<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于博客</title>
    <url>/2025/06/22/RDM/</url>
    <content><![CDATA[<h3><span id="碎碎念">碎碎念</span></h3><p>终于把博客搞好啦！大概以后会经常拿这个网站来发东西了。评论功能和联系功能都已经上线。学习笔记已经全部公开了，一些随笔会在筛选后公开一部分。</p>
<h3><span id="致歉">致歉</span></h3><p>另外需要声明的是，因为公开的往往是我直接在课上记录的笔记，因此可能会出现老师讲什么我抄什么，导致我的某篇笔记可能与某篇文章的思路雷同。由于文章太多难以对其中搬运的部分一一溯源，只好在这里提前致歉。如若您的确发现我博客中某一块内容来源于您，请联系博客，我会尽快作出修改。</p>
<h3><span id="致谢">致谢</span></h3><p>感谢ycmgg帮助构建了博客的最初架构。</p>
<p>感谢djzgg帮忙支持了博客的xypic渲染。</p>
]]></content>
  </entry>
  <entry>
    <title>逃</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E9%80%83/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#一">一</a></li>
<li><a href="#二">二</a></li>
<li><a href="#三">三</a></li>
<li><a href="#四">四</a></li>
<li><a href="#五">五</a></li>
<li><a href="#六">六</a></li>
<li><a href="#七">七</a></li>
<li><a href="#后记">后记</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>你所说的曙光究竟是什么意思。</p>
<p>——海子《春天，十个海子》</p>
</blockquote>
<h3><span id="一">一</span></h3><p>等我迷迷糊糊睁开眼时，阳光已经从窗帘外透进来了。</p>
<p>我裹着被子翻过身，想不起刚刚发生了什么。今天是周几、现在是几点、为什么我在这里躺着，突然一点都想不起来了。我半睁着眼盯着天花板，看着透过窗帘撒在上面的一点点光纹——像是漆黑的世界的裂痕。</p>
<p>我刚刚做了一个什么梦呢？一定是一个特别美好而温馨的梦，因为我现在脸上还带着笑呢。梦中好像有一个女孩，我还记得我在梦的结尾向她跑过去，拉起她的手。可她长什么样子、声音如何、我与她之间发生了什么故事呢？她又到底是谁呢？我一定认识她，因为梦里我对她有一种那么熟悉的感觉，是那种久别重逢一样、并且深信命运的指引使我们相识的感觉。</p>
<p>可我为什么现在什么都想不起来了呢。</p>
<p>我起身走到卫生间，站在镜子前，我打开水龙头，捧起一把水抹到脸上，但这水为什么一点都不凉，而且缺少水的质感，我像是把某种丝绸状的东西抹在了脸上，然后它们又缓缓一点点滑落了。我忽然想起来我现在脸上应该挂着水珠。所以我抬起头，看着镜子中的我，我的脸上的确有着水珠的，它就在那里——可我怎么看不清我的脸，镜子里面只有一个人的轮廓，依稀有黑色的头发和黑色的眼睛。</p>
<p>我感到害怕了。</p>
<p>我逃出卫生间来到客厅，几乎占据整个墙壁的窗户将屋子里的一切照亮。但为什么天空上面一无所有。我只能感受到那是一片天，是光进来的地方，却什么都看不见，没有蓝色也没有云，没有一切天空的质感。</p>
<p>我转头看见屋内的东西：茶几上的水杯，书架上的奖状，小时候的玩具……我突然意识到少了好多东西，我家中远远没有这么空荡。可我想不起来少了什么，想不起来。</p>
<p>我发了疯一样跑到镜子前，拼命地盯着镜中我的模样。我忽然想到我可以盯着自己的眼睛看，这样我的脸庞会在镜子和眼睛之间来回反射，我就可以借此看清自己。</p>
<p>耳边传来闹钟的声响。我看见镜子从我的眼眶中碎裂，其中反射的千万的我立刻爬满了碎纹。</p>
<h3><span id="二">二</span></h3><p>我从梦中惊醒，伸手向旁边一下关掉了手机闹钟，仍然因刚才的噩梦而惊悚。等我稍稍定神，打开手机，今天是周二，现在是早上五点五十七分，我应该起身去洗漱，然后去上班了。像是从前无数个日子一样。</p>
<p>我坐起来下了床，不要打开第一个格子，从床头柜第二个格子中拿出袜子穿上。然后走到衣柜前，挑出前天晚上洗好的白衣服穿上。我起身走出房间，转两个弯来到厨房，从冰箱中拿出面包和番茄酱，放在盘子里简单解冻。然后走去卫生间。</p>
<p>看到镜子的时候我又一惊，有点迟疑地打开了水龙头，这次流出来的水很冷，水流很大，看来我的确彻底从梦中醒了。这是毫无疑问的。</p>
<p>等到一切收拾妥当，闹钟响起，此时是六点二十分，我该出门去坐地铁。</p>
<p>地铁站离我家三四分钟的路程，等我过了安检来到站点，闹钟再一次响了，地铁也一同进站。我从兜里掏出手机关掉闹钟，现在是六点三十分。</p>
<p>上了地铁，我带上耳机放上音乐，然后闭上眼靠在椅子上。等我昏昏沉沉将要入睡的时候，闹钟响了，随之是地铁提示到站的广播。我关掉闹钟走下地铁，现在是六点四十五分。</p>
<p>从地铁站出来会经过一条走廊，走廊上挂着康定斯基的《Picture XVI, The Great Gate of Kiev》的照片。穿过走廊就是扶梯，一年中的某些时候，我借扶梯向上攀升的时候，会看到太阳也在升起。盛夏的时候我会迎面撞上最最刺眼的阳光，以至于我不得不举起手遮住眼睛。可过一段日子当我已经养成了习惯，却会在到达地面的时候，放下手才发现日光虚弱的盈在周围，我才终于知道夏天已经过去了。</p>
<p>走出地铁站向右拐，就是我上班的公司。等我坐在自己的工位上，闹钟会在七点最后响一次。这时桌上往往已经放好了今天的工作内容细表，这是我前一天晚上早已准备好了的。</p>
<p>如此一天。等到晚上下班，闹钟响。我指定好第二天的工作计划，闹钟再响。走出门来到地铁站，再次经过康定斯基的画。买完票来到站台，坐上地铁回到家，我和地铁一起穿行，穿行在狭窄的不知何地的空间，穿行在看似无边无际的时间。</p>
<p>五点五十分闹钟会响，车会到站。</p>
<h3><span id="三">三</span></h3><p>第二天我又被闹钟吵醒。我伸手向旁边一摸，却摸了个空，一阵寒意猛然涌起，我立刻清醒了，坐了起来。手机仍在床头柜上发着声响，直到我抬手将闹钟关上。</p>
<p>起身，不要打开床头柜的第一个格子，从第二个格子中拿出袜子穿上。走到衣柜前，继续穿上昨天的衣服。起身走出房间，转两个弯来到厨房，从冰箱中拿出面包和番茄酱，放在盘子里简单解冻。然后走去卫生间，将脸浸没在冷水里……</p>
<p>吃完饭，闹钟响起，现在是六点二十分，出门去坐地铁。过了安检来到站点，闹钟响起。关掉闹钟，走上地铁，我拿出耳机，靠在椅子上闭上眼睛。</p>
<p>我迷迷糊糊回忆着自己早上做过的事：起床，穿衣，准备早饭，来到洗手间，看向镜子，曾经梦到的那个女孩长什么样子来着……</p>
<h3><span id="四">四</span></h3><p>我突然惊醒，那个女孩就在我的眼前，笑盈盈地看着我。我看向周围，地铁已经到站了，身边的人都在往外走，我拿出手机一看，现在是六点四十三分，地铁早到站了两分钟。我意识到正是这个女孩将我从沉睡中唤醒了。</p>
<p>那个女孩看我醒了，就拿起她的东西也下了车。</p>
<p>我跌跌撞撞走出地铁。她是谁？是和我一样的乘客么？我们从前认识？不，我们根本素不相识，可能这只是一个陌生人无心的善举……可陌生人又怎么会知道我要在哪一站下车呢？</p>
<p>我的闹钟突然响起，我连忙从兜里拿出手机关掉。现在是六点四十五分，我在不知所措中向旁边一瞥，看到了康定斯基的那幅画，那凄冷的太阳，以及那么温暖的月光……</p>
<p>我在那幅画前浪费了太多时间，因此我刚走进公司，闹钟就不合时宜地响了起来。一路上的同事都在抬头看我，而我只能匆匆忙忙地走到座位前坐下，关掉闹钟，现在是七点零一分。</p>
<p>今天一切好像都与往常不一样，也许正是因为我早上晚到了一分钟，我几乎没有准时完成一个任务。总之终于熬到下班，闹钟一响，我却不像往常那样制定第二天的任务表，然后再收拾东西。我关掉闹钟后坐在椅子上，闭上眼睛，一点一点向后仰去……我忽然又有一种失重感了，我知道再往后仰去我就一定会摔倒在地上，所以我连忙睁开眼睛立直了身子。可稍微靠在椅子上，应该没问题吧，没问题吧……我又闭上眼向后靠去，脑子里一片昏沉……闹钟响了，我意识到再这么下去就赶不上地铁了。</p>
<p>一路跑出办公室，跑进地铁站，路过康定斯基的画，却来不及再看一眼了。买票，等车，上车，在车上玩着手机，实际上什么都看不进去，只是一直盯着时间，直到手机上的时间显示为五点五十分，闹钟响了，车也准时到站，一切好像如常。</p>
<h3><span id="五">五</span></h3><p>我回到家里，站在洗手台前，盯着镜子中的自己，比梦中的场景清晰得多，而且我眼中也的确有一个我的倒影，因此我敢断言这一切都不是梦。但我又不明白为什么，这一天似乎经历了太多太多，而且好像完全不寻常，但我又找不出奇怪的地方。地铁到站早了两分钟，毕竟不是什么很值得惊奇的事情。再精密的机器总会有失误的一刻。我的意思是，这一刻是总要来临的。当地铁如此周而复始，在每个精准的时间到达站点的循环中，只是两分钟的早点也许就逐渐地被写在命运中了……我忽然想起之前有一天，我出门才发现我把眼镜落在了家里——那一天足足七点十分我才到了公司。那天我走进公司的门的时候几乎有些战栗，可我最后还是一步一步挪到了座位前。可后来还是什么都没发生，那天大概是——也许两年前，也许三年前。总之，这件事后的第一个周我总是胆战心惊，每天晚上睡前都仔细检查一遍闹钟，调一调音量键，并在走前仔细检查自己的随身物品。可不到一个月后我就将这一天的经历抛之脑后。事实就是这样，今天也是一样。而且今天还并没有影响什么，也许一个周后我就可以忘记这些。</p>
<p>睡前我又想起了这件事，我忽然有些虔诚起来，我想如果今天的确有些不同，也许我可以在梦中得到一些启示，一些可以被缜密的心理学分析的细节。这种信念越来越坚定，“只要睡着，我就可以在梦里得到答案。”我反复这么想着。</p>
<p>可这一夜似乎没有做梦，又可能做了，但我忘掉了。总之当第二天五点五十五的闹钟响起的时候，我什么都想不起来。意识到这后，我暗自觉得有点遗憾。</p>
<p>我坐起来，外面才刚刚有点亮光。该收拾收拾去上班了，我想，然后我打开了床头柜的第一个格子。</p>
<p>等我意识到发生了什么的时候已经太迟了。</p>
<p>格子里面是一面爬满裂纹的镜子。</p>
<p>我瘫坐在地上，突然认识到这可能是个梦。所以我又站起身来，拿出那面镜子。但它反射出的我的面容是如此的清晰。黑色的眼睛，黑色的头发。</p>
<p>我拉开床帘，外面是蒙蒙白的天空，看不见太阳，可能被楼挡住了，我看向窗外，又看向镜子，看向镜子里的自己。手一滑，镜子掉到地上彻底摔成了玻璃碎片。</p>
<p>我低下身捡起一块碎片，然后划向自己的手腕。可我什么感觉都没有，手腕上面也没有划痕，我忽然疑心是不是当我的手捏着碎片划向手腕的最后一刻向后退缩了，我忽然意识到我刚才也许正在幻想一种近乎狂热的痛苦，可这并没有发生，就如同我没有真的用玻璃碎片划开手腕。</p>
<p>然后一道裂纹在血的晕染下逐渐浮现，像是一只暗红的眼睛。一股温热的血像水一样流了出来。</p>
<h3><span id="六">六</span></h3><p>我的第一反应是，手腕很疼，很疼。但这疼不足以让我感到后悔。我想起来小学科学课的实验，将两面镜子对放在一起，它们便会无限叠加下去，放在镜子前的东西——也许是一块橡皮——就会被困进无尽的牢笼里，连同它的无数个分身一起，避无可避，逃无可逃。</p>
<p>血还在往外流，在这不亮的早上像是黑色的。</p>
<p>我艰难爬起身，扫落书架上的奖状，看向后面藏着的书——其中有很多还是全新未开封的。我把手腕尽力侧过去，怕血流到书上。我感到一阵头晕，摔倒在地上。但我还是强撑着意识爬起来，地上全是脏血和废纸。我忽然想看看太阳。</p>
<p>扶着墙，一点一点地，我向外挪着步子。走出房门，转一个弯，来到客厅。阳光刚刚好洒进来，照在空气中的上升的尘埃里。“原来现在正是盛夏”，我想。</p>
<p>我向着窗户跑去，才跑了两步就摔倒了。我抬起头向窗外看去。</p>
<p>天空是淡蓝淡蓝的颜色，太阳从高楼后面露出一个角来，小区里的树和花全被阳光照亮了。我看见天上飘着几丝细云，小区里的人工河里刚刚放上了水。不远处有位母亲正推着一个淡黄色的婴儿车。</p>
<p>我用完好的那只手撑着地面想要站起来，可我忽然眼前一黑……等我恢复了意识，我正坐倒在地上，眼前是我一路爬来留下的血迹，将地板染成一条红黑色的河。</p>
<p>地上好冷。</p>
<p>我正要闭上眼睛的时候，却听见了有人敲门的声音。</p>
<h3><span id="七">七</span></h3><p>我拼命抵抗着睡意，是谁会在此刻敲我的门呢？</p>
<p>老板、邻居，他们一个都不会来的。物业和收费的人绝不会这个时间点来。来的人一定是那个女孩。</p>
<p>对，是那个女孩。是她把我从地铁上叫醒的，当时我还在沉睡，全然不知道自己要坐过站了。当时我还没反应过来，连句谢谢都没说，她就走开了。她长什么样子来着？我突然觉得自己好可悲啊，临死之前，连一个女孩的样子都想不起来。</p>
<p>不，我要知道她长什么样子。我想要知道她叫什么，喜欢些什么，会不会也喜欢康定斯基的那幅画。我想要和她相爱，和她白头偕老，和她一起在公园里坐着，看新开的小花，新来的小孩子。</p>
<p>我撑着地，想要站起来，但我的手已经虚弱地支撑不起我的身体了。我不甘心，所以我将那支还在流着血的手也按在了地上，用力一撑，这次我感到手腕传来刺中心脏的痛了，但我总归是爬起来了。</p>
<p>我站起身来，跌跌撞撞，跌跌撞撞，向着门跑去。我以为我要到达门口了，直到我被我自己的鞋绊倒，一下子又摔在门前。这次我彻底站不起来了。</p>
<p>好吧，我想。我再也无法知道她长什么样子了，我无法得知她的爱好，无法得知她是不是爱着我，无法得知我们之后的爱情会不会一帆风顺，还是吵吵闹闹，还是终于分道扬镳。</p>
<p>好吧，我想。这一切终于要结束了。</p>
<p>可此时闹钟突然响起来了，我听着那刺耳的声在我兜里响起。我掏出手机，将它狠狠摔到墙上，它于是终于彻底不再作声了。而此时敲门声又响起来了，比第一次更清楚，更清脆，更加的近在咫尺。</p>
<p>我的手在一旁胡乱地摸着，想找点什么扶我起来。手臂在空中挥舞着，最后只抓到了自己的睡衣。我十指狠狠地扣着自己的衣服，用力站了起来。我的血全抹在我的白衣服上，形成一幅扭曲的图腾。</p>
<p>我抬起头，正好对上客厅的阳光。太阳已经从楼外完全地升起来了，一路上的扭曲的血迹被照得金红。</p>
<p>我闭上双眼，想象着自己现在的样子，黑色的头发，黑色的眼睛，站在一片腥红中间，眼前只有太阳在缓缓升起，升起，升到天上去。</p>
<p>那个女孩长什么样子呢？</p>
<p>我睁开双眼，茶几上的水杯折射着光线，柔和的尘埃在光里飘着，洋溢着整个屋子。</p>
<p>那个女孩长什么样子呢？</p>
<p>我想起曾经读过的诗歌，看过的小说，曾经见过的人，经历过的事。我的眼角渗出泪来，但我看不见，也许我的眼角渗出血来。</p>
<p>那个女孩长什么样子呢？</p>
<p>我将手按在门把手上，门外已经听不见敲门的声音了。也许她走了，也许她从没来过。</p>
<p>我突然感到恐惧而不敢开门，或者因为双手无力而按不开门。</p>
<p>最后我抬头看了看窗外，天空是蓝的，上面一无所有，但是飘着云彩。</p>
<p>我的泪落在地上，散在血迹中，在一片深红中点出几丝粉色，像是点在血液中的云彩。</p>
<p>然后我打开了门。</p>
<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.857d4adbadb26a69e5a3a68f005781f7?rik=jQ8XQX9xF%2bRDUQ&amp;pid=ImgRaw&amp;r=0" alt></p>
<p>（写于2024.04.30）</p>
<p>（2024.05.18修改）</p>
<p>（2025.04.21再改）</p>
<h3><span id="后记">后记</span></h3><p>马上高考了，先祝大家和我高考顺利！</p>
<p>《逃》这篇小说企划了很久，又是中途易辙的一篇。原本想写的故事是从学校逃走，其实那个故事扣题会更好一点，最后的割腕也会更自然一点，下面贴一下之前写的片段：</p>
<blockquote>
<p>我好想逃。</p>
<p>我们班的老师正站在讲台上，或者说站在比地面高二十厘米左右的台子上，拿着粉笔在黑板上拉着，头顶是刺白色的灯光。白炽灯下闪着在空中乱旋的粉笔灰。</p>
<p>我坐在人群中，坐在桌子下，双腿稍一移动就要碰到桌子腿——我试过用力地将腿向两边舒展，可这样并不能将桌子下的空间撑的更大一些，而且还要碰到旁边同学挂书的袋子。我的桌子上摆满了一会儿下课之后要复习的资料，它们在左边堆成高高的一摞。又有几张这节课要用的卷子铺在面前，它们占据了桌子上最后一点位置，让整张桌子终于被黑色的字和白色的纸所填满。可是桌面的空间狭小到不能展开一张卷子，甚至卷子的下端要悬在空中一段，在头顶不知道混杂了多少尘埃的白光下，我可以看清它粗糙的边缘。</p>
<p>我的笔袋放在桌子前方，如果我挪动卷子，那么它现在立刻就会被碰掉到地上，里面藏着的刻了几行小字的笔，藏着的留作留念的纸条，藏着的朋友对自己的祝福就会杂着笔袋中混入的橡皮屑，叮当一声散落在地上。全班原本的沉寂变成安静，所有人都盯着我。然后我站起身来，穿过自己的厚重的挂书袋，走到桌子前，蹲下身来收拾自己散落的东西。会有好心的同学来帮我，然后我对他们说声谢谢，站起身来拿着笔袋，再次穿过挂书袋，回到自己的位置上。</p>
<p>我想逃，想现在就冲出教室。但我怕冲出去后同学异样的眼光，怕老师在身后严厉地呵斥，更怕我一听到那呵斥，于是就两腿发软了，爬回教室，用双手在地上撑着走回自己的座位。</p>
<p>终于有一天我决定行动起来，那一天晚上我花了半个小时的时间收拾自己的东西，我清理好了桌面，整理了一大摞卷子，将所有的教科书分门别类地摆放在了角落里。可第二天，当新的卷子发下来，我又手忙脚乱不知道该把它们放在哪里了，因为哪里都是满的。当老师忽然又要从好久好久前讲过的卷子中翻出一张来讲时，我又不知道该从哪里找到它了。而当我晚自习收拾出比头还要高的今晚要完成的作业，下课时却总共做了几页的时候，我还是不愿意把它们收拾起来，而是仍然堆在桌子的角落上，知道某一刻我终于认清自己是没有时间完成它们了。时间日复一日的过去，我原本所整理好的就又归了混乱。</p>
<p>发卷子的时候，我喜欢用两根手指捏住所有卷子，然后从最上面抽出一张，纸张会和手指摩擦出轻微的声响。直到有一天，我的虎口略微向前了一点，纸张仍然发着轻轻的响声，伴随着虎口上刀割的疼痛。</p>
<p>我抬起眼，举起手，看着上面的伤口，那是纸的带刺的边缘在我手上锯开的，像是木匠锯开一根死了的柴火。锯开地方的皮略微舒张，露出下面粉色的肉，看不见血，可能是因为伤口浅了一些。我试着轻轻挤压伤口，然后伤口破开了。顺着那道狭长的口子，一点血渗了出来。我怀疑这图案我在哪里见过，随即意识到我小的时候画人的眼睛就是这么画的：一条长长的向上弯的弧线，再加上一条长长的向下弯的弧线。</p>
<p>这时我突然意识到自己不能再这么细致地观察一个小伤口了，时间宝贵。所以我把卷子传给后面的同学，并在心中对他们略感了一点歉意。然后我低下头看上面的题。做完第一面，当我想要翻页的时候，大拇指略微外展，于是原本可能已经愈合的伤口再次撕裂，我又感受到了那轻微的疼痛了，而且仿佛听到了那轻微的声响。</p>
</blockquote>
<p>原本的故事后面，会转学来一个女孩，会与主角相知相爱，直到他们的爱情被发现，女孩因为反抗而被开除，可这时的男孩却懦弱地什么都不敢做，也什么都做不了。当他在家里想起女孩时，他痛苦地选择了割腕。在他将死之时，他想起了他和女孩之间的点点滴滴，女孩在这时敲响了他的门。</p>
<p>这个故事我也尝试写过，甚至一度接近写完了，但最后还是放弃了。原因有很多，其中一个原因是，我突然开始构思另一种可能的剧情。</p>
<p>原本我想写的故事，是一个神启式的救赎故事。一个近乎天使般的人拯救了一个懦弱的可悲的人。我其实在现实中也许也是这样一个懦弱的可悲的人，什么都做不了，只能一次次反抗又一次次被迫臣服。所以说到底，原本的《逃》只是一个幻想，一个希望。</p>
<p>但后来我越发想，幻想的越多，越来越觉得这种救赎是飘渺的。也许真会有这么一位善良的骄傲的女孩，但绝不会爱上一位懦弱的可悲的男孩。总之，男孩首先要做的，是<strong>自己救赎自己</strong>。</p>
<p>在本文中，“我”有着无法逃脱的宿命（闹钟/时间），有着不堪回首的过去和几乎崩溃的精神（碎镜）。这一切看上去，这种禁锢是无法被打破的，就像文中说的那样，这座囚笼逃无可逃。</p>
<p>一次救赎，一次他人给的救赎，会像是一滴血落进一杯白水里，瞬间绽开奇美的色彩。但等血扩散完了，就还是只会留下一杯红水。同样的平淡，毫无生机。</p>
<p>文中的“我”非常清楚这一点，他认为宿命是无可逃避的，即使一时将它改变，也只不过从一条道路走到另一条道路上。其实他到最后也仍然是这么认为的，其实我现在也仍然是这么认为的。</p>
<p>但，走到另一条路，会意味着更多的希望，会意味着见到从前从未见过的风景。也许人在跳脱当前宿命的时候，也可以尝试选择自己的宿命。</p>
<p>这就是最终的结局的寓意：一次重生，一次新的开始。门外当然不可能是女孩，但总之，男主会被送到医院，会得到救助，会迎来新生。他也许会去找到那个女孩，也许会表明心意，也许会在一起，也许会白头偕老；也许那个女孩从此和他再无关系，他将自己的爱投入生命之中，直到遇到真正的那个，能和他永不离分的人。</p>
<p>总之，比起困在当前的命中，他此时拥有无限的未来。</p>
<hr>
<p>我其实一直想为自己的高考写一篇小说，你可以把它当作我高考前冲锋的号角。</p>
<p>可能很多人都觉得我执念太深，其实我自己也是这么认为的。在经历过种种后，这执念本身甚至加上了许多理性的束缚。我觉得自己一直都是一个追求幸福的人，哪种选择可能走向幸福，我就去走哪条路。但真正选到死路之后，我才发现原来世界没有那么简单，不是真的，只要有理想和爱，就什么都可以做到。</p>
<p>起码，我改变不了别人。我做不到让一个不爱我的人爱我，做不到让不理解我的人理解我，做不到改变顽固不灵的人的想法——或者我自己也是一个顽固不灵的人。我也不可能，不可能像所有童话故事一样，等到救赎自己的精灵，等到一股强大的外力将我现在的所有囚笼击破，等到一位天使将我救赎。</p>
<p>我很喜欢霸王别姬的一个镜头，并且几乎天天引用这个片段：那就是当小豆子和小癞子看京剧名角的表演的时候，小癞子放声大哭：“他们怎么成的角儿啊，挨了多少打啊，我什么时候才能成角儿啊？”</p>
<p>后来小癞子自杀了。师父对小豆子说：“人呐，得自个儿成全自个儿。”</p>
<p>所以其实，也许从来就没有什么天使，没有地铁上叫醒你的人，没有帮你打破闹钟的人，只有你自己，抓着自己的衣服，在血泊里爬起来，向外张望撒进来的阳光，逃离这所囚笼。</p>
<hr>
<p>我有的时候自嘲，说自己每次想要改变的时候，可悲的事情就会一件接着一件纷至沓来，仿佛是命运逼迫我成为行尸走肉一样。</p>
<p>好像总有人在充当命运的刽子手，一刀一刀将我活剐成一具骷髅。</p>
<p>我有的时候甚至以为，救赎是一个标志，是命运终于允许我拥抱幸福的标志。只有有了这种允许，我才能抬起头来生活，将自己从无尽的悲哀中拽起来，看看太阳。</p>
<p>这个标志是什么呢？也许是一次巨大的成功，是时来运转的惊喜，是一个爱着你的人，无微不至体贴你的所有。</p>
<p>但后来我明白了，原来救赎其实是，你坠到沼泽中，全身都被脏泥淹没的时候，好像听见有人在叫你。你突然睁开眼睛，看了看太阳。</p>
<p>原来太阳是那么耀眼，原来周围的叶子也可以反射太阳的光，原来空气中的尘埃都在光影中浮动着，绽开着。</p>
<p>你想看看是谁在喊你，可你无法动弹。</p>
<p>你拼了命向上爬，即使口鼻中全是污泥和脏血，即使四肢被厚重的泥土压到畸形。原来还有人在叫你，原来还有人爱着你，原来这个世界如此美丽。</p>
<p>你用尽自己全部的力气，像是生出了额外的羽翼，你从此不甘心被活埋，被忘记，被裹挟在地下沉睡成百上千年后化成黑水。</p>
<p>你向上爬去，终于会爬出沼泽，会带着一身的伤痕站在地上，四处望着是谁在呼唤你。</p>
<p>至于到底有没有人，至于你愿不愿意相信刚才这里存在过一个人，至于你愿意相信她是谁，这完全取决于你。</p>
]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>谶</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E8%B0%B6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="69814eefad2cb4303353533a986e6e713f9359c7ea7999c23e58de2555f6a76c">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e7aa3c5a6384741e6edec61be5e2ce4effd178440d2739930d957ae61218fd26817887255090ac4a40336c354788a2bae2e43639273481fb3190c449df4e30a028fc485dab6b463c4f46b54d8a179b329bf99861183942714b77ff24c5ae09a419bf96f8d57b01828163b56d4e18e3f4969b90e6ad4e1472b9420049be7825fbab5210a66e9cb846ece5f8bbb16a60d523066da4b5e77b19827bbd31c173d5288e1ad81d2aa0de1357f6dac71985f16e5a9bff9e91c3de1cd71934706148e9cae98c40cd67ebce972518cceb3d3dcaa90e03db4c338d33fc3269daebf61ccbda07ee40a4564813c4ad0cb536530effcbf12433de0a61933b6fa8f01b43ef4529414f29c24d9a49e319df12191b1bcf69f51e29abf32a4ac3d6aa226869d70fb800d231bcc3815bff73b3834f8e48ad9cd1d7db5d910cf6e8e3a9a9e89f9adb1eb8701298e7e00fd43354bf673ed690a3e7fe0d633e540cd081cebffb482336163885cdfadf82a5c7e7c5f6b24daafc93d7025b8913708f2476e781c3e11bfd0722f90e1c7dc2a5fe547c8b527e9edd0822fc0b563c367c1a0604ffc0b360eea4b4a46783fa23aa8749222c67104c77e5736ab92e1fd44d0212baf370ed6ee98e9045125c55a6dd5dd9b25b2906c4ef4ca2ac9f653b34bb42337ce83f998d350117f1282f9dd744f01b40141db62265c874613417c4025942cb19eb4c48b8ea44315f96555aff416ef45e2e090abe49ce437e138ddaa0832986e3cb445e56f01631a278d0e6c608123fb3de028f1d173ee546d88b85a6954247a864570aded4b9892f53a37a96334e501ec23932062820d5d6fe3ee27a9a1ae291196bd48607898dc8c5a3d9307b8a28d419ef6df01ed1eb34e99bccff452be91c2a4ad7ea85086a6349aa62a60a36268086f1ab8e604b38d417b822d07deddb317a187e9a2866c76b8818abc0aec7261490cd164445514e0350ee31fcab389fa158e46295146bfa47b9671eec2138909b6d15d92b8aac4adeec6d5c8c04c588a72db774572911be3b16edcaa791d2b69d1e915902a0d521adbd99edfe551b3bf3d058d93752c8f195b633823725a9e760d2ba8d14bf889f08953148eeb52a33f42933a56225dcc5e9b1eaffa1ee2f86ff243c56e7aa13dbe0792c63e009ea8c0a55289201ecaf9315950f5d80bca35af11e5163158f57beefb603c6b8be9a06d6af40b45cc66186026bcf0a94b0bf7793ccf8b0e6ea3485e82184d8e4266f3b8d00823a19b2069eeeb29dca8324cf87e78249296b08a5d2f4b79830f4fc34ba56d41bbec6ffc823f77496f0f452260c35abf655bb059378b200b2eee5fa58c06003d959f7c313e67a016125379f9ecc29557418f46e94b8d9d18d8ffd6b3a1d092c124baf8a39225cf9144bc917ccecc60e585192ad97417f1b9e5a40cb93e6af37b774e7905bf05748babfc521c0299f4fb22785319c0ab7e633e6bd00874b1a5d10ff597e8e69c6a8d98bd2db12d83d527b7f4440a7c922e50c6c4cc27a66d437e3d86e55fb059c4f20f2566240f7a8d63adbbcf5d4e0fe18c33be96c48e7f28dfcba4c007ae0d2365aef8e15d1bfee49630e73548d68f15336d0835c1ab9ae576f77de83b94461177f92f5ee889fb67e40e82bba0c9e0ed949bf9a6e7474d53ed03e685f6e6004c3e4fa43e61d4470cb5b429605f59adde59ec4cfe87eebde7f6aa29ad7266062f5c99e7f6ddb9d48ed29dfb8106efdfaa3450b74460e78633e6f862e6386c14ef43cdc29b39ec67fb69c9fc14c98b70371bf66a33e636c9fbb5df356a9b01e3b4ac1509c7e7821f212b6c0e2ffdb7b4b6eac11b7e06bf6e7cf98d947c724f6397408f4c2ca065e063c985dc743539021dc8e839e041aac36d9066155410c5efbf4fe68e33caabebdb3a2f22c080d085920c4facfabc9ad28255e616618bfbae0ab818f8e47069713156038e52c72a93efd0dc1ff2e3fe968b116bd42e38286f3eba838b6aec313b68818b092e18464b0eeb3e451a40bd99f4c94f3c9a06cb119c838cce8f17ba90f42f3751dabd5417034b858329632e2c47f9a7606b20a8ee3571f1e7bce6f7267577417e88fd842a027f3e45592881413dd34cf39126b4cdf1556f18c4b15182ffe5c871c3c0484b293a7f944ebbcfc078b791adf41542bab0df62515a39d43b3358f8d8a3ee5744a53729ee0be90cfe0be3ee2d38fcb191021f67006671bedc18908a16d2e773feb1853008fda9c21f94bf7aa8780f30949666ac4049fb691ffd41669235d5057d6d252ace444ea438e93762569f8d74d9d317a2be677f475ab2b6153c31f9bb20255a82ccc2081725cfe7173469de3e86891abd9f83233290d614cde0b4e4de013095ace4390012a8217f5f61f8891658e544de42deebdf4d7c75478b1d94bebce352be66f82226e83f176b40f9b7ada2bfdfa8ae16a71de4dc9057f37f790a257afc974ed28bc67de76c3e91aac409b0b2c514cc4cfe19b83ec7f603220c3155345d0732fea17e025c397f49010cc8c1fc47f54aede08584e45669b6058e176bc2c56896eeea9fea9a499c097c5d8ef8304d13fe9a80a1a43227295799f81e1de8b985f8ece42346344e322e596fd1a0e380b15785dcea63facfe33dcd5414f8cd8ed15ebaa9c295ba49987625545c91a555615f6b87bcfeefb21675d341b7ad6dbcbf376c991297286d5dfb9fc1676247e82ab2ba4d5419d9112ba21b146a1775bdc1561f8cbbfac1c3bd11959c0dae96b3b5801598147c5d4e73cd4407685785030b537096234020345eab30e1d5c6cb547d1079f873e7b9e133a4c9ba1ada0df68dcb5c951e24dfcfa9082574b829dc8e86f2097855756797d58bdf4c9ef9a160babc71954a8794ecbb237b731d71b6327ef1893cd1e5fef29aa492628c3433fa1f4933ade473796f413ea3b8d1a1fb383c48e16aebd2ab8e1f384011cc096df007a773ef8cc0fb47898ad7a0da49ce9a8785f8f52673e13cc43949c59c896b8c512ab84474c6d88665e90799441c2022b4a828d1ebb68a7ab69170c47af1397baf931c3750d4abff0805916b73d1102dc727a122eb1156af99bede7131315751119d7e20a060b71b2f58608dd50b1510e1cc368b0b0e0767565e0fc5ca58cec5463407aa356a40c7e65b771f4cc1951526fa4ec6daf46024a48d12a2b35ea624f328325655a05c2d37d2b8549f6f8af998c4d228575d6297d9cecd90298cc3ca1298bf1f3d75e05758e0a474535ba9745c893f3814adee0961f28eec98eae159fa843a3573e70722a8cd9efd6170bfb88ee7ad21761d17c0a967c382c976b190071aecf19035876189f4d65303a27e3785b279b3db6ae7b0dcacb5a7a30b67b47eb1c0c34e974f7c8a9ebb193f3a7b055679ac09620a034168665d255dd428d5ecb553da31befe60d982bf3b844f032da9b535c6213edf76b5d5003a184a9f7f2c92ea305dfb31b665554f0edcfda11b792748c58645c0ec0bd794fa11d0bf6beee25d6217d98d3ad2963804ea1817b00192c5e888ad4b21f8e318db713df06f7c16149e58d4e187634ea661564741a0da34411b621833beae222b56d327d4096330e6e4db3ce035050f9d919ee7707c59d67a15ccd82b307bed8bf4e877368b0ed9b6b1f8a687a94272495167a653d843691aec69599efb67ae39d59c71e023fd4ba89bb52b30bc58d82e2f62896354ca830aa66130c7cd0b36a109db4008bed64d28312fa0970be2ab3141d3c0b4836ac6f335450018ae32a649ddb3ffdf8ce053a2d631654f5b8e841258785e00b9fd926b69c2ced8c6333419c17bdcb3cf406b6a5d4f4a7005d8265ae5667aca993974df87ecd717f6b8adf6c3d8c519e511499df848a12dc77e441bb94aaf06941d04aa10e3fa8adcaa9ff5020b15f048dd8c78a2cd1911375e984c2e387e8f3070cf44d03ab4f2ad7279fe7cca2e1d18519d23dfc31d4acc806b973b05129f0bea9bb9eb6478a40f27920cd544b395af7c7326c41b070014f47f294acdac5fff5587855f4463781200e21077a76c64385a7d42a19933ef78964efb9d558cb739d8614df8d268c2f15b0b21de5096ce41fa27bed36d59faef673d5ca3c864673ebd92fd94af1e38ae1ad30f09598913ccd7ed8d86cd38dd6c3da21ace457311f688d9cbe951123ab01842be58375f8c054cebd4f5188510eb4cc99ec7fa9db2e43ceb37f9a8205cb9168626d9170abac8864a2d9c9a4c60e599f147d74ce039b5c4c6a4976be0fcdf89a2755c621ba9414310d3cf11be9b0deeb03d80c0b937ad45b913dbe55b11c1a8b1691ef129237ffaaa8d9078cf9af17f596263448b57f104701d51dd3dd52dc7f964fc1a7ccdd5186b7ff193eec6092b4f5fb884c47d6986e8d8fed32241840516becb9f01ca0bef5d02077e4c05fbd02cc9b9a3deee26adb954e0292b9ee580641e19f22fdadb827bb1badf873d4ace2a6541a32c474253760d01bdbd44dacfcc214abf83e7057716957ea9e030bd449171f1092f0169e38fe9fc47602ef613fb429e284811df64bee059033504f2fc37b4cd112a8683185e3577b2168797e8b62dc151c731ca58beb46e3d72fb56ab17d47b480a3f3a4f5e4012ba3be18d1ac15d53c5ee821596ed7f6e6d22b834c099abd791d163775d4eee2befbd3facd140c3acc7f224d68864a09f91ddacaaae123b84071fa6674261b06c313ce0f6faa5220c78cf7b0543977c01a787e92b0e007caa558a5e7bdfe9a40da48ba2636668efbe843b2aef4f628c57865544cee54d8ce4c1387b0d6fdd91ba183aff00d91bc8f0f9f7123d2c1517127d43e3d564e3ff8ce08035091d5555bc1580ea2da03d9c4dfbfd4744cca8e7979715b0402994abaf678f08abea5186f07e1ef2f29d500cda876223ddde27bfbebd5abf0fe2e363cbe0f8325add02eb1b701d42903abae046582753ada701b96b5022c328f06998df9e6b6703f6778e6f5ee83eed4d93e61e0366b38e65c2ddba1262a40f688389d87d9655f3b51a2a09acb6de91c4b7f2e73c5efab0bfa1bd2c6a467d93ec47c5316d3f308de0064b3cf5acaaff528581ccd573cd4ff2cc1e83943a90b7cba78a75f02982f58ac98d2855c97fb3f8a32e8066d2d66150fc254544b2176ea167e2a1b259749e92f11ca2dcb76976fb669ba192a7a7d32c4ee2c618a2eb4be41cf3ac46fe7f78cd19bacbecbcdab3bb793f3bf66acb559207f2d8c015c4d72ff8478f1e2d5d84690ebf3ed55d5c7eca152078e1d0c50e0967f8f7fcec92fcbcec9b0c62b71e4f9d6bf0fd0f0bb48e9e9a28e9cadf771f3181d45e9506879ece417708b8ac2948d4b0db611028b7bca85f4346a9356bca259ee30cd4eb63226104026aac5ba84e1acacf02b1e066f899506733bd78b88b0bf9540794a0cd79af3e596dca82fb2c58ab7247e85ab538cb421a2b9ad4eac37ac65020fe7f1e913d3990a9673b8f40448d6110538318ac89f944c5b294b312cc3a38216707d232db6b29af7d2581dde51b4efa327467dd2069e1c3bf4e03a053bdfa0f3158af35788a0a647df877eaf83f52d1fbd299994bea852cabc08a70c147cf8bce62899cdc6d7201e22100a10c84dfb16ab0ef1e16c691b630eb72e3709f612b8056ea77c6dd49512f1355eceabe8430f7ae49a631a903997dc84b2c46b81e569094022fe2dc2c8458749fdb9d7948640de37cfdbb6534fb3d37087138edc19da64c6f359d32d4e67d5f0e0b94365d28b64e32ba856685d73b7775d1d633b9ad69b519ac43b59bb14496fb14354be578cbe244eb3882a117b09d8c4c9e7fe26e2ee5a7594978676060688c0e64c837d70559fa5dbe5d81951ca82275aca5df2c7d501cbe1f9938471cc250f984df82e5bf601df3b1ff17d3ab1ad110f3add50375f4b0d1eac0f11f251b27e7a4803f43fc2562e0ae08869e9d8eb7c86a2b38eb0856ea96f3c26327b09c1b9f9a327a25a44109f343559100cdd42e26ae8c4505c0d5ae8702893ec96f47447fbb07bfdcdb6902a62d642654faad2ad6635302c333d2f7d87593f2267cc05fdd44e702c61f4d8d9c91b22ffb7eb20ae9665db37b827eb7854d3535b07403dbb8b871b19986a9237325a3b10a4b37ae2962a643fb2462a4ad9c6c5867865f6f770ef984d64c612bf939e8832cf65bdc134d97b26923338ead314c59c8381c1accb061c330ea06113dbf51bd016995f2c2d8970a4913eccb23d3e774b3020f933a2f501f25550d8d2426d6804bb99439381feae34b79264d40247cc4efc944b6cc893d2e9ae37cf33732b0f1403b952f150fed7b1c90cbe24dbc9cc820a97e7c332c3649d7a77dc0be46273511eceb66366ca8efe0ad66120ef1b32998313c3b9accbd97ae5685e55a43e47d28f962ca8729d305793499c931df89731f977df7043e4ae11089bc51590cdb5a2e8cc986db0e6397692f1949e36154098e879c1e2f35539419fa84d33cd1fc7aba05427ca97f8b8f085d1caf245fddf5b99df4ea511655b66de9ca36e54f979adf56817b8a76e674900ff451ed266a6c8cb1ec2a19d1ac4da18d67cc907b59a6847bcb7cf37a947abd30857c5afe6efbbbb40b8ea4913512f25911455169bef033d04c72dd97f1782f922bbd58dd2ceb7516077df2597f80d3fe87d25196a054f3df0443701239ec5acb379f0297e3afbdc51e218ab710b37311cd5e74eded69392bb6ef128968d792d250506bef6b513807b1e04925a5f614c6e5d1bbfb19ca5460ba63a4471dac5797490ea11df5c28ff99160e375bd75b4c6e33b8c4b902f0987985354a74a4e65ce212e39b13a818f863f7604bffb5294711b0760dd700be32677d319c7be5ac789c7b23a17dd84105034615b3a2d1a51e6d39d4a6e29b56edf76d4cc9f4c09c65776b3a5cdb8f12e4c336dedbd107f202dd22d115dfc0bd79c0de749e3e9b40bb818eb8b4170368198a016920fac9b2177b32ccd4a5c2967f822ca2fd9d00127c608ea64628e16b5ddb5e8384a5cc1230b48a3b9d2710c55ff49af62e979ea1f3d3b5a8c78042a4d1f89754c60cf946be37f116fad50c244489da57f126d4b933c77eafff8b14182a5adefbbe674c85da96173d1733f6c4fdb53d8748afc276c50342a6b4a16fb198ba5f249e824be6430e3ca7712c0723fbbcdd46ffc03402ece6d15f79a97d5d0316d2366d42938435efea4cc3e21a7c1c7b01ab113c2d3c4c90ec7ee43d0578525ade8aa0a3281ef053f51ed2dcb512517d5052f243e58478f441da3003bcc1984a37baa7857edaf2e8dc383be23424ae318406f496ab56d020646900721ac7cd07f8bf79a0e15d93ab5cd24a13ef8fc896ed21c2992a33f88835d7efc2b8abd252ec2e23f9c931ecd8a6004cba8ba05f4a822a23d4eee34969f4573810fa1a29ef2aed8708630a3d85b14dcd35542f436e0bf1d548a9c0aa03beece63cdaffb934cd92ca529812dfbeeaa70cee3cfa73f09b72229a6533c45f1372336df80e693c168e4e81113c9406314fa89d4f95229f61f95c615ff8b246acad709bf260203f9b4886721239a6327bea1c2a6a13d0246a113be10955975bc87c8ad5f8e651392c5d80ca2df68def51fd3244ee31d46cb4cbc6bed1fbf91d4440d32a206d9e5ee76de6a00351bbb04df23b7286efb710c48b675ed45104d10a7c62421f9804b4685c57e4dd84fd4b0e94789a6cb54203065a7f808babb13150c5a84bc4edca29ff6728d259d17b93bdd84ffbef58fbf8c1ee164fe2d0853d14c326d243a592744f992047138395c760b69e163fae137be643404911ad09221797d77d3b22290fc55f43402083c35539b14647639e6039fcd0e0a50202cc9d0d147dc1d57b5c74191bd019a611f44a021b863a35c7a70c0a5c2946bf4a3ac70c518c54d5ced890ae95ab31c79572d0f5d45b83726d94c9777dbbff07ee43baf67b714e6d284aca3c709684c8f30fa559a1af36edda701f52ba9e4b6ca20972a9bfaca6b2a594864788db4924ea44079492222aabda1bb5f3b0ffad465d557b13becab059557b26c7148cf2010d4410f57d26fe1c3ceaba7e9f78d6694aa409cf3f3d9040690d565572ac7c0a625a1e5e000c0d7f8e82f3ace54c418646360c28ab53ae40b097320031aba7078cd399b383fa7d832e439dd29b7e4985283fca3f0674b4964897145b315e287818fc1a32f87378864fbd02fd4c8a66be2e5fafa3db01e4a94ec47b54464afda2003b90b13c82e4a449d087b4905d01e3292f96e56f831b376bee768030788d57a844b8b4cd9a2e32204c88f5cb9a8c6af880e8b9321aa0eae50fb07be6346b86e3944fcc542d46bd37da4e9f18e0b07551e6192c488f8df728e6739c00ab5e3660a16d4f7e6f6a6908b19da2267fe99ceb456755873786167f204e040d46f4721c4ca0ebbd929f0ce7d8a597c2d91dd7dbda43560e2bda5a5294785bc6eff5ffc217d26444d2d9a427a422aa6e934baf3f6e5433b05dd89f067b6f1cbf5aa7ffbc7694741ebb85a4d465e7a912842ba0a6173edaa4f73b4ee540e8fe65bc063733c80a143032ffbe9b347161dce5b983d3c5bf5171bc154b18d2d8afb2b4933b042f548e2f72f7c6953e01e43323dea4b895e2bdc28c7947fd759ccb7e4fe8b7b9ef7ec030f0e99b56beeb422e896d31071ceb1fe54c92fa14770c09c3d3934fb229c8ab0b4925dd25714ba6cee30a5fa02afdce6c8e573eb104cf72d765707b358a9b526b51fac470e8c29497257aea3154098fdea934fb5f3e9e39ac56d34fe7939dcae6203fbdcd129508d75fde44a6396311b1c55b495c4d333a61769e5984e17f4ac14ee7fa2927b57771092fba00c6460d3da9a64cbf83bf350c97c6dab2ad9c8d54fad0bd5ba6ae32cf76aa391c3f3d373d7f69138fa5a620ad66417da7e2e7b0b71a76eb4ccdad4fcfe65eb469b8e5ef7b040a23067c11f7bb92a0f72e2504f3d79d90625a7dddc1ab2f46b44c21296a3f443204a49b93067ed26e5d0187170c6c48444b7fbddaddc272aeba155772220febe58daa8949a346f10a37ee52258b65186f8819b759f0eb1fe5900b2b07a3b8c9c59097ad854d8e2b76e9a4e655a6b707dade7c1ac257f8b9d2a04f4fdc9c8b9c22944c246b656dfb89382834d50164170d2f19c24f3f92a09baedd1a3edd30d61408eb0342d58b0e31d1c20834c3f745ce3db1c27940c129b0dee0c20f428328cf8c3b4e5e993dcba3df93f01d51fc96979e0cada5fbdc3b1b7656581ea529a8af7628d984dd39ba01368fa83a20c23f14075f407ce24d034bc4be6f35d26e7bbfcdc490cb2c25c26d5ea8bf4f82a516ada0627cb039a96b436c0d9336586b35d0fe99e0b6c213894ed3257f4079db77ce97c94a187699d7e4a5b215691d503bd46b241c9f6ac649359e290688c66dd3a4fee95d103319dc53744c7afda662a2010af6230a57d2ed3cb8d84ae79e858ec2164f6cf3bf9679ea6bf0b45fb5d981e388767a5059e42795397d3564a23925469089772a46747bf8f3d20db39d0fa0ae2939faf6c4e8d9434e25586402e07b1fc3e21d65df419f526cf9e204986abe3626c0ac4594bb1751aa3b4fdd6bce69d3c425b3c15455c1906fba3af4b1d339216d22ac973f44f1875179a45fc706004b84383c084caf02ae93c94837e62add8e011be95cb01477615d523c66527093a92b5923a10f287d214478e042c1eb9dce0a58a46cde6332c96e45e7132769d47cb257f34375c850eaf399f7e491c6b66bec666d9092888f73188e343652bd33d52d1db9fceeaedebc935ba98d6e75e5d50dec4e533891d3eed711458098353a67d2f103d2ba340efbe36a51677defcc4265986374110b85f1f9057e4d8df43d31765d512df5d06488582623c651b5346b033e4c0bcfb5e5c275f40296817f4428772cc0351e97802667a901c768117ef8bfeff45f0e9950474d0f45498e621c792e7e39b90a6a21e190cb506c2fd1f43043079d3421967689115e2aaf7c454cc219b262f682f851ae7597ec491a45975a2fab7ceec1adde352dbc5177f573be23f6e35c28a05f39121f90e82e9cb44662a7a6ee7d64c50d30aeba888257fc71f1bd14d50083bc244ed106bb6487f40ad0601b7a5d8dd10466f721f34faaadbb1763abfe6624dfa686330adb74a5d71d8b39e9cd05acef34db47200e695681867faebc3ba36684a2a73bd40cfa2626eb7bb3a8acbdf23a2f841c54de7c22248316b26616ea90a234e2262aa140d45d61c83b87232bee5612ef51106304daacc50822a016fc4afac5d44b22280c03cb0546db3e4d2ea8b1c3c6af91d8f5bc2b99394451b5fe5f2ecec6e4b506eeba0718e08d9cfa1d218165c8c66e0f1764c0bf3ac815ea997f8950f594b0df02392328889c614e85e499508c3938b0025ded8037fc6b6c820c7275635bb83f238e63407258748dfda02c88ec8e0fa836a5721a4d1c155493dee63bf48354c835335e8cee78eb1ea8dceff3789f582ec4be9f31eb9be1271f6d479885e5d7473ad333929547783333c18e17ac1bfeca4d1ccc541782e124407623604e49e7075433445f582ef72ad431068ac8eec73344e9410a746494165ac39ae3f5fa1e257d8907266474890f16a43ae4251d6e97984347f9f15bc960dcdb61af5f4cb11e2856f6ff91a814fa0ed1b8804da2fe7fd63da0a6f8387e6db9ecc316a84bef264091ad513a383ef06daf19dc26f304e5c0e5ff8d9e2e9ef2e3aa4e7ae7850994e19f739d6b2586ccb31b9f2280037d98dec2b71924cdfb153a490fdf2b18c00c99bc228f421badb31de67e351aa8111416fa1fde262dbabd768e7b1988f767271157b05cde896d082bf41dc0d96a54cd78c0116e6810bcfaa0aa4752ec229991b7bdbe8ec619beddb244ca284dee4de1d15bdebb5b1cb022eab725db1122850d56c9b98e41a1ad02d11d42ed6bcdb69691d5343dc243868f93ec8d958f9e5d5d02256fa917a6790fcc70911e969f67fe0e5c49e9e20bf3161802cf68b09337ab0e7308bf6684b7b5d6a46aa69724bb40f90c15c8565f793faac27ee28a35e63951633bc4240889859c8783ac5797abd6ea5c5de452ef98b4a5a35d08ea8467cbf5f6bee0e50f78a9d1896bae7bace353ea89946bbd4b2e0ab97a03c3df353aaf95174c8a9a56022a5526cf5adaec974bab5726d024da14b3f627adbe0fa337a6a117f770224f23337e287ee7bca74caf233e30c9a07e582bb2803c56fc6bf3101fa116140a52003e0af8f2587b5d7f0f61185358eca42b3df8f40102985d6b4c7555478d36da069c321a4d9cc0dd4996ec085b831b72226b6e6dda061eb7b38d95f379be6a7ac56982b9ef60abe178671693b4b96a48a61f13341f6fbc24f5c71c2402b1fa632e74a31d7e1fcfdbe82a420413e650662d708fa8a029a3eb155b031794ab5ca46663780c267fc5c990866b9768d13901d55cd79baeed38d0291481dd06bffc5c38b42ed37b9834dc55d1f5423de04cca99dedffc7b80826806f44fc44a763046e969342cfe278ad5c20432d80bef48130338b22e437ca898ac795f292215ebbc01b054252989b3aeea6faaf8ae7b729de2fb8e51b4f544d5ca9f6db3f93a266a84262b9d7ad034b2ca9f27c99212f8be6d8c30cd6ac125741b654f614ec4f89a16979f0bdc5298cf6aa8960668963f378b99ddd0950401c3e021321bac32db122dcdb4ad7d8e81049d18d453ab7fb29bc0f9d16b045b996b637bcebb5de03590aff3ff40dd180b7debda4386db7b904e626d32d21d3bb2cba3c2f0353a561138aae150d330d24f82f52e8fd81f9867b6a810531402a532193e696de7e947e967b5db1f83546c5dfcab9682c85db7efefaf353b44ba98b235f31ad1866c4ecf573bb0173bc3e9abeb14e1610b329a1155ffa8f60e59e6c6cf25626032db551c66ae8456daeb33812dde381d1be806e4dcf18188943853fa698992af3fef0327cb2449db0ea1d58caf07b11e2596bc5b6c1d0179b2190bc2f88643c3f3ccbde16954582f033f08b706efe95cae40527220eb215aa8dfbda833f4bc91bbce1d8d6cf831bf692334dd77c1f8450a93e2c2d923d38e5b8b173a2a6bc7059aa6f18b943934cfe4c082382bb8da9c411290ed673f55c5205c9f3e8366bd0e4d0a5cb9d59aa1711f957c245af9f930f4ba50d51c3ccac73d32d9d6aa4ad3ad6407f5e76eb466f929a01b913f578ed41a6ac64be63ee1c6a08ed8ab001d5c477a95d8d13eb871188d0bd4cb02338e78dab359a4cba472e09d73243c6c128d07d951536c019bbf65a87e2b83bfd3bc7eeff4bb3bc04393b3625ef46289e0d028c19c9c3b1d56f4b552d867b5adcbbd0c47551ec5c653cc7ee30f06cf8e9807ed233c78e4bb8a299dc237a3d3eb426e1eeefdb7755387ad70b15c9320dee1870a7246b0d4b2bb28de0dda6f059f84c87129555524ac96d6bbbfaa3d2a532e1d1fd86212fc82c5bc60dc05e9f8333855a7cd4bc6d06b26611839923a2ce67990066128d34678d9254475e6db74ad462f8900351c9ddbb364e928c02cc7811aac1c4d0bbd1c5b25513ac649d40933a3830f83b88cea26bd4da72e471ff28f297b480a99c125b299b159896a72ba1d95d4decc3649b9f0a7df1d190c3d3ad9a1ab900f72197198b7082f0be75982f67c2a9b55af4e50d4d55cbb889a1b541913dc3f8a3a8a649fc1e8d4d7bc22085b72998cf9409b0d89e88d3d6ed591b4bc0be1c6ba06796b0c3e8373a3f81fde273a761eed274546688c9cdb7dd7bfebc772be392ed31788a12671872680a4a0d4624f35cfaf7b2799b6dcbde96e20c24152a32860dc983fd7220899beff5e76218c90f8e09bd6d91942abd545b67155a1449bbc23476363126f7d9f5996f0c7e5ebb675857f86c82debfddcaaf02045d709abc1683a819a8d1cdf981f15b7499dfcfdd6cf76461f187da0db2e98379b5c127cb3bbe0bc6fec3026eb15ee075e9dd50a61116b446de62b85004b002506cc432916f54b2ebe0e58b98770f993c4020120c3c5962a7ad17983f9a112fe1ed7ee97d592457bdbe15a14b3c3b7af9a5beb86c838c55cf6248bb3bd7a8331d7211ebc52b064140262972a2ffce921a64ee91ec11a24fb8a104767d48fc47b8433b31e87d834cadc7692f03369ed3721c2a269682986d788dfdb15664ac8c46bc1a453d83d3cdf07e4302daa844baaf1719f077ce39562238026c37bc95dea23840e564107679983f259ffcad9e2da16431177bb9ff1fd40cba0a7595d93edcd382bb3f4d42e747ab3ec128c30f4bc162f1d2b935dbb2e8aef4ec508007ff633e2ce7c3c6691c2c255f5a27eefb021eaa804ae73263445d24d2d8858428e97a3289a37d959a1f58143a3a5911a33b9644959ab033dc783b292d5cfd3513ccbfcffc0247ca5775662ab55069ecb86f72c3afb01cd14d72f8bc59bdb7398df67bdaf4a421d012531ac6c822009cb19aa5044b45362680700b50bf121c5c3a6f0b96f12e6c63aa0049ea33c9a8edf41336c69538a9bdb0b7acc8adced37d4ac32ac2796314119bfe29a917831e980676757cd032f63f42b4fb7bf5af43959ed31221d584e1eee42681bb28c06c551f4d06311d77b7bcfceb3524825c30dc92f60e9e59f9077707a48ec14102d00f42cbd70d5c0e3488722170b934ab8628d522cc402a92862b0b9e38e39769c048fb88aac32986e84f880a7f6413142e5c8709ca37f6cdb9bebdd772fe58aec4423990eebb9c5d97e30609696f9f533fbbde8544131626dbb467369ef61acb7a58d8e6021024e95edd3344fcbcc4ca99b1d7f80e92c3fc6fbdd97fa1b96fab1011809f66303b5fc883abf3eec845e93a62613bf0771a124a7b500d62a1acb9a10291aeb37fe3375134efb734c86eec5d8992f311b67de0b5785daae10b5cb267d8b0a78f43eba2023cf70d865576430f96aaf721e2a7a1d245ab2735137a4c040be9fe809369b765374f031f3d60e7533e621498fc4442a05f37c58e4356945be30ddc3259e1c47810e86d33fb9ac2aa0fa860a18a9641f8ee3e0466c91fe13644ab2a6d9de74adf8d7a6bbfdca47126a276dbf6a03e6e94efd708e1b7ac85557922a5205b5d9192115cf578669225eff9515b887aeefd7ece8b724aff872157f9ef3d130ac8cde93114866e321e3dc5ca2a66a9e014bf1576886c60744813b4f63a024ed97103b0657efaf495f28476f5f998f34bec78ed349e6f1a02ecd0d0883f98a0ef5ac6169fc56db6448f5c992a8939859085acd96992aac455b11f7ce197e4faa4dcf151f6f22699755216e1b0882fbe4e9e64cb8566e605c19cba5d8433c188daec6bdacabc0640bfa72de7e0f1edcf81ef79e5d1b06aff061cb8b2e5cb2543d3dfa98ebde23d35d0465c93a9211c4016f00593632e19007024641c7db065413d50ce70d7bddd4d3dcc5da07d1cc3c0693610ee069e6645c6ce9c46d8baf88e1fa02899770cbe58e54011b3997e6de4e8d7c278e40e97681d4d4cc3bff1497a570f48e60b4200512818de8f12be34c6e9ca0278de7ff67ce83d47c2d9b470d493bcd88b3bcee64344eb9becbf3db2cdb4bb438421151d4f44ed99d2adee027dfb25ad0de6e84b1a7c7de7ef83f5ca89308ad4239e5cf30aeda70cb8c36eafbbb676dd456969aadb86d20d76fd13ed2e67144936f84fb2020afa46b4a52c3fa2f743e03a2b06245b3da0be15cf641a3c5daddba6d47757e05860b6fbad449d0a758cb716155e5764b41ae74239c170655b82b98ab869c962c57d60201c690868653ddd8d9a6c938508114215b962b32f404594c5413017eee50ad9bf5a4ff81b3c274201b807305cc8f67ef77c6bf5c1bee4d74e22bd6a77896757083b0d6413ef9f6ff26283a70e0d18520f2df0add8326bac289486e49014d5699e9df9f8d1c5027cf790c09a6ea5248adb15080e4b1a2c0e88a82012557419ed1aa156a5165eee2771289bbf740976c5d44920bbfc1492e59d83d2e7a4feb873900b90ea02103f8cad098bb7eb4cad177033407d027e701a88b22d9d2f3f2605bb8aed9743d14b71d825476923ae8ce7bff6b3f67cdd3c90cc46f17390af3893b93c6affced7f3252c22ec00b5270c7344fdb1ecbc735babfbf1f7fc984a5dfc3347e5736ac16145ff5da1bf18628fe7b0ef05113769a3905290eb11d4abe09d76811a99d6eac4afb69cc2c6c92f079953497f1f1153be912ada56b5a5a91b4c3e07ee13d1dacc0132fec3dc4435dc2330976e26395e1b40088d38bfbdb78df90d907c46c3594622864fc7500febc2eab608285984864cf1d73ffb98566c20b07a177f915d666b9e7cc226a3aa83e6fc31eb0f35640dc5656b2c4dc98f3e3b23f2b8be8e3f0e779b9afc727572a35992a8c0ea5fac4e2f503710be8f812b81071fe1cf301762a2403ddcf8bd24067d10f38d163ba9eb3ed7803fe93cd4f5d56b85fac27ed9536e9ba9d8191a02acfd3a88d73b01951d3a895f68e12005b6d4d0c7d64f66888260207cfb31044df79b6e02422fd4b3a277d448e28ded99cfd89c145a49dbd14f29c9b5ec916160d9bc22c62b829935494a6782a5863c4fd394bd46d4f156197659842aebae1965a9de3cc9c1b49fa0dc31c79c1a049023e7059706bd98fb9f72bf2729afb51859367900dcdbeff57f09088c178195c458bb9546ac810fc701753d71617ac0c8e7a38510b71aedf6ab111ff61fe3970a48994ff57a04b936b6eb4b993cfdd8e7f67254a7ac5e5dd7bffb5370a84d3fca80bb4cfb68434c948e885f417dfeac481e246f0a4cc1b47630459c12faf05debc6d82a2e665cd2c85ad57bb0c359ee5c4b9eb2dab29e1c769db057be7ccdfc7ef7d4c7d5198d7465f5f361072fdbfdc6febfaa85ee9fd24697bb402254bf60ced669a1af6e4fc03b7269962bedb6d1cce88f95375bffd2628128194d4cac6db06e8e380a8b4f058297ec933e5adafae4509ce8e25142ee7ffad75bf241c90bdac95111088e8fb6884ad3e2e65eb1d500f42aae97574b6985ba357666e9c0c646c54c08ff2769d50a7687bc1d9117a15cf266ec9f4bd7fcaf10a9074dbbb9f5d8b35e88db6e6024891e168b314fdef2133011864f14662426a53082c9a1b90b604a494953d7a94c9608700e2abedffd8814109058a42bad73d8839628e497d34010d9afcf6fe5803f4f4845864732863ca09d4e764a31631c2c94a28a2af5fe0f64a768aff4cc31b2c76387ea535517173a8a0e9a66fbaf6b6987e952e9328cb0924e4bb54b373b70bc744441dbb851754e13afbe6916632a0c719df5837743982eb88a6dd6d0302554c09c55b813b7b13805175626e77f44fd8b2d85b92abd06f1104fc79a630cf91809a9d4f5180b2e32bdaef8a217f0e8837a38e41e9b0e20afb955371544dd33a547d3a9614b277033240de13a1d4be95a6b87f7e754c587ed8fa732e2d1d75863ca8b2eab0722dd3d61a045d3976d117a868201cb010ca9bcd71b9963c8688687829ee3e860192191b302a0638a2991f9cbb26e6deeb88b71e320298760eef731b36f3ca21a65013ed6a2d718b17a4510e9ca7559b6a297b338d473f00a975f7574b3d99469e3d627ea56db5f17c89569f9603a650715d4f5eeaed5ae3866d717812a02f95bb9ed0769bfb6ca03c05be04d220826d198a29e3d186b93ea515f1d9b06f071aedd9fb18cd4cfcd64629f9847c9bf39b26e0f07ac296dfd8da297af6f5e9fc87ba8713838482faca3331641a00dffc046f71c9fd5069e31e66ed46f9f0413e5ae0cf019785974ff982a3721b4d6720715c30058b53d80d6f224b0792e8fb12c9671da71da5394c849428fd1a5d36c02d7cd650c7341a03755b655dbcab195d3e8a9fe307d606653325684786fcea980d9cde0166f91d4126f4fb147f9f2141c2de1af2a879c24499a5abc1b0824aa4837a812d7bef1bda8e22031a11695932b57681797c0d1b5faa96b23da10188b1c232ad9de816bb6f8a6622bc61963d948da4e256d2e22f744ba01576f86d44fcee4b033390604d1511612736d12bae482e5dfa921ca74a4fa51cbdb7128f91de821e20bcb95c45de85613d423a2c612512034aa8f4f2cadcdfbffdd9cee9a3a31da8929c71ef00a0bbc6fe6d0ab54bcdcab8c916ac87b35bb2dc9aecabea4862665dd15ac31c892288ef125f54a190f7ebe7ea1a21cc3569b18fec00ab1018ac531cea6671b5d24c5407057135deb3f91c40a5ba058c12395e10b5713f5155b8bb87d4705a408af40470c43599cef47ec90cec13e2a4148af84465075c31310c0f433063f3763c20c6855ac7ba5fcb2b047c3139cd106a039e4db8497473a66dd48930eb8aac6bddd8ade11cc5aba88f0f9507bc2996f598518606a8c82a7b48c83d251b9267c924097e930a5c82f6abbcf7a8ef20bbff375c5e88180c125dccc15b2e5c91c606eaac322c6a1eb39ac7827ef8ee6881feddafc01a65dc6352b05b6a3c8c7663580ea8182485a96d239dda1241e54a1b9a7fa3ea08096cc7491a949231a92121ebe616640d3ffee82c10ee738ee05d58120939c317aa2ad88420732883a5be78a754a23f24e98553a968d513ff2b3b4e80c48302a9441bae38abff51ac3fd67dc48a997c3284824cfd991118dc298b59a0ff380cd3272732a2697805acc5f9ab5158fb0abebe96cf408482fd8dc5881857d15389717401ce8a4392cd7286e70eee2665a3973eaa73662eec0b1dddf6527809bd196fd3114f694888e7ebba27e5e607b850978eb351ba70773b623943d4a61e451defd4f55ae2cd70ca1527ec22b6a913dd423ba075f27b25f0e2c22923e3373205b4db85fab3e3620e3d44f907346ad8e215c155e9030fca283951bfbc3d6f998e361e6d80428039223f9cfffbff006142034a821ece2ad70ecc70854c8d5d36d720aa2d5da0a15580103f3414273b8572017d610030de8019c7406e48932ef90d783ee88198420f917600c2ecd640b3c993280ec0cb358eff85aa17e5c482fcc6d4d9d13a5dc8e4c05b41c6159aa41ab5c806069e09cb1c62206b7f3d3bb2958cf1b4a814943d0cec02466b70c40671bec7a7ea581268d4c1bf6261e791ed0f834df4ca6ba520ce58158691b30042c1b91d5b027a351f8d72735858b429edef333a0c26102f8b91e787606867f22ad8b748c885ff57f6fba8e7e99afdbaef35f635facd48c52dfc9ca2c9473c87c7740278f36fbf4d6e96f12213f8badd7514e4fa5fd40ab8ffa7aa97bfa201f584e6f214dce0260330fe133dbea98de4feb6a0f9219b17542677ca2acc77b8472fdf21b0051cbea190f714fb1f2afc178077c028aabc58a82eec96f3d659fd5b8559b41fe2e920674bcbfdec42140ef4720f9bcc3148bafababe5f5208aa29d9f1ae5f7492f11e755e1467622bc33f8c7d421f146b8418a2a309267da9dcdea51f86d8215a09bc527aeda42bad6945a47a43448d171818a0bfc4af4891d854aecee8a032ca40b32ccfab3c8136422599be1c0352e90589cff4fceacf34890134d78e47527f59c2dc185bc82484fd468837ccc341c6e1d299d29e1df4b463477e9e8a0efc5887acf5f35bff6d09818dbaf8e1c58bcb4c2be8167ae5480425500d1e5db0fa36c94db99e7d592307731ff8228c20d118da84e4e67d921508aea9acb3de0a8f64262d4048d22d81162f546eb0670127c9e49249bd1c8a1b95be5b65a0727189a6a2c975328221644148155405d82d458bd864752bf969aeda56ba50e7830dfebfd8972bef723052e967d550c90d3eb447ac3d5bce779653e7008b411633cea9f4dfe200fbfb037dda8777e1c88b15c5be29a6c383e0e766310dcb9473cc3b6883d0912776b29a49e2b55b479391940471e239aff2677e02b4b4592106c3eec1b0041c7f7fed9a63b8db9343f177b5ef70707a8369f0ed1a8e097fb027bfdc2af9afae9b87b630ae908826bfda41e92ef288402ee26b54e1b9f1ae36f7851122dd5cae7b7f83e7619172140ca7a08cb2babcceec449a96e78254954ad979e8402e34c8e2685d5b931d1d065f79e53c474a90e267151b4f074e1d4bf56f282acda0e44f5178bc18e3dba6a8b92dfe0d4e3cc79cb8037a42c6001c17dba9d57355ff9169c30dd08ec841795a706140100a3d16d1a105baf6ad15a89e02cf5538a37d67fa60cc8f07658ceb1d0072f393c83a5a2b80ab1a422c87f1c7c1dd2b57c4d4621a970b0dca73c3059858ca72aba07f9cce17d10c4e9fe633e9490cd977c898fc593f5e46226050210391b99163feae48ed8cd81ee8195061d9c2136839f5fc9bbeb2a434a16ab820c44d2955e594edab09f531eab0f96e567e36f13f667f38c0f5007d5034145db0080cbb49359109f9137649435838258c54b35d256179462f4c19f9605ba1b61a87f936c720ba18b710946932d9144aae69d4b15454d27312de5af07610e81dbd8ace9b69ee65ebdeea5ad4d1016cdbe5a797ffc61254a9090fb9ffa36aca59396f76eebbc50248cc9074786eec48a0dc99627c60d6e4497dd8052c3c92e2de5facbd5ab21ba20cd1f922bc5eabae049bc21a067b76226bddd1f366d6a0fb33bf152e05c30503b42a960f366742583fe57b75165299470da76ab30fe118e6b8f242e53d464390c99c394843ceb406d87b3bd58f773031b20a6dc3347268b5b7ed3b26bb4896a7d11dcbf13b296b76cc5093076ed179e929c7a6dc97ba5b46aef3092a73b0537c962a3fb111ec3f81e7b23d9b099b518b02a8612476bcd9641e436899dd932cae5008f5e2e31874cafaacc9c18d07813a232eecf1a9c8ca3d80704a9db77936ab389c9ab262cc72575e8713d861d3144bd9416caf4ad5ebc3c4cdacbe699f92c69ab7fdd756899a38a7e330680585da52f504a7fb4c048c9c6a27244179f6a736583718439cf1238a313944cafb4770b44166e30351612ee43ed3ea082aeceaccafa170b1e1f81b94599f15fd4160527e5b3e0237a63fbed4e773c5c20c048094800f55ee53912688e60ee98ad0c04dde52ae80034beafe83942407fb7cdea393e7bba93f470ab03d71ee6742d63387d04982c58cb575f591f4d63ed5fa476f87c187238698482cbcd4236977850855f12ee2f0298da46561ed02b98198f87824bfda5eae98187345123c460e7234cf86cf695820e736170933606a1153a32bc2f96542de9fd487f58c4579afb8927f5a9ae458f9a074ab2b456b87e58191f9ca60329c8923bcad02d724e995fb5f2b287634079d564022261fa002ab547cc146ab5d58ca02ad6bc3e51db3a7cf3c41f5aa3401f97103ac03649c16163f9c1246887d9f09099da4f4b3b1b799c3239b1424ab5f2a877f0265f30e6d789e99b1c78888d04bfbf4bb9d68b6c253042bfcd5aa451b7b7d3ced1d60dc76253ae352d282a2ca28e109654ca67216ea9a42c3bb2b91e8222417a65209c1a1e3566c9a78c6f63c11eb1e08b8ced8ec932763a1efb1d97e514f9e9966c018edbd631a7f8a62436e0fe2958acc7b5537d1330a3a536135997606fad91be29f3774fa7b0741f5f2f93e9c722ea973597059cead191ae40c6fd62d236fa5f8c7947483afe6f290bafef6dbf169517d530a6188e6d0a1b143cf582f95fc17d16c43bf13879aa48e2adcb5c74f1cbd672b130487364aa8bc7a2d8040e606d76ee5a5569e958080baa16029af4f6a98cc0941c1fc78ac72c53d47833defd40d179d1c5366d211a4e096f4051f025cd6413348eb94d608bb8a0335488ba2b1aa9a9eaf9024ad023f425a6692cea6849b1b7ce631e255f63f7b3aea1e752eb3f51e96aad60c48bae2df51ff9232d44601e8e647feab51fda78bd98e3d36cf3a5e1b872c16c56db99df984ff5258d263e1e73a89b2d41736edf9ecf7cc3c548327068ad22ee3f433476efc37b85a3a2f0fd0eb2ada8ff7ed89e30d1b313dd23f55e7df04ac05899d2334a23e290f7f5d66e0decedd46fe356098bfc2d8205f1fd8545788ca01500d21f8ab21f59ddb2764eea7db140048a0e98e1f41ee2f8cd0fa73e31a480d2494dec5f6549f76ded4b129415dd8974a617d64e756ea301c61202ce6f0e2b280847269e640797a06aca90b5d848a1d22019d314a357fee8b4071e872c59235775cc7a8a9366840882c2efbe1a1a7bc38c85fbc7b8703f7b96cd83c2e2c9146167994b350c4fe431604bb281bb752a119fed4e1a99b25bab0f4f3fa77fa73047a81c3094402e5b4b697628936fb6710e4a88e7e5b79aa70436900d3fb499770ee00c6b355a56645d4f4c270436d1d5ae753d0f6527ad0dad5570d9c76ec67fee3da2f79dac58f74eba2fe40f1035f7184ede8a41407babd63ed9e0c1bf3948495e7eaf460ecb5c1ad4947cebb88b7e076c287178301e21412d16a89f606c680b872847d99fbd7a384ec7f0b59963fb2c9c48d41e572a8a153793d174913ca1aa5cbc8d10b6f06d0fedd9bc43fbd4461a3bc2d25b0d7204370f8d2a195b4e390c712191608fe6263a5cd0252c52ffb3093d8d120d114a5ba6108d798d05e84a9a94efb7368ceaea8b1739f1bd267df8c5d10c2f7e5475b874f42591fde40ca405991e52b0a43325e40c425760020ab92309154c7d85dc76defc9cb54b208f07a80390255a9362f6ee70580231d02ee95dd32108241e7d2bb22d5e2657c070cf524b79ffeefc4197674f31d6094c8e70af3f13413bf80bae0c0040c0785e926f9f0ba1816cde374bee779a4afeaae8f63d9417e61ccbf06c0cb85fc7fb5a60dc645f160da3af244a4f0c85d372e86ebaf1d191456c2bfecdb5fdb1611f7057510bf31edaef04ad56f17a79ea9c23602c22de979f8c5b0f5e101e8981cc13fa16c13389d1d644fcb331aa412d2e2e95b32065433485b985023d9d02b7c950a8f58fe9d06bb42676ef8bd6cbdc8d81be38727c3d1346052b876ffc2a7894df6014cffb8765baf505b148c413ce67da42e5a545184e81cf89d0a7077b5928519b4cd368b8cdc3b36d40fe56ef46f91948f219a37bc5481ae108a87ce0d49a3103372b2238d7fadeefc59079bdbc13bd008dcf17cf277ac5649fe6b2c99c82a40d9ed04c254fc0741d016bf489951ace271abf2325f03490a2d98d98706123000c948212d24773bf6aaf6f5c174cb57dc11bcb0eb280aefe42c2cfbfff00b1080729e5abcf0f68a7564226136a993f2ebcbd490015f735c89c3da583a40b01393eea9cd7f445e88474ce6637358e22f888ca43f3d8b4a7c9112af8ec38f0f6d82e3c2f33a09c22b9bc59bae9e1bc62af9a198b6faf614b1f00b162b3d024257383e62b6ea33ee47b9552f611e2dd688edd5a70f0d1f1ae6cb7feaf80538a12e497df5cae57082dfc455583e0e10cd42d9538f701dc288c7278026db7bcbd22522253a16627d9fa8eb6704bedc818e384cbfa989ce8bb9363c30b18fa8dc8146b52e3c8082aefd94d1759c7b6e8e009b6c8657315ee436b73d147d28ef7ab457cb0e440e53b1c1c3ac1b859f7b9bbeacaf4f021ab31adc89ee806a6100145ac7aee9939a3c4e88bdd89894bbaa54339ffad2de4471c6de87ce227fbf4e1fc28f38b4bbbdab128ed53c041f715cd9aed5566eed229d9397c36d2826b1aa329ea6ba35021d983fd4ec11ed19c70cb0f59955c0bd808a9ec61bea979efc27722b2994c1be087fb81ebdd0002094bf40c443cc75ea865d9ccdb7b5173a4cbb6eaf9e49f61c8a30c50dacc9d4853277c88dc09d914427e8c72d61bd7729370b5249a5fe9813e28e3dca896ab912b4c6f8bf41635bafd07cb2f24c7d558bd88dcf4ceae4f8b464d044725926393e8101513506e0863625b95f1eb00aa573738a267562bfcae822ed5976dea494633fd5ac1c372c7413812da959fdb14d92628ff3b4bd64009a44c6141f70023c57ef25c00a12f08a91222aa1a1a4e5793de94ec6d3712521a22a694694ce5fe24c86f94385dfa07fc4ba3f3cde5e79c9880d35cbf8f046452ffa785d4a327356d335ce1342f6e96c2341cfd547816c10430fc5d825b841699dd25755d91aa3bb6f1b665200fcb11423dc24b12164008e5f59712368b23cac6b7526ce0ffc9b46a3562c4e7d1236d12d922bcf9b420b3a5dd2179fcaae4d948ef4c947074a270e823eeb5d65a5d1dd71681f280068696d1821773267377a1816d4bc651052c9a7b77c444bb3e45d15e4203423367ae83c8703e84531a43faa8e8713b43e20378bcc8e9f06403e01660848862d8273cbe5633589f49bc4a9692becfd187ede5e1ae1c14992aa70ee89a12e6bdad4a561eae6a205185e2777a21e2f18c679eb36998ce1fae7d2eccf3c74bfa9866f873630f87a41869d49f25c432a748e6701f7e4478150f649f5092621cfe09905f36e7af54bf0a68137d37f43fd1b9acf8073c50104ab289f28251ab47d1df0fa54c640fc2ed53cb573d6adff94abd64a2b6c415507447b06f708546ceab5c66cd1c4fd35678fcbad98e00cff9c13ff56fd843ee4cfa1528d3de69b2256a1d95a5eef9dfaec1e53bb3fbd31aedbeb07b3a56c82f91e7bf19f10ffb26a071b0f3ae7f01ae448d5b8b1a2b90fa070f48e3325c0da14b6c2e02e97b809987a6e7936539b59f4bda44b018e63d3ae651b38e69babbe3c33db24002f18d35841e0524d187c329cf3cd17c8620b045ae40ed5aa4ecef3629fdf5d6985fe4df2b80ab9ff4ed3672bb3cbcb4f9b6f24470e6127f341accfd5f4ff955e03e5d6e8996991bcb41f979b8427d6aa7395d0facd9a053b760626ed4f3f4073f4f95bd87a7781a70efc837067adc8dd9c61f12e324b87fd9424ecc9f13623ac55fe34426833a8c4bf1340deaee3216e0c5079cb246af6412671e6b028dc4f928a5097fc1f4924700a54cf5d03ad447b00ac42442922c7067baf047c5220284c4d33bfaa89e00ff10924a946d6dfb088669706ce007204472ff152bfffa3a0df58ad2de8989360efc6c52d53294bb5ba84eb5ccde221ab96a1bda7ee51a9692e5f992ca94007c6bd53e11f09a90a4f42621d6e907f50ed7f1c3eddb83ccbc0536be97c6a81a4138f54dab155ba71f10b0f228f172d1b17553e799ba043122e71ff7e6db1e328ca6f9a94764c138e6e2f32aab798c815f749223d8bf09708852e41be4a01667b32ee0c998de899c2d146647addb42c4ad233edc78c3c544a8b9a919dfc395605dd7d368722f2983a2e1e77974b7f3ecaeedc913091909d9dd73506daddcff342f7fffd483a50eee4f8227ec541e27879e2808cdbe122e7c85c7d815f7f27c678b4283343fe2f6feb4811ae7b522ad6408de60ab268b8717f973a8a43773ecf29d7d08dd3d35d716fd0197c2438564a2e70e836e7e10bb169df1a58d075b09c76d74bf2841f8ca42e5edbfd7bbf11957649f311cb95d20608b3fc527cc03ac836ef5386c74baf03f1a1eb0fbbbedf43927e2fbb3431d6fc8b0351f05ae92c3b8d9fb464417aba491ef05e89e9df4599f79a357d4100b43b7d0f4d05af9cbabba106677d6ef51412a30dc14b9eedb8425f38af54bb19235796de312d02dd87d717e5fd7f3c4671ddf10ba1e9b867ffbc439a8bf49b74dd2c8e1f66c60e50befb19d3771c9969c6c5fbdd127572da9a7c27a69cc46a89a4443af2d4d11a7bace14af1d841cac1883afa830d37c9da7b2354bfc900b8789f473e17c9a7509ea28c66caf3e9b3e0981a3bdeebbd4b6875284b63b351e29bbbfc158c6a268e37e6ef721031816568133300f09cf7979db99d3c460b3b146ed264fcdbcd1211fd80b75464ad24e611851a47d1675c20e511b40cd5b4e9a21afaf18a142a5dc4f84e860f756e7f1e752e8893bbd189b189fd2ebd12ea4b2cddf74d366346de4552a09b691dc79cbfb9b3efd8ad8a626db3b346dc9ac927cf156b45828c89fe316bc96c90b19c1da5b6a63ee8688993f6cab84ef0b4ad42a2646b161f9c940b4cad0dd72edbf3e566905570e4b722fd09c9edf1766740becaa28f838fc0093a37b59abf047588df8967e81e112187f25a5663b865c4dfa8c1e1f60343ef31d9dfb8edc3e393517017d6741f7f1d69e7a7cf8e7b319c5bd5665f03bcb5de676865f72043b09ea6a617cbf4275c0edb15ba72699a13a80ccb62a0a9c0c65f3a070b5b427c5894aba6d602d5170b51e56b750472e5a4a0985e65e6ff996e0e36d88909e531d122f7c4be85f7e053ccc14f1dd907d21712d42ba3e0916189b109af772c71868705549cd64b4ea20c317ae009a76199bbe71c7ecafeb4bd0d05c6bfeff33236314d6c198c58418866cd757eada3fe395fe6d716e4dce56d029f0c4ee762cd676486028873310e6a65dbbb7d1a2d5b251812d3c1971a6391480264a142f817907515de271d19938ae9d3a798b2a17dc18bd976c2f2a41915cb7147eabce0d0e6c8012fb289136883c3e4a30f2c47b8a88764d8d57923b2bd794512f2f320b891abc9b5d66e337ef544dee573c2beabfe4579d737f7245c977d3140c7b14ddda79e70ffe55febb312f13f16f09049b3360026dd2b7d141e3bb26aee914b50f817e4f421a14b67715894e780b93eb918346d680366d77475b4d6f47720e66bf61c09834535575ac215cbdbf52c4c198570acf35fc6660162c5ad6543d54961b5157b859c2cbfb140bb7706d1462c699391f4f688a0f03df15b2584d7dbec0eea0e4f4c4313772fee1ee3756ea70c5207f6f1ce59b460c151e8e5e3f7b900d9be8213dda1c73843d26e1418fee27fa8c372f28c237d2cab3c887884a91d2b2e3d0d2cc31cc86c1795b85c64bb87039b641d049639543b96032eb0d706047d3f8ad3fa981ad8e883d58822396ba47bde4fcf163b34de6f3aaecc5be92a571dc66dc84025ee93d4753bc8df8b05e452b33c41e24318dd51128d2b7e6bac7a766f48641c06d18a976a8c12f9ec6ec24af61cda9e120beabe2846a6d32c23efec88a817debb2d73c9977d06054d87ef0b44a685bf4c01ae1decafbb7b2176224f31b86f018052c802642e0f4db79d77b8ec49e7ec91fedcd95c1cbcc007f2c8e3391d51d35e3c0a6fb0e53f88e9972b8fd67b7827c96dda9b20fafd38d05ec4ad2cf2827fa62e1567ae3b81518c9065c58d9e9bf95c94b05e883092d70f501797bf26e03ec5a06b6a0ec71c039020ca9d27359152a54efa9ca0a1dadc5a637c968434acf9c567f24e6567bd218e53a58c40b52971c7748e57dd0af1034f0dcf2b32f9943d631238cd9cf822b1441cd62fcd7ed2a5e6f0eb36b525c8871ece81e1ee428a8975c6e7c8c2f723d296772fb18bc208698ee6a288d71e82521232b8eeb23afa76c8a0969ff5c03a4254b3479e4d413e40067dffea005cc041e1cb96c299b03a34603816dee8ef15ea63383391b3187091107e5652827bc88dfaed424e41ddbfd2ee1611b75aedb9a7d3c0d6f84167553ad9ba889aaebc21534a5deb764551c921122c1f6f5220b045ac39afc6be8cae35cc87e5429ef88860204d19ee9d30c6a36e72817b8ee2ae8709f864bed39e3e496152f80233c2361c42e09bde684f7dc771dc9be56906c1a56ef943584c9b922a889c2dd8d832e2351fe3848fd52734584d6e1ec1f5ca17b9e710c025b21c89477219d60f5815803a021baac6d47f4e1ef406ef0b3272c38ae5fbda9c9854c827522cde9c4eab8b49d405b0f4edf8ef4420351d665f9f6f03f893adba2c8595e85647ddf6fad1a342665330886b53de880cc70adeafa53c5c9b24dfa6544a3313e339e9e337af6fccb936d5876c49dfa0d2acd5dcab790ebd74c84f9f540ddcc23902e37d02ff4ba8c09b9fa8da7370e00d0ff8fa394ae63d2d9fc570912a48ce532b7e784f4de83125162ab58074923642198d73e641e65f548d8b2e48c559b87a6f0f93e33b14e047c8ccc7c0d4e3118687c38334a8c9a955d4da47d0801462a6f067e8c515786ded39198bc4c9909ff04ff8c250e8068807f7ad4f8840233f11dae62a99c9c7ac215d860c159036944ca7cf87d5e3eb25bc7d2da8d39f69eb3bf528833ad8baef2319651077518b29fb5b5fa5dad5f64eed7d6fff5f5133c779af03b39261375be9aa041670baedef3f177be8149560c37cb73b7a1d6aee6a6936d792d0d827c6468322ab230fd7b0236489906497a902301a36ee91f2618d846cb229c675378cebeeaa84d9e8db50acf2a28bf000f14925ba9626149ab85ed64c6a45f5a974e1960962eee7adf1774bae337ab10c263852d22b4e1b8056b2575db555fc3e934282595005acaf7a547a53e74209d90277d26419178cf35f4e1c074e1c86725218ae34c0eeb814264ab91f525d7df402aeb37a15c6f49dc6136e6635463b90c4131a947523bc12ed158165861d3919355ab6e373938b8dd53416297d4b8d0a2785547317e8aa9ac51b8aa6ab21e52afd8db9d05c101ebcd387b55431e73d3f814ed50a42bfb0fde3e2517db75d3cacbfd879666dcc675b36735da78b37d2b985207db4106f7abbb245352350c870e3d8efd676b91a91abd77fc511dfb4f0ec70fb708376747009a191df71f3b77c44f2e6ac77d4b18f6aeb0945c7abfce92448d1ed53a57bd6161c205b135365367273bdde30a302506a4de958d3af22ce403bd5202e2b79d8ce96c3207357b8942f9e6a833d6f2f13c285d0543d7097bbf2d1056220a07370b0bcda28c5a8b424211838167fd2236506d64b824bdf6c20b0a0628ace43e9bad7c5bd704b6dbfd8632b56575b27a06578a744698345d757be7d7dd0fb8ba8ec9d68aedcd681f2574a4bc7c786d85a07ed35656945e221ed2c0f4e2ca7f3e9db80a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>眼</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E7%9C%BC/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="439dfe845f5a6c2e9a5f65ff3571f19ffe8cb9e3b100fbcdb9a8bd7793c87bf4">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7a46464cd06891aab0d8be9a070942039a419f93208ebff4ef4007e9e34bc9944085658459c1546d09bcaa9f72d106645c8eb0b5bd9c2a1c5c8063ead401cceb5fd7a7b1d40466a3cb64bc49accafee2e0c866c157160581d8b20a9340f5050979782f8f7a793741549459445c520a45687aed56cb84ff81601fb0407dbf169eb4a992097adfc37da7793935f897b176223e08b5882e2e18b72d5036095b1f56ebe40a748b1ae9f177a98559ecda7425b468a5aee0a5d79e5fea7a33c2e7e034b8bee3b48fc4dfc0c9e0d502eb6296e31eae919dd5c9539713943f5b99135a17aa88838462c127e62ba1c0d144a1d5cca8e81bcf987956d9bdd837e5634f9d75b2e5644a33ec2a97ae8f650c924e05f98ab610002c52249e3df912c001b1d02d406bdb385719e0789c08c2dfa6eb7b900ab591939a2ffd2e0792412c71f69c4bb1a28afd3988688fdecb4d346622c44ff081001924857c8bb4c161c0704fc7934110d4b02762287fc7ea888130d7335ed24f920c40bbbe9ee34c456b76e2870e4a45da24fd6cac7677c4cf7b4d4749c5f337e8b42fbb24ecdcd2a1673c923b24f3ae877cc8b4647e7f2f0371392f3e8d3e7d0b4e729f1d140557a705ec930e08f3d447a1b06c0f8074100cf00e63fe0eb9f9278e2eeeebfd5727bd99abdc41a88672c39e550c4deace24cc4594a859225fec175c11fa4f4d251e5282fdc17ffc46e4c799ce49f341855bf0f7c2614a31be9b08186645f7d4e8fd88a741a56c4fa893000f0803554b245b8792bad6290c2026e8bd58ead336884069d6910e5fa013a4738fd4343458b61eeaf42a364bedfb4b89affb0d5324bb3d0e6c8f1e1f1d657723b86ea6fbb56068b66b52f9dc46f42567a97c13db5716518ad32198427a784050233d33e7b7d0b1c81b6cb202875567b76140bc75820c0e198f0da37da8dd5c2345b5175aedc25b62f77745a9d022a4649c81a0e8ccb79fefaced2b2cb3126f26f906273f967e067c8d72f383d34c6fa2e8679bdeeff46e472a0c92c1639ec04f40893bcd0faaa40b4c2327e1baeececccc2dcf4bdf9c4a90c9bfdb0036ea774379352368085933a830848459e733a207df0ef223887c051c3867ff9a4d71cd666824b32e0dff8b77a3d2e628439a2d295e4430b52b2fd8b0ccddc34787230c2bf866c94f29a3b7f785a2db288656a4731a1cf8729bb13fec3238ef0be83efcdc8f6191e1fd0f400ab3cd204bdd9e030d20109a3a72c26f705bd4fc2124b8695bc9e96ffb50da647b613cb7cf3ca1192cc0c84bab87c7f244ad51d6fbc1b4f3f75d60c9734a04065abd335b9234653fb0207441fd39bccc4b748e95a8dc7a83166fe563080c42e2d72cff18ff37c155d8d84a38e23c46f9b292e26ea0819f2c18f80d80c5a367e971e18449bb8a27dbaf8c99b23bfbc7362cc134c486d81c9b02b7a43a0c46904f3b1330374a9ce171ad599799691684739153bacaa458d408d57a681c21af5504dab3dee10e4112723dde851b6cd03fef64aded7578ec52da1914d1af62336999a359099fd354979311db2d21c4922b1287154c9a0e84847e4e914268bbb9d39c2850f10a047e1e590051a42b3c6a926fa1649843da0b10d8f375da2343cbd73d54b657449e118faf40030132f95426bc0b337607a76069cc5d472717460e6c8bb7ff1863030c3483ebe5b4c01e70c91adb614b8307bb21e1d683da975e3c27e8f045759f3207cc17dbf8d8cb9989b48c7bb8d071eb33bf72a2f53b40e97cd2b1268698fa93c644629d454b94f7765623d827569249ed5b798f0ec91dba24b23a93edb15348a76ef259b5607106e004b1a46574340d37806b6409e8cd5ce767f9c9e9207067b0fc3877810ecca683bd629087edbb06396831e604f3f078150a24b424a7054e083dad5859d3b2e4aed617b011c8d4c259f74157de0ba48ec6da315b510b5f9451440036ee65823e86f313b8aa60c97c34f3f087a3af1147d18e154b366572e107e0e683838add96ac4553b288c4d6ea4fb24d6d1a71a4dcdaf933979acc9a283a2cb4c2a05a759abb86bd808cc5032e6a7bc644e5acb6da88b335e95b3bb609e3ee7ff5a2d2d320565845bd7504d06b9f18b32a31f73e7b6801b3a9c097fab36b69d9dee2c5d6d203be7ca3cdaadc0934c015b909374c159dc842e1b5129ca819b39cbb68b47415c9dc8462aa5ee94040357b819152f559d039982170dfc268d6c258f7d0e8c156a6d7bd057a51d673c35829bfc2d66b954fc3e23e4b5f0b4396c92574594f2d5d87f6a0cdc20dfb2d413743c4172c7a3ac481a79c08eef5d8c26debba841ab76be1535a828cc10dc6c60289d35347ac4f41a4b556113aa014ecb87e6a8ed94b7b08975c85682ca1751a90e3b452fcebfb55e26dccfc9e69f92f4ca8364bff5f7950badccccd9fc1edac659f72f704fddd3ed3da1e7765c0e38eb8499b98066b162fc9e7dc807ebcdbf9c0c7e865e2a7eb31e424ec6cc3f7f1c0ea95e5a64421b84d390dd2e49ef2b058c130a3a43cd3b0b94191d0760f2413cc163f6b96aec8c55d47aa34f01a080a1cfc26b46307b648e1bfb8ea013726d0a1fa106b94e698ee218badc7e8f9d178222282fbe979973c9c11afd4bff95fb3fedb71b87a6a3d8dbd3e26f65d7dc25911b0f3af085b4c0dda01209178b6381748369ff8bbba54dd89223fee02a5269d803cf34d5d911259ad1825d9040196b3645834d6d727cfec8e686f2d668aaed66691687eb3e9766b19f26391d04eeb0d6ecf6d80a3dc37288e5dc5fc62c46f85d75299ff34a6f66c20230af072506a5292ead0daf79615a18a23d20cab3e891b35d9883fb31c298e55d431df116a278f10b4e0b46278018e116a0a1426d294052040963fcb3a342ce94891a291dc20d1f0ce4e9bb3aa442492416f674c6b2a1e85eba91c6a913a280e5394a5aad4ef113bd435eb8cb708520d90b3f0cfad96f757883bdf7edfe673502278e69194f65067ca439c9cdbe2569a4d842b886c607b3eb775749eaa65d04222f9020688a924d1ab7b242cde6d402cd8b045dc57e14f7441c090601051428f38ddeace3c8e3ac0a26ab2429c39c656af32ab402ddc4587cf19a1115823fac871479a1b57f0b3ca04a4ff3a9c723cde9d4f405fb3491c22f855e82aace24d8a5f9fca11bab480b1da5d15eac499d6fe24a05680665ee22a202a0eeecdc75bc5e96646f3f10c2903f310de92f571a3eac351bcc76b467663d22ad746d2df0c4d0779791a765d0b0528f673513690905bd358a33ed34b8fec00a24c01b0bcfc0a56e30faa0c794bff1443920d35fa596134cb71235eab4718158c80b98a863442a95b8cd586e894235e9c10dbe72b5dbde06a5be0b10174ac3f171fd7e3a82eba255ef2c5f3eb40ad32a009bdb07461107325671e46d664184c36312c69245dfc47fc1a26c31a3f92e0b7294d79c81a68c708116999bdcfe71028b966af0d1dc5867c39299aad2fa3731cc2b15f85a7869b9e802e7e7cf5d750e2e17c8606ee77ecef28b88c019d7bc35638c72a5adbdb8853b70ef609ad68d0f22d274a21719b2d051a35130c031bb296615bfc9a507317a103d436468fbca8765a222dcdb410964377a78ddddc7148268c597d6c7cfa21be86fb509bc7770fad5151aac46faf0ffe1f7888682d6af0af9003d96d31bb92b8544d5b6b61c98bcdce3d12a9257a566c161758e051c5aaef145225b540bc3d79def6846296b25a4d347ae3a758ccbb137ccdadd4a0f1c6ffff13687c9362455e9e57bf58fa4e96ecc537444631d5bc2a05bd50df5644db39e79f6ba1f63daf437d8de3c09e7d2a87544b31d12dd3e3df76326ce592251450e2b0ee5474ef2431275823d649b1c227fc20acdf40b7c6c0f740a063866050bf669ce2ab914810f0fdfe073cbde3a99617c29e998830a77d5fdd005ac2e456418e091accd81f6f50e7982e5e85a8b852b48214367097c5e28571ea1651cf1d22f0f2cecb9d176deffe9413919eee35ae8c25dd6ec8f1304aa365f9ca40189150234665581e46cdff36a2d37638dc5df1f54fe4e3d63b0f150fa9560c4ab48e8db4c1ff8e67e7e0ec0a54be51359735f28f13f2e0389c5ffc5e270fd752b64d1d8c439d87443162ff6ffe0d8ffdd692c22351d40d7fdfa8080b09a45adf42d81664bd2af9691dd883661cbfeeac824ae8591bf811b774a2aac79419acc879a1d167931900a08eaa0a6e73fedd2222617cf676a993d500a1d5525abc563ff6c4344a159700baa1206777f935baf194b12728fae0dc7b119fcb935406f6e68c59e822c5e6983a572e14f7a339394cb6314bb095781fdba5cd95ba0488a05cb6b5fe1a3bcded93eec6b5b87c03e1f56c50936fb423e764635524adc8f201d5127e7ff1bcaabcd4630bebdb7b4221f8e69e93fbf969b63816ad5e6d9ea4497e41c0ed96414cbfb2392fed71e63c227f0b938d7abd33e13bb0c4d8539bb17bb3bc266d660b87c8df01b6e00c4a5b4e771264ab0100dc0a7f48e2c8ad3339b9f158fdd00db719d9d6f7cd28d0d69658fec5a171566bc0e89d1d88c3cd64bb3c965ddca4197cde359e1a878c6b155e18be084778204b8fa21b1aebd50d80ab36a39fe72c0b1b01fea038de347e3c15007e82a375bdb039d53d31a40eafadaf5639273a917c9c1ba6f7117ff972ed1b34e6f354be89a5c81d0a6171bcfd8a9e81185040d255771bd8748b2eab6b69f1c3b17385b6fa3737260ebe5697c5709f1c15f8f4d863a16c8457be14fa72b11aba063c3928dabc3aebdb98cd7c8c1cdc789221ff8dd80f2772bfa5c84fb69f6ecf49fde7126b4a8f7547983bb202c15a8d06c99dd52872cb692d06d62cee5fc246df7fc9081ab89414f7d310279b6f481f64d43fc330390845eb6338d6a582566724049155f0d1555412f2484d358f090017cea9b4fee2edcd2629f9e59d7a2f1ec477640f713d1400d4c3480a1b50ede466e4002275e6a4aaa28c9a3ec3fe9379a1f04ab1d41bfc02193b0ae1f826d6432fb7034d36c0261d5504c980f30bbd191bc7ef8c4800a5858c4297990a630c788fb5f39b6b233544cf8dfe83b961b084f64f0b6c4e22dca5d22be7da6f681e6f5813d8594c034b441a18a70e8dbb92386dca2a1705780db4a64679e45283fbf1f515b26d949277035a42bf0ee1d4f51e960f309e8eaafd3c604b7fee42dd1e57bd60a79068bf2efeb3adb2ff66a27818df705a476200659ecbe84b68fed9a188b2b7990a53f05505d67b5d9f67588ec132902a7a9ce3144dba3fa76c1a78ed0f81bf52df0b6aec61d40035a9db70ceb317cf480aede25815055f8663a551f4d42ebe72e20152db475640f3cb83bfdec2af8d56495cb745fd3c1336a3af5e81c4fe5e250670270da71be221361056f7e925cfc826349ebffcf9f302de47a3a974d83ebd562f6c6f7c631d5a78c08cec2ab0d34ae027d29d971921ad88d877cd5f774f23ce154363db877bcbf08dba45f00941eacb54a2ab6cf2c8a4ae7c03c1d65ff22d0c3212badfe9e25e39406309b3345ce748c3fc345a0f25ea26b21d3eba022624250701c1496c06ab76734479eb6ad23d3d0d4b3381bc7b747badbf10ffa1920fa7a98a4bbbec88a9d00390ae1177319d7af07fb4506d92ab98cb0253cfad51b78de4bd9a1924b1a10c9e424bee21b97b9f537c094ec9be489a9ba59b9957e904575f09744b01c4226aae9f3a145deac79bb7107e1a1f66d84e534eb1e23baa9b154e3ed2c3790c13b4c6e67d9eb77934ad711f58de6236529d2ed7dd7670708b7958b1bc4d092046cbd8114344c874cdc5d74f8517a95e5593e8b9c2c1f01a14965c2e06fd2ef356ee3fad98b904fe7cae8c175cf926a0f188ccc49682dd68e223e8b7370f2879c6f3e67b72b9a3438da4dccb580392923db9b105e22a37fb00b74370fb43645980a28bf860808f34f7f23f5132fe1472e1790d3e5613c821ceabfb2e19529ad045acbe5ba7db9462fa0a6edd5809fc0289c4a3b302d86ea67fbf1ba44a046c91df62e57c77d76cf73ceee301a22a59c85d98915d349c67494e595242fd4a3bc674b425017e1ca3c2456435c3d43a2370bdf3bb44024ac297722e69dc5cfafc5aa2c89e1aaed95924b6f000c338d82492b5f3fe6d5ac74c06c8792663eaaac2b64ee9a30d13a7ffa27cf92578926e9dc7891f021120fb59c38079cac52862c21f51628345cfabc9d476d87a293c14d339a108d288af6596dc2717b6c4487e81144b620c7d8151b863849c7ecf535cee3f312a8d1809970b1f0a9a9e358579384315f648f781cd3e1f25d08034d146529f2f55d6c435d902876523a8270840ae7b98efd316ef968b599d3133b3d83fbc2f4ab10f746b80a8996c2adb9a944414abaf0a4afb395c55c53031588350031df5e638faf707248fe3df64a532c40804ba461f42216a163aabc9b81c7841f060e88b54fe37b53a4c74c6e5b805ba22fca26196778f972854c7cae82c4a6c22d512e25e0fd318d5135179718f3c7ffe3e70a5e02ca930b72555421200f4cca75d8568774d55f6fd3b6c7fa5e580be485720f8b1a253a5e53153fd4791fb9f6337154c4e1cf6a7558747a274192e4c1d34f622584db8a8f71d56019e4a300941b7e1265ff3793095097e7ed2cf3ea45901087fedd6964796beb37dcb259b11d991d3f0027fcddbf640d04344063cdefae5671b8912eefa040275276735c37d8b5fdab8b44bcd81af7af3c034a736724333d9fcb67eb71e8906618afd08d5f4bccbdae5feb0cb2c3c93eea6a5663c2e8535dacec47219b7fd9456fd1658d8f766f5a573bd47de0e823a797cdd3bdc40ab54e4277de0acc053328f2c3e9b3a9ee8512f7b36f2a435ea6a0b5b8825b37c1e1bc3c930d1c73a9bd33b381c7f6fdcc25cc0a98bfa838e58fabfbc756f0b6a43ff78309045d87ce462a8a94e590bd4610c0c4d5e97584bf97b8a587a7592f44c31650ac4a31ecd8b1c3cbbad3d1bfb826bae807b3a7a307889179dcce88f19c9353b4a70b68c2469354025c9c8769dbf6e9e7baf8a981cedf9a0d2433e3e33dc5b9990ce3eb8689fd1d2ffce0f19a5c403d57034d7782a0496ff5da19e8fccebf10fc32c5ed4b3ab9a0b5adf488dd41dfb8f19582a48d8a1e3841eb1ad38aa129492de5d9f2d665584bc50d9b2dbf76e5a7fd1cdeb8f44f74c56ac08f4c659fc9d22975ce924db4618319aa3f1d3b39ccd870546cc4464269fef665ae90b75ce1efd2727b78aa87b7691c0f847e95c67f29abcc48292ff1bb3cc03746603c003c41fee8ac1bbdac8004a2f3268e89c386d56d155327b71fd68853568858bd61e4c0cc86f13ebe6b874ea6fb7b52d7c545051da5ad7fff2956b364decff04c0b862952567c9023530bde71f4fffdc905dc5705b3ab9606fafe3aebd97ffc1b0420d96dbd594c3e0a2305f117d24e100d6d872ca31f3e94a44d4b705ec1addfdfb98945bb1b50563343918aa8f84657c25b9e2e29fc52380c7d2c2e2bad4e41286b2657ea4af126eeb24af9e3afd29f442e2afe1c7e03de4bf92f9fa9f9ec1112c46b971d43654336498d0c71861fcc98b561528aa946a97f3fd04be188eb45b668a001ffb5074e966a7faa6da902d13b83a407fa2159c1ce9314d2116296fedcfcc4ba50659c38e2180a935038563c2b863043148ab33bd5fa5ebe26c7aa29acbbeab3f5c4f04b359026d3aa98409d078112153aa7880e1da279bbbbc6947f4105c7f203e5545b9e4f612c2c8858952603d87f2a148716f406f7fc76ee8dbe9e6a9e2149e0f514209e4a6024bc038c2f704ca64de74a20751b1a4a1a4900ff89fb7422a926da6d01f87e1033cb53cc29a6e45b558de4fef1a9149b14c29ffc78f97161362d6e13cd5377d7af4fd042afde4e6f62b6990744ca19d694dc1b3966d03274d75cde76a8e54fda99163921aefa6ab2679676b2339e6d5244b1e52c079d7632c4a0d32e490544c80aac146f96fe8ffcdb74667a56e004bae499fd93037a2bb96bf59f23652a7106b724ecaa59138569fafbb5bfce9029676ae1a8604bdb30ddf2d8597a43d5eeeaa5c21d9732f5469503561caecf7b7f5eede69dfc3cbec8927590784d99cd4fc18f9bfc3aa012be021b4fa04b098bd54eb0a0c5de311486ac44ba715c246bce931dc1951ab1bb3dd4bf4a682ca11c2894fcbe1c41b044c2db3454f18550a3d078f558826aa2c171a80dbfa455ec514a7479b5890d85a427917fd7912687623bdc6ffcdea15aff20dc21bcb69e5d17b233a557afdbb02ac645a18f42634f4629f3fa94c06fa385b73a7a4500b2acaefa50466990184fcac6d756ca8a1905e38ef7b00e4d2adf1659a83ef9f2c39561c58f616097533d10f54153e8d003bb6b5195e5c124cba4d360d8fdda6935696e4b6c67f1efabf9b3bcf5175c81d3d884112ba9f137172fe3b967d964445f581b4f030bb1094eefbc92035c12d4ffe3ebdb635b3ccf7bb88bfd7b001487b136869f320c923ac42c64f23c845506b1cd693883f20cb9ded21d91a6fcf31bdbc19402ed0d50b6c834e3a870c8aaa09499b3cc31c05c4a438aa08c79a2ab5bccb49214000681e35555184937b962659cc54fafb1bf45e10f67f23e58ddeb7f1f0b34d3b8397d24c2d6f274b8067f3fcb164301232f7d5e8385d91b8895e9ca94be610e6e799570b042823628544f085dc02b77eeddd5f3b2b40f7389bcfdc111f22b1a1a009923301f4af090b3efa1e963a7866389decda72eae9030d1c33f15ff0fc0925b27c65cf8f8645b73770d9ea3a98b5e8566d27e341bf573ab2201658945feafa3c0c0eb40ce072bcd986ae6f5349e4420d866e4a35ac88866b0f8106d02d37fade4259cd49068acef8130db60a612bf5ba0f073346c8653e019ba5c0cc9a3421e840bd2d55b2e466e377e348f6f1578285444d1d876a1bee7f55db07ecde31f32966c8abc2edda398c3fc89e2cc1472335980bb1cdce7cc5618515873e242c56a39c01abdb88a6ec52e9d94c993f236e00c084312ea693005c4e69a63d05642bee3d243c342ab44ae4647701b689f6c1948b05f0192e7519a3d405e670fd7c9b379b51ed10523f2537ee957ad810dea1e0b95d3f272b55b57e94fb7c5c63b51ace7c8dbc4e3c6d7beeee3531dbe2391005913ab2c52768b43741d3cca7bbddbf95510466a1bd2121824da4d67bfd5efc1ebda6a86dd653ff546b553e43889e35be6c869a5b78d721cce0ae6721f9224cf013d4284a23620dbcbd56f947ac248d96b11d1dc8b2d74df160c536aee0d871751ec24ccf8b49f436312275fdde20b59f0b2ccfb975fee3543ef5abd76b254c912742854e7c148fb4af0ec02022e5bd366eba4d00d824e815def9c4cfc3112f3573a381433ee192082c07199cf6bc6031fd4c62f26db373172815ef672fde2492929b485e79fafa7819d95d8747292ded129b715e56556fabf4dac72007c9f700c36d857f1b37784d33b19397dc7e32ae988bee3db9141f4fbbe981a34c3f87d788b545733a02a3f5e267e1f407f35af39d4dcacd73f838972e0a8430b476fedc48407e4a5d5c0052a32b442e23015d375f211d0aad7a3fe2177dcbff6020d22ff4c768ef4808f3145300cebdbb5e045bad502f269cab53d4db1bdf9de51d7b1b719e23bb6b533dad2d212d8604225b3d34161a4ab172ff345a3ea2c4c0e912fc907973720fb2b4c1fb5772029a6566bbc189ded33b93c85d53f2e92ed2fb4d3d67867bc594beba48f8341e8a00487996d0701019df824450db37890bd4040acce09281994c6e6905201f26f245cc0b8e83a196c439cb7c1e68338aa145c3aa333b66450518bd4a184f175f77b3873b4529fdffcea201171d3d3b4e5862afe85c27781a8e110a3becf6a8ce047ccc7c3fe4cd598feac0cc09c25063bb4ff1fdff26e908b0c7b922369ae26e74eb774bd36adfc227f485e987b67e653f2b8d017cf063596396c65ab582d620785d525bfff554fde8aee4cff53686fcccad1a1e4fdd0f9dd3082336920af7734901cc3e55b7b446744818ad7c25ad947c9a96fbd4a5fdaed5f12562c7019ff956ab9c0f32a51462a165edccdb6e50344390efdab6877c4b9f778f3c1fab41737deffea7e676cf99aa67a9006bfc543df334d624412664e9698e7e3e70be7199a9e0525715b92fdf19215d51d91983eda28621f3a9e670fc6ab8564bf563d2cb6b30ce907fd93b4b21e656a694294518bcaeb56d963297ba1d95777ce3b12f08d001143ec424bc43ee21aea4b4245bf0ad5a159eebe9ec9ed7f7313ae3899c3d0c88e65f477741f9bc6fae284b80853d2d231a2452a9b5ba7444290174adfe08a970a97fa59344f1b588e107c15aa1d50eaa1d9d891f39b542034db5d163cb99685800e05886239969182cfb756095eeea80bcbf902bf792086951e31532bac1244e4fe05a98ddbd45dd7fdfa0d5a63cdf7c1f59b611ebb2396fcce52102fd4b2774aa4cac42a0bd3b4f569ec0bd67f4e505d03fd7f69aa72125dc3656ad3c9dbf4c3901d5c56b4d62c5af66299a7b95ed2ee6c840b32d6811f2decc74d3c37491a03f727121b7e5c467e2b7e425c10333618357a00a701f460846503d711d8aa5a00de95cdd278318dd0b6665fa03fbd940ffe480f795f512bb400efbc79d187455b2f6b3b8c8d97ddcb8dd08d5aded4b63b9445fbbe7f86aa08214859a5316eb7aded43e17a4042d2a42721c8ab122d5bb5ce57d106fcc3bb89f88daa1588e725a54f89f894c5816df96ffebabd7bf0f5c22ab00c456cc99cf46853b147e3262350ce58907681fa99848186a9d0539bb4ee2b5afadbc3c3b40b545a8df7243e4c935f0af836f9a97aca9c3e44c068df09fa229f50a529b2d78dced010dd46d178e5622acd4eac8258cd6717bd14795bd06392b4efa26d262b9f370f86532239aba9fe7566cf5ff25451ddf95b882ede2606c3301e266b94b8948056f77c21df77ec07dca91359dca2086190b0397e18d9566cc212432187f48b44622d60a1064565061178d736752073245ecf00da4905d3e07529afe12c749c7aa7d2378421813673cc8ead016e79858be1709506b13f0e754c3b784a1af463546ea229d96e0b8fcb3f16aee0bcf555ad8f45db89c42ea386d7e8b3bd7e9a52c486bb0d390fe0a0c7c136f13bdcf7e10a72536be8578cf39eeb7338ef4b6cccd442150ffd78ab01b322b2f1aef4a92fe9501b6580240ff451e2c9ae18e86ecc7ff09789731972d3820469da822d0ea667609129dfd686740ffc80ae7b32b73f25ce6875c64586a232a456c2ed8c931db11064679200e5fa9ed330f272cccb0ceacd3735487b9dc23339917f27da256668acacc64eecb8c389d8fe06ebb82ed382ace113e4e79b7e127f9856381ade73a5763d1eb197e7a7156b0da74c674074daa7f85cc1f3751f4c3a31146ec39b1982ab639dbcaebf86228124d7983f86c11cee645517f9574d21c4798fb5275f23b91bd909fbc1079564c47ed86fd9a11a699bd2bba974ffd3e8b67e9109b5994b674c78bb46dbd45c282c86503e83ff093b978d1a4465dd9256feb0dfed5bb963486b24028e07a21aa5c49626938e839ff2136e2ca2d75548597f854a2d26930a63540acf6252b43fe9c7220c97ba0c0056a524b138407d760cb80b5b0306e46c7fbbb8f643d07215e41ea81f94efb79d5e00c644cb397d65f79dc40c9188aa71bf4de49c7b970e847e9f43e4ec26792385bc1d27d33e9bce9af646e5302676c05b3d0a8a760d6b6df778170bbd6ace8ccb61ce8ac2a9ee3669544bfc4b27cd6aff3b46b53671aca94eb0bdd5fbd8cafc56fa0ae6bba7cb7d53c08b66a1e45551b87670ccffe27218cace1b50e9d12245feecf6de59a0a03c927aaf0331992c97858ee239f2b62f2f9f7befb309e8f05d297ada7d8c2d1802b5e3369eb8b0b0139472cda5beb6ba91567980eab6d8a3015a9ae75df1c35942095db960d05b66683eb56aad93201485a61a77c32907b11454531741ff067644df7ace0bb8b6f4888a0a8692be7829aa499bfd894e00edbd7bf9d10264d4299a19e4ac7258f32557461be798520fe04ee3a6c07e4aa33a98b457a65a907a05fd44459cddc6df3a22983ebd382486140cf70b07c833f83ea653785ea6f0d4d58a5aea19fccdbc4d4a96abd3ef80aaa95c6235a577419fce433292c9119ceb4119548d5e48553c70ad8ea04798db7f19abe3d5edd1c8da70a9333c93009745ee78a6746fc0958c2ff950276a1ca6d30b555c68bcb37ae0418a230e57c2af2d778557ab4fbe30d55bd9497064ebbfb5d27ece2a90248151f9b387d9f47fd4607472f0345fa22482548d9385a5d38ce2ec4eb662956351ddf45251d923514c559dd1b290c0db1a1d8c825ab5ba6564ba8373e4980954d09e311b38bbb920477f22edc37920911a220391c8d9d8b956cdefceeefb0758b1c7e8b8e212cf0d9bce5f3193b00376e2cde15b909102cefbbcf46f86ba5370e9df1b110aa6f8d0f47cfc18035d895f11add97a575a273ee205fcd2e641ff21a61b1ebdc89bc83b45bc86b2e9393cb862b8b6fc0e565076ec72e7d992669348df76327293f98873297851efa8091cf289085eddd59d317062c33f08e84919bf446bf4f208db7db6bd5d404aef4014d2ce64929e756d8463d75436a93005896c36b1116191899a07627069e6ef53ea224a154fbfb2a0cb8314492aa8a19b0953702a6c14e143cb891a34063c5a6d47ceec1f1ac58059a21db6dbb4bd6cbb160d27952178e405ce9999df217052f08ce39a6f8c7fa810f6ffcf3910fd25ad3f5846470d2b80a15d79027db0838b5bf709954173bbdd26c72b3b4a5bbc10a00db1da736ddfb4040043c2b5774283c00f14ba8c8953a422c87d704e5ec759c8d7887241f02a41a02771b366eecffe2a44bef722728c344a10be015fdbf768901efab2fbc447d0976ff3c74549554cfb9a686fe9b80f771644c6e436792b1c45a0bea3f530c5f01a400b0da94c3696a54a55163bc5b057babd5208351491423ac4a4ddd04f004d001bdec83023114de81cdad314159e235ad5c4a705b9cb1e9b82b0f4d638226536e95628fb3d1b0a4195439ba6d6f6726af57867345dc634b5be6154e2e1c9446c0753f0b13824485e82a7227c0a74b137c9ecb0b2c6922c3ed38f34d4445383eb6c4a9d843028be95dfaae60e7724f9da052fbc977c9d987f9443ff2cfcc7bbabf520c4217489062808c6fd938d255437f96660024a117a4062d8a51f19201db50880382a2ddc7095828eef9e06942ca16f19fe965a2afac429aba7a9d7ae02845c547cccb47c4e287d37d1622e66cf7dca6c3f5e5a70f9714e3d7c3a7a40d76506648087271e2dcd6c1650d801fe57c877b39e75b41c0c8a4161f2bada91eb8f7dab9f819898c5b7c133614a4520eefb6e72692502c1c697210173b04035f47825067238e7ffa0ecd0a2602680d099bbed190e284bc104e1e0fd7a261516aa850174a8a033a4d4ca7cf6ee2b6afd4ff00963947c469755b058a5bb522608745a44c7154516fceb29c6134cb380d8a6eb654bf438c89329a19dde0b8a4a02ba23de7d4de72940d7892101bc7f025d4b309b180c6cdd5bc2fea111562778eb4c4343846f3114fbef1125e298723cfdea950ef9eb0e9afeb05f456d3e23c027742ac7291fb26693db81796dfb388e1b2a4aaad9e85d141cb80ccf2f9e2af8b9c38e97110067e62d0520bc0fe8bac1ac22d4d742d3476643a3f758383826716534c1b00ddab43faec5e8634ee071294a0b3d0067b071a3274e96b149143f1a476a5f3fdee9a82ed9499e5bae4dec97f334b73f0896d375ad2367c9fab80750425ef11a52fb8a2cc211975c79455e9b57d41bf68d6aae02a1e8c7d3d0ea17988a49202277a7e783fea9d43c6122682c8d8bbb3cf8a7cf6dba8afa9cb9452b417e9998518d1fef1ab18eeca6ae1cf01a1e2d76fa2f7abf8ebfd696f36defb8f92037eabd85ce086660dccc3d5aeff6fd630cb20f11c6d4e41ff30aed17ac2ba29b23badb4a9c87ccd78a2f7e5515f0478b4f82cdf4ee923891ab6b14fd60d9c61c5585d0782e26c98e2172ed5fa1a61921ddb74a49e0d91152fa67a690a0604af15aa1c597a16ca7fcd5cd21946dce53644a37b575b8291db7acc87850dc7dcf242f8576558ae971de1f9d01111eb1de6e2820a12fd907da28e2c910b4918d0515122d2e9e55a0e79ff243eff9e7c0d2f32bfa9f7255020e62ba5684145e43e3bc0d63be6f8e84e51c4b8e7aa50dd28c6f2917f394c02bbd726fa79c23ee39f7b6ad00ceda3e9bda6db102a1cda124b36620e5c9bd59a6cf51be886a4381ca4d05b1e55a83536ea08e0e9a7dec342e40e1b4e8316eb34066effb460f24179a222dd9951f128529f74ade2113e7d522166fe78655f06429cc0f730a82de42dbd573bb308fa4a65bc37fd25991f72553954712227d2992439af4937ef601eb01ca52edda5127ea771148f9ebd1931793b013126dc604f3c4bda40061189f5b422c2e8d0a46b0d21147f98a341632b81991e1da1ae8f589c706014661700f0c11b2219378ce2e9a64a4c31c7ec96a14e2398f5a80506a78f0d22d1a28cef72d56ccefb3a71cf8fb36a28bfb0c27fb155340db220e037ee65f0c729f01cf5c36654ec5ca6daf63cc85ce60ad4df47ce3a18da78de632b5dc5dd0e75e166418df7f66644913de69912619139296246db04d894dfde31255b6b25ab0fa11384b48e100610c84268479c7e60073c18cc3e30a08ffaba7a188b0bf56b5a7353569d8f3d3535b83290dce0eacc7831bb6472e914cdb775a8c0298fe31a170ae6bc402bf990a831e04c5a1269242ea92b254bc9c1cc73f75573e9b9ee8317148866772879e0c33c7e6b5f31684cba7bd4e046817a3cbca493c43df944b506d675623fe7a640f59133df5ac0d265a6fb0c005fd5b798791acc90041db451d100fe3280dc08aa4a256802b73a2a9e30d6ecc7093f19ce6c2e4b731bc7eca50b615483447a76d92fc3f0b13bab77e818361c630b4deadc8209e4fbba229a5a4882a284f9d693d092d8ed0d910045c7a8d96148a657c3c0a0ba1d3b401d0a04a180db861f9ce0ce4709433c10b4f095e3ca9534394b3c56b3261672c7ebff80419ae62d7f282c24d4573fd7e84f1b1e7436ecb6a86d0f94e1f6e7ce1099031a2154572ffbdd9e50d767a714463625eab3b848ccbd2a4bd9e77e9a06a63658da637d63d30c7ee42b60a4fbcd3ba7132541d51a5d5eed0c167d53499de9592a9de852a872d450bf23c365762606d6fb49b0dbdaa4749139561532128e19143a36e1674193d9bbcf708c505fb92a1e5f0b1f1c83c2780fa9bdc4e42e38702aa99f47e12a56a0cbef0e4a7353714ba29e8fc51475e9999982ce0c7602d5f940baed723347febdd5d3ed191f60933cccd56d5615ac8413e88ad2881f12d569850007ba99a1d8945ef443e71e986a836f351eafd281190dcc96bf59331634229243585f50283b49a3173b959d401b442e1abff4720ed7a3f509dbac4a4ce0c943fdfd11de5e35ad716f64ae9514ccb912c93aed564d326bcc6582aa807670b5295babe58980e545082f01cc4d167ed1417cee869dc69312e8c1e23445ba4d310a0d9d464aa969a4d3b601dfa930eb61f9ceb18e56e90ffbeb71d8c5a077c0a40baeb4a23ecbb09c32b3b8fdc19e2679bf4f71e8bab838c2dc0ddf3c4c9887f12d1879f2329b684f5f290de2e389361c57672155d3db7d20de312f8437641af9ac82885267107c2d434f621cf1e48c27dd8fccd3dd3e55c7a28f822b9c0a51a9513e23c3adb942c623e757114ad19fed59bfb7afaf08545a2b402d40aa3daf544c9813e66e34518e5e5289c8d221029c6a17328a694b1838b4457fc063d43edcc632f158b101548a3f5dca450df3582e7ed5e0121241857cee2779dfe92d458f689675fbeee97573af5240068bfccd28aa04e498bf6a09fc4a3a4b027c2b8ec6d25aa9a165034f6bd8bc43bd5c32df37ed4daa2e88e6fa07c4af2bf33a5208e3fa416a59f8162065796937570606104967018ad5dbdd11c2eb47c23a4f4879f05579e51bedfa68ded35c6f89f1b3a007db98b9b5867e6c9a4e8021fa24a2c97b690648c3e764da3a4cd1d9c8c71dfe4593a1be5d2b479f51c1d8ffbdc64f78f71afb99b40500e7709407da3c62bbf3403d140ac50c373dc5e8e4a8c5af3975a601d8cecae95f6a2a3e3964f5ec96bfc4ea6867f32987b36989214ae87b905e5f27718890b5a59808bd326dd562134e4e736f422bc54ffe47f6c9c822af051ac9d9ac85de82fef4720199615a9aa710920639d9640adfb3a519e62e5105d987549600db9a412c6c50beb32dc30a9524e0e88d1844a665e70b85795e466fb464040e981ee775f0fbb51ab23e4678f81a9375ebea11929de18abd5968f62d662454f7784685ac5fc95a6d19917f713a3c4a319e7c1f0028fb792e035245d4b1dafc9b11da4699601ab135a9b2ad9314dbe5703affb30b42069f350bdeff341ba221a9b814a6473b494df764c4e85a95c1da9870ac75ff28be7d347b0a96c5c610b9ac5fe263e16a09ae93fe36298413438a3d6d6f8e3d8eb7529f7bd6dc4e76ca299643e3b20308a0ffe215053e2a4ff6d4d93fde4f2762b3d4ae2ca90f16e89a5b572601f87ba67127d7a29b603fe4eca83a94a3772a5f753637870cca5f669cf14e6a1ac73be8915e73e4f6619376ac5ebdec57f7526a396d0602f16ef913644053c9fb1b03ad5d845c803aa865ed1579efab9286546fdd8991cbc93476180d827a8df797bd7f44f3f0d756ad579dab2827c409190186c6dbebac4a028e11525fcc0dd9e0967b695a3b7a9b6b0b23ee4e90513ca48cce0c8d91bcd21a6bf055f54df98894f79ecaa59c21e3f789fdd70da7f666e60fa5f9f068e85371198a0f5d9b0d977d7a2c5f9f431f8d99a8318b110a72639707653744c3705a12b7152571b51253bda5734b138b03e20c099b7b63bb6bd64da5b80a1677c730cb8afd2ffce3813acbb92cb1e01240b0527eda06bd9bf5aefdf16c62fd1a741ea9d35a252400cada93c4bebf3f25d0f0f9aed3a4f4e73188f39e6ed9e362b905ae5d01e108e466b677f434795a9f94fc36b77fa691a30505e3e7c763771e24402031834b9a702bcc6235c39678f899ead015ef8a75a06f8bbcfd308ec9787511784f3a4ff2fa67a45c607b2ecd53593ccf6d714c9cb3b23fa3679ee61cac4cd1e8d536ba64836d5a42da81de444e9124c207b7ad84fdbc26fb2ee3c217f925bc670a3193b61ac7fb0dab0d4f6ace2ccc32d5e5a2514ed3762468ba059da0225fc2ff28ce5a2120c438b0f68b79c1454797625f3129356dd3d84dd9293973baff240a4c6ffd40e6ff1a570f6df8336abffa230eb20aa7331c7f1ec17c95faf895e8ecbe32832500f460ae2772ac2367946ac86f50da49aee2eb8c7be10303ba2d30141ee5b4ce8f993b58c85268275040dc5b6855fe0eaa2cc4cf2bf4589dbf181f6d56f01c96a5f2a2c0940cf92d0a5dc4924f333b7a77796c5675fa95f3cc268ce55e6f3a0071c1cc690064d21d64ed93fe0528916ef2b62ce4ffb40a288f597d5101dd32bb0a7bbce36dde8848f4bcee5b70c692d72b44cd22f1d33f61f87a258c06c723383af7f8bf292cfc2a9de3712205e8a78a6618f8b3d16971510dc1a8e97193d0477c03a07fe144428f72171c5648e55c35faaa371dc25656976514fe80404f5425fa8c68a2bbd67abe61f863fc535085b9b1fcac3c7e4fc3dd4d63369ab7f08a0a48548e3b75bdca43a4daff78398225e1aaa19f1dd9fbca3d8f38dd48f475a06defb0eb2579ade6aa0cd788ff9d1b842cdbd346d86ce3243302e4cb6de444b6436612864bd17f8689f93036d406280937620c5953909765b5e55a7432184167e80132a3a80e2dabf3867d8e2eb7de295a93e77733f43fad04cc1168d82d272805811d7d679ccc39e85c26da3dec82a49cd7e629ec0d8e437049b75038a9c185c33b517c5e34de0fd0b979694d677dfa8486115fcf7861de5c263bb33d8549fe74ddd0d668d15bd32e32787c86de8dc614a04a8187f86e2e9eaf853630e22da2daa4b2a53d72c50d3612a0bee4d02a80e5df81ce1e07f55f4374904d7cbccdbc5925a351c311390defca7290cd2e424502ad7fae574890518f0039c10d5ce4c8c0889bb3dd9e45655773f650f950e2546d2d0f10face62b7d22b6475446d2d1e787d42c12809cb1c1c1a25cf1661411fc782c71d2e7923d59d7e3b400c0948016e6daaa02b593d4554f7d1b01ddeb4828288aadcc7c9ee3e062ea4d94422f82b14b534b64e723db682a3e10561e6a416ecc99db82664a847a9e929a65dfc82bca8cb6390cb267f208fcd96935c1e4a4ca740fbecc5a652c88a91435c86eafd62ccfe64c00b663885f14a9342d6f905b879e4dddb4eb5ca2ae7182f338c833494a6f2d43ca1ddccdc23130f7d060f93dfe6bf306614a9fad2ed8beadc2d75ab02d4f00c9f8c30db9e65fe1bb4959eee1abe9d65f472f55f7b867f07ecf48449bf7c7e7488a98324f1ca5de4798fcf5bda8feed498fd82f5f9747e1d5a0304c338d8827c06796fef3e05608a0e93070cdf5074023cac8ff520284d02e05fbe42dd20b816fbe23023fe9f0dcf2acad85a113be946e8b4903dc1e90e852d7cef367f5f702a2318431a1451f37dfaac623722169e172649fc70f2641d94374941a0955f5e187f9c44250390743f9e59bfb34595fa7041f59955d789a96b08aa1e6255a38a1eb8d40204f8b71c6e78d6e79154c4caa911eca0013ced9751d10046e19e8b6b671a3dc7be4111e770aa1199b77dd960b52f2652b83c35b62c3d07c47fdc9d80a6b2a2c4cbecd77ad98132caceb8244b3bcf43b0f692573130b211f2e8596f38b203efa8ff5cbe373258d9a43f87c66ee604eddac6947edd9d063e5a593a3c6e655780fe360c3216ffcd9b1f8e67701f0752e74b508a44b9682a58e50484a36483bd70c7547e7b93482bd77675d9b5dad58be349569805b58971da5230fe29ae4484c275532801a26ec471e8ab38195dd6a85fbe1cd38f568e1048f52ba60fbeeb432bc2b117e01c9cb63a21e716706fd8bdf7120be84c6809b25d3cf0138bb25aa2e707ea0cee249ef2eb8e5569c94b06f79b02d7ce6344fc2addc199a10612a6a956ca4e8978427963783aa807f60544e34f5ee97b949050d11094d69187d4d50df63d4a98f6927f461f8ac137af2809e90248d4c46550c64adb00bc52bdcf71359a21eff48268046247244b9b54c1447e0ce598a286e73eacbedd78124632898facd6938281dc3c0552f3aa673181b09b4af88f5712a4cb0725ce1ee8c9023fe264122c3ec78694cad794429d3dd38ba07a71e34c4bf44edf70cd1eeecbdfa47fe857ec2a633cf74c1879740288ae0e006452018f660df3932f77110cc6cea97df0518f55bcfb4a481c214a3933714346daf3b494f84ce97184ef2a886ee85bc0c40751ad4c61968c70d1129557b428384234607cf7df4e448f0139c608d76316f7ace494f1a6205ad852fe0949a543545956540fba17a36b0ceb5f1affb7a0a98f9a9e658f08fdebf2cd5f9cadfd4c81a5e83ce4b898449dfb21da1786b2db2ebbaa19b14ba8c891cc97b2928b882287116cb565abe3f07842071a45190de693301b732498809d0fcf05daf82c95e24a6f7c7f9913fc31c21f66c634aa5cba994adbab928441fbe4e5d72adefe20f827428c165457e29a255adae3f940110c4d28f8c2233607f666961d5d2f06da155e7cdc556c737667637795cc63775b7437ad6acf0f400f632f0049b4e3479249e29d30f47877a2678b028edb40b5d844b95eec79352d23be7fbc0a15b0f17f7ed9f95a94198f4167da6f199ca1066f5a9f9cd2e0869c9deef70c8cb6d9fd0fbc0806aaaa29e52996f64fd4926c686790d0d3a30221dc818de7b1fc7604f721377c14f38b9259315012e38a2e7812a55c4940cf7fda0381edd9ae15f789c2ea692347b1fcc6fdde309f0776f5fcf2db9680f69fb8ef31a12735093097c0ab1f9824b4a18a6e0378e5296620f91cd2add859b658ad6f668d0364e396d0988e2b819e804d4bfc5df37ed1c8ddf9984b7e70fabb66aab895470bb7c45c64cfd19c857abc45a040673bc0569d9c48d3589fee39e706811f8685157d21ccf8b1421fd9a502994a9061efb510839850903044e502d402a0eb3f9e81df83ceea9ae2999ed20314d702f39645fa34e17cc64bb288731ae9f36aa8315fd70bc4acf71c756f65204e0f50a6f197fefa4bd983b170beadc44614a3547bf0257686d83fe82dba0927608ec603191ba229d556f3ec33bea6cc156adceaacd1199a96ba49f28fb9f677b1f76d5d336538c18375e5fc3339d19e83d399c805f48c0822c4f3fc1de8050b23ae2d288355599870a77858a697400d6fc0a5ed42b5def587eab06678123544bb751647b9054c5ec841059626bae4ee472ff7e0f7cf1fb0c2e129d823c6c17a3ace94b0ab22c1efd185723e54c7cca833d6f6a64fef9ec205b6cc7f0e3787662066a42830505ffbc39d042329acdf567865fe1d4eaab482d0ec661e278dd95ca18a08a9d2f18501b4ed4a7c142c7f815958414bc318898fb76e08f512dc7f7e0f8b99392727db265d7ba2496e8522df321b06b47eba75014514a5d0bbd8f78ce045896073814e22f9eaa722952c24166066a60202ab08880ba3ad061a6987c6f39b1c39e1eeaf245983f63511518d9dcfd032676d3e7a7a9f070b6013ec2badd2cfc6d3f6b6c6c346f195604fb170ceb2cbcbdc5aff8fb68b924a3bbf7966068358710a146ec357d3324a758d1a272d4694b223ec0e3fcfbedb2db69f7253ff96172c41896898855d3fcd0cac3afa1c4564477021410ffc16e9a8591b53cced16eec4f6ac5784b031c8cdb0386d24a1542b4eaaa842dc3b7e06e4b1f480023a9ce6739e2f1ec63c25b00b20c96f9e6ad5f3e20b8cc4dc0e7ec438fc98079347487f4a914a17e6338cccf458733df8c11f4330d2476ffb79ea5ef1f8ffa8a7dfa981ce1662614e9d7c03e7bcb433b77deefd514194092dad7187241a463848b98595593f1803e90beb6fc465d283835018728252af014b628954f4245dc6acad4ab8a5a939d9bfd87af9d0d69a25a657faa9a4ba49eccbe6c7e5fda66dfb2418873aa621d895f13f7a5d2da3dea3a9d33a92f8ba72cafe8e2f8442550fbe7bf38f4374d69a932702d5c12923b2f1794e841fcd29d2a5f46e613dd2c5d34fa78a27d06f811bf26de478eed9a216b48fdfa866dcf0c1186bfa6d9d891ef9b9d58e2fa9d6bf2194dec557811a2a88f9a0676efabe99589cb4721b777042b3a1ed35c18969cdc356930549e399e036cc1ea1a37c5e1457e0fb8324b40a6136a53a54a98aafa83c1b7687a41140ce944c8ae1fefca9f7471cbefbab7ab4d0adb2807419e2f10d58fab05a1d20e0efd28bf62316b1cd8f4a51b3550e6fdf008efe05bd79e9005d5bdf46ea1cbb3e44b67d3f0cfd21bb23d2a10a88743830b0f4c867f05ba2e2f71acc32d84c156ff37a6ef038fd4025ba23a6160d0525d234ddf63e1239dd7ebe361a071d61dd69aa5079329b9c6e916913a196e194ad3fef550ba37acdfa1ecaa7028c23444c38beeacae71bb67b17a3e4a1f24e08f14b2abfb25f0ad0780c6df134fc7da4019e2c7b352297be0fb9341f0abcafcff1c373faf525b6801a89f2469610d7d88063b5b1aa39890145c5961349e74535816cffee7d0bc670a65a355f5cdf258426d14acbbbe90aea35d72f1be8438e6127787a0962fc33568ee5fe2794f951a11682ea05f48b5b7706b4a813c794cbf650f409268787e8fe329aab6cbdca5e973cf0ffa4d61b5715bd15e37e84da84ecd0c5044827b5f967f111ef864a67a6ae14b36184bb7fbaf2b97ec1ca1489e3c857e92f87ac5ec3b063a13ff2bbb7f882d39855f9c6630d7347689a30f32798052d0f517839834f876f66b085316e900789fbb3e117125f27c8c65b21d02ae894ca5d722742e7e97f18969fdf0f204d9811976d1c56f9df230a7391c18779ea2806a0ce006da282632629386ac035ed9e7413b41ff9cbdf69a1ff37c523ac3579403cfbe329d4245ec86e4f7e290ffd6a03aa3b377ae9720af7aee91307360650bfa337653d79748083fb3a76f9ed94a75d3739a8de885ccbbeff6a5366329321f8f8ec35573615251da750ec70597733fde9de4dc6f8ae3e40e8d30621ffdc7e845ee5b0452f4eba9b1feab4474a9007cb508de1ec9535dc30d86f73971379181a2640eb1d9807b1c45a64d703afe8a66ada9155f39b3e90aca957a8ca2aca891b0ee39db905412432146965c87263ffbb34f57644836dc554d68d49492f27dfc75b876753c0fcef89a299a0c3facfee6e52ccd49532cf3e58decc0aab417a0ec7386b040b40cc4ba82bc681a686e8997eced06beac407719c445a6cec148930b2c2e9ed14780b49a6f832761bd29da5b13aed6b1aabbbb981c1f2a1072e5601f95d8ed4686337</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E6%A0%91/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#零">零</a></li>
<li><a href="#一">一</a></li>
<li><a href="#二">二</a></li>
<li><a href="#三">三</a></li>
<li><a href="#四">四</a></li>
<li><a href="#五">五</a></li>
<li><a href="#六">六</a></li>
<li><a href="#七">七</a></li>
<li><a href="#后记">后记</a></li>
<li><a href="#后后记">后后记</a></li>
<li><a href="#后后后记">后后后记</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="零">零</span></h3><p>村子西边的高地上有一棵古树，没人知道它在那里已经多久了。</p>
<p>有一位游历四方的医生曾经到过我们村子，并对它产生了浓厚的兴趣。为了搞清楚树的来历，他挨家挨户拜访村里的老人，向他们询问这棵树的年龄。可那些老人有的回答几百年，有的说上千年，总之没有什么确切的答案——这棵树在他们很小的时候就已经在这里了。而且据他们回忆，那时的树似乎也与现在一样的粗壮。</p>
<p>后来医生向村长要来了村里仅存的几本古籍，其中的一本可以追溯到一千多年以前，那个时候的树竟也是一样的在这里，据描述也是一样的粗壮。</p>
<p>医生取消了去另一个村子的计划，把自己关在房间里日夜研究。可每当他似乎寻到了一点线索，接下来的研究又会逐渐将他之前的猜想全部否定掉。如此过去了十七年，十七年后他终于把村民召集起来，宣称自己已经找到了答案。面对着议论纷纷的村民们，医生先是展示了自己手上厚厚的一叠资料，然后呵呵一笑，说：“这棵树，是一颗从远方飘来的种子长出来的。”</p>
<p>众人哗然，哄笑声与咒骂声不绝于耳。医生看着他们，眼神却越发坚定起来。他挥舞着手上的资料，看着下方逐渐散去的人群，高声重复了一遍自己的话：</p>
<p>“这棵树，是一颗从远方飘来的种子长出来的！”</p>
<p>然而已经没人在听他的话了。</p>
<p>几天后他在家中去世，没能留下遗言。这一年我七岁。</p>
<h3><span id="一">一</span></h3><p>树上曾经是有一架秋千的，用带有毛刺的粗麻绳挂在横生的一根树枝上。村里的老人给孩子们讲故事的时候，会说这秋千是几百年前全国手艺最好的木匠的杰作——他曾经进过宫给皇上做过龙椅呢。</p>
<p>比起虚无缥缈的传说，秋千于我而言承载着更加美好真实的回忆。小的时候，我总喜欢在黄昏的时候一个人坐上秋千。因为这个时候孩子们都在村里，秋千这里往往只有我一个。我背对着坠落的夕阳，望着眼前簇拥的房屋和上面在光下灿然的瓦片的场景。我可以看见孩子们在村里的道路上嬉戏，一个把另一个推倒，一个把另一个拉到角落里耳语，还有几个一起在光下翻着石头堆，试图找到几块稍带光泽的石头（他们一度坚信那些光泽是细小的金粒）……而等到孩子的父母从屋里出来，轻呼一声，立刻有一个孩子浑身是泥地跑向自己的家的方向。日日如此。</p>
<p>但十岁那年的一个黄昏，当我像往常一样来到树前，却看到一个陌生的女孩正坐在树下。</p>
<p>我疑心我从未在村里见过她，村里的这个年龄的女孩子早已经下地劳作过两三年了，脸上时常还会挂着被杂草划伤的痕迹，皮肤往往已经被泥土染成麦色。但她却是一头短发，有着皎白的皮肤，正在树下用纤细的手指翻着一本小说。我忽然有了一种——我不知道该将其称作预感或是幻想。但总之，我忽然觉得她于我来说十分熟悉。有那么一瞬我感觉自己呆站在原地不动了，直直望着她，拼命回忆我们过去是否在哪里见过……而这时她抬起头来了，冲我轻轻一笑，我登时脸颊发红，撇过头去，快步走到秋千前坐下，却又忍不住偷偷回头看她。她则是背靠着树，面向西边的落日，借着光只顾着看她的小说。我们如此背对着一言不发，直到太阳完全落下，各自起身回家。</p>
<p>如此又过去了三四天，直到她某一天翻过了书的终页，站起身来，望着她面前的黄昏，忽然开口轻念：“唯黄昏华美而无上……”</p>
<p>我很惊讶，转过头去看她。她也注意到了我，用左手扶着树绕过来……她猛然蹙眉，抬起左手凑到眼前，她的左手食指刚被树上的倒钩划伤了。她把食指放到嘴里吮吸，也不扶着树了，缓缓走到我面前。黄昏的残光映在她黑色的眸子里。</p>
<p>我问她刚才念的是什么，她却笑着不回答。</p>
<p>后来我才知道，她是隔壁村子中的一个没落家族的独生女。她的家族曾经在某处显赫一时，但到了她的某个祖先的时候，却卖光了所有家产田产，捐了个小官，携妻带子远赴千里来当我们这的县令。她没有提过她的这位祖先当县令当得怎么样，只说他在任上暴死了。</p>
<p>到了她父亲这一辈，家里早就很不景气了。可即使这样，她的父母从小也仍把她当作富家千金来宠爱。每天的这个时候，按她的父母的规划，应该是要让她在家里的书斋——一个在厨房旁划出的隔间里面读书。我们相遇的那天，也是她十二岁生日的那天，她的父母却开始想要让她学些女红一类的事。她因此赌气跑了出来，因为早听说过古树的传说，于是一路来到了我们这里。</p>
<p>这意料之外的出逃当然让她的父母焦急得要命。她晚上回到家时发现父母都不在房间里，来到祠堂才看见他们正跪在祖先列牌前。她的父亲双膝跪地，双手合十，闭着眼虔诚祈祷；母亲跪在旁边，弯着腰捂着脸抽泣。当看到站在门口的拿着书吮着手指不知所措的女儿时，她的父亲立刻起身跑过去，然后被门槛绊倒摔在了地上，爬起来一边哎呦着一边哭着笑着把女儿搂进了怀里。母亲随后也扑过来放声痛哭，一边拍着她指责她四处乱跑，一边又仔细打量着看她有没有哪里受伤。</p>
<p>那之后她的父母再也不逼她学女红了，但她还是天天来树旁。</p>
<p>八年后，有一个孩子从秋千上摔了下来，摔断了腿。他的母亲因此暴跳如雷，来到树旁，先是拿起斧头砍断了麻绳，又举起斧头准备将秋千板劈成两半，但劈下去的瞬间却听见了巨大的金属碰撞的声音。她一开始吓得扔掉了斧头，两腿一软跪了下去，以为触怒了树神。但旁边围观的人围上来后，却发现是她的斧头砍到了秋千板里的钢筋。</p>
<h3><span id="二">二</span></h3><p>从那一天起，我们每天黄昏都会在树下相逢，这似乎成了一个无言的约定。</p>
<p>她从小读过各式各样的书，比我又大了两岁，见识比我广得多。有次她问我读没读过李商隐的《锦瑟》，我只说学校要求背过。她又问我觉得这首诗好在哪里。我想了半天想不到什么东西，只能把学校老师教的那一套名词一股脑说出来。她忍着笑听我讲完了这些，然后说，她觉得这首诗好，就好在即使你不知道它在谈些什么，也说不清楚意象之间的关联又是什么，但只要你一读，你仍能感受到字里行间藏着的悲伤。</p>
<p>如此的对话，在树下的这几年时有发生。从《堂吉诃德》中的蒙德西诺斯地洞，到《奥赛罗》中的天鹅，她总是有着独到的见解，像是一个偶像似的人物，如此完美，完美到不像凡世的人。</p>
<p>在她的十八岁生日那晚，她深夜跑来我家，向我哭诉她的父母想为她和一个她从未见过的男人订婚，于是她又像六年之前一样跑了出来。她扑在我怀里，把头埋在我肩膀上哭，这是我第一次见到她哭，也是我们第一次相拥在一起。我一时不知所措起来，只能轻拍着她的肩膀。过了一会，我看她情绪平复了一些。</p>
<p>我问她，那个男生怎么样呢？</p>
<p>她回答，家境很殷实，听说为人也很不错。</p>
<p>我又问，那为什么你不同意呢？</p>
<p>她从我怀里挣出来，扭过头去，然后又发疯似地将桌子上的书一本一本扔向我，鞋都没穿好就跑了出去。我望着她的背影，在那一刻第一次清晰地认识到我们之间的感情。</p>
<p>于是我追了上去。我们一路跑过村庄里那条土路。那个时候的天空还能看见星星，满天的星月仿佛都在陪着我们一起向前奔跑，奔跑，奔跑……她一直跑上西边的高地，跑到树下，然后站住转身面对着我，头发在月光下似乎变得透明起来。可能是因为含着泪水的原因，她的双眼似乎也变得透明起来。她歇斯底里地喊着要我离开，语气从愤怒辗转到央求。我看着她痛苦的神情，看着她嘴唇微张着，昂着头，眼泪从眼角落到下颌。</p>
<p>我伸出手去握她的手，她一开始想挣开，但我紧紧握住不肯放手，将她的手用力包在手心里。她的手好暖和，手上有些汗。我们如此四目相对，直到她放声大哭起来，将手抽出我的手心，然后紧紧抱住我。我也伸开双臂将她拥在怀里，将头倚在她的头上。我看见月光散在下方房子的瓦片上，但看不清模样。几间屋子里微亮着光……可有一家怎么却骤然熄了灯，灯光挣扎着闪动一下后缓缓暗淡。我悚然一惊，手一软，几乎要把她放开，但缓过神后我立即将她抱的更紧，更紧。</p>
<p>我开口向她求婚。</p>
<p>后来我们在她十九岁生日当天结婚。那一年我十七岁。</p>
<h3><span id="三">三</span></h3><p>再后来我和她去了同一所大学，报了同一个专业，又在学校外租了一间房子同居，课程安排也选了几乎一样的时间：这样我们就真可以形影不离了。</p>
<p>婚后的生活与我们过去的相处模式几乎没有区别，除了我们几乎放弃了各自所有的自由时间，每一年、一个月、一天，我们无时无刻不在一起。即使是因为差了两岁而导致的一些安排上的差异，我们也一定会定下一个地点和时间，等到各自的事情处理完了之后来到那里，然后一路聊着各自的见闻，相挽着回家或者去吃饭。</p>
<p>我们共享着彼此的社交账号的密码，用着同一张银行卡，每天晚上十指相握着一起入睡。连我们读的书也完全一致，因为我们总是依偎在一起读同一本书。她比我读的快一些，在等我读完这一页的时间内就侧着头看我。我们甚至讨论过要不要以后只买中性的衣服，这样连衣服都可以混穿。不过这个想法最后没来得及实施。</p>
<p>离她的生日还有二十一天的时候，她受邀参加一个文学研讨会，而我在同时报名去听了一个哲学讲座。我们暂时分开，约好上午九点四十五分在学校的图书馆北门前见面。讲座刚刚结束，我就收拾东西往图书馆赶去。到了那里，我抬头张望，发现她也正往我这里跑来，冲着我张开双臂，阳光倾洒在她的短发上，直到一辆跑车将她撞飞出去。</p>
<h3><span id="四">四</span></h3><p>跑车的主人是学校的一位教授，他与他的女伴一起随我们来到了医院。在抢救室外面，他静静地听我哭着说完我与我的妻子之间的故事。他听我讲我们的相遇，我们的相爱，我们的相处模式。他感到不可理喻。</p>
<p>手术并不顺利，医生通知我，我的妻子的内脏受到了不可逆的伤害，大概三个周后就会死去。</p>
<p>第一个周，我的妻子还在昏迷。我原本想在她的床旁边铺毯子打地铺，可这样我睡觉时就没有办法握着她的手。所以最终我搬了张椅子到她的旁边，每夜靠在椅子上，握着她的手入睡。</p>
<p>第二个周，我的妻子醒了过来，刚恢复神智，就拉着我谈那场文学研讨会的内容。我紧紧握着她的手，含着泪静静听她说完。然后我也开始细细跟她讲我去的那次讲座的内容。我正讲着的时候却发现她走神了，本想停下来，但犹豫一会，还是用手在她面前晃了晃，然后用略带委屈的眼神望着她。她捎带歉意和俏皮地朝我笑了笑，然后打起精神继续听我讲。</p>
<p>她的精力恢复得很快，这一个周，我们从我们第一次相遇谈起，再到第一次对话、第一次牵手。再往后谈，谈到订婚、结婚、相处。她谈到兴起的时候会从床上坐起来，我一开始还想劝她坐下好好休息，但终于没有劝她。她总是提到那棵树，提到她坐在树下看书的时候抬头看到的黄昏，提到那架已经不在的秋千。她回忆起西面的树干上有一处倒刺，她当时被它划伤过。她回忆起那天晚上她站在我面前，我身后是清冷的月光。</p>
<p>第三个周，她甚至可以下地行走了。第三周的第二天早上，我醒来后发现床头放着我们正在读的那本《达洛维夫人》。她笑着跟我说，她今天感觉恢复得很好，所以自己扶着栏杆下了床，走到外面请护士帮我们回家取来了这本书。接下来的五天，我们逐字逐句仔细看完了整本小说。这次她读的没有我快了，轮到我读完后侧着脸看着她了。当她察觉到我在看着她的时候忽然脸红了，撅着嘴看了我一眼。</p>
<p>第七天，她躺在床上，我知道她要死了。</p>
<p>我伸出手去握她的手，她侧着头看着我，忽然笑着说：</p>
<p>“你向我求婚的那天晚上，也是这么握着我的手。”</p>
<p>我看着她，嘴唇张开又闭上了，只是嗯了一声。我们就如此四目相对，她突然挣开了我的手，把头别过去了。借着阳光在她眼角的反射，我知道她哭了。这是我第二次看到她哭。</p>
<p>她问我，她走了，我还怎么活呢？</p>
<p>我说，我会陪你一起走的。</p>
<p>她没有看我，但是轻笑了一声。过了一会又摇了摇头，说不行，你要活下去。</p>
<p>我问她，我还能为了什么而活呢？</p>
<p>她闭上眼，似乎在思考。</p>
<p>她没有再睁开眼。</p>
<p>那个教授承担了全部的医疗费用。谈起赔偿的时候，我没要他的钱，但是要来了那辆跑车。一开始教授甚至有些不情愿，因为那辆跑车太贵了，但最终他还是没有拒绝我的请求。</p>
<p>这一天是她的二十二岁生日，是我们第一次相遇的日子，是我们的结婚纪念日。她曾经跟我说她觉得死去的最好时间就是生日那天，当时我笑着跟她说那我们两个总有一个不能在最好的那天死去了。</p>
<p>现在她如愿以偿了。</p>
<h3><span id="五">五</span></h3><p>处理完她的后事，我开始看我们之前留下来的随笔、照片、录像，去学习她的一言一行。我买了一支录音笔，每天去刻意模仿她的声音，并录下来反复比对。除此之外，我还养成了写日记的习惯，每天要花两到三个小时事无巨细地写一天遇到的几乎每一件事，睡觉前在蜡烛上烧掉，之后吹灭蜡烛平躺在床上逼迫自己立刻进入梦乡（可为什么，为什么我却从来没有梦见过她）。我唯一不会在日记中写的是，我有的时候会自己一个人待在那辆跑车里，待好久好久。</p>
<p>如此过去了接近两年，我知道不能再这样下去了。</p>
<p>我带着录音笔，开着跑车回到了乡下的村庄。离她的二十四岁生日还有两天。</p>
<h3><span id="六">六</span></h3><p>如今这村子已经没有几户人家了，大部分居民早就迁走了。我走在村子内的老路上，漫无目的地四处走着，最终兜兜转转来到了树前。村庄里的人走后，连树好像都透出了些憔悴，但仍然和记忆中一样的粗壮。我把跑车开到了树的东面。</p>
<p>我在树下睡了一夜。醒来后，我望着那棵树，拿出录音笔，打开录音，喃喃说着“我爱你。”然后播放录音。我一次又一次地对着录音笔说着不同的话，从我对她的思念到她对我的不舍，然后一遍又一遍播放，几乎分辨不出是谁的声音。如此挨到了黄昏，我坐上了跑车，盯着挡风玻璃发愣。我开始想，在那天的九点四十五分，当跑车开到她面前的时候，从这面挡风玻璃看出去会是什么景象呢？是不是一个漂亮活泼的短发女生正跑着迎向她的所爱，却在被撞上的那一刻……我不敢再想下去了，闭上双眼，用脚摸索到了油门，向树加速冲过去。</p>
<p>车子离树越来越近，越来越近，一开始我觉得自己会撞断这棵古树，但随即又觉得自己会在车中与车一起在撞树的同时死去。耳边的风声越来越大，树叶的沙沙声同样也越来越大。我耳边却好像缓缓传来一个人的声音，是她的声音吗？是她的声音吗！是不是她其实并没有死去，是不是她正在树下呼唤着我，呼唤着我，呼唤着我！我睁开双眼，将手从方向盘上挪开，两只手合力打开了车门，在车与树相撞之前跳下了车。身后传来巨大的金属碰撞声。我转过身，看到车身已经变得扭曲，像是死尸上暴起的青筋。而那棵树仍在那里，毫发无损，与从前一千年一样粗壮。我走近树，转到树的西面，伸出了手去轻轻抚摸过树干。手指突然传来一阵疼痛，我凑近一看，右手食指正挂在一个倒刺上，往外缓缓渗出血来。</p>
<p>我转过身来，靠在树上，抬头看着夕阳。我以前总是不喜欢在黄昏望着太阳，总觉得那样太落寞，所以我一直都只往东看，只看被染上阳光的村庄。现在我忽然明白她看向夕阳的时候看到的是怎样美的景象，我忽然明白她当时给我讲的那首海子的诗……那首诗怎么写的来着？我闭上眼，尝试学着她的语气开口轻念那首诗：</p>
<blockquote>
<p>火焰的顶端</p>
<p>落日的脚下</p>
<p>茫茫黄昏 华美而无上</p>
<p>在秋天的悲哀中成熟</p>
<p>日落大地 大火熊熊 燃红地平线滚滚而来</p>
<p>使人壮烈 使人光荣与寿同在 分割黄昏的灯</p>
<p>百姓一万倍痛感黑夜的来临</p>
<p>在心上滚动万寿无疆的言语</p>
<p>时间的尘土 抱着我</p>
<p>在火红的山冈上跳跃</p>
<p>没有谁来应允我</p>
<p>万寿无疆或早夭襁褓</p>
<p>相反的是 这个黄昏无限的痛苦</p>
<p>无限漫长 令人痛不欲生</p>
<p>切开血管</p>
<p>落日殷红</p>
<p>愿有情人终成眷属</p>
<p>愿爱情保持一生</p>
<p>……</p>
</blockquote>
<p>下一句是什么来着，是什么来着……</p>
<h3><span id="七">七</span></h3><p>再醒来的时候已经是第二天了。我起身站起来，发现树下没了车的尸体。转过头去，我看见树上挂着一架秋千，我的妻子坐在上面，清晨的阳光照亮了半面树冠，也照亮了她的头发。</p>
<p>恍惚中我觉得这是梦，直到我看到了手上还未结痂的伤口。</p>
<p>（写于2023.09.17）</p>
<p>（2024.10.19修改）</p>
<p>（2024.10.29再改）</p>
<h3><span id="后记">后记</span></h3><p>那天偶然想到了这样一个故事，但是一连等了三个周才写完，主要还是最近太忙，抽不出时间。</p>
<p>对于故事情节，我其实想声明一点：</p>
<p>文章中除了“我”以外，所有的人在现实中都没有对应的原型！“教书先生”与“教授”原本是有的，但后来改掉了。可即使是他们，也只是对应了早已去世的两位名人。作者无意以这样一篇故事写任何现实中发生在作者周围的故事，希望读者不要妄加揣测。这篇故事在现实中的原型，也取自作者本人的脑海中的思考。</p>
<h3><span id="后后记">后后记</span></h3><p>在参加魔怔杯的时候，这篇本是我一时兴起所写的小说受到了许多认识的或者不认识的人的热爱和称赞，再次非常感谢大家。作者并非专业写手或是文科生，语文成绩也并不突出，能获得大家如此的赞扬是作者的荣幸。</p>
<p>另外，也时常有人希望作者能解释一下小说中的一些情节。由于这篇小说在写作过程中<strong>两次</strong>更换主旨，导致其实主题是并不明确的，因此连作者自己对同一种意象都可能会有不同的理解方式。作者仍然鼓励大家自己去感受这篇文章，如同文中所提到的《锦瑟》，不去理解它，而去感受它。</p>
<h3><span id="后后后记">后后后记</span></h3><p>上了大学后，我忽然动了重新改这篇小说的欲望，并最终修改了大量的细节，甚至将“黄昏”的意象提升到和“树”几乎相等的地位。</p>
<p>我很难说在修改的时候我还有没有抱着之前的什么哲学观点或者思考深度，很难说。我似乎只是凭着心里的感觉去改。这是我第一篇发表在公开博客上的小说，我当时写它的时候是什么样的人呢？现在我又是怎么样的人呢？我在这段时间经历了多少才会让我挥笔对此进行如此大的改动呢？我不知道，也懒得去想。</p>
<p>后来本来想把这篇小说投到文学社公众号，但是疑似被拒了。其实再读一遍也确实觉得当时文笔还是不行，改过了后也仍然不行。但我心里还是相当喜欢这篇小说。可能因为这是我创作的真正意义上的开始。</p>
]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>刺杀</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E5%88%BA%E6%9D%80/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f474ec06a635b0b5e4b63f3f1ed6d85283f4a2c32da88462a9d744190ed99dd0">adba944712a73720e1f31df1fce5374437facb60f406548d8cd1a592f11521c4fc77ac30ca3525d544520ed08223f2795d9e400dcadc70327dc9018f2f8f2cecf83e606f40fc095f0058a77416c3fca7c3676df1be697643f1457fc67c6d5bc3282314944e25240782254b60c46fd8b6fe7652fa7f6f2a44856ad5e6f276a7a55f7a0434c4900b8dd88791f6b64a95234cc0b87213730d3dec77b14b1e44d0db763c82e6a7f3ef1cc8151dd24574764a5ed5c8d12b12c8e3fce77370a5450f15df4a842e77a77b4aaf6d125f9a01a6ed5473b32e030faf8d0e4b3dfd7fa4804e541d2c80850ed2cd9dd9893d4e20f0314b1a3e06d7cc3dd06a5701806106454b6f24a10822de849cb140f56f7cb39201fbbc98ee080ff835fcf369d446389c7883e5b80b3e41d3915a6f21ae072f0cfd88fa38415a67375f6afdf82438c5d82d81525d24c025e4a1ae2d9d7ecfa98896ea64aad70e076a9152347563ad9d417152b7b095a1e3d0dd5e4f1359898ec6b30124f130ea5cfad25b565191435af908e700f63185e746c47735bdebf406536ab5cf27577ca6c651bdb34ecde5694da19f702f43fcd852d9de8b2da8ac3f07eb558874a181a1ff5c0266bde7beebabff25233fd9e81a9b8ba0179e9dc7107a5e2f793bf50134950d028dd7b6a1af6694ee15415aed7739887767efaffa1a9cd9393c263d04b0b967a89cdd0b7b284c3b0fe922dc582e53433e8ba44d7beb316f525ed5d8d66f0c96ce8ee383ebcc0bc00a1e85fd16d2b94b25828de72f99400d50793391c28525baa85c4092fba43d3c77babe63c9984f09e0ce1a016e6a16d1d81754a9fb2f9ca1c8b66f1594c99e84c4b171c5987a2f128daf073ab3d99da60f5da9e97f065b9ab8df6fd50aedd72dfed05aa889e0c072dd25ebc39297947778b29151e1aabf8312324b0723366fb7a6d92ad7f249d1bd16cff7935711d894cd7be2a3ca9b193175053a1b67098283d071318c5060353f6d6e66eb06d5d4ab0f42e2fb6611aa3ffcb58cd63193100b336957c24a43d14599acbe08838d511b73150dcf9a9fce6d19a365ae6f0d5ce479324e0336665e189978e8d98c3729e07f06301fc4d019d34b0c3483cbada0e45ad0e3a310e11dfc3b8b4570c561f3810a2cb729d2496f200b60a5f33dfecf34834b3a2e9e3d9a04eb558a0aaf5eb56803ec9abb92c05518d6134f3679a96f2be7b2b67e862df18c124faa31b096497d12fe4588835424e59472c7db0830376dee5c624d226e22493faef6063331e6720c5b7c62bac9163592f530847b0a74e3aaed6ff6c4a8076af9797f109c3d02039e5dceb4a223b83ca84693928bc70bb42d7cab7da07cf66d7a80a4e5cf4070f257b7895b85e58863d1d22e3b796dc0c525521c508eb2a13bdebb00a07f052485eeb8e250dbfa8d7040cdea4c1ad71318188e4b765f72d0519d7a77cf39e9a347142d3dac874484749395aef47ac46cc34ae80a2bf96b065637553083438a387fc4237bfeaf1ed4691fee437b9de58f30829e54831152fff9ff64fa9aee9dcc63860714a987d8569c02e7e40ec7f0ec5c9e440c5f0836541ab183540c85e7e635480ac8aa283143b477fd91eb0e66eba459ec7b96847a819355be61a4011657fde74c1022d5f4f496d9b9b3cf73065670288b3e54d512ca6ac503c73e729093036332318e799536a0eee864ffb03fb0e3f8cf4647a27bedc3c9e69f258cf4aa5afd74e19984be651ba391e64eb1ba394c07772cf1b5c6c72b2f1369586cd41c2977c0020a7b33b896f2ef9e868e3850faa61e7e00c6ea289d3a7f3faa74ce7ccdc373c9d064248ac47df9c6f0def48eb3170b73a482cfec7b6db7c718defa679a486cc386768ee679af54d8440ae2387888f1a1419434e9688d85d04032b4512c14a7d9d142193fd4c55a02fc72bf65291abe25ee04d3666024b78c2c683926d49e467baa2a45b25e6db204bdefbe84022d3b2dfd1d8cbfdd1fe3a1b35399397ea72f7a80c56cc8edc9e0f9966001f2342d7e03dea030cb290a0a33570b9b86de1cbb842552f1b1bd879f9cb0d67565eea9c9ef8046bfc0a56fc399137a5f975d040bbac902275c947630598f43f96e5a437762c77ee15c4ea9b958d79cc5751cd2d455dfa034642da7b47de876a12edf5f0f5d15363d64339671c61a141c79ea27d43387e26904807c6abb85d104908bf6ac01630d9a9b239a8354d6423333409dfa21215e23c0484dfb1c1f74e433fe4c2cf7c5d6fef1f2f6e5a76a8238e5ab45a26a7a86097df4919a6ff23f669305b3a2248189e535be94eca06c48e98cde20e47a255ba52842ab171616b894f6b15bcfdf9130fa3ba30b3d9e9c4e0312ce23956f8d0902974b0abf8aa551e3aca27d2d1b38292af90baaddecf5d8deb34ad48ac15232b2e221a22d10e1b47af410eee73ea7b9823472ad6ee34c7bee958dd495aa87d3c9285e0abc44584cb2f3c598759987993bc24d86b770f3f168604ead68ce4d970393fd4738083633d1c7845c7ee82c1f28ddb9489c913cdb856ae9bac59e7118d0f18ebbf542505d57506379f56714b1bda5a2a1f178b36b4df297230f450c942bc2edd9363b137fd6cf06dd9dfcd023703a4c06c791c7a46c14044550eb3c0cbe487e1f029aa7e258af074a9ba5bff4ee016c3601890301e844578310818fd3ca381cef650a6da91b767bf263941cb13099807e315ab9fd5f2158624f70af90e2287245c926e37fbfe8d5417c8d7e6271b77a9743688c7a4f6d06ca7b8c2f54f5a21b8c8903a92796a868a7de2adcb8bbbf573b2f0be0e029ec5d760a9729d1e0022a3e3b0b81d4061e71791606578b4e124a1b9fe19f2372a1e9691c04af19ff7e59c9d31c40271b4bb2e3aff466920f2abb42ef6ef2e1ffc2052ac848ab9eeb11fa39157a494473bed4a19b10b5c923dd9f8db2dcc2e9c93d6deae8c8ebecc067217303fa517a64b0c6627b57df4646320f44da7878b7b09b3d9b1a3dbba4a60febad502648e72f1e7e1e39a9253e051510c6f06eba3515e2d4ed5dc8f527da35ce01d555be558bfb78cb904d648b4d7a4d02f736558a3ccc82c5f419da9a38e9214c99cc5479c93c600a24cdef6aff7bb3a4b16efa458c9a21cf8c81452ff9e15410dfb44bc6edf60c8cf5af426eceae8ab9adfd18a844a81b813e63bbe689f194d89d48eadafecc451f96f348df2e0312761c5554501fb7c8e4fbb54e98a98473fd0ed53db4053adb06f3cdbaf9f253d5bc09bde44e322f5b8fc5d0831cd5ba2f68bf8b66f1270ec4588577a979a86ec018df5c901a46e58cf292bd719e075b5bd9389a169b08730c26149c5edac83184a0c9c29a2e118fb9c8bb07b965ca52cf9af8ce6d2741db0316777f3d25892e3acc2ef6b71722caa52afe2582f9b99ea2927d573edb2fe4eb12593b3ecd7163bdbb71a53aaf75908c69fd4479c4dcaf9d95722ead9fa10ca206401c4b5574267574d5bb2878a2973e97f56f7b0461f033570b8231bcbfe41c151150bc4a0f312d215d6db3c6f89836f784a43fcf32cf9d694f6ddba62181e0dd9d4cbb727269cb212112126666f0e99f063706a057d77f57245480b50b76a7b516c8e16e84f6770048a6353a8409e544b85df646deccc3e05a9e95782a98ff09587c5a51983ebee6f00e20cb4f23660a418f3238e1a80b2634acbfa855e9c2b408f5c82b87843e26a8582e6c86b9d7dddda0ec2a72e7830cdf7a88ead92480e5089d5d95b494859716a47e98314d36bd17447f526a02d346d9a34ed5601652b9b8e65a1897e0f1c10564c356baab9cf58e5c15c3ccd0b0e228c5cb5a3409004eb1664d08a711e37a14e67be7d4c0c31dd4d754937ff5e1988a8d3b5257e5cf49091b626a6b42f95f5a8cea75494d1e1a1aad322d0754070e43e9c024d02e1b950f6d3cbe3ff58f2f14f37fb0d5e3ab0fa70ff7e9e09aee2342755e964c53c79a540e2e7e3ff0514ca9cfd30f29bf59afed09bc6c74cef2b78aafa8532cfa89b407aa3e59a3ab916bed1fa28c5d1a3349927732a952a7569a1d753fcc188e2d10546f14cbbeb52e832a2bf53d5aee2b04e2207e11795e1a1a34a2a00bce220054cd04540bacd41c6ebd6ecead06fdd391af76a836f568b5b89015db5f38020c955ac9e6928d3d3ab979451788232a0b1b2c0aed75c7fa1830ffc4f0dd7b1f61ee92bc6527a4a3d963ec0736251a0f45da7f12b3cb45f32c68ea653681d4bd242727655fa5e4f42755f6502e2062f9ff44363be09b1f6acd4ae9c012d717dd64a850acc02bf0a644d17459406f34cf946239a4c483aa4bce06d255bcb24a8f73fe0fccabb246adf62c6f878a9735e010d91652935d3b4c72e537561b09c9c9e094b99a8622999a2f51f81a39591b61c9955ed4cf431c13fdc8a724bd12133f92711432db0aec5223220ffdf1eaad0918b1e9129ee89f9d3119a68cc3bc9e35503f844031838659c8fbde02dc07ea1db4dddadfaa566e0c4919a644dcd6d9e51033181be57aedc71162cfed3eeb002139521068557d5ec46098d08612553177dff95dec867d44382476cdaa2e337492d74c0f69bb931074dc6a400e9de86502c9c22907540dd8b4f96107f0c642b917a029bc23a5679bff6374399fcb85251d494b178b03e469f705408c848a98e53bff193e32256d7bb32606d7dbccbabe67c7fcd1432c2734e52e9bf8f3d4cbd32d7bd006819684fd24a03eb3c866e3b5f6e4a2b621332053dca60d56c96a93970458d4efca8b13e23edb924f6e63e027b1703c22005715123d1c3a2886593146253cafc10c50bdc3d8bbaee8f45686055ba466f4a30427a619eeae0c648cea131ad680ab10a233b51cd8c7d05961763fe729ac51ff988cf61202a8349ac516a40f74c6703220cbf08554a9cae63ad77e3e3bc5842fc89f7cdf4b11ba0147ed25850b5e7faf6fdcc8bcd4ea9ea8eae5c95219a6af49a6c7f876bb343ff7b9fdfa8ad443076def5e6f52dca753491b73e48b1d2568aefe8a37ba1a9163e8b31d7d5e60385275da81d6604837477aae6db0bb0624810e1859b5dc42fab559d5950621b2ad9c40f82203f169e66ace29251eee14b0de9afed849f8749befb9ed776fa73d5088f3d6c0bd416852396d2d0fa5d8e3eda272155730808fd57221894a893bfbb728a73356f7560035b88ff43626933b4a4f87465e75777cad50ccee33205d93696138611d85b33a40c274ab9458b1d396ca13478ef4c4d4844aa8bcc32ef44140f7e463f0e34c05af5f1a4114cd3320ae8f58398d93cb861903f9f44fd49614356b4399f1267d3635e2b9bb308a2771c278a34839df2bc33497207810d1141a64dff4ac881b7f75a5cbd993ef666ce646e1d3c9d023684e2aed79ba86b842351505c25439a29c9a7f9b9856f6842b2a50f370dd0e5ef08dd3335803fda2bc64bcdefdfc0846ccf35ff4be3a900281e9edd728dc474f9616183495cf5327b56e226edae8d9ec2bf74243d89c694116d74cd7719c5f5e68db41048fbf19d54ed3d3fe03bf3537da1c9b31b41e12fda725e6351e8ce12d30dda2d417685ddf96240674fd53be3467c5d44fde9db82c2084342a7ada6f40c4601a176990d355edb095dca76890b8e417474fadf7d3c0d31fe4f813a9cfbdc402af9a2bab497a958e12efec293d22af8cc63f04d85b5270f43a1295d5bc22edbf2d0d57dd3f223eba47b20df259e26ac19b60e38153f9ec82097d611a5d920c4e9d2820621cf9fca405988445c5be649f85be3215717c89469b38a988239695b4c88609b33816fc7e9b0bcf53b73e3aa16bb986e1eb39e7745dded17936a0a1b14302de88853e96819f33b1017ca26154350ad9807ec050e8cbf4d57c705e47921eb190cc3572c4e45bf0a8a00a870b1918a5824e0d4614f0a80c3445e8ea53ce571717d5dc5db0d1248fa99f019cdc7d9853b48f4f75dc4e52bf14cdc9f7159a8e73d4ebedb94711991659c3a612f91a2daaf487dc6c3bc00db9757399e0de01367b322c2ebdf63e487cf0c89a08293d25684cfa421cbe098cf63ed24e0819d5a99a864d1e897f9692304ecdd2f6e070f4cfb93ecf8df038462ef9ee49ab5801473f76966d90648eb000c9af6a6f3cde15237494a41b1d0bd3120a4681b95a3998398121b5f31f8bd7fbca59b36b84437f18929bb07d4787d28c0eff36a75a39b79cd104612b00da9fd3490adb519c9a3a7a8a3ce4262804ffefca6429d18667e83adc7bd1e3e5cd84f7be6177ed0fa8907dc8868b46004152549dc62db9fe483ef4eafa54054495c56c10b002d7874116d4f06fb320d42d6e7354a32a950e3f5e1e3dc03f30762f85bb8fcecfb40b0e3961383ef71b58653da309325a18f2c8169a489adc3bdbe38a8c26fedbfeeb0f698695d38435f9d004a5fe1f99ee876cae3e1116dbd01f2dbb9a111ee1b9177809eb0492f53a0b7f514fa3ee62966e7105f025fa38d25c9989523eef5a76b7e3aaa80978631931591e765a659df874c375c8190fd67317c8ff1bf382fa8536ae57676db3c8350006df3cfbacb64d2129c0a90de43b7143451efcd88bf483d4e9c7637442a2a80b2346b44f33e39e4416236c2a4396bbe2b011e86e115687f1556889031f9acfa54b11566e2478a30900d758c00e6026b993d1f8ecc6cd127d834df09c1d1a6693457edaf26f30d27a6bbccdeaf3ab795d3473b178ddf3812a175a4b3d43d0ea2987a0e5f8224f0335df1ecc1208e8960db5b6accd9fc6f21e07b8ae6ee04af5081694ac846d73c14315274071d56404d56b0c5e32791ed58906628147b5c4128e1a4da48c7dc1a384eaff51b4a9f2a54d2aa86aa83a29013b9594404280121fd3c9466fc22e2d426544911a0fcef8c6e334ab5786c337f19fbb9d52161f4a50d54f8229527fb44cb8e094a8e55accbdd38a615680179f2c25dbde8f4e619816a3a00a4524f6550ea8d93738f348ac570de9247de456a665105fd0c8edd86bde0df887ce1451f92bd38d21db6f29a71416c619fe1fd699800f151cd3094c06e0b169b3aa60b6160cac7443e8aed03f8f9201baeb167a4f6819f84de9bcce8cd6df5e8d6456b7fc880ef58d6032608b17ebcb74a88ccf427fcbdbb86ba5db6a2f2f9e10871548b920d184ccba40f85f616a35ba390997c758d0bdb382f82d903e225a10a2841c25011462c567958e3555fe13424856ecd4982640993bdb0a8b7e6d4dd56b639a696cb1eea65d0c58ac895cfb8206ad80a94ab640bc135d18e9adee0afedf453b3a35c220a9297b63fb5d2a0a99ab382b1fc643f57debb20e840e63b47e73297b5c998b06ab69473a344e7dad27cb957cb12389df3b29c1318de119227eca65717bc862acf2376e4d2d1914b861318e4ea9c2fb6e248199b83c249e0b8ab12242474472fcaef6c0d44f59fa7c8e89f138648d54cbde685669bfa6db07748f5a7c755f2b4cd4492543a1d44f211674bb1f7ad57547a9528cd17f98b1a6d86a64db7f879587fcf73fb4cee45694a3f00282110e886b6475e8b05308fb527a4598bc7471227dda611048cde27e01037c3e85e7229a5d08eaff532d946e327b5c22296dcb816422766d1255574164144d2f346c45fd3a637d2f429c2f394041462c79b355003c8ec8e480de885fe1af8a48f17ec3760affff579902dbe600f8340c8dc6b7939236ed5f3d2dafc88313e106695473c2fe4fb7a5def1e5cf730437d61d7cd8ddc3b4b8919dd33b63560814c84bdb12595e5fcf30a3f1547fed4b2cbc722c7d5e53cecb0fd2b111870f26941776de91e2a7b90b6ddee7b5e358f5b6b7a884dd55f142e963bd966d43a69711a4a7181251da3af905d5c16e3f7cc8a3a6e1f00642495e754048a289660f865719f038cb45b61deba278363024a6ad0c00442485d925a0698c22c37cc81109a6ccaf9569f02f784a3f0f3cedc2ba7a9f21435f06d8b43f48d64a27f9f58c361409df5e120a74de913f5e2abe3098301838b1be558052fdbb564f747046cb3b9c79cc3d0e7327bbf4c61d446a5125e7af8b981687f47c2fc44c6c207452761ad1161b42863699abbd6d88e343ae7f1cc3865dc245f9314f00ff5c5381e4e15dfba70f005fe6662d4b638e87f46a42decfd3a6174d502b4cb5992fa7ad259367df0f50fc17bb10cd4d80050b70858da7e5a83bfad957e21e344022b777d46346d5c4b786c3a9f75aae716f263e90d9726d32e477b482148d6ab762ad89b390746f351884d61ddb4f8e41c737c9ba0455200a09ed486c764e68a5e4c04db9ff8291dae9bd6a3c4dc19f8f6ac04a6b1cb650784a3a4ac4dabc07b36456852af3d308f0e03c22d932f3905eca4415ec6a8f37184ecf8cf2bc8c6389c394a5fa3ce941ae86694527baf3e44bb37be1006ffd9bed06c76038d4af261f0ec0dd4e9f5a2a07c2c78a1976131aeb72f1ae75f126091a12f97d5412b7200e331231b951327165972a478c2cee1a2335fc2ffaeb83f41739282c904acb64ffe0c7eb3aa9903b759fc53d89b7036ce09cb7cb9cbaa7d325f2df51fc4dc53c9eecae20048a93893db1c2ef8fbbe1ac4c00c9eae2e3a3e36880fadcc5bb2ac72446963d7b27e19a60cb9ec2408aa6bc5b3b78a0289810fb28b1140a63548a82ce19d34d1c207c3da16e77a00828fd5583e9faf1acd347fa68a479d9c919579ca030214a4f7477f52d6ac17ed9a27100a5e4be6b18215f0785fb08a73909002c0c113ea424650f8cc91900775d0f57f1fd52b1ebbdb97ad189faabe3612f38dd942cb9e9898739f65647353bad7fe041168d4cc6a2960176de9bb85c87b820f0023030e36757f77bfef71628e706852357e1c129c1afd70bc7bfde43e511df4f7d0e864690e400b83d04d83937f0e9136280e0985cdcbf41e0a0d3cfab65923d08643b729ff147a835dc157cf37896659dae7a3663efec4e50364b4605ecd4c74e548bdfc7bfd3f6da04fc7d5854978f7ce52d9bb758b25b589cb5aa50527a27972c893d29d41b765ca4eb980a6c32e2486dedf99c0d7f7620820c5997125ed61afb514b6c3af309b406702fc9f33360650c18863380ab711eb29bfb102075e5d54e0fc6706c776a9a3a3a5f1cfd83e0242f134872a58229fe8967c30e0172be22f4581830dd0cc189e55d74803d9354338bd9d3bcfa57d03f3c4d129e7a6c2baf0604e3124483e8890b157593a7d044c8b4f526f2b2e9d60421956601adbb52f35ee365e853401865460163993a5ce1c1c9951ff2a7a3161f82acff21de601a15b911b82925b193a41a80b9e36f1e4214752a671a555ac7c0a933c365d186803ac618430cd709cf05a8d4e3e357ff0caa0df6e29dc76d4af1810e0d38e2d7191da77bfa8e03a71f27d2695f07a28db8c09c84a707c42a39f0539139243756232c647598275d8f27cac05cd58f5607cfe8d5343a6f4bed0eddefbff19dae1d6164f4a15f5a35e51068e5baf08dcc4871c3bb889825d43e71a044f2ae0c016f44c42cfac0b9d4cbbcf257811c1c2401bb4de0a85d1e91ce9174cea94916745f92ac6f7aac8525b9619e1e3fcc5333b4d98caccb9172bbe7ebf540668ead7c8ba497b8285303dcb8294b58288d9014790d38d94600cbd3f425e3861c41009ca099930c7b55c897dff547b986a12bc7acfbd4b7243e7a4cc7fa69526928e78d4d82f0eee5598be05b7558b08033170b5d62a430c3f7e66eb10df54b5a44e67f923bbab47ea1b6dfe7c7ccceb5d16239477e1acd315ff9a8a9270547fac4c78e1c0624f3d54804c7205e341306ec7fa5b4029624763cdeb302b1ebb38fcbf92bcf6d7b5df2379cc9441ce62ddacb3904d83eda4dda470cf788a852413ad3974009694b9845a45e417ef29612f34b65463935aa63e486f5d5c2f1927902ab61b1fb5a6b0a4c7a8abf77a3e3989d194783f8b795493d844df2a3e76bdeb9cf8962d3dd0eef42b7f7bead7850edd139c57197f47bf2731cafc0bb9e0459c0b921a6679ecc4f8c426f534127bda9936dbb97aee6ca9741d77cf92b23d5a4184576faa3654a8a0bae42789dcd8c19a94e2f1eb19ac4295c2739cb45eb82cbaa1ea489b84d41406a87b0ae160dd9b1cef299276a73d13de8a2b75b1afe5a76e78f8f209e824f98f29925c4a958afca5318bdc365c25339b672065603e44b7526299b013eadddf7a43a0a09a1b050e9f41ef5c0fe3fd65500c4ca874ddfe80e0ee489928649a0b8835de056228d3fbda6e6ef25eb4e8a66e75c59d7a271be6b411f70c2c88816327f7d7604c71972b52cb344f75c156b2e1357d96ebb6c8558d214019594037ecf4dbe863cc49c2a43e23e719b08b98a508b297ae68f2551396f75818afdb9800d60f3df4af5828316aeabc74cf3b73be38863f888d397bf01d295a490fd770f947b69110bf1032d42636d63e610b831dfe0e76c6bc53e641956b7550e3fe6643c599fdc47f677500900b4788b5479269f7bb8bc17a764ccc71a92f0ef0d3107640007b73948a8224e642e38952ccd01f7f056ef43d1797ac66975b6d853d2416b39f1569e9632f5c40df7c63aee8afe165405874534c0d1f7b7f5b0f576d6a914080aa419853217c762575801ee136e08e950fe3cc8f66c86121ef4c4b69309c9479d83f7dffaa3fa96ea90b896f73304c571fc735e5259e419ef1e386d17a0e65a6cca8bf0c8da1a880765f594c507a62026a023c7b720ab9b88e3b1f8160aba317e1579b1b1d726d052a73a0cc801456b08f49dbe0f5586bc4a020d9bffcb30fa30232b772abbab645efa7681aa15c82cfbf964ab96783be050a8f903c59c6fc2927454428488b340f939755223cd5d7a646601727e5f2e45ab6aff5d662bc9d1eb569f7bf1dfa808e5a9b9902c6730fb8ecaefed0c495e208f7252bcfda188485e74bd2d13b3d3d64dc389faf03433aa78ad3cb023ed7713b86c1586ca5ec6e5b04a6adbd579c4eb9eb625c240892579b125cf9010b2bbdba2cbabd922637e4149467e2dd18a2d738344637242241adf5a53bba7d73be619dc9457d569d8ecc45e163298a75425eb50363c474d8fa5e9a2c912a61c45432e423a0d814d1f3a7f4267b95e92fb26f9ee0b9bd3f20588ff136bdc024f3776ef541375bacacd8c7d8b81fe4b54f1a3530b26f71a35395c1f9e82866ce87e1fd190a05b945ec785d6da244b9c84252c55b064eac78fdfcf33b50fdf1e26f01f334c5cb509ec42cf013db9354e389c4a4c0a48aba3d72da65604a48d5f4304feb5fdf131c60b474b8bd5c1088ed803fa3658cda81472e0828ecd5c7363aea9b62170400bbd7042a9a8b210445d071466fb779ebc47fae5164320607b72b6b927d42788f4eee5ec6b46264c62d5d62590406dc833aa370e3c37392dc279a8d31ede8339f4e8ccd87144635b51140686a74c562b3c6ff71ff1b44460a9979065c6bdd1f680687d22adcc7dfd2a8e87743360a01833df606e952ec9d387ff6e78e64ea7fc3aff5d3c14cd93430aa0dac9b79654b633b2d4782a10b3892bb757e9000e1b35232fd3201b4c8daff7c08e4fa23b2c01e7512a893478a952718647e1abba22e9c6aea24a5900379dfc03cf825ae60e4530279436dbdbb2d297f03149e1337684c6b158b60f7d075443a10e39829208db6c4fce1d1d362a9c5409130f05ce6de46591c0e18837365ced1fa15e4e73fb78514fac342419f3bb1483578c3c084875a3b2accfc5d9279f1cc6dcb0d5b5ae86f7f8090ffdcb60b68ca42b3bafc744fcdc54ae695eaebfe1186d6fbb29bea398060e86aa4f8ec8da5407fb521da9f421d08f36e86be5ad6158ab4e2dd09c107fb03253f0482ae6415ba89da167b2927dd3c60cd204dd6dc168b6968f9912d9e62adbf6abf37f45d11aab1ca89cb51cac9b03af0a404cbb42072237dacd43ae8e95aa93f140725ef76205cdab3203619333f3ea3e171429609738e677696381f5618492e3b3b42df99e6402fe374b84d87782c3c0c819197335abcaafd451f238aa471433ec0c0e0d60566d9fd4cae56237716389cb012a020634408e4a9949c25946e6db9c86d390ebf543a306ff828c9031d3930fea7460b1e601f9f957f39fe2b5c1e776bae1cb145dcd3f7ee71c7e8070ac2a87a8d7d9c972f52781d8487f64700067fcd773f59f9921eb4d95434ca3c052d35f0a6e7640c9edb97f7f02639ba738b5480c0dc026a4c2d1bf7fa19369cc0c934bad45875a1eb90c30edd357b4a4910e034cf90201ed60861806348afd44868e999a95f0e4ad628c46822f05611249ea3657338014c5590443b31af38d354da2e578f3a450ddcb2262719f5992637b14e8eacaaaccfaccc748bda7c88c4236ff93a2a6be2cb9c38c1588288d8c7c102ea9dc491cc3df693bbb6395156fd26c7b6611ea97f3ae9085bd49d85f0631148b296465c8c24c132522f8fe5683eecd1b319b49a7474a9c4218be5cb77ed36e574f6f914d04e21c2d441c84c7ca8f9f6a6ea895531fae45a45787baf16edcf922cf5172c2c1dbfb0a3e4a027581f84eab9c760289aa304c0d13342dca501b57dec6d9aec7179f0c67a10a1434fddf2633f31bc8dd3e319f03113a2e9981d1d4dbde9ac747785ad0f8898e48621e17c22ac875da734ea139a3b986668f441227c087d5d94593cca462e2f4fbaabcc41bdb3ed20fa9fd24bc953e785a8d4727772e6605509196c51542126179a2abd44356cd8d0e5dc7fa7af432fdc574dd9501cfd961ae4c76856ef4cfa6c1859c814910c62e1bcf2bde790ecfc5a47bd1d53d0543f0ed92bd5d0db5818b9bd9303905acdf5a2940121a7113f7532581d58392369dcf826cfffcb6be60d9e7ab571ddfd7db5edfd03239aa107dabdd1f2ac89f53f695ad0ecc78ae5449925771cd98fd73a0326b53fede8d0c463a3b24e6f831700005aa950cd242c1dd9b3edfbf0f075680ee8480b42aa0320d7ad899efea245ce84ab50c60af0f3657b3ed3b60ed297b98cdf471d02cc330c0300cb74aaf9e905b4b636a44d9b28596c90376af201a4e41ab60d41af8a6c930681538027c9a7914e909db2d548b78f127afc536a5342ee7ab45d622c948f3de2823db6c8fa8d98e48b464fac4dbb7576fc42d0a54223e5e154415ed5a48833be9ec5515e65c5bc28ae2bf87ebfce2de763c3525d12bc20041e8de7b874cdb5b41b04f8a765fea0379807d0fa12a4654a60d384dab6d5ae44df7b6a5165e21f43febd1ac3f12da0959342c1d7ddc8cf0db9144e7242e4b729fc4de5b75a5146ad3e50f718c422c1ab6b47f88c970a27f7d6b7496ea0bcd18fd17000dbc5eab7268f139697cd20b13f600f3c05fc9f1a1017d299397903a76ab395d883f289cf8ea3da7ee611b03873976ced5ec985e82c800bbf9b95b85ef956d0ef61189a3063a4b6b3be5dff60404e72e7a070746f29ef0904700cbe87adc81f112ccbd61aaa502daa4b7d53c4b1a496c185eda23b3b9ed9b468fbdd2c3fdc3e692f04f1396f3b0279ddb28aceda8a1aff54e16f2ea2e66c1b6c85651b3c6dad27d2a3bc9c506c7389b8e3ea3c01675d86a949bf9327b3dfc3d47035563889a1858defbf67a78009ce64bd10da70aeb057c782ce0e6e78e2c1007e0b7a427bb84f7bed40c18d3ce1a74b38680fb6373bc5662f99a2046947bf8dc1ff0f62f7eb356bb7aaf89944723720b279d10ffa6a0470b98b5fd5cf100ee0ec9828f94237355031ea032e2e81cd943769fb1d32eb274c20ee71a46a3e94335b333923b5b2513fe6c37e55b215bc333757267a5f3faa8f7f5c5c7048c2ab12657da6101301013be2fbcfc233284fcae5df55228ebd27117087496d95d740f3367201dc7f3b858dd70fd60b081a3e0c60e87158946f5f31ba67aee5d0e7af80eeb40dcdf14899dff7b619d725180dfc572d47b704f0412d9be087cd9a654d5eaaa1bc01ed2dc8d2a4cce73eaf23f714a2b464b834dddc27660c4bd17e27eb06e0e667908e1a944bd5838d418c58018b588cbf025baac1d14606fc23c0bb9f38caacb4e524994faf8642e814af7f37392592dbfefae8ff8a98b3c4dc6adfbbe72a5080df0cac7d0d79b3eb65143e4d22ea0ea8e0fdb7dbbf5b1e5052a3b3cd374fe822f073c331b8262eed3ed6c520e53cad950c273ee469921d4bcb269f86b7ed00306322d2ff0dfd95576fe76ad448cec749f4142677ec3c5a9a6f7cac13a8aa2155c9716d23a8a412ae79c44b8a00b56159a787e8553794bf4bcb55535c86981718a4e6b750666e950b58af8ce28b9eff669553f23c49cf163de985ea9b693c0b567f5c01a5c470a1dd99e5dbb08edfd9a8d98bd450dc4735ee0e409929d9d5570acf4dc816952ab79652a651f78144832f972a03d6187f3acbab64b1e88df82efe3f67217b034348581cc7e7dac17c4d2168ce6a40e9f5d370251c444f76c64557920057aea9b163adc7ffab7275213737561943bf35d748320e59e5b0f8ab9b4d4dc034360d6c47a7e73e14f457814b522c1a2d73c679562a304f48d76f4cb52d7158aea32b1410ebbdf268c56f05737b3d80791b6081d90e83b8bde24a7a062b9f5386511fa9575d54a052f826a46e0fd616f4defe912b8c270176ca4235a923c0afefa7b1d0c753204186204218540706ddb23678010e9451fb489596fd6f78bd2596c517f4a96ffaee526bb8424b43ce0074761af1ff38d64aadc52aef560a10022c92678904102a4d2f8be8492028d289156c6a776db8c066d4a7acc49d9d3af6204007cbef05bb1e7f70443c5b4b7be882f757c3cee88e65db728b60debc2f518549ddfb4b2bc4ab02af5055bb0c6189ef22b2c54fb29d0704da845cdc575976ea509be9ca2260393fb63824551eaafaab002040c8980c93397cdef4e489ef29bc55b4e8c274eee588f6c9f6ccdff79a78c73b02e9a3cc340e7fd8de70ce444d7105db972d16622958849f0fd39d1c5fbfb3f396afbe9c200d131a31b2f34754078dacf14c01c890f17b8e7031fae1664a232e9b70d9cfe0e0dc716ae4698dc6474e24f7ec9587339df7d54be4ed8c71dec8046017013bba77e7a7102301bd39d2d8ef6a8fe99bbd7299a5985954dd7de220f1ade52f9a88c2cced00739c298bdfd0f142b3b75e05972349b9c71494a729ce628c37bb443df76235070dde617f16c3c0683ae365702ddb429241a6aecb7e7f8919f6459a4773671e1bab9e35a7852d0d9046709a179da151df7b41281c8034cd9c886b7c0c624612c1cffb5f6cd29dc55b9f67f5d0464b333ca9a982bf432513ca8a4eb4cba6e3302467ab62f9972e37aa72627497ebfbaf9a7fde2716205450513be98fe6de314bee48307afd0c3033a91ca13bde096d700cf383102aba94fad975ba56afa71f940c1b1acdb8d62a158078667d78398c3738c5dfc906b3ce5a63c052201aa6ab94ce5387e15b88302bc0053b2589aea787c09785f60e67dda04f994e5d74dcffd30c2574b7c29ac6be1d0fea5c4a996c4bd2a511629550219c6907c8bf8998ed17f05f519b4098746ec7d2c69c272fb8d1e4818d99855baf17f7d0789395090de255ad2e89b72581f6aed9ebca9da7f27562c2215413c37173e8097b172f5a06fa1f9ccaef453a3f1fa1f1b50044975e37e4bebe960ae57fc237328c659ff526260ebad57c4dd67da830eddfe7154a53e4f4187aed6258de5ff7ea77cd16ebe6c0ac1d645e4e514ae9bded2adfe5e5d7a1eb24cf1656faed1653fc34c454448379a74fbb76a251fe63c97638d12758fd67c6a9787cec69a611dddcbec3bf2840d7745f5a561cd2a90b785afe0daff5d784d214d9859f0707b1cdb3af0a2d0c6822bc25f2ce6e3f0c33900f01e2a68f7366017b2d757bfb5f8b384bdf14b8f42040cf2c4d4c89e07057572ee452b42d45480cb7df3818b8a9f522e44e65e4b3b82bf3192641ce12827a4f378791b90b77a0d6b298fb07ffe9aa043b391bcf68ad7056f5d0c0e8ca1b03ed6a07397608522f01a9603565ea3a68076d6480ec2a6e51fad92bf7f24aa2f458410e1b271f7f6dbf8f69b59e35ea8aa02eb854852aff592242276e8bfe55b108ded5cecfa4f9e8c57d8d759a7eb49f2c6b932626af0449068e57c3f3ce9b0c86f085c5374bd1a8b3d5d0a4e54d6568cd29b7d19c1979c20445b7ee708b03dd210aa86e5d80510af2dccf20ae4a7488966f5254c2cecdd312a6f04ff984379b528b135b19937e9ae1c868c4066bd84a909e05af0e8c08703f59d9e5391b476458900a764b76bcdbd68b3dd69108cb4708365eb35f9b6f89aec9db071223476b4a2fb5bbcc5882157c18f87026120874fabacbfd346cdfabec0f67e910e207d7f1e74bb10415da14927c630620b47cf396f8f2745e765767e23e4061625bb481e8dde7a362e41452edbd9b804605fe0905651805fc41f25695e0af5fe77fa01eba45d29bf1a91345c6575baf546633956dc662ae5e22d7ad671eba9365b6cc851795456dea5f429ccf3c21cd0e864e6158b41808bf8bf8acff382624db01c5268c18345cddc0e34609d67f8cc48d43fdcb5c1491e87670a75de1abe679818ab1b751c2784ffc6e1bd8d087bf554b25c75d18ee11d9ec4b7699dc882f5c9e9e7b360a1c23db3f77fd6cafc2183c62faca8da5b8883d3cf1a8e5d899da3cb734c14d64f70abfbcbe0fd555afcbf806c5424f804d72b7512689679fd5d63185cc961f43246dbaf84ed5576e6810e98f88ce60d09b4cf584abfb30c0764f3a91ea1ca686524933c1c94c91789581812e87046fddd632eda66dbdd53e3bb4b5298e861a7101d373dd33d2adb91ac7fb15e5337e75f74c6861023fcb933725576ff179ac035f7a7d3264fb5ebb2bfd3baf844f58abe4b0d0ac07d198b97024b1aeb0c322bf465974e63427296aa2104e49d63691c34ff9543ff55542b4fd772e0c980c530060f575bdd5ff3c58adb9204e1ae55dca14d1163a4a32bcaa493272a1327db79951fa786f60b94510a1faba90abcf10fa502ef0357f03c41590d6960a0a771514188fb3f049dd6039c8031d63d407fc706a382cb0f1f47ad94f044a49bc2a2fad131c1e78fdb7af10de7f0223fe92621665d744a5a9c5460329410e5da63b1acd1e43cc24dc117e799fbd991ceb29cd61890221340939e891b9a29d4b5c091b32020cd608187215516f78ef68e997d25aff254b652141c23aa8a0ab0e9700e46debd8e5aeffa09fac21c64c6f09ead58bc4ffc0087f5cd11a79834ea4aed5d9e4f51b272e61e91655ea0a4e43deabfa78feabf4b365891abaa2b45b3fee8ae86d827e856e2a644c922c88847c9c595a4d062b02ef5e412ef2d6e9cb2619ab8058378a7d8ba96bdcfcf2467709b8c557f24dd6be245b8bbe5c5bd221cc1a4a7701c03dd175a1bbb21569c63c459bd493afa0ac1a29a4b605bd6caa7e59a2e522c57571fd6ea938f6504b2cb87c141bbab6745ad73c3347046d7c172fbbd7197ba5fafbf55022bc45825f6d8fc3c0e84064fee28f72a5dad91d341d25a68d06cb9b89babd0bab82fda9b1ab6993ac6f232c92032eb24feed35471ede1ca5b184914e875f2257694fac8fbcf6b491240d88c929969a8cf2c648464e3277cc679b2aef3cd6106de6d5e6709627e9818ada73fc626692c55b5b94cd99aec2684709f1d2c4ccdfc9ab891ec1488b826ed0e343bf1567703f685cf8fef4e586c44eb6ff9657104f223057d0b789d583979c1c89e6129c29aa95942a9026e95cf17e2042119d63dadd7c533ad55005a2d52ff9ad67f3e5b678bc32c57601ad7125cc12535157180c330347cf8de0f31967b2bd3f74edd7037f9e4e8a724b6994c5a40c8a056cd005d76e2e7ec6d028a9dd154a38742d6dfb92411b528883f92572e44c8b8c7676f11aee34450c7732429d74e5a7cb8f3fdec80e5d07094d93da84044ce357a5b2095ed98e557f1c4c57c7cb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>一半</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E4%B8%80%E5%8D%8A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5fb0319561981e973b8a62e0682c2f2993e2aa630bb3a8b156680113da550545">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e7aa3c5a6384741e6edec61be5e2ce4efd43abaf3b76e1412a9fa35a661af60897347ff6be28bd92d557911ed08f8ca5584acb34257f04b7f580b3f5e668edf25a3781015fbef7262bf4fb4e91ade61e7e355d0cb8801a400eae5b82ea39d196224cd48e5f4054b4ba8be0acc3d1cd2bc22dafdbb5e9c4d02bcb7511fc660d12bfce91b62aac1145fc2d7ce0b18d390c6ff86fe0a49d7cda8b1f6edc82d7f80b9ddb0ccd19ba6206f775180755cf02ac5c0049341ab270c5e2fd8e4f61d8a80123868d26c5a7c6db3a13ad54130d2ea3338a2a64052b37eb9ca17b5872d60405060a5f3f5605286fc97106476db4e9d9ee5f079217a45eba6dda2ff86f671d320d80ce586d7c98320fc7fecd3ec2e8cda60a887dcfc3b61e006e3e208daabf8dfe2029cd4727d1a7cb2e45c528e60a34869da91b51c7ac33cee21736620a247883c8c540845e8bd08f986cf4e1203e582b969c9459962aa5f4e3efd2f1ad151342ce41e0b9bdc0c2f24b068d2a87681980f053c9b1b4bdc5ed17cd2e075f10c405bd6f151458f2db35d640e12e62a667105783a57efc38eb1e26f61b46bffb120d5c9a156764f5df50ed09d073e8a7cf4620a64df0e2b2aad0c3f329c41b0d2bff0aa6b7b88855a618ae36918e29ff9b3cbf04dbbc8c7f91d7c1f45947b45d498e5983a2fbb71bdc8e9d50aa726a8c789659670c354ec5ef8c679634ab0f238c02cffdbfd9d00d4232d3779b421cc98fc2e1054fcf342a772a6571ce78874e0d0705b667757a6f0e30b592d2fad857bd30568e415d91db7d4d5145547c14a31e90d3f933af5b88a6515be997e10e0e86e45328dc406611566180f65da40a32208a400a8efec610d393ae9a1694b0e7222d10487ee4a3b3e18da65ed38821ca86e59bd4d293523ce11eca98d8ffd98e0a5f590e97b639cb646d93ee71669aad56b3c1d4eb7344ad7d8addb96cd99df0442880e63413ca0e759beb55e177395ee0679f186c606d7e6aa014a18ee456bb2a5089bc8238473594c166e3307f8bc7a18d4e6132a0e5b65e00b7cf862eb24fdaf2db7827008e3847ce1ab77effa965bb09f230eee7503f0d25b0bac1611b1eccdb5c4730f81daf0dcdfe302eefcb9ad8c5ca06aeda507c15a61e0152274e5f71deb2f5ca265c631dd17b48195ffadae4438373645ed1cbd4bc4e77700d28be5e09cd9103f2254100a379d6a7abf5e322f868339437a4354ee4c748f6b5ec0648fed4b45a8da30fa688c67bac76d358a45c2b4df47f38d0b5635d0617e7a0b235e73a696bdffaf5dfc8ba860f4ecf16414b59ebb14d6f3d5b570f444dfc74f068216d81073c74f1e1a7186ff1777fee45a45bbe1fb6e52c626f8224d9ddca86ff411f6996576f29c5fc0b64367c38eae684b52a67898f04c28b7239f77f0f34b7f6080b678600212d85f5e567550cd013abc5d7949c971d265be148003b53df69405d773d5de423388ca70847fbfe61a7bd7ed4349670aaad4f08e98eccf1ca4b7eeb8951f407de485f76332befe79fc7a9a54efb88270151c9dfe69aed201804676399433a8cc7529d2e633ef9ab62432e00c6b69f9af402a90d74797c9f6d4e42f5b2948389f273573e1d1e9e052e17598f2c98f0d633e815291cd1642befd0e9c7d0b05d4e77a6bd85d20ac1e982042c1dd013264a4fa54c6dc88fb69f560d305c327d0d77e4f10d1fa36ab7653775dee386409fa2bb4232e42489cbb38334e676cd564b9f7fc97068163b8d39b72a86fea5236fd64375e552bac509faefba5ca3d78c5d24e294c4abfe86b8bae97cba1ca8049c35a1fd3e6b275fb1042006f916d1f7ed5de67fe5411ec73ab49d332ba59fc67e7c690314ef583eb3c57f6d3dc471058cac58f9223aa2056756d1b4552ef7bed260e1e2967824315f231d72de40a1738ac56430a0be5959321feb7cf10f33a419e9f4861acbae335bfd512133a8fd54a71e3aa6484e6f0bf7dd700647f8b00662181e840a92eb12e2c834cd0abdf54982209c47da6d21a84f1a04bac798b5d6b6f40b4564ab210dbe64633509c046c31b05194065dc528366171ec1494f047328b2eab46c04b69d5047a51abb29b55ab0f075a7d8700fa19ab981efa8a2e6a18e8b74787b492b72471b0da07ebee34b869756efb1abc26b2ef53234f95691e4b8b2a037017a1a8791685ee6c33aa3eee88b65bd561c556cbbcc4d6cc0e84f2f0eba1617d3002cef1f790c0c834efc1d0356368dcef33bda506a7e18fa4f11f627e6681b8853ca5679a7fcdf838e55db315677502502cfc6b856cb2249b9484d713acb8d30fa67a1e144cbfda79befe13b7648e0b7a05ee26ea6aee2eb2e7e1f92546cc0d4f81ab5b238c7a32d78155511d77825c442996432e23ddf73312f584b356b597e493666bb81d14fdf6dedfa4a5c7a4905d120cbbd90f6dec6e44b42f56794c978da17dde18cf4596bea9b8119235c4a2bec6b96a73d14d54a2f90e53ef227bac4645d6c4bf3a92a2981e0e52dbd81cfa3640469d057f020b3e6c3e4610d51cace6366f41680f3c45ea10d8041251f5fafb18d573d6f28830705bd435041f1a727a63c0e41314f364b091577952b73a6a8d94dcc7c05b8ed8bcb113c2ce19c6f3fbf6d0c6e4544fd315fa1373cf12587e2f8fc19c2f2eba9207d68ff35234cc6fac7cef18fdd7fb66dd84f455abcde64f468047198523aa8a6c6377e63969aa1efdd56f630359f2ad255a6ebf3c842afd6f50a75c4fb8ada75ff9cb769cf0110f8765c77031b34dfcc3774911f8160dcf15a03e2832126b21ef16b98fc1c52ac5bc6fb1a9994d45417b3d151113d7f25551e7073a15fcb4b41afe533d9fda1846331d767a54936a62e8ba7cb4bf4385b408f15c1381cf7a5756d6929000592cdaec7168c948e0ebabb520c8bae245490c411af795edf6e74417a8d91ea3931ef5b1d5f111ad0a9fdacf69ce3d67973b290efa1d80cf8c441780e072099e69bfdeebb258977013803e0d8407db290b80bf5bc39c8c06139b4fccb22082dc64e52743fbe6b044f82137319d80bee9c3f7ff9e5ecd8f29e2daffa3f16264469a58748290f46e4a0ab6161f147b24468a5e46d119fcc98c84b683eb33acb07b593f9481a659eed50f8b67487884632f93653b769567fa10bdf4ee0c6233fb5d6c97d99d4d6bbdd327cc4c1e12b21ae000524b41a95036901fcd065a48a918c66a66294d353a1ef596adaec94616442b599d6e0fe71f3750b231e364afeaae847793f37b1584343133ac565f475ade5c8716303eb42b557583983bc4a02afe25332fa210d443f54c1ce8667fdfcea89193ce6bf13d489d21ec4ebb405d125809837c06dcb43dbc9c461e478306b9b233696c6dc373072c56db250a0675d861ad8c29c2eb71fb25a42b2031f6f6964d9c5fd4f5806be4fedaae849932e2e4896ca9be10c69bb1af4922d24b54767aeb9b89e37ded4a45047e15b672fa3bb73fbec9e7643269695cc43bc452c6dd28c07571447438c4c50648a14763bb8215071376da5943a260b10102404895f415b53278681ca3b1264d665c63766bc1ba7cc2224856555b8f65945f2d71a774b7178cf03ebc1ff8c1905a464fdcf80c76d9981a941cab0ce4178a5d2f87bee4b67a3c899ecc2dc6736a161079c8ed468cdf78da2f77d670d36f357bf49c95661598ce7273cd99df970b5cc4b13e6201dbc7e4b74d10a87d284f76aa6c1142351f55390e313657410ac52fbce452188754a5f8f06fb247b840ecea896c4709aad0f629c9f5232f5a3613bbf336c37acdbc8995571a25af5a15a9a644c1ab9e8f7fd1cb3a4fb47951c2d5e7a98630add6a6e994a7baeac5a7e51cc0578d6c4cc498561d6e980f2cfa2aa18850db7fd33ce08f46a5865ae16c8b47cb92ebc8afffba13d923af1ff4b1aa9912d73a8505d13304d1e1ab45f02e630adfdff5d8b603d79dd384bf380a36bc1ac8849d4b5da8a0f619d8c019b6019dc2dd287f20fc7b41b8c74dbc4f5470ca4df807c8b2d0ab4412eb57318e423ffd0f5dc5ef93115ff204b1cb32599873669543624593bd923f03a22fa439e9a209c9f2ce04e722cc1e2695420f82a88a751b00c137508ad88c25388ec15ed4634e1700a00373d03a01a5e3eede9155d1b9ad5b11b82fb5558d26c98d5ed3181dadc47ecd6639741686e91643200b707d1c4d536e8715222b43a24be7133f9dc10ea2bdffd7f12efb27ab479173f2caefb28c5b83ab1d8458b653b7ecd0be86bdc4a8b17b6b03fa621644d53eb547a30ca838a76f32b4168482fe8ffc637c2e8fbc7bf5dbdd66c61e2760bbf0e5a21d6d87ed3b9e5121af77eb44f6dd501ce3cca7e0b182c28fa287f1743a5920ba3eee7d19fa1d5d8e40a42fef92305546bed6883313ac7664320273541082190f0296225801bc2ba1fd12a1bd9d4e363242f6ffb926ca29162d9dfdc3c42b03ae9a8f274c58c0abf9910067e1abbfeb93617a217ccd9c5182e65f8d93bc4989e408ba468ee58853f7c257270d31fa15f0c9f3bfebf1775f0375732427954899afd6ef0c0dee675890294494f3bf76894f52118809b06fbcfe275e29b01c36ae54714e8ad20fff9cbfb4fdb470e36d53561e4b0919cd2bcedec4a6433168ec78c80cc3d14fc40df2d70ddbe46e3f526eaef7c97f46facbd92efda4450c5ec0fdf508fe134060de557e1cd6efbe958b7aa651bd66cdb581584fe19362663dea1ed073394bd3f9264660db72b080f9a645affa4a3cec89968038a14e7f6333691319c17336bb94413c9ffa15da83708a225e2ba3478a5d2e2a412e9bf324c349c82b85fb273354a47972af843171a8e3a3c62fcc13a922b14ad2aec946b695ffb03c7d256d15c0fba5af4fc0d5b038179772723e71506b9d8548674e25e1f7b139488fc4a7a1f4a3dc4125b58d5aa7ef44c32f814d28c873b7186f5e3452699ea03941d2095a48389c68b00975307758955b01324021400b7ac42da9d6da4e486705d54b9e9a7ed9acf2dfd032e577ff1fcd952fd8ffb8d60f29e0d550ada0663b9761cd4300470a0f67be75c590946a65881a9f84c1b719c74343b3e93d16ab3c2c5c7a58c0cdd5a550368e3bbb47d995deb970e1e435c880fabb2a8c3a7ca88fc539cacdd3c71a6cc68652cb2b47228565c9c94af916abeee3f7c980bfec52f949e5e9382154536f6539b0a1a7650a6457f69f06f7f5fc2bd7e776db1ffc687fb28ff008ad16fb784cec4cbc145eb4edf92ec3fbdc079012efa9d0a425f8a95a13fcbd13ada2433591b95b340250653f3aea3c778d6222818406f79afa9176706b2ed2424a18e4b3e457a2e1231acc4dd9d20bcc8599255baa95e4c83df83013aefd27594040a9bc64e93e0f27cc1cc0869c20a37925370209bf119348bcdf2c30a48dc364e93ccfea03c0220023ba24872038bb5c02ee5e756934352ce394fdd9ff5f1f77fc4289e11dd03e1c5cbcc630da7596867d18404541864ea748519a49ef5a686722101958a79b2404ff7006f2cfac4be947fe4df210d6669892eca45e2c55a7ea80a8bfbf9247fef7b0de40fc0ec409452951bcce55dc746dde954650e0973b4652fde9c44d3826f1b2fe9d21b8ee68f0692df6e1970bbf9e585bb032be744766f0040dc18c5ffc45d361670f9133c2470fdaf557fa77a14cfbe2f3756ac730018d443954f840201bcd1c5477570f4329a4326593a27e5253ac1a1a01c7fba21c1bfab3ee760bad8ee0fd602dabfaeec34ad63cf8c06d9fcbe21c40ab3a711cfc70c946b6ba2261fa4213a68bc54be4a519e7df1d9190dda94d941cf3bea90889a610de06b5bc60a028427a1d1d4273e8d783955a8c4d01a19eac969073f758c441ee7077476cd0538d51ec11c961f3ab04758405a38bea39d2efce6383bf1d8f7ed67efcaa4d2e2cb498fdb91d6618aa314086671119bbd738eee90cabfecce855ea3211ea6e15931b2cbfe071803ef376167a26d428ec6137be1a059b801af8ee0938bddbd7080dd04b0817f688831207fb87762aadb681e2d79731d511d301f3a78576ad02190d4acb8cd2982647f628bb5b1d1d41e5f0ffdae6f2edc1fccd83cfc58d6a766e65fc805b89014cdc4a41347577cdccab29a3d8d947739b084c2de18ac3d455c847519e94a95aa0d3948581a4b714f6511a489b1e7b2d78bc2f6f4f95eb23fe7863fc67453d5926277ab5b93074ec735eded0f6e36fb3ed701605701c39b45204ef8be6a1fa95a05ffde5d050122f1c04776dd2616a51da6270aad626d3a63dfc655a5a45fbf357a06dd1c005a487e4ca5c3d8c82ea3fae5148f77519ac66e3214514e74a126ff55f690c8519458b90ed7b9743d5cb75e303b6a9ca5ca916b67d3ca5f9a1f321b1e6329c7a3243a9c7ccfa6466f5036a097e93393b89df820a836d276ad0c9cab5a618e20cc77ffd6a600cb6638331773aff79e083ef2c20a781d5e778aec7590c50ab2615774362a3a706a7fe558b3cdb798f4b560a42ed99abcff4aee3e017d7002a21acdea0f42a22bf2ba003b5d8fc56c3484b9278623dce1ebe02bf3d72d096d69cb36d2cdff1867e49b03b63a81974c14d7dd5200b302e74a9008124068faa8ec3bab60ab907911630bc6fd40f1a19beea399459ed14e3f12b005307a4646e44fe4e5fb72b5f1f99722c76a75ec81931ea13b4b216cc7246a54dc6403a114c614768a787c830138f3810f5f009015338a87c1a66b1d3215d11f6a25152a5e51e56f14c4454ceded3270c93aeed2a740ee545ea1ed02933d44f08f0ced611ecd8cffd6834197c7f4195fb6394818832031b55d20c8780ce007cb47bee0563b223ef9edb65f6f812d83058a9e6a8228e6ca4901cd8ec36de071bc937feb211ef2cf5a7fc9953614e2d470db56a28adb78895f5bc8e57d8aa98cca1b772a24bee7771b761083bd5e6e2dc5ac37edc77b3ad2bbda3c60e90dea0a5e1c2923cbae28f13ac9e9e6409e381a8bfdae2398bff4b30b2cbb80c764c20c270c5352cc49b168f3c8207d4c4b47851ad7abd7eea07487f307980f1202ad330694e35de5ff2be96f7ce2685fed92d53a246b72cc5b930351557134aafc70151f907d519583c7de91c9e0d1ce0108c2a8818c7d48b4bbe58ff2960e5a9d0bc9d3721fec3392eccd0b0d18de51151c65ddf5a2c5fc26aa48fda18f7ecfcf17db555e0d7589dc88c079aa8969a48643d9ead22a99c24bfdc507789155bce4400ee7680d0ccb1c496b639267162a4990385956c14b6ff7ecb43af2b65ab9f55415f2552dd968feb4b7dd7534e289fc3f6391b059392bcf6d820fbe94a0673d5ebf53eba70327663dd14c50ce1795759616b1a8f257d0227b0e7d720f91c5f8c63cb55cb7954b3460b8142eafaa0f85cc52fa271dc3e6c9220a4dd820a5d116d09ed37f760fddbe80f723ac8a1c67dfe62365166aa9168dd8c72f9c1ad4d907a72a0ec36086028e6775e5493d73e15d88e3669636f6d0ba4d11a8b42aeff6f79e4e6e7d0703eac21d7a88d713cc55b73241bb7e99c8c5376eb580270871b8db843c76bfdf68eb94c2ffa7b3ea7a61cc620902ac9b857395e28d3b887512fffadbdfd21634337769531dc6fc1f57db9effe9069e4e516acf4d67faafe47251c768703b1af7d01921e7d73783aa87269687f87854fddbcb7f2bce6914d4d24da1789f6e8dd3de0852554eead0795861a2813f06b1b53686fa024ca885e72214e1b73026a08a367976b038cbfe644c76f8c54f2eedaf4b40f45cad043b97240c0ea1d84acbb02aa4049a54d85e74c82e7016e98983d50abd4e254450e5831ef003e274e3ca2310ba3adc1ff01fcb90b66733f2cdca6eb2e62fc3e19659ad8b0fe6a3619a602115232cf724563d8ad59bb67a148c322c98822bfc05dff8c9b9fe62694f2368c40c542d08ae52564f9b4a9ee7b50fa0f1c2361c7978f819959419da73d4c822121bf6ced304af1fd998448abde8466bee906e5b103c808f3d89c3b0d2b88ba8f56eb739e7d186720f534cddc745d7c3e153829adb86274c8a93c4614bd4a50697d64007a8f66ae07cbda5f05606b5a94abd5c160877c7ae3665697aa20321e363998b8608c2accc4e72e31d7d16f4b321836bffb5a45b7b3a9a5dc0afc47910d7e4530f90d9426fa28da584e19a0d69372feaf102e6b2075adf9ff5f6e8d6fad4d1f53b975ffffa4a8994272362702d78cb4dec88d4f6bc143c043263059147bcdf085d1e0527ab0fb0247b81c7296bc9a5f0f6dff1f4385bb939a1340c70ded067673993b6d469b18933ca9cec696bc0567d42edecff58475110bd43f1a3569c9e1ef8952a86bd0d19a3f5164cbe40d423983fbccfb688a3977b525f34670d25970d6f32469f42ec7dc8296b691378b9854201183ec048e4146884f4b890199e54daab2d9661c0474fa2402d53c5786b6e09f93f5a5c695bd20af97f6b2486ecb019f402faafa2d7540801add21016545a7db8c95135c96d3f3fd4c1b59c231a61e1f4b862dfd7d840264ea8087f1ccc395371ef689e148cf1a53982acd59e18bd9ac638d2442d4678400647d84bec53c29a6cd4903ab4b6c4e4ec9692624fe02acb3e71b06332ac6393b3ddfffdfb5fc336195585a46061784d78adb4013e394c2d1c8680ddc4337e66c868e37f71666ee9b9595561922a9505906d2df8706334abc82b01f8da79667b03f7abc15dccd795d87e0f35d9751a10e0a5f694cd0570eaf58d22515f2912529c1d1c599dce1a809c8483b2270fd2478c66405b493529d079b5370f120c1d4bafc6245dee391e4354ad1c0f00730dcf3a2f6cd6216e4755f14785c22b8414e050875f5fa378087d3b47dcd33389a75b029611a5ba8c23b5708cc54dbf7e36b706148ad6c6bf620f32ffa8b8fe512328032df232788db222c1e5788f34a60d755cb57662333828dbf6bfbb045b56e479d11e825703e3123cea8bb9312735c754597bcb7c97ea839e15887a2496415090f0e974d954d6b3e71bb015349e6ca05ca946b299abd850ff63cc7e713a0e83b8a2d2d36b3e3c7ec661dc48d5837f34e8e936f0bc030e851411bb4e1b0be9a4385c6d036f3d542eb24492e4c40008b2495529f959df24885de7e85e1185bca7d3c439b072f1be5664c0a84020f43cbb99887c54879639b1b1c8a0e331499bf6840309a53542d08469c202843d3a77e60c95744acf0502084203eb14fea2c2c3a9394e6e972fac4bd3c33f1202a33f5593fd7fee2dcc39b227e406db29c821cdc85ff3ddf54db7e253cd2e8997ac1211a92c761021d4f5ddfe96c5b71d701cd7dc2140e641d0ce864f70ef04dc1f0c5ebdb6b815b16463d4a224a96917cb0a659fc1725ed3ec631d9b76d5a346140f43cfab62ffa0bf45ab777db9567d51108a82df5f51e9ebcaee0bc7e98a56bf5cd898b7ff731bd329caeda77a4132f4e9f5061b9f7794a123327b3915d68c242c5320bc4db5fa013e4d812fb07fb12328c7e55ac98f126fa9734b77df1e9df3e92f4a0f36a1a315009f380574f6541259c8401650931ddab80a7b92aaec399571100aeda59ffbc269d5c443a17bfd1eac3d0a1f8697f93e4202666d834765aa64f3bf5f55a3e736f37f7b1925a1e7445055a411f065dd39c783e4af83d4c518930a70613daf50d6a246d2b9400d2ae4ce3c41c968a54c2dec502622c3522b12e6eea1278cca28067f964d4db47a1d5d5850a6bd7441fc1dd855208d50af19038a0bf053fa5a10f310f72a10adfaacfcc30c41cf150587e3b5512e893dfb15b2fde780eecf761babae22065ad7627256d8a9d105a103841ade2cee7cdeacd76ef8b7d5fbe447df497ffbcd4f777154541455cf37184d04a678119a43a2b064ba3c5e3ecf8c50f9e2b8042c44570b7cd88b4700fb48d2d1ca998fb854f7622b6777599bfd4bfacbc33a61c55c37d03092cdc3ced95e97a88662a4176d1752e0567c35c7e5b590e3ad70e1184d0ec3cdeb4a45ddd6c64292b6bab0e93e514a1bad88df997f55d3b9116e94074f7153244db63d9903f2a393130caab7852aeb81473ba9e845c54de9287654e46448725498db43d260cc49f38f1e4bdea99dec70f69b7840811faa0591b88127ec74bfb68e183da26fcc6e1642dbf6536feb03473ccf091ae61c62660d9e93cab9e238036a3a65a1c966688f2f50fac535ac65acc6505673db8d66bb317aebdf64e52e8967f5287dfd4926b016d861e82481df9eca5fcf0c05f404722987b3c42b270dab9fa1134d8a1fd8daddf4261066f15e46c3cef84291769bd65deca9e504e0f3ee2fcddc999a974e7f242abf84dc6a950bbd056016edd430ad29cd29eebd3f48719ab4e55887a5b3a214b73b837f154da505e7cf7154adcc8e8efb4d56d3eddaa23a7c2440869e4f86b33e7f2f0e4a3035daed022809e9a6535091b298201235fc4beda80a5c950efa0352737d8ca406b02a2a0a6c0d77fbc54311f195b5b758d32e5c76e2c10085dc34b03b8db46e8053b8f5c30e218a833e96d1da7329d2c4efe9e91dac748f90494aecc407a5ae3ef0ea935172c8de8f46d6943d9b611040fc4eb3bdb973c1768f574090363e5b6fe0923daf59d36fc4c286271c2d3dc12d207bbfa32f60e757e046f147afae8d01b76a21e60c58ecb3a28fa1c8adf859f043efba400f1bb76257b84e69e1d2f3096d9ead14d163ba2aadeecdb1403ef18797c337568b9c8d92c50efbf1ebf5b4855e409ce499c134088e89d0e073ceabd4594f3c6376e232850a455085d9a72d4e73b8efac87faa1877471862e0d6f32b6386dde5fec24e6a38856fed10ec5a9b3b2150ffa0364e88fb8c392520ee6143a5add22a0a5fc2326f7ae2a86280b44faffa662b3d757a5e7e8b8f9253857808bbb688a2b574b3a7dcf1d3fdb2b21a662e63383a79a0705297f53d1a3c00b49ceb90cc314f8dd7f6b99e656b1ec33cac7b3a733702e957e6baedf69d27391bc0adc771e472ee685412cd6749f6b69d248b08950c6b36fdec4de4d0c2f17848cae98b20a01fa429fa7952072af7160a094d5fe7c28159413f89b00d74c43c9ce039285b56b64e5da2e34e3ff5ece4b55202f1a9fd0608e5196a1cf58ec66d3e22bbed640193882d4170448d11ae06305cc1c3e1b3dcf37fcafa74c368caecdf9b6b8c6d6ac1d106e0b5198115097fbcd328f0d568d6a4769606cda5ac151c994257aa3c00908dd42e96bf74212f9d896b9adbadb02815cc95f71f8004b025a2e2a91c0b89e570ba591926f497df13f27a1eb326d66af6d91e603e743c8532c4342160b2ee5c9e314fdd82a884efb856be13b80485794bb1becaea0d97002a67b0da7770a507a241e07f8115f3e2772d80ccde6110090182a820aa1e3d9fc59884612043a6df22ca612e6a41122a6fc72ea9134968bcea9a15380a32c01ead97fb5a9d2a67916c6e8b4ce2e842335d1c7d7b515ce86bcf624fac35066573e3864edcbafebf78b116cb87a93725468e83ebf4c7d470620b056a75650bc217918d4fcb9e68aacd6fab301f43acd6f33dabf767040b5460461e61dd0f20e45a2c3af360dec79a9063b640c17ece311fa041a2b7cf9391e651aceefef209b9d0c73799c49e64ce7f8c7ecfd4fb3f235c987b423cf65481609e356bc932ada9e84d021bfd3115c037ac5f16cbfe933cb08925f19b070e53018fc24ba8180146ba0b4f20a2e931889f20ed6d49d64391808767efabc6f29f21146ee842dfe7a84aefbf7eeb3daf48462a453852bbd31447cfbff1dceddbba29c7fd53a5f52132b124d9f6ea9a7b957c6920e050e530474cda7228dcebf163f9cdcc9d3e27683a48ca7846ddb7e8c0878e7452e465e944422bf7b321ff10bf4c35957ce8dbbb983e1b8c10ef7a8d0cd22cc9b031b272177ed2451d3ebfc2771cfefdb4c3995d7146bbd97e8a46ce1531b453b5d109092666ebd8f31d1aad0fb8e9a4b216ef594e62e5196f6b2cbbc43a9511d695de641c344d883e08dac46e4443605aaa336eb549122cacca5d9a3a7a715179bfcbe46fbc2fde48de76e5b84cd9ebae540f0b1c968ea45990ce6b0498a69676dc848137d850258b2dbdbbb66c6e801a1467b569e0f415806f76cd6a92fd026b0d9d5ad75888d3d0c3cd4481df8fae96fdb50a5c5c2827686d4e3c922d667d29aa4ae80061beb3894605a034871caa1b97d9bbfa98f623f13db2a6a45f7b01898a8009aa24014fb78be87dd09df876cc71df496bea58b5ff8ce1c5078f11ec592a15ae2df947ceb41bdcfc29309fea9247eb6ebb55e3d5196edac8cf97791e03044af399c95de533e72f031ef0214f07c7f6a7e26d77723b7d053cc1eebd3ace6cfcd84c52796f8413831dcde2117c534d593ed28fac5e6fc12d686eeb109265e2daead6676ff6d25a9ab68a82a4ba61a4d5f49e3c4308e53c84ef74fca732819803aee1100cb098388c9ef08cd0bd9babe7a88ca43267e61fff0690fbda760783b358d7283d2092e0c14729e0c3d8e81eda93ab8a8eec1f4dd5cd40becca547a53e2e58e62a7630411e810e6c760b9a8dd45c60bcba65b48113b6c1337f235cad8d381681064801793dd408a95ed7dea23adc18ea6ed6a4c0efa2befb99c8773f8d23cc05087299d305da89d90c2a296528491e46129d83f9336210cfa55f7298fb51d1f0c96d8f66da5b10631dc2643216a79ce73a9558f8cc3f0e6a1ab4230011ed2ffdc45cfb74e7765da738c2c45a8f9705320aa8fae4e656dafd3d340b683dded2158118feefa6bcacfb5aa7bdcf25107851fd3239393152c083132fd81114f78bf437f397274dfcd910c138a0b5b81069992c050c5abec9d0951d3414a59bfa015f08858d06dc6180df69d1edafd3dc7e6902456529ad906175fb58367bb3905d8e15e56bd66c64b20046c18a440cfffe52d742805d80fa3950c41adbd2c156e9c65af6898eb2f3379e7b19d581ec686413311196d29165573b60f6ff57fd86aad2dd7b9f80cc2f2b94245d1aa893ddf6ebad785f631b95022a9585aea54c05402cdb5b0f68dc4ec2bd15605346dd8a970176bf6db620103016f16684e86f13be642f0c844f6c90ec92fccb916f01f547b9d675dfcb5bbb0bb3e1004bd4f4bcde59e28d9fb93811f469e6ec8e3f4509147ef9ebcd4aada5da8e945aa9585df39d163c040ac993dd705c84766c7112d6c008d237e0aa36eb07368f39d72b1745513352eef1d06aee0d184f403d2a022f5e53659caf6de1cd21dd51935300e1e286cee057a69f1aac4b96f50c5d225be006baadc0fa41006a676e5320f9b91eace5ad78dd782d56c11692eda17fffcc378b7adfa3a8842c52c28643f3c656137aebd62bfed3144b8653132a1a627ba8a86b2d3cd98a514a40fef39778110acfd8e2417f67e3673574f6e165e9841711f733f9a67880077b741f48cb45eb37cd83c61706f8ff7a64aae10d00e68c2a1e68d46c8d2c035896d1d4dabe336cb561ea79a08782ba96b074f8680c385b74dcc2d0000d1b1f830e2ddb59b8fa57095320be1a89e7f444d2a82c7795f87109a579cbbe13726eca22d68fa3170001358921714f5fc6c6932082ea2a04c1dfb332909366492e95e1df3266d7c6dc7d08a2ce3820426d29ac8847b337da6acd9b18bdbc8733fea933451b466bba15bcf2510e356bc21de1636c024a0968ce9e6fcde7935f33d2b198d2b528b7eae1350a3ce92af587cef0cfe09e9ea18e6c4958cd415b00d42f506c1ffe0dbaf359562e814c0bdf706655e4cb91b5977b2f11deb51f5a08d5429d7c3a75e5e30610f6ac2108c6bf44cf62aff790be4c7bb4457ef44946ffd221dabfb2c510ccffc9e6868660bd838fe58f489441624feaca549d57b6273d51b944f49be2405079c8735ac06304f178a3018f51482a3060f8143c611500897e8a4691ffa67339c0960e0753bb022797ee39ad8a11968c21c138ea3fda43163626e7fe7672239507d258b203005a94c93380eb2189cfcf10ad96d0e689896b5553c0b744ac53483a41fc681ef4a455b2395f0c53113790203909ed635eb006f99b3607d52b777a62c83dcf277b494454b0c0a4982eaa2b60f4dae3bf3914c1d8f31e09829b59b585fa6a45f7db895929668872d2343e602976f3b883cc455918a705bf27cbafa00a7beb245a3386d30198c76bdc90c70f5a7c8b205a18900fb00b9315676a25c472370cebe1732bdc2f950d7388d4293428992db7046598bc4b776fb3d0ca93d70813156884ae5aab662605d14d555ce148943c4968dcdff0683a013f3842b3eaf48b69e0755d714247f883f9c6a16cdd3d4f01af1ee5b611e2d6a138c8f64a5fa362eb2a4f10ecabf20e0b99809e55c5be1238c29eb4fdec328f0cd593e867831895eee5685aa37ffc4ef4a7d2848b598416f4e3239132139bafd3cdf8c36f701511f1af478fe0a0a4460916d4c7e41fe16447093990d2dbf024bd2cd0ff131b3dd9d9506ca29211266005c5f8aae5e135940a5fba745dd7f31024ffcaf115c68059080223e72ac4e8e427f627b9cdecad9e9d9fd5d9b6ae1f137eb2c1b7bd23a19a2061fdc1141e75fa974f38b7b273a11435304507c99c639a9a20d15c8f3d097315a668ed9cd5c8ad1cc9bf884a467db760e8544021fa5cfb04762b22ee15e9ede0c32aa47ffd9e52e8b3abd5af30b115963a4ec49720eabe704c7be2f5b4b4574790754f2e37bd6333a45a9b01799356bf7409743b72227fb56b5f6ef6a04887a9e2b295b9bb666d0d2714e0900dbea16dd471bf645300d7d978d400f9a21361abd4a86a8a99db85cb9e9023f912e5eeae31ac217bebd9a8f2e6773a3120c7da75a116406395b602afb56d458d2b480b3031acf60e0ee60e64c043f16af86d9e5425979709a7eceddc0639e49321f45751d8d4d39c541e97e7b2926db2e185cc4215f890980f251e2dfeff175f0c05912d2e9e6c93178132e94c5ef48235a52161fbccb310e14c4e7367e3ce3cfd4f11aaf77f76e2682a857e66f3f4338d0e67063f78c171f9da29206203d61de43e2dcabe20b6803baf57a3aa444bfd0d0fea8659d559a432baf7bf29aa4556d89e3fbacb174d9477aa42037de905198ff316c609b9bda3dbfe859e8036b9ce5a5be7dfaa94dd1822ad9ff569f5e146996393f1fe7ee43eb8dbc88ef428ceb9656daab381707e5aeca277b409225635a9739fa80eb3fa65c31c9a1f4059d08e2193de21127dc2a3c7a952289392ad7e53ef88f4f311d384b235c27ba6a6ad15b1bd825204e14c48496f2cfefd563cea89ccda94e4fdd8485788a0b206af7744af609d571dc276147ae4bd8fb3f38ec1685c8ccd84ebc214c88803c6be322648b19caa5042440aa34b35df0c35d243047076def6654b70cfc6155b8c404cda6ad9d672bf5b487c030aa2e73105f7c0141ce54bac848fdcf493b61c58c9639c70af3004fc9b1f17ab669b5055aaf7202231416ec95d60df0c6f61875bf10bd5efe0b9fc989dbde0eb9c209be42465646c31c9f5dbb76c044dfb8ec2bb1ef42d1f3ebf34f6086949b398f1517f359cedfa875db7f82c835281687183a423c4f6ca8697787eec7d3df3cd13e5f2f43ecf237d4b3b11bce8ff4146221bba5dc9dc4762ec49cc278133f563b1069d96beae39f6030148de1966a2acd6d0ed9505ed002533e6f14a00d13ae64ea1d8f718674a25e3aa9ef90ba8273b91acfe4610a145c372720336569b87a2c8afb6a685e08fcfd63cea4d1af2ec7388cfa205a669c59617c85bdf7407f215bde6c30bfd0f6a1a2612c21d7ddaaf9aa36818f2498040ae5998c7e6b50f13be24e79cddc5f3f607c08391674b8599ae1e711ce767e73cd221d25fe411f14076ff9b52048812c844fd7b464b4f31ddbb6f76ef3e263a3b9b4cd4faf0269d46ed3befe2afa037857d0d6dda61cc636989138a58738af236d97c57ce25beb5be1f874712705ceb8cb8302a09b73692cda8c59b3e1ca7a6c2da84cadb4e9292e0e6363610bdc861c47a8dd50a2c0564e81bbb074d1c2527b55cf690e0d8a59f05ddcc52ef30558ca0f5d0bd438670f34ad9ccf81b17e3ff4501721035b08be3c6d0b094ff3a823b08a42ea449a3d7daaf8d418efe9956f9ad1e60ff0ae5369a2ba419a6236b981f1a6502615c5d4bd64ee74e56b62978cf4c1b754da47440b1f97ae04253bb7432163684542850ee169c40cea2f1ee7b0d24b4fd17709f7f3d8865cb483cb0db7e3aedfcab56ae24e8a06d63b735d0bcef970197079aeeed580c658a4e62c0959e85174bf3b3d620a308fe984d97fb7abc63291681bc2ea01cd18b49f4ce27a578e8c33d6e1e0ced1c65ff416176eda109de3b9b8cc3c938284818a770114b2136bccfaacf23c2672d060b42f3d7742a9eebd1600a988700ed4bbd9e198de8167a95a821aeabe9c1b36535baa8b29320dae10c202a218460f72ebf0a08fa4d357b14e840c465d37d38365c3478717a3789bd88a7f33ca4fb181b046a8600b8613585553c17fcbaeaa98096b814428249bdd4b5d19d905a7ecdfbcc42535338a5cc7c91e3f142cf5f626d0568b6fc99af7b71077c7902544c5544969864a57863e189dde2dadf2529290a24f3164729ed578a753e718933895de9902639273c18734b1ceec91b9d601f656f6a6c8962e36796ccc5b7a76c53c041e2848f329f7b268258b07f5be1449b01837bbdca6fdda6945510faf7a9ab26a4c18f01058459fe2edc7b84f38a90777d294841c3089ec2849c32780315f37b9b7c43e84a3f5e03c1a10bb2dfce611449e1484a7dac20f98a6d82ea5911541901541a823b70088c7fb9584e59ae0f536186e8fd690b7d6162dec28b3a0b1b4cc1c90b6f06aea015d98e7fd9da3b60bbb9433e9efc43127f289b830713bda70b237d06cd0230a3c545f1934b68711c3e840c1f64d7039259b9d4c7dfad7f5512de43dde5b303fe0cbd60d86b16503d7b84ee10bc949c6c371bb2361ced36b81ebebfe5ec7a605f1c1e7dea5f452ec7a4e5973d511106aa408b8bada7cf567ee0b12ac17463923db23eaea10b128d9497d6af931bb13d5b62765e8d144be0280d7630f44877244b8a830093fd300086563540638990dc0cd3697cc918c00505e281577f4950e6e3fc6a720ff6331aaeff776359ac1b1222225486caf25b16b70d2acf7233f09aab54465316f59997343b797b10b2d8ec74ee35a7a028d9c1be59ac55a900e27433117214f2ae86eb2b7f645e1a065dbcf3c5d12706f4374b2725580a1348e8045870fb1d672dccc6b49123fb965205536188700ea2a7db2b21082613ff6c5e937772c2c5edefb13be67e59d256d971d507affddfdce3494652f723ae04058c874848240224770d46d562006676316a7380688ced1c44f894480dca8909e7a241b549012e8c92e94009d4ef8c3199dfc7a0387b0ba8dc19008073175e1622409189cb4e96abf04e0d528ab04fd74af5b4570fa642f873913c0644f6cc35cf5c7f6b218c2b21dc1d20e23773554b08dd57ff81eaaf7e653cd6750cd73c736ef83b5fb5e3ca5d3359c116632370c91630798fa386161c4aec9f91d18a29312ec90c2fa454fb30f558f84f9a8066a3b7ab3843c4ffbc4c6acd1db29ea7f6f3b0f35a2b75a8c7907b3e0ef7b226fc069861db67a73358583038572e3d6775a9766448c473f20d409831e09fb5453f0f14cde256d56aa455a1e559b03bc158a2aa8c86b5ebc4e73310835aa73ba5087c5605806fd39058baa8c49b7dacd82e67a13d4e0be45d5c70010cf20c079f85395bad5d5f275fbb34becf4f835466a6680c66dde41dfa178dcd5ffe3b5e7bb3104eaacd9454c3ec225a0e3d002b4a864d86ee6ce47b2a6c514ece0f0b187c89a6e5ec0ba6dadeebc0010b7d5783ceb42dd40f5bf963a619f70e5a1f5d80aadf7f23798220dae9a8ccc2cf3d21f9bff8375baab7972305852dcd44a3299fc6ba577b2318cb9f915c6826160293c5b71813a2c98e40d8ea1b8ac7c463c81c0fb7d347a0f736596175b33fadb852528115a12d2b3445534fa489d2175bb79b60f876e2d068b64b023e00910036905f71548a41a5e2885288be6c69a98bcc231a9bfd1300efbff3243b930411bd4dd74b8cd78da7a0f06c7adcf10e319f587d059f32c5fda3d5b51cdfa89ba49044186474c6d15ff3a2b8cccd0748436e883519df87e467187b2ab549ee876faadd6787742396b58fd08610c5258248fb798e79694ba15f91f1a2708e72e4b3558c9797356850eff2e6a05c30cc3b0f52d27425e843f35ba97eb707d75ddf3d199e98545122f55e5f19f6af8257155294fe9c758b7d9632a6d0a0c38eaf33e56533ab37450c55cca2ae1a73a3c8387cfa073c58305425ce9031871af885caf1c177d01a5bd6fd115257911a0f2f9992cbaea9f0d6d909deab0bf30bdf44ce5b1fb4be2f45b28c728b0a1366e880921504f86baf3e8f76b7b901d0d418512708f5a4eb0d12c5558fce67edc5097eb07b269fee41a9149a25861f0557083919213e4c89a4a384b94939520597ffa82f44f28ec84e63b62a7db97be75975e18c8726abb2e14dd5f61a627745d4e010935331f6ae493992c54550c462558cd49fc2db1d1ac0c3ee1cb892a42ff344827f605dbc6e78b3aa7054e28cb8ee35e0031eb7287fb0f509666499053ad42bbc15d96bfa7d6d7d7be148c3fa0406ca04af913bc353d8e3e78d2871efb5834c7af710fed4de24e75e4f8ff0e2c0856d7e05370f07686b6dcf51dce3919d12d228169d790848f00b8b2bbd4751d1f406f83d9dc6389d14400e8b7e2f588f0d2d999dee7cefd5230f05d60e8fbb37788a8c6c634501bf62a04504756f792e5f1405ebf7878e6c3621d4141c44b22d512f85578d8b7cc94b6c83538692110bc6130f203ba00fafa231c52f651522604c712a6fa6392e8c4ae01e5209b67e88b527cd836b754dd1ab20221d7a30e44c463b6640e81f6e68979bfd5aab291ef856b59013f683c7847a869f7d248ffe677a82f5e898a5cdd559f49d4617ebb036ecc6c5bd18d462a5a47e3bca4e65719b5a90acb53321c7086860a330f9394f9f5ba81ae3d0b970f5f6ad8d05491cc5e6b0b64649bfa82492ff06512020d7b28827cc4a26bf78adc38f3a9e223529bba0eac24b81a9d41c6fe0b6a95aa0f282d1a368ad3f9546b5bf04e6efd68aea016e33f4203140df60d6e53fd870fc93f1f3d03a7b4e1f9d33b11708976e0536d05c7c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>离弦</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E7%A6%BB%E5%BC%A6/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>破碎尘埃在掌心堆叠</p>
<p>太相似的岁月</p>
<p>连泪水炽热，都被抛却</p>
<p>我想我是在等，某个微小瞬间</p>
<p>一阵不经意的风，就颤动某列和弦</p>
<p>唤醒过往誓言，再度闪烁于指尖</p>
<p>编织起音节</p>
<p>牵引我去比遥远，更远的天</p>
<p>（初繁言《离弦》）</p>
</blockquote>
<hr>
<blockquote>
<p>所以看上去，故事已经临近尾声。</p>
<p>但我想，故事大概永远不会结束。</p>
<p>这几天经常想：如果我联赛考砸怎么办？如果我省选失利怎么办？如果我国赛出错怎么办？</p>
<p>如果我没能考上北大怎么办？</p>
<p>所有人都在问我这一个问题。</p>
<p>所有人都等着我作出回答。</p>
<p>他们告诉我：一旦我输了，我就全完了。</p>
<p>他们跟我说：一旦我失败了，我将永远翻不了身。</p>
<p>他们是谁呢？</p>
<p>（写于2022.10.08，国庆集训后）</p>
<p>考前跟同学说，我特别讨厌自己不能掌控的局面。那些即使我拼尽全力也无法改变的局面，我是难以面对的。结果还真是一语成谶，现在我的命运脱离于我手中了。</p>
<p>每次听歌，听到《猜火车》的时候总是有别样的感觉：那种青年的迷茫，所谓“未来即是永不到来”的迷茫。我记得曾读过的句子：“对自己命运掌控权的过度追求，是妄图以微弱的天赋和丝毫的努力，挑战造物主的疯狂。”想来大抵如此。</p>
<p>好吧，我不知道故事会不会就此结束。故事开始的时候没有人会一下就注意到，故事结束的时候没有人会相信这已经是终页。造物主的笔永不停歇，没有人会永远是主角。</p>
<p>（写于2022.11.29，联赛后）</p>
<p>我是个懦夫，所以我不敢回看过去了。</p>
<p>我也是个勇士，因为我要看向未来了。</p>
<p>（写于2022.12.18，省选前停课）</p>
</blockquote>
<hr>
<p>删删改改过好多次，最后还是打算写完这么一篇文章作为OI生涯结束的标志。已经好久好久没去写一篇这样的随想了，所以感觉自己根本写不出来什么主题明确的东西，只能写一些不知所云的碎碎念。</p>
<p>但想到Anlin老师也经常写这种碎碎念，于是我又登时充满信心了。而写了两句就发现自己文笔远远比不上Anlin老师，连一个明确的主题都写不出来。然而既然已经写完了，姑且认作我的说说合集篇看吧。</p>
<p><a href="https://www.bilibili.com/video/BV1Wu411h7t6/">本文的bgm</a>。</p>
<hr>
<p>退役后这两个周一直浑浑噩噩，白天几乎学不进去任何东西，到了晚上觉得这一天不能就这么过去了，于是一直学到两三点，然后第二天睡到中午再起床，于是下午继续浑浑噩噩。</p>
<p>我记得我高一高二省选后补课都不是这样的。</p>
<p>高一省选后已经确知自己进不了队了，拼了命地补课，当时和她还在一起。记得当时补课压力特别大，因为补一个周的课就要去考月考了。有一天晚上精神崩溃了，很晚很晚的时候给她发了好长一段话，我知道的是她平时睡得很早，没猜到的是她却迅速回复我了。我们那天晚上聊了好多好多。</p>
<p>最后的结果就是一个周过去了，除了生物以外所有课全部补完了，而生物在只补了三分之一左右的情况下去考试考到了大实验平均分，最后赋分到了总分年级第十。她是班级第一，我比她低了$0 . 5 $分。</p>
<p>我一直认为自己其实是一个很狂妄的人，但我想一直到现在我说过的最狂的话，还是月考成绩出来后，我说，级部第十不重要，重要的是排在她的后面。</p>
<p>现在当时的种种已经是难以回忆的故事了。前不久看过一个视频，讲的是人在失去什么后，会应激性忘记大部分不开心的事，然后只留下那些美好的回忆，于是越发不舍。我想我的大脑可能比我聪明得多也理智得多，它选择放弃了几乎全部的记忆。</p>
<hr>
<p>高二补课的时候是极其不甘的，联赛挂分挂了$65 $分，省选第一天明明拍过了出来也对过思路了，本来都充满希望地认为自己将拿到$248 $的标准分，结果挂分，最后无从得知是否能进入省队。</p>
<p>那时我突然开始想，为什么要这么拼呢？说到底，对北大的执念可能是一部分，另一部分，可能是一种复杂而扭曲的情绪。我一直抵触将自己标榜为一个过于注重功利的人，一直试图掩饰自己过强的好胜心，但我的内心是极其争强的。我见过的几乎所有的老师都有一种固有的观念，那就是成功者不聪明，失败者不努力。每次有什么讲座或者所谓优生交流之类的事情，都会有老师在上面说诸如谁谁谁并不如你们聪明，谁谁谁是我见过最聪明的学生此类话。我印象很深的是刚开学的时候竞赛生训话，说到我时说我是所有人中最聪明的，但可能会成为最后的“无冕之王”。当我真正取得成绩后，我又成为了所有人中最努力的，最“听老师话的”，其他人代替了我的位置成为了这个老师口中的“最聪明但存在问题”的学生。没人会喜欢平凡的人的故事，人们称赞成功者，惋惜失败者，并试图从他们身上找到一些经验教训，为此他们不惜强说因果，因为没人会选择去从那些玄而又玄的命运或者天赋中汲取经验。</p>
<p>而我听过了太多的反面教材，于是也害怕自己成为别人口中的反面教材。</p>
<p>所以也许我一直都在怕，一直怕别人对我的评价，怕别人说我如此聪明却又不努力，怕别人说我因为一时的恋爱而影响了一辈子，怕别人说我钻研难题而导致基础知识失误。尤其是那些我在意的人。我曾经也许真的有那么一段时间，不顾别人对我的看法，只是按照自己的方式活着。但她走了之后，我发现原来那些我所珍视的人，原来他们对我的评价足以超脱一切相处的记忆。甚至一件事，只是一件事就足以掩盖曾经相处的种种。</p>
<hr>
<p>我至今清晰地记得我们班主任来通知我进队时的情景，我补课补得差不多了，在教室里等着准备接下来要跟着班级上课了。那节课大概是体育课或是别的什么，反正教室里只有几个人。低头写着作业的时候发现我们班主任进来找我，他问我，我自己觉得能考第几名。我愣了一下知道省选成绩出了，我说老师你先告诉我进没进队。他说那肯定进了，但是你猜猜第几名。我说第九第十左右吧，他说，第五名。</p>
<p>我记得我当时从椅子上跳起来了。然后跟着他在上课的时候满教学楼乱窜，最后到了我们学校竞赛总教练，也是我们级部主任的办公室。</p>
<p>级部主任看到我后笑着对我说，你怎么跟范进一样。于是我在办公室里喊了一声“噫，好了，我中了！”</p>
<p>他们不知道的是我昨天和wmy打赌，我说，如果我进了A队，我就在宿舍里唱大风的《范进中举》。</p>
<p>所有人都不知道的是，进队后高喊一声“噫，好了，我中了”这件事，从一年之前，我就开始幻想了。</p>
<hr>
<blockquote>
<p>好想就这么一直下去，好想自己就在这里上学，虽然很累但是每天可以学自己喜欢的也可以和兴趣相投的朋友一起玩永远不要回去面对文化课和文化课同学。</p>
<p>但只是想想罢了。</p>
<p>（写于2023.04.22，省队一轮集训）</p>
</blockquote>
<p>后来自然而然地参加了一轮省集，然后去了平邑一中集训。在我OI的将近六年的生涯中，在平邑一中的这两个月是我印象最深的两个月。每天有教练安排的任务，有一起聊天、一起训练、一起打羽毛球的朋友。很后悔去年这个时候没有来到平邑一中，如果那个时候来了或许现在的OI水平会强上不少。</p>
<p>二轮省集的时候阳了，本来都让父母不要来，然后父母瞒着我买了车票到济南了，然后拉着我回烟台了。然后是SDCPC。我的OI生涯中掺杂了大概四五场正式的ACM比赛，印象最深的一个是美团杯的队伍伞兵队，那次和lrg、qhr熟悉了起来；另一个就是SDCPC的队伍BAD队，和dwt、qyc熟悉了起来。</p>
<p>又想起省选之前问学长们问题，学长们对我的问题除去一些确实过难的问题，几乎是有问必答。有的时候一天会在问问题上用上三四个小时，也耽误了学长们三四个小时的时间。</p>
<p>有的时候惊叹于自己的运气，能遇上如此好的大家。无论是平邑一中或者说泰安OI的大家、亦或者两次ACM的队友，再或者是烟台二中的2020级和2019级的学长们，遇上大家是我的幸运。有的时候真的会想，如果自己低谷的时候没有大家来安慰我、瓶颈期的时候没有大家来解答我的问题，我应该是绝无可能走到现在的。</p>
<hr>
<p>NOI的过程没什么可说的，考前说自己不擅长拼包的话真是一语成谶。</p>
<p>最后倒是没挂分，也无分可挂。平平淡淡地考完了NOI，拿到了一块低分Ag。</p>
<p>前段时间那个“爽滑慢舔”很火，所以去听了一下原歌。听到“偏偏雀落人间”这句词的时候一愣。再一看歌词，发现是“翩翩雀落人间”，一时不知道说什么好。</p>
<p>也许我一直自命不凡吧，一直觉得自己是天命之选。</p>
<p>最后发现落幕的时候倒也没有英雄的悲哀，只是突然意识到自己也没有那么特别，一个有些天赋、有些努力的普通人而已。</p>
<p>我想这大概是我现在消沉的原因。</p>
<hr>
<p>前不久，我从歌单里翻出了《少年月光》这首歌，听到双目含泪。</p>
<p>哪来那么多天命啊，哪来那么多平凡与不平凡的论调，又哪来那么多反面教材。</p>
<p>我在怕些什么呢？我在担心些什么呢？</p>
<p>我已经走到这里了啊，这还不能反驳别人口中对我的诋毁，对我未来的诅咒么？</p>
<p>这还不能反驳我自己对自己的贬低么？</p>
<blockquote>
<p>这一路走了很久很久</p>
<p>走到少年老，走到年轮旧</p>
<p>梦结束在街口，或绽放枝头</p>
<p>星月还在，只有云悠悠</p>
<p>（瞳荧《在人间》）</p>
</blockquote>
<p>有的时候会想如果我不学竞赛，或者学到一半放弃了会怎样。这想象如此之困难，以至于我无法想象出任何一种可能性。</p>
<p>很喜欢一句话：“在人生的某些时刻，你只能把它归结于命运。”我有的时候会恐惧，如果这命运走偏一点会怎样。总是觉得，偏离一步、走错一点都不会走到现在。</p>
<p>但最终我走完了这一切。</p>
<p>也许没有走错不走错之说，因为没有正确的道路之说。我NOIP后对挂分惋惜不已，省选结果出来后突然觉得，如果NOIP没挂分，我省选前大概也不可能如此拼命地准备。即使竞赛这条路最后没有走到NOI的考场，也许我的人生也仍然没有failed。</p>
<p>NOI Ag意味着我在准备高考的时候可以轻松一些，但毕竟也不是大道坦途。至于以后，我希望自己能沿着曾经梦想过的道路走下去。</p>
<p>现在我走到了这里，不清楚我和运气谁的功劳更大一些，我感谢我自己，也感谢运气。</p>
<blockquote>
<p>这一路好像没走太久</p>
<p>情感没腐朽，回忆没生锈</p>
<p>距意气斥方遒，没几个春秋</p>
<p>怎么能走到厌倦以后</p>
<p>（瞳荧《在人间》）</p>
</blockquote>
<hr>
<p>一开始听到《离弦》这首歌，其实第一反应是箭的“离弦”，觉得讲的是那种一往无前的勇气。</p>
<p>后来才知道原来“离弦”可以指代离别时候演奏的歌曲，那偷来当我的OI回忆录的题目吧。</p>
<p>虽然很不愿意承认，但我的竞赛生涯也确实到这里结束了。大学不确定会不会打ACM，至少OI与我的关联应该是顶多出去讲两节课了出两套题了。</p>
<p>看到这里的读者，我不清楚你是谁，也许是完全不熟的陌生人，也许是一面之缘、点头之交，也许是关系极好的朋友，但我都要感谢你看到这里。感谢你听完我的这些碎碎念，也感谢你来看过了我OI生涯的最后所留下的残篇。愿你有一个灿烂的前程，愿你幸福，愿你的一切如愿以偿。</p>
<blockquote>
<p>你在人间走一走</p>
<p>有温暖也有寒流</p>
<p>为何奔波为何停留</p>
<p>是生活亦是所求</p>
<p>熬过苦累悲痛，迷茫不必再深究</p>
<p>你的存在你的意义</p>
<p>因爱或被爱而不朽</p>
<p>在人间走一走</p>
<p>从婴提走到白头</p>
<p>理想与梦是烂借口</p>
<p>一直前行便足够</p>
<p>（瞳荧《在人间》）</p>
</blockquote>
<p>最后的最后，如果让我对我的OI生涯做一个总结的话，我想化用瓶子的那句话：</p>
<blockquote>
<p>当我回忆我的OI生涯，你要问我觉得成功吗，那其实没有很成功。但你问过程精彩吗，那我觉得真他妈的是相当精彩啊！</p>
</blockquote>
<hr>
<p>2023.08.12</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>猜火车</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E7%8C%9C%E7%81%AB%E8%BD%A6/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>题目是后来加的，是一首我挺喜欢的歌的名字，原本题目是日记的日期。</p>
<p>下面是原文。</p>
<p>现在耳机里在循环播放《猜火车》。</p>
<p>五年前的我，不谙世事。我在微机课上第一次接触了OI，老师推荐我去学，我就去了。</p>
<p>故事从这里开始，我从此接触了我将为之奋斗五年的OI。</p>
<p>最开始年少轻狂。小孩子什么都不懂，刚刚初一，照顾不好自己，也不知道什么叫天高地厚。当时觉得，未来还离自己太远，却又在心里想象未来的辉煌，觉得自己未来一定无比光明，会去北大、会搞科研、会做出许多许多的成果、会青史留名、会有幸福的一生。当时还什么都不知道呢，考试考得有点不好就是对我最大的打击，会哭好几天呢（笑）。</p>
<p>后来啊，时间一点一点过去了。</p>
<p>我亲眼看着我从山顶坠落、亲眼见证苍穹的沦落、亲眼目睹所有的骄傲被打破——仿佛我已经泯然众人矣了，仿佛所有的故事都结束了。或许我该退役，该好好回去学文化课，该心无旁念学习的。</p>
<p>但最后还是坚持下来了，还是一场一场比赛地打，一套一套卷子地刷。</p>
<p>猜火车的少年，永远不知道下一列火车驶向哪里，大概也无从推理，只是漫无目的、毫无头绪地猜。</p>
<p>猜中了如何？猜错了又如何？</p>
<p>我的努力收获了成效，我的文化课甚至比以前还要好了，我的OI终于打出了不错的成绩。</p>
<p>我敢不敢说这些是我应得的呢？</p>
<p>我不知道。</p>
<p>很早我就听过一句话：所有命运赠送的礼物，都已在暗中标好了价格。</p>
<p>我以为我所付出的努力、经历过的迷茫就是这些价格了。</p>
<p>我真是什么也不懂。</p>
<p>我终于迎来了幻灭。</p>
<p>我失去了我曾骄傲的一切。</p>
<p>我站在现在看过往，已经像看一个陌生人的故事一样了：他聪明、努力、善良、骄傲、幼稚。我无从得知他曾经的骄傲，也无从得知他当时的痛苦。</p>
<p>我只知道，他挺过来了。</p>
<p>好吧，故事又重新开始了，仿佛以前从未开始过，仿佛过去四年都只是幻觉，或者说是另一个人的故事。</p>
<p>那个人早就死去了，不是吗？</p>
<p>但过去的故事，没有结束。</p>
<p>我还记得我第一次来机房的新鲜感；</p>
<p>我还记得我第一次过题的成就感；</p>
<p>我还记得我第一次打比赛的迷茫；</p>
<p>我还记得我第一次给别人讲课的狂妄；</p>
<p>我还记得我第一次拿奖时的喜悦；</p>
<p>我会永远记得，有一天晚上，一个少年让家长拨通了教练的电话；</p>
<p>我会永远记得，他曾狂妄得不可一世，也曾自卑得泪流满面；</p>
<p>我会永远记得，他曾骄傲地宣称：我不能书写神话，但我可以创造奇迹；</p>
<p>我会永远记得，他在模拟赛失利后对朋友的哭诉；</p>
<p>我会永远记得，他在模拟赛打好后大喊的那一声：莫欺少年穷！</p>
<p>所以看上去，故事已经临近尾声。</p>
<p>但我想，故事大概永远不会结束。</p>
<p>这几天经常想：如果我联赛考砸怎么办？如果我省选失利怎么办？如果我国赛出错怎么办？</p>
<p>如果我没能考上北大怎么办？</p>
<p>所有人都在问我这一个问题。</p>
<p>所有人都等着我作出回答。</p>
<p>他们告诉我：一旦我输了，我就全完了。</p>
<p>他们跟我说：一旦我失败了，我将永远翻不了身。</p>
<p>他们是谁呢？</p>
<p>继续向前走吧。</p>
<p>如果你找不到活下去的理由了，请回忆：有一个人，在四年前给了你生活的意义；在现在给了你生活的慰藉。</p>
<p>如果你找不到坚持下去的理由了，请想：你已经承受了许多痛苦，你总得为其他的处于苦难的人做些什么。</p>
<p>愿这世上的人都能幸福。</p>
<p>愿我实现我的梦想和诺言。</p>
<p>（写于2022.10.08）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>昔巷旧梦</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E6%98%94%E5%B7%B7%E6%97%A7%E6%A2%A6/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>题目是后来加的，是一首我挺喜欢的歌的名字，原本题目是日记的日期。</p>
<p>下面是原文。</p>
<p>昨晚将自己关在房间里哭了一夜，最后下了决心：请一下午的假。</p>
<p>下车前接过母亲递来的硬币，以备需要自己乘公交车回家的情况。</p>
<p>到教室里，教室里是不一的读书声，我听见一句“风急天高猿啸哀”，听见一句“古来万事东流水”，我拿出语文书也想读，喉头一痒，词语就都改成了咳嗽。我几乎带着期望去看手心里有没有血丝，血倒是没有，泪倒是不止。</p>
<p>我攥紧硬币，压着咳嗽，读下去。</p>
<p>早晨又是愤怒的，我几乎带着莫大的敌意针对每一个人，却又在片刻后宁静下来报以歉意和冷静的语气。第一节课是语文，原本以为老师不来，拿出生物卷子想做，却又放下了。拿出语文书，重新读史铁生的《我与地坛》。</p>
<p>再后来的课几乎没听进去，我害怕班主任不准假，于是脑中只充满无助的愤怒，想着想着泪又留下来，低着头掩饰着，即使我明明知道，这样的事并没有发生。</p>
<p>上数学公开课也是低垂着头，忍耐咳嗽时的声音像是啜泣，同桌时常看我，我不知道该怎么跟他说，索性不说，谁过来搭话也不说。</p>
<p>然后是去找班主任要假条，再然后回班级收拾东西。我尽力让自己看起来兴奋一点，健康一点，然后少有的从前门进了教室，我看见地上的那个蓝绿色箱子，我突然感觉又有了活力。却也只是突然。我最后还是拎着两个袋子来到座位上收拾东西，然后是带子断裂的声音。</p>
<p>我几乎要哭出声来，我带着哀求的目光往那个方向看，只有一张空空的桌子。</p>
<p>到了家，带着手机，攥着硬币出门去。</p>
<p>我大概两三年没有走过家门前的这条路了，再往前的那条路应该已经有五六年没涉足了，一开始倒害怕自己走错，可明明是小时候天天走过的路。</p>
<p>当时还是泥土地上的石板路，现在是全改成鲜红的柏油路了。总疑心路边的白桦林换过，因为树干很细，不像是过去了五六年，而且树干都斜着，压向小路。</p>
<p>我还能回忆起小时候陪父母在这条路上散步，他们走在前面，我走在后面。倒不是因为关系不好或是别的什么原因，只是我喜欢在散步的时候想故事。我已经记不起来多少故事了，只觉得当时编了好多，都是那种孩子最喜欢的故事。有的时候还会特意构思一个悲剧结尾以体现自己的审美水平。于是又感叹，命运不是和我一样的拙劣的写手，不然它大抵会让我在昨晚下定决心后在睡梦中死去，或是让我在今天早晨出车祸，但也不一定，因为它还有机会，前面还有几个路口。</p>
<p>我遇见一段残存的石板路，从柏油路延伸出去，伸入几棵小松树，然后消失在拐角。我想到了小学时校园里也有几棵松树，玩松针、松油的故事记不清了，但又总记得。只是之前听说，那几棵树已经被砍倒了。我几乎确信我曾经踩过这几块石板，但突然又谨慎起来了，说不定换过石板。或许几年后的我经过这里，再看到这几块石板也会有一样的感觉。或许看不到了，或许不会再经过这里了。</p>
<p>前面是绿灯，但我不想急。到了路口就转为红灯了。于是四处望望，早已经不是熟悉的景象了。恍惚中看见对面有人穿过马路，再一定神，绿灯闪着，又变成了红灯。</p>
<p>我来到商场，多了很多新开的门店，但很多旧的也还在。我又想，如果命运不肯和我开大一点的玩笑，或许可以最后开个恶作剧，让我走到那里的时候看到那家店关门待转让的告示。可它没有这么无聊，我沿着记忆中的路，走到了那里。</p>
<p>这时候已经下午两点，来之前担心这里只有我一个人，多少会有些尴尬，但进来后看见零散的几张桌子坐着零散的人，于是便放下心来，走到角落坐下。</p>
<p>角落里还有一个女人，在那里静静地吃着饭，我过来的时候她抬头看了我一眼，然后低头继续吃。吃得很慢，我开始好奇她的故事。人总是奇怪的生物，明明知道有些人和自己一辈子只有那么一面两面的交集，却还是好奇对方的故事。</p>
<p>但在一生结束之前，谁又能确定只有一两面的交集？我曾经以为会很快变得陌生，很快淡忘掉的人，有多少一辈子刻在了我心里？我曾经确信会一直相交的人，有多少后来证明，只是生命中的过客？</p>
<p>我低下头，打开手机，看史铁生的《我与地坛》。</p>
<p>我的饭来了，醋加多了，但刚刚好。我想起小的时候觉得好玩，会故意多加很多醋。结果最后自己吃不了，就全给父亲吃了。不知道他这几年替我吃了多少醋，又不知道他这几年替我吃了多少苦。</p>
<p>我想起曾经自己不愿意来这里吃，连尝试都不愿意。后来有个阿姨带我来，推脱不过，尝试了一下，于是便成了常客。那个阿姨很讨厌，我不喜欢她，但想起她来总没多少厌恶的感情，不知道与这有没有关系。</p>
<p>以前和父母来的时候，母亲总会在第二碗的时候把鸡柳挑给我，在第三碗的时候把牛肉挑给我。所以我吃了几口，约莫到一碗了，就咬下鸡柳，约莫第二碗吃完了就挑出牛肉。但总是少了那种感觉，我吃的也很慢。到最后有些饱了，但还是接着吃，因为不知道下次什么时候来。我想起以前，我总会吃的很慢，最后父母都起身了，我还是要贪恋一口汤再走。于是想着喝一口汤就走，但又不想起身，坐在椅子上，把手里的文章看完。</p>
<p>回去的路上，车流多了起来，不知道为什么。</p>
<p>我发现小区门口的洗车的地方换了足球场，想起之前和父母来这里的情景，有点不知道说什么好。但随即发现只是换了个地方，不过生意看起来冷清了许多。很快我就找到了冷清的原因：前面有了一家新的汽车保养店。</p>
<p>那家包子铺还在开着，我已经记不清什么时候第一次来这里了。</p>
<p>许多新店开了，许多老店还在。</p>
<p>走进小区，我看到原本幼儿园前的几张木椅已经破损地不像样了，里面的钢丝漏了出来，原来竟是假的，可我小时从没怀疑过。幼儿园里空荡荡的，想来孩子们都在室内。往回走的时候听到后面的响声，以为是孩子们出来玩了，回头一看，还是没有人。有一条人工河，上面有一条刻成弯曲木头形状的桥。我想起来曾经经常在上面玩，熟悉每一道花纹。</p>
<p>人工河以前是有生机的，还有很多水。以前是有青蛙的，我记得我来这里抓过蝌蚪，可现在大部分都干涸了，露出了光秃的地面。仅剩的水在今天也结着冰。</p>
<p>曾经那边有一家面包店，我经常在那里买十块钱一袋的肉松面包当作零食。</p>
<p>曾经那边有一家菜店，我有时会替母亲去那里买菜。</p>
<p>曾经小区里是有桃树的，小时候摘过桃子，后来可能摘得人多了，桃树再也见不到了。</p>
<p>曾经小区里有条管道放着水，母亲经常去那里洗衣服，我就坐在她旁边看书。</p>
<p>我张开手，拿出攥着的硬币。我原本想将它抛到河里，但又改了主意。我记得我小时候捡到一元钱是很开心的，我可以买两袋零食吃，同学也会都来分着要。</p>
<p>所以，我望着前面结冰的河，把硬币放在拇指上。</p>
<p>希望以后，不必回望过去，不必妄想将来，只活在当下，做好自己。</p>
<p>希望以后，不必因为别人而惩罚自己，不必在意别人的评价，不必在意别人的性格。</p>
<p>希望以后，只为自己而活，不必将生命托付给谁，只为了所有的记忆与情感而活。</p>
<p>我抛出硬币。</p>
<p>我想起来月考后，我拿着橡皮和自己打赌。“三次正面就去”，我扔了两正一反。但又不甘心，于是又来：“五次正面就去”，这次倒是扔了五次正面，但我又不放心了，再扔一次，是反面。</p>
<p>所以我转身，我听见硬币落在地上，滚动着，然后停下。</p>
<p>去他妈的命运。</p>
<p>（写于2022.01.07）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>我多想说再见啊</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E6%88%91%E5%A4%9A%E6%83%B3%E8%AF%B4%E5%86%8D%E8%A7%81%E5%95%8A/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>试着掬一把星辰在手心</p>
<p>却遮住迷恋遥远的眼睛</p>
<p>窗外传来记忆的声音</p>
<p>在半夜迷失，在房间消失</p>
<p>去幻想着夜晚之前的一种逃离</p>
<p>——柯立可《我多想说再见啊》</p>
</blockquote>
<hr>
<blockquote>
<p>那时我突然开始想，为什么要这么拼呢？说到底，对北大的执念可能是一部分，另一部分，可能是一种复杂而扭曲的情绪。我一直抵触将自己标榜为一个过于注重功利的人，一直试图掩饰自己过强的好胜心，但我的内心是极其争强的。我见过的几乎所有的老师都有一种固有的观念，那就是成功者不聪明，失败者不努力。每次有什么讲座或者所谓优生交流之类的事情，都会有老师在上面说诸如谁谁谁并不如你们聪明，谁谁谁是我见过最聪明的学生此类话。我印象很深的是刚开学的时候竞赛生训话，说到我时说我是所有人中最聪明的，但可能会成为最后的“无冕之王”。当我真正取得成绩后，我又成为了所有人中最努力的，最“听老师话的”，其他人代替了我的位置成为了这个老师口中的“最聪明但存在问题”的学生。没人会喜欢平凡的人的故事，人们称赞成功者，惋惜失败者，并试图从他们身上找到一些经验教训，为此他们不惜强说因果，因为没人会选择去从那些玄而又玄的命运或者天赋中汲取经验。</p>
<p>而我听过了太多的反面教材，于是也害怕自己成为别人口中的反面教材。</p>
<p>所以也许我一直都在怕，一直怕别人对我的评价，怕别人说我如此聪明却又不努力，怕别人说我因为一时的恋爱而影响了一辈子，怕别人说我钻研难题而导致基础知识失误。尤其是那些我在意的人。</p>
<p>——《离弦》（写于2023.08.13）</p>
<p>我们上个周的作文题是要对这样一句话引出议论：“人生的路程就是这样，用大把的时间迷茫，在几个瞬间成长。”</p>
<p>我写作文的时候对这句话嗤之以鼻，我认为你“迷茫”的时候，也同时是你“成长”的时候。而最终完美的“成长”是不存在的，从生下来的第一天，到死亡的前一天，哪一个瞬间不是在成长呢？</p>
<p>话是这么说，我怕是以前心中却不是这么想的。我经常喊“自己与过去切割了”。逐渐地，我切割的时间点离我越来越近，昨天做的事，道歉之后，今天就切割。我现在觉得，也许这样对也不对，切割意味着你从过去学到了什么而成长了，但切割也意味着你无法接受自己的过去。但过去的事情总在过去，未来的事情总在到来。</p>
<p>我想明天的我大概也与今天的我不一样。</p>
<p>我希望每天的我都在向着那个心目中理想的人前进。</p>
<p>——《枷》（写于2023.09.21）</p>
</blockquote>
<hr>
<p>大学报到也有一段时间了，在校园里待的这几天竟然无比适应，既没有在高中的那种被支配全部生活的禁锢，也没有假期在家里那种一天天无所事事的颓废。总之我愿意说——我希望过几个月、过几年后的我看到这句话不要哑然失笑——我现在真的开始向往着无限可能的未来。</p>
<p>关于我高中的回忆录是我一直想写却写不出的东西。我甚至想过要不要采取另一种荒诞的写法，于是拉来了一大堆人陪我攥写《烟台二中俗世奇人》。当然这个企划最后以一篇稿子都没结稿的蛇头蛇尾的成绩收场了。但我总之真的想写点东西，回忆回忆过去、嘲笑嘲笑校领导、称赞称赞老师、分享分享自己的经验（如果有的话）、以及写写她。</p>
<p>在我写到这段话的前不久我刚刚和高中的几个关系还好的朋友一起出去玩了一趟，当时我们在奶茶店等着奶茶，等着等着我突然说了一句：“欸原来我高考完都一个月多了。”其实你现在要让我回忆高三的生活，我几乎都无法理解当时的自己。为什么我如此脆弱又如此顽强，为什么我真的做到了这一切呢？</p>
<p>但即使从最功利的角度来讲，高三让我上到了理想的大学，让我认识了一些关系很好的朋友，甚至说它还让我有了足够的悲叹的苦难作为创作的源泉。我初中的时候很喜欢一句话，后来我才知道这句话出自陀思妥耶夫斯基，这句话是这么说的：“我担心的事情只有一件：就是我配不上自己经历过的苦难。”直到如今我仍然对这句话感触颇深。我不愿意歌颂苦难本身，但我愿意花大篇幅歌颂经历着苦难的人。我高一的时候有一段失败的恋爱经历，但我后来甚至逐渐对此产生了感激之情——我在经历过那样的痛苦后，竟然反而能因此而读懂不少曾经看不懂的诗歌。</p>
<p>所以我其实还是想要动笔。当然这篇写出来估计要写不少私密性的故事，也要写不少攻击力极强的故事（笑），希望我别被突然询问其中不愿意提起的私密细节，也别被一个电话打过来强制我删稿。</p>
<p><strong>注意：本篇虽然以第一人称写成，但完全是虚构小说，发生背景在一座叫做“亚特尔泽”的学校，和现实无关。如有雷同，纯属巧合！！！！！</strong></p>
<p><strong>注意：本篇虽然以第一人称写成，但完全是虚构小说，发生背景在一座叫做“亚特尔泽”的学校，和现实无关。如有雷同，纯属巧合！！！！！</strong></p>
<p><strong>注意：本篇虽然以第一人称写成，但完全是虚构小说，发生背景在一座叫做“亚特尔泽”的学校，和现实无关。如有雷同，纯属巧合！！！！！</strong></p>
<hr>
<p>我觉得我高三可能被分成了差不多两个部分，分界线大概是《逃》创作的时间左右。第一个部分的主要矛盾是我与腐朽的规章制度之间的冲突，第二个部分的主要矛盾则是我日益增长的美好生活需要和我个人极端性格之间的矛盾。</p>
<p>当然，即使这么说，我对亚特尔泽也仍然是有感情的。这份感情主要来自于我的老师们，我对我高中遇到的教过我的每一个老师都给予极高的评价，我认为他们无论是从师德还是从能力来讲都无比顶尖。其中有一些老师我更是几乎视为人生导师一样的人物。比如高考前几天我情绪崩溃的时候，我的生物、化学、英语、数学老师轮番上阵给我做心理辅导，甚至隔壁班的班主任也来找我聊天，而且这种聊天甚至都没太有身份，我完全在把老师当成哥们在那里聊天。我这么说你可能没太理解我在说啥，我就这么说吧，我们聊天的内容大概分为以下几个部分：首先我发泄一顿高考前的压力；然后老师半开玩笑吐槽我已经很牛逼了就别在这凡尔赛了；然后开始给我讲他们过去教过的很多学生，有一些是很成功很成功的，也有一些是高考没那么成功，但最后总是在发光发热的学生；再之后开始数我比较好的地方，顺便说几个我不好的地方（比如我性格很极端）；然后开始闲聊，我开始问他们上了大学怎么找女朋友，不同老师给出了不同的建议，比如化学老师建议我大一适应一年大二找学妹、英语老师给我讲了点追女生的技巧、隔壁班班主任直接说我高考后看上哪个了她去给我说媒、生物老师更是直接跟我约定高考后给我找个女朋友；最后甚至还会扯一点家常话题。</p>
<p>还有一些很感人的小细节，比如说年级主任经常和我聊很多话题聊到很晚，我的班主任高考前送了我一个刻着“一举夺魁”的木质手链，我的化学老师几乎每场都出现在红毯边上和我击掌，生物老师高考后还经常和我聊家常（内含不少感情问题）。总之我在亚特尔泽这里体会到了相当多的<strong>来自一线教师</strong>的人文关怀。</p>
<p>不过我当然要在这篇文章里大肆夸赞学校的规章制度，如果不写这段我估计可能很多人也懒得看我碎碎念。我前段时间发了个动态是这么说的：</p>
<blockquote>
<p>亚特尔泽学生应该报考猪大的五个理由：</p>
<ol>
<li>食堂的蛋挞是温的</li>
<li>洗手间有无限量的洗手液</li>
<li>椅子上可以随便放东西，地上也可以</li>
<li>有什么东西坏了最多第二天就会有人来修</li>
<li>椅子是完整的</li>
</ol>
</blockquote>
<p>我觉得可能有的校领导看到这段话估计要破防，但我对自己的幽默感自鸣得意。亚特尔泽有很多传奇性的故事，<del>比如我至今为止都没见到第二个中学出现老师和学生联合起来的奇观</del>，其中甚至包含了大量不能碰的滑梯，不过即使是我日常中碰到的小细节也足够让我在这里狠狠发泄一波了。</p>
<p>比如几乎已经成为我知名脱口秀包袱的若干条规章制度，例如椅子上不让放衣服，椅子上不让放书包（地上也不让），水杯不让带到教室里（要在教室外面排排站摆成一排），原则上不推荐学生背双肩包（升旗时多次强调），听说还尝试推行过桌子上不让放笔袋（传言，不知真假，如果是假的我立刻删除并发表《我的忏悔》）。至于什么垃圾桶里不让有垃圾，这个我们倒是没有，因为我们不搞那些形式主义的东西，我们的宿舍和教室里压根没垃圾桶（乐）。至于宿舍里的被子是摆设，这个纯属尬黑，它放在那上面还会占大家睡觉的地方呢，根本就不是摆设。退一步讲，亚特尔泽也曾经试图消灭学生中的形式主义，比如强制要求“叠被神器”无法加分。但后来发现收效甚微，所以又改回来了。</p>
<p>至于亚特尔泽最为人津津乐道的，当然是其认为对学生提高成绩极其重要的三板斧：培优、讲座和班会。</p>
<p>其实关于这个培优我想吐槽的也挺多。但防止有人说我成绩好就高高在上，所以我还是不说话比较安全。</p>
<p>至于这个讲座可以说的就很多了。首先要声明啊，这个讲座办了十几场，肯定是有特别好的讲座的。比如曾经请过一位王老师来给大家讲语文讲座，这也是我唯一一场一点都没摸鱼，甚至有点想哭地听完了整场讲座。讲座拖了一会导致晚放学了，外面甚至还下着大雨。但大家几乎没有人抱怨，甚至连平时最推崇应试教育的那几位优等学生也没有吐槽过一句。反而正是因为外面有雨声，使得里面的讲座格外动人。</p>
<p>写到这我又按捺不住想多写写和这个讲座有关的事。理论上来说，这个讲座应该给我们讲如何写作文，但其实他真正在讲的远远不止作文。</p>
<p>王老师来了后首先给大家讲了一个故事，说他曾经有个文笔特别好的学生（发表了好像是十几篇文章？我记不清数字了），有一次拿了篇作文过来给他看，他一看怎么才$41 $分。仔细一看，认为是这位学生没有开门见山亮明观点，导致阅卷老师错误评估。然后他就劝这位学生说，人在屋檐下不得不低头，低头过去了，后面大片的广阔天地等着你去发展呢。他说这位学生当时用一种近乎悲悯的表情看着他，说王老师你不懂，我是有自己风格的人。</p>
<p>这个故事对我感触颇深，它和我的生物老师LL老师后来某次对我的劝导一起成为了我高中总结的最大的人生经验之一——如果你认为一个事情从任何角度来说都完全不合理，但你又完全没有办法反抗它，你不妨将它视作你人生中逃无可逃也没有原因的一次苦难。我后来某一次给学弟作报告也是这么说的：高三只有一年，再阴暗再苦难也只有一年，撑下来、熬过去。</p>
<p>王老师还讲了些别的，有一些很符合我的文学观点，比如说努力去写一些干净的句子（我忘了他举的那个例子是啥了，可能是这句：“在那个下着雪的冬天，李老师来到了我们的班上。”），还有去写一些冲击力很强的句子（他举了个例子是他让他们班学生写《祝福》读后感的时候，其他同学的第一段全是什么“鲁迅先生生平概括，《祝福》创作背景”，只有一个同学第一段只写了一句话：“太不公平了！”）；还有一些对我产生了很深的影响，比如说他建议少与人交流自己的作品（他举了个例子是如果让你想象一个场景：“最后一堂音乐课，当老师宣布下课的时候，同学们突然起立鼓掌，然后一起合唱了一首歌。”如果不与别人交流，只是在脑中想象，那每个人想象的场景的刻画，班级座位的排布，甚至有几个同学的面孔，以及唱的那首歌到底是什么都是不同的。但如果真交流起来就会趋于同质化）。</p>
<p>还有一些他自己的人生哲学。比如有一句印象特别深的话是：“当你们过个几十年再回忆起自己的高中，也许还包括王老师给你们的这个讲座，可能会有很多不一样的体会。比如你后来带着孙子走在街上，突然发现一个看上去很普通的老太太是你的高中同学。你可能会跟你的孙子这么说：‘看到那个老太太了么，她以前写的诗都美死人呢。’”当然原句我已经记不清了，这个句子是我背在这里的，我毫不怀疑自己的背诵误差导致这句话失去了太多原有的感人的遣词，但原句真的让我当时悚然一颤。</p>
<p>我至今仍然对这位老师，或者说这位长者心怀敬意。</p>
<p>好像说着说着跑题了，那么其它的讲座是不是像这场一样这么好呢？</p>
<p>当然不是，比如请了衡水中学的老师来讲了两次，我印象特别深的是其中一位老师把一位同学当成正面典型来给大家介绍，说这位同学有两个理论：一个叫做光宗耀祖理论，简单来说就是他认为自己的姓氏非常稀少，认为自己应该扛起家族振兴的使命；另一个我忘了叫啥了，好像叫做分流理论么，简单来说就是这位同学觉得自己从小到大跨越了许多阶层，小时候很多玩伴已经远远到达不了自己的等级了，以后他也要尽力地去冲向最高等级，而不是被分流。</p>
<p>我当时立即对这俩理论嗤之以鼻，并且难得地写了一篇议论文发在空间里对这位同学这位老师这个学校大肆批判。我觉得这完全就是社达主义下放到高中教育阶段的活生生的例子。我也给这俩理论起了俩别的名字，一个叫做“过度繁殖理论”，另一个叫作“自然选择理论”。</p>
<p>还请了个xx师范大学的教授来作了个讲座，这个讲座连我们班主任也绷不住了，回来跟我们大喷这个教授就是个骗子。这个教授也有很多抽象的言论，比如认为“高考范文”全是垃圾，这个我小部分认同；还有认为高中语文老师绝绝大部分都是垃圾，这个我当时真没绷住。</p>
<p>其他的基本就是浪费时间的讲座了，连让我喷的资格都没有。</p>
<p>值得一提的是后来还发明了学生讲座，简单来说就是每天晚三找个学生去年级广播给大家灌鸡汤，后来有个牛逼老哥在灌鸡汤的时候脏话频出，遂取消。</p>
<p>至于这个班会，由于我几乎班会全程都在摸鱼，倒是没什么可说的。</p>
<p>当然啊，虽然我们这是一篇架空世界虚构文章，但是卡夫卡曾经说过：“越是虚构的故事，细节处越要真实。”所以我们也可以提很多真实的小细节，用来揭露不能碰的滑梯的一角。</p>
<p>比如当我高考完回校的时候，遇到门口有两个穿得人模狗样的校领导（估计也不是什么很大的官，因为我甚至没见过）在背着手巡视，突然经过了一个遗落在地上的篮球，校领导当时就在这个篮球不到三步远的距离，然后他伸手招呼来了几十米开外的保安，让他来把这个篮球捡起来了。</p>
<p>还有高三的时候突然宣称要“开源节流”然后不让老师给同学印答案了，引起了所有人的一致质疑，后来好像是取消了。</p>
<p>至于什么校领导来听课结果听课本上写了几段字就开始玩手机（甚至在教室外面高分贝打电话）、高考前两个周高三厕所水龙头坏了一直拖到高考都没修、任课老师在课上吐槽校领导不会教书瞎指挥这些事情更是老生常谈，蓝的盆。</p>
<hr>
<p>我们亚特尔泽还有一对“双子星”，俩人为亚特尔泽的风评一起做出了突出贡献。</p>
<p>一位老师，我们不妨称其为花沫兮老师，被我们称作压在学生身上的三座大山（其实不止三座）之一。这位老师以一名一线教师的身份（甚至都没教过我），跻身进我专门为校领导著书立专的故事中，可见他的传奇性。首先我不得不在这里高度赞扬花老师的教学水平，不仅在课上错误频出，还经常自信地认为自己的方法比学生的方法简单。当然作为一名老师来说，这点小事根本瑕不掩瑜。花老师是一位坚定的进步主义者、禁步主义者、紧捕主义者。比如原本我们学校的早读时间仅仅是$6 : 25 $，这个时间不仅一点都不吉利，更是体现不出我们学校制度的优越性和进步性。王安石曾经说过：“度义而后动，是而不见可悔故也。”于是花老师秉持着“苦一苦学生，骂名班主任来背”的想法，敢冒天下之大不韪，毅然决然将早读时间提前到了$6 : 20 $。这一举动立即得到了领导的赏识，从而引起了对其他保守而不愿改革的班主任的思想教育，并且逼迫他们去对学生进行同样的思想教育。这一举动自然引起了部分不理解领导苦心的学生们的无耻辱骂，人们不感谢花老师，花老师如同一位悲剧英雄一般百遭辱骂，令人不禁潸然泪下。但花老师以为，“至于怨诽之多，则固前知其如此也。人习于苟且非一日。”因此，人们的反对没有阻碍其进步的脚步，其更是进一步将他自己的班级的早读时间提前到了$6 : 18 $。而且还觉得不够进步，将早饭时间从$30 $分钟缩短到了$23 $分钟，将午饭晚饭时间从$30 $分钟缩短到了$25 $分钟。说到这里连我都感动地热泪涟涟，这些正确无比的决定甚至只能在他自己的班级实行，而不被广大的群众所接受，如此正确的政策竟然被同学们自己拒绝了。在我心中，花老师的形象更是如同乾隆帝一般伟大。甚至于花老师的班级在级部中也享有盛誉，当其他班级的同学看到他们班的学生来回奔波在教学楼和食堂之间、挥洒着青春的气息的时候，无不鼓掌脱帽致敬。</p>
<p>花老师对他的学生们更是展现了父亲一样的关爱，包括但不限于：翻学生书包以文明其精神、在临冬（还没下雪）的时候要求大课间出去溜达的同学在门外站着（最后自然是感冒了）以野蛮其体魄。</p>
<p>另一位老师，我们不妨称其为舒昂建莎老师。舒老师几乎可以称得上是亚特尔泽的标志性人物，之前我们提到的若干条规章制度几乎全是他一手操办的，可谓亚特尔泽真正的九千岁。我在这里引用一个故事来给大家展现舒老师的传奇性：</p>
<blockquote>
<p>在亚特兰大地区大会上，领导强调：有的同学在双肩包里放课外书，老师们应该加强管理。<br>亚特原泽的同学们懵了，他们不知道什么是课外书。<br>亚特撒泽的同学们懵了，他们不知道什么是老师。<br>亚特尔泽的同学们懵了，他们不知道什么是双肩包。</p>
</blockquote>
<p>舒老师的身影无处不在，作为亚特尔泽的九千岁，他如同一个幽灵一般徘徊在学生身旁。他和花老师如同亚特尔泽的萧何和韩信一般，为亚特尔泽的长足发展做出了卓越的贡献。</p>
<hr>
<p>然后可能无法避免要谈到的一个事是“献给蔷薇系列”的创作。</p>
<p><del>不过笔者写到这里已经很晚了，中午发烧了而且明天要早起，所以先中断一下，有时间再补。</del></p>
<p>“蔷薇系列”的创作背景正是上面以一种很欢乐的方式讲的传奇故事。我现在讲起来很乐，大家听起来也很乐，但在当时对我来说实在是乐不起来。我首先就无法理解这些逼规则，对大家的学习助力完全是负的（虽然其实从各种角度来说都促进了班级同学的团结，甚至是同学和老师的团结），所以从开学我就跳反了，装上诸葛连弩，给所有校领导套上铁索连环就开始扔酒火杀。结果自然是被约谈了无数次。这个时候我才明白了这些规则得以推行的背后原理：如果你遵守这些规则对你的学习帮助可能是负一，你不遵守这些规则可能对你的学习帮助可能是正一，这样学生们自然不会遵守规则，校领导怎么能满意呢！所以他们就有了一个天才般的想法，那就是只要你不遵守规则，就通过不断约谈的方式给你施加一个负十的惩罚值，这样遵守规则就是最优解了。我们班的想法更天才，那就是分小组后采用量化连坐制度，彻底堵死有些人决心反抗到底的最后意愿。</p>
<p>还有一个背景是，我也许始终没有从高一的失败感情经历中走出来。这导致我几乎无法和其他同学正常交流，努力将自己封闭起来。我在这个过程中的思考后来写成了《白鸟》这篇小说。</p>
<p>在这几个背景下，小说《谶》就此诞生。</p>
<blockquote>
<p>那仅仅一句话就彻底改变了我所有的生活习惯，将我生命中所有的亮色夺走。我想要反抗这一切，反抗这个世界强加给我的一切，反抗这生命，以及这生命强加给我的一切。我被无缘无故抛到了这个世界上，从生下来就被迫被社会所塑形。他们先是给我讲这个或那个圣人，然后讲这个或那个圣徒，最后讲这个或那个死刑犯，以此击破我妄图在世界中保持自我的私心。他们逼迫我沦落为常人，逼迫我脱离自己的存在，逼迫我混入世界之中被他们物化，原因只是因为他们认为这样做是对的，先前所有人都是这样做的。他们不会在意你的做法有没有道理，再正确的做法也可以挑出二十个缺点。他们忽略你自身的独特，用一个个更加偶然的例子来激励你，然后对那些不符合他们思考的例子则视之为“幸运”的特例，然后置之不理。</p>
<p>——《谶》（写于2023.11.13）</p>
</blockquote>
<p>虽然小说中的主角从此破除了枷锁，但现实中的人没有。我在写完小说后虽然一直以小说主角为偶像，但其实到最终也没做到那样。原因很简单：我只是一个人。</p>
<p>的确，几乎所有的学生都痛恨这样的制度，但我怎么能像小说中的“言”一样找到那个属于她的“贺”呢？我完全没有任何援助，只能眼睁睁看着自己原定的计划被一次又一次约谈打破。</p>
<p>那段时间晚上回家之后基本就是躺在床上躺尸，因为我太累了、太累了，我那段时间经常躺在床上，一边痛恨自己的颓废一边又没有意志力能支撑我爬起来完成自己的目标，脑子里经常回绕的是海子的那句诗“面对大河我无限惭愧，我年华虚度，空有一身疲惫。”但同时我又深深沉溺于这种痛苦所带来的副作用，我在反抗中感受到了自己在朝着自己的理想的模样前进并为此深深自豪。这种生活提供了《逃》《眼》《刺杀》的背景。</p>
<blockquote>
<p>我喜欢幻想自己的未来，也喜欢回忆自己的过去。</p>
<p>我当然这样是不对的，我在逃避现实，可我能怎么样呢？</p>
<p>我那天嘲笑自己，觉得自己幻想过的未来好像一个都未曾来过。所有的重要的事都在意料之外。</p>
<p>我还嘲笑自己，自己回忆过的过去，幸福的美好的记忆我回不去，痛苦的悲惨的记忆我改不了。</p>
<p>我有的时候觉得自己的未来一片光明，阳光太过迷幻。</p>
<p>可有的时候又觉得毫无希望，不如死了算了。</p>
<p>我很羡慕高一的我，意气风发，自命不凡，觉得只要自己足够努力，只要自己的感情足够真挚，自己什么都可以做到。觉得自己一定在走向幸福。</p>
<p>现在的我却是瞻前顾后，考虑一切现实的因素。</p>
<p>——《你有想去的地方吗》（写于2024.06.01）</p>
</blockquote>
<p>我真正没有想到的是，在这种情况下，竟然会出现一个女孩。</p>
<p>我后来想到这个事的时候有的时候都觉得是神迹，像是老天爷为了救我而降下的神恩。但这么说其实非常高高在上，搞得自己像是天命之选，并且模糊了她自己的独立人格，很不公平。</p>
<p>具体细节我还是不讲了吧，你可以想象在这种情况下的我，甚至已经打算几乎断绝自己和别人的社交的时候，突然遇到一个很温柔主动帮助我的女生，这对我来说还是一个挺大的奇迹的（笑）。当我在一个如此阴暗潮湿的环境下，甚至班里同学大概只能认识三分之一，能和个位数同学聊上天的前提下，突然有了这么一个人。即使我一开始没有动容，后来每次跑操或者什么别的活动看到她了，一想，哦，她是那个对我很温柔的女生；当自己哪天非常绝望的时候，一想（虽然感觉是郭楠幻想）也许还有一个人愿意对我好，这种日积月累的情感是很恐怖的。</p>
<p>最终我干了一件很不理性的事，我为她写了一篇小说《逃》。</p>
<blockquote>
<p>可能很多人都觉得我执念太深，其实我自己也是这么认为的。在经历过种种后，这执念本身甚至加上了许多理性的束缚。我觉得自己一直都是一个追求幸福的人，哪种选择可能走向幸福，我就去走哪条路。但真正选到死路之后，我才发现原来世界没有那么简单，不是真的，只要有理想和爱，就什么都可以做到。</p>
<p>起码，我改变不了别人。我做不到让一个不爱我的人爱我，做不到让不理解我的人理解我，做不到改变顽固不灵的人的想法——或者我自己也是一个顽固不灵的人。我也不可能，不可能像所有童话故事一样，等到救赎自己的精灵，等到一股强大的外力将我现在的所有囚笼击破，等到一位天使将我救赎。</p>
<p>……</p>
<p>我有的时候自嘲，说自己每次想要改变的时候，可悲的事情就会一件接着一件纷至沓来，仿佛是命运逼迫我成为行尸走肉一样。</p>
<p>好像总有人在充当命运的刽子手，一刀一刀将我活剐成一具骷髅。</p>
<p>我有的时候甚至以为，救赎是一个标志，是命运终于允许我拥抱幸福的标志。只有有了这种允许，我才能抬起头来生活，将自己从无尽的悲哀中拽起来，看看太阳。</p>
<p>这个标志是什么呢？也许是一次巨大的成功，是时来运转的惊喜，是一个爱着你的人，无微不至体贴你的所有。</p>
<p>但后来我明白了，原来救赎其实是，你坠到沼泽中，全身都被脏泥淹没的时候，好像听见有人在叫你。你突然睁开眼睛，看了看太阳。</p>
<p>原来太阳是那么耀眼，原来周围的叶子也可以反射太阳的光，原来空气中的尘埃都在光影中浮动着，绽开着。</p>
<p>你想看看是谁在喊你，可你无法动弹。</p>
<p>你拼了命向上爬，即使口鼻中全是污泥和脏血，即使四肢被厚重的泥土压到畸形。原来还有人在叫你，原来还有人爱着你，原来这个世界如此美丽。</p>
<p>你用尽自己全部的力气，像是生出了额外的羽翼，你从此不甘心被活埋，被忘记，被裹挟在地下沉睡成百上千年后化成黑水。</p>
<p>你向上爬去，终于会爬出沼泽，会带着一身的伤痕站在地上，四处望着是谁在呼唤你。</p>
<p>至于到底有没有人，至于你愿不愿意相信刚才这里存在过一个人，至于你愿意相信她是谁，这完全取决于你。</p>
<p>——《逃：后记》（写于2024.04.30）</p>
</blockquote>
<p>等我写完《逃》第二天看到她的时候，我突然感到一阵悸动。我在想，她知不知道我为她写了一篇小说呢。</p>
<p>我想我大概是喜欢上她了吧。</p>
<p>这是很致命的。就如我上面所说，我一直都可以意识到自己是一个性格很极端的人，她没有任何可能喜欢上我这样的人。我当然清楚她表现出来的友善大概只是礼貌，但我深陷其中，完全如同将要溺死的人试图抓住稻草。</p>
<p>我明白这感情没有结果、甚至还会影响高考，但又深深陷在这个光影飘散的水晶迷宫中走不出来。我真的从未有过如此狼狈。</p>
<p>但也正是这种情况下，她那天突然开了个玩笑。</p>
<p>现在看可能觉得那句话只是玩笑，但我当时真的将其视作灯塔的曙光。我终于可以有一条救赎的道路，终于有人指出了一道宽阔的大门。</p>
<p>我终于将要得救了。</p>
<blockquote>
<p>终于我闭上了眼流出了泪放下了手，我站起身迎着窗外。她的面容浮现了出来，朝我轻轻地笑。</p>
<p>她真的好美。</p>
<p>我睁开了眼。玻璃上仍然是我的倒影。</p>
<p>我真的很丑。</p>
<p>可这个世界真的好美。</p>
<p>——《眼》（写于2024.06.10）</p>
</blockquote>
<p>但后来证实了，这一切真的只是我的幻想。</p>
<p>所以就有了《青蛙王子》和《刺杀》这两篇小说。</p>
<blockquote>
<p>他以为自己是受了诅咒的王子，但在她眼中它只是只戴着金冠的青蛙。</p>
<p>——《青蛙王子》（写于2024.06.17）</p>
<p>等人们发现你的时候，你扑在蔷薇花丛里。人们把你救出来，你的全身被二十三朵蔷薇花刺穿，其中一朵刺穿了心脏。</p>
<p>——《刺杀》（写于2024.06.21）</p>
</blockquote>
<p>我后悔吗？</p>
<p>我一直都笃信一个事，那就是人不应当压抑自己的情绪。我一直很不喜欢别人劝我、甚至是要求我去乐观开朗向上，我觉得一个人的情感是属于自己的，我应该在我想哭的时候哭，想笑的时候笑。</p>
<blockquote>
<p>也狂欢着 也狂笑着 青春是官能的王国</p>
<p>也淋漓着 也耽溺着 血液中蒸沸快乐</p>
<p>——Kevinz《猜火车》</p>
</blockquote>
<p>我当然不后悔。</p>
<p>这段略显幼稚肉麻而且夹带郭楠幻想的故事可能放在这里会被很多人吐槽吧（笑），甚至有可能当作梗广泛流传，以后也许有许多人都一边玩着梗一边魔改着其中的某一句话一边嘲笑我的失败，也许我过不久就会把这段话从这篇文章里删掉。</p>
<p>但我真的不后悔。即使我们以后的人生大概再无交集。</p>
<hr>
<p>也许过几年我会忘记很多事，但高考前那个夜晚，我突然回忆起了我高三的故事，我想起了过去的痛苦，我也畅享着未来的美好，我终于鼓起了全部勇气冲向了现在。因为我真的有想去的地方，因为我真的有想见到的人。</p>
<p>高考前感冒还有点低烧，但是我反而一点都不害怕了。</p>
<blockquote>
<p>确实，有时最离奇古怪的念头，看来根本难以置信的想法一旦牢牢地占据了你的脑海，最终，你就会认为这种想法是可以实现的⋯⋯此外，如果这种想法与强烈的、疯狂的愿望结合在一起，那么，有的时候，你最终会把这种想法看作是命中注定、无可避免的事情，认为它是不可能不存在、不可能不发生的了！也许，这里还包含着别的什么，包含着许多预感、非凡的意志力，对自己想入非非的沉迷或者别的东西——我不知道。但是，这天晚上（这个夜晚我终生不会忘记）在我身上产生了奇迹。虽然这个奇迹可以用算术知识加以诠释，但是，对我而言，它至今仍然是一个奇迹。当时，为什么这种自信会深深地、牢牢地印在我的心中，而且早就如此？究竟是什么原因？确实，我再重复一遍，我没有把它看作那种可能发生、因而也可能不会发生的偶然，我认定它是那种无论如何都不可能不发生的必然！</p>
<p>——陀思妥耶夫斯基《赌徒》</p>
</blockquote>
<p>高三的时候把<a href="https://music.163.com/song?id=2058806421&amp;uct2=U2FsdGVkX1/Cbeq60Q5irnrpFBmGevhxb3gkBGECxVw=">《猜火车》</a>听了好多好多遍。直到现在我的qq签名还是里面的那句“而唇瓣风干锈死之际，谁先一步释怀。”</p>
<p>我当然不知道未来会发生什么，我现在也仍然是坐在轨道旁猜火车的少年。</p>
<p>但我仍然想要记录过去。如果过去的故事不够圆满、充满遗憾，那我希望起码以此文来为过去画上一个圆圆的句号。</p>
<blockquote>
<p>……</p>
<p>欲念和浓烈狂热 身体内一并痉挛厮磨</p>
<p>血管过电生枝杈 镶嵌在皮肤和骨骼</p>
<p>世界不关己事 我只需选择全都不选择</p>
<p>啡肽与荒草里 猜远处不停脚的列车</p>
<p>爱是反叛 是瘟疫 是革命 是疯魔成活</p>
<p>每名少年都周身赤裸 借由本能作则</p>
<p>洁持中跌堕 潮林里纵火</p>
<p>阳光越迷幻 你越深熔化进我</p>
<p>……</p>
<p>最坏也最好的年代 未来即是永不到来</p>
<p>开一窗逼仄屋室 蓦然涌起滂沱火海</p>
<p>我们在迷离眼光中 反复读懂每个现在</p>
<p>而唇瓣风干锈死之际 谁先一步释怀</p>
<p>生命是违逆 是服从 是有预谋的意外</p>
<p>每名少年都试图 一边告别 一边告白</p>
<p>洞察与窥猜 胡乱生青苔</p>
<p>阳光太迷幻 以至我脚步加快</p>
<p>……</p>
<p>我们终将归于沉寂 令一切都失去意义</p>
<p>反叛着反叛 接受没道理的 不无道理</p>
<p>于是这世界突然美好 突然通透而瑰丽</p>
<p>甚至令人忘记开篇 何其宏伟的命题</p>
<p>——Kevinz《猜火车》</p>
</blockquote>
<p>（写于2024.08.26）</p>
<p>（谨以此文纪念我的高三生涯）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>壬寅年末</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E5%A3%AC%E5%AF%85%E5%B9%B4%E6%9C%AB/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#后记">后记</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>单翅鸟为什么要飞呢</p>
<p>（海子《单翅鸟》）</p>
</blockquote>
<p>谢谢你点开这篇文章。你会是谁呢？也许是恩重如山的老师，也许是相识相知了多年的挚友，也许只是点头之交、萍水相逢。</p>
<p>我不清楚你的身份，也不知道是什么时候你点开了这篇文章。也许是烟花璀璨的夜晚，也许是繁华散尽后的第二天清晨。我不是造物主，我毕竟无法预测到一切。</p>
<p>好吧，我知道在很多人眼里，我在一夜间性情大变。我知道在很多人眼里，包括很多正在读文章的人眼里，我突然变得不可接近、不可理喻。我在一夜间退出了所有的小群，删掉了一批又一批的好友。即使是现在在看文章的你们——我所信任的挚友或是所认同的善良的人，我相信我也可能曾以某种举动伤害过你们。我很抱歉。所以我想，在这一时刻，无论你是谁，我们两个像朋友一样好好聊一聊。我知道似乎没有什么好说的，我也知道人类的悲欢并不相通，我更知道一切的一切都不是我自我孤立，将自己闭塞起来的借口。我不奢求原谅，不奢求理解，不奢求别人将我捧得多么高——就像他们曾经做的那样。我只是想给过去的一年一个交代，写下一个并不完美的句号。人生太长太长了，我不知道等我百年之后再看这一年，我会如何评价它。我无法预料这一年对我的人生会有什么影响，更不知道命运会如何安排，不知道道路通向何方。但我想记住这一年，记住我的变化、我的心情，记住我所经历过的一切。我也想给我的朋友们一个答复，一个道歉。</p>
<blockquote>
<p>生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p>
<p>（马尔克斯《百年孤独》）</p>
</blockquote>
<p>有人对我说，我太爱憎分明了，因此活得很累；有人对我说，我道德感太强了，所以容易幻灭；有人说我过于桀骜不驯了，不懂得收敛自己；还有人说，我太刚了，易折。我不知道谁口中的我是真正的我，也许都是，也许都不是。每个人都以自己的方式理解对方，每个人都不一定能理解对方。我看不透，我也不想用别人的评价来概括我这个人，概括我的这一年。我的朋友，我更想，给你讲讲我这一年的故事和感受。</p>
<blockquote>
<p>人只是他企图成为的那样，他只是在实现自己意图上方才存在，所以他除掉自己的行动总和外，什么都不是；除掉他的生命外，什么都不是。</p>
<p>（萨特《存在主义是一种人道主义》）</p>
</blockquote>
<p>我要从何讲起呢？我想起来写前几篇文章的时候，都会放《猜火车》这首歌，而我已经好久没听过它了：猜火车的少年已经长大了，他知道该何去何从了，知道前路该如何走了。他要做的只是去努力赚得那一张火车票，去搭上那一班他清楚目的地的火车。</p>
<p>不过，除开《猜火车》，也许有别的歌，更适合描绘这一年的图景。</p>
<blockquote>
<p>我会永远记得年迈的他拍拍我额头</p>
<p>说：</p>
<p>“别难过，人生路很长，总有人要先走”</p>
<p>（瞳荧《我从人间走过》）</p>
</blockquote>
<p>愿逝者安息，如果有来生……</p>
<p>一定会有来生。</p>
<blockquote>
<p>他问为什么你看起来比我还悲伤</p>
<p>这种人生已经算不错的模样</p>
<p>承认普通接受平庸然后随波流淌</p>
<p>成为别人故事中的稀疏平常</p>
<p>（瞳荧《张小北》）</p>
</blockquote>
<p>一开始，我将自己的qq ID改成了张小北的想法是：我要提醒自己，自己并非什么天生英才，并非天选之子，我只是一个普通人，我应该努力做好普通人应做的事，应该努力让自己不普通，成为所谓“了不起的人”。</p>
<p>但后来，当我见的太多了之后，我才发现，我怎么敢将自己标榜为普通人。</p>
<blockquote>
<p>我以为自己是个普通人，直到遇到了真正的普通人，才发现我拥有的已经是他遥不可及的幸福。（《张小北》评论区）</p>
</blockquote>
<p>我所经历过的我以为是锥心刺骨的生离死别，难道不是大多数人，大多数普通人都要经历的吗？我如何敢标榜自己生不如死的痛苦，我如何敢称自己平庸无比？我如何敢用平庸掩盖自己的失败？我如何敢说自己已经努力到极致？我曾以为我足够努力，这一切都是我应得的。但其实这一切只是我足够幸运不是吗？若我比其他人更聪明，比其他人理解得更快，那这本是上天的安排，是造物主的赠礼，我如何敢将这功劳全然安到自己身上呢？</p>
<p>从那之后，我或许才真正确立了人生理想：我已经经历了苦痛，我要帮助那些苦痛中的人幸福，我要帮助他们远离痛苦；我已经足够幸运，我要帮助那些不幸的人，帮助他们过上幸福的生活。</p>
<p>但我如何确认，我这种感情不是居高临下的怜悯？我如何确认这是真正的善良而不是所谓的责任心？我如何确认我不是将自己摆在了救世主的高位，并且傲慢地认为自己有资格当救世主？我如何确认呢？</p>
<p>我不知道。</p>
<p>我连我自己都看不透。</p>
<p>有人说伪君子虚伪了一辈子，那就是真的君子。</p>
<p>可明明虚伪到连自己都被欺骗，才是最大的悲哀。</p>
<p>我不知道这一切是不是我在自我欺骗，我不知道我自我封闭究竟是为了保护他人还是为了保护自己，或者更有可能只是纯粹的偏见。我不明白。我看不透。</p>
<p>我不知道我会不会找到答案，无所谓。我只希望，我能永远保持对苦难中的人的同情心和同理心，以及尊重，足够的尊重。我希望我能永远认为自己是张小北，也永远将别人认作张小北。我希望自己将每一个人视作历经苦痛仍热爱生活的人，即使我对他们有偏见，也应该想到他们所曾历经的苦痛。我应该尊重每一个人，每一个思考着世界的，感受着生活的人。</p>
<blockquote>
<p>“设想一切，但就是不把我当人看。你一再宣称我在接受实验前什么也不是，我知道为什么。因为如果我什么也不是，你就可以成为我的上帝和主人。你无时无刻憎恨我不知感恩，但信不信由你，我确实感激。然而，你为我做的事尽管美妙，你却没有权利可以像实验动物一样对待我。我现在是个独立的个人，但查理在走进实验室前，同样也是独立的个人。你看起来很惊讶！是的，突然间我们发现我一直是个人，即使以前也是，这对你的信念是一大挑战，因为你认为智商低于一百的人不值得被当人看待。尼姆教授，我相信你看我的时候，你的良心会感到不安。”</p>
<p>（丹尼尔·凯斯《献给阿尔吉侬的花束》）</p>
</blockquote>
<p>但同时，我的同情不应该成为伤害过我的人的盾牌。我曾做错的，是把别人对自己的伤害全然当作自己的错——仅仅因为他们也受过苦难，仅仅因为他们也不易，我就认为自己应该承受一切。我不会再这么做了。</p>
<blockquote>
<p>任由着你躲闪我追赶你走散我呼喊</p>
<p>是谁在泛泛而谈</p>
<p>任由着你来了你笑了你走了不看我</p>
<p>与理所当然分摊</p>
<p>不明白残存的没用的多余的不必的</p>
<p>破烂也在手紧攥</p>
<p>不明白谁赧然谁无端谁古板谁极端</p>
<p>无辜不知所以然</p>
<p>（陈粒《小半》）</p>
</blockquote>
<p>我该如何说呢？</p>
<p>现在回忆起来，一切都好遥远，故事好像从没发生过，也好像从没结束过。我几乎想象不到我当时的心情了，也几乎理解不了我当时的做法了。</p>
<p>做了一场好长好长的梦啊。</p>
<p>好吧，我懦弱，我自卑。我曾将一切都认作我的错。我曾卑微到泥土里，卑微到尘埃里，可最终也没开出花来。无所谓了，我不要在乎这些了。</p>
<p>我现在回看一切才发现：</p>
<p>我从未愧对过任何人，我只是对不起自己。</p>
<blockquote>
<p>或许故事还未结束。</p>
<p>或许故事早就结束。</p>
<p>或许故事从未开始。</p>
<p>或许故事尚未开始。</p>
<p>或许故事不会开始。</p>
</blockquote>
<p>我所盼望着的爱恋，我所向往着的理想的爱人，那个爱我如爱她自己的人，那个和我一样将道德与感情一起摆在首位的人，那个愿意为了爱情放弃所有的责任和幸运的人，我如何知道她什么时候出现呢？</p>
<p>我不知道。</p>
<p>人无法预知自己的命运。</p>
<blockquote>
<p>我把石头还给石头</p>
<p>让胜利的胜利</p>
<p>今夜青稞只属于他自己</p>
<p>一切都在生长</p>
<p>（海子《日记》）</p>
</blockquote>
<p>好吧，我的，壬寅年的故事，写到这里。</p>
<p>马上就是新的一年。</p>
<p>这一年我承受了许多苦痛。</p>
<p>这一年我遇到了很多朋友。</p>
<p>这一年我有所作为又虚度光阴。</p>
<p>这一年我曾光辉熠熠，也曾跌落谷底。</p>
<p>故事还没有写完，新的一年，故事还要继续写。</p>
<p>一切还没有结束，我还要等那一班火车。</p>
<p>那片我所梦的校园，那个我所梦的人在远方等我，</p>
<p>她在等我。</p>
<blockquote>
<p>我很清楚，干游侠骑士这一行，总免不了要吃尽千辛万苦。可我也知道随之而来的无尽福祉。我也懂得，美德只能走在狭窄的小径上，而罪孽却沿着宽敞的大道横行。可我心里有数，两条路的终点和归宿完全不同：罪孽之路虽然宽敞，却最终导向灭亡；而美德的小径尽管狭窄崎岖，但一直通往新生，不是有限的新生，而是没有止境的永生。就像咱们卡斯蒂利亚一位大诗人说的那样：沿着这条崎岖的小径步入天国，获得永生，从此是一颗不落的星。</p>
<p>（塞万提斯《堂吉诃德》）</p>
</blockquote>
<p>我不知道明年的故事会怎么写，我不知道谁是执笔人，更不知道祂会如何对待我。</p>
<blockquote>
<p>若云端之上，果真有主掌一切的神明，</p>
<p>那祂是否知晓一切，拨弄着我的命运；</p>
<p>若宇宙之间，果真有普适万物的规律，</p>
<p>那是否在我降世时，故事就已经写定。</p>
<p>（写于2022.07.09）</p>
<p>是否神明要将我掩埋，</p>
<p>让腐烂泥土中沉睡我的骨骸？</p>
<p>是否太阳的光芒早就不在，</p>
<p>只剩下一个癫狂的人，向着东方，顶礼膜拜。</p>
<p>（写于2022.10.05）</p>
<p>考前跟同学说，我特别讨厌自己不能掌控的局面。那些即使我拼尽全力也无法改变的局面，我是难以面对的。结果还真是一语成谶，现在我的命运脱离于我手中了。</p>
<p>每次听歌，听到《猜火车》的时候总是有别样的感觉：那种青年的迷茫，所谓“未来即是永不到来”的迷茫。我记得曾读过的句子：“对自己命运掌控权的过度追求，是妄图以微弱的天赋和丝毫的努力，挑战造物主的疯狂。”想来大抵如此。</p>
<p>好吧，我不知道故事会不会就此结束。故事开始的时候没有人会一下就注意到，故事结束的时候没有人会相信这已经是终页。造物主的笔永不停歇，没有人会永远是主角。</p>
<p>（写于2022.11.29）</p>
</blockquote>
<p>我不知道，我能不能给自己一个满意的结局。</p>
<blockquote>
<p>这几天经常想：如果我联赛考砸怎么办？如果我省选失利怎么办？如果我国赛出错怎么办？</p>
<p>如果我没能考上北大怎么办？</p>
<p>所有人都在问我这一个问题。</p>
<p>所有人都等着我作出回答。</p>
<p>他们告诉我：一旦我输了，我就全完了。</p>
<p>他们跟我说：一旦我失败了，我将永远翻不了身。</p>
<p>他们是谁呢？</p>
<p>（写于2022.10.08）</p>
</blockquote>
<p>我不知道，是否会有一天，我也再也支撑不住自己。</p>
<blockquote>
<p>英国的乌鸦被屠戮至消亡</p>
<p>高卢的骑士也无人再颂唱</p>
<p>（写于2021年）</p>
<p>好吧，他们说这苦难是神明的考验，</p>
<p>为了使我重生，来迎接前路的遥远。</p>
<p>难道未来真的不能由我自己去选，</p>
<p>要前行，就要流着泪告别、放弃一切？</p>
<p>好吧，他们让我仔细看看这人世间，</p>
<p>哪里不在上演悲欢境遇，生死离别。</p>
<p>难道因为世事无常，悲剧万万千千，</p>
<p>我就只能哭或笑着接受，无力改变？</p>
<p>（写于2022.07.09）</p>
</blockquote>
<p>我知道，我身上寄托着许多人的期盼。</p>
<blockquote>
<p>那些梦并未散去只化作星火</p>
<p>那些事，铭记在某刻</p>
<p>那些人亲吻我后转身走过</p>
<p>我才能是我</p>
<p>别再问，曾经的事有没有如果</p>
<p>别再怕被浪花淹没</p>
<p>（写于2022.05.19）</p>
</blockquote>
<p>我知道，还有许多在苦难中的人，我想要去帮他们。</p>
<blockquote>
<p>愿贫穷的人儿能免于饥荒</p>
<p>愿痛苦的人儿能重拾希望</p>
<p>愿迷茫的人儿能找回方向</p>
<p>愿努力的人儿不失所望</p>
<p>（写于2022.11.05）</p>
</blockquote>
<p>我知道，我还想找到那个她。</p>
<blockquote>
<p>纵使湛蓝如同梦幻；</p>
<p>纵使吹面只是北风寒。</p>
<p>（写于2021年）</p>
<p>你在哪里？</p>
<p>你是森林中飞鸟的歌音，</p>
<p>还是山野中风的呼吸？</p>
<p>是星河中闪烁的光明，</p>
<p>还是月色下静默的冷清？</p>
<p>你生来和光同尘，</p>
<p>却注定大象无形。</p>
<p>（写于2022.12.20）</p>
</blockquote>
<p>我知道，未来的路也许并不好走，但我也一定要走下去。</p>
<blockquote>
<p>活在现在的人已走向未来，</p>
<p>信步前行，满载幸福的回忆；</p>
<p>活在未来的人早死于现在，</p>
<p>还幻想着一切会如同过去。</p>
<p>（写于2022.07.09）</p>
<p>我所追求的一切，如果在这一刻或某一刻崩塌了，我该如何做？我该认为我所追求的都是无用的吗？我该自暴自弃地认为故事该结束了吗？</p>
<p>（写于2022.08.24）</p>
<p>我是个懦夫，所以我不敢回看过去了。</p>
<p>我也是个勇士，因为我要看向未来了。</p>
<p>（写于2022.12.18）</p>
</blockquote>
<p>我相信，我将永远爱着世界，爱着生活。</p>
<blockquote>
<p>生命多么美好，像晨星一样，</p>
<p>挂在天空，发一份很弱的光，</p>
<p>带给夜色中的人一抹微亮。</p>
<p>死亡多么美好，像流星一样，</p>
<p>划过天空，然后只留下愿望：</p>
<p>愿我死后的世界鸟语花香。</p>
<p>（写于2022.07.09）</p>
<p>如果我还有时间，我还有能力，我希望自己能为所有因为这样或那样的原因和我一样痛苦或比我更痛苦的人做些什么，我想让他们幸福，即使我自己都不知道，我还可不可能得到幸福。</p>
<p>“你是来寻找本质的吗？”</p>
<p>“我是来感受存在的。”</p>
<p>（写于2022.09.26）</p>
</blockquote>
<p>我相信，我将永远尊重他人，尊重自己。</p>
<blockquote>
<p>所有人都相信自己是独一无二的，没有人能接受自己的平凡与从众。所以有了叛逆，有了为了“标新”所以“立异”的行为。但很多人往往忘记了，即使最最平凡的普通人，他们身上也有不可磨灭的光芒——道德。</p>
<p>有人认为，罪犯反而是最接近自然的人类，因为自然本就是残酷的，野兽的目的仅仅是自己的个体或族群的存续。而人不一样，我们会注重自身，会有很多人利己、自私，但大部分人仍然秉持着道德，接受着道德：我们认同“己所不欲，勿施于人”，我们认同“达则兼济天下，穷则独善其身”，我们会替别人考虑，我们会思考自己的行为是否对别人产生了伤害。这是我们套在自己身上的枷锁，我们会被枷锁勒痛勒伤，我们会对此感到抱怨，但很少有人尝试去挣脱。因为挣脱了，会有更多的人受到伤害。</p>
<p>（写于2022.04.29）</p>
</blockquote>
<p>我相信，有一天，薄荷会开出淡蓝色的花。</p>
<blockquote>
<p>若我有一天得以一睹灿金的世界，</p>
<p>得以亲吻真正的鲜花，</p>
<p>我也相信她是薄荷的升华，</p>
<p>是我以泪感动上苍得到的奖赏。</p>
<p>（写于2021年）</p>
<p>“我的薄荷正在生长。在月光下，我看着她一点一点长高，伸展出几片淡绿的叶子，散着那股我永远忘不掉的清香。我看着她长出两片含着的叶子，然后它们缓缓张开，里面是一朵淡蓝色的薄荷花。月光洒在上面，像是云散在天上。”</p>
<p>（写于2022.11.13）</p>
</blockquote>
<p>我相信，我将与崭新的灵魂一同醒来。</p>
<blockquote>
<p>尘之花啊，请盛开在这世界</p>
<p>多反射一束光，多舒展一寸羽翼</p>
<p>才能离湛蓝的天空更近</p>
<p>才能触碰那至善至美的神明</p>
<p>才能亲吻那有着洁白双翼的天使</p>
<p>才能以光将影消弭</p>
<p>尘之花啊，我知你生于毫末</p>
<p>我知那影仍要戕害于你</p>
<p>我知你不甘居于这丑陋身躯</p>
<p>但请你相信：</p>
<p>待你的生命散尽</p>
<p>有些会下落，拥抱大地</p>
<p>有些会上升，触摸天际</p>
<p>有些会在人世弥漫</p>
<p>组成另一朵花的魂灵</p>
<p>（写于2022.10.15）</p>
</blockquote>
<p>我相信，我会铭记着所有过去的记忆，向未来走去。</p>
<blockquote>
<p>你曾遁入黑暗之中，</p>
<p>在秋雨中坠落，在时间中沉默。</p>
<p>陪伴你的是腐烂泥土里肮脏的昆虫，</p>
<p>拥抱你的是万丈深渊下无尽的夜色。</p>
<p>（写于2021年）</p>
<p>我打算再买一支新笔，打算将旧笔收藏起来。</p>
<p>新笔上也刻了字，是《吉檀迦利》的第一句：“你已经使我永生。”</p>
<p>（写于2022.12.29）</p>
<p>愿你从此一生心中善意长存，</p>
<p>愿万千苦难磨折无法遮掩你的神。</p>
<p>愿你记得曾拥抱过你的我们，</p>
<p>愿你高唱着理想，回应他人的质问，</p>
<p>愿你敬仰着光芒，永不向罪恶俯身，</p>
<p>我们为你祝福，愿从此所有幸福都将你拥吻。</p>
<p>（写于2022.07.11）</p>
</blockquote>
<p>再见，壬寅年。</p>
<p>你好，癸卯年。</p>
<blockquote>
<p>回去的路上，车流多了起来，不知道为什么。</p>
<p>我发现小区门口的洗车的地方换了足球场，想起之前和父母来这里的情景，有点不知道说什么好。但随即发现只是换了个地方，不过生意看起来冷清了许多。很快我就找到了冷清的原因：前面有了一家新的汽车保养店。</p>
<p>那家包子铺还在开着，我已经记不清什么时候第一次来这里了。</p>
<p>许多新店开了，许多老店还在。</p>
<p>走进小区，我看到原本幼儿园前的几张木椅已经破损地不像样了，里面的钢丝漏了出来，原来竟是假的，可我小时从没怀疑过。幼儿园里空荡荡的，想来孩子们都在室内。往回走的时候听到后面的响声，以为是孩子们出来玩了，回头一看，还是没有人。有一条人工河，上面有一条刻成弯曲木头形状的桥。我想起来曾经经常在上面玩，熟悉每一道花纹。</p>
<p>人工河以前是有生机的，还有很多水。以前是有青蛙的，我来这里抓过蝌蚪。可现在大部分都干涸了，露出了光秃的地面。仅剩的水在今天也结着冰。</p>
<p>曾经那边有一家面包店，我经常在那里买十块钱一袋的肉松面包当作零食。</p>
<p>曾经那边有一家菜店，我有时会替母亲去那里买菜。</p>
<p>曾经小区里是有桃树的，小时候摘过桃子，后来可能摘得人多了，桃树再也见不到了。</p>
<p>曾经小区里有条管道放着水，母亲经常去那里洗衣服，我就坐在她旁边看书。</p>
<p>我张开手，拿出攥着的硬币。我记得我小时候捡到一元钱是很开心的，我可以买两袋零食吃，同学也会都来分着要。</p>
<p>所以，我望着前面结冰的河，把硬币放在拇指上。</p>
<p>希望以后，不必回望过去，不必妄想将来，只活在当下，做好自己。</p>
<p>希望以后，不必因为别人而惩罚自己，不必在意别人的评价，不必在意别人的性格。</p>
<p>希望以后，只为自己而活，不必将生命托付给谁，只为了所有的记忆与情感而活。</p>
<p>我抛出硬币。</p>
<p>我记得月考后，我拿着橡皮和自己打赌。“三次正面”，我扔了两正一反。但又不甘心，于是又来：“五次正面”，这次倒是扔了五次正面，但我又不放心了，再扔一次，是反面。</p>
<p>所以我转身，我听见硬币落在地上，滚动着，然后停下。</p>
<p>我不回头地向家走去。</p>
<p>去他妈的命运。</p>
<p>（写于2022.01.07）</p>
</blockquote>
<p>感谢你看到这里，我的朋友。</p>
<p>新年快乐！</p>
<blockquote>
<p>人在雨中往前走，在人的感受中，本应静止的树木自然在往后走。时间在不可抗地流逝，人不可抗地要往前走，树木也不可抗地往后走。人的生命一点一点流失，过往的记忆埋在树洞里，生出叶来。</p>
<p>当雨停了的那一天，也许人也走到了生命的终末。他停下脚步，回望自己的一生。愿他会发现，自己的一生是多么灿烂，即使自己已经到了人生的冬季，自己的故事也会在这天空绽开。</p>
<p>（某年，某月，某日，读过《树与天空》，记在……）</p>
</blockquote>
<h3><span id="后记">后记</span></h3><p>大概是第一次如此用心地写文章，从发布前大概两周开始准备。因为我想让这篇文章彻底成为一个句号，也成为一个开始。</p>
<p>原本只是想参杂着歌词。大概是发布前一个周，翻了翻日记本，才有了用类似蒙太奇的手法串起来这一年写的日记来总结。发布前两三天想起插入一些这一年读过的书。</p>
<p>最终插入的书选定了《堂吉诃德》《百年孤独》《献给阿尔吉侬的花束》《存在主义是一种人道主义》《海子全集》。原定还有更多，这是精简后的结果。在我看来，前三本书所代表的：理想、记忆、善良，是我想要去成为的人的模样。而第四本书则告诉了我应该如何去成为这样的人。</p>
<p>下面是过程中的一些改动：</p>
<p>《百年孤独》的引用原本选择了马尔克斯的诺奖领奖词，后改为“世界乃身外之物”，后改为现在这段。</p>
<p>萨特的《恶心》未读完，只能引用《存在主义是一种人道主义》中的句子。原本还有同篇文章中萨特对信任他人的阐释，后删。</p>
<p>《献给阿尔吉侬的花束》阅读时过于注重情节，没留下多少摘抄，只能找了一段对话插入。</p>
<p>《小王子》原本引用其改编电影中的结尾句子，后删。</p>
<p>原定引用莫奈的故事，后删。</p>
<p>第二部分第三段的引用歌曲原定《然而我不是神》的结尾，后改为《我用什么把你留住》的开头，后改为《小半》。</p>
<p>原本第二部分的结尾是海子《以梦为马》和《黑翅膀》的节选，后删，改为《堂吉诃德》的摘抄。</p>
<p>原本的结尾是海子在《面朝大海，春暖花开》最后的祝福，后删，改为现在这一段。</p>
<p>全篇中，下标写于xx日或未标记来源的均是我曾经写过的日记或随笔，选定的时候有轻微改动。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>其实悲伤早已死去</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E5%85%B6%E5%AE%9E%E6%82%B2%E4%BC%A4%E6%97%A9%E5%B7%B2%E6%AD%BB%E5%8E%BB/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>我想我大概永远都不会忘记2024这一年吧。</p>
<p>其实现在都是期末周了，但现在同时也是年末了。2024这一年，我毫不怀疑它拦腰斩断了我的人生。在这之前与从此之后的我被短短的一年甚至短短的四天阻隔开来，我不明白为什么这么短的时间会起到如此大的作用。</p>
<p>我总是梦见NOI，梦见NOIP，梦见高考前的模拟考，却几乎一次也没有梦见过高考。而且我在梦见的时候总是清楚明了的知道自己的结局了，我在梦中清楚知道我未来已经在p大了。可我在梦里还是恐惧，还是惊慌，考后会回忆自己考场上是否做错了题，出成绩会痛苦懊悔不已乱发脾气。所以我总是怀疑，我曾经的那些痛苦是否其实并不只是来自于升学的压力。</p>
<p>我高考出分的当天早上做了个特别特别清晰的梦，我从未如此详细地记住一个梦的每一个细节。我梦见我被父母叫醒，他们告诉我高考成绩已经出了，他们告诉我我的分数，一个从现在看来会被恰好卡掉破格强基的分数。我记得我在梦里歇斯底里，记得我冲到茶几前，拿起水果刀狠狠地划自己的手腕，可却怎么也划不开。然后我醒了，我说不出来我醒来的那一刻看着房间的天花板是什么感受，也许是恍如隔世。</p>
<p>我至今仍清楚地记得梦中的那个高考成绩，比我真实的高考成绩恰好低了$23 $分。现在看来我的这一整年都充满了这个诡异的数字，这个我从2020年听说的典故在四年之后诡异地一次又一次出现。我总怀疑我真正的高考成绩是不是应该是梦里那个，只是命运心软开恩让我有了从梦中惊醒的机会。</p>
<p>上次去理发店的时候店员问我，走到这一步靠的是天赋还是努力。我很想回答他我靠的是运气。因为连我自己也不知道，我走到这一步究竟是不是命运无由的馈赠。我走到如今靠的到底是什么，是一次次起死回生的运气作祟，是我从出生带来的天赋，还是我长久以来自鸣得意的努力。我不知道，也大概再也无从得知。</p>
<p>总之这一年就这么过去了。我不知道该窃喜还是该怀念。</p>
<hr>
<p>标题是周存的《向内生长》的歌词。其实坦白而言，我这一年也没有太多值得悲伤的事。我只不过失去了两样也许本就不属于我的东西。可我总是，无论是嘴上说还是实际做，我总是笃信着人应该放纵情绪，总是认为自己应该去追求，应该有执念，应该笑，也应该哭。我心里有一个完美的我永远都在追求的人，他（她）应该是偏执的，应该是骄傲的，应该是温和的，也应该是痛苦的。从这个形象被我用剪刀从我见到的人、读过的所有书中剪下来又拿胶带一点一点拼凑起来的那一刻，她就始终在影响着我的一举一动。我疯了一般朝她靠近，我毫不怀疑只要我离她靠得足够近我就能获得我心心念念梦寐以求的幸福。<strong>我心心念念，梦寐以求的幸福。</strong></p>
<p>我之前去过一次文学社的社团活动，坦白而言我的体验很差，一方面是因为那个活动其实人数很少，所以搞了个很小的房间导致我社恐发作；另一方面是我总是怀疑他们在讲的时候带有一种学院派的盛气凌人的风格。那次活动讲的是布朗肖的《文学如何可能》，里面有一个我到现在仍然深以为然的观点，里面有这么一段话：</p>
<blockquote>
<p>使用这样的语言（陈词滥调）只是因为它过于陈腐以至于无法引起注意并阻碍了它必须转述的意义。陈词滥调注定不会引起注意。意象、词语不再重要了。语言从中勾勒了一具不可见的缺席的身体。</p>
<p>——布朗肖《文学如何可能》</p>
</blockquote>
<p>我对此的理解是，有一些词被人使用得太多太多了，导致人们终于忘记了这个词原本的含义，而只是将其强加一个“某某场合可以使用的特定搭配”。主讲人举了个很有意思的例子，他说当我们在讨论爱情的时候，我们会想起玫瑰。但很少人会去仔细想玫瑰的艳丽强香，而只是想起玫瑰。当我们在讨论玫瑰的时候，我们其实并不很清楚我们究竟在讨论什么。</p>
<p>我觉得这句话相当有道理，并且终于迟钝地在某一天吃饭的路上想到，当我们在讨论梦想的时候，我们究竟在讨论什么。</p>
<p>我想一个中文的初学者见到梦想这个词一定会被惊艳到的，这个词的构成太过飘渺，太过轻灵，然而这些漂亮的地方全都被掩盖在日常的滥用之下了。</p>
<p>所以在我心中，到底什么事情能配得上“梦想”这个词的分量呢？</p>
<hr>
<p>开学的时候哪个老师给我们放了个短片，大概是叫了几个同学到讲台上来，让他们按照自己认为的大学中未来可能的成绩排一下名。然后那个老师问排在第一名的那个同学他为什么如此自信地站在那里，我对他的回答至今记忆犹新，他说：“因为我想要改变这个世界。”</p>
<p>我至今仍然会想起高三遇到的那个女孩，有的时候会愧疚高考后打扰到了她的生活，但更多的时候我总是回忆着当时的一个又一个细节，即使我现在连她长什么样子也记不起来了，却总是会忽然忍不住嘴角上扬，然后忽然被巨大的遗憾和痛苦掩埋。坦白而言，我在那之后的种种心情到底有多少是因为我对她的感情，有多少是对她的感激。还是说更多的部分是我自己幻想的破灭：我一直一直都在憧憬的那个幸福的未来，终究没有到来。</p>
<p>我后来写了《刺杀》，将这种幻想自嘲是溺在月光里。</p>
<blockquote>
<p>月光将那条路撒上一层银光，一层诡异的银光，你伸出手想抓住空中的流银，可你什么都抓不住。但你要是站着不动，那些无边的流银又会一点一点覆盖在你的身上，你被一点一点包裹住，你会有一种错觉，觉得自己在化茧。可并不是这样，你一点一点忘记了呼吸，跪倒在地上抬头看着月亮，感受着自己身上一层又一层地镀上白银，然后它们一点一点一点收紧，你的胸腔被一层一层包裹住缠绕住，心脏跳动着击打在胸口发出挣扎。你无法呼吸。</p>
<p>（2024.06.21）</p>
</blockquote>
<p>可我又如此清晰地记着高考前我坐在楼下，我想着我还有想去的地方，我想着我还有想要见到的人的那个时刻。我为什么那么清楚地记得我在走向高考考场的时候，鼓起全部的勇气回过头来朝着她的方向大喊一声“高考加油”。我为什么那么清楚地怀念着我幻想了无数次的我与她站在蔷薇丛中的对话，即使那段对话其实在现实里一个字也没有发生。</p>
<p>高考后我逼自己去准备图选。我当然清晰地意识到自己实力不足，但我总是想，如果我真进了图，她在看到喜报的那一瞬间会想些什么呢。我也总是回想，如果我在明天死去，她得知我的死讯的时候会想些什么呢？说到底，我后来的种种行径是不是，是不是到底来说是一种卑劣幼稚委屈的情绪，我明明知道她已经下定了决心，却总希望着她哪一天哪一瞬间会忽然动摇，所以我其实一切的所作所为都是在努力去博得她一瞬间的后悔，去赌她会像达洛维夫人一样想：“如果我嫁给了他，这种快乐将会整天伴随着我哩！”</p>
<p>我在这里将这段话写在这里以自嘲我的卑劣，我或许心中始终以一种丑陋到极致的观点看待着我自己追求的幸福。我一直宣扬自己与过去自己的各种行为切割，但其实我骨子里仍然是曾经的那个卑劣的我，其实所有我拼命养成的道德感也许都没有抹掉这个事实。</p>
<p>后来我笔试的确答得极好，却也的确没进得了图。</p>
<hr>
<p>我后来读《罪与罚》，被其中的“索尼娅”深深吸引。再后来英语课上读了《欲望号街车》，说实话，一开始我对白兰奇其实异常鄙视，但最终却渐渐感同身受，以至于我选择了这部戏剧的续写作为我的英语大作业：</p>
<blockquote>
<p>MITCH: If we … get married, I swear that you won’t be on the edge of lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world is … always too harsh. [<em>There is a pause.</em>] It’s getting late. Maybe the bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend my funeral in the future? I have no idea when it will be held. But I know it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could imagine it. It will be quiet and stainless, with pretty flowers … right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t … don’t answer me. Let it be a mystery, a fantastic mystery, just like the end of a fairy tale. I had read so many fairy tales when I was young and I always imagined that I’m a princess living in a palace, in a magic palace, waiting for my prince and then having a happy ending. Everyone believes that the protagonists of stories will have a happy ending, and I’ll also believe it. Do you know the French story <em>La Porte étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the end of the story, the hero and the heroine get married and have a happy ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry. Tears are so precious that you should save them for more precious people.</p>
<p>​    [<em>Mitch covers his face with his hands. Blanche wants to wipe away his tears at first, but then she hesitates and turns back.</em>]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the former things are passed away.</p>
</blockquote>
<p>也许我自己也是如此积重难返，无论别人怎么说，我自己都能体会到自己性格中最为肮脏丑陋的一面。</p>
<p>可，是不是只是今年的我如此认为呢。我毫不怀疑现在的我拥有了高一的我所梦寐以求的一切，毫不怀疑他看到他的未来的时候会欢欣鼓舞，明白他所经历的一切都是值得的。我也好想在未来对小时候的我说，他最后终于成了一位发明家（虽然可能发明的东西会与他想象的略有不同？（笑））今年我的网易云年度歌曲是孙燕姿的《遇见》。我太爱这首歌了，我也太爱其中的那句歌词：</p>
<blockquote>
<p>我遇见谁，会有怎样的对白</p>
<p>我等的人，他在多远的未来</p>
<p>——孙燕姿《遇见》</p>
</blockquote>
<p>说来也好玩，我是在冬天听到的这首歌，而这首歌的开头第一句就是“听见冬天的离开”。我想也许冬天也的确该离开了，只不过还有不到两个月的时间。也许不止两个月，那就三个月，但总之它是一定要离开的。</p>
<p>上了大学后我写高三回忆录的时候写了这么一段话：</p>
<blockquote>
<p>大学报到也有一段时间了，在校园里待的这几天竟然无比适应，既没有在高中的那种被支配全部生活的禁锢，也没有假期在家里那种一天天无所事事的颓废。总之我愿意说——我希望过几个月、过几年后的我看到这句话不要哑然失笑——我现在真的开始向往着无限可能的未来。</p>
<p>（2024.08.26）</p>
</blockquote>
<p>我现在看到它其实已经哑然失笑了。我知道自己的未来其实并没有无限可能，有太多的事情是我无论如何也做不到的了。</p>
<p>可也许我一直渴望着的那些事情，我一直向往着的未来，我无数个夜晚辗转反侧的时候脑海中幻想的一切，我走在路上忽然入迷直到差点撞到人才清醒过来的幻梦，我一次次写在笔下，一次次自嘲，一次次又在笔下抹去的幸福，也许，也许还会来。</p>
<p>可我难道不是总是这么希冀的吗，我难道不是每次都在幻想之后发现自己所幻想的事情一件也没有到来吗？我曾在脑海中描摹的一切最终证明只不过是虚无的清梦，如同一个赌徒将筹码堆上牌桌前幻想的他赢下所有的场面。我读过无数次“远离颠倒梦想，究竟涅槃”，也自嘲过自己是心想事不成的超能力者。</p>
<p>可是梦是如此美好，美好到我仍然愿意执迷不悟。</p>
<blockquote>
<p>不，他说得不对！如果我谈到波丽娜和德·格里的那番话是愚蠢而尖刻的话，那么他对俄国人的讲法则是尖刻而无礼了。关于我自己，我没有什么话要说。不过……不过……这一切都不是这么一回事。这一切都是空话、废话、扯淡，而需要的是事实！现在最要紧的是去瑞士！明天，哦，如果可能的话，明天就动身！重新振作精神，重新做人。应当向他们证明……让波丽娜知道，我还能够成为一个人。只消……不过，现在……已经晚了，但是明天……啊，我有预感，事已如此，已经无可挽回了！现在我身上有十五个金路易，而过去我曾经从十五个盾开始！假如小心谨慎地开始……况且，难道，难道我是个小孩吗？未必我不知道自己是个堕落的人？但是，——我为什么又不能重新做人呢？行的！一生中只消一次（哪怕只有一次）我谨慎而耐心的话，就一切都妥了！只消有一次坚持到底，我就能在一个小时之内改变我自己的命运！要紧的是坚持到底。只要回想一下，七个月前我在鲁列津堡彻底输光之前也曾发生过的类似情况。哦，那真是坚毅果断的极好的例证：我当时输得山穷水尽……从游乐宫出来，一瞧，背心袋里还有一个盾，“呀，那么，吃饭的钱有了！”我心里想，但是走了百来步，转念一想，又折回去。我把这个盾押在小数上（这次是押小数），真的，当你独自一人，置身异国，远离祖国，远离朋友，不知道今天是否有饭可吃，却把最后一个盾，真正最后一个盾拿去下注，这时候是有一种特殊的感觉的！我赢了，二十分钟后我从游乐宫出来，口袋里有了一百七十盾。这可是事实！有时候最后一个盾就可能意味着柳暗花明！如果我当初灰心泄气呢？如果我不敢下决心呢？……</p>
<p>明天，明天一切都将见分晓！</p>
<p>——陀思妥耶夫斯基《赌徒》</p>
</blockquote>
<p>新年快乐！</p>
<p>（写于2024.12.28）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>你有想去的地方吗</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E4%BD%A0%E6%9C%89%E6%83%B3%E5%8E%BB%E7%9A%84%E5%9C%B0%E6%96%B9%E5%90%97/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>你有想去的地方吗</p>
<p>目的地是天空 还是大海呢</p>
<p>你有想要的东西吗</p>
<p>是繁花 还是细雨呢</p>
<p>——JUSF周存 <a href="https://www.bilibili.com/video/BV1Vv411i7UU">《你有想去的地方吗》</a></p>
</blockquote>
<hr>
<p>那天她问我：“你有想去的地方吗？”</p>
<p>我一时不知道怎么回答，低下了头。</p>
<hr>
<p>我喜欢幻想自己的未来，也喜欢回忆自己的过去。</p>
<p>我当然这样是不对的，我在逃避现实，可我能怎么样呢？</p>
<p>我那天嘲笑自己，觉得自己幻想过的未来好像一个都未曾来过。所有的重要的事都在意料之外。</p>
<p>我还嘲笑自己，自己回忆过的过去，幸福的美好的记忆我回不去，痛苦的悲惨的记忆我改不了。</p>
<p>我有的时候觉得自己的未来一片光明，阳光太过迷幻。</p>
<p>可有的时候又觉得毫无希望，不如死了算了。</p>
<p>我很羡慕高一的我，意气风发，自命不凡，觉得只要自己足够努力，只要自己的感情足够真挚，自己什么都可以做到。觉得自己一定在走向幸福。</p>
<p>现在的我却是瞻前顾后，考虑一切现实的因素。</p>
<hr>
<p>前几天一个朋友突然兴高采烈地跟我说，他找个大师算了一卦，他未来会找到一个特别好特别好的女孩。</p>
<p>嘴上不饶人，我心里其实很羡慕他。这几天和老师聊天，所有的老师都鼓励我，说他们都认为我完全没有问题：无论是高考还是以后。但这些话听上去总有些奇怪的感觉，有些安慰的感觉，有些怜悯的感觉。其实这些话很有道理，毕竟老师们可太熟悉我什么人了。比起这个，路边只问生辰八字的算命先生似乎不靠谱得多。但有些话从人家嘴里说出来，可信度反而看上去高得多。</p>
<p>说到底是命运，我有的时候太过相信命运。</p>
<p>因为当我一步一步往上爬的时候，好像就会有一种错觉，觉得自己是天命之选，自己与众不同。</p>
<p>当我伴着风往下坠落的时候，好像也有一种错觉，觉得自己什么都做不了。</p>
<hr>
<p>但其实能做的还挺多的。我想做的还挺多的。</p>
<p>现在书单里大概攒了十几本高考后想看的书，还有几本看完电子书准备高考后去补纸质书的票的。</p>
<p>和几个朋友约好了考后一起出去全省乱转，和几个朋友约好了去他们的大学看看。</p>
<p>高三不知道为什么突然喜欢上了写小说，现在大概还攒了三四个idea还没动笔，以及几个已经写了但是藏起来的残篇。</p>
<p>买回来的数学书好多还没有仔细看，一直说等到高考后就开始读抽代。</p>
<p>好多画好多建筑只在图片里看过，什么时候能一睹真容呢？</p>
<hr>
<p>周存的《你有想去的地方吗》好像是我关注她之后她发的第一首新歌。我其实不怎么喜欢听外语歌，所以听了一遍就放一边了。</p>
<p>前几天坐在高一楼下，突然想起来了这首歌名，所以我对着竹林，我很想大声喊出来，但我知道喊出来周围一圈人都会觉得我是傻逼，所以我最后还是很小声地念了一句：“你有想去的地方吗？”</p>
<p>但其实根本没什么人，这个时候早就放学了，周围人都走光了。</p>
<p>所以我又站起来，鼓足勇气提高声音喊：“你有想去的地方吗！”</p>
<p>还是没人回应。这时候轮到我不知所措了。</p>
<p>我放下书包，看着远方还亮着的灯，我拼了命大声喊：</p>
<p>“你有想去的地方吗！</p>
<p>你有想见的人吗！”</p>
<hr>
<p>写到这我自己都觉得自己在强说愁了，但总觉得高考前不写点什么心里难受。</p>
<p>其实她并没有问过我想去哪里，但是我确实是一直低着头。</p>
<p>为什么低着头呢？</p>
<p>可能因为我真的有想去的地方。</p>
<p>可能因为我真的有想见的人。</p>
<hr>
<p>高考加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>一路喧嚣到黄土中</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E4%B8%80%E8%B7%AF%E5%96%A7%E5%9A%A3%E5%88%B0%E9%BB%84%E5%9C%9F%E4%B8%AD/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>我实在睡不着，所以我决定起来写点东西，以纪念我的第一次通宵。说实话，这种想法实在有点可笑，仿佛通宵的意义就是写这篇文章。我有的时候总怀疑自己是不是闲话写多了，所以生活中看到什么都像素材。陀氏说他“担心自己配不上所经受过的苦难。”坦白而言，我的确很喜欢这句话。可我也知道，陀氏这么说一定原因是他是个虔诚的东正教徒，所以他的灵魂可以在饱经苦痛后伟大而不朽。而且他也的确是文学上的天才，他的灵魂也的确随着他的作品伟大而不朽了。可我是个不信神的异教徒，我死了就是死了，一片灵魂也留不下。再者我也不是天才。事实上，我之所以现在仍然醒着动笔写东西（现在是凌晨4:49），无非也就是我清楚地明白了自己并非天才，因此的确，我死后不会留下什么长篇鸿文供人瞻仰，我的灵魂因此也不再可能伟大而不朽了。</p>
<p>我先前说自己不信神，也许这句是气话。因为直到刚刚我还在嘲笑上苍的恶趣味，可如果我在心里真有些什么宿命论信仰，我想也多是自命不凡的骄傲。当一个人开始自命不凡，那对他来说，苦难无非只是磨练。甚至于他每遇到一次苦难，而且是那种最无来由、最奇异、最想不到的苦难时，他只需稍一摸索就会明白：这当然是上天的考验。上天处心积虑、费尽心思地指引着他，一直到他也不知在何方的彼岸那里去。写到这里我也不得不承认，我所描写的这些当然就是我本人。这种宿命论的困扰太过严重，以至于不知从什么时候起——我以考试为例——我好像错以为决定我考试成绩的并不是考前或考中，而是考后。如果我考后灰心丧气、后悔不已、发奋图强，那么我的最终成绩好像也不会多难看；可如果我沾沾自喜、自鸣得意，命运就总是能找到方式击倒我。这甚至使得我一度过于害怕自己心想事不成的能力，在期盼任何事情的时候都要竭力往坏的情况去想，以这种方式向命运摇尾乞怜，展示自己其实并没有颠倒梦想，而是正脚踏实地，而且正亟待命运的救援呢。我在这里又情不自禁提及命运，我想这是一个一锤定音的证据，说明我其实内心深处仍是一个自命不凡的宿命论者。我认为这源于我的懦弱。一个强大的人可以笑着放过苦难，而我只能默默将苦难视作某种积蓄——某种流通于命运之间的货币。</p>
<p>我刚刚提到货币，其实这个比喻不是我想的。我之前给DeepSeek喂了句歌词：“也没有用情至深，到命运心软开恩。”所以是否只要用情至深，就一定能感动神明，换取我应得的幸福呢？而且这其中是否还有某种汇率关系，受了多少苦难可以换取多少分量的幸福。也许神明还默默给苦难和幸福都分了分等级，算了算公式了。</p>
<p>我说“我应得的幸福”，看上去好像是受了多大的委屈。但是，诸君，不论你们会不会哑然失笑，不论你们抛出多少理性分析与证据，再把话题扯到诸如心理学、社会学，或者与我一样，扯到宿命论和神学。无论你们怎么批判我、赞扬我、攻击我、喜爱我，我都一定要说：我认为我完全配得上一份幸福。我直到如今都坚定不移地深信这一点，并且就在刚刚动笔写下这段开头的时候，终于从长篇大论的自我剖析中走了出来。我不敢说我的生命有多耀眼、光彩夺目，但它一定足够璀璨，而且熠熠生辉。我直到写到这里才终于明白先前提及的命运什么的全是借口，与其说我是一个自命不凡的骄傲者，不如说我是歌剧台上登场的演员。我至今都记得王尔德在他小说中嘲讽一个人说话的时候会抬起头来，像是对着看台上的观众表演歌剧。这当然就是我，我所要追求的从来不是什么伟大的不朽的灵魂，不是with pretty flowers 的彼岸，我要做的就是以我的生命完成一场演出，主角可以平庸，但故事必须精彩。一切多余的理性都不该染指这场盛放的晚霞，因为生命只是一场盛大的葬礼。一切悲欢喜乐只是这场葬礼上的配乐，而我要将我所有的情绪都奏得更高亢些。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>一个个慢慢暗淡</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E4%B8%80%E4%B8%AA%E4%B8%AA%E6%85%A2%E6%85%A2%E6%9A%97%E6%B7%A1/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>之前学长跟我提过可能要回ytez宣讲这个事，在那之后我有的时候走在路上就会想：我该讲点什么呢？</p>
<p>坦白而言，我到现在也没有原谅ytez。但我确实对我的学弟们怀有一种莫名其妙的感情。这种感情大概会被几年前的我写长文狠批一顿，原因是这是“毫无原因的集体归属感”。</p>
<p>我记得可能大概一个月前空间里莫名其妙掀起了一阵怀念高中母校的热潮，说真的，我一开始看到这些的第一反应是不理解。我不明白高三有什么可怀念的，ytez有什么值得怀念的。但后来我又渐渐觉得委屈了：我不明白为什么别人可以拥有一个值得怀念的高三。</p>
<p>如果要界定我高三的开始，我觉得毫无疑问是那天晚上班主任找我谈话的时候。我大概高二的时候在博客里写过这么一句话：“当以后迷茫的时候，你要想想：你已经受了这么多苦难，你应当为了那些还在苦难中的人做点什么。”这话直到现在相当的程度上指导我的生活，以至于我大学的一大乐趣就是给过路的游客指路（笑）。但当那天晚上班主任突然嘲讽我是“精致的利己主义者”的时候，怎么说呢，很难形容我当时内心的感受。我不明白为什么反对学校的那些屁用没有的形式主义规章制度就是利己了，我也不明白为什么我会被贴上这样的标签，我更不明白为什么我当时情绪立刻就爆发了，仿佛恼羞成怒了一样。然后我听着他说他从来没见过我这样的学生能考上清北的。我对他说那我就去成为第一个。</p>
<p>我后来果真成了第一个，只是我已经辨认不清那是不是当时的我了。</p>
<p>至于后来搞什么小组连坐制度强迫我就范，至于后来我期末考崩了自己低下了头。我该因此而责备谁呢？当我后来上了大学，即使在宿舍里舍友大声说话都不敢制止（坦白而言，后来经过交流发现舍友只是没意识到我有的时候睡得很早，因为我一夜又一夜地失眠，经常半夜一点下床喝口水，然后出去走一圈上个厕所冷静冷静）的时候，我又该因此说些什么呢？</p>
<p>当我高考完去山外，听到老刘给我作讲座介绍的时候说我“是省队里性格最温和的一个”的时候，我只感觉恍如隔世。</p>
<p>我毫不避讳我对高三、对学校、对班级的厌恶，我到现在都忘不了我们班班长站在讲台上嘲笑有些人思想反动的时候，到现在都忘不了当我反抗学校早读提前的时候，学校一个电话打给了我妈妈，然后我妈妈坐在餐桌上劝我，她说高三只有一年，熬过去就过去了。她说她看班级群里的录像，每次早读宣誓我都低着头不张嘴，她说她从来没看见我举起右拳，但别人都是在举起来的。</p>
<p>我后来写了一篇又一篇的小说，我将自己的人格女性化，我叫自己“莉娃丽尔小姐”，我让“莉娃丽尔小姐”在小说中遭遇背叛、强奸，我让她的希望一次又一次地破灭，我让她被刽子手砍断双脚，我让她一次又一次迎来自己悲惨的结尾。可为什么我还是觉得自己不足够写出自己在高三所经历的一切呢？为什么我写到这里的时候连我经历了什么都有点想不起了，只是觉得胸口好难受呢。</p>
<p>为什么别人都有值得怀念的高三呢。</p>
<p>我的高三当然也有一段时间是幸福的。临近高考的时候，有一天晚上我放学之后走到我曾经待过的高一楼下，我就坐在楼梯上看着前面那条小路，这条路承载了太多太多的回忆了，那是我最意气风发的年纪啊。我突然想起一首歌，那是周存的《你有想去的地方吗》。</p>
<blockquote>
<p>所以我对着竹林，我很想大声喊出来，但我最后还是很小声地念了一句：“你有想去的地方吗？”</p>
<p>但其实根本没什么人，这个时候早就放学了，周围人都走光了。</p>
<p>所以我又站起来，鼓足勇气提高声音喊：“你有想去的地方吗！”</p>
<p>还是没人回应。这时候轮到我不知所措了。</p>
<p>我放下书包，看着远方还亮着的灯，我拼了命大声喊：</p>
<p>“你有想去的地方吗！</p>
<p>你有想见的人吗！”</p>
</blockquote>
<p>我是幸运的，我高考后真的去了我一直想去的地方。</p>
<p>可我再也没见过我想见的人。</p>
<hr>
<p>所以当我见到学弟们的时候，我该对他们说点什么呢？</p>
<p>我一直都觉得给别人提建议是一个相当傲慢的事情，但我其实真的很想说：</p>
<p>我希望大家可以保持自己，我希望大家走过校园里那潭绿色的死水的时候，看完上面漂着的油膜后，抬头看看太阳。</p>
<p>我希望大家都能拥有一个值得回忆的高三。</p>
<blockquote>
<p>我也为你祝福</p>
<p>愿你有一个灿烂的前程</p>
<p>愿你有情人终成眷属</p>
<p>愿你在尘世获得幸福</p>
<p>——海子《面朝大海，春暖花开》</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>誓</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E8%AA%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6e42c90926aa3967443d4d57d44ae2f26898ecae63c5d69c4a17fb76c895c130">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e7d6fc45f233b4b0f80ad704da28189c8599487337841ac11305ee212fce8c6693ba4b7268c2dc9dc845f408c17b606a1e14d812ca1b394757ec64f2d8d6a3bc28034f490e3d8f57f30d4abab075b9449466c5295ba113b6975a7a0b492786ead41d9f4aa75fbed9314506e50e6d7ce506aab2e76ee5bb856f637c8a0ea13320ffb82e4bced46d2a434a016b0df223de26cfa2c5198fe8b37062d43dafb7ffedd7831b66188245ebfc629a8f7be313c96a61e8745b01aa0b6c9a730522cb52a5af764d018b8458f4a14c1891957b69a49062f806704162140ce137b52d652ecfce69255c5cb871cecf86702dc429839bcf30755f0692db97a04df61d1e89dbdedecaa634fc5bb89a072c72f27c3c92566dadc4a48cf99eb7dd8084bb4cd4446dcad19d1f252316bf40941b6d76589e4fafd1aec4be9c8b8e61ea4287769b1ee20c57d40599ddcc07459b8ba6510bfee5dd4f26801e854ed748b66f014e0d9fb5231c16a9f4b1efe8172516c4127862b99391adf9fbb0d4cf6d5ed33193998578f750e417ff58cab35637a5c416449fb371b178e894df5c01a1a7dae2dd6378791c9559dfd749574479839afd72eed2d2213ead2d42ed9972a593013856ef88187704875278e91a8ed620c5566cbbcf222fb03489c96a3e829f911c70bd4c51f6609af86172e0bf7927b37c710511c17aba97b517b7119f894c9dafad800d902d674564dc31712fc3c72d509c19ee99d3f01f39741ebc3d3c4b63b6ce51fe242e2612c39449e665996009c4b45ca5b965f33a46c0096128e2110594fc037f6c652c12aec0a0d6e1e665ee056700590f3f8a15660720b1997f2c8c056d156a057164a3829f9aba9424c9bb7d162b01dc1a08b9df0873586acff959e138465267db619164aeb1254ea971f7adfb04e2da60008e088ef8b6e00afc006c5d2dd5b67f37841a75e1973a4f19ea6319f348a7f0da4e3068dcfa052d1179345c7a782620137a466dbbc801548b6d02caa38d298c17cd1c2e45bf8caa69b5d0603a2bde4886d7a8d55f1ab8879714eaa72d853d2a3e45c55dc7678d8171c9551a612400f82888890bfa2546127c617baef0601565888a16c90a039961111bda588670f8dbaa26b06c75df0637fe1dd0dffa55ad39a8d02d45b312d36f9e226bec939814c9a1b6ef75fe8d0d6a6e0684f0065f0c202bf84af9fa2f1fb1c0b6e63d13711cf97f615e76ed8a2861c70dafa37c0b8d14bcad3a12b670f00f69e95e9f6f24a8210a93fc2def1a77f23ad45b119b5d6b09c83cd19eee12980ede0eed86ce3bf176b042d40ba8c512affbc5900640735695c9f2ff9f9ed8d4078bd7a4c238be8c04eb4bb8d4ba4f1c6bc8eb7f232eb8712995e2437d05dec1084ca5deb6c440fd21a2d38d67f526f36447707e89e070f30ac2e7c40185f408d75e09ab11188f2d1a780a83097156dd36dc669bba7eedc691b231c9031e9495ea8fbee8e739a5243886242eccca0fd9cf8cace6eee2081a3f1a2b6a897eaa9960a5d5a4803ab0fa4847fbf77f66304505a83e6c23aa4df28b7bb6a716126a56aa69536d205591c713d91a4598b583455018e7aee940a3dee94054b7e794d2ec06de86c3abb434b89a68bf0823139209022acb9db4aff8997a92c62442466980556b3be6ebf51d438f63aef9fa2f99c78f2c950f37ea865f9b9a99dc92e767d1414046cd45c286221dec14e9c79d6e20c888649de684d628105ac69847c85769d2b768de38da1b00239d146cd3799f7c38dbeebf69669f0b884c7157f067658c044fc6514b6350552d640a9498abb70448e4b3cdc931cbdf10be2a60be9c5a39eceafece08099903b7a5154763c66f4c06caa762c3d0cfac90defbac35a3e60566d239a89bcc65f10633aca43fe177f0821babb756516f978eef66119b55f00697bd1903235aa25a1f97f7ee050d817249b22cdc6b95ffaa9f2aae017fbf9a929510e767ab7606b7f7ae44641dba8277f19e96cc017ecf5ec81a38fe84a065d1d653d18de6514cf14beae682fb3c1698d6af1a03fa38cd519305a9840ec78cafcd695d4699b5db60a4bc04470bcebf390c694eb99435386e57f4a3c66da2955fdfacfb3caed429ec9446b326f7fad326c66c1b5c7765ec7eb6622bf231d6c2bf6c73e9494875cb2e8add654278c1c558b8daa172914e9b5e05d678ac62cdc068bff22c27e5c50f80cfb637d76e839b31660792e1fbd623c1190e5fe0485561a95f95d29de77071d709a69e1a3a30d45222b42a5b184222096ea5cc6fafa30c415b32f514533b0bf83b1242d36923240bc211aae14f15b14d6f9614c157f10434af22c8fe45f1e09b30d3ee83528da7c687bf07f5b5651221f6fbee2345e3dc9a30aa42b0006402443e173c9f92cadae8087254ba5879836d4d705122f33a9aeac813359e27a79aadbf1c371d0b1a4b10dc163440a2b3945d57e67059d420e5aa1109af6d519ba2ebbd326bdf922f9634a427474a2692da2a52f36b993b39fb728b2f62428085306fb9bfc5487364a676678bd5ed560d468e40ac208c77a4146a801c9f7a6a6b558c92780dda0c2ca3c8fa7c42907740055e631b4faf906ee917abd25152947a34d1e69759f3b961a92fa69030ee906a7298e89854b2911ff20f0bef983559187206aa032a7c152f01ed739ca79b9b573d33edb17259f7f5e0ed438e3889cd9f8e0bd176f1d57423f08249b29bba9dc40808f65da59c9ed3782a7f135e96ed3727d08759b3dd1341c62b7b3c0caa8cd2fd9657419d62bda2a3c742dd87c290ef2a3db8853301fe37fa7747a4e6792ffa897668c915d7a5442576cb806d3fd4348f05f4160a87540c4c151a7a6f5b957c08ce41f40c8b65b5c4d66573f5fe311526e6a4fa7cda987e1c60b6f47fba47a59e86958e536d462e4765d0751faa8037f4e78009021d82e3b4ab1bf3787ecc68c73d159ab7badf9093486b81fd341f7122e7e9fba1239aad58a48450720637d4e3ba5f23eba6518d760d2ebad46a21ea8f95aef4874e46721665eca06dc842600e54cae58b118013c964231118423f5a6df4d128a1bac7bcd4c7ff6f60df0f77564cfd6d89aba875c7d91ca3332f57c8cee754d41c60095d4d93628cde512d2c9a46ad942f3b62c29aaf8c36b84347492c240af9e17f4ce3d9a04e6060dfd7781692b73829c6256cf4793a4479d9abd713c116b74b8eaf8fd483904f645a368c79a9c6f883e21390c8cf3cb35c1445c9b357868d812b6f5fb45b21c691760812fd79e219a0fc1bf0980184f9c0cc225ffa2df88ac56c0b848b7b8dde891149e861423cf12f68833c56242c86471405938ca68f99f657309e2f55a04a4e3c9300dcbbcc65d76884dda415997f01849f3d8d09688031a7883457c56e9c0869a238ff4a8c233430c4a5d9dfc7f48aa4b79d26c224428740e5fc131e3d091e65b155dd4a5fb3ff0ba9a78f844019e47f01d13ccd6a16d112a33613aa4d5b8d5d4091afc7c03392967014fb7e84e77444ff161684540bd6edfe0e06ad2d9d87ec7a909b4b29e3d5418de4472b0ec94c592cb323f86c3b77aa9d9541a92c63085d2d6b5a855371b0563738d60554da2b7cbcc12d6ffb445d19dd9f10405d34fa1635f5a5150129213f8c2058aed12d5543bd7b2e6483f12e4934d28a0cbe3947c408a79d186a2f81e341f354190f9dee883443bdfeaf200217ff1b8eff3ba0d8fb1eb73288a4f8c1dbe734a9d8d32d5ecd7c6dd70cfd1dde4ef628f48832183208ee8c11b3e7cd9ffebbabbea2d1eb2c8f724a899cbc7e4dbe968c2c1be92140b68331b28afa36e1c13ed11c7975e04c56256db439ca2fb9461b62ce363ca33a2b9713060d13b431b39f6cdf08ca771bc77f769af04e1ff2ee0a2ede94dd7e489511c558557acdf8dc6224225e9a49cb5b818c9204452cbb573a9b95a8fb3d2ec9012cd8bd75b46ff64fdcc2ffc601ffbbc843bd583a4b09019c00b029ca1e72ddbbdb97bdeccc5aacf5c41ccb01dd839c46503bac084a1b2299a33b222c34af96fa7f241111a1a3e4bdc870f68a3c0ad172b697ca4824db717a6c5d508d5c434c15a1376d90ffd947c9bfc316952b5ea0c713bb01bd37f65100885c4f5fac34de3188357999de9fa541c25fb07d5d7d07b8069329a3b09da0a1ee9d52c79cf65c8470430b41b97c06ec1bc2cd21a6e5d2be425670462c09bfda1472f6b7fabd9deb04dfdbc195c3239e508bf6ab877186b0296aac5230081e50fdc1383203185003866ec4dbd0e17d170baf2565c289659037deacc6329fb9b2561539d90e48d31706ca1234788ddeb81a38cc896d7e137efb396f3220b5649e3cf62c6bde8ac62861bf042830278482e5bffa8a8efc6242d8650dbce701a1924b8fe148d41d1e3065e42460fd7a86f2fc5a9aedfd0fd806d906ccbf592ba4eef436e59cad473d2de455be25cb6f2ad4396b223b4a5dc3dfeaf85e723f96d9ebab6f704cac06995e0807284997917610db49bc3cd532518b616f80641ffe710b7dd3dbdb95d27e6f13f3a42e5acdc3f5e6634f087a63cf8fab8abcbbd642fd033a74effeb487463a2a2dbb255c445038b4ef017f5e7b6f3270436c0c7ca0a3f1f3c2799033c0184b05fcf4b000bde9b4fb5233c19c85739b77b44488cb440a2849c8b76dadac959e4c17eb9319e838e13720d13f0c163cb53e908a2d47e41114e63c992f330dcbbbc274f34edfae8263f5af127f5c4f13bfbb79c2fb463692e15a3255806431bf8cef707cd088bed073bd60d20148d8048394c4555f284cb3fc0b923bc6ddaaa7f240e6c6d96603e067c1a07018a3e5053eca48fbc02e2079fb1fafeec25e9ce8592452989e8185d35dd46c6fd646d7e82282ad5477581b0e81f047b571b62c1e354fee9f72a18060de44fd407474fd087c20ad7e1406c4dd9579e48b42f59a3050402f70557a7e3c53e0d7354a04e7d1fc1db5746188e75366998ec2c53b51739a2c99d59c7f60b458fc4fedb8d72668d7d58d5acc6b659b974a38a1c85e52d51a4ff1761c9a4bbba0f02ef608384203de8a8b072a5cb40bf0a28a486059d10c4567c04abbdbde17f394000709c42bb8ff716c38f21f0af90444b1ffa2d67390d4b60909dd5fae4cec5e2364e70e1ba084dd42c7054a03f47cae26bc63c025f7637b3bd1738e8d60e0117fa33adbfbca8ba8429e5a97111a7ee8732d62685b83aafcd62e6e6d16a27fb1b1d02966b882096de16127556c45af37d05d915d0fb21eb50cf4d7423153307ea4b5ba4caa185d742dc7238078ad28f3f429de3bbfb09782b5edf0259ae576d798559cf99b769e4a847084ef8ce39993eda029d3c19677c3826bfc60d3f2fac4912b49134993b61088ef94ea948adc145ef8225fbf646fdb034f0a4dc990a7546dbaa5e317db0df1a91ef0ef1a51d63b3017275aa9e082e7563f0e4bf8aaa0fd0103618decc272ba1b93eb51ec9a947a1dc17156526cca3a20b11d0e893e05f29544da95931005a9d239859b9af4baa08b6c1e71a112ffdac5ca3ce11b0b8afe9094dd5dbfaf98f1322baed87cd11c06dcec8fa1643bcfdc77bb5c1a9c38f361a4537f34e95cbee9824212205cfea5e4a00f1191809421525a2b17512e6db3d2cccfaa5e521b280bad16674b46f575023ef78417261d8bdf9725f78ecc32f09cd463da623433af76bbec4247e472276c78f24753eda9accb30f6be0cfcb4d694122fbc911cf87dae9bffb5d6acc44ef42ddc0285f974575cff2d43de0de478eb69ce5ebee9c21b340fab705163606c8f4ece0f58a592fdda38b2b76f099cfdadd79e78bef802794647e50c4a9e2b5dc7eb31a6274d09e7418d0a6a6c3199ce2ca3fc4de6de4a4fbf607ef364b982e75f3771b014410298d2d6dde57a043c301dec1afea0e7a2f930295d2197d7bd7e29b2feab874628850bc32897db313df4ef3270659c3798fc4bd920751a43eb86bf7ee8cc7a269fe7b3b48be26ab30287b3a05d29a71d475796b91e79dbd088d658707ce2eee3cf28f135daf32631cbcae09c4271d7db9185bb9ecd07681db6d5c482a6deafb957ce8c78fa998d7003fa4478123a79d56a96eb39be3d24b1d7397e61fce07d09fd7664e7aaf28bbe2bf1aa8ce37199a39eb99a31ddfd4ded6d745cd33b7f34b44ef8a89e479c87396637d135adf9a16193e1ef456410af082707bf77640c102e4677b7ad5708f68e9e78099ca62e175337cd3c11f14100751540a517e7a45c7576f06df39a77bfd0b9527c11792de220eb09f82ca7cc42cafdde1616c805d79e8475c51432b31c367b9b93762a17c65055067b0571a906e99627844c699808c73c6b7293b71c5c985c472c586fea180abc0a42acd40a15b1a7a2186647f1cca362677522676564667dd7c038a2a6da91b97a39843f9ad0220c3c607cc13b96a61a02ada51f0c949b1c42a13094880bb64ea7f8db7a41bc61268d24de7075645e5caea8761460891465e89366d7e96a98c61626023ea391e217028b3011acede41e1bde9cb1ad290b962686d5e99fa7ca84e53e4096ba660ac52dea6d4e8b5f5850bbea1b023162bc1643af5fc2ffb11f17a6e6abbf7d550357769bf456449c56b0b8fbf91ac75b1589d1b0d268f715941127216fbb08bdf355446233529a245ec4daed7755a3645fab9fcfef8dc70f4fbde94b46f535ee94be8f6ac9466fbe1b4f88ea4c71178d06234aa721cc83f1952383fafa055a44e4184a51aa8ff0d7b80cec7af958d10025652cc042674567eb5428f69ee04f10c1f00e7eadfe08061daf65687d2be6c88d128d3d9c4b4976f0af584a22895411c71d1469942b97e9ce6bf5f10fb3464b7a85fbb7529d8bb7e70bcb4e8ba0be194672f9b26b3930092725b603c3c0ffecce4e5441df88ec50d3c96c4280dd0595bdcab6727216909054f5c9b578f7159b0213fb9d452c69a5694b3554aa8f6b64266c0bbcf5d697dd83aad798a01ae3311527fe5e69263bc2193bcc96ce4e9a2d6ce160fdcd9457a701b25b06c3f5d6bb9328d0d3d6c993405b19602f8b2cbb7f3dd8fd97637fd7f08e2df7be40607b9ea0f03f092f756af82047493f11675b9ef1516c63a8f9876cff15f45168c605754acad75d6bee8f1be6965a51371d612163ccbf75c7c2754ed93976f4f884c7e3b4b9e29dd79e15955d37c71eacacc475e49dee1522eadb20b16bbaa4b61df5aa32c70624b76d58d4b09e0615b789ca950eddca7585076f66fe0c1e27dade50890c93635eb49f28225a7eebe6ba5d2604b6d40a9d7b649caf478cbb7e546e85168a754529a1e253dba60186ede660e3f6d375dc2b82e370fa9e7c3d9b83381da3598195b41ca87ca3a87a36a9feff40a1efd6576a352ce9dadc47b0c429b47efb965d423171cd033b44945b1fe2324927e20db7a1904ae81038b98e0292b0144add449e2e58ddc66d9663f3726c64c153ff5a1a44cd32851788a8c25478afbc488d016e493303ef9e11590f2a11a9d5bb91b5ae88cf3529498ba536ecb98d8b4a89043c970e572bbd248e9ff185a0846cc5af4c753be1ee6db3303de842fb2876679c130d02719f6a149b491eaf973ca2f09708ce92c9d45ac01475c8020ca6999fd5df1cf2e5f4b9f8744c955128f9d64e4ff9a9d1ec6313f94bb40a1684f1ef9cb0ee823593b672aa2cd05d5264d37a0eb6dd16f7ef3cb138117a0128af27c28dd5d7935a17b99a710129107b9e4758e532caf8ec8069e07b0eb3a7763db093cd3093f161c0c72a6d8c23cca787df290340e385d6aa134e2604d1344f9e37b74864a3924438a2e7ce4d58806ec43fe9ca7089c9055651cc7a4b7640768f668ba1b91b0c7dfaacbd73369a3670871178910c43c63a3f32e074be5964f6bb01fa7efe5dba10c038e5b3867039f8e86b114e3094e1a28519e152a4afd6376b0ce46ccf1e4211d825c8013ba379f4ab4ce8a7001ca880845c27d5f9ce80308da1d27e18f07865798f799c0b7a996e22acabe1df03050e675cdf55bfac71afa21bcc5efd91aff0a7a19f6bdb75051c92608ee922d6b47f4c0ec8060f1c8b3004de3446ad7d752f05e98034f266c74fe941509e65f96cec44a8dbec66748fee39b3d1b33d75bd41bb83f92451dfd13e3c6d7b2d18f869d0b6091925461e6d3a79775e7ee752edc7abdfb5be57754dafd5aec54c23543737f0c708f077df1f56bc766dddd2172943c9dc157dcf62483b4078c6a5fc31945afd428cbb72710641945581b0b2281417b22d91ae77378684135bd03ecd6b9b48577ffa98277892c00ca3018db815220c448618b282a5dff0497d116b397f76a7dad16cf898c8476539fda4e5cad45298887d65b70265c72e69b9ef4c75674a59ebfb5c05188fb0e7279046d0870206ac44adeb0fb69bc86420610c8422d139f16a998dbac053ef55c4466c2a59fca5ec3e18208a9bde89caac930ec211e48ec920265fe5a83b06b1187ff78a2932f1684e0ce21aa5d9f3c770b9842cbf426fdc393426d8576ce81689c31af5c114583d7e0da4d1591c0708b6c71bdd2ae847797fef34cfd96254fb67f539cda77db3ad89c5a35f68b152320ba964266f6712a0be86769245f17e3b638d9ea5f8bc13ca66418b60c652beae6ab3ac0a9d6c90d195221fb0ab9ca982dc074ad35210775336c3326285c193231f6ac4a49a9612cc1506773d71281f4307e1d21e5e8d87e4bdaa0ab0099626995f2361711f7d0d427491c35be0919fe360bd0109a9d8d2f867aa0bd7996ad9c86171a324620ee5a9bb25973b5e5d41b5b9a11bb83ef81888c7ce710c39888808a3592e20cf2acd54dc7d8d07f818cf73516844803341479bd2a28b89483b2d08084204c2aa89823f41749b855fd129947447f4a2749945061ba7151e2d2fa1544968bb14774073335a4c6b93a4f082dceb6bb4e46e4aa6aabc9ae6fbcbe71ddd00d3a15f30a8aae7d413cbb88db5ee793a7d79eca8d42b9ae440a7f06343a3991339629965baeaeaac01e07527bd4ea06ac225ad685bc2e31483ef0cfb0f437d861412e77c7a02c15f209554ee0ca8767cbe64da480540c6ebaa1fa49f9b55d8f5363e42add4d8f363a8707a21b32da9fd5d5c6df57934e26615c5e2ae3ddd8508d2f72516785cacbe8acaed78590ab7517580ebf424ad4c5c2f691eb02b37d7ee21a5103157ec6acab05ceadd4f690607778114f5befc224db5d32383334867c84c21127102c36753fe0d6b53c9b47b8d9a03e42bd66ee90fc19cdc9547ac4484142bd936473812aada4686707b73b4860f077302cba270222682a263b820b311e2204c735202c20257433a033b2b7a3483eecf0fbbdf79f4fbe16ce12f3545bd15420c084f503f50654209c2bdd753811ba76a5c3f09c0e9f4f9b03a809da2ec096d0f020c6aa80cfe5720857464ca700f6d4b0ec7daad43875be8f51fa55692a944b59a57d5bc5525f3565accafb146465276366eca6cd6709a70ea8905c45a742e46490c9bb1b77d515bb99c707c7ea6ac293ae9a54c2d732230a1e59af280a6c25cf457fc1b785e769a5ef0373cf5fe4b7b3acbdfc68ca56d3657d40454c713339ad673e5a646808fae9799945bc1347b9dfe70ac067128522884d5994560bceb50072f99fdf9b8e89df125dac08cf74e0510963f4763634ea7c4c6a3dd543600bfff6a5e008854fe54d67bf4bbdfb5394eb948a85eb57dffa48e62d1d0e9b9175c7459d9c4f43cf8a70cd717384b944e7c06d4efc8cc26f437f661d886f5d4fff8240162c9276dcc0382a77927ff4d484af24b55a2da57978bf2a4c6aac1fb9e2cbf54f62b052980473bd0da9e53376b0f91a9ce89c0689f30993c6c50e5e07e49344e7cad57e6be3013424dc5fe801d75074eda80af20169dfedbc412f7b79b2216405e3023a35883c0d9593c5c22e94635bed9c62098cf91f4287cf9b38ef86a74d1b346314de7f65711b04e3a5665340ff34a014595b5c7a8695d4374fd4a0344d6c116fe112422ea275694ef15ff53984643820318c36c016ad676333fe1fe35413d314897ed11190f168cc018dd0c3e2289e3ad8aa8f0f5e5565434f38cb6bfd3f62563da8aa70c5a754c2a6c27a2491ae62b8ca04a26bbcabf03305b7c78040715e2d4b16ac4fafd5fc4107d3efae7476077b09d2f6603643240c8f3a3b4dedc023ee7931d2e2beda506e149b31c007f418728e09f4d2cfed80a7bd2d620329071ee433f6449df7a166bd7c5dc2534eaee10416c8caa2cf21b0e619387551cad9ae8de493d37215c8491d1d4ef8c4a23e7f785016732da7dddc3cc222aebe2dd0bc3eb35679c46c3673d3085c8507b33fb3228211bf9492d9190ded22a73b325610472bac7bb0cfb58910a6f432d43425593029166749c38523722221ef480f55274ead0e9b1348e5bfc3cb49e09ee9ce50879d70a131300416687a94e52c57053d616c288fdf794d8bac65bf35d4c439b3630c8d9e5f9f79940aa02cc79f1a5bf5e7ebbfa67b4fd2ae4e0f869ef26e4b5859eb104cc00ce96da9d8023ba9505761dbf6c1a455c0314001f0088d6001d8e404b366cd24708ecac520159dd83e5a732fad4c48ca7f2d0d5b046f9259c94fb48cce4f1b56c992b792596b54150c0d52248cb0b6e7fef72f2201f8dbadc19ebc4d5143566f956fb04f47c6d64ccdac501681876acf6d7b4fc1b9e92b4b36f0570dd77cd3496e6d35aed873b078a52b59cb2eb9b8b1bd2ed81ed74ba5db59727c8128e4b9a926fd9d0da1e2064be3884b0344ed5928ef0a17c3a386c5a1acf8041a8b8585327b8ad96c685b4f5ecbb7b392c0200d66aff689c89fd55c046b3f4665ec5fc24a331ffe13cce84403996790b0a52976f2389abe12ed7bf65354f9bab170f31054febecf47bb4f3824f265f9c049cede2b2966c9227a2e0632ab524fbe36fe34e9f6b2becdf2be61b5f2c9e0c9abb505e256ffe198de6eca4e920daa0b46423b782996ed4d45c16cc39ad9e087bd8cefe3c70f00de0e67b9d0015908df8dc2004096d05975751c10dc14dfc2cfcd8ed61831db8bfc03ff43156ce2c02a8689aec9a81d9cc3c9136a3a5c4c06ff68f940f8b244bf12e70f89bb2980e26ed344c41bc9f7ea0fa10f83944d8832432236021431f940e76e514ac0765d3cd66c083a5c0a4dc8ac88967598c78b6b2faddde64ea6eee60e7a899b9ac1a72ecbff0a859715badbd58c6219112f8954f4847bd55a135b66048f8040c9995d9054eee8459d3c0657449c45162caa4201aea3092cbd0dfb0493489dc770fbc317448f9babebffa6378d612efa07bc52a6c1ccdfe1e9a0d048a277844f6a5b93b206efb4d3c3d13f6536b4645c37eae9a8124c228e05973b1724221b481ef40c1ec0e04e48d20e5d3d75fc09bc99de14b607687f7295cade9a07b233c64f60839ca8724a49cdc85ee38e96f9f1681d59db10f4b5a6101aaf43f98bf990947f3f5898238706420db9d4e6577eb9befc10ca3cd55e22c12357faeeb88b42c6819777225122eb965b62217912e8e5231bdfb11cc254d6ad25e0ed5c9559f24f33244ca6c171813075d40f2696d485f70a0808914bc8c1b79d71eec3df145914f0be06c2a4d79de22a062e0289b5de76091a97a6c22ca85840a135e35589744f423402a3dc027c4acd36bdd2fc67b98f9a74a7edcf19221e3f6c64d8243cccf272c275ff8919bdfd8fd13bfce92ae9722d46e1ad99d5b26af92f9155a634dbd377e803152e63142895b7f625d7d1427233969ce214c8602e4b283ec0d3ebec811608cdf92731bc6649bce9c3e689dcf0bcb46913e07a0bd07bb266d2d3de824417b3a8e9c7c67d8b01e84f3ff781cd2a17cce6fa44571f70f3232436ac634aa1daf393fb702ca1a4ece5b059ff5b58c48a1afcbd4b12dbb744a985562a861b838a477f6f9a47ef9588aa188391c33492231db8277010e7d41a63ab94053d4d3517451d5fb003caaa2f9a6ee17e4ef552cb7be5111f3aca29bca63bf50c6f8e1c778d80248498081d6b7176813ca37797c60abbc70f4e29afa9f02388e9eef5a9c78669169a9eeffa8b3fd84072dd40a5d654cd8ff7537f6f65acfd49d323895130f7d6ca98890f07b97f564ee4fd6932739f94ee251c49b35dd29ff57b244e16a9153b113639287573b92b08320d266a0a3a1485cc5884b0d19413c0817e41ff6102fbb731550b9be5440b45bd3d61671f66870718b632b7fece86bd415e50475ad0298934782aa267bff4522ef62fee11d95c50384608fc0293ebcef3e5f272093844f8517cf2343adc55ce2bb59870d7136e29dd24b29ea503f022ad52a6ab13059bc119efd101b69fa0ab31e8e20f37988370b111feee5aa66602c14ddbb40cf230193a043da9fab8fbb4439c494afe06f1e924a082518238aafa9d16ac4aa1835d1528beea229789d5310f0f1ad4005d399f5cf225f372d05675a644aaf4661aa90ea9be6d0d74bd4f74d993b14e3ce9e01f116ceb739ea64d442b9898425e6a92aa63ef6f64443442b25310eac368e828c2eb4780aac4df7998a0d2790f7320709cc38a2e3ef39a81a9e76a66096b7dbe2e26aaac2655c12d73470b83d67533ce798afe12efb2e3078275e404cd4b0a4570b6da58c48d2700f52a5d7d72b1fe0b68984dde5763089e2d59dbb52187ee8fd70f820ff628b7dfdf8db30e6198db7a226455ef46457ce2db66f4a580d734b07808bcf7aaf6ad2afb30f14160b175536ca094c875373f07dd39fecfd43836233098c36fa953c1fb2095929a902586cb4bbef4dad43e023b084d7da5819080bbd5fcb130c441373eb49985b7de7c16f00254efc0dadb547366ac3e37b314979cec7e3bbff2422956d941f44e09cf02dec9288aff383d5080664b505c1ef7aa19f065ea2dfe3ddb1e1948fc348802a04126a21e54f0a713327387fcc890335a8b09a10e6957335acb81887c735b96cabeb786b4708d08530d664bbc4e44b9ee2438079583298511e553e2860c08e72b8a155d75b6484d997bc25a1338dd7fb96567e8ec6778abc35660c19d510bed2756ed92c21dc541b1d873e7d0373d77ce8768eda9dc52fe3778b800a0dfb2087045ee20efa0a1e22791db6f3ad8d301f1cf08cef3aa7fc9cfec117e3284d9cc362cf61d9e3c4986511cfd1c5886dbbb574d06157cd719d2f9e6faa8b0dda9ded0947c25993e162fe6a13ee6061499208fb5f4912fe536fbaaa0407ec7865b58f4d2ee154f0a77dafce9d0be79d74cd74729f4de0298dbb75bf218b64e6914b7e99b96b6eec19be7d4bfd5a52c1bbe3a0b7b0037c0b8687a1d4babffa07bdbc69accf42cdb7a0b01b94fc45880f8a35a42c143bb96531e5fb526c7774b42e21963e10bfe8d134f4b9c726c90a9db2ec1722526fba37974143e3c0c0fb375dde1987731c9d3fcd5e1e77b5655cece138d6d971df9e78fc5b19d2e908d786c47b354bf1c8606b2f452f27ac4c5536f3d72b0716e5f779b474609e5ca1fad37547414a1e9f1ed7e37f67cb55864f1f3cda9010a67baf9ab1fef5c210bc59a27d399fd3756d9f2f88f87ce9259a7ca4f022bce4f92dccdd7a79532ee82064a6561e3666fc2657f778c37654a6f9a730b70f7dbcf8ee31dd55bcf0be62a11a60cf8442b181ef0aae70412a360045a169167978a40a54a381e4e7535e8412de87688d9af5b48e66fbdf3078be69f4fd22a68e6f4724ae989b7100ce75562842df7a2391db2a3a2f9729acb4b53d69d1359b23491f7d0eed3ddd61e3af36b5f59a728e98bc3151cd1024206bdb6f270718d66070f7b9ad33223a82ab86f2a8339f79a9d1c8c3d6f5ae5be6fb0d4f1d5aaa0cea2f83b0dea3a85d2b5abc799fa613024bc1326b5e497ceb15df341ef392bac2a0ba934e1c028400e027f57543f4ae1aee104bf48dcbd94cf717fa1833892804ca015d326ca758cb2fc0b9bd994e7dd6dae503307570ada78948fdf6c3e641288824208c48bf57aee0a761e15a797ab994e4ca1422e06cd1bc0a95a88262986af134a012521e1f33900efffce616bcbfecd2a01f85556e2a54183efd00401fbfaebfa0927553f2a2fecb9878183fca2807ff5455ed5bf20f4dd0234b2ac710502e4b8f8da9cff30f7d06542c030ef7f326e243e4ac2466c41b445e83933bb6567db3b1b24dc172d1aa99b470ca323f91af82802eeb3b588faa4ade23fa2d2d75d0d912588f7455823c7d4e18aaf8dbc70abc4fbf3bbbb965ae61116a96dc381f7a526e8677e2c781cd691436476cdddf2917df635c8cebda8af9addf04ce9f51e60e345eadaae4293f8fa53eb9e4b6372fe7238bc8247651ffea6e03b5e8b5dffdafae2fb998f57cebcc723eb355119a63701848f77cc2c924c07bbee58ae25e38e09444799a01cb424165bef1888e54fb1bf5766acf6078404da6aa0c1e8f8ec36e038e1c2b15ed37cefea9d0b1c24b4655dd6a92ca9b8620b121aeb3400a967474026de4dd498b9b5553878f925e95453438d8af9cd23d41cbeda8216af58a039756e60020b3fb87dd8f0fb07c95e24f974cc9e80b8d0a83c643afb5c10a80b59e959be92fb0fc211992fd4b8651f4ebde42cbc4c912c05d871595bf213dfca308cd528f035d8c7ef20c4d8cbb01a785ca40239b3f7508eeb0382a7cb73df2931effbb95f70021515c1bafcb66f2c68714046ad19fcc5f73d4d25f39b5d33d340037193b172cae5004bb041742285aa538dc8ff8f0de409f9a4bd2a976d4b0445b29e43eaeead2648a6e92f38556bb39c199900e9a673aad2cb694c6e8e0910173c0a06cace05b081601d8e1085214b02b31317ee26b4cd46b075d962d8fe61d85cb8a94d8a9a9e3c40dc0f662b5d337dc8539de1828e82f4ef8189df338939465b0412ab9e462a2e8e22a0e6ca7710e1791541e974dfa6932c5386767410798ba5cb17042ee4a0e2fbc5044b1e1b8f5e0af77ed6c4dbae3e73006714337888913a21fc1a96dedb9c9cd117b87d0e3a3fb8320495625091988dd66cc731e238be83b9f7b7240a86ca9be151ecf130326194d1cfaef6f7edd76687e0dc7ff6ca7331cb1bc5d6c9f6d3a532506f05f531359a080b4fc3244a635b5e0942036a4d3b490a0bd89cd7280e6d75fc453743338ae2ed2004af82dc15c5dd324e91a84739e44c33b1cc0f6bc9db2b730d0422188850be66ef980cef3cafa39013633661a2a789c1071f0371aea3c0b09fffb91ff81282b7a98a62853d15b7f7be29fffd0ee6bdbdcac1a554d64ddcd851a4ce24f29531c6545665011e4783d8579ee82e7ce84c83ee30e816b09ef2ec10c3d6da53f448f20fee74834137ac124cfe67b450440a98fac1367bdfc976986c208257370e080b5b3d33b5ff5c34538caa62fe5eec11068497e674495ba26180e3e846263e5fdbb8429e11d9485f6077163009790d3e6f2236efc7b1c9b4fd0bebfa6718ef147c5ceb34182c26c7b2084a7fce8df6cccbe3f0bfad18feab47f1679319740126a6d82cfdedff0941a9b3dc6e32843fcab5cf15c54a6d45a13801ea4669a2f8b9da47183d0ad6c233b2d5e26b04e8bdaa953c2848b76df3eabc48a9b188d24a582103c5daf97633ea5d5b5b01bcde1bbbe95a8ac7446f7d0c986dc50c25fb06f6c613bf19e2808fc7efd369dbf79be05b9e3ff190b181839808b23927258e2fa3f1a17fbf166c9b18f9ed680f9c8f81b8bc7f955301dca2dfe2daadb678c8c69a0037d70694fc2ec79e73d1e2258a2dd21a08d0909e243d3cd7e8869e0bafa173cd98ce903d322be5fb5db24416adb3b931cccd98ff7e6814b0eda85dccfa2cc675952276db325387fb79f8f8a98e6ece8caae4f2bbd5bd67ff3b0aecc3ede29089b3a876bc9ef8571459a56670a5ff74c619f9c47748f87a76e6b070537c349049097d563b9601ae74a410cac0c2e37093dbf28e7daaafc320b6dacc9e397d59efed56a1f03c27aacddda621bf1ec05ba3cc7a430c3e754b8661af66dd071f93f237617468f12a0e83e4624138af91060602b45f8f0904900f73379e60cde66a18da8a6d58faee9bb68ba951928f222ccd3af14af012e3d7e4ef401a4184c5a4e2cd06ff0ba83aa55f642d6867e37aee4d65321e6d7d55860cbde371815f9696d02a38140338a206c3ede61a5bb722733980598672def41a8a6d74b0ee37e17ba1228d2af5fdefc5394f6e75c6c4eda9335cc913cdfe34b5313afc6e2e186cec714267eed288a4561c50aecde85c2939c9b409b130e127f5e567793293e803a1c60cd97ebefc0f78a3f432c4df2b0a4ff26bb46568f97b851cf75f141a8f834eb6eaf014ed11d1c4e76649bb9bf102185297f4aa384324a555358a5a1983ba7a890ba926328baafb75e1754173e5630ac7b426f9a83c05efba1f744dac4c68570249a9ad02c1aee0b358c47f2cdbf3eb7141ad15b2ddefcb8a3aad8b350458aaeba26c0c872239a033c1f9b5280847f1fde5e9b8a1534de8c851e16043049a4a55d2844b157fa46201337f511976af5304c0699ba5f0cbbdc88a78fc598369ef8a92e615a994404a232d08946f1db8259a10491e309b975b9e9050d7531c9d1d82b00812217f71a39447f6f2cc48b25b5e10501322e69271faeef7a3da7cc6abd7a273649c89d7579fbc2a8360287ec2d65c5a0e18390555b099b7cbc949c275d0435ee3778b5543c582e30f362c8ff1b1971ff3d439634bc8995861690d88831184da6e339538d014771a530ddfeafe0def39da7784b0dc8e4b233d5e813d0ffdda8be5e2e06720020e9e4420e2ec7a2ba89f53da00c6bc9db09d65e3e77f5f835bbfb662f63401210d205e4cb690755dcc873f79774ebb5223cfce5e0ec6c12b479eca58620da81e92791b3c5e58f2037bd4f52aa70b069a2d417cac6233fb514b1f58234ccd85c1aff1851556de951a89dc16520e0e56044165868aa35be42fa853dae772c57c596a07b1f3337f6e37576ebd27779285c0c03e013bb793950f51a964bf713f8a4e569f25abb63a3485219621c822aeb12c32a8cb20cc1e3ca4bafbe38a41e8f7c8efe1be2f008f7a4dd972f69400342acd5580b59ab67c9ae34dbf2524becc990a2073361a47282def08c60b2c5c85c2edfa5644d327fae4ac596f2fd0746b9f4d331aa268ca28e2946ceb5cd6e66eb509065e0e0c94fb6958fa043fb8c016e32e6d5c88a864e9c9d8e98d4af23a1d04c5fbf6fc9eb4e5c69d7deb7aa5fb3c5746dade268e2f94c50580adf3e458ab1fb9a28d17e8a45fe4574fe3817fa3caa1aa9e682beb9f6579c6f4bd91306bbd618dc111cd402712ae9aa0d8ef7485f650cacf1702cae97583e8c12304539d1ef5a7ee10af48b58f14bff330a2ecdcff81f1a144fd6094faa0e1b88aaf93fdc8fce448911f58d1762527f0e8be743b2be2d1d93e9bcbe8698008808d68b84c1d276f3f05ecb9f8ad68f5b45131214233abf0210f87af0899f9b5b2bac5fb57e904e7eba1a4abfdf7dd21d96b39f27e3075538ea919b783347447231bb21fb6b032c538bc8db7cf80724daffb3d83bc55435bbb4aefc9e254fd037fd62e10b45feed7a16588f0b7c321b7e913468927ffe70bf61938e00cccb532113e5d052da9f32ed3e806384a8ff3b2287be195ed87fbd4ef07d15d39542c9fa63104a174cfe68383aa3768eb40129c6a6d6d1d8149f2e6cd31ec8ed58e85596eb0be8f796a2109e9a26f4e10fd5b4654288ffcb17bb2fab74cf13202014b0ab2b3c1a065480bba40e4fe3f6ad59df2d3bf2b4c01c54fb86da542b5c471db5a528aef39720345000657256cf89ca43f9873a8f8785ece9babd1b54004bb21babe669bc869a33a1bca49334b1b4275f5ee56e98ca33b75f1f942e482fc6a127a71204bd5a09947f96f8d7c06a35a3ac48bc9f8e49436a375c9fbb953ac256acf62caf3ff727342739ab3608654ef5b4c2ddc11ddd52574caccacc0b5490c1eac03f66d42f06e2f991e438af0f3b48561136ef2975c1d5651effb6b1e035f4ef3d995836f2034af9d3e49705660485fe15831c5e4c9d22b4e99cceaff4ba14c66a2d2e6db2bfb11a5424678981d237b333d42094880b1270d34937fe111f3a0d64dc485a7852964927264f15f34b226292395748608ada5dd9c39ef1ca00de195e7b147b96725f0e7f237176453f34e8af5a4103d30c6be756342c8adde0c75e357684291940b7add5b83da041add9682976ecea417db15be90879e382333a6e5aa5fbc5908ce71eaad4170e293877ddf73dd86102367baa73abd55bb53a22642644d7579f05ce97d4c6799b79886136ec1bd98a597f7abc4062d4a9720733b29b8c261b1296890fb992cf7860c6b2b944675a5d020511a928df7e467b2e880f169a8bcf2eb345e1b8b34b8e6b14ec54b48d68cf2bc5d19c48d021f1586c5a35e681580ad6f4c081e3e42134a76762bbf7d85926b1b068e453169c63dfbe57016e7abb3d2ee46f77075f0c4ba7f5559c7099a6507f60cc36f8724a720017bc557a223a8ea66215f0b10a6ffe68b7acaae2b0f7921e0f72e0c16a390820bc4bd91d262c314160b99b84bdeead2f6f174f48d3052e54f93b830a9c936ca6cfd61c4769d8f9d23a83f88b32ee1037fa2535128804152359e889311f0f3e326159c7e02ecf7d0404fd29ddac3d7f6e48f8fc82f1d9cb7cf25ec547649fc9b6e6df473620933f4b69607c3d58ec114f7eac6a87924812113f6d37084b316dcc1e16588311c800ba511963757b32ecbbaf258eb65facf02788029839809ba11eeef85e2d508cf17e43c446a09aa44ce853a5e7f28a3dc6ca3680edf521dcf99c71e779ad23c981033e579c61ad7509fbd00b6b21018e99978c1cef26a8eb21522b7b1723637f03877d8d23876d8a73c7d4d3b783599ad3f164551e6ec0132a1f73089b550186356ba22b98f30a3a65f10db58198e13e038f4289b0e66938d2b697b69212a11d5ea7dbe23423e8f7669c9ada4d8683a72bed7699efc30728003062ae0991e6f564084614c3eaeb947558c573a9b0259a717f18d135b8b82978d40f19f6eb343d41f0d4b22b0bbe0acfe011d8f2aeb23875e661b91d734bdfca0bbe0d21efaae6dc33c44bfc1003d4ad74a3f6f52239891e3212f9800d41d9397bb310f14e44ea4cf9cca21f0de5f82cc5b88764990eea61d40704936d4538be8902d5aec8023bc51d607b5b3176a05ba1e306058772faf8e2f2ebffdc5b68d332b66e254eaa89904426288070f6adb40fd661428b1e4750efaa46c940e1079b22f11b7ff9ae791a36de1b390607b157eeff31a0ea60f753f33335c280da32060a32b6383d4db48a09eff2f7f01a00a415664f7f903d5953e58ec1a25c276ac768ec07d954baf34b863491c555b23c18ab84ffbeb67f18270399b2cdc40d59837ff39a8a3d25b059ef87ca85727b647e67e0e077d380b9c3a32f7ed969c5361c72f9f31bcc3f584980617e9f6c60eb17c781fab99b6a129e5cdaf2cf213c96df1ab8a568ecfb2bc4491db4993d4625ed45b582f7d3b645f6af3e605e02eb54fff5bd63649701c68220feb300338432b7fcabddcb1215da00ab9e6d61886284a509fe93e1863cc7b2108c0c90490f0c90c214fdea963625b8bb36a3165496147e3add13c6c4369f0f7594b9cd73249c5173010ccc22c588937709a92436c952dc31b477810462b373948d589192778c87c6a23e2533d8fe752fd6acb8b5a3accb87a4ef6efd917ed84f21a7da95a752b61812fdf8da1a39193171ab731e219ddb0df7aad7175cc42cee8493a8277b91fe830b0fcfb9e8a5909174b4880412109cc72ac30fe4dc7c1238b72b22753556d3cbb09070cc4f42f6d2a48b3db6d5e889f3f13349c0d9bf07bc72820148ba45e1936aaa8735982cf7b4c5647ef4d47f652e1954d077ec9b3099bcff1fb5e73807184004ae5c1ca22694ea0106b160507c4f1312c01ac69d2d5cb0023b6462d933a6fe5294a5da4613e4bf63cc1af950a4a22d5c1bb913102d02378f6a5f37b9f8463d319acc0680a78b60e9eb11b8e12e479e5a90519f2566f746eee79e8b4d2248fc096f9bc54adcd2bee57551c4f82a2bf60e5fefbdd6c4086b454803b872724702597308ca2b1e6b22137bac33984bbdfdbc6aad6338cfcc3135da05cd83b25f0e1f127bf6bff1a4fc6794b06f5e2619b822f6824bc25ca05b2ff3383ba716aa7d57af2663a9481bc0d4e6edb5ee0ecf3ef1cb1aefb1e28b12a9998d686477d65dfdeca56da203b2cb32288c482100774918ed2cc7db28ba0d4969b8f8c71ddd6b063c4e2db002d1d9acc219e2e79c8ce27c0661204b4a5635991aed16674cd33945e27f538ec5790a75451f9f432b2994231413f80c3f23d0c65ed1cc3899df404a2fc719b688d7b087003ad35d352987b6b7457832bea116a58c6a91a238284f78d312e41a06ced881ba95d724ea29bc91d946d3dc7f4e30aa4b12a436c403e40cc68503ac64c89d1769d7f4b04f32539891e768b54d92a6eb2b4af22ef1349a2009559c77c5e8f738c44787eb51fac2087dcfa67e0a5e6dee78de954147d3f2e489df2523255ae76f8db17fcaf900fb4fac57e4fa1d93e165e28ff1018cdeb0bb9fd9e10d59d15d442337f703fa0f845f6d2839f7479c0b1f2b6fbf794851b3351acfc184eba837b0501cdf6dbcf365bce8f7a98a3f1306b90779e3936fe2073e62adf55ad8aec573e4c89244d2e5da7d784dbeb0e2b3a8ab1062880794ab3b494b4cb00e8f6d4583a2139937a3cd6b1443db055245c838face46a19c7c2b7f4f8949b4d243ffa90ea278bdc7211faeb289a4bf0eccb47d9383350c94cd2d1391b6add5adc263b2fd06d11840ffde1d824c127fadc700f62d2c14a6b2e4c05fdfd2bbfbc4f14259dadc62ce493150aaa4b1fd3604f2fb7c69fae775050bb813a460b03dc89571fe116248350a9af30936debb4f458beda4cef5ca8b43be1a6110899baf383e6e218b7a022557658b758b4b4b4925abd7a099a18dcfe8c711d331cd09f0ee49156e19c4744467dbf9e636456145fde1c81fd51223c11bf183e3dada05d9b90da204024cf5ac3dc4e875cb053174eb2167593081927aeca76cda100850bfb3b81d1a2adcf11ca3c4222ba57cf60222baec63e62066a54b1336369110529f868bcd9f2507c6801eba97a1cdd6ce86ad868afa0cf8f0cf0875156dfc765cbc848c6021d5191a4a7ed5fd2edb84e4354d97558271feb134b027db22deacfa15b91be578fb82f5a36e09ca32a581090c381163ff3ac9a34e15a757ff8d95d97bd179f571471d2f42f76bd5210dd8bb7215d97f0788bddfcebcbe870df9143c1bffbc10803b0526769abec0ea141fb60d1b33ee7d4f6ca5633d839e536e09d09fd501a671f9ab4532851d31466a8c46169aeca63f3b3123636cfb2f56658d28105856e801ae9afdcbb7e765917aef11e381edcbb18d68cf10469bb83e2b7fbf6b4b90fc644913486612108da9088f02d9568476207653ab2087c28f4e011cc6de62f00da0c64b55ed73fb0aa55a293fa400bca72a73b10e2fbc7711e6f0cb52290d23bc5f4e8a05468464c63d547c799fce96f6d054526d18b490bedf1f14a643ffc0a441e252e97fa5a68c2e6cdf3cf09e757514cbada37948c08c49a57f2d1aada8e903a18dfcf18ea213d58fa7c104ee10c1860e8f486598e24367943e3b6b732334f85d4cb9914ed6aab0463c57bf30fbb376e85b91b24120628ee706ad78a61fba8300afdc70cea5e431e4813c2726126de0600c99783bd6d2b5602f34a6040230716e71663b0e4bf120666d927b960c9e8ceda01291af56038b35a8f090ee29edd478fc02752e3d2e98cae62c5ab8aebbd41ea903d574d99df89420b268670e2bb94f1a220bc301c65a13b716c0afeb37beb6b7bb06bddd299eb5fb800fe69ccd172fa81eb839c31dbd0dfe151158ffd50a34390dda50fa1754c18958894e2b822511b8ec0e69cb67327b1daf7c9f16468efd877f86d9a93de8390970cf798fd87cec89051bfe15211d287a0bfab65366cd081cc27cdcac8916ffc18cc1fa80368d45022c35b4ef33a1262ad49bac56240a7a0767d3465533569e478a97de23b8eb0f067434a32e19da54c1cd9c745f8e37c5f54f78fa4f4d3bd58ecabefca5520446684b172fc373cc57dcefd2cc3f2212d8873e1790455bb8f54fbe6bbdf2e8d8e357891dba32689f8a6044f0cce16bab0742b526c0a498e1358acbd497cf59e6193180ce9e68c5e5dda6bc98f0c40dbd38b21194abef80c26b1a282d3aea5b0e676704aee8a9518799afe8e0695ebd11dd66c85d7abc9cf279afa98922b99a5961e046acf21cc1148c70440a2926bf6e8916a87535c0cdfcf4d8edcd64999985194947afc9d9e0d36e942da44ac40f522d89d34ac802f338ff2aa31c9b52513d8c2f2cc6d4031998e2cd6a18bf7a2d8f65c9da704c4763ab00fa2edc40b15d995116af190f377c09eb6dc6286aa0aa9d195102ada565e38d880e1508548a4e9703360711ccafffd915db1f6aa4486ba3bb750a27f104280c2a6f2bfedb71ab353f2bb56bc74f36a1233752b202dc748bdd758584624b164bf7f30225f3c6b7492f91c3a696899d17996901c263ada3b2593f1432da9c6764981328f023ba1bd87c07196f3a480558f1b3503b6385b28c019bf63accd5ccf3d4b7c4b2c8f4f4934b3d5f6c52d4217451fa945db3e546e3a3eff0af3674a3a06863ddf8608d36dccbe6437cfb559252fd707e3939a54944fdc575f863fdfd08ac15a55617fc833a0bd3da10edcc51d03ddd5bb57a8e9d5c6da0f996a56e170fef1e3f85ae29154de0eddf3b583c7144564f1b32fdad6cce448c22e6396c3dcaf6e04fac5a1fbd4a4b1f16e0addfaa759ed90dbfdd21467af7c12eeec11d2737a1eba953bb8de104d4689d1af0a6ebf6bfafd0052e51610996225b5e61af8e70ddea6a7fbd52cb1cf1b699c83272db00528da1484bb53ac5d1ec9ea02f1465152c4d13cb05750e75ebaaf0ce39a52a846187f58c695b02e411b8ebfa6458e84837cdb83e90388b630d679fa2d31e02153d3c2c5edda7c3f03a2fa7ccfc846061a447c406cb99bb872e805e9a017da2f02cd084bef89dff871e1b946336079ed4b5c79096dbe50063c01a7f5d28be885e31aaa455b0dceb22cbca29cac0cbab0e7d783eb9d478a50597ae26ffdf6b39c4101283dc69052e8db9c0a19402041ba898f57454a490e7e4f2ad8cfb77acf59a5988f1dc17ebd43407ea3c194608d38a1e6e1d39c76981df1331008392d3b27565f61c038f7b63d20da2852e8374c98a01f211d0755b69da3fdeb7c92b7b174e98488a9cde5a84d41093bfdac4211409c6278acd044572266ebe1e7685c72054ab7b60ce531c4542a2dd2812375205bc5eaffb3b5098d4eac295fc2ead1bffc8ce326c2e903c2ff3d5a88ae395c470a90f142c3851342201f68734c0065725a39baef4a84c2a6a1735d026bb43d3c8043f6db1d0afaf38e048ca19f9f5b9e605f22a13f32d1aa2955a6fd3e824d013137f8f6a814be5e0203d1eaadd5b1b56e5c42e0dd26dc936e271e7d8e055a7e601c05f77cb64352bd91ba17113a7a2ea29ed1f7d165e94481f7af6a6814d174c999c90b88b5cc8081a62381516d3ce46d8bbed8de1c2051690fdc315ad13401f5342a4c9d374a58bbede93c47ee782a4bebe7b82264932e47fd22356035b38997398aa701563e41106c851388d9e75c94d398c26bb0ec74323ea5d1203f5ce997631aaab9db0cf89798c9a8657daae3765b7183c212aba4f39142ddecbf2c6540830a88a1f1dc237c5c557d59a7a132de08c1d7a9d2792caf07cf3bfd97468157e6cb5aae278d014e19243bd4564211ca2da4dbed3dc91ca9d595f538d60b855983b2dbf6258917f57f97f8d342481750dc18f8c2904c99f4fdc9b7ef66f3de26e75bc47caf340990d1b381595e1048952142116072682f2cf02fa2776888d34714773a22e6a8b466ef6907dcb2c04fd6077453eaa26013bf4d0caae38c0a2abdc3ef0ff11ad696c337997d442b8c7ea04bf70bb6a04d655c1833644c0479fbfdabd6521443ccf28b88b2c8b47901f65777e4e7cc5a178f319b8d215ff02b30ed0627f975e0d09ea5075d5d796f3bebcf933137aff5a5ca3195f42186aaf25cc7c26c9eb6d9e56be3f636dcc108a16ff9fdec1c6c56a52541dec3d89d6c2940e1b73b778c7654dcb299f2be16a8993123bac9c74220019de79007db4aae6d74a7f18c725353ac4894a6a725b82340b4c64d50c9c6afb87cbaa16d1e1be3c61cfe761add96cce7752f238e2971ff108e314533a3fd6c2427bcfb3cb7cc86d3aaa300a0f6d62f77d611884b535e1789c85bac273308de0b506b4eb7c8c1a60a7216e1ee2cf060c7b0123d37bf8406cb8fdaa66120c5e9f7fcc4c1c8ed13377757c761f6e47d5b818e5fa28377565cbafaffd0e7fb6837f0e54510b68083f2c5f25306059811b1073ce1221690452aae4cf1525574acbc159e55dcc7ac17aa82df0d337ae3d3843b835f297b7165a918bf1c0727f9fe158043a508422439b4687e1c7d8a866dc553c66ab2e6e20f69c5980d1a960fe41ab8840689551cd6b2584a9b99757fe895b1f91bea75585476cd7472f6be34ad757184b4024a213acf68e1061cc0539440ddb45801a67f2e7660ff33a4dd14e6a24ed08e5dcecc6d8701565b04303f79b3226c1df7e589cdef171d2ecd6e60b120ad232f09d66c0771c22401cccb0714d016008ab4aa247693c2b3922f05e3f72640e5b2878b396e8c6c69eb3156ba278962981e9c021d8646f9b7339e835e59db23017b7ceeeaa12c6f1a67b5b12c35d7736f667e6455086f0270db5787b0380fd9be25ea534e663ffe6732d29aeea29fe958ada37736c6523debe8385c46e155da0bdc484c82af4be8ff9d2859c33e6f88ba9d297edb0943620fa8499b60dd6a2ca48a8c228d793b62954c37504150e00f0d0d8977e8ae027fc077ed49ab0f9278e336c0942db45fb16ae294561525a47d4dd6b324bdf0525fb4d034f663d60f4044c86d6528e9c172f7e91f1e247d768d6f5b8f5c87e4cc0f357c229124f33ba1ce283e17e14dd04748645d1c4a5dc7b4cf3f449c606e49e18ffdf8420c913efa9b675e604580858d5e5aa9b9f499c9eeab1f02f2fe271b24c2305231dc9d125f964e2144135f6afebe1495e23fae01c7c05ac8be11598f70242beac853f713a80e8acd3fc0a9c95741813b0be146be1dc7351918fabe9b3143bff0a47b6e5d5008aaef4b33d2cec3a91df4c9f4450197bb48c42948ca999a504c83be4e1461e4363c73c420437f83f5f735833f4db681e4b48ba771242d1b4f21d4c3d8baa1b2cbc4af413e6bd511a275d251bbc63eb756ead25275722a47a9b51e999a49e18b9c479bbd1aa69fc0596e46c38f835c86cdbba708a03207b117385d7296411bfb85c589a5a3d0a5ce443993f8cd965580b402e3eb1e647183a7b59da208065ea9802301dfdc4722157424232ab5717a02a0c25148fb4561a58ad670f4397d38607f98691026f7b3e474d8bd027f84c75542116c1e88fb7806e766f2b7ef57cf06a431dd3e17a4c2a770327519e42d18b35493cf03d709236566aea054f622f5b3cbd3f048f311730b99ffb068b752a2b93cc89d98a0ea8ea1ead0e69e74b7627730c54061a8738d4752a5452883251c5e030f5a9f7854010a982dce2d0259f180255f33e30dee96df56fdc723f166bfde83d95ab058c34df17cc02212c69cd579269f0acefb6ab21d6626c9a3ff9a259f3015ba1d064f9c8e4e106ed5e8f458eae906cfba8802e943a36b0a1aba9e63abae9867ceb4511f90ab25dfd14cfcde8a341a6c5255f989103e20ad53e86ebe9d5deb6511e3d6a2ffc649b0b9d87fb77929973eb07270318586e19b716163e519aa63a7c282fb0e89029885b006a929a7a4043f940c5949a63f1a6d1c5742921cb13b401fd00c632a435b621110f31aaad9b25984210de4a8abfd8032f7f241a918df917b159938c7cf151f13122fccc7f1f5b05ca7734d5c076163852097ddcab0364994037e876d3fc8b8d3999518776fbbcb5eefbcedcf20a554f659f595efed550577407381ab8eeb546afa7c7b1f53c20688ff4a00af64fc432c203d3830be5f144c7bbf01e754d0ae3213c2d44539979dbff941ef3f045e401c84609f9b33bbcd2d94e4c4a744e0bef7e1e696edebded6520fa0850bcf128d281bea47550e01cb197579fd80b3de95469de1091361662df5518c963ae5daa3f1d64b60cfb07e3ace059f119f555ac976ba72e5e131edfed9ad643f09eeb04c37a0a0fdfb5e7ef30815cd2853758190c73491ec48b489fbc25aa270b961735b2562b977898aa6ef53a9deedeaff176677633eef4a265c784903ac4530d85f45bbb2919b22359154be784024c0207c67bd7140455c2c9baa589beb7ca89465579e19889af2b18473826a5d4beb359d3705bf3899a104e365cb9711c99d33f0f9399bc3c8f1f0748c5d4c66f71dfe43dcaa8dd0dcd5452e2b14d814936e0abeb5f7f13987306236ac5a94b1a639252d19fe9e6526b08d645a90c2e6984c1f2aaf52163107be82e8b38b11aca5f33b65151b4d43b3488853a281ad26f836aca83dff679fd88c1ef14e39ee4122190834a4fd9a69d8d95d1ae895e30bfe0b350dd45de674f3ec437541e788cc1917f6f4dbe2284d48b190febd51a06d6211ae73d03711139905e12bfc50eca802a8d6dd0d47428dbfd7ae737ae1d3b0e9b3662adf7a04d319594a128714d488eac0d2a9e83fd8e5a2dc7f9026b4ddfd1e316beaf92b650ed190eb7086574111feaf55cde8eed9ae6fa6c5fa14a6a801167a94d27bfe361242f77d8fa4dc4f1fa559f67cc5ac98357560649b87411cd439d2c1490e1d2479c2f0a0953c2547173d40dbbdd6ff06011f30da6ca308653628e4a9b6597eb7556c2ecac0b5bd120555a07aed1e8fef4b34ebc5115939ee7b17589184906278cee99de3064c59fb4e81fa6ae589c84fa64ec5fbdd7e0aacce41600c3dfa3707a0c78edd1f64ae7b2c9138e2ac1f7d9a284f9a1e945c96f87676b0775d35ea0453ea3c4096d78db8ea4e23e9e39acc4545a3aec3c3e2b0eb9146e622086f428ddbe90fe515ea9004099deac46b95f2a9b607457242fcea8add2bec1eff5185921cd11b83429b34cfb7386b7fa5a5a87f9fd2e2ea95ad0615e2508b1f334df1471495924cbc86eed6e4f0a2d0913e7cd20f8be04e5d46e27d88b46b9195ade8eb4daadf896ca6bc1e8bad01b3b62742f7a443aa55b43c984b595dd784b5465956e50a13a3f29e12308feb953546f318c227195b60450530e98d4c373db3adf0b7008dd4b875e0bbac9865eaa7984b82d611edca456265a171cefdc8cd5bb039d17e5e8634d526363febebf3f022f475b2b32b2dc52c5802ff1b1da423e8f8c60dfe6efcc68988411ab9d1aa17c33acb41fedd8a03fd9f15176e1ecbf25021c14bc451c60514dd5729671e03e21a6094cf3a47187f51a5f162a4e7804828bc2144c2bb337dfc3bff77d2fe4780c4f4b98b2827283bf286d3db50472ddfdae0209d46a3a4a41837720f0481d5be3b14e24ec7f4c1233f8a4dd58b154001aa261c105790e28ce84210b52cf0deeeb1088dc19738607739c35eb79e44ca4fb618201992049a3c426b045aca48d7a9a974be3d5b31d819eec40f957ec7f4ec3edbf5731fdfdf308aa3e4847b9351a06bba87013c925d54e03c616efd1511f60273a05dadefbc5c71669fae16afa4d6204d70ef80930551e7164b447ffbc657070640f63c4030d902fec015852137a53cdeb427fbd9c821278f3eb41761e6f8537a0e537cc32269f0e848d21aaa17951885675a1702971b1e41ec91f5fea2f6effb6f73fa9b99b1a206e6b62b6c96262eb0f9eb72f95b9505a2a73ba95a01eb740096dd67e0a18781b1b66382f5eb3f11d1851f49e24c32cfa8b97f4bc22c94df76df3a5f1aa46d4cfba62b9dd34e7944fa04216791bc2f1ea9278802c62990eaab348c2b7ada7dd9bd021725ceb19adb7b682f149dc3865b3bea71f0ddd1aa47aa4fe04f60cd10c8b2af5e56b4cae48624ba2b42de4d0bb63657c19d71eb10864e66e96a35d907eda9d0c70b672d846f4ffad70b706229e8f0e73be23aa77d3f9c19fc1d4ea492116d6ec1a7365ee1a061a99e86672344ed59d9a8ced5dceb3fb1deec7898946e0c86a206b06aa36ee4129928b7acf22ba96c623b3207b10c50ab1c564e9f467036bfac0a0bb98313d193e13e5a066ad10ae45606769e81d821dcb01a7d0508b0ebc3cb83980fd6b9752924209056a0f577843c6032c1e6d6c3ed2f2456739b68a2d3a55b39f3ed54804e9f253d456ca3f61b5c0b2246b24c7f34b2cbb9bfbf98ae8c9fa447a5b0e1396175a1266c6cbde39e18f45ab36f480485737e3ae2c51d9b56381a32026ccb09958c857a4d010ea91e7dafe023964d8f2437796479da647c8bf29d4dac98e2e555d3e6a1194ed8aeb2d36e1825cb2c6d37d521acc04b34b9db803f0d76c5357c4f5c733b6f8e285c5b32d067346b63be4171782e75fe1e2dcccd000e44faa740066ac933253dae24ed1030113a0459acba9f4d721f664631880cb3ed203ee6bce0752751e13377dc233a843c9dfcd164c7febe1440b539d73f568dd329776fba4f6afaa0455bc9b7724c9b1b086e3ba8ea78749a100cb471bc1521e1c9f67c8abc8a13b90ed092a36bca626f7e2341ec180df9f1e723465a1b1a3771f0d26411eb2a4dc1eebaf8e068d1a5ccf6b3a970d51a7d80d3f717f9d2369360a7b89d111a6985918b23d5469189b31b4d7e396feda70924029925151959d4b8dfca025faeef3ae0fb159e36b5222cd64269ddc21a5a27e696cb4868dc489ebadebe39a6840d896f264d7558947c3959cbbf59f98eaa9493ad320ce3d1693528bf8b9a8c9b53427b719b99657afa11c5b84f8fa4fd7c6e9baa040d693e6a055be3aa3c22c6410cb7bf404a069dded8efe5bf7fc004fa14b1355fa123c1d1834cc3ce1ea374666d14f327e766b749e03fae8d5b8bbb5d2b20d12b2a8c66cf470d634884e37a894c715889dbc992dbec72721aef35fd5d8956a69e6d8dbd1f94a5ee48284c4e608ebcade9a20cafad8a7be14ba9eaaeb4d47f0e7ca8f72bdf12c4a57e607c3ea9c78503c20f4f3c30fc3aba48a06243068b9694dd94afb1c9597ab8d347e2710076d12cb43c5df546bce1672c4737b6370f81dcca7d7be973ca8d419c232561fa5bc05bf593a5821f14e02c17fb46385fc19ab0f478f951d9e5ed56edb4314827b4b27fce6d356f5dfb44eeadf270876530559fe87f7723faa1ba85ec5edea7c7bae287f38e1b7c882341c830855b2d493754402aa54541ce9e7e5e81f164b2a99a94f153a5dbcaf4d7f3a1e138d3e84faf446e6ddc043410b3332264879c1d01bd9b5cb057e3a13595b8173973fba408d229b054f601e3bf1f40182a5a8b3df3965e1f837e030e5c4eacfe29db4ef940aedca00aa8e575b3862522f4e95df4a0cdfb1fd1e89716efdcb56fb9193facc964c061b794114f57db085e43bdbebcded55ca242000a621c13a061755f6a169dddc799efe92807de8d490d372a6858cbc4cb050e5ebbcf7f499fe0260985112ba89dc525e446537f831a84ae51e9614b910a2c20fa68e0aa1158d12f018d3f100f15d3101eb2ee93361a739984a8b77dfab95412d1df3425f9753f3ce060bfa321a67a3bb06b83523cab9c0fdcdb70e0e19a9e43661740f78936495eb4eb091dbf088617972b1084e51c97d2cd0e7637651417739ce8c939016c011bfb63b7cce6db1702d3f9df50e143cc7f02d7267875224c0d88b3a2ea90e72fd5a791742f0da4a3636f5bc8c2178d83f8d1d930b2757bce35169f718ba137e6acf4a8b8c4fece9e9847f5a908edeae771d899a1409d8342af3b8bf2853bab234079a00fcd3087862b2d6612f86d1994b1af38d34d4b94ed4a630fc7b2011622e5404e760cb5828d890e50a3c33573bb637b256af0b89524b952ae129127c3b431ff9993607ead40bd81e6de6e6f5f4e2315366505e317205b1d5fccef9a752ecc3ed489b10bc8462248f77f108dcf1293cda29425f29f23e670015c3e9da962f4ffe0fcaa984cfa8ef3b17ab76c44697c33d9fab7bf14177f3ed6334f209f2114388a903bcce27f8ca9852363d994f668815df9acb202729f93f8984bbfd2fc0572d628a068ef6a123012e8a4b6d9365d9ca39822b3a0e55bd1edca704a024eeef184fa71a5d401019d6b0cc3d2119338b0b64263a85e2e706ca7e3d0bc74810319e343ba58027ed01b6f898be491796eaf8c12a0a246bffd70a81d108de25fb5a5c438ba5caa499c068dfc9f4604e55f160bb86f8266ed022e6068de4988c2f50cc8808609760d9ae35e31114e308f7118ed1f8f4477ca8b2e143d0cf9d6e00324e40866b1cad9ad119dcdf0911b4022537b3e0b6c695b4f3aef86ad5bc5f5f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>解</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E8%A7%A3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="42153575d422283d0619cdfd920c9b5272b1b75dba792936f3e811bfb4d514b4">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7aac8f69693102ccd60b1ee4a04782ebbdfe9e00d54d1bc0f7c984568b717ba2edf03281cf4531b4b169df2cee51b13628b72e7509081db3fc68d4053c7cd017717a4f13becc1c16d8459cb21ff83d9058055e819ba284becb6e512fa03da1a990a1e30cf69a5811ecc0ad663fc7e5e7eff4b3c198d82aabcc76241f560898871531aec02d59e5d31a349855424b5c1b8ae7e285bec74003c9db88a8add9bcde4af2dd85fe4457590641815754dadd6da62c3f73074fe40cd1d6bb592d87faaf4f922ff1424bc9f38806b7c34ad6524a5bca1780e6480d5caa4c19f569dd4616f5cc46a55f2b673bae43d9a4c9161a1cfdf77dae9f89b1a9ad716c0d7bd78f8b2fe5005e0cfb4ff3e2b077956f1431244d0f589d8a5b59d789d4ee2189f90cd4aaf660719cdf9a1dc494c14fe756fd3926f5ec1ca80d1df2308019e85f8d70d0ad8eabe71e9366c1b3377ea84cde9aefa17c0d6cdeb6372eb29b19858b26c4d81512011bfe1dca58306c54e3e4b31b739af0b776607e5b8dfc1a33730c88c27740f8a24bba81c3c1c0d53b1c153dc40ea1861080e40ea42e05a47b2155e46c0b1c9a7244a31ce77be1b68a3e3cd1bad6624f2a7050f1bee4aa10e76b6f54960d7709406aa5b2872c3902fe2a541a401c20794aef88e27ab06fa0768a7f8c06a47e7f04b67431e72727ad71b2344797390bddb56f2e9328f860cb09feef4174db7c1860dc6e442921fa17cbc1eaaea8663806d9f9e27a40186f9d2ae096f437d42314c4581fc565890fc336dbdf6bcfbb99faedf51148bc8f2d027e274d0e32e37941563210ae1c54477842a6588e5c52aec32ba4b53597b96973c1a1e23a980d5d10cc615a5e085f5b1863a553201f822fb7ba22620ce62cb22be3f2bef47964f199303dc0949835982dfe72902489550a6c9aa1604448da4f18a4ba5460db8c01cea4d9307dc303cf9d8624bdedc5064fb090c8a290725b67e810c5381d33645a97235b2e0d74361fcf3a75fb27935e84b26abbfdc9b0535216a34d739da6581b91c12d17c2405cbb4a7288c14bc1a035c59963bdb34b93ecb069c3eab3c1b304c9083873f8e581bec3effcb4839d83e6b8a5ca2fcae71aa808c4cccf7c4da9a241cbd1fc7d957e3a442dc5b8e7e98a856154e20c3831f72bee25ae3171b37b39799533dbf6c92a02b52f174827d7dd748faf4636598875deddbc88305cb67fcdef61b18b64226076b9845e98e0ff0a374d2643569f3ee1addd0e931e732adabbe6d0350ec4bd468d87b103001ddc3eecb0087e899b6bff4fa0c4001a672aba95c761c514b4b132536666b78110b125f7854cb15cdbd5e286548a10788d80ffbdd8687c8cb3c24c7e2d3b39c929399bd2f1519deccf9491917a381049ad3ff1f50a79c13fab8b78d0c9690e67eeda7897c3d748e99edaa991bce70959fefaed127a013cee583d97cc7c2712421624a740ca71de0f7db6bedbd140ffbb3ef8f3c412cc7bd825766383cffe4c8a66cf90881c96bda1c2e585244cde214abb4c17e3ba4ecdf857de616002f7600b5af247a9c9d7eca5fe44f066ab04d99bbe0c0be9d2797d9eeccccfedfe9dd9bd77fd76f7b90b79b203dc2736f6ae468c26cec20ce6d80c98352a72496286b89153dee3c1fc6f2609060cf0f0a62bff4e357e315ecb5675cae419c3f1ab07f1feacac4325d05c29df5ff39650d0f2b7b67f4cb407e4befc1629dc5ee7b61a55e83ca670c37fc92bf00ada07e04ed7cc65ade91037d20dcf30a8c84a8e697d6815a82df56b81de02b1d32409667eb0cd21deb348ee625be182c0959785cdaa2d4fceeabe26</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>薄荷养护日志</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E8%96%84%E8%8D%B7%E5%85%BB%E6%8A%A4%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="18065cd6b2a51b08fcf25eef0fc2fd06a1605d122cb000cae279f3bed1928339">3bb9165ff5e6bbea951b9b42679dea8a305cede40e7ef5bb2a1eb3c75cc72fb01152df24b6bd0adf15261f2b20a06ca4e59f137516019510f60cc6b528a7ee4bdc161aa3150cfd156e2d8ef61be46c84fc10ef7e59ae427029690805cb7864c90d775b2cf6b66661086dc3f8e58fd451491126ad533aa6edd183b707312b586e533df5640f9c1357e375480bfcb4b194c717ab1150d82b385ed191576859a33222038e599f5690e1a0df47aa6a13e80872c4f94456b25cd1dd49fc55e97db657b25236cd0a476b2a95d244c9d6da6ccba520247d1e6a3d31f1d4fb7c36e1ee4eb6f318010da9a4cd845f3164e19e88a67ad6be4eca9636c7bb44aa5375bb4e22de0047399e091d9a6bfdcc076ea4cae8c848d405871ef27b97c8d1fe7a0077a57a69b5e4796af7a12deb6a2b83ff5128328cfef34c170e42bcd28be8891310fe6fe7082eec2a5df2d00c22f8881068725f55a334a951860bac8e05c7f0664743c30f491525fcd7a1fdf2ab2c0e4effada5ba07b1f3e7039c1783253708f89515898913db85f9ca0d4edbccf6607a43fec848ba865e4b4de30a151b6d4cbdfd7b5767fc54e03e9830fabb66d9eb5478102bfbf4f9b4441a2bf763696cd84ebda00570e13c63af26a0fbae0753917f970b144538d00972cf6a64305b097259cddca4fa4450ffeac6c72efde5d1bb53c468b91225fff8630511a3cfa1b497678c8e1c2859877737cf257fd599495f5c2f3edf26e3c0603d478f5f9b074065c94f2fe6159f03b85c5757ee07fbff7da4261ddf69e1e47d01ee4955e12766d3a6d6214ef3fdb55c6bb10456c742a653e6d408e264e483fc71b62df352746e722edc0be3eba151f1809fb74eb84269028daca79fcdecc0512bbedb591a0afc06b0d1890efe6c000b92885b36cd61f28d96d665d32966d0186320c848b04401f8f7955551179efa0f13e9c9eef7d2a3e2ea9495b8a2313163aab1b330c7de348d50c51279888e0d398034bb5bd4e77500a612ba569e60405c248ef9db944477403eed74a862cb6357597a0f5eba6598f7043af9556041cb5668fd6d02dd1083b8a7218ccd571c8c56504b648fbe65a27ba182426aa135a547639c17296b3cdac193729bab33bd650c333c6bd02d735ce42b8af454b7ad7b615936ea342be45f80e9b659f69352c0227e17d7c9c448d281addd4004c6b0edc27d6e698bf18473dd488e2084af8cf65f30f82335041fdd8211e16c8b87eba308288c4eb354500334fec2684cd6fdbf7ad867245fc4aef65cdf3367fb4e9d25e4094b6ba10d4ff443ab0503458f85c5090562c0a2b7b096939d54d3994bf0d767a87968dc3699e45c3ecd55f29ded0c46a36150d869b7d43b70bdfe22f500f3ba16935c89299107b8e5872b8352950f43db98803a1326f42e46ba46bbf662140b96fdf1175139bcdf0702a491aa2b9fc053b7f069fd00acaf09676363c32cf3d8779e8c8e43abe7e77676e82c693c5ad4694fa971e3f9cd8c57f9095f5b0a4cecd21228d1436634d72395ffbb5a6e153796bb7f7b0a34ed915258babc6c9864fa554ca99f19e78b36e9085a178d89da386556a16ff2e6b72d22d8882ff9c4f872aa2090ff6562bd606481f1caa8218b4684fe25c35db20ce3be6ec8187b5106b9447fd09229e197972f7ff28c4b81413405314c275caadbc99b5014b74847ddd856f6587fed287d4e8d42523f05138c9ca7d30eb9a02d0589d795b2457f2451296b7254632eff9dd6a85ed67ab1de8f10db55350a4755c3974a800f2ba01c4a204774c8f14d67d50b0122949391892e7f269d58a73024539ceedb90fa8b93a14ade1fc63a424dbc33a03fc26eef1d7383e36b1c745043fabef1e18a0d117396434e3db6a146bf3c9e74bd2997672d5eb316ad433aa8f6b1925feee569b6e86fa73e3027f8f55a97159f3db2849855fc869b3c8c360720b7ae32d432354bb697abf471232f94afb726e4c51376b2131d6b2a90274e158ebc26ee4266a6b21985a9c7f2a09c55749a5c0c7d88a6966f9ce39e6641c9b4b4b1cb7a9182a8bb63c4d5bf55baca05abfa397f93a611a8dcc6ba012cb0461f4337f23b36645f12c322258ec092f716ac53b7ed787ee1b5727b40b7585c9b82949466339e1d5dd422c2d8bb5f89715cbdad8314812039e7594a1dbea43402b0ec311eaed9c944a5aa05c78797b696154be0106e689e1998dfaf1feeac2b7f08489e864c6e0e8a8103a0c1b7c1a1e564d02e9f64114f4c4cd8b523cce572702618ecb79db90c856c94681c37d99ef5d65efa3efc44938cf4e3d3af31cc0de24cc509373f9fa05d5c8ae5709b747c9bada5797a8cf4a2aeff8ec02da2845ca9e8d2d0f09f9ecd83eb0f72d4382078b3a8ef3fc59e7a1d2c9ad1e5ba607fa1f557030776a11f906be1530ba74f647c55d50c6faa227981a116b7822cb650b72be4af5b03a0ced625cc41f3168256de910c88af48e999fcbece4cd5e43bcea43da0c3dcfc5e8121b46f49358dc8b957c3c5367b4f5e6ba8e445eadb72d644154285ddecd686e50e2dcb8591f868c863c0b42c8f3928cca51e912e80ca72ad85631fb6be1c157073d52d2e26217b2fbe1ee5373e1c3eaca9bdf192bbb729a4bbdac0b019e4f03e022cddccd4124f2d7c257b9d3acb118d91c08789701be50d7be5ebb45bce97fd742b485fa703b507a4e65380724ec5df44d1579b579e0a6dd995b90217e53dca8e769d6cdbfb3b51f8e2fd147d85ee636a134041ee6f5fa6bdc29ddb624c0d82203e6f0731be9b162bdb96811935605f305d61412d2324303b41bc9a0b29f56132dbaee8f4992d4eca84437bf71b75b994415a9bb03cb157e9eba0b6bdb1e78adf9c1d75b57e964f8229325998421f0eebe571c466098261945efc739fe4de164f2379e30e87060c829c1da70bc43287aa03d8cc5fb053985ea8263a0fb35ae4d06029ae177892e4fb69ea5da301b55953012d0664b9a01a596c070c0d8c662a167154e5686b93646166389a9f52ed3bfc949d9d5bd96ef78ce90abb8ca860102a24a8d3d6467ab4c2504771fddaa6c1cb8d2e0bdd3e303412c005b701367d4c492c39af3f9782229ece5f0153738c80a79d47ccede652dcacab0ee629fd4941550848cc22bfe4f593a655ea131cf56f069398e500db6c912b88948faea6ac2d03affe49bcb4f437c209a4826f66d10fd191a6c3941307fd550645a9a0382f72778f552819648909559cc509ad0d99e0fc4b8feba0a71cee118c0ade235c6f80174ba84f012fbdf1c64b17e4e6b441c9df2e2f448d57ac62cb08c40685439ed292cfa0a4c1c818eaba4a5aaddfbb3dd752c8150a5c0db3a5b9b60741a14ee8109c8e740be6df868d1218af8fdae6609694f3f9e9e026bd29a5db652f5eec68cd8499f4250c56c401491292a1bc91bdbff9ee0b0853a3ea043e43b67648175161580e84986c7019e9789b3cde6c8253ac6cb145cd68cff2ff5fa38f693dde828d446c0c444ba8bb95ea700a8dbb44c8ee1c3c740faba7f680b5b695a1eb0ef3c75d78f43e5e3d7c647845081712bd35fec2eba2c07dc0ce38329894d0bcdf2aa7f507e9137b5d8e4b1beb92a3f65b5c81d6dcf5b5f87f8183157957679b3415d71841f69e82a4be677cef7a0945344f89a4bc2172653cc4da81af687ef314eff2a1b7bd30e0516e81a86d3d48543f9780dc4cdd23810bef0a4d1cd414221b1d06a1062cc7662db58fc5835a0f1b54e201aa0a450eb6a1e0658f0087dd0b660d01fe04f7c8a6607923d7703cbb30213e8815e5f03492ec3b33ece967c325e673e1190522731bae955c2dc11793d2b9f58536e49c4052d13239b05294262c7f4f10a464fc57afb09a3dc5360ce2a399bf63fb335d883f85b6732c01c09cdcd56932755610facd0622687487c478505d0ca6f2ae8b99b586eedd1765ec2642b3a4877d6732ec7dac6fa7f0bb8bfd6f007e833e1b567674e683fcb4d9489d12853b0f368910a8106b2a3b90b4ae6fca441d443e183e931d84728d2f09c49349655c5a4c866b294b567141c602899d5d35e4b33b1cc34bc98fc28288e22f99cfd2178f46117e547bacbdbc7707db45aa90d4a103eccc0846acd1f33ca02d83e1e16ec6cac120b70ba75331848574e4441cd6ac25e308f3461aef0c2236ca4eb8e05919e1eb373f7433884c64bbdc12555da6b106daad7cb62c743d8d59c1de5a55739ffe63a4d46ca6738ac312a0a44da9bdeb5c64dca7ac92d1c7a2a01e19c779b3b5888ca7b2828c82289f6d8e5617ea42fd6182873f81fe52d8c34ca91ae086ef6239b5e9a80232b424a0dca5bb8401f4def9fc25560a0686a89c48bd3071327b347e805e775795b147b89ffc648836928ac83c1b9fb54bf58e13cef939f795856a02623a4d9437d239f51c1adf3d9d2a96674a1205664ff133180361cd8a17572d8bb1008ed52892a34b7548771d55e7c48f1b05bcc5b94b7b85f90f0b48372cf080262ba35221c2794f50dc8f4d97b26b1e432b06fa8b9a755f9cbd3131f61a6b1907e0406054ca10cb514715b31f5e5d9817ea3b39cca4034bcbdce4f2300cd18fa6bfa7142618ab92e72d25c2a27c212328a82c49530764f529c87a85cfbc97ea768f85c997950f6e3b26c1faad42b2ddef1b7cb84d31d3ab24f30f0f040adad06fcc63571d2388b6cd0fe4cac7224e6a8af5e0b3ed18f64d5d7da173db420900aed842bf944da0ad3b1fac3c881b8423fc0df5fe978385158d706f0fff5fbb7734cbc34b50418b262adb0c5aa2cb9c2586752dbdf8884f20aaeee735a7fba5aa8ca3b15a6cd3bbb77d4bd6df98c39e9618cd8092dca5a4c4559ca8cfbc895098251f13317e060d2ed399140684e6938f232de433629f145e6d20a6979979785698d9be99a81e4171a2a100f1b7e59250ad8c79b1e589958d35fc0d0b6ef27a11bd52f2d757325e95bcbe362518fbd06dbb62bfec2cf49472a7c6e69afd0e439799267db90ae87442948d8f4de83c306ec4f92bb94a27df3d2503cc121fa4d9f718ac2a231e4514f1b9bbbcdb7e6854c2c39a6231f1bf4a66d77e3c6a3808a69e81db31881ed4ab17a2c11685af34cc3944796f5a20f9055e8a6d3716640bc30076d31b1807a1006a7ff10cf7b8bc4d7e7a3f68863334c19151758d148295c2df387e1cb605cb1abcf27b27960ad75f0f3a5fe5e7e124a1447d2bbd61eaa7ddad4f0372eae3b960838246812e2c17d5ef3bd314d347717f874c92600d3a3c8abc6222ffc0e2fdd3caeee8770cb403e2c86aef93bb38eddcc3da7d90df860d97858de103cfcd9bf5064d2c1c469987bbc579369fa8ba7c35cff347d2bb6b5617fdb877c027d187bcef19ea8beae646824b5408703e95f682504203118de27be0ac6f3650f16c8c5f9aafd9e653d9a81bedb7e1ae84c6f61dfc9a55a6b009743b65154b087b2dc3e9f642a096b85b0d6427114a7ed9fcceeab1b745e845dc89fd59e6e2e58a792f0d1c501d4b61e97c7f28f36a07584f16aa7bc6ac40db1b5747ec2eaf977abe8e4918bea298bdce024c2ab1371dd96cc91d79bd3cd6a51859a7c85bb20a47851e11009c00533f65eb94f86d8f6dc085af467ef6efbfb6b2575c4469db1ffd0cb3ede08116dee77e07daeb228112105027ab0d9397649087542e709ba8008a8c0a6e3694ea2b2e08a43708941685ed6e6845697afab6054cce6497e51a47018ebb8bf2ee8a65ab20f46ef1cab621eca1d7320194c720b64d7a3205e07aa3baf5dbb2bea8aa636c6f670a4c2498afb876fcc0a6d1a3f27be5a7a608cb4092c3b46f69e37bebc4d05773aa491795053ac7c0c2776b513d68aee4088bba9f4962d4774132a7f5c61fe5c10ab525f05b34075272936c176b85bbcf2d30d9f5b8090a98d99495a30203ec37af146aaac4674cc3d0b5dab7628f1677041bc3e322a6223944791266418c1c09735fe7129c32fdc416ff04dd5f33835965d1e2ca42a2be83c9a05dcca9ace90bdad31e453e748e54f96d11203a698ffd29bc0e57efd077263dd3107a159d6edad21c133d0d740e5510d4673f64c63c92e766d2f2667ae50483c8490cfd7139231fea25ae91572cfaeb5bd498f0fc08f7ba1db1f301c6a8d1535820bc474ad7af99149b3e469d4c7099985eaf6498d769df74eb090bff29089dd68066347f7c33a33e122c7ea6641e90e8c7aa10152b5eb9a65bae0ad0d8dff6496a938938f88dee6cef73b604d1c3f80cf5e74ff741853bc9f1c85a78b087f72c4bf9b4ab6727338c1579d833cfae16aa22e9ece935e4192359da8fc118cf734918b86a33c3c4fedf2f8abbbcd29d348355e298fff115b09659997afc622cb2198b172541ddbdac04fa62c27a69286b4548d6347bb7ab276abc3724729004667743cba34a1d7697bb324e43d1a912bfdb65acb234823a9700f6bda25e903cedaae81b50e95de91a84d5d9eb11ac8449b1384d691ba6a2456e72ac96801cc7a89e43531dfefe9995687c4a5d7d4782f5a52e55806fa95f23097e055da9244e5d8e4f830188feecc89e6186bedf40f4a24795b35a34c9d64c224dfbfb594585fcf3cf24197000606d52fe77cfd233df962fcc43a58f6ff5b63697bfeae56c32a5dd9737cd3f69b2519772f17b5cb2d375ce394b1e822a7bc616497f6cb769fea9aa9dd03ac49f6d375896e5043a98bfbb3682068317eae72187a56635927fb6dc89f8f4da1b8db5604e51cf286ad56445a2c29997d592e0bc124f964436628c259a7d43937a0ac20344dae68d0f9d6cc1fbad031645741de8fb5c60d257b590fedef7f538ac6c1214239bbc5a26afd9f708322c28b6b8c6c4ab8707a5bf1125fb4717381c4a2c4c2f4b066ea7aafa417d0ed14e73e6725b230d8eb71122712140af11ab69ab47a8d89bae05e338df2b2fbbe23d661cffff521d359923be9cd5043b14c9d898cc94c44a3a221e75af43066adba6ee4ad929b183ac70af9756b18d7d83567daf7cf2840cbbed613767b47f53c18472ebfcf722936ece05173c362d229c5dbbc65001f5f21127cc0ffc3080c5640ee8252a85441b0f3aeabd76c269c174580cf9bb9a7668f28dee7c2adfdea833e85468830796faed7e84609f342716ffe378c899262f9fa7dc56e943f7c2d495388509a44ac5a4a9f69fed4f9b6d9cda377ddf21266fdbef6f1786e3a9f5608eba20a3a14e59c7fcdf58073dc6b73e79b88bb1a2cf3f1ba2a1d1daad87a200effbd607079897a14c9c7cb020926f0d77d8d616f369c427dee7dedbff1e1bae4b401d87ddba6ca42ec3a7becb23d1be2d1edfa96b652b3a4423f5ad56ca7a90c8d5d8ba6faa034996040e33a5754197543343cfded563f7ea9569e48c6f6124b6789b3e0ba0d1728790b5b9e2cd4d0b0c532d194aa070f5714717fecb494c45b501e231aa37f45df4ea893e01154bb98a674384963ae4d7ff7e4ac8b517b835f16bdc5233ebfd58299fbdbef609b1fb60d9e0ed72a1a4dc5e56090bb9875a1c59cb8dac5f723521c9c4d8e95cebb6d67f5768523fb92e9df96df27f6a9a54e215a1f152d8ed187bbd4aec99f4faf955cf8c34f8611058a6f36a556bb09a667bfc6838e1bdc17748400ca188d4dcb29437cc18a2271957820a9ef648cb735d1ed5d4db215f3caa22ba51b99c57dc63915edb523785e7b66f6dfb7722644b2a2ef80e583ac66a1712f3c63996d3aaeb38cb6a1c202edfeb9ad6470142f08be02ae8b64ab341a61ab736c219ce478c0e20190058f6f8f7d176b9cca5a5e986a0fe95d807d90304afac0ba0e4146cc26230dd9bfb04b3bc1128e2d12bbde2ba526795bf3205f95af8bade23d7d05de3d35f6b31b2f4224bbc0a64ff00ac0c8254c69b1cfbb8950dd0ef5257a185d80dee47f79f63afc65767cb00da3f05d73f12b0c53324382a4f9b127cda4697e01435504b394ae809638df77e731c6890c56235f289fbd6a3126aa8038fe8c8cdd019c046af3a690ac47998a3172b78ef045aaaae80524bef73b15107a8cd32f1a9f4de606e9c19d4ec6bd042d64bf08533b6a3552e36c84e021a9eb3255a88c22457067802877dcd92b02b49687b0916f39707a6806346f15932d8458c3e31dfefde2c467f2d978c754dac0b70edc3eed4d5f27a03546a90d461572c1d8c8701e6e8ec7c0b1ab9786670df1e87b16e840fe12d0e1370529b358e1992056a302cf20c59048200a3b79b6a9ad84ca0f78c12fdb4aff99a2c8dc26f4976d560f39ea2042a6a1e0ba305bae22767ce00591c2e26d558f787fa35cba3d4c1fb065c87d07d3ad5b3b3862cf559d633f6f264dcad08441e79abbbaadcba52cf0b727f782b0a86f8beb62a5ea909da2037e168b3c62fce423267fd9cac00293f7361e611b22f08f79a4bf0e26062b7b5401a5303fee0a5b9046a2a66196e9493982485325cd432d8314791b21fe477d6324ad5e1251f531d2e02ebe9795f9dd0529e6d5df1444df1f379291752f7e03f83d3b051a66c20c1960a2507a910dc15aa783d8383edf6a3a126c7a5fd1172bb8f4a6aad040194381bf79c7275056c25d4e7fd774bec048727266d10ad4af1ee15d5caffff11ebaa28f0b5009b7afe3c3941f33942996d6e4089b46f08e492a4a625bbc539d197b8bc9e9d14a099f96525d7fdda9f976d2ee694ebb70491667bcd3325ac2a2a2b1e779cf2561210876b00400041404f76e3d63ae0ce8f1c91db1b8aa907782857041abc6dbc160ab8d9b43487ea2c547994a991bed8140eb0f327eb4c485e693f84cce225ac5feb1aacce83aa32e5ac7f4fdbbdbeebd42f64aab2408fcb57ef8a39eba5b12a651d379d525eec687382781ec5539d0f0a396d36a4a1f0a64bc72d1b0798ee62bac790b0b0bbdfe612fd0a017309cdb9146b3f48256c5256808074923249b9ba4426c57f17340117eb2f43350bef33bef7da37f958952f1791f8e1d3e9d2f1d5a24bae398acd2a95010a521719ae0d0599b9e41969e4e99300263d54524ed37c857588ff4041aeff06b5a4abbae6ade3e657fa81f6b724ede1faaa80bbe245edf42a43dc31e3af7e4ac5713b271618bfcd9e3fe47235fcaf98ccdc31a371e3fe6b9601fbb60c856afba9745a35e574b0b69074648d1d483df91771a70837d91d51197bc671be0dee262e2fdc214995211af13994b23dc7cbd59c367c1f9a86519480e47bf6ed35129b9781421d6f331c4c976598592fbbf5bdcf3af53b8b01a5c581f684ae2d35284b8bfdde8d148593fa70db9a5e197cc21f008566b48418f4d6bc63de7ab73d12fc2fb59b8574bd42d3cf3a9d223cfbff7dade8e7c86a77576efabac2b54133d7fcb470208b37a908d9918d94fe006f3163fe6ded0609a7de1e65396fe4ffd6abc35833beda6be5d939b9f0546fa534aabb49bb0195700f99db85f3adaece84414b56cfa0601600cef9a642a3ddbc8455938e8f2206356e9b7a074d0fbc00b55706e8bc56d124022b9cd45b29f0dfc3c87a3bf6559bc03a45030b4fcae50e3840ca04146ee5c390b492d79340768670054d1a31307325c91695746696d3e4110130436f67a5d2f8acd7fbef1b19d45c07b45013dcb830462de69212e38e72e4466aaa5fb93ab6f098ab6630824973e91572b6b8f2cffa2ace8456551945c715e25be9b6a76111d39ef4c7e6f8883ff0cbf4e3c9ca7f2fa13b500fce151c56d51bc10c23bb7560844ba37af1b949c9a0cdf380f51f218188f244d1992a3d49f17f768a0ccc99cd368db375c8d1983154764319ce3d7326c1719764cdaa246ebd377b7998237155450ab4305e5ccd57a38303a4afbeb92dc6e52ac55863cfa56ae2231cd25665c122fa02efc4e15cf73e2b1b9a59324af373555d7a01e5225d760c378b5fd7ace7dd62c34f5cf5664219baad6e3d0a51b8b28b29a82b4181089f6302248607735e9b4aa7ce9e0f016e986cb4e83e284d6855459b3c6fd17e54150d24835a4e774f973770302ff2553571a0e70fe7d876afb315f77cf0d2fbe5d3cd3ed1c18df18dc39ac7805795f7b4388cc55b6b24622ef777c69a68036b5f2c5c4962d1f0ea60e74b555b9290239bf0fc9db2e06819897ab0f5d3be1924b082a37491d7dd6347fc79c0645742161c93b332dfecae52b61e4a7e1e3a87d8b639bf140c3f2110e2a8e6862eb741fc66065405ba391a324f8175284485d71b779991371ed45309e4b23a88b8094daf99a24ac2726268d106ee58a4dadbf7a2619f239a2c12f04a5af33c228065e702fae2ae8f171073be5e7708453a6e0f28a17263496f493198976f5031997286631b8f548a53ec83112ef114ff7f0b86dc07d8db62b271280a45ea6156380538fa5f129e2591979dc568183a9ebb3f4bb43f729b500d6a9da59385ad137f0ceb3180bb86869cb038b92563c9001d12a8a999d6fac23914c4945731107d997ae57a9fba29e16bf54f64260de9d031aba182668404965d9ae8c1ae3721bd60b174fdd2d5b5f62502705989068ee3b84248072b10f3011af88b3b21034ab8f1b2817e005b05680b8a8d5e98156bd33e20ae8fd17e1cbca0b72589e9779ba27d0bccbc73dd3348d30e90722f44804f9991ffb74e7e297777db88a63ab081d6bd25a76da5e0816646043f51d9b4d0d06fff8ad91dcf027cccda23af4cdc24c07b98b0b58167b5ca1d88e3b4b746686100636bdb7fdb348f39a344e52603c4ee6ed88f44f78ff6d1bcd0b3778608b88d326f296e7d32dced0322b5ea5826d0bf6936e5b9d422226fc47d6f68fc5e886aae1e6dfd0b7fc27a663e21cdaba52d27bb62fc6c7362334de71e7c8204b0ec253c17c510350ea23aba58e03fa38817a4f38aca20e8950b5eebc8adf11efb68d5073497f27c3c7a9250ea87f613a45f2459d62f3386545b14f7cc5cdafd3150c7f202cd7022e7fc60dfbb22f2a6316db71f22d9b76388052a7f24f6203c8ea3613d4fa80eef5a6931df66144e9fbe19d8943903c95cd6b2633d882f592f3a384fb5a799d849c951a1fa33312bc31e3df6d2f73cc113607b36b2d0478b4f9ff65e1f8d5dfad64b9d693197dcbd0e7f7e7d9228d725a1dc93efc605371daeda5afd502ce4f42610f4032334975bb73e88c13f5e2dd45b02f07c81478976351a7bfd5e65ece72c584c5dcdedf2d4f83db112db9d92cb8f95a0a84975b5ff634fef1373b932a689c72e33484c5bcefbaed3aced25ef7b7ee95111ce43d6f1936c9a6fcd26d569346890429d9ac0f16731ccba57ff8c4a34f401262ba53b865babb110815062bce3800792246cd904028aa7e47440717821e0751e529336d74a1cb36b5d20dbe077ea2b9c1c2d8198ef2c024220d44832b7eaa3fefdcda01dfb9ced929dd564ac35161aa27d87214310aecc0c128032ed9fd0bb18a258d8995320b26e7829735c07484a0367b153d6874d47357f4590d4b4e9f2e1878d01e36fe670870b4bf98c8a92d24b7c92cf6d9e85e35d43b546aca3c760c8f558ca122892f8ca8eb8020eb96673785d2d29aca2235fedca79184bb4e63f5f2f304194f6e5f2657f68738034f544f4fee498c82d61e0c6cf69e4ed9f2bd401e45c15bc2a8c702f3da5763ba85311d7354839f54d0340e11402862945f1dbd16c9ce4ccb76d08cb1d34fdfe3b36e9cbbd481213654d7b6c51c1806d2751af2b6c4898bc133277176caa4cb557176571c2674ba099ffb3b3ccae1278fc82d9fe37462a3690bb5640cc1861dc842850d798d2c5ce6da73b4f6566afa995c08ebd6f92b256c32b4e9fbd9488bf394a968e8d1e70d640b9fcfc86968262ad7b62172b8e1d2e59888d23706fa242d1867d20d459d556bfffa74299ff4af514e032eb6c1ab3ba067a5a43e4edc7a0d1b7519ccc22be5c2d5c6be3988122e30ffac76def9293c365c2f457070a278b9109b047014e5a1e71175206887c5d8b9bd64d946c79d2c7464803056a30fc5f7e2345640a54b25c5d7d0b296aa14be29777a4bf49bcf45de8ff769cae6ef86dc6b2426f1371c608835d24a753210b1193fdf6723b157675f39b15b561f36ff6d0e4d6b691ffdfe9b7253e2e878d35c0e6ca3b35afc8d84b80562feb5af7cac073f66c5591b97202ed9ab19946b4af5b59b4984859d610c164443fb8e25064f2d74402a4e8973747fad84844c4452ea708b9961ef68dfe63eed16e88e026259053dcc67046e4cada7dc104bba87e902ff309b9d555aa1bf895cc3fb859455c7bd1610fc03554619e894fb5e3c7a5ab9e8eda958cd2297589f34bcf730242ab4fe54253a44c0b280a9de0610754957ae80902b29c4de7669f9949860ee0293f36912b8f9802810009b7cb5ceb8c7b1b0343f24e617d788c77c4ade34d046569f535766dcc968df85ebd5218425a649659e688e72ba03daefe492ce1cdfba62e0264a1e11e54a68062ae62de41ac1cd43aeec771c6fa37afc02ada0dfd8fe311e0aa71ba7947dc7d4de908d4a82c7a6111c3259459fe0604adb69d83b72644fee7292548ca1c8012969984f39f690bab9eaa29da3d0f9ee7d8038e133d85255a0050abd20b91b2d458b5b1241771f330b6b8a639994b0b6a60302693330b9b19b1881ddd635771f18037c85e28421fb4410f3eb7500b7b9d28702d8e8a0c133a3d34cd011d2ae459e7f4d03e889104b33bc1b4269243035048b825f5d12669cd74bdb1e24a2e0bb54602f49d87537dbe1c2686f12a02bcc66d17eae27c84bf2fd181979fbb91c2c92a1c7651fdf66381511a0074c4cae34adf08db7b31da59599fb10f61b8576a5301cd5f23f5b0ec2a5267240b744c0ec5aba4620eaa6bdffc581986c271b86891d98c622c19745f170f681c8c2a7917a332c205ddeeb22dd5c1f409437c5e8d1c725a34e3de2afba3eb34505a66f4c8c97e7e28a6cfd0d99c77f8882de7005dc26d4159ffc31e0b7a66c1a8f6e369858fc58dd37384950d7cef785fb0d28fcdd07a7f5c1266a90ad27d16cd2f8406b2c723e740df5aada9aa6529003abf8fc96dab2999120eda304047a6836dea26c0974ec897e36e30d41fb682d9a0907df2e5262b2500df32de32f539d9571e1902a8e37b390238851a4054d52cd37f3fc587cabe95122220ada4a53efa506db8c716516cdfcb3c2c24ebb2870975e7297fd52ba6391afaa14934a0ba301175bd4f2c3023b084aa5dd176d0086a882774cff5bd3b4a343e084c3b42ff666be3552a471f9beb25221309fafac4e3509ff589c09476dfb188d401dff2a48c632850154d0ce31f25ba520c804ff7f7ecaef016276eab3b50119d2099b296b411dc8b1a359671e250c73e3281e1f8721d7c8498fea351869effa9378bdcf3111ea9b848c516f5d676f411492052301c6d339e6d78fb5dfb38e70217f49c6b062b3211b9279d28ccd0817856e5bde17364b99c267f5076459e1bfddf0776b27a4656f12af9b6d736d578e840f8a93caecab92b99ea760e9f35f9ffe6039fdfc30ac32111d4c59c7c79e7f030c7d7cc34ce3d92e34ecdc42e9c6f631a70760fe5cfbc65ad372e15f6c294116afd97d42f12f6eed3e5f7861cf4226ed966533f99bfde79dce0a9efba9c0ba562f139d9b68e897f4296a23279e8bf166518b6825e74e3dac96933dd77196c23e52ded54da716ada140323f92236c2a4bef75c99ac0623317947e75549b55645bd190cbf64f0a1005bcab473e6b70f1fc7ab46ff186d59f83b7430160534084db041ade8f4b4cf53316185260a6d289b7ef0d761de7dbe8fbed4420a2df495d2f6c5fc53bd23be01911b9dd84a75b76980f3b0ed93c484c7d235ec7d6f6843f49fabcad1e5d68d19d54aaabc1559b33e1bd15ad9ddbb466e5145fa2879480cba4a37a90af0d3e8dbdff0d004bade71ffdccb48b8c4493e29894685f2e31a592a32394f48c7f0c4fab656202ff98da0535cf3f5338389e8cec52cc16291e1b849bb0c341400e4acacea19320d55f0174b1557ec62b30b76b67ac333f62c52fb86fcb16809b68ae7b7d030d16a0f3d11129730a77c2d5004fb18f8469bf8da4858b49c8b9ca2aaecc47747cfeecad952f68b6158ef067b567884197637f0c8168f7d795358d929d7452834964061af4fb7cdff76157c012ea5c0bd347a7ef72dfb596a64f22d996e29cd62218aaf97dc67c5396729703d6728dbf0ec8b5a31a08aafe12b0dae276949d88d00fea819abb1ac8e2545d8d73342916c6e02debb81591d52fc9505f52aafbc484d6d0190cb1ca3145cb2c0eb25fd8773c28d67b8de786df6fe365cd947ab1a730a2962e47d98a27bce8542dcdb31efdb0efcc5952caf4e545352deab57f022cfa028a6ce52fb8a307fad059c67b65c75ff8ff91d4ebb8d9224a0c49850b34751df85d844c61f1fe15056524ed88cd09db4c1f9b824bb4aa9d2ce139a7fd348d8fe088b188a25fb7bb5d63d030f4ca8ea290b2496d98ac633a6878ab25e8ecd8bf16a5ec6e82365f84455515a642059ebd64f56c751cc8dd6ded3c414da2dca3256cb9eac0582589e30598e6a5e6017c547358aac5783f8c6b7f35c9aa6bcdd0a270918c878e91c5b33d6cc757e0b061ad68cfafea657f3502586ea237a3d3d9447933f633ad50e75f3d3125eeede1bae98944cc0da152f8ea1a3505a2275166a3ed796812cb2b64399cfa3236d6001bcd3a047acff16fbd718df1675fe09dff1adc14b8f3c574b3b556662c4fac64ef1cc6e18703289f4b96042fdcded1a387fa73dd5642e0b1abe75bd986792a335df35e527ffb27ac2d47a133ebb811543a13ca95a2c173321ac4ecb04f88fc3b0264ca4efbc151e99868613f9033381a2c5e7b766f1ad833dc13e41a17be31d9392afd3f7bac2afc40b393d0d20148b8cf61f370add03e5dad88ffd690d38fbc31c0e469e5d603e30a8ac8e2e94f2d722f251935ce11c09f0781af928a7a84d65efed9a64c460078923b0d6e2d6a0bbba2985e64aff71eb1e36c90afb8919790804bbb7a5cd361b72f43f6bb4900d93cbffd5b64fa613f9c8ed7e8ab11399b40951af74d24558bfc98625a67d317e9fcf938b3b6fb70617d0b65af336eb2ecf1c2dd16bdad119bf134e964e758e44a890a5d7491b5b55d25ff9caeba158aca65b6586ad5b4dff01ba17c59b1f6f97c161d0d12702cdfd250dc600cac15ce1939e9593d33aabbcfb70afa360c5b4746907f5fdee73db0e061c7ecc3c20e99b9023186dc020c317c80d10e9f9141886f631b8d67e2fb35ed69061592a3846569f6abc47c1d8001b02fe40d57eebad2d966516bdf4f6cfb8ad520abd7388ea8841634a944278e3381e4c755918f999757ca40564d464563fffa6e6ff9cc98d54a656d5980954047e9f6dc15bf5f4540519f541cce63c6ffa80950b3705c725a7fbb14e23e9943e9148deaadb9fae16bec13bb3363c75beb273c5069e6c6bffc2dc87adf181b67d73f57a442c7dde70ace0bbf146b7d20b48bfd023a38c0a13aa99e06dd78473508f4d3c19bc68d594383cc109cf68150ef6ec7c7941698d2a35a5b069fa60dc3e9236c463e280cdb746b49ff8d116b8ed894a47eb870cd9b9cd21fee6f71ab81a45b0add16e14834cf46a013b82673dee3c0993b37b5ece54054f5026af35b460d5c91d771c11898e1a2fff93de6b8ea1c75d3c3d3d9aa8ca3916c2975253d52ca61a6dba7814792e62380f3ca6b6a6e0358231932b84478f075f3249e28ffc561232c56ce4d17e92b868351e8c98472f7c709350d12b22676002e4f850d9fa49d1fbc8682d3d5aac5facc0e612602550c3a327d052b69df4f1891ca889cae5cc4ecb543bbc52b049313c91ecad90bfc4c58f35125033da4f7e4a43efa59c01b563125db0e4272f352b87daffe126f7e7110a1dcfd7eed5f24d4c7bb93678f1f02abcc46b6a7a853ab6f6419438af9264ea5882c661bc884879052cab84b993f9ff0b34547349b2f6f7472bba8d8e90287c88f893f0f86f39accf7b8fc99359671dcc2d5117381f03c81726dc27d7f3963ebfef6c87e5e4a2831f25139c0d456d34365dfcf5ab794944ba19c3af9d935fdee99be7bb021655037bdcbe004997aa6c68fe5eb3793ed47a6d8758b4bb2e36d0b574b6989b6ebabc0285cddff3546b12ca593b74b56f26d2f0adad0a9bb0454f8ba99e6254e7e0254bc11c794b470069f52f09ccb63d249e450b7660a9417ae8d9577d78dbfa381c2258cfbf4cf8c23c516def4970b44c09ae0e33d5c41ed9d4ec45d435124703ad85d9a1afe4cadadf69aa426e5acac39b975fe083e9840bd0ee608c24d21ae80d6a72617ced43c8d43c36733aa9fb28d91fc230f055380a31e31c8af05ef02a7fc91b11e1b422ffc11fddb245e6909860ecd4232a7ab0ae7363b644266741f6faf70d101657515df02229af7b9d2a6966b5f31f2ba5cb9b6c94a2076539de5ced972232f8ed7b48fa5370955e7bb9ce517e838467ba0042111ee00ab8d6353d70eddde9d8763910186bbbc56b3f638c20966a8e2725969215c36c031929b37511320c9e803142e0ae6d7167bc9b61cd55f1aa13b9ec30cc924946e9ac656d87bc40dff16c4b10f723a906fba5810b928a6797c7f1c11ea41e2dbe3db700dad49beb6a818efd82ef18d2213d894ac2e0ec358a5d7bf0807b5cd47b2ecbf29c3c4abef3c11343d64bac1c19d07b04d280dbff5e6d167ae323e215fdcc1e3cfad14cba5ec9a3d805c4213683ff27547197a0bd7c301a12f214a1ade7d0c08a97bb05cf5815403a3d4f85ffbc3bb61845fae115105e233fd960c69ff3c6d93f2654881a869c80bda57ef09f2d3661f1c203cb84f2725ce82c3397a439deed0547b1e6f878295877b2bed4cdbe373ddefcd870600b1c46140de89aac524e7a074e091b951edbd8b371c070ed352b6a56e95c7de670bc3bcbafc721594283422df845f44e5a78da95932705cfaf57aeb951d0b0bc1dd74d86d82cc1d83189966cde84d405a3a7c830c9b54126d63128a591deeb8d89c7cb759d054a31d95067cade350b8401cd69e9482219cf53cda6f4631667e91b349e52ecd38cdf7eb58dcedaf3f98672a49c2923d1915ba3ef72fb0c19167e987ab1007a5a05892fe47d0756fb0e91259d83409910872fffd4ef4584595dfc4b3172cfa9ceb871961ebd940923016f692a8a8c1d2d6d58b9e1bf6708f1bd876721c2ec25f8da4fbbed93d3258a14fbff0f4784fcdbeadd0716b4afdba1c9e4016c7ff9de4df46b8a8a5f30f6c420dea96aeb4274254be48f52d11287938f0734112455d7513b31d26f7a2cf308e1f4d3855269cde27ae2b739526714e674893902755f8d82270c1b3ef1f28f35515b4942631b5f1de85e472d4e67d87f41dd24fa91bff6f710291baebb854b3c9db9d8ba2133aa071d67e55fadb7cf52b4d331067d00141477bc7fff39be6e378f3b72ba29d2657d3dbd00c10edf6687e5d42809b57cd233e261013c615960709e9f42ed4c389941bdfc58e00f37318a76ddd03a5e71c9addcbe35abbc6b5367637b6bf85feee0e2245db9f0bec0cbae433be7740a67b505efbc6f1916207c299a67c8eedbfbe155833866a8f29003badfa6ca3a0fdba0bb539e61f55fdb780f1aa3e7e7943a3d5a6dbab7f96a75548135d936899cff568af760d06dbc0b4ca116a9bcf6c2c8de9931a7ba42788e6ea763dc0a870c18515c98de312c9deb983a9714e139878befdf2fde6953d1a29ff0257ade471d984972782865359941a0260bcb336fb08e3998ba7c2064e3daa3130e17b417a0517f8a9a6e7166947bb367e7174ce13e5664a727e5c09ff0567a548dee18d5608dce1496a5c4c0ad3e95fbbcf0ee60aab30ce22d4b44a2a0d604624c8706b5971377be522aa2bab7d14f04f68de9e2161598210ddc38d436e332e336121411e4b56d9513b6ce612bccb40e3193013b6b1d26760a9da03ad036e9edc16f7adc4ee2a1128c7467181c5e852802822719a42d6f0c5aa39ea3ce36d66fa0a4ced2c68d13f6621c7d989d9d7f4b4e7353a8a4016eb0d6fa9137803ef06b1be2ddc8de841b40e2cc6a827ef6d2dec75b4d9214aa33224c5d85932328a4452bbc9ab7e4f4127713dbab12a7847bfc479429056073e4e574d53016f6fe17986dc935ef30066724dce33aada973e6f95298e7822485374e48e804b9450e7b00b8fc3ba290ee007df102cc1d09ff8ca49d9c64e2b5bd061beab530e2835a11e5a64133eabc9bfc8abb0ccee127959b0273ddce4fc365517b762c5b7852a55f2bee612a23f690122981f2b4a532f9720fd59b26ebd90164dc532e9be1a2ce9cb67281db407c7d6b99a898fa33ca7ba18ceba52b0173c37bbced4e12fb597cdf58da7f7487c4ca5417f29b0ed4f935020b06fc757b2b52267f943de9f177562a985118e153918b12d00d7b234523576cf707361b0293df5217374101eea3c12737ffde7a90172bf019686b43460e9a372772aaeb6274315e253261ef5d4606d41121d4396db495cdf409faa09946c67834c6c57cd87bedafc6c4c0d9aba01455cda0e13ad32397b520d62bd74741ed64d2f2609b8c5ff1bdf37960f802eb7885fa8c1dbd068daa178e48dfceff702d685e239f9b2c0684e368eeb6da20f1e033b71393521b8629ca2575cf808b1bfb1832f6d279e0fee95344d55475aaf22e60de96db267caeb9d6d8e6d186f239ba3fb239395b32a28a76f280292f9a7df82e4e93bfe533d6162c696fc8a38b9fa0ae3303c0f31cfc6a68bf0c9e3ec0a42ae0747f7cbab9982876419766221caad09e606e34bcfe0dd6b03750c029c6de5d66229851efffbb2718ccd364c535dd04136ee5c21fa3ff877365b10ffdadfa0e591112608e759bc643b7a520aa0d520891d3bc1a33416d6f699a76209f6546583465d8b9d42aa389c9f5f595009ae6062bd37b8c2cd70b9565c8d4a45f62c6d5ddc1bd33fdd3716df08f2f1fc3ac7e1c1daed4effc6da0f4f1a5805978308134a095e4b4361a3a0c089f1b86c553151a3064ef754b59fa760eabf1a79c3e3df09634ab30c75aa605c29f49b712497a2c25da1ca15bc5216f18f98e0c3f40dd724bb646feec68f33f25bf20ad2d96cdf62909f64ba9ea22c870d0644598bf409a6207dd54ac6791f1e9f43fc81f97e159863b531d0a957a7190763e5491fc13cd4b4bd44face0986684c0ecec10962c4db8fe507f9f77139ac52ae1fd3e43feae51428972f4253ca56c8c1b1ad8133b530e8f400e00d9da01a01737bca65c7da54c2db4e05a9b932cc49df0ff372ba5c8af3a1635b0e85f113b0ca37c18113ba85e3c23df1eb77569ac98041d6fb78acc4b16b139574c13c97662e1ab24742c878225bea082d5ca6228e5c89b01c8246905efdd08fead5fce75b5be4575893bac0033570159adb24a73bb6c0fe13a178702f15b3a13873b0e4c4b0f64781183457d81ad72f4526e17425dcb3d562278772d4f330212ca3a4e38d4dc2a07e9ef6aece0ff4f4ce9bac79fd988586cf3ae356de6104540ac7f3d2852a04b24dbf6256170ddcc41af8c455140061fbba33cd9342201ff7872d7b44bf88e878a36ca539daf66bd1211822f42bfb3fafd7980e63166f1892051fcc4c1c3627275e4391fa2d3f85e0566a28ecb2ea2c972c21fe66fcd2b7092d46cddc2db07a80924116baf51a5e33f7dfee813f13da98c97a814983ba016720c5df453a64d8a5f349df39f6fd3c6a3906012bb2509afd594aa742ec175940a48cfade98fd447a062fe7a2a5ceeec0664eb1b1137920e18342f98f971371df28ed6626538e704bc1d477c7c7890bc55e5a90ff8788ba64101493cef539afa7a9682dd2563c8be88fd7b2779e77eed377edf7ae3334e11fcf7899849bcc46b7dd4588c3dd43440a37ff6d70f386b09eff7dc437b9d3317cd3f7414e10ca87a1fd21cd44b4ee2488c05b5641246c19d42f781a7098a6a8fc2c6fd90697fab7f946feb2092d53fabae7618459c0216f9402235ec0c2da385aaf972763dd2e181c92bfaf99562897091b33909627a62b801a7ae210f30674ca974c33b81b0d19b8be5d2c7aca48da52df59168930b45b2f996259faec1ca1a594bf056a061133843081d486dd23f967e33752b65b2689568ab9333b56cca203507c15e709bae328f660aaf6fcbdbedfffebbe30229ba1ba83830c453b1b449580f51f9f3c7950fa9a184d9388268e705f6939950661e4a68a6a063e9dd13473faa23532dea02304f6b2f16005c2fca15e7f60a278ebdca1d5f70e8ef4f2b747962ea9953dc4e3de330d32cba5f0e60d39b26290f7de6bce21f78a06751fadd638e5cb6aba381abc3ffcd810a6afa26fde729714c246d2244b870d85af65e62e43831e63e69678d177a7f1a1535765c769865fbc18aecf7bc76b50290bd6f59a5b63216a06cafc341c8a3e9c430e531ccaa4e9327f1180c6d4cc355e26d07de090e3953aced1c3707ec88b3e16175b54946c0a87c3be6b4044e0815af3986a833cc2332d17a746ccc3ed51a948fa78adc447e72fc52e984a0825de5d7460e716d3a825d1d02de2f4391f9e85df9b0511546d1539a646a4c96e09ff9a916fded3cc4d5fbf40e5597f42e7af16111c95c49db15596d99ab078b02b76f7a16c7e5c533a671eb23b60b989341e39d1f3b79a63532a989adcb82284c5e564cdc7b6ce0df2a7ef14deb4d9d64905c470a3a67543ab15384974391a01a247e895610c589c17a6f95f617fe9f1765f84bf914cee7a8421da84cc5b5724e3b9fa79ff2eb5d35bae7586e189d7ecd48ed3e358d54debc6e81ea3ff1aad00de8b5e8186ebbd0b106a4651dfc02796d8c1cf4c85fb80648ce1f2e51f1d651d3804ed3eedf431af6a9bf18d2564f22afe3939bedbe167562fa08cdc7872192bf3a2994c2d7e9e4a7831f599e5fc130d7f11c4c361556ee8a9862ab57fda5b668c5e9c0679729da42f5e74dc363a4fe68bbe45d9b391c29748f851070896acee9f953daac13890611902a1053e635636b82ff0c8ef3c334b89c1bb3550fdcc178e157447f151c7934562a9c57b09cd5f6a7fa4ee8325aefc23ccbedebc0a814d202c7ca6c6f95b8345ba958ddca515bda799a59881baa9443e69ee3abb8bf83e6dd0b4d76af72fc0bc536f12e93f5f2d6a7aa3657b15ac8816dc3ecce29d862710f49662498067cfd77811a26e14ae0b0907397bb93ecd9106dbfa8956d69cfe9561d924ab9ff531f22035c8b37dd69e5ca3e0c6c9712ad1ebc90d8e1899860502bd61fb56e9340c8ecbdf6867318ecdaa40f4a6f934e2c909dc390325c0f70f27f4a70f6b6c4793ba12dec2c4e8d9ad5ac895cd6e4e8f95046927734a81e78ecafc54b194e25308f3dddc7ed735ebc311abb8c08612c5b2de1282d22a36d354e4a1513ce9930aa18fd08be978f4f10b656509654599a47ecbe06b180a24bf1501edeacd6221efb45fbeda26eb560dcb39dd8051cb7f8c37212d113c6eca8849836658efc343822adedc10e32a77afde113144ab01ade1f712c38f640919b988e9e8d4d886f3d4f6694c283a3f25e11637a3d20c688650f4d9ea424ecbb3a7e7959147d79b9a3e117bdc4e2aef17a2c1e3cb7c2fb6a95abc0c6a2297148a5795fc3f7158514fbb19059058d4f12dff2e5bff208225960688aa9c198a125439345a9fcd438c96a8956c6b6975df535dc9a1592d2b7ad9e6cc3c1f3c8196b90001d10359708a0993acd38edacfef657444a4cd94d05a8d4e9f593822101ea4b4f20f5cd8867d084cf736ad2cdd258fb1d35fb0099cf055980571ef8d6768a79b56565f59d9f0a4b69ac155079233ea00af9ca413a5edda9802757bd17b1f004fe941172c19426355664cb6c13d57a6922ccaee7ef88f8deaa2305dbca2611b52a5ea4cec7bc3ffc647d3cbf65f6ccfd849208d8d15bd4b94e71145f66ea460b6bedd88b7f2e7284b500ef2da9c21f28c72b6e47d679edf8e9c054325fa3deffbdafb289df15c921ef8e902cba7edf48cffda09c19eb1abead20e369a9dd6efd47021a4d304ca64426566c1de1d2de4776a1da95ec71076d7f05ada4afd48abcef3e77476475a032b50ed3f1479f7b309744d7ed36d97f7471d05928fcf683f4bfb9e5501f47c2482e92d769f36f60ed0b72710d5c8eef03ce39e13308fd675870e7500eeeb3082422879cd94cbb6fb8e108a9ba526ddccd399f2f787ec9bb1bce341ce94359688d0b6c85fbac25e6372f644d3067ab0aad37dc2766e566671adb41c1395154db92b4c6804758d762e0b68600511b3b2d7e45ee1b227f73c07f6974b02db54eae7fcf20ea300f2e82b6933b05592fc15a625d68a5114f4b7fda99b4b736d77fe0916dfbbb0187167cbb96116ecee848f0922f81d24fb39e26de80e978e2ba0ca2c757bf789b91a569da8953fb7982c70c3c54e5696fa0da7f8db3a5460319c145c152d84e1982b1667612f671c649c2f2b12988750e0419027e6c377bcf29fc673a8f2f25d042fc0878a1b84c13a112560fb0ff07962db54ca7062659be217b65523b1a42634731e633d7bffa11cb7179d0b92ae56aa6d8e6d5120301c2189338d71cc3ef20b02efbe7019eafa944a0a874029fd1ab3e4dd6872a2b7b55ca8ce0b381156228d1268074186baaa70b471189d353817171e4594de4a05e4f84b7a81e39a26490c926cbdd0da4bb7ab0a830263980a6ffed804e1dbe07003922bd725eb8e1e874b13164072eede2c796f6aa953a4007bfd02022877b71327fe7a228f831ac4ed0f8b40d55077798c625177bc2836ae9e8d0d1b4d38d85d0db1d497c2069e0b9eab7920887e7bcbd2b6ac16dab209ddc220b49ee5ae2e3d9de50a1e9e63ed9292ab54dc61b6afb4caeefa82d2cc92e2906213f73b7baa5659d5056d3dab498bea33c03ddc23e0d4fda341c71292a6834134dc6842289f65652fd1114c62384a77283e929098a5b39dba1be455246373a6b513e8296af8b543f77639448af0155aa45b5a4317cd9d783456088129f72098abfc4bdd29904ebad0b27c1a126437f8fd8be96d2d35618c171eccab27121438ee8db473a6314415442fc8c71283d71a0acc878d3ff9de6c64c1795f9f4e41b5fed2cfe5dc6b6124cb34a30529007663162eac6de50c8c7596207ed5277a2ef8d9fc806bc4c8fd338879e28531aeaf2024c8a112e5a0825844870014edf4d06d7464273d725f530e03e82380987a062423013ff9f964d94c37755a01ac4003c28c8d636fffd75954f15ec84c03fc733a415e29e2edeb6f05573b01d7fada6337395167c6474408c94ee755d716ff2b3e54b33a510a7fbd7dd1667bc9843a5990fa2f8f473559f43f3a83655a4b93c19e3862b9e7879d71f84bef926b90956e77545e97659c298a50988ee57d3f53b764d4481ae467e9eb377cbeb061055fa85f890d05942a91c28dede99b3667df2695505ae19480ca8a65317a24c026fb84838b3259a074b736dad488d905052f54d022bc427e3125800c588ce7ce2f2ddd804f414be2d6b3e99283df83fae8ff20f58491d67bbd51771e2fd991345b2ce1aa30f3c61d5eb5237c9a1efced52ef7dcec5ca68533d3b32f87c2a6e3cc3ef8d14fa1cd95818528c2499f18ba0f2a1cb78148f2425728895664f55fb43a6dcdfbbbdb68a99cd0a37727af86463184a750fbd5b9b7843dc0c63179e385f5e2348c1380892451e602fccb29385ea0352640c1dd45afc2a0c452302f2d8bd75f0ad45f8ff76e2ea632238a1e18114b5b39118cdc4de9ded69c260410d350d8fa5489e0b058c3c03cbb6db59ff25ccd69fee15fdc5046e4a6f8d7451e1fa713144958fbd7f8975c60050da14e0ffe6c4619e2ff0fcaf7f3170199154f02bce6fe373472f58a275c87f4c769e886b51905b398d5cc61a4b32d1fd065a48e6f3164d1b227cd052bdc9b5db76d9073fc1fd8de2a2420dff9a8187eebc3a85c1fe597b957273c5db4b8a57bf4b180695472328a655286502cf2e4cd2d281fcfe3ad19e5c1fa67f437d653dd9dd3323504e5cb67bccdb67e439248814ec969537b7592b835e1e1335d95a47a7a19e54a68ab1341673c896231c139fe3ce8ef8cd43edbcfbc3d68d82534919834190f5ddf43ad</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>白鸟</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E7%99%BD%E9%B8%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="07ea0c3f06cb7dc1ee41b8c3ec288f343edb881871756f20f57b85f06e1ea4c1">e55e8fb0918b8b65d60b5b09d6dc221c9895c42adfd9f5723b544e43004f0924b7d98920e8d6821ce1bb55b041be4e0607f594387e54f339a3015447447f244b620b072273eedcfe95026ca474ab6f2f7d3e2a4fbf9e04cb560b08da3f908fbed87834e6475c61fc3f1433a034817504addb9e4ec17bdb5744ed1fe2859cc171204d5aa6c49fac97b9fc923fd2ed501e4af034af458b431186fbb285cf0c5e49c1bc14c65ada40649f2882eb3092e614a407ac11746d015cfff54ddb1942d9c145a7b68eb5176ef8d282cccaf0cd6ee4f861ff241539a2d778c00efbd66c30214ad91e49fc103430fc2976d8ff9db548109485f4829b24399e2c7dd39c85942681c286d15e0d1c2f7f700f29f8150910d7fff8a35ad007e736c3febd336e708bee6361e060f864cc2ee45df95f795cfc5b9e679fe3a7176fea912b6371d5692937e3f3e31794091c136ffdc64410745a21e684c5ed7c2476bb92503a9d8ee32bd210b6fe6fb22d36c0859c64ba4e0ca7a03f7b75d508781de9aff078d185b73d0274518134db8c8a032e216c2ce224cc93e8ad0bd29da25b411c3d436a1d3d7084a386b1f30ef0844d13ca8582379d91adf9afa152af460af24c1f8b99e17e40fd39174dc716329d237e90dd606be4a61697d70a4f96f70b57b0372de5138b0eb4241135e0257d0cb6f23cc22cf1c2de7a9824b48dec0c1cc41e9bc4c642c38050f18c1f25e3b1187a1fcc31e34270b9164fe53e3a016f8b554978fddd6ffa34135b2d93ae34209dadc4ef65a8eb559d2be5c8dcb62e6a891ff355507f196a94747fb73db9d38fb3dfbbb2300a9b8863cba111db4b234c67fdab30bd1f49659499d953c00d08dc1e695bc194af405e320d469850ce2574b16ab3a45cac07f937780ffa12e06d012861510a61107817232aaa7e4424af39d7f26dd0b12e720dd1c748e1badce9f432723a325e8b08543dc292928075a9c1b260b794db356169a17fa0a026312042572d46ae9bf4c82355cf05a9502bf6d8736f2e0ee3f76bd9f1e5fb99420e9ed7210add941e8cdfef6baab13ac224745580671e0a81907addc3a751ad5c2199df60735f053389deb6ffba989d214e9a5d092b36fb0dd99ab7067d46030e142eab6c595c6421106f89f7d4db2d6b92973d8febf7565f7c0b6d1b6754584bf94a80ecb632afbbc0052d0eda967c9405fd946f04f2a2c6fc86ffb2e86c02dccb88224fc3df43f650552640e06167dcb8f78c28570ab3ba5df20b4b5db859dd42ae82fd96115112aba9ac00748c1a335f68e8fd3fdecbc56afb41f10b56fc03674adc4ef89eaffdbc7d8005d05ad9e428f50adc7022a2f7e6d626f5003cd5e162faf4b27250e60350ff369f52834e2298b197d79f1a641dce830e62fc04f3c9a0851af752dbce66c2c3a2fe62b8a8861885f7e1bd1ad120b80da33e8fe214ec9adbd9493bf1ed20edb6f044935f279fdaa7596bcfa38d9788bd620a5c69bbb2522a7b14c5ce59409ec9fd31844cf071774baad4ea5bdf31d129d8f2f7eb0c97239dce56a48fecc2ecec8fcf7ea1c01e760281fcf38c254422e8720aebf2adc8a1304116ef60d1b7245d57d569e3a4cd31d7dc27ac1ee715efc054391050c10d64b4e2bd324c10187e7880e7d5e0992d556a85ac035e7a864c89a6a0acff44c850b4c2dfb8c4889f7c5ef297d002cfb0748fa9611d4fce51717b1d69d3f5fddfbf300a7e938dad2e5f9100d83fdbafe5e05e3955b909202a2afa5ff9419156ff60f2d022e24f37f1a16d1524f6fcdf8c1005d2e64db91e26aaee1793d1ff16fb6ed7a960391342b335a2c12044f9bf3274f4556fefc0dc226f85096fa378ee195a687f7709c63bf35aab186e790aacaab03f5774ad8e0e2af286168ab9527d601b2cb3a908b1a011e245d667a604500281bbf5382a3d04e78a8851faec8d2430ba93a3524083d05df68c40a1533bd2a375b857c52e6fd35d133a98e1eb938de3a24fa7770a68626b3942fc9c07ea277f61f16a1cda4cb685169cebfe39a175de3145aebe0b43223bf05d967059d4e4c49ab853c7a22da5dededfe309c2bbb4048ae839880f8a2dbd78a04e7d55094dfd603fd965c9a452b30c30990b664d5ccc38ee17bae53b2e073abc94e7a881ee80759c620dc091a697be53f2e1c60fa2d44837c4f784180ff3e2ab1b4ce9026bfd71a6d274721841554198418b11e8a9e90a2ca3525848db9803fd962c108a9eda9f7c8637faac4b4cf9b16de1fa0252c0614d13643058788a0cca8e749513a6b0b93c0cdd1381e3b7e4dd5b1feee4813f76c94d45c99743cf55c92742a3496091078d40c316a7ab7bf2ca9c0a972f353db701c301024cf4f0b3f23c749d2b660a735278c6c1c0bc1b155d76645e498461f80e0e2faacaa8010a9d882eb2706b5ec6d93bafac1cbb7e8a7559198a59a47ac179f099821efb207e0dc1ae5c7f858ecac1b721f1fce73bdeb8d26438ae21237e6374a04765a6ffe72d8b044871857f0f4ccc0eb83cf115a3bef09be5e961f53f2e9a83e9a244a10b2cb09bac7678f4112b9ef11807847afbdf877ff75a5877a4994d26e7fc76d979e2ca5320a18edd64d670b95f61f6fab858aeeb31dcab5966a8bab9adbdef94f5c8c2d59c7aeac46cea01472aa37d10d34ad195cff644d29501e5db9655c797c9faaa9fd005ea95d99889e5ecf3a9e5e51008f30685184e6a2f33b5c4216ab0c926798a24367d60b37f9110a5fdc2b9be522f0e980763b96bc5bdbce47bf82c409eb5eedc32a6fbea1ead766da9e9d59e139c89f2d27bcfe5bf5b8992788bcf32e2b50841cac7506b08ffe41a9c280cc5f9c4013a8b861ea6e70b0eaab2c3d9448f54865df8e08fb4c285f1b05d2901e43185f44ba7d637806b55f9a03fffb5c46f374ec55e7eebb7339be3ee43f5f58c8e3f6458eb572171bb03d0bb1c241a48a66e6f05627bfddc3fec3dc2d924f593207a870a1dde6a3bd5b0bef8803897ba5bd97fa92b2c47443bc56c72d57b7b5b254217aa0d7a47c6d79924a852e2ad3ed343e83193316d5a7740d846c42a6ba4aec4327367de4c3a414e81be0941715437b4088334c72ed149cdbf97bc4654ae15942f3becd9bb0da72d299a0066d6b3ed8b2fbc732eec0c2cec0b191be16959c426382d9ef3de3d115e864c4e301bbfa58564f52b60ae4421d7f62c92e9ba2b51dae1407bca4c115f9aaf5709393b47f05f4661f191a3a6281c33e173f7fc0ecb11974a927394aa5fb1104cf7a4581d3532676c2a46bbcdf88f155544dd979ee4c3123ad4495ab642ea49e0b3c7a80b7b930c346c0dad4fa86ed1e5239f0143ea09b5d1c24dceafcf2589392af44a5e248e4f4e4e34246b77403e690668fa43fbe2d39f00fb951447ab9c39a74823dd468ab6532174de456d306e33f6842f3aa0bd483c8d7aaf9ec702de6d9fcb27f6d9d687db6f9dd8a3fc59618fba028e7a8a963359821740156077fae43032c935bdf22dc38b70f0fd2985ba830a0e5f0eacd0dc567b5303ff59d193db0397c2695a664bd1e13a571ef06b059cfbd162073ee06dc9a6522fb833737fa381f151dd3f1b0b6104e853fa91f28b460b938f0b4dbf6c423922e9aacc3015894e65d87d7bc4d9b8140b45fa126a3a02202d0511903f1911f649b0ecfdd3ae36389a22f73ab83d94291b7c10ff65c4a9e189bfa4074757be00646815d8012085f0c0b0301c2a732d6911d62962692f198218228e2a5e3cc138e8f65be3746f87dcb9f7a3642c6301deabcfd78241e2e82263240bf6549be8911e56fc1920423516c416ec8c70396d0aa5b3415d4c18fac5f371f11ce4e74234932a7b62a1461a8038299c4fcb3733f68c124b1d963401d5ff58c1e97654d9b3b45d9f7be4915ded0598074106f868b378f8f61e55f188eceecf69ea9e766f7c8070809dac59a37fb4e96f5fa3651c150cd3c7ead72fa419cdb604147615fad28e7c049604df85c30ea9c8528972e8edccf1e713868ba630db0c5f39d95ae78063e4db002349dcb1689d0933bbf865da7ada69959a569f8630252ac70401336544eb8bd68e345fd81ea7c582e9c7ade93132bb046b405653c5b5f8ea718a852584684b59dea5653a494de1f5b0e1fa3136760d09189745b692ee280c249d8a2c679fc0032f5a605dec23bc4c6bd34cbf4e395d239f66b2f22319aa9202e04ea56a2fb97a2bd62fc6fe5a4ab43a2bc0b6e293feba7669d49b373499382ca3f036304d84bec06a17f9bc45b2b59127b7b885e724849b8511b07cc0c7d1628651dfd4a6a62f13190d2426588983b545902f4f0eb42d0a1f334eeb4212c4c718a8e91a933fa8255de24db7383e6cfc1238ef7a71433a1a6fba976e46841fb03d02feed063b99ba9692fced97887c79a6d4a13550d31ae3787f287c46670c6ad0fd4fc51071a0e5bdb98624cf5ca4e5a2ad5ac6b90157fec3b9ae10d3c077b740f705e3a95812d0219b1f1ee42f1745c990fa85bdc7ade0c69c90bc818bdd9c91c3d45eec4f61c180c654508f45bc72693cf8bb07f1de415153b85254a5426a8ad1824f088aca39335bfad3e25e00c3b451285a6249d287d21b374e584a1c8c015445b491233bdb1f372b1ab6094995c0012435b49f50e99ff7ae9103c3b33f015badcaded666092a1f4eb4565319ef2642c5203285650263dd041476ef6f57dc496b4d15529bcc8273082d02f2ba19e77ef1e31b2701a5a7815e8b288019d29b9002c33bbe096ae10ca2d6fcf0f3b6058cfdbe560c5be74be497860fa9d85b3607cd830552d83e366934be686af1b4e9b0a529ef26b191edde98c720f459c92dbd185b966fdc5a625915afd300bfb968adcac67411cea2fff1be92e5a65d60973954247fae2c6b66aa8f89dc923141e8e5cfa3722485d2f0db6c04934d14747121189e6a0d2a93bc779855e74f589239bc6a59f3c166d922e3683337f9a3f40fd53ebeaa81d1e561f2e40bb47c5087ff0f7de01f4471bf3ea5f58a988e9404eb9abb4c43ec79f9a2910d4fc786dc3ae07eca48cbdebf188a67cd58b529d58bc57bbd291c3faea28bb6c653ae5590ce04629c9860f7695d6926fd3a3bc78ddd7b05968fceaacc1a8ff83a53470b93cb102f92704b20b5340751f1138883c396462792f9af380c1638369d88ca22b514757c583d60b4fe5571e0087aead82257b512a28962acaa500d319cd412e55ffc5f634cfedefa319dff6f5bd0e2357cd54bfe3460a5e4fa37c3c0d48d006d0315a129728fcc55392f1ce653029ccc3416485488243c6c9d64c9264cdd5f09fd6401f156e745517e9077a64423b3910e3b0cac909cd01214409f7e18465dfee6287dcd1c10fdac5049cb8b9c96df280211385eee8928f78d20fbe67894cb531bb50ab7c3f7b38473f58e328c6b446ec414760dc207a0f880219976d0439d558654fb6be6237382dab3a2a6b71157c26aa6af6095c39bb167b48075ac7a17a59bc26092640562e7810d6a98b1c86fb23cce8435817354b0ebd014de7fb58af31cbe9d10272dd2d963ca30f50375620627051ce22f69e01077305c98e3369768f800c74021718863d103981893692f24b91e2bf1faaab2dea6eed38d1db5088461cb4abe1e25d5b6e4abc043fa572015c245da8784ab8850d6b2555db44e48e70ee3fd9fed047674589211362a5bd3bcf1b957652982af67dcc7c2a0b97183634394337fe6daf285a291865f519dc34dfdd7928bba8b9ee7d382e5b6757ee006b8421a88963fdca1bb56f9d0ed4252af508565d4e529214cb74928564fb8adf2077ef63d0514f18835eca5f63d411248dfd8a4854d421cac9a0b6feb7d5e9f0c8d94eb5c0190c86cc324ac0733b52e5548e80c123d12f68c9e627bdb02e7ac9d3d7057a91a5fbbb736151586b0ab83797c9fa44a7adb393bb73c74c9fa96235445f6805566b387298b313a03857a1c1f12c36a10c761d66a665de5c87d123d38ce5106d7e20942ecd8f51db1cd8541f572c5cf2e761194ec7cb2d472a2fc9829b7570c2088bb57adcdb55a48e5994d77495b00dcdff3ba5d6a9e78ac302b9733bcdbe0062d7b3480973296766b263fe9258007b2182359e48bd17483e02e14e67f8cd50664493f5ed3a82293c9d2f7a6b8d968c0f65f5bc61f7c87d3c21b7f8e5ec7172a244124b64608581ea277732fd6c9d0082baef4d87ea28f8dcbc4c9cb2d8374c0efa45c2db365b8d7e99c5c6fe690520204c7ae841c946a41ac250de1da9bbf7ffe36bf637102e079b581b78439064d20f79e081bd729cbb95be3bc50294e00cd335695fa1a25cd8f0c2389c306093f3f3cc8fc5334f9f1509ae751eaaad9b1358d4db4283def685a3b31bb02e16dcd12e77ae877e4d64dcd16beee78ac2ea04b427f58aa0e675b69b51abae8397c08fd17276d6b69253c09b9112d4bcc54252fcc2d2f2dd0f10e8434689d047960e6bf55a25786930b75a818ac2b40edc05506ab15e2914e717a4ef726a63c33c98c2060758c5f20305e4ef62d1e29db3bbc6a4c18a4554899f4385defa5327b545f187c876ad1626ba231b17c988ad93388fd41195429155a2654ffc2f6c419eed9628777c1ec072a40bd4d1418a8367cfddf79ca791456a6bad30ce79534c9646dd781d4879dcac846496c0d061bfb00bdf63e9895360447ae03ccc30cfa50acee9cb3bae2345b7e4539cacfe2e410d11bf0056e7f1406a75f3e5016043a531c4e20604e22ede07c1e290ca381b29ca79940c4be3c7821af38de99bb390799b7b34782dfcfaf425a351c78961305851c9211a0060a3168b4f210f40d8a3e25e0a695241a6c5c3d72d76eb696090140488748c9808eec926165048bcd3e383f7cda3e668e46134b1e8fcdba883e1986b51756aa4fe2c03af53904952a8bc5aca9b4754f29238d446d3339ffb676f5340f5f4c27a21b4fbd858bdf66aac4cc385c28f5cff1fd0b02af711b4d472f3e1b29f2ded3fed23ac964c05483875d3d1432a202f2110e966b11c6fd4b0dc82f17395493a734796011e8c304fbb7ee2e8860f6d6a20f16d60ff8768630998b4414278803c25b461c08fbe001f231949e2ab73b7efe0494bb0fff0b0a803d7435f2fdfd83c06c47825d0d25a33b09d699aaf46d6019bfc3125b7d2942aed9cfa5975bd0762f641efa99f051eef3c3d198bb4fa4dd2aca3ed1e9b0a7c79e09e9cfa65249dfb5252ee92e74c7af0eced757c449fe98f86d1ec004ecc52d5886bdd991ec3f665a9c2c4ecc2feb9deda60a4b55516a7a63f7b21497b12597994f90f53513f2677f7eecf31086b495445fb0a2c711322c81041707782acf5b163c7c14a6178d393586fe0284369be01d70e1ed5192ff647cc84f4ba53dcba9e950697681f21709d8f54dd1d3b0123f990e70759c11ebc6a86b8f8a21a7d0b64c792f790ceee3b04213f5078aaaa7dfcb1023b474655bacab4dbc15187be81a548e2575bebe73c3be60a575ed4355e044ce3c2d714a7a7c13bf21ffa088bf94941effacf1feffe49f0db847ff78c4764da160fbadbae59f95755e6822c92af89b733d8075df35edfa7359f26d5f9ac5fce4e1e2391254295beed054e64cce25a5c1d2d574694a5ac60c92deec5947f9b5cc592388d53bdcb9c94cd878a1807fb5e3e0563d78da038a8443f1105e94f3b9aa0e5f91dd36e784e698c7fd5c6ed7e382725beac5576bc4cc62a49f7e8bdd392e79f0e6191a230395eacaf2fd8078205272bed2063fcd921e9126d09f39d97db717c7bc201ca62a17918231ce51d44d42c5a7a9a2fc29064fe221400b54f49cab8c45cd9970d94d31fb52655f032b91349fbeac55730cbbcd7ae8fd962d394cd76b24822cb661a4cdd876e4d16d4f55345cccea29114b50a8e560d70bf10c0e81773e742f222a24bd8389c529e14862b980dbba0171df08337326a1ad473ccd11a88928cee8b5239436d278ac8dc72aad85db15225bd3713e046b7cf005c0920fee74d4e7c03b9e63d6ffed787d4d716b0c5537b039d3b0219abec220684e7f7d803910c4d79e7f2845c4d17e90def5e342708db30e9917fef9b23e40316d1f8f4cbed0dbc9d9bdfc0b32b69152db5de00cbb5928b08ede82475470d57fdc471c076c964cf8cb9b09327e4007d36e56b4c9e48985a15d3782cae01165e42d30aadf6cd680b1f015d31c785c0e3f278aeabc355546520bc6d1ee2187b263dd997aaaf2813191f37a7c45073f94362c35c9900b043a3d995c73706e00e829526c7d669dfc104a237d308ac78326eaeb98cbf0ee1e99342059c53921be9264efdc4a65fbc8e6589d57a38938de45f2f4fb5e4be80028e4f7913ac2896d236c0a8d5f2458687920bd4f26fa0fe4e11ce04e128a4fa40967fbbe8c16ffda4c045c853960035953c525618883753d5bf5b5a5f90b2de9c105f65ce402cf90469eb83942f13b307fd3c18da3bd803e3add92777c12af07a22866c77fb4a08f37f3e550abac51f97fd1cc10705c0c601013998b949afc57dd793264e2408202ebc1abbf7299825667ce1b12c3c547ea510cb921e533bf8fd3b0ab65fb904cebc0b8f20911342865bb25b344319d1c6330710ec93ec4870cea27fa26198eaa7240601edc34a7fea65ef50d9d4da5c3654c455d0589d02bfed4404fb857a3602f792eab41891f359b5b0b745fbc4dc3b2853028aea07bb6af49ecac0fd5feb030d2a5707ecb1004e8a18ebbbe5aca791ea30d53213584de6916dddbd94c93938abccb58395215d0e918ef1537d9cf1b0e1dbe657636d9405bf409589027c2153d2f5a6d1ea1d1c0002e89ed5565db61222d7d652620d31e632a97b100c29102969ec0eb9c9183d0871bc52d809263abf3a9e52ab2fde8350b46643c5f4d14e8afab96660df887830a09cba530bede84f9868cc4756168348245827f0c3aae964969720f17934539bbfa5f4563229abaf58b754830526a4bf1084a49c16b85dccb6e4532b3d8603c405bc1976174935344e4929ce0e5f4b06b3373ddbb5638f30b94475b63be6b7cb8cf17c838723231e5583106df68575332bb181647be6a0b8d7ff80514fb0823484c86adcd557a776706c723236e34dfcd83a484a0f90527cb0bb99f04db22e2acbec6d367dc4113cbe3bc8f6572a4e3e326ea34a56c8c3a304d515e39fd27ff50bc442616845755870e8e8ce077c7cb1ab9836e8f960a8ee646b3834cb8c6aa432d2f94635a3bd82ec7f5278c0d62d57f01f7d5a701d6c576b839036aba589a2a19a2720c84bfcc1d479572d466fca4c34765d77619d5a4998c1a624aa511b48d6f0b79cd40cc64ada2134aded087e9ab5a4c6149bbf914453ffeac878bc03121b6bddf1b28528e984e0640902d343a37a7bbaed1603b158e0ca17265eb8411a43d57b155d57f51778887d68da1470b4e99591999c4e0d458d44ffe19ab4fb0403b6ecb5d236682ff83cf5e78d4e23e4517eec47d97e89781c7d8f0dd263eac4119c0c8707c5fcff2a15fbb74687ad6fda43a94088b8fd98f6f62b2ac0775a3cca83dac1e4cbbf09de584b40e60e684e819af88158a4e2105d1144326b5dfee80796489f1a6ef7502f7b8e2557f71ecc693bb57709329a1e5f132d353c3f712f8aa220be596ef585c03cb769bcc37f81e5b80a6d696938c109b83da7e23e28b9f6a9693a7cc80be79732b02839f25b0ffd6b74959985dd277f384c10bfcdb1d22ee810e8e83b32eeb062967dbf17fd32cde14ad183a2f9f9b38856e652a75d73f390af7647afc004f000c727914424a1763eab87e91822442deeb4954ad8c132459c5911fe86aa1040ca124da4bb87dec095dde6a974f4b59b35318cb2112da922f52b85a2c9dc99a92bc1ca8e393585faede8bed4453abd06392d76e53283da4309829d8ea522b28629d5245f1b5d90033331d702642864c9d330e030b9411c42040a7dfa8119403faab1fdcf19639034dae497eb80f9b1572473818a8330e42c412c612872d3138752df9d62a49f1851cbcb01a8b3b423040d3155e3402ff2b3fbc4363dd513e9d1b6aa48e9fca0a9292c05bbf27d81adae6d6d33e456183c32c89503fbf972fdb25597364b1fe7215281f2bc4eb7c625dcdb8ee8be9c5ee0308dcab32beda0308b595b56cf0e9d5bb0c2ee63127076e1dc9b79ef5a5883e45cd4e3c3bd7cda3dbbb948401ad1765960d7ab159c27beccfd40ad3b63ee668e45435a91d497138499c21b6ee1e102eff0ff87c4674ce8e216efc8dd441300d55ecab0bc148585103fdefc7a1671c2d031c31af9671fa36bab3168599f311bae6bf69256564dcefe7cd99815464db7b3b00fca36bbb1b11ec59f70d41cb529d66ed4e96b5b285d00d4333fc6ad4b564a555cbd893143c3ca401279db4020ac4992984d07cb50009f00846dafc289949ddba02bbd511a6d9b394ecdd807966310788be83621dba71eb446bd6abc04926ca0f4bf1307fbf6804616f73fda751d4e79264e6afdbb02c2a7a7809ba96ddb678cfcba6482dc711fbb65d5cc3d13f7581b2a4e7da635034840c158c8e21f10615da48b6be1a521e667496668621a95e2f6f5e4c84cb0cf2f3093a279536ba7aa5abf5190606de770d77bbfab967a3e444b2c4e88985e41fc8f68701b737b4d439b75682e4e9a643f3b555b283b7b960cca461b5044e3b39fcafeccded3a67d775a2ff85aa0b85bb6600207045a519d105cd48ac8b00d21e06dca67154832acf751d465aee28d6f41b229233a603904534ac49218a14c91791944301695dceaeea8eb3451ad81d0beacb564b7c49f6028a01c7f9348b22152681f2336c98f184813f8f89a610d1ca9805dc727ae0fbdbbc577631ae40f6781dd8bf452ee4f59a885b7010f0445375141c6dd7ef232b81070caf981edee4b4b3f0c2717f7a2113580a70e1aeb90ab34b85fa72f8089c3018c0ea77ed784335cb5deb961a9bb0eadf5ba72a8e2ba41896b871d8cf23edcacdf4b6acfead0ee2a298b7b17160e838671d30e7e3f62e556d458439bedbbe2dc3c80a4018247b5d432dc88c4fe01ccca4e06033dd41da46f0b689073d04c81fcddff7fa0d91d91c4b67c84a2222c05e97a3574742a11efd5459e345e2f9d20e9ffc90a11388ba714ffc817976af7e7d1f6a90b52dbe93e54d7e55d842f8de6672d4c59e657dcee30e81568adeb2d7ef82e825cbbf6db7b6d8834b0a295ab8d69ac2052011295b6506652a4060228794421b6630cee329ee178f364240036d4eabf589af8a04ff253d66a8302e416287483dc1661e8c6bfb1091b87052b602f91ef48dd34e41767ab8d3617cb76396a2b8842d09c1c51971398f0dbe98628c1c604c32b4e40b07dbec4237b9c6bc39c12b4dfe2ce965331bd77c53625f0a5f93dfa541c92bc45f64f519bcce92e4c541e1c343a2580d9af0027ef23200853764f23d19174d822badb763c8685c1e1ccde48d9dfb12d51a03f700ba77d04974eb3c03296150d7b00455392fdf58ad7f2e7358148f56fac9520c35604b716b5eea00c611cee94257346b809baafe871307dae53b14cc7da72695f4f9e008db9486dd8c09e1be18b48ac85d81564a0ff41751787a1cd3598f57eb8f1d1cec659789427f6b9ec8791160cbddae00af0555b9691773b2f2e9e5c7688856e30b44c8be26ef1afea2b457a3f411fd7b5799d28a53c54c28642955b3163a4f1b17f8e3d8764acb8d4e592dc729543dcabd23bd9bb06d0ffbc12a2472cea3441e6a3ed0f1ae38cbf2b6f2640ad61d3a2fed67824edc31205814ada9f8894686c9c5a90972271b77cc00b1c3d27ada6494204cb2c2db043a1a4cb4cc2ad5d165c926621f547f3ef880b51dfd982a1b7f739ff42b105563d0c5dbc449dce63f226e07d482cd72784eca7aacfe98c3ee0263c77344e0467ac2066bcdf7938b9c793bf71882b3a10b49e40786ed94e1fa351d7cae6265a3ae3331a1ff095a4d29a53cfbc1af116c056c62f1699bf6d54fd865c0568272491f8d64e2741884a6d60a8202cf78120e95a537eaf4d57d8d5a02c819688b251d617b720eefe33c47c0e88a596583328d7d8117cdbb4716556e1564079c3c4bb7f53d60872ae51f76c034e3753bafcfad062604bde52b5ce9dd3a14ce56b183c0c8c0f1fa6c2ac57f02bc6d950e11995b7b3ae9d20903c11cc16d9ee74fb08d26056884e1e9a7bad0f093a5010072b45d3ace3e352075ff5b9c919fc257127fd80121bf8253512542247cec76880fdcf1066075050f8d02a80fbf41257b20141eca1f9295d2107e6acf19770cba1c49808efaa020867cf333255ecd7d049a381e8969596492aa65a453c04e78fb35b4e1d168b70e47c9c1922505c28ee182015de0945f33c4a7840cfc1ecaca0835fd6193a03b23b85d9173f5a6f19aeefc66fa49c0fdb9315b442161bba0e0637be77f20bfedbb731cbdf14ed4f417e284c1e1c89c6197f8dd2dde716ecde961aa7e279dcf7a2e9a79f98c6d21cde96ed44d854c427ec21efb05f2556d6a0a10ba964262ba9389b4e1c376aa419565683c39cdc4a0a581831c36ac4c389a9f0f049c6f2f8842e4846aaad8232811b5a70598adf3cba4984dead39a3f35fd0b09fcff41277a202e6155a37acede7a3f08ff4b3cfa3194c29ebbbf56363b04b45840313de0c7ca07e4b9aeb7994d23dc940fabdd0538e6304df3e21f46f08b15556bfc12b88e0895fae31d20a57e694fc0d18c1e1c6912f7854c7e0eabfc3949dd137cc0a848442b1e1014423324227fe1bf7e4c8f5a0fa6570be05a8d7e1edfef2567bb7bc6fea0765563b32db63b94f12ac0b363da3fb0bca9b46edc160c7fff79adfc40f81fc9378f0143ede46c042caf36aecca14a0b2cbee271818d2301e7874c134bddc9ee2dd9d1bb42c1357c1f5bf644efd56f9de1d239e08acff0a970aba95a4299c6b22575b1a3bdb23e73d58c282c48afeb97d11e275106489eb1919d27c107df0dda5cfbf4c05282fcb72058245122faec224eaf343a2a7213ec058a279661505139ee89c9aef06b0633c950a6fe23ed4ac05e9dfaa76b91da27f0afee0e1c833cbbd7a231a88ee4cb93f6b766411a1b7b2b7430915c1d7753a9a064c9bdfcc4cbd1a51bbcd2c2c7ed796e6fc43337578a3fad5bdb5b6e31c4db4f7db1bb4104ff4072cf4bf52d57729811a28a8d3940ec8d86cdc322c901514a3e7c6d80ed539d242355582b1b91a28acd40d1645e94c6081f341ebde21e0f3803404916bc989a17cbc3cef1c4b4a9d43e8c1def99b0f087a7b78338736db830e186535079cf0be1c65fff9728138a4ea40e831a875c12ea73dcaacab3a99cb94a5b674e5f6355d1a6d9a60dcefc3b2748faec78f90d3acf4b7c9c55d2c6b1e3a53eccf9c4857c5dccc10bbd93524af4e3e5f8f5eacd192a9935d050f0313462e23643dae872f23bf7474da8a9b41f097529b47b7564ff39040833ebb7b4df0ccd910c62a8e87d35d300a5fd5ef6db8a53f654a56c2e1d20dcff7451670b68f2a6ac701d08f82d79a84a9bbf0fe15e5c97a95e66fdd4eefc238067f2274964502cb8ccb7cce546647ebe86e45d0b65ce229d4529b594b982215225968e220205a3d76dfc28015783eb9eab83593dcd9a79de13ccd60a7b101f083eb14b44df3ae88480cc0e6165fc7b423e7e383af104f234a3dfd89cf8c6b0b948958ba5790736e3680331ea5b6213e177fb6f4f224ea268d807d628bbf15b3ca3cb26135b21b324d41fd9efd9e82d64e72b369ccf82f0eac11cb28901ab139620db83d8c1cc63f6281e95728c0112da8a545b299845199d101ffefb721cc5b54e4b885705ee28143997e6a43ab23d692b6d46f175eccb2b0af62c1b6c71fd6e2bf0741b7a00802e65f684f1073d8b5d6119a964d588aace6e8b38e1f24e05612546bb1df499f9a48d100f58733ca64103c33f47f96bf23ce7cc292fc1ead1a01a04876a2962d8bed581d96d14a457794292e39e21c6ce9415aa2cd48ad53e1561eded6480d715588e19b7048d19063d2769bffbbc8ae441a9cfe6a812d72068b791bf8d450c27d0e3d8eb485876a76a7811eb6483d81607a01bf0635782913d26e7ab2e1aec83cc092aadf01bd24732e51668c15b4ce47b155123045b130254cf4185257ae7e032bc7ae7ee8eb9d7697b214a35a6270d4e560167c7b7a815be8e584fa5f73a796e15df14521c8af10abc3cd92f427c1d402f687b6310601c33ce822e0680aabe0c1f60f31f3ce2ac45f5993af29ba12187f5d87ffb929960f88ade39646e85f8fc04653325161184a95395ad9e10cc3ba9aa1c2246cb152e48fef1ccdaa96c901f4a1937787022e8174c75bbca8a03199c0fda51b1d73d11962b19dbe068b206454e5617f31f68f601c30f88d438fb6db7514dd61aaae523a98945e1b76e4d04c2aa5abebd5bca27184f578c36f34b1cda5c99df6c9a3ac68963b5d11a405487ff428c636a315528e1ff275576d83579edd629c6bd60509ddf92140abceb8d64c621241b3386cc82e4ffddbda0f414c8c6adcf784cb2907a9433926f4a864df7e4c5937f8c49515a18ec3aca5b506b34050a87a4dcbd2a13ce6382fda7841d185c496c29bb8c0f8e542629e6d2fa469088ca497a4f9bb7a5175d20b9841b0c84aad759a3e6130f381fc34e4033075554735fd91db4d48eedecf7366a2693cab05d0cc4d3f986c45a40ae6b115658e1d16b5f58662e28c46d62012afce5f188206c591071698dcc6e658ea6b8e820184ffd39cbb87dd3db788b25f4c4feaff204e8a942bc7ee6c0e2e43bf3ff07f63841f7d6ee7eb271b946082bb5de91d9c315451428b451e03b1ac638cd4cd4f3451451bbee38a3befc3d8f0703a15565c3040d780345062e02d4d11ed31f7854a8f211c7da5b640ab6ecf88a3cbe978ca6751c9a699f747357f6da04b7bb0576719b5d205a83a78e0037b588ca991a2ca55d49fd1d69ebdb3bbc19dbbff918e46802d830e09fa528d9e0bff0486ad532ca9599d3d0ede67877fabcbcae61a5e41274e5a800f699028d06a06896015949360811b4b70b632bfd6ed991abdb31214b1323bad00fc676e91de832c6d5bac29bd3641bb80692217c0f02f4eb1c8eb63ae4afddfdf16d2943686a981b0765683264487a7a343a3b171396e43efbcf8744ec9cabdb9aa5432a2f2714a90ca31064bc26f438e1597e10b955eab54aa488d6761258252de125e54c2b475e93d62e66d06d856a8eae124131e6f4f9efd3a553842451185203c7d0103bca3663e2caf5308ba4b8471e1785ab9d1bd764e8869da53cf04d86da5c5786b44b4eba1a3734d75b80264cdc6ed479b4d04bf93c0a4f99d2e6b2ddfdc8bbf2055dcb3f4ca26c66c8c80e408ab2075e29e194e75c8b07e89d0223816f50a3aa134ec7d0d55df6069270e5e16911a6802fabae687880e10c74cc31170a4aef9c7ea5c9103108046c54f3efe98e487d3cefc56cb7558ecb5acba2153fd6c87c2f0e918e26ec79233eb00726b2d83e26fbeb3bbcb7f1fe69e2fe07e01a022f476bf51b663fcaf2b329a772c2a5440bc69c292c5db4334caea2397b4e3ceedc2e0ef91d4232f7c09b458ce0eaea40bdbe581b1bc7050bee6bcdb50c2b9628e12dd17925b3777959f921a2d93a95e72854413ebd6f112d6818a021c9cd6e5469b5e29c34c5057d2756d09e83182c1a8864f16983630fc432f8ca6da659b3d0c4bff84367e974c745eb6c884c7317b16d313b6b1fcdac7fe8fef3ad667f63de0c60f0591bdb327b7fb00f200e730051e0c47c6becf769bc225e6a99bc5c08a87b692365fb9d8be76b360a1c44a8153c6bebd2bd8b516e032e009db089333893da8462e2bf26304c7e505a41ce1ff81f217b4e80a62d513407025b0af4d46d922c9e8f13911b8d027f97af448c6bfc7d9b1c6a891f3e3efc8de5f56e51e3b1b74a10f62a99994df26c2af1e276cadf1c26490be64d77c61c049846e9ce2a41de3633c8e2aee6942019db8db4618be00a19168bac7029476d11b3630500cb718026b4b7232f59cb224c8d16f925d5d5cbcd84fb9c95c33bc101e82e763ae8921977acb0b62874c0e0112b99ddeaaf649a451c04972f8b8542f7d65d92a5ade6914b0f14346fe851a2c63b1b02248b1d00873b17c9797637589b2a9014aac13b6cdbb1a62db591107df0cccd0a196f030d775f836aa7d80ac410ccd6859b8c7dc161e5f04b67fe8440c27fc59f2aa583ab333844fa00be6a075a05bf4319c223630d8d77ae3a1cc5b9cb72bcbd2d381a93d0d54796a92b7fb3aaf3e3b72658855ebd989ec79c9d26622054b5a2e461115c3181bd3b0a55fbd269e231dd2d9b39d1b67bfed3ac9089878c44c7aa4542aa14c5a0c25807556d362140f345827f3a5d80a2b31c0834a9ac0103dd6d525a04ab37c637fd48aaba9641492dfb13d29b6ccff19cd216e5e7766f575800a0fa8bd67ee1d2ff312165f18d7717f1628d71b388d9b021a2a3d9add40b7013300ef896189e46f2f70ee9bfc4a26d119e6f22323c4650cde3bc61283569272b3658ee8cc76b9d4423e0b450f9e72aebb7be1946312b497d9d1a93a346d08330f62f7691e7c56f007d6525871403817bef5a1357434e0f79bdaabd63d4e36129bbbda3f7b9ae067cb3375e2d8f032161ea62e875311fe65b470e5b53357d8189b6a5fdbeb26eaca4b03940820f82931de681e9f7f1c1cf7f8d595bf255688f67e4f1ebd7bcb09c1c138f24656a164f732ce3153f07124f40564605edfb84029996a5e5f34f41b152d5a78e79b22ed267a883dbebc1bfff81a9d769a17d50b83d28032ab716bcd2925a19562a6ff15981e7bd8d00ef4b7a17c22dcf260748f4fb67ebda88e2ac8bd8f6451459253601fae6e7a82c56b160cc60c4d1f2cd34afde5a0ca1a1142644ec8ff7e53392ee023bd17d5dc609bcf8c684ed25ae32d1b6b6c6d447377195c642f46981cbead57964647b737725ce68f9f00e8dc8aaf9126137c0021925b6d75dc34f9cc1b2839147166a92399bcb0ce024495db6296349649a51b226acc9cfe4184ceb334fb1182555d24d0551ef8746dd3295ffe8606edd846921186a39f893b1f520141d9a4a1e9e68dc6153626afacadbda7a1ec3da2f1bdc205e054e67c84c282b5684dbb4721034f3f40c46faf7c985e2ca4cd9f92deb2fd86b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>杂草</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E6%9D%82%E8%8D%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bec95eee7502ce41f038d22897c85d6893020fdd26b8fd6b70d66a2083d490e5">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e7736cf69313dfb1e949bf85217db3350df41ae8ab3f171251ea176a20cf5be752a083112848789a344000841a0399538694e98f25d1f064365fe410a16b722997555979c946bce8b35ede07072ae0529c3d9adb018f1995413998748b67d6f6fc825f3d73c6a7ea05ace98e47e6bf8d6a65857c5add2bece09e8baae4b6791c4761b256e6858b69c3181573586f1adea7fbfa4bbd860792899c8d0f7832266053ae66b6cac810bb98ac54f6f48757a48c72e9a5165952c649072822dc87562ef1cf0836392a6c56c263bf3e1c20ff81a5dd7001362935adbf774b79afa01b5dc2394c2d43a0972d1b20f5d6ddc7a5c3908e99bb940f3dddfb42baded82afaa91fdec2933c32c035187c7a75e1a77d5e8f411c870700437023b4d7c00250f0117c7c78c740b785bc451e1bdbb5707f17a5f4b75f634ed75bc4339c6c9d1ae82dbe2eb8ffe8addba679f58bda60a6194a12020e9a1f1ce2a5e9a3248b855a2aa1fe393eec64f9e1819cb07a44d0cc7fda2d656f6582383ee0a081e53b27e1c712ff5d3444243f343aade60df0ab9759f92e43c9731fca54f2648533dfdc6c0ba0f0bff804c83da00cc4fb632674a7cb0689518c0da77ebd4e8a4681920c6f1331f56d7a38006df8fe6d763bb52c15b5fd1d2666be18683fdbd90e30a5ded98d7fee928a994235213e21fc305f9e3cd841a639b368205b90d4d239780d751f2e4811f63c9cca35534b42085426fc08eddac8e2a7e25dc16103ca14788b818e6433d563ee0263d7f648ecdc769edf7a26ffadcdf6d6c58f7b5afa811e3ff2012f94b184c3d6d687ed7f88ea2328f072f333f521412bf044ed7b2ab756ec7805c51ff023bb563be56d841fffc120e48646d289fbee7fc66e5f966563ee887883a7e6d6bda84143d658b001236cad903bd9129f76f2540beb6cff97c8e78b3b0437a3478bf9b1f6e665abb8a3dce17623a0da69474da4a5cf48a778f780943a8f0fa30fc7ed5a87e0a4c52de448b87290455bd167044b6279d82129427e49c55d88185bde276a2921e04f10e67405a86b7bc72635c9c683f3f6af62392fa274a3a11e44dabd8777617585c6da93ffa9dc86ed8fbd80ce84b9a4efb1dd618b703f44d11c3dc8f4a57cf98fb542294d4415c4fbb1fcdddcbcb5747e85167acf29e936e918b158eeab84e97d5274c66b688ef0cc6aed6387dcfff49251b82472e2c65ccdddd0f828ac5e56b987acc8e642b32960f955ee29deb822dbdb6c91a1f418c16331914a0480172b5e33cd5a19b3f54a27af30b6511936f984004c7d7e0631f9ff4c71183d2f96ce380ca62d732804633d82ef787d191b0f56d86f7e326228f1d3b333b26fdfabd300e757cd68acee0215c1a0f8ac4b889463932a873cfbcd9e188cccfe93698b40ebd10356e986e293b127a410428ef20bae42fdcfb0e886af890f5801dec1265c9e67008456bb5119184e4366c4b1cf9433d81d274fc1a0094f891ac8f34e522902d01a21e85ddd7b34040b89e5fc770c31e8ca6816df7140038e4aa78975d528cc788c04fd873100d46385d5ba7f32c27f60e42dbc932cd2704bb5fd0457970c449b9a3b13071fd50b5b1aadb6424519977587fa81f9cd6f2bbe81dbf03fd22fcf9ba83f3fb4b2bc0223e68edb4a1a1cfa50fecda6e3ea1eddb25fa3ea44952927297e9e4e6055f479a28d75dbd1fdd56d0fa1136ca6e4d969b8ef00bdc21eeb5c4c9c840644dc24255df3e234c192b1145ee5df4e85ccaef104f6e912d2d9de9e494423cf0142ad0470c82b7949c04be20f1664d9c43dfe17440928b582deff1b4fc96df6c84639c95726eaf9359b5a12e0ef0a7760147aaefdbcf75fad4a79e32ade9a54056ebcd3e59da7f133686ab327dec929f76b28da2bc270614c5476358e28870d9015a5617c9d2f72ce5d1238a6eb236ab5539618f9d7b84b0207d4554f48974ec1d6972c4c73c8c6d20c1917a124d214ae760bd4aa2c732425d226e73ed3bbd640cf5df268fb9a612d5b8edf9da0ac63c905ef9163d1ca383b2b5cbe7149f84dad7f02209364a7108275f5ffffc142ebdfe9b25f264f95423cc7ad61cc392d81baaab7523341527e5adac860385b3f8accebf01f7cf4247d7016a254763b9904ca02ef02e19e5bf7e942bec2e4a96bc8bd5ad55ad554a10c10c6c4a9038c2741615ef3c91dd2821ec616bc9b7d96b9d2effdb51884aaac288ba56b0863ed10480b127a945504e598e1ba0a877e5fd522427bfd7d5077ea53565612040efb1087aee847547e671672edf215b518cd8021f62c10b5571ff99752714fda55fe43972a69770db8b05d770aff1e35f020828a6e0aa433e245075c0105ee8149cd1dc7041c5650a8edd8882b1fe9234bd6047a844ff2521eeb9fbb63c0729512ab14b24a5821739a086fd68749637621a8ca818424051239f487e7b930c4bce58a5414648ab0fe689577a30d969f25a3642c2c9ff7fbd532fa6dce1f6bedf9e4e6c9ed03c1a393800d982728cf89c1a5d20d3379c698c99edd028112147f58148b9cd8e2bf703a1a7f7c26e4b6833129b8596d4f4d58f56b32443f6d0ab69b68d3dbecc14803bb611fb2fb7f8234f45916cb1f3dd594258e874b412f74fcb1a2734b72b46a101ab8ba3aeaf34f97926e3cc5519e46baf066709717049c55dab02e64cfd85c2654dbf16aa6a10602725c822c77ab8c3441e88584633b6930fb069c6c432bb188ff9fe553907b387d0c9ba7ee85a611a3d34a3ed95f50fba1564a120cc1be6b9647d4523cbca9b3007bf2428e6e2d7fcae956bfbd8969363bf28a2d13af2632e09470f5bf45944f044e9128b958cc389e20cdc5abee2725ab3c9043578b22e92b7069cd7de3117c50ac4423c6a8d77fb3997fa955dbb5027ce5c3d7b0efbf67a51849a34e27805f65badf43cd5ab004b77e904f6f0dedef4c1a2d84a9cbc511c6d30f97d2688641e31f50d1dff93388bd214a9ab226b3c238bbb1db17b6a7eabb9ce139d55197b707a181fa4e687c4860f1e07d74b5e436e08599068f04fdfc701cefc825ee9ddd12593586ef34d26e5f4009bd293f24dfc3398d45882fdb86eea60bca3a1cb9bb86d97e03e59b60f8187368a6cfe425b9793a242be34914b8a0f9475530ad967778af56b82b1237629f1bcfabb266e627cef31c10a89f42291032a72c824654f24b711bbcf1f652928f66bdce260a5589c8a618bdd3712e52e46b2f0d8bce0370dabdae2217e2868ab16f04fd8d725946dd813860040a89cc1b86b442432a63b5596af120f51fdf863443ea4bb65b09ed53a9cf0ac6e0eb042f37f201ad1087d098463fe3dfd1d9a22351f759ea2c3b9960cf5a04bf412a44b89118aadb22c5a139bbd66681c048a71a73a2b73f22fafaf1d2fbf07a24dc2ecb1b11a828c3b5f9693399a9c9117028764c8a5b8d7d10c5979b37a43240c952768c6d2c5c896e614b4922d46d23e62bbfe91176b8072113d5c3eed5ee84cefbb633083b64a2c8f1ee1ef48c859aa4a70a6e38efee4e0974bef323b8c4aa5ad2dc870681678b93c288802f79b66afb9b154ac3cdea7ea91b754ea10d70322d1fea58ca4b4c006ef7ff87d142ddb97744135e08485bae3ecf3807aec75c624ef3e016d48d215e4b780351b44312d5b95fd6a88daf4e6afcc298d93ca6f62e97c590cadae130a2a40b93a4e5e98cf679be18171ecba7073aa8c79eab896cb279261243078ace454da745f984e6dcdf82967aa059f6a4815a9b407b75036d61a498860c526b7f0bc7c848c7947a2e15ed552d12c3544ad5abe3a5f4976e02f61ebe997dfeea07626fb8fa21f43fcd7eb2d899a5d503e25106b8b6949f87ad519e9f9da7794116682fb72fe350b5c9445158a17fec89a1a8833d5eed32212accb1bf466b7cefd4b555b8f81476cbe1734ffcc457a08c393912d5b4b90fb9af897ab203a07b50d006a398eca639768b9747d32d6980ca809fe05bdf656ec858537f7ef836941e64a914ca0fdec52ae92a4fe0628aadc515052d59913f1d5caaa8fd80fca4d8185ca0b5a76b1e88beac1fc31fc2a0ac99a1562ea338e6cbf12337e29ed04c28b211923a3c3f7e229d4fe508b151faa5a04feb7840a0ada3ebbdbdcc3d50c8bd08b98b2bac1a6403576c565326a6c1910539cd9432a59f97c708c8d11ba5dff03c4fd487bc1e7deb8b5d2eeee3c82842190475f1ef516ab1fc5b9301aa151ee9b7ae50b120be755ce06ec0549a127e4cd61c4982d2400c57c0e37d239af37ebcef222db623d6a3d02da799b1f29971c93e0406fe850dbca533cce76fc2e2b569f916326b766692ef87197448bb6916de7675d030fd58264615f8741de892393cd58e96c11427662256dc638296f6160ce6170aebe7f2adcfad7c54b8e81149cb7b6b11c12035db75a6e61fa804ee4bb0372ed10f7fbcdd0db2d5f137ee4c9746428394c31914746756bd6abda4160426c956f0aef1f2282fa833c1eafc10e8c8fb9e23fcade9e058cad9edd17397284888e11d45da3ca7f47be7907a7db1a5838c618b84dabb40cbb9416a5204e9e0a0b993239af309da0696fd3432a805c786945f27c5292ad08a71c981c27de9c7bbc33adb7e8fc58bda040babe3f6720f965b23ed7c8bebf103e59841f6c5b545d8cca2baacc256f408eea7cb3326fb9c0f4c78f21fab323060f454298b778669451aceecc4a40b83271bac49129792efd906385868a4fda8afca56d057463406e8849e4d29e58f12d0f590ed9d91702b1d851b4d6af258330743f533a60280cb91db05396e5d0f1f7d56c2184913c183317fdc4edab061368d651bf410c12a346346de18fb5130a91569f906ad2c644fa2dea583f3aae7ec3d8e974834faf371927470d4ed18ec28ee82d5fc1f84645afe593eb5c26f52e308daec34eda46b7e6918da13429e20d07886e885fd74062849050ecf9a6669377470ac9f890f38b1b4c55c83ab9d7b549ee6df88e44fdf7e29f53bb68e7162a7d606ef0cb0151569908537c286e0efa107210ca4592d4ae6018ffe6a09b499e9202813cc04851494f04ee7ede11a8804eafdb7c9d0fdec4282fa24e52894cd0b5108b1f22c2dfbd7cf</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>被轮子创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%BD%AE%E5%AD%90%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>2024的烟台一模数学压轴题是一道新定义题,是说证明<a href="https://baike.baidu.com/item/%E6%91%86%E7%BA%BF/5893005">摆线</a>上一点$M ( x _0 , y _0 ) $的切线的倾斜角为$\theta $,求证$\frac { 1 + \cos 2 \theta  } { y _0  } = 1 $.在这个题下选用的参数方程是$x = t - \sin t , y = 1 - \cos t $.</p>
<p>这个怎么做呢?我的文化课同学们纷纷使用强大的隐函数求导技巧把它杀穿了啊.可惜我不会隐函数求导,我只会链式法则.但是我考场只记得链式法则怎么用了而完全忘记了这个东西为啥是对的,所以就有了这篇复健博客.</p>
<p>首先来复习一下微分$\text { d  } y $的定义啊,下面这段抄自我原本的高数笔记:</p>
<p>考察$\Delta y = f ( x _0 + \Delta x ) - f ( x _0 ) $,不妨假设$f ( x ) $在$x _0 $处导数存在,自然有$\lim _{ \Delta x \rightarrow 0  } \frac { \Delta y  } { \Delta x  } = f ‘ ( x _0 ) \ $.考察$\eta ( \Delta x ) = \frac { \Delta y  } { \Delta x  } - f ‘ ( x _0 ) $,显然$\Delta x \rightarrow 0 $时$\eta ( \Delta x ) $是一个无穷小量.</p>
<p>那么,我们自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta y & = f ' ( x _0 ) \Delta x + \eta ( \Delta x ) \Delta x \\
& = f ' ( x _0 ) \Delta x + o ( \Delta x ) , \Delta x \rightarrow 0 
\end{aligned}</script><p>同时,如果我们有这个式子,可以两边同时除以$\Delta x $以证明可导.</p>
<p>这就将一阶导数转化成了无穷小量的形式,我们借此给出微分的定义:</p>
<p>设$y = f ( x ) $在$x _0 $处有定义,假设有一个常数$A $使得$f ( x _0 + \Delta x ) - f ( x _0 ) = A \Delta x + o ( \Delta x ) , \Delta x \rightarrow 0 $,称$f ( x ) $在$x _0 $处<strong>可微</strong>,并把$\text { d  } f = \text { d  } y = A \Delta x $称为$f ( x ) $在$x _0 $处的<strong>微分</strong>,由于后半部分是一个更高阶的无穷小量,我们说微分是函数改变量的线性主要部分.这个时候结合导数极限的定义,就可以得到$\text { d  } y = f ‘ ( x ) \text { d  } x $,$f ‘ ( x ) = \frac { \text { d  } y  } { \text { d  } x  } \ $.这就是我们将导数称作<strong>微商</strong>的原因.</p>
<p>一阶微分具有<strong>形式不变性</strong>.换言之就是,我们在求导的时候是需要选定一个自变量的,当选定的自变量是$y $的时候,根据上面自然会有$z = g ( y ) , \text { d  } z = g ‘ ( y ) \text { d  } y $.</p>
<p>但是当选定的自变量不是$y $的时候,上面的形式是同样成立的.我们下面证明这个结论,令$y = f ( x ) $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
[ g ( f ( x ) ) ] ' & = g ' ( f ( x ) ) f ' ( x ) \\
\text { d  } z & = g ' ( f ( x ) ) f ' ( x ) \text { d  } x \\
\text { d  } z & = g ' ( y ) \text { d  } y \\

\end{aligned}</script><p>必须提出高阶微分不存在形式不变性,换句话说,$z = g ( y ) $的二阶微分的形式不等价于$z = g ( y = f ( x ) ) $的二阶微分,你不能乱换元.</p>
<p>根据上面的操作,我们很自然引出了链式法则,也就是:</p>
<script type="math/tex; mode=display">
\frac { \text { d  } y  } { \text { d  } x  } = \frac { \text { d  } y  } { \text { d  } t  } \frac { \text { d  } t  } { \text { d  } x  } = \frac { \text { d  } y  } { \text { d  } t  } \frac { 1  } { \frac { \text { d  } x  } { \text { d  } t  }  }</script><p>这样上面的题就可以迎刃而解了.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被豌豆创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%B1%8C%E8%B1%86%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>在YT2S 2021级生2课上有一个著名的open problem,也就是在计算自由交配的时候能否拆开考虑,下面我来尝试写一点自己的理解.</p>
<p>首先来看两个问题(前置条件均为孟德尔第二次杂交实验):</p>
<ol>
<li><p>将F2中双显性植株自由交配,求后代表现型及比例.</p>
</li>
<li><p>将F2中单显性植株(包括两种单显性植株)自由交配,求后代表现型及比例.</p>
</li>
</ol>
<p>为了方便笔者书写,不妨设这两对基因是$A / a $和$B / b $.</p>
<p>先来看第一个问题,双显性植株中应该有:$\frac { 1  } { 9  } AABB , \frac { 2  } { 9  } AABb , \frac { 2  } { 9  } AaBB , \frac { 4  } { 9  } AaBb $.先让第一组基因自由交配,也就是只看$A / a $,我们有$\frac { 1  } { 3  } AA $和$\frac { 2  } { 3  } Aa $,产生$\frac { 2  } { 3  } A $和$\frac { 1  } { 3  } a $配子,得到$AA : Aa : aa = 4 : 4 : 1 $,也就是$A _ : aa = 8 : 1 $.对另一对也这么考虑,最终得到$A _ B _ : A _ bb : aaB _ : aabb = 64 : 8 : 8 : 1 $.</p>
<p>非常合理且简洁对吧,但如果你同样拆开考虑第二个问题,会发现这么做是错误的.</p>
<p>我们生物老师LL老师给出的解释是,单显性植株的个体是$A _ bb $和$aaB _ $,它们的基因型并没有组合的非常彻底,也就是并没有出现$aabb $和$A _ B _ $个体,导致不能乱拆开.</p>
<p>而直觉上感觉这个东西和独立性有关对吧,我们来简单证明一下:</p>
<p>约定$X $是$AA , Aa $或$aa $,$Y $则是$BB , Bb , bb $,那么:$P ( XY ) = P ( Y | X ) P ( X ) $.如果可以拆开,那么$P ( XY ) = P ( X ) P ( Y ) $,于是有:$P ( Y | X ) = P ( Y ) $,也就是这两种基因型互相独立就行,老师说的对啊!</p>
<p>如果只是这样就水了一篇博客非常无聊对吧,能不能证明一点更好玩的结论呢?</p>
<p>考虑设产生四种配子$AB , Ab , aB , ab $的概率分别是$x , y , z , w $,其中$x + y + z + w = 1 $.</p>
<p>使用生成函数技巧,配子法给出的答案应该是:$( x  AB + y  Ab + z  aB + w  ab ) ^2 $,而拆分再乘起来的答案应该是$( ( x + y ) A + ( z + w ) a ) ^2 ( ( x + z ) B + ( y + w ) b ) ^2 $,其中$A , B , a , b $均为形式幂.</p>
<p>如果两边相等,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x \ AB + y \ Ab + z \ aB + w \ ab ) ^2 & = ( ( x + y ) A + ( z + w ) a ) ^2 ( ( x + z ) B + ( y + w ) b ) ^2 \\
( x + y + z + w ) ( x \ AB + y \ Ab + z \ aB + w \ ab ) & = ( ( x + y ) A + ( z + w ) a ) ( ( x + z ) B + ( y + w ) b ) \\

\end{aligned}</script><p>两边展开,就可以知道它的充分必要条件是$P ( ab ) = P ( a ) P ( b ) $,也就是产生$a $和$b $的配子概率是独立的.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被蝴蝶创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%9D%B4%E8%9D%B6%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>事情是这样的,很久很久很久以前,我做了一个圆锥曲线压轴题,大概就是椭圆$x $轴上蝴蝶定理硬算题给我整傻眼了.今天我闲的没事乱想突然意识到椭圆可以仿射变换到圆来解决,那么圆肯定有很优美的做法了吧!</p>
<p>然而我瞪了半天也没看出来,没办法最后拿联消判韦把圆的结论搓出来了.</p>
<p>这个时候我又想看看其它的圆锥曲线,发现双曲线好像有点不太会,因为我不是很懂双曲线的内部是啥,然后我发现抛物线的蝴蝶定理更加优美.</p>
<p>所以我就把这一坨东西出了思考题,下面是整理.</p>
<h3><span id="约定">约定</span></h3><p>下文称$A , B , C $三点满足蝴蝶定理,当且仅当A,B,C三点都在圆锥曲线内部,并且过A的直线与圆锥曲线交于$P , Q $两点,$PB , QB $分别与圆锥曲线交于$P ‘ , Q ‘ $两点,而且$P ‘ Q ‘ $恒过$C $点.</p>
<h3><span id="抛物线">抛物线</span></h3><h4><span id="定理1">定理1</span></h4><p>对于任何一条抛物线$y ^2 = 2 px $以及与其内部一点$A ( a , 0 ) $,过$A $点与抛物线相交的两个点的横坐标之积等于$a ^2 $.</p>
<p>证明:联立即可.</p>
<h4><span id="定理2">定理2</span></h4><p>对于任何一条抛物线$y ^2 = 2 px $以及其内部的三点$A ( a , 0 ) , B ( b , 0 ) , C ( c , 0 ) $,三点满足蝴蝶定理当且仅当$b ^2 = ac $.</p>
<p>证明:由定理1,我们有:</p>
<p>x_Qx_{Q’}=b^2\\x_{P’}x_{Q’}=c^2\end{cases}</p>
<p>简单解一下就可以.</p>
<h4><span id="定理3">定理3</span></h4><p>对于任何一条抛物线$y ^2 = 2 px $以及其内部的两点$A ( x _a , y _a ) , B ( x _b , y _b ) $,要么存在一个点$C $使得$A , B , C $三点满足蝴蝶定理,要么$P ‘ Q ‘ $的斜率恒定.</p>
<p>证明:</p>
<h5><span id="引理">引理</span></h5><p>如果一条动直线$Ax + By + C = 0 $中,$A , B , C $满足一次方程$pA + qB + C = 0 $,那么这条直线肯定过定点$( p , q ) $.</p>
<p>而如果可以找到一个参数$t $,使得可以做到将$A , B , C $分别表示为$f ( t ) , g ( t ) , h ( t ) $的形式,其中$f , g , h $都是关于$t $的一次函数或常函数,那么这条直线要么过定点,要么斜率恒定.</p>
<p>对于$P ‘ Q ‘ $这条直线,这个$t $相当好找,可以是$k _{ PQ  } $,可以是$y _P y _Q $,可以是$y _P + y _Q $,然后带入简单检验一下即可.</p>
<h3><span id="圆">圆</span></h3><h4><span id="定理坎迪定理">定理(坎迪定理)</span></h4><h5><span id="特例">特例</span></h5><p>对于任何一个圆$x ^2 + y ^2 = r ^2 $以及其内部三点$A ( a , 0 ) , B ( b , 0 ) , C ( c , 0 ) $,若三点满足蝴蝶定理,当且仅当$( a + c ) ( b ^2 + r ^2 ) = 2 b ( ac + r ^2 ) $.</p>
<h5><span id="通解">通解</span></h5><p>对于任何一个圆,我们有下图(图源自百度百科)</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ah1ipl9o.png" alt></p>
<p>那么$\frac { 1  } { GP  } - \frac { 1  } { HP  } = \frac { 1  } { AP  } - \frac { 1  } { BP  } $.</p>
<p><del>该定理的几何/代数证明好像都略麻烦,笔者决定开摆</del></p>
<p>@Querainy 牛逼,下面给出他提供的曲线系<a href="https://www.luogu.com.cn/blog/uakioi/qu-xian-xi">证明</a>:</p>
<p>我们尝试把这个做法拓展到坎迪定理上.</p>
<p>照葫芦画瓢,设圆心为$( x _0 , y _0 ) $,得到$( CE , DF ) : ( 1 + \lambda k _1 k _2 ) x ^2 - 2 x _0 x + x _0 ^2 + y _0 ^2 - r ^2 = 0 $.</p>
<p>此时,$| AB | = \sqrt { r ^2 - y _0 ^2  } $,$| AP | = | AB | - x _0 , | BP | = | AB | + x _0 $,$\frac { 1  } { AP  } - \frac { 1  } { BP  } = \frac { 2 x _0  } { r ^2 - y _0 ^2 - x _0 ^2  } $.</p>
<p>而$\frac { 1  } { GP  } - \frac { 1  } { HP  } = - \frac { y _1 + y _2  } { y _1 y _2  } = \frac { 2 x _0  } { r ^2 - y _0 ^2 - x _0 ^2  } $.</p>
<p>笔者后来思考了一下为什么这个是二次曲线系啊.</p>
<p>我们考虑求过四个定点的二次曲线系,不妨假设这些二次曲线均为$Ax ^2 + By ^2 + Cxy + Dx + Ey + F = 0 $\\</p>
<p>带入四个定点坐标,就可以得到关于$( A , B , C , D , E , F ) $的四个方程.不妨先假设这四个方程线性无关.那么就有两个自由元,那么方程的任何一个解,就可以表示为两组线性无关的特解的线性组合.</p>
<p>注意到两个二次曲线线性相关,当且仅当它们是同一条曲线,这就证明了二次曲线系的正确性!</p>
<p>那么怎么证明这四个方程线性无关呢,不太会啊,这次真摆了.</p>
<h3><span id="椭圆">椭圆</span></h3><h4><span id="定理1">定理1</span></h4><p>对于任何一个椭圆$\frac { x ^2  } { r ^2  } + \frac { y ^2  } { d ^2  } = 1 ( r &gt; d ) $以及其内部三点$A ( a , 0 ) , B ( b , 0 ) , C ( c , 0 ) $,若三点满足蝴蝶定理,当且仅当$( a + c ) ( b ^2 + r ^2 ) = 2 b ( ac + r ^2 ) $.</p>
<p>证明:</p>
<p>注意到圆的坎迪定理的特例,然后发现我们如果将椭圆的纵轴拉长使其成为一个圆,换言之就是对椭圆进行仿射变换,那么$A , B , C $三点坐标不变并且仍然满足蝴蝶定理.</p>
<h3><span id="其它">其它</span></h3><p>众所周知,极点极线有一个经典内切四边形结论,其实也就是所谓的完全四边形啊.</p>
<p>给张图,</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9uzi7mgg.png" alt></p>
<p>其中$G , D , H , A $成调和点列.</p>
<p>我们冷静一下,注意到$( AF , AE ) $就是一个二次曲线,而且$F , C , B , E $是二次曲线上四个点,所以这个还可以用曲线系方程来证明这四个点成调和点列,非常有实力.</p>
<p>当然,为了应对文化课,我们有更加简单的证明完全四边形调和点列的做法:</p>
<p>不妨设$d = \frac { BC  } { EF  } $,令$\vec { e  } = \vec { AE  } , \vec { f  } = \vec { AF  } $,则$\vec { AD  } = \lambda _1 \vec { e  } + \mu _1 d \vec { f  } = \lambda _2 d \vec { e  } + \mu _2 \vec { f  } $,对比系数得到两个方程,再加上$\mu _1 + \lambda _1 = 1 , \mu _2 + \lambda _2 = 1 $,立刻解出结论.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被炮弹创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E7%82%AE%E5%BC%B9%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>高中物理的时候有这么一个题,然后今天刚好信物讲到了,顺手来总结一下.</p>
<p>先来个简单版本:我从一个点打炮弹,目标与我的距离为$x $,且目标比我高$h $,问以什么样的角度打出炮弹能使得击中目标并且初速度最小.</p>
<p>我们当然会第一反应认为这是一个很简单的问题,考虑$t = \frac { x  } { v _0 \cos \theta  } $,因为我们很容易写出方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x \frac { \sin \theta  } { \cos \theta  } - \frac { gx ^2  } { 2 v _0 ^2 \cos ^2 \theta  } & = h \\
\frac { 1  } { v _0 ^2  } & = \frac { 1  } { gx ^2  } ( x \sin ( 2 \theta ) - h \cos ( 2 \theta ) - h ) \\
\frac { 1  } { v _0 ^2  } & = \frac { 1  } { gx ^2  } ( \sqrt { x ^2 + h ^2  } \sin ( 2 \theta - \varphi ) - h ) , \varphi & = \arctan ( \frac { h  } { x  } ) 
\end{aligned}</script><p>只需要对后面那个东西用辅助角公式就可以了对吧,非常简单啊!</p>
<p>然而,我们稍微改下题面:</p>
<p>我从一个高度为$h $的点打炮弹,初速度确定为$v _0 $,问以什么样的角度打炮弹能打得最远.</p>
<p>这有啥区别啊,只需要改个正负号就行了是吧,让我们看看:</p>
<script type="math/tex; mode=display">
\frac { 1  } { v _0 ^2  } = \frac { 1  } { gx ^2  } ( x \sin ( 2 \theta ) + h \cos ( 2 \theta ) + h )</script><p>这下发现问题了,这个$x $根本拿不出来啊.</p>
<p>重新按部就班,发现只能用求根公式得到$x $的表达式,更进一步地,我们有:</p>
<script type="math/tex; mode=display">
x = \frac { v _0 \cos \theta ( v _0 \sin \theta + \sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  } )  } { g  }</script><p>怎么办呢?yth老师给出了一个想法是使用柯西不等式,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x & = \frac { v _0 \cos \theta ( v _0 \sin \theta + \sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  } )  } { g  } \\
& = \frac { v _0 \sin \theta v _0 \cos \theta + v _0 \cos \theta \sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  }  } { g  } \\
& \leq \frac { 1  } { g  } ( v _0 \sqrt { v _0 ^2 + 2 gh  } ) 
\end{aligned}</script><p>当且仅当$v _0 ^2 \cos ^2 \theta = v _0 \sin \theta \sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  } , \frac { 1  } { \tan ^2 \theta  } = \frac { 2 gh  } { v _0 ^2  } + 1 $的时候取等.</p>
<p>还有一种策略是考虑对隐函数求导然后令$\frac { \text { d  } x  } { \text { d  } \theta  } = 0 $,这样得到情况会和我们一开始的初始问题得到的答案相等,也就是当$\tan ( 2 \theta ) = - \frac { x  } { h  } $的时候$x $会取极限.这也很好理解,因为我们如果当前的速度没有用到极限打到最远,总能调整使得得到一个更小的速度打到当前的距离,因此距离还有提高的空间.</p>
<p>有没有更聪明一点的办法呢?</p>
<p>我们注意到初速度是定值,根据机械能守恒定律,末速度的大小一定是个定值,我们考虑:</p>
<script type="math/tex; mode=display">
\vec { v  } = \vec { v  } _0 + \Delta \vec { v  }</script><p>通过机械能守恒定律可以算出$| \vec { v  } | = \sqrt { v _0 ^2 + 2 gh  } $.</p>
<p>注意到$\vec { v  } $和$\vec { v  } _0 $的水平方向分速度是相同的.然后有一个天才的想法是,考虑上述那个向量式的三角形法则,设那个三角形的面积为$S $,注意到$\Delta \vec { v  } = gt $,而$x = v _0 \cos \theta t = \frac { 2 S  } { g  } \leq \frac { v _0 \sqrt { v _0 ^2 + 2 gh  }  } { g  } $,也就是面积最大的时候应该是$\vec { v  } _0 $和$\vec { v  } $夹角为$\frac { \pi  } { 2  } $的时候.</p>
<p>直接从形式上来看:</p>
<script type="math/tex; mode=display">
\frac { v _0 \sin \theta v _0 \cos \theta + v _0 \cos \theta \sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  }  } { g  }</script><p>我们知道正交分解的时候从结果上来说可以作分方向的动能定理,因此初速度是$( v _0 \cos \theta , v _0 \sin \theta ) $,末速度是$( v _0 \cos \theta , - \sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  } ) ) $,因此$x = \frac { \vec { v  } \times \vec { v  } _0  } { g  } $.</p>
<p>这个想法过于震惊了,以至于我在之后多次回忆起这个题,想去找到初速度与末速度叉积的物理意义.但直到如今我也没有完全理解这个做法.</p>
<p>写到这发现没活整了,顺便在这写一下另一个斜抛题:</p>
<p>抛射质量为$m $的小球,抛射倾角为$\theta $,初速度大小为$v _0 $,所受空气阻力$\vec { F  } $与速度$\vec { v  } $的关系为$\vec { F  } = - k \vec { v  } $,其中$k $为固定系数,求小球在空气中运行的轨迹曲线.</p>
<p>考虑$\frac { \text { d  } \vec { v  }  } { \text { d  } t  } = \vec { a  } = \frac { \vec { F  } + \vec { G  }  } { m  } = \frac { 1  } { m  } ( - k \vec { v  } + m \vec { g  } ) $.</p>
<p>于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text { d  } \vec { v  } & = \frac { 1  } { m  } ( - k \vec { v  } + m \vec { g  } ) \text { d  } t \\
\int _{ \vec { v  } _0  } ^{ \vec { v  }  } \text { d  } \vec { v  } & = \int _{ 0  } ^t \frac { 1  } { m  } ( - k \vec { v  } + m \vec { g  } ) \text { d  } t \\
\vec { v  } & = \frac { - k \vec { x  }  } { m  } + \vec { g  } t + \vec { v  } _0 \\
\begin{cases}
\frac { \text { d  } x  } { \text { d  } t  } = \frac { - kx  } { m  } + v _0 \cos \theta \\
\frac { \text { d  } y  } { \text { d  } t  } = \frac { - ky  } { m  } + v _0 \sin \theta + gt 
\end{cases} 
\end{aligned}</script><p>对于第一个式子,令$w = \frac { - kx  } { m  } + v _0 \cos \theta $我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { - m  } { k  } \frac { \text { d  } w  } { \text { d  } t  } & = w \\
\frac { - m  } { k  } \int _{ v _0 \cos \theta  } ^{ w  } \frac { \text { d  } w  } { w  } & = \int _{ 0  } ^t \text { d  } t \\
\ln ( \frac { \frac { - kx  } { m  } + v _0 \cos \theta  } { v _0 \cos \theta  } ) & = \frac { - k  } { m  } t \\
\frac { - kx  } { mv _0 \cos \theta  } + 1 & = e ^{ \frac { - k  } { m  } t  } \\
x & = \frac { mv _0 \cos \theta  } { k  } ( 1 - e ^{ - \frac { k  } { m  } t  } ) 
\end{aligned}</script><p>同理解出$y = \frac { m  } { k  } ( ( v _0 \sin \theta + \frac { mg  } { k  } ) ( 1 - e ^{ - \frac { k  } { m  } t  } ) - gt ) $.</p>
<p>综上参数方程是:$\begin{cases}x = \frac { mv _0 \cos \theta  } { k  } ( 1 - e ^{ - \frac { k  } { m  } t  } ) \ y = \frac { m  } { k  } ( ( v _0 \sin \theta + \frac { mg  } { k  } ) ( 1 - e ^{ - \frac { k  } { m  } t  } ) - gt ) \end{cases} $.</p>
<p>轨迹方程是:$y = ( v _0 \sin \theta + \frac { mg  } { k  } ) \frac { x  } { v _0 \cos \theta  } + \frac { mg  } { k  } \ln ( 1 - \frac { kx  } { mv _0 \cos \theta  } ) $.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被火车创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E7%81%AB%E8%BD%A6%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>为啥这篇文章总是传不上去???</p>
<p>为啥这篇文章总是传不上去???</p>
<p>事情是这样的,几天前,我们班被出了这么一道物理思考题(为表述方便略有简化).</p>
<p>有一辆以$v _0 $行驶的质量超级大的火车,上面站了一个质量为$m $的人随火车一起运动.突然，这个人相对于火车以$\Delta v $的速度向前平跳(也就是说此时他相对于地面的速度为$v _0 + \Delta v $),求这个人做这个起跳需要多少能量.</p>
<p>注意这里火车质量很大,所以火车在此人跳跃过程中始终以$v _0 $速度前进.</p>
<p>我看到这个题觉得很简单啊,肯定是$\frac { m  } { 2  } ( ( v _0 + \Delta v ) ^2 - v _0 ^2 ) $.然后发现答案竟然是$\frac { m  } { 2  } ( \Delta v ) ^2 $.</p>
<p>下面是我们物理课代表给出的解释:</p>
<p>虽然人的动能变化确实是$\frac { m  } { 2  } ( ( v _0 + \Delta v ) ^2 - v _0 ^2 ) $,但是在他起跳的过程中,火车对他是有一个力的.而且,因为火车在运动,所以虽然起跳的时候人相对于火车没有运动,但这个力的作用点相对于地面竟然是运动着的!</p>
<p>因此,不妨设这个力为$F $,注意这里的$F $不一定是常数,而是一个关于时间$t $的函数,我们自然有:$W = \int _{ t _0  } ^{ t _1  } Fx \text { d  } t $,注意到作用点的速度恒为$v _0 $,因此$W = v _0 \int _{ t _0  } ^{ t _1  } F \text { d  } t = v _0 \Delta p = v _0 \Delta vm $,把这个加上后恰好得出答案.</p>
<p>这时我意识到这个事情其实就等价于任何惯性参考系参考下能量都是守恒的.所以我们直接以火车为参考系,立即得出答案.</p>
<p>但是为啥呢?而且我总觉得上面那个力的分析非常诡异,因为我总感觉起跳是瞬间的,这个力理论上不应该做功啊.</p>
<p>通过在网上海量搜索后,我大概找到了这么两种理解方式啊.</p>
<p>第一种是,我们冷静一下.如果没有外力干扰,那么火车其实<strong>并不能匀速前进</strong>.设火车质量为$M $,当人的速度为$v _0 + \Delta v $的时候,根据动量守恒,火车的速度应该为$v _0 - \frac { m  } { M  } \Delta v $.</p>
<p>注意这个时候不能以火车为参考系了,因为火车不再是惯性参考系了,所以我们加入一个以$v _0 $匀速前进的青蛙作为新的参考系.不难发现在青蛙参考系和在地面参考系下,火车和人的系统的动能增量是相等的,都是$\frac { 1  } { 2  } ( m ( \Delta v ) ^2 + M ( \frac { m  } { M  } \Delta v ) ^2 ) $.</p>
<p>然后,因为火车质量非常非常非常大,我们注意到$\lim _{ M \rightarrow + \infty  } \frac { m  } { M  } \Delta v = 0 $,完活.</p>
<p>但是这个过程别说还是进行了近似估计了,就是和现实也不符啊.你火车肯定要有动力来源使得其能进行匀速直线运动.但是这个理解方式的优越性在于,它试图将火车和人视作一个系统来观察,这个角度下我们完全不要去管二者分别的动能了,而是直接分析系统动能.</p>
<p>所以我反思了一下为什么我觉得一开始的那个做法很奇怪,我注意到对人做功的力同时一定对火车作负功,那么也就是一定还有一个对火车作正功的外力,这个力同时也是整个系统的外力.</p>
<p>对这个施加在火车上的外力进行完全一样的分析,就可以得到相同的答案.</p>
<p>或者更一般地,我们来证明惯性参考系下的所需要的能量恒定:</p>
<p>我们已知:</p>
<script type="math/tex; mode=display">
\int _{ t _0  } ^{ t _1  } Fv \ \text { d  } t = \frac { m  } { 2  } ( v _1 ^2 - v _0 ^2 ) + \Delta E</script><p>要证:</p>
<script type="math/tex; mode=display">
\int _{ t _0  } ^{ t _1  } F ( v - v _w ) \ \text { d  } t = \frac { m  } { 2  } ( ( v _1 - v _w ) ^2 - ( v _0 - v _w ) ^2 ) + \Delta E</script><p>而注意到:</p>
<script type="math/tex; mode=display">
\int _{ t _0  } ^{ t _1  } F ( v - v _w ) \ \text { d  } t = \int _{ t _0  } ^{ t _1  } F ( v ) \ \text { d  } t - \int _{ t _0  } ^{ t _1  } Fv _w \ \text { d  } t = \frac { m  } { 2  } ( v _1 ^2 - v _0 ^2 ) - v _w m ( v _1 - v _0 ) + \Delta E</script><p>这就证明了该结论!</p>
<p><del>不过这个做法虽然相当理性但是一点都不直观啊,为什么两个平方竟然可以在这里线性加减,我其实还是没找到更加易于理解的方式啊,如果有大佬知道可以联系我一下qwq</del></p>
<p>哦哦我突然瞎想出了一个相当简洁的方式啊,就是我们不难注意到只要满足动量守恒以及做功的方程$W = Fx $,我们很自然可以推导出动能差的表达式,而这两个基础的表达式都是线性的,因此动能差也一定与选取哪个惯性参考系无关!</p>
<p>换句话说,这个动能差的表达式中的平方是我们积分积出来的,但是积分是可以加减的!</p>
<hr>
<p>在大半夜和Querainy 和Minuses 深入交流之后,我发现上面的过程还是太感性理解了,我们来添加一些细节.</p>
<p>首先,Minuses 提供了在宏观下动量定理和牛二等价的证明(他原本的形式用的全是向量,但是我比较懒,所以换成一维情况了):</p>
<script type="math/tex; mode=display">
F \ \text { d  } t = m \ \text { d  } v</script><script type="math/tex; mode=display">
F = \frac { \text { d  } v  } { \text { d  } t  } m = am</script><p>然后,他又提供了只要有牛顿第二定律和$W = Fx $的定义,我们就可以推导惯性参考系下动能定理的证明:</p>
<script type="math/tex; mode=display">
F = m \frac { \text { d  } v  } { \text { d  } t  }</script><script type="math/tex; mode=display">
F \text { d  } x = m \frac { \text { d  } v  } { \text { d  } t  } \text { d  } x = mv \ \text { d  } v</script><script type="math/tex; mode=display">
W = \int _{ t _0  } ^{ t _1  } F \text { d  } x = m \int _{ t _0  } ^{ t _1  } v \text { d  } v = \frac { 1  } { 2  } m ( v _1 ^2 - v _0 ^2 )</script><p>Minuses 无敌,可让天下一先.</p>
<hr>
<p>Querainy提出我之前的说法是错误的,因为在不同参考系下牛顿第二定律的确不会有影响,但是$W = Fx $是受到了影响的.例如在上面的例子中,如果以火车为参考系,那么火车与人之间的力对人是没有做功的.但是以地面为参考系,那么这个力因为作用点在变所以是做功了的.</p>
<p>然而这个做功的改变在上面的积分形式中就可以发现,由于速度的改变导致平方项不能完美消除,因此这个做功的改变会抵消切换参考系(伽利略变换)带来的<strong>动能形式的改变</strong>.</p>
<p>这个自我修正bug看上去相当诡异,但是一想到动能定理本身就是从$W = Fx $和牛顿第二定律推导出来的,因此有自洽性也非常合理.</p>
<p>追根溯源看上面整个问题,我们会发现,如果我们换参考系然后看动能,动能的变化量的确是不一样的.</p>
<p>但是问题在于,我们在意的不是动能的变化量,而是我引起这个变化需要外加多少能量.如果我引起这个变化所需要外加的能量不变,那么就仍然满足能量守恒定律.</p>
<p>如果我们换参考系,动能的变化量改变,但是同时原本不做功的力也会随之进行做功.事实上由于力的作用点最多只在一个惯性参考系下才是静止的,因此换参考系几乎一定会引起力的做功.</p>
<hr>
<p>所以我们其实还可以再举一个类似的例子:</p>
<p>考虑一个劲度系数为$k $的弹簧连在地上,上面放了一个重物$M $,我们来观察一下这个东西.</p>
<p>不妨取<strong>重物放上弹簧后的平衡位置</strong>为重力势能和弹性势能的零点,设弹簧原长位置相对于此位置距离为$x _0 $,此时当然有$kx _0 = Mg $那考虑系统的弹性势能:</p>
<script type="math/tex; mode=display">
E _{ p 1  } = \frac { k  } { 2  } ( x - x _0 ) ^2 - \frac { k  } { 2  } ( x _0 ) ^2 = \frac { k  } { 2  } x ^2 - kx _0 x</script><p>重力势能:</p>
<script type="math/tex; mode=display">
E _{ p 2  } = Mgx</script><p>那么总势能当然是:</p>
<script type="math/tex; mode=display">
E _p = \frac { 1  } { 2  } kx ^2 - kx _0 x + Mgx = \frac { 1  } { 2  } kx ^2</script><hr>
<p>时隔不知道多长时间,现在我们来证明柯尼希定理:质点系在参考系$A $中的总动能等于质点系在质心系中的动能与质心在参考系$A $中的动能之和.</p>
<p>不妨设质心系下质点系的总动能为$E _{ kS  } $,参考系$A $下的总动能为$E _{ kA  } $,质心相对于$A $参考系的速度为$\vec { v  } _C $,我们当然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _{ kS  } & = \frac { k  } { 2  } \sum m _i ( \vec { v  } _i - \vec { v  } _C ) ^2 \\
& = E _{ kA  } + \frac { k  } { 2  } ( M \sum ( \vec { v  } _C ) ^2 - 2 \sum m _i \vec { v  } _i \vec { v  } _C ) \\
& = E _{ kA  } + \frac { k  } { 2  } ( M \sum ( \vec { v  } _C ) ^2 - 2 ( \vec { v  } _C ) ^2 \sum m _i ) \\
& = E _{ kA  } - \frac { k  } { 2  } M ( \vec { v  } _C ) ^2 
\end{aligned}</script><p>那这就给出了一个更强的结论,而且这里的质心参考系甚至不需要是惯性系.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被摆球创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E6%91%86%E7%90%83%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>今晚学弟问了我这么一个问题:</p>
<p>对于一个圆锥摆,设其绳上拉力为$T $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T \sin \theta & = m \omega ^2 \sin \theta L \\
T & = m \omega ^2 L 
\end{aligned}</script><p>那么问题来了:当小球自然下垂的时候,$T = mg $,但是$\omega = 0 $,左边不等于右边???</p>
<p>怎么处理这个问题呢?</p>
<hr>
<p>下面是我个人的想法啊,不一定正确.</p>
<p>冷静一下,$\omega = \frac { v  } { r  } $,我们的确能确认自然下垂的时候$v = 0 $,但由于$r $也是$0 $,我们没道理判定$\omega = 0 $.</p>
<p>那么我们把角速度换成线速度就有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T \sin \theta & = m \frac { v ^2  } { \sin \theta L  } \\
T \sin ^2 \theta & = \frac { mv ^2  } { L  } 
\end{aligned}</script><p>这样极限情况下两边就相等了(均为$0 $).</p>
<hr>
<p>或者说我们还可以这么干:</p>
<p>考虑$T = \frac { mg  } { \cos \theta  } $,所以$\omega ^2 = \frac { g  } { L \cos \theta  } $,注意到其实$\omega $是随着小球下落而单调递减的,但是不可能减到$0 $.</p>
<hr>
<p>另一个想法是:考虑先放一个实体圆锥(可提供支持力),让球在圆锥上转圈,然后逐渐加速到支持力$N = 0 $,此时小球会飘起来.我们观察一下这个式子是啥:</p>
<p>考虑引入离心力,只需要让离心力,重力,支持力和拉力四力平衡即可,设绳子与竖直方向的夹角为$\theta $,作正交分解后立刻有:</p>
<script type="math/tex; mode=display">
\begin{cases}
N \cos \theta = T \sin \theta - m \omega ^2 L \sin \theta \\
N \sin \theta = mg - T \cos \theta 
\end{cases}</script><p>替换掉其中的$N $,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
mg \cos \theta - T \cos ^2 \theta & = T \sin ^2 \theta - m \omega ^2 L \sin ^2 \theta \\
T & = mg \cos \theta + m \omega ^2 L \sin ^2 \theta 
\end{aligned}</script><p>考虑$T $和$\omega ^2 $的函数关系,小球从在圆锥摆上的状态到飘起来的状态应该是连续的两段直线,注意到当$\theta \rightarrow 0 $的时候,它俩的关系是$T = mg $的平行于$\omega ^2 $轴的直线,这段直线会一直延伸到$\omega $的最低点,也就是$\omega = \sqrt { \frac { g  } { L  }  } $的点然后再转上去.</p>
<hr>
<p>如果这个文章就这么结束还是有点无聊,不如让我们来看个类似的问题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k0eufkm2.png" alt></p>
<p>先来看第一问:</p>
<p>设水平向左为正方向,设小球相对于滑块的水平速度为$v _1 $,滑块速度为$v _2 $.</p>
<p>水平方向动量守恒,当然有$m ( v _1 - v _2 ) = Mv _2 $.</p>
<p>此时小球的总速度应该为$v = \sqrt { ( v _1 - v _2 ) ^2 + ( \frac { v _1 \sin \theta  } { \cos \theta  } ) ^2  } = v _2 \sqrt { ( \frac { M  } { m  } ) ^2 + \frac { ( M + m ) ^2 \sin ^2 \theta  } { m ^2 \cos ^2 \theta  }  } $.</p>
<p>小球和滑块的总机械能守恒,当然有:$\frac { 1  } { 2  } mv ^2 + \frac { 1  } { 2  } Mv _2 ^2 = mgR \cos \theta $.</p>
<p>两式联立,解得:$v _2 = \sqrt { \frac { 2 m ^2 gR \cos \theta  } { ( Mm + M ^2 ) + ( M + m ) ^2 \tan ^2 \theta  }  } = \sqrt { \frac { 2 m ^2 gR \cos ^3 \theta  } { ( m + M ) ( M + m \sin ^2 \theta )  }  } $.</p>
<p>看上去只是麻烦而已,也没那么难嘛.</p>
<p>再来看第二问:</p>
<p>考虑$a _n = \frac { ( \frac { v _1  } { \cos \theta  } ) ^2  } { R  } = \frac { v _2 ^2 ( M + m ) ^2  } { m ^2 R \cos ^2 \theta  } = \frac { 2 g ( M + m ) \cos \theta  } { M + m \sin ^2 \theta  } $,</p>
<p>而滑块的水平加速度大小应该是$a ‘ = - \frac { N \sin \theta  } { M  } $,那么惯性力$F ‘ = - a ‘ m = \frac { mN \sin \theta  } { M  } $.</p>
<p>而$a _n m = N - mg \cos \theta + F ‘ \sin \theta $,$\frac { M + m \sin ^2 \theta  } { M  } N = ma _n + mg \cos \theta = \frac { 2 gm ( M + m ) \cos \theta  } { M + m \sin ^2 \theta  } + mg \cos \theta = mg \cos \theta ( \frac { 3 M + 2 m + m \sin ^2 \theta  } { M + m \sin ^2 \theta  } ) $,整理得到$N = Mm \cos \theta ( \frac { 3 M + 3 m - m \cos ^2 \theta  } { ( M + m \sin ^2 \theta ) ^2  } ) $.方向沿半径方向朝向圆心.</p>
<p>这里就要用惯性力了.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被小船创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%B0%8F%E8%88%B9%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>众所周知,高中物理有一道很经典的分解速度的题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1t04v0mr.png" alt></p>
<p>物理老师在上课讲这个题的时候,将速度分解为两个正交的速度,这两个速度的矢量和就是原速度.</p>
<p>乍一看好像非常合理,然而随即大家可能就会见到这个题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ajz7jb.png" alt></p>
<p>其中中间的物体下落的速度为$v $,这个时候沿绳子分解速度的时候,两个分速度应该均是$v \cos \theta $,而这个时候两个速度的矢量和并不是原速度啊!</p>
<p>老师讲到这里的时候,往往会说这是因为:”速度的分解和力的分解并不一样.”但你可能会疑问:同样是矢量的分解,为什么会不一样呢?</p>
<p>先提前给出我的思考:在这个滑轮组模型中,我们做的操作并不是将原速度分解为了这两个速度,这两个速度也并非由原速度一下分解出来的,而分别只是原速度分解出的速度的一部分.</p>
<hr>
<p>先看这个最经典的模型:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1t04v0mr.png" alt></p>
<p>不妨设高度差为$h $,此时绳子长度为$L $,物体距离墙的距离为$x $.</p>
<p>有勾股定理:</p>
<p>$L ^2 = h ^2 + x ^2 $,注意到此时$h $是一个常量.</p>
<p>两边对$t $求导,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 Lv _L & = 2 xv _x \\
v _L & = \frac { x  } { L  } v _x & = v _x \cos \theta 
\end{aligned}</script><p>此时的另一个分速度自然是$v _h = v _x \sin \theta $.在物理课上,物理老师会这么解释这种分解:</p>
<p>$v _L $这个速度提供了绳子缩短的速度,而$v _h $提供了绳子转动的速度.</p>
<p>那么这个$v _h $听上去应该是此时绳子与物体接触点的转动的线速度对吧.也就是说角速度应该是$\omega = \frac { v _h  } { L  } = \frac { h  } { L ^2  } v _x $,令绳子与转轴夹角为$\alpha , \sin \alpha = \frac { x  } { L  } $而我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\omega & = \frac { \text { d  } \alpha  } { \text { d  } t  } \\
& = \frac { \text { d  } \alpha  } { \text { d  } \sin \alpha  } \frac { \text { d  } \sin \alpha  } { \text { d  } t  } \\
& = \frac { 1  } { \frac { \text { d  } \sin \alpha  } { \text { d  } \alpha  }  } \frac { \text { d  } \sin \alpha  } { \text { d  } t  } \\
& = \frac { 1  } { \cos \alpha  } \frac { v _x L - v _L x  } { L ^2  } \\
& = \frac { h  } { L ^2  } v _x 
\end{aligned}</script><p>这就证明了$v _h $的确是线速度,这也与我们直观感受相当匹配.</p>
<hr>
<p>解释完上面这个分解的正确性,我们又要开始考虑了:那么为什么力和速度的分解不一样呢?</p>
<p>有一个很形象的比喻,那就是如果两个人同时以速度$v $的速度拉一个物体,这个物体的速度是$v $;但如果两个人同时以力$F $拉一个物体,这个物体的受力是$2 F $.</p>
<p>这是为什么呢?动量定理实际上将力在时间上的积累与动量等价起来了对吧,由于速度并非是动量,因此自然像力那样叠加.这么思考也许是正确的:两个受力均为$F $的物体的合力是$2 F $,两个速度均为$v $的物体合速度为$v $,两个动量均为$p $的速度相同的物体合动量为$2 p $.</p>
<p>或者换而言之,力的作用之间是有牛顿第三定律作保证的,这就可以让力在物体间存在一种类似传递的效果.但是速度并没有这种效果,速度并非是外界对物体做出的改变,而是物体的性质本身.</p>
<p>从这个角度,我们回到滑轮的那个题,我们就可以明白为什么要这么分解了:原因很简单,这两个沿绳的速度并不是一次分解分解出来的,而是让原本的速度先沿其中一个绳分解为两个速度,一个是沿绳的速度$v \cos \theta $,另一个是提供绳转动的线速度$v \sin \theta $.</p>
<p>而速度是不能叠加的,因此右边也做这个操作,这就使得沿绳的分速度均为$v \cos \theta $.</p>
<hr>
<p>回看开头的那个滑轮题,这题其实还有个很好玩的地方:那就是C的动能最大点可不是C的受力平衡点:原因很简单,C的受力平衡点由于滑轮作用仍然存在角速度上的加速度.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被地球创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%9C%B0%E7%90%83%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>大家高中都学过开普勒三定律对吧!下面我们来证明它们是对的.</p>
<p>由于难度不太一样,我们微调一下顺序.</p>
<h3><span id="开普勒第二定律">开普勒第二定律</span></h3><p>根据角动量守恒,当然有$\vec { r  } \times \vec { p  } = C $为定值.又根据机械能守恒,其在某一个点的机械能应该为$- \frac { GmM  } { r  } + \frac { p ^2  } { 2 m  } $.</p>
<p>先考虑证明开普勒第二定律,取一段极小时间$\text { d  } t $,考虑掠过的面积应该是$\text { d  } S = \frac { 1  } { 2  } \vec { r  } \times ( \vec { r  } + \text { d  } \vec { r  } ) = \frac { 1  } { 2  } \vec { r  } \times \text { d  } \vec { r  } $,于是掠面速度$V = \frac { \text { d  } S  } { \text { d  } t  } = \frac { 1  } { 2 m  } \vec { r  } \times \vec { p  } $是一个常数.</p>
<h3><span id="开普勒第三定律">开普勒第三定律</span></h3><p>那么$T = \frac { S  } { V  } = \frac { 2 m \times ab \pi  } { \vec { r  } \times \vec { p  }  } = mab \frac { 2 \pi  } { C  } $.</p>
<p>那么$\frac { T ^2  } { a ^3  } = \frac { 4 \pi ^2 m ^2 b ^2  } { aC ^2  } $.</p>
<p>根据机械能守恒,当然应该有在近日点和远日点机械能相等,那自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- \frac { GmM  } { a + c  } + \frac { C ^2  } { 2 m ( a + c ) ^2  } & = - \frac { GmM  } { a - c  } + \frac { C ^2  } { 2 m ( a - c ) ^2  } \\
m ^2 & = C ^2 \frac { a  } { b ^2 GM  } 
\end{aligned}</script><p>带入得到$\frac { T ^2  } { a ^3  } = \frac { 4 \pi ^2  } { GM  } $是一个定值.</p>
<h3><span id="开普勒第一定律">开普勒第一定律</span></h3><p>我们知道圆锥曲线的极坐标方程是:</p>
<script type="math/tex; mode=display">
r ( \theta ) = \frac { ep  } { 1 - e \cos \theta  }</script><p>其中$e $是离心率,$p $是准焦距(焦点到准线的距离).</p>
<p>后面不会了,开摆!</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被兔子创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%85%94%E5%AD%90%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>没想到这个系列博客都出到第三节了.</p>
<p>之所以起这么个名字,是因为下面要开搞的数列很像真理元素的<a href="https://www.bilibili.com/video/BV1B7411W7LB">这个视频</a>.但其实下面的操作和这个视频并没有什么关系.</p>
<p><del>而且其实理论上,这篇博客的名字应该叫《被qyc创飞了(1)》</del></p>
<p>前天,qyc给我发了一个<a href="https://www.luogu.com/article/5gal95wp">博客</a>,里面提供了一种非常厉害的估计数列的方法.我一看就觉得超级厉害啊,因为这个题我之前也做过然后被爆杀了,而竟然可以拿科技秒掉.</p>
<p>大概讲一下qyc的神仙操作:</p>
<p>$a _1 = 1 , a _{ n + 1  } - a _n = - \frac { 1  } { 3  } a _n ^2 $</p>
<p>考虑构造一个函数$f ( n ) $使得$f ( n ) \approx a _n $,那我们就可以将$a _{ n + 1  } - a _n \approx f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$\exists x _0 \in [ n , n + 1 ] , f ‘ ( x _0 ) = f ( n + 1 ) - f ( n ) $,而对于增长率变化不大的函数,直接认为$f ‘ ( x _0 ) = f ‘ ( n ) $是有理可循的!</p>
<p>@Minuses在知乎上找到了这个东西的<a href="https://zhuanlan.zhihu.com/p/342641401">系统理论</a>.<del>但是我没有看</del>.</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 $解得$f ( n ) = \frac { 3  } { n + 2  } $.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>但是我不满意!具体数学上教过我们可以用数列估计误差项,那现在我们来考虑一下它的误差项吧!</p>
<p>令$a _n = \frac { 3  } { n + 2  } - b _n $,带入化简,得到$\{ b _n \} $的递推式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } & = ( \frac { 3  } { n + 2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _{ n + 1  } - \frac { 3  } { n + 3  } & = ( b _n - \frac { 3  } { n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 & = 0 , b _{ n + 1  } & = \frac { b _n ^2  } { 3  } + \frac { n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  } 
\end{aligned}</script><p>算到这里,我们可以很轻易使用数学归纳法算出$b _n \leq \frac { 1  } { 4 n  } $,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n $的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设$b _n ^2 &lt; &lt; b _n $:</p>
<p>$b _{ n + 1  } = O ( 1 ) b _n + O ( \frac { 1  } { n ^3  } ) $.</p>
<p>那么$b _n $应该是$O ( \frac { 1  } { n ^2  } ) $级别的对吧!然后我就开始算,算了一晚上也没放出来一个式子,相当自闭.</p>
<p>晚上回家咨询了一下汪神wzm,得知了这个$b _n $是$O ( \frac { \ln n  } { n ^2  } ) $级别的,这下白算一晚上了.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b _{ n + 1  } & = \frac { n  } { n + 2  } b _n + \frac { 1  } { n ( n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } & = n ( n + 1 ) b _n + \frac { 1  } { n  } \\
g ( n ) & = n ( n + 1 ) b _n , g ' ( n ) & = \frac { 1  } { n  } , g ( n ) & = \ln n \\
b _n & = \frac { \ln n  } { n ^2  } 
\end{aligned}</script><p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ \epsilon  } ) $和$O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n \leq \frac { 3 \ln n  } { n ( n + 1 )  } $.</p>
<p>但是如果你尝试带入数学归纳,会发现完全做不动.怎么办呢?</p>
<p>在这个问题被搞出来后两个周,我妈的一位同事给出了纯文化课的牛逼做法,下面来介绍一下这个做法并且终结此题:</p>
<p>首先换元,上面等价于下面这个数列放缩:</p>
<script type="math/tex; mode=display">
a _1 = \frac { 1  } { 3  } , a _{ n + 1  } = - a _n ( a _n - 1 )</script><p>观察形式,注意到$a _n ( a _n - 1 ) $这个东西很像一个类似裂项的东西,因此两边取倒数,自然有:</p>
<script type="math/tex; mode=display">
\frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } = \frac { 1  } { 1 - a _n  }</script><p>考虑$0 &lt; a _n \leq \frac { 1  } { 3  } $,于是我们有下面这个不等式:</p>
<script type="math/tex; mode=display">
1 < \frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } \leq \frac { 3  } { 2  }</script><p>两边求和有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n & \leq \frac { 1  } { a _{ n + 1  }  } - 3 & \leq \frac { 3  } { 2  } n \\
\frac { 2  } { 3 ( n + 1 )  } & \leq a _n & \leq \frac { 1  } { n + 2  } 
\end{aligned}</script><p>仔细观察下面这个式子:</p>
<script type="math/tex; mode=display">
\frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } = \frac { 1  } { 1 - a _n  }</script><p>我们上面的操作实质上是使用这个式子将$0 &lt; a _n \leq \frac { 1  } { 3  } $这个放缩给缩紧了,所以我们再用一次这个式子再紧一遍.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } & \leq \frac { 1  } { 1 - \frac { 1  } { n + 2  }  } & = \frac { n + 2  } { n + 1  } & = 1 + \frac { 1  } { n + 1  } \\

\end{aligned}</script><p>两边求和自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { a _{ n + 1  }  } - 3 & \leq n + \sum _{ k = 2  } ^{ n + 1  } \frac { 1  } { k  } & \leq n + \ln ( n + 1 ) \\
a _n & \geq \frac { 1  } { n + 2 + \ln n  } 
\end{aligned}</script><p>这个界甚至比我们给出的界还要紧.而且似乎继续迭代可以得到更紧的解!相当牛逼!</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>文化课数学导论</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2><h3><span id="习惯的更改">习惯的更改</span></h3><p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将$C _{ n  } ^k $写作$\binom { n  } { k  } $,而文化课中不允许此类更改,再者文化课中将$C _{ n  } ^k a ^{ n - k  } b ^k $称作二项式的第$k + 1 $项(从第$1 $项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3><p>首先我们有$E ( aX + b ) = aE ( X ) + b , D ( aX + b ) = a ^2 D ( X ) $.</p>
<p>我们都知道期望满足线性可加,也就是$E ( X _1 + X _2 ) = E ( X _1 ) + E ( X _2 ) $,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若$X _1 $和$X _2 $相互独立,$E ( X _1 X _2 ) = E ( X _1 ) E ( X _2 ) $,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要$X _1 $和$X _2 $相互独立,$D ( X _1 + X _2 ) = D ( X _1 ) + D ( X _2 ) $.从形式上证明是好证明的,我们考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
D ( X _1 + X _2 ) & = E ( ( X _1 + X _2 ) ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + E ( 2 X _1 X _2 ) + E ( X _2 ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + 2 E ( X _1 ) E ( X _2 ) + E ( X _2 ^2 ) - ( E ( X _1 ) + E ( X _2 ) ) ^2 \\
& = E ( X _1 ^2 ) - E ^2 ( X _1 ) + E ( X _2 ^2 ) - E ^2 ( X _2 ) \\
& = D ( X _1 ) + D ( X _2 ) 
\end{aligned}</script><p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为$0 $,不然$D ( X _1 + X _2 ) $要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为$0 $,并且缩放权值,使得方差恰好为$1 $.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为$0 $的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3><h4><span id="两点分布">两点分布</span></h4><p>直接写的话也就是$P ( X ) = \begin{cases}p &amp; X = 1 \ 1 - p &amp; X = 0 \ 0 &amp; other \end{cases} $,事实上这么写可能不太严谨,因为两点分布的$X = 1 $和$X = 0 $两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是$G ( x ) = ( 1 - p ) + px $.由此式子轻松推得$E ( x ) = G ‘ ( 1 ) = p , D ( x ) = E ( x ^2 ) - E ^2 ( x ) = G ‘ ‘ ( 1 ) + G ‘ ( 1 ) - ( G ‘ ( 1 ) ) ^2 = p - p ^2 = p ( 1 - p ) $.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4><p>所谓$n $重伯努利试验,也就是$n $次两点分布的累计,满足$P ( X = k ) = C _{ n  } ^k ( 1 - p ) ^{ n - k  } p ^k $,我们关注两个事情,也就是二项式分布的$E ( X ) = np , D ( X ) = np ( 1 - p ) $,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4><p>所谓不放回取球,考虑目前有$N $个数字,有$M $个是$1 $,剩下$N - M $个是$0 $,取出$n $次,取出了$m $个$1 $的概率.简单组合一下得到此概率为$\frac { C _{ M  } ^m C _{ N - M  } ^{ n - m  }  } { C _{ N  } ^n  } \ $,注意这里必须保证$n \leq N $.</p>
<p>由范德蒙德卷积得知,$\sum _{ m  } C _{ M  } ^m C _{ N - M  } ^{ n - m  } = C _{ N  } ^n $,因此该分布列所有情况之和为$1 $.</p>
<p>考虑其均值,从感性上讲必定是$\frac { nM  } { N  } $.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如$01101 $之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到$1 $的概率,和第二次取得到$1 $的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是$n \frac { N ( N - M ) ( N - n )  } { N ^2 ( N - 1 )  } $,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4><p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写$f ( x ) = \frac { e ^{ - \frac { ( x - \mu ) ^2  } { 2 \sigma ^2  }  }  } { \sigma \sqrt { 2 \pi  }  } \ $,是不是看着非常震撼!其中的方差是$\sigma ^2 $,期望是$\mu $.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足$\sigma = 1 , \mu = 0 $,此时的函数也就是$f ( x ) = \frac { e ^{ - \frac { x ^2  } { 2  }  }  } { \sqrt { 2 \pi  }  } $.一个好奇是,你凭啥说所有情况下的概率之和为$1 $,事实上这其实是因为$g ( x ) = e ^{ - x ^2  } $的积分是$\sqrt { \pi  } $,不会求这个积分.</p>
<p>观察$g ( x ) = e ^{ - x ^2  } $这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数$e ^{ - | x |  } $模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是$\sigma $的由来,将$x \rightarrow \sigma x $,也就是在$x $那里除去一个$\sigma $.而对这个曲线进行横向移动,也就是将$x \rightarrow x - \mu $.</p>
<p>这也就引出所谓的$3 \sigma $原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3><h4><span id="样本相关系数">样本相关系数</span></h4><p>对于若干数据$( x _i , y _i ) $,我们先进行标准化,也就是减去均值后再除以方差,这样做使得$x , y $分别的均值为$0 $,方差为$1 $.下面默认已经标准化过了.</p>
<p>不妨构造$n $维向量$\vec { x  } = ( x _1 , x _2 , \cdots , x _n ) , \vec { y  } = ( y _1 , y _2 , \cdots , y _n ) $,考虑它们的点乘$\vec { x  } \cdot \vec { y  } $,不难发现由于方差为$1 $,因此$| \vec { x  } | = | \vec { y  } | = \sqrt { n  } $,因此它们的点乘为$n \cos \theta $,设$r = \frac { \vec { x  } \cdot \vec { y  }  } { n  } = \cos \theta $.</p>
<p>如果$\exists k $,$\forall i , y _i = kx _i $,此时必有$| r | = 1 $,因此我们断言(为啥呢?其实是不太理解的啊)当$| r | $越靠近$1 $的时候,$x , y $之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4><p>我们在上面的角度审视中提出了一个观点:在满足均值为$0 $的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:$Y = bx + a + e , E ( e ) = 0 , D ( e ) = \sigma ^2 $.</p>
<p>现在我们要做的就是,已知若干组数据$( x _i , y _i ) $,去构造一组$a , b $满足上面的条件.不妨令$e _i = y _i - ( bx _i + a ) $,若$\sum e _i = 0 $,必有$a = \bar { y  } - b \bar { x  } $,带入解得当$\sigma $最小的时候,$b = \frac { \sum _{ i  } ( x _i - \bar { x  } ) ( y _i - \bar { y  } )  } { \sum _{ i  } ( x _i - \bar { x  } ) ^2  } \ $.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个$b $使得$\sigma $最小,标准化说到底只是为了保证$\sigma = 1 $的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4><p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知$P ( AB ) = P ( A ) P ( B ) $,那么我们反推,如果我们在现实中的估计中,发现$P ( AB ) $和$P ( A ) P ( B ) $差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:$P ( 00 ) = \frac { a  } { n  } , P ( 01 ) = \frac { b  } { n  } , P ( 10 ) = \frac { c  } { n  } , P ( 11 ) = \frac { d  } { n  } $.那么$P ( A = 0 ) P ( B = 0 ) = \frac { ( a + b ) ( a + c )  } { n ^2  } $.我们计算它与$P ( 00 ) $的差,平方后除以$P ( A = 0 ) P ( B = 0 ) $然后做四遍求和化简,得到$\chi ^2 = \frac { n ( ad - bc ) ^2  } { ( a + b ) ( a + c ) ( c + d ) ( b + d )  } $.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么$P ( \chi ^2 \geq x _\alpha ) = \alpha $.或者给出我们经验上的准则:</p>
<p>选取一个较小的$\alpha $,并得知其对应的$x _\alpha $,如果$\chi ^2 \geq x _\alpha $,推断独立性不成立,犯错的概率是$\alpha $.反之断言其独立性成立,犯错的概率不可知,肯定$\alpha $越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2><h3><span id="常用对数表">常用对数表</span></h3><ol>
<li><p>$\ln 2 = 0 . 693 $.</p>
</li>
<li><p>$\ln 3 = 1 . 099 $.</p>
</li>
<li><p>$\ln 5 = 1 . 609 $.</p>
</li>
<li><p>$\ln 0 . 1 = - 2 . 303 $.</p>
</li>
<li><p>$\ln 0 . 5 = - 0 . 693 $.</p>
</li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3><ol>
<li><p>$e = 2 . 718 $.</p>
</li>
<li><p>$e ^2 = 7 . 389 $.</p>
</li>
<li><p>$e ^3 = 20 . 086 $.</p>
</li>
<li><p>$e ^5 = 148 . 413 $.</p>
</li>
<li><p>$e ^{ 0 . 1  } = 1 . 105 $.</p>
</li>
<li><p>$e ^{ 0 . 5  } = 1 . 649 $.</p>
</li>
<li><p>$e ^\pi = 23 . 147 $.</p>
</li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3><h4><span id="fxxex">$f(x)=xe^x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = ( x + 1 ) e ^x $,$x = - 1 $的时候,取最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxxln-x">$f(x)=x\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 + \ln x , x = \frac { 1  } { e  } $的时候,有最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow 0 ^{ +  }  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracexx">$f(x)=\frac{e^x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e^xdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { e ^x ( x - 1 )  } { x ^2  } , x = 1 $的时候,有极小值$e $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracln-xx">$f(x)=\frac{\ln x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - \ln x  } { x ^2  } , x = e $的时候,有极大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxx-ln-x">$f(x)=x-\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 - \frac { 1  } { x  } , x = 1 $的时候,有最小值$1 $.</p>
<hr>
<h4><span id="fxfracxex">$f(x)=\frac{x}{e^x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - x  } { e ^x  } , x = 1 $的时候,有最大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<h3><span id="预处理函数">预处理函数</span></h3><h4><span id="分离对数">分离对数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = ( 2 + x + ax ^2 ) \ln ( x + 1 ) - 2 x $,已知$x = 0 $是极大值点,求$a $.</p>
<p>考虑分离对数后操作多项式,我们显然可找到$0 &lt; t &lt; 1 , 2 + t + at ^2 &gt; 0 , 2 - t + at ^2 &gt; 0 $,下面只考虑$x \in [ - t , t ] $.此时$f ( x ) = ( 2 + x + ax ^2 ) ( \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } ) $.</p>
<p>考虑令$g ( x ) = \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } $,由于$f ( 0 ) = 0 $,只需证明$g ( x ) \leq 0 , x \in [ - t , t ] $即可.</p>
<p>而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ' ( x ) & = \frac { 1  } { x + 1  } - \frac { 4 - 2 ax ^2  } { ( 2 + x + ax ^2 ) ^2  } \\
& = \frac { x ^2 ( a ^2 x ^2 + 4 ax + 6 a + 1 )  } { ( x + 1 ) ( 2 + x + ax ^2 )  } \\
\text { sign  } ( g ' ( x ) ) & = \text { sign  } ( a ^2 x ^2 + 4 ax + 6 a + 1 ) 
\end{aligned}</script><p>则$a ^2 0 ^2 + 4 a 0 + 6 a + 1 = 0 $,$a = - \frac { 1  } { 6  } $.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = e ^x - \ln ( x + 1 ) + ax ^3 - x ^2 - 1 $,若$\forall x \in ( - 1 , 1 ) , f ( x ) \geq 0 $,求$a $.</p>
<p>$f ( 0 ) = 0 $,于是上面的条件等价于$0 $是$( - 1 , 1 ) $的最小值点.</p>
<p>考虑$f ‘ ( x ) = e ^x - \frac { 1  } { x + 1  } + 3 ax ^2 - 2 x $,则$f ‘ ( 0 ) = 0 $恒成立.</p>
<p>讨论$g ( x ) = 1 + e ^{ - x  } ( 3 ax ^2 - 2 x - \frac { 1  } { x + 1  } ) $的正负,看$g ‘ ( x ) = \frac { x ( - 3 ax ^3 + 2 x ^2 + ( 9 a + 2 ) x + 6 a - 1 )  } { ( x + 1 ) ^2 e ^x  } $.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3><h4><span id="变化条件">变化条件</span></h4><h5><span id="example">Example</span></h5><p>已知$x + 2 y = 1 $,求$x ^2 + y ^2 $的最小值.</p>
<p>直接令$x = 1 - 2 y $,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^3 = 2 $,求$x + y $的最小值.</p>
<p>这个的话不妨设其最小值为$C $,有$x + y \geq C $,移项得到$y \geq C - x $,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3><h4><span id="普通参数方程">普通参数方程</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^2 - xy = 1 $,求$x + y $的最小值.</p>
<p>这个的话大概是这样,我们找到一个$t $,使得$x = f ( t ) , y = g ( t ) $,然后换元.</p>
<p>比如这个题,你就可以凑成$( x - \frac { y  } { 2  } ) ^2 + ( \frac { \sqrt { 3  }  } { 2  } y ) ^2 = 1 $,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4><h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5><p>求证$\sqrt { ab  } &lt; \frac { a - b  } { \ln a - \ln b  } &lt; \frac { a + b  } { 2  } $.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { a - b  } { \ln a - \ln b  } & < \frac { a + b  } { 2  } \\
\frac { a - b  } { a + b  } & < \frac { \ln \frac { a  } { b  }  } { 2  } \\
\frac { \frac { a  } { b  } - 1  } { \frac { a  } { b  } + 1  } & < \frac { \ln \frac { a  } { b  }  } { 2  } 
\end{aligned}</script><p>换元,令$t = \frac { a  } { b  } $,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5><p>已知函数$f ( x ) = 3 \ln x - ax $,若$x _1 &lt; x _2 $是$f ( x ) $的两个零点,求证$f ‘ ( \frac { x _1 + 3 x _2  } { 4  } ) &lt; 0 $.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
3 \ln x _1 = ax _1 \\
3 \ln x _2 = ax _2 
\end{cases}</script><p>我们想要知道的是:$\frac { 12  } { x _1 + 3 x _2  } &lt; a $.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把$a $给换掉,事实上我们根据前面的方程有$a = \frac { 3 \ln \frac { x _2  } { x _1  }  } { x _2 - x _1  } $.</p>
<p>于是我们只需要证明:$\frac { x _1 + 3 x _2  } { 4  } &gt; \frac { x _2 - x _1  } { \ln \frac { x _2  } { x _1  }  } $,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>同样分析已知,我们得到的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _1 = ax _1 \\
\ln x _2 = ax _2 
\end{cases}</script><p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _2 - \ln x _1 = a ( x _2 - x _1 ) \\
\ln x _2 + \ln x _1 = a ( x _2 + x _1 ) 
\end{cases}</script><p>这里先把所求变形一下,我们把它改成$\ln x _1 + \ln x _2 &gt; 2 $.</p>
<p>发现了什么?这个东西等价于$a ( x _2 + x _1 ) &gt; 2 $,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换$a $即可.</p>
<h5><span id="example4">Example4</span></h5><p>已知$f ( x ) = x ^2 + axe ^x - ae ^{ 2 x  } $有三个不同的零点$x _1 &lt; x _2 &lt; x _3 $,求$a $的范围,并求证$( 1 - \frac { x _1  } { e ^{ x _1  }  } ) ^2 ( 1 - \frac { x _2  } { e ^{ x _2  }  } ) ( 1 - \frac { x _3  } { e ^{ x _3  }  } ) = 1 $.</p>
<p>考虑两边同时除以$e ^{ 2 x  } $,这样得到$g ( x ) = ( \frac { x  } { e ^x  } ) ^2 + a \frac { x  } { e ^x  } - a $,令$t = \frac { x  } { e ^x  } $得到$g ( t ) = t ^2 + at - a = 0 $.</p>
<p>考察$g ( t ) = 0 $的两根$t _1 &lt; t _2 $,根据韦达定理,首先需要满足$\Delta = a ^2 + 4 a &gt; 0 \Rightarrow a &gt; 0 $,然后$t _1 + t _2 = - a , t _1 t _2 = - a $.</p>
<p>接下来考察函数$\frac { x  } { e ^x  } $,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为$t _1 , t _2 $中必有一负,因此$t _2 \in ( 0 , \frac { 1  } { e  } ) $.由此立得$0 &lt; a &lt; \frac { 1  } { e ( e - 1 )  } $.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4><h5><span id="example1">Example1</span></h5><p>若$x &gt; 0 $时,$ax ( e ^{ ax  } + 1 ) \geq 2 ( x ^2 + 1 ) \ln x $恒成立,求$a $取值范围.</p>
<p>一般这种题先判$a $的正负,注意到$x &gt; 1 $的时候右边恒大于$0 $,因此$a &gt; 0 $.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数$2 $放进$\ln $,自然有:$ax ( e ^{ ax  } + 1 ) \geq ( x ^2 + 1 ) \ln x ^2 $.</p>
<p>考虑令$t _1 = ax , t _2 = \ln x ^2 $,则:</p>
<script type="math/tex; mode=display">
t _1 ( e ^{ t _1  } + 1 ) \geq t _2 ( e ^{ t _2  } + 1 )</script><p>接下来分析函数$f ( x ) = x ( e ^x + 1 ) $的单调性,就可以得到$a \geq \frac { 2  } { e  } $.</p>
<h3><span id="不等式相关">不等式相关</span></h3><h4><span id="基本不等式相关">基本不等式相关</span></h4><h5><span id="方程角度的审视">方程角度的审视</span></h5><p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造$\frac { m  } { n  } = k $.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5><p>已知$n , m &gt; 0 , 2 m + n = nm $,求$n + m + \sqrt { n ^2 + m ^2  } $的最小值.</p>
<p>这个题有一个方式是观察到$n , m , \sqrt { n ^2 + m ^2  } $是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n + m + \sqrt { n ^2 + m ^2  } & \geq k \\
\Leftarrow \sqrt { n ^2 + m ^2  } & \geq k - n - m \\

\end{aligned}</script><p>如果$n + m \geq k $,那么不等式显然成立,下面只需要证明$n + m &lt; k $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt { n ^2 + m ^2  } & \geq k - n - m \\
\Leftarrow n ^2 + m ^2 & \geq ( k - ( n + m ) ) ^2 \\
\Leftarrow k ^2 + ( n + m ) ^2 - 2 k ( n + m ) & \leq n ^2 + m ^2 \\
\Leftarrow k ^2 + 2 nm - 2 k ( n + m ) & \leq 0 \\
\Leftarrow k ^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) & \leq 0 \\
\Leftarrow k ^2 & \leq n ( 2 k - 2 ) + m ( 2 k - 4 ) 
\end{aligned}</script><p>变形方程得到$\frac { 2  } { n  } + \frac { 1  } { m  } = 1 $,使用这个式子来降次:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) & = 6 k - 8 + \frac { n  } { m  } ( 2 k - 2 ) + \frac { m  } { n  } ( 4 k - 8 ) \\

\end{aligned}</script><p>要严谨一点的话我们需要证明$4 k - 8 \geq 0 $,$k \geq 2 $.这非常简单,因为$k \geq n + m &gt; 3 $.</p>
<p>这就足够了么?不需要证明存在一个$w = \frac { n  } { m  } $使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>这个等号可以取到,也就是说,只要满足:</p>
<script type="math/tex; mode=display">
k ^2 \leq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下界,特别地,如果满足:</p>
<script type="math/tex; mode=display">
k ^2 = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到$k = 10 $是一个解了),接下来我们必须求出一个$k $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 & = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
k ^2 - 6 k + 8 & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
\sqrt { k - 2  } & = \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } 
\end{aligned}</script><p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个$\sqrt { k - 2  } $带入到上面去!</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 )  } \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } \\
( k - 4 ) ( k - 2 ) & = \frac { 32 ( k - 1 )  } { k - 4  } \\

\end{aligned}</script><p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说$k = 0 $是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出$k = 10 $.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4><h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5><script type="math/tex; mode=display">
\begin{aligned}
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( x _0 )  } { k !  } ( x - x _0 ) ^k \\
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( 0 )  } { k !  } x ^k \\

\end{aligned}</script><h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5><ol>
<li><p>$\frac { 1  } { 1 - x  } = \sum _{ k \geq 0  } x ^k = 1 + x + x ^2 + \cdots \ $.</p>
</li>
<li><p>$e ^x = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } = 1 + x + \frac { 1  } { 2 !  } x ^2 + \cdots \ $.</p>
</li>
<li><p>$\ln ( 1 + x ) = \sum _{ k \geq 1  } ( - 1 ) ^{ k - 1  } \frac { x ^k  } { k  } = x - \frac { 1  } { 2  } x ^2 + \frac { 1  } { 3  } x ^3 + \cdots \ $.</p>
</li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4><h5><span id="example1">Example1</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>极值点偏移的形式,应该是形如$g ( x ) = a $有两个解$x _1 , x _2 $,然后使得$x _1 + x _2 $满足一定条件.因此我们先变形条件:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { \ln x _1  } { x _1  } = a \\
\frac { \ln x _2  } { x _2  } = a 
\end{cases}</script><p>也就是目前我们构造出了函数$g ( x ) = \frac { \ln x  } { x  } $,观察$g ( x ) $图像立得$x _1 + x _2 &gt; 2 e $.</p>
<p>我们发现,$x _1 x _2 \leq \frac { ( x _1 + x _2 ) ^2  } { 4  } $,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为$\ln x _1 + \ln x _2 &lt; 2 $,然后令$t _1 = \ln x _1 , t _2 = \ln x _2 $,带入立有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { t _1  } { e ^{ t _1  }  } = a \\
\frac { t _2  } { e ^{ t _2  }  } = a 
\end{cases}</script><p>而$g ( x ) = \frac { x  } { e ^x  } $恰好也是满足$x _1 + x _2 &gt; 2 $的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5><p>$f ( x ) = x ( 1 - \ln x ) $,$b \ln a - a \ln b = a - b $,求证$2 &lt; \frac { 1  } { a  } + \frac { 1  } { b  } &lt; e $.</p>
<p>首先变形条件得到$b ( 1 + \ln a ) = a ( 1 + \ln b ) $,得到$f ( \frac { 1  } { a  } ) = f ( \frac { 1  } { b  } ) $,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p>$f ‘ ( x ) = - \ln x $,其在$( 0 , 1 ) \uparrow , ( 1 , + \infty ) \downarrow $,考察极值点偏移,我们想要证明$\frac { 1  } { b  } &lt; e - \frac { 1  } { a  } $,我们就想办法把$\frac { 1  } { b  } $和$e - \frac { 1  } { a  } $扔到同一个区间里,而它们确实同在$( 1 , + \infty ) $这个区间内.</p>
<p>比较有启发性的是,你发现$\frac { 1  } { b  } , e - \frac { 1  } { a  } $和$\frac { 1  } { a  } , e - \frac { 1  } { b  } $这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { b  } & < e - \frac { 1  } { a  } \\
f ( \frac { 1  } { a  } ) & = f ( \frac { 1  } { b  } ) & > f ( e - \frac { 1  } { a  } ) 
\end{aligned}</script><p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5><p>$f ( x ) = e ^{ x - 1  } - ax $在$( 0 , 2 ) $有两个零点$x _1 , x _2 $,求证$x _1 x _2 &gt; \frac { 1  } { a  } $.</p>
<p>首先要证明$a $的范围啊,我们不加证明地给出:$a \in ( 1 , \frac { e  } { 2  } ) $,并且$( - \infty , 1 + \ln a ) \downarrow , ( 1 + \ln a , + \infty ) \uparrow $.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
ax _1 = e ^{ x _1 - 1  } \\
ax _2 = e ^{ x _2 - 1  } 
\end{cases}</script><p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取$\ln $,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取$\ln $,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到$x _1 x _2 $和$x _1 + x _2 $之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如$0 &lt; f ( 2 + \ln a - x _2 ) $,也就是$0 &lt; ae ^{ 1 - x _2  } - a ( 2 + \ln a - x _2 ) $.</p>
<p>但是这样有一个问题,我们把$f $带进去,你会发现最后我们的式子同时带有$a , x _2 $,这个就难做了,咋办呢?考虑拿$ax _2 = e ^{ x _2 - 1  } $操作一下把$a $消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4><h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5><ol>
<li><p>$e ^x \geq x + 1 $.</p>
</li>
<li><p>$\frac { x - 1  } { x  } \leq \ln x \leq x - 1 $.</p>
</li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol>
<li>$\ln ( n + 1 ) &lt; \sum _{ k = 1  } ^n \frac { 1  } { k  } $.</li>
</ol>
<p>考虑$\ln ( \frac { n + 1  } { n  } ) &lt; \frac { 1  } { n  } $,左右两边分别求和得到上面的式子.</p>
<ol>
<li>$\ln n &gt; \sum _{ k = 2  } ^n \frac { 1  } { k  } , n &gt; 1 $.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明$\ln \frac { 1  } { n  } &lt; - \sum _{ k = 2  } ^n \frac { 1  } { k  } $.</p>
<p>考虑$\ln ( \frac { n - 1  } { n  } ) \leq - \frac { 1  } { n  } $,两边求和得到上式.</p>
<ol>
<li>$\sum _{ k = 1  } ^n ( \frac { k  } { n  } ) ^n &lt; \frac { e  } { e - 1  } $.</li>
</ol>
<p>考虑$n \ln ( \frac { k  } { n  } ) \leq k - n $,也就有$( \frac { k  } { n  } ) ^n \leq e ^{ k - n  } $,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5><h6><span id="example1">Example1</span></h6><p>设$f ( x ) = x \ln x $,若$f ( x ) = b $有两个实数根$x _1 , x _2 ( x _1 &lt; x _2 ) $,求证:$be + 1 &lt; x _2 - x _1 &lt; \frac { e ^{ - 3  } + 2 + 3 b  } { 2  } $.</p>
<p>注意到$f ( x ) $下凸,考虑求出两条切线,那么这两条切线与$y = b $的交点之差要大于等于$x _2 - x _1 $,两条割线交点之差要小于等于$x _2 - x _1 $.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是$b \rightarrow - \frac { 1  } { e  } $的情况,为了让这种情况有解,我们的割线必过$( \frac { 1  } { e  } , - \frac { 1  } { e  } ) $.</p>
<p>考虑直接选取$( 0 , 0 ) $和$( 1 , 0 ) $作为另外两个点,这两条割线就是$x = - y $和$x = ( e - 1 ) y + 1 $.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得$( x _2 - x _1 ) _{ \max  } $尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是$u $,另一个是$v $,其中$v &lt; \frac { 1  } { e  } &lt; u $,那么两条切线分别是:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = \frac { y - f ( u )  } { f ' ( u )  } + u \\
x = \frac { y - f ( v )  } { f ' ( v )  } + v 
\end{cases}</script><p>那么,现在我们要做的就是找到一组$( u , v ) $,使得:</p>
<script type="math/tex; mode=display">
\frac { b - f ( u )  } { f ' ( u )  } + u - \frac { b - f ( v )  } { f ' ( v )  } - v = \frac { e ^{ - 3  } + 2 + 3 b  } { 2  }</script><p>感觉很难搞啊,我们不妨让$u = 1 $,自然有:</p>
<script type="math/tex; mode=display">
\frac { ( f ' ( v ) - 1 ) b + f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  } + 3 b  } { 2  }</script><p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { f ' ( v ) - 1  } { f ' ( v )  } = \frac { 3  } { 2  } \\
\frac { f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  }  } { 2  } 
\end{cases}</script><p>考虑让$f ‘ ( v ) = - 2 $,则$v = e ^{ - 3  } $,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4><h5><span id="example1">Example1</span></h5><p>求证:$\forall x \in ( 0 , + \infty ) , \ln x + 1 &gt; \frac { 1  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2 x  } $.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以$x $,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为$x \ln x + x &gt; \frac { x  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2  } $,然后证明左边的最小值$\geq $右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4><p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5><p>已知$a = 0 . 1 e ^{ 0 . 1  } , b = \frac { 1  } { 9  } , c = - \ln 0 . 9 $,求比较$a , b , c $的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6><p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算$a $和$c $的大小关系.</p>
<p>构造函数$f ( x ) = xe ^x + \ln ( 1 - x ) $,则$f ( 0 . 1 ) &gt; 0 \Rightarrow a &gt; c $.</p>
<p>考察$f ( 0 ) = 0 $,$f ‘ ( 0 ) = 0 $,$f ‘ ‘ ( 0 ) = 4 &gt; 0 $,则$f ( 0 ) = 0 $是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算$f ( 0 . 1 ) &gt; 0 $.</p>
<h6><span id="估算定积分">估算定积分</span></h6><p>考察$a $和$b $的大小关系,不妨设$f ( x ) = ( 1 - x ) e ^{ 1 - x  } - \frac { 1  } { 10 x  } $,则$f ( 0 . 9 ) &lt; 0 \Rightarrow b &gt; a $.</p>
<p>注意到$f ( 1 ) = - \frac { 1  } { 10  } $,$f ‘ ( 1 ) = - \frac { 9  } { 10  } $,考虑估算一下积分,那么$f ( 0 . 9 ) \approx f ( 1 ) - f ‘ ( 1 ) 0 . 1 = - \frac { 1  } { 100  } &lt; 0 $.</p>
<p>你可能会觉得这个$- \frac { 1  } { 100  } $,是不是不太能那么肯定地估算啊.但是实际上,我们考察$f ‘ ( x ) = ( x - 2 ) e ^{ 1 - x  } + \frac { 1  } { 10 x ^2  } $,这个东西在$[ 0 . 9 , 1 ] $上直觉上平均值是大于$- \frac { 9  } { 10  } $的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6><p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6><p>接下来开抄标答.</p>
<p>令$f _a ( x ) = xe ^x , f _b ( x ) = \frac { x  } { 1 - x  } , f _c ( x ) = - \ln ( 1 - x ) $.</p>
<p>这样当$x = 0 . 1 $的时候所有的数字都被正确表示了.</p>
<p>比较$a , b $:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = \ln ( a ) - \ln ( b ) & = x + \ln ( 1 - x ) \\
y ' & = 1 - \frac { 1  } { 1 - x  } & = \frac { - x  } { 1 - x  } 
\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单减,这样立有$a &lt; b $.</p>
<p>比较$a , c $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = a - c & = xe ^x + \ln ( 1 - x ) \\
y ' & = ( x + 1 ) e ^x - \frac { 1  } { 1 - x  } & = \frac { ( 1 + x ) ( 1 - x ) e ^x - 1  } { 1 - x  } \\

\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单增,这样立有$a &gt; c $.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2><h3><span id="递归式的求解">递归式的求解</span></h3><h4><span id="特征根法">特征根法</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>在上面做$k = 2 $的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6><p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定$a _0 , . . . , a _n $,其中$a _0 \ne 0 $,对于所有的$k \in \mathbb { N  } $,若有下列式子成立:</p>
<script type="math/tex; mode=display">
a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = z _k</script><p>则称为一个$n $阶线性差分方程(或递归关系).为了简化,通常取$a _0 = 1 $.若$\{ z _k \} $是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6><p>我们注意到,对于齐次差分方程而言,如果不给定$y _0 , \cdots y _{ n - 1  } $,只是构造一组满足条件的$y $的话,自然的想法是令$y _k = r ^k $.其中$r $是辅助方程$a _0 r ^{ n  } + a _1 r ^{ n - 1  } + \cdots + a _n = 0 $的一个根.</p>
<p>注意到如果我们将上面的内容看作是$T : \{ y _k \} \mapsto \{ z _k \} $这样一个映射,这显然是一个线性变换.这意味着齐次方程$a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = 0 $的解集就是$T $的核,设为$H $,不难发现只要给定$y _0 , \cdots y _{ n - 1  } $,这个解就唯一确定,将它们看作自由变量,这意味着$\dim H = n $.</p>
<p>还没完,注意到我们解方程可以解出$n $个根,如果这$n $个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了$y _0 , \cdots y _{ n - 1  } $,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这$n $个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的$\mathbb { R  } ^k $的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共$n $个线性无关的根,然后拟合初值.我们如此做:对于一个出现了$m $次的根$r $,我们注意到$r ^k , kr ^k , \cdots , k ^{ m - 1  } r ^k $都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以$kr ^k $作为例子,即证明:</p>
<script type="math/tex; mode=display">
a _0 nr ^n + a _1 ( n - 1 ) r ^{ n - 1  } + \cdots + a _1 r = 0</script><p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个$r $作为根,必然意味着原方程形如$( y - r ) ^2 P $,其中$P $是一个关于$y $的多项式.</p>
<p>我们把它写开:$( y ^2 - 2 ry + r ^2 ) P = 0 $,然后我们用$kr ^k $去代替$r ^k $,不难发现代替后右边还是个多项式,而左边变成了$0 $,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _0 r ^{ n + k  } + a _1 r ^{ n + k - 1  } + \cdots + a _1 r ^k & = 0 \\
a _0 ( n + k ) r ^{ n + k - 1  } + a _1 ( n + k - 1 ) r ^{ n + k - 2  } + \cdots + a _1 kr ^{ k - 1  } & = 0 \\
a _0 ( n + k ) r ^{ n + k  } + a _1 ( n + k - 1 ) r ^{ n + k - 1  } + \cdots + a _1 kr ^{ k  } & = 0 \\

\end{aligned}</script><p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:$( ( y - r ) ^2 P ) ‘ = ( y - r ) ( ( y - r ) P ) ‘ + ( y - r ) ‘ ( y - r ) P = ( y - r ) [ ( y - r ) ‘ P + ( ( y - r ) P ) ‘ ] $,$r $一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6><p>我们注意到齐次差分方程一定能写成$\vec { x  } _k = A \vec { x  } _{ k - 1  } $的形式.如果我们取$A $的特征向量的线性组合作为$\vec { x  } _0 $,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为$1 $的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3><h4><span id="和式的基本运算">和式的基本运算</span></h4><p>分配律:$\ \sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i \ $.</p>
<p>结合律:$\ \sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i $.</p>
<p>交换律:$\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  } $,其中$p $是$S $集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol>
<li><p>$\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] $.</p>
</li>
<li><p>$\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } $.</p>
</li>
</ol>
<p>一般分配律:$\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j ) $.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4><h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6><p>等差数列求和：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\

\end{aligned}</script><p>又有$( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) $,显然有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \leq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \leq b _j \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \geq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \geq b _j \\

\end{aligned}</script><p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6><p>即$\sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \ $.</p>
<p>令$S _n = \sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 \ $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k - a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6><p>$S _n = \sum _{ i = 0  } ^n i ^2 $.</p>
<p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推，我们设$W _n = \sum _{ i = 0  } i ^3 $</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h4><span id="展开和收缩">展开和收缩</span></h4><h6><span id="example1平方和公式">Example1(平方和公式)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="problme3">Problme3</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="problemex2">ProblemEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<p>$g ( x ) = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f ( x ) + C \ $</p>
<p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<p>\Delta(x^{\underline{m}})=mx^{\underline{m-1}}，\sum mx^{\underline{m-1}}\delta x=x^{\underline{m}}+C，m\ne 0\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $，有:</p>
<p>令H(x)=\sum_{i=1}^x\frac{1}{i}\\\Delta(H(x))=x^{\underline{-1}}，\sum x^{\underline{-1}}\delta x =H(x)+C\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<p>$\Delta ( 2 ^x ) = 2 ^x ， \sum 2 ^x \delta x = 2 ^x + C \ $</p>
<p>$\Delta ( c ^x ) = ( c - 1 ) c ^x ， \sum c ^x \delta x = \frac { c ^x  } { c - 1  } + C , c \ne 1 \ $</p>
<p>$\Delta ( c ^{ \underline { x  }  } ) = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x = c ^{ \underline { x  }  } + C , c - x \ne 0 \ $.</p>
<p>根据组合数公式,有:</p>
<p>$\Delta ( \binom { x  } { k  } ) = \binom { x  } { k - 1  } \ $.</p>
<h6><span id="example1">Example1</span></h6><p>仍然考虑平方和公式：</p>
<p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p>$\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \ $.</p>
<h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k 2 ^k \\
& = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x \\
& = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 \\

\end{aligned}</script><h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3">Example3</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } \\
& = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="example4">Example4</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script><h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3><h5><span id="example">Example</span></h5><p>令$A = \{ 2 n - 1 | n \in \mathbb { N  } _{ +  } \} , B = \{ 3 n - 1 | n \in \mathbb { N  } _{ +  } \} $.求$A \cap B $,以及$A \cup B $的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a \in A \Leftrightarrow a & \equiv - 1 \pmod { 2  } \\
b \in B \Leftrightarrow b & \equiv - 1 \pmod { 6  } \\

\end{aligned}</script><p>所以$A \cap B = \{ 6 n - 1 | n \in \mathbb { N  } _{ +  } \} $.</p>
<p>而同理,$x \in A \cup B \Leftrightarrow x \equiv - 1 / - 2 / - 3 / - 5 \pmod { 6  } $.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3><p>设$A = \{ x | x = 2 n - 1 , n \in \mathbb { N  } _+ \} , B = \{ x | x = 2 ^n , n \in \mathbb { N  } _+ \} $,现在将$A \cup B $中的元素排序并提取成一个数列$a $,求使得$S _n &gt; 12 a _n $最小的正整数$n $.</p>
<p>写出数列,它长这样:</p>
<script type="math/tex; mode=display">
\begin{matrix}
1 & 2 \\
3 & 4 \\
5 & 7 & 8 \\
9 & 11 & 13 & 15 & 16 \\
& & \cdots 
\end{matrix}</script><p>不妨设$n $在第$r $行$c $列,显然$( r , c ) $和$n $构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的$n $能快速表达$( r , c ) $,要么反之.显然反之比较简单.</p>
<p>考虑设前$k $行共有$W _k $个数,不难发现$W _{ k + 1  } = W _k + 2 ^{ k - 1  } + 1 , W _k = 2 ^{ k - 1  } + k $.</p>
<p>显然,对于$( r , c ) $来说,它对应的$n $就是$W _{ r - 1  } + c $.</p>
<p>令$SR _{ r  } $为前$r $行数字之和,不难发现$SR _r = 2 ^{ r + 1  } - 2 + ( 2 ^{ r - 1  } ) ^2 $.</p>
<p>接下来考虑找到这个最小的$n $,显然$r \ne 1 $,接下来只考虑$r \geq 2 $的情况.</p>
<p>那么我们可以轻松写出$S _n $和$a _n $的表达式,下面直接给出:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = SR _{ r - 1  } + \sum _{ k = 1  } ^c ( 2 ^{ r - 1  } + 2 k - 1 ) - [ c & = 2 ^{ r - 2  } + 2 ] \\
S _n & = 2 ^r - 2 + 4 ^{ r - 2  } + 2 ^{ r - 1  } c + c ^2 - [ c & = 2 ^{ r - 2  } + 1 ] \\
a _n & = 2 ^{ r - 1  } + 2 c - 1 - [ c & = 2 ^{ r - 2  } + 1 ] 
\end{aligned}</script><p>讨论一下$[ c = 2 ^{ r - 2  } + 1 ] $这个判定式取$0 $还是取$1 $,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3><h2><span id="几何导论">几何导论</span></h2><h3><span id="三角相关">三角相关</span></h3><h4><span id="三角恒等变换">三角恒等变换</span></h4><h5><span id="两角和差公式">两角和差公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( A + B ) & = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) & = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) & = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) & = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) & = \frac { \tan A + \tan B  } { 1 - \tan A \tan B  } \\
\tan ( A - B ) & = \frac { \tan A - \tan B  } { 1 + \tan A \tan B  } 
\end{aligned}</script><h5><span id="倍角公式">倍角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\tan ( 2 A ) & = \frac { 2 \tan A  } { 1 - \tan ^2 A  } \\
\sin ( 2 A ) & = 2 \sin A \cos A \\
\cos ( 2 A ) & = \cos ^2 A - \sin ^2 A & = 2 \cos ^2 A - 1 & = 1 - 2 \sin ^2 A 
\end{aligned}</script><h5><span id="半角公式">半角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 - \cos A  } { 2  }  } \\
\cos ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 + \cos A  } { 2  }  } \\
\tan ( \frac { A  } { 2  } ) & = \frac { \sin A  } { 1 + \cos A  } & = \frac { 1 - \cos A  } { \sin A  } & = \pm \sqrt { \frac { 1 - \cos A  } { 1 + \cos A  }  } 
\end{aligned}</script><h5><span id="和差化积">和差化积</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A + \sin B & = 2 \sin ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\sin A - \sin B & = 2 \cos ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\cos A + \cos B & = 2 \cos ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\cos A - \cos B & = - 2 \sin ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\tan A + \tan B & = \frac { \sin ( A + B )  } { \cos A \cos B  } 
\end{aligned}</script><p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<script type="math/tex; mode=display">
\sin ^2 A - \sin ^2 B = \sin ( A - B ) \sin ( A + B )</script><p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A \sin B & = - \frac { 1  } { 2  } [ \cos ( A + B ) - \cos ( A - B ) ] \\
\cos A \cos B & = \frac { 1  } { 2  } [ \cos ( A + B ) + \cos ( A - B ) ] \\
\sin A \cos B & = \frac { 1  } { 2  } [ \sin ( A + B ) + \sin ( A - B ) ] \\
\cos A \sin B & = \frac { 1  } { 2  } [ \sin ( A + B ) - \sin ( A - B ) ] 
\end{aligned}</script><h5><span id="万能公式">万能公式</span></h5><p>令$w = \tan \frac { A  } { 2  } $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin A & = \frac { 2 w  } { 1 + w ^2  } \\
\cos A & = \frac { 1 - w ^2  } { 1 + w ^2  } \\
\tan A & = \frac { 2 w  } { 1 - w ^2  } 
\end{aligned}</script><p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos ( x ) & = \frac { e ^{ ix  } + e ^{ - ix  }  } { 2  } \\
\sin ( x ) & = \frac { e ^{ ix  } - e ^{ - ix  }  } { 2 i  } 
\end{aligned}</script><h5><span id="补充公式">补充公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
1 + \sin A & = ( \sin \frac { A  } { 2  } + \cos \frac { A  } { 2  } ) ^2 \\
1 - \sin A & = ( \sin \frac { A  } { 2  } - \cos \frac { A  } { 2  } ) ^2 
\end{aligned}</script><h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4><p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的$k $来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6><p>已知函数$f ( x ) = \sin ( \omega x + \varphi ) , w &gt; 0 $,$f ( - \frac { \pi  } { 6  } ) = 0 , f ( \frac { \pi  } { 2  } ) = - 1 $,求$w $和$\varphi $的表达式.</p>
<p>正确做法应该是强设$k _1 , k _2 $,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的$\omega $和$\varphi $都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令$\frac { \pi  } { 2  } $为单位$1 $,我们必有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- \frac { \omega  } { 3  } + \varphi & \equiv 0 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><p>下面推导$\omega $,首先将上面两个式子直接相减,立有:</p>
<script type="math/tex; mode=display">
\frac { 4  } { 3  } \omega \equiv 1 \pmod { 2  }</script><p>对于$\varphi $,考虑类似的做法,将第一个式子乘以$3 $后与第二个式子相加,立有:</p>
<script type="math/tex; mode=display">
4 \varphi \equiv 1 \pmod { 2  }</script><p>这样我们得到的必须满足的条件就有以下几条:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 4  } { 3  } \omega & \equiv 1 \pmod { 2  } \\
4 \varphi & \equiv 1 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><h3><span id="向量相关">向量相关</span></h3><h4><span id="旋转模型">旋转模型</span></h4><p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6><p>已知$AB = 2 , AC = 1 , \angle A = \theta $,$BC $绕$B $点顺时针旋转$\frac { \pi  } { 3  } $得到$BD $,求以$\theta $表示$S _{ \triangle CBD  } $.</p>
<p>先来说文化课做法,我们直接表示$S $,令$\alpha = \angle ABC $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S & = | BD | \sin ( \alpha + \frac { \pi  } { 3  } ) \\

\end{aligned}</script><p>对于这个式子,我们发现如果我们能得到$| BD | \sin ( \alpha ) $和$| BD | \cos ( \alpha ) $就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现$BD $是$\alpha $的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出$| BD | \sin \alpha $,余弦定理可以帮助我们求出$| BD | \cos \alpha $.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出$\overrightarrow { AB  } $和$\overrightarrow { BC  } $的坐标表示,将$\overrightarrow { BC  } $用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4><p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol>
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p>
</li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作$1 $是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p>
</li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6><p>$\triangle ABC $中,$b ^2 = ac $,点$D $在$AC $上且满足$BD = b $,有$\overrightarrow { AD  } = 2 \overrightarrow { DC  } $,求$\cos \angle ABC $.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定$c = 1 $,于是有$b ^2 = a $.</p>
<p>考虑我们要求$\cos \angle ABC $,而我们有一条很奇怪的边$BD $,似乎不满足任何性质,我们立刻想到要把它用$\angle ABC $的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让$c = 1 $,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4><h5><span id="奔驰定理">奔驰定理</span></h5><p>对于$\triangle ABC $内一点$P $,立有$S _{ \triangle PBC  } \overrightarrow { PA  } + S _{ \triangle PAC  } \overrightarrow { PB  } + S _{ \triangle PAB  } \overrightarrow { PC  } = \vec { 0  } $.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令$a = PA , b = PB , c = PC $,我们要证奔驰定理,也就是要证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
bc \sin \alpha \overrightarrow { PA  } + ac \sin \beta \overrightarrow { PB  } + ab \sin \gamma \overrightarrow { PC  } & = \vec { 0  } \\
abc \sin \alpha \frac { \overrightarrow { PA  }  } { a  } + abc \sin \beta \frac { \overrightarrow { PB  }  } { b  } + abc \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\
\sin \alpha \frac { \overrightarrow { PA  }  } { a  } + \sin \beta \frac { \overrightarrow { PB  }  } { b  } + \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\

\end{aligned}</script><p>考虑$| \frac { \overrightarrow { PA  }  } { a  } | = | \frac { \overrightarrow { PB  }  } { b  } | = | \frac { \overrightarrow { PC  }  } { c  } | = 1 $,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5><p>有正弦定理,$| \overrightarrow { OA  } | = | \overrightarrow { OB  } | = | \overrightarrow { OC  } | = \frac { a  } { 2 \sin A  } $.</p>
<p>考虑三个三角形的面积可以表示为$\frac { r ^2  } { 2  } \sin \theta $,又考虑到圆中的$\theta $是圆心角是圆周角的两倍,立有$\sin ( 2 A ) \overrightarrow { OA  } + \sin ( 2 B ) \overrightarrow { OB  } + \sin ( 2 C ) \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6><p>在$\triangle ABC $中,$AB = 2 , BC = \sqrt { 10  } , AC = 3 $,若$O $是其外心,且$\overrightarrow { AO  } = p \overrightarrow { AB  } + q \overrightarrow { AC  } $.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用$| OA | = | OB | = | OC | $,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于$p , q $的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了$| OA | $,用上$| OB | $,这样的话我们两边同时加上$\overrightarrow { BA  } $,就可以得到$p , q $的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据$| OC | $也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { AO  } & = p \overrightarrow { AB  } + q \overrightarrow { AC  } \\
\vec { 0  } & = ( p + q - 1 ) \overrightarrow { OA  } + p \overrightarrow { OB  } + q \overrightarrow { OC  } 
\end{aligned}</script><p>考察奔驰定理,立有$\frac { p + q - 1  } { \sin ( 2 A )  } = \frac { p  } { \sin ( 2 B )  } = \frac { q  } { \sin ( 2 C )  } $,简单题.</p>
<h6><span id="example2">Example2</span></h6><p>已知相异两点$O , H $分别为$\triangle ABC $的外心和垂心,若$\overrightarrow { OH  } = m ( \overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } ) $,求$m $.</p>
<p>这题要用到的性质是,我们一定要知道$( \overrightarrow { OB  } + \overrightarrow { OC  } ) \cdot \overrightarrow { BC  } = 0 $,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出$\overrightarrow { AH  } $,然后两边同时乘以$\overrightarrow { BC  } $就可以解决.注意到最后解方程的时候要么$m = 1 $,要么三角形等边,但是我们声明过$O , H $相异两点.</p>
<h5><span id="重心">重心</span></h5><p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的$1 : 2 $的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若$O $是重心,则必有$\overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5><p>若$O $是重心,立有$\overrightarrow { OA  } \cdot \overrightarrow { BC  } = 0 $,将$\overrightarrow { BC  } = \overrightarrow { BO  } + \overrightarrow { OC  } $,立有$\overrightarrow { OA  } \cdot \overrightarrow { OB  } = \overrightarrow { OA  } \cdot \overrightarrow { OC  } = \overrightarrow { OB  } \cdot \overrightarrow { OC  } $.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有$\overrightarrow { OA  } \tan A + \overrightarrow { OB  } \tan B + \overrightarrow { OC  } \tan C = \vec { 0  } $.</p>
<h5><span id="内心">内心</span></h5><p>根据奔驰定理,立有$a \overrightarrow { OA  } + b \overrightarrow { OB  } + c \overrightarrow { OC  } = \vec { 0  } $.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3><h4><span id="基本概念">基本概念</span></h4><h5><span id="直线">直线</span></h5><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h5><span id="平面">平面</span></h5><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h5><span id="夹角">夹角</span></h5><h6><span id="两直线夹角">两直线夹角.</span></h6><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h5><span id="交点">交点</span></h5><p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4><p>参考:<a href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3><h4><span id="约定">约定</span></h4><p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可($mx + ny = 1 $需要判断过原点的直线,$y = kx + b $需要判断平行于$y $轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之和为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | F _1 P | + | F _2 P | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5><h6><span id="标准方程">标准方程</span></h6><p>由定义不难得到椭圆的标准方程:$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( b ^2 = a ^2 - c ^2 , a &gt; b &gt; 0 ) $.</p>
<h6><span id="一般方程">一般方程</span></h6><p>$nx ^2 + my ^2 = 1 ( n , m \geq 0 ) $,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下$n $和$m $的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = a - ex _0 $.</p>
<h6><span id="焦点弦">焦点弦</span></h6><p>过$F _1 $的弦$| AB | = 2 a + e ( x _1 + x _2 ) $.</p>
<p>过$F _2 $的弦$| AB | = 2 a - e ( x _1 + x _2 ) $.</p>
<p>注意到焦点弦最短时$x _1 = x _2 $.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li><p>$C = 2 a + 2 c $.</p>
</li>
<li><p>$S = b ^2 \tan \frac { \theta  } { 2  } = c | y _P | $.</p>
</li>
<li><p>$\cos \theta \geq 1 - 2 e ^2 $(当$P $在短轴上取等).</p>
</li>
<li><p>$| PF _1 | | PF _2 | = \frac { 2 b ^2  } { 1 + \cos \theta  } $.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example1">Example1</span></h6><p>已知椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,$P $是椭圆上一点,$\angle F _1 PF _2 $的角平分线交$x $轴于$Q ( \frac { c  } { 4  } , 0 ) $,求离心率取值范围.</p>
<p>注意到$S _{ \bigtriangleup QPF _1  } = \frac { 5  } { 3  } S _{ \bigtriangleup QPF _2  } $,又有$Q $到$PF _1 $和$PF _2 $的距离相等,用等积法,显然$PF _1 = \frac { 5  } { 4  } a , PF _2 = \frac { 3  } { 4  } a $.</p>
<p>然后用三角形不等式做差就行.$2 c &gt; \frac { 1  } { 2  } a , \frac { 1  } { 4  } &lt; e $</p>
<h4><span id="双曲线">双曲线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之差为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | | F _1 P | - | F _2 P | | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) , ( x _0 &gt; 0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = - a + ex _0 $.</p>
<h6><span id="渐近线">渐近线</span></h6><p>$y = \pm \frac { b  } { a  } x $.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成$0 $得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li>$S = \frac { b ^2  } { \tan \frac { \theta  } { 2  }  } $.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5><h6><span id="焦点弦">焦点弦</span></h6><p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线$AB $为过$y ^2 = 2 px ( p &gt; 0 ) $焦点的弦,$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,倾斜角为$\theta $,准线与$x $轴交点为$E ( - \frac { p  } { 2  } , 0 ) $,作$AA _1 $,$BB _1 $垂直于准线于$A _1 , B _1 $,则:</p>
<ol>
<li><p>$| AF | = x _1 + \frac { p  } { 2  } $,$| BF | = x _2 + \frac { p  } { 2  } $,$| AB | = x _1 + x _2 + p , \frac { 1  } { | FA |  } + \frac { 1  } { | FB |  } = \frac { 2  } { p  } $.</p>
</li>
<li><p>$| AF | = \frac { p  } { 1 - \cos \theta  } , | BF | = \frac { p  } { 1 + \cos \theta  } , | AB | = \frac { 2 p  } { \sin ^2 \theta  } $.</p>
</li>
<li><p>$x _1 x _2 = \frac { p ^2  } { 4  } $,$y _1 y _2 = - p ^2 $.</p>
</li>
<li><p>$S _{ \bigtriangleup AOB  } = \frac { p ^2  } { 2 \sin \theta  } $.</p>
</li>
<li><p>$k _{ AE  } + k _{ BE  } = 0 $.</p>
</li>
<li><p>$A , O , B _1 $三点共线,$B , O , A _1 $三点共线.</p>
</li>
<li><p>以$AB $为直径的圆与抛物线的准线相切.</p>
</li>
<li><p>以$A _1 B _1 $为直径的圆与$AB $相切.</p>
</li>
<li><p>以$AF $或$BF $为直径的圆与$y $轴相切.</p>
</li>
</ol>
<h4><span id="通用解法">通用解法</span></h4><h5><span id="联立方程">联立方程</span></h5><h6><span id="点参">点参</span></h6><p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线$l $上有两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,那么$| NM | = \sqrt { 1 + k ^2  } | x _1 - x _2 | = \sqrt { 1 + \frac { 1  } { k ^2  }  } | y _1 - y _2 | $.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,其中点$M ( x _0 , y _0 ) $,有$2 x _0 = x _1 + x _2 , 2 y _0 = y _1 + y _2 $.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线$l $与曲线交于两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,$MN $的中点为$P ( x _0 , y _0 ) $,那么:</p>
<ol>
<li><p>在椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( a &gt; b &gt; 0 ) $中,$k \frac { y _0  } { x _0  } = - \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $中,$k \frac { y _0  } { x _0  } = \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在抛物线$y ^2 = 2 px ( p &gt; 0 ) $中,$k = \frac { p  } { y _0  } = \frac { x _0  } { p  } $.</p>
</li>
</ol>
<h6><span id="小联立">小联立</span></h6><p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6><p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线$PA $,$PB $,我们可以将公共点$P $平移至原点,这样$PA $和$PB $的方程都方便表达.然后设$AB $的方程为$mx + ny = 1 $(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以$mx + ny $,零次项乘以$( mx + ny ) ^2 $,这样就得到了一个齐次式子.将两边同时除以$x ^2 $后就得到了一个和$k = \frac { y  } { x  } $有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的$x _1 x _2 $和$x _1 + x _2 $之间的关系来做.</p>
<p>当然还有一种情况是问形如$\frac { Ax _1 + Bx _2  } { Cx _1 + Dx _2  } $是定值的问题,这个时候一定有$\frac { A  } { C  } = \frac { B  } { D  } $.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令$w = \frac { x _1  } { x _2  } $,自然有$w + \frac { 1  } { w  } + 2 = \frac { ( x _1 + x _2 ) ^2  } { x _1 x _2  } $.</p>
<p>还比如有$y _2 = ny _1 + m $,我们可以用配凑技巧改写作$( y _2 + w ) = k ( y _1 + w ) $,也就有$\frac { y _2 + w  } { y _1 + w  } = k $,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线$y = kx + \varphi $与曲线$\frac { x ^2  } { m  } + \frac { y ^2  } { n  } = 1 $相交于$A ( x _1 , y _1 ) $和$B ( x _2 , y _2 ) $.</p>
<p>那么联立方程是:$( n + mk ^2 ) x ^2 + 2 k \varphi mx + m ( \varphi ^2 - n ) = 0 $.</p>
<p>判别式:$\Delta = 4 mn ( n + mk ^2 - \varphi ^2 ) $.</p>
<p>韦达定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x _1 + x _2 & = \frac { - 2 km \varphi  } { n + mk ^2  } \\
x _1 x _2 & = \frac { m ( \varphi ^2 - n )  } { n + mk ^2  } \\
| x _1 - x _2 | & = \frac { \sqrt { \Delta  }  } { n + mk ^2  } 
\end{aligned}</script><h6><span id="配凑法">配凑法</span></h6><p>参考:<a href="https://zhuanlan.zhihu.com/p/521025768">https://zhuanlan.zhihu.com/p/521025768</a>.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6><p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线$y ^2 = 4 x $,若$A , B $位于抛物线上$x $轴上方不同的两点,直线$OA , OB $的斜率分别为$k _1 , k _2 $,且满足$k _1 k _2 - 4 = 4 k _1 + 4 k _2 $,求证:$AB $过定点,并求出$k _{ AB  } $的取值范围.</p>
<p>注意到$k _1 $和$k _2 $之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设$AB : y = kx + b $,则$A ( x _1 , kx _1 + b ) , B ( x _2 , kx _2 + b ) $,显然$k _1 = k + \frac { b  } { x _1  } , k _2 = k + \frac { b  } { x _2  } $.</p>
<p>直接带入方程,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k + \frac { b  } { x _1  } ) ( k + \frac { b  } { x _2  } ) - 4 & = 4 ( 2 k + \frac { b  } { x _1  } + \frac { b  } { x _2  } ) \\
k ^2 + kb ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) + \frac { b ^2  } { x _1 x _2  } - 4 & = 8 k + 4 b ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) \\

\end{aligned}</script><p>而直接大联立得到的式子是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 x ^2 + ( 2 kb - 4 ) x + b ^2 & = 0 \\
\Delta & = 16 - 16 kb & > 0 , kb & < 1 \\
x _1 x _2 & = \frac { b ^2  } { k ^2  } , x _1 + x _2 & = \frac { 4 - 2 kb  } { k ^2  } , \frac { 1  } { x _1  } + \frac { 1  } { x _2  } & = \frac { 4 - 2 kb  } { b ^2  } 
\end{aligned}</script><p>带入,得到$k - b = 4 $,因此过定点$( - 1 , - 4 ) $,与$kb &lt; 1 $联立得到$k &lt; 2 + \sqrt { 5  } $.</p>
<p>还没完,这种题一定要检查一遍条件.注意到$AB $为$x $轴上方两点的性质没用到,这意味着$y _1 y _2 &gt; 0 \land y _1 + y _2 &gt; 0 $,带入方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b ^2 + b ( \frac { 4 - 2 kb  } { k  } ) + b ^2 & > 0 \\
\frac { 4 - 2 kb  } { k  } + 2 b & > 0 
\end{aligned}</script><p>化简得到$\begin{cases}b &gt; 0 \ k &gt; 0 \end{cases} $,解得$k &gt; 4 $,于是$k \in ( 4 , 2 + \sqrt { 5  } ) $.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,$OA $和$OB $的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k _{ OA  } & = \frac { y _1  } { x _1  } , k _{ OB  } & = \frac { y _2  } { x _2  } \\
\frac { y _1 y _2  } { x _1 x _2  } - 4 & = 4 ( \frac { y _1  } { x _1  } + \frac { y _2  } { x _2  } ) \\
16 - 4 y _1 y _2 & = 16 ( y _1 + y _2 ) 
\end{aligned}</script><p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<script type="math/tex; mode=display">
\begin{aligned}
AB : \\
x - x _1 & = ( y - y _1 ) \frac { x 1 - x _2  } { y _1 - y _2  } \\
x - \frac { y _1 ^2  } { 4  } & = ( y - y _1 ) \frac { 1  } { 4  } ( y _1 + y _2 ) \\
x & = \frac { y _1 + y _2  } { 4  } y - \frac { y _1 y _2  } { 4  } \\
x & = \frac { y _1 + y _2  } { 4  } y - 1 + ( y _1 + y _2 ) 
\end{aligned}</script><p>显然过定点$( - 1 , - 4 ) $,并且通过$y _1 $和$y _2 $的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个$\frac { x - x _1  } { x _1 - x _2  } = \frac { y - y _1  } { y _1 - y _2  } $的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + y ^2 = 1 $,$P , Q $在椭圆上,$A ( 2 , 0 ) $,$k _{ AP  } k _{ AQ  } = \frac { 1  } { 20  } $,求证:$PQ $过定点.</p>
<p>注意到$A ( 2 , 0 ) $,设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$PQ : m ( x - 2 ) + yn = 1 $,那么我们要求的也就是$x - 2 $和$y $之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然$\frac { x ^2  } { 4  } + y ^2 = 1 \Rightarrow \frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 $.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令$x ‘ = x - 2 , y ‘ = y $,我们有$x = x ‘ + 2 , y = y ‘ $,带入就可以得到关于$x ‘ , y ‘ $的方程,然后再带回$x $和$y $就行.</p>
<p>我们开始推导:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 \\
( x - 2 ) ^2 + 4 ( x - 2 ) + 4 y ^2 = 0 \\
( x - 2 ) ^2 + 4 n ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
( 4 n + 1 ) ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
4 n + 1 + 4 m \frac { y  } { x - 2  } + 4 ( \frac { y  } { x - 2  } ) ^2 = 0 \\

\end{aligned}</script><p>令$k = \frac { y  } { x - 2  } $,也就得到了$4 n + 1 + 4 mk + 4 k ^2 = 0 $.用一遍韦达定理,有:$k _1 k _2 = \frac { 4 n + 1  } { 4  } = \frac { 1  } { 20  } , n = - \frac { 1  } { 5  } $.</p>
<p>也就有:$PQ : - \frac { 1  } { 5  } ( x - 2 ) + my = 1 $,显然过定点$( - 3 , 0 ) $.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 9  } + y ^2 = 1 $,$P , Q $是该椭圆上两动点,$M , N $分别为$P , Q $在$x $轴上的射影,而且$k _{ OP  } k _{ OQ  } = - 1 $,记$S = S _{ \bigtriangleup OPM  } + S _{ \bigtriangleup OQN  } $,求$S $的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线$PQ $很重要的时候,而这个题除了$P , Q $两点以外,和$PQ $半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$k = \frac { y _1  } { x _1  } , - \frac { 1  } { k  } = \frac { y _2  } { x _2  } $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = | x _1 y _1 | + | x _2 y _2 | \\
& = | x _1 ^2 k - \frac { 1  } { k  } x _2 ^2 | \\

\end{aligned}</script><p>而联立方程,有:</p>
<script type="math/tex; mode=display">
x _1 ^2 = \frac { 1  } { \frac { 1  } { 9  } + k  } , x _2 ^2 = \frac { 1  } { \frac { 1  } { 9  } - \frac { 1  } { k  }  }</script><p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线$PQ $有两个未知量,我们还需要拿$k _{ OP  } k _{ OQ  } = - 1 $限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 2  } + y ^2 = 1 $,$F ( 1 , 0 ) $,直线$l $过$F $且交椭圆于$A , B $两点.求问:$x $轴上是否存在异于$F $的一点$Q $,使得$\frac { k _{ QA  }  } { k _{ QB  }  } $是定值.</p>
<p>直接设$AB : x = ky + 1 $,$Q ( q , 0 ) $.我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = \frac { y _1 ( q - x _2 )  } { y _2 ( q - x _1 )  } \\
& = - \frac { ky _1 y _2 + y _1 - qy _1  } { ky _1 y _2 + y _2 - qy _2  } 
\end{aligned}</script><p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k ^2 + 2 ) y ^2 + 2 ky - 1 & = 0 \\
\Delta & = 8 k ^2 + 8 & > 0 \\
y _1 + y _2 & = - \frac { 2 k  } { k ^2 + 2  } \\
y _1 y _2 & = - \frac { 1  } { k ^2 + 2  } \\

\end{aligned}</script><p>注意到$\frac { ( y _1 + y _2 )  } { 2  } = k ( y _1 y _2 ) $,代入,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = - \frac { y _1 + y _2 + 2 y _1 - 2 qy _1  } { y _1 + y _2 + 2 y _2 - 2 qy _2  } \\
& = - \frac { ( 3 - 2 q ) y _1 + y _2  } { ( 3 - 2 q ) y _2 + y _1  } 
\end{aligned}</script><p>若是定值,那么就有:$\frac { 3 - 2 q  } { 1  } = \frac { 1  } { 3 - 2 q  } $,解得$q _1 = 1 ( F ) $,$q _2 = 2 ( Q ) $.</p>
<p>所以$Q ( 2 , 0 ) $.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,过$F ( - 1 , 0 ) $的直线交椭圆于$M , N $两点,过$M $作直线$x = - 4 $的垂线,垂足为$E $,求证:$EN $过定点.</p>
<p>根据对称原理,显然这个定点一定在$x $轴上.</p>
<p>我们先写大联立的式子:设$MN : x = - 1 + ky $,带入有$( 3 m ^2 + 4 ) y ^2 - 6 my - 9 = 0 $.再设$M ( x _1 , y _1 ) , N ( x _2 , y _2 ) $,自然有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\Delta = 144 k ^2 + 144 \\
y _1 + y _2 = \frac { 6 k  } { 3 k ^2 + 4  } \\
y _1 y _2 = \frac { - 9  } { 3 k ^2 + 4  } 
\end{cases}</script><p>接下来呢,我们想一下我们要求什么:我们要求出$EN $的表达式:形如$y - m = k ( x - n ) $,然后声明$( n , m ) $是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有$k = \frac { y - m  } { x - n  } $.而我们现在有两个点$E ( - 4 , y _1 ) $和$N ( x _2 , y _2 ) $,又猜出$m = 0 $,也就是我们要找到一个$n $满足$\frac { y _1  } { - 4 - n  } = \frac { y _2  } { x _2 - n  } $.</p>
<p>我们倒着推:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { x _2 - n  } \\
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { ky _2 - 1 - n  } 
\end{aligned}</script><p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ky _1 y _2 + \frac { 3  } { 2  } ( y _1 + y _2 ) & = 0 \\
( x _2 + \frac { 5  } { 2  } ) y _1 & = - \frac { 3  } { 2  } y _2 \\
y _1 & = \frac { - 3  } { 2  } \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - \frac { 3  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - 4 + \frac { 5  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\

\end{aligned}</script><p>做到这一步发现要做完了,不难发现$n = \frac { 5  } { 2  } $.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了$m = 0 $了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5><h6><span id="定义">定义</span></h6><p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点$P $作直线$l $交二次曲线于$M , N $两点(离$P $近的是$M $),则在$l $上有且只有一点$Q $,使得$| MQ | | NP | = | MP | | NQ | $(即$P , Q , M , N $构成一调和点列).当$l $绕着$P $旋转时,$Q $的轨迹是一条直线$p $(或一部分),这条直线$p $叫做点$P $关于二次曲线的极线,而$P $叫做$p $关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:$p : \frac { x _0 x  } { a ^2  } + \frac { y _0 y  } { b ^2  } = 1 $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线$C : Ax ^2 + Bxy + Cy ^2 + Dx + Ey + F = 0 $上的一点$P ( x _0 , y _0 ) $,我们称它的极线为$p : Axx _0 + B \frac { x _0 y + y _0 x  } { 2  } + Cyy _0 + D \frac { x + x _0  } { 2  } + E \frac { y + y _0  } { 2  } + F = 0 $.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6><p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线$C $,如果点$P $的极线经过点$Q $,那么点$Q $的极线经过点$P $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol>
<li><p>设四边形$ABCD $(对边不平行)内接于二次曲线$C $,则对角线交点$P $的极线是两组对边交点的连线.反之同理,若$P $在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p>
</li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p>
</li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p>
</li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6><p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知$\frac { \cos \theta  } { a  } + \frac { \sin \theta  } { b  } = 1 $,求证:$\frac { 1  } { a ^2  } + \frac { 1  } { b ^2  } \geq 1 $.</p>
<p>设直线$l : \frac { x  } { a  } + \frac { y  } { b  } = 1 $,$M ( \cos \theta , \sin \theta ) $,则$M $在$l $上.</p>
<p>又注意到$M $显然是在单位圆上,而$l $是单位圆关于$P ( \frac { 1  } { a  } , \frac { 1  } { b  } ) $的极点.又注意到$l $与单位圆至少有一个交点,因此$P $要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,$A _1 ( - 2 , 0 ) , A _2 ( 2 , 0 ) , D ( \frac { 1  } { 2  } , 0 ) $,过$D $的直线交椭圆于$P , Q $两点(不与$A _1 , A _2 $重合).$A _1 P \cap A _2 Q = M $,$A _1 Q \cap A _2 P = N $,设$k _1 = k _{ A _1 P  } , k _2 = k _{ A _1 Q  } $.求证:$k _1 k _2 $是定值,求出这个定值并求出$\bigtriangleup DMN $面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知$MN : x = 8 $.</p>
<p>我们先来看已知$MN : x = 8 $之后怎么做:</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,再设$PQ : x = ky + \frac { 1  } { 2  } $,则:$k _1 k _2 = \frac { y _1  } { x _1 + 2  } \frac { y _2  } { x _2 + 2  } $,不难算出$k _1 k _2 = - \frac { 9  } { 20  } $.</p>
<p>此时$S _{ \bigtriangleup DMN  } = | MN | | 8 - \frac { 1  } { 2  } | \frac { 1  } { 2  } $.不难发现只需求出$| MN | _{ \min  } $即可.而$MN \bot x $轴,所以$| MN | = | y _M - y _N | $.</p>
<p>接下来咋做?第一问求得$k _1 $和$k _2 $的关系不能白求啊!</p>
<p>我们有$A _1 P : x = - 2 + \frac { 1  } { k _1  } y , A _1 Q : x = - 2 + \frac { 1  } { k _2  } y $,带入$x = 8 $,求得$y _M = 10 k _1 , y _N = 10 k _2 $.</p>
<p>于是$| MN | = 10 | k _1 - k _2 | $.注意到$k _1 &gt; 0 \land - k _2 &gt; 0 \land k _1 ( - k _2 ) = \frac { 9  } { 20  } $,显然可以用基本不等式计算,最后得到$S _{ \min  } = \frac { 45 \sqrt { 5  }  } { 2  } $.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出$A _1 Q : x = - 2 + \frac { y _2  } { x _2 + 2  } y , A _2 P : x = 2 + \frac { y _1  } { x _1 - 2  } y $,然后我们声明这两条直线的交点的横坐标一定是$8 $,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5><p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们将$y $看作$x $的函数,对两边求导,自然得到:</p>
<script type="math/tex; mode=display">
\frac { 2 x  } { a ^2  } + \frac { 2 yy '  } { b ^2  } = 0</script><p>这是个方程,你可以解得$y ‘ = - \frac { b ^2 x  } { a ^2 y  } $.而这就是椭圆过$( x , y ) $这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5><p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6><p>向量$\vec { b  } = ( x , y ) $逆时针旋转$\theta $后得到的答案是$A \vec { b  } $,其中</p>
<p>\cos\theta,-\sin\theta\\</p>
<p>\sin\theta,\cos\theta</p>
<p>\end{bmatrix} </p>
<p>你要不喜欢矩阵表示也不是不行,那向量$( x , y ) $旋转$\theta $得到$( x ‘ , y ‘ ) $,其中</p>
<p>y’=xsin\theta+ycos\theta</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6><p>我们注意到圆的方程是$( x ‘ ) ^2 + ( y ‘ ) ^2 = 1 $,而椭圆的方程形如$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们注意到上面的式子等价于:$( \frac { x  } { a  } ) ^2 + ( \frac { y  } { b  } ) ^2 = 1 $.我们将原坐标系中的所有坐标$( x , y ) $全部变成$( \frac { x  } { a  } , \frac { y  } { b  } ) $之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令$\vec { f  } = ( x , y ) $满足椭圆方程,令$\vec { g  } = ( x ‘ , y ‘ ) $满足圆的方程,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}
\frac { 1  } { a  } , 0 \\
0 , \frac { 1  } { b  } 
\end{bmatrix} \vec { f  } & = \vec { g  } \\

\end{aligned}</script><script type="math/tex; mode=display">
\begin{bmatrix}
a , 0 \\
0 , { b  } 
\end{bmatrix} \vec { g  } = \vec { f  }</script><h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6><p>注意到反比例函数的方程是$x ‘ y ‘ = 1 $,而双曲线的方程是$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
<p>首先先转化为$x ^2 - y ^2 = 2 $的形式,需要左乘矩阵$\begin{bmatrix}\frac { \sqrt { 2  }  } { a  } , 0 \ 0 , \frac { \sqrt { 2  }  } { b  } \end{bmatrix} $.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转$\frac { \pi  } { 4  } $了.旋转矩阵为</p>
<p>\frac{1}{\sqrt{2}},-\frac{1}{\sqrt{2}}\\</p>
<p>\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>\frac{1}{a},-\frac{1}{b}\\</p>
<p>\frac{1}{a},\frac{1}{b}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x ‘ = \frac { x  } { a  } - \frac { y  } { b  } , y ‘ = \frac { x  } { a  } + \frac { y  } { b  } $.带入反比例函数的方程:</p>
<script type="math/tex; mode=display">
x ' y ' = \frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1</script><p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>\frac{a}{2},\frac{a}{2}\\</p>
<p>-\frac{b}{2},\frac{b}{2}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x = \frac { a  } { 2  } ( x ‘ + y ‘ ) , y = \frac { b  } { 2  } ( { y ‘ - x ‘  } ) $,带入双曲线方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \frac { x  } { a  } ) ^2 - ( \frac { y  } { b  } ) ^2 & = 1 \\
( x ' + y ' ) ^2 - ( x ' - y ' ) ^2 & = 4 \\
x ' y ' & = 1 
\end{aligned}</script><p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6><p>这个比较简单,交换$x , y $即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5><p>平面内取一点$O $为极点,引一条射线$Ox $叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点$M $,令$\rho = | OM | $,$\theta $为以$Ox $为始边,沿角度正方向(一般是逆时针方向)转到$OM $的夹角.那么我们称$( \rho , \theta ) $为$M $的极坐标,其中$\rho $叫做极径,$\theta $叫做极角.</p>
<p>$\rho $有可能取负,我们通常认为$( - \rho , \theta ) = ( \rho , \theta + \pi ) $.</p>
<p>通常情况下默认$0 \leq \theta &lt; 2 \pi , \rho \geq 0 $.如果遇到和直角坐标系结合的问题,通常默认原点为极点,$x $轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若$M $在直角坐标系中坐标为$( x , y ) $,在极坐标中坐标为$( \rho , \theta ) $,若$M \ne O $自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x & = \rho \cos \theta , y & = \rho \sin \theta \\
\rho ^2 & = x ^2 + y ^2 , \theta & = \begin{cases}
\frac { \pi  } { 2  } & x = 0 \land y > 0 \\
\frac { 3 \pi  } { 2  } & x = 0 \land y < 0 \\
\arctan ( \frac { y  } { x  } ) & x \ne 0 
\end{cases} 
\end{aligned}</script><p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6><p>显然是$\rho ^2 = r ^2 $.</p>
<p>另外,如果中心在$C ( \rho _0 , \theta _0 ) $,半径为$r $的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
r ^2 & = ( \rho \cos \theta - \rho _0 \cos \theta _0 ) ^2 + ( \rho \sin \theta - \rho _0 \sin \theta _0 ) \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos \theta \cos \theta _0 - 2 \rho \rho _0 \sin \theta \sin \theta _0 \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos ( \theta - \theta _0 ) 
\end{aligned}</script><p>另外由于$\cos \theta = \cos ( - \theta ) $,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6><p>过定点$( \rho _1 , \theta _1 ) $,且倾斜角为$\alpha $:$\rho \sin ( \alpha - \theta ) = \rho _1 \sin ( \alpha - \theta _1 ) $.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点$( x _1 , y _1 ) $,倾斜角为$\alpha $,我们自然有$( x - x _1 ) \sin \alpha = ( y - y _1 ) \cos \alpha $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) \sin \alpha & = ( y - y _1 ) \cos \alpha \\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) \sin \alpha & = ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) & = \rho _1 \sin ( \alpha - \theta _1 ) 
\end{aligned}</script><p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点$( \rho _1 , \theta _1 ) $和$( \rho _2 , \theta _2 ) $的直线方程.</p>
<p>同理的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) ( y _2 - y _1 ) & = ( y - y _1 ) ( x _2 - x _1 ) \\
\\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) ( \rho _2 \sin \theta _2 - \rho _1 \sin \theta _1 ) \\
& = ( \rho _2 \cos \theta _2 - \rho _1 \cos \theta _1 ) ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \\
\\
\rho \rho _2 ( \cos \theta \sin \theta _2 - \cos \theta _2 \sin \theta ) \\
+ \rho \rho _1 ( - \cos \theta \sin \theta _1 + \sin \theta \cos \theta _1 ) \\
+ \rho _1 \rho _2 ( - \cos \theta _1 \sin \theta _2 + \cos \theta _2 \sin \theta _1 ) \\
& = 0 \\
\\
\rho \rho _2 \sin ( \theta _2 - \theta ) + \rho \rho _1 \sin ( \theta - \theta _1 ) + \rho _1 \rho _2 \sin ( \theta _1 - \theta _2 ) & = 0 
\end{aligned}</script><p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6><p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离$d $和到定点距离$r $之比为常数的曲线.令$e = \frac { r  } { d  } $.</p>
<p>假定定点为原点,极轴垂直于准线,$h $为定点到准线的距离,又设曲线上一点为$M ( \rho , \theta ) $,自然有:$r = \rho , d = h + \rho \cos \theta $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
e & = \frac { \rho  } { h + \rho \cos \theta  } \\
he + e \rho \cos \theta & = \rho \\
\rho & = \frac { he  } { 1 - e \cos \theta  } 
\end{aligned}</script><p>值得一提的是这玩意不能将圆理解为$e = 0 $的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5><p>在平面直角坐标系中,曲线上任意一点的坐标$x , y $都是某个变量$t $的函数$\begin{cases}x = f ( t ) \ y = g ( t ) \end{cases} $.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6><p>$M ( r \cos \theta , r \sin \theta ) $,其中$\theta $是$\angle OMx $.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6><p>$M ( x _0 + t \cos \theta , y _0 + t \sin \theta ) $,其中$\theta $是倾斜角,$t $是参数,$M _0 ( x _0 , y _0 ) $.</p>
<p>注意到$| M _0 M | = | t | $.事实上,设$\vec { e  } = ( \cos \theta , \sin \theta ) $,也就是直线的单位方向向量,则$\overrightarrow { M _0 M  } = t \vec { e  } $.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6><p>$M ( a \cos \theta , b \sin \theta ) $,其中$\theta $称为$M $的离心角.</p>
<p>值得注意的是,这里的$\theta $并非$\angle MOx $,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆$\frac { x ^2  } { 9  } + \frac { y ^2  } { 4  } = 1 $上求一点$M $,使$M $到直线$x + 2 y - 10 = 0 $的距离最小.</p>
<p>直接令$M = ( 3 \cos \theta , 2 \sin \theta ) $,则$d = \frac { | 3 \cos \theta + 4 \sin \theta - 10 |  } { \sqrt { 5  }  } = | \sqrt { 5  } \sin ( \theta + \varphi ) - 2 \sqrt { 5  } | $,其中$\varphi = \arcsin \frac { 3  } { 5  } $.</p>
<p>于是$d _{ \min  } = \sqrt { 5  } $,此时$\sin ( \theta + \varphi ) = 1 = \sin { \frac { \pi  } { 2  }  } $,那么就有$\theta = \frac { \pi  } { 2  } - \varphi $,$\sin \theta = \cos \varphi = \frac { 4  } { 5  } , \cos \theta = \sin \varphi = \frac { 3  } { 5  } $.</p>
<p>则$M = ( \frac { 9  } { 5  } , \frac { 8  } { 5  } ) $.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 100  } + \frac { y ^2  } { 64  } = 1 $,有一内接矩阵$ABCD $($AB / / x , BC / / y $),求矩阵最大面积.</p>
<p>直接令$A = ( 10 \cos \theta , 8 \sin \theta ) $,则$S = 20 \cos \theta \times 16 \sin \theta = 160 \sin ( 2 \theta ) $,$S _{ \max  } = 160 $.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6><p>$M ( \frac { a  } { \cos \theta  } , b \tan \theta ) = M ( a \sec \theta , b \tan \theta ) $,其中$\theta $称为$M $的离心角,通常规定$\theta \in [ 0 , 2 \pi ] \land \theta \ne \frac { \pi  } { 2  } \land \theta \ne \frac { 3 \pi  } { 2  } $.</p>
<p>其实本质也就是三角恒等式$\sec ^2 \theta = 1 + \tan ^2 \theta $.</p>
<p><strong>Example1</strong></p>
<p>圆$O : x ^2 + ( y - 2 ) ^2 = 1 $上有一点$P $,双曲线$x ^2 - y ^2 = 1 $上有一点$Q $,求$| PQ | _{ \min  } $.</p>
<p>设$Q ( \sec \theta , \tan \theta ) $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
| OQ | ^2 & = \sec ^2 \theta + ( \tan \theta - 2 ) ^2 \\
& = \tan ^2 \theta + 1 ( \tan \theta - 2 ) ^2 \\
& = 2 ( \tan \theta - 1 ) ^2 + 3 
\end{aligned}</script><p>$| OQ | _{ \min  } = \sqrt { 3  } , | PQ | _{ \min  } = \sqrt { 3  } - 1 $.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设$P ( a \sec \theta , a \tan \theta ) , Q ( - a \sec \theta , a \tan \theta ) $,则$k _P = \frac { a \tan \theta  } { a \sec \theta - a  } , k _Q = \frac { a \tan \theta  } { - a \sec \theta - a  } $.注意到$k _P \cdot k _Q = - 1 $.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,$A , B $是双曲线同支上相异两点,线段$AB $的垂直平分线与$x $轴相交于点$P ( x _0 , 0 ) $,求证:$| x _0 | &gt; \frac { c ^2  } { a  } = \frac { a ^2 + b ^2  } { a  } $.</p>
<p>设$A ( a \sec \alpha , b \tan \alpha ) , B ( a \sec \beta , b \tan \beta ) $,则中点$M ( \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) , \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) $.</p>
<p>于是中垂线方程为$y - \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) = - \frac { a ( \sec \alpha - \sec \beta )  } { b ( \tan \alpha - \tan \beta )  } [ x - \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) ] $.</p>
<p>代入$P ( x _0 , 0 ) $,求得$x _0 = \frac { c ^2  } { 2 a  } ( \sec \alpha + \sec \beta ) $.</p>
<p>也就是要比较$| \sec \alpha + \sec \beta | $和$2 $的大小关系,注意到$A , B $同支,所以$| \sec \alpha + \sec \beta | &gt; 2 $.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6><p>$M ( \frac { 2 p  } { \tan ^2 \theta  } , \frac { 2 p  } { \tan \theta  } ) $,其中$\theta $称为$M $的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:$M ( 2 pk ^2 , 2 pk ) $,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
<p>若抛物线$\begin{cases}x = 2 pt ^2 \ y = 2 pt \end{cases} $上有不同两点$M _1 , M _2 $,所对应的参数分别是$t _1 , t _2 $,求直线$M _1 M _2 $所在直线的斜率.</p>
<p>$k _{ M _1 M _2  } = \frac { 2 pt _1 - 2 pt _2  } { 2 pt _1 ^2 - 2 pt _2 ^2  } = \frac { 1  } { t _1 + t _2  } $.</p>
<p><strong>Example2</strong></p>
<p>$A , B $是抛物线$y ^2 = 2 px $上异于顶点的两动点,且$OA \bot OB $,$AB $上有一点$M $满足$OM \bot AB $,求$M $的轨迹方程.</p>
<p>设$M ( x , y ) , A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { OM  } & = ( x , y ) \\
\overrightarrow { OA  } & = ( 2 pt _1 ^2 , 2 pt _1 ) \\
\overrightarrow { OB  } & = ( 2 pt _2 ^2 , 2 pt _2 ) \\
\overrightarrow { AB  } & = ( 2 p ( t _2 ^2 - t _1 ^2 ) , 2 p ( t _2 - t _1 ) ) 
\end{aligned}</script><p>因为$\overrightarrow { OA  } \bot \overrightarrow { OB  } $,所以$( 2 pt _1 t _2 ) ^2 + ( 2 p ) ^2 t _1 t _2 = 0 $,$t _1 t _2 = - 1 $.</p>
<p>因为$\overrightarrow { AB  } \bot \overrightarrow { OM  } $,又有$k _{ AB  } = \frac { 1  } { t _1 + t _2  } $,所以$k _{ OM  } = - ( t _1 + t _2 ) $,$\frac { y  } { x  } = - ( t _1 + t _2 ) $.</p>
<p>接下来咋做捏?注意到我们好像忘记了$ABM $三点共线的性质,拿向量做这个东西.</p>
<p>$\overrightarrow { AM  } = ( x - 2 pt _1 ^2 , y - 2 pt _1 ) , \overrightarrow { MB  } = ( 2 pt _2 ^2 - x , 2 pt _2 - y ) $.</p>
<p>那么有$( x - 2 pt _1 ^2 ) ( 2 pt _2 - y ) = ( 2 pt _2 ^2 - x ) ( y - 2 pt _1 ) $.</p>
<p>化简得到$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点$A , B $,自然要设出它们的参数方程.然后呢?然后我们发现最后$M $一定和$t _1 , t _2 $有关.但是我们要求的是$M $的方程,其中不能带有$t _1 , t _2 $,因此考虑把$M $的坐标设出来,再用这个坐标表示$t _1 , t _2 $,表示不出来表示$t _1 t _2 , t _1 + t _2 $也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到$M $一定在以$| OA | $为直径的圆上,$B $同理,这两个圆的方程分别为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^2 + y ^2 - 2 pt _1 ^2 x - 2 pt _1 y & = 0 \\
x ^2 + y ^2 - 2 pt _2 ^2 x - 2 pt _2 y & = 0 
\end{aligned}</script><p>也就是说,$t _1 , t _2 $是同一个方程的两个根,根据韦达定理自然有$t _1 t _2 = \frac { - ( x ^2 + y ^2 )  } { 2 px  } = - 1 $,于是直接有$x ^2 + y ^2 - 2 px = 0 $.</p>
<p>还没完,注意到$O $一定是一个根,要去掉,所以答案就是$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p><strong>Example3</strong></p>
<p>已知$A , B , C $是抛物线$y ^2 = 2 px ( p &gt; 0 ) $上的三个点,且$BC $与$x $轴垂直,直线$AB $和$AC $分别与抛物线的轴交于$D , E $两点,求证:抛物线的顶点平分$DE $.</p>
<p>设$A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) , C ( 2 pt _2 ^2 , - 2 pt _2 ) $,注意到$AB : y - 2 pt _1 = \frac { 1  } { t _1 + t _2  } ( x - 2 pt _1 ^2 ) $,$AC : t - 2 pt _1 = \frac { 1  } { t _1 - t _2  } ( x - 2 pt _1 ^2 ) $.</p>
<p>可求得$D ( - 2 pt _1 t _2 , 0 ) , E ( 2 pt _1 t _2 , 0 ) $,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5><p>参考:<a href="https://zhuanlan.zhihu.com/p/591258689">https://zhuanlan.zhihu.com/p/591258689</a></p>
<h6><span id="定义">定义</span></h6><p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6><p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 + b ^2 $.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 - b ^2 $.</p>
<p>证明:其实注意到椭圆的证明中设$b $是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线$y ^2 = 2 px $,其蒙日圆方程为$x = - \frac { p  } { 2  } $.</p>
<p>有一说一,直线是半径无穷大的圆.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>递归式与和式</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3><p>三个柱子,$n $个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T _n $表示答案,显然$T _0 = 0 , T _1 = 1 $.</p>
<p>而我们一定可以找到一种方案,使得前$n - 1 $个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把$n - 1 $个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:$T _n \leq 2 T _{ n - 1  } + 1 $.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:$2 T _{ n - 1  } + 1 \leq T _n $.于是有$T _n = 2 T _{ n - 1  } + 1 $.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4><p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4><p>考虑设$T _n $为n个圆盘时的最小操作次数.假设已知$T _{ n - 1  } $,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T _{ n  } = 3 T _{ n - 1  } + 2 , T _0 = 0 $.</p>
<p>考虑如何求该式子的封闭形式,令$W _n = T _n + 1 $,显然有$W _n = 3 W _{ n - 1  } , W _0 = 1 $,显然$W _n = 3 ^n $,有$T _n = 3 ^n - 1 $.</p>
<p>注意到$T _n $刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4><p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2 ^n - 1 $.</p>
<h4><span id="solution-2">Solution 2</span></h4><p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4><p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4><p>令$Q _n $为将n个圆盘从A移动到B的最小操作次数,令$R _n $为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q _0 = 0 , R _0 = 0 $.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q _n $的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,$R _n $的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q _n = 2 R _{ n - 1  } + 1 , 1 \leq n $.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R _n = R _{ n - 1  } + 1 + Q _{ n - 1  } + 1 + R _{ n - 1  } = Q _n + Q _{ n - 1  } + 1 , 1 \leq n $.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4><p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4><p>a.仍然令$T _n $为n对圆盘的最小操作次数,显然$T _n = 2 T _{ n - 1  } + 2 , T _0 = 0 $,可解得$T _n = 2 ^{ n + 1  } - 2 $.</p>
<p>b.令$Q _n $为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现$Q _n = T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } = 4 T _{ n - 1  } + 3 = 2 ^{ n + 2  } - 5 $.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q _n $就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4><p>类似Problem11,但第$i $大的圆盘有$k _i $个.</p>
<h4><span id="solution-5">Solution 5</span></h4><p>无区别,只是$T _n = 2 T _{ n - 1  } + k _n , T _0 = 0 $.</p>
<p>如果求封闭形式的话,显然有$T _n = \sum _{ i = 1  } ^n 2 ^{ n - i  } k _i $.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3><p>在上述问题中，我们已经有了以下式子：</p>
<p>$T _n = 2 T _{ n - 1  } + 1 , n &gt; 0 , T _0 = 0 $.</p>
<p>如果$n $很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出$T _n $的方法.</p>
<p>换句话说，我们想要把$T _n $表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4><h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5><p>解递归式:$Q _n = \begin{cases}\alpha &amp; n = 0 \ \beta &amp; n = 1 \ \frac { ( 1 + Q _{ n - 1  } )  } { Q _{ n - 2  }  } &amp; n &gt; 1 \end{cases} $,保证$\forall n , Q _n &gt; 0 $.</p>
<h5><span id="solution">Solution</span></h5><p>注意到$Q _2 = \frac { \beta + 1  } { \alpha  } , Q _3 = \frac { \beta + \alpha + 1  } { \beta \alpha  } , Q _4 = \frac { 1 + \alpha  } { \beta  } , Q _5 = \alpha , Q _6 = \beta $.</p>
<p>显然该递归式存在长度为$5 $的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4><p>观察T序列的前几项，可以发现似乎有$T _n = 2 ^n - 1 $.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n = 0 $成立，显然可验证.</p>
<p>2.若该公式对$n = k $时成立，那该公式必然对$n = k + 1 $成立.</p>
<p>因为有$T _{ k + 1  } = 2 T _k + 1 = 2 \times 2 ^k + 2 - 1 = 2 ^{ k + 1  } - 1 $.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5><p>求证:$\prod _{ i = 1  } ^n x _i \leq ( \frac { \sum _{ i = 1  } ^n x _i  } { n  } ) ^n , \forall i \in N _+ , 1 \leq i \leq n , 0 \leq x _i $.</p>
<h5><span id="solution">Solution</span></h5><p>使用反向归纳法.</p>
<p>1.$n = 2 $时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n = k $时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A _1 = \sqrt [k ] { \prod _{ i = 1  } ^k x _i  } , B _1 = \sqrt [k ] { \prod _{ i = k + 1  } ^{ 2 k  } x _i  } , A _2 = ( \frac { \sum _{ i = 1  } ^k x _i  } { k  } ) , B _2 = ( \frac { \sum _{ i = k + 1  } ^{ 2 k  } x _i  } { k  } ) $,显然有$A _1 \leq A _2 , B _1 \leq B _2 $.</p>
<p>同时有$( \frac { A _2 + B _2  } { 2  } ) \geq \sqrt { A _2 B _2  } \geq \sqrt { A _1 B _1  } $.</p>
<p>3.若该式子对$n = k $时成立,则该式子对$n = k - 1 $的时候也成立.</p>
<p>令$x _k = \frac { \sum _{ i = 1  } ^{ k - 1  } x _i  } { k - 1  } $,有$x _k \prod _{ i = 1  } ^{ k - 1  } x _i \leq ( x _k ) ^k $.</p>
<p>则显然$n = k - 1 $时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4><p>考虑令$U _n = T _n + 1 $,显然有:$T _n + 1 = 2 T _{ n - 1  } + 2 $.即$U _n = 2 U _{ n - 1  } $,显然$U _n = 2 ^n $,则$T _n = 2 ^n - 1 $.</p>
<p>这个做法可以做掉所有形如$a _{ n + 1  } = pa _n + q $的递归式.我们有:</p>
<script type="math/tex; mode=display">
a _{ n + 1  } + \frac { q  } { p - 1  } = p ( a _n + \frac { q  } { p - 1  } )</script><p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4><p>考虑递归式$a _n T _n = b _n T _{ n - 1  } + c _n $.如果我们能找到一个不为0的求和因子$s _n $并满足$s _n b _n = s _{ n - 1  } a _{ n - 1  } $.那么我们两面同时乘以$s _n $,显然有：$s _n a _n T _n = s _{ n - 1  } a _{ n - 1  } T _{ n - 1  } + c _n s _n $.</p>
<p>令$S _n = s _n a _n T _n $.显然有$S _n = s _0 a _0 T _0 + \sum _{ i = 1  } ^n s _i c _i $,则$T _n = \frac { S _n  } { s _n a _n  } $.</p>
<p>而我们也会发现$s _n = \frac { \prod _{ i = 1  } ^{ n - 1  } a _i  } { \prod _{ i = 1  } ^n b _i  } $.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5><p>结论:排序$n $个数时,其期望复杂度满足:</p>
<script type="math/tex; mode=display">
C _n = \begin{cases}
0 & n = 0 , 1 \\
n + 1 + \frac { 2  } { n  } \sum _{ i = 0  } ^{ n - 1  } C _k & n > 1 
\end{cases}</script><p>不妨考虑两边同时乘以$n $,有 $nC _n = n ^2 + n + 2 \sum _{ i = 0  } ^{ n - 1  } C _i , n &gt; 1 $ .</p>
<p>显然也有$( n - 1 ) C _{ n - 1  } = ( n - 1 ) ^2 + n - 1 + 2 \sum _{ i = 0  } ^{ n - 2  } C _i , n &gt; 2 $.</p>
<p>二式相消,有$nC _n - ( n - 1 ) C _{ n - 1  } = 2 n + 2 C _{ n - 1  } , n &gt; 2 $.</p>
<p>而同时有$C _2 = 3 $.即:$nC _n = ( n + 1 ) C _{ n - 1  } + 2 n , n &gt; 2 $,可以使用转化和式的方法,两边乘以$\frac { 1  } { n ( n + 1 )  } $解决.</p>
<h5><span id="example2">Example2</span></h5><p>已知$a _1 = 1 $,$a _n = \sqrt { S _n  } + \sqrt { S _{ n - 1  }  } $,求$a _n $.</p>
<p>注意到$a _n = S _n - S _{ n - 1  } $,则有$\sqrt { S _n  } - \sqrt { S _{ n - 1  }  } = 1 $,于是$\sqrt { S _n  } = n $,$S _n = n ^2 $,$a _n = 2 n - 1 $.</p>
<h4><span id="成套方法">成套方法</span></h4><p>如果我们有</p>
<p>\alpha &amp; n=1\\</p>
<p>2f(\frac n 2)+\beta &amp; n=2k,k\in \mathbb{N_+}\\</p>
<p>2f(\frac {n-1}2)+\gamma &amp;n=2k+1,k\in \mathbb{N_+}</p>
<p>\end{cases}</p>
<p>其中$n = 2 ^m + l $且$2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>该如何求出$f ( n ) $的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有$f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n ) \gamma $,而有$A 、 B 、 C $互不影响且$\alpha \beta \gamma $与$ABC $无关.</p>
<p>那无论$\beta $和$\gamma $的取值如何,$A ( n ) $都不会受到影响,我们考虑$\beta = \gamma = 0 $的特殊情况,此时显然有$A ( n ) = 2 ^m $.</p>
<p>接下来,我们考虑取$\alpha \beta \gamma $的特殊值,去得到ABC之间的关系.</p>
<p>例如，当$f ( n ) = 1 $时，由递推式可知$\alpha = 1 , \beta = \gamma = - 1 $,那么有$A ( n ) - B ( n ) - C ( n ) = f ( n ) = 1 $.</p>
<p>同理，$f ( n ) = n $时，可知$\alpha = 1 , \beta = 0 , \gamma = 1 $,此时有$A ( n ) + C ( n ) = f ( n ) = n $.</p>
<p>显然可以通过解方程求得$B ( n ) $和$C ( n ) $.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC $互不影响且$\alpha \beta \gamma $与$ABC $无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>直接在复数域上定义$f _k ( x ) = \{ n ^k x ^n \} _{ n = 0  } ^\infty $,此时我们规定$0 ^0 = 1 $.特别地,当$x = 0 $的时候,定义$f _k ( x ) $的第$k $项是$1 $,其余项是$0 $.在此基础上定义线性映射$T : ( a _n ) _{ n = 0  } ^\infty \mapsto ( a _{ n + 1  } ) _{ n = 0  } ^\infty $,立刻见到:$( T - x ) ^{ k + 1  } f _k ( x ) = 0 , ( T - x ) ^k f _k ( x ) \ne 0 $.原因只需简单数学归纳.而此还可以引出$f _0 ( x ) , f _1 ( x ) , \cdots $线性无关.</p>
<p>在此基础上观察线性递推$a _{ n + d  } = c _{ d - 1  } a _{ n + d - 1  } + \cdots + c _0 a _n $,不妨取$G ( x ) = x ^d - c _{ d - 1  } x ^{ d - 1  } - \cdots - c _0 $,立刻应当见到如果$a $是$G $的根并且重数为$e ( a ) $,那么$f _{ 0  } ( x ) , \cdots , f _{ e ( a ) - 1  } ( a ) $都在$\ker f ( T ) $中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如$\sum _j w _i f _i ( y ) = \sum _j w _j f _j ( x ) $的情况,此时对右边直接操作若干次$( T - x ) $就可以把右边全部消成$0 $,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于$n $的多项式右边的$( T - x ) $是不会改变左边这边的每一个位置多项式的$\deg $,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3><p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是$2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 , 9 $.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有$J ( 2 n ) = 2 J ( n ) - 1 $;当人数是奇数时,我们杀掉一号,然后有$J ( 2 n + 1 ) = 2 J ( n ) + 1 $.</p>
<p>整理得到:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 1 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>仍然可以使用数学归纳，如果令$n = 2 ^m + l 且 2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>有$J ( n ) = 2 l + 1 $.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从$0 $开始编号:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
0 & n = 1 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>这下相信$J ( n ) $是多少就很显然了,将$n $写成二进制的形式,这个就相当于把首位$1 $抹去然后在末尾加个$0 $.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4><p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4><p>显然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
2 & n = 2 \\
1 & n = 3 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>从$0 $开始编号,自然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 2 \\
0 & n = 3 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>显然$J ( n ) $也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2><h3><span id="和式的基本运算">和式的基本运算</span></h3><p>分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i</script><p>一般分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j )</script><p>结合律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i</script><p>交换律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  }</script><p>交换求和顺序:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] & = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] \\
\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } & = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } 
\end{aligned}</script><h3><span id="和式的封闭形式">和式的封闭形式</span></h3><h4><span id="交换顺序法">交换顺序法</span></h4><h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i < j \leq n  } ( a _j - a _i ) ( b _j - b _i ) 
\end{aligned}</script><p>显然有以下式子:</p>
<p>(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\geq n\sum_{i=1}^na_ib_i，\forall i&lt;j，a_i\leq a_j且b_i\geq b_j\\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5><p>证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 & = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \\

\end{aligned}</script><p>有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 \\
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k + a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5><p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n i ^2 & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推,我们设$W _n = \sum _{ i = 0  } i ^3 $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5><p>令$H _n = \sum _{ k = 1  } ^n \frac { 1  } { k  } $,求$\sum _{ i = 0  } ^n H _i $.</p>
<h5><span id="solution3">Solution3</span></h5><p>不妨考虑$\sum _{ i = 0  } ^n iH _{ i  } $的值.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^n iH _{ i  } & = \sum _{ i = 1  } ^n [ ( i - 1 + 1 ) H _{ i - 1  } + 1 ] \\
& = n + \sum _{ i = 0  } ^{ n - 1  } H _i + \sum _{ i = 0  } ^{ n  } iH _i - nH _n \\
\sum _{ i = 0  } ^{ n - 1  } H _i & = n ( H _n - 1 ) \\
\sum _{ i = 0  } ^n H _i & = ( n + 1 ) ( H _{ n + 1  } - 1 ) \\

\end{aligned}</script><h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5><p>求$S _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } , T _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i , U _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i ^2 $.</p>
<h5><span id="solution-4">Solution 4</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 1  } ^{ n  } ( - 1 ) ^{ n - i  } + ( - 1 ) ^n \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - 1 - i  } \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + S _{ n - 1  } \\
S _{ n - 1  } & = \frac { 1 - ( - 1 ) ^n  } { 2  } \\
S _n & = \frac { 1 + ( - 1 ) ^n  } { 2  } 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
T _{ n  } & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i \\
- T _{ n - 1  } + n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- T _{ n - 1  } + n & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } - ( - 1 ) ^n \\
- T _{ n - 1  } + n & = T _{ n - 1  } + S _n - ( - 1 ) ^n \\
n - \frac { 1 - ( - 1 ) ^n  } { 2  } & = 2 T _{ n - 1  } \\
T _n & = \frac { 1  } { 2  } ( n + 1 + \frac { - 1 - ( - 1 ) ^n  } { 2  } ) & = \frac { 1  } { 2  } ( n + \frac { 1 - ( - 1 ) ^n  } { 2  } ) 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
U _n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 + 1 ) ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) ^2 + 2 \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i ^2 + 2 \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } \\
- U _{ n - 1  } + n ^2 & = U _{ n - 1  } + 2 T _{ n - 1  } + S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - 2 T _{ n - 1  } - S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - ( n - \frac { 1 - ( - 1 ) ^n  } { 2  } ) - \frac { 1 - ( - 1 ) ^n  } { 2  } \\
2 U _{ n - 1  } & = n ^2 - n \\
U _n & = \frac { n ( n + 1 )  } { 2  } 
\end{aligned}</script><h4><span id="转化为递归式">转化为递归式</span></h4><p>考虑和式$S _n = \sum _{ i = 0  } ^n f ( i ) = S _{ n - 1  } + f ( n ) \ $，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5><p>求$\sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 \ $.</p>
<h5><span id="solution1">Solution1</span></h5><p>令$S ( n ) = \sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 = S ( n - 1 ) + ( - 1 ) ^n n ^2 $,考虑使用成套方法.</p>
<p>不妨令$S ( n ) = S ( n - 1 ) + ( - 1 ) ^n ( \alpha + \beta n + \gamma n ^2 ) = \alpha A ( n ) + \beta B ( n ) + \gamma C ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n , 可 以 解 得 \alpha = - 1 , \beta = 2 , \gamma = 0 $,有$( - 1 ) ^n n = - A ( n ) + 2 B ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n ^2 , 可 以 解 得 \alpha = 1 , \beta = - 2 , \gamma = 2 $,有$( - 1 ) ^n n ^2 = A ( n ) - 2 B ( n ) + 2 C ( n ) $.</p>
<p>显然可解得$2 C ( n ) = ( - 1 ) ^n n ^2 + ( - 1 ) ^n n , C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<p>而原式中,$S ( n ) = C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5><p>有$2 T _n = nT _{ n - 1  } + 3 n ! , T _0 = 5 $,求$T _n $.</p>
<h5><span id="solution-2">Solution 2</span></h5><p>令$s _n = \frac { 2 ^{ n - 1  }  } { n !  } $,两边同时乘以$s _n $,有$\frac { 2 ^n  } { n !  } T _n = \frac { 2 ^{ n - 1  }  } { ( n - 1 ) !  } T _{ n - 1  } + 3 \times 2 ^{ n - 1  } \ $.</p>
<p>令$S _n = \frac { 2 ^n  } { n !  } T _n $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = S _{ n - 1  } + 3 \times 2 ^{ n - 1  } \\
& = 5 + 3 \sum _{ i = 0  } ^{ n - 1  } 2 ^i \\
& = 5 + 3 \times 2 ^{ n + 1  } - 3 \\
& = 3 \times 2 ^{ n  } + 2 \\
T _n & = 3 n ! + \frac { n !  } { 2 ^{ n - 1  }  } 
\end{aligned}</script><h4><span id="转化为积分形式">转化为积分形式</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数$f ( x ) = x ^2 $,显然$\int _0 ^n x ^2 dx = \frac { n ^3  } { 3  } \sim S _n \ $.</p>
<p>接下来,我们考虑求得二者之间的误差,设$E _n = S _n - \frac { n ^3  } { 3  } \ $,对其使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \frac { n ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 + 1 ) ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 ) ^3  } { 3  } - ( n - 1 ) ^2 - ( n - 1 ) - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n ^2 - n ^2 + 2 n - 1 - n + 1 - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n - \frac { 1  } { 3  } 
\end{aligned}</script><p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \int _0 ^n x ^2 dx \\
& = \sum _{ k = 1  } ^n ( k ^2 - \int _{ k - 1  } ^k x ^2 dx ) \\
& = \sum _{ k = 1  } ^n ( k ^2 - \frac { k ^3 - ( k - 1 ) ^3  } { 3  } ) \\
& = \sum _{ k = 1  } ^n ( k - \frac { 1  } { 3  } ) 
\end{aligned}</script><p>这是一个简单的和式.而$S _n = E _n + \frac { n ^3  } { 3  } \ $,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5><p>已知$a _1 = 1 , a _{ n + 1  } - a _n = - \frac { 1  } { 3  } a _n ^2 $,估计$a _n $的值.</p>
<p>考虑构造一个函数$f ( n ) $使得$f ( n ) \approx a _n $,那我们就可以将$a _{ n + 1  } - a _n \approx f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$\exists x _0 \in [ n , n + 1 ] , f ‘ ( x _0 ) = f ( n + 1 ) - f ( n ) $,而对于增长率变化不大的函数,直接认为$f ‘ ( x _0 ) = f ‘ ( n ) $是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 $解得$f ( n ) = \frac { 3  } { n + 2  } $.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令$a _n = \frac { 3  } { n + 2  } - b _n $,带入化简,得到$\{ b _n \} $的递推式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } & = ( \frac { 3  } { n + 2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _{ n + 1  } - \frac { 3  } { n + 3  } & = ( b _n - \frac { 3  } { n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 & = 0 , b _{ n + 1  } & = \frac { b _n ^2  } { 3  } + \frac { n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  } 
\end{aligned}</script><p>算到这里,我们可以很轻易使用数学归纳法算出$b _n \leq \frac { 1  } { 4 n  } $,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n $的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设$b _n ^2 &lt; &lt; b _n $:</p>
<p>那么这个$b _n $是$O ( \frac { \ln n  } { n ^2  } ) $级别的.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b _{ n + 1  } & = \frac { n  } { n + 2  } b _n + \frac { 1  } { n ( n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } & = n ( n + 1 ) b _n + \frac { 1  } { n  } \\
g ( n ) & = n ( n + 1 ) b _n , g ' ( n ) & = \frac { 1  } { n  } , g ( n ) & = \ln n \\
b _n & = \frac { \ln n  } { n ^2  } 
\end{aligned}</script><p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ \epsilon  } ) $和$O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n \leq \frac { 3 \ln n  } { n ( n + 1 )  } $.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5><p>求$\sum _{ i = 1  } ^n i 2 ^i \ $.</p>
<h5><span id="solution-2">Solution 2</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n i 2 ^i & = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i 2 ^i \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n 2 ^i \\
& = \sum _{ j = 1  } ^n ( 2 ^{ n + 1  } - 2 ^j ) \\
& = n 2 ^{ n + 1  } - ( 2 ^{ n + 1  } - 2 ) \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 
\end{aligned}</script><h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<h5><span id="solution-3">Solution 3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="exampleex">ExampleEX</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solutionex">SolutionEX</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="exampleex2">ExampleEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( x ) & = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x & = f ( x ) + C \\

\end{aligned}</script><p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( x ^{ \underline { m  }  } ) & = mx ^{ \underline { m - 1  }  } \\
\sum mx ^{ \underline { m - 1  }  } \delta x & = x ^{ \underline { m  }  } + C , m \ne 0 \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( H ( x ) ) & = x ^{ \underline { - 1  }  } & = \frac { 1  } { x + 1  } \\
\sum x ^{ \underline { - 1  }  } \delta x & = H ( x ) + C \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( 2 ^x ) & = 2 ^x , \sum 2 ^x \delta x & = 2 ^x + C \\
\Delta ( c ^x ) & = ( c - 1 ) c ^x , \sum c ^x \delta x & = \frac { c ^x  } { c - 1  } + C , c \ne 1 \\
\Delta ( c ^{ \underline { x  }  } ) & = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x & = c ^{ \underline { x  }  } + C , c - x \ne 0 \\

\end{aligned}</script><p>根据组合数公式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( \binom { x  } { k  } ) & = \binom { x  } { k - 1  } \\
\sum \binom { x  } { k - 1  } \delta x & = \binom { x  } { k  } + C 
\end{aligned}</script><h6><span id="example平方和公式">Example(平方和公式)</span></h6><p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5><p>考虑一阶差分是$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $,那么二阶差分就是$\Delta ^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f ( x ) $.</p>
<p>类似地,我们可以通过归纳法证明$\Delta ^n f ( x ) = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } f ( x + k ) \ $.</p>
<p>事实上有一种更简单的证明方法,由于$\Delta = E - 1 $,于是$\Delta ^n = ( E - 1 ) ^n = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } E ^k \ $,由于$E ^k f ( x ) = f ( x + k ) $,即可证明原式.</p>
<p>另外,不难发现如果$f ( x ) $是一个关于$x $的$d $次多项式,那么$\Delta f ( x ) $是一个$d - 1 $次多项式.同理,$\Delta ^d f ( x ) $会是一个常数而$\Delta ^{ d + 1  } f ( x ) $会是$0 $,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6><p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为$x _1 , x _2 $.</p>
<p>不难写出期望转移式子:$f _i = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 $,并且$f _{ x _1  } = f _{ x _2  } = 0 $.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _i & = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 \\
2 f _i & = f _{ i - 1  } + f _{ i + 1  } + 2 \\
f _i - f _{ i - 1  } & = f _{ i + 1  } - f _i + 2 \\
\Delta f _{ i - 1  } & = \Delta f _{ i  } + 2 \\
\Delta f _i - \Delta f _{ i - 1  } & = - 2 \\
\Delta ^2 f _{ i - 1  } & = - 2 
\end{aligned}</script><p>$f $的二阶差分是常数,也就是说$f $是二次多项式,不难求得其二次项系数为$- 1 $又知道两个零点,显然可以得到$f $的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5><p>令$f ( x ) = \sum _{ 0 \leq i \leq d  } a _i x ^i \ $.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为$f ( x ) = \sum _{ 0 \leq i \leq d  } b _i x ^{ \underline { i  }  } \ $.</p>
<p>我们设$c _i = i ! b _i $,于是有:$f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i  } \ $.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为$f ( x ) $的牛顿级数.</p>
<p>于是不难发现有:$\Delta ^n f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i - n  } \ $.如果我们令$x = 0 $,则有:$\Delta ^n f ( 0 ) = \begin{cases}c _n &amp; n \leq d \ 0 &amp; n &gt; d \end{cases} $.那么牛顿级数的另一种表示即:$f ( x ) = \sum _{ 0 \leq i \leq d  } \Delta ^i f ( 0 ) \binom { x  } { d  } \ $.</p>
<p>另外,如果我们展开一下$c _n = \Delta ^n f ( 0 ) $,我们可以得到公式:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } c _i \binom { k  } { i  } ) = ( - 1 ) ^n c _n , n \in \mathbb { N  } \ $.</p>
<p>如果我们将多项式还原,由于$a _n = b _n $,有:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } a _i k ^i ) = ( - 1 ) ^n n ! a _n , n \in \mathbb { N  } \ $.</p>
<p>另外,如果$x \in \mathbb { N  } $,那么我们有:$f ( x ) = \sum _{ 0 \leq k  } \Delta ^k f ( 0 ) \binom { x  } { 0  } $,根据多项式推理法,这个公式对$\forall x \in \mathbb { Z  } $都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<script type="math/tex; mode=display">
g ( a + x ) = \sum _{ 0 \leq k  } \cfrac { \Delta ^k g ( a )  } { k !  } x ^{ \underline { k  }  }</script><h6><span id="example">Example</span></h6><p>求$\sum _{ k  } \binom { n  } { k  } \binom { r - sk  } { n  } ( - 1 ) ^k , n \in \mathbb { N  } \ $.</p>
<p>如果我们令$f ( k ) = \binom { r - sk  } { n  } = \sum _{ 0 \leq i \leq n  } a _i k ^i \ $,不难发现$a _n = \cfrac { ( - 1 ) ^n s ^n  } { n !  } $,于是显然原式$= s ^n $.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \\
\sum _{ i = l  } ^{ r - 1  } ( \Delta a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( \Delta b _i ) 
\end{aligned}</script><p>对于$l = 0 , r = n , a _0 = b _0 = 0 $的特殊情况,应当有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } a _{ i + 1  } ( \Delta b _i ) \\
\sum _{ i = 1  } ^n a _i ( b _{ i + 1  } - b _i ) & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i 
\end{aligned}</script><p>取两组数列$\alpha , \beta $,并令$\sum _{ i = 1  } ^n \beta _i = B _i $,立刻有:</p>
<script type="math/tex; mode=display">
\sum _{ i = 1  } ^n \alpha _i \beta _i = \alpha _n B _n - \sum _{ i = 1  } ^{ n - 1  } ( \alpha _{ i + 1  } - \alpha _i ) B _i</script><h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<p>$\sum _{ k = 0  } ^n k 2 ^k = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 = ( n - 1 ) 2 ^{ n + 1  } + 2 \ $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<h6><span id="solution-3">Solution 3</span></h6><p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } & = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<h6><span id="solution-4">Solution 4</span></h6><p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script>]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2><p>参考:<a href="https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong">https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong</a>.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3><h4><span id="eps">eps</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$\vec { a  } \cdot \vec { b  } = | \vec { a  } | | \vec { b  } | \cos \theta = x _a x _b + y _a y _b $.也就等于$\vec { a  } $在$b $上的投影与$\vec { b  } $的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol>
<li><p>如果$\vec { a  } \cdot \vec { b  } = 0 $,则说明$\vec { a  } \bot \vec { b  } $.</p>
</li>
<li><p>如果$\vec { a  } \cdot \vec { b  } &gt; 0 $,则说明$\vec { a  } $和$\vec { b  } $正方向的夹角小于$90 \degree $.</p>
</li>
<li><p>如果$\vec { a  } \cdot \vec { b  } &lt; 0 $,则说明$\vec { a  } $和$\vec { b  } $正方向的夹角大于$90 \degree $.</p>
</li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$\vec { a  } \times \vec { b  } = x _a y _b - y _a x _b $.也就等于$\vec { a  } , \vec { b  } $两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol>
<li><p>如果$\vec { a  } \times \vec { b  } = 0 $,说明二者共线.</p>
</li>
<li><p>如果$\vec { a  } \times \vec { b  } &lt; 0 $,说明从$\vec { a  } $到$\vec { b  } $的方向是顺时针.</p>
</li>
<li><p>如果$\vec { a  } \times \vec { b  } &gt; 0 $,说明从$\vec { a  } $到$\vec { b  } $的方向是逆时针.</p>
</li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵$\begin{bmatrix}\cos \theta &amp; - \sin \theta \ \sin \theta &amp; \cos \theta \end{bmatrix} $.</p>
<h4><span id="line">Line</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下$x _{ L _1  } , x _{ L _2  } , y _{ L _1  } , y _{ L _2  } $围成的四边形,计算面积后用等高不等底计算.注意$ls $和$rs $所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4><p>利用叉乘,任取平面上一点$O $,则$S = \frac { 1  } { 2  } \sum _{ i = 1  } ^n \overrightarrow { OP _i  } \times \overrightarrow { OP _{ i + 1  }  } $.证明的话考虑分$O $在内部和$O $在外部两种情况分类讨论.注意此时的$P $必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为$a $,它的边上(包括顶点)的整点数为$b $,则它的面积$S = a + \frac { b  } { 2  } - 1 $.</p>
<h3><span id="基本算法">基本算法</span></h3><h4><span id="排序算法">排序算法</span></h4><h5><span id="极角排序">极角排序</span></h5><p>定义原点$O $并建立坐标系,所有点按照和$O $所连直线与$x $轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$x $相同比$y $,否则比$x $.</p>
<h4><span id="二维凸包">二维凸包</span></h4><h5><span id="定义">定义</span></h5><p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5><p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否$ABC $三点是一个上凸的(注意$ABC $三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4><h5><span id="定义">定义</span></h5><p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5><p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4><p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5><p>两个区域$A , B $的闵可夫斯基和定义为$\{ a + b \mid a \in A , b \in B \} $.</p>
<h5><span id="实现">实现</span></h5><p>事实上,新的区域所形成的凸包,一定是原本$A , B $的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下$A , B $,使得$B $有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是$B $这个边加上$A $的最右边的点.这样这条边必定还在最终的凸包上.就算$A $最右边的是一条边,你也会发现最终的凸包最右边也一定是由$A $的这条边和$B $的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4><h5><span id="定义">定义</span></h5><p>定义半平面为满足$ax + by + c &gt; 0 $或$ax + by + c \geq 0 $的点对$( x , y ) $组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5><p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2><p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3><h4><span id="直线">直线</span></h4><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h4><span id="平面">平面</span></h4><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h4><span id="夹角">夹角</span></h4><h5><span id="两直线夹角">两直线夹角.</span></h5><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h4><span id="交点">交点</span></h4><p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3><p>参考:<a href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>范畴论初步</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2><h3><span id="映射">映射</span></h3><p>设$A , B $为两个集合,$\varphi $称为从$A $到$B $的一个<strong>映射</strong>,如果对于任意$a \in A $,$\exists b \in B , b = \varphi ( a ) $.此时$b $称为$a $在$\varphi $下的像,$a $称为$b $在$\varphi $下的原像或反像.一般地,这个定义可以拓展到$S \subseteq A $,$\varphi ( S ) = \{ \varphi ( a ) \mid a \in S \} $,定义$\varphi ^{ - 1  } ( T ) = \{ a | \varphi ( a ) \in T , a \in S \} $.</p>
<p>如果$\forall a _1 , a _2 \in A , a _1 \ne a _2 , \varphi ( a _1 ) \ne \varphi ( a _2 ) $,称$\varphi $是<strong>单射</strong>.</p>
<p>如果$\forall b \in B , \exists a \in A , \varphi ( a ) = b $.称$\varphi $为<strong>满射</strong>.</p>
<p>如果$\varphi $既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果$A = B $,我们又称$\varphi $为一个<strong>变换</strong>.</p>
<p>设$f : A \rightarrow B , g : B \rightarrow A $,那么:</p>
<ol>
<li><p>如果$g \circ f = id _A $,称$g $是$f $的一个<strong>左逆</strong>,不难发现$f $存在左逆当且仅当$f $是单射.</p>
</li>
<li><p>如果$f \circ g = id _B $,称$g $是$f $的一个<strong>右逆</strong>,不难发现$f $存在右逆当且仅当$f $是满射.</p>
</li>
<li><p>如果$g $既是$f $的左逆又是$f $的右逆,则称$g $为$f $的<strong>逆</strong>,不难发现$f $存在逆当且仅当$f $是双射,并且逆唯一.</p>
</li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3><p>集合$A , B $的<strong>笛卡尔积</strong>或<strong>直积</strong>是指$A $的元素与$B $的元素构成的有序对的集合,即$A \times B = \{ ( a , b ) \mid a \in A , b \in B \} $.可以推广到多元对.</p>
<p>集合$A $上的一个<strong>二元运算</strong>是由$A \times A $到$A $的一个映射.对于定义在$U $上的一个二元运算,不妨用$+ $来表示,集合$A , B \subseteq U $的<strong>闵可夫斯基和</strong>定义为$A + B = \{ a + b \mid a \in A , b \in B \} $.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合$A $上的一个<strong>二元关系</strong>$R $定义为$A \times A $的一个子集(可以理解为满足二元关系的解集),如果$( a _1 , a _2 ) \in R $,就称$a _1 , a _2 $有关系$R $,记作$a _1 Ra _2 $,注意这里有序.</p>
<p>如果$R $满足以下三个性质:</p>
<ol>
<li><p>反身性:$\forall a \in A , aRa $.</p>
</li>
<li><p>对称性:$a _1 Ra _2 \Leftrightarrow a _2 Ra _1 $.</p>
</li>
<li><p>传递性:$a _1 Ra _2 , a _2 Ra _3 \Leftrightarrow a _1 Ra _3 $.</p>
</li>
</ol>
<p>则称$R $是一个<strong>等价关系</strong>,不难发现满足等价关系的元素构成了若干个集合,称作<strong>等价类</strong>.等价关系通常记作$\sim $.</p>
<p>如果将等价关系的(2)改作:</p>
<ol>
<li>反对称性:$a _1 Ra _2 , a _2 Ra _1 \Leftrightarrow a _1 = a _2 $.</li>
</ol>
<p>则称$R $是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$\leq $.</p>
<h4><span id="保序映射">保序映射</span></h4><p>对于映射$f : A \rightarrow B $,如果$\forall a , a ‘ \in A , a \leq a ‘ \Rightarrow f ( a ) \leq f ( a ‘ ) $,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4><p>对于偏序集$( A , R ) $来说,定义:</p>
<ol>
<li><p>链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 1 $.</p>
</li>
<li><p>反链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 0 $.</p>
</li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p>
</li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,$| A | \leq 3 $显然成立.</p>
<p>当$| A | &gt; 3 $时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为$d $,下面证明其最小链覆盖也是$d $.</p>
<p>考虑取一条尽可能长的链$A ‘ $,设其中最大的为$M $,最小的为$m $(如果有多个就任取一个).</p>
<p>考虑$T = A \setminus A ‘ $,如果$T $中的最长反链数小于$d $,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链$S $,使得$S \cap A ‘ = \emptyset $.考虑设$A ^{ +  } = \{ x | x \in A \land \exists s \in S , sRx \} $,$A ^{ -  } = \{ x | x \in A \land \exists s \in S , xRs \} $.不难发现$m $一定不在$| A ^{ +  } | $中,不然取出的那条链$A ‘ $可以更长.同理$M $一定不在$| A ^{ -  } | $中,也即$| A ^+ | , | A ^- | &lt; | A | $.</p>
<p>我们又发现$A ^+ \cup A ^- = A $,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,$S \subseteq A ^{ +  } \cap A ^{ -  } $.</p>
<p>由数学归纳,$A ^+ $和$A ^- $中的最小链覆盖均为$d $,并且一个以$S $中元素开头,一个以$S $中元素结尾,我们把它俩拼起来就是一个大小为$d $的新的大小为$d $的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4><p>考虑定义一种等价关系$\sim $,我们可以在此基础上定义商集$A / \sim = \{ [ a ] | a \in A \} $,其中$[ a ] $是$a $所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过$\mathbb { N  } $来定义$\mathbb { Z  } $.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系$\sim $,$( n , m ) \sim ( n ‘ , m ‘ ) $当且仅当$n + m ‘ = m + n ‘ $.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将$\mathbb { N  } / \sim $定义为整数,更确切地,对于任意一组$( n , m ) $其代表的就是$n - m $这个整数.</p>
<p>容易定义加法:$( n , m ) + ( n ‘ , m ‘ ) = ( n + n ‘ , m + m ‘ ) $,乘法$( n , m ) \times ( n ‘ , m ‘ ) = ( mm ‘ + nn ‘ , mn ‘ + m ‘ n ) $.也可以定义大小关系$( n , m ) \leq ( n ‘ , m ‘ ) \Leftrightarrow n + m ‘ \leq m + n ‘ $.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义$- ( n , m ) = ( m , n ) $即可,容易验证二者之和处于$( 0 , 0 ) $这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用$\mathbb { Z  } $构造$\mathbb { Q  } $,构造二元组$\mathbb { Z  } \times \mathbb { N  } _+ $,定义$( r , s ) \sim ( r ‘ , s ‘ ) \Leftrightarrow rs ‘ = r ‘ s $,容易验证其满足等价关系的性质.实际上其对应的就是$\frac { r  } { s  } $这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3><h4><span id="外延公理">外延公理</span></h4><p>$A = B \Leftrightarrow ( A \subset B ) \land ( B \subset A ) $.</p>
<h4><span id="配对公理">配对公理</span></h4><p>对于任意元素$a , b $,存在集合$\{ a , b \} $.特别地,当$a = b $的时候存在集合$\{ a \} $.</p>
<p>值得一提的是可以将数对$( a , b ) $定义为$\{ \{ a \} , \{ a , b \} \} $,下面的幂集公理说明了数对属于$2 ^{ 2 ^{ A \cup B  }  } , a \in A , b \in B $.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4><p>对于一个集合$A $,和一个性质$P $,若$\alpha $满足性质$P $则称$P ( \alpha ) $.那么存在集合:</p>
<script type="math/tex; mode=display">
\{ x | x \in A \land P ( x ) \}</script><p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质$P $都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4><p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4><p>一个集合的所有子集构成一个新的集合(可以记作$2 ^A $).</p>
<h4><span id="无穷公理">无穷公理</span></h4><p>称满足以下性质的集合为归纳集:</p>
<ol>
<li><p>$\emptyset \in A $.</p>
</li>
<li><p>若$\alpha \in A $,则$\{ \alpha \} \cup \alpha \in A $.</p>
</li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4><p>对于集合$A $和一种定义在集合$A $上的映射$F $,存在集合$A ‘ $使得$x \in A ‘ \Leftrightarrow x = F ( a ) , a \in A $.</p>
<p>用替换公理可以证明映射也是一种集合,并且从$A \rightarrow B $的所有映射可以构成集合,可以记作$B ^A $.</p>
<h4><span id="正则公理">正则公理</span></h4><p>对任何非空集合$A $,存在$a \in A $使得$\forall a ‘ \in A $,$a ‘ \notin a $,也就是$a \cap A = \emptyset $.</p>
<h4><span id="选择公理">选择公理</span></h4><p>说对于任何一族非空集$A $,总能从其中的每个集合$a $选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5><p>如果$X $上的一个偏序关系$\leq $,满足其每条链$A $都存在上界($\exists x \in X , \forall a \in A , x \geq a $),那么$X $存在极大元$( \exists x \in X , \forall a \in X , a \geq x \Rightarrow a = x ) $.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系$( A ‘ ‘ , g ‘ ‘ ) \leq ( A ‘ , g ‘ ) $当且仅当$A ‘ ‘ \subseteq A ‘ $并且$\forall x \in A ‘ ‘ , g ‘ ‘ ( x ) = g ‘ ( x ) $.这样拿出来的极大元就是我们需要的$A \rightarrow g ( A ) $.</p>
<h5><span id="良序定理">良序定理</span></h5><p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对$( S , R ) $组成的集合,其中满足$S $对于偏序关系$R $来说是良序的,我们定义两个二元对$a , b $满足$a \leq b $当且仅当它们的$R $相等并且$S _a \subseteq S _b $.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)$( S , R ) $,注意到如果$S $是全集则证毕,如果不是,则取一个全集中不在$S $的元素$x $接到$S $的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3><p>如果存在单射$\varphi : A \rightarrow B $,则称$| A | \leq | B | $.如果存在双射,则称$| A | = | B | $.</p>
<p>如果使用选择公理的话,可以说明如果存在满射$\varphi : A \rightarrow B $,则称$| A | \geq | B | $.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有$A , B $两个集合,接下来我们证明一定存在一个从$A $到$B $的映射,且其要么为单射要么为满射.</p>
<p>我们记$X $为所有$A $的子集到$B $的单射组成的集合,并且我们定义这样一种偏序关系:若$f : A _f \rightarrow B , g : A _g \rightarrow B , A _f \subseteq A _g , \forall a \in A _f , f ( a ) = g ( a ) $.</p>
<p>这样的话,我们不妨取出$X $的一个全序的子集$I $,显然其存在上界.</p>
<p>根据Zorn引理,$X $存在极大元$g : A _g \rightarrow B $,此时我们开始讨论:</p>
<p>如果$A _g = A $,那么找到了一个单射$g : A \rightarrow B $.</p>
<p>反之,如果$A _g \subsetneq A $,考虑如果$g ( A _g ) = B $,也就是找到了一个满射;反之,考虑取$a ‘ \in A \setminus A _g , b ‘ \in B \setminus g ( A _g ) $,在$g $的基础上加上映射$a ‘ \mapsto b ‘ $,这是一个比$g $还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4><p>如果$| A | \leq | B | \land | B | \leq | A | $,则$| A | = | B | $.</p>
<p>不妨设$f : A \rightarrow B , g : B \rightarrow A $我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用$f , f ^{ - 1  } $来构造双射,只有一种除外:那就是以一个$B $中节点开始不断延伸的无限的,我们在这里使用$g , g ^{ - 1  } $来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取$C _0 = B \setminus f ( A ) $,$C _n = f ( g ( C _{ n - 1  } ) ) $,那么对于$C = \cup _{ n \geq 0  } C _n $,使用$g , g ^{ - 1  } $构造双射,剩下的使用$f , f ^{ - 1  } $构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4><p>我们称集合$A $是<strong>可数</strong>的,当且仅当$| A | = | \mathbb { N  } | $.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是$0 $)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为$1 $和$0 $显然都是代数数.</p>
<p>我们接下来看两个代数数$x , y $.考虑如何构造$x + y $作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
X & = \sum _{ k = 0  } ^n a _k x ^k & = 0 \\
Y & = \sum _{ k = 0  } ^m b _k y ^k & = 0 
\end{aligned}</script><p>对于加法,考虑:$( x + y ) ^0 , ( x + y ) ^1 , \cdots $,这些东西,先把它们对$X $取膜再对$Y $取膜,得到的一定是$nm $维的,只需要取$nm + 1 $个就会出现线性相关.乘法同理考虑$( xy ) ^0 , ( xy ) ^1 , \cdots $即可.</p>
<p>值得一提的是,$| \mathbb { R  } | = 2 ^{ | \mathbb { N  } |  } $.这个是怎么构造的呢?只需要证明$[ 0 , 1 ] $上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果$k $在取出的自然数子集中,那么小数点后第$k + 1 $位为$1 $否则为$0 $,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是$0 . 1 = 0 . 0111 \cdots $,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明$| \mathbb { R  } | \leq 2 ^{ | \mathbb { N  } |  } $并且$| \mathbb { R  } | \geq 2 ^{ | \mathbb { N  } |  } $,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2><h3><span id="范畴">范畴</span></h3><p>一个<strong>范畴</strong>$\mathcal { C  } $应当包含以下:</p>
<ol>
<li><p>一个类$\rm { Ob  } ( \mathcal { C  } ) $,其元素称作$\mathcal { C  } $的<strong>对象</strong>.</p>
</li>
<li><p>对于$X , Y \in \rm { Ob  } ( \mathcal { C  } ) $指定一个集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,称作$\mathcal { C  } $中从$X $到$Y $的<strong>态射</strong>.</p>
</li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol>
<li><p>对于$X \in \text { Ob  } ( \mathcal { C  } ) $存在其到自身的<strong>恒等态射</strong>$\text { id  } _X \in \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong>$\circ : \text { Hom  } _{ \mathcal { C  }  } ( Y , Z ) \times \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , ( g , f ) \mapsto g \circ f $.</p>
</li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol>
<li><p><strong>结合律</strong>:对于$\mathcal { C  } $中的态射$h , g , f $,如果合成有意义,那么$h ( gf ) = ( hg ) f $.</p>
</li>
<li><p><strong>单位元</strong>:对于$f \in \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,$f \circ \text { id  } _X = f = \text { id  } _Y \circ f $.</p>
</li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有$\text { id  } _X = \text { id  } _X \text { id ‘  } _X = \text { id ‘  } _X $.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<script type="math/tex; mode=display">
\xymatrix { R \ar [r ] ^u \ar [d ] _x & S \ar [d ] ^v \\
T \ar [r ] _y & U  }</script><p>这意味着$yx = vu $.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol>
<li><p>如果对于$f \in \text { Hom  } ( X , Y ) $,$\exists g \in \text { Hom  } ( Y , X ) $使得$gf = \text { id  } _X $,那么称$g $是$f $的一个<strong>左逆</strong>,称$f $是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p>
</li>
<li><p>如果$f $左右均可逆,易见左右逆相等,记作$f ^{ - 1  } $,易见$f ^{ - 1  } $可逆而且$( f ^{ - 1  } ) ^{ - 1  } = f $.此时称$f $是<strong>同构</strong>的.</p>
</li>
</ol>
<p>同构还有以下性质:</p>
<ol>
<li><p>$( \text { id  } _X ) ^{ - 1  } = \text { id  } _X $.</p>
</li>
<li><p>如果$f $和$g $均为同构并且合成有意义,那么$gf $是同构并且$( gf ) ^{ - 1  } = f ^{ - 1  } g ^{ - 1  } $.</p>
</li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol>
<li><p>自同态幺半群:$\text { End  } _{ \mathcal { C  }  } ( X ) = \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>自同构群:$\text { Aut  } _{ \mathcal { C  }  } ( X ) = ( \text { End  } _{ \mathcal { C  }  } ( X ) ) ^\times $.</p>
</li>
</ol>
<p>如此起名的原因是由抽象代数知识见到$\text { End  } $对二元运算$\circ $构成幺半群,$\text { Aut  } $则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称$\mathcal { C  } ‘ $是$\mathcal { C  } $的子范畴当且仅当:</p>
<ol>
<li><p>$\text { Ob  } ( \mathcal { C  } ‘ ) \subseteq \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $都有$\text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \subseteq \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$\text { id  } _X = \text { id  } _X ‘ $.</p>
</li>
<li><p>态射在$\mathcal { C  } ‘ $中的合成运算应从$\mathcal { C  } $中继承而来.</p>
</li>
</ol>
<p>特别地,如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) , \text { Hom  } ( X , Y ) _{ \mathcal { C  } ‘  } = \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,则称$\mathcal { C  } ‘ $是$\mathcal { C  } $的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3><p>如果$\mathcal { C  } $是一个范畴,其中有一个元素$X \in \mathrm { Ob  } ( \mathcal { C  } ) $,如果$\forall Y \in \mathrm { Ob  } ( { \mathcal { C  }  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称它是始(initial)的.类似地,如果对于$Y \in \mathrm { Ob  } ( \mathcal { C  } ) $,$\forall X \in \mathrm { Ob  } ( \mathcal { C  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称$Y $是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol>
<li><p>如果$X , X ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是initial的,则存在一个唯一的同构$a : X \cong X ‘ $.</p>
</li>
<li><p>如果$Y , Y ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是terminal的,则存在一个唯一的同构$b : Y \cong Y ‘ $.</p>
</li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3><p>我们定义从$\mathcal { C  } ‘ $到$\mathcal { C  } $的<strong>函子</strong>$F $需要有以下性质:</p>
<ol>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,指定一个$\mathcal { C  } $中的对象$FX $.或记作$F : \text { Ob  } ( \mathcal { C  } ‘ ) \to \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,对于态射$f : X \to Y $指定一个$\mathcal { C  } $中的对象$Ff $.或记作$F : \text { Hom  } _\mathcal { C  } ‘ ( X , Y ) \to \text { Hom  } _\mathcal { C  } ( FX , FY ) $.</p>
</li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol>
<li><p>$\forall g , f \in \text { Hom  } _{ \mathcal { C  } ‘  } $,它们的合成有意义,则$F ( gf ) = F ( g ) F ( f ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F ( \text { id  } _X ) = \text { id  } _{ FX  } $.</p>
</li>
</ol>
<p>我们一般也将上述函子记作$F : \mathcal { C  } ‘ \to \mathcal { C  } $.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然$F $可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol>
<li><p>如果$\forall T \in \text { Ob  } ( \mathcal { C  } ) , \exists X \in \text { Ob  } ( \mathcal { C  } ‘ ) $使得$T \cong FX $,则称$F $是<strong>本质满</strong>的.</p>
</li>
<li><p>如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F : \text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( FX , FY ) $均为单射,则称$F $是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p>
</li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓$\text { Hom  } $函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴$\mathcal { C  } $以及其对象$X $,我们定义函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) : \mathcal { C  } \to Set $,它映对象$Y $为集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,映态射$f : Y \to Z $为映射$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) f : \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , h \mapsto f \circ h $.</p>
<p>同理可以定义函子$\text { Hom  } _{ \mathcal { C  }  } ( \cdot , X ) $.</p>
<p>对于函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) $,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3><h4><span id="kleisli范畴">Kleisli范畴</span></h4><p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol>
<li><p>加上修饰.</p>
</li>
<li><p>合并修饰.</p>
</li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>简单乐理</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="前言">前言</span></h3><p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3><h4><span id="拍音理论">拍音理论</span></h4><p>假设两个正弦单音的频率分别是$\omega , \omega + \delta $,那么它们叠加后是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
& = 2 \sin \left ( 2 \pi ( \omega + \frac { \delta  } { 2  } ) t \right ) \cos ( \pi \delta t ) 
\end{aligned}</script><p>注意到这个声音受到$\cos ( \pi \delta t ) $的控制.因此会以$\frac { \delta  } { 2  } $的频率振动,由于$\delta $应该远小于$\omega $,这里就会产生$\delta = | \omega _1 - \omega _2 | $个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4><p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol>
<li><p>弦长$L $.</p>
</li>
<li><p>张力$T $.</p>
</li>
<li><p>线密度$\rho $.</p>
</li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点$u ( x , t ) $,首先是一维振动方程:</p>
<script type="math/tex; mode=display">
\frac { \partial ^2 u  } { \partial x ^2  } = \frac { \rho  } { T  } \frac { \partial ^2 u  } { \partial t ^2  }</script><p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<script type="math/tex; mode=display">
u _n ( x , t ) = c _n \sin ( \omega _n t + \theta _n ) \sin ( \frac { n \pi  } { L  } x )</script><p>其中第$n $项的频率满足:</p>
<script type="math/tex; mode=display">
f _n = \frac { n  } { 2 L  } \sqrt { \frac { T  } { \rho  }  }</script><p>其中我们将$f _1 $称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中$f _n , n \geq 2 $对应的是第$n - 1 $泛音.</p>
<p>特别地,如果我们干脆记$f = f _1 $,上述结果告诉我们弦的振动产生的一列频率是:</p>
<script type="math/tex; mode=display">
f , 2 f , 3 f , \cdots</script><p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的$n $,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0" alt></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的$f _{ 2 k + 1  } $,泛音列中只剩下$2 f , 4 f , \cdots $.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按$\frac { 1  } { 3  } $处呢?那泛音列中就会只剩下$3 f , 6 f , 9 f , \cdots $,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是$f , 3 f , 5 f , \cdots $.</p>
<h4><span id="管乐器">管乐器</span></h4><p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<script type="math/tex; mode=display">
f , 2 f , 3 f , 4 f , \cdots</script><p>闭管的泛音列:</p>
<script type="math/tex; mode=display">
f , 3 f , 5 f , 7 f</script><p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4><p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots 
\end{gathered}</script><p>或是:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac { 3  } { 2  } f , 3 f , \frac { 9  } { 2  } f , 6 f , \cdots 
\end{gathered}</script><p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3><p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是$L _p = 20 \log _{ 10  } ( \frac { p  } { p _0  } ) $,其中$p _0 = 20 \mu Pa $.</p>
<h4><span id="音程">音程</span></h4><p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<p>| 度数 | 半音数 | 名称   |</p>
<p>| —— | ——— | ——— |</p>
<p>| 一   | 0      | 纯一度 |</p>
<p>| 二   | 1      | 小二度 |</p>
<p>| 二   | 2      | 大二度 |</p>
<p>| 三   | 3      | 小三度 |</p>
<p>| 三   | 4      | 大三度 |</p>
<p>| 四   | 5      | 纯四度 |</p>
<p>| 四   | 6      | 增四度 |</p>
<p>| 五   | 6      | 减五度 |</p>
<p>| 五   | 7      | 纯五度 |</p>
<p>| 六   | 8      | 小六度 |</p>
<p>| 六   | 9      | 大六度 |</p>
<p>| 七   | 10     | 小七度 |</p>
<p>| 七   | 11     | 大七度 |</p>
<p>| 八   | 12     | 纯八度 |</p>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<p>| 音程   | 频率比 |</p>
<p>| ——— | ——— |</p>
<p>| 纯八度 | $2 : 1 $  |</p>
<p>| 纯五度 | $3 : 2 $  |</p>
<p>| 纯四度 | $4 : 3 $  |</p>
<p>| 大三度 | $5 : 4 $  |</p>
<p>| 小三度 | $6 : 5 $  |</p>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4><p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定$C $的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为$1 $,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求$\{ 7 k \} \pmod { 12  } $这个数列对吧,简单数论知识告诉我们它必然能遍历$12 $种情况,具体而言:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C \to & & G \to & & D \to & & A \to & & E \to & & B \to \\
1 \to & & \frac { 3  } { 2  } \to & & \frac { 3 ^2  } { 2 ^3  } \to & & \frac { 3 ^3  } { 2 ^4  } \to & & \frac { 3 ^4  } { 2 ^6  } \to & & \frac { 3 ^5  } { 2 ^7  } \to \\
\\
\\
\# F \to & & \# C \to & & \# G \to & & \# D \to & & \# A \to & & \# E \\
\frac { 3 ^6  } { 2 ^9  } \to & & \frac { 3 ^7  } { 2 ^{ 11  }  } \to & & \frac { 3 ^8  } { 2 ^{ 12  }  } \to & & \frac { 3 ^9  } { 2 ^{ 14  }  } \to & & \frac { 3 ^{ 10  }  } { 2 ^{ 15  }  } \to & & \frac { 3 ^{ 11  }  } { 2 ^{ 17  }  } \\

\end{aligned}</script><p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度$CE $的比是$\frac { 81  } { 64  } &gt; \frac { 80  } { 64  } = \frac { 5  } { 4  } $.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的$# E \ne F $,你对着这个$# E $往上再升一个音得到的理应是$C ‘ = \frac { 3 ^{ 12  }  } { 2 ^{ 18  }  } &gt; 2 $,具体来说$\frac { 3 ^{ 12  }  } { 2 ^{ 19  }  } \approx 1 . 013643 $,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于$1 $的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升$12 $个纯五度,再下降$7 $个纯八度理应回到原点,可是:</p>
<script type="math/tex; mode=display">
( \frac { 3  } { 2  } ) ^{ 12  } \times ( \frac { 1  } { 2  } ) ^7 > 1</script><p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4><p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定$C $的频率为$1 $.接下来用正三和弦(一个大三度和一个小三度)$I : C - E - G $,$IV : F - A - C ‘ $,$V : G - B - D ‘ $的比例是$4 : 5 : 6 $确定剩下的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C & & D & & E & & F & & G & & A & & B & & C ' & & D ' \\
1 & & \frac { 9  } { 8  } & & \frac { 5  } { 4  } & & \frac { 4  } { 3  } & & \frac { 3  } { 2  } & & \frac { 5  } { 3  } & & \frac { 15  } { 8  } & & 2 & & \frac { 9  } { 4  } 
\end{aligned}</script><p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol>
<li><p>五度音程$D - A $不协和,比例为$\frac { 80  } { 54  } &lt; \frac { 81  } { 54  } = \frac { 3  } { 2  } $.这直接导致了转调会出错.</p>
</li>
<li><p>有两种不同的大二度:音程$C - D , F - G , A - B $的比例是$\frac { 9  } { 8  } $而音程$D - E , G - A $的比例为$\frac { 10  } { 9  } $.</p>
</li>
<li><p><strong>谐调音差</strong>:从$C $出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:$( \frac { 3  } { 2  } ) ^4 \times ( \frac { 1  } { 2  } ) ^2 \times \frac { 4  } { 5  } = \frac { 81  } { 80  } = 1 . 0125 &gt; 1 $.</p>
</li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4><p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用$\sqrt [12 ] { 2  } $来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是$f _1 , f _2 $,则它们的音分数定义为$1200 \log _2 ( \frac { f _2  } { f _1  } ) $,容易见到十二平均律拿到的一个半音恰好是$100 $音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3><h4><span id="大小调">大小调</span></h4><h5><span id="自然大调">自然大调</span></h5><p>就是我们最常用的$CDEFGABC ‘ $,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol>
<li><p>主音</p>
</li>
<li><p>上主音</p>
</li>
<li><p>中音</p>
</li>
<li><p>下属音</p>
</li>
<li><p>属音</p>
</li>
<li><p>下中音</p>
</li>
<li><p>导音</p>
</li>
</ol>
<p>用五度相生,下属音$\rightarrow $主音$\rightarrow $属音.</p>
<h5><span id="自然小调">自然小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以$ABCDEFG $用的调子,然而这里的问题是$G $作为导音却和$A ‘ $差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用$A , B , C , D , E , F , ( ^# G ) $.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用$A , B , C , D , E , ( ^# F ) , ( ^# G ) $.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4><p>以五度相生:</p>
<script type="math/tex; mode=display">
C \to G \to D \to A \to E \to B \to ( ^\# F ) \to ( ^\# C )</script><p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从$C $开始每次往后跳一次都要在一个音阶上增一个升号.从$C $大调提升到$G $大调的时候就是将$C $的下属音(也就是$F $)升音.</p>
<p>对称地,反方向的五度相生:</p>
<script type="math/tex; mode=display">
C \to F \to ( ^b B ) \to ( ^b E ) \to ( ^b A ) \to ( ^b D ) \to ( ^b G ) \to ( ^b C )</script><p>那这个应该降什么呢?比如从$C $大调提升到$F $大调的时候就是将$F $的下属音$B $降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png" alt></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3><h4><span id="三和弦">三和弦</span></h4><p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol>
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成$4 : 5 : 6 $的频率关系.</p>
</li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p>
</li>
<li><p>减三和弦:两个小三度.</p>
</li>
<li><p>增三和弦:两个大三度.</p>
</li>
</ol>
<h4><span id="七和弦">七和弦</span></h4><p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol>
<li><p>减减七和弦(减七和弦):小小小.</p>
</li>
<li><p>减小七和弦(半减七和弦):小小大.</p>
</li>
<li><p>小小七和弦(小七和弦):小大小.</p>
</li>
<li><p>小大七和弦:小大大.</p>
</li>
<li><p>大小七和弦(属七和弦):大小小.</p>
</li>
<li><p>大大七和弦(大七和弦):大小大.</p>
</li>
<li><p>增大七和弦:大大小.</p>
</li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4><p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol>
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p>
</li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p>
</li>
</ol>
<p>对于七和弦来说:</p>
<ol>
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p>
</li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p>
</li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p>
</li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4><p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为$C - E - G $,$F - A - C ‘ $,$G - B - D ‘ $.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol>
<li><p>正格进行:$I \to V \to I $.</p>
</li>
<li><p>变格进行:$I \to IV \to I $.</p>
</li>
<li><p>复式进行:$I \to IV \to V \to I $.</p>
</li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<script type="math/tex; mode=display">
\xymatrix { & & & & I \\
& & IV \ar [r ] \ar [d ] \ar [dr ] \ar [rru ] & vii \degree \ar [ru ] & \\
iii \ar [r ] & vi \ar [r ] \ar [ru ] & ii \ar [r ] \ar [ru ] & V \ar [ruu ] &  }</script><p>其中$I $较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4><p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol>
<li><p>平行变换$P $:保持纯五度音阶不变,将三音切换.</p>
</li>
<li><p>关系变换$R $:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p>
</li>
<li><p>导音变换$L $:保持小三度音阶不变,补上剩下的一个.</p>
</li>
</ol>
<p>容易见到$R \circ ( L \circ R ) ^3 = P $.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计实习</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2><h3><span id="基本分析">基本分析</span></h3><h4><span id="union-bound">Union Bound</span></h4><p>即:$Pr [ \bigcup _i X _i ] \leq \sum Pr [ X _i ] $,取等当且仅当所有$X _i $互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4><p>若$X \geq 0 $,则$Pr [ X \geq t \mathbb { E  } [ X ] ] \leq \frac { 1  } { t  } $.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6><p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有$\frac { 1  } { 2  } $的概率是割边,因此期望自然是$\frac { 1  } { 2  } | E | \geq \frac { 1  } { 2  } | \text { max - cut  } | $.</p>
<p>由此立即见到,$Pr [ | ans | \leq ( \frac { 1  } { 2  } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac { 1  } { 2  } + \epsilon ) | E | ] \leq \frac { 1  } { 1 + 2 \epsilon  } $.</p>
<p>由于每次独立操作,因此如果有$P $的概率失败,那么运行$T $次后至少成功一次的概率应当为$1 - P ^T $.从而$T = O ( \log _P { \delta  } ) = O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \ln ( 1 + { 2 \epsilon  } )  } ) \approx O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \epsilon  } ) $即可拿到$\delta $失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4><p>设$X _1 , \cdots , X _n \in [ 0 , 1 ] $是独立,同期望(期望为$\mu \geq t $)的随机变量,令$X = \frac { \sum _k X _k  } { n  } $,对于任何失败概率$\delta \in ( 0 , 1 ) $,应当有:</p>
<script type="math/tex; mode=display">
Pr \left [ | X - \mu | \geq \sqrt { \cfrac { \log ( 1 / \delta )  } { nt  }  } \mu \right ] \leq \delta</script><h6><span id="examplemedian-trick">Example(Median Trick)</span></h6><p>现在有一个黑盒能够以$p &gt; \frac { 1  } { 2  } $的概率正确回答Yes或者No,问重复$T $选多少次能拿到$1 - \delta $的成功概率.</p>
<p>考虑重复$T $次后应当有期望$pT $个正确答案,因此直接取中位数.称此算法为Median Trick.</p>
<p>Chernoff Bound 告诉我们$T = O ( \log \frac { 1  } { \delta  } ) $足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4><p>设独立随机变量$x _1 , \cdots , x _m \in [ s , t ] $,令$X = \sum _i x _i $,则:</p>
<script type="math/tex; mode=display">
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac { 2 z ^2  } { m ( t - s ) ^2  } \right )</script><h3><span id="编程中的随机性">编程中的随机性</span></h3><p>一般采用伪随机,也即是给定初值$X _0 $,通过某个确定性的函数来生成$X _{ n + 1  } = f ( X _n ) $这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2><h3><span id="基本定义">基本定义</span></h3><p>概率空间$\Omega $:在一个给定问题中可能发生的所有情况.</p>
<p>事件:$\Omega $的一个子集.</p>
<p>基本事件$\omega $:$\Omega $中的单个元素,也可以看作集合大小为$1 $的事件.</p>
<p>概率:若$\omega \in \Omega $,我们称它发生的概率为$\Pr ( \omega ) $,有$\Pr ( \omega ) \geq 0 $且$\sum _{ \omega \in \Omega  } \Pr ( \omega ) = 1 $.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量$X $和$Y $定义在同一个概率空间$\Omega $上,对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,我们称$\Pr ( X = x \land Y = y ) $为它们的联合分布.</p>
<p>独立:如果对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,$\Pr ( X = x \land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y ) $,我们称$X $和$Y $是独立的.</p>
<p>期望(均值)$E X $:我们设概率空间上的随机变量$X $的期望$EX = \sum _{ x \in X ( \Omega )  } x \times \Pr ( X = x ) = \sum _{ w \in \Omega  } X ( \omega ) \Pr ( \omega ) $.</p>
<p>中位数:我们设概率空间上的随机变量$X $的中位数为满足$\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x ) \geq 0 . 5 $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量$X $的众数为满足$\Pr ( X = x ) \geq \Pr ( X = x ‘ ) , \forall x ‘ \in X ( \Omega ) $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>方差$VX $:我们设概率空间上的随机变量$X $的方差$VX = E ( ( X - EX ) ^2 ) $.</p>
<p>标准差$\sigma $:我们设概率空间上的随机变量$X $的标准差$\sigma = \sqrt { VX  } $.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3><p>如果$X , Y $是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol>
<li><p>$E ( X + Y ) = EX + EY $.</p>
</li>
<li><p>$E ( \alpha X ) = \alpha EX $.</p>
</li>
<li><p>如果$X $和$Y $互相独立,那么$E ( XY ) = ( EX ) ( EY ) $.</p>
</li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3><p>我们考虑方差的定义式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X - EX ) ^2 ) & = E ( X ^2 - 2 X ( EX ) + ( EX ) ^2 ) \\
& = E ( X ^2 ) - 2 ( EX ) ( EX ) + ( EX ) ^2 \\
& = E ( X ^2 ) - ( EX ) ^2 
\end{aligned}</script><p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当$X $和$Y $为独立的随机变量时,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( ( X + Y ) ^2 ) - ( EX + EY ) ^2 \\
& = E ( ( X + Y ) ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 
\end{aligned}</script><p>而又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X + Y ) ^2 ) & = E ( X ^2 + 2 XY + Y ^2 ) \\
& = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) 
\end{aligned}</script><p>则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 \\
& = VX + VY 
\end{aligned}</script><p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<script type="math/tex; mode=display">
\Pr ( ( X - EX ) ^2 \geq \alpha ) \leq \cfrac { VX  } { \alpha  } , \alpha > 0</script><p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
VX & = \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) \\
& \geq \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& \geq \sum _{ \omega \in \Omega  } \alpha \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& = \alpha \Pr ( ( X - EX ) ^2 & \geq \alpha ) 
\end{aligned}</script><p>如果我们用$c ^2 VX $代替$\alpha $,我们就有:</p>
<p>$\Pr ( | X - EX | \geq c \sigma ) \leq \cfrac { 1  } { c ^2  } $.</p>
<p>简单来说,这个不等式说明:$X $落在$( EX - c \sigma , EX + c \sigma ) $之外的概率至多为$\cfrac { 1  } { c ^2  } $.</p>
<p>另外,如果我们取$n $个独立的样本$X _1 , X _2 , . . . , X _n $,令$S = \sum _{ i = 1  } ^n X _i $,那么它的均值是$nEX $,标准差是$\sqrt { n  } \sigma $,也就是说,$\cfrac { S  } { n  } $落在$( EX - \cfrac { c \sigma  } { \sqrt { n  }  } , EX + \cfrac { c \sigma  } { \sqrt { n  }  } ) $之外的概率小于等于$\cfrac { 1  } { c ^2  } $.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3><p>如果我们随机取得了$n $个值$X _1 , X _2 , . . . , X _n $,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p>$\hat EX = \cfrac { \sum _{ i = 1  } ^n X _i  } { n  } $.</p>
<p>$\hat VX = \cfrac { \sum _{ i = 1  } ^n X _i ^2  } { n - 1  } - \cfrac { ( \sum _{ i = 1  } ^n X _i ) ^2  } { n ( n - 1 )  } $.</p>
<p>这里的$\hat VX $似乎与定义不是那么相符.但是它拥有更好的性质:$E ( \hat VX ) = VX $.</p>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( \hat VX ) & = \cfrac { 1  } { n - 1  } E ( \sum _{ i = 1  } ^n X _i ^2 - \cfrac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n X _j X _k ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X _i ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n E ( X _i X _j ) ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( ( EX ) ^2 [ j \ne k ] + E ( X ^2 ) [ j & = k ] ) ) \\
& = \cfrac { 1  } { n - 1  } ( nE ( X ^2 ) - \cfrac { 1  } { n  } ( nE ( X ^2 ) + n ( n - 1 ) ( EX ) ^2 ) ) \\
& = E ( X ^2 ) - ( EX ) ^2 \\
& = VX 
\end{aligned}</script><h3><span id="条件概率">条件概率</span></h3><p>已知事件B发生时事件A发生的概率为$P ( A | B ) = \frac { P ( AB )  } { P ( B )  } \ $.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4><p>贝叶斯公式:如果有$\{ B _i \} $是样本空间的一个划分,即$\forall i , j $,有$B _i \cap B _j = \emptyset $,并且有$\bigcup _{ i = 1  } ^n B _i = \Omega $.则有$P ( B _i | A ) = \frac { P ( AB _i )  } { P ( A )  } = \frac { P ( AB _i )  } { P ( A ) \sum P ( B _j )  } = \frac { P ( A B _i )  } { \sum _{ j = 1  } ^n P ( A B _j )  } = \frac { P ( A | B _i ) P ( B _i )  } { \sum _{ j = 1  } ^n P ( A | B _j ) P ( B _j )  } \ $.</p>
<p>简化形式:$P ( B | A ) = \frac { P ( A | B ) P ( B )  } { P ( A )  } \ $.</p>
<p>另外,我们考虑设$O ( B ) = \cfrac { P ( B )  } { P ( \lnot B )  } $,称$\cfrac { P ( B | E )  } { P ( \lnot B | E )  } $为贝叶斯算子,则同理可得:</p>
<script type="math/tex; mode=display">
O ( B | E ) = O ( B ) \cfrac { P ( B | E )  } { P ( \lnot B | E )  }</script><p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3><p>如果$X $是定义在概率空间$\Omega $上的随机变量,那么它的概率生成函数为$G _X ( z ) = \sum _{ k \geq 0  } \Pr ( X = k ) z ^k = E ( z ^X ) $.</p>
<p>不难发现$G _X ( z ) $需要满足的条件:所有系数都非负并且$G _X ( 1 ) = 1 $.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = G _X ' ( 1 ) \\
E ( X ^2 ) & = G ' ' _X ( 1 ) + G _X ' ( 1 ) \\
VX & = G _X ' ' ( 1 ) + G _X ' ( 1 ) - ( G _X ' ( 1 ) ) ^2 
\end{aligned}</script><p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G ) & = G ' ( 1 ) \\
Var ( G ) & = G ' ' ( 1 ) + G ' ( 1 ) - ( G ' ( 1 ) ) ^2 
\end{aligned}</script><p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<script type="math/tex; mode=display">
G ( 1 + t ) = \sum _{ i \geq 0  } \cfrac { G ^{ ( i )  } ( 1 )  } { i !  } t ^i</script><p>另外,我们不难发现:$G _{ X + Y  } ( z ) = G _X ( z ) G _Y ( z ) $.</p>
<p>根据前面的推导,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _{ X + Y  } ) & = Mean ( G _X ) + Mean ( G _Y ) \\
Var ( G _{ X + Y  } ) & = Var ( G _X ) + Var ( G _Y ) 
\end{aligned}</script><p>换句话说,若$G _X ( 1 ) = 1 , G _Y ( 1 ) = 1 $,那么这个式子与直接对$G _{ X + Y  } $使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _X ) & = Mean ( G _{ X + Y  } ) - Mean ( G _Y ) \\
Var ( G _X ) & = Var ( G _{ X + Y  } ) - Var ( G _Y ) 
\end{aligned}</script><h4><span id="example1">Example1</span></h4><p>一枚硬币正面向上的概率为$p $,反面向上的概率为$q $,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设$N $为所有不包含THTTH的硬币序列的生成函数,$S $为所有只有结尾为THTTH的硬币序列的生成函数,令$H = pz , T = qz $,$1 $为空集,我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N \times ( H + T ) & = N + S \\
N \times THTTH & = S + S \times TTH 
\end{aligned}</script><p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设$A $是我们要找到的字符串,$m $是它的长度,令$A ^{ ( k )  } $表示$A $字符串的前$k $个字符所组成的字符串,$A _{ ( k )  } $表示$A $字符串的后$k $个字符所组成的字符串.这样的形式与$k $阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S \\
N \times A & = S ( \sum _{ k = 0  } ^{ m - 1  } A ^{ ( k )  } [ A ^{ ( m - k )  } & = A _{ ( m - k )  } ] ) 
\end{aligned}</script><p>如果我们设$\tilde { A  } $为将字符串$A $中的H替换成$\cfrac { 1  } { p  } z $,T替换成$\cfrac { 1  } { q  } z $之后的值,那么显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N \times A & = A \times S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
N & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
\cfrac { S - 1  } { H + T - 1  } & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) ) & = 1 
\end{aligned}</script><p>这显然是一个卷积的形式.</p>
<p>令$w = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.</p>
<p>令$H ( z ) = 1 $,$F ( z ) = ( 1 + ( 1 - z ) \times w ) $,$G ( z ) = S $.</p>
<p>那么我们显然可以直接求$G ( z ) $的期望和方差,事实上:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] \\
VX & = ( EX ) ^2 - \sum _{ k = 1  } ^m ( 2 k - 1 ) \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] 
\end{aligned}</script><p>如果硬币是均匀的($p = q = \cfrac { 1  } { 2  } $)我们引入另一个符号:我们设$A : A = \sum _{ k = 1  } ^m 2 ^{ k  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.那么显然期望需要的抛硬币次数就是$( A : A ) $.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4><p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设$S _A $为所有以HHT结尾的硬币序列的生成函数,设$S _B $为所有以HTT结尾的硬币序列的生成函数.$N $为其它的硬币序列的生成函数,令$H = T = 0 . 5 z $.</p>
<p>我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S _A + S _B \\
N \times HHT & = S _A \\
N \times HTT & = S _A \times T + S _B 
\end{aligned}</script><p>解方程并带入$z = 1 $,可以有得知以HHT结尾的概率为$\cfrac { 2  } { 3  } $.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为$A $和$B $,那么可以求出:</p>
<script type="math/tex; mode=display">
\cfrac { S _A  } { S _B  } = \cfrac { B : B - B : A  } { A : A - A : B  }</script><h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4><p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设$g _i $表示进行了$i $步还未结束的概率,$f _{ k , i  } $为进行了$i $步恰好第$k $个人胜利的概率,$F , G $是它们的生成函数,我们自然有:</p>
<ol>
<li><p>$1 + xG ( x ) = \sum _k F _k ( x ) + G ( x ) $.</p>
</li>
<li><p>$( \frac { 1  } { 2  } x ) ^L G ( x ) = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^i [ A _k ^{ ( L - i )  } = { A _j  } _{ ( L - i )  } ] $.</p>
</li>
</ol>
<p>第一个式子的用处在于带入$x = 1 $,发现$\sum _{ k  } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  } & = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{ L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } & = { A _j  } _{ ( i )  } ] 
\end{aligned}</script><p>带入$x = 1 $,有:</p>
<script type="math/tex; mode=display">
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [ A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]</script><p>不难发现对于不同的$k $,(2)的右边不同,而左边一定相同,这样就给出了$n $个等式,算上(1)一共有$n + 1 $个等式,可以算出$G ( 1 ) , F _{ 1 \cdots n  } ( 1 ) $这$n + 1 $个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3><p>现在有一个大小为$n + 1 $的概率空间,其中$\Pr ( \omega _k ) = \binom { n  } { k  } p ^k q ^{ n - k  } \ $,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令$H ( z ) = q + pz $,不难发现二项式分布的生成函数为$H ( z ) ^n $.</p>
<p>不难发现,满足二项式分布的随机变量的均值是$np $,方差是$npq $.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:$G ( z ) ^n = ( \cfrac { p  } { 1 - qz  } ) ^n = \sum _{ k  } \binom { n + k - 1  } { k  } p ^n q ^k z ^k $.</p>
<p>我们考虑如何求$G ( z ) $的方差和均值,不妨设$F ( z ) = \cfrac { 1 - qz  } { p  } = \cfrac { 1  } { p  } - \cfrac { q  } { p  } z $,则$G ( z ) ^n = F ( z ) ^{ - n  } $.</p>
<p>不难发现$F ( z ) $满足二项式分布.也就是说,以$( n , p , q ) $为参数的负二项式分布也就是以$( - n , - \cfrac { q  } { p  } , \cfrac { 1  } { p  } ) $为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3><h4><span id="树上随机游走">树上随机游走</span></h4><p>随机游走指每次从相邻的点中随机选一个走过去， 重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5><p>给一棵所有边长都为$1 $的$n $个点的树,问所有点对$( i , j ) ( 1 \leq i , j \leq n ) $中,从$i $走到$j $的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设$f _u $表示$u $随机走到它父亲的期望,$g _v $表示$v $的父亲(假设是$u $)走到$v $的期望.</p>
<p>对于$f _u $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { \sum _{ u \rightarrow v  } ( f _v + f _u )  } { \deg _u  } + 1 \\
f _u & = \deg _u + \sum _{ u \rightarrow v  } f _v 
\end{aligned}</script><p>对于$g _v $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _v & = \cfrac { g _u + g _v + \sum _{ u \rightarrow w , w \ne v  } ( g _v + f _w )  } { \deg _u  } + 1 \\
g _v & = g _u + \sum _{ u \rightarrow w , w \ne v  } f _w + \deg _u 
\end{aligned}</script><h5><span id="example2">Example2</span></h5><p>给出一棵$n $个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从$1 $号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案$+ 1 $.当走到度数为$1 $的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设$f _u $表示以$u $为起点的路径的期望长度,不难注意到$f _{ leaf  } = 1 $且$f _u = 1 + \cfrac { 1  } { \deg _u  } \sum _{ u \rightarrow v \lor v \rightarrow u  } f _v $.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得$f _u = k _u f _{ fa  } + b _u $,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出$g _v $表示从$v $的父亲(假设是$u $)走到$v $的概率,再令$f _u $表示从$u $走到父亲的概率,类似Example1,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { 1  } { \deg _u  } ( 1 + \sum _{ u \rightarrow v  } f _v f _u ) \\
g _v & = \cfrac { 1  } { \deg _u  } ( 1 + g _v g _u + \sum _{ u \rightarrow w , w \ne v  } f _w g _v ) 
\end{aligned}</script><p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4><h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5><p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为$\frac { 1  } { \binom { n  } { 2  }  } $.</p>
<p>把所有人权值从大到小排序,设$f _i $表示只考虑前$i $个人的时候的期望,不难发现:$f _{ i  } = \frac { 1  } { \binom { i  } { 2  }  } v _i + ( 1 - \frac { 1  } { \binom { i  } { 2  }  } ) f _{ i - 1  } $.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4><h5><span id="example1cf865c">Example1(CF865C)</span></h5><p>首先写出转移式子,但是存在后效性.如果我们设$f _{ i , j  } $表示过了$i $关,花费为$j $的期望,不难发现所有的$f $都需要与$f _{ 0 , 0  } $取$\min $,这咋办?</p>
<p>我们考虑二分这个$f _{ 0 , 0  } $,做的时候直接取$\min $,这样最后还会求出一个$f _{ 0 , 0  } $,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的$f _{ 0 , 0  } $越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取$\min $的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5><p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5><p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张$n \times m $的图(假设$n \geq m $),其中格点$( a , b ) $表示现在还剩$a $个Yes,$b $个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从$( n , m ) $走到$( 0 , 0 ) $的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线$y = x $翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从$( n , m ) $走到$( 0 , 0 ) $一定会经过$n $条有向边,所以期望贡献一定要加上一个$n $.而如果我走到了直线$y = x $上,那接下来的贡献是$\frac { 1  } { 2  } $.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2><h3><span id="树">树</span></h3><ol>
<li><p>随机树树高为$\sqrt { n  } $.</p>
</li>
<li><p>点的度数期望为$\log n $.</p>
</li>
</ol>
<h3><span id="数">数</span></h3><ol>
<li>数字的期望因数个数为$\log V $.</li>
</ol>
<h3><span id="序列">序列</span></h3><ol>
<li>随机序列的LIS长度期望为$O ( \sqrt { n  } ) $.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2><h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构相关</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2><h3><span id="维度">维度</span></h3><h4><span id="b维正交范围">B维正交范围</span></h4><p>对于一个$B $维的点$x $,满足$\forall 1 \leq i \leq B , l _i \leq x _i \leq r _i $,称所有这样的点组成的集合为一个$B $维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果$l , r $有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个$B $维正交范围有$k $个有用限制,称它为$k - side $的.</p>
<p>例如,找到区间$[ l , r ] $中$&lt; x $的元素,这个矩形是$3 - side $的.找到区间$[ 1 , l ] $中$&lt; x $的元素,这个矩形是$2 - side $的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3><h4><span id="矩阵乘法">矩阵乘法</span></h4><p>做$n \times n $的矩阵乘法目前得到的最优秀复杂度也是$O ( n ^{ 2 . 373  } ) $.</p>
<p>另外可以归约:$01 $矩阵和整数矩阵在去除$\log n $后的复杂度相同.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5><p>考虑构造一棵树:他有$\sqrt { n  } $个叉,每个叉上有$\sqrt { n  } $个点.我们将这些叉编号为$[ 1 , \sqrt { n  } ] $.然后我们考虑询问两个叉所组成的链的答案,设$f _{ i , j  } $表示数字$j $是否在$i $的叉上出现过,不难发现它们合并的时候要对$f $做或运算,$01 $矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5><p>考虑对序列和值域同时分块,考虑序列中第$L $到第$R $个块的答案,设为$f ( L , R ) $,这两块间的答案设为$g ( L , R ) $,显然$f ( L , R ) = f ( L + 1 , R ) + f ( L , R - 1 ) - f ( L + 1 , R - 1 ) + g ( L , R ) $,而由于对值域分块,$g ( L , R ) = \sum a \times b $的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5><p>平面上有若干点,两个操作:每次将横坐标小于等于$A $的点加上$v $,或者查询纵坐标小于等于$B $的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2><h3><span id="分块">分块</span></h3><h5><span id="example1luogup8527-ynoi2003-樋口円香">Example1(luoguP8527 [Ynoi2003] 樋口円香)</span></h5><p>首先将$a $分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的$L $的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为$B $,暴力处理散块的复杂度是$O ( Bm ) $,处理整块的复杂度是$O ( \frac { n  } { B  } ( m + n \log n ) ) $.取$B ^2 = \frac { n  } { m  } ( m + n \log n ) = 500 $最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了$B = 2048 $.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079-riapq">Example2(luogu[Ynoi2079] riapq)</span></h5><p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了$[ 1 , l - 1 ] $对$[ l , r ] $的贡献.</p>
<p>先序列分块.然后$[ 1 , l - 1 ] $中的整块对$[ l , r ] $的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将$[ 1 , l - 1 ] $中的整块的树状数组进行一个$[ l , r ] $的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到$O ( Bq \log n ) $的时间复杂度和$O ( Bn ) $的空间复杂度.</p>
<p>问题在于$[ 1 , l - 1 ] $中的散块咋办.首先$[ 1 , l - 1 ] $中的散块对$[ l , r ] $中的散块的贡献是好处理的,因为总共就$O ( \frac { n  } { B  } ) $个数字,直接全部存下来排序做归并就可以统计,时间复杂度$O ( Bq \log n ) $.</p>
<p>现在的问题在于$[ 1 , l - 1 ] $中的散块对$[ l , r ] $中的整块如何贡献.能不能把$[ l , r ] $的信息统计在$[ 1 , l - 1 ] $的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有$\frac { n  } { B  } $个,整块一共有$B $个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为$O ( n \sqrt { n  } \log n ) $,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022-普罗霍洛夫卡">Example3([CTS2022] 普罗霍洛夫卡)</span></h5><p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu-6331">Example4(Walking Plan HDU 6331)</span></h5><p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度$O ( nq ) $.</p>
<h5><span id="example5p5063-ynoi2014-置身天上之森">Example5(P5063 [Ynoi2014] 置身天上之森)</span></h5><p>考虑如果$n = 2 ^k $,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的$a $(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是$n $不一定是$2 ^k $,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5><p>大概是对于每个块处理出它的值域范围:一开始是$[ 1 , n ] $,然后每次操作都会将整个块分为两部分:$[ 1 , x ) $和$[ x , maxn ] $,讨论一下$maxn $和$2 x $的大小,就可以用$\min ( x , maxn - x ) $的复杂度使得$maxn $变成$maxn - x $,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3><h5><span id="example1luogup5047-ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5><p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到$O ( n \sqrt { n  } \log n ) $.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为$[ l , r ] $对$r $的贡献实际上就是$[ 1 , r ] $对$r $的贡献减去$[ 1 , l - 1 ] $对$r $的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这$O ( n \sqrt { n  } ) $次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入$O ( n ) $次但是需要查询$O ( n \sqrt { n  } ) $次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了$O ( n \sqrt { n  } ) $,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到$O ( n ) $.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3><p>我们现在有一个需要维护的$n \times n $的平面,我们现在对其进行分块:</p>
<ol>
<li><p>将平面分成$n ^{ \frac { 1  } { 2  }  } $个$n ^{ \frac { 3  } { 4  }  } \times n ^{ \frac { 3  } { 4  }  } $的$A $块,以$A $块为单位做二维前缀和.</p>
</li>
<li><p>每个$A $块内部分成$n ^{ \frac { 1  } { 2  }  } $个$n ^{ \frac { 1  } { 2  }  } \times n ^{ \frac { 1  } { 2  }  } $的$B $块,在$A $块内部以$B $块为单位做二维前缀和.</p>
</li>
<li><p>将整个平面横着分别分成一个个$n \times n ^{ \frac { 3  } { 4  }  } $的$C $块.(竖着也要分成一个个$n ^{ \frac { 3  } { 4  }  } \times n $的块,是类似的,略去)</p>
</li>
<li><p>每个$C $块内部分成$\sqrt { n  } $个$n ^{ \frac { 3  } { 4  }  } \times n ^{ \frac { 1  } { 2  }  } $个$D $块,在$C $块内部以$D $块为单位做二位前缀和.</p>
</li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度$O ( \sqrt { n  } ) $.同时注意到空间复杂度是$O ( n ) $的.</p>
<p>查询显然是分四种情况讨论:$A , B , D $块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应$O ( 1 ) $个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个$l $对应$O ( 1 ) $个$r $,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有$O ( \sqrt { n  } ) $个查询,记录一下即可.这样就做到了$O ( \sqrt { n  } ) $单点改,$O ( 1 ) $查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现$O ( 1 ) $单点改,那这种情况下如何实现$O ( \sqrt { n  } ) $求和呢?首先还是可以$O ( \sqrt { n  } ) $求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度$&lt; n ^{ \frac { 1  } { 2  }  } $,我们就可以在每次查询的时候用$\sqrt { n  } $的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以$O ( \sqrt { n  } ) $求散块.</p>
<h5><span id="example1luogup7448-ynoi2007-rdiq">Example1(luoguP7448 [Ynoi2007] rdiq)</span></h5><p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和$a _r $颜色相同的点是$r ‘ $,则显然新增的逆序对只可能出现在$[ r ‘ , r ] $中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从$n \rightarrow 1 $扫左端点,总共做$O ( n ) $次单点修改,做$O ( n \sqrt { n  } ) $次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为$( r ‘ + 1 , a _r ) $,右上角是$( r , \infty ) $的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令$rev ( x ) = n - x + 1 $.然后将所有点的纵坐标$rev $掉,现在我们要查询的也就是左下角为$( r ‘ + 1 , 1 ) $,右上角是$( r , rev ( a _r ) ) $的矩阵,这玩意可以拆前缀和拆成形如左下角是$( 1 , 1 ) $,右上角是$( i , rev ( a _i ) ) $的矩阵.也就是说我们的$O ( n \sqrt { n  } ) $次矩阵查询本质上只有$O ( n ) $种.</p>
<p>拆到这里发现其实到这一步$a _r $和$a _{ r ‘  } $是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530-ynoi2003-博丽灵梦">Example2(luoguP8530 [Ynoi2003] 博丽灵梦)</span></h5><p>首先自然的想法是拿莫队扫掉$[ l _1 , r _1 ] $这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维$[ l _2 , r _2 ] $扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点$( a , a ) $上加上一个相应的$b $,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点$A ( x _1 , x _1 ) $和$B ( x _2 , x _2 ) $之间的$( x _1 , x _2 ) $上加上一个$- b $,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol>
<li><p>莫队时查询一个点的前驱后继,这个操作就需要$O ( 1 ) $完成.</p>
</li>
<li><p>$n \sqrt { n  } $次单点修改,这个操作需要$O ( 1 ) $完成.</p>
</li>
<li><p>$n $次矩阵求和,这个操作需要在小于$O ( \sqrt { n  } ) $的时间完成.</p>
</li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为$O ( n \sqrt { n  } ) $,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3><h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5><p>首先反应是扔到trie上然后异或就是打个tag,但是$+ 1 $很难处理,因为它形如在trie上找到所有长度连续为$1 $到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是$+ 1 $的话就相当于反转一条从根开始均为$1 $的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3><h4><span id="普通线段树">普通线段树</span></h4><h5><span id="example1luogup6780-ynoi2009-pmrllcsrms">Example1(luoguP6780 [Ynoi2009] pmrllcsrms)</span></h5><p>感觉这题比较厉害.</p>
<p>先扔做法:对$c $分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求$\max $.而对于块间如何做呢?</p>
<p>我们设$suf _i $为前一个块的后$i $个数之和,$pre _i $为后一个块的前$i $个数之和.注意到我们要求的就是$\max \{ suf _i + pre _j | i + j \leq c \} $.这个咋做呢?</p>
<p>你注意到这个$i + j \leq c $的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用$j \rightarrow c - j + 1 $的话,这个限制就转化为了$i + c - j + 1 \leq c $,也就是$i &lt; j $,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对$c $分块?</p>
<p>一方面,题目中的$c $是给定的.另一方面,我们注意到我们需要维护一个和$c $有关的东西,而如果没有$c $,或者说$c = n $的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了$c = n $的条件.考虑到这一点,对$c $分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将$a [ l - 1 ] $和$a [ r + 1 ] $都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个$maxn $设成$- \infty $的.如果这两个东西设成等大的$- \infty $,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比$- \infty $还要小的数字,最底层的$maxn $有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4><p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5><p>注意到每个点其实只需要找到$[ i - r _i , i - 1 ] $和$[ i + 1 , i + r _i ] $这两段的最大值,设为$x $,则最后的答案就是$\max \{ a _i + x \} $.</p>
<p>思考这个过程,我们将$[ i - r _i , i - 1 ] $和$[ i + 1 , i + r _i ] $这两条线段以$a _i $的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的$a _i $的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4><h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5><p>考虑全局的和是$sum $,则我们要在这些数中找到一个分界点,使得左边的和大于等于$sum $,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5><p>给定$a _i , b _i $,选定至多$k $个位置使这里的值为$a _i - b _i $,其它位置的值是$a _i $,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的$mid $,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出$\min _{ k = 1  } ^r \{ \max ( \max _{ i = k + 1  } ^n \{ sum _{ i  } \} , - b _k + \max _{ i = 1  } ^k \{ sum _i \} ) \} $.注意改掉一个位置后要把它的$b $变成$0 $.</p>
<p>那么什么样的$b $有可能是我们要选中的呢?显然可能被选中的$b $一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:$\min _{ k = 1  } ^r \{ \max ( \max _{ i = k + 1  } ^n \{ sum _{ i  } \} , - \max _{ i = k  } ^n \{ b _i \} + \max _{ i = 1  } ^k \{ sum _i \} ) \} $,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的$\max $尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\min _{ k = 1  } ^r \{ \max ( sufmax ( sum ) _{ k + 1  } , - sufmax ( b ) _k + premax ( sum ) _k \} \\
& = \min _{ k = 1  } ^r \{ \max ( sufmax ( sum ) _{ k + 1  } , - \max ( sufmax ( b ) _{ k + 1  } , b _k ) + premax ( sum ) _k \} \\

\end{aligned}</script><p>这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的$k $后面最大的$b $,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响$sufmax ( b ) $的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的$b $,这个$b $必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4><h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4><h4><span id="吉司机线段树">吉司机线段树</span></h4><h4><span id="李超线段树">李超线段树</span></h4><h3><span id="珂朵莉树">珂朵莉树</span></h3><h5><span id="example1luogup8512-ynoi-easy-round-2021-test_152">Example1(luoguP8512 [Ynoi Easy Round 2021] TEST_152)</span></h5><p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3><h3><span id="kd-tree">KD-Tree</span></h3><p>处理$K $维正交范围(给定$n $个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度$O ( n ^{ 1 - \frac { 1  } { k  }  } + \log n ) $.(单调修改复杂度只是$O ( \log n ) $)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4><p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4><p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> siz;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">ll d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=cur[mid];</span><br><span class="line">tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line"><span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3><h5><span id="example1cfgym101613factor-free-tree">Example1([CFgym101613]Factor-free tree)</span></h5><p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是$\sum dep _u $,是可以被卡成$O ( n ^2 ) $的.</p>
<p>但我们考虑类似dsu on tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5><p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为$[ l , r ] $,这样会有:$[ l - 1 , i - 1 ] \rightarrow [ i , r ] $.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3><h5><span id="exampleloj3151">Example(loj3151)</span></h5><p>首先自然地,我们设$f _{ i , j  } $表示前$i $个测试点已经分成了$j $段的方案数,然后做转移,复杂度$O ( T ^2 S ) $.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到$k $最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把$[ l , r ] $分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点$r $,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3><p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5><p>维护一个序列支持把$x $位置的值改为$y $或查询一个区间中小于$y $的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054-jsoi2009计数问题">Example2(Luogu4054 [JSOI2009]计数问题)</span></h5><p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开$100 $个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2><h3><span id="分开考虑">分开考虑</span></h3><h5><span id="example1p6105-ynoi2010-y-fast-trie">Example1(P6105 [Ynoi2010] y-fast trie)</span></h5><p>考虑只有两种可能:</p>
<ol>
<li><p>$x + y &lt; C $,取$x + y $作为答案.</p>
</li>
<li><p>$x + y \geq C $,取$x + y - C $作为答案.</p>
</li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在$[ 0 , \lceil \frac { C  } { 2  } \rceil ) $中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,$x + y &lt; C $也就是$x &lt; C - y $,我们把第二个集合中的元素全部变成$C - y $后插入,只需最小化$C - x - y $,这个只需要维护最大的$x $和最小的$C - y $就行.</p>
<h3><span id="合并信息">合并信息</span></h3><p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复 / [JSOI2011]括号序列)</span></h5><p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5><p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用$O ( \log n ) $的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5><p>设$w _i $为从上往下延伸到$i $这个点后,还能多往下延伸多少,一开始$w $都是$- 1 $,每次操作会让$w + = 1 $.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3><h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5><p>自然的想法是考虑找到每个点前面第一个和它之和为$w $的数字,但这样就炸了,因为每修改一个点可能要影响$O ( n ) $个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为$w $的数字,而显然只有两个数互相匹配才可行.如果$i &lt; j &lt; k , ( i , j ) , ( i , k ) $分别配对,那么显然$( i , k ) $没有用.这样每个点只有$O ( 1 ) $个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3><h5><span id="example1luogup5278-算术天才9与等差数列">Example1(luoguP5278 算术天才⑨与等差数列)</span></h5><p>首先考虑$k = 1 $怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p>$k \ne 1 $怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在$\bmod k $意义下全部相等,维护差分数组的区间$\gcd $就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3><h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5><p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为$q $的衣服,$[ 0 , q ) $的人肯定买不了,$[ q , 2 q - 1 ] $的人买完后,手上的钱至少减半,我们暴力处理,至于$[ 2 q , + \infty ) $,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5><p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到$0 $,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690-ynoi2016镜中的昆虫">Example3(Luogu 4690 [Ynoi2016]镜中的昆虫)</span></h5><p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是$pre [ i ] = i - 1 $).</p>
<h3><span id="根号分治">根号分治</span></h3><h5><span id="example1luogup7722-ynoi2007-tmpq">Example1(luoguP7722 [Ynoi2007] tmpq)</span></h5><p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改$a , b , c $中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5><p>对于一个数字$x $,每次随机在$[ 1 , x ] $中一个数$y $并令$x \leftarrow x \bmod y $,初始值为$n $,求期望几次能变成$0 $.</p>
<p>注意到如果$y $很小就直接做,$y $很大的话$\lfloor \frac { x  } { y  } \rfloor $很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5><p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5><p>给定序列,每次询问给出两个数字$x , y $,求最小的$| i - j | $满足$a _i = x , a _j = y $.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果$x , y $出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5><p>首先对于$Y $很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于$Y $很大的情况,$\frac { n  } { Y  } $一定很小,我们不断查询大于等于$kY $的最小元素即可,这个可以值域分块来根号平衡做到$O ( 1 ) $查询,$O ( \sqrt { n  } ) $单点修改.具体地,我们对每个块处理出大于等于这个块的最小的$X $,以及块内每个点后面最小的$X $(必须在块内),然后定位到$kY $的块.</p>
<h5><span id="example6">Example6</span></h5><p>给定$n , m $,以及序列$a $和长度为$n $的排列$y $,你需要回答$m $个询问.对每个询问,给定$l , r $,查询:</p>
<script type="math/tex; mode=display">
\sum _{ i = 1  } ^n \sum _{ j = i + 1  } ^n [ a _i = a _j ] \prod _{ k = i  } ^j [ l \leq y _k \leq r ]</script><p>注意到$y _i = i $的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点$( x , y ) , a _x = a _y , \nexists x &lt; z &lt; y , a _z = a _x $,对于$( x , y ) $这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于$\sqrt { n  } $的数字,它们最多只有$\sqrt { n  } $个,考虑莫队复杂度$O ( n \sqrt { m  } + m ) $,因此我们可以对每个分别做莫队,总复杂度$O ( n \sqrt { m  } + m \sqrt { n  } ) $,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于$\sqrt { n  } $的数字,这些数字一共最多有$n $个,每个点暴力配对就有$O ( n \sqrt { n  } ) $个点对,然后$O ( m ) $次询问,用根号平衡做扫描线,这里复杂度$O ( n \sqrt { n  } + m \sqrt { n  } ) $.</p>
<h3><span id="重链分治">重链分治</span></h3><h5><span id="example1luogu5314-ynoi2011odt">Example1(Luogu5314 [Ynoi2011]ODT)</span></h5><p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为$1 $,支持把一条链上所有点加上$k $,或者查询距离一个点$&lt; = 1 $的所有点的点权$kth $.$n \leq 2 \times 10 ^5 $.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改$O ( \log n ) $个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3><h4><span id="一维扫描线">一维扫描线</span></h4><p>最经典的应用是对于一个$B $维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个$B - 1 $维的动态问题.不过扫描线处理的时候可能需要是低$side $的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4><p>也就是莫队.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1cf1609f-interesting-sections">Example1(CF1609F Interesting Sections)</span></h5><p>首先枚举每个数的$popcount $,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点$x $作为最大值的影响区间$[ l , r ] $,也就是如果一个区间左端点在$[ l , x ] $,右端点在$[ x , r ] $即可满足条件.我们考虑放入一个左下角坐标为$( l , x ) $,右上角坐标为$( x , r ) $的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5><p>离散化,设$S = \{ l \} \cup \{ r \} $,考虑用$len _i $表示$i $节点及以前最多能有多少阳光.我们考虑用$len _{ i - 1  } $更新$len _i $,如果$[ i - 1 , i ] $没被覆盖,显然直接加上这段的长度.如果$[ i - 1 , i ] $被覆盖大于两次,那显然直接继承$len _{ i - 1  } $.</p>
<p>先考虑$[ i - 1 , i ] $被两朵云覆盖了怎么办,我们考虑用$h _{ j , k  } $表示当前被且只被$j $和$k $共同覆盖的区间长度,不难发现$h _{ j , k  } $有值的地方很少,用map.然后还要加上它们各自的贡献,用$g _j $表示当前被且只被$j $覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断$[ i - 1 , i ] $是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果$[ i - 1 , i ] $被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为$k $,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是$g _j + g _k $,用线段树处理出当前代价和小于等于$C $的$k $的$g _k $的最大值就行.</p>
<p>再考虑有交的情况,答案应该为$g _j + g _k + h _{ j , k  } $,我们在每次遇到$( j , k ) $的时候都在对方那里打个tag就好,也就是对于每个$j $,处理出和它有交的云中$g _j + g _k + h _{ j , k  } $的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5><p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成$0 $后那些数一定没清空).</p>
<h5><span id="example4luogup7709-wdsr-27八云蓝自动机-ii">Example4(luoguP7709 「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5><p>如果初始序列全为$0 $:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5><p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5><p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是$L &lt; R $,自然有$L \leq \min \{ r _i \} , R \geq \max \{ l _i \} $,那么当我们确定$L $后,我们有$R \in [ \max \{ l _i \} , f ( L ) ] $.接下来我们考虑如何计算$f ( L ) $.</p>
<p>注意到$L &lt; l _i \Rightarrow R \leq r _i $,我们考虑将$l _i $这个点的权值设成$r _i $,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3><h4><span id="回滚莫队">回滚莫队</span></h4><h4><span id="带修莫队">带修莫队</span></h4><p>也就是维护三维的扫描线,根据KDT不难发现复杂度是$O ( nm ^{ \frac { 2  } { 3  }  } ) $,$B = n ^{ \frac { 2  } { 3  }  } $,排序原则是$( ls , rs , t ) $,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4><h4><span id="二次离线莫队">二次离线莫队</span></h4><p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个$\log n $的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带$\log n $的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有$n \sqrt { n  } $次询问,每次询问$f ( l , r , r + 1 ) $表示区间$[ l , r ] $对$r + 1 $的逆序对贡献.考虑差分成$f ( 1 , r , r + 1 ) - f ( 1 , l - 1 , r + 1 ) $,前者显然可以迅速求出.而后者的右端点需要移动$n $次,需要查询总共$n \sqrt { n  } $次,zhe’ge</p>
<h4><span id="example">Example</span></h4><h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5><p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都$4 - side $了,但是有可减性,减成$2 - side $就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5><p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉$p = 2 $和$p = 5 $的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字$\bmod p $的值,设为$suf _i $,假设存在两个点$l , r $满足$p | ( suf _l - suf _{ r + 1  } ) $,那么$[ l , r ] $就是合法的,这是自然的,也就等价于$suf _l = suf _{ r + 1  } $,相当于要对满足$suf _l = suf _{ r + 1  } $的二元组$( l , r ) $计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604-美好的每一天">Example3(luoguP3604 美好的每一天)</span></h5><p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3><p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的$( l , r ) $的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5><p>考虑转化为二维平面,$a _{ l , r  } = maxn - minn - ( r - l ) $,显然只需要找到为$0 $的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有$3 - side $的,但是可差分成$2 - side $.</p>
<h3><span id="时间倒流">时间倒流</span></h3><h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5><p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5><p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3><h5><span id="example1cf1540d-inverse-inversions">Example1(CF1540D Inverse Inversions)</span></h5><p>考虑对于一个数列怎么构造:假设只考虑前$k $个数,它们的取值是$[ 1 , k ] $,现在加入第$k + 1 $个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都$+ 1 $,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道$p _i $是多少,根据上面的构造过程,首先将$p _i = a _i $,然后不断向后遍历,每遇到一个$a _j $,如果$a _j \leq p _i $,则把$p _i + = 1 $.</p>
<p>我们将数列分块,设块长为$B $,那一个值经过一个块的时候最多加块长个$1 $.也就是经过整块的时候是一个$B $段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是$\sum { \cfrac { B  } { 2 ^i  }  } = B $的,</p>
<p>于是最后复杂度为$O ( T ( B + \cfrac { n  } { B  } \log n ) ) $,取$B = \sqrt { n \log n  } $即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3><p>根号平衡主要用到下面四个东西:</p>
<ol>
<li><p>$O ( 1 ) $单点加,$O ( \sqrt { n  } ) $区间和:维护块内的和即可.</p>
</li>
<li><p>$O ( \sqrt { n  } ) $单点加,$O ( 1 ) $区间和:维护块内和块间的前缀和即可.</p>
</li>
<li><p>$O ( \sqrt { n  } ) $区间加,$O ( 1 ) $单点和:差分转化为$( 2 ) $.当然打标记也是可以的.</p>
</li>
<li><p>$O ( 1 ) $区间加,$O ( \sqrt { n  } ) $单点和:差分转化为$( 1 ) $.当然打标记也是可以的.</p>
</li>
</ol>
<p>还有一些拓展的东西:</p>
<ol>
<li><p>维护值域$O ( n ) $的集合,支持$O ( 1 ) $插入,$O ( \sqrt { n  } ) $查询第$k $小:值域分块就可以.</p>
</li>
<li><p>维护值域$O ( n ) $的集合,支持$O ( \sqrt { n  } ) $插入,$O ( 1 ) $查询第$k $小:值域分块,然后暴力改变每个点所属的块就行.</p>
</li>
</ol>
<h4><span id="example">Example</span></h4><h5><span id="example1区间众数">Example1(区间众数)</span></h5><p>首先分块,处理出$f _{ l , r  } $表示块$[ l , r ] $的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是$\log n $的,因此复杂度$O ( n \sqrt { n \log n  } ) $.</p>
<p>但是可以优化,我们设$mx $表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于$mx $可以$O ( 1 ) $判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然$mx $增加总次数也不会超过$O ( \sqrt { n  } ) $,因此做到$O ( n \sqrt { n  } ) $.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-and-churu">Example2(CodeChef Chef and Churu)</span></h5><p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个$O ( 1 ) $查询区间和,$O ( \sqrt { n  } ) $单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5><p>莫队,发现有$m $次查询,$n \sqrt { m  } $次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5><p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有$O ( n ) $种,用值域分块就可以平衡复杂度.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式与生成函数</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2><h3><span id="复数相关">复数相关</span></h3><p>棣莫弗定理:$( cos \theta + i \sin \theta ) ^n = \cos ( n \theta ) + i \sin ( n \theta ) $.</p>
<p>欧拉公式:$e ^{ i \pi  } = - 1 $.</p>
<p>也就是$e ^{ 2 i \pi  } = 1 $,同时又有$e ^{ i \theta  } = cos \theta + i · sin \theta $,证明直接使用泰勒展开.</p>
<p>单位根:对于$x ^n = 1 $,我们会有$n $个根,设第$k $个根为$\omega _n ^k $.那么我们有:$\omega _n ^k = e ^{ 2 \pi \frac { k  } { n  } i  } = cos ( 2 \pi \frac { k  } { n  } ) + i · sin ( 2 \pi \frac { k  } { n  } ) $.</p>
<p>单位根有以下性质:</p>
<ol>
<li><p>折半引理:$\omega _{ 2 n  } ^{ 2 k  } = \omega _n ^k \ $,由我们上面推导的通项公式即可证明.</p>
</li>
<li><p>消去引理:$\omega _n ^{ k + \frac { n  } { 2  }  } = - \omega _n ^k \ $,同样使用通项，运用三角恒等变换可证明.</p>
</li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4><p>上复平面,设$S _k = ( \cos \frac { 2 k \pi  } { n  } , \sin \frac { 2 k \pi  } { n  } ) $,也就是$z _k = \cos \frac { 2 k \pi  } { n  } + i \sin \frac { 2 k \pi  } { n  } $是方程$z ^n - 1 = 0 $的复根.我们把这个方程写开:</p>
<script type="math/tex; mode=display">
z ^n - 1 = ( z - 1 ) ( z ^{ n - 1  } + z ^{ n - 2  } + \cdots + 1 ) = 0</script><p>不难发现$z = 1 $是平凡解.</p>
<p>我们不妨定义$f ( x ) = \prod _{ k = 1  } ^n ( 1 + X ^k ) = \sum _{ k \geq 0  } a _k X ^k $,事实上我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { n  } \sum _{ j = 1  } ^n f ( \omega _n ^j ) & = \frac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k \geq 0  } a _k \omega ^{ kj  } _n \\
& = \frac { 1  } { n  } \sum _{ k \geq 0  } a _k \sum _{ j = 1  } ^n \omega _{ n  } ^{ kj  } \\
& = \sum _{ j \geq 0  } a _{ jn  } + \frac { 1  } { n  } \sum _{ k \geq 0 , n \nmid k  } a _k \frac { 1 - \omega ^{ nj  } _n  } { 1 - \omega ^{ k  } _n  } \omega _{ n  } ^j \\
& = \sum _{ j \geq 0  } a _{ jn  } 
\end{aligned}</script><p>事实上,我们令$d = \frac { n  } { \gcd ( j , n )  } $,容易发现$f ( \omega _n ^j ) = ( \prod _{ k = 1  } ^d ( 1 + \omega _n ^{ kj  } ) ) ^{ \frac { n  } { d  }  } $,又容易发现$n | jd $.</p>
<p>接下来观察$X ^d - 1 = \prod _{ k = 1  } ^d ( X - \omega _{ n  } ^{ kj  } ) $,带入$X = - 1 $得到$f ( \omega _n ^j ) = \begin{cases}2 ^{ \frac { n  } { d  }  } &amp; d \in \text { odd  } \ 0 &amp; d \in \text { even  } \end{cases} $.</p>
<p>接下来考虑拿到$\sum _{ j  } a _{ jn  } $,只需求$\frac { 1  } { n  } \sum _{ j = 1  } ^n f ( \omega _n ^j ) = \frac { 1  } { n  } \sum _{ d \in \text { odd  } , \gcd ( j , n ) = \frac { n  } { d  }  } 2 ^{ \frac { n  } { d  }  } = \frac { 1  } { n  } \sum _{ d \in \text { odd  }  } \varphi ( d ) 2 ^{ \frac { n  } { d  }  } $.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5><p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现$+ , - , \times , \div , \sqrt [2 ] {  } $五种操作.而对于正$n $边形,显然只要我们能将$\cos \frac { 2 \pi  } { n  } $用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6><p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma _1 & = z _1 + z _4 \\
\sigma _2 & = z _2 + z _3 
\end{aligned}</script><p>不难验证:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma _1 + \sigma _2 & = - 1 \\
\sigma _1 \sigma _2 & = - 1 
\end{aligned}</script><p>可以求出复合条件的解,将$z $带入又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma _1 & = 2 \cos \frac { 2 \pi  } { 5  } \\
\sigma _2 & = 2 \cos \frac { 4 \pi  } { 5  } 
\end{aligned}</script><p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6><p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6><p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设$n \in prime $,我们用$p $代替$n $.</p>
<p>我们有$z _1 = \cos \frac { 2 \pi  } { p  } + i \sin \frac { 2 \pi  } { p  } $,由于其它的$z $都可以表示成它的幂,因此我们记$\varepsilon = z _1 $.</p>
<p>我们现在想要这么分组:</p>
<script type="math/tex; mode=display">
\sigma _{ k + 1  } = \sum _{ 1 \leq l \leq p - 1 , f ( l , k ) = 1  } \varepsilon ^l</script><h3><span id="泰勒展开">泰勒展开</span></h3><p>即$f ( x ) = g ( x ) = f ( x _0 ) + \sum _{ k \geq 1  } \frac { f ^{ ( k )  } ( x _0 )  } { k !  } ( x - x _0 ) ^k \ $.$x _0 = 0 $的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2><h3><span id="多项式基础">多项式基础</span></h3><h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4><p>代数基本定理:一个$n - 1 $次方程在复数域上有且只有$n - 1 $个根.</p>
<p>定理:一个$n - 1 $次多项式在$n $个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个$n - 1 $次多项式$A ( x ) $和$B ( x ) $且有$\forall i \in [ 0 , n - 1 ] , A ( x _i ) = B ( x _i ) \ $.</p>
<p>令$C ( x ) = A ( x ) - B ( x ) $,那么$C ( x ) $至多是一个$n - 1 $次多项式且$\forall i \in [ 0 , n - 1 ] , C ( x _i ) = 0 \ $,也就是$C ( x ) $有$n $个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:$A ( x ) = \sum _{ i = 0  } ^{ n - 1  } a _i x ^i \ $.</p>
<p>点值表示法:$y _i = \sum _{ j = 0  } ^{ n - 1  } a _j x _i ^j \ $.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4><p>构造多项式$\sum _{ i = 0  } ^{ n - 1  } y _i ( \prod _{ j = 0 \land j \ne i  } ^{ n - 1  } \frac { x - x _j  } { x _i - x _j  } ) \ $.显然当$x = x _i $时,该多项式的答案为$y _i $.</p>
<p>另外,如果$x _i = i $,不难发现这个式子可以写成:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^{ n  } y _i ( \prod _{ j = 1 \land j \ne i  } ^{ n  } \frac { x - x _j  } { x _i - x _j  } ) \\
\\
& = \sum _{ i = 1  } ^n y _i ( \prod _{ j = 1 \land j \ne i  } ^n \cfrac { x - j  } { i - j  } ) \\
& = \sum _{ i = 1  } ^n y _i ( - 1 ) ^{ n - i  } ( \cfrac { 1  } { ( i - 1 ) ! ( n - i ) !  } \prod _{ j = 1 , j \ne i  } ^{ n  } ( x - j ) ) 
\end{aligned}</script><h3><span id="多项式运算">多项式运算</span></h3><p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4><h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5><h6><span id="dft">DFT</span></h6><p>将$n $次单位根(默认$n $是二的整次幂,如果少了的话补零,设$n = 2 ^w $)分别带入$A ( x ) $得到点值向量$A ( \omega _n ^k ) \ $.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( x ) & = \sum _{ i = 0  } ^{ n - 1  } a _i x ^i \\
& = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^i + \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a _i x ^i \\
& = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^{ 2 k  } + x \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a _i x ^{ 2 k  } \\

\end{aligned}</script><p>令</p>
<p>A_2(x)=\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{k}\\$, 那 么 $A(x)=A_1(x^2)+xA_2(x^2)\\</p>
<p>接下来分类讨论:</p>
<p>$\forall 0 \leq k \leq \frac { n  } { 2  } - 1 , k \in \mathbb { N  } \ $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^k ) & = A _1 ( \omega _n ^{ 2 k  } ) + \omega _n ^k A _2 ( \omega _n ^{ 2 k  } ) \\

\end{aligned}</script><p>根据折半引理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^k ) & = A _1 ( \omega _{ \frac { n  } { 2  }  } ^k ) + \omega _n ^k A _2 ( \omega ^k _{ \frac { n  } { 2  }  } ) \\

\end{aligned}</script><p>这样我们处理完了前半部分.</p>
<p>$\forall \frac { n  } { 2  } \leq k + \frac { n  } { 2  } \leq n - 1 , k \in \mathbb { N  } \ $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) & = A _1 ( \omega _n ^{ 2 k + n  } ) + \omega _n ^{ k + \frac { n  } { 2  }  } A _2 ( \omega _n ^{ 2 k + n  } ) \\

\end{aligned}</script><p>根据消去引理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) & = A _1 ( \omega _{ \frac { n  } { 2  }  } ^k ) - \omega _n ^k A _2 ( \omega _{ \frac { n  } { 2  }  } ^k ) \\

\end{aligned}</script><p>综上,我们可以递归处理$A _1 $和$A _2 $,然后合并得到$A $的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6><p>设$A ( \omega _n ^k ) = d _k \ $,构造多项式$F ( x ) = \sum _{ i = 0  } ^{ n - 1  } d _i x ^i \ $.</p>
<p>我们求出$F ( x ) $的点值表示,设$c _k = F ( \omega _n ^{ - k  } ) \ $,也即:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c _k & = \sum _{ i = 0  } ^{ n - 1  } d _i ( \omega _n ^{ - k  } ) ^i \\
& = \sum _{ i = 0  } ^{ n - 1  } ( \sum _{ j = 0  } ^{ n - 1  } a _j ( \omega _n ^i ) ^j ) ( \omega _n ^{ - k  } ) ^i \\
& = \sum _{ j = 0  } ^{ n - 1  } a _j \sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } \\

\end{aligned}</script><p>当$j = k $时,显然$\sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } = n \ $.</p>
<p>否则根据等比数列求和公式,$\sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } = \frac { \omega ^0 _n [ ( \omega _n ^{ j - k  } ) ^n - 1 ]  } { \omega _n ^{ j - k  } - 1  } = 0 \ $.</p>
<p>所以$\sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } = n [ j = k ] \ $.</p>
<p>那么我们有</p>
<p>a_k=\frac{c_k}{n}\\</p>
<h6><span id="写法">写法</span></h6><p>递归写法显然.</p>
<p>递归过程中,第$k $层相当于在根据数在第$k $位的二进制数是$1 $还是$0 $来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">ll ak=a[i+k];</span><br><span class="line">a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5><p>由于FFT中的单位根会产生精度误差,因此在膜$998244353 $意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为$g $,$g _n = g ^{ \frac { p - 1  } { n  }  } \ $,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol>
<li><p>$g _n ^n = g _n ^0 = 1 $且$\forall 0 \leq i &lt; j &lt; n , g _n ^i \ne g _n ^j $,证明由原根的性质.</p>
</li>
<li><p>折半引理:$g _{ 2 n  } ^{ 2 k  } = g _{ n  } ^k $,证明显然.</p>
</li>
<li><p>消去引理:$g _{ n  } ^{ k + \frac { n  } { 2  }  } = - g ^k _n \ $.由于$g ^{ \frac { p - 1  } { 2  }  } = - 1 $,该结论显然成立.</p>
</li>
</ol>
<p>由上我们证明了,我们完全可以使用$g _n $代替$\omega _n $进行变换.</p>
<p>另外,注意到$998244352 = 2 ^{ 23  } \times 7 \times 17 \ $,而$2 ^{ 23  } \approx 8 \times 10 ^6 \ $.因而,当$n \leq 8 \times 10 ^6 $的时候,$g _n $可以直接求出.这也是为什么大部分NTT题目都使用$998244353 $作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5><p>范德蒙德矩阵形如:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & \alpha _1 & \cdots & \alpha _1 ^{ n - 1  } \\
1 & \alpha _2 & \cdots & \alpha _2 ^{ n - 1  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \alpha _m & \cdots & \alpha _m ^{ n - 1  } 
\end{bmatrix} \in \mathbb { R  } ^{ m \times n  }</script><p>如果取单位根,我们有:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega _n ^1 & \cdots & \omega _2 ^{ n - 1  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega _n ^{ n - 1  } & \cdots & \omega _n ^{ ( n - 1 ) ^2  } 
\end{bmatrix} \in \mathbb { R  } ^{ n \times n  }</script><p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega _n ^1 & \cdots & \omega _2 ^{ n - 1  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega _n ^{ n - 1  } & \cdots & \omega _n ^{ ( n - 1 ) ^2  } 
\end{bmatrix} ^{ - 1  } = \frac { 1  } { n  } \begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega _n ^{ - 1  } & \cdots & \omega _2 ^{ - ( n - 1 )  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega _n ^{ - ( n - 1 )  } & \cdots & \omega _n ^{ - ( n - 1 ) ^2  } 
\end{bmatrix}</script><h4><span id="分治fft">分治FFT</span></h4><p>给定$g ( x ) $和$f ( 0 ) $,求$f ( x ) = \sum _{ y = 1  } ^x f ( x - y ) g ( y ) $,答案对$998244353 $取膜.</p>
<p>考虑分治,假如我们已经知道了$f ( x ) , x \in [ 1 , \frac { n  } { 2  } ] $.那我们可以计算出这段部分对$f ( y ) ， y \in [ \frac { n  } { 2  } + 1 , n ] $的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算$f $和$g $的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4><p>对于多项式$P ( x ) $,找到$Q ( x ) $使得$Q ( x ) P ( x ) \equiv 1 \pmod { x ^{ n  }  } \ $.显然$Q ( x ) $是唯一的.</p>
<p>首先不妨设$n = 2 ^k \ $.</p>
<p>如果我们已知$P ( x ) Q _{ k - 1  } ( x ) \equiv 1 \pmod { x ^{ 2 ^{ k - 1  }  }  } \ $,同时肯定有$P ( x ) Q _{ k  } ( x ) \equiv 1 \pmod { x ^{ 2 ^{ k - 1  }  }  } \ $,相减得到$Q _k ( x ) - Q _{ k - 1  } ( x ) \equiv 0 \pmod { x ^{ 2 ^{ k - 1  }  }  } \ $.</p>
<p>两边平方:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q _k ^2 ( x ) + Q ^2 _{ k - 1  } ( x ) - 2 Q _k ( x ) Q _{ k - 1  } ( x ) & \equiv 0 \pmod { x ^{ 2 ^k  }  } \\

\end{aligned}</script><p>两边乘一下$P ( x ) $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q _k ( x ) - 2 Q _{ k - 1  } ( x ) + P ( x ) Q _{ k - 1  } ^2 ( x ) & \equiv 0 \pmod { x ^n  } \\
Q _k ( x ) & \equiv 2 Q _{ k - 1  } ( x ) - P ( x ) Q _{ k - 1  } ^2 ( x ) \pmod { x ^n  } \\

\end{aligned}</script><p>根据主定理，这么做复杂度是$O ( n \log _2 n ) $的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F ( x ) & \equiv F ( x ) G ( x ) + f _0 \pmod { x ^{ n + 1  }  } \\
F ( x ) & = \frac { f ( 0 )  } { 1 - G ( x )  } \pmod { x ^{ n + 1  }  } 
\end{aligned}</script><p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4><p>对于$n $次多项式$F ( x ) $和$m $次多项式$G ( x ) $,找到$Q ( x ) , R ( x ) $使得$F ( x ) = G ( x ) Q ( x ) + R ( x ) \ $.</p>
<p>考虑对于$n $次多项式$F ( x ) $,令$F _R ( x ) = x ^n F ( \cfrac { 1  } { x  } ) $,如果设$f _i $为其$x ^i $项前的系数,不难发现$f _R ( i ) = f ( n - i ) $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F ( x ) & = G ( x ) Q ( x ) + R ( x ) \\
F ( \cfrac { 1  } { x  } ) & = G ( \cfrac { 1  } { x  } ) Q ( \cfrac { 1  } { x  } ) + R ( \cfrac { 1  } { x  } ) \\
x ^n F ( \cfrac { 1  } { x  } ) & = x ^m G ( \cfrac { 1  } { x  } ) x ^{ n - m  } Q ( \cfrac { 1  } { x  } ) + x ^{ n - m + 1  } x ^{ m - 1  } R ( \cfrac { 1  } { x  } ) \\
F _R ( x ) & = G _R ( x ) Q _R ( x ) + x ^{ n - m + 1  } R _R ( x ) \\
F _R ( x ) & \equiv G _R ( x ) Q _R ( x ) \pmod { x ^{ n - m + 1  }  } \\
Q _R ( x ) & \equiv F _R ( x ) G _R ^{ - 1  } ( x ) \pmod { x ^{ n - m + 1  }  } 
\end{aligned}</script><p>于是只要做一遍多项式求逆即可求得$Q ( x ) $,再做一遍相减既可以得到$R ( x ) $.</p>
<h4><span id="多项式ln">多项式ln</span></h4><p>给出$n - 1 $次多项式$A ( x ) $,求一个多项式$B ( x ) $,满足$B ( x ) \equiv \ln A ( x ) $.</p>
<p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
B ( x ) & \equiv \ln A ( x ) \pmod { x ^n  } \\
B ' ( x ) & \equiv \cfrac { A ' ( x )  } { A ( x )  } \pmod { nx ^{ n - 1  }  } \\
B ( x ) & \equiv \int \cfrac { A ' ( x )  } { A ( x )  } dx \pmod { x ^n  } \\

\end{aligned}</script><p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当$[ x ^0 ] f ( x ) = 1 $的时候,$f ( x ) $有对数多项式.</p>
<p>我们对最后再做一步:</p>
<script type="math/tex; mode=display">
\begin{aligned}
B ( x ) & \equiv \int _0 ^x \cfrac { A ' ( t )  } { A ( t )  } dt + B ( 0 ) \pmod { x ^n  } \\

\end{aligned}</script><p>首先$B ( 0 ) = \ln A ( 0 ) = \ln a _0 $,如果$a _0 \in \mathbb { Q  } \land a _0 \ne 1 $,则$B ( 0 ) \notin \mathbb { Q  } $,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若$[ x ^0 ] f ( x ) = 1 $的时候,$B ( 0 ) = 0 $,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4><p>给定多项式$G ( x ) $,求一个多项式$F ( x ) $满足$G ( F ( x ) ) \equiv 0 \pmod { x ^n  } $.</p>
<p>首先$n = 1 $的时候,也就是求$G ( F ( x ) ) \equiv 0 \pmod { x  } $.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在$\bmod x ^{ \lceil \frac { n  } { 2  } \rceil  } $意义下的答案$F _0 ( x ) $,我们考虑在$F _0 ( x ) $处做泰勒展开:</p>
<script type="math/tex; mode=display">
\begin{aligned}
G ( F ( x ) ) & = \sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k )  } ( F _0 ( x ) )  } { k !  } ( F ( x ) - F _0 ( x ) ) ^k & \equiv 0 \pmod { x ^n  } \\

\end{aligned}</script><p>考虑$F ( x ) - F _0 ( x ) $,由于$F _0 ( x ) \equiv F ( x ) \pmod { x ^{ \lceil \frac { n  } { 2  } \rceil  }  } $,因此,因此$( F ( x ) - F _0 ( x ) ) ^2 \equiv 0 \pmod { x ^n  } $.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k )  } ( F _0 ( x ) )  } { k !  } ( F ( x ) - F _0 ( x ) ) ^k & \equiv 0 \pmod { x ^n  } \\
G ( F _0 ( x ) ) + G ' ( F _0 ( x ) ) ( F ( x ) - F _0 ( x ) ) & \equiv 0 \pmod { x ^n  } \\
F ( x ) & \equiv F _0 ( x ) - \frac { G ( F _0 ( x ) )  } { G ' ( F _0 ( x ) )  } \pmod { x ^n  } 
\end{aligned}</script><p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4><p>给定$h ( x ) $,设$g ( f ( x ) ) = f ^2 ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<script type="math/tex; mode=display">
f ( x ) \equiv f _0 ( x ) - \frac { f ^2 ( x ) - h ( x )  } { 2 f _0 ( x )  } \equiv \frac { f ^2 ( x ) + h ( x )  } { 2 f _0 ( x )  } \pmod { x ^n  }</script><p>还没完,用牛顿迭代前一定要求$g ( a ) \equiv 0 \pmod { x ^n  } $的解,也就是$[ x ^0 ] h ( x ) $的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4><p>给定$h ( x ) $,设$g ( f ( x ) ) = \ln f ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( x ) & \equiv f _0 ( x ) - \frac { \ln f _0 ( x ) - h ( x )  } { \frac { 1  } { f _0 ( x )  }  } \pmod { x ^n  } \\
& \equiv f _0 ( x ) ( 1 - \ln f _0 ( x ) + h ( x ) ) \pmod { x ^n  } 
\end{aligned}</script><p>还没完,还需要求$g ( a ) \equiv 0 \pmod { x ^n  } $的解,注意到存在$\exp $当且仅当$[ x ^0 ] g ( x ) \equiv 0 $,此时$f ( x ) \equiv 1 \pmod { x  } $.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4><p>求$\ln $后求$\exp $即可,唯一的问题是为什么指数可以对$p $取膜.</p>
<p>我们有一个结论:</p>
<script type="math/tex; mode=display">
f ( x ^p ) \equiv f ( x ) ^p \pmod { p  }</script><p>这个结论很简单,注意到$( a + b ) ^p \equiv a ^p + b ^p \pmod { p  } $即可.</p>
<p>而又由于$n &lt; p $,因此$f ( x ) ^p \equiv f ( 0 ) \pmod { p  } $,通常取$f ( 0 ) = 1 $,于是就可以直接对$p $取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4><p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做$\exp $的时候的直接数组传参,会导致$\exp $的复杂度退化到$O ( n \log ^2 n ) $.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">ll x[qwq];</span><br><span class="line"><span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">ll ak=(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">x.k=k;</span><br><span class="line">x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">y.x[i]=x*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">y.limit=x.limit;y.k=x.k;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">tmp_inv.x[i]=x.x[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">tmp_inv.k=q_inv.k=k;</span><br><span class="line">q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line"><span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line"><span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">x.limit=lim,x.k=k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">tmp_exp.k=q_exp.k=k;</span><br><span class="line">q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_exp;</span><br><span class="line">&#125;</span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3><p>集合幂级数形如$\sum _{ i = 0  } ^{ 2 ^n - 1  } a _i x ^i $,其中二进制数$i $表示$\{ 1 , 2 , . . . , n \} $的一个子集,用$| i | $表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4><p>高维前缀和:$c _i = \sum _{ j \subseteq i  } a _j \ $.</p>
<p>高维后缀和:$c _i = \sum _{ j \supseteq i  } a _j \ $.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:$c _i = \sum _{ j  } \sum _{ k  } [ j \lor k = i ] a _j b _k \ $.</p>
<p>与卷积:$c _i = \sum _{ j  } \sum _{ k  } [ j \land k = i ] a _j b _k \ $.</p>
<p>二者求法类似,考虑如何求$a $和$b $的或卷积:</p>
<p>引理:</p>
<p>若$j , k \subseteq i $,则$j \lor k \subseteq i $,逆命题同样成立.</p>
<p>若$j , k \supseteq i $,则$j \land k \supseteq i $,逆命题同样成立.</p>
<p>设$a , b , c $的高维前缀和分别为$A , B , C $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A _i B _i & = ( \sum _{ j \subseteq i  } a _j ) ( \sum _{ k \subseteq i  } b _k ) \\
& = \sum _{ j , k \subseteq i  } a _i b _k \\
& = \sum _{ k \lor j \subseteq i  } a _i b _k \\
& = C _i \\

\end{aligned}</script><p>现在考虑已知$C $求$c $,本质上是一个反演.注意到$\sum _{ r \subseteq p  } ( - 1 ) ^{ | r |  } = \sum _{ k = 0  } ^{ | p |  } C _{ | p |  } ^k ( - 1 ) ^k = [ p = 0 ] \ $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c ( p ) & = \sum _{ q \subseteq p  } [ p - q & = 0 ] c ( q ) \\
& = \sum _{ q \subseteq p  } \sum _{ r \subseteq ( p - q )  } ( - 1 ) ^{ | r |  } c ( q ) \\
& = \sum _{ r \subseteq p  } ( - 1 ) ^{ | r |  } \sum _{ q \subseteq ( p - r )  } c ( q ) \\
& = \sum _{ r \subseteq p  } ( - 1 ) ^{ r  } C ( p - r ) \\
& = \sum _{ r \subseteq p  } ( - 1 ) ^{ | p | - | r |  } C ( r ) \\

\end{aligned}</script><p>于是有$c ( S ) = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } C ( T ) \ $(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度$O ( 2 ^n n ) $.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4><p>异或卷积:$c _i = \sum _j \sum _k [ j \oplus k = i ] a _j b _k \ $.</p>
<p>引理:$( i \oplus j ) \land k = ( i \land k ) \oplus ( j \land k ) $.</p>
<p>证明的话考虑如果$k = 0 $,二者显然相等;当$k = 1 $的时候,左右都等价于$( i \oplus j ) $.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数$FWT ( a ) $,满足$FWT ( a ) _i = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } a _j \ $.</p>
<p>那么有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( c ) _i & = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } c _j \\
& = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } [ k \oplus l & = j ] a _k b _l \\
& = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | ( k \oplus l ) \land i |  } a _k b _l \\
& = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | k \land i |  } a _k ( - 1 ) ^{ | l \land i |  } b _l \\
& = FWT ( a ) _i FWT ( b ) _i \\

\end{aligned}</script><p>时间复杂度$O ( 2 ^n n ) $.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的$\frac { 1  } { 2  } $都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4><h5><span id="线性代数角度">线性代数角度</span></h5><p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换$FWT $,使得</p>
<ol>
<li><p>若$c _i = \sum _{ j \oplus k  } a _j b _k $,则$FWT ( c ) = FWT ( a ) FWT ( b ) $.</p>
</li>
<li><p>这个线性变换是可逆的.</p>
</li>
<li><p>做这个线性变换和其逆变换的复杂度都可以接受.</p>
</li>
</ol>
<p>我们设$FWT ( A ) _i = \sum _{ j  } w ( i , j ) A _j $,我们想要做的就是构造一组满足上述条件的$w $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( C ) _i & = FWT ( A ) _i FWT ( B ) _i \\
\sum _{ j  } w ( i , j ) C _j & = \sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k 
\end{aligned}</script><p>再考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C & = A * B \\
C _i & = \sum _{ k \oplus l = i  } A _k B _l \\
\sum _{ j  } w ( i , j ) C _j & = \sum _j w ( i , j ) \sum _{ k \oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k & = \sum _j w ( i , j ) \sum _{ k \oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k & = \sum _{ j , k  } A _j B _k w ( i , j \oplus k ) 
\end{aligned}</script><p>比较两边系数,有$w ( i , j ) w ( i , k ) = w ( i , j \oplus k ) $.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于$\oplus $是集合的运算,我们可以对二进制分开考虑.换句话说,如果$a = \sum _{ i = 0  } a _i 2 ^i , b = \sum _{ i = 0  } b _i 2 ^i $,那么$w ( a , b ) = \prod _{ i = 0  } w ( a _i , b _i ) $一定是满足条件的.</p>
<p>这样我们就可以只求一个$2 \times 2 $的线性变换矩阵就好.我们接下来将对三种常见的基础位运算($\lor , \land , xor ( \oplus ) $)分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出$FWT ( a ) $呢?</p>
<p>考虑和FFT一样折半,令$i _0 $为$i $的最高位是否是$1 $,$i ‘ $为$i $去掉最高位后的二进制数字,令$n = 2 ^m $我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) _i & = \sum _{ j = 0  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
& = \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i , j ) A _j + \sum _{ j = 2 ^{ m - 1  }  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
& = w ( i _0 , 0 ) \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i ' , j ' ) A _j + w ( i _0 , 1 ) \sum _{ j = 2 ^{ m - 1  }  } ^{ 2 ^m - 1  } w ( i ' , j ' ) A _j 
\end{aligned}</script><p>这样就实现了规模减半,复杂度$O ( mn ) $.</p>
<p>下面我们设FWT的变换矩阵为$\begin{bmatrix}w ( 0 , 0 ) &amp; w ( 0 , 1 ) \ w ( 1 , 0 ) &amp; w ( 1 , 1 ) \end{bmatrix} $.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6><p>取矩阵$\begin{bmatrix}1 &amp; 0 \ 1 &amp; 1 \end{bmatrix} $.其逆矩阵为$\begin{bmatrix}1 &amp; 0 \ - 1 &amp; 1 \end{bmatrix} $.</p>
<h6><span id="与卷积">与卷积</span></h6><p>取矩阵$\begin{bmatrix}1 &amp; 1 \ 0 &amp; 1 \end{bmatrix} $.其逆矩阵为$\begin{bmatrix}1 &amp; - 1 \ 0 &amp; 1 \end{bmatrix} $.</p>
<h6><span id="异或卷积">异或卷积</span></h6><p>取矩阵$\begin{bmatrix}1 &amp; 1 \ 1 &amp; - 1 \end{bmatrix} $.其逆矩阵为$\begin{bmatrix}\frac { 1  } { 2  } &amp; \frac { 1  } { 2  } \ \frac { 1  } { 2  } &amp; - \frac { 1  } { 2  } \end{bmatrix} $.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5><p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:$x ^S x ^T = x ^{ S \oplus T  } $,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) _S & = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | S \land T |  } a _T \\
IFWT ( A ) _S & = \frac { 1  } { 2 ^n  } FWT ( A ) _S 
\end{aligned}</script><p>这等价于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
[ x ^S ] FWT ( A ) & = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | S \land T |  } a _T \\
[ x ^S ] IFWT ( A ) & = [ x ^S ] \frac { 1  } { 2 ^n  } FWT ( A ) 
\end{aligned}</script><h4><span id="子集卷积">子集卷积</span></h4><p>子集卷积:$c _i = \sum _{ j  } \sum _{ k  } [ j \land k = \emptyset , j \lor k = i ] a _j b _k \ $.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些$[ j \land k \ne \emptyset ] $的答案,而$[ j \land k = \phi , j \lor k = i ] = [ | j | + | k | = | i | , j \lor k = i ] \ $.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再$n ^2 $次结合,并做IFMT,最终将结果累计,复杂度$O ( 2 ^n n ^2 ) $.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4><p>其实就是设$g _{ i , j  } = z ^i f _j $,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4><h5><span id="example1agc034f-rng-and-xor">Example1([AGC034F] RNG and XOR)</span></h5><p>设$f _i ( n ) $表示操作$n $次后第一次变成$i $的概率,$g _i ( n ) $表示操作$n $次后变成$i $的概率.$F , G $分别是其生成函数.</p>
<p>注意到$G _i = F _i G _0 , F _i = \frac { G _i  } { G _0  } $,而$F _i ‘ ( 1 ) $就是期望.接下来的问题在于如何求$G $.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把$a _i \rightarrow \frac { a _i  } { \sum a  } $,然后做$A = FWT ( a ) $,注意这里$A _0 = \sum a = 1 $,FWT自身有很好的性质:$a = \frac { 1  } { 2 ^N  } FWT ( A ) $.我们做$n $次操作后得到的概率数组也就是$\frac { 1  } { 2 ^N  } FWT ( A ^n ) $.展开FWT的式子,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _i ( n ) & = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } A _j ^n x ^n \\
G _i & = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } \frac { 1  } { 1 - A _j x  } \\
F _i & = \frac { G _i  } { G _0  } \\
F _i ' & = \frac { G _i ' G _0 - G _0 ' G _i  } { G _0 ^2  } \\
& = \frac { ( \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { 1  } { 1 - A _j x  } ) - ( \sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } \frac { 1  } { 1 - A _j x  } )  } { ( \sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { 1  } { 1 - A _j x  } ) ^2  } 
\end{aligned}</script><p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求$F ‘ _i ( 1 ) $,因此我们直接把$x = 1 $带入算一算就好.不过由于$A _0 = 1 $,我们必须要解决分母为$0 $的情况,解决的方法是分母乘上$( 1 - x ) $,这样就消掉了$j = 0 $的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5><p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边$u \leftrightarrow v $就异或上$( 2 ^u + 2 ^v ) $.最后要求这个二进制数是$0 $.我们用一个二元组$( a , F ) $表示在集合幂级数上异或上$a $,在多项式上乘上$F $.显然一条边是$( 0 , 1 ) + ( 2 ^u + 2 ^v , x ) $.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上$1 + x $要么乘上$1 - x $,做完FWT得到的每一个$FWT _i $一定形如$( 1 + x ) ^k ( 1 - x ) ^{ m - k  } $,做IFWT的时候直接求$\frac { 1  } { 2 ^N  } \sum ( 1 + x ) ^k ( 1 - x ) ^{ m - k  } $即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:$( 0 , 1 ) $和$( 2 ^u + 2 ^v , x ) $,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个$i $求$k $,也就是对于每个$i $求有多少条边满足$| i \land ( 2 ^u + 2 ^v ) | = 1 $,也就是求有多少条边一段链接在了$i $的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-c-loves-3-iii">Example3(CF1034E Little C Loves 3 III)</span></h5><p>仍然是子集卷积,转化为$c _i = \sum _{ j  } \sum _{ k  } [ | j | + | k | = | i | , j \lor k = i ] a _j b _k \ $.然后我们将$a _j $乘上$4 ^j $,将$b _k $乘上$4 ^k $,最后把$c _i $除去$4 ^i $对$4 $取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2-chiori-and-doll-picking">Example4(CF1336E2 Chiori and Doll Picking)</span></h5><p>先考虑easy version.首先求出线性基,如果线性基的大小$k $比较小,我们可以直接$2 ^k $枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个$1 $取决于选了多少个元素,其他位置共有$m - k $个,可以直接状压进状态.这样复杂度就是$O ( \min \{ 2 ^k , m ^2 2 ^{ m - k  } \} ) $.</p>
<p>那么我们怎么优化呢?首先$k $较大的时候有点难做,我们看看能不能优化到$2 ^{ m - k  } $.</p>
<p>考虑设$f _i ^c = [ | i | = c ] $,将线性基能做出的线性空间设为$A $,$A _S = 1 $当且仅当线性基能异或出$S $(最后再把那些废元素贡献到答案里).那么$popcount = c $的答案就是$IFWT ( FWT ( F ) FWT ( A ) ) _0 $.考虑$IFWT _0 = \frac { 1  } { 2 ^m  } \sum _{ i = 0  } ^{ 2 ^m - 1  } FWT ( F ) _i FWT ( A ) _i $,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:$FWT ( A ) $要么是$2 ^k $,要么是$0 $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
A * A = A \times 2 ^k</script><p>这句是为啥呢?因为对于右边的每一个数字$x $和左边的一个数字$y $,如果它们都在线性基中,一定存在一个数字$z $满足$y \oplus z = x $,不然就是$0 $.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) _i \cdot FWT ( A ) _i & = FWT ( A ) _i \times 2 ^k \\
FWT ( A ) _i & = 0 \lor 2 ^k 
\end{aligned}</script><p>引理2:$FWT ( A ) _i = 2 ^k \Leftrightarrow \forall x , A _x \ne 0 , | i \land x | \equiv 0 \pmod { 2  } $.</p>
<p>直接展开上面的式子,用$\sum _{ S \subseteq T  } ( - 1 ) ^{ | S |  } = [ T = \emptyset ] $.</p>
<p>引理3:$FWT ( A ) $中值为$2 ^k $的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果$i $满足条件,$j $满足条件,一开始做FWT时我们已经注意到:$( i \oplus j ) \land x = ( i \land x ) \oplus ( j \land x ) $.于是这个引理也显然成立.</p>
<p>引理4:$FWT ( A ) $中值为$2 ^k $的位置构成的线性基的大小是$m - k $.</p>
<p>设这些位置构成的空间是$B $,$B _S = 1 $当且仅当$S $在这个空间中.我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) & = B \times 2 ^k \\
A & = IFWT ( B ) \times 2 ^k 
\end{aligned}</script><p>注意到$a _0 = 1 $,也就是$\frac { 2 ^k  } { 2 ^m  } \sum b = 1 , \sum b = 2 ^{ m - k  } $,这就证明了引理.</p>
<p>引理5:将$A $的线性基对应的矩阵从前往后消成最简,$B $的线性基对应的矩阵从后往前消成最简,上$A $下$B $拼成一个$m \times m $的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据$rank ( A ) + rank ( B ) = k + m - k = m $可以知道主对角线一定全是$1 $,然后我们任取$A $中的一个基$x $和$B $中的一个基$y $,应该有$| x \land y | \equiv 0 \pmod { 2  } $.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由$A $得知$B $长什么样.</p>
<p>引理6:$FWT ( F ^c ) _i $只和$| i | $有关.</p>
<p>因为$F ^c _i $只和$| i | $有关,这里考虑一下对称性就可以.因此设$w _{ d  } ^c = FWT ( F ^c ) _i , | i | = d $.</p>
<p>然后注意到$w _d ^c = \sum _{ i = 0  } ^{ 2 ^m - 1  } ( - 1 ) ^{ | i \land ( 2 ^d - 1 ) |  } [ | i | = c ] $.组合意义展开一下:</p>
<script type="math/tex; mode=display">
w _d ^c = \sum _{ j = 0  } ^{ d  } ( - 1 ) ^{ j  } \binom { d  } { j  } \binom { m - d  } { c - j  }</script><p>接下来怎么做呢?令$g _d = \sum _{ i = 0  } ^{ 2 ^m - 1  } [ A _i = 1 ] [ | i | = d ] $,这里可以$O ( 2 ^{ m - k  } ) $,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5><p>首先发现”如果没有边那么是$0 $”这个限制太强了,如果我们能改为”如果是$0 $,那么可有边可无边”的话,整个序列就会被$1 $的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设$g _{ len , S  } $表示长度为$len $,一段长度为$len - 1 $的连续的$1 $对应的集合是$S $的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个$0 $).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5><p>首先可以类似数位dp设计一个$dp _{ i , S  } $表示目前dp到了第$i $位,然后前面的$limit $是$S $.接下来分类讨论当前的最大值限制是$1 $还是$0 $.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2><h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3><h4><span id="概念">概念</span></h4><p>我们定义一个幂级数形如$A ( z ) = \sum _{ k \geq 0  } a _k z ^k $,并使$[ z ^n ] A ( z ) = a _n $.则称$A ( z ) $是$\langle a _0 , a _1 , . . . \rangle $的生成函数.</p>
<h4><span id="运算">运算</span></h4><ol>
<li><p>$\alpha A ( z ) + \beta B ( z ) = \sum _{ n \geq 0  } ( \alpha f _n + \beta g _n ) z ^n $.</p>
</li>
<li><p>$z ^m A ( z ) = \sum _{ n \geq 0  } g _{ n  } z ^{ n + m  } = \sum _{ n \geq m  } g _{ n - m  } z ^n $.</p>
</li>
<li><p>$A ( cz ) = \sum _{ n \geq 0  } c ^n f _n z ^n $.</p>
</li>
<li><p>$A ‘ ( z ) = \sum _{ n \geq 1  } ig _i z ^{ i - 1  } $.</p>
</li>
<li><p>$\int A ( z ) dz = \sum _{ n \geq 0  } \cfrac { 1  } { n + 1  } g _n z ^{ n + 1  } $.</p>
</li>
<li><p>$A ( z ) B ( z ) = \sum _{ n \geq 0  } ( \sum _{ k = 0  } ^n f _k g _{ n - k  } ) z ^n $.</p>
</li>
<li><p>$\cfrac { 1  } { 1 - z  } A ( z ) = \sum _{ n \geq 0  } ( \sum _{ k = 0  } ^n g _k ) z ^n $.</p>
</li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4><ol>
<li>$\cfrac { 1  } { 1 - z  } = \sum _{ k \geq 0  } z ^k \ $,$\cfrac { 1  } { 1 - cz  } = \sum _{ k \geq 0  } c ^k z ^k \ $.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$( 1 + z ) ^r = \sum _{ k \geq 0  } \binom { r  } { k  } z ^k \ $,$( 1 - z ) ^r = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { r  } { k  } z ^k \ $.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol>
<li>$\cfrac { 1  } { 1 - z ^m  } = \sum _{ n \geq 0  } [ n | m ] z ^n \ $.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$\cfrac { 1  } { ( 1 - z ) ^{ n + 1  }  } = \sum _{ k \geq 0  } \binom { n + k  } { n  } z ^k , n \in \mathbb { N  } \ $,$\cfrac { z ^n  } { ( 1 - z ) ^{ n + 1  }  } = \sum _{ k \geq 0  } \binom { k  } { n  } z ^k , n \in \mathbb { N  } \ $</li>
</ol>
<p>直接使用二项式定理展开$( 1 - z ) ^{ - n - 1  } $,可以得到:</p>
<script type="math/tex; mode=display">
( 1 - z ) ^{ - n - 1  } = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { - n - 1  } { k  } z ^k</script><p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cfrac { 1  } { ( 1 - z ) ^2  } & = \sum _{ n \geq 0  } ( n + 1 ) z ^n \\
\cfrac { z  } { ( 1 - z ) ^2  } & = \sum _{ n \geq 0  } nz ^n 
\end{aligned}</script><p>根据$( 1 ) $求导即可得到此式.</p>
<ol>
<li><p>$e ^z = \sum _{ k \geq 0  } \cfrac { z ^k  } { k !  } \ $.</p>
</li>
<li><p>$\ln ( \cfrac { 1  } { 1 - z  } ) = \sum _{ n \geq 1  } \cfrac { 1  } { n  } z ^n $.</p>
</li>
<li><p>$\ln ( 1 + z ) = \sum _{ k \geq 0  } ( - 1 ) ^k \cfrac { z ^{ k + 1  }  } { k + 1  } \ $.</p>
</li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol>
<li>$\frac { 1 - \sqrt { 1 - 4 x  }  } { 2 x  } = \sum _{ k \geq 0  } \frac { \binom { 2 k  } { k  }  } { k + 1  } x ^k $.</li>
</ol>
<p>也即卡特兰数$C _k $的生成函数,证明考虑:</p>
<script type="math/tex; mode=display">
xC ^2 + 1 = C</script><p>然后得到两个根,带入$x = 0 $舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3><p><a href="https://zhuanlan.zhihu.com/p/53079223">https://zhuanlan.zhihu.com/p/53079223</a></p>
<p>序列$\{ a \} $的指数生成函数定义为形式幂级数$\hat F ( x ) = \sum a _n \frac { x ^n  } { n !  } $.注意$[ x ^n ] \hat F ( x ) = a _n $.</p>
<h4><span id="基本运算">基本运算</span></h4><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat F ( x ) \hat G ( x ) & = \sum _{ j \geq 0  } a _j \frac { x ^j  } { j !  } \sum _{ k \geq 0  } b _k \frac { x ^k  } { k !  } \\
& = \sum _{ k \geq 0  } x ^k \sum _{ j = 0  } ^k a _j b _{ k - j  } \frac { k !  } { j ! ( k - j ) !  } \frac { 1  } { k !  } \\
& = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } \sum _{ j = 0  } ^k a _j b _{ k - j  } \binom { k  } { j  } 
\end{aligned}</script><p>即$\lang \sum _{ i = 0  } ^n \binom { n  } { i  } a _i b _{ n - i  } \rang $的EFG.</p>
<p>注意到有一个特例是$x \hat F ( x ) $就是$\lang \binom { n  } { n - 1  } a _i \rang $的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4><ol>
<li>$e ^x = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } $</li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol>
<li>$e ^{ px  } = \sum _{ k \geq 0  } p ^k \frac { x ^k  } { k !  } $</li>
</ol>
<p>换元后可以得到.一个经典特例是$e ^{ - x  } = \sum _{ k \geq 0  } ( - 1 ) ^k \frac { x ^k  } { k !  } $.</p>
<ol>
<li>$\frac { e ^x + e ^{ - x  }  } { 2  } = \sum _{ k \geq 0  } [ 2 | k ] \frac { x ^k  } { k !  } $.</li>
</ol>
<p>显然.</p>
<ol>
<li>$( 1 + x ) ^n = \sum _{ k \geq 0  } n ^{ \underline { k  }  } \frac { x ^k  } { k !  } $.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol>
<li><p>$\ln ( 1 + x ) = \sum _{ k \geq 1  } ( - 1 ) ^{ k - 1  } ( k - 1 ) ! \frac { x ^k  } { k !  } $.</p>
</li>
<li><p>$\ln ( 1 - x ) = \sum _{ k \geq 1  } ( k - 1 ) ! \frac { x ^k  } { k !  } $.</p>
</li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4><p>我们设$F _k ( n ) $为$n $个有标号元素划分成$k $个非空无序集合的情况,$f _i $为$i $个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和$| S | $有关的定义在集合上的函数),有:</p>
<script type="math/tex; mode=display">
F _k ( n ) = \frac { n !  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a _j !  }</script><p>设$\hat { F  } ( x ) = \sum _{ n \geq 0  } f _n \frac { x ^n  } { n !  } $,再设:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat G _k ( x ) & = \sum _{ n \geq 0  } F _k ( n ) \frac { x ^n  } { n !  } \\
& = \sum _{ n \geq 0  } x ^n \frac { 1  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a _j !  } \\
& = \sum _{ n \geq 0  } \frac { 1  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  } x ^{ a _j  }  } { a _j !  } \\
& = \frac { 1  } { k !  } \hat F ^k ( x ) 
\end{aligned}</script><script type="math/tex; mode=display">
\sum _{ k \geq 0  } \hat G _k ( x ) = \exp \hat F ( x )</script><p>或者直接递推:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F _k ( x ) & = \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \frac { 1  } { k  } \\

\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\hat G _k ( x ) & = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } F _k ( n ) \\
& = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \frac { 1  } { k  } \\
& = \frac { 1  } { k  } \sum _{ n \geq 0  } \frac { x ^n  } { n !  } \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \\
& = \frac { 1  } { k  } \hat G _{ k - 1  } ( x ) \hat F ( x ) \\
& = \frac { 1  } { k !  } \hat F ^k ( x ) 
\end{aligned}</script><p>简而言之,$[ x ^n ] \hat F ( x ) $是将$n $个有标号的元素放到同一个无序集合的方案数,而$[ x ^n ] \exp \hat F ( x ) $是将$n $个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1poj3734">Example1(POJ3734)</span></h5><p>对于红黄色砖块,其选取方案为$\{ 1 , 0 , 1 , 0 , \cdots \} $,对应的EGF是$\frac { e ^x + e ^{ - x  }  } { 2  } $.</p>
<p>对于蓝绿色砖块,选取方案是$e ^x $.</p>
<p>乘起来有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat F ( x ) & = ( \frac { e ^x + e ^{ - x  }  } { 2  } ) ^2 e ^{ 2 x  } \\
& = \frac { ( e ^{ 2 x  } + 2 + e ^{ - 2 x  } ) e ^{ 2 x  }  } { 4  } \\
& = \frac { e ^{ 4 x  } + 2 e ^{ 2 x  } + 1  } { 4  } \\
& = \frac { 1  } { 4  } + \sum _{ k \geq 0  } \frac { 4 ^i + 2 ^{ i + 1  }  } { 4  } \frac { x ^i  } { i !  } 
\end{aligned}</script><p>于是有$[ x ^n ] \hat F ( x ) = 4 ^{ n - 1  } + 2 ^{ n - 1  } $.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5><p>长度为$n $的排列数的指数生成函数是$\hat P ( x ) = \sum _{ n \geq 0  } \frac { n ! x ^n  } { n !  } = \frac { 1  } { 1 - x  } $.</p>
<p>长度为$n $的圆排列的指数生成函数是$\hat Q ( x ) = \sum _{ n \geq 0  } \frac { ( n - 1 ) ! x ^n  } { n !  } = \frac { x ^n  } { n  } = - \ln ( 1 - x ) = \ln \frac { 1  } { 1 - x  } $.</p>
<p>于是有$\exp \hat Q ( x ) = \hat P ( x ) $.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5><p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为$1 $的置换环,其EGF显然是$\sum _{ n \geq 2  } \frac { x ^n  } { n  } = - \ln ( 1 - x ) - x $,错排数的EGF对其取$\exp $即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5><p>考虑如果$n $个点带编号的无向连通图的EGF是$\hat F ( x ) $,那么$n $个点带标号无向图的EGF就是$\exp \hat F ( x ) $,后者直接计数,前者对后者做一次$\ln $就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5><p>求有多少个映射$f : \{ 1 , 2 , \cdots , n \} \mapsto \{ 1 , 2 , \cdots , n \} $满足$f \circ f \circ \cdots \circ f $(共$k $个$f $)$= f \circ f \circ \cdots \circ f $(共$k - 1 $个$f $).</p>
<p>考虑将$i \rightarrow f _i $,这等价于对深度不超过$k $的基环树(环的长度为$1 $)计数,等价于对深度不超过$k $的有根树计数.注意到删去根节点后等价于对深度不超过$k - 1 $的有根树计数,因此$\hat F _k ( x ) = x \exp \hat F _{ k - 1  } ( x ) $.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5><p>假设$k $次操作后$a _i $减少了$b _i $,实际上要求的就是$\prod _{ i = 1  } ^n a _i - \prod _{ i = 1  } ^n ( a _i - b _i ) $.</p>
<p>考虑对所有情况下的$\prod _{ i = 1  } ^n ( a _i - b _i ) $求和,注意到$k $次操作,使得$i $出现$b _i $次的方案数是$\frac { k !  } { \prod _{ i = 1  } ^n b _i !  } $.直接设$a _j $的EGF是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat F _{ j  } ( x ) & = \sum _{ i \geq 0  } ( a _j - i ) \frac { x ^i  } { i !  } \\
& = \sum _{ i \geq 0  } a _j \frac { x ^i  } { i !  } - \sum _{ i \geq 1  } \frac { x ^i  } { ( i - 1 ) !  } \\
& = a _j e ^x - xe ^x & = ( a _j - x ) e ^x 
\end{aligned}</script><p>答案就是$[ x ^k ] \prod _{ j = 1  } ^n \hat F _j ( x ) $.</p>
<h5><span id="example7">Example7</span></h5><h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3><p>对于序列$f _n $,定义其DGF为$\tilde { F  } ( x ) = \sum _{ i \geq 1  } \frac { f _i  } { i ^x  } $.注意到若$f $是积性函数,那么$\tilde { F  } ( x ) = \prod _{ p \in prime  } \sum _{ i \geq 0  } \frac { f _{ p ^i  }  } { p ^{ ix  }  } \ $.</p>
<h4><span id="基本运算">基本运算</span></h4><p>对于两个序列$f , g $,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde { F  } ( x ) \tilde { G  } ( x ) & = \sum _{ i  } \sum _{ j  } \frac { f ( i ) g ( j )  } { ( ij ) ^x  } \\
& = \sum _{ i  } \frac { 1  } { i ^x  } \sum _{ d | i  } f ( d ) g ( \frac { i  } { d  } ) 
\end{aligned}</script><h4><span id="封闭式">封闭式</span></h4><ol>
<li>$\epsilon ( x ) = [ x = 1 ] $.</li>
</ol>
<p>显然为$\tilde { E  } ( x ) = 1 $.</p>
<ol>
<li>$I ( x ) = 1 $.</li>
</ol>
<p>其封闭式是黎曼函数$\zeta ( x ) $,事实上,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\zeta ( x ) & = \prod _{ i \geq 1  } \frac { 1  } { i ^x  } \\
& = \prod _{ p \in prime  } \sum _{ i \geq 0  } \frac { 1  } { p ^{ ix  }  } \\
& = \prod _{ p \in prime  } \frac { 1  } { 1 - p ^{ - x  }  } 
\end{aligned}</script><ol>
<li>$\mu ( n ) $.</li>
</ol>
<p>其DGF为$\tilde { M  } ( x ) = \prod _{ p \in prime  } ( 1 - p ^{ - x  } ) $.注意到$\zeta ( x ) \tilde { M  } ( x ) = 1 , \tilde { M  } ( x ) = \frac { 1  } { \zeta ( x )  } $.</p>
<ol>
<li>$id ( n ) = n $.</li>
</ol>
<p>有$\tilde { ID  } ( n ) = \prod _{ i \geq 1  } \frac { i  } { i ^x  } = \prod _{ i \geq 1  } \frac { 1  } { i ^{ x - 1  }  } = \zeta ( x - 1 ) $.</p>
<ol>
<li>$I _k ( n ) = n ^k $.</li>
</ol>
<script type="math/tex; mode=display">
\tilde { I _k  } ( x ) = \prod _{ i \geq 1  } \frac { 1  } { i ^{ x - k  }  } = \zeta ( x - k )</script><ol>
<li>$\varphi ( n ) $.</li>
</ol>
<p>注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde { \Phi  } ( x ) & = \prod _{ p \in prime  } ( 1 + \frac { p - 1  } { p ^x  } + \frac { p ( p - 1 )  } { p ^{ 2 x  }  } + \cdots ) \\
& = \prod _{ p \in prime  } \frac { 1 - p ^{ - x  }  } { 1 - p ^{ 1 - x  }  } \\
& = \tilde { \Phi  } ( x ) & = \frac { \zeta ( x - 1 )  } { \zeta ( x )  } 
\end{aligned}</script><p>也注意到$\tilde { \Phi  } ( x ) I ( x ) = \zeta ( x - 1 ) = \tilde { ID  } ( x ) $.</p>
<ol>
<li>$\sigma _k ( n ) = \sum _{ d | n  } d ^k $.</li>
</ol>
<p>注意到$\sigma _k ( n ) = I _k ( n ) * I _0 ( n ) $,也就是说$\tilde { S  } ( x ) = \zeta ( x - k ) \zeta ( x ) $.</p>
<ol>
<li>$u ( n ) = | \mu ( n ) | $.</li>
</ol>
<p>$\tilde { u  } ( n ) = \frac { \zeta ( n )  } { \zeta ( 2 n )  } $.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5><p>考虑对于$f ( n ) = n ^2 \varphi ( n ) $构造积性函数$g ( n ) , h ( n ) $使得$f * g = h $.</p>
<p>注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde { F  } ( x ) & = \prod _{ p \in prime  } ( 1 + \sum _{ k \geq 1  } \frac { p ^{ 3 k - 1  } ( p - 1 )  } { p ^{ kx  }  } ) \\
& = \prod _{ p \in prime  } \frac { 1 - p ^{ 2 - x  }  } { 1 - p ^{ 3 - x  }  } & = \frac { \zeta ( x - 3 )  } { \zeta ( x - 2 )  } 
\end{aligned}</script><p>也就是$f * I _2 = I _3 $.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3><p>对于复数的阶乘,我们通常定义:</p>
<script type="math/tex; mode=display">
\cfrac { 1  } { z !  } = \lim _{ n \rightarrow + \infin  } \binom { n + z  } { z  } n ^{ - z  }</script><p>同时我们定义$\Gamma ( z + 1 ) = z ! $,有:$( - z ) ! \Gamma ( z ) = \cfrac { \pi  } { \sin ( \pi z )  } $.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<script type="math/tex; mode=display">
\begin{aligned}
z ^{ \underline { w  }  } & = \cfrac { z !  } { ( z - w ) !  } \\
z ^{ \overline { w  }  } & = \cfrac { \Gamma ( z + w )  } { \Gamma ( z )  } 
\end{aligned}</script><p>通过以上我们还可以有二项式系数的定义:</p>
<script type="math/tex; mode=display">
\binom { z  } { w  } = \lim _{ \zeta \rightarrow z , \omega \rightarrow w  } \cfrac { \zeta !  } { \omega ! ( \zeta - \omega ) !  }</script><h3><span id="超几何级数">超几何级数</span></h3><h4><span id="超几何函数">超几何函数</span></h4><p>我们定义超几何函数$F ( a _1 , . . . , a _m ; b _1 , . . . b _n ; z ) = F \left ( \begin{array}{ r |  } a _1 , . . . , a _m \ b _1 , . . . , b _n \end{array} z \right ) = \sum _{ k \geq 0  } \cfrac { z ^k \prod _{ i = 1  } ^m a _i ^{ \overline { k  }  }  } { k ! \prod _{ i = 1  } ^n b _i ^{ \overline { k  }  }  } $.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$\cfrac { 0  } { 0  } = 1 $之类的式子,可以发现当$z = 0 $时任意超几何函数总是$= 1 $.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0 $或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4><h5><span id="合流超几何函数">合流超几何函数</span></h5><p>我们通常把形如$M ( a ; b ; z ) = F \left ( \begin{array}{ r |  } a \ b \end{array} z \right ) = \sum _{ k \geq 0  } \cfrac { z ^k a ^{ \overline { k  }  }  } { b ^{ \overline { k  }  } k !  } $的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<script type="math/tex; mode=display">
F \left ( \begin{array}
{ r |  } 1 \\
1 
\end{array} z \right ) = e ^z</script><p>也即常见生成函数中的$( 6 ) $.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5><p>我们把形如$F \left ( \begin{array}{ r |  } a , b \ c \end{array} z \right ) = \sum _{ k \geq 0  } \cfrac { z ^k a ^{ \overline { k  }  } b ^{ \overline { k  }  }  } { c ^{ \overline { k  }  } k !  } $的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } 1 , 1 \ 1 \end{array} z \right ) = \cfrac { 1  } { 1 - z  } $.</li>
</ol>
<p>即常见生成函数$( 1 ) $.</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } - a , 1 \ 1 \end{array} - z \right ) = ( 1 + z ) ^a $.</li>
</ol>
<p>即常见生成函数$( 2 ) $.</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } a , 1 \ 1 \end{array} z \right ) = \cfrac { 1  } { ( 1 - z ) ^a  } $.</li>
</ol>
<p>即常见生成函数$( 4 ) $.</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } 1 , 1 \ 2 \end{array} - z \right ) = \cfrac { \ln ( 1 + z )  } { z  } $.</li>
</ol>
<p>即常见生成函数$( 7 ) $.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4><p>我们先考虑改写超几何级数的形式:</p>
<p>$F \left ( \begin{array}{ r |  } a _1 , . . . , a _m \ b _1 , . . . , b _n \end{array} z \right ) = \sum _{ k \geq 0  } t _k , t _k = \cfrac { z ^k \prod _{ i = 1  } ^m a _i ^{ \overline { k  }  }  } { k ! \prod _{ i = 1  } ^n b _i ^{ \overline { k  }  }  } $.</p>
<p>不难发现$t _0 = 1 $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cfrac { t _{ k + 1  }  } { t _k  } & = \cfrac { z ^{ k + 1  }  } { z ^k  } \cfrac { k !  } { ( k + 1 ) !  } \cfrac { \prod _{ i = 1  } ^m a _i ^{ \overline { k + 1  }  }  } { \prod _{ i = 1  } ^m a _i ^{ \overline { k  }  }  } \cfrac { \prod _{ i = 1  } ^n b _i ^{ \overline { k  }  }  } { \prod _{ i = 1  } ^n b _i ^{ \overline { k + 1  }  }  } \\
& = \cfrac { \prod _{ i = 1  } ^m ( k + a _i )  } { \prod _{ i = 1  } ^n ( k + b _i )  } \cfrac { z  } { k + 1  } 
\end{aligned}</script><p>换句话说,$\cfrac { t _{ k + 1  }  } { t _k  } $是关于$k $的一个有理函数.而根据代数基本定理,任意$k $的有理函数在$\mathbb { C  } $内都可以分解为以上的形式(如果缺少$k + 1 $项则需要上下同时乘以$k + 1 $以补上).</p>
<p>换句话说,对于一个无穷级数$\sum _{ k \geq 0  } t _k $,我们先将$\cfrac { t _{ k + 1  }  } { t _k  } $表示回超几何函数,设为$F $.</p>
<p>那么有:$\sum _{ k \geq 0  } t _k = t _0 F $.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$\Gamma $函数的定义)来使这些公式全部成立.But who cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5><p>求证:$\sum _{ k \leq n  } \binom { r + k  } { k  } = \binom { r + n + 1  } { n  } \Leftrightarrow F \left ( \begin{array}{ r |  } 1 , - n \ - n - r \end{array} 1 \right ) = \cfrac { r + n + 1  } { r + 1  } , n \in \mathbb { N  } \ $.</p>
<p>首先考虑:</p>
<script type="math/tex; mode=display">
\sum _{ k \leq n  } \binom { r + k  } { k  } = \sum _{ k \geq 0  } \binom { r + n - k  } { n - k  }</script><p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<script type="math/tex; mode=display">
\binom { r + n  } { n  } F \left ( \begin{array}
{ r |  } 1 , - n \\
- n - r 
\end{array} 1 \right ) = \binom { r + n + 1  } { n  }</script><p>两边同时除以$\binom { r + n  } { n  } $得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5><p>通过范德蒙德卷积,不难验证:</p>
<script type="math/tex; mode=display">
F \left ( \begin{array}
{ r |  } a , b \\
c 
\end{array} 1 \right ) = \cfrac { \Gamma ( c - a - b ) \Gamma ( c )  } { \Gamma ( c - a ) \Gamma ( c - b )  } , - b \in \mathbb { N  }</script><p>这个公式的一个特例是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F \left ( \begin{array}
{ r |  } a , - n \\
c 
\end{array} 1 \right ) & = \cfrac { ( c - a ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  }  } & = \cfrac { ( a - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline { n  }  }  } , n \in \mathbb { N  } \\
\sum _{ k \geq 0  } \cfrac { a ^{ \overline { k  }  } ( - n ) ^{ \overline { k  }  }  } { c ^{ \overline { k  }  } k !  } & = \cfrac { ( c - a ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  }  } & = \cfrac { ( a - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline { n  }  }  } , n \in \mathbb { N  } \\

\end{aligned}</script><p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F \left ( \begin{array}
{ r |  } a , b , - n \\
c , a + b - n - c + 1 
\end{array} 1 \right ) & = \cfrac { ( c - a ) ^{ \overline { n  }  } ( c - b ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  } ( c - a - b ) ^{ \overline { n  }  }  } & = \cfrac { ( a - c ) ^{ \underline { n  }  } ( b - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline { n  }  } ( a + b - c ) ^{ \overline { n  }  }  } , n \in \mathbb { N  } \\

\end{aligned}</script><p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3><h4><span id="example1luogu4931">Example1(luogu4931)</span></h4><p>二项式反演:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans _k & = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } { k  } \binom { n  } { i  } \binom { n  } { i  } i ! ( 2 n - 2 i ) ! 2 ^i \\
& = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { k ! ( i - k ) !  } \frac { n !  } { ( n - i ) !  } \frac { n !  } { ( n - i ) !  } ( 2 n - 2 i ) ! 2 ^i \\
& = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { ( i - k ) !  } \binom { 2 n - 2 i  } { n - i  } 2 ^{ i - k  } \\
& = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  } 
\end{aligned}</script><p>注意到后者只与$n - k $有关,不妨设其为$f _{ n  } = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  } $,预处理一下就可以做到$O ( n ^2 + nT ) $.</p>
<p>加强版咋做?我们继续看看式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans & = ( n ! ) ^2 \frac { 2 ^k  } { k !  } f _{ n - k  } \\
f _{ n  } & = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  } 
\end{aligned}</script><p>注意到$f $是一个卷积的形式,设其生成函数为$F _n $,$g _n = \frac { ( - 2 ) ^n  } { n !  } , h _n = \binom { 2 n  } { n  } $,我们自然有$F = GH $.</p>
<p>考虑$G $和$H $的生成函数形式,先看$G $,显然用泰勒展开:</p>
<script type="math/tex; mode=display">
G = \sum _{ n \geq 0  } \frac { ( - 2 x ) ^n  } { n !  } = e ^{ - 2 x  }</script><p>再看$H $,是卡特兰数的生成函数,有:</p>
<script type="math/tex; mode=display">
H = \frac { 1  } { \sqrt { 1 - 4 x  }  }</script><p>这下简单了,答案是:</p>
<script type="math/tex; mode=display">
( n ! ) ^2 \frac { 2 ^k  } { k !  } [ x ^{ n - k  } ] \frac { e ^{ - 2 x  }  } { \sqrt { 1 - 4 x  }  }</script><p>现在看$F $,平方一下有:</p>
<script type="math/tex; mode=display">
( 1 - 4 x ) F ^2 = e ^{ - 4 x  }</script><p>两边求导:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F ' & = - 4 e ^{ - 4 x  } \\
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F ' & = - 4 ( 1 - 4 x ) F ^2 \\
( 2 - 8 x ) F ' & = 16 xF \\

\end{aligned}</script><p>得到了一个线性递推形式,更进一步地:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ( i + 1 ) f _{ i + 1  } - 8 if _i & = 16 f _{ i - 1  } \\
if _i & = 4 ( i - 1 ) f _{ i - 1  } + 8 f _{ i - 2  } 
\end{aligned}</script><p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3><h4><span id="求解递归关系">求解递归关系</span></h4><p>我们假设已经有了$R ( z ) = \sum _{ k \geq 0  } g _k z ^k $,并且$R ( z ) = \cfrac { P ( z )  } { Q ( z )  } $,其中$P ( z ) $和$Q ( z ) $都是多项式,我们想要找到一种方式求解$[ z ^n ] R ( z ) $.</p>
<p>考虑有理函数$S ( z ) = \sum _{ k = 1  } ^m \cfrac { a _k  } { 1 - \rho _k z  } \ $,不难发现$[ z ^n ] S ( z ) = \sum _{ k = 1  } ^m a _k \rho _k ^n \ $.</p>
<p>那么可以证明,只要$Q ( z ) = 0 $无重根并且无零根,那么就存在一组系数满足$S ( z ) = R ( z ) $.</p>
<p>我们这么定义”反射”运算,若$Q ( z ) = \sum _{ k = 0  } ^m q _k z ^k \ $,则其反射多项式为$Q ^R ( z ) = \sum _{ k = 0  } ^m q _k z ^{ m - k  } \ $.</p>
<p>若$Q ( z ) = q _0 \prod _{ k = 1  } ^m ( 1 - \rho _k z ) $,则显然有$Q ^R ( z ) = q _0 \prod _{ k = 1  } ^m ( z - \rho _k ) \ $.</p>
<p>那么显然这里求出来的这组数$\rho $就是$S ( z ) $中的那组$\rho $.</p>
<p>而我们有$a _k = \cfrac { - \rho _k P ( \cfrac { 1  } { \rho _k  } )  } { Q ‘ ( \rho _k )  } $.</p>
<h4><span id="example1">Example1</span></h4><p>已知$n ! = \sum _{ k  } \binom { n  } { k  } g _{ n - k  } , n \in \mathbb { N  } \ $,求$g _n $.</p>
<p>首先两边同时除以$n ! $并将组合数用阶乘形式展开,我们有:</p>
<script type="math/tex; mode=display">
1 = \sum _{ k  } \cfrac { g _{ n - k  }  } { k ! ( n - k ) !  } .</script><p>如果我们令$D ( z ) = \sum _{ k \geq 0  } \cfrac { g _{ k  }  } { k !  } z ^k $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cfrac { 1  } { 1 - z  } & = e ^z D ( z ) \\
D ( z ) & = \cfrac { 1  } { 1 - z  } e ^{ - z  } \\
D ( z ) & = ( \sum _{ k \geq 0  } z ^k ) ( \sum _{ k \geq 0  } ( - 1 ) ^k \cfrac { z ^k  } { k !  } ) \\
[ z ^n ] D ( z ) & = \sum _{ k = 0  } ^n \cfrac { ( - 1 ) ^k  } { k !  } 
\end{aligned}</script><p>于是$g _n = n ! \sum _{ k = 0  } ^n \cfrac { ( - 1 ) ^k  } { k !  } \ $.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4><p>首先设$F _i ( x ) $为第$i $家的生成函数,这个是显然可以快速预处理出来的.令$M = 520 $.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有$n $个多项式,最高次数是$M $,因此一共要插入$nM $个值,又要处理每个后缀,复杂度来到$O ( n ^2 M ^3 ) $.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到$O ( n ^2 M ^2 ) $.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到$O ( n ^2 Mq ) $.但$n $如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下$2 ^n $的答案,复杂度来到$O ( nM 2 ^n q ) $.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到$O ( \frac { n  } { B  } B 2 ^B MnM ) $,单次询问复杂度来到$O ( \frac { n  } { B  } Mnq ) $.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以$k $要大于$m $,就直接输出$0 $.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要$O ( ( nM ) ^2 q ) $的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到$O ( nMq ) $.</p>
<h4><span id="example3十二省联考-2019-皮配">Example3([十二省联考 2019] 皮配)</span></h4><p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为$xy , y , x , 1 $,这样最后判断幂在一个区间内的$x $和$y $前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是$\prod ( x ^{ s _i  } y ^{ s _i  } + x ^{ s _i  } ) + \prod ( y ^{ s _i  } + 1 ) = ( \prod ( x ^{ s _i  } + 1 ) ) ( \prod ( y ^{ s _i  } + 1 ) ) $.也就是$x $和$y $是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于$O ( mk ^2 s ) $.最后两部分合并一下.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>反演与容斥</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="反演">反演</span></h2><p>假设有两个函数$f $和$g $满足:$f ( n ) = \sum _{ k  } a _{ n , k  } g ( k ) $,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( S ) & = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S ) & = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
f ( S ) & = \sum _{ S \subseteq T \subseteq U  } g ( T ) \Leftrightarrow g ( S ) & = \sum _{ S \subseteq T \subseteq U  } ( - 1 ) ^{ | T | - | S |  } f ( T ) 
\end{aligned}</script><p>证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( S ) & = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
& = ( - 1 ) ^{ | S |  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | T |  } \sum _{ P \subseteq T  } g ( P ) \\
& = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T | + | P |  } \\
& = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) ( - 1 ) ^{ | P |  } \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T |  } \\
& = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) [ S & = P ] ( - 1 ) ^{ | P |  } \\
& = g ( S ) 
\end{aligned}</script><p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5><p>根据子集反演,设$cnt _S $为集合为$S $的数量,然后设$f _S = \sum _{ S ‘ \subseteq S  } cnt _{ S ‘  } $,有:$ans = \sum _{ S  } 2 ^{ f _S  } ( - 1 ) ^{ n - | S |  } $.</p>
<p>做一遍高维前缀和就好,复杂度$O ( n 2 ^n ) $,应该也可以用分治FMT无脑做到$O ( n ^2 2 ^n ) $.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5><p>设$f _{ i , j  } $表示$i $个点,其中有$j $个点的入度数为$0 $的方案数.(等一下,为撒子想到要记度数为$0 $的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这$j $个点后,还剩下$k $个零度点.于是自然有:</p>
<script type="math/tex; mode=display">
f _{ i , j  } = \binom { i  } { j  } \sum _{ k = 1  } ^{ i - j  } ( 2 ^j - 1 ) ^k 2 ^{ j ( i - j - k )  } f _{ i - j , k  }</script><p>等一下咧,这复杂度$O ( n ^3 ) $了,这咋办啊?</p>
<p>好像转移优化不太了,因为$k $很难省去(在指数上).但我们注意到我们定义的时候说:$0 $度点的数量恰好为$k $,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少$k $个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设$f ( n , S ) $表示$n $个点,其中只有$S $中的点的入度为$0 $;类似定义$g ( n , S ) $表示$n $个点,至少$S $中的点的入度为$0 $.显然我们所求也就是$g ( n , \emptyset ) $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n , S ) & = 2 ^{ | S | ( n - | S | )  } g ( n - | S | , \emptyset ) \\
g ( n , S ) & = \sum _{ S \subseteq T  } f ( n , T ) 
\end{aligned}</script><p>对第二个式子用子集反演,有:</p>
<script type="math/tex; mode=display">
f ( n , S ) = \sum _{ S \subseteq T  } ( - 1 ) ^{ | T | - | S |  } g ( n , T )</script><p>接下来使用反复带入大法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n , \emptyset ) & = \sum _{ \emptyset \ne T  } f ( n , T ) \\
& = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } g ( n , S ) \\
& = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S | , \emptyset ) \\
& = \sum _{ m = 1  } ^n \sum _{ | T | = m  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S | , \emptyset ) \\
& = \sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \\

\end{aligned}</script><p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \\
& = \sum _{ k = 1  } ^n \sum _{ m = 1  } ^k \binom { n  } { m  } \binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \\
& = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \sum _{ m = 1  } ^k \binom { k  } { m  } ( - 1 ) ^{ k - m  } \\
& = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) ( ( 1 - 1 ) ^k - ( - 1 ) ^k ) \\
& = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) ( - 1 ) ^{ k - 1  } \\

\end{aligned}</script><p>注意到复杂度已经降到$O ( n ^2 ) $了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个$( - 1 ) ^{ k - 1  } $,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _n & = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k - 1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}</script><p>也就是直接设,然后钦定其有至少$j $个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = 0  } ^n C _n ^k g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
f ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } f ( k ) \\
f ( n ) & = \sum _{ k = n  } ^N C _k ^n g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _k ^n f ( k ) \\
f ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } f ( k ) \\

\end{aligned}</script><p>显然以$( - 1 ) ^n g ( n ) $代替$g ( n ) $即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
& = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^{ n - m  } ( - 1 ) ^k C _{ n - m  } ^k C _n ^m g ( m ) \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k \sum _{ m = 0  } ^{ n - k  } C _{ n - k  } ^m g ( m ) \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k f ( n - k ) \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\

\end{aligned}</script><h5><span id="example1错排问题">Example1(错排问题)</span></h5><p>$n $个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设$f ( n ) $为$n $个人随便站的方案数,$g ( n ) $为$n $个人都站错的方案数.</p>
<p>如果知道$g $的表达式,我们可以通过枚举有多少人站错位置来得到$f $,即:$f ( n ) = \sum _{ k = 0  } ^n C _n ^k g ( k ) $.</p>
<p>显然就是一个二项式反演,$g ( n ) = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k k ! $.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:$g ( n ) = n ! \sum _{ 0 \leq k \leq n  } \cfrac { ( - 1 ) ^k  } { k !  } \ $.</p>
<p>不难发现$n ! $的后面形如$e ^{ - 1  } $的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \cfrac { n !  } { e  } - n ! \sum _{ k > n  } \cfrac { ( - 1 ) ^k  } { k !  } \\
& = \cfrac { n !  } { e  } - \cfrac { ( - 1 ) ^{ n + 1  }  } { n + 1  } \sum _{ 0 \leq k  } ( - 1 ) ^k \cfrac { ( n + 1 ) !  } { ( k + n + 1 ) !  } 
\end{aligned}</script><p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有$g ( n ) = \lfloor \cfrac { n !  } { e  } + \cfrac { 1  } { 2  } \rfloor + [ n = 0 ] $.</p>
<p>另外,观察$g $关于$f $的表达式,不难求出$g $的递推式:$g ( n ) = ng ( n - 1 ) + ( - 1 ) ^n $.</p>
<p>下面证明$g _n = ( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) $,事实上,右边等于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) \\
& = ( - 1 ) ^{ n - 1  } ( n - 1 ) + ( n - 1 ) \sum _{ k = 0  } ^{ n - 2  } ( ( n - 1 ) ! \frac { ( - 1 ) ^k  } { k !  } + ( n - 2 ) ! \frac { ( - 1 ) ^k  } { k !  } ) \\
& = n ! \sum _{ k = 0  } ^{ n - 2  } \frac { ( - 1 ) ^k  } { k !  } - ( n - 1 ) ( - 1 ) ^n \\

\end{aligned}</script><h5><span id="example2cf1750g">Example2(CF1750G)</span></h5><p>如果没有字典序限制就是经典的二项式反演:考虑能被分为$k $段,说明有$n - k $个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了$x $个数字,$y $个区间,那么钦定$j $对的方案是$\binom { x - y  } { j  } ( x - j ) ! $.然后要乘上前面已经有了的,也就是乘上形如$( 1 + z ) ^k $.这样复杂度$O ( n ^4 ) $.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的$x , y , k $有$O ( 1 ) $种不同的取值,因此不用枚举.这样就是$O ( n ^3 ) $.但是那个多项式乘法也可以规避,考虑最后的答案形如$\sum ( 1 + z ) ^k P _k ( x ) $,我们考虑写成$P _{ n - 1  } ( z ) + = ( 1 + z ) P _n ( z ) $,然后不断这么做,就只需要$O ( n ^2 ) $.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5><p>不妨设至多有$i $行$j $列最小值为$1 $的答案是$f _{ i , j  } $,恰好有$i $行$j $列最小值为$1 $的答案是$g _{ i , j  } $,注意到:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  }</script><p>令$h _{ n , m  } = \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ n , j  } \ $,则$f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } h _{ i , m  } \ $,而$f _{ n , m  } = k ^{ nm  } ( k - 1 ) ^{ NM - nm  } $.做两次二项式反演得到$g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f _{ n , m  } \ne \binom { N  } { n  } \binom { M  } { m  } k ^{ nm  } ( k - 1 ) ^{ NM - nm  } $呢?我们写成子集反演形式看看:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ S , T  } & = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  } g _{ s , t  } \\
f _{ S , T  } & = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } & = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}</script><p>做子集反演:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ S , T  } & = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S | | T |  } \\
h _{ s , T  } & = \sum _{ S \subseteq s  } ( - 1 ) ^{ | s | - | S |  } f _{ S , T  } \\
g _{ s , t  } & = \sum _{ T \subseteq t  } ( - 1 ) ^{ | t | - | T |  } h _{ s , T  } 
\end{aligned}</script><p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g _{ n , m  } $本身就包含了所有$| S | = n , | T | = m $的情况的和,并且在组合数$\binom { m  } { j  } $那里就找到了唯一确定的$f _{ s , t  } $,因此$f _{ n , m  } $是唯一确定的.这意味着这里$f $的$n , m $并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _i & = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k & = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k & = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } { k  } f _i 
\end{aligned}</script><p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  }</script><p>这个问题其实非常显然,我们的$g _{ i , j  } $定义为所有$| S | = i , | T | = j $的答案之和.$f $也是这么定义的,那这个式子就是错的,应该写成:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{ j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }</script><p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M  } $,那此时$g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _k & = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}</script><p>这个定义式就非常良性,$g $是已知的集合,$f $是未知的集合.我们乘上组合数就可以得到对于$f $来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f $的定义改成$f _{ n , m  } = k ^{ nm  } ( k - 1 ) ^{ NM - nm  } $就对了呢?</p>
<p>再看看这个式子:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  }</script><p>这个式子的右边在干这样一件事:那就是在已知$n $行$m $列的集合的前提下,从中选出$i $行$j $列并求$g $.那么你从哪知道的$n $行$m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ n , m  } & = \binom { N  } { n  } \binom { M  } { m  } \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  } \\
f _{ n , m  } & = \binom { N  } { n  } \binom { M  } { m  } k ^{ nm  } ( k - 1 ) ^{ NM - nm  } 
\end{aligned}</script><p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}</script><p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ‘ _{ i , j  } $为至少有$i $行$j $列不满足条件的方案数,自然有$f ‘ _{ i , j  } = f _{ N - i , M - j  } $.你发现此时一定有:</p>
<script type="math/tex; mode=display">
f ' _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j = m  } ^M \binom { j  } { m  } g ' _{ i , j  }</script><p>最后答案就是$g ‘ _{ 0 , 0  } $.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\
f ( n ) & = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} ( - 1 ) ^{ n - k  } f ( k ) \\
f ( m ) & = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left [ \begin{array}
{ c  } n \\
m 
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) & = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} f ( k ) \\
f ( m ) & = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left \{ \begin{array}
{ c  } n \\
m 
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) & = \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } k \\
m 
\end{array} \right ] f ( k ) \\

\end{aligned}</script><p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} ( - 1 ) ^{ n - k  } & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} \left [ \begin{array}
{ c  } k \\
m 
\end{array} \right ] ( - 1 ) ^{ n - k  } & = [ m & = n ] \\

\end{aligned}</script><p>第一个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ m = 0  } ^n [ m & = n ] g ( m ) \\
& = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( m ) \\
& = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] ( - 1 ) ^{ n - k  } \sum _{ m = 0  } ^k \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} g ( m ) & = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\

\end{aligned}</script><p>第三个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( m ) & = \sum _{ n = m  } ^M [ n & = m ] g ( n ) \\
& = \sum _{ n = m  } ^M \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( n ) \\
& = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} f ( k ) \\

\end{aligned}</script><h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ d | n  } g ( d ) \Leftrightarrow g ( n ) & = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\
f ( n ) & = \sum _{ n | d  } g ( d ) \Leftrightarrow g ( n ) & = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\
f ( x ) & = \sum _{ 1 \leq d  } g ( d ) \Leftrightarrow g ( x ) & = \sum _{ 1 \leq d  } f ( \cfrac { x  } { d  } ) \mu ( d ) 
\end{aligned}</script><p>第一个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ m | n  } [ \frac { n  } { m  } & = 1 ] g ( m ) \\
& = \sum _{ m | n  } \sum _{ d | \frac { n  } { m  }  } \mu ( d ) g ( m ) \\

\end{aligned}</script><p>注意到$[ d | \frac { n  } { m  } ] = [ md | n ] = [ m | \frac { n  } { d  } ] \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ d | n  } \mu ( d ) \sum _{ m | \frac { n  } { d  }  } g ( m ) \\
& = \sum _{ d | n  } \mu ( d ) f ( \frac { n  } { d  } ) \\
& = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\

\end{aligned}</script><p>第二个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ n | d  } [ \frac { d  } { n  } & = 1 ] g ( d ) \\
& = \sum _{ n | d  } \sum _{ c | \frac { d  } { n  }  } \mu ( c ) g ( d ) \\
& = \sum _{ c | d  } \sum _{ nc | d  } \mu ( c ) g ( d ) \\
& = \sum _{ c  } \mu ( c ) f ( nc ) \\
& = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\

\end{aligned}</script><p>第三个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 1 \leq d  } g ( \cfrac { x  } { d  } ) \mu ( d ) & = \sum _{ d \geq 1  } \mu ( d ) \sum _{ k \geq 1  } f ( \cfrac { x  } { kd  } ) \\
& = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d , k \geq 1  } [ m & = dk ] \mu ( d ) \\
& = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d | m  } \mu ( d ) \\
& = f ( x ) 
\end{aligned}</script><h4><span id="example1">Example1</span></h4><p>求长度为$n $且仅包含小写英文字母且循环节长度恰为$n $的字符串个数.</p>
<p>不妨设$f ( n ) $表示长度为$n $的字符串个数,$g ( n ) $表示长度为$n $且循环节长度恰为$n $的字符串个数.</p>
<p>有$f ( n ) = \sum _{ d | n  } g ( d ) $,根据莫比乌斯反演,$g ( n ) = \sum _{ d | n  } \mu ( \cfrac { n  } { d  } ) f ( d ) $.</p>
<h4><span id="example2">Example2</span></h4><p>求$\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) \ $.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) & = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m id [ gcd ( i , j ) ] \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  } \varphi ( d ) \\

\end{aligned}</script><h5><span id="交换枚举顺序">交换枚举顺序</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  } \varphi ( d ) & = \sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) \\

\end{aligned}</script><h5><span id="分离无关变量">分离无关变量</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) & = \sum ^{ \min ( n , m )  } _{ d = 1  } \varphi ( d ) \times \lfloor \cfrac { n  } { d  } \rfloor \times \lfloor \cfrac { m  } { d  } \rfloor \\

\end{aligned}</script><p>考虑使用数论分块,只需处理出$\varphi ( d ) $的前缀和即可在$O ( \sqrt { n  } + \sqrt { m  } ) $的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4><p>求$\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) = 1 ] \ $.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从$id $变为了$\epsilon $.</p>
<h4><span id="example4">Example4</span></h4><p>求$\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ] \ $.</p>
<p>考虑增加枚举量,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ] & = \sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m \sum _{ p \in prime  } [ gcd ( i , j ) & = p ] \\
& = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{ j = 1  } [ gcd ( pi , pj ) & = p ] \\
& = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { p  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { p  } \rfloor  } _{ j = 1  } [ gcd ( i , j ) & = 1 ] \\
& = \sum _{ p \in prime  } \sum _{ d = 1  } ^{ \min ( \lfloor \frac { m  } { p  } \rfloor , \lfloor \frac { n  } { p  } \rfloor )  } \mu ( d ) \lfloor \cfrac { n  } { pd  } \rfloor \lfloor \cfrac { m  } { pd  } \rfloor \\

\end{aligned}</script><p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5><p>考虑设$x = pd $,则变为$\sum _{ x = 1  } ^{ \min ( n , m )  } \sum _{ p \in prime \land p | x  } \mu ( \frac { x  } { p  } ) \lfloor \frac { n  } { x  } \rfloor \lfloor \frac { m  } { x  } \rfloor \ $.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4><p>首先先考虑去掉$lcm $使得式子中只有$i , j , \gcd ( i , j ) $.</p>
<p>显然可以构造函数$f ( x ) = x ^{ c - d  } , g ( x ) = x ^d , h ( x ) = x ^d \ $,然后将题目转化为$\sum _{ j = 1  } ^n f ( gcd ( i , j ) ) g ( i ) h ( j ) x _j \equiv b _i ( \mod p ) \ $.</p>
<p>$\gcd ( i , j ) $很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出$f _r ( n ) $使得$f ( n ) = \sum _{ d | n  } f _r ( d ) \ $,也即$f _r ( n ) = \sum _{ d | n  } \mu ( \cfrac { n  } { d  } ) f ( d ) $.</p>
<p>则原式即:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ j = 1  } ^n \sum _{ d  } [ d | i ] [ d | j ] f _r ( d ) g ( i ) h ( j ) x _j & \equiv b _i ( \mod p ) \\
\sum _{ d | i  } f _r ( d ) \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j & \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \\

\end{aligned}</script><p>令$z _d = \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j \ $,有$\sum _{ d | i  } f _r ( d ) z _d \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \ $.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出$z _d $.</p>
<p>而$z _d = \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j = \sum _{ d | j  } ^n h ( j ) x _j $,可以再次使用莫比乌斯反演求出$h ( j ) x _j $,进而求$x _j $.</p>
<p>无解条件显然是$g _i = 0 \land x _i \ne 0 $.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol>
<li><p>通过增加枚举量消掉$lcm $以及$\gcd $这些难以处理的项.</p>
</li>
<li><p>将$i $与$j $尽量分到式子两边.</p>
</li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p>
</li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4><p>首先注意到一个重要的事实:我们只需要询问所有$\mu ( x ) \ne 0 $的$x $,就可以得到全部信息,而这些$x $的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \bigoplus _{ i \in A  } i [ \gcd ( i , n ) & = 1 ] \\
& = \bigoplus _{ i \in A  } ^c i \sum _{ d | i , d | n  } \mu ( d ) \\

\end{aligned}</script><p>注意到$\sum _{ d | i  } \mu ( d ) = \bigoplus _{ d | i  } | \mu ( d ) | $,于是:</p>
<script type="math/tex; mode=display">
f ( n ) = \bigoplus _{ d | n  } | \mu ( d ) | \bigoplus _{ d | i , i \in A  } i</script><p>接下来只要我们形式上写作$n $,我们就默认$\mu ( n ) \ne 0 $,又令$g ( n ) = \bigoplus _{ n | i , i \in A  } i $,此时自然有$f ( n ) = \bigoplus _{ d | n  } g ( d ) \ $.这是一个经典的莫反形式,我们再反演回去就可以得到$g ( n ) = \bigoplus _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) = \bigoplus _{ d | n  } f ( d ) $,也就是说我们可以求得所有的$g ( n ) $,也就是这个集合中所有是$n $的倍数的异或值.</p>
<p>注意一个事实:如果我们设$w ( m ) = \prod _{ p \in prime , p | m  } p $,那么我们就可以按照$w $的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进$A $的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设$S ( n ) = \{ x | w ( x ) = n \} $,又设$h ( n ) = \bigoplus _{ i \in A , i \in S ( n )  } i $.考虑用$g ( n ) $表示$h ( n ) $,我们有:</p>
<script type="math/tex; mode=display">
g ( n ) = \bigoplus _{ n | d  } | \mu ( \frac { d  } { n  } ) | h ( d )</script><p>反演,有$h ( n ) = \bigoplus _{ n | d  } g ( d ) \ $.于是我们可以求得所有的$h ( n ) $了.</p>
<p>现在的问题在于:对于数$n , \mu ( n ) \ne 0 $,我们要在$S ( n ) $中选出若干个数,使得它们的异或和为$h ( n ) $,并且选出的数字总共有$| A | $个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3><p>设$S $为可重集合.</p>
<p>一般形式:定义$\mu ( S ) $,若$S $包含重复元素则为$0 $,否则为$( - 1 ) ^{ | S |  } $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( S ) & = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S ) & = \sum _{ T \subseteq S  } \mu ( S - T ) f ( T ) \\

\end{aligned}</script><p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3><p>一般形式($\omega _n = e ^{ \frac { 2 \pi i  } { n  }  } $):</p>
<script type="math/tex; mode=display">
f _m = \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ mk  } g _k \Leftrightarrow g _m = \frac { 1  } { n  } \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ - mk  } f _k</script><p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3><p>考虑莫比乌斯反演的过程,我们实际上使用的是$[ m | n ] \sum _{ d | \frac { n  } { m  }  } \mu ( d ) = [ n = m ] \ $.</p>
<p>令$c = md $,左边$= \sum _{ c | n  } [ m | c ] \mu ( \frac { c  } { m  } ) = \sum ( [ c | n ] ) ( [ m | c ] \mu ( \frac { c  } { m  } ) ) \ $.</p>
<p>令$A _{ c , n  } = [ c | n ] $,$B _{ m , c  } = [ m | c ] \mu ( \frac { c  } { m  } ) \ $,那我们有$BA = I $.</p>
<p>刚才的过程相当于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Ax & = b \\
x & = Ix \\
x & = ( BA ) x \\
x & = B ( Ax ) \\
x & = Bb \\

\end{aligned}</script><p>无论是二项式反演还是莫比乌斯反演,他们都满足$f ( n ) $所依赖的$g ( k ) $有$k \leq n \ $.</p>
<p>根据上面的情况,我们发现$A $是一个下三角矩阵,$B $是$A ^{ - 1  } $.</p>
<p>现在来推导满足$k \leq n $的一般情况反演:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = 1  } ^n a _{ n , k  } g ( k ) \\

\end{aligned}</script><p>不妨设算子$\mu ( n , m ) $,满足$\sum _{ k = 1  } ^n a _{ n , k  } \mu ( k , m ) = \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k , m  } = [ n = m ] \ $.</p>
<p>即$AB = BA = I \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ m = 1  } ^n [ n & = m ] g ( m ) \\
& = \sum _{ m = 1  } ^n \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k , m  } g ( m ) \\
& = \sum _{ k = 1  } ^n \mu ( n , k ) f ( k ) \\

\end{aligned}</script><p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c _r & = \sum _{ p , q  } [ f ( p , q ) & = r ] a _p b _q \\

\end{aligned}</script><p>而我们需要把$f $分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2><h4><span id="一般形式">一般形式</span></h4><p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:$\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . . , n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid $.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属$m $个集合$T _1 , . . . , T _m $,而除了这些集合以外的集合,</p>
<script type="math/tex; mode=display">
\begin{aligned}
cnt & = \sum _{ i = 1  } ^m ( - 1 ) ^{ i - 1  } \binom { m  } { i  } \\
& = \binom { m  } { 0  } - \sum _{ i = 0  } ^m ( - 1 ) ^i \binom { m  } { i  } \\
& = 1 - [ m & = 0 ] 
\end{aligned}</script><p>显然,当这个元素被包含的时候,贡献为$1 $,反之贡献为$0 $.</p>
<p>如果我们定义一类在集合上的函数$F ( S ) = \sum _{ p \in S  } F ( p ) $,那么自然也有:</p>
<script type="math/tex; mode=display">
F ( \bigcup _{ i = 1  } ^n S _i ) = \sum _{ T \subseteq \{ 1 , . . . , n \}  } ( - 1 ) ^{ | T | - 1  } F ( \bigcap _{ p \in T  } S _p )</script><p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<script type="math/tex; mode=display">
\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  } ^n \overline { S _i  } \mid</script><p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5><p>考虑不定方程$\sum _{ i = 1  } ^n x _i = m $,和$n $个限制条件$x _i \leq b _i $,其中$m $和$b _i $都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集$U $,以及刻画$U $中元素的$P _i $(条件):</p>
<ol>
<li><p>$U $是满足$\sum _{ i = 1  } ^n x _i = m $的所有非负整数解;</p>
</li>
<li><p>对于每个变量$i $,都对应一个$P _i = [ x _i \leq b _i ] $.</p>
</li>
</ol>
<p>设所有满足$P _i $的解构成集合$S _i $,那么我们需要求解的值就是$\mid \bigcap _{ i = 1  } ^n S _i \mid $.而$\mid U \mid $显然是$\binom { m + n - 1  } { n - 1  } $.我们有:$\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  } ^n \overline { S _i  } \mid $.考虑对$\mid \bigcup _{ i = 1  } ^n \overline { S _i  } \mid $使用容斥原理,注意到$\overline { S _i  } $的意义是满足$x _{ i  } \geq b _{ i  } + 1 $的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5><p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集$U $,以及刻画$U $中元素的$P _i $(条件):</p>
<ol>
<li><p>$U $是长度为$n $的所有排列;</p>
</li>
<li><p>对于每个变量$i $,都对应一个$P _i = [ p _i \ne i ] $.</p>
</li>
</ol>
<p>注意到所求仍然是$\mid \bigcap _{ i = 1  } ^n S _i \mid $.于是我们仍然试图$| \bigcap _{ k = 1  } ^m \overline { S _{ a _k  }  } | $.考虑其意义,也即:有$m $个位置被确定了,而其它位置没有限制,于是$| \bigcap _{ k = 1  } ^m \overline { S _{ a _k  }  } | = \binom { n  } { m  } ( n - m ) ! $.根据容斥,自然有:$d _n = n ! - \sum _{ m = 1  } ^n ( - 1 ) ^{ m - 1  } \binom { n  } { m  } ( n - m ) ! = n ! \sum _{ m = 0  } ^n \cfrac { ( - 1 ) ^m  } { m !  } $.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5><p>首先可以用dp+双指针得到$f _i $表示勒令$i $对满足条件的方案数.把$k $的定义改为恰好$k $对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U $,以及刻画$U $中元素的$P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a $对的方案会被恰好$b $对的方案计算$\binom { b  } { a  } $次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为$k $的方案贡献为$1 $,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为$k + 1 $的方案贡献为$0 $,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令$ans = f _k $,第二步除去其中被多算的$k + 1 $,这一步令$ans - = \binom { k + 1  } { k  } f _{ k + 1  } $.这个时候,我们再考虑$k + 2 $的贡献:它将在$f _k $时贡献$\binom { k + 2  } { k  } $次,在$f _{ k + 1  } $时贡献$- \binom { k + 2  } { k + 1  } \binom { k + 1  } { k  } = - \binom { k + 2  } { k  } \binom { 2  } { 1  } $次,那它现在的贡献还有:$- \binom { k + 2  } { k  } $次.以此类推,可以得到$ans = \sum _{ i = k  } ^n f _i ( - 1 ) ^{ i - k  } \binom { i  } { k  } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P _i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i $,因为只有这个时候,我们才能通过分析满不满足$P _i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1 / 0 $就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5><p>如果直接对于每次询问暴力做,复杂度显然是$O ( 4 ns ) $,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画$P _i = [ use _i \leq d _i ] $,从而可以用容斥做.复杂度$O ( 4 m + n 2 ^4 ) $.</p>
<h5><span id="example5">Example5</span></h5><p>Alice和Bob在玩游戏,他们有一个$n $个点的无向完全图,设所有的边组成了集合$E $,他们想取遍$E $的所有非空子集,对某个集合$S $有一个估价$f ( S ) $:考虑$n $个点与$S $中的边组成的图,我们用$m $种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么$f ( S ) $等于这个图的染色方案数.同时,Alice喜欢奇数,所以当$| S | $为奇数时,Alice的分值加上$f ( S ) $,否则Alice的分值减去$f ( S ) $,求最后的分值.$( n , m \leq 10 ^6 ) $.</p>
<p>一开始抄题的时候没有写染色而是直接写”设$k $为连通块个数,则$f ( S ) = m ^k $.”然后发现做不了,因为$| S | $相同的$f ( S ) $不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个$m $,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那$x \leftrightarrow y \Rightarrow col _x = col _y $.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与$- 1 $有关的单位元素(从一开始就是点)和与$f $有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令$F ( C ) $表示在$C $情况下的染色方案,$T _{ ( i , j )  } $表示满足边$( i , j ) $限制的解集:</p>
<script type="math/tex; mode=display">
ans = \sum _{ \emptyset \ne S \subseteq E  } ( - 1 ) ^{ | S | - 1  } F ( \bigcap _{ ( i , j ) \in S  } T _{ ( i , j )  } )</script><p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出$ans $的意义:显然是$F ( \bigcup _{ i = 1  } ^{ m  } P _i ) $.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是$m ^n - m ^{ \underline { n  }  } $.</p>
<h5><span id="example6">Example6</span></h5><p>求$\varphi ( n ) $.</p>
<p>考虑这么一个事实:假设$n = \prod p _i ^{ q _i  } $,注意到令$P _i = [ \gcd ( i , n ) = 1 ] $,我们所求也就是$\mid \bigcap _{ i = 1  } ^n S _i \mid $.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5><p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如$ABCABCAB . . . $这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于$3 $并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5><p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的$1 $,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是$\sum _{ i = 0  } ^{ \min ( n , m )  } ( - 1 ) ^i \binom { n  } { i  } \binom { m  } { i  } i ! ( m + 1 ) ^{ n - i  } ( n + 1 ) ^{ m - i  } $.</p>
<h5><span id="example9">Example9</span></h5><p>给定若干个限制条件$( x , y ) $,表示$a _x = y $和$a _y = x $必须满足至少一个,求排列方案数.</p>
<p>首先$i \rightarrow p _i $把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为$2 $的链,它自己成环的话是不用$\times 2 $的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是$\times 2 $,所以一个有$1 $个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为$2 $的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-square-constraints">Example10([AGC036F] Square Constraints)</span></h5><p>由题意得:$n ^2 - i ^2 \leq P _i ^2 \leq ( 2 n ) ^2 - i ^2 $.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为$l _i $,那么只有上界的答案应该是什么呢?将$l $从小到大排序,答案就是$\prod _{ i = 0  } ^{ 2 n - 1  } ( l _i - i ) $.(注意到必须满足$l _{ 2 n - 1  } = 2 n - 1 $.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个$\frac { 1  } { 4  } $的圆弧.而通过圆弧的性质不难看出:最终的$l $分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道$l $按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照$l $的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度$O ( n ^3 ) $.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5><p>(下面将$n $和$m $反着写)</p>
<p>设$p = \frac { 2 k  } { n  } , q = n - p $.</p>
<p>首先注意到期望$= P [ len \geq 1 ] + P [ len \geq 2 ] + \cdots $.</p>
<p>考虑如何计算$P [ len \geq x ] $,如果我们设$a _i $表示以$i $作为开头的极长的带劲的长度大于等于$x $的序列的集合,那么最后无非是要求所有$a $的并.考虑用容斥做到求所有$a $的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5><p>给定$n , k $和$n $个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过$k $.$n \leq 300 $.</p>
<p>著名结论:$n $个点$m $个连通块任意连边成树的方案数是$n ^{ m - 2  } \prod s $,其中$s $是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过$k $,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于$k $的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过$k $,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数$( - 1 ) ^{ 块 数 - 1  } $.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4><p>对于:</p>
<script type="math/tex; mode=display">
\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . . , n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid</script><p>考虑一个特例:$S _i = \{ 1 , 2 , \cdots , a _i \} $,那么上面的式子导出min-max容斥(我们设$S = \{ a _1 , a _2 , \cdots , a _n \} $)(第二个式子可以把前缀改成后缀):</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max ( S ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } \min ( T ) \\
\min ( S ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } \max ( T ) 
\end{aligned}</script><p>由于是集合,这个式子在期望意义下同样成立:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( \max \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E ( \max \{ S \} ) 
\end{aligned}</script><p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<script type="math/tex; mode=display">
\begin{aligned}
kth \max \{ S \} & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \min \{ T \} \\
kth \min \{ S \} & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \max \{ T \} \\
E ( kth \max \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E ( \min \{ T \} ) \\
E ( kth \min \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E ( \max \{ T \} ) 
\end{aligned}</script><p>原理是消掉前$k - 1 $大的数字,让他们的贡献为$0 $,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5><p>不妨设$tim _i $为$[ i , i + 1 ] $第一次被覆盖的时间,答案就是:</p>
<script type="math/tex; mode=display">
E ( \max _{ i = 1  } ^{ n - 1  } \{ tim _i \} ) = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E ( \min _{ j \in T  } \{ tim _j \} )</script><p>设$f ( S ) $为有多少个区间能覆盖至少一个$[ i , i + 1 ] , i \in S $,考虑$E = p _{ [ t \geq 0 ]  } + p _{ [ t \geq 1 ]  } + p _{ [ t \geq 2 ]  } + \cdots $,于是$E ( \min _{ j \in S  } \{ tim _j \} ) = \frac { m  } { f ( S )  } $.</p>
<p>于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans & = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } f ( T ) \\
& = \sum _{ k = 0  } ^m \frac { m  } { k  } \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k  } ( - 1 ) ^{ | T | - 1  } 
\end{aligned}</script><p>注意到$f ( S ) $可能不那么好求,我们求$g ( S ) = m - f ( S ) $,也就是不包含任何一个$[ i , i + 1 ] , i \in S $的区间个数,我们有:</p>
<script type="math/tex; mode=display">
ans = \sum _{ k = 0  } ^m \frac { m  } { m - k  } \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k  } ( - 1 ) ^{ | T | - 1  }</script><p>这里已经不难写出$O ( n ^3 ) $的dp了.</p>
<p>那么怎么优化呢?设$dp _{ i , j  } $表示只考虑$[ 1 , i ] $时($[ i - 1 , i ] $必选),$\sum _{ g ( T ) = j  } ( - 1 ) ^{ | T | - 1  } $的答案,不难发现每次加入一个区间$[ l , r ] $就会让$dp _{ i , j  } , i &lt; = l $对$dp _{ r , j + 1  } $的贡献乘一个$1 $.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度$O ( nm \log n ) $.</p>
<h4><span id="反射容斥">反射容斥</span></h4><p>一般形式:给定二维平面上两个点$S $和$T $,其中$T $在$S $的右方,给定两条线$y = a $和$y = b $,每次可以向右上或者右下走一步,求不碰线的从$S $到$T $的方案数.</p>
<p>我们不妨设$A $表示一定碰了一次上界的方案数,$B $表示一定碰了一次下界的方案数,$AB $表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走$- A - B + AB + BA - ABA - BAB . . . $.</p>
<p>考虑设步数为$n $,那显然长度最多为$\cfrac { n  } { a - b  } $.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3><p>$A $和$B $,有$n $颗石子,每次可以取$x $颗,其中$1 \leq x \leq m \ $,求$A $是否能赢.</p>
<p>考虑直接令石子数量为状态,有$SG ( x ) = mex \{ SG ( y ) | \max \{ 0 , x - m \} \leq y \leq x - 1 \} \ $,注意到$SG ( x ) = 0 $当且仅当$x \equiv 0 ( \mod m + 1 ) $.</p>
<p>我们使用数学归纳证明:</p>
<p>当$0 \leq x \leq m $时,显然成立.</p>
<p>而对于$x $,如果$x \equiv 0 ( \mod m + 1 ) \ $,那么集合$S = \{ y \in \mathbb { Z  } | \max \{ 0 , x - m \} \leq y \leq x - 1 \} $中一定$\nexists y $满足$y \equiv 0 ( \mod m + 1 ) \ $.</p>
<p>也就是$\nexists y $满足$SG ( y ) = 0 $,那么$SG ( n ) = 0 $.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3><p>$A $和$B $,有$n $堆石子,第$i $堆石子有$x _i $个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果$x $均等于$0 $一定先手必败.考虑令$w = x _1 \oplus x _2 \oplus . . . \oplus x _n $($w $即为全游戏的$SG $值),那么先手必败当且仅当$w = 0 \ $.</p>
<p>证明:</p>
<p>只需证明当$w \ne 0 $时一定存在一种方法使得$w = 0 \ $.</p>
<p>考虑$w $的最高位为第$k $位,那么一定存在一个$x _i $的第$k $位为$1 $.将它改为$0 $,然后这个$x _i $的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4><p>$A $和$B $,有$n $堆石子,第$i $堆石子有$x _i $个石子.每次可以任选不超过$k $堆取走若干个石子,最后不能取的人输.</p>
<p>将$x _i $写成二进制,如果每一位的$1 $的个数均是$k + 1 $的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4><p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于$2 $的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p>$SG ( x ) = mex \{ \{ SG ( v ) | x \rightarrow v \} , \{ SG ( x - i ) \oplus SG ( i ) | 1 \leq i &lt; x \} \} \ $.</p>
<p>找一下规律可以发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
SG ( x ) & = \begin{cases}
x - 1 & x \equiv 0 ( \mod 4 ) \\
x & x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 & x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}</script><p>不妨设当$x \leq 4 k $时结论成立.</p>
<p>当$x = 4 k + 1 $时,前半部分一定是取遍了$[ 1 , 4 k ] $.</p>
<p>但是一定不存在$a $和$b $满足$a + b = 4 k + 1 $并且$SG ( a ) \oplus SG ( b ) = 4 k + 1 $.讨论一下$a $和$b $在$\mod 4 $意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3><p>$n $个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.$A $和$B $每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用$SG ( u ) = mex \{ SG ( v ) | u \rightarrow v \} $.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是$0 $.</p>
<p>首先如果$SG ( u ) = x $,那么$\forall 0 \leq y &lt; x $,$\exists v $使得$u \rightarrow v $且$SG ( v ) = y $.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能$\exists y &gt; x $,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个$u ‘ $使得$SG ( u ‘ ) = x $,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4><p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol>
<li><p>游戏的SG函数不为$0 $且游戏中某个单一游戏的SG函数大于$1 $.</p>
</li>
<li><p>游戏的SG函数为$0 $且游戏中没有单一游戏的SG函数大于$1 $.</p>
</li>
</ol>
<p>如果没有单一游戏的SG函数大于$1 $,那么显然游戏的SG函数为$0 $就赢了,否则就输了.</p>
<p>而如果SG函数为$0 $且存在某个单一游戏的SG函数大于$1 $,一定是输的.</p>
<p>因为这个情况下,后手先按照正常$SG $游戏压着先手,最后一定会剩两堆一样大于$1 $的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4><p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在$DAG $上dp的时候除了$SG $我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4><p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4><p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:$SG ( u ) = \bigoplus _{ u \rightarrow v  } ( SG ( v ) + 1 ) $.</p>
<p>考虑归纳假设.如果$u $只有$v $一个儿子.那么要么将$v $子树全删,要么删一部分,有:</p>
<script type="math/tex; mode=display">
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 < SG ( v ) ) = SG ( v ) + 1</script><p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的$SG $为$0 $,而显然$SG $图中的其它节点的$SG $均要$+ 1 $.</p>
<h4><span id="example4">Example4</span></h4><p>$n $个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环$SG = 1 $,偶环$SG = 0 $.</p>
<p>这么考虑:边数为$k $的链的$SG $为$k $.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到$1 $.偶环同理,不可能得到$0 $.</p>
<h4><span id="example5">Example5</span></h4><p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,$SG $值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3><p>一个数$N $,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当$N $是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当$N $是斐波那契数时必败,不妨假设$N = N _0 + N _1 $,</p>
<p>考虑将$N $看成两堆,因为如果第一次取走了大于$N _1 $颗石子,由于$N _0 \leq N _1 \ $,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在$N _0 $堆取石子,原因是如果取了大于$N _0 $颗石子,由于$N = N _0 + N _1 \leq 3 N _0 \ $.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取$N _0 $这一堆,如果在这一堆取的过程中,先手一直取得不超过$N _0 $剩下的数,那么根据归纳假设,后手一定可以取走$N _0 $堆的最后一个石子,此时局面变成了只剩$N _1 $颗石子.只要此时先手不能一次取走$N _1 $颗石子,先手就必败.而后手最后一步拿走石子最多会拿走$\frac { 2  } { 3  } N _0 $的石子,但是,$\frac { 4  } { 3  } N _0 &lt; N _1 $,因此一定不可能.</p>
<p>否则,仍然是先手取走了$N _0 $全部石子,又当了先手取$N _1 $的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设$N = \sum _{ i = 1  } ^k f _{ p _i  } $,其中$p _1 &lt; p _2 &lt; p _3 &lt; . . . &lt; p _k \ $,先手取走$f _{ p _1  } \ $.由于$2 f _{ p _1  } &lt; f _{ p _2  } $,因此后手接下来无论如何不可能取得大于等于$f _{ p _2  } \ $,问题转化为一堆大小为$f _{ p _2  } $的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3><p>给出一张二分图和起点$S $,$A $和$B $轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点$S $,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含$S $,那么$A $只需要每次走到一个和$S $匹配的点即可.$B $无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含$S $的点,与假设不符.</p>
<p>而如果存在一个匹配不包含$S $,如果$A $仍然第一步走到一个和$S $匹配的点那么$B $一定能想办法走到一个不在当前$A $选择的最大匹配中的点而在一个不包含$S $的最大匹配中的点,于是$B $必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4><p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设$dp _{ S , x  } = 0 / 1 $表示目前集合$S $中的所有人都已经离场了,而目前金条在$x $手中,金条会不会被抢.显然,如果$\exists y $满足$dp _{ S \cup \{ x \} , y  } = 0 $,也就是金条在$y $手里不会被抢,那$x $手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与$S $匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果$S $和$x $并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断$S $是否一定在其中,只需要先删去$S $,跑dinic,再在残联网络上加上$S $,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3><h4><span id="example1zr23省选10连-day1-clashmas">Example1(zr[23省选10连 day1] Clashmas)</span></h4><p>注意到删点对树形态的影响,考虑重心</p>
<ol>
<li>$n $为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol>
<li>$n $为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时$n $为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为$S _A $,B的点的集合为$S _B $.以原重心为根建树,设其所有儿子组成的集合为$S _C $,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当$\sum _{ u \in S _A \cap S _C  } siz _u \geq \sum _{ u \in S _B \cap S _C  } siz _u $.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中$siz $最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol>
<li>$n $为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时$n $为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol>
<li>$n $为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol>
<li>$n $为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3><h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5><p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设$f _i $为还剩$i $条蛇的时候能不能吃,那$f _i = 1 $的话,要么$i = 2 $,要么吃完后不是最小的,要么$f _{ i - 1  } = 0 $.</p>
<p>递归做就好了.另外这题需要复杂度$O ( n ) $,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5><p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5><p>首先考虑如果有人作为第$n - p + 1 $个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读$n - p $个人.</p>
<p>继续思考,如果有人作为第$n - 2 p + 1 $个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有$n \mod p $个人复读,并且一定是前$n \mod p $在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5><p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录$f _{ i , j  } $表示当前的$G $是$i $,$G $的倍数还剩下$j $个,然后做转移,再进一步发现我们只关心$j $的奇偶性.于是记$f _{ i , 0 / 1  } $即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5><p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在$[ l _i , r _i ] $,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为$0 $.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为$0 $.</p>
<p>换句话说,我们现在有$x _1 , x _2 , x _3 $,我们要将其中一个$x _i $改为$y _i $,其他不变,使得他们仨异或值为$0 $.和Nim游戏类似,假设他们仨异或值的最高位为$k $.那么一定有一个$x _i $的第$k $位为$1 $,将它改为$0 $,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的$[ l _i , r _i ] $求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5><p>Nim游戏,但是每堆石子有一个$K _i $.如果这堆石子剩$x _i $个每次最多取$\lfloor \frac { x _i  } { K _i  } \rfloor $个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-\lfloor\frac n k\rfloor,k)&amp;n\ne 0(\mod k)\\</p>
<p>\frac n k&amp;n=0(\mod k)\\</p>
<p>\end{cases}\\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于$k $是否大于$\sqrt { n  } $讨论一下,如果$k &lt; \sqrt { n  } $暴力,最多只会做$\sqrt { n  } $次.否则,意识到此时可以通过求一个区间$[ l , r ] $,满足$\forall x \in [ l , r ] , \lfloor \frac { x  } { k  } \rfloor $均相等,加速一下.这种区间最多只会有$\sqrt { n  } $个.</p>
<h5><span id="problem7">Problem7</span></h5><p>一个数$N $,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当$N = 2 ^k $,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5><p>A和B,有$n $颗石子,每次可以取$x $颗,其中$1 \leq x \leq \lceil \frac { n  } { 2  } \rceil \ $.</p>
<p>仍然令石子数量为状态,注意到$SG ( x ) = 0 $当且仅当$x + 1 = 2 ^k - 1 $,也即$x = 2 ^k - 2 \ $.首先,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n - \lceil \frac { n  } { 2  } \rceil & = \lfloor \frac { n  } { 2  } \rfloor \\
SG ( n ) & = mex \{ SG ( y ) | \lfloor \frac { n  } { 2  } \rfloor & \leq y & \leq n - 1 \} \\

\end{aligned}</script><p>设$n = 2 ^k - w $,其中:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- 2 ^{ k - 1  } + 2 & \leq w & \leq 2 \\
\lfloor \frac { 2 ^k - w  } { 2  } \rfloor & = 2 ^{ k - 1  } - \lfloor \frac { w  } { 2  } \rfloor \\

\end{aligned}</script><p>当$w = 2 $时,原式$= 2 ^{ k - 1  } - 1 &gt; 2 ^{ k - 1  } - 2 \ $.反之.$2 ^k - 2 \leq $原式.因此数学归纳即可证明.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>北大相关选拔数学真题汇总</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3><h4><span id="problem4">Problem4</span></h4><p>设$G ( x ) = ( x ^2 + x - 1 ) ^{ 100  } = \sum _{ k = 0  } ^{ 200  } a _k x ^k $,求$2 a _0 - a _1 - a _2 + 2 a _3 - a _4 - a _5 + \cdots + 2 a _{ 198  } - a _{ 199  } - a _{ 200  } $.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑求出$\sum _{ 0 \leq k \leq 66  } { a _{ 3 k  }  } $.直接取三次单位根$\omega _3 = - \frac { 1  } { 2  } + \frac { \sqrt { 3  }  } { 2  } i $,自然有$1 + \omega _3 + \omega _3 ^2 = 0 $,所以$G ( 1 ) + G ( \omega _3 ) + G ( \omega _3 ^2 ) = 3 \sum _{ 0 \leq k \leq 66  } { a _{ 3 k  }  } $.</p>
<p>所以答案显然是$G ( \omega _3 ) + G ( \omega _3 ^2 ) = ( - 2 ) ^{ 100  } + ( - 2 ) ^{ 100  } = 2 ^{ 101  } $.</p>
<h4><span id="problem10">Problem10</span></h4><p>等差数列中,$a _1 &gt; 0 $,公差$d &lt; 0 , \frac { a _{ 31  }  } { a _{ 30  }  } &lt; - 1 $,求最大的正整数$n $,使得$S _n &gt; 0 $.</p>
<h5><span id="solution10">Solution10</span></h5><p>显然$S _{ 60  } = 30 ( a _{ 30  } + a _{ 31  } ) &lt; 0 , S _{ 59  } = 59 a _{ 30  } &gt; 0 $.</p>
<h4><span id="problem11">Problem11</span></h4><p>全为整数的等差数列,$d = 4 $,求所有满足$S _n = 2024 $的$n $的和.</p>
<h5><span id="solution11">Solution11</span></h5><p>则$n ( 2 n - 2 + a _1 ) = 2024 = 2 ^3 \times 11 \times 23 $.显然只要$n | 2024 $即可.</p>
<p>所有$n $的和自然是$( 1 + 2 + 4 + 8 ) ( 1 + 11 ) ( 1 + 23 ) = 15 \times 12 \times 24 = 4320 $.</p>
<h4><span id="problem14">Problem14</span></h4><p>整数数列$U _n $满足$U _0 = 1 $,且当$n \geq 1 $的时候$U _{ n + 1  } U _{ n - 1  } = kU _n $,其中$k $是一个正整数.问能让$U _{ N  } = N $的$k $的个数有多少个,其中$N = 2024 $.</p>
<h5><span id="solution14">Solution14</span></h5><p>则$U _{ n + 1  } = \frac { kU _n  } { U _{ n - 1  }  } , \frac { U _{ n + 1  }  } { U _n  } = k \frac { U _n  } { U _{ n - 1  }  } \frac { 1  } { U _n  } $.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设$T _n = \prod _{ k = 1  } ^n U _k , W _n = U _n \prod _{ k = 1  } ^{ n - 2  } U _k $.</p>
<p>注意到$W _n = kW _{ n - 1  } , W _1 = U _1 , W _n = k ^{ n - 1  } U _1 $.又注意到$T _n = kU _{ n - 1  } W _{ n - 1  } = kW _{ n - 1  } \frac { T _{ n - 1  }  } { T _{ n - 2  }  } = k ^{ n - 1  } U _1 \frac { T _{ n - 1  }  } { T _{ n - 2  }  } = ( k ^{ n - 1  } U _1 ) ( k ^{ n - 2  } U _1 ) \frac { 1  } { T _{ n - 3  }  } $,$T _{ n - 3  } = ( k ^{ n - 4  } U _1 ) ( k ^{ n - 5  } U _1 ) \frac { 1  } { T _{ n - 6  }  } $.所以$T _{ n  } = k ^6 T _{ n - 6  } $,所以$U $存在长度为$6 $的循环节.所以$U _{ N  } = \frac { T _N  } { T _{ N - 1  }  } = \frac { T _2  } { T _1  } = U _2 = kU _1 $.(其实直接暴力找循环节也是可以的)</p>
<p>所以$k $需要是$N $的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设$w = U _1 $,则$U $的前六项是:$1 , w , kw , k ^2 , \frac { k ^2  } { w  } , \frac { k  } { w  } $.要求$kw = N , w | k $,所以$( 11 \times 23 ) | k $,$k \equiv 0 \pmod { 4  } $.所以$k = 4 \times 11 \times 23 $或$k = 8 \times 11 \times 23 $.</p>
<h4><span id="problem15">Problem15</span></h4><p>求使方程$\lfloor \frac { 10 ^n  } { x  } \rfloor = N = 2024 $恰有两个整数解的正整数$n $的个数.</p>
<h5><span id="solution15">Solution15</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N & \leq \frac { 10 ^n  } { x  } & < N + 1 \\
xN & \leq 10 ^n & < x ( N + 1 ) \\
\frac { 10 ^n  } { N + 1  } & < x & \leq \frac { 10 ^n  } { N  } \\
\lfloor \frac { 10 ^n  } { N + 1  } \rfloor & < x & \leq \lfloor \frac { 10 ^n  } { N  } \rfloor \\
\lfloor \frac { 10 ^n  } { N  } \rfloor - \lfloor \frac { 10 ^n  } { N + 1  } \rfloor & = 2 \\
\frac { 10 ^n  } { N ( N + 1 )  } - \frac { 10 ^n \bmod N  } { N  } + \frac { 10 ^n \bmod { ( N + 1 )  }  } { N + 1  } & = 2 
\end{aligned}</script><p>显然$\lfloor \frac { 10 ^n  } { N ( N + 1 )  } \rfloor = 1 , 2 , 3 $.而$N ( N + 1 ) = 4098600 $,所以只有$n = 7 $可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4><p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5><p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是$5 \times 3 ! = 30 $.</p>
<h4><span id="problem19">Problem19</span></h4><p>$f ( x ) = \lfloor 2 x \rfloor + \lfloor 4 x \rfloor + \lfloor 6 x \rfloor + \lfloor 8 x \rfloor , x \in \mathbb { R  } $,求其不超过$n = 2024 $的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5><p>显然$f ( x + 1 ) = f ( x ) + 20 $,因此我们先考虑$x \in [ 0 , 1 ) $的情况.</p>
<p>手动枚举一下知道此时$f ( x ) $有$12 $种不同的取值,前六种是$\{ 0 , 1 , 2 , 4 , 5 , 6 \} $,后六种对应了前六种$+ 10 $.而$2024 = 101 \times 20 + 4 $,所以共有$101 \times 12 - 1 + 4 = 1215 $种取值.</p>
<h4><span id="problem20">Problem20</span></h4><p>从$[ 1 , n ] , n = 2024 $中分别独立随机两个正整数(可以相同)$a , b $,则求$3 ^a + 7 ^b \equiv 8 \pmod { 10  } $的概率.</p>
<h5><span id="solution20">Solution20</span></h5><p>考虑$\varphi ( 10 ) = 4 $,所以原题答案等价于$n = 4 $的时候的答案.在这$16 $中可能性中满足条件的只有三种,概率为$\frac { 3  } { 16  } $.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3><h4><span id="problem3">Problem3</span></h4><p>已知$a _1 = \frac { 5  } { 2  } , a _{ n + 1  } = a _n ^2 - 2 $,求$\lfloor a _n \rfloor \bmod 7 , n = 2023 $.</p>
<h5><span id="solution3">Solution3</span></h5><p>这个一看就不是好解的,想都别想直接数学归纳,注意到$a _n = \frac { 4 ^{ 2 ^{ n - 1  }  } + 1  } { 2 ^{ 2 ^{ n - 1  }  }  } $,那么$\lfloor a _n \rfloor = 2 ^{ 2 ^{ n - 1  }  } $.</p>
<p>而$\varphi ( 7 ) = 6 , \varphi ( 6 ) = 2 $.由扩展欧拉定理,立刻有:$2 ^{ 2 ^{ 2022  }  } \equiv 2 ^{ 2 ^{ 2022  } \bmod 6  } \equiv 2 ^{ 2 ^{ 6  }  } \equiv 16 \equiv 2 \pmod { 7  } $.</p>
<h4><span id="problem4">Problem4</span></h4><p>$50 $个队伍两两打比赛,胜一场积分$+ 1 $,负一场积分不变,无平局.</p>
<p>且任取$27 $支队伍,其中一定有一支队伍负于其它的$26 $支,也一定有一支队伍胜于其它的$26 $支.</p>
<p>问$50 $支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5><p>答案是$50 $.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都$\leq 27 $的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都$&gt; 27 $,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为$k $的简单环,由鸽笼原理,剩下的$n - k $个点中至少有$\frac { n - k  } { 2  } $个点对着$k $个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要$k + \frac { n - k  } { 2  } \geq 27 $即可,此时$k \geq 4 $即可.由于这是竞赛图,显然存在长度为$4 $的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为$u $.我们任意取一个击败过它的点(如果有的话),假设为$v $,再取$25 $个被$u $击败的点(显然这些点存在),设这些点集为$S $.则$u , v , S $组成的集合中,有一个点可以击败其它所有点,根据假设,只能是$v $.由此,可以知道,只要是$u $能击败的点,$v $一定能击败,而且$v $能击败$u $,因此$\deg _v &gt; \deg _u $,与假设不符.因此一定不存在一个$v $可以击败$u $.删掉$u $后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4><p>一只蚂蚁第一天在$( 0 , 0 ) $,第$k + 1 $天向上下左右随机一个方向移动$\frac { 1  } { 4 ^k  } $单位,求第$n $天的可能位置数量,$n = 2023 $.</p>
<h5><span id="solution8">Solution8</span></h5><p>不妨设第$n $天不同位置数量为$S _n $,显然只要前面岔开了,后面永远无法走到一个点.所以$S _1 = 1 , S _{ n + 1  } = 4 S _n , S _{ 2023  } = 4 ^{ 2022  } $.</p>
<h4><span id="problem10">Problem10</span></h4><p>集合$U = \{ 1 , 2 , \cdots , n \} , n = 10 $,求$U $中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5><p>集合是无序的,这个很难搞,我们先从$U $中把$1 $去掉最后再加上.</p>
<p>先考虑可以重复放$1 $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^{ n  } \sum _{ k = 1  } ^{ n  } [ \gcd ( i , j ) & = 1 ] [ \gcd ( i , k ) & = 1 ] [ \gcd ( j , k ) & = 1 ] \\

\end{aligned}</script><p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从$1 , 3 , 5 , 7 , 9 $中选,答案应该是$1 + 2 \binom { 3  } { 2  } = 7 $.</p>
<p>接下来考虑选一个偶数,如果选$2 , 4 , 8 $是等价的,答案此时是$3 ( \binom { 5  } { 2  } - 1 ) = 27 $.如果选$6 $的话答案是$\binom { 3  } { 2  } = 3 $.如果选$10 $的话方案数是$\binom { 4  } { 2  } - 1 = 5 $,加起来方案数是$42 $.</p>
<h4><span id="problem11">Problem11</span></h4><p>集合$U = \{ 1 , 2 , \cdots , n \} , n = 366 $,则$U $的互不相交且各元素之和为$17 $的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5><p>考虑$\lfloor \frac { 366  } { 17  } \rfloor = 21 , 366 \equiv 9 \pmod { 17  } $.答案显然是$21 \times 8 + 10 + 1 = 179 $个.</p>
<h4><span id="problem12">Problem12</span></h4><p>三个互不相同的数的$\gcd = 20 , \text { lcm  } = 20000 $,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5><p>显然等价于$\gcd = 1 , \text { lcm  } = 1000 = 2 ^3 \times 5 ^3 $.先只分析其中一个质因子,方案应该是$( 0 , 0 , 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , ( 0 , 3 , 3 ) $,打乱一下顺序的话就共有$3 + 6 + 6 + 3 = 18 $种方案.如果可以重复,平方一下得到$324 $.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有$2 \times 2 \times 3 = 12 $种,于是答案为$312 $.</p>
<h4><span id="problem14">Problem14</span></h4><p>求$\lfloor \frac { k ^2  } { n  } \rfloor , k \in [ 1 , n ] , n = 2023 $种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\lfloor \frac { k ^2  } { n  } \rfloor & = d \\
d & \leq \frac { k ^2  } { n  } & < d + 1 \\
nd & \leq k ^2 & < n ( d + 1 ) 
\end{aligned}</script><p>由于两个完全平方数的差是固定的,不妨猜测存在一个$k _0 $,$\leq k _0 $的$k $会扎堆,但是这些$d $全都能取到,$&gt; k _0 $的则不会有两个$k $得到相同的元素.所以前者统计不同的$d $,后者统计不同的$k $考虑$( k + 1 ) ^2 - k ^2 = 2 k + 1 $.分界线应该是$k _0 = 1011 $.</p>
<p>所以答案应该是$n - k _0 + \lfloor \frac { k _0 ^2  } { 2 k _0 + 1  } \rfloor + 1 = 1012 + 506 = 1518 $.</p>
<h4><span id="problem15">Problem15</span></h4><p>对四元组$( a , b , c , d ) $计数,满足$101 | ( a + b + c + d ) $且$0 &lt; a &lt; b &lt; c &lt; d \leq 101 $.</p>
<h5><span id="solution15">Solution15</span></h5><p>这题真的厉害啊.</p>
<p>不妨设$S _k $为满足$( a + b + c + d ) \equiv k \pmod { 101  } $的满足$0 &lt; a &lt; b &lt; c &lt; d \leq 101 $的四元组数量.不难发现$\sum S _k = \binom { 101  } { 4  } $.</p>
<p>注意到$( a , b , c , d ) \mapsto ( a + 1 , b + 1 , c + 1 , d + 1 ) $,注意这里是$\pmod { 101  } $意义下的加法,这是一个双射,所以$S _{ k  } = S _{ k + 4  } $,下标同样也是$\pmod { 101  } $意义下进行的.又因为$\gcd ( 101 , 4 ) = 1 $,所以所有的$S _k $均相等.$S _0 = \frac { \binom { 101  } { 4  }  } { 101  } = 40425 $.</p>
<h4><span id="problem16">Problem16</span></h4><p>问方程$x \lfloor x \rfloor = 6 $的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5><p>$6 = x \lfloor x \rfloor \geq \lfloor x \rfloor ^2 $,所以$\lfloor x \rfloor = \pm 1 , \pm 2 $.显然都不可以.所以个数为$0 $.</p>
<h4><span id="problem17">Problem17</span></h4><p>设$R ( n ) = \sum _{ k = 2  } ^{ 10  } ( n \bmod k ) $,求满足$R ( n ) = R ( n + 1 ) $的十进制下的两位数$n $的个数.</p>
<h5><span id="solution17">Solution17</span></h5><p>从$R ( n ) $到$R ( n + 1 ) $,应该是加了若干个$1 $,然后又丢了几个$k - 1 $这样的.那就一定需要丢掉的数字之和为$9 $.枚举一下,丢了的只有可能是以下情况:$( 9 ) , ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 + 3 + 2 ) $,分别对应了$n + 1 $应该是分别以下数的倍数$( 9 ) , ( 14 ) , ( 6 ) , ( 20 ) , ( 12 ) $,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:$( 7 + 2 ) $,并且分别不能是以下数字的倍数$( 3 , 4 , 5 ) $.</p>
<p>取一下的话$n + 1 $可以是:$14 , 98 $,$n = 13 , 97 $,验证一下均合法,所以答案为$2 $.</p>
<h4><span id="problem18">Problem18</span></h4><p>已知$a &lt; b &lt; c &lt; d $,而$x , y , z , w $是$a , b , c , d $的一个排列,求$( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 $得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5><p>圆排列个数是$3 ! = 6 $个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是$( x , y , z , w ) , ( x , z , w , y ) , ( x , w , y , z ) $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 \\
& = 2 ( x ^2 + z ^2 + y ^2 + w ^2 ) - 2 ( xy + yz + zw + wx ) 
\end{aligned}</script><p>显然只要$xy + yz + zw + wx $不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4><p>已知$0 &lt; x _1 &lt; x _2 &lt; \cdots &lt; x _9 $且$\sum _{ k = 1  } ^9 x _k = 220 $,在$\sum _{ k = 1  } ^5 x _k $最大的前提下,最小化$x _9 - x _1 $.</p>
<h5><span id="solution19">Solution19</span></h5><p>不妨枚举一下$x _5 $选啥,设$f ( S , m , k ) $表示选出$k $个互不相同的数,使得它们$\leq m $且总和为$S $,是否可行.不难发现$f ( S , m , k ) = [ \frac { k ( k + 1 )  } { 2  } \leq S \leq \frac { k ( 2 m - k + 1 )  } { 2  } ] $.</p>
<p>那我们要求的就是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max _{ 5 \leq x _5  } \{ S | f ( 220 - 4 x _5 - S , + \infty , 4 ) & = 1 \land f ( S - x _5 , x _5 - 1 , 4 ) & = 1 \} \\
& = \max _{ 5 \leq x _5  } \{ S | 4 x _5 + S & \leq 210 \land 10 + x _5 & \leq S & \leq 5 x _5 - 10 \} \\
& = \max _{ 5 \leq x _5  } ( \min \{ 5 x _5 - 10 , 210 - 4 x _5 \} ) 
\end{aligned}</script><p>立刻得到$x _5 = 24 , 25 , S = 110 $,那么后面的选法就一定了,后面四个数一定是$26 , 27 , 28 , 29 $,只需要让$x _1 $最大即可</p>
<p>$x _5 = 24 $时,此时最优显然是$20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 , 29 $,$x _9 - x _1 = 9 $.</p>
<h4><span id="problem20">Problem20</span></h4><p>有一个$n $边形,其中有$\binom { n  } { 2  } $条对角线,不存在三线交于一点的情况,问这些对角线将该$n $边形分成了多少个部分.$n = 10 $.</p>
<h5><span id="solution20">Solution20</span></h5><p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了$\binom { n  } { 4  } $个点(任意四个点有且只有一种交法),每交一个点就会多出$2 $条边,所以多出来了$2 \binom { n  } { 4  } + \frac { n ( n - 3 )  } { 2  } $条边.</p>
<p>考虑内部的若干个部分一定是$a _3 $个三角形,$a _4 $个四边形,…,$a _k $个$k $边形,总之我们发现:</p>
<script type="math/tex; mode=display">
\begin{cases}
\sum _{ j = 3  } ^k ( j - 2 ) \pi a _j = ( n - 2 ) \pi + 2 \pi \binom { n  } { 4  } \\
\sum _{ j = 3  } ^k ja _j = n + 4 \binom { n  } { 4  } + n ( n - 3 ) 
\end{cases}</script><p>两式得到:$\sum _{ j = 3  } ^k a _j = \frac { ( n - 1 ) ( n - 2 )  } { 2  } + \binom { n  } { 4  } $.</p>
<p>$n = 10 $的时候,答案为$246 $.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3><h4><span id="problem1">Problem1</span></h4><p>求$\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \bmod 7 , n = 2024 $.</p>
<h5><span id="solution1">Solution1</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \\
& = \sum _{ i = 1  } ^n \lfloor \frac { \sum _{ k = 0  } ^i 20 ^k ( - 1 ) ^{ i - k  } \binom { i  } { k  }  } { 20  } \rfloor \\
& = - \lfloor \frac { n  } { 2  } \rfloor + \sum _{ i = 1  } ^{ n  } \frac { 19 ^i - ( - 1 ) ^i  } { 20  } \\
& = - \lfloor \frac { n  } { 2  } \rfloor + \frac { \frac { 19  } { 18  } ( 19 ^n - 1 ) - ( \frac { ( - 1 ) ^n - 1  } { 2  } )  } { 20  } 
\end{aligned}</script><p>带入$n = 2024 $并$\bmod 7 $,原式为:</p>
<script type="math/tex; mode=display">
\equiv - 4 + \frac { 5  } { 4  } ( 1 - 5 ^n ) \equiv - 4 + 3 ( 1 - 5 ^n )</script><p>注意到$2024 \bmod 6 = 2 $,原式$\equiv - 4 - 9 \equiv 1 $.</p>
<h4><span id="problem3">Problem3</span></h4><p>求长度为$n $的排列个数,使得排列中$\nexists i \in [ 1 , n - 1 ] , a _i = a _{ i + 1  } - 1 $.$n = 8 $.</p>
<h5><span id="solution3">Solution3</span></h5><p>一眼容斥,也就是每个长度为$k $的连续段的容斥系数应该是$( - 1 ) ^{ k - 1  } $.那么设分成了$w $个段,总的容斥系数应该是$( - 1 ) ^{ n - w  } $,答案就是$f _{ n ‘  } = \sum _{ w = 1  } ^n ( - 1 ) ^{ n - w  } w ! \binom { n - 1  } { w - 1  } = \sum _{ w = 0  } ^{ n ‘  } ( - 1 ) ^{ n ‘ - w  } \binom { n ‘  } { w  } ( w + 1 ) ! = n ‘ ! \sum _{ w = 0  } ^{ n ‘  } \frac { ( - 1 ) ^w  } { w !  } ( n ‘ - w + 1 ) $,此时已经能算出答案是$16687 $.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设$g _n $为错排数量,显然有$f _{ n  } = nf _{ n - 1  } + g _{ n  } $,立刻算出答案是$16687 $.</p>
<h4><span id="problem4">Problem4</span></h4><p>已知数列$1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , \cdots $,求其第$n $项$\bmod 5 $的值,$n = 2024 $.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑第一个值为$k $的地方应该在哪里.显然$a _{ \frac { k ( k - 1 )  } { 2  } + 1  } = k $.注意到$a _{ 2081  } = 65 $,所以$a _n = 64 $,其$\bmod 5 = 4 $.</p>
<h4><span id="problem5">Problem5</span></h4><p>求四元组$( a _1 , a _2 , a _3 , a _4 ) $的个数,满足$a _1 , a _2 , a _3 , a _4 \in \{ 1 , 2 , 3 \} $,且$10 &lt; a _1 a _2 a _3 a _4 &lt; 20 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>排个序按照字典序开搜,只有三种可能:$\{ 3 , 3 , 2 , 1 \} , \{ 3 , 2 , 2 , 1 \} , \{ 2 , 2 , 2 , 2 \} $,打乱顺序的话就有$25 $种可能.</p>
<h4><span id="problem8">Problem8</span></h4><p>求$\mathbb { R  } $上方程$x ^2 - 13 \lfloor x \rfloor + 11 = 0 $的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5><p>首先注意到$\lfloor x \rfloor = \frac { x ^2 + 11  } { 13  } $,那么自然有方程组:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { x ^2 + 11  } { 13  } \leq x \\
x < \frac { x ^2 + 11  } { 13  } + 1 
\end{cases}</script><p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑$x ^2 \equiv 2 \pmod { 13  } $这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设$x = \sqrt { 2 + 13 k  } $的形式,带入有不等式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k - x + 1 & \leq 0 & < k - x + 2 \\
1 & \leq \sqrt { 2 + 13 k  } - k & < 2 \\
\begin{cases}
0 < k ^2 - 9 k + 2 \\
k ^2 - 11 k - 1 \leq 0 
\end{cases} 
\end{aligned}</script><p>冷静一下!注意到$0 \leq k \leq 13 $,又根据第一个不等式得知大部分$k $应该会很大,开始暴力枚举一下,合法的情况有:$k = 0 , 9 , 10 , 11 $,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4><p>在一个体积为$1 $的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积$\leq \frac { 1  } { 8  } $的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5><p>原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积$\leq \frac { 1  } { 8  } $.考虑设这个点是$( x , x , h ) $,那么必然有$\begin{cases}( 1 - h ) x ^2 &gt; \frac { 1  } { 8  } \ h ( 1 - x ) ^2 &gt; \frac { 1  } { 8  } \end{cases} $,化简,只要$8 &gt; \frac { 1  } { x ^2  } + \frac { 1  } { ( 1 - x ) ^2  } $即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取$( 0 . 5 , 0 . 5 , 0 . 1 ) $即可.那么是不是可以证明答案一定$&gt; 3 $呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积$\leq \frac { 1  } { 8  } $的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为$( x , y , h ) , x , y , h \leq \frac { 1  } { 2  } $,然后证明$8 &gt; \frac { 1  } { xy  } + \frac { 1  } { ( 1 - x ) ( 1 - y )  } , x , y \leq \frac { 1  } { 2  } $这个不等式无解即可.</p>
<p>由基本不等式,$\frac { 1  } { xy  } + \frac { 1  } { ( 1 - x ) ( 1 - y )  } \geq 2 \sqrt { \frac { 1  } { x ( 1 - x ) y ( 1 - y )  }  } \geq 2 \sqrt { 4 \times 4  } = 8 $,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4><p>设$S ( n ) $表示正整数$n $的十进制数码和,求满足$S ( n ) \equiv S ( n + 1 ) \equiv 0 \pmod { 5  } $的最小的$n $.</p>
<h5><span id="solution11">Solution11</span></h5><p>显然必须发生进位,不妨设$n = 10 ^k a + 10 ^k - 1 $,$a \ne 9 \pmod { 10  } $,$S ( n ) = S ( a ) + 9 k , S ( n + 1 ) = S ( a ) + 1 $,</p>
<p>此时显然有$9 k - 1 \equiv 0 \pmod { 5  } $,$k \equiv 4 \pmod { 5  } $.$n _{ \min  } = 49999 $.</p>
<h4><span id="problem12">Problem12</span></h4><p>求满足以下条件的最大的正整数$n $:十进制下每一位数字互不相同,且$\forall m , 10 ^m \leq n , \lfloor \frac { n  } { 10 ^m  } \rfloor | n $.</p>
<h5><span id="solution12">Solution12</span></h5><p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是$0 $.</p>
<p>不妨设其为$\overline { ab  } $,其中$b = 10 c $,$a $是$b $的因子,不妨枚举一下$k = \frac { b  } { a  } $.注意到因为$a $中不能有$0 $,所以$k \in \{ 2 , 4 , 5 , 8 \} $.取$k = 2 $试出来$3570 $是合法的,而且显然$k \in \{ 4 , 5 , 8 \} $的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4><p>$a _1 = \sqrt { 2  } , a _{ n + 1  } = \lfloor a _n \rfloor + \frac { 1  } { a _n - \lfloor a _n \rfloor  } $,求$\sum _{ k = 1  } ^{ n  } a _k , n = 2024 $.</p>
<h5><span id="solution20">Solution20</span></h5><p>这一看就是个环,设$a _n = b _n + c _n \sqrt { 2  } $.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<script type="math/tex; mode=display">
\begin{cases}
a _1 = 0 + \sqrt { 2  } \\
a _2 = 2 + \sqrt { 2  } \\
a _3 = 4 + \sqrt { 2  } \\
\cdots 
\end{cases}</script><p>容易猜测$b _n = 2 ( n - 1 ) , c _n = 1 $.也就是$a _n = 2 ( n - 1 ) + \sqrt { 2  } $,数学归纳一下即可.</p>
<p>那么$\sum _{ k = 1  } ^n a _k = n ( n - 1 ) + n \sqrt { 2  } $,带入$n = 2024 $即可.</p>
<h3><span id="2022图选">2022图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol>
<li><p>任意两个正方形至多有一个顶点重合</p>
</li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p>
</li>
</ol>
<h5><span id="solution1">Solution1</span></h5><p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol>
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p>
</li>
<li><p>边可以相交,放到正十二边形的边上.</p>
</li>
</ol>
<h4><span id="problem2">Problem2</span></h4><p>求$\lfloor ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ 12  } \rfloor $.</p>
<h5><span id="solution2">Solution2</span></h5><p>考虑$( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^3 = 2 + \sqrt { 5  } $,$\lfloor ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ 12  } \rfloor = 161 + \lfloor 72 \sqrt { 5  } \rfloor = 321 $.</p>
<p>也可以考虑类似斐波那契数列,取$f _n = ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ n  } + ( \frac { 1 - \sqrt { 5  }  } { 2  } ) ^{ n  } $,其满足$f _n = f _{ n - 1  } + f _{ n - 2  } , f _0 = 2 , f _1 = 1 $,取$f _{ 12  } - 1 $就是答案$321 $.</p>
<h4><span id="problem3">Problem3</span></h4><p>对于一个加法乘法环,要求你利用:</p>
<ol>
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p>
</li>
<li><p>加法结合律、逆元.</p>
</li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5><p>倒反天罡题.</p>
<p>注意到$( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a + 1 ) $,所以$a + b = b + a $.</p>
<h4><span id="problem4">Problem4</span></h4><p>给你$n $个数集$a _i $,其中$| a _i | = i + 1 $,要你选出$n $个两两不同的数字满足$x _i \in a _i $,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是$2 ^n $.</p>
<h4><span id="problem5">Problem5</span></h4><p>Alice和Bob博弈.Alice先选一个数$m $,然后Bob选一个数$n ( n &gt; m ) $,并构造一个$n $个点的竞赛图.Alice如果能从中选出$m $个不同的点,满足不存在某个点$x $到这$m $个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5><p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是$( 1 - \frac { 1  } { 2 ^m  } ) ^{ n - 2  } $,因此期望为$E = \binom { n  } { m  } ( 1 - \frac { 1  } { 2 ^m  } ) ^{ n - 2  } $,只需$n $足够大的时候期望$&lt; 1 $,则说明一定存在$0 $,也就是Bob总有必胜策略.</p>
<p>注意到只需证明$\exists n $,$\binom { n  } { m  } &lt; ( \frac { 2 ^m  } { 2 ^m - 1  } ) ^{ n - 2  } $,而$\binom { n  } { m  } = \frac { n ^{ \underline { m  }  }  } { m !  } &lt; n ^m $.下面证明$\exists n , n ^m &lt; ( \frac { 2 ^m  } { 2 ^m - 1  } ) ^{ n - 2  } $.</p>
<p>两边取$\ln $,不妨假设$n \geq 3 $,有$m \ln n &lt; ( n - 2 ) \ln ( \frac { 2 ^m  } { 2 ^m - 1  } ) , \frac { m  } { \ln ( \frac { 2 ^m  } { 2 ^m - 1  } )  } &lt; \frac { n - 2  } { \ln n  } $,$\frac { n - 2  } { \ln n  } $显然在$n \geq 3 $的时候单增,所以一定存在这么一个$n $.</p>
<h3><span id="2023图选">2023图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5><p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4><p>求正整数拆分成有序的$1 , 2 $序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5><p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4><p>定义$* $为集合$G $上的二元运算,已知:</p>
<ol>
<li><p>满足结合律$a ∗ b ∗ c = a ∗ ( b ∗ c ) $.</p>
</li>
<li><p>存在左单位元$e $,对任意$a $满足$e ∗ a = a $.</p>
</li>
<li><p>对任意$a $存在左逆元$b $,使$b ∗ a = e $.</p>
</li>
</ol>
<p>问:</p>
<ol>
<li><p>左单位元是否也为右单位元.</p>
</li>
<li><p>左逆元是否也为右逆元.</p>
</li>
</ol>
<h5><span id="solution3">Solution3</span></h5><p>看(2),考虑设$b $是$a $的左逆元,$c $是$b $的左逆元,则$cba = ce = a , ab = ceb = e $.</p>
<p>看(1),设$b $是$a $的逆元,$ea = aba = ae $,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明$ab $的时候$b $不能彻底损失信息,而观察$ab = eab $知道$a $也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算$( a _1 , b _1 ) ( a _2 , b _2 ) $,想办法让其损失掉$( a _1 , b _1 ) $中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到$( a _1 , b _1 ) ( a _2 , b _2 ) = ( a _1 + a _2 , b _2 ) $即可,存在左幺元为$( 0 , 0 ) $,右逆元为$( - a , 0 ) $.</p>
<h4><span id="problem4">Problem4</span></h4><p>$f $的定义域和值域都是正整数并且$f ( xy ) = f ( x ) + f ( y ) - 1 $,求:</p>
<ol>
<li><p>是否存在这样的函数.</p>
</li>
<li><p>是否存在无数个这样的函数.</p>
</li>
<li><p>是否存在严格递增的函数.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>令$g ( x ) = f ( x ) - 1 $,则$g ( xy ) = g ( x ) + g ( y ) $.</p>
<p>对于(1),取$g ( x ) = 0 , f ( x ) = 1 $即可.</p>
<p>对于(2),考虑$g ( p ^k ) = kg ( p ) $,只需要让$g ( p ) $取不同的值即可.</p>
<p>对于(3),考虑$g ( 2 ^a ) = ag ( 2 ) $,$g ( 3 ^b ) = bg ( 3 ) $.</p>
<p>考虑构造$a , b $,使得$2 ^a &lt; 3 ^b $但是$ag ( 2 ) \geq bg ( 3 ) $.不妨取$a = \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil $,那么必定有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ^{ \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil  } & < 3 ^b \\
\lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil & < b \log _2 3 \\
\frac { bg ( 3 )  } { g ( 2 )  } + \Delta & \leq b \log _2 3 \\

\end{aligned}</script><p>于是如果存在,必定需要$\frac { g ( p _1 )  } { g ( p _2 )  } \geq \log _{ p _2  } p _1 \land \frac { g ( p _2 )  } { g ( p _1 )  } \geq \log _{ p _1  } p _2 $,也就是$\frac { g ( p _2 )  } { g ( p _1 )  } = \log _{ p _1  } p _2 $.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4><p>对于任意$2 n - 1 $个正整数(可重复),问其中是否一定有$n $个数的和能被$n $整除,这题$n = 50 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>考虑当$n $是合数的时候,设$n = pq $,则可以将其拆成$q - 1 $组每组$2 p $个数以及一组$2 p - 1 $个数,因此只需要这些都可以找到$p $个数使得其是$p $的倍数,组合起来就行了.</p>
<p>只需要解决$n $是质数的情况.</p>
<p>感觉场上的最优解应该是解决$n = 2 $和$n = 5 $的情况然后拼成$n = 50 $.</p>
<p>$n = 2 $的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然$S = \sum _{  } ( x _{ p _1  } + x _{ p _2  } + \cdots + x _{ p _n  } ) ^{ p - 1  } \equiv \binom { 2 n - 1  } { n  } \equiv 1 \pmod { n  } $.</p>
<p>但是考虑左边那个多项式的每一项,形如$c \prod _{ i = 1  } ^k x _{ p _i  } ^{ e _i  } $.注意到$c $一定是$\binom { 2 n - 1 - k  } { n - k  } $的倍数,而后者$\bmod n $为$0 $.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为$1 $并不是对称的,而左边是个对称式子,某个$x $增大也无所谓,这意味着左边应该是为$0 $的,我们要做的就是去证明它是$0 $.</p>
<h3><span id="2024图选">2024图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>问在双曲线$xy = 1 $上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5><p>不会做,取个特殊值知道答案应该是$[ 2 \sqrt { 6  } , + \infty ) $.</p>
<h4><span id="problem2">Problem2</span></h4><p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol>
<li><p>如果$n , m $都是好的,那么$nm $是好的.</p>
</li>
<li><p>$2024 $不是好的.</p>
</li>
</ol>
<h5><span id="solution2">Solution2</span></h5><p>如果$n = a ^2 + b ^2 , m = c ^2 + d ^2 $,那么$nm = a ^2 c ^2 + a ^2 d ^2 + b ^2 c ^2 + b ^2 d ^2 = ( ac - bd ) ^2 + ( ad + bc ) ^2 $.</p>
<p>$2024 = 2 ^3 \times 11 \times 23 $,使用反证法,不妨设其可以被表示为$a ^2 + b ^2 $.</p>
<p>讨论一下:如果$a , b $均为奇数,那么$a ^2 + b ^2 \equiv 2 \pmod { 8  } $,不符题意.</p>
<p>于是$a , b $应该均为偶数,那么就有$a ‘ ^2 + b ‘ ^2 = 506 $.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4><p>对于集合$G $,$e \in G $,定义域为$G $的函数$f $满足以下性质:</p>
<ol>
<li><p>$e \in G $,但$e $不在$f $的值域中.</p>
</li>
<li><p>$G $关于$f $封闭.</p>
</li>
<li><p>若$\exists A \subseteq G $,$e \in A $且$A $对$f $封闭,则$A = G $.</p>
</li>
</ol>
<p>在$G $上定义二元运算$\circ $,满足$ae = a , af ( b ) = f ( ab ) $.</p>
<p>求证:</p>
<ol>
<li><p>存在幺元.</p>
</li>
<li><p>运算满足交换律.</p>
</li>
<li><p>运算满足结合律.</p>
</li>
</ol>
<h5><span id="solution3">Solution3</span></h5><p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往$A $里面扔个$e $,此时$A $一定不满足条件.我们不断从$A $中选出一个元素$w $满足$f ( w ) \notin A $,并把$A : = A \cup \{ f ( w ) \} $.不断做这个过程显然最后会得到$G $,这意味着任何一个元素$a $可以写成$f ( f ( f \cdots f ( e ) ) ) $的形式.</p>
<p>不妨将$f $函数嵌套$k $次记作$f ^{ ( k )  } $,那么我们要证明的是$a = f ^{ ( A )  } ( e ) , b = f ^{ ( B )  } ( e ) $,$ab = ba $.</p>
<p>考虑$ab = f ^{ ( A )  } ( e ) f ^{ ( B )  } ( e ) = f ^{ ( B )  } ( f ^{ ( A )  } ( e ) e ) = f ^{ ( A + B )  } ( e ) $,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4><p>给出一个具体函数满足:</p>
<ol>
<li><p>$f ( x + y ) = f ( x ) + f ( y ) + xy $.</p>
</li>
<li><p>$f ( xy ) = f ( x ) f ( y ) + f ( x - 1 ) f ( y - 1 ) $.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>先注意到$f ( 0 ) = 0 , f ( 1 ) = 1 $.</p>
<p>以$x $为主元两边求导,立刻得到$f ‘ ( x + y ) = f ‘ ( x ) + y $,因此$f ‘ ( x ) $是斜率为$1 $的一次函数,立刻得到$f ( x ) = \frac { x ^2  } { 2  } + \frac { x  } { 2  } $.</p>
<h4><span id="problem5">Problem5</span></h4><p>对于$r = \sqrt { 2  } $,是否存在正整数$p $和整数$q $满足$| pr - q | &lt; \frac { 1  } { 2024  } $且$p &lt; 2024 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>考虑取$0 , \sqrt { 2  } , 2 \sqrt { 2  } , 3 \sqrt { 2  } , \cdots 2023 \sqrt { 2  } $的小数部分,记作$a _0 , a _1 , \cdots a _{ 2023  } $.</p>
<p>由鸽笼原理,一定存在两个数$0 \leq x &lt; y \leq 2023 $满足$| a _x - a _y | &lt; \frac { 1  } { 2024  } $,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>在一个数轴上,你站在$0 $点,并按照如下算法寻找$x ( x &gt; 0 ) $点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. $3 x $  B. $5 x $  C. $7 x $  D. $9 x $  E. 以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5><p>考虑找到牛的时候$step $为多少,应该为$2 ^{ 2 k  } $,其中$k $满足$2 ^{ 2 k  } \geq x &gt; 2 ^{ 2 ( k - 1 )  } $.此时走的步数应该是$ans = 2 \sum _{ i = 0  } ^{ 2 k - 1  } 2 ^i + x = 2 ^{ 2 k + 1  } - 1 + x $步.而$x \leq 2 ^{ 2 k  } &lt; 4 x $,所以$ans &lt; 9 x - 1 $.</p>
<h4><span id="problem2">Problem2</span></h4><p>给定$10 $个实数变量$x _1 , \cdots , x _{ 10  } $,满足它们均$\geq 1 $且两两不同.你要寻找一组$\{ x \} $和一个实数$a $,使得存在尽可能多组$\langle b \rangle , b _i = \pm 1 $,满足$\sum _{ i = 1  } ^{ 10  } b _i x _i \in ( a , a + 2 ) $.</p>
<p>最多存在多少组$\langle b \rangle $?</p>
<p>A. $512 $  B. $252 $  C. $504 $  D. $684 $  E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5><p>不妨猜测$x $全取$1 $最优,此时的答案是$\binom { 10  } { 5  } = 252 $.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于$x \geq 1 $,所以如果存在两组$\langle b \rangle $,使得$A $组中选择取$+ 1 $恰好是$B $组的子集,那么$S _A \leq S _B - 2 $,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让$x $尽可能接近$1 $,这样就是满足条件的.所以问题变为对于一个大小为$10 $的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取$\binom { 10  } { 5  } $最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4><p>给定无向图$G = ( V , E ) $,我们称一个图是好的,如果:</p>
<ol>
<li><p>每个点的度数均为$d $.</p>
</li>
<li><p>任何一个大小不超过$\frac { | V |  } { 2  } $的联通集合$S $,其邻居(不属于$S $但和$S $中的某个点存在直接相连的边)的大小$\geq \frac { 5  } { 4  } | S | $.</p>
</li>
</ol>
<p>求证:好的图中任意两个点$u , v $之间的最短路径长度$dis ( u , v ) = O ( \log | V | ) $.</p>
<h5><span id="solution3">Solution3</span></h5><p>考虑以$u $为起点一点一点往外扩张,这样一直扩张到$\frac { | V |  } { 2  } + 1 $时,集合中每个点到$u $的距离不超过$O ( \log | V | ) $.</p>
<p>然后以$v $做同样的事,由于这两个集合大小之和大于$| V | $,说明一定有交,且存在一条路径长度为$O ( \log | V | ) $的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4><p>给你两个完全相同的鸡蛋和一个$n = 100 $层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5><p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有$101 $个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设$f _{ i , 1 / 2  } $表示一棵有$i $个叶子的树,最多向右走$1 / 2 $步,深度最低为多少.显然$f _{ i , 1  } = i - 1 $.</p>
<p>不妨设最后的最大深度为$k $,需要满足$1 + \sum _{ i = 1  } ^k i = 1 + \frac { k ( k + 1 )  } { 2  } \geq 101 , k ( k + 1 ) \geq 200 $,$k _{ \min  } = 14 $.</p>
<h4><span id="problem5">Problem5</span></h4><p>$n $个人要进行一场游戏.游戏设计者准备了$n $张卡片,正面分别写着$n $个人的名字,背面写了$[ 1 , n ] $共$n $个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,$n $个人可以经过充分的讨论,并依次进入房间,一张一张地翻开$\lfloor \frac { n  } { 2  } \rfloor $张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有$n $个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过$0 . 1 $的胜率.</p>
<h5><span id="solution5">Solution5</span></h5><p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是$a $,如果$a $就是自己的编号就下班;反之接下来翻开$a $位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于$\frac { n  } { 2  } $的环.</p>
<p>考虑总方案数是$n ! $.不妨枚举这个环的长度为$K $,则存在一个长度$= K &gt; \frac { n  } { 2  } $的环的方案数是$\binom { n  } { K  } ( K - 1 ) ! ( n - K ) ! = \frac { n !  } { K  } $.所以此时的概率为$\frac { 1  } { K  } $.</p>
<p>那么失败的概率就是$H _n - H _{ \frac { n  } { 2  }  } \approx \ln 2 $.</p>
<h3><span id="2022茶选">2022茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化$z = 5 x _1 + 8 x _2 + 4 x _3 $,其中:</p>
<ol>
<li><p>$x _1 , x _2 , x _3 \geq 0 $</p>
</li>
<li><p>$\frac { 1  } { 2  } x _1 + 5 x _2 + 9 x _3 \leq 3 $</p>
</li>
<li><p>$4 x _1 + 7 x _2 + 3 x _3 \leq 6 $</p>
</li>
</ol>
<p>再提一个问题:最小化$v = 3 y _1 + 6 y _2 $,其中:</p>
<ol>
<li><p>$y _1 , y _2 \geq 0 $</p>
</li>
<li><p>$\frac { 1  } { 2  } y _1 + 4 y _2 \geq 5 $</p>
</li>
<li><p>$5 y _1 + 7 y _2 \geq 8 $</p>
</li>
<li><p>$9 y _1 + 3 y _2 \geq 4 $</p>
</li>
</ol>
<p>现在请你证明:$z \leq v $.</p>
<h5><span id="solution1">Solution1</span></h5><p>下面乘一下配一下上面的系数,自然得证.</p>
<p>写成矩阵形式,设$X = \begin{bmatrix}x _1 &amp; x _2 &amp; x _3 \end{bmatrix} , A = \begin{bmatrix}0 . 5 &amp; 4 \ 5 &amp; 7 \ 9 &amp; 3 \end{bmatrix} , Y = \begin{bmatrix}y _1 \ y _2 \end{bmatrix} $,不难发现$z \leq XAY \leq v $.</p>
<h4><span id="problem2">Problem2</span></h4><p>半径为$R $的球里放点,要求两两之间距离不能小于$1 $,证明至多放$( 2 R + 1 ) ^3 $个.</p>
<h5><span id="solution2">Solution2</span></h5><p>要求两两距离不能小于$1 $等价于往其中放半径为$0 . 5 $的球,这种球体积为$\frac { 4  } { 3  } \pi \frac { 1  } { 8  } $.然后原球要扩大一圈,所以原球体积变为$\frac { 4  } { 3  } \pi ( R + 0 . 5 ) ^3 $.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4><p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数$n $.</p>
<p>它每秒以$v $的速度行驶,其中$v $是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数$x $,你会得知此时车的坐标是否是$x $(Yes or No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5><p>第$t $秒的时候车应该在$n + vt $处.由于我们知道现在是第几秒,枚举$n , v $然后不断check即可.这个是经典的证明$\mathbb { Z  } ^2 $和$\mathbb { N  } $等势.按照$| n | + | v | $排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4><p>对满足$\forall i , | i - p _i | \leq 1 $的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5><p>简单题,设$f _n $为答案,考虑$p _n $取什么.</p>
<p>当$p _n = n $时,方案数为$f _{ n - 1  } $.</p>
<p>当$p _n = n - 1 $时,$p _{ n - 1  } = n $,方案数为$f _{ n - 2  } $.</p>
<p>于是,$f _1 = 1 , f _2 = 2 $,$f _n = f _{ n - 1  } + f _{ n - 2  } $.</p>
<h4><span id="problem5">Problem5</span></h4><p>你有一个$n \times n $的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择$k $个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数$k $最小值是$n $.</p>
<h5><span id="solution5">Solution5</span></h5><p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是$\frac { 4 n  } { 4  } = n $个.</p>
<h4><span id="problem6">Problem6</span></h4><p>设$F = \{ S _1 , S _2 , S _3 , . . . , S _{ | F |  } \} $,定义一个集合$T $能被$F $ shattered为:$T $的任意一个子集(包括它自己和空集),都可以由$T \cap S _{ i _1  } \cap S _{ i _2  } . . . $表示.其中$S _{ i _j  } $是$F $中的集合(就是说每个子集都等于$T $和某些$F $内集合的交.)</p>
<p>定义一个$F $的”VC-Dimension”是,能被他shattered的集合$T $的大小的最大值.</p>
<p>$F $中的集合们只会包含某$n $种不同的元素.证明:</p>
<ol>
<li><p>任意一个$F $能shattered的$T $至少有$| F | $个.</p>
</li>
<li><p>对于一个VC-Dimension的大小为$k $的$F $,其$| F | \leq \sum _{ i = 0  } ^k \binom { n  } { i  } $.</p>
</li>
</ol>
<h5><span id="solution6">Solution6</span></h5><p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的$S $,满足$S , S \cup \{ x \} \in F $,然后将这些$S \cap \{ x \} $拎出来,假设有$t $个,左边删去$x $后再进行数学归纳得到$| F | - t $个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有$t $个集合,在这$t $个集合添上$x $这个元素即可.</p>
<p>$t = 0 $怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为$S $(选取最大的那个集合为新加入的),我们在前面的集合中找到一个与$S $有交的集合$T $,根据上面的预处理,此集合显然存在.选出一个$x \in S \setminus T $,不妨设$S = S ‘ \cup \{ x \} $,令$T ‘ = S ‘ \cap T $,然后用$T ‘ $代替原本的$T $即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>令$p ( x ) $表示$x $的最大质因子,求所有$( x , y , z ) $使得:</p>
<ol>
<li><p>$x &lt; y &lt; z $且$x + z = 2 y $.</p>
</li>
<li><p>$p ( xyz ) \leq 3 $.</p>
</li>
</ol>
<h5><span id="solution1">Solution1</span></h5><p>不妨令$g = \gcd ( x , y , z ) $,令$x ‘ = \frac { x  } { g  } $,则只需要解:$x ‘ + z ‘ = 2 y ‘ $.</p>
<p>我们有$y - x = z - y $,则$\gcd ( y ‘ , x ‘ ) = \gcd ( y ‘ , y ‘ - x ‘ ) = \gcd ( y ‘ , z ‘ ) = 1 $,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol>
<li><p>$2 \nmid x ‘ , 2 \nmid z ‘ $.</p>
</li>
<li><p>$2 \mid x ‘ , 2 \mid z ‘ , 2 \nmid y ‘ $.</p>
</li>
</ol>
<p>先看(1),设$x ‘ = 3 ^a , z ‘ = 3 ^c , y ‘ = 2 ^b $.方程变为$3 ^a ( 1 + 3 ^{ c - a  } ) = 2 ^{ b + 1  } $,一定有$a = 0 $,只需解$1 + 3 ^{ c  } = 2 ^{ b + 1  } $.</p>
<p>当$b \leq 2 $的时候,经检验有$\begin{cases}c = 0 \ b = 0 \end{cases} $(舍)和$\begin{cases}c = 1 \ b = 1 \end{cases} $两组解.</p>
<p>当$b \geq 3 $的时候,注意到$3 ^{ c  } \equiv - 1 \pmod { 4  } $,所以$c $是偶数.又注意到$3 ^{ c  } \equiv - 1 \pmod { 8  } $,但是奇数的平方$\bmod 8 $应该是$1 $,不符.</p>
<p>再看(2),设$x ‘ = 2 ^d , z ‘ = 2 ^e , y ‘ = 3 ^b $.</p>
<p>当$e = 1 $时,显然不符.</p>
<p>当$d = 1 , e &gt; 1 $时,要解$2 ^{ e - 1  } + 1 = 3 ^{ b  } $.当$e = 2 $的时候有一组解$\begin{cases}e = 2 \ b = 1 \end{cases} $.当$e \geq 3 $的时候,有$3 ^b \equiv 1 \pmod { 4  } $,说明$b $是偶数.</p>
<p>那必然有$2 ^{ e - 1  } = 3 ^b - 1 = ( 3 ^{ \frac { b  } { 2  }  } + 1 ) ( 3 ^{ \frac { b  } { 2  }  } - 1 ) $.令$t = 3 ^{ \frac { b  } { 2  }  } - 1 $,则$2 ^{ e - 1  } = t ( t + 2 ) $.则要么$t = 2 $,要么$t + 2 = 2 $.解出$b - 2 $,此时有$\begin{cases}e = 4 \ b = 2 \end{cases} $.</p>
<p>综上,解出来的解有$\begin{cases}x ‘ = 2 \ y ‘ = 3 \ z ‘ = 4 \end{cases} , \begin{cases}x ‘ = 1 \ y ‘ = 2 \ z ‘ = 3 \end{cases} , \begin{cases}x ‘ = 2 \ y ‘ = 9 \ z ‘ = 16 \end{cases} $.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程$2 ^x + 1 = 3 ^y $,考虑两边$\bmod 3 $知道$x $是奇数,于是$v _3 ( 2 ^x + 1 ) = v _3 ( 3 ) + v _3 ( x ) = y , 3 ^{ y - 1  } | x , x \geq 3 ^{ y - 1  } $,用这个放缩一下就行.</p>
<p>再看方程$2 ^x = 3 ^y + 1 $.仍然考虑两边$\bmod 4 $,知道$y $是奇数.$x = v _2 ( 3 ^y + 1 ) = v _2 ( 3 + 1 ) = 2 $,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4><p>给定两个随机分布：</p>
<p>$x ∼ D _1 $:从${ 0 , 1 , … , p − 1  } $中等概率随机一个$y $,令$x = y   \bmod   { 2 ^k  } $.</p>
<p>$x ∼ D _1 $:从${ 0 , 1 , … , 2 ^k - 1  } $中等概率随机一个$y $,令$x = y   $.</p>
<p>定义二者的统计距离为:$SD ( D _1 , D _2 ) = \frac { 1  } { 2  } \sum _{ i = 0  } ^{ 2 ^k - 1  } | P _{ D _1  } ( x = i ) - P _{ D _2  } ( x = i ) | $.</p>
<p>求证:$SD ( D _1 , D _2 ) ≤ \frac { 2 ^k  } { 4 p  } $.</p>
<h5><span id="solution2">Solution2</span></h5><p>令$w = p \bmod { 2 ^k  } $.则$SD ( D _1 , D _2 ) = \frac { w  } { 2  } ( P _{ D _1  } ( x = 0 ) - P _{ D _2  } ( x = 0 ) ) + \frac { 2 ^k - w  } { 2  } ( P _{ D _2  } ( x = w ) - P _{ D _1  } ( x = w ) ) $.</p>
<p>令$k = \lfloor \frac { p  } { 2 ^k  } \rfloor = \frac { p - w  } { 2 ^k  } $不难发现$P _{ D _1  } ( x = 0 ) = \frac { k + 1  } { p  } , P _{ D _1  } ( x = w ) = \frac { k  } { p  } $.</p>
<p>则$SD ( D _1 , D _2 ) = \frac { w  } { 2  } ( \frac { p - w + 2 ^k  } { p 2 ^k  } - \frac { 1  } { 2 ^k  } ) + \frac { 2 ^k - w  } { 2  } ( \frac { 1  } { 2 ^k  } - \frac { p - w  } { p 2 ^k  } ) = \frac { 1  } { 2 ^{ k + 1  }  } ( \frac { w ( 2 ^k - w )  } { p  } + \frac { w ( 2 ^k - w )  } { p  } ) = \frac { w ( 2 ^k - w )  } { p 2 ^k  } $.</p>
<p>要证明$\frac { w ( 2 ^k - w )  } { p 2 ^k  } \leq \frac { 2 ^k  } { 4 p  } \Leftrightarrow w ( 2 ^k - w ) \leq ( 2 ^{ k - 1  } ) ^2 $.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4><p>给你一个单增函数$f $,满足定义域和值域都是$\mathbb { N  } $,并且$f ( f ( n ) ) = 3 n $,求$f ( 2023 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><p>首先我们不妨先试一下$f ( f ( 1 ) ) = 3 $.由于$f ( 1 ) \geq 2 $,且$f ( 1 ) \ne 3 $,所以$f ( 1 ) = 2 , f ( 2 ) = 3 $.</p>
<p>考虑$f ( 3 n ) $,必然存在一个$n &lt; m &lt; 3 n $,使得$f ( n ) = m , f ( m ) = 3 n $.</p>
<p>用这个找前几项,发现规律是把$n $写成三进制形式,如果首位是$1 $就变成$2 $,首位是$2 $就改为$1 $再在后面加个$0 $.容易验证这是合法的$f $且$f ( 2023 ) = 3882 $.</p>
<p>但问题没有解决,需要证明它是唯一的$f $.</p>
<p>考虑数学归纳假设现在$f ( x ) , x \in [ 1 , 3 k ] $都确定了.</p>
<p>注意到如果$f ( n ) = m , f ( m ) = 3 n , f ( 3 n ) = 3 m , f ( 3 m ) = 9 n $.所以如果$f ( n ) = m $,我们实际上有$f ( 3 ^k m ) = 3 ^{ k + 1  } n , f ( 3 ^k n ) = 3 ^k m $.数学归纳即可以证明$f ( 3 k + 3 ) $一定是确定的.</p>
<p>接下来要证明$f ( 3 k + 1 ) $和$f ( 3 k + 2 ) $一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol>
<li><p>$f ( 3 k ) + 3 = f ( 3 k + 3 ) $.</p>
</li>
<li><p>$\exists n , f ( n ) = 3 k + w ( w \in \{ 1 , 2 \} ) $.</p>
</li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当$k $在三进制下首位如果是$2 $,则一定满足(2).</p>
<p>当$k $在三进制下首位是$1 $,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4><p>对于一个$n \times n $的包含$[ 1 , n ^2 ] $各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol>
<li><p>如果一个排列矩阵满足每行恰有模$n $余$[ 0 , n - 1 ] $的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第$i $行第$j $列为$( i - 1 ) n + j $的矩阵(不妨称为有序矩阵).</p>
</li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列$\bmod n $不相同,可以先将每行按照$\bmod n $排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将$\bmod n $不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是$n $正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4><p>有$n ( \geq 2 ) $个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称$n $是好的.求证:</p>
<ol>
<li><p>$4 $是好的.</p>
</li>
<li><p>如果$n $是奇数,那么$n $不是好的.</p>
</li>
<li><p>求出所有好的$n $.</p>
</li>
</ol>
<h5><span id="solution5">Solution5</span></h5><p>首先可以证明$2 $是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要$2 ^n $步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样$0 $和$1 $就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到$1100 $来一个$1010 $之后啥也不变,但是$1010 $来一个$1010 $一定赢了.所以上来先来一个$1010 $,如果赢了就下班,没赢就来个$1100 $,这样$1100 $要么下班,要么变成了$1010 $,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:$0000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111 , 1000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111 $.</p>
<p>上面的构造启发我们手玩一下$n = 3 $,注意到此时的问题在于$100 $和$110 $,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全$0 $;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全$0 $.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全$0 $的成功状态.我们不妨令一个成功状态的度为$d $表示它可以经过$d $步到达全$0 $,显然全$1 $的$d = 1 $,$n = 4 $的时候,$1010 $的$d = 2 $,因为其可以通过一次操作转化为全$1 $,$1100 $的$d = 3 $,因为其可以用一次操作转化为$1010 $.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向$d $比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然$n = 3 $的时候,$\{ 110 , 100 \} $就是失败状态.</p>
<p>而对于$n $取任意来说,一定得存在一个$d = 2 $的成功状态.一个显然的$d = 2 $的成功状态要满足的条件是,假设它是$a $,那么存在一个数$b $,使得$a \oplus b $是全$1 $或者全$0 $.既然$a $和$b $旋转后只有两种结果,那么$b $的循环节必定为$2 $,也就是$b $一定要是$101 \cdots 010 $这样的,于是$n $是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找$d = 3 $的成功状态,现在我们已知的四种成功状态是$111 \cdots 111 $,$000 \cdots 000 $,$101 \cdots 010 $,$010 \cdots 101 $,所以考虑构造一个循环节长度为$4 $的串,使得异或完它是这上面四种其一,注意到$1100 \cdots 1100 $就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明$n = 2 ^k $一定是好的.考虑数学归纳,不妨这么干:构造一个长度为$2 ^{ k - 1  } $的串$b $,使得其$b _i = a _i \oplus a _{ i + 2 ^{ k - 1  }  } $.然后由数学归纳,可以造出$b $全$0 $的情况.而如果$b $全$0 $,则原串一定存在长为$2 ^{ k - 1  } $的循环节,并且消除循环节的过程不会改变$b $的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设$n = 2 ^k m $,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造$b $数组,由于$b $数组都不可能全$0 $,显然也不可能成立.</p>
<p>这个能不能顺便证明$n $是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了$n - 1 $个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前$n - 1 $个位置的异或值为$1 $.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为$50 \% $,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5><p>简单题,设$f _0 , f _1 , f _2 , f _3 $,然后有$\begin{cases}f _3 = 0 \ f _2 = \frac { 1  } { 2  } f _3 + \frac { 1  } { 2  } f _0 + 1 \ f _1 = \frac { 1  } { 2  } f _2 + \frac { 1  } { 2  } f _0 + 1 \ f _0 = \frac { 1  } { 2  } f _1 + \frac { 1  } { 2  } f _0 + 1 \end{cases} $,算出$f _0 = 14 $.</p>
<h4><span id="problem2">Problem2</span></h4><p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<script type="math/tex; mode=display">
x ^3 + □ x ^2 + □ x + □ = 0</script><h5><span id="solution2">Solution2</span></h5><p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为$- A , - B , - C $,方程应该可以写作$( x + A ) ( x + B ) ( x + C ) = 0 $.</p>
<p>拆开有$x ^3 + ( A + B + C ) x ^2 + ( AB + AC + BC ) x + ABC = 0 $.</p>
<p>这么对称,不妨猜一手Alice先选择$0 $,讨论一下:</p>
<ol>
<li>Bob令$ABC = 0 $.不妨令$C = 0 $.</li>
</ol>
<p>此时方程变为$x ^2 + ( A + B ) x + AB = 0 $.直接秒了,随便选一个数就行(比如选$3 $,如果Bob令$AB = 3 $,就再选$4 $;如果令$A + B = 3 $,就再选$2 $)</p>
<ol>
<li>Bob令$A + B + C = 0 , C = - A - B $.</li>
</ol>
<p>不妨令$C ‘ = - C , D = AB $,则$AB + AC + BC = D - C ‘ ^2 , ABC = DC ‘ $.</p>
<p>接下来Alice要选择一个数字$k $,如果Bob又令$D - C ‘ ^2 = k $,发现在此时如果$k $是一个负的完全平方数,并且Alice接下来选择$0 $,当场就下班了.</p>
<p>所以不妨直接让$k = - n ^2 $,然后看当$DC ‘ = - n ^2 $的时候如何去解.此时有$AB ( A + B ) = n ^2 $.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择$- 3 ^2 \times 4 ^2 \times 5 ^2 $,这样就赢了.</p>
<ol>
<li>Bob令$AB + AC + BC = 0 , C = - \frac { AB  } { A + B  } $.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择$6 ^2 \times 7 ^3 $,两种情况如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) & = 0 \\
( x - 2 \times 6 ^2 \times 7 ^2 ) ( x + 3 \times 6 ^2 \times 7 ^2 ) ( x + 6 \times 6 ^2 \times 7 ^2 ) & = 0 
\end{aligned}</script><p>后来又找人讨论了一下这个是咋得出来的啊.考虑$ABC \ne 0 $,我们有的条件其实是$\frac { 1  } { A  } + \frac { 1  } { B  } + \frac { 1  } { C  } = 0 $.方程现在是$x ^3 + ( A + B - \frac { AB  } { A + B  } ) x ^2 - \frac { A ^2 B ^2  } { A + B  } = 0 $.不妨令$a = A + B , b = AB $,方程实际上是$x ^3 + ( a - \frac { b  } { a  } ) x ^2 - \frac { b ^2  } { a  } = 0 $.最好能让$a $小一点,因此我们不妨直接取$a = 1 $,此时$A = - n , B = n + 1 , C = n ( n + 1 ) $,只要能构造这样的两组$A , B , C $使得它们的$a _1 - \frac { b _1  } { a _1  } = - \frac { b _2 ^2  } { a _2  } $即可.直接造看上去没啥前途,但是不难发现$A = - nk , B = ( n + 1 ) k , C = n ( n + 1 ) k $依然合法.此时有$k _1 = a _1 , b _1 = - n ( n + 1 ) a _1 ^2 , k _2 = a _2 , b _2 = - n ( n + 1 ) a _2 ^2 $,我们有$a _1 ( n ^2 + n + 1 ) = - n ^2 ( n + 1 ) ^2 a _2 ^3 $.取$n = 2 $试试看!此时有$7 a _1 = - 36 a _2 ^3 $.取$a _2 = 7 , a _1 = - 6 ^2 \times 7 ^2 $,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4><p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外$3 $个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌$1 $个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5><p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4><p>有公式:</p>
<script type="math/tex; mode=display">
\sum _{ S \subseteq \{ 1 , 2 , \cdots , n \}  } ( P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 0 ) - P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 1 ) ) ^2 = 1</script><p>其中$f $是任意一个将$\{ 0 , 1 \} ^n \rightarrow \{ 0 , 1 \} $的函数,$\oplus $是二进制意义下的异或运算,$R $是$\{ 0 , 1 \} ^n $上的均匀分布,$R _i $表示第$i $位.再定义$\chi _S ( r ) = \prod _{ i \in S  } ( - 1 ) ^{ r _i  } $.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol>
<li><p>$\chi _S ( r ) \times \chi _S ( r ‘ ) = \chi _S ( r \oplus r ‘ ) $.</p>
</li>
<li><p>当$r \ne 0 $时,$\sum _{ S \subseteq \{ 1 , \cdots , n \}  } \chi _S ( r ) = 0 $.</p>
</li>
<li><p>$[ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] - [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 1 ] = ( - 1 ) ^{ f ( r )  } \chi _S ( r ) $.</p>
</li>
<li><p>证明原命题.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>(1)显然.</p>
<p>(2)也很经典,挑选一个$j $,使得$r _j = 1 $,然后所有的集合分为两类:一类是包含$j $,一类不包含,两类集合一一对应并且$\chi $互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到$P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 0 ) = \frac { 1  } { 2 ^n  } \sum _{ r  } [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] $,而$\sum _{ r  } [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] - [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 1 ] = \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) $,要证明的只是$\sum _{ S  } \frac { 1  } { 4 ^n  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 = 1 $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 \\
& = \sum _S \sum _{ r  } \sum _{ r '  } ( - 1 ) ^{ f ( r ) + f ( r ' )  } \chi _S ( r \oplus r ' ) \\
& = \sum _{ r  } \sum _{ r '  } ( - 1 ) ^{ f ( r ) + f ( r ' )  } \sum _S \chi _S ( r \oplus r ' ) \\
& = \sum _{ r  } 2 ^n & = 4 ^n 
\end{aligned}</script><p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4><p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于$50 \% $.</p>
<h5><span id="solution5">Solution5</span></h5><p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数$x $,然后随机一只手,看上面的数字$a $,如果$a \geq x $就认为$a $大,反之认为$b $大.只要随机到一个区间内的实数的概率不为$0 $即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4><p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5><p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令$p $为素数,把整个图形放大$p $倍(也就是长度$1 $变成长度$p $).下面把每个交叉点$( x , y ) $换成其整数部分$( \lfloor x \rfloor , \lfloor y \rfloor ) $,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被$p $整除.这样这个新的大矩形的面积也能被$p $整除,所以它的有一边长能被$p $整除.这条边只是被换成了它长度的整数部分,所以变化不超过$1 $,所以在放大之前这条边的长度和某个整数相差不超过$1 / p $.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有$2 $条边或者$4 $条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点$( x , y ) $染色:如果$x $是整数,染X颜色.如果$x $不是整数但$y $是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为$[ 0 , a ] \times [ 0 , b ] $,并假设$b $不是整数.把所有小矩形的下边界去掉,然后令$f ( t ) $为所有上边界$y $坐标不是整数,并且与直线$y = t $相交的小矩形的$x $方向边长之和.那么$f ( 0 ) = 0 $,而且当$f ( t ) $变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以$f ( b ) $是整数.而因为$b $不是整数,$f ( b ) $就是最靠上的所有小矩形的宽之和,等于$a $,所以$a $是整数.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划相关</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2><h3><span id="分析状态">分析状态</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个$[ 1 , m ] $中的数字,然后进行以下判断:</p>
<ol>
<li><p>如果当前序列末尾两个数字相同且小于$t $,假设都是$x $,那就将它们都删去,加入一个$x + 1 $.</p>
</li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为$n $,终止操作.</p>
</li>
</ol>
<p>给定$n , m , t $,求最终序列的元素和的期望.</p>
<p>$n , m \leq 10 ^3 , t \leq 10 ^9 $.</p>
<p>首先$t \leq 10 ^9 $显然是没用的,因为它最多也就能这么凑:$m + n - 2 , m + n - 3 , \cdots , m , m $,合成一个$m + n - 1 $,因此我们令$t = \min \{ t , m + n - 1 \} $即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置$i $,有$a _i &lt; a _{ i + 1  } $,那么无论后面怎么做,这里的$a _i $都必不可能被删除.以此,我们不妨设$f _{ i , j  } $表示序列长度为$i $,序列开头元素为$j $的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过$t $,另一个是序列的长度不能超过$n $.我们不妨设$ans _{ n , t  } $表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移$ans $需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下$ans _{ n , t  } $,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有$ans _{ n , t  } = \sum _{ x = 1  } ^t E ( n 个 位 置 , 第 一 个 位 置 是 x 并 且 没 有 被 删 去 ) $.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:$3 , 3 , 3 $,最终的答案应该是$4 , 3 $.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了$3 , [ 3 , 3 ] $,最终的答案就变成了$3 , 4 $.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设$g _{ i , j  } $表示当前后面还有$i - 1 $个位置,当前前面已经放好了一个$j $,这个$j $不能被删掉的期望,显然有$ans _{ n , t  } = \sum _{ x  } ^t g _{ n , x  } P ( 最 终 序 列 中 , 这 里 是 k ) $,问题只在于如何求$g $.这个$g _{ n , k  } $是钦定了这个位置放$k $的期望,后面我们需要将它乘上这个位置放$k $的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个$g _{ n , k  } = ( k + \sum _{ j \ne k  } g _{ n - 1 , j  } ) $.但是实际上这个是不对的.这里的$k $不能删掉不意味着后面的$j $不能删掉,事实上后面的$j $爱怎么删怎么删,只要不搞出一个$k $来就可以.因此我们需要设$f _{ i , j  } $表示当前后面还有$i $个位置,第一个位置不能是$j $,也不能曾经是$j $(因为这里只要是$j $都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设$f _{ i , j  } $表示后面还有$i $个位置,第一个位置现在或曾经是过$j $的期望.那么全集是什么呢?全集是$ans _i $.</p>
<p>还没完啊,我们还需要求一下这里是$k $的概率,由于还有一个类似的$f $,我们还要求一下这里曾经是$k $的概率.设前者为$q _{ i , k  } $,后者为$p _{ i , k  } $.我们来强调一下这里设计的原则:这里的$p $其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了$k $,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过$k $了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是$k $等价于这里是$k $并且后面没有出现过$k $,也就是$q _{ i , k  } = p _{ i , k  } ( 1 - p _{ i - 1 , k  } \times [ k &lt; t ] ) $.这里加一个限制是因为有不能超过$t $的限制.</p>
<p>对于后者,这里的$k $有很多种可能出现过,一种是直接加入,一种是合并而来,于是$p _{ i , k  } = \frac { 1  } { m  } [ k \leq m ] + p _{ i , k - 1  } p _{ i - 1 , k - 1  } $.</p>
<p>因此我们几经辗转,终于得到了$g $的转移式子:</p>
<script type="math/tex; mode=display">
q _{ i , k  } g _{ n , k  } = p _{ i , k  } ( k + ans _{ i - 1  } - f _{ i - 1 , k  } p _{ i - 1 , k  } )</script><p>就差$f $了.$f $有两种可能:要么最后仍然是$k $,要么这个$k $已经被杀掉了.于是:</p>
<script type="math/tex; mode=display">
p _{ i , k  } f _{ i , k  } = q _{ i , k  } g _{ i , k  } + ( p _{ i , k  } - q _{ i , k  } ) f _{ i , k + 1  }</script><h5><span id="example2cf1007e">Example2(CF1007E)</span></h5><p>首先我们需要发现一个很强的性质:作用到了第$i $个站台就会清空前面所有站台.清空后就和$a _i $无关了,而如果还没涉及到一定和$a _i $有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设$f _{ i , j  } $表示只考虑前$i $个站台,要撑$j $个单位时间需要的最少火车数量.$g _{ i , j  } $表示只考虑前$i $个站台,要撑$j $个单位时间,并且$[ 1 , i - 1 ] $全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为$+ \infty $表示无法满足(对于全局,我们在$n + 1 $处放一个$a = + \infty , b = 0 , c = + \infty $来保证一定会满载).为什么需要$g $作为辅助dp数组呢?我们先对着$f $分析.</p>
<p>考虑$f _{ i , j  } $的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前$j $轮中根本没接走站台$i $的人.此时需要满足$f _{ i - 1 , j  } \ne + \infty \land a _i + j \times b _i \leq c _i $.那么这里怎么更新$g $呢?设$L = sa _{ i - 1  } + sb _{ i - 1  } \times j $,显然$g _{ i , j  } = \lceil \frac { L  } { K  } \rceil $,并且需要保证此时没有用到$i $以后的站台,因此需要保证$\lceil \frac { L  } { K  } \rceil K \leq sa _{ i  } + sb _i \times j $.注意到由于这里保证了$f _{ i - 1 , j  } $是可以取到的,因此我们可以撑到第$j $秒,剩下的火车在$j + \varepsilon $秒全选.</p>
<p>第二种,前$j $轮中有火车接走站台$i $的人.设最后一次是在$r $时间接走的站台$i $,那么此时必然清空了$[ 1 , i - 1 ] $,这里用了$g _{ i , r  } $.然后为了防止这里在$[ r + 1 , j ] $这段时间中爆掉,因此还需要$w = \lceil \frac { \max \{ 0 , rem + ( j - r ) b _i - c _i \}  } { K  } \rceil $,其中$rem $是$r $时刻$i $剩下的人数.这些火车都要在$r $时刻之前解决(因为我们设了最后一次在$r $时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在$r $这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有$wK \leq rem $.但是,接下来在$[ r + 1 , j ] $时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设$f _{ i , j , 0  } $表示只考虑前$i $个站台,要撑$j $个单位时间需要的最少火车数量,但是$[ 1 , i ] $都被清空为$0 $过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol>
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p>
</li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将$g _{ 1 , t , 0 / 1  } $全部设为$0 $,因为我觉得无论如何$0 $位置都是清空的,但实际上这是错误的!因为在$t $时刻的$1 $位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前$i $个的合法性,并且如果我们想要让$i $位置合法,一定要求让$[ 1 , i - 1 ] $合法.</p>
</li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从$r \rightarrow t $这个过程中会积累的量,这些量必然要在$r $时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p>
</li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3><h5><span id="example1">Example1</span></h5><p>定义一个有根树为大菊花,当且仅当这棵树的根的度数$\leq m \land \nexists x \ne root , \deg ( x ) &gt; 2 $.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.$( n \leq 5 \times 10 ^5 , m \leq 50 ) $</p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到$O ( nm ^2 ) $.</p>
<p>注意到这个背包是可删除的,所以就能做到$O ( nm ) $.</p>
<h3><span id="dp分界点">dp分界点</span></h3><h4><span id="example12022zrtg十连测day7-permutation">Example1(2022zrtg十连测day7 Permutation)</span></h4><p>首先注意到$[ 3 , n ] $一定会被分成两段递减的序列,分别跟在$1 $和$2 $的后面,假设$1 $在$2 $前面,这样算出答案后乘以$n $即可.</p>
<p>注意到$i + 1 $一定可以放到$i $的前面,设$f _i $表示在$i $和$i + 1 $之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即$i $的倍数$\pm 1 $之类的,于是可以实现,复杂度$O ( n \ln n ) $.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3><h4><span id="example1cf1666e">Example1(CF1666E)</span></h4><p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i $条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i $表示第$i $个分界点可能的最小值,$g _i $表示第$i $个分界点可能的最大值.假设我们目前二分的最大值要小于等于$mx $,最小值要大于等于$mn $,那么我们有转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1  } & = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } & = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}</script><p>注意到$f $与$g $的转移是无关的,而显然对于第$i $个分界点,它可以取$[ f _i , g _i ] $中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans _{ i  } $表示第$i $条分界线是啥,那么我们$ans _i $是可以取$[ ans _{ i + 1  } - mx , ans _{ i + 1  } - mn ] $中的任何一个数字的,我们将其和上面求出的$[ f _i , g _i ] $求一下交集.如果交集为空,说明要么$ans _{ i + 1  } - mn &lt; f _i , f _{ i + 1  } &lt; ans _{ i + 1  } &lt; f _i + mn $,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差$\leq mx - mn $.</p>
<h3><span id="数位dp">数位dp</span></h3><h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4><p>首先设$f _{ i , j  } $表示长度为$i $的,以$S [ n - j + 1 . . . n ] $为子序列的字符串个数.</p>
<p>考虑按位处理,每次将$T $的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出$k $.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为$k $.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4><p>第一反应就是枚举$x ‘ $和$y ‘ $,然后用数位dp枚举$d $使得$x = dx ‘ , y = dy ‘ $.</p>
<p>但是有一个问题在于如果$\gcd ( x ‘ , y ‘ ) \ne 1 $怎么办,这样有可能会算重.我们发现我们只判断$\gcd ( x ‘ , y ‘ ) = 1 $的情况就行,然后写一个$2 ^8 $判断$x ‘ , 2 x ‘ , 3 x ‘ , 4 x ‘ $以及对应的$y ‘ $出现了没有.复杂度$( 9 ^4 \times 2 ^8 \times \log _{ 10  } n ) $,有点难过.</p>
<p>但是我们发现这个$2 ^8 $可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有$3 ^4 \times 2 $的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3><h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4><p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是$O ( nd ^2 ) $的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是$O ( nd ) $的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取$\min $转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3><h4><span id="example1">Example1</span></h4><p>现在有一个$[ 1 , n ] $的排列,现在要从中选出一个集合$S $,满足$\forall x \in S , 2 x \notin S , 3 x \notin S $,求方案数.</p>
<p>首先考虑将每个数分解为$a \times 2 ^b \times 3 ^c $的形式,显然$a $不相同的数之间互不干扰.</p>
<p>对于$a $相同的一群数,我们考虑将$( b , c ) $作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3><h4><span id="example1">Example1</span></h4><p>$n $个点的树,一开始位于一号点,每个点有一个颜色($0 $或$1 $),每次随机选择一个点$v $,从当前所在点移动到$v $并将$v $的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为$1 $,当然不为$1 $也能做).</p>
<p>$n \leq 100000 $.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是$1 $还是$0 $就可以.不妨设$f _{ i  } $表示当前有$i $个点是$1 $,最后全$1 $或者全$0 $所需要的期望步数,显然$f _0 = f _n = 0 $,$f _{ i  } = \frac { 1  } { 2  } ( f _{ i + 1  } + f _{ i - 1  } ) + 1 $.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在$u $,只要当前没有结束,我们还要选点$v $,对答案的期望的贡献就是$u $到这棵树上所有点的距离之和除以$n $,而这是一个定值.也就是说,只要我们统计一下到了每个点$u $多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设$f _{ i , j , 0 / 1  } $表示当前场面上有$i $个$1 $,$j $号点这里是$0 $还是$1 $,它在结束前能被期望选多少次,注意$f _{ n / 0 , j , 0 / 1  } = 0 $.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设$f _{ i , 0 / 1  } $表示当前有$i $个$1 $,$0 / 1 $染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ 0 / n , 0 / 1  } & = 0 \\
f _{ i , 0  } & = \frac { i  } { n  } f _{ i - 1 , 0  } + \frac { n - i - 1  } { n  } f _{ i + 1 , 0  } + \frac { 1  } { n  } ( f _{ i + 1 , 1  } + [ i + 1 \ne n ] ) \\
f _{ i , 1  } & = \frac { i - 1  } { n  } f _{ i - 1 , 1  } + \frac { n - i  } { n  } f _{ i + 1 , 1  } + \frac { 1  } { n  } ( f _{ i - 1 , 0  } + [ i - 1 \ne 0 ] ) 
\end{aligned}</script><p>为啥最后加上了$[ i + 1 \ne n ] $呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了$f _{ i , 0 / 1  } $和$f _{ i - 1 , 0 / 1  } $,我们发现我们可以用这两个方程求出$f _{ i + 1 , 0 / 1  } $,然后就比较典了:我们将所有的函数表示成$af _{ 1 , 0  } + bf _{ 1 , 1  } + c $的形式(之所以这么表示,是因为我们架设了$f _{ 1 , 0 / 1  } $已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出$f _{ n , 0 / 1  } $,而$f _{ n , 0 / 1  } $我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3><h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4><p>首先注意到,$a _i = 1 $的时候和$a _i \ne 1 $的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设$f _i $为$a _i = 1 $,而其他$a $全都为$0 $时的答案,不难发现最后的答案也就是$\sum { a _i f _i  } $.</p>
<p>而上面的转移自然是:$f _i = \min \{ b _i , w + \sum _{ j = l  } ^r f _j \} $.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次$f _i $最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查$\log n $次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3><h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5><p>考虑组合意义,$\sum a _i ^2 $的意义也即满足操作序列$u $和操作序列$v $的最终结果相同的二元组$( u , v ) $的数量.</p>
<p>不妨设$dp _{ i , j , k  } $为第一个装置上方已经动了$i $个珠子,下放动了$j $个珠子,第二个装置上方动了$k $个珠子,下方动了$i + j - k $个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然$dp _{ n , m , n  } $即答案.</p>
<h5><span id="example2">Example2</span></h5><p>求长度为$n $的排列的$( \sum _{ i = 2  } ^{ n - 1  } [ a _i &lt; a _{ i - 1  } \And a _i &lt; a _{ i + 1  } ] ) ^k $的期望$( n \leq 10 ^9 , k \leq 500 ) $.</p>
<p>$O ( n ^2 k ^2 ) $是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是$\sum ans ^k $,而加入$1 $的时候,对于每个长度为$n - 1 $的排列,有$( n - 2 - 2 ans ) $个位置加入后会使答案加一,那我们要求的也就是:</p>
<script type="math/tex; mode=display">
\sum ( n - 1 - 2 ans ) ( ans + 1 ) ^k + \sum ( 2 ans + 2 ) ans ^k</script><p>推一推式子就可以做到$O ( nk ^2 ) $,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,$ans ^k $等价于从所有的地方中可重复地选出$k $个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为$1 $的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设$f _{ i , j  } $表示已经选了$i $段波动序列,其中有$j $个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度$O ( k ^3 ) $.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3><h4><span id="example1">Example1</span></h4><p>求$\sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( a _i \oplus a _j ) ^2 $,$n \leq 10 ^5 $,$a _i \leq 10 ^9 $.</p>
<p>考虑设$f _i $表示只考虑前$i $低的位置,高位全部默认为$0 $的方案数.如果我们设$cnt _i $表示$a $中第$i $位为$1 $的数个数,那根据$( a + b ) ^2 = a ^2 + 2 ab + b ^2 $,我们只需要求出$g _{ i  } $表示只考虑前$i $低的位置,第$i + 1 $位是$1 $的数和第$i + 1 $位是$0 $的数两两异或之和,显然有$f _i = f _{ i - 1  } + 2 cnt _i \times 2 ^i \times g _{ i - 1  } + cnt _i 2 ^{ i + 1  } $.</p>
<p>$g $可以用$O ( n \log a ) $的复杂度求,这样总复杂度$O ( n \log ^2 a ) $.</p>
<h3><span id="线头dp">线头dp</span></h3><h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5><p>令$dp _{ i , j , k  } $表示目前倒到第$i $个水杯,前面还有$j $个延续过来的未结束的线头,目前已经选定了$k $个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是$O ( n ^5 ) $的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了$O ( n ^4 ) $的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5><p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设$dp _{ i , 0 / 1 / 2  } $表示前$i $个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212-svjetlo">Example3([COCI2020-2021#2] Svjetlo)</span></h5><p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设$dp _{ u , 0 / 1 , 1 / 2  } $为$u $的状态为$0 / 1 $,以$u $为根的子树内有$1 / 2 $个线头的方案数.注意如果子树内有$0 / 2 $个线头,那么会在$u $处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此$dp _{ u , s , 2  } $的两个接头实际上一个位于$u $,另一个位于$u $的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5><p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设$dp _{ i , j , k  } $表示目前走到$i $,前面分成$j $组,总贡献不超过$k $的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489-jtravel-in-sugar-country">Example5([XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain contest 1489) J]Travel in Sugar Country)</span></h5><p>一条线段上有$n ( \leq 100 ) $个商店,要从中选出$k ( \leq 10 ) $个不同的商店$s _1 , s _2 , \cdots , s _k $,使得按顺序遍历这$k $个商店的路径长度是$m ( \leq 30 ) $的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设$dp _{ i , j , w , l  } $表示目前在判断了$i $个商店,选了$j $个,并且目前整个图有$w $条”路径”(连续走动),走过的路在$\bmod m $一意义下为$l $的方案数.最后的答案就是$dp _{ n , k , 1 , 0  } $.</p>
<p>首先,我们对每个点求出$D ( 1 , x ) $,然后$D ( x , y ) = | D ( 1 , y ) - D ( 1 , x ) | $,不难发现$x $越大$D ( 1 , x ) $越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的$D $和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径($s _1 \rightarrow s _1 $),接下来,我们每插入一个点$x $,我们考虑它的贡献:</p>
<ol>
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是$- 2 D ( 1 , x ) $,对方案数的贡献为$1 $.</p>
</li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为$0 $.</p>
</li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为$2 D ( 1 , x ) $.</p>
</li>
</ol>
<p>这样我们就做到了$O ( n ^4 km ) $的复杂度.如果我们加两维$0 / 1 $表示目前起点和终点是否加入,就可以把复杂度优化到$O ( n ^2 km ) $.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3><p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4><p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3><p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4><p>先考虑数字两两不同的时候怎么做,我们先找到$A $中的全局最大值所在位置和$B $中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时$A $取出的数量和$B $的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把$B $序列分成两部分,这两部分将由$A $中相等的两部分分别生成.不妨假设这个全局最大值的位置是$x $,那么对于$[ 1 , x ] $这一段的$A $生成的$B $数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的$A $能生成的$B $的数量.对于$[ 1 , x + 1 ] $则任意.</p>
<p>那么我们所需要做的就是求出$A $的某一段删掉若干次最大值后的序列所能生成的$B $的数量.不妨设$dp _{ l , r , i  } $表示$[ l , r ] $中所有$\leq i $的数字组成的序列所能生成的数量.</p>
<p>如果$[ l , r ] $这段区间中没有数字$i $,那显然$dp _{ l , r , i  } = dp _{ l , r , i - 1  } $,不然,我们可以枚举两端分开的位置,那这个位置一定在数字$i $的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4><p>注意到第$n $个元素一定是山峰.所以我们考虑用第$n $个元素分割整个区间为两部分.</p>
<p>设$f _n $为$n $个元素且开头为山谷的答案.枚举第$n $个元素在位置$k $($k - 1 $是奇数),则$f _k f _{ n - 1 - k  } \binom { n - 1  } { k  } \rightarrow f _n $.</p>
<h4><span id="example3">Example3</span></h4><p>给定数组$a $,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.$n \leq 500 $.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设$f _{ l , r  } $为将$[ l , r ] $删干净后再去删$a _{ l - 1  } , a _{ r + 1  } $的方案数,然后枚举$[ l , r ] $中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairing-points">Example4([AGC039E] Pairing Points)</span></h4><p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从$1 $号点这里断开,枚举$1 $号点连接哪个点,然后就可以让$( 2 , 2 n ) $这些点断开了.我们设计$f _{ i , j , k  } $或$[ i , j ] ( k ) $表示区间$[ i , j ] $中的$k $向外连了一条边.答案是枚举$1 $号点连了哪个点,也就是$\sum _{ i = 3  } ^{ 2 n - 1  } f _{ 2 , 2 n , i  } $.</p>
<p>于是我们现在的问题在于如何求$f _{ i , j , k  } $.由于边要联通,所以与$k $相连的这条边必然被$[ i , j ] $中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为$x \leftrightarrow y $.这样整个区间被分为了两个部分:$[ i , k ] ( x ) , [ k , j ] ( y ) $.但是问题并没有得到解决.因为$[ i , x ] $和$[ y , j ] $之间的确不可能出现连边了,但$[ x , k ] $和$[ k , y ] $之间仍然可能出现连边.但我们发现:在$[ i , k ] $中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为$p , q $.现在整个区间被分为了三个部分:$[ i , p ] ( x ) , [ p , q ] ( k ) , [ q , j ] ( y ) $,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-and-remove">Example5([AGC035D] Add and Remove)</span></h4><p>首先自然想到区间dp.但是难以处理的是如果一个区间$[ l , r ] $中间删掉一个点$p $之后,$[ l , p - 1 ] $和$[ p + 1 , r ] $会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到$[ l + 1 , r - 1 ] $中最后删除的点$p $,这样区间$[ l , r ] $的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除$[ l + 1 , p - 1 ] $的时候,对$p $产生的贡献和删除$[ p + 1 , r - 1 ] $的时候对$p $的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设$a _l $贡献了$x $倍,$a _r $贡献了$y $倍,那么由于$a _p $会两边都贡献到,所以$a _p $会对答案贡献$x + y $倍.</p>
<p>于是设计一个dp是:$f _{ l , r , x , y  } $表示删除$[ l + 1 , r - 1 ] $后,$xa _l + ya _r $最小是多少.自然有$f _{ l , r , x , y  } = \min \{ f _{ l , p , x , x + y  } + f _{ p , r , x + y , y  } + ( x + y ) a _p \} $.</p>
<p>至于复杂度,前两维肯定是$n ^2 $的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移$n $层,因此是$2 ^n $的空间,于是时间复杂度不会超过$O ( n ^3 2 ^n ) $,其实经过一些奇怪计算应该是不会超过$O ( 2 ^n ) $的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4><p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设$f _{ l , r  } $表示删除$[ l , r ] $区间的代价.接下来我们无非要枚举$k $,使得$k $是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如$l $,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果$a _l = a _k $,那么这等价于$f _{ l + 1 , k - 1  } + [ l = k - 1 ] + f _{ k + 1 , r  } $.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4><p>首先考虑一下$m = 2 ^k - 1 $的情况,首先我们要判断有几个数最高位是$1 $,然后接下来判断第二位哪些数字是$1 $.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是$1 $的就一定大于最高位是$0 $的了,这两个区间就没有影响了.因此可以设$f _{ l , r , k  } $表示$[ l , r ] $这个区间,前面已经有了$k $个$1 $的最大贡献.</p>
<p>那么对于$m \ne 2 ^k - 1 $的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过$m $就行了.</p>
<h3><span id="相互独立">相互独立</span></h3><h5><span id="example12019zrtg十连测day1-origami">Example1(2019zrtg十连测day1 origami)</span></h5><p>看上去很不好做,先考虑宽为$1 $怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间$[ l , r ] $,然后看$[ 1 , l - 1 ] $和$[ r + 1 , m ] $能不能折进来.也就是判断以$r $和$r + 1 $为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设$f _i $表示能不能折成以$[ 1 , i ] $为最下层,$g _i $表示能不能折成$[ i , n ] $为最下层,那$[ l , r ] $能折出来当且仅当$f _r = g _l = 1 $,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-an-edge">Example2(CF1616G Just Add an Edge)</span></h5><p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如$1 \rightarrow x \cup y \rightarrow n $,并且$1 \rightarrow x $和$y \rightarrow n $不交,然后添加边$x \rightarrow y $.</p>
<p>那么什么时候$1 \rightarrow x $和$y \rightarrow n $没有交并且他们的并是$[ 1 , n ] $呢?考虑将$1 \rightarrow x $这条路径上的点染色为$0 $,$y \rightarrow n $上的点染色为$1 $,由于边只有从前往后的,因此$[ 1 , y - 1 ] $必然为$0 $,$[ x + 1 , n ] $必然为$1 $.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了$y $,现在想要找到$x $,我们现在假设染色的末尾是$( i , i + 1 ) $,也就是$i $染色和$i + 1 $的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个$p $,满足$p \nrightarrow p + 1 $,那么$p $和$p + 1 $永远不可能染同种颜色,我们直接以它为断点,自然发现$p $的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了$p \rightarrow p + 1 $这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立$0 $和$n + 1 $两个虚点,向所有点连边.</p>
<p>总之$O ( nm ) $的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3><p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5><p>首先考虑已知一个序列,如何快速求它最后有几个位置不是$0 $.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其$- 1 $并重复判断操作,直到为$0 $或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是$0 $相当于判断后面的已知序列的$mex $,这个要记入状态中,于是考虑设$dp _{ i , j  } $表示当前到了第$i $个位置,后面的数的$mex - 1 $是$j $的方案数.</p>
<p>但是如果直接这么设会发现,当前$i $的加入有可能会改变$mex $的值,而这个改变是很难处理的,因为如果$i $位置选择了$j + 1 $这个数字,那么$mex $要向上伸展到某一个值,而如果不选择$j + 1 $,也有可能选择一个更大的值后不断落到$j + 1 $,这意味着我们转移时需要枚举补上$j + 1 $这个数字后的$mex $并用刷表法转移.</p>
<p>不妨设这个数字是$k $.如果我们插入一个数字后直接更新当前的答案,可以发现这个$k $是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起$mex $的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全$[ j + 2 , k ] $这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以$2 ^{ n  } $.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5><p>$O ( n ^3 ) $的暴力是显然的:设$f _{ i , j , k  } $表示目前考虑到第$i $个位置,前面还有$j $个A,已经选了$k $个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到$n ^2 $.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设$f _{ i , j  } $表示目前考虑到$i $,还需要$j $个B才能凑齐$c _B $个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3><h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5><p>设$f _{ i , j  } $表示长度为$i $,开头为山峰且高度为$j $的方案数;$g _{ i , j  } $表示长度为$i $,开头为山谷且高度为$j $的方案数.注意到这俩显然是一个双射,也就是$f _{ i , j  } = g _{ i , i - j + 1  } $.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于$j $的数都向上平移一格,于是自然有:$f _{ i , j  } = \sum _{ k = 1  } ^{ j - 1  } g _{ i - 1 , k  } = \sum _{ k = 1  } ^{ j - 1  } f _{ i - 1 , i - k  } $.</p>
<p>另外,这个式子可以稍微转化为:$f _{ i , j  } = f _{ i - 1 , i - j + 1  } + f _{ i , j - 1  } = g _{ i - 1 , j - 1  } + f _{ i , j - 1  } $.</p>
<p>上式可以这么理解:我们讨论一下$j $和$j - 1 $是否相邻,如果相邻必然是$j $是山峰,$j - 1 $是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1-group">Example2(2019zrtg十连测day1 group)</span></h5><p>首先注意到$2 k \leq n \land nk \leq 10 ^5 $,不难发现$k \leq 500 $.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到$O ( nk ^2 ) $.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点$w $,使得成为组长的经验$\geq w $,成为组员的经验$\leq w $,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5><p>双序列计数,考虑把$x $双射到某个东西上.</p>
<p>考虑最后的图一定是个$DAG $,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设$dp _{ l , r , mx  } $表示只考虑$[ l , r ] $这一段的线段,然后最大值所在位置需要$\geq mx $的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3><p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweighted-increasing-subsequences">Example1([CF1621G]Weighted Increasing Subsequences)</span></h5><h2><span id="动态规划的优化">动态规划的优化</span></h2><h3><span id="递进转移">递进转移</span></h3><p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5><p>有$m $种礼物,每种礼物有无数个(有有限个也能做),$n $个朋友,第$i $个朋友喜欢第$j $个礼物的概率是$p _{ i , j  } $,$\forall i , \sum p _{ i , j  } = 1 $.</p>
<p>现在你可以选$n $件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p>$n \leq 3000 , m \leq 300 $.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出$g _{ i , j  } $表示第$i $种礼物一共选了$j $个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么$g $怎么求呢?这个是简单的,我们设$f _{ i , j  } $表示喜欢第$i $种礼物的人有$j $个的概率,不难发现$g _{ i , j  } = \sum _{ k = 0  } ^n \min \{ j , k \} f _{ i , k  } $.递推式就有$g _{ i , j  } = g _{ i , j - 1  } + \sum _{ k = j  } ^n f _{ i , k  } $.$f $同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是$O ( n ^2 m ) $的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现$g _{ i , j  } $满足四边形不等式,而其转移是经典的$k $点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于$g _i $是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为$c _i $,每次选当前$g _{ i , c _i + 1  } - g _{ i , c _i  } $最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为$c _i $越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度$O ( n ^2 \log n ) $,不太确定有没有$O ( n ^2 ) $的做法.</p>
<p>但是第二个背包,也就是$f $怎么求呢?我们发现我们没有必要把$g $全都求出来,只需要求目前需要的一部分就可以了,由于$\sum f = 1 $,因此后缀和可以改为前缀和,考虑到每往后推一位是$O ( n ) $的,但是只会往后推总共$O ( n ) $位,因此这里复杂度$O ( n ^2 ) $.</p>
<h5><span id="example2">Example2</span></h5><p>给一个字符串,求一个最大长度$L \leq \frac { n  } { 2  } $,使得前$L $个字符与后$L $个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<script type="math/tex; mode=display">
ABSBA</script><p>我们枚举$A $的长度,然后就只需要求$B $,设$f _{ i  } $表示字符串去掉开头和结尾的$i $个字符后的border,有$f _{ i - 1  } \leq f _i + 1 $.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3><p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4><p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k $暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取$\max $操作很艰难.但如果!我把这个dp反过来,我设$f _{ i , j  } $表示<strong>从后往前</strong>dp到$i $,当前的最大前缀和是$j $的概率是多少,这个dp的转移极其简单:</p>
<script type="math/tex; mode=display">
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  }</script><p>最后在$f _{ 1 , j  } $处乘上$h _j $.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g _{ i , j  } $表示如果初始只有$f _{ i , j  } = 1 $,dp到最后的答案是多少.于是只需要:</p>
<script type="math/tex; mode=display">
\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g _{ i , j  } \\

\end{gathered}</script><p>我认真考虑过这个$P $应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些$P $变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3><h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4><p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于$200 $.也就是说转移矩阵大概是$200 \times 200 $的,设状态数为$S $.</p>
<p>继续考虑,如果直接做的话复杂度是$O ( TS ^3 \log n ) $,过不了.</p>
<p>我们考虑将一个$n $在$w $进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了$O ( wS ^3 \log _w n + TS ^2 \log _w n ) $,平衡一下复杂度即可,大概取$w = 4 $会比较优秀.</p>
<h4><span id="example2noi-online3提高组魔法值">Example2([NOI Online#3提高组]魔法值)</span></h4><p>重新定义矩阵乘法:用$\oplus $替换原本的$+ $,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4><p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令$f _i = \sum _{ j , a _j = a _i - 1  } f _j $,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的$\sum $的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的$f $.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设$f _{ i , j  } $表示所有$a _x = i $的$x $中第$j $小的$x $的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4><p>注意到$m $和$k $很小,这一定是突破口.</p>
<p>又注意到如果$a _{ i + 1  } &gt; a _i $,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字$x + 1 $,我们考虑它只能插入$[ x + 1 - m , x ] $后面,我们直接用一个二进制数$S $表示$[ x + 1 - m , x ] $中的数字是否存在,然后就可以在转移上直接调用$popcount ( S ) $.设$dp _{ i , j , S  } $表示目前考虑完了数字$i $,插入了$j $个数字,存在情况是$S $.直接对它做矩阵加速就可以做到$O ( ( 2 ^m k ) ^3 \log n ) $.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4><p>设$dp _{ i , j  } $表示第$i $天走到城市$j $的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上$k $.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3><p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4><p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设$f _{ l , r  } $表示$a _l $和$a _r $必选的前提下,$[ l , r ] $这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设$dp _{ i , j  } $表示前$i $个点,最大值为$j $的方案数,不难发现最后一个矩阵的最小值一定是$a _{ i  } $.然后$dp _{ a , b  } = \sum _{ i &lt; a , j &lt; b  } dp _{ i , j  } f _{ i + 1 , a  } $.</p>
<p>这个转移是$n ^4 $的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到$n ^2 $,这样我们就得到了一个复杂度$O ( n ^3 ) $的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点$i $,它所在矩阵的最左边的点$k $,最右边的点$k $,然后此时的答案为$pre [ j - 1 ] [ a [ k ] - 1 ] \times nxt [ k + 1 ] [ a [ j ] + 1 ] \times f [ j ] [ i ] \times f [ i ] [ k ] $.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设$g _{ i , j  } $为接下来我们要选$[ i , j ] $,$i $是矩阵左端点,$j $任意且这两个点必在矩阵中,左右两边的方案数.初始条件$g _{ i , j  } = pre [ i - 1 ] [ a [ j ] - 1 ] \times nxt [ j + 1 ] [ a [ i ] + 1 ] $.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3><h4><span id="example2022zrtg十连测day7-zero">Example(2022zrtg十连测day7 Zero)</span></h4><p>设$k = \max \{ i , j \} $,首先可以求出$x , y , z $分别表示:</p>
<ol>
<li><p>$x $:只包含第一行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
<li><p>$y $:只包含第二行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
<li><p>$z $:同时包含两行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
</ol>
<p>那么自然有转移:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z , z ) + 1 \} 
\end{gathered}</script><p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到$f ( i , k ) $关于$i $不降,于是显然当$f ( i , y ) \ne f ( i , k - 1 ) $的时候才会由$f ( i , y ) + 1 $转移过来.我们不妨设$p _i $表示最小的位置满足$f ( i , p _i ) = f ( i , k - 1 ) $,那转移也就是$f ( i , k ) \leftarrow f ( i , k - 1 ) + [ p _i \leq y ] $.并且每进行一次转移,都会满足$p _i \leq y $的$p _i $设为$k $.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的$i $在当前$k $的$f $值,将这个点放到$p _i $位置上.然后我们每次找到$y $并把所有在$y $位置前的点都合并到$k $这个点上,并打一个加法$tag $,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的$p _k $.</p>
<p>最后还需要处理一下$f _{ k , k  } $,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照$\max \{ i , j \} $为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3><p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5><p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是$\nexists 1 \leq i &lt; j &lt; k \leq n $,$a _i &gt; a _j &gt; a _k $.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是$dp _{ i , j  } $表示现在做到$i $,另一个上升子序列的终点是$j $,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在$i $一定的情况下,$j $的值越小越容易满足.所以设$dp _i $表示一个上升子序列的终点是$i $,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5><p>首先自然的设计是$dp _{ l , r , u , d  } $,然后优化一下就是$O ( n ^4 ) $.然后咋做?</p>
<p>注意到答案不超过$\log $级别,所以设$dp _{ l , r , u , c  } $表示答案为$c $的时候,最大的$d $是多少.然后就$O ( n ^3 \log n ) $.</p>
<h5><span id="example3">Example3</span></h5><p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数$a _i $减去$[ 1 , a _i ] $中的一个数字,减成$0 $就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.$( n \leq 2000 ) $</p>
<p>先考虑一个$O ( n ^2 a ^2 ) $的dp,比较显然,因为一个人取数显然要么取$1 $要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设$dp _{ l , r , x , y  } $表示目前Alice在取第$l $堆,Bob在取第$r $堆,第$l $堆为$x $,第$r $堆为$y $的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把$a $存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是$1 $还是更大的数好像无所谓.那:如果$a _1 = x $的时候,Alice能赢,那$a _1 = x + 1 $的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选$1 $,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于$a _l $或$a _r $.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存$0 / 1 $是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设$dp _{ l , r  } $表示当前Alice在$l $,Bob在$r $,Bob还没动$a _r $的前提下,$a _l $至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较$dp _{ 1 , 1  } $和$a _1 $的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选$l $,Bob开始选$r $,那Alice的获胜条件显然是$dp _{ l , r  } \leq a _r $</p>
<p>如果可以全选(也就是Alice开始选$l + 1 $,Bob开始选$r $的时候Alice能赢),就直接让$dp _{ l , r  } = 1 $.不然,由于清空堆的人要输,所以Alice为了不输,必须要让$dp _{ l , r - 1  } $也满足条件,一个自然的想法是$dp _{ l , r - 1  } + a _r + 1 $,但是这个值好像没有必要:因为Bob并不是只有会不断清空$a _r $的,如果目前的$[ l + 1 , r ] $这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢$[ l + 1 , r ] $的值,Bob就必须全清空,所以如果我们设$g _{ l , r  } $是Bob的$dp $数组,那其实这里应该是$a _r + 1 + dp _{ l , r - 1  } - g _{ l + 1 , r  } $,因为Bob的策略一定是一步一步走到$g _{ l + 1 , r  } $后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5><p>自然的想法是$dp _{ i , j  } $表示$i $子树内划分成$j $个连通块是否合法,然后我们发现如果$j $满足条件,那么$j + 2 $一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3><p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于$y $轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5><p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3><p>能用WQS二分解决的问题通常形如:需要在$n $个物品中选择恰好$m $个,使得最后答案最大.并且如果令$f _i $表示选了$i $个的最大答案,$f _i $必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数$C $,每选择一个物品就减去$C $的答案.不难发现这样我们一定能逼近$f _m $.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3><p>对于定义在$\mathbb { Z  } $上的二元函数$w $,若对定义域上任意$a , b , c , d ( a \leq b \leq c \leq d ) $都有$w ( a , c ) + w ( b , d ) \leq w ( a , d ) + w ( b , c ) $,也就是交叉小于包含,则称函数$w $满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:$w $所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于$0 $.</p>
<p>如果它还满足$\forall 1 \leq l ‘ \leq l \leq r \leq r ‘ \leq n , w ( l , r ) \leq w ( l ‘ , r ‘ ) $，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理$\min $型dp的问题,对于$\max $型dp需要取相反数改成$\min $.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4><h5><span id="定理1">定理1</span></h5><p>若二元函数$w ( x , y ) $满足$w ( a , b ) + w ( a + 1 , b + 1 ) \leq w ( a , b + 1 ) + w ( a + 1 , b ) $.其中$a &lt; a + 1 \leq b &lt; b + 1 $,则$w $满足四边形不等式.</p>
<p>证明:</p>
<p>对于$a + 1 &lt; c $ 有</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) \\
w ( a + 1 , c + 1 ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\

\end{aligned}</script><p>同时有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) & \leq w ( a + 1 , c + 1 ) + w ( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) & \leq w ( a + 1 , c + 1 ) \\

\end{aligned}</script><p>联立得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) & \leq w ( a + 1 , c ) + w ( a + 2 , c + 1 ) 
\end{aligned}</script><p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个$2 \times 2 $的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5><p>若$w _1 ( l , r ) , w _2 ( l , r ) $满足四边形不等式(或区间包含单调性),则$\forall c _1 , c _2 \geq 0 $,$( c _1 w _1 + c _2 w _2 ) $满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5><p>若$\exists f ( x ) , g ( x ) $使得$w ( l , r ) = f ( r ) - g ( l ) $,则$w $满足四边形恒等式.当$f , g $单调递增时,$w $还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5><p>设$h $是一个单调递增的下凸函数(一阶导数单调递增),若$w ( l , r ) $满足四边形不等式和区间包含单调性,则复合函数$h ( w ( l , r ) ) $也满足四边形不等式和区间包含单调性.</p>
<p>令$l _1 \leq l _2 \leq r _1 \leq r _2 $,由于$w $满足四边形不等式,于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( l _1 , r _1 ) + w ( l _2 , r _2 ) & \leq w ( l _1 , r _2 ) + w ( l _2 , r _1 ) \\
0 & \leq w ( l _1 , r _1 ) - w ( l _2 , r _1 ) & \leq w ( l _1 , r _2 ) - w ( l _2 , r _2 ) 
\end{aligned}</script><p>令$t = w ( l _1 , r _2 ) - w ( l _2 , r _2 ) $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( l _1 , r _1 ) & \leq w ( l _2 , r _1 ) + t \\
w ( l _1 , r _2 ) & = w ( l _2 , r _2 ) + t \\
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq h ( w ( l _2 , r _1 ) + t ) - h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) & = h ( w ( l _2 , r _2 ) + t ) - h ( w ( l _2 , r _2 ) ) 
\end{aligned}</script><p>不妨令$\Delta h ( x ) = h ( x + t ) - h ( x ) $,由于$h $是下凸函数,所以$\Delta h $函数单调递增.</p>
<p>那么也就有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq \Delta h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) & = \Delta h ( w ( l _2 , r _2 ) ) 
\end{aligned}</script><p>由于$w ( l _2 , r _1 ) \leq w ( l _2 , r _2 ) $,所以$\Delta h ( w ( l _2 , r _1 ) ) \leq \Delta h ( w ( l _2 , r _2 ) ) $于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) \\
h ( w ( l _1 , r _1 ) ) + h ( w ( l _2 , r _2 ) ) & \leq h ( w ( l _1 , r _2 ) ) + h ( w ( l _2 , r _1 ) ) 
\end{aligned}</script><p>证毕.</p>
<h5><span id="定理5">定理5</span></h5><p>设$h $是一个下凸函数(一阶导数单调递增),若$w ( l , r ) $满足四边形恒等式和区间包含单调性,则复合函数$h ( w ( l , r ) ) $也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到$h $单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4><p>对于形如$f _i = \min _{ 1 \leq j &lt; i  } \{ f _j + w ( j , i ) \} $的状态转移方程,记$p _i $为$f _i $的最优决策.若$p $在$[ 1 , n ] $上单调不降,则称$f $具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的$\min $改为$\max $,并且把$+ w $改为$- w $,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5><p>定理：对于形如$f _i = \min _{ 1 \leq j &lt; i  } { f _j + w ( j , i )  } $的状态转移方程,若$w $满足四边形不等式,则$f $有决策单调性.</p>
<p>证明:</p>
<p>$\forall i \in [ 1 , n ] , \forall j \in [ 0 , p _i - 1 ] $,根据$p $的定义,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ p _i  } + w ( p _i , i ) & \leq f _j + w ( j , i ) \\
f _{ p _i  } - f _j & \leq w ( j , i ) - w ( p _i , i ) \\

\end{aligned}</script><p>而对于$k \in [ i + 1 , n ] $,根据$w $的四边形不等式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( j , i ) + w ( p _i , k ) & \leq w ( j , k ) + w ( p _i , i ) \\
w ( j , i ) - w ( p _i , i ) & \leq w ( j , k ) - w ( p _i , k ) \\

\end{aligned}</script><p>联立得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ p _i  } - f _j & \leq w ( j , k ) - w ( p _i , k ) \\
f _{ p _i  } + w ( p _i , k ) & \leq w ( j , k ) + f _j \\

\end{aligned}</script><p>即:$j $对$k $的更新一定不如$p _i $对$k $的更新更优,因此$p _k \in [ p _i , n ] $,因此$f $有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6><p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设$f _i $表示价值为$i $的答案,自然有:$f _i = \max \{ f _{ i - kc  } + sum _{ c , k  } \} $.</p>
<p>如果我们把$c $相同的分层,那这显然是一个最短路型dp,其中$w ( i , j ) = sum _{ c , \frac { i - j  } { c  }  } $.</p>
<p>显然这个转移只会让$\mod c $相同的相互转移,于是后面的$w ( i , j ) $可以理解为一段数字的和,自然满足四边形不等式($\max $也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5><p>对于形如$f _{ x , j  } = \min _{ i = 1  } ^{ x - 1  } \{ f _{ i , j - 1  } + w _{ i , x  } \} $的状态转移方程,若$w $满足四边形不等式,则$f $有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如$f _x = \min _{ i = 1  } ^{ x - 1  } { w _{ i , x  }  } $,我们也可以看作$k $点最短路型的$k = 1 $的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6><p>令$f ( i , j ) $为在第$j $个位置建造第$i $个基站的代价最小值,那么我们有转移:</p>
<script type="math/tex; mode=display">
f ( i , j ) = \min _{ 1 \leq k < j  } \{ f ( i - 1 , k ) + \sum _{ l = k + 1  } ^{ j - 1  } w _l [ d _l - s _l > d _k ] [ d _l + s _l < d _j ] + c _j \}</script><p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时$d _k $单调递增,更新答案时$d _j $单调递增,于是可以直接使用线段树维护,复杂度$O ( nk \log n ) $.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度$O ( nk \log ^2 n ) $.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度$O ( n \log k \log n ) $.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6><p>自然的设计是$f _{ i , j , k  } $表示前$i $个,已经打了$j $个,末尾有连续$k $个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为$f _{ i , j  } $表示前$i $个,目前打了$j $个且第$i $个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成$f _{ i , j  } $表示前$i $个,目前有$j $个没打中而且第$i $个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:$dp _{ i , j  } = \max \{ dp _{ k , j - 1  } + \sum _{ l = k + 1  } ^{ i - 1  } C _{ l - k  } A _l + P \} $.</p>
<p>令$w ( l , r ) = \sum _{ k = l + 1  } ^{ r - 1  } C _{ k - l  } A _k + P $,接下来我们证明:$w ( l + 1 , r ) + w ( l , r - 1 ) \geq w ( l , r ) + w ( l + 1 , r - 1 ) $即可.讨论一下每个$A $面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5><p>引理:在状态转移方程$f _{ i , j  } = \min _{ i \leq k &lt; j  } \{ f _{ i , k  } + f _{ k + 1 , j  } + w ( i , j ) \} $中(通常$f _{ i , i  } = w ( i , i ) = 0 , f _{ i , i + 1  } = w _{ i , i + 1  } $),如果$w $满足四边形不等式和区间包含单调性,那么$f $也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明$f _{ i , j  } + f _{ i + 1 , j + 1  } \leq f _{ i , j + 1  } + f _{ i + 1 , j  } $即可,考虑$j - i = 1 $的时候,显然成立.</p>
<p>使用数学归纳,假设当$b - a &lt; k $时,$f $满足四边形不等式,考虑$j - i = k $的情况:</p>
<p>设$f _{ i , j + 1  } $的最优决策为$x $,$f _{ i + 1 , j  } $的最优决策为$y $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j + 1  } + f _{ i + 1 , j  } & = f _{ i , x  } + f _{ x + 1 , j + 1  } + w ( i , j + 1 ) + f _{ i + 1 , y  } + f _{ y + 1 , j  } + w ( i + 1 , j ) \\

\end{aligned}</script><p>对于$f _{ i , j  } $和$f _{ i + 1 , j + 1  } $来说,$x $和$y $不一定最优,所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } & \leq f _{ i , x  } + f _{ x + 1 , j  } + w ( i , j ) + f _{ i + 1 , y  } + f _{ y + 1 , j + 1  } + w ( i + 1 , j + 1 ) \\

\end{aligned}</script><p>$w $和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } & \leq f _{ i , j + 1  } + f _{ i + 1 , j  } \\

\end{aligned}</script><h6><span id="定理">定理</span></h6><p>记$p _{ i , j  } $为$f _{ i , j  } $的最优决策,若$f $满足四边形不等式,那么对于$\forall i &lt; j ， 有 p _{ i , j - 1  } \leq p _{ i , j  } \leq p _{ i + 1 , j  } \ $.</p>
<p>证明:</p>
<p>记$p = p _{ i , j  } $,$\forall k , i &lt; k \leq p $,因为$f $满足四边形不等式,所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , k  } + f _{ i + 1 , p  } & \leq f _{ i , p  } + f _{ i + 1 , k  } \\
f _{ i + 1 , p  } - f _{ i + 1 , j  } & \leq f _{ i , p  } - f _{ i , k  } 
\end{aligned}</script><p>根据$p $定义,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , p  } + f _{ p + 1 , j  } & \leq f _{ i , k  } + f _{ k + 1 , j  } \\
f _{ i , p  } - f _{ i , k  } & \leq f _{ k + 1 , j  } - f _{ p + 1 , j  } 
\end{aligned}</script><p>由上两式移项联立,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1 , p  } - f _{ i + 1 , k  } & \leq f _{ k + 1 , j  } - f _{ p + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } & \leq f _{ i + 1 , k  } + f _{ k + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } + w _{ i + 1 , j  } & \leq f _{ i + 1 , k  } + f _{ k + 1 , j  } + w _{ i + 1 , j  } \\

\end{aligned}</script><p>因此对于$f _{ i + 1 , j  } $,$p $比任意的$k &lt; p $更优,因此$p _{ i + 1 , j  } \geq p _{ i , j  } $,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4><p>判断一个函数的凸性只需判断$f ( k ) + f ( k + 2 ) \geq 2 f ( k + 1 ) $,而这只需证明$k $的时候的答案和$k + 2 $时的答案可以调整出两个$k + 1 $的答案(不一定是最小答案)并且这两个$k + 1 $的答案的和小于等于$k $时和$k + 2 $时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5><p>首先考虑四个点$( a , b , c , d ) $,注意到其一定满足四边形不等式,也就是$w _{ ac  } + w _{ bd  } \geq w _{ ad  } + w _{ bc  } $.</p>
<p>我们现在想证明,设$f _k $为新增$k $个传送机后的减少的答案,我们考虑证明$f _k + f _{ k + 2  } \geq 2 f _{ k + 1  } $.</p>
<p>我们画出$f _k $时选的点和$f _{ k + 2  } $时选的点,注意到我们可以用这两次调整出两个$k + 1 $的答案,并且这两个答案的和小于等于$f _k + f _{ k + 2  } $,于是证明了最小的$f _{ k + 1  } $是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量$w $,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于$w $的最大的传送机数量,然后就可以做了.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中的线性代数</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#oi中的线性代数">OI中的线性代数</a><ul>
<li><a href="#线性基">线性基</a><ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan and Burgers)</a></li>
<li><a href="#example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337 [Ynoi2004] rsxc)</a></li>
<li><a href="#example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</a></li>
</ul>
</li>
<li><a href="#杂题">杂题</a><ul>
<li><a href="#example1cf1270ixor-on-figures">Example1([CF1270I]Xor on Figures)</a></li>
<li><a href="#example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing Finals)</a></li>
</ul>
</li>
<li><a href="#逆矩阵求解线性方程组">逆矩阵求解线性方程组</a><ul>
<li><a href="#example1codeforces-cf1266h-red-blue-graph">Example1(codeforces CF1266H Red-Blue Graph)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="oi中的线性代数">OI中的线性代数</span></h3><h4><span id="线性基">线性基</span></h4><h5><span id="example1">Example1</span></h5><p>给定$n $个非平方因子数$a _i $,求有多少种选取一个子集的方式满足每个质因子都在子集中恰好出现偶数次.$n \leq 2 \times 10 ^5 , a _i \leq 10 ^6 $.</p>
<p>考虑将每个数的质因子压成一个二进制数,那所求也就是问有多少种选取子集的方式使得子集内二进制数异或和为$0 $.自然想到线性基.$2 $的自由变量的数量次幂即答案.</p>
<p>但是直接做线性基不太对,因为质数级别是$10 ^6 $.我们冷静一下,把一个数中大于$1000 $的质因子拿出来,显然只会有一个.把所有数字根据这个质因子分类,那么显然一个组内必能插入一个数(作为这个质因子的主元),而其他数也必要异或上这个数,而异或后就只有小于等于$1000 $的质因子了,这种质因子只有不到$200 $个,可以拿bitset优化一下.</p>
<p>复杂度$O ( \cfrac { \pi ( \sqrt { a  } ) ^2 n  } { w  } ) $.</p>
<h5><span id="example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan and Burgers)</span></h5><p>考虑扫描线,这样我们需要解决如何询问一段后缀$[ l , n ] $的答案,以及如何根据上一个位置的后缀推出这一个位置的后缀.</p>
<p>考虑有一个暴力是直接把每个后缀的线性基建出来:注意在此过程中,能放到高位的数字一定出现地尽可能靠后,因为它一早就被放进来了.而只要满足这个条件,也就是能放高位的一定尽量放高位,并且高位出现时间要尽可能晚,那我们自然就得到了此时的线性基,删去那些出现太靠前的数字就行.</p>
<p>但有没有什么直接一点的理解方式呢?一个直觉是,我们现在要把出现时间太早的给删了,那肯定想要让高位出现时间尽可能晚.但是这样会有两个问题:</p>
<ol>
<li><p>可能$l $较小但是没那么小,高位即使不顶替,也会被选上,但是顶替了高位就无法顶替一个将被删除的低位.</p>
</li>
<li><p>由于线性基并非最简线性基,我们最后的答案有可能不会将某一位异或进答案,那此时尽量最优化它是不优秀的.</p>
</li>
<li><p>线性基中的元素不能受到非线性基中的元素的影响,我们删除一位的时候,这一位有可能在之前影响了比它低的一些位置.</p>
</li>
</ol>
<p>来一个一个解决.</p>
<p>(3)是最好解决的.对于因为出现时间太早而导致的删除来说,因为如果一个位置被高位影响了,根据我们的构造过程,这个位置出现时间必然不会晚于那个高位,高位都被删了,那这个位置也会被删.</p>
<p>对于因为被其他人而取代导致的删除来说,因为它被删了,因此它一定可以表示为其它线性基底的异或,因此有影响也无所谓.</p>
<p>再来看(1),考虑我们当前插入的数字是$v $,如果$v $本来就会被加入线性基,那它扔到高位,然后替换下来的那个数字也不可能被删除,一定会延续到低位.如果$v $本来不会被加入,必然因为有一些基底的异或值是$v $,那么把$v $加入后,一路到最后,被删除的那个基底必然是出现时间最早的那个菜逼,删了就是了.</p>
<p>接下来是(2),考虑上面这个过程完全不耽误你把它变成最简线性基,最简线性基就没这个问题了.</p>
<p>当然这题还可以分治,注意到用线段树直接合并区间的线性基的复杂度达到了$\log ^3 $,但是如果我们用猫树的结构但是不必要在线,复杂度降到了$\log ^2 $.</p>
<h5><span id="example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337 [Ynoi2004] rsxc)</span></h5><p>注意到区间数字种类个数一定是二的整数次幂,假设为$2 ^k $,先枚举$k $.</p>
<p>首先根据CF1100F,我们可以离线找出区间的线性基,这意味着区间不同整数个数是否是$2 ^k $.</p>
<p>做完这两步之后呢?我们接下来需要求和.这里注意到随着扫描线的进行,左端点可能合法的区间左右端点均单调不降,我们对着二维坐标系做一个差分(就是把一条直线延伸到$y = x $这条直线上),于是可以$O ( 1 ) $求和.</p>
<p>这里详细解释一下上面的那个套路:当我们插入一个数字的时候,每当遇到了一个此位置是$1 $的出现次数早于该数字的数字,我们就交换它们.为啥这样是对的呢?首先如果插入的这个数字并不能被其他数字所表示,那无论怎么交换都不会有影响.而如果可以,那一定会与所有参与表示的数字都交换一次.注意到每次交换等价于找到两者中出现较早的那个,所以最后一定会删去出现最早的数字.</p>
<h5><span id="example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</span></h5><p>用一下构造能力不难发现,每个点的取值是它前面的数能表示出的所有数(也就是线性基)异或上他自己.</p>
<p>我们考虑从左往右加线性基(并保存旧的版本),每次如果一个数并不能更新线性基,说明这个数字能取的取值范围就是到它的线性基中的所有数字.进一步地,你注意到它的取值范围一定包括了它前面的所有数字,这个同样可以通过线性基的性质来得到.</p>
<p>注意到难点在于那些加入后更新线性基的点,称它们为关键点,这样的关键点最多$\log V $个.所以我们可以暴力讨论它们的存在.而那些普通的点显然分成了若干个段,每段的取值是相等的.我们可以按照线性基的顺序走.如果我们必须要在关键点和其它的点中挑一个删了,显然我们要删关键点,因为其他的点能很完美地接上,但是关键点可不一定能接上.</p>
<p>也就是说对于一个非关键点,能选则一定要选.因此我们直接从后往前dp,如果遇到关键点的话讨论一下它选不选,遇到非关键点一定要选,如果选不了就更新答案.</p>
<p>我们不妨设计一个dp,设$f _{ i , j  } $表示从$n $走到第$i $个数字,中间取了$j $个关键点,$a _i $的最大值是多少.这样问题转化为:</p>
<ol>
<li><p>对于一个数字$X $,找到线性基中最大的小于它的数字.</p>
</li>
<li><p>对于一个数字$X $,将它与线性基中若干基底异或得到$X ‘ $,使得$X ‘ &lt; Y $并且$X ‘ $尽可能大.</p>
</li>
</ol>
<p>不难发现第一个问题就是第二个问题中的$X = 0 , Y = X $的情况.用最简线性基算排名可以轻松解决上面的问题.</p>
<h4><span id="杂题">杂题</span></h4><h5><span id="example1cf1270ixor-on-figures">Example1([CF1270I]Xor on Figures)</span></h5><p>首先我们发现,它的平移操作和矩阵很相似,我们考虑将操作写成矩阵形式.</p>
<p>具体地,我们定义新的矩阵乘法为:$A \times B = C $,其中$C _{ x , y  } = \bigoplus _{ i = 0  } ^{ 2 ^k - 1  } \bigoplus _{ j = 0  } ^{ 2 ^k - 1  } A _{ i , j  } \times B _{ ( x - i ) \mod 2 ^k , ( y - j ) \mod 2 ^k  } $.</p>
<p>定义矩阵$F $:$F _{ x _i , y _i  } = 1 , 1 \leq i \leq t $,其他位置均为$0 $.不难发现每次操作无非是将$F $乘上一个只有$( X , Y ) $位置是$w $,其余位置都是$0 $的矩阵然后异或到$A $上.我们发现这些操作也可以压缩成一个矩阵.这样问题就转化为:我们已知$F $,求$0 $的位置尽可能多的矩阵$C $,满足$F \times C = A $.</p>
<p>我们看到这个形式,发现它很优美,这个时候自然有一个猜想:$F $在这种形式下是否存在逆矩阵呢?</p>
<p>注意到$F $的值是异或运算下,和取膜有一定关系,我们再大胆猜测:$\exists m , F ^m = I $,其中$I _{ 0 , 0  } = 1 $,其他位置都是$0 $.此时$F ^{ - 1  } = F ^{ m - 1  } $.打表可以发现$m = 2 ^k $.</p>
<p>接下来我们只需要证明这个结论就行.其实也好证:注意到进行一次运算后,$F _{ x _i , y _i  } \times F _{ x _j , y _j  } $和$F _{ x _j , y _j  } \times F _{ x _i , y _i  } $都会更新到$F ^2 _{ x _i + x _j , y _i + y _j  } $,因此他们俩互相抵消.这意味着$F ^2 $中,只有$F ^2 _{ 2 x _i , 2 y _i  } $有可能非零.</p>
<p>进行$2 ^k $后,由于下标对$2 ^k $取膜,容易发现这个时候只有$( 0 , 0 ) $有可能非零.而由于一共有奇数个$1 $,所以这里一定是$1 $.得证.有$C = F ^{ 2 ^k - 1  } A $.</p>
<p>根据上面的证明过程不难发现,$F $的$2 $的整次幂很好求,所以我们拆开幂,有$C = \prod _{ i = 0  } ^{ k - 1  } F ^{ 2 ^i  } A $.注意到$F $很稀疏,最多只有$t $个地方非零,所以做一次的复杂度是$O ( ( 2 ^k ) ^2 t ) $,总复杂度$O ( kt 4 ^k ) $.</p>
<h5><span id="example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing Finals)</span></h5><p>给定一个$n \times n $的矩阵,其中有$m $个位置($m \leq 5 $)的数字缺失了.给定质数$P $,现在要在这$m $个位置上填上$[ 0 , p - 1 ] $的数字,使得最后矩阵的行列式在$\bmod p $意义下等于给定数字$C $,求任意一组方案,$1 \leq n \leq 100 $,$2 \leq P \leq 10 ^9 $.</p>
<p>如果$m = 1 $,做代数余子式展开,显然如果这个位置对应的代数余子式为$0 $,那它填什么无所谓,随便填一个然后验证.不然,我们一定可以用逆元算出一个答案,使得满足条件.</p>
<p>同理,如果$m &gt; 1 $,我们考虑随机$m - 1 $个位置并随机它们的值,然后验证.如果我们能找到一组随机满足剩下的那个位置对应的代数余子式非零就做完了.如果我们随机了若干次,还是没有找到,宣告无解.</p>
<h4><span id="逆矩阵求解线性方程组">逆矩阵求解线性方程组</span></h4><p>如果我们已知线性方程组的系数矩阵,但是多次询问,每次会给出不同的常数项,我们可以使用下文中提到的逆矩阵来求解.</p>
<h5><span id="example1codeforces-cf1266h-red-blue-graph">Example1(codeforces CF1266H Red-Blue Graph)</span></h5><p>如果我们设$x _i $表示每个点被经历过多少次.注意到一共有$n - 1 $个方程以及$n - 1 $个未知数,我们实际上是要根据$s $和$v $求出一组$x $然后判定合法,我们先写方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x _i - [ i & = 1 ] \\
& = \sum _{ e : j \rightarrow i \ is \ blue  } \frac { x _j - [ s _e = red ] - [ j = v ]  } { 2  } \\
+ \sum _{ e : j \rightarrow i \ is \ red  } \frac { x _j + [ s _e = red ] - [ j = v ]  } { 2  } 
\end{aligned}</script><p>化简一下:</p>
<script type="math/tex; mode=display">
2 x _i - \sum _{ j \rightarrow i  } x _j = - \sum _{ e : j \rightarrow i \ is \ blue  } [ s _e = red ] + \sum _{ e : j \rightarrow i \ is \ red  } [ s _e = red ] - \sum _{ j \rightarrow i  } [ j = v ] + 2 [ i = 1 ]</script><p>注意到这是一个系数恒定且常数项不确定的矩阵,可以先矩阵求逆再做.</p>
<p>另外有一个问题是,怎么证明这个系数矩阵一定存在逆矩阵,不难注意到这是个基尔霍夫矩阵,显然$\det $为$0 $.</p>
<p>这也就是说,我们一定可以求出唯一一组解.我们要做的只是判定它是否合法.</p>
<p>先通过数学归纳等方法证明一组满足流量平衡以及以下条件的$x , s , v $一定合法:</p>
<p>对于任意一个点,都存在一条只经过激活边的路径到达最终点.</p>
<p>首先充分性,如果满足这个条件,我们只要不断地退流就可以得到一组一定合法的答案.</p>
<p>然后必要性,如果存在一个点没有这条路径,那这个点也必然不可能被回溯到,自然不可能出现一组解.</p>
<p>这题关键在于发现流量平衡这个等价条件,然后知道我们可以求出一组状态,并只需要判定状态是否合法,找判定条件.</p>
<p>然后写分数的人被卡常了,泪目.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中的常见套路</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="本质相同">本质相同</span></h3><h5><span id="example1">Example1</span></h5><p>对于所有满足以下条件的长度为$n $的序列$\{ a \} $,我们称它是好的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _1 & = 1 \\
\forall 2 & \leq i & \leq n , a _i & \leq \max \{ a _1 , \cdots , a _{ i - 1  } \} + 1 
\end{aligned}</script><p>对于每一个数$1 \leq x \leq n $,求它在每个好的序列中出现的次数的平方和.其中$1 \leq n \leq 3000 $,任意模数.</p>
<p>首先注意到可以枚举每个数$x $出现的次数,这样就转化为对满足某些位置是$x $的好的序列计数.</p>
<p>对于一个没有限制的好的序列,设$f _{ i , j  } $表示$[ 1 , i ] $中填了$[ 1 , j ] $(其中$j $必填)的方案数,不难发现这就是第二类斯特林数.</p>
<p>这样,对于一个$x $,我们可以枚举它第一次出现的位置以及出现的次数,以及它第一次出现的位置后面的大于等于它的数的数量,合并即可.复杂度$O ( n ^4 ) $.</p>
<p>再思考一下,似乎我们不用枚举它出现的次数,而是可以直接用$g _{ i , j , 0 / 1 / 2  } $表示在$[ 1 , i ] $中填$[ 1 , j ] $,$1 $出现次数的平方和.同样枚举后面有多少大于等于它的位置,然后就可以把这些位置抽出来作为一个子序列,这个子序列就可以认为$x $就是$1 $.复杂度$O ( n ^3 ) $.</p>
<p>如果写出上面的式子的话,会发现最难处理的是一个形如$x ^k $的项,表示$x $第一次出现的位置后面仍然选比它小的数字的位置的方案数.这个怎么办呢?自然的想法是想在dp中顺便把它算了.</p>
<p>再进一步想,我们之所以合并麻烦,是因为取了两段上升区间.如果我们能求出一个上升区间和一个下降区间,在交点处合并呢?</p>
<p>但是这样怎么统计平方和呢?我们发现如果在$[ 1 , k ] $中选了$[ 1 , i ] $,那么$[ 1 , i ] $在$[ k + 1 , n ] $中是本质完全相同的,因此还是可以用上面的dp求.</p>
<h3><span id="排列转环">排列转环</span></h3><h5><span id="example1p8416">Example1(P8416)</span></h5><p>这题牛逼.</p>
<p>首先考虑一维的情况,一维情况下最劣应该是$2 , 3 , . . . , n , 1 $这样的.</p>
<p>为啥捏?因为注意到操作数$= n - $排列环数,这样的排列环数为$1 $,显然是最小的.加上列也差不多,所以$k _0 = 2 n ( n - 1 ) = 2 n ^2 - 2 n $.</p>
<p>而我们显然可以通过两次操作把一个位置归位,最后剩一行再随便做做,这样的答案就是$2 n ^2 - n + 1 $,如果我们想赢,那就需要在上面的$n - 1 $行每行省出一步操作.</p>
<p>这咋做呢?类似上面的做法,也考虑找环然后省一步,对于一行,我们找到所有应该放在这里的值以及它们所在的列,把它们应该在的列和实际在的列连边,一定能找到至少一个环(自环也算),删环就可以省一步操作.</p>
<h5><span id="example2">Example2</span></h5><p>给序列$a $和排列$b $,有若干次操作:</p>
<ol>
<li><p>修改操作:给定$x , y $,将$a _x $改为$y $.</p>
</li>
<li><p>查询操作:给定$l , r , x $,查区间$[ l , r ] $内最长的子区间$[ l ‘ , r ‘ ] $,使得对$\forall l ‘ \leq i &lt; r ‘ $,有$a _{ i + 1  } = b _{ a _i  } $,且存在$l ‘ \leq i \leq r ‘ $使得$a _i = x $.需要输出满足条件的子区间的长度最大值.</p>
</li>
</ol>
<p>一步一步来,首先处理出所有的极长的满足条件的段,不难发现修改一个点只会断掉一个段或者连接两个段,影响是$O ( 1 ) $的.</p>
<p>难点在于,我们如何处理要求其中存在一个$x $这种东西.</p>
<p>注意到$b $是排列,上置换,不难发现$b $其实就是一个置换,也就是说每一个极长的段一定是一个置换环内部的元素,我们可以快速定位到$x $所在的置换环.但这样还是不能做.</p>
<p>考虑由于是单点查询$x $,我们可以直接将数组也做置换,这样一个置换环就在一个区间内部,意味着一个极长的段一定是一个区间或者两个区间(原区间的一段前缀和一段后缀).</p>
<p>现在对于区间查询,我们考虑特殊处理和端点相交的段,这个是平凡的.这样我们只需要处理出完全被区间包含的那些段该怎么做.把右端点缩一缩,就等价于左端点完全被区间包含的那些点.也就是以$a $为横坐标,$l $为纵坐标,这样这些就相当于对一条横线取$\max $,然后查询一段竖着的线段的最大值.注意到一行不可能有两个横线,因此可以线段树分治+线段树维护,复杂度$O ( n \log ^2 n ) $.</p>
<h3><span id="规定转移顺序">规定转移顺序</span></h3><h5><span id="example1">Example1</span></h5><p>给定一张$n $个点的图,每个点有一个$[ 1 , k ] $的颜色,求这张图有多少个子图是一棵树并且在这棵树中每种颜色恰好出现了一次.</p>
<p>首先无根树转有根树计数,设$dp _{ i , S  } $表示以$i $为根,已经选了$S $集合中的颜色的方案数.转移的时候枚举出边(注意可能会算重,只要是会算重的都考虑钦定某种颜色在其中一个块里),复杂度$O ( m 3 ^k ) $.</p>
<p>冷静一下,想到斯坦纳树,于是再设一个$g _{ x , S  } $表示以$x $为根且$x $只有一个儿子,$S $的定义类似的方案数.这样我们就可以用斯坦纳树的换根技巧计数.很厉害.</p>
<p>这个故事告诉我们:对于图论计数问题(尤其是和树有关),$m $大概率可以转化为$n $,但是需要一些小技巧(例如斯坦纳树)</p>
<h5><span id="example2p7142">Example2(P7142)</span></h5><p>类似宝藏那个题,我们考虑设$f _{ d , S _1 , S _2  } $表示$S _1 $中的点到$1 $的距离$&lt; d $,$S _2 $中的点到$1 $的距离$= d $.然后枚举到$1 $的距离$= d + 1 $的点集,这一部分复杂度是$O ( n 3 ^n ) $,预处理一下不同情况的答案即可.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3><p>大概是如果多组询问那复杂度是错误的,但是如果我全局求,那我$\sum $起来的总复杂度大概是对的.经典问题是树上背包.</p>
<h5><span id="example1">Example1</span></h5><p>给定一颗二叉树,求对于每一个$x $,满足$x , y , z $互不相同的三元组$( x , y , z ) $的价值(定义为两两距离之和对$L $取膜)的最大值是多少.$n \leq 3000 $.</p>
<p>乍一看,二叉树,想到换根后做dsu on tree+set.但是$O ( n ^2 \log ^2 n ) $实在是跑不过去.冷静一下,除去三点共线的情况,考虑三个点在二叉树上的两两LCA一定只有两个点,枚举其中深度较浅的那个点并枚举其子树中的两个点和子树外的一个点.假设其子树内有$x $个点对,子树外有$y $个点,注意到$\sum x = n ^2 \land \sum y \leq n ^2 $,于是总复杂度$O ( n ^2 \log n ) $.</p>
<h3><span id="字典序相关">字典序相关</span></h3><p>题目中询问满足条件的字典序第$k $小之类的问题,通常采用转化为计数问题.</p>
<h5><span id="example12022noip十连测day88ady">Example1([2022noip十连测day8]8ady)</span></h5><p>首先,我们肯定想如果知道$a $,我们怎么求出$b $.</p>
<p>首先不难发现,我们可以这么还原:先开一个堆,然后先将前$m - 1 $个位置扔进堆里,从第$m $个位置开始,假设现在到了第$i $个位置$( m \leq i \leq n ) $,每次将$a _i $扔进堆里,并从堆中取最小元素扔到$i - m + 1 $位置,最后把堆清空到剩下的位置即可.</p>
<p>大量实验证明:这种反向构造思路,你用个堆通常是做不动的.</p>
<p>我们考虑有没有别的做法.</p>
<p>一个一个数地考虑,$b _1 $在$a $中的位置应该在哪?显然是应该在$[ 1 , m ] $中,而且根据上面的堆的做法,显然它应该是$[ 1 , m ] $中最小的数字,换句话说,我们需要满足:$[ 1 , m ] $中除它以外的数字都比它大.</p>
<p>我们继续考虑$b _2 $,显然它在$a $中应该在$[ 1 , m + 1 ] $中,并且需要满足$[ 1 , m + 1 ] $中的所有数字除了$b _1 $,都比它大.</p>
<p>以此类推.不难注意到对于一个数$b _i $,其中$1 \leq i \leq n - m + 1 $,它能填回的原序列的位置一定最大最大是$[ 1 , m + i - 1 ] $,并且如果它能填到区间$[ l , r ] $中,这个区间中除去在它之前填进来的数字以外,均比它大.</p>
<p>但是,这显然是个上界.这个区间能不能缩小一下呢?</p>
<p>对于一个$i $,我们找到最大的$j $满足$1 \leq j &lt; i $并且$b _j &gt; b _i $(有可能找不到).</p>
<p>冷静一下,显然,$b _i $不能填到$[ 1 , j + m - 1 ] $.(因为如果它扔在这里,那它就:在$j $出堆前入堆,在$j $出堆后出堆,显然不合法)</p>
<p>也就是说,我们将每个数能填的区间缩小为了$[ j + m , i + m - 1 ] $.</p>
<p>那是不是说每个数只要填在这个区间中,就一定合法呢?</p>
<p>我们考虑一个数$i $以及所有比它小且在它后面的数字$j $,当$j = i + 1 $时,显然$j $只有一种选择,直接填上;当$j = i + 2 $时,若$i + 1 $已经选择好了,那$j $显然也只有一种选择,填上.这样,对于所有$i $,如果它前面有一个大于它的数字,那它一定只有一个位置可以填.</p>
<p>这样我们就可以简化为:给定$b $数组单调递增的问题.不难发现该条件下$i $可以选择的区间是$[ 1 , i + m - 1 ] $,且满足条件一定有解.</p>
<p>冷静一下,这个时候假设新序列长度为$len $,那显然一共有$m ^{ len  } $个满足条件的$a $序列.注意到这个级别是指数级别.</p>
<p>所以前面一定是按顺序填,直到后面才会打乱顺序.而后面的长度大概也就是个$\log _m k $,枚举枚举就行.</p>
<h3><span id="前缀和与差分">前缀和与差分</span></h3><h5><span id="example1loj3266">Example1(loj3266)</span></h5><p>把点都扔到坐标系上,显然到一个点曼哈顿距离相等的数一定在一个正方形(对角线平行于坐标轴)上.</p>
<p>我们考虑如果已知两个点,怎么找第三个点的坐标,显然是两个正方形的边界的交点,那也就是说,曼哈顿距离下,一个等边三角形必定有两个点所在直线与坐标轴成$45 \degree $角,那这两个点必然和另一个点组成了一个等腰直角三角形(欧几里得意义下),我们枚举等腰直角三角形的直角顶点和直角边长就可以确认这两个点的坐标,而另一个点一定在一条与坐标轴成$45 \degree $的斜线上,可以使用前缀和做.</p>
<p>注意到有的点对可能会被算两遍,要特判.</p>
<h5><span id="example2">Example2</span></h5><p>小孔在玩卡牌游戏.众所周知,在卡牌游戏里,过牌是很关键的,所以目前小孔的牌库中,只可能有数字牌$0 , 1 , 2 , 3 , 4 $.</p>
<p>数字牌$x $的含义是当你打出它的时候,会从牌库的顶端抽$x $张牌到自己手里,若牌库中不足$x $张牌,则将牌库抽空为止.打出的数字牌$x $会放入弃牌堆中.在题目中你可以认为这张牌不会再被用到了.</p>
<p>目前,牌库里有$n $张牌,从牌堆顶到牌堆底数第$i $张牌为数字牌$a _i $.在开始回合时,发牌员会进行一次切牌,切牌的结果是从牌堆顶到牌堆底的牌的顺序变为了$a _s , a _{ s + 1  } , . . . , a _n , a _1 , . . . , a _{ s − 1  } $.</p>
<p>接着,小孔会抽$k $张牌堆顶的牌到自己手上.每次小孔可以打出一张牌,但这一回合中小孔至多打出$p $张牌.小孔可以在任意时刻结束回合.</p>
<p>请问,这一回合中若小孔使用最优策略,那么牌库里最少还剩多少牌.进一步地,有$q $次这样的询问,每次询问给定三个整数$s , k , p $,你需要输出牌库里最少还剩多少牌.$( n , q \leq 3 \times 10 ^5 ) $.</p>
<p>每次询问是独立的,也就是说每次询问并不会以任何方式影响到之后的询问.</p>
<p>首先我们想一下我们需要知道什么:我们需要知道其在这一回合中打出的各种牌的数量是多少.而只要知道这一点,我们自然得到了答案是多少.注意到每次一定优先打出手头上最大的牌.</p>
<p>我们设$sum _{ t , i  } $表示从开始到抽完第$i $张牌<strong>之前</strong>,在只用大于$t $的牌的前提下,还能往下抽多少张牌.显然$sum _{ t , 0  } = 0 $并且$sum _{ t , i  } = sum _{ t , i - 1  } + a _{ i - 1  } [ a _{ i - 1  } &gt; t ] - 1 $.注意到$sum _{ t , i  } = 0 $就抽不了第$i $张牌了.不考虑还能抽负数张牌的情况,注意到$sum $数组具有可差分性!</p>
<p>那我们一开始抽了$k $张牌,也就是令$sum _{ s + 1  } \leftarrow sum _{ s + 1  } + k $,那第一个不能继续抽牌的地方显然也就是第一个满足$sum _{ i  } - sum _{ s  } \leq 0 $的地方,用原本的$sum $数组表示也就是$sum _{ i  } + k \leq sum _{ s  } $.那第二个地方呢?由于后面的$sum $都加上$k $了,第二个地方也就是满足$sum _j \leq sum _{ i  } - t $的地方(不过注意到后面要倍增,所以直接写$sum _j &lt; sum _i $也可以,这样方便用单调栈维护这个东西).以此类推,注意到这个东西和询问无关,可以使用倍增预处理,处理的过程中判断一下还有没有大小为$t $的牌以及用牌总数是否小于等于$p $即可.都是可以用前缀和之类的东西预处理的.最后从小的牌开始选,选完之后的牌就可以当成$0 $牌了.另外要注意:我们要保证目前一定有大小为$t $的牌选,所以需要在做之前判断一下最后一次选择大小为$t $的牌的位置是在哪里.</p>
<p>等一下,注意到我们好像没啥办法判断还有没有大小为$t $的牌.有一个方法是:我们直接令所有$\leq t - 1 $的牌变成$t $,并处理出不用$\leq t - 1 $的牌能跑到的最右点,然后取个$\min $.</p>
<p>想出$sum $数组并发现可差分性后,这个题突然就变可做了.问题来了:咋想到的$sum $数组,又是怎么发现的可差分性?</p>
<p>首先,由于切牌这个环节会变化起点.所以有两种可能:要么是像倍增那样起点不定,要么是像差分一样其它起点的答案可以由原本的起点答案得到.那想到差分后呢?又注意到一定会先选较大的牌,所以大概率可以分层考虑:这样就先把问题转化为只有$0 / 1 $或者是只有$0 / 1 / 2 $的情况再继续考虑.由于要多组询问,所以答案一定是可以通过某种方式迅速算出来的,考虑到只要得到每种牌选的次数就可以快速算答案.又有一定是比它大的牌都选完了才选它,于是考虑第一次选不了其它牌只能选它的地方.注意到这个地方可以使用前缀和在变换起点的情况下求.于是由前缀和判断差分性质.</p>
<h3><span id="二分答案">二分答案</span></h3><h5><span id="example12022qbxt国庆day6kth">Example1([2022qbxt国庆Day6]kth)</span></h5><p>考虑$f $的取值不会很多,我们可以枚举$f $的取值,并把相同取值的归类.也就是,对于$f = i $的类别里也就是后$i $位为$0 $,第$i $位为$1 $的那些数.</p>
<p>注意到每个类别内部是很有序的,也就是说我们可以采取类似初赛归并排序的方法二分,找到前$k $大的和.</p>
<p>调了一年,这个故事告诉我们,如果一个东西暴力调整能过/复杂度均摊,就不要写一些很丑的很难写的即使更快的东西去做.</p>
<h5><span id="example2">Example2</span></h5><p>给你一棵$n $个点的树,每条边是一个字符(字符集是小写字母),一个点的所有相邻边边权不同.</p>
<p>有$m $次操作:每次询问给出点$x $和字符串$S $,$S $中不包含相同字符,$| S | = 26 $,每次修改会修改一条边边权.</p>
<p>从$x $点开始,每次对与$x $点相邻的边,对这些边找出其边权在$S $中出现的位置,找出边权出现位置最靠前的边,然后走过去.</p>
<p>每次询问走过的边直接从树上删除,一条边正反方向算同一条边,也就是说没法$x \rightarrow y \rightarrow x $.</p>
<p>这个过程会停机,你需要输出在哪个点停下来,询问之间独立.</p>
<p>这题最重要的思想在于:我们首先需要将这个问题改成一个判定性问题:判定性问题显然弱于找到答案.</p>
<p>怎么判定呢?对于一条路径,如果我们要沿着它走,那么我们就可以确定每个点的最小边(或者次小边),这等价于给出若干个边之间的大小关系,可以使用bitset维护一下,最后判定即可.我们发现判定数组是可以合并的,于是这玩意可以扔到线段树上维护.</p>
<p>会了判定这题就做完了,做树链剖分,然后开始从下往上跳重链,能跳到顶端就跳,不然二分跳到哪里,下去是同理的,只不过下去的二分需要多个$\log n $.</p>
<h3><span id="整体二分">整体二分</span></h3><p>通常解决在二分的情况下,单次check的复杂度比较高的问题.思想是把所有询问共同的check一起做.</p>
<p>整体二分的具体复杂度往往需要现场分析.</p>
<p>最常用的整体二分的写法是分治.但是有的问题(例如不能撤销)可能不太好写分治.</p>
<p>还有一种方式是,我们把所有询问一字排开,然后求出每个询问当前二分的$mid $,然后顺序处理或者别的什么处理方式做这些$mid $.</p>
<h5><span id="example1agc002dstamp-rally">Example1([AGC002D]Stamp Rally)</span></h5><p>直接整体二分,注意需要做可撤销并查集之类的东西.</p>
<h3><span id="分治">分治</span></h3><h5><span id="example1平面最近点对">Example1(平面最近点对)</span></h5><p>按照$x $轴排序,递归做两边的子问题,假设两边问题的最小值为$d $,对着$d $做中间的问题.</p>
<h5><span id="example2cf1764g3-doremys-perfect-ds-class-hard-version">Example2([CF1764G3] Doremy’s Perfect DS Class (Hard Version))</span></h5><p>有一个$[ 1 , n ] $的排列$p $,每次可以询问$l , r , k $,交互库会返回$\lfloor \frac { p _l  } { k  } \rfloor , \lfloor \frac { p _{ l + 1  }  } { k  } \rfloor , \cdots , \lfloor \frac { p _r  } { k  } \rfloor $中不同数字的个数,你需要在$20 $次询问内找到$p $中$1 $的位置.</p>
<p>第一反应就是令$k = 2 $,然后如果$n $是奇数,不难发现此时只有$1 $自己一个人一组.一个自然的想法是,我们可以对于每个位置$i $,查询$[ 1 , i - 1 ] $和$[ 1 , i ] $的答案,如果答案一样,那这个位置肯定不是$1 $.如果不一样,我们再查一下$[ i , n ] $和$[ i + 1 , n ] $.由于$1 $不会和左右任意一个人配对,不难发现如果这两种情况都不一样,那这里一定是$1 $,这样我们就做到了$2 n - 2 $次查询.</p>
<p>那么如何优化呢?我们冷静一下,如果我们查询一个区间$[ l , r ] $,那么得到的答案自然是$len - $配对数字都在区间内的对数,因此我们自然也能得到这个区间的未配对数.这个时候发现,对于位置$i $,如果我们查询$[ 1 , i ] $和$[ i + 1 , n ] $,由于这两个区间内没配对的数字要么是$1 $,要么会和另一个区间中的数字配对,因此这两个区间中,未配对数多的那个一定包含$1 $.这样就可以通过$k $不断向下二分,最后只需要$20 $步操作就可以解决$n $是奇数的情况.</p>
<p>那么$n $是偶数怎么办呢?这个时候$1 $和$n $都没人配对.我们需要找到$n $并将它杀掉.注意到$k $可以取别的数,我们如果只是让$k = 2 $未免有些弱,而且看上去也区分不了$1 $和$n $,而不难发现,令$k = n $就可以找到$n $在哪里,于是可以先找$n $再找$1 $,需要$40 $步.</p>
<p>那怎么继续优化呢?我们还是令$k = 2 $,查询$[ 1 , i ] $和$[ i + 1 , n ] $,我们发现此时会有两种情况:</p>
<ol>
<li><p>左右两边未配对数量相差$2 $,这个时候$1 $和$n $一定都在较大的那边,直接递归.</p>
</li>
<li><p>左右两边未配对数量相等,这个时候一定$1 $在一边,$n $在另一边,我们可以通过一次查询$k = n $判断哪边是$n $.</p>
</li>
</ol>
<p>于是只需要$21 $次.</p>
<p>但是还是不够,我们从哪里抠出那一次呢?发现最后处理区间$[ i , i + 1 ] $还需要两步操作,我们看看能不能省掉一步.</p>
<ol>
<li><p>$1 $和$n $都在$[ i , i + 1 ] $中,我们显然只需要查询一步就可以知道哪边是$n $.</p>
</li>
<li><p>只有$1 $在$[ i , i + 1 ] $中,我们考虑利用一下前面的信息.注意到我们一定已经知道$[ 1 , i - 1 ] , [ i , n ] , [ 1 , i + 1 ] , [ i + 2 , n ] $的答案(如果区间为空或者区间为$[ 1 , n ] $显然我们也知道答案),假设这个区间中的两个数是$1 $和$x $,$x \in ( 1 , n ) $,那么$x $一定有一个和它配对的数字,我们考虑通过$[ 1 , i - 1 ] $和$[ 1 , i + 1 ] $就可以知道和$x $配对的数字在$[ 1 , i - 1 ] $还是在$[ i + 2 , n ] $.接下来只需要一步判断就可以找到$1 $了.</p>
</li>
</ol>
<h5><span id="example3xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopentraisn-contest-1489d-nice-set-of-points">Example3(XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(opentraisn contest 1489)D  Nice Set of Points)</span></h5><p>给定一个点集$S = \{ ( x , y ) \} $,$( x _1 , y _1 ) $和$( x _2 , y _2 ) $可达当且仅当$x _1 = x _2 \lor y _1 = y _2 $.称一个点集是好的当且仅当这个点集中任意两个点的最短距离是它们的曼哈顿距离.给出一个点集,大小为$N $,$1 \leq N \leq 1000 $,加入不多于$10000 - N $个点使得这个点集变成好的.</p>
<p>找一条分界线$x = d $,我们将这条线左右两边的点全都作出在这条线上的投影点,将这些投影点全都加入,不难发现左右两边之间的路径就合法了,继续递归就行.</p>
<h5><span id="example4cf1442dsum">Example4([CF1442D]Sum)</span></h5><p>一个自然的想法是由于越靠后的可能越优秀,所以应该是要不断往后挖的.具体地,我们发现只可能有一个数组被选了一部分,剩下的数组要么不选,要么全选.</p>
<p>为什么呢?假设有两个数组各选了一部分,不妨假设它们最后选的数分别是$a $和$b $,下一个未选的数分别是$c $和$d $,有$c \geq a , d \geq b $,假设$a \geq b $,那么自然有$c \geq b $,于是我们把$b $删掉换成$c $一定更优秀.</p>
<p>有了这个性质后,我们可以枚举是哪个数组只选了一部分,然后求出剩下部分的背包,背包部分可以求前缀和后缀最后合并起来,我们的复杂度就是$O ( nk ^2 ) $.</p>
<p>但这个复杂度还是不太够,如何优化呢?</p>
<p>注意到这里的背包是支持撤销操作的,我们考虑一个分治做法:每次做到$[ l , r ] $的时候,假设此时$[ 1 , l - 1 ] $和$[ r + 1 , n ] $都加入答案了,我们把$[ mid + 1 , r ] $也加入背包,然后递归求解$[ l , mid ] $,然后再撤销,同样的方法求解右边的答案.复杂度$O ( nk \log n ) $.</p>
<h5><span id="example5agc044d">Example5(AGC044D)</span></h5><p>这题在于分治后归并,考虑我们是可以快速判断一个串是否是原串的子序列的,就是判断它们的编辑距离是否恰好等于长度之差.而我们也可以快速判断每个字母在原串中出现了多少次,只需要询问$L $个这个字母然后看编辑距离就是替换的次数.这样我们考虑对字母分治,$[ l , r ] $表示只用到$[ l , r ] $中的字母,得到的极长的原串的子序列是什么.边界情况$[ l , l ] $是好处理的,对于$[ l , r ] $,我们考虑归并,合并$[ l , mid ] $和$[ mid + 1 , r ] $的时候不断判断当前串是否是子序列就行.</p>
<h3><span id="倍增">倍增</span></h3><p>顺便一提,倍增比二分方便的一点在于:倍增能迅速确定答案的规模,这在复杂度与答案规模有关的时候至关重要.</p>
<h5><span id="example1scoi2015国旗计划">Example1([SCOI2015]国旗计划)</span></h5><p>先破环成链,然后设$f _{ i , j  } $表示从$i $这个人,途径$2 ^j $个人后能到达的最远的人是谁,然后就可以直接通过倍增处理.</p>
<h5><span id="example2pkusc2018星际穿越">Example2([PKUSC2018]星际穿越)</span></h5><h5><span id="example3cf1523h-hopping-around-the-array">Example3(CF1523H Hopping Around the Array)</span></h5><p>类似国旗计划,只不过需要用背包合并一维.</p>
<p>不过吧,这题有个问题在于最后的询问,我们要每次判断当前越界的点的代价是否小于等于dp数组的代价,如果小就回撤dp数组(因为无论如何都必不可能在这里选择).</p>
<h5><span id="example4loj3665">Example4(loj3665)</span></h5><p>思考一下发现,走相同的步数能到的点一定是一段区间,于是考虑使用倍增算法,设$f _{ x , i  } $表示从$x $走$2 ^i $步能到的区间,转移是简单的RMQ问题.</p>
<p>但是初值怎么求呢?先考虑右端点怎么求.对于每个路线$j $,它会把$[ A _j , A _j + k - 1 ] $能到达的右端点与$B _j $取$\max $,由于查询在修改之后,所以这个东西很好做.</p>
<h5><span id="example5cf1707e">Example5(CF1707E)</span></h5><p>引理1:如果$[ l , r ] \subseteq [ L , R ] $,则$f ( ( l , r ) ) \subseteq f ( ( L , R ) ) $.</p>
<p>引理2:如果$[ L , R ] = [ l _1 , r _1 ] \cup [ l _2 , r _2 ] $,则$f ( ( L , R ) ) = f ( ( l _1 , r _1 ) ) \cup f ( ( l _2 , r _2 ) ) $.</p>
<p>引理1显然,引理2是因为$[ L , R ] $中的最大值和最小值一定都被后面的两个部分取到.</p>
<p>于是,考虑$[ l , r ] = \cup _{ i = l  } ^{ r - 1  } [ i , i + 1 ] $,就可以倍增了.</p>
<p>考虑求出每个单点的倍增数组,那么总区间的倍增数组也就是这些数组的最小值和最大值.</p>
<p>大概做一下.</p>
<h5><span id="example622zr提高组十连测day6百分号">Example6([22zr提高组十连测day6]百分号)</span></h5><p>首先看上去多组询问给定起点终点看上去就很像倍增.</p>
<p>一个很自然的设计是$L _{ x , i  } $表示从$x $这个点跳$2 ^i $所能到达的最左端的点,$R _{ x , i  } $同理.但是能跳到最远的点不一定能跳到一个较近的点,那咋办呢?</p>
<p>冷静一下,注意到我们好像还没有用到括号序列的性质:两个跳跃要么包含要么不交,不可能出现第三种情况.</p>
<p>所以,如果目前能跳到的最远的点为$l , r $,那么再跳一步能到达的最远的点一定是从$l $或$r $跳过去的.考虑反证这个结论,设能从$( l , r ) $中的一个点$k $跳到更远的点,那么由于之前没跳到过$k $就跳到$l $了,所以一定存在一个$i &gt; k $,$i \rightarrow l $,而如果存在$j &lt; l $,$k \rightarrow j $,显然不满足性质.</p>
<p>同理,我们最后处理询问答案的时候,考虑从$x $和$y $都跳.先从$x $跳到再跳一步就会跳过$y $的位置,然后把$y $跳到再跳一步就会跳过$x $的位置,那么现在的$x $和$y $一定相邻,不然分别跳一步就会出现包含的情况,于是一定是最优解.</p>
<h3><span id="对称建立双射">对称/建立双射</span></h3><h5><span id="example1cf1627f">Example1(CF1627F)</span></h5><p>冷静一下考虑,分界线一定是一个中心对称图形,分成的两部分一定中心对称.那这条分界线一定过中心点.</p>
<p>我们考虑这么一点:如果所有点对都在矩阵一边,我们就可以直接求中心点到矩阵一边的最短路然后对称一下就好了.</p>
<p>而矩阵上遍布点对怎么办呢?我们在和每个点对对称的位置把这个点对复制一遍,然后从中心点找到一条到边界的最短路,把它对称一下即可.</p>
<h5><span id="example2ah2017hnoi2017抛硬币">Example2([AH2017/HNOI2017]抛硬币)</span></h5><p>设$A $的正面朝上为$S _A $,$B $的为$S _B $.设$p _1 = \sum [ S _A &gt; S _B ] , p _2 = \sum [ S _A = S _B ] , p _3 = \sum [ S _A &lt; S _B ] $.</p>
<p>当$a = b $,翻转所有硬币,自然有$p _1 = p _3 $,又设$P = p _1 + p _2 + p _3 = 2 ^{ a + b  } $,于是求得$p _2 $即可得到答案.而$p _2 = \sum _{ i = 0  } ^a \binom { a  } { i  } \binom { b  } { i  } $,用范德蒙德卷积的变式,有$p _2 = \binom { a + b  } { a  } $.</p>
<p>同样,当$a &gt; b $时.我们设$p _4 = \sum [ a - S _A &gt; b - S _B ] , p _5 = \sum [ a - S _A = b - S _B ] , p _6 = \sum [ a - S _A &lt; b - S _B ] $.同样是翻转硬币的套路,自然有$p _4 = p _1 , p _5 = p _2 , p _6 = p _3 $.注意到:$S _A \leq S _B \Rightarrow a - S _A &gt; b - S _B $,但逆命题不成立.不妨设$p _7 = \sum [ S _A &gt; S _B \land a - S _A &gt; b - S _B ] $.自然有:</p>
<script type="math/tex; mode=display">
p _1 = p _4 = p _7 + p _2 + p _3 = p _7 + P - p _1</script><p>于是只要求出$p _7 $就可以求得$p _1 $.</p>
<p>考虑$p _7 $如何求,注意到$[ S _A &gt; S _B \land a - S _A &gt; b - S _B ] = [ 0 &lt; S _A - S _B &lt; a - b ] $,我们可以枚举$S _A - S _B $,然后继续用范德蒙德卷积的变式.</p>
<h5><span id="example32022qbxt国庆day4c">Example3([2022qbxt国庆Day4]C)</span></h5><p>直接考虑对于每一对位置$( i , j ) , i &lt; j $,计算它们可能产生的逆序对贡献.注意到每一对对答案的贡献会大概接近$0 . 5 $,我们考虑构造一个双射,判断双射左右是否都会贡献.</p>
<p>设$d _i $为$i $个数的错排数量,根据错排公式有$d _n = ( n - 1 ) ( d _{ n - 1  } + d _{ n - 2  } ) $.接下来讨论一下这两个位置的取值:</p>
<ol>
<li><p>如果$a _i = j , a _j = i $,那么一定贡献了逆序对,这里总共贡献为$d _{ n - 2  } \cfrac { n ( n - 1 )  } { 2  } $,一半的贡献也就是$\cfrac { d _{ n - 2  } n ( n - 1 )  } { 4  } $.</p>
</li>
<li><p>如果$a _i = j , a _j = k , k \ne i \lor a _i = k , a _j = i , k \ne j $,考虑前后两者形成双射.如果$k $在$i $和$j $之间,那么无论前者还是后者,都一定贡献逆序对;不然,则两种情况一定只有一种会贡献逆序对.前者多出的贡献应该是$\cfrac { n ( n - 1 ) ( n - 2 )  } { 6  } ( d _{ n - 2  } + d _{ n - 3  } ) $,也就是先选出$i &lt; k &lt; j $,如果$a _k = i $,那么剩余的可能性就是$d _{ n - 3  } $;不然,也就是说$a _k \ne i $,类似于错排公式,剩余的可能性为$d _{ n - 2  } $.另外,由于$d _{ n - 2  } + d _{ n - 3  } = \cfrac { d _{ n - 1  }  } { n - 2  } $,所以上面的贡献也就是$\cfrac { n ( n - 1 )  } { 6  } d _{ n - 1  } $.</p>
</li>
<li><p>如果$i , j , a _i , a _j $互不相同,那我们交换$a _i $和$a _j $一定可以构造出另一组答案,并且这两组答案中一定只有一组贡献了逆序对,于是二者形成双射.</p>
</li>
</ol>
<p>除去上面的部分的贡献是$\cfrac { d _n n ( n - 1 )  } { 4  } $.于是总贡献为:$n ( n - 1 ) ( \cfrac { d _{ n - 1  }  } { 6  } + \cfrac { d _n + d _{ n - 2  }  } { 4  } ) $.</p>
<h5><span id="example4arc115d">Example4(ARC115D)</span></h5><p>第一反应感觉完全不可做.</p>
<p>思考一下,如果我们随便选边肯定完蛋了:我们又不知道选出了几个奇度点,这不完蛋了?</p>
<p>先考虑要求全是偶度点怎么办?</p>
<p>由于点只有奇度点和偶度点两种,如果我能先随便选个边集,再把它删到全是偶度点好像就赢了.但是一方面我咋删啊,一方面这样删有可能删出重复的.又注意到删一条边就一定可以让两个点的奇偶性改变.</p>
<p>我们考虑求出原图的一棵生成树,然后剩下的边随便选.之后从生成树深度较大的点开始考虑:如果这个点是奇度点,我们就把它的父边删掉.容易发现这样是双射.而如果有奇度点的话可以先组合数选出来然后同样做上面的操作,容易发现是一样的.</p>
<p>不同的连通块可以分别做最后卷起来.</p>
<h5><span id="example5hihocoder1230">Example5(Hihocoder1230)</span></h5><p>这题最重要的一点在于观察到一组$a $如果有解,那么一定是唯一解.为啥呢?我们考虑如何构造一个解:从小位到高位枚举,如果当前位所有数异或起来是$1 $,那么$x $这一位也必然是$1 $,然后加上后进位.这是由于序列长度是奇数.然后就每次对于$a \in [ x , m + x ] $计数,做FWT就行.</p>
<h5><span id="example623省选10连测-day5b">Example6(23省选10连测 day5B)</span></h5><p>首先我们要知道,一轮冒泡排序的过程等价于:从前往后考虑每一个点,如果它前面存在一个比它大的点,就将它和前面的点交换.</p>
<p>于是我们考虑令$b _i = \sum _{ j = 1  } ^{ i - 1  } [ a _j &gt; a _i ] $.也就是每次冒泡排序,这个$b _i $都会变成$\max \{ b _i - 1 , 0 \} $.显然$b _i $需要满足的条件是$b _i \in [ 0 , n - i ] $,接下来我们证明:只要满足这个条件,$b $和$a $就是双射关系.根据$a $还原$b $是简单的,那么如何根据$b $还原$a $呢?我们只需要从大向小考虑元素,就可以判断元素插入哪里.</p>
<p>有了这个条件后,我们不妨设原序列是$a ‘ $,其对应$b ‘ $,那么显然$b _i = \max \{ 0 , b _i ‘ - m \} \leq \max \{ 0 , n - i - m \} $.也就是说,如果$b _i = 0 $,那么$b _i ‘ \in [ 0 , m ] $,反之$b _i ‘ = b _i + m $.但问题在于:我们如何保证$b _i ‘ \in [ 0 , n - i ] $呢?不难发现,冒泡排序每次会把前面最大的数扔到后面,也就是说整个序列最后的$m $个数一定有序,那我们分开考虑:对于最后的$m $个数,它一开始在序列中的相对顺序是无所谓的:无论如何都会扔到最后.而对于其它的数,如果$b _i = 0 $,$b _i ‘ \in [ 0 , m ] $,由于最后都已经凑出$m $个数了,从大向小将数字插入,一定可以使这一部分满足条件.而如果$b _i &gt; 0 $,由于有判定条件$b _i \leq \max \{ 0 , n - i - m \} $,显然满足.于是我们设一共有$k $个$b _i = 0 $的位置(也就是前缀最大值位置),于是自然有$f ( a , m ) = ( m + 1 ) ^k m ! $.注意这个式子的前提在于判定每个$b _i \leq \max \{ 0 , n - i - m \} $以及$a $的最后$m $个位置是$n - m + 1 , \cdots , n - 1 , n $.到这里不难发现只要满足后者前者必定满足.现在只需要统计前缀最大值的个数就可以解决这个问题了.这个设计个$dp _{ i , j  } $表示前$i $个数的最大值是$j $就行.</p>
<h3><span id="拆多项式">拆多项式</span></h3><p>通常适用于数据范围中有一项的范围不大的情况,然后拆成多项式后可以带入另一项较大的值.</p>
<h5><span id="example122zr提高组十连测day5可">Example1([22zr提高组十连测day5]可)</span></h5><p>首先考虑数位dp,每次枚举当前的$k $个数中还有$x $个数被limit,这次又有$y $个数不用被limit,再枚举一下当前各位之和,然后可以写一个转移,复杂度$O ( k ^4 \lg x ) $</p>
<p>然后想了好久发现这个东西好像优化不动了.</p>
<p>冷静一下,注意到问题在于枚举,我们不妨把枚举换成容斥试试.设$g ( x ) $为$\sum a $为$x $的方案数,那么可以通过容斥得知:</p>
<script type="math/tex; mode=display">
g ( n ) = \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }</script><p>我们最后要求的答案也就是$\sum f ( n ) g ( n ) $,继续推式子:</p>
<script type="math/tex; mode=display">
ans = \sum _{ n = 0  } ^{ kx  } f ( n ) g ( n ) = \sum _{ n = 0  } ^{ kx  } f ( n ) \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }</script><script type="math/tex; mode=display">
= \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \sum _{ n = 0  } ^{ kx  } f ( n ) \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }</script><p>看上去好像推不动了.</p>
<p>冷静一下,会发现$n $的取值远远大于$i , k $的取值.于是我们选择把组合数拆成一个$k - 1 $次多项式,这样只需要处理出这个多项式的每一项的系数,然后就可以预处理后面的东西.</p>
<p>拆二项式系数的时候要注意特判上指标小于下指标的情况.</p>
<script type="math/tex; mode=display">
ans = \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \sum _{ j = 0  } ^{ k - 1  } c _{ i , j  } \sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n ) n ^j</script><p>其中$c _{ i , j  } = [ n ^j ] \binom { n - i ( x + 1 ) + k - 1  } { k - 1  } $.</p>
<p>这样我们就成功地分离出了一项$\sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n ) n ^j $,接下来考虑怎么处理这一项.</p>
<p>考虑枚举$i $,然后设$dp _{ j , limit  } = \sum _{ n = 0  } ^{ limit  } f ( n ) n ^j $,考虑拿数位dp做这个东西,枚举当前位置$cnt $的取值$w $,根据二项式定理,$dp _{ a + b , limit  } \leftarrow \binom { a + b  } { b  } dp _{ b , limit  } f ( w ) ( w 10 ^{ cnt  } ) ^a $,那么$\sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n ) n ^j = dp _{ j , kx  } - dp _{ j , i ( x + 1 ) - 1  } $.</p>
<p>这样我们需要枚举$i , a , b , cnt $得到一组答案,然后还需要把这些答案合并起来,复杂度$O ( k ^3 \lg x ) $.</p>
<h3><span id="抽屉原理">抽屉原理</span></h3><h5><span id="example1unr-6小火车">Example1([UNR #6]小火车)</span></h5><p>首先考虑证明一定有解:</p>
<p>注意到我们可以先选择出两个不完全相同的集合,如果这两个集合的和相等,那么我们把只在第一个集合的$b $设为$- 1 $,只在第二个集合的$b $设为$1 $,都在或都不在的设为$0 $,那么这显然就是一组解.</p>
<p>而由于$p &lt; 2 ^n $,根据抽屉原理,显然存在这么两个集合.</p>
<p>考虑对于一个权值区间$[ l , r ] $,如果有超过$r - l + 1 $个集合的和在这个区间内,那一定有两个集合可以组成一个解.</p>
<p>假设现在已知权值区间$[ l , r ] $一定有解,我们判断$[ l , mid ] $中是否有超过$mid - l + 1 $个集合,使用折半搜索再合并可以快速求出权值和为某个定值的集合有多少个.然后可以使用双指针判断,继续递归下去判断即可.复杂度$O ( 2 ^{ \frac { n  } { 2  }  } n ) $.</p>
<h5><span id="example2noi2021量子通信">Example2([NOI2021]量子通信)</span></h5><p>考虑$k \leq 15 $,所以如果我们把两个零一串每$16 $个分一块,那么两个零一串相差少于$k $处,则一定有一块完全相等.由于数据随机,这个概率为$\cfrac { 1  } { 2 ^{ 16  }  } $.</p>
<p>考虑把在一块中是某个数的零一串全都集合到一起,然后暴力判断,复杂度约为$O ( \cfrac { n ^2 q  } { 2 ^{ 16  } w  } ) $.</p>
<h3><span id="拆贡献">拆贡献</span></h3><h5><span id="example12022qbxt国庆day7fenwick">Example1([2022qbxt国庆Day7]fenwick)</span></h5><p>注意到要变换多次,考虑每个值的贡献.</p>
<p>一个点要往后更新,不难通过平行求和法则一个值$v $对它向后跳$w $步的贡献为$\binom { w + k  } { w  } $.但是有修改很难办,怎么办?注意到如果我们暴力跳,查询的时候复杂度是$O ( 1 ) $的,我们没必要让它这么低.我们把所有值对$p $这个点的更新存到一个数组里,显然只有$\log n $种步数.最后每次查询的时候用组合数一起更新即可.</p>
<h5><span id="example2qoj5097-小-p-爱学习">Example2([QOJ5097] 小 P 爱学习)</span></h5><p>这个题的厉害之处在于完全将贡献拆开.</p>
<p>我们不妨设最后将所有的数分成了$k $组,那么显然我们只要算出两个东西就可以得到此时的答案的和:</p>
<ol>
<li><p>$\sum _{ x _{ 1 , . . . , k  }  } \prod _{ i = 1  } ^k a _{ x _i  } \ $.</p>
</li>
<li><p>$\sum _{ 1 \leq x _1 , . . . , x _k \leq n , \sum x = n  } \frac { ( nm - k ) !  } { \prod _{ i = 1  } ^k ( x _i m - 1 ) !  } \ $.</p>
</li>
</ol>
<p>第一个显然就是个背包,问题在于第二个的分子部分,我们用生成函数,设$F = \sum _{ i = 1  } ^{ n  } \frac { 1  } { ( im - 1 ) !  } x ^i $,我们要求的就是$[ x ^n ] F ^k , \forall 1 \leq k \leq n $.</p>
<p>这个东西可以做BSGS,也就是光速幂.这样就可以用$O ( n ^2 \sqrt { n  } ) $预处理,用$O ( n ) $查询单个$k $.</p>
<h5><span id="example3luogu4211-lnoi2014lca">Example3(Luogu4211 [LNOI2014]LCA)</span></h5><p>将$dep $拆成到根节点的路径上的点的数量,差分一下$[ l , r ] $,这样就只需要求$z $和一个前缀点的LCA的$dep $.将这个操作离线下来,我们对于每一个点把它到根节点的路径上的点全部$+ 1 $,查询每个点到根节点上的权值和就行.</p>
<p>CF757G是一样的,只不过好像需要卡卡空间?</p>
<h3><span id="二进制拆位">二进制拆位</span></h3><h5><span id="example1luogu5354-ynoi2017由乃的oj">Example1(Luogu5354 [Ynoi2017]由乃的OJ)</span></h5><p>对每一位分开处理,对于线段树上每个区间,设$f _{ 0  } $表示一开始$v $的这一位是$0 $,最后的答案是$1 $还是$0 $,显然可以合并,拿bitset优化一下.</p>
<h3><span id="bitset优化暴力">bitset优化暴力</span></h3><h5><span id="example12022qbxt国庆day4d">Example1([2022qbxt国庆Day4]D)</span></h5><p>先想一个很明显的优化:我们记录一下每个字符出现的位置,当我们判断当前字符串是否出现过的时候,我们直接从这个字符串开头的字符存在的位置进行判断.</p>
<p>如果我们记录下每个字符在母串中的某个位置是否存在,我们就可以基本脱离母串进行判断.注意到只需要用bitset优化这个过程就可以做到$O ( \sum tlen + \cfrac { nq  } { w  } ) $.</p>
<h5><span id="example2noi2020-制作菜品">Example2([NOI2020] 制作菜品)</span></h5><p>这题首先要根据数据范围,注意到$m \geq n - 1 $的时候存在贪心解法.</p>
<p>具体怎么做呢?我们将原料按照质量排序,每次选最小的那个,不够的话就选最大的那个的一部分,重新排序后递归处理.</p>
<p>为啥这个是对的呢?根据鸽笼原理,最大的那个的质量一定大于等于$\frac { mk  } { n  } $,而最小的那个数和最大的那个数之和一定大于等于$0 + \frac { mk  } { n - 1  } \geq k $,因此一定有解.</p>
<p>接下来我们就只需要做$m = n - 2 $的情况.</p>
<p>那么这个怎么做呢?我们发现每道菜和两个原材料有关,于是不妨抽象成图论模型:将这两个原材料所代表的点用一条边连起来:我们发现有$n - 2 $条边和$n $个点,这个图必不联通.也就是说如果有解,必然可以分成两个集合,这两个集合互不相关.如果我们分成了两个集合,一个集合有$a $个原材料,另一个集合有$n - a $个原材料,我们就可以第一个集合做$a - 1 $道菜,第二个集合做$n - a - 1 $道菜,自然解决了问题.</p>
<p>接下来的问题在于01背包,用bitset优化一下.</p>
<h3><span id="简化能更新答案的集合">简化能更新答案的集合</span></h3><p>简单来说就是当你注意到一个答案只有可能由某些地方贡献,我们就只判断这些地方的贡献.有的时候不仅需要减小集合,还需要使这个集合尽可能好维护,这个时候可能会向集合里放一些不合法但不可能更新答案的选项.</p>
<h5><span id="example1cf1149d-abandoning-roads">Example1(CF1149D Abandoning Roads)</span></h5><p>首先一个把只有$a $边的连通块缩起来,那$1 $到$i $的最短路显然是通过几个$b $连接若干个连通块来到$i $.</p>
<p>由于防止用$b $边链接连通块的时候连出环,我们需要用一个$dp _{ S , x  } $表示从$1 $经过$S $集合的连通块到$x $的最短路.</p>
<p>但是集合数量可能很多,怎么办?</p>
<p>注意到,如果这个集合只有一个点,那显然不可能重复经过;如果这个集合只有两个点,那重复经过意味着想用一条长度为$2 b $的边代替一条长度为$a $的边,显然也不优秀;同理集合只有三个点也不优秀.</p>
<p>于是只有点数$\geq 4 $的集合是有用的,复杂度$O ( 2 ^{ \frac { n  } { 4  }  } m \log n ) $.</p>
<h5><span id="example2">Example2</span></h5><p>给定$n $个正整数,要求将$n $个正整数分到$k $个集合中,每个集合恰好$\cfrac { n  } { k  } $个数(保证$k | n $)且每个集合中不能有相同的数.设一个方案的代价是每个集合的极差之和,求最小代价,$n \leq 70 $.</p>
<p>首先$O ( 3 ^n ) $很好设计不说了.</p>
<p>注意到这题看上去就不太能多项式复杂度,我们考虑简化一下状态数.考虑做$O ( 3 ^n ) $的时候,我们是将$\cfrac { n  } { k  } $个数打包成一个集合再塞进去,这样看上去就不太优秀,我们考虑能不能一个数一个数塞进去.</p>
<p>我们现在有$k $个集合,要塞进去一个数到一个集合中.注意到最后的代价实际上和很多数是没啥关系的.考虑先把数字从小到大排序,然后挨个插入集合.如果插入一个数之前,这个集合是空的,那这个数对答案有负的贡献;如果插入一个数之后,这个集合是满的,那这个数对答案有正的贡献;反之无贡献.</p>
<p>于是我们可以枚举目前集合填成啥样了,这样状态数变成了$( \cfrac { n  } { k  } + 1 ) ^k $.</p>
<p>这样还是过不去,我们再冷静一下,显然我们只关心每个集合填了多少个数而不关心具体是哪个集合,于是我们把每个集合的大小排序后再压成状态,这样状态数就是$\sum _{ i = 0  } ^{ k  } { \binom { i + \frac { n  } { k  }  } { \frac { n  } { k  }  }  } \ $,根据目前填到第几个数分一分类就会发现这部分上限是$O ( n \binom { 2 \sqrt { n  }  } { \sqrt { n  }  } ) $.</p>
<p>不过我们还需要保证一个集合里不能有相同的元素.这里我们考虑将相同的元素一起放并规定放的顺序.因为放进去的集合在放这种元素前是有大小顺序的,我们每次放进最大的集合中.换句话说,我们设$f _{ i , j , S  } $表示目前放到$i $,状态是$S $,并且$a _i $放进去的那个集合目前大小是$j + 1 $(放前是$j $).</p>
<p>算一下复杂度是$O ( n ^2 \binom { 2 \sqrt { n  }  } { \sqrt { n  }  } ) $的,实际上远远跑不满,甚至写了个map来做双射也跑过去了.</p>
<h5><span id="example3">Example3</span></h5><p>给定一张有向图,多组询问,每次询问三个数$p , x , y $,求是否能从$p $出发只经过$[ x , y ] $中的边且经过的边的编号单调递减到达$1 $号节点.</p>
<p>冷静一下,先加边,注意到如果加$u \rightarrow v $这条边的时候,不存在一条从$v $到$1 $的路径,那这条边显然没有用.</p>
<p>做完这一步后,我们注意到可以在加边的过程中对于每个$u $维护从$u $到$1 $的所有合法路径经过的最小编号的边的最大值$maxn _u $,这样就可以对于每个点维护若干个二元组$( l , r ) $,只要对于$p $,存在一个二元组$[ l , r ] \in [ x , y ] $就合法.</p>
<h5><span id="example4petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-ccombinations-strike-back">Example4([Petrozavodsk Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) C]Combinations Strike Back)</span></h5><p>给定一个大小为$n $的可重集,多次询问,每次询问查询插入一个数$x $后,这个集合大小为$k $的可重子集共有多少个,每次询问互相独立.$n , q \leq 1 . 2 \times 10 ^5 $,答案对$1051721729 = 1003 \times 2 ^{ 20  } + 1 $取膜.</p>
<p>自然的想法是上生成函数.</p>
<p>假设数字$i $在原集合中共有$b _i $个,那么原集合大小为$k $的可重子集数量显然为$[ z ^k ] \prod _{ i = 1  } ^n \frac { z ^{ b _i + 1  } - 1  } { z - 1  } $.</p>
<p>插入一个数字$x $,自然就是乘上一个$\frac { z ^{ b _x + 2  } - 1  } { z ^{ b _x + 1  } - 1  } $.但如果每次都乘的话复杂度显然不行.怎么办?</p>
<p>注意到答案与插入的数字本身无关,只和这个数字在原集合中出现了多少次有关.而原集合最多有$\sqrt { n  } $(自然根号)个出现次数不同的数字,预处理一下就行.</p>
<h5><span id="example5cf1621gweighted-increasing-subsequences">Example5([CF1621G]Weighted Increasing Subsequences)</span></h5><p>一个自然的想法是拆出每个点$x $的贡献,再枚举终点$y $,这样问题就转化为了以$y $结尾并且包含$x $的LIS计数,这样做到$O ( n ^2 ) $的复杂度.</p>
<p>那么怎么继续优化呢?我们还是想拆出每个点的贡献,但是如何不枚举终点$y $呢?我们考虑枚举一下和它做贡献的点$z $满足$a _z &gt; a _x $并且终点$y $满足$y &lt; z $,但是这样的$z $有很多个,不难发现取最后一个就行.如果我们对整个序列取后缀$\max $,就可以得到所有可能被当作$z $的点,而且更强的性质是,只要这些点不在LIS中,LIS的终点$y $必然有$y &lt; z $,这是显然的.做一下补集转化,就变成了计数包含$x $和$z $的LIS数量.</p>
<p>注意到$z $的数量不多,且所有数字按照权值排序后被这些$z $分成了若干个区间.所以颠倒值域和下标重新做LIS就行.</p>
<h5><span id="example6cf919f-a-game-with-numbers">Example6(CF919F A Game With Numbers)</span></h5><p>最小表示法表示每个人的手牌.</p>
<p>不过要注意有可能成环.我们考虑用刷表法更新,最后刷不出来的点就是和.</p>
<h5><span id="example7ioi2014holiday">Example7([IOI2014]holiday)</span></h5><p>首先发现走的一定是一个区间,然后发现这个区间$[ l , r ] $的$l $随$r $的增大具有决策单调性,然后做完了,上主席树就行.</p>
<h5><span id="example8cf1446d2">Example8(CF1446D2)</span></h5><p>我们假设目前得到的答案区间是$[ l , r ] $,也就是说$[ l , r ] $无论如何不可能扩展成更大的区间了.那这需要满足什么条件呢?注意到全局众数一定是答案,如果它不是答案,我们就可以往两边拓展,直到满足区间众数是答案且区间合法.显然可以实现.然后做根号分治.</p>
<p>这个是怎么想到的呢?我们考虑一个区间如何拓展成更大的区间:如果每个数出现次数不降,显然是一个更大的区间.这同样是在说:如果我们能找到一段区间,使得加上这段区间后,原本不是区间众数的数成为了区间众数,并且区间仍然合法,那就一定更为优秀.再注意到如果一个数在全局出现次数多于区间众数,这一定可以实现,进而推出全局众数的结论.</p>
<p>你以为结束了?没有,我们下面给出一个$O ( n \log n ) $的做法:</p>
<p>首先,我们假设全局众数是$x $,枚举和它一起成为区间众数的数字$y $,剩下的数先不管,那么区间大概长这个样:xyxyyxyxxxxxx.</p>
<p>我们发现这一段x一定是没有意义的:xyxyyxyxx[xxxx].</p>
<p>我们对于每一个$y $出现的位置,找到其左右两边离他最近的没有被标记的$x $标记一下,没有被标记的$x $一定没有意义.这样对于一组解$( x , y ) $,合法的端点数量只有$O ( y 出 现 的 次 数 ) $次.每次判断每个端点是否可以做右端点,拿$set $维护一下后缀和就可以实现$O ( n \log n ) $.</p>
<p>当然,这里得到的区间不一定是合法的(有可能$x , y $出现的次数都不是最多的,但没关系,这种一定不优秀).</p>
<p>【luoguP4062 [Code+#1]Yazid 的新生舞会】也是这个标记的思路,标记的话用一下链表之类的大概能做.</p>
<h4><span id="支配对问题">支配对问题</span></h4><p>lxl起的名字.</p>
<p>这里的思路其实大概就是:我们将一些很废物的二元组杀了,然后将剩下的二元组进行贡献答案.我们称这种一个二元组严格强于另一个二元组的限制称作支配关系.</p>
<h5><span id="第一类支配对">第一类支配对</span></h5><p>虽然总数很多,但是本质不同的很少.</p>
<h6><span id="example1luogup7880-ynoi2006-rldcot">Example1(luoguP7880 [Ynoi2006] rldcot)</span></h6><p>我们这么考虑:如果现在有三个点$a , b , c , a &lt; b &lt; c $,它们两两LCA都是$d $,那么显然$( a , c ) $这一对是没有用的,有用的是$( a , b ) $和$( b , c ) $.进一步你发现这等价于什么呢:我们从下往上合并子树,每次做启发式合并,假设当前要把子树$A $合并到子树$B $上,考虑所有的点对$( a , b ) , a \in A , b \in B $的贡献,显然,能贡献到$a $的$b $只有$a $的前驱和后继,这样我们就只找到了$O ( n \log n ) $个点对,它们等价于$O ( n \log n ) $个矩形,最后把$dep $相等的合并一下,随便做做.</p>
<h6><span id="example2luogup8528-ynoi2003-铃原露露">Example2(luoguP8528 [Ynoi2003] 铃原露露)</span></h6><p>和Example1基本差不多.</p>
<h5><span id="第二类支配对">第二类支配对</span></h5><p>虽然总数很多,但是有用的很少.</p>
<h6><span id="example1cf765f">Example1(CF765F)</span></h6><p>典.</p>
<h6><span id="example2codechef-minxorseg">Example2(CodeChef MINXORSEG)</span></h6><p>这个题比较厉害,仍然考虑$a &lt; b &lt; c $,我们看如果$a \oplus c &gt; \max \{ a \oplus b , b \oplus c \} $的充要条件是什么.</p>
<p>简单分类讨论一下,不难发现这意味着$LCP ( a , c ) &gt; LCP ( a , b ) $.于是有用的贡献对只有$O ( n \log v ) $个.</p>
<h6><span id="example3luogu9058-ynoi2004-rpmtdq">Example3(Luogu9058 [Ynoi2004] rpmtdq)</span></h6><p>这题更为逆天.</p>
<p>首先,这题有两个维度:树和序列,我们要先处理掉其中一维.lxl:树这一维度更加困难,因此我们应该是选择困难的那一维分治掉.</p>
<p>考虑边分治,然后就只需要处理两棵子树间的贡献.但是对于一棵子树内的点,我们要找到在另一棵子树中有可能和它产生贡献的点对,这个咋做呢?</p>
<p>牛逼的一步来了,我们考虑对于每个点,算出它到分治中心的距离$r $,然后找另一棵子树中到分治中心距离$\leq r $的点$x $与它贡献,但是这还是有很多点,其实只需要找这些点中的$x $的前驱后继就可以了.因为如果$x &lt; b &lt; c $,$b $和$c $在同一边,那么$( b , c ) $一定比$( a , c ) $更加优秀.</p>
<h6><span id="example4cf1635f-closest-pair">Example4(CF1635F Closest Pair)</span></h6><p>首先,由于匹配无序,我们考虑对于一对数$( i , j ) $,只在$w $较大的那个位置来更新答案.</p>
<p>不妨假设较大的为$i $,我们考虑$i $有可能和谁来更新答案.</p>
<p>如果现在有两个数$k &lt; j , w _k \leq w _i \land w _j \leq w _i $,如果$w _k \geq w _j $,那肯定选$( j , i ) $更优秀;不然,如果选$( k , i ) $比选$( j , i ) $更优秀,那么我们会发现$( k , j ) $比$( k , i ) $更要优秀,因此答案一定会由$( k , j ) $更新而不是由$( k , i ) $更新.通过这里的分析我们发现,每个数只有可能和它左右两边的第一个$w $小于等于它的数更新.</p>
<p>于是我们可以找到$O ( n ) $个可能更新答案的点对,设点对为$( x , y ) $,我们每次查找一个区间$[ l , r ] $,即要找到所有在$[ l , r ] $内的点对并将它们的答案取min.</p>
<p>这一步可以将$( x , y ) $当作二维平面的点,查询当作一个左下角为$( l , l ) $,右上角为$( r , r ) $的矩阵,就是一个经典的矩阵取min的操作.</p>
<h6><span id="example5icpc2017-wfmoney-for-nothing">Example5([ICPC2017 WF]Money for nothing)</span></h6><p>注意到抽象问题后等价于有若干个A点$( x _1 , y _1 ) $和若干个B点$( x _2 , y _2 ) $,我们想要找到一个A点和一个B点使得$( x _1 - x _2 ) ( y _1 - y _2 ) $最大.也就是它们作为右上和左下顶点的矩形面积最大.</p>
<p>怎么做这个问题呢?首先我们必须要发现的一点是:对于A点来说,如果有两个点$( a _1 , b _1 ) $和$( a _2 , b _2 ) $满足$a _1 \leq a _2 $,$b _1 \leq b _2 $,那么前者一定更优秀.把那些废点删掉后,就会得到一个横坐标递增,纵坐标递减的点的序列.对于B点是同理的.</p>
<p>这个序列看上去就很亲切了,接下来简单证明一下是满足决策单调性的就可以判断答案了.</p>
<h3><span id="奇偶染色">奇偶染色</span></h3><h5><span id="example1">Example1</span></h5><p>一个$9 \times 9 $的网格,一开始上面有$65 $个蚂蚁,每个蚂蚁每分钟会四联通移动一格,每个蚂蚁每三分钟所在的格子不能在一条直线上,求证:一定会有一个时间,两只蚂蚁在同一个格子里.</p>
<p>sol1:</p>
<p>注意到如果条件不成立,则一定存在若干条路径,蚂蚁在路径上转圈,也就是找到长度和尽可能大的路径不交地覆盖矩阵,注意到一定是使用$2 \times 2 $的矩阵路径,于是最多有$64 $只蚂蚁.(感性理解)</p>
<p>sol2:</p>
<p>考虑对奇偶染色,设$( i , j ) = \begin{cases}white &amp; 2 \nmid ( i + j ) \ blue &amp; 2 \mid i \land 2 \mid j \ yellow &amp; \text { otherwise  } \end{cases} $.</p>
<p>我们把黄格子和蓝格子称为彩格子,注意到如果一开始一只蚂蚁在白格子,一分钟后必定在彩格子.一开始一只蚂蚁在蓝格子,两分钟后必定在黄格子.</p>
<p>因为最多有$16 $个蓝格子,所以一开始黄格子和蓝格子上分别最多有$16 $只蚂蚁,从而白格子上最多有$32 $只蚂蚁,总共最多$64 $只,得证.</p>
<h5><span id="example2cf1521e">Example2(CF1521E)</span></h5><p>首先考虑我们显然可以一行空一行放,也就是说如果最大的$a _i &gt; n \times \lceil \frac { n  } { 2  } \rceil $的话显然不可以,如果能放的位置少于$\sum a $显然也不可以.</p>
<p>类似lyz那个题,我们考虑删去行列编号均为偶数的点,这样就满足了一个子矩阵不能全放的限制.</p>
<p>然后呢?我们考虑将所有能放的位置排序.先把所有的位置分成三类:$( \mathrm { even  } , \mathrm { odd  } ) , ( \mathrm { odd  } , \mathrm { odd  } ) , ( \mathrm { odd  } , \mathrm { even  } ) $,不同类位置按照这个顺序排,不然按照相对位置排.然后直接从头开始放.如果不合法,一定是同种颜色放到了$( \mathrm { even  } , \mathrm { odd  } ) $和$( \mathrm { odd  } , \mathrm { even  } ) $,并且相同类别是按照相对位置排序的,于是一定不满足最大的$a _i \leq n \times \lceil \frac { n  } { 2  } \rceil $的限制条件.所以这么做一定是对的.</p>
<p>好!冷静一下,咋想到的啊.</p>
<p>首先这种题肯定要找到一些看上去就很显然的边界,当你发现找不到的时候,大概率就一定有解了(大概率).</p>
<p>然后呢?注意到不合法一定是同种颜色放到了$( \mathrm { even  } , \mathrm { odd  } ) $和$( \mathrm { odd  } , \mathrm { even  } ) $,又观察到每种位置的数量和一个边界限制条件很像,于是就可以构造出来了.</p>
<p>所以大概是说,这种构造题要先想判断边界的条件,然后对着做.</p>
<h5><span id="example3cf1615f">Example3(CF1615F)</span></h5><p>太牛逼了这个题.</p>
<p>首先,找边界条件:啥时候$s $不能变成$t $呢?一个自然的想法是数$1 $的个数的奇偶性,但这样显然不对($01 $和$10 $不能互相转移),我们需要一个更强的条件.</p>
<p>然后:注意到每次操作是相邻的两个数,于是我们有:奇数位置的和-偶数位置的和是定值.但是:注意到这个操作是有限制的!它只能对相邻相同的位置做.</p>
<p>然后我也不知道咋想到的,可能是因为找到限制条件后只要不改变限制条件就可以随便转化?反正我们先把偶数位置全部取反,这样操作就变成了交换相邻数字(如果相邻数字不相同,取反后相同,交换无用).</p>
<p>就可以dp了.</p>
<h5><span id="example4cf1517g">Example4(CF1517G)</span></h5><p>按照横纵坐标的奇偶性,分四种情况染色.注意到四边形接下来的路径一定会形如$1 \rightarrow 2 \rightarrow 3 \rightarrow 4 $,建立分层图跑最小割.</p>
<h3><span id="捆绑更新答案">捆绑更新答案</span></h3><h5><span id="example12022qbxt国庆day6binary">Example1([2022qbxt国庆Day6]binary)</span></h5><p>首先因为有$- 1 $,我们先考虑一个朴素的暴力,从$L $到$R $枚举现在被匹配的数$i $,我们假设之前匹配到$p - 1 $,那我们接下来一定是要找到一个最小的$x \geq p $能把$i $给匹配掉,仔细思考这个过程,由于是二进制考虑最高位,不难发现我们只需要找到$( p \land i ) \oplus i $的最高位$1 $,然后把$p $的这一位改成$1 $,然后后面的位置全部设成$0 $,如果$i \subseteq p $那么就不用改.</p>
<p>冷静一下,二进制大概率是没啥通项公式的,还是要一点一点做.但是我们枚举每一个数实在是太慢了,我们考虑一个地方:$i \subseteq p $就不用改,下一步$i + = 1 , p + = 1 $,如果没有发生进位还是不用改,这个过程看上去就很可以优化.</p>
<p>所以我们考虑:当遇到$i \subseteq p $的时候,我们就捆绑更新.如果不满足就暴力更新.重复这个过程,每次不断暴力更新$\rightarrow $捆绑更新$\rightarrow $暴力更新$\rightarrow . . . $.每次捆绑更新至少会更新一个$lowbit $,而暴力更新的情况下,每次$p $至少会多包含一位$i $.就算后面进位把这一位消掉了,由于这里进位了,那下一步一定可以直接包含掉,于是复杂度也是$\log n $的,反复做一下就做完了,这里能分析复杂度$O ( T \log ^2 R ) $.我们冷静一下,发现二者复杂度算重了,捆绑更新会帮助暴力更新多匹配$1 $,于是复杂度$O ( T \log R ) $.但是肯定跑不满,考场甚至写了个上界$O ( T \log ^2 R ) $的仍然跑的飞快.</p>
<h5><span id="example2">Example2</span></h5><p>给定一棵树和一个值域为$n $序列$a $,每次询问给出$l , r , x $.</p>
<p>设$f ( x , y ) $为点$x $朝着$y $的方向走一步后得到的点,求$x $在经过$a [ l \cdots r ] $操作后得到的答案.</p>
<p>这么考虑:这题看上去就需要把任何一个数字$x $,通过若干个点变成了一个$f ( x ) $,我们要做的就是把$f ( x ) $求出来,这玩意很难求,考虑分块,单点用长剖做$O ( 1 ) $求$k $级祖先,然后对于每个整块预处理出它的$f $就可以了.</p>
<p>接下来的问题在于如何快速处理一个块的答案,考虑把所有的$x $扔到树上,然后一起维护它们的$f ( x ) $.这玩意看上去好像有点不太能做.</p>
<p>牛逼的一步来了:考虑对于每个块内的$\sqrt { n  } $个点,建立这些点的虚树,对于不在虚树上的点,它们一定会往虚树的方向跑(其实也就是向上跑),然后处理出时间扫描线转化成在虚树上的点的问题.对于在虚树上的点,考虑虚树一共有$O ( \sqrt { n  } ) $条边(也就是原树上的路径),我们用一个双端队列维护每条边上的点,显然每次每条边只会有$O ( 1 ) $的入队和出队,这样就实现了$O ( n ) $的预处理单个块.</p>
<h3><span id="单独更新答案">单独更新答案</span></h3><h5><span id="example1">Example1</span></h5><p>一个数轴上有$n $个小球,第$i $个小球在$x _i $坐标处.数轴上还有$m $个洞.第$i $个洞在$y _i $坐标处.你每秒可以以相同矢量速度移动所有小球.当一个小球和一个洞重合时,小球就会进洞.求一共可能出现多少种最终情况.(我们认为,两种”最终情况”不同,当且仅当存在一个球在两种情况中进入了不同的魔法洞中)</p>
<p>考场的想法:按照洞分类,把被同样两个洞夹起来的球一起处理,显然会有一段区间往左走一段区间往右走,按照这种区间的长度排序,然后硬dp,复杂度$O ( n ^3 ) $.</p>
<p>实际的做法:我们抛弃区间,单独考虑每个球.对于每个球而言,有用的信息只有它到左端点的距离和它到右端点的距离.我们把这两个距离缩为$( x _i , y _i ) $.接下来我们要给每个点$0 / 1 $染色,如果是$0 $代表它要到左边的洞里,如果是$1 $代表要到右边的洞里.那什么染色条件是无解的呢?</p>
<p>如果存在两个点$a $和$b $,$col _a = 0 $,$col _b = 1 $,那显然当$x _a \geq x _b \land y _a \leq y _b $时无解.换句话说,如果$col _b = 1 \land x _a \geq x _b \land y _a \leq y _b $,那么$col _a = 1 $.我们不妨按照$x $降序排序,$x $相同的按照$y $升序排列.那就会先决定$b $再决定$a $.注意到:如果$a $能确定$c $的状态,那$b $一定也能确定$c $的状态.因此我们采取这个策略:如果$x _a \geq x _b \land y _a \leq y _b \land col _b = 1 $,那我们直接不管$a $;反之,则考虑一下$a $的两种取值即可.具体一点,我们设$f _{ i , 0 / 1  } $表示以$i $结尾,$col _i = 0 / 1 $的方案数,然后顺着做就好.注意到:我们其实不关心$col _x $具体是啥,我们只关心最后的方案数.所以其实可以直接删去第二维.</p>
<p>zhq对这题的理解:</p>
<p>这可以等价成求一个上升子序列.上升子序列说的是如果$x _i &lt; x _j , y _i &gt; y _j $,$i $”选了”,$j $就必须”不选”.但是钦定必须选和必须不选,这两个限制是一样的.就是说,$j $没有选择的权力了.</p>
<p>这个说法很有意思,但是要注意:类似说法成立当且仅当我们认为$j $选了和认为$j $没选对后面不会产生影响.</p>
<h5><span id="example2petrozavodsk-summer-2015-moscow-ipt-contestopenstrain-contest-1464-jtwo-airlines">Example2([Petrozavodsk Summer-2015. Moscow IPT Contest(openstrain contest 1464) J]Two Airlines)</span></h5><p>这是一道交互题.给定一张$n $个点的完全图,每两个点之间是红色的边或是蓝色的边.可以询问$2 n $次某两个点之间的边的颜色,求一条哈密顿回路使得这条路上的颜色段最多有两个.</p>
<p>考虑将点逐个加入.假设现在的哈密顿回路的两种颜色分别是$r _s \rightarrow r _t $和$b _s \rightarrow b _t $,当前要加入$x $,我们每次询问$x $和$r _t $和$b _t $之间的颜色,如果可以加入链就加入.如果不能加入,必然意味着$x $和$r _t $之间是蓝边,和$b _t $之间是红边,我们查一下$r _t $和$b _t $之间是什么边,然后将其中一个点与$x $一起扔到对面就行.</p>
<p>不过这样用了$3 n $次询问,考虑先询问$r _t $和$b _t $之间的颜色,这样就能省掉一种.</p>
<h3><span id="寻找不变量">寻找不变量</span></h3><h5><span id="example1noip2021-方差">Example1([NOIP2021] 方差)</span></h5><p>首先我们注意到:设$b _i = a _i - a _{ i - 1  } $这个操作相当于交换$b _{ i - 1  } $和$b _i $.</p>
<p>接下来推一下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ^2 S ^2 & = n \sum _{ i = 1  } ^n a _i ^2 - ( \sum _{ i = 1  } ^n a _i ) ^2 \\
& = n \sum _{ i = 1  } ^n ( \sum _{ j = 1  } ^i b _j ) ^2 - ( \sum _{ i = 1  } ^n ( n - i + 1 ) b _i ) ^2 \\
& = n \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i b _j \sum _{ k = 1  } ^i b _k - \sum _{ j = 1  } ^n ( n - j + 1 ) b _j \sum _{ k = 1  } ^n ( n - k + 1 ) b _k \\
& = n \sum _{ j = 1  } ^n b _j \sum _{ k = 1  } ^n b _k \times ( n - \max \{ j , k \} + 1 ) - \sum _{ j = 1  } ^n ( n - j + 1 ) b _j \sum _{ k = 1  } ^n ( n - k + 1 ) b _k \\
& = n \sum _{ j = 1  } ^n b _{ n - j + 1  } \sum _{ k = 1  } ^n b _{ n - k + 1  } \times \min \{ j , k \} - \sum _{ j = 1  } ^n jb _{ n - j + 1  } \sum _{ k = 1  } ^n kb _{ n - k + 1  } 
\end{aligned}</script><p>令$c $为$b $的倒置数组,则原式</p>
<script type="math/tex; mode=display">
\begin{aligned}
& = n \sum _{ j = 1  } ^n c _{ j  } \sum _{ k = 1  } ^n c _{ k  } \times \min \{ j , k \} - \sum _{ j = 1  } ^n jc _{ j  } \sum _{ k = 1  } ^n kc _{ k  } \\
& = 2 \sum _{ j = 1  } ^n nc _j \sum _{ k = 1  } ^j c _k k - 2 \sum _{ j = 1  } ^n jc _{ j  } \sum _{ k = 1  } ^j kc _{ k  } + \sum _{ i = 1  } ^n c _i ^2 i ( i - 1 ) \\
& = 2 \sum _{ j = 1  } ^n ( n - j ) c _j \sum _{ k = 1  } ^j c _k k + \sum _{ i = 1  } ^n c _i ^2 i ( i - 1 ) \\
& = \sum _{ j = 1  } ^n ( n - j ) c _j \sum _{ k = 1  } ^n c _k k + \sum _{ i = 1  } ^n ( n - 1 ) ic _i ^2 
\end{aligned}</script><p><del>推到这一步发现好像没啥用但是推了好久懒得删了</del></p>
<p>冷静一下,由于一开始的数列是单调递增的,所以改变后的数列一定也是单调递增的(差分数组均$\geq 0 $).感性上理解,我们肯定是想让尽可能多的数接近绝对值,于是让重新排列后的差分数组呈现单最小值的峰看上去就很优秀.</p>
<p>这样我们设计$dp _{ i , S  } $表示现在填到第$i $小的$b $,$\sum a = S $的情况下最小的$\sum a ^2 $,复杂度$O ( n ^2 a ) $.</p>
<p>注意到$a $很小的时候大部分$b $都是$0 $,于是可以优化为$O ( na ^2 ) $.</p>
<h5><span id="example2agc030e-less-than-3">Example2([AGC030E] Less than 3)</span></h5><p>注意到:当我们把一个位置取反的时候,这个位置相邻的左右两个位置一定有一个$0 $和一个$1 $,所以我们的操作等价于移动$0 $和$1 $的分界线.</p>
<p>然后枚举一下从边界多产生了多少个分界线就行.</p>
<h3><span id="组合意义">组合意义</span></h3><h5><span id="example1arc110d">Example1(ARC110D)</span></h5><p>注意到这相当于先把一个长度等于$m $的序列划分成$n + 1 $段,再从第$i $段选出$a _i $,其中$a _{ n + 1  } = 0 $.</p>
<p>于是自然是$\binom { n + m  } { \sum a + n  } $.</p>
<h5><span id="example2abc231g">Example2(ABC231G)</span></h5><p>乍一看,感觉完全不可做.因为一开始给定$a $了,感觉上好像也不太能组合意义.</p>
<p>如果没有$a _i $怎么做?我们设$f _n $表示将$k $个小球分到$n $个盒子后的答案.那乘法相当于:分完后,在每个盒子中取出一个小球的方案数.于是$f _n = \binom { k  } { n  } n ! n ^{ k - n  } $.</p>
<p>那给定$a $咋做呢?我们注意到上面的式子好像可以对于任意$n $快速求.于是将原式子拆为:$\prod ( a _i + b _i ) $,那答案就是选出$n - x $个$a $和选出$x $个$b $的答案.前者可以背包,后者也就是$f _x = \binom { k  } { x  } x ! n ^{ k - x  } $.</p>
<h5><span id="example3agc060d">Example3(AGC060D)</span></h5><p>不妨设$C _p = \{ i | p _i &gt; p _{ i + 1  } , 1 \leq i &lt; n \} $.</p>
<p>用一下组合意义,注意到答案等于:</p>
<script type="math/tex; mode=display">
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2</script><p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<script type="math/tex; mode=display">
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2 = \sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C _p ] ) ^2</script><p>这个咋做呢?我们考虑用组合意义展开:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C _p ] ) ^2 \\
& = \sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) 
\end{aligned}</script><p>注意到$S $屁用没有,直接交换枚举顺序.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
& = \sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) 
\end{aligned}</script><p>考虑$( \sum _{ p  } [ T _1 \subseteq C _p ] ) $怎么求,注意到这等价于所有$T _1 $中的位置全都被钦定为$&gt; $,而其他位置任意,如果我们设所有以大于号连接的部分的长度为$l _1 , l _2 , . . . , l _k $,那么这里的答案就是$n ! \prod _{ i = 1  } ^k \frac { 1  } { l _i !  } $.</p>
<p>但我们很快发现了难点:$2 ^{ | T _1 \cap T _2 |  } $这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在$T _1 $和$T _2 $中都是$&gt; $的位置,这个好像不太好求,因为$&gt; $是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
& = \sum _{ T _1 , T _2  } 2 ^{ ( ( n - 1 ) - | T _1 \cup T _2 | ) - ( n - 1 )  } ( - 2 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
& = 2 ^{ 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 |  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ | T _2 |  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T _1 \cup T _2 |  } 
\end{aligned}</script><p>其中$n - 1 - | T _1 \cup T _2 | $意味着均不在$T _1 $和$T _2 $中的位置的数量.为了给每一段连续的$&gt; $都分配权值,我们进行一个细小的修改:</p>
<script type="math/tex; mode=display">
2 ^{ - 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 | + 1  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ | T _2 | + 1  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T _1 \cup T _2 |  }</script><p>写到这里应该就能发现,接下来必然要对$n - 1 - | T _1 \cup T _2 | $做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对$T _1 $和$T _2 $求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了$&gt; $,我们自然有:</p>
<script type="math/tex; mode=display">
\begin{gathered}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\

\end{gathered}</script><p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时$| T _1 \cap T _2 | $这个限制就显得尤其强,如果只是$S \subseteq T _1 , T _2 $就会好做很多:我们可以钦定$S $作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\
& = 2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } \sum _{ S \subseteq T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ S \subseteq T _2  } ( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) \\

\end{aligned}</script><p>令$f ( T ) = \sum _{ S \subseteq T  } ( \frac { 1  } { ( - 2 ) ^{ | T | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) \ $,则原式即:</p>
<script type="math/tex; mode=display">
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2</script><p>考虑下面这个东西怎么求:</p>
<script type="math/tex; mode=display">
\sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2</script><p>注意到,如果我们把每一段($[ T _i , T _{ i + 1  } ) $)的贡献求和,那么$f ( T ) $相当于这些和乘起来,那么$( \sum _{ S \subseteq T  } f ( T ) ) ^2 $就是这些和的平方乘起来.换句话说,我们自然有$ans _n = \sum _{ m  } ans _{ n - m  } g ^2 _{ m  } $,其中$g _m $表示长度为$m $的一段的贡献之和.而$g _{ n  } = \sum _m g _{ n - m  } \frac { 1  } { - 2 m !  } $.二者都可以使用分治FFT或多项式求逆解决.更进一步地,$h _i = \frac { 1  } { - 2 i !  } , G = \frac { 1  } { 1 - H  } , F = \frac { 1  } { 1 - G  } $.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将$( &gt; , &gt; ) $容斥掉,这样我们有若干种对:$2 ( &lt; , &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e ) $,然后我们发现两个序列联系得太紧了,我们考虑分配系数:$&lt; \rightarrow \sqrt { 2  } $,$e \rightarrow - \frac { 1  } { \sqrt { 2  }  } $,但是这样发现$( e , e ) $算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h3><span id="复杂度抵消">复杂度抵消</span></h3><h5><span id="example1cf1439b">Example1(CF1439B)</span></h5><p>首先注意到度数小于$k - 1 $的点一定没用,于是可以不断删点.删点后的图度数全部$\geq k - 1 $.</p>
<p>首先如果剩下的点度数全都$\geq k $那就直接找到答案,不然,我们看一下度数为$k - 1 $的点:它要么在团里,要么没用.不妨直接暴力判断是否在团里,复杂度$O ( k ^2 ) $.</p>
<p>欸等一下,这总复杂度$O ( mk ^2 ) $了啊,这咋办?</p>
<p>首先,删完点后的度数全都$\geq k - 1 $,注意到此时的点数是$O ( \frac { m  } { k  } ) $的.所以复杂度$O ( mk ) $.</p>
<p>好像还是过不去,这咋办?</p>
<p>冷静一下,如果$k \geq \sqrt { m  } $,显然不可能存在团.于是复杂度$O ( m \sqrt { m  } ) $.</p>
<h3><span id="寻找关系式">寻找关系式</span></h3><h5><span id="example1">Example1</span></h5><p>一张有向图,边有两种颜色,从$s $开始随机游走,维护一个权值.经过第一种颜色的边,权值$+ 1 $.经过第二种颜色的边,权值归$0 $.保证$t $没有出边,所有点均能到$t $.询问到$t $时权值的期望和方差.$n \leq 100 $.</p>
<p>(注意方差为平方的期望减去期望的平方.)</p>
<p>注意到难点在于权值归$0 $.所以一个点到$t $的期望权值一定和到达它时的权值有关系.</p>
<p>然后就来到了降维打击的时间:我们可以使用数学归纳法证明,如果到一个点$u $的权值是$x $,那它到达$t $的权值一定形如$a _u x + b _u $.</p>
<p>如果要严谨一点的话,我们发现第一种颜色的边会影响常数项,第二种颜色的边会影响一次项,因此最后的答案一定是一次函数.</p>
<p>最后可以使用高斯消元直接求出每个点权值的$a _u $和$b _u $,就可以求出期望.</p>
<p>至于方差是同理的,你注意到平方的期望一定是一个二次函数.</p>
<h3><span id="特判边界">特判边界</span></h3><h5><span id="example12022icpc杭州e">Example1(2022ICPC杭州E)</span></h5><p>第一反应肯定是一点一点调整成$\{ 1 , 2 , . . . , n \} $的形式,写个暴力验证一下发现当$n \geq 4 $的时候的确都可以调整成功.</p>
<p>假设目前形如:$[ 1 , k ] , A , k + 1 , B $.我们考虑如何调整:</p>
<ol>
<li>$| B | \ne 0 $.</li>
</ol>
<p>我们有:</p>
<script type="math/tex; mode=display">
\{ [ 1 , k ] , A , k + 1 , B \} \rightarrow \{ B , A , k + 1 , [ 1 , k ] \} \rightarrow \{ [ 1 , k + 1 ] , B , A \}</script><ol>
<li>$| B | = 0 , | A | = 0 $.</li>
</ol>
<p>直接合并就行.</p>
<ol>
<li>$| B | = 0 , | A | \geq 2 $.</li>
</ol>
<p>假设$A = A _1 A _2 $,我们有:</p>
<script type="math/tex; mode=display">
\{ [ 1 , k ] , A _1 , A _2 , k + 1 \} \rightarrow \{ A _2 , k + 1 , A _1 , [ 1 , k ] \} \rightarrow \{ [ 1 , k + 1 ] , A _1 , A _2 \}</script><ol>
<li>$| B | = 0 , | A | = 1 $.</li>
</ol>
<p>此时一定有$k \geq 2 $,发现有点难构造,但是我们猜测是可以构造出来的.不难证明这个问题等价于将$\{ 1 , 2 , 4 , 3 \} $调整为$\{ 1 , 2 , 3 , 4 \} $,写个暴力跑一下就行.</p>
<h3><span id="摩尔投票">摩尔投票</span></h3><h5><span id="example1cf643gchoosing-ads">Example1([CF643G]Choosing Ads)</span></h5><p>将摩尔投票扩展一下.我们现在想求其中出现次数大于等于$\lfloor \frac { n  } { p  } \rfloor $的数字,令$k = \lfloor \frac { 100  } { p  } \rfloor $,我们考虑每次取出$k + 1 $个两两不同的数字并且全部杀掉,那么做完这一步操作后,该满足条件的仍然满足条件(讨论一下),于是拿线段树维护当前的五个数的出现数量,每次对着杀就行.</p>
<h3><span id="寻找周期性">寻找周期性</span></h3><h5><span id="example1cf1463fmax-correct-set">Example1([CF1463F]Max Correct Set)</span></h5><p>自然的想法是$O ( n 2 ^{ \max ( x , y )  } ) $作dp.</p>
<p>接下来比较牛逼的是,注意到如果$S _1 $满足条件,令$m = x + y $那么$S _1 \cup ( S _1 + m ) $也满足条件.</p>
<p>我们考虑$S _1 $中满足条件意味着什么,意味着$\forall a , b \in S _1 , a &lt; b $,$b - a \ne x \land b - a \ne y $,这意味着$m + b - a \ne x \land m + b - a \ne y $,这同样意味着$m + a - b = x + y + a - b \ne x + y - x \land m + a - b \ne x + y - y $.</p>
<p>因此,只要我们找到了一个长度为$m $的可行解,我们一定可以将其不断扩展到全部集合.</p>
<p>进一步地,我们一定能证明:原集合中的最优解是以一个长度为$m $的可行解作为周期的.</p>
<p>这个是为啥呢?我们设$n = km + c $,那么我们直接求出一个长度为$m $的解,满足前$c $位对答案的贡献的权值是$k + 1 $,后$m - c $位贡献的权值为$k $,然后直接求答案.注意到如果最大答案另有其人,我们一定可以拿其中的某一段不断循环得到更大的答案,这就不符合我们的假设了.</p>
<h3><span id="补集转化">补集转化</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个$n $个点$m $条边的无向图,求给每一条边定向使得$1 $和$2 $能到达同一个点(可以是$1 $或$2 $)的方案数.$n \leq 15 , m \leq \frac { n ( n - 1 )  } { 2  } $.</p>
<p>考虑正难则反,算不存在的概率(事实上也确实很好理解,因为存在性问题通常都要取补集),这时候我们发现:此时$1 $能到达一个集合$S $,$2 $能到达一个集合$T $,$S $和$T $无交,并且两个集合之间不可能存在边,因此我们只需要算$f ( S ) $表示$1 $能到达$S $中的点的方案数即可,$2 $同理.</p>
<p>那么这个怎么算呢?我们仍然考虑正难则反,如果$1 $不能到达$S $中的所有点,那么$1 $一定只能到达$S $中的一部分点,枚举这一部分,假设是$T $,就可以用$f ( T ) $算$f ( S ) $的答案.</p>
<h3><span id="二进制分组">二进制分组</span></h3><h5><span id="example1loj3273">Example1(loj3273)</span></h5><p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点$( x , y ) $,随着$x $的增大$y $不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.我们使用二进制分组,将所有点分为大小为$0 , 1 , 2 , 4 , \cdots , 2 ^k $大小的组,当然有些组可能没被分出来.然后如果有两个大小都是$2 ^k $的组,我们暴力合并二者,得到一个还没被折线扫过的新的大小为$2 ^{ k + 1  } $的组.</p>
<h5><span id="example2luogu7447-ynoi2007-rgxsxrs">Example2(Luogu7447 [Ynoi2007] rgxsxrs)</span></h5><p>一眼看上去和CF702F很像,但是区间操作感觉很艰难,怎么做呢?</p>
<p>我们对值域分块:分成$[ 0 , 1 ) , [ 1 , 2 ) , [ 2 , 4 ) , [ 4 , 8 ) , \cdots $,这样只会分成$\log V $段,每段内部维护平衡树来处理下标.那么对于一个$x $,它会把后面的段全部打上一个$tag $,有些位置要掉落到下面的段上,这个维护每个段的最小值就可以处理(最多只会掉落$\log n $段),问题是和$x $在同一块内的没有办法打tag,但这一部分一定会掉落到下面的段,一块处理.</p>
<p>好,下面开始思想总结:</p>
<p>首先,我们发现这个区间和值域都很难处理,但是感觉值域更加重要,应该是对值域做均摊(也就是类似CF702F的打tag操作和暴力修改操作分开),于是考虑到对值域分块然后内部平衡树,然后发现可以做了吧.不太清楚,也有可能只是值域分块的套路.</p>
<p>Luogu9069是同款思路,判一下负数.</p>
<h5><span id="example3cf1515i-phoenix-and-diamonds">Example3(CF1515I Phoenix and Diamonds)</span></h5><p>俗称带修T-shirt.</p>
<p>做法大概是这样的:我们考虑对于每次给出的$c $,不妨假设它在$[ 2 ^k , 2 ^{ k + 1  } ) $这个块上,那么如果它减去了任何一个还在这个块里的数字,那就一定会掉落到下一个块中.这样就又有均摊了.</p>
<p>但是我们不一定能减去一个还在这个块里的数字,我们怎么做呢?</p>
<p>我们考虑最后的操作一定是减去若干个小于这个块的,最后有可能再减去一个这个块的,然后$c $就掉到了下一个块,考虑先按照价值排序,然后维护$f _i $表示排名在$i $前面且代价在更小的块中的代价和,我们要找到最靠左的小于$c - 2 ^k $的$f $,这个可以做线段树二分维护.</p>
<p>[IOI2021]地牢游戏 类似,但是因为是在图上做,所以把二分要改成倍增.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>英美戏剧与电影大作业</title>
    <url>/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="the-bright-morning-stara-sequel-to-a-streetcar-named-desire">The Bright Morning Star(A Sequel to <em>A Streetcar Named Desire</em>)</span></h3><p>MATRON: This is her room. [<em>She knocks on the door.</em>] Miss DuBois,</p>
<p>here is someone who wants to visit you.</p>
<p>MITCH [<em>overwrought</em>]: Thank you. Has anyone visited her before? And</p>
<p>has she recovered?</p>
<p>MATRON: No, no. Although she has recovered a lot, sometimes she’ll</p>
<p>crouch over and tremble in corners as if someone will hurt her, and</p>
<p>she’ll try to hit anyone who wants to touch her when she’s insane.</p>
<p>[*She pushes the door open and lets Mitch in. The room where Blanche</p>
<p>lives now is a pure white space without windows, and a naked bulb</p>
<p>brightens the whole room as if it were daylight. There is a collapsible</p>
<p>bed in the corner of the room and a Bible on the table. Blanche sits on</p>
<p>a chair in a blue dress and stares at Mitch, which makes Mitch feel a</p>
<p>little guilty. Then the Matron goes out and leaves Mitch in the room.*]</p>
<p>MITCH [<em>keeping his head lower, staring at his hands</em>]: Hello, Miss</p>
<p>… DuBois.</p>
<p>BLANCHE [<em>happily</em>]: Hello, Mitch. I’m glad that you could visit me.</p>
<p>You know, I haven’t spoken to anybody for a long time. I … I didn’t</p>
<p>mean that the Doctor and the Matron treated me badly, and I also didn’t</p>
<p>mean that you are just a … talkative partner in my heart. [*Her voice</p>
<p>dies out nervously.*] You know that, you know that … did you bring</p>
<p>some whiskey or lemon coke for me?</p>
<p>MITCH: No, the Matron said that you can’t have any liquor.</p>
<p>BLANCHE: That’s a pity. Did you bring some unwashed grapes for me?</p>
<p>MITCH: What?</p>
<p>BLANCHE [<em>smiled</em>]: That’s just a joke.</p>
<p>MITCH [<em>relieved</em>]: It’s a relief to see you more delighted and</p>
<p>energetic now. [<em>There is a pause.</em>] The room is so … white, like a</p>
<p>… marble palace.</p>
<p>BLANCHE [<em>delightedly</em>]: Yes. Yes, I know that you mean to say “Ivory</p>
<p>tower”. The room is neat and … it is better than Elysian Fields,</p>
<p>right? I feel like a new human being with the white walls, the light,</p>
<p>and the Bible here. And Shep Huntleigh called me a few seconds ago. Soon</p>
<p>I’ll leave here and go to the real palace, being old and full of days.</p>
<p>The Lord will bless the latter end of mine more than my beginning.</p>
<p>[*The music of the polka rises, faint in the distance. She gets</p>
<p>crazy<em>] No, no, I don’t want to hear it again! [</em>Mitch gets</p>
<p>shocked.*] I’m sorry for that. I … I don’t know why sometimes I</p>
<p>behave like … like … Oh, how is your mother?</p>
<p>MITCH [<em>sadly</em>]: She has passed on.</p>
<p>BLANCHE: I’m sorry to hear that. [<em>There is a pause.</em>] Oh, don’t let</p>
<p>silence ruin our meeting. We haven’t met for …</p>
<p>MITCH: Seven months.</p>
<p>BLANCHE: Yes, seven months … It’s difficult for me to count the days</p>
<p>because there’s no calendar, nor sun … How about Stella’s baby? When I</p>
<p>feel lonely at night, I will miss the lovely baby. I haven’t seen him</p>
<p>… or her? Oh, it is not important, you know, Stella is my precious</p>
<p>little sister, and her baby is my precious little nephew … although</p>
<p>the baby’s father is … Stanley.</p>
<p>MITCH [<em>avoiding Blanche’s eyes</em>]: That’s why I came here, Blanche, I</p>
<p>have known the brutal thing that Stanley had done. I feel angry and …</p>
<p>sorry for it. I want to confess my behavior to you and … beseech your</p>
<p>forgiveness. [<em>His voice dies out.</em>]</p>
<p>BLANCHE: What thing? I must forget something. Pardon me, let me remember</p>
<p>for a moment … [*She starts shaking all over and panting for</p>
<p>breath.<em>] No, no, no! [</em>She screams*] That’s enough.</p>
<p>MITCH [<em>bravely</em>]: You know, Blanche. I … I’m sorry for what Stanley</p>
<p>… and I have done.</p>
<p>BLANCHE: I forgive you! You are the man that is without sin.</p>
<p>MITCH [<em>shocked</em>]: No, no, I’m not …</p>
<p>BLANCHE [<em>raising her voice</em>]: You are the one! It is you who lighten</p>
<p>my life … although just for a while. But that is not your fault. I</p>
<p>don’t deserve the light for my sinful self. It must be God’s punishment</p>
<p>…</p>
<p>MITCH [<em>restlessly</em>]: No, Blanche, you are …</p>
<p>BLANCHE: A courtesan, I’ve known it.</p>
<p>MITCH [<em>embarrassedly</em>]: No, Blanche, I didn’t mean that.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: So why do you come here? To remind me</p>
<p>of the past which I try to forget, to sneer at my fate that I have been</p>
<p>trapped in this prison, or just because you want to have a sweet rest</p>
<p>without guilt?</p>
<p>MITCH [<em>embarrassedly</em>]: No, no, Blanche, I come here with kindness. I</p>
<p>know the memory of Stanley is so harsh for you and I … I have no</p>
<p>hostility to mention it. And … and, you see, the room is not so bad as</p>
<p>a prison. It is safe. No one will hurt you here.</p>
<p>BLANCHE [<em>coldly</em>]: And no one will love me here.</p>
<p>[<em>They keep silent for a while.</em>]</p>
<p>MITCH [<em>nervously</em>]: Maybe we can turn the light off. The room is too</p>
<p>bright.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: Don’t touch the button. From the</p>
<p>first day I came here, the merciful Doctor and the Matron kept the bulb</p>
<p>on because they thought I’d be cured when there was no night. It works!</p>
<p>Now I love the light, it makes the room like a … white coffin. Yes, a</p>
<p>white coffin made of white woods.</p>
<p>MITCH: Don’t talk about death. You said you were afraid of it.</p>
<p>BLANCHE [<em>faintly</em>]: That was the past. In the past, I always wanted</p>
<p>to get away from death. Before I met you, I escaped to desire; after I</p>
<p>met you, I was lost in hope. In the past, I clutched at anything that</p>
<p>would tell me that I’m alive, and when there was no solid thing in</p>
<p>reality, I tried to clutch at myself … although I’m not solid enough.</p>
<p>The seven months I have spent here helped me understand death. Maybe</p>
<p>death isn’t just about crying and darkness but salvation and light. I</p>
<p>thought I dreamt about Jesus a few days ago and he said, “Today shalt</p>
<p>thou be with me in paradise.” I wanted to ask him what paradise is like</p>
<p>but … I could speak no word, and then I woke up ... But, but I could</p>
<p>imagine it! You see, the room is … is as stainless as heaven. You see</p>
<p>I’m more delighted and energetic here! It is doubtless that I’ll keep</p>
<p>delighted and energetic in heaven after I pass on … if I can go to</p>
<p>heaven by entering in at the strait gate … Do you think I can?</p>
<p>MITCH: Yes, of course.</p>
<p>BLANCHE [<em>laughed</em>]: God love you for a liar! But let me tell you the</p>
<p>truth: I’ve chosen a wide way that leadeth to destruction … it’s real</p>
<p>… but why I talk about the truth …</p>
<p>MITCH: I’m serious. I have made up my mind to come here … and I want</p>
<p>to take you away.</p>
<p>BLANCHE: I am not clean enough.</p>
<p>MITCH: Everyone is not clean enough. Everyone has … a sinful past. The</p>
<p>world is broken, Blanche …</p>
<p>BLANCHE: No, Mitch. I\’m too delicate and painful, but you … are</p>
<p>realistic and natural. How can we live together … just because we long</p>
<p>for a partner? Sick people have such deep, sincere attachments. But the</p>
<p>truth is that I’m sick and you’re not. How can you forbear me when I’m</p>
<p>on the edge of lunacy and want magic?</p>
<p>MITCH: If we … get married, I swear that you won’t be on the edge of</p>
<p>lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world is …</p>
<p>always too harsh. [<em>There is a pause.</em>] It’s getting late. Maybe the</p>
<p>bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend my</p>
<p>funeral in the future? I have no idea when it will be held. But I know</p>
<p>it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could imagine</p>
<p>it. It will be quiet and stainless, with pretty flowers … right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t … don’t</p>
<p>answer me. Let it be a mystery, a fantastic mystery, just like the end</p>
<p>of a fairy tale. I had read so many fairy tales when I was young and I</p>
<p>always imagined that I’m a princess living in a palace, in a magic</p>
<p>palace, waiting for my prince and then having a happy ending. Everyone</p>
<p>believes that the protagonists of stories will have a happy ending, and</p>
<p>I’ll also believe it. Do you know the French story <em>La Porte étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the end</p>
<p>of the story, the hero and the heroine get married and have a happy</p>
<p>ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry. Tears</p>
<p>are so precious that you should save them for more precious people.</p>
<p>[*Mitch covers his face with his hands. Blanche wants to wipe away his</p>
<p>tears at first, but then she hesitates and turns back.*]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the former</p>
<p>things are passed away.</p>
<p>MITCH [<em>raising his head with eyes full of tears, hesitantly</em>]: Do you</p>
<p>… do you still remember the inscription?</p>
<p>BLANCHE: What inscription? I have forgotten about it.</p>
<p>MITCH: Alright … alright, I’ll go. Good night, Miss DuBois.</p>
<p>BLANCHE: I shall say “Good night” till it be morrow.</p>
<p>[<em>MITCH leaves.</em>]</p>
<p>BLANCHE: And if God choose, I shall but love thee better after death.</p>
<p>[<em>The lights fade away.</em>]</p>
<p><strong>END</strong></p>
<h3><span id="summary">SUMMARY</span></h3><p>At the end of <em>A Streetcar Named Desire,</em> Blanche says she has forgotten</p>
<p>something. In this sequel, Mitch visits the asylum where Blanche is</p>
<p>living to express his wish to take Blanche away. Blanche refuses him</p>
<p>despite her love for Mitch. While living in the asylum, Blanche has</p>
<p>understood more about death and love. She knows she is not clean enough</p>
<p>and wants to go to heaven and love Mitch after death.</p>
<p>Or is this sequel just Blanche’s another dream before death? In the</p>
<p>Bible, there is no night nor sun in heaven, just like the room.</p>
<h3><span id="theme">THEME</span></h3><p>It’s an attempt to explain Blanche’s change after Stanley’s rape. Before</p>
<p>that, she was afraid of death and tried to avoid harsh light. But after</p>
<p>that, she claimed that she’d be buried at noon. I tend to link it to her</p>
<p>chase for a fancy world like heaven.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙王子</title>
    <url>/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>我急匆匆进了酒吧，抬手看了看表上的时间，庆幸自己来得还早。</p>
<p>酒吧里只有稀稀拉拉几个人。我找了个没人的地方坐下，又拿手中的书占住旁边的一个位置。</p>
<p>我的左手紧握，攥着什么东西。我能感受到手心沁出的汗珠，黏糊糊的，以至于我不得不找服务员要了点纸。</p>
<p>“现在我该做些什么呢？”我想，离约定的时间还有半个小时。</p>
<p>这时，一个老乞丐凑了过来，一把移开我放在那里占位置的书，然后坐了下来。我正要发怒，那老乞丐却比了个噤声的手势，然后又忽然大笑起来。</p>
<p>“呦，这不是我们的大作家么，来这里等人么？”</p>
<p>我瞪了他一眼，站起身，拿起被他扔到一边的书，准备换个位置坐。但他竟一把按住我的肩让我坐下，然后笑嘻嘻地看着我。随后又把脸凑过来，漏出一口碎牙，“请我一杯酒，我可以为您讲个故事。”</p>
<p>我几乎快要为他的无礼而发疯了。我抡起书狠狠地将他打翻在地，但他仍旧笑嘻嘻地站起身来，“哎哟，早就听说您才华大脾气也大，写的故事怪而人也怪，今天算是见到了。但我敢打赌，您从来没有听过我讲的故事，那些吹捧你的俗人也从来没有听过我这个童话，它足以将您的所有作品都比下去呢。”</p>
<p>我对此嗤之以鼻，看了看表，时间尚且还早。于是我请了他一杯最便宜的啤酒，他看到酒端过来后笑嘻嘻地搓着手说，“哎呀，大作家出手就是阔绰。”然后他猛喝一大口，放下杯子来就开始讲。</p>
<p>“您一定听过青蛙王子的故事，一个女巫爱上了王子，因爱生恨而将他变成了一只青蛙。后来这个王子得到了一位公主的吻，爱的力量解除了诅咒，让他变回了俊俏的小王子。</p>
<p>“但这显然是个杜撰的故事，没有人见过青蛙变成王子。”</p>
<p>他露出一抹不屑的笑。</p>
<p>“但王子变成青蛙倒是可能的，这便是我接下来要讲的故事。</p>
<p>“其实真正的故事是，王子爱上了女巫，但女巫憎恶王子的骄傲和清高，于是施展魔法将他变成了一只青蛙。但女巫告诉王子，只要得到三样东西，他便可以重新变回王子的模样。</p>
<p>“于是王子问她是哪三样东西，女巫告诉王子，他需要拿到黄金的王冠，纯银的戒指，和一位公主的吻。</p>
<p>“黄金的王冠戴在巨人之王的手上，而巨人只会在一年一次的极夜陷入休眠，只有这个时候，青蛙王子才有机会从巨人的脚上一路向上爬，直到摘下那顶黄金的王冠。</p>
<p>“于是青蛙王子来到巨人国躲藏了一年，这一年它几乎时时胆战心惊，四处躲藏。终于等到了极夜，它一路紧紧攀着巨人发臭且粗糙的皮肤向上爬，直到摘下了那顶黄金的王冠。”</p>
<p>说到这里，他不禁又失声笑了起来。</p>
<p>“您知道嘛，那青蛙得了王冠，竟然真的觉得自己已经恢复了王子之身了。</p>
<p>“接下来是那枚纯银的戒指，它戴在蛇王的头上。青蛙这次没什么投机取巧的办法了，它唯有一条路可走，那就是苦练武艺，直到亲手杀死蛇王。</p>
<p>“这对于你我来说当然不是难事，但它是一只青蛙。它在一堆枯树枝中寻觅了良久才找到那根趁手的兵器，随后日夜勤加练习。直到那一天，它终于拿起树枝和蛇王苦战，最终遍身血肉模糊的它斩下了蛇王的头颅。”</p>
<p>我已然听入了迷，“那么公主的吻呢？”我问到。</p>
<p>那老乞丐笑着将杯中的酒一饮而尽。</p>
<p>“青蛙王子将黄金的王冠戴在头上，将纯银的戒指藏在舌头下，它此时真的像是一位王子了——但还少了一样东西，一样最重要的东西。‘一位王子，就要有和他相配的公主’他想。</p>
<p>“他日夜思索那位公主的模样，那位公主一定有着一头乌黑的长发，穿着淡蓝色的裙子，举手投足间尽显优雅。一定饱读诗书，一定多愁善感，会因为书中英雄的落幕而垂泪，会因为书中少女的迟暮而感伤。</p>
<p>“‘哦！’他想，‘只要我见到了这位公主——我一定一眼就能认出她来——我就为她献上我的纯银的戒指，她会给我一个吻，然后我就彻底摆脱了诅咒，从此像所有童话书的结尾一样，过上幸福的生活。’</p>
<p>“‘哦！’他想，‘那位公主会在什么时候出现呢？也许就在下个路口的转角，等我走到那里，一辆镶金的带着异香的马车就会缓缓驶过，我一跃跳到那马车上，将银戒指轻轻吐到那位公主面前，抬头向她展示我头上的金冠，然后为她高歌一曲，赞颂她的美丽与优雅，讲述我的苦难与不幸。然后她便会为我的魅力所折服，为我献上一吻，我从此就可以变回王子的模样了！’</p>
<p>“青蛙王子如此幻想着，他当然有资格幻想。在青蛙中，他可是前无古人后无来者的。试问哪一只青蛙可以取得巨人手指上的金冠，拿到毒蛇头顶的银戒呢？他当然是有资格这么想的。我想他当时还自称自己是青蛙中的凤凰。</p>
<p>“他就如此跳跃着跳跃着，满怀对着未来的憧憬，去寻找他的公主。”</p>
<p>“那后来呢？”我问。</p>
<p>“有一天青蛙王子越过田间的时候，却突然被一只手给抓住了。他扭头一看，是一位美丽的姑娘。青蛙王子一眼就爱上了这位姑娘，尽管她有着一头棕色的短发，身上穿着亚麻色的衣裳。</p>
<p>“‘啊，一只戴着金冠的青蛙！’那位姑娘惊呼道。青蛙王子立刻为自己头上的金冠，以及还未吐出的银戒而自豪了。说真的，从他历经磨难取下这两样事物的时候，他就有资格为它们而自豪。它们中的任何一件都是世间少有的珍宝。</p>
<p>“‘但这不是一位公主，’青蛙王子想着，‘我需要一位公主的吻才可以解除诅咒。’所以青蛙王子纵身一跃跳出了姑娘的手心。他往前跳了几步，却又不禁回头望向那位姑娘。望了两眼，又想到自己要破除诅咒的决心，扭头往前再跳几步，却最终又忍不住回头看。</p>
<p>“终于青蛙王子下定了决心，他连跳几步跳到姑娘面前，那位姑娘蹲下身来看着他，他们俩就这么四目相对。青蛙王子伸出舌头，将银戒放到姑娘的面前。然后开始大声唱起自己的赞美诗。</p>
<p>“但你猜怎么着，哈哈哈，在姑娘耳中，她根本听不懂青蛙在唱些什么，只听见青蛙‘呱呱’地大叫，大叫，大叫，哈哈哈哈哈哈……</p>
<p>“‘真是一只奇怪的青蛙’姑娘嘟囔着，站起身来准备去继续做自己的事了。青蛙王子看到这几乎不敢相信，所以他又大声唱起来，有几句还是他现场为姑娘写的词。</p>
<p>“但具体是什么词又有什么所谓呢，在姑娘耳中，这一切都只不过是聒噪的叫声。他以为自己是受了诅咒的王子，但在她眼中它只是只戴着金冠的青蛙。”</p>
<p>老乞丐讲完了故事，笑眯眯地站起身来。“我的故事讲完了，大作家，你应该还给我一个故事了。”</p>
<p>我愣住了，“我没有什么可还给你的。”</p>
<p>老乞丐放声大笑，笑过之后，他又露出了一口碎牙。</p>
<p>“那把你左手的银戒还给我吧，大作家。”</p>
]]></content>
      <categories>
        <category>习作</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>海的女儿</title>
    <url>/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>你知道的，我是海的女儿，我是不应该离开大海的。</p>
<p>海底的确没有光，但我本就不依靠我这双眼睛。我依靠我的感觉在海底游逛，依靠我的歌声取悦自己。你一定没有听过我在海底唱过的歌。当我唱起歌来的时候，会有一群群游动的小鱼围绕着我旋转、旋转。我看不清她们的样子，也不知道她们的名字。但我仍然爱着她们，即使几分钟后就会有一条鲨鱼被鱼群吸引而来，然后周围就会散开一阵阵的血腥味。我闭上眼睛（虽然我本来也什么都看不见），闻着海水里的苦涩和血腥交织的味道，我有点想哭。可我为什么要哭呢，鲨鱼不会伤害我，我是海的女儿。</p>
<p>海底会有老人鱼给大家讲海面上的故事，她们会讲她们的祖先与陆地上的人相爱的传说。很多年轻的小人鱼都对这些故事心驰神往，可我对它们不以为然。她们有一次问我：</p>
<p>“你就从没幻想过一位王子会带你离开这里吗？”</p>
<p>“可如果那位王子不会唱歌的话，那我也一定不会跟他离开。”</p>
<p>我并不明白海面上有什么值得我向往的，我在海底拥有着我希望拥有的一切：我的歌声、我的小鱼们……除了光。</p>
<p>海底为数不多的亮光是鮟鱇发出来的，我小的时候还会被这种小而轻灵的光芒吸引，偏执地游向每一点星光。可是靠近后唯一能看见的只有鮟鱇满嘴獠牙的狞笑。最后一次的时候，那只鮟鱇朝我张开了嘴，散出一片暗红色的血雾，夹杂着破碎的鱼鳞和鱼骨。</p>
<p>我吓得转身逃走，连回头看都不敢，一味地向上游动，游动，游动。可周围的鮟鱇好像全都闻到了这边的血腥味，我看着一点又一点光逐渐变亮，逐步聚拢。我吓坏了，闭上双眼继续想前游。我在心里安慰自己：</p>
<p>“它们不会伤害我的，我是海的女儿。”</p>
<p>我就这么游了好久好久，直到我终于听不见鮟鱇獠牙错动的声音，我停下来，双手捂住自己的胸口。我睁开双眼，却发现周围几乎全是闪动的光点。我尖叫起来，拼命挥舞着双手，可什么也没有打到。这时我才发现那些光好像是凭空游在水里的，没有什么鮟鱇。那些光将整个海洋照的幽蓝，我发现自己能看清自己的双手，也能看清周围游动的小鱼。我抬头向上望去，上面是浮动的大块的光斑。</p>
<p>这是我第一次来到海面上，当我游出水面上的时候，阳光随着水花破碎在我眼前。我不知道该如何形容天空，那好像是另一片我永远无法触及的海洋；我也不知道该如何形容太阳。</p>
<p>正当我望着远处的日光出神的时候，却听见远处有人的呼喊。我转头看过去，一个男人正在船上挥舞着双手，大喊道：</p>
<p>“姑娘，你是溺水了吗？我们这就来救你！”</p>
<p>我想回他的话，我想告诉他我没事。可我张开嘴才发现我喊不出声音。离开了海洋，我发不出一点声音。</p>
<hr>
<p>我去找了海底的巫师，我恳求她教我如何到岸上去，她也教给我了方法。</p>
<p>那天我再次向上游去，只不过这次我睁着双眼。深海里往哪里游都是一片黑暗，但我选择向我感觉中的方向游去。这次我亲眼看着我身边的黑暗一点点褪去，大海本身的颜色从永夜中显现出来，眼前逐渐出现了海面上的破碎的光斑。我放平身子，任由海水将我一点点向上托出水面，任由阳光铺满了我全身的鳞片。然后我将刀刺进了我的身体，用刀刃一点点划开我的身体，将原本还紧紧相连血肉分开，鲜血从我的身体中涌出、散开在周围，在光下我第一次看到鲜红被光刺穿后的那么飘渺的色彩，我像是套上了一件血色的轻纱舞裙。</p>
<p>我继续将刀往下划去，一点一点。我有一次被游动的鱼鳍划伤过，那是一阵瞬间的疼痛，沿着伤口像水流一样蔓延。但此时的疼痛却如此漫长，已经被划开的身体浸在海水中，仿佛海水在拼了命侵占我的身躯；而正抵在刀刃上的血肉则咬住刀刃，黏住刀刃不让它继续往下割去，可刀片一点一点撕开血管，撕开肌肉，撕开所有不愿分开的部分。那是一种很奇怪的手感，会让你回想起你之前咀嚼鱼肉的记忆，我记得我用牙齿轻轻一压就将里面的鱼肉压断，但外面的鱼皮却还连接着，这时我会轻轻磨动牙齿，第一次下牙向前磨动的时候鱼皮几乎被卷了起来，第二次上牙往前磨动的时候卷起的鱼皮缓缓舒展而从中间断裂。但这和刀割还是有区别，刀割的时候我的鳞片外皮和里面的血肉几乎连成一起，你必须用刀上下不断磨动，一点一点划开里面的纤维。直到刀刃将我的整条鱼尾完全割开，我终于精疲力尽，昏死过去。</p>
<hr>
<p>等我醒来的时候，发现自己躺在海滩上，下半身已经完全变成了人的双腿，而且真的穿上了一件轻纱红裙。一位男子——这正是当时在船上呼喊过我的那位——正蹲在我身旁察看我的情况。看到我醒过来他很是高兴，正打算叫人过来，我却一下子抱住他。我原本想要哭，可我张开嘴，却发不出一点声音。</p>
<p>他背着我，把我带到了海边的小渔村里。原来他并不是什么王子，而只是海边的一个普通的渔夫。但这都无所谓了，只要能每天都见到阳光，只要能每天都见到他，这都是无所谓的对吧。想到这里，我趴在他的背上将他抱得更紧，将脸几乎埋在他的脖颈里。我听着路过的人对此议论纷纷，但我毫不在乎。</p>
<p>他就这么背着我一路到了他家里，然后他把我放下来，扶我躺到床上。然后转头向里屋喊了一声。一个女人走了出来，他们紧紧拥抱在一起。我听着他向他的妻子讲我的情况，我看着他的妻子的脸上露出同情的神色，我发现我全身穿着的根本不是什么红裙，我其实赤身裸体，全身都是血迹、伤口和淤青，皮肤上沾了薄薄一层沙子，左腿上插了一块贝壳碎片，现在还在流着血。我看着他打开了家里的灯，我看着那刺眼的白光射进我的双眼，我用尽全力将头别了过去，拼命捂住我的头，我想大声呼喊，可我什么声音也发不出来。我想掀起床单盖住自己，可我又发现自己已经弄脏了整张原本洁白的床，上面现在全是我的血和沙子，涂抹成诡异的图像。我转头看向他，他的渔夫装上也全都是血。这时门开了，我看着他们的女儿穿着一身白裙子蹦跳着走进了房间，转头看到了我，吓得尖叫着哭着抱紧了她的妈妈。</p>
<p>我跑下了床，在穿过门的时候被门槛绊了一下，整个人向下摔去，一头磕在了门口的石板上。他从背后跑过来把我扶起来，我看着那片石板上全是我的血。</p>
<p>我挥手用力地把他甩开，然后向街上跑去。</p>
<p>街边聚集了一群群的人，他们交头接耳，指指点点。我不知道哪个方向是海的方向，我跟着我的感觉的方向跑去。全身的伤口立刻痛起来，每一次我脚落在地上，整个小腿就是一阵痉挛。有几次我几乎因此跪在地上，但我还是拼了命跑，往海的方向跑。我是海的女儿。</p>
<p>我的感觉没有错，我跑到了海边，当我把双脚伸入海水的那一刹那，我感受到了从未有过的无比的温暖。一层又一层的波浪扑上来治愈我的伤口，我忽然感到全身都轻松起来，我想发笑，可我还是什么声音也发不出来。</p>
<p>我转头，回头看着村子。我想看看他在哪里。</p>
<p>一群又一群人开始聚集在海滩上，有的像是刚在酒馆里一起把酒言欢的朋友，有的则是十指相握的夫妻。他们有人在劝我回去，所以我拔下了左腿上的那片碎贝壳，把它抵在我的喉咙上，然后指着人群想命令他们安静。可我什么也说不出来，但他们仍然安静下来了。</p>
<p>渔村里的窗户开始探出一个又一个的头，他们全都看着我。这像是一场盛大的审判一样。我忽然发现我认出了其中的几个人，我不明白，我是海的女儿，为什么我会认出他们。</p>
<p>他终于来到了海滩，我看着他拨开人群站到最前面。我们就这么对视了好久好久好久好久好久，我咧开嘴冲他笑了笑，他却怎么低下头去了。</p>
<p>“他不愿意看到我了。”我想着，转头奔向海洋。</p>
<p>海浪一次又一次打在我身上，但我知道她们是想清洗我身上的淤血，我知道她们在赐予我新生，我知道我的双腿正在愈合在一起，我将重新拥有一条闪动着鳞片的鱼尾，我是海的女儿。</p>
<p>我忽然想起来他一定不知道这些，他可能以为我在跳海自杀，但其实不是这样的，我是海的女儿。我想回头告诉他这些，我不会死，我只是在重新回到我从前的生活罢了，但我忽然又好奇他会不会为我而哭，所以我决定不告诉他这些，继续往大海深处一步一步走去。</p>
<p>先是我的双腿，然后是我的双手，最后当我的脖子也被海水淹没的时候，我终于忍不住回头看了一眼。人群小的像是沙滩上的一个个光点，我确信其中的某一个就是他，虽然我其实根本看不清他们的脸。我转回头来，在海里张开双臂，向前拥抱海洋。当我终于全身都被海水淹没的时候，我张开了嘴，却被海水呛了一下。这不应该，一定只是我上岸后太久没歌唱了的原因。我抑制住自己的恶心和反胃，拼力再次张开了嘴，现在我终于可以歌唱了。我是海的女儿。</p>
<hr>
<p>没人知道那个哑女为什么要跳海自杀。她在很小的时候就被从外地卖到村里的妓院去了。人们总猜测是因为那些嫖客对她太过粗暴，但也有人说她当时跳海的时候脸上满是幸福的表情。总之，大家只好把这件事归结为大海的感召。</p>
]]></content>
      <categories>
        <category>习作</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>卖火柴的小女孩</title>
    <url>/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>“地上好冷。”这是莉娃丽尔冻死在街头前最后闪出的念头。</p>
<p>路人熙熙攘攘从她旁边走过，但没有人会为她停留的。今晚正是平安夜，明天就是圣诞节。</p>
<p>她不记得去年的平安夜她是怎么过的了，但她记得在前年的平安夜，当她卖掉了第十三盒火柴后，她看着空空的篮子，又抬头看了看刚买了火柴的绅士，忽然开口说：</p>
<p>“先生，请问您能送我一根火柴么？”</p>
<p>那位西装革履的绅士愣了一下，然后和善地笑着抽出一根火柴送给了她。</p>
<p>她将那根火柴用原本盖在篮子上的布包好，小心翼翼地放在篮子里，然后一路小跑着回了家。在家门口她看见了泽基华尔兹先生，他面前是一棵刚刚运来的圣诞树，他正抱起一包礼物准备放在树下。莉娃丽尔欢快地向他打招呼：</p>
<p>“泽基华尔兹先生，您好！圣诞节快乐！”</p>
<p>然后她转头进了自己住的地下室。从自己的枕头底下摸出一根蜡烛，那是她两天前卖剩下的蜡烛，她本应将其还给雇佣她的商店老板。但那天她突然决定将这根蜡烛拿回家去。她回到家翻找自己的存钱盒——那原本是一个火柴盒，后来莉娃丽尔偷偷拿泽基华尔兹先生的笔在上面画了朵小花——从里面拿出了一根蜡烛的钱（那本是她下个月应交的租金），然后混在她卖蜡烛得到的钱里，跟商店老板谎称自己已经把蜡烛卖完了。</p>
<p>莉娃丽尔将蜡烛小心翼翼地放在桌子上。她在街上卖火柴的时候经常透过窗户看到市民们这么做，他们往往在桌子上摆上一排蜡烛，让几个孩子依次点燃它们。</p>
<p>莉娃丽尔又拿出了她篮子里的包裹，轻轻地打开，从里面拿出那根绅士施舍的火柴。她没有火柴盒，但她知道该怎么点燃它，她见过一个躺在街边要死的流浪汉是如何向她奢求一根火柴，在她给他后又是如何擦着自己的手背将它擦着，然后小心翼翼地点燃路边捡来的烟头抽了起来。</p>
<p>所以莉娃丽尔也拿起那根火柴。她一开始怕把火柴折断，只敢轻轻地擦过她的手背。但除了她自己手上被擦出几根红印子以外，什么也没发生。莉娃丽尔有点着急，因为她听见了外面钟楼的报时：还有十分钟平安夜就要过去了。她深呼一口气，将火柴在手上用力一划——火柴就这么折断在她的手背上。</p>
<p>她看着那半根火柴，忽然哭了出来。但她又想起了自己的存钱盒，所以她连忙将那个小盒子找了出来，小心地捏着半根火柴，然后猛地在盒子的侧面一蹭。但她手一抖，刚刚点燃的火柴和盒子一起掉在了地上。她连忙拿手去扑，但立刻被烫得缩回了手。此时她站起来扫视她的小地下室，想找些什么东西来扑灭这堆小火——她跑到床前捧起自己的被子，然后转身，来不及了。她的小存钱盒被烧成了一堆灰，她的那半根火柴棍倒是还剩下一些木头，但是火柴头已经被烧没了，留下黑色的一小块昂着头，好像也在看着莉娃丽尔。</p>
<p>莉娃丽尔站在那里，两手还捧着她的小被子，不知道该做些什么。忽然她意识到自己好像应该哭，但她试了试发现她哭不出来。</p>
<p>她想到自己可以去找泽基华尔兹先生借一根火柴。</p>
<p>泽基华尔兹先生是她的房东，也算是她父母的朋友。莉娃丽尔的父母长年在外地打工，莉娃丽尔就这么被他们托付给泽基华尔兹先生照顾。但泽基华尔兹在她的父母走后第二天就将莉娃丽尔叫过去，命令她每个月初都要缴纳五戈比的房租。他带着他那顶黑色羊毛帽，将手插到兜里，然后望着面前的莉娃丽尔说：“小姑娘，你要知道，我是你父母的朋友。正是因此我才会只要你如此少的租金。当然了，您一个小姑娘，况且才刚刚十一岁，靠自己当然是没有办法找到工作的。您知道的，我是您父母的朋友，所以我和商店老板商量好了，您可以帮他在街上卖报纸、蜡烛这类东西，等到了冬天还可以卖些火柴。您知道的，市民们总是很需要火柴的。等您十四岁后，我当然就可以为您提供一些新的工作。”</p>
<p>莉娃丽尔又欢快起来了，她知道泽基华尔兹先生一定会帮她的，他是她父母的朋友。</p>
<p>她飞奔出地下室，刚好碰见正欣赏自己杰作的泽基华尔兹先生。他看到莉娃丽尔，忽然咧出笑容：</p>
<p>“莉娃丽尔，过了这个平安夜，你就要十四岁了对吧。”</p>
<p>莉娃丽尔点点头，然后张口问泽基华尔兹先生能否借给她一根火柴。</p>
<p>泽基华尔兹笑得更开心了：“当然可以，莉娃丽尔。我还答应过等您十四岁的时候要为您介绍工作。您知道的，我是您父母的朋友，我绝不会食言的，这您是知道的。这份工作当然要远比您上街卖火柴要舒服得多。您甚至可以在冬天用上属于自己的火炉，我亲爱的莉娃丽尔。您知道的，亚特太太就住在不远处，我将在她那里为您找一份新的工作。”</p>
<p>莉娃丽尔于是跟着泽基华尔兹先生一路去找亚特太太。然后泽基华尔兹先生领她到了一个房间并让她待在房间里。不久后她听到了泽基华尔兹先生和亚特太太的争吵。</p>
<p>“什么！一百卢布？亚特太太，我想您应该重新想想。这么漂亮的一个小女孩，而且才刚刚十四岁，接一次客就能收十个卢布！三年前我到您这来，您告诉我警察会因为您这里有十一岁的女孩而找您的麻烦，并承诺我三年后可以给我两百卢布，现在您倒是全不记得了！一百卢布，开什么玩笑！”</p>
<p>莉娃丽尔忽然觉得好害怕，她从来没见过泽基华尔兹先生这么发过火。此时她才意识到她没能把她的那支小蜡烛一块带来，所以她立刻跑出了房间。她听见泽基华尔兹先生在后面怒吼，但她不敢停留，一路狂奔回了她的小地下室。然后拿上那支小蜡烛，准备去街上。她忽然记起她父母跟她说过他们就在不远处的一个小城里打工，她立刻决定去找她的父母。但当她走到地下室门前的时候，她发现泽基华尔兹先生站在门口。他面色凶恶地看着莉娃丽尔，莉娃丽尔从来没见他这么生气过。</p>
<p>“把衣服脱掉！”他朝着莉娃丽尔大吼，然后转身带上了门，并上了锁。</p>
<hr>
<p>莉娃丽尔自那天之后就一直被关在地下室里。她开始出现幻觉，她有的时候会忽然觉得自己的父母就在房间里，有的时候又会忽然在地下室里叫起来：</p>
<p>“卖火柴啊，卖火柴啊。绅士们，买一盒火柴吧！”</p>
<p>后来莉娃丽尔忽然又有一天看着墙壁，想要在上面画些什么。所以她拿着那根小蜡烛在墙上画出一朵小花，正像她之前在火柴盒上画的一模一样。但泽基华尔兹先生为此十分生气，他那天晚上拿着小刀狠狠地划着墙壁，把莉娃丽尔的小花划得七零八落，然后狠狠地揍了她一顿。所以后来莉娃丽尔再也没用蜡烛画过画，她把蜡烛扔到角落里，然后开始用手蘸着唾沫抹在墙上，这样在墙上的唾沫干之前，她还是有一朵小花。</p>
<p>后来她画着画着，直到有一天她发现一块砖头松动了。她试图去挪动那块砖头，却一不小心将它整个从墙上拿了下来。她看着在手上的砖头尖叫起来，她知道泽基华尔兹先生一定会为此再揍她一顿的。但泽基华尔兹先生却恰好在这个时候走了进来。他看了看墙上的窟窿，怒不可遏地向莉娃丽尔冲过去，但他却在这个时候被地上的蜡烛绊倒了。他趴在地上，正准备起来——但莉娃丽尔将砖头狠狠地拍向了他的头上。</p>
<p>莉娃丽尔跑到街上才发现今天恰好是平安夜。她觉得离上一个平安夜过了好长时间，所以她认定这是两年后的平安夜。莉娃丽尔走在街上，她想去找她的父母，但她不知道该去哪里找他们了。她就这么走在路上，直到迎面撞上一位绅士。她抬头看，然后认出了他——那是两年前送给她一根火柴的那位绅士。</p>
<p>但绅士没有认出莉娃丽尔，他只是看着莉娃丽尔身上褴褛的衣服和脸上的淤青，在胸前画了个十字。“上帝保佑您，小姐。”</p>
<p>莉娃丽尔扑到绅士身上，紧紧抱住他放声大哭起来。她觉得绅士一定可以带她去找她的父母，他是多么好的一位人啊，比莉娃丽尔见过的所有人都要好。她想跟绅士讲她过去经历的故事，她忽然想给绅士画一画那朵小花，所以她松开了手，然后把手伸进嘴里想蘸上点唾沫，但手指拿出来的时候却沾满了血，但莉娃丽尔小姐反而更加兴奋，她知道红色的小花要更加漂亮。她举起手指，在绅士眼前晃了晃，开心地笑了。</p>
<p>然后她看见了绅士的妻子带着他们的女儿走到了绅士旁边，她盯着那个女孩，她正穿着一件白色的大衣，脸颊被冻得有点发红。她听见绅士跟她们解释自己遇到了一位“可怜的女孩”，并看见他将手伸进口袋里，拿出一枚五十戈比的硬币。她突然明白自己的出现意味着什么，是她打扰了他们一家的平安夜。她低头看了看自己满是伤痕的身体，看了看自己已经破烂发臭的衣服，她终于明白了自己出现在这里对这位绅士来说是一辈子遇到的最令人作呕的事情。</p>
<p>她转头向街上跑去。</p>
<p>绅士没有叫住她。</p>
]]></content>
      <categories>
        <category>习作</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
</search>
