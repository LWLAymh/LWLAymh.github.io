<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于博客</title>
    <url>/2025/06/22/RDM/</url>
    <content><![CDATA[<h3><span id="碎碎念">碎碎念</span></h3>
<p>终于把博客搞好啦！大概以后会经常拿这个网站来发东西了。评论功能和联系功能都已经上线。学习笔记已经全部公开了，一些随笔会在筛选后公开一部分。</p>
<h3><span id="致歉">致歉</span></h3>
<p>另外需要声明的是，因为公开的往往是我直接在课上记录的笔记，因此可能会出现老师讲什么我抄什么，导致我的某篇笔记可能与某篇文章的思路雷同。由于文章太多难以对其中搬运的部分一一溯源，只好在这里提前致歉。如若您的确发现我博客中某一块内容来源于您，请联系博客，我会尽快作出修改。</p>
<h3><span id="致谢">致谢</span></h3>
<p>感谢ycmgg帮助构建了博客的最初架构。</p>
<p>感谢djzgg帮忙支持了博客的xypic渲染。</p>
]]></content>
  </entry>
  <entry>
    <title>逃</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E9%80%83/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#一">一</a></li>
<li><a href="#二">二</a></li>
<li><a href="#三">三</a></li>
<li><a href="#四">四</a></li>
<li><a href="#五">五</a></li>
<li><a href="#六">六</a></li>
<li><a href="#七">七</a></li>
<li><a href="#后记">后记</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>你所说的曙光究竟是什么意思。</p>
<p>——海子《春天，十个海子》</p>
</blockquote>
<h3><span id="一">一</span></h3>
<p>等我迷迷糊糊睁开眼时，阳光已经从窗帘外透进来了。</p>
<p>我裹着被子翻过身，想不起刚刚发生了什么。今天是周几、现在是几点、为什么我在这里躺着，突然一点都想不起来了。我半睁着眼盯着天花板，看着透过窗帘撒在上面的一点点光纹——像是漆黑的世界的裂痕。</p>
<p>我刚刚做了一个什么梦呢？一定是一个特别美好而温馨的梦，因为我现在脸上还带着笑呢。梦中好像有一个女孩，我还记得我在梦的结尾向她跑过去，拉起她的手。可她长什么样子、声音如何、我与她之间发生了什么故事呢？她又到底是谁呢？我一定认识她，因为梦里我对她有一种那么熟悉的感觉，是那种久别重逢一样、并且深信命运的指引使我们相识的感觉。</p>
<p>可我为什么现在什么都想不起来了呢。</p>
<p>我起身走到卫生间，站在镜子前，我打开水龙头，捧起一把水抹到脸上，但这水为什么一点都不凉，而且缺少水的质感，我像是把某种丝绸状的东西抹在了脸上，然后它们又缓缓一点点滑落了。我忽然想起来我现在脸上应该挂着水珠。所以我抬起头，看着镜子中的我，我的脸上的确有着水珠的，它就在那里——可我怎么看不清我的脸，镜子里面只有一个人的轮廓，依稀有黑色的头发和黑色的眼睛。</p>
<p>我感到害怕了。</p>
<p>我逃出卫生间来到客厅，几乎占据整个墙壁的窗户将屋子里的一切照亮。但为什么天空上面一无所有。我只能感受到那是一片天，是光进来的地方，却什么都看不见，没有蓝色也没有云，没有一切天空的质感。</p>
<p>我转头看见屋内的东西：茶几上的水杯，书架上的奖状，小时候的玩具……我突然意识到少了好多东西，我家中远远没有这么空荡。可我想不起来少了什么，想不起来。</p>
<p>我发了疯一样跑到镜子前，拼命地盯着镜中我的模样。我忽然想到我可以盯着自己的眼睛看，这样我的脸庞会在镜子和眼睛之间来回反射，我就可以借此看清自己。</p>
<p>耳边传来闹钟的声响。我看见镜子从我的眼眶中碎裂，其中反射的千万的我立刻爬满了碎纹。</p>
<h3><span id="二">二</span></h3>
<p>我从梦中惊醒，伸手向旁边一下关掉了手机闹钟，仍然因刚才的噩梦而惊悚。等我稍稍定神，打开手机，今天是周二，现在是早上五点五十七分，我应该起身去洗漱，然后去上班了。像是从前无数个日子一样。</p>
<p>我坐起来下了床，不要打开第一个格子，从床头柜第二个格子中拿出袜子穿上。然后走到衣柜前，挑出前天晚上洗好的白衣服穿上。我起身走出房间，转两个弯来到厨房，从冰箱中拿出面包和番茄酱，放在盘子里简单解冻。然后走去卫生间。</p>
<p>看到镜子的时候我又一惊，有点迟疑地打开了水龙头，这次流出来的水很冷，水流很大，看来我的确彻底从梦中醒了。这是毫无疑问的。</p>
<p>等到一切收拾妥当，闹钟响起，此时是六点二十分，我该出门去坐地铁。</p>
<p>地铁站离我家三四分钟的路程，等我过了安检来到站点，闹钟再一次响了，地铁也一同进站。我从兜里掏出手机关掉闹钟，现在是六点三十分。</p>
<p>上了地铁，我带上耳机放上音乐，然后闭上眼靠在椅子上。等我昏昏沉沉将要入睡的时候，闹钟响了，随之是地铁提示到站的广播。我关掉闹钟走下地铁，现在是六点四十五分。</p>
<p>从地铁站出来会经过一条走廊，走廊上挂着康定斯基的《Picture XVI, The
Great Gate of
Kiev》的照片。穿过走廊就是扶梯，一年中的某些时候，我借扶梯向上攀升的时候，会看到太阳也在升起。盛夏的时候我会迎面撞上最最刺眼的阳光，以至于我不得不举起手遮住眼睛。可过一段日子当我已经养成了习惯，却会在到达地面的时候，放下手才发现日光虚弱的盈在周围，我才终于知道夏天已经过去了。</p>
<p>走出地铁站向右拐，就是我上班的公司。等我坐在自己的工位上，闹钟会在七点最后响一次。这时桌上往往已经放好了今天的工作内容细表，这是我前一天晚上早已准备好了的。</p>
<p>如此一天。等到晚上下班，闹钟响。我指定好第二天的工作计划，闹钟再响。走出门来到地铁站，再次经过康定斯基的画。买完票来到站台，坐上地铁回到家，我和地铁一起穿行，穿行在狭窄的不知何地的空间，穿行在看似无边无际的时间。</p>
<p>五点五十分闹钟会响，车会到站。</p>
<h3><span id="三">三</span></h3>
<p>第二天我又被闹钟吵醒。我伸手向旁边一摸，却摸了个空，一阵寒意猛然涌起，我立刻清醒了，坐了起来。手机仍在床头柜上发着声响，直到我抬手将闹钟关上。</p>
<p>起身，不要打开床头柜的第一个格子，从第二个格子中拿出袜子穿上。走到衣柜前，继续穿上昨天的衣服。起身走出房间，转两个弯来到厨房，从冰箱中拿出面包和番茄酱，放在盘子里简单解冻。然后走去卫生间，将脸浸没在冷水里……</p>
<p>吃完饭，闹钟响起，现在是六点二十分，出门去坐地铁。过了安检来到站点，闹钟响起。关掉闹钟，走上地铁，我拿出耳机，靠在椅子上闭上眼睛。</p>
<p>我迷迷糊糊回忆着自己早上做过的事：起床，穿衣，准备早饭，来到洗手间，看向镜子，曾经梦到的那个女孩长什么样子来着……</p>
<h3><span id="四">四</span></h3>
<p>我突然惊醒，那个女孩就在我的眼前，笑盈盈地看着我。我看向周围，地铁已经到站了，身边的人都在往外走，我拿出手机一看，现在是六点四十三分，地铁早到站了两分钟。我意识到正是这个女孩将我从沉睡中唤醒了。</p>
<p>那个女孩看我醒了，就拿起她的东西也下了车。</p>
<p>我跌跌撞撞走出地铁。她是谁？是和我一样的乘客么？我们从前认识？不，我们根本素不相识，可能这只是一个陌生人无心的善举……可陌生人又怎么会知道我要在哪一站下车呢？</p>
<p>我的闹钟突然响起，我连忙从兜里拿出手机关掉。现在是六点四十五分，我在不知所措中向旁边一瞥，看到了康定斯基的那幅画，那凄冷的太阳，以及那么温暖的月光……</p>
<p>我在那幅画前浪费了太多时间，因此我刚走进公司，闹钟就不合时宜地响了起来。一路上的同事都在抬头看我，而我只能匆匆忙忙地走到座位前坐下，关掉闹钟，现在是七点零一分。</p>
<p>今天一切好像都与往常不一样，也许正是因为我早上晚到了一分钟，我几乎没有准时完成一个任务。总之终于熬到下班，闹钟一响，我却不像往常那样制定第二天的任务表，然后再收拾东西。我关掉闹钟后坐在椅子上，闭上眼睛，一点一点向后仰去……我忽然又有一种失重感了，我知道再往后仰去我就一定会摔倒在地上，所以我连忙睁开眼睛立直了身子。可稍微靠在椅子上，应该没问题吧，没问题吧……我又闭上眼向后靠去，脑子里一片昏沉……闹钟响了，我意识到再这么下去就赶不上地铁了。</p>
<p>一路跑出办公室，跑进地铁站，路过康定斯基的画，却来不及再看一眼了。买票，等车，上车，在车上玩着手机，实际上什么都看不进去，只是一直盯着时间，直到手机上的时间显示为五点五十分，闹钟响了，车也准时到站，一切好像如常。</p>
<h3><span id="五">五</span></h3>
<p>我回到家里，站在洗手台前，盯着镜子中的自己，比梦中的场景清晰得多，而且我眼中也的确有一个我的倒影，因此我敢断言这一切都不是梦。但我又不明白为什么，这一天似乎经历了太多太多，而且好像完全不寻常，但我又找不出奇怪的地方。地铁到站早了两分钟，毕竟不是什么很值得惊奇的事情。再精密的机器总会有失误的一刻。我的意思是，这一刻是总要来临的。当地铁如此周而复始，在每个精准的时间到达站点的循环中，只是两分钟的早点也许就逐渐地被写在命运中了……我忽然想起之前有一天，我出门才发现我把眼镜落在了家里——那一天足足七点十分我才到了公司。那天我走进公司的门的时候几乎有些战栗，可我最后还是一步一步挪到了座位前。可后来还是什么都没发生，那天大概是——也许两年前，也许三年前。总之，这件事后的第一个周我总是胆战心惊，每天晚上睡前都仔细检查一遍闹钟，调一调音量键，并在走前仔细检查自己的随身物品。可不到一个月后我就将这一天的经历抛之脑后。事实就是这样，今天也是一样。而且今天还并没有影响什么，也许一个周后我就可以忘记这些。</p>
<p>睡前我又想起了这件事，我忽然有些虔诚起来，我想如果今天的确有些不同，也许我可以在梦中得到一些启示，一些可以被缜密的心理学分析的细节。这种信念越来越坚定，“只要睡着，我就可以在梦里得到答案。”我反复这么想着。</p>
<p>可这一夜似乎没有做梦，又可能做了，但我忘掉了。总之当第二天五点五十五的闹钟响起的时候，我什么都想不起来。意识到这后，我暗自觉得有点遗憾。</p>
<p>我坐起来，外面才刚刚有点亮光。该收拾收拾去上班了，我想，然后我打开了床头柜的第一个格子。</p>
<p>等我意识到发生了什么的时候已经太迟了。</p>
<p>格子里面是一面爬满裂纹的镜子。</p>
<p>我瘫坐在地上，突然认识到这可能是个梦。所以我又站起身来，拿出那面镜子。但它反射出的我的面容是如此的清晰。黑色的眼睛，黑色的头发。</p>
<p>我拉开床帘，外面是蒙蒙白的天空，看不见太阳，可能被楼挡住了，我看向窗外，又看向镜子，看向镜子里的自己。手一滑，镜子掉到地上彻底摔成了玻璃碎片。</p>
<p>我低下身捡起一块碎片，然后划向自己的手腕。可我什么感觉都没有，手腕上面也没有划痕，我忽然疑心是不是当我的手捏着碎片划向手腕的最后一刻向后退缩了，我忽然意识到我刚才也许正在幻想一种近乎狂热的痛苦，可这并没有发生，就如同我没有真的用玻璃碎片划开手腕。</p>
<p>然后一道裂纹在血的晕染下逐渐浮现，像是一只暗红的眼睛。一股温热的血像水一样流了出来。</p>
<h3><span id="六">六</span></h3>
<p>我的第一反应是，手腕很疼，很疼。但这疼不足以让我感到后悔。我想起来小学科学课的实验，将两面镜子对放在一起，它们便会无限叠加下去，放在镜子前的东西——也许是一块橡皮——就会被困进无尽的牢笼里，连同它的无数个分身一起，避无可避，逃无可逃。</p>
<p>血还在往外流，在这不亮的早上像是黑色的。</p>
<p>我艰难爬起身，扫落书架上的奖状，看向后面藏着的书——其中有很多还是全新未开封的。我把手腕尽力侧过去，怕血流到书上。我感到一阵头晕，摔倒在地上。但我还是强撑着意识爬起来，地上全是脏血和废纸。我忽然想看看太阳。</p>
<p>扶着墙，一点一点地，我向外挪着步子。走出房门，转一个弯，来到客厅。阳光刚刚好洒进来，照在空气中的上升的尘埃里。“原来现在正是盛夏”，我想。</p>
<p>我向着窗户跑去，才跑了两步就摔倒了。我抬起头向窗外看去。</p>
<p>天空是淡蓝淡蓝的颜色，太阳从高楼后面露出一个角来，小区里的树和花全被阳光照亮了。我看见天上飘着几丝细云，小区里的人工河里刚刚放上了水。不远处有位母亲正推着一个淡黄色的婴儿车。</p>
<p>我用完好的那只手撑着地面想要站起来，可我忽然眼前一黑……等我恢复了意识，我正坐倒在地上，眼前是我一路爬来留下的血迹，将地板染成一条红黑色的河。</p>
<p>地上好冷。</p>
<p>我正要闭上眼睛的时候，却听见了有人敲门的声音。</p>
<h3><span id="七">七</span></h3>
<p>我拼命抵抗着睡意，是谁会在此刻敲我的门呢？</p>
<p>老板、邻居，他们一个都不会来的。物业和收费的人绝不会这个时间点来。来的人一定是那个女孩。</p>
<p>对，是那个女孩。是她把我从地铁上叫醒的，当时我还在沉睡，全然不知道自己要坐过站了。当时我还没反应过来，连句谢谢都没说，她就走开了。她长什么样子来着？我突然觉得自己好可悲啊，临死之前，连一个女孩的样子都想不起来。</p>
<p>不，我要知道她长什么样子。我想要知道她叫什么，喜欢些什么，会不会也喜欢康定斯基的那幅画。我想要和她相爱，和她白头偕老，和她一起在公园里坐着，看新开的小花，新来的小孩子。</p>
<p>我撑着地，想要站起来，但我的手已经虚弱地支撑不起我的身体了。我不甘心，所以我将那支还在流着血的手也按在了地上，用力一撑，这次我感到手腕传来刺中心脏的痛了，但我总归是爬起来了。</p>
<p>我站起身来，跌跌撞撞，跌跌撞撞，向着门跑去。我以为我要到达门口了，直到我被我自己的鞋绊倒，一下子又摔在门前。这次我彻底站不起来了。</p>
<p>好吧，我想。我再也无法知道她长什么样子了，我无法得知她的爱好，无法得知她是不是爱着我，无法得知我们之后的爱情会不会一帆风顺，还是吵吵闹闹，还是终于分道扬镳。</p>
<p>好吧，我想。这一切终于要结束了。</p>
<p>可此时闹钟突然响起来了，我听着那刺耳的声在我兜里响起。我掏出手机，将它狠狠摔到墙上，它于是终于彻底不再作声了。而此时敲门声又响起来了，比第一次更清楚，更清脆，更加的近在咫尺。</p>
<p>我的手在一旁胡乱地摸着，想找点什么扶我起来。手臂在空中挥舞着，最后只抓到了自己的睡衣。我十指狠狠地扣着自己的衣服，用力站了起来。我的血全抹在我的白衣服上，形成一幅扭曲的图腾。</p>
<p>我抬起头，正好对上客厅的阳光。太阳已经从楼外完全地升起来了，一路上的扭曲的血迹被照得金红。</p>
<p>我闭上双眼，想象着自己现在的样子，黑色的头发，黑色的眼睛，站在一片腥红中间，眼前只有太阳在缓缓升起，升起，升到天上去。</p>
<p>那个女孩长什么样子呢？</p>
<p>我睁开双眼，茶几上的水杯折射着光线，柔和的尘埃在光里飘着，洋溢着整个屋子。</p>
<p>那个女孩长什么样子呢？</p>
<p>我想起曾经读过的诗歌，看过的小说，曾经见过的人，经历过的事。我的眼角渗出泪来，但我看不见，也许我的眼角渗出血来。</p>
<p>那个女孩长什么样子呢？</p>
<p>我将手按在门把手上，门外已经听不见敲门的声音了。也许她走了，也许她从没来过。</p>
<p>我突然感到恐惧而不敢开门，或者因为双手无力而按不开门。</p>
<p>最后我抬头看了看窗外，天空是蓝的，上面一无所有，但是飘着云彩。</p>
<p>我的泪落在地上，散在血迹中，在一片深红中点出几丝粉色，像是点在血液中的云彩。</p>
<p>然后我打开了门。</p>
<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.857d4adbadb26a69e5a3a68f005781f7?rik=jQ8XQX9xF%2bRDUQ&amp;pid=ImgRaw&amp;r=0"></p>
<p>（写于2024.04.30）</p>
<p>（2024.05.18修改）</p>
<p>（2025.04.21再改）</p>
<h3><span id="后记">后记</span></h3>
<p>马上高考了，先祝大家和我高考顺利！</p>
<p>《逃》这篇小说企划了很久，又是中途易辙的一篇。原本想写的故事是从学校逃走，其实那个故事扣题会更好一点，最后的割腕也会更自然一点，下面贴一下之前写的片段：</p>
<blockquote>
<p>我好想逃。</p>
<p>我们班的老师正站在讲台上，或者说站在比地面高二十厘米左右的台子上，拿着粉笔在黑板上拉着，头顶是刺白色的灯光。白炽灯下闪着在空中乱旋的粉笔灰。</p>
<p>我坐在人群中，坐在桌子下，双腿稍一移动就要碰到桌子腿——我试过用力地将腿向两边舒展，可这样并不能将桌子下的空间撑的更大一些，而且还要碰到旁边同学挂书的袋子。我的桌子上摆满了一会儿下课之后要复习的资料，它们在左边堆成高高的一摞。又有几张这节课要用的卷子铺在面前，它们占据了桌子上最后一点位置，让整张桌子终于被黑色的字和白色的纸所填满。可是桌面的空间狭小到不能展开一张卷子，甚至卷子的下端要悬在空中一段，在头顶不知道混杂了多少尘埃的白光下，我可以看清它粗糙的边缘。</p>
<p>我的笔袋放在桌子前方，如果我挪动卷子，那么它现在立刻就会被碰掉到地上，里面藏着的刻了几行小字的笔，藏着的留作留念的纸条，藏着的朋友对自己的祝福就会杂着笔袋中混入的橡皮屑，叮当一声散落在地上。全班原本的沉寂变成安静，所有人都盯着我。然后我站起身来，穿过自己的厚重的挂书袋，走到桌子前，蹲下身来收拾自己散落的东西。会有好心的同学来帮我，然后我对他们说声谢谢，站起身来拿着笔袋，再次穿过挂书袋，回到自己的位置上。</p>
<p>我想逃，想现在就冲出教室。但我怕冲出去后同学异样的眼光，怕老师在身后严厉地呵斥，更怕我一听到那呵斥，于是就两腿发软了，爬回教室，用双手在地上撑着走回自己的座位。</p>
<p>终于有一天我决定行动起来，那一天晚上我花了半个小时的时间收拾自己的东西，我清理好了桌面，整理了一大摞卷子，将所有的教科书分门别类地摆放在了角落里。可第二天，当新的卷子发下来，我又手忙脚乱不知道该把它们放在哪里了，因为哪里都是满的。当老师忽然又要从好久好久前讲过的卷子中翻出一张来讲时，我又不知道该从哪里找到它了。而当我晚自习收拾出比头还要高的今晚要完成的作业，下课时却总共做了几页的时候，我还是不愿意把它们收拾起来，而是仍然堆在桌子的角落上，知道某一刻我终于认清自己是没有时间完成它们了。时间日复一日的过去，我原本所整理好的就又归了混乱。</p>
<p>发卷子的时候，我喜欢用两根手指捏住所有卷子，然后从最上面抽出一张，纸张会和手指摩擦出轻微的声响。直到有一天，我的虎口略微向前了一点，纸张仍然发着轻轻的响声，伴随着虎口上刀割的疼痛。</p>
<p>我抬起眼，举起手，看着上面的伤口，那是纸的带刺的边缘在我手上锯开的，像是木匠锯开一根死了的柴火。锯开地方的皮略微舒张，露出下面粉色的肉，看不见血，可能是因为伤口浅了一些。我试着轻轻挤压伤口，然后伤口破开了。顺着那道狭长的口子，一点血渗了出来。我怀疑这图案我在哪里见过，随即意识到我小的时候画人的眼睛就是这么画的：一条长长的向上弯的弧线，再加上一条长长的向下弯的弧线。</p>
<p>这时我突然意识到自己不能再这么细致地观察一个小伤口了，时间宝贵。所以我把卷子传给后面的同学，并在心中对他们略感了一点歉意。然后我低下头看上面的题。做完第一面，当我想要翻页的时候，大拇指略微外展，于是原本可能已经愈合的伤口再次撕裂，我又感受到了那轻微的疼痛了，而且仿佛听到了那轻微的声响。</p>
</blockquote>
<p>原本的故事后面，会转学来一个女孩，会与主角相知相爱，直到他们的爱情被发现，女孩因为反抗而被开除，可这时的男孩却懦弱地什么都不敢做，也什么都做不了。当他在家里想起女孩时，他痛苦地选择了割腕。在他将死之时，他想起了他和女孩之间的点点滴滴，女孩在这时敲响了他的门。</p>
<p>这个故事我也尝试写过，甚至一度接近写完了，但最后还是放弃了。原因有很多，其中一个原因是，我突然开始构思另一种可能的剧情。</p>
<p>原本我想写的故事，是一个神启式的救赎故事。一个近乎天使般的人拯救了一个懦弱的可悲的人。我其实在现实中也许也是这样一个懦弱的可悲的人，什么都做不了，只能一次次反抗又一次次被迫臣服。所以说到底，原本的《逃》只是一个幻想，一个希望。</p>
<p>但后来我越发想，幻想的越多，越来越觉得这种救赎是飘渺的。也许真会有这么一位善良的骄傲的女孩，但绝不会爱上一位懦弱的可悲的男孩。总之，男孩首先要做的，是<strong>自己救赎自己</strong>。</p>
<p>在本文中，“我”有着无法逃脱的宿命（闹钟/时间），有着不堪回首的过去和几乎崩溃的精神（碎镜）。这一切看上去，这种禁锢是无法被打破的，就像文中说的那样，这座囚笼逃无可逃。</p>
<p>一次救赎，一次他人给的救赎，会像是一滴血落进一杯白水里，瞬间绽开奇美的色彩。但等血扩散完了，就还是只会留下一杯红水。同样的平淡，毫无生机。</p>
<p>文中的“我”非常清楚这一点，他认为宿命是无可逃避的，即使一时将它改变，也只不过从一条道路走到另一条道路上。其实他到最后也仍然是这么认为的，其实我现在也仍然是这么认为的。</p>
<p>但，走到另一条路，会意味着更多的希望，会意味着见到从前从未见过的风景。也许人在跳脱当前宿命的时候，也可以尝试选择自己的宿命。</p>
<p>这就是最终的结局的寓意：一次重生，一次新的开始。门外当然不可能是女孩，但总之，男主会被送到医院，会得到救助，会迎来新生。他也许会去找到那个女孩，也许会表明心意，也许会在一起，也许会白头偕老；也许那个女孩从此和他再无关系，他将自己的爱投入生命之中，直到遇到真正的那个，能和他永不离分的人。</p>
<p>总之，比起困在当前的命中，他此时拥有无限的未来。</p>
<hr>
<p>我其实一直想为自己的高考写一篇小说，你可以把它当作我高考前冲锋的号角。</p>
<p>可能很多人都觉得我执念太深，其实我自己也是这么认为的。在经历过种种后，这执念本身甚至加上了许多理性的束缚。我觉得自己一直都是一个追求幸福的人，哪种选择可能走向幸福，我就去走哪条路。但真正选到死路之后，我才发现原来世界没有那么简单，不是真的，只要有理想和爱，就什么都可以做到。</p>
<p>起码，我改变不了别人。我做不到让一个不爱我的人爱我，做不到让不理解我的人理解我，做不到改变顽固不灵的人的想法——或者我自己也是一个顽固不灵的人。我也不可能，不可能像所有童话故事一样，等到救赎自己的精灵，等到一股强大的外力将我现在的所有囚笼击破，等到一位天使将我救赎。</p>
<p>我很喜欢霸王别姬的一个镜头，并且几乎天天引用这个片段：那就是当小豆子和小癞子看京剧名角的表演的时候，小癞子放声大哭：“他们怎么成的角儿啊，挨了多少打啊，我什么时候才能成角儿啊？”</p>
<p>后来小癞子自杀了。师父对小豆子说：“人呐，得自个儿成全自个儿。”</p>
<p>所以其实，也许从来就没有什么天使，没有地铁上叫醒你的人，没有帮你打破闹钟的人，只有你自己，抓着自己的衣服，在血泊里爬起来，向外张望撒进来的阳光，逃离这所囚笼。</p>
<hr>
<p>我有的时候自嘲，说自己每次想要改变的时候，可悲的事情就会一件接着一件纷至沓来，仿佛是命运逼迫我成为行尸走肉一样。</p>
<p>好像总有人在充当命运的刽子手，一刀一刀将我活剐成一具骷髅。</p>
<p>我有的时候甚至以为，救赎是一个标志，是命运终于允许我拥抱幸福的标志。只有有了这种允许，我才能抬起头来生活，将自己从无尽的悲哀中拽起来，看看太阳。</p>
<p>这个标志是什么呢？也许是一次巨大的成功，是时来运转的惊喜，是一个爱着你的人，无微不至体贴你的所有。</p>
<p>但后来我明白了，原来救赎其实是，你坠到沼泽中，全身都被脏泥淹没的时候，好像听见有人在叫你。你突然睁开眼睛，看了看太阳。</p>
<p>原来太阳是那么耀眼，原来周围的叶子也可以反射太阳的光，原来空气中的尘埃都在光影中浮动着，绽开着。</p>
<p>你想看看是谁在喊你，可你无法动弹。</p>
<p>你拼了命向上爬，即使口鼻中全是污泥和脏血，即使四肢被厚重的泥土压到畸形。原来还有人在叫你，原来还有人爱着你，原来这个世界如此美丽。</p>
<p>你用尽自己全部的力气，像是生出了额外的羽翼，你从此不甘心被活埋，被忘记，被裹挟在地下沉睡成百上千年后化成黑水。</p>
<p>你向上爬去，终于会爬出沼泽，会带着一身的伤痕站在地上，四处望着是谁在呼唤你。</p>
<p>至于到底有没有人，至于你愿不愿意相信刚才这里存在过一个人，至于你愿意相信她是谁，这完全取决于你。</p>
]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>谶</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E8%B0%B6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="161a07c6df16a24dd37b37ede2327fb851728a39fbc71b61c508f9e75d0eb963">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e6b9306cd99a79ef4fe2bedca4c3b94085bd082a31af65556655b615893926e8254d6500cf88fd10abc9947172fc4ecd8356f372a107c038b3ad474c257d53639aeaa7e144da2364d3dfcfed0da9e1e81c904df19f6b558d3ac17589cca1cdbb443d1e5ad294fca15e80eaec684125eddcb3bcf948f4cd7ba777d554990cd300f6af1e0da5372dfdac27f7403b45f85d6de418beebeab3df6509e4e9f8d29d834b9e29b7918f3d4b68c3c0e0b9f8abf5f43c63833efe26325752dfb2f2c09a788376d9560167306c15a97a602530a0b2d34d1ab56c91a2e762a1fb0f1d5b98e645b7ee6a74b4aa826002424f54ca7c928ef91d1d5fd39e1e147120e597433c56746d1290fe0412525c30907bc2be8fd3f7c61075c2047082aadc0ba0e005c921c38ed9bb8eabac7c89aa9d278382372c5592a0410d11902b49dd3f00c73ddf66f9b03caab2b3ee3cd7c50e52380efe61928a2a11cb3f30cf0a8d890d044e2f3439046f6e316d7ae777e1fb25026ca050c6d977840aa9887698ad281e0ece890d9cf0896cb15c24d1445d5f7def0fa4d477d33064ece020f5cb7abf8a0f496f2aab78404565e38699030b1df897f0502a63022ac054066e82fb4803a0413f7a0535b67fed111a736e1a4341d964f7935af278477f3a6d101ae31ce8edde85d025dcc6e042e13a3b7791eeb857d3432798467e6ae5bc0cd0ee2a2fe1e6891e768f361b6c566c9e8f17ae14acaba1f4b1bb771a299225e08b3c7bd2178c5680932ed40f822effb6d1237ee46137d38b11d4c8beeb34be95ffce643eb9c754888739359096b26f789a8d7f4bf993909cbf9f9e6c8a8cf2e5219f0b0f90b1a29d8f7f1ab87213f3055a424e73a421b1fef50154d88ed3eaea74fb94329e187d71d5601767c463676bb627540b9c75085bcc60277f48a6ad31d0541b80cc4a18ecb0066e4fbf6211c92942278bd0c116f0ab3a92c8df8379315555397492ef278a2dafe044294b3fe6e9766ed350ef36d1824d7b793b42279065a4d554eac2d30a51c588fc00be4d859ed9adc553461a068165c3c86bfe6a39520b0393b5932549df8570b43a3656a903c2efc84b3b02db38d9b2e6294362a499a1ca6856ec0e0b0c31191e0aa5bf587cb1c2df0f52640010608b9955aa68ada2a4e2226c8b11583e356ff0c19ae486c9e2ee9fbd757d7d696569f5289078f531426ce20f2a26f2dabe7d47857fa28f564fa117ced259fbe9ea2cc312b7355a382e01372cd4b31286f4de5956e59cd78f6a44828de9f0d04aa3543075177773c95f781d1a8be5879b3ef48e49a0282d7461b5da8083351523b083c860b2431c79653af2fa9a3d4d6f41c7288d6d81e4fd283deead6b5fbf8673a01d0deced8c81447bc6025fdfdb704972e0821988a83778b4191f05d418c44c84bd5007c412922d36499d7161055edf482165fb7b50698029769dbebc86c726d585f2d6b01fac987a4e82617cba2de5b75b4ecb04e67fefc14cea916746203b546f6144fde856f0aaa5fd52070d2bffec2e3f70076ecaf29def204bd309fa97b2778af26b6bfc96299c196768c298766636450a1b0e9b47eb594de9f1aca5bd64b5ed71ad10a19e020b0fa3f1e98b086229234f19fda8eae479887e143082e61ead19a8e689547eef4e4f447fdba35fc581240c215964b9216110dd7387e1a02eb90b9b4b5aa889e02de4381be239ff444bde457adb4f06a091300a504ba8168542c6915d81f449323f8c2f014aded4d71eabf6341a81e176c766526b6995d5014df1bc629c51ccd65d5ef82a0ab891bedfe43bd9f47ca33b93cd7e2be82185bcbf0fded86f406677bb67ae082caaa1e8fd4bb2c0cb0718cf72eeaabb97f46b9dda3c292aa618de1ac16d0b641feae8091abd3a3ee500f00ba81c268d00d07c6a11138de035f473a0b196e358456f226794d3d28924e2842f6e927582834c98f9c62ea164a44e7fc16a6d326b55d5177c235bfc383a6c7b11c43035e9cea3ab1ca9c7a4de6621a778965f5f5a77d5f4b58290f48a73b56ce9fe7b1b200f28c4e5cc3f78e6aeb034723cd97650ab3295928f41d4a92f815abddee4b13bb644782c74b7f723d4ae814fb6bf0eee1adc3be1c3d8228627550b7323e1d7546e70b826195d5df68d881b50fe2e17f7cb92e4eb4e09af7454ef17a6b617f29157c4e79adc61a4159f093a634a59519607c30a170516884b2652dc3782f90c5a12a4208801de8f699bdfb1b93a1c02970989a4bca32d48c6e813675ad8edc0595958900620c4e5199cc030b083b732679dabc64de85e961019980ae5a69f6ce5270424154722882fe67f5ae1d4b06b74aa8392bbf4a2c170837aea331a8db1984d6ee0711ba503f7605064f49df5e0bfda77d14063dcbb2e15186e1b84bcd077a1b2ca487c8425aafa62c6b9461b15859c19fcd113372fa936f3d417c9dfdbdc38ee46fc909f53a9f02747bf9edd4aa93948c1a1a2f4d55ce2f7daaef794b281260568a536d144c0ba900062766075ce0abfc22350e1d7665c84cf0105e944d7f249369cf6e5c6e050d2d1460ca1012653c744a4b1a54b47b8e2ce81009cd42f77c92fa680152af5e0bc092435491736abd3f9b5114cc3127ac9c1501fedafef28be6e24ee351bd692c6727897b79058cb0412a2ee701bbb24440fa7ed670956fd7c67aa75a37055ff5332942230b6b74e195b2171396a8b58fffcca501cf8f32210b9f8e38655a65b3eb041d8dbfe5ef2060c3c91b9625127e58167c620ec1ce8f7f7dd62800ce0ad9419f2b2d0fe3fe8905b1efc473a5b790f9b4b6139c1cdb6832f3ae72299cbd787e115efc0ff9badb44801de1e6a22112b6bf8cc715e6feda4d9aa74ade6c64530636a1eafa208a2a833c575e4934158d8ddc7f4ab7b8eec34c76a1f859f5f3e1a51cebb74ffb5e1ac6f2505428560dd3238830b9f40facfe11597cbd1fb876a84c71fffe42b0f804b2f2f4d19b7562119c58b9a2793bb95da4be25ff165d3a8b503e473be443ac4d2e02dea36b400d0f07892587c2a66bddf386098d223279e6ebb3b049b24132db224bc61587591e7ba4398ea30164cd07a8e6db3408c2094415af66ef4313217f5902b68633ad96eb3ff63112deead21ca6b45cd086e1104ec89c94bdb51624ebf5ab8e7b327244f24f0f46f2b62462b8621591d014c3e9bf853bc2a89855b2feb608455a25a6374c0a7e34932cd0c2c11e4326762f342db2bf0eef1642334dae443598e643fb7e034a94facd46d63c577758ab59556994376de601346fdd46964527ed7cbfbb9cbf1fc3c740d84d348bf87bf0eeed6a729a8b3bfb5ec52d870c2f11e057bf6c86686cf11a1eeba76e98526136bba95fa418aa1d2532aba6427999da17e34c46e54b33fe5957bc467db6b2f3e260d52c287e3819d750ad1c5a1e9ce4db6d0611cd4846f9264161fb002c39a9035c341f02a250d7ff3a9d3ef096256387ac7852a58be53dee8f07a63e4ef335e7a00022395f1ff5b1e6545552e4ea54d0ffd0c997d2f7560dbd6e4eeb72d001f37b2c0697a276b75d7a7fbb4c5da86e5628b8773b2a09d9f9abe408ae6fe963b2eed419f501267019df3db20a0919b55f0180ec90556e6a00d0b5b29b22d74bb715f31f3c07ffc2e462c391f8e826a9b6346e7fa141fe22546a26f493fb80da52d6632fbc1df72aaa2135d291f87803b02b99a2ae250a357a9d2955f2abca6af44e98a808ccec858ca2d102ea70be35f84e668c2da6fa0bdbe448e7d5643ac3f54942b33e9d9748ceda5ee9ed097d2af03f12e9d4a5c45f213dc6997ad56d31c8048aebc79f0bb4334e279e3534dcfd2995e0a793dca338a98fabb507f2186d5fae8fb67fefe53bb91ebe4f1d015127d466fc98e1d268bf84b029e0cbb7a0affbfbfb26cfa8b4825a6b9df7ae46a6c93ba135a28331c6486d493af506d9381bb2f2a3ba533c03b3bc75f01cdf4c1855f4d4884d67add257d18128440fc3983cccd2511a0ea24a1c2387c20213d3aae18f1c7eb4ee92e0830f365043cc668094a51c4a05ed7d051ccf50efec168f9a94a9a0006a797035d6629e7fea575af6191ab872688a9beb2d2962977b94ddf2148404e282dde0b9d01782e039d936779d0f94b0bf920fd44fc5805252e5c0a459957257ff2d177bd5dc91d5cbb805a551cff16411916d184af3998c7f184f4464d7062d504fdf24e8d81d52c0fd20a588f6b0fcc1b260debf78313de42509480f5c8c186c995e0abfbb3a9a6296d1d79a56aaf25c0767bb90e41349f359d289fbe49096a46688d15cb559ef189620611138f6afedb7eef91f16f4433915d96a3da43256820f2911bf4b630959ab7e3633a9479b87599d056609741338f006afb0e3a30b1be79e8506d5e23e4db5c6451d5b62e00e3e56452c9c05582776709e49f547e2a0b7195694f59f8e64fa8f987ee98f89202479f7a4c94c27ca8f06f8c19ce1ff5e7ac270fa5a0599f58f39d852f1871f5ce9965e1941ac685bea8e5e3c55a82ccddc93c552cd36087e0b46a9326220685b9b49c221c5fe62e01f2c8605a2051ef041e6ca5591c6331869d0c177db31cd9c347158102ed423c5b9c8c682a18aa199785f03178098371281ac2c98d9bdcc7c30190f286d6631513af2912e380b2277b8413e47ff4ab7931ad8964c08506e552951d8dec853c956b42db642d88bca29ae069ae5284cfc7fca6c826f8ebac5380adc2a859724c5ea43fbcf0a7c77cc65c388304ab10364c28613de9c7697691ab9f07c5f956eb154b96ab72b902f5ed315b885d664ee9dc9309d8a9ad913fc5377fee818480965e04dd5b4e71cc7e0ec90cb25dc9868c86940e4e4af159ad1ecd85767531e81dd52e75d498c3348e3645fcb6903b4516682250b1bf699b7e8dc71fa36b601551e4dc24f8f412ab9f707e32ed0f3da9de662153a128dac5675620e27fac1a3087372ec5e403ffd3be7de0b8169cb93800c5da1e01a59f5b8d360fdc6b180d8a7d67ac203df8323a2b8eed3f6f39f801c5beebb1d3cfab28ba8ad1ebe65528e2497034a5cf2f0e2a437631319b7fa8e0c6eef1ad8a506d34610e0a06db800b21c8390ff2b29d2641315bb55c2a0a6c98f3465f7463b8eb1b159bb0fd9f0694f03a6d5a47b33002f37716d7534c08e6af38aa669d822c6a4ad7b5ec119c01ad149cdfd3eb6c0bf6a422c9264b8ec0d0654cc492c29677be233fbb37f2838606e347174fdf93b151b74f47929722d1abb0fddb256b059d4141b2ee3840e47fe09313a4b20ea3a1ac54c4f68914d067456eb3cfb4db253b4f5552b0fb37dda4a63a52d8a726583f24eddc726b12e098ad1bba19c206b9875e6c412641d554cd178c07c41ed0cc9906985012bca1534eafe742955809165c6dd60cfdb9439463845a1fcad38cbdf381f506c514b62925428238f30bd7718659a2d66fd5ca23461018df6627ca0b6512f7e82d0f6336b5331096a96b918051704da78de224e9836c4c9b1663d5a7cf32bce1243d86971eb21cc65dfa6374e59a9d20b3ee125539716bc01d877d7c4ea8910fb6b7a8f251958789479dce188ea5bb97243e744c86cfc82ee5656a4c9e3fefa051ba078ff014c4c6ac980a3706581c782fcebfbb7c4bacbbe0397b21cc943d0186500ecd361490db4436d7638d43b6ddb5d1dcf560c7385eecb8facc4503df6a99c499a1f55e5ca084f6cc8832958b902c272a2fa952719dc26214ad7dcc72ecce01156af79e4e1d5d277c22c9ba294335a662f3ead256118cf0a967d556970a478580a690b2b6ee4fdffb40a70286221a0d778aab2531e1ac1394d49adb388681bb124389734eca67cd73878354f6bfe149c2c22ac822f5f511bd50ee48cb05f7b5633f21633dc13445b8ccdf787c566d27785a3a388792bc4ea5c0b22801635e831739b0e1d0c52a538e56961026a3c8527bba018d95fca53ffdeed2fa76f528a6d19c60e54fc0ccf02223280c38af53e3552c02b121eba2bccf79886553adc1384d0876631011a77293d2fe3fac3b5b91bfd38d1932966207b4e522f9c61e9457326035db55b2aaed12901be6cc6ebeaaeb26b234531b5a7df3750b36fb9f46e525047609ebf874e04a760ffa91c3a0ede1dfdc1aa2374a8de438e125cb95addf127eba70ee6715b06d862351cc5ae65394e657f702274dbf648a1089f941210439d37d2fe0dc112b077c912626fcc7dc993bfe616960c39efbea5981fbe485f8427cb18a2efc00039488c3602f3fd04630ad80b3e57739159c33d443502d9154dee1f5721b24080fb964cca40255abf12938a20f4491214f71bacaa3bda1a19770c3d6db1264b887ea282aa245fd54779382376130fdbae740ee64f4a418f609dadd4aa79b48d9d6986a999ea07b4f224ff36e3f12bd09fe1fb98e07635c40f4ed1fcca2df6c778a56cc9c16c77f868e7d40cfb5e169ac9761153cda130221d3a069ddb75b9229f0128e5ca82d0d31d6eab21ce746261c05ad56e50e90ccc1ba424979364d7b79083ab08c5d8dde432c0cb13e5b6406db54e2b0e82a51fc18fb79409eb2b99eaebf3ae074927a366a8bc9814b2d7dee6dc0f4d7911813f6cad348f26db2b50da8aac2ddfe988f793ea8d8ce2793e87954386f614656cb62c8cc8bbad502e3a30ed2a0d1e19c2d20ba9f423c8d888b48a90fef84033c3f49be7b8ad7232e067697b12da05a52dea4b58321136e469f16ff252a1d851274fe5756ced24867ad0e69b8c228bc86c7031770cd37687ac3ff200a3dd7a8f21fb44f756480e6efb5b6f5986db59f2cfca18a340beabc0e77d8e2d90827fb9f2075dafa69c681b6be673f7f84e896007f4bcbe8568e023f923b332d55581d9402abbc5717d801f8bcc0af39cc8fd532940f98582bf0bf38db28c808f85759d675e03e4daaa96fd87774c26453d9e54ff5a3f86d299e47beccdde54b85c7b64447442e5cd585d0a985658fdaa1881e8e837069f6777a0e186e4ba3568e439f093ce26afaa17887cd0b3f866ea2fae8d687dad47890fd997bd8572e6b16ef5d3237d8fdfe96e11361ed3944d10f3cef77ec8f94faf4bf1126dda4472117c333f92ea23ae55289250538fab8b5e2e4ea2e613ea73eabb69d1f3bbc861691160e44f1b6add327c48a52a599dce1a4627cf77e0504efdcf191863908fd6a6a9bd148406e470809adf2d07cee9ec01596abc807a58fae0b0b372b024ed3dfec0305071dbb738d3dd8fdd3015138431d0cb71187c438ef2d4b6b20ae808f6c67083e90bf77b05c89181e4a0f17577e8fc506743a7d90203e7cb25683f2c642a39434cb7ac7bdde9a2db7633cdd11782af1ba3d7e31f3ef70a8adbbdc2c383b2b22fbf62bbcdb9f8c02b3035bd4cd84f722be78b85d8e52d9f57c32b33ea3c4bb1da0aa42717ecc2ad4db4b060ccd0c41af96a65b5530db49a39c03e3fc282fb9d81613e77dd60aa490fd5376db64ca8961c7e94ef71f6cb1691f1f161ee0f05f3aa2d6136ed8e39d7abbf423b0d36c5b750e78ea87c253e629ec59b5e0d0956a300287c38d8fdca86ae05953a715d6efcae6daac0a746b803c853b035c75e20eda93897372f1bc40ca24f3ce7a9931beb4cfff98d372bcc4b797130867126defdb37310607b827619a5ab4b96826fb5de5eae6813a100ce491952045be2e00f7addf70e380de1a2c013f5980af3d8f8430b5aecf6a8840ce5b4f965865b82681cfd9405a6e8b330f7566c3f281b1ff14cefcdb7ac30c8dff593e0c60f12d94420905699c4fc265bfc785fcbb3bbaaea802fd30436ba3d08d1846f199bd5e427da5185ff4e466a368569dfdd26bf9698b27fd453e15294fc39f507dcbdbee754e47ef82b0dfa92d4b44abd19ce13116b743878f3d68c0affba8652ab498a150d6c390f0d46f4d805d3e466b0f55ab285eb818658806c9b19ba5571bffa79abd14cb10cb2623796a9b31478897f91068ab54da365a36e3f940ba027d09899c2d39ece534590eac2859ecd0bb5f5a88bb5879b2953b939108cc26baae88fc6338b238b60e027a2c843d5ad220ac9c728ebabec45681a4d7d415101b6dd709bb1a14a71e2777adb5457619e9500fd09c805de57987a6c808e966140085e0b8473c7e73b05e33d9c17df75d17ddc821c6003d0e2904c780e5b8be740a420086d24f0200c36cdf3a83676f60d4f4e3ebcaa679617374a1defe9e3d1f08bc5d91abe0d2f89c0330f7301eb299edcf06cd60c10cd9292c68900e8372ba18779b11d86a16ab6d3dd3c72fa322bc2e3ca23811d77edace07e81b1b5fb11b562dbc8ae53424c5dc24b816cf9d7984379e434b73f2508ab794d75460b6a54c6e218fc0d441325910dda4f2781377d7e86f2c8ea85d4a443be5975f736654044a0b974d9c7c406d955e32124bcef8f83662e4996bc851b018336e24afdc6a0554de0b3ed8508e027cb02f635cafa9b21aafb0fb48baa8b6e7f283f27200bbe3e17533d19665a0ed47a6a040bc5419e24cabf0049d4a721352d71a018551b8271c601594b8602ebbe4992b23716e6381100b9f6da2d050a28e57fbc2a157094b7ecad9e7349c9102fe1c160845ff0583981bae60d5fc3f100c8592c84c0a76bc1c1ad4f8f86e0718be511fb9b5b02074aa4a64272b1c3003a0777a2ffe2942f07354bc907ae87037032376fbf729504a652e0f4ec454fb60852e25317c09871ecca758db1431db0d13a15dd3dab88bf3f5e16f66738c6d7a342787127ee7d146bbb4180a7ea75d03277102d8f129790bc235e4ab218687e1280b39baba9b414a631371874f00edb518c1d2694655f4650fcfb725a29f1d1231e148cce3d0839b539cc72939f3d1a0760ef32e5baad4a3d2bf90593b0518fccfc49d8d422c4fe8b14b68de159b9185798ade0a2b258d2e91f25145743eb209fba4411485f70a537647b3dd6471c59fc0c98a6b0d91651b552d7d82c5e6d9df52cef9826fd667b7910d4810adc70a37b971245584246a9cab9316306ab3eacde42764e4d46cb3b503095597346bb0d29958eb8ba271186d932a9d7c26aa716d81ab340cfeb95e35555252dd5a32a5179e5602d1497c70b0920a6b7e55b8d196e15630e523b3c1a46e4ec60d34c542d12ac05cff03353c27d8bbddeb5b4d07f4fcb541f91ecb421684943750579b13c48705d3af84d2f04dcb01847c5a8cacfc839fb458048af21d915ba13d103dd925c00f72216a6abf9775470785d999184252d476242322be71f49a6274d1749a5bda3df1ae621db438aca6f150ddf73e13fac0cc7ea6898f5943e9e941389690e11b361d6fec2c1dbe12776b0ef783647b837821ceccebc460a7693e6547d607f9dfa11cce2fbd2dd057248997d3a119d54e9b797a6152b866c608763e8e880ccd4daaf5ef8f70c0be1f32467e8928460561606e62b4b390c3bfdeaad62cbf4bc0b93eee9bb6b0ebe2907aaffb989f583188596337f0a791a72ac46ee4e243e63fb23b66e914b227b98870e710806fb1d5aa14b11fa96c93d295ced1c2180ae837e51bcc59e7ec1b713f78f94a741132753b14ad30e0349cc48db4e6363148423d74ea15422e3e7d2856a0308ac1e11180d250c1597dde2f94a5cb4b4742737c18395251f6df8893cef4cf4250dbeb5f885a4a88c5087be061cb4091c3745a2c5e0e7391865315beea5892345c880940f1d695cd8ec199793d1d26fe82dae953d25cd9a7148f78ec0c16361d72bf652d64c86eea3c44f402fffd4b1552c0d995b97e4d466a3f574d51f23c5b40cdf8b166377009080c392911ec03ba8ae3acad8ab08fd1306627d3f1d02591255c89c30c48fbdf6c463ea7b433ae664d28ad511859543fa79878aab95c06bc04a9aa23da09247c932a5841c24322199d50f7a1f0581cf99bda11b05cbb4aab6a2367609271148ff21f3277921048cbd0f24d0c069ce4dbcb8c222020b4c24e63ffe9f1dda76a240901f0cf48528fb7398a0a798f07704583f540ea3220c3932542718549b79be5d8cf364630c94abd3212888bae505db8d089a49cdf499889203efdbd69c74e90a35ac2eeec91ddbe261f6854d9fcb0e995f6bf5dc1dbd1d071524f5e6603000d836d7c61cf013e9776fc6acb86dfeac663764a3bd6bb10ed534c9e5e60b78f1d9ff0c75ff85a66073b1c1f170489d32d339f6bf02657760ae38ae87cfacb82bdb9ceeee4c30ac964ebb1e309a779a969e8de0647c0674040aa25b2511dab23e3290efc58630b2dfb27e42845718bcc77737de4f6b8fc429161cfb31d6d5fe0723e863be15ad9c0f44c3bc6ba720c1f4d16ab76b4165de1cb740fcfb362f24adba90b6c9ddd72bd9abd423914899af61bc3bef1b1713882edd3f60ed1a4c4c1fc06be6ec00cb2be4ff6387aba2a0df1f5f299e4eb38842b7affa339a5f34879615acc753b937e6eaf1def7a9c256c87ab8cc1481c7b3f1b4ac1169c9887b518c289cf0319e7a2a766d073c2361c865a49017e97e21bf1c0552e9c468110b257ca15137631d4e56b5ecd4984426a1f349743ccfe90a12cee75937758906510a5b77ae672daf0ed2951d66f4afd23d400a67362de378d19afa5eb7a857d79f7b6025b1ef63e6115ca8702c1994da7d678b48fcbb8744ebb580db8ff56b27f6fb1e5dc968d786926b5f1e530f043ed3fcfa7df8d1e3e147afaed13e1f1c257a1784562a4dcf5c29fa606be480c58656a0a29fa553cddecee1b9793129e1f812af8ed9b5c50b8e56ca1d1940de5bb342f4b4a1048e6c46b9bf55e9c623d164ceee6c98db7d6d1c56ab77bc65853ed2ad2769ac34abdb7f8d066ebd6f34e2cc08d6e89d4308fcbd50eb12ee2c38e887819cd5e623faef136f6a9a17bc1cd4493acb6468b93b3e18dfd8842b2aa9597c9ada603759b316afba51f565f0d6b7e24605a4fd1f5a9b02dc4721bb9013a5e857de4716fc69de33264fb99a13c076334733b23c5d5a58eba47a005097e85d048ccbe4aea402865b2e4e54d36d562058d69d86767337c8fb235de761f45cd594e90d69fdf8cc3365c6fef82bc95ebadc8f7b612efb667d1dde35081780876df41a5933b72939363b5005263d2f67d8f47f8362efb812968114b99cbc612b38e3f58b573d6023915d84b74f0c4d403ffe1f480252c86689771bdb80806bfb585a70f31acb4c3609c4195ebe3648766ba197a2dc6fc1e46dc0adb132ec5c1ee279192bb84d714ec52e15ca145e141b7b0c726e93aef1d2fff8fb9ab72e7cf5d8d7953c61c7f0d34bd04a974f83378762c3607e73e67a76c5731276dfac9b95b45379705fd25ba0eaef0e9483c3f1fa304fbeb8fbbbecb2742e5a95f891bba3f175a73f75b5e2d265bea720cc8efb61d8310e907091c81758d8e816ec1b28d37b0e83b1e894f7d79b3e1922f5afa9659289236e7517954134af75767fb5e1525c3b0f74a6861d95a5bb88fa755e04df2a499b873b98b20ad539410eb35f2cae930982bb3725ae92fe1a787f58921a65e5eb3783133ede729c41fba7f88ce922e363a36daabd14e4231394e41c5ff59daa92cd73c1f70c5ec940dd1be1b685810abdc868231f6f99456b9b6eb87da40ec449440c79f0b1cb108baa12eeb930b26760109185d3b4ef22a17b64d0f68a40257271a797c0346055877bc5f1d67b21196edcd37f8f2fc36cb597cb7d34538556b1bfbb4496ea730e40da4b3316359f6433918c8802c18c34e6310970147b2d84b4ed871847f35da49c4c272402b7e09a1420fa344ae281f1104e0a8389be00df5f74c5ec7a4acef20ea45c1c6b6b79cf95b6bfe580f3bed2037360e863d5caf08180cc0907e6d2cd3d96e6b8f99ae711cf9b8ca5f707e072f0707ae708842df26ce081c7b80241dc0ff4a846acb431457bb06132f64571d6d004da80ca1989a5d102d9e4350da1241bafd87b9cbc8165600b4ee61e56afc94d2c79125a8024bf74d89295e00f243fa5c75147bacb2aa08ca66ef2716fb4031579e6fd5b7eeab5bca12465cdec083d4c776ee899f3048e9573ebdbcf5b259d94c2683bdf09f3b1a1b30991938312cf64077eada9c8307007f3fc0e45bde36fd4c39be22705ba59e976d66666e0197a98464c5f8d8e66de6c6d35e7cd585dc5cf617f4d5d6b5ee8417921cd682e8bc62938c4a8118ac015c2423daf31bd5b6f28fef0033fc22b3f6c3c04ee070b2399dcb3c3911398ce8f5f11458c910438e4ed634ecf4dfedebaa0a12ecf0641cc59ce2cb7af652024502c33d36752268bbb5b841488f920bcd1961ed7a454d0a59003dd01efb4870a8a1698b22df9b09f2732b73461ceda2807ebd7d9767fdd941657ed00e6a531ea88c97be1c2d25a33dc85822c77c5854dd5e245aeaab298816fc144d5b70495833c57365e9e0d55bfe01ebb4f46b672a1e5d7c812064f98fa0fe8760631ab295d288983754e76fe948e4b4a630508b16f1689e157aa352bc1fab06bbc197e98bb7fbe2c14d379394e737a5095961e63ccf7cd2f7f7e46676623d49ebe1ee7705c822ba6b76bcf234b714c0bf4830e2fe505894b876cbf23d83f4c8200f091b3b44a4e94c1b3ff324dd3a6ccd169984567e173477e97cbc6e5ca495295cd36f2dab08960ec00aaf80a051fbd53e2423e0a816b51c5cdb9e59803a6af17a69e2c9fb8b6601bbea27be690bb53abcb92dd79717808fdb74f075458e22716f04b913cc0ba9afb71215194b9a39ea64ef73379f986b8187ac74622fddd0f299008eb9c8811902d7a9fb0637f57b240a521726afa7f8e0464454b92ce047b0b8d21c26a58497ae6a8412f5e30a9452810139180e455ecb83463e4b918497efc86347ff9deafbe4ff962c8c1b3724d62ec21e405c0c7c2d7cc8192306a6c87e794af0207008bfde3a94a0e89609c82bcaa687543e84aca6003576342b2aeb858574535c54b0ccad1e4954320fe7b584a7efd4bc7908bdc7b2b518f7deaea4188e3921071ca7faf081bd3eeb4f0cd74a4ce4cd70c361c92da5a055026d5e708768ed9018b024a4078f63731b26587db879a14ff1f09feee2d36b1a06a39097f25e8ae36b3534d9102de7e9330ea9c6ee5e544d163b8f332a3e8798ec229083c0d41c5a0d0ceeb82c8a1cb9327c0dbd9d96059f952dd867bf400b5d3bc43270ff4f3bf707b5ab000bae6a5554bb8c0b61b3b300b25bee4c1f77c11a88f0ed0027a8268766e77aef3c084027def80db42d27f1a5a6935c571d4caa4ad246a619e42e6201951e0ef00e6b347f65ee97a5d618416bb30ee617c9f1d20a10365be8ba58c4b29a56070c33e5f364c2942186cf70b8f26781ae2d1dd89e221d187027fefc0727bc460226f0c705325a368b76f4f7aee816c94d82ea3719f550ec48744fd168a1929281676d12a1a991093a8ab2cfad442526a2f1cc39883b1d7f3a6938fbdf9eaac8ba9b76f7c13e132f049af7384581fe8a01891d34fb8707484191ca557919e66ab8c7c48e1469b598094c01a9bf9f24816d7a05fd52bcf266a88d6773cc10c451eff91cb22445a46ca298499edbff52afe089404ee0a25483e5e48a5a125850053154db3ae62772e23e7082a5fe4c6f3cb1cb77e9c4022edf8eefc6a7e65380816c730d15c929656ad7c63c6229da451e941e764678b29d7e42cf719f0f31c0f80c7afccaafd0550655180ffdd6eeea0894acc4ac748f637375d6b8cc1babe4e0698b05aa8f3460e78bbee7467947282bbf1ee401316ea92e3180bf8e7e97ced0172a6019444630d153b6786932d50c081e883f26835c45e9a64911e4efe29b41670529020acf495f3dd934de4c038e0ac87085d6e16b611d36c8d54f07278ad13659e2fab44de17d784943bf51b4618f5313b23e6431d00241f42fc42f446ea674cf215d3bc9ca3655282e0da434cef4bf7d4d43f8b0789bca1711aee3874449a0022c7b3c0539984f0b055e2006d68f9cd48b884c87f8a88194c313fa97c5a2f949360048172a9e54a4d7158d93193a8b4104b127e12b77ed04313eaf48b356cbd8f9afa592a12c75b0e4082db3031c7774a7e2770d6d6334d19ab077ed8eda05529ac82e865ec32d7246252b7b610fbe3640c1b965f88ad578ccc83f266020913d07216020f9688ab7827773017d88b67c9c16f742f5a194fb1e12865c345cb43d44d0b470e99d487de9976a8597974e4f8f4f500a1bbaa93d27e350a3a66e140495250d94b2ad5679db48769a90ef8c26cf5bfd3460868a1fde8aaf9a4bf12d9e74fc0bb3df280e11eb87f0ddd1a135548931779375a5faf7086ef61ee54d78fd09c533de87412799d0cdffcd93397b18badf94d520770e6a22543904f023417597f6c952d4897e40da351abad0b4b76bed8460176558a75b121fbd98252f82ec372204e67013fd9654e974d12e19a193113f3206f573bdc94d5756490ffc720000eac787242649e67e7d2718ca8295fa9bcf1e11acfa8a12d2b5c67cbaec052b51915e8aba9a32e4c772492619070cb74d8f7ed910b8853504de00e2ddb3508678b84ca36fbdbbf6fcd1c9bdf2c55425119779c4ccfe50e2dcf6b06386961ab7defcf7d42f9937fb9935d96e9ebdd2a134f554a4e1ae1b3e7292e68612cc2154b617120b2fdabfbf130a96434a14008502d75ca7be8f6127556d88ea7edd3f38814af8325343aba4ecb43a5b80d3041d5ffc7019fd01893d6b50300425c475188d1af1fa50fe4aeadcafc4170dca672610d87d3a0a6f89be432cedcf95eab0016ef9c672af557675f4d1fd9afa1edc965eb9ef30e9ee12602a4305b1d541acb392798c2e711eda7fe015de7be3d37f85763f560cb12617985d82e25bc79930b2454cef8211d9e5ea1ce976be2b8190b0c2938e8f7ad20240750db5355f275f3d9ae9908184fb476c637e6fc1cbec54675a43a59a6223186ce5b449ce39ad6f65875203a3dbe56ae0df259b0312c5af30849b98591579a3759ace491a1deb21fc16f4e9921ffa697902e71a57163833d045ca49a596d2e80ab03ae11e6d9be06b93e1607e504054a526e8f06a8de0085de53d171c62a7ccb60094f5a148179f98ac58b8944fa735ae0cd8132cd4bcb45b80aa44fa6086a5d00cd8f8a4a06495256e032c67d64abb7562cba7a52bf22d5a206429ab995d3b79005481111746c813b4804875610e8f00c8c11a359e4ccb46e91b8aa8e334bcc8bea919eb5ba6bef1b135d0a89078227d992680ade00cfdfa0c806c31c6a383b9fb542565dbecf6118c226c0a2a06bfe85ca410790c86b7002a84f96b468985711ecbc0b147514507d43497e965d9a6f147d7657f8e9d1ce1f69b22ba2ec3cdbe3a3acc73d4f05aec7321a359605046bb179e7b8f8cbcc04d41a481aabf685e94972c58f308f0d009ffe73b7f8e9bdf4d746ecf258cd6a4024abec6e2baa894f66c6b6096a93d8d4c767fcd42113f9a39efe87331f6d3b305c8dbadc5e443b8c46e6b3415a83c9b40d7f4e5b07322e3b00f931adc414f64c044608151bad4857cc74498db0a599336c8ad85ce1c9113e0df03cdbfc16e310fd72824ee421e33889d804a77cc09d4855dec9e22cf41c3227599d1b30d051555f23ab2da5b86c934a818a4599dfdc48e3bb3b6abff6d748054a0387e9b51d7cf9f68f015d22e6aaa34221e94ced8a3a9ab03b5f2e12989b1276449f17ee8334d74eef2f2d056745fa62eb647195eef66c54ab0c85f4e2a7437a15942dd03fc15250ec69d0372ec67dafec09b648877d0e526c6e465f4f81f6aa637db58f1e65d95fd87d1f031934d65591ed6977e46ea9d5a2d5cff3ec37ee995b9523e7ad66a9f04a503589490e23e3eb6e9a9bfaf4dec5331515607126c3582c80a2f849029ae72655708c384d17e0b571404da1c9aae3a2513f7ef4cde28e3262b8d31293753ed47467b05e9edee7de34c3ccfb52963042f02c91b9396fa6b215b4921de00c43592098348f89e46b26b5070a427858d678eedc10bc57396b7597acad6f62edb455e86e1ea4d2a17ff74b44f37ba925e1e75523cb498af5f0f954926b1a0bf027490330a79fe89d6f0d30a2d787b67c216d14f7ffd71c793888c9b911a41485957397f8e69c0d8ade626b739632bc0005363a8c4d7ac1badb37b07b71647d698f8bf1e26c7b5c01e74433d4094aa7aa8b464888b486fe65440f07f30b89319bd14bc4c341641932598eaeba3652511bd20baa821791e8467b6db8ae05947b727d6dbad6b089ad615152f3e59d8e4a41ae513bbbcd5ad279243274a283fe5901875d603ca4652e6d4a6a64f277d718e2cda622ae83f74aacee6b7d675b0771026dff402d24611f59c0b61f12aca45d79ec7f4327a32d0327f693df9e09c72d1950e1b02435d65608f74e39735be7ab381c906705020fc2a49e9a964715e4b26703ddf7c10a07a4bfcb0572cc34adc847b27115cc0c3dc93dc4776bf06941f794a0aa6fd3fd38e03714f986f16fe0804d6d6ca5a45c094f22142aec690ad85cae9a20dd0bda09c8d378226379064c1874c1597dd8cfd458fac4917f56b5699918a3586fde8e118dd9b6b294c385019eefb5bb176d1ef99a08fce028d6fd80a52cbe24ea01ffd5ea4064452dbce14624741e12a471bf18822ac09f97c223a2d977b8db8d991c9b5b8c0c317059715c99cebd00987a41e9842e9c25215b8433e8c2b895dc0b1bc37ad084bdd54be47e42a2797d143d805f5605bb9d838b38f5aa04b34a9ce42c11c36abc478015aaa58fe091894ee227c5be4fcdbc69e21005e750890ab978b21c909639634935a405f00b9e30a6b7135f417e3920d9734737e7a4ec990d5f739f40676fe3e96f628f1b3f720dc2ad38eb831e7df0029228ca94487d4be1aaca9ab45fe2a98942a3a63bc2c74a6edd5658cc4eaedd08b45cc1b35a3993106a84a963283ffb3a7e5e8c219ea7ce073e3623f2ed29d6d8649c6d491cea8559b235431a27c291b9f32b07319ce6895add208509a72054e7844b3a234636b790e1e183e96de3e48ebec708a85ae78c15b69288d057b73fa5bc1dc97b93ee147c9907b8d9d7300c3e08661d2020ebe43cfec269d1c38599a0b7a7316a758bbf08df4cf18664fda4ac7f6989f14891247e0a025b763e7794b3bbc708c0b5987499e46789fde52b7364c6346a23b2fefd9377dd46c3ee0069b89988850fe0eabbc795454f7b2c3b14296304331e301d1ffe4499a8e0b7c2dae2e726ba99cafc82617aa9a7dbc86d0d451c97467e1efc3a5e37a3c5967b99eba041a6f70a1962e8de90e44728d8737b90b37ebbe2120cb1020829829153d9cdf8952aeac5d156c1610145ffa63ca389a4b2ec2137969fb852f97aec639ac48bb2597c8869742f5c3c69fc01dbb427051dc19b0d9dcb9967135c9c1349ec3c9351bd98d4c037606268f613c553f129d68fa584fb5f45de3aed9bce76ed96b8546b672cf80864d8343f4bcae21d502829441a0531d56a36fa02d05ad4ccc757cf307720f0889fd4fd7a68f465ee54cfcbde7b5addc8be18e1ff13b3d2b3a1724676c393916574144f3f5890d45bb60e506a2f6651f345324a525a95b4df98dada8116a583262896007ff3ecb2f40bb412d352ad77545347fd664946e687952f93730f0514f9666249fd8ab4e07096cdc1429dc574d1e32b2647f91a0f6f4fa2126c7a2d1cefe1727c08783b56fd452a2294ae234622e7dcd8cd5ba6c13384c00536c07804579576ce700b9159abbb1de5d7d42b77b30a8d15934eed1dfdcd5ddeb09d1101ed5732f2600bff27cf22952b17f3cde0002a63fe90bab051cd1b1bea3d2bfd10f5de5f543ff02c9d4a76c9bb9fa27724931ef7022712f93db55523c33d5556ff9673adbd0126c9921e520e1366d325607260b5d41a1d34c1ebd6077efca176b741b2ab20578df6328aed9ec9aadd9e2937af7339af43e39de936b3ea9cab893cc1721b28fc3228c5401fadc069decfcea90d728ce7ec8c0a4cb938d2502c7e4ee96b579e198c0aa5e3f80bcfdba55af0856b342697da48a1744c87e69569ce3c052b496910102d8518b5dce9eef2679e98684ad01c1feeb71c389c70a0c6f509227dbecd65886ba5f6c3b7d5ca195749cbdd00e70d9a79191ccc70e975664392c1a1a00ff5111403613570737781c3db902087708c4a52d003b58c3e8655c5c1030a8b5e451853e37794688b0d96aa19745c66c0e132229a18f9cf77292bd90bc5e00313a6e599a3df69275456c9851b9da406e2227f9717fd046764082e5932ab976c2a6479d045dc40312fdaa58d7eb05d6fbcc0e7531b0c6d8cb9a7a47e5591ee30cda6aea35430a0ffd827f544d51b151a2c74552d1e16f89f2ab51f9b4ac7fc07649ee8932b19f10aead32ba94ae8bf7f075f3c1e0c703c03095d8aaf3aaea97718046052e70d120c6d795fee1761fc5a303a4fd8b4275fcd7945763f52ffb885690981ef6862364c4dfcc3ea00dda4c6bb1ea23d210601c30dc3c24ae78e1c14c04060567598289fe6c2c481f0448d24f9179b3f3ca6701c9503ceccd616547eb7af1245b12b54e3ec2d4a1064b30ac0db240d751752e39f77f946e3782c30eecab3d70ea16dc9efb0184633c7f821368edcd3354d8af6e857c40803ba81eb5761fdf0cb5ed180b1be9ac981c7a39e01664ae05c71c72dd88b57491b9a6a163a8f1a709c00c276ef37757c4e4928bced755c45adf6a730195a5de644f231d70d019cffb7d5af68a0c7d1ad2964f3bc0b8397f5dee2bdb43cf06f488583fec5677daa75f75dacbe0ea63618733b552a539856dacaf98b661c8d327a0e89a7d473e963e85b582de7232b4f057dc694b52e03c6be2d436bf55880f79053e0367fc2ee7ad72586aea9402066d636c89a214d88bb0dccb130d5d763075d6e0f0e5a865e149a1b3f74b7087a461c73f7102122a26221b702982f51a506e92c26e0dfde0e7c218bd67102b921b433fe2bc68418b05dc350957455597462b55ae0290c4f222e52932990ed3738d3eb4e1db2edfc61102de7110c42373885f5aafdf5d7760f326c5d50c43dc9acb2bc3da0531540eaa645b54f7a156b8048fd858a4dfc03a3eb8b5954b924174a8803610f4099721fd1eb65c26ca56666cbf127e88e891a7f362abe00f342735eb44cb864d8b874d7bb068f1b91bfcc6b25c96943269fc698a305b18e2fa8db49ae42e05606592ae12a136716bf0382941c0d27db0444587215a46bf7e068fd242f81be35cb1d676dfb7c2df64b932de3759e35371d08630a20d4e8a037994f5d89260e13ef732cc6443bcb4fad5bfb708824743508e85d0577c92bd5e18139cc112f59c40efb81a901956cded24300ae56c769669f72920f217190b7184fdab28afb98633112091ee3d0d6346079c889a6c684c5fbaf842763d46ea50858735757227569dcfccb0b08f3fe60944479cd59c2124f398c85baa119bddda22487f4805023060cfe7c2fc702c3f814dcf2f3f598e5bab6c72ca532f8546a7c96a24d412f4c331a9995c7cc8f3759f65f19221f07710bd8494a229c028247121ff82486d33197efd66283854e52acb74776a6eefd5282b45b4748652f7d5e3cf7c4874d4da618f628c3cc70d83a4848d396e8942c70f3bec1a8761a2482c66fbe9c0e92fbe106e91915c6ca98bdc4fdca21ca2e718b8269827c4a2c229a0327e624675906ac5b9918b232a13bdabbd4099c8805d7711cf38f625c0968c28de5a5cbc8b8df19f928a448f0408b63957c6c10e65a63f1bfb49877cff1223dca2d3084407ff7e28c9a759d5ba843553bfa1fc5fd9db63d35230f567607984bc7e8adcc4e11f8053be4a664f2061f15eefc37f67b1db26147f01f608c384228679e6329306fdea7513a17663c1b57649f8a474e21849dbabe201a21460a77d0b2367b5e5e64fe37830e042fffae5f13aa0dd8e634e4759738a358e966a12c7b1133265fc4a1b0bcc75d2f90a6744a6a63e798f01a15be034b2caa1239465d91401950d7ca13ca5ec1d431d7aef6f404389a42592e590ecf6d7416ec3e55de419508baa2a52f957e95bc283f8c2fb77f4b9e8a4603b874ea700bd09a57c59fcd345b7dab24234d05d66bddd7a601e110f4f8f84b8c03db6363ceb1d57d0260c084429ad55f70f0f25e7ae8f38ae2145aa705993ec7579f349c92cf1acc57a8797d7a56c294a6570680ff4dee756de05e60431c2e8845224493241c98c82a34ea3d4a691809fa21011d3ae8f43bb90710b4e2fd8c084b6b3f4b795dc5746c6a0363abacbbf909a02a93cf31b40408d04273a5bbe5d95916ef42d40e78be32dde9204cca35c103e068acf5b3b85179833f1d9a23f13c4f3e06ca8f22c71cfa7055785786a474d15d79dcc8b9d73b87abebd6ad31d936a9740a724fbf8cf99fd20b43b68c9fc52b19bc522c8db720c1985d9737153b296ebf854e0898d5e562ee5ebcf140956c2f6083c0d27202a891bcb4a1777a4a7f5c4a3856323b663d8c8902a59f19ea1b6ef6fc9df41d65995d260e40d425fc28dd434c9ec7513db2ff92fa8ee91345faa251dae778b2b32f1e74e031e67e01989e6c0581b84116b81ba0821bdf44f1287d9e06fe5bdb1579df8a7943211b8c5b2a9b01f0b93712fa3920652c613b78fbf25a397489fb4f5e57a524408a09df85a18ad3ca794d5ce8e570382f3f2e81daab68d9ed086a63377603dd60990041954c224a59dcf1b3ecebef2d36ca91d9fabc421e70f20a518d96fb490fb4f899a54146336303cf426b8ea9e0f2b495de72f7100c5c9aee38ede745d90195fcd30cdcba17bb71deeae9218eae1982b228a89aeec8ba9a1a355882f14fe1ea83c0895d7780b9956812d4494928068b7e86473dd54af38cc8a728200dd2edfc3dcf3a35aa559284a696243d2fae8416181657879ffd3a33c943b5893dff322bfd60ea2e570b2e2668fb678ef9b2af141fc21f919395f7825b79249f042053f324af8c62937c2ec7240dbecc240511406beb82e1c2fc03040062c3e6a368428bbfd89f3387de2e0dac226bab7f7bc6df8a5f6d74b41dc9a72c6b5830a008319bc008b8d386b0e74180c08f801860db8c5d960cbc088d594eaffa0fdb8e7842389198c0d11be4166c1cadf6c413d5afc780990ed07fa175c113f2b5e4cc22b5a7d0debc4efc576125fb780adb1bce8bf31854c31b8c4cbe73eed7deeb33b020342e45f32284e622ff584be5350686679bf6e5d62602b9d219f765e5a336f9d170aa4646025cd25636d3df6eeb387482d476a37183be329abecd9970a7d1bdf69ae669fc29669c87a9d9003f52e29d81243614169750b957423db1bdadcc6c91eeb5ba8420bc88bee5ec93e0f6330ebe4873fa70cb3a470af2309f08f3601916a28cd7aa4be586ded130a283605f509f744f8c4e3cca07edc06ae79efcf7c2a701d04276dab65e27b8405e130fb44d948ecb2b6ef14941f5d70b9d5d2fbffaa4c5aa98d1cd4bbcb9bf56c2de00b7c0cc95d2fdb7de97ca8be01edf8f816ae956f770dc9b8b20195086c59fd14193bb2a600444493467ad4f1c515587d6a51f3e4af476248ffcba838b002c46bf14803e84fb1d5afb9e505cc685ad5cadc1411218285c06f3cd0648586c9568d7687ba83d4a42687a4f0fd0048805ef48c804503d36da46290348305b2b1480c3a933d0ac74920dbfaae6619f0b9550f5f086915c58e477817e1d4adb05938b5f8656d74812fc0991b10c95739c355f745c85bc7636e9d8f222478128078e484e941f94d84c3cec57c7c64dd948b052ec8bd5b602230f22364f4519509a3a9834b3bf65a3063590e532f087eb041496bc74251a7c4310270232404c41d5582df2692f86ca41776eb2241771acb648d064a9221ab0222e34632859ecc151b8ecbcb0fc22f7f527e0e8ebc947bca3c246d776fb76d4f5ef9649f29589b326ea52c518bb84619845c09e8b2a3064ff3f44d61ed4313fde9bc25f5c59ce05cef2e72245bd6c8239ba10bd363350443200941846f7d7fa52cd81ba6886e3a81502002e7aae5e7994548a51bf4862a9703b016d0113eaeb70746cafc6e91acbdbeed4dadc8b643c5a40db7b975da099ad9daea365a49ac1ef2c4a846ff43f2c811ddbe06a11149ea047dad70e1c0f08e73a44cb2212b24d430babf729378b6637bf6002f5ffb8ed4511dc23e60167c16ba23c513285b235d8fc879289256bce1ab7e49f366842fb79a842cf4c550957a2058b4460bc51fc2995d9ba17e7cb2a7006a6bf0489c38b46dfd3df3379cd285ad5538fb8a6ba70c47d7f46cd3eb5f55fc6b5b6020112436316ec65b4ae70bcc93156fde9ac40169b5b3af8e3a8d036e4bc38b9f465d7f97f72078ea00ed6f3c8bad0818f7d5aea55dd81468fd0c8fdd8bde9a33206e1d6ea81f0e98932a1625001b0c7dc5c8cc4a2fe764bbd64a891e2b073f70dc7e110152978b760d34c2d3a778bd3da71c16801eb3088b8b0face7d96a02702704b4811f16923022b30b2ffac0a9c0e4e6b2ca55c6ede7795f91e5f54d31d7a5142aad2c627170bf4e86b8c814559a160d8898d9f44a746e49f47f067028b95ec22bcb548d47281ef5c22ad01f4c08f1a0fb8705b66cb31d302e9d7be9c7019ece808c9d110486dab9391adcbfafb6e7d4827170d1726ca8e728826499fbb11f2eba670f2302d5dad5544086ccdeca518db2ae18c61af2ea548e70a044e024cd025b1155664028ed6a257defe6bb1aa6906e1ee95d4f5ed4c32125c1812feb1b3f090f6df77ecbf4b861678593b1f884404927bd8799a94bd5564c8a145232c04002ae80529abb231aed5d328b5df78ad9f2ac8e05590fc6bf2247dab741302ddb363518ca705fd41477948dee32bfa4ae20c7e053694252e86c6faef759e38f74933e05080b192a73072bae5667acdfad2a6f6359e1d8136eb0a7e97ce2367117ad1fb096d79e562968447662f2551a67e83f2e5a4cfc47ce3f2d3fd21e7c8f295acfae04fd791596172648c7659faaa4d6245be68e1fc9b5a60173db826c17465ec44c283754fcf0e45b89330697e3c86159223e9e828a48836b41536a267d7c7b3efcdc7848b4f860683d10c640dd93687e66bd8c2e4a173d73d5c9a18f3546192be0461304aea2d59c7e57746b2cf033c4b713f17b20ae303dd156405c158523e89802bf3ab261010715776c357394e326dc7548abe82adbeaa078849e61c6849fb43f6ce8ba53c72d39b8505ef3dfb91f59015bc78055b45466ee23f171a2ce188e80b499652d06b1b2a10e58d61fc6bccba638549c55aeaec4a1a981c8213c8bcb4ed92df9066dea6107ed24794dd3f5c73d55b4d5387689844bb3321e3c1ad47b0901764bf5c0171d6a0f6d70f84949dddfa9fa0d9821bc25ff08c75ca426f8f083a2ac4b825353029f60a594f5a8c905a7ccbbf161b2630884b76849c554c298b1355557692ef753cd3e0df8eba703ce43dc783aec5566eec2d605c2754bbe2b7c2194d8bb04c952aad44b435e1bc831701cd7b991fea2be7e46efc9a776528912ee5e23867af1381323370a2a4ef9004fb2e732f8d0a0387fe8721f94cd3d4740f4e8ad19fc83000ee4a71b6ebf163184a716f769364c4c3134b72c2d03bc48c39d8051ae518a178f64b306cb01148cfca6d53f743e0d1e2a068cecf9cd8882a39997d5dad2bbb04dd761e79fb3b429d9dfa43409697e9dcfd32c1e0c5762fca0edeea6e2b352cc66ad481c4482f1e03188a556d14f00b816784009bb58abf4cb4e7142394ba78161ae1c7c26fab7b657a7d2e5e889cf8cc07e26b642d2ab020c996d5f6107683100a130d0ab459dfaf20f71d554a307d15eb7da7b3f237ebcb38098ee3180caac92b1b5f86ed8b605461f2e1c43b824b4ee88b02589d2551a058556bd89c4b5d9ae369b3108c166a87ba76dd99138cbbcbd3efdc92047323718587fd433430823de10c9f9ee8b88235f42e86399b6bb2169ac372a6ddf0e4ce31f1fca52a3c7f87a026da44f0755414b383fac56975063dd10001bc8ccecc7b489127eaf3b02fe89e8d6cbd0fd116fa8ce56c45156634befc5539708672d298fb9ea93b772c229c5a73f1b5c9def1e92e36336d013eab30f228b285696072e0c32937e093a2dd8b3c5725a2854e599b7763c2d6b02b129fb3cbd7b07ac1e1df90cc6f70a209e27bae7235414d4b76cd3c3469ac88ff06fa666492b9be6b3444efce0d0c49fa315a7dd7b19b0a6e62b1ce4836f24a41b0cb4bb82d9825b44929f5274617c44d292999ebe14c49f3a998335281089bf88f39e53b513360f1a2f848757cd4f077d17962ae6337235389ad2acc5531d32e30610f8924540a8a02e3076408861b81d9528348fb3044648d8f1eeef888f9c0f79f2f37a5aea4dea227181e17dfb901a7e19c9301b023f40ad10c0f074e5c2e7a6bf104a48adcb6f21940928cabe7d967d046e36740b25eb8513f65e86abfd2f1c570714c68f2602f4d507b372031bf1d27bb404c512a5e92640cbdc78738839cf4cd344d48743f3087d32aa34e1e2c4a40a17d0ae717895a8528f832227c78fc3c6f94005d198c1ab8b600bbbd172cebcd71f091994b3a0481fc5db624db23e80c41b10b2d815476b669bf387b209c9b91085d4b4135dcd0b3dd34d0ffe6c35e2b4c189134c9713e2de969bcf7976dd59494737d7eef5d4b7fda776ea9ef4c63473ce1326513aa7fea8ce3af6e20fdf79cfb1468d0e3e96b2273bf2acad9354fc3c6958c0d774e7743e128840a1c9a6eedde5833bc030ba62617cea283dac25465f606392882d8c82ad86119678c591779a373560b17a4bc69f82592b479141e575a42fc30c81bc7daa90a72f62b7041c755a22570e52bf5dff37f518a6f245f6096f28b1e7dfa9c2585232691c14002c34bcaee7ed3db185d00a55a70a9ffaa3042ecf19437f152a5224a802f63d80b4211633f555c8bc5dfdc82a867882805b59572483298b1dfc41dc5ac2fd6c4edb081ec888b9128083f91f17dfe86a4cffda2ab755abaa70f7de67c03b4577817f562e43da70486f60b33c24eb728cbb5b2dc9eb6c28218d3ff54d64ec8996ffe60ab92fc80bcf6b6a79335c395cae3ca517e8a99aa0961819aa61853d51f98af8d7611e0c4d56da39d575433be3f926f9fac46d69b858a3b189d89a0f34f24ca7b11cd42ab431f6cfcf28657dc00a4f2dc9b6eb6db06aab28c0a5f18db9ca4ba4c743394c27db54b365b9921ce5cbd9c1da78c151386a07d7c3f697f3995ab6ffeaebf144ecad6c336f8264383fd7aa0225abd2e65100ff3510b4f100f659f710f9a10a10b45f356e2b986523bfd191be0686539deb29fedebf8780e92797046426871b79f6432fb0c1d445e973ab76d378394870e157f2fba9ed8a18f1957b29f07f768a46daf9a72362bfea903303f99bbad780b390d7ee5bb8c48669305d232300670acc4dd807802a75bf0221ddc34fc0916f152bf66e793c12fe140a7e15d8651049d5b8469fb4494b6e6c94207b41579ce45af39e5a0b3dab61b19dc9b6f0ff581992feb6ef872d1b8fa32a69075c9273971561d5d465f1db4882c02425185b0a5da407c39b74b0379876b94bd2e03cd293fce61eb8a8c6203cf12d115ba9eedf44ca73d5587131054db74a5a0e02be0e6c766d841490f0690616ea51733a0263543204b5310b92c89ef10d1da4b51952757a8c31677910f564f835cd30e2fcb54fe5080da48abf48c8a99ce368125bf7badf1869c0c2f35aed97e80dda3e8309be9507047c9a87822f7eea8fe54ac7bd3aeb4c77c910c9c7452ce9ee511f6a545a3274fba473d943746cd82ba50eb9772cbd15a8ebb4c81878968dba6c2d15ab97b45ca4ec603406ba64940d68b9c89867f321af87e5a4681217105d2d4a2f24443a1a34d03176420e77a1acb1b42c85f95d5065c542bcce9916c3535f46ade21dd33d1a08aea4be56c9e4b6c1cd6b87e6de9661fe2a727727baba259d02d48102d2928b328438f3a42cb6279978c3447814697f396d472c4739d83e37fdaf9ded37e3156c5908bf4f79100139cf54ac02112b3744b46c0ace2b9ce15d5992407f3e9627a42a940e27af3881553e1f73045f2015497bee2c2340b0db264f720d27cf5424b4e2707fad0be65199ce31c2ac1e2537db38e45107d53948ae0595b650e4d47a7abe9be693dd237cea995022417c3a6611b05c1dd23b86355a90cfc26ca3d51528c7ee852c83fcf95b61922c111d6e23d6ddb2bf8cc9fd1557c4a1d023c562023c77094ff5a8ef7af4a24e8dc7699ae12ca3830f2188559a3c057c9f8ef4891a1003a515fa4e2da3083c3fb9b71ebb302dc0d2e0b9f6f769695e460907d3b8b9a746213e03ca5b52a05422673d2f72db250cf85f6149bfb7693c48dc02127068d4a0aa12835f18079fb084b2fbcdadfb95a4dc49813bed689303c1ca87d13ff46dc9467bf71b89801125f5c36be42244eb5f2da2d3a326ef78fe697a530f0db39f6f44ae60304729de8e8a956e27f93c393842bac780385a8c4f9e3e5a6e16d3e1f3b92be5de6cbb1833adef8aba687d9cb9471a3af623170aadae10adf9dfd7027ad8121916a075c5022bb72ad472dea57c3f4a43d53f9e93a49772ae2eb6a7f581280b47d594eacdd3136b5743f6675c66a4d6e9f9842fb416a45c745e9234d019bf09959a14b2643f1c3599da691589e5b49c0905b6fd4b7d1ca77e94ffc191d9a80b36a08a05c300f9e4eebef6341b446c83673696bd2d1603e1e27654496c8a76a198e74583de72742365ac28384c7847d86edb6479cb9b7a28f603911ca49d9fedce970f20020ace95614194201ba0d2cb3c859848ec779e8a4d9126353ace3eaa14b5d1909c1b626a8d511fdaf6baf6145f39ed2b9f54263c8c67a5087c199ed040488b894f3530d6a3977a762cfb184cfe8ede91daced4eaff2bd15db61cc5f5ef68423a6f46ad389f902aac8f06fcab91870dbec8fda66037ab4b2343f1df7b5d5cfb84db200be53903dcfc62c5c3df905f5b601568a971e9fd6799fb19351a1aabeb47f98aebab7c86233919c50faa0128d64840bf826452f40a5548d0407261883bf21f92d7193930b7cd7cd422bd5ed3adbc9fbc7c58bcd07881533985708c47056bc1d7b848af376c8a3ac855937642b0a456e0f6a1e3c2d7e5496d5e0ac8979d46c747340f6fb2528d3ba24349fe5851a984eaca0bb4ffbedd2e5df356e625095d8d935c4fb38eadf80695ceef05af97e77528b4fe41b579227121aac021bcdd2a0eab44f991934deb8828007a08e9e89101ab4c179e49f5d0e13bc2a6b1cb8630afe35c3f47014c2acd8e198577288df0a2b33a6dbd0fb6aef927cacee81126e1b12777f22275fbce8324ac1b0f9cbb2095e38ac0cd3363fd789ce12babd7c7e51bf0f6e5093c1c37c869ca66ec170b29d8f7be9e1229939804815a261b848d4410518f05784d09ff8ea13f43e13acc295b576010fed88ee6cf5cb11583251d4240b4534d6b67c57d6733bd40dffa9b95bf1c6ef521726f4875103bb102bc7da7582d9fc773cde287417a72cf435d5cdd86d4def383ba6248bebf4ca1ec3a4bcf32c8b5bad84967a688101bb416ea1a06d00fe03b46ada3e04a00748742d86e8f1495a39980fd162c6cccdf1421563ecf17eb799060b0e3b9aa73ac1275f6626dfb61a37a598fbd9a2787cfe5ad55c5bea7009afa49267828702e83f55869abfe3242280572d51975fe2717f29793d67e58f514a3d173772dd18e3b65125fd8f7746848748b8742ba1ec6e50b016fd2d94fdf470de5790579f320a8b9a855bbc253cad471adcc384d8166a3fc6c70f9eb34f03d7a8c26805d2fbd6f971f3b2632b08506aeb46b3647b70110dc1b17b544495fde43dd3ff57804939016c0761d16080064770b71def18da1f846f868d383b289a97cbc4a88daff4a1100805503f851495a96315ef69d4bf330d601fb97273d7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>眼</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E7%9C%BC/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0837302962e8acd8632b072350944908662482707bf03c4f4871c680bee803b4">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7ac088f10226f5125607fe60c002264e53b3b3000ecf4dc6f328f938821c76ad1b9ad76edb99494ce9c972b8d3dbfdb4c22a4656d48551d10d778d560aa273de9d3bba7e12736d2973ea2c4e5a8bd2102a39abe60cf30ea4eadf6e2d581c6e0e258f3aff13bf82f0a532c7566c6c6e1a357483a171e20df6faecb6cf1b2fb194de12605057c767aa72be9f1bbce887cced2fa8e89f7d2e90fbf418c64204ab329e11ca72525424754ef062fa02e096a261492d81af31721ad415b2013cfcb149857de905652f8b617a99781836728986a128a9a5675f230976341ffc85612556b9bc362e8cb7434c7d56a901a40d1fb6c27d8fb17e384f2971aff1ec2f10f8ac6d2e35c67f48d987af36277a5b81ad2f334f2e091b5cce89fd93e33403948c078e9029fa5449a0b151b1f77ba3496b3898bcad8dacdbea11452fb8528dfa64ee68c1ab5fd1fb12c794793d76afe8fc7131eb3e9fa92e4294100efc527f00ffb679cfb8354e6779b55cdfa346bc25eaf417bda5e92e46467d033f988d0ba09749e82de4fb53243c814008d951d8d3724bc00571aaa916aa0de7320e577196f77fd25eadacc2bd6f780c25548473328fecae40dbc4a99878b2c7e4030ad6eeb1ff530f05b3f73990ff2580e0474d7bcdf0baf08c7dd89bc7d89cdc139ab8a984f5272f647b0ab8643a41f21db3114c746177093925301310ac174d3245245a24eef19f8eaef46899ffdfe6aab7342fa9ec6bb162a31218a2ef6979fe609a15da68ad063f125b3be2269e153d94f8f5a12167ef2ef73bf19b8dc6598fe9b263d9af44f8c4a9eb6d1638dd058b20e715cc42aa2536e9553c4477ad6d74a66a17f7ebe633af044e502f5f16d18de4ea7fabb4f27c18eb48352b0f8201637b57873c3f3cd79ae6076c52fa9b7ba8f7babca7c02bb7b29d6a7084be8802e3444f917679509c848ef99f92c59af042ec0e78ecd043c5db75afb471c2bc4fb1b21fc939baa8b4cdd66a1abe25b4f8d44e09197e786f8350effba4cc31f032fa1180d475d3beb980552fc4840eb4f0135c4f3735a5171b4b21b91f6a282702e07f5c501731ee8c243064b33f4ab2e784260cabd36e476d3d8142bd173a2821823770fea8850ad8aac49894131a89c83535b75bdc333ad93a7beea438b9a1518699ad24da4256effc45b171f3eca7e93aabc4f87bc74d7676558b645a9b4c8959f2ab32c0b1819a6b974829d6dd239231cd5bdc5368f9ce9302061e7f7c91843e265987cee1db14414ea42dc28ab077dad7d09048cfe8e3822a8f3c0cafdf1fffebc7d55fb4fdc8ac777be9a225f61031b232cff4ef889cbbfebbe1a1446c2f47c0b0168019e9cb4ba4168f19ef3dfb18b721ef6be3183bf612ea8acb9e9ad9786b8b5e5ddec344ffa50f8a007e88be052e728ee0167578b006fc846fb4d5efb2877ca9af0aa77ffc05286e1d01f439d87b5dae44991971c5fd70183629ce727129d7a248113422051088dfdc60c7ed6267df0aeb44e20d5dd9f7a26237dcf4b34dd22b74a9542985f34a6ca64dcf0cae6db5b7cb607e439241710f67fa5f3badcd749620784760867aeea5a3defa1de5b2df0d4a016c1f8352d0b2b766167d5eb9d2a51985fd609e702cea25d71499fc847b11b9720395c4af1ba013ba8edf71d4813b403ad4a224c6032ee1049755ea137c4aec54d10dee29aca9d4a9b6db3cfef2153ffa961ee6bac6783ee378c96227196abc1a4ceb7e5176dae474e0a0938d55cfebdac51cff138ef63dbe1bef426ae3d4adf2735332b8beba3c3b0699084e7c2b81d36a257b2eb4cb6c8a29fbdb6bda7b7f3d4c9c28a9db05c62a151605a8994c0477afe13a4bfd8f971211a17e4890559415f94ed1f50864ecf7ed16b81e9dff792f9a98426eb9de96ea33486b1f7bac48ebbc50ddbca0ea252ebdda6455a89bab952c4f4e3fec1d1bf19edacfa066339d06d7bdf9b6b87b70f45aef9d08dca724ee68751e96c44d0dc1330af84a264f4854bad33344c123194579c142e30e5d9503638ebeab80f5892fa0a189aee3309083fc5d1979c54481a0a4c8de4541ccdaa777058099f6e3b5d4537f62293941469031493dc5ec3e30d093502005bf1182a3d91b3baf896df0b52d0cc4b8569d2ffd94983394ae9ae13ee9e6df11e7339cee82e11a5f19ff2ba286222b917bc5be87db12f32827e394dcd4a74a6c5e0e15de3cc781094040f601da73018e7c7e98193b2e79a3ec76034cbe722df390e29a9e60157cbe20a4673953d9a45026334128fc99d69ff53ecdbd5ab2419030e7522a8d7067691e8c4ee7a662b16734dfeffc50682c97d52f064591a6a0c08e997fac2b2cac04f30cbdcc63eb6cc36458bef11e465cec90b0cc1a07474c1d7a19c77a1f9671d8a612ef6f77aba455b74bb8b6f5fb7d56f7648e0117356f471d6d727f4abd8ba414813536553aa8454ab75d87b5f38bbebe7da2df40f4ce99417dd7235c212da860a7d3359c9859e7297d9b94e82e1bef2631f5c6f8b9de4813657d76ae57a9aacf99fa4d6dd787e7c1ed49289fef242418326680e78e43f665a1ecd850a94183ac56cdbe24d19d91115c9ea8545d2bb598520f10c1e6fc82eaec568c10f3dd65516ef7a990620989ed109eaa4231cf021c0c8d64208122a50d0d39c645cce4d52778992ff9a9b5c786e3cb4628c589f63aaa216f085f404063ea62842b6805e8e28d41d5eb39b0063b3455d704aedad40c5fe5834013f1941a9b843bac70ad4c66469aa77d4a359fb3d9b963d288183f0457f5dbce5f5ac7d7f37416cb5abd88f35e9164a2d5f668d94c6807611c9529f289853e46c56c63d94b58b046f0cebd6f32e60ee9f610c7c3cb5099c05843324630e0a68669bc850f9ce57f891463fa9c8bd4e26fb5abaacdc02c3987f680287d9fe57f2ab194fa3f14a4b73c5c5e2a74c8042d73187ecdca10250c9d8d3054e7da024ae03ddb1b04857b1018c3898b8675ed50c9dd67dbcccfce1e4f6cb397a79a0f10dddaa8e4cd03b7e135c4f30ec44a50571f3e756ebe1af1d9b166f902d6ae65d03e0d13206b382fd8e350407dad371ae03e5ebd04ece58885d369366fa0e91753b01e4e09dda5cb73bfe7758b709475ea851da79e873614b09e212e05170a5d5b42924163742002a1c6093c953d9a753537f17bf837e7adca496bc4bf8f488387565fd56bd50c21f71aae6e2e121ac4a6578b35e98df6884272ae451ce0c3ee8166ac523da12af4415c2bc4f341b1c610cd4563ea75dd266a3be789259270753f4d2ac9f447b9c00ea3da18c9c9859e5d144a0435a07b368cd4fe7bd0c511238988d18f9e982b3cacd7edc3ce1f40292c90ce78e6aad972d6e23ba9576f702dc4c7ea5c3fbbc7ef545bc86b9f57649e72c09b83d34d8b03cbf9c38e7932b8682f19d49b5c7927137fc9981f3223e4d3c46921fa3b2ea3013db82711d741e63d1e8c0a0cefff0deffdc0fb97442af4db48137a89a7dd5153b0f99474d96c07aab0e0eb902b564816c633c2728a46a49f81f2127c9344384e43457d087b690a785fd0b4e6f98bad1dc55678cc42e52240adbdad92e67f20e90ef89147accecde7305fab41a7c4e2b77e48686aea16ca13104aa711f6f52eeec63d9dd717244281f0a43ea4ac4cadd59b5c4c888c8e8c15c62b19109eb28e9da3ee9a00a82aa19e9dccff35d31de6105929199d119111c3b5d38afeaf5252e364b473f57e47ab90012d22de6af88f1d730bc44a02d401321239810a7d79f248a856566265704b25e45c838567ceeef60d69ba8b50f8d37e8868aad8d40882247b8ea2724e8d3e1c2f08f000b2bd7ce62001db4c299dad1dfc0445e6c36ae1f69df266ea93d8aaa63ee19aafce5197bb5d0b1ac1271a9a47c00304c455f78344c822dcd7416fad1450c95e0249b26c548ea0017a9789eb00919ef648cd20caf726ce31c3ef6d0c7179da94f821df05b480bee5d3a17db4ba1c026844583de933d972868f00e437b996c8727cbd9a311e09cac63e4dfcd928a0686c0a4a9072426a1f83fd6aab184fb1b391a6f9d7fc646f6965e94b563c85ea1316fcdcc578d4dcd3092331fa9427825c2642bf054bdf4b1a5211233e02dc337877fd95df2d106cd03fb5d7038c15044fe98335f132d10f5bff3ea90ef759063608a36cbd1f37309634fc7fa7c6a9f46999d58216b0c943ce496151443efb2932ca6fe98f670a19ae1ef914ca981ebcf5c2de95ff3d6c447c6c0d887f0e9f6ec7ab55aeb84bce339d593cedd23862eb313bd74aa3e040a35d99492e1c150e88e3ef36e60c6f3f870663013fd9822b4c389bd41f85e843412f5630948531589241d660221179f50359d67fc8bf988a8950a9e641b23537b690fb5b220d60f685e219edd946053185679bfef5d162a850413cda13ec3f37aaf21c74183b4c67ae195c31be16d171a000a415b9b2b983be960737c3dfad41e944e9dac9bae3666440f96af11e2a657f2ae57bc0ba437964090741e84c5dbc763bea57ae5352d05a5e62cdb4aab95ee8a5f8f1b24269ba45708ea4c2ca85f800bed9e59fdad6add71f860d7fc950936ceb634649d2912af07effaffa4ea9deeb943f079593f87086832086b8785a14c21bfcc33f054e2acaa2c2eacce9fa5ae59d6803c1294b7ac0ff05ba328a7567bfaca9ffc99fb8cd8edd1a3f2afe165e0d4428b35f26647e53e7db8286f2c4c2868daed3672637fe6f5481a335de781159b7af5a948de0720b00cfe134cb2fbf7e648dcb9ca7627898191943159dddc41fb8b000b366d1bd001c9f03b2e133c2a57f9d8e10610923852f64a11207efd45d811457cf7d74fdf2ef8073728c1dbe771e19968da448451881ac994450414f3c5c462088358b7d68f968a0124ecfcce128cb53b2d733596945c68115ab91ea3b8ea1ac7e9494129a96d106acc93527baf8df66da5e3bafe302e3aa161c1901982ff4d9bb50c4618273ee323c9f6c170e9806193b345337dda1bf3cd3aa743241ee631e7d0805bd433903eee5ce85290a4b253ebcfc44149c6b75af96189513ef5b7ff19f482cc1da117c1daf65953c698127296e3088168d5f5ca69c8741de9d967ea21a92d7a948b1efe7537e92e8c25f569610cde88d82dbfa4a1dc508159e4cea9360b7b46d14c0f02ec1d262cc40f355df1e46717c79b45cd263709b682e68200106d77c374d59865e1b0c784759893d2ea8382ea8e7f71a69b0182f2ed29d93da6789ae0002711245feace8e365c8685a02a94413c6b4414885daba6029503b1732f40458c991a73ebd482ec65d3ad9f7243e2de5e58ca645e247b94f7bfdc8cae6509d6013ba16e660bf52f1d5cfb6ce68bfe20f8e49ada119c69c30ea53fdcbdfddc7f0ca8417cb478585a7e2bf6a442e0c0a93265b1e4d6ce60364bf72e7e483431ba3b0b46f2fcefd7b4898e96482b259936c1ba8ea5cd49bd409ca6c7cc1cb7fa4288b296696fd9d07ab496ac100d00294b9343c95f7dbe550a5ab5309b6b8440d0cde108ac68fe0560b415829a13c1674596c17037e0e4b57bc1e9ba59c28d2f3bb55c6bcf7dde1597c1e91598851797110995e73730fa8d9ec46fd5a2a822b66e5089a9bb3cc298a64e13bacbeb8675195ec2a0e4cfa66e8654877bea11e228980186a0b173584afd2f05046e00fa6d3ad2d70dbc0ad383020e7964b63ffd0187fb65a1f820aacd8e6e3f16027aca74cd1563bfa71b0a8b4fbb15b2283209e3e208e55ff09b8db52933060df2e1840af8eaf91d57b9b10f9f4e5542048c5b7028f1f4a5f3108b47ca644e7f9741c7ef644ff1aa276a577c113ce83cb1478f06e2abe719a3b15e6a4101c6f92ada7288402e6e76dd86cbd7e9a2ced38679655f5f280b56970cb98951332bfe01a2830379c4202fac26edd3f9e1ee3e1a26b185135556275818796b80923cb6e94db82e445b403677816a162f3237e69a8b35f696951d1dba7d4b3a4875f250557743f2cfb8c6918d7d6c7e11fa18be4c967e8cda80b87de663adb5b3e72ed7c7c3d6cdc6feba4adaf81c32e6a078db53e37dba50a44a6ce386f15f41424cf314f9358fccd3d5517c3d43ba6462708aa7d4f751aa16c6c85248c6deb8936f7376d91292d9c3f9247aef42d879c214dd4a3580e63e1b8823d8c394923f006169f681cf6f517a7e16234cb0f80f106ba6284840a281b7ff6f4852282cf3557b3292a948656f86cca72aecd8df019fd850a5509a84a58a1ea5b57436c18445b6ad2317341c5a537fbd40b4e1289dc0df5f1a3821f7113cfcea7e1c4936fd0dd1f0011c1ee1f47585c3174f978b1cb97bc17fbd4f9443aadea4772fd27ed9137c7aadb43417ce0e96edcd78028d04030e05867d04d3f643dd54cf76047d29e6b48e2b6b26e7e434e2b303945de1e2539b927fa70e7a749d226ecf0b27b7757e2fa202813438f43b439088e6095d63a514de9051d67576853dddca7322e671296eaee58e2cf9b4aa90028132fac047701a49b7e05e06cfee959b70edee04acf669b84ae5ef55720afb2fbb19f3c801cb4ca8c9b1b209dc6b880b19bdfaf5365a385c9fdcc31571338709499721b70917f5d5bf82c056749792c9ff2f703f633de0c69ac35242244406dfea2e83f233e44d270a4c5ce8efade90d72708e5e435ce604e04bc17e5dda8a66b75677ac90e21d7b56439bb4b943fd9f2970cb9fd50a2446d558abac8c46e38626b29e32d6743ddef766db250bd80a954917efe22222bc4beffc378b6f7d515ef67986f573f7b2a75b4f7d172ad2422caed4a870e6f1040248d7c61f3486143c76d398a5fe4d304b888ac5ecc35d69447ac85a8a15381d05d9decd13293a4e261cf7a2be9e92ae9678f19acf28ea3783fdad8c90784167ac929924b067bad0bafff97f90f8f97c8cfcdd2f9d06566b4a20adbea3f29f3e70bc59087ae69957d5c693a0288c671cf3ad2c6370ba836e9748b9971aa14cf806e0a2dafa31738008dbf8f0ef28ffbaebafcdeed5e122bd5379bd04092b1656c464ebf4d366da3fe2e3b684d33c7e6011dae867c81f7ccda897d2ccefb0e9964f302e404177bb393a6f78e1a14c8096166a401c7448bcc71aed99a916683c0e4616bf71fc5a13fa2ec37e7595d8defc52ea4a9c82fecdbf4dc156b278bedc544a50e852555a732e17c556f58ed9d3813cf5f0280b3e11a701611990061735d73e78f870aee3240407c25a75df6efa3c569607ac5e8073b21cbd8bd6a7c5e4e207b53de97c6f7b41ed38bc2ef059fdf7cb9d6981da54e0b3d66701851ec2693b0968a4549043d7d4748bccd3c30a81c1f67199a244df85cbc78db18bc2c1e845a058d7afb238e432560cb605e3c7df507ef4457c1622edf42becb70743329148bebf2a77086f91b7baae83533f618ce6c64ad4437929f25bee501fd6d57eda2963e75064366032ed370bf68ec50da9375643d788eb3fa8fca826a1f7bceca15ceb19277d8fc67c898fc9ce6ce90d9535ead52ef92a5dd56b157be4d9b5edfe6775f5ee870803b53213246a4e8d9cd5e92374506ba9a01e44aa5037a4d9e97f291dca0d1c798be4f54a0a34953a93942ac513bb8cd1d5d61b615a2b036a0138faea5e9ce5ec3f3dbb7923edcdcabfe711f1cf7864280c2ca7da27c32f36146d868a370a38a42ca34fd17025d23c64badd48764e33ff30767ffce44e0478afac42367ae126a9a5dd1db635dc6ff2b9fdef90d611ca9e1d9a5256eceb4db80d0620da4fb3c174047c9f1afc3551fe7437a74c90b620b44013f484062f52870d02ae6c279f8d0393fed67dc2d3771ca4938d0448bc73ac122d1390f1d0a29f5e763e60e6ac2bb3cb4a464705784154225c94c03f48ef34134f1a8f85a72fa02e2d9d026cfa2edcf4fc86da71b9a4c1769a2b1ea9727b6b44e05b3af8c2c5b7fde74c34ceb4517329a98daa2201a7982bd2ac57dc1455aafd09aedf12ab64c25ef21ddd2d37a1f587d71654098166fe4699d2c854c55bc2e50cb25a922fc8ba40f681c8bde216bbe20bedcda9dc8e7527ef07e4cee505df6204d5310f3ea8e3122f1a454de28779807b876d533c4aa190cdd91e8d40c49a1b387b3f703a44c74572b1fc3ca568ab794f26c50659b215b5b98a9dbe2e63fd78696f7341f4d6a2caa8ac359dd7dab7a3f36d2d19295e45591511ee9829701337475e983fe6f07926f2f3137c9189643b5170513c2b2c3e1c759fa0afa79b66396bd63927854beb37959e97ab1cd6fd5d6d0fce7074bb336b41482320de84316d1645af116a3bb4f011f32f26a1ad55b3424efd984c3581c792fd67557eb6e043535601e65155b34b32261d5f493e8acf9f578b29e9c0a44f2f6f8319ee9b024a535ba92d4013fe0402e908d0c3beb7fe6926e188fd908bcca8136573154dc989c4ab09a40042e7b530603618770905f4591dfb85616eac84ee670acbaf150427f5653373e697f888f96fb1099f3d59744f07d606bea593caac4142ea1ca602d1f4c09483d8431440fa221758c3ee365408404f65ed2cc1fcba9674f533ba1d54b22ac1aa98d9d0c6855707179e78ab11cd75befe17572838afca8333ea5f74d0671f9966c1544bf559b35afce15d716235ae4a68e6b5efcbf9f0a9f3a83879e4c2aed04eed11647d02bff6efb6b36a7737cbd760e0eeb2ce32699f54c8a4b463c6ac3f901b4e679a24f680e6335e2efc4cf0271bc06d6e702cb2857c5dbb6a858c091d7c5a1b34f1ecf613ac5f99a54d8f22153f7ea26b3fbac91266095eae5fe053b5e11f29ca2dbe8ff2e6d8a51bbb14170524691cc7f203ff298d5fa78365bd0967def566e2ab31bfa8e60c710ceec6b2c9c6dda4ab24ee362e4118dfc21b6d651e96720407d4333214761f49110c7dea90efc8f0655e858eb4f79883d40d3d328861b8991da6ec53fd8e690ad483ea1d89680681be3f047015cc8967f4abfd3e5f1cbbe3127074285d29ae294b28daf9b04d30c13f07f43c28954ac0fd468e8a00ce00b87327d0c265522073a5391445289020dff544331919f03fabe21c0b0d9e07fd487a2d7cc6d2c943fbd6761c62e86db6bf2a14d6bd906a4be6cc8d38fead5e8ababbb80b647fda6a401b44603d72e7422c265c1938bbb9be8992f6d28072de300452bb1fd174969b2683fb0e28452f40a4adf5a40c477a1606c7ae11b67b8ddf0173c749869cebcc8ce6998270af0cdbd2d637c69da8b4436796f6b2b4a3cc5c0b8fbbbda2a329141311b00e688856c1c29a00c7247d971e426a48e43f6cf47eb3ee16c24f8a506867adfdba28ee07c583941a27d899c102f3a138756026ebc3a5f7437e8dee8e5e9548115f288f27b41e10a90dd9c524cafc739e1c099b3518f3aa1ec1926c290ac18ca85aefee6d54d118fd0daf634305cfea1177a86fccabcc3649b6ef8691cb0ce61cddfc5ca20d0fd9f76f20223f0edf516114fbc2f86f3e54b4250202b26ba1f2414807a7254a36bd402677016599eab89248194316c8cd302a98bb9d2ab2c40a541b96e84cbd70d45d1bf0397c5203c2b2c97e04d2b21d58342d7983771d529042b02c4bcbf6f0d4f197c7a34f1677654aa3c9b3d10f6865def471d54f248762c85cac0345ee182bd56cd3b68ce5efb8aedcd2fa6d1510f04aa4f02dcdd80a37f39d562b09b94831b9a65e12c9625bb60131869e474c6d409b686814c742d788a021338f2ee107fa7862f358ae9ae0acd48857eb57fd4ae966ab324fecdf3dd323b37b45c045607d77535f7d86df0c8da1759fe221088b004159e87de77172a539dc6bfb7dec3b007ce11d74d80bed5bb1ec8bb637a3b5b10048b9a768d1c0fd1ec831a3ddad0bde4539360b7aeb6d9535ffc51d0ec4607d0d0720a0e35ef08e7f427c1b8de179f7d86548c5218ef00df201e4a7fb1ab365ab14262ce2c76184d959ae9ff4ca5fb1b93fc7b11236c50f0196ebe5c74d882b3915998c50d71071af13d7a6d9870ca274c723be44698dfe6168017b0e47d72202a3ca96fb5d9f7f63a16d649f07a74b18c27d00d16db4449545d5e5a30ab9423465e8a61030aa6c284d4d4af6705925ed560f7fde77c17ae66bc5311ae80f4f1be889238b016e54fa7591792a4c9df763e27b214a0a626f338ea9f8403a90274c3b194bb94a9fdfe1b7cb7b8411cd62a99811481a06a94d86be1503876e2dd8bad6efc0745bd11b89368e4048a2c51b1b386d706346659b0b754b5b4cdf7c8549a6f91d96654a480da3c3966da47059233c1a965a39224a97fbb1cc9ea86f21a861c4b1bc133298892cf3b48edbc5f404a428dc99c3d81b68cb4c945fd5e23a2b9795801f2ea78f9217b37711cbc3f18045073bfa693101f6f4130bd7c8fbe00598d9bda2c15920be12298ad7ac6292fef6a82ae796e686147b8e21fb578c24ab88df6820a7e96e7615904bc4efa4f5f3949220311df47988e93b6720b1fb5bf29a5fc98c5f2f3ad5707c40cabb1ce85da840667408c5400b10a851d218608fc5b4a30a64ad593c31f2d058d89cd11a1d76451de70da86f988fcf0b718ab7b5436a1e751da741b7a9f1274ec53f6020a2e117ba9cbe95d10b6e43800d7d32f93cba422c00aab063761cbbbd567810b5bcdbd116145bd1ef191330f1b5277b12c612ea62a24b742ba856f2871888da64c66f24820b63cee75eae7a5fc86243eb68f493fb3f204d4193b224d2b1ca81f94643c0511895ffe88ee3addee36e96b69d8d91b57624499bf67192d2880c8529f8f2cb46784eb0a605fcbdd575677f6ec43cbcb7e2fcfe96f9d9e8e7a5da48a3be090f89e8b0d5d9ac92280e4b6113a8c150f99f8da1d629c047a10a90a53d68dc8122d851634356f50c0826ed7b022c0861298f45a56b5c1615781295da8ccf1c6fa580dc1559a83b748c70ab6d3ac13be40721232d3ed9f3fd3a06407e5ef419f8ab79ba6c9227480869d3b3273f5668b1e1148a9e41ec0f519ce9f7973c5ed2320fff031f54164e979596fb684c8c224d14fc14206a0c01586754e2edacd3a0f1c932aa647f4d710d9de37d8b294c3fd07c2327cf05c6ae2f948c1e94add4440db1c11767b9d9fce27af1841442619c276c085c601f96ec4a67b2bb6a59f08257e0c4ccdd9560654db4ceb49d27d13a7d78653932b35368ca2b18cc530b2e9491f7f962f827c4e5c541b81b1a16a3f845382a46f6bed76bc1a1ae0fb27a7eed8fd547524ee883ae26c56cc752605f95c4fe8139656c4903d7e556e2c801766af60a22e039e021a8271c8aed10df2cb319a3a968037d9cea98cbfd234f0848a0ac6b3d0583da2b37afcf31e366cc9f449cfb8ccd2385675b5ddeb117552f95e7548be01873829721b78030cc4ab1267e9704e78295580a86a3e29c18e07404e39881dd7373d927295c4fec2afb07b1dc915eae1a16218e7cb00753bc9d2c3b84e343e00910d626c7dbaf576946cbab37806038875d9cc4385b16ce28388bf84a3bf46cd673f0b8d0172a1b24b3df615e25983054bb6571f764e2fbd7068363a4c724dcf1965dcd37fc08779bf97da9c948cd8138e6f254ec05adfdbfd523ae10539cbcb8d7fb1ef1d4679e0d347e1b02c5d8b3cecf2f9693e02cb95ab0873832280799a8c84e6994b3cbc45d6c2e88a11727bb7a0f4df56e9e46b35e7d622f5b100bd14316cfc5dcfe1e7d0e83410bccd3ab87fb53be5ed04267707989718d7f683700326a194777407e9ad96721af34c96b2af6cf14306137c0d380597cb6d3b6fec8cbebe21824614aa7e7ac5c6ec99f4917f25cd7f4885e38b74ad0517a53435070f9e86680672b6c906864fb22a0c8c323277c82f36e48de5ae320a051079f3be06ec60605ca3192274968b6f3b6cc3dc79aac0247d5c2f683b7683d5cf0fc483706412292bb705d2940f05217c1cd90ca23a525a86372e7d6a9e39299c574098024feeaeb84933e8013f4489e6f76827688c79fd836f8f46e3506065c0a48356838dfbed4eb31e6f36bee65bc4ff80150e0c7aa80121f5e852464538919a9ce948d5d653dd202ed0b188842b3335d37bdabcc1f169204a19abeba78f4d66ce59ef8bbbda7e7b775937f2679dbaa7cbd5a4fdc8c167de2b591329c7bb8e46d528364f908d8e0b65a0920d6db6be108cbc14fa5273b31cbf7cf28a11a75cb72cc74a12ed467473934f9f26c61b7c38c0f6a95c68e6d70ff6539836c01930b529024172f16e0e477151af90dce534141e86bb402cb2796269174ed1025465e32854f5ea4e0647ab660bbc363049c7feb2b6aa627882bd7f0426ec260f82d67f8f67c0ab33d95b80fc9e57ec8969e80e0ac42883cae0df5e94601de113fa2736a60955b0f88c1f5638b5622e7513e87bda8ef9a234dfb0145e53456183184913da37bd1faddefe74c75e49d0761d63a49993c68ad44d823690dc74bcdc2520edd355d4038ac85264081320a4a727c5ad45ea8ea9c8cff313fa995406e9c31120e4e87db34466e526f665f8b1a87e5ff6e81227bd7f62713ef86547f3267d5b0a39347938457beea7ee419db218570ef5b2564872a2849b1e032fbb6833be117a960de23457e20c1fffd77b4813e4346b8b1d98732d2fb7c5a5c7368cfb564beb5e49f5fd99f12edf9f33cc89b442f7e21f35c2d7ecae86c9e4fa103a4d9433c71f66789879292ff6d9acb8adfa4ddce6ccd1522cc8175f5d48d054cfd0dd634468b7c24bdacff23e3639b826cd85b925963f15a52e5f17e3f4dff2c79c0b82c84ccd00a04c57f6798021d1460fc532d41f58adbc0cf69fde615761bfa5c3369995a46bc703e8c72da394814875e7706f19eabc34c7bf2fb34cbbbec8112e8dce8e752c0d69673c22c931639264493b4e5b624ebb097aecaf5226afa8b32c58ba8d8f9991a3c893913a15d0c870a0bcd1b12562f8cb7570ee3218172bb4880bfff992cb12ac4d83d2fe75257aa37ca6cac6645292a0a44f9f6d9a8cecbfc343bad5e694a365f71da066712d23e2587c6f585c40574567e1daef1b4d2f239964991a77559eff1aea4c4845eab8771e23eb453c276ef712f7c35765613b96e302976b25644a4e48c184084b0870056c0e12fb04560445762334e694c6fb331e4a89dadbe69e3fcf794e58f23e73ac69035220646cdb8a377efc4806006103dae598b2745822570d5e668409985fe80d3a105c500c821d1881e56a8eff30a6ef5101dc3fb819dfdf8ca04a5bedd85af336911be3ad0751cb821bda7881042aba35060cb2c2a72daf7f7265198e7b3af1ef3d1ab915d10eecd250325cc2947711889eff76e9411eae22c49274df394c4b84c31852fcbc55ba52eadf064848351c9e28526cb1d3dcb2086c5676f801b1ec126cd36d7bd8c808f74c71fb65de9f983a7894139bd47182dbfd5e302c748aa229113c29e774ce69cf7882621f8eb83e74cd907d7441a248ff1fdd496cf6fa9e6f41b8512cf3a32282fb9407a8bbec0c4d972f298b6cb4feab1d90d480739311fcbc0a095b02e155c5c46fd9626b6379267c6dbbb66eaa2e3e7c493eb651751378c560029357ddfda3ab64a54025a1b1c3523fd5afa9ccfe5fbe0452f9c57150639c78b5336e992f7637ede40302335e52618b51021eaaab02608ef5791574774f0ede2d474da1884e71f875b67ac798eaf5c9c0a77470446497e1fa640e1174bc997cac473d1357b974e14e8dee1a68944a6c5c9ac165b831cb56d94634f4d4dac1e778408840a2b5a530e19f21afff847650ce84ad4be77d1d3e4b2c670499e27ace8d1192153f4bbf3d48426fdfc9562b182a4b547fafd642e600f40632901fff0052625cff5047f10da82ebf7283cfa621a08a3bfb2f396d3976021d99be346e9fc307dfa349ea9d917cbf33f5c89604ebe3d7c4411e399f9659de2112811346d0fcda0bc49cd847d18fa3ef3d1817e8c495c44304dc5923458ced6bbbb8d834288055f591cb20db0ae229f4b138964e85665ef96592ef4bec520eab5b59912a80b2d48089513cb933313d9f1474474b9d7e6418ef6ffb685a34d833c1fc5b668a3a851a4532b9b789e788848fcfab441683aa2754fc8fb77f3d6f99e5ae23521ba39753ba15c86176faa1c5f83ed820b75cd5b28f54c8062a563c8ca36ba585f0bfb1308a73b1f7d0c797c873c6891bf3c8f58b5f3ccb087372cd517b0020b335287fae3dbaf89870d59cb3510a5fa01448aa58ab71bdcf0b504460b917086bed921c3a7751329397f8d2e9d18b3f31e65b5d5bfc0fb10c6f5384b948a063f2d488bdb664182c776f53cd732ae4f99ab31b466438c4674ed33cffb2ec1b61f4ee3683e5fd791af1326e0e544207888b95fc32023a5a02f23c482cfb82ddf62f26e90d5ecffafa4e1393682d840e3c4272b0204dfb340ea4e64e4cfe74a406097744a53892b515f45e20c8eb29ca9c6147a29f332e6f8c0deacc5556f98ceacd0134d82d394a826ec678affa1583dd5e7921b67baaa10ebb390ebea9991f0249ec0853c50d6351b868953ae2cf51cd5dedd81d774498fa31e6ab8c2a4c5e62fe33e77216b284c474c78e4f13136d6796b9e2dd9ca5f1d3db0639710016b5d3aecec91c749cdbe1314e13b3cc38bf91b4a87f176d253fe4d85f920da7252d10219faa3937b58a49e2b258d3797b3874b3ce87bbfe20e456f6dc84b7f4fc419344f30ccec8d691e259ccfef3443086b90349acdbc0b0c70fb3c7a71bae80e965edbc6dcf96750bfb7389cb210ef1b483f5e79d3aa27e7c81844ea09da9bfb0a081e6f6cde761f096ef5868cc5f63cf64ee1611e9acfadf25bb9ab6c09c130fa6e6b0dcb48ceb2db740a4767e56dad217d24de18ac847d9ba58489faea026fa30e53100cae1d1aa19b6365bf2cdecde092d000efb98220973c1412589cba9f6a4440e2f118d195ab1f0c84d5d2c2ed556831ae0b100c2764ec2ed3045c9191a512106269619bab21afca30f50fe367de406338998b03487965c27af583f7d918629431c52904b4c2efba1d91b28be50fabcfeb2ca8530faa485b5341da0b3b2244ec21e9c417b149f93991e0848ff3fa12c2e3062e09380b9718635ba2764e091d57ace8fb4464b1c980a293211e80c646d6c85e41336f89078c33c7a3a9fbedb0968978c3d756c0aad1afcbf28c7f6536eb1a17d4307c92a70b65618ff783bf123236751c088b879690e4950d4c8cc81e7ff51352eebd909c64987305d62d48924291f26802500e8b1f0cb359aeb2cdcfc0c038ceedbf58e9426711f9f5f19dfc8a38cf443017609a00c913533e85c98e728c348e0c4a49d7cb8d9d8ede2a3df7c1205c49aa8d39d5c793ff6d2aff0d8c67ab63cbf68d76ab96e0ec8b658eef19fd68d6443ce11610432123391e7015c2461081fdd7a6dcc6ea3e25fb8990f438ba8ac96c65d28bfcfed88a5be573feb27d92a4c67b0393359b401c4fb5ba7bcbbc5059165d64bbaff5607e966589f138adacbfc8c05d39221df8f049cd4f19127f1d2751f85d3e3d0e084c73409e0a4807b18aea63ead03c064786462fafd96c3da407b7dec57acb3988dcb7006ffae1cc0013e835a53caba1e764235aa00a5a10356a558cf6fddc4206c55afb3057b72786f5c5e077d2030695640279c61c826d4f5747ed355445da5a7338b18acd6d6e910794978ed6602bfbd010290d6bbf661ff84e973faec0e5f6df5595d6d956834747ec9fa9542dcd211d4190cc2ad7e6d7cfbe4013ab9ef80bfb16d8b1b61186fff9663530d7fafb567a6c0d0a35bcbeda9fdba64a9f93160d436ef455a14ba623b5e192b960e4d924e827fdc6ace2050c7c2e8fb6f7cae015ba225ecfd0daf67258bbe4b7fc86b57a1708d90d58619ba12658f37f59888baef7b487bc59a37e3f7ace474e2e8a45e2b592e3ab7699c676acb089cc0845562496e29145c21822e7b15ab62bf9ab96710f56569c99a5c0d66b8af2bea095ee2f569517f67a5558f74613ec3766c2a3bc61ef945fe29e38f2441f1fe0651e1a0db342f0a345fc5ed5b0a99237210d45bdeea95116e3892af87b2172603fad30ce15fbcdf61b8394f9af7c5d98843018d561932a336a25f7f484cdca2588f59c9f40ad75bcf54ac4de76365423eddba7fe90e2990b11792a1083c58242e0bf4af95988e20b19c594a5b5c8a2f90749bdc4de2854f38acb68d9f3ce5d7fee847f47d2767883ef72ad4956b4f70b2bc217478991a9a6ec153ca03b071e61df21824a30f83bd389b7200817e676f038e3ed719724a8ecc90610ae2ca03870c27f18be77e1f6ad8a061408e4add8f5f6d69086c5e6238ab74951568e49b458c781d7d14479526392369ff9cd822d70032a189bf1758bc43b2ada3dbfc95f6344a42c7448c9b8bf4b747eba9012139cc2a296ed002b4f3feda2221bf1818588639bfeeb130a32a3ae8c4706bea91ff3bd8fb99c61444cfd2c614f8044fd25b1e965a1ff882de9afd08d47b4ce5bf4aa3e87517cb410f9119d6c642d61b50a06bac190a50f74ab2cd3b851f5b91c89df1744a1a4e15551130b092341d1e7c8d59b81e211718a9c9f58c934bdff4f8c591a83b13882677788698feb33ce816a87dec7736f6a1e096f0e888b8d6e173a1616e592711a3175c57095b418be814a242f8e8354c02d8b8fca8a91443491e740763537451a939df7410823f7ba25cfbc138312012a8e7d0d852b1b5886b3213d1ad250f5a612a327cb990de78c39d301bfe5b61e57c310ef8d7b3a4fee31fc475474b284747ef67d8e0a7919688f8b5b9427ca1e6d578e35fb45d0be6cf8688b136264fb7e4113594b1fb8f71de26266f342adb8d7f1b46cda912c74fda2a28bbc3425eef49234ea7fcdd149d046ecc7ec70beab8f53be83ef85ec7c7a73aceac41583132d999419f67c61518a930fd819cdd17a4efccd886fe981c843133829ddbfb540a66cf936a0427e6f6ee27acb3eb2c47376fdce62ea0277794225a2b273f47dcfcbddd30d019d1bca396ff518ff1603adc69d5d4107a498ebce41033f87370a3ae1483e0504cc39bbb6711618e5e7bf0e826f00dd401f5685de1b1203593a08307df4de89f251fb249ee1099a860cba8b0a12889c2b2dd3cb2b076f23c738553e699ff9208b608812ddecab8853f1167e15cbf5ec314235f2070680636ba6fafc20e8dd67a99636c9c0d697286f48946cc47eec2b9fcc52ec2ef3c5a825bcc35be303b5a465b41bd6c0ec565381dbfb5989ec47154f8cad81054f54a85eae7e7ea4ef33843906870a7bf9cf825484c9cbceefbe6d28d5918492a4540e19c50259469de9839e4f1fd694b02a0da637b4bec269218673b205b20467e6ae9425e30d303bd66090f6b2d1124df03e0c487ffd8ca9b115b92f0b048d7201fc4e7aea4f74ba68b231732da651c02dfd24e1b64ec3eb65f5284b2635549c45de531f3846ee34d20cc9b7e5c332851c61259b3f509d5c527a4d4edd356fbd8c7f638cc73b472bf726ad0e5406296dc3d44849f2b393da73809550026baa5c879afa11c5e8819850df4dd23b13858fe1f613071739bd6be55b775a9e9fc6a79fa5e21fbe647029a114b9b49e470088f5cb594f1031b720a8d3383624aa991f603b96d5991075648c8dd5f58e3b12258847c028b5e450496ed110d7673e70d82cad3b0253a911bfbcc372c89797c111c46541bd89da8bf0b9c7783dfe29832b10c6d57e1160d0ba9ac3da2531ee883ffbd565de5373d026c607728563456e3ebec22a4c1238f38ab67bfa62d9484c295c810b14dea48061d8c63a044d49e825e811f35e31183dd152452764d14b9f64e28c458e31c810e8d1b0d867a5396bf3056a2e0376ceed41e66882112351e7847e35c5fa14afa584a6c36ccc797257d511ded27a9404305fc4bfb4048b56f3ce919b9bf11754ccb0f39f47d6a1989369d1cbda03cf715f5d11e76f8fd50fdab5b50bafe1ad4239dc8bd7f205cf1bfc3501cdf758b9effbbc090eb7a1a9aaa649f0cc4cfc9eb8d892cf4749b216ac574467b5828a3c4ff378029231d71d1f801731320f743f2aa523da74269745c73a86db7ad03e74ab27e18e8e88e1ac8c479e1c2085321ad1e8cec1a1e4b48e730180ebd89d11bc528f7fb592979c547976605842841d1e32df683fadbf5f422e1fbdc3955318ef73f04f522967e3c7c9c23a7f02dc443dcd5f4db9ef5ca79a8692f9481d82fc7c2d783605c98e393e5c7a51d5b298c5c455773567d282e8f699e3ecf532f6501ced60ccf5814f5b085854452e2cb6e43452e01f57d413f8287fdf24143f4453906437b6f970f1fd21bc2501a11069d70bbd1b34903f7cc1e2589bf12e87475e1c8e8c5f5401d9930125d26b0e2e8ef49cb243c2d7b8629040d78cffc5b484060748fd6e9182671cd6b24f059691ca0a701d3dc5b36d3256737ca77ec1fd7f8b5fcad0c1f368af302d657413b8f8a58dc1e12cb6a6ed1443d7b963ded1b85fe04c4d94b5d6b5903e9577d120cbc0808d598b88d441416659028183d916d8dcf6e2038080253b79616de6be1fb16952ef9dc0f7481615c34b1523bdd70f6bc674ee79166c18a5bbb7abc639bd25cd2a9a48c27b78de22638d9cfda1a4f540b7caecaf7a964f269296f03a3c57b499092b520f9c29d510fb54d9fcabdfe2ec6af91772a792f4c4c7b3a80e8571044cce678f5fd65c002f4132b89870f068b974993ece82fc306b2da2cb21ec1795928d47dd6142fb5aeb61168c0a2dc4ebbc5871b0b6abb4f810ead939cf6c15cf161772c11f36a9b7d25d4955e33f431b3c0a80b8960cad664dd3a8bfc82267279d7bdee85f8bdab09192d6d6b53381fcbe6ed5777dddf3ec43e57e69d348e71f445079856f04bc20347aa95ffc160420207217a4bc2c762b43c73e7adc3f30383e7758b3f3ac33d87d511d6c6267717c584bac0303678721ea62808c6b5e11b143d4ab2abbb5cfcb8fa7043acfa59706d0079ac08bfd93eeef43f6b16fa46146357ea6fafde0af91c04ba0dac9273fde4425d2ba160850b88089d1e346c12890d8b9e67de5890d731b1665d042622ee98309a55b70f6ec3f555f9db16f2bce439cb113101f217e61e59b497dbc0dfbaca987d476d9f38a4df2c019ae0ee5b22c3d911e4b56d048bb79c757db0c4a6f38fcbbeb18803875342a338ee781e94b334c6a42cebd5d0601ae73a2e36ce27de0a6fdd76299c18deb25a735cc5125e0eb8f801a2312ad0eec2edd4a139a3ebe972513a00e3c341923deac2421954eeaee7881702d8f98cb32832f1e350611dd43cae29484ab726b001a1b3da6b4cc0cd6cf8fdfc1efeabc9ba70f1079f288094f710781212fd355ea22e0f2f61360424817830c2610c4321eedb3a8f4a2c71f0c010ebe0f313e94fea553bd65a38ff4597011ce84d74875a3ddc9d39c4d7d796bc76ecaa7d6f230594d91cbe044623aa73c483c74542669ed97aba5974ee2cc5b39acd23a75dafd511ff824384e279fea23f32cf947b715c8d4ecd8d728a16350e79b7338d6cf07db9bd9e3fee28d464905e99167d695d3b8bd8f05f904f411ec30c8327d959388bcdf4c00fc32c145289ea9c9141fc9c7bb88ae8e3bc1bec862cc07908e55bf8d6979a58421cf26e71555ec21e15420bd271844f7b5880dd0e4c1f20b59adf9354fedce58f6ec9c8146d7e7d7a822e7e1994387d72161793a104883a506d934036c252b3878a6053ae53952d480db0ee7d7d00cfd1e2f09b54299704cd760922c4627dad4fef25237d8d584a93f3e6e1408b882f199550cb3e23700822fd7483598bc69b20df1678e7ad02b95597fc143b39d3fdcbe656699c59a2e744938432a23c8c43271a2f64368aaf6faae4a37f44bbffe730de27df33c1c8c90ce25d2af7915823c4ee3720ac19acd9bc9f3fcd54186aaa8ef2362058ef92828c1d7433b4e896494760365eef9b36a8e5e2691079faacd209274e94defedc94f3f15893778e3345d7aa77efbba390b4a9467f7b74947ec671d07b3fd52f64dfa3e92fda318b21d827c6cdeec1aea57515af947f016b16b0eecd6953e1462c81f4acfc48c5f3c25e8a14ecbdc5c34be6ba6451edb200373efbbbe90d37ba25336f95cb7f60b99a509ca8b9835d14147f9632cb33f08786a052a9dc4262841d83ca078254156be244e80ed4f24c9316ccb0ebc73e7bb02e7cc322eb995d281afefa3fa9a08472454b5e9bfad172febdc2c3c22a76a124f0b787b343ecf7fdcf2891fd259da104ea688f94045d450e0412d75c85cdec6d8417cc4bdb1003bf4ca601bec7cb895e8e1ecd36b0930799fd646a070cc79a7f1cdeaf63ebad7e44f2dd9c2939eee79d3281e94cc8be3986f899ac83f6211cfb847338676ea629da630c345a199248b1b79a6ed6b840b431302ec1fdb4c3411bc915ebf619c5655489aa74d29987e5a76e48de7628dac14f6451634d83c88e0d09cf59accaadc3cb67a3166f6b614aecf5533474faf752c1835d5eb88902d5df7af798df3076e893db4b6e8782ea7d7fda4a63b26973c513e9f2b143bed7ee35b93ffe613b5599364f3cfce0cabd4530c038e7629450c2997278135a2968fd26e27d63a0d680aa5cfb2a44be4f51dbbad1c471d8e60b0bc2a4311eb46377ea75852d814b82ae524efc2bceb3532119be2f4ba6d203309318201874fdd6513600b10702cda9a2291ac381f5dfc852abade9bedce56576ac92687acc69595620d53f8dfe354be3cbf9da1a481747434a20f1ec44407238b4671c91ad3e2e055673677a9dd5e298284f898a9b9d8690b811acab61720ae90777f652a0628ba4d8e83816dc0f0abff36664c006c4d7bbfa525377c37c94ebe81a97ee5fe12513fcaa07090dda497c4859dd5565a6849595bae886da3a541e6f23e5a5f45d03b57b2e7c09252c43fe6e5701ec00eb6273e3d16dbf76f3c59822866777908676f2e83043bbb3e6d3cefec53315f04523af39609fb547940cc9bb7e790746b8d2005aebc7c42421100432297be6189c0f4e617677de9e8997076b0f0cc1a957554543d7fab52142cc268b774620ea7ad4ef9104c9fba7ad9c036e82171bdf110ffebf96e6f6af7507a82ab9f69ef755b4d3a08ecf86cd57d38c025adb4aa2956f1ed6bc65c962a754dd397d1318d582eb041bf4971e468add21fd6aecda46bb84a0db8485301c76470e1ecac673722a484f3b455ea6cacf14ee1ce8928fee781aec35677c57fd16a5b05bdfbb168442aae84c53b4503458ef22e383d9178141b6a78b491b79245d9289cf09f28f2a2b4760ce881c905b4a89469fc9e2c60a3ffdd7cb944d54bcbca423c96933a1df199cec4bfcc8f6f5822af9666e625cc5ca24bc0bdcee6e1e33f711feadb371695a10ed859d6a99344ad3b2c7f81d66c5cbc9f07f4a0c4a82195bb6404744fc3ae37cec6bffd4ce9f0fd83d49bab85f30da0c3e48ad0aa654b573d0acc819e90d099ead2f9a198ff69ab54ae394ff859614a005a8ad6b8852bc73f4c27eca681ed709a4dacd146c1d05acb08c1ad0946ba23295294806dbdcfbaa794d7cb2ed3aec3bf7caccc65c02e6d8feab4cdab3b8ed8d8896d2a22aab6a006a5841b632e876c3ae67ec59a57385b8bd426c6f97e4f558ae2f4767c4d94b06731a09e5cca99b034005f22817e1dac542320b8a82e637b0b6711b69360d8b6e74b7e44adab695e794648b414af40b8a97380c3cd419ed49ca1420e26f7a85c642615f0084291715c383bf74a5c6a5a47f16a23a6b4e4b1f71ea33afee38e29a6c4402b3cf953b9302efd2a1b7333726f4771ee87a72eb5b6e67fb4c9280d8d8e20849ab9bc945eee0c20ac3239e36319b61f792988c932852aca98301bc02cf8f0afcc189fd71cf29a41af64f4e121efcb4e4d868abca09dbffa5dca6cf70f32d05fe29161d2c40a358002532905ff29bc3358963b04e53324daa6ee6e1e50e63af288ea87b3f8d2ccc609fdbd8ccce2baf342ffe61998b70f54c56d9dbbdc02b7dc70994b2cab303d1bb443e5984377b2b51d1adfbe41332fff68dfc49127dbe9b20bd65fdcee45f0ce22d17908b7a60b6586c1c32b247aeb57bcb24cbe745437cdf3b48689d2a5ed6ca79cd387015d116c5b21456adc524fb51d34e401521bcd2d3da0f39142f43e1e9bf69acaa30edd6050afb1c3fe8e8982c786b410931086f90bd14e9ef723fdb0a41a7aa9cff295aeaa5d07f3a33998bf8c542cc60237b031ed86a559b5182bc312d2fba383b44d195064f68eb37c8cc66f54200787a4e7db593cde8b3ece6867bd2cab90449c41d421712a748ef631c3c9dffa08eb4141b521bad47049b551ad7974d627e4dea3ead203ebbec937b72fb238dfd924b42795793429829d89631a065df9d52592f3bd5262b4fa909e5afdaff3626a244a99ec0b3f43b3c5538b7773e28ae02ac265b8bbd0470c060f9e25ddf2a628148cb67a1970d772dfbb640f77a2e6c37d28848465302b30273209a47eb805c685093d43c296aa86198209f4aec2b554ec9972c64eb339c8e82ff7f76a62019165f36c40dcc893df6731a928fb2d788420e19597da9eea2da0ae7c5bb6dad0626112cf7376b9b1f62c87d20c65f9fe124b3e7d610ad3e1e028a90f830bce20356bbf60fe73cdd2ec69a00af64764f89ce0391ccd0f56d5d5533a3e2a63f731e65985a93c9c46b701dc0cb639dfde476fe03cec66d2e3ce4cdf79df446a62bd54f47d15e9153d70dc18df976de15fcab64e1dccb09e6bc8eaf3e8323fca01f3786938c32b823f0aed9d9bcf6185691bd987da13ff6d8787646e3961e0846962d4320</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E6%A0%91/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#零">零</a></li>
<li><a href="#一">一</a></li>
<li><a href="#二">二</a></li>
<li><a href="#三">三</a></li>
<li><a href="#四">四</a></li>
<li><a href="#五">五</a></li>
<li><a href="#六">六</a></li>
<li><a href="#七">七</a></li>
<li><a href="#后记">后记</a></li>
<li><a href="#后后记">后后记</a></li>
<li><a href="#后后后记">后后后记</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="零">零</span></h3>
<p>村子西边的高地上有一棵古树，没人知道它在那里已经多久了。</p>
<p>有一位游历四方的医生曾经到过我们村子，并对它产生了浓厚的兴趣。为了搞清楚树的来历，他挨家挨户拜访村里的老人，向他们询问这棵树的年龄。可那些老人有的回答几百年，有的说上千年，总之没有什么确切的答案——这棵树在他们很小的时候就已经在这里了。而且据他们回忆，那时的树似乎也与现在一样的粗壮。</p>
<p>后来医生向村长要来了村里仅存的几本古籍，其中的一本可以追溯到一千多年以前，那个时候的树竟也是一样的在这里，据描述也是一样的粗壮。</p>
<p>医生取消了去另一个村子的计划，把自己关在房间里日夜研究。可每当他似乎寻到了一点线索，接下来的研究又会逐渐将他之前的猜想全部否定掉。如此过去了十七年，十七年后他终于把村民召集起来，宣称自己已经找到了答案。面对着议论纷纷的村民们，医生先是展示了自己手上厚厚的一叠资料，然后呵呵一笑，说：“这棵树，是一颗从远方飘来的种子长出来的。”</p>
<p>众人哗然，哄笑声与咒骂声不绝于耳。医生看着他们，眼神却越发坚定起来。他挥舞着手上的资料，看着下方逐渐散去的人群，高声重复了一遍自己的话：</p>
<p>“这棵树，是一颗从远方飘来的种子长出来的！”</p>
<p>然而已经没人在听他的话了。</p>
<p>几天后他在家中去世，没能留下遗言。这一年我七岁。</p>
<h3><span id="一">一</span></h3>
<p>树上曾经是有一架秋千的，用带有毛刺的粗麻绳挂在横生的一根树枝上。村里的老人给孩子们讲故事的时候，会说这秋千是几百年前全国手艺最好的木匠的杰作——他曾经进过宫给皇上做过龙椅呢。</p>
<p>比起虚无缥缈的传说，秋千于我而言承载着更加美好真实的回忆。小的时候，我总喜欢在黄昏的时候一个人坐上秋千。因为这个时候孩子们都在村里，秋千这里往往只有我一个。我背对着坠落的夕阳，望着眼前簇拥的房屋和上面在光下灿然的瓦片的场景。我可以看见孩子们在村里的道路上嬉戏，一个把另一个推倒，一个把另一个拉到角落里耳语，还有几个一起在光下翻着石头堆，试图找到几块稍带光泽的石头（他们一度坚信那些光泽是细小的金粒）……而等到孩子的父母从屋里出来，轻呼一声，立刻有一个孩子浑身是泥地跑向自己的家的方向。日日如此。</p>
<p>但十岁那年的一个黄昏，当我像往常一样来到树前，却看到一个陌生的女孩正坐在树下。</p>
<p>我疑心我从未在村里见过她，村里的这个年龄的女孩子早已经下地劳作过两三年了，脸上时常还会挂着被杂草划伤的痕迹，皮肤往往已经被泥土染成麦色。但她却是一头短发，有着皎白的皮肤，正在树下用纤细的手指翻着一本小说。我忽然有了一种——我不知道该将其称作预感或是幻想。但总之，我忽然觉得她于我来说十分熟悉。有那么一瞬我感觉自己呆站在原地不动了，直直望着她，拼命回忆我们过去是否在哪里见过……而这时她抬起头来了，冲我轻轻一笑，我登时脸颊发红，撇过头去，快步走到秋千前坐下，却又忍不住偷偷回头看她。她则是背靠着树，面向西边的落日，借着光只顾着看她的小说。我们如此背对着一言不发，直到太阳完全落下，各自起身回家。</p>
<p>如此又过去了三四天，直到她某一天翻过了书的终页，站起身来，望着她面前的黄昏，忽然开口轻念：“唯黄昏华美而无上……”</p>
<p>我很惊讶，转过头去看她。她也注意到了我，用左手扶着树绕过来……她猛然蹙眉，抬起左手凑到眼前，她的左手食指刚被树上的倒钩划伤了。她把食指放到嘴里吮吸，也不扶着树了，缓缓走到我面前。黄昏的残光映在她黑色的眸子里。</p>
<p>我问她刚才念的是什么，她却笑着不回答。</p>
<p>后来我才知道，她是隔壁村子中的一个没落家族的独生女。她的家族曾经在某处显赫一时，但到了她的某个祖先的时候，却卖光了所有家产田产，捐了个小官，携妻带子远赴千里来当我们这的县令。她没有提过她的这位祖先当县令当得怎么样，只说他在任上暴死了。</p>
<p>到了她父亲这一辈，家里早就很不景气了。可即使这样，她的父母从小也仍把她当作富家千金来宠爱。每天的这个时候，按她的父母的规划，应该是要让她在家里的书斋——一个在厨房旁划出的隔间里面读书。我们相遇的那天，也是她十二岁生日的那天，她的父母却开始想要让她学些女红一类的事。她因此赌气跑了出来，因为早听说过古树的传说，于是一路来到了我们这里。</p>
<p>这意料之外的出逃当然让她的父母焦急得要命。她晚上回到家时发现父母都不在房间里，来到祠堂才看见他们正跪在祖先列牌前。她的父亲双膝跪地，双手合十，闭着眼虔诚祈祷；母亲跪在旁边，弯着腰捂着脸抽泣。当看到站在门口的拿着书吮着手指不知所措的女儿时，她的父亲立刻起身跑过去，然后被门槛绊倒摔在了地上，爬起来一边哎呦着一边哭着笑着把女儿搂进了怀里。母亲随后也扑过来放声痛哭，一边拍着她指责她四处乱跑，一边又仔细打量着看她有没有哪里受伤。</p>
<p>那之后她的父母再也不逼她学女红了，但她还是天天来树旁。</p>
<p>八年后，有一个孩子从秋千上摔了下来，摔断了腿。他的母亲因此暴跳如雷，来到树旁，先是拿起斧头砍断了麻绳，又举起斧头准备将秋千板劈成两半，但劈下去的瞬间却听见了巨大的金属碰撞的声音。她一开始吓得扔掉了斧头，两腿一软跪了下去，以为触怒了树神。但旁边围观的人围上来后，却发现是她的斧头砍到了秋千板里的钢筋。</p>
<h3><span id="二">二</span></h3>
<p>从那一天起，我们每天黄昏都会在树下相逢，这似乎成了一个无言的约定。</p>
<p>她从小读过各式各样的书，比我又大了两岁，见识比我广得多。有次她问我读没读过李商隐的《锦瑟》，我只说学校要求背过。她又问我觉得这首诗好在哪里。我想了半天想不到什么东西，只能把学校老师教的那一套名词一股脑说出来。她忍着笑听我讲完了这些，然后说，她觉得这首诗好，就好在即使你不知道它在谈些什么，也说不清楚意象之间的关联又是什么，但只要你一读，你仍能感受到字里行间藏着的悲伤。</p>
<p>如此的对话，在树下的这几年时有发生。从《堂吉诃德》中的蒙德西诺斯地洞，到《奥赛罗》中的天鹅，她总是有着独到的见解，像是一个偶像似的人物，如此完美，完美到不像凡世的人。</p>
<p>在她的十八岁生日那晚，她深夜跑来我家，向我哭诉她的父母想为她和一个她从未见过的男人订婚，于是她又像六年之前一样跑了出来。她扑在我怀里，把头埋在我肩膀上哭，这是我第一次见到她哭，也是我们第一次相拥在一起。我一时不知所措起来，只能轻拍着她的肩膀。过了一会，我看她情绪平复了一些。</p>
<p>我问她，那个男生怎么样呢？</p>
<p>她回答，家境很殷实，听说为人也很不错。</p>
<p>我又问，那为什么你不同意呢？</p>
<p>她从我怀里挣出来，扭过头去，然后又发疯似地将桌子上的书一本一本扔向我，鞋都没穿好就跑了出去。我望着她的背影，在那一刻第一次清晰地认识到我们之间的感情。</p>
<p>于是我追了上去。我们一路跑过村庄里那条土路。那个时候的天空还能看见星星，满天的星月仿佛都在陪着我们一起向前奔跑，奔跑，奔跑……她一直跑上西边的高地，跑到树下，然后站住转身面对着我，头发在月光下似乎变得透明起来。可能是因为含着泪水的原因，她的双眼似乎也变得透明起来。她歇斯底里地喊着要我离开，语气从愤怒辗转到央求。我看着她痛苦的神情，看着她嘴唇微张着，昂着头，眼泪从眼角落到下颌。</p>
<p>我伸出手去握她的手，她一开始想挣开，但我紧紧握住不肯放手，将她的手用力包在手心里。她的手好暖和，手上有些汗。我们如此四目相对，直到她放声大哭起来，将手抽出我的手心，然后紧紧抱住我。我也伸开双臂将她拥在怀里，将头倚在她的头上。我看见月光散在下方房子的瓦片上，但看不清模样。几间屋子里微亮着光……可有一家怎么却骤然熄了灯，灯光挣扎着闪动一下后缓缓暗淡。我悚然一惊，手一软，几乎要把她放开，但缓过神后我立即将她抱的更紧，更紧。</p>
<p>我开口向她求婚。</p>
<p>后来我们在她十九岁生日当天结婚。那一年我十七岁。</p>
<h3><span id="三">三</span></h3>
<p>再后来我和她去了同一所大学，报了同一个专业，又在学校外租了一间房子同居，课程安排也选了几乎一样的时间：这样我们就真可以形影不离了。</p>
<p>婚后的生活与我们过去的相处模式几乎没有区别，除了我们几乎放弃了各自所有的自由时间，每一年、一个月、一天，我们无时无刻不在一起。即使是因为差了两岁而导致的一些安排上的差异，我们也一定会定下一个地点和时间，等到各自的事情处理完了之后来到那里，然后一路聊着各自的见闻，相挽着回家或者去吃饭。</p>
<p>我们共享着彼此的社交账号的密码，用着同一张银行卡，每天晚上十指相握着一起入睡。连我们读的书也完全一致，因为我们总是依偎在一起读同一本书。她比我读的快一些，在等我读完这一页的时间内就侧着头看我。我们甚至讨论过要不要以后只买中性的衣服，这样连衣服都可以混穿。不过这个想法最后没来得及实施。</p>
<p>离她的生日还有二十一天的时候，她受邀参加一个文学研讨会，而我在同时报名去听了一个哲学讲座。我们暂时分开，约好上午九点四十五分在学校的图书馆北门前见面。讲座刚刚结束，我就收拾东西往图书馆赶去。到了那里，我抬头张望，发现她也正往我这里跑来，冲着我张开双臂，阳光倾洒在她的短发上，直到一辆跑车将她撞飞出去。</p>
<h3><span id="四">四</span></h3>
<p>跑车的主人是学校的一位教授，他与他的女伴一起随我们来到了医院。在抢救室外面，他静静地听我哭着说完我与我的妻子之间的故事。他听我讲我们的相遇，我们的相爱，我们的相处模式。他感到不可理喻。</p>
<p>手术并不顺利，医生通知我，我的妻子的内脏受到了不可逆的伤害，大概三个周后就会死去。</p>
<p>第一个周，我的妻子还在昏迷。我原本想在她的床旁边铺毯子打地铺，可这样我睡觉时就没有办法握着她的手。所以最终我搬了张椅子到她的旁边，每夜靠在椅子上，握着她的手入睡。</p>
<p>第二个周，我的妻子醒了过来，刚恢复神智，就拉着我谈那场文学研讨会的内容。我紧紧握着她的手，含着泪静静听她说完。然后我也开始细细跟她讲我去的那次讲座的内容。我正讲着的时候却发现她走神了，本想停下来，但犹豫一会，还是用手在她面前晃了晃，然后用略带委屈的眼神望着她。她捎带歉意和俏皮地朝我笑了笑，然后打起精神继续听我讲。</p>
<p>她的精力恢复得很快，这一个周，我们从我们第一次相遇谈起，再到第一次对话、第一次牵手。再往后谈，谈到订婚、结婚、相处。她谈到兴起的时候会从床上坐起来，我一开始还想劝她坐下好好休息，但终于没有劝她。她总是提到那棵树，提到她坐在树下看书的时候抬头看到的黄昏，提到那架已经不在的秋千。她回忆起西面的树干上有一处倒刺，她当时被它划伤过。她回忆起那天晚上她站在我面前，我身后是清冷的月光。</p>
<p>第三个周，她甚至可以下地行走了。第三周的第二天早上，我醒来后发现床头放着我们正在读的那本《达洛维夫人》。她笑着跟我说，她今天感觉恢复得很好，所以自己扶着栏杆下了床，走到外面请护士帮我们回家取来了这本书。接下来的五天，我们逐字逐句仔细看完了整本小说。这次她读的没有我快了，轮到我读完后侧着脸看着她了。当她察觉到我在看着她的时候忽然脸红了，撅着嘴看了我一眼。</p>
<p>第七天，她躺在床上，我知道她要死了。</p>
<p>我伸出手去握她的手，她侧着头看着我，忽然笑着说：</p>
<p>“你向我求婚的那天晚上，也是这么握着我的手。”</p>
<p>我看着她，嘴唇张开又闭上了，只是嗯了一声。我们就如此四目相对，她突然挣开了我的手，把头别过去了。借着阳光在她眼角的反射，我知道她哭了。这是我第二次看到她哭。</p>
<p>她问我，她走了，我还怎么活呢？</p>
<p>我说，我会陪你一起走的。</p>
<p>她没有看我，但是轻笑了一声。过了一会又摇了摇头，说不行，你要活下去。</p>
<p>我问她，我还能为了什么而活呢？</p>
<p>她闭上眼，似乎在思考。</p>
<p>她没有再睁开眼。</p>
<p>那个教授承担了全部的医疗费用。谈起赔偿的时候，我没要他的钱，但是要来了那辆跑车。一开始教授甚至有些不情愿，因为那辆跑车太贵了，但最终他还是没有拒绝我的请求。</p>
<p>这一天是她的二十二岁生日，是我们第一次相遇的日子，是我们的结婚纪念日。她曾经跟我说她觉得死去的最好时间就是生日那天，当时我笑着跟她说那我们两个总有一个不能在最好的那天死去了。</p>
<p>现在她如愿以偿了。</p>
<h3><span id="五">五</span></h3>
<p>处理完她的后事，我开始看我们之前留下来的随笔、照片、录像，去学习她的一言一行。我买了一支录音笔，每天去刻意模仿她的声音，并录下来反复比对。除此之外，我还养成了写日记的习惯，每天要花两到三个小时事无巨细地写一天遇到的几乎每一件事，睡觉前在蜡烛上烧掉，之后吹灭蜡烛平躺在床上逼迫自己立刻进入梦乡（可为什么，为什么我却从来没有梦见过她）。我唯一不会在日记中写的是，我有的时候会自己一个人待在那辆跑车里，待好久好久。</p>
<p>如此过去了接近两年，我知道不能再这样下去了。</p>
<p>我带着录音笔，开着跑车回到了乡下的村庄。离她的二十四岁生日还有两天。</p>
<h3><span id="六">六</span></h3>
<p>如今这村子已经没有几户人家了，大部分居民早就迁走了。我走在村子内的老路上，漫无目的地四处走着，最终兜兜转转来到了树前。村庄里的人走后，连树好像都透出了些憔悴，但仍然和记忆中一样的粗壮。我把跑车开到了树的东面。</p>
<p>我在树下睡了一夜。醒来后，我望着那棵树，拿出录音笔，打开录音，喃喃说着“我爱你。”然后播放录音。我一次又一次地对着录音笔说着不同的话，从我对她的思念到她对我的不舍，然后一遍又一遍播放，几乎分辨不出是谁的声音。如此挨到了黄昏，我坐上了跑车，盯着挡风玻璃发愣。我开始想，在那天的九点四十五分，当跑车开到她面前的时候，从这面挡风玻璃看出去会是什么景象呢？是不是一个漂亮活泼的短发女生正跑着迎向她的所爱，却在被撞上的那一刻……我不敢再想下去了，闭上双眼，用脚摸索到了油门，向树加速冲过去。</p>
<p>车子离树越来越近，越来越近，一开始我觉得自己会撞断这棵古树，但随即又觉得自己会在车中与车一起在撞树的同时死去。耳边的风声越来越大，树叶的沙沙声同样也越来越大。我耳边却好像缓缓传来一个人的声音，是她的声音吗？是她的声音吗！是不是她其实并没有死去，是不是她正在树下呼唤着我，呼唤着我，呼唤着我！我睁开双眼，将手从方向盘上挪开，两只手合力打开了车门，在车与树相撞之前跳下了车。身后传来巨大的金属碰撞声。我转过身，看到车身已经变得扭曲，像是死尸上暴起的青筋。而那棵树仍在那里，毫发无损，与从前一千年一样粗壮。我走近树，转到树的西面，伸出了手去轻轻抚摸过树干。手指突然传来一阵疼痛，我凑近一看，右手食指正挂在一个倒刺上，往外缓缓渗出血来。</p>
<p>我转过身来，靠在树上，抬头看着夕阳。我以前总是不喜欢在黄昏望着太阳，总觉得那样太落寞，所以我一直都只往东看，只看被染上阳光的村庄。现在我忽然明白她看向夕阳的时候看到的是怎样美的景象，我忽然明白她当时给我讲的那首海子的诗……那首诗怎么写的来着？我闭上眼，尝试学着她的语气开口轻念那首诗：</p>
<blockquote>
<p>火焰的顶端</p>
<p>落日的脚下</p>
<p>茫茫黄昏 华美而无上</p>
<p>在秋天的悲哀中成熟</p>
<p>日落大地 大火熊熊 燃红地平线滚滚而来</p>
<p>使人壮烈 使人光荣与寿同在 分割黄昏的灯</p>
<p>百姓一万倍痛感黑夜的来临</p>
<p>在心上滚动万寿无疆的言语</p>
<p>时间的尘土 抱着我</p>
<p>在火红的山冈上跳跃</p>
<p>没有谁来应允我</p>
<p>万寿无疆或早夭襁褓</p>
<p>相反的是 这个黄昏无限的痛苦</p>
<p>无限漫长 令人痛不欲生</p>
<p>切开血管</p>
<p>落日殷红</p>
<p>愿有情人终成眷属</p>
<p>愿爱情保持一生</p>
<p>……</p>
</blockquote>
<p>下一句是什么来着，是什么来着……</p>
<h3><span id="七">七</span></h3>
<p>再醒来的时候已经是第二天了。我起身站起来，发现树下没了车的尸体。转过头去，我看见树上挂着一架秋千，我的妻子坐在上面，清晨的阳光照亮了半面树冠，也照亮了她的头发。</p>
<p>恍惚中我觉得这是梦，直到我看到了手上还未结痂的伤口。</p>
<p>（写于2023.09.17）</p>
<p>（2024.10.19修改）</p>
<p>（2024.10.29再改）</p>
<h3><span id="后记">后记</span></h3>
<p>那天偶然想到了这样一个故事，但是一连等了三个周才写完，主要还是最近太忙，抽不出时间。</p>
<p>对于故事情节，我其实想声明一点：</p>
<p>文章中除了“我”以外，所有的人在现实中都没有对应的原型！“教书先生”与“教授”原本是有的，但后来改掉了。可即使是他们，也只是对应了早已去世的两位名人。作者无意以这样一篇故事写任何现实中发生在作者周围的故事，希望读者不要妄加揣测。这篇故事在现实中的原型，也取自作者本人的脑海中的思考。</p>
<h3><span id="后后记">后后记</span></h3>
<p>在参加魔怔杯的时候，这篇本是我一时兴起所写的小说受到了许多认识的或者不认识的人的热爱和称赞，再次非常感谢大家。作者并非专业写手或是文科生，语文成绩也并不突出，能获得大家如此的赞扬是作者的荣幸。</p>
<p>另外，也时常有人希望作者能解释一下小说中的一些情节。由于这篇小说在写作过程中<strong>两次</strong>更换主旨，导致其实主题是并不明确的，因此连作者自己对同一种意象都可能会有不同的理解方式。作者仍然鼓励大家自己去感受这篇文章，如同文中所提到的《锦瑟》，不去理解它，而去感受它。</p>
<h3><span id="后后后记">后后后记</span></h3>
<p>上了大学后，我忽然动了重新改这篇小说的欲望，并最终修改了大量的细节，甚至将“黄昏”的意象提升到和“树”几乎相等的地位。</p>
<p>我很难说在修改的时候我还有没有抱着之前的什么哲学观点或者思考深度，很难说。我似乎只是凭着心里的感觉去改。这是我第一篇发表在公开博客上的小说，我当时写它的时候是什么样的人呢？现在我又是怎么样的人呢？我在这段时间经历了多少才会让我挥笔对此进行如此大的改动呢？我不知道，也懒得去想。</p>
<p>后来本来想把这篇小说投到文学社公众号，但是疑似被拒了。其实再读一遍也确实觉得当时文笔还是不行，改过了后也仍然不行。但我心里还是相当喜欢这篇小说。可能因为这是我创作的真正意义上的开始。</p>
]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>刺杀</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E5%88%BA%E6%9D%80/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4a008c41eb06db89196be589e211c0d5d3f8181925da189fdef5e89c24459cb0">adba944712a73720e1f31df1fce5374437facb60f406548d8cd1a592f11521c4fc77ac30ca3525d544520ed08223f279f869a36289e229e8acbaf28bf5b062353348e7ddfe9a0318ec09b9800208d4d317456867e1f9e4df12ca80a32da49aba97c618f256f3ca158fd5b87ba21ec38d1b644021fb50058573d8956fbb1df15e583c5b889c3a1e2e9189a273f436ec2270b5a6a2fc5379700bb990a92f482d69bd21f29135ef2671a8981faa3adf92a3fffea31e0d38c06d3f3756956c9b473f1837749c62b1f151deec7bf24b919159941a837781582e0d8a91be0138b295539625acc7e7d4d6609363d2d9271221dc773ecd86830f838b09e48f2002c4c199a0a3928a79352bdfe93dd3f22097a819fda2879e806539022388136224391604caf082682fd294e2df1f7cc4cedc17358e2ea6f96b1b2e9a5e11101849344ebd7c99b67bb81914104c3549db0594e6efa5bf89152fcdbf583812f5c5a267379899a0da2cc48a32e1a34401bbc3437c521c5c9c76321a214c2d7acf69b61d0add84bda98a54618e1ee4589d6e42ecfc8e91cc6e16627d2556cabc3c37fa8405890277eeba19077631e32c020486c894651daa1bc733237e645a9a5aaf80a98b470b491076bff07ce2b660be41006d19489b514ecefe5e9479dd83cf77409e6b170ee79219e0a05de8ea16532c352945d6e8df28b4e3920ce945388f8dddaafe5ed7e0d4a890574a9eb0d78d9c5dd455442c5850c6ad2688eef6cfb26a0833afc6a5c2460191514f6c441f676c45243ee0fd72b005c32d15bd945eb2c82ea7ee1e30111421220bca845bf6e8e1edc0b247ec9875d550bd791a984ab8e541482e416472ed27c76f0f1d4c929d64820cb45becc5f97ddb604ce2fd0289e21600204820c3760d6bb2d517c9ee1c5c3295218e2819bc57c7f159e992ef12bec55d7de2965222d6315a9c6b7e5066cf5fecd1de66ed9b2cc6622c9d5f0ca0166f0a8112405b3750f9526743a7805dd055cde6c1824628d4f7a0eaeb52c760de8a159d912fc0de19e0f54d50789d25aa806a49e5bf717c8168a043926a9c432b3e2a93a441f35bc1d690ebe9ec3e58a39176af10a90e2d0ca317449d362046bb45125eb5a781432a702454f38d6f698a76096fedf6e6599dd3a629f7524d692c1cb92ac4abb26421ad90bfa262cc0e54718629a01da61f4c7eedf8cc172629e0523f2e62db34f0ce62da9f2dd561c0bbf462a7a919187020247bfa31fd12240864b78bef9a264074146694a594dc78bd0ae14a1549bd3b22bf8b8903ea91e34ab93dac194a377480bac4f63a5ad2edcc438f332a293440c63f69d1fb7de53d644b22489e358c8ec329b05fe596f1f7c67adbe208a8a14eeb638231ebfd7d5b3947f6e6862514b186628a072ea2cdfedce0c994e27c14dbffa61c475a9efcf47b7eb68b3e6d402f47428ad89b80a8d9d327469dbb694f5814b28073fbae34454289d5b65f6ec8bff78d7e5e3d285f8fd829f9835a0caa3dc2e51d653dcfe7b1e60c156e9cadb63d87d2c2b61274e568052495fea9f7415ee553749bba76b3b0195b0ef087c35a7cdb9d14983970b2dd4ba567a77cea0d425fb893924ea0b4575150864537bc7627c038d95235b5d802a1d19c2db3e5e6bca2fcddd1e1c574039fd4116eb194fec46abea30d7a3d2091cc9e5ba09d4c0a5f53a0fe082066656b123a28dd8fb6cb5e08ef1e89c187305cf0d935cae02a79ba0f0a07956b7f124150d44ac7913ba486c92056d7b3e1799f11706656e8e21afaf896e8e56bb9b8f29e25f0e084661adeebe4eba7ed96a83faac4ccd7c3cebf1d19514098e33a7ed3c4b678ed2f5c8b9dae4a3e4f4901ba394365a743f407e7de1ef3ec95c2e1e4c369f824ae879e4c7e2a7aa83e08600df43d022f3491da90cf19d69ee27be200c6fc9ce4ccdf158150373bc6e942d41f596a0636d6d07ea6e38068e6e4c1f4602490ea875fd95a672de121fc08817ebac5662b7b4d0b2b2de285e3826842b058ee0c3120f6a5ca66c6f3fbb4f3b881d286f5a4c08ec9d6cfd2c1764290f9e2daa51ce7e12c5279df565a475a9cc06b41c80498bed3531844fe3eaed13eb1612504fe80e72f76fd5c5d01ad3036c0e897821e207e43c58b83d21e4ed2b858a46ccf1c021949a3c0882a51d20a74fa0730cfc67f7a34ec571774aec04d6f3febf0e09122450c4b9964a7116b837807448f6020eb17013691d9c7f43fbdb240df3041542718c2793876c1eaf18c50b31f5f0c972f86c0c791492ed3fe787a228911e21f6e2bf188fe04a903060d3e44a8eedc06b65305106afb330b53c9576c13b7d3fbce411c215cc4e9cf8acc2398d5f8cfbbe2f5fef6671110974ae4146c1583ad5332b82fd337885e68c3bdc12970fee1fa36432f91e21b4ee52533e62d88fa23900d04c99cdb76047a7281499c60bf7293624559a89a012c9aadd4b3ce61642446cfe5d652e5e1fff130b4b76d0f506039b39c9411a1fc29b9e7da5fdeb96c3d01f982b0df55b15b0fd6ee6e1be08ebabf6d4c929f654f345c925d5ebf8970d3a6e73758633da164ce4eea5c8298bf40f9567f336932c24b4f8349b5d0e3ea7a1a35a973cd60449af7bf47d5464f0451de6e6c16c3c0b7d8c5ff07301de3c90b8416a7896ec00e319f7d96378404c208a302a15828bf25279cd2d58bdf7c29083e69412a16d6cf9103c1f09b0aec51eae5794deef250598d2973f4777f3d5a3324946c5d073b04ff4e6f93207f7bfc296d86b1ca3631c2cc7c5acb13dd8f7d5c8579ea3bb14ae3d550a0444ac99075016e4e2c38401167488874d79fd9543463437d007446e8a6a55228959952588c925963fb4a99d6243e57aacf61dd3f8cec1ee52392ed2ca06d57e9b2829410efb06f52319f9232c7b6247ef3d6b85145413176316a4dd1cf578f2d1a71abf7e6c1ca2e3f8419ceb8df37b70df565d79684fd86200b41822f48fcb14d6b3f0ff78b28335edbaa5a41dd18ec4906d82f00c6ec0ae6228740e5436ad205543c49060a13989df75f21010be374bf69eebc288b22a558bd5dcda1d22aa58865096008a9c8ae8b3995fbb07dfa5d7283e73e00677233250c952dbdbb856bd94a4133d9b1f499955352abba94ea8a5b55de66c303cd9d963657222263640ebcfcdc93c29f7fb175dab3da4b6bc01949bd1026ddb05db455b4b925d4b924bdede50f74f3048325f0534c558945b48d7d0e75cb6d650582b650f284f740a6fb3a2cf42936df0f2eef5824f108ea03bcad23154578f92a4b52e0403b6e337d05800893d17ef4f55e6f556006d570a64dd8da627c71e6cbf35803a478d688ca5639ed57824bd747ec970307b7c08c60ecf86e09f71e1f305fa195038eb93a48f04434a05b0564a3b719bb9d6ae39918f63b70cadab525cc6e42b20616d3f4157cc9f873fade64b7fa112047f3dc50426f6385a4153958c6e995585ebcacb65dce9aedea7ad4bc838864a45a83b04c54d40982c60c32b5b0cdad607c8d056c3dd38f82e23e4ca6e680b83042b582016cd09be7098a02749dbd5fbaf34538cddbf80f9a4b756b142490f808563079b118598591c862ee034dd8bd3c9fd75e521ba169930223b4d7179b08eb638cb517c3fa549d2e4275aaae4a26740a408113afaab4ac003c275d86b3c3f45c2c1bc0d12bcc98aea482d779066e84e48dcfad32876a26b2df879dd16c93e60ac1d9b9e3710661d2676d2397b320d84c40a14eec2f5778fd4a5db9ec7cf68a9e98fc109ee3211f4e0633fd3a1cb6ce670344a3405e203b1239430b69ca45b699b0ac4e61bf88deee79cb6c4800a223b9fe1826673be763e68387b9e5f59dfc4bcbb7f1c1ca5d768eaca23b62409d670c57f6c789a5936e61622a2e6406e1f0651021c06937f4f7c6de9224953beba0a3a097896edee71b5e66036101947423a89d17309e08c3996aa13f6ad95772b911f7dac491642c090739f5634d2ff42c0b95671bbaefa730cc3430ced6be208fe95d3f2b7ec981316ba158b1de462a3d72cbf38c644441c38501519a386c1ada8ded38de934de741f0967a89e08aa4152f88fc732272d74aaa715b93318c0d0d82c5b8e502a789a0cb0054b34910011f659e45ec5eae3ed3d60ba5096db2141a76637541cde4ea82a923cca9d9d152d88a53f608e135cf990a936440a7630617bec3b19ea4d7a9592e72a1f6e5233eb47c21181fb65fa796114910d92cd22783f76aec2001811e62c3b4d0327dded2f4aeadc3037c23f6408ecbdf49be39f878e276f724ea661ef8f462187e363229891549b049cd36c8b5ea2654d0df4ad4f6e5dd2ef5546216154f82c341ec5d0c1c450b18f87ece8d132ff9e84faaedc83c32101d09c5a5234b2c878be919ed140121b599518411bab2c26aaba5996e6d633be4742d16ef05098b53ce485bd59794f60a47b033771536c4fe566cbacbb0a409355f15e2136ac514f1bc42750bae5b0b1e840842f102173e5e5db42417ff5766b6fa6665ca19d87b21b0c1e88d00ac93860b571f99408f46e8178a1f0ac04447c1f5d8e49aa34bc908b72bc60f5860208b1f31fe5a8f05312349f709c97dd304cdf6f182772bd9ad87fc24c225ec7946969b5502b455045f589be06fbb96e40618128baa96c25d2a0f08549659a34057206953474c687eb99e32dd60cfca70f7380905391ab3794b820c1c80141cbf92aa71083ef6ad1b8f0f5874c48fa281bc85f2180e261bac230b3630819d9c22216de891c778c7ebb8efb693f346cf52b5001d8abdb645c607a558f11676c860e58d2e35131e633408129abef981751ed65408150bf108b2f23f3ec0b3299d26fb37c4ef542a7c0de701b3af13a9244b22d3164b3ae995c98d594a47a60c5779f494d42d58063a988aa11a0ad09b97ff9cb2463d433f866242586484069cf6ae0a9ec636d4ffa5880cc4b1f03f64d5bbe2fbb44e9391290a223ca627398500210585c628e52401a371b193dd82514dac21edbf568f8d443b0ff41e7b5b7e68137914095be1c94112191f3caa190ab3e4fd22172ed82e4219ae41fad7db3511bbf512067ceb2c9d3954500c9d06dd80d695ab35257026de3364d7c1922ba9e9c9940d20db913fc283aeee84e74a1ac267ffe215c9d9d3799b11a8747ea5977cbf7b32b530f948e35a3639df6e4b3b656a3a31d31eb94146eff5f9cbce0517def3073ec6713f560dc082ceda4ad168cde4598ff49d9270e1e8a1986d0905735ef27aa82d6618b8c1f2fceb618ece60497acff4034f87c8e622e0ed05800276ebe855df557b63acbe8f5b1ddd9dd6a2a0a43c90ec6d2fc90efee011f089f6a878480c433c36442b7145f962489a4adfd64b3acbb71c87b2510a1b18a5c13cb2de608e638dc6753953109283e7bbf455146003f94ba53be538fbe89070fb5e9a6bb1a515e94882728b5487f6efccf1476e39c26145e78df17ea7075ff2259d310ad23b2bf3e1e5859ca6bb0163388c3e826667b2d9bf0942bb1ced337126b84aca316a4bbfc8820573c3ecd3ebc59ba48d027b2dca569133d5e59bfc78f4852f7835506ee2ebf62f113f81de27791ef397f70347eeba1be5cda6cf53ea77b7071e5120ee5dddcaa0d2c8c7efd2d49c8b40277fce025aa75426a978dc37514aadfe440d12cc727da04d63c8e9f010b4b0de10d7b1ba8fb8cfbb45cfca7d67573794d71647a91b3e9e334c5e8829b103d9db9041f0db89045a20a894faaa72771cb3b70603f84090a0ccdeadb3492c43441bb91b6721cb26d1e589873d72dc60a6c62eb938889632c18285369a33ede1bce2e5abba77a4d15140d563665864ec3f8acea07a9b392ff88d8cb3f2f88860c1d501c2a886bee5e7bcbaf04cc9d05e56c24b676030ee676939962fac5d80b85cca1b3858f9141830f870281c1fbfc449a41af1759160721ab8f6f583e3f71fed412d865bc253ed90d908724953e250a9ed5e4c23bd7cd89ee327e52995783edbe2c40fa05742ed189dff889e23715ab9ab455ae168688501b061e0a3f84d1d7ab618dbabbe0d7bf7bccf3be9eecc42bede4f9381e1512f851f8b835bbd663fcbbc38d817d304c24ce9d7c5799f73bbe8d418fa846ee94ac3f1bfdc4374427d283aa0df5d650e559afac99cda2bb97aaf416eefce8f36b0807fbb65feb429d41599e88f8b67b227b549d890653d2a6ee2b20fa8e0c480117bc0097a4993336650265316e28b8586e172b439985c4071a72858d88e12b0e3c3a504e06a92e257bdd76eb819ccf6873bb28d74ec207874390ff591c477643ae1e4b0b34ccbd2cab499cb16d61d749df71f7d2ec0e7a56a57faf39e0e958fa3ddc1a93f2296f9a4209ee77fffc31069efbeaa78f6b4962f55ea0222f3ffdb346c27db6356092a4888d23344b244887b6b5d073d32bb0bba91cf06482eb52e99d873012ab7fa80f3766a29962474e7aa8c31d44b46170c4f5dfc01749f99f2f89f1cf3051b367dbff71215e2fbad827e96d017a2438532c633236ed02bd755d51f1312b77eda6c43a5c8ede8f3df2af68fe3927f15c16f4eeea7c561d54bae897f9de0d5d6784539925a1a3891ac18463847adf7ffbae85863a53e113ddcd43247a0aad551cf7cd08f4a1c4d4432c51fee3ea4e1b63af12361e4b14a3b221730607583b9b86ca48d225ead2fd586a1baceeb5583f2fd677ba26b7500a2a9bc2a91c12237e1d98d5be12ccae674813ba5862082a91694a6b1c15406b320c6bf8c5da4e219c759d7d27c9fd2b63ecb955e268fcdb14c28adeade85e500b6deeaedaa8cac6e11fab17ea3055ae46276718d944e6246be1779b7188be41e06fab5ef6946419c25d3f6d8d2ac67ec9199308fd2104bff86e8241346057b07239875a646f34570a3420f8ecc0830b2d0d62dd26734bf2215b8756d7ef160a788bb08bd0cbfdca0bcf12906dbc10f14420d4d1fc5e5dd46f567b0d74c5d3eb4668a84fefd447acdf2ac823adfc3a75f6029eb3bf5fe0521f5b6c662d4f0846ba4bdf866dc7910f48e6fd48288a91e423079c24574aa25632e7a73d67b1f6736328f8df64aa9a31885e7a33afc7a13d429b8f74ba40e582fd668d3be914441d82d7cc2102b5aec2cd2b7dec04e6e30ba8360553fd3dd2bbead28d24a52ee77d254b373065de14ec1430dbbfbfba99f40bfa5300739496c2cce046260f92b96f18fb366dc874bcab67bfabb025cdd7571310ded99829d2c87c5979ca24e7274e97f9266a24818af685386d3aed058bfa7ba01c72f98c6b7a80ce0e6f5f788b92240f5702b9bc25a94fc7137e929ac9a5c6bc96f0c6041b5a5b1186f9cb006adb05fe6ab339b8086abb14572f2749658c0c888059c8fd742e62058d98d8b7685bf104eba54930829d8b622c940de1059021fb4888f3862dd98e6450a54d81c696205f74334f2c1b212d1dae6ac1dcc8cc438ea45b970d87c1be4943ab3149aaabc7d435aa42624b86a2bb45ce2a88c0720acb7204475ef55baac0992793ffea06043df2e56bad7c5fc9bed319571eea14b8c7be11a42402ab525131cbe999f685e9617bad5b7c6d2260e4fd9a914e58f290ec29f53668ffa2da24a4232b3f258b5364975a776acb307911fb868bc142f3376a4c101cbd45a2c3b8d48bc03de09b0439a961bf04150c1ec765346f682dee5c5b78eee6adc50c21360db8f6a03b9d01961d14176a9330e439198c0abd429ed989162e9eabc9254a10f85bddfcc7a6f75ceb56372e248fbb0481c3c32eeb13914768103c99d873780269372f6d99b88cfcb50593b8b2a8804ab69f996281b49dc879d05644aed08b074035b71800f6ee2db78f335d07aba58f4aa4ec9160a1211ab781a1081eaa3e48e79a994e074608d71f7cadd84958a4825197a02b4f86b3a8a5c8f9aaf4dca5cc18987480019a7c3cbcdd4f7f461dc37b178673e468cca9a3964dd796f394184c611baf98342c97e479505011d6044632c622502adc66f8c44404671c191be6e3204082f9525947daeeada5da14c5485dd7b3d2cd97e13eee0cbda17fc992274945b89c67a7abbf0f4a2a5495d1f854b6c1574b2741210633fc2394019d1704a7ae6d56bfc9f34089c0f295dc13e3390bb1f3320a05766fd3b95d76ff1d0829ea8f5a782c29f694a5332912c542271f434395196a29a9898b68a69ea990e7b3faad642895af64208a89089632015a7cffe49193737bc92dffa184623fbb9b1890549002eaeea28d46e8cef204fb566c4abcc42aa4dd2d6ad3a2327d5ea12b33bc822960a9d9f37afa77a373855509f2a9aee3fcff26d2cc7c58aa112567dd2670f9915b017cd0d942a03afa2c0567c3a532f7fe45dc0e5fc40016eebb4c4b00a0c84b94c468f852ec2d5330f5d0898403a6e7c1784918a8966a0c52c523385051e4c6ac98c171ca0ba7369f0f6100c5fa8d6ce7c2f80a66edb7e7efcc804bf094612f1531fb60f66795b8ad434510a734cdd2025844cd137f48006722e1c6dea82ad031c9a07ef9971287db2bb7e1c3fcbb80b2dd1adb54361adb3884f35c74867ec3a17be799d4c8fdcb0ba8568bf3e8bfb747dd776acaa0e876ed2e9a751408aa865623d66951242576d59bd27737942a3aa427ce980269789fc681085a1ad72eadcbaadcc40cb0bf96033330669077574a6b2c0bae26bc3339dac866ff0b4e12bd856d9c9fd252a421be70a02040c41a1041b4a168d5e9187a87e88738de1a2a63e0741a1acf4cab07d413ab7f069c6365636739b01b1ec420529d89db0e1855517c403e4f7be3a33a61704900b043212d748c239a0b3354a9b1b8d39b6a3c83938800f68781087d624c740ea37b242ed2b63e7f22b95db999e27fff56d0843c76a526d92f06a9f6e94a3a899e0dd8e073fea2271adf413aa9d6cf5441a127eb68692cff2dcd63dfd6094d846b0a85d2dc19478587c566211dbbe16431d21472ae093444842e567347c1396c0687241b8250f216188d33cefb26c6145f94547351f3b822ebda8f3b48457d2495ecb93b9ad978bf7af15b977546cee0f71bff92d62325c4f4803be156121896b860c4cf13f1516ad702814c68c035ae17fceba0db234a5d6b29705d7b5903a5e0c300ff2b130a7015caee9246340e90a1a19e4e6ada7c724b7f02ada2c718df08e94daa4c55de0d8fe25f5a8f819ff203e7932feeb2b5c41281c95f461374804d0b0436129a97a28437b1f08a06af7be53616d35b535479334a83d64214f0c35c5bc2e03e2c4935b64c32f6cf91b4425f9953b4eac735455bcee447cde25b141035a6fb21096b8072bddec2949e75964893cb730f8d252a927fc004401de83a592b4f636a5c653e3a5f59b1ac02968d469501f3b3a5d448d27ed2b51eba8d195d55c124986891d6efb63da09824c205c5ce29eda793144f2d883b9907471ca03b337a2b99cdec67017a0b721db231939b8a9c1f71545cb864122b5124519305670c61c0fcd6489456f02c07001ceb098200cf93161dd38f144d6d951728d0007869f7f48c464f6ce73232e7544aef8e8d5fe8f4bce4c49f617fda33debb9e24d1fa24f3782c740919ce3bf28e36ad82255ae235b41919d4661b0d26f92683c0d741569523ac1e1f52acc93a203f6eecbee911f3020cd76a4194cba2dd5c0533918c11c263d22294a73606c8034282197a926440e4e2d3e22a014e0c0c933d021f4d8ed3f928093ef4b51bc60e3aae0927ab3acbc3aa31f5b9c5edbd7542c8e476d02875767c9acdd14ab643260d846f8898abe0a37b360b770ccf3b4f99b61ef72f7d6b4cd3b4b3954ccfc62b484391616350ada191c6e750cdd4f0777aae905c22b70e1725ae01807ffd11c60f5a4b1b77a0dbeacd07efd67d299149b199e177e0b9ad0815ab7bcf04e3f273e3dc0a0c265de0cfeeba55d98aea95f644c9bc8637da0f32040fc81994ee658a92b5ab3b780d67935b709aa146f1d553d57ad8f7d59a0b8fdb7b81dd96c9b0b2cfd434ea9875c966fa0ec0fc20200df8426a29b80391e601541d8fc3515d2380de5d98c98053eac43ba94c604d755290e1c7c0aa9c47ddd9370543247397eeeb3d06c00e94deb9918b6be11580895ab200e8a6b7180128129049fd299e3f6566676cd10dc2609227c6a337fe60abccaa6f1afc467fdef262a93110016dcf19edc88b10ce11f4e8820ae0f1b4928e4be425ef8b6fb2e98fcc865bc7aa5e7cfdac9e2f933f31b6cf4d83102e649e7c066fe22f3218a3dc89a568f530f191e016abdb4c4c8f00d80895af03456636fb46ac08f608e4ea91cd599346ef91dac817ddbc855d05b50bee2a95a999e31c7301f7ed4ee84dbbad87e3dc907f27e4f97dcc6b75b251541be7fc2252998bf255b300d8d57744338a84baaa4c20be2a64da6b6ad01baf4efa40cbc137b2ddb06cfb8e95e42405b34263f60cac984eb992e418125f45cd77eab276c3a0fd407e37b1c137c7fd2341337aa3e7ecc3e3beace059d804ea7ee953f92a89f82856074dba28354b3c27e9ce1c47cabcdd4b299e3dfa389f0dd14f129f5e6d245acb6a54f4b5cdb7024e3335c3734dcf37c9d103d89fcedb0193e35c5a00af5d701c5f3c7346402783989f0869764233bd940f2e5f981ccc2435665ca90cab235f122e419eb2ac99909683355d83d78f1d4435fd2e74c3d45a98ae6c5ebcd9b7f7795fcba29f0ec820c2adf559e92f923b3341d22f3991d899075d1fd7894d201e2658a52ba7f3da6d1e6b5ccb8b78eea1657fa656b6becda394034cb2197a4eb9610a74255e5076e2ef6b6b34d87f7fe9f4e8305f8741eb735f72bb5ad72f75d1f13e635b0b1a348f349357fa86bd17849231a6d5f51a87b6ceaae456719426355abd54904d2f5b6039bf1fa75fd017c2cae3778e8e1026ee7d7fe63b301cd9b1a09358096b949768c4d9aca108b8699dbc40ef83a7fd273611e096981f0d6568a0e5b09fdffce0e47aa64912f6dcd2deedab0a0de2f4ddada87e629a711379c6f2163e6935d25143b865b8f0f597bd6189c4ea54a5ed370bd4f16e2411f86ea86e70a01f1fb1cde3085ad0433add6623c10a1e8444e8ac46f63e3a99ae96df863af7b5a5840b4b4394e2918aacc923ca3c7eae0c71f9d59807a20fabb5d04c40294c6beeea793323b6aaa1c172864980b65f2ee64363447d3abffd5b46c01327713f8f4be1b5093b496bae65a5710a1d57f6410672a9b7812c2a5742fe023284657c6f3983e79f7d2534c92240d10b7f5f5445b4cdd72303237898c7533df1d76327de3279345ff3f6fb5805004bae801e579afe735919d92a236263418fe1f6e72c89f56dfea2bf2bdbac795a42a2488313b3c9fe7694f9025d3898498744b48445a6bcdf1ebf81e244e33930e3fe138e6e7360babc3b239d1f361dbea01032a3807e32dce0a9b3d29f12df13c21bb03339ed900f23eecd2326b7bf95007ca0047e01506362abe26c003ba6a3746b4e0a8aa089e24f198a8fb079ea64cbb5fe9d29a552406b83d85923bf47dae788ab468e22f2dfad70a20c1f580121e82d3c28654689b244c34e8aa4d551cca81ce25aae96851f21606496ad4eb0396a3d49d7c1b3e811ef54ae19ccc3e9ee9a791a1207b4d39bbdfdd5c238cd5a4044851980bea19791c108c423b22fc26a88e459ff161955c302fc5107d043050a4c0f8c73180d378ed6f7ea95571c618e080330f841526eddbf432ca7ec2b4b204a354fc3260a12e3f720503d4df31df5e65de64663a1c75defd401155e6c88f3d86eb14429fab62d53e8dd4622b490f0ecccec974db90c4daa4913c99af5f0b1316ea742a1f685d42f5d9ab768dca206d7014d2b0cdf420274df66cd03fcbcb8b8cbb6089fe39ec761dbe6022285edf95848e40dc3de050e8bdd13070f27c792cbcd0e9fffdabc467417d077e42cbe920f325858f779b75a102f4c6802681352174837e04d8ef701de0f223913b545632046255401e94d05bfa89f2c3ea2a5c3bc8a8b7a21df58502ee3d4cfd6cc50f0637da6f09940a7db548ed60be7722bd945b2db941f7350231c6f651b027858e65720ab0b6658da935cd076acb2f4c66489f49b78a71f887dde95e43261a75551c1c710746126fa1912f30a118966d9437082fcc2cce9ab59798a2c8b224363026ffa36efa75791df6c55d7ac6399c8366c5f955a1ae47fcfea8b05d7942c8ad532de04791a95ee0e53b8b0b829040b2640dda82cb5576c77e4e86183e744dccfcc76f4cbabac4cd9391c80f70996a3d031c054fc98d1d0e0dfb5657b2802f6ee9ee2bfb991c60455f98b8da08df7fd72bae4f0f2027f83cfd32412f89906196b5f85875d66a8f3dc008f40a633ca4bbafe650e4329ec1ab7cef15e51117ff44e222692112c557bee64e5cc4e47ab9681bbfa071365bc31210abf272084f91c5f034e65985a8ace87fcc1381e8f451fdcbbca2c19c74f10f9313394ba88c131df17ab282ffd93c085e943696d61b114b8860139c12a0fa904732b564f30bc091addc55dfac69e7780b830d9acb25cd45b3b754f8645018f2b9d330b5e44413408e44a16d72079f2abc0c91c68ac1dc82a88d230261929d96bf75f8515353308541c23e591b7a119e1f3474a8ed795a1130a8c5524b248a06ce11ab2601e89eecb51587cd1f2c5f65259ced020bf97841cbec887829905ded2fc279700a1876cb71bbd2b46667afdcc9a1af71e7517db86856d5ff50bf99571000db51fcd63f0bded9d4abfc6a047403570b041138377a90b0afa3aa315cdfd7a5e7cf8a0a0e681d622e2d3f75625e5270b3f908f380a97033977a72b989f017facc0ac8ab9cd60844de393a3c516fa5a1271b3dc9a6fdd5f8c59bab91eab7c26f471d0ddec10cb26f3740c466d9213d20472472cbc726fc7e2bc574563b917841e7299da6c749a1a495ceec9891ca2370f90e33729c125f81227fc5eb0b1d0033c3352ff88a8cf107c684c4757ed023c8355b48ffa7363bf63f9f077be9e5dc92531f84bab1c25cb41504aa033f71ede2629ddb6be3f0d6a7ff398e5a9320bb6d1589c471aa326da0c588000978a1da11ed24ce6e197152263f905e849e15c4d76ae575bd9b670ba50e1796ba0e8534124194c40b013a6cdb350a5b9474e4f9f0eef8fdf6f04958cef47e3db3943e42df58c1030ab9b5cc8a6b52c43d764e42ef5bfd1ee4ea8d9953cae4792dbe311c8081630fa629e1a0fdd5e15b21b9208e30372d32eb4715feb39a08741021f205946629b41b66761f6df754649f18c1a3705ad18644e14741df4a91e211b91d2fb9ab8c20cf7a86ef7c1ac453e2b8a6637a3040d6eb5be0365e6b318264e474eafd16398f04dd930b41ced8b13fff1fa857b6324daff88bae4ab0df34705254a40c90eea9904732fa130c36cb7bfd7712f128ccf59d6c00afd5e980dbbbe77632d715ace183d4a0ceb47e9a3e83ca980a8acbddf102814ceab0dd0193d66b37cb9f13de3e0467fbe94db69b98f2c86ba3b6f2b1d88503d79e4fa3b09ddba0ee12178975f6aa3a0a95bccd88c65efefba280a8a2a259f99dbef7a2c54a3769a6a20f31dc550a9f338a753e8f5a19c9d657d22d9ccc969f02c603ecb604c3db0c77afb5ca1fae290c49483e7994dbe8b700ba7f8962eba03b3b27ca28277242efb901dddc24e21962a99587b3a452da6b9f647e90d1cd378ac7d862704380ee99dd44c5a49a786773b644a8563f37c2588f0b60ffb9fbfecb7b605e71a4fd8e74286a1f64876972899a8b7ba4d60a4cb45d415a53d718699551811a06f516edb88682f9d4cc58c54e34e8e6d2cf7acf2bf8a01ae91947c2b852180a292303782d3e5f2c0c30e98a6351690fbef3f7a765ca2f7c9f8877fc4239195004d4f1a7a4e6f198ad8f73704b79402579388a606749112375553fb3e8173efa1952ebef4935341dd2cc83d3da67657637bd20f190197b2e7334af176bf3d7ec4edaa52ffec273e2f4e5bbf3202f3801e82818b6fd3bd07bb122281b5a9a9e115283cded76e166b014e69def047a864607e64194243f7950fe45c7198bc38aaa3c0ad1d65e8625725238b9761eb31df10346bdda038c3282392c0133fd49b2f38a18b581adaf21866dcf734396f020f9954f16ba92f84f6adb95e0ddc65943c2acb4d7905fa63971679633a70776ab0b78cb0797a50c70e83ab1d4ed822fe72b453b1803a40ff7aa6721e72c8c2dd701e71db9024b5304aa01cf1389d29732848f6eb9d2fab1e8e770721bf4096090943b771c4fe99e5014e7854c76d3fc91a8969a1034cebab0413987991b2afe866f79f389f187eb28f36333aaa643104bfcd5b6d66c8b96ab4111c71df65adddbfeffe64017255235b87c457afcdb30e7651e3b59065767d9ee712b6854dafb239cef5f7e12939ff5754d2d5faaa7ccf2ed98ec453fc8437f021c74639f0cf55cf987471fe02a38bf5cb08e14b33e3bbd2a6bf1f5a04a7642e23289d1d0cb37890af8242fa2481b4f51de11407d8752c0a772df1f257adb74f8c42e407c4aef07a107b5d89f0debbd46293731f04dfe885bf766b91f6c4f54117eddf77fe0a33d14148b997a0638596f52b50468fa73252561c155ef285915f812fb2542a398fb2ad1c80c3ac7e7596fd6ed1201a0733d77919ce8b8c0e9616fa96be7d15234f8b5b9a13d8e079cc1e169d483ead124751fc631c8f856cdbb512167092410c7059c5a3193da395aab1a87136b7375fd6f116c9b38175678fb20d78e3930dfc16e59642a20c605ff526c88f1a90ca10313f906f9a4fb08c0a7958bed43b291cb7a89da48b986e4e1fca0ef9082681207a680d0ce1762fe94ac85ce6b8974110a1a84c49f267a7f171866e2066c65e14682020ac2c3fa152b1c1260f0605f520a111ee96372a07c1310893a06388a8d135c00877bdade43f4ae6e62c767afaa5055756c61b2768ebb3cfa1b187c954a27e2247877248ad85d9f152a35d20f60cd49d77e0c45b38495433fcfd8de739416ff3db23c73b466dbae8d96b8fb0f52e9b59a5ec991210d86ff5a9e6603efc89ea4c95f387674828fbb52d3eecc04139ecdc3162add07b8aad9ca8e446f16765ce9fbed6baa6754dd336bf613f31e0cce5c41322e3af79a09c1a99222b3bfa9311bec5d5e1548fc56dc7e95a092ec749b2be5b3c5092fdedf3cd0e042a28f38826b12778b78fcc78bfa67535696e14fa5faf1fdffc14cd2b79fe529e33e449edd9aa8fa013858a2de174b17718454c5095c6c1c565fc92924371fc2891ba949d41e51ce8241c5ef12514cbb6540966e936f41a530ae4ddb6a398fc90d26ee87ee6c83df0afe85a149ea10cf8469a57647b2ff7c5720c405fe528e24b6b6a643d700163029df7fddadfd402908a906454d4d1f6628ef45f634ea1c620caa49a309196a5bd0a9442ad42590806f2ae6fa04762cfacd523dce215de125dd0763528237af17cdcc4cb10b1498c989af150a83491d0672d22c5474782d9996e5d70205a27639f7fffa786fd4a83fabffeeed85747adaf14c68db83262b31af3b7c477e5263619b7875bb3428439005c90087680f2453b990a53c53604b814db4e9972bdc1fb0f381d4d7cf688457d79547bf294a1b46107aa38cabfcd0cab7f7f82d6fbd25bd770cc84b3d6b076ea3225aeae9cb85ed8558c805cfc2183834b73cc921374f48cd429f885380861735d9d6a2bb36832379f70bc338e175a8c73557c216514b4c44c761c737943b25a52444f26330d1c53522d115b779ba1a02ceb9230e5977fc947aff2c18c341208eab2aeed9636614014f41dbf008b6f27b4b7c0a217442cce1f6580457ceabe3bc3e27bd66143793146c5f3fb4aa213e6b47822f2760cee3638e5c02f6fedc7415f5e3f87c0b8ee730a274a2f6ec993ba0881bba7a31342553cb0f8c71441c9b03079787708c6bf77c98cff7d271b86f6a71d1779ae7d73a46ae1a5d41606045e7a97363296f4310bb0b99f984bd77916c022c07c49ba4367560f7a566613bf1bfcf8d21b62140e05173afc3736d66db73937117d07e88bfa3f6af98d58a9c181806a3f59b99e9d7e5f148671f536f8b408415862aa68091736623292f90e3b1b7ba2482019625103cedf4daeef1ce907512aa7c25c6524c4c58a47d977f333ad8c8407c1b832b49852a581bf628a24b61a582855bd68e993eedb01eed952b264746f382cc1f21174cba75a72ff42309ec1da6baa4a137ad74398aec4be464b7c08af80a0e753392f703bf04106439195b82df49778fd5cdff2b3234158d5ed6f243660d921b0c614881732e5000899c31fcf6de454d8010279dd349ce2057a8d9e3c8344a7a24590b4258756e5ddd3cf46de6713b28cdc6220a875b51e952cb1dc6b20e82d5f99ed45c4b7b6819fa0cd8caf86929f082272a8618fe0717ae0297410f0fb4511da883a42d10c5112ee1e44850f2ee32f4eb9c84e85588367255bb2a0a1750f520ffd224484b62e6c2c533e7a505cd45c5bce2bd5b320b48d4dbd305eb97bf8330bbc6ca2dbfd3379f37b150ad210cb203c3e77193599e86a38f1aca30d396176230903e4bf7e63874492c1af0cf81d77c92a8418cf2f59da37865cab71cf6596f3f8331755265b3cc75e56f572737659a1a67e35bbbded12655366e62ae4e094288d7d91f7245d20ec22d676b2ceef9204f3c99753ff715051bd709154f12ded34993c9be71eaeb66e1df32dddddf10d019448ace1f3ab4690576f1b3aa7ec9f86403b3c2f328a70cd03950c5dfb2ebe095aba581b8bdab57c5c5c0d2a3fd56373671ccc603249fdf95562d7622a96a9e9fbbb495c305e1a40df69221f131721f35e4fe1405559cbf017bdafa0b04550b6de38b22442065058266192a741bcf4f0fdcb72ada1182162b28e6683f549e1ce2b2a5c21a17c4f4f968adf038c6b17cf0971aeb0d60ef9cd90355282944474e67a7fc9b1b4c99b9d771ae62d61bf05076da37a66ec64460299761ea556fe8f47dfc0a9bfdcc62dfc0a69b7cdaa0b8c4e6fd7d46f073d747944b2d491f75a497d6e0807bfc3842ba9f4ca2a40c75db8b2546d75e6cdb8a88bbab94bd35505478f497c6695b8375de63bc7547ed8a0e91f3b3117a3e3eed2fb56f3561365e80ebf39d07ccb4f7ff027cd5b2f6ce783207cceca4b6e895d362da853cc3ed163ae292be860f51d5056b6ce6d4625f2acf3660f08ca757a0a61091ce4822475300b7771a60dee81ba28c872b4a8a05127bbe86abd3c89e236f6402f654517c390c6296d3ed580b0e96efd1d9607a12c835233309e05dcf7f4df630f026ed0a6007b53833cf55a450dfaf0575aad60aaeb24a2776927d1e1d189d1eb8da290f89ba996ec4e4be56d9d5a2aab6d37a9ece463a21747bfe796673555c4b585ea95565ed55c6254a5ee7d8e5e9337a685978771ca6463e1d9d827d4b18a9aa402d02de0d4c30eedbf9d46a0e5f0003a4846e6257d898f9a751dd483cd209a98c26c72b81f23b14d8fe748e58347adce8c957ba7021dee148b05f8ec3bac61938b2b7539cba947fdfdc981f6f7302a8ee240ede27f96768dae2da12a7b93e69643253d6684f40ec424c38ed74b9f5c3d0a00e3a0a192df0b0ec74e32c034074a5593991aa55cef57a769eed7ce49ae565659f8986887b7de2f539fe7f186c853e609ee89f58196c9bf2604bd266ce849532bbe47de4d803b5ab2aa890946dd81ab727ae5a9f2b0feae58f2811e0f4f5a1b352260acdbbc64b28b096512799990fe98849ec48d0de167b00eb8a26a3c3cb87f62ed5923863b5d97bad0965c14527217f6727954f27f0b0f8783da4591531bd56ef84e2ddbbdb3dabcea531b176af7643ef662b5ae698e2513a90093e3635e0a9032e1e2dc13a49f7694f0cc03c38eb04329978bd22c33e77a3191e2915c63f49e0803977a44659e985224564f8cfd48ae87844c8c053b445bb82dce10fe6b6b3ca779ecb6bb055a2583bd6b71955d8f3fe45fdbbe95e65fe2fa079ad288cb0d7e4bc8789dd2486ab460d44c0cb4452714085a575</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>一半</title>
    <url>/2025/06/22/%E9%B2%9C%E8%8A%B1-%E4%B8%80%E5%8D%8A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a0d7ac7fb61de2eae02adc0b5620ad19a12ec06e0512dcfb340699a13a0d3d85">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e6b9306cd99a79ef4fe2bedca4c3b94085a3e8fbed2932c0767ece642ae6e95e5db4b246d3daaf362154b4bcdb394fbc65d89acc20b9dbb737c1ad821553a735a86143068f3e9b4d2d70011ce99fd86e6c24eb081d87429e70fc6c67128245def228163d2c8ecf937aee051bca9b2f5efcba5d6cde48a1dfff5b10e417a7a8da294ae034ed18f2bf002053dcd212d9a3cd5aa7652b948569783eadf0875db35c2dfe32fcb8327beb66010df26dbb86d4bc5a9ac1135e39caad3e45730aa903d8c04f8ce16d2a235d097b10fa6eeaa0d0a065871a4cf4a5be2b8630654cbca30eeec4039a44c668a94689e511523db951418896febeef68ee5c7e283a0a79b4d2095961743b51a43fef9f0167730396b5c0a5760df3f10bbb772ca1bd3a62fd0e9f6881653b5b1023e79ab81651b433c35f285950924f1d27e0c7bac85f017caabc60b16d554a78ba44a80690c6b6fae2c7af78af6d0462a49670fe6a3e29b742ad4bff17f7206e7170c8643ec85c9019b5bf5d7d0a94c30e6fdcf71fb303c541f88e1bc0cdda79d0fdbd47d0072584a9bbfc163472e126b22e580e488659b618093a8a2f0286e63a1c0717bf4667988fc4ece71c813a94f6bc1130fa8b10ad40dbd000e2c067ae598b506526603fc08647f4802a1922958203af4766a210176adaa3c1c923851146f7b05cd17bcfae45921972db2b0404113ab255bfe86f69a1dc6fbd555cdc11fbc071f4771068e37ba4640b0e8d47815052653838c5f732a4018501a43683099e12d9c7a7353c2586c53e610d2845271c59721769f3984defec1f64a95d90509a8f2550e9e6c30791a742490e968ec5de60f36255633214788b0e299adcc5c32cd49f061babc905464e0acfec5b56327c4d430a012350fece52c46a95333968fc6c4508b57140aa48a9b89640f885dc60eeb56d34048dd6ebe370048bad780ac4dd9aa80d7c5659e3584dd8f2cb9987b76880a41521eba3fe7d744cc950c501b40b3a8477391f9dde43199a49ebe03849912c858654a1fbc1fd33b2ff429f944d8bda5ac96e3e223118387396a2fbbee4ed0a5edd4f2004a54fae61e943a3c7a52285a673046e12e3c92a1265f9b730560d51c1338190fd80eea789454f109bb2359487ae8f8ca52e0e536d3e607834f7730ebf9660580c987db1e2d6d517e3c91529c8ad9571f6c5261ce226090b6f1febcdb13e6f25e007ff6f54f3ab259d7358aacfa8f2e88ac538d6792cffcaee4ef4a2cf98a80357ef53f8d4bb70f451b18fe3979c4bf9604f993f390edf1b5ba33be86d0e4ae6d0d56706d8401eb0f13854615d794b4cf20092c210bcf750bc8252d6718f10e06521bc9f1e5b897df22fe2ca3ee905d20ddf8f9a96501392382738611128114672bbbbf79f05f46e28de28686b0b46a7994445dbe378cc5412cd0fa3ca8c1a10b8830bda336a4bb02c87f52cc24673a03c007ceffd414ef29acd1e28137eb758411263e2465d29ff6f5ff09c2dc6aea0ac59c5ae0806beaa7a105512014965f35582828719c18ee40d43951ba89a9792bb7b2416ec0b3f38f65bcddba6af40fe172f689f05b5853cb4d77d1f2d5be35388fe40a0b811b65f95c41c1b4d1be6a27a410b36f447164f57f7ca043cd1f08087f65b41105a041998baf4e074385acd3394f397478346fbae9ca5eb37d64c12794078775dfb8b61420ccdd0abf70475534b635226f5e6a33599a514b95f0ea0255f08893b05fb4bf0a5e51a44ed93dfdbf91efc42dd3d1fe2b8e904bcc34e8c0a17c6807338cae1ef893cb9bba61fdbdbb66798c219264731bd02d4658f216a01c39a043e6d985df4893de8583db29f5fd27ed8ef1ed8c1dff75122cd34c19395f3b31ac2ffa7c1c8e0d3add966c70d99f53a5b19d17d294bd3801ba9532e502891edcf58a695eaa27dde3fcfcfb2c619253f8b8146932c9de380d7fc754cffa2bc070e44fc2ada9881c1858a96bab1370ec1589d3407a340df2255267b5f8d4a8d822ed0dc798e64019f00bca2514d3defcfc1432e68d2edfbc7a36c68c600cd1946fd8df9b396b114e1938685a48fc5df25937afdbaa1a60b799b9951d339160ed95efac18db6a9316c8210620ce7f3ca78e05ba610dcffa27cbe29d905aa8af90c387559cf10b5e7b5760a5b3143c11057b1e98f3cba35143651afa54def3b6c4090b4743ed5af7cd916eca0c7f8248e99be4b1e765270eb65fb0d890805e1035e73beae0257db091f4c3584b2c5880dbd9b4d9c6205f4a5e33a2e434362e19207dd757a38f103501c6bbc351355af438156f97088daaa2b38b71e1ffe2ddde26d68aa20b4a5745a6fcef0aaff92d426868f7a7b57a9d5c2d0366e6062c844a004c5db02d4120eb410121feab94785473287ba2e10af1ec27447d1040e01fab89ecef3e9751892449795ebf7d6b381de3db7a78ef74ac527b080401cb5733e9fbd5901689f197cccf62315fd95d0caf132309af712b0504596bce14c6bc7a9872a8c16d190abb003a9306d66dc3ef0cde19244f2c24c58f00dfc143982d9d4ff614678964048ce068799b8a0d9aca1b7aa2acf17fda5735b3e9cd33050df8f941582c70fe7a3db53d33f14bacefd1d17bed60e38bf8c792c77ed5e3601b6aacf4fd4a8689cbee064b9ace1be6d4222910524b2cba21078112b452d0b39f221b23e0c908d0fdab8c8629d350a5f4c23873356d68420616ca0e978b1e2cd77a698cebe70f0d37c2e016f417ce2cf10a6be385374a74abedb6a2049812a5180213520889949faa007445e36023caa2dc26a7eaf5bb8e46574cb7dc85eada5345950f03ac3a9965690b29a5613fa0709990edfbe03805daf7ce7fb744e737353252e1c038fc4deb73ba63a71ceb69f1a4b59d653a4f8465e68eff7f8c538f3a84f2af8436933cc323397adcb1f7a66d68b4d4ee63b29bd76ef39a9038921bbf34cf283a8cfa308c86fd354eb96aff812d5aad6ba33fe8dcbb976e0ca32b784a7464f7f95d2e8293eb12bba0d886e5631b5a804b5238d9dd424c11bf911ace0f80c738a3e30f65b2ac05f918725f9eccbbc30ec7c8bd7ce62659022a32ecc8e9cf60a97199355a5877d0050271b90d362baf9d51358c198bd2bee06888bcf8b4e0c3b5ad2a3d4373e33dade0ee9fd51b300ca214689035f28c4be1b345619389eefe65dd63f7d4b7dc350376a4c14da9607d9997d7c4255a2ddde48e92529e0226dd75ba5fb4be85c7ba4dc451da73f24b4f0bed1d2a7b13acf5548030a799b3d08c257d2e2eda269239cd384c4c09f0030144b225584aa4100bf90d58537151c401cdefd8ca2fc602b0e803dff166b07a6e46e03c57c304cc27f5b87062a6b229bd5b9b8af38a7667bb94f5e2e9a6eb6a2a671498afc2abc8c8a16e1ca5abbcce8b3bb2156e649f34f346c72738dc155aa393b1d86cd4b365ac1feceddd02f5ffb115839d35c18e37146b652895ab6a65920442fb59d90b020dc1577db6aab7519ece29ed2b54f8189700ef6890554a4b108f6b9ea5feb0b4a9760bff351fddd0bb0278463b4cdf6b3ce2dad6c4c430962b19d0b06ce363f98008397c74997b43be49ffd263a1b1e0ff993e1194dd9817631c7bffcc4528c3dc9451e1431c0b40966faa89a5dc88e2574db2b626779eee77db4d1050671fda374d15a7aa430defa4dfba66fc9ee436f4744f434d1c0ac9804949c60112c29d0fdaa41a3bea05443a7f04ddb611a7cb3e7fc8c8db429bbcd6bed52c87b1d87a31407fb656a6a22fa5b0f4b60fbeb657c502c1a726427f3e12f29a1fcaa5ac874de5d2697f63a1862ffeac67b59432f981a9be47325a54f9a497644afd68a52eaa5154d9c97bc570ca52f5c31cbff2240322f2c76b301fac07a8349885b9c381d599b94bb7632e3786e3612dba3eb6e28e0d87d09a502b8af82f16b48a9d1631b7c5c498bca0e570b109d02f74d1993a16218a9efe1a03dcac5d1a903db5eb8436285b289e818868d1fb373e75c913c1ae03fb0add57aed540bbe8cf54f455b0c9600eef2e4afc5ac688a6324bdb1970469b713ed951ca22da346e8bd680b4d12d1ef962977f486c9a72a850777a6c4c200a93da25412c4a7641eec6b514b2850ade42475335c74fd2223158836a5ff9114c4aaeaa1d1e09ec1ec7935bd06cf0659e6a32e97cdcb6e5674038348712af536ef163bf61de436d5e15bcc082fa6827bcd1385bbda3afcca2b9675a4dd41fca60403ae322169373bffafa78e29bb8d652e0a679f32be0706eb73f849716b603f56d7c4fd3b1482983bb9f15d4d1cd5367935518c747cf4792604309acb651e0afdd36de3bb5080d6707d4bf61932de6efa3c1f3a85e2b6cfe1b1c5d6f1879b2d805a48c090f87d98f28ca0f708ba7c22f6c291249bd989cf9db89e5ee774836514b3ec39baf87e906888089f394ec428d769dbefaf7c960a94de312685673f04e7b1584477ea611a3aeb31b025fb2866f382dce5e3d03268c8cd3e3cde3042be993feac59b4a3edbc861bbd28e3f10b4cd753493c0c7031c96b9ea4ec63d11c4cdafc2b069a06d6625c401db120a4cdc1c7461e6641cd82edf9fdde916ed3ceb9a21fa95a86130fb80cb54ae54cfc9e1adc388f5ff8ff980699437f0a6d41b1a5ab0f5997c24c06646602e3f1dceeeadd0fb3395a07c939d1b98261be8704fad739009ba08f3b35a8bbe3ab121c6b3fbe97e7722208308d7e88d44492c3957e4758246509373ecdf4d410acae4d51a0c0f8213ff4401b92073ff104b9950f219bc258c3b52c5a731a011e5dae93bd3550e3443c4579b066756a773fd45e0de81de06b0581a94068ab3952c1e99a5f55ed0000552259f472c0cf796fb1ac8d70fffa481421931b4be488e1bc873059bbaab09d1fe3b3e5952e72ff21c8340fac58f31ae15c536ebcb18d84893920db2fe828cd280fb0496f430450b95eb1528bbca18f18db35ff132bea5ef9916a87625f501e41221f9c60bf78d9ebf2a32f0ab7de2c4e3632f8aca9e62b2536545262f4b1a22ff8dc26dc7feeb42e5ee3aa053e0054b7186b490c4c0e782da68a089b79f1499b9297badf95c7120ec77b46593215aae003c00ad580929aaf0d74107ea17b45cf26b2463ec17f671f4e8912a582fe9a9ecd462d6ddcb3a3927e318f1752df4c421bee756c43e1ae4282a9a41e0e5b239b50da355c8a62037a6f631cc3917e1d7802a9980f03e66390ebf2d68ea3e31569e097f87411fa9de5846521f5ef33b3da88272977fe83c4885c2a4ccc576d7e09db1ce4708f2509b0f4109bd32851230770fbd981ce6c375f49b798009755558440e39b2285014f8d6a58dd6dd137c20b3a86dcd1ee69b44369e338b17f421b27053d5503297c88cb3faa790194c0438231f67ce84631ea893e23921c5b0288ebd3a52ff77487acd2c67015818022e484e94d6a66f9e89e264100e2206fd1a9f844255124f7b1a881e233247a76b09cb8d96adc8fc0fdcfe5f8479f43999696be6586a9a18aa92be99c80d05fc8f7e18e142cccce8afeca77e2adfd97142690ed3123e55df1e4a17f5c2492ca44342b3e7e34f6fc3de2826945814d00b074ed8e094ee974e4e1780fd6e3d5258e0b0f7468ead020d46c00f3682239611e3951deac481e81d6e08663e6e6e4cfc43ac6c7e88168fa0275aae7f9fc5b71ae0e67db22d350fecaad7020679a1cd20cb625dd508558bf13d60a529e01695a3adf4c1be97cc2184a81eb468cc3318bfe5fba2be5b94b45babe32afd3506b84576e26b45692f22110155beece652c4aff60fa61082e22dcc4d1371ae4ceff6cef4fd693186f8d833f790974123abaeb36e42a1ecae71b50a47d1a3b56e58d3738e22836d39cbd47f13000b7c48f2447224300270d75578c499ae1b1fa1afd844a9e05b7a65e275a2de794289c3af3f307b8435bc84575c92ff6ebd15c88a6017c5cfb1ff6899cabbe032004b3924bfd6560721bf90904e0620529023e1b0982929f0c9c97157a4b611e0be05215aa92d0bee293a2303eb6408ac51d87910fecf38f1797838b202a05265f2e9c4b38dc15e3bc7924b2b91bc986f21f62d27a91567ab443cb1560deb13e9d3f0af5e9805aa05cafa2131d52d1eba088e69baf0e3a55aea301e313c4b41c4a81bdfe6c2bdc001820897ef3d468c5cc65860c329bfc6e67c77e0fee480816ee9cb3e9f03b3780daaabfdef6f24149320290ed43361b18e0726543bd5b6859e6e4323171e37d4f4bd8972715dc0556570ec2a223b9bf42768ed9ccdf180ffc63ca614fae0e47320a1840e72a1155fbe123b98c6883394aa95661f65242704d81dab2e0efe0162ebb813dfbd710164436b1354e81293258b7f85fc6774c044563c30b989ab73cd8e191d8a8312ef826374ce8a089b2296609e7e21995bd5d073723be7f095c2e63de20ff14356616729725f751061d3b113714d1530950bc88ed9b168d521674d51461c6bf5a08d5d2f83dd132808dd29d08caef942621cc4a57192bff918c2c8d8e18c4cb3f4d737512dd086da52c082eef89f3536aee2ccb5718a5fba703b94f8c8e5ac5b6ba298194b2936818188e0161b3ad6a5d1610bb2caddcf7eff7ca9c3ee69b6467b13312920bbf9fd5afe9d6b0629a2797c45ce47589e16e0fdd99ea40123cdb4ad85d1f67eeeb314ebd2014d959f8ef90afe17e21856f9a39c899907d55c2f8b10c986f24512ebd3a95f8c4ecce0de15aa802133d658318a8c089684fd745b5f423a551839111d10e9ce2c957a13528c992cb2c040ff81689b16d9bcb842484d93a072040c397aad4066b7768cfa6b89d6ed0ec8c37143c36ca7925007dcace547c64420bdafeb75d0d158c4b42e50455b2c4483d3e37ab408157f5e96d9333ccd941114eb8c53635f26ba2b8970702d5fce02e51e68f6948c3d023beefdcd9d1ef7af49b7ea396b89e25df9635fdbaf615faba4fca0de1a3eb03ee7a3add37132d716d86dad481f6c5142049ef26c4847f433078159dde6a3209cc6288f770bb3af34296343ccf5d304170e6b06dfeb1ba7c2824e94cff89c472e50da526e745bc979b0a1252690f2926e3af9d7276f02d768b689bb9d946b7d704853b8a6e2a07ac1aede4509d80db631c7312898b5f65b8b09e536a2b4e6ba9440e8117df9d8473421d7e5375d43b3ac8ba4cd63427e8fd9059135091a4cb373ca1904e8015303f1bdca9104f7c8befdc1a9ea81feea9050ccbd2291380fbf0c6de3136b8fdbb98bd458607833cb157175df089c41f5ac0dfb3874f6ef5e5a3a44ade40f7ee9a44de03e1bf1ec12890832decfb2b81411c39df3dc10770f9b820280877cdcd671ee3e772458881349944abc320d9ac984472acfca2a215530bcd1f6bf0b00c6d4a344a1be9dbc3030d8ada90562626844b3d10a0b2819adfd960bf951940ca9be7ed77d85474ca0046f94229fcba1378f8009c2786ab77fb0dbbdc03c956655d7b6bdbf17c01c862dfbde8ea65a8b53b92dbf0a3b5f5795beaed21dc1d5b994739d984b85f5658d6c0f28866b0028bf0656d7a1e939a48435debfb894c9d406d32224a8f210ebbdc8bca0d0bdd70554d1251a75e28f21d47d94ec459f79e82b43c492c0cf080e2cab7618b3fadc29bf816c80e44797f0759c178419bc13c53834b35d50a71e6c19f0f02aa70ab3b312025598b76153b75f9e08ad62bed8aa1913f0f5936ddd3e4fbc9038d05f02fb579306ac3986a29ddbf6b641bed0e8d6399db04331f5dd7790b05cd06a493ffec5bce9c427310c3d518cdeffbeb14894768f8e96a432ccc45d0a763e0d9e60caf1ba344f869a7a28abd7f68078be0f1d1c8b1afb192b2a8ce4abd34693679b2d1ae5b5084d0c926665edd51bc38a4c641d6400dc37b8f8a9e496aaa71afe5f60b0bc4967d0dd30beb9e30dc8f751701d2f8082072e1cb233a48debf8ad2b802750d76675b0d6b6b20193099206a894871dc78aaba0590109cfb2235913405725149432d508b74c304a30e6fd66f8b8f43d9eb19364add925a092e52729c5bc44843183fb431dd80caf8055f0866cb924442b4341314e790c35fae0737ab8dac026286ee2acde6f43794133b8e01390e0cbeb5d7ab18bf38fcd0a9985b6f9598949f49e6cc00cf047b4c57eeda408a3531362ae2403be0ec42e8827b769a7060a02d2f68f027ad0cff3ca5d5281e66d316515e9c04f868d08bf9c0510b7677570a84e9a528933c6d43b39c22002041bdac096b3c42609409104cdad3090aa8cb5c1db6cca72ef978b50c9f40d57d821fcfc58cc3e5f5cca13522eb4e1b6fec4476bbb46c13c927d3e4377071b9f62f786924aeb68edf4714ed6d2f167516ef0c16171c713cce1830e07205f555186dd11eeb248c16bbd04db6b0be026897791e1c9bb4700a1585de75ce5c230f464ede87876e96ab0b8a42d5a7e0a88266d4ed967948c9ccd71685efb67d2da3d4a47d716c0a4ba3d83fc97da5ff9aaf05361557c0209c87b1daf0ee4c33565892394b9a0fa9eb1381cca158a39d7694f03428a1b0ed9f519223fb98ad6f60522953ae281416090ff30a3d452d07a6074652df62221400668e6d6eebb399039196a725f21b62ddcc3ea792c9d983436891a36255633f65dbcaa5ad112b9be1cd5136316c9ec6da7e751bc69162f193c8150d9acad6e99d99a8b2d12ab68c48623ff61368d96135e70caaa111ad18232fc1b0289c0e635268c20626b47c110b72a49bc5ac77746d0f149f8a520e5e42770f794e39c0e65e911db38eafaeeaa81294417f9b6965e8504b5ad1d01c20e79f27a41330bd3dd4aaab43162fc16ce579cb9c447901eedafde0d371e3aa6e8b37e98153e432a730903642ccb24648e6d9531dae0e11b60dea413985863504cc3b9622c67169c2066698701d943df04d1e4b363493a9c6edb948bc8d497f8fb2fd02603146ca5cffde1b9b7767b3f3bd998c5daa01a8f13513063630f16fe3b0c42678fba3e7c3f28840d2e22ff7ea09a6a542f20fc6a22706cd668643cbbc2d2d90c7fd33a2f5221c3a63d6349528780af66e7915b5ed0aa26c4e4e974b5b9cd3566cbb6bac1ce0d8235cac6f751df3dcd4d4fedd8288becd2b386c4c196ac79ce46f3e37b8e4b555ed724dff20e61a12b639119a68a5836dcdc31a885a60668e8789cb1d64712031c528b2c9f51a1795f375764f9aa446feee63283837e28e2b37eaf9d697ae953645ef59d6f75c1cb35d37bf83426cada9046095b4f435e4421addf027953ba141873bfbd62047427ad71fdc1929d00251de9197ee4d73838bce6fc3e49cca3fc17fdc1cecf0535032b03db872fd853757a6b5b1baca429ccf685418f95e315ed34a15997a6e4a162659ecb2207182b9e4d3738d07a1c956a4e91e9718eabbd98ed013497e4a79650646f84c222580c2c030cacada2e9655b6883ffc4c8ff868b3fffa244ef8329c192e533f828aefc5abf0ec287fdf85706372d0a452a22a313e7cd55319b9e86bb65126f1c18319904cd4ca59dc5a1cd4a0268f5cd79ba1531e323bade1879158ed1140d1d1cf115dc9a2632b3d2c8912365ecd79e701ce3ce2e9bd524ca23acf9b2a35d87ebe4743732c1b07a5b7c1a1e3c8b966fe2aed282ede890f4540993519759c51f07180a29e11256dfe9b47c852d90d90f7b5a6dce0d751389f6571321f1dedaf072cbfc9eb00574271e6e1080abe596f30e37db69a1e221e6ec3bb0074dd2138d82d29a1a99434421c0342a955c2ab8dfa1d0e1791421eb79c390235812857d22611b3d4401e856d378dd3db1398fbe71f2b27251d71d30c9d9ccaef49c6bf3aa3accff0cb6d4721aa8b08fdd76efe25909503d46cb876a4872b4b19aeb82d97bb04d52ff90bd19ff95585e23a7619894e0444ec425edf0220fb16c1e453ce0f281f04badc26a065247e8b4f02ff07f414eeebb36e9d63dd8ee657b9d150a82c09e7ac24817030682a675c8043c52251e2a19e94468fdec01e7484c960c8b6513ac2717cf6199dd0736abe0c917cc50bab9b471f6d9289ef550053d932f386b6df16cd81e956173130644e6cc68b525b850e4710e05dbe7534a099166f3a2338679a68637a554d02e60ad8d5a91fdb6aa638f007cf449409f481429262bd91cba04e7e78a5def51c0b8f868c43a5bcbbda8578754b29abf9353ccbe838205566a400e3eef0fe42476f134e1a39e1a5e11d153ecb01f97c5b92abc798c8b5ed7e3fd9892f66103d768599e290213ef3f3b956bea3dec6149cc678f577d1ae2732bef80715ed036f750cb5f10a9c24f032d4eaa83edffbb0110e59f706985b544af7bf32519ce37e5c527c8617bb35a2c9b8aa339e321d8071f38fab2df9477e5be5d05c855c41b13739838c9ca9632b41f386d7a23595c3180f8c29e7aea56cb9bd452ceb3c539f95751d7eba364887414525fc37bbd42cf7d0fbafbc45e5b2dc469837a0ffeb2d0bc4a24559bd364205abcc9f5e378c355bd46b65f2e5e3b6cfa1ca0775c9efaf7e81318e3c6d0dd7a962e40fac460360735bec2061bb76c2262e15eacc2a1f962ebffa67f3e62b738ea519264bd144fbfe686bfbd56a813428837f8c6eee51166e913b3347c82bc11e8104b3150dbe10bfc05077e6ea4accecf1089c6765fedfb17f9297915077b16147aa8cca7cd966da0dbf62bb6eaf70aa4111579cead4ab98ef5215dd58e1b448b91ff0d193d50db95582918556e1f908a0e5e7e1c1c7b90f5d6dcfa3fa8af5c095cc1fd887e48822d545ab12ca8eb8cdac6891ab9afd8a799ec4e8ba70f570260ee5fbf0298cd493e4ec749f1af5d0d9d9f26563e9eab6689033f4823efefee498d186f78f6a6bbd4771a4d54d83f0ed53d42c9dd92be59867bee692407064eb8f57d17354bdfb10aade926b87289355cb1787c835b484b1ff170038fe1e2e0cd405d49c3a40aa2623312d64f215f5cb21997726315f05340f549fe3d2b267427262a355ae44ee95e1b07523009c7e530010f903dd4f1567abe2ab8bc4ef492191763e0636fca809943fa4c7cb85e1f837ec69fe8ddc8511f3e3a4546e1d333d289c9ae44ede635f726fe58de262688fa66583f922f6ea3e5b7cedc87b2262d0ff1559949be6de46ccf99259bb2281ac63e59a669cc2e1093d0139976959945702377b2c4a49da80e96146a6b6780805cb41d71240716e0467ccad94468ca719cabddc15745585e62ac0afdeeaae659b7a97da2f64f66577b201e9d35273c25b747bced90056fa8a4555fa8e7cbe402207a356cc88904e368bd037029d2633d8786838d07316e5a186d4c9c66bf8066b36f2eb1e2bcb0d0d60812dc26872c698c7b633caea99560759adc0f0dc1ff72001a526127b7d3c2f33480dd5b558c5980ecb9edb2ce91f60bebd20cf5fef1a932c78b7bab381274e340f16597684f0971cc35c58c4d54bfdb85a0b0b716f11a1c3fcfe25a393d4399deb03df3def4413a7847bffa4e047648ce3f6b401072cab902d39ebf293fa6ed1f016b2e21166c3cc03ed5f5fdca9fe14683291f7577d5e19e06d29ac006165ab3149f9d0d9effedc30be8a6d12d4f2d2f23121a470f9075514ad93d077a204d4c4d4826c47940402fbbb8bedd161ac933d4ecaab6cdffdbfc5bfb7f4492e702ed77eed9a468758c5e192b72f58eefc13c6e36b1a616d24b31bc8cb8cd3de86f63aa4ad7b2385b3cbfe8ec039bfe167d598d0e2a7a0e08acd871f485dad243595e90db0e55cbcc49689bd2c434c92e1a5451e67e7f7c2acb5d65e2f9cb252ac841b0d1780bd3d31c5de295f4434b0df56f80a71a226825f6ad8914d61f5b67df4c2c16a829ad9cb1094fca038328fa9ed34c5e53505de2283dd9e2ce3cd05034e0b2234292578392703212cc05e35e04a086d13ae06c5d2f584d0ae5c0c403b89589c619049095c73277db4690eb4856f936a9e5174ec266cacdcfe60c2ff2e8f7d47733fb17746f59434b5b25819b4fb588da94eca7eb1313abbc3f3c611c1e392a8f0537b27a479d8473002c56b333c056e092351a66d7d0b43026792858db0521bba215d8e029e1d169a652c1351862a4e57e92be7b19e0af94324aa97db928056483bd80d07ab96a4b36cf1c98ccae96cc6f8bd7fc56fbb834e3a49d95ed934fd65da053d3e657bd3953250f83dae789011f3d9c563227cc1a196195ccbd71476c9a9404663c8ad60fa1aecf951b40ff4438dcf20eb24eedc34159ac1f3960d72f02273926706862066cadd1c9726d003a58379c7fefe8a2b4bf9765349929aaab80481ba874ddc1f00c91d3a277456886f07580073ffa5778be413075c2e0b7b44ced4f25b24708d39ec0bd0b2aee4f4ac24d406a7e87bc3fa9395f6c74af610c6d024b07f8e5b81f964dbcc4f72b9ac82f27adaa9a26d70b48c134054ba4c4cdf2b912bf0aea3d4766c9690c189098e4cc8668cb8bfd78e8896cf82d5ef4ba678254948a5bb5cd274710f682bc1bee486eb43bd28ca218ff8e8f5d5b9a5dd0d303c7e51d22355f00bd4ac8858a2af4f92505f5deb5d52b273f5350ed2de9201208ca30373b427ae34ec4e0096d7a2b4ae56fd6c823547f9d8814dc12362ad9e77af1f8b8a9ae1510eb6c0e06775622a95ec9f415534608a23ae3760ae19506d40f57cd25c613dc5ef25e50b816d834d0969b8f61f787d8186117f1c81821ab5d7faed6abfe074d9f3d2d3956b0be6734d400b1196a02c6924a0fb5463d8e05b19827178829c09e3b783fffccc1bf02f7d80ace0a3f935b9721f7f7a786ec9f49352acd80a6719e9c5a4fdabfab6a0be33d9922d990a16f1b5015a254d274009d6da30ca15bb03f4a0b072b92c4bb33f26b3ba0306a49c317449e4a2a825fd94d415042a53135bcfe3df0119311340c2ffa9e836c8cd1ff71d94b51920d4d98f03854584d7a8deabe278fec45364c2a9e6eb2122475f2b62fc0ca7896537b82435e64ef521061b5ab955f0a654222c712819626a0556d7f6ec74d44663057b47f05f0b8b0738ee9d87534ccbe0d27103ebb52b68367dbe64b192c1c1d0168a4b484f9fc870daa5ebb10c6c8258ad024886bb76b8205cf1e3ff924485b1af895a653f3d272501d7628a1ca3d2cedd5a5ab1884e9316648052eefa8d8e7ad8abe65fb25d012009d5db4c92bea8aaaaeababb21d6b431de51dd0122a5b0a924070cedb50752e7562fb8c5a24b8680c5e1664875170d4f4827df46512c04a7d5c341c8db592cca1b73dc196ae21d16f25c278290e9d9e7bf5f77ea65c5daa426c5f037f0e13793f88d03e53eb88cf170e9376a40f8c5583505eac60149c6fa82705756c7404905b85e1a640ad10160e3b414b3bfd9255fd4596a459299abfdfc2f0af722b01007a125bf9b769dd7c99d15e478f24f51e04d475eec0228ffe04f2c86fef09350c742dedc429dae56daad03d91cc659ac88d6dcabd91542234e4085420bedc1f9f7bbebe71452ec2199d0baa6655010b1d0984ef74b4ee05be6a13e0c887fd9962f58225989eafdead52c69423aa9f8401d3ff8b942e13deb16378f5fc8d5d8ca7aaaa36e83ce4ad2c64111e62b40b51782e48a6c8c3b30a896a17d7f531aff1cc3f8f8667f56ba3176a09b7dfcf2a23cc0c5d17d8e549c034feaad30945278089fe7608b1029c61b30ba8f3c36db862f050d23ff3e0e0fdae07749379e53de82a7f6bb6be06a673c93a1fe2d1617d4b426db7372ce30ba11e1bbdb25198849002a4d394298bdc54632f4f9b40036d12d079020ba41f64c8128a01e29d026b3d59516bf586ea48e981f8bd58306d9f5e9bddb33f70712603fada7ac6860f7621505bd12e7293f99c490154e74bb9b2a7ab34580aaace192a894d63b00f2a67c00cf09b90240b0ab044a4d9dce482f7253839cf3f1bb2f758f1154bfdfe2fff12895fd20a7b95cd48a124ef1312c7049eef340bf4588aabd20243a09e5b2cd4dab6267b3a074ac51e470e4bdd1aa07113b18ec19f50816f02b6542b6b6585c9871a400424a760f82bcfa3aad718f2ea8421eef7402e6142d83f23e0cbd7ce99c535a81d04637c6a20f107ec4a9af7bd074843733e924b3dc687b441f663b7cbad5bba6037658af01d3540993adf567ca173b7ec9acc8ef53506409d255889eea660616612dd9e3783ad71017b37f911b474dff642463f8e94929efab3aebdac084654a5ee2a9e1f1fe08f701190a73a1d2e27bf2f2d3ea43c15b924b1cd8024f7b90b4df1181acc85aa477fb22599a8635a087b7a5b9702909ebca083121a929166dc921172027c758a500ed51f436dbe302a957a3042ce9c11818c82b33d21560de1d61488caf1498918e385205c30d148b27d55f60784c27c118c38d0dbe50365d353c3938e536348ab2492e59ad176e5e6547ab08d44f6d5c817bcd61641c49b2358d0a2c9d3e9578f9b817d4143547537a59a9fb17aaffcb5bde35f5888407351a9fc456181c84cdd1a97f30826e3957e140692fb88b11f1822bd8d3858543ea0dbae60b6f6c804a3f8c6b48156e4e94e00986e5ebe92c6b6876308c22204a106946cea1953dadf437ea7f95a99150f346fbaeb8446fb717cfcae1d2c561e64dccb482b134a61fd285ae4d98b265bf6161c5b996cd8c7e907ba81b8a02c62065a93bd38e1a65f892c37555050215c2d05977b75ee2568d0da678170a8da82227a9aa0c0bdf7c2d06340282b3d5a2e81a51b949696b9c288f8a42b17b084babe78afc7793692ed489e18ad262405861ab7930c54c702ca36776f47ea2aa66e7a0da27c3d4b96e3053585fa72f2febb9cc68751c88240c02df24fba742ed54f1557cc2e8a48cc6d929635439de94164dca7201cdc8aafbd48a1c86cc9819ebbcca603fec452d31e28f7b428ebb9903c9ea95d243977e19c7865c74db1276fe33fafdaae9a3db3be9cd05a6e815f6d7ce17729eb3cb0c94a618867aab92c5cf8b81a587d1f4a9071237b3428ea3f8bc574c215ec86e2dc0dc09de1698b7a025b258ec3a98c19156f1a69bbdc2d4696964629af70cc1ee17452d81b89c8ed6a6ff96cce4faa6ac7c300156f9e1417df1ae5da9fcd8774c9e245c2254f02b6f98e59c06a4ae88d19cfbfcd68067eea7d590576dbdcdaf7cda56873fc2e1240041fa6795a400d17a9ad135503b379c9d049bf1276c2f8b71b7f13a52c9d7a99e2382587b4997394d5f85c1d9abf2326c6f61478b52ae5bb9f4d55b7f0e997e50e007b675445b31f05b0dd9daf8a30530b4ceacb10e7ba47590903903430eaf9f782f1f1af314bc58071a7208e8e9812ab993c64d613ff73c08c4256c211cd2de2c1db344b900f4f6167225b46efad0ad070a54ac532e7ba47b94b94ac714a53df1729ee772fcb3c133f6420f2fd3f351ae11b33af88ccf41fc7132f3420121a456ef396b8c365e2c29af0b27917b199b2633503951010358fd6e398001521e5b5d6dce961ed403a9326b9a8b6418bff9c96ccadbef1d14c27acb6ab4ca954b43c6020bd38e920597f647c60c6ed7ed2441521d5cf8231e1ee2dd52e8a89bcb924a1f07b79c4397f43fdfbe43247f8be644950d28618f7c4054b87049c2e115a7e228a46b20ddc1830028143924912dddf6aafd4525963790f77578ef0fbe91993df8313ea333812881a2c10dbb5d021b3f5a60b51310d0ffd7c3b5483579ed933e6ed2d8514444079efae54077cbef5fb5ab662e1584d1a5d0f669f714aa1d630fe45412a695374b8ad5463cc033005dbbea6178531263142e0060824b0819fff1a9b2d0081c26bb2491a598973c2af77cead8e0d9653327d6525153588c023564f8244f6c624dfab58add859d90436cde262ded291fcf39e2a3fdfa7e007075d5f85ce8f52818d9bc575ed55884ab81b2d5fcee3f28b2cc8b2f2f57c7afa8b8f05aba42b8ed2d6d1be0c0b34d68625c0f1396eb7b4295e027e751a6c280c6ab63a466bd8655322a1aff0113bc60cb9a5c57a99beb1f311bad296300b5b0bdf280425e50ffc960b4d6378d3ec54bec74e5697f2089f87c892df28a0ad649bf2e9facfc3c1f6ce70564c927d20731aaa06f1a00b74af8781d56ed623073ba0d170321062705fa0a524ffeef2aafc4a108469d2b9ddae125d15fec6e1567086b1a70d0d3a1b52b33ff90f85df87a163922cfd29a2ac0e33560c5a413ff8d778801faffc5aed5bb213b99e721f35bbd4c78dd063340e83be9c11f306d0f6d9292a064319858f453133902fc13633e2a6478031a179ae878f8f1a77aa10b79bebf1395e9213b4ece143ed13811b0bfc0ae43197236d2fa41be342043e716a4eb3a3fd453a0c586203c8c3794ce8f2450f4fd041fa09fbb627ed0152fa7f5f7319f8c6481374b31565f029ac0e916ce79e2091a2414003e54c76b9bac9cf8622d357100bd7dff5ff8bb54d9930dfc3f4c03dd0962e9ba66d0d56081f20508f2d99c378977bac0705e30b99033f4c2fe1843d750583e90f3973b2c21cd25d5954561dd81440f15a3848d9bc34440f487fa28fc7bc189ef1d0821fb1df284352c27616941f6db6460b95aed0245fe344b504513cea542935c432a8a0c21db4261f1771854d6980d1f1ffa12912b0b9aaddeaa33370176c1b6b9d2df012549105d2f8e7bf3f51743be16f0116173ffab8f78a29b877250924f42e804662b15739005414e8dc270582d60e0f58df37b158bf67782ac83e72672e83f29faf13d01fa91d2a46f94d8988895322e3bb7e8f12e86aae15094d434d8b7245155f7edb2b9c95c9e50a0ae11eaa5cc9c85cebd3c59f383827e29cdfd436d38a66ebd641027c7ea4e7881470620c36473125ee330f0a01c5754e47b20d3581a24308d91eb43d1d0a911bd6053f401a3b99b2d80e9167ac72410f1ae8adfcde261feadb99441131b279e895d2475bc68af37ef1d07e35016cebfbb8ab004fd66fa64bd70b3aa1978eed134de71266b7e855949335cb67bf4e73233f08e9b8185b9317a3736416487476bf3a2467f573fe8a0af72521310a2a2728ab2b0e28ca08045cc26d1ac9c8059a71a3e505000f5fe36ffbf23800fcd011c0617f705760d9e81c539d5e6b0999211a4cae32ebaaf2665383e93c78f86b512a8a58fe0f604f2552af97c1b61c615853b6c586bafcdcbd6b00868a00f6dc112d158a896dd7d5c910011ceccd0f8497cf21fa6e6ac9bee353ea1392fad48bed5762d1ab65e079496c9fddf5336acbc09501dc2f6a8855af25e9731804e99f26022c28535ed7345b5a15f2e8001b696d873066add596f46478f7eaa228a39612435f4ba6502b8958f7d3b4f1977749317fdf4a8706273ee9321cd0f5eb69f8d75855398078b413b224095164913fc80dbb549fdd0e0ffb0f899d76a2cc28d7bc538223d3ca300b683a0d75aa8409ba09a68d4bc2d8c73f13f649d418bcf477d2b0e2e922c3ce597a5c6717d4d71f7460a3fcf3d6330d25820895254c2c446c065a57620f301d85422a674385bc4c6823a19b756961c8e48ba58ef71b76152e73e7b6f8ddf4067aec0df26b4c37218beebe2cbf92746b46058c4663b930e30301a0366f3510068f853fbb83e8774431e805dc0ec2e6681328c85ae6805b58cae7e219fe7b5178373ddf4df80567af180d6eef198e7d44408ddf215dc7eb8042fb9752d7ee4ad01fcfc3407a617615b60a7a6985d056cef86ab4be45f0dd1cc004a49ff47d4540d7b6c4518014863cddb04e945683e3fcd879778e2b4ab146e40a16dcaa9ad2ef55290b4aa2f4533423997ece06014c1c9aac9ee22ac043d8a3acd195727101119e8a353cb735349bb9850f6dea205d74e0e708a73aae53e9fc4c6f007c6037a279ab73b61314d14c7f5974075697c889aa516840306fa482a474f39a3f4538994cce7966e0d8b9b626981a95c3619d8dca830994eb253e9ba2a99ec9c30bee21d4500b7680a3872e46f952264caa6eef559196f8a5859ab459dd5b8ced324200d198eb6125c3d18bfce5937a00800b679948c27e5f14d76c429f70d8bb78fbec986ebd6981e2f40d21255d39b4e81a84b30a13ca0ea5ef563279d97760d45c277473223941d2ed8aeb12e938aa61a81bc31347a564a038e34dde76c0be67213a1c075fe5f714bc83aeadde872440beaba4a3f056417ee4d2a206a610e35d8d50dc6730d6d64a3d306480d6490fa64e03b623e917b2542b9dd883ad2de7734fbbd72bc3fc5a8581066c529dc15dc466f78484371b477b6ef850a53150e25e67db5033223bf925990d6f9d81effbea11dc059cd0498746e3ed8e027235c5f61a8bd6b316a9881b04caf9f9cdfecc327acd33f3489f3dc9a46c0437c8f54b67c72e0cd95a0288e20fdb23d517f9b3bce72cf55dc228656cfa199aa9294a1479939adece08e94d1e112cf70d2da3f8ed22f608327e9d36602eb2b3a35b4d13b8ecc31b70651223194ca24585ae729310f4d38bdc1d1873bc293ac54af85ca8f079e7d10d2ad97017b2cf84b2511801d697dcca949fd84299d510abcb5ebced45efe35e9afabc1bcfa74332b581652aa57329dd395075941672765c555aef3adbac3d6a7d900460e2b245ee4600a1e1897dbaf9e6b8e669aa82397a275f4e4a3fdb93441ad9fe2ff6dc70c286660d5de927e2d49b90c40014c01f9aaea38006c1a4ababe187d49034fdc98ee32ef77566fe953aa2360436878d7dbccf84254083dc578c06414960c6810e5057c139826ed2c7c2dc463899f0948de89dcc733fb9687059727c5fa3d75d94eb4bcd554a517af4a26785cae330f98f951d06d8726635240287021cdd02a6072f7b512af43e2ddac08b11720f84686b0b2fada5f901f2e6caa00eacd6b4f12c20a0577ea2a971176cf1e946fae95a82b6e4d762558eed7c8c912e286de4065198f73df5cdfe5c1e0e1237d3e169d8668e253c3d513e20d03fdca744db690f6495d0171990672cef2dbbfa2a1892181757fca956da9ae47837261746d727aa0469c99e7e8fdcdadcab48f87181462177610fcf7f695269d6cdcdaff81a793a895c00c5aedcd321f43262a24d4cfe2d8ff1a9bab656fc839b0ba92bdd1066974fd9683e5c8720193a184b9e6441fd776c891f18876112595fff0f96c58a5fd69a5f0a5673cc27a00b56f86143b4e6631e267a39741e00252b60968217001bb3e5929ac68a964aff01f57ffa85f7194b2d458cdd80c8d2dfb02c13adb625f0137d186d6102a6e65d92fe02178f8e36c912e8af939f0091095c817dd4ad25baa4752bf86e97a5257d4994d6137e7fda6caa6d230f2cd86329528e26ab310fcce990f3106da5ca8c85d23bcbf8966de3b591cc4b54d8c038828b84d469bfb91b5562483831875a9490cc0e1ec5865b7c554c382891a9bb1ace9fe0f345a12c4e79a73a2e49097838e29</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>鲜花</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>离弦</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E7%A6%BB%E5%BC%A6/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>破碎尘埃在掌心堆叠</p>
<p>太相似的岁月</p>
<p>连泪水炽热，都被抛却</p>
<p>我想我是在等，某个微小瞬间</p>
<p>一阵不经意的风，就颤动某列和弦</p>
<p>唤醒过往誓言，再度闪烁于指尖</p>
<p>编织起音节</p>
<p>牵引我去比遥远，更远的天</p>
<p>（初繁言《离弦》）</p>
</blockquote>
<hr>
<blockquote>
<p>所以看上去，故事已经临近尾声。</p>
<p>但我想，故事大概永远不会结束。</p>
<p>这几天经常想：如果我联赛考砸怎么办？如果我省选失利怎么办？如果我国赛出错怎么办？</p>
<p>如果我没能考上北大怎么办？</p>
<p>所有人都在问我这一个问题。</p>
<p>所有人都等着我作出回答。</p>
<p>他们告诉我：一旦我输了，我就全完了。</p>
<p>他们跟我说：一旦我失败了，我将永远翻不了身。</p>
<p>他们是谁呢？</p>
<p>（写于2022.10.08，国庆集训后）</p>
</blockquote>
<blockquote>
<p>考前跟同学说，我特别讨厌自己不能掌控的局面。那些即使我拼尽全力也无法改变的局面，我是难以面对的。结果还真是一语成谶，现在我的命运脱离于我手中了。</p>
<p>每次听歌，听到《猜火车》的时候总是有别样的感觉：那种青年的迷茫，所谓“未来即是永不到来”的迷茫。我记得曾读过的句子：“对自己命运掌控权的过度追求，是妄图以微弱的天赋和丝毫的努力，挑战造物主的疯狂。”想来大抵如此。</p>
<p>好吧，我不知道故事会不会就此结束。故事开始的时候没有人会一下就注意到，故事结束的时候没有人会相信这已经是终页。造物主的笔永不停歇，没有人会永远是主角。</p>
<p>（写于2022.11.29，联赛后）</p>
</blockquote>
<blockquote>
<p>我是个懦夫，所以我不敢回看过去了。</p>
<p>我也是个勇士，因为我要看向未来了。</p>
<p>（写于2022.12.18，省选前停课）</p>
</blockquote>
<hr>
<p>删删改改过好多次，最后还是打算写完这么一篇文章作为OI生涯结束的标志。已经好久好久没去写一篇这样的随想了，所以感觉自己根本写不出来什么主题明确的东西，只能写一些不知所云的碎碎念。</p>
<p>但想到Anlin老师也经常写这种碎碎念，于是我又登时充满信心了。而写了两句就发现自己文笔远远比不上Anlin老师，连一个明确的主题都写不出来。然而既然已经写完了，姑且认作我的说说合集篇看吧。</p>
<p><a href="https://www.bilibili.com/video/BV1Wu411h7t6/">本文的bgm</a>。</p>
<hr>
<p>退役后这两个周一直浑浑噩噩，白天几乎学不进去任何东西，到了晚上觉得这一天不能就这么过去了，于是一直学到两三点，然后第二天睡到中午再起床，于是下午继续浑浑噩噩。</p>
<p>我记得我高一高二省选后补课都不是这样的。</p>
<p>高一省选后已经确知自己进不了队了，拼了命地补课，当时和她还在一起。记得当时补课压力特别大，因为补一个周的课就要去考月考了。有一天晚上精神崩溃了，很晚很晚的时候给她发了好长一段话，我知道的是她平时睡得很早，没猜到的是她却迅速回复我了。我们那天晚上聊了好多好多。</p>
<p>最后的结果就是一个周过去了，除了生物以外所有课全部补完了，而生物在只补了三分之一左右的情况下去考试考到了大实验平均分，最后赋分到了总分年级第十。她是班级第一，我比她低了$0
. 5 $分。</p>
<p>我一直认为自己其实是一个很狂妄的人，但我想一直到现在我说过的最狂的话，还是月考成绩出来后，我说，级部第十不重要，重要的是排在她的后面。</p>
<p>现在当时的种种已经是难以回忆的故事了。前不久看过一个视频，讲的是人在失去什么后，会应激性忘记大部分不开心的事，然后只留下那些美好的回忆，于是越发不舍。我想我的大脑可能比我聪明得多也理智得多，它选择放弃了几乎全部的记忆。</p>
<hr>
<p>高二补课的时候是极其不甘的，联赛挂分挂了$65
$分，省选第一天明明拍过了出来也对过思路了，本来都充满希望地认为自己将拿到$248
$的标准分，结果挂分，最后无从得知是否能进入省队。</p>
<p>那时我突然开始想，为什么要这么拼呢？说到底，对北大的执念可能是一部分，另一部分，可能是一种复杂而扭曲的情绪。我一直抵触将自己标榜为一个过于注重功利的人，一直试图掩饰自己过强的好胜心，但我的内心是极其争强的。我见过的几乎所有的老师都有一种固有的观念，那就是成功者不聪明，失败者不努力。每次有什么讲座或者所谓优生交流之类的事情，都会有老师在上面说诸如谁谁谁并不如你们聪明，谁谁谁是我见过最聪明的学生此类话。我印象很深的是刚开学的时候竞赛生训话，说到我时说我是所有人中最聪明的，但可能会成为最后的“无冕之王”。当我真正取得成绩后，我又成为了所有人中最努力的，最“听老师话的”，其他人代替了我的位置成为了这个老师口中的“最聪明但存在问题”的学生。没人会喜欢平凡的人的故事，人们称赞成功者，惋惜失败者，并试图从他们身上找到一些经验教训，为此他们不惜强说因果，因为没人会选择去从那些玄而又玄的命运或者天赋中汲取经验。</p>
<p>而我听过了太多的反面教材，于是也害怕自己成为别人口中的反面教材。</p>
<p>所以也许我一直都在怕，一直怕别人对我的评价，怕别人说我如此聪明却又不努力，怕别人说我因为一时的恋爱而影响了一辈子，怕别人说我钻研难题而导致基础知识失误。尤其是那些我在意的人。我曾经也许真的有那么一段时间，不顾别人对我的看法，只是按照自己的方式活着。但她走了之后，我发现原来那些我所珍视的人，原来他们对我的评价足以超脱一切相处的记忆。甚至一件事，只是一件事就足以掩盖曾经相处的种种。</p>
<hr>
<p>我至今清晰地记得我们班主任来通知我进队时的情景，我补课补得差不多了，在教室里等着准备接下来要跟着班级上课了。那节课大概是体育课或是别的什么，反正教室里只有几个人。低头写着作业的时候发现我们班主任进来找我，他问我，我自己觉得能考第几名。我愣了一下知道省选成绩出了，我说老师你先告诉我进没进队。他说那肯定进了，但是你猜猜第几名。我说第九第十左右吧，他说，第五名。</p>
<p>我记得我当时从椅子上跳起来了。然后跟着他在上课的时候满教学楼乱窜，最后到了我们学校竞赛总教练，也是我们级部主任的办公室。</p>
<p>级部主任看到我后笑着对我说，你怎么跟范进一样。于是我在办公室里喊了一声“噫，好了，我中了！”</p>
<p>他们不知道的是我昨天和wmy打赌，我说，如果我进了A队，我就在宿舍里唱大风的《范进中举》。</p>
<p>所有人都不知道的是，进队后高喊一声“噫，好了，我中了”这件事，从一年之前，我就开始幻想了。</p>
<hr>
<blockquote>
<p>好想就这么一直下去，好想自己就在这里上学，虽然很累但是每天可以学自己喜欢的也可以和兴趣相投的朋友一起玩永远不要回去面对文化课和文化课同学。</p>
<p>但只是想想罢了。</p>
<p>（写于2023.04.22，省队一轮集训）</p>
</blockquote>
<p>后来自然而然地参加了一轮省集，然后去了平邑一中集训。在我OI的将近六年的生涯中，在平邑一中的这两个月是我印象最深的两个月。每天有教练安排的任务，有一起聊天、一起训练、一起打羽毛球的朋友。很后悔去年这个时候没有来到平邑一中，如果那个时候来了或许现在的OI水平会强上不少。</p>
<p>二轮省集的时候阳了，本来都让父母不要来，然后父母瞒着我买了车票到济南了，然后拉着我回烟台了。然后是SDCPC。我的OI生涯中掺杂了大概四五场正式的ACM比赛，印象最深的一个是美团杯的队伍伞兵队，那次和lrg、qhr熟悉了起来；另一个就是SDCPC的队伍BAD队，和dwt、qyc熟悉了起来。</p>
<p>又想起省选之前问学长们问题，学长们对我的问题除去一些确实过难的问题，几乎是有问必答。有的时候一天会在问问题上用上三四个小时，也耽误了学长们三四个小时的时间。</p>
<p>有的时候惊叹于自己的运气，能遇上如此好的大家。无论是平邑一中或者说泰安OI的大家、亦或者两次ACM的队友，再或者是烟台二中的2020级和2019级的学长们，遇上大家是我的幸运。有的时候真的会想，如果自己低谷的时候没有大家来安慰我、瓶颈期的时候没有大家来解答我的问题，我应该是绝无可能走到现在的。</p>
<hr>
<p>NOI的过程没什么可说的，考前说自己不擅长拼包的话真是一语成谶。</p>
<p>最后倒是没挂分，也无分可挂。平平淡淡地考完了NOI，拿到了一块低分Ag。</p>
<p>前段时间那个“爽滑慢舔”很火，所以去听了一下原歌。听到“偏偏雀落人间”这句词的时候一愣。再一看歌词，发现是“翩翩雀落人间”，一时不知道说什么好。</p>
<p>也许我一直自命不凡吧，一直觉得自己是天命之选。</p>
<p>最后发现落幕的时候倒也没有英雄的悲哀，只是突然意识到自己也没有那么特别，一个有些天赋、有些努力的普通人而已。</p>
<p>我想这大概是我现在消沉的原因。</p>
<hr>
<p>前不久，我从歌单里翻出了《少年月光》这首歌，听到双目含泪。</p>
<p>哪来那么多天命啊，哪来那么多平凡与不平凡的论调，又哪来那么多反面教材。</p>
<p>我在怕些什么呢？我在担心些什么呢？</p>
<p>我已经走到这里了啊，这还不能反驳别人口中对我的诋毁，对我未来的诅咒么？</p>
<p>这还不能反驳我自己对自己的贬低么？</p>
<blockquote>
<p>这一路走了很久很久</p>
<p>走到少年老，走到年轮旧</p>
<p>梦结束在街口，或绽放枝头</p>
<p>星月还在，只有云悠悠</p>
<p>（瞳荧《在人间》）</p>
</blockquote>
<p>有的时候会想如果我不学竞赛，或者学到一半放弃了会怎样。这想象如此之困难，以至于我无法想象出任何一种可能性。</p>
<p>很喜欢一句话：“在人生的某些时刻，你只能把它归结于命运。”我有的时候会恐惧，如果这命运走偏一点会怎样。总是觉得，偏离一步、走错一点都不会走到现在。</p>
<p>但最终我走完了这一切。</p>
<p>也许没有走错不走错之说，因为没有正确的道路之说。我NOIP后对挂分惋惜不已，省选结果出来后突然觉得，如果NOIP没挂分，我省选前大概也不可能如此拼命地准备。即使竞赛这条路最后没有走到NOI的考场，也许我的人生也仍然没有failed。</p>
<p>NOI
Ag意味着我在准备高考的时候可以轻松一些，但毕竟也不是大道坦途。至于以后，我希望自己能沿着曾经梦想过的道路走下去。</p>
<p>现在我走到了这里，不清楚我和运气谁的功劳更大一些，我感谢我自己，也感谢运气。</p>
<blockquote>
<p>这一路好像没走太久</p>
<p>情感没腐朽，回忆没生锈</p>
<p>距意气斥方遒，没几个春秋</p>
<p>怎么能走到厌倦以后</p>
<p>（瞳荧《在人间》）</p>
</blockquote>
<hr>
<p>一开始听到《离弦》这首歌，其实第一反应是箭的“离弦”，觉得讲的是那种一往无前的勇气。</p>
<p>后来才知道原来“离弦”可以指代离别时候演奏的歌曲，那偷来当我的OI回忆录的题目吧。</p>
<p>虽然很不愿意承认，但我的竞赛生涯也确实到这里结束了。大学不确定会不会打ACM，至少OI与我的关联应该是顶多出去讲两节课了出两套题了。</p>
<p>看到这里的读者，我不清楚你是谁，也许是完全不熟的陌生人，也许是一面之缘、点头之交，也许是关系极好的朋友，但我都要感谢你看到这里。感谢你听完我的这些碎碎念，也感谢你来看过了我OI生涯的最后所留下的残篇。愿你有一个灿烂的前程，愿你幸福，愿你的一切如愿以偿。</p>
<blockquote>
<p>你在人间走一走</p>
<p>有温暖也有寒流</p>
<p>为何奔波为何停留</p>
<p>是生活亦是所求</p>
<p>熬过苦累悲痛，迷茫不必再深究</p>
<p>你的存在你的意义</p>
<p>因爱或被爱而不朽</p>
<p>在人间走一走</p>
<p>从婴提走到白头</p>
<p>理想与梦是烂借口</p>
<p>一直前行便足够</p>
<p>（瞳荧《在人间》）</p>
</blockquote>
<p>最后的最后，如果让我对我的OI生涯做一个总结的话，我想化用瓶子的那句话：</p>
<blockquote>
<p>当我回忆我的OI生涯，你要问我觉得成功吗，那其实没有很成功。但你问过程精彩吗，那我觉得真他妈的是相当精彩啊！</p>
</blockquote>
<hr>
<p>2023.08.12</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>猜火车</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E7%8C%9C%E7%81%AB%E8%BD%A6/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>题目是后来加的，是一首我挺喜欢的歌的名字，原本题目是日记的日期。</p>
<p>下面是原文。</p>
<p>现在耳机里在循环播放《猜火车》。</p>
<p>五年前的我，不谙世事。我在微机课上第一次接触了OI，老师推荐我去学，我就去了。</p>
<p>故事从这里开始，我从此接触了我将为之奋斗五年的OI。</p>
<p>最开始年少轻狂。小孩子什么都不懂，刚刚初一，照顾不好自己，也不知道什么叫天高地厚。当时觉得，未来还离自己太远，却又在心里想象未来的辉煌，觉得自己未来一定无比光明，会去北大、会搞科研、会做出许多许多的成果、会青史留名、会有幸福的一生。当时还什么都不知道呢，考试考得有点不好就是对我最大的打击，会哭好几天呢（笑）。</p>
<p>后来啊，时间一点一点过去了。</p>
<p>我亲眼看着我从山顶坠落、亲眼见证苍穹的沦落、亲眼目睹所有的骄傲被打破——仿佛我已经泯然众人矣了，仿佛所有的故事都结束了。或许我该退役，该好好回去学文化课，该心无旁念学习的。</p>
<p>但最后还是坚持下来了，还是一场一场比赛地打，一套一套卷子地刷。</p>
<p>猜火车的少年，永远不知道下一列火车驶向哪里，大概也无从推理，只是漫无目的、毫无头绪地猜。</p>
<p>猜中了如何？猜错了又如何？</p>
<p>我的努力收获了成效，我的文化课甚至比以前还要好了，我的OI终于打出了不错的成绩。</p>
<p>我敢不敢说这些是我应得的呢？</p>
<p>我不知道。</p>
<p>很早我就听过一句话：所有命运赠送的礼物，都已在暗中标好了价格。</p>
<p>我以为我所付出的努力、经历过的迷茫就是这些价格了。</p>
<p>我真是什么也不懂。</p>
<p>我终于迎来了幻灭。</p>
<p>我失去了我曾骄傲的一切。</p>
<p>我站在现在看过往，已经像看一个陌生人的故事一样了：他聪明、努力、善良、骄傲、幼稚。我无从得知他曾经的骄傲，也无从得知他当时的痛苦。</p>
<p>我只知道，他挺过来了。</p>
<p>好吧，故事又重新开始了，仿佛以前从未开始过，仿佛过去四年都只是幻觉，或者说是另一个人的故事。</p>
<p>那个人早就死去了，不是吗？</p>
<p>但过去的故事，没有结束。</p>
<p>我还记得我第一次来机房的新鲜感；</p>
<p>我还记得我第一次过题的成就感；</p>
<p>我还记得我第一次打比赛的迷茫；</p>
<p>我还记得我第一次给别人讲课的狂妄；</p>
<p>我还记得我第一次拿奖时的喜悦；</p>
<p>我会永远记得，有一天晚上，一个少年让家长拨通了教练的电话；</p>
<p>我会永远记得，他曾狂妄得不可一世，也曾自卑得泪流满面；</p>
<p>我会永远记得，他曾骄傲地宣称：我不能书写神话，但我可以创造奇迹；</p>
<p>我会永远记得，他在模拟赛失利后对朋友的哭诉；</p>
<p>我会永远记得，他在模拟赛打好后大喊的那一声：莫欺少年穷！</p>
<p>所以看上去，故事已经临近尾声。</p>
<p>但我想，故事大概永远不会结束。</p>
<p>这几天经常想：如果我联赛考砸怎么办？如果我省选失利怎么办？如果我国赛出错怎么办？</p>
<p>如果我没能考上北大怎么办？</p>
<p>所有人都在问我这一个问题。</p>
<p>所有人都等着我作出回答。</p>
<p>他们告诉我：一旦我输了，我就全完了。</p>
<p>他们跟我说：一旦我失败了，我将永远翻不了身。</p>
<p>他们是谁呢？</p>
<p>继续向前走吧。</p>
<p>如果你找不到活下去的理由了，请回忆：有一个人，在四年前给了你生活的意义；在现在给了你生活的慰藉。</p>
<p>如果你找不到坚持下去的理由了，请想：你已经承受了许多痛苦，你总得为其他的处于苦难的人做些什么。</p>
<p>愿这世上的人都能幸福。</p>
<p>愿我实现我的梦想和诺言。</p>
<p>（写于2022.10.08）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>昔巷旧梦</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E6%98%94%E5%B7%B7%E6%97%A7%E6%A2%A6/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>题目是后来加的，是一首我挺喜欢的歌的名字，原本题目是日记的日期。</p>
<p>下面是原文。</p>
<p>昨晚将自己关在房间里哭了一夜，最后下了决心：请一下午的假。</p>
<p>下车前接过母亲递来的硬币，以备需要自己乘公交车回家的情况。</p>
<p>到教室里，教室里是不一的读书声，我听见一句“风急天高猿啸哀”，听见一句“古来万事东流水”，我拿出语文书也想读，喉头一痒，词语就都改成了咳嗽。我几乎带着期望去看手心里有没有血丝，血倒是没有，泪倒是不止。</p>
<p>我攥紧硬币，压着咳嗽，读下去。</p>
<p>早晨又是愤怒的，我几乎带着莫大的敌意针对每一个人，却又在片刻后宁静下来报以歉意和冷静的语气。第一节课是语文，原本以为老师不来，拿出生物卷子想做，却又放下了。拿出语文书，重新读史铁生的《我与地坛》。</p>
<p>再后来的课几乎没听进去，我害怕班主任不准假，于是脑中只充满无助的愤怒，想着想着泪又留下来，低着头掩饰着，即使我明明知道，这样的事并没有发生。</p>
<p>上数学公开课也是低垂着头，忍耐咳嗽时的声音像是啜泣，同桌时常看我，我不知道该怎么跟他说，索性不说，谁过来搭话也不说。</p>
<p>然后是去找班主任要假条，再然后回班级收拾东西。我尽力让自己看起来兴奋一点，健康一点，然后少有的从前门进了教室，我看见地上的那个蓝绿色箱子，我突然感觉又有了活力。却也只是突然。我最后还是拎着两个袋子来到座位上收拾东西，然后是带子断裂的声音。</p>
<p>我几乎要哭出声来，我带着哀求的目光往那个方向看，只有一张空空的桌子。</p>
<p>到了家，带着手机，攥着硬币出门去。</p>
<p>我大概两三年没有走过家门前的这条路了，再往前的那条路应该已经有五六年没涉足了，一开始倒害怕自己走错，可明明是小时候天天走过的路。</p>
<p>当时还是泥土地上的石板路，现在是全改成鲜红的柏油路了。总疑心路边的白桦林换过，因为树干很细，不像是过去了五六年，而且树干都斜着，压向小路。</p>
<p>我还能回忆起小时候陪父母在这条路上散步，他们走在前面，我走在后面。倒不是因为关系不好或是别的什么原因，只是我喜欢在散步的时候想故事。我已经记不起来多少故事了，只觉得当时编了好多，都是那种孩子最喜欢的故事。有的时候还会特意构思一个悲剧结尾以体现自己的审美水平。于是又感叹，命运不是和我一样的拙劣的写手，不然它大抵会让我在昨晚下定决心后在睡梦中死去，或是让我在今天早晨出车祸，但也不一定，因为它还有机会，前面还有几个路口。</p>
<p>我遇见一段残存的石板路，从柏油路延伸出去，伸入几棵小松树，然后消失在拐角。我想到了小学时校园里也有几棵松树，玩松针、松油的故事记不清了，但又总记得。只是之前听说，那几棵树已经被砍倒了。我几乎确信我曾经踩过这几块石板，但突然又谨慎起来了，说不定换过石板。或许几年后的我经过这里，再看到这几块石板也会有一样的感觉。或许看不到了，或许不会再经过这里了。</p>
<p>前面是绿灯，但我不想急。到了路口就转为红灯了。于是四处望望，早已经不是熟悉的景象了。恍惚中看见对面有人穿过马路，再一定神，绿灯闪着，又变成了红灯。</p>
<p>我来到商场，多了很多新开的门店，但很多旧的也还在。我又想，如果命运不肯和我开大一点的玩笑，或许可以最后开个恶作剧，让我走到那里的时候看到那家店关门待转让的告示。可它没有这么无聊，我沿着记忆中的路，走到了那里。</p>
<p>这时候已经下午两点，来之前担心这里只有我一个人，多少会有些尴尬，但进来后看见零散的几张桌子坐着零散的人，于是便放下心来，走到角落坐下。</p>
<p>角落里还有一个女人，在那里静静地吃着饭，我过来的时候她抬头看了我一眼，然后低头继续吃。吃得很慢，我开始好奇她的故事。人总是奇怪的生物，明明知道有些人和自己一辈子只有那么一面两面的交集，却还是好奇对方的故事。</p>
<p>但在一生结束之前，谁又能确定只有一两面的交集？我曾经以为会很快变得陌生，很快淡忘掉的人，有多少一辈子刻在了我心里？我曾经确信会一直相交的人，有多少后来证明，只是生命中的过客？</p>
<p>我低下头，打开手机，看史铁生的《我与地坛》。</p>
<p>我的饭来了，醋加多了，但刚刚好。我想起小的时候觉得好玩，会故意多加很多醋。结果最后自己吃不了，就全给父亲吃了。不知道他这几年替我吃了多少醋，又不知道他这几年替我吃了多少苦。</p>
<p>我想起曾经自己不愿意来这里吃，连尝试都不愿意。后来有个阿姨带我来，推脱不过，尝试了一下，于是便成了常客。那个阿姨很讨厌，我不喜欢她，但想起她来总没多少厌恶的感情，不知道与这有没有关系。</p>
<p>以前和父母来的时候，母亲总会在第二碗的时候把鸡柳挑给我，在第三碗的时候把牛肉挑给我。所以我吃了几口，约莫到一碗了，就咬下鸡柳，约莫第二碗吃完了就挑出牛肉。但总是少了那种感觉，我吃的也很慢。到最后有些饱了，但还是接着吃，因为不知道下次什么时候来。我想起以前，我总会吃的很慢，最后父母都起身了，我还是要贪恋一口汤再走。于是想着喝一口汤就走，但又不想起身，坐在椅子上，把手里的文章看完。</p>
<p>回去的路上，车流多了起来，不知道为什么。</p>
<p>我发现小区门口的洗车的地方换了足球场，想起之前和父母来这里的情景，有点不知道说什么好。但随即发现只是换了个地方，不过生意看起来冷清了许多。很快我就找到了冷清的原因：前面有了一家新的汽车保养店。</p>
<p>那家包子铺还在开着，我已经记不清什么时候第一次来这里了。</p>
<p>许多新店开了，许多老店还在。</p>
<p>走进小区，我看到原本幼儿园前的几张木椅已经破损地不像样了，里面的钢丝漏了出来，原来竟是假的，可我小时从没怀疑过。幼儿园里空荡荡的，想来孩子们都在室内。往回走的时候听到后面的响声，以为是孩子们出来玩了，回头一看，还是没有人。有一条人工河，上面有一条刻成弯曲木头形状的桥。我想起来曾经经常在上面玩，熟悉每一道花纹。</p>
<p>人工河以前是有生机的，还有很多水。以前是有青蛙的，我记得我来这里抓过蝌蚪，可现在大部分都干涸了，露出了光秃的地面。仅剩的水在今天也结着冰。</p>
<p>曾经那边有一家面包店，我经常在那里买十块钱一袋的肉松面包当作零食。</p>
<p>曾经那边有一家菜店，我有时会替母亲去那里买菜。</p>
<p>曾经小区里是有桃树的，小时候摘过桃子，后来可能摘得人多了，桃树再也见不到了。</p>
<p>曾经小区里有条管道放着水，母亲经常去那里洗衣服，我就坐在她旁边看书。</p>
<p>我张开手，拿出攥着的硬币。我原本想将它抛到河里，但又改了主意。我记得我小时候捡到一元钱是很开心的，我可以买两袋零食吃，同学也会都来分着要。</p>
<p>所以，我望着前面结冰的河，把硬币放在拇指上。</p>
<p>希望以后，不必回望过去，不必妄想将来，只活在当下，做好自己。</p>
<p>希望以后，不必因为别人而惩罚自己，不必在意别人的评价，不必在意别人的性格。</p>
<p>希望以后，只为自己而活，不必将生命托付给谁，只为了所有的记忆与情感而活。</p>
<p>我抛出硬币。</p>
<p>我想起来月考后，我拿着橡皮和自己打赌。“三次正面就去”，我扔了两正一反。但又不甘心，于是又来：“五次正面就去”，这次倒是扔了五次正面，但我又不放心了，再扔一次，是反面。</p>
<p>所以我转身，我听见硬币落在地上，滚动着，然后停下。</p>
<p>去他妈的命运。</p>
<p>（写于2022.01.07）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>我多想说再见啊</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E6%88%91%E5%A4%9A%E6%83%B3%E8%AF%B4%E5%86%8D%E8%A7%81%E5%95%8A/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>试着掬一把星辰在手心</p>
<p>却遮住迷恋遥远的眼睛</p>
<p>窗外传来记忆的声音</p>
<p>在半夜迷失，在房间消失</p>
<p>去幻想着夜晚之前的一种逃离</p>
<p>——柯立可《我多想说再见啊》</p>
</blockquote>
<hr>
<blockquote>
<p>那时我突然开始想，为什么要这么拼呢？说到底，对北大的执念可能是一部分，另一部分，可能是一种复杂而扭曲的情绪。我一直抵触将自己标榜为一个过于注重功利的人，一直试图掩饰自己过强的好胜心，但我的内心是极其争强的。我见过的几乎所有的老师都有一种固有的观念，那就是成功者不聪明，失败者不努力。每次有什么讲座或者所谓优生交流之类的事情，都会有老师在上面说诸如谁谁谁并不如你们聪明，谁谁谁是我见过最聪明的学生此类话。我印象很深的是刚开学的时候竞赛生训话，说到我时说我是所有人中最聪明的，但可能会成为最后的“无冕之王”。当我真正取得成绩后，我又成为了所有人中最努力的，最“听老师话的”，其他人代替了我的位置成为了这个老师口中的“最聪明但存在问题”的学生。没人会喜欢平凡的人的故事，人们称赞成功者，惋惜失败者，并试图从他们身上找到一些经验教训，为此他们不惜强说因果，因为没人会选择去从那些玄而又玄的命运或者天赋中汲取经验。</p>
<p>而我听过了太多的反面教材，于是也害怕自己成为别人口中的反面教材。</p>
<p>所以也许我一直都在怕，一直怕别人对我的评价，怕别人说我如此聪明却又不努力，怕别人说我因为一时的恋爱而影响了一辈子，怕别人说我钻研难题而导致基础知识失误。尤其是那些我在意的人。</p>
<p>——《离弦》（写于2023.08.13）</p>
</blockquote>
<blockquote>
<p>我们上个周的作文题是要对这样一句话引出议论：“人生的路程就是这样，用大把的时间迷茫，在几个瞬间成长。”</p>
<p>我写作文的时候对这句话嗤之以鼻，我认为你“迷茫”的时候，也同时是你“成长”的时候。而最终完美的“成长”是不存在的，从生下来的第一天，到死亡的前一天，哪一个瞬间不是在成长呢？</p>
<p>话是这么说，我怕是以前心中却不是这么想的。我经常喊“自己与过去切割了”。逐渐地，我切割的时间点离我越来越近，昨天做的事，道歉之后，今天就切割。我现在觉得，也许这样对也不对，切割意味着你从过去学到了什么而成长了，但切割也意味着你无法接受自己的过去。但过去的事情总在过去，未来的事情总在到来。</p>
<p>我想明天的我大概也与今天的我不一样。</p>
<p>我希望每天的我都在向着那个心目中理想的人前进。</p>
<p>——《枷》（写于2023.09.21）</p>
</blockquote>
<hr>
<p>大学报到也有一段时间了，在校园里待的这几天竟然无比适应，既没有在高中的那种被支配全部生活的禁锢，也没有假期在家里那种一天天无所事事的颓废。总之我愿意说——我希望过几个月、过几年后的我看到这句话不要哑然失笑——我现在真的开始向往着无限可能的未来。</p>
<p>关于我高中的回忆录是我一直想写却写不出的东西。我甚至想过要不要采取另一种荒诞的写法，于是拉来了一大堆人陪我攥写《烟台二中俗世奇人》。当然这个企划最后以一篇稿子都没结稿的蛇头蛇尾的成绩收场了。但我总之真的想写点东西，回忆回忆过去、嘲笑嘲笑校领导、称赞称赞老师、分享分享自己的经验（如果有的话）、以及写写她。</p>
<p>在我写到这段话的前不久我刚刚和高中的几个关系还好的朋友一起出去玩了一趟，当时我们在奶茶店等着奶茶，等着等着我突然说了一句：“欸原来我高考完都一个月多了。”其实你现在要让我回忆高三的生活，我几乎都无法理解当时的自己。为什么我如此脆弱又如此顽强，为什么我真的做到了这一切呢？</p>
<p>但即使从最功利的角度来讲，高三让我上到了理想的大学，让我认识了一些关系很好的朋友，甚至说它还让我有了足够的悲叹的苦难作为创作的源泉。我初中的时候很喜欢一句话，后来我才知道这句话出自陀思妥耶夫斯基，这句话是这么说的：“我担心的事情只有一件：就是我配不上自己经历过的苦难。”直到如今我仍然对这句话感触颇深。我不愿意歌颂苦难本身，但我愿意花大篇幅歌颂经历着苦难的人。我高一的时候有一段失败的恋爱经历，但我后来甚至逐渐对此产生了感激之情——我在经历过那样的痛苦后，竟然反而能因此而读懂不少曾经看不懂的诗歌。</p>
<p>所以我其实还是想要动笔。当然这篇写出来估计要写不少私密性的故事，也要写不少攻击力极强的故事（笑），希望我别被突然询问其中不愿意提起的私密细节，也别被一个电话打过来强制我删稿。</p>
<p><strong>注意：本篇虽然以第一人称写成，但完全是虚构小说，发生背景在一座叫做“亚特尔泽”的学校，和现实无关。如有雷同，纯属巧合！！！！！</strong></p>
<p><strong>注意：本篇虽然以第一人称写成，但完全是虚构小说，发生背景在一座叫做“亚特尔泽”的学校，和现实无关。如有雷同，纯属巧合！！！！！</strong></p>
<p><strong>注意：本篇虽然以第一人称写成，但完全是虚构小说，发生背景在一座叫做“亚特尔泽”的学校，和现实无关。如有雷同，纯属巧合！！！！！</strong></p>
<hr>
<p>我觉得我高三可能被分成了差不多两个部分，分界线大概是《逃》创作的时间左右。第一个部分的主要矛盾是我与腐朽的规章制度之间的冲突，第二个部分的主要矛盾则是我日益增长的美好生活需要和我个人极端性格之间的矛盾。</p>
<p>当然，即使这么说，我对亚特尔泽也仍然是有感情的。这份感情主要来自于我的老师们，我对我高中遇到的教过我的每一个老师都给予极高的评价，我认为他们无论是从师德还是从能力来讲都无比顶尖。其中有一些老师我更是几乎视为人生导师一样的人物。比如高考前几天我情绪崩溃的时候，我的生物、化学、英语、数学老师轮番上阵给我做心理辅导，甚至隔壁班的班主任也来找我聊天，而且这种聊天甚至都没太有身份，我完全在把老师当成哥们在那里聊天。我这么说你可能没太理解我在说啥，我就这么说吧，我们聊天的内容大概分为以下几个部分：首先我发泄一顿高考前的压力；然后老师半开玩笑吐槽我已经很牛逼了就别在这凡尔赛了；然后开始给我讲他们过去教过的很多学生，有一些是很成功很成功的，也有一些是高考没那么成功，但最后总是在发光发热的学生；再之后开始数我比较好的地方，顺便说几个我不好的地方（比如我性格很极端）；然后开始闲聊，我开始问他们上了大学怎么找女朋友，不同老师给出了不同的建议，比如化学老师建议我大一适应一年大二找学妹、英语老师给我讲了点追女生的技巧、隔壁班班主任直接说我高考后看上哪个了她去给我说媒、生物老师更是直接跟我约定高考后给我找个女朋友；最后甚至还会扯一点家常话题。</p>
<p>还有一些很感人的小细节，比如说年级主任经常和我聊很多话题聊到很晚，我的班主任高考前送了我一个刻着“一举夺魁”的木质手链，我的化学老师几乎每场都出现在红毯边上和我击掌，生物老师高考后还经常和我聊家常（内含不少感情问题）。总之我在亚特尔泽这里体会到了相当多的<strong>来自一线教师</strong>的人文关怀。</p>
<p>不过我当然要在这篇文章里大肆夸赞学校的规章制度，如果不写这段我估计可能很多人也懒得看我碎碎念。我前段时间发了个动态是这么说的：</p>
<blockquote>
<p>亚特尔泽学生应该报考猪大的五个理由：</p>
<ol type="1">
<li>食堂的蛋挞是温的</li>
<li>洗手间有无限量的洗手液</li>
<li>椅子上可以随便放东西，地上也可以</li>
<li>有什么东西坏了最多第二天就会有人来修</li>
<li>椅子是完整的</li>
</ol>
</blockquote>
<p>我觉得可能有的校领导看到这段话估计要破防，但我对自己的幽默感自鸣得意。亚特尔泽有很多传奇性的故事，<del>比如我至今为止都没见到第二个中学出现老师和学生联合起来的奇观</del>，其中甚至包含了大量不能碰的滑梯，不过即使是我日常中碰到的小细节也足够让我在这里狠狠发泄一波了。</p>
<p>比如几乎已经成为我知名脱口秀包袱的若干条规章制度，例如椅子上不让放衣服，椅子上不让放书包（地上也不让），水杯不让带到教室里（要在教室外面排排站摆成一排），原则上不推荐学生背双肩包（升旗时多次强调），听说还尝试推行过桌子上不让放笔袋（传言，不知真假，如果是假的我立刻删除并发表《我的忏悔》）。至于什么垃圾桶里不让有垃圾，这个我们倒是没有，因为我们不搞那些形式主义的东西，我们的宿舍和教室里压根没垃圾桶（乐）。至于宿舍里的被子是摆设，这个纯属尬黑，它放在那上面还会占大家睡觉的地方呢，根本就不是摆设。退一步讲，亚特尔泽也曾经试图消灭学生中的形式主义，比如强制要求“叠被神器”无法加分。但后来发现收效甚微，所以又改回来了。</p>
<p>至于亚特尔泽最为人津津乐道的，当然是其认为对学生提高成绩极其重要的三板斧：培优、讲座和班会。</p>
<p>其实关于这个培优我想吐槽的也挺多。但防止有人说我成绩好就高高在上，所以我还是不说话比较安全。</p>
<p>至于这个讲座可以说的就很多了。首先要声明啊，这个讲座办了十几场，肯定是有特别好的讲座的。比如曾经请过一位王老师来给大家讲语文讲座，这也是我唯一一场一点都没摸鱼，甚至有点想哭地听完了整场讲座。讲座拖了一会导致晚放学了，外面甚至还下着大雨。但大家几乎没有人抱怨，甚至连平时最推崇应试教育的那几位优等学生也没有吐槽过一句。反而正是因为外面有雨声，使得里面的讲座格外动人。</p>
<p>写到这我又按捺不住想多写写和这个讲座有关的事。理论上来说，这个讲座应该给我们讲如何写作文，但其实他真正在讲的远远不止作文。</p>
<p>王老师来了后首先给大家讲了一个故事，说他曾经有个文笔特别好的学生（发表了好像是十几篇文章？我记不清数字了），有一次拿了篇作文过来给他看，他一看怎么才$41
$分。仔细一看，认为是这位学生没有开门见山亮明观点，导致阅卷老师错误评估。然后他就劝这位学生说，人在屋檐下不得不低头，低头过去了，后面大片的广阔天地等着你去发展呢。他说这位学生当时用一种近乎悲悯的表情看着他，说王老师你不懂，我是有自己风格的人。</p>
<p>这个故事对我感触颇深，它和我的生物老师LL老师后来某次对我的劝导一起成为了我高中总结的最大的人生经验之一——如果你认为一个事情从任何角度来说都完全不合理，但你又完全没有办法反抗它，你不妨将它视作你人生中逃无可逃也没有原因的一次苦难。我后来某一次给学弟作报告也是这么说的：高三只有一年，再阴暗再苦难也只有一年，撑下来、熬过去。</p>
<p>王老师还讲了些别的，有一些很符合我的文学观点，比如说努力去写一些干净的句子（我忘了他举的那个例子是啥了，可能是这句：“在那个下着雪的冬天，李老师来到了我们的班上。”），还有去写一些冲击力很强的句子（他举了个例子是他让他们班学生写《祝福》读后感的时候，其他同学的第一段全是什么“鲁迅先生生平概括，《祝福》创作背景”，只有一个同学第一段只写了一句话：“太不公平了！”）；还有一些对我产生了很深的影响，比如说他建议少与人交流自己的作品（他举了个例子是如果让你想象一个场景：“最后一堂音乐课，当老师宣布下课的时候，同学们突然起立鼓掌，然后一起合唱了一首歌。”如果不与别人交流，只是在脑中想象，那每个人想象的场景的刻画，班级座位的排布，甚至有几个同学的面孔，以及唱的那首歌到底是什么都是不同的。但如果真交流起来就会趋于同质化）。</p>
<p>还有一些他自己的人生哲学。比如有一句印象特别深的话是：“当你们过个几十年再回忆起自己的高中，也许还包括王老师给你们的这个讲座，可能会有很多不一样的体会。比如你后来带着孙子走在街上，突然发现一个看上去很普通的老太太是你的高中同学。你可能会跟你的孙子这么说：‘看到那个老太太了么，她以前写的诗都美死人呢。’”当然原句我已经记不清了，这个句子是我背在这里的，我毫不怀疑自己的背诵误差导致这句话失去了太多原有的感人的遣词，但原句真的让我当时悚然一颤。</p>
<p>我至今仍然对这位老师，或者说这位长者心怀敬意。</p>
<p>好像说着说着跑题了，那么其它的讲座是不是像这场一样这么好呢？</p>
<p>当然不是，比如请了衡水中学的老师来讲了两次，我印象特别深的是其中一位老师把一位同学当成正面典型来给大家介绍，说这位同学有两个理论：一个叫做光宗耀祖理论，简单来说就是他认为自己的姓氏非常稀少，认为自己应该扛起家族振兴的使命；另一个我忘了叫啥了，好像叫做分流理论么，简单来说就是这位同学觉得自己从小到大跨越了许多阶层，小时候很多玩伴已经远远到达不了自己的等级了，以后他也要尽力地去冲向最高等级，而不是被分流。</p>
<p>我当时立即对这俩理论嗤之以鼻，并且难得地写了一篇议论文发在空间里对这位同学这位老师这个学校大肆批判。我觉得这完全就是社达主义下放到高中教育阶段的活生生的例子。我也给这俩理论起了俩别的名字，一个叫做“过度繁殖理论”，另一个叫作“自然选择理论”。</p>
<p>还请了个xx师范大学的教授来作了个讲座，这个讲座连我们班主任也绷不住了，回来跟我们大喷这个教授就是个骗子。这个教授也有很多抽象的言论，比如认为“高考范文”全是垃圾，这个我小部分认同；还有认为高中语文老师绝绝大部分都是垃圾，这个我当时真没绷住。</p>
<p>其他的基本就是浪费时间的讲座了，连让我喷的资格都没有。</p>
<p>值得一提的是后来还发明了学生讲座，简单来说就是每天晚三找个学生去年级广播给大家灌鸡汤，后来有个牛逼老哥在灌鸡汤的时候脏话频出，遂取消。</p>
<p>至于这个班会，由于我几乎班会全程都在摸鱼，倒是没什么可说的。</p>
<p>当然啊，虽然我们这是一篇架空世界虚构文章，但是卡夫卡曾经说过：“越是虚构的故事，细节处越要真实。”所以我们也可以提很多真实的小细节，用来揭露不能碰的滑梯的一角。</p>
<p>比如当我高考完回校的时候，遇到门口有两个穿得人模狗样的校领导（估计也不是什么很大的官，因为我甚至没见过）在背着手巡视，突然经过了一个遗落在地上的篮球，校领导当时就在这个篮球不到三步远的距离，然后他伸手招呼来了几十米开外的保安，让他来把这个篮球捡起来了。</p>
<p>还有高三的时候突然宣称要“开源节流”然后不让老师给同学印答案了，引起了所有人的一致质疑，后来好像是取消了。</p>
<p>至于什么校领导来听课结果听课本上写了几段字就开始玩手机（甚至在教室外面高分贝打电话）、高考前两个周高三厕所水龙头坏了一直拖到高考都没修、任课老师在课上吐槽校领导不会教书瞎指挥这些事情更是老生常谈，蓝的盆。</p>
<hr>
<p>我们亚特尔泽还有一对“双子星”，俩人为亚特尔泽的风评一起做出了突出贡献。</p>
<p>一位老师，我们不妨称其为花沫兮老师，被我们称作压在学生身上的三座大山（其实不止三座）之一。这位老师以一名一线教师的身份（甚至都没教过我），跻身进我专门为校领导著书立专的故事中，可见他的传奇性。首先我不得不在这里高度赞扬花老师的教学水平，不仅在课上错误频出，还经常自信地认为自己的方法比学生的方法简单。当然作为一名老师来说，这点小事根本瑕不掩瑜。花老师是一位坚定的进步主义者、禁步主义者、紧捕主义者。比如原本我们学校的早读时间仅仅是$6
: 25
$，这个时间不仅一点都不吉利，更是体现不出我们学校制度的优越性和进步性。王安石曾经说过：“度义而后动，是而不见可悔故也。”于是花老师秉持着“苦一苦学生，骂名班主任来背”的想法，敢冒天下之大不韪，毅然决然将早读时间提前到了$6
: 20
$。这一举动立即得到了领导的赏识，从而引起了对其他保守而不愿改革的班主任的思想教育，并且逼迫他们去对学生进行同样的思想教育。这一举动自然引起了部分不理解领导苦心的学生们的无耻辱骂，人们不感谢花老师，花老师如同一位悲剧英雄一般百遭辱骂，令人不禁潸然泪下。但花老师以为，“至于怨诽之多，则固前知其如此也。人习于苟且非一日。”因此，人们的反对没有阻碍其进步的脚步，其更是进一步将他自己的班级的早读时间提前到了$6
: 18 $。而且还觉得不够进步，将早饭时间从$30 $分钟缩短到了$23
$分钟，将午饭晚饭时间从$30 $分钟缩短到了$25
$分钟。说到这里连我都感动地热泪涟涟，这些正确无比的决定甚至只能在他自己的班级实行，而不被广大的群众所接受，如此正确的政策竟然被同学们自己拒绝了。在我心中，花老师的形象更是如同乾隆帝一般伟大。甚至于花老师的班级在级部中也享有盛誉，当其他班级的同学看到他们班的学生来回奔波在教学楼和食堂之间、挥洒着青春的气息的时候，无不鼓掌脱帽致敬。</p>
<p>花老师对他的学生们更是展现了父亲一样的关爱，包括但不限于：翻学生书包以文明其精神、在临冬（还没下雪）的时候要求大课间出去溜达的同学在门外站着（最后自然是感冒了）以野蛮其体魄。</p>
<p>另一位老师，我们不妨称其为舒昂建莎老师。舒老师几乎可以称得上是亚特尔泽的标志性人物，之前我们提到的若干条规章制度几乎全是他一手操办的，可谓亚特尔泽真正的九千岁。我在这里引用一个故事来给大家展现舒老师的传奇性：</p>
<blockquote>
<p>在亚特兰大地区大会上，领导强调：有的同学在双肩包里放课外书，老师们应该加强管理。
亚特原泽的同学们懵了，他们不知道什么是课外书。
亚特撒泽的同学们懵了，他们不知道什么是老师。
亚特尔泽的同学们懵了，他们不知道什么是双肩包。</p>
</blockquote>
<p>舒老师的身影无处不在，作为亚特尔泽的九千岁，他如同一个幽灵一般徘徊在学生身旁。他和花老师如同亚特尔泽的萧何和韩信一般，为亚特尔泽的长足发展做出了卓越的贡献。</p>
<hr>
<p>然后可能无法避免要谈到的一个事是“献给蔷薇系列”的创作。</p>
<p><del>不过笔者写到这里已经很晚了，中午发烧了而且明天要早起，所以先中断一下，有时间再补。</del></p>
<p>“蔷薇系列”的创作背景正是上面以一种很欢乐的方式讲的传奇故事。我现在讲起来很乐，大家听起来也很乐，但在当时对我来说实在是乐不起来。我首先就无法理解这些逼规则，对大家的学习助力完全是负的（虽然其实从各种角度来说都促进了班级同学的团结，甚至是同学和老师的团结），所以从开学我就跳反了，装上诸葛连弩，给所有校领导套上铁索连环就开始扔酒火杀。结果自然是被约谈了无数次。这个时候我才明白了这些规则得以推行的背后原理：如果你遵守这些规则对你的学习帮助可能是负一，你不遵守这些规则可能对你的学习帮助可能是正一，这样学生们自然不会遵守规则，校领导怎么能满意呢！所以他们就有了一个天才般的想法，那就是只要你不遵守规则，就通过不断约谈的方式给你施加一个负十的惩罚值，这样遵守规则就是最优解了。我们班的想法更天才，那就是分小组后采用量化连坐制度，彻底堵死有些人决心反抗到底的最后意愿。</p>
<p>还有一个背景是，我也许始终没有从高一的失败感情经历中走出来。这导致我几乎无法和其他同学正常交流，努力将自己封闭起来。我在这个过程中的思考后来写成了《白鸟》这篇小说。</p>
<p>在这几个背景下，小说《谶》就此诞生。</p>
<blockquote>
<p>那仅仅一句话就彻底改变了我所有的生活习惯，将我生命中所有的亮色夺走。我想要反抗这一切，反抗这个世界强加给我的一切，反抗这生命，以及这生命强加给我的一切。我被无缘无故抛到了这个世界上，从生下来就被迫被社会所塑形。他们先是给我讲这个或那个圣人，然后讲这个或那个圣徒，最后讲这个或那个死刑犯，以此击破我妄图在世界中保持自我的私心。他们逼迫我沦落为常人，逼迫我脱离自己的存在，逼迫我混入世界之中被他们物化，原因只是因为他们认为这样做是对的，先前所有人都是这样做的。他们不会在意你的做法有没有道理，再正确的做法也可以挑出二十个缺点。他们忽略你自身的独特，用一个个更加偶然的例子来激励你，然后对那些不符合他们思考的例子则视之为“幸运”的特例，然后置之不理。</p>
<p>——《谶》（写于2023.11.13）</p>
</blockquote>
<p>虽然小说中的主角从此破除了枷锁，但现实中的人没有。我在写完小说后虽然一直以小说主角为偶像，但其实到最终也没做到那样。原因很简单：我只是一个人。</p>
<p>的确，几乎所有的学生都痛恨这样的制度，但我怎么能像小说中的“言”一样找到那个属于她的“贺”呢？我完全没有任何援助，只能眼睁睁看着自己原定的计划被一次又一次约谈打破。</p>
<p>那段时间晚上回家之后基本就是躺在床上躺尸，因为我太累了、太累了，我那段时间经常躺在床上，一边痛恨自己的颓废一边又没有意志力能支撑我爬起来完成自己的目标，脑子里经常回绕的是海子的那句诗“面对大河我无限惭愧，我年华虚度，空有一身疲惫。”但同时我又深深沉溺于这种痛苦所带来的副作用，我在反抗中感受到了自己在朝着自己的理想的模样前进并为此深深自豪。这种生活提供了《逃》《眼》《刺杀》的背景。</p>
<blockquote>
<p>我喜欢幻想自己的未来，也喜欢回忆自己的过去。</p>
<p>我当然这样是不对的，我在逃避现实，可我能怎么样呢？</p>
<p>我那天嘲笑自己，觉得自己幻想过的未来好像一个都未曾来过。所有的重要的事都在意料之外。</p>
<p>我还嘲笑自己，自己回忆过的过去，幸福的美好的记忆我回不去，痛苦的悲惨的记忆我改不了。</p>
<p>我有的时候觉得自己的未来一片光明，阳光太过迷幻。</p>
<p>可有的时候又觉得毫无希望，不如死了算了。</p>
<p>我很羡慕高一的我，意气风发，自命不凡，觉得只要自己足够努力，只要自己的感情足够真挚，自己什么都可以做到。觉得自己一定在走向幸福。</p>
<p>现在的我却是瞻前顾后，考虑一切现实的因素。</p>
<p>——《你有想去的地方吗》（写于2024.06.01）</p>
</blockquote>
<p>我真正没有想到的是，在这种情况下，竟然会出现一个女孩。</p>
<p>我后来想到这个事的时候有的时候都觉得是神迹，像是老天爷为了救我而降下的神恩。但这么说其实非常高高在上，搞得自己像是天命之选，并且模糊了她自己的独立人格，很不公平。</p>
<p>具体细节我还是不讲了吧，你可以想象在这种情况下的我，甚至已经打算几乎断绝自己和别人的社交的时候，突然遇到一个很温柔主动帮助我的女生，这对我来说还是一个挺大的奇迹的（笑）。当我在一个如此阴暗潮湿的环境下，甚至班里同学大概只能认识三分之一，能和个位数同学聊上天的前提下，突然有了这么一个人。即使我一开始没有动容，后来每次跑操或者什么别的活动看到她了，一想，哦，她是那个对我很温柔的女生；当自己哪天非常绝望的时候，一想（虽然感觉是郭楠幻想）也许还有一个人愿意对我好，这种日积月累的情感是很恐怖的。</p>
<p>最终我干了一件很不理性的事，我为她写了一篇小说《逃》。</p>
<blockquote>
<p>可能很多人都觉得我执念太深，其实我自己也是这么认为的。在经历过种种后，这执念本身甚至加上了许多理性的束缚。我觉得自己一直都是一个追求幸福的人，哪种选择可能走向幸福，我就去走哪条路。但真正选到死路之后，我才发现原来世界没有那么简单，不是真的，只要有理想和爱，就什么都可以做到。</p>
<p>起码，我改变不了别人。我做不到让一个不爱我的人爱我，做不到让不理解我的人理解我，做不到改变顽固不灵的人的想法——或者我自己也是一个顽固不灵的人。我也不可能，不可能像所有童话故事一样，等到救赎自己的精灵，等到一股强大的外力将我现在的所有囚笼击破，等到一位天使将我救赎。</p>
<p>……</p>
<p>我有的时候自嘲，说自己每次想要改变的时候，可悲的事情就会一件接着一件纷至沓来，仿佛是命运逼迫我成为行尸走肉一样。</p>
<p>好像总有人在充当命运的刽子手，一刀一刀将我活剐成一具骷髅。</p>
<p>我有的时候甚至以为，救赎是一个标志，是命运终于允许我拥抱幸福的标志。只有有了这种允许，我才能抬起头来生活，将自己从无尽的悲哀中拽起来，看看太阳。</p>
<p>这个标志是什么呢？也许是一次巨大的成功，是时来运转的惊喜，是一个爱着你的人，无微不至体贴你的所有。</p>
<p>但后来我明白了，原来救赎其实是，你坠到沼泽中，全身都被脏泥淹没的时候，好像听见有人在叫你。你突然睁开眼睛，看了看太阳。</p>
<p>原来太阳是那么耀眼，原来周围的叶子也可以反射太阳的光，原来空气中的尘埃都在光影中浮动着，绽开着。</p>
<p>你想看看是谁在喊你，可你无法动弹。</p>
<p>你拼了命向上爬，即使口鼻中全是污泥和脏血，即使四肢被厚重的泥土压到畸形。原来还有人在叫你，原来还有人爱着你，原来这个世界如此美丽。</p>
<p>你用尽自己全部的力气，像是生出了额外的羽翼，你从此不甘心被活埋，被忘记，被裹挟在地下沉睡成百上千年后化成黑水。</p>
<p>你向上爬去，终于会爬出沼泽，会带着一身的伤痕站在地上，四处望着是谁在呼唤你。</p>
<p>至于到底有没有人，至于你愿不愿意相信刚才这里存在过一个人，至于你愿意相信她是谁，这完全取决于你。</p>
<p>——《逃：后记》（写于2024.04.30）</p>
</blockquote>
<p>等我写完《逃》第二天看到她的时候，我突然感到一阵悸动。我在想，她知不知道我为她写了一篇小说呢。</p>
<p>我想我大概是喜欢上她了吧。</p>
<p>这是很致命的。就如我上面所说，我一直都可以意识到自己是一个性格很极端的人，她没有任何可能喜欢上我这样的人。我当然清楚她表现出来的友善大概只是礼貌，但我深陷其中，完全如同将要溺死的人试图抓住稻草。</p>
<p>我明白这感情没有结果、甚至还会影响高考，但又深深陷在这个光影飘散的水晶迷宫中走不出来。我真的从未有过如此狼狈。</p>
<p>但也正是这种情况下，她那天突然开了个玩笑。</p>
<p>现在看可能觉得那句话只是玩笑，但我当时真的将其视作灯塔的曙光。我终于可以有一条救赎的道路，终于有人指出了一道宽阔的大门。</p>
<p>我终于将要得救了。</p>
<blockquote>
<p>终于我闭上了眼流出了泪放下了手，我站起身迎着窗外。她的面容浮现了出来，朝我轻轻地笑。</p>
<p>她真的好美。</p>
<p>我睁开了眼。玻璃上仍然是我的倒影。</p>
<p>我真的很丑。</p>
<p>可这个世界真的好美。</p>
<p>——《眼》（写于2024.06.10）</p>
</blockquote>
<p>但后来证实了，这一切真的只是我的幻想。</p>
<p>所以就有了《青蛙王子》和《刺杀》这两篇小说。</p>
<blockquote>
<p>他以为自己是受了诅咒的王子，但在她眼中它只是只戴着金冠的青蛙。</p>
<p>——《青蛙王子》（写于2024.06.17）</p>
</blockquote>
<blockquote>
<p>等人们发现你的时候，你扑在蔷薇花丛里。人们把你救出来，你的全身被二十三朵蔷薇花刺穿，其中一朵刺穿了心脏。</p>
<p>——《刺杀》（写于2024.06.21）</p>
</blockquote>
<p>我后悔吗？</p>
<p>我一直都笃信一个事，那就是人不应当压抑自己的情绪。我一直很不喜欢别人劝我、甚至是要求我去乐观开朗向上，我觉得一个人的情感是属于自己的，我应该在我想哭的时候哭，想笑的时候笑。</p>
<blockquote>
<p>也狂欢着 也狂笑着 青春是官能的王国</p>
<p>也淋漓着 也耽溺着 血液中蒸沸快乐</p>
<p>——Kevinz《猜火车》</p>
</blockquote>
<p>我当然不后悔。</p>
<p>这段略显幼稚肉麻而且夹带郭楠幻想的故事可能放在这里会被很多人吐槽吧（笑），甚至有可能当作梗广泛流传，以后也许有许多人都一边玩着梗一边魔改着其中的某一句话一边嘲笑我的失败，也许我过不久就会把这段话从这篇文章里删掉。</p>
<p>但我真的不后悔。即使我们以后的人生大概再无交集。</p>
<hr>
<p>也许过几年我会忘记很多事，但高考前那个夜晚，我突然回忆起了我高三的故事，我想起了过去的痛苦，我也畅享着未来的美好，我终于鼓起了全部勇气冲向了现在。因为我真的有想去的地方，因为我真的有想见到的人。</p>
<p>高考前感冒还有点低烧，但是我反而一点都不害怕了。</p>
<blockquote>
<p>确实，有时最离奇古怪的念头，看来根本难以置信的想法一旦牢牢地占据了你的脑海，最终，你就会认为这种想法是可以实现的⋯⋯此外，如果这种想法与强烈的、疯狂的愿望结合在一起，那么，有的时候，你最终会把这种想法看作是命中注定、无可避免的事情，认为它是不可能不存在、不可能不发生的了！也许，这里还包含着别的什么，包含着许多预感、非凡的意志力，对自己想入非非的沉迷或者别的东西——我不知道。但是，这天晚上（这个夜晚我终生不会忘记）在我身上产生了奇迹。虽然这个奇迹可以用算术知识加以诠释，但是，对我而言，它至今仍然是一个奇迹。当时，为什么这种自信会深深地、牢牢地印在我的心中，而且早就如此？究竟是什么原因？确实，我再重复一遍，我没有把它看作那种可能发生、因而也可能不会发生的偶然，我认定它是那种无论如何都不可能不发生的必然！</p>
<p>——陀思妥耶夫斯基《赌徒》</p>
</blockquote>
<p>高三的时候把<a href="https://music.163.com/song?id=2058806421&amp;uct2=U2FsdGVkX1/Cbeq60Q5irnrpFBmGevhxb3gkBGECxVw=">《猜火车》</a>听了好多好多遍。直到现在我的qq签名还是里面的那句“而唇瓣风干锈死之际，谁先一步释怀。”</p>
<p>我当然不知道未来会发生什么，我现在也仍然是坐在轨道旁猜火车的少年。</p>
<p>但我仍然想要记录过去。如果过去的故事不够圆满、充满遗憾，那我希望起码以此文来为过去画上一个圆圆的句号。</p>
<blockquote>
<p>……</p>
<p>欲念和浓烈狂热 身体内一并痉挛厮磨</p>
<p>血管过电生枝杈 镶嵌在皮肤和骨骼</p>
<p>世界不关己事 我只需选择全都不选择</p>
<p>啡肽与荒草里 猜远处不停脚的列车</p>
<p>爱是反叛 是瘟疫 是革命 是疯魔成活</p>
<p>每名少年都周身赤裸 借由本能作则</p>
<p>洁持中跌堕 潮林里纵火</p>
<p>阳光越迷幻 你越深熔化进我</p>
<p>……</p>
<p>最坏也最好的年代 未来即是永不到来</p>
<p>开一窗逼仄屋室 蓦然涌起滂沱火海</p>
<p>我们在迷离眼光中 反复读懂每个现在</p>
<p>而唇瓣风干锈死之际 谁先一步释怀</p>
<p>生命是违逆 是服从 是有预谋的意外</p>
<p>每名少年都试图 一边告别 一边告白</p>
<p>洞察与窥猜 胡乱生青苔</p>
<p>阳光太迷幻 以至我脚步加快</p>
<p>……</p>
<p>我们终将归于沉寂 令一切都失去意义</p>
<p>反叛着反叛 接受没道理的 不无道理</p>
<p>于是这世界突然美好 突然通透而瑰丽</p>
<p>甚至令人忘记开篇 何其宏伟的命题</p>
<p>——Kevinz《猜火车》</p>
</blockquote>
<p>（写于2024.08.26）</p>
<p>（谨以此文纪念我的高三生涯）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>壬寅年末</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E5%A3%AC%E5%AF%85%E5%B9%B4%E6%9C%AB/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#后记">后记</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>单翅鸟为什么要飞呢</p>
<p>（海子《单翅鸟》）</p>
</blockquote>
<p>谢谢你点开这篇文章。你会是谁呢？也许是恩重如山的老师，也许是相识相知了多年的挚友，也许只是点头之交、萍水相逢。</p>
<p>我不清楚你的身份，也不知道是什么时候你点开了这篇文章。也许是烟花璀璨的夜晚，也许是繁华散尽后的第二天清晨。我不是造物主，我毕竟无法预测到一切。</p>
<p>好吧，我知道在很多人眼里，我在一夜间性情大变。我知道在很多人眼里，包括很多正在读文章的人眼里，我突然变得不可接近、不可理喻。我在一夜间退出了所有的小群，删掉了一批又一批的好友。即使是现在在看文章的你们——我所信任的挚友或是所认同的善良的人，我相信我也可能曾以某种举动伤害过你们。我很抱歉。所以我想，在这一时刻，无论你是谁，我们两个像朋友一样好好聊一聊。我知道似乎没有什么好说的，我也知道人类的悲欢并不相通，我更知道一切的一切都不是我自我孤立，将自己闭塞起来的借口。我不奢求原谅，不奢求理解，不奢求别人将我捧得多么高——就像他们曾经做的那样。我只是想给过去的一年一个交代，写下一个并不完美的句号。人生太长太长了，我不知道等我百年之后再看这一年，我会如何评价它。我无法预料这一年对我的人生会有什么影响，更不知道命运会如何安排，不知道道路通向何方。但我想记住这一年，记住我的变化、我的心情，记住我所经历过的一切。我也想给我的朋友们一个答复，一个道歉。</p>
<blockquote>
<p>生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p>
<p>（马尔克斯《百年孤独》）</p>
</blockquote>
<p>有人对我说，我太爱憎分明了，因此活得很累；有人对我说，我道德感太强了，所以容易幻灭；有人说我过于桀骜不驯了，不懂得收敛自己；还有人说，我太刚了，易折。我不知道谁口中的我是真正的我，也许都是，也许都不是。每个人都以自己的方式理解对方，每个人都不一定能理解对方。我看不透，我也不想用别人的评价来概括我这个人，概括我的这一年。我的朋友，我更想，给你讲讲我这一年的故事和感受。</p>
<blockquote>
<p>人只是他企图成为的那样，他只是在实现自己意图上方才存在，所以他除掉自己的行动总和外，什么都不是；除掉他的生命外，什么都不是。</p>
<p>（萨特《存在主义是一种人道主义》）</p>
</blockquote>
<p>我要从何讲起呢？我想起来写前几篇文章的时候，都会放《猜火车》这首歌，而我已经好久没听过它了：猜火车的少年已经长大了，他知道该何去何从了，知道前路该如何走了。他要做的只是去努力赚得那一张火车票，去搭上那一班他清楚目的地的火车。</p>
<p>不过，除开《猜火车》，也许有别的歌，更适合描绘这一年的图景。</p>
<blockquote>
<p>我会永远记得年迈的他拍拍我额头</p>
<p>说：</p>
<p>“别难过，人生路很长，总有人要先走”</p>
<p>（瞳荧《我从人间走过》）</p>
</blockquote>
<p>愿逝者安息，如果有来生……</p>
<p>一定会有来生。</p>
<blockquote>
<p>他问为什么你看起来比我还悲伤</p>
<p>这种人生已经算不错的模样</p>
<p>承认普通接受平庸然后随波流淌</p>
<p>成为别人故事中的稀疏平常</p>
<p>（瞳荧《张小北》）</p>
</blockquote>
<p>一开始，我将自己的qq
ID改成了张小北的想法是：我要提醒自己，自己并非什么天生英才，并非天选之子，我只是一个普通人，我应该努力做好普通人应做的事，应该努力让自己不普通，成为所谓“了不起的人”。</p>
<p>但后来，当我见的太多了之后，我才发现，我怎么敢将自己标榜为普通人。</p>
<blockquote>
<p>我以为自己是个普通人，直到遇到了真正的普通人，才发现我拥有的已经是他遥不可及的幸福。（《张小北》评论区）</p>
</blockquote>
<p>我所经历过的我以为是锥心刺骨的生离死别，难道不是大多数人，大多数普通人都要经历的吗？我如何敢标榜自己生不如死的痛苦，我如何敢称自己平庸无比？我如何敢用平庸掩盖自己的失败？我如何敢说自己已经努力到极致？我曾以为我足够努力，这一切都是我应得的。但其实这一切只是我足够幸运不是吗？若我比其他人更聪明，比其他人理解得更快，那这本是上天的安排，是造物主的赠礼，我如何敢将这功劳全然安到自己身上呢？</p>
<p>从那之后，我或许才真正确立了人生理想：我已经经历了苦痛，我要帮助那些苦痛中的人幸福，我要帮助他们远离痛苦；我已经足够幸运，我要帮助那些不幸的人，帮助他们过上幸福的生活。</p>
<p>但我如何确认，我这种感情不是居高临下的怜悯？我如何确认这是真正的善良而不是所谓的责任心？我如何确认我不是将自己摆在了救世主的高位，并且傲慢地认为自己有资格当救世主？我如何确认呢？</p>
<p>我不知道。</p>
<p>我连我自己都看不透。</p>
<p>有人说伪君子虚伪了一辈子，那就是真的君子。</p>
<p>可明明虚伪到连自己都被欺骗，才是最大的悲哀。</p>
<p>我不知道这一切是不是我在自我欺骗，我不知道我自我封闭究竟是为了保护他人还是为了保护自己，或者更有可能只是纯粹的偏见。我不明白。我看不透。</p>
<p>我不知道我会不会找到答案，无所谓。我只希望，我能永远保持对苦难中的人的同情心和同理心，以及尊重，足够的尊重。我希望我能永远认为自己是张小北，也永远将别人认作张小北。我希望自己将每一个人视作历经苦痛仍热爱生活的人，即使我对他们有偏见，也应该想到他们所曾历经的苦痛。我应该尊重每一个人，每一个思考着世界的，感受着生活的人。</p>
<blockquote>
<p>“设想一切，但就是不把我当人看。你一再宣称我在接受实验前什么也不是，我知道为什么。因为如果我什么也不是，你就可以成为我的上帝和主人。你无时无刻憎恨我不知感恩，但信不信由你，我确实感激。然而，你为我做的事尽管美妙，你却没有权利可以像实验动物一样对待我。我现在是个独立的个人，但查理在走进实验室前，同样也是独立的个人。你看起来很惊讶！是的，突然间我们发现我一直是个人，即使以前也是，这对你的信念是一大挑战，因为你认为智商低于一百的人不值得被当人看待。尼姆教授，我相信你看我的时候，你的良心会感到不安。”</p>
<p>（丹尼尔·凯斯《献给阿尔吉侬的花束》）</p>
</blockquote>
<p>但同时，我的同情不应该成为伤害过我的人的盾牌。我曾做错的，是把别人对自己的伤害全然当作自己的错——仅仅因为他们也受过苦难，仅仅因为他们也不易，我就认为自己应该承受一切。我不会再这么做了。</p>
<blockquote>
<p>任由着你躲闪我追赶你走散我呼喊</p>
<p>是谁在泛泛而谈</p>
<p>任由着你来了你笑了你走了不看我</p>
<p>与理所当然分摊</p>
<p>不明白残存的没用的多余的不必的</p>
<p>破烂也在手紧攥</p>
<p>不明白谁赧然谁无端谁古板谁极端</p>
<p>无辜不知所以然</p>
<p>（陈粒《小半》）</p>
</blockquote>
<p>我该如何说呢？</p>
<p>现在回忆起来，一切都好遥远，故事好像从没发生过，也好像从没结束过。我几乎想象不到我当时的心情了，也几乎理解不了我当时的做法了。</p>
<p>做了一场好长好长的梦啊。</p>
<p>好吧，我懦弱，我自卑。我曾将一切都认作我的错。我曾卑微到泥土里，卑微到尘埃里，可最终也没开出花来。无所谓了，我不要在乎这些了。</p>
<p>我现在回看一切才发现：</p>
<p>我从未愧对过任何人，我只是对不起自己。</p>
<blockquote>
<p>或许故事还未结束。</p>
<p>或许故事早就结束。</p>
<p>或许故事从未开始。</p>
<p>或许故事尚未开始。</p>
<p>或许故事不会开始。</p>
</blockquote>
<p>我所盼望着的爱恋，我所向往着的理想的爱人，那个爱我如爱她自己的人，那个和我一样将道德与感情一起摆在首位的人，那个愿意为了爱情放弃所有的责任和幸运的人，我如何知道她什么时候出现呢？</p>
<p>我不知道。</p>
<p>人无法预知自己的命运。</p>
<blockquote>
<p>我把石头还给石头</p>
<p>让胜利的胜利</p>
<p>今夜青稞只属于他自己</p>
<p>一切都在生长</p>
<p>（海子《日记》）</p>
</blockquote>
<p>好吧，我的，壬寅年的故事，写到这里。</p>
<p>马上就是新的一年。</p>
<p>这一年我承受了许多苦痛。</p>
<p>这一年我遇到了很多朋友。</p>
<p>这一年我有所作为又虚度光阴。</p>
<p>这一年我曾光辉熠熠，也曾跌落谷底。</p>
<p>故事还没有写完，新的一年，故事还要继续写。</p>
<p>一切还没有结束，我还要等那一班火车。</p>
<p>那片我所梦的校园，那个我所梦的人在远方等我，</p>
<p>她在等我。</p>
<blockquote>
<p>我很清楚，干游侠骑士这一行，总免不了要吃尽千辛万苦。可我也知道随之而来的无尽福祉。我也懂得，美德只能走在狭窄的小径上，而罪孽却沿着宽敞的大道横行。可我心里有数，两条路的终点和归宿完全不同：罪孽之路虽然宽敞，却最终导向灭亡；而美德的小径尽管狭窄崎岖，但一直通往新生，不是有限的新生，而是没有止境的永生。就像咱们卡斯蒂利亚一位大诗人说的那样：沿着这条崎岖的小径步入天国，获得永生，从此是一颗不落的星。</p>
<p>（塞万提斯《堂吉诃德》）</p>
</blockquote>
<p>我不知道明年的故事会怎么写，我不知道谁是执笔人，更不知道祂会如何对待我。</p>
<blockquote>
<p>若云端之上，果真有主掌一切的神明，</p>
<p>那祂是否知晓一切，拨弄着我的命运；</p>
<p>若宇宙之间，果真有普适万物的规律，</p>
<p>那是否在我降世时，故事就已经写定。</p>
<p>（写于2022.07.09）</p>
<p>是否神明要将我掩埋，</p>
<p>让腐烂泥土中沉睡我的骨骸？</p>
<p>是否太阳的光芒早就不在，</p>
<p>只剩下一个癫狂的人，向着东方，顶礼膜拜。</p>
<p>（写于2022.10.05）</p>
<p>考前跟同学说，我特别讨厌自己不能掌控的局面。那些即使我拼尽全力也无法改变的局面，我是难以面对的。结果还真是一语成谶，现在我的命运脱离于我手中了。</p>
<p>每次听歌，听到《猜火车》的时候总是有别样的感觉：那种青年的迷茫，所谓“未来即是永不到来”的迷茫。我记得曾读过的句子：“对自己命运掌控权的过度追求，是妄图以微弱的天赋和丝毫的努力，挑战造物主的疯狂。”想来大抵如此。</p>
<p>好吧，我不知道故事会不会就此结束。故事开始的时候没有人会一下就注意到，故事结束的时候没有人会相信这已经是终页。造物主的笔永不停歇，没有人会永远是主角。</p>
<p>（写于2022.11.29）</p>
</blockquote>
<p>我不知道，我能不能给自己一个满意的结局。</p>
<blockquote>
<p>这几天经常想：如果我联赛考砸怎么办？如果我省选失利怎么办？如果我国赛出错怎么办？</p>
<p>如果我没能考上北大怎么办？</p>
<p>所有人都在问我这一个问题。</p>
<p>所有人都等着我作出回答。</p>
<p>他们告诉我：一旦我输了，我就全完了。</p>
<p>他们跟我说：一旦我失败了，我将永远翻不了身。</p>
<p>他们是谁呢？</p>
<p>（写于2022.10.08）</p>
</blockquote>
<p>我不知道，是否会有一天，我也再也支撑不住自己。</p>
<blockquote>
<p>英国的乌鸦被屠戮至消亡</p>
<p>高卢的骑士也无人再颂唱</p>
<p>（写于2021年）</p>
<p>好吧，他们说这苦难是神明的考验，</p>
<p>为了使我重生，来迎接前路的遥远。</p>
<p>难道未来真的不能由我自己去选，</p>
<p>要前行，就要流着泪告别、放弃一切？</p>
<p>好吧，他们让我仔细看看这人世间，</p>
<p>哪里不在上演悲欢境遇，生死离别。</p>
<p>难道因为世事无常，悲剧万万千千，</p>
<p>我就只能哭或笑着接受，无力改变？</p>
<p>（写于2022.07.09）</p>
</blockquote>
<p>我知道，我身上寄托着许多人的期盼。</p>
<blockquote>
<p>那些梦并未散去只化作星火</p>
<p>那些事，铭记在某刻</p>
<p>那些人亲吻我后转身走过</p>
<p>我才能是我</p>
<p>别再问，曾经的事有没有如果</p>
<p>别再怕被浪花淹没</p>
<p>（写于2022.05.19）</p>
</blockquote>
<p>我知道，还有许多在苦难中的人，我想要去帮他们。</p>
<blockquote>
<p>愿贫穷的人儿能免于饥荒</p>
<p>愿痛苦的人儿能重拾希望</p>
<p>愿迷茫的人儿能找回方向</p>
<p>愿努力的人儿不失所望</p>
<p>（写于2022.11.05）</p>
</blockquote>
<p>我知道，我还想找到那个她。</p>
<blockquote>
<p>纵使湛蓝如同梦幻；</p>
<p>纵使吹面只是北风寒。</p>
<p>（写于2021年）</p>
<p>你在哪里？</p>
<p>你是森林中飞鸟的歌音，</p>
<p>还是山野中风的呼吸？</p>
<p>是星河中闪烁的光明，</p>
<p>还是月色下静默的冷清？</p>
<p>你生来和光同尘，</p>
<p>却注定大象无形。</p>
<p>（写于2022.12.20）</p>
</blockquote>
<p>我知道，未来的路也许并不好走，但我也一定要走下去。</p>
<blockquote>
<p>活在现在的人已走向未来，</p>
<p>信步前行，满载幸福的回忆；</p>
<p>活在未来的人早死于现在，</p>
<p>还幻想着一切会如同过去。</p>
<p>（写于2022.07.09）</p>
<p>我所追求的一切，如果在这一刻或某一刻崩塌了，我该如何做？我该认为我所追求的都是无用的吗？我该自暴自弃地认为故事该结束了吗？</p>
<p>（写于2022.08.24）</p>
<p>我是个懦夫，所以我不敢回看过去了。</p>
<p>我也是个勇士，因为我要看向未来了。</p>
<p>（写于2022.12.18）</p>
</blockquote>
<p>我相信，我将永远爱着世界，爱着生活。</p>
<blockquote>
<p>生命多么美好，像晨星一样，</p>
<p>挂在天空，发一份很弱的光，</p>
<p>带给夜色中的人一抹微亮。</p>
<p>死亡多么美好，像流星一样，</p>
<p>划过天空，然后只留下愿望：</p>
<p>愿我死后的世界鸟语花香。</p>
<p>（写于2022.07.09）</p>
<p>如果我还有时间，我还有能力，我希望自己能为所有因为这样或那样的原因和我一样痛苦或比我更痛苦的人做些什么，我想让他们幸福，即使我自己都不知道，我还可不可能得到幸福。</p>
<p>“你是来寻找本质的吗？”</p>
<p>“我是来感受存在的。”</p>
<p>（写于2022.09.26）</p>
</blockquote>
<p>我相信，我将永远尊重他人，尊重自己。</p>
<blockquote>
<p>所有人都相信自己是独一无二的，没有人能接受自己的平凡与从众。所以有了叛逆，有了为了“标新”所以“立异”的行为。但很多人往往忘记了，即使最最平凡的普通人，他们身上也有不可磨灭的光芒——道德。</p>
<p>有人认为，罪犯反而是最接近自然的人类，因为自然本就是残酷的，野兽的目的仅仅是自己的个体或族群的存续。而人不一样，我们会注重自身，会有很多人利己、自私，但大部分人仍然秉持着道德，接受着道德：我们认同“己所不欲，勿施于人”，我们认同“达则兼济天下，穷则独善其身”，我们会替别人考虑，我们会思考自己的行为是否对别人产生了伤害。这是我们套在自己身上的枷锁，我们会被枷锁勒痛勒伤，我们会对此感到抱怨，但很少有人尝试去挣脱。因为挣脱了，会有更多的人受到伤害。</p>
<p>（写于2022.04.29）</p>
</blockquote>
<p>我相信，有一天，薄荷会开出淡蓝色的花。</p>
<blockquote>
<p>若我有一天得以一睹灿金的世界，</p>
<p>得以亲吻真正的鲜花，</p>
<p>我也相信她是薄荷的升华，</p>
<p>是我以泪感动上苍得到的奖赏。</p>
<p>（写于2021年）</p>
<p>“我的薄荷正在生长。在月光下，我看着她一点一点长高，伸展出几片淡绿的叶子，散着那股我永远忘不掉的清香。我看着她长出两片含着的叶子，然后它们缓缓张开，里面是一朵淡蓝色的薄荷花。月光洒在上面，像是云散在天上。”</p>
<p>（写于2022.11.13）</p>
</blockquote>
<p>我相信，我将与崭新的灵魂一同醒来。</p>
<blockquote>
<p>尘之花啊，请盛开在这世界</p>
<p>多反射一束光，多舒展一寸羽翼</p>
<p>才能离湛蓝的天空更近</p>
<p>才能触碰那至善至美的神明</p>
<p>才能亲吻那有着洁白双翼的天使</p>
<p>才能以光将影消弭</p>
<p>尘之花啊，我知你生于毫末</p>
<p>我知那影仍要戕害于你</p>
<p>我知你不甘居于这丑陋身躯</p>
<p>但请你相信：</p>
<p>待你的生命散尽</p>
<p>有些会下落，拥抱大地</p>
<p>有些会上升，触摸天际</p>
<p>有些会在人世弥漫</p>
<p>组成另一朵花的魂灵</p>
<p>（写于2022.10.15）</p>
</blockquote>
<p>我相信，我会铭记着所有过去的记忆，向未来走去。</p>
<blockquote>
<p>你曾遁入黑暗之中，</p>
<p>在秋雨中坠落，在时间中沉默。</p>
<p>陪伴你的是腐烂泥土里肮脏的昆虫，</p>
<p>拥抱你的是万丈深渊下无尽的夜色。</p>
<p>（写于2021年）</p>
<p>我打算再买一支新笔，打算将旧笔收藏起来。</p>
<p>新笔上也刻了字，是《吉檀迦利》的第一句：“你已经使我永生。”</p>
<p>（写于2022.12.29）</p>
<p>愿你从此一生心中善意长存，</p>
<p>愿万千苦难磨折无法遮掩你的神。</p>
<p>愿你记得曾拥抱过你的我们，</p>
<p>愿你高唱着理想，回应他人的质问，</p>
<p>愿你敬仰着光芒，永不向罪恶俯身，</p>
<p>我们为你祝福，愿从此所有幸福都将你拥吻。</p>
<p>（写于2022.07.11）</p>
</blockquote>
<p>再见，壬寅年。</p>
<p>你好，癸卯年。</p>
<blockquote>
<p>回去的路上，车流多了起来，不知道为什么。</p>
<p>我发现小区门口的洗车的地方换了足球场，想起之前和父母来这里的情景，有点不知道说什么好。但随即发现只是换了个地方，不过生意看起来冷清了许多。很快我就找到了冷清的原因：前面有了一家新的汽车保养店。</p>
<p>那家包子铺还在开着，我已经记不清什么时候第一次来这里了。</p>
<p>许多新店开了，许多老店还在。</p>
<p>走进小区，我看到原本幼儿园前的几张木椅已经破损地不像样了，里面的钢丝漏了出来，原来竟是假的，可我小时从没怀疑过。幼儿园里空荡荡的，想来孩子们都在室内。往回走的时候听到后面的响声，以为是孩子们出来玩了，回头一看，还是没有人。有一条人工河，上面有一条刻成弯曲木头形状的桥。我想起来曾经经常在上面玩，熟悉每一道花纹。</p>
<p>人工河以前是有生机的，还有很多水。以前是有青蛙的，我来这里抓过蝌蚪。可现在大部分都干涸了，露出了光秃的地面。仅剩的水在今天也结着冰。</p>
<p>曾经那边有一家面包店，我经常在那里买十块钱一袋的肉松面包当作零食。</p>
<p>曾经那边有一家菜店，我有时会替母亲去那里买菜。</p>
<p>曾经小区里是有桃树的，小时候摘过桃子，后来可能摘得人多了，桃树再也见不到了。</p>
<p>曾经小区里有条管道放着水，母亲经常去那里洗衣服，我就坐在她旁边看书。</p>
<p>我张开手，拿出攥着的硬币。我记得我小时候捡到一元钱是很开心的，我可以买两袋零食吃，同学也会都来分着要。</p>
<p>所以，我望着前面结冰的河，把硬币放在拇指上。</p>
<p>希望以后，不必回望过去，不必妄想将来，只活在当下，做好自己。</p>
<p>希望以后，不必因为别人而惩罚自己，不必在意别人的评价，不必在意别人的性格。</p>
<p>希望以后，只为自己而活，不必将生命托付给谁，只为了所有的记忆与情感而活。</p>
<p>我抛出硬币。</p>
<p>我记得月考后，我拿着橡皮和自己打赌。“三次正面”，我扔了两正一反。但又不甘心，于是又来：“五次正面”，这次倒是扔了五次正面，但我又不放心了，再扔一次，是反面。</p>
<p>所以我转身，我听见硬币落在地上，滚动着，然后停下。</p>
<p>我不回头地向家走去。</p>
<p>去他妈的命运。</p>
<p>（写于2022.01.07）</p>
</blockquote>
<p>感谢你看到这里，我的朋友。</p>
<p>新年快乐！</p>
<blockquote>
<p>人在雨中往前走，在人的感受中，本应静止的树木自然在往后走。时间在不可抗地流逝，人不可抗地要往前走，树木也不可抗地往后走。人的生命一点一点流失，过往的记忆埋在树洞里，生出叶来。</p>
<p>当雨停了的那一天，也许人也走到了生命的终末。他停下脚步，回望自己的一生。愿他会发现，自己的一生是多么灿烂，即使自己已经到了人生的冬季，自己的故事也会在这天空绽开。</p>
<p>（某年，某月，某日，读过《树与天空》，记在……）</p>
</blockquote>
<h3><span id="后记">后记</span></h3>
<p>大概是第一次如此用心地写文章，从发布前大概两周开始准备。因为我想让这篇文章彻底成为一个句号，也成为一个开始。</p>
<p>原本只是想参杂着歌词。大概是发布前一个周，翻了翻日记本，才有了用类似蒙太奇的手法串起来这一年写的日记来总结。发布前两三天想起插入一些这一年读过的书。</p>
<p>最终插入的书选定了《堂吉诃德》《百年孤独》《献给阿尔吉侬的花束》《存在主义是一种人道主义》《海子全集》。原定还有更多，这是精简后的结果。在我看来，前三本书所代表的：理想、记忆、善良，是我想要去成为的人的模样。而第四本书则告诉了我应该如何去成为这样的人。</p>
<p>下面是过程中的一些改动：</p>
<p>《百年孤独》的引用原本选择了马尔克斯的诺奖领奖词，后改为“世界乃身外之物”，后改为现在这段。</p>
<p>萨特的《恶心》未读完，只能引用《存在主义是一种人道主义》中的句子。原本还有同篇文章中萨特对信任他人的阐释，后删。</p>
<p>《献给阿尔吉侬的花束》阅读时过于注重情节，没留下多少摘抄，只能找了一段对话插入。</p>
<p>《小王子》原本引用其改编电影中的结尾句子，后删。</p>
<p>原定引用莫奈的故事，后删。</p>
<p>第二部分第三段的引用歌曲原定《然而我不是神》的结尾，后改为《我用什么把你留住》的开头，后改为《小半》。</p>
<p>原本第二部分的结尾是海子《以梦为马》和《黑翅膀》的节选，后删，改为《堂吉诃德》的摘抄。</p>
<p>原本的结尾是海子在《面朝大海，春暖花开》最后的祝福，后删，改为现在这一段。</p>
<p>全篇中，下标写于xx日或未标记来源的均是我曾经写过的日记或随笔，选定的时候有轻微改动。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>其实悲伤早已死去</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E5%85%B6%E5%AE%9E%E6%82%B2%E4%BC%A4%E6%97%A9%E5%B7%B2%E6%AD%BB%E5%8E%BB/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>我想我大概永远都不会忘记2024这一年吧。</p>
<p>其实现在都是期末周了，但现在同时也是年末了。2024这一年，我毫不怀疑它拦腰斩断了我的人生。在这之前与从此之后的我被短短的一年甚至短短的四天阻隔开来，我不明白为什么这么短的时间会起到如此大的作用。</p>
<p>我总是梦见NOI，梦见NOIP，梦见高考前的模拟考，却几乎一次也没有梦见过高考。而且我在梦见的时候总是清楚明了的知道自己的结局了，我在梦中清楚知道我未来已经在p大了。可我在梦里还是恐惧，还是惊慌，考后会回忆自己考场上是否做错了题，出成绩会痛苦懊悔不已乱发脾气。所以我总是怀疑，我曾经的那些痛苦是否其实并不只是来自于升学的压力。</p>
<p>我高考出分的当天早上做了个特别特别清晰的梦，我从未如此详细地记住一个梦的每一个细节。我梦见我被父母叫醒，他们告诉我高考成绩已经出了，他们告诉我我的分数，一个从现在看来会被恰好卡掉破格强基的分数。我记得我在梦里歇斯底里，记得我冲到茶几前，拿起水果刀狠狠地划自己的手腕，可却怎么也划不开。然后我醒了，我说不出来我醒来的那一刻看着房间的天花板是什么感受，也许是恍如隔世。</p>
<p>我至今仍清楚地记得梦中的那个高考成绩，比我真实的高考成绩恰好低了$23
$分。现在看来我的这一整年都充满了这个诡异的数字，这个我从2020年听说的典故在四年之后诡异地一次又一次出现。我总怀疑我真正的高考成绩是不是应该是梦里那个，只是命运心软开恩让我有了从梦中惊醒的机会。</p>
<p>上次去理发店的时候店员问我，走到这一步靠的是天赋还是努力。我很想回答他我靠的是运气。因为连我自己也不知道，我走到这一步究竟是不是命运无由的馈赠。我走到如今靠的到底是什么，是一次次起死回生的运气作祟，是我从出生带来的天赋，还是我长久以来自鸣得意的努力。我不知道，也大概再也无从得知。</p>
<p>总之这一年就这么过去了。我不知道该窃喜还是该怀念。</p>
<hr>
<p>标题是周存的《向内生长》的歌词。其实坦白而言，我这一年也没有太多值得悲伤的事。我只不过失去了两样也许本就不属于我的东西。可我总是，无论是嘴上说还是实际做，我总是笃信着人应该放纵情绪，总是认为自己应该去追求，应该有执念，应该笑，也应该哭。我心里有一个完美的我永远都在追求的人，他（她）应该是偏执的，应该是骄傲的，应该是温和的，也应该是痛苦的。从这个形象被我用剪刀从我见到的人、读过的所有书中剪下来又拿胶带一点一点拼凑起来的那一刻，她就始终在影响着我的一举一动。我疯了一般朝她靠近，我毫不怀疑只要我离她靠得足够近我就能获得我心心念念梦寐以求的幸福。<strong>我心心念念，梦寐以求的幸福。</strong></p>
<p>我之前去过一次文学社的社团活动，坦白而言我的体验很差，一方面是因为那个活动其实人数很少，所以搞了个很小的房间导致我社恐发作；另一方面是我总是怀疑他们在讲的时候带有一种学院派的盛气凌人的风格。那次活动讲的是布朗肖的《文学如何可能》，里面有一个我到现在仍然深以为然的观点，里面有这么一段话：</p>
<blockquote>
<p>使用这样的语言（陈词滥调）只是因为它过于陈腐以至于无法引起注意并阻碍了它必须转述的意义。陈词滥调注定不会引起注意。意象、词语不再重要了。语言从中勾勒了一具不可见的缺席的身体。</p>
<p>——布朗肖《文学如何可能》</p>
</blockquote>
<p>我对此的理解是，有一些词被人使用得太多太多了，导致人们终于忘记了这个词原本的含义，而只是将其强加一个“某某场合可以使用的特定搭配”。主讲人举了个很有意思的例子，他说当我们在讨论爱情的时候，我们会想起玫瑰。但很少人会去仔细想玫瑰的艳丽强香，而只是想起玫瑰。当我们在讨论玫瑰的时候，我们其实并不很清楚我们究竟在讨论什么。</p>
<p>我觉得这句话相当有道理，并且终于迟钝地在某一天吃饭的路上想到，当我们在讨论梦想的时候，我们究竟在讨论什么。</p>
<p>我想一个中文的初学者见到梦想这个词一定会被惊艳到的，这个词的构成太过飘渺，太过轻灵，然而这些漂亮的地方全都被掩盖在日常的滥用之下了。</p>
<p>所以在我心中，到底什么事情能配得上“梦想”这个词的分量呢？</p>
<hr>
<p>开学的时候哪个老师给我们放了个短片，大概是叫了几个同学到讲台上来，让他们按照自己认为的大学中未来可能的成绩排一下名。然后那个老师问排在第一名的那个同学他为什么如此自信地站在那里，我对他的回答至今记忆犹新，他说：“因为我想要改变这个世界。”</p>
<p>我至今仍然会想起高三遇到的那个女孩，有的时候会愧疚高考后打扰到了她的生活，但更多的时候我总是回忆着当时的一个又一个细节，即使我现在连她长什么样子也记不起来了，却总是会忽然忍不住嘴角上扬，然后忽然被巨大的遗憾和痛苦掩埋。坦白而言，我在那之后的种种心情到底有多少是因为我对她的感情，有多少是对她的感激。还是说更多的部分是我自己幻想的破灭：我一直一直都在憧憬的那个幸福的未来，终究没有到来。</p>
<p>我后来写了《刺杀》，将这种幻想自嘲是溺在月光里。</p>
<blockquote>
<p>月光将那条路撒上一层银光，一层诡异的银光，你伸出手想抓住空中的流银，可你什么都抓不住。但你要是站着不动，那些无边的流银又会一点一点覆盖在你的身上，你被一点一点包裹住，你会有一种错觉，觉得自己在化茧。可并不是这样，你一点一点忘记了呼吸，跪倒在地上抬头看着月亮，感受着自己身上一层又一层地镀上白银，然后它们一点一点一点收紧，你的胸腔被一层一层包裹住缠绕住，心脏跳动着击打在胸口发出挣扎。你无法呼吸。</p>
<p>（2024.06.21）</p>
</blockquote>
<p>可我又如此清晰地记着高考前我坐在楼下，我想着我还有想去的地方，我想着我还有想要见到的人的那个时刻。我为什么那么清楚地记得我在走向高考考场的时候，鼓起全部的勇气回过头来朝着她的方向大喊一声“高考加油”。我为什么那么清楚地怀念着我幻想了无数次的我与她站在蔷薇丛中的对话，即使那段对话其实在现实里一个字也没有发生。</p>
<p>高考后我逼自己去准备图选。我当然清晰地意识到自己实力不足，但我总是想，如果我真进了图，她在看到喜报的那一瞬间会想些什么呢。我也总是回想，如果我在明天死去，她得知我的死讯的时候会想些什么呢？说到底，我后来的种种行径是不是，是不是到底来说是一种卑劣幼稚委屈的情绪，我明明知道她已经下定了决心，却总希望着她哪一天哪一瞬间会忽然动摇，所以我其实一切的所作所为都是在努力去博得她一瞬间的后悔，去赌她会像达洛维夫人一样想：“如果我嫁给了他，这种快乐将会整天伴随着我哩！”</p>
<p>我在这里将这段话写在这里以自嘲我的卑劣，我或许心中始终以一种丑陋到极致的观点看待着我自己追求的幸福。我一直宣扬自己与过去自己的各种行为切割，但其实我骨子里仍然是曾经的那个卑劣的我，其实所有我拼命养成的道德感也许都没有抹掉这个事实。</p>
<p>后来我笔试的确答得极好，却也的确没进得了图。</p>
<hr>
<p>我后来读《罪与罚》，被其中的“索尼娅”深深吸引。再后来英语课上读了《欲望号街车》，说实话，一开始我对白兰奇其实异常鄙视，但最终却渐渐感同身受，以至于我选择了这部戏剧的续写作为我的英语大作业：</p>
<blockquote>
<p>MITCH: If we … get married, I swear that you won’t be on the edge of
lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world
is … always too harsh. [<em>There is a pause.</em>] It’s getting late.
Maybe the bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend
my funeral in the future? I have no idea when it will be held. But I
know it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could
imagine it. It will be quiet and stainless, with pretty flowers …
right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t … don’t
answer me. Let it be a mystery, a fantastic mystery, just like the end
of a fairy tale. I had read so many fairy tales when I was young and I
always imagined that I’m a princess living in a palace, in a magic
palace, waiting for my prince and then having a happy ending. Everyone
believes that the protagonists of stories will have a happy ending, and
I’ll also believe it. Do you know the French story <em>La Porte
étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the
end of the story, the hero and the heroine get married and have a happy
ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry.
Tears are so precious that you should save them for more precious
people.</p>
<p>​ [<em>Mitch covers his face with his hands. Blanche wants to wipe
away his tears at first, but then she hesitates and turns
back.</em>]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the former
things are passed away.</p>
</blockquote>
<p>也许我自己也是如此积重难返，无论别人怎么说，我自己都能体会到自己性格中最为肮脏丑陋的一面。</p>
<p>可，是不是只是今年的我如此认为呢。我毫不怀疑现在的我拥有了高一的我所梦寐以求的一切，毫不怀疑他看到他的未来的时候会欢欣鼓舞，明白他所经历的一切都是值得的。我也好想在未来对小时候的我说，他最后终于成了一位发明家（虽然可能发明的东西会与他想象的略有不同？（笑））今年我的网易云年度歌曲是孙燕姿的《遇见》。我太爱这首歌了，我也太爱其中的那句歌词：</p>
<blockquote>
<p>我遇见谁，会有怎样的对白</p>
<p>我等的人，他在多远的未来</p>
<p>——孙燕姿《遇见》</p>
</blockquote>
<p>说来也好玩，我是在冬天听到的这首歌，而这首歌的开头第一句就是“听见冬天的离开”。我想也许冬天也的确该离开了，只不过还有不到两个月的时间。也许不止两个月，那就三个月，但总之它是一定要离开的。</p>
<p>上了大学后我写高三回忆录的时候写了这么一段话：</p>
<blockquote>
<p>大学报到也有一段时间了，在校园里待的这几天竟然无比适应，既没有在高中的那种被支配全部生活的禁锢，也没有假期在家里那种一天天无所事事的颓废。总之我愿意说——我希望过几个月、过几年后的我看到这句话不要哑然失笑——我现在真的开始向往着无限可能的未来。</p>
<p>（2024.08.26）</p>
</blockquote>
<p>我现在看到它其实已经哑然失笑了。我知道自己的未来其实并没有无限可能，有太多的事情是我无论如何也做不到的了。</p>
<p>可也许我一直渴望着的那些事情，我一直向往着的未来，我无数个夜晚辗转反侧的时候脑海中幻想的一切，我走在路上忽然入迷直到差点撞到人才清醒过来的幻梦，我一次次写在笔下，一次次自嘲，一次次又在笔下抹去的幸福，也许，也许还会来。</p>
<p>可我难道不是总是这么希冀的吗，我难道不是每次都在幻想之后发现自己所幻想的事情一件也没有到来吗？我曾在脑海中描摹的一切最终证明只不过是虚无的清梦，如同一个赌徒将筹码堆上牌桌前幻想的他赢下所有的场面。我读过无数次“远离颠倒梦想，究竟涅槃”，也自嘲过自己是心想事不成的超能力者。</p>
<p>可是梦是如此美好，美好到我仍然愿意执迷不悟。</p>
<blockquote>
<p>不，他说得不对！如果我谈到波丽娜和德·格里的那番话是愚蠢而尖刻的话，那么他对俄国人的讲法则是尖刻而无礼了。关于我自己，我没有什么话要说。不过……不过……这一切都不是这么一回事。这一切都是空话、废话、扯淡，而需要的是事实！现在最要紧的是去瑞士！明天，哦，如果可能的话，明天就动身！重新振作精神，重新做人。应当向他们证明……让波丽娜知道，我还能够成为一个人。只消……不过，现在……已经晚了，但是明天……啊，我有预感，事已如此，已经无可挽回了！现在我身上有十五个金路易，而过去我曾经从十五个盾开始！假如小心谨慎地开始……况且，难道，难道我是个小孩吗？未必我不知道自己是个堕落的人？但是，——我为什么又不能重新做人呢？行的！一生中只消一次（哪怕只有一次）我谨慎而耐心的话，就一切都妥了！只消有一次坚持到底，我就能在一个小时之内改变我自己的命运！要紧的是坚持到底。只要回想一下，七个月前我在鲁列津堡彻底输光之前也曾发生过的类似情况。哦，那真是坚毅果断的极好的例证：我当时输得山穷水尽……从游乐宫出来，一瞧，背心袋里还有一个盾，“呀，那么，吃饭的钱有了！”我心里想，但是走了百来步，转念一想，又折回去。我把这个盾押在小数上（这次是押小数），真的，当你独自一人，置身异国，远离祖国，远离朋友，不知道今天是否有饭可吃，却把最后一个盾，真正最后一个盾拿去下注，这时候是有一种特殊的感觉的！我赢了，二十分钟后我从游乐宫出来，口袋里有了一百七十盾。这可是事实！有时候最后一个盾就可能意味着柳暗花明！如果我当初灰心泄气呢？如果我不敢下决心呢？……</p>
<p>明天，明天一切都将见分晓！</p>
<p>——陀思妥耶夫斯基《赌徒》</p>
</blockquote>
<p>新年快乐！</p>
<p>（写于2024.12.28）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>你有想去的地方吗</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E4%BD%A0%E6%9C%89%E6%83%B3%E5%8E%BB%E7%9A%84%E5%9C%B0%E6%96%B9%E5%90%97/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<blockquote>
<p>你有想去的地方吗</p>
<p>目的地是天空 还是大海呢</p>
<p>你有想要的东西吗</p>
<p>是繁花 还是细雨呢</p>
<p>——JUSF周存 <a href="https://www.bilibili.com/video/BV1Vv411i7UU">《你有想去的地方吗》</a></p>
</blockquote>
<hr>
<p>那天她问我：“你有想去的地方吗？”</p>
<p>我一时不知道怎么回答，低下了头。</p>
<hr>
<p>我喜欢幻想自己的未来，也喜欢回忆自己的过去。</p>
<p>我当然这样是不对的，我在逃避现实，可我能怎么样呢？</p>
<p>我那天嘲笑自己，觉得自己幻想过的未来好像一个都未曾来过。所有的重要的事都在意料之外。</p>
<p>我还嘲笑自己，自己回忆过的过去，幸福的美好的记忆我回不去，痛苦的悲惨的记忆我改不了。</p>
<p>我有的时候觉得自己的未来一片光明，阳光太过迷幻。</p>
<p>可有的时候又觉得毫无希望，不如死了算了。</p>
<p>我很羡慕高一的我，意气风发，自命不凡，觉得只要自己足够努力，只要自己的感情足够真挚，自己什么都可以做到。觉得自己一定在走向幸福。</p>
<p>现在的我却是瞻前顾后，考虑一切现实的因素。</p>
<hr>
<p>前几天一个朋友突然兴高采烈地跟我说，他找个大师算了一卦，他未来会找到一个特别好特别好的女孩。</p>
<p>嘴上不饶人，我心里其实很羡慕他。这几天和老师聊天，所有的老师都鼓励我，说他们都认为我完全没有问题：无论是高考还是以后。但这些话听上去总有些奇怪的感觉，有些安慰的感觉，有些怜悯的感觉。其实这些话很有道理，毕竟老师们可太熟悉我什么人了。比起这个，路边只问生辰八字的算命先生似乎不靠谱得多。但有些话从人家嘴里说出来，可信度反而看上去高得多。</p>
<p>说到底是命运，我有的时候太过相信命运。</p>
<p>因为当我一步一步往上爬的时候，好像就会有一种错觉，觉得自己是天命之选，自己与众不同。</p>
<p>当我伴着风往下坠落的时候，好像也有一种错觉，觉得自己什么都做不了。</p>
<hr>
<p>但其实能做的还挺多的。我想做的还挺多的。</p>
<p>现在书单里大概攒了十几本高考后想看的书，还有几本看完电子书准备高考后去补纸质书的票的。</p>
<p>和几个朋友约好了考后一起出去全省乱转，和几个朋友约好了去他们的大学看看。</p>
<p>高三不知道为什么突然喜欢上了写小说，现在大概还攒了三四个idea还没动笔，以及几个已经写了但是藏起来的残篇。</p>
<p>买回来的数学书好多还没有仔细看，一直说等到高考后就开始读抽代。</p>
<p>好多画好多建筑只在图片里看过，什么时候能一睹真容呢？</p>
<hr>
<p>周存的《你有想去的地方吗》好像是我关注她之后她发的第一首新歌。我其实不怎么喜欢听外语歌，所以听了一遍就放一边了。</p>
<p>前几天坐在高一楼下，突然想起来了这首歌名，所以我对着竹林，我很想大声喊出来，但我知道喊出来周围一圈人都会觉得我是傻逼，所以我最后还是很小声地念了一句：“你有想去的地方吗？”</p>
<p>但其实根本没什么人，这个时候早就放学了，周围人都走光了。</p>
<p>所以我又站起来，鼓足勇气提高声音喊：“你有想去的地方吗！”</p>
<p>还是没人回应。这时候轮到我不知所措了。</p>
<p>我放下书包，看着远方还亮着的灯，我拼了命大声喊：</p>
<p>“你有想去的地方吗！</p>
<p>你有想见的人吗！”</p>
<hr>
<p>写到这我自己都觉得自己在强说愁了，但总觉得高考前不写点什么心里难受。</p>
<p>其实她并没有问过我想去哪里，但是我确实是一直低着头。</p>
<p>为什么低着头呢？</p>
<p>可能因为我真的有想去的地方。</p>
<p>可能因为我真的有想见的人。</p>
<hr>
<p>高考加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>一路喧嚣到黄土中</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E4%B8%80%E8%B7%AF%E5%96%A7%E5%9A%A3%E5%88%B0%E9%BB%84%E5%9C%9F%E4%B8%AD/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>我实在睡不着，所以我决定起来写点东西，以纪念我的第一次通宵。说实话，这种想法实在有点可笑，仿佛通宵的意义就是写这篇文章。我有的时候总怀疑自己是不是闲话写多了，所以生活中看到什么都像素材。陀氏说他“担心自己配不上所经受过的苦难。”坦白而言，我的确很喜欢这句话。可我也知道，陀氏这么说一定原因是他是个虔诚的东正教徒，所以他的灵魂可以在饱经苦痛后伟大而不朽。而且他也的确是文学上的天才，他的灵魂也的确随着他的作品伟大而不朽了。可我是个不信神的异教徒，我死了就是死了，一片灵魂也留不下。再者我也不是天才。事实上，我之所以现在仍然醒着动笔写东西（现在是凌晨4:49），无非也就是我清楚地明白了自己并非天才，因此的确，我死后不会留下什么长篇鸿文供人瞻仰，我的灵魂因此也不再可能伟大而不朽了。</p>
<p>我先前说自己不信神，也许这句是气话。因为直到刚刚我还在嘲笑上苍的恶趣味，可如果我在心里真有些什么宿命论信仰，我想也多是自命不凡的骄傲。当一个人开始自命不凡，那对他来说，苦难无非只是磨练。甚至于他每遇到一次苦难，而且是那种最无来由、最奇异、最想不到的苦难时，他只需稍一摸索就会明白：这当然是上天的考验。上天处心积虑、费尽心思地指引着他，一直到他也不知在何方的彼岸那里去。写到这里我也不得不承认，我所描写的这些当然就是我本人。这种宿命论的困扰太过严重，以至于不知从什么时候起——我以考试为例——我好像错以为决定我考试成绩的并不是考前或考中，而是考后。如果我考后灰心丧气、后悔不已、发奋图强，那么我的最终成绩好像也不会多难看；可如果我沾沾自喜、自鸣得意，命运就总是能找到方式击倒我。这甚至使得我一度过于害怕自己心想事不成的能力，在期盼任何事情的时候都要竭力往坏的情况去想，以这种方式向命运摇尾乞怜，展示自己其实并没有颠倒梦想，而是正脚踏实地，而且正亟待命运的救援呢。我在这里又情不自禁提及命运，我想这是一个一锤定音的证据，说明我其实内心深处仍是一个自命不凡的宿命论者。我认为这源于我的懦弱。一个强大的人可以笑着放过苦难，而我只能默默将苦难视作某种积蓄——某种流通于命运之间的货币。</p>
<p>我刚刚提到货币，其实这个比喻不是我想的。我之前给DeepSeek喂了句歌词：“也没有用情至深，到命运心软开恩。”所以是否只要用情至深，就一定能感动神明，换取我应得的幸福呢？而且这其中是否还有某种汇率关系，受了多少苦难可以换取多少分量的幸福。也许神明还默默给苦难和幸福都分了分等级，算了算公式了。</p>
<p>我说“我应得的幸福”，看上去好像是受了多大的委屈。但是，诸君，不论你们会不会哑然失笑，不论你们抛出多少理性分析与证据，再把话题扯到诸如心理学、社会学，或者与我一样，扯到宿命论和神学。无论你们怎么批判我、赞扬我、攻击我、喜爱我，我都一定要说：我认为我完全配得上一份幸福。我直到如今都坚定不移地深信这一点，并且就在刚刚动笔写下这段开头的时候，终于从长篇大论的自我剖析中走了出来。我不敢说我的生命有多耀眼、光彩夺目，但它一定足够璀璨，而且熠熠生辉。我直到写到这里才终于明白先前提及的命运什么的全是借口，与其说我是一个自命不凡的骄傲者，不如说我是歌剧台上登场的演员。我至今都记得王尔德在他小说中嘲讽一个人说话的时候会抬起头来，像是对着看台上的观众表演歌剧。这当然就是我，我所要追求的从来不是什么伟大的不朽的灵魂，不是with
pretty flowers
的彼岸，我要做的就是以我的生命完成一场演出，主角可以平庸，但故事必须精彩。一切多余的理性都不该染指这场盛放的晚霞，因为生命只是一场盛大的葬礼。一切悲欢喜乐只是这场葬礼上的配乐，而我要将我所有的情绪都奏得更高亢些。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>一个个慢慢暗淡</title>
    <url>/2025/06/22/%E9%9A%8F%E7%AC%94-%E4%B8%80%E4%B8%AA%E4%B8%AA%E6%85%A2%E6%85%A2%E6%9A%97%E6%B7%A1/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>之前学长跟我提过可能要回ytez宣讲这个事，在那之后我有的时候走在路上就会想：我该讲点什么呢？</p>
<p>坦白而言，我到现在也没有原谅ytez。但我确实对我的学弟们怀有一种莫名其妙的感情。这种感情大概会被几年前的我写长文狠批一顿，原因是这是“毫无原因的集体归属感”。</p>
<p>我记得可能大概一个月前空间里莫名其妙掀起了一阵怀念高中母校的热潮，说真的，我一开始看到这些的第一反应是不理解。我不明白高三有什么可怀念的，ytez有什么值得怀念的。但后来我又渐渐觉得委屈了：我不明白为什么别人可以拥有一个值得怀念的高三。</p>
<p>如果要界定我高三的开始，我觉得毫无疑问是那天晚上班主任找我谈话的时候。我大概高二的时候在博客里写过这么一句话：“当以后迷茫的时候，你要想想：你已经受了这么多苦难，你应当为了那些还在苦难中的人做点什么。”这话直到现在相当的程度上指导我的生活，以至于我大学的一大乐趣就是给过路的游客指路（笑）。但当那天晚上班主任突然嘲讽我是“精致的利己主义者”的时候，怎么说呢，很难形容我当时内心的感受。我不明白为什么反对学校的那些屁用没有的形式主义规章制度就是利己了，我也不明白为什么我会被贴上这样的标签，我更不明白为什么我当时情绪立刻就爆发了，仿佛恼羞成怒了一样。然后我听着他说他从来没见过我这样的学生能考上清北的。我对他说那我就去成为第一个。</p>
<p>我后来果真成了第一个，只是我已经辨认不清那是不是当时的我了。</p>
<p>至于后来搞什么小组连坐制度强迫我就范，至于后来我期末考崩了自己低下了头。我该因此而责备谁呢？当我后来上了大学，即使在宿舍里舍友大声说话都不敢制止（坦白而言，后来经过交流发现舍友只是没意识到我有的时候睡得很早，因为我一夜又一夜地失眠，经常半夜一点下床喝口水，然后出去走一圈上个厕所冷静冷静）的时候，我又该因此说些什么呢？</p>
<p>当我高考完去山外，听到老刘给我作讲座介绍的时候说我“是省队里性格最温和的一个”的时候，我只感觉恍如隔世。</p>
<p>我毫不避讳我对高三、对学校、对班级的厌恶，我到现在都忘不了我们班班长站在讲台上嘲笑有些人思想反动的时候，到现在都忘不了当我反抗学校早读提前的时候，学校一个电话打给了我妈妈，然后我妈妈坐在餐桌上劝我，她说高三只有一年，熬过去就过去了。她说她看班级群里的录像，每次早读宣誓我都低着头不张嘴，她说她从来没看见我举起右拳，但别人都是在举起来的。</p>
<p>我后来写了一篇又一篇的小说，我将自己的人格女性化，我叫自己“莉娃丽尔小姐”，我让“莉娃丽尔小姐”在小说中遭遇背叛、强奸，我让她的希望一次又一次地破灭，我让她被刽子手砍断双脚，我让她一次又一次迎来自己悲惨的结尾。可为什么我还是觉得自己不足够写出自己在高三所经历的一切呢？为什么我写到这里的时候连我经历了什么都有点想不起了，只是觉得胸口好难受呢。</p>
<p>为什么别人都有值得怀念的高三呢。</p>
<p>我的高三当然也有一段时间是幸福的。临近高考的时候，有一天晚上我放学之后走到我曾经待过的高一楼下，我就坐在楼梯上看着前面那条小路，这条路承载了太多太多的回忆了，那是我最意气风发的年纪啊。我突然想起一首歌，那是周存的《你有想去的地方吗》。</p>
<blockquote>
<p>所以我对着竹林，我很想大声喊出来，但我最后还是很小声地念了一句：“你有想去的地方吗？”</p>
<p>但其实根本没什么人，这个时候早就放学了，周围人都走光了。</p>
<p>所以我又站起来，鼓足勇气提高声音喊：“你有想去的地方吗！”</p>
<p>还是没人回应。这时候轮到我不知所措了。</p>
<p>我放下书包，看着远方还亮着的灯，我拼了命大声喊：</p>
<p>“你有想去的地方吗！</p>
<p>你有想见的人吗！”</p>
</blockquote>
<p>我是幸运的，我高考后真的去了我一直想去的地方。</p>
<p>可我再也没见过我想见的人。</p>
<hr>
<p>所以当我见到学弟们的时候，我该对他们说点什么呢？</p>
<p>我一直都觉得给别人提建议是一个相当傲慢的事情，但我其实真的很想说：</p>
<p>我希望大家可以保持自己，我希望大家走过校园里那潭绿色的死水的时候，看完上面漂着的油膜后，抬头看看太阳。</p>
<p>我希望大家都能拥有一个值得回忆的高三。</p>
<blockquote>
<p>我也为你祝福</p>
<p>愿你有一个灿烂的前程</p>
<p>愿你有情人终成眷属</p>
<p>愿你在尘世获得幸福</p>
<p>——海子《面朝大海，春暖花开》</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>誓</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E8%AA%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b575eb2e2fdbbc659b56fba4f115fcf12df4b336ffb2e7e63c267a43bcf4c717">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e7cefd2dbe40612c7c2a8140ffa690a2bd07c3ac8375b4f96a5b65ce7515f96287621085bb53fb723b8067d99d935c66727149bf42f0a38fa896b9def28ed80055718f799b492aa257d0f6e5bdae703ccd7a8379b069ec2ad2262d444242aa8f3b1f483c8783214a6cb29dd4f972f29a6c9f5a3a9bfad2ee055746120f5472b3487c143d3865be01e85bd3b6ece642587853f088c47add2a23f05f3e6395ee8a040de9011ff3649423af88733f3c60a679d90977075a129b3d0b9aa61f84a5f3f347fe19f11c64cfc8c791402c76978e5ee9bdc1d28a431b14d4d942bf654d648035935086610b312f10956ad47425a76bd954b79083e8df490736d2fa1442735ecf5077327716e3771656b2389966a08ea7e86915282dae621b671bae09b11e56a0f405b2d2fbc8621a971cdc8f11d6c0e9c1985b7c362480fa980103d9dcd11f7db793cefddc9cce86be5420102ff4dd7e06b813f64819d04033c32924d886a152f0914b6de9da0364aedeabf7d363809a28b6cf80ab475a23415d561af889d0f03055ba3bbb716cbc6677eddfd2f75e425bf56d6f8992a074a6d524619df63720f926e23d934937d532d046daefa3b0a887f7742c7ee077a68f294dda43eaa0129368eff3b356f4bd2c21d6b7e2a19b5ce5761e3c2497d6664582ab9b2f9bb4dc61834a4e964fa2f6028deb3bf040efd2dff86dad1231c1dbb58904fb4b19036fbd1230510376944f83fadd4a874c5b55b371aa9383caab6b3baabb83d620bbc0c05e365604e4fdf4d50578f8bd2d725fb390246d63beef0d2ad0bc543d2679cb70b24f9bf63cc6295f6febc314fbbecf195848d0c33951dedf4d638f6940231e67d025ec996801026b8185bebe2b2e2db1b7c10868eeb36f82727b593442688788aa70177823dc5e7b52f56ea2cf4bd07ef5c1e802ba3f6503499dd82b1abf435d85ecb251e50c9f13c81853dfddd6570a25d414c40154b8cfac9cf2208e8182ed2147e66e9d516ee523347328c0990a4d11e399c3f863d4ae3cdaa0b38ad0e13723eda5e718d7d4d6b9e0541f15155c240b1e10139e5fe43b471743d3076ab5370d717422d2a1100d9d3e647c4d5d0f331ab671aef726e1181e8aebbfe6addb453a3ae886f10132fb052b8099a2aa0c2ea55046fbbf419c553708e3391ff9787eee0413d807026eea0b13657bff99ba7e08cafc853cde03124440edc6a79b8268355b8da6cfe41ed455164e8067bce800d7dc7d4bdbd545579d1740b0481ec943aa71c2a03072dd7e581d78869ea171be416eb8e9766693a0d37427be7093af29dd525a9e8b419378be10592895b6442b5b15c9f689257d7a09dcf97ef0b3cd4612d9ca5eb45462c5fb79f36b1418e19fcf42bbffebc9ed1572db45faa6237d5419e81c3e86cab04daa3a2e1b83f4e5cc58b28e7d84ca3771ade48c26e0de572644b1a7c3501867df39a1bb86fac4722e1899b89db618b8b3b8584dc0a876ae1f747d7152a8e294e02d04a5d65bf4df3b8220c933961ce5d7df713175f6fc1563400fbf18fcda9799b1824cba25ee07dc8d41d40ebbc6446a458eb82dc128b14c292d316ab321f0b912c8f23d2ca78a9226eb75d994288a157bcf7b1107b49cb489392e36364c47dede550c015a05b1efe95deaa3444e57fbb7d3990de53de27c09cef112abc2d7764488c5e67a277ee36abfc2416f1f3c87c271eafbee13b4bd2e1478b97eb9f7e7206431fb9fe737717932b6e3e6cd186ce0c4f231471808aac33e73d9788453d4ee3a55e900fef843675305b4aa5a4e3489ad5b7477a55c7c6f77507a00791037e8cafeb7c5c176b5acaefc3f333140547cb31e8c9ecbe4bf90ce70d273733b99d5b4961a38f7e6f406641eb6e9cbdd640fed4e82f8d84449b208d298cc1ad05500be74a214e570443d271fb65b80028d6d8e5e5861f12f80a05c534c9faa57875e9876fd3d32a134429ad1f3ba970d074fce57b40b0e39b99cb44cd99530bce88de6a21ba27f00051396f187578ed60fd4d999f0ae0f61202ef51fe64158df9f58d8636b61ee187a8be47d1f9d471e696c19025bec25730bf9422ac3ab531aab5357ad2875ed354a38b6461c1a543a0a2d8575ebe12ba8def7e0333fdb0781647e1e00bcd857a45d79fe75e0fc88e5e4cd65eeb946c485df90f906ef097c5eadb4c16e25603db81c6e0c4f19645808be276898345487912c3056517633e4535052dd29e6b06c63a42013a78c2dda5ddd5156e51da5e2dafbca71aa31bf4b288a554ea5ad9c5e712aafb4a5a58e740d1ae26163d360a9ceebf14717ba530bc5471b4c29b9defb552fb93bfbd28cceea0e2e0ceb5e8fb6466d2a6079737b030153b3aa5dc7f9620efa2321131d541e6c931ffa9bb2888dd87c6c771e60f5ef4856a2a50ca98e0b37dba0d0812ee16a4da31d8052b790c83580eb6a146459d41da38e5fa7df26f81865a9b27edd2a8420b4227d433125cf79a587f229b2407a1b1c681082bef3145d5aa7e4a7fe70a099b36adeba955bd2cb0865bc1dbb48545a1b01b38f36d0e4d6bf557405c9649f4af3ebbddf4c12c0eeb4c3913fb831c80b7306aa7a1c53195ec7e0125171006b93818dcbf27ffb3c164368c5845cad4ab1533d4a7326e8e80a74055488400550d9f42a7fc3d2dc2f013b95a5dc0fd9a7f9e0d3cc55b546242fb364490caec83fc91b5a72d79443ee855e6902cffa65e567ee7e1495b0236ea61b72aeb89c0b602f87847d2529bde047c0bee9880c9145f7a00e65e547aa53771eab8edf2e4788f4c50a6a141654a72a7e66aef63c9500e98e1f40e5dcdadfa4f394f830c93330343810a985131e6df06516fd9ee89fd61277bd424ac46d5f9ea453cc1163f10a8529e800eb88b11b189d9a6d789ecb09c6f2ff55045b8624c45b46b58048b74c0404778524c95b926a8e6944ca957dd78106e2f1faad8c1edec57f7de74ad16ab059eacee19679c1a8ed38fc184e206cafbc012a735f74a31c51abeba7f59e55e2ebdd5c33500c8cf5c5420edce3200092e3c40786cb606c51b3acc1f25106981f3f13ca5f25531d453f19220d3d65900bf8f48ef525897a90d4a43af195a0f79585694291afe3fc9f31ea648b0fafb6219ee2cf78099d312d6d13af022d6b188b813d50a293cb1c9bf97e53da90d7cdf9a80b47acf35dc7d95c22397170a391c5705d8893fda4746b4633c2c0ffdcd3e59f2a3af719b52c2c7c42dd768f302e8c98b465038392a0513d4058e0cb837cd135f6d41546fe39253883babd6d600e91a85e8970fabc41fb6a099b47376b2ff4e623d8e715522bad1ad5f2b27481d862b567a3d2fb9ce38d5c76433566ab10c1e1445116f0f50c7b64ff1401b6f0566c877031b10f39c957a4414b1144ecbf19fe8726e4d3a511fb55d745b342162eddb7f46ca4571090b26283958c98a72fe7ade931c06a0488894176afbac2572161aa35549820ae9f422858ea9be3d4cb8f446d9ca61e3d05c268c01b07788287bf7becab0fd2b1aabc1c0325b386844c425788169db09428d92255702bfa3089693c875def5c2a49f3009348a74972b2ec3739fe087bb09a2a28a3a8ab769f88fcc4fdb704569405fc670705df8675fa47b7b36ac19cd3a8d35bc71b7111d9d2497d811d656efd2feba81818bbfb6d924ef2555af6581f8f2b915a04f360426d4bf3a6b322ab6d6079b26e597df90f1f5dd19fddbcd28590fccaa7613dfa67d44cf7160f7e39da283bcc723377210148f0f736df2e8250ad7b3ca1b8bdc61bef94d83240507a6338cf191cb38f2c54f71deb24f198d4ab3c8ec083edf86045d7a935f7e49433d7d9a7a6f6eef2eb576afffaa87a50605dd8ca67005cb9cb136b0840237115e6c93ffc1ef4e583c37bdfc29577388743bc5e83d98e046361cbbd4ce6489056b1e9e638dec1216d02919c74710b235a4385f0254b4a6d176a7f398abd0ffdffefb412c452c3a4d03b7ee4156781d5c6225de7c295f93d1e0c75c4e5466b6155a47c13d8ddbc1020cf71d13946dbe7b4a11a56fab47e0a28d865b502edd266ef34a6a997fb4d5933cb8ba9d753c0025f495fd0c3e731acceca3302db33d2aba4d38e32dbc8291f5cf589a0295f62b1591c452dd9a50c532817ef22b1085b0b07ea768282dd0847c63cac16aa67c19dade4e3180aa6e97204937547165e32cd2c3d2fb303d2f30c7eb0d9a6306aba04f5d8bdfcb3ab581ed09b3d068000c501b35c63ca2914efe0d769afdeda84f6912ad9775a8407ad50e1f3cd6ade3a17cfb6c511bbcb79368e08d71f5a6656d95ae6576443293fa9563b79150e9cc78eedad22cdb8b1c769a6ff29287e45834b80e45ad2dafb473e61097cb171bc8668367e8a7ee215ac9e149cd0f614bec1dca5c0baadc7ef02e6af00f1704544f500dcd5ecd8530f1c9d6cbc218c51f5ee80c0ff104d95160c832b84ee8dcd9206832c8d12beb47cdf20648d8077b15e487292d2728ce58b4fd6b78187853776fedf81d59d259afb8e5560e75f33663d1302e0f66c0a4df56ec4c2873bcde07e0f6877e0dc05fa8a71117d0071389e5136341827dc9c529f7f56172ff27be6a0f6367e67b9f309e6d99c4a7ba743d7c295e90689c4314f79c9b5e468b58df656e3a9ceb9a90bda027dcd25e70bc18bf5aabfe1db451906603aa0e1a85155113089fd062dc0f9a1547b02e82286d7c7727df91e947e1422669d91e0692ee274c441454e6290c0e73cf7dbf2c6b93f1eb12eaeb7ce679a24c4e4bf54a5b5eab6d913a58d7c4a92cc26e4c9e9c94e498844afa1c007f4997b538b827738ce5bdb03a117608cf9fb912905bf042097e42501b07ec4b9f34a952beccb531e412f50ce68a5241c3d5ece03db94067d5698070744ed63f2df7d999dd08fefe74d076248b6dd44ca09c717a3ed5fb4af83f879b6ef63da2bb0f3d3fb979ed88a1217871b511a3dbd94e8852bb0bf3d381c4ece21f276914f3e99370a6c9e85a862296b343a23ac2d2299728ba90ba3dc9d58cbdf5475196426df2ccd533e44a82ded64617110d5eb18077274a4489e924282c0c58fcae9f198053c24334ba875d637342fa03d234c70f7112eb9ba703827ff348e8eec8043a70883872a64d8a73e484bde340882e6e39c66e2a0dc92becb33cd66c4191b33fc4080ee28248a14f4fdebc240cdbbc03d577f16d046773d9e3f719f4ec9179cfac143c005218a13adb2a5b1625dd583a96e2748d67e4b2c061c3314bddc3b9ec9a5950c1d017cd2b7bf5f3eff874b3a01b73df96487991401cb342fe413ff959a298ce4929c831bbb2019a667dff9a5dbab4129a486f5033a74c8652f956184d08e696a8fdb71e1253615735466838d3cee907e0e749117b90b39b94f3124147938cee6c77291163bab679f15cec4df06b8b53459e3a7f307bdaa61f2ffaeebf6de077eebc63824b0b927c820a27a7586b8ac4b7f915289f6f0068c91fbc14721806f7cda7e5059f959f34122919101998aa43cf9ddb19c6613ed06eb0dca1078e3842c8a9bb3dccf1e753b9fdbe5f550afaebcaeda58f02e7d88fbef6265e031ea63d9ce1b27eb5c87756d677e0f894aa8e9af276486b3013b4f79fa2ab296c3ddf3f5171a836ccd9f9df8040a330764cc0a4de8472aea5673640d874d2370eea46524a859aa87ca2da02038a9dc5004a9d48e34be7cd8df5db482903506c11820c3a54cbe10e0b7e4c3fcb0aa3773ce3a6d595b371ef9652dc8b29e436c0e00f1ded38607232e40aa5edc3ead15e92c03651b003dda557ebd2fb6168bf7d930f9cf00f88e027d2cdf5b11c93217e739b2a730e909457a3306c95f790287d0db9c825ee7848a8d55ecdca8f54449a284e930476a3bd7d1af519604c242ddcd588becc9cf2e1e3d7369dddea3f9523bf068a559c5a73b19eed18d50f39e48d726f4f570b09b10fbf854f0357309f751852a873ed17129a48163980258ebc7f56cbbc80246ae21256456b2b6e42cfb89966c3552c6ccec179cdcce87a45b46efb6293def0c07dd3faf6639bfc1754ca370a9815088bf9595dd05edd1b9a93ea5b298e6c0f334d3b3c19a333d630fa37100dd85501ad3a8bd3f1399a00bf5e8edefc5a487b7e03bd64e67b781434a411087cd51f3633ca9e324e61ce14e937447329f82bb8e1260d7d811738b0dfe2238ea13d1a3628e00a26d316ea49b57a782911ef15f18b660a865eb54e3690338189d2805f764b81cb6966c99ed26eb3a67fdf0025be94ebba63c45d0be1d2b9736cc3b2e91de67b28ad3c7a8938f19160562f9a0196db9d0b02199b15dcdcc723809262dc365bba1e55b046fa774fe6ddfb0c11302849ea3f69d3f052fc85ca18d63d1f1c4464a3cad05a0b092d81b0c88a6d09a97df0d23eac4543ed8feba5c9a289aec4db74c2ca47136fb9b8f31b40511ed2d8db7d5270100e4751faa5b4eaecd760d088ab8ae89a45d65bae46be66f7638d39f513f32c183da2e650648b299ded9938ee53bc98077e740fceded2cf119a767a6c6aa435924f62b9bf252c4ca37233903cfb86e130041b1f887a0c8d7e23da35d8d65cfbcd8033ab11c6df8ef41c86d6ff73b12a50a0be131aef787deb7b732226e408885e3004e0223a14e4ab18128ab4222451ca11e598ea8befb638004cfb1368185e6c39cf5ca4bd1da6eb52314ed668206b4cc3a279508e7a1b06f57051bdb3524dc77cba244394a500b557376c0c295acb442599a30170c12500b5576f2df003e58dce5a62dee1ed8125a36225193d858a36c333c5a173b6d970da0fc6e47209093a934d4931177202393dc073c21e498a101cd3b0ecbe1d4e81fb3bdcacda01e06bcf29ca24b486cbdf822d58026380e95d0d1ca673cf4c84749592266e9e7ab6555101451a2360d6a348e9152d1b87f524003f181db5ede29d4085d845d9970eb2af0c02ef16fc038a92c3963c1d8c07b8901a9039e1aa7e09416b233356812e7c8e1e58702af812e27a98a2a317397e5f2c5d7a785d05be31afdbff2c83d27a11669eec74a1faac1650d2a7f5dab85baac6f0b9308427cd100c2e16644ccde785712450a8208480580279e4b0fc4f30e0394b218bb96d3c67ca18261a300f0fcdaaa6a1450f29bbcf06c3491f7eb16a5bc41b89d7a6b9e69c3f0118ef6191a01ed7efd38805ec1fc8fcfddf778602a9cd0da4ca216cfd02492c5aacb57cef35b4f2b498cc4e92b0188d04e2b387494f01a97f976e900c8e36d29738417374b28d7fa0a35367f50335e629e22c3dc506a417f37b13d3243963030a8c3590805bc9f0afeec82102799513c7c3038b9834c87899ebbff4eeb7b729e36b3a1301340aff5b638ef0eb432e7863b2b10d7fcf2ab19cd4d3a1f5ea8fe1bf6991af939b0aa8977d685d6bbde2336deb34633e71a585c55ce64e6bf19c0db1c60e7c02c839e1fc1e90dea6015e884aa8f6e4deec75a2c9ef445baef9574bf3be7b6bb2043c6f45cf85ddefa15b573f44902327ea17a0be09dd31ef2392d26c6766175ee25a68d59ea549cff378ef729971a18d399b7ebd85956e4cb6403cd2171516f6a93234ad1b300eec180bfa7688c466483c79aadc98346f49c63533d3817053dc7625e1fcd7b19c734860ad3e5c9c229ad124a33ebad956122f7d3e234ccd8eeeb006dba78f844ee6b23828ad6d5d7d106fc87f9627a9cbcd356ad56af73fdf0a020a93e3e65457ad18dd73ca298e3743e628e20bac88711c58c1b8569e71856e8e95158d987e9afc8fcc3087297ae070c22cc0673db3aa81140fa7efb0451932e46e00966cdea7f11e234085b48290eeabafe46904945efb7377e452fcfe4e670f29fccd355a8ea4c5e6b3966e45106eb1ec45a0251f51bf611207284a6dfd2cd07181170771248be666b125d52b89d8d3dd57a2dcf0d10ae999bb54278000b562678d7f2ed7d4d03eeacaed447df3cd6d98ccc77638b719e10bc66423fdd59c5c2c04e3efd37b2f1403dd7fffed6bc6e967e1475abc0e18e34794179d5f73897434da90319c4a43d8e0eac2ec535a41e0f19520643accb4eb1df504357a0e7cf9622d8237d52aaa25541cc4f27f34258dd3c280c59b8d6a645c21e3a593b13cdf5dc1ce1041efc98210fd65130082bf742ab4da999ca3debfa3f5072735fc43006475ea4c10c568b35699b0a9f640a1c4d5664f1ec9120c44e72ed1cd7e469381a04e5087e6523216bac5c3172f3b8be8f8f159312e103ba7c273d3156f7a69eff2ee8f1977c42d142d476d2bedfeec6b75af4b8886d71de654f0ca084ff45c70f7f713fc7aa831ec54858e06e18a30b4777f7a4247869dab6c829478153c85cf1a5c1ec0ec3f1df58b9ad462c3c6c89153d2e76cd26365e49c7b6419f4b4141719dd1c22fa6a2aaaa20687a629bc4165680dc642b897a1e2a028e66f33f156a2fa8b4c415de321dc33bda18a01e5ce28ad08db5f52cc190032713736cd282135ef031ab809128bb4300a79c7cbb512caae13f042bdf11d173c45c7d9edeab67e678a09dee2a886366a8ac5a015b206b384f58992b0516f0433428966fc77e42feee63c04dd15161df79f494f750e3ea7ab06c4576eb59f11c193cda4a60c82ef5cc55ffe189fda7b17187fa23c8ca693f505f3c09ea4637376ff365f892e6567f084b475d184d2d36ea4b0c52e56f7d09400756a6943c36a097e7ad4166db8373a25bf6667316d226af5b3c14dff9ddf17169efb9671932b0a00f74ee831f720ad4e7cb5adce438b40196f931fa9a2dfe95d7e1f421d4da225aff0bfe3b86b06d3ad53f47c0ea9d73940b1b652ef30c9ce391d80d9540a29cb3a3f6f854939c38108358b9d3392dae7039f722599a59293ff2f796103c96fa6a43f5e45b728076196855e46fcf991c6c23426b54d04883bb4cd34367a07f8a085208d6ddc7020bd207e144d23fdf2cc6288492de02218d0ec7711987bcd7b6885f8da96725fed69bfe8b38fd6b37061e966895c7978c87d2e27570dbd1e40fa3b07d7597cb693b73d1c0a2e333d233826e3c13945329d88d62eba4b491886c8dc773ffe54cb4a41346cfaaf66bb76a26e5ddc4debc788fd8d6fde418f270174d04cd110c025587971aab18ac3162fdac8e9d6b8d11435694cbb72456c08a397f1a9a4dcaf618e5490b7c127984012a787b10e477016bce95038e5f409a50dfc4daae32e9db01810223d5b9dea911c06b2358ac6e4ef1d90db39475f32b3de09521eda5a9151c156f654c08affa1c9b95b73bdf34736e1e1bc876a69e3ad8915afa090ce3089cb8eb7b8c06372cf87740e5272edabd3136a534b216fc9e77d11a2d6a24c61b93ec4f0a192d519cf97cf69f376a2b8bbdaf8ab567efd7e112f41da2f714c1201fe19c663c5a614350718317330e73a736c660b313b8874f0e1c5f5588f1a129660d2be2fa84549110aa8da1b53aabe4e07c0ccaa86c1ae498a31821f2366850df95dcdd362b6aba0caaa0494570d601a390c505ca7099667a8aa11b6b6617d34fe1358180a60a6405ac3190ad5a6d7578445f0f089653ea480f55973af1db878c3d30c3d5b9bd399a9b65bef647137627f2d7ea3560c43c5bc9d913d09eb6eb0713577e50c2a22d2688e1cfd25493d9d8fcc26d15ac7f50285230fdca7d0bd5b737b0e492490c315f258de7ae13a45ab03ce8245abfe0c2b7921992cd7b9ab206ce692958c3950f47761da9618befd15608b1ebde645330de9f8fd0b2bc8656029d279999d308f152069f4843f38017c9912b1bf46f320c864212a6bfc54cc6dfa17e6b0bd9284bed3a88e17614daa51ee8ed8373749dc9d27222b6869f29c5114f46c0f373c1dba88fbf739f2a4ad3611ed2586dd7f351b582b16fe3b8394cb14eb13a65a86bf79570374a9d95d448e5721bf161eb8324329e6d5e1f65044ce53655dacf7d6e35e70d12fa1c71e580ab16f44aa2e59425752294ffbda66ac022e0e297b2c05fbcccd4241060afec6796a3baaa3af19054940149f71978587230ade33d68c76403582a785b46e69464d7e2de970802dd65c6e7173bfa67c8e811b4443e8a88f44d41d359372c8ad81843b4549d9e57d3a728e9d0bd7062067a64b2c2064e56999fdd391efd6d8c3eeb710d104b7b569464c3a0c9b9d6e6d36845c2d60441521978577127c846b91dc796a50adfc21813334724461430632c055511a587cb04a27b795406cbc9bdbab0b62afe074ec5bc487270a11b881136d1c15f840af76d6d5f7e7e691af54152083310825df775d7fbd180981b46b3c9fb1235022ed892095837c0f7eaccb3654b3d7c2c02b8ae989219c517f879927afdaf3977305516ee2d6ee8ee881a63d27ab10edb839be563fd2b8b4eb26c729113b37b2a6ce0259a73c7f8a0abcff92bd23d7807320c12350acdfe072916d8c2e3fc6ac06699780064268b6aea55870d72d2967e01df4019232f2fa4c0af5acdc0d2d7dd6a22c3d528efa22f0eb8bfd23c7c879c796b7b3a9e053fe550e4e89860afe4656d9cd3ca128a5a17ba3ea235023c1f41f9bda1a055ab77a983d5be3c4bd8e2e5b6f919e9538f1a78bd43de82d346c64847f477162ea4db3b3a19fd265342ddb7e987db9897139da450fb06869319b74f501d6b00266fcbe49c28640dc6608e3371d43f24ad0398d8709923495432d56f58fd1bd6463e269d1738802609df22e3ba0256be02241059d877cb578c8d7efc601878ff49a805210d30cfab347d92b608b3c25fc6a01cc716d9e4869d28441b1161fd4b82902b6e9e98be70afa33a8218e8047161bc26308a743ae30b433698b08779e4ec23884fdb1cb360a885f9bd626d6058a193af331fb344d556a70253acae557e88ecfa5b4fa66311db9f1d79f130efff8e7ce140297480616d36d40a6e8311c1fab954a867b871dfc3d086e2353fac8f8a2a4223dcd7f279919fbd5f764d5ec494d5c89e2f19bf6f509d7a4ff2d35a0304ab52b18134e13864b8edf75bf9c7a3118114b3efcaceffcfc4b71965da35fca98c039ccbe69617dd67d0fcb7f796a04dc14e4c88b9c90e8e79e63dc78cd55d6bf2a753c5ac4f97e227b0be925f30483f32af4f3721e2911f1554d50819c71fc84657a124bea25634bbd18b98ffc9e0daa09990fd6cf9625aa188367a26037869b43e036edb33e328a86069af9bf4ebeb1b801f47c5dcc66ff41852a480d2854a61465099b1645912a76614f1aadd85ff57bff5173f938c442ccc4606f01a115b4ba0dbf040daa6a1962702234fb541834f946162cd8d6f220ca01e5ef7ed0e963e85ee196adc523882ae9dda72ecfe28173181d65dae7a9488302021730d5c8b703d6fa67f94f94f15ff489bf89fcfb136a5d7b9eb07f5d78cf56421a005e4f6b2f52ad7375fd0998830c217ab19967f9976bf12b6f5ef1b741034b2e972673a954ed5f6ef6ef889989e5cd4e6c1e42429a63e7b94154cdc351919559608126a27a0ad9dd57df1f52367663bbedbac325887fef7cec06330c5140cc58c6f37af33cb5ef43f23bfe9c286495ea69178b6cc14fbbc876a7285c70841b78b24a7f2b48a3e3506a03ca7d2b307f9d86c959fe913c696a8d6d8b830ad409c49d82cd01145ebf161d1c185aec7397d2bd55fa6f44b71afd3fb295124bdba057c4d080cc1a05b28b2d7624fb3f97c740ba7d4bb86631772e71794574a7a29c6d4735823b070cf4539209ed90525e67e24a09bd312aeaacec9582314e798f129b138d34577419a06894f53383e7bdb2ba43642a2c53e78e3eabb7e7ed34a981b46cc95280bc6e4514e95ca6169f4ae44427f17668baa52b535614cb8f5e63b7e22909bd531219ce576457a607435eb45daea7569f3dd12f295fba9743d469b75a405d228a8c37295a305fd7f8f37faf7b40482e4db62715340761730925b42924b46a3b3f9a3aaee5734a36d9f3a31d7027292e373e8a68ad14f8eff813f2eda1437a5d07f8a050cbe02de7dfa0ab388970bbf7b665894cc7489602e0f5e469f9a588c4aa316e13f7d9f0dd2bb270dc2d5fea376f7e38da463ec84fc82dccf262ea45cce9cdf231a6ca588bbfb2ff77c7aa79f9113fa9189e93996ffbe1893e8ddb62ff0fef0cbf4b374180f41163828bfef51f211c134d65ec4354c9de0d1a840ad9470ca2c6a73879253ce93b17ecc3299bf2cc1a2458753f79700b3290655c232ba70bf194b1a4ba0308d23d2aff4c18b8ce02053adf044ccecbbf927a265bb5c7eab5afca36b17aa30cfcde5a570b405791b586de9191706169517e3e6591a1d4f8af17f8e84c3f54c2b558bcc48ca4576edcea067ebc7df5ba4c87c133437b6e489139e405bc44d522112ec1c52718b076645a74438aa77999792b4a9f74e63ee54ee4b857c2008e859b7ecbc7ce0669fd6b8184818d9d6e11bf34e5fb92c9ea9d99301cee511f71b6e61715b562d3abfb4089cfd05757b064908ad36c1bc773a81395ef6132e82f25ac10a65e7b501748c63ee3e5015cdb186b1451baf1ab3606756b525132192e25b46461691d30084c9be6d0deecc25d3405ed7aea70136977eea3b3f83dc4b8907f8145ce8aa7bc2275c48e25aef830f344d443e76c686632ce8f217b3f7f9bcdd8372bfbf34d7f76b7e879f0e4adb6a9404f0032b7dae60d8f76bb0fab405574b0f15c3364e3f9612609dd752ddf0c87fa238dd730fe54ffca710a193e642ff0066d20b0cc6dd9032e63b72bf7c0d1534613f93e7a86f06f4d196f63ddbb5a512535a92113710aefe1d1dc695610151316e850d77fbb905c2d30327869fd073e9b4e6f551a324bc82c5f482790a39554149c7c8d9a866bbca12be1108de2258921436f35edee34c2f9d65d866e5834c428fa43c6c498b08dfa19be578020773dac787355f23f978624c6d2e04733f7dbdd9119b08924d2ba81cd0b2f5cf1f4fba30625c3ae12478a095138d509eb747fccbdfef1d2798cba84a3ab1ce21fc8756d887fbc3c60953b7bfa6d98e449e40660c58fe880dd1838a1c0c329d0103b99e3c0029d42b32654cd46900dde9def84d0a4e6608b7258879f92da1e9c66dfdcd32ceac793696a9ebce7b1ca1965d7c69553abf0a994dab8e1baef37328b7cb711f1b0a54be26fad65e30eb4ccd071cc7d3f79a575f51a23fdf043f8e428aa38496f090f8beb97b0a0f7965f6043ed426ccf4a7b5801f487a4184831e5e75333ca83c522cbf8405db3182078f5dead0328c3a72ffc2c209d3ed5dc61a65319a243314abcb85a90caef37464eaad82bf44e7aba20b82782485ce1d51e4681d1b9becaf6843a102a01640c0c5831c37af7546445d0024c1abcf9d535928f2213075528b1f7e22bc000993f2e93f77c219159c510e72e43db9b87faa1e1069a90c76552cc0da4a9fe1ba793e26f5eda0f80beb8d342d3933753aee94536b41c663d7e8d17fc397378ff5456554886fd4faf4afaf1620452242935ea61b0b4863aaa04e7f5061125d84018dcfdf621eb660730f49d020153e70c836085ec693c94d91c0d98e3d18e9e707889ba8836f04b9df66716ef3ab9fa8aaf0d92d7736a06134a2e14820742285a1d50d5d51cf916509ac79bd6ddf8bea8194b0bf3bbed3d212a087918f2a4982588522af7d7a5b5c6a49610a74aea9bb2cc1264498d178bbecc05effbb450575ee6943721ed842757199c069e9cf9357c91e0608f788b7217eafeb7c3d2b97fdc78d38204ba25431326a754559dca3e80557859b4091de5f804ec9fe72da42b2622d17fb87eeedc59b67791acfd43902354a54413f2dab71012e884d06232d93ea6eaa837c0bd0f738f3796e829d0c5cbe75bc8aeab8da3306c1e293610f40e5c11fd15f1067926f0349e00a52c1cb5dac24822ff39a5a419b027d4ade5f8f2b7b4c29bf517b2b901287b9715f963d6dd5e17c0ef41f7b36ed122469f7957cb84c91c1b5cd6c58fbd825cea3d88563faf75af4988f6d71418d448644c4ddd27cc3fa4f37917013e041c257c7ec1255836c02f4d3030aebf079102ac0b9e38188937223b3adfcc5abe8fe9099159ff5b747aa1b3480594aba03c0a72d658218d8d9472ecedc5227eb3cb3b4389814a84b024c41634d93ca240a660b36a91b4d5e071a94e6c3a027163b2b5341132aaf2253c3b1257c4f9986c61b7467b71ef0254e8ecca69cb1c04bce57f7c2ada8c7d3c4b62af0300c287a111a8de215e3562770ac7d3f05c9df2185ed683d5ff57f7f03c00a10fa48aabc7fd767c34bfcde37ede03d2d7fa363ca4e50ef577156c5395a3659b7d07577281913966671c8efc85c7c178429764679e63494aa81c7419d6997fe3262f28a12698bc510d43d537424729e85f9cd3d4c439601c15353e9a0ce9f641ea6a8f8d24c3c3b8fef0458c04a5b12a9cb253138d80a668b13057e602de2a55bb09f655b46d1a77cd5914e69fcf1848b3c336827b01f407e81eed13a0e4b767798e1a4252550c529c5df585a91f87061af476dd1e332abff43a7974dca59897db37bea0cdf64793a200d90f04f29c2bde605e1bfde0234ef53a08f86f7c1f66bf47bece8cca38ae762b80200f0563c166c2ca3e0294a7ca41170970020d5fcd6d363d5ab6c6362718755efb07789136793d0859818c2de05a8dcbcb0a663021c19d63bcdd4a5d2a94d53548207a9c73fcd86df8ab18e4008ada6ec38a20ecc55ea28f6316e9c4b1aa5f757796a06ab6ba6fb1c4bac7c10de65c1933b327b6e17632846c77aea76be9748c14bbe135aa6de2254d44d6df61930846a7e6cd8be363799ff049927707e98d1071fc3f98565a95336778cd72e9b4c06f68404278baa7ecc7c7dac4c2b3155d932d701dec7137aff4128d6e9bf58b4af40a858efc536fc5a858ff2a7b17e6fae9ab248bf5b0dd91a37b2d9da18d8d7ccd6d2f9cab2829cbf3df376db9ab4e25dd5179b598c516b568c2c9b9e9a2086ca7023612bf0db592eeda2cb3758e153b26600151300770b3a28702bb4434eea707cae051d570374cb370ee6ba3628fd5057af955e4251b87c18e32bf7bc9f4686d29e8248226a73f7afbb750594fe2037ca6d849ca36c740395fccf46edc1320e88acdaed949075f702bfedec72e26524dbc6051858d8152450ec87063019a10fa83f3ed8202a02981a37445660b79e60825e9b7b18557a72655970aeb7662072ed14699f021ab512f918e735bd2daf6e892cf1409681ee1e786573f10aed77129a04c50cd8650d0081a85a77a129e610136c4e9694c4c7e9ec93507f6a50e3999f4f5fd4206742a177d4a188c30cdcedc45cbbb566fbc2b00832b455fe5aa52a60aaccdd0c5e09cac9805d18916f74559e0e2a88ea090bb3ca98413da175af1c91531e7a7a22d1a30bcb193d7f1d40af3451de72e63b14c7e641a4d757b63cfa4193c10f9d53ebd2e9494e3a1cdf499cec89f05a3f8066324b971a73d22429d412fc4d8d7056a8fec81c31c327bbdfd0b69b229ba8b8a76e809dee23da1176bb9ff2f738e628a091252951a35fd653d6e8dce67208f1ca345b4fffc7dd8441ff83e5fb065544b6a343d914744a5f8224e86631fc89f4822eb5987884b06a9cdb54e2b6a48c006ba93b748cb629bf425fb6833d7561d2c478b5671a103178d9b8bbcc2d9bb1e0e4cec00e3c20f92ecd288a081ecf86fcb10b9c04869119c561ca08fcae079dcf38fe43414108045312a88dfd75f6a379ee0dd8b86759e1991277f293b8893c333ad3f781eac1a3318e3729e1041b52b7c891c6bd39da0fc69532f25196357934e3324da6e97cd1db9e83611d9d5145cccc5993c62fa75ce2262ac85ec46dd471cd194ee4cdb65f0b7fe76c00dcc63468d44dcf92bda3142931fc8bcf205543a6bde94599e76030cab68e4bc002d911b80ad176c6bc27dadf51773c952891909cbbafa549adf301ecaca9788f4a27f0ea9ffaffec9471d1b3c0f5a5903e74b3e0bbc28621c93fee503dc02b7f2a6457fb5cc7a3cf5927ab2be0304deab9ceba205ade642a471f60b7203f0a4d94fbe14c32ce19bab90c1d84d47393c40eef53c56fc03a22b4e67b0df2e5daf2115982a231437ffb08a577338a84f188c065e2b96ead9f6f0cce01a70bc49b59d694e7236d7cedf7082ed2cdf326e28af7eaf51b99dcf70a6159a7e7a4c19139a47809dccaff57cc1a72a442ceb7116bf9ff8872fc6d772332e419bad89078d12f8cc0415d73041338a2e6e504450a900a0182395019906761962cbd08e389c0d2a339a85f289f106cf4929c0884c37dd2fb394cb282693f1c78deae6e0bef10856d83797a4051863abfe028267e183648202adc5f7759dd339aa95411072bf63ee62f99e94dbb835ca36c4c4df669cd760a7877e73f5e3a111eb1e1ae0ad6ede83568c06bc3761bddd30a3d8f080927e192aee0a707b917629718a84d26a2f40f7fac712ce55b8f133dec684bebd5af96cb42db9c8c7b80c59489d3cc8dbef6cadff9244e96e6a169ce2639f7ebe363f4fab676e4de56db27635d4398301c34a80359fbaa30c264e9889b84870daa42f87c4edc007e14c00d3ddb372737bd3d5126caa5ff9b59090bd5513871fb578136902d7199c81151afcdc2d2a00995d2cd2440a3ca3e3783af76b0dc38608e893e7e204d790ad4a6d403bf23f4cb30cedd952f9e2bffd02012c29216dd39c1cfa01434308339bd6e92e2c2e035c07a82b5f0c5de7bbc196a339f458319d3de11382171d7f99fe41adc8ecf5fce6eb0e99c9e6db519a2d676394810ebc4693bece3c6cde32979d1893bf3ec99b65d099054df99449eafcce1af8cf38c488aa378c327ed3e58290131dc7f48b118158cdf439223eb283b3e3efc42556002fdb538d1d3ed2bcefaf972f2b110dbe43dc16bcde934a6336262740cba3d45e6655be0693a3d3eab68385afa2de1edb47b279121f2a9195e84ed02ca00abd4386b74bf6a4d1a07616d629b571a76864574733864b5781d4a3f6f609b4d70ce2192e9063599b773ea8678262c686b0bcc10df19b5e65973aed82270b59027de02762476d8558596e915e726c3d4049738abf7d6edfac4d4c0a589a44f5c565a05e0d75a563852ed188012c12dc557af14532c588c794d5356e6f5edcb84c196cadc3b8c366628fd116530413b87bc52c640a33949eeaba963c0513560627779d22206aa05e4bae90baf1f5ad00583653fe55934fd500259dcd3c39d30f48d8710f1d3b7d52e815f44fbaa95146ca67182aef7e7fd0fb42e9f64bd4d325bf56c608fb1cf5e657c21fb73bbb06e73e498a40946b89cb6a4b9426ab7e5ebd1d050a07527a6e686b366f54fdf2eef84f15afa45c9bbd594a28e3a726938cf803582821c18434c1dbc64d380189a5534df5be7e60e4132e2a943a778457ad7882d65709e1a82566bacfcdb04362a6a3c8d01a0aa4cd1575ce21228e0799de1f6b68a42470007f769b73b15842c655f5edd2f30567238ec2f4e1a8213440d65e5a19f9705f22a2a55ce531902abc9d5adc126dcf92bd99a29067e31b0e753597b189ab868fb135ba89128ded195dd0f60d839363cd1319129cad2ec9b8b00e4f94bc2f69802b7117cec055bba67fc050402ebb42187c33866e596aa0cbe139b9e6cde9b5dc4e23fb90d165079f10255ae7189564d8edaf089a1b00fed33eb4c444939c63bc4f4efb3489b1df30cafad2fc02e720245c41d90e08a361b493f9f670ef49317c80dcc8e118a2daf7481a2f4149527a0900388cf3f49767fc49989a1cd3379da72b36af04a72ec9fb206156ad5b12ecbbaeff223f7980fcfe2d284a6c76229bf9c52006e80043e5fe9192c33024273a4e5df76f7e376af142b2f28a4787327b237b4de086007e79ff1de9751450e5bd0500bd8dfddcbf15a4b8e098d3c11586051e6b593a8f6177613dd0b0f4ae6a041ae2e07402a2e59803ae3b856cad204e28873e1c3efcf769b1f6bae8343dd2f6d822d20c6c60cd8692aebd66aeb18abc51cc3315e4ded1f4a8a65b909e100514845a656659123d78c5db134c9d8cc861db17b1ead74002109e8a1ca5e1668761cefa15271ee2ec9a4c34ca4aa337bb632466bc6fed2b11e9c3fd2c550464b70a2d327fdbf77ffd9702f9de4e441903bd459dfce5bc9c1401ce162fbbd47c05a9e598a37659b81bc8d85132996a8ea877a3d5858ab7eade518cb5eed151ada9475a0f7c324b7d94dbd9fb3ee33d1560fd63e9245418152f7a6743d5589555deedd0f0932401e31cdc9ae8fed3fe51dc26ac829f06288da9edcd648fd4874410ec7f9db575c204821660c0b98adc8b38e4fbac83fc345fdacf6be4bac7ab006d074120f1c9e9c0e96c849fb3ea7f9dc5940036e3d6ed9bed64984e4b821200ac4cd3f7530c4748a6f3bb31cd8bdd9842860c99f6c677cfdae7b60a369ac932db6c84f2d546b8bf6c6596aa0e1e0f53ce9b43738fc4e9c26de25be9146382420b87f00ab43f0e3cac3ef70aaefea8c9110515dfdf14baccdf553f2efbfc0f5630d30b5e8377cea5086def5a607775a54041635d033f6a5f8ec19be5c96243fd13b1a512cbabe9d06af88a8c1d420cef178b76f746c6c4bdfb43769d43601c4b11f2858d36ffbb7827be3585c2466e9e6c6f55ec4af4ed85cdef2c4dcf248aec274e236490edf893a15db17f1536a164f7b750808a4cea6f166300065e9a0b6569eafbfbb85b6caef41476982446f550db5aced0dbc0c7c8ba02998468387f401438a6974ed58d811444b0e69fbbfd0e838fb4fd8885a797691823a6e261b5c2e7e542b639eee743cb8fba61a064a333601040e5c0c1b364c9bec5a6d91f6962ac9c889c0f55dc91bc57e1b86d336e11e1a903c62a83ec4e4723b786620833f3cc3068c0fe448af6c51a9b316747b91591726357b3c8937a3adcc0ccd141b894da2af74b03a00a0ef1f66dae3850cb42a9fed892469634f5c8101e971a1fdf0d2866d47dd0aad922529dee84a877f79e1b46c11d1ab7ce95d8577052439bd9f6beb632642e98805fbd38acf205dc7a7d8c6059a4c425070f0af5b1fd2dfd23ad2aed0fa4e3e2d1ff98c54f0afa72761ce1b1c20847caaa78934726974d5e881f2d51630c20230e2eb556e5d021b3e000dfbe7163b4bfbe84d209f9267e75c5027dfde6322ebb9df31c578daba4292e9737b781c67d443f7f6b722d00fced9b8ebc3391d0fd282580149c4483437fdcbfd86567a7949f4b3736a9916089f7ea69ea470503522a2f2a4577c4635cd25953794c183a767abb18b2675a1e0181a3766e8d2e042fb7b9ff820d4ed93fdf39d38ee3d55891818fac8e518ba265e5ea36e367a563b127a8e690b32fa48d18dfefc2816b120759ee8e80bdb694f2b09677041a3ab3557f4201766f2b2d641ac827a239c156cafa5cc108dd5973d364ae728e40904f4edfb420ebd0ecec2e1d6847a8e24f4dc8b8c7ae96e91cef6fb64701acb5ab134bf81f4b453bb93f050965baba776a1b29d6802bcf5022c0bf472d64ff971c12a9389a84cc1d47c78d6dbfae95fc4f755086059a59490fbd8b8a01f67eff43149784a2362a0163402f8241874542a4e3a2d7acabd9bfc7b1d1a8109d50274b972e60bdb40ac685830c1295ce18b3e46eb7dc7bcf0dd880268dd099d9769d9fb3b1660cfde1fcafbf2290497bafd9e965bcfef879cd036ab03b97eb61b28d437a1ac783921b23baeebabd3f9f220f9ad25329cc30e8a49aa5f420c8a0ebbc7643ddd10ebb685a7211ce6042af8277b7ae8f7f0bb8932bc8eff90e9efcac0438f8a1709c7c8e8dfc507af20e0dae4249a2c202de669f36d73280da899afe8bfbb549fea995b7e6a91aa313cee02b8959d44779babc5940f3a7973f45d23635897a54943fc612d9b605fd2eaac425adade491e87778d7231986f1bfce8fbaf22de16b854c583e9f10569decbe824184ce8a036c922f18eda86ccb9e02da3b361f9dc80271fec10f458f200979f19a353b215e03e05ccae2c48041aca7bfb39a390153ef68bf36fd2b97339f1e8478b2adac4cb49dfe5e6ab01ada5e9c2791afd294189720e70614598a815a7c455d8cc014d3bdebf998675839fc0ad6667f43182488305756b8fd41d8c68bb88d5f0569fb5e57cecf525f1123a2c054bba564b5c122bec0fce58b641b1f3c2cfb5911f36bb953f9655eef92e58a4279db6a7a2bb90c0358e09ae006d40df5b826282e34fc97fc34b0e5603a206373c8ee0c57f4d780b85d9f7d547c38fb50e4e788ea4e0b46de839e87504210ccd5573942912d42a04536ea1c5ba87bbccf2b23810852f5dd7f5cf0da28727c969d93d56529285cb3f956b629db365abbdb0edc3811a7d8a59b531e5b4c49ad3286f8a69cd1a215a4f384d7730fc0977047bb0faa1f32bd862b26f0f4e56f30449d6d896aa83acd1fbf08dfdca68efc03d29802006519569a90e21fb641ca3e4058ba3d1e3d57c6e9580527f487a8196f7929b5b99c53bafc50f09136ed6edf007b5b3362fba90c29a7814b04bf0941f5858e4a594fde9344bf4b4528fa6d935875f1bbdcded526f99abba28713d9da6b53bbce5157ffac9bacfa0a47bd3f0046a50f96521c37fc334aeb6f787658568a26681bddd80d64914e52db5296c105602a9fa220ec46f79f552cd3f0067c529986cf910fa55a43317a0c451c5c9295b9dfc2b351015ae973db5c65b363f48d7191cee2fc29bc7a86fbca43942b0e926f2ee4960f4e6852c53fb72b524bd53421d5d6d7ecd506af1fdfcda9768ff7718de977a2e771a22416b576753856564167834bd24cff00fdb67fad2daec714d3aedb58e816a63dd3405c0a93b078ebd7dfe1c66be35f6e46ff0a695a1f13ad814f1fad2b6d0642d25b0bf0526e001b38acdad51beaaf074eaeabafcda254fa15a29b675a7e190e5dfd8a95cbafe90b1ed81cda6cc79327cb8fd83f35a9787b7a1ff1c252a0543fede1223b157a3d932b56aab1ada8c4fb66edd6963fcb80b11ad401faef16882b0e18780d5ea0812d07c93db48d07de24bc0fb1f553efed69f809f4c0f97c2d288d187f656acce849b26c72bf5ec9eded08b236f645be2fdc3fa7467b735e42e89084feb52bbf3a0b4aea82b7b4112473e8a3269db862af3e596cb996f45faa6edd33d7d85d74f85ee49b565967269c497f834ec33311bdc9ce385c9288b938c509d79915e3905ee6e60edb1c31331ae6f3c2ba9f4b11d7e0497943d7e31a41acaf791b30c9e1e6aaad5af839b22929d35834611da4ce3ae1ab8325ac3c1b5fb6b6049b218edce0bc35f26d46a5e3014ff6864fc8bece948ea59c44adbff426e20402b0b95924f4f4d2b93ae167393972b3ed4a5fbe80058f70609b1ed1a21c3f0901fa34b3733820246ed59c3395b48286713a27c789cc9a3b816f1a964be8426175e40df93475927664a49760e13cd3770c3bd431e7c40ba6138b46f0a5dafa6f2ff6dc8d622e75f52056b588b6cce7b885b4f33834ed6f561bab8e8970a43552a69ebe23c1a4cc77b2cdc79a66a72a4a22a16e4681095842cade040333120d8afddfff0e61bcda36cde483e476855b03f0bec38c586af4cdabbc3dc7978f12d2aa8b97a6675d676b319c0fbcce0a3a2f5cd39976ce7cffaeecb4f48886389c48458340c5436b0193b162accd491dfd2f244ad5d2e1386b2c3a903a9958f9ce1dc5099a955f74fb2f5e96d73f7930c0351f4714a0514ce0d1cdbd9be7b76c98213d1ee96cbd172f767122bc22ffabc23cd9550552a67d79a1c6bd3b6c14566113ee7df2e7f33cc446436e96e022a2b46d8b48066bf7d9925aa8073faeca677a9450b1afb2989f28feb41882ad80b0e5f0dcb1e6e68e87e38367a32ee582550e51a85a03bc19f4a31080d6d904bc347631dec9703776de3ecf98333889e0ea2a81e78c5a45ee2a3211c9efc03751836c35d201967d402dc5db2413b473636261de184b38d5f465ad8002af48c114418379c97ded0e7caba42f4ac0d99e5d2afe59bf771b3d0dc1fa6fe3465455406e8cfdb371e7efe5c6dc411800f5f034b98504fb5fe45c7978c29f0555fe0b4b7c14b88063f1d62cf220c9985663ddb004662ea7cde7cb70940e0661d4a431508a2076147eb78352a24431bf17d18e7049c1cac815686cdf8871d8caf100c80b14c821f941a226460c6e88d085a341ed54d0ad080acd41a1ce6371cdedea5aaf99fd9f33f75c88d07724c4520c3610949505d40278d8d240a720715cb04b212e613d7203fd362e5346fbd728a84fcf5274c04562eec922d6e73515c84f9940607968c18dca327c2bf5059958478cc144bd1e680c79cc1948644887fbf782b0c95987b4a84a7f4450465ab9b7a003b97c9e7930d45179bc74ac3fdc5c3693a6a8528f7d4b3af5142580a6360f83c05a4150986145f2af05007cc607421d2c8a08493316f7f9ed811954f9fddba0ec52d5aa2d795e5fcc06152a581551bb5680fa424e94f5a2065535fb26c9d05c7d44f3706a846487018f2821d05af71294848ec22a430beb93a7dae2fa90850a2ff0bee9209d0ece6c37a5127454a0b17959e10af4440843c2b45fdde7cb127172148c472f483178da2dab14f0484cce7dbe77971ee22b9642044e77f1220e9d53bd384d5656dc521ae46bc0ee73e94acff95bad603f1f6344edf0c576bf11408ba469251fe2c0b6d86b189885e90a1aa2c37f0b8271f18ed60df9cc7960e7a3527ec16b64cf933bb055ad610d45862c7e6ef22f7d9c64e0a033da39977103c8dffb7165d4738f5c509dc9516f4af8a8a272c275a2dba1458f256fc33672150f32bc0205ed927639b09531d4d25f2feb2f7b86d2f4e7cabd78fe90b7b3938e85cd9ce3239a10fd83eb7858930b873fac80872eee96bb2939091b55cf714e2194aa1ba1ac63b66bbbaf8b283f0b2e34c727c245346f979c0efb670e157dad5029a5f0574eb9503c701ba32fb28042c6851b2c4f5e54faef31fa17c38e1ca1aca438c8395b650c02f73698d438cc9959ab52357712813817b85717ddc8a29d0ca2b13632d1e9cc48b8475e3f8f5ad8e225b18321c9ef5005468210ce38d817c61c11c3288880fed94e7f57ee64d3ff2ca4f48ca5557b3676124afff8954604e9c18407497fcf6be300832f3506985463215666e589094b1ccf5502f5e5e9a20222d0ac1b24754f41c82f29fdb4f6a8fa04cb89cf3f7c07b8e6d38bc5912e737c4da399343a068fa2385ad810a678b45e7392a8b570e0062e456c865d16cf88c817a414245ca79875ebc99a79e7e6a8b06efc827aa7e691519a04fb141c05717ea813cfe350c750d5e85f1015e27ee30f2cce31e230a9273fb65398a73cdfdb1df45f713bb7c15d90238ba0d4434a098cac4e6b89b826adfb004ecd2ade64f5b7ee4db5b69bd63b19d26e8ad456d67d43307d482e58d5a860b964457a2d71544f87ecfb20465de3cf1f7789e03e9b0f5fbdf491acb3e84a70f6c7e6156735741773d1740a2deda070d769134d604b960ab792f15c89561adf67ed622b0fc279a7208b021565430a1de6bc3ae62430c152f1d13838f859afcf35db3c4e8259e3b06f27ecb5e2c30acfd4495b5ec871adb3e5dd3afdbc228e9b35fab0f3176bf5e07a5910a5e95c9f11595d15a57d0db773a6b96cc1739d9d6225351d41719aa40cfcaa393ae88a2f7cfcd483cd28e630adf0df2dee1249d703a531388c6a63b944d16e3267d5602dbaff63819cd08fc2e9dc91adfedf1961b57646830482c7050c88de416c814d4e0494231d3c9eef421ceb678fdfb8d6628ec731c74dfe54d86ef5679812ea4646f7cbcf3096c55474c100c04ddb0c2fd93ea8006c8f1a4f5b99f1965529eff85e38217c0dbca9be0b541cccd6b2814ce220411db737cda7a7ceeb752adc4932410722fc81349d45d6d67883b98a9d776e60425b6e369286cff8268e7f03813a875adc056d1a437f689d18000253115a3e3b7c54fcee4f6685e745161bb9dd4cfaa04b49632598681acf8f9512710c5495979553a91be5f80d78d5e2b31645f2a49849b3d7a086078b625fe88b373e913a07410f770f9756fe0bf8d390034158b2d724c37bdc568832db2d36688d6428d2258a65142212445c86c30410f29df08bb44a23cb35dc735b7864aa6d31b2304a452fed69a8003d66a4119069318cb84de4de35f4c4c9573a61d885d9824612e8d6c7ad9d9dca15ac13a25112797aa9589d10046a04f834db43559bc07dfb034001df07952781a561b4d0cceab8a476b0b828c196668ff9f1b179b4efe667bc07e809130c27b2d7060c4b36bb7bc9ca5eb959843a19d1b19452e7bd02a6ffdd213cfc16e6aa2bf785f0018b8d19f41cd940d5279f02e5b7e4988b2fdcd23a325d74a98e9c1e5571b00688e4d5053bcacb1cb0be24597b8bc4bb01091050bd657103200434c43a941e7e36a61e145c7d66e6402dd831ffcad7a4d4b132485d9f6eba356d66c39cef03532c999bb0b38db8deab2b7a1111794777efffefac02a0330d7f7688144b5df218500cf3a5e72ac9b1d24917731e2abaa99e810c0db7b4554c962660d9f3e5aa643d1efdc7aa9ae183d7934dc1cc65a3bc2d40e818568f1bfaba16146e48ea97701f180e0efd63d71780cf26297d7dc459f8e4de132bd33ca0e4efd4440c143edbd93672dd218bdcd3e24635084dceee5b37d7f83a0871b415fa6e664effc6a5903719ae8e4840c00a46b7050a015f5c09c1fcd587f6ef1690eb149f6c5510bd6fc77b16f6ca70ad91969e18bcc4c75392335a26006b9cc741348d0265c1afbc322817d3ad13159cf8f043d4b90b7395bf42a72125f1e19fc19633156e99aa1082aba1ecdde861f5998717c42ac345dd0cc97caf9192c409fc38383129c921c0d3448a3af5ed482c66e6b01d5aaeabb38bd1fc063fa918faf93ecf8a29beb928e2c915f1759d18ed7b0d530ec3e3f76e23725c085f92fc8a9b44986385ef654f0d52df0475e79a3de9162a25689190569cff67ccca2524a27a83efe43a1926efc150df7b6ba10efe5870a0192fce4e9eb3197b572fd3896b34f7fa56800d30716efb9c0a6601afd24cd92539acfdb3877e3c5e769b57bc0887debbc52fef7e7a496e57c67e614fccac85f47bc4c9c8c1ac7930af34af52be90aa1983cbc907d17f08964c546ba7599b33980bd4f5bf8d2fbf55080215f007df93dab96bcead3d0e6fc589e72d4b9c6bbf828be4916224137524bd80c245bf437d7783e825a27d478cce040185603cb95c79951979b22559fe4edf2a875514123b719a17a3abd9f5c783f0afb0830c80facd00ed900f537227312fa08175fd0203f45985b119b96a65f21ea8fab9593a7029d64b31ab0a1500fd257a35da695ea2044a97a1257094c72dd1306316bb016df310827c307b3de0c1f3c905cbcdf9195bffdaa15595dce3397b174260a78df743fa5f748bd30d1ea72c2b80ee76e33f5d6043343446718f2d4f27146e85f4cc2cabe571ea78245524b6bd744c6c23ecdedc901cb45b80b238c44a2b0cd28d8568b7a7b18a873fb2fdcf0d7bbf365cc40bad3c9500447a9d19a814458efb6371351889643e8f2ad7d66d5224b612037d5ee25785dcf17739733691e846b8fbdf0f78289b64d09909a12b9c028d4b9d1f31f9219ec6d52be98bc43b9739ca7915252aec10ebc24b61746569746fc633ee82d4940e13460033cdd8e8e2ded2fa75851afcb212fdb69c3da2d4b23972e64b4587140692442faa8076aafa0e47772369f770cfec303dadfb31ed4d69b132a0df94a4b2d499760fd01afabe19a5b4cf87d449e2cfa8be9705a404a8d5a9dc53c4f3055ac2794aac51f8a27c801491c85da3cc40b4064ffb5a075f645413ce45a54cda3354503dfd1217df7076bc99f79fbb1f7e2dd1e2ac5b213ec22801395371b286a6377187e69899810a03c8ff7b720c622307536f1b26368b1921ae590d4f16e770f7c7586e9bc8ca76f0a704203d1b5ebf5e13522a3242675ba3199f63a2614bc906470f689a561eefc75c74f48be6d7e59b5fadeb6dd7f2d02a4fac2fcd3b139c7ab48b2b130aa969bc3e2005f8f4fca060fc087500996fada4c5a09751ca349b9f9b720a04b471ecfe49d9de602ed4551078a57249723a03e7fc24e29dde1fc735d7b303371faf02e54658836a6f66d2ce7c11274cae39c26f0eb7c8e709e2efec96f532ad48b2bb39fd8d05adb35993ed558fd52fb169e32c5be18317bf62b54e6228e14e6aad05d11b304d9a41c27e6ec77a2532caebf18d951be26cc7542aee8f53629a530de7b83fc97ce26a8fe37bc74e21ba4059cc4781686f037e6c782d085b77db0cd1242303080b4ade58bfffe7d5075e866599a95119a7e5a549e257a12316ce1b73ca76dff41c14bfe41f8604cb5ef5feca9c12a1e544fc864fe269bb75125bef6259dd176fc51a53e6fa4dd04afe02e8ecbbaaba7197dcae729f42a10bc056ff4c8c10af6564440081859bd8928759ffd0647c794368d7ac3cb453908c8946cfe532b2f48a898e994c000ada9f44c893fd5b3b4acafe43e32ec0f021d896cad740f2626f5915543eb01a1b5e1008ab390e5b84399598dc946fbb3832dacbf7749f2611a5efd65d388dfcfb25a6b78704b9bf52d4e98f468975b8b291e6d6fd89ab011ebb8a0bb9b8f62364e1e459a00e77c99377c9c2c2b5ea2a1d064ce8d8cee033ea330cfc816602e5abcd6ce8a4b02b4f83f7ded80490c79c1b26a096669469348093074de53ef81bb6941b475e4749c927f5ce7c6fe2b7d1bcba05df8cc703caf3772d823297826129dadf7c2432d0cb959d9a18729a4084a8854c513fc1c8cc19a38609850997c6f947f6f83a423497d4507d3a92a43365b1f172babff17c406515ab38b2699ea7999538cd881b61034c7a059b54131af60638059949696d73c091552e08d8430a0a940c780a26f150d013a2c12dcfa2a9db61745a7e3fee7a59e7d62729850a4ef382d315a91278251a0550fd95a09765a36ffba2c8bc4b153f25d09793fad0ca1ebf3826dc21c5daf0a3f2a21ec64789f70fbcc3f702ac9788b9ec32a9463b6f0f3f69d097e0a78c8e4b75e98b8ed44b81ec210d41d3b7828d233d1299c43eae009adc78b4e89266a06856af61de13dcb0e55b6ef842e2385ca71799e0177b3c1dc708b5d833e43895309119867562ae86afbc7a247e5d8bf4fb86cf38e7a8493784c5ca8f10e9b97bfc21e3cde5d8ba7319efdff61bd798a0e568cfd2fa9174ce97b0a36147f7b54989605f0debffacaf5fafccc7dae5ece69bd232fc3b1a2a93c2fb7adcc6966e2a8121582a729e93ec497773f705cfa5b2e62d081aa1407e00c6679af472bcce7b6f82deb72463187060a73f6e379138fba4e99ca01c88a74cb50b5a895332dd4b5fad1c7a6a954ad0ac41e17fc1649c1bf13e21af56073694cc9bf56c1cfcf2f2acdf86a48e74ab5b7edda70eeafe1aed29ffd9bb839b1ec10635888f56b2206e6a69d9bf3f6c15a3bdb70ea4a16109deebe25bb668ffa37d01a938ac689d6235c2670d68cbeec20b051ea6fa36c679a69269266eb84123fb0df7a4f0b8632d25b685456e81eb2d1b301650975ae85d47dde61d5d89323d0e63c6ef22f6e9e6c8521a2de777a234ee183dbd45749a44404ec1aad32ac31ae3f8014bbe6553a9f8f8a748fdb8339faf799802f48c3811ba0726fee8773ae8d5a8c4cd8b7e94d7eb1ddb84542d1d7d50304fb9dd6a644e8f7a6c034fba5986b93856dfcda080ddfdbd68e8de9c1b8ba3968a45df01d122fad8a79ba313fdde3a7bd3aaab85f297ef13bb953c13b378753a1b69e88639f4488d6f10f6ab79c7807713e29aa4f19672ac7a2bd96bcc639852b1db128673ec4a8083fc8b5601f389a93dc3e8e0a3eb89f40b43f54fa2033fbce5c54b1dfc04fa95214125c931828bf04bef2155dffe191c967b13a7df1606ab86a9a315ca7fca5ac3d1c5b826d0d56be1d4d8fd6e19afb36ac58c1de93af0d8c66d49e64e1cbb95ff86957edf2ee8819cd824d5fb54568a659c5cf042ac1778dda3482b298858b243a82ebb9caf767ffd469ce4c590be61fe4b01a68fd191e9d78a849e12691983dcfb04f76387aac5ca4d76f240963b7155669272c2ab1b84f48641066a742f46706a946ba9e45eb5bbe3c288e7be356c4cc2769285603bfdd42786573e74286dc9391b2fe0a47430cab3dd8d07baf9bcb70df97b981349743cc64a971e2ca8bfcea58501d4b43bfe90957b351963e70b6d14ba6e86051bdda60d6c27f850f4d154509e6fb2575afd6e17288ae825a0ef484ccfe3c1eed00fe88b5cdd9e0d000d4b646729878f969e9ce252e1bdc80ea442be271ea318c980ffb5d3dc4bf8e75a8a3a201ec408e1dede7f91f56cace0e31b70e8e854c9cb87bfe5a32bb56c7f20858601775fa26238e72370b45e02556fcdac17b215e874dc3dc3768d457b7757404ba81a09c9de7ed59f73e0647276b7805c3dd8fa95241d07fb7df454304499169520d2b67a30ae90745b3cea02d455dbd08e0ef9a9567ccfe8442ebe115287b636b9e90ab5748ecab6a9cceb00e5cb98bff5343f7ce5eecd44975135bfacccc63f1ba6c10ab177f43eb624b8322dcf9d0e9b541bdb0bbd3781ee003c35629db519e2e8655a47b2b346853fb29e864f70448b01666d97513dc98636396ff91cf0246970f4b4af46f6f48f4edfef9988fc7c00381560bae6aa4731a64556d8c67f6b9798838cbebf36a6c11839b3c9fb30ecc74742019a17bde63e481eeedd0f76027252a46a3ba41f9f958a92fa833eaa6fb4d606d1afa197a983b6c53860e4e8c75696f9057d0bb4d0382c730c21f51d937daba996781b964567fe8a511eabc0c5fbcd48cb19b4df17ec87a5adf05f6b0476ba4cf3864913ddc1ac107b58157203b7e890dba3989cbba9160127c20fd195ea2cf741ce57d4f785946a2ee36c3ad989c229570400c2d9b671907a0c17b57d0f68d61e522f97452753e9ebc2a44b8fc93560f98740a51bffed597c31735a84536ed188facdeba94c84c90f0681dd479dd16d9c33f3f697759462c2a5f74e6b128c33ded48d212597eb7311fb95c10dd18616af088fd7d67edfd000fb9a109cb7e97291af5d16e97372af620c5b289c458c25a5ac24a7fabf49559bb0271ae10fad96a3147248bae51c804054c43cab22f9381c2690816a35c74891a16464d068ed27506c293ebda42382c01de95ea3f02ab2b02d378a43b6c7a9c8109bf42079a67907df289e4f0bc0f3c1f847a151d938784f7c3c6f82f905d343a5ed2768a6784369d24db6b860e894d99d2b554c39385991f171cc522dafcff19d169fb830c21542405da8af23e256c7bda7f2def9af2f7a0eddbd16c9434a1d5baf05b4b3261232e0f4942d26e63e232f8a9cc525fe9571521ab35d684ee3fed7529fd33e13356b78fb9a5279a52411b2a24250a0a674f14f8f193406fc0e88667a44ee2aa16535e3ebd9ffaf68f85d7c409610ffec1892bd9329ac70febb0033eb49c3c5c14882cbdcaefad1a31c37dbde0a765f043ebec0f330a316fb310e7102b497aa07deb64a1fe8af2e4337ec9911ebcde8e03cdaff13e96b18ac05c56f77c30d9448f2b5cf41fa5f38ab944ffa9116cd7100a65ca0cbd8fb23fbbda730bbb4c4192b4edf41df90d8bb9f4d19602972eb354bec76d22e81a89d234c4ec533ef874612ff7adbbd9fa52ba215f12316a52059425760b3ba8058ec6b628ffe8b1aa005dee330c65cc3a2a6f008ec5e8527f63c1492e3d08b56a770cdfa45bd8ab8b7775f7830e900c5d172696adfba0058d654370f0568f11cfa6c94f40b66e0750b50148a2619b63d413ef896fe126604369a93fc3b38bee4b1adaa9931ec952de2c2ac333f30bf04ffa39af489c8cd74009485452bd90b602e56c6bbc7611604b60f737a7f2e72153d35209e8fa231b5b612c1b048d92d8856f1502792e3789ac11ceb0096f924d1add1114c74914ddea2ad2661ed3ed62d79cb200dd9754f5a846462149995efa71f1aef97218a11b23d0ebd29f258ca82c843fb751487e8bc865442dc223af4e55fae60f77abd6dbc98cdbafcf7d7212769ec16f9a546501ee9fca82a5433e829f58c205bc5ae429f2df6c54ab814989167c7eb1227e2867eb3d72d95a1b96c1c37a42a41b8733569f1eef0cccebdf0306f3850065c7963ad0d8a5e94d4256a00e66d46003009f85e72cb84b44a43164e1340d24352a3429dd00c91fe5a87abcf564c8a827198783913e285a24ca6ebf1e3c97b7b3e8c3cfd77581398c117db08e6acabe5046e201bd5df2c6fe8bbc6e4676b05279a0da37ef8be5b25d019913b676dfab2ea796e8b4deba436b29349a07f784697681720004c38d77014c7a1393a3a3df6d8a37783e0fefb4dac6e8e12b01f099c0d07b7492e29dfcddf4571a36c3c17685d4fa9b12a14dffbf8905c7549efc2c45983ed1edddf18afeceb05d61599511d1fbdad442e8f6989d1c1da6d9885e737898f18c9c37bb9196d917c4cef1ca9557af586fa5f22c7671e757e3fe3feb93fad990ba674ee84c1009bda656d53963091a315026cdc2f10f1c482ae096d4c089a45f257fed3102d44261accfea962e69d893fcf099de823df084eb8d3748c2732a34b283c0da5c3a8215f7d89357e279056154332dceabf8a7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>薄荷养护日志</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E8%96%84%E8%8D%B7%E5%85%BB%E6%8A%A4%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c0362eb0639f92a183aaa164ebbb72c020237c3bea751eaa8703be1c3ca29ba6">3bb9165ff5e6bbea951b9b42679dea8a305cede40e7ef5bb2a1eb3c75cc72fb01152df24b6bd0adf15261f2b20a06ca49235753e24d969c2f482fa6f31e3878cac1e2e5fc8f45eb0208386b0947571212f5ab1ed58cdeecdc1597d3fe7aa1c26a74e72627fb03aa411fe315add7fe623bed0cf4e0562a71215f6b20adde9dcda46d9e4aea2bce808de16a6f1c24037cca3c29435742c0e3745b5001c632ad92866d6ce6af1ac750d07f79d59aea371e3138741eb1ba5b03d66a0145bfa5a54b54f9746cd26ba8db254c6456768dca2d94b2312724f7b3d202629e3ccb151bc8e16b402dbc1bcfded566487c2019679d7b3bc805aaf28184932712fc0f974d106faa95727caea6c152659588611f4f51bb2825a7f1170fb820706a018aa4326be76e866d62213a5b897ed7010be62ff6f32e74526a98689cf1bbc5c95aef2dab96afb55f9997266bbbab66cb2fab2e05fc303d97fe63371d73d6e059699595c8cc92f15e5604b761fed5145146c1943d0c9e6430f77d80589dd57ca22ed3dd91ab7b7011c1cea5eb144c2762f3d111dad63d8777c2d07401d2985373f84cf39d5747635d1a6554053a1f94bd9ff3b1ea8626c2b2e12cbee2ef6138608ddf93559390b80d50fbfc04dd0f981c49093fc872eaa1342222017c18839262de48d5e8d0c90d79bc99999a82291ad57714d314e804a049757d115a2caddba4b46e30bac26747f2062fb5ed82c9ca9baab21013a30e0404f5a6054264eb6b26e0e5bda872f067c2adbc896399ff3196c8b778db854622f0fd35964fb77add4dd542bb9efc32d8b04ca157a5e4e4d7bdeb0ddb1e724cdabb7097160ce464d974c32950f658189902e95ac177e9f7467848c0e7c5b623e689ab4b802e6bd0862bf8bf2dc8898f1cbfd9da7d9c4ba19df7f94dc636f97f56b65cd973b6ba3b673a5e1bc62655b0c66d96b526edabad0ffc7134e2ccfa3f98051e102ff5c35744571c40b8c40212025d18a2f22d1b024dd094c59902937a4272a029173c8eb1b1a4938243cc967a8f67f7437f96e4b6bb196e9e802293febd19087ad305ed87a263f24db99b06ff64b679d373e4d87e23c239517540448e9354379d0cacaa59ec145951aec6a6653c58c1bd00ead2c3a957c27191438c0db3ceccef57e53eee7e8829e7f8cc91e6c0890e66bc333658ab42eab7c1ec7fce6798d834888208ab5ee42e23f10ae483c1b38ea68124134ea9aea5f5368e6a9483daae1748c849ef490c6806947dc50c23e17b4c4693a8beab9540acbf0b71175d9ba1eb8f5e88a5a0992c62b7adcd350f71b883e7f3d89863dfc36edd8bdc902b793a8da3cbddd20b91165c5267ef4cadba3c46e0a1070831505ef3ba244f01dbdbf65d16413e8cfc66998adc7584c83a5b0114b6927bbba7090e8dbacf000bfb896d792a469e6c1f0d58ebceeee5ff927e63111d6dbd3ca63446375e5623f8809f2448db27b49862b87c3731896c5b1226e19d03f4da0c4767d85aa02a8d3a0a8dbca14211a1c7087804364eaf990bd4fd43116187155bb4865d4d0095ab1cd2d97ba9f4cdec260eeebe9f0d93371ad371de1bcab7852b3c6e746ea177a76e5cda53cc673222297fa1f388a50cc8c2e08f0adc14dc9311419011ac523dfd27f7d72d112a82721a9f44f68b27d60a25723ff534f05ffdff69af13e630e49cac71628e9a06d5f737995b052881e5b3071bc8f4726e9c82f97bebb9017f7ac1d6532dd491b40e77181ce722e20d942c2f7a16e996a9aeb05f4ed9dc8e37e65c6884a6bb148b0f33fd27dec5fb82152a27fbbd7bc1740152c5961c024b5d82f465ac3795adcabdbc6f79158d445893d152531e2ea9d7fa7bbf8c6841bf25510dc3a39eee80c0209f5bec3c951da7e4f3ec42329c3859fc62651c320b6ae0e521c3760619f1c4c4cb67d200c0a66a661ee8b8945523c9e157fdb5c6400875946dbd808af4319a397f2462b0e324383ff8c1f892e451c8e43ef03b53804b1d772a754848c08d46f8cf43d9e493639a368c102a3ef9879d51e107ade5a79d0ee1e3aae3aec0070e051aec80a8940502760d86775145264e8c02d3883fb5e4b849613eb9ed235cca98de767caa823a41ad32a8a494804d732239fb8ed386d3d00f42646e8731a3e434519f9d6791663372d218c196a013c975741794c2d7b27287199113d9ce3ab46b3c953ad84922ee8bcc1697b71c2a9184ccf90cddcea7edf36fca97d8186f1790e06cae4bdda37cd53258e0ec2cc946d6eadd853e44ce67145ef7f966a7175c655074f047b2667c2bcb625e07ca2ccf6021d4b61c77a1be6be8d75bb01283a2e5694219c631613d8359c58d250854b9a1a1264f537aa34dee63d6871789fc4766264c8ade9b037a55ac38bb9d227df2677ed03bde3541db00c05bdaabc97d80763ada07ded764088fc47264256f285a255a1ea8c46681779f8bb4790e6a1dbd9079ac3b4e11663212a9e7b79aabc9700b2e58134dbb3862328c2e6b9aecf9a36143b475b7f37492494b7482c5acdbfca88afe53735c6704eaa11b774196dea8ecc8f3a56bed7bd872faeb14c44385fb72f9abbd2439db4215b10b017c2101b92c7594ffcb1f8dc1604c53184416e2e993239d0582e1a6956a45cc9ec003926d49403c6886ef33b81fc320484aec0284eace359d4816617addef47fcf17cfb33c980af6cc60537106346cfa5a2db41da39a560d7cc0e2f3223010701d01a7642ad521b592b0a2b19bbc62cc5b321b79548a287168e6e764ec044eb047e399eba20e3a6da4e23c81af0c129fbd6d9d00a52f668663f402b59522f603ceb119f457bcb2da38a92f6b08c866fe81209fa861e700438124935b8a0292b4d2b02879a6dbe329a7ce7ae86f0e7742892ed425989ab0984a5ab48c0305785425ed9cebc8b2f10562c91205da77d155de5714a776ac278ccaf147c5ac630d5b0d5cdaed1e9ae5036856e72349c742c85dc2dfe5bf1277f5de466fc87fe6fbd98b5b70c4c41a7a6913b1f76a355ec72deab4ddd0edb4a928a9816ab174612c3c1471eb0bb0bd856026123faf4b962c01ea84b35c7dee4a8c9279ddb55326c00b9b7c8f381e6dd85bca4ed19c01e43f4e2cc23977d8d496716107e90183cc094df8c150c4c39e487e3fdc13f6599dfd8396ab6bf7787c1f55e1517735ebfa49d265ba7412ea7da4f08240d21230ca331203417db9b764bc7bbcff221d518ae28eccb38296362eb62a2fb543dea8d582b98906514e5399ba0385fe1e52ed2f4cdbe9745afef01cd1e26aa3e58a247fe1b55d233e7e2efc09fdd543b25cf9c55f40d02b3764eeb841b1908f203ba9c95cbe4d4b634c6e75f28e631fea1c742ef2f74d282874a5fedb1a2322dc48042171e453bcadae1ffae775a2804eb103233b612a19c42bebd2a2956ea71be7b04d0a1b5194f0265e3f6f999e503c28cc2f016f10020b2a67227aa6c0b204d9bbd53bedd7e80ad20c37f4754ffdab32c41e6286d83ec8b77ad71d7e5ced77448dba9e2b22eb98e5f91459f74ab88bc86446c61687638db59dcb2270160126cdfcb8538029f3446776c1c1918ef615af999d2d0095c2dbf0b711dafe79fd82c243f417bd0cfb708c92d8de0d3faafa3fb68104398f7c41e45a14b34762cb992854e9fc332e3bab4cc0d0a7cd2a0d5eb3ca761286826eb228be0b824df56eaad3f897d8d110cfce14212cd3a94776f6220c82fc102ea3e65eca29fb09a46a02966837536dd107fb2af8131fece82952d7ee9dc50b94c311db9e2c25dd224efa43184bbe0776451a1ef372c1ea5f7a9b6ddbb99294f1d5ac661ba065f354057636e0850529e9df0474aee13574903b3d536fa04c0b40cf2e00c44c0dca2b9128ebd16ce3b2836cf12fbbb2f5e2d8156020a10320036f1def9f04777615bb9b98fe64b18be64b8815db859726f83b2060996f7a790a335f3f0138db4468c5d99f1a50521f42b37e39e9e00b02468cc3eec95d36a941807433ffb9282c2453613c29f95c9854875ad35eb924b760f48f0bc50df36dfe625d6cfe11e271e5e07004ff7b48b6eacc01a93587d896492deb2ef0b8ec0406c186e002fc1a153bfd746de7ed5789b7e604c883a3078197ce29aa44fcd4e462994668cc5bf3c07b59a8d79fee3e28f49512d57a48abbf51e1718c34ca5f1466b522aa51953aaf4b5e28031c7b27d0324eb40caa760a9898bf29db48b8d2c077e4a8a93e669e8067ef11c184317e647f7d0f6af15bf02c05324a714a6f11f99e498d16bbd0bbdd51ba7f001a7ba5d5c337937ffe57809146422958c7d5077c3a031ffed45a7a7dd09c6d0e2b400a096025ea3e6398ff6c4133880dc2681fee59129f2a824ed15cea361907d48e459015df98e4dfd7677399c3816c5728d0dae36c4eec613c5b3e9bbf151a217456eb3c62e9ef47f618e6501512048374072418aa0251c03761f9d1ca7c24df061686f4bfceab6369d024908db902727ba6a4f274f439370ae79dde7082e63c85de498f2014d380d6a0a7c976aebee5b27e77793bfea5c943c88287d34fcbfeb5d661e6f0e293c45b3cad4141c7957e42d94a129ec8dc6676aefdcc8cbc0dbb646d61a9c433f7c6e8b445248899a6185b1289d2fd13a52758f6d818e699999bb943faf6c8cd4356c832f9cf46fcee7ead8ce549b89837ad615b6399069f874a3ce55bd662dd5b7e01955c6a4846c6620da85543bfde73e7ab8c3a0aab34ced3259f35140cb0e1415036fefd6f8db471e1d37e02a990d2e5c76361ecbb81dd9ab9a76d25f72f12a0e0af51ee5c2b514b69a04c74662ef05e47ee1f8af6e58d3f4a81398057b6ef187ba888809dc4b4e26c082a7ab8e4cd15f8f06a5f22985769c55d5375dbe32bfc483e7a29982e87b02300568261b30c01621968cb78561b17b7722cbd7b8882cf41629a2f665b1bb41c48259087f8dc1f7a382a670dbf5671b2515cdf7d252dfbbd2e993febc0cf828826dc8fe033b329d650d3e65add2cfddee67a12dc034970800ec2604e0a8bd8516ffa400b62b6e589852d95fc52eee1002c00a4d55f1740a893bad098c52c7c65c9d3eaf54938e000547cadc50350d8d5c7a8d38d1593195eef40fda75666484edcec19a06c1ef192a80e98bde83713118c1916bf8902eab1789e8e447b4be22e083a26a24e487ee43fc8d5a88f23354f44dbb1d9791f5e282c7b7478d640de5a27e4afe4605e0343ba4e45ffd9fd61493404b0a940ff5e4732adc31440c4c5f2ed0006f027d3095690405f5a9be0c925175d255dec7e8f69245c638636088070722f2cb53b976ebb7dfc34b94de567b28442500ad328da7bf091f10af5b5de54cc611a0cbeac68b61939cddf6ab4c87be06169f371611e05ab2e9593c95023328eecc5ee36f746b2f03d7d61e2a8b44ab4cf4d613dfe97ca11aa5114e0e8854abbd8ffbdb309ccfc4f8ea42173d136a82568cae561958e2c6979d309ba846a0f269cdff8166ac295cfc932c2d9ddcb0865bdbdfd1eee3dbd8c9bade0c38301726391805415724006c81b67195370de5fea6fcacc013851f324f7002023e2121aafb7491f72893775deeae76d33293eb6cac0229771fb928863b95a4a4690235c09178c8e39d62914ffa0f8fef8ff30bfeca5c75e504ca786e5f3db39bb71930563ea748ced5ea71ff20d04a0853b58647835203d0065d3262091a605bf6bdb83c92fb7937b2d0a0acba4f8fa740fea38a3dde92de8d21483a27a328fd856e53ea7af214b4b3d8fcc66adde03a4a158ecafb7acbca864d955e152538faced5fbe159ff776b4cf290f04923a48541faeae20d7cb15ac83910b0f173404d0be68e254fa4ab7abc0056a0519ad738ba8ea4a8df20552961fa00f7e0666f736745058c3ba85a2bb51bd0faa69e4ff4eebf56b8c4e1ee25f95664b297c8434be145dd12e9c15ead40a0771dd7b7e12bbdb2cba4c807e0a5a076142b1d7769ffdef5909ebe7a9c1ba73117d0380c9022dffc0ec304f12dd62928ef68f1dffce274aa7f4babaaa95d1e286eecf0d1133e9f0ef47a50b596df41efb12ce82be60070ae8299e8308deffe47f6a725b5fca0891ba4329d0defbcf75f732e617badcc37de3a53ebc78e179cecc9ef94a618eff9ffd38a2df19ab1b301cd18cb69dc2fedcfeed1156d90192d363ed605845369ee0e2829ec3c1cd304ef7b87be99448c60cab491e9a7f5c07a96ab35b5ee73f3cc6222ac171afd54a6275a1db5e5c7aa4c30c98767fd575d3aaf22661ecade4a7f06715bceefdfe46dabbae5898aa05f4ef0a065eb3e35fa7c4407beb0195a6a3d9fa04b61eea46fe552c152c368ae5c915a0c8428d3fbf6c29b671fb84ac03bf836267c9286a43d60712abfe20158e63dde74adb68ed4a0fef30432e25217e47c1b4c582db13b107730c643d70d4fcc6e56ce31752915456bd791cb15d3b44404fe25d59e4a857995d8b2a20e66f81cf68a66a3af28c735fd8f3cf16055a0f4b67d7357d9b4c726b7abe6bcb6de76a907b9ef5e7fec2d2e6999a4981a16bd754f8aafdad2beed40c3476d027cc999b2683e5130fe203bb10919d57a67b74e027025a4b0b19e904fe6667721086bfa7236c58582f565ba460240aba5343e811d7b487add44ce2f126e9aafa5a1b89364963b2d63b81032c84da70dbd93e7352ffed9e4db86527a6d11703a0644ba629bc1d7f23f6731ef3387cfdd8916a1f8590932d77c60f800da586d8836641a894ede960cdfb1cfd00055457d4f0b343ed8e287c5f73537ce2eb518e5e5d9c2a0f11df1cdb5fe646b14f1e64937a397bff4fede75b3409611e1a62aaacac34ee7c98787fd5dbd25e223a38441026310a74254a0d21fe76f0c7bc9f739810603020f54e7144df63ecb2c0b34c61ae0ba1460b20c4376b7c63e8e894c6da61d039ab5e9b7e75c0478b50b723192ce83e0f1c58913a2d0fbd5223a2622d4fcc7f47d1941b6e3e64d97b53ae111d74ebb0be942415d391739d867bc8c5f6699853365856e4e982009812d125800f3e36f8341a6c984b4a991baa3562867e89a0c7f21ade353264cc51c3b3291ea35976830198ac6e65c185169ea8d4ca54ae5635f96b375be21c08bd355934305dd05e4cf0bd598b9e790ea36d367412c68bdd20fb6e283502afd333f3e35e5a0d9a6b4e85d65474e79d0d74f20639bab3c693789d60f205724859a14e7f78a29842145f9d181b88705f7391ea464d3d04ce2f33a5dc1d7737f999d539284f76a747d5826749061bfc74d717b2ab344c9299c38b93a7389e825739849993956a8f2096d896a99636751a408bdaa3ddd55f73d89eec1ae3ebd886f4f854211a2f39f555b7ef6a842c36a673a8117847b190ebe6a660b1a738cf84ea3dba7b48d911c3837e067e7a2756024a73fed556bc343f6dd665a195ddc6efbaa28f4852b10563e4a0543a074f1f1d21c7137fc9ec4f0f0d436541d2a1c4350a203933691d75442cb203c5246e594cb67dd847e6c8681b8a981773453334f629b481ee37397ee496566e5b746618da84452de9308bb41053e5363d768b18eeacc135f9eaf6bb7f9a66fd762c4560082f9ee03ab3e34da7c7c4341b5382f3430b863b677ee53a3bd83c2ebf1909bedb8e211e360e7ca63939364bdfe5874b07c55d2cf2800924452b0050294a57b89506b29bf2a39017933e8284dc9c1d2a461cc543f446b994e4a3179c6f2b61e3dc748156a937c8e693042b1c625049b036f51724b9f778130d4b4f8531ccb1c2c918e9f0c2083d027f4165462d5979c27fd30cab0740347f924a3ea4c19566e0dd18be3376598b21e179a79685437e9c0761e024c9f32858d056040d802af356b017e621e712f6e69a34f6558b516415ef34f34994e89166d081003a397d2d117eb8e64e3d0083f71ad5f70616f7fe5ab8fa37806b48885512d5a5c139fac94dca2bfb764e9df52e691a5c8ff1197bccbf07369e87fc784663aaf56de70ac0e11ec6f5db52e7e537f16f494b8df9c112154e00b5f19ee4714eb3427c5ef8e209aaab1243bfdfc1cfda3dbdcca2b2dfd8366b12bd4423d8219e41a14e20c02d5efe51319836973f747906d67a501d44d8ca5704da529ecfc66a1e2838d02888912573050a2611ecaa6043bbdf4cd87a85be69b7c2438aa49f5121170b227de93876bb6a8da6cbbaee9fa6e9466bcceb545f2c3a06110ea7ef13310a941874c0fe126fb5aca5d078534ba63d0a236c5de2d421e341de443ee5c522a6c721f617f1aad89fb014fbbed02abb8cca9a84df43c8959d97b3025ae46f895283946af0282e1018f507ce475b03bbf9037478300432366a7409702606e21603d328e47076132812b0f30fd407a8c6849fcf56e4ba6c32ba2737b1c3364b54935f871727bb0e1939122a46d1b1199ad9d9934df6fcd67b7c5bc6bfca47c6cc8686c69144ee950597afa538a6281855036ba0ee339d552b475426037626de93d6d5558b5bca3184f1082bfb860e57969f567bcb150d90644aea31dd6fd76037ef0354cf1e8c42cd0c20fb11a521faa84cc53268dcafff2d70d9ed87a4ecf3af860245cfdb1e79be1268b3c6b54c2dc32bcd0da6213994ddc54e72673d8e53ec20a94fa13c3cb24a6ded31d3a3bd821258d51dec11b4e3e8bc5e2267d27a96a10bed4344bf63d259cd7008ad8493814e307b55c7a8c73b8daff8dfc3e2d59f06ffe2b1704bd2dffd1d01990df90efe9cad8a2b6ce7103b4755907ec6e3ae19fb08a938a57c185b08adf07fb9de755800d14a01442e3cdcaa51cfda9eae530e15a9eb0f5e3e8e884c329832aac20184a2801d319489cebdd9400078cca60502ebe4216c2f4f596b49241b69b6ed88828dcc0d6fceb5bc7e7d7957f61d039cf0989a66ccbdf6a3fd715a55753764b5c3b01db8bfedad77eb25aaaa78fd5d543d7c13d431440fe842e2ca626a353816930fe534de830769edcd1288d942b3f3fd8cc2b37c3ba4dc35188a0415b97927ea29a6ad515c1096db788e8a9b8169e08759495c4d4388cb47bb0042ad5100e8bfff004354e9da66c3791e7bc62a384383af5259a500661145a585c97870e75f3b588dd434b0ac06989e40464c4345b8f6bf9b1bf6402f07c6de47dcb3a12f47c807792001836fa87b417033678e3dddaad10f61584499b67030833d7994e5a6114b6494b9d8e318a75f0246581322d8f7cd51d11ce815150a61b81f67fcea6c2f9d31089aa21f26e0268ba1fe553ba19b9a01f0292882c0dfd520c0ee78123762d4edf2b0bba1bcae195b671aec120922f47a4ed48c5d1c457de9e8022aecbced7322e3b60b51a454423625faae45e29c5f454e7db45d9a18956c084256daf9d390aa9434899715adfd4d48eecab71b425ffbc71fad2b914015b3e0b0a560cc03f3ab890e9bfa123f2e0d90c6713458346da9429a454591908f7c3d816ac5ac71c4b628ec60fe4f774c56a6ba2d0cb90916567a0828471678fff11e4d2f33aa97d00667571ad9d25cc1d298cdf3fbf10f95691cf28dc27d21f53f046075bcd1856f42738324613c06a7ffe87b0b6cf62a6e9a5b4e2ec14636e9b284108ebd98964478034fe61f107da0eedde5b696cd681af366712f3d4a71a7137187e3ddafe8f3b79f091816641c707e5e83d8db9d31df89755b29fd24d4726fa3ff402bfdc157ee2f454eabdef492616d2da5070ff344be22e430e10def9073ab71795731ca814d881219d08a5841adba6735b61b86bc16b3143b2b430fed4d0f6a9a740477298f7a16864aea404890339c49b241e51fcea484c931c171b12df70434ce3fe018908358a96b171573c817d6b4b786b35a161314103072e2982365b1f7b4e1702fd2b685d61f7785c2a8f2846e00c022657f50fe447fb4a7096433b5c75993981c1bde22bdc00dd6024b1f44637c39d5584e9241540d94f6acde652724592660ba9eff51ed3af9fbedf333ea25b745316aeab9adf607fe41baf755fe7251c22fc734f9fe43cc353e797a74e75329abe2c199b261f5198ef7c3f9b156427b95c3bcdc32d22c66bcc0a71cbd64b5a751c0a636ee95bac086f61b34a4df078890d9eeb60cb0d793370b5dd65252473c7b61d3ce093b6e9f65e55dc80cf5d5bbac2d87783abcbc60e7d2771d62e3316f2dbce0c40495c9d4d96b1105a4cba9a6382028803e1af35613a67a8c64bf29289eefd664e36125c0d253a9e02d409dee968a9bf85317c0536ffefca0485c1543bd360c8ac54dc6ade8c7f65d3928232784fba14d0ff77693f222d053cc5593cc4dcb974c04b7311cb15a1298279fcbb6565bb268e3799e7a210a80ad7e57a60b0711b08edc0f289c92ef59f9a52de725ccda5e98f1580c0505a6c009475e6a243b4de0715d78eccb36a58e654bf161a9b9535add0fb8acb9cbb7a01e935287a335b03d5d6b3186d62c745f5cffe77df59ee9177a794189b2366bfa7c433be531cad3639c2616895957ec34d6b4b4eccc64dfdddedd7fa5e8c9fa8805522a9aa8cd2e72c86705a9841cc225820c4c3f0bcf73d499cc4020fca80366daad93b2dbb91333088ef0106a82cfe5edbebc9ac3ad83dff516db6b878be2aabcddfb5be88e5d790330d56b927b275380d7d4e393330fbe82c9f6af0fe97f4bdb89b07a2b0b45f687bc8cbd244b497d8143363229caa6ac8225389bf44ccf81224ceb36b70d50d4a0c2072a85d4f2a9d9ef30d514c9fd545bc602d8745fb2118153d3d64724df32afe0c5bb7b159ffb97194c9d107782af9a3a2f38347df1e4ba5448c64fc4e17ec0ce6b20c5a3cb8fc62ff12731ff4f8df52f3ac0c7d80ed56b40e198f9005a59c523f61d27361d1513bf46d1859664e743330b4403a00e3f34ed14ae8aa7858f7fb3ed9be75018ca7854c1ddfbf32fca99fe29f5a71597cb596d32d8917758e36a030d39ba70b493f584d0e3f1c1f45bc937fffec2807592e8c0a212172f1668a59807932baf4a111e3f412291d14281e39c75604d7a2bb07bb30d27717dc89909de0504aacf9e8330e9aeb7afc02e78770d91597c1781304687b09981d6d4d04d19da4d3e6a7c1111463ad56a310ee009eb675357dadfc4a8859acd1ee0532c6970ca9abfb293e9c379f75ceac5c17e18ed13d4fd523b9e54d2ed7d3f25992e36c394cb345165dbc93a130e57bb9a22c5b6a8d5908ad5b565f8af422575ec1a06974cd02d877807e85af66614cf0818a30211b7a8d326ff032386ab948771de198eb4333d2933587a011492c9cbfb226de5d314cd8343112195911accae66f9b3e69e542ee318221e28349ac9c705429a127f4984ac684917be727e8823aee8b17594dd603b40a39ab43c389258c7aa54669483dafc2170a856b8bca35a4311e369cf5d06864f36894594901141ad7b761c5251d768fb815e9cdc8e29590ec198af28bd2993003f1e852a02610fb375ccf574ca71ab1933edb70d67690c00239f9835320715c69fccb2532928208831989f6712e79d1387af06ddf21dfc8e4d1805e77e47aa460b54c181755be6fdff4bc0b0640ccc9ce4454edaeeed30f7284bbde4be43e82743a247d5d0c0cbfdf16736acbed924e0702c520cc80dc6ab33e912db8c9764c619b0bf4a6e1259309e34c473ef0770f8f6b6d71c4ff72a9044b0b96fd218cd24c2d6708263c1f410f2037c4541a88efc4a09a871edb397ea8b8e72a965ddbd4209bc57a104b599f25cc8844a87d8c5d909ea1facbf2accaa1ee675efaf16c132bf5d071458eb1d39dc66e3d40f08fb2c4c561bf6c712260a05f9ccbdbf9acec25696d2d1835eb986890249f428eec42ae31ea400f6b1cbb47ce0f73947f1b646d5fdd8dabda8dabccbdb40b1f9d9f66ac2710add426334b7889692c0956074e701ebacfa84272bf6f4df0e9c8018a31212d05f48f6828ca028366dcbd17a78e8e3738ddfa6f778133dbf458962d88111790d546113e5b5d562c4abfb680ce7c436bc6488e617aeb509b07519dc862f3a4d558c13c3e5a238066225e1e9ed3b2c219172d8b9bcaa0c3430438f66ec65531396f7afee0c0ffd2beeae08d102250c2ae80bb4a40d8f62e9af84c315c4fdac5b7857eef1821b89a211f26e653baff3d81f226fbe25dabc20d4dc714178176cd0111c6db514a1f0a2c71470b9dc5972b7c06a78360bf272e43dc474f11a97fb172262757268a56cc69489ca17ad82b592d78650b340f5c78756b34df310982219c8827bdb7f55da4cd88e8189c849fb71a9b88d6d1379c5390932b8714ab2e3b35037bc3d25f24f80811b85e608aedf03cd26e930dcfb3bc4becf6e7612d7962676c3c233b2c7aec09b8eaccd4cc8eb0ecd13db85557651c5149b3ff8a015083b323d92658dcca9654ce7bd5bc220836efc988b86c044e5a63aa63eca5968726725da5728df90e3fc29c4b9b7c26655014cb1af7c889b1bac8695b815024b2668050c86a1737528ab2f02521cb22ad499b9448992c24b518b8da8df35bf3f54ba856ef4befbf236d70b16174d4da001406f8a1347e2b4fc269bd1a9497c56896eeb0841afdc0690505efbba46420c9deeb608a65f46d94daf0500a91d5c9b29e67a2498bf697b686f7a70675519999d77dc4a259563e115d3b638a68172019df2f006ef67e73cbc0b44caf9ea8103c88804a0a2ec143197a376f7f3f287c1aa85118967c8c44b4bcf653a86751f9f1d7a169f800e8c077a8e472c2ac7c0fcb563ab73bfcb09dcd792516b7c714673e95e251dec2ccae8b77215fe3a360950ac80cda78b68cc395980ca318692df87c8ec8f3806d9a0d81ab32d45c5b1cdfb3e3e995edb092793e0bac85dec41c6939264d1da1a9be16bd0add256ae0cb213eb108b86d76afed621c9a223e68d5373d45c4addb6b5b80b3f52a5653a6edfae41580518acb464d8767619091d87823b2aba84b8d475949128593f2efd766044d9da08e35e2ad75b3cfe2b7482b3171121e2c07589d70e47fcfb00d385283d119961fc5d006ebcfcd0fb6980cc6b55b095a86ec2e88d34b48e7b0e2214694be5ec34fd9dfaa0ab03d3afdfae4b063aa5bbdd531776f8a4fa25e6ded74b5c1c2a9ecf4d6f0ce02c13dc41f045f9f033cf057d3b2aea06267fc5f0aa2fa5f817ae19ef937282211bff6b973aa65818ad4a980843ec121de18d3a98da76a72b7bafaac3f6acef82e0b5a7d9c7bb0b87a3874b46ed7c7fd318031428c41bb324ed7ceccd325068447f2780ac8b3a45c87ea6b778afc32e98db0d23bd0eb03334f57507cafd4317e40a0891dc54e3d9f4f68b767ea3f34c5c8df8d81b1d51918e2d2d2826c554f57be23c523d8b430beb6c633ad02cefb551aa1e25d7fe850b44fa2e6c8c66ef54c7455e88bc6f10ffdd9fd50cddc8ba72297dec33365c10703f86f39e4f40bbdeea2701ac50022ecafa31f133cc6e3cc83c40bb5d06222ebe6e266b1ffbd9e05d91762e1d5b76b145f6e697d9e53f0abd1658bacac428bf5152e16372c567ed6f5d9625531367f2d931b85c3b4d85eb4699629cfb54fa3b39d9b500c2016db54f292a8a9d56ace741cf96b25b62af4018d55432450a8bb5427827ddf9bb2a0684d5e4f11e795644f63fc3111b87af17ae29bdf718c24cd2719428bd25950b2eb18085846d40e4663de200e14a7185f1ff22a3da35719d2539c235255a67b4cb02d4c944d32b8262b39de2b684ead991d2e7a237a0b028c2de08f981017f21aa2aa26883487f5d82b592bbe9d3944f5140cd2a1cee92037a0cd3559acc75258e430eaf82722d33fd9cdeb95173ae52a8f68e850179349a3b0558fd4bc3d91777ee1870c7bbfe68c88766bf09e52011f579a35461bfebf4516c3ffcf089d600e392c946f934b8ac3e98c59a6e3dca0f26a93848c4c8ed1ce77feec220974a3884a4d24bdd9fb1e89b17c4830debee271418692c933bbe0d6158aedc53d1f8f8d18d6a98e238c120d1a212d7d054b79724ee09f88b5bb79111bbc92a14a6b2fadcba44cca0ed29caa7461efd82185ef31d0d8db4e754d57210340217487a5d2e1b47ab214cc782a992082a612f972b3f394e5512bdb706eebf17ebd7a520c91e72330b1c6b9a2b9253a6d5ae31a8fa2c7e62ab0b4b57a1bd5307013a6d3d1162b6892fbd49afb2e2a9dcf31af7473fe6e6535bad60950608949bd19ff1d98a011904debf9a8dbc9220d13488402744a2dccbd6f2a6355d3e9ab7fc4dc23a270a8be3c50de97f08c984fd80198fa52ec12fb57c1b186b07eda211a62aa4b275c69264d862824d87451a8ac0c66955458186ab64f0cdf77fdb65cbe9922c7e96f3fd0c638df37be597471c380436fc24bc7d004f4338321051219f976be7ed5a936f63be6202177b1d1788e33f4ef9715f0798ccfd37db1e022b73aa2aa0a6ecdce21271668010c9c50b8fbc2b743e7f9d90e7f97b3b35da6cba6e89eca6940d4723329beb58cd227ed44eca73a549242941ce29946a6b0c3cc2d3879cdc6ab14a6ed2f9e72bd3734149d0c0d23795632a2c38ffbac8789a2731b4f8cffe9fb477826a32676219b522332aab1793928351c6bf1ae1328fae3fa0d54ff8805331ae12e1232fef031bd92f0b737714a8ab09060624bb07d384e6947909a4bc9781fefe11fe6cba2a3cf97726df5580162094155fa3a2a597cb2d74be9c7dfcb57c7e1797d111279f8f222f25a47fcc6e90473a74b7dec307ea3c6cf002db3125d46492d5029c8958d82d87682cf7ae746a335c761ecd588704362645aa58e1fe53fd900e8dbf075f80f1e8ad0ab4585cae70ce03fbfd0f0bfa4e8911cb1cd8b760e03baab4e7e14b8b655a5467ef018be4c0b4894bc5090c0f42b4a73378ae21d95fd0a88b8c1480c14577226a07eea2582c009019c18e067d108f05d5adfb38d15c3bd9d84ec1552d12614ca6c0a565a5c7edda89447a35520c478c72f487c5c9e5d53e3d5079d6a35e2b6017f5aa66a5c4e3158c7cb32e4b0cd74108a219e9a4f01956f34081ec12502a6ccd16ebac8f5936e0d9933e2251b149775823d6ed773628bb80b15ae783ed681daed411dc5aaa6ad79977105e47e27cdeb4566e5df2bb364985269bdb41e7b48fd32278f5fc22ffc1d06b0fe8b020a402cf08eb6d576f78b377bd487e9f7e0314689ef99ba31607d1378a27aa6dafe28046eed35a6a0921a658c8e391edb281e51e3d8c48c8ac65021bd099246cf0d66e8b6bd51af7a537cdc5cceaf9a956e082e0c57a48266268d90adca02bb197bc4e1c84888b1179366377841f743396a725a049d19db3578316d090bc22ba8e2d548f92831c5bcb5b73048fd9ff3a8adc1abc108126fce83a5a01927ebc75d772c0435ac9e8eec42a443f26ff7e09ec87fbf04330b3df9a810606b52c4904e8c18587879a1bdaf436b5814a04602054363ba467a92298da39eecbd2e349dfe820334a2058aa94e3eafbc5868a20a91222baf481d0b19e6f0fcaa1f3cd51a13788da9bd71a82aebd7681456a59f542e5d12f9bd66aaca17d2a674fcaf9397f1f2bfdb16fe03a3502cf1e6d3940253aa679235fbf06d53f69b1d0ef49dd95ed165a764d20225d800577d6234c0a0a94eaecebfbcb9263bd13dddd94cda7c7b0c7b95691132bfd02014cb8eb5dfb3167ea37f198d560a67a03d2e688f1315a61d9958ae5ffdbb8d9fa214a8d23a7208e8d76dd9f6bd98ba7086c32408a3a57e652f05414cb7dd32c2f2729a6498b0cfd3ff4a242ddfa5609477607ba6d6dd8741527133604bb6caf0faa139314a2d610d5ab2b97f9dab701ce3fd77f0ce1e54240dcc0275c44a1db1cb1a6753b69ed63d35d5f392099931a384d14a91fb7f5e594ac6b9eaedfa67eaaa1cd6d9761d32ec6c7001cd44825ed2a5d3f9f3f1ee64796eb501c66e940ebab435aad0540ad6745efb289fea21793b4207ffd74abcaa345814a5a8f785d53fc58cc5019b33a318490e18b22240cf77326129c984d9292c0888eb314a930d53292c1f26318391470da3f5966658dd9307deb0e4212bd6f7a5230515bba6ac91e2698789b8657d6d849e099789a106c789cf528ca4b88be653e1fdeeb76637916af1cdb09a1ecd0a1901071e900a928a87b594b844406ca90e08868daecf97a5c8b6c45318725b713be4a863204fc3e74f59ad309a3a556d68ca885815ca03c4aaaa684a111c6e3d105240da1a6396ebc0a680f2e759efbe3b57cb81d2dd113d48640943d53b9e18b3ee7784f0d90ee6182e1e8f701aef529fbb61f0635672b92eaa5fcb0dc97ebdbb7e2190c86faa77f05ab72d1be2f13a689653b9798ee2308b0b3a6ffb966b43e9c601df58c4efeba481201dfd35df84f2b173f2cc08bf33be3fa6ee2d05f4c8521eb64d3ac3283d0c296e8388aea479c48d0f7c31d601ddde4bb6b228017387ec5727949c70137f82f8cf5eb373822828ae64bdcddf5ec8ebbdeae120c25308afa78afc8a132e5cad0f89234d9e96fd146e4d7481d45691ca59bde58a7dd6312d03e0e58949d855760a4620eba0d498a8fc585d93684a2b4bd73bba2a6f9e08463ee9fd5a6632cd7c2cbcda45ae6585d348bfbd55b219126165f7c0e271dfea3b5af7ef8f7f2a8a77e28d5f5d6946df59f7d19841d899f5fa0542cb712b2c3672465eface638c089d426d589c6e917a18eea15b8e745b6f5e580f54e4e8d15640ba6c9305d8b9a6f558ea3157801176663c69ca35f0e15dff15e9325e29fabcc21100ff1c3eae63297d9de13195a6adf80ea3e54ebf104423a396f6e04be0092091f9dc78d5f2f7930b2cf3249af3201803f3587efff7af65a5656b711b641e8406e763ee283d70a2c34610ffa26e8f37d1d2d74693203991bc25b53be6abc08f4ea195be9adee30a50351f6bb62d72be506ee4c1b481e6bdaead1ee65c3ee35ad5058c8ea0ec242c0bf1fa1d94194362f6741650a440f74dfbfc7a46a6660957009edadb3f0cbc69fe8bc1f7cd1301bfa199565242e659efe840afb6a1e39236553ba3627a44695660e949fbc42d40720854d6f5b0a67ec67516635c0c0b342f933d5d7f592016e82fb5bd8e57137651816875e2cbcb96409a05ccbec8337024b5b9feaaef5d8961f136c2b66c049bde93fd5ef1cf4f5f0db52cc30acf6e51fab375e59a60a1fcba8d5efaff7e4e389f4ef06752eee0fe695bc0206f2c561a189a985629410863d05af461ec12477dca23d564ae87d7322f46f3c868beccb2023579f27ffd7a129faeda8278eb203d0e986924b5ede36ce040f9540a4cf8c7677261f043955f715f5d59b793c45c5c9fc60505ad3593a9f7a41f0bbd640c442c62180a913a8bea69f54582492b013ef2daddbe9071af5d37607ebb32f455e2e2ad3aba2a083eaddb063d55a59eb9226b3bed28fcff7183214a1a6fd9795fb3ab84dfc470d12739e69380a66b56e56c394bc0974ad94a8847b3bd352801cc3dc7f03e2dd4a504cc98d3db02fdb9a98885d4d13750eb5f73aca96f4c87ebe73bf06e7d5d4688acd427acd2bbdcdcb35b4ccf4be51469c5f16905b1ad730d27d66fc04197dae61f811650ecaf8d0709e0d4456a4849d302b541a1ce186f6507337e2c433474f3f5b6fcc2e38c626c15a0686352f489a055f114327755b9476cb90dd7fb4d75e68fa70a42d1ff8a3c5fda568bb6580be3e6078a99c0852af82253265c75c9e161f054bc366f4bea5a7141a23640c265cbbd595ae11d7c1209d957b7cf0eaec93d49ac45323d01d16a139a50ee3b2ca7c7e06087df462ea0b539469fa67330405cff1b4146000d9bde433f2f0a2f9849b8b31c4ed7614fe4f5ab50f4133868f897669bf2a6fd7397cc6e8dfacdcb61b9c7ef57a2c358b2aa474c390e10f83cc688101c5872f58f7ffa50ee251670de134101bb3f6325e1a8181848db2d06cf878be27ad14bbf93c69cf2024b28c2018856bc3286296e9b53b5f4447163237824e97afc464082bd9bf20c050eec7533f6eb051a2c503274f879778bebec94be73aeecc008e9a036fe46f50961da88c56fee3145e37c4c9f88b5b469e26aa42f6c30856372260748e1a353248c0c5dc7d35cf8d8976bd2fde8232057c27e3854e5e29e8154ac6b316679b4c26c123e28a04130cf709f32ec8d1beb81fbe36d4dcfd4a35f7ae7e55ae84a768b9bb8f3d2eee1ac52d04609bd7a55cb96bf5168d12e9ff62bb7cc76a9826ea45b8dea77af7dba03a1c37458e31fdb62f78977b26d8e13b72c47f753044e86faca968965dc6be979f64f1a0688e60853d50b9d63859ab605901f96ddfedfd3455377745aa45e7b525bb6581d9aad414aaf5c5cbdc49ed4740981353d851e435d012a99b9b080a23bddbe186acd54366075b8cba9b2144af45f0680a27e6db77a113189c933f25d93e8eaec9da8524d06829cce4676b5ba9a6729cf5e9639f9be54dd3f8146fad0a55349105f77c891f84c2f0191f99d4d1019a56ac5586dc0d3e32b30da13e625b7483f641c87cc16edc088b99621fca241920b00eea641f942ca6779cb2da8100b10b63bc0a06ea3491ad39ad1eca1d0ab1ad815cb43f1f1f9d6336f771c97e011c50f5e93cf2189e2e5284580180406e5931eea418a1f26a54ceb849f223faa5e2b7c41c5fa9b921a5fa5c627be0615826549e44c502034ff66bc6a70f10dacc0c66a4bf0468aa281e00ee8ed3da79bee4a38a8794f80927c6cbb55e4f45559e0977e28dde296d15866381e80e3fea6d3a1d25c62b3af928a16bf944f60d7e587e9a3a108e61caa3af279f6c14e6b09ce6d58e2e8ee8966a123d9a50e8f03d7cabcf72cc48e1dfb1867790e12c1effdc6e33049b730ed5b3d8f4c874014aa50827ee172318cbbe4a941da31c1902ae9749bacd288d1c4e0f487cfa5d6ec937e2d0ddf3e8a9797c76222c3a3074b64affa5129fc982afbc984d3d988fd8ea493b73008dee60c0cb36f33f8ef7ee814a5970040ebb6c011ff6fcd14d15ad8b1c219e025db82ccfb3f6357d8eb45b216f23df863f6232d29779c32b3a580145041fe10b7e6158b1e1f04a0e4d2196779fc75251a9226759a50562c9785960aed0100f5c5a8b37b38e85440e4c56abe1443004a40ed4f38c7e19e437c6a60b609c445e542bf337055c8214fa5a8be8b7ee7f5ba5c0e28e557794af5a949b1fdcfa64f6c783c1b9110872dd9323af8376e4a19283355b4023145b2711ce4dd2acac7f8ebcf9cf57c9bf176bdb744ff9a1a8a12fdf21873b2852c899dd7354c3a5696a71e53de609311f951a079c14cb5b12c8067800b6f4f72ebaa2de1b268cc07278686a9911cc7f96465bc7994add3361e2c2ec5c77c80c134a272afc9038695b8c4e2c4b8c7a9760b82139fe87dab4a109435ac0c09227c7a4f42cfe133b1c66411ec6b3a2082f4884159bbcd103a00f4b5b7644b210e2a738f857be2305c21ab897a26187a17cae65f84b3e8319903802b27d209097d6166d72ca26c7881716134a38d2d5d9908d550e161827a243a00326e78259dda0e66def1beafcda407c0e50af6ef32bdf1ffb396dca180d6ef506433727506f1f625035ea2a1b3c89ce7f948124f6349e97bc26e0107eb5c42aeff51cab004dcd66cf3f15d8f1a2068b21e3bd6d327a66a77648ec6cc9f5960f7da21b7c675eb4daa1da4533e3dd464cd3827deab787c3236018d497fcf634fd638e3808012af074e5746a1ae3e00e254586ee2fcc58e673da1fc8405a09a27327ab6bf0f0fa4862e3155b6b588e8b984c060012e504d9acc838db707ac7ea03d5badc1d76a190477720a2d77a62dbebd7b3f349cca6ff23fff53d7a2b3b25d48e7f3ac89037c9aa37ce0e97a5cfab35a78089ecee69c78e0d80ac00484f46e5509cdb02587ecdd3ae12ce9fdbc957594b8ef736229c6aec89cbb3ad68f07695c04de5d4c55ff0b4f3222c40343863f39b5ef7d7f18d8eb217644a8895fb2e9e3572c98f506bc4d308cc196b35cfdc0b28a1d247f3d4a314580e88928d3f6daeb1f31b42f5e46fc8f232a6cf611ffcbee8dcf89b2446a6c23997da26f79a3e6578cfaab60b11a25445be0de357525f568b858a8c2fcd59e4c9f8fd5f75a2117cbb145c7ed72af613b29fa61a88278ee3c8cb7e7db3c3cd61fbc58a3bc21433724bc198f0f6df3184e276b7b32bb4b74f7df4da4415433343ebebdcce9116e0e7566dc89e9136c6a74961c02e85626982d33e4a3daa0a3d73af20ebfd6da455c54b53e463e104e35fb97c198b2ab86cb0f4e7aaccf9ca9f45a71969127120add7428fb5f5c0561c036cc9bf2dc017c8ffb524b2d14759f99c4bda4fb676454609fa7ddda0a8f4147b5d1ee116f6ae0a5c0575ee51c8db1bf4892bbdf6dfb8a5ecf25ec8c9d99736167b6263bf2a631ab8d8ae87015fc4b2bbe13acfacd821a5c9f3a2f4b0a200ecd8258e0b86f824c44480cb9eb727ad6cd8cf537363f71af9f24faa134943a1aa5e3b3384a7cb1fa60877942be7d50457addc5be02804aef4a207143d13545a03ce5e1e17f533d9edab2c8d2cfd40e30cef26e7ac390b32127fb308ffbe6fb789efa48c841dd8d25f100cb4f8b82abe3824d6a5f8a65386b78a2af7e4e400b39a9aed59e5a6dfe271edbf604e64dff0ce67592c37a21604dd7c2285080435130a53af6d1f5486243e38b5b538102a9c31a997b4488926caf67833ce744392b8dae7d51bbd32c032aaeb50d1a4d84a4395f72943243443edce7a495f268f9d2227cbe3a67d6c36f2eb880c0f306970b880908b28842561c919c4113cfedddcb8f84625756a239d562b50e1ad9a8363f975ad0d70590773d0236745f4b49c4d192af199b4530d432cc9b71111587a17463f876bd9fcaa3abef82093bcf4548e32fd7150292bbf9d5777ea3ec2c842ddc5830bc240aaf84faeb1a76c223f3a14b539988d779dc91cb86883e40762dd919c87b6d6871bf603cfd21b7ea3fbfa6514f5815bb27c59f8ceb3abae1f608754fe8d22999d76060658bc84b7e5d2f2fec7634449fa701770f00fafda3a63fdaa8438de0941d2b4af5b93e183f81008ae519158cac590c1621a6d4c0cd996e7c1687473bc3cd53b138d2131b7e0f0ff460b51f7f0988ae44e290cd63593baa93904e1af3ef62f2c6592e9d18cedee48b1872742c9de382e19a94b605c5f619f584c388ed94e595c62c9ffec547b3de8f13990d2afdfe824bf37e142458316e8699eb7492f7568697e7977565d89bc61e2cb7fc941ff6d8b6d83573a468d40f0b626969719af1a245960c6a2e2eae5d7c20f815023beff35d7d4f12954095d3ba19ad32e4ab198e0511e8c6740b51309ec737fa4cc87e5097354c6fb1c1b6584704d4f9addead4d8d56edf84e804673d058f6bb8e77ee3a15d77a2d8166b405457543622c765c63ec21ef60ba14f7b8ca872bd828dcd28d49950ff86c30545effa5687bd618cc4e781a3890990731e9a516a17e3256a20325f940ca3b732630c16bbd875910623a624256d11e21a5f15eab9525b558157041695fc5c73e511f53c2275e322678724ada997e907e2668ea7afa1f96e39c79faae70e63559d18be3f0a17ab921dd8d499a8d419071d1e274fe7921efba492203f5e30f73be760cf9780d292bc87274b9b695b916ac8d4863c55a28aa144c3808854879f9e1e742cd3730ade2838afc10a82b10e78e556f9bd5da0bb326d6e7477056e6de6b99ed89ee2d2a5979abb73a7f1a58716965d9e097f44b1b4e817311875f3c53ee6e660510bb9de1b3fb6a477c63d9b5203c2cd29480b74802c502abab2ce30e6f668462cd011cd934bb1669841cde72e49c902887dac459dd6c7a4a4e8ed425f8dab2b7ffa6588b7179eca816cbc2a70988441eb79941528ecbf20e0cec6d81fab7e17b5ae3d72fd08d8da03e86bf0ee366d4c644e2d75101613d7e3068ab0ecb98e64d1c271fab354c66e0c65ae9dad549039c06aa999153e62f2959cee6adb8e3b7627acc46801374860063dd9bf3af4e4fc5f1f318d5248237b614e14832b3cbe1240ed69077e6c12c0b5bc8df5735417e7c691e16d1259441c465bd466f10c5207c591d8ae8fffd52d77312747c7c488e74e3bb9da673142c1ebd19ae4b4be1d2fb69fcb6f29308a077060f331dd72f54f81a599caa79fb91ce9c94e590749dab760d634e8fdafa6d2ee508db43310c14a6466a25e7684ae5c66eb7a48a265106ae0cb9c1b7056019c94391140e34968d47496b8111a1293e138ccb1e6b11e58a9bfed16660e41f28b35bce497ee81b9d2087d23d64c58b6a4158b37d389a77a85b6e1ec7a87f76ce0dead91c7c076aecf8e84e72d4b581532d60f78fbe5a8b3ce9b7cfc190f3d7adc3364ab58c794d6bacbe622d3d884b0493084cead15736a656c6fe3439915b975f3b2e3f6c33db7f7aab8d45e477f5c1491acfef1ad4c3175bac855bd5e50ca90caebc7d739bd80e868cac27f6d7a24f7dc298a606c0d65b2c29c489710fede3fcf4d693abba2d4e0f6203441edc086eb5bddfa7fd99899a2bb5b200675ddadb9a34a6f7edcdf710595a48c3ef957c183a177e290c995686077946d6f0655493755118b7d437b5a93610dbcdb6cc6a25ac7edf439888ad7b655be35211f6654ce56f68bff2ed7872b83155fff945136f318548f14e6961db3f6d914f29c3936ef22152f0187589d63e43f82d74b67a2650f8fe4d3dbea55db3d8ec0217e5308cf1c43dbcf0dac9a0424ca54dbe2265b87d8695fceabf7c3f078fb526824d659d68410edd1dcd7ab316cbdced3e23821323cfa978daa12368023863f11029956399a96696be0d0f7a4f902fb86a04b7c9e1c39bc5c2973bc5d8e65c79dc6b6d162604127974a245aaeb36c5de295b3d90b39220538c0e79263ef9ea8d0a025cddc9979884be40e081a3420089b335933529989b9c46fce6d549b3a9fff592229ed2f75fb84166a57d17f69c88dc0f3e8e1fad97a454f3e0d44372f2d97ac4be2add14c64730fac1d83069e6156d40c7ac793390d149d63bb693491054c1a1aa165a6187a548349e2bc51291a12f22358178997708cf61a5b5b7bbe90bcdc8459cf48a8d999f6c4a7cb9dd7d79cef808de8641a0db4e7b76e8441ed122132921151739318f4dadf67495a12d16923d2500f8d13a86710c5ac5e90bf252adb551459b02cb23372bb08e05acefc88ad3b9898aa403c678415cb85449ed8b19ace034bd8f9add084a38edfc6890a214bcf0bb1a5488e35074261b34ab5efd8d17f49ad71e684ab1f200e517fd1f796668828a7010830fe1c186a515c0333f8c12c3268b66fd44baf0048e1fa3fd1e08842975d1b74eb0a1e6b60542203537a89cd1839c80163463c8d36ccf3effe46a324380d7c33ff8b43ef642a51562110b4c4d52bc625d4198cfac101d127dbcccfd1d4654c3d0e6f3835e3cea1ba97ff76ce9b39b03c8e520f98552006ee85ef390974242b4a8511c0b414599d229900063e14c152ef825b9a6b2b6416bb78df5a9f5c4c994483e92a38c958afae9d659eb15ba0edd90f70394bfda54682903ba1f5758fdc7763b20394802ace6159853bbbf9d45c1f997792d663780c5ed666c5380b2562cb523ad62393edef4fe9b4bb540f19760f59932b694c4fc912ee5223d489aa6cc459797758db5b32ec3061a989b2f23e47af419035ebf0ecf2b76f577291f7af3ce0ef91e1081059078994e8e9d27f288df03907b7454bf7c8a248ea29c1db3becfbf157b2cddd2a4337a1b8fc068005e3ca4caf1cb1a5ebbecd9565f806b4faa5559882b2c26abe4a1f815f7625f6e0b64e902575312cce891fe5d86d2a2c370a6cc35127197e20ed6000130404b5db59d2bb52cbb20bd76918c790a1a0865e2a12fcf2ab59d31f8872472a71fc2c60644cc60af36214994ba97cf359b1e1a152f6f0ee74afc8fa94aff10374ea42afeef681e133b04f15e5fdb6ff9253f096288052bb60478481f8cf7834f55112693b7a17e942193c201e04d9d8e2a5f04b4469cbd18750bf140511bdb5d909bc4d78b6c420a25c6e22dac6f6721d4e5b65bd84340315658812d36c51d467a9c163f679a8651369836c7dae9836608a7c34e924247e2ca7102b71acaf2014ecb863153b2f6b8d215f542f5b4e83fe0600c7892c8a157587bb9a43c83406caf650d38bba798f06</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>解</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E8%A7%A3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3133f19d10072e511fc7434e7a8b0be6b61f9509ab17170541406baba96d2884">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7a89cb2e7037e28244962c73ae44b5b67472b65e10ed11890669b42aef28bceb23d1f0affd68b66549ec1829c20de2df6b2a515d96174cad219953e14d928aea7a2b1c04625335c632df061d5f0ffeb4b695e56767d28bf1c0d902f27afd0c3a1fc1ace3439c096269cee5a741e3eb5579c7c85db7bab95515bc52c0f40b4b08a4020b1eb58f4111a9344dea91fabd28da257e35bb1bd6628315f660041b796f073c21769e838af127e4f589a6a20c01c67acfc993525cf509d6696a2119f4eb3f618284c4cfdb3613491aead91a8872542f1db0ecd92516c38869851581dd4045f2c7c2c43cd4b6e92fb25a01da3ca5246fdf3147f26c02271e0dfebc0505d1364fdd0ab588313b1062ee9deedf1a12670e6a6995762150a7812282303f1af6f103af6b56f8c2e457a42c5b3c768259a471726aced0c25a9d13304999bf1095f18aae89a3b6f3a82d09f81f7a0935949f3522f77308a0c92abfca722849fc8c8a998902395d45c69d7bd0fc5a5ad878c74662ff25eee047d568ba4eb31f5a90ea9ef090d9b6638305d50faa345f63a090dd026874a44ddfd36425a7f9e975fe09a783ac5782b1b53b19c2ecd1f7081c01e52f1e5dba6aabbb93efc5a072958614926aece4753e7354ae8f403d1462fba9d91b5026e9ba7569c06b156b57a80a4dd309797f8731ab89918782a06fcedeb40b3848a449b0ad4f4c775a0c9e9274d9259609b5bb51e7671d91b9dfca7293baa86fcbf2ca2a1b3bbdcc20b35b724526112c77dafb8cdcf99f6678afa7047b5f06960f3bb5ad8cdc2f0658abd0a2a8a574ff45e7f1a32622ecc179bf8825f75d583de284c847db7da3d8242a14fdf71e791b47b8c5db59e0294d2cbf360ecc8d1526a9807730c36cf5c5b4d86b644360b9c34117c279febb48cc3601ecdbccc0d8adaacb9f074f9f8127aa6a21f44f0fe968ee0ee698339177e5426fa1b7f624e6be3c380da0eec525e8d3e0ec2615db99dd3d4dc77c4e4fcc8a1aa6cff40081ed90a22c1a6a28906c18f5e435769d2b888483c2d0f316150a89865e5fe118d9c5ec37da0c8dcd8b95ffdc9d55f790058b61cada244b16607de27585cd9ece5cfbaa3ecaea3c60d4a2d828c073866aa42c2b2442572f22a008db574a8c7baa8ac5c455f3d73875c37d10f9dcc51f1e5453be57fd331447658d564046926e8abf40ff4000f374daead8c49093790ba750b9b0c34df116ddb3dea8aeda19589cdf36727059fb9a50bfdaf01a498b38d0201536272a9584db43227d0eabf6047d2febb3ca6216e5d0524ebb235609fcd169b4a2a9c016b64e70232a41b202e6d160632a0db18a7c557f6e7c738c53b49857380b8f84974eb5585adba6e02df6ff6f47e6ce4e8e9ee41b2eecfd9c39995252678d99585be5ac60638ac153b79a34c9e78c7d5e3c435cecaf8b1b022be3489f6df2759ebfb94e2774963b390875a4031fe491a04d82c8c7c7e077836f5159354e3e3facf827b1f69f01802fdc2503f96da068d82f35f5d1ea238e682e69a180c8c619a3c8cc702e77680c81491f5884f56ae54caaf6731708d327c915c63b949d1b20cdccb2f6fdefdc8477b5d9bbc99891530a83b9b6f9f50d91fc08d3999093d18fdb63ecf6f833e0661e7925ecc341779d418e9be986b625d17ce62ccb96c24f6b548e7021bb5f8465b2731480c60b77bcb3b916ba136703560e7eb51755aab0f6e3428f6a727dcd9e04cab4c04f852d743f3788e2aa008c46aee75b30cad84814df0a72810760b35f2da4314107c4330a7eba862af708c3584253eb11c19b7241ed73d642d372cd1b4f5ede454a3838d6ac4171a9e26e820ca12ee09b61</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>白鸟</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E7%99%BD%E9%B8%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f39d55663832cf5df4f3e4b2315ece8a04db974ef3d661644f179cb15d1ef183">e55e8fb0918b8b65d60b5b09d6dc221c9895c42adfd9f5723b544e43004f0924b5ef6d7b6aa284c580e875977ecd937d4481a716230d22f9dbdcccaab7df91fac27a409f5ac72691f8f7aabd9d0c522557645a4d9ce000a9a3741d8b1663072edd01c27ee57d374002aa7c15d7d1be696c7d9054bb5682cd25376a51201597a7d879252ea34b76ffebc964556ec01874a20f6f56d89a2e42a0bc37e797fd7c72fe04ef7b0fb704509bee549729470b6b39520ed03050ffc97e74d0d22926153f285bb2fcf60ac841ee1fd358507f0be41a4657030f03d1cf149ad850901b13d712a4ca6d88f65f8237fc1087bcdc7a2060faab45bf2de62c0b6e2357115afa0e8d465faf046312638c9abae36e2967b654499ef43b6497816c319d4908d12ac875646b685ca59fdd77f4c958716ca8a5b8f48c5e9d3711f9a13947872de87f01f331b8953317ee023981ebf3c7e2c62226185d5f810ede00776f314075298faa5ae93d16ae16b3870d5f9767b99e25ab5d888f614c5e6959fbb5cb4f57bb8b829314ad6448201d1c16c7e480638f0318580b0dee45fc5df4a9069f460964c20cce32c7706b783a839a9d8a24de7a8b378eda30f7d41308dafed890d55658c2b1f5c4c9d48728564d3d656a70ebc808420fd7aabb5832dafd69450544c5802e098c1a84580dfedd98f1c4f9657642980f7a77ec98cab1f22a271131755e25d0958599052160fc09ed22e15e648f5235c7b57a46de56d52ba5307a114c371bb5072a48950d496135546c006c3973887933f0f605f545069d2190e93cd0599ca286711d6cb0a3700cc144a558f1840ac8e512e8572906f09a0ddf3703fadce0857bcf80f04ba74cb7ad6ea4eb50de3dbc76b50acf2cd6763ffa5b9ceecb1194cded0937d0b55d35ff45b29bbab92d0b6a338a0b765d33f61ed2875f5aeaa30ffc9d866a3d3b213ba6df965f3133c623c6e8a082beea96ee03a992c6e8f5bdd202e39c82e7461ec7ef6bd3540665b718de08821d0ef4bb1beca2caa7185fcbedfb63479945935dbdd76dc9aaa58f049b6857bf51410208445fb3e621338bc16b224660baba9361e0d4184166a498878794d5f7d7769bab0817cfad3d1fc2a5f57c337fe8eb33fc38e4b6a2c1867fdf4cc3af1a7053689cfd20db599441bf9e69c17af6d3a8889ee4d710a48bd664b88b900e5444e0da48bc0c17869757a85f46a1a3ca98dad306f6c9592e8765ddf737c408d19f98bec70d113bbbb84c9b16c214ce08fedc6b2c92206eee032cc5e4eb482675df0bd5744b6607019a847fa7a7c1eeed5522c578dae8ffa6850f2a791fd99f9e3f63386d2ce307f46a88b60729bfecc58e70f6c87a8618a26075825e2923fcc890cd021ad2eb9be2cd834ae0de90ab796aca1b0544b55ea6fe3723ea4b636bbf6762d93d8ac5cd5725fd4090c158217f80e8190fcf6398d22f39b9c266691a28bcc22d1d360bd381e413fe7e798111e13bf3bbde3bf8bc15efc587b85118e704a8310a239d51fe890ec3416a0a6bd425375f074ba51911a09c99090be88f80d5111118b94ea76e4cdc44c735db257ab63fb88f5719e1e77da73a17502922b8852a7107f50ef425c6390e031d48d31b33891d292d344d21eb211d9f57a0165ade9649b2b8a589b293eaaaab4ccf6af44051d3a1f8c12a3ffda9b60dad0efe9df69a874f1a64e2f494986d69378a3ed10c0af2cf52cca2715c4c70f062b300c7179ca6e8b0fff4c0249365bd8d75c40dcf7adb209d23e0b4d4d64d5909e2bf614d53b0e272da333716c6fda207c57300abfbc69a9e1c9d83dd35790f13f42ea2e49c16604baf7507e7e9fbd1b8f48eaf5dc6a7709d2b5e66f700dcc7d377bb40e0e9200c7f32296579c4110632e051d035df4c490b2124cd69bd507c295679db0a56bad69d8b60e41b54f4a27264f53f32f269428a3b79249908b3c33f42751a8b602d0aa5fc44aa28ce5adb87198f2cb5763cbf5810a6d738f16088e5259ab97976a71ba302aacde4aac94c854cd25753a535c5a964bccbc13b335a0a1b2b0c380cf76b0548b7a109acc537b13d18b1a7dbbe2ec6bf56922cff38be791200fccc796f7d4a71830450f96292d947e446f7213efd3d62ad46f9f17b17dbc93c8a17399d444482fa5ebb0897f9f5c9c7cb88409cd74327e9bbe78b0ea75c18737576a4323f4920ff846ea89c3a7d1f10d8ccd421834c3ca9e27f7b02ad76553df7035f747b928af370e8a91b3cb842241e0a09d1dae07dbb4bad6f6daeb345966f8b7a1d188e765083ea853b0a17f91dba5e2e8e94dd9ce70caf2fc4fd2c1b1c8e8b65d93fb6fefa4b447b3eb2eddea3b6903f732a87a3dc8ac8dcf34f84de4483739d02e50b46a7dd606f789cd12089f17b6427a9f85aef03c4881ef8fa8ca6c7bf899c0e5fc3155ed1ef25a9f8e955645803841e4d39b980d7ff261e05be4840fcd19a8b3fa64b8ef768d48b716995dbb99dfbdb1d2e6af60f2ba7638ba8d07eeb310438dfd8936c658e5a46415e70d44488b8d88c13e4e0634da66f33aaf3a26156c0d76ad6ba579aee76b42b9241df4e091e1a7f17df209117271c57638f153cbf3caccd4e2b83d025b6881a1dd29be3e21b3ea7409144a5d07be6a8808e30331f38c246feb1ff4ba41cb4fefdb4db5ad177c2d561224556d20401c10dfb18709424655cfb6dff53ac86df7669610400e45e0b913d1c0cf86dc3d0243a95e790f2ab2b11c63a7db607dd45504e842a778926010f3763fb46eff0d81cb90c112c04ba91c2f1b8fdf91364bfdafbbfcf4c06cc056107988d4d428e744570babfd4be0de6c7f1b838ada93f4a11fca23ed95ea30b76784fa5bf9216e284013cedba141f62b4046da321b059ecb3f382d68d0f0dd8fb03c41e36917a97b3e288f6ee412becfa6d658e9ac7963def51ee98e855da69ea26242deaa504424ec2a7714fcba490815e75b30dc69eb7edf152c5d91aae932539c20a0b2b29b4c59fce1d2bc9c6ebfab1502e27465e039d97a0c751dcb8a6a17d6422548d60b12afa6269ffcd8c73e534cd30342451c75d8f355b0d675243be1dca145d9adebe4317848921982dd4bd0c344cee63ee36b3378c316144e1779241e1fa5b678db272433aa98d3cbe4eb7fcba7777404d8641f7b0e52d8fd094cb157ba89cc9b81ca5e8177399766f50a34cc0b26af14e40afc1bd7272cebc7654d082dd625a0abb718bf4210227812ef2c78af3d2bf7dc373230c75fb78b90167a202c19ef9e031e98617dd6f9487c9abf3b233ae0f6c3563f623c0e756e3445b58c5762ac7f3b7df99d555d455b826a5bbc0842955dce42f4d5e86363786a8c6a27a551bb2414e98a6c51530e7cdb69c16f541d032675409fd2c08bad457e73955661cdaab720b43f63eb46eb34d94af870bbb15f998d617810766f71e66a2d45f57400eae6f4604c7809619d73414a1620562d0a774ce5847cc109384ea67fb0adf49b45d543e97ba806dd89b9104492b3197342f31ef23327945184b7298490caaf1ec24d3afcb930ad680f7f540a71d2ed5847badd7d619b00aadd7cfbbebcab6a79105b87ed6e89ab8ef9ac3add904be8da2755add80690e5a36856099c3905bf4d02d79888e132ea7ea2c93d363a181925511223da28ef999b0c39684ab5c13ba239a099cc4c25254b499d51bbd31a07bf701a13e28b35666c522f443fd30f17d0fb3029217941596eb43089eb1018ef44e49aa33093ed43d57b474f339dc9f58eb32b75d395a0884fce267154b39c78053aafc039341cdb75c1afdddc004489e37f38570e48536c477d38d58db02c12033c923c95937aac5cf9242505536930481f1a31780a72bce43a8886358ff54ea13a26670d382ccb3ab50172ad2b7e51168a59bd6628adb82291865552da25bb9688c15106a76f3a9b116ff92499b3e44533faeda527ab9f81f29998dfba301564f1d5667337315d5b216922fa8384ada1aca26f6614cbd79572fc0569d95b181a8cf63a68a40c5732852ddf235ec3037de3e3aa0dac54e964b2677530bed736f8640859880d2c1fb3e427a491b684d755f39a1211a69dd1511ef68dc024a7fc3d294d9435283ff6972d63e64bb34ff2b195ab690fb3891983cee9dd672f15df9b9473c4caefa94f58632d3c80bc34990f3f72b379b7e91000e0b75bc90c0e856c10fcfd7e334cf1660c2a51aaccf1d316967a12c3249b932f663ebb73bccd2e5af104a4866e061660f473f2177ba2efc373a30950f78f997fc5848fd7fcd73df5d66bdb50434e30cf6b5d1dc8711ab98d5e000946434178595480c6403f38af1488081ca4a65f4198ff76ad1c84ffd08fbc61cfe3eb8eecf6fdca63a0e1752e9e44313918a36dcc1186e56052c5eeadaa75a6261f9d949702e80dc5d1557333068744be1aa6c5c05c03a9ffdf695a6ed606092a7867dfeef79084c61d305f3c429baec833025cbe79afeb282341503d1253ed7abd8de8ab58f5d86e1a4f56069b7f31a538c3e480d2544fdc9943053f98ff345db3ff1fac484aaa877bf1b6caa71b894b812d153e63f36772513e10ab709d493cc17c4ce507f6bd8d9d2f8901f5dc594a061eacb74903ae4f71478f73e5c9b4a10f9e43152c02d2c44a077bdc6a96baf512e93718206dddf9ca0a1bcee3147cf7ea3e610b2bbaff3a3abbae09ceb9882a70f143b0ba3c4980d0198eaf95ced4fee6b9482fd7da46ca98231c50b4cc0d971d3046f5141d90f5e2346b07323b8bb040fa800b7d8f9a33c081d95316b2dc52ff4e3ad305c731b2f27fa69836b8ad39b22a2d19e432c4fd27cee57c0b6d469188a1698a95bb2263c231997d243c84c42704ee04e020d73737f774efece8cdedae16462c54ed1680157eca4bb129dfdd2be90f69d89c82a2d6110ebd01a23e0ec69340b1292865ac7e07cb3f698058089d92eef4f679e581e72242a9ea8b2440c221d6fa1237938a5ed8c079ffdcf1666b0a1a9da494d40e1e8e2c8ce796a6aeb126fbc44be114e98f59facd93828a8f249b1351040b337732f3c427e2c0e700ba12205876883d047e6e5fc9a1a1c9afcc047861ce48e07b1fd3789f6eb2d33390a5470711329a35d690a963b80e612090b8ea31ce6ccbb484ae4b5d39b6b32619e1308d82629e42a787341c9c66096f55bbc5b6aeb3fa162fc2957aff1fce6ac430600622a9e6e87cbb4f63c12c7e8a70f563298afbef52fb250c7ca976d35c64232925b41b9029f65fb8373505f48afdab8391ebd0c1e920b22e15c86ee4a070c6e8813c17f60eeadca2f83d655fd8d5c3dc9f67f05fb41aa4e6ba4b7dc6d5ec4721afe310168be70f1c4e03e699f1bb072d980e0b0b4243c30a94c507340435efe0c039772c0a3e1e226417ee16c43bceab42928c33482d18c06de6656b78e182f35fcedd687b0173e08af7b719d12315f3325ce69beca59eed82c5700a1907936c087c4e6f38cfb4de5e890489a7e776ac4b8fb37df447fb55a9cb31cf66d3696062b54c8cc6cd1b810ccaf948b163e493ad1413641863dbdcaf5acfeeaac901240eb565f9937b83dcb34b02222b033c40da8317734542c6e63473bb105fe5ed6d6df3fae16663e522061bb7cc6978d155cbca4bd186cbdf93803dea881baf94c438ed7932c462844b8c077e975d5af0587a2172b779cb1df0fc4a4ceb35546a1a7f4402da41c61bb86485d083326e4a5afc7d195f1160d498b705c956ed684659483818d9a1e8d1ecce4f1a48597af0e7bc9309fdf37d86288ccacfa369e888e599d88702de5aeb8169479754d8f79a055ccc47a913b2c02d10a77cc43ab26319b68949c3a29ffa03c0143b9178760156fd73ddf29749b22fbd67b33eb2ab9b32791f106f9471a3b2ead4c16325b1aec3f045aa55a0089d4cb3103fef903cd31e2548286b68d38d2a055de17c0ca1d1eb1896c8011d8986402e5ab89c99617d1dfdaaa6f2c2fad95e8679e2256fc118e24e0ee75a51b89c8db6addbc39992bd5be3375cb167e846454cb2e57fa2d48f3d493507e1e336b412782ea7cfd69b19716e3ab9a1a46b3f34640786c5721e206391878a26ed505f9234841b33a921ab172d4dfe5e043ac0df09b5cec5829580dd54459316e2afd0ba4497d19e63fc825f16379f0e6545d5edf3d1d3ef60210906ca78e6bbb94231abde4c89235e4108c37b90ba4a5e87f5ea21a37e77d2a6c2778e1aa936cd068b2fd17b553d70049e926e3d5cbd481a9a54534a3c69a265114e7142aa345e125aad396ad9fdc969f1990abfae94f1149287fbbb7212d0bd37bf507ad733c35ceb1276ca7d9fe3709daa947b411b94890e4ac091add84d14fb389c50693c7370cb2ab644e0fe19b7ed4e1387ace49d2e238439b8cf1605611e5577935281b74d49efcb34d2fa4ce1edea00c9a3e501af79eb081b802f9fe6cd840e959292ecd501e65eac843c8cd35644bc51d24cef6b856961036841fd580f0ccea2c2f7e148a2eaa36a422d5d5f11366420f7b367f6696a840a94f46015dd9618a3752a76c150c683e6b1601a7eb99255e2df548e446d660ff8691ae82f916ab281209dc4f1fdd955162a6e74bfda504878ce4cd7cf6274adcd3c284aa5b478cda5e799ed74628015b05b301757293988b23c820242e521cf7fbef22fedf0fc4bd8e7be4d9524a8fba116d7d2150be16f21f9861bfc1e9203c9ef8d18ad94f4c4b9e561a63127e27bb38063e830e12486840e5f6ab6e801034c797f252a9255975f3bdd5c39f453b6cef16b8ea6a71cea9c0b4b49b701781ee1f16e87ec17a893972bbd4f6ac59294eee0d7a8796b2e815dced1d655b3506806d1bccc400a132f89db6ff7d45b71587e683fd28afc8af14a7eb371be60b9bf9f587c67774f0ce74116e066d7bb3bba3f0ead18b47c9c155b5587c4cb17d2b7bbb612958f7fe54712bb994979f9d303f71967d7b865714b80a65c327b396b1ff5abc99b12124b8d7ce2d36973befdd541b38a13d3f0fbcc4391a468f2262e2a7d87035ee253585b4dd3367c56551c300cf08cd8f31a2aec74a39904b2dff7ca531f76d38a7c3021b94ba23459d95913563de4589e249a1abfe493fe7d061ccaed6990d1a224507963974a6402f403ff5522ccd180b206494e23bece480fb7a78b92d0927a2be4e5026f4fac6cf22cb7d3432b0c3123814eebbbe719c69039ac4990c8e0309cd42825a30206da24cbf203c990d8577604fecd997926e69064fd68ee458739682099309972c752450b007a2b0845c7e051d3e33ea1ce5cb8bd146c0fff59eaa3cc6c861adf4329c57d7e4c64d45664d9eb355c9124ca4236ad532537b2231a2fbfe6fa3009bcf93a4501817cb9cd41718a90ec6d3afd4160b0f52fb6aa4cc5834e89cb1dfc75b2218f64f8261d35be1d924b41b3ffb1eb9e2195a6f3e51a0b63a2d9098fa805f232afb1ab2f8160e33d718101d74073da09d0f30a118dd0670416744134978a29c62b7bdcf5c59fe03dcbe0a87463741847891181ed04ff0fd20fe685f01824c47aef805890527cd330a826dd293d60f5371d5cf2f9b54d32e4f9287004a4476aab5ecf923197345169003fa15cfa7f9fbdd22b494f3a418d5c85fca1501602b0434f8e95addda22e722866f56274b0af1f7ef4c5bea2346ffed892485824599485ab0c30d9478c9c6070ca2151cb2409e7c4fbed3bfdfcb1d69d6720eb7df5390aaffa921d0ddf5dd19b3f8397f6459e71f67fc29bea3483f4aa917af58650b37338b0c64a4159715ad169be2c2e26be540c017c2804a66091feb3c9f3fca763e2104797c5858ccbb5e0ccb6f551f6f70a97431b19313aabd349a9b89eed3cb5a6bbba00835e74f92dee28b16ca8f2cc864fa14f50b9fda654dfdbf19be9d0bc60a01ff9b1c61ea6305b13b29f5196a3bdacf84bd76d74b35d051721c7020b697ec2759cb07671fea4cbf96261846b678cff06a14d658d76e539d20d63d11af14f67ce16903095837e7e4aa2cf0fc0cb9c45dc8a0e96cbdec478ac24301eb978ae944575cfa138ddaa495214f3985956aab92f4b61f959aff652a7e11f442bded98260465cb343ac8794f1af22c0d3e435e20b755af843ce5aa7b2004e03e802a2895aff3688fbcef7c03143fadb1dde8c1042b6a339dba90cbc3f1b249b93840e998ec1db001872cc7212a49aef8d6a65f79d286c8ff222eda626e62d2057ce18fb5d8b1c11170b74baf6e4099be56f57c868086d10b63d0a19d987e33e3541b9bb245229803fc98856e2ab7d5df815aab2856e8ede154e6087ec36a460c54f969f0ee4ddfb2d849f19a2216fdc235b2493ac88271dc73a2b027062da2f1ae979cf84d9b28602a519eed91658f8680fefe12da9519d10551ae38f4d022ec4700377f1807e6de2adf411a1bf0fe72f17679320958b45502fd2bea410c14ac85d864ff2c035935c0c0859322af90bd9ef5b31d95b23831c7add17e9d9c79ca521350cae368c74389c1ceb6cebfdb05a83acbcadf84b7a3ef65eef0bbdd5d49882deb448e72a08f55d40cbcba99ce03fb82b611a26e3d742590ac13078532076c3277229334a3b1669b9a044e6c0b94fc5d198cec47168eede4604f16e1678112cf5bad8646ab968fded3fb89df419ba6a58b23184bb0621c44433b11bd7b1ff7bcee78ca3f49a2a3099745ed7015219e1c28b288671fb5044eb1144c22fdb8a2afbdea7c67de581d47818bca8aaa315d752783e5e5bf72d1aa7b3152828b1e79a24ec0abc9db30acc232f8649449b7597b555bc2365494615d9af676ec671ff4014b60008f8174af61be6322d61c13034c1b6ee6c828301185ebe217bd2abad123a8d4e0bc048d7c3b03fae40c07ebfe26290567b98842dd77e053b16ce5c9420a887e6198baa3adf68474f4f14498443ce63e071e7d71be586acfff8cf44b96af4d8d4a6cb67b16b28b00fccd52bc2c216d1d3696bb787a0182df6e7c02fc40c77e64368d89dd9b5164f2b1175535b0ecf507cc9e364e1fd0b9e528e2b95f10483798b6c39d5091cb43296be8e46334abe57de4d03723cf4745b3ac7784cb72ea2b23a6f260d6a791de0a22e6e9194d24d694c11d52f89b16f1b4ad8f3011ca9e3abf947f9e218235fde8e84385d5f2e50e65a67412e0cff43c9d5355eb84d8159dbe19e7eff7448c797a7f398d2d2754da73848e953922a14fa1bc5ad7b3818a624ac53e3ff695d4d5eb4978f0d6ca9fac95bfbeb09405a6927e73e6f2d3fee5bac176bf2817fd3754725afe34e9fe766dbae1bee942997408386a86a185c9b4bf31ddf5bb691552b40d827e3e169b85b2eae1801b63ec217fa55284053351ee4361bf27b6c7aedbb96039cf5270c5a8d6ebc131d1cd2ff086f0ee36be2098dac3e3eee5bdf89a0390c0eb5885f59ae9d2fba2e8a0623d7e1b10350eee65e2f7f4de9112b452d9ad648596c81b0636d3652984ffa38284ffccd381350e97eae7a66c903c722b90f4ddf8e47eda79315cc4228fa4002da89247b5a87103668631aa37e7fd265ea0d0c0b8cb8c5c567f63954f715dce1e2d93cf4d94356a60bfcbd923610991f240c8dcfa2da9ea20dec67d90cf67cf24985837fbd520c62a22192fd823b53305f7382a7068d15d953b5e88a53053279c08d51343dd46ebd929fee7006c16d19efb1650b413552b8e211ee6a2d9301655ec47565b38a7d739bd476985ba230de7ffdbea0d3ba579903662ab2ee38ff5dbaf09af8273dd28a7009d1d21d13a69e30bc67a0f6eb9cce9473afbcf6d65e8579bcbab0ba46b92a193e8cf2d93dea5a17739c96eb772afa7aeea484c82c118504cd06fc86d89a74386340c1ec0349efe0d79e6365fadd6a6eb677c144fc328640f9fb2e478b8d9c3d7255a0012b17a4e655fc3451f92ba824972da630ce3a15426ae448989ac31f88244d05ed714b0ed52c69d54285c31df8170a7f42d7641a60223887bebd79de9d374cc7820fbd01c5db922a9e0cfff58929ef4a2273bf7c52e397dc07cc1326bcd8d2fbdba3254eb2ca16b6ed9ed88dbb3e33fa05af28f542061875314f3f9aa29ceb3b97fb6ea4499851c43e3b78e4382530535a29cefa96b4724404f78ef3142e7271eeb17b93567f74be4e23d4ca94c377ddfff531542df6f1e721270e16aaf0632b3e2fee98124442c730de7290529d4feacc2bc2e3d9e2ed393d20d871cab63b607a162b95f92ce7ad73c56382066e8ff3a9a9d7522eec5f47e011ecd83290aa380015af9ffb529a56fcad88b8d340d949f96cc51161ae3d1219131794b1234c9fa8dd350d15b71bf8333ff1493a1b09f1ec8d1c458a5a2ebbbabb3d8f8ef3b81826c253cde2fc001375399a33d9a16d542f89d33e874a41dc4936f4dbee8ff0d46ef10f32ac45eee81ac7efc32b82bb6ba432da7671b98231c8bbc607d8f9091a95effad9c1088e63780f5fa6b43db462029300419d93226487ca71832260778e9c89a674366cff4c5d16b957c41010a5436efb299045291c4b29ad33c1b2ee6dffbe5adb850b9c9deac1029bdebca4a04bc6cf48fb32cbaa908da93975cef230637eab827bd6c31c6eafef0dcbb1269e926cd1869dc7089ad07dcc72d9dfdde5549e5e51efde10f3b53f330060590816da964a69f67a663901854260d4e0edeaa43986150ee709a65eec1d8cecef7897d03c5f306df1b614d85bd9f8aab3c96e7ecc6e46b97599566f24b58288605bc2a55db2710f3f5a025f531d9ac8fc540d17f207bbdbdcacc4ae60d9de821a8ec229995795f65ddc4cf95ddc1021ad36c7a2fd8d5591e7e8d663daf8e146990b096bf539e32cdb0b40695b6efae564d2dfeb23567aba1c1565dc56bd56800a5c47dc792d9261aca11ac91234436900cd682b9c0d1bd6aa2eec54865500e2c9bfbaaed35bdc1d159b3f66685445e714d90af05c693fda2a86f989734282d1d48a3716ccb0c798191c82f5727fcdc4304f8c49300390cc28154e619070a5384c69a4dd0343c593cb5761a3f6a5a0d80655fc0b64762761d90ecc4e70346fe46d0137f728ab87094888ef6eab64423dd97b9dccfe1b87419ef038b741ba0c36f699e29c4880ce1416731f2d888e8e80430889539a2a471766af40afee218d3514156597747fdca734b622c6623d4097c3491adaf6f607e6160a74cc5f66ab42023d73c8a756b3b13b07578f017e0bd3aacdb21809d7e9715c4aec6938234bb57b42b80143de8cb7f6c2a4adf619c4e5bd32593bbdd75e3fc000b3d56fb339bd4996c9466cf6e0c8b8af400bca099f1b448426a940835f1aae28727e378a2ed5b920c00f4039a64f6f0002f52c5860d1eb4a3ed3f628900f3db4de1f091e8eac766b4b33b45032487c40b460cb22c88c7c3dd050b22a0d783081ed4474ad2c690138204008ec6314ba9f280ca36d32729f4ee7e5802f40ccf953f43400a288d08ce5b75f882950653712ef83d2248a09a5c38ad0ceb4b1528a34ef52a4d1c55026339a47637520dbad60d3a84243df435e876d7c59d652ca1b9ff83c2f37902b23da885933d74770bfe2814c09bbde6b5bd0103bf907b5cc85ae5bd1fde6d7f6b2b5456e6949f1982d771f374e451ec16faed5a0a458bc82de2ec6840adb565b9ec6ec2522909af69e1fa97b02a063f875b13ace5dae886fcfeb8299ff050c82f0e7db41ced32c5538eddc9fb08f7e14f81c12e53f6c88176c6b43b80bf2abe954d98d1c29d79a1f335c4384fc7dccf841c0603ce29c3e836cb6a42b74507fb8033244d28b3f389045bc7db3f27e75b115c8daab0f4b3937a783a3259ce0ef79c4c1e7d0943c67a71140a275a28b735cae74d189775a7727de233e6c690ed1e2ff24b203faa2a56b97872ab6bc9835f3d1ac271f9576ce53927c3e87b43a0c277e3e9365681ea168e9fe8574e47f5ae8f79b16e630b030256f647f118ecc135640852924ad3051708e4e9cb7fbee1a77e8f70ac40ab880f04f6c17f41e44d0d58ef8f2b83729fb289674202c686083c1e0440f9b8cf6b005ae12b91970fb3984f95845e7f64841f10c472b4e1fcf6bf9eca1103089a57a8aadc875cc9edb64dd9c1672391fea6a0300332f1458e46dfc48482700c15d5efaec12b92666f27727d1e2e1928e5948e1edec7d7dd72ab89759228f10edaf5d386f4bc0a45729cac559e03fc598ca369ff289a0b35a9eaf258bec6e0a194ad0dd70d8f349a22dddaf2685f099d37a37624c2d51989515118f6ac755e76eeccc076a8d4a1c8b27e15bcf6aa07d1493c4889a3f26e5d3e5474a005c8280e6704acb02d4fa143d86033f67c502fe17de217df9192c08122a27d76c2318b0ad305ddd247dcc05a0126d0b9b137784da737f087a2d1206e52d038a99d81aea6e00fbda7c346533e5bc6938ce3a8ec8f01d6c65c506ca9989589324ac86b4c03ba60f80a18282f7e2ea193fed4f0ed1b49c039b3d4714c75d8f847b0cfe5c733fcfc2a74d702f2c1aa20086ca04dc22a6e12461625d902e2998b57b6449579f458aff854c98356233ac0d576dfb7200806cc8e0ee106f6102f3eca2c3c37328320cfa720372299e79e28c1cd0277c76fb47f6de1f0ada4b0ad5f2a44d9e8042467f981fd5900a0794ab959c202419606464bd2c7718a961e748c8105e3a20352a10de35874283f46412590457910ddd7f463600e7b8e4b98a5d2865cc0c7e24b648aaf82d1930d5e8b00e452a8f77b28b9e0d1117874d76bb6ee102e4af383aa4c7728503e3a06e7f52a313747f54ed8b8b160ed8aa192be01a96de853857af9455ce81339b154894c8eb418b61536555facf62fbe9eea119c3edb8991ac19c555403113c58e15cb080a7f6e09200cd13631dbf2c60dc24af6b31c23ef541613977ef1e52837e0d7d2d5468ab3d4819a586ae1a160525855a52dec3013e59bf84af35c48bba3e51a842a4e255cacc7117585a9a5626d039a06a2687a6c60af1d1e161bf6192a41600c22debedc4f1eceede4245e1f3615dcb85e2f7bd32c78a5377d206917b4abf81a0802327918e195c11af866e4aab6cb4f565da916e70c2a62f6a4df34d36fd17b8a2860f8657082842d54628072f21efdafe1f2afecec792ddba6b7bbab6363b18064518dbccffb35642ae79411987fd6654727baf95823d2b6c7eac8fd5a663ea76073fd3e492b339f688969049bc896d111beeeeb23407e96d6f0b4918093eeee87804d75410dd231fdb628e30756dcdd1ff5e83c9820a59aa0d992f6d7f123f13a5e444e8d3c5e35e588041502713a268dab8d08c1c19a9cef37bf21e3003a29c615efe3c34532f58babc348a19104636a29b483c14cdabdd09254de94f8c1e3f26db1df1281aacc7f357e50385091567508d78bfbb3bbf94d8c67cd0bc192e37f5c6a73a28e626a9abcd1f09ebf49d26432d5b7e9a4e95789200053d3bc2de009a67a3375bebe48cffbb6a73779e27cf7b7203312ae41099deba309f220dc2b349912b07bf9770f4fe3957543a7174039ad26e1e57b10d3c7885268cdacf4188bc3da89bb69becf5ec3aaf6e18bfe6de9b6010681e6305efc4b69537c52c10f7cb45950ac72ee4dcdafe2258f6d892f858f1e969010d27ccaa11c3bec1a2941ebc3fe97a1fe6eb6d9715efa6ad712afb2623b20514fb6e33313ad97358db83cc5ba153e0c0170acae1d1a7149ea65840ac280dd967f030f4bc9b451173b29d10fb8862ec9bf751c8701d5ede17f31160bb0e842bbdb1f5513e98a6358f72504767a25f516eb64fb23c6dd1d65c3ea99c497301a8d5749920873d936a50c12e1b02e9cad4508513fa17e80c4cd79ca6ff7e8fd0e3e5dafd63ccf7e214f8c8c664854e47d7981dbae15c210eb9cfb57c70ab80f3990bd296a3610108b39a9cdac28299d28d74b0e7394fd4b82ff36c998682167880a0f7ab29d75f5c9d590061b454bb7019703a4b05eda00d97617648130cf1f06e5d455a3d16228d296cd0bffd073a6812877df0a1aa304538287d41cb465e1d006f07f6605e93c9156c9b5ad9b3f44799d9b76b6af5ac095e20bb9214037b38c671e17e50e63d6a045d619c378c3b06a159eb66c87ec65fe8e00946329cd2dbac07b39e549a10726e74294c60fb9fa71b9a257757952f275d3d6f42f1480409b44595516ae62485210f3e03e39172570da722ffcafec673da7bb262ae4e0521e2aeea7d876fd4bee197a5198b3b068d7675f810888616d128f6733ca9e49e8cdd57e3b464487902d02fa4fcd9522f98a7374ad3de7632fe6d94d6ca7a77a46d9c317e4baf8c0e20aeac1d6bee3c9546e1a731ad72fcadcef82e679a18f672e2c7ede0b0a0a97399dda2fd21952c3dfcb174de674aa563c2a6840b47287b8328edba8d3c73b558d0e866b42b772c79d26b77fb24e4d12f3776648d5d093e71daf898d332de84d0468564b0eaf1ca00554dddfc6f583040bc614bee01358dfbb6a3ba2a9b08e4cbe691ebf4aca078274f98d8e6fd4edc614c6979cfdb94a5023e8157bc77bc23563473aa386b93fa78f5379c70eefaacf5ba6c517f9076eb2dbd5e9199aadfce035b80aeb35b1e55c495a52eed78d46bfee5f41dbc6a94b934d6ae39756288ae29cbd5fc483f0f2dbba51d79a652b17b5b8b3c8506864ae4d45a8dde49f269bb75adf8b0777dbb20ed0dc1b399f682c4dc229abb70447a768588af1fe2feef8b53f121e8320db259c01da951d8fc23616824d99f1c458215f33d6fc9a26c7e9d6dcbea6be12657aa105bbbe4d96dd988109e16815e71f0b9426433d588fa82bf3bf81514fa2e80af835998408c33efe4dded812cf001feca28d88ac44836381816b5ef9e49286aeb7a0ed47f24904cddb54196dad3e327fb48d4d25ae92b4f20ad0968b1caedaa2159ba3396f5f5f6bb1de177297d5c2dc1ee15d63edf8a79eeaa17128e787a860984be5d1221f40dd04c2c22012b65853a338fc3bd4410574aa98eb72e3d20f78beb2d6dd731c478c236d848862fd1dd2e733a0097b7c935b08c1d2b682e149f29df9e894eff0d332e3b69ebdc1d619502db5e39726b6bceefb86dea8d8fbaa897da5578edac7d035f8def25cf536c7792d91c2b3f837f5b9ea261ea2ea681346fe030876ff04b37176215ce1d78c54e9e97b234df02757b89516bf31506ddc662c72c277005c43120f891646cba816b812f41f02eb7bf4be8e7ec16071062796fb3e97fc63789ff6e79aeef0042522c70d9562839697b33d988bf494ef89aa9fa0a61d18e748d26c62a465b744a2ce6914becb9171d74f78dc91842d2c5e32a680f9ac97c647ef0a244a19c8045e60ecb3b356e90f5e0d12cf40bf3f1db4d8782bfe08a40c8fa060f9eeb127dfedec4d707c834b4406b6b95c580eeb3913b461b792085d48b48be56df782af18e3888ac51f68f4db057e44000e13e3ac71297df52843a549027f0f2a9545249450ca3170f02f9110915c2aae494cd3c2b5035edf00ce6a94542fd0c5782d3479947d5e3ee1e2d902eec172f7505fa98ca88b3ceb6d86f724cc5d2c14c10df15d6bb6b14d9ce46e10c3e5eb12c8598cdddcb42a2507c30230a3c75c0434146f8bd6dadc40b6b647997630619e5d32380be901e9597d948f841a2501ea0835e87d9c0ca3f8d4a066762b42dbea181ad3ebfdf0e24e687be6ffe1fc87160b63477f4eedbfca85c6982e44a2e15ede7b48dff8afc917e25689f4ba91d3073e66fa8091585ec8f234a5f7490e6b671b88b3e5089333f5d310cde8ee0b56e582d50a2889d48e06822cfa479df2114a028deb90befb2138ee462ac3350f1e52d2d0a63647fcdc6ab5e2d348692649210dc9632ecf38fbe886b683f7bb50ddc7827a9a50e0d769b2787a45f559d86447a944118bc5062f947ed85c984ff3c71b9680f09713e592474f8e4cfcfe134d342d3c5021d2e7000f252133035e260e10194565e2906c6c57e234b6a7e4d349854442db0831ff9975a5c9250864cb8a39f985dc804e92ac4a08d20e9cf29070e2863309709025d153b39ba381c2c8620979bcfb82314cb68c5c392f44697d50a60c02af744f96428aaaa94a7f722b7008e2881a52cb5f09d5b84ef7941094127a2c1b75f1ae0a17333ccd1179e61449b83bc58a492814946656302f9c116e4367f3282356218ae97517493cb0a3d26268f03ea2cd52a12e8e3fbc534d73d1ddb3e9ea42caf564ef2e4f903ef94a6a4ed66d30727e01cc53646b37d2185bb73d418506a4d5fdc0fd1eab28678d24a0f025e6525fa01af28abbd988a2d68549c3d328f5a84266e12daf09bfc2ddfb05f2406fbdc0e7faaa534988b54489ffa14fa4dcf9ddad8aa8bdd64f43562bb4c630e4a2d5026e2fccd4af33341bd2bfd558e74784e9d40906e80410cc3724a42d97f736f6341e594f7c289c236bd42c9797d4b0a97c32a7c1398a41115d3ce16cb2bfda38caee230c69b78f8cb6f365ad3226526d8a092d32f52daae2aae01ea21d8089899a405b428605bccd3f1c36035d55b81b712fc9b8e493b0a30df8961b96d43c169eb9d0390c740622b21ccc319380f9ca0ff4371ce58c7302b9f52b735e578ef6cc5173a0abe1c9fa8e3b2a377c2c9c0c45a5f72389918e5294480734be8b07bb78a7045354cb95d5e2daea119b65800a7ada51b1c09c993dd1685da0edd0c5bc9e1eb473a1d3f07536087eff58a66aa4f0301fa2e4dc746528bb79bfce2b567d954d0e26e386576347c28ec247fa7e1aa994f3257a40e075a1d5a3311b75449c36debbf520f158731d863f08d2907eda00c5b07d71d340f721148dbba8229b775f76c07c69b827186ce963d5876f6c876812bfebbe214fb7bde794a9c438ea36a2f1086af04e68aab1c3d2a413a400ac20a5db2bc053ab9e74d86bc0174b7100f196090b21a4362e6ad6d915f05f7b4729bb102958248ccd90921a78e039733bd11cd4e305c3197b7519d1853e3bb58b2f690252c7a8bd5920617105fc50c4562543494d71bff5232182840a21cc2cc591bb442a6b845f59850b9089b2eaaded30ec4287bf61a6d337eba74fd1499ee80af36842143adea031a10b2b524a8500a5eb01b925ca27c3c71d690729a27bdfca121a7d4d625900ad6b68eae52e9e23d210c4bde6914e8a423fe852fc569298f15981bd0e48df37fec70971b23a2a060a7320a854edc51da9551934746be5ebcfc29b4e35a8221879776bb2070bc8d24dcd69660842b961fa58f73c43b12aad1bf3ac1f8a2046a412dad72879928215acf6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>杂草</title>
    <url>/2025/06/22/%E6%9C%AA%E5%AE%8C%E6%88%90-%E6%9D%82%E8%8D%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="32680ddb89cdf0ed6f58a901105ae703ecff2a5238aef29bebe46b7f23c1a24a">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e71fed42b0df9ed23ad4b33b2802bcc4e404509a46e3710100332b3a5ee7d0f057487782eec9c5e4497ebd0300c3ad714336ff2034072c862adc48bfa7250841ab9f0be7aceaa01fe78d79802ea3d4e7aa48cbbe9550dc944d005b14f5fdeda3426e294a5a32ee433794b5f64bfc8eef133178186a8ff20afe67f3302eaba3fa5f618dbcff8a1b49be501385c2d308d375339c46ae091fff1f7fb083eb0fc7fc18d5d98d400110cc17af9f1bc9bd46f4137cdf0f455b78e929fe163ac9baa7d9801ad55604c9539628e6294f0c68c08b1b90cce02d1b9636acf461345555b7bd17d821d440db709e1397c7c889eb44dc4a9793aaa1828faadd6cf72f81fab1b09606114ec8e53b1f9f0c03187727cef03f5b97c71d9b0c1d575de7880dd768ec5c5caee4d14328b365883493142298967e1189dcb06cc9d2fe88ac39b2e6a083640efd4e2b91efdb7265cd0d361864c77f7249430f56178e3259afcb463dae5f1857610a13eb911ad3c111b4f0dba0473e51159322dfdc5d0f95acfcbad3bebd9806a5e829dcf2d66d403ac3640c3431d24186c3185b7df7c039eafe85bc6acf79bfc8cfd5f26d637f1cce9cecaf9f903d4f1b48cfcf65917157fb06368d6084a91bee3cb330beadbaab0431af59b6f5a340d8d3f1b285e22ee8b480d34ef4e545c1f1dc473c329051c5317b289e425542610824934565ac0f5c7f795ace79c7dccfd54f7a12a866ccdee36825bf9125bcb3bb1f668d73daaf28fe117f8a57d5be530f6f2f22a9ace5ff2c401fc922180ec3e48effd8113df9f5d2f910afea9a792fa5a9607efb9f5b98559a132b823a2c21d7294a397aaf9dae228927a48b971fb3d1183983a80d758f5975d9bc7158c19ee73051233e3d682f43986d8a2c514eccadfd310ba4dc6577a31226c4d4f5f0d043c171c74f792255359ed76eefda60163e9a607e0c0d8c8987f1fd78b91bab7743cfed5b2a957f7babead6cf38328b2238c17b988eecaec121f78acf0f0f0ac3b73fa3cb24c44d3f1e536851b318b5d894a3c528e8d253db9f0ff45b4e9aebcba0149e3aba22b66aad05ad11ba5988e2da5b8d21319cfd1255675df4656d20f4cd1c3c9bf287d93dc1714a53a2f326027fedacd1bbfcdde78d8aea8df78a80f95929055c2b0276946dca973cdfeaee688118761154b99a25a4a4b329dd553a79ddac7d814cc3d9fc36d686bfb0940a8ebdeedb06efbceceb28e79ec6e807ac5f88854d9b1f5e9ab7b55b650945c03e25eecd93376ea384c5a6a0815e74bda63cbb5f96f1b787e9bd608b9047a845ac2e9ffd7582222c57fc4b42babc087bed40bf0531b0719dc61edc8ac525a373b7737df477908717ca3e8728016841aa1e58e949dd3e389a9237d81ad3cae34cd4da42d8ca2cdb44e10a871e2607e80d3faad753fdb0c7babb850600ca59b03df68d6d7c48cbe744697c0e6083e062c8774c405461b82b78205e4c8eb25e4399da384bad678130513cb3764fc3c0de03495213a6120c44cc78c5af5e156697d964cd2497d708eb1ddf7edc215c1e6d8f00eb57ceae1637f94992250ece6d8469017111458bebc94d8f500c14452d0056c5a4cc7999352871a0893de672699f458e8fe96a7e896a98a6ec7f8403be9e969deb38164a170efedcb9e59c867e9aab1c72646bf21d4a6e6888c266777e3dc2d5d229f1bd75d3b333179a0250445aaeedf88aad38f258a6749d234a63dc1bc1d2fea595ca77eec30bfa05d65369e65e101648ac09f2290fa2808616f1cb1e246c72a5359c8bdbb417fffc9d69e53f932346df86824f16f7c8d08e0df1bf4efaea2a04558b9c902dc9d8d7537d19f645f0d0dfd5e1160bd404cd5224e8667502ccb5ea397ce5b8a9bb3a5da670f511f45e41da589426c760216591eddc423626df9442902dab28c691e107cd2ec8f21e4d24574054f601502611a28313bf53de3d39cfdfc938bfbfb4a3ba27bf421ce2fee948a7fc697c0dead4b5ddd99461b63e0b08bbe2d43b2613f55aad05b335b2b6a023d0f0f3d9a2898695f1981b3165d9627730e2220936bd606c49a0bea42a5747ad17592436e2d778d6c812450858203604ac5001023adf5bfece737ec23c898300eefdbc42f6a6cb62d466eb45f55c6c52bf702d4a82e68d7e1361864f5011988a5f2c281b1447f31e76faf62b9c0feeea8bf7ae073e9d3093725f62d9a1108c632d502d759382f4205e46e37f872cc4e99f0279823741544163e49ddd49ed8ef171f101e1b40aa13543cb1fc94794336b1b8a83c77baaf411d5e4b292aa45c65038500081a3d35910e0f823c1c3c2c4e5ac8329edb58f6a6063dc602fcca05bbd3b7bf47a24050e7132fe22ae5b6f66959aaac47d18e8fcc3c813b61f3cf088f1a1a9bcec0a1fd90616071eff222406cb450767f0320761268a3518614c013dcc0abfc99e63a50355f796840cb1bf7af7a614fa33064ebcba8ff74caa0ab0713dd01f126a17fbf5f4df3be05087679e93cfe4f125a79156461a3cc101c2e641b12f3dce755fe96ee96a03bcfccff845359c2d02ee0cc6a65c277545f482d83fa41293e47495e80dc873fed5ff0b67fe23afb0ece6924daa6ab783d53b4c970b64e5a13e60a38e903b51dde4a9bbd95ee1703b30004b888b0032568a07fee01ceb41256f669f2e6f3688b565bb4af1dbf25d703fd076488eb7b18c63557c1e0ddfaebbf850ad3f4fd823954edbe1ac4a92dd0d09127049fba1cc121f6c28b4c49e4dafe92d53a4e5b26ae8418421e192b18b9fba96a7d0075e2f075ed1c462dd5922dbf7fe86eba3907af7da5c6874a4abf9f43458896d598f14dd6abfd6636fae0d68b45fbaeecd016b8c6c316ce18da45cdc727699097c6188326c3a453f204616d792b5a51e11b2bd7e204cb64738d7140c687ff7fae5c4b026909f270ca72ad6143abd84130d85ee1246b0ae5a15ae733440025cde8673fb38d06fedf6aa54e02c4d4841d342a2f1a99bb53972b8ccd3e87ddaf3c2be5781f011cf9aa71966394fa1cbeef8d19081bd65ed2c098cc3da7487d86dba46ecb48b1a3a0247dd04fc847356dc265dbbfbff47dac13b870decbf60158b7d7ffb53b6d70737c0013b1bf3d2143d18a21de4a13883efd4f439f1204b290088edc9c3cca8061b351140e7330abc5715e65f4d6d1a0eed5a8027e56391fe79fb9d808cf6277f676befb84f80a98fb0663ef35e83e30bd6a01d193e3c488a7195cf21f2a635592e8fbfb2e7742e8473d6cf040eafdccf38fa04977cfc195f441ab4f26eef3a82245f7afba268614f8817fc20426a5394848a9e214ae34ae7fa6b6bae9f0500d927e5ff41e0f10fa0546d2fa293f4e7c5382da430d0a41129dfaaac29d6fd57c00d5b98311e109a63193d6a369773feeac8db09cbc95b0cdfc2dda6ee24981713085986bef72c6c9a5b6b557624bfc0d87c8598f286d42f37766e8568d1661019f9cfe43df5777064658c553b08676a64de474250682b8bc9d8112e84c8b00e574d813f05260f1b66d01dc08a9bffd80a6b5a8a1149ccdfea1b2e98d071f35dcce4bf8936ad7f9827d43fc7e9d9133ac3b5a8fdcf2020c36253904bf785cf84e6d38175a15def3e6f622dd4d315406a5523fbe6add3ad1eefd3a099d47dea31c196902e1e1979e95a5a82187d1f5ba2addb5e82bb18fe90b60bfdc8340b8416fbcc5f621fdeeddcf65bba60c70abdb8e08f21e16ced7d7961fcd04604ec57f55cadbd80b0af17885772de85d88cba380cfb28bfc443af490a35763a5c7fbfebcb5e1a6e05bf506a6ae8547d6b9d76e0b078b172fc96d889107a0ae4c6e5c644be86a0ef7f987c873ecf477a2a7ff9a576e4b8927d39da357841708dcaf883c1e80e373414d6dea54d2fa840b04cbcde49e42792d24877d7181e6a60a5594596cebcd4e21bc8238937c6cbe8306ae3c735fdc233d6894409109b064efdd4b52cf6a772c607a9af95e25f57eb63f4d198679b0d55b465bdf68782d55aa0f30953e1a6cb2095c1bd86b9399ee68f6b16a4df29718c8a72e9192d0cae4a74583a5e5858d30c8f4119ee9531f397e8b3c174520270d648fa2594282be4f3fc084d98704198834d075912db0172a8f836c3f56eb34e4ea7e6daadfc26de1dbc2036fff9100bd0fbb8198ba7c39e33feb1755efec4f395644a1c1d444733f3ae7518d0e2a34ad39aa04bd1d79ca5956edf0f4cd077b9105933611cdb448d96d91c4775c4a659aaa0798c3e623611196b47e7130800be08d86a6495bd555a385ab9a5d70517fb12e19620a5b0d1a10f9bc4096ca7844169da1f495a911fc5c5bdb7e5e4f40f955ed2379f09bb96f399f61505764869baaeafd72a3a7ab37f5e948be86307f51d257d20a01f02e6bd32f6c7c6ebee489dafa3129c02557bca2ca4120dba4d651c55acc85a71e24db72f99e274c501529717e1584a4037fbb420cda042e7c07b1cc81546580736850ca8d6b97238139a6c1f7c0f2aa5d569d95bbf290d6baf0274d4bbb6197c9b63c9119796e8b8717f6698148b24d17eec163fa54282ae295f631aad9b6570a1fb63983ca7fdfedfd3aa697648059b65326318f8841fdad1fdfb5248a20262587f525c1588b36075ec5461fde3f40f39868b2e65e58fc9d3a8d99611ba3ad844a0b524a26b5fc4fdbe0de80558a473c0688e40947c85831b362070afc921990f9e9182c63a2e058f14ef68b45637bd04d4d142c3a40b26e964b612a919210ee093ff324b7f8d76008545b6688282299e54834cdd7221d7ce1c743e4bb4c26ec9282e6d2ed791776aef7333e1e54e74253eac59a43f4638ba80090044404a164063fd336d8fdbccbc01afd9f848c163eba339c5fcaa5b4ad951978903d5ababd4230645194449fb57e628231920584c1f840750dbcfc3ca8842ac3b58eeac77a39ab164ad13c61a585802fdc2016748c42a9cc1ce155c06193c879c44df008f420f6da5174727f333430796afa06bc5402a19e796de9ff9022d1ea339632398dbf300cf0bd6a2d473f85275fe1203781bbb2f2cad4a8a86721be42f1c3fa8916924518a4c72c8b77aeb9a583fd4ffc207b1058bb2b09e1407a6b4c59660baf137d4740de4bc9da8db5ffc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>被轮子创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%BD%AE%E5%AD%90%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>2024的烟台一模数学压轴题是一道新定义题,是说证明<a href="https://baike.baidu.com/item/%E6%91%86%E7%BA%BF/5893005">摆线</a>上一点$M
( x _0 , y _0 ) <span class="math inline">\(的切线的倾斜角为\)</span><span class="math inline">\(,求证\)</span> { y _0 } = 1 <span class="math inline">\(.在这个题下选用的参数方程是\)</span>x = t - t , y
= 1 - t $.</p>
<p>这个怎么做呢?我的文化课同学们纷纷使用强大的隐函数求导技巧把它杀穿了啊.可惜我不会隐函数求导,我只会链式法则.但是我考场只记得链式法则怎么用了而完全忘记了这个东西为啥是对的,所以就有了这篇复健博客.</p>
<p>首先来复习一下微分$ y $的定义啊,下面这段抄自我原本的高数笔记:</p>
<p>考察$y = f ( x _0 + x ) - f ( x _0 ) <span class="math inline">\(,不妨假设\)</span>f ( x ) <span class="math inline">\(在\)</span>x <em>0 <span class="math inline">\(处导数存在,自然有\)</span></em>{ x } { x } = f ’ (
x _0 ) \ <span class="math inline">\(.考察\)</span>( x ) = { x } - f ’ (
x _0 ) <span class="math inline">\(,显然\)</span>x <span class="math inline">\(时\)</span>( x ) $是一个无穷小量.</p>
<p>那么,我们自然有:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta y &amp; = f &#39; ( x _0 ) \Delta x + \eta ( \Delta x ) \Delta x
\\
&amp; = f &#39; ( x _0 ) \Delta x + o ( \Delta x ) , \Delta x
\rightarrow 0
\end{aligned}
\]</span></p>
<p>同时,如果我们有这个式子,可以两边同时除以$x $以证明可导.</p>
<p>这就将一阶导数转化成了无穷小量的形式,我们借此给出微分的定义:</p>
<p>设$y = f ( x ) <span class="math inline">\(在\)</span>x _0 <span class="math inline">\(处有定义,假设有一个常数\)</span>A <span class="math inline">\(使得\)</span>f ( x _0 + x ) - f ( x _0 ) = A x + o
( x ) , x <span class="math inline">\(,称\)</span>f ( x ) <span class="math inline">\(在\)</span>x _0 <span class="math inline">\(处**可微**,并把\)</span> f = y = A x <span class="math inline">\(称为\)</span>f ( x ) <span class="math inline">\(在\)</span>x _0 <span class="math inline">\(处的**微分**,由于后半部分是一个更高阶的无穷小量,我们说微分是函数改变量的线性主要部分.这个时候结合导数极限的定义,就可以得到\)</span>
y = f ’ ( x ) x <span class="math inline">\(,\)</span>f ’ ( x ) = { x }
\ $.这就是我们将导数称作<strong>微商</strong>的原因.</p>
<p>一阶微分具有<strong>形式不变性</strong>.换言之就是,我们在求导的时候是需要选定一个自变量的,当选定的自变量是$y
<span class="math inline">\(的时候,根据上面自然会有\)</span>z = g ( y )
, z = g ’ ( y ) y $.</p>
<p>但是当选定的自变量不是$y <span class="math inline">\(的时候,上面的形式是同样成立的.我们下面证明这个结论,令\)</span>y
= f ( x ) $:</p>
$$
<span class="math display">\[\begin{aligned}
[ g ( f ( x ) ) ] &#39; &amp; = g &#39; ( f ( x ) ) f &#39; ( x ) \\
\text { d  } z &amp; = g &#39; ( f ( x ) ) f &#39; ( x ) \text { d  } x
\\
\text { d  } z &amp; = g &#39; ( y ) \text { d  } y \\

\end{aligned}\]</span>
<p>$$</p>
<p>必须提出高阶微分不存在形式不变性,换句话说,$z = g ( y ) <span class="math inline">\(的二阶微分的形式不等价于\)</span>z = g ( y = f ( x
) ) $的二阶微分,你不能乱换元.</p>
<p>根据上面的操作,我们很自然引出了链式法则,也就是:</p>
<p><span class="math display">\[
\frac { \text { d  } y  } { \text { d  } x  } = \frac { \text { d  }
y  } { \text { d  } t  } \frac { \text { d  } t  } { \text { d  } x  } =
\frac { \text { d  } y  } { \text { d  } t  } \frac { 1  } { \frac {
\text { d  } x  } { \text { d  } t  }  }
\]</span></p>
<p>这样上面的题就可以迎刃而解了.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被豌豆创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%B1%8C%E8%B1%86%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>在YT2S 2021级生2课上有一个著名的open
problem,也就是在计算自由交配的时候能否拆开考虑,下面我来尝试写一点自己的理解.</p>
<p>首先来看两个问题(前置条件均为孟德尔第二次杂交实验):</p>
<ol type="1">
<li><p>将F2中双显性植株自由交配,求后代表现型及比例.</p></li>
<li><p>将F2中单显性植株(包括两种单显性植株)自由交配,求后代表现型及比例.</p></li>
</ol>
<p>为了方便笔者书写,不妨设这两对基因是$A / a <span class="math inline">\(和\)</span>B / b $.</p>
<p>先来看第一个问题,双显性植株中应该有:$ { 9 } AABB , { 9 } AABb , { 9 }
AaBB , { 9 } AaBb <span class="math inline">\(.先让第一组基因自由交配,也就是只看\)</span>A / a
<span class="math inline">\(,我们有\)</span> { 3 } AA <span class="math inline">\(和\)</span> { 3 } Aa <span class="math inline">\(,产生\)</span> { 3 } A <span class="math inline">\(和\)</span> { 3 } a <span class="math inline">\(配子,得到\)</span>AA : Aa : aa = 4 : 4 : 1 <span class="math inline">\(,也就是\)</span>A _ : aa = 8 : 1 <span class="math inline">\(.对另一对也这么考虑,最终得到\)</span>A _ B _ : A _
bb : aaB _ : aabb = 64 : 8 : 8 : 1 $.</p>
<p>非常合理且简洁对吧,但如果你同样拆开考虑第二个问题,会发现这么做是错误的.</p>
<p>我们生物老师LL老师给出的解释是,单显性植株的个体是$A _ bb <span class="math inline">\(和\)</span>aaB _ <span class="math inline">\(,它们的基因型并没有组合的非常彻底,也就是并没有出现\)</span>aabb
<span class="math inline">\(和\)</span>A _ B _ $个体,导致不能乱拆开.</p>
<p>而直觉上感觉这个东西和独立性有关对吧,我们来简单证明一下:</p>
<p>约定$X <span class="math inline">\(是\)</span>AA , Aa <span class="math inline">\(或\)</span>aa <span class="math inline">\(,\)</span>Y <span class="math inline">\(则是\)</span>BB , Bb , bb <span class="math inline">\(,那么:\)</span>P ( XY ) = P ( Y | X ) P ( X )
<span class="math inline">\(.如果可以拆开,那么\)</span>P ( XY ) = P ( X
) P ( Y ) <span class="math inline">\(,于是有:\)</span>P ( Y | X ) = P (
Y ) $,也就是这两种基因型互相独立就行,老师说的对啊!</p>
<p>如果只是这样就水了一篇博客非常无聊对吧,能不能证明一点更好玩的结论呢?</p>
<p>考虑设产生四种配子$AB , Ab , aB , ab <span class="math inline">\(的概率分别是\)</span>x , y , z , w <span class="math inline">\(,其中\)</span>x + y + z + w = 1 $.</p>
<p>使用生成函数技巧,配子法给出的答案应该是:$( x  AB + y  Ab + z  aB + w
 ab ) ^2 <span class="math inline">\(,而拆分再乘起来的答案应该是\)</span>( ( x + y ) A
+ ( z + w ) a ) ^2 ( ( x + z ) B + ( y + w ) b ) ^2 <span class="math inline">\(,其中\)</span>A , B , a , b $均为形式幂.</p>
<p>如果两边相等,有:</p>
$$
<span class="math display">\[\begin{aligned}
( x \ AB + y \ Ab + z \ aB + w \ ab ) ^2 &amp; = ( ( x + y ) A + ( z + w
) a ) ^2 ( ( x + z ) B + ( y + w ) b ) ^2 \\
( x + y + z + w ) ( x \ AB + y \ Ab + z \ aB + w \ ab ) &amp; = ( ( x +
y ) A + ( z + w ) a ) ( ( x + z ) B + ( y + w ) b ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边展开,就可以知道它的充分必要条件是$P ( ab ) = P ( a ) P ( b )
<span class="math inline">\(,也就是产生\)</span>a <span class="math inline">\(和\)</span>b $的配子概率是独立的.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被蝴蝶创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%9D%B4%E8%9D%B6%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>事情是这样的,很久很久很久以前,我做了一个圆锥曲线压轴题,大概就是椭圆$x
$轴上蝴蝶定理硬算题给我整傻眼了.今天我闲的没事乱想突然意识到椭圆可以仿射变换到圆来解决,那么圆肯定有很优美的做法了吧!</p>
<p>然而我瞪了半天也没看出来,没办法最后拿联消判韦把圆的结论搓出来了.</p>
<p>这个时候我又想看看其它的圆锥曲线,发现双曲线好像有点不太会,因为我不是很懂双曲线的内部是啥,然后我发现抛物线的蝴蝶定理更加优美.</p>
<p>所以我就把这一坨东西出了思考题,下面是整理.</p>
<h3><span id="约定">约定</span></h3>
<p>下文称$A , B , C <span class="math inline">\(三点满足蝴蝶定理,当且仅当A,B,C三点都在圆锥曲线内部,并且过A的直线与圆锥曲线交于\)</span>P
, Q <span class="math inline">\(两点,\)</span>PB , QB <span class="math inline">\(分别与圆锥曲线交于\)</span>P ’ , Q ’ <span class="math inline">\(两点,而且\)</span>P ’ Q ’ <span class="math inline">\(恒过\)</span>C $点.</p>
<h3><span id="抛物线">抛物线</span></h3>
<h4><span id="定理1">定理1</span></h4>
<p>对于任何一条抛物线$y ^2 = 2 px <span class="math inline">\(以及与其内部一点\)</span>A ( a , 0 ) <span class="math inline">\(,过\)</span>A <span class="math inline">\(点与抛物线相交的两个点的横坐标之积等于\)</span>a
^2 $.</p>
<p>证明:联立即可.</p>
<h4><span id="定理2">定理2</span></h4>
<p>对于任何一条抛物线$y ^2 = 2 px <span class="math inline">\(以及其内部的三点\)</span>A ( a , 0 ) , B ( b , 0 )
, C ( c , 0 ) <span class="math inline">\(,三点满足蝴蝶定理当且仅当\)</span>b ^2 = ac $.</p>
<p>证明:由定理1,我们有:</p>
<p>x_Qx_{Q’}=b<sup>2\x_{P’}x_{Q’}=c</sup>2\end{cases}</p>
<p>简单解一下就可以.</p>
<h4><span id="定理3">定理3</span></h4>
<p>对于任何一条抛物线$y ^2 = 2 px <span class="math inline">\(以及其内部的两点\)</span>A ( x _a , y _a ) , B ( x
_b , y _b ) <span class="math inline">\(,要么存在一个点\)</span>C <span class="math inline">\(使得\)</span>A , B , C <span class="math inline">\(三点满足蝴蝶定理,要么\)</span>P ’ Q ’
$的斜率恒定.</p>
<p>证明:</p>
<h5><span id="引理">引理</span></h5>
<p>如果一条动直线$Ax + By + C = 0 <span class="math inline">\(中,\)</span>A , B , C <span class="math inline">\(满足一次方程\)</span>pA + qB + C = 0 <span class="math inline">\(,那么这条直线肯定过定点\)</span>( p , q ) $.</p>
<p>而如果可以找到一个参数$t <span class="math inline">\(,使得可以做到将\)</span>A , B , C <span class="math inline">\(分别表示为\)</span>f ( t ) , g ( t ) , h ( t )
<span class="math inline">\(的形式,其中\)</span>f , g , h <span class="math inline">\(都是关于\)</span>t
$的一次函数或常函数,那么这条直线要么过定点,要么斜率恒定.</p>
<p>对于$P ’ Q ’ <span class="math inline">\(这条直线,这个\)</span>t
<span class="math inline">\(相当好找,可以是\)</span>k _{ PQ } <span class="math inline">\(,可以是\)</span>y _P y _Q <span class="math inline">\(,可以是\)</span>y _P + y _Q
$,然后带入简单检验一下即可.</p>
<h3><span id="圆">圆</span></h3>
<h4><span id="定理坎迪定理">定理(坎迪定理)</span></h4>
<h5><span id="特例">特例</span></h5>
<p>对于任何一个圆$x ^2 + y ^2 = r ^2 <span class="math inline">\(以及其内部三点\)</span>A ( a , 0 ) , B ( b , 0 ) ,
C ( c , 0 ) <span class="math inline">\(,若三点满足蝴蝶定理,当且仅当\)</span>( a + c ) ( b
^2 + r ^2 ) = 2 b ( ac + r ^2 ) $.</p>
<h5><span id="通解">通解</span></h5>
<p>对于任何一个圆,我们有下图(图源自百度百科)</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ah1ipl9o.png"></p>
<p>那么$ { GP } - { HP } = { AP } - { BP } $.</p>
<p><del>该定理的几何/代数证明好像都略麻烦,笔者决定开摆</del></p>
<p><span class="citation" data-cites="Querainy">@Querainy</span>
牛逼,下面给出他提供的曲线系<a href="https://www.luogu.com.cn/blog/uakioi/qu-xian-xi">证明</a>:</p>
<p>我们尝试把这个做法拓展到坎迪定理上.</p>
<p>照葫芦画瓢,设圆心为$( x _0 , y _0 ) <span class="math inline">\(,得到\)</span>( CE , DF ) : ( 1 + k _1 k _2 ) x ^2
- 2 x _0 x + x _0 ^2 + y _0 ^2 - r ^2 = 0 $.</p>
<p>此时,$| AB | = <span class="math inline">\(,\)</span>| AP | = | AB |
- x _0 , | BP | = | AB | + x _0 <span class="math inline">\(,\)</span> {
AP } - { BP } = { r ^2 - y _0 ^2 - x _0 ^2 } $.</p>
<p>而$ { GP } - { HP } = - { y _1 y _2 } = { r ^2 - y _0 ^2 - x _0 ^2 }
$.</p>
<p>笔者后来思考了一下为什么这个是二次曲线系啊.</p>
<p>我们考虑求过四个定点的二次曲线系,不妨假设这些二次曲线均为$Ax ^2 + By
^2 + Cxy + Dx + Ey + F = 0 $\</p>
<p>带入四个定点坐标,就可以得到关于$( A , B , C , D , E , F )
$的四个方程.不妨先假设这四个方程线性无关.那么就有两个自由元,那么方程的任何一个解,就可以表示为两组线性无关的特解的线性组合.</p>
<p>注意到两个二次曲线线性相关,当且仅当它们是同一条曲线,这就证明了二次曲线系的正确性!</p>
<p>那么怎么证明这四个方程线性无关呢,不太会啊,这次真摆了.</p>
<h3><span id="椭圆">椭圆</span></h3>
<h4><span id="定理1">定理1</span></h4>
<p>对于任何一个椭圆$ { r ^2 } + { d ^2 } = 1 ( r &gt; d ) <span class="math inline">\(以及其内部三点\)</span>A ( a , 0 ) , B ( b , 0 ) ,
C ( c , 0 ) <span class="math inline">\(,若三点满足蝴蝶定理,当且仅当\)</span>( a + c ) ( b
^2 + r ^2 ) = 2 b ( ac + r ^2 ) $.</p>
<p>证明:</p>
<p>注意到圆的坎迪定理的特例,然后发现我们如果将椭圆的纵轴拉长使其成为一个圆,换言之就是对椭圆进行仿射变换,那么$A
, B , C $三点坐标不变并且仍然满足蝴蝶定理.</p>
<h3><span id="其它">其它</span></h3>
<p>众所周知,极点极线有一个经典内切四边形结论,其实也就是所谓的完全四边形啊.</p>
<p>给张图,</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9uzi7mgg.png"></p>
<p>其中$G , D , H , A $成调和点列.</p>
<p>我们冷静一下,注意到$( AF , AE ) <span class="math inline">\(就是一个二次曲线,而且\)</span>F , C , B , E
$是二次曲线上四个点,所以这个还可以用曲线系方程来证明这四个点成调和点列,非常有实力.</p>
<p>当然,为了应对文化课,我们有更加简单的证明完全四边形调和点列的做法:</p>
<p>不妨设$d = { EF } <span class="math inline">\(,令\)</span> = , =
<span class="math inline">\(,则\)</span> = _1 + _1 d = _2 d + _2 <span class="math inline">\(,对比系数得到两个方程,再加上\)</span>_1 + _1 = 1 ,
_2 + _2 = 1 $,立刻解出结论.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被炮弹创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E7%82%AE%E5%BC%B9%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>高中物理的时候有这么一个题,然后今天刚好信物讲到了,顺手来总结一下.</p>
<p>先来个简单版本:我从一个点打炮弹,目标与我的距离为$x <span class="math inline">\(,且目标比我高\)</span>h
$,问以什么样的角度打出炮弹能使得击中目标并且初速度最小.</p>
<p>我们当然会第一反应认为这是一个很简单的问题,考虑$t = { v _0 }
$,因为我们很容易写出方程:</p>
<p><span class="math display">\[
\begin{aligned}
x \frac { \sin \theta  } { \cos \theta  } - \frac { gx ^2  } { 2 v _0 ^2
\cos ^2 \theta  } &amp; = h \\
\frac { 1  } { v _0 ^2  } &amp; = \frac { 1  } { gx ^2  } ( x \sin ( 2
\theta ) - h \cos ( 2 \theta ) - h ) \\
\frac { 1  } { v _0 ^2  } &amp; = \frac { 1  } { gx ^2  } ( \sqrt { x ^2
+ h ^2  } \sin ( 2 \theta - \varphi ) - h ) , \varphi &amp; = \arctan (
\frac { h  } { x  } )
\end{aligned}
\]</span></p>
<p>只需要对后面那个东西用辅助角公式就可以了对吧,非常简单啊!</p>
<p>然而,我们稍微改下题面:</p>
<p>我从一个高度为$h <span class="math inline">\(的点打炮弹,初速度确定为\)</span>v _0
$,问以什么样的角度打炮弹能打得最远.</p>
<p>这有啥区别啊,只需要改个正负号就行了是吧,让我们看看:</p>
<p><span class="math display">\[
\frac { 1  } { v _0 ^2  } = \frac { 1  } { gx ^2  } ( x \sin ( 2 \theta
) + h \cos ( 2 \theta ) + h )
\]</span></p>
<p>这下发现问题了,这个$x $根本拿不出来啊.</p>
<p>重新按部就班,发现只能用求根公式得到$x
$的表达式,更进一步地,我们有:</p>
<p><span class="math display">\[
x = \frac { v _0 \cos \theta ( v _0 \sin \theta + \sqrt { v _0 ^2 \sin
^2 \theta + 2 gh  } )  } { g  }
\]</span></p>
<p>怎么办呢?yth老师给出了一个想法是使用柯西不等式,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = \frac { v _0 \cos \theta ( v _0 \sin \theta + \sqrt { v _0 ^2
\sin ^2 \theta + 2 gh  } )  } { g  } \\
&amp; = \frac { v _0 \sin \theta v _0 \cos \theta + v _0 \cos \theta
\sqrt { v _0 ^2 \sin ^2 \theta + 2 gh  }  } { g  } \\
&amp; \leq \frac { 1  } { g  } ( v _0 \sqrt { v _0 ^2 + 2 gh  } )
\end{aligned}
\]</span></p>
<p>当且仅当$v _0 ^2 ^2 = v _0 , { ^2 } = { v _0 ^2 } + 1
$的时候取等.</p>
<p>还有一种策略是考虑对隐函数求导然后令$ { } = 0 <span class="math inline">\(,这样得到情况会和我们一开始的初始问题得到的答案相等,也就是当\)</span>(
2 ) = - { h } <span class="math inline">\(的时候\)</span>x
$会取极限.这也很好理解,因为我们如果当前的速度没有用到极限打到最远,总能调整使得得到一个更小的速度打到当前的距离,因此距离还有提高的空间.</p>
<p>有没有更聪明一点的办法呢?</p>
<p>我们注意到初速度是定值,根据机械能守恒定律,末速度的大小一定是个定值,我们考虑:</p>
<p><span class="math display">\[
\vec { v  } = \vec { v  } _0 + \Delta \vec { v  }
\]</span></p>
<p>通过机械能守恒定律可以算出$| | = $.</p>
<p>注意到$ <span class="math inline">\(和\)</span> _0 <span class="math inline">\(的水平方向分速度是相同的.然后有一个天才的想法是,考虑上述那个向量式的三角形法则,设那个三角形的面积为\)</span>S
<span class="math inline">\(,注意到\)</span> = gt <span class="math inline">\(,而\)</span>x = v _0 t = { g } { g } <span class="math inline">\(,也就是面积最大的时候应该是\)</span> _0 <span class="math inline">\(和\)</span> <span class="math inline">\(夹角为\)</span> { 2 } $的时候.</p>
<p>直接从形式上来看:</p>
<p><span class="math display">\[
\frac { v _0 \sin \theta v _0 \cos \theta + v _0 \cos \theta \sqrt { v
_0 ^2 \sin ^2 \theta + 2 gh  }  } { g  }
\]</span></p>
<p>我们知道正交分解的时候从结果上来说可以作分方向的动能定理,因此初速度是$(
v _0 , v _0 ) <span class="math inline">\(,末速度是\)</span>( v _0 , - )
) <span class="math inline">\(,因此\)</span>x = { g } $.</p>
<p>这个想法过于震惊了,以至于我在之后多次回忆起这个题,想去找到初速度与末速度叉积的物理意义.但直到如今我也没有完全理解这个做法.</p>
<p>写到这发现没活整了,顺便在这写一下另一个斜抛题:</p>
<p>抛射质量为$m <span class="math inline">\(的小球,抛射倾角为\)</span><span class="math inline">\(,初速度大小为\)</span>v _0 <span class="math inline">\(,所受空气阻力\)</span> <span class="math inline">\(与速度\)</span> <span class="math inline">\(的关系为\)</span> = - k <span class="math inline">\(,其中\)</span>k
$为固定系数,求小球在空气中运行的轨迹曲线.</p>
<p>考虑$ { t } = = { m } = { m } ( - k + m ) $.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
\text { d  } \vec { v  } &amp; = \frac { 1  } { m  } ( - k \vec { v  } +
m \vec { g  } ) \text { d  } t \\
\int _{ \vec { v  } _0  } ^{ \vec { v  }  } \text { d  } \vec { v  }
&amp; = \int _{ 0  } ^t \frac { 1  } { m  } ( - k \vec { v  } + m \vec {
g  } ) \text { d  } t \\
\vec { v  } &amp; = \frac { - k \vec { x  }  } { m  } + \vec { g  } t +
\vec { v  } _0 \\
\begin{cases}
\frac { \text { d  } x  } { \text { d  } t  } = \frac { - kx  } { m  } +
v _0 \cos \theta \\
\frac { \text { d  } y  } { \text { d  } t  } = \frac { - ky  } { m  } +
v _0 \sin \theta + gt
\end{cases}
\end{aligned}
\]</span></p>
<p>对于第一个式子,令$w = { m } + v _0 $我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { - m  } { k  } \frac { \text { d  } w  } { \text { d  } t  }
&amp; = w \\
\frac { - m  } { k  } \int _{ v _0 \cos \theta  } ^{ w  } \frac { \text
{ d  } w  } { w  } &amp; = \int _{ 0  } ^t \text { d  } t \\
\ln ( \frac { \frac { - kx  } { m  } + v _0 \cos \theta  } { v _0 \cos
\theta  } ) &amp; = \frac { - k  } { m  } t \\
\frac { - kx  } { mv _0 \cos \theta  } + 1 &amp; = e ^{ \frac { - k  } {
m  } t  } \\
x &amp; = \frac { mv _0 \cos \theta  } { k  } ( 1 - e ^{ - \frac { k  }
{ m  } t  } )
\end{aligned}
\]</span></p>
<p>同理解出$y = { k } ( ( v _0 + { k } ) ( 1 - e ^{ - { m } t } ) - gt )
$.</p>
综上参数方程是:$
<span class="math display">\[\begin{cases}x = \frac { mv _0 \cos
\theta  } { k  } ( 1 - e ^{ - \frac { k  } { m  } t  } ) \\ y = \frac {
m  } { k  } ( ( v _0 \sin \theta + \frac { mg  } { k  } ) ( 1 - e ^{ -
\frac { k  } { m  } t  } ) - gt ) \end{cases}\]</span>
<p>$.</p>
<p>轨迹方程是:$y = ( v _0 + { k } ) { v _0 } + { k } ( 1 - { mv _0 } )
$.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被火车创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E7%81%AB%E8%BD%A6%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>为啥这篇文章总是传不上去???</p>
<p>为啥这篇文章总是传不上去???</p>
<p>事情是这样的,几天前,我们班被出了这么一道物理思考题(为表述方便略有简化).</p>
<p>有一辆以$v _0 <span class="math inline">\(行驶的质量超级大的火车,上面站了一个质量为\)</span>m
<span class="math inline">\(的人随火车一起运动.突然，这个人相对于火车以\)</span>v
<span class="math inline">\(的速度向前平跳(也就是说此时他相对于地面的速度为\)</span>v
_0 + v $),求这个人做这个起跳需要多少能量.</p>
<p>注意这里火车质量很大,所以火车在此人跳跃过程中始终以$v _0
$速度前进.</p>
<p>我看到这个题觉得很简单啊,肯定是$ { 2 } ( ( v _0 + v ) ^2 - v _0 ^2 )
<span class="math inline">\(.然后发现答案竟然是\)</span> { 2 } ( v ) ^2
$.</p>
<p>下面是我们物理课代表给出的解释:</p>
<p>虽然人的动能变化确实是$ { 2 } ( ( v _0 + v ) ^2 - v _0 ^2 )
$,但是在他起跳的过程中,火车对他是有一个力的.而且,因为火车在运动,所以虽然起跳的时候人相对于火车没有运动,但这个力的作用点相对于地面竟然是运动着的!</p>
<p>因此,不妨设这个力为$F <span class="math inline">\(,注意这里的\)</span>F <span class="math inline">\(不一定是常数,而是一个关于时间\)</span>t <span class="math inline">\(的函数,我们自然有:\)</span>W = _{ t _0 } ^{ t _1 }
Fx t <span class="math inline">\(,注意到作用点的速度恒为\)</span>v _0
<span class="math inline">\(,因此\)</span>W = v <em>0 </em>{ t _0 } ^{ t
_1 } F t = v _0 p = v _0 vm $,把这个加上后恰好得出答案.</p>
<p>这时我意识到这个事情其实就等价于任何惯性参考系参考下能量都是守恒的.所以我们直接以火车为参考系,立即得出答案.</p>
<p>但是为啥呢?而且我总觉得上面那个力的分析非常诡异,因为我总感觉起跳是瞬间的,这个力理论上不应该做功啊.</p>
<p>通过在网上海量搜索后,我大概找到了这么两种理解方式啊.</p>
<p>第一种是,我们冷静一下.如果没有外力干扰,那么火车其实<strong>并不能匀速前进</strong>.设火车质量为$M
<span class="math inline">\(,当人的速度为\)</span>v _0 + v <span class="math inline">\(的时候,根据动量守恒,火车的速度应该为\)</span>v _0
- { M } v $.</p>
<p>注意这个时候不能以火车为参考系了,因为火车不再是惯性参考系了,所以我们加入一个以$v
_0 <span class="math inline">\(匀速前进的青蛙作为新的参考系.不难发现在青蛙参考系和在地面参考系下,火车和人的系统的动能增量是相等的,都是\)</span>
{ 2 } ( m ( v ) ^2 + M ( { M } v ) ^2 ) $.</p>
<p>然后,因为火车质量非常非常非常大,我们注意到$_{ M + } { M } v = 0
$,完活.</p>
<p>但是这个过程别说还是进行了近似估计了,就是和现实也不符啊.你火车肯定要有动力来源使得其能进行匀速直线运动.但是这个理解方式的优越性在于,它试图将火车和人视作一个系统来观察,这个角度下我们完全不要去管二者分别的动能了,而是直接分析系统动能.</p>
<p>所以我反思了一下为什么我觉得一开始的那个做法很奇怪,我注意到对人做功的力同时一定对火车作负功,那么也就是一定还有一个对火车作正功的外力,这个力同时也是整个系统的外力.</p>
<p>对这个施加在火车上的外力进行完全一样的分析,就可以得到相同的答案.</p>
<p>或者更一般地,我们来证明惯性参考系下的所需要的能量恒定:</p>
<p>我们已知:</p>
<p><span class="math display">\[
\int _{ t _0  } ^{ t _1  } Fv \ \text { d  } t = \frac { m  } { 2  } ( v
_1 ^2 - v _0 ^2 ) + \Delta E
\]</span></p>
<p>要证:</p>
<p><span class="math display">\[
\int _{ t _0  } ^{ t _1  } F ( v - v _w ) \ \text { d  } t = \frac {
m  } { 2  } ( ( v _1 - v _w ) ^2 - ( v _0 - v _w ) ^2 ) + \Delta E
\]</span></p>
<p>而注意到:</p>
<p><span class="math display">\[
\int _{ t _0  } ^{ t _1  } F ( v - v _w ) \ \text { d  } t = \int _{ t
_0  } ^{ t _1  } F ( v ) \ \text { d  } t - \int _{ t _0  } ^{ t _1  }
Fv _w \ \text { d  } t = \frac { m  } { 2  } ( v _1 ^2 - v _0 ^2 ) - v
_w m ( v _1 - v _0 ) + \Delta E
\]</span></p>
<p>这就证明了该结论!</p>
<p><del>不过这个做法虽然相当理性但是一点都不直观啊,为什么两个平方竟然可以在这里线性加减,我其实还是没找到更加易于理解的方式啊,如果有大佬知道可以联系我一下qwq</del></p>
<p>哦哦我突然瞎想出了一个相当简洁的方式啊,就是我们不难注意到只要满足动量守恒以及做功的方程$W
= Fx
$,我们很自然可以推导出动能差的表达式,而这两个基础的表达式都是线性的,因此动能差也一定与选取哪个惯性参考系无关!</p>
<p>换句话说,这个动能差的表达式中的平方是我们积分积出来的,但是积分是可以加减的!</p>
<hr>
<p>在大半夜和Querainy 和Minuses
深入交流之后,我发现上面的过程还是太感性理解了,我们来添加一些细节.</p>
<p>首先,Minuses
提供了在宏观下动量定理和牛二等价的证明(他原本的形式用的全是向量,但是我比较懒,所以换成一维情况了):</p>
<p><span class="math display">\[
F \ \text { d  } t = m \ \text { d  } v
\]</span></p>
<p><span class="math display">\[
F = \frac { \text { d  } v  } { \text { d  } t  } m = am
\]</span></p>
<p>然后,他又提供了只要有牛顿第二定律和$W = Fx
$的定义,我们就可以推导惯性参考系下动能定理的证明:</p>
<p><span class="math display">\[
F = m \frac { \text { d  } v  } { \text { d  } t  }
\]</span></p>
<p><span class="math display">\[
F \text { d  } x = m \frac { \text { d  } v  } { \text { d  } t  } \text
{ d  } x = mv \ \text { d  } v
\]</span></p>
<p><span class="math display">\[
W = \int _{ t _0  } ^{ t _1  } F \text { d  } x = m \int _{ t _0  } ^{ t
_1  } v \text { d  } v = \frac { 1  } { 2  } m ( v _1 ^2 - v _0 ^2 )
\]</span></p>
<p>Minuses 无敌,可让天下一先.</p>
<hr>
<p>Querainy提出我之前的说法是错误的,因为在不同参考系下牛顿第二定律的确不会有影响,但是$W
= Fx
$是受到了影响的.例如在上面的例子中,如果以火车为参考系,那么火车与人之间的力对人是没有做功的.但是以地面为参考系,那么这个力因为作用点在变所以是做功了的.</p>
<p>然而这个做功的改变在上面的积分形式中就可以发现,由于速度的改变导致平方项不能完美消除,因此这个做功的改变会抵消切换参考系(伽利略变换)带来的<strong>动能形式的改变</strong>.</p>
<p>这个自我修正bug看上去相当诡异,但是一想到动能定理本身就是从$W = Fx
$和牛顿第二定律推导出来的,因此有自洽性也非常合理.</p>
<p>追根溯源看上面整个问题,我们会发现,如果我们换参考系然后看动能,动能的变化量的确是不一样的.</p>
<p>但是问题在于,我们在意的不是动能的变化量,而是我引起这个变化需要外加多少能量.如果我引起这个变化所需要外加的能量不变,那么就仍然满足能量守恒定律.</p>
<p>如果我们换参考系,动能的变化量改变,但是同时原本不做功的力也会随之进行做功.事实上由于力的作用点最多只在一个惯性参考系下才是静止的,因此换参考系几乎一定会引起力的做功.</p>
<hr>
<p>所以我们其实还可以再举一个类似的例子:</p>
<p>考虑一个劲度系数为$k <span class="math inline">\(的弹簧连在地上,上面放了一个重物\)</span>M
$,我们来观察一下这个东西.</p>
<p>不妨取<strong>重物放上弹簧后的平衡位置</strong>为重力势能和弹性势能的零点,设弹簧原长位置相对于此位置距离为$x
_0 <span class="math inline">\(,此时当然有\)</span>kx _0 = Mg
$那考虑系统的弹性势能:</p>
<p><span class="math display">\[
E _{ p 1  } = \frac { k  } { 2  } ( x - x _0 ) ^2 - \frac { k  } { 2  }
( x _0 ) ^2 = \frac { k  } { 2  } x ^2 - kx _0 x
\]</span></p>
<p>重力势能:</p>
<p><span class="math display">\[
E _{ p 2  } = Mgx
\]</span></p>
<p>那么总势能当然是:</p>
<p><span class="math display">\[
E _p = \frac { 1  } { 2  } kx ^2 - kx _0 x + Mgx = \frac { 1  } { 2  }
kx ^2
\]</span></p>
<hr>
<p>时隔不知道多长时间,现在我们来证明柯尼希定理:质点系在参考系$A <span class="math inline">\(中的总动能等于质点系在质心系中的动能与质心在参考系\)</span>A
$中的动能之和.</p>
<p>不妨设质心系下质点系的总动能为$E <em>{ kS } <span class="math inline">\(,参考系\)</span>A <span class="math inline">\(下的总动能为\)</span>E </em>{ kA } <span class="math inline">\(,质心相对于\)</span>A <span class="math inline">\(参考系的速度为\)</span> _C $,我们当然有:</p>
<p><span class="math display">\[
\begin{aligned}
E _{ kS  } &amp; = \frac { k  } { 2  } \sum m _i ( \vec { v  } _i - \vec
{ v  } _C ) ^2 \\
&amp; = E _{ kA  } + \frac { k  } { 2  } ( M \sum ( \vec { v  } _C ) ^2
- 2 \sum m _i \vec { v  } _i \vec { v  } _C ) \\
&amp; = E _{ kA  } + \frac { k  } { 2  } ( M \sum ( \vec { v  } _C ) ^2
- 2 ( \vec { v  } _C ) ^2 \sum m _i ) \\
&amp; = E _{ kA  } - \frac { k  } { 2  } M ( \vec { v  } _C ) ^2
\end{aligned}
\]</span></p>
<p>那这就给出了一个更强的结论,而且这里的质心参考系甚至不需要是惯性系.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被摆球创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E6%91%86%E7%90%83%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>今晚学弟问了我这么一个问题:</p>
<p>对于一个圆锥摆,设其绳上拉力为$T $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T \sin \theta &amp; = m \omega ^2 \sin \theta L \\
T &amp; = m \omega ^2 L
\end{aligned}
\]</span></p>
<p>那么问题来了:当小球自然下垂的时候,$T = mg <span class="math inline">\(,但是\)</span>= 0 $,左边不等于右边???</p>
<p>怎么处理这个问题呢?</p>
<hr>
<p>下面是我个人的想法啊,不一定正确.</p>
<p>冷静一下,$= { r } <span class="math inline">\(,我们的确能确认自然下垂的时候\)</span>v = 0 <span class="math inline">\(,但由于\)</span>r $也是$0 <span class="math inline">\(,我们没道理判定\)</span>= 0 $.</p>
<p>那么我们把角速度换成线速度就有:</p>
<p><span class="math display">\[
\begin{aligned}
T \sin \theta &amp; = m \frac { v ^2  } { \sin \theta L  } \\
T \sin ^2 \theta &amp; = \frac { mv ^2  } { L  }
\end{aligned}
\]</span></p>
<p>这样极限情况下两边就相等了(均为$0 $).</p>
<hr>
<p>或者说我们还可以这么干:</p>
<p>考虑$T = { } <span class="math inline">\(,所以\)</span>^2 = { L }
<span class="math inline">\(,注意到其实\)</span>$是随着小球下落而单调递减的,但是不可能减到$0
$.</p>
<hr>
<p>另一个想法是:考虑先放一个实体圆锥(可提供支持力),让球在圆锥上转圈,然后逐渐加速到支持力$N
= 0 $,此时小球会飘起来.我们观察一下这个式子是啥:</p>
<p>考虑引入离心力,只需要让离心力,重力,支持力和拉力四力平衡即可,设绳子与竖直方向的夹角为$$,作正交分解后立刻有:</p>
<p><span class="math display">\[
\begin{cases}
N \cos \theta = T \sin \theta - m \omega ^2 L \sin \theta \\
N \sin \theta = mg - T \cos \theta
\end{cases}
\]</span></p>
<p>替换掉其中的$N $,得到:</p>
<p><span class="math display">\[
\begin{aligned}
mg \cos \theta - T \cos ^2 \theta &amp; = T \sin ^2 \theta - m \omega ^2
L \sin ^2 \theta \\
T &amp; = mg \cos \theta + m \omega ^2 L \sin ^2 \theta
\end{aligned}
\]</span></p>
<p>考虑$T <span class="math inline">\(和\)</span>^2 <span class="math inline">\(的函数关系,小球从在圆锥摆上的状态到飘起来的状态应该是连续的两段直线,注意到当\)</span>
<span class="math inline">\(的时候,它俩的关系是\)</span>T = mg <span class="math inline">\(的平行于\)</span>^2 <span class="math inline">\(轴的直线,这段直线会一直延伸到\)</span><span class="math inline">\(的最低点,也就是\)</span>= $的点然后再转上去.</p>
<hr>
<p>如果这个文章就这么结束还是有点无聊,不如让我们来看个类似的问题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k0eufkm2.png"></p>
<p>先来看第一问:</p>
<p>设水平向左为正方向,设小球相对于滑块的水平速度为$v _1 <span class="math inline">\(,滑块速度为\)</span>v _2 $.</p>
<p>水平方向动量守恒,当然有$m ( v _1 - v _2 ) = Mv _2 $.</p>
<p>此时小球的总速度应该为$v = = v _2 $.</p>
<p>小球和滑块的总机械能守恒,当然有:$ { 2 } mv ^2 + { 2 } Mv _2 ^2 = mgR
$.</p>
<p>两式联立,解得:$v _2 = = $.</p>
<p>看上去只是麻烦而已,也没那么难嘛.</p>
<p>再来看第二问:</p>
<p>考虑$a _n = { R } = { m ^2 R ^2 } = { M + m ^2 } $,</p>
<p>而滑块的水平加速度大小应该是$a ’ = - { M } <span class="math inline">\(,那么惯性力\)</span>F ’ = - a ’ m = { M } $.</p>
<p>而$a _n m = N - mg + F ’ <span class="math inline">\(,\)</span> { M }
N = ma _n + mg = { M + m ^2 } + mg = mg ( { M + m ^2 } ) <span class="math inline">\(,整理得到\)</span>N = Mm ( { ( M + m ^2 ) ^2 } )
$.方向沿半径方向朝向圆心.</p>
<p>这里就要用惯性力了.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被小船创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%B0%8F%E8%88%B9%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>众所周知,高中物理有一道很经典的分解速度的题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1t04v0mr.png"></p>
<p>物理老师在上课讲这个题的时候,将速度分解为两个正交的速度,这两个速度的矢量和就是原速度.</p>
<p>乍一看好像非常合理,然而随即大家可能就会见到这个题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ajz7jb.png"></p>
<p>其中中间的物体下落的速度为$v <span class="math inline">\(,这个时候沿绳子分解速度的时候,两个分速度应该均是\)</span>v
$,而这个时候两个速度的矢量和并不是原速度啊!</p>
<p>老师讲到这里的时候,往往会说这是因为:“速度的分解和力的分解并不一样.”但你可能会疑问:同样是矢量的分解,为什么会不一样呢?</p>
<p>先提前给出我的思考:在这个滑轮组模型中,我们做的操作并不是将原速度分解为了这两个速度,这两个速度也并非由原速度一下分解出来的,而分别只是原速度分解出的速度的一部分.</p>
<hr>
<p>先看这个最经典的模型:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1t04v0mr.png"></p>
<p>不妨设高度差为$h <span class="math inline">\(,此时绳子长度为\)</span>L <span class="math inline">\(,物体距离墙的距离为\)</span>x $.</p>
<p>有勾股定理:</p>
<p>$L ^2 = h ^2 + x ^2 <span class="math inline">\(,注意到此时\)</span>h
$是一个常量.</p>
<p>两边对$t $求导,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
2 Lv _L &amp; = 2 xv _x \\
v _L &amp; = \frac { x  } { L  } v _x &amp; = v _x \cos \theta
\end{aligned}
\]</span></p>
<p>此时的另一个分速度自然是$v _h = v _x
$.在物理课上,物理老师会这么解释这种分解:</p>
<p>$v _L <span class="math inline">\(这个速度提供了绳子缩短的速度,而\)</span>v _h
$提供了绳子转动的速度.</p>
<p>那么这个$v _h <span class="math inline">\(听上去应该是此时绳子与物体接触点的转动的线速度对吧.也就是说角速度应该是\)</span>=
{ L } = { L ^2 } v _x <span class="math inline">\(,令绳子与转轴夹角为\)</span>, = { L }
$而我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\omega &amp; = \frac { \text { d  } \alpha  } { \text { d  } t  } \\
&amp; = \frac { \text { d  } \alpha  } { \text { d  } \sin \alpha  }
\frac { \text { d  } \sin \alpha  } { \text { d  } t  } \\
&amp; = \frac { 1  } { \frac { \text { d  } \sin \alpha  } { \text {
d  } \alpha  }  } \frac { \text { d  } \sin \alpha  } { \text { d  }
t  } \\
&amp; = \frac { 1  } { \cos \alpha  } \frac { v _x L - v _L x  } { L
^2  } \\
&amp; = \frac { h  } { L ^2  } v _x
\end{aligned}
\]</span></p>
<p>这就证明了$v _h $的确是线速度,这也与我们直观感受相当匹配.</p>
<hr>
<p>解释完上面这个分解的正确性,我们又要开始考虑了:那么为什么力和速度的分解不一样呢?</p>
<p>有一个很形象的比喻,那就是如果两个人同时以速度$v <span class="math inline">\(的速度拉一个物体,这个物体的速度是\)</span>v <span class="math inline">\(;但如果两个人同时以力\)</span>F
$拉一个物体,这个物体的受力是$2 F $.</p>
<p>这是为什么呢?动量定理实际上将力在时间上的积累与动量等价起来了对吧,由于速度并非是动量,因此自然像力那样叠加.这么思考也许是正确的:两个受力均为$F
$的物体的合力是$2 F <span class="math inline">\(,两个速度均为\)</span>v
<span class="math inline">\(的物体合速度为\)</span>v <span class="math inline">\(,两个动量均为\)</span>p
$的速度相同的物体合动量为$2 p $.</p>
<p>或者换而言之,力的作用之间是有牛顿第三定律作保证的,这就可以让力在物体间存在一种类似传递的效果.但是速度并没有这种效果,速度并非是外界对物体做出的改变,而是物体的性质本身.</p>
<p>从这个角度,我们回到滑轮的那个题,我们就可以明白为什么要这么分解了:原因很简单,这两个沿绳的速度并不是一次分解分解出来的,而是让原本的速度先沿其中一个绳分解为两个速度,一个是沿绳的速度$v
<span class="math inline">\(,另一个是提供绳转动的线速度\)</span>v $.</p>
<p>而速度是不能叠加的,因此右边也做这个操作,这就使得沿绳的分速度均为$v
$.</p>
<hr>
<p>回看开头的那个滑轮题,这题其实还有个很好玩的地方:那就是C的动能最大点可不是C的受力平衡点:原因很简单,C的受力平衡点由于滑轮作用仍然存在角速度上的加速度.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被地球创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%9C%B0%E7%90%83%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>大家高中都学过开普勒三定律对吧!下面我们来证明它们是对的.</p>
<p>由于难度不太一样,我们微调一下顺序.</p>
<h3><span id="开普勒第二定律">开普勒第二定律</span></h3>
<p>根据角动量守恒,当然有$ = C <span class="math inline">\(为定值.又根据机械能守恒,其在某一个点的机械能应该为\)</span>-
{ r } + { 2 m } $.</p>
<p>先考虑证明开普勒第二定律,取一段极小时间$ t <span class="math inline">\(,考虑掠过的面积应该是\)</span> S = { 2 } ( + ) = {
2 } <span class="math inline">\(,于是掠面速度\)</span>V = { t } = { 2 m
} $是一个常数.</p>
<h3><span id="开普勒第三定律">开普勒第三定律</span></h3>
<p>那么$T = { V } = { } = mab { C } $.</p>
<p>那么$ { a ^3 } = { aC ^2 } $.</p>
<p>根据机械能守恒,当然应该有在近日点和远日点机械能相等,那自然有:</p>
<p><span class="math display">\[
\begin{aligned}
- \frac { GmM  } { a + c  } + \frac { C ^2  } { 2 m ( a + c ) ^2  }
&amp; = - \frac { GmM  } { a - c  } + \frac { C ^2  } { 2 m ( a - c )
^2  } \\
m ^2 &amp; = C ^2 \frac { a  } { b ^2 GM  }
\end{aligned}
\]</span></p>
<p>带入得到$ { a ^3 } = { GM } $是一个定值.</p>
<h3><span id="开普勒第一定律">开普勒第一定律</span></h3>
<p>我们知道圆锥曲线的极坐标方程是:</p>
<p><span class="math display">\[
r ( \theta ) = \frac { ep  } { 1 - e \cos \theta  }
\]</span></p>
<p>其中$e <span class="math inline">\(是离心率,\)</span>p
$是准焦距(焦点到准线的距离).</p>
<p>后面不会了,开摆!</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被兔子创飞了</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%85%94%E5%AD%90%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>没想到这个系列博客都出到第三节了.</p>
<p>之所以起这么个名字,是因为下面要开搞的数列很像真理元素的<a href="https://www.bilibili.com/video/BV1B7411W7LB">这个视频</a>.但其实下面的操作和这个视频并没有什么关系.</p>
<p><del>而且其实理论上,这篇博客的名字应该叫《被qyc创飞了(1)》</del></p>
<p>前天,qyc给我发了一个<a href="https://www.luogu.com/article/5gal95wp">博客</a>,里面提供了一种非常厉害的估计数列的方法.我一看就觉得超级厉害啊,因为这个题我之前也做过然后被爆杀了,而竟然可以拿科技秒掉.</p>
<p>大概讲一下qyc的神仙操作:</p>
<p>$a <em>1 = 1 , a </em>{ n + 1 } - a _n = - { 3 } a _n ^2 $</p>
<p>考虑构造一个函数$f ( n ) <span class="math inline">\(使得\)</span>f (
n ) a <em>n <span class="math inline">\(,那我们就可以将\)</span>a </em>{
n + 1 } - a _n f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$x
_0 , f ’ ( x _0 ) = f ( n + 1 ) - f ( n ) <span class="math inline">\(,而对于增长率变化不大的函数,直接认为\)</span>f ’ (
x _0 ) = f ’ ( n ) $是有理可循的!</p>
<p><span class="citation" data-cites="Minuses在知乎上找到了这个东西的">@Minuses在知乎上找到了这个东西的</span><a href="https://zhuanlan.zhihu.com/p/342641401">系统理论</a>.<del>但是我没有看</del>.</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 <span class="math inline">\(解得\)</span>f ( n ) = { n + 2 }
$.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>但是我不满意!具体数学上教过我们可以用数列估计误差项,那现在我们来考虑一下它的误差项吧!</p>
<p>令$a _n = { n + 2 } - b _n <span class="math inline">\(,带入化简,得到\)</span>{ b _n } $的递推式:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } &amp; = ( \frac { 3  } { n +
2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } )
\\
b _{ n + 1  } - \frac { 3  } { n + 3  } &amp; = ( b _n - \frac { 3  } {
n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 &amp; = 0 , b _{ n + 1  } &amp; = \frac { b _n ^2  } { 3  } + \frac
{ n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  }
\end{aligned}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出$b _n { 4 n }
$,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n <span class="math inline">\(的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设\)</span>b
_n ^2 &lt; &lt; b _n $:</p>
<p>$b _{ n + 1 } = O ( 1 ) b _n + O ( { n ^3 } ) $.</p>
<p>那么$b _n <span class="math inline">\(应该是\)</span>O ( { n ^2 } )
$级别的对吧!然后我就开始算,算了一晚上也没放出来一个式子,相当自闭.</p>
<p>晚上回家咨询了一下汪神wzm,得知了这个$b _n <span class="math inline">\(是\)</span>O ( { n ^2 } )
$级别的,这下白算一晚上了.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
b _{ n + 1  } &amp; = \frac { n  } { n + 2  } b _n + \frac { 1  } { n (
n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } &amp; = n ( n + 1 ) b _n + \frac {
1  } { n  } \\
g ( n ) &amp; = n ( n + 1 ) b _n , g &#39; ( n ) &amp; = \frac { 1  } {
n  } , g ( n ) &amp; = \ln n \\
b _n &amp; = \frac { \ln n  } { n ^2  }
\end{aligned}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ } ) <span class="math inline">\(和\)</span>O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n { n ( n + 1 ) } $.</p>
<p>但是如果你尝试带入数学归纳,会发现完全做不动.怎么办呢?</p>
<p>在这个问题被搞出来后两个周,我妈的一位同事给出了纯文化课的牛逼做法,下面来介绍一下这个做法并且终结此题:</p>
<p>首先换元,上面等价于下面这个数列放缩:</p>
<p><span class="math display">\[
a _1 = \frac { 1  } { 3  } , a _{ n + 1  } = - a _n ( a _n - 1 )
\]</span></p>
<p>观察形式,注意到$a _n ( a _n - 1 )
$这个东西很像一个类似裂项的东西,因此两边取倒数,自然有:</p>
<p><span class="math display">\[
\frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } = \frac { 1  }
{ 1 - a _n  }
\]</span></p>
<p>考虑$0 &lt; a _n { 3 } $,于是我们有下面这个不等式:</p>
<p><span class="math display">\[
1 &lt; \frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } \leq
\frac { 3  } { 2  }
\]</span></p>
<p>两边求和有:</p>
<p><span class="math display">\[
\begin{aligned}
n &amp; \leq \frac { 1  } { a _{ n + 1  }  } - 3 &amp; \leq \frac { 3  }
{ 2  } n \\
\frac { 2  } { 3 ( n + 1 )  } &amp; \leq a _n &amp; \leq \frac { 1  } {
n + 2  }
\end{aligned}
\]</span></p>
<p>仔细观察下面这个式子:</p>
<p><span class="math display">\[
\frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } = \frac { 1  }
{ 1 - a _n  }
\]</span></p>
<p>我们上面的操作实质上是使用这个式子将$0 &lt; a _n { 3 }
$这个放缩给缩紧了,所以我们再用一次这个式子再紧一遍.</p>
$$
<span class="math display">\[\begin{aligned}
\frac { 1  } { a _{ n + 1  }  } - \frac { 1  } { a _n  } &amp; \leq
\frac { 1  } { 1 - \frac { 1  } { n + 2  }  } &amp; = \frac { n + 2  } {
n + 1  } &amp; = 1 + \frac { 1  } { n + 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边求和自然有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 1  } { a _{ n + 1  }  } - 3 &amp; \leq n + \sum _{ k = 2  } ^{ n
+ 1  } \frac { 1  } { k  } &amp; \leq n + \ln ( n + 1 ) \\
a _n &amp; \geq \frac { 1  } { n + 2 + \ln n  }
\end{aligned}
\]</span></p>
<p>这个界甚至比我们给出的界还要紧.而且似乎继续迭代可以得到更紧的解!相当牛逼!</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>文化课数学导论</title>
    <url>/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2>
<h3><span id="习惯的更改">习惯的更改</span></h3>
<p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将$C
<em>{ n } ^k <span class="math inline">\(写作\)</span> { k } <span class="math inline">\(,而文化课中不允许此类更改,再者文化课中将\)</span>C
</em>{ n } ^k a ^{ n - k } b ^k <span class="math inline">\(称作二项式的第\)</span>k + 1 $项(从第$1
$项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3>
<p>首先我们有$E ( aX + b ) = aE ( X ) + b , D ( aX + b ) = a ^2 D ( X )
$.</p>
<p>我们都知道期望满足线性可加,也就是$E ( X _1 + X _2 ) = E ( X _1 ) + E
( X _2 )
$,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若$X _1
<span class="math inline">\(和\)</span>X _2 <span class="math inline">\(相互独立,\)</span>E ( X _1 X _2 ) = E ( X _1 ) E (
X _2 ) $,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要$X _1 <span class="math inline">\(和\)</span>X _2 <span class="math inline">\(相互独立,\)</span>D ( X _1 + X _2 ) = D ( X _1 ) +
D ( X _2 ) $.从形式上证明是好证明的,我们考虑:</p>
<p><span class="math display">\[
\begin{aligned}
D ( X _1 + X _2 ) &amp; = E ( ( X _1 + X _2 ) ^2 ) - E ^2 ( X _1 + X _2
) \\
&amp; = E ( X _1 ^2 ) + E ( 2 X _1 X _2 ) + E ( X _2 ^2 ) - E ^2 ( X _1
+ X _2 ) \\
&amp; = E ( X _1 ^2 ) + 2 E ( X _1 ) E ( X _2 ) + E ( X _2 ^2 ) - ( E (
X _1 ) + E ( X _2 ) ) ^2 \\
&amp; = E ( X _1 ^2 ) - E ^2 ( X _1 ) + E ( X _2 ^2 ) - E ^2 ( X _2 ) \\
&amp; = D ( X _1 ) + D ( X _2 )
\end{aligned}
\]</span></p>
<p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为$0
<span class="math inline">\(,不然\)</span>D ( X _1 + X _2 )
$要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为$0
$,并且缩放权值,使得方差恰好为$1
$.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为$0
$的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3>
<h4><span id="两点分布">两点分布</span></h4>
直接写的话也就是$P ( X ) =
<span class="math display">\[\begin{cases}p &amp; X = 1 \\ 1 - p &amp; X
= 0 \\ 0 &amp; other \end{cases}\]</span>
<p><span class="math inline">\(,事实上这么写可能不太严谨,因为两点分布的\)</span>X
= 1 <span class="math inline">\(和\)</span>X = 0
$两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是$G ( x ) = ( 1 - p ) + px <span class="math inline">\(.由此式子轻松推得\)</span>E ( x ) = G ’ ( 1 ) = p
, D ( x ) = E ( x ^2 ) - E ^2 ( x ) = G ’ ’ ( 1 ) + G ’ ( 1 ) - ( G ’ (
1 ) ) ^2 = p - p ^2 = p ( 1 - p ) $.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4>
<p>所谓$n <span class="math inline">\(重伯努利试验,也就是\)</span>n
<span class="math inline">\(次两点分布的累计,满足\)</span>P ( X = k ) =
C _{ n } ^k ( 1 - p ) ^{ n - k } p ^k <span class="math inline">\(,我们关注两个事情,也就是二项式分布的\)</span>E ( X
) = np , D ( X ) = np ( 1 - p )
$,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4>
<p>所谓不放回取球,考虑目前有$N <span class="math inline">\(个数字,有\)</span>M $个是$1 <span class="math inline">\(,剩下\)</span>N - M $个是$0 <span class="math inline">\(,取出\)</span>n <span class="math inline">\(次,取出了\)</span>m $个$1 <span class="math inline">\(的概率.简单组合一下得到此概率为\)</span> { C _{ N
} ^n } \ <span class="math inline">\(,注意这里必须保证\)</span>n N
$.</p>
<p>由范德蒙德卷积得知,$<em>{ m } C </em>{ M } ^m C <em>{ N - M } ^{ n -
m } = C </em>{ N } ^n $,因此该分布列所有情况之和为$1 $.</p>
<p>考虑其均值,从感性上讲必定是$ { N } $.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如$01101
$之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到$1
$的概率,和第二次取得到$1 $的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是$n { N ^2 ( N - 1 ) } $,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4>
<p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写$f ( x ) = { }
\ <span class="math inline">\(,是不是看着非常震撼!其中的方差是\)</span>^2 <span class="math inline">\(,期望是\)</span>$.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足$= 1 , = 0 <span class="math inline">\(,此时的函数也就是\)</span>f ( x ) = { }
$.一个好奇是,你凭啥说所有情况下的概率之和为$1 <span class="math inline">\(,事实上这其实是因为\)</span>g ( x ) = e ^{ - x ^2
} <span class="math inline">\(的积分是\)</span> $,不会求这个积分.</p>
<p>观察$g ( x ) = e ^{ - x ^2 } <span class="math inline">\(这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数\)</span>e
^{ - | x | } <span class="math inline">\(模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是\)</span><span class="math inline">\(的由来,将\)</span>x x <span class="math inline">\(,也就是在\)</span>x <span class="math inline">\(那里除去一个\)</span><span class="math inline">\(.而对这个曲线进行横向移动,也就是将\)</span>x x -
$.</p>
<p>这也就引出所谓的$3 $原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3>
<h4><span id="样本相关系数">样本相关系数</span></h4>
<p>对于若干数据$( x _i , y _i ) <span class="math inline">\(,我们先进行标准化,也就是减去均值后再除以方差,这样做使得\)</span>x
, y $分别的均值为$0 $,方差为$1 $.下面默认已经标准化过了.</p>
<p>不妨构造$n <span class="math inline">\(维向量\)</span> = ( x _1 , x
_2 , , x _n ) , = ( y _1 , y _2 , , y _n ) <span class="math inline">\(,考虑它们的点乘\)</span> $,不难发现由于方差为$1
<span class="math inline">\(,因此\)</span>| | = | | = <span class="math inline">\(,因此它们的点乘为\)</span>n <span class="math inline">\(,设\)</span>r = { n } = $.</p>
<p>如果$k <span class="math inline">\(,\)</span>i , y _i = kx _i <span class="math inline">\(,此时必有\)</span>| r | = 1 <span class="math inline">\(,因此我们断言(为啥呢?其实是不太理解的啊)当\)</span>|
r | $越靠近$1 <span class="math inline">\(的时候,\)</span>x , y
$之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4>
<p>我们在上面的角度审视中提出了一个观点:在满足均值为$0 <span class="math inline">\(的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:\)</span>Y
= bx + a + e , E ( e ) = 0 , D ( e ) = ^2 $.</p>
<p>现在我们要做的就是,已知若干组数据$( x _i , y _i ) <span class="math inline">\(,去构造一组\)</span>a , b <span class="math inline">\(满足上面的条件.不妨令\)</span>e _i = y _i - ( bx
_i + a ) <span class="math inline">\(,若\)</span>e <em>i = 0 <span class="math inline">\(,必有\)</span>a = { y } - b { x } <span class="math inline">\(,带入解得当\)</span><span class="math inline">\(最小的时候,\)</span>b = { </em>{ i } ( x _i - { x
} ) ^2 } \ $.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个$b <span class="math inline">\(使得\)</span><span class="math inline">\(最小,标准化说到底只是为了保证\)</span>= 1
$的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4>
<p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知$P
( AB ) = P ( A ) P ( B ) <span class="math inline">\(,那么我们反推,如果我们在现实中的估计中,发现\)</span>P
( AB ) <span class="math inline">\(和\)</span>P ( A ) P ( B )
$差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:$P ( 00 ) = { n } , P ( 01 ) = { n } ,
P ( 10 ) = { n } , P ( 11 ) = { n } <span class="math inline">\(.那么\)</span>P ( A = 0 ) P ( B = 0 ) = { n ^2 }
<span class="math inline">\(.我们计算它与\)</span>P ( 00 ) <span class="math inline">\(的差,平方后除以\)</span>P ( A = 0 ) P ( B = 0 )
<span class="math inline">\(然后做四遍求和化简,得到\)</span>^2 = { ( a +
b ) ( a + c ) ( c + d ) ( b + d ) } $.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么$P (
^2 x _) = $.或者给出我们经验上的准则:</p>
<p>选取一个较小的$<span class="math inline">\(,并得知其对应的\)</span>x
<em><span class="math inline">\(,如果\)</span>^2 x </em><span class="math inline">\(,推断独立性不成立,犯错的概率是\)</span><span class="math inline">\(.反之断言其独立性成立,犯错的概率不可知,肯定\)</span>$越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2>
<h3><span id="常用对数表">常用对数表</span></h3>
<ol type="1">
<li><p>$ = 0 . 693 $.</p></li>
<li><p>$ = 1 . 099 $.</p></li>
<li><p>$ = 1 . 609 $.</p></li>
<li><p>$ . 1 = - 2 . 303 $.</p></li>
<li><p>$ . 5 = - 0 . 693 $.</p></li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3>
<ol type="1">
<li><p>$e = 2 . 718 $.</p></li>
<li><p>$e ^2 = 7 . 389 $.</p></li>
<li><p>$e ^3 = 20 . 086 $.</p></li>
<li><p>$e ^5 = 148 . 413 $.</p></li>
<li><p>$e ^{ 0 . 1 } = 1 . 105 $.</p></li>
<li><p>$e ^{ 0 . 5 } = 1 . 649 $.</p></li>
<li><p>$e ^= 23 . 147 $.</p></li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3>
<h4><span id="fxxex"><span class="math inline">\(f(x)=xe^x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = ( x + 1 ) e ^x <span class="math inline">\(,\)</span>x =
- 1 <span class="math inline">\(的时候,取最小值\)</span>- { e } $.</p>
<p>另外$_{ x - } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxxln-x"><span class="math inline">\(f(x)=x\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = 1 + x , x = { e } <span class="math inline">\(的时候,有最小值\)</span>- { e } $.</p>
<p>另外$_{ x ^{ + } } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracexx"><span class="math inline">\(f(x)=\frac{e^x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e%5Exdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = { x ^2 } , x = 1 <span class="math inline">\(的时候,有极小值\)</span>e $.</p>
<p>另外$_{ x - } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfraclnxx"><span class="math inline">\(f(x)=\frac{\ln
x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = { x ^2 } , x = e <span class="math inline">\(的时候,有极大值\)</span> { e } $.</p>
<p>另外$_{ x + } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxx-ln-x"><span class="math inline">\(f(x)=x-\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = 1 - { x } , x = 1 $的时候,有最小值$1 $.</p>
<hr>
<h4><span id="fxfracxex"><span class="math inline">\(f(x)=\frac{x}{e^x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = { e ^x } , x = 1 <span class="math inline">\(的时候,有最大值\)</span> { e } $.</p>
<p>另外$_{ x + } f ( x ) = 0 \ $.</p>
<h3><span id="预处理函数">预处理函数</span></h3>
<h4><span id="分离对数">分离对数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令$f ( x ) = ( 2 + x + ax ^2 ) ( x + 1 ) - 2 x <span class="math inline">\(,已知\)</span>x = 0 <span class="math inline">\(是极大值点,求\)</span>a $.</p>
<p>考虑分离对数后操作多项式,我们显然可找到$0 &lt; t &lt; 1 , 2 + t + at
^2 &gt; 0 , 2 - t + at ^2 &gt; 0 <span class="math inline">\(,下面只考虑\)</span>x <span class="math inline">\(.此时\)</span>f ( x ) = ( 2 + x + ax ^2 ) ( ( x +
1 ) - { 2 + x + ax ^2 } ) $.</p>
<p>考虑令$g ( x ) = ( x + 1 ) - { 2 + x + ax ^2 } <span class="math inline">\(,由于\)</span>f ( 0 ) = 0 <span class="math inline">\(,只需证明\)</span>g ( x ) , x $即可.</p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
g &#39; ( x ) &amp; = \frac { 1  } { x + 1  } - \frac { 4 - 2 ax ^2  } {
( 2 + x + ax ^2 ) ^2  } \\
&amp; = \frac { x ^2 ( a ^2 x ^2 + 4 ax + 6 a + 1 )  } { ( x + 1 ) ( 2 +
x + ax ^2 )  } \\
\text { sign  } ( g &#39; ( x ) ) &amp; = \text { sign  } ( a ^2 x ^2 +
4 ax + 6 a + 1 )
\end{aligned}
\]</span></p>
<p>则$a ^2 0 ^2 + 4 a 0 + 6 a + 1 = 0 <span class="math inline">\(,\)</span>a = - { 6 } $.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令$f ( x ) = e ^x - ( x + 1 ) + ax ^3 - x ^2 - 1 <span class="math inline">\(,若\)</span>x ( - 1 , 1 ) , f ( x ) <span class="math inline">\(,求\)</span>a $.</p>
<p>$f ( 0 ) = 0 $,于是上面的条件等价于$0 <span class="math inline">\(是\)</span>( - 1 , 1 ) $的最小值点.</p>
<p>考虑$f ’ ( x ) = e ^x - { x + 1 } + 3 ax ^2 - 2 x <span class="math inline">\(,则\)</span>f ’ ( 0 ) = 0 $恒成立.</p>
<p>讨论$g ( x ) = 1 + e ^{ - x } ( 3 ax ^2 - 2 x - { x + 1 } ) <span class="math inline">\(的正负,看\)</span>g ’ ( x ) = { ( x + 1 ) ^2 e ^x
} $.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3>
<h4><span id="变化条件">变化条件</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知$x + 2 y = 1 <span class="math inline">\(,求\)</span>x ^2 + y ^2
$的最小值.</p>
<p>直接令$x = 1 - 2 y $,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知$x ^2 + y ^3 = 2 <span class="math inline">\(,求\)</span>x + y
$的最小值.</p>
<p>这个的话不妨设其最小值为$C <span class="math inline">\(,有\)</span>x
+ y C <span class="math inline">\(,移项得到\)</span>y C - x
$,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3>
<h4><span id="普通参数方程">普通参数方程</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知$x ^2 + y ^2 - xy = 1 <span class="math inline">\(,求\)</span>x +
y $的最小值.</p>
<p>这个的话大概是这样,我们找到一个$t <span class="math inline">\(,使得\)</span>x = f ( t ) , y = g ( t )
$,然后换元.</p>
<p>比如这个题,你就可以凑成$( x - { 2 } ) ^2 + ( { 2 } y ) ^2 = 1
$,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4>
<h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5>
<p>求证$ &lt; { a - b } &lt; { 2 } $.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<p><span class="math display">\[
\begin{aligned}
\frac { a - b  } { \ln a - \ln b  } &amp; &lt; \frac { a + b  } { 2  }
\\
\frac { a - b  } { a + b  } &amp; &lt; \frac { \ln \frac { a  } {
b  }  } { 2  } \\
\frac { \frac { a  } { b  } - 1  } { \frac { a  } { b  } + 1  } &amp;
&lt; \frac { \ln \frac { a  } { b  }  } { 2  }
\end{aligned}
\]</span></p>
<p>换元,令$t = { b } $,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知函数$f ( x ) = 3 x - ax <span class="math inline">\(,若\)</span>x
_1 &lt; x _2 <span class="math inline">\(是\)</span>f ( x ) <span class="math inline">\(的两个零点,求证\)</span>f ’ ( { 4 } ) &lt; 0
$.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<p><span class="math display">\[
\begin{cases}
3 \ln x _1 = ax _1 \\
3 \ln x _2 = ax _2
\end{cases}
\]</span></p>
<p>我们想要知道的是:$ { x _1 + 3 x _2 } &lt; a $.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把$a
<span class="math inline">\(给换掉,事实上我们根据前面的方程有\)</span>a
= { x _2 - x _1 } $.</p>
<p>于是我们只需要证明:$ { 4 } &gt; { { x _1 } }
$,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5>
<p>已知函数$f ( x ) = x - ax <span class="math inline">\(,其有两个零点\)</span>x _1 x _2 <span class="math inline">\(,求证\)</span>x _1 x _2 &gt; e ^2 $.</p>
<p>同样分析已知,我们得到的是:</p>
<p><span class="math display">\[
\begin{cases}
\ln x _1 = ax _1 \\
\ln x _2 = ax _2
\end{cases}
\]</span></p>
<p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<p><span class="math display">\[
\begin{cases}
\ln x _2 - \ln x _1 = a ( x _2 - x _1 ) \\
\ln x _2 + \ln x _1 = a ( x _2 + x _1 )
\end{cases}
\]</span></p>
<p>这里先把所求变形一下,我们把它改成$x _1 + x _2 &gt; 2 $.</p>
<p>发现了什么?这个东西等价于$a ( x _2 + x _1 ) &gt; 2
$,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换$a $即可.</p>
<h5><span id="example4">Example4</span></h5>
<p>已知$f ( x ) = x ^2 + axe ^x - ae ^{ 2 x } <span class="math inline">\(有三个不同的零点\)</span>x _1 &lt; x _2 &lt; x _3
<span class="math inline">\(,求\)</span>a <span class="math inline">\(的范围,并求证\)</span>( 1 - { e ^{ x _1 } } ) ^2 (
1 - { e ^{ x _2 } } ) ( 1 - { e ^{ x _3 } } ) = 1 $.</p>
<p>考虑两边同时除以$e ^{ 2 x } <span class="math inline">\(,这样得到\)</span>g ( x ) = ( { e ^x } ) ^2 + a {
e ^x } - a <span class="math inline">\(,令\)</span>t = { e ^x } <span class="math inline">\(得到\)</span>g ( t ) = t ^2 + at - a = 0 $.</p>
<p>考察$g ( t ) = 0 <span class="math inline">\(的两根\)</span>t _1 &lt;
t _2 <span class="math inline">\(,根据韦达定理,首先需要满足\)</span>= a
^2 + 4 a &gt; 0 a &gt; 0 <span class="math inline">\(,然后\)</span>t _1
+ t _2 = - a , t _1 t _2 = - a $.</p>
<p>接下来考察函数$ { e ^x } <span class="math inline">\(,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为\)</span>t
_1 , t _2 <span class="math inline">\(中必有一负,因此\)</span>t _2 ( 0 ,
{ e } ) $.由此立得$0 &lt; a &lt; { e ( e - 1 ) } $.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>若$x &gt; 0 <span class="math inline">\(时,\)</span>ax ( e ^{ ax } +
1 ) ( x ^2 + 1 ) x <span class="math inline">\(恒成立,求\)</span>a
$取值范围.</p>
<p>一般这种题先判$a <span class="math inline">\(的正负,注意到\)</span>x
&gt; 1 $的时候右边恒大于$0 <span class="math inline">\(,因此\)</span>a
&gt; 0 $.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数$2 <span class="math inline">\(放进\)</span><span class="math inline">\(,自然有:\)</span>ax ( e ^{ ax } + 1 ) ( x ^2 + 1 )
x ^2 $.</p>
<p>考虑令$t _1 = ax , t _2 = x ^2 $,则:</p>
<p><span class="math display">\[
t _1 ( e ^{ t _1  } + 1 ) \geq t _2 ( e ^{ t _2  } + 1 )
\]</span></p>
<p>接下来分析函数$f ( x ) = x ( e ^x + 1 ) <span class="math inline">\(的单调性,就可以得到\)</span>a { e } $.</p>
<h3><span id="不等式相关">不等式相关</span></h3>
<h4><span id="基本不等式相关">基本不等式相关</span></h4>
<h5><span id="方程角度的审视">方程角度的审视</span></h5>
<p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造$
{ n } = k $.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5>
<p>已知$n , m &gt; 0 , 2 m + n = nm <span class="math inline">\(,求\)</span>n + m + $的最小值.</p>
<p>这个题有一个方式是观察到$n , m ,
$是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
$$
<span class="math display">\[\begin{aligned}
n + m + \sqrt { n ^2 + m ^2  } &amp; \geq k \\
\Leftarrow \sqrt { n ^2 + m ^2  } &amp; \geq k - n - m \\

\end{aligned}\]</span>
<p>$$</p>
<p>如果$n + m k <span class="math inline">\(,那么不等式显然成立,下面只需要证明\)</span>n + m
&lt; k $的情况:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt { n ^2 + m ^2  } &amp; \geq k - n - m \\
\Leftarrow n ^2 + m ^2 &amp; \geq ( k - ( n + m ) ) ^2 \\
\Leftarrow k ^2 + ( n + m ) ^2 - 2 k ( n + m ) &amp; \leq n ^2 + m ^2 \\
\Leftarrow k ^2 + 2 nm - 2 k ( n + m ) &amp; \leq 0 \\
\Leftarrow k ^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) &amp; \leq 0 \\
\Leftarrow k ^2 &amp; \leq n ( 2 k - 2 ) + m ( 2 k - 4 )
\end{aligned}
\]</span></p>
<p>变形方程得到$ { n } + { m } = 1 $,使用这个式子来降次:</p>
$$
<span class="math display">\[\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) &amp; = 6 k - 8 + \frac { n  } { m  } ( 2
k - 2 ) + \frac { m  } { n  } ( 4 k - 8 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>要严谨一点的话我们需要证明$4 k - 8 <span class="math inline">\(,\)</span>k <span class="math inline">\(.这非常简单,因为\)</span>k n + m &gt; 3 $.</p>
<p>这就足够了么?不需要证明存在一个$w = { m }
$使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<p><span class="math display">\[
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k -
2 )  }
\]</span></p>
<p>这个等号可以取到,也就是说,只要满足:</p>
<p><span class="math display">\[
k ^2 \leq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }
\]</span></p>
<p>那么这个$k $就是一个下界,特别地,如果满足:</p>
<p><span class="math display">\[
k ^2 = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }
\]</span></p>
<p>那么这个$k $就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到$k = 10 <span class="math inline">\(是一个解了),接下来我们必须求出一个\)</span>k
$.</p>
<p><span class="math display">\[
\begin{aligned}
k ^2 &amp; = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
k ^2 - 6 k + 8 &amp; = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
( k - 4 ) ( k - 2 ) &amp; = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
\sqrt { k - 2  } &amp; = \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  }
\end{aligned}
\]</span></p>
<p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个$
$带入到上面去!</p>
$$
<span class="math display">\[\begin{aligned}
( k - 4 ) ( k - 2 ) &amp; = 2 \sqrt { 8 ( k - 1 )  } \frac { 2 \sqrt { 8
( k - 1 )  }  } { k - 4  } \\
( k - 4 ) ( k - 2 ) &amp; = \frac { 32 ( k - 1 )  } { k - 4  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说$k
= 0 $是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出$k = 10 $.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4>
<h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5>
$$
<span class="math display">\[\begin{aligned}
f ( x ) &amp; = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( x _0 )  } {
k !  } ( x - x _0 ) ^k \\
f ( x ) &amp; = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( 0 )  } { k
!  } x ^k \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5>
<ol type="1">
<li><p>$ { 1 - x } = _{ k } x ^k = 1 + x + x ^2 + \ $.</p></li>
<li><p>$e ^x = _{ k } { k ! } = 1 + x + { 2 ! } x ^2 + \ $.</p></li>
<li><p>$( 1 + x ) = _{ k } ( - 1 ) ^{ k - 1 } { k } = x - { 2 } x ^2 + {
3 } x ^3 + \ $.</p></li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>已知函数$f ( x ) = x - ax <span class="math inline">\(,其有两个零点\)</span>x _1 x _2 <span class="math inline">\(,求证\)</span>x _1 x _2 &gt; e ^2 $.</p>
<p>极值点偏移的形式,应该是形如$g ( x ) = a <span class="math inline">\(有两个解\)</span>x _1 , x _2 <span class="math inline">\(,然后使得\)</span>x _1 + x _2
$满足一定条件.因此我们先变形条件:</p>
<p><span class="math display">\[
\begin{cases}
\frac { \ln x _1  } { x _1  } = a \\
\frac { \ln x _2  } { x _2  } = a
\end{cases}
\]</span></p>
<p>也就是目前我们构造出了函数$g ( x ) = { x } <span class="math inline">\(,观察\)</span>g ( x ) <span class="math inline">\(图像立得\)</span>x _1 + x _2 &gt; 2 e $.</p>
<p>我们发现,$x _1 x _2 { 4 }
$,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为$x
_1 + x _2 &lt; 2 <span class="math inline">\(,然后令\)</span>t _1 = x _1
, t _2 = x _2 $,带入立有:</p>
<p><span class="math display">\[
\begin{cases}
\frac { t _1  } { e ^{ t _1  }  } = a \\
\frac { t _2  } { e ^{ t _2  }  } = a
\end{cases}
\]</span></p>
<p>而$g ( x ) = { e ^x } <span class="math inline">\(恰好也是满足\)</span>x _1 + x _2 &gt; 2
$的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5>
<p>$f ( x ) = x ( 1 - x ) <span class="math inline">\(,\)</span>b a - a
b = a - b $,求证$2 &lt; { a } + { b } &lt; e $.</p>
<p>首先变形条件得到$b ( 1 + a ) = a ( 1 + b ) <span class="math inline">\(,得到\)</span>f ( { a } ) = f ( { b } )
$,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p>$f ’ ( x ) = - x <span class="math inline">\(,其在\)</span>( 0 , 1 )
, ( 1 , + ) <span class="math inline">\(,考察极值点偏移,我们想要证明\)</span> { b } &lt; e
- { a } <span class="math inline">\(,我们就想办法把\)</span> { b } <span class="math inline">\(和\)</span>e - { a } <span class="math inline">\(扔到同一个区间里,而它们确实同在\)</span>( 1 , + )
$这个区间内.</p>
<p>比较有启发性的是,你发现$ { b } , e - { a } <span class="math inline">\(和\)</span> { a } , e - { b }
$这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 1  } { b  } &amp; &lt; e - \frac { 1  } { a  } \\
f ( \frac { 1  } { a  } ) &amp; = f ( \frac { 1  } { b  } ) &amp; &gt; f
( e - \frac { 1  } { a  } )
\end{aligned}
\]</span></p>
<p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5>
<p>$f ( x ) = e ^{ x - 1 } - ax <span class="math inline">\(在\)</span>(
0 , 2 ) <span class="math inline">\(有两个零点\)</span>x _1 , x _2 <span class="math inline">\(,求证\)</span>x _1 x _2 &gt; { a } $.</p>
<p>首先要证明$a <span class="math inline">\(的范围啊,我们不加证明地给出:\)</span>a ( 1 , { 2 }
) <span class="math inline">\(,并且\)</span>( - , 1 + a ) , ( 1 + a , +
) $.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<p><span class="math display">\[
\begin{cases}
ax _1 = e ^{ x _1 - 1  } \\
ax _2 = e ^{ x _2 - 1  }
\end{cases}
\]</span></p>
<p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取$$,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取$<span class="math inline">\(,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到\)</span>x
_1 x _2 <span class="math inline">\(和\)</span>x _1 + x _2
$之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如$0
&lt; f ( 2 + a - x _2 ) $,也就是$0 &lt; ae ^{ 1 - x _2 } - a ( 2 + a - x
_2 ) $.</p>
<p>但是这样有一个问题,我们把$f <span class="math inline">\(带进去,你会发现最后我们的式子同时带有\)</span>a ,
x _2 <span class="math inline">\(,这个就难做了,咋办呢?考虑拿\)</span>ax
_2 = e ^{ x _2 - 1 } <span class="math inline">\(操作一下把\)</span>a
$消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4>
<h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5>
<ol type="1">
<li><p>$e ^x x + 1 $.</p></li>
<li><p>$ { x } x x - 1 $.</p></li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol start="3" type="1">
<li>$( n + 1 ) &lt; _{ k = 1 } ^n { k } $.</li>
</ol>
<p>考虑$( { n } ) &lt; { n } $,左右两边分别求和得到上面的式子.</p>
<ol start="4" type="1">
<li>$n &gt; _{ k = 2 } ^n { k } , n &gt; 1 $.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明$ { n } &lt; - _{ k = 2 }
^n { k } $.</p>
<p>考虑$( { n } ) - { n } $,两边求和得到上式.</p>
<ol start="5" type="1">
<li>$_{ k = 1 } ^n ( { n } ) ^n &lt; { e - 1 } $.</li>
</ol>
<p>考虑$n ( { n } ) k - n <span class="math inline">\(,也就有\)</span>(
{ n } ) ^n e ^{ k - n } $,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>设$f ( x ) = x x <span class="math inline">\(,若\)</span>f ( x ) = b
<span class="math inline">\(有两个实数根\)</span>x _1 , x _2 ( x _1 &lt;
x _2 ) <span class="math inline">\(,求证:\)</span>be + 1 &lt; x _2 - x
_1 &lt; { 2 } $.</p>
<p>注意到$f ( x ) <span class="math inline">\(下凸,考虑求出两条切线,那么这两条切线与\)</span>y =
b <span class="math inline">\(的交点之差要大于等于\)</span>x _2 - x _1
<span class="math inline">\(,两条割线交点之差要小于等于\)</span>x _2 - x
_1 $.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是$b - { e } <span class="math inline">\(的情况,为了让这种情况有解,我们的割线必过\)</span>(
{ e } , - { e } ) $.</p>
<p>考虑直接选取$( 0 , 0 ) <span class="math inline">\(和\)</span>( 1 , 0
) <span class="math inline">\(作为另外两个点,这两条割线就是\)</span>x =
- y <span class="math inline">\(和\)</span>x = ( e - 1 ) y + 1
$.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得$(
x _2 - x <em>1 ) </em>{ } $尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是$u <span class="math inline">\(,另一个是\)</span>v <span class="math inline">\(,其中\)</span>v &lt; { e } &lt; u
$,那么两条切线分别是:</p>
<p><span class="math display">\[
\begin{cases}
x = \frac { y - f ( u )  } { f &#39; ( u )  } + u \\
x = \frac { y - f ( v )  } { f &#39; ( v )  } + v
\end{cases}
\]</span></p>
<p>那么,现在我们要做的就是找到一组$( u , v ) $,使得:</p>
<p><span class="math display">\[
\frac { b - f ( u )  } { f &#39; ( u )  } + u - \frac { b - f ( v )  } {
f &#39; ( v )  } - v = \frac { e ^{ - 3  } + 2 + 3 b  } { 2  }
\]</span></p>
<p>感觉很难搞啊,我们不妨让$u = 1 $,自然有:</p>
<p><span class="math display">\[
\frac { ( f &#39; ( v ) - 1 ) b + f ( v ) - vf &#39; ( v )  } { f &#39;
( v )  } = \frac { e ^{ - 3  } + 3 b  } { 2  }
\]</span></p>
<p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<p><span class="math display">\[
\begin{cases}
\frac { f &#39; ( v ) - 1  } { f &#39; ( v )  } = \frac { 3  } { 2  } \\
\frac { f ( v ) - vf &#39; ( v )  } { f &#39; ( v )  } = \frac { e ^{ -
3  }  } { 2  }
\end{cases}
\]</span></p>
<p>考虑让$f ’ ( v ) = - 2 <span class="math inline">\(,则\)</span>v = e
^{ - 3 } $,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求证:$x ( 0 , + ) , x + 1 &gt; { e ^{ x + 1 } } - { e ^2 x } $.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以$x
$,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为$x x + x &gt; { e ^{ x + 1 } } - { e ^2 } <span class="math inline">\(,然后证明左边的最小值\)</span>$右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4>
<p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5>
<p>已知$a = 0 . 1 e ^{ 0 . 1 } , b = { 9 } , c = - . 9 <span class="math inline">\(,求比较\)</span>a , b , c $的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6>
<p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算$a <span class="math inline">\(和\)</span>c $的大小关系.</p>
<p>构造函数$f ( x ) = xe ^x + ( 1 - x ) <span class="math inline">\(,则\)</span>f ( 0 . 1 ) &gt; 0 a &gt; c $.</p>
<p>考察$f ( 0 ) = 0 <span class="math inline">\(,\)</span>f ’ ( 0 ) = 0
<span class="math inline">\(,\)</span>f ’ ’ ( 0 ) = 4 &gt; 0 <span class="math inline">\(,则\)</span>f ( 0 ) = 0 <span class="math inline">\(是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算\)</span>f
( 0 . 1 ) &gt; 0 $.</p>
<h6><span id="估算定积分">估算定积分</span></h6>
<p>考察$a <span class="math inline">\(和\)</span>b <span class="math inline">\(的大小关系,不妨设\)</span>f ( x ) = ( 1 - x ) e ^{
1 - x } - { 10 x } <span class="math inline">\(,则\)</span>f ( 0 . 9 )
&lt; 0 b &gt; a $.</p>
<p>注意到$f ( 1 ) = - { 10 } <span class="math inline">\(,\)</span>f ’ (
1 ) = - { 10 } <span class="math inline">\(,考虑估算一下积分,那么\)</span>f ( 0 . 9 ) f ( 1 )
- f ’ ( 1 ) 0 . 1 = - { 100 } &lt; 0 $.</p>
<p>你可能会觉得这个$- { 100 } <span class="math inline">\(,是不是不太能那么肯定地估算啊.但是实际上,我们考察\)</span>f
’ ( x ) = ( x - 2 ) e ^{ 1 - x } + { 10 x ^2 } <span class="math inline">\(,这个东西在\)</span>[ 0 . 9 , 1 ] <span class="math inline">\(上直觉上平均值是大于\)</span>- { 10 }
$的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6>
<p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6>
<p>接下来开抄标答.</p>
<p>令$f _a ( x ) = xe ^x , f _b ( x ) = { 1 - x } , f _c ( x ) = - ( 1 -
x ) $.</p>
<p>这样当$x = 0 . 1 $的时候所有的数字都被正确表示了.</p>
<p>比较$a , b $:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<p><span class="math display">\[
\begin{aligned}
y &amp; = \ln ( a ) - \ln ( b ) &amp; = x + \ln ( 1 - x ) \\
y &#39; &amp; = 1 - \frac { 1  } { 1 - x  } &amp; = \frac { - x  } { 1 -
x  }
\end{aligned}
\]</span></p>
<p>注意到$x = 0 <span class="math inline">\(的时候\)</span>y = 0 <span class="math inline">\(,又注意到其在\)</span>( 0 , 0 . 1 ) <span class="math inline">\(上单减,这样立有\)</span>a &lt; b $.</p>
<p>比较$a , c $:</p>
$$
<span class="math display">\[\begin{aligned}
y &amp; = a - c &amp; = xe ^x + \ln ( 1 - x ) \\
y &#39; &amp; = ( x + 1 ) e ^x - \frac { 1  } { 1 - x  } &amp; = \frac {
( 1 + x ) ( 1 - x ) e ^x - 1  } { 1 - x  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$x = 0 <span class="math inline">\(的时候\)</span>y = 0 <span class="math inline">\(,又注意到其在\)</span>( 0 , 0 . 1 ) <span class="math inline">\(上单增,这样立有\)</span>a &gt; c $.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2>
<h3><span id="递归式的求解">递归式的求解</span></h3>
<h4><span id="特征根法">特征根法</span></h4>
<p>一个常系数的$k $阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n &amp;
\geq k \\
a _0 &amp; = C _0 , a _1 &amp; = C _1 , . . . , a _{ k - 1  } &amp; = C
_{ k - 1  }
\end{aligned}
\]</span></p>
<p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程$r ^k = _{ i = 1 } ^k c _i r ^{ k - i }
$是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根$r _1 <span class="math inline">\(和\)</span>r _2 <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r _1 ^n + _2 r _2 ^n
$.</p>
<p>若其特征方程有两个相同的根$r <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r ^n + _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 <span class="math inline">\(或者\)</span>n = 1 <span class="math inline">\(的情况,我们考虑求出一组\)</span>_1 <span class="math inline">\(和\)</span>_2 $来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C _0 &amp; = \alpha _1 + \alpha _2 \\
C _1 &amp; = \alpha _1 r _1 + \alpha _2 r _2
\end{aligned}
\]</span></p>
<p>若$r _1 r _2 $,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha _1 &amp; = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 &amp; = C _0 - \alpha _1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } )
+ c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) +
\alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有$= c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C _0 &amp; = \alpha _1 \\
C _1 &amp; = \alpha _1 r + \alpha _2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } -
\alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2
nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
&amp; = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n -
2  }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明$c _1 r + 2 c _2 = 0 <span class="math inline">\(即可.根据方程,不难发现\)</span>r = { 2 } <span class="math inline">\(,根据\)</span>= 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>在上面做$k = 2
$的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6>
<p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定$a _0 , . . . , a _n <span class="math inline">\(,其中\)</span>a
_0 <span class="math inline">\(,对于所有的\)</span>k
$,若有下列式子成立:</p>
<p><span class="math display">\[
a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = z _k
\]</span></p>
<p>则称为一个$n <span class="math inline">\(阶线性差分方程(或递归关系).为了简化,通常取\)</span>a
_0 = 1 <span class="math inline">\(.若\)</span>{ z _k }
$是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6>
<p>我们注意到,对于齐次差分方程而言,如果不给定$y <em>0 , y </em>{ n - 1 }
<span class="math inline">\(,只是构造一组满足条件的\)</span>y <span class="math inline">\(的话,自然的想法是令\)</span>y _k = r ^k <span class="math inline">\(.其中\)</span>r <span class="math inline">\(是辅助方程\)</span>a _0 r ^{ n } + a _1 r ^{ n - 1
} + + a _n = 0 $的一个根.</p>
<p>注意到如果我们将上面的内容看作是$T : { y _k } { z _k } <span class="math inline">\(这样一个映射,这显然是一个线性变换.这意味着齐次方程\)</span>a
<em>0 y </em>{ k + n } + a <em>1 y </em>{ k + n - 1 } + + a _n y _k = 0
<span class="math inline">\(的解集就是\)</span>T <span class="math inline">\(的核,设为\)</span>H <span class="math inline">\(,不难发现只要给定\)</span>y <em>0 , y </em>{ n - 1
} <span class="math inline">\(,这个解就唯一确定,将它们看作自由变量,这意味着\)</span>H
= n $.</p>
<p>还没完,注意到我们解方程可以解出$n <span class="math inline">\(个根,如果这\)</span>n <span class="math inline">\(个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了\)</span>y
<em>0 , y </em>{ n - 1 }
$,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这$n <span class="math inline">\(个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的\)</span>
^k $的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共$n
<span class="math inline">\(个线性无关的根,然后拟合初值.我们如此做:对于一个出现了\)</span>m
<span class="math inline">\(次的根\)</span>r <span class="math inline">\(,我们注意到\)</span>r ^k , kr ^k , , k ^{ m - 1 }
r ^k $都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以$kr
^k $作为例子,即证明:</p>
<p><span class="math display">\[
a _0 nr ^n + a _1 ( n - 1 ) r ^{ n - 1  } + \cdots + a _1 r = 0
\]</span></p>
<p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个$r <span class="math inline">\(作为根,必然意味着原方程形如\)</span>( y - r ) ^2 P
<span class="math inline">\(,其中\)</span>P <span class="math inline">\(是一个关于\)</span>y $的多项式.</p>
<p>我们把它写开:$( y ^2 - 2 ry + r ^2 ) P = 0 <span class="math inline">\(,然后我们用\)</span>kr ^k <span class="math inline">\(去代替\)</span>r ^k
$,不难发现代替后右边还是个多项式,而左边变成了$0
$,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
$$
<span class="math display">\[\begin{aligned}
a _0 r ^{ n + k  } + a _1 r ^{ n + k - 1  } + \cdots + a _1 r ^k &amp; =
0 \\
a _0 ( n + k ) r ^{ n + k - 1  } + a _1 ( n + k - 1 ) r ^{ n + k - 2  }
+ \cdots + a _1 kr ^{ k - 1  } &amp; = 0 \\
a _0 ( n + k ) r ^{ n + k  } + a _1 ( n + k - 1 ) r ^{ n + k - 1  } +
\cdots + a _1 kr ^{ k  } &amp; = 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:$( ( y - r ) ^2 P ) ’ = ( y - r ) ( ( y - r ) P
) ’ + ( y - r ) ’ ( y - r ) P = ( y - r ) [ ( y - r ) ’ P + ( ( y - r )
P ) ’ ] <span class="math inline">\(,\)</span>r
$一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6>
<p>我们注意到齐次差分方程一定能写成$ <em>k = A </em>{ k - 1 } <span class="math inline">\(的形式.如果我们取\)</span>A <span class="math inline">\(的特征向量的线性组合作为\)</span> _0
$,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为$1
$的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是$ <em>{ k + 1 } = A <span class="math inline">\(,\)</span> </em>{ n } = A ^n _0 <span class="math inline">\(.而我们又知道CH定理:\)</span>p ( A ) = 0 <span class="math inline">\(,我们用多项式取膜,有\)</span>A ^n = p ( A ) F ( A
) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3>
<h4><span id="和式的基本运算">和式的基本运算</span></h4>
<p>分配律:$\ _{ i S } ca <em>i = c </em>{ i S } a _i \ $.</p>
<p>结合律:$\ _{ i S } ( a _i + b <em>i ) = </em>{ i S } a <em>i + </em>{
i S } b _i $.</p>
<p>交换律:$<em>{ i S } a <em>i = </em>{ p ( i ) S } a </em>{ p ( i ) }
<span class="math inline">\(,其中\)</span>p <span class="math inline">\(是\)</span>S $集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol type="1">
<li><p>$<em>{ i } </em>{ j } a <em>{ i , j } [ P ( i , j ) ] = </em>{ j
} <em>{ i } a </em>{ i , j } [ P ( i , j ) ] $.</p></li>
<li><p>$<em>{ i = 1 } ^n </em>{ j = i } ^n a <em>{ i , j } = </em>{ j =
1 } ^n <em>{ i = 1 } ^j a </em>{ i , j } $.</p></li>
</ol>
<p>一般分配律:$<em>{ i } </em>{ j } a _{ i } b <em>j = ( </em>{ i } a _i
) ( _j b _j ) $.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6>
<p>等差数列求和：</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ( ai + b ) &amp; = \sum _{ i = 0  } ^n
( a ( n - i ) + b ) \\
2 S _n &amp; = \sum _{ i = 0  } ^n ( an + 2 b ) &amp; = an ( n + 1 ) + 2
b ( n + 1 ) \\
S _n &amp; = ( n + 1 ) ( \frac { an  } { 2  } + b )
\end{aligned}
\]</span></p>
<h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6>
<p>令$S = _{ 1 i &lt; j n } ( a _j - a _i ) ( b _j - b <em>i ) = </em>{
1 j &lt; i n } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 j &lt; i n ] + [ 1 i &lt; j n ] = [ 1 j , i n ] - [ 1
i = j n ] $.</p>
<p>那么我们有:</p>
$$
<span class="math display">\[\begin{aligned}
2 S &amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i
) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
&amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i )
\\
&amp; = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i
) ( \sum _{ j = 1  } ^n b _j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>又有$( _{ i = 1 } ^n a <em>i ) ( </em>{ j = 1 } ^n b <em>j ) = n
</em>{ i = 1 } ^n a _i b <em>i - </em>{ 1 i &lt; j n } ( a _j - a _i ) (
b _j - b _i ) $,显然有以下式子:</p>
$$
<span class="math display">\[\begin{aligned}
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) &amp; \leq n
\sum _{ i = 1  } ^n a _i b _i , \forall i &amp; &lt; j , a _i &amp; \leq
a _j \land b _i &amp; \leq b _j \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) &amp; \geq n
\sum _{ i = 1  } ^n a _i b _i , \forall i &amp; &lt; j , a _i &amp; \leq
a _j \land b _i &amp; \geq b _j \\

\end{aligned}\]</span>
<p>$$</p>
<p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6>
<p>即$_{ 1 j &lt; k n } ( a _j b _k - a _k b <em>j ) ^2 = ( </em>{ i = 1
} ^n a <em>i ^2 ) ( </em>{ i = 1 } ^n b <em>i ^2 ) - ( </em>{ i = 1 } ^n
a _i b _i ) ^2 \ $.</p>
<p>令$S <em>n = </em>{ 1 j &lt; k n } ( a _j b _k - a _k b _j ) ^2 \
$,有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S _n &amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a
_k b _j ) ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a
_j a _k b _j b _k - a _k ^2 b _j ^2 ) \\
&amp; = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2
) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ax ^i \\
&amp; = a + \sum _{ i = 1  } ^n ax ^i \\
&amp; = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
&amp; = a + xS _{ n - 1  }
\end{aligned}
\]</span></p>
<p>而$S _{ n - 1 } + ax ^n = S <em>n = a + xS </em>{ n - 1 } <span class="math inline">\(,有\)</span>S _n + ax ^{ n + 1 } = a + xS _n , S
_n = a { x - 1 } <span class="math inline">\(，其中\)</span>x $.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6>
<p>$S <em>n = </em>{ i = 0 } ^n i ^2 $.</p>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
&amp; = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2
\end{aligned}
\]</span></p>
<p>我们无法得到$S <em>n <span class="math inline">\(的封闭形式,但我们发现我们得到了\)</span></em>{ i =
1 } ^n i $的封闭形式.</p>
<p>那以此类推，我们设$W <em>n = </em>{ i = 0 } i ^3 $</p>
<p><span class="math display">\[
\begin{aligned}
W _n &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum
_{ i = 1  } ^n i - n + n ^3 \\
&amp; = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n &amp; = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
&amp; = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
&amp; = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
&amp; = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  }
\end{aligned}
\]</span></p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h6><span id="example1平方和公式">Example1(平方和公式)</span></h6>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ k = 1  } ^n k ^2 \\
&amp; = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
&amp; = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 )
\\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 -
ni + n ) \\
&amp; = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  }
^n i ^2 + n ^3 + n ^2 ) \\
&amp; = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n +
\frac { n ^3 + n ^2  } { 2  }
\end{aligned}
\]</span></p>
<p>整理得到$S _n $.</p>
<h6><span id="example2">Example2</span></h6>
<p>求$_{ i = 1 } ^n i ^3 \ $.</p>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum _{ i = 1  } ^n i ^3 \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
&amp; = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  }
- \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
&amp; = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } {
3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n (
n + 1 )  } { 12  } \\
S ( n ) &amp; = \frac { n ^2 ( n + 1 ) ^2  } { 4  }
\end{aligned}
\]</span></p>
<h5><span id="problme3">Problme3</span></h5>
<p>求$_{ i = 1 } ^n iq ^i ( q ) $.</p>
<h5><span id="solution3">Solution3</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n iq ^i &amp; = \sum _{ j = 1  } ^n \sum _{ i = j  }
^n q ^i \\
&amp; = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  }
\\
&amp; = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q
^j ) \\
&amp; = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  }
- q  } { q - 1  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="problemex2">ProblemEX2</span></h5>
<p>求$_{ i = 1 } ^n ( ai + b ) q ^{ i - 1 } ( q ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令$A = { q - 1 } , B = { q - 1 } <span class="math inline">\(,答案为\)</span>( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子$E <span class="math inline">\(，使得\)</span>Ef ( x ) =
f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子$f ( x ) = f ( x + 1 ) - f ( x )
$，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$= E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子$$,可以得到有限微积分的基本定理:</p>
<p>$g ( x ) = f ( x ) g ( x ) x = f ( x ) + C \ $</p>
<p>这里的$<span class="math inline">\(又被称为不定和式,是差分等于\)</span>g
$的一个函数类.</p>
<p>值得一提的是,这里的$C <span class="math inline">\(与无限微积分中的\)</span>C <span class="math inline">\(有一定区别,这里的\)</span>C <span class="math inline">\(可以是满足\)</span>p ( x ) = p ( x + 1 )
$的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果$g ( x ) = f ( x ) <span class="math inline">\(,那么有\)</span>_{
a } ^b g ( x ) x = f ( x ) | ^{ b } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a b <span class="math inline">\(,显然有\)</span><em>{ a } ^b g ( x ) x = </em>{ x
= a } ^{ b - 1 } g ( x ) \ $.</p>
<p>但如果$a &gt; b <span class="math inline">\(,那么\)</span>_{ a } ^b g
( x ) x = - _b ^a g ( x ) x \ $.</p>
<p>事实上,我们一定有:$_a ^b g ( x ) x + _b ^c g ( x ) x = _a ^c g ( x )
x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1 } $，有:</p>
<p>(x<sup>{})=mx</sup>{}，mx<sup>{}x=x</sup>{}+C，m\</p>
<p>\</p>
<p>类比无限微积分中的$D ( x ) = { x } $，有:</p>
<p>令H(x)=_{i=1}<sup>x\(H(x))=x</sup>{}，x^{}x =H(x)+C\</p>
<p>\</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<p>$( 2 ^x ) = 2 ^x ， ^x x = 2 ^x + C \ $</p>
<p>$( c ^x ) = ( c - 1 ) c ^x ， c ^x x = { c - 1 } + C , c \ $</p>
<p>$( c ^{ } ) = { c - x } , { c - x } x = c ^{ } + C , c - x \ $.</p>
<p>根据组合数公式,有:</p>
<p>$( { k } ) = { k - 1 } \ $.</p>
<h6><span id="example1">Example1</span></h6>
<p>仍然考虑平方和公式：</p>
<p>我们有:$k ^2 = k ^{ } + k ^{ } \ $.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S _{ n - 1  } &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
&amp; = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{
\underline { 1  }  } ) \\
&amp; = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x +
\sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
&amp; = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline
{ 2  }  }  } { 2  }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v &amp; = Ev \Delta u + u
\Delta v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p>$u v = uv - Ev u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p>$<em>{ i = l } ^{ r - 1 } ( a </em>{ i + 1 } - a _i ) b _i = a _r b
<em>r - a <em>l b <em>l - </em>{ i = l } ^{ r - 1 } a </em>{ i + 1 } ( b
</em>{ i + 1 } - b _i ) \ $.</p>
<h6><span id="example1">Example1</span></h6>
<p>求$_{ k = 0 } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$x 2 ^x x = x 2 ^x - ^{ x + 1 } x = x 2 ^x - 2 ^{ x + 1 } + C \
$.</p>
<p>改为定和式形式，显然有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^n k 2 ^k \\
&amp; = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x \\
&amp; = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 \\
&amp; = ( n - 1 ) 2 ^{ n + 1  } + 2 \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="example2">Example2</span></h6>
<p>求$_{ k = 0 } ^{ n - 1 } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = { 2 } x ^{ } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$xH _x x = { 2 } H _x - { 4 } + C \ $.</p>
<p>带入即可求出原式$= { 2 } ( H _n - { 2 } ) \ $.</p>
<h6><span id="example3">Example3</span></h6>
<p>求$_{ i = 1 } ^n { i ( i + 1 ) } \ $.</p>
<p>令$u = ( 2 n + 1 ) , v = - { i } <span class="math inline">\(,则\)</span>u = 2 , v = { i ( i + 1 ) } $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } &amp; = ( 2 n +
3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( -
\frac { 2  } { i + 1  } ) \\
&amp; = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n
+ 1  } \\
&amp; = 2 H _n - \frac { n  } { n + 1  }
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>求$_{ i = 0 } ^{ n - 1 } { ( k + 1 ) ( k + 2 ) } \ $.</p>
<p>令$u = H _n , v = - { n + 1 } , u = { n + 1 } , v = { ( n + 1 ) ( n +
2 ) } \ $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  }
&amp; = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( -
\frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } (
\frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  }
{ n + 1  } ) \\
&amp; = 1 - \frac { H _n + 1  } { n + 1  }
\end{aligned}
\]</span></p>
<h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3>
<h5><span id="example">Example</span></h5>
<p>令$A = { 2 n - 1 | n <em>{ + } } , B = { 3 n - 1 | n </em>{ + } }
<span class="math inline">\(.求\)</span>A B <span class="math inline">\(,以及\)</span>A B $的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
$$
<span class="math display">\[\begin{aligned}
a \in A \Leftrightarrow a &amp; \equiv - 1 \pmod { 2  } \\
b \in B \Leftrightarrow b &amp; \equiv - 1 \pmod { 6  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以$A B = { 6 n - 1 | n _{ + } } $.</p>
<p>而同理,$x A B x - 1 / - 2 / - 3 / - 5 $.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3>
<p>设$A = { x | x = 2 n - 1 , n <em>+ } , B = { x | x = 2 ^n , n </em>+
} <span class="math inline">\(,现在将\)</span>A B <span class="math inline">\(中的元素排序并提取成一个数列\)</span>a <span class="math inline">\(,求使得\)</span>S _n &gt; 12 a _n <span class="math inline">\(最小的正整数\)</span>n $.</p>
<p>写出数列,它长这样:</p>
<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 \\
3 &amp; 4 \\
5 &amp; 7 &amp; 8 \\
9 &amp; 11 &amp; 13 &amp; 15 &amp; 16 \\
&amp; &amp; \cdots
\end{matrix}
\]</span></p>
<p>不妨设$n <span class="math inline">\(在第\)</span>r <span class="math inline">\(行\)</span>c <span class="math inline">\(列,显然\)</span>( r , c ) <span class="math inline">\(和\)</span>n $构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的$n <span class="math inline">\(能快速表达\)</span>( r , c )
$,要么反之.显然反之比较简单.</p>
<p>考虑设前$k <span class="math inline">\(行共有\)</span>W <em>k <span class="math inline">\(个数,不难发现\)</span>W </em>{ k + 1 } = W _k + 2
^{ k - 1 } + 1 , W _k = 2 ^{ k - 1 } + k $.</p>
<p>显然,对于$( r , c ) <span class="math inline">\(来说,它对应的\)</span>n <span class="math inline">\(就是\)</span>W _{ r - 1 } + c $.</p>
<p>令$SR _{ r } <span class="math inline">\(为前\)</span>r <span class="math inline">\(行数字之和,不难发现\)</span>SR _r = 2 ^{ r + 1 } -
2 + ( 2 ^{ r - 1 } ) ^2 $.</p>
<p>接下来考虑找到这个最小的$n <span class="math inline">\(,显然\)</span>r <span class="math inline">\(,接下来只考虑\)</span>r $的情况.</p>
<p>那么我们可以轻松写出$S _n <span class="math inline">\(和\)</span>a _n
$的表达式,下面直接给出:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = SR _{ r - 1  } + \sum _{ k = 1  } ^c ( 2 ^{ r - 1  } + 2 k
- 1 ) - [ c &amp; = 2 ^{ r - 2  } + 2 ] \\
S _n &amp; = 2 ^r - 2 + 4 ^{ r - 2  } + 2 ^{ r - 1  } c + c ^2 - [ c
&amp; = 2 ^{ r - 2  } + 1 ] \\
a _n &amp; = 2 ^{ r - 1  } + 2 c - 1 - [ c &amp; = 2 ^{ r - 2  } + 1 ]
\end{aligned}
\]</span></p>
<p>讨论一下$[ c = 2 ^{ r - 2 } + 1 ] $这个判定式取$0 $还是取$1
$,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3>
<h2><span id="几何导论">几何导论</span></h2>
<h3><span id="三角相关">三角相关</span></h3>
<h4><span id="三角恒等变换">三角恒等变换</span></h4>
<h5><span id="两角和差公式">两角和差公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin ( A + B ) &amp; = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) &amp; = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) &amp; = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) &amp; = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) &amp; = \frac { \tan A + \tan B  } { 1 - \tan A \tan B  }
\\
\tan ( A - B ) &amp; = \frac { \tan A - \tan B  } { 1 + \tan A \tan B  }
\end{aligned}
\]</span></p>
<h5><span id="倍角公式">倍角公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\tan ( 2 A ) &amp; = \frac { 2 \tan A  } { 1 - \tan ^2 A  } \\
\sin ( 2 A ) &amp; = 2 \sin A \cos A \\
\cos ( 2 A ) &amp; = \cos ^2 A - \sin ^2 A &amp; = 2 \cos ^2 A - 1 &amp;
= 1 - 2 \sin ^2 A
\end{aligned}
\]</span></p>
<h5><span id="半角公式">半角公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin ( \frac { A  } { 2  } ) &amp; = \pm \sqrt { \frac { 1 - \cos A  } {
2  }  } \\
\cos ( \frac { A  } { 2  } ) &amp; = \pm \sqrt { \frac { 1 + \cos A  } {
2  }  } \\
\tan ( \frac { A  } { 2  } ) &amp; = \frac { \sin A  } { 1 + \cos A  }
&amp; = \frac { 1 - \cos A  } { \sin A  } &amp; = \pm \sqrt { \frac { 1
- \cos A  } { 1 + \cos A  }  }
\end{aligned}
\]</span></p>
<h5><span id="和差化积">和差化积</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin A + \sin B &amp; = 2 \sin ( \frac { A + B  } { 2  } ) \cos ( \frac
{ A - B  } { 2  } ) \\
\sin A - \sin B &amp; = 2 \cos ( \frac { A + B  } { 2  } ) \sin ( \frac
{ A - B  } { 2  } ) \\
\cos A + \cos B &amp; = 2 \cos ( \frac { A + B  } { 2  } ) \cos ( \frac
{ A - B  } { 2  } ) \\
\cos A - \cos B &amp; = - 2 \sin ( \frac { A + B  } { 2  } ) \sin (
\frac { A - B  } { 2  } ) \\
\tan A + \tan B &amp; = \frac { \sin ( A + B )  } { \cos A \cos B  }
\end{aligned}
\]</span></p>
<p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<p><span class="math display">\[
\sin ^2 A - \sin ^2 B = \sin ( A - B ) \sin ( A + B )
\]</span></p>
<p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin A \sin B &amp; = - \frac { 1  } { 2  } [ \cos ( A + B ) - \cos ( A
- B ) ] \\
\cos A \cos B &amp; = \frac { 1  } { 2  } [ \cos ( A + B ) + \cos ( A -
B ) ] \\
\sin A \cos B &amp; = \frac { 1  } { 2  } [ \sin ( A + B ) + \sin ( A -
B ) ] \\
\cos A \sin B &amp; = \frac { 1  } { 2  } [ \sin ( A + B ) - \sin ( A -
B ) ]
\end{aligned}
\]</span></p>
<h5><span id="万能公式">万能公式</span></h5>
<p>令$w = { 2 } $,则:</p>
<p><span class="math display">\[
\begin{aligned}
\sin A &amp; = \frac { 2 w  } { 1 + w ^2  } \\
\cos A &amp; = \frac { 1 - w ^2  } { 1 + w ^2  } \\
\tan A &amp; = \frac { 2 w  } { 1 - w ^2  }
\end{aligned}
\]</span></p>
<p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<p><span class="math display">\[
\begin{aligned}
\cos ( x ) &amp; = \frac { e ^{ ix  } + e ^{ - ix  }  } { 2  } \\
\sin ( x ) &amp; = \frac { e ^{ ix  } - e ^{ - ix  }  } { 2 i  }
\end{aligned}
\]</span></p>
<h5><span id="补充公式">补充公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
1 + \sin A &amp; = ( \sin \frac { A  } { 2  } + \cos \frac { A  } { 2  }
) ^2 \\
1 - \sin A &amp; = ( \sin \frac { A  } { 2  } - \cos \frac { A  } { 2  }
) ^2
\end{aligned}
\]</span></p>
<h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4>
<p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的$k
$来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6>
<p>已知函数$f ( x ) = ( x + ) , w &gt; 0 <span class="math inline">\(,\)</span>f ( - { 6 } ) = 0 , f ( { 2 } ) = - 1
<span class="math inline">\(,求\)</span>w <span class="math inline">\(和\)</span>$的表达式.</p>
<p>正确做法应该是强设$k _1 , k _2 $,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的$<span class="math inline">\(和\)</span>$都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令$ { 2 } $为单位$1 $,我们必有以下式子:</p>
<p><span class="math display">\[
\begin{aligned}
- \frac { \omega  } { 3  } + \varphi &amp; \equiv 0 \pmod { 2  } \\
\omega + \varphi &amp; \equiv 3 \pmod { 4  }
\end{aligned}
\]</span></p>
<p>下面推导$$,首先将上面两个式子直接相减,立有:</p>
<p><span class="math display">\[
\frac { 4  } { 3  } \omega \equiv 1 \pmod { 2  }
\]</span></p>
<p>对于$$,考虑类似的做法,将第一个式子乘以$3
$后与第二个式子相加,立有:</p>
<p><span class="math display">\[
4 \varphi \equiv 1 \pmod { 2  }
\]</span></p>
<p>这样我们得到的必须满足的条件就有以下几条:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 4  } { 3  } \omega &amp; \equiv 1 \pmod { 2  } \\
4 \varphi &amp; \equiv 1 \pmod { 2  } \\
\omega + \varphi &amp; \equiv 3 \pmod { 4  }
\end{aligned}
\]</span></p>
<h3><span id="向量相关">向量相关</span></h3>
<h4><span id="旋转模型">旋转模型</span></h4>
<p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6>
<p>已知$AB = 2 , AC = 1 , A = <span class="math inline">\(,\)</span>BC
<span class="math inline">\(绕\)</span>B <span class="math inline">\(点顺时针旋转\)</span> { 3 } <span class="math inline">\(得到\)</span>BD <span class="math inline">\(,求以\)</span><span class="math inline">\(表示\)</span>S _{ CBD } $.</p>
<p>先来说文化课做法,我们直接表示$S <span class="math inline">\(,令\)</span>= ABC $:</p>
$$
<span class="math display">\[\begin{aligned}
S &amp; = | BD | \sin ( \alpha + \frac { \pi  } { 3  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于这个式子,我们发现如果我们能得到$| BD | ( ) <span class="math inline">\(和\)</span>| BD | ( ) $就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现$BD <span class="math inline">\(是\)</span><span class="math inline">\(的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出\)</span>|
BD | <span class="math inline">\(,余弦定理可以帮助我们求出\)</span>| BD
| $.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出$ <span class="math inline">\(和\)</span>
<span class="math inline">\(的坐标表示,将\)</span>
$用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4>
<p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol type="1">
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p></li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作$1
$是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p></li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6>
<p>$ABC <span class="math inline">\(中,\)</span>b ^2 = ac <span class="math inline">\(,点\)</span>D <span class="math inline">\(在\)</span>AC <span class="math inline">\(上且满足\)</span>BD = b <span class="math inline">\(,有\)</span> = 2 <span class="math inline">\(,求\)</span>ABC $.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定$c = 1 <span class="math inline">\(,于是有\)</span>b ^2 = a $.</p>
<p>考虑我们要求$ABC <span class="math inline">\(,而我们有一条很奇怪的边\)</span>BD <span class="math inline">\(,似乎不满足任何性质,我们立刻想到要把它用\)</span>ABC
$的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让$c = 1
$,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4>
<h5><span id="奔驰定理">奔驰定理</span></h5>
<p>对于$ABC <span class="math inline">\(内一点\)</span>P <span class="math inline">\(,立有\)</span>S <em>{ PBC } + S </em>{ PAC } + S
_{ PAB } = $.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令$a
= PA , b = PB , c = PC $,我们要证奔驰定理,也就是要证明:</p>
$$
<span class="math display">\[\begin{aligned}
bc \sin \alpha \overrightarrow { PA  } + ac \sin \beta \overrightarrow {
PB  } + ab \sin \gamma \overrightarrow { PC  } &amp; = \vec { 0  } \\
abc \sin \alpha \frac { \overrightarrow { PA  }  } { a  } + abc \sin
\beta \frac { \overrightarrow { PB  }  } { b  } + abc \sin \gamma \frac
{ \overrightarrow { PC  }  } { c  } &amp; = \vec { 0  } \\
\sin \alpha \frac { \overrightarrow { PA  }  } { a  } + \sin \beta \frac
{ \overrightarrow { PB  }  } { b  } + \sin \gamma \frac {
\overrightarrow { PC  }  } { c  } &amp; = \vec { 0  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑$| { a } | = | { b } | = | { c } | = 1
$,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5>
<p>有正弦定理,$| | = | | = | | = { 2 A } $.</p>
<p>考虑三个三角形的面积可以表示为$ { 2 } <span class="math inline">\(,又考虑到圆中的\)</span><span class="math inline">\(是圆心角是圆周角的两倍,立有\)</span>( 2 A ) + ( 2
B ) + ( 2 C ) = $.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6>
<p>在$ABC <span class="math inline">\(中,\)</span>AB = 2 , BC = , AC = 3
<span class="math inline">\(,若\)</span>O <span class="math inline">\(是其外心,且\)</span> = p + q $.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用$| OA | = | OB
| = | OC | <span class="math inline">\(,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于\)</span>p
, q $的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了$| OA | <span class="math inline">\(,用上\)</span>| OB
| <span class="math inline">\(,这样的话我们两边同时加上\)</span> <span class="math inline">\(,就可以得到\)</span>p , q <span class="math inline">\(的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据\)</span>|
OC | $也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow { AO  } &amp; = p \overrightarrow { AB  } + q
\overrightarrow { AC  } \\
\vec { 0  } &amp; = ( p + q - 1 ) \overrightarrow { OA  } + p
\overrightarrow { OB  } + q \overrightarrow { OC  }
\end{aligned}
\]</span></p>
<p>考察奔驰定理,立有$ { ( 2 A ) } = { ( 2 B ) } = { ( 2 C ) }
$,简单题.</p>
<h6><span id="example2">Example2</span></h6>
<p>已知相异两点$O , H <span class="math inline">\(分别为\)</span>ABC
<span class="math inline">\(的外心和垂心,若\)</span> = m ( + + ) <span class="math inline">\(,求\)</span>m $.</p>
<p>这题要用到的性质是,我们一定要知道$( + ) = 0
$,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出$ <span class="math inline">\(,然后两边同时乘以\)</span> <span class="math inline">\(就可以解决.注意到最后解方程的时候要么\)</span>m =
1 <span class="math inline">\(,要么三角形等边,但是我们声明过\)</span>O ,
H $相异两点.</p>
<h5><span id="重心">重心</span></h5>
<p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的$1
: 2 $的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若$O <span class="math inline">\(是重心,则必有\)</span> + + = $.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5>
<p>若$O <span class="math inline">\(是重心,立有\)</span> = 0 <span class="math inline">\(,将\)</span> = + <span class="math inline">\(,立有\)</span> = =
$.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有$ A + B + C = $.</p>
<h5><span id="内心">内心</span></h5>
<p>根据奔驰定理,立有$a + b + c = $.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3>
<h4><span id="基本概念">基本概念</span></h4>
<h5><span id="直线">直线</span></h5>
<p>使用直线的方向向量$ = ( n , m , p ) <span class="math inline">\(和直线上一点\)</span>M _0 = ( x _0 , y _0 , z _0 )
$.那么方程显然为:</p>
<p><span class="math display">\[
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z
_0  } { p  }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt
\end{cases}
\]</span></p>
<h5><span id="平面">平面</span></h5>
<p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) <span class="math inline">\(和该平面的法向量\)</span> <span class="math inline">\(来表示一个平面,不妨设\)</span> = ( A , B , C )
$,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0
\]</span></p>
<p>如果我们令$D = - ( Ax _0 + By <em>0 + Cz </em>) $,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h5><span id="夹角">夹角</span></h5>
<h6><span id="两直线夹角">两直线夹角.</span></h6>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$ = ( n _1 , m _1 , p _1 ) , = ( n _2 , m _2 , p _2
) <span class="math inline">\(,也就有\)</span>= ( { | _1 | | _2 | } ) \
$.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6>
<p>同样使用向量,不妨设方向向量$ = ( n , m , p ) <span class="math inline">\(,法向量\)</span> = ( a , b , c ) <span class="math inline">\(,那么\)</span>= ( { | | | | } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p></li>
<li><p>若直线与平面垂直,则$ { m } = { n } = { p }
$.注意这里分母可能除以$0 <span class="math inline">\(,我们实际上应该是三个形如\)</span>a = mt
$的参数方程,这里简化了.</p></li>
</ol>
<h5><span id="交点">交点</span></h5>
<p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3>
<h4><span id="约定">约定</span></h4>
<p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可($mx
+ ny = 1 <span class="math inline">\(需要判断过原点的直线,\)</span>y =
kx + b <span class="math inline">\(需要判断平行于\)</span>y
$轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点$F _1 , F _2 <span class="math inline">\(距离之和为常数(\)</span>&gt; | F _1 F _2 | <span class="math inline">\()的点轨迹.即:\)</span>{ P | F _1 P | + | F _2 P |
= 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线($x = { c } <span class="math inline">\()的距离比是常数\)</span>e = { a } <span class="math inline">\(的点轨迹,即\)</span>{ P { d _1 } = { d _2 } = { a
} = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) <span class="math inline">\(的斜率乘积等于定值\)</span>e ^2 - 1
$的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5>
<h6><span id="标准方程">标准方程</span></h6>
<p>由定义不难得到椭圆的标准方程:$ { a ^2 } + { b ^2 } = 1 ( b ^2 = a ^2
- c ^2 , a &gt; b &gt; 0 ) $.</p>
<h6><span id="一般方程">一般方程</span></h6>
<p>$nx ^2 + my ^2 = 1 ( n , m ) <span class="math inline">\(,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下\)</span>n
<span class="math inline">\(和\)</span>m $的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若$P ( x _0 , y _0 ) <span class="math inline">\(,则\)</span>| PF _1
| = a + ex _0 <span class="math inline">\(,\)</span>| PF _2 | = a - ex
_0 $.</p>
<h6><span id="焦点弦">焦点弦</span></h6>
<p>过$F _1 <span class="math inline">\(的弦\)</span>| AB | = 2 a + e ( x
_1 + x _2 ) $.</p>
<p>过$F _2 <span class="math inline">\(的弦\)</span>| AB | = 2 a - e ( x
_1 + x _2 ) $.</p>
<p>注意到焦点弦最短时$x _1 = x _2 $.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即$PF _1 F _2 <span class="math inline">\(,令\)</span>= F _1 PF _2
$,有以下性质:</p>
<ol type="1">
<li><p>$C = 2 a + 2 c $.</p></li>
<li><p>$S = b ^2 { 2 } = c | y _P | $.</p></li>
<li><p>$ - 2 e ^2 <span class="math inline">\((当\)</span>P
$在短轴上取等).</p></li>
<li><p>$| PF _1 | | PF _2 | = { 1 + } $.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>已知椭圆$ { a ^2 } + { b ^2 } = 1 <span class="math inline">\(,\)</span>P <span class="math inline">\(是椭圆上一点,\)</span>F _1 PF _2 <span class="math inline">\(的角平分线交\)</span>x <span class="math inline">\(轴于\)</span>Q ( { 4 } , 0 )
$,求离心率取值范围.</p>
<p>注意到$S _{ QPF <em>1 } = { 3 } S </em>{ QPF _2 } <span class="math inline">\(,又有\)</span>Q <span class="math inline">\(到\)</span>PF _1 <span class="math inline">\(和\)</span>PF _2 <span class="math inline">\(的距离相等,用等积法,显然\)</span>PF _1 = { 4 } a ,
PF _2 = { 4 } a $.</p>
<p>然后用三角形不等式做差就行.$2 c &gt; { 2 } a , { 4 } &lt; e $</p>
<h4><span id="双曲线">双曲线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点$F _1 , F _2 <span class="math inline">\(距离之差为常数(\)</span>&gt; | F _1 F _2 | <span class="math inline">\()的点轨迹.即:\)</span>{ P | | F _1 P | - | F _2 P
| | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线($x = { c } <span class="math inline">\()的距离比是常数\)</span>e = { a } <span class="math inline">\(的点轨迹,即\)</span>{ P { d _1 } = { d _2 } = { a
} = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) <span class="math inline">\(的斜率乘积等于定值\)</span>e ^2 - 1
$的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若$P ( x _0 , y _0 ) , ( x _0 &gt; 0 ) <span class="math inline">\(,则\)</span>| PF _1 | = a + ex _0 <span class="math inline">\(,\)</span>| PF _2 | = - a + ex _0 $.</p>
<h6><span id="渐近线">渐近线</span></h6>
<p>$y = { a } x $.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成$0
$得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即$PF _1 F _2 <span class="math inline">\(,令\)</span>= F _1 PF _2
$,有以下性质:</p>
<ol type="1">
<li>$S = { { 2 } } $.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5>
<h6><span id="焦点弦">焦点弦</span></h6>
<p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线$AB <span class="math inline">\(为过\)</span>y ^2 = 2 px ( p &gt;
0 ) <span class="math inline">\(焦点的弦,\)</span>A ( x _1 , y _1 ) , B
( x _2 , y _2 ) <span class="math inline">\(,倾斜角为\)</span><span class="math inline">\(,准线与\)</span>x <span class="math inline">\(轴交点为\)</span>E ( - { 2 } , 0 ) <span class="math inline">\(,作\)</span>AA _1 <span class="math inline">\(,\)</span>BB _1 <span class="math inline">\(垂直于准线于\)</span>A _1 , B _1 $,则:</p>
<ol type="1">
<li><p>$| AF | = x _1 + { 2 } <span class="math inline">\(,\)</span>| BF
| = x _2 + { 2 } <span class="math inline">\(,\)</span>| AB | = x _1 + x
_2 + p , { | FA | } + { | FB | } = { p } $.</p></li>
<li><p>$| AF | = { 1 - } , | BF | = { 1 + } , | AB | = { ^2 }
$.</p></li>
<li><p>$x _1 x _2 = { 4 } <span class="math inline">\(,\)</span>y _1 y
_2 = - p ^2 $.</p></li>
<li><p>$S _{ AOB } = { 2 } $.</p></li>
<li><p>$k <em>{ AE } + k </em>{ BE } = 0 $.</p></li>
<li><p>$A , O , B _1 <span class="math inline">\(三点共线,\)</span>B , O
, A _1 $三点共线.</p></li>
<li><p>以$AB $为直径的圆与抛物线的准线相切.</p></li>
<li><p>以$A _1 B _1 <span class="math inline">\(为直径的圆与\)</span>AB
$相切.</p></li>
<li><p>以$AF <span class="math inline">\(或\)</span>BF <span class="math inline">\(为直径的圆与\)</span>y $轴相切.</p></li>
</ol>
<h4><span id="通用解法">通用解法</span></h4>
<h5><span id="联立方程">联立方程</span></h5>
<h6><span id="点参">点参</span></h6>
<p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线$l <span class="math inline">\(上有两点\)</span>N ( x _1 , y
_1 ) , M ( x _2 , y _2 ) <span class="math inline">\(,这条直线的斜率为\)</span>k <span class="math inline">\(,那么\)</span>| NM | = | x _1 - x _2 | = | y _1 -
y _2 | $.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) <span class="math inline">\(,其中点\)</span>M ( x _0 , y _0 ) $,有$2 x _0 = x
_1 + x _2 , 2 y _0 = y _1 + y _2 $.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线$l <span class="math inline">\(与曲线交于两点\)</span>N ( x
_1 , y _1 ) , M ( x _2 , y _2 ) <span class="math inline">\(,这条直线的斜率为\)</span>k <span class="math inline">\(,\)</span>MN <span class="math inline">\(的中点为\)</span>P ( x _0 , y _0 ) $,那么:</p>
<ol type="1">
<li><p>在椭圆$ { a ^2 } + { b ^2 } = 1 ( a &gt; b &gt; 0 ) <span class="math inline">\(中,\)</span>k { x _0 } = - { a ^2 } = e ^2 - 1
$.</p></li>
<li><p>在双曲线$ { a ^2 } - { b ^2 } = 1 <span class="math inline">\(中,\)</span>k { x _0 } = { a ^2 } = e ^2 - 1
$.</p></li>
<li><p>在抛物线$y ^2 = 2 px ( p &gt; 0 ) <span class="math inline">\(中,\)</span>k = { y _0 } = { p } $.</p></li>
</ol>
<h6><span id="小联立">小联立</span></h6>
<p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6>
<p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线$PA <span class="math inline">\(,\)</span>PB <span class="math inline">\(,我们可以将公共点\)</span>P <span class="math inline">\(平移至原点,这样\)</span>PA <span class="math inline">\(和\)</span>PB <span class="math inline">\(的方程都方便表达.然后设\)</span>AB <span class="math inline">\(的方程为\)</span>mx + ny = 1
$(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以$mx
+ ny <span class="math inline">\(,零次项乘以\)</span>( mx + ny ) ^2
<span class="math inline">\(,这样就得到了一个齐次式子.将两边同时除以\)</span>x
^2 <span class="math inline">\(后就得到了一个和\)</span>k = { x }
$有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的$x _1 x _2 <span class="math inline">\(和\)</span>x _1 + x _2 $之间的关系来做.</p>
<p>当然还有一种情况是问形如$ { Cx _1 + Dx _2 } <span class="math inline">\(是定值的问题,这个时候一定有\)</span> { C } = { D }
$.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令$w = { x _2 } <span class="math inline">\(,自然有\)</span>w + { w } + 2 = { x _1 x _2 }
$.</p>
<p>还比如有$y _2 = ny _1 + m <span class="math inline">\(,我们可以用配凑技巧改写作\)</span>( y _2 + w ) = k
( y _1 + w ) <span class="math inline">\(,也就有\)</span> { y _1 + w } =
k $,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线$y = kx + <span class="math inline">\(与曲线\)</span> { m } + {
n } = 1 <span class="math inline">\(相交于\)</span>A ( x _1 , y _1 )
<span class="math inline">\(和\)</span>B ( x _2 , y _2 ) $.</p>
<p>那么联立方程是:$( n + mk ^2 ) x ^2 + 2 k mx + m ( ^2 - n ) = 0 $.</p>
<p>判别式:$= 4 mn ( n + mk ^2 - ^2 ) $.</p>
<p>韦达定理:</p>
<p><span class="math display">\[
\begin{aligned}
x _1 + x _2 &amp; = \frac { - 2 km \varphi  } { n + mk ^2  } \\
x _1 x _2 &amp; = \frac { m ( \varphi ^2 - n )  } { n + mk ^2  } \\
| x _1 - x _2 | &amp; = \frac { \sqrt { \Delta  }  } { n + mk ^2  }
\end{aligned}
\]</span></p>
<h6><span id="配凑法">配凑法</span></h6>
<p>参考:https://zhuanlan.zhihu.com/p/521025768.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6>
<p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线$y ^2 = 4 x <span class="math inline">\(,若\)</span>A , B
<span class="math inline">\(位于抛物线上\)</span>x <span class="math inline">\(轴上方不同的两点,直线\)</span>OA , OB <span class="math inline">\(的斜率分别为\)</span>k _1 , k _2 <span class="math inline">\(,且满足\)</span>k _1 k _2 - 4 = 4 k _1 + 4 k <em>2
<span class="math inline">\(,求证:\)</span>AB <span class="math inline">\(过定点,并求出\)</span>k </em>{ AB }
$的取值范围.</p>
<p>注意到$k _1 <span class="math inline">\(和\)</span>k _2
$之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设$AB : y = kx + b <span class="math inline">\(,则\)</span>A ( x _1 ,
kx _1 + b ) , B ( x _2 , kx _2 + b ) <span class="math inline">\(,显然\)</span>k _1 = k + { x _1 } , k _2 = k + { x
_2 } $.</p>
<p>直接带入方程,有:</p>
$$
<span class="math display">\[\begin{aligned}
( k + \frac { b  } { x _1  } ) ( k + \frac { b  } { x _2  } ) - 4 &amp;
= 4 ( 2 k + \frac { b  } { x _1  } + \frac { b  } { x _2  } ) \\
k ^2 + kb ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) + \frac {
b ^2  } { x _1 x _2  } - 4 &amp; = 8 k + 4 b ( \frac { 1  } { x _1  } +
\frac { 1  } { x _2  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而直接大联立得到的式子是:</p>
<p><span class="math display">\[
\begin{aligned}
k ^2 x ^2 + ( 2 kb - 4 ) x + b ^2 &amp; = 0 \\
\Delta &amp; = 16 - 16 kb &amp; &gt; 0 , kb &amp; &lt; 1 \\
x _1 x _2 &amp; = \frac { b ^2  } { k ^2  } , x _1 + x _2 &amp; = \frac
{ 4 - 2 kb  } { k ^2  } , \frac { 1  } { x _1  } + \frac { 1  } { x
_2  } &amp; = \frac { 4 - 2 kb  } { b ^2  }
\end{aligned}
\]</span></p>
<p>带入,得到$k - b = 4 <span class="math inline">\(,因此过定点\)</span>(
- 1 , - 4 ) <span class="math inline">\(,与\)</span>kb &lt; 1 <span class="math inline">\(联立得到\)</span>k &lt; 2 + $.</p>
<p>还没完,这种题一定要检查一遍条件.注意到$AB <span class="math inline">\(为\)</span>x <span class="math inline">\(轴上方两点的性质没用到,这意味着\)</span>y _1 y _2
&gt; 0 y _1 + y _2 &gt; 0 $,带入方程得到:</p>
<p><span class="math display">\[
\begin{aligned}
b ^2 + b ( \frac { 4 - 2 kb  } { k  } ) + b ^2 &amp; &gt; 0 \\
\frac { 4 - 2 kb  } { k  } + 2 b &amp; &gt; 0
\end{aligned}
\]</span></p>
化简得到$
<span class="math display">\[\begin{cases}b &gt; 0 \\ k &gt; 0
\end{cases}\]</span>
<p><span class="math inline">\(,解得\)</span>k &gt; 4 <span class="math inline">\(,于是\)</span>k ( 4 , 2 + ) $.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,$OA <span class="math inline">\(和\)</span>OB
$的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<p><span class="math display">\[
\begin{aligned}
k _{ OA  } &amp; = \frac { y _1  } { x _1  } , k _{ OB  } &amp; = \frac
{ y _2  } { x _2  } \\
\frac { y _1 y _2  } { x _1 x _2  } - 4 &amp; = 4 ( \frac { y _1  } { x
_1  } + \frac { y _2  } { x _2  } ) \\
16 - 4 y _1 y _2 &amp; = 16 ( y _1 + y _2 )
\end{aligned}
\]</span></p>
<p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<p><span class="math display">\[
\begin{aligned}
AB : \\
x - x _1 &amp; = ( y - y _1 ) \frac { x 1 - x _2  } { y _1 - y _2  } \\
x - \frac { y _1 ^2  } { 4  } &amp; = ( y - y _1 ) \frac { 1  } { 4  } (
y _1 + y _2 ) \\
x &amp; = \frac { y _1 + y _2  } { 4  } y - \frac { y _1 y _2  } { 4  }
\\
x &amp; = \frac { y _1 + y _2  } { 4  } y - 1 + ( y _1 + y _2 )
\end{aligned}
\]</span></p>
<p>显然过定点$( - 1 , - 4 ) <span class="math inline">\(,并且通过\)</span>y _1 <span class="math inline">\(和\)</span>y _2 $的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个$ { x _1 - x _2 } = { y _1 - y
_2 }
$的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆$ { 4 } + y ^2 = 1 <span class="math inline">\(,\)</span>P ,
Q <span class="math inline">\(在椭圆上,\)</span>A ( 2 , 0 ) <span class="math inline">\(,\)</span>k <em>{ AP } k </em>{ AQ } = { 20 }
<span class="math inline">\(,求证:\)</span>PQ $过定点.</p>
<p>注意到$A ( 2 , 0 ) <span class="math inline">\(,设\)</span>P ( x _1 ,
y _1 ) , Q ( x _2 , y _2 ) <span class="math inline">\(,\)</span>PQ : m
( x - 2 ) + yn = 1 <span class="math inline">\(,那么我们要求的也就是\)</span>x - 2 <span class="math inline">\(和\)</span>y $之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然$ { 4 } + y ^2 = 1 { 4 } + ( x - 2 ) +
y ^2 = 0 $.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令$x ’ = x - 2 , y ’ = y <span class="math inline">\(,我们有\)</span>x = x ’ + 2 , y = y ’ <span class="math inline">\(,带入就可以得到关于\)</span>x ’ , y ’ <span class="math inline">\(的方程,然后再带回\)</span>x <span class="math inline">\(和\)</span>y $就行.</p>
<p>我们开始推导:</p>
$$
<span class="math display">\[\begin{aligned}
\frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 \\
( x - 2 ) ^2 + 4 ( x - 2 ) + 4 y ^2 = 0 \\
( x - 2 ) ^2 + 4 n ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
( 4 n + 1 ) ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
4 n + 1 + 4 m \frac { y  } { x - 2  } + 4 ( \frac { y  } { x - 2  } ) ^2
= 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$k = { x - 2 } $,也就得到了$4 n + 1 + 4 mk + 4 k ^2 = 0 <span class="math inline">\(.用一遍韦达定理,有:\)</span>k _1 k _2 = { 4 } = {
20 } , n = - { 5 } $.</p>
<p>也就有:$PQ : - { 5 } ( x - 2 ) + my = 1 <span class="math inline">\(,显然过定点\)</span>( - 3 , 0 ) $.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆$ { 9 } + y ^2 = 1 <span class="math inline">\(,\)</span>P ,
Q <span class="math inline">\(是该椭圆上两动点,\)</span>M , N <span class="math inline">\(分别为\)</span>P , Q <span class="math inline">\(在\)</span>x <span class="math inline">\(轴上的射影,而且\)</span>k <em>{ OP } k </em>{ OQ }
= - 1 <span class="math inline">\(,记\)</span>S = S <em>{ OPM } + S
</em>{ OQN } <span class="math inline">\(,求\)</span>S $的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线$PQ <span class="math inline">\(很重要的时候,而这个题除了\)</span>P , Q <span class="math inline">\(两点以外,和\)</span>PQ
$半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) <span class="math inline">\(,\)</span>k = { x _1 } , - { k } = { x _2 } $:</p>
$$
<span class="math display">\[\begin{aligned}
2 S &amp; = | x _1 y _1 | + | x _2 y _2 | \\
&amp; = | x _1 ^2 k - \frac { 1  } { k  } x _2 ^2 | \\

\end{aligned}\]</span>
<p>$$</p>
<p>而联立方程,有:</p>
<p><span class="math display">\[
x _1 ^2 = \frac { 1  } { \frac { 1  } { 9  } + k  } , x _2 ^2 = \frac {
1  } { \frac { 1  } { 9  } - \frac { 1  } { k  }  }
\]</span></p>
<p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线$PQ <span class="math inline">\(有两个未知量,我们还需要拿\)</span>k <em>{ OP } k
</em>{ OQ } = - 1 $限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆$ { 2 } + y ^2 = 1 <span class="math inline">\(,\)</span>F (
1 , 0 ) <span class="math inline">\(,直线\)</span>l <span class="math inline">\(过\)</span>F <span class="math inline">\(且交椭圆于\)</span>A , B <span class="math inline">\(两点.求问:\)</span>x <span class="math inline">\(轴上是否存在异于\)</span>F <span class="math inline">\(的一点\)</span>Q <span class="math inline">\(,使得\)</span> { k _{ QB } } $是定值.</p>
<p>直接设$AB : x = ky + 1 <span class="math inline">\(,\)</span>Q ( q ,
0 ) $.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } &amp; = \frac { y _1 ( q - x _2
)  } { y _2 ( q - x _1 )  } \\
&amp; = - \frac { ky _1 y _2 + y _1 - qy _1  } { ky _1 y _2 + y _2 - qy
_2  }
\end{aligned}
\]</span></p>
<p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
$$
<span class="math display">\[\begin{aligned}
( k ^2 + 2 ) y ^2 + 2 ky - 1 &amp; = 0 \\
\Delta &amp; = 8 k ^2 + 8 &amp; &gt; 0 \\
y _1 + y _2 &amp; = - \frac { 2 k  } { k ^2 + 2  } \\
y _1 y _2 &amp; = - \frac { 1  } { k ^2 + 2  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$ { 2 } = k ( y _1 y _2 ) $,代入,有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } &amp; = - \frac { y _1 + y _2 + 2
y _1 - 2 qy _1  } { y _1 + y _2 + 2 y _2 - 2 qy _2  } \\
&amp; = - \frac { ( 3 - 2 q ) y _1 + y _2  } { ( 3 - 2 q ) y _2 + y
_1  }
\end{aligned}
\]</span></p>
<p>若是定值,那么就有:$ { 1 } = { 3 - 2 q } <span class="math inline">\(,解得\)</span>q _1 = 1 ( F ) <span class="math inline">\(,\)</span>q _2 = 2 ( Q ) $.</p>
<p>所以$Q ( 2 , 0 ) $.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆$ { 4 } + { 3 } = 1 <span class="math inline">\(,过\)</span>F
( - 1 , 0 ) <span class="math inline">\(的直线交椭圆于\)</span>M , N
<span class="math inline">\(两点,过\)</span>M <span class="math inline">\(作直线\)</span>x = - 4 <span class="math inline">\(的垂线,垂足为\)</span>E <span class="math inline">\(,求证:\)</span>EN $过定点.</p>
<p>根据对称原理,显然这个定点一定在$x $轴上.</p>
<p>我们先写大联立的式子:设$MN : x = - 1 + ky <span class="math inline">\(,带入有\)</span>( 3 m ^2 + 4 ) y ^2 - 6 my - 9 = 0
<span class="math inline">\(.再设\)</span>M ( x _1 , y _1 ) , N ( x _2 ,
y _2 ) $,自然有:</p>
<p><span class="math display">\[
\begin{cases}
\Delta = 144 k ^2 + 144 \\
y _1 + y _2 = \frac { 6 k  } { 3 k ^2 + 4  } \\
y _1 y _2 = \frac { - 9  } { 3 k ^2 + 4  }
\end{cases}
\]</span></p>
<p>接下来呢,我们想一下我们要求什么:我们要求出$EN <span class="math inline">\(的表达式:形如\)</span>y - m = k ( x - n ) <span class="math inline">\(,然后声明\)</span>( n , m ) $是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有$k = { x -
n } <span class="math inline">\(.而我们现在有两个点\)</span>E ( - 4 , y
_1 ) <span class="math inline">\(和\)</span>N ( x _2 , y _2 ) <span class="math inline">\(,又猜出\)</span>m = 0 <span class="math inline">\(,也就是我们要找到一个\)</span>n <span class="math inline">\(满足\)</span> { - 4 - n } = { x _2 - n } $.</p>
<p>我们倒着推:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { y _1  } { - 4 - n  } &amp; = \frac { y _2  } { x _2 - n  } \\
\frac { y _1  } { - 4 - n  } &amp; = \frac { y _2  } { ky _2 - 1 - n  }
\end{aligned}
\]</span></p>
<p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
ky _1 y _2 + \frac { 3  } { 2  } ( y _1 + y _2 ) &amp; = 0 \\
( x _2 + \frac { 5  } { 2  } ) y _1 &amp; = - \frac { 3  } { 2  } y _2
\\
y _1 &amp; = \frac { - 3  } { 2  } \frac { y _2  } { x _2 + \frac { 5  }
{ 2  }  } \\
\frac { y _1  } { - \frac { 3  } { 2  }  } &amp; = \frac { y _2  } { x
_2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - 4 + \frac { 5  } { 2  }  } &amp; = \frac { y _2  } {
x _2 + \frac { 5  } { 2  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做到这一步发现要做完了,不难发现$n = { 2 } $.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了$m = 0 $了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5>
<h6><span id="定义">定义</span></h6>
<p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点$P <span class="math inline">\(作直线\)</span>l
<span class="math inline">\(交二次曲线于\)</span>M , N <span class="math inline">\(两点(离\)</span>P <span class="math inline">\(近的是\)</span>M <span class="math inline">\(),则在\)</span>l <span class="math inline">\(上有且只有一点\)</span>Q <span class="math inline">\(,使得\)</span>| MQ | | NP | = | MP | | NQ | <span class="math inline">\((即\)</span>P , Q , M , N <span class="math inline">\(构成一调和点列).当\)</span>l <span class="math inline">\(绕着\)</span>P <span class="math inline">\(旋转时,\)</span>Q <span class="math inline">\(的轨迹是一条直线\)</span>p <span class="math inline">\((或一部分),这条直线\)</span>p <span class="math inline">\(叫做点\)</span>P <span class="math inline">\(关于二次曲线的极线,而\)</span>P <span class="math inline">\(叫做\)</span>p $关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:$p : { a ^2 } + { b ^2 } = 1 $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线$C : Ax ^2 + Bxy + Cy ^2 + Dx + Ey + F = 0 <span class="math inline">\(上的一点\)</span>P ( x _0 , y _0 ) <span class="math inline">\(,我们称它的极线为\)</span>p : Axx _0 + B { 2 } +
Cyy _0 + D { 2 } + E { 2 } + F = 0 $.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6>
<p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线$C <span class="math inline">\(,如果点\)</span>P
<span class="math inline">\(的极线经过点\)</span>Q <span class="math inline">\(,那么点\)</span>Q <span class="math inline">\(的极线经过点\)</span>P $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol type="1">
<li><p>设四边形$ABCD <span class="math inline">\((对边不平行)内接于二次曲线\)</span>C <span class="math inline">\(,则对角线交点\)</span>P <span class="math inline">\(的极线是两组对边交点的连线.反之同理,若\)</span>P
$在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p></li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p></li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p></li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6>
<p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知$ { a } + { b } = 1 <span class="math inline">\(,求证:\)</span> {
a ^2 } + { b ^2 } $.</p>
<p>设直线$l : { a } + { b } = 1 <span class="math inline">\(,\)</span>M
( , ) <span class="math inline">\(,则\)</span>M <span class="math inline">\(在\)</span>l $上.</p>
<p>又注意到$M <span class="math inline">\(显然是在单位圆上,而\)</span>l
<span class="math inline">\(是单位圆关于\)</span>P ( { a } , { b } )
<span class="math inline">\(的极点.又注意到\)</span>l <span class="math inline">\(与单位圆至少有一个交点,因此\)</span>P
$要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$ { 4 } + { 3 } = 1 <span class="math inline">\(,\)</span>A
_1 ( - 2 , 0 ) , A _2 ( 2 , 0 ) , D ( { 2 } , 0 ) <span class="math inline">\(,过\)</span>D <span class="math inline">\(的直线交椭圆于\)</span>P , Q <span class="math inline">\(两点(不与\)</span>A _1 , A _2 <span class="math inline">\(重合).\)</span>A _1 P A _2 Q = M <span class="math inline">\(,\)</span>A _1 Q A _2 P = N <span class="math inline">\(,设\)</span>k <em>1 = k </em>{ A _1 P } , k <em>2
= k </em>{ A _1 Q } <span class="math inline">\(.求证:\)</span>k _1 k _2
<span class="math inline">\(是定值,求出这个定值并求出\)</span>DMN
$面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知$MN : x = 8 $.</p>
<p>我们先来看已知$MN : x = 8 $之后怎么做:</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) <span class="math inline">\(,再设\)</span>PQ : x = ky + { 2 } <span class="math inline">\(,则:\)</span>k _1 k _2 = { x _1 + 2 } { x _2 + 2 }
<span class="math inline">\(,不难算出\)</span>k _1 k _2 = - { 20 }
$.</p>
<p>此时$S <em>{ DMN } = | MN | | 8 - { 2 } | { 2 } <span class="math inline">\(.不难发现只需求出\)</span>| MN | </em>{ } <span class="math inline">\(即可.而\)</span>MN x <span class="math inline">\(轴,所以\)</span>| MN | = | y _M - y _N | $.</p>
<p>接下来咋做?第一问求得$k _1 <span class="math inline">\(和\)</span>k
_2 $的关系不能白求啊!</p>
<p>我们有$A _1 P : x = - 2 + { k _1 } y , A _1 Q : x = - 2 + { k _2 } y
<span class="math inline">\(,带入\)</span>x = 8 <span class="math inline">\(,求得\)</span>y _M = 10 k _1 , y _N = 10 k _2
$.</p>
<p>于是$| MN | = 10 | k _1 - k _2 | <span class="math inline">\(.注意到\)</span>k _1 &gt; 0 - k _2 &gt; 0 k _1 ( -
k <em>2 ) = { 20 } <span class="math inline">\(,显然可以用基本不等式计算,最后得到\)</span>S
</em>{ } = { 2 } $.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出$A _1 Q : x = - 2 + { x _2 + 2 } y , A _2 P : x =
2 + { x _1 - 2 } y $,然后我们声明这两条直线的交点的横坐标一定是$8
$,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5>
<p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是$ { a ^2 } + { b ^2 } = 1 $.</p>
<p>我们将$y <span class="math inline">\(看作\)</span>x
$的函数,对两边求导,自然得到:</p>
<p><span class="math display">\[
\frac { 2 x  } { a ^2  } + \frac { 2 yy &#39;  } { b ^2  } = 0
\]</span></p>
<p>这是个方程,你可以解得$y ’ = - { a ^2 y } <span class="math inline">\(.而这就是椭圆过\)</span>( x , y )
$这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5>
<p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6>
<p>向量$ = ( x , y ) <span class="math inline">\(逆时针旋转\)</span><span class="math inline">\(后得到的答案是\)</span>A $,其中</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>你要不喜欢矩阵表示也不是不行,那向量$( x , y ) <span class="math inline">\(旋转\)</span><span class="math inline">\(得到\)</span>( x ’ , y ’ ) $,其中</p>
<p>y’=xsin+ycos</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6>
<p>我们注意到圆的方程是$( x ’ ) ^2 + ( y ’ ) ^2 = 1 <span class="math inline">\(,而椭圆的方程形如\)</span> { a ^2 } + { b ^2 } = 1
$.</p>
<p>我们注意到上面的式子等价于:$( { a } ) ^2 + ( { b } ) ^2 = 1 <span class="math inline">\(.我们将原坐标系中的所有坐标\)</span>( x , y )
<span class="math inline">\(全部变成\)</span>( { a } , { b } )
$之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令$ = ( x , y ) <span class="math inline">\(满足椭圆方程,令\)</span> = ( x ’ , y ’ )
$满足圆的方程,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
\begin{bmatrix}
\frac { 1  } { a  } , 0 \\
0 , \frac { 1  } { b  }
\end{bmatrix} \vec { f  } &amp; = \vec { g  } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{bmatrix}
a , 0 \\
0 , { b  }
\end{bmatrix} \vec { g  } = \vec { f  }
\]</span></p>
<h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6>
<p>注意到反比例函数的方程是$x ’ y ’ = 1 <span class="math inline">\(,而双曲线的方程是\)</span> { a ^2 } - { b ^2 } = 1
$.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
首先先转化为$x ^2 - y ^2 = 2 <span class="math inline">\(的形式,需要左乘矩阵\)</span>
<span class="math display">\[\begin{bmatrix}\frac { \sqrt { 2  }  } {
a  } , 0 \\ 0 , \frac { \sqrt { 2  }  } { b  } \end{bmatrix}\]</span>
<p>$.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转$ { 4 }
$了.旋转矩阵为</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x ’ = { a } - { b } , y ’ = { a } + { b }
$.带入反比例函数的方程:</p>
<p><span class="math display">\[
x &#39; y &#39; = \frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  }
= 1
\]</span></p>
<p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>,\</p>
<p>-,</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x = { 2 } ( x ’ + y ’ ) , y = { 2 } ( { y ’ - x ’ } )
$,带入双曲线方程得到:</p>
<p><span class="math display">\[
\begin{aligned}
( \frac { x  } { a  } ) ^2 - ( \frac { y  } { b  } ) ^2 &amp; = 1 \\
( x &#39; + y &#39; ) ^2 - ( x &#39; - y &#39; ) ^2 &amp; = 4 \\
x &#39; y &#39; &amp; = 1
\end{aligned}
\]</span></p>
<p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6>
<p>这个比较简单,交换$x , y $即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5>
<p>平面内取一点$O <span class="math inline">\(为极点,引一条射线\)</span>Ox
$叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点$M <span class="math inline">\(,令\)</span>= | OM |
<span class="math inline">\(,\)</span><span class="math inline">\(为以\)</span>Ox <span class="math inline">\(为始边,沿角度正方向(一般是逆时针方向)转到\)</span>OM
<span class="math inline">\(的夹角.那么我们称\)</span>( , ) <span class="math inline">\(为\)</span>M <span class="math inline">\(的极坐标,其中\)</span><span class="math inline">\(叫做极径,\)</span>$叫做极角.</p>
<p>$<span class="math inline">\(有可能取负,我们通常认为\)</span>( - , )
= ( , + ) $.</p>
<p>通常情况下默认$0 &lt; 2 , <span class="math inline">\(.如果遇到和直角坐标系结合的问题,通常默认原点为极点,\)</span>x
$轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若$M <span class="math inline">\(在直角坐标系中坐标为\)</span>(
x , y ) <span class="math inline">\(,在极坐标中坐标为\)</span>( , )
<span class="math inline">\(,若\)</span>M O $自然有:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = \rho \cos \theta , y &amp; = \rho \sin \theta \\
\rho ^2 &amp; = x ^2 + y ^2 , \theta &amp; = \begin{cases}
\frac { \pi  } { 2  } &amp; x = 0 \land y &gt; 0 \\
\frac { 3 \pi  } { 2  } &amp; x = 0 \land y &lt; 0 \\
\arctan ( \frac { y  } { x  } ) &amp; x \ne 0
\end{cases}
\end{aligned}
\]</span></p>
<p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6>
<p>显然是$^2 = r ^2 $.</p>
<p>另外,如果中心在$C ( _0 , _0 ) <span class="math inline">\(,半径为\)</span>r $的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
r ^2 &amp; = ( \rho \cos \theta - \rho _0 \cos \theta _0 ) ^2 + ( \rho
\sin \theta - \rho _0 \sin \theta _0 ) \\
r ^2 &amp; = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos \theta \cos
\theta _0 - 2 \rho \rho _0 \sin \theta \sin \theta _0 \\
r ^2 &amp; = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos ( \theta -
\theta _0 )
\end{aligned}
\]</span></p>
<p>另外由于$= ( - ) $,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6>
<p>过定点$( _1 , _1 ) <span class="math inline">\(,且倾斜角为\)</span><span class="math inline">\(:\)</span>( - ) = _1 ( - _1 ) $.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点$( x _1 , y _1 ) <span class="math inline">\(,倾斜角为\)</span><span class="math inline">\(,我们自然有\)</span>( x - x _1 ) = ( y - y _1 )
$.</p>
<p>于是有:</p>
<p><span class="math display">\[
\begin{aligned}
( x - x _1 ) \sin \alpha &amp; = ( y - y _1 ) \cos \alpha \\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) \sin \alpha &amp; = ( \rho
\sin \theta - \rho _1 \sin \theta _1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) &amp; = \rho _1 \sin ( \alpha - \theta _1
)
\end{aligned}
\]</span></p>
<p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点$( _1 , _1 ) <span class="math inline">\(和\)</span>( _2 , _2 ) $的直线方程.</p>
<p>同理的:</p>
<p><span class="math display">\[
\begin{aligned}
( x - x _1 ) ( y _2 - y _1 ) &amp; = ( y - y _1 ) ( x _2 - x _1 ) \\
\\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) ( \rho _2 \sin \theta _2 -
\rho _1 \sin \theta _1 ) \\
&amp; = ( \rho _2 \cos \theta _2 - \rho _1 \cos \theta _1 ) ( \rho \sin
\theta - \rho _1 \sin \theta _1 ) \\
\\
\rho \rho _2 ( \cos \theta \sin \theta _2 - \cos \theta _2 \sin \theta )
\\
+ \rho \rho _1 ( - \cos \theta \sin \theta _1 + \sin \theta \cos \theta
_1 ) \\
+ \rho _1 \rho _2 ( - \cos \theta _1 \sin \theta _2 + \cos \theta _2
\sin \theta _1 ) \\
&amp; = 0 \\
\\
\rho \rho _2 \sin ( \theta _2 - \theta ) + \rho \rho _1 \sin ( \theta -
\theta _1 ) + \rho _1 \rho _2 \sin ( \theta _1 - \theta _2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6>
<p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离$d <span class="math inline">\(和到定点距离\)</span>r <span class="math inline">\(之比为常数的曲线.令\)</span>e = { d } $.</p>
<p>假定定点为原点,极轴垂直于准线,$h <span class="math inline">\(为定点到准线的距离,又设曲线上一点为\)</span>M ( ,
) <span class="math inline">\(,自然有:\)</span>r = , d = h + $.</p>
<p>于是有:</p>
<p><span class="math display">\[
\begin{aligned}
e &amp; = \frac { \rho  } { h + \rho \cos \theta  } \\
he + e \rho \cos \theta &amp; = \rho \\
\rho &amp; = \frac { he  } { 1 - e \cos \theta  }
\end{aligned}
\]</span></p>
<p>值得一提的是这玩意不能将圆理解为$e = 0 $的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5>
在平面直角坐标系中,曲线上任意一点的坐标$x , y <span class="math inline">\(都是某个变量\)</span>t <span class="math inline">\(的函数\)</span>
<span class="math display">\[\begin{cases}x = f ( t ) \\ y = g ( t )
\end{cases}\]</span>
<p>$.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6>
<p>$M ( r , r ) <span class="math inline">\(,其中\)</span><span class="math inline">\(是\)</span>OMx $.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6>
<p>$M ( x _0 + t , y _0 + t ) <span class="math inline">\(,其中\)</span><span class="math inline">\(是倾斜角,\)</span>t <span class="math inline">\(是参数,\)</span>M _0 ( x _0 , y _0 ) $.</p>
<p>注意到$| M _0 M | = | t | <span class="math inline">\(.事实上,设\)</span> = ( , ) <span class="math inline">\(,也就是直线的单位方向向量,则\)</span> = t $.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6>
<p>$M ( a , b ) <span class="math inline">\(,其中\)</span><span class="math inline">\(称为\)</span>M $的离心角.</p>
<p>值得注意的是,这里的$<span class="math inline">\(并非\)</span>MOx
$,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆$ { 9 } + { 4 } = 1 <span class="math inline">\(上求一点\)</span>M <span class="math inline">\(,使\)</span>M <span class="math inline">\(到直线\)</span>x + 2 y - 10 = 0 $的距离最小.</p>
<p>直接令$M = ( 3 , 2 ) <span class="math inline">\(,则\)</span>d = { }
= | ( + ) - 2 | <span class="math inline">\(,其中\)</span>= { 5 } $.</p>
<p>于是$d _{ } = <span class="math inline">\(,此时\)</span>( + ) = 1 =
<span class="math inline">\(,那么就有\)</span>= { 2 } - <span class="math inline">\(,\)</span>= = { 5 } , = = { 5 } $.</p>
<p>则$M = ( { 5 } , { 5 } ) $.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$ { 100 } + { 64 } = 1 <span class="math inline">\(,有一内接矩阵\)</span>ABCD <span class="math inline">\((\)</span>AB / / x , BC / / y
$),求矩阵最大面积.</p>
<p>直接令$A = ( 10 , 8 ) <span class="math inline">\(,则\)</span>S = 20
= 160 ( 2 ) <span class="math inline">\(,\)</span>S _{ } = 160 $.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6>
<p>$M ( { } , b ) = M ( a , b ) <span class="math inline">\(,其中\)</span><span class="math inline">\(称为\)</span>M <span class="math inline">\(的离心角,通常规定\)</span> { 2 } { 2 } $.</p>
<p>其实本质也就是三角恒等式$^2 = 1 + ^2 $.</p>
<p><strong>Example1</strong></p>
<p>圆$O : x ^2 + ( y - 2 ) ^2 = 1 <span class="math inline">\(上有一点\)</span>P <span class="math inline">\(,双曲线\)</span>x ^2 - y ^2 = 1 <span class="math inline">\(上有一点\)</span>Q <span class="math inline">\(,求\)</span>| PQ | _{ } $.</p>
<p>设$Q ( , ) $,则:</p>
<p><span class="math display">\[
\begin{aligned}
| OQ | ^2 &amp; = \sec ^2 \theta + ( \tan \theta - 2 ) ^2 \\
&amp; = \tan ^2 \theta + 1 ( \tan \theta - 2 ) ^2 \\
&amp; = 2 ( \tan \theta - 1 ) ^2 + 3
\end{aligned}
\]</span></p>
<p>$| OQ | <em>{ } = , | PQ | </em>{ } = - 1 $.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设$P ( a , a ) , Q ( - a , a ) <span class="math inline">\(,则\)</span>k _P = { a - a } , k _Q = { - a - a }
<span class="math inline">\(.注意到\)</span>k _P k _Q = - 1 $.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线$ { a ^2 } - { b ^2 } = 1 <span class="math inline">\(,\)</span>A , B <span class="math inline">\(是双曲线同支上相异两点,线段\)</span>AB <span class="math inline">\(的垂直平分线与\)</span>x <span class="math inline">\(轴相交于点\)</span>P ( x _0 , 0 ) <span class="math inline">\(,求证:\)</span>| x _0 | &gt; { a } = { a } $.</p>
<p>设$A ( a , b ) , B ( a , b ) <span class="math inline">\(,则中点\)</span>M ( { 2 } ( + ) , { 2 } ( + ) )
$.</p>
<p>于是中垂线方程为$y - { 2 } ( + ) ) = - { b ( - ) } [ x - { 2 } ( + )
] $.</p>
<p>代入$P ( x _0 , 0 ) <span class="math inline">\(,求得\)</span>x _0 =
{ 2 a } ( + ) $.</p>
<p>也就是要比较$| + | $和$2 <span class="math inline">\(的大小关系,注意到\)</span>A , B <span class="math inline">\(同支,所以\)</span>| + | &gt; 2 $.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6>
<p>$M ( { ^2 } , { } ) <span class="math inline">\(,其中\)</span><span class="math inline">\(称为\)</span>M
$的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:$M ( 2 pk ^2 , 2 pk )
$,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
若抛物线$
<span class="math display">\[\begin{cases}x = 2 pt ^2 \\ y = 2 pt
\end{cases}\]</span>
<p><span class="math inline">\(上有不同两点\)</span>M _1 , M _2 <span class="math inline">\(,所对应的参数分别是\)</span>t _1 , t _2 <span class="math inline">\(,求直线\)</span>M _1 M _2 $所在直线的斜率.</p>
<p>$k _{ M _1 M _2 } = { 2 pt _1 ^2 - 2 pt _2 ^2 } = { t _1 + t _2 }
$.</p>
<p><strong>Example2</strong></p>
<p>$A , B <span class="math inline">\(是抛物线\)</span>y ^2 = 2 px <span class="math inline">\(上异于顶点的两动点,且\)</span>OA OB <span class="math inline">\(,\)</span>AB <span class="math inline">\(上有一点\)</span>M <span class="math inline">\(满足\)</span>OM AB <span class="math inline">\(,求\)</span>M $的轨迹方程.</p>
<p>设$M ( x , y ) , A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt
_2 ) $,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow { OM  } &amp; = ( x , y ) \\
\overrightarrow { OA  } &amp; = ( 2 pt _1 ^2 , 2 pt _1 ) \\
\overrightarrow { OB  } &amp; = ( 2 pt _2 ^2 , 2 pt _2 ) \\
\overrightarrow { AB  } &amp; = ( 2 p ( t _2 ^2 - t _1 ^2 ) , 2 p ( t _2
- t _1 ) )
\end{aligned}
\]</span></p>
<p>因为$ <span class="math inline">\(,所以\)</span>( 2 pt _1 t _2 ) ^2 +
( 2 p ) ^2 t _1 t _2 = 0 <span class="math inline">\(,\)</span>t _1 t _2
= - 1 $.</p>
<p>因为$ <span class="math inline">\(,又有\)</span>k _{ AB } = { t _1 +
t <em>2 } <span class="math inline">\(,所以\)</span>k </em>{ OM } = - (
t _1 + t _2 ) <span class="math inline">\(,\)</span> { x } = - ( t _1 +
t _2 ) $.</p>
<p>接下来咋做捏?注意到我们好像忘记了$ABM
$三点共线的性质,拿向量做这个东西.</p>
<p>$ = ( x - 2 pt _1 ^2 , y - 2 pt _1 ) , = ( 2 pt _2 ^2 - x , 2 pt _2 -
y ) $.</p>
<p>那么有$( x - 2 pt _1 ^2 ) ( 2 pt _2 - y ) = ( 2 pt _2 ^2 - x ) ( y -
2 pt _1 ) $.</p>
<p>化简得到$x ^2 + y ^2 - 2 px = 0 ( x ) $.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点$A , B <span class="math inline">\(,自然要设出它们的参数方程.然后呢?然后我们发现最后\)</span>M
<span class="math inline">\(一定和\)</span>t _1 , t _2 <span class="math inline">\(有关.但是我们要求的是\)</span>M <span class="math inline">\(的方程,其中不能带有\)</span>t _1 , t _2 <span class="math inline">\(,因此考虑把\)</span>M <span class="math inline">\(的坐标设出来,再用这个坐标表示\)</span>t _1 , t _2
<span class="math inline">\(,表示不出来表示\)</span>t _1 t _2 , t _1 + t
_2 $也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到$M <span class="math inline">\(一定在以\)</span>| OA | <span class="math inline">\(为直径的圆上,\)</span>B
$同理,这两个圆的方程分别为:</p>
<p><span class="math display">\[
\begin{aligned}
x ^2 + y ^2 - 2 pt _1 ^2 x - 2 pt _1 y &amp; = 0 \\
x ^2 + y ^2 - 2 pt _2 ^2 x - 2 pt _2 y &amp; = 0
\end{aligned}
\]</span></p>
<p>也就是说,$t _1 , t _2 <span class="math inline">\(是同一个方程的两个根,根据韦达定理自然有\)</span>t
_1 t _2 = { 2 px } = - 1 <span class="math inline">\(,于是直接有\)</span>x ^2 + y ^2 - 2 px = 0 $.</p>
<p>还没完,注意到$O <span class="math inline">\(一定是一个根,要去掉,所以答案就是\)</span>x ^2 + y
^2 - 2 px = 0 ( x ) $.</p>
<p><strong>Example3</strong></p>
<p>已知$A , B , C <span class="math inline">\(是抛物线\)</span>y ^2 = 2
px ( p &gt; 0 ) <span class="math inline">\(上的三个点,且\)</span>BC
<span class="math inline">\(与\)</span>x <span class="math inline">\(轴垂直,直线\)</span>AB <span class="math inline">\(和\)</span>AC <span class="math inline">\(分别与抛物线的轴交于\)</span>D , E <span class="math inline">\(两点,求证:抛物线的顶点平分\)</span>DE $.</p>
<p>设$A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) , C ( 2 pt
_2 ^2 , - 2 pt _2 ) <span class="math inline">\(,注意到\)</span>AB : y -
2 pt _1 = { t _1 + t _2 } ( x - 2 pt _1 ^2 ) <span class="math inline">\(,\)</span>AC : t - 2 pt _1 = { t _1 - t _2 } ( x -
2 pt _1 ^2 ) $.</p>
<p>可求得$D ( - 2 pt _1 t _2 , 0 ) , E ( 2 pt _1 t _2 , 0 )
$,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5>
<p>参考:https://zhuanlan.zhihu.com/p/591258689</p>
<h6><span id="定义">定义</span></h6>
<p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6>
<p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为$ { a ^2 } + { b ^2 } = 1 <span class="math inline">\(,其蒙日圆方程为\)</span>x ^2 + y ^2 = a ^2 + b ^2
$.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为$ { a ^2 } - { b ^2 } = 1 <span class="math inline">\(,其蒙日圆方程为\)</span>x ^2 + y ^2 = a ^2 - b ^2
$.</p>
<p>证明:其实注意到椭圆的证明中设$b $是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线$y ^2 = 2 px <span class="math inline">\(,其蒙日圆方程为\)</span>x = - { 2 } $.</p>
<p>有一说一,直线是半径无穷大的圆.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>递归式与和式</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3>
<p>三个柱子,$n
$个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T _n <span class="math inline">\(表示答案,显然\)</span>T _0 =
0 , T _1 = 1 $.</p>
<p>而我们一定可以找到一种方案,使得前$n - 1 <span class="math inline">\(个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把\)</span>n
- 1 <span class="math inline">\(个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:\)</span>T
<em>n T </em>{ n - 1 } + 1 $.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:$2
T _{ n - 1 } + 1 T _n <span class="math inline">\(.于是有\)</span>T
<em>n = 2 T </em>{ n - 1 } + 1 $.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4>
<p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4>
<p>考虑设$T <em>n <span class="math inline">\(为n个圆盘时的最小操作次数.假设已知\)</span>T
</em>{ n - 1 } $,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T
<em>{ n } = 3 T </em>{ n - 1 } + 2 , T _0 = 0 $.</p>
<p>考虑如何求该式子的封闭形式,令$W _n = T _n + 1 <span class="math inline">\(,显然有\)</span>W <em>n = 3 W </em>{ n - 1 } , W
_0 = 1 <span class="math inline">\(,显然\)</span>W _n = 3 ^n <span class="math inline">\(,有\)</span>T _n = 3 ^n - 1 $.</p>
<p>注意到$T _n
$刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4>
<p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2
^n - 1 $.</p>
<h4><span id="solution-2">Solution 2</span></h4>
<p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4>
<p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4>
<p>令$Q _n <span class="math inline">\(为将n个圆盘从A移动到B的最小操作次数,令\)</span>R
_n $为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q _0 = 0 , R _0 = 0 $.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q _n <span class="math inline">\(的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,\)</span>R
_n $的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q <em>n = 2 R </em>{ n - 1 } + 1 , 1 n $.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R <em>n = R </em>{ n - 1 } + 1 + Q <em>{ n - 1 } + 1 + R </em>{ n
- 1 } = Q <em>n + Q </em>{ n - 1 } + 1 , 1 n $.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4>
<p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4>
<p>a.仍然令$T _n <span class="math inline">\(为n对圆盘的最小操作次数,显然\)</span>T <em>n = 2 T
</em>{ n - 1 } + 2 , T _0 = 0 <span class="math inline">\(,可解得\)</span>T _n = 2 ^{ n + 1 } - 2 $.</p>
<p>b.令$Q <em>n <span class="math inline">\(为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现\)</span>Q
<em>n = T </em>{ n - 1 } + 1 + T </em>{ n - 1 } + 1 + T <em>{ n - 1 } +
1 + T </em>{ n - 1 } = 4 T _{ n - 1 } + 3 = 2 ^{ n + 2 } - 5 $.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q
_n $就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4>
<p>类似Problem11,但第$i <span class="math inline">\(大的圆盘有\)</span>k
_i $个.</p>
<h4><span id="solution-5">Solution 5</span></h4>
<p>无区别,只是$T <em>n = 2 T </em>{ n - 1 } + k _n , T _0 = 0 $.</p>
<p>如果求封闭形式的话,显然有$T <em>n = </em>{ i = 1 } ^n 2 ^{ n - i } k
_i $.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3>
<p>在上述问题中，我们已经有了以下式子：</p>
<p>$T <em>n = 2 T </em>{ n - 1 } + 1 , n &gt; 0 , T _0 = 0 $.</p>
<p>如果$n <span class="math inline">\(很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出\)</span>T
_n $的方法.</p>
<p>换句话说，我们想要把$T _n
$表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4>
<h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5>
解递归式:$Q _n =
<span class="math display">\[\begin{cases}\alpha &amp; n = 0 \\ \beta
&amp; n = 1 \\ \frac { ( 1 + Q _{ n - 1  } )  } { Q _{ n - 2  }  } &amp;
n &gt; 1 \end{cases}\]</span>
<p><span class="math inline">\(,保证\)</span>n , Q _n &gt; 0 $.</p>
<h5><span id="solution">Solution</span></h5>
<p>注意到$Q _2 = { } , Q _3 = { } , Q _4 = { } , Q _5 = , Q _6 = $.</p>
<p>显然该递归式存在长度为$5 $的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4>
<p>观察T序列的前几项，可以发现似乎有$T _n = 2 ^n - 1 $.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n = 0 $成立，显然可验证.</p>
<p>2.若该公式对$n = k <span class="math inline">\(时成立，那该公式必然对\)</span>n = k + 1
$成立.</p>
<p>因为有$T _{ k + 1 } = 2 T _k + 1 = 2 ^k + 2 - 1 = 2 ^{ k + 1 } - 1
$.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5>
<p>求证:$_{ i = 1 } ^n x <em>i ( { n } ) ^n , i N </em>+ , 1 i n , 0 x
_i $.</p>
<h5><span id="solution">Solution</span></h5>
<p>使用反向归纳法.</p>
<p>1.$n = 2 $时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n = k $时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A _1 = , B _1 = , A _2 = ( { k } ) , B _2 = ( { k } ) <span class="math inline">\(,显然有\)</span>A _1 A _2 , B _1 B _2 $.</p>
<p>同时有$( { 2 } ) $.</p>
<p>3.若该式子对$n = k <span class="math inline">\(时成立,则该式子对\)</span>n = k - 1
$的时候也成立.</p>
<p>令$x _k = { k - 1 } <span class="math inline">\(,有\)</span>x <em>k
</em>{ i = 1 } ^{ k - 1 } x _i ( x _k ) ^k $.</p>
<p>则显然$n = k - 1 $时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4>
<p>考虑令$U _n = T _n + 1 <span class="math inline">\(,显然有:\)</span>T
<em>n + 1 = 2 T </em>{ n - 1 } + 2 <span class="math inline">\(.即\)</span>U <em>n = 2 U </em>{ n - 1 } <span class="math inline">\(,显然\)</span>U _n = 2 ^n <span class="math inline">\(,则\)</span>T _n = 2 ^n - 1 $.</p>
<p>这个做法可以做掉所有形如$a _{ n + 1 } = pa _n + q
$的递归式.我们有:</p>
<p><span class="math display">\[
a _{ n + 1  } + \frac { q  } { p - 1  } = p ( a _n + \frac { q  } { p -
1  } )
\]</span></p>
<p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4>
<p>考虑递归式$a _n T _n = b <em>n T </em>{ n - 1 } + c _n <span class="math inline">\(.如果我们能找到一个不为0的求和因子\)</span>s _n
<span class="math inline">\(并满足\)</span>s <em>n b <em>n = s </em>{ n
- 1 } a </em>{ n - 1 } <span class="math inline">\(.那么我们两面同时乘以\)</span>s _n <span class="math inline">\(,显然有：\)</span>s <em>n a <em>n T <em>n = s
</em>{ n - 1 } a </em>{ n - 1 } T </em>{ n - 1 } + c _n s _n $.</p>
<p>令$S _n = s _n a _n T _n <span class="math inline">\(.显然有\)</span>S _n = s _0 a _0 T <em>0 + </em>{
i = 1 } ^n s _i c _i <span class="math inline">\(,则\)</span>T _n = { s
_n a _n } $.</p>
<p>而我们也会发现$s <em>n = { </em>{ i = 1 } ^n b _i } $.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5>
<p>结论:排序$n $个数时,其期望复杂度满足:</p>
<p><span class="math display">\[
C _n = \begin{cases}
0 &amp; n = 0 , 1 \\
n + 1 + \frac { 2  } { n  } \sum _{ i = 0  } ^{ n - 1  } C _k &amp; n
&gt; 1
\end{cases}
\]</span></p>
<p>不妨考虑两边同时乘以$n $,有 $nC <em>n = n ^2 + n + 2 </em>{ i = 0 }
^{ n - 1 } C _i , n &gt; 1 $ .</p>
<p>显然也有$( n - 1 ) C <em>{ n - 1 } = ( n - 1 ) ^2 + n - 1 + 2 </em>{
i = 0 } ^{ n - 2 } C _i , n &gt; 2 $.</p>
<p>二式相消,有$nC <em>n - ( n - 1 ) C </em>{ n - 1 } = 2 n + 2 C _{ n -
1 } , n &gt; 2 $.</p>
<p>而同时有$C _2 = 3 <span class="math inline">\(.即:\)</span>nC <em>n =
( n + 1 ) C </em>{ n - 1 } + 2 n , n &gt; 2 <span class="math inline">\(,可以使用转化和式的方法,两边乘以\)</span> { n ( n
+ 1 ) } $解决.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知$a _1 = 1 <span class="math inline">\(,\)</span>a _n = + <span class="math inline">\(,求\)</span>a _n $.</p>
<p>注意到$a _n = S <em>n - S </em>{ n - 1 } <span class="math inline">\(,则有\)</span> - = 1 <span class="math inline">\(,于是\)</span> = n <span class="math inline">\(,\)</span>S _n = n ^2 <span class="math inline">\(,\)</span>a _n = 2 n - 1 $.</p>
<h4><span id="成套方法">成套方法</span></h4>
<p>如果我们有</p>
<p>&amp; n=1\</p>
<p>2f(n 2)+&amp; n=2k,k\</p>
<p>2f(2)+&amp;n=2k+1,k</p>
<p>\end{cases}</p>
<p>其中$n = 2 ^m + l $且$2 ^m n &lt; 2 ^{ m + 1 } $.</p>
<p>该如何求出$f ( n ) $的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有$f ( n ) = A ( n ) + B ( n )
+ C ( n ) <span class="math inline">\(,而有\)</span>A 、 B 、 C <span class="math inline">\(互不影响且\)</span><span class="math inline">\(与\)</span>ABC $无关.</p>
<p>那无论$<span class="math inline">\(和\)</span><span class="math inline">\(的取值如何,\)</span>A ( n ) <span class="math inline">\(都不会受到影响,我们考虑\)</span>= = 0 <span class="math inline">\(的特殊情况,此时显然有\)</span>A ( n ) = 2 ^m
$.</p>
<p>接下来,我们考虑取$$的特殊值,去得到ABC之间的关系.</p>
<p>例如，当$f ( n ) = 1 <span class="math inline">\(时，由递推式可知\)</span>= 1 , = = - 1 <span class="math inline">\(,那么有\)</span>A ( n ) - B ( n ) - C ( n ) = f (
n ) = 1 $.</p>
<p>同理，$f ( n ) = n <span class="math inline">\(时，可知\)</span>= 1 ,
= 0 , = 1 <span class="math inline">\(,此时有\)</span>A ( n ) + C ( n )
= f ( n ) = n $.</p>
<p>显然可以通过解方程求得$B ( n ) <span class="math inline">\(和\)</span>C ( n ) $.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC <span class="math inline">\(互不影响且\)</span><span class="math inline">\(与\)</span>ABC $无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4>
<p>一个常系数的$k $阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n &amp;
\geq k \\
a _0 &amp; = C _0 , a _1 &amp; = C _1 , . . . , a _{ k - 1  } &amp; = C
_{ k - 1  }
\end{aligned}
\]</span></p>
<p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程$r ^k = _{ i = 1 } ^k c _i r ^{ k - i }
$是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根$r _1 <span class="math inline">\(和\)</span>r _2 <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r _1 ^n + _2 r _2 ^n
$.</p>
<p>若其特征方程有两个相同的根$r <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r ^n + _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 <span class="math inline">\(或者\)</span>n = 1 <span class="math inline">\(的情况,我们考虑求出一组\)</span>_1 <span class="math inline">\(和\)</span>_2 $来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C _0 &amp; = \alpha _1 + \alpha _2 \\
C _1 &amp; = \alpha _1 r _1 + \alpha _2 r _2
\end{aligned}
\]</span></p>
<p>若$r _1 r _2 $,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha _1 &amp; = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 &amp; = C _0 - \alpha _1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } )
+ c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) +
\alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有$= c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C _0 &amp; = \alpha _1 \\
C _1 &amp; = \alpha _1 r + \alpha _2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } -
\alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2
nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
&amp; = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n -
2  }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明$c _1 r + 2 c _2 = 0 <span class="math inline">\(即可.根据方程,不难发现\)</span>r = { 2 } <span class="math inline">\(,根据\)</span>= 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>直接在复数域上定义$f <em>k ( x ) = { n ^k x ^n } </em>{ n = 0 }
^$,此时我们规定$0 ^0 = 1 <span class="math inline">\(.特别地,当\)</span>x = 0 <span class="math inline">\(的时候,定义\)</span>f <em>k ( x ) <span class="math inline">\(的第\)</span>k $项是$1 $,其余项是$0 <span class="math inline">\(.在此基础上定义线性映射\)</span>T : ( a <em>n )
</em>{ n = 0 } ^( a </em>{ n + 1 } ) _{ n = 0 } ^<span class="math inline">\(,立刻见到:\)</span>( T - x ) ^{ k + 1 } f _k ( x )
= 0 , ( T - x ) ^k f _k ( x ) <span class="math inline">\(.原因只需简单数学归纳.而此还可以引出\)</span>f _0
( x ) , f _1 ( x ) , $线性无关.</p>
<p>在此基础上观察线性递推$a <em>{ n + d } = c </em>{ d - 1 } a _{ n + d
- 1 } + + c <em>0 a <em>n <span class="math inline">\(,不妨取\)</span>G
( x ) = x ^d - c </em>{ d - 1 } x ^{ d - 1 } - - c <em>0 <span class="math inline">\(,立刻应当见到如果\)</span>a <span class="math inline">\(是\)</span>G <span class="math inline">\(的根并且重数为\)</span>e ( a ) <span class="math inline">\(,那么\)</span>f </em>{ 0 } ( x ) , , f </em>{ e (
a ) - 1 } ( a ) <span class="math inline">\(都在\)</span>f ( T ) <span class="math inline">\(中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如\)</span>_j
w _i f _i ( y ) = _j w _j f _j ( x ) <span class="math inline">\(的情况,此时对右边直接操作若干次\)</span>( T - x )
$就可以把右边全部消成$0 <span class="math inline">\(,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于\)</span>n
<span class="math inline">\(的多项式右边的\)</span>( T - x ) <span class="math inline">\(是不会改变左边这边的每一个位置多项式的\)</span>$,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是$ <em>{ k + 1 } = A <span class="math inline">\(,\)</span> </em>{ n } = A ^n _0 <span class="math inline">\(.而我们又知道CH定理:\)</span>p ( A ) = 0 <span class="math inline">\(,我们用多项式取膜,有\)</span>A ^n = p ( A ) F ( A
) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3>
<p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是$2
, 4 , 6 , 8 , 10 , 3 , 7 , 1 , 9 $.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有$J ( 2 n ) = 2 J ( n ) - 1 <span class="math inline">\(;当人数是奇数时,我们杀掉一号,然后有\)</span>J ( 2
n + 1 ) = 2 J ( n ) + 1 $.</p>
<p>整理得到:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 1 \\
2 J ( \frac { n  } { 2  } ) - 1 &amp; n = 2 k , k \in \mathbb { N _+  }
\\
2 J ( \frac { n - 1  } { 2  } ) + 1 &amp; n = 2 k + 1 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>仍然可以使用数学归纳，如果令$n = 2 ^m + l 且 2 ^m n &lt; 2 ^{ m + 1 }
$.</p>
<p>有$J ( n ) = 2 l + 1 $.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从$0
$开始编号:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
0 &amp; n = 1 \\
2 J ( \frac { n  } { 2  } ) &amp; n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 &amp; n = 2 k + 1 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>这下相信$J ( n ) <span class="math inline">\(是多少就很显然了,将\)</span>n
$写成二进制的形式,这个就相当于把首位$1 $抹去然后在末尾加个$0 $.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4>
<p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4>
<p>显然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
2 &amp; n = 2 \\
1 &amp; n = 3 \\
2 J ( \frac { n  } { 2  } ) - 1 &amp; n = 2 k + 2 , k \in \mathbb { N
_+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 &amp; n = 2 k + 3 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>从$0 $开始编号,自然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 2 \\
0 &amp; n = 3 \\
2 J ( \frac { n  } { 2  } ) &amp; n = 2 k + 2 , k \in \mathbb { N _+  }
\\
2 J ( \frac { n - 1  } { 2  } ) + 2 &amp; n = 2 k + 3 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>显然$J ( n ) $也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2>
<h3><span id="和式的基本运算">和式的基本运算</span></h3>
<p>分配律:</p>
<p><span class="math display">\[
\sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i
\]</span></p>
<p>一般分配律:</p>
<p><span class="math display">\[
\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum
_j b _j )
\]</span></p>
<p>结合律:</p>
<p><span class="math display">\[
\sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i
\in S  } b _i
\]</span></p>
<p>交换律:</p>
<p><span class="math display">\[
\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  }
\]</span></p>
<p>交换求和顺序:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] &amp; = \sum _{
j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] \\
\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } &amp; = \sum _{ j
= 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  }
\end{aligned}
\]</span></p>
<h3><span id="和式的封闭形式">和式的封闭形式</span></h3>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ( ai + b ) &amp; = \sum _{ i = 0  } ^n
( a ( n - i ) + b ) \\
2 S _n &amp; = \sum _{ i = 0  } ^n ( an + 2 b ) &amp; = an ( n + 1 ) + 2
b ( n + 1 ) \\
S _n &amp; = ( n + 1 ) ( \frac { an  } { 2  } + b )
\end{aligned}
\]</span></p>
<h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5>
<p>令$S = _{ 1 i &lt; j n } ( a _j - a _i ) ( b _j - b <em>i ) = </em>{
1 j &lt; i n } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 j &lt; i n ] + [ 1 i &lt; j n ] = [ 1 j , i n ] - [ 1
i = j n ] $.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S &amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i
) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
&amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i )
\\
&amp; = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i
) ( \sum _{ j = 1  } ^n b _j ) \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) &amp; = n \sum
_{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a
_i ) ( b _j - b _i )
\end{aligned}
\]</span></p>
<p>显然有以下式子:</p>
<p>(_{i=1}<sup>na_i)(<em>{j=1}^nb_j)n</em>{i=1}</sup>na_ib_i，i&lt;j，a_ia_j且b_ib_j\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5>
<p>证明:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 &amp; = (
\sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum
_{ i = 1  } ^n a _i b _i ) ^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j )
^2 \\
2 S _n &amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a
_k b _j ) ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a
_j a _k b _j b _k + a _k ^2 b _j ^2 ) \\
&amp; = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2
) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ax ^i \\
&amp; = a + \sum _{ i = 1  } ^n ax ^i \\
&amp; = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
&amp; = a + xS _{ n - 1  }
\end{aligned}
\]</span></p>
<p>而$S _{ n - 1 } + ax ^n = S <em>n = a + xS </em>{ n - 1 } <span class="math inline">\(,有\)</span>S _n + ax ^{ n + 1 } = a + xS _n , S
_n = a { x - 1 } <span class="math inline">\(，其中\)</span>x $.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n i ^2 &amp; = \sum _{ i = 0  } ^{ n -
1  } i ^2 + n ^2 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
&amp; = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2
\end{aligned}
\]</span></p>
<p>我们无法得到$S <em>n <span class="math inline">\(的封闭形式,但我们发现我们得到了\)</span></em>{ i =
1 } ^n i $的封闭形式.</p>
<p>那以此类推,我们设$W <em>n = </em>{ i = 0 } i ^3 $.</p>
<p><span class="math display">\[
\begin{aligned}
W _n &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum
_{ i = 1  } ^n i - n + n ^3 \\
&amp; = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n &amp; = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
&amp; = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
&amp; = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
&amp; = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  }
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5>
<p>令$H <em>n = </em>{ k = 1 } ^n { k } <span class="math inline">\(,求\)</span>_{ i = 0 } ^n H _i $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>不妨考虑$<em>{ i = 0 } ^n iH </em>{ i } $的值.</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 0  } ^n iH _{ i  } &amp; = \sum _{ i = 1  } ^n [ ( i - 1 + 1
) H _{ i - 1  } + 1 ] \\
&amp; = n + \sum _{ i = 0  } ^{ n - 1  } H _i + \sum _{ i = 0  } ^{ n  }
iH _i - nH _n \\
\sum _{ i = 0  } ^{ n - 1  } H _i &amp; = n ( H _n - 1 ) \\
\sum _{ i = 0  } ^n H _i &amp; = ( n + 1 ) ( H _{ n + 1  } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5>
<p>求$S <em>n = </em>{ i = 0 } ^n ( - 1 ) ^{ n - i } , T <em>n = </em>{
i = 0 } ^n ( - 1 ) ^{ n - i } i , U <em>n = </em>{ i = 0 } ^n ( - 1 ) ^{
n - i } i ^2 $.</p>
<h5><span id="solution-4">Solution 4</span></h5>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 1  } ^{ n  } ( - 1 ) ^{ n - i  } + ( - 1 ) ^n
\\
- S _{ n - 1  } + 1 &amp; = ( - 1 ) ^n + \sum _{ i = 0  } ^{ n - 1  } (
- 1 ) ^{ n - 1 - i  } \\
- S _{ n - 1  } + 1 &amp; = ( - 1 ) ^n + S _{ n - 1  } \\
S _{ n - 1  } &amp; = \frac { 1 - ( - 1 ) ^n  } { 2  } \\
S _n &amp; = \frac { 1 + ( - 1 ) ^n  } { 2  }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
T _{ n  } &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i \\
- T _{ n - 1  } + n &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i
- 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- T _{ n - 1  } + n &amp; = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n -
i - 1  } i + \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } - ( - 1 ) ^n \\
- T _{ n - 1  } + n &amp; = T _{ n - 1  } + S _n - ( - 1 ) ^n \\
n - \frac { 1 - ( - 1 ) ^n  } { 2  } &amp; = 2 T _{ n - 1  } \\
T _n &amp; = \frac { 1  } { 2  } ( n + 1 + \frac { - 1 - ( - 1 ) ^n  } {
2  } ) &amp; = \frac { 1  } { 2  } ( n + \frac { 1 - ( - 1 ) ^n  } {
2  } )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
U _n &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i ^2 \\
- U _{ n - 1  } + n ^2 &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } (
i - 1 + 1 ) ^2 \\
- U _{ n - 1  } + n ^2 &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } (
i - 1 ) ^2 + 2 \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum
_{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- U _{ n - 1  } + n ^2 &amp; = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n
- i - 1  } i ^2 + 2 \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  }
i + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } \\
- U _{ n - 1  } + n ^2 &amp; = U _{ n - 1  } + 2 T _{ n - 1  } + S _{ n
- 1  } \\
2 U _{ n - 1  } &amp; = n ^2 - 2 T _{ n - 1  } - S _{ n - 1  } \\
2 U _{ n - 1  } &amp; = n ^2 - ( n - \frac { 1 - ( - 1 ) ^n  } { 2  } )
- \frac { 1 - ( - 1 ) ^n  } { 2  } \\
2 U _{ n - 1  } &amp; = n ^2 - n \\
U _n &amp; = \frac { n ( n + 1 )  } { 2  }
\end{aligned}
\]</span></p>
<h4><span id="转化为递归式">转化为递归式</span></h4>
<p>考虑和式$S <em>n = </em>{ i = 0 } ^n f ( i ) = S _{ n - 1 } + f ( n )
\ $，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5>
<p>求$_{ i = 0 } ^n ( - 1 ) ^i i ^2 \ $.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>令$S ( n ) = _{ i = 0 } ^n ( - 1 ) ^i i ^2 = S ( n - 1 ) + ( - 1 ) ^n
n ^2 $,考虑使用成套方法.</p>
<p>不妨令$S ( n ) = S ( n - 1 ) + ( - 1 ) ^n ( + n + n ^2 ) = A ( n ) +
B ( n ) + C ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n , 可 以 解 得 = - 1 , = 2 , = 0 <span class="math inline">\(,有\)</span>( - 1 ) ^n n = - A ( n ) + 2 B ( n )
$.</p>
<p>令$S ( n ) = ( - 1 ) ^n n ^2 , 可 以 解 得 = 1 , = - 2 , = 2 <span class="math inline">\(,有\)</span>( - 1 ) ^n n ^2 = A ( n ) - 2 B ( n )
+ 2 C ( n ) $.</p>
<p>显然可解得$2 C ( n ) = ( - 1 ) ^n n ^2 + ( - 1 ) ^n n , C ( n ) = ( -
1 ) ^n { 2 } $.</p>
<p>而原式中,$S ( n ) = C ( n ) = ( - 1 ) ^n { 2 } $.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5>
<p>有$2 T <em>n = nT </em>{ n - 1 } + 3 n ! , T _0 = 5 <span class="math inline">\(,求\)</span>T _n $.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p>令$s _n = { n ! } <span class="math inline">\(,两边同时乘以\)</span>s
_n <span class="math inline">\(,有\)</span> { n ! } T <em>n = { ( n - 1
) ! } T </em>{ n - 1 } + 3 ^{ n - 1 } \ $.</p>
<p>令$S _n = { n ! } T _n $,有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = S _{ n - 1  } + 3 \times 2 ^{ n - 1  } \\
&amp; = 5 + 3 \sum _{ i = 0  } ^{ n - 1  } 2 ^i \\
&amp; = 5 + 3 \times 2 ^{ n + 1  } - 3 \\
&amp; = 3 \times 2 ^{ n  } + 2 \\
T _n &amp; = 3 n ! + \frac { n !  } { 2 ^{ n - 1  }  }
\end{aligned}
\]</span></p>
<h4><span id="转化为积分形式">转化为积分形式</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数$f ( x ) = x ^2 <span class="math inline">\(,显然\)</span>_0
^n x ^2 dx = { 3 } S _n \ $.</p>
<p>接下来,我们考虑求得二者之间的误差,设$E _n = S _n - { 3 } \
$,对其使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
E _n &amp; = S _n - \frac { n ^3  } { 3  } \\
&amp; = S _{ n - 1  } + n ^2 - \frac { ( n - 1 + 1 ) ^3  } { 3  } \\
&amp; = S _{ n - 1  } + n ^2 - \frac { ( n - 1 ) ^3  } { 3  } - ( n - 1
) ^2 - ( n - 1 ) - \frac { 1  } { 3  } \\
&amp; = E _{ n - 1  } + n ^2 - n ^2 + 2 n - 1 - n + 1 - \frac { 1  } {
3  } \\
&amp; = E _{ n - 1  } + n - \frac { 1  } { 3  }
\end{aligned}
\]</span></p>
<p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<p><span class="math display">\[
\begin{aligned}
E _n &amp; = S _n - \int _0 ^n x ^2 dx \\
&amp; = \sum _{ k = 1  } ^n ( k ^2 - \int _{ k - 1  } ^k x ^2 dx ) \\
&amp; = \sum _{ k = 1  } ^n ( k ^2 - \frac { k ^3 - ( k - 1 ) ^3  } {
3  } ) \\
&amp; = \sum _{ k = 1  } ^n ( k - \frac { 1  } { 3  } )
\end{aligned}
\]</span></p>
<p>这是一个简单的和式.而$S _n = E _n + { 3 } \ $,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5>
<p>已知$a <em>1 = 1 , a </em>{ n + 1 } - a _n = - { 3 } a _n ^2 <span class="math inline">\(,估计\)</span>a _n $的值.</p>
<p>考虑构造一个函数$f ( n ) <span class="math inline">\(使得\)</span>f (
n ) a <em>n <span class="math inline">\(,那我们就可以将\)</span>a </em>{
n + 1 } - a _n f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$x
_0 , f ’ ( x _0 ) = f ( n + 1 ) - f ( n ) <span class="math inline">\(,而对于增长率变化不大的函数,直接认为\)</span>f ’ (
x _0 ) = f ’ ( n ) $是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 <span class="math inline">\(解得\)</span>f ( n ) = { n + 2 }
$.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令$a _n = { n + 2 } - b _n <span class="math inline">\(,带入化简,得到\)</span>{ b _n } $的递推式:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } &amp; = ( \frac { 3  } { n +
2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } )
\\
b _{ n + 1  } - \frac { 3  } { n + 3  } &amp; = ( b _n - \frac { 3  } {
n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 &amp; = 0 , b _{ n + 1  } &amp; = \frac { b _n ^2  } { 3  } + \frac
{ n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  }
\end{aligned}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出$b _n { 4 n }
$,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n <span class="math inline">\(的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设\)</span>b
_n ^2 &lt; &lt; b _n $:</p>
<p>那么这个$b _n <span class="math inline">\(是\)</span>O ( { n ^2 } )
$级别的.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
b _{ n + 1  } &amp; = \frac { n  } { n + 2  } b _n + \frac { 1  } { n (
n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } &amp; = n ( n + 1 ) b _n + \frac {
1  } { n  } \\
g ( n ) &amp; = n ( n + 1 ) b _n , g &#39; ( n ) &amp; = \frac { 1  } {
n  } , g ( n ) &amp; = \ln n \\
b _n &amp; = \frac { \ln n  } { n ^2  }
\end{aligned}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ } ) <span class="math inline">\(和\)</span>O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n { n ( n + 1 ) } $.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ k = 1  } ^n k ^2 \\
&amp; = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
&amp; = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 )
\\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 -
ni + n ) \\
&amp; = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  }
^n i ^2 + n ^3 + n ^2 ) \\
&amp; = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n +
\frac { n ^3 + n ^2  } { 2  }
\end{aligned}
\]</span></p>
<p>整理得到$S _n $.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5>
<p>求$_{ i = 1 } ^n i 2 ^i \ $.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n i 2 ^i &amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  }
^i 2 ^i \\
&amp; = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n 2 ^i \\
&amp; = \sum _{ j = 1  } ^n ( 2 ^{ n + 1  } - 2 ^j ) \\
&amp; = n 2 ^{ n + 1  } - ( 2 ^{ n + 1  } - 2 ) \\
&amp; = ( n - 1 ) 2 ^{ n + 1  } + 2
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5>
<p>求$_{ i = 1 } ^n i ^3 \ $.</p>
<h5><span id="solution-3">Solution 3</span></h5>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum _{ i = 1  } ^n i ^3 \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
&amp; = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  }
- \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
&amp; = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } {
3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n (
n + 1 )  } { 12  } \\
S ( n ) &amp; = \frac { n ^2 ( n + 1 ) ^2  } { 4  }
\end{aligned}
\]</span></p>
<h5><span id="exampleex">ExampleEX</span></h5>
<p>求$_{ i = 1 } ^n iq ^i ( q ) $.</p>
<h5><span id="solutionex">SolutionEX</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n iq ^i &amp; = \sum _{ j = 1  } ^n \sum _{ i = j  }
^n q ^i \\
&amp; = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  }
\\
&amp; = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q
^j ) \\
&amp; = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  }
- q  } { q - 1  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="exampleex2">ExampleEX2</span></h5>
<p>求$_{ i = 1 } ^n ( ai + b ) q ^{ i - 1 } ( q ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令$A = { q - 1 } , B = { q - 1 } <span class="math inline">\(,答案为\)</span>( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子$E <span class="math inline">\(，使得\)</span>Ef ( x ) =
f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子$f ( x ) = f ( x + 1 ) - f ( x )
$，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$= E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子$$,可以得到有限微积分的基本定理:</p>
$$
<span class="math display">\[\begin{aligned}
g ( x ) &amp; = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x
&amp; = f ( x ) + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里的$<span class="math inline">\(又被称为不定和式,是差分等于\)</span>g
$的一个函数类.</p>
<p>值得一提的是,这里的$C <span class="math inline">\(与无限微积分中的\)</span>C <span class="math inline">\(有一定区别,这里的\)</span>C <span class="math inline">\(可以是满足\)</span>p ( x ) = p ( x + 1 )
$的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果$g ( x ) = f ( x ) <span class="math inline">\(,那么有\)</span>_{
a } ^b g ( x ) x = f ( x ) | ^{ b } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a b <span class="math inline">\(,显然有\)</span><em>{ a } ^b g ( x ) x = </em>{ x
= a } ^{ b - 1 } g ( x ) \ $.</p>
<p>但如果$a &gt; b <span class="math inline">\(,那么\)</span>_{ a } ^b g
( x ) x = - _b ^a g ( x ) x \ $.</p>
<p>事实上,我们一定有:$_a ^b g ( x ) x + _b ^c g ( x ) x = _a ^c g ( x )
x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1 } $，有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( x ^{ \underline { m  }  } ) &amp; = mx ^{ \underline { m -
1  }  } \\
\sum mx ^{ \underline { m - 1  }  } \delta x &amp; = x ^{ \underline {
m  }  } + C , m \ne 0 \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的$D ( x ) = { x } $,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( H ( x ) ) &amp; = x ^{ \underline { - 1  }  } &amp; = \frac {
1  } { x + 1  } \\
\sum x ^{ \underline { - 1  }  } \delta x &amp; = H ( x ) + C \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( 2 ^x ) &amp; = 2 ^x , \sum 2 ^x \delta x &amp; = 2 ^x + C \\
\Delta ( c ^x ) &amp; = ( c - 1 ) c ^x , \sum c ^x \delta x &amp; =
\frac { c ^x  } { c - 1  } + C , c \ne 1 \\
\Delta ( c ^{ \underline { x  }  } ) &amp; = \frac { c ^{ \underline { x
+ 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  }
{ c - x  } \delta x &amp; = c ^{ \underline { x  }  } + C , c - x \ne 0
\\

\end{aligned}\]</span>
<p>$$</p>
<p>根据组合数公式,有:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta ( \binom { x  } { k  } ) &amp; = \binom { x  } { k - 1  } \\
\sum \binom { x  } { k - 1  } \delta x &amp; = \binom { x  } { k  } + C
\end{aligned}
\]</span></p>
<h6><span id="example平方和公式">Example(平方和公式)</span></h6>
<p>我们有:$k ^2 = k ^{ } + k ^{ } \ $.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S _{ n - 1  } &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
&amp; = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{
\underline { 1  }  } ) \\
&amp; = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x +
\sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
&amp; = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline
{ 2  }  }  } { 2  }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5>
<p>考虑一阶差分是$f ( x ) = f ( x + 1 ) - f ( x ) <span class="math inline">\(,那么二阶差分就是\)</span>^2 f ( x ) = f ( x + 2 )
- 2 f ( x + 1 ) + f ( x ) $.</p>
<p>类似地,我们可以通过归纳法证明$^n f ( x ) = _{ k } { k } ( - 1 ) ^{ n
- k } f ( x + k ) \ $.</p>
<p>事实上有一种更简单的证明方法,由于$= E - 1 <span class="math inline">\(,于是\)</span>^n = ( E - 1 ) ^n = _{ k } { k } ( -
1 ) ^{ n - k } E ^k \ <span class="math inline">\(,由于\)</span>E ^k f (
x ) = f ( x + k ) $,即可证明原式.</p>
<p>另外,不难发现如果$f ( x ) <span class="math inline">\(是一个关于\)</span>x <span class="math inline">\(的\)</span>d <span class="math inline">\(次多项式,那么\)</span>f ( x ) <span class="math inline">\(是一个\)</span>d - 1 <span class="math inline">\(次多项式.同理,\)</span>^d f ( x ) <span class="math inline">\(会是一个常数而\)</span>^{ d + 1 } f ( x ) $会是$0
$,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6>
<p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为$x
_1 , x _2 $.</p>
<p>不难写出期望转移式子:$f <em>i = { 2 } ( f </em>{ i - 1 } + f <em>{ i
+ 1 } ) + 1 <span class="math inline">\(,并且\)</span>f </em>{ x <em>1 }
= f </em>{ x _2 } = 0 $.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1
\\
2 f _i &amp; = f _{ i - 1  } + f _{ i + 1  } + 2 \\
f _i - f _{ i - 1  } &amp; = f _{ i + 1  } - f _i + 2 \\
\Delta f _{ i - 1  } &amp; = \Delta f _{ i  } + 2 \\
\Delta f _i - \Delta f _{ i - 1  } &amp; = - 2 \\
\Delta ^2 f _{ i - 1  } &amp; = - 2
\end{aligned}
\]</span></p>
<p>$f <span class="math inline">\(的二阶差分是常数,也就是说\)</span>f
<span class="math inline">\(是二次多项式,不难求得其二次项系数为\)</span>- 1
<span class="math inline">\(又知道两个零点,显然可以得到\)</span>f
$的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5>
<p>令$f ( x ) = _{ 0 i d } a <em>i x ^i \ <span class="math inline">\(.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为\)</span>f
( x ) = </em>{ 0 i d } b _i x ^{ } \ $.</p>
<p>我们设$c _i = i ! b <em>i <span class="math inline">\(,于是有:\)</span>f ( x ) = </em>{ 0 i d } c _i { i
} \ $.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为$f
( x ) $的牛顿级数.</p>
于是不难发现有:$^n f ( x ) = _{ 0 i d } c _i { i - n } \ <span class="math inline">\(.如果我们令\)</span>x = 0 <span class="math inline">\(,则有:\)</span>^n f ( 0 ) =
<span class="math display">\[\begin{cases}c _n &amp; n \leq d \\ 0 &amp;
n &gt; d \end{cases}\]</span>
<p><span class="math inline">\(.那么牛顿级数的另一种表示即:\)</span>f (
x ) = _{ 0 i d } ^i f ( 0 ) { d } \ $.</p>
<p>另外,如果我们展开一下$c _n = ^n f ( 0 ) $,我们可以得到公式:</p>
<p>$<em>{ k } { k } ( - 1 ) ^k ( </em>{ 0 i n } c _i { i } ) = ( - 1 )
^n c _n , n \ $.</p>
<p>如果我们将多项式还原,由于$a _n = b _n $,有:</p>
<p>$<em>{ k } { k } ( - 1 ) ^k ( </em>{ 0 i n } a _i k ^i ) = ( - 1 ) ^n
n ! a _n , n \ $.</p>
<p>另外,如果$x <span class="math inline">\(,那么我们有:\)</span>f ( x )
= _{ 0 k } ^k f ( 0 ) { 0 } <span class="math inline">\(,根据多项式推理法,这个公式对\)</span>x
$都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<p><span class="math display">\[
g ( a + x ) = \sum _{ 0 \leq k  } \cfrac { \Delta ^k g ( a )  } { k !  }
x ^{ \underline { k  }  }
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>求$_{ k } { k } { n } ( - 1 ) ^k , n \ $.</p>
<p>如果我们令$f ( k ) = { n } = _{ 0 i n } a _i k ^i \ <span class="math inline">\(,不难发现\)</span>a _n = { n ! } <span class="math inline">\(,于是显然原式\)</span>= s ^n $.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v &amp; = Ev \Delta u + u
\Delta v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p>$u v = uv - Ev u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i &amp; = a _r
b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i +
1  } - b _i ) \\
\sum _{ i = l  } ^{ r - 1  } ( \Delta a _i ) b _i &amp; = a _r b _r - a
_l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( \Delta b _i )
\end{aligned}
\]</span></p>
<p>对于$l = 0 , r = n , a _0 = b _0 = 0 $的特殊情况,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i &amp; = a _n b _n -
\sum _{ i = 0  } ^{ n - 1  } a _{ i + 1  } ( \Delta b _i ) \\
\sum _{ i = 1  } ^n a _i ( b _{ i + 1  } - b _i ) &amp; = a _n b _n -
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i
\end{aligned}
\]</span></p>
<p>取两组数列$, <span class="math inline">\(,并令\)</span>_{ i = 1 } ^n
_i = B _i $,立刻有:</p>
<p><span class="math display">\[
\sum _{ i = 1  } ^n \alpha _i \beta _i = \alpha _n B _n - \sum _{ i =
1  } ^{ n - 1  } ( \alpha _{ i + 1  } - \alpha _i ) B _i
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求$_{ k = 0 } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$x 2 ^x x = x 2 ^x - ^{ x + 1 } x = x 2 ^x - 2 ^{ x + 1 } + C \
$.</p>
<p>改为定和式形式，显然有:</p>
<p>$_{ k = 0 } ^n k 2 ^k = _0 ^{ n + 1 } x 2 ^x x = ( n + 1 ) 2 ^{ n + 1
} - 2 ^{ n + 2 } + 2 = ( n - 1 ) 2 ^{ n + 1 } + 2 \ $.</p>
<h6><span id="example2">Example2</span></h6>
<p>求$_{ k = 0 } ^{ n - 1 } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = { 2 } x ^{ } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$xH _x x = { 2 } H _x - { 4 } + C \ $.</p>
<p>带入即可求出原式$= { 2 } ( H _n - { 2 } ) \ $.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6>
<p>求$_{ i = 1 } ^n { i ( i + 1 ) } \ $.</p>
<h6><span id="solution-3">Solution 3</span></h6>
<p>令$u = ( 2 n + 1 ) , v = - { i } <span class="math inline">\(,则\)</span>u = 2 , v = { i ( i + 1 ) } $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } &amp; = ( 2 n +
3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( -
\frac { 2  } { i + 1  } ) \\
&amp; = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n
+ 1  } &amp; = 2 H _n - \frac { n  } { n + 1  }
\end{aligned}
\]</span></p>
<h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6>
<p>求$_{ i = 0 } ^{ n - 1 } { ( k + 1 ) ( k + 2 ) } \ $.</p>
<h6><span id="solution-4">Solution 4</span></h6>
<p>令$u = H _n , v = - { n + 1 } , u = { n + 1 } , v = { ( n + 1 ) ( n +
2 ) } \ $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  }
&amp; = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( -
\frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } (
\frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  }
{ n + 1  } ) \\
&amp; = 1 - \frac { H _n + 1  } { n + 1  }
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心与构造</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="贪心">贪心</span></h2>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了$t <span class="math inline">\(个消息\)</span>a _1 , a _2 , . . . , a _t <span class="math inline">\(,那么答案就是\)</span> { t } <span class="math inline">\(.显然如果\)</span>t <span class="math inline">\(固定,那么每个\)</span>a _j <span class="math inline">\(的贡献是独立的.于是只需要枚举\)</span>t
$然后取贡献最大的.</p>
<p>但是,如果$t &gt; { k _i } <span class="math inline">\(,这个时候\)</span>t - 1 <span class="math inline">\(的答案是\)</span>t - 1 <span class="math inline">\(个数之和除以\)</span>t - 1 <span class="math inline">\(,\)</span>t <span class="math inline">\(的答案是这\)</span>t - 1 <span class="math inline">\(个数之和加上另一个更小的数除以\)</span>t
$,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度$O ( n { k _i } ) $.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分($b <em>{ i , j } = a </em>{ i , j } a <em>{ i +
1 , j } a </em>{ i , j + 1 } a _{ i + 1 , j + 1 }
$)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是$0
$了,那么矩阵外不可能是$1 $,也就是原矩阵也全都是$0 $了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成$0
$才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对$( x , y ) <span class="math inline">\(使用操作四,那我们不可能再对一个\)</span>( x , i )
$使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有$b <em>{ x , y } , b </em>{ n , y } , b
<em>{ x , m } $都是$1
$的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个$1
$,所以一定不如直接用一操作来的划算.不然,如果三个都是$1 <span class="math inline">\(,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后\)</span>b
</em>{ n , m } $变成$1 $了,再不行也可以使用一次$1 $操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果$b
<em>{ x , y } , b </em>{ n , y } , b _{ x , m } $都是$1 <span class="math inline">\(,我们就把\)</span>x <span class="math inline">\(到\)</span>y
$连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i
$条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最小值,\)</span>g _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最大值.假设我们目前二分的最大值要小于等于\)</span>mx
<span class="math inline">\(,最小值要大于等于\)</span>mn
$,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i + 1  } &amp; = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } &amp; = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$f <span class="math inline">\(与\)</span>g <span class="math inline">\(的转移是无关的,而显然对于第\)</span>i <span class="math inline">\(个分界点,它可以取\)</span>[ f _i , g _i ]
$中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans <em>{ i } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(条分界线是啥,那么我们\)</span>ans <em>i <span class="math inline">\(是可以取\)</span>[ ans <em>{ i + 1 } - mx , ans
</em>{ i + 1 } - mn ] <span class="math inline">\(中的任何一个数字的,我们将其和上面求出的\)</span>[
f _i , g _i ] <span class="math inline">\(求一下交集.如果交集为空,说明要么\)</span>ans
</em>{ i + 1 } - mn &lt; f <em>i , f </em>{ i + 1 } &lt; ans </em>{ i +
1 } &lt; f _i + mn <span class="math inline">\(,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差\)</span>mx
- mn $.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对$( l , r ) <span class="math inline">\(,我们想给每一个点对赋值:\)</span>a _l = i , a
<em>r = n - i + 1 <span class="math inline">\((注意如果\)</span>n <span class="math inline">\(是奇数,那么中心点应该是\)</span>a </em>{ mid } = {
2 } $),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对$( l _1 , r _1 ) <span class="math inline">\(,\)</span>( l _2 , r _2 ) <span class="math inline">\(之间的三种可能的关系:不交,包含,相交且不包含.会发现若\)</span>l
<span class="math inline">\(小则让\)</span>a _l $尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个$ <span class="math inline">\(操作很奇怪.我们不妨这么考虑:设最后的答案序列为\)</span>b
<span class="math inline">\(,那么答案其实就是\)</span>| b _i - a _i |
<span class="math inline">\(.这实际上是什么呢?实际上是数轴上\)</span>a
_i <span class="math inline">\(和\)</span>b _i <span class="math inline">\(之间的距离.既然这样,那么我们同时反转\)</span>a
<span class="math inline">\(和\)</span>b <span class="math inline">\(,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个\)</span>a
<span class="math inline">\(,将它和\)</span>x <span class="math inline">\(同时反转,那么答案不变.这么做后我们可以直接清空所有\)</span>a
<span class="math inline">\(的最高位,只剩下\)</span>x $可能有最高位.</p>
<p>那$x <span class="math inline">\(的最高位一定会让若干\)</span>a <span class="math inline">\(往上变成它.注意到最多只会有一个\)</span>a <span class="math inline">\(会向上满足\)</span>x <span class="math inline">\(的最高位.证明的话同样考虑取反,如果有两个\)</span>a
<span class="math inline">\(满足\)</span>a _i b _i <span class="math inline">\(和\)</span>a _j b _j $这一位是$1 <span class="math inline">\(,我们仍然考虑数轴,有\)</span>| not ( b _i ) - a _i
| | a _i - b _i | <span class="math inline">\(,这由\)</span>a _i b _i
$最高位是$1 $导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个$a <span class="math inline">\(上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的\)</span>a
$可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作$[ l , r , k ] <span class="math inline">\(表示可以将\)</span>a [ l r ] <span class="math inline">\(减一进行至多\)</span>k
$次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个$- 1 <span class="math inline">\(,另一个\)</span>- 2 $,求使得整个序列都小于等于$0
$的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p></li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p></li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p></li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做$( - 2 , -
1 ) <span class="math inline">\(,最后不够了再加个\)</span>( - 1 , - 2 )
$补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候$( - 1 , - 2 ) + ( - 1
, - 2 ) <span class="math inline">\(比\)</span>( - 2 , - 1 )
$更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做$( - 2 , - 1 )
<span class="math inline">\(,最后不够了再加个\)</span>( - 1 , - 2 )
<span class="math inline">\(补一下.我们通过样例以及其它栗子发现:有的时候\)</span>(
- 1 , - 2 ) + ( - 1 , - 2 ) <span class="math inline">\(比\)</span>( - 2
, - 1 ) <span class="math inline">\(更优秀,这启发我们:能不能在做后面位置的时候将前面的\)</span>(
- 2 , - 1 ) <span class="math inline">\(变成\)</span>( - 1 , - 2 ) + ( -
1 , - 2 ) <span class="math inline">\(呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个\)</span>(
- 2 , - 1 ) <span class="math inline">\(操作,那么我可以在这个位置进行一个\)</span>( 0 , -
3 ) <span class="math inline">\(操作.显然\)</span>( 0 , - 3 ) + ( - 2 ,
- 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2 ) $.我们完成了反悔的操作!</p>
<p>但是,我们直接认为$( - 1 , - 2 ) <span class="math inline">\(不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个\)</span>(
- 1 , - 2 ) + ( - 1 , - 2 ) <span class="math inline">\(,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑\)</span>(
- 3 , 0 ) <span class="math inline">\(怎么反悔.这个看上去很疑惑:我们为了使\)</span>( - 2
, - 1 ) <span class="math inline">\(变成\)</span>( - 1 , - 2 ) + ( - 1 ,
- 2 ) <span class="math inline">\(而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在\)</span>(
- 2 , - 1 ) $的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:$( - 3 , 0 ) <span class="math inline">\(这个技能的发动是有前提条件的:前面必须有\)</span>(
- 2 , - 1 ) <span class="math inline">\(才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个\)</span>(
- 2 , - 1 ) <span class="math inline">\(,也很清楚每个地方用了几个\)</span>( - 3 , 0 )
$.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:$( - 3 , 0 ) ( - 1 , - 2
) + ( - 2 , - 1 ) = ( - 3 , 0 ) + ( 0 , - 3 ) <span class="math inline">\(,或者\)</span>( - 3 , 0 ) ( - 1 , - 2 ) + ( - 1 ,
- 2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3 ) $.</p>
<p>最后遇到一个点,能用$( 0 , - 3 ) <span class="math inline">\(就用\)</span>( 0 , - 3 ) <span class="math inline">\(,不够用的再补齐.这个原因也很简单:如果我们在这里不用\)</span>(
- 3 , 0 ) <span class="math inline">\(而用其它的代替的话,你会发现无论如何都等价于\)</span>(
- 3 , 0 ) $然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的$(
- 2 , - 1 ) <span class="math inline">\(和\)</span>( - 1 , - 2 ) <span class="math inline">\(的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的\)</span>(
- 3 , 0 )
$操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为$n <span class="math inline">\(的序列\)</span>a <span class="math inline">\(,保证\)</span>a _1 = a _n = 1 <span class="math inline">\(.每次你可以选择一个\)</span>i ( 1 &lt; i &lt; n )
<span class="math inline">\(将\)</span>a <em>i <span class="math inline">\(删去并付出\)</span>a </em>{ i - 1 } a <em>i a
</em>{ i + 1 } <span class="math inline">\(的代价.删去\)</span>a _i
$后序列两端会接起来,求删成两个$1 $的最小代价.</p>
<p>首先注意到,如果有一个$1 &lt; i &lt; n <span class="math inline">\(满足\)</span>a _i = 1
$,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要$1
$的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个$1
<span class="math inline">\(所划分.接下来我们只考虑中间所有数\)</span>
$的情况.</p>
<p>再思考一个事实:当$a , b <span class="math inline">\(时,一定有\)</span>ab a + b <span class="math inline">\(.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是\)</span><em>{
i = 2 } ^{ n - 2 } a <em>i a </em>{ i + 1 } + </em>{ i = 2 } ^{ n - 1 }
{ a _i }
$.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造$a
$数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值$a _i
$,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑$a _i <span class="math inline">\(互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数\)</span>$还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在$a <em>i <span class="math inline">\(相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的\)</span>(
a <em>i , a </em>{ i + 1 } ) <span class="math inline">\(,然后这么选:\)</span>a <em>i , a </em>{ i + 1 } ,
a <em>n , a </em>{ i - 1 } , a </em>{ n - 1 } , a _{ i - 2 } . . .
$,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在$a _i
$上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是$a <span class="math inline">\(和\)</span>b $,其中$2 a &lt; b <span class="math inline">\(.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果\)</span>b
<span class="math inline">\(之前吃过别的鱼,假设是\)</span>c <span class="math inline">\(和\)</span>d <span class="math inline">\((不妨假设\)</span>d c <span class="math inline">\(),有\)</span>b = c + d <span class="math inline">\(,由鸽笼原理,发现\)</span>d &gt; a <span class="math inline">\(.这意味着:如果\)</span>a <span class="math inline">\(都没被操作掉,那么\)</span>d <span class="math inline">\(必不可能被操作掉,这也就是说\)</span>b <span class="math inline">\(不可能出现.因此\)</span>b <span class="math inline">\(在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于\)</span>b
<span class="math inline">\(,且\)</span>a <span class="math inline">\(就是所有一开始小于\)</span>b $的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是$w
<em>i &gt; 2 </em>{ j = 1 } ^{ i - 1 } w _j
$,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多$w <span class="math inline">\(个,我们考虑一下这个两倍的用处,我们按照值域\)</span>[
1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , . . . , [ 2 ^{ k - 1 } + 1
, 2 ^k ]
$将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定$n
$个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><p>$S $表示标准球.</p></li>
<li><p>$&lt; A , B &gt; <span class="math inline">\(表示称量集合\)</span>A <span class="math inline">\(和集合\)</span>B <span class="math inline">\(,\)</span>&lt; A , B &gt; = 0 <span class="math inline">\(表示平衡,\)</span>&lt; A , B &gt; = A <span class="math inline">\(表示\)</span>A <span class="math inline">\(较重,\)</span>&lt; A , B &gt; = B <span class="math inline">\(表示\)</span>B $较重.</p></li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量$x <span class="math inline">\(有\)</span>n <span class="math inline">\(种取值,出现概率分别为\)</span>p _1 , p _2 , , p _n
<span class="math inline">\(,则其熵为\)</span>H ( x ) = f ( p _1 , p _2
, , p _n ) = <span class="math inline">\(,\)</span>C $为正整数,通常取$1
$.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量$x <span class="math inline">\(的一个熵为\)</span>h <span class="math inline">\(的信息后,\)</span>x <span class="math inline">\(的熵会减少\)</span>h $.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有$n
<span class="math inline">\(个球,每个球等概率成为次品,因此总熵是\)</span>n
<span class="math inline">\(,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是\)</span>
<span class="math inline">\(,也就是说我们至少要猜\)</span> { } = _3 n
<span class="math inline">\(次.如果我们不知道次品的轻重,那么至少要猜\)</span>
{ } = _3 2 n $次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p>$n <span class="math inline">\(个叶子的树的最小深度是\)</span>_3 n
$,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设$f ( n ) <span class="math inline">\(表示有\)</span>n <span class="math inline">\(个球的最少次数,注意到\)</span>f ( 3 ) = 1 $.</p>
<p>根据信息论,$f ( n ) _3 n $,下面证明等号成立:</p>
<p>首先考虑证明$f ( 3 ^m ) = m <span class="math inline">\(,\)</span>m =
1 <span class="math inline">\(时已经得证.\)</span>m &gt; 1 <span class="math inline">\(时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此\)</span>f
( 3 ^m ) f ( 3 ^{ m - 1 } ) + 1 <span class="math inline">\(.综合信息论下界\)</span>f ( 3 ^m ) m <span class="math inline">\(,我们不难得出以上结论.至于\)</span>n ^m <span class="math inline">\(的情况,我们类似这个过程按照\)</span>n <span class="math inline">\(的值讨论一下即可,于是有\)</span>f ( n ) f ( { 3 }
) + 1 $.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,$f ( n ) _3 2 n $.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有$n <span class="math inline">\(个球,第二堆有\)</span>m <span class="math inline">\(个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是\)</span>g
( n , m ) <span class="math inline">\(,则\)</span>g ( n , m ) = _3 ( n +
m ) $.</p>
<p>先证明信息论下界,不难发现仍然是$g ( n , m ) = _3 ( n + m ) $.</p>
<p>首先不难发现,$g ( 1 , 0 ) = g ( 0 , 1 ) = 0 , g ( 1 , 1 ) = g ( 2 , 0
) = g ( 0 , 2 ) = 1 $.</p>
<p>仍然使用数学归纳,假设$n + m &lt; k ( k ) <span class="math inline">\(的时候成立,我们接下来证明\)</span>n + m = k
$的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若$n = 3 p , m = 3 q <span class="math inline">\(,我们将\)</span>n
<span class="math inline">\(分成等数量的三堆:\)</span>A _1 , B _1 , C _1
<span class="math inline">\(,将\)</span>m <span class="math inline">\(分成等质量的三堆\)</span>A _2 , B _2 , C _2 $.</p>
<p>接下来称量$A _1 + A _2 , B _1 + B _2 $.</p>
<ol type="1">
<li><p>如果$A _1 + A _2 , B _1 + B _2 = 0 <span class="math inline">\(,那么答案在\)</span>C _1 C _2 <span class="math inline">\(中,此时有\)</span>g ( n , m ) = g ( { 3 } , { 3 }
) + 1 $.</p></li>
<li><p>如果$A _1 + A _2 , B _1 + B _2 = A _1 + A _2 <span class="math inline">\(,由于若次品在\)</span>A _2 <span class="math inline">\(中,那么它不可能是重球,因此次品不可能在\)</span>A
_2 <span class="math inline">\(中,同理不可能在\)</span>B _1 <span class="math inline">\(中,只可能在\)</span>A _1 B _2 <span class="math inline">\(中,此时有\)</span>g ( n , m ) = g ( { 3 } , { 3 }
) + 1 $.</p></li>
<li><p>$A _1 + A _2 , B _1 + B _2 = B _1 + B _2 $,同理.</p></li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p>$n = 3 p + 1 , m = 3 q + 2 <span class="math inline">\(.此时我们将第一堆分成\)</span>A _1 ( p ) , B _1 (
p ) , C _1 ( p + 1 ) <span class="math inline">\(,将第二堆分成\)</span>A
_2 ( q + 1 ) , B _2 ( q + 1 ) , C _2 ( q ) <span class="math inline">\(,然后\)</span>A _1 + A _2 , B _1 + B _2 <span class="math inline">\(,接下来和情况1一样,于是有\)</span>g ( n , m ) = {
g ( p , q + 1 ) , g ( p + 1 , q ) } = _3 { 3 } + 1 $.</p>
<p>同理,当$n , m $的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论$n $的值.</p>
<p><strong>情况1</strong></p>
<p>当$n = 3 p <span class="math inline">\(时,直接分成\)</span>A ( p ) ,
B ( p ) , C ( p ) <span class="math inline">\(,然后\)</span>A , B <span class="math inline">\(.如果平衡则接下来需要\)</span>f ( p ) = _3 2 p
<span class="math inline">\(次,不然根据引理,需要\)</span>_3 ( p + p )
<span class="math inline">\(次,因此\)</span>f ( n ) = _3 2 p + 1 = _3 6
p = _3 2 n $.</p>
<p><strong>情况2</strong></p>
<p>当$n = 3 p + 1 <span class="math inline">\(时,一种自然的想法是分成\)</span>A ( p + 1 ) , B (
p ) , C ( p )
$,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了$2 p
+ 2 , 2 p , 2 p <span class="math inline">\(,这显然是不优秀的.正确的做法是分成\)</span>A = { S
, 1 , p } , B = { p + 1 , p + 1 } , C = { 2 p + 2 , p + 1 } <span class="math inline">\(.由于存在标准球,此时如果\)</span>A , B = A  or  B
<span class="math inline">\(,那么转化成\)</span>g ( p , p + 1 ) = _3 ( 2
p + 1 ) <span class="math inline">\(,不然转化成\)</span>f ( p ) = _3 2 p
$.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有$n
= 1 <span class="math inline">\(的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题\)</span>f
( n ) = _3 ( 2 n + 2 ) $.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将$a <span class="math inline">\(个球放左边,\)</span>b <span class="math inline">\(个球放右边,\)</span>a b <span class="math inline">\(,在左边补上\)</span>b - a $个标准球.</p>
<ol type="1">
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要$_3
( a + b ) + 1 $步.</p></li>
<li><p>如果天平平衡,需要$f ( n - a - b ) + 1 $步.</p></li>
</ol>
<p>我们有$f ( n ) = _{ a , b } { { f ( n - a - b ) , _3 ( a + b ) } } +
1 $.</p>
<p>注意到接下来的步数只与$a + b <span class="math inline">\(有关,取\)</span>b - a
$,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到$f ( n ) = _3 ( 2 n - 1 ) $.</p>
<p>接下来归纳法就简单了,只需要对于$n <span class="math inline">\(的余数讨论一下,然后再讨论一下\)</span>a
$的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求$n
<span class="math inline">\(所在位置.要求询问次数\)</span> . 5 _2 n
<span class="math inline">\(,询问区间总长度\)</span> n $.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设$T ( n ) <span class="math inline">\(表示长度为\)</span>n
$的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程$T ( n ) = _{ m &lt; n } { { T ( m ) + 1 , T ( n -
m ) + 2 } } $.</p>
<p>当然有$m <em>n m </em>{ n + 1 } $,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3>
<h4><span id="模型1">模型1</span></h4>
<p>给定$n <span class="math inline">\(个元素\)</span>x _1 , . . . , x
<em>n <span class="math inline">\(,以及一个定义域为这些元素的序列,定义域为有序集合的函数\)</span>F
<span class="math inline">\(.求出对于所有的\)</span>n <span class="math inline">\(阶排列\)</span>p <span class="math inline">\(,表达式\)</span>F ( { x </em>{ p <em>1 } , x
</em>{ p <em>2 } , . . . , x </em>{ p _n } } ) $最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定$n <span class="math inline">\(个二元正整数对\)</span>( a _i , b
_i ) <span class="math inline">\(,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的\)</span>a
<span class="math inline">\(乘上序列中这个二元组之后的所有二元组的\)</span>b
<span class="math inline">\(之和的总和,求最小代价.\)</span>n , a _i , b
_i ^6 $.</p>
<p>转化为上面的形式,也即:$F ( { ( a _1 , b _1 ) , . . . , ( a _n , b
<em>n ) } ) = </em>{ 1 i &lt; j k } a _i b _j $.</p>
<p>考虑调整法,令排列$( q _1 , . . . , q <em>n ) = ( p <em>1 , . . . , p
</em>{ i - 1 } , p </em>{ i + 1 } , p <em>i , p </em>{ i + 2 } , . . . ,
p _n ) $.则:</p>
<p><span class="math display">\[
F ( \{ ( a _{ p _1  } , b _{ p _1  } ) , . . . , ( a _{ p _n  } , b _{ p
_n  } ) \} ) - F ( \{ ( a _{ q _1  } , b _{ q _1  } ) , . . . , ( a _{ q
_n  } , b _{ q _n  } ) \} ) = a _{ p _i  } b _{ p _{ i + 1  }  } - a _{
p _{ i + 1  }  } b _{ p _i  }
\]</span></p>
<p>因而如果$a <em>{ p <em>i } b </em>{ p </em>{ i + 1 } } - a <em>{ p
</em>{ i + 1 } } b _{ p <em>i } &gt; 0 <span class="math inline">\(,则\)</span>F ( { ( a </em>{ p <em>1 } , b </em>{
p <em>1 } ) , . . . , ( a </em>{ p <em>n } , b </em>{ p <em>n } ) } )
&gt; F ( { ( a </em>{ q <em>1 } , b </em>{ q <em>1 } ) , . . . , ( a
</em>{ q <em>n } , b </em>{ q _n } ) } ) <span class="math inline">\(,也就是说\)</span>( p <em>1 , . . . , p <em>n )
<span class="math inline">\(不是最优解.因此只有满足\)</span> i &lt; n
<span class="math inline">\(,\)</span> { b </em>{ p <em>i } } { b </em>{
p </em>{ i + 1 } } } $可能是最优解.</p>
<p>如果一个$p <span class="math inline">\(满足这样的性质,则所有\)</span>
{ b } <span class="math inline">\(相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换\)</span>
{ b } <span class="math inline">\(相等的两个位置,是不会使答案改变的.因此直接按照\)</span>
{ b } $排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为$S <span class="math inline">\(,定义\)</span>S
<span class="math inline">\(上的一种二元比较关系\)</span>$,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li><p>强完全性:$a , b S <span class="math inline">\(,\)</span>a b b a =
1 $.</p></li>
<li><p>传递性:$a , b , c S <span class="math inline">\(,\)</span>a b , b
c a c $.</p></li>
<li><p>$a , b S <span class="math inline">\(,如果\)</span>a b <span class="math inline">\(,则对于任意一个包含\)</span>{ a , b } <span class="math inline">\(作为子段的元素序列\)</span>{ s <em>1 , . . . , s
</em>{ k - 1 } , a , b , s _{ k + 2 } , . . . , s <em>n } <span class="math inline">\(和\)</span>{ s <em>1 , . . . , s </em>{ k - 1 } ,
b , a , s </em>{ k + 2 } , . . . , s <em>n } <span class="math inline">\(都有:\)</span>F ( { s <em>1 , . . . , s </em>{ k -
1 } , a , b , s </em>{ k + 2 } , . . . , s <em>n } ) F ( { s <em>1 , . .
. , s </em>{ k - 1 } , b , a , s </em>{ k + 2 } , . . . , s _n } )
$.</p></li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义$<span class="math inline">\(后自然也就定义了\)</span>=
$,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到$$的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定$n <span class="math inline">\(个包含小写字符的字符串\)</span>s
_1 , . . . , s <em>n <span class="math inline">\(,找到一个\)</span>n
<span class="math inline">\(阶排列\)</span>p <span class="math inline">\(,将\)</span>s </em>{ p <em>1 } , s </em>{ p <em>2
} , . . . , s </em>{ p _n } <span class="math inline">\(顺序拼接得到\)</span>S <span class="math inline">\(,使\)</span>S $的字典序最小.</p>
<p>令$s t <span class="math inline">\(当且仅当\)</span>s + t <span class="math inline">\(的字典序\)</span>$t+s</p>
<p>此时我们注意到:$s + t <span class="math inline">\(的字典序小于等于\)</span>t + s <span class="math inline">\(的字典序当且仅当\)</span>s ^{ } t ^{ } <span class="math inline">\(.原因是:不妨设\)</span>s <span class="math inline">\(的长度\)</span>t <span class="math inline">\(的长度.若\)</span>s <span class="math inline">\(不是\)</span>t <span class="math inline">\(的前缀,那显然只需比较\)</span>t <span class="math inline">\(的前缀和\)</span>s <span class="math inline">\(的字典序即可,此时上面两个条件等价;若\)</span>s
<span class="math inline">\(是\)</span>t <span class="math inline">\(的前缀,则我们需要比较\)</span>t <span class="math inline">\(的前缀和\)</span>t <span class="math inline">\(的后缀,注意到\)</span>t <span class="math inline">\(的前缀还是\)</span>s <span class="math inline">\(,于是需要比较\)</span>s <span class="math inline">\(和\)</span>t $的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有$n <span class="math inline">\(个箱子,第\)</span>i <span class="math inline">\(个箱子有重量\)</span>w _i <span class="math inline">\(和承载量\)</span>v _i <span class="math inline">\(,\)</span>( w _i , v _i &gt; 0 )
$,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化$_{ i = 1 } ^n { v <em>i - </em>{ j = 1 } ^{ i - 1 } w _j }
<span class="math inline">\(,并判断是否\)</span> $.</p>
<p>我们令$b _i = - ( v _i + w _i ) , a _i = - v <em>i <span class="math inline">\(,则我们要最大化\)</span>{ </em>{ j = 1 } ^{ i - 1
} b <em>i - </em>{ j = 1 } ^i a _i } $.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义$x y <span class="math inline">\(当且仅当\)</span>F ( { x ,
y } ) F ( { y , x } ) <span class="math inline">\(,那么对于两个元素\)</span>( a _1 , b _1 ) , ( a _2
, b _2 ) <span class="math inline">\(,显然\)</span>( a _1 , b _1 ) ( a
_2 , b _2 ) <span class="math inline">\(当且仅当\)</span>{ - a _1 , b _1
- a _1 - a _2 } { - a _2 , b _2 - a _1 - a _2 }
$.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li><p>都大于等于第一个元素,则相当于$a _1 a _2 b _1 - a _1 $.</p></li>
<li><p>都大于等于第二个元素,则相当于$b _1 b _2 b _2 - a _2 $.</p></li>
</ol>
<p>可能这里后面和$0
$比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对$b - a $的符号进行讨论:</p>
<ol type="1">
<li><p>若$sgn ( b _1 - a _1 ) &gt; sgn ( b _2 - a _2 )
$,则不等式成立.</p></li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 1 <span class="math inline">\(,则不等式成立当且仅当\)</span>a _1 a _2
$.</p></li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 0
$,则不等式成立.</p></li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = - 1 <span class="math inline">\(,则不等式成立当且仅当\)</span>b _1 b _2
$.</p></li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时$b _1 = a _1 <span class="math inline">\(,\)</span>b _2 = a _2 <span class="math inline">\(,两条件必有一真.(1)则是因为此时满足\)</span>b _1 -
a _1 &gt; b _2 - a _2 sgn ( b _1 - a _1 ) sgn ( b _2 - a _2 ) <span class="math inline">\(.也就有\)</span>a _2 - a _1 &gt; b _2 - b _1 b _1
a _1 b _2 a _2 $.怎么着都能成立.</p>
<p>由此发现,对于$sgn ( b - a ) $相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<p><span class="math display">\[
\begin{aligned}
( a _1 , b _1 ) &amp; \leq ( a _2 , b _2 ) \\
\Updownarrow \\
( sgn ( b _1 - a _1 ) &amp; &gt; sgn ( b _2 - a _2 ) ) \\
\lor ( sgn ( b _1 - a _1 ) &amp; = sgn ( b _2 - a _2 ) \land F ( \{ 1 ,
2 \} ) &amp; \leq F ( \{ 2 , 1 \} )
\end{aligned}
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定$n <span class="math inline">\(个元素\)</span>x _1 , . . . , x
<em>n <span class="math inline">\(,以及一个定义域为这些元素的序列,值域为有序集合的函数\)</span>F
<span class="math inline">\(.求出对于给定整数\)</span>k <span class="math inline">\(,所有的\)</span>n <span class="math inline">\(阶排列\)</span>p <span class="math inline">\(的长度为\)</span>k <span class="math inline">\(的子序列,表达式\)</span>F ( { x </em>{ p <em>1 } ,
x </em>{ p <em>2 } , . . . , x </em>{ p _k } } ) $最小值.</p>
<p>如果$k = n <span class="math inline">\(,则就是模型1.不然,我们考虑先选出一个大小为\)</span>k
<span class="math inline">\(的子集,然后使用模型1.不难发现,我们最后取出的\)</span>{
x _{ p <em>1 } , x </em>{ p <em>2 } , . . . , x </em>{ p _k } } <span class="math inline">\(一定是\)</span>n = k
$时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有$n <span class="math inline">\(个物品,第\)</span>i <span class="math inline">\(个物品有非负费用\)</span>c _i <span class="math inline">\(和价值\)</span>v _i $,两个人进行如下博弈:</p>
<ol type="1">
<li><p>第一个人要么选择一个物品,付出$c _i
$的代价;要么选择结束游戏.</p></li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行$k
<span class="math inline">\(次);也可以选择不操作,此时第一个人获得\)</span>v _i
$的收益,博弈结束.</p></li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.$(
n . 5 ^5 , k ) $</p></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择$k + 1 <span class="math inline">\(个,然后收益为\)</span><em>{ i = 1 } ^{ k - 1 } { v
</em>{ x <em>i } - </em>{ j = 1 } ^i c _{ x _j } } <span class="math inline">\((如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度\)</span>O
( n n + nk ) $.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有$n
$条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有$n <span class="math inline">\(条直线的答案,求\)</span>n + 1
$条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度$a _1 , , a _n { 90 , 270 } <span class="math inline">\(,要求构造一个\)</span>n <span class="math inline">\(边形(边必须平行于坐标轴),使得其内角依次是\)</span>a
_1 , , a _n $.</p>
<p>首先有解条件显然是判定它们的和是否是$180 ( n - 2 ) $.</p>
<p>注意到相邻的$90 $和$270
$无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让$S T <span class="math inline">\(.这个时候可以找一个中间状态\)</span>A <span class="math inline">\(,让\)</span>S A , T A $.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有$( X , 0 ) <span class="math inline">\(亮着,每次把\)</span>( x , y ) <span class="math inline">\(,\)</span>( x , y + 1 ) <span class="math inline">\(,\)</span>( x + 1 , y )
$状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p>$n ^5 <span class="math inline">\(,坐标的绝对值均\)</span> ^{ 17 }
$.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线$y = - inf <span class="math inline">\(,然后比对.我们注意到\)</span>( X , 0 ) <span class="math inline">\(向下推的过程类似一个组合数递推的过程,由经典公式\)</span>
{ T } <span class="math inline">\(可知,我们取\)</span>inf = 2 ^{ 63 } -
1 $即可.然后最后在这条线上一定是有一个区间是$1
$,我们需要找到区间左端点,我们选择在直线上随便找到一个$1 <span class="math inline">\(,由于\)</span>inf $很大,大于$10 ^{ 17 }
$,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,$n ^4 <span class="math inline">\(,但是初始点可能是\)</span>( X , Y ) $.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点$( j , - inf ) <span class="math inline">\(和\)</span>( k , - inf ) <span class="math inline">\(是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出\)</span>X
<span class="math inline">\(和\)</span>Y <span class="math inline">\(.而上述条件满足当且仅当\)</span>[ j - X Y + inf ]
$.</p>
<p>如果我们随便找一个点$( p , - inf ) <span class="math inline">\(满足条件,那我们接下来只需要枚举\)</span>w <span class="math inline">\(,判断\)</span>( p - 2 ^w , - inf )
$是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间$[ l , r ]
$中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2>
<p>参考:https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3>
<h4><span id="eps">eps</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$ = | | | | = x _a x _b + y _a y _b <span class="math inline">\(.也就等于\)</span> <span class="math inline">\(在\)</span>b <span class="math inline">\(上的投影与\)</span> $的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol type="1">
<li><p>如果$ = 0 <span class="math inline">\(,则说明\)</span>
$.</p></li>
<li><p>如果$ &gt; 0 <span class="math inline">\(,则说明\)</span> <span class="math inline">\(和\)</span> $正方向的夹角小于$90 $.</p></li>
<li><p>如果$ &lt; 0 <span class="math inline">\(,则说明\)</span> <span class="math inline">\(和\)</span> $正方向的夹角大于$90 $.</p></li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$ = x _a y _b - y _a x _b <span class="math inline">\(.也就等于\)</span> ,
$两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol type="1">
<li><p>如果$ = 0 $,说明二者共线.</p></li>
<li><p>如果$ &lt; 0 <span class="math inline">\(,说明从\)</span> <span class="math inline">\(到\)</span> $的方向是顺时针.</p></li>
<li><p>如果$ &gt; 0 <span class="math inline">\(,说明从\)</span> <span class="math inline">\(到\)</span> $的方向是逆时针.</p></li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
也就是将这个竖向量乘左乘旋转矩阵$
<span class="math display">\[\begin{bmatrix}\cos \theta &amp; - \sin
\theta \\ \sin \theta &amp; \cos \theta \end{bmatrix}\]</span>
<p>$.</p>
<h4><span id="line">Line</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下$x _{ L <em>1 } , x </em>{ L <em>2 } , y </em>{ L
<em>1 } , y </em>{ L _2 } <span class="math inline">\(围成的四边形,计算面积后用等高不等底计算.注意\)</span>ls
<span class="math inline">\(和\)</span>rs
$所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4>
<p>利用叉乘,任取平面上一点$O <span class="math inline">\(,则\)</span>S =
{ 2 } _{ i = 1 } ^n <span class="math inline">\(.证明的话考虑分\)</span>O <span class="math inline">\(在内部和\)</span>O <span class="math inline">\(在外部两种情况分类讨论.注意此时的\)</span>P
$必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为$a
<span class="math inline">\(,它的边上(包括顶点)的整点数为\)</span>b
<span class="math inline">\(,则它的面积\)</span>S = a + { 2 } - 1 $.</p>
<h3><span id="基本算法">基本算法</span></h3>
<h4><span id="排序算法">排序算法</span></h4>
<h5><span id="极角排序">极角排序</span></h5>
<p>定义原点$O <span class="math inline">\(并建立坐标系,所有点按照和\)</span>O <span class="math inline">\(所连直线与\)</span>x $轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$x <span class="math inline">\(相同比\)</span>y <span class="math inline">\(,否则比\)</span>x $.</p>
<h4><span id="二维凸包">二维凸包</span></h4>
<h5><span id="定义">定义</span></h5>
<p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5>
<p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否$ABC <span class="math inline">\(三点是一个上凸的(注意\)</span>ABC
$三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5>
<p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4>
<p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5>
<p>两个区域$A , B <span class="math inline">\(的闵可夫斯基和定义为\)</span>{ a + b a A , b B }
$.</p>
<h5><span id="实现">实现</span></h5>
<p>事实上,新的区域所形成的凸包,一定是原本$A , B
$的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下$A , B <span class="math inline">\(,使得\)</span>B
<span class="math inline">\(有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是\)</span>B
<span class="math inline">\(这个边加上\)</span>A <span class="math inline">\(的最右边的点.这样这条边必定还在最终的凸包上.就算\)</span>A
<span class="math inline">\(最右边的是一条边,你也会发现最终的凸包最右边也一定是由\)</span>A
<span class="math inline">\(的这条边和\)</span>B $的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义半平面为满足$ax + by + c &gt; 0 <span class="math inline">\(或\)</span>ax + by + c <span class="math inline">\(的点对\)</span>( x , y )
$组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5>
<p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2>
<p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3>
<h4><span id="直线">直线</span></h4>
<p>使用直线的方向向量$ = ( n , m , p ) <span class="math inline">\(和直线上一点\)</span>M _0 = ( x _0 , y _0 , z _0 )
$.那么方程显然为:</p>
<p><span class="math display">\[
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z
_0  } { p  }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt
\end{cases}
\]</span></p>
<h4><span id="平面">平面</span></h4>
<p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) <span class="math inline">\(和该平面的法向量\)</span> <span class="math inline">\(来表示一个平面,不妨设\)</span> = ( A , B , C )
$,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0
\]</span></p>
<p>如果我们令$D = - ( Ax _0 + By <em>0 + Cz </em>) $,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h4><span id="夹角">夹角</span></h4>
<h5><span id="两直线夹角">两直线夹角.</span></h5>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$ = ( n _1 , m _1 , p _1 ) , = ( n _2 , m _2 , p _2
) <span class="math inline">\(,也就有\)</span>= ( { | _1 | | _2 | } ) \
$.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5>
<p>同样使用向量,不妨设方向向量$ = ( n , m , p ) <span class="math inline">\(,法向量\)</span> = ( a , b , c ) <span class="math inline">\(,那么\)</span>= ( { | | | | } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p></li>
<li><p>若直线与平面垂直,则$ { m } = { n } = { p }
$.注意这里分母可能除以$0 <span class="math inline">\(,我们实际上应该是三个形如\)</span>a = mt
$的参数方程,这里简化了.</p></li>
</ol>
<h4><span id="交点">交点</span></h4>
<p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>范畴论初步</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2>
<h3><span id="映射">映射</span></h3>
<p>设$A , B <span class="math inline">\(为两个集合,\)</span><span class="math inline">\(称为从\)</span>A <span class="math inline">\(到\)</span>B <span class="math inline">\(的一个**映射**,如果对于任意\)</span>a A <span class="math inline">\(,\)</span>b B , b = ( a ) <span class="math inline">\(.此时\)</span>b <span class="math inline">\(称为\)</span>a <span class="math inline">\(在\)</span><span class="math inline">\(下的像,\)</span>a <span class="math inline">\(称为\)</span>b <span class="math inline">\(在\)</span><span class="math inline">\(下的原像或反像.一般地,这个定义可以拓展到\)</span>S
A <span class="math inline">\(,\)</span>( S ) = { ( a ) a S } <span class="math inline">\(,定义\)</span>^{ - 1 } ( T ) = { a | ( a ) T , a S
} $.</p>
<p>如果$a _1 , a _2 A , a _1 a _2 , ( a _1 ) ( a _2 ) <span class="math inline">\(,称\)</span>$是<strong>单射</strong>.</p>
<p>如果$b B , a A , ( a ) = b <span class="math inline">\(.称\)</span>$为<strong>满射</strong>.</p>
<p>如果$$既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果$A = B <span class="math inline">\(,我们又称\)</span>$为一个<strong>变换</strong>.</p>
<p>设$f : A B , g : B A $,那么:</p>
<ol type="1">
<li><p>如果$g f = id _A <span class="math inline">\(,称\)</span>g <span class="math inline">\(是\)</span>f <span class="math inline">\(的一个**左逆**,不难发现\)</span>f <span class="math inline">\(存在左逆当且仅当\)</span>f $是单射.</p></li>
<li><p>如果$f g = id _B <span class="math inline">\(,称\)</span>g <span class="math inline">\(是\)</span>f <span class="math inline">\(的一个**右逆**,不难发现\)</span>f <span class="math inline">\(存在右逆当且仅当\)</span>f $是满射.</p></li>
<li><p>如果$g <span class="math inline">\(既是\)</span>f <span class="math inline">\(的左逆又是\)</span>f <span class="math inline">\(的右逆,则称\)</span>g <span class="math inline">\(为\)</span>f <span class="math inline">\(的**逆**,不难发现\)</span>f <span class="math inline">\(存在逆当且仅当\)</span>f
$是双射,并且逆唯一.</p></li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3>
<p>集合$A , B <span class="math inline">\(的**笛卡尔积**或**直积**是指\)</span>A <span class="math inline">\(的元素与\)</span>B <span class="math inline">\(的元素构成的有序对的集合,即\)</span>A B = { ( a ,
b ) a A , b B } $.可以推广到多元对.</p>
<p>集合$A <span class="math inline">\(上的一个**二元运算**是由\)</span>A
A <span class="math inline">\(到\)</span>A <span class="math inline">\(的一个映射.对于定义在\)</span>U <span class="math inline">\(上的一个二元运算,不妨用\)</span>+ <span class="math inline">\(来表示,集合\)</span>A , B U <span class="math inline">\(的**闵可夫斯基和**定义为\)</span>A + B = { a + b a
A , b B }
$.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合$A <span class="math inline">\(上的一个**二元关系**\)</span>R
<span class="math inline">\(定义为\)</span>A A <span class="math inline">\(的一个子集(可以理解为满足二元关系的解集),如果\)</span>(
a _1 , a _2 ) R <span class="math inline">\(,就称\)</span>a _1 , a _2
<span class="math inline">\(有关系\)</span>R <span class="math inline">\(,记作\)</span>a _1 Ra _2 $,注意这里有序.</p>
<p>如果$R $满足以下三个性质:</p>
<ol type="1">
<li><p>反身性:$a A , aRa $.</p></li>
<li><p>对称性:$a _1 Ra _2 a _2 Ra _1 $.</p></li>
<li><p>传递性:$a _1 Ra _2 , a _2 Ra _3 a _1 Ra _3 $.</p></li>
</ol>
<p>则称$R <span class="math inline">\(是一个**等价关系**,不难发现满足等价关系的元素构成了若干个集合,称作**等价类**.等价关系通常记作\)</span>$.</p>
<p>如果将等价关系的(2)改作:</p>
<ol start="2" type="1">
<li>反对称性:$a _1 Ra _2 , a _2 Ra _1 a _1 = a _2 $.</li>
</ol>
<p>则称$R
$是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$$.</p>
<h4><span id="保序映射">保序映射</span></h4>
<p>对于映射$f : A B <span class="math inline">\(,如果\)</span>a , a ’ A
, a a ’ f ( a ) f ( a ’ ) $,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4>
<p>对于偏序集$( A , R ) $来说,定义:</p>
<ol type="1">
<li><p>链:$A ’ A , x , y A ’ , [ xRy yRx ] = 1 $.</p></li>
<li><p>反链:$A ’ A , x , y A ’ , [ xRy yRx ] = 0 $.</p></li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p></li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,$| A | $显然成立.</p>
<p>当$| A | &gt; 3
$时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为$d <span class="math inline">\(,下面证明其最小链覆盖也是\)</span>d $.</p>
<p>考虑取一条尽可能长的链$A ’ <span class="math inline">\(,设其中最大的为\)</span>M <span class="math inline">\(,最小的为\)</span>m $(如果有多个就任取一个).</p>
<p>考虑$T = A A ’ <span class="math inline">\(,如果\)</span>T <span class="math inline">\(中的最长反链数小于\)</span>d $,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链$S <span class="math inline">\(,使得\)</span>S A ’ = <span class="math inline">\(.考虑设\)</span>A ^{ + } = { x | x A s S , sRx }
<span class="math inline">\(,\)</span>A ^{ - } = { x | x A s S , xRs }
<span class="math inline">\(.不难发现\)</span>m <span class="math inline">\(一定不在\)</span>| A ^{ + } | <span class="math inline">\(中,不然取出的那条链\)</span>A ’ <span class="math inline">\(可以更长.同理\)</span>M <span class="math inline">\(一定不在\)</span>| A ^{ - } | <span class="math inline">\(中,也即\)</span>| A ^+ | , | A ^- | &lt; | A |
$.</p>
<p>我们又发现$A ^+ A ^- = A
$,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,$S A ^{ + } A ^{ - } $.</p>
<p>由数学归纳,$A ^+ <span class="math inline">\(和\)</span>A ^- <span class="math inline">\(中的最小链覆盖均为\)</span>d <span class="math inline">\(,并且一个以\)</span>S <span class="math inline">\(中元素开头,一个以\)</span>S <span class="math inline">\(中元素结尾,我们把它俩拼起来就是一个大小为\)</span>d
<span class="math inline">\(的新的大小为\)</span>d
$的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4>
<p>考虑定义一种等价关系$<span class="math inline">\(,我们可以在此基础上定义商集\)</span>A / = { [ a ]
| a A } <span class="math inline">\(,其中\)</span>[ a ] <span class="math inline">\(是\)</span>a $所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过$ <span class="math inline">\(来定义\)</span>
$.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系$<span class="math inline">\(,\)</span>( n , m ) ( n ’ , m ’ ) <span class="math inline">\(当且仅当\)</span>n + m ’ = m + n ’
$.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将$ / <span class="math inline">\(定义为整数,更确切地,对于任意一组\)</span>( n , m )
<span class="math inline">\(其代表的就是\)</span>n - m $这个整数.</p>
<p>容易定义加法:$( n , m ) + ( n ’ , m ’ ) = ( n + n ’ , m + m ’ ) <span class="math inline">\(,乘法\)</span>( n , m ) ( n ’ , m ’ ) = ( mm ’ +
nn ’ , mn ’ + m ’ n ) <span class="math inline">\(.也可以定义大小关系\)</span>( n , m ) ( n ’ , m ’
) n + m ’ m + n ’ $.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义$- ( n , m ) = ( m , n ) <span class="math inline">\(即可,容易验证二者之和处于\)</span>( 0 , 0 )
$这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用$ <span class="math inline">\(构造\)</span> <span class="math inline">\(,构造二元组\)</span> _+ <span class="math inline">\(,定义\)</span>( r , s ) ( r ’ , s ’ ) rs ’ = r ’ s
<span class="math inline">\(,容易验证其满足等价关系的性质.实际上其对应的就是\)</span>
{ s } $这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3>
<h4><span id="外延公理">外延公理</span></h4>
<p>$A = B ( A B ) ( B A ) $.</p>
<h4><span id="配对公理">配对公理</span></h4>
<p>对于任意元素$a , b <span class="math inline">\(,存在集合\)</span>{ a
, b } <span class="math inline">\(.特别地,当\)</span>a = b <span class="math inline">\(的时候存在集合\)</span>{ a } $.</p>
<p>值得一提的是可以将数对$( a , b ) <span class="math inline">\(定义为\)</span>{ { a } , { a , b } }
$,下面的幂集公理说明了数对属于$2 ^{ 2 ^{ A B } } , a A , b B $.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4>
<p>对于一个集合$A <span class="math inline">\(,和一个性质\)</span>P
<span class="math inline">\(,若\)</span><span class="math inline">\(满足性质\)</span>P <span class="math inline">\(则称\)</span>P ( ) $.那么存在集合:</p>
<p><span class="math display">\[
\{ x | x \in A \land P ( x ) \}
\]</span></p>
<p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质$P $都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4>
<p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4>
<p>一个集合的所有子集构成一个新的集合(可以记作$2 ^A $).</p>
<h4><span id="无穷公理">无穷公理</span></h4>
<p>称满足以下性质的集合为归纳集:</p>
<ol type="1">
<li><p>$A $.</p></li>
<li><p>若$A <span class="math inline">\(,则\)</span>{ } A $.</p></li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4>
<p>对于集合$A <span class="math inline">\(和一种定义在集合\)</span>A
<span class="math inline">\(上的映射\)</span>F <span class="math inline">\(,存在集合\)</span>A ’ <span class="math inline">\(使得\)</span>x A ’ x = F ( a ) , a A $.</p>
<p>用替换公理可以证明映射也是一种集合,并且从$A B <span class="math inline">\(的所有映射可以构成集合,可以记作\)</span>B ^A
$.</p>
<h4><span id="正则公理">正则公理</span></h4>
<p>对任何非空集合$A <span class="math inline">\(,存在\)</span>a A <span class="math inline">\(使得\)</span>a ’ A <span class="math inline">\(,\)</span>a ’ a <span class="math inline">\(,也就是\)</span>a A = $.</p>
<h4><span id="选择公理">选择公理</span></h4>
<p>说对于任何一族非空集$A <span class="math inline">\(,总能从其中的每个集合\)</span>a $选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5>
<p>如果$X <span class="math inline">\(上的一个偏序关系\)</span><span class="math inline">\(,满足其每条链\)</span>A <span class="math inline">\(都存在上界(\)</span>x X , a A , x a <span class="math inline">\(),那么\)</span>X <span class="math inline">\(存在极大元\)</span>( x X , a X , a x a = x )
$.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系$( A ’ ’ , g ’ ’ ) (
A ’ , g ’ ) <span class="math inline">\(当且仅当\)</span>A ’ ’ A ’ <span class="math inline">\(并且\)</span>x A ’ ’ , g ’ ’ ( x ) = g ’ ( x )
<span class="math inline">\(.这样拿出来的极大元就是我们需要的\)</span>A
g ( A ) $.</p>
<h5><span id="良序定理">良序定理</span></h5>
<p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对$( S , R ) <span class="math inline">\(组成的集合,其中满足\)</span>S <span class="math inline">\(对于偏序关系\)</span>R <span class="math inline">\(来说是良序的,我们定义两个二元对\)</span>a , b
<span class="math inline">\(满足\)</span>a b <span class="math inline">\(当且仅当它们的\)</span>R <span class="math inline">\(相等并且\)</span>S _a S _b <span class="math inline">\(.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)\)</span>(
S , R ) <span class="math inline">\(,注意到如果\)</span>S <span class="math inline">\(是全集则证毕,如果不是,则取一个全集中不在\)</span>S
<span class="math inline">\(的元素\)</span>x <span class="math inline">\(接到\)</span>S
$的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3>
<p>如果存在单射$: A B <span class="math inline">\(,则称\)</span>| A | |
B | <span class="math inline">\(.如果存在双射,则称\)</span>| A | = | B |
$.</p>
<p>如果使用选择公理的话,可以说明如果存在满射$: A B <span class="math inline">\(,则称\)</span>| A | | B | $.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有$A , B <span class="math inline">\(两个集合,接下来我们证明一定存在一个从\)</span>A
<span class="math inline">\(到\)</span>B
$的映射,且其要么为单射要么为满射.</p>
<p>我们记$X <span class="math inline">\(为所有\)</span>A <span class="math inline">\(的子集到\)</span>B <span class="math inline">\(的单射组成的集合,并且我们定义这样一种偏序关系:若\)</span>f
: A _f B , g : A _g B , A _f A _g , a A _f , f ( a ) = g ( a ) $.</p>
<p>这样的话,我们不妨取出$X <span class="math inline">\(的一个全序的子集\)</span>I $,显然其存在上界.</p>
<p>根据Zorn引理,$X <span class="math inline">\(存在极大元\)</span>g : A
_g B $,此时我们开始讨论:</p>
<p>如果$A _g = A <span class="math inline">\(,那么找到了一个单射\)</span>g : A B $.</p>
<p>反之,如果$A _g A <span class="math inline">\(,考虑如果\)</span>g ( A
_g ) = B <span class="math inline">\(,也就是找到了一个满射;反之,考虑取\)</span>a ’ A A
_g , b ’ B g ( A _g ) <span class="math inline">\(,在\)</span>g <span class="math inline">\(的基础上加上映射\)</span>a ’ b ’ <span class="math inline">\(,这是一个比\)</span>g
$还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4>
<p>如果$| A | | B | | B | | A | <span class="math inline">\(,则\)</span>| A | = | B | $.</p>
<p>不妨设$f : A B , g : B A <span class="math inline">\(我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用\)</span>f
, f ^{ - 1 } <span class="math inline">\(来构造双射,只有一种除外:那就是以一个\)</span>B
<span class="math inline">\(中节点开始不断延伸的无限的,我们在这里使用\)</span>g
, g ^{ - 1 } $来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取$C <em>0 = B f (
A ) <span class="math inline">\(,\)</span>C <em>n = f ( g ( C </em>{ n -
1 } ) ) <span class="math inline">\(,那么对于\)</span>C = </em>{ n } C
_n <span class="math inline">\(,使用\)</span>g , g ^{ - 1 } <span class="math inline">\(构造双射,剩下的使用\)</span>f , f ^{ - 1 }
$构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4>
<p>我们称集合$A <span class="math inline">\(是**可数**的,当且仅当\)</span>| A | = | | $.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是$0
$)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为$1 $和$0 $显然都是代数数.</p>
<p>我们接下来看两个代数数$x , y <span class="math inline">\(.考虑如何构造\)</span>x + y $作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<p><span class="math display">\[
\begin{aligned}
X &amp; = \sum _{ k = 0  } ^n a _k x ^k &amp; = 0 \\
Y &amp; = \sum _{ k = 0  } ^m b _k y ^k &amp; = 0
\end{aligned}
\]</span></p>
<p>对于加法,考虑:$( x + y ) ^0 , ( x + y ) ^1 , <span class="math inline">\(,这些东西,先把它们对\)</span>X <span class="math inline">\(取膜再对\)</span>Y <span class="math inline">\(取膜,得到的一定是\)</span>nm <span class="math inline">\(维的,只需要取\)</span>nm + 1 <span class="math inline">\(个就会出现线性相关.乘法同理考虑\)</span>( xy ) ^0
, ( xy ) ^1 , $即可.</p>
<p>值得一提的是,$| | = 2 ^{ | | } <span class="math inline">\(.这个是怎么构造的呢?只需要证明\)</span>[ 0 , 1 ]
<span class="math inline">\(上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果\)</span>k
<span class="math inline">\(在取出的自然数子集中,那么小数点后第\)</span>k + 1
$位为$1 $否则为$0 $,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是$0 . 1 = 0 . 0111 <span class="math inline">\(,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明\)</span>|
| ^{ | | } <span class="math inline">\(并且\)</span>| | ^{ | | }
$,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2>
<h3><span id="范畴">范畴</span></h3>
<p>一个<strong>范畴</strong>$ $应当包含以下:</p>
<ol type="1">
<li><p>一个类$\rm { Ob } ( ) <span class="math inline">\(,其元素称作\)</span>
$的<strong>对象</strong>.</p></li>
<li><p>对于$X , Y \rm { Ob } ( ) <span class="math inline">\(指定一个集合\)</span> _{ } ( X , Y ) <span class="math inline">\(,称作\)</span> <span class="math inline">\(中从\)</span>X <span class="math inline">\(到\)</span>Y $的<strong>态射</strong>.</p></li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol type="1">
<li><p>对于$X ( ) <span class="math inline">\(存在其到自身的**恒等态射**\)</span> <em>X </em>{ }
( X , X ) $.</p></li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong>$: <em>{ }
( Y , Z ) </em>{ } ( X , Y ) _{ } ( X , Z ) , ( g , f ) g f $.</p></li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol type="1">
<li><p><strong>结合律</strong>:对于$ <span class="math inline">\(中的态射\)</span>h , g , f <span class="math inline">\(,如果合成有意义,那么\)</span>h ( gf ) = ( hg ) f
$.</p></li>
<li><p><strong>单位元</strong>:对于$f _{ } ( X , Y ) <span class="math inline">\(,\)</span>f _X = f = _Y f $.</p></li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有$ _X = _X _X
= _X $.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<p><span class="math display">\[
\xymatrix { R \ar [r ] ^u \ar [d ] _x &amp; S \ar [d ] ^v \\
T \ar [r ] _y &amp; U  }
\]</span></p>
<p>这意味着$yx = vu $.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol type="1">
<li><p>如果对于$f ( X , Y ) <span class="math inline">\(,\)</span>g ( Y
, X ) <span class="math inline">\(使得\)</span>gf = _X <span class="math inline">\(,那么称\)</span>g <span class="math inline">\(是\)</span>f <span class="math inline">\(的一个**左逆**,称\)</span>f
$是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p></li>
<li><p>如果$f <span class="math inline">\(左右均可逆,易见左右逆相等,记作\)</span>f ^{ - 1 }
<span class="math inline">\(,易见\)</span>f ^{ - 1 } <span class="math inline">\(可逆而且\)</span>( f ^{ - 1 } ) ^{ - 1 } = f <span class="math inline">\(.此时称\)</span>f
$是<strong>同构</strong>的.</p></li>
</ol>
<p>同构还有以下性质:</p>
<ol type="1">
<li><p>$( _X ) ^{ - 1 } = _X $.</p></li>
<li><p>如果$f <span class="math inline">\(和\)</span>g <span class="math inline">\(均为同构并且合成有意义,那么\)</span>gf <span class="math inline">\(是同构并且\)</span>( gf ) ^{ - 1 } = f ^{ - 1 } g
^{ - 1 } $.</p></li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol type="1">
<li><p>自同态幺半群:$ <em>{ } ( X ) = </em>{ } ( X , X ) $.</p></li>
<li><p>自同构群:$ <em>{ } ( X ) = ( </em>{ } ( X ) ) ^$.</p></li>
</ol>
<p>如此起名的原因是由抽象代数知识见到$ <span class="math inline">\(对二元运算\)</span><span class="math inline">\(构成幺半群,\)</span> $则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称$ ’ <span class="math inline">\(是\)</span> $的子范畴当且仅当:</p>
<ol type="1">
<li><p>$ ( ’ ) ( ) $.</p></li>
<li><p>$X , Y ( ’ ) <span class="math inline">\(都有\)</span> <em>{ ’ }
( X , Y ) </em>{ } ( X , Y ) $.</p></li>
<li><p>$X ( ’ ) <span class="math inline">\(,\)</span> _X = _X ’
$.</p></li>
<li><p>态射在$ ’ <span class="math inline">\(中的合成运算应从\)</span>
$中继承而来.</p></li>
</ol>
<p>特别地,如果$X , Y ( ’ ) , ( X , Y ) <em>{ ’ } = </em>{ } ( X , Y )
<span class="math inline">\(,则称\)</span> ’ <span class="math inline">\(是\)</span> $的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3>
<p>如果$ <span class="math inline">\(是一个范畴,其中有一个元素\)</span>X
( ) <span class="math inline">\(,如果\)</span>Y ( { } ) <span class="math inline">\(,\)</span>| <em>{ } ( X , Y ) | = 1 <span class="math inline">\(,则称它是始(initial)的.类似地,如果对于\)</span>Y (
) <span class="math inline">\(,\)</span>X ( ) <span class="math inline">\(,\)</span>| </em>{ } ( X , Y ) | = 1 <span class="math inline">\(,则称\)</span>Y $是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol type="1">
<li><p>如果$X , X ’ ( ) <span class="math inline">\(都是initial的,则存在一个唯一的同构\)</span>a : X X
’ $.</p></li>
<li><p>如果$Y , Y ’ ( ) <span class="math inline">\(都是terminal的,则存在一个唯一的同构\)</span>b : Y
Y ’ $.</p></li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3>
<p>我们定义从$ ’ <span class="math inline">\(到\)</span> <span class="math inline">\(的**函子**\)</span>F $需要有以下性质:</p>
<ol type="1">
<li><p>$X ( ’ ) <span class="math inline">\(,指定一个\)</span> <span class="math inline">\(中的对象\)</span>FX <span class="math inline">\(.或记作\)</span>F : ( ’ ) ( ) $.</p></li>
<li><p>$X , Y ( ’ ) <span class="math inline">\(,对于态射\)</span>f : X
Y <span class="math inline">\(指定一个\)</span> <span class="math inline">\(中的对象\)</span>Ff <span class="math inline">\(.或记作\)</span>F : <em> ’ ( X , Y ) </em> ( FX ,
FY ) $.</p></li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol type="1">
<li><p>$g , f _{ ’ } <span class="math inline">\(,它们的合成有意义,则\)</span>F ( gf ) = F ( g ) F
( f ) $.</p></li>
<li><p>$X ( ’ ) <span class="math inline">\(,\)</span>F ( <em>X ) =
</em>{ FX } $.</p></li>
</ol>
<p>我们一般也将上述函子记作$F : ’
$.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然$F $可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol type="1">
<li><p>如果$T ( ) , X ( ’ ) <span class="math inline">\(使得\)</span>T
FX <span class="math inline">\(,则称\)</span>F
$是<strong>本质满</strong>的.</p></li>
<li><p>如果$X , Y ( ’ ) <span class="math inline">\(,\)</span>F : <em>{
’ } ( X , Y ) </em>{ } ( FX , FY ) <span class="math inline">\(均为单射,则称\)</span>F
$是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p></li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓$
$函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴$ <span class="math inline">\(以及其对象\)</span>X <span class="math inline">\(,我们定义函子\)</span> <em>{ } ( X , ) : Set <span class="math inline">\(,它映对象\)</span>Y <span class="math inline">\(为集合\)</span> </em>{ } ( X , Y ) <span class="math inline">\(,映态射\)</span>f : Y Z <span class="math inline">\(为映射\)</span> <em>{ } ( X , ) f : </em>{ } ( X ,
Y ) _{ } ( X , Z ) , h f h $.</p>
<p>同理可以定义函子$ _{ } ( , X ) $.</p>
<p>对于函子$ _{ } ( X , ) $,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3>
<h4><span id="kleisli范畴">Kleisli范畴</span></h4>
<p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol type="1">
<li><p>加上修饰.</p></li>
<li><p>合并修饰.</p></li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2>
<h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3>
<p>定义下降幂$x ^{ } = _{ i = 0 } ^{ k - 1 } ( x - i ) = { ( x - k ) ! }
$.</p>
<p>定义上升幂$x ^{ } _{ i = 0 } ^{ k - 1 } ( x + i ) = { ( x - 1 ) ! }
$.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:$r ^{ } ( r - 0 . 5 ) ^{ } = { 2 ^{ 2 k } } , k
$.</p>
<p>他们之间存在转换:$x ^{ } = ( - 1 ) ^n ( - x ) ^{ } $.</p>
<p>同时存在大小关系:$x ^{ } x ^n x ^{ } $,其中$0 n &lt; x $.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3>
<p>考虑令$ { m } <span class="math inline">\(表示从一个大小为\)</span>n
<span class="math inline">\(的子集中选出大小为\)</span>m <span class="math inline">\(的子集的方案数.第一次有\)</span>n <span class="math inline">\(个选择,第二次有\)</span>n - 1 <span class="math inline">\(个选择......第m次有\)</span>n - m + 1 <span class="math inline">\(个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是\)</span>m
! <span class="math inline">\(,因此显然有\)</span> { m } = { m ! }
$.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
$ { k } =
<span class="math display">\[\begin{cases}\cfrac { r ^{ \underline {
k  }  }  } { k !  } &amp; k \geq 0 \\ 0 &amp; k &lt; 0
\end{cases}\]</span>
<p>, r , k $.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把$ { k } <span class="math inline">\(看作了一个关于\)</span>r <span class="math inline">\(的\)</span>k $次多项式.</p>
<p>另外根据定义,$r r &lt; k $时,该公式给出$0 $.</p>
<p>值得一提的是,为了使二项式系数在面对$0 $的时候更加简洁,通常直接定义$0
! = 1 , 0 ^0 = 1 $.</p>
<p>另外不难发现$ { n } <span class="math inline">\(是所有\)</span> { k }
<span class="math inline">\(中最大的.事实上我们有Wallis公式:\)</span>_{
n } { 2 n + 1 } = { 2 } $.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3>
<ol type="1">
<li>阶乘展开式:$ { k } = { k ! ( n - k ) ! } , n , k , n k \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="2" type="1">
<li>对称恒等式:$ { k } = { n - k } , n , k \ $.</li>
</ol>
<p>根据$( 1 ) $,$0 k n $时是显然的.而其他情况两边都会给出$0
$,因此也是成立的.</p>
<ol start="3" type="1">
<li>吸收恒等式:$ { k } = { k } { k - 1 } , k k \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="4" type="1">
<li>吸收恒等式的变式:$k { k } = r { k - 1 } , k \ $.</li>
</ol>
<p>根据$( 3 ) <span class="math inline">\(,只需要验证\)</span>k = 0
$的情况即可,也是显然的.</p>
<ol start="5" type="1">
<li>相伴恒等式:$( r - k ) { k } = r { k } , k \ $.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
( r - k ) \binom { r  } { k  } &amp; = ( r - k ) \binom { r  } { r -
k  } \\
&amp; = r \binom { r - 1  } { r - k - 1  } \\
&amp; = r \binom { r - 1  } { k  }
\end{aligned}
\]</span></p>
<p>问题在于:我们在上述描述中并未提到$r <span class="math inline">\(的范围,但是推导过程要求\)</span>r <span class="math inline">\(.不过,我们已经说明了二项式系数是关于\)</span>r
<span class="math inline">\(的\)</span>k <span class="math inline">\(次多项式,因此只需要有\)</span>k + 1 <span class="math inline">\(个\)</span>r <span class="math inline">\(满足这个公式即可.而根据推导过程显然有无限个\)</span>r
<span class="math inline">\(满足,因此这个公式对\)</span>r
$也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<p><span class="math display">\[
\begin{aligned}
k \binom { r  } { k  } &amp; = r \binom { r - 1  } { k - 1  } \\
( r - k ) \binom { r  } { r - k  } &amp; = r \binom { r - 1  } { r - k -
1  } \\
( r - k ) \binom { r  } { k  } &amp; = r \binom { r - 1  } { k  }
\end{aligned}
\]</span></p>
<ol start="6" type="1">
<li>加法公式:$ { k } = { k } + { k - 1 } , k \ $.</li>
</ol>
<p>证明可以使用定义,也可以先用$r
$的情况给出组合意义,再使用多项式推理法证明.</p>
<ol start="7" type="1">
<li>$ { m } { k } = { k } { m - k } , n , k \ $.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol start="8" type="1">
<li>平行求和法:$_{ k n } { k } = { n } , n \ $.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p>$ { n } = { n } + { n - 1 } = { n } + { n - 1 } + { n - 2 } = . . . \
$,最终下标会减成负数,这样后面的项就全都是$0 $了.</p>
<p>也可以考虑组合意义:如果$r <span class="math inline">\(,那么我们考虑从右到左第一个没有被选上的数,假设它是\)</span>r
+ k + 1 <span class="math inline">\(,那么在它右边的数全部选择了,一共是\)</span>n - k
<span class="math inline">\(个数,而还需要在左边的\)</span>r + k <span class="math inline">\(中选择\)</span>k $个数.</p>
<ol start="9" type="1">
<li>上指标求和法:$_{ 0 k n } { m } = { m + 1 } , n , m \ $.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是$k + 1 <span class="math inline">\(,接下来就还需要在\)</span>[ 1 , k ] <span class="math inline">\(中选择\)</span>m $个.</p>
<p>如果我们将这个公式两边同时乘以$m ! <span class="math inline">\(,我们可以得到公式:\)</span>_{ 0 k n } k ^{ } = { m
+ 1 } , n , m \ $,这也就是有限微积分的公式中的一个.</p>
<ol start="10" type="1">
<li>二项式定理:$( x + y ) ^r = _{ k } { k } x ^k y ^{ r - k } , r \
$.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 0 \leq k \leq n  } \binom { n  } { k  } &amp; = 2 ^n , n \in
\mathbb { N  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令$x = y = 1 $即可证明.</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 0 \leq k \leq n  } ( - 1 ) ^k \binom { n  } { k  } &amp; = 0 ^n
&amp; = [ n &amp; = 0 ] , n \in \mathbb { N  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令$x = - 1 , y = 1 <span class="math inline">\(即可证明,值得一提的是,当\)</span>n = 0
$的时候这个式子给出$1 $,并在其他情况下给出$0
$,这个式子是二项式反演的基础.</p>
<ol start="11" type="1">
<li>三项式定理:$( x + y + z ) ^n = _{ 0 a , b , c n } [ a + b + c = n ]
{ a ! b ! c ! } x ^a y ^b z ^c , n \ $.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,$ { a ! b ! c ! } = { b + c } { c }
$.</p>
<ol start="12" type="1">
<li>多项式定理:$( _{ i = 1 } ^m x <em>i ) ^n = </em>{ i , 0 a <em>i n }
[ _{ i = 1 } ^m a _i = n ] { </em>{ i = 1 } ^m a <em>i ! } </em>{ i = 1
} ^m x _i ^{ a _i } , n \ $.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol start="13" type="1">
<li>范德蒙德卷积:$_{ k } { m + k } { n - k } = { n + m } , n , m \
$.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol start="14" type="1">
<li>范德蒙德卷积的变式:$_{ k } { m + k } { n + k } = { l - m + n } , l ,
n , m \ $.</li>
</ol>
<p>有$ { m + k } = { l - m - k } $,然后运用范德蒙德卷积即可得到答案.</p>
<ol start="15" type="1">
<li>上指标反转公式:$ { k } = ( - 1 ) ^k { k } \ $.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3>
<ol type="1">
<li>$_{ k m } { k } ( - 1 ) ^k = ( - 1 ) ^m { m } , m \ $.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k \leq m  } \binom { r  } { k  } ( - 1 ) ^k &amp; = \sum _{ k
\leq m  } \binom { k - r - 1  } { k  } \\
&amp; = \binom { - r + m  } { m  } &amp; = ( - 1 ) ^m \binom { r - 1  }
{ m  }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li>$_{ - q k l } { m } { n } = { m + n + 1 } , n , m , l + q \ $.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol start="3" type="1">
<li>$_{ k } { a + k } { b + k } ( - 1 ) ^k = { a } , a , b \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="4" type="1">
<li>$_{ k = 0 } ^m { { k } } = { n + 1 - m } , n , m , n m \ $.</li>
</ol>
<p>我们有$ { m } { k } = { k } { m - k } \ <span class="math inline">\(,两边同时除以\)</span> { m } { m - k } \ <span class="math inline">\(,于是我们得到了\)</span> { { k } } = { { m } } \
$.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^m \cfrac { \binom { m  } { k  }  } { \binom { n  } {
k  }  } &amp; = \sum _{ k = 0  } ^m \cfrac { \binom { n - k  } { m -
k  }  } { \binom { n  } { m  }  } \\
&amp; = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m
\binom { n - k  } { m - k  } \\
&amp; = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m
\binom { n - m + k  } { k  } \\
&amp; = \cfrac { \binom { n + 1  } { m  }  } { \binom { n  } { m  }  }
\\
&amp; = \cfrac { n + 1  } { n + 1 - m  }
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li>$( - 1 ) ^m { m } = ( - 1 ) ^n { n } , n , m \ $.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于$ { m } \ $.</p>
<ol start="6" type="1">
<li>$_{ k m } { k } ( { 2 } - k ) = { 2 } { m + 1 } , m \ $.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol start="7" type="1">
<li>$<em>{ k m } { k } x ^k y ^{ m - k } = </em>{ k m } { k } ( - x ) ^k
( x + y ) ^{ m - k } , m \ $.</li>
</ol>
<p>不妨令左边的值为$S _m $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S _m &amp; = \sum _{ k \leq m  } \binom { m + r  } { k  } x ^k y ^{ m -
k  } &amp; = \sum _{ k \leq m  } \binom { m + r - 1  } { k  } x ^k y ^{
m - k  } + \sum _{ k \leq m  } \binom { m + r - 1  } { k - 1  } x ^k y
^{ m - k  } \\
&amp; = y \sum _{ k &lt; m  } \binom { m - 1 + r  } { k  } x ^k y ^{ m -
1 - k  } + \binom { m + r - 1  } { m  } x ^m + x \sum _{ k \leq m  }
\binom { m + r - 1  } { k - 1  } x ^{ k - 1  } y ^{ m - k  } \\
&amp; = ( x + y ) S _{ m - 1  } + \binom { m + r - 1  } { m  } x ^m \\
&amp; = ( x + y ) S _{ m - 1  } + \binom { r  } { m  } ( - x ) ^m
\end{aligned}
\]</span></p>
<p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol start="8" type="1">
<li>$_{ k m } { k } 2 ^{ - k } = 2 ^m , m \ $.</li>
</ol>
<p>考虑$( 7 ) <span class="math inline">\(,将\)</span>x = y = 1 , r = m
+ 1 $带入,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k \leq m  } \binom { 2 m + 1  } { k  } &amp; = \sum _{ k \leq
m  } \binom { m + k  } { k  } 2 ^{ m - k  } \\
2 ^{ 2 m  } &amp; = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ m
- k  } \\
2 ^m &amp; = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ - k  }
\end{aligned}
\]</span></p>
<ol start="9" type="1">
<li>$_{ k } { m + k } { n } ( - 1 ) ^k = ( - 1 ) ^{ l + m } { n - l } ,
l , n , m \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="10" type="1">
<li>$_{ k l } { m } { k - n } ( - 1 ) ^k = ( - 1 ) ^{ l + m } { l - n -
m } , l , n , m \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3>
<ol type="1">
<li>$ { k } { k } = { 2 ^{ 2 k } } , k \ $.</li>
</ol>
<p>将加倍公式两边同时除以$k ! ^2 $即可得到这个公式.</p>
<ol start="2" type="1">
<li>$ { n } = { 2 ^{ 2 n } } , n \ $.</li>
</ol>
<p>将$( 1 ) <span class="math inline">\(中令\)</span>r = k = n
$即可得到这个公式.</p>
<ol start="3" type="1">
<li>$ { n } = ( { 4 } ) ^n { n } , n \ $.</li>
</ol>
<p>即$( 2 ) $的变形.</p>
<ol start="4" type="1">
<li>$_{ k } { 2 k } { k } 2 ^{ - 2 k } = { { 2 } } , n \ $</li>
</ol>
<p>首先根据$( 1 ) <span class="math inline">\(,左边\)</span>= _{ k } { k
} { k } \ <span class="math inline">\(,而考虑到\)</span> { 2 } <span class="math inline">\(和\)</span> { 2 }
$必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol start="5" type="1">
<li>$_{ k } { k } { n - k } = ( - 1 ) ^n , n \ $.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol start="6" type="1">
<li>$_{ k } { k } { n - k } = 4 ^n , n \ $.</li>
</ol>
<p>由$( 5 ) <span class="math inline">\(和\)</span>( 3 ) $不难推出.</p>
<ol start="7" type="1">
<li>$_{ k } { k } { x + k } = x ^{ - 1 } { n } ^{ - 1 } , x { 0 , - 1 ,
. . . , - n } \ $.</li>
</ol>
<p>令$f ( x ) = ( x - 1 ) ^{ } $,直接做高阶差分即可得到这个式子.</p>
<ol start="8" type="1">
<li>$_{ k = 0 } ^n { k } { n - k } ( - 1 ) ^k = [ n  is   ] ( - 1 ) ^{ {
2 } } { { 2 } } \ $.</li>
</ol>
<p>首先不难发现,$( 1 - z ) ^r = _{ k } ( - 1 ) ^k { k } \ $.</p>
<p>考虑$( 1 - z ) ^r ( 1 + z ) ^r = ( 1 - z ^2 ) ^r $.</p>
<p>我们有$[ z ^n ] ( 1 - z ) ^r ( 1 + z ) ^r = [ z ^n ] ( 1 - z ^2 ) ^r
$,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3>
<p>卡特兰数$f _n $表示:长度为$2 n $的合法括号序列个数.</p>
<p>卡特兰数的前几项为$1 , 1 , 2 , 5 , 14 , 42 , 132 $.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:$f <em>n = </em>{ i = 0 } ^{ n - 1 } f <em>i f </em>{ n - 1
- i } $.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如$( A ) B
$.</p>
<p>考虑将其删成$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,则\)</span>A <span class="math inline">\(一定合法,因为若\)</span>A
$不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:$f <em>n = { n + 1 } C </em>{ 2 n } ^n = C <em>{ 2 n } ^n -
C </em>{ 2 n } ^{ n - 1 } $.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从$( 0 , 0 ) <span class="math inline">\(走到\)</span>( 2 n , 0 )
$不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到$( 2 n , 0 ) <span class="math inline">\(的方案数是\)</span>C _{ 2 n } ^n $.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点$( x , - 1 ) $.</p>
<p>考虑将$x <span class="math inline">\(以后的折线以直线\)</span>y = - 1
<span class="math inline">\(为对称轴反转,那么终点到了\)</span>( 2 n , -
2 ) $.</p>
<p>不难发现,任意从$( 0 , 0 ) <span class="math inline">\(走到\)</span>(
2 n , - 2 ) <span class="math inline">\(的方案一定唯一对应了一种从\)</span>( 0 , 0 ) <span class="math inline">\(走到\)</span>( 2 n , 0 ) <span class="math inline">\(的不合法方案.因为从\)</span>( 0 , 0 ) <span class="math inline">\(走到\)</span>( 2 n , - 2 ) <span class="math inline">\(一定会经过直线\)</span>y = - 1 <span class="math inline">\(,将后半部分对称后就是其对应方案.而从\)</span>( 0 ,
0 ) <span class="math inline">\(走到\)</span>( 2 n , - 2 ) <span class="math inline">\(的方案数为\)</span>C _{ 2 n } ^{ n - 1 } $.</p>
<p>因而$f <em>n = C </em>{ 2 n } ^n - C _{ 2 n } ^{ n - 1 } \ $.</p>
<p>而$C <em>{ 2 n } ^n - C </em>{ 2 n } ^{ n - 1 } = { n ! n ! } - { ( n
- 1 ) ! ( n + 1 ) ! } = { n ! ( n + 1 ) ! } = { n + 1 } \ $.</p>
<p>递推定义:$f <em>n = { n + 1 } f </em>{ n - 1 } \ $.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\</p>
<p>f_{n-1}=</p>
<p>\end{cases}\</p>
<p>不难发现$f <em>n = { n ( n + 1 ) } f </em>{ n - 1 } \ <span class="math inline">\(.整理,得到\)</span>f <em>n = { n + 1 } f </em>{ n
- 1 } \ $.</p>
<p>换个记号,设$C _n <span class="math inline">\(为卡特兰数的第\)</span>n
<span class="math inline">\(项,卡特兰数有一个著名的结论是\)</span>k
$次卷积:</p>
<p><span class="math display">\[
C ^{ ( k )  } _n = \sum _{ \sum _{ j = 1  } ^k a _j = n  } \prod C _{ a
_i  } = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  }
\]</span></p>
<p>我们可以这么理解它:它指的是一个长度为$n + k - 1 <span class="math inline">\(的括号序列,前\)</span>k - 1 <span class="math inline">\(个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成\)</span>(
( ( A ) B ) C ) D $之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<p><span class="math display">\[
\begin{aligned}
C ^{ ( k )  } _n &amp; = \binom { 2 n + k - 1  } { n  } - \binom { 2 n +
k - 1  } { n - 1  } \\
&amp; = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  }
\end{aligned}
\]</span></p>
<h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5>
<p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是$
{ n } $.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5>
<p>给定$x , n <span class="math inline">\(,对\)</span>y <span class="math inline">\(,固定\)</span>p _x = y <span class="math inline">\(做笛卡尔树的**形态**计数.\)</span>n ^5 $.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现$a
_x = y $只要满足:</p>
<ol type="1">
<li><p>$x <span class="math inline">\(节点的祖先数量不超过\)</span>y - 1
<span class="math inline">\(个(深度小于等于\)</span>y $).</p></li>
<li><p>$x <span class="math inline">\(节点的子树大小不超过\)</span>n - y
+ 1 $.</p></li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出$f _p <span class="math inline">\(表示\)</span>x
<span class="math inline">\(的深度为\)</span>p <span class="math inline">\(的答案,\)</span>g _p <span class="math inline">\(表示\)</span>x <span class="math inline">\(的子树大小为\)</span>p
$的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:$x <span class="math inline">\(的祖先有两种:一种在序列中在\)</span>x <span class="math inline">\(的左边,一种在\)</span>x $的右边.我们设前者为$0 = l
<em>0 &lt; l <em>1 &lt; l <em>2 &lt; l <em>p &lt; l </em>{ p + 1 } = x
<span class="math inline">\(,设后者为\)</span>n + 1 = r <em>0 &gt; r
<em>1 &gt; r <em>2 &gt; &gt; r </em>{ q } &gt; r </em>{ q + 1 } = x
<span class="math inline">\(.这么分类有什么用呢?我们考虑\)</span>( l
</em>{ i - 1 } , l </em>{ i } ) <span class="math inline">\(这一段数能放在哪里,它只能是\)</span>l </em>{ i }
<span class="math inline">\(的左儿子,独立于整棵树,因此这一段的答案就是\)</span>C
</em>{ l <em>i - l </em>{ i - 1 } - 1 } $.</p>
<p>记:</p>
$$
<span class="math display">\[\begin{aligned}
L _p &amp; = \sum _{ l  } \prod _{ i = 1  } ^{ p + 1  } C _{ l _i - l _{
i - 1  } - 1  } \\
R _q &amp; = \sum _{ r  } \prod _{ i = 1  } ^{ q + 1  } C _{ r _{ i -
1  } - r _i - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到这等价于卡特兰数的$k $次卷积,有:</p>
$$
<span class="math display">\[\begin{aligned}
L _p &amp; = C _{ x - p - 1  } ^{ ( p + 1 )  } \\
R _q &amp; = C ^{ ( q + 1 )  } _{ n - x - q  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时的答案自然是$f _{ p + q + 1 } = L _p R _q { q } $,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把$x
<span class="math inline">\(的子树从原树中删去,然后插入\)</span>x <span class="math inline">\(一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为\)</span>p
<span class="math inline">\(,右子树大小为\)</span>q <span class="math inline">\(,我们有\)</span>g _{ p + q + 1 } = C <em>p C <em>q
C </em>{ n - ( p + q + 1 ) } = C </em>{ n - 1 } ^{ ( 3 ) }
$,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3>
<h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求$_{ k = 0 } ^n k { m - n - 1 } , n , m m &gt; n \ $.</p>
<p>这个式子乘了个系数$k <span class="math inline">\(导致很难处理,一个自然的想法是使用吸收恒等式将\)</span>k
$消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } &amp; = \sum
_{ k = 0  } ^n m \binom { m - k - 1  } { m - n - 1  } - \sum _{ k = 0  }
^n ( m - k ) \binom { m - k - 1  } { m - n - 1  } \\
&amp; = m \sum _{ k = 0  } ^{ m - 1  } \binom { m - k - 1  } { m - n -
1  } - ( m - n ) \sum _{ k = 0  } ^m \binom { m - k  } { m - n  }
\end{aligned}
\]</span></p>
<p>不妨令$S <em>m = </em>{ k = 0 } ^m { m - n } \ $,不难发现我们有:</p>
<p><span class="math display">\[
S _m = \sum _{ k = 0  } ^m \binom { k  } { m - n  } = \binom { m + 1  }
{ m - n + 1  }
\]</span></p>
<p>于是原式$= mS _{ m - 1 } - ( m - n ) S _m = { m - n + 1 } { m - n } \
$.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将$k = { 1 }
$带入:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } &amp; = \sum
_{ k = 0  } ^n \binom { k  } { 1  } \binom { m - k - 1  } { m - n - 1  }
\\
&amp; = \binom { m  } { m - n + 1  } \\
&amp; = \cfrac { n  } { m - n + 1  } \binom { m  } { m - n  }
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>求$_{ k } k { k } { k } , n \ $.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到$n <span class="math inline">\(和\)</span>s
$的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k  } k \binom { n  } { k  } \binom { s  } { k  } &amp; = s \sum
_{ k  } \binom { n  } { k  } \binom { s - 1  } { k - 1  } \\
&amp; = s \binom { n + s - 1  } { n - 1  }
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求$_{ 0 k } { 2 k } { k } { k + 1 } , n \ $.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 0 \leq k  } \binom { n + k  } { 2 k  } \binom { 2 k  } { k  }
\cfrac { ( - 1 ) ^k  } { k + 1  } &amp; = \sum _{ 0 \leq k  } \binom { n
+ k  } { k  } \binom { n  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n
\in \mathbb { N  } \\
&amp; = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { n + k  } {
k  } \binom { n + 1  } { k + 1  } { ( - 1 ) ^k  } \\
&amp; = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { - n - 1  }
{ k  } \binom { n + 1  } { k + 1  } \\
&amp; = \cfrac { 1  } { n + 1  } \binom { 0  } { n  } \\
&amp; = [ n &amp; = 0 ]
\end{aligned}
\]</span></p>
<h5><span id="example4">Example4</span></h5>
<p>求$_{ k } { m + 2 k } { k } { k + 1 } , n , m \ $.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的$( 1 ) $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k \geq 0  } \binom { n + k  } { m + 2 k  } \binom { 2 k  } {
k  } \cfrac { ( - 1 ) ^k  } { k + 1  } &amp; = \sum _{ k \geq 0  } \sum
_{ 0 \leq j \leq n + k - 1  } \binom { n + k - 1 - j  } { 2 k  } \binom
{ j  } { m - 1  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k +
1  } \\
&amp; = \sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{
j + 1 - n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom
{ 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  }
\end{aligned}
\]</span></p>
<p>注意到如果$j + 1 - n <span class="math inline">\(,则\)</span> { 2 k }
\ $应为$0 $.所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{ j + 1 -
n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom { 2
k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } \\
&amp; = \sum _{ 0 \leq j &lt; n  } \binom { j  } { m - 1  } [ n - 1 - j
&amp; = 0 ] &amp; = \binom { n - 1  } { m - 1  }
\end{aligned}
\]</span></p>
<h5><span id="example5">Example5</span></h5>
<p>求$_{ k = 0 } ^n ( C _n ^k ) ^2 $.</p>
<p><span class="math display">\[
\sum _{ k = 0  } ^n ( C _n ^k ) ^2 = \sum _{ k = 0  } ^n C _{ n  } ^k
\times C _{ n  } ^{ n - k  } = C _n ^{ 2 n  }
\]</span></p>
<h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求$Q <em>n = </em>{ k ^n } { k } ( - 1 ) ^k , n \ $.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于$Q
_n $的式子中实际上只与$2 ^n <span class="math inline">\(有关,我们不妨令\)</span>R <em>n = </em>{ k n } { k
} ( - 1 ) ^k \ <span class="math inline">\(,显然有\)</span>Q <em>n = R
</em>{ 2 ^n } $.</p>
<p>而我们有:</p>
<p><span class="math display">\[
\begin{aligned}
R _n &amp; = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k
+ \sum _{ k \leq n  } \binom { n - 1 - k  } { k - 1  } ( - 1 ) ^k \\
&amp; = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k +
\sum _{ k \leq n - 1  } \binom { n - k - 2  } { k  } ( - 1 ) ^{ k + 1  }
\\
&amp; = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k
+ \binom { - 1  } { n  } ( - 1 ) ^n - ( \sum _{ k \leq n - 2  } \binom {
n - 2 - k  } { k  } ( - 1 ) ^k + \binom { - 1  } { n - 1  } ( - 1 ) ^{ n
- 1  } ) \\
&amp; = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k
- \sum _{ k \leq n - 1  } \binom { n - 2 - k  } { k  } ( - 1 ) ^k \\
&amp; = R _{ n - 1  } - R _{ n - 2  } \\
&amp; = R _{ n - 2  } - R _{ n - 3  } - R _{ n - 2  } \\
&amp; = - R _{ n - 3  } \\
&amp; = R _{ n - 6  }
\end{aligned}
\]</span></p>
也即$R _n <span class="math inline">\(具有周期性,不难计算前几项答案,最后有\)</span>Q _n
<span class="math display">\[\begin{cases}1 &amp; n = 0 \\ 0 &amp; n \
is \ \mathrm { odd  } \\ - 1 &amp; n &gt; 0 \land n \ is \ \mathrm {
even  } \end{cases}\]</span>
<p>$.</p>
<h5><span id="example2">Example2</span></h5>
<p>求$( ^{ + } <em>{ i = 0 } C ^{ ik + r } </em>{ nk } ) p $.</p>
<p>考虑设$f ( n , r ) = ^{ + } <em>{ i = 0 } C ^{ ik + r } </em>{ nk } \
$,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n , r ) &amp; = \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{
nk  } \\
&amp; = \sum _{ i = 0  } ^{ + \infty  } \sum _{ j = 0  } ^k C _{ nk -
k  } ^{ ik + r - j  } \times C _k ^j \\
&amp; = \sum ^k _{ j = 0  } C _k ^j \sum _{ i = 0  } ^{ + \infty  } C _{
nk - k  } ^{ ik + r - j  } \\
&amp; = \sum _{ j = 0  } ^k C _k ^j f ( n - 1 , r - j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理上式,得到:$f ( n , r ) = _{ j = 0 } ^k C _k ^j f ( n - 1 , r - j
) \ $.</p>
<p>于是我们得到了关于$f $的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4>
<h5><span id="example">Example</span></h5>
<p>求$_{ k = 1 } ^n k ^2 C _n ^k $.</p>
$$
<span class="math display">\[\begin{aligned}
( ( 1 + x ) ^n ) &amp; = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } ) \\
( ( 1 + x ) ^n ) &#39; &amp; = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } )
&#39; \\
n ( 1 + x ) ^{ n - 1  } &amp; = \sum _{ k = 0  } ^n kC _n ^k x ^{ k -
1  } \\
nx ( 1 + x ) ^{ n - 1  } &amp; = \sum _{ k = 0  } ^n kC _n ^k x ^{ k  }
\\
( nx ( 1 + x ) ^{ n - 1  } ) &#39; &amp; = ( \sum _{ k = 0  } ^n kC _n
^k x ^{ k  } ) &#39; \\
n ( ( 1 + x ) ^{ n - 1  } + ( n - 1 ) x ( 1 + x ) ^{ n - 2  } ) &amp; =
\sum _{ k = 0  } ^n k ^2 C _n ^k x ^{ k - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>取$x = 1 <span class="math inline">\(,则原式\)</span>= n ( n + 1 ) 2
^{ n - 2 } $.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>多次询问给定$k , r <span class="math inline">\(,\)</span>k n , r &lt;
2 n - k <span class="math inline">\(,求\)</span>_{ i = 0 } ^{ r } { 2 ^i
} { n - k } $,.</p>
<p>我们把模型抽象成:在二维平面上,从$( 0 , 0 ) <span class="math inline">\(随机游走到\)</span>( n - k + 1 , r - n + k ) <span class="math inline">\(正下方(包含这个点)的概率,容易发现此时向右走了\)</span>n
- k <span class="math inline">\(步,总共走了\)</span>r <span class="math inline">\(步,然后再向右走一步保证第一次走到了\)</span>( n -
k + 1 , r - n + k ) $下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到$x
+ y = r + 1 <span class="math inline">\(这条直线时横坐标\)</span>n - k +
1 <span class="math inline">\(的概率.枚举一下总共向上走了几步,就得到\)</span> {
2 ^{ r } } _{ j = 0 } ^{ r - n + k } { j } <span class="math inline">\(,注意这里是\)</span> { 2 ^r } <span class="math inline">\(,因为从一开始钦定了一步,因此映射过来需要多乘个\)</span>
{ 2 } $,反映射就要乘个$2 <span class="math inline">\(.但是这个式子还是做不了,因为\)</span>r <span class="math inline">\(并不满足\)</span>r n $.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于$1 - { 2 ^{ r } }
_{ i = 0 } ^{ n - k } { i } <span class="math inline">\(.我们考虑暴力预处理出\)</span>f <em>r = </em>{ i =
0 } ^{ n } { i } <span class="math inline">\(,每次删掉一个后缀的组合数就行.现在的问题在于\)</span>f
$怎么做.</p>
<p>直接拆组合数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f _r &amp; = \sum _{ i = 0  } ^n \binom { r  } { i  } \\
&amp; = \sum _{ i = 0  } ^n \binom { r - 1  } { i - 1  } + \sum _{ i =
0  } ^n \binom { r - 1  } { i  } \\
&amp; = 2 \sum _{ i = 0  } ^n \binom { r - 1  } { i  } - \binom { r -
1  } { n  } \\
&amp; = 2 f _{ r - 1  } - \binom { r - 1  } { n  }
\end{aligned}
\]</span></p>
<h3><span id="lucas定理">Lucas定理</span></h3>
<p>若$p <span class="math inline">\(是质数,则\)</span>C <em>n ^m p = C
</em>{ n p } ^{ m p } C _{ { p } } ^{ { p } } p \ $.</p>
<p>或者说,将$n <span class="math inline">\(和\)</span>m <span class="math inline">\(在\)</span>p $进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若$i <span class="math inline">\(且\)</span>i p <span class="math inline">\(,\)</span>C <em>{ p } ^i { i } C </em>{ p - 1 } ^{
i - 1 } ( p ) \ $.</p>
<p>而根据二项式定理,$( 1 + x ) ^p <em>{ i = 0 } ^p C </em>{ p } ^i x ^i
= 1 + x ^p ( p ) \ $.</p>
<p>令$n = k _1 p + b _1 <span class="math inline">\(,\)</span>m = k _2 p
+ b _2 <span class="math inline">\(,则\)</span>( 1 + x ) ^n = ( 1 + x )
^{ k _1 p } ( 1 + x ) ^{ b _1 } \ $.</p>
<p>而$( 1 + x ) ^{ k _1 p } ( 1 + x ^p ) ^{ k _1 } ( p ) \ <span class="math inline">\(,有\)</span>( 1 + x ) ^n ( 1 + x ^p ) ^{ k _1 } (
1 + x ) ^{ b _1 } \ $.</p>
<p>根据二项式定理,$C _n ^m p <span class="math inline">\(即\)</span>x ^m
$项的系数.</p>
<p>我们可以得出,$C <em>n ^m x ^m C </em>{ k _1 } ^{ k _2 } x ^{ k <em>2
p } C </em>{ b 1 } ^{ b _2 } x ^{ b _2 } \ <span class="math inline">\(,那么有\)</span>C <em>a ^b C </em>{ k _1 } ^{ k
<em>2 } C </em>{ b _1 } ^{ b _2 } \ $.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<p><span class="math display">\[
\binom { n  } { m  } \equiv [ m \subseteq n ] \pmod { 2  }
\]</span></p>
<h5><span id="example1cf1770fkoxia-andsequence">Example1([CF1770F]Koxia and
Sequence)</span></h5>
<p>首先观察样例并思考,可以发现当$n
$为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是$0
$),所以异或值为$0 <span class="math inline">\(.不然,我们可以翻转\)</span>a [ 2 . . . n ] <span class="math inline">\(,得出答案应该是所有\)</span>a _1 $的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有$y
’ y <span class="math inline">\(,求出满足\)</span>a _i y ’ , a _i = x
<span class="math inline">\(时,\)</span>a _1
$异或和.接下来怎么做呢?我们考虑拆位,若$2 ^k y ’ <span class="math inline">\(,假设\)</span>a _1 <span class="math inline">\(的第\)</span>k $位是$1
$,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第$k $位贡献是:</p>
<p><span class="math display">\[
[ 2 ^k \subseteq y &#39; ] \bigoplus _{ \sum a = x  } [ 2 ^k \subseteq a
_1 ] \prod _{ i = 1  } ^n [ a _i \subseteq y &#39; ]
\]</span></p>
<p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:$[ x y ] {
x } $.</p>
<p>所以原式化简为:</p>
$$
<span class="math display">\[\begin{aligned}
\binom { y &#39;  } { 2 ^k  } \sum _{ \sum a = x  } \binom { a _1  } { 2
^k  } \prod _{ i = 1  } ^n \binom { y &#39;  } { a _i  } \pmod { 2  } \\
&amp; = \binom { y &#39;  } { 2 ^k  } \sum _{ a _1  } \binom { y &#39; -
2 ^k  } { a _1 - 2 ^k  } \sum _{ \sum a = x - a _1  } \prod _{ i = 2  }
^n \binom { y &#39;  } { a _i  } \pmod { 2  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
\binom { y &#39;  } { 2 ^k  } \sum _{ a _1  } \binom { y &#39; - 2 ^k  }
{ a _1 - 2 ^k  } \binom { ( n - 1 ) y &#39;  } { x - a _1  } \pmod {
2  } \\
&amp; = \binom { y &#39;  } { 2 ^k  } \binom { ny &#39; - 2 ^k  } { x -
2 ^k  } \pmod { 2  } \\
&amp; = [ 2 ^k \subseteq y &#39; ] [ ( x - 2 ^k ) \subseteq ( ny &#39; -
2 ^k ) ]
\end{aligned}
\]</span></p>
<h3><span id="扩展lucas定理">扩展Lucas定理</span></h3>
<p>令$p = p _i ^{ e _i } <span class="math inline">\(,那我们只要对于每个\)</span>i <span class="math inline">\(求出\)</span>C _n ^m p _i ^{ e _i }
$,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求$C _n ^m p ^k <span class="math inline">\(,其中\)</span>p prime $.</p>
<p>原式$= { m ! ( n - m ) ! } p ^k = { { p ^y } { p ^z } } p ^{ x - y -
z } p ^k \ $.</p>
<p>现在问题转化为求$ { p ^x } p ^k 以 及 p ^x \ $.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n ! &amp; = \prod _{ i = 1  } i \\
&amp; = ( \prod _{ i = wp , w \in \mathbb { Z  }  } i ) ( \prod _{ i \ne
wp , w \in \mathbb { Z  }  } i ) \\
&amp; = p ^{ \lfloor n p \rfloor  } ( \lfloor n p \rfloor ! ) ( \prod _{
i \ne wp , w \in \mathbb { Z  }  } i ) \\
&amp; \equiv p ^{ \lfloor \frac { n  } { p  } \rfloor  } ( \lfloor \frac
{ n  } { p  } \rfloor ! ) ( \prod _{ i = 1 , i \ne wp , w \in \mathbb {
Z  }  } ^{ p ^k  } i ) ^{ \lfloor \frac { n  } { p ^k  } \rfloor  } (
\prod ^{ n \ \bmod { p ^k  }  } _{ i = p ^k \lfloor \frac { n  } { p
^k  } \rfloor , i \ne wp , w \in \mathbb { Z  }  } i ) ( \mod p ^k )
\end{aligned}
\]</span></p>
<p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将$[ 1 , n ] <span class="math inline">\(的所有数全部排成一个宽为\)</span>p ^k $的矩阵.</p>
<p>那右边第一项就是把那些$p
$的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2>
<h3><span id="第一类斯特林数">第一类斯特林数</span></h3>
<p>$n k \ <span class="math inline">\(:长度为\)</span>n <span class="math inline">\(的排列划分成\)</span>k $个轮换的方案数.</p>
<p>考虑现在已经将$n - 1 <span class="math inline">\(个数分成了若干轮换,现在新加入第\)</span>n
$个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然$= ( n - 1 ) + \ $.</p>
<p>特别地,我们定义$= [ k = 0 ] \ $.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:$_{ k = 0 } ^n = n ! $.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3>
${
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>} <span class="math inline">\(:将\)</span>n
$个本质不同的物品划分成k个非空集合的方案数.</p>
考虑现在已经放好$n - 1 <span class="math inline">\(个物品,正要放入第\)</span>n <span class="math inline">\(个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然\)</span>{
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} = k {
<span class="math display">\[\begin{array}{ c  } n - 1 \\ k
\end{array}\]</span>
} + {
<span class="math display">\[\begin{array}{ c  } n - 1 \\ k - 1
\end{array}\]</span>
<p>} \ $.</p>
特别地,我们定义${
<span class="math display">\[\begin{array}{ c  } 0 \\ k
\end{array}\]</span>
<p>} = [ k = 0 ] \ $.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3>
<p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:${ n m }
= { - m - n } \ $.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3>
<ol type="1">
<li>$x ^n = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} x ^{ } = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} ( - 1 ) ^{ n - k } x ^{ } \ $.</li>
</ol>
证明:先考虑前半段,不妨使用数学归纳.若$x ^{ n - 1 } = _{ k = 0 } ^{ n - 1
} {
<span class="math display">\[\begin{array}{ c  } n - 1 \\ k
\end{array}\]</span>
<p>} x ^{ } \ $,我们要证</p>
<p>\</p>
$$
<span class="math display">\[\begin{aligned}
x \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} x ^{ \underline { k  }  } &amp; = \sum _{ k = 0  }
^{ n  } \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} x ^{ \underline { k  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑$( x - k ) x ^{ } = x ^{ } <span class="math inline">\(,所以\)</span>x x ^{ } = x ^{ } + kx ^{ } \
$.那么左边即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} x ^{ \underline { k + 1  }  } + \sum _{ k = 0  }
^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} kx ^{ \underline { k  }  } \\
&amp; = \sum _{ k = 1  } ^{ n  } \left \{ \begin{array}
{ c  } n - 1 \\
k - 1
\end{array} \right \} x ^{ \underline { k  }  } + \sum _{ k = 1  } ^{
n  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} kx ^{ \underline { k  }  } \\
&amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} x ^{ \underline { k  }  } \\
\\

\end{aligned}\]</span>
<p>$$</p>
至于后半段,由于$x ^{ } = ( - 1 ) ^n ( - x ) ^{ } \ <span class="math inline">\(,所以\)</span>x ^n = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>} ( - 1 ) ^k ( - x ) ^{ } \ $.</p>
<p>不妨用$x <span class="math inline">\(来代替\)</span>- x $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( - x ) ^n &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^k ( x ) ^{ \overline { k  }  } \\
x ^n &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^{ n - k  } x ^{ \overline { k  }  }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><p>$x ^{ } = _{ k = 0 } ^n x ^k \ $.</p></li>
<li><p>$x ^{ } = _{ k = 0 } ^n ( - 1 ) ^{ n - k } x ^k \ $.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于$( x + n - 1 ) x ^k = x ^{ k + 1 } + ( n - 1 ) x ^k \
$,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol start="4" type="1">
<li>反转公式:$_{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
} ( - 1 ) ^{ n - k } = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} ( - 1 ) ^{ n - k } = [ m = n ] \ $.</li>
</ol>
<p>证明:</p>
考虑先证明后半部分,将(3)带入(1),得到$x ^n = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} x ^{ } = <em>{ k = 0 } ^n </em>{ m = 0 } ^k {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>} ( - 1 ) ^{ n - k } x ^m \ $.</p>
<p>由于这对任意$x <span class="math inline">\(都成立,因此右边除了\)</span>x ^n
$以外的项系数均为$0 <span class="math inline">\(,而\)</span>x ^n
$的系数为$1 $.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol start="5" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n + 1 \\ m + 1
\end{array}\]</span>
<p>} = _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) {</p>
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
<p>} \ $.</p></li>
<li><p>$= _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) \ $.</p></li>
</ol>
<p>证明:对于前者,考虑组合意义,将$n + 1 <span class="math inline">\(个分为\)</span>m + 1 <span class="math inline">\(组,也就是先找一部分分成\)</span>m
$组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3>
<ol start="7" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n \\ m
\end{array}\]</span>
<p>} = _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) {</p>
<span class="math display">\[\begin{array}{ c  } k + 1 \\ m + 1
\end{array}\]</span>
<p>} ( - 1 ) ^{ n - k } \ $.</p></li>
<li><p>$= _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) ( - 1 ) ^{ n - k } \ $.</p></li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol start="9" type="1">
<li>$m ! {
<span class="math display">\[\begin{array}{ c  } n \\ m
\end{array}\]</span>
} = _{ k = 0 } ^m C _m ^k k ^n ( - 1 ) ^{ m - k } \ $.</li>
</ol>
证明:首先有$m ^n = _{ k = 0 } ^m m ^{ } {
<span class="math display">\[\begin{array}{ c  } m \\ k
\end{array}\]</span>
} = _{ k = 0 } ^m k ! C _m ^k {
<span class="math display">\[\begin{array}{ c  } m \\ k
\end{array}\]</span>
<p>} \ $,对这个式子进行二项式反演即可.</p>
<ol start="10" type="1">
<li>${
<span class="math display">\[\begin{array}{ c  } n + 1 \\ m + 1
\end{array}\]</span>
} = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
} ( m + 1 ) ^{ n - k } \ $.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前$k <span class="math inline">\(个分为\)</span>m <span class="math inline">\(组,把第\)</span>k + 1 <span class="math inline">\(个数放到第\)</span>m + 1 <span class="math inline">\(组.然后剩下\)</span>( n + 1 ) - ( k + 1 ) = n - k
<span class="math inline">\(个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第\)</span>m
+ 1 <span class="math inline">\(组(最小值最大的那组)在\)</span>k
$不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol start="11" type="1">
<li>$= <em>{ k = 0 } ^n C </em>{ n } ^k ( n - k ) ! = n ! _{ k = 0 } ^n
{ k ! } \ $.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果$n &gt; 0 <span class="math inline">\(,我们有\)</span>= ( n - 1 ) ! \ <span class="math inline">\(.这个式子很显然,我们现在有一个长度为\)</span>n - 1
<span class="math inline">\(的环,想要往里插入第\)</span>n <span class="math inline">\(个数有\)</span>n - 1 <span class="math inline">\(种选择,所以我们有:\)</span>= ( n - 1 ) \
$,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将$n + 1 <span class="math inline">\(个数划分成\)</span>m + 1 <span class="math inline">\(个环,我们先将其中\)</span>k <span class="math inline">\(个数划分成\)</span>m <span class="math inline">\(个环,剩下\)</span>n + 1 - k <span class="math inline">\(个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第\)</span>n
+ 1 $个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于$C _n ^k ( n - k ) ! = C _n ^{ n - k } ( n - k ) ! = n ^{ } = {
k ! } \ $.因此后半部分也得证.</p>
<ol start="12" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n + m + 1 \\ m
\end{array}\]</span>
<p>} = _{ k = 0 } ^m k {</p>
<span class="math display">\[\begin{array}{ c  } n + k \\ k
\end{array}\]</span>
<p>} \ $.</p></li>
<li><p>$_{ k = 0 } ^m ( n + k ) \ $.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将$n + k <span class="math inline">\(个位置分到\)</span>k <span class="math inline">\(个集合之后.还剩下\)</span>( n + m + 1 ) - ( n + k
) = ( m - k + 1 ) <span class="math inline">\(个数,剩下\)</span>( m - k
) $个集合.</p>
<p>拿出来$( n + k + 1 ) <span class="math inline">\(这个数,剩下的数刚好够每个集合放一个.最后枚举一下把\)</span>(
n + k + 1 ) $放在哪里即可.由于每个划分一定存在一段(可能是$0
$)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol start="14" type="1">
<li>$C <em>n ^m ( n - 1 ) ^{ } = </em>{ k = m } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
} \ $.</li>
</ol>
<p>证明:</p>
考虑$( n - 1 ) ^{ } = { ( m - 1 ) ! } \ <span class="math inline">\(,不妨设\)</span>f ( n , m ) = _{ k = m } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
<p>} \ <span class="math inline">\(,相当于将\)</span>n <span class="math inline">\(个数分成非空\)</span>m <span class="math inline">\(组,然后组内的数要形成若干轮换的方案数.那么知道\)</span>f
( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m ) f ( n - 1 , m ) \ $.</p>
<p>设$g ( n , m ) = C _n ^m { ( m - 1 ) ! } = { m ! ( n - m ) ! ( m - 1
) ! } \ $,那么知道:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n - 1 , m - 1 ) &amp; = \frac { ( n - 1 ) ! ( n - 2 ) !  } { ( m - 1
) ! ( n - m ) ! ( m - 2 ) !  } \\
g ( n - 1 , m ) &amp; = \frac { ( n - 1 ) ! ( n - 2 ) !  } { m ! ( n - 1
- m ) ! ( m - 2 ) !  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然$g ( n , m ) = g ( n - 1 , m - 1 ) + ( n - 1 + m ) g ( n - 1 , m
) \ $,数学归纳即可.</p>
<ol start="15" type="1">
<li><p>$C <em>n ^m = { m ! ( n - m ) ! } = </em>{ k = m } ^n {</p>
<span class="math display">\[\begin{array}{ c  } n + 1 \\ k + 1
\end{array}\]</span>
<p>} ( - 1 ) ^{ m - k } \ $.</p></li>
<li><p>$n ^{ } = { m ! } = _{ k = m } ^n {</p>
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
<p>} ( - 1 ) ^{ m - k } ， 其 中 m n \ $.</p></li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol start="17" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n \\ l + m
\end{array}\]</span>
<p>} C <em>{ l + m } ^l = </em>{ k = l } ^n {</p>
<span class="math display">\[\begin{array}{ c  } k \\ l
\end{array}\]</span>
<p>} {</p>
<span class="math display">\[\begin{array}{ c  } n - k \\ m
\end{array}\]</span>
<p>} C _n ^k \ $.</p></li>
<li><p>$C <em>{ l + m } ^l = </em>{ k = l } ^n C _n ^k \ $.</p></li>
</ol>
<p>证明:先考虑前者,左边即先将$n <span class="math inline">\(个数分为\)</span>l + m <span class="math inline">\(个集合,然后再挑出\)</span>l <span class="math inline">\(个集合.那不妨枚举这\)</span>l
$个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2>
记$
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
<span class="math inline">\(表示\)</span>{ 1 , 2 , . . . , n } <span class="math inline">\(的排列\)</span>a <span class="math inline">\(中满足这条性质的排列个数:存在且只存在\)</span>k
<span class="math inline">\(个升高,换句话说,存在且只存在\)</span>k <span class="math inline">\(个\)</span>i $,满足$1 i &lt; n <span class="math inline">\(,\)</span>a <em>i &lt; a </em>{ i + 1 } <span class="math inline">\(.不难发现\)</span>
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
=
<span class="math display">\[\begin{array}\\ n \\ n - k - 1
\end{array}\]</span>
<p>$.</p>
考虑在一个${ 1 , 2 , . . . , n - 1 } <span class="math inline">\(的排列中插入\)</span>n <span class="math inline">\(,设插入的位置是原本\)</span>a _i <span class="math inline">\(的后面,那么要么原本\)</span>a <em>i &lt; a </em>{
i + 1 } $,要么反之.前者不会改变排列的升高的数量,后者则会增加$1 <span class="math inline">\(.另外还有一种情况是插入到了序列最前面.于是我们自然得到:\)</span>
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
= ( k + 1 )
<span class="math display">\[\begin{array}\\ n - 1 \\ k
\end{array}\]</span>
+ ( n - k )
<span class="math display">\[\begin{array}\\ n - 1 \\ k - 1
\end{array}\]</span>
<p>$.</p>
特别地,我们令$
<span class="math display">\[\begin{array}\\ 0 \\ k \end{array}\]</span>
= [ k = 0 ] <span class="math inline">\(,若\)</span>k &lt; 0 <span class="math inline">\(,则\)</span>
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
<p>= 0 $.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3>
<p>我们有Worpitzky恒等式:</p>
<p><span class="math display">\[
x ^n = \sum _{ k \geq 0  } \binom { x + k  } { n  } \left \langle
\begin{array}
\\
n \\
k
\end{array} \right \rangle , n \in \mathbb { N  }
\]</span></p>
<p>还有另一个恒等式:</p>
<p><span class="math display">\[
\left \langle \begin{array}
\\
n \\
m
\end{array} \right \rangle = \sum _{ k = 0  } ^m \binom { n + 1  } {
k  } ( m + 1 - k ) ^n ( - 1 ) ^k
\]</span></p>
<p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2>
<p>定义$B <em>j <span class="math inline">\(为第\)</span>j <span class="math inline">\(个伯努利数,且满足\)</span></em>{ j = 0 } ^m { j }
B _j = [ m = 0 ] , m \ $.</p>
<p>定义$S <em>m ( n ) = </em>{ i = 0 } ^{ n - 1 } i ^m $.</p>
<p>伯努利数满足公式:$S <em>m ( n ) = { m + 1 } </em>{ k = 0 } ^m { k } B
_k n ^{ m + 1 - k } \ $.</p>
<p>证明如下:</p>
<p>对$S _{ m + 1 } ( n ) $使用扰动法,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
S _{ m + 1  } ( n ) + n ^{ m + 1  } &amp; = \sum _{ k = 0  } ^{ n - 1  }
( k + 1 ) ^{ m + 1  } \\
&amp; = \sum _{ k = 0  } ^{ n - 1  } \sum _{ j = 0  } ^{ m + 1  } \binom
{ m + 1  } { j  } k ^j \\
&amp; = \sum _{ j = 0  } ^{ m + 1  } \binom { m + 1  } { j  } S _j ( n )
\\
&amp; = \sum _{ j = 0  } ^{ m  } \binom { m + 1  } { j  } S _j ( n ) + S
_{ m + 1  } ( n ) \\
n ^{ m + 1  } &amp; = \sum _{ j = 0  } ^m \binom { m + 1  } { j  } S _j
( n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来使用数学归纳,假设$0 j &lt; m <span class="math inline">\(时该公式成立,并假设有\)</span>S <em>m ( n ) = { m
+ 1 } </em>{ k = 0 } ^m { k } B _k n ^{ m + 1 - k } + \ <span class="math inline">\(,我们只需要证明\)</span>= 0 $.</p>
<p><span class="math display">\[
\begin{aligned}
n ^{ m + 1  } &amp; = \sum _{ j = 0  } ^m \binom { m + 1  } { j  }
\cfrac { 1  } { j + 1  } \sum _{ k = 0  } ^j \binom { j + 1  } { k  } B
_k n ^{ j + 1 - k  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k  }
\binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _k n ^{ j + 1 - k  }
+ ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { j - k  }
\binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k +
1  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k + 1  }
\binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k +
1  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  }
\sum _{ j = k  } ^m B _{ j - k  } \binom { m + 1  } { j  } \binom { j  }
{ k  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  }
\binom { m + 1  } { k  } \sum _{ j = k  } ^m B _{ j - k  } \binom { m +
1 - k  } { j - k  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom
{ m + 1  } { k  } \sum _{ j = 0  } ^{ m - k  } B _{ j  } \binom { m + 1
- k  } { j  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom
{ m + 1  } { k  } [ m - k &amp; = 0 ] + ( m + 1 ) \Delta \\
&amp; = n ^{ m + 1  } + ( m + 1 ) \Delta
\end{aligned}
\]</span></p>
<p>显然$= 0 $,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2>
定义斐波那契数$F _n =
<span class="math display">\[\begin{cases}0 &amp; n = 0 \\ 1 &amp; n = 1
\\ F _{ n - 1  } + F _{ n - 2  } &amp; n &gt; 1 \end{cases}\]</span>
<p>$.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3>
<p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<p><span class="math display">\[
F _{ n + 1  } F _{ n - 1  } - F _n ^2 = ( - 1 ) ^n , n &gt; 0
\]</span></p>
<p>事实上,如果我们将斐波那契数的递推式改写作:$F <em>n = F </em>{ n + 2 }
- F _{ n + 1 } <span class="math inline">\(,我们可以在\)</span>n
$的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<p><span class="math display">\[
F _{ - n  } = ( - 1 ) ^{ n - 1  } F _n , n \in \mathbb { Z  }
\]</span></p>
<h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3>
<p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
F _{ n + k  } &amp; = F _k F _{ n + 1  } + F _{ k - 1  } F _n \\
F _{ n + m + 1  } &amp; = F _{ n + 1  } F _{ m + 1  } + F _n F _m
\end{aligned}
\]</span></p>
<p>另外,如果我们在上面这个式子中取$k = wn , w <span class="math inline">\(并使用归纳法,我们又可以得到一个性质:\)</span>F _{
kn } <span class="math inline">\(是\)</span>F _n <span class="math inline">\(的倍数,\)</span>k $.</p>
<p>再观察这个式子,使用归纳法可以证明$( F <em>{ n } , F </em>{ n - 1 } )
= 1 <span class="math inline">\(,进一步有:\)</span>( F _{ n + m } , F _m
) = ( F _n , F _m ) $.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<p><span class="math display">\[
\gcd ( F _m , F _n ) = F _{ \gcd ( n , m )  }
\]</span></p>
<p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<p><span class="math display">\[
F _n ^2 | F _m \Leftrightarrow nF _n | m , n &gt; 2
\]</span></p>
<p>这个引理的证明如下:</p>
<p>由于$F <em>{ n + 1 } F </em>{ n - 1 } <span class="math inline">\(.于是我们有:\)</span>F <em>{ 2 n } = F <em>n F
</em>{ n + 1 } + F </em>{ n - 1 } F <em>n <span class="math inline">\(,也就是\)</span>F </em>{ 2 n } F <em>n F </em>{ n
+ 1 } $.</p>
<p>另外我们有:$F <em>{ 2 n + 1 } F </em>{ n + 1 } ^2 $.</p>
<p>同理,使用归纳法可以证明:$F <em>{ kn } kF <em>n F </em>{ n + 1 } ^{ k
- 1 } , F </em>{ kn + 1 } F _{ n + 1 } ^k $.</p>
<p>而$F _{ n + 1 } F <em>n <span class="math inline">\(,于是\)</span>F
</em>{ kn } k , n &gt; 2 $.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3>
<p>我们如果定义$j k j k + 2 $,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:$n = <em>{ i = 1 } ^r F </em>{ k _i
} , i &lt; r , k <em>i k </em>{ i + 1 } $.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果$k <span class="math inline">\(满足\)</span>F _k = n <span class="math inline">\(,则显然成立,不然,应\)</span>k <span class="math inline">\(满足\)</span>F <em>k &lt; n &lt; F </em>{ k + 1 }
<span class="math inline">\(,而\)</span>n - F _k <span class="math inline">\(的表示已经存在了.另外,由于\)</span>n - F <em>k
&lt; F </em>{ k + 1 } - F <em>k = F </em>{ k - 1 } <span class="math inline">\(,因此必定不可能出现选了\)</span>F <em>k <span class="math inline">\(又选了\)</span>F </em>{ k - 1 }
$的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择$F <em>k <span class="math inline">\(而是选择\)</span>F </em>{ k - 1 } <span class="math inline">\(,那么显然接下来无论怎么选,它们的加和都不可能大于等于\)</span>F
_k $,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数$n $以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3>
<p>使用生成函数,令$F ( z ) = _{ k } F _k z ^k <span class="math inline">\(.那么不难发现\)</span>F ( z ) - zF ( z ) - z ^2 F
( z ) = z <span class="math inline">\(,也就是\)</span>F ( z ) = { 1 - z
- z ^2 } $.</p>
<p>考虑这个形式一定可以分解为$F ( z ) = { 1 - z } + { 1 - z }
$的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令$= { 2 } , = { 2 } <span class="math inline">\(,那么可以得到\)</span>F _n = { } ( ^n - ^n )
$.</p>
<p>另外,由于$^n <span class="math inline">\(的影响很小,于是又有\)</span>F _n = { } + 0 . 5
$.</p>
<h3><span id="连项式">连项式</span></h3>
连项式多项式$K _n ( x _1 , x _2 , . . . , x _n ) <span class="math inline">\(定义为:\)</span>K _n ( x _1 , x _2 , . . . , x _n
) =
<span class="math display">\[\begin{cases}1 &amp; n = 0 \\ x _1 &amp; n
= 1 \\ x _n K _{ n - 1  } ( x _1 , x _2 , . . . x _{ n - 1  } ) + K _{ n
- 2  } ( x _1 , x _2 , . . . , x _{ n - 2  } ) &amp; n \geq 2
\end{cases}\]</span>
<p>$.</p>
<p>通过定义不难发现:$K <em>n ( 1 , 1 , . . . , 1 ) = F </em>{ n + 1 }
$.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数$( x _{
n - 1 } , x _n )
$.我们考虑用这样一种形式的字符串来表示最后某一项的情况:‘.’为还没有消除掉的项,长度为$1
$;’-’为已经消除了的两项,长度为$2 <span class="math inline">\(.那么\)</span>K _n ( x _1 , x _2 , . . . , x _n )
<span class="math inline">\(就可以表示为一个长度为\)</span>n <span class="math inline">\(的字符串,其中若有\)</span>k <span class="math inline">\(个&#39;-&#39;,有\)</span>n - 2 k <span class="math inline">\(个&#39;.&#39;,则有\)</span> { k }
$种不同的排列方式.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
K _n ( z , z , . . . , z ) &amp; = \sum _{ k = 0  } ^n \binom { n - k  }
{ k  } z ^{ n - 2 k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,这也导出:$F <em>{ n + 1 } = </em>{ k = 0 } ^n { k } \ $.</p>
<p>考虑上面的构造过程,不难发现$K _n ( x _1 , x _2 , . . . , x _n ) = K
_n ( x <em>n , x </em>{ n - 1 } , . . . , x _1 ) $.</p>
<p>于是递归式可以写成:$K _n ( x _1 , x _2 , . . . , x _n ) = x <em>1 K
</em>{ n - 1 } ( x <em>2 , x <em>3 , . . . x </em>{ n } ) + K </em>{ n -
2 } ( x _3 , x <em>4 , . . . , x </em>{ n } ) $.</p>
<p>进一步地,不断展开后得到:</p>
<p><span class="math display">\[
\begin{aligned}
K _{ m + n  } ( x _1 , . . . , x _m , x _{ m + 1  } , . . . , x _{ n +
m  } ) &amp; = \\
K _m ( x _1 , . . . , x _m ) K _n ( x _{ m + 1  } , . . . , x _{ n +
m  } ) + K _{ m - 1  } ( x _1 , . . . , x _{ m - 1  } ) K _{ n - 1  } (
x _{ m + 2  } , . . . , x _{ n + m  } )
\end{aligned}
\]</span></p>
<p>另外,根据连项式的定义,不难导出$K _n ( x _1 , . . . , x _n + y ) = K
_n ( x _1 , . . . , x <em>n ) + K </em>{ n - 1 } ( x <em>1 , . . . , x
</em>{ n - 1 } ) y $.</p>
<p>由这个公式可以推出:$ { K _n ( a _1 , . . . , a <em>n ) } = { K </em>{
n - 1 } ( a <em>1 , . . . , a </em>{ n - 1 } + { a _n } ) } $.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<p><span class="math display">\[
\cfrac { K _{ n + 1  } ( a _0 , . . . , a _n )  } { K _n ( a _1 , . . .
, a _n )  } = a _0 + \cfrac { 1  } { a _1 + \cfrac { 1  } { a _2 +
\cfrac { 1  } { a _3 + . . .  }  }  }
\]</span></p>
<p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>简单乐理</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="前言">前言</span></h3>
<p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3>
<h4><span id="拍音理论">拍音理论</span></h4>
<p>假设两个正弦单音的频率分别是$, + $,那么它们叠加后是:</p>
<p><span class="math display">\[
\begin{aligned}
\sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
&amp; = 2 \sin \left ( 2 \pi ( \omega + \frac { \delta  } { 2  } ) t
\right ) \cos ( \pi \delta t )
\end{aligned}
\]</span></p>
<p>注意到这个声音受到$( t ) <span class="math inline">\(的控制.因此会以\)</span> { 2 } <span class="math inline">\(的频率振动,由于\)</span><span class="math inline">\(应该远小于\)</span><span class="math inline">\(,这里就会产生\)</span>= | _1 - _2 | $个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4>
<p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol type="1">
<li><p>弦长$L $.</p></li>
<li><p>张力$T $.</p></li>
<li><p>线密度$$.</p></li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点$u
( x , t ) $,首先是一维振动方程:</p>
<p><span class="math display">\[
\frac { \partial ^2 u  } { \partial x ^2  } = \frac { \rho  } { T  }
\frac { \partial ^2 u  } { \partial t ^2  }
\]</span></p>
<p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<p><span class="math display">\[
u _n ( x , t ) = c _n \sin ( \omega _n t + \theta _n ) \sin ( \frac { n
\pi  } { L  } x )
\]</span></p>
<p>其中第$n $项的频率满足:</p>
<p><span class="math display">\[
f _n = \frac { n  } { 2 L  } \sqrt { \frac { T  } { \rho  }  }
\]</span></p>
<p>其中我们将$f _1 <span class="math inline">\(称为**基频**,相应的声音称为**基音**,而将剩下的频率对应的声音统称为泛音,其中\)</span>f
_n , n <span class="math inline">\(对应的是第\)</span>n - 1 $泛音.</p>
<p>特别地,如果我们干脆记$f = f _1
$,上述结果告诉我们弦的振动产生的一列频率是:</p>
<p><span class="math display">\[
f , 2 f , 3 f , \cdots
\]</span></p>
<p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的$n
$,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0"></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的$f
_{ 2 k + 1 } $,泛音列中只剩下$2 f , 4 f , <span class="math inline">\(.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按\)</span>
{ 3 } $处呢?那泛音列中就会只剩下$3 f , 6 f , 9 f ,
$,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是$f
, 3 f , 5 f , $.</p>
<h4><span id="管乐器">管乐器</span></h4>
<p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<p><span class="math display">\[
f , 2 f , 3 f , 4 f , \cdots
\]</span></p>
<p>闭管的泛音列:</p>
<p><span class="math display">\[
f , 3 f , 5 f , 7 f
\]</span></p>
<p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4>
<p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots
\end{gathered}
\]</span></p>
<p>或是:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac { 3  } { 2  } f , 3 f , \frac { 9  } { 2  } f , 6 f , \cdots
\end{gathered}
\]</span></p>
<p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3>
<p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是$L
<em>p = 20 </em>{ 10 } ( { p _0 } ) <span class="math inline">\(,其中\)</span>p _0 = 20 Pa $.</p>
<h4><span id="音程">音程</span></h4>
<p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<div class="line-block">度数 | 半音数 | 名称 |</div>
<div class="line-block">—- | —— | —— |</div>
<div class="line-block">一 | 0 | 纯一度 |</div>
<div class="line-block">二 | 1 | 小二度 |</div>
<div class="line-block">二 | 2 | 大二度 |</div>
<div class="line-block">三 | 3 | 小三度 |</div>
<div class="line-block">三 | 4 | 大三度 |</div>
<div class="line-block">四 | 5 | 纯四度 |</div>
<div class="line-block">四 | 6 | 增四度 |</div>
<div class="line-block">五 | 6 | 减五度 |</div>
<div class="line-block">五 | 7 | 纯五度 |</div>
<div class="line-block">六 | 8 | 小六度 |</div>
<div class="line-block">六 | 9 | 大六度 |</div>
<div class="line-block">七 | 10 | 小七度 |</div>
<div class="line-block">七 | 11 | 大七度 |</div>
<div class="line-block">八 | 12 | 纯八度 |</div>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<div class="line-block">音程 | 频率比 |</div>
<div class="line-block">—— | —— |</div>
<div class="line-block">纯八度 | $2 : 1 $ |</div>
<div class="line-block">纯五度 | $3 : 2 $ |</div>
<div class="line-block">纯四度 | $4 : 3 $ |</div>
<div class="line-block">大三度 | $5 : 4 $ |</div>
<div class="line-block">小三度 | $6 : 5 $ |</div>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4>
<p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定$C
$的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为$1 <span class="math inline">\(,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求\)</span>{
7 k } $这个数列对吧,简单数论知识告诉我们它必然能遍历$12
$种情况,具体而言:</p>
$$
<span class="math display">\[\begin{aligned}
C \to &amp; &amp; G \to &amp; &amp; D \to &amp; &amp; A \to &amp; &amp;
E \to &amp; &amp; B \to \\
1 \to &amp; &amp; \frac { 3  } { 2  } \to &amp; &amp; \frac { 3 ^2  } {
2 ^3  } \to &amp; &amp; \frac { 3 ^3  } { 2 ^4  } \to &amp; &amp; \frac
{ 3 ^4  } { 2 ^6  } \to &amp; &amp; \frac { 3 ^5  } { 2 ^7  } \to \\
\\
\\
\# F \to &amp; &amp; \# C \to &amp; &amp; \# G \to &amp; &amp; \# D \to
&amp; &amp; \# A \to &amp; &amp; \# E \\
\frac { 3 ^6  } { 2 ^9  } \to &amp; &amp; \frac { 3 ^7  } { 2 ^{
11  }  } \to &amp; &amp; \frac { 3 ^8  } { 2 ^{ 12  }  } \to &amp; &amp;
\frac { 3 ^9  } { 2 ^{ 14  }  } \to &amp; &amp; \frac { 3 ^{ 10  }  } {
2 ^{ 15  }  } \to &amp; &amp; \frac { 3 ^{ 11  }  } { 2 ^{ 17  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度$CE
<span class="math inline">\(的比是\)</span> { 64 } &gt; { 64 } = { 4 }
$.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的$#
E F <span class="math inline">\(,你对着这个\)</span># E <span class="math inline">\(往上再升一个音得到的理应是\)</span>C ’ = { 2 ^{ 18
} } &gt; 2 <span class="math inline">\(,具体来说\)</span> { 2 ^{ 19 } }
. 013643
$,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于$1
$的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升$12
$个纯五度,再下降$7 $个纯八度理应回到原点,可是:</p>
<p><span class="math display">\[
( \frac { 3  } { 2  } ) ^{ 12  } \times ( \frac { 1  } { 2  } ) ^7 &gt;
1
\]</span></p>
<p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4>
<p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定$C $的频率为$1 <span class="math inline">\(.接下来用正三和弦(一个大三度和一个小三度)\)</span>I
: C - E - G <span class="math inline">\(,\)</span>IV : F - A - C ’ <span class="math inline">\(,\)</span>V : G - B - D ’ $的比例是$4 : 5 : 6
$确定剩下的:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; &amp; D &amp; &amp; E &amp; &amp; F &amp; &amp; G &amp; &amp; A
&amp; &amp; B &amp; &amp; C &#39; &amp; &amp; D &#39; \\
1 &amp; &amp; \frac { 9  } { 8  } &amp; &amp; \frac { 5  } { 4  } &amp;
&amp; \frac { 4  } { 3  } &amp; &amp; \frac { 3  } { 2  } &amp; &amp;
\frac { 5  } { 3  } &amp; &amp; \frac { 15  } { 8  } &amp; &amp; 2 &amp;
&amp; \frac { 9  } { 4  }
\end{aligned}
\]</span></p>
<p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol type="1">
<li><p>五度音程$D - A <span class="math inline">\(不协和,比例为\)</span>
{ 54 } &lt; { 54 } = { 2 } $.这直接导致了转调会出错.</p></li>
<li><p>有两种不同的大二度:音程$C - D , F - G , A - B <span class="math inline">\(的比例是\)</span> { 8 } <span class="math inline">\(而音程\)</span>D - E , G - A <span class="math inline">\(的比例为\)</span> { 9 } $.</p></li>
<li><p><strong>谐调音差</strong>:从$C <span class="math inline">\(出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:\)</span>(
{ 2 } ) ^4 ( { 2 } ) ^2 { 5 } = { 80 } = 1 . 0125 &gt; 1 $.</p></li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4>
<p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用$
$来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是$f _1 ,
f _2 $,则它们的音分数定义为$1200 _2 ( { f _1 } )
$,容易见到十二平均律拿到的一个半音恰好是$100 $音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3>
<h4><span id="大小调">大小调</span></h4>
<h5><span id="自然大调">自然大调</span></h5>
<p>就是我们最常用的$CDEFGABC ’
$,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol type="1">
<li><p>主音</p></li>
<li><p>上主音</p></li>
<li><p>中音</p></li>
<li><p>下属音</p></li>
<li><p>属音</p></li>
<li><p>下中音</p></li>
<li><p>导音</p></li>
</ol>
<p>用五度相生,下属音$<span class="math inline">\(主音\)</span>$属音.</p>
<h5><span id="自然小调">自然小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以$ABCDEFG <span class="math inline">\(用的调子,然而这里的问题是\)</span>G <span class="math inline">\(作为导音却和\)</span>A ’ $差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用$A , B , C , D , E , F , ( ^# G )
$.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用$A , B , C , D , E , ( ^# F ) , ( ^#
G ) $.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4>
<p>以五度相生:</p>
<p><span class="math display">\[
C \to G \to D \to A \to E \to B \to ( ^\# F ) \to ( ^\# C )
\]</span></p>
<p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从$C
<span class="math inline">\(开始每次往后跳一次都要在一个音阶上增一个升号.从\)</span>C
<span class="math inline">\(大调提升到\)</span>G <span class="math inline">\(大调的时候就是将\)</span>C <span class="math inline">\(的下属音(也就是\)</span>F $)升音.</p>
<p>对称地,反方向的五度相生:</p>
<p><span class="math display">\[
C \to F \to ( ^b B ) \to ( ^b E ) \to ( ^b A ) \to ( ^b D ) \to ( ^b G )
\to ( ^b C )
\]</span></p>
<p>那这个应该降什么呢?比如从$C <span class="math inline">\(大调提升到\)</span>F <span class="math inline">\(大调的时候就是将\)</span>F <span class="math inline">\(的下属音\)</span>B $降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png"></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3>
<h4><span id="三和弦">三和弦</span></h4>
<p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol type="1">
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成$4 : 5 : 6
$的频率关系.</p></li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p></li>
<li><p>减三和弦:两个小三度.</p></li>
<li><p>增三和弦:两个大三度.</p></li>
</ol>
<h4><span id="七和弦">七和弦</span></h4>
<p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol type="1">
<li><p>减减七和弦(减七和弦):小小小.</p></li>
<li><p>减小七和弦(半减七和弦):小小大.</p></li>
<li><p>小小七和弦(小七和弦):小大小.</p></li>
<li><p>小大七和弦:小大大.</p></li>
<li><p>大小七和弦(属七和弦):大小小.</p></li>
<li><p>大大七和弦(大七和弦):大小大.</p></li>
<li><p>增大七和弦:大大小.</p></li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4>
<p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p></li>
</ol>
<p>对于七和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p></li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p></li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4>
<p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为$C
- E - G <span class="math inline">\(,\)</span>F - A - C ’ <span class="math inline">\(,\)</span>G - B - D ’
$.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol type="1">
<li><p>正格进行:$I V I $.</p></li>
<li><p>变格进行:$I IV I $.</p></li>
<li><p>复式进行:$I IV V I $.</p></li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<p><span class="math display">\[
\xymatrix { &amp; &amp; &amp; &amp; I \\
&amp; &amp; IV \ar [r ] \ar [d ] \ar [dr ] \ar [rru ] &amp; vii \degree
\ar [ru ] &amp; \\
iii \ar [r ] &amp; vi \ar [r ] \ar [ru ] &amp; ii \ar [r ] \ar [ru ]
&amp; V \ar [ruu ] &amp;  }
\]</span></p>
<p>其中$I $较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4>
<p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol type="1">
<li><p>平行变换$P $:保持纯五度音阶不变,将三音切换.</p></li>
<li><p>关系变换$R
$:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p></li>
<li><p>导音变换$L $:保持小三度音阶不变,补上剩下的一个.</p></li>
</ol>
<p>容易见到$R ( L R ) ^3 = P $.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计实习</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2>
<h3><span id="基本分析">基本分析</span></h3>
<h4><span id="union-bound">Union Bound</span></h4>
<p>即:$Pr [ _i X _i ] Pr [ X _i ] <span class="math inline">\(,取等当且仅当所有\)</span>X _i $互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4>
<p>若$X <span class="math inline">\(,则\)</span>Pr [ X t [ X ] ] { t }
$.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6>
<p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有$ { 2 } <span class="math inline">\(的概率是割边,因此期望自然是\)</span> { 2 } | E | {
2 } | | $.</p>
<p>由此立即见到,$Pr [ | ans | ( { 2 } - ) | E | ] = Pr [ | E | - | ans |
( { 2 } + ) | E | ] { 1 + 2 } $.</p>
<p>由于每次独立操作,因此如果有$P <span class="math inline">\(的概率失败,那么运行\)</span>T
$次后至少成功一次的概率应当为$1 - P ^T <span class="math inline">\(.从而\)</span>T = O ( _P { } ) = O ( { ( 1 + { 2 }
) } ) O ( { } ) <span class="math inline">\(即可拿到\)</span>$失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>设$X _1 , , X _n <span class="math inline">\(是独立,同期望(期望为\)</span>t <span class="math inline">\()的随机变量,令\)</span>X = { n } <span class="math inline">\(,对于任何失败概率\)</span>( 0 , 1 ) $,应当有:</p>
<p><span class="math display">\[
Pr \left [ | X - \mu | \geq \sqrt { \cfrac { \log ( 1 / \delta )  } {
nt  }  } \mu \right ] \leq \delta
\]</span></p>
<h6><span id="examplemedian-trick">Example(Median Trick)</span></h6>
<p>现在有一个黑盒能够以$p &gt; { 2 } <span class="math inline">\(的概率正确回答Yes或者No,问重复\)</span>T
$选多少次能拿到$1 - $的成功概率.</p>
<p>考虑重复$T <span class="math inline">\(次后应当有期望\)</span>pT
$个正确答案,因此直接取中位数.称此算法为Median Trick.</p>
<p>Chernoff Bound 告诉我们$T = O ( { } ) $足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4>
<p>设独立随机变量$x _1 , , x _m <span class="math inline">\(,令\)</span>X = _i x _i $,则:</p>
<p><span class="math display">\[
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac { 2 z ^2  } { m (
t - s ) ^2  } \right )
\]</span></p>
<h3><span id="编程中的随机性">编程中的随机性</span></h3>
<p>一般采用伪随机,也即是给定初值$X <em>0 <span class="math inline">\(,通过某个确定性的函数来生成\)</span>X </em>{ n + 1
} = f ( X _n ) $这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) ) <span class="math inline">\(的算法,我们运行其\)</span>k $次,则正确率为$1 - ( 1
- p ) ^k <span class="math inline">\(,时间复杂度为\)</span>O ( kf ( n )
) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) <span class="math inline">\(,其中\)</span>f ( n ) <span class="math inline">\(为枚举部分的复杂度,\)</span>g ( n ) <span class="math inline">\(为单词枚举中计算所需的复杂度.大部分情况下应保证\)</span>g
( n ) $不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有$n $个互不重合的点,已知存在不超过$7 <span class="math inline">\(条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.\)</span>n
$.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O
( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$
{ 7 } <span class="math inline">\(个点.换句话说,我们随机一个点,这个点在这条直线上的概率是\)</span>
{ 7 } <span class="math inline">\(,因此随机两个点确定这条直线的概率为\)</span> { 49
} $.随机$1000 $次,错误概率为$1 - ( { 49 } ) ^{ 1000 } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为$n <span class="math inline">\(的序列,要求找出一个长度大于等于\)</span> { 2 }
<span class="math inline">\(的子序列,使这个子序列中所有数的\)</span><span class="math inline">\(最大,求最大的\)</span><span class="math inline">\(.\)</span>n ^6 <span class="math inline">\(,\)</span>a _i ^{ 12 } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$ { 2 } <span class="math inline">\(.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度\)</span>O
( n ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$ <span class="math inline">\(个质因子全都存下来,然后将\)</span>n <span class="math inline">\(个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个\)</span>$,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为$n <span class="math inline">\(的序列\)</span>a <span class="math inline">\(,有\)</span>m <span class="math inline">\(次询问,每次给定一个区间\)</span>[ l , r ] <span class="math inline">\(,问\)</span>a [ l , r ] <span class="math inline">\(中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.\)</span>(
n , m , 1 a _i n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A <span class="math inline">\(并判断它与其它向量的内积,这样复杂度为\)</span>O (
n ^2 d ) $.</p>
冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A =
<span class="math display">\[\begin{bmatrix}\vec { a _1  } , \vec { a
_2  } , . . . , \vec { a _n  } \end{bmatrix}\]</span>
<p><span class="math inline">\(,那我们要验证的无非是\)</span>B = AA ^T
<span class="math inline">\(中是否存在一个不在主对角线上的元素\)</span>B
_{ i , j } <span class="math inline">\(在\)</span> $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C <span class="math inline">\(,其中\)</span>C <span class="math inline">\(的主对角线元素与\)</span>B $相同,而其他元素全是$1
<span class="math inline">\(.接下来我们要做的无非是找到\)</span>B <span class="math inline">\(和\)</span>C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C <span class="math inline">\(,那么对于任意一个\)</span>X _{ m n } <span class="math inline">\(都应该满足\)</span>XB = XC <span class="math inline">\(,取\)</span>m = 1 <span class="math inline">\(,我们的问题就转化为:是否能找到一个\)</span>X <span class="math inline">\(,使得\)</span>XB XC <span class="math inline">\(?这显然可以随机化.计算前者的复杂度为\)</span>O (
nd ) <span class="math inline">\(,后者由于\)</span>C <span class="math inline">\(很特殊,可以在\)</span>O ( n )
$的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令$D = B - C <span class="math inline">\(,若返回相等但实际上不相等,则\)</span>D
$中至少存在一个不为$0 <span class="math inline">\(的数字,假设\)</span>D
<em>{ i , j } <span class="math inline">\(.我们令\)</span>E = X D <span class="math inline">\(,那么只有当\)</span>E <span class="math inline">\(是零向量时才会错误.而\)</span>E <em>j = </em>{ k }
X <em>k D </em>{ k , j } <span class="math inline">\(,不难解得:\)</span>E <em>i = - { D </em>{ i , j }
} </em>{ k i } X <em>k D </em>{ k , j } <span class="math inline">\(,也就是说如果\)</span>X <span class="math inline">\(的其它位置都确定了,那么\)</span>E <span class="math inline">\(只有一种取值会返回错误.由于\)</span>k <span class="math inline">\(一共就俩取值,所以正确率至少\)</span> { 2 } $.</p>
<p>至于找到答案:我们找到一个不为$0 <span class="math inline">\(的\)</span>E _i <span class="math inline">\(,那么一定存在一组解包含了第\)</span>i <span class="math inline">\(个向量,只需枚举另一个向量检验就行,复杂度\)</span>O
( nd ) $.</p>
<p>$k = 3 <span class="math inline">\(的话,我们注意到\)</span>
$意义下,$1 $和$2 $的平方都是$1 <span class="math inline">\(.考虑\)</span><em>{ j } B </em>{ i , j } ^2 X
<em>j = </em>{ j } B _{ i , j } X <em>j B </em>{ h , i } ^T
$,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) <span class="math inline">\(表示对长度为\)</span>n
$的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要$+ 1 <span class="math inline">\(或者\)</span>- 1
$或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n
- 1  } ( T _i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{
\frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } {
n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i
- 1 ) )
\end{aligned}
\]</span></p>
<p>由于$T ( n ) n <span class="math inline">\(,所以对于\)</span> { 2 } i
j <span class="math inline">\(,我们显然有:\)</span>T ( i ) + T ( n - i )
T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } {
2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  }
{ 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
&amp; \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明$c <span class="math inline">\(,\)</span>T ( n ) cn n
$,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log
( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } {
4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  }
\log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } {
4  } + \frac { n  } { 2  } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } {
3  } ) - \frac { c  } { 4  } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) )
$的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk &amp; = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } &amp; =
p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k &amp; = \frac { 1  } { p  }
\end{aligned}
\]</span></p>
<p>则期望复杂度为$O ( { p } ) $.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 <span class="math inline">\(和第二个位置\)</span>x _2 <span class="math inline">\(,显然只要问到\)</span>[ x _1 , x _2 )
$是正确的.</p>
<p>考虑因为是随机,所以$x _1 x _2 <span class="math inline">\(的概率应当是不低的(事实上约为\)</span> { 2 } <span class="math inline">\(),而此时的\)</span>[ x _1 , x _2 )
$中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . .
$.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E _{ t + 1  } &gt; E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } &amp; E _{ t + 1  } \leq
E _t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度$T _0 <span class="math inline">\(,降温速度\)</span>k ( 0 , 1 ) <span class="math inline">\(,以及终止温度\)</span>T _k <span class="math inline">\(,每次操作后让\)</span>T = kT
$,直到其小于终止温度.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间$$:在一个给定问题中可能发生的所有情况.</p>
<p>事件:$$的一个子集.</p>
<p>基本事件$<span class="math inline">\(:\)</span>$中的单个元素,也可以看作集合大小为$1
$的事件.</p>
<p>概率:若$<span class="math inline">\(,我们称它发生的概率为\)</span>( )
<span class="math inline">\(,有\)</span>( ) <span class="math inline">\(且\)</span>_{ } ( ) = 1 $.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量$X <span class="math inline">\(和\)</span>Y
<span class="math inline">\(定义在同一个概率空间\)</span><span class="math inline">\(上,对于每一个在\)</span>X <span class="math inline">\(取值范围内的\)</span>x <span class="math inline">\(以及在\)</span>Y <span class="math inline">\(取值范围内的\)</span>y <span class="math inline">\(,我们称\)</span>( X = x Y = y )
$为它们的联合分布.</p>
<p>独立:如果对于每一个在$X <span class="math inline">\(取值范围内的\)</span>x <span class="math inline">\(以及在\)</span>Y <span class="math inline">\(取值范围内的\)</span>y <span class="math inline">\(,\)</span>( X = x Y = y ) = ( X = x ) ( Y = y )
<span class="math inline">\(,我们称\)</span>X <span class="math inline">\(和\)</span>Y $是独立的.</p>
<p>期望(均值)$E X <span class="math inline">\(:我们设概率空间上的随机变量\)</span>X <span class="math inline">\(的期望\)</span>EX = <em>{ x X ( ) } x ( X = x ) =
</em>{ w } X ( ) ( ) $.</p>
<p>中位数:我们设概率空间上的随机变量$X <span class="math inline">\(的中位数为满足\)</span>( X x ) . 5 ( X x ) . 5
<span class="math inline">\(的\)</span>x X ( ) $所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量$X <span class="math inline">\(的众数为满足\)</span>( X = x ) ( X = x ’ ) , x ’ X
( ) <span class="math inline">\(的\)</span>x X ( ) $所组成的集合.</p>
<p>方差$VX <span class="math inline">\(:我们设概率空间上的随机变量\)</span>X <span class="math inline">\(的方差\)</span>VX = E ( ( X - EX ) ^2 ) $.</p>
<p>标准差$<span class="math inline">\(:我们设概率空间上的随机变量\)</span>X <span class="math inline">\(的标准差\)</span>= $.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果$X , Y $是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><p>$E ( X + Y ) = EX + EY $.</p></li>
<li><p>$E ( X ) = EX $.</p></li>
<li><p>如果$X <span class="math inline">\(和\)</span>Y <span class="math inline">\(互相独立,那么\)</span>E ( XY ) = ( EX ) ( EY )
$.</p></li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X - EX ) ^2 ) &amp; = E ( X ^2 - 2 X ( EX ) + ( EX ) ^2 ) \\
&amp; = E ( X ^2 ) - 2 ( EX ) ( EX ) + ( EX ) ^2 \\
&amp; = E ( X ^2 ) - ( EX ) ^2
\end{aligned}
\]</span></p>
<p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当$X <span class="math inline">\(和\)</span>Y
$为独立的随机变量时,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( ( X + Y ) ^2 ) - ( EX + EY ) ^2 \\
&amp; = E ( ( X + Y ) ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2
\end{aligned}
\]</span></p>
<p>而又有:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X + Y ) ^2 ) &amp; = E ( X ^2 + 2 XY + Y ^2 ) \\
&amp; = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 )
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) - ( EX )
^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 \\
&amp; = VX + VY
\end{aligned}
\]</span></p>
<p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<p><span class="math display">\[
\Pr ( ( X - EX ) ^2 \geq \alpha ) \leq \cfrac { VX  } { \alpha  } ,
\alpha &gt; 0
\]</span></p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
VX &amp; = \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr (
\omega ) \\
&amp; \geq \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr (
\omega ) [ ( X ( \omega ) - EX ) ^2 &amp; \geq \alpha ] \\
&amp; \geq \sum _{ \omega \in \Omega  } \alpha \Pr ( \omega ) [ ( X (
\omega ) - EX ) ^2 &amp; \geq \alpha ] \\
&amp; = \alpha \Pr ( ( X - EX ) ^2 &amp; \geq \alpha )
\end{aligned}
\]</span></p>
<p>如果我们用$c ^2 VX <span class="math inline">\(代替\)</span>$,我们就有:</p>
<p>$( | X - EX | c ) { c ^2 } $.</p>
<p>简单来说,这个不等式说明:$X <span class="math inline">\(落在\)</span>(
EX - c , EX + c ) <span class="math inline">\(之外的概率至多为\)</span>
{ c ^2 } $.</p>
<p>另外,如果我们取$n <span class="math inline">\(个独立的样本\)</span>X
_1 , X _2 , . . . , X <em>n <span class="math inline">\(,令\)</span>S =
</em>{ i = 1 } ^n X _i <span class="math inline">\(,那么它的均值是\)</span>nEX <span class="math inline">\(,标准差是\)</span> <span class="math inline">\(,也就是说,\)</span> { n } <span class="math inline">\(落在\)</span>( EX - { } , EX + { } ) <span class="math inline">\(之外的概率小于等于\)</span> { c ^2 } $.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了$n <span class="math inline">\(个值\)</span>X _1 ,
X _2 , . . . , X _n
$,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p>$EX = { n } $.</p>
<p>$VX = { n - 1 } - { n ( n - 1 ) } $.</p>
<p>这里的$VX <span class="math inline">\(似乎与定义不是那么相符.但是它拥有更好的性质:\)</span>E
( VX ) = VX $.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \hat VX ) &amp; = \cfrac { 1  } { n - 1  } E ( \sum _{ i = 1  } ^n X
_i ^2 - \cfrac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n X
_j X _k ) \\
&amp; = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X _i ^2 ) -
\cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n E ( X _i X
_j ) ) \\
&amp; = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X ^2 ) -
\cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( ( EX ) ^2
[ j \ne k ] + E ( X ^2 ) [ j &amp; = k ] ) ) \\
&amp; = \cfrac { 1  } { n - 1  } ( nE ( X ^2 ) - \cfrac { 1  } { n  } (
nE ( X ^2 ) + n ( n - 1 ) ( EX ) ^2 ) ) \\
&amp; = E ( X ^2 ) - ( EX ) ^2 \\
&amp; = VX
\end{aligned}
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为$P ( A | B ) = { P ( B ) } \ $.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有${ B _i } <span class="math inline">\(是样本空间的一个划分,即\)</span>i , j <span class="math inline">\(,有\)</span>B _i B <em>j = <span class="math inline">\(,并且有\)</span></em>{ i = 1 } ^n B _i = <span class="math inline">\(.则有\)</span>P ( B _i | A ) = { P ( A ) } = { P (
A ) P ( B <em>j ) } = { </em>{ j = 1 } ^n P ( A B <em>j ) } = { </em>{ j
= 1 } ^n P ( A | B _j ) P ( B _j ) } \ $.</p>
<p>简化形式:$P ( B | A ) = { P ( A ) } \ $.</p>
<p>另外,我们考虑设$O ( B ) = { P ( B ) } <span class="math inline">\(,称\)</span> { P ( B | E ) }
$为贝叶斯算子,则同理可得:</p>
<p><span class="math display">\[
O ( B | E ) = O ( B ) \cfrac { P ( B | E )  } { P ( \lnot B | E )  }
\]</span></p>
<p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果$X <span class="math inline">\(是定义在概率空间\)</span><span class="math inline">\(上的随机变量,那么它的概率生成函数为\)</span>G
<em>X ( z ) = </em>{ k } ( X = k ) z ^k = E ( z ^X ) $.</p>
<p>不难发现$G _X ( z ) <span class="math inline">\(需要满足的条件:所有系数都非负并且\)</span>G _X ( 1
) = 1 $.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = G _X &#39; ( 1 ) \\
E ( X ^2 ) &amp; = G &#39; &#39; _X ( 1 ) + G _X &#39; ( 1 ) \\
VX &amp; = G _X &#39; &#39; ( 1 ) + G _X &#39; ( 1 ) - ( G _X &#39; ( 1
) ) ^2
\end{aligned}
\]</span></p>
<p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G ) &amp; = G &#39; ( 1 ) \\
Var ( G ) &amp; = G &#39; &#39; ( 1 ) + G &#39; ( 1 ) - ( G &#39; ( 1 )
) ^2
\end{aligned}
\]</span></p>
<p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<p><span class="math display">\[
G ( 1 + t ) = \sum _{ i \geq 0  } \cfrac { G ^{ ( i )  } ( 1 )  } { i
!  } t ^i
\]</span></p>
<p>另外,我们不难发现:$G _{ X + Y } ( z ) = G _X ( z ) G _Y ( z ) $.</p>
<p>根据前面的推导,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G _{ X + Y  } ) &amp; = Mean ( G _X ) + Mean ( G _Y ) \\
Var ( G _{ X + Y  } ) &amp; = Var ( G _X ) + Var ( G _Y )
\end{aligned}
\]</span></p>
<p>换句话说,若$G _X ( 1 ) = 1 , G <em>Y ( 1 ) = 1 <span class="math inline">\(,那么这个式子与直接对\)</span>G </em>{ X + Y }
$使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G _X ) &amp; = Mean ( G _{ X + Y  } ) - Mean ( G _Y ) \\
Var ( G _X ) &amp; = Var ( G _{ X + Y  } ) - Var ( G _Y )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为$p <span class="math inline">\(,反面向上的概率为\)</span>q
$,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设$N <span class="math inline">\(为所有不包含THTTH的硬币序列的生成函数,\)</span>S
<span class="math inline">\(为所有只有结尾为THTTH的硬币序列的生成函数,令\)</span>H
= pz , T = qz $,$1 $为空集,我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N \times ( H + T ) &amp; = N + S \\
N \times THTTH &amp; = S + S \times TTH
\end{aligned}
\]</span></p>
<p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设$A <span class="math inline">\(是我们要找到的字符串,\)</span>m <span class="math inline">\(是它的长度,令\)</span>A ^{ ( k ) } <span class="math inline">\(表示\)</span>A <span class="math inline">\(字符串的前\)</span>k <span class="math inline">\(个字符所组成的字符串,\)</span>A _{ ( k ) } <span class="math inline">\(表示\)</span>A <span class="math inline">\(字符串的后\)</span>k <span class="math inline">\(个字符所组成的字符串.这样的形式与\)</span>k
$阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S \\
N \times A &amp; = S ( \sum _{ k = 0  } ^{ m - 1  } A ^{ ( k )  } [ A ^{
( m - k )  } &amp; = A _{ ( m - k )  } ] )
\end{aligned}
\]</span></p>
<p>如果我们设$ <span class="math inline">\(为将字符串\)</span>A <span class="math inline">\(中的H替换成\)</span> { p } z <span class="math inline">\(,T替换成\)</span> { q } z
$之后的值,那么显然有:</p>
<p><span class="math display">\[
\begin{aligned}
N \times A &amp; = A \times S \times ( \sum _{ k = 1  } ^{ m  } \tilde {
A  } _{ ( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ] ) \\
N &amp; = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  }
[ A ^{ ( k )  } &amp; = A _{ ( k )  } ] ) \\
\cfrac { S - 1  } { H + T - 1  } &amp; = S \times ( \sum _{ k = 1  } ^{
m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ] )
\\
S \times ( 1 + ( 1 - H - T ) \times ( \sum _{ k = 1  } ^{ m  } \tilde {
A  } _{ ( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ] ) ) &amp; = 1
\end{aligned}
\]</span></p>
<p>这显然是一个卷积的形式.</p>
<p>令$w = <em>{ k = 1 } ^{ m } </em>{ ( k ) } [ A ^{ ( k ) } = A _{ ( k
) } ] $.</p>
<p>令$H ( z ) = 1 <span class="math inline">\(,\)</span>F ( z ) = ( 1 +
( 1 - z ) w ) <span class="math inline">\(,\)</span>G ( z ) = S $.</p>
<p>那么我们显然可以直接求$G ( z ) $的期望和方差,事实上:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k
)  } &amp; = A _{ ( k )  } ] \\
VX &amp; = ( EX ) ^2 - \sum _{ k = 1  } ^m ( 2 k - 1 ) \tilde { A  } _{
( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ]
\end{aligned}
\]</span></p>
<p>如果硬币是均匀的($p = q = { 2 } <span class="math inline">\()我们引入另一个符号:我们设\)</span>A : A = _{ k =
1 } ^m 2 ^{ k } [ A ^{ ( k ) } = A _{ ( k ) } ] <span class="math inline">\(.那么显然期望需要的抛硬币次数就是\)</span>( A : A
) $.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设$S _A <span class="math inline">\(为所有以HHT结尾的硬币序列的生成函数,设\)</span>S
_B <span class="math inline">\(为所有以HTT结尾的硬币序列的生成函数.\)</span>N
<span class="math inline">\(为其它的硬币序列的生成函数,令\)</span>H = T
= 0 . 5 z $.</p>
<p>我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S _A + S _B \\
N \times HHT &amp; = S _A \\
N \times HTT &amp; = S _A \times T + S _B
\end{aligned}
\]</span></p>
<p>解方程并带入$z = 1 <span class="math inline">\(,可以有得知以HHT结尾的概率为\)</span> { 3 } $.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为$A <span class="math inline">\(和\)</span>B $,那么可以求出:</p>
<p><span class="math display">\[
\cfrac { S _A  } { S _B  } = \cfrac { B : B - B : A  } { A : A - A :
B  }
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设$g <em>i <span class="math inline">\(表示进行了\)</span>i <span class="math inline">\(步还未结束的概率,\)</span>f </em>{ k , i } <span class="math inline">\(为进行了\)</span>i <span class="math inline">\(步恰好第\)</span>k <span class="math inline">\(个人胜利的概率,\)</span>F , G
$是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p>$1 + xG ( x ) = _k F _k ( x ) + G ( x ) $.</p></li>
<li><p>$( { 2 } x ) ^L G ( x ) = _{ j = 1 } ^n F <em>j ( x ) </em>{ i =
0 } ^{ L - 1 } ( { 2 } x ) ^i [ A _k ^{ ( L - i ) } = { A <em>j } </em>{
( L - i ) } ] $.</p></li>
</ol>
<p>第一个式子的用处在于带入$x = 1 <span class="math inline">\(,发现\)</span>_{ k } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{
L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  }
&amp; = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{
L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } &amp; = { A
_j  } _{ ( i )  } ]
\end{aligned}
\]</span></p>
<p>带入$x = 1 $,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [
A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]
\]</span></p>
<p>不难发现对于不同的$k <span class="math inline">\(,(2)的右边不同,而左边一定相同,这样就给出了\)</span>n
<span class="math inline">\(个等式,算上(1)一共有\)</span>n + 1 <span class="math inline">\(个等式,可以算出\)</span>G ( 1 ) , F _{ 1 n } ( 1 )
<span class="math inline">\(这\)</span>n + 1 $个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为$n + 1 <span class="math inline">\(的概率空间,其中\)</span>( _k ) = { k } p ^k q ^{ n
- k } \ $,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令$H ( z ) = q + pz <span class="math inline">\(,不难发现二项式分布的生成函数为\)</span>H ( z ) ^n
$.</p>
<p>不难发现,满足二项式分布的随机变量的均值是$np <span class="math inline">\(,方差是\)</span>npq $.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:$G ( z ) ^n = (
{ 1 - qz } ) ^n = _{ k } { k } p ^n q ^k z ^k $.</p>
<p>我们考虑如何求$G ( z ) <span class="math inline">\(的方差和均值,不妨设\)</span>F ( z ) = { p } = { p
} - { p } z <span class="math inline">\(,则\)</span>G ( z ) ^n = F ( z )
^{ - n } $.</p>
<p>不难发现$F ( z ) <span class="math inline">\(满足二项式分布.也就是说,以\)</span>( n , p , q )
<span class="math inline">\(为参数的负二项式分布也就是以\)</span>( - n ,
- { p } , { p } ) $为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为$1 <span class="math inline">\(的\)</span>n <span class="math inline">\(个点的树,问所有点对\)</span>( i , j ) ( 1 i , j n
) <span class="math inline">\(中,从\)</span>i <span class="math inline">\(走到\)</span>j $的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设$f _u <span class="math inline">\(表示\)</span>u <span class="math inline">\(随机走到它父亲的期望,\)</span>g _v <span class="math inline">\(表示\)</span>v <span class="math inline">\(的父亲(假设是\)</span>u <span class="math inline">\()走到\)</span>v $的期望.</p>
<p>对于$f _u $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f _u &amp; = \cfrac { \sum _{ u \rightarrow v  } ( f _v + f _u )  } {
\deg _u  } + 1 \\
f _u &amp; = \deg _u + \sum _{ u \rightarrow v  } f _v
\end{aligned}
\]</span></p>
<p>对于$g _v $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
g _v &amp; = \cfrac { g _u + g _v + \sum _{ u \rightarrow w , w \ne v  }
( g _v + f _w )  } { \deg _u  } + 1 \\
g _v &amp; = g _u + \sum _{ u \rightarrow w , w \ne v  } f _w + \deg _u
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵$n $个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从$1 <span class="math inline">\(号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案\)</span>+
1 $.当走到度数为$1 $的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设$f <em>u <span class="math inline">\(表示以\)</span>u <span class="math inline">\(为起点的路径的期望长度,不难注意到\)</span>f </em>{
leaf } = 1 <span class="math inline">\(且\)</span>f _u = 1 + { <em>u }
</em>{ u v v u } f _v <span class="math inline">\(.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得\)</span>f
_u = k <em>u f </em>{ fa } + b _u
$,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出$g
_v <span class="math inline">\(表示从\)</span>v <span class="math inline">\(的父亲(假设是\)</span>u <span class="math inline">\()走到\)</span>v <span class="math inline">\(的概率,再令\)</span>f _u <span class="math inline">\(表示从\)</span>u
$走到父亲的概率,类似Example1,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f _u &amp; = \cfrac { 1  } { \deg _u  } ( 1 + \sum _{ u \rightarrow v  }
f _v f _u ) \\
g _v &amp; = \cfrac { 1  } { \deg _u  } ( 1 + g _v g _u + \sum _{ u
\rightarrow w , w \ne v  } f _w g _v )
\end{aligned}
\]</span></p>
<p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为$
{ { 2 } } $.</p>
<p>把所有人权值从大到小排序,设$f <em>i <span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(个人的时候的期望,不难发现:\)</span>f </em>{ i } =
{ { 2 } } v <em>i + ( 1 - { { 2 } } ) f </em>{ i - 1 } $.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设$f <em>{ i , j } <span class="math inline">\(表示过了\)</span>i <span class="math inline">\(关,花费为\)</span>j <span class="math inline">\(的期望,不难发现所有的\)</span>f <span class="math inline">\(都需要与\)</span>f </em>{ 0 , 0 } <span class="math inline">\(取\)</span>$,这咋办?</p>
<p>我们考虑二分这个$f <em>{ 0 , 0 } <span class="math inline">\(,做的时候直接取\)</span><span class="math inline">\(,这样最后还会求出一个\)</span>f </em>{ 0 , 0 }
$,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的$f _{ 0 , 0 } <span class="math inline">\(越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取\)</span>$的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张$n m <span class="math inline">\(的图(假设\)</span>n m
<span class="math inline">\(),其中格点\)</span>( a , b ) <span class="math inline">\(表示现在还剩\)</span>a <span class="math inline">\(个Yes,\)</span>b <span class="math inline">\(个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从\)</span>(
n , m ) <span class="math inline">\(走到\)</span>( 0 , 0 )
$的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线$y
= x $翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从$( n , m ) <span class="math inline">\(走到\)</span>( 0
, 0 ) <span class="math inline">\(一定会经过\)</span>n <span class="math inline">\(条有向边,所以期望贡献一定要加上一个\)</span>n
<span class="math inline">\(.而如果我走到了直线\)</span>y = x <span class="math inline">\(上,那接下来的贡献是\)</span> { 2 }
$.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2>
<h3><span id="树">树</span></h3>
<ol type="1">
<li><p>随机树树高为$ $.</p></li>
<li><p>点的度数期望为$n $.</p></li>
</ol>
<h3><span id="数">数</span></h3>
<ol type="1">
<li>数字的期望因数个数为$V $.</li>
</ol>
<h3><span id="序列">序列</span></h3>
<ol type="1">
<li>随机序列的LIS长度期望为$O ( ) $.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) ) <span class="math inline">\(的算法,我们运行其\)</span>k $次,则正确率为$1 - ( 1
- p ) ^k <span class="math inline">\(,时间复杂度为\)</span>O ( kf ( n )
) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) <span class="math inline">\(,其中\)</span>f ( n ) <span class="math inline">\(为枚举部分的复杂度,\)</span>g ( n ) <span class="math inline">\(为单词枚举中计算所需的复杂度.大部分情况下应保证\)</span>g
( n ) $不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有$n $个互不重合的点,已知存在不超过$7 <span class="math inline">\(条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.\)</span>n
$.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O
( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$
{ 7 } <span class="math inline">\(个点.换句话说,我们随机一个点,这个点在这条直线上的概率是\)</span>
{ 7 } <span class="math inline">\(,因此随机两个点确定这条直线的概率为\)</span> { 49
} $.随机$1000 $次,错误概率为$1 - ( { 49 } ) ^{ 1000 } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为$n <span class="math inline">\(的序列,要求找出一个长度大于等于\)</span> { 2 }
<span class="math inline">\(的子序列,使这个子序列中所有数的\)</span><span class="math inline">\(最大,求最大的\)</span><span class="math inline">\(.\)</span>n ^6 <span class="math inline">\(,\)</span>a _i ^{ 12 } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$ { 2 } <span class="math inline">\(.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度\)</span>O
( n ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$ <span class="math inline">\(个质因子全都存下来,然后将\)</span>n <span class="math inline">\(个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个\)</span>$,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为$n <span class="math inline">\(的序列\)</span>a <span class="math inline">\(,有\)</span>m <span class="math inline">\(次询问,每次给定一个区间\)</span>[ l , r ] <span class="math inline">\(,问\)</span>a [ l , r ] <span class="math inline">\(中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.\)</span>(
n , m , 1 a _i n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A <span class="math inline">\(并判断它与其它向量的内积,这样复杂度为\)</span>O (
n ^2 d ) $.</p>
冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A =
<span class="math display">\[\begin{bmatrix}\vec { a _1  } , \vec { a
_2  } , . . . , \vec { a _n  } \end{bmatrix}\]</span>
<p><span class="math inline">\(,那我们要验证的无非是\)</span>B = AA ^T
<span class="math inline">\(中是否存在一个不在主对角线上的元素\)</span>B
_{ i , j } <span class="math inline">\(在\)</span> $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C <span class="math inline">\(,其中\)</span>C <span class="math inline">\(的主对角线元素与\)</span>B $相同,而其他元素全是$1
<span class="math inline">\(.接下来我们要做的无非是找到\)</span>B <span class="math inline">\(和\)</span>C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C <span class="math inline">\(,那么对于任意一个\)</span>X _{ m n } <span class="math inline">\(都应该满足\)</span>XB = XC <span class="math inline">\(,取\)</span>m = 1 <span class="math inline">\(,我们的问题就转化为:是否能找到一个\)</span>X <span class="math inline">\(,使得\)</span>XB XC <span class="math inline">\(?这显然可以随机化.计算前者的复杂度为\)</span>O (
nd ) <span class="math inline">\(,后者由于\)</span>C <span class="math inline">\(很特殊,可以在\)</span>O ( n )
$的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令$D = B - C <span class="math inline">\(,若返回相等但实际上不相等,则\)</span>D
$中至少存在一个不为$0 <span class="math inline">\(的数字,假设\)</span>D
<em>{ i , j } <span class="math inline">\(.我们令\)</span>E = X D <span class="math inline">\(,那么只有当\)</span>E <span class="math inline">\(是零向量时才会错误.而\)</span>E <em>j = </em>{ k }
X <em>k D </em>{ k , j } <span class="math inline">\(,不难解得:\)</span>E <em>i = - { D </em>{ i , j }
} </em>{ k i } X <em>k D </em>{ k , j } <span class="math inline">\(,也就是说如果\)</span>X <span class="math inline">\(的其它位置都确定了,那么\)</span>E <span class="math inline">\(只有一种取值会返回错误.由于\)</span>k <span class="math inline">\(一共就俩取值,所以正确率至少\)</span> { 2 } $.</p>
<p>至于找到答案:我们找到一个不为$0 <span class="math inline">\(的\)</span>E _i <span class="math inline">\(,那么一定存在一组解包含了第\)</span>i <span class="math inline">\(个向量,只需枚举另一个向量检验就行,复杂度\)</span>O
( nd ) $.</p>
<p>$k = 3 <span class="math inline">\(的话,我们注意到\)</span>
$意义下,$1 $和$2 $的平方都是$1 <span class="math inline">\(.考虑\)</span><em>{ j } B </em>{ i , j } ^2 X
<em>j = </em>{ j } B _{ i , j } X <em>j B </em>{ h , i } ^T
$,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) <span class="math inline">\(表示对长度为\)</span>n
$的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要$+ 1 <span class="math inline">\(或者\)</span>- 1
$或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n
- 1  } ( T _i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{
\frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } {
n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i
- 1 ) )
\end{aligned}
\]</span></p>
<p>由于$T ( n ) n <span class="math inline">\(,所以对于\)</span> { 2 } i
j <span class="math inline">\(,我们显然有:\)</span>T ( i ) + T ( n - i )
T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } {
2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  }
{ 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
&amp; \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明$c <span class="math inline">\(,\)</span>T ( n ) cn n
$,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log
( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } {
4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  }
\log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } {
4  } + \frac { n  } { 2  } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } {
3  } ) - \frac { c  } { 4  } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) )
$的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk &amp; = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } &amp; =
p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k &amp; = \frac { 1  } { p  }
\end{aligned}
\]</span></p>
<p>则期望复杂度为$O ( { p } ) $.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 <span class="math inline">\(和第二个位置\)</span>x _2 <span class="math inline">\(,显然只要问到\)</span>[ x _1 , x _2 )
$是正确的.</p>
<p>考虑因为是随机,所以$x _1 x _2 <span class="math inline">\(的概率应当是不低的(事实上约为\)</span> { 2 } <span class="math inline">\(),而此时的\)</span>[ x _1 , x _2 )
$中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . .
$.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E _{ t + 1  } &gt; E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } &amp; E _{ t + 1  } \leq
E _t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度$T _0 <span class="math inline">\(,降温速度\)</span>k ( 0 , 1 ) <span class="math inline">\(,以及终止温度\)</span>T _k <span class="math inline">\(,每次操作后让\)</span>T = kT
$,直到其小于终止温度.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数论相关</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文除特殊说明,所涉及数均为整数.</p>
<h3><span id="整除性及相关">整除性及相关</span></h3>
<p>如果$m &gt; 0 <span class="math inline">\(且\)</span> { m } <span class="math inline">\(是一个整数,我们就说\)</span>m <span class="math inline">\(整除\)</span>n <span class="math inline">\(,记作\)</span>m | n $.</p>
<p>能同时整除两个数$n <span class="math inline">\(和\)</span>m <span class="math inline">\(的数称为\)</span>n <span class="math inline">\(和\)</span>m <span class="math inline">\(的公因子,所有公因子中最大的那个称为最大公因子,记作\)</span>(
n , m ) <span class="math inline">\(.而最小的能同时被\)</span>n <span class="math inline">\(和\)</span>m <span class="math inline">\(整除的非零数被称为他们的最小公倍数,记作\)</span>lcm
( n , m ) <span class="math inline">\(.不难发现\)</span>lcm ( n , m ) (
n , m ) = nm $.</p>
<h4><span id="欧几里得算法">欧几里得算法</span></h4>
<p>欧几里得算法基于以下定理:</p>
<p>$( 0 , n ) = n <span class="math inline">\(且\)</span>( n , m ) = ( n
m , m ) , m &gt; 0 $.</p>
<p>考虑证明,首先,$k <span class="math inline">\(,\)</span>n <span class="math inline">\(和\)</span>m <span class="math inline">\(的公因子一定是\)</span>n <span class="math inline">\(和\)</span>m + kn <span class="math inline">\(的公因子,这是显然的.因此,\)</span>n <span class="math inline">\(和\)</span>m <span class="math inline">\(的公因子一定是\)</span>m <span class="math inline">\(和\)</span>n - m { m } $的公因子,而反之亦然.</p>
<p>另外有如下性质:</p>
<ol type="1">
<li><p>$( kn , km ) = k ( n , m ) <span class="math inline">\(以及\)</span>lcm ( kn , km ) = k  lcm ( n , m )
$.</p></li>
<li><p>若$a b <span class="math inline">\(,则\)</span>( a ^m - b ^m , a
^n - b ^n ) = a ^{ ( n , m ) } - b ^{ ( n , m ) } $.</p></li>
<li><p>如果$n ^a n ^b <span class="math inline">\(,则\)</span>n ^{ ( a ,
b ) } $.</p></li>
</ol>
<p>(1)的证明较为显然,我们考虑(2)的证明.</p>
<p>不妨假设$n m <span class="math inline">\(,当\)</span>n = m
$时显然成立.</p>
<p>当$n &lt; m $时:</p>
<p>假设$a &gt; b <span class="math inline">\(,考虑\)</span>( a ^m - b ^m
, a ^n - b ^n ) = ( a ^m - b ^m - k ( a ^n - b ^n ) , a ^n - b ^n )
$.</p>
<p>取$k = b ^{ m - n } $,则:</p>
<p><span class="math display">\[
\begin{aligned}
\gcd ( a ^m - b ^m , a ^n - b ^n ) &amp; = \gcd ( a ^m - b ^{ m - n  } a
^n , a ^n - b ^n ) \\
&amp; = \gcd ( a ^n ( a ^{ m - n  } - b ^{ m - n  } ) , a ^n - b ^n )
\end{aligned}
\]</span></p>
<p>由于$a b <span class="math inline">\(,所以显然\)</span>a ^n - b ^n a
^n $,于是:</p>
<p><span class="math display">\[
\gcd ( a ^m - b ^m , a ^n - b ^n ) = \gcd ( a ^{ m - n  } - b ^{ m -
n  } , a ^n - b ^n )
\]</span></p>
<p>自然得证.</p>
<p>接下来考虑(3)的证明:</p>
<p>如果$a = b <span class="math inline">\(,显然得证.不然,不妨设\)</span>a &gt; b
$注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n ^a &amp; \equiv 1 \pmod { m  } \\
n ^a - n ^{ a - b  } n ^b &amp; \equiv 1 - n ^{ a - b  } \pmod { m  } \\
n ^{ a - b  } &amp; \equiv 1 \pmod { m  }
\end{aligned}
\]</span></p>
<p>自然得证.</p>
<h4><span id="一些性质">一些性质</span></h4>
<p>令$n , m $.</p>
<ol type="1">
<li><p>$k | n k | m k | ( n , m ) $.</p></li>
<li><p>$<em>{ m | n } a <em>m = </em>{ m | n } a </em>{ { m } }
$.</p></li>
<li><p>$<em>{ m | n } </em>{ k | m } a <em>{ k , m } = </em>{ k | n }
<em>{ l | ( { k } ) } a </em>{ k , kl } $.</p></li>
</ol>
<p>另外,$<span class="math inline">\(有一个很著名的性质:对于数字\)</span>n , m <span class="math inline">\(,找到最小的正整数\)</span>x <span class="math inline">\(满足\)</span>y <span class="math inline">\(,\)</span>xn = ym $.</p>
<p>首先令$g = ( n , m ) <span class="math inline">\(,我们自然有\)</span>x { g } = y { g } <span class="math inline">\(,也就相当于\)</span>x { g } <span class="math inline">\(,由于\)</span>( { g } , { g } ) = 1 <span class="math inline">\(,所以左边的\)</span> { g } <span class="math inline">\(可以用逆元消掉,显然最小正整数解为\)</span>x = { g
} $.</p>
<h5><span id="example1cf1656hequal-lcmsubsets">Example1([CF1656H]Equal LCM
Subsets)</span></h5>
<p>注意到插入可能有点小困难,我们考虑从全集中删除:注意到如果对于一个数字的某一个质因子,如果它的指数大于了对方集合中相同质因子的最大指数,那这个数一定不可能存在,直接删掉.不难发现删完后就是合法的了.</p>
<p>首先,数据范围不允许我们判断质因子,那么怎么做呢?</p>
<p>显然合法的条件等价于$a <em>i | lcm ( b ) , i n <span class="math inline">\((当然这个还要反过来再写一遍,两个式子一起才是充要条件,这里为了方便只写一个),这个条件等价于\)</span></em>{
j = 1 } ^n ( { ( b _j , a _i ) } ) = 1 $.后者是方便做的.</p>
<p>然后上线段树处理一下,好像先random_shuffle一下再暴力删除也是对的.</p>
<h4><span id="基于值域预处理的快速-gcd">基于值域预处理的快速 GCD</span></h4>
<p>存在一种$O ( n ) <span class="math inline">\(预处理,\)</span>O ( 1 )
<span class="math inline">\(求任意两个小于等于\)</span>n <span class="math inline">\(的数的\)</span>$的方法:</p>
<p>引理:</p>
<p>对于任意整数$n <span class="math inline">\(,存在一种划分方式\)</span>n = abc <span class="math inline">\(,\)</span>a <span class="math inline">\(,\)</span>b <span class="math inline">\(,\)</span>c <span class="math inline">\(三个数要么是质数,要么\)</span> $.</p>
<p>证明:</p>
<p>如果$n <span class="math inline">\(存在一个大于等于\)</span>
$的质因子,显然成立.</p>
<p>否则,使用数学归纳,我们考虑$n <span class="math inline">\(的最小质因子为\)</span>p <span class="math inline">\(,设\)</span> { p } = xyz <span class="math inline">\(,不妨设\)</span>x y z $.</p>
<p>如果$x = 1 $,显然成立.</p>
<p>不然有$p x y z <span class="math inline">\(,而\)</span>pxyz = n <span class="math inline">\(,那么\)</span>p ^4 n <span class="math inline">\(,\)</span>p n ^{ { 4 } } $.</p>
<p>现在我们想要证明不存在$xp &gt; <span class="math inline">\(,\)</span>yp &gt; <span class="math inline">\(,\)</span>zp &gt; $.</p>
<p>如果存在,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
xyzp ^3 &amp; &gt; n ^{ \frac { 3  } { 2  }  } \\
np ^2 &amp; &gt; n ^{ \frac { 3  } { 2  }  } \\
p ^2 &amp; &gt; \sqrt { n  } \\
p &amp; &gt; n ^{ \frac { 1  } { 4  }  }
\end{aligned}
\]</span></p>
<p>与我们前面的结论不符合.</p>
<p>因而该引理成立,并且给出了$O ( n ) <span class="math inline">\(预处理所有数\)</span>abc $的方法.</p>
<p>接下来，设$m = <span class="math inline">\(,考虑使用\)</span>O ( n )
<span class="math inline">\(的时间求出每个小于等于\)</span>m <span class="math inline">\(的数对的\)</span><span class="math inline">\(,如果我们要求\)</span>( x , y ) <span class="math inline">\(,设\)</span>x = abc <span class="math inline">\(,显然\)</span>( x , y ) = ( a , y ) ( b , { ( a ,
y ) } ) ( c , { ( ab , y ) } ) $.</p>
<p>如果$a <span class="math inline">\(是质数，只需要判断\)</span>a <span class="math inline">\(是否整除\)</span>y $.</p>
<p>否则$( a , y ) = ( y a , a ) <span class="math inline">\(,因为\)</span>a $,因而可以直接查表.</p>
<h4><span id="裴蜀定理">裴蜀定理</span></h4>
<p>$a , b , m <span class="math inline">\(,则\)</span>x , y <span class="math inline">\(满足\)</span>ax + by = m <span class="math inline">\(,当且仅当\)</span>( a , b ) | m $.</p>
<p>证明如下:</p>
<p>若$a = 0 <span class="math inline">\(或\)</span>b = 0 $,显然成立.</p>
<p>不然,设集合$A = { xa + yb | x , y } <span class="math inline">\(中的最小正元素\)</span>d _0 = x _0 a + y _0 b
$,该集合中显然一定有正元素.</p>
<p>考虑取该集合中另一个正整数$d _1 = x _1 a + y _1 b &gt; d _0 <span class="math inline">\(,注意到\)</span>d _1 - d _0 = ( x _1 - x _0 ) a +
( y _1 - y _0 ) b A <span class="math inline">\(,所以\)</span>( d _1 , d
_0 ) A <span class="math inline">\(,如果\)</span>d _0 d _1 $,那么$0 &lt;
( d _1 , d _0 ) &lt; d _0 <span class="math inline">\(,与假设不符.所以这个集合里的所有数一定都是\)</span>d
_0 $的倍数.</p>
<p>事实上还有另一种证明方式:</p>
<p>如果我们定义一个非空集合$I <span class="math inline">\(,满足其对加法和数乘(\)</span>a , x I , ax I <span class="math inline">\()均封闭,那么我们可以证明其中存在一个唯一的数字\)</span>g
<span class="math inline">\(满足所有数都是\)</span>g $的倍数.</p>
<p>如果$I = { 0 } <span class="math inline">\(,可以取\)</span>g = 0
$.</p>
<p>反之,显然其中有正有负(因为可以取$a = - 1 <span class="math inline">\(),我们设\)</span>I <em>+ = { k I | k } <span class="math inline">\(取\)</span>g = I </em>+ <span class="math inline">\(.\)</span>a I <span class="math inline">\(,不妨设\)</span>a = gq + r , r </p>
<p>=$, 令 <span class="math inline">\(q=\lfloor\frac a
b\rfloor\)</span>, 那 么 我 们 有 $</p>
<p>=</p>
<p>同样我们可以得到:</p>
<p>x_1&amp;y_1\</p>
<p>x_2&amp;y_2</p>
<p>\end{matrix}]</p>
<p>=</p>
<p>$, 即 <span class="math inline">\(ax_1+by_1=\gcd(a,b)\)</span>,
$(x_1,y_1)</p>
<h5><span id="example1xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489eeel-and-grid">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</span></h5>
<p>题意:$h w ( h , w ^6 ) <span class="math inline">\(的格子图,只能往下往右走,走到边界会循环,问从\)</span>(
0 , 0 ) $开始走遍历走一个哈密顿回路的方案数.</p>
<p>这题最重要的地方其实在于观察到,由于每个点只会被走到一次(除了$( 0 , 0
)
$,它会被走到两次,但只会由其它格子走来一次),因此如果抽象成图,每个格子只会有一个出边和一个入边.这意味着每个格子上面的和左边的格子必定只有一个指向它,进一步地,这意味着这两个格子的状态必然相同.</p>
<p>由此我们发现,每条副对角线(取膜意义下)的状态必然相同,而取膜意义下的副对角线有多少条呢?不难注意到是$d
= { ( h , w ) } = ( h , w ) <span class="math inline">\(条.也就是说,我们只需要确定这\)</span>d <span class="math inline">\(条对角线的值,就可以确定整个矩阵的答案.假设\)</span>R
<span class="math inline">\(表示向右走,\)</span>D <span class="math inline">\(表示向下走,\)</span>a _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(条副对角线的状态,最后的操作序列自然是\)</span>a _0
a <em>1 . . . a </em>{ d - 1 } a _0 a _1 . . . $.</p>
<p>那么我们接下来要做的就是给这$d
$条副对角线定向,并判断一个方案是否合法.注意到一个方案不合法当且仅当出现了多于$1
<span class="math inline">\(个环.那这又意味着什么呢?意味着存在一个点,它可以通过少于\)</span>hw
<span class="math inline">\(次走动走回自己.这显然是不被我们允许的.另一件不难发现的事是,第一个走回自己的点一定是\)</span>(
0 , 0 ) <span class="math inline">\(.再不难发现的是,走回自己的时候一定是经过了若干个周期:\)</span>a
_0 a <em>1 . . . a </em>{ d - 1 } a <em>0 . . . a </em>{ d - 1 } <span class="math inline">\(,因为每次向下或者向右走都会走到下一条副对角线,而且最后要回到自己.这就注意到每一个循环\)</span>a
_0 a <em>1 . . . a </em>{ d - 1 }
$内部具体什么情况是不在乎的,只在乎经历过这个过程之后会发生什么样的变化.</p>
我们不妨假设序列${ a } <span class="math inline">\(中有\)</span>k <span class="math inline">\(个\)</span>R <span class="math inline">\(,\)</span>d - k <span class="math inline">\(个\)</span>D <span class="math inline">\(,那会产生这种情况当且仅当\)</span>x , x &lt; { d }
<span class="math inline">\(,\)</span>
<span class="math display">\[\begin{cases}h | x ( d - k ) \\ w | xk
\end{cases}\]</span>
<p><span class="math inline">\(.注意到这等价于寻找最小的\)</span>x <span class="math inline">\(,判断其是否小于\)</span> { d } <span class="math inline">\(,于是条件等价于自然有\)</span>x = lcm ( { ( d - k
, h ) } , { ( w , k ) } ) <span class="math inline">\(,枚举\)</span>k
$并判断即可.</p>
<h3><span id="素数及相关">素数及相关</span></h3>
<h4><span id="定义">定义</span></h4>
<p>可以利用裴蜀定理证明素数的定义等价于$a , b , p | ab p | a p | b
$.</p>
<p>考虑先用最基础的定义得到这个命题,考虑$p | ab , p a $,则$1 = px + ay
<span class="math inline">\(有解,则\)</span>b = pxb + ( ab ) y <span class="math inline">\(,右边都是\)</span>p <span class="math inline">\(的倍数,所以\)</span>p | b $.</p>
<p>这个命题反推的话,考虑设$p = ab , a , b <span class="math inline">\(,则\)</span>p | ab <span class="math inline">\(且\)</span>p a , p b $,不符.</p>
<h5><span id="example1具体数学422">Example1(《具体数学》4.22)</span></h5>
<p>证明:在$n <span class="math inline">\(进制下,若\)</span>( 11 . . . 1
) _n $的$1 $的个数不是质数则其一定不是质数..</p>
<p>设$1 <span class="math inline">\(的个数为\)</span>m <span class="math inline">\(,则\)</span>( 11 . . . 1 ) <em>n = </em>{ i = 0 }
^{ m - 1 } n ^i $.</p>
<p>如果$m prime <span class="math inline">\(,不妨设则\)</span>m = cd , c
d $.</p>
<p>则</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ m - 1  } n ^i &amp; = \sum _{ i = 0  } ^{ c - 1  } n
^{ di  } \sum _{ j = 0  } ^{ d - 1  } n ^{ j  } \\
&amp; = ( \sum _{ i = 0  } ^{ c - 1  } n ^{ di  } ) ( \sum _{ j = 0  }
^{ d - 1  } n ^j )
\end{aligned}
\]</span></p>
<p>显然不是质数.</p>
<h4><span id="唯一分解定理算数基本定理">唯一分解定理(算数基本定理)</span></h4>
<p>任何正整数都只有一种方式以素数非减的次序写成素数的乘积.</p>
<p>证明:</p>
<p>考虑数学归纳法,设小于$n $的数全部满足.</p>
<p>则对于$n <span class="math inline">\(,如果它不满足条件,一定存在两种分解方式\)</span>n =
_{ i = 1 } ^m p <em>i = </em>{ i = 1 } ^k q _i $.</p>
<p>首先,如果$p _1 = q _1 $,根据归纳假设,显然不成立.</p>
<p>不失一般性,设$p _1 &lt; q _1 <span class="math inline">\(.则\)</span>q _1 | p <em>1 </em>{ i = 2 } ^m p _i
<span class="math inline">\(,显然\)</span>q _1 p _1 <span class="math inline">\(,所以\)</span>q <em>1 | </em>{ i = 2 } ^m p <em>i
<span class="math inline">\(,设\)</span>s = </em>{ i = 2 } ^m p _i <span class="math inline">\(,但这是不可能的,因为\)</span>s &lt; n <span class="math inline">\(,根据归纳假设,它只有一种分解方式,这种方式中显然不可能存在\)</span>p
_1 $.</p>
<p>那么根据上述证明,我们可以将一个数表示为以下形式:$n = _p p ^{ n _p } ,
n _p $.</p>
<p>另外不难证明的一点是,假设$n _p = k <span class="math inline">\(,那么最小质因子一定不大于\)</span> $.</p>
<h5><span id="example1cf986foppafuncan-style-remastered">Example1([CF986F]Oppa
Funcan Style Remastered)</span></h5>
<p>首先对$k <span class="math inline">\(做pollard-Rho算法.注意到我们可以默认\)</span>q _i
$是质因子,这显然不会影响答案.</p>
<p>然后,如果只有一个质因子,显然直接判断.</p>
<p>如果有两个质因子,是经典的二元不定方程.</p>
<p>如果有三个质因子,此时最小质因子的大小就不大于$
$,做同余最短路即可.</p>
<h4><span id="素数的个数">素数的个数</span></h4>
<p>首先,欧几里得证明了素数有无穷多个:</p>
<p>假设素数有有限个,分别为$p _1 , p _2 , . . . p <em>m <span class="math inline">\(,则\)</span></em>{ i = 1 } ^m p _i + 1
$无法被其中任何素数整除,则假设不成立.</p>
<p>在此基础上,我们可以定义欧几里得数:</p>
<p>$e _1 = 2 , e <em>n = 1 + </em>{ i = 1 } ^{ n - 1 } e _i $.</p>
<p>令$( n ) <span class="math inline">\(表示小于等于\)</span>n <span class="math inline">\(的素数个数,有\)</span>{ _{ n + } { n } } = 1
$.</p>
<p>有切比雪夫定理(又称贝特朗假设):若$n &gt; 1 , p prime , p ( n , 2 n )
$.</p>
<p>又有狄利克雷定理:若$( a , b ) = 1 , { an + b }
$中包含了无穷个素数.</p>
<p>(顺便一提,当$a = 4 <span class="math inline">\(或者\)</span>a = 6
<span class="math inline">\(,\)</span>b = - 1
$的时候是好证明的,由于素数要么形如$6 n - 1 $要么形如$6 n + 1
$,或者要么形如$4 n - 1 $要么形如$4 n + 1
$,只需要类似证明素数无限那样乘一乘)</p>
<p>同时,我们还有以下结论:$_{ 1 p n p prime } { p } n $.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq p \leq n \land p \in prime  } \cfrac { 1  } { p  } &amp;
= \sum ^n _{ k = 1  } \cfrac { \pi ( k ) - \pi ( k - 1 )  } { k  } &amp;
= \sum ^n _{ k = 1  } \cfrac { \pi ( k )  } { k  } - \sum ^n _{ k = 1  }
\cfrac { \pi ( k - 1 )  } { k  } \\
&amp; = \sum ^n _{ k = 1  } \cfrac { \pi ( k )  } { k  } - \sum ^{ n -
1  } _{ k = 0  } \cfrac { \pi ( k )  } { k + 1  } \\
&amp; = \sum ^{ n - 1  } _{ k = 1  } \cfrac { \pi ( k )  } { k  } +
\cfrac { \pi ( n )  } { n  } - \sum ^{ n - 1  } _{ k = 1  } \cfrac { \pi
( k )  } { k + 1  } - \cfrac { \pi ( 0 )  } { 1  } \\
&amp; = \sum ^{ n - 1  } _{ k = 1  } \cfrac { \pi ( k )  } { k ( k + 1
)  } + \cfrac { \pi ( n )  } { n  } \\
&amp; = \sum ^{ n - 1  } _{ k = 1  } { ( \cfrac { 1  } { k \log k  }
)  } + O ( \frac { 1  } { \log n  } ) &amp; = O ( \log \log n ) + O (
\frac { 1  } { \log n  } )
\end{aligned}
\]</span></p>
<h5><span id="example1具体数学420">Example1(《具体数学》4.20)</span></h5>
<p>证明:存在一个常数$b <span class="math inline">\(满足\)</span> ^b , ^{
2 ^b } , ^{ 2 ^{ 2 ^b } } . , . . $都是质数.</p>
<p>如此构造数列:设$p _1 = 2 <span class="math inline">\(,且\)</span>p
<em>n $为满足$2 ^{ p </em>{ n - 1 } } &lt; p <em>n &lt; 2 ^{ p </em>{ n
- 1 } + 1 } $的最小质数.</p>
<p>通过构造不难发现:$p _{ n - 1 } = _2 p _n $.</p>
<p>根据整值函数的性质,我们有$_2 x = _2 x <span class="math inline">\(.考虑反向数学归纳,考虑当\)</span>n + <span class="math inline">\(时构造满足题目条件,那么\)</span>p ^{ n - 1 } = _2
^{ 2 ^{ 2 ^{ . . . ^{ b } } } } = ^{ 2 ^{ . . . ^{ b } } } <span class="math inline">\(,自然也满足条件.所以如果设\)</span>_2 ^{ ( n ) } x
<span class="math inline">\(为不断对\)</span>x <span class="math inline">\(迭代求\)</span><em>2 <span class="math inline">\(做\)</span>n <span class="math inline">\(次后的答案,只需构造\)</span>b = </em>{ n + } _2 ^{
( n ) } p _n $即可.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证:</p>
<p><span class="math display">\[
\mu ( \gcd ( a , b ) ) = 0 \Leftrightarrow \forall n &gt; 0 , \mu ( an +
b ) = 0
\]</span></p>
<p>左推右是简单的.接下来考虑右推左.</p>
<p>考虑狄利克雷定理,数列${ { ( a , b ) } } <span class="math inline">\(.不妨反证,假设\)</span>( ( a , b ) ) <span class="math inline">\(,不妨设\)</span>p = { ( a , b ) } <span class="math inline">\(,\)</span>p ( a , b ) = ax + b <span class="math inline">\(,也就是\)</span>( p ( a , b ) ) = 0 <span class="math inline">\(,注意到\)</span>( ( a , b ) ) <span class="math inline">\(,此时必有\)</span>p | ( a , b ) <span class="math inline">\(,而\)</span>p <span class="math inline">\(无限,\)</span>( a , b )
$的素因子有限,这就导出了矛盾.</p>
<h4><span id="欧几里得数">欧几里得数</span></h4>
<p>定义欧几里得数:$e _1 = 2 , e <em>n = 1 + </em>{ i = 1 } ^{ n - 1 } e
<em>i <span class="math inline">\(.不难发现\)</span>e <em>n = e </em>{ n
- 1 } ( e </em>{ n - 1 } - 1 ) $.</p>
<h4><span id="费马数">费马数</span></h4>
<p>定义费马数$f _n = 2 ^{ 2 ^n } + 1 <span class="math inline">\(.不难发现\)</span>f <em>n = ( f </em>{ n - 1 } - 1
) ^2 + 1 $.</p>
<p>另外,费马数还满足$f <em>n = </em>{ i = 0 } ^{ n - 1 } f <em>i + 2
$,我们考虑这个式子的证明:显然后面那一个连乘会得到若干项$2 <span class="math inline">\(的次幂,并且这些项两两不同,根据几何级数,我们有\)</span></em>{
i = 0 } ^{ n - 1 } f _i + 1 $=$2 ^{ 2 ^{ n } } $,于是显然得证.</p>
<h5><span id="example1具体数学417">Example1(《具体数学》4.17)</span></h5>
<p>求证:如果$m n <span class="math inline">\(,则\)</span>f _m f _n
$.</p>
<p>不妨假设$m &lt; n <span class="math inline">\(,有:\)</span>( f _m , f
_n ) = ( f _m , 2 ) = 1 $.</p>
<h5><span id="example2具体数学418">Example2(《具体数学》4.18)</span></h5>
<p>求证:若$2 ^n + 1 <span class="math inline">\(是质数,则\)</span>n
$是$2 $的整数幂.</p>
<p>如果$n = qm <span class="math inline">\(且\)</span>q
$是奇数,我们有:$2 ^n + 1 = ( 2 ^m + 1 ) ( 2 ^{ n - m } - 2 ^{ n - 2 m }
+ 2 ^{ n - 3 m } . . . - 2 ^m + 1 ) $.</p>
<h4><span id="miller-rabin算法">Miller-Rabin算法</span></h4>
<p>如果判断$n <span class="math inline">\(是否是质数,取\)</span>a &lt; n
<span class="math inline">\(,设\)</span>n - 1 = d ^r $.</p>
<p>则要么$a ^d ( n ) $.</p>
<p>要么$i $,使得$0 i &lt; r <span class="math inline">\(,\)</span>a ^{ d
^i } - 1 ( n ) $.</p>
<p>若一个都不满足,则n一定不是质数,不然可能是质数.</p>
<p>但是若取足够多的不同的$a <span class="math inline">\((如果选\)</span>m <span class="math inline">\(个),那么\)</span>n $是质数的可能性更大.</p>
<p>此为Miller-Rabin算法,复杂度$O ( m log _2 n ) $.不保证正确性.</p>
<p>其中a通常取质数,原因不详.（事实上，如果a取前八个小质数，在$2 ^{ 64 }
$内是不会出错的）</p>
<h4><span id="pollard-rho算法">Pollard-Rho算法</span></h4>
<p>对$n <span class="math inline">\(做质因数分解,若能找到\)</span>a
<span class="math inline">\(使得\)</span>a | n <span class="math inline">\(,则考虑对\)</span> { a } <span class="math inline">\(和\)</span>a $分别进行质因数分解.</p>
<p>考虑随机$a <span class="math inline">\(,若\)</span>n <span class="math inline">\(有\)</span>m <span class="math inline">\(个因数,那么显然随机到\)</span>a <span class="math inline">\(使得\)</span>a | n <span class="math inline">\(的概率为\)</span> { n } $,显然不太优秀.</p>
<p>考虑改变随机策略,我们考虑随机一个$a <span class="math inline">\(使得\)</span>( a , n ) <span class="math inline">\(,那么\)</span>( a , n ) <span class="math inline">\(就是\)</span>n $的一个因子.</p>
<p>这种情况下,随机的概率是$ { n } $,仍然很不优秀.</p>
<p>考虑使用生日悖论优化,随机$k <span class="math inline">\(个数\)</span>a <span class="math inline">\(.两两匹配得到\)</span>k ^2 <span class="math inline">\(个值,这些值全都不整除\)</span>n
$的概率可以用生日悖论来计算.</p>
<p>当$k = 10 $时,错误的概率会很小,但是复杂度仍然很高,无法接受.</p>
<p>考虑构造$a _i = [ ( a _{ i - 1 } ) ^2 + b ] n $.</p>
<p>考虑该数列的性质,当$b <span class="math inline">\(确定时,\)</span>a
$一定有循环节.</p>
<p>显然当$x | ( a <em>i - a <em>j ) <span class="math inline">\(,则\)</span>x | [ ( a _i - a _j ) ( a _i + a _j )
- b + b ] <span class="math inline">\(,\)</span>x | ( a </em>{ i + 1 } -
a </em>{ j + 1 } ) $.</p>
<p>因此,我们可以利用floyd判环法(双指针法)找出循环节.</p>
<p>并且在这个过程中,我们可以预处理出大量的$a _{ i + len } - a _i $.</p>
<p>复杂度极其玄学,但是实际应用中不差.</p>
<h4><span id="狄利克雷前缀和">狄利克雷前缀和</span></h4>
<p>已知数列$a <span class="math inline">\(,求数列\)</span>b <span class="math inline">\(满足\)</span>b <em>n = </em>{ d | n } a _d $.</p>
<p>我们将一个数的质因数分解看作它的向量表示.更直接地,如果$n = _{ i = 1 }
^k p _i ^{ q _i } <span class="math inline">\(,其中\)</span>p _i <span class="math inline">\(是第\)</span>i <span class="math inline">\(大的质数.我们将其写作向量\)</span>( q _1 , q _2 ,
. . . , q _k ) $的形式,并做高位前缀和.</p>
<p>可以用$O ( n n ) $的时间复杂度解决问题.</p>
<h3><span id="阶乘">阶乘</span></h3>
<p>我们定义$n ! = _{ i = 1 } ^n i $,特别地,$0 ! = 1 $.</p>
<p>考虑估计$n ! <span class="math inline">\(的大小,不难发现\)</span>( n
! ) ^2 = _{ i = 1 } ^n i ( n + 1 - i ) $.</p>
<p>而函数$y = i ( n + 1 - i ) , i <span class="math inline">\(显然在\)</span>i = 1 <span class="math inline">\(和\)</span>i = n <span class="math inline">\(时取最小值,而在\)</span>i = { 2 } $时取最大值.</p>
<p>那么我们有$<em>{ i = 1 } ^n n ( n ! ) ^2 </em>{ i = 1 } ^n { 4 }
$.</p>
<p>于是$n ^{ { 2 } } n ! { 2 ^n } $.</p>
<p>还有一种估计方式是考虑$_{ n } { ! } <span class="math inline">\(,由Stolz定理及其推论,我们知道若\)</span>a _n &gt;
0 , { a <em>n } = a <span class="math inline">\(,那么\)</span></em>{ n }
= a <span class="math inline">\(.而我们令\)</span>a _n = { n ! } <span class="math inline">\(,\)</span> { a <em>n } = ( 1 + { n } ) ^n <span class="math inline">\(,所以\)</span></em>{ n } { } = e <span class="math inline">\(,于是我们可以估计\)</span>n ! ( { e } ) ^n $.</p>
<p>事实上有一种更准确的估计方法:$n ! ( { e } ) ^n $.</p>
<p>考虑设$_p ( n ! ) <span class="math inline">\(为\)</span>n ! <span class="math inline">\(中质因子\)</span>p
$的个数,我们分析一下这个函数:</p>
<p>首先显然有:$<em>p ( n ! ) = </em>{ k } { p ^k } { p - 1 } $.</p>
<p>我们考虑以$v _p ( n ) <span class="math inline">\(表示\)</span>n
<span class="math inline">\(在\)</span>p <span class="math inline">\(进制下各位数字之和,不妨设第\)</span>k <span class="math inline">\(位数字为\)</span>w <span class="math inline">\(.那么这个数字对于最后的答案的贡献为\)</span>w ( p
^{ k - 1 } + p ^{ k - 2 } + . . . + 1 ) = w { p - 1 } = { p - 1 } <span class="math inline">\(.求和得到\)</span>_p ( n ! ) = { p - 1 } $.</p>
<h5><span id="example具体数学455">Example(《具体数学》4.55)</span></h5>
<p>令$P <em>n = </em>{ i = 1 } ^n i ! <span class="math inline">\(,求证:\)</span>P <em>n ^4 ( n + 1 ) P </em>{ 2 n }
$.</p>
<p>考虑对于每个质因子,分开考虑它在前者和后者内出现的次数.</p>
<p>我们不妨将$p <span class="math inline">\(和\)</span>p ^k
$分开考虑,于是显然下面的式子是上面的式子成立的充分条件:</p>
<p><span class="math display">\[
\sum _{ m \geq 1  } \sum _{ i = 1  } ^{ 2 n  } \lfloor \cfrac { i  } { p
^m  } \rfloor \geq 4 \sum _{ m \geq 1  } \sum _{ i = 1  } ^n \lfloor
\cfrac { i  } { p ^m  } \rfloor + [ p ^m \mid ( n + 1 ) ]
\]</span></p>
<p>我们不妨对上面这个式子使用数学归纳,也就是说它的充分条件是:</p>
<p><span class="math display">\[
\lfloor \cfrac { 2 n - 1  } { p ^m  } \rfloor + \lfloor \cfrac { 2 n  }
{ p ^m  } \rfloor \geq 4 \lfloor \cfrac { n  } { p ^m  } \rfloor + [ n
\equiv - 1 \pmod { p ^m  } ] - [ n \equiv 0 \pmod { p ^m  } ]
\]</span></p>
<p>这个式子,当$1 n p ^m <span class="math inline">\(时显然成立.而当\)</span>n <span class="math inline">\(每增大\)</span>p ^m $的时候,左右两边同时增大$4
$,于是也是成立的,由此可以数学归纳.</p>
<h3><span id="互素">互素</span></h3>
<p>如果两个数$n <span class="math inline">\(和\)</span>m <span class="math inline">\(满足\)</span>( n , m ) = 1 <span class="math inline">\(,我们称他们互素,记作\)</span>n m $.</p>
<p>我们显然有这样两条性质:</p>
<ol type="1">
<li><p>$ { ( n , m ) } { ( n , m ) } $.</p></li>
<li><p>$k n k m k nm $.</p></li>
</ol>
<h5><span id="example1具体数学442">Example1(《具体数学》4.42)</span></h5>
<p>证明:如果两个分数$ { n } <span class="math inline">\(和\)</span> { n
’ } <span class="math inline">\(满足\)</span>n m <span class="math inline">\(且\)</span>n ’ m ’ <span class="math inline">\(,则\)</span>( mn ’ + m ’ n ) ( nn ’ ) <span class="math inline">\(的充分必要条件是\)</span>n n ’ $.</p>
<p>首先,如果$( n , n ’ ) $,显然不可能满足条件,必要性得证.</p>
<p>考虑充分性,如果$n n ’ <span class="math inline">\(,则只需证明\)</span>n ( mn ’ + m ’ n ) n ’ ( mn ’
+ m ’ n ) $即可.</p>
<p>而$( n , mn ’ + m ’ n ) = ( n , mn ’ ) = 1
$,另一个式子同理,于是得证.</p>
<h5><span id="example2">Example2</span></h5>
<p>证明:$<em>{ 0 k &lt; m } f ( k ) = </em>{ d | m } _{ 0 k &lt; d } f (
{ d } ) [ k d ] \ $.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 0 \leq k &lt; m  } f ( k ) &amp; = \sum _{ d | m  } \sum _{ 0
\leq k &lt; m , d | k  } f ( k ) [ \gcd ( k , m ) &amp; = d ] \\
&amp; = \sum _{ d | m  } \sum _{ 0 \leq k &lt; m , d | k  } f ( k ) [
\frac { k  } { d  } \bot \frac { m  } { d  } ] \\
&amp; = \sum _{ d | m  } \sum _{ 0 \leq k &lt; \frac { m  } { d  }  } f
( kd ) [ k \bot \frac { m  } { d  } ] \\
&amp; = \sum _{ d | m  } \sum _{ 0 \leq k &lt; d  } f ( \frac { km  } {
d  } ) [ k \bot d ]
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学463">Example3(《具体数学》4.63)</span></h5>
<p>证明:满足$a ^n + b ^n = c ^n ( n , n &gt; 2 ) <span class="math inline">\(的最小的(\)</span>n <span class="math inline">\(为第一关键字,\)</span>c <span class="math inline">\(为第二关键字)一组正整数解(即费马大定理最小的反例)一定满足以下性质:(另外,\)</span>n
= 4 $的情况早被证明了无解)</p>
<ol type="1">
<li><p>$n prime $.</p></li>
<li><p>$m , a + b =</p>
<span class="math display">\[\begin{cases}m ^n &amp; n \nmid c \\ n ^{ n
- 1  } m ^n &amp; n \mid c \end{cases}\]</span>
<p>$.</p></li>
</ol>
<p>首先证明(1),如果$n <span class="math inline">\(是最小的满足条件的数但并不是质数,我们不妨设\)</span>n
= xy , x &gt; 2 <span class="math inline">\(,则\)</span>( a ^y ) ^x + (
b ^y ) ^x = ( c ^y ) ^x $,显然这是更小的一组反例,于是(1)得证.</p>
<p>接下来考虑性质(2),注意到$a , b , c
$必然两两互质,不然可以两边同时除以一个数构造出更小的解,又注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\gcd ( a + b , \cfrac { a ^n + b ^n  } { a + b  } ) &amp; = \gcd ( a + b
, ( a ^{ n - 1  } - a ^{ n - 2  } b + . . . + b ^{ n - 1  } ) ) \\
\gcd ( a + b , \cfrac { c ^n  } { a + b  } ) &amp; = \gcd ( a + b , na
^{ n - 1  } ) \\
\gcd ( a + b , \cfrac { c ^n  } { a + b  } ) &amp; = \gcd ( a + b , n )
\end{aligned}
\]</span></p>
<p>如果$( a + b , n ) = 1 <span class="math inline">\(,那么我们有\)</span>( a + b ) { a + b } <span class="math inline">\(.接下来考虑每一个质因子\)</span>p <span class="math inline">\(,如果\)</span>( a + b ) <span class="math inline">\(中有\)</span>x <span class="math inline">\(个\)</span>p <span class="math inline">\(,\)</span>c <span class="math inline">\(中有\)</span>y <span class="math inline">\(个\)</span>p <span class="math inline">\(,于是\)</span>c ^n <span class="math inline">\(中有\)</span>ny <span class="math inline">\(个\)</span>p <span class="math inline">\(,我们自然有:\)</span>x = ny <span class="math inline">\(,于是\)</span>m <span class="math inline">\(满足\)</span>a + b = m ^n $.</p>
<p>如果$n ( a + b ) <span class="math inline">\(,我们就有:\)</span>( a +
b , { a + b } ) = n <span class="math inline">\(,此时必有\)</span>n c
<span class="math inline">\(,\)</span>n ^n c ^n <span class="math inline">\(,并且不难发现:\)</span>n ^k { a + b } n ^{ n - k }
( a + b ) <span class="math inline">\(,由于上面提到的\)</span><span class="math inline">\(的原因,\)</span>{ k , n - k } = 1 <span class="math inline">\(,显然\)</span>k = 1 <span class="math inline">\(或者\)</span>k = n - 1 <span class="math inline">\(.下面只需要证明\)</span>k n - 1 $.</p>
<p>冷静一下,如果$n | ( a + b ) , n ^2 ( a + b ) <span class="math inline">\(,令\)</span>m = a + b $,此时必有:</p>
<p><span class="math display">\[
\begin{aligned}
c ^n &amp; = a ^n + ( m - a ) ^n \\
&amp; = a ^n + ( - a ) ^n + nm ( - a ) ^{ n - 1  } + \frac { n ( n - 1
)  } { 2  } m ^2 ( - a ) ^{ n - 2  } + \cdots
\end{aligned}
\]</span></p>
<p>注意到$n <span class="math inline">\(是奇数,\)</span>a ^n + ( - a )
^n = 0 <span class="math inline">\(,而\)</span>n ^n | c ^n n ^3 | c ^n
<span class="math inline">\(,又注意到\)</span>n ^3 | nm ^2 <span class="math inline">\(,我们把两边对\)</span>n ^3 $取模:</p>
<p><span class="math display">\[
0 \equiv nx ( - a ) ^{ n - 1  } \pmod { n ^3  }
\]</span></p>
<p>注意到若$n ^2 m $,则该式子必不成立.</p>
<h4><span id="stern-brocot-树">Stern-Brocot 树</span></h4>
<p>Stern-Brocot树是一种可以不重不漏列举有理数的方式,它的构造如下:</p>
<p>一开始,序列中有两个分数:$ { 1 } <span class="math inline">\(和\)</span> { 0 } $,这里使用了$0
$作分母,但我们暂且认为它是正确的,因为这样会出现很多方便的性质.</p>
<p>接下来,不断地对这个序列进行以下操作:在两个相邻的分数$ { n } <span class="math inline">\(和\)</span> { n ’ } <span class="math inline">\(之间插入一个新分数\)</span> { n + n ’ } $.</p>
<p>这么无限构造下去得到的序列满足两个性质:</p>
<ol type="1">
<li><p>所得到的分数全都是最简分数.</p></li>
<li><p>所得到的分数不重不漏,换句话说,任意非负有理数都在这个序列中出现恰好一次.</p></li>
</ol>
<p>我们不妨认为$ { 0 } = +
$,那么不难发现这么构造序列,所得到的序列一定是单调递增的.</p>
<p>这是因为如果我们有$ { n } &lt; { n ’ } <span class="math inline">\(,那么我们一定有:\)</span> { n } &lt; { n + n ’ }
&lt; { n ’ } <span class="math inline">\(,其中\)</span>n , n ’ , m , m ’
$,这一点不难验证.</p>
<p>而正因为如此,我们可以证明所得到的所有分数不重.</p>
<p>然后,如果当前所得到的序列中有两个数$ { n } <span class="math inline">\(和\)</span> { n ’ } <span class="math inline">\(相邻,则\)</span>m ’ n - mn ’ = 1 <span class="math inline">\(,这一点不难通过数学归纳证明.而根据裴蜀定理,显然\)</span>m
n <span class="math inline">\(且\)</span>m ’ n ’ $.</p>
<p>我们最后需要证明任意非负有理数都可以通过这个序列构造出来,考虑类似二分的方法构造.换句话说,我们有两个序列中的分数$
{ n } <span class="math inline">\(和\)</span> { n ’ } <span class="math inline">\(,要构造的有理数为\)</span> { b } <span class="math inline">\(且满足\)</span> { n } &lt; { b } &lt; { n ’ }
$.</p>
<p>我们考虑判断$ { n + n ’ } <span class="math inline">\(与\)</span> { b
} $的大小关系,这样就可以类似二分的方法一直往下找下去.</p>
<p>问题在于为什么我们最后一定可以找到这个数呢?如果我们一直找不到这个数,意味着无论我们怎么做,都有$
{ n } &lt; { b } &lt; { n ’ } <span class="math inline">\(成立,而这也就意味着\)</span>an - bm bm ’ - an ’
<span class="math inline">\(,处理一下不等式并合并,我们有\)</span>( m ’ +
n ’ ) ( an - bm ) + ( n + m ) ( bm ’ - an ’ ) n + m + n ’ + m ’ $.</p>
<p>化简这个式子得到$a + b m ’ + n ’ + m + n <span class="math inline">\(,而我们在操作过程中\)</span>m , n , m ’ , n ’
<span class="math inline">\(显然会有两个数不变,另外两个数变大,因此迟早会大于\)</span>a
+ b $,也就意味着这个数迟早会被找到.</p>
<p>之所以称其为”树”,则是因为我们如果每次都在任意两个数之间插入一个数,然后将进行若干次操作得到的序列放到二叉搜索树上,会得到一些很好的性质,譬如一个数是由它所有祖先中最大的小于它的数和最小的大于它的数生成的,以及关于根中心对称的两点互为倒数.</p>
<p>另外,如果我们定义法里级数$ _n <span class="math inline">\(表示所有在\)</span>[ 0 , 1 ] <span class="math inline">\(范围内且分母小于等于\)</span>n <span class="math inline">\(的最简分数的集合.不难发现,\)</span> <em>n <span class="math inline">\(对应着整棵树的一棵子树的一部分.而\)</span> <em>n
<span class="math inline">\(可以由\)</span> </em>{ n - 1 } <span class="math inline">\(得到,只需要判断\)</span> </em>{ n - 1 }
$中每两个相邻数能否生成一个满足条件的数即可.</p>
<p>我们回到它的树形态上,如果我们定义$ { 1 } <span class="math inline">\(为这棵二叉搜索树的根,那么每个有理数显然都可以表示为从根到它的一个\)</span>LR
<span class="math inline">\(序列,表示从根向下搜索时每一步向左走还是向右走.特别地,我们定义根的序列为\)</span>I
$.</p>
<p>不难发现,通过这样的操作,我们将每一个非负有理数都对应到了一个$LR
$序列.</p>
<p>那么我们来考虑第一个问题:已知$LR $序列如何求这个数.</p>
<p>我们可以设当前点是$x <span class="math inline">\(,且它由\)</span>y
<span class="math inline">\(和\)</span>z <span class="math inline">\(生成,其中\)</span>y &lt; x &lt; z <span class="math inline">\(,那么不难发现它的右儿子由\)</span>x <span class="math inline">\(和\)</span>z <span class="math inline">\(生成,左儿子由\)</span>y <span class="math inline">\(和\)</span>x $生成.</p>
<p>那么我们显然可以使用记录$y <span class="math inline">\(和\)</span>z
<span class="math inline">\(的方式,反复迭代求得答案.注意\)</span>x <span class="math inline">\(是可以通过\)</span>y <span class="math inline">\(和\)</span>z $求得的,因此没有必要存储.</p>
<p>而这一过程可以简化为矩阵运算:</p>
我们令$y = { n } <span class="math inline">\(,\)</span>z = { n ’ } <span class="math inline">\(,\)</span>S =
<span class="math display">\[\begin{bmatrix}n &amp; n &#39; \\ m &amp; m
&#39; \end{bmatrix}\]</span>
<p><span class="math inline">\(,\)</span>f ( S ) = { n + n ’ } $.</p>
<p>那么不难发现它的每一次操作只需右乘一个变换矩阵即可.</p>
其中:$L =
<span class="math display">\[\begin{bmatrix}1 &amp; 1 \\ 0 &amp; 1
\end{bmatrix}\]</span>
, R =
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ 1 &amp; 1
\end{bmatrix}\]</span>
<p>$.</p>
<p>使用数学归纳不难证明:</p>
$L ^k =
<span class="math display">\[\begin{bmatrix}1 &amp; k \\ 0 &amp; 1
\end{bmatrix}\]</span>
, R ^k =
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ k &amp; 1
\end{bmatrix}\]</span>
<p>$.</p>
<p>至于已知数字求它的序列表示,首先可以直接在树上搜索.</p>
<p>而如果要脱离树,我们仍然可以回到矩阵上,意识到$f ( RS ) = f ( S ) + 1
$,再加上关于根中心对称两点互为倒数的性质,我们可以推导出以下法则:</p>
<p>如果$m &gt; n <span class="math inline">\(,那么\)</span>f ( RS ) = {
n } f ( S ) = { n } $.</p>
<p>如果$m &lt; n <span class="math inline">\(,那么\)</span>f ( LS ) = {
n } f ( S ) = { n - m } $.</p>
<p>借助这一点,我们就可以求一个数的$LR $序列表示了.</p>
<p>在某些情形下,这种表示可以解决二进制下某些分数无法精确表示的问题.</p>
<h4><span id="升幂引理">升幂引理</span></h4>
<h5><span id="形式一">形式一</span></h5>
<p>对于素数$p <span class="math inline">\(,\)</span>p x , p y <span class="math inline">\(,对于满足\)</span>( n , p ) = 1 <span class="math inline">\(的\)</span>n $:</p>
<ol type="1">
<li><p>若$p | ( x - y ) <span class="math inline">\(,则\)</span>v _p ( x
^n - y ^n ) = v _p ( x - y ) $.</p></li>
<li><p>若$p | ( x + y ) <span class="math inline">\(,\)</span>n <span class="math inline">\(是奇数,则\)</span>v _p ( x ^n + y ^n ) = v _p ( x
+ y ) $.</p></li>
</ol>
<p>考虑(1)的证明,由于$p | ( x - y ) , x y <span class="math inline">\(,因此\)</span>_{ k = 0 } ^{ n - 1 } x ^k y ^{ n -
1 - k } nx ^{ n - 1 } $.有次方差公式,显然.</p>
<p>(2)类似.</p>
<h5><span id="形式二">形式二</span></h5>
<p>对于奇素数$p <span class="math inline">\(,\)</span>p x , p y $:</p>
<ol type="1">
<li><p>若$p | ( x - y ) <span class="math inline">\(,则\)</span>v _p ( x
^n - y ^n ) = v _p ( x - y ) + v _p ( n ) $.</p></li>
<li><p>若$p | ( x + y ) <span class="math inline">\(,\)</span>n <span class="math inline">\(是奇数,则\)</span>v _p ( x ^n + y ^n ) = v _p ( x
+ y ) + v _p ( n ) $.</p></li>
</ol>
<p>和形式一的证明完全类似.</p>
<h3><span id="同余">同余</span></h3>
<p>如果$a m = b m <span class="math inline">\(,我们称\)</span>a <span class="math inline">\(和\)</span>b <span class="math inline">\(关于模\)</span>m <span class="math inline">\(同余,记作\)</span>a b ( m ) $.</p>
<p>根据同余的定义,若$a , b , c , d , k <span class="math inline">\(,\)</span>n , m $,我们有以下性质:</p>
<ol type="1">
<li><p>$a b a - b = km $.</p></li>
<li><p>$a b c d a + c b + d $.</p></li>
<li><p>$a b c d ac bd $.</p></li>
<li><p>$a b a ^k b ^k $.</p></li>
<li><p>$ad bd a b , m d $.</p></li>
<li><p>$ad bd a b , d $.</p></li>
<li><p>$ad bd a b $.</p></li>
<li><p>$a b a b , d $.</p></li>
<li><p>$a b a b a b $.</p></li>
</ol>
<p>我们考虑第五条的证明:由于$m d <span class="math inline">\(,则根据扩展欧几里得算法,可以求得一个数\)</span>d ’
<span class="math inline">\(满足\)</span>dd ’ + mm ’ = 1 <span class="math inline">\(,也就是\)</span>dd ’ ( m ) <span class="math inline">\(,那么如果我们有\)</span>ad bd ( m ) <span class="math inline">\(,只需要两边同时乘以\)</span>d ’ <span class="math inline">\(就可以得到右边.值得一提的是,我们通常称\)</span>d ’
<span class="math inline">\(是\)</span>d <span class="math inline">\(在模\)</span>m <span class="math inline">\(意义下的逆元,记作\)</span>inv ( d , m ) <span class="math inline">\(或\)</span>d ^{ - 1 } $.</p>
<p>逆元有一种线性预处理的求法:</p>
<p>考虑$1 i n <span class="math inline">\(,设\)</span>p = ki + r <span class="math inline">\(,则有\)</span>ki + r ( p ) <span class="math inline">\(,则有\)</span>kr ^{ - 1 } + i ^{ - 1 } ( p )
$.</p>
<p>于是有$i ^{ - 1 } - kr ^{ - 1 } ( p ) <span class="math inline">\(,即\)</span>i ^{ - 1 } - { i } r ^{ - 1 } ( p )
$.</p>
<p>现在,我们给出一个结论:数列$0 m , n m , 2 n m , . . . , ( m - 1 ) n m
$在排序去重后恰好为数列$0 , d , 2 d , . . . , m - d <span class="math inline">\(,\)</span>d = ( n , m ) <span class="math inline">\(,而且其中每个数字在原数列中恰好出现了\)</span>d
$次.</p>
<p>恰好出现$d <span class="math inline">\(次是好证明的:考虑\)</span>jn
kn ( m ) <span class="math inline">\(可以推导出\)</span>j k ( { d } ) ,
d = ( n , m ) <span class="math inline">\(,则显然这些数是一个序列复制\)</span>d
$次得到的.</p>
<p>由上,我们要证明$kn m <span class="math inline">\(一定是\)</span>d
<span class="math inline">\(的倍数.不难发现\)</span>kn m = dk { d } ( {
d } d ) = d ( { d } { d } ) $.</p>
<p>接下来,不妨假设$n m $,并在此条件下证明$0 m , n m , 2 n m , . . . , (
m - 1 ) n m <span class="math inline">\(两两不同即可.而由于\)</span>n m
<span class="math inline">\(,则\)</span>kn jn ( m ) <span class="math inline">\(的充分必要条件是\)</span>k j ( m )
$,因此它们显然两两不同.</p>
<h5><span id="example具体数学431">Example(《具体数学》4.31)</span></h5>
<p>$n <span class="math inline">\(进制下,各位数字之和是\)</span>m <span class="math inline">\(的倍数,则这个数是\)</span>m
$的倍数的充分必要条件是?</p>
<p>令$a _i <span class="math inline">\(表示这个数字在\)</span>n <span class="math inline">\(进制下的第\)</span>i $位,则这条性质也就是:</p>
<p><span class="math display">\[
\sum _{ i = 0  } a _i n ^i \equiv 0 \pmod { m  } \Leftrightarrow \sum _{
i = 0  } a _i \equiv 0 \pmod { m  }
\]</span></p>
<p>不难发现,当$n $时,满足该性质.</p>
<h4><span id="威尔逊定理">威尔逊定理</span></h4>
<p>-1(p)&amp;pprime\</p>
<p>2(p)&amp;p=4\</p>
<p>0(p)&amp;other</p>
<p>\end{cases}</p>
<p>证明:</p>
<p>当$p <span class="math inline">\(为质数时，考虑对于\)</span>a <span class="math inline">\(和\)</span>b = a ^{ - 1 } ( p ) <span class="math inline">\(,若\)</span>a = b <span class="math inline">\(,此时可证明\)</span>a = 1 <span class="math inline">\(或\)</span>a = p - 1
$(需要用到下面独立剩余知识).</p>
<p>如果$a b <span class="math inline">\(那么一定可以在\)</span>[ 1 , p -
1 ] $找到一对数,它们相乘为$1 <span class="math inline">\(.原因是若\)</span>a _1 a _2 <span class="math inline">\(,那么\)</span>a _1 ^{ - 1 } a _2 ^{ - 1 } $.</p>
<p>若$p <span class="math inline">\(不是质数,则设\)</span>p = ab <span class="math inline">\(,当\)</span>a b <span class="math inline">\(时,由于\)</span>a , b p <span class="math inline">\(,因此\)</span>( p - 1 ) ! <span class="math inline">\(一定是\)</span>p $的倍数.</p>
<p>若$a = b <span class="math inline">\(,除非\)</span>p = 4 <span class="math inline">\(,不然一定能在\)</span>[ 1 , p - 1 ] <span class="math inline">\(里找到\)</span>a $和$2 a <span class="math inline">\(,此时\)</span>( p - 1 ) ! <span class="math inline">\(也是\)</span>p $的倍数.</p>
<p>另外,当$p $是奇质数的时候,威尔逊定理可以写成如下形式:</p>
<p><span class="math display">\[
\begin{aligned}
\prod _{ k = 1  } ^{ \frac { p - 1  } { 2  }  } k ( p - k ) &amp; \equiv
- 1 \pmod { p  } \\
\prod _{ k = 1  } ^{ \frac { p - 1  } { 2  }  } - k ^2 &amp; \equiv - 1
\pmod { p  } \\
( - 1 ) ^{ \frac { p - 1  } { 2  }  } ( ( \cfrac { p - 1  } { 2  } ) ! )
^2 &amp; \equiv - 1 \pmod { p  }
\end{aligned}
\]</span></p>
<p>另外,通过以上推导过程,不难发现威尔逊定理还可以写成:</p>
<p><span class="math display">\[
( p - 2 ) ! \equiv \begin{cases}
1 ( \mod p ) &amp; p \in prime \\
2 ( \mod p ) &amp; p = 4 \\
0 ( \mod p ) &amp; other
\end{cases}
\]</span></p>
<h5><span id="example1具体数学448">Example1(《具体数学》4.48)</span></h5>
<p>求$_{ 1 n &lt; m , n m } n \ $.</p>
<p>首先,类似威尔逊定理的推导,不难注意到这个式子也就等价于:</p>
<p><span class="math display">\[
\prod _{ 1 \leq n &lt; m , n ^2 \equiv 1 \pmod { m  }  } n \pmod { m  }
\]</span></p>
<p>首先考虑满足$n ^2 <span class="math inline">\(的\)</span>n
$满足什么性质,根据我们在二次剩余的推导,先考虑$2 m <span class="math inline">\(的情况,此时我们将\)</span>m <span class="math inline">\(分解为了若干个形如\)</span>p ^k <span class="math inline">\(的质因数的乘积,对于每个\)</span>p ^k <span class="math inline">\(作为模数时,\)</span>n $有两个解:$1 <span class="math inline">\(和\)</span>p ^k - 1 $.</p>
<p>当$m = p ^k <span class="math inline">\(的时候,显然答案就是\)</span>-
1 $.</p>
<p>不然,由于此时有很多解,我们考虑设答案为$ans <span class="math inline">\(并对于每个\)</span>p ^k <span class="math inline">\(求出\)</span>ans <span class="math inline">\(的答案,再使用中国剩余定理合并.不难发现只要\)</span>m
<span class="math inline">\(有多个不同的质因子,那么中国剩余定理合并的时候,一定会有偶数个\)</span>n
<span class="math inline">\((事实上,假设\)</span>m <span class="math inline">\(有\)</span>a $个质因子,那么有$2 ^{ a - 1 } <span class="math inline">\(个这样的\)</span>n <span class="math inline">\()满足\)</span>n - 1 <span class="math inline">\(,也有同样数目的\)</span>n <span class="math inline">\(满足\)</span>n <span class="math inline">\(.那么此时的\)</span>ans <span class="math inline">\(.多次合并后的\)</span>ans $显然还是$1 $.</p>
<p>至于$2 m $的情况并没有麻烦很多,当$2 m m $,显然有没有这个$2
$作为质因子都一样.当$4 m m $,这个质因子和其它质因子并没有多少区别.</p>
<p>于是我们最后得到结论:</p>
$$ _{ 1 n &lt; m , n m } n
<span class="math display">\[\begin{cases}
- 1 \pmod { m  } &amp; m = p ^k \lor m = 2 p ^k \lor m = 4 , p \in prime
\land p \ne 2 \\
1 \pmod { m  } &amp; other \\

\end{cases}\]</span>
<p>$$</p>
<h5><span id="example2具体数学440">Example2(《具体数学》4.40)</span></h5>
<p>如果我们设$n = _{ k } a _k p ^k <span class="math inline">\(,求证:\)</span> { p ^{ _p ( n ! ) } } = ( - 1 ) ^{
<em>p ( n ! ) } </em>{ k } a _k ! $.</p>
<p>证明考虑数学归纳:如果$n n + 1
$的过程中没有发生进位,那么该公式显然成立.</p>
<p>如果发生进位了,假设进到了第$k <span class="math inline">\(位,第\)</span>k <span class="math inline">\(位原本是\)</span>w <span class="math inline">\(,现在是\)</span>w + 1 <span class="math inline">\(,那么要证其对于\)</span>n + 1
$成立,即证明下式成立:</p>
<p><span class="math display">\[
\cfrac { n ! ( n + 1 )  } { p ^{ \varepsilon _p ( n ! ) + k  }  } = ( -
1 ) ^{ \varepsilon _p ( n ! ) + k  } ( w + 1 ) ! \prod _{ i \geq k +
1  } a _i ! \pmod { p  }
\]</span></p>
<p>考虑$( p - 1 ) - 1 $,于是上式也即:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { n ! ( n + 1 )  } { p ^{ \varepsilon _p ( n ! ) + k  }  } &amp;
= ( - 1 ) ^{ \varepsilon _p ( n ! )  } ( w + 1 ) \prod _{ i \geq 0  } a
_i ! \pmod { p  } \\
\cfrac { n !  } { p ^{ \varepsilon _p ( n ! )  }  } \cfrac { n + 1  } {
p ^k  } &amp; = ( - 1 ) ^{ \varepsilon _p ( n ! )  } ( w + 1 ) \prod _{
i \geq 0  } a _i ! \pmod { p  } \\
\cfrac { n !  } { p ^{ \varepsilon _p ( n ! )  }  } ( w + 1 ) &amp; = (
- 1 ) ^{ \varepsilon _p ( n ! )  } ( w + 1 ) \prod _{ i \geq 0  } a _i !
\pmod { p  }
\end{aligned}
\]</span></p>
<p>于是化到$n <span class="math inline">\(的情况,于是\)</span>n + 1
$时该式子成立.</p>
<h5><span id="example3具体数学453">Example3(《具体数学》4.53)</span></h5>
<p>求所有满足$n | { n + 1 } <span class="math inline">\(的整数\)</span>n
$.</p>
<p>首先这个形式看上去就是威尔逊定理的形式,所以第一步我们先暴力验证$n
<span class="math inline">\(的答案,注意到此时当且仅当\)</span>n = 1
<span class="math inline">\(时成立.接下来我们尝试找到\)</span>n
$时的解.</p>
<p>考虑当$n + 1 prime <span class="math inline">\(时,根据威尔逊定理,要求化为:\)</span>n { n + 1 }
<span class="math inline">\(.注意到此时\)</span>n <span class="math inline">\(一定不是质数,又因为\)</span>n ( n + 1 ) <span class="math inline">\(,于是要求化为\)</span>n $,显然成立.</p>
<p>当$n + 1 prime <span class="math inline">\(时,要求则化为\)</span>n {
n + 1 } <span class="math inline">\(.当\)</span>n prime
$时,显然不成立.反之显然成立.</p>
<p>于是要么$n = 1 <span class="math inline">\(,要么\)</span>n n prime
$.</p>
<h4><span id="费马小定理">费马小定理</span></h4>
<p>$n ^{ p - 1 } ( p ) , n p , p prime $.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\prod _{ k = 1  } ^{ p - 1  } kn &amp; \equiv \prod _{ k = 1  } ^{ p -
1  } ( kn \mod p ) ( \mod p ) \\
n ^{ p - 1  } ( p - 1 ) ! &amp; \equiv ( p - 1 ) ! ( \mod p )
\end{aligned}
\]</span></p>
<p>根据威尔逊定理,显然可以推得费马小定理.</p>
<p>根据费马小定理,我们可以考虑证明一个结论:$n ^{ p ^k } n ^{ p ^{ k - 1
} } ( p ^k ) $.</p>
<p>由于$n ^{ p - 1 } ( p ) <span class="math inline">\(,那么我们有\)</span>n ^p n ( p ) <span class="math inline">\(,也即\)</span>q <span class="math inline">\(满足\)</span>n ^p = n + pq <span class="math inline">\(,不断两边取\)</span>p $次方即可得到上述结论.</p>
<p>另外,费马小定理还可以如下证明:</p>
<p>考虑证明$n ^p n <span class="math inline">\(,也就是要证明\)</span>(
_{ i = 1 } ^n 1 ) ^p n $.</p>
<p>注意到根据多项式定理,$( <em>{ i = 1 } ^n 1 ) ^p = </em>{ a = p } { a
_1 ! . . . a _n ! } <span class="math inline">\(.而如果\)</span>{ a } p
<span class="math inline">\(,则后面的式子在\)</span>p $意义下显然为$0
<span class="math inline">\(,不然,考虑\)</span>{ a } = p <span class="math inline">\(的序列一共会出现\)</span>n
$次且每次对答案的贡献都是$1 <span class="math inline">\(,自然有\)</span>n ^p n ( p ) $.</p>
<h5><span id="example1具体数学441">Example1(《具体数学》4.41)</span></h5>
<p>求证:如果质数$p <span class="math inline">\(满足\)</span>p <span class="math inline">\(,则不存在整数\)</span>n <span class="math inline">\(满足\)</span>p | ( n ^2 + 1 ) <span class="math inline">\(;如果其满足\)</span>p <span class="math inline">\(,则一定存在一个整数\)</span>n $满足条件.</p>
<p>先考虑证明前半部分,如果存在这样一个整数$n <span class="math inline">\(,考虑\)</span>p | ( n ^2 + 1 ) <span class="math inline">\(也就等价于\)</span>n ^2 - 1 <span class="math inline">\(,则\)</span>n ^4 <span class="math inline">\(.显然\)</span>p n <span class="math inline">\(,根据费马小定理,我们有\)</span>n ^{ p - 1 } <span class="math inline">\(,也就有\)</span>n ^{ p + 1 } - 1 $.</p>
<p>而由于$p $,所以$4 | ( p + 1 ) <span class="math inline">\(,所以\)</span>n ^{ p + 1 }
$,不符,因此一定不存在.</p>
<p>反之,考虑威尔逊定理的变形$<em>{ k = 1 } ^{ { 2 } } - k ^2 - 1 \ <span class="math inline">\(.由于\)</span>p - 1 <span class="math inline">\(,所以这个式子也就等价于\)</span></em>{ k = 1 } ^{
{ 2 } } k ^2 - 1 <span class="math inline">\(,也就是\)</span>( ( { 2 } )
! ) ^2 - 1 $,这就是一个解.</p>
<h5><span id="example2具体数学446">Example2(《具体数学》4.46)</span></h5>
<p>求证:如果$n &gt; 1 $,则$2 ^n $.</p>
<p>如果$n $是质数,根据费马小定理,显然得证.</p>
<p>不然,设$n = pq <span class="math inline">\(,且\)</span>p <span class="math inline">\(是\)</span>n $的最小质因子,若$2 ^{ n } $,则$2 ^n
$.</p>
<p>若$p = 2 $,显然不成立.不然,有$2 ^{ p - 1 } <span class="math inline">\(,由于\)</span>( p - 1 ) n $,则$2 ^{ ( p - 1 , n )
} $,显然不成立.</p>
<p>另外,上面的过程显然可以推广为:</p>
<p>如果$n &gt; 1 <span class="math inline">\(,则对于任意质数\)</span>p
<span class="math inline">\(,\)</span>p ^n $.</p>
<h4><span id="中国剩余定理crt">中国剩余定理(crt)</span></h4>
<p>对于方程组$x a _i ( m _i ) <span class="math inline">\(,其中\)</span>m _i <span class="math inline">\(两两互质,求\)</span>x $.</p>
<p>令$m = ^k _{ i = 1 } m _i <span class="math inline">\(,设\)</span>M
_i = { m _i } <span class="math inline">\(,\)</span>N _i <span class="math inline">\(是\)</span>M _i <span class="math inline">\(在\)</span>m _i $意义下逆元.</p>
<p>则$x ^k _{ i = 1 } M _i N _i a _i ( m ) $.</p>
<p>中国剩余定理的证明类似拉格朗日插值:</p>
<p>由于$x <span class="math inline">\(在\)</span>m _i <span class="math inline">\(意义下,\)</span><span class="math inline">\(中枚举的所有不等于\)</span>i $的项都会成$0 <span class="math inline">\(，等于\)</span>i <span class="math inline">\(的项会成\)</span>a _i $.</p>
<p>考虑每次合并两项，显然有:$a = a _1 + ( a _2 - a _1 ) m _1 inv ( m _1
, m _2 ) <span class="math inline">\(,\)</span>m = m _1 m _2 $.</p>
<p>中国剩余定理的本质是一个环同构$: / m _1 m _2 ( / m _1 ) ( / m _2 )
<span class="math inline">\(,当\)</span>m _1 m _2 $.</p>
<p>由于映射两边都是大小相同的有限环,所以只需证明它是单射就行.而容易发现$=
{ [ 1 ] } $.</p>
<p>下面的扩展中国剩余定理亦然同理,用一下裴蜀定理证明映射两边的有限环大小相等,再注意到$|
| = 1 $.</p>
<h4><span id="扩展中国剩余定理excrt">扩展中国剩余定理(excrt)</span></h4>
<p>对于方程组$x a _i ( m _i ) <span class="math inline">\(,若\)</span>m
_i $两两不互质.</p>
<p>我们考虑每次合并两个方程:</p>
<p>xa_1(m_1)\</p>
<p>xa_2(m_2)</p>
<p>\end{cases}</p>
<p>那这个方程组等价于:</p>
<p>x=k_1m_1+a_1\</p>
<p>x=k_2m_2+a_2</p>
<p>\end{cases}</p>
<p>合并上下方程,有:</p>
<p><span class="math display">\[
\begin{aligned}
k _1 m _1 + a _1 &amp; = k _2 m _2 + a _2 \\
a _2 - a _1 &amp; = k _1 m _1 - k _2 m _2
\end{aligned}
\]</span></p>
<p>设$g = ( m _1 , m _2 ) <span class="math inline">\(,显然若\)</span>g
( a _2 - a _1 ) $,方程无解.</p>
<p>不然,有:</p>
$$
<span class="math display">\[\begin{aligned}
\frac { a _2 - a _1  } { g  } &amp; = k _1 \frac { m _1  } { g  } - k _2
\frac { m _2  } { g  } \\
k _1 \frac { m _1  } { g  } &amp; = k _2 \frac { m _2  } { g  } + \frac
{ a _2 - a _1  } { g  } \\
k _1 \frac { m _1  } { g  } &amp; \equiv \frac { a _2 - a _1  } { g  } (
\mod \frac { m _2  } { g  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$inv ( a , p ) <span class="math inline">\(表示\)</span>a <span class="math inline">\(在\)</span>p $意义下的逆元,有:</p>
$$
<span class="math display">\[\begin{aligned}
k _1 &amp; \equiv inv ( \frac { m _1  } { g  } , \frac { m _2  } { g  }
) \frac { a _2 - a _1  } { g  } ( \mod \frac { m _2  } { g  } ) \\
k _1 &amp; = inv ( \frac { m _1  } { g  } , \frac { m _2  } { g  } )
\frac { a _2 - a _1  } { g  } + k _3 \frac { m _2  } { g  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>带回第一个方程:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = m _1 ( inv ( \frac { m _1  } { g  } , \frac { m _2  } { g  } )
\frac { a _2 - a _1  } { g  } + k _3 \frac { m _2  } { g  } ) + a _1 \\
x &amp; \equiv m _1 inv ( \frac { m _1  } { g  } , \frac { m _2  } {
g  } ) \frac { a _2 - a _1  } { g  } + a _1 ( \mod \frac { m _1 m _2  }
{ g  } )
\end{aligned}
\]</span></p>
<h5><span id="example1noi2018屠龙勇士">Example1([NOI2018]屠龙勇士)</span></h5>
<p>考虑拿个set之类的维护,然后问题转化为求:</p>
<p><span class="math display">\[
\begin{cases}
b _1 x \equiv a _1 ( \mod m _1 ) \\
b _2 x \equiv a _2 ( \mod m _2 ) \\
. . . \\
b _n x \equiv a _n ( \mod m _n )
\end{cases}
\]</span></p>
<p>的一个$x $的最小解.</p>
<p>对于一个式子$b _i x a _i <span class="math inline">\(,设\)</span>g =
( b _i , m _i ) <span class="math inline">\(,那么若\)</span>g a _i <span class="math inline">\(,显然无解;不然,我们有:\)</span> { g } x { g }
<span class="math inline">\(,而\)</span> { g } { g } $,可以求逆元.</p>
<h5><span id="example2cf571egeometricprogressions">Example2([CF571E]Geometric
Progressions)</span></h5>
<p>首先分解质因子,这样问题转化为判断等差数列中是否出现.我们随便挑一个数列,假设这个数列中第$x
<span class="math inline">\(个数字是答案,显然最小化\)</span>x $即可.</p>
<p>但是直接对所有质因子做excrt复杂度不可接受.我们考虑如果对于质因子$p
<span class="math inline">\(,\)</span>i , j , i j <span class="math inline">\(有\)</span>p | b _j , p a _i , p b _i <span class="math inline">\(,显然无解.如果有\)</span>p | b _j , p | a _i , p b
_i
$,显然要么无解,要么有唯一解,而且可以快速求出唯一解是谁,直接验证就行.</p>
<p>这样,我们就保证了所有需要做excrt的质因子必然全部出现,容易发现这样的质因子数量很少.</p>
<h4><span id="二次剩余">二次剩余</span></h4>
<p>求方程$x ^2 = k ( m ) $的解.</p>
<p>我们先考虑一个特殊情况:$k = 1 <span class="math inline">\(,\)</span>m
= p ^k , p prime $.</p>
<p>那么也就相当于求方程$( x - 1 ) ( x + 1 ) ( p ^k ) $.</p>
<p>如果$p &gt; 2 <span class="math inline">\(,那么显然\)</span>x - 1
<span class="math inline">\(和\)</span>x + 1 <span class="math inline">\(只有一个能被\)</span>p ^k <span class="math inline">\(整除,所以有\)</span>x = $.</p>
<p>如果$p = 2 <span class="math inline">\(,那么显然\)</span>x - 1 <span class="math inline">\(和\)</span>x + 1 $有一个能被$2 $整除但不能被$4
$整除,另一个能被$2 ^{ k - 1 } <span class="math inline">\(整除,如果\)</span>k = 1 <span class="math inline">\(时,显然只有一个解.当\)</span>k = 2 <span class="math inline">\(时,同上.反之,有\)</span>x = <span class="math inline">\(或\)</span>x = 2 ^{ k - 1 } <span class="math inline">\(.考虑一个性质:\)</span>( 2 k + 1 ) ^2 ( ) $.</p>
<p>那么如果:$k = 1 , m <span class="math inline">\(,也是一样的.先把\)</span>m <span class="math inline">\(作质因数分解,然后再用中国剩余定理合并,那么显然不同质数的解会累乘到总的解上,若\)</span>m
<span class="math inline">\(有\)</span>r $个不同大于$2
$的质因子,总的解的个数是$2 ^r <span class="math inline">\(.而如果考虑\)</span>p = 2 <span class="math inline">\(的情况,\)</span>m <span class="math inline">\(有\)</span>r $个不同的质因子,则解的个数为$2 ^{ r +
[ 8 | m ] + [ 4 | m ] - [ 2 | m ] } $.</p>
<p>下面开始讲正经的二次剩余.</p>
<p>我们称$a <span class="math inline">\(是\)</span>p <span class="math inline">\(的二次剩余,当且仅当\)</span>b , b ^2 a <span class="math inline">\(并且\)</span>a <span class="math inline">\(,这里的\)</span>p <span class="math inline">\(是奇素数,如果\)</span>a <span class="math inline">\(不是\)</span>p <span class="math inline">\(的倍数且\)</span>b , b ^2 a
$,则称为二次非剩余.我们引入勒让德符号来表示这个东西:</p>
<p><span class="math display">\[
\left ( \frac { a  } { p  } \right ) = \begin{cases}
1 &amp; a 是 二 次 剩 余 \\
0 &amp; a \equiv 0 \pmod { p  } \\
- 1 &amp; a 为 二 次 非 剩 余
\end{cases}
\]</span></p>
<p>那么这玩意怎么求呢?我们有欧拉判别准则:</p>
<p><span class="math display">\[
\left ( \frac { a  } { p  } \right ) \equiv a ^{ \frac { p - 1  } {
2  }  } \pmod { p  }
\]</span></p>
<p>先证明个引理:若$g <span class="math inline">\(为\)</span>p <span class="math inline">\(意义下的原根,且\)</span>a g ^k <span class="math inline">\(,那么\)</span>x ^2 a <span class="math inline">\(有解的充要条件是\)</span>k $是偶数.</p>
<p>充分性显然,而必要性,我们考虑费马小定理:$g ^{ p - 1 } <span class="math inline">\(,而\)</span>p - 1
$是偶数,因此无论如何奇偶性都不会变.</p>
<p>接下来证明欧拉判别准则:</p>
<p><span class="math display">\[
\begin{aligned}
g ^{ p - 1  } &amp; \equiv 1 \pmod { p  } \\
g ^{ p - 1  } - 1 &amp; \equiv 0 \pmod { p  } \\
( g ^{ \frac { p - 1  } { 2  }  } + 1 ) ( g ^{ \frac { p - 1  } {
2  }  } - 1 ) &amp; \equiv 0 \pmod { p  } \\
g ^{ \frac { p - 1  } { 2  }  } &amp; \equiv - 1 \pmod { p  } \\
a ^{ \frac { p - 1  } { 2  }  } &amp; = ( g ^k ) ^{ \frac { p - 1  } {
2  }  } &amp; = ( g ^{ p - 1  } ) ^{ \frac { k  } { 2  }  }
\end{aligned}
\]</span></p>
<p>于是得证.另外通过这个证明过程,我们可以发现$[ 1 , p - 1 ] <span class="math inline">\(中有正好一半的数是二次剩余,我们还能得知\)</span>x
^2 a <span class="math inline">\(的解的数量是\)</span>( { p } ) + 1 \
$.</p>
<h5><span id="example1cf1091gnewyear-and-the-factorisation-collaboration">Example1([CF1091G]New
Year and the Factorisation Collaboration)</span></h5>
<p>考虑随机一个$x <span class="math inline">\(,令\)</span>x ’ = <span class="math inline">\(,如果\)</span>x ’ = x <span class="math inline">\(则放弃这次询问,不然自然有\)</span>( x ’ - x ) ( x
’ + x ) $.</p>
<p>$p | n , p prime <span class="math inline">\(,注意到一定满足\)</span>p | ( x ’ - x ) <span class="math inline">\(或\)</span>p | ( x ’ + x ) <span class="math inline">\(,我们可以多做几次,可以理解为这样将\)</span>n
$随机分割了.</p>
<h5><span id="example2qoj5021">Example2(qoj5021)</span></h5>
<p>整个题就强调一个字:双射!</p>
<p>先把模数质因数分解.</p>
<p>从头开始看,这种多元组计数肯定要一点一点确定,我们考虑固定$( a , a ’ )
<span class="math inline">\(求解\)</span>( b , b ’ ) <span class="math inline">\(,这个时候发现只要\)</span>( a , a ’ ) $不全为$0
<span class="math inline">\(,那么就有\)</span>p <span class="math inline">\(组\)</span>( b , b ’ )
$满足条件,这个可以通过移项求逆元发现.发现这个全为$0
$的条件很烦,我们先把它处理掉.</p>
<p>显然只有$r = 0 <span class="math inline">\(会出现这种情况,讨论一下\)</span>( a , a ’ )
$全为$0 <span class="math inline">\(或\)</span>( b , b ’ ) $全为$0
$的情况,简单分类讨论可以得到共有$2 p ^3 + p ^2 - 2 p $种方案.</p>
<p>好了,困难的部分被我们解决了,不过这样我们需要多讨论一下$r $是否等于$0
$,不过问题不大.</p>
<p>先考虑$r = 0 $的情况:</p>
注意到此时固定$( a , a ’ ) <span class="math inline">\(会有\)</span>p -
1 $组(有一组全$0 <span class="math inline">\()\)</span>( b , b ’ ) <span class="math inline">\(满足条件,此时有方程\)</span>
<span class="math display">\[\begin{cases}ac + a &#39; c &#39; \equiv 0
\pmod { p  } \\ bc + b &#39; c &#39; \equiv 0 \pmod { p  }
\end{cases}\]</span>
<p><span class="math inline">\(.显然若\)</span>( b , b ’ ) k ( a , a ’ )
<span class="math inline">\(,那么该方程有\)</span>p <span class="math inline">\(组解,不然只有一组解.而前者相当于\)</span>( a , a ’
) <span class="math inline">\(满足\)</span>ka ^2 + ka ’ ^2 <span class="math inline">\(,我们设\)</span>C _k <span class="math inline">\(是方程\)</span>a ^2 + a ’ ^2 k
$的解的数量,把上面的全部加起来,答案是:</p>
<p><span class="math display">\[
( C _0 - 1 ) ( p - 1 ) p + ( ( p ^2 - 1 ) ( p - 1 ) - ( C _0 - 1 ) ( p -
1 ) )
\]</span></p>
<p>化简一下得到:$( C _0 - 1 ) ( p - 1 ) ^2 + p ^3 - p ^2 - p + 1 $.</p>
<p>再考虑$r $的情况:</p>
注意到此时不可能有全为$0 <span class="math inline">\(的二元组了.所以固定\)</span>( a , a ’ ) <span class="math inline">\(的话,\)</span>( b , b ’ ) <span class="math inline">\(共有\)</span>p <span class="math inline">\(组解,此时有方程\)</span>
<span class="math display">\[\begin{cases}ac + a &#39; c &#39; \equiv r
\pmod { p  } \\ bc + b &#39; c &#39; \equiv r \pmod { p  }
\end{cases}\]</span>
<p>$.</p>
<p>若$( b , b ’ ) k ( a , a ’ ) <span class="math inline">\(,显然当\)</span>k = 1 <span class="math inline">\(时有\)</span>p <span class="math inline">\(组解,否则无解,此时\)</span>a ^2 + a ’ ^2 r $.</p>
<p>不然有唯一解.</p>
<p>而$( b , b ’ ) = k ( a , a ’ ) <span class="math inline">\(的方案有多少呢,显然是\)</span><em>{ k = 1 } ^{ p -
1 } C </em>{ { k } } = _{ k = 1 } ^{ p - 1 } C _k = p ^2 - C _0 <span class="math inline">\(,这里用到了这篇题解的第一个双射,\)</span>[ 1 , p -
1 ] / k $.</p>
<p>于是这里的答案就是:</p>
<p><span class="math display">\[
C _r p + ( ( p ^2 - 1 ) p - ( p ^2 - C _0 ) )
\]</span></p>
<p>化简一下得到$p ^3 - p ^2 - p + C _0 + C _r p $.</p>
<p>现在的问题是如何求$C _0 , C _r $.</p>
<p>先来技术总结一下,这种多元组计数通常要确定一些数字,然后对另一些数字进行计数,如果确定的那些数字不能进行枚举,那就得进行一些别的操作来在不同的情况下判断数量.</p>
<p>那么$C _r <span class="math inline">\(怎么求呢?考虑\)</span>x ^2 a
<span class="math inline">\(的解数为\)</span>( { p } ) + 1 $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
C _r &amp; = \sum _{ i = 0  } ^{ p - 1  } ( \left ( \frac { i  } { p  }
\right ) + 1 ) ( \left ( \frac { r - i  } { p  } \right ) + 1 ) \\
&amp; = \sum _{ i = 0  } ^{ p - 1  } \left ( \frac { i ( r - i )  } {
p  } \right ) + 2 \sum _{ i = 0  } ^{ p - 1  } \left ( \frac { i  } {
p  } \right ) + p \\
&amp; = \sum _{ i = 1  } ^{ p - 1  } \left ( \frac { \frac { r  } { i  }
- 1  } { p  } \right ) + p
\end{aligned}
\]</span></p>
<p><del>(这是干啥啊)</del></p>
<p>我们来一步一步分析这个式子是怎么得到的:</p>
<p>首先,第一步仍然是枚举其中一个,然后求另一个.然后将整个式子乘开,做一个双射$r
- [ 0 , p - 1 ] <span class="math inline">\(就可以合并其中两项,而至于前两项则是根据欧拉判别准则直接将上指标乘起来合并.然后我们发现\)</span>_{
i = 0 } ^{ p - 1 } ( { p } ) = 0 <span class="math inline">\(,因为\)</span>[ 0 , p - 1 ] $中一半是$1 <span class="math inline">\(一半是\)</span>- 1 <span class="math inline">\(,又可以发现\)</span>i = 0 $时显然为$0 <span class="math inline">\(,\)</span>x ^2 = i ( r - i ) ( { i } ) ^2 = { i }
- 1 <span class="math inline">\(,做双射\)</span>[ 1 , p - 1 ] i ^{ - 1 }
$.</p>
<p>做到这一步,自然有$C _0 = ( p - 1 ) ( { p } ) + p $.</p>
<p>而对于$r <span class="math inline">\(的时候,我们再做双射\)</span>r /
[ 1 , p - 1 ] <span class="math inline">\(,于是\)</span>C <em>r = </em>{
i = 0 } ^{ p - 2 } ( { p } ) + p = p - ( { p } ) $.</p>
<p>只能说模质数意义下的加法乘法减法以及不含$0
$的乘法都是群,而且所有运算都是双射,很牛逼,计数题直接起飞.</p>
<p>不过这题需要特别判断一下$p = 2 $的情况,也容易,暴力就行.</p>
<h5><span id="example3">Example3</span></h5>
<p>求$2 ^a = 3 ^b + 1 $和$3 ^a = 2 ^b + 1 $的所有解.</p>
<p>先看$2 ^a = 3 ^b + 1 <span class="math inline">\(,显然\)</span>( 2 ,
1 ) <span class="math inline">\(是一组解.当\)</span>y $的时候,显然有$3
^a + 1 $,而考虑$3 ^{ 2 k } $,这自然不可能.</p>
<p>再看$3 ^a = 2 ^b + 1 <span class="math inline">\(.显然\)</span>( 1 ,
1 ) <span class="math inline">\(和\)</span>( 2 , 3 ) <span class="math inline">\(是两组解.当\)</span>b $的时候$3 ^a <span class="math inline">\(,根据欧拉定理知道\)</span>a <span class="math inline">\(,令\)</span>a = 2 k <span class="math inline">\(.自然有\)</span>( 3 ^k - 1 ) ( 3 ^k + 1 ) = 2 ^b
<span class="math inline">\(,这是形如\)</span>t ( t + 2 ) = 2 ^b <span class="math inline">\(的形式,只有\)</span>t = 2 $是一个解.</p>
<h4><span id="bsgs">BSGS</span></h4>
<p>求$a ^x b ( p ) <span class="math inline">\(的一组解,其中\)</span>p
prime $且$1 p ^9 $.</p>
<p>直接枚举显然是$O ( p ) $的,非常不合理,考虑如何优化.</p>
<p>求出$s = <span class="math inline">\(,并求出所有\)</span>a ^i <span class="math inline">\(,其中\)</span>i $.</p>
<p>若$x s - 1 $.则可以直接判断是否被求出来过.</p>
<p>否则,则将$x = x ( s - 1 ) <span class="math inline">\(,一直操作直到\)</span>x s - 1 $.</p>
<h4><span id="exbsgs">exBSGS</span></h4>
<p>求$a ^x b ( p ) $的一组解,其中$1 p ^9 $.</p>
<p>设$g = ( a , p ) <span class="math inline">\(,那么根据膜的性质,原方程即\)</span> { g } { g } (
{ g } ) $.</p>
<p>显然若$g b <span class="math inline">\(并且\)</span>b <span class="math inline">\(,方程定无解.(若\)</span>b = 1 <span class="math inline">\(,那么\)</span>x = 0 $就是一个解)</p>
<p>那么现在的方程就是$a ^{ x - 1 } { g } { g } ( { g } ) $.</p>
<p>继续进行这个过程,不断求$a <span class="math inline">\(和当前模数的\)</span><span class="math inline">\(.并将当前模数除以该\)</span>$,这样最后我们得到了方程:</p>
<p>$a ^{ x - k } _{ i = 1 } ^k { g <em>i } { </em>{ i = 1 } ^k g <em>i }
( { </em>{ i = 1 } ^k g _i } ) \ $</p>
<p>不妨设$A = _{ i = 1 } ^k { g <em>i } , B = { </em>{ i = 1 } ^k g
<em>i } , P = { </em>{ i = 1 } ^k g _i } \ $</p>
<p>那么现在方程就是$a ^{ x - k } { A } $,可以使用BSGS求解.</p>
<p>ps：$p = 1 $的时候要特判.</p>
<h4><span id="原根和阶">原根和阶</span></h4>
<p>阶:找到一个最小的$k <span class="math inline">\(使得\)</span>a ^k ( p
) <span class="math inline">\(,则称\)</span>k <span class="math inline">\(是\)</span>a <span class="math inline">\(在膜\)</span>p $意义下的阶.</p>
<p>原根:如果$a <span class="math inline">\(在膜\)</span>p <span class="math inline">\(意义下的阶是\)</span>( p ) <span class="math inline">\(且\)</span>a &lt; p <span class="math inline">\(,则称\)</span>a <span class="math inline">\(是\)</span>p $的一个原根.</p>
<p>若$m <span class="math inline">\(有原根,则\)</span>m $一定是$2 $,$4
<span class="math inline">\(或是\)</span>p ^a , 2 p ^a <span class="math inline">\(,其中\)</span>p prime $且$2 p $.</p>
<p>由于对于大部分$m
$来说,都存在一个很小的原根,所以在实际应用中只需要暴力找就可以了.</p>
<p>根据阶的定义,我们如果要判断一个$a <span class="math inline">\(不是\)</span>p <span class="math inline">\(的原根,只需判断是否\)</span>i <span class="math inline">\(使得\)</span>a ^i ( p ) $.</p>
<p>而由于$a ^{ ( p ) } ( p ) <span class="math inline">\(,因此一定有\)</span>i | ( p ) <span class="math inline">\(,因此只需判断\)</span>( p ) <span class="math inline">\(的所有因数,复杂度\)</span>O ( ) $.</p>
<p>事实上,只需要判断对于$( p ) <span class="math inline">\(的所有质因子\)</span>w <span class="math inline">\(,是否有\)</span>a ^{ { w } } ( p ) <span class="math inline">\(即可,复杂度\)</span>O ( ( p ) ) $.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定$k <span class="math inline">\(,\)</span>p <span class="math inline">\(,\)</span>a <span class="math inline">\(,求\)</span>x ^k a ( p ) <span class="math inline">\(的所有解,其中\)</span>p prime $,$1 k ^5 $.</p>
<p>考虑求出$p <span class="math inline">\(的原根\)</span>g <span class="math inline">\(,得到\)</span>g ^r a ( p ) <span class="math inline">\(,同时由于\)</span>x g ^y ( p ) <span class="math inline">\(,因此原方程变为:\)</span>g ^{ yk } g ^r ( p )
$.</p>
<p>于是有:$yk r ( p - 1 ) $,即可求解.</p>
<h5><span id="example2具体数学447">Example2(《具体数学》4.47)</span></h5>
<p>证明:如果$n , n ^{ m - 1 } <span class="math inline">\(,且对于所有满足\)</span>p | ( m - 1 ) <span class="math inline">\(的\)</span>p <span class="math inline">\(都满足\)</span>n ^{ { p } } <span class="math inline">\(,那么\)</span>m $是素数.</p>
<p>首先不难发现,$m  prime ( m ) = m - 1 $.</p>
<p>考虑上面的过程中,不可能存在一个数$k $满足$0 k &lt; m - 1 , n ^k <span class="math inline">\(.因此\)</span> i , j &lt; m , i j , n ^i n ^j
$.</p>
<p>根据欧拉定理,$m - 1 = ( m ) $,因此得证.</p>
<h3><span id="积性函数">积性函数</span></h3>
<p>若函数$f ( x ) <span class="math inline">\(满足\)</span>n , m , n m
<span class="math inline">\(,有\)</span>f ( 1 ) = 1 , f ( nm ) = f ( n )
f ( m ) <span class="math inline">\(,则称其为积性函数.若\)</span>n , m
<span class="math inline">\(,有\)</span>f ( 1 ) = 1 , f ( nm ) = f ( n )
f ( m ) $,则称其为完全积性函数.</p>
<p>若函数$g ( x ) <span class="math inline">\(是积性函数并且有\)</span>g
( m ) = _{ d | m } f ( d ) <span class="math inline">\(,则\)</span>f ( x
) $也是积性函数,证明如下:</p>
<p>不妨考虑数学归纳,首先$g ( 1 ) = f ( 1 ) = 1 $.</p>
<p>令$m = m _1 m _2 , m <em>1 m <em>2 <span class="math inline">\(,则\)</span>g ( m ) = </em>{ d | m } f ( d ) =
</em>{ d _1 | m <em>1 } </em>{ d _2 | m _2 } f ( d _1 d _2 ) <span class="math inline">\(.由于归纳假设,此时只有\)</span>d _1 = m _1 d _2 =
m _2 <span class="math inline">\(的时候,\)</span>f ( d _1 d _2 ) <span class="math inline">\(可能不等于\)</span>f ( d _1 ) f ( d _2 ) $.</p>
<p>于是有</p>
<p><span class="math display">\[
\begin{aligned}
g ( m ) &amp; = \sum _{ d _1 | m _1  } \sum _{ d _2 | m _2  } f ( d _1 )
f ( d _2 ) - f ( m _1 ) f ( m _2 ) + f ( m _1 m _2 ) \\
&amp; = g ( m _1 m _2 ) - f ( m _1 ) f ( m _2 ) + f ( m _1 m _2 )
\end{aligned}
\]</span></p>
<p>于是$f ( m _1 ) f ( m _2 ) = f ( m _1 m _2 ) $.</p>
<p>该命题的逆命题也是同样成立的.有一些常见的积性函数,比如:$id ( x ) = x
<span class="math inline">\(,\)</span>I ( x ) = 1 <span class="math inline">\(,\)</span>( x ) = [ x = 1 ] $.</p>
<h5><span id="example具体数学458">Example(《具体数学》4.58)</span></h5>
<p>求:$f ( m ) = _{ d | m } d $是$2 $的整数次幂的充分必要条件.</p>
<p>不难发现$f <span class="math inline">\(是一个积性函数,于是考虑\)</span>f ( p ^k ) = 1 + p
+ p ^2 + . . . + p ^k $.</p>
<p>当$p = 2 $的时候,显然不满足条件.</p>
<p>不然,只有$k <span class="math inline">\(是奇数的时候,\)</span>f ( p
^k ) $才是一个偶数.</p>
<p>而此时$f ( p ^k ) = ( 1 + p ) ( 1 + p ^2 + p ^4 + . . . + p ^{ k - 1
} ) = ( 1 + p ) ( 1 + p ^2 ) ( 1 + p ^4 + . . . + p ^{ k - 3 } )
$.其是$2 <span class="math inline">\(的整数次幂的一个必要条件是\)</span>p <span class="math inline">\(是一个梅森素数,而且不难发现只有当\)</span>k = 1
$的时候才满足条件.</p>
<p>于是充分必要条件是:$m $是若干个不同的梅森素数的乘积.</p>
<h4><span id="狄利克雷卷积">狄利克雷卷积</span></h4>
<p>$f * g = _{ d | n } { f ( d ) g ( { d } ) } $.</p>
<p>不难证明狄利克雷卷积满足:</p>
<ol type="1">
<li><p>交换律:$f * g = g * f $.</p></li>
<li><p>结合律:$f * ( g * h ) = ( f * g ) * h $.</p></li>
<li><p>分配律:$f * ( g + h ) = f * g + f * h $.</p></li>
<li><p>若$f , g <span class="math inline">\(是积性函数,则\)</span>f * g
$也是积性函数.</p></li>
</ol>
<p>考虑第四条的证明:</p>
<p><span class="math display">\[
\begin{aligned}
f * g ( nm ) &amp; = \sum _{ d | ( nm )  } f ( d ) g ( \cfrac { n  } {
d  } ) \\
&amp; = \sum _{ c | n  } \sum _{ d | m  } f ( cd ) g ( \cfrac { nm  } {
cd  } ) \\
&amp; = \sum _{ c | n  } \sum _{ d | m  } f ( c ) f ( d ) g ( \cfrac {
n  } { c  } ) g ( \cfrac { m  } { d  } ) \\
&amp; = ( f * g ( n ) ) \times ( f * g ( m ) )
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li>$f , f ( 1 ) <span class="math inline">\(,\)</span>f ^{ - 1 } <span class="math inline">\(,\)</span>f * f ^{ - 1 } = $.</li>
</ol>
<p>构造$g ( x ) <span class="math inline">\(满足\)</span>f ( 1 ) g ( x )
= ( x ) - _{ d | x , d } f ( d ) g ( { d } ) $显然就是满足条件的.</p>
<ol start="6" type="1">
<li>积性函数的逆元也是积性函数.</li>
</ol>
<h4><span id="欧拉函数">欧拉函数</span></h4>
<p>定义欧拉函数$( m ) $为所有满足$1 n m n m <span class="math inline">\(的\)</span>n $的个数.</p>
<p>令$m = m _1 m _2 <span class="math inline">\(,其中\)</span>m _1 m _2
<span class="math inline">\(.由于若\)</span>n m _1 , n m _2 <span class="math inline">\(,显然有\)</span>( n m _1 ) m _1 <span class="math inline">\(且\)</span>( n m _2 ) m _2 <span class="math inline">\(,则根据中国剩余定理,不难有\)</span>( m ) = ( m _1
) ( m _2 ) <span class="math inline">\(,也即\)</span>( x )
$是积性函数.</p>
<p>若$n = ^{ k } _{ i = 1 } p _i ^{ a _i } $,则:</p>
<p>$( n ) = ^k _{ i = 1 } ( p _i ^{ a <em>i } ) = ^k </em>{ i = 1 } { p
_i ^{ a _i } - p _i ^{ a <em>i - 1 } } = ^k </em>{ i = 1 } { p ^{ a _i -
1 } ( p _i - 1 ) } $.</p>
<p>考虑改变枚举方式,因为$n = _{ p | n } p ^{ a <em>p } <span class="math inline">\(,则:\)</span>( n ) = </em>{ p | n } { p ^{ a <em>p
- 1 } ( p - 1 ) } = </em>{ p | n } { ( p ^{ a <em>p } { p } ) } = n
</em>{ p | n } { p } $.</p>
<p>我们考虑一个事实:现在有$m <span class="math inline">\(个不同的分数\)</span> { m } , k <span class="math inline">\(,这些分数进行约分后,它们的分母即\)</span>m <span class="math inline">\(的若干因数,而它们的分子就是与这些因数互质的数,同时这些数的个数总共是\)</span>m
<span class="math inline">\(个,我们可以得到:\)</span>_{ d | m } ( d ) =
m $.</p>
<p>上面这个结论还有另一种证明方法:</p>
<p>由于$<span class="math inline">\(是积性函数,若\)</span>n <span class="math inline">\(,设\)</span>n = _{ i = 1 } ^k p _i ^{ q <em>i }
<span class="math inline">\(,则\)</span>( n ) = </em>{ i = 1 } ^k ( p _i
^{ q _i } ) $,则有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ d | n  } \varphi ( d ) &amp; = \sum _{ w _1 = 0  } ^{ q _1  }
\sum _{ w _2 = 0  } ^{ q _2  } . . . . . . \sum _{ w _k = 0  } ^{ q
_k  } { \varphi ( p _1 ^{ w _1  } ) \varphi ( p _2 ^{ w _2  } ) . . . .
. . \varphi ( p _k ^{ w _k  } )  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>而$( p ^q ) = p ^q - p ^{ q - 1 } <span class="math inline">\(,于是有\)</span>_{ i = 1 } ^{ q _i } { ( p _x ^i -
p _x ^{ i - 1 } ) } = ( p _x ^{ q <em>x } - 1 ) <span class="math inline">\(,则有\)</span></em>{ i = 0 } ^{ q _x } ( p _x ^{ i
} ) = p _x ^{ q _x } $.</p>
<p>则原式等于$_{ i = 1 } ^k p _i ^{ q _i } = n $.</p>
<h5><span id="和法里级数的关系">和法里级数的关系</span></h5>
<p>我们考虑之前提到的法里级数$ <em>n <span class="math inline">\(,令\)</span>( x ) = </em>{ 1 k x } ( k ) <span class="math inline">\(,那么\)</span> _n <span class="math inline">\(的个数显然是\)</span>( x ) + 1 $.</p>
<p>接下来我们思考如何计算$( x ) <span class="math inline">\(.事实上,我们有\)</span>_{ d = 1 } ^n ( { d } ) = {
2 } ( n + 1 ) n $.这里的证明是:考虑满足$0 a &lt; b n <span class="math inline">\(的分数\)</span> { b } <span class="math inline">\(共有\)</span> { 2 } n ( n + 1 ) <span class="math inline">\(个,而如果我们枚举\)</span>d = ( a , b )
$,那么显然右边也等于这些分数个数,于是得证.</p>
<p>而事实上,如果我们用$n = x <span class="math inline">\(来带入上面的式子,可以得到\)</span>_{ d = 1 } ( { d
} ) = { 2 } x + x $.</p>
<p>根据第三种莫比乌斯反演的形式,我们有:$( x ) = { 2 } _{ 1 d } ( d ) { d
} { d } + 1 $.</p>
<h5><span id="麦克马洪和式">麦克马洪和式</span></h5>
<p>考虑这个问题:我们现在有$m <span class="math inline">\(种颜色,要对一个长度为\)</span>n
$的圆环进行染色,旋转后相同算一种方案,求方案数.</p>
<p>我们先设答案为$N ( n , m ) <span class="math inline">\(,并将这些答案全部列举出来,然后将它们进行旋转,进行\)</span>n
- 1 <span class="math inline">\(次.这样我们就得到了\)</span>nN ( n , m )
$个圆环,但是这些圆环是有重复的.</p>
<p>那么我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
nN ( n , m ) &amp; = \sum _{ a _0 a _1 . . . a _{ n - 1  }  } \sum _{ 0
\leq k &lt; n  } [ a _0 a _1 . . . a _{ n - 1  } &amp; = a _k . . . a _{
n - 1  } a _0 . . . a _{ k - 1  } ] \\
&amp; = \sum _{ 0 \leq k &lt; n  } \sum _{ a _0 a _1 . . . a _{ n -
1  }  } [ a _0 a _1 . . . a _{ n - 1  } &amp; = a _k . . . a _{ n - 1  }
a _0 . . . a _{ k - 1  } ]
\end{aligned}
\]</span></p>
<p>接下来我们只需要知道,当已知$k <span class="math inline">\(的时候,右边和式的贡献是多少.显然此时有\)</span>a
<em>i = a </em>{ ( i + k ) n } <span class="math inline">\(,也就是\)</span>a <em>i = a </em>{ ( i + kl ) n }
<span class="math inline">\(,此时答案为\)</span>m ^{ ( { n , k } ) }
$.</p>
<p>为啥答案为$m ^{ ( n , k ) } <span class="math inline">\(呢?我们考虑这一定会不断在\)</span>a <span class="math inline">\(中取数,那么会取多少数呢?显然会取\)</span>x - 1
<span class="math inline">\(个数,其中\)</span>i + xk = i + yn <span class="math inline">\(,不难解得此时\)</span>x = { ( k , n ) } <span class="math inline">\(,因此一共有\)</span>( n , k ) $个轨道.</p>
<p>也就是说:$nN ( n , m ) = <em>{ 0 k &lt; n } m ^{ ( n , k ) } , N ( n
, m ) = { n } </em>{ 0 k &lt; n } m ^{ ( n , k ) } \ $.</p>
<p>如果我们对这个式子进行化简:</p>
<p><span class="math display">\[
\begin{aligned}
N ( n , m ) &amp; = \cfrac { 1  } { n  } \sum _{ d | n  } m ^d \sum _{ 0
\leq k &lt; n  } [ d &amp; = \gcd ( n , k ) ] \\
&amp; = \cfrac { 1  } { n  } \sum _{ d | n  } m ^d \sum _{ d | k , k
&lt; n  } [ \cfrac { k  } { d  } \bot \cfrac { n  } { d  } ] \\
&amp; = \cfrac { 1  } { n  } \sum _{ d | n  } m ^d \sum _{ 0 \leq k &lt;
\frac { n  } { d  }  } [ k \bot \cfrac { n  } { d  } ] \\
&amp; = \cfrac { 1  } { n  } \sum _{ d | n  } \varphi ( d ) m ^{ \frac {
n  } { d  }  } .
\end{aligned}
\]</span></p>
<p>这个式子被称为麦克马洪公式.</p>
<p>另外,如果我们考虑$n | ( _{ d | n } ( d ) n ^{ { d } } ) <span class="math inline">\(这件事的证明,考虑如果\)</span>n = p ^k
$,那么根据费马小定理,显然可证明.</p>
<p>而由于$( x ) <span class="math inline">\(是积性函数,令\)</span>n = n
_1 n _2 , n _1 n _2 $,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ d | n  } \varphi ( d ) n ^{ \frac { n  } { d  }  } &amp; = \sum
_{ d _1 | n _1 , d _2 | n _2  } \varphi ( d _1 d _2 ) n ^{ \frac { n _1
n _2  } { d _1 d _2  }  } \\
&amp; = \sum _{ d _1 | n _1  } \varphi ( d _1 ) ( \sum _{ d _2 | n _2  }
\varphi ( d _2 ) ( n ^{ \frac { n _1  } { d _1  }  } ) ^{ \frac { n
_2  } { d _2  }  } )
\end{aligned}
\]</span></p>
<p>我们可以通过数学归纳来证明.</p>
<h5><span id="burnside定理">Burnside定理</span></h5>
<p>现在让我们来进行一些抽象代数的计算.</p>
<p>置换群:运算$( a _1 , a _2 , . . . , a _k ) <span class="math inline">\(表示将\)</span>a _1 <span class="math inline">\(放到\)</span>a _2 <span class="math inline">\(位置...把\)</span>a <em>i <span class="math inline">\(放到\)</span>a </em>{ i + 1 } <span class="math inline">\(的位置...把\)</span>a _k <span class="math inline">\(放到\)</span>a _1 <span class="math inline">\(的位置,而幺元\)</span>e = ( 1 ) ( 2 ) ( 3 ) . . .
( n ) $.</p>
<p>由麦克马洪和式的证明,我们不难推导出Polya定理:设要对$n <span class="math inline">\(个元素用\)</span>m <span class="math inline">\(种颜色染色,若通过某种旋转得到的染色方案算同一种,考虑旋转一定是一种置换,则本质不同的染色方案数\)</span>=
{ | S | } <span class="math inline">\(,其中\)</span>( s ) <span class="math inline">\(表示\)</span>s $的轨道数,即有多少组置换.</p>
<h6><span id="example1hnoi2009图的同构计数">Example1([HNOI2009]图的同构计数)</span></h6>
<p>首先看到循环同构,第一反应就是Burnside定理.考虑将每条边的状态设为两种:选或不选,那么我们就对点的编号进行置换,然后找到不动边的数量.</p>
<p>我们先考虑对于一个置换,该如何求得它的不动边的数量.考虑置换是一个排列,对它做置换环分解.</p>
<p>现在问题在于置换环内和置换环间要分别求不动点的数量.</p>
<p>先来考虑置换环内:由于是一个置换环,我们假设它的大小是$b <span class="math inline">\(,将这\)</span>b <span class="math inline">\(个点排成一个正\)</span>b <span class="math inline">\(边形(\)</span>b <span class="math inline">\(个点的完全图),考虑一个一条边转多少次才能转回来,如果不是\)</span>b
<span class="math inline">\(是偶数并且这条边正好平分整个多边形的话,显然需要转\)</span>n
<span class="math inline">\(次,简单判掉特殊情况,发现轨道数量\)</span> {
2 } $.</p>
<p>接下来考虑置换环外:对于两个置换环间,对于一条边,我们考虑不断做置换,做多少次才能使这条边回归原位置.注意到需要做$lcm
( b _1 , b _2 ) <span class="math inline">\(次.而总共有\)</span>b _1 b
_2 <span class="math inline">\(条边,于是轨道数量\)</span> { lcm ( b _1 ,
b _2 ) } = ( b _1 , b _2 ) $.</p>
<p>这样对于一个$k <span class="math inline">\(个环的置换,它的答案就是\)</span><em>{ i = 1 } ^k {
2 } + </em>{ i = 1 } ^k _{ j = i + 1 } ^k ( b _i , b _j ) $.</p>
<p>接下来发现本质不同的置换不多,搜出来每个置换环的大小,暴力判断.</p>
<h5><span id="欧拉定理">欧拉定理</span></h5>
<p>当$a m <span class="math inline">\(时,\)</span>a ^{ ( m ) } ( m )
$.</p>
<p>证明考虑取出$[ 1 , m ] <span class="math inline">\(中所有和\)</span>m
<span class="math inline">\(互质的数,设它们为\)</span>b _1 , b <em>2 , ,
b </em>{ ( m ) } $.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\prod _{ k = 1  } ^{ \varphi ( m )  } ab _k &amp; \equiv \prod _{ k =
1  } ^{ \varphi ( m )  } ( ab _k \bmod p ) ( \mod p ) \\
a ^{ \varphi ( m )  } \prod _{ k = 1  } ^{ \varphi ( m )  } b _k &amp;
\equiv \prod _{ k = 1  } ^{ \varphi ( m )  } b _k ( \mod p )
\end{aligned}
\]</span></p>
<p>欧拉定理可以用来求逆元:$a ^{ ( p ) } ( p ) <span class="math inline">\(,则有\)</span>a ^{ - 1 } a ^{ ( p ) - 1 } ( p )
$.</p>
<h5><span id="扩展欧拉定理">扩展欧拉定理</span></h5>
<p>$a ^b a ^c ( m ) $,其中</p>
<span class="math display">\[\begin{cases}

b\bmod \varphi(m) &amp;a\perp m\\

b &amp;b&lt;\varphi(m)\\

(b\bmod \varphi(m))+\varphi(m) &amp;other

\end{cases}\]</span>
<p>证明如下:</p>
<p>设$m = ^k _{ i = 1 } p _i ^{ e _i } <span class="math inline">\(,则要证\)</span>a ^b a ^{ ( b ( m ) ) + ( m ) } (
m ) <span class="math inline">\(,即证\)</span>i <span class="math inline">\(都有\)</span>a ^b a ^{ ( b ( m ) ) + ( m ) } ( p
_i ^{ e _i } ) $.</p>
<p>分情况讨论:</p>
<p>若$p _i ^{ e _i } a <span class="math inline">\(,则为普通欧拉定理情况,即证明\)</span>( p _i ^{ e
_i } ) <span class="math inline">\(是\)</span>b - c <span class="math inline">\(的因数.由于\)</span>( p _i ^{ e _i } ) <span class="math inline">\(是\)</span>( m ) <span class="math inline">\(的因数,而\)</span>( m ) <span class="math inline">\(是\)</span>b - c $的因数,显然得证.</p>
<p>不然,发现$e _i ( p _i ^{ e _i } ) ( m ) b <span class="math inline">\(且\)</span>( m ) c <span class="math inline">\(,又发现\)</span>p _i ^{ e _i } | a ^{ e _i } <span class="math inline">\(,所以\)</span>p _i ^{ e _i } | a ^b <span class="math inline">\(,\)</span>p _i ^{ e _i } | a ^c $,左右两边均为$0
$,得证.</p>
<h6><span id="example1cf906d-power-tower">Example1(CF906D Power Tower)</span></h6>
<p>考虑每次暴力做扩展欧拉定理,注意到每次会把$p <span class="math inline">\(变成\)</span>( p ) <span class="math inline">\(,如果\)</span>p <span class="math inline">\(是奇数,那它下一步会变为偶数,如果\)</span>p <span class="math inline">\(是偶数,则下一步至少减半,于是迭代次数是\)</span>n
$级别的.</p>
<h6><span id="example2六省联考-2017相逢是问候">Example2([六省联考 2017]
相逢是问候)</span></h6>
<p>同上.</p>
<h6><span id="example3具体数学454">Example3(《具体数学》4.54)</span></h6>
<p>求$1000 ! $.</p>
<p>首先,根据前面的例题,不难发现$5 ^{ 249 } ^{ 994 } ( 1000 ! ) $.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
1000 ! &amp; \equiv ans \pmod { 10 ^{ 250  }  } \\
\cfrac { 1000 !  } { 10 ^{ 249  }  } &amp; \equiv \cfrac { ans  } { 10
^{ 249  }  } \pmod { 10  }
\end{aligned}
\]</span></p>
<p>由于模数现在变成了$10 $,考虑$1 = 7 $,于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\cfrac { ans  } { 10 ^{ 249  }  } &amp; \equiv 2 ^{ 745  } \times 7 ^{
100  } \pmod { 10  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>而$( 10 ) = 4 $,根据扩展欧拉定理:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { ans  } { 10 ^{ 249  }  } &amp; \equiv 2 ^{ 5  } \pmod { 10  }
\\
ans &amp; \equiv 2 \times 10 ^{ 249  } \pmod { 10 ^{ 250  }  }
\end{aligned}
\]</span></p>
<h5><span id="example1具体数学457">Example1(《具体数学》4.57)</span></h5>
<p>求证:$_{ 1 k n + m } ( k ) [ ( m k ) + ( n k ) k ] = nm \ $.</p>
<p>先考虑将条件改为一个更好处理的式子,不难发现:</p>
<p><span class="math display">\[
[ m \bmod k + n \bmod k \geq k ] = \lfloor \cfrac { n + m  } { k  }
\rfloor - \lfloor \cfrac { n  } { k  } \rfloor - \lfloor \cfrac { m  } {
k  } \rfloor
\]</span></p>
<p>于是接下来我们要处理的式子形如$_{ 1 k n } ( k ) { k } \ $.</p>
<p>对其增加枚举量:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq k \leq n  } \varphi ( k ) \lfloor \cfrac { n  } { k  }
\rfloor &amp; = \sum _{ 1 \leq k \leq n  } \varphi ( k ) \sum _{ d =
1  } ^{ \lfloor \frac { n  } { k  } \rfloor  } 1 \\
&amp; = \sum _{ k = 1  } ^n \sum _{ d | k  } \varphi ( d ) \\
&amp; = \sum _{ k = 1  } ^n k &amp; = \cfrac { ( n + 1 ) n  } { 2  }
\end{aligned}
\]</span></p>
<p>带入即可证明.</p>
<h5><span id="example2">Example2</span></h5>
<p>求$_{ 1 a , b p ( p - 1 ) } [ a ^b b ^a ( p ) ] , p prime $.</p>
<p>考虑$p ( p - 1 ) $,使用中国剩余定理,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq a , b \leq p ( p - 1 )  } [ a ^b &amp; \equiv b ^a ( \mod
p ) ] \\
&amp; = \sum _{ 0 \leq a , b &lt; p  } \sum _{ 0 \leq c , d &lt; p -
1  } [ a ^c &amp; \equiv b ^d ( \mod p ) ] \\
&amp; = ( p - 1 ) ^2 + \sum _{ 1 \leq a , b &lt; p  } \sum _{ 0 \leq c ,
d &lt; p - 1  } [ a ^c &amp; \equiv b ^d ( \mod p ) ]
\end{aligned}
\]</span></p>
<p>后面那部分的答案是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq a , b &lt; p  } \sum _{ 0 \leq c , d &lt; p - 1  } [ a ^c
&amp; \equiv b ^d ( \mod p ) ] \\
&amp; = \sum _{ 1 \leq x &lt; p  } \sum _{ 0 \leq a , b &lt; p  } \sum
_{ 1 \leq c , d &lt; p - 1  } [ a ^c &amp; \equiv x ( \mod p ) ] [ b ^d
&amp; \equiv x ( \mod p ) ] \\
&amp; = \sum _{ 1 \leq x &lt; p  } ( \sum _{ 1 \leq a &lt; p , 0 \leq c
&lt; p - 1  } [ a ^c &amp; \equiv x ( \mod p ) ] ) ^2
\end{aligned}
\]</span></p>
<p>令$g <span class="math inline">\(为\)</span>p <span class="math inline">\(的原根,令\)</span>a = g ^b <span class="math inline">\(,\)</span>x = g ^{ x ’ } $有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 1 \leq x &lt; p  } ( \sum _{ 1 \leq a &lt; p , 0 \leq c &lt; p -
1  } [ a ^c &amp; \equiv x ( \mod p ) ] ) ^2 \\
&amp; = \sum _{ 0 \leq x &#39; &lt; p - 1  } ( \sum _{ 0 \leq b &lt; p -
1 , 0 \leq c &lt; p - 1  } [ bc &amp; \equiv x &#39; ( \mod p - 1 ) ] )
^2 \\
&amp; = \sum _{ 0 \leq x &lt; p - 1  } ( \sum _{ 0 \leq a , b &lt; p -
1  } [ ab &amp; \equiv x ( \mod p - 1 ) ] ) ^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑前面那个式子,如果我们令$x = x _0 x _1 , x _0 x _1 <span class="math inline">\(,\)</span>p - 1 = p _0 p _1 , p _0 p _1 $,其中$0 x
_0 &lt; p _0 , 0 x _1 &lt; p _1 <span class="math inline">\(,后面那个式子为\)</span>f ( p - 1 , x ) <span class="math inline">\(,由于中国剩余定理,有\)</span>f ( p - 1 , x ) = f (
p _0 , x _0 ) f ( p _1 , x _1 ) $.</p>
<p>于是令$p - 1 = _{ i = 1 } ^k p _i ^{ q _i } $上面的式子可以改为:</p>
<p><span class="math display">\[
\prod _{ i = 1  } ^k ( \sum _{ 0 \leq x _i &lt; p _i ^{ q _i  }  } (
\sum _{ 0 \leq a , b &lt; p _i ^{ q _i  }  } [ ab \equiv x _i ( \mod p
_i ^{ q _i  } ) ] ) ^2 )
\]</span></p>
<p>我们只考虑其中一项,形如:</p>
<p><span class="math display">\[
\sum _{ 0 \leq x &lt; p ^{ q  }  } ( \sum _{ 0 \leq a , b &lt; p ^q  } [
ab \equiv x ( \mod p ^{ q  } ) ] ) ^2
\]</span></p>
<p>我们不妨用$ap ^{ } <span class="math inline">\(代替\)</span>a <span class="math inline">\(,\)</span>bp ^<span class="math inline">\(代替\)</span>b <span class="math inline">\(,\)</span>xp ^t <span class="math inline">\(代替\)</span>x <span class="math inline">\(,其中\)</span>a , b , x p $那么有:</p>
<p><span class="math display">\[
\sum _{ 0 \leq x &lt; p ^{ q - t  }  } ( \sum _{ 0 \leq a &lt; p ^{ q -
\alpha  } , 0 \leq b &lt; p ^{ q - \beta  }  } [ abp ^{ \alpha +
\beta  } \equiv xp ^t ( \mod p ^{ q  } ) ] ) ^2
\]</span></p>
<p>则我们要做的即对四元组$( a , b , , ) <span class="math inline">\(计数.由于\)</span>a , b , x p $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha + \beta &amp; = t , \alpha , \beta \in \mathbb { N  } \\
ab &amp; \equiv x \pmod { p ^{ q - t  }  } , 0 &amp; \leq a &amp; &lt; p
^{ q - \alpha  } , 0 &amp; \leq b &amp; &lt; p ^{ q - \beta  }
\end{aligned}
\]</span></p>
<p>第一个式子对四元组的贡献显然是$t + 1 <span class="math inline">\(,而第二个式子,由于\)</span>[ 1 , p ^{ q - t } ) )
^2 + ( <em>{ 1 a , b p ^q } [ ab &amp; ] ) ^2 \ &amp; = </em>{ 1 x &lt;
p ^{ q - t } } ( ( t + 1 ) p ^{ t - } p ^{ t - } _{ 1 a , b &lt; p ^{ q
- t } } [ ab &amp; x ] ) ^2 + q ( p - 1 ) p ^{ q - 1 } + p ^q
\end{aligned} $$</p>
<p>后面,由于$a p <span class="math inline">\(,显然一个\)</span>a <span class="math inline">\(唯一对应一个\)</span>b $.于是我们得到了答案为:</p>
<p><span class="math display">\[
\sum _{ 1 \leq x &lt; p ^{ q - t  }  } ( ( t + 1 ) p ^{ t  } \varphi ( p
^{ q - t  } ) ) ^2
\]</span></p>
<p>而后面的式子显然跟$x $无关,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 0 &lt; x &lt; p ^{ q - t  }  } ( ( t + 1 ) p ^{ t  } \varphi ( p
^{ q - t  } ) ) ^2 \\
&amp; = \sum _{ 0 \leq t &lt; q  } ( \varphi ( p ^{ q - t  } ) ) ( ( t +
1 ) p ^{ t  } \varphi ( p ^{ q - t  } ) ) ^2 \\
&amp; = \sum _{ 0 \leq t &lt; q  } ( t + 1 ) ^2 p ^{ 2 t  } ( p - 1 ) ^3
p ^{ 3 q - 3 t - 3  } \\
&amp; = \sum _{ 0 \leq t &lt; q  } ( t + 1 ) ^2 ( p - 1 ) ^3 p ^{ 3 q -
t - 3  }
\end{aligned}
\]</span></p>
<p>其实到这一步,由于$t <span class="math inline">\(是\)</span>O ( n )
$级别的,这题已经可以做了.</p>
<h4><span id="莫比乌斯函数">莫比乌斯函数</span></h4>
<p>莫比乌斯函数$( x ) <span class="math inline">\(是一个满足\)</span>_{
d | n } ( n ) = 1
$的函数,根据定义其显然是积性函数.根据定义可以求出它的封闭形式:</p>
$( m ) =
<span class="math display">\[\begin{cases}0 &amp; \exists m _i \geq 2 \\
( - 1 ) ^k &amp; \forall m _i \leq 1 \end{cases}\]</span>
<p>, m = _{ i = 1 } ^k p _i ^{ m _i } $.</p>
<h5><span id="莫比乌斯反演">莫比乌斯反演</span></h5>
<p>见”反演.md”.</p>
<p>另外,值得一提的是,根据莫比乌斯反演,我们可以发现$id = $.</p>
<p>有公式:$^2 ( x ) = <em>{ i ^2 | x } ( i ) <span class="math inline">\(.原因很简单,我们设\)</span>x ’ <span class="math inline">\(为\)</span>x <span class="math inline">\(中所有的质因子的幂先除二下取整再乘二后变成的答案,显然\)</span>^2
( x ) = ^2 ( x ’ ) <span class="math inline">\(,我们有\)</span></em>{ i
| } ( y ) = [ = 1 ] , _{ i ^2 | x ’ } ( y ) = [ x ’ = 1 ] $.</p>
<h4><span id="min25筛">min25筛</span></h4>
<p>如果我们考虑积性函数的值,理论上来说,设$S ( n , k ) <span class="math inline">\(表示最小质因子大于等于\)</span>p _k <span class="math inline">\(的所有\)</span>f <span class="math inline">\(的和加上\)</span>f ( 1 ) $,其实我们自然有:</p>
<p><span class="math display">\[
S ( n , k ) = \sum _{ e \geq 0  } f ( p _k ^e ) S ( \lfloor \frac { n  }
{ p _k ^e  } \rfloor , k + 1 )
\]</span></p>
<p>问题在于这么做需要枚举$[ 1 , n ]
$中的全部质数,这是根本无法接受的.</p>
<p>我们考虑一些很大的质数,换言之,最小质因子大于$ <span class="math inline">\(的数在\)</span>[ 1 , n ]
$中只有可能是质数本身.</p>
<p>因此你会发现,这个过程只需要把质数单独拿出来做,复杂度就可以得到相当的飞跃.</p>
<p>考虑:</p>
<p><span class="math display">\[
\sum _{ i = 1  } ^n f ( i ) = \sum _{ p \in prime  } f ( p ) + \sum _{ p
\notin prime \land p \ne 1  } f ( p ) + f ( 1 )
\]</span></p>
<p>令$g ( N , i ) = _{ j = 1 } ^N [ j prime _j &gt; p _i ] F ( j ) \
<span class="math inline">\(,其中\)</span> _j <span class="math inline">\(表示\)</span>j <span class="math inline">\(最小的质因数,\)</span>p _i <span class="math inline">\(表示第\)</span>i $个质数.</p>
<p>注意到$g ( N , i ) <span class="math inline">\(实际上就是\)</span>N
<span class="math inline">\(以内的数在第\)</span>i <span class="math inline">\(轮埃氏筛后剩余的数的\)</span>F $的和.</p>
<p>$F ( i ) <span class="math inline">\(表示若干完全积性函数之和且当\)</span>p prime $
时,$F ( p ) = f ( p ) <span class="math inline">\(,下文为了方便书写,直接认为\)</span>F
$是完全积性函数.</p>
<p>而$g ( N , ) <span class="math inline">\(实际上就是\)</span>N <span class="math inline">\(以内的质数的\)</span>F $之和,那么有:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , 0 ) &amp; = \sum _{ i = 2  } ^n F ( i ) \\
g ( i , j ) &amp; = g ( i , j - 1 ) - F ( p _j ) ( \ g ( \lfloor \frac {
i  } { p _j  } \rfloor , j - 1 ) - \sum _{ 2 \leq p \leq p _{ j - 1  } ,
p \in prime  } F ( p ) \ ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>ps1:</p>
<p>第$j <span class="math inline">\(个质数会比第\)</span>j - 1 <span class="math inline">\(个多筛若干个数,即最小质因数是\)</span>p _j <span class="math inline">\(的数.这些数形如\)</span>{ p _j , 2 p _j , 3 p _j .
. . } <span class="math inline">\(,同时除以\)</span>p _j <span class="math inline">\(得到\)</span>{ 1 , 2 , 3 . . . } $.</p>
<p>我们要的就是其中最小质因数大于等于$p <em>j <span class="math inline">\(的数,也就是最小质因数大于\)</span>p </em>{ j - 1 }
<span class="math inline">\(的数,因而就是\)</span>g ( { p _j } , j - 1 )
$.</p>
<p>但还有一些质数会被重复计算,我们把他删掉就可以了.</p>
<p>考虑到$g <span class="math inline">\(后面的维度最多走到\)</span>
<span class="math inline">\(,所以我们所枚举的最小质因子一定小于等于\)</span>
<span class="math inline">\(,所以一定有\)</span>p _{ j - 1 } &lt; { p _j
} $,所以直接删去一定不会多删.</p>
<p>ps2:</p>
<p>注意到以下事实:$ { c } = { bc } \ $.</p>
<p>因而,如果我们有以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[n])<span class="keyword">return</span> f[n];</span><br><span class="line"><span class="keyword">else</span> f[n]=......;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="built_in">solve</span>(n/i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">solve</span>(n);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码复杂度为$O ( ) <span class="math inline">\(.原因在于,根据整数分块,\)</span> { i } <span class="math inline">\(有\)</span> $种取值.</p>
<p>而如果递归下去,继续枚举$j <span class="math inline">\(,并往下递归到\)</span> { j } <span class="math inline">\(,那他就相当于枚举\)</span>k = ij <span class="math inline">\(,并递归到\)</span> { k } $,因而复杂度得到保证.</p>
<p>由此可知,求$g <span class="math inline">\(的复杂度为\)</span>O ( ) =
O ( n ^{ { 4 } } ) $.</p>
<p>令$S ( n , m ) <span class="math inline">\(表示前\)</span>n <span class="math inline">\(个数中,最小质因数大于等于\)</span>p _m <span class="math inline">\(的数的\)</span>f $之和,可知:</p>
$$
<span class="math display">\[\begin{aligned}
S ( n , m ) &amp; = g ( n , + \infty ) - \sum _{ k = 1  } ^{ m - 1  } f
( p _k ) + \sum _{ k \geq m , e \geq 1 , p _k ^{ e + 1  } \leq n  } f (
p _k ^e ) S ( \lfloor \frac { n  } { p _k ^e  } \rfloor , k + 1 ) + \sum
_{ k \geq m , e = 2 , p _k ^e \leq n  } f ( p _k ^e ) \\
&amp; = g ( n , + \infty ) - \sum _{ k = 1  } ^{ m - 1  } f ( p _k ) +
\sum _{ k \geq m , e \geq 1 , p _k ^{ e + 1  } \leq n  } [ f ( p _k ^e )
S ( \lfloor \frac { n  } { p _k ^e  } \rfloor , k + 1 ) + f ( p _k ^{ e
+ 1  } ) ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>ps1:</p>
<p>前半段求出质数部分的和,后半段开始枚举最小质因子.</p>
<p>由于$p _k <span class="math inline">\(是当前数的最小质因子,\)</span>e
<span class="math inline">\(是他的幂.则这个数其他的质因子应该均大于\)</span>p
<em>k <span class="math inline">\(,因而大于等于\)</span>p </em>{ k + 1 }
$.</p>
<p>注意到由于$S $中不包含$1 <span class="math inline">\(,所以应特殊处理只含有\)</span>p _k
$一个质因子的情况.</p>
<p>又注意到,如果$p _k ^e &lt; n &lt; p _k ^{ e + 1 } <span class="math inline">\(,那么此时\)</span> { p _k ^e } <span class="math inline">\(一定小于\)</span>p _k <span class="math inline">\(,则不可能拥有比\)</span>p _k $更大的质因子.</p>
<p>该形式与上面一致,因而复杂度同样为$O ( n ^{ { 4 } } ) <span class="math inline">\(.我们最终要求的答案即\)</span>S ( n , 1 ) + f ( 1
) $.</p>
<p>一些后记:</p>
<ol type="1">
<li><p>事实上,复杂度的计算只是上限,实际上应该约为$O ( { _2 n } )
$.</p></li>
<li><p>如果使用map会导致复杂度较差,考虑如下事实:</p></li>
</ol>
<p>(1).$ x n <span class="math inline">\(,则要么\)</span>x <span class="math inline">\(,要么\)</span> { x } \ $.</p>
<p>(2).$a <span class="math inline">\(形如\)</span> { x } <span class="math inline">\(,则\)</span> { a } <span class="math inline">\(应为\)</span>x _{ max } $,互不相同.</p>
<p>因而可以分别特判,从而做到比map或离散化都优秀的复杂度.</p>
<ol start="3" type="1">
<li><p>我们在代码中所求出的$w
$是倒序的,而我们转移的过程也是倒序的,因而枚举的时候可以直接正序枚举.</p></li>
<li><p>考虑做的时候由于进行了滚动数组,因而继承操作可以直接使用,为了方便可以直接判掉可以直接继承的情况.</p></li>
<li><p>求$S <span class="math inline">\(的过程可以使用递归,因为我们只关心一个\)</span>S
$的量.</p></li>
</ol>
<h5><span id="example1uoj188sanrd">Example1([uoj188]Sanrd)</span></h5>
<p>注意到这题显然可以写埃筛的暴力.考虑使用类似min15筛的方式,定义$f ( n )
<span class="math inline">\(为\)</span>n <span class="math inline">\(的次大质因子(若\)</span>n = 1 n prime <span class="math inline">\(则\)</span>f ( n ) = 0 <span class="math inline">\(),\)</span>S ( n , k ) = _{ i = 1 } ^n [ _i p _k ]
f ( i ) <span class="math inline">\(.不难发现我们要求的就是\)</span>S (
n , 1 ) <span class="math inline">\(,而显然\)</span>S ( n , ) = 0 $.</p>
<p>注意到:</p>
<p><span class="math display">\[
S ( n , m ) = \sum _{ i \geq m , e \geq 1 , p _i ^{ e + 1  } \leq n  } S
( \lfloor \frac { n  } { p _i ^e  } \rfloor , i + 1 ) + p _i \sum _{ i =
p _i + 1  } ^{ \lfloor \frac { n  } { p _i ^e  } \rfloor  } [ i \in
prime ]
\]</span></p>
<p>区间素数个数可以拿min25筛的前半部分做.</p>
<h4><span id="杜教筛">杜教筛</span></h4>
<p>令$F ( n ) = _{ i = 1 } ^n f ( i ) \ <span class="math inline">\(,我们考虑构造两个函数\)</span>g <span class="math inline">\(和\)</span>s <span class="math inline">\(.使得\)</span>f * g = s $.</p>
<p>令$G ( n ) = <em>{ i = 1 } ^n g ( i ) , S ( n ) = </em>{ i = 1 } ^n s
( i ) \ <span class="math inline">\(.若\)</span>G ( i ) <span class="math inline">\(和\)</span>S ( i ) <span class="math inline">\(都很方便求,\)</span>g ( 1 ) = 1 <span class="math inline">\(,我们就可以求出\)</span>F ( n ) $.</p>
$$
<span class="math display">\[\begin{aligned}
f * g &amp; = s \\
\sum _{ j | i  } f ( j ) g ( \frac { i  } { j  } ) &amp; = s ( i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由于$g ( 1 ) = 1 <span class="math inline">\(,我们有\)</span>f ( i )
= s ( i ) - _{ j | i , j i } f ( j ) g ( { j } ) \ $.</p>
<p>那么:</p>
$$
<span class="math display">\[\begin{aligned}
F ( n ) &amp; = \sum _{ i = 1  } ^n f ( i ) \\
&amp; = \sum _{ i = 1  } ^n ( s ( i ) - \sum _{ j | i , j \ne i  } f ( j
) g ( \frac { i  } { j  } ) ) \\
&amp; = S ( n ) - \sum _{ j = 1  } ^n \sum _{ k = 2  } ^{ \lfloor \frac
{ n  } { j  } \rfloor  } g ( k ) f ( j ) \\
&amp; = S ( n ) - \sum _{ k = 2  } ^n g ( k ) \sum _{ j = 1  } ^{
\lfloor \frac { n  } { k  } \rfloor  } f ( j ) \\
&amp; = S ( n ) - \sum _{ k = 2  } ^n g ( k ) F ( \lfloor \frac { n  } {
k  } \rfloor ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>复杂度证明和min25筛是一样的,不同点在于我们可以预处理$n ^{ { 3 } }
<span class="math inline">\(以内的\)</span>F <span class="math inline">\(,这样复杂度可以降到\)</span>O ( n ^{ { 3 } } )
$.</p>
<h5><span id="example1">Example1</span></h5>
<p>求$_{ i = 1 } ^N ( i ) \ $.</p>
<p>由于$I = <span class="math inline">\(,于是考虑\)</span>g = I $.</p>
<h5><span id="example2">Example2</span></h5>
<p>求$_{ i = 1 } ^N ( i ) \ $.</p>
<p>由于$I = id <span class="math inline">\(,于是考虑\)</span>g = I
$.</p>
<h5><span id="example3">Example3</span></h5>
<p>求$_{ i = 1 } ^N { ( i ) i } \ $</p>
<p>由于$^N <em>{ i = 1 } ( f * g ) ( i ) = </em>{ d | N } { f ( i ) g (
{ d } ) } = _{ d | N } { ( d ) d g ( { d } ) } \ $</p>
<p>由于中间过程中乘出来的$d <span class="math inline">\(很难处理,需要消掉它,于是考虑\)</span>g = id $.</p>
<h5><span id="example4">Example4</span></h5>
<p>$_{ i = 1 } ^N { ( i ) i ^2 } \ $.</p>
<p>由Example3,于是考虑$g = id ^2 $.</p>
<h4><span id="powerful-number筛">Powerful Number筛</span></h4>
<p>定义Powerful Number为满足所有质因子的指数都$&gt; 1 <span class="math inline">\(的数,不难证明这样的数在\)</span>[ 1 , n ] <span class="math inline">\(中最多只有\)</span>O ( )
$个(使用积分).同时对于质因子的幂分奇偶讨论:奇数分成一个$3 <span class="math inline">\(加上一个偶数,那么不难证明这个数一定有:\)</span>a
^2 b ^3 $的形式.找到这些数字可以直接dfs搜指数.</p>
<p>现在我们要求积性函数$f ( n ) <span class="math inline">\(的前缀和.假设\)</span>f = h * g <span class="math inline">\(,其中\)</span>h ( 1 ) = 1 , g ( p ) = f ( p ) , p
prime <span class="math inline">\(且\)</span>g ( n )
$的前缀和容易计算.</p>
<p>接下来我们证明:$h ( n ) n  is  Powerful  Number $.</p>
<p>$p prime <span class="math inline">\(,\)</span>f ( p ) = g ( 1 ) h (
p ) + g ( p ) h ( 1 ) = h ( p ) + g ( p ) <span class="math inline">\(,于是\)</span>h ( p ) = 0 <span class="math inline">\(.根据积性函数的性质有\)</span>x , h ( x ) = 0
$.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
F ( n ) &amp; = \sum _{ i = 1  } ^n f ( i ) \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j | i  } h ( j ) g ( \frac { i  } {
j  } ) \\
&amp; = \sum _{ j = 1  } ^n h ( j ) G ( \lfloor \frac { n  } { j  }
\rfloor )
\end{aligned}
\]</span></p>
<p>于是可以快速求,复杂度$O ( ) $.</p>
<h5><span id="example1sp20174divcnt3">Example1([SP20174]DIVCNT3)</span></h5>
<p>首先我们需要构造$g ( p ) = f ( p ) , p prime <span class="math inline">\(.注意到\)</span>f ( p ) = d ( p ^3 ) = 4 <span class="math inline">\(,我们构造\)</span>g ( p ) = ( d * d ) ( p ) <span class="math inline">\(.这样问题在于求\)</span>G ( n ) $.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
G ( n ) &amp; = \sum _{ i = 1  } ^n ( d * d ) ( i ) \\
&amp; = \sum _{ ij \leq n  } d ( i ) d ( j ) \\
&amp; = \sum _{ i = 1  } ^n d ( i ) D ( \lfloor \frac { n  } { i  }
\rfloor )
\end{aligned}
\]</span></p>
<p>而$D ( n ) = _{ i = 1 } ^n { i } <span class="math inline">\(,自然可以做.复杂度算一算是\)</span>O ( n ^{ { 3 }
} ) $.</p>
<p>感觉Powerful Number筛的关键在于构造.</p>
<h2><span id="整值函数">整值函数</span></h2>
<h3><span id="定义">定义</span></h3>
<p>若$x $,则:</p>
<p>$x = $小于等于x的最大的整数.</p>
<p>$x = $大于等于x的最小的整数.</p>
<p>我们有时称$x <span class="math inline">\(为\)</span>x <span class="math inline">\(的整数部分,并定义\)</span>x - x <span class="math inline">\(为分数部分,有时记作\)</span>{ x } $.</p>
<p>我们定义$x y = x - y { y } <span class="math inline">\(,\)</span>x
 mumble  y = y { y } - x <span class="math inline">\(,其中\)</span>x , y
$.</p>
<p>当然,我们也可以使用上述定义将$mod <span class="math inline">\(和\)</span>mumble <span class="math inline">\(的定义扩展到实数域,不过\)</span>y = 0
$的时候需要特殊处理.</p>
<h3><span id="整值函数的基本性值">整值函数的基本性值</span></h3>
<p>若$x , n $,则有:</p>
<ol type="1">
<li><p>$x = x x = x x $.</p></li>
<li><p>$x - x = [ x ] $.</p></li>
<li><p>$x - 1 &lt; x x x &lt; x + 1 $.</p></li>
<li><p>$- x = - x , - x = - x $.</p></li>
<li><p>$x = n n x &lt; n + 1 x - 1 &lt; n x $.</p></li>
<li><p>$x = n n - 1 &lt; x n x n &lt; x + 1 $.</p></li>
<li><p>$x &lt; n x &lt; n $.</p></li>
<li><p>$x n x n $.</p></li>
<li><p>$x &gt; n x &gt; n $.</p></li>
<li><p>$x n x n $.</p></li>
<li><p>$x + n = x + n $.</p></li>
<li><p>$x + n = x + n $.</p></li>
<li><p>$nx = n x n = 0 x - x &lt; { n } $.</p></li>
<li><p>$nx = n x n = 0 x - x &lt; { n } $.</p></li>
<li><p>$ { m } = { m } + 1 , m $.</p></li>
<li><p>$m x - m ( x - x ) = mx $.</p></li>
<li><p>$( x ny ) y = x y , n $.</p></li>
<li><p>分配律:$c ( x y ) = ( cx ) ( cy ) $.</p></li>
</ol>
<h3><span id="整值函数的应用">整值函数的应用</span></h3>
<h4><span id="一类函数与整值函数">一类函数与整值函数</span></h4>
<p>设$f ( x ) $是一个有以下性质且在一个实数区间连续的单调递增函数:</p>
<p>$f ( x ) x $.</p>
<p>那么,只要$f ( x ) , f ( x ) , f ( x ) $都有定义,我们有:</p>
<p>$f ( x ) = f ( x ) <span class="math inline">\(和\)</span>f ( x ) = f
( x ) $.</p>
<p>由于底和顶是类似的,我们考虑先对顶进行证明,这样也可以类似证明底:</p>
<p>若$x = x $,显然得证;</p>
<p>不然,有$x &lt; x <span class="math inline">\(,那么有\)</span>f ( x )
&lt; f ( x ) <span class="math inline">\(,也就有\)</span>f ( x ) f ( x )
$.</p>
<p>考虑反证法,不妨令$f ( x ) &lt; f ( x ) <span class="math inline">\(.则一定存在一个整数\)</span>y <span class="math inline">\(使得\)</span>f ( x ) = y &lt; f ( x ) <span class="math inline">\(,此时必有\)</span>x y &lt; x <span class="math inline">\(.由于\)</span>f <span class="math inline">\(的性值,显然有\)</span>y <span class="math inline">\(是整数,但根据整值函数的性值,不可能存在这样一个整数\)</span>y
<span class="math inline">\(满足\)</span>x y &lt; x $,因此得证.</p>
<p>另外,我们考虑函数$f ( x ) = { n } <span class="math inline">\(,显然这是一个满足条件的函数,因此显然满足上述的条件.再考虑\)</span>m
= 0 <span class="math inline">\(的特殊情况:\)</span> { m } = { nm }
$.</p>
<p>而单调递减函数可以取相反数转化为单调递增函数.</p>
<h4><span id="迪利克雷抽屉原理">迪利克雷抽屉原理</span></h4>
<p>$n <span class="math inline">\(个物体放进\)</span>m <span class="math inline">\(个盒子里,那么必定有一个盒子中放入了大于等于\)</span>
{ m } <span class="math inline">\(个物品,有一个盒子放入了小于等于\)</span> { m }
$个物体.</p>
<h5><span id="example1">Example1</span></h5>
<p>求证:每个由$n ^2 + 1 <span class="math inline">\(个不同实数构成的序列都包含一个长为\)</span>n + 1
$的严格递增子序列或严格递减子序列.</p>
<p>设$a _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(个实数,\)</span>c _i <span class="math inline">\(为以这个数为开头的最长的递增子序列,\)</span>d _i
<span class="math inline">\(表示以这个数为开头的最长的递减子序列.考虑反证法,如果不成立,那么\)</span>
i n ^2 + 1 $,$1 c _i n d _i n <span class="math inline">\(.那么一共有\)</span>n ^2 $种不同的有序对.</p>
<p>根据抽屉原理,一共有$n ^2 + 1 <span class="math inline">\(个有序对,所以一定有两个有序对相等.由于这些数字两两不同,所以一定可以把其中一个数字加到另一个数字的递增或递减子序列的后面,这样那个数字的\)</span>c
_i <span class="math inline">\(或者\)</span>d _i <span class="math inline">\(就要\)</span>+ 1
$,与我们的假设不符,因此该定理成立.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证:若任意两个人间只有两种关系:朋友或敌人.那么对于六个人而言,一定有三个人两两都是朋友或者两两都是敌人.</p>
<p>令$A $是这六个人中其中一个,根据抽屉原理,一定有大于等于$3 <span class="math inline">\(个人都是\)</span>A <span class="math inline">\(的敌人或者都是\)</span>A <span class="math inline">\(的朋友,不妨假设这三个人都是\)</span>A $的朋友.</p>
<p>如果这三个人中有两个人是朋友,那么它们和A就一起构成了一组人.不然,他们三个人就构成了一组人.</p>
<h4><span id="计算区间内整数个数">计算区间内整数个数</span></h4>
<p>整值函数的另一个应用是计算区间内整数个数:</p>
<p>考虑基本性值$7 , 8 , 9 , 10 $,不难发现:</p>
<ol type="1">
<li><p>$[ , ] <span class="math inline">\(包含\)</span>- + 1
$个整数.</p></li>
<li><p>$( , ) <span class="math inline">\(包含\)</span>- - 1
$个整数.</p></li>
<li><p>$( , ] <span class="math inline">\(包含\)</span>-
$个整数.</p></li>
<li><p>$[ , ) <span class="math inline">\(包含\)</span>-
$个整数.</p></li>
</ol>
<h4><span id="谱">谱</span></h4>
<p>我们定义一个实数$$的<strong>谱</strong>是以下集合:</p>
<p>$Spec ( ) = { , , . . . } $.</p>
<p>不难发现,只要$<span class="math inline">\(,则\)</span>Spec ( ) Spec (
) $.</p>
<h5><span id="example">Example</span></h5>
<p>求证:$Spec ( ) Spec ( 2 + ) = <span class="math inline">\(且\)</span>Spec ( ) Spec ( 2 + ) =
$,即这两个集合构成了正整数集的一个划分.</p>
<p>我们考虑这样一个事实:对于任意正整数$n <span class="math inline">\(,如果我们能求出来\)</span>Spec ( ) <span class="math inline">\(中有\)</span>a <span class="math inline">\(个元素\)</span>n <span class="math inline">\(,\)</span>Spec ( 2 + ) <span class="math inline">\(中有\)</span>b <span class="math inline">\(个元素\)</span>n <span class="math inline">\(,并且\)</span>a + b = n $,则结论显然成立.</p>
<p>不妨令函数$N ( , n ) <span class="math inline">\(表示\)</span>Spec (
) <span class="math inline">\(中有多少个元素\)</span>n <span class="math inline">\(,其中\)</span>$是正数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
N ( \alpha , n ) &amp; = \sum _{ k \in \mathbb { N _+  }  } [ \lfloor k
\alpha \rfloor &amp; \leq n ] \\
&amp; = \sum _{ k \in \mathbb { N _+  }  } [ \lfloor k \alpha \rfloor
&amp; &lt; n + 1 ] \\
&amp; = \sum _{ k \in \mathbb { N _+  }  } [ k \alpha &amp; &lt; n + 1 ]
\\
&amp; = \sum _k [ 0 &amp; &lt; k &amp; &lt; ( n + 1 ) / \alpha ] \\
&amp; = \lceil ( n + 1 ) / \alpha \rceil - 1
\end{aligned}
\]</span></p>
<p>则我们要证明的就是:</p>
<p><span class="math display">\[
\begin{aligned}
\lceil \cfrac { n + 1  } { \sqrt { 2  }  } \rceil - 1 + \lceil \cfrac {
n + 1  } { 2 + \sqrt { 2  }  } \rceil - 1 &amp; = n \\
\lfloor \cfrac { n + 1  } { \sqrt { 2  }  } \rfloor + \lfloor \cfrac { n
+ 1  } { 2 + \sqrt { 2  }  } \rfloor &amp; = n \\
\cfrac { n + 1  } { \sqrt { 2  }  } - \{ \cfrac { n + 1  } { \sqrt {
2  }  } \} + \cfrac { n + 1  } { 2 + \sqrt { 2  }  } - \{ \cfrac { n +
1  } { 2 + \sqrt { 2  }  } \} &amp; = n
\end{aligned}
\]</span></p>
<p>而由于我们有恒等式:$ { } + { 2 + } = 1
$,且两个相加为整数的数的分数部分相加显然为$1 $,原式得证.</p>
<p>事实上,如果两个集合$Spec ( ) <span class="math inline">\(和\)</span>Spac ( ) <span class="math inline">\(构成正整数集一个划分,可以同上证明\)</span> { } + {
} = 1 <span class="math inline">\(且\)</span><span class="math inline">\(和\)</span>$都是无理数.</p>
<h4><span id="整值函数的递归式">整值函数的递归式</span></h4>
<p>得到递归式的封闭形式的确很有用,它可以让我们在很快的时间内求出答案,但大部分时候是很麻烦的.</p>
<p>而如果我们对时间的要求没有那么紧,我们不妨考虑一种较慢但更容易的方法:</p>
<h5><span id="example">Example</span></h5>
<p>约瑟夫问题,但是每隔两个人处死一个人,求最后存活者的编号.</p>
<p>我们不妨这样考虑:我们每略过两个人,就将他们重新编号.</p>
<p>例如,我们杀掉了三号,就将一号和二号重新编号为$n + 1 <span class="math inline">\(号和\)</span>n + 2 <span class="math inline">\(号,杀掉了六号,就将四号和五号重新编号为\)</span>n +
3 <span class="math inline">\(号和\)</span>n + 4
$号,这样,我们在做游戏的时候,场上人员的编号一定是连续的.</p>
<p>我们把最后存活者改为最后死亡者,这样它的最后编号就是$3 n $.</p>
<p>并且不难发现,第$k $个死亡的人的最后编号就是$3 k $.</p>
<p>我们考虑已知新编号如何求旧编号,设新编号为$N $:</p>
<p>如果$N n <span class="math inline">\(,则\)</span>N <span class="math inline">\(是初始编号,反之,我们考虑在编号\)</span>N
$的时候被杀死的人的编号.</p>
<p>假设现在进行完了$k + 1 <span class="math inline">\(轮,令\)</span>N =
n + 2 k + w <span class="math inline">\(,其中\)</span>w { 1 , 2 } <span class="math inline">\(,则编号\)</span>N $的时候被杀死的即是$3 ( k + 1 )
<span class="math inline">\(,那么\)</span>N $之前的编号就是$3 k + w = N
- ( n - k ) = N - n + k $.</p>
<p>而$k = { 2 } $,我们可以不断进行迭代.</p>
<p>如果我们令$D = 3 n + 1 - N
$,换句话说即改变编号的顺序,我们可以有以下的赋值操作:</p>
<p>$3 n + 1 - D ’ = 3 n + 1 - D - n + { 2 } $.</p>
<p>化简这个式子,我们有:$D ’ = D + n - { 2 } = D + { 2 } = { 2 } $.</p>
<p>事实上,我们可以证明:如果我们每隔$q <span class="math inline">\(个人就杀掉一个人的话,那么\)</span>D ’ = { q }
<span class="math inline">\(,一直迭代到\)</span>D ’ &gt; qn $时.</p>
<p>而最后的答案就是$( q + 1 ) n + 1 - D $.</p>
<h4><span id="整值函数的恒等式">整值函数的恒等式</span></h4>
<p>考虑公式$ { m } $,不难发现它在$1 k n m <span class="math inline">\(时的值为\)</span> { m } <span class="math inline">\(,而在\)</span>n m &lt; k m <span class="math inline">\(的值为\)</span> { m } $.</p>
<p>那么我们可以得到以下恒等式:</p>
<p>$n = _{ k = 1 } ^m { m } $.</p>
<p>类似地,有:</p>
<p>$n = _{ k = 1 } ^m { m } $.</p>
<p>用$mx <span class="math inline">\(替换上面的\)</span>n <span class="math inline">\(有\)</span>mx = _{ k = 1 } ^m x + { m } $.</p>
<p>同样的,有$mx = _{ k = 1 } ^m x - { m } $.</p>
<h4><span id="整值函数的和式">整值函数的和式</span></h4>
<p>通常情况下,处理含整值函数的和式时,通过引入新变量进行代替以及通过转化为区间进行化简.</p>
<p>如果遇到难以处理的情况,我们不妨考虑直接处理其中一段的和,使得剩下部分求和更为简单.</p>
<p>处理整值函数的另一个方法是:考虑将整值函数内的东西移出,并且让里面的东西形如等差序列,这样我们就可以尝试使用恒等式来化简.</p>
<h5><span id="example1">Example1</span></h5>
<p>求$_{ k = 0 } ^{ n - 1 } $.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^{ n - 1  } \lfloor \sqrt { k  } \rfloor &amp; = \sum
_{ 0 \leq k , m  } [ k &amp; &lt; n ] [ m &amp; = \lfloor \sqrt { k  }
\rfloor ] m \\
&amp; = \sum _{ 0 \leq k , m  } [ k &amp; &lt; n ] [ m ^2 &amp; \leq k
&amp; &lt; ( m + 1 ) ^2 ] m \\
&amp; = \sum _{ 0 \leq k , m  } m [ m ^2 &amp; \leq k &amp; &lt; n &amp;
&lt; ( m + 1 ) ^2 ] + \sum _{ 0 \leq k , m  } m [ m ^2 &amp; \leq k
&amp; &lt; ( m + 1 ) ^2 &amp; \leq n ]
\end{aligned}
\]</span></p>
<p>考虑$n = a ^2 $的特殊情况,则前面那一项显然是$0 $,那么:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ 0 \leq k , m  } m [ m ^2 &amp; \leq k &amp; &lt; ( m
+ 1 ) ^2 &amp; \leq n ] \\
&amp; = \sum _{ 0 \leq m  } m ( 2 m + 1 ) [ m &amp; &lt; a ] \\
&amp; = \sum _{ m = 0  } ^{ a - 1  } ( 2 m ^2 + m ) \\
&amp; = \cfrac { ( a - 1 ) a ( 2 a - 1 )  } { 3  } + \cfrac { a ( a - 1
)  } { 2  } \\
&amp; = \cfrac { ( 4 a + 1 ) a ( a - 1 )  } { 6  }
\end{aligned}
\]</span></p>
<p>而如果$n a ^2 <span class="math inline">\(,我们令\)</span>a = <span class="math inline">\(,而当\)</span>k \ &amp; = <em>{ 1 j &lt; a }
</em>{ k } [ j ^2 &amp; k &amp; &lt; a ^2 ] \ &amp; = _{ 1 j &lt; a } a
^2 - j ^2 &amp; = a ^3 - { 6 } \end{aligned} $$</p>
<h5><span id="example2类欧几里得算法">Example2(类欧几里得算法)</span></h5>
<p>求$_{ k = 0 } ^{ m - 1 } { m } , m , n $.</p>
<p>由于$kn - ( kn m ) = m { m } $,我们有:</p>
<p><span class="math display">\[
\lfloor \cfrac { x + kn  } { m  } \rfloor = \lfloor \cfrac { x + ( kn
\mod m )  } { m  } \rfloor + \cfrac { kn  } { m  } - \cfrac { kn \mod
m  } { m  }
\]</span></p>
<p>这样,我们将整个式子的求和分为了三部分,第二项显然是等差数列求和,而如果我们令$g
= ( n , m ) $,不难发现第三项的分子是一个等差数列$0 , g , 2 g , . . . m -
g <span class="math inline">\(重复了\)</span>g
$次,而且正因为这,第一项里面的数也就自然组成了等差数列,由于我们有恒等式,那么这一项也就自然可以计算了.</p>
<p>分别求和后加起来,得到答案为$g { g } + { 2 } + { 2 } $.</p>
<p>另外,对这个式子进行化简,我们可以得到:$g { g } + { 2 } + { 2 } <span class="math inline">\(,而这个式子关于\)</span>n <span class="math inline">\(和\)</span>m $是对称的.</p>
<p>也就是说:$<em>{ k = 0 } ^{ m - 1 } { m } = </em>{ k = 0 } ^{ n - 1 }
{ n } , m , n $.</p>
<p>另外,如果要求$^n _{ i = 0 } { c } <span class="math inline">\(,我们也有一种\)</span>O ( n )
$的做法(类欧几里得算法):</p>
<p>若$c a <span class="math inline">\(,原式化为\)</span>^n _{ i = 0 } {
( i { c } + { c } ) } $.</p>
<p>若$c b <span class="math inline">\(,原式化为\)</span>^n _{ i = 0 } {
{ c } + { c } } $.</p>
<p>考虑$a , b &lt; c <span class="math inline">\(的情况,设\)</span>m = {
c } $,原式化为</p>
<p><span class="math display">\[
\begin{aligned}
\sum ^n _{ i = 0  } \sum ^m _{ j = 1  } [ j &amp; \leq \lfloor \cfrac {
ai + b  } { c  } \rfloor ] \\
&amp; = \sum ^n _{ i = 0  } \sum ^m _{ j = 1  } [ cj &amp; \leq ai + b ]
\\
&amp; = nm - \sum ^n _{ i = 0  } \sum ^m _{ j = 1  } [ ai &amp; \leq cj
- b - 1 ] \\
&amp; = nm - \sum ^m _{ i = 1  } \lfloor \cfrac { ci - b - 1  } { a  }
\rfloor
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求$_{ n = 1 } ^{ 1000 } [ | n ] $.</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ n , k  } [ k &amp; = \lfloor \sqrt [3 ] { n  }
\rfloor ] [ k | n ] [ 1 &amp; \leq n &amp; \leq 1000 ] \\
&amp; = \sum _{ k , m , n  } [ k ^3 &amp; \leq n &amp; &lt; ( k + 1 ) ^3
] [ n &amp; = km ] [ 1 &amp; \leq n &amp; \leq 1000 ] \\
&amp; = 1 + \sum _{ k , m  } [ k ^3 &amp; \leq km &amp; &lt; ( k + 1 )
^3 ] [ 1 &amp; \leq k &amp; &lt; 10 ] \\
&amp; = 1 + \sum _{ k , m  } [ k ^2 &amp; \leq m &amp; &lt; \frac { ( k
+ 1 ) ^3  } { k  } ] [ 1 &amp; \leq k &amp; &lt; 10 ] \\
&amp; = 1 + \sum _{ k = 1  } ^9 ( \lceil k ^2 + 3 k + 3 + \frac { 1  } {
k  } \rceil - \lceil k ^2 \rceil ) \\
&amp; = 1 + \sum _{ k = 1  } ^9 ( 3 k + 4 ) &amp; = 172
\end{aligned}
\]</span></p>
<p>上述推理过程将$n = 1000 <span class="math inline">\(的情况特殊讨论了一下,不难发现,如果我们要求的式子是\)</span>_{
n = 1 } ^{ N } [ | n ] <span class="math inline">\(,也仍然可以使用将\)</span>[ K ^3 , N ] , K = <span class="math inline">\(中的数特殊处理的方式做掉,因为这些数的三次根下取整一定是\)</span>K
$,式子就不难化简了.</p>
<h5><span id="example4uoj42sum">Example4([uoj42]Sum)</span></h5>
<p>这题的重点在于将幂通过$- 1 $的性质拿下来.</p>
<p>我们有$( - 1 ) ^a = 1 - 2 ( a ) = 1 - 2 ( a - 2 { 2 } ) $.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ d = 1  } ^n ( - 1 ) ^{ \lfloor d \sqrt { r  } \rfloor  } \\
&amp; = n - 2 \sum _{ d = 1  } ^n \lfloor d \sqrt { r  } \rfloor + 4
\sum _{ d = 1  } ^n \lfloor \frac { \lfloor d \sqrt { r  } \rfloor  } {
2  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$f ( x ) = { 2 } <span class="math inline">\(,根据整值函数的性质,不难发现\)</span> { 2 } = { 2
} $.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
ans &amp; = n - 2 \sum _{ d = 1  } ^n \lfloor d \sqrt { r  } \rfloor + 4
\sum _{ d = 1  } ^n \lfloor \frac { d \sqrt { r  }  } { 2  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>记$t = <span class="math inline">\(,我们所要解决的问题是\)</span>_{ d
= 1 } ^n d { Q } <span class="math inline">\(.如果\)</span> { Q }
$,我们可以把整数部分取出来单独算.于是接下来我们只讨论$0 { Q } &lt; 1
$的情况.相当于求一条斜率小于$1
$的直线下方的整点个数.我们可以反转坐标系,这样就变成了斜率大于$1
$的直线,继续做上面的操作.</p>
<p>这个问题引出万能欧几里得算法.</p>
<h5><span id="example5loj6440万能欧几里得算法">Example5([loj6440]万能欧几里得算法)</span></h5>
<p>解决形如$_{ x = 1 } ^{ L } A ^x B ^{ { Q } } <span class="math inline">\(的问题,其中\)</span>A <span class="math inline">\(和\)</span>B <span class="math inline">\(都是\)</span>n n <span class="math inline">\(的矩阵.默认\)</span>P , Q , R $.</p>
<p>我们将问题抽象为下面的模型:</p>
<p>首先将坐标系中所有经过整数点的与坐标轴平行的直线全都标记出来.</p>
<p>考虑将问题转化为:有一条$y = { Q } <span class="math inline">\(的直线,我们从\)</span>( 0 , { Q } ) <span class="math inline">\((不包含这个点)处开始沿直线向右走.每遇到一条横线,就进行\)</span>U
_w <span class="math inline">\(操作;每遇到一条竖线,就进行\)</span>R _w
<span class="math inline">\(操作.如果遇到了整数格点,就先进行\)</span>U
_w <span class="math inline">\(操作,再进行\)</span>R _w $操作.</p>
<p>例如上面那个例子就是:现在有一个矩阵二元组$( X , Y ) <span class="math inline">\(,初始为\)</span>( A , B ^{ { Q } } ) <span class="math inline">\(,\)</span>R _w <span class="math inline">\(操作是:\)</span>( X , Y ) ( AX , Y + X ) <span class="math inline">\(,\)</span>U _w <span class="math inline">\(操作是:\)</span>( X , Y ) ( XB , Y ) <span class="math inline">\(.一直走到\)</span>x = L <span class="math inline">\(的点为止,最后矩阵\)</span>Y <span class="math inline">\(就是答案.不过这个形式不好写成矩阵,我们可以记录\)</span>(
A ^a , B ^b , Y ) $.这样最后就可以带入操作,不难发现这个操作是个环.</p>
<p>操作要满足可合并性,也就是我可以将$U _w R _w $变成一个操作进行.</p>
<p>接下来我们分情况讨论一下:</p>
<p>当$P Q <span class="math inline">\(时,注意到\)</span>y = { Q } = { Q
} x + { Q } <span class="math inline">\(,此时任意一个\)</span>R _w <span class="math inline">\(操作前必然有至少\)</span> { Q } <span class="math inline">\(个\)</span>U _w <span class="math inline">\(,我们令\)</span>R _w ’ = U _w ^{ { Q } } R _w
<span class="math inline">\(,不难发现:\)</span>solve ( P , Q , R , L , U
_w , R _w ) = solve ( P Q , Q , R , L , U _w , R _w ’ ) $.</p>
<p>当$P &lt; Q P <span class="math inline">\(时,我们想要让\)</span>P
<span class="math inline">\(与\)</span>Q <span class="math inline">\(互换,假设第\)</span>a <span class="math inline">\(个\)</span>R _w <span class="math inline">\(在第\)</span>b <span class="math inline">\(个\)</span>U _w <span class="math inline">\(之前,考虑这个\)</span>R _w <span class="math inline">\(前会有\)</span> { Q } - { Q } <span class="math inline">\(个\)</span>U _w <span class="math inline">\(,而对于后者,变换坐标系得到\)</span>x = { P } <span class="math inline">\(,由于遇到整点时,先\)</span>U _w <span class="math inline">\(再进行\)</span>R _w <span class="math inline">\(,也就是说,第\)</span>b <span class="math inline">\(个\)</span>U _w <span class="math inline">\(前会有\)</span> { P } <span class="math inline">\(个\)</span>R _w <span class="math inline">\((这个并没有忽略初始位置).我们考虑如何让这个数和上面的\)</span>
{ Q } <span class="math inline">\(的差分写成一样的形式.注意到\)</span>b
= 1 $需要特殊处理!</p>
<p>显然操作序列一共有$cntU = { Q } - { Q } <span class="math inline">\(,将二者对应一下,这里的答案就是\)</span>solve ( Q ,
P , ( Q - R - 1 ) P , cntU - 1 , R _w , U _w ) $.</p>
<p>然后是开头部分,开头部分一共有$ { P } <span class="math inline">\(个\)</span>R _w <span class="math inline">\(和一个\)</span>U _w $.</p>
<p>但是注意到末尾部分同样是不规整的,注意到末尾一共有$L - { P } <span class="math inline">\(个\)</span>R _w $,拼到末尾即可.</p>
<p>最后$P = 0 <span class="math inline">\(的时候直接返回\)</span>R _w ^{
L } $即可.</p>
<p>假设合并的复杂度是$c <span class="math inline">\(,注意到每层的复杂度是\)</span>O ( c ( { P } ) ) =
O ( c ( Q - P ) ) <span class="math inline">\(,但是每两层会抵消,因此复杂度\)</span>O ( C ( P + Q
) ) $.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构相关</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2>
<h3><span id="维度">维度</span></h3>
<h4><span id="b维正交范围">B维正交范围</span></h4>
<p>对于一个$B <span class="math inline">\(维的点\)</span>x <span class="math inline">\(,满足\)</span> i B , l _i x _i r _i <span class="math inline">\(,称所有这样的点组成的集合为一个\)</span>B
$维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果$l , r <span class="math inline">\(有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个\)</span>B
<span class="math inline">\(维正交范围有\)</span>k <span class="math inline">\(个有用限制,称它为\)</span>k - side $的.</p>
<p>例如,找到区间$[ l , r ] <span class="math inline">\(中\)</span>&lt; x
$的元素,这个矩形是$3 - side <span class="math inline">\(的.找到区间\)</span>[ 1 , l ] <span class="math inline">\(中\)</span>&lt; x $的元素,这个矩形是$2 - side
$的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3>
<h4><span id="矩阵乘法">矩阵乘法</span></h4>
<p>做$n n <span class="math inline">\(的矩阵乘法目前得到的最优秀复杂度也是\)</span>O ( n
^{ 2 . 373 } ) $.</p>
<p>另外可以归约:$01 <span class="math inline">\(矩阵和整数矩阵在去除\)</span>n
$后的复杂度相同.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5>
<p>考虑构造一棵树:他有$ <span class="math inline">\(个叉,每个叉上有\)</span> <span class="math inline">\(个点.我们将这些叉编号为\)</span>[ 1 , ] <span class="math inline">\(.然后我们考虑询问两个叉所组成的链的答案,设\)</span>f
_{ i , j } <span class="math inline">\(表示数字\)</span>j <span class="math inline">\(是否在\)</span>i <span class="math inline">\(的叉上出现过,不难发现它们合并的时候要对\)</span>f
$做或运算,$01 $矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5>
<p>考虑对序列和值域同时分块,考虑序列中第$L <span class="math inline">\(到第\)</span>R <span class="math inline">\(个块的答案,设为\)</span>f ( L , R ) <span class="math inline">\(,这两块间的答案设为\)</span>g ( L , R ) <span class="math inline">\(,显然\)</span>f ( L , R ) = f ( L + 1 , R ) + f (
L , R - 1 ) - f ( L + 1 , R - 1 ) + g ( L , R ) <span class="math inline">\(,而由于对值域分块,\)</span>g ( L , R ) = a b
$的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5>
<p>平面上有若干点,两个操作:每次将横坐标小于等于$A <span class="math inline">\(的点加上\)</span>v <span class="math inline">\(,或者查询纵坐标小于等于\)</span>B
$的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="分块">分块</span></h3>
<h5><span id="example1luogup8527ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</span></h5>
<p>首先将$a
$分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的$L
$的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为$B <span class="math inline">\(,暴力处理散块的复杂度是\)</span>O ( Bm ) <span class="math inline">\(,处理整块的复杂度是\)</span>O ( { B } ( m + n n )
) <span class="math inline">\(.取\)</span>B ^2 = { m } ( m + n n ) = 500
$最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了$B = 2048 $.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079riapq">Example2(luogu[Ynoi2079]
riapq)</span></h5>
<p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了$[ 1 , l - 1 ] <span class="math inline">\(对\)</span>[ l , r ] $的贡献.</p>
<p>先序列分块.然后$[ 1 , l - 1 ] <span class="math inline">\(中的整块对\)</span>[ l , r ] <span class="math inline">\(的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将\)</span>[
1 , l - 1 ] <span class="math inline">\(中的整块的树状数组进行一个\)</span>[ l , r ] <span class="math inline">\(的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到\)</span>O
( Bq n ) <span class="math inline">\(的时间复杂度和\)</span>O ( Bn )
$的空间复杂度.</p>
<p>问题在于$[ 1 , l - 1 ] <span class="math inline">\(中的散块咋办.首先\)</span>[ 1 , l - 1 ] <span class="math inline">\(中的散块对\)</span>[ l , r ] <span class="math inline">\(中的散块的贡献是好处理的,因为总共就\)</span>O ( {
B } ) <span class="math inline">\(个数字,直接全部存下来排序做归并就可以统计,时间复杂度\)</span>O
( Bq n ) $.</p>
<p>现在的问题在于$[ 1 , l - 1 ] <span class="math inline">\(中的散块对\)</span>[ l , r ] <span class="math inline">\(中的整块如何贡献.能不能把\)</span>[ l , r ] <span class="math inline">\(的信息统计在\)</span>[ 1 , l - 1 ] <span class="math inline">\(的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有\)</span>
{ B } <span class="math inline">\(个,整块一共有\)</span>B
$个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为$O ( n n ) $,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</span></h5>
<p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu6331">Example4(Walking Plan HDU
6331)</span></h5>
<p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度$O ( nq )
$.</p>
<h5><span id="example5p5063-ynoi2014置身天上之森">Example5(P5063 [Ynoi2014]
置身天上之森)</span></h5>
<p>考虑如果$n = 2 ^k <span class="math inline">\(,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的\)</span>a
$(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是$n $不一定是$2 ^k
$,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5>
<p>大概是对于每个块处理出它的值域范围:一开始是$[ 1 , n ] <span class="math inline">\(,然后每次操作都会将整个块分为两部分:\)</span>[ 1 ,
x ) <span class="math inline">\(和\)</span>[ x , maxn ] <span class="math inline">\(,讨论一下\)</span>maxn $和$2 x <span class="math inline">\(的大小,就可以用\)</span>( x , maxn - x ) <span class="math inline">\(的复杂度使得\)</span>maxn <span class="math inline">\(变成\)</span>maxn - x $,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3>
<h5><span id="example1luogup5047ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5>
<p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到$O ( n n ) $.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为$[ l , r ] <span class="math inline">\(对\)</span>r <span class="math inline">\(的贡献实际上就是\)</span>[ 1 , r ] <span class="math inline">\(对\)</span>r <span class="math inline">\(的贡献减去\)</span>[ 1 , l - 1 ] <span class="math inline">\(对\)</span>r $的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这$O ( n ) <span class="math inline">\(次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入\)</span>O
( n ) <span class="math inline">\(次但是需要查询\)</span>O ( n )
$次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了$O ( n ) <span class="math inline">\(,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到\)</span>O
( n ) $.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3>
<p>我们现在有一个需要维护的$n n $的平面,我们现在对其进行分块:</p>
<ol type="1">
<li><p>将平面分成$n ^{ { 2 } } <span class="math inline">\(个\)</span>n
^{ { 4 } } n ^{ { 4 } } <span class="math inline">\(的\)</span>A <span class="math inline">\(块,以\)</span>A $块为单位做二维前缀和.</p></li>
<li><p>每个$A <span class="math inline">\(块内部分成\)</span>n ^{ { 2 }
} <span class="math inline">\(个\)</span>n ^{ { 2 } } n ^{ { 2 } } <span class="math inline">\(的\)</span>B <span class="math inline">\(块,在\)</span>A <span class="math inline">\(块内部以\)</span>B $块为单位做二维前缀和.</p></li>
<li><p>将整个平面横着分别分成一个个$n n ^{ { 4 } } <span class="math inline">\(的\)</span>C <span class="math inline">\(块.(竖着也要分成一个个\)</span>n ^{ { 4 } } n
$的块,是类似的,略去)</p></li>
<li><p>每个$C <span class="math inline">\(块内部分成\)</span> <span class="math inline">\(个\)</span>n ^{ { 4 } } n ^{ { 2 } } <span class="math inline">\(个\)</span>D <span class="math inline">\(块,在\)</span>C <span class="math inline">\(块内部以\)</span>D $块为单位做二位前缀和.</p></li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度$O ( ) <span class="math inline">\(.同时注意到空间复杂度是\)</span>O ( n ) $的.</p>
<p>查询显然是分四种情况讨论:$A , B , D
$块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应$O
( 1 ) $个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个$l <span class="math inline">\(对应\)</span>O ( 1 ) <span class="math inline">\(个\)</span>r <span class="math inline">\(,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有\)</span>O
( ) <span class="math inline">\(个查询,记录一下即可.这样就做到了\)</span>O ( )
<span class="math inline">\(单点改,\)</span>O ( 1 ) $查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现$O ( 1 ) <span class="math inline">\(单点改,那这种情况下如何实现\)</span>O ( ) <span class="math inline">\(求和呢?首先还是可以\)</span>O ( )
$求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度$&lt; n ^{ { 2 }
} <span class="math inline">\(,我们就可以在每次查询的时候用\)</span>
<span class="math inline">\(的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以\)</span>O
( ) $求散块.</p>
<h5><span id="example1luogup7448-ynoi2007rdiq">Example1(luoguP7448 [Ynoi2007]
rdiq)</span></h5>
<p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和$a
_r <span class="math inline">\(颜色相同的点是\)</span>r ’ <span class="math inline">\(,则显然新增的逆序对只可能出现在\)</span>[ r ’ , r
] $中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从$n <span class="math inline">\(扫左端点,总共做\)</span>O ( n ) <span class="math inline">\(次单点修改,做\)</span>O ( n ) $次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为$( r ’ + 1 , a _r ) <span class="math inline">\(,右上角是\)</span>( r , ) $的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令$rev ( x )
= n - x + 1 <span class="math inline">\(.然后将所有点的纵坐标\)</span>rev <span class="math inline">\(掉,现在我们要查询的也就是左下角为\)</span>( r ’ +
1 , 1 ) <span class="math inline">\(,右上角是\)</span>( r , rev ( a _r )
) <span class="math inline">\(的矩阵,这玩意可以拆前缀和拆成形如左下角是\)</span>(
1 , 1 ) <span class="math inline">\(,右上角是\)</span>( i , rev ( a _i )
) <span class="math inline">\(的矩阵.也就是说我们的\)</span>O ( n )
<span class="math inline">\(次矩阵查询本质上只有\)</span>O ( n )
$种.</p>
<p>拆到这里发现其实到这一步$a <em>r <span class="math inline">\(和\)</span>a </em>{ r ’ }
$是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</span></h5>
<p>首先自然的想法是拿莫队扫掉$[ l _1 , r _1 ] $这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维$[ l _2 , r _2 ]
$扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点$(
a , a ) <span class="math inline">\(上加上一个相应的\)</span>b <span class="math inline">\(,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点\)</span>A
( x _1 , x _1 ) <span class="math inline">\(和\)</span>B ( x _2 , x _2 )
<span class="math inline">\(之间的\)</span>( x _1 , x _2 ) <span class="math inline">\(上加上一个\)</span>- b
$,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol type="1">
<li><p>莫队时查询一个点的前驱后继,这个操作就需要$O ( 1 ) $完成.</p></li>
<li><p>$n <span class="math inline">\(次单点修改,这个操作需要\)</span>O
( 1 ) $完成.</p></li>
<li><p>$n <span class="math inline">\(次矩阵求和,这个操作需要在小于\)</span>O ( )
$的时间完成.</p></li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为$O ( n )
$,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3>
<h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5>
<p>首先反应是扔到trie上然后异或就是打个tag,但是$+ 1
$很难处理,因为它形如在trie上找到所有长度连续为$1
$到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是$+ 1
$的话就相当于反转一条从根开始均为$1 $的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3>
<h4><span id="普通线段树">普通线段树</span></h4>
<h5><span id="example1luogup6780ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</span></h5>
<p>感觉这题比较厉害.</p>
<p>先扔做法:对$c <span class="math inline">\(分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求\)</span>$.而对于块间如何做呢?</p>
<p>我们设$suf _i <span class="math inline">\(为前一个块的后\)</span>i
<span class="math inline">\(个数之和,\)</span>pre _i <span class="math inline">\(为后一个块的前\)</span>i <span class="math inline">\(个数之和.注意到我们要求的就是\)</span>{ suf _i +
pre _j | i + j c } $.这个咋做呢?</p>
<p>你注意到这个$i + j c <span class="math inline">\(的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用\)</span>j
c - j + 1 <span class="math inline">\(的话,这个限制就转化为了\)</span>i
+ c - j + 1 c <span class="math inline">\(,也就是\)</span>i &lt; j
$,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对$c $分块?</p>
<p>一方面,题目中的$c <span class="math inline">\(是给定的.另一方面,我们注意到我们需要维护一个和\)</span>c
<span class="math inline">\(有关的东西,而如果没有\)</span>c <span class="math inline">\(,或者说\)</span>c = n <span class="math inline">\(的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了\)</span>c
= n <span class="math inline">\(的条件.考虑到这一点,对\)</span>c
$分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将$a
[ l - 1 ] <span class="math inline">\(和\)</span>a [ r + 1 ]
$都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个$maxn <span class="math inline">\(设成\)</span>- <span class="math inline">\(的.如果这两个东西设成等大的\)</span>-
$,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比$- <span class="math inline">\(还要小的数字,最底层的\)</span>maxn
$有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4>
<p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5>
<p>注意到每个点其实只需要找到$[ i - r _i , i - 1 ] <span class="math inline">\(和\)</span>[ i + 1 , i + r _i ] <span class="math inline">\(这两段的最大值,设为\)</span>x <span class="math inline">\(,则最后的答案就是\)</span>{ a _i + x } $.</p>
<p>思考这个过程,我们将$[ i - r _i , i - 1 ] <span class="math inline">\(和\)</span>[ i + 1 , i + r _i ] <span class="math inline">\(这两条线段以\)</span>a _i <span class="math inline">\(的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的\)</span>a
_i $的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4>
<h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5>
<p>考虑全局的和是$sum <span class="math inline">\(,则我们要在这些数中找到一个分界点,使得左边的和大于等于\)</span>sum
$,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定$a _i , b _i <span class="math inline">\(,选定至多\)</span>k
<span class="math inline">\(个位置使这里的值为\)</span>a _i - b _i <span class="math inline">\(,其它位置的值是\)</span>a _i
$,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的$mid
$,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出$<em>{ k = 1 } ^r { ( </em>{ i
= k + 1 } ^n { sum _{ i } } , - b <em>k + </em>{ i = 1 } ^k { sum _i } )
} <span class="math inline">\(.注意改掉一个位置后要把它的\)</span>b
$变成$0 $.</p>
<p>那么什么样的$b <span class="math inline">\(有可能是我们要选中的呢?显然可能被选中的\)</span>b
<span class="math inline">\(一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:\)</span><em>{
k = 1 } ^r { ( </em>{ i = k + 1 } ^n { sum <em>{ i } } , - </em>{ i = k
} ^n { b <em>i } + </em>{ i = 1 } ^k { sum _i } ) } <span class="math inline">\(,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的\)</span>$尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是:</p>
$$
<span class="math display">\[\begin{aligned}
\min _{ k = 1  } ^r \{ \max ( sufmax ( sum ) _{ k + 1  } , - sufmax ( b
) _k + premax ( sum ) _k \} \\
&amp; = \min _{ k = 1  } ^r \{ \max ( sufmax ( sum ) _{ k + 1  } , -
\max ( sufmax ( b ) _{ k + 1  } , b _k ) + premax ( sum ) _k \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的$k <span class="math inline">\(后面最大的\)</span>b <span class="math inline">\(,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响\)</span>sufmax
( b ) <span class="math inline">\(的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的\)</span>b
<span class="math inline">\(,这个\)</span>b
$必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4>
<h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4>
<h4><span id="吉司机线段树">吉司机线段树</span></h4>
<h4><span id="李超线段树">李超线段树</span></h4>
<h3><span id="珂朵莉树">珂朵莉树</span></h3>
<h5><span id="example1luogup8512ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</span></h5>
<p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3>
<h3><span id="kd-tree">KD-Tree</span></h3>
<p>处理$K <span class="math inline">\(维正交范围(给定\)</span>n <span class="math inline">\(个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度\)</span>O
( n ^{ 1 - { k } } + n ) <span class="math inline">\(.(单调修改复杂度只是\)</span>O ( n ) $)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4>
<p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4>
<p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> siz;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">ll d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=cur[mid];</span><br><span class="line">tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line"><span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3>
<h5><span id="example1cfgym101613factor-freetree">Example1([CFgym101613]Factor-free
tree)</span></h5>
<p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是$dep
_u <span class="math inline">\(,是可以被卡成\)</span>O ( n ^2 ) $的.</p>
<p>但我们考虑类似dsu on
tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5>
<p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为$[ l , r ] <span class="math inline">\(,这样会有:\)</span>[ l - 1 , i - 1 ]
$.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3>
<h5><span id="exampleloj3151">Example(loj3151)</span></h5>
<p>首先自然地,我们设$f _{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个测试点已经分成了\)</span>j <span class="math inline">\(段的方案数,然后做转移,复杂度\)</span>O ( T ^2 S )
$.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到$k
$最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把$[ l , r ] <span class="math inline">\(分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点\)</span>r
$,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3>
<p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5>
<p>维护一个序列支持把$x <span class="math inline">\(位置的值改为\)</span>y <span class="math inline">\(或查询一个区间中小于\)</span>y $的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</span></h5>
<p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开$100
$个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2>
<h3><span id="分开考虑">分开考虑</span></h3>
<h5><span id="example1p6105-ynoi2010y-fast-trie">Example1(P6105 [Ynoi2010]
y-fast trie)</span></h5>
<p>考虑只有两种可能:</p>
<ol type="1">
<li><p>$x + y &lt; C <span class="math inline">\(,取\)</span>x + y
$作为答案.</p></li>
<li><p>$x + y C <span class="math inline">\(,取\)</span>x + y - C
$作为答案.</p></li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在$[
0 , { 2 } )
$中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,$x + y &lt; C <span class="math inline">\(也就是\)</span>x &lt;
C - y <span class="math inline">\(,我们把第二个集合中的元素全部变成\)</span>C - y
<span class="math inline">\(后插入,只需最小化\)</span>C - x - y <span class="math inline">\(,这个只需要维护最大的\)</span>x <span class="math inline">\(和最小的\)</span>C - y $就行.</p>
<h3><span id="合并信息">合并信息</span></h3>
<p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</span></h5>
<p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5>
<p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用$O ( n )
$的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5>
<p>设$w _i <span class="math inline">\(为从上往下延伸到\)</span>i <span class="math inline">\(这个点后,还能多往下延伸多少,一开始\)</span>w <span class="math inline">\(都是\)</span>- 1 <span class="math inline">\(,每次操作会让\)</span>w + = 1
$.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3>
<h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5>
<p>自然的想法是考虑找到每个点前面第一个和它之和为$w <span class="math inline">\(的数字,但这样就炸了,因为每修改一个点可能要影响\)</span>O
( n ) $个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为$w <span class="math inline">\(的数字,而显然只有两个数互相匹配才可行.如果\)</span>i
&lt; j &lt; k , ( i , j ) , ( i , k ) <span class="math inline">\(分别配对,那么显然\)</span>( i , k ) <span class="math inline">\(没有用.这样每个点只有\)</span>O ( 1 )
$个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3>
<h5><span id="example1luogup5278算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</span></h5>
<p>首先考虑$k = 1
$怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p>$k <span class="math inline">\(怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在\)</span>k
<span class="math inline">\(意义下全部相等,维护差分数组的区间\)</span>$就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5>
<p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为$q <span class="math inline">\(的衣服,\)</span>[ 0 , q ) <span class="math inline">\(的人肯定买不了,\)</span>[ q , 2 q - 1 ] <span class="math inline">\(的人买完后,手上的钱至少减半,我们暴力处理,至于\)</span>[
2 q , + ) $,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5>
<p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到$0
$,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</span></h5>
<p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是$pre
[ i ] = i - 1 $).</p>
<h3><span id="根号分治">根号分治</span></h3>
<h5><span id="example1luogup7722-ynoi2007tmpq">Example1(luoguP7722 [Ynoi2007]
tmpq)</span></h5>
<p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改$a , b , c $中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个数字$x <span class="math inline">\(,每次随机在\)</span>[ 1 ,
x ] <span class="math inline">\(中一个数\)</span>y <span class="math inline">\(并令\)</span>x x y <span class="math inline">\(,初始值为\)</span>n $,求期望几次能变成$0 $.</p>
<p>注意到如果$y <span class="math inline">\(很小就直接做,\)</span>y
<span class="math inline">\(很大的话\)</span> { y }
$很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5>
<p>给定序列,每次询问给出两个数字$x , y <span class="math inline">\(,求最小的\)</span>| i - j | <span class="math inline">\(满足\)</span>a _i = x , a _j = y $.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果$x , y $出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5>
<p>首先对于$Y $很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于$Y <span class="math inline">\(很大的情况,\)</span> { Y } <span class="math inline">\(一定很小,我们不断查询大于等于\)</span>kY <span class="math inline">\(的最小元素即可,这个可以值域分块来根号平衡做到\)</span>O
( 1 ) <span class="math inline">\(查询,\)</span>O ( ) <span class="math inline">\(单点修改.具体地,我们对每个块处理出大于等于这个块的最小的\)</span>X
<span class="math inline">\(,以及块内每个点后面最小的\)</span>X <span class="math inline">\((必须在块内),然后定位到\)</span>kY $的块.</p>
<h5><span id="example6">Example6</span></h5>
<p>给定$n , m <span class="math inline">\(,以及序列\)</span>a <span class="math inline">\(和长度为\)</span>n <span class="math inline">\(的排列\)</span>y <span class="math inline">\(,你需要回答\)</span>m <span class="math inline">\(个询问.对每个询问,给定\)</span>l , r $,查询:</p>
<p><span class="math display">\[
\sum _{ i = 1  } ^n \sum _{ j = i + 1  } ^n [ a _i = a _j ] \prod _{ k =
i  } ^j [ l \leq y _k \leq r ]
\]</span></p>
<p>注意到$y _i = i
$的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点$( x , y ) , a _x = a _y , x &lt; z &lt; y ,
a _z = a _x <span class="math inline">\(,对于\)</span>( x , y )
$这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于$ <span class="math inline">\(的数字,它们最多只有\)</span> <span class="math inline">\(个,考虑莫队复杂度\)</span>O ( n + m ) <span class="math inline">\(,因此我们可以对每个分别做莫队,总复杂度\)</span>O (
n + m ) $,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于$ <span class="math inline">\(的数字,这些数字一共最多有\)</span>n <span class="math inline">\(个,每个点暴力配对就有\)</span>O ( n ) <span class="math inline">\(个点对,然后\)</span>O ( m ) <span class="math inline">\(次询问,用根号平衡做扫描线,这里复杂度\)</span>O ( n
+ m ) $.</p>
<h3><span id="重链分治">重链分治</span></h3>
<h5><span id="example1luogu5314ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</span></h5>
<p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为$1 <span class="math inline">\(,支持把一条链上所有点加上\)</span>k <span class="math inline">\(,或者查询距离一个点\)</span>&lt; = 1 <span class="math inline">\(的所有点的点权\)</span>kth <span class="math inline">\(.\)</span>n ^5 $.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改$O
( n ) $个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="一维扫描线">一维扫描线</span></h4>
<p>最经典的应用是对于一个$B <span class="math inline">\(维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个\)</span>B
- 1 <span class="math inline">\(维的动态问题.不过扫描线处理的时候可能需要是低\)</span>side
$的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4>
<p>也就是莫队.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1cf1609finteresting-sections">Example1(CF1609F
Interesting Sections)</span></h5>
<p>首先枚举每个数的$popcount
$,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点$x <span class="math inline">\(作为最大值的影响区间\)</span>[ l , r ] <span class="math inline">\(,也就是如果一个区间左端点在\)</span>[ l , x ]
<span class="math inline">\(,右端点在\)</span>[ x , r ] <span class="math inline">\(即可满足条件.我们考虑放入一个左下角坐标为\)</span>(
l , x ) <span class="math inline">\(,右上角坐标为\)</span>( x , r )
$的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5>
<p>离散化,设$S = { l } { r } <span class="math inline">\(,考虑用\)</span>len <em>i <span class="math inline">\(表示\)</span>i <span class="math inline">\(节点及以前最多能有多少阳光.我们考虑用\)</span>len
</em>{ i - 1 } <span class="math inline">\(更新\)</span>len <em>i <span class="math inline">\(,如果\)</span>[ i - 1 , i ] <span class="math inline">\(没被覆盖,显然直接加上这段的长度.如果\)</span>[ i -
1 , i ] <span class="math inline">\(被覆盖大于两次,那显然直接继承\)</span>len </em>{ i
- 1 } $.</p>
<p>先考虑$[ i - 1 , i ] <span class="math inline">\(被两朵云覆盖了怎么办,我们考虑用\)</span>h <em>{ j
, k } <span class="math inline">\(表示当前被且只被\)</span>j <span class="math inline">\(和\)</span>k <span class="math inline">\(共同覆盖的区间长度,不难发现\)</span>h </em>{ j , k
} <span class="math inline">\(有值的地方很少,用map.然后还要加上它们各自的贡献,用\)</span>g
_j <span class="math inline">\(表示当前被且只被\)</span>j <span class="math inline">\(覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断\)</span>[
i - 1 , i ] $是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果$[ i - 1 , i ] <span class="math inline">\(被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为\)</span>k
$,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是$g _j + g _k <span class="math inline">\(,用线段树处理出当前代价和小于等于\)</span>C <span class="math inline">\(的\)</span>k <span class="math inline">\(的\)</span>g _k $的最大值就行.</p>
<p>再考虑有交的情况,答案应该为$g _j + g <em>k + h </em>{ j , k } <span class="math inline">\(,我们在每次遇到\)</span>( j , k ) <span class="math inline">\(的时候都在对方那里打个tag就好,也就是对于每个\)</span>j
<span class="math inline">\(,处理出和它有交的云中\)</span>g _j + g <em>k
+ h </em>{ j , k }
$的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5>
<p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成$0
$后那些数一定没清空).</p>
<h5><span id="example4luogup7709wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5>
<p>如果初始序列全为$0 $:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5>
<p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5>
<p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是$L
&lt; R <span class="math inline">\(,自然有\)</span>L { r _i } , R { l _i
} <span class="math inline">\(,那么当我们确定\)</span>L <span class="math inline">\(后,我们有\)</span>R <span class="math inline">\(.接下来我们考虑如何计算\)</span>f ( L ) $.</p>
<p>注意到$L &lt; l _i R r _i <span class="math inline">\(,我们考虑将\)</span>l _i <span class="math inline">\(这个点的权值设成\)</span>r _i
$,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3>
<h4><span id="回滚莫队">回滚莫队</span></h4>
<h4><span id="带修莫队">带修莫队</span></h4>
<p>也就是维护三维的扫描线,根据KDT不难发现复杂度是$O ( nm ^{ { 3 } } )
<span class="math inline">\(,\)</span>B = n ^{ { 3 } } <span class="math inline">\(,排序原则是\)</span>( ls , rs , t )
$,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4>
<h4><span id="二次离线莫队">二次离线莫队</span></h4>
<p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个$n <span class="math inline">\(的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带\)</span>n
$的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有$n <span class="math inline">\(次询问,每次询问\)</span>f ( l , r , r + 1 ) <span class="math inline">\(表示区间\)</span>[ l , r ] <span class="math inline">\(对\)</span>r + 1 <span class="math inline">\(的逆序对贡献.考虑差分成\)</span>f ( 1 , r , r + 1
) - f ( 1 , l - 1 , r + 1 ) <span class="math inline">\(,前者显然可以迅速求出.而后者的右端点需要移动\)</span>n
<span class="math inline">\(次,需要查询总共\)</span>n $次,zhe’ge</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5>
<p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都$4
- side $了,但是有可减性,减成$2 - side $就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5>
<p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉$p = 2 <span class="math inline">\(和\)</span>p = 5 <span class="math inline">\(的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字\)</span>p
<span class="math inline">\(的值,设为\)</span>suf _i <span class="math inline">\(,假设存在两个点\)</span>l , r <span class="math inline">\(满足\)</span>p | ( suf <em>l - suf </em>{ r + 1 }
) <span class="math inline">\(,那么\)</span>[ l , r ] <span class="math inline">\(就是合法的,这是自然的,也就等价于\)</span>suf <em>l
= suf </em>{ r + 1 } <span class="math inline">\(,相当于要对满足\)</span>suf <em>l = suf </em>{ r +
1 } <span class="math inline">\(的二元组\)</span>( l , r )
$计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604美好的每一天">Example3(luoguP3604
美好的每一天)</span></h5>
<p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3>
<p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的$( l , r )
$的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5>
<p>考虑转化为二维平面,$a _{ l , r } = maxn - minn - ( r - l )
$,显然只需要找到为$0
$的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有$3 - side $的,但是可差分成$2 - side $.</p>
<h3><span id="时间倒流">时间倒流</span></h3>
<h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5>
<p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5>
<p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3>
<h5><span id="example1cf1540d-inverseinversions">Example1(CF1540D Inverse
Inversions)</span></h5>
<p>考虑对于一个数列怎么构造:假设只考虑前$k <span class="math inline">\(个数,它们的取值是\)</span>[ 1 , k ] <span class="math inline">\(,现在加入第\)</span>k + 1 <span class="math inline">\(个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都\)</span>+
1 $,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道$p _i <span class="math inline">\(是多少,根据上面的构造过程,首先将\)</span>p _i = a
_i <span class="math inline">\(,然后不断向后遍历,每遇到一个\)</span>a _j
<span class="math inline">\(,如果\)</span>a _j p _i <span class="math inline">\(,则把\)</span>p _i + = 1 $.</p>
<p>我们将数列分块,设块长为$B $,那一个值经过一个块的时候最多加块长个$1
<span class="math inline">\(.也就是经过整块的时候是一个\)</span>B
$段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是$
= B $的,</p>
<p>于是最后复杂度为$O ( T ( B + { B } n ) ) <span class="math inline">\(,取\)</span>B = $即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3>
<p>根号平衡主要用到下面四个东西:</p>
<ol type="1">
<li><p>$O ( 1 ) <span class="math inline">\(单点加,\)</span>O ( )
$区间和:维护块内的和即可.</p></li>
<li><p>$O ( ) <span class="math inline">\(单点加,\)</span>O ( 1 )
$区间和:维护块内和块间的前缀和即可.</p></li>
<li><p>$O ( ) <span class="math inline">\(区间加,\)</span>O ( 1 ) <span class="math inline">\(单点和:差分转化为\)</span>( 2 )
$.当然打标记也是可以的.</p></li>
<li><p>$O ( 1 ) <span class="math inline">\(区间加,\)</span>O ( ) <span class="math inline">\(单点和:差分转化为\)</span>( 1 )
$.当然打标记也是可以的.</p></li>
</ol>
<p>还有一些拓展的东西:</p>
<ol start="5" type="1">
<li><p>维护值域$O ( n ) <span class="math inline">\(的集合,支持\)</span>O ( 1 ) <span class="math inline">\(插入,\)</span>O ( ) <span class="math inline">\(查询第\)</span>k $小:值域分块就可以.</p></li>
<li><p>维护值域$O ( n ) <span class="math inline">\(的集合,支持\)</span>O ( ) <span class="math inline">\(插入,\)</span>O ( 1 ) <span class="math inline">\(查询第\)</span>k
$小:值域分块,然后暴力改变每个点所属的块就行.</p></li>
</ol>
<h4><span id="example">Example</span></h4>
<h5><span id="example1区间众数">Example1(区间众数)</span></h5>
<p>首先分块,处理出$f _{ l , r } <span class="math inline">\(表示块\)</span>[ l , r ] <span class="math inline">\(的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是\)</span>n
<span class="math inline">\(的,因此复杂度\)</span>O ( n ) $.</p>
<p>但是可以优化,我们设$mx <span class="math inline">\(表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于\)</span>mx
<span class="math inline">\(可以\)</span>O ( 1 ) <span class="math inline">\(判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然\)</span>mx
<span class="math inline">\(增加总次数也不会超过\)</span>O ( ) <span class="math inline">\(,因此做到\)</span>O ( n ) $.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-andchuru">Example2(CodeChef Chef and
Churu)</span></h5>
<p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个$O
( 1 ) <span class="math inline">\(查询区间和,\)</span>O ( )
$单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5>
<p>莫队,发现有$m <span class="math inline">\(次查询,\)</span>n
$次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5>
<p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有$O ( n ) $种,用值域分块就可以平衡复杂度.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>平邑一中集训作业</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="反悔贪心">反悔贪心</span></h3>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6940</p>
<p>首先发现,从上往下扫行,然后对于每个右下角匹配一个列最近的左上角是最优秀的.所以拿set维护上述过程.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3268</p>
<p>这题比较厉害,直接扫,然后维护每个圆当前与这条线的两个交点,注意到这些交点的顺序是固定的,于是可以拿set维护.</p>
<h3><span id="二分图hall定理">二分图HALL定理</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc076_d</p>
<p>根据Hall定理,我们只要找到一个子集的人,使得人数与它们的区间的并所包含的椅子数量之差最大,这个最大值就是答案.而它们区间的并显然是同样类型的区间,也就是中间扣去一段.考虑枚举中间扣去的那一段是啥,就可以快速算答案.这玩意可以扫描线维护.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF981F</p>
<p>一眼丁真,鉴定为二分+Hall定理.</p>
<p>这题真正的难点在于如何check.考虑我们现在有了若干个区间$[ l , r ]
<span class="math inline">\(,每个整数点上都有一个人.然后要check.那就必须满足\)</span>r
_j - l _i j - i <span class="math inline">\(,这意味着\)</span>r _j - j l
_i - i $,然后就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3488</p>
<p>比较简单,考虑如果最后找的若干个区间是分开的,那它们必然其中有一个区间自己就不合法.因此找到这个区间就行,然后每个位置减去$k
<span class="math inline">\(,用线段树维护区间小子段和判断加上\)</span>k
d $是否小于$0 $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>这题比较厉害啊.首先猜到要用网络流.</p>
<p>然后注意到选的集合$= <span class="math inline">\(选的数字等价于不选的集合\)</span>+ <span class="math inline">\(选的数字\)</span>= n
$.考虑最小割.先将边权全部取反,这样变成求最大权值,</p>
<p>然后集合连权值加上一个极大值$M <span class="math inline">\(,单点连极大值\)</span>M
$.这样割掉一个单点意味着选这个单点,割掉一个集合意味着不选这个集合.由于存在完美匹配,因此一定会跑出答案.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc106_e</p>
<p>首先答案显然不会超过$2 nk
$,考虑二分,这样每一天会有哪些人来就知道了.然后对着上面的信息做高维前缀和就可以知道对于一个人的集合,它会来哪些天.这样就可以check.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc037_d</p>
<p>考虑最后$C D <span class="math inline">\(显然需要把该放的位置归位,这样我们的\)</span>a
$里面存的完全可以是它应该在第几行这个信息.</p>
<p>再考虑$B C <span class="math inline">\(,显然只需要保证每列的\)</span>a
$互不相同,这一步就可以满足上面的要求.</p>
<p>于是,$A B <span class="math inline">\(只需要保证每列的\)</span>a
$互不相同.这个可以使用网络流实现.</p>
<p>那么,如何证明一定有解呢?这是一张正则二分图,根据Hall定理推论,一定存在完美匹配.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc029_f</p>
<p>这题好牛啊.发现如果几个集合的并的点数过少,那么一定无解.因为怎么连都会连出环来.这直接将整个题的思路引向Hall定理.</p>
<p>考虑直接做二分图匹配.左边是点右边是集合,然后连边.</p>
<p>那么根据Hall定理一定存在$n - 1 <span class="math inline">\(的匹配,并且恰好有一个点没被匹配到.我们干脆删掉这个点,最后再加回来.事实上理论上来说我删掉哪个点都应该存在完美匹配,我们先只删一个.然后从\)</span>r
$开始不断dfs找到一条遍历所有边的交错树,对着交错树构造就行.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1519F</p>
<p>首先注意到,只要任意一个宝箱集合需要的钥匙集合的权值大于等于自己,那Bob就输了.这类似Hall定理.我们把钥匙和宝箱都拆点,然后判断拆点后的图是否存在完美匹配.求完美匹配可以使用状压.</p>
<h3><span id="轮廓线dp">轮廓线dp</span></h3>
<p>这个板块好像没啥说的,因为思维难度远低于代码难度.而且思路都比较直接.</p>
<p>放一下我做的题.</p>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5056</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2289</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3886</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P1933</p>
<h3><span id="广义串并联图">广义串并联图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6790</p>
<p>比较简单,首先这个图这么简单,那它大概率是个广义串并联图.感性理解一下,$n
$的时候肯定是存在度数较小的边的,并且你在合并的过程中它也一直是仙人掌+至多一条边的形状.</p>
<p>然后简单做做.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P8426</p>
<p>ps:本题选入笔记:图论-广义串并联图/三度化-Example2.</p>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果$S <span class="math inline">\(和\)</span>T <span class="math inline">\(在一个点双中,我们找到两个点\)</span>u , v <span class="math inline">\(,使得\)</span>u v <span class="math inline">\(,并且\)</span>u $的出度至少是$2 <span class="math inline">\(,\)</span>v $的入度至少是$2
$,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为$2
<span class="math inline">\(的点\)</span>v <span class="math inline">\(,找到它的入点\)</span>u <span class="math inline">\(,如果\)</span>u $的出度不是$2 <span class="math inline">\(,那么\)</span>u $也是一个入度至少为$2 <span class="math inline">\(的点.这样往前推一定至少能推到一个点(因为不可能\)</span>S
$贡献了俩入度).</p>
<p>如何保证$S , T <span class="math inline">\(在一个点双中呢?其实只需要添加一条边\)</span>( S ,
T , dis _{ S T } ) <span class="math inline">\(就行了.显然加了后不会对答案产生影响.然后不在\)</span>S
, T $这个边双内的点也没有用了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://loj.ac/p/3076</p>
<p>这题没啥好说的,小E的集训队论文讲的很清楚.简单来说就是用三度化求出一棵决策树,然后做动态dp.</p>
<h3><span id="动态规划第一期">动态规划第一期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1810G</p>
<p>ps:本题选入笔记:动态规划-动态规划的优化-反向操作-Example1.</p>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k <span class="math inline">\(暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取\)</span><span class="math inline">\(操作很艰难.但如果!我把这个dp反过来,我设\)</span>f
_{ i , j } <span class="math inline">\(表示**从后往前**dp到\)</span>i
$,当前的最大前缀和是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i -
1  } \}  }
\]</span></p>
<p>最后在$f _{ 1 , j } <span class="math inline">\(处乘上\)</span>h _j
$.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g <em>{ i , j } <span class="math inline">\(表示如果初始只有\)</span>f </em>{ i , j } = 1
$,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g
_{ i , j  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>我认真考虑过这个$P <span class="math inline">\(应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些\)</span>P
$变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<p>回来简单提下容斥做法,其实是有一个自然的想法是只要这个序列中出现过前缀和为$x
<span class="math inline">\(的位置,我们就加上一个\)</span>h <em>x - h
</em>{ x - 1 }
$.然后我们要统计的是出现过的,因此用容斥把这个条件删了就行.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc061_c</p>
<p>这题纯容斥,首先考虑找到一种统计答案序列而非操作序列的方式:一般而言会选择建立某种双射.考虑一个答案序列可以怎么被操作到:或者说,对于一个答案序列,判断它能否操作到.</p>
<p>注意到序列中第一个元素,肯定是选择左端点比较合理.因为这样它对后面的限制要少一些.那么其实双射方式就呼之欲出了:就是从左往右扫,能取左端点就取左端点.我们就可以对这个操作序列进行计数.</p>
<p>这个操作序列怎么计数呢?考虑这个序列满足啥条件:其实就是能选左边的就不会选右边的,那也就是不可能出现一个空的区间,这个区间没有任何数字.对着这个条件容斥即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc134_e</p>
<p>这题见过两次了.大概是按部就班一点一点去找条件.</p>
<p>至于考试怎么办,考试打表啊!</p>
<p>下面抄一下演算纸上的结论,注意这些判定条件的优先级从前往后:</p>
<ol type="1">
<li><p>如果序列全$1 $,显然后手获胜.</p></li>
<li><p>如果序列不是全$1 <span class="math inline">\(并且存在奇数,选择\)</span>m = 2
$,先手获胜.</p></li>
<li><p>如果序列全$2 $,显然后手获胜.</p></li>
<li><p>如果序列全是偶数并且不全是$4 <span class="math inline">\(的倍数,取\)</span>m = 4
$转化为(3),先手获胜.</p></li>
<li><p>如果序列全是$4 <span class="math inline">\(的倍数,考虑取\)</span>m = 3 <span class="math inline">\(,如果序列中只有\)</span> = 1 <span class="math inline">\(或者只有\)</span> = 2 <span class="math inline">\(的数字,显然先手获胜.不然,如果同时存在,考虑先手取\)</span>m
= 12 <span class="math inline">\(,序列中就会只剩下\)</span>{ 4 , 8 }
$.此时如果后手取一个奇数,显然会剩下奇数,根据(2)先手获胜;如果后手取一个偶数,讨论一下全部的偶数,都是先手获胜.</p></li>
</ol>
<p>综上,除非所有的数字都是$12 <span class="math inline">\(的倍数,不然后手获胜当且仅当序列是\)</span>{ 1 } ,
{ 2 } , { 4 , 8 } $.</p>
<p>如果所有的数字都是$12 $的倍数,最多只有$16 $个,状压即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_abc290_h</p>
<p>显然对于猫来说,它的$d <span class="math inline">\((定义为左右狗的数量之差,对于狗同理)是一个从左到右先减少再增加的东西.因此一个\)</span>O
( n ^4 ) <span class="math inline">\(的dp是简单设计的,也就是\)</span>f
_{ i , j , k , l } <span class="math inline">\(表示目前用了\)</span>i
<span class="math inline">\(只猫,有\)</span>j <span class="math inline">\(只放在前面,\)</span>i - j $只放在后面,狗同理.</p>
<p>这个怎么优化呢?我们仔细思考,如果要放,是不是最好放的平均一点.因此引出一个结论:那就是一定存在一个分界点,使得左右猫的数量相同,狗的数量也相同.你可能会好奇$n
, m <span class="math inline">\(都是奇数怎么办,这种情况下会把中间的两个点当作分界点.如果\)</span>n
+ m $是奇数就找中间的那个点,不然就找中间的那个空格.</p>
<p>这个是怎么证明的呢?我们考虑对于猫来说,先找到能平分猫的分界点.然后考虑这个点左右两侧的狗的数量是否相同(这里先假设狗的数量是偶数,奇数是同理的,只是要多说几步).我们选择狗多的那一边,把这边最靠近分界线的那只狗恰好移过分界线.注意到这样一定更优秀.</p>
<p>那么上面的结论证明了啥呢?证明了整个序列一定可以分成两部分(左右两部分).这有什么用?这去掉了前两维.具体来讲,对于一部分,如果可以填某只猫或某只狗二者之一,一定选择权值较小的先填,这样的话这一对的贡献就会少一些.其实就是把权值转化为每个序列中每一对的贡献.于是这个结论就是对的,我们可以把猫狗放在一起排序来处理第一维.复杂度$O
( n ^3 ) $.</p>
<p>测完样例发现一个问题啊,上面那个结论还真不能简单地拓展到奇数.因为会出现权值相等的情况.对于偶数来讲,权值相等是无所谓的.但是奇数不行.因此我们选择如果$n
<span class="math inline">\(是奇数,就挑出最大的那只强行放在中间,\)</span>m
$同理.</p>
<p>但是,这题被爆标了.存在$O ( n n ) $的做法:</p>
<p>注意到,$d $总是一样的.因为这个猫前面的狗会因为它而贡献$1
$,然后这个猫和后面的狗也会贡献$1 <span class="math inline">\(.于是考虑从大到小开始放,优先放中间.然后先把狗堆一边,猫堆另一边,堆不动了再放对边,这样就是满足让\)</span>a
<span class="math inline">\(较大的\)</span>d $较小.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9338</p>
<p>首先能划分就一定需要是一个合法括号序列.同时这意味着一定可以划分出$N
$个合法的序列.</p>
<p>也就是说,我们其实只在乎这个序列最少能划分出多少,并且判断这个数字是否小于等于$K
$.那么如何求这个数字呢?</p>
<p>考虑第一个$B <span class="math inline">\(,它一定会和它左边的某个\)</span>A <span class="math inline">\(配对,不妨设它左边有\)</span>i <span class="math inline">\(个\)</span>A <span class="math inline">\(,那么最好的办法显然是这\)</span>i <span class="math inline">\(个\)</span>A <span class="math inline">\(和后面紧接着的\)</span>i <span class="math inline">\(个\)</span>B <span class="math inline">\(合并成一个序列.这是为什么呢?因为第一个\)</span>B
<span class="math inline">\(需要配对,因此它需要在一个序列中,把它删掉后后面的一个\)</span>B
<span class="math inline">\(也需要配对,而此时它前面的\)</span>A
$其实都是等价的,于是选择最早的那个,以此类推.</p>
<p>然后题解开始变魔术了.设$f [ x ] <span class="math inline">\(表示第\)</span>x <span class="math inline">\(个\)</span>B <span class="math inline">\(前有多少个\)</span>A <span class="math inline">\(,那我们做的实际上就是\)</span>x = 1 <span class="math inline">\(,然后不断做\)</span>x : = f [ x ] + 1 <span class="math inline">\(直到\)</span>x &gt; n
$.发现这样其实顺便把合法括号序列那个条件一起满足了,因为如果不合法一定会跳跳跳跳跳然后死循环.</p>
<p>那么我们的交换操作实际上是啥呢?首先不可能交换两个相同的,那实际上就是给一个$f
<span class="math inline">\(,实际上显然不可能给一个\)</span>f $减一.</p>
<p>但是这样会出现一个问题是,我们其实并不能选择任意一个$f <span class="math inline">\(进行更改.那怎么办呢?事实上,只要过程中满足\)</span>
&lt; i n , f <em>i f </em>{ i - 1 } <span class="math inline">\(,那我们的修改就一定可以实现.因为这等价于把后面的一个\)</span>A
<span class="math inline">\(挪前面去了.这样我们一开始进行操作使得整个序列满足\)</span>f
_i i $.</p>
<p>于是就有了一个$O ( n ^3 ) <span class="math inline">\(的dp,即设\)</span>dp _{ i , k } <span class="math inline">\(表示跳到\)</span>i <span class="math inline">\(跳了\)</span>k <span class="math inline">\(步的最小花费,每次跳到\)</span>j <span class="math inline">\(的话要求把\)</span>[ i , n ] <span class="math inline">\(上的所有\)</span>f <span class="math inline">\(对\)</span>j - 1 <span class="math inline">\(取\)</span>$.</p>
<p>仔细观察上面的过程,不难发现答案关于$k <span class="math inline">\(是凸的,用wqs二分去掉第二维,于是现在就有了一个\)</span>O
( n ^2 n ) $的一维dp.</p>
<p>不妨设$sum _x <span class="math inline">\(表示\)</span>f _i x <span class="math inline">\(的\)</span>f _i <span class="math inline">\(之和,\)</span>cnt _x <span class="math inline">\(表示这样的\)</span>f _i <span class="math inline">\(的个数,再设\)</span>pre _i <span class="math inline">\(为\)</span>f <span class="math inline">\(的前缀和.由于\)</span>f _i i $,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
dp _i &amp; = dp _j + \\
( i - 1 ) ( cnt _{ i - 1  } - j + 1 ) - sum _{ i - 1  } + pre _{ j -
1  } - val
\end{aligned}
\]</span></p>
<p>其中$val <span class="math inline">\(是wqs二分出来的惩罚量.然后如果能选前面的\)</span>i
$尽量选靠前的.再就是dp过程中需要记录跳了几步,但是不作为dp的维度而是内容.</p>
<p>显然可以斜率优化,于是复杂度$O ( n n ) $.</p>
<h4><span id="第六题">第六题</span></h4>
<p>考虑Hall定理,设最后的盒子是$x _1 , x _2 , , x _k
$,将它们<strong>从大到小</strong>排序,那么合法当且仅当:</p>
<ol type="1">
<li><p>$x = a $.</p></li>
<li><p>$k , _{ i = 1 } ^k x <em>i </em>{ i = 1 } ^n { k , a _i }
$.</p></li>
</ol>
<p>为啥是这个方向的Hall定理呢?因为我们肯定要对$x
$做一个背包的问题,这个时候肯定是对后面那一个已知的操作会比较好.</p>
<p>然后就直接dp.把$b <span class="math inline">\(从大到小排序,\)</span>f
_{ i , j , k } <span class="math inline">\(表示当前考虑前\)</span>i
<span class="math inline">\(个\)</span>b <span class="math inline">\(,选了\)</span>j <span class="math inline">\(个,和为\)</span>k <span class="math inline">\(是否可行,用bitset优化一下得到\)</span>O ( { w } )
$的算法.</p>
<p>但是实际上,考虑到$m <span class="math inline">\(其实是\)</span> <span class="math inline">\(级别的,再注意到dp的过程中,\)</span>j { b _i }
<span class="math inline">\(,因此\)</span>max _j = O ( S S ) <span class="math inline">\(,所以这个算法是\)</span>O ( { w } ) $的.</p>
<p>实现可以使用滚动数组.然后压位的话要压掉最后一维.</p>
<p>dp的话是下面这样的:</p>
<p><span class="math display">\[
\begin{gathered}
dp _{ i , j , k  } \rightarrow dp _{ i + 1 , j , k  } \\
dp _{ i , j , k  } \rightarrow dp _{ i , j + 1 , k + b _i  }
\end{gathered}
\]</span></p>
<p>算的时候记得删掉过大的$k $.</p>
<p>看到这种dp可能第一反应是考虑能不能交换dp状态和dp值,但是这个哪一维状态也不是和状态是单调的.</p>
<p>至于构造方案,暴力用堆一个一个做.</p>
<h3><span id="组合数学">组合数学</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_jsc2019_qual_f</p>
<p>比较牛.首先千万要看清楚不是每个点的值在$[ L , R ] <span class="math inline">\(之间而是和在\)</span>[ L , R ] $之间!</p>
<p>然后考虑后者怎么做.注意到如果是第$M <span class="math inline">\(大等于第\)</span>M + 1 <span class="math inline">\(大的话,中间那一段会是一段连续的,这个特别难搞.所以我们考虑求第\)</span>M
<span class="math inline">\(大不等于第\)</span>M + 1 <span class="math inline">\(大,这样前\)</span>M <span class="math inline">\(个和后\)</span>N - M
$个数字其实就分开了.而且因为前后没有相等的数字,我们很容易把它们乱序合并起来.</p>
<p>因此接下来的关键在于把前后分开,假设$a _M = x <span class="math inline">\(,那么前\)</span>M <span class="math inline">\(个数字大于等于\)</span>x <span class="math inline">\(,后\)</span>M <span class="math inline">\(个数字小于\)</span>x <span class="math inline">\(.不妨假设此时全局和为\)</span>s
$,那我们如何解决这个问题呢?</p>
<p>首先较大的那几个可以隔板法做,较小的那几个是个经典容斥:枚举有几个大于等于$x
<span class="math inline">\(的,这个数量不会超过\)</span> { x }
$,然后剩下的暴力隔板.</p>
<p>写式子之前考虑上面那个$s <span class="math inline">\(怎么办,总不能暴力枚举,其实写出来也可以用二项式技巧去掉,但是更重要的是,为啥你不转化成和在\)</span>[
0 , R ] <span class="math inline">\(的答案减去和在\)</span>[ 0 , L - 1 ]
$的答案呢?这下做完了.</p>
<p>于是我们只考虑限制是$[ 0 , R ] $.</p>
<p>这个时候我还在想要把左右两边分开求答案然后卷起来,但是这样还是避免不了枚举一边的和.事实上,我们可以把二者放在一起做容斥.下面式子会给出一个显式的表达.另外就是,有一个很大的问题在于我们如何钦定$a
<em>M = x <span class="math inline">\(,这一点其实是难以做到的.但我们可以钦定\)</span>a
<em>M x , a </em>{ M + 1 } &lt; x <span class="math inline">\(,然后再减去\)</span>a <em>M x + 1 , a </em>{ M + 1
} &lt; x <span class="math inline">\(.为了方便,我们不妨设\)</span>a
<em>M x , a </em>{ M + 1 } y <span class="math inline">\(的答案是\)</span>f ( x , y ) <span class="math inline">\(,然后我们要求的就是\)</span></em>{ x } f ( x , x -
1 ) - f ( x + 1 , x - 1 ) $.</p>
<p>接下来写一下$f ( x , y ) $的式子:</p>
<p><span class="math display">\[
f ( x , y ) = \sum _{ i = 0  } \binom { N - M  } { i  } ( - 1 ) ^i
\binom { R - Mx - i ( y + 1 ) + N  } { N  }
\]</span></p>
<p>乍一看不太能算,实际上注意到$R - Mx - i ( y + 1 ) <span class="math inline">\(,由于\)</span>x , y <span class="math inline">\(同级别,这意味着\)</span>i <span class="math inline">\(大致是\)</span> { x }
$级别的.于是就是一个调和级数复杂度.</p>
<h4><span id="第二题第三题">第二题/第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1264D2</p>
<p>直接做的hard version.</p>
<p>首先我们发现,不妨我们最后取出来的串一定是个$( ( ( ) ) ) <span class="math inline">\(这样的结构.再进一步,我们找到这个结构在原串上的分界点,设其左侧有\)</span>s
_l <span class="math inline">\(个\)</span>( <span class="math inline">\(,右侧有\)</span>s _r <span class="math inline">\(个\)</span>) <span class="math inline">\(,那么这个串的长度一定形如\)</span>{ s _l , s _r }
<span class="math inline">\(,由于随着分界点的右移,\)</span>s _l <span class="math inline">\(增大,\)</span>s _r
$减小,因此一定是它俩相等的时候最优秀.</p>
<p>于是我们考虑枚举分界点,对于每个分界点枚举答案.不妨设左侧有$a _l <span class="math inline">\(个问号,总共有\)</span>a $个问问号,答案显然是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k  } k \binom { a _l  } { k - s _l  } \binom { a - a _l  } { k -
s _r  } \\
&amp; = \sum _{ k  } ( k - s _l ) \binom { a _l  } { k - s _l  } \binom
{ a - a _l  } { k - s _r  } + \sum _{ k  } s _l \binom { a _l  } { k - s
_l  } \binom { a - a _l  } { k - s _r  } \\
&amp; = a _l \sum _{ k  } \binom { a _l - 1  } { k - s _l - 1  } \binom
{ a - a _l  } { k - s _r  } + s _l \sum _{ k  } \binom { a _l  } { k - s
_l  } \binom { a - a _l  } { k - s _r  } \\
&amp; = a _l \sum _{ k  } \binom { a _l - 1  } { a _l - k + s _l  }
\binom { a - a _l  } { k - s _r  } + s _l \sum _{ k  } \binom { a _l  }
{ a _l - k + s _l  } \binom { a - a _l  } { k - s _r  } \\
&amp; = a _l \binom { a - 1  } { a _l + s _l - s _r  } + s _l \binom {
a  } { a _l + s _l - s _r  }
\end{aligned}
\]</span></p>
<p>不过这里有个问题啊,那就是$a = 0 <span class="math inline">\(怎么办,扩域的二项式我其实是不太会算的.于是我特判了\)</span>a
= 0 $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc146_e</p>
<p>由于相同值域相互间有限制,不妨考虑值域那一维扫一下.</p>
<p>进一步地,我们考虑维护若干个上升的直线,然后每次可以选择把两条直线并起来成为一个峰,或者凭空分裂出两条直线作为一个谷.维护直线数量并且从下往上扫就可以了.</p>
<p>但是你注意一个问题,我们是不能先分裂出两条直线,再把它俩合并起来的.考虑能不能设计一点自适应的东西.当前的直线数量一定是偶数,然后我们每隔一个判断是否要合并,或者直接在一半的空位置上判断是否要分裂就行.更具体地,我们设$f
_{ i , j } <span class="math inline">\(表示当前有\)</span>j <span class="math inline">\(个位置能放\)</span>i <span class="math inline">\(的答案.显然\)</span>j = b _i
$,所以这一维看上去是没用的.</p>
<p>但是我们仔细想一想,我们要维护若干条折线.这些折线是有左右端点的,我们需要做的就是要么加入一条折线,要么合并两条折线,这两个操作都会带来一个空位置.而一条不操作的折线会带来两个空位置.其实相当于每个操作减少了一个空位置.不过有一个问题啊,我们只能通过$b
_i
$得知有多少个空位置,却不知道有多少条折线.事实上空位置数量=折线端点数量+操作次数.也就是说,和dp关系比较大的是折线数量,但我们只能推测出空位置数量.这下这下了.</p>
<p>但是但是但是,我们写一个$O ( n ^2 ) <span class="math inline">\(的dp,\)</span>f <em>{ i , j , 0 / 1 , 0 / 1 }
<span class="math inline">\(表示当前做到\)</span>i <span class="math inline">\(,有\)</span>j <span class="math inline">\(条折线,左端点是否已经选定,右端点是否已经选定.为啥要记录后两维呢?因为这不是环,这是一个排列,最左侧端点和最右侧端点是有可能直接停步的.因此我们还得讨论这个.说实话有点麻烦,所以我们先忽略左右端点,假设它们一直延伸.不妨设\)</span>k
= cnt </em>{ merge } - cnt <em>{ split } <span class="math inline">\(,自然有\)</span>k = 2 j - b <em>i <span class="math inline">\(.不放在设\)</span>w = cnt </em>{ split } , cnt
</em>{ merge } = k + w <span class="math inline">\(,再设\)</span>F ( n ,
m ) <span class="math inline">\(为将\)</span>n <span class="math inline">\(个无编号球放到\)</span>m <span class="math inline">\(个有编号盒子(盒子可空)的方案数,不难发现\)</span>F
( n , m ) = { m - 1 } $.那我们有:</p>
$$
<span class="math display">\[\begin{gathered}
f _{ i - 1 , j  } \sum _{ w \geq 0  } \binom { j - 1  } { k + w  } F ( w
, j - w - k + 1 ) \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \sum _{ w  } \binom { j - 1  } { k + w  } \binom { j -
k  } { j - w - k  } \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \binom { 2 j - k - 1  } { j  } \rightarrow f _{ i , j
- k  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>用范德蒙德卷积的时候一定要注意,这个东西是扩域后的二项式,因此一定要在意一下枚举量是否取遍整数,这里是发现如果$w
&lt; 0 $,那么后面那个组合数一定是$0 $.</p>
<p>原本其实很怕这个转移,因为觉得很麻烦,但其实写出来就不麻烦了.甚至加两维也是好做的,我们不妨设后两维的和为$t
$,就是几个端点是挂的,我们仍然有:</p>
<p><span class="math display">\[
\begin{aligned}
b _i &amp; = 2 ( j - k ) + cnt _{ merge  } - cnt _{ split  } - t +
\Delta t \\
k &amp; = 2 j - t + \Delta t - b _i
\end{aligned}
\]</span></p>
<p>其中$t <span class="math inline">\(是决定在这里停步的端点数量,\)</span>t <span class="math inline">\(是停步后的端点数量,\)</span>j - k <span class="math inline">\(是做完选择后,在\)</span>i <span class="math inline">\(处的折线数量,两个\)</span>cnt
$都是在做选择的<strong>过程中</strong>所做的merge和split的抉择数量.这样我们就完成了转移.</p>
<p>没完没完,差点就寄了.如果左右端点没有确认,那么我们是可以在左边或者右边split的.令$t
’ = t - t $,于是重推一下式子:</p>
$$
<span class="math display">\[\begin{gathered}
f _{ i - 1 , j  } \sum _{ w \geq 0  } \binom { j - 1  } { k + w  } F ( w
, j - w - k + 1 - t &#39; ) \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \sum _{ w  } \binom { j - 1  } { k + w  } \binom { j -
k - t &#39;  } { j - w - k - t &#39;  } \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \binom { 2 j - k - 1 - t &#39;  } { j - t &#39;  }
\rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \binom { b _i - 1  } { j - t &#39;  } \rightarrow f _{
i , j - k  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这一步步是怎么加上去的呢?实际上是按照先merge,再slipt,再stop来做的.因为split一定要放在最后,防止split了一个stop的点或者split在了一个merge好了的区间中.</p>
<p>但是这个转移是$O ( n b ) <span class="math inline">\(的,咋办呢?我们本着先冷静再冷静始终冷静的想法,去考虑一下\)</span>j
<span class="math inline">\(的取值:不难发现在上面的操作过程中,基本都是一个\)</span>j
<span class="math inline">\(对应一个\)</span>j - k <span class="math inline">\(,只有在\)</span>t <span class="math inline">\(变化的时候才会增加一个状态,这意味着\)</span>O (
cnt _t ) = O ( cnt _j ) <span class="math inline">\(,因此总空间是\)</span>O ( n ) <span class="math inline">\(的,于是时间也是\)</span>O ( n ) <span class="math inline">\(的,拿map维护一下这个dp就行,时间退化至\)</span>O (
n n ) $.</p>
<p>再有一个细节就是组合数怎么办,哦,$b $这么小,那没事了.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P6276</p>
<p>首先显然不会破坏环的形态.也就是说,你把所有置换环的长度求出来然后求lcm就是一个排列的阶.这直接启发我们对于每个质数分开求贡献.</p>
<p>更进一步地,我们发现只要排列中有$p ^k <span class="math inline">\(的倍数,我们就直接贡献一个\)</span>p <span class="math inline">\(作为答案.因此我们枚举\)</span>q = p ^k <span class="math inline">\(并统计有多少个排列至少有长度为\)</span>q <span class="math inline">\(的倍数的环.这都至少了,直接容斥就行,我们设当前有\)</span>i
$个点,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ i  } &amp; = \sum _{ q | k  } - f _{ i - k , j - 1  } \binom { i -
1  } { k - 1  } ( k - 1 ) ! \\
&amp; = \sum _{ q | k  } - { ( i - 1 )  } ^{ \underline { k - 1  }  } f
_{ i - k , j - 1  }
\end{aligned}
\]</span></p>
<p>$_{ q | i } - f _i ( n - i ) ! { i } <span class="math inline">\(就是答案.这样复杂度是\)</span>O ( ( { q } ) ^2 ) =
O ( n ^2 ) <span class="math inline">\(,事实上要更少,因为你发现我们只会对某个\)</span>q =
p ^k $做这个东西.</p>
<p>另外由于模数不确定,我们还要对着每个$i $预处理下降幂,有点难蚌的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc060_d</p>
<p>ps:本题选入笔记:常见套路-组合意义-Example3.</p>
<p>这题听了三遍,直接抄笔记.</p>
<p>不妨设$C _p = { i | p <em>i &gt; p </em>{ i + 1 } , 1 i &lt; n }
$.</p>
<p>用一下组合意义,注意到答案等于:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2
\]</span></p>
<p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2 = \sum _{ S  } ( \sum _{ S
\subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C
_p ] ) ^2
\]</span></p>
<p>这个咋做呢?我们考虑用组合意义展开:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | -
| S |  } [ T \subseteq C _p ] ) ^2 \\
&amp; = \sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T
_1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [
T _2 \subseteq C _p ] )
\end{aligned}
\]</span></p>
<p>注意到$S $屁用没有,直接交换枚举顺序.</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + |
T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2
\subseteq C _p ] ) \\
&amp; = \sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T
_1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [
T _2 \subseteq C _p ] )
\end{aligned}
\]</span></p>
<p>考虑$( _{ p } [ T _1 C _p ] ) <span class="math inline">\(怎么求,注意到这等价于所有\)</span>T _1 <span class="math inline">\(中的位置全都被钦定为\)</span>&gt; <span class="math inline">\(,而其他位置任意,如果我们设所有以大于号连接的部分的长度为\)</span>l
_1 , l _2 , . . . , l <em>k <span class="math inline">\(,那么这里的答案就是\)</span>n ! </em>{ i = 1 } ^k
{ l _i ! } $.</p>
<p>但我们很快发现了难点:$2 ^{ | T _1 T _2 | }
$这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在$T _1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(中都是\)</span>&gt; <span class="math inline">\(的位置,这个好像不太好求,因为\)</span>&gt;
$是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | +
| T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2
\subseteq C _p ] ) \\
&amp; = \sum _{ T _1 , T _2  } 2 ^{ ( ( n - 1 ) - | T _1 \cup T _2 | ) -
( n - 1 )  } ( - 2 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1
\subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
&amp; = 2 ^{ 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1
|  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 )
^{ | T _2 |  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - |
T _1 \cup T _2 |  }
\end{aligned}
\]</span></p>
<p>其中$n - 1 - | T _1 T _2 | <span class="math inline">\(意味着均不在\)</span>T _1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(中的位置的数量.为了给每一段连续的\)</span>&gt;
$都分配权值,我们进行一个细小的修改:</p>
<p><span class="math display">\[
2 ^{ - 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 | + 1  }
\frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ |
T _2 | + 1  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T
_1 \cup T _2 |  }
\]</span></p>
<p>写到这里应该就能发现,接下来必然要对$n - 1 - | T _1 T _2 | <span class="math inline">\(做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对\)</span>T
_1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了\)</span>&gt;
$,我们自然有:</p>
$$
<span class="math display">\[\begin{gathered}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T
_1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  }
( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{
2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时$| T _1 T _2 |
<span class="math inline">\(这个限制就显得尤其强,如果只是\)</span>S T _1
, T _2 <span class="math inline">\(就会好做很多:我们可以钦定\)</span>S
$作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
$$
<span class="math display">\[\begin{aligned}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T
_1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  }
( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{
2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\
&amp; = 2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } \sum _{ S \subseteq T
_1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } {
\prod l _{ 1 , i  } !  } ) \sum _{ S \subseteq T _2  } ( \frac { 1  } {
( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>令$f ( T ) = <em>{ S T } ( { ( - 2 ) ^{ | T | + 1 } } { l </em>{ 2 ,
i } ! } ) \ $,则原式即:</p>
<p><span class="math display">\[
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } ( \sum _{ S \subseteq T  } f ( T )
) ^2
\]</span></p>
<p>考虑下面这个东西怎么求:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2
\]</span></p>
<p>注意到,如果我们把每一段($[ T <em>i , T </em>{ i + 1 } ) <span class="math inline">\()的贡献求和,那么\)</span>f ( T ) <span class="math inline">\(相当于这些和乘起来,那么\)</span>( <em>{ S T } f (
T ) ) ^2 <span class="math inline">\(就是这些和的平方乘起来.换句话说,我们自然有\)</span>ans
<em>n = </em>{ m } ans </em>{ n - m } g ^2 _{ m } <span class="math inline">\(,其中\)</span>g <em>m <span class="math inline">\(表示长度为\)</span>m <span class="math inline">\(的一段的贡献之和.而\)</span>g </em>{ n } = <em>m g
</em>{ n - m } { - 2 m ! } <span class="math inline">\(.二者都可以使用分治FFT或多项式求逆解决.更进一步地,\)</span>h
_i = { - 2 i ! } , G = { 1 - H } , F = { 1 - G } $.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将$( &gt; , &gt; ) $容斥掉,这样我们有若干种对:$2 ( &lt;
, &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e ) <span class="math inline">\(,然后我们发现两个序列联系得太紧了,我们考虑分配系数:\)</span>&lt;
<span class="math inline">\(,\)</span>e - { } <span class="math inline">\(,但是这样发现\)</span>( e , e )
$算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1188E</p>
<p>首先发现肯定不可能所有颜色都点过,那么至少有一个颜色没点过.</p>
<p>然后呢?考虑操作序列和答案序列是否一一对应,事实上确实是这样,因为至少有一个颜色没点过,因此可以找到下降最多的那个颜色,这样就知道了总共操作过程.然后由每个颜色减少的次数,就可以知道每种颜色操作的次数.接下来就只需要对于每种操作次数判断是否能在全程非负的前提下做完.</p>
<p>一个显然的必要条件是,不妨设$l _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(种颜色操作次数,\)</span>a _i + l _i k l <span class="math inline">\(.但是操作过程中有可能有负数,这个怎么办呢?注意到为了让\)</span>a
<span class="math inline">\(不变负数,我们必须要让它在\)</span>a _i + 1
<span class="math inline">\(时刻前完成至少一次操作,在\)</span>a _i + k +
1 $时刻前完成至少两次操作……</p>
<p>注意到只需要满足第一个条件就行,因为后面的条件只需要把当前所有需要做的人排个序,挨个做.显然就一定会满足条件.根据Hall定理,从前往后判断每一时刻是不是能填满前面的每个人,并将它和$a
<span class="math inline">\(取\)</span><span class="math inline">\(得到\)</span>maxt <span class="math inline">\(,这就是\)</span>l <span class="math inline">\(的最大值.不难发现只要\)</span>l maxt <span class="math inline">\(就一定有解.枚举\)</span>t <span class="math inline">\(计算每个\)</span>a <span class="math inline">\(需要的次数,剩下的次数随意分配,注意要保证\)</span>l
= 0 <span class="math inline">\(,要减去\)</span>l $的情况.</p>
<p>事实上啊,只要我们得知了前一个要求条件然后枚举$t
$就行,时刻维护着复杂度就对,根本不用管后面的东西.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1595</p>
<p>弱智题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://darkbzoj.cc/problem/4665</p>
<p>直接容斥,用dp出前$i <span class="math inline">\(个人,钦定\)</span>j
$个人拿到了自己的糖果的方案数.然后容斥起来就行.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4859</p>
<p>ps:本题选入笔记:容斥与反演-容斥-Example3.</p>
<p>首先可以用dp+双指针得到$f _i <span class="math inline">\(表示勒令\)</span>i <span class="math inline">\(对满足条件的方案数.把\)</span>k <span class="math inline">\(的定义改为恰好\)</span>k
$对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a <span class="math inline">\(对的方案会被恰好\)</span>b <span class="math inline">\(对的方案计算\)</span> { a } <span class="math inline">\(次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为\)</span>k
$的方案贡献为$1 <span class="math inline">\(,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为\)</span>k
+ 1 $的方案贡献为$0 <span class="math inline">\(,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令\)</span>ans
= f <em>k <span class="math inline">\(,第二步除去其中被多算的\)</span>k
+ 1 <span class="math inline">\(,这一步令\)</span>ans - = { k } f </em>{
k + 1 } <span class="math inline">\(.这个时候,我们再考虑\)</span>k + 2
<span class="math inline">\(的贡献:它将在\)</span>f <em>k <span class="math inline">\(时贡献\)</span> { k } <span class="math inline">\(次,在\)</span>f </em>{ k + 1 } <span class="math inline">\(时贡献\)</span>- { k + 1 } { k } = - { k } { 1 }
<span class="math inline">\(次,那它现在的贡献还有:\)</span>- { k } <span class="math inline">\(次.以此类推,可以得到\)</span>ans = _{ i = k } ^n f
_i ( - 1 ) ^{ i - k } { k } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P
_i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i <span class="math inline">\(,因为只有这个时候,我们才能通过分析满不满足\)</span>P
_i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1
/ 0 $就行.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://darkbzoj.cc/problem/2839</p>
<p>简单二项式反演.(埋下伏笔)</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://codeforces.com/gym/101933/problem/K</p>
<p>考虑如果用小于等于$k <span class="math inline">\(种是好计算的(设为\)</span>f _k <span class="math inline">\(),显然\)</span>f _k = k ( k - 1 ) ^{ n - 1 }
$,对着做二项式反演.</p>
<p>一开始想直接拿$f <em>k - f </em>{ k - 1 }
$,实际上不行,因为颜色之间是有区别的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6478</p>
<p>这个题面真你妈逆天.</p>
<p>发现我们要求恰好$k <span class="math inline">\(个,自然的想法是想到钦定\)</span>k <span class="math inline">\(个,不妨假设钦定\)</span>k <span class="math inline">\(个的答案是\)</span>f _k $,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } ans _i \\
ans _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } ( - 1 ) ^{ i -
k  } f _i
\end{aligned}
\]</span></p>
<p>至于$f <span class="math inline">\(怎么求,你直接dp,设\)</span>dp _{ i
, j } <span class="math inline">\(表示当前在\)</span>i <span class="math inline">\(,子树内部选了\)</span>j <span class="math inline">\(对祖先后代,那我们就知道目前子树内还有多少可以和\)</span>i
$配对.合并是个树形背包.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1228E</p>
<p>ps:本题选入笔记:容斥与反演-反演-二项式反演-Example3.</p>
<p>不妨设至多有$i <span class="math inline">\(行\)</span>j $列最小值为$1
<span class="math inline">\(的答案是\)</span>f <em>{ i , j } <span class="math inline">\(,恰好有\)</span>i <span class="math inline">\(行\)</span>j $列最小值为$1 <span class="math inline">\(的答案是\)</span>g </em>{ i , j } $,注意到:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>令$h <em>{ n , m } = </em>{ j = 0 } ^m { j } g <em>{ n , j } \ <span class="math inline">\(,则\)</span>f </em>{ n , m } = <em>{ i = 0 } ^n {
i } h </em>{ i , m } \ <span class="math inline">\(,而\)</span>f _{ n ,
m } = k ^{ nm } ( k - 1 ) ^{ NM - nm } <span class="math inline">\(.做两次二项式反演得到\)</span>g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f
_{ n , m } { n } { m } k ^{ nm } ( k - 1 ) ^{ NM - nm }
$呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  }
g _{ s , t  } \\
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } &amp; = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ S , T  } &amp; = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S |
| T |  } \\
h _{ S , T  } &amp; = \sum _{ s \subseteq S  } ( - 1 ) ^{ | s | - | S
|  } f _{ s , T  } \\
g _{ S , T  } &amp; = \sum _{ t \subseteq T  } ( - 1 ) ^{ | t | - | T
|  } h _{ S , t  }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g <em>{ n , m } <span class="math inline">\(本身就包含了所有\)</span>| S | = n , | T | = m
<span class="math inline">\(的情况的和,并且在组合数\)</span> { j } <span class="math inline">\(那里就找到了唯一确定的\)</span>f </em>{ s , t }
<span class="math inline">\(,因此\)</span>f _{ n , m } <span class="math inline">\(是唯一确定的.这意味着这里\)</span>f <span class="math inline">\(的\)</span>n , m
$并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } f _i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个问题其实非常显然,我们的$g _{ i , j } <span class="math inline">\(定义为所有\)</span>| S | = i , | T | = j <span class="math inline">\(的答案之和.\)</span>f
$也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{
j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M } <span class="math inline">\(,那此时\)</span>g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,$g <span class="math inline">\(是已知的集合,\)</span>f <span class="math inline">\(是未知的集合.我们乘上组合数就可以得到对于\)</span>f
$来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f <span class="math inline">\(的定义改成\)</span>f _{ n , m } = k ^{ nm } ( k -
1 ) ^{ NM - nm } $就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知$n <span class="math inline">\(行\)</span>m <span class="math inline">\(列的集合的前提下,从中选出\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列并求\)</span>g <span class="math inline">\(.那么你从哪知道的\)</span>n <span class="math inline">\(行\)</span>m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } \sum _{
i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } {
j  } g _{ i , j  } \\
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } k ^{
nm  } ( k - 1 ) ^{ NM - nm  }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ’ <em>{ i ,
j } <span class="math inline">\(为至少有\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列不满足条件的方案数,自然有\)</span>f ’ </em>{ i ,
j } = f _{ N - i , M - j } $.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39; _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j
= m  } ^M \binom { j  } { m  } g &#39; _{ i , j  }
\]</span></p>
<p>最后答案就是$g ’ _{ 0 , 0 } $.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF997C</p>
<p>和上一题差不多,不妨设$g <em>{ n , m } <span class="math inline">\(表示恰好有\)</span>n <span class="math inline">\(行\)</span>m <span class="math inline">\(列同色的答案,\)</span>f </em>{ i , j } <span class="math inline">\(为钦定\)</span>i <span class="math inline">\(行\)</span>j $列同色的答案,自然有:</p>
<p><span class="math display">\[
g _{ n , m  } = \sum _{ i = n  } ^N ( - 1 ) ^{ i - n  } \binom { N  } {
i  } \binom { i  } { n  } \sum _{ j = m  } ^N ( - 1 ) ^{ j - m  } \binom
{ N  } { j  } \binom { j  } { m  } f _{ i , j  }
\]</span></p>
<p>可以求出$g _{ 0 , 0 } $然后再拿全集减一下.</p>
<p>我们求一下$g _{ 0 , 0 } $:</p>
<p><span class="math display">\[
g _{ 0 , 0  } = \sum _{ i = 0  } ^N ( - 1 ) ^{ i  } \binom { N  } { i  }
\sum _{ j = 0  } ^N ( - 1 ) ^{ j  } \binom { N  } { j  } f _{ i , j  }
\]</span></p>
<p>注意到$[ i = 0 j = 0 ]
$的时候算的挺特殊的,因此先把那些算掉,我们就只需要算下面这个东西:</p>
<p><span class="math display">\[
3 \sum _{ i = 1  } ^N ( - 1 ) ^{ i  } \binom { N  } { i  } \sum _{ j =
1  } ^N ( - 1 ) ^{ j  } \binom { N  } { j  } 3 ^{ ( N - i ) ( N - j )  }
\]</span></p>
<p>看后面那一块:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ j = 1  } ^N ( - 1 ) ^{ j  } \binom { N  } { j  } { ( 3 ^{ ( N -
i )  } )  } ^{ ( N - j )  } \\
&amp; = ( - 1 ) ^{ [ N \ne 0 \pmod { 2  } ]  } \sum _{ j = 1  } ^N ( - 1
) ^{ N - j  } \binom { N  } { N - j  } { ( 3 ^{ ( N - i )  } )  } ^{ ( N
- j )  }
\end{aligned}
\]</span></p>
<p>再看后面那一块:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ j = 1  } ^N ( - 1 ) ^{ N - j  } \binom { N  } { N - j  } { ( 3
^{ ( N - i )  } )  } ^{ ( N - j )  } \\
&amp; = \sum _{ j = 0  } ^{ N - 1  } ( - 1 ) ^j \binom { N  } { j  } { (
3 ^{ N - i  } )  } ^{ j  } \\
&amp; = \sum _{ j = 0  } ^{ N  } ( - 1 ) ^j \binom { N  } { j  } { ( 3
^{ N - i  } )  } ^{ j  } - ( - 1 ) ^N { ( 3 ^{ N - i  } )  } ^N \\
&amp; = ( 1 - 3 ^{ N - i  } ) ^N - ( - 1 ) ^N { ( 3 ^{ N - i  } )  } ^N
\end{aligned}
\]</span></p>
<p>这样就做完了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4491</p>
<p>直接二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^{ m  } ( - 1 ) ^{ i - k  } \binom { m  }
{ i  } \binom { i  } { k  } \binom { n  } { iS  } \frac { ( iS ) !  } {
( S ! ) ^i  } ( m - i ) ^{ n - iS  } \\
&amp; = \sum _{ i = k  } ^{ m  } ( - 1 ) ^{ i - k  } \frac { m !  } { (
m - i ) !  } \frac { 1  } { k ! ( i - k ) !  } \frac { n !  } { ( n - iS
) !  } \frac { 1  } { ( S ! ) ^i  } ( m - i ) ^{ n - iS  }
\end{aligned}
\]</span></p>
<p>令$tag = m ! n ! $,自然有:</p>
<p><span class="math display">\[
\frac { k ! f _k  } { tag  } = \sum _{ i = k  } ^m \frac { ( - 1 ) ^{ i
- k  }  } { ( i - k ) !  } \frac { ( m - i ) ^{ n - iS  }  } { ( m - i )
! ( n - iS ) ! ( S ! ) ^i  }
\]</span></p>
<p>注意到枚举量即$i , k , i - k <span class="math inline">\(,是一个卷积的形式,更进一步地,我们设\)</span>F
<em>k = { tag } , g </em>{ i } = { i ! } , h _i = { ( m - i ) ! ( n - iS
) ! ( S ! ) ^i } \ $.自然有:</p>
<p><span class="math display">\[
F _k = g _{ i - k  } h _i
\]</span></p>
<p>再设$g <em>k = G </em>{ m - k } , G <em>k = g </em>{ m - k }
$,自然有:</p>
<p><span class="math display">\[
F _k = G _{ m - i + k  } h _i
\]</span></p>
<p>ntt即可.</p>
<h4><span id="第十题第十一题">第十题/第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4931</p>
<p>ps:本题选入笔记:多项式与生成函数-生成函数-求微分方程</p>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } \binom { n  } { i  } \binom { n  } { i  } i ! ( 2 n - 2 i ) ! 2 ^i
\\
&amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { k ! ( i -
k ) !  } \frac { n !  } { ( n - i ) !  } \frac { n !  } { ( n - i ) !  }
( 2 n - 2 i ) ! 2 ^i \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = k  } ^n ( - 1 )
^{ i - k  } \frac { 1  } { ( i - k ) !  } \binom { 2 n - 2 i  } { n -
i  } 2 ^{ i - k  } \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = 0  } ^{ n  }
\frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到后者只与$n - k <span class="math inline">\(有关,不妨设其为\)</span>f <em>{ n } = </em>{ i = 0
} ^{ n } { i ! } { n - i } <span class="math inline">\(,预处理一下就可以做到\)</span>O ( n ^2 + nT )
$.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } f _{ n - k  } \\
f _{ n  } &amp; = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } {
i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到$f <span class="math inline">\(是一个卷积的形式,设其生成函数为\)</span>F _n <span class="math inline">\(,\)</span>g _n = { n ! } , h _n = { n } <span class="math inline">\(,我们自然有\)</span>F = GH $.</p>
<p>考虑$G <span class="math inline">\(和\)</span>H <span class="math inline">\(的生成函数形式,先看\)</span>G
$,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum _{ n \geq 0  } \frac { ( - 2 x ) ^n  } { n !  } = e ^{ - 2 x  }
\]</span></p>
<p>再看$H $,是一个类似卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac { 1  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! ) ^2 \frac { 2 ^k  } { k !  } [ x ^{ n - k  } ] \frac { e ^{ - 2
x  }  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>现在看$F $,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F ^2 = e ^{ - 4 x  }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e ^{ - 4 x  } \\
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F ^2
\\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f _{ i + 1  } - 8 if _i &amp; = 16 f _{ i - 1  } \\
if _i &amp; = 4 ( i - 1 ) f _{ i - 1  } + 8 f _{ i - 2  }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P5339</p>
<p>简单题,不妨设当前这个序列中不同颜色的分别有$a , b , c , d <span class="math inline">\(个(区别于题面中的\)</span>A , B , C , D
$),自然有:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { k  } { 0  } \binom {
n - 3 k  } { k  } \frac { ( n - 4 k ) !  } { ( a - k ) ! ( b - k ) ! ( c
- k ) ! ( d - k ) !  } \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n - 3 k  } { k  } \frac
{ ( n - 4 k ) !  } { ( a - k ) ! ( b - k ) ! ( c - k ) ! ( d - k ) !  }
\end{aligned}
\]</span></p>
<p>然后对最后那个东西做背包就行.</p>
<h4><span id="第十三题">第十三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5400</p>
<h3><span id="字符串算法">字符串算法</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P7114</p>
<p>调和级数加哈希,简单题,场切了.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3526</p>
<p>注意到一个事实:如果这个字符串存在长度为$k <span class="math inline">\(的周期,等价于存在长度为\)</span>len - k
$的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设$q $为最小周期,如果$2 q n <span class="math inline">\(,也就是原串能写成\)</span>tt t ’ <span class="math inline">\(的形式.我们不妨先求\)</span>tt ’ <span class="math inline">\(对应的答案,然后在前面拼\)</span>t <span class="math inline">\(.根据\)</span> { 2 }
$的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果$2 q &gt; n <span class="math inline">\(,此时必定有\)</span>s =
tat <span class="math inline">\(,其中\)</span>t <span class="math inline">\(是border.考虑递归求解\)</span>t <span class="math inline">\(,然后就只需要找到一个\)</span>a <span class="math inline">\(满足条件,最小的\)</span>a $是全$0
$,能放的话肯定放,不然我们就放一个$0 $.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全$0 $不合法:</p>
<ol type="1">
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l |
t | + | a | <span class="math inline">\(:考虑\)</span>l
$的最后一段是一段全$0 <span class="math inline">\(,也就必然意味着\)</span>t $的最后一段是全$0
$,这么不断推下去就可以说明整个序列都是全$0 $,此时放上$0
$必定合法.</p></li>
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l
&gt; | t | + | a | <span class="math inline">\(:不妨设当前的\)</span>l
<span class="math inline">\(是最大的那个(最小的无意义,因为需要保证\)</span>| l
| &gt; | t | <span class="math inline">\(),此时最短周期必然是\)</span>d
= 2 | t | + | a | - l <span class="math inline">\(.由于\)</span>| t | +
| a | <span class="math inline">\(也是周期并且二者之和\)</span>n <span class="math inline">\(,因此必然有\)</span>d | ( | t | + | a | ) <span class="math inline">\(.把\)</span>ta <span class="math inline">\(按照\)</span>d <span class="math inline">\(长度划分.如果\)</span>d | a | $必有该串是全$0
<span class="math inline">\(串,不然考虑此时\)</span>d = | b | + | a |
<span class="math inline">\(,\)</span>b <span class="math inline">\(是\)</span>t <span class="math inline">\(的一段后缀.考虑此时的周期必然\)</span>&lt; | b | +
| a | <span class="math inline">\(,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比\)</span>|
b | - | a | <span class="math inline">\(少了\)</span>w <span class="math inline">\(,那么此时必定有\)</span>b <span class="math inline">\(的前\)</span>w $个字符是$0 $,但是由于$0 <span class="math inline">\(后面第一个\)</span>b <span class="math inline">\(也往前平移了\)</span>w <span class="math inline">\(格,因此它的第\)</span>w $个字符必定是$1
$,这就保证了$0 1 $必定合法.</p></li>
</ol>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6623</p>
<p>考虑怎么维护所有点权值$+ 1 <span class="math inline">\(后的结果.一个自然的想法是,如果前\)</span>[ 0 , k -
1 ] $位都是$1 <span class="math inline">\(,或者说\)</span>v - 1 <span class="math inline">\(,那加一后会让第\)</span>k <span class="math inline">\(位取反.所以我们设\)</span>t _{ i , j , k } <span class="math inline">\(表示\)</span>i <span class="math inline">\(的子树内,\)</span> ^k <span class="math inline">\(的结果为\)</span>j <span class="math inline">\(的权值的数量.发现这个非常容易维护,用启发式合并可以做到\)</span>O
( n ^2 n ) $.</p>
<p>考虑这个权值的变化其实比较有规律,因为是树上的距离的差.我们考虑把距离这个东西做树上差分,设$v
_i = c _i + dis ( i , 1 )
$,我们要找到子树内部满足条件的其实就是在找满足:</p>
<p><span class="math display">\[
\begin{aligned}
v _i - dis ( x , 1 ) - 1 &amp; \equiv - 1 \pmod { 2 ^k  } \\
v _i &amp; \equiv dis ( x , 1 ) \pmod { 2 ^k  }
\end{aligned}
\]</span></p>
<p>也就是说我们每次对这个桶中要找的元素很固定,用一下colorful
tree的trick可以做到$O ( n n ) $.</p>
<p>然后然后,这题还有一个无脑做法是,我们倒着建01trie,这样$+ 1
$后可以快速更新.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1535F</p>
<p>我一开始第一反应是对$n len ^5 $这玩意根号分治,但是麻烦得很.</p>
<p>我们来看我当时想的根号分治部分:首先枚举两个字符串然后判断是好做的.我们来看$n
<span class="math inline">\(很大,\)</span>len
$较小的时候:此时枚举某个串的后缀,并同时枚举其前缀,然后前缀相同的若干个字符是一个trie上的子树,dfn是一个区间,后缀同理,这样就是一个二维数点问题.</p>
<p>冷静看一下上面的过程,你需要判断中间那一段$[ l + 1 , r - 1 ] <span class="math inline">\(是否是单调不降的序列.那如果我们枚举\)</span>r
<span class="math inline">\(,然后直接看满足单调不降的序列最靠左的\)</span>l
<span class="math inline">\(是谁,再看\)</span>[ 1 , l ] <span class="math inline">\(相同,这样不就直接做完了嘛?总之,先按照字符不同分类,再按照字典序排序,然后枚举\)</span>r
<span class="math inline">\(,二分找LCP满足条件的区间,和trie上dfn区间构成一个二维数点,总复杂度\)</span>O
( n len len ) $.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3311</p>
<p>简单题,ACAM上做数位dp.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1437G</p>
<p>首先肯定可以fail树上树剖,这个做法一眼秒.</p>
<p>然后我看题解发现这个题也可以colorful
tree.大概就是你先离线,然后维护时间维的答案,那么所有的修改操作就可以改成将时间在$[
l , r ] <span class="math inline">\(这段的字数答案取\)</span>$.这个是一个二维的问题.</p>
<p>但是,我们按照colorful
tree的思路去搞,每次dfs到一个点的时候,把答案加入线段树,在返回的时候撤销.注意colorful
tree其实不用撤销,因为它的信息满足可减性,这题不行.然后就实现了单$<span class="math inline">\(做法.可以使用吉司机,但是没必要,因为查询是单点查询,在每个节点上标记永久化然后一路取\)</span>$就行.</p>
<p>总结一下上面的这个东西是啥啊,就是说,你发现我们查询的内容是到根的一条链的最大值,这个还挺难做的,因为这条链不满足什么区间的性质,但是子树满足,因此想到了我们可以把操作改成对子树取$$.但是这个操作不满足可减性,难以消去.</p>
<p>如果不满足可删除性,我们一般要想想它是不是满足可撤销性,显然是满足的.因此自然想到了colorful
tree.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1483F</p>
<p>这题可能比较像lxl当时讲的那个支配对问题.我们考虑合法的$( i , j )
<span class="math inline">\(的数量的一个上界.一个自然的发现是,考虑先把所有的串按照长度排个序,然后对于较长的串,去找较小的串是否和它满足条件,一个自然的观察是,对于这个较长的串的每个位置\)</span>i
<span class="math inline">\(,最多只有一个串是满足条件的\)</span>[ 1 , i
] <span class="math inline">\(的后缀.因为如果有多个后缀可以选取最长的那个(注意当\)</span>i
= len <span class="math inline">\(的时候要选次长的那个,最长的是这个串本身),于是合法的\)</span>(
i , j ) <span class="math inline">\(数量只有\)</span>len <span class="math inline">\(个.首先这些\)</span>( i , j ) <span class="math inline">\(是有重复的,不过去重很简单.我们现在需要判定是否统计上了\)</span>(
i , j ) <span class="math inline">\(和\)</span>( k , j ) <span class="math inline">\(使得\)</span>i <span class="math inline">\(是\)</span>k <span class="math inline">\(的子串,\)</span>k <span class="math inline">\(是\)</span>j <span class="math inline">\(的子串.不难发现如果有这种情况出现,必然是因为\)</span>k
<span class="math inline">\(在\)</span>j <span class="math inline">\(中的出现位置在某一个\)</span>i <span class="math inline">\(之后,但是\)</span>k <span class="math inline">\(中又出现了\)</span>i <span class="math inline">\(,因此它的左端点必然在\)</span>i
$之前.我们维护一个单调栈,每次弹出左端点比当前左端点靠右的那些点,这些一定不会贡献答案.</p>
<p>我本来以为这样就做完了,实际上没有,上面的过程出了什么问题呢?我们确实能删掉所有的$(
i , j ) <span class="math inline">\(使得存在\)</span>( k , j ) <span class="math inline">\(满足\)</span>i <span class="math inline">\(是\)</span>k <span class="math inline">\(的子串,并且\)</span>i <span class="math inline">\(不是\)</span>k
$的后缀.但是如果是后缀的话我们是有可能删不掉的.</p>
<p>这个问题怎么解决呢?考虑这种事情会发生当且仅当$i <span class="math inline">\(所代表的ACAM的节点是\)</span>k <span class="math inline">\(的父亲.于是我们用树状数组维护这个东西,具体来说,从大到小判断\)</span>i
<span class="math inline">\(是否合法,并且在这个点上\)</span>+ 1
$,用树状数组统计子树内部是否有点就行.注意即使被弹出栈的那些字符串,也需要在这个过程中删去它所有的后缀.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1110H</p>
<p>考虑一个暴力的想法是,这个$[ l , r ] <span class="math inline">\(的限制条件其实等价于要求\)</span>[ l , r ] <span class="math inline">\(内的所有数字作为子串出现的次数加起来.把所有的这些字符串全部扔进ACAM,然后对着它dp.不妨设\)</span>dp
_{ i , j } <span class="math inline">\(表示当前走到\)</span>i <span class="math inline">\(节点,然后后面还可以填\)</span>j
$个位置的答案,自然有:</p>
<p><span class="math display">\[
dp _{ i , j  } = \max \{ dp _{ son , j - 1  } \} + cnt _i
\]</span></p>
<p>其中$cnt _i <span class="math inline">\(表示\)</span>i
$节点是多少子串的endn,构造方案是简单的.</p>
<p>考虑如何优化,注意到dp部分看上去挺优秀的,难搞的是ACAM的建树.我们不能把所有数字全扔进去.这种区间信息看上去就是如果走到当前,后面全填$0
$或者后面全填$9
$都能满足条件,那我们就开摆.更具体地来说,我们发现当前的最靠前的那一位没有用了:以它为开头的一定可以找到一个答案(其实因为填的数位).所以我们直接跳fail把那一位跳掉.</p>
<p>如果说的再形象一点的话就是,我们插入的过程其实很废,对于一些特定的前缀$x
<span class="math inline">\(,它的子树内部会形成一个满十叉树.这个是我们无法接受的.来考虑这个东西怎么办,我们一路dfs到叶子后肯定要跳fail,根据ACAM的建树过程,这等价于跳到\)</span>x
<span class="math inline">\(的fail,因此其实就等价于把\)</span>x
$这一位(或者后面的几位)跳掉.</p>
<p>但是,如果你顺着这个思路想,你开始逐渐剥掉满十叉树,然后一点一点搞,你会做的巨他妈复杂.</p>
<p>我们完全没有必要只在满十叉树的时候才跳跃.换句话说,如果后面填$len
$长度的字符串全部合法,我们就在这里统计答案,然后继续跳son而不是fail.</p>
<p>我们考虑既然这里填$len <span class="math inline">\(都可以,那填\)</span>l - 1 <span class="math inline">\(的长度或者填\)</span>r + 1
$的长度就不一定能全部合法了.只有后面几位填的满足某种条件才能合法.但是你注意啊,我们并不在左端点统计答案,而是在这个串填到某一位(可能是最后一位),然后后面都可以随便填的时候,才统计这里的答案,不一定跳fail.而我们跳fail的时候,会删去若干个前缀字符,这些答案会随着fail链一路传过来.还有一个问题是,如果我们跳fail跳到了被删去的虚拟节点怎么办?这种情况压根不会有贡献:这个被删去的虚拟节点的贡献会被传到它的某个祖先上,然后早早地贡献掉.我们跳到的fail应该是第一个不是虚拟节点的位置.因此这里也不会被更新答案.</p>
<p>这样整个题就是简单的了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4218</p>
<p>首先有一个$O ( n ^2 ) <span class="math inline">\(的暴力是,我们暴力在\)</span>SAM
$上跑一遍所有的串.我们考虑怎么优化这个东西.</p>
<p>树上路径,想到点分治,我们考虑对于一个分治中心$x <span class="math inline">\(,求出所有经过它的路径.这个怎么求呢?我们考虑先求出所有\)</span>u
x <span class="math inline">\(的路径,以及所有\)</span>x v <span class="math inline">\(的路径,假设前者的终点为\)</span>p <span class="math inline">\(,后者的起点为\)</span>p <span class="math inline">\(,那我们可以在\)</span>p <span class="math inline">\(节点统计答案.但是发现\)</span>u x <span class="math inline">\(这个东西需要往前加字符,不过这个好做,首先往前加字符等价于在parent
tree上跳儿子,而所有的儿子前面的第一个字符肯定是不同的,我们处理出\)</span>son
_{ x , c } <span class="math inline">\(表示在\)</span>x <span class="math inline">\(这个节点,往前加一个字符\)</span>c
$会到哪个节点.当然这个你实在不行把串反过来也行.</p>
<p>以及为了不让$u <span class="math inline">\(和\)</span>v <span class="math inline">\(在同一棵子树内,我们需要对其做容斥.不难发现每次操作和每次容斥的复杂度都是\)</span>O
( m + size ) <span class="math inline">\(的.总复杂度\)</span>O ( n n +
nm ) $,好像不太行.</p>
<p>冷静一下,我们把$siz <span class="math inline">\(较小的那些拿上面的暴力处理掉,这样就只有\)</span>siz
$较大的那些会有用了.这个复杂度怎么证明呢?我们考虑点分树.不妨假设它是一棵二叉树(其它的情况是类似的).</p>
<p>考虑将它的第$B $层以下的树全部暴力,这里一共有$2 ^{ B } <span class="math inline">\(棵树,每棵复杂度是\)</span>O ( 2 ^{ 2 ( n - B ) } )
$的.</p>
<p>它的第$B $层以上的跑上面的点分树,这里一共有$2 ^B <span class="math inline">\(个节点,每个节点要跑一次\)</span>O ( n + m )
$的做法.</p>
<p>平衡一下复杂度,设$B = { 2 } <span class="math inline">\(,此时复杂度\)</span>O ( ( n + m ) ) $.</p>
<h3><span id="动态规划第二期">动态规划第二期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P9318</p>
<p>不合法的情况如此方便,因为两边直接独立了,因此直接考虑二项式反演,设$f
_k <span class="math inline">\(表示恰好有\)</span>k <span class="math inline">\(个裂缝,\)</span>g _k <span class="math inline">\(表示钦定有\)</span>k $个裂缝,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g _k &amp; = \sum _{ i = k  } ^w \binom { i  } { k  } f _i \\
f _k &amp; = \sum _{ i = k  } ^w \binom { i  } { k  } ( - 1 ) ^{ i -
k  } g _i \\
ans &amp; = f _0 &amp; = \sum _{ i = 0  } ^w ( - 1 ) ^{ i  } g _i
\end{aligned}
\]</span></p>
<p>考虑设一个高为$h <span class="math inline">\(,长为\)</span>k <span class="math inline">\(的段随便填的方案数,显然就是每一层都随便填的方案数,也就是\)</span>w
_k = ( F _k ) ^h ( w _0 = 0 ) <span class="math inline">\(,其中\)</span>F _k <span class="math inline">\(是斐波那契数列的第\)</span>k <span class="math inline">\(项,那么\)</span>g <em>i <span class="math inline">\(就是这玩意做卷积.更具体地,我们设\)</span>g </em>{
i , j } <span class="math inline">\(表示目前长度为\)</span>j <span class="math inline">\(,分成了\)</span>i $段的答案,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g _{ i , j  } &amp; = \sum _{ k &lt; j  } g _{ i - 1 , k  } w _{ j -
k  } \\
G _i &amp; = W ^i
\end{aligned}
\]</span></p>
<p>这个生成函数形式其实没啥用,因为模数是$10 ^9 + 7 <span class="math inline">\(.上述dp的复杂度是\)</span>O ( n ^3 ) $的.</p>
<p>冷静一下不要魔怔,我们考虑别二项式反演,直接补集转化,这样就只需要知道最靠前的裂缝.换句话说,我们设$f
_i <span class="math inline">\(表示当前考虑到前\)</span>i <span class="math inline">\(列,然后没有裂缝的方案数,不难发现\)</span>f _n = w
<em>n - </em>{ k = 1 } ^{ n - 1 } f <em>k w </em>{ n - k } <span class="math inline">\(.这样就是\)</span>O ( w ^2 ) $的.</p>
<p>冷静一下,注意到$wh <span class="math inline">\(有限制,因此复杂度应该要和\)</span>wh <span class="math inline">\(有关,考虑对于一个联通的块的答案,你的最右侧一定不是平的,应该是有凹凸的.我们设\)</span>f
_{ i , j } <span class="math inline">\(表示当前dp完了前\)</span>i <span class="math inline">\(列,在第\)</span>i + 1 <span class="math inline">\(列凸出来了\)</span>j
$个位置.转移的话考虑凹的位置填什么,如果填$2 $就往后再凸一格,如果填$1
$就没啥事.具体地:</p>
<p><span class="math display">\[
f _{ n , m  } \binom { h - m  } { k  } \rightarrow f _{ n + 1 , k  } , k
\in [ 0 , h - m ]
\]</span></p>
<p>这个dp的复杂度为$O ( wh ^2 ) <span class="math inline">\(.注意到这两个dp的复杂度不同,于是分治,不妨设\)</span>N
= wh $,</p>
<p>第一个dp的复杂度是$O ( { h ^2 } ) <span class="math inline">\(,第二个dp的复杂度是\)</span>O ( Nh ) <span class="math inline">\(,当\)</span>h N ^{ { 3 } } <span class="math inline">\(的时候使用第二个dp,不然使用第一个,复杂度\)</span>O
( N ^{ { 3 } } ) $.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1250D</p>
<p>最重要的观察在于,这题等价于保留最多的区间,使得若其中某两个区间有交,那么它们必定颜色相同,但是同时需要满足一些形如某个区间只能染某种颜色的限制条件.原因很简单,首先原题的意思自然是找到染色方式,使得满足与其有交的区间颜色必定和它相同.那么对于一个满足条件的区间,如果与它有交的区间不满足条件,我们把那个区间删了这个区间也不会不满足条件.于是合法的不会变成不合法,接下来需要说明不合法的不会变成合法.首先是原本已经确定了颜色的区间,这个限制好做.然后是如果一个区间没有确定颜色,那它不能被包括在多个确定了的区间.这等价于,我们对于与右端点相交的所有无色区间全部作为新的右端点来更新.这样后面选的时候就不会错误更新右端点了.</p>
<p>或者我们换一个更清晰的描述,我们现在想要得到一些极长的段,使得这些段两两不交,并且与这些段相交的区间都是一个颜色.那么被完全包含在这个段内的区间显然就是答案,我们要最大化这个.</p>
<p>然后上面形成若干限制条件,但是这个在下面的dp中是好处理的.不过有个细节是,如果有两个相邻的连续段(不一定紧邻)的颜色相同,那么我们上一个区间的后面拖着的无色区间是不必对此产生影响的.这怎么办呢?特判一下同色.</p>
<p>这样的dp就很好设计了,更具体地,设$f _{ r , k } <span class="math inline">\(表示目前\)</span>[ 1 , r ] <span class="math inline">\(,包含\)</span>r <span class="math inline">\(的那个区间颜色是\)</span>k
$,最多能保留多少个区间.自然有:</p>
<p><span class="math display">\[
[ l , r ] = k \Rightarrow f _{ r , k  } \leftarrow cnt _{ l , r , k  } +
\max _{ i = 0  } ^{ l - 1  } f _{ i , k &#39;  }
\]</span></p>
<p>设$g <em>{ i } = </em>{ k } f _{ i , k } $,我们有:</p>
<p><span class="math display">\[
[ l , r ] = k \Rightarrow f _{ r , k  } \leftarrow cnt _{ l , r , k  } +
\max _{ i = 0  } ^{ l - 1  } g _{ i  }
\]</span></p>
<p>对于$g _i <span class="math inline">\(做前缀\)</span><span class="math inline">\(,这样就只需要枚举\)</span>r , k <span class="math inline">\(.复杂度\)</span>O ( n ^2 c ) $.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1158F</p>
<p>考虑如何判断一个串的密度,不妨设它密度为$P
$,我们从左往右找到第一个位置,使得前缀的密度为$1 <span class="math inline">\(,那么显然这个位置的后缀的密度是\)</span>P - 1
<span class="math inline">\(,如果小了,那么这个第一个位置所代表的那个数字开头的子序列就不全.如果多了,那显然可以构造出密度至少为\)</span>P
+ 1 <span class="math inline">\(的子序列.由上面这个描述,我们发现一个密度为\)</span>P
<span class="math inline">\(的序列一定可以分成\)</span>P <span class="math inline">\(个子段,使得每个子段都出现了\)</span>[ 1 , c ]
<span class="math inline">\(中所有的数字.更进一步地,我们如果不是划分,那么\)</span>P
<span class="math inline">\(中一定存在\)</span>P <span class="math inline">\(个互不相交的子段,使得每个子段都出现了\)</span>[ 1
, c ] <span class="math inline">\(中所有的数字并且每个子段最后的那个元素只出现了一次.顺便我们还可以发现\)</span>p
{ c } $.</p>
<p>由上面,我们可以发现一个状压dp,也就是设$dp _{ i , j , S } <span class="math inline">\(表示当前走到\)</span>i <span class="math inline">\(,前面的密度为\)</span>j <span class="math inline">\(,然后如果在后面全出现了\)</span>S
$中的数字,那么密度会变大$1 <span class="math inline">\(.这样给出了一个\)</span> { c } 2 ^c $的做法.</p>
<p>质数感觉不太行啊,考虑考虑dp,上面的形式看上去就很好dp,设$dp <em>{ i ,
j } <span class="math inline">\(表示当前在\)</span>i <span class="math inline">\(然后密度是\)</span>j <span class="math inline">\(的方案数,再设\)</span>f </em>{ l , r } <span class="math inline">\(表示在\)</span>[ l , r ] <span class="math inline">\(中选出一个子序列,\)</span>r <span class="math inline">\(必选且\)</span>a <em>r <span class="math inline">\(只出现了一次的方案数.不妨设\)</span>T <em>i <span class="math inline">\(表示\)</span>i <span class="math inline">\(在这个区间出现的次数,不难发现\)</span>f </em>{ l ,
r } = </em>{ i a _r } ( 2 ^{ T _i } - 1 ) <span class="math inline">\(.这个只需要枚举\)</span>l <span class="math inline">\(扫\)</span>r <span class="math inline">\(就可以\)</span>O ( n ^2 ) $算.自然有转移:</p>
<p><span class="math display">\[
dp _{ i , j  } = \sum _{ k &lt; i  } dp _{ k , j - 1  } f _{ k + 1 ,
i  }
\]</span></p>
<p>不过吧这么转移有一个小问题,那就是我们的$dp _{ i , j } <span class="math inline">\(必须是最后一段以\)</span>i <span class="math inline">\(结尾.那么我们最后统计答案还要算上最后的那一段没有选出\)</span>[
1 , c ] $的答案.不过这个也好算.</p>
<p>但是还有一个方式,那就是从后往前dp,然后每次放这么一段,对dp取一个后缀和来转移.</p>
<p>总之,这个dp的复杂度是$O ( { c } ) <span class="math inline">\(的.取\)</span>c = n <span class="math inline">\(为两个复杂度的边界,这样总复杂度是\)</span>O ( n ^2
n ) $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1175G</p>
<p>显然设$f _{ i , j } <span class="math inline">\(为前\)</span>j <span class="math inline">\(个划分了\)</span>i $段,自然有:</p>
<p><span class="math display">\[
f _{ i , j  } = \min _{ k &lt; j  } \{ f _{ i - 1 , k  } + ( j - k )
\max _{ l = k + 1  } ^j a _l \}
\]</span></p>
<p>第一反应是决策单调性,可惜没有.</p>
<p>不过后面那个形式很简单,我们暴力一点维护这个东西.用单调栈维护出当前哪些后缀的最大值相等,不妨记这个最大值为$m
$.我们改成刷表更新:</p>
<p><span class="math display">\[
f _{ i - 1 , k  } + ( j - k ) \max _{ l = k + 1  } ^j a _l \rightarrow f
_{ i , j  }
\]</span></p>
<p>对于每层$i <span class="math inline">\(从左往右扫\)</span>k <span class="math inline">\(,然后维护单调栈,然后对于每个点,它对右边的贡献在\)</span><em>{
l = k + 1 } ^j a <em>l <span class="math inline">\(不变的情况下,就是一条稳定的一次函数.但是这样还有一个问题,就是我们如何快速求出一个区间的所有的直线.这个的话,我们考虑对于不同的\)</span></em>{
l = k + 1 } ^j a <em>l <span class="math inline">\(,求出最小的\)</span>f
</em>{ i - 1 , k } - k </em>{ l = k + 1 } ^j a _l <span class="math inline">\(,这相当于一个凸包,然后用斜率为\)</span>m
$的直线来切点.然后合并两个凸包可以启发式合并,用链表维护队列.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9312</p>
<p>首先观察到我们可以限制手上的灯笼能照亮的海拔是一段区间,因为我们可以先选择不断扩张,而不是提前买,等到了需要用的时候再买就行.</p>
<p>一个自然的想法是$f <em>{ s , l , r } <span class="math inline">\(表示以\)</span>s <span class="math inline">\(为起点,当前能走到的海拔高度是\)</span>[ l , r ]
<span class="math inline">\(.为什么需要记录\)</span>s <span class="math inline">\(呢?因为可能有不同的区间走出来的海拔高度都是\)</span>[
l , r ] <span class="math inline">\(.那我们设\)</span>f </em>{ l , r }
<span class="math inline">\(为当前海拔最低的那个灯编号是\)</span>l <span class="math inline">\(,最高的那个编号是\)</span>r <span class="math inline">\(.然后我们要知道的就是\)</span>f _{ s , s } <span class="math inline">\(.然后按照区间从大到小dp.这样有一个\)</span>O ( k
^3 ) $的做法.</p>
<p>考虑如何优化,不妨假设当前新买的灯笼是第$u
$个,那么我们分情况讨论一下:</p>
<ol type="1">
<li><p>$f <em>{ i , u } + c <em>u f </em>{ i , j } <span class="math inline">\(.这种情况需要保证\)</span>u <span class="math inline">\(能买的地方在\)</span>i , j <span class="math inline">\(的控制区域里,并且需要满足\)</span>u <span class="math inline">\(的区间和\)</span>i , j <span class="math inline">\(的区间是相交的.这种情况上也就是需要\)</span>u
<span class="math inline">\(的下界小于等于\)</span>j <span class="math inline">\(的上界.这个比较好处理,我们从大到小枚举\)</span>j
<span class="math inline">\(,等\)</span>f </em>{ i , u }
$不合法的时候把它删了就是了.</p></li>
<li><p>$f _{ u , u } + c <em>u f </em>{ i , j }
$.和上面是类似的.</p></li>
</ol>
<p>也就是说,我们现在唯一最需要搞定的就是怎么让$u <span class="math inline">\(能买的地方在\)</span>i , j
$的控制区域里,不难发现这是一个看上去比较典的线段树维护dp.</p>
<p>事实上有一种更简单的写法,不妨设$L , R <span class="math inline">\(为实际控制的海拔范围,\)</span>S , T
$为实际控制的山峰范围,我们先把转移仔细写一下:</p>
<ol type="1">
<li><p>$f _{ l , u } + c <em>u f </em>{ l , r } ( R _u &gt; R _r L _u u
) $.</p></li>
<li><p>$f _{ u , r } + c <em>u f </em>{ l , r } ( L _u &lt; L _l R _u u
) $.</p></li>
<li><p>$f _{ u , u } + c <em>u f </em>{ l , r } ( L _u &lt; L _l R _u R
_u &gt; R _r L _u u ) $.</p></li>
</ol>
<p>按照$L <span class="math inline">\(从小到大枚举,按照\)</span>R
$从大到小枚举,那上面的所有转移都是无后效性的.</p>
<p>注意到第三种转移没有意义,我们可以直接改写成:</p>
<ol type="1">
<li><p>${ f <em>{ l , u } , f </em>{ u , u } } + c <em>u f </em>{ l , r
} ( R _u &gt; R _r L _u u ) $.</p></li>
<li><p>${ f <em>{ u , r } , f </em>{ u , u } } + c <em>u f </em>{ l , r
} ( L _u &lt; L _l R _u u ) $.</p></li>
</ol>
<p>原因在于,我们其实只想要让$u <span class="math inline">\(与\)</span>l
, r
$所代表的区间相交,这个比较重要,其它的都不重要.就算转移是错误的,那样转移一定不优秀.</p>
<p>此刻对于(1)我们想知道的就是固定$l <span class="math inline">\(的情况下,按照\)</span>R <span class="math inline">\(从大到小枚举的贡献,以及对称情况,不难发现这个用堆也是能做的.也就是在\)</span>l
<span class="math inline">\(相同的前提下,如果\)</span>R _i &lt; R _j
&lt; R _k <span class="math inline">\(,如果\)</span>k <span class="math inline">\(不能贡献到\)</span>j <span class="math inline">\(,那么\)</span>k <span class="math inline">\(必然不能贡献到\)</span>i
$,这就保证了堆的正确性.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P8294</p>
<p>毛估估的话就是设$f _{ x , s , t } <span class="math inline">\(表示在断开\)</span>x <span class="math inline">\(到父亲这条边时,\)</span>x <span class="math inline">\(的值来自子树内的点\)</span>s <span class="math inline">\(,然后从父亲换下来的值将要去子树内的\)</span>t
<span class="math inline">\(.不难发现\)</span>( x , s , t ) <span class="math inline">\(合法当且仅当\)</span>x = lca ( s , t ) <span class="math inline">\(,这样状态数就是\)</span>O ( n ^2 ) $的.</p>
<p>来细细写一写转移:</p>
<p>首先,如果$cnt <em>{ son } = 0 <span class="math inline">\(,显然\)</span>f </em>{ x , x , x } = d _x $.</p>
<p>如果$cnt _{ son } = 1 <span class="math inline">\(,不妨设其儿子是\)</span>u <span class="math inline">\(,不难发现此时必有\)</span>s _x = x t _x = x
$,讨论一下:</p>
<p>若$s _x = x $,那么之间换出去就行,然后因为要一路换下去:</p>
<p><span class="math display">\[
f _{ x , x , t _x  } \leftarrow f _{ u , s _u , t _x  } + d _x
\]</span></p>
<p>反之,那么要先把$s _x <span class="math inline">\(换到\)</span>x
$这里,然后再换出去,此时有:</p>
<p><span class="math display">\[
f _{ x , s _x , x  } \leftarrow f _{ u , s _x , t _u  } + d _x + d _{ s
_x  } ( dep _{ s _x  } - dep _{ x  } )
\]</span></p>
<p>注意到上述复杂度均为$O ( n ^2 ) <span class="math inline">\(.因为枚举一下\)</span>( s _u , t _x ) <span class="math inline">\(或\)</span>( s _x , t _u ) <span class="math inline">\(就可以确定\)</span>u <span class="math inline">\(,而\)</span>x <span class="math inline">\(是\)</span>u $的父亲,自然也可以确定.</p>
<p>这个式子已经给了我们启发了,剩下的类似.有时间再补这个题吧,太精神污染了.</p>
<h3><span id="数据结构">数据结构</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1648D</p>
<p>不妨设$f _i <span class="math inline">\(表示从\)</span>( 1 , 1 )
<span class="math inline">\(走到\)</span>( 2 , i ) <span class="math inline">\(的最大收益,显然求出这个后再拼一下第三行的后缀和就是答案.我们枚举覆盖\)</span>(
2 , i ) <span class="math inline">\(的区间是\)</span>k <span class="math inline">\(,此时必然需要满足\)</span>l _k i r _k $.</p>
<p>不妨设$sum <span class="math inline">\(表示每一行的前缀和,\)</span>sufsum
$表示第三行的后缀和,注意到转移:</p>
<p><span class="math display">\[
\begin{gathered}
- c _k + \max _{ l _k - 1 \leq j &lt; i \leq r _k  } \{ f _j \}
\rightarrow f _i \\
- c _k + \max _{ l _k \leq j \leq i \leq r _k  } \{ sum _{ 1 , j  } -
sum _{ 2 , j - 1  } \} \rightarrow f _i
\end{gathered}
\]</span></p>
<p>这个东西即使我们枚举$k , i <span class="math inline">\(,然后数据结构优化\)</span>j <span class="math inline">\(来转移它也是艰难的.那咋办呢?我们考虑我们枚举\)</span>k
<span class="math inline">\(的原因是,我们需要保证\)</span>i r _k <span class="math inline">\(.如果我们钦点\)</span>i = r _k <span class="math inline">\(,那我们上面的枚举就只有一维了.也就是需要保证\)</span>i
<span class="math inline">\(右边的点一定走不到,这样我们上面的转移仍然是正确的.至于计算答案,一个反应是把这个\)</span>f
<span class="math inline">\(做一下后缀\)</span><span class="math inline">\(.但其实不对!因为你往后多走点可能多吃到了一点\)</span>a
$.</p>
<p>那么怎么处理这个东西呢?考虑如果当前选的这个区间不是最后一个区间,那我从后面的$r
<span class="math inline">\(走到前面的一个\)</span>i <span class="math inline">\(再拐到第三行去,显然只会有第二行的一段和的差别,我们把这个差别统计进去就行.但是如果只开了一个区间,也就是从第一行拐下来没到结尾直接拐下第三行了,那么第一行的贡献也要减去.我们可以把\)</span>f
<em>{ i } <span class="math inline">\(改成\)</span>f </em>{ i , 0 / 1 }
$来解决这种问题.</p>
<p>于是吧,我们就有了下面这个转移:</p>
<p><span class="math display">\[
\begin{gathered}
- c _k + \max _{ l _k - 1 \leq j &lt; r _k  } \{ f _{ j , 0  } , f _{ j
, 1  } \} \rightarrow f _{ r _k , 1  } \\
- c _k + \max _{ l _k \leq j \leq r _k  } \{ sum _{ 1 , j  } - sum _{ 2
, j - 1  } \} \rightarrow f _{ r _k , 0  }
\end{gathered}
\]</span></p>
<p>然后怎么贡献答案呢?首先你不能往左走太多,至少不能超过最后选的那个区间.事实上我们发现最后一定只有一个区间的右端点超过了拐点.因为选择的所有区间一定没有包含关系,而右端点可以对拐点取$<span class="math inline">\(.因此我们枚举当前最靠右的那个区间\)</span>k <span class="math inline">\(,以及最后拐到第三行的点\)</span>i $,自然有:</p>
<p><span class="math display">\[
\begin{gathered}
- c _k + \max _{ l _k - 1 \leq j &lt; r _k  } \{ f _{ j , 0  } , f _{ j
, 1  } \} + \max _{ j &lt; i \leq r _k  } \{ sum _{ 2 , i  } + sufsum _{
i  } \} \rightarrow ans \\
- c _k + \max _{ l _k \leq j \leq i \leq r _k  } \{ sum _{ 1 , j  } -
sum _{ 2 , j - 1  } + sum _{ 2 , i  } + sufsum _i \} \rightarrow ans
\end{gathered}
\]</span></p>
<p>要统计所有$j &lt; i <span class="math inline">\(或者\)</span>j i
$的点对的答案在线段树上都是好做的.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P9371</p>
<p>考虑如何判断$x <span class="math inline">\(是否是这个区间的中位数:我们把大于\)</span>x
$的记作$1 <span class="math inline">\(,小于\)</span>x <span class="math inline">\(的记作\)</span>- 1 <span class="math inline">\(,\)</span>x $记作$0 <span class="math inline">\(,如果区间和的绝对值小于等于\)</span>x <span class="math inline">\(的出现次数,那么\)</span>x $满足条件.</p>
<p>我们先扫值域,这样修改每个点的取值的总复杂度均摊.对于每一个权值$v
<span class="math inline">\(,枚举权值是\)</span>v <span class="math inline">\(的一个点作为这个区间中最靠左的\)</span>v <span class="math inline">\(,然后考虑找到最大的右端点使得合法,而由于确定了最靠左的\)</span>v
<span class="math inline">\(,我们其实是不在乎这个区间左端点是啥的,只要包含这个点就行,不妨设这个点为\)</span>l
$.</p>
<p>接下来在每个点记录以这个点的为结尾的所有后缀和(要求左端点小于等于$l
<span class="math inline">\()的集合.不难发现,这个集合一定是一段区间,因为每个值只有可能是\)</span>
$或$0 <span class="math inline">\(.于是我们要维护的就是这些点的最大后缀和以及最小后缀和,然后判断这个值与\)</span>x
<span class="math inline">\(的大小关系.用线段树维护这两个东西的\)</span><span class="math inline">\(和\)</span>$,能往右跳就往右跳.</p>
<p>有个细节是我们需要保证这些后缀和的左端点小于等于$l <span class="math inline">\(,这其实等价于直接求\)</span>l <span class="math inline">\(这里的最小后缀和以及最大后缀和,然后在每个点上只需要存这个点与\)</span>l
<span class="math inline">\(这段区间和即可,这个在\)</span>l
$的移动过程中是好维护的.</p>
<p>至于最大后缀和的合并是简单的.</p>
<p>写起来发现上面那个东西其实不太好搞啊,我们考虑改改描述,上面等价于将每个区间改成最小后缀和$-
x <span class="math inline">\(出现次数,以及最大后缀和\)</span>+ x
$出现次数,然后只需要判断这个区间是否包含$0 $.好像还是不太好做???</p>
<p>冷静一下,注意到相邻两个位置的最大后缀和相差不超过$1
$,这意味着我们可以维护一段区间的所有区间的并,这必定还是一个区间.然后判断这个并是否包含$0
$,这个就方便线段树上二分了.至于我们的修改操作,无非是以下几种操作:</p>
<ol type="1">
<li><p>对于每个$l
$以及它的一对后缀和,在线段树上找到最靠右的一个叶子使得这个区间在加上这对后缀和更改后包含$0
$.</p></li>
<li><p>在更改当前处理的值$v $的时候,将所有点的值恢复为前缀和.</p></li>
<li><p>在更改当前处理的值$v <span class="math inline">\(的时候,将某些点的值置为\)</span>- 1
$,将某些点的值置为$0 $.</p></li>
</ol>
<p>显然都好做.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P7220</p>
<p>ps:本题选入笔记:常见套路-二进制分组-Example1</p>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点$(
x , y ) <span class="math inline">\(,随着\)</span>x <span class="math inline">\(的增大\)</span>y
$不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.考虑求出所有能影响到一个询问的区间,把它们扔到线段树上,然后就可以用线段树分治维护这个东西.具体来说,我们在线段树上dfs,每次遇到一个区间,把该搞得全部搞完,然后这个点的位置就留在这里了,在后面dfs到其它的区间后再改.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9168</p>
<p>场上写了$48 pts <span class="math inline">\(,简单来说就是对于每个\)</span>m
$,从下往上合并,然后当某一个时刻某棵子树内人数大于子树大小,就把最菜的那几个给删了.根据Hall定理,这样做显然是正确的.</p>
<p>接下来看怎么优化,首先第一反应肯定是线段树分治,这样我们只需要做加入和撤销,就不需要做删除了.撤销总是好做的.</p>
<p>那么只有加入怎么做呢?这个点能造成的影响无非是以下几种:</p>
<ol type="1">
<li><p>它被加入,没有别的点被删除.</p></li>
<li><p>它被加入,另一个点被删除.</p></li>
<li><p>它没有被加入.</p></li>
</ol>
<p>注意到(1)发生当且仅当这个点到根的路径上没有节点是满节点,这个判一下就行.</p>
<p>然后考虑(2),(3),淘汰必然会发生,并且必定是在离插入点最近的那个满的祖先.</p>
<p>这样的话我们需要实现的就是两件事:</p>
<ol type="1">
<li><p>对于一个点,找到离他最近的满的祖先.</p></li>
<li><p>查询子树内部点的最小值.</p></li>
<li><p>支持在点上插入和删除.</p></li>
</ol>
<p>这三个操作显然都可以用树剖维护.算上线段树分治,这样就是$O ( n ^3 n )
$.</p>
<p>不过吧,我们需要说明一件事情:那就是为啥选择子树内最小的那个点一定是优秀的.我们可以简单举个例子来反对这个直觉:如果有两个点权值相同,一个点是另一个点的祖先,那显然选择祖先会优秀一点,因为这个祖先对下面子树的限制要小一些.</p>
<p>我们可以这么干:我们在一开始那个暴力中这么规定:每次满员了之后,删掉权值最小的,权值相同的则按照编号删.对于一个子树$x
$,假设它所有儿子的子树都合法了,并且它需要删,此时:</p>
<ol type="1">
<li><p>如果我们之前想删的那个点已经死了,那就完事了.</p></li>
<li><p>如果我们之前想删的那个点没死,注意到我们接下来插入的点一定排序比当时想删它的时候只大不小,那此时必然还要删掉它.</p></li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF464E</p>
<p>之前做过,就是最短路.但是我们要实现高精度加法和高精度比较大小,注意到加上一个$2
^x $在二进制上的体现是某段$1 $变成$0 $,某一个$0 $变成$1
$,这个可以用主席树实现.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1801E</p>
<p>简单题,考虑暴力显然是直接大力并查集,而并查集的操作其实是不多的:一次有用的并查集操作必定是会让连通块个数减少$1
<span class="math inline">\(,因此操作均摊.于是考虑二分+哈希找到第一个有用的并查集操作.这就必然要求我们快速求出一条路径的哈希值.考虑哈希是可以差分的,因此处理每个点到根的哈希值(注意要维护两个方向)即可.每改变一个点就把子树内全部更改一下,这样就做完了.使用启发式合并可以做到\)</span>O
( n ^2 n ) $.</p>
<p>不过发现这个过程只有区间加法和单点查询,可以使用树状数组.</p>
<p>然后就卡了一晚上常数.事实上这题存在二进制分组做法:我们发现我们要做的无非是将两段直上直下的序列,然后定义它们对应数字相等.我们可以将一个点到它的$2
^k $级祖先所形成的这么一段拆成一段,这样就可以直接倍增然后处理.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF702F</p>
<p>典典典.考虑维护人的平衡树,然后每次check一个衬衫.注意到它会把大于等于它的人给减去这个值.我们考虑将这个splay分裂开来,然后对大于等于它的那些点打个减法tag,再与小于它的那个分裂出去的树合并起来.但是splay无法支持快速合并两棵无大小关系的树(ye不能启发式合并,因为以后还要裂开),我们考虑当前衬衫的价格是$v
<span class="math inline">\(,将所有人分成\)</span>[ 0 , v ) , [ v , 2 v
) , [ 2 v , + ) <span class="math inline">\(,三个部分,第一个部分不用管,第二个部分减去\)</span>v
<span class="math inline">\(后变成第一个部分,我们把它们暴力插入第一个部分.第三个部分直接打tag并合并,由于第二个部分的暴力插入会使得权值减半,因此总复杂度\)</span>O
( n ^2 n ) $.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P6072</p>
<p>考虑对于每一条边,求出以这条边为界限,两边的最大值然后加起来,显然就是答案.</p>
<p>还有一点是,一条路径$x - y <span class="math inline">\(的权值可以表示为\)</span>dep _x dep _y
$,这就启发我们用01trie维护最大异或值.</p>
<p>现在相当于求出$f _x <span class="math inline">\(表示\)</span>x <span class="math inline">\(的子树内的答案,再求出\)</span>g _x <span class="math inline">\(表示\)</span>x <span class="math inline">\(的子树外的答案.这个怎么求呢?首先\)</span>f _x
$可以启发式合并01trie.</p>
<p>对于$g _x <span class="math inline">\(,也很好做.你考虑求出全局最大的那条路径,显然只要分割点不在这条路径上,就会选取它.反之的话,就是两条路径往下dfs,这个直接暴力做01trie就是\)</span>O
( n w ) $.</p>
<p>做到这里我们冷静一下看看$f <span class="math inline">\(,注意到只有临近上面我们说的那条链的\)</span>f
<span class="math inline">\(,或者是就在这条链上的\)</span>f <span class="math inline">\(.我们只需要求出这些\)</span>f <span class="math inline">\(,因为再往下也没啥用,这样就能让总复杂度变成\)</span>O
( n w ) $.</p>
<h3><span id="图论">图论</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4768</p>
<p>典中典,求kruskal重构树,以及$1 $到所有点的最短路即可.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1408G</p>
<p>首先你需要发现,一个点集内部的边全部小于它与外界相连的边,那么如果我们从小到大加边,那么必然有一个时刻是这个点集成为了一个和外界分离的团.因此,考虑从小到大加边,并考虑kruskal重构树的结构,我们就可以将这个过程展现在树上.并且这个过程等价于区间合并.因此我们的问题转化为了有若干区间,选取若干不交的区间覆盖全集的方案数,简单的.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P9167</p>
<p>我们设题面中的$t <span class="math inline">\(座城市是关键城市,根据题面,断掉这\)</span>t <span class="math inline">\(座城市之间的边,会使得图分裂成若干个大小相差至多为\)</span>k
<span class="math inline">\(的连通块.我们不妨认为在一个连通块中,关键城市控制着里面的所有点,那么被不同城市控制的点一定没有边相连.如果此时图是树的话我们已经做完了,无非是要在树上划分点集.反之,我们考虑dfs树,维护出点双意义下的\)</span>dfn
, low $.注意到一个连通块必定在dfs树上也是连通块.</p>
<p>那么一个点能作为关键点,当且仅当它在dfs树上的某些子树所组成的城市都被控制,这个可以通过$low
<span class="math inline">\(来判断.枚举连通块大小,并设\)</span>dp _{ i ,
j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(子树上部还有\)</span>j <span class="math inline">\(个城市没决定被控制,这样就可以dp.注意到第二维有用的信息不多,这样就可以优化到\)</span>O
( n ) $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9170</p>
<p>先看Bob,先把$| T | = 1 <span class="math inline">\(的选了,然后删掉.不断做这个过程直到所有的\)</span>|
T | = 2 <span class="math inline">\(,此时将这两个点之间连一条边,那就会形成一张图.对于每个连通块,若\)</span>|
E | &gt; | V | $,则必然无解.其它的情况必然有解,这就解决了第一个问题.</p>
<p>不过其实没必要删$| T | = 1 $,直接连自环就行.</p>
<p>对于Alice,考虑以下几种情况:</p>
<ol type="1">
<li><p>$| S T | = 0 $,显然Alice选啥都没用.</p></li>
<li><p>$| S T | = 1 $,此时Alice必然选那个和Bob有交的.</p></li>
<li><p>$| S T | = 2 $,此时Alice可以选择其中一个.</p></li>
</ol>
<p>这样的话,Alice就已经确定了一些东西,而不确定另一些东西.Alice必然是要让Bob能选的最小情况最大,我们考虑再讨论一下:</p>
<ol type="1">
<li><p>$| E | = | V | <span class="math inline">\(,此时连通块是一个基环树.那么除了环以外的点一定都选好了.如果是自环那么怎么选都行.反之,环上有两种选择方式(就是一个点会在哪条边上被选).考虑对于两种方式,Alice已经确定必选的数量分别是\)</span>c
_1 , c _2 <span class="math inline">\(,而Alice现在还可以选的个数是\)</span>c <span class="math inline">\(,我们也就是要选取\)</span>i <span class="math inline">\(,最大化\)</span>{ c _1 + i , c _2 + c - i } <span class="math inline">\(,显然取\)</span>c _1 + i = c _2 + c - i , i = { 2
} <span class="math inline">\(,注意如果\)</span>i $要对$0 <span class="math inline">\(取\)</span><span class="math inline">\(,对\)</span>c <span class="math inline">\(取\)</span>$.</p></li>
<li><p>$| E | = | V | - 1 <span class="math inline">\(,此时连通块是一棵树,并且有一个点不会被选择.不妨设\)</span>f
_i <span class="math inline">\(表示\)</span>i <span class="math inline">\(这个点不会被选的方案数,那Alice对于一条边的定向,会让这条边其中一侧的子树的\)</span>f
<span class="math inline">\(整体\)</span>+ 1 <span class="math inline">\(.这个看上去极其熟悉.典中典套路是,考虑两条边选择使得\)</span>V
_1 , V _2 $分别加了$1 <span class="math inline">\(,如果\)</span>V _1 V
_2 = $,同时取反这两条边的选择,一定不劣.于是选择的边会让加$1 <span class="math inline">\(的点集两两有交.枚举交集中的一个点\)</span>x <span class="math inline">\(,则所有边的选择全部确定:每条边都选择深度较低的那个点.仔细考虑此时,Bob的最优选择是啥.如果Bob选择了一个点\)</span>y
<span class="math inline">\(,那么\)</span>f _y <span class="math inline">\(显然是\)</span>f _x <span class="math inline">\(减去\)</span>x <span class="math inline">\(到\)</span>y <span class="math inline">\(的路径上Alice能选的数量加上Alice只有一种选择,并且在这里为反向选择的数量.我们要最大化这个东西,也就是最小化\)</span>x
<span class="math inline">\(到\)</span>y
$的路径上Alice能选的数量,其实也就是最小化一棵树的深度,这个是方便dp的.</p></li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF235D</p>
<p>这个形式看上去极其复杂,考虑简单化一下:我们考虑对当前图选一个分治中心,对答案的贡献是$|
G |
$,不难发现,这相当于每个点贡献了一次.进一步地,这等价于对于每个点,判断它会在多少个点作为分治重心的时候,仍然在那个点所在的连通块中.</p>
<p>如果原图是树,这等价于对于$u , v <span class="math inline">\(,\)</span>u <span class="math inline">\(是\)</span>( u , v ) <span class="math inline">\(路径上第一个被删除的点的概率,这等价于\)</span> {
len } $.这样树的情况就做完了.</p>
<p>考虑基环树怎么做:如果两个点$( u , v ) <span class="math inline">\(之间路径唯一,那上面做的显然还是对的.反之,我们有公式\)</span>P
( A B ) = P ( A ) + P ( B ) - P ( A B ) <span class="math inline">\(,因此你把这两条路径求出来,加起来,减去它们同时发生的概率即可.注意同时发生的概率不是\)</span>P
( A ) P ( B )
$,因为这两件事不独立,事实上应该是这两条路径的点集并的大小分之一.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4429</p>
<p>如果图不连通可以对于每个块分开考虑,下面只考虑图连通的情况:</p>
<p>显然,如果图不是二分图一定无解.</p>
<p>其次,我们注意到孤立点和一度点一定都可以删去,前者显然,后者是因为与它相邻的那个点的颜色如果确定,那它一定有一种和它选不一样的方法.这样当前所有点的度数$
$.</p>
<p>接下来,青鱼说得好,我们把很多比较能看出来有解的情况判掉,剩下的就是无解.</p>
<ol type="1">
<li>偶环一定有解.</li>
</ol>
<p>如果偶环上的颜色全都一样,那直接二分图染色.不然,一定存在相邻的两个点$x
, y <span class="math inline">\(使得\)</span>x <span class="math inline">\(有一种颜色,\)</span>y <span class="math inline">\(没有,直接让\)</span>x <span class="math inline">\(染这种颜色,\)</span>x - y <span class="math inline">\(这条边就没用了,断掉,然后顺着\)</span>x
$平推过去,一定有解.</p>
<p>妈的,剩下的不会了,先咕着.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1672G</p>
<p>发现个事情:如果当前所有行和所有列的异或值都是$0 <span class="math inline">\(,那么我们可以每次选取四个点然后点击,这样这四个点会改变,而其它点都不改变,从左上开始一直点相邻的四个点,这样最后左上角的\)</span>(
n - 1 ) ( m - 1 ) $的矩阵就全空,而由于每行每列$1
$的个数都是偶数,这个过程不改变这个性质,因此最后一定全图是空的.</p>
<p>而由于最后的状态是全空,因此在变化过程中总有一个时刻使得每行每列异或值为$0
$.</p>
<p>考虑异或的过程,如果$n
$是偶数,那么这么一次异或会使得除了一列以外的所有列都异或上$1 <span class="math inline">\(.如果\)</span>n $是奇数,则会使得全局异或上$1
$.</p>
<p>现在我们来讨论一下$n , m $的奇偶性(对称情况可以反转,不讨论):</p>
<ol type="1">
<li><p>$n , m
$均为偶数.只考虑第一行,从第二列开始,如果当前这一列和第一列不一样就把它操作掉.这样最后所有列的异或值都相同.如果最后是全$1
<span class="math inline">\(,我们把第一行轮着点一遍,这样每一列都被点了\)</span>m
- 1
$次,而行的奇偶性不变.也就是说,此时无论怎么填都是有解的.行再一样做</p></li>
<li><p>$n <span class="math inline">\(是奇数,\)</span>m
$是偶数.此时必须要求所有列的异或值相同.每一行如何做可以(1)一样使得每一行异或值都是$0
$.枚举所有列是$0 $还是是$1 $,留一个?来调整,剩下的?随便选.</p></li>
<li><p>都是奇数,此时要求所有行和所有列的奇偶性分别相同.枚举这四种奇偶性情况,然后将$?
$看成连在横坐标和纵坐标之间的边.那也就相当于确定了每个点的度数,然后问有多少种选边方式.典中典.对于每个连通块,求出一棵生成树,然后剩下的边随便选,用生成树一路调整上去.注意这要求所有点的度数之和是偶数,也就是至少得是一张合法的图.</p></li>
</ol>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc117_f</p>
<p>考虑求出前缀和,此时要满足条件,不妨设全局和为$x $,此时必然有:</p>
<p><span class="math display">\[
\begin{aligned}
\forall 0 &amp; \leq i &amp; &lt; n , s _{ i + n  } - s _i &amp; \geq a
_i \\
\forall n &amp; \leq i &amp; &lt; 2 n , x - ( s _{ i  } - s _{ i - n  }
) &amp; \geq a _i , s _i - s _{ i - n  } &amp; \leq x - a _i \\
\forall 0 &amp; \leq i &amp; &lt; 2 n , s _i &amp; \leq s _{ i + 1  }
\end{aligned}
\]</span></p>
<p>注意上面的限制条件限制住了$s <em>{ i + n } - s </em>{ i } <span class="math inline">\(的上下界,我们不妨设它的上下界分别为\)</span>l
<span class="math inline">\(和\)</span>r <span class="math inline">\(.但是这俩需要知道\)</span>x <span class="math inline">\(才能求出来,于是不妨二分\)</span>x $.</p>
<p>贪心地构造,考虑每次要求$s <em>{ i + n } <span class="math inline">\(尽可能地小,于是如果\)</span>l <em>i s </em>{ i - 1
+ n } - s </em>{ i - 1 } r <em>i <span class="math inline">\(,我们就继承前面的答案.反之,如果\)</span>l <em>i
&gt; s </em>{ i - 1 + n } - s </em>{ i - 1 } <span class="math inline">\(,我们就提升\)</span>s <em>{ i + n } = s </em>{ i -
1 } + l <em>i <span class="math inline">\(,\)</span>r <span class="math inline">\(同理.这样走到最后一定是最小的,只需要满足\)</span>s
</em>{ n - 1 } s <em>n s </em>{ 2 n - 1 } x $即可.</p>
<p>但是你发现个事情,我们前面一直在保证$s <span class="math inline">\(尽可能小,却没有保证\)</span>s _{ n - 1 } s _n
<span class="math inline">\(.我们怎么处理这里的\)</span>s _n <span class="math inline">\(呢?考虑再次二分,每次找到最小的\)</span>s _n
$满足前一个条件.那我们就需要说明两件事情:</p>
<ol type="1">
<li><p>满足前一个条件的$s _n $满足单调性.</p></li>
<li><p>$s _n $越小,越有可能满足第二个条件.</p></li>
</ol>
<p>先来说(2),这个比较显然.因为如果$s _n <span class="math inline">\(在前面较小不满足的话,我们可以在后面某个地方给提升得大一点,显然由于\)</span>s
_n $的提升比较自由,这个是可以做到的.</p>
<p>再来看(1),如果一个$s _n <span class="math inline">\(满足条件,我们把这个\)</span>s <em>n $增大$1 <span class="math inline">\(.考虑将前面的所有\)</span>s </em>{ 0 n - 1 }
$全部提升$1 $,这样所有的差都不变,因此仍然满足条件.</p>
<p>冷静总结一下这个题,其实就是我们首先要发现很多可二分的性质:</p>
<ol type="1">
<li>$s _{ 2 n } $可二分.</li>
</ol>
<p>这个是显然的,放更多显然不会更劣.但是我们要在这个基础上找到一种方法,使得如果当前二分的值合法,一定能构造出一组答案.我们发现如果没有$s
<em>{ n } s </em>{ n - 1 } <span class="math inline">\(这个限制,一切都是好做的:因为我们可以贪心地使得当前的\)</span>s
$最小.</p>
<ol start="2" type="1">
<li>$s _n $可二分.</li>
</ol>
<p>这个是怎么发现的呢?因为我们发现我们勒令$s _n <span class="math inline">\(是啥,似乎对这个贪心过程没有啥影响.如果\)</span>s
<em>n <span class="math inline">\(过小,上面的贪心过程就会在\)</span>s
<em>n s </em>{ n - 1 } <span class="math inline">\(这里判出错.如果\)</span>s <em>n <span class="math inline">\(过大,则会在\)</span>s </em>{ 2 n - 1 } s </em>{ 2
n } <span class="math inline">\(上判错.这意味着\)</span>s _n
$可能需要是一个区间才合法.接下来就是去证明它确实是一个区间是合法的,并且证明我们的贪心过程能在这个贪心过程中正确地check.</p>
<h3><span id="线性代数">线性代数</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1224</p>
<p>首先显然的一点是,我们把它搞成一个矩阵$A <span class="math inline">\(,然后拿\)</span>A A ^T
$.注意到如果最后的答案矩阵存在$0 <span class="math inline">\(就有解,这个解就是\)</span>B _{ i , j } = 0 <span class="math inline">\(的那对\)</span>( i , j )
$.到这里已经可以猜到,这题不是什么正经题,应该要搞一些随机化东西.</p>
<p>想起来之前那个经典判断$A B = C
$的题,就是随机几个向量然后乘起来.这个我们想想能不能类似做.</p>
<p>先考虑$k = 2 <span class="math inline">\(,如果\)</span>A A ^T $是全$1
<span class="math inline">\(矩阵,那么我们随机一个向量去乘它,得到的向量每一位必然都是这个向量所有数字之和.不难发现如果这个向量每一位差别足够大就可以check,这就提供了一个\)</span>O
( nd ) <span class="math inline">\(的做法,不过我们实现肯定造不出差别足够大的向量,因此可以多check几次.然后如果第\)</span>i
<span class="math inline">\(行不满足条件,一定存在一组\)</span>( i , j )
<span class="math inline">\(作为答案,枚举\)</span>j $即可.</p>
<p>再考虑$k = 3 $,这个有点难搞.实际上是一个牛逼发现:$1 ^2 ^2 <span class="math inline">\(.因此我们考虑将\)</span>B <span class="math inline">\(矩阵的每一位平方后与一个向量相乘.考虑\)</span><em>{
j } B </em>{ i , j } ^2 r <em>j = </em>{ j } B <em>{ i , j } r <em>j B
^T </em>{ j , i } <span class="math inline">\(,考虑构造矩阵\)</span>R
<span class="math inline">\(,使得\)</span>R </em>{ i , i } = r <em>i , R
</em>{ i , j } = 0 , i j <span class="math inline">\(,不难发现\)</span>(
BR ) <em>{ i , j } = B </em>{ i , j } R <em>{ j , j } <span class="math inline">\(,于是\)</span>( BRB ^T ) </em>{ i , i } = <em>{ j
} B </em>{ i , j } R <em>{ j , j } B ^T </em>{ j , i }
$.接下来我们只要check $BRB ^T <span class="math inline">\(的对角线即可.然后\)</span>B ^T = ( AA ^T ) ^T = {
A ^T } ^T A ^T = AA ^T $.于是有:</p>
<p><span class="math display">\[
BRB ^T = AA ^T RAA ^T
\]</span></p>
<p>考虑$A <span class="math inline">\(是一个\)</span>n d <span class="math inline">\(的矩阵,\)</span>A ^T <span class="math inline">\(是一个\)</span>d n <span class="math inline">\(的矩阵.不妨假设我们已经算出了\)</span>A ^T RA
<span class="math inline">\(,那这里是好算的,因为\)</span>( ABC ) <em>{ i
, i } = </em>{ j , k } A <em>{ i , k } B </em>{ k , j } C _{ j , i }
<span class="math inline">\(,这里可以\)</span>O ( nd ^2 )
$地check每一个位置.</p>
<p>那我们现在面临的问题就是如何去求出来$A ^T RA <span class="math inline">\(.注意到\)</span>RA <span class="math inline">\(是一个\)</span>n d <span class="math inline">\(的矩阵,因此如果知道\)</span>RA <span class="math inline">\(,\)</span>A ^T ( RA ) <span class="math inline">\(是好求的.我们现在需要求出\)</span>RA <span class="math inline">\(.由于\)</span>R <span class="math inline">\(是对角线矩阵,\)</span>( RA ) <em>{ i , j } = R
</em>{ i , i } A _{ i , j } <span class="math inline">\(,这样就可以\)</span>O ( nd ) $求.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P6772</p>
<p>典中典,首先如果是边权的话有个经典dp:设$dp _{ i , x } <span class="math inline">\(表示当前经过了\)</span>i <span class="math inline">\(条边,目前在\)</span>x
$点的最优答案,自然有转移:</p>
<p><span class="math display">\[
dp _{ i , x  } = \max \{ dp _{ i - 1 , y  } + val _{ y \rightarrow x  }
\}
\]</span></p>
<p>这是一个经典的${ , + } $矩阵,可以矩阵加速.</p>
<p>这个题不是边权,但是点权可以改成入边的边权,只不过起点需要特判.</p>
<p>还有一个问题是边权不是$1
$,拆边的话复杂度太高,考虑拆点,每个点拆成五个,然后只有最后一个点才会连出边,剩下的按照距离出边的距离连到前面的点.</p>
<p>至于美食节,一个想法是直接矩阵加速到那一天,然后把对应的点加上美食节的权值,继续做完每个美食节即可.但这样复杂度是$O
( kN ^3 T ) $的.</p>
<p>冷静一下,预处理出矩阵的二的次幂,这样就是$O ( kN ^2 T + N ^3 T )
$.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6125</p>
<p>简单题,建ACAM,然后对于每个人求答案.枚举每个人,对于每个点,设$p _i
$为以它为起点,最后这个人胜利的概率,做高斯消元即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3706</p>
<p>ps:本题选入笔记:概率与期望-概率生成函数-Example3.</p>
<p>把上面的东西给形式化一下,不妨设$g <em>i <span class="math inline">\(表示进行了\)</span>i <span class="math inline">\(步还未结束的概率,\)</span>f </em>{ k , i } <span class="math inline">\(为进行了\)</span>i <span class="math inline">\(步恰好第\)</span>k <span class="math inline">\(个人胜利的概率,\)</span>F , G
$是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p>$1 + xG ( x ) = _k F _k ( x ) + G ( x ) $.</p></li>
<li><p>$( { 2 } x ) ^L G ( x ) = _{ j = 1 } ^n F <em>j ( x ) </em>{ i =
0 } ^{ L - 1 } ( { 2 } x ) ^i [ A _k ^{ ( L - i ) } = { A <em>j } </em>{
( L - i ) } ] $.</p></li>
</ol>
<p>第一个式子的用处在于带入$x = 1 <span class="math inline">\(,发现\)</span>_{ k } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{
L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  }
&amp; = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{
L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } &amp; = { A
_j  } _{ ( i )  } ]
\end{aligned}
\]</span></p>
<p>带入$x = 1 $,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [
A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]
\]</span></p>
<p>不难发现对于不同的$k <span class="math inline">\(,(2)的右边不同,而左边一定相同,这样就给出了\)</span>n
<span class="math inline">\(个等式,算上(1)一共有\)</span>n + 1 <span class="math inline">\(个等式,可以算出\)</span>G ( 1 ) , F _{ 1 n } ( 1 )
<span class="math inline">\(这\)</span>n + 1 $个未知数.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3292</p>
<p>首先第一反应是树剖+线段树上合并线性基,轻松做到$O ( q ^2 n ^2 v )
$.</p>
<p>但是过不太去!注意到$n <span class="math inline">\(要小一点,考虑离线点分治.记录下从分治中心到每个点的线性基,这样只需要做\)</span>q
<span class="math inline">\(次线性基合并,复杂度是\)</span>O ( q ^2 v + n
n v ) $.</p>
<p>不过如果你做过CF1100F,那这题就是上个树.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4151</p>
<p>典中典,注意到一个值异或两遍就会没掉.我们考虑随便求一条$S T
$的路径,然后再求出来所有的环上的异或值.我们发现我们可以走到一个简单环上,走一圈再原路返回,这样答案只会异或上简单环的异或值.对这个东西用线性基就行.</p>
<p>至于这个东西的正确性,首先考虑$S T <span class="math inline">\(唯一的情况,这样的话你如果要扩展就必须走环.不然,则\)</span>S
T $有边在环上,只要溜达一圈就行.</p>
<p>接下来的问题在于找简单环.我们直接dfs,就可以找到一部分环.但是其实是没有找到全部的环的.但是没关系,在dfs的过程中,dfs树不可能有横插边,也就是所有找到的的环不在树上的边一定是反走边.而没有找到的环可能是若干个反走边拼起来的.这必然意味着它可以由那些反走边所代表的环拼起来:原因比较简单,考虑从上往下遍历这个没找到的环,那么每条边一定被经过了两次:下去一次,上来一次.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P6178</p>
<p>板子题</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P4455</p>
<p>板子题</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4336</p>
<p>简单题,无脑矩阵树定理+容斥.复杂度$O ( 2 ^n n ^3 ) $.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P5807</p>
<p>板子题</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF917D</p>
<p>一眼二项式反演.不妨设$f _i <span class="math inline">\(表示钦定\)</span>i $条边已经选上了的答案.显然:</p>
<p><span class="math display">\[
ans _k = \sum _{ i \geq k  } ( - 1 ) ^{ i - k  } \binom { i  } { k  } f
_i
\]</span></p>
<p>对于$f _i <span class="math inline">\(,考虑Prufer序列的推论:\)</span>k <span class="math inline">\(个大小分别为\)</span>s _1 , s _2 , , s <em>k <span class="math inline">\(的连通块,任意加边使得连通块成树的方案数是\)</span>n
^{ k - 2 } s <span class="math inline">\(.于是考虑dp,不妨设\)</span>dp
</em>{ x , i , j } <span class="math inline">\(表示当前\)</span>x <span class="math inline">\(为根的子树内部,当前\)</span>x <span class="math inline">\(所在连通块的大小是\)</span>i <span class="math inline">\(的方案数,这样可以做到\)</span>O ( n ^3 ) $.</p>
<p>看了看题解发现可以做到$O ( n ^2 ) <span class="math inline">\(.简单来说就是考虑\)</span>s <span class="math inline">\(的组合意义,是在每个连通块内选一个点的方案数.那我们可以用\)</span>f
_{ i , j , 0 / 1 } <span class="math inline">\(表示当前\)</span>i <span class="math inline">\(子树内选了\)</span>j <span class="math inline">\(个点,然后\)</span>i
$所在连通块内是否选点了的方案数.</p>
<h3><span id="计算几何">计算几何</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2742</p>
<p>板子题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3829</p>
<p>简单题,注意到圆弧之和一定是一个圆,因此把角上的四个点拿出来做凸包即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4196</p>
<p>板子题.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3256</p>
<p>板子题.甚至</p>
<h4><span id="第五题第六题第七题">第五题/第六题/第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P1742</p>
<p>https://www.luogu.com.cn/problem/P2533</p>
<p>https://www.luogu.com.cn/problem/P4288</p>
<p>三个题全是一样的.</p>
<p>大概是这么做的啊,就是说我们增量构造,每次对于前$i <span class="math inline">\(个点的最小覆盖圆,考虑\)</span>i + 1 <span class="math inline">\(个点在不在圆上.如果在就忽略,不在的话,那它必然是新圆的一个卡着边的点.考虑再找到另两个卡着边的点,我们暴力枚举这两个点.并且计算出所有的圆,挑选面积最大的那个.事实上,可以直接每次更新圆,直到这个圆包含了前\)</span>i
+ 1 $个点,显然总会遇到,然后之后就不会更新这个圆了.</p>
<p>这个写法导致了复杂度正确.具体来说,考虑一个点成为卡着圆边界的点的概率是$
{ n } $,这三层循环的调用次数分别是:</p>
<p><span class="math display">\[
\begin{aligned}
T _3 ( n ) &amp; = O ( n ) \\
T _2 ( n ) &amp; = O ( n ) + \sum _{ i = 1  } ^n \frac { 3  } { i  } T
_3 ( i ) \\
T _1 ( n ) &amp; = O ( n ) + \sum _{ i = 1  } ^n \frac { 3  } { i  } T
_2 ( n )
\end{aligned}
\]</span></p>
<p>显然$T _1 ( n ) = O ( n ) $.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P2287</p>
<p>枚举三个点,然后判断这三个点所在平面是否是三维凸包的一个面.注意四点共面就完蛋了,因此每个点加上一个随机扰动量.这个量首先得在eps范围内显著体现出来,其次还不能对答案影响太大.这个题是直接给了一个小于$10
^{ - 10 } $的扰动量,然后因为没有判相等操作,直接用了c++的浮点数比较.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P1452</p>
<p>板子题.</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6247</p>
<p>板子题.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3187</p>
<p>旋转卡壳的时候维护三个边界就行.</p>
<h3><span id="网络流建图">网络流建图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>Hall引理的时候做过.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF311E</p>
<p>发现变$0 $变$1 $这个操作可逆,不妨先把所有位置都变成$1 $.</p>
<p>接下来考虑把若干个$1 $变成$0 $.不难发现:一个全$0 <span class="math inline">\(的要求合法\)</span>$所有包含位置都是$0 <span class="math inline">\(\Leftrightarrow\)</span>所 有 包 含 位 置 都 不 是
<span class="math inline">\(1\)</span>$包含这些的全$1
$要求不合法.这是一个最大权闭合子图问题.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF884F</p>
<p>直接费用流,考虑左边每个点是字母,然后连到右边的点上,拆一下点保证对应的位置不会有相同字母.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF802C</p>
<p>牛逼题,考虑我们不好搞这个丢弃的东西,因为你也不知道你留下来的是谁.因此我们考虑如果一本书不在当天丢弃,那就一定会对下本书产生贡献,我们把它当成将书卖出.</p>
<p>也就是说,考虑将每一天建点,上面这个过程保证了我们每一天的书都会买,这就保证了最大流量.</p>
<p>将每一天建点并以流量为$k - 1
$的边相连(因为下一天必须买书),然后如果这本书要留着,就在前一天卖掉.</p>
<p>但是这样需要保证,我们卖书的时候必定在前面没有丢弃这本书,拆点维护,用一个点同时维护当天丢弃和卖书两种操作即可.</p>
<p>点数是$2 n <span class="math inline">\(的,边数有拆点的\)</span>n
<span class="math inline">\(条,连接相邻两天的\)</span>n
$条,卖出的和丢弃的共$2 n $条,这样总共是$4 n $条边.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF786E</p>
<p>一眼最小割,然后线段树+树剖优化建图.注意这样是$O ( n ^2 n ) <span class="math inline">\(的建图,我们把树剖跳topn的过程建一个点,这样就是\)</span>O
( n n ) $的建图.</p>
<p>考虑点数,原图有$n $个点,线段树是$2 n <span class="math inline">\(个点,树剖只会贡献\)</span>n $个点,点数是$4 n
$的.</p>
<p>考虑边数,注意到一个点会连$2 n <span class="math inline">\(条边到树剖上,在最后一下会连\)</span>n
$个点到线段树上,因此总边数是$2 n + 3 m n ^6 $,但是显然远远跑不满.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1139E</p>
<p>第一反应是二分答案,然后拿网络流二分图匹配check,这样复杂度是$O ( n ^2
n ) $的.</p>
<p>事实上注意删人后答案只减不增,因此复杂度$O ( n ^2 ) $.</p>
<p>但是这样过不去,考虑把删除改成增加,这样就可以在残留网络上跑,然后就能过了.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1061E</p>
<p>考虑每个问题,其实是形如要保证子树内有一定数量的点不能选.也就是这个限制要和修建港口抢城市.</p>
<p>但是不同的限制可能限制了同一城市,我们发现深度更浅的那个限制数量可以减去深度较深的限制数量,毕竟较深的满足较浅的也就满足了.</p>
<p>但是这个思路建图好像有点不太对.因为两个树的港口是通用的,那考虑让一个限制是入,另一个限制是出.换句话说,让一个限制被源点流,另一个限制流向汇点,中间是树节点,源点连出去的边有一个权值,跑费用流.</p>
<p>注意到每个点只会被连一次,因此边数大概是$2 n $级别,点数是$3 n
$级别.</p>
<p>总之这种网络流题,主要还是要考虑谁连着源点,谁连着汇点.这个题我一开始以为是限制连源点,然后城市连汇点,发现做不了,那就两种限制分别连源点和汇点.</p>
<h3><span id="交互题练习">交互题练习</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5875</p>
<p>这是广义串并联图嘛?好像显然不是.</p>
<p>但是仍然有性质,如果没有点权的话,注意到(1)一定会选新加入的点,(3)也一定会选新加入的点,(2)则一定要么两者都选要么都不选.</p>
<p>现在有点权,考虑把新加入的点删了,不妨设新加入的点为$i <span class="math inline">\(,主持人为\)</span>x $,自然有:</p>
<ol type="1">
<li><p>$a _i ans , a _x : = { 0 , a _x - a _i } $.</p></li>
<li><p>$a _x : = a _x + a _i $.</p></li>
<li><p>$a _x : = { a _x , a _i } $.</p></li>
</ol>
<p>不难发现每一步操作做完后,答案都不会改变.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3641</p>
<p>牛逼题.</p>
<p>考虑答案最小是什么,根据鸽笼原理,显然是$B = { n - 1 } $.</p>
<p>所以我们按照值域每$B <span class="math inline">\(长度分块,然后考虑答案不可能出现在块内,也就是块内的点对不可能贡献答案,答案只有可能由上一个数字(也就是上一个查询到的\)</span>mx
<span class="math inline">\()和当前块的\)</span>mn <span class="math inline">\(贡献.这样一开始的贡献是\)</span>n + 1 <span class="math inline">\(,中间问了\)</span>n - 1 <span class="math inline">\(次,总共涉及到了\)</span>n - 2
$个数字,这样就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3777</p>
<h5><span id="sub1">Sub1</span></h5>
<p>minValue是好求的,我们考虑选取${ 1 , 0 , , 0 }
$,这样的话对手必然放弃一个,被放弃的那个就是最小的.</p>
<h5><span id="sub2">Sub2</span></h5>
<p>一个显然的想法是,如果我们一开始全选$1 <span class="math inline">\(,那么对手一定会选取\)</span>[ 51 , 100 ]
$中的所有数字.</p>
<p>然后呢?我们接下来考虑继续在$[ 51 , 100 ]
$这些数字中找到最大的.我们肯定要让它们全选$2 <span class="math inline">\(,这样对方可能会放弃一些这个区间中较小的数字,然后去选取\)</span>[
1 , 50 ] $中较大的一些.持续这个过程,发现正好需要四次操作.</p>
<h5><span id="sub3">Sub3</span></h5>
<p>考虑结合sub1和sub2,我们不妨询问${ x , x , 0 , 0 , } <span class="math inline">\(,这样直觉上总是存在一个\)</span>x
$使得前两个数字有一个被放弃.</p>
<p>事实上也确实.考虑前两个数字中较小的那一个,设为$v <span class="math inline">\(,当\)</span>_{ i = x } ^{ 2 x } i = { 2 } v <span class="math inline">\(的时候,显然它就会被放弃,对于这个最小的\)</span>x
<span class="math inline">\(,会发现两个数字中较大的那个(设为\)</span>w )
<span class="math inline">\(一定不会被放弃,因为如果它被放弃了,一定是因为\)</span>w
x - 1 <span class="math inline">\(,而我们知道\)</span> { 2 } &lt; v &lt;
w x - 1 <span class="math inline">\(,又因为\)</span>x
$,因此显然不成立.</p>
<p>二分这个$x <span class="math inline">\(,由于\)</span>v _{ } = 99
<span class="math inline">\(,发现\)</span>x $,直接二分需要四次.</p>
<p>然后有个牛逼做法是,考虑每个$x <span class="math inline">\(能控制一个区间的\)</span>v <span class="math inline">\(,发现\)</span>x = 7 <span class="math inline">\(的那个区间全部被覆盖了两次,因此不用选取\)</span>x
= 7 $.</p>
<h5><span id="sub4">Sub4</span></h5>
<p>这个简单,不难发现只需要在$B _i = B _j = 100
$,那么对手就必然需要在这两者中选一个留下来,这样我们就可以比较任意两个位置的大小,使用stable_sort即可.</p>
<h5><span id="sub5">Sub5</span></h5>
<p>一种想法是sub4+sub3,但过不去.</p>
<p>冷静思考,注意到sub2,我们其实是知道了某些位置在哪个权值区间的.对着这个分治下去,这样实现了划分区间的功能,按理说应该是会有$2
n - 1 $个节点.</p>
<p>冷静一下,$l = r <span class="math inline">\(的叶子节点是不用计算的,因此刚好玩了\)</span>n - 1
$次.</p>
<p>现在唯一的问题是,我们怎么找到一个$w <span class="math inline">\(,使得这个区间内我都选\)</span>w <span class="math inline">\(后,然后这个区间一定会被划分呢?考虑\)</span>sub 3
<span class="math inline">\(告诉我们如果\)</span>r - l + 1 <span class="math inline">\(一定有解,考虑\)</span>( r , 100 ] <span class="math inline">\(的数字肯定要被选,那对方只剩下\)</span>r <span class="math inline">\(个石子,不妨直接令\)</span>w = { r - l + 1 } + 1
<span class="math inline">\(,注意到这个区间一定选不满.并且由于\)</span>r
- l + 1 &gt; 12 $,因此你会发现前面即使全选了也有剩余.</p>
<p>实际的写法选择了直接枚举$w $,然后判断是否合法.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P4373</p>
<p>这怎么做!考虑分块.(这谁想得到啊)</p>
<p>不妨设$f <em>i <span class="math inline">\(表示\)</span>[ i , i + k -
1 ] <span class="math inline">\(的最小值,我们先求出来\)</span>f </em>{ 0
} , f <em>{ B } , f </em>{ 2 B } , <span class="math inline">\(的值.这个怎么求呢?考虑一个值什么时候有用:如果它比队列末尾优秀肯定有用,不然只有它是\)</span>B
<span class="math inline">\(的倍数,它才有可能有用.我们只去维护这两种情况,就可以做到\)</span>O
( ) $的空间.</p>
<p>然后考虑剩下的$( iB , ( i + 1 ) B ) <span class="math inline">\(这些答案怎么求.不难发现这些的\)</span>f <span class="math inline">\(一定大于等于\)</span>f <em>{ iB } <span class="math inline">\(并且小于等于\)</span>f </em>{ ( i + 1 ) B } <span class="math inline">\(.如果直接对这个做单调队列空间还是不足,但我们发现做单调队列的时候,会被弹出的只有\)</span>[
f <em>{ iB } , ( i + 1 ) B ) <span class="math inline">\(这些数字,剩下的只要右端点卡到它,就一定不会被弹出.因此只需要对前面这个东西做单调队列,直到做到\)</span>f
</em>{ ( i + 1 ) B }
$出现,那我们就停下来,把前面该输出的答案全部输出.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P5473</p>
<p>考虑异或能实现的是判断奇偶性,具体来说,我们很容易判断一个点到一个集合内部点的奇偶性.考虑这样其实已经能$O
( n )
$找到一个点了:我们每修改一个前缀,然后check所有不在这个前缀内的点,这样就可以知道它俩是有边的.</p>
<p>这个过程能不能二分呢?好像不能,那我们随机化.</p>
<p>换句话说,我们random_shuffle一下序列,然后分治,每次把左侧的点全部点亮,然后看右侧的点有没有发生变化.如果发生了,则说明左侧的点到右侧的点的边的数量是奇数,递归下去处理,就可以至少连一条边,把这条边删了继续做.</p>
<p>然后发现这么写有个$L _c = 0 <span class="math inline">\(的\)</span>B
<span class="math inline">\(包过不去啊,那个包可以考虑我们对于一个点\)</span>x
<span class="math inline">\(,二分\)</span>[ 0 , x - 1 ] <span class="math inline">\(中谁是它的父亲.不难发现如果把\)</span>[ 0 , k ]
$这个前缀全部modify掉,并且它父亲在里面,那它当前状态一定是$1
$.用整体二分解决这个问题.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6541</p>
<p>考虑动态点分树.每次找到一对点$x , y <span class="math inline">\(,\)</span>x <span class="math inline">\(已知,\)</span>y <span class="math inline">\(未知,然后explore(x,y).如果得到的是未知的点,那就不断操作直到得到\)</span>y
$.</p>
<p>反之,考虑得到了$z <span class="math inline">\(,由于\)</span>z <span class="math inline">\(已知,因此\)</span>z <span class="math inline">\(在我们的点分树上.不妨从\)</span>z <span class="math inline">\(暴力向上跳到\)</span>x <span class="math inline">\(,这样就可以知道\)</span>y <span class="math inline">\(在\)</span>x
$的哪个方向,往那个方向的点分树儿子走一步即可.</p>
<p>至于动态点分树怎么做,替罪羊重构即可.</p>
<p>至于链,我们每次随机一个没有搞定的点,走过去即可.期望的错误次数是$O ( n
) $的.</p>
<h3><span id="模拟退火">模拟退火</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2503</p>
<p>考虑如果要求有序划分,可以直接写一个dp.</p>
<p>因此我们考虑每次交换几个位置,然后当成有序的跑dp,用这个来模拟退火.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2538</p>
<p>随机交换两个城市的状态即可.如果为了复杂度更好一点可以要求交换的城市状态必然不同.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5544</p>
<p>这题退火退半天退不出来,但是爬山直接过了.</p>
<p>这是为啥呢?原因在于,这题我们既然要对坐标进行跳跃,很有可能大部分坐标的答案都是$0
$.这就必然导致了我们一开始可能跳到了很远的地方,但是由于一直是$0
$,因此不断地跳过去.很难蚌.</p>
<p>而爬山不会有这种问题.</p>
<p>有没有什么改良的方式?一种是改变估价函数,通过精细实现估价函数导致其估价为连续实数函数,这样退火的效果就会好很多.</p>
<p>总的来说,退火失败的地方在于它一开始跳跃得太远了.而由于前几次操作我们跳出去的概率很大,因此极难得到答案.对于这种跳跃性不确定的题,反而你发现爬山不会拘束于局部最优解,而是会跳出去的.这也就是爬山在这题表现极其良好的原因.</p>
<p>有没有什么更优秀的方式呢?我们考虑先爬几次山,爬到一个好地方,然后以这个位置开始退火往旁边跳.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P7218</p>
<p>考虑一个显然的贪心是,直接枚举每个$W $,能放就放.</p>
<p>考虑把一开始所有能放的$W
$全拿出来作为一个操作序列,然后用模拟退火打乱.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1105E</p>
<p>不妨考虑满足某个人要求,就一定要在一段时间内全是它的id.也就是说如果两个人都抢了一段时间,那这两个人不能同时选择.</p>
<p>这也就是一个最大团问题,模拟退火解决一下.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="kmp">KMP</span></h3>
<h5><span id="example1zr23省选第一轮集训day5b">Example1(zr23省选第一轮集训day5b)</span></h5>
<p>必须提一下的是,能用KMP的前提是可以比较两个字符串是否相等,不一定是比较两个字母相等.只要能比较两个字符串是否相等,并且已知$A
= B <span class="math inline">\(能快速判断是否有\)</span>A + a = B + b
<span class="math inline">\(,那么就可以使用KMP.并不要求\)</span>A = B
<span class="math inline">\(并且\)</span>a = b <span class="math inline">\(才有\)</span>A + a = B + b $.</p>
<p>因此,我们取$p <span class="math inline">\(的置换\)</span>q <span class="math inline">\(,然后找到所有和\)</span>q
$的大小关系一样的区间即可,要证明这是个等价关系,然后就可以上KMP了.</p>
<h5><span id="example2noi2014-动物园">Example2(NOI2014 动物园)</span></h5>
<p>自然的想法是先求border数组,然后每次暴力跳border直到当前前后缀不重叠.根据border的定义显然是对的.但这样复杂度不对.</p>
<p>另一个想法是我们能不能在做KMP的时候,直接判掉当前长度是否超过,如果超过就放弃呢?也不对,因为这样往前跳也会用到这个border数组,但往前跳有可能跳的很少.</p>
<p>因此我们先求border,再第二遍做KMP,用另一个数组,但是往前跳的时候用border跳,其他情况正常做就行.</p>
<h3><span id="border理论">border理论</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p>$s <span class="math inline">\(的某个border长度为\)</span>k <span class="math inline">\(等价于\)</span>| s | - k <span class="math inline">\(是\)</span>s $的周期.</p>
<p>证明显然.</p>
<h5><span id="定理2周期引理">定理2(周期引理)</span></h5>
<p>弱周期引理:如果$p , q <span class="math inline">\(是\)</span>s <span class="math inline">\(的周期且\)</span>p + q | s | <span class="math inline">\(,那么\)</span>( p , q ) <span class="math inline">\(是\)</span>s $的周期.</p>
<p>考虑分开两面证明,不妨设$p &gt; q , r = p - q <span class="math inline">\(,先证明\)</span>i &gt; q , s <em>i = s </em>{ i +
r } <span class="math inline">\(,事实上\)</span>s <em>i = s </em>{ i - q
} = s <em>{ i - q + p } = s </em>{ i + r } <span class="math inline">\(.再考虑证明\)</span>i | s | - p , s <em>i = s
</em>{ i + r } <span class="math inline">\(,事实上\)</span>s <em>i = s
</em>{ i + p } = s <em>{ i + p - q } = s </em>{ i + r } $.</p>
<p>由于$p + q | s | <span class="math inline">\(,因此上面那个证明对所有\)</span>i
$成立,由此得证.</p>
<p>强周期引理:如果$p , q <span class="math inline">\(是\)</span>s <span class="math inline">\(的周期且\)</span>p + q - ( p , q ) | s | <span class="math inline">\(,那么\)</span>( p , q ) <span class="math inline">\(是\)</span>s $的周期.</p>
<p>这个有一个生成函数证明.简单来说我们不妨设长度为$p <span class="math inline">\(的那个周期的生成函数为\)</span>P ( z ) <span class="math inline">\(,它是一个\)</span>p - 1 <span class="math inline">\(次的生成函数.同理定义\)</span>Q ( z ) <span class="math inline">\(.不妨设\)</span>S _p ( z ) = { 1 - z ^p } <span class="math inline">\(,同理定义\)</span>S _q ( z ) $.</p>
<p>如果我们能说明$S _p ( z ) = S _q ( z ) <span class="math inline">\(,由于这两个都是无穷项,由欧几里得算法立刻得到\)</span>(
p , q ) $是其周期.考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S _p ( z ) - S _q ( z ) \\
&amp; = \frac { P ( z )  } { 1 - z ^p  } - \frac { Q ( z )  } { 1 - z
^q  } \\
&amp; = \frac { 1 - z ^g  } { ( 1 - z ^p ) ( 1 - z ^q )  } ( \frac { 1 -
z ^q  } { 1 - z ^g  } P ( z ) - \frac { 1 - z ^p  } { 1 - z ^g  } Q ( z
) )
\end{aligned}
\]</span></p>
<p>此时注意到括号里面的那个东西的次数有限,设其为$H ( z ) <span class="math inline">\(,不难发现\)</span>H ( z ) <span class="math inline">\(的次数是\)</span>p + q - g - 1 <span class="math inline">\(.若\)</span>H ( z ) <span class="math inline">\(,又因为\)</span> { ( 1 - z ^p ) ( 1 - z ^q ) }
$的常数项不为$0 <span class="math inline">\(,因此\)</span> k p + q - g -
1 , [ z ^k ] ( S _p ( z ) - S _q ( z ) ) <span class="math inline">\(,但根据假设,\)</span> k n - 1 p + q - g - 1 <span class="math inline">\(,应该有\)</span>[ z ^k ] ( S _p ( z ) - S _q ( z )
) = 0 <span class="math inline">\(,因此\)</span>H ( z ) = 0 <span class="math inline">\(,因此\)</span>S _p ( z ) = S _q ( z ) $.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若$S <span class="math inline">\(是\)</span>T <span class="math inline">\(的前缀,且\)</span>T <span class="math inline">\(有周期\)</span>a <span class="math inline">\(,\)</span>S <span class="math inline">\(有整周期\)</span>b <span class="math inline">\(,\)</span>b | a , | S | a <span class="math inline">\(,则\)</span>T <span class="math inline">\(有周期\)</span>b $.证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>若$2 | S | | T | <span class="math inline">\(,则\)</span>S <span class="math inline">\(在\)</span>T $中的匹配位置必为等差序列.</p>
<p>证明考虑WPL就行.</p>
<h5><span id="定理5">定理5</span></h5>
<p>$S <span class="math inline">\(的长度大于等于\)</span> { 2 }
$的border长度构成一个等差序列.</p>
<p>不妨设最长的border长度为$n - p <span class="math inline">\(,还有一个border长度是\)</span>n - q <span class="math inline">\(,\)</span>q &gt; p <span class="math inline">\(,那么必有长度为\)</span>n - ( p , q ) <span class="math inline">\(的border.注意到\)</span>n - p <span class="math inline">\(是最长的border,则\)</span>( p , q ) p <span class="math inline">\(,\)</span>p | q $.</p>
<h5><span id="定理6">定理6</span></h5>
<p>一个串的所有border按照长度排序后,可以被划分成$O ( n )
$个等差序列.</p>
<p>首先,将该串的长度$ { 2 } <span class="math inline">\(的border拿出作为一个等差序列.考虑这些中长度最小的\)</span>T
$.</p>
<p>再考虑最小循环节$d <span class="math inline">\(,如果\)</span>d { 4 }
<span class="math inline">\(,那么不断减小一定有\)</span>| T | { 4 } n
<span class="math inline">\(.反之则最长border本身就\)</span> { 4 } n
<span class="math inline">\(,于是剩下的border都是\)</span>T <span class="math inline">\(的border.这样就证明了\)</span>O ( n ) <span class="math inline">\(,事实上更紧凑的界是\)</span>_2 | S | $,不会证.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poi2011okr-periodicity">Example1([POI2011]OKR-Periodicity)</span></h5>
<p>注意到一个事实:如果这个字符串存在长度为$k <span class="math inline">\(的周期,等价于存在长度为\)</span>len - k
$的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设$q $为最小周期,如果$2 q &lt; n <span class="math inline">\(,也就是原串能写成\)</span>tt t ’ <span class="math inline">\(的形式.我们不妨先求\)</span>tt ’ <span class="math inline">\(对应的答案,然后在前面拼\)</span>t <span class="math inline">\(.根据\)</span> { 2 }
$的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果$2 q n <span class="math inline">\(,此时必定有\)</span>s = tat
<span class="math inline">\(,其中\)</span>t <span class="math inline">\(是border.考虑递归求解\)</span>t <span class="math inline">\(,然后就只需要找到一个\)</span>a <span class="math inline">\(满足条件,最小的\)</span>a $是全$0
$,能放的话肯定放,不然我们就放一个$0 $.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全$0 $不合法:</p>
<ol type="1">
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l |
t | + | a | <span class="math inline">\(:考虑\)</span>l
$的最后一段是一段全$0 <span class="math inline">\(,也就必然意味着\)</span>t $的最后一段是全$0
$,这么不断推下去就可以说明整个序列都是全$0 $,此时放上$0
$必定合法.</p></li>
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l
&gt; | t | + | a | <span class="math inline">\(:不妨设当前的\)</span>l
<span class="math inline">\(是最大的那个(最小的无意义,因为需要保证\)</span>| l
| &gt; | t | <span class="math inline">\(),此时最短周期必然是\)</span>d
= 2 | t | + | a | - l <span class="math inline">\(.由于\)</span>| t | +
| a | <span class="math inline">\(也是周期并且二者之和\)</span>n <span class="math inline">\(,因此必然有\)</span>d | ( | t | + | a | ) <span class="math inline">\(.把\)</span>ta <span class="math inline">\(按照\)</span>d <span class="math inline">\(长度划分.如果\)</span>d | a | $必有该串是全$0
<span class="math inline">\(串,不然考虑此时\)</span>d = | b | + | a |
<span class="math inline">\(,\)</span>b <span class="math inline">\(是\)</span>t <span class="math inline">\(的一段后缀.考虑此时的周期必然\)</span>&lt; | b | +
| a | <span class="math inline">\(,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比\)</span>|
b | - | a | <span class="math inline">\(少了\)</span>w <span class="math inline">\(,那么此时必定有\)</span>b <span class="math inline">\(的前\)</span>w $个字符是$0 $,但是由于$0 <span class="math inline">\(后面第一个\)</span>b <span class="math inline">\(也往前平移了\)</span>w <span class="math inline">\(格,因此它的第\)</span>w $个字符必定是$1
$,这就保证了$0 1 $必定合法.</p></li>
</ol>
<h3><span id="sa">SA</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个长度为$n <span class="math inline">\(的字符串,要从中从左往右选出若干段不相交的子串,使得选出的这些串中,每个串都是上一个串的严格子串.求最多能选出多少段.\)</span>n
^5 $.</p>
<p>不难发现一定有一组答案每段的长度是$k , k - 1 , , 2 , 1
$,我们不妨把串反过来,这样就是$1 , 2 , , k - 1 , k <span class="math inline">\(.这样就可以设计一个简单的dp是\)</span>f _{ i , j }
<span class="math inline">\(表示以\)</span>i <span class="math inline">\(结尾,\)</span>i <span class="math inline">\(这段长度为\)</span>j <span class="math inline">\(是否可行,发现单调性后把dp状态扔进值里,\)</span>f
_i <span class="math inline">\(表示以\)</span>i <span class="math inline">\(结尾的最大长度是多少,这样用SA做lcp就可以实现\)</span>O
( n ^2 ) <span class="math inline">\(.仔细观察转移过程,我们可以二分答案,然后用主席树+SA判断答案是否可行.复杂度\)</span>O
( n ^2 n ) $.</p>
<p>那么怎么优化呢?我们考虑类似height的证明:$f <em>i f </em>{ i - 1 } + 1
<span class="math inline">\(,原因很简单,如果\)</span>f <em>i &gt; f
</em>{ i - 1 } + 1 <span class="math inline">\(,那么我们把\)</span>f _i
<span class="math inline">\(那个序列的末尾字符全部删掉,自然得到了一个以\)</span>i
- 1 <span class="math inline">\(结尾,长度为\)</span>f <em>i - 1 &gt; f
</em>{ i - 1 } $的串,于是就可以类似height那样去掉二分,很厉害.</p>
<h3><span id="acam">ACAM</span></h3>
<p>用于对于每个文本串的前缀,求出它以哪些模式串为后缀.</p>
<h5><span id="example1uoj772企鹅游戏">Example1(uoj772企鹅游戏)</span></h5>
<p>考虑一个暴力:建出$s <span class="math inline">\(的AC自动机,然后我们记录fail树结构,然后把\)</span>t
<span class="math inline">\(放上去跑,每次暴力向上跳fail树上的匹配节点,这样的复杂度就是\)</span>O
( 匹 配 节 点 个 数 ) $.</p>
<p>但是这个复杂度是正确的.</p>
<p>为啥呢?首先对于任意节点,它在fail树上的祖先中匹配节点个数不可能超过$O
( ) <span class="math inline">\(个,这是个自然根号,因此复杂度至少是\)</span>O ( L )
$.</p>
<p>但还没完,考虑所有长度小于等于$B <span class="math inline">\(的模式串,他们会被匹配\)</span>O ( B | t | ) <span class="math inline">\(次.对于所有长度大于\)</span>B <span class="math inline">\(的模式串,考虑只有长度大于\)</span>B <span class="math inline">\(的文本串会匹配到他们,于是复杂度\)</span>O ( { B ^2
} ) <span class="math inline">\(,\)</span>B = L ^{ { 3 } } <span class="math inline">\(得到\)</span>O ( L ^{ { 3 } } ) $.</p>
<h5><span id="example2loj3396-novel">Example2(loj3396 novel)</span></h5>
<p>offline.</p>
<h3><span id="pam">PAM</span></h3>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li>本质不同回文串最多只有$n $个.</li>
</ol>
<p>证明:考虑类似manacher,每次将$S S + c <span class="math inline">\(,新产生的回文串一定是\)</span>S + c
$的最长回文后缀.</p>
<h4><span id="算法">算法</span></h4>
<p>回文自动机由转移边和fail树构成,经过一条转移边的影响是在前后均添加一个该字符,一个状态在fail树上指向它的最长回文border.</p>
<p>我们记录两个根:长度为$- 1 $的奇根和长度为$0
$的偶根,偶根的失配指针指向奇根.</p>
<p>增量构造,每次加入个新字符,然后在fail树上跳祖先直到$s <em>i = s </em>{
i - len - 1 } $.</p>
<p>继续跳这个节点,直到又遇到一个位置,那这个位置就是当前节点的fail指针所指向的点.这个操作是$O
( n )
$的,因为这个fail指针只有一个永远不会访问,另外的都会访问至少一次,在访问的时候就会均摊掉求的时候往上跳的复杂度,因为深度直接减去这玩意了.</p>
<h3><span id="sam">SAM</span></h3>
<ol type="1">
<li><p>$endpos ( T ) <span class="math inline">\(表示子串\)</span>T
<span class="math inline">\(在\)</span>S <span class="math inline">\(中出现位置的末尾集合,特别地,我们设\)</span>endpos
( ) = { 1 , , | S | - 1 , | S | } $.</p></li>
<li><p>若两个不同的子串的$endpos <span class="math inline">\(相等,则称它们为一个\)</span>endpos
$等价类.</p></li>
</ol>
<p>下面开始证明引理:</p>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li><p>字符串$s <span class="math inline">\(的两个非空子串\)</span>u
<span class="math inline">\(和\)</span>w <span class="math inline">\(的\)</span>endpos <span class="math inline">\(相同(假设\)</span>| u | | w | <span class="math inline">\(),当且仅当字符串\)</span>u <span class="math inline">\(在\)</span>s <span class="math inline">\(中的每次出现,都是以\)</span>w
$后缀的形式存在.</p></li>
<li><p>字符串$s <span class="math inline">\(的两个非空子串\)</span>u
<span class="math inline">\(和\)</span>w <span class="math inline">\(的\)</span>endpos <span class="math inline">\(集合的交为空(假设\)</span>| u | | w | <span class="math inline">\(),当且仅当字符串\)</span>u <span class="math inline">\(不是\)</span>w $的后缀.</p></li>
<li><p>字符串$s <span class="math inline">\(的两个非空子串\)</span>u
<span class="math inline">\(和\)</span>w <span class="math inline">\(的\)</span>endpos <span class="math inline">\(集合的交为\)</span>endpos ( w ) <span class="math inline">\((假设\)</span>| u | | w | <span class="math inline">\(),当且仅当字符串\)</span>u <span class="math inline">\(是\)</span>w $的后缀.</p></li>
</ol>
<p>证明都是显然的.</p>
<ol start="4" type="1">
<li>对于一个$endpos <span class="math inline">\(等价类中的子串\)</span>u
<span class="math inline">\(,要么\)</span>u <span class="math inline">\(是这个等价类中最短的子串,要么存在一个子串\)</span>w
<span class="math inline">\(且\)</span>| w | + 1 = | u | <span class="math inline">\(,\)</span>w <span class="math inline">\(是\)</span>u $的后缀</li>
</ol>
<p>由前面的引理,容易证明.</p>
<ol start="5" type="1">
<li>对于一个$endpos <span class="math inline">\(等价类中最短的子串\)</span>w <span class="math inline">\(,不妨设\)</span>v <span class="math inline">\(是\)</span>w <span class="math inline">\(去掉最前面的元素后得到的子串,那么\)</span>v <span class="math inline">\(在另一个\)</span>endpos <span class="math inline">\(等价类中,我们将\)</span>endpos ( w ) endpos ( v )
<span class="math inline">\(,记\)</span>link ( w ) = v <span class="math inline">\(或\)</span>fa ( w ) = v
$,这就是后缀链接link,这些关系构成树.</li>
</ol>
<p>首先除了$<span class="math inline">\(,每个\)</span>w $的出度都是$1
<span class="math inline">\(,而我们发现所有的子串都会以\)</span>$作为祖先,这就证明了连通性.</p>
<ol start="6" type="1">
<li>$endpos <span class="math inline">\(等价类的数量有\)</span>O ( n )
$个.</li>
</ol>
<p>考虑后缀链接树,显然一个点的$endpos <span class="math inline">\(集合包含它的所有儿子的\)</span>endpos <span class="math inline">\(集合的并,并且它所有儿子的\)</span>endpos
$集合两两无交,这等价于一个合并的过程.</p>
<h4><span id="约定">约定</span></h4>
<ol type="1">
<li><p>记$longest ( v ) <span class="math inline">\(为\)</span>v <span class="math inline">\(这个\)</span>endpos <span class="math inline">\(等价类中最长的一个字符串,记\)</span>len ( v )
<span class="math inline">\(为它的长度.类似地定义\)</span>shortest ( v )
<span class="math inline">\(和\)</span>minlen ( v ) <span class="math inline">\(,不难发现\)</span>minlen ( v ) = len ( fa ( v ) )
+ 1 <span class="math inline">\(.每个节点的子串数量也就是\)</span>len (
v ) - len ( fa ( v ) ) $.</p></li>
<li><p>记$siz ( v ) <span class="math inline">\(为\)</span>v <span class="math inline">\(这个\)</span>endpos <span class="math inline">\(等价类的\)</span>endpos $集合的大小.</p></li>
</ol>
<h4><span id="算法">算法</span></h4>
<p>先来捋一下整个过程:整个SAM分为两部分:</p>
<p>第一部分:后缀链接树(parent tree).</p>
<p>它的信息由下文中的fa记录.对于每一个节点:它对应一个endpos等价类,因此它拥有一个父亲节点,也就是后缀链接link指向的节点.同时它拥有一个len,表示这个endpos等价类中最长的子串的长度.</p>
<p>第二部分:trie图.</p>
<p>它的信息由下文中的son记录,表示一个endpos(设为x)通过一条trie边走到另一个endpos(设为y),不难发现x中的所有endpos+1所形成的集合包含y.我们注意这一点后,会发现只要从$<span class="math inline">\(所代表的节点不断地走trie边,最后走到的节点的对应长度的子串就是我们想要的子串.这也意味着我们要保证对应长度的子串一定在走到节点的子串集合中.另外有个结论是trie图的边数是\)</span>O
( n ) <span class="math inline">\(的.这必然要求走trie走到的那个节点的\)</span>len
<span class="math inline">\(的长度的区间包含了这个节点的\)</span>len
<span class="math inline">\(的长度的区间\)</span>+ 1 $.</p>
<p>也就是说,走trie边的过程是不断在字符串后面添加字符的过程,而走link的过程是不断在字符串前面删去字符串的过程(当然,反向link自然是不断在字符串前面加上另一个字符串集合的过程).</p>
<p>下面给出构造代码.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>&#123;</span><br><span class="line"><span class="type">int</span> fa;</span><br><span class="line"><span class="type">int</span> son[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> len,siz;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cntp=<span class="number">1</span>,las=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> End[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_c</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=++cntp;</span><br><span class="line">End[i]=x;tr[x].siz=<span class="number">1</span>;<span class="comment">//新建一个endpos=&#123;i&#125;</span></span><br><span class="line"><span class="comment">//End[i]存的是前缀[1,i]的结束位置,由于我们当前正在插入i,自然是x.</span></span><br><span class="line"><span class="type">int</span> prex=las;</span><br><span class="line">las=cntp;</span><br><span class="line"><span class="comment">//las存储的是当前的终止节点,其实也就是End[i],我们每次要找到上一次的终止节点,根据它来操作.</span></span><br><span class="line">tr[x].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==<span class="number">0</span>;prex=tr[prex].fa)tr[prex].son[c]=x;</span><br><span class="line"><span class="comment">//考虑当前的串:[1,i-1]+&#x27;c&#x27;,如果前面存在一个endpos集合包含[j,i-1](这个集合可能是空子串所在的集合)并且它存在一条&#x27;c&#x27;边,那么就存在这么一个子串[j,i-1]+&#x27;c&#x27;,它的endpos应该是&#123;i&#125;这个集合的祖先.</span></span><br><span class="line"><span class="comment">//如果在判断[j,i-1]的时候,发现[j,i-1]+&#x27;c&#x27;在原串中不存在,那么我们就直接连过来.可以发现在这个跳跃的过程中就是不断探索当前x的shortest的过程.</span></span><br><span class="line"><span class="keyword">if</span>(!prex)&#123;</span><br><span class="line"><span class="comment">//说明一直到最后都没有找到字母c,这也意味着c在前面根本没出现过,于是endpos=&#123;i&#125;的等价类是[1,i],[2,i],...,[i,i],所以父亲设为1.</span></span><br><span class="line">tr[x].fa=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> y=tr[prex].son[c];</span><br><span class="line"><span class="comment">//考虑这里的prex到底是什么意义,它意味着我们找到了一个最长的[j,i-1]的子串所在的endpos集合,并且[j,i-1]+&#x27;c&#x27;这个子串在原串存在,这也意味着[j,i-1]+&#x27;c&#x27;这个子串所在的endpos集合必然真包含&#123;i&#125;,而这个子串的长度是tr[prex].len+1.</span></span><br><span class="line"><span class="keyword">if</span>(tr[y].len==tr[prex].len+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果y这个节点的长度恰好也是tr[prex].len+1,那么必然意味着[j,i]这个子串完全就在y这里,而[j-1,i]这些子串不在y这里,但被y表示的endpos集合包含.</span></span><br><span class="line">tr[x].fa=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//反之,这里y这个节点的endpos集合就可以分成两部分了:第一部分的endpos集合在加入[j,i]这个子串后不变:因为它们的长度都大于tr[prex].len+1,它们必然不可能存在一个endpos是i.而第二部分,其实也只包含一个子串:就是长度等于tr[prex].len+1的子串,它的endpos集合必然是第一部分的endpos集合并上&#123;i&#125;,根据我们上面所发现的parent tree的本质是合并endpos集合的性质,它应该是第一部分以及&#123;i&#125;的父亲(也就是这两部分合并的结果),我们把第二部分拿出来单独建点.</span></span><br><span class="line"><span class="type">int</span> fay=++cntp;</span><br><span class="line">tr[fay]=tr[y];</span><br><span class="line">tr[fay].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line">tr[y].fa=tr[x].fa=fay;</span><br><span class="line"><span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==y;prex=tr[prex].fa)tr[prex].son[c]=fay;</span><br><span class="line"><span class="comment">//注意单独建点后,原本指向y的trie边要改向.这是为什么呢?考虑当前这条边是什么意义:它必然指向一个endpos集合要包含&#123;i&#125;的点,因为这样才能保证trie图的性质.此时指向y的点就不能是包含&#123;i-1&#125;的点了.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> que[MAXN&lt;&lt;<span class="number">1</span>],l,r;</span><br><span class="line"><span class="type">int</span> ind[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work_siz</span><span class="params">()</span></span>&#123;<span class="comment">//通过一次拓扑排序处理出siz</span></span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">++ind[tr[i].fa];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ind[i]==<span class="number">0</span>)que[++r]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="type">int</span> x=que[l];++l;</span><br><span class="line">tr[tr[x].fa].siz+=tr[x].siz;</span><br><span class="line">--ind[tr[x].fa];</span><br><span class="line"><span class="keyword">if</span>(ind[tr[x].fa]==<span class="number">0</span>)que[++r]=tr[x].fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是省掉了很多说明:比如这里的复杂度证明以及边数证明,但是我们咕了吧.</p>
<h4><span id="应用">应用</span></h4>
<h5><span id="检查字符串是否出现">检查字符串是否出现</span></h5>
<p>从根开始跳trie边就行.</p>
<h5><span id="不同子串个数">不同子串个数</span></h5>
<p>显然是$len <em>i - len </em>{ fa _i } $.</p>
<h4><span id="例题">例题</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给出一个长度为$n <span class="math inline">\(的小写字母串,你需要计算有多少对非空字符串\)</span>(
A , B ) $满足:</p>
<ol type="1">
<li><p>$AB $是原串的子串.</p></li>
<li><p>每次$A <span class="math inline">\(在原串中作为子串出现后,要么紧跟着出现一个子串\)</span>B
<span class="math inline">\(,要么\)</span>A <span class="math inline">\(后面放不下一个子串\)</span>B $.</p></li>
</ol>
<p>两个字符串被认为是不同的当且仅当他们在某个位置上字母不同,$| S | ^5
$.</p>
<p>首先,我们考虑确定$( AB , A )
$这个二元组,对反串建立SAM,我们自然有:</p>
<ol type="1">
<li><p>$AB <span class="math inline">\(的endpos集合是\)</span>A
$的endpos集合的后缀.</p></li>
<li><p>$A <span class="math inline">\(的endpos集合中存在的最大的不存在于\)</span>AB
<span class="math inline">\(的endpos集合的endpos的大小小于\)</span>| AB
| $.</p></li>
</ol>
<p>看到这里你可能有疑问:为啥要建立反串.因为不建立反串的话$( AB , B )
<span class="math inline">\(的endpos可能根本没啥区别,这个很难处理\)</span>A
$.SAM最强大的武器还是在于它能快速处理endpos.</p>
<p>那么接下来我们要在SAM上判断这两件事,我们需要一些更方便判断的条件.首先一个自然的发现是,$A
<span class="math inline">\(的最大的endpos必然也是\)</span>AB <span class="math inline">\(的最大的endpos,我们进行一个类似重链剖分的操作:将每个点的重儿子设为它所有儿子中最大的endpos最大的那个.不难发现此时的\)</span>A
<span class="math inline">\(与\)</span>AB <span class="math inline">\(必然在同一条重链上,且\)</span>A <span class="math inline">\(是\)</span>AB <span class="math inline">\(的祖先.不过显然这并不能保证一定是后缀,我们开始补条件,直到补到它充要:另一个显然的条件是,设\)</span>mx
_v <span class="math inline">\(表示节点\)</span>v <span class="math inline">\(的轻儿子中最大的endpos最大是多少,那么\)</span>A
<span class="math inline">\(与\)</span>AB <span class="math inline">\(间的所有\)</span>mx <span class="math inline">\(的最大值就是\)</span>A <span class="math inline">\(的endpos集合中存在的最大的不存在于\)</span>AB
<span class="math inline">\(的endpos集合的endpos的大小,它需要小于\)</span>| AB
| <span class="math inline">\(.进一步发现这个数字必然需要小于\)</span>AB
<span class="math inline">\(的endpos的集合中最小的那个(不然就不是后缀),这被包含于小于\)</span>|
AB | $这个条件.</p>
<p>接下来就拆重链,写单调栈就行.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式与生成函数</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2>
<h3><span id="复数相关">复数相关</span></h3>
<p>棣莫弗定理:$( cos + i ) ^n = ( n ) + i ( n ) $.</p>
<p>欧拉公式:$e ^{ i } = - 1 $.</p>
<p>也就是$e ^{ 2 i } = 1 <span class="math inline">\(,同时又有\)</span>e
^{ i } = cos + i · sin $,证明直接使用泰勒展开.</p>
<p>单位根:对于$x ^n = 1 <span class="math inline">\(,我们会有\)</span>n
<span class="math inline">\(个根,设第\)</span>k <span class="math inline">\(个根为\)</span>_n ^k <span class="math inline">\(.那么我们有:\)</span>_n ^k = e ^{ 2 { n } i } =
cos ( 2 { n } ) + i · sin ( 2 { n } ) $.</p>
<p>单位根有以下性质:</p>
<ol type="1">
<li><p>折半引理:$_{ 2 n } ^{ 2 k } = _n ^k \
$,由我们上面推导的通项公式即可证明.</p></li>
<li><p>消去引理:$_n ^{ k + { 2 } } = - _n ^k \
$,同样使用通项，运用三角恒等变换可证明.</p></li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4>
<p>上复平面,设$S _k = ( { n } , { n } ) <span class="math inline">\(,也就是\)</span>z _k = { n } + i { n } <span class="math inline">\(是方程\)</span>z ^n - 1 = 0
$的复根.我们把这个方程写开:</p>
<p><span class="math display">\[
z ^n - 1 = ( z - 1 ) ( z ^{ n - 1  } + z ^{ n - 2  } + \cdots + 1 ) = 0
\]</span></p>
<p>不难发现$z = 1 $是平凡解.</p>
<p>我们不妨定义$f ( x ) = <em>{ k = 1 } ^n ( 1 + X ^k ) = </em>{ k } a
_k X ^k $,事实上我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 1  } { n  } \sum _{ j = 1  } ^n f ( \omega _n ^j ) &amp; = \frac
{ 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k \geq 0  } a _k \omega ^{
kj  } _n \\
&amp; = \frac { 1  } { n  } \sum _{ k \geq 0  } a _k \sum _{ j = 1  } ^n
\omega _{ n  } ^{ kj  } \\
&amp; = \sum _{ j \geq 0  } a _{ jn  } + \frac { 1  } { n  } \sum _{ k
\geq 0 , n \nmid k  } a _k \frac { 1 - \omega ^{ nj  } _n  } { 1 -
\omega ^{ k  } _n  } \omega _{ n  } ^j \\
&amp; = \sum _{ j \geq 0  } a _{ jn  }
\end{aligned}
\]</span></p>
<p>事实上,我们令$d = { ( j , n ) } <span class="math inline">\(,容易发现\)</span>f ( <em>n ^j ) = ( </em>{ k = 1
} ^d ( 1 + _n ^{ kj } ) ) ^{ { d } } <span class="math inline">\(,又容易发现\)</span>n | jd $.</p>
接下来观察$X ^d - 1 = <em>{ k = 1 } ^d ( X - </em>{ n } ^{ kj } ) <span class="math inline">\(,带入\)</span>X = - 1 <span class="math inline">\(得到\)</span>f ( _n ^j ) =
<span class="math display">\[\begin{cases}2 ^{ \frac { n  } { d  }  }
&amp; d \in \text { odd  } \\ 0 &amp; d \in \text { even  }
\end{cases}\]</span>
<p>$.</p>
<p>接下来考虑拿到$<em>{ j } a </em>{ jn } <span class="math inline">\(,只需求\)</span> { n } <em>{ j = 1 } ^n f ( <em>n
^j ) = { n } </em>{ d , ( j , n ) = { d } } 2 ^{ { d } } = { n } </em>{
d } ( d ) 2 ^{ { d } } $.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5>
<p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现$+ , - , , , <span class="math inline">\(五种操作.而对于正\)</span>n <span class="math inline">\(边形,显然只要我们能将\)</span> { n }
$用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6>
<p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma _1 &amp; = z _1 + z _4 \\
\sigma _2 &amp; = z _2 + z _3
\end{aligned}
\]</span></p>
<p>不难验证:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma _1 + \sigma _2 &amp; = - 1 \\
\sigma _1 \sigma _2 &amp; = - 1
\end{aligned}
\]</span></p>
<p>可以求出复合条件的解,将$z $带入又有:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma _1 &amp; = 2 \cos \frac { 2 \pi  } { 5  } \\
\sigma _2 &amp; = 2 \cos \frac { 4 \pi  } { 5  }
\end{aligned}
\]</span></p>
<p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6>
<p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6>
<p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设$n prime <span class="math inline">\(,我们用\)</span>p <span class="math inline">\(代替\)</span>n $.</p>
<p>我们有$z _1 = { p } + i { p } <span class="math inline">\(,由于其它的\)</span>z <span class="math inline">\(都可以表示成它的幂,因此我们记\)</span>= z _1
$.</p>
<p>我们现在想要这么分组:</p>
<p><span class="math display">\[
\sigma _{ k + 1  } = \sum _{ 1 \leq l \leq p - 1 , f ( l , k ) = 1  }
\varepsilon ^l
\]</span></p>
<h3><span id="泰勒展开">泰勒展开</span></h3>
<p>即$f ( x ) = g ( x ) = f ( x <em>0 ) + </em>{ k } { k ! } ( x - x _0
) ^k \ <span class="math inline">\(.\)</span>x _0 = 0
$的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2>
<h3><span id="多项式基础">多项式基础</span></h3>
<h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4>
<p>代数基本定理:一个$n - 1 <span class="math inline">\(次方程在复数域上有且只有\)</span>n - 1 $个根.</p>
<p>定理:一个$n - 1 <span class="math inline">\(次多项式在\)</span>n
$个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个$n - 1 <span class="math inline">\(次多项式\)</span>A ( x ) <span class="math inline">\(和\)</span>B ( x ) <span class="math inline">\(且有\)</span>i , A ( x _i ) = B ( x _i ) \ $.</p>
<p>令$C ( x ) = A ( x ) - B ( x ) <span class="math inline">\(,那么\)</span>C ( x ) <span class="math inline">\(至多是一个\)</span>n - 1 <span class="math inline">\(次多项式且\)</span>i , C ( x _i ) = 0 \ <span class="math inline">\(,也就是\)</span>C ( x ) <span class="math inline">\(有\)</span>n $个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:$A ( x ) = _{ i = 0 } ^{ n - 1 } a _i x ^i \ $.</p>
<p>点值表示法:$y <em>i = </em>{ j = 0 } ^{ n - 1 } a _j x _i ^j \ $.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式$_{ i = 0 } ^{ n - 1 } y <em>i ( </em>{ j = 0 j i } ^{ n -
1 } { x _i - x _j } ) \ <span class="math inline">\(.显然当\)</span>x =
x _i <span class="math inline">\(时,该多项式的答案为\)</span>y _i $.</p>
<p>另外,如果$x _i = i $,不难发现这个式子可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^{ n  } y _i ( \prod _{ j = 1 \land j \ne i  } ^{ n  }
\frac { x - x _j  } { x _i - x _j  } ) \\
\\
&amp; = \sum _{ i = 1  } ^n y _i ( \prod _{ j = 1 \land j \ne i  } ^n
\cfrac { x - j  } { i - j  } ) \\
&amp; = \sum _{ i = 1  } ^n y _i ( - 1 ) ^{ n - i  } ( \cfrac { 1  } { (
i - 1 ) ! ( n - i ) !  } \prod _{ j = 1 , j \ne i  } ^{ n  } ( x - j ) )
\end{aligned}
\]</span></p>
<h3><span id="多项式运算">多项式运算</span></h3>
<p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4>
<h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5>
<h6><span id="dft">DFT</span></h6>
<p>将$n <span class="math inline">\(次单位根(默认\)</span>n <span class="math inline">\(是二的整次幂,如果少了的话补零,设\)</span>n = 2 ^w
<span class="math inline">\()分别带入\)</span>A ( x ) <span class="math inline">\(得到点值向量\)</span>A ( _n ^k ) \ $.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
A ( x ) &amp; = \sum _{ i = 0  } ^{ n - 1  } a _i x ^i \\
&amp; = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^i
+ \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a _i x ^i \\
&amp; = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^{
2 k  } + x \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a
_i x ^{ 2 k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>令</p>
<p>A_2(x)=_{i=2k+1,k}<sup>{n-1}a_ix</sup>{k}\$, 那 么
$A(x)=A_1(x<sup>2)+xA_2(x</sup>2)\</p>
<p>接下来分类讨论:</p>
<p>$ k { 2 } - 1 , k \ $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^k ) &amp; = A _1 ( \omega _n ^{ 2 k  } ) + \omega _n ^k A
_2 ( \omega _n ^{ 2 k  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据折半引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^k ) &amp; = A _1 ( \omega _{ \frac { n  } { 2  }  } ^k )
+ \omega _n ^k A _2 ( \omega ^k _{ \frac { n  } { 2  }  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们处理完了前半部分.</p>
<p>$ { 2 } k + { 2 } n - 1 , k \ $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) &amp; = A _1 ( \omega _n
^{ 2 k + n  } ) + \omega _n ^{ k + \frac { n  } { 2  }  } A _2 ( \omega
_n ^{ 2 k + n  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据消去引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) &amp; = A _1 ( \omega _{
\frac { n  } { 2  }  } ^k ) - \omega _n ^k A _2 ( \omega _{ \frac { n  }
{ 2  }  } ^k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>综上,我们可以递归处理$A _1 <span class="math inline">\(和\)</span>A
_2 <span class="math inline">\(,然后合并得到\)</span>A
$的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6>
<p>设$A ( _n ^k ) = d <em>k \ <span class="math inline">\(,构造多项式\)</span>F ( x ) = </em>{ i = 0 } ^{ n
- 1 } d _i x ^i \ $.</p>
<p>我们求出$F ( x ) <span class="math inline">\(的点值表示,设\)</span>c
_k = F ( _n ^{ - k } ) \ $,也即:</p>
$$
<span class="math display">\[\begin{aligned}
c _k &amp; = \sum _{ i = 0  } ^{ n - 1  } d _i ( \omega _n ^{ - k  } )
^i \\
&amp; = \sum _{ i = 0  } ^{ n - 1  } ( \sum _{ j = 0  } ^{ n - 1  } a _j
( \omega _n ^i ) ^j ) ( \omega _n ^{ - k  } ) ^i \\
&amp; = \sum _{ j = 0  } ^{ n - 1  } a _j \sum _{ i = 0  } ^{ n - 1  } (
\omega _n ^i ) ^{ j - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>当$j = k <span class="math inline">\(时,显然\)</span>_{ i = 0 } ^{ n
- 1 } ( _n ^i ) ^{ j - k } = n \ $.</p>
<p>否则根据等比数列求和公式,$_{ i = 0 } ^{ n - 1 } ( _n ^i ) ^{ j - k }
= { _n ^{ j - k } - 1 } = 0 \ $.</p>
<p>所以$_{ i = 0 } ^{ n - 1 } ( _n ^i ) ^{ j - k } = n [ j = k ] \
$.</p>
<p>那么我们有</p>
<p>a_k=\</p>
<h6><span id="写法">写法</span></h6>
<p>递归写法显然.</p>
<p>递归过程中,第$k <span class="math inline">\(层相当于在根据数在第\)</span>k $位的二进制数是$1
$还是$0 $来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">ll ak=a[i+k];</span><br><span class="line">a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5>
<p>由于FFT中的单位根会产生精度误差,因此在膜$998244353
$意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为$g <span class="math inline">\(,\)</span>g _n = g ^{ { n } } \
$,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol type="1">
<li><p>$g _n ^n = g _n ^0 = 1 <span class="math inline">\(且\)</span> i
&lt; j &lt; n , g _n ^i g _n ^j $,证明由原根的性质.</p></li>
<li><p>折半引理:$g <em>{ 2 n } ^{ 2 k } = g </em>{ n } ^k
$,证明显然.</p></li>
<li><p>消去引理:$g _{ n } ^{ k + { 2 } } = - g ^k _n \ <span class="math inline">\(.由于\)</span>g ^{ { 2 } } = - 1
$,该结论显然成立.</p></li>
</ol>
<p>由上我们证明了,我们完全可以使用$g _n <span class="math inline">\(代替\)</span>_n $进行变换.</p>
<p>另外,注意到$998244352 = 2 ^{ 23 } \ $,而$2 ^{ 23 } ^6 \ <span class="math inline">\(.因而,当\)</span>n ^6 <span class="math inline">\(的时候,\)</span>g _n
$可以直接求出.这也是为什么大部分NTT题目都使用$998244353
$作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5>
<p>范德蒙德矩阵形如:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; \alpha _1 &amp; \cdots &amp; \alpha _1 ^{ n - 1  } \\
1 &amp; \alpha _2 &amp; \cdots &amp; \alpha _2 ^{ n - 1  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \alpha _m &amp; \cdots &amp; \alpha _m ^{ n - 1  }
\end{bmatrix} \in \mathbb { R  } ^{ m \times n  }
\]</span></p>
<p>如果取单位根,我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega _n ^1 &amp; \cdots &amp; \omega _2 ^{ n - 1  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega _n ^{ n - 1  } &amp; \cdots &amp; \omega _n ^{ ( n - 1 )
^2  }
\end{bmatrix} \in \mathbb { R  } ^{ n \times n  }
\]</span></p>
<p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega _n ^1 &amp; \cdots &amp; \omega _2 ^{ n - 1  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega _n ^{ n - 1  } &amp; \cdots &amp; \omega _n ^{ ( n - 1 )
^2  }
\end{bmatrix} ^{ - 1  } = \frac { 1  } { n  } \begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega _n ^{ - 1  } &amp; \cdots &amp; \omega _2 ^{ - ( n - 1
)  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega _n ^{ - ( n - 1 )  } &amp; \cdots &amp; \omega _n ^{ - (
n - 1 ) ^2  }
\end{bmatrix}
\]</span></p>
<h4><span id="分治fft">分治FFT</span></h4>
<p>给定$g ( x ) <span class="math inline">\(和\)</span>f ( 0 ) <span class="math inline">\(,求\)</span>f ( x ) = _{ y = 1 } ^x f ( x - y ) g
( y ) $,答案对$998244353 $取膜.</p>
<p>考虑分治,假如我们已经知道了$f ( x ) , x <span class="math inline">\(.那我们可以计算出这段部分对\)</span>f ( y ) ， y
$的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算$f <span class="math inline">\(和\)</span>g $的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4>
<p>对于多项式$P ( x ) <span class="math inline">\(,找到\)</span>Q ( x )
<span class="math inline">\(使得\)</span>Q ( x ) P ( x ) \ <span class="math inline">\(.显然\)</span>Q ( x ) $是唯一的.</p>
<p>首先不妨设$n = 2 ^k \ $.</p>
<p>如果我们已知$P ( x ) Q <em>{ k - 1 } ( x ) \ <span class="math inline">\(,同时肯定有\)</span>P ( x ) Q </em>{ k } ( x ) \
<span class="math inline">\(,相减得到\)</span>Q <em>k ( x ) - Q </em>{ k
- 1 } ( x ) \ $.</p>
<p>两边平方:</p>
$$
<span class="math display">\[\begin{aligned}
Q _k ^2 ( x ) + Q ^2 _{ k - 1  } ( x ) - 2 Q _k ( x ) Q _{ k - 1  } ( x
) &amp; \equiv 0 \pmod { x ^{ 2 ^k  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边乘一下$P ( x ) $:</p>
$$
<span class="math display">\[\begin{aligned}
Q _k ( x ) - 2 Q _{ k - 1  } ( x ) + P ( x ) Q _{ k - 1  } ^2 ( x )
&amp; \equiv 0 \pmod { x ^n  } \\
Q _k ( x ) &amp; \equiv 2 Q _{ k - 1  } ( x ) - P ( x ) Q _{ k - 1  } ^2
( x ) \pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据主定理，这么做复杂度是$O ( n _2 n ) $的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; \equiv F ( x ) G ( x ) + f _0 \pmod { x ^{ n + 1  }  } \\
F ( x ) &amp; = \frac { f ( 0 )  } { 1 - G ( x )  } \pmod { x ^{ n +
1  }  }
\end{aligned}
\]</span></p>
<p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4>
<p>对于$n <span class="math inline">\(次多项式\)</span>F ( x ) <span class="math inline">\(和\)</span>m <span class="math inline">\(次多项式\)</span>G ( x ) <span class="math inline">\(,找到\)</span>Q ( x ) , R ( x ) <span class="math inline">\(使得\)</span>F ( x ) = G ( x ) Q ( x ) + R ( x ) \
$.</p>
<p>考虑对于$n <span class="math inline">\(次多项式\)</span>F ( x ) <span class="math inline">\(,令\)</span>F _R ( x ) = x ^n F ( { x } ) <span class="math inline">\(,如果设\)</span>f _i <span class="math inline">\(为其\)</span>x ^i <span class="math inline">\(项前的系数,不难发现\)</span>f _R ( i ) = f ( n - i
) $.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; = G ( x ) Q ( x ) + R ( x ) \\
F ( \cfrac { 1  } { x  } ) &amp; = G ( \cfrac { 1  } { x  } ) Q ( \cfrac
{ 1  } { x  } ) + R ( \cfrac { 1  } { x  } ) \\
x ^n F ( \cfrac { 1  } { x  } ) &amp; = x ^m G ( \cfrac { 1  } { x  } )
x ^{ n - m  } Q ( \cfrac { 1  } { x  } ) + x ^{ n - m + 1  } x ^{ m -
1  } R ( \cfrac { 1  } { x  } ) \\
F _R ( x ) &amp; = G _R ( x ) Q _R ( x ) + x ^{ n - m + 1  } R _R ( x )
\\
F _R ( x ) &amp; \equiv G _R ( x ) Q _R ( x ) \pmod { x ^{ n - m +
1  }  } \\
Q _R ( x ) &amp; \equiv F _R ( x ) G _R ^{ - 1  } ( x ) \pmod { x ^{ n -
m + 1  }  }
\end{aligned}
\]</span></p>
<p>于是只要做一遍多项式求逆即可求得$Q ( x ) <span class="math inline">\(,再做一遍相减既可以得到\)</span>R ( x ) $.</p>
<h4><span id="多项式ln">多项式ln</span></h4>
<p>给出$n - 1 <span class="math inline">\(次多项式\)</span>A ( x ) <span class="math inline">\(,求一个多项式\)</span>B ( x ) <span class="math inline">\(,满足\)</span>B ( x ) A ( x ) $.</p>
<p>我们有:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \ln A ( x ) \pmod { x ^n  } \\
B &#39; ( x ) &amp; \equiv \cfrac { A &#39; ( x )  } { A ( x )  } \pmod
{ nx ^{ n - 1  }  } \\
B ( x ) &amp; \equiv \int \cfrac { A &#39; ( x )  } { A ( x )  } dx
\pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当$[ x ^0 ] f ( x ) = 1 <span class="math inline">\(的时候,\)</span>f ( x ) $有对数多项式.</p>
<p>我们对最后再做一步:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \int _0 ^x \cfrac { A &#39; ( t )  } { A ( t )  }
dt + B ( 0 ) \pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>首先$B ( 0 ) = A ( 0 ) = a _0 <span class="math inline">\(,如果\)</span>a _0 a _0 <span class="math inline">\(,则\)</span>B ( 0 )
$,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若$[ x ^0 ] f ( x ) = 1 <span class="math inline">\(的时候,\)</span>B
( 0 ) = 0 $,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>给定多项式$G ( x ) <span class="math inline">\(,求一个多项式\)</span>F ( x ) <span class="math inline">\(满足\)</span>G ( F ( x ) ) $.</p>
<p>首先$n = 1 <span class="math inline">\(的时候,也就是求\)</span>G ( F
( x ) ) $.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在$x ^{ { 2 } } <span class="math inline">\(意义下的答案\)</span>F _0 ( x ) <span class="math inline">\(,我们考虑在\)</span>F _0 ( x ) $处做泰勒展开:</p>
$$
<span class="math display">\[\begin{aligned}
G ( F ( x ) ) &amp; = \sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k
)  } ( F _0 ( x ) )  } { k !  } ( F ( x ) - F _0 ( x ) ) ^k &amp; \equiv
0 \pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑$F ( x ) - F _0 ( x ) <span class="math inline">\(,由于\)</span>F
_0 ( x ) F ( x ) <span class="math inline">\(,因此,因此\)</span>( F ( x
) - F _0 ( x ) ) ^2 $.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k )  } ( F _0 ( x ) )  }
{ k !  } ( F ( x ) - F _0 ( x ) ) ^k &amp; \equiv 0 \pmod { x ^n  } \\
G ( F _0 ( x ) ) + G &#39; ( F _0 ( x ) ) ( F ( x ) - F _0 ( x ) ) &amp;
\equiv 0 \pmod { x ^n  } \\
F ( x ) &amp; \equiv F _0 ( x ) - \frac { G ( F _0 ( x ) )  } { G &#39;
( F _0 ( x ) )  } \pmod { x ^n  }
\end{aligned}
\]</span></p>
<p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4>
<p>给定$h ( x ) <span class="math inline">\(,设\)</span>g ( f ( x ) ) =
f ^2 ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
f ( x ) \equiv f _0 ( x ) - \frac { f ^2 ( x ) - h ( x )  } { 2 f _0 ( x
)  } \equiv \frac { f ^2 ( x ) + h ( x )  } { 2 f _0 ( x )  } \pmod { x
^n  }
\]</span></p>
<p>还没完,用牛顿迭代前一定要求$g ( a ) <span class="math inline">\(的解,也就是\)</span>[ x ^0 ] h ( x )
$的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4>
<p>给定$h ( x ) <span class="math inline">\(,设\)</span>g ( f ( x ) ) =
f ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; \equiv f _0 ( x ) - \frac { \ln f _0 ( x ) - h ( x )  } {
\frac { 1  } { f _0 ( x )  }  } \pmod { x ^n  } \\
&amp; \equiv f _0 ( x ) ( 1 - \ln f _0 ( x ) + h ( x ) ) \pmod { x ^n  }
\end{aligned}
\]</span></p>
<p>还没完,还需要求$g ( a ) <span class="math inline">\(的解,注意到存在\)</span><span class="math inline">\(当且仅当\)</span>[ x ^0 ] g ( x ) <span class="math inline">\(,此时\)</span>f ( x ) $.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4>
<p>求$<span class="math inline">\(后求\)</span><span class="math inline">\(即可,唯一的问题是为什么指数可以对\)</span>p
$取膜.</p>
<p>我们有一个结论:</p>
<p><span class="math display">\[
f ( x ^p ) \equiv f ( x ) ^p \pmod { p  }
\]</span></p>
<p>这个结论很简单,注意到$( a + b ) ^p a ^p + b ^p $即可.</p>
<p>而又由于$n &lt; p <span class="math inline">\(,因此\)</span>f ( x )
^p f ( 0 ) <span class="math inline">\(,通常取\)</span>f ( 0 ) = 1 <span class="math inline">\(,于是就可以直接对\)</span>p $取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4>
<p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做$<span class="math inline">\(的时候的直接数组传参,会导致\)</span><span class="math inline">\(的复杂度退化到\)</span>O ( n ^2 n ) $.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">ll x[qwq];</span><br><span class="line"><span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">ll ak=(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">x.k=k;</span><br><span class="line">x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">y.x[i]=x*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">y.limit=x.limit;y.k=x.k;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">tmp_inv.x[i]=x.x[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">tmp_inv.k=q_inv.k=k;</span><br><span class="line">q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line"><span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line"><span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">x.limit=lim,x.k=k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">tmp_exp.k=q_exp.k=k;</span><br><span class="line">q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_exp;</span><br><span class="line">&#125;</span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3>
<p>集合幂级数形如$_{ i = 0 } ^{ 2 ^n - 1 } a _i x ^i <span class="math inline">\(,其中二进制数\)</span>i <span class="math inline">\(表示\)</span>{ 1 , 2 , . . . , n } <span class="math inline">\(的一个子集,用\)</span>| i |
$表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4>
<p>高维前缀和:$c <em>i = </em>{ j i } a _j \ $.</p>
<p>高维后缀和:$c <em>i = </em>{ j i } a _j \ $.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:$c <em>i = </em>{ j } _{ k } [ j k = i ] a _j b _k \ $.</p>
<p>与卷积:$c <em>i = </em>{ j } _{ k } [ j k = i ] a _j b _k \ $.</p>
<p>二者求法类似,考虑如何求$a <span class="math inline">\(和\)</span>b
$的或卷积:</p>
<p>引理:</p>
<p>若$j , k i <span class="math inline">\(,则\)</span>j k i
$,逆命题同样成立.</p>
<p>若$j , k i <span class="math inline">\(,则\)</span>j k i
$,逆命题同样成立.</p>
<p>设$a , b , c <span class="math inline">\(的高维前缀和分别为\)</span>A
, B , C $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A _i B _i &amp; = ( \sum _{ j \subseteq i  } a _j ) ( \sum _{ k
\subseteq i  } b _k ) \\
&amp; = \sum _{ j , k \subseteq i  } a _i b _k \\
&amp; = \sum _{ k \lor j \subseteq i  } a _i b _k \\
&amp; = C _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>现在考虑已知$C <span class="math inline">\(求\)</span>c <span class="math inline">\(,本质上是一个反演.注意到\)</span><em>{ r p } ( - 1
) ^{ | r | } = </em>{ k = 0 } ^{ | p | } C _{ | p | } ^k ( - 1 ) ^k = [
p = 0 ] \ $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
c ( p ) &amp; = \sum _{ q \subseteq p  } [ p - q &amp; = 0 ] c ( q ) \\
&amp; = \sum _{ q \subseteq p  } \sum _{ r \subseteq ( p - q )  } ( - 1
) ^{ | r |  } c ( q ) \\
&amp; = \sum _{ r \subseteq p  } ( - 1 ) ^{ | r |  } \sum _{ q \subseteq
( p - r )  } c ( q ) \\
&amp; = \sum _{ r \subseteq p  } ( - 1 ) ^{ r  } C ( p - r ) \\
&amp; = \sum _{ r \subseteq p  } ( - 1 ) ^{ | p | - | r |  } C ( r ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是有$c ( S ) = _{ T S } ( - 1 ) ^{ | S | - | T | } C ( T ) \
$(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度$O ( 2 ^n n ) $.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4>
<p>异或卷积:$c _i = _j _k [ j k = i ] a _j b _k \ $.</p>
<p>引理:$( i j ) k = ( i k ) ( j k ) $.</p>
<p>证明的话考虑如果$k = 0 <span class="math inline">\(,二者显然相等;当\)</span>k = 1 <span class="math inline">\(的时候,左右都等价于\)</span>( i j ) $.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数$FWT ( a ) <span class="math inline">\(,满足\)</span>FWT ( a ) <em>i = </em>{ j = 0 } ^{
2 ^n - 1 } ( - 1 ) ^{ | i j | } a _j \ $.</p>
<p>那么有:</p>
$$
<span class="math display">\[\begin{aligned}
FWT ( c ) _i &amp; = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i
\land j |  } c _j \\
&amp; = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } \sum
_{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } [ k \oplus l
&amp; = j ] a _k b _l \\
&amp; = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  }
( - 1 ) ^{ | ( k \oplus l ) \land i |  } a _k b _l \\
&amp; = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  }
( - 1 ) ^{ | k \land i |  } a _k ( - 1 ) ^{ | l \land i |  } b _l \\
&amp; = FWT ( a ) _i FWT ( b ) _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>时间复杂度$O ( 2 ^n n ) $.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的$ { 2 }
$都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4>
<h5><span id="线性代数角度">线性代数角度</span></h5>
<p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换$FWT $,使得</p>
<ol type="1">
<li><p>若$c <em>i = </em>{ j k } a _j b _k <span class="math inline">\(,则\)</span>FWT ( c ) = FWT ( a ) FWT ( b )
$.</p></li>
<li><p>这个线性变换是可逆的.</p></li>
<li><p>做这个线性变换和其逆变换的复杂度都可以接受.</p></li>
</ol>
<p>我们设$FWT ( A ) <em>i = </em>{ j } w ( i , j ) A _j <span class="math inline">\(,我们想要做的就是构造一组满足上述条件的\)</span>w
$.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( C ) _i &amp; = FWT ( A ) _i FWT ( B ) _i \\
\sum _{ j  } w ( i , j ) C _j &amp; = \sum _{ j , k  } w ( i , j ) w ( i
, k ) A _j B _k
\end{aligned}
\]</span></p>
<p>再考虑:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; = A * B \\
C _i &amp; = \sum _{ k \oplus l = i  } A _k B _l \\
\sum _{ j  } w ( i , j ) C _j &amp; = \sum _j w ( i , j ) \sum _{ k
\oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k &amp; = \sum _j w ( i
, j ) \sum _{ k \oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k &amp; = \sum _{ j ,
k  } A _j B _k w ( i , j \oplus k )
\end{aligned}
\]</span></p>
<p>比较两边系数,有$w ( i , j ) w ( i , k ) = w ( i , j k )
$.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于$<span class="math inline">\(是集合的运算,我们可以对二进制分开考虑.换句话说,如果\)</span>a
= _{ i = 0 } a <em>i 2 ^i , b = </em>{ i = 0 } b <em>i 2 ^i <span class="math inline">\(,那么\)</span>w ( a , b ) = </em>{ i = 0 } w ( a
_i , b _i ) $一定是满足条件的.</p>
<p>这样我们就可以只求一个$2 <span class="math inline">\(的线性变换矩阵就好.我们接下来将对三种常见的基础位运算(\)</span>,
, xor ( ) <span class="math inline">\()分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出\)</span>FWT
( a ) $呢?</p>
<p>考虑和FFT一样折半,令$i _0 <span class="math inline">\(为\)</span>i
$的最高位是否是$1 <span class="math inline">\(,\)</span>i ’ <span class="math inline">\(为\)</span>i <span class="math inline">\(去掉最高位后的二进制数字,令\)</span>n = 2 ^m
$我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) _i &amp; = \sum _{ j = 0  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
&amp; = \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i , j ) A _j + \sum
_{ j = 2 ^{ m - 1  }  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
&amp; = w ( i _0 , 0 ) \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i
&#39; , j &#39; ) A _j + w ( i _0 , 1 ) \sum _{ j = 2 ^{ m - 1  }  } ^{
2 ^m - 1  } w ( i &#39; , j &#39; ) A _j
\end{aligned}
\]</span></p>
<p>这样就实现了规模减半,复杂度$O ( mn ) $.</p>
下面我们设FWT的变换矩阵为$
<span class="math display">\[\begin{bmatrix}w ( 0 , 0 ) &amp; w ( 0 , 1
) \\ w ( 1 , 0 ) &amp; w ( 1 , 1 ) \end{bmatrix}\]</span>
<p>$.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6>
取矩阵$
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ 1 &amp; 1
\end{bmatrix}\]</span>
<span class="math inline">\(.其逆矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ - 1 &amp; 1
\end{bmatrix}\]</span>
<p>$.</p>
<h6><span id="与卷积">与卷积</span></h6>
取矩阵$
<span class="math display">\[\begin{bmatrix}1 &amp; 1 \\ 0 &amp; 1
\end{bmatrix}\]</span>
<span class="math inline">\(.其逆矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}1 &amp; - 1 \\ 0 &amp; 1
\end{bmatrix}\]</span>
<p>$.</p>
<h6><span id="异或卷积">异或卷积</span></h6>
取矩阵$
<span class="math display">\[\begin{bmatrix}1 &amp; 1 \\ 1 &amp; - 1
\end{bmatrix}\]</span>
<span class="math inline">\(.其逆矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}\frac { 1  } { 2  } &amp;
\frac { 1  } { 2  } \\ \frac { 1  } { 2  } &amp; - \frac { 1  } { 2  }
\end{bmatrix}\]</span>
<p>$.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5>
<p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:$x ^S x ^T = x ^{ S T }
$,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) _S &amp; = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | S
\land T |  } a _T \\
IFWT ( A ) _S &amp; = \frac { 1  } { 2 ^n  } FWT ( A ) _S
\end{aligned}
\]</span></p>
<p>这等价于:</p>
<p><span class="math display">\[
\begin{aligned}
[ x ^S ] FWT ( A ) &amp; = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ |
S \land T |  } a _T \\
[ x ^S ] IFWT ( A ) &amp; = [ x ^S ] \frac { 1  } { 2 ^n  } FWT ( A )
\end{aligned}
\]</span></p>
<h4><span id="子集卷积">子集卷积</span></h4>
<p>子集卷积:$c <em>i = </em>{ j } _{ k } [ j k = , j k = i ] a _j b _k \
$.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些$[ j k ] <span class="math inline">\(的答案,而\)</span>[ j k = , j k = i ] = [ | j | +
| k | = | i | , j k = i ] \ $.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再$n ^2 <span class="math inline">\(次结合,并做IFMT,最终将结果累计,复杂度\)</span>O (
2 ^n n ^2 ) $.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4>
<p>其实就是设$g _{ i , j } = z ^i f _j $,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1agc034f-rng-andxor">Example1([AGC034F] RNG and
XOR)</span></h5>
<p>设$f _i ( n ) <span class="math inline">\(表示操作\)</span>n <span class="math inline">\(次后第一次变成\)</span>i <span class="math inline">\(的概率,\)</span>g _i ( n ) <span class="math inline">\(表示操作\)</span>n <span class="math inline">\(次后变成\)</span>i <span class="math inline">\(的概率.\)</span>F , G $分别是其生成函数.</p>
<p>注意到$G _i = F _i G _0 , F _i = { G _0 } <span class="math inline">\(,而\)</span>F _i ’ ( 1 ) <span class="math inline">\(就是期望.接下来的问题在于如何求\)</span>G $.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把$a _i { a } <span class="math inline">\(,然后做\)</span>A = FWT ( a ) <span class="math inline">\(,注意这里\)</span>A _0 = a = 1 <span class="math inline">\(,FWT自身有很好的性质:\)</span>a = { 2 ^N } FWT ( A
) <span class="math inline">\(.我们做\)</span>n <span class="math inline">\(次操作后得到的概率数组也就是\)</span> { 2 ^N } FWT
( A ^n ) $.展开FWT的式子,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g _i ( n ) &amp; = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land
j |  } A _j ^n x ^n \\
G _i &amp; = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  }
\frac { 1  } { 1 - A _j x  } \\
F _i &amp; = \frac { G _i  } { G _0  } \\
F _i &#39; &amp; = \frac { G _i &#39; G _0 - G _0 &#39; G _i  } { G _0
^2  } \\
&amp; = \frac { ( \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j
|  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N
- 1  } \frac { 1  } { 1 - A _j x  } ) - ( \sum _{ j = 0  } ^{ 2 ^N -
1  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N
- 1  } ( - 1 ) ^{ | i \land j |  } \frac { 1  } { 1 - A _j x  } )  } { (
\sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { 1  } { 1 - A _j x  } ) ^2  }
\end{aligned}
\]</span></p>
<p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求$F ’ _i (
1 ) <span class="math inline">\(,因此我们直接把\)</span>x = 1 <span class="math inline">\(带入算一算就好.不过由于\)</span>A _0 = 1
$,我们必须要解决分母为$0 <span class="math inline">\(的情况,解决的方法是分母乘上\)</span>( 1 - x )
<span class="math inline">\(,这样就消掉了\)</span>j = 0
$的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5>
<p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边$u
v <span class="math inline">\(就异或上\)</span>( 2 ^u + 2 ^v )
$.最后要求这个二进制数是$0 <span class="math inline">\(.我们用一个二元组\)</span>( a , F ) <span class="math inline">\(表示在集合幂级数上异或上\)</span>a <span class="math inline">\(,在多项式上乘上\)</span>F <span class="math inline">\(.显然一条边是\)</span>( 0 , 1 ) + ( 2 ^u + 2 ^v ,
x )
$.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上$1
+ x $要么乘上$1 - x <span class="math inline">\(,做完FWT得到的每一个\)</span>FWT _i <span class="math inline">\(一定形如\)</span>( 1 + x ) ^k ( 1 - x ) ^{ m - k }
<span class="math inline">\(,做IFWT的时候直接求\)</span> { 2 ^N } ( 1 +
x ) ^k ( 1 - x ) ^{ m - k } $即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:$(
0 , 1 ) <span class="math inline">\(和\)</span>( 2 ^u + 2 ^v , x )
$,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个$i <span class="math inline">\(求\)</span>k <span class="math inline">\(,也就是对于每个\)</span>i <span class="math inline">\(求有多少条边满足\)</span>| i ( 2 ^u + 2 ^v ) | = 1
<span class="math inline">\(,也就是求有多少条边一段链接在了\)</span>i
$的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-cloves-3-iii">Example3(CF1034E Little C
Loves 3 III)</span></h5>
<p>仍然是子集卷积,转化为$c <em>i = </em>{ j } _{ k } [ | j | + | k | = |
i | , j k = i ] a _j b _k \ <span class="math inline">\(.然后我们将\)</span>a _j $乘上$4 ^j <span class="math inline">\(,将\)</span>b _k $乘上$4 ^k <span class="math inline">\(,最后把\)</span>c _i $除去$4 ^i $对$4
$取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2chiori-and-doll-picking">Example4(CF1336E2
Chiori and Doll Picking)</span></h5>
<p>先考虑easy version.首先求出线性基,如果线性基的大小$k
$比较小,我们可以直接$2 ^k
$枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个$1
<span class="math inline">\(取决于选了多少个元素,其他位置共有\)</span>m
- k <span class="math inline">\(个,可以直接状压进状态.这样复杂度就是\)</span>O ( {
2 ^k , m ^2 2 ^{ m - k } } ) $.</p>
<p>那么我们怎么优化呢?首先$k $较大的时候有点难做,我们看看能不能优化到$2
^{ m - k } $.</p>
<p>考虑设$f _i ^c = [ | i | = c ] <span class="math inline">\(,将线性基能做出的线性空间设为\)</span>A <span class="math inline">\(,\)</span>A _S = 1 <span class="math inline">\(当且仅当线性基能异或出\)</span>S <span class="math inline">\((最后再把那些废元素贡献到答案里).那么\)</span>popcount
= c <span class="math inline">\(的答案就是\)</span>IFWT ( FWT ( F ) FWT
( A ) ) _0 <span class="math inline">\(.考虑\)</span>IFWT <em>0 = { 2 ^m
} </em>{ i = 0 } ^{ 2 ^m - 1 } FWT ( F ) _i FWT ( A ) _i
$,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:$FWT ( A ) $要么是$2 ^k $,要么是$0 $.</p>
<p>考虑:</p>
<p><span class="math display">\[
A * A = A \times 2 ^k
\]</span></p>
<p>这句是为啥呢?因为对于右边的每一个数字$x <span class="math inline">\(和左边的一个数字\)</span>y <span class="math inline">\(,如果它们都在线性基中,一定存在一个数字\)</span>z
<span class="math inline">\(满足\)</span>y z = x $,不然就是$0 $.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) _i \cdot FWT ( A ) _i &amp; = FWT ( A ) _i \times 2 ^k \\
FWT ( A ) _i &amp; = 0 \lor 2 ^k
\end{aligned}
\]</span></p>
<p>引理2:$FWT ( A ) _i = 2 ^k x , A _x , | i x | $.</p>
<p>直接展开上面的式子,用$_{ S T } ( - 1 ) ^{ | S | } = [ T = ] $.</p>
<p>引理3:$FWT ( A ) $中值为$2 ^k $的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果$i <span class="math inline">\(满足条件,\)</span>j <span class="math inline">\(满足条件,一开始做FWT时我们已经注意到:\)</span>( i
j ) x = ( i x ) ( j x ) $.于是这个引理也显然成立.</p>
<p>引理4:$FWT ( A ) $中值为$2 ^k <span class="math inline">\(的位置构成的线性基的大小是\)</span>m - k $.</p>
<p>设这些位置构成的空间是$B <span class="math inline">\(,\)</span>B _S =
1 <span class="math inline">\(当且仅当\)</span>S
$在这个空间中.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) &amp; = B \times 2 ^k \\
A &amp; = IFWT ( B ) \times 2 ^k
\end{aligned}
\]</span></p>
<p>注意到$a _0 = 1 <span class="math inline">\(,也就是\)</span> { 2 ^m }
b = 1 , b = 2 ^{ m - k } $,这就证明了引理.</p>
<p>引理5:将$A <span class="math inline">\(的线性基对应的矩阵从前往后消成最简,\)</span>B
<span class="math inline">\(的线性基对应的矩阵从后往前消成最简,上\)</span>A
<span class="math inline">\(下\)</span>B <span class="math inline">\(拼成一个\)</span>m m
$的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据$rank ( A ) + rank ( B ) = k + m - k = m
$可以知道主对角线一定全是$1 <span class="math inline">\(,然后我们任取\)</span>A <span class="math inline">\(中的一个基\)</span>x <span class="math inline">\(和\)</span>B <span class="math inline">\(中的一个基\)</span>y <span class="math inline">\(,应该有\)</span>| x y |
$.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由$A <span class="math inline">\(得知\)</span>B
$长什么样.</p>
<p>引理6:$FWT ( F ^c ) _i <span class="math inline">\(只和\)</span>| i |
$有关.</p>
<p>因为$F ^c <em>i <span class="math inline">\(只和\)</span>| i | <span class="math inline">\(有关,这里考虑一下对称性就可以.因此设\)</span>w
</em>{ d } ^c = FWT ( F ^c ) _i , | i | = d $.</p>
<p>然后注意到$w <em>d ^c = </em>{ i = 0 } ^{ 2 ^m - 1 } ( - 1 ) ^{ | i (
2 ^d - 1 ) | } [ | i | = c ] $.组合意义展开一下:</p>
<p><span class="math display">\[
w _d ^c = \sum _{ j = 0  } ^{ d  } ( - 1 ) ^{ j  } \binom { d  } { j  }
\binom { m - d  } { c - j  }
\]</span></p>
<p>接下来怎么做呢?令$g <em>d = </em>{ i = 0 } ^{ 2 ^m - 1 } [ A _i = 1 ]
[ | i | = d ] <span class="math inline">\(,这里可以\)</span>O ( 2 ^{ m -
k } ) $,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5>
<p>首先发现”如果没有边那么是$0 $“这个限制太强了,如果我们能改为”如果是$0
$,那么可有边可无边”的话,整个序列就会被$1 <span class="math inline">\(的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设\)</span>g
_{ len , S } <span class="math inline">\(表示长度为\)</span>len <span class="math inline">\(,一段长度为\)</span>len - 1 $的连续的$1 <span class="math inline">\(对应的集合是\)</span>S
$的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个$0
$).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5>
<p>首先可以类似数位dp设计一个$dp _{ i , S } <span class="math inline">\(表示目前dp到了第\)</span>i <span class="math inline">\(位,然后前面的\)</span>limit <span class="math inline">\(是\)</span>S $.接下来分类讨论当前的最大值限制是$1
$还是$0 $.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2>
<h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3>
<h4><span id="概念">概念</span></h4>
<p>我们定义一个幂级数形如$A ( z ) = _{ k } a _k z ^k <span class="math inline">\(,并使\)</span>[ z ^n ] A ( z ) = a _n <span class="math inline">\(.则称\)</span>A ( z ) <span class="math inline">\(是\)</span>a _0 , a _1 , . . . $的生成函数.</p>
<h4><span id="运算">运算</span></h4>
<ol type="1">
<li><p>$A ( z ) + B ( z ) = _{ n } ( f _n + g _n ) z ^n $.</p></li>
<li><p>$z ^m A ( z ) = <em>{ n } g </em>{ n } z ^{ n + m } = <em>{ n m }
g </em>{ n - m } z ^n $.</p></li>
<li><p>$A ( cz ) = _{ n } c ^n f _n z ^n $.</p></li>
<li><p>$A ’ ( z ) = _{ n } ig _i z ^{ i - 1 } $.</p></li>
<li><p>$A ( z ) dz = _{ n } { n + 1 } g _n z ^{ n + 1 } $.</p></li>
<li><p>$A ( z ) B ( z ) = <em>{ n } ( </em>{ k = 0 } ^n f <em>k g </em>{
n - k } ) z ^n $.</p></li>
<li><p>$ { 1 - z } A ( z ) = <em>{ n } ( </em>{ k = 0 } ^n g _k ) z ^n
$.</p></li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4>
<ol type="1">
<li>$ { 1 - z } = <em>{ k } z ^k \ <span class="math inline">\(,\)</span> { 1 - cz } = </em>{ k } c ^k z ^k \
$.</li>
</ol>
<p>证明显然.</p>
<ol start="2" type="1">
<li>$( 1 + z ) ^r = <em>{ k } { k } z ^k \ <span class="math inline">\(,\)</span>( 1 - z ) ^r = </em>{ k } ( - 1 ) ^k { k
} z ^k \ $.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol start="3" type="1">
<li>$ { 1 - z ^m } = _{ n } [ n | m ] z ^n \ $.</li>
</ol>
<p>证明显然.</p>
<ol start="4" type="1">
<li>$ { ( 1 - z ) ^{ n + 1 } } = <em>{ k } { n } z ^k , n \ <span class="math inline">\(,\)</span> { ( 1 - z ) ^{ n + 1 } } = </em>{ k } {
n } z ^k , n \ $</li>
</ol>
<p>直接使用二项式定理展开$( 1 - z ) ^{ - n - 1 } $,可以得到:</p>
<p><span class="math display">\[
( 1 - z ) ^{ - n - 1  } = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { - n -
1  } { k  } z ^k
\]</span></p>
<p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { 1  } { ( 1 - z ) ^2  } &amp; = \sum _{ n \geq 0  } ( n + 1 ) z
^n \\
\cfrac { z  } { ( 1 - z ) ^2  } &amp; = \sum _{ n \geq 0  } nz ^n
\end{aligned}
\]</span></p>
<p>根据$( 1 ) $求导即可得到此式.</p>
<ol start="5" type="1">
<li><p>$e ^z = _{ k } { k ! } \ $.</p></li>
<li><p>$( { 1 - z } ) = _{ n } { n } z ^n $.</p></li>
<li><p>$( 1 + z ) = _{ k } ( - 1 ) ^k { k + 1 } \ $.</p></li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol start="8" type="1">
<li>$ { 2 x } = _{ k } { k + 1 } x ^k $.</li>
</ol>
<p>也即卡特兰数$C _k $的生成函数,证明考虑:</p>
<p><span class="math display">\[
xC ^2 + 1 = C
\]</span></p>
<p>然后得到两个根,带入$x = 0 $舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3>
<p>https://zhuanlan.zhihu.com/p/53079223</p>
<p>序列${ a } <span class="math inline">\(的指数生成函数定义为形式幂级数\)</span>F ( x ) = a
_n { n ! } <span class="math inline">\(.注意\)</span>[ x ^n ] F ( x ) =
a _n $.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) \hat G ( x ) &amp; = \sum _{ j \geq 0  } a _j \frac { x
^j  } { j !  } \sum _{ k \geq 0  } b _k \frac { x ^k  } { k !  } \\
&amp; = \sum _{ k \geq 0  } x ^k \sum _{ j = 0  } ^k a _j b _{ k - j  }
\frac { k !  } { j ! ( k - j ) !  } \frac { 1  } { k !  } \\
&amp; = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } \sum _{ j = 0  } ^k
a _j b _{ k - j  } \binom { k  } { j  }
\end{aligned}
\]</span></p>
<p>即$_{ i = 0 } ^n { i } a <em>i b </em>{ n - i } $的EFG.</p>
<p>注意到有一个特例是$x F ( x ) <span class="math inline">\(就是\)</span> { n - 1 } a _i $的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li>$e ^x = _{ k } { k ! } $</li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol start="2" type="1">
<li>$e ^{ px } = _{ k } p ^k { k ! } $</li>
</ol>
<p>换元后可以得到.一个经典特例是$e ^{ - x } = _{ k } ( - 1 ) ^k { k ! }
$.</p>
<ol start="3" type="1">
<li>$ { 2 } = _{ k } [ 2 | k ] { k ! } $.</li>
</ol>
<p>显然.</p>
<ol start="4" type="1">
<li>$( 1 + x ) ^n = _{ k } n ^{ } { k ! } $.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol start="5" type="1">
<li><p>$( 1 + x ) = _{ k } ( - 1 ) ^{ k - 1 } ( k - 1 ) ! { k ! }
$.</p></li>
<li><p>$( 1 - x ) = _{ k } ( k - 1 ) ! { k ! } $.</p></li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4>
<p>我们设$F _k ( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(个有标号元素划分成\)</span>k <span class="math inline">\(个非空无序集合的情况,\)</span>f _i <span class="math inline">\(为\)</span>i <span class="math inline">\(个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和\)</span>|
S | $有关的定义在集合上的函数),有:</p>
<p><span class="math display">\[
F _k ( n ) = \frac { n !  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i =
n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a _j !  }
\]</span></p>
<p>设$ ( x ) = _{ n } f _n { n ! } $,再设:</p>
<p><span class="math display">\[
\begin{aligned}
\hat G _k ( x ) &amp; = \sum _{ n \geq 0  } F _k ( n ) \frac { x ^n  } {
n !  } \\
&amp; = \sum _{ n \geq 0  } x ^n \frac { 1  } { k !  } \sum _{ \sum _{ i
= 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a
_j !  } \\
&amp; = \sum _{ n \geq 0  } \frac { 1  } { k !  } \sum _{ \sum _{ i =
1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  } x ^{ a
_j  }  } { a _j !  } \\
&amp; = \frac { 1  } { k !  } \hat F ^k ( x )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\sum _{ k \geq 0  } \hat G _k ( x ) = \exp \hat F ( x )
\]</span></p>
<p>或者直接递推:</p>
$$
<span class="math display">\[\begin{aligned}
F _k ( x ) &amp; = \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  }
F _{ k - 1  } ( n - i ) f _i \frac { 1  } { k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{aligned}
\hat G _k ( x ) &amp; = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } F
_k ( n ) \\
&amp; = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } \sum _{ i = 1  } ^{
n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \frac {
1  } { k  } \\
&amp; = \frac { 1  } { k  } \sum _{ n \geq 0  } \frac { x ^n  } { n !  }
\sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n
- i ) f _i \\
&amp; = \frac { 1  } { k  } \hat G _{ k - 1  } ( x ) \hat F ( x ) \\
&amp; = \frac { 1  } { k !  } \hat F ^k ( x )
\end{aligned}
\]</span></p>
<p>简而言之,$[ x ^n ] F ( x ) <span class="math inline">\(是将\)</span>n
<span class="math inline">\(个有标号的元素放到同一个无序集合的方案数,而\)</span>[
x ^n ] F ( x ) <span class="math inline">\(是将\)</span>n
$个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poj3734">Example1(POJ3734)</span></h5>
<p>对于红黄色砖块,其选取方案为${ 1 , 0 , 1 , 0 , } <span class="math inline">\(,对应的EGF是\)</span> { 2 } $.</p>
<p>对于蓝绿色砖块,选取方案是$e ^x $.</p>
<p>乘起来有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) &amp; = ( \frac { e ^x + e ^{ - x  }  } { 2  } ) ^2 e ^{ 2
x  } \\
&amp; = \frac { ( e ^{ 2 x  } + 2 + e ^{ - 2 x  } ) e ^{ 2 x  }  } {
4  } \\
&amp; = \frac { e ^{ 4 x  } + 2 e ^{ 2 x  } + 1  } { 4  } \\
&amp; = \frac { 1  } { 4  } + \sum _{ k \geq 0  } \frac { 4 ^i + 2 ^{ i
+ 1  }  } { 4  } \frac { x ^i  } { i !  }
\end{aligned}
\]</span></p>
<p>于是有$[ x ^n ] F ( x ) = 4 ^{ n - 1 } + 2 ^{ n - 1 } $.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5>
<p>长度为$n <span class="math inline">\(的排列数的指数生成函数是\)</span>P ( x ) = _{ n }
{ n ! } = { 1 - x } $.</p>
<p>长度为$n <span class="math inline">\(的圆排列的指数生成函数是\)</span>Q ( x ) = _{ n }
{ n ! } = { n } = - ( 1 - x ) = { 1 - x } $.</p>
<p>于是有$Q ( x ) = P ( x ) $.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5>
<p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为$1
<span class="math inline">\(的置换环,其EGF显然是\)</span>_{ n } { n } =
- ( 1 - x ) - x <span class="math inline">\(,错排数的EGF对其取\)</span>$即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5>
<p>考虑如果$n <span class="math inline">\(个点带编号的无向连通图的EGF是\)</span>F ( x )
<span class="math inline">\(,那么\)</span>n <span class="math inline">\(个点带标号无向图的EGF就是\)</span>F ( x ) <span class="math inline">\(,后者直接计数,前者对后者做一次\)</span>$就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5>
<p>求有多少个映射$f : { 1 , 2 , , n } { 1 , 2 , , n } <span class="math inline">\(满足\)</span>f f f <span class="math inline">\((共\)</span>k <span class="math inline">\(个\)</span>f <span class="math inline">\()\)</span>= f f f <span class="math inline">\((共\)</span>k - 1 <span class="math inline">\(个\)</span>f $).</p>
<p>考虑将$i f _i <span class="math inline">\(,这等价于对深度不超过\)</span>k
$的基环树(环的长度为$1 <span class="math inline">\()计数,等价于对深度不超过\)</span>k <span class="math inline">\(的有根树计数.注意到删去根节点后等价于对深度不超过\)</span>k
- 1 <span class="math inline">\(的有根树计数,因此\)</span>F <em>k ( x )
= x F </em>{ k - 1 } ( x ) $.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5>
<p>假设$k <span class="math inline">\(次操作后\)</span>a _i <span class="math inline">\(减少了\)</span>b <em>i <span class="math inline">\(,实际上要求的就是\)</span></em>{ i = 1 } ^n a
<em>i - </em>{ i = 1 } ^n ( a _i - b _i ) $.</p>
<p>考虑对所有情况下的$_{ i = 1 } ^n ( a _i - b _i ) <span class="math inline">\(求和,注意到\)</span>k <span class="math inline">\(次操作,使得\)</span>i <span class="math inline">\(出现\)</span>b <em>i <span class="math inline">\(次的方案数是\)</span> { </em>{ i = 1 } ^n b _i ! }
<span class="math inline">\(.直接设\)</span>a _j $的EGF是</p>
<p><span class="math display">\[
\begin{aligned}
\hat F _{ j  } ( x ) &amp; = \sum _{ i \geq 0  } ( a _j - i ) \frac { x
^i  } { i !  } \\
&amp; = \sum _{ i \geq 0  } a _j \frac { x ^i  } { i !  } - \sum _{ i
\geq 1  } \frac { x ^i  } { ( i - 1 ) !  } \\
&amp; = a _j e ^x - xe ^x &amp; = ( a _j - x ) e ^x
\end{aligned}
\]</span></p>
<p>答案就是$[ x ^k ] _{ j = 1 } ^n F _j ( x ) $.</p>
<h5><span id="example7">Example7</span></h5>
<h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3>
<p>对于序列$f <em>n <span class="math inline">\(,定义其DGF为\)</span> (
x ) = </em>{ i } { i ^x } <span class="math inline">\(.注意到若\)</span>f <span class="math inline">\(是积性函数,那么\)</span> ( x ) = <em>{ p prime }
</em>{ i } { p ^{ ix } } \ $.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>对于两个序列$f , g
$,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde { F  } ( x ) \tilde { G  } ( x ) &amp; = \sum _{ i  } \sum _{
j  } \frac { f ( i ) g ( j )  } { ( ij ) ^x  } \\
&amp; = \sum _{ i  } \frac { 1  } { i ^x  } \sum _{ d | i  } f ( d ) g (
\frac { i  } { d  } )
\end{aligned}
\]</span></p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li>$( x ) = [ x = 1 ] $.</li>
</ol>
<p>显然为$ ( x ) = 1 $.</p>
<ol start="2" type="1">
<li>$I ( x ) = 1 $.</li>
</ol>
<p>其封闭式是黎曼函数$( x ) $,事实上,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\zeta ( x ) &amp; = \prod _{ i \geq 1  } \frac { 1  } { i ^x  } \\
&amp; = \prod _{ p \in prime  } \sum _{ i \geq 0  } \frac { 1  } { p ^{
ix  }  } \\
&amp; = \prod _{ p \in prime  } \frac { 1  } { 1 - p ^{ - x  }  }
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>$( n ) $.</li>
</ol>
<p>其DGF为$ ( x ) = _{ p prime } ( 1 - p ^{ - x } ) <span class="math inline">\(.注意到\)</span>( x ) ( x ) = 1 , ( x ) = { ( x )
} $.</p>
<ol start="4" type="1">
<li>$id ( n ) = n $.</li>
</ol>
<p>有$ ( n ) = <em>{ i } { i ^x } = </em>{ i } { i ^{ x - 1 } } = ( x -
1 ) $.</p>
<ol start="5" type="1">
<li>$I _k ( n ) = n ^k $.</li>
</ol>
<p><span class="math display">\[
\tilde { I _k  } ( x ) = \prod _{ i \geq 1  } \frac { 1  } { i ^{ x -
k  }  } = \zeta ( x - k )
\]</span></p>
<ol start="6" type="1">
<li>$( n ) $.</li>
</ol>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde { \Phi  } ( x ) &amp; = \prod _{ p \in prime  } ( 1 + \frac { p -
1  } { p ^x  } + \frac { p ( p - 1 )  } { p ^{ 2 x  }  } + \cdots ) \\
&amp; = \prod _{ p \in prime  } \frac { 1 - p ^{ - x  }  } { 1 - p ^{ 1
- x  }  } \\
&amp; = \tilde { \Phi  } ( x ) &amp; = \frac { \zeta ( x - 1 )  } {
\zeta ( x )  }
\end{aligned}
\]</span></p>
<p>也注意到$ ( x ) I ( x ) = ( x - 1 ) = ( x ) $.</p>
<ol start="7" type="1">
<li>$<em>k ( n ) = </em>{ d | n } d ^k $.</li>
</ol>
<p>注意到$_k ( n ) = I _k ( n ) * I _0 ( n ) <span class="math inline">\(,也就是说\)</span> ( x ) = ( x - k ) ( x ) $.</p>
<ol start="8" type="1">
<li>$u ( n ) = | ( n ) | $.</li>
</ol>
<p>$ ( n ) = { ( 2 n ) } $.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5>
<p>考虑对于$f ( n ) = n ^2 ( n ) <span class="math inline">\(构造积性函数\)</span>g ( n ) , h ( n ) <span class="math inline">\(使得\)</span>f * g = h $.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde { F  } ( x ) &amp; = \prod _{ p \in prime  } ( 1 + \sum _{ k \geq
1  } \frac { p ^{ 3 k - 1  } ( p - 1 )  } { p ^{ kx  }  } ) \\
&amp; = \prod _{ p \in prime  } \frac { 1 - p ^{ 2 - x  }  } { 1 - p ^{
3 - x  }  } &amp; = \frac { \zeta ( x - 3 )  } { \zeta ( x - 2 )  }
\end{aligned}
\]</span></p>
<p>也就是$f * I _2 = I _3 $.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3>
<p>对于复数的阶乘,我们通常定义:</p>
<p><span class="math display">\[
\cfrac { 1  } { z !  } = \lim _{ n \rightarrow + \infin  } \binom { n +
z  } { z  } n ^{ - z  }
\]</span></p>
<p>同时我们定义$( z + 1 ) = z ! <span class="math inline">\(,有:\)</span>( - z ) ! ( z ) = { ( z ) } $.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<p><span class="math display">\[
\begin{aligned}
z ^{ \underline { w  }  } &amp; = \cfrac { z !  } { ( z - w ) !  } \\
z ^{ \overline { w  }  } &amp; = \cfrac { \Gamma ( z + w )  } { \Gamma (
z )  }
\end{aligned}
\]</span></p>
<p>通过以上我们还可以有二项式系数的定义:</p>
<p><span class="math display">\[
\binom { z  } { w  } = \lim _{ \zeta \rightarrow z , \omega \rightarrow
w  } \cfrac { \zeta !  } { \omega ! ( \zeta - \omega ) !  }
\]</span></p>
<h3><span id="超几何级数">超几何级数</span></h3>
<h4><span id="超几何函数">超几何函数</span></h4>
我们定义超几何函数$F ( a _1 , . . . , a _m ; b _1 , . . . b _n ; z ) = F
(
<span class="math display">\[\begin{array}{ r |  } a _1 , . . . , a _m
\\ b _1 , . . . , b _n \end{array}\]</span>
<p>z ) = <em>{ k } { k ! </em>{ i = 1 } ^n b _i ^{ } } $.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$ { 0 } = 1 <span class="math inline">\(之类的式子,可以发现当\)</span>z = 0 <span class="math inline">\(时任意超几何函数总是\)</span>= 1 $.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0
$或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4>
<h5><span id="合流超几何函数">合流超几何函数</span></h5>
我们通常把形如$M ( a ; b ; z ) = F (
<span class="math display">\[\begin{array}{ r |  } a \\ b
\end{array}\]</span>
<p>z ) = _{ k } { b ^{ } k ! } $的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r |  } 1 \\
1
\end{array} z \right ) = e ^z
\]</span></p>
<p>也即常见生成函数中的$( 6 ) $.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5>
我们把形如$F (
<span class="math display">\[\begin{array}{ r |  } a , b \\ c
\end{array}\]</span>
<p>z ) = _{ k } { c ^{ } k ! } $的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } 1 , 1 \\ 1
\end{array}\]</span>
z ) = { 1 - z } $.</li>
</ol>
<p>即常见生成函数$( 1 ) $.</p>
<ol start="2" type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } - a , 1 \\ 1
\end{array}\]</span>
<ul>
<li>z ) = ( 1 + z ) ^a $.</li>
</ul></li>
</ol>
<p>即常见生成函数$( 2 ) $.</p>
<ol start="3" type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } a , 1 \\ 1
\end{array}\]</span>
z ) = { ( 1 - z ) ^a } $.</li>
</ol>
<p>即常见生成函数$( 4 ) $.</p>
<ol start="4" type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } 1 , 1 \\ 2
\end{array}\]</span>
<ul>
<li>z ) = { z } $.</li>
</ul></li>
</ol>
<p>即常见生成函数$( 7 ) $.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4>
<p>我们先考虑改写超几何级数的形式:</p>
$F (
<span class="math display">\[\begin{array}{ r |  } a _1 , . . . , a _m
\\ b _1 , . . . , b _n \end{array}\]</span>
<p>z ) = _{ k } t _k , t <em>k = { k ! </em>{ i = 1 } ^n b _i ^{ } }
$.</p>
<p>不难发现$t _0 = 1 $,而:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { t _{ k + 1  }  } { t _k  } &amp; = \cfrac { z ^{ k + 1  }  } {
z ^k  } \cfrac { k !  } { ( k + 1 ) !  } \cfrac { \prod _{ i = 1  } ^m a
_i ^{ \overline { k + 1  }  }  } { \prod _{ i = 1  } ^m a _i ^{
\overline { k  }  }  } \cfrac { \prod _{ i = 1  } ^n b _i ^{ \overline {
k  }  }  } { \prod _{ i = 1  } ^n b _i ^{ \overline { k + 1  }  }  } \\
&amp; = \cfrac { \prod _{ i = 1  } ^m ( k + a _i )  } { \prod _{ i =
1  } ^n ( k + b _i )  } \cfrac { z  } { k + 1  }
\end{aligned}
\]</span></p>
<p>换句话说,$ { t _k } <span class="math inline">\(是关于\)</span>k
<span class="math inline">\(的一个有理函数.而根据代数基本定理,任意\)</span>k
<span class="math inline">\(的有理函数在\)</span> <span class="math inline">\(内都可以分解为以上的形式(如果缺少\)</span>k + 1
<span class="math inline">\(项则需要上下同时乘以\)</span>k + 1
$以补上).</p>
<p>换句话说,对于一个无穷级数$_{ k } t _k <span class="math inline">\(,我们先将\)</span> { t _k } <span class="math inline">\(表示回超几何函数,设为\)</span>F $.</p>
<p>那么有:$_{ k } t _k = t _0 F $.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$$函数的定义)来使这些公式全部成立.But
who
cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5>
求证:$_{ k n } { k } = { n } F (
<span class="math display">\[\begin{array}{ r |  } 1 , - n \\ - n - r
\end{array}\]</span>
<p>1 ) = { r + 1 } , n \ $.</p>
<p>首先考虑:</p>
<p><span class="math display">\[
\sum _{ k \leq n  } \binom { r + k  } { k  } = \sum _{ k \geq 0  }
\binom { r + n - k  } { n - k  }
\]</span></p>
<p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<p><span class="math display">\[
\binom { r + n  } { n  } F \left ( \begin{array}
{ r |  } 1 , - n \\
- n - r
\end{array} 1 \right ) = \binom { r + n + 1  } { n  }
\]</span></p>
<p>两边同时除以$ { n } $得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5>
<p>通过范德蒙德卷积,不难验证:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r |  } a , b \\
c
\end{array} 1 \right ) = \cfrac { \Gamma ( c - a - b ) \Gamma ( c )  } {
\Gamma ( c - a ) \Gamma ( c - b )  } , - b \in \mathbb { N  }
\]</span></p>
<p>这个公式的一个特例是:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r |  } a , - n \\
c
\end{array} 1 \right ) &amp; = \cfrac { ( c - a ) ^{ \overline {
n  }  }  } { c ^{ \overline { n  }  }  } &amp; = \cfrac { ( a - c ) ^{
\underline { n  }  }  } { ( - c ) ^{ \underline { n  }  }  } , n \in
\mathbb { N  } \\
\sum _{ k \geq 0  } \cfrac { a ^{ \overline { k  }  } ( - n ) ^{
\overline { k  }  }  } { c ^{ \overline { k  }  } k !  } &amp; = \cfrac
{ ( c - a ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  }  }
&amp; = \cfrac { ( a - c ) ^{ \underline { n  }  }  } { ( - c ) ^{
\underline { n  }  }  } , n \in \mathbb { N  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r |  } a , b , - n \\
c , a + b - n - c + 1
\end{array} 1 \right ) &amp; = \cfrac { ( c - a ) ^{ \overline { n  }  }
( c - b ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  } ( c - a -
b ) ^{ \overline { n  }  }  } &amp; = \cfrac { ( a - c ) ^{ \underline {
n  }  } ( b - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline {
n  }  } ( a + b - c ) ^{ \overline { n  }  }  } , n \in \mathbb { N  }
\\

\end{aligned}\]</span>
<p>$$</p>
<p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3>
<h4><span id="example1luogu4931">Example1(luogu4931)</span></h4>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } \binom { n  } { i  } \binom { n  } { i  } i ! ( 2 n - 2 i ) ! 2 ^i
\\
&amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { k ! ( i -
k ) !  } \frac { n !  } { ( n - i ) !  } \frac { n !  } { ( n - i ) !  }
( 2 n - 2 i ) ! 2 ^i \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = k  } ^n ( - 1 )
^{ i - k  } \frac { 1  } { ( i - k ) !  } \binom { 2 n - 2 i  } { n -
i  } 2 ^{ i - k  } \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = 0  } ^{ n  }
\frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到后者只与$n - k <span class="math inline">\(有关,不妨设其为\)</span>f <em>{ n } = </em>{ i = 0
} ^{ n } { i ! } { n - i } <span class="math inline">\(,预处理一下就可以做到\)</span>O ( n ^2 + nT )
$.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } f _{ n - k  } \\
f _{ n  } &amp; = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } {
i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到$f <span class="math inline">\(是一个卷积的形式,设其生成函数为\)</span>F _n <span class="math inline">\(,\)</span>g _n = { n ! } , h _n = { n } <span class="math inline">\(,我们自然有\)</span>F = GH $.</p>
<p>考虑$G <span class="math inline">\(和\)</span>H <span class="math inline">\(的生成函数形式,先看\)</span>G
$,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum _{ n \geq 0  } \frac { ( - 2 x ) ^n  } { n !  } = e ^{ - 2 x  }
\]</span></p>
<p>再看$H $,是卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac { 1  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! ) ^2 \frac { 2 ^k  } { k !  } [ x ^{ n - k  } ] \frac { e ^{ - 2
x  }  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>现在看$F $,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F ^2 = e ^{ - 4 x  }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e ^{ - 4 x  } \\
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F ^2
\\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f _{ i + 1  } - 8 if _i &amp; = 16 f _{ i - 1  } \\
if _i &amp; = 4 ( i - 1 ) f _{ i - 1  } + 8 f _{ i - 2  }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3>
<h4><span id="求解递归关系">求解递归关系</span></h4>
<p>我们假设已经有了$R ( z ) = _{ k } g _k z ^k <span class="math inline">\(,并且\)</span>R ( z ) = { Q ( z ) } <span class="math inline">\(,其中\)</span>P ( z ) <span class="math inline">\(和\)</span>Q ( z ) <span class="math inline">\(都是多项式,我们想要找到一种方式求解\)</span>[ z ^n
] R ( z ) $.</p>
<p>考虑有理函数$S ( z ) = _{ k = 1 } ^m { 1 - <em>k z } \ <span class="math inline">\(,不难发现\)</span>[ z ^n ] S ( z ) = </em>{ k = 1
} ^m a _k _k ^n \ $.</p>
<p>那么可以证明,只要$Q ( z ) = 0 <span class="math inline">\(无重根并且无零根,那么就存在一组系数满足\)</span>S
( z ) = R ( z ) $.</p>
<p>我们这么定义”反射”运算,若$Q ( z ) = _{ k = 0 } ^m q <em>k z ^k \
<span class="math inline">\(,则其反射多项式为\)</span>Q ^R ( z ) =
</em>{ k = 0 } ^m q _k z ^{ m - k } \ $.</p>
<p>若$Q ( z ) = q <em>0 </em>{ k = 1 } ^m ( 1 - _k z ) <span class="math inline">\(,则显然有\)</span>Q ^R ( z ) = q <em>0 </em>{ k =
1 } ^m ( z - _k ) \ $.</p>
<p>那么显然这里求出来的这组数$<span class="math inline">\(就是\)</span>S
( z ) <span class="math inline">\(中的那组\)</span>$.</p>
<p>而我们有$a _k = { Q ’ ( _k ) } $.</p>
<h4><span id="example1">Example1</span></h4>
<p>已知$n ! = <em>{ k } { k } g </em>{ n - k } , n \ <span class="math inline">\(,求\)</span>g _n $.</p>
<p>首先两边同时除以$n ! $并将组合数用阶乘形式展开,我们有:</p>
<p><span class="math display">\[
1 = \sum _{ k  } \cfrac { g _{ n - k  }  } { k ! ( n - k ) !  } .
\]</span></p>
<p>如果我们令$D ( z ) = _{ k } { k ! } z ^k $,则有:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { 1  } { 1 - z  } &amp; = e ^z D ( z ) \\
D ( z ) &amp; = \cfrac { 1  } { 1 - z  } e ^{ - z  } \\
D ( z ) &amp; = ( \sum _{ k \geq 0  } z ^k ) ( \sum _{ k \geq 0  } ( - 1
) ^k \cfrac { z ^k  } { k !  } ) \\
[ z ^n ] D ( z ) &amp; = \sum _{ k = 0  } ^n \cfrac { ( - 1 ) ^k  } { k
!  }
\end{aligned}
\]</span></p>
<p>于是$g <em>n = n ! </em>{ k = 0 } ^n { k ! } \ $.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4>
<p>首先设$F _i ( x ) <span class="math inline">\(为第\)</span>i <span class="math inline">\(家的生成函数,这个是显然可以快速预处理出来的.令\)</span>M
= 520 $.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有$n <span class="math inline">\(个多项式,最高次数是\)</span>M <span class="math inline">\(,因此一共要插入\)</span>nM <span class="math inline">\(个值,又要处理每个后缀,复杂度来到\)</span>O ( n ^2
M ^3 ) <span class="math inline">\(.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到\)</span>O
( n ^2 M ^2 ) $.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到$O ( n ^2
Mq ) <span class="math inline">\(.但\)</span>n
$如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下$2 ^n <span class="math inline">\(的答案,复杂度来到\)</span>O ( nM 2 ^n q ) <span class="math inline">\(.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到\)</span>O
( { B } B 2 ^B MnM ) <span class="math inline">\(,单次询问复杂度来到\)</span>O ( { B } Mnq ) <span class="math inline">\(.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以\)</span>k
<span class="math inline">\(要大于\)</span>m $,就直接输出$0
$.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要$O ( ( nM ) ^2 q ) <span class="math inline">\(的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到\)</span>O
( nMq ) $.</p>
<h4><span id="example3十二省联考-2019皮配">Example3([十二省联考 2019]
皮配)</span></h4>
<p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为$xy , y , x , 1 <span class="math inline">\(,这样最后判断幂在一个区间内的\)</span>x <span class="math inline">\(和\)</span>y $前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是$( x ^{ s _i
} y ^{ s _i } + x ^{ s _i } ) + ( y ^{ s _i } + 1 ) = ( ( x ^{ s _i } +
1 ) ) ( ( y ^{ s _i } + 1 ) ) <span class="math inline">\(.也就是\)</span>x <span class="math inline">\(和\)</span>y $是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于$O ( mk ^2 s )
$.最后两部分合并一下.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="约定">约定</span></h3>
<p>$K _n <span class="math inline">\(为\)</span>n $个点的完全图</p>
<h3><span id="树的性质">树的性质</span></h3>
<h5><span id="example1hdu6035colorfultree">Example1([HDU6035]Colorful
Tree)</span></h5>
<p>考虑每种颜色的贡献,一种颜色的贡献显然是删去所有这个颜色的边后,剩下的联通块之间的路径.</p>
<h5><span id="example22022qbxt国庆day1tree">Example2([2022qbxt国庆Day1]tree)</span></h5>
<p>首先考虑分开处理每个点,在做每个点的时候假设它的所有子节点全部已经满足条件了,最终我们再通过计算组合数的方式计算即可.</p>
<p>那么最后,我们需要对于每个点进行处理,假设我们已知这个子树的集合是$S
<span class="math inline">\(,那么我们需要用容斥计算如果当前子树集合是\)</span>S
$的子集的情况,不难发现容斥式子:</p>
<p><span class="math display">\[
ans = \sum _{ k = \max \{ f _v | x \rightarrow v \}  } ^{ f _x  } ( - 1
) ^{ f _x - k  } k \binom { f _x  } { k  } \sum _{ x \rightarrow v  }
\binom { k  } { f _v  }
\]</span></p>
<p>其实也就是个二项式反演的形式.</p>
<p>这题还需要一些技巧优化,我们首先发现由于$f _v <span class="math inline">\(有可能有重复的,我们可以提前把重复的\)</span>f _v
<span class="math inline">\(压缩到一起再用快速幂求,于是后面的部分最多不过\)</span>
<span class="math inline">\(级别.而前面是一个类似于树上启发式合并的东西,于是复杂度\)</span>O
( n n ) $.</p>
<h5><span id="example3cf1628egroceries-in-meteor-town">Example3(CF1628E
Groceries in Meteor Town)</span></h5>
<p>因为要求路径最大值,所以先建Kruskal重构树.然后问题转化为求一个点和一群白点的LCA是谁.</p>
<p>树上多点LCA有个经典性质:也就相当于其中$dfn
$序最大的和最小的两个点的LCA.</p>
<p>至于区间覆盖可以用线段树.</p>
<h5><span id="example4loj3692">Example4(loj3692)</span></h5>
<p>注意到$D $很小.</p>
<p>我们考虑处理邻域乘,设$f <em>{ x , i } <span class="math inline">\(表示\)</span>x <span class="math inline">\(的\)</span>i <span class="math inline">\(级儿子需要乘上的答案.每次修改时,先将\)</span>f
</em>{ x , D } <span class="math inline">\(和\)</span>f _{ x , D - 1 }
<span class="math inline">\(乘上\)</span>W <span class="math inline">\(,然后令\)</span>x = fa _x <span class="math inline">\(,\)</span>D = D - 2 <span class="math inline">\(,继续此操作直到\)</span>D $为$0 $.</p>
<p>然后询问的时候直接暴力跳$D $层父亲找答案,不难发现这样做是对的.</p>
<p>同样的思路可以脱离点分治处理很多邻域问题.</p>
<h4><span id="树的直径">树的直径</span></h4>
<ol type="1">
<li><p>定义:树中最长的一条简单路径.</p></li>
<li><p>树的直径可能有多个.</p></li>
<li><p>直径的两个端点一定是两个叶子节点.</p></li>
<li><p>如果树有多条直径,树的不同的直径的中点/中边一定是相同的.</p></li>
<li><p>到一个点距离最远的点一定是直径的一个端点.</p></li>
<li><p>对于两棵树,如果第一棵树直径两端点为$( u , v ) <span class="math inline">\(,第二棵树直径两端点为\)</span>( x , y ) <span class="math inline">\(,用一条边将两棵树连接,那么新树的直径一定是\)</span>u
, v , x , y $中的两个点.</p></li>
</ol>
<p>上述的证明大都是考虑反证法:如果不成立,则一定存在一条更长的直径.</p>
<h5><span id="example1sdoi2013直径">Example1([SDOI2013]直径)</span></h5>
<p>有一个做法是:考虑找到直径的中点/中边,找到它到两边的最远距离的点,显然两边的点分别的以中点/中边的两个端点为根的LCA中间的部分就是一定会被包含的边.</p>
<h4><span id="树的重心">树的重心</span></h4>
<ol type="1">
<li><p>定义:树的重心是删去后所有剩余子树大小最大值最小的点.</p></li>
<li><p>树的重心是删去后所有剩余子树大小全部小于等于$ { 2 }
$的点.</p></li>
<li><p>树的重心只有可能有一个或两个.</p></li>
<li><p>如果树有两个重心,那么这两个重心相邻.</p></li>
<li><p>树的重心是所有点到其距离之和最小的点.</p></li>
<li><p>把一个树添加或删除一个叶子,那么它的重心最多只移动一条边的距离.</p></li>
<li><p>把两个树通过一条边相连得到一个新的树,那么新的树的重心在连接原来两个树的重心的路径上.</p></li>
</ol>
<p>(2)的证明如下:</p>
<p>如果重心是$u <span class="math inline">\(,且删去\)</span>u <span class="math inline">\(后剩余最大子树大小大于\)</span> { 2 } <span class="math inline">\(,设这棵子树中与\)</span>u <span class="math inline">\(相邻的点为\)</span>v <span class="math inline">\(,则我们删去\)</span>v
$后,最大子树大小一定会减少,不满足假设,所以(2)得证.</p>
<p>另外,如果一个点删去后所有剩余子树大小全部小于等于$ { 2 } <span class="math inline">\(,那它也一定是重心.因为不存在除了重心以外的满足条件的点:考虑调整法,与重心相邻的点一定都不满足条件,因为它们的子树大小全都小于等于\)</span>
{ 2 } <span class="math inline">\(,移动后最大子树一定不小于\)</span>n -
{ 2 } $.</p>
<p>(3)(4)的证明如下:</p>
<p>首先证明:如果有两个点都是重心,那它们一定相邻.</p>
<p>考虑如果二者不相邻,那删去它们后剩下的最大子树大小一定相等,设这两个点分别为$x
, y <span class="math inline">\(,那删去\)</span>x <span class="math inline">\(后,剩下的最大子树一定包含了\)</span>y <span class="math inline">\(,而这个子树的大小一定小于等于\)</span> { 2 } <span class="math inline">\(.那删去\)</span>y <span class="math inline">\(后,剩下的最大子树大小必定大于\)</span> { 2 }
$,一定不合法.</p>
<p>而树上不可能有超过两个点两两相邻,于是最多只有两个重心,且它们一定相邻.</p>
<p>(5)的证明如下:</p>
<p>考虑如果$u <span class="math inline">\(是树的重心,我们看能不能将\)</span>u
$调整到另一个点使得所有点到其距离之和更小.</p>
<p>由于调整是一步一步做的,显然只需要判断所有和$u <span class="math inline">\(相邻的点是否符合条件即可.设这个点为\)</span>x
<span class="math inline">\(,那我们把\)</span>u <span class="math inline">\(改为\)</span>x <span class="math inline">\(,会使答案减小\)</span>siz _x <span class="math inline">\(,增加\)</span>n - siz _x <span class="math inline">\(,由于\)</span>siz _x { 2 }
$,所以这么做一定不优.</p>
<p>(6)的证明如下:</p>
<p>首先,如果加入一个叶子节点后,各个子树大小仍然都$&lt; { 2 }
$,那显然不必调整.</p>
<p>不然,显然是往叶子节点移动一格或者加入一个相邻的重心.</p>
<p>(7)的证明如下:</p>
<p>不妨设两棵树大小分别为$siz _a siz _b
$,然后令相连的两个点是这两棵树的根.</p>
<p>对于$b <span class="math inline">\(中的重心,肯定是会往根跳,并且不可能跳出\)</span>b
$原本的树.</p>
<h5><span id="example1csp-s2019树的重心">Example1([CSP-S2019]树的重心)</span></h5>
<p>首先取重心$rt $为根,如果有两个就随便取一个.</p>
<p>接下来我们考虑对于每个点$x <span class="math inline">\(,它在什么情况下会成为重心.首先,删掉的边不可能在\)</span>x
<span class="math inline">\(的子树内,不然一定不可能取到\)</span>x <span class="math inline">\(的.然后,我们假设删掉的子树大小为\)</span>S <span class="math inline">\(,\)</span>x <span class="math inline">\(的子树内最大的一个子树大小为\)</span>g _x
$,那么根据重心的性质有:</p>
$$
<span class="math display">\[\begin{aligned}
2 ( n - S - siz _x ) &amp; \leq n - S \\
2 g _x &amp; \leq n - S \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理得到:</p>
<p><span class="math display">\[
2 g _x \leq n - S \leq 2 siz _x
\]</span></p>
<p>考虑这个怎么计算:如果没有删边必须在$x <span class="math inline">\(子树外的限制,那显然可以直接遍历一遍存下\)</span>n
- S <span class="math inline">\(,然后统一使用值域树状数组做.而我们接下来考虑删去\)</span>x
$子树内的贡献,类似colorful
tree的做法,每次dfs到一个点,记录下来当前树状数组的答案,然后dfs子树,回溯时拿新答案减去旧答案就是子树内的答案.</p>
<p>接下来我们需要考虑$x = rt $怎么做.</p>
<p>考虑$x
$的子树中最大的那个和次大的那个,如果我们删去的节点不在最大的子树中,那只需要保证最大的子树大小满足条件;不然,只需保证次大的子树大小满足条件,也是好维护的.</p>
<h4><span id="树的结构的维护">树的结构的维护</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定一棵树,树上点有点权$val <span class="math inline">\(.现在有一个值\)</span>sum $,初始为$0 $.从$1 <span class="math inline">\(号点出发,每第一次到一个点\)</span>u <span class="math inline">\(,就会使\)</span>sum + = val _u <span class="math inline">\(.求在时刻保证\)</span>sum <span class="math inline">\(的前提下,\)</span>sum $最终的最大值.</p>
<p>首先注意到为了保证$sum <span class="math inline">\(这个性质,一个节点应该有两个值:\)</span>lim <span class="math inline">\(表示能走到这个点所需要的最小的\)</span>sum <span class="math inline">\(,\)</span>val <span class="math inline">\(表示到了这个点后能获得的价值.显然如果\)</span>val
$则无意义.</p>
<p>如果我们能一开始处理出根的所有儿子的$lim <span class="math inline">\(和\)</span>val <span class="math inline">\(,我们就可以使用先走\)</span>lim <span class="math inline">\(小的点,并不断累计\)</span>sum $的方式做.</p>
<p>所以考虑不断向上合并信息.不难发现此时一个点要处理出多对$( lim , val )
$.考虑用一个左偏树维护这个东西.</p>
<p>但是,我们还需要保证不能跳着选点.也就是说我们要保证选中一个点,这个点的父亲必须选,怎么办呢?</p>
<p>一个方式是,我们把排序方法从只看$lim <span class="math inline">\(变成先判是否存在祖先后代关系,再判断\)</span>lim
$.</p>
<p>另一个方式是,我们每次直接把当前子树根节点扔到堆顶.但是需要满足堆的性质.不难发现如果这个点$val
&lt; 0 <span class="math inline">\(,我们可以将它与下面的\)</span>lim
<span class="math inline">\(最的节点合并直到这个点\)</span>val <span class="math inline">\(.而如果这个点的\)</span>lim
$太大,我们同样可以合并.注意到这样我们采取了一种很聪明的方式维护了树的形态.</p>
<h4><span id="dfs树的性质">dfs树的性质</span></h4>
<h5><span id="example1cf1361ejames-andthe-chase">Example1([CF1361E]James and
the Chase)</span></h5>
<p>如何判断一个点是否是好的呢?首先,如果要求是任意路径,那一个点是好的当且仅当它是一个叶向有根树的根.</p>
<p>现在要求是简单路径,那也就是说如果走了重复点是可以忽略的,这也就是说这个叶向有根树可以有反走边,而显然不能有横插边.不难发现这是充要条件.</p>
<p>另一个问题是:如何快速判断一个点是否满足上述条件呢?首先我们求出以一个好的点为根的dfs树(随机选取一定数量的点,如果一个都不是好点直接输出$-
1 <span class="math inline">\(),然后我们发现:一个点\)</span>u <span class="math inline">\(是好的必要条件是它的子树内只有一条反走边,证明显然.假设\)</span>u
<span class="math inline">\(通过这条反走边走到了点\)</span>v <span class="math inline">\(,那么\)</span>u <span class="math inline">\(是好的点当且仅当\)</span>v $也是好的点.</p>
<p>这是为啥呢?首先,因为我们是以一个好点为根跑的dfs树,所以$u <span class="math inline">\(走到子树内的点必定只有一种方式.那子树外的点呢?走到\)</span>v
<span class="math inline">\(后,显然就要从它走到其它点,而它到\)</span>u
<span class="math inline">\(的子树内显然只有一种方案,那如果\)</span>v
<span class="math inline">\(到其它点也只有一种方案,那么根据\)</span>u v
<span class="math inline">\(这条路径,\)</span>u $显然也是好点.</p>
<h5><span id="example2loj-6276">Example2(Loj 6276)</span></h5>
<p>找到所有颜色相同的点对$( x , y )
$,经过它们的路径都不合法,显然经过它们的路径可以用dfs序刻画成矩阵,最后要求矩阵面积并.</p>
<h3><span id="圆方树的性质">圆方树的性质</span></h3>
<ol type="1">
<li><p>对于任意的非空无向图$G <span class="math inline">\(,一定存在一个\)</span>G <span class="math inline">\(的点双连通分量\)</span>B <span class="math inline">\(,使得\)</span>B $中只有不超过$1 <span class="math inline">\(个节点是\)</span>G <span class="math inline">\(的割点.其中,若\)</span>B <span class="math inline">\(中没有\)</span>G <span class="math inline">\(的割点,则有\)</span>B = G $.</p></li>
<li><p>若一个点双连通分量不为$K _2
$,则该点双连通分量中至少有一个简单环.</p></li>
<li><p>在仙人掌上的每个点双连通分量要么是$K _2
$,要么是一个简单环.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双连通分量中的任意一个点\)</span>u <span class="math inline">\(,一定存在一个简单环\)</span>C <span class="math inline">\(使得\)</span>u <span class="math inline">\(在\)</span>C $上.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双连通分量中的任意两个点\)</span>u , v <span class="math inline">\(,一定存在一个简单环\)</span>C <span class="math inline">\(使得\)</span>u , v <span class="math inline">\(在\)</span>C $上.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双,任给一点\)</span>x <span class="math inline">\(和一边\)</span>e <span class="math inline">\(,一定存在经过\)</span>x , e $的简单环.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双,任给两点\)</span>s , t <span class="math inline">\(和一边\)</span>e <span class="math inline">\(,一定存在一条\)</span>s - e - t
$的简单路径.</p></li>
</ol>
<p>(6)的证明非常变魔术,你考虑把$e : u v <span class="math inline">\(这条边给改成\)</span>u w v <span class="math inline">\(,然后\)</span>w <span class="math inline">\(和\)</span>x <span class="math inline">\(在一个简单环上,意味着\)</span>u , w , v , x
$在一个简单环上.</p>
<p>(7)考虑(6)就行,先找到$s <span class="math inline">\(和\)</span>e
<span class="math inline">\(所在的简单环,然后从这个环上连到\)</span>t
$.</p>
<h3><span id="任意图的性质">任意图的性质</span></h3>
<ol type="1">
<li>若一张无向连通图$G $中存在$3 <span class="math inline">\(个不同的一度点\)</span>x , y , z <span class="math inline">\(,则一定存在一个点\)</span>u { x , y , z }
$使得存在$3 <span class="math inline">\(条两两没有公共边的简单路径满足其中一个端点均为\)</span>u
$ 且另一个端点分别为$x , y , z $.(证明考虑求生成树后讨论LCA)</li>
</ol>
<h3><span id="dsu-on-tree">dsu on tree</span></h3>
<h5><span id="exampleqoj5020">Example(QOJ5020)</span></h5>
<p>我们考虑树链剖分,这样将问题转化为三部分:</p>
<ol type="1">
<li><p>对于某个点而言,到它距离$d
$的点数量.这个问题可以使用点分治解决.</p></li>
<li><p>对于某条重链的上半部分而言,它连接的所有轻子树中,到它距离$d
$的点数量.这个问题直接dsu on tree.</p></li>
<li><p>对于某个点而言,在它子树内到它距离$d
$的点数量.这个问题也可以直接dsu on tree.</p></li>
</ol>
<p>为什么转化为三个部分就能求解呢?我们考虑一条链$u w v <span class="math inline">\(,其中\)</span>w <span class="math inline">\(是这条链上深度最浅的点.那么首先我们统计在\)</span>w
<span class="math inline">\(子树外的,这一个部分可以由(1)和(3)做差求出来.然后我们要求的就是在\)</span>w
<span class="math inline">\(子树内,到这条链的距离\)</span>d
$的点的数量.这个怎么求呢?我们考虑差分,求一下$1 u $和$1 w
$的答案然后做差.这样我们对这条到根的路径重链剖分,只需要处理重链的上半部分以及两条重链的连接处.不难发现两条重链的连接处会被多算一次,拿(3)减一下就好.以及这条路径所叉出去的重儿子也需要用(3).</p>
<p>现在的问题在于怎么求(2)和(3),先考虑(2),我们对于每一条重链从顶端走到低端不断地加入轻儿子,然后维护BIT就行.(3)是类似的,只不过是需要从底端走到顶端.</p>
<p>注意如果把重儿子和轻儿子分开处理,那么可能会在一些奇怪的地方算重,解决方法是特判$w
$处的答案,然后拆成两条互相之间完全没有影响的链,当然这也有可能会发生跳重链的时候轻儿子算重的情况,同样需要判断一下.</p>
<h3><span id="最小生成树">最小生成树</span></h3>
<h5><span id="example1cf1550f-jumpingaround">Example1(CF1550F Jumping
Around)</span></h5>
<p>首先考虑离线.注意到每次肯定跳到一个自己能跳到的点,而这个点应该是所需灵活度最小的点.</p>
<p>考虑boruvka算法,建立最小生成树并判断.</p>
<h3><span id="kruskal重构树">Kruskal重构树</span></h3>
<p>最小生成树时,每一次加边的时候把那个边变成虚点,两个点连到这条边上.任意两个点的LCA就是它们路径上的最小边权.</p>
<h3><span id="最短路">最短路</span></h3>
<h5><span id="example1cf1753d-the-beach">Example1(CF1753D The Beach)</span></h5>
<p>首先,自然的想法是把格子图黑白染色.</p>
<p>然后,我们注意到一个床是不可能被移动两次及以上的.因为如果是横着动两次,那不动自然就有一对空位置了;如果是转两次,考虑转的目的一定是为了空出某个位置或某两个位置(不可能为了空出三个位置,显然这么做很闲),一次操作足矣;如果是动一次转一次也是一样的,要么转的很闲要么原本就存在这么一对空位置.</p>
<p>我们再进行一步转化,考虑把动床改为动格子.换句话说,每个格子可以通过一定的代价移动到和它相邻的床的与它不相邻的那个位置上.注意到移动格子的过程只会把黑格子移动到黑格子,白格子移动到白格子.</p>
<p>于是建立超级源点跑两边最短路,枚举最后床放在哪里即可.不过这里有一点是一个床有没有可能被黑白最短路同时跑了一遍,是有可能的,但这么跑一定不优秀,不可能是最小答案.</p>
<h5><span id="example2cf843ddynamicshortest-path">Example2([CF843D]Dynamic
Shortest Path)</span></h5>
<p>注意到$O ( nq ) <span class="math inline">\(能过.而且每次修改只是对于若干条边\)</span>+ 1
$,自然想到每次修改完后跑01bfs.</p>
<p>但是怎么跑呢?注意到维护每个点最短路的增量,并且在路径的增量上跑01bfs,自然可求.</p>
<h5><span id="example3同余最短路luogup2371墨墨的等式">Example3
同余最短路([luoguP2371]墨墨的等式)</span></h5>
<p>因为$a _i <span class="math inline">\(无序,假设\)</span>a _1 <span class="math inline">\(最小,那么所有的数字都可以按\)</span>a _1 <span class="math inline">\(的结果分成\)</span>a _1 <span class="math inline">\(类.我们按照余数设置\)</span>a _1 $个点,编号为$0
<span class="math inline">\(至\)</span>a _1 - 1 $.</p>
<p>设$dis _i <span class="math inline">\(为所有能组成的数中且\)</span>a
_1 <span class="math inline">\(余数为\)</span>i <span class="math inline">\(的最小数.那么,所有能表示出来的\)</span>a _1 <span class="math inline">\(余数为\)</span>i <span class="math inline">\(的数都可以写作\)</span>dis _i + k a _1 , k <span class="math inline">\(的形式,求得\)</span>dis _i $后可以很轻易算出.</p>
<p>那么怎么求$dis _i <span class="math inline">\(呢?我们考虑:对于任意一个数\)</span>k <span class="math inline">\(,它可以怎么得到.注意到如果\)</span>k - a _j <span class="math inline">\((其中\)</span>i j <span class="math inline">\()可行,那么\)</span>k <span class="math inline">\(一定可行.自然有:\)</span>dis _i = { dis _j + a _k
| 0 j &lt; a _i , k i } $.</p>
<p>这显然是一个最短路问题.</p>
<h3><span id="差分约束">差分约束</span></h3>
<h5><span id="example1agc056c-01balanced">Example1([AGC056C] 01
Balanced)</span></h5>
<p>将$1 <span class="math inline">\(看成\)</span>- 1 $,$0 <span class="math inline">\(看成\)</span>+ 1 <span class="math inline">\(,不难发现字典序最小也就是让前缀和序列字典序最小,并且有\)</span>sum
<em>{ r <em>i } = sum </em>{ l <em>i - 1 } <span class="math inline">\(以及\)</span>- 1 sum </em>{ i } - sum </em>{ i - 1
} $,然后做$01 <span class="math inline">\(bfs跑最短路,显然最短路可以保证每个\)</span>sum
$都尽可能小.</p>
<p>然后另一个问题在于这玩意为啥不会让$sum <em>i = sum </em>{ i - 1 }
$,这个建图后观察一下就知道不会发生这种情况.</p>
<h3><span id="2-sat">2-SAT</span></h3>
<h5><span id="example1cf1697f">Example1(CF1697F)</span></h5>
<p>对每个点建立$k <span class="math inline">\(对点表示\)</span>a _i x
<span class="math inline">\(和\)</span>a _i &lt; x $,就能做了.</p>
<h5><span id="example22021集训队互测-序列">Example2(2021集训队互测 序列)</span></h5>
<p>注意到如果$a _i &lt; x <span class="math inline">\(,那么\)</span>a _j
x a _k x $,这样就可以刻画所有的条件.</p>
<p>而且一定可以刻画所有的条件.</p>
<h3><span id="对偶图">对偶图</span></h3>
<h5><span id="example1csp-s-2021交通规划">Example1([CSP-S 2021]
交通规划)</span></h5>
<p>先考虑如果附加点的颜色全都相同,那肯定输出$0 $即可.</p>
<p>考虑附加点的数量为$2
$的时候,那显然最优情况需要将整个图分成各自联通的两部分,一部分染成黑色,一部分染成白色.可以发现这就是一个对偶图.</p>
<p>而如果附加点的数量很多怎么做呢?稍微思考一下</p>
<h3><span id="广义串并联图三度化">广义串并联图/三度化</span></h3>
<h4><span id="定义">定义</span></h4>
<p>定义:不存在$4
$个点使得任意两点之间存在一条简单路径,且这六条路径不在$4
$个点之外的地方相交.</p>
<h4><span id="删一度点">删一度点</span></h4>
<p>经典问题引入:树上带权最大独立集.</p>
<p>首先dp是可以实现的,我们考虑是否存在贪心算法.</p>
<p>首先,如果不带权,我们显然可以每次选取一度点或零度点,并删去所有相连的点.这样做显然是最优的.</p>
<p>但怎么做带权的方法呢?我们注意到可以先删掉所有负点权的点,然后可以加入剩下的所有零度点.</p>
<p>那么对于一度点呢?对于一个一度点$u <span class="math inline">\(和它的相邻点\)</span>v <span class="math inline">\(,我们不能盲目选\)</span>u <span class="math inline">\(的原因是可能选取\)</span>v <span class="math inline">\(会更优秀.考虑做一个带悔贪心,我们先把\)</span>u
<span class="math inline">\(选上,然后把\)</span>v <span class="math inline">\(的权值设为\)</span>val _v - val _u <span class="math inline">\(,相当于我们仍然可以选\)</span>v <span class="math inline">\(,但是要花费\)</span>val _u <span class="math inline">\(的代价把\)</span>u $删去.</p>
<p>我们把类似这样的操作称为<strong>删一度点</strong>.</p>
<h4><span id="缩二度点">缩二度点</span></h4>
<p>问题引入:给定一个仙人掌,每个点可以染色为$0 $或$1 <span class="math inline">\(,\)</span>u $节点染成$0 <span class="math inline">\(会有\)</span>b _u <span class="math inline">\(的贡献,不然有\)</span>w _u <span class="math inline">\(的贡献.若一条边\)</span>e <span class="math inline">\(相邻的两点颜色相同则有\)</span>s _e <span class="math inline">\(的贡献,不然有\)</span>d _e $的贡献,求最大答案.</p>
<p>首先如果有一度点和零度点,我们仍然可以使用删一度点的操作.</p>
<p>如果没有,考虑仙人掌上的一个点双一定是一个简单环.而且一定存在一个点双$B
<span class="math inline">\(满足\)</span>B $只包含一个割点.</p>
<p>那么对于这个点双上的一个非割点$x <span class="math inline">\(以及和它相邻的两个点\)</span>u <span class="math inline">\(和\)</span>v <span class="math inline">\(,我们考虑\)</span>x <span class="math inline">\(的染色有可能改变\)</span>u <span class="math inline">\(和\)</span>v $的答案,那么怎么办呢?</p>
<p>冷静思考一下,我们想办法把$x <span class="math inline">\(给删掉.简单来说,我们把\)</span>u <span class="math inline">\(和\)</span>v <span class="math inline">\(之间连一条边权为\)</span>[ w <em>{ 0 , 0 } , w
</em>{ 0 , 1 } , w <em>{ 1 , 0 } , w </em>{ 1 , 1 } ] <span class="math inline">\(的边,分别表示\)</span>u <span class="math inline">\(和\)</span>v <span class="math inline">\(的染色为以上四种情况时这条边(也就是原本的\)</span>x
<span class="math inline">\()的最大贡献是什么,这显然可以通过讨论\)</span>x
<span class="math inline">\(的取值而求得.这样初始边权实际上就是\)</span>[ s ,
d , d , s ]
$,于是我们就可以删掉一个二度点并连起来与它相邻的两个点,我们把类似这样的操作称为<strong>缩二度点</strong>.</p>
<h4><span id="叠合重边">叠合重边</span></h4>
<p>注意到使用缩二度点的时候,会把一个三元环缩成两个点及链接它们的两条重边,但是我们可以直接把重边合起来,我们把类似这样的操作称为<strong>叠合重边</strong>.</p>
<h4><span id="正确性证明">正确性证明</span></h4>
<p>接下来我们证明:任何广义串并联图都可以通过以上三种操作缩为一个点.</p>
<h5><span id="引理1">引理1</span></h5>
<p>对于一个无向图$G $,若进行若干次删一度点操作,缩$2 <span class="math inline">\(度点操作以及叠合重边操作后得到的图不是广义串并联图,那么\)</span>G
$也不是广义串并联图.</p>
<p>考虑用逆操作还原原图.删一度点的逆操作是加入一个点,叠合重边的逆操作是将一条边变成两条边,这两个操作显然不会使一个不是广义串并联图的图变成广义串并联图.接下来考虑缩二度点的逆操作:删掉一条边$(
u , v ) <span class="math inline">\(并加入一个点\)</span>w <span class="math inline">\(和两条边\)</span>( u , w ) <span class="math inline">\(和\)</span>( w , v ) $.</p>
<p>由于这个图不是广义串并联图,所以一定存在一组反例点${ a , b , c , d }
$.如果我们删掉的边不在作为反例的六条边上,那显然不影响;如果在,由于新加入的两条边仍然可以作为路径,所以也不影响.</p>
<p>于是引理得证.</p>
<h5><span id="引理2">引理2</span></h5>
<p>任意一张所有点的度数都大于等于$3
$的简单无向连通图,一定不是广义串并联图.</p>
<p>这个引理的严格证明有些麻烦.我们冷静一下,一个四个点的完全图满足以上条件且不是广义串并联图.而其他的图感性理解一下应该可以通过缩路径的方式变成一个四个点的完全图.</p>
<p>结合引理1,我们得知任意一个操作后不能变成单个节点的图的无向连通图不是广义串并联图.</p>
<h5><span id="引理3">引理3</span></h5>
<p>任意一个满足$m n + k <span class="math inline">\(的图,通过删一度点,缩二度点,叠合重边操作后,\)</span>m
<span class="math inline">\(和\)</span>n <span class="math inline">\(都会到达一个\)</span>O ( k ) $的量级.</p>
<p>考虑缩完点后,所有点的度数$ $,于是有$2 m n <span class="math inline">\(,而在操作过程中,\)</span>m - n <span class="math inline">\(的值显然是不增的,于是有\)</span>m - n k <span class="math inline">\(,解一下方程得到\)</span>n k , m k $.</p>
<h4><span id="example122zr提高十连测day6摆件">Example1(22zr提高十连测day6摆件)</span></h4>
<p>首先考虑颜色之间没啥区别,所以对于一棵树来说,朴素的dp是可以的.</p>
<p>简单来说,设$dp _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(棵子树的答案.合并的时候考虑设\)</span>f _v = { k }
dp _v sam _e + { k } dp _v dif _e <span class="math inline">\(,自然有\)</span>dp <em>u = </em>{ u v } f _v \
$.</p>
<p>接下来考虑先随便找一棵生成树,然后暴力枚举多余的反走边的深度较低的叶子节点的颜色,再进行dp即可.</p>
<p>另外也可以缩点后做,不过对于这题没啥区别.</p>
<h4><span id="example2joi-open-2022放学路">Example2([JOI Open 2022]
放学路)</span></h4>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果$S <span class="math inline">\(和\)</span>T <span class="math inline">\(在一个点双中,我们找到两个点\)</span>u , v <span class="math inline">\(,使得\)</span>u v <span class="math inline">\(,并且\)</span>u $的出度至少是$2 <span class="math inline">\(,\)</span>v $的入度至少是$2
$,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为$2
<span class="math inline">\(的点\)</span>v <span class="math inline">\(,找到它的入点\)</span>u <span class="math inline">\(,如果\)</span>u $的出度不是$2 <span class="math inline">\(,那么\)</span>u $也是一个入度至少为$2 <span class="math inline">\(的点.这样往前推一定至少能推到一个点(因为不可能\)</span>S
$贡献了俩入度).</p>
<p>如何保证$S , T <span class="math inline">\(在一个点双中呢?其实只需要添加一条边\)</span>( S ,
T , dis _{ S T } ) <span class="math inline">\(就行了.显然加了后不会对答案产生影响.然后不在\)</span>S
, T $这个边双内的点也没有用了.</p>
<h3><span id="点分治">点分治</span></h3>
<h5><span id="example1cfgym101002k">Example1(CFgym101002K)</span></h5>
<p>点分治,假设当前分治重心是$g <span class="math inline">\(,将每个数缩成一个二元组\)</span>( w _i , d _i )
<span class="math inline">\(,所求就是\)</span>w _i w _j + d _i + d _j
$最小,直接排序做斜率优化.</p>
<h4><span id="点分树的性质">点分树的性质</span></h4>
<ol type="1">
<li><p>点分树的高度是$O ( n ) $级别.</p></li>
<li><p>两个点在原树上的路径一定经过其在点分树上的LCA.</p></li>
</ol>
<h5><span id="example1codechef-btree">Example1(codechef [BTREE])</span></h5>
<p>这题用到了一个经典套路:一个树形连通图的点数减去边数为$1
$,把虚树建出来,能到达一个点的守卫必然是一个树形连通图(虚树中原本没有守卫的点可以加个不同覆盖范围的守卫).于是我们只需要求出每个守卫能覆盖多少点以及两个守卫之间的那条路径能覆盖多少个点,前者用点分树轻松维护,后者的话找一下这条边上的某个满足条件的点就行.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树,现在在上面选定$m $对不同的点,要求每对点的距离之和最大.</p>
<p>考虑如果确定了$2 m <span class="math inline">\(个点,我们如何匹配他们.对每条边算贡献,假设这条边两侧分别有\)</span>a
, b <span class="math inline">\(个点,那么这条边最大的贡献就是\)</span>{
a , b } $.不难发现这个上界可以取到,只需要取这$2 m <span class="math inline">\(个点的带权重心,由于不存在绝对众数,所以直接两两匹配.枚举带权重心是啥,这样复杂度\)</span>O
( n ^2 ) $.</p>
<p>那么怎么优化呢?我们注意到如果以一个点$x <span class="math inline">\(作为根,而它有一个儿子\)</span>y <span class="math inline">\(,\)</span>y <span class="math inline">\(的子树中选了少于\)</span>m <span class="math inline">\(个点,那么我们以\)</span>y <span class="math inline">\(为根一定是不优秀的,不然一开始就不可能只选少于\)</span>m
$个点,再考虑带权重心这个东西,上点分树.</p>
<p>具体来说,我们建立点分树,然后从点分树的根开始枚举带权重心,如果当前没有一棵子树选了$m
<span class="math inline">\(个点,就停止,不然往选了\)</span>m <span class="math inline">\(个点的那棵子树走(如果有两个的话选第\)</span>m
<span class="math inline">\(大更大的那个),这样就只会选取\)</span>O ( n )
$个带权重心.</p>
<h3><span id="边分治">边分治</span></h3>
<p>需要建立虚点转二叉树.</p>
<h4><span id="边分树的性质">边分树的性质</span></h4>
<ol type="1">
<li><p>非叶子节点代表边,叶子节点代表点.</p></li>
<li><p>边分树的高度是$O ( n ) $级别.</p></li>
<li><p>边分树上每棵子树中的叶子节点一定联通.</p></li>
<li><p>是一棵完全二叉树.</p></li>
<li><p>两个点在原树上的路径一定经过其在边分树上的LCA所代表的边.</p></li>
</ol>
<h3><span id="二分图">二分图</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="最大流-最小割定理">最大流-最小割定理</span></h5>
<h5><span id="hall定理">Hall定理</span></h5>
<p>对于二分图$V _1 , V _2 , E , | V _1 | | V _2 | <span class="math inline">\(,那么该图存在完备匹配的充要条件是\)</span>Q V _1 ,
| Q | | N ( Q ) | <span class="math inline">\(,其中\)</span>N ( Q )
<span class="math inline">\(指的是所有与\)</span>Q
$中点有边相连的点的集合.</p>
<p>必要性很显然,接下来说明充分性.设$T <span class="math inline">\(为最小点覆盖,也就是最大匹配的数量,再设\)</span>M
$为最大匹配,此时自然有:</p>
<p><span class="math display">\[
| M | = | T | = | T _1 | + | T _2 | \geq | T _1 | + | N ( V _1 / T _1 )
| \geq | T _1 | + | V _1 / T _1 | = | V _1 |
\]</span></p>
<p>显然$| M | | V _1 | <span class="math inline">\(,于是\)</span>| M | =
| V _1 | $.</p>
<p>另外,Hall定理有一个推论:正则二分图一定存在完美匹配.什么叫正则二分图,就是所有的点的度数(不为$0
$)都相等的图.</p>
<p>$2 ^d
$-正则二分图求完美匹配的话,可以不断求欧拉回路并给边定向,每次把一个方向的边全都删掉,这样就转化成了$2
^{ d - 1 } <span class="math inline">\(-正则二分图,不断递归到\)</span>d
= 0 $.</p>
<h5><span id="vizing定理">Vizing定理</span></h5>
<p>设$f ( G ) <span class="math inline">\(表示将\)</span>G
$边染色,使得有公共点的边的颜色不同,最少需要的颜色数量.</p>
<p>设$( G ) <span class="math inline">\(表示\)</span>G
$中的点的最大度数.</p>
<p>对于一般图,我们有:$( G ) f ( G ) ( G ) + 1 <span class="math inline">\(,对于二分图有\)</span>( G ) = f ( G ) $.</p>
<p>考虑这个的证明:我们每次将一对点$( x , y ) <span class="math inline">\(染色,考虑设它们当前没染色的最小的颜色是\)</span>l
_x , l _y ( l _x l _y ) $,如果相等就直接选,不然类似增广路更新.</p>
<h4><span id="二分图最大权匹配">二分图最大权匹配</span></h4>
<p>假定二分图两边两两有边(不是的话可以补上$-
$的边),这样就一定存在完美匹配.</p>
<p>我们给每个点一个顶标权值$v <span class="math inline">\(,对于任意一条边\)</span>e : a b <span class="math inline">\(,它的权值是\)</span>w _e <span class="math inline">\(,我们要求\)</span>v <span class="math inline">\(满足\)</span>v _a + v _b w _e $.</p>
<p>如果我们规定了一组顶标后,取出所有满足$v _a + v _b = w _e
$的边后的图(称作相等子图)存在完美匹配,那这组完美匹配就一定是最大权匹配.</p>
<p>这是为啥呢?考虑此时的最大权其实也就是$v <span class="math inline">\(,而由于\)</span>v _a + v _b w _e <span class="math inline">\(,因此最大权匹配一定不会超过\)</span>v
$.这就是一个可达的上界.</p>
<p>那么我们该怎么得到一个相等子图呢?考虑先构造一组合法的顶标,让左部端点取边的最大值,右部端点取$0
$,然后开始增广.</p>
<p>从左侧任意一个非匹配点出发,在相等子图上走增广路并增广.如果增广失败,我们将访问过的左部端点全部减去$d
<span class="math inline">\(,右部端点全部加上\)</span>d
$,注意到此时匹配边一定不会变化,因为匹配边要么两个端点都没被访问过,要么都被访问过.而左端点被访问过,右端点没被访问过的边有可能加入相等子图,我们考虑取所有这种边的需要的差值的最小值并进行更新.但是直接这么做的复杂度有点高.</p>
<p>使用bfs优化,可以发现只会扩大$O ( n ^2 ) <span class="math inline">\(次子图,每次复杂度\)</span>O ( n ) <span class="math inline">\(,增广的复杂度类似,于是总复杂度\)</span>O ( n ^3 )
$.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-ofjapanopenstrain-contest-1489-bpoint-pairs">Example1([
XVII Open Cup named after E.V. Pankratiev. Grand Prix of
Japan(openstrain contest 1489) B]Point Pairs)</span></h5>
<p>看到这种要求横坐标或纵坐标相同的题,有一个自然的想法是建立二分图,对于点$(
x , y ) <span class="math inline">\(,将二分图左边的\)</span>x <span class="math inline">\(和右边的\)</span>y
$连一条边.那么配对等价于要每次找两条相邻的边删掉.那么如何删掉呢?</p>
<p>首先发现的是,二分图不同的连通块可以分开处理,我们接下来只讨论一个连通块的情况.如果这个连通块有奇数条边,显然一定不行.而又可以发现,如果这个连通块有一个点度数仅为$1
$,那这条边如何删是确定的,我们可以把它和另一条边删掉,不难发现怎么删最后得到的新图仍然联通.而如果不存在度数为$1
$的点呢?由于这是一个二分图,不存在奇环,所以我们可以找一个简单环删掉,之后显然也是一个连通块.我们到这里就可以发现问题了.运用数学归纳不难证明:只要一个连通块的边数是偶数就一定合法.</p>
<p>然后我们可以使用可撤销的分治解决这个问题.</p>
<h3><span id="网络流常见模型">网络流常见模型</span></h3>
<h4><span id="最大流">最大流</span></h4>
<h4><span id="最小费用最大流">最小费用最大流</span></h4>
<h4><span id="最小割">最小割</span></h4>
<p>最大流$= $最小割,证明显然.</p>
<p>最小割求方案。这个是简单的，我们删去所有流量$0 <span class="math inline">\(的边后从\)</span>S <span class="math inline">\(开始bfs，找到所有\)</span>S <span class="math inline">\(能到达的点，显然这些点（注意如果这个点一开始就不能到达\)</span>T
<span class="math inline">\(，那它是废物，不用管它，下面只讨论它能到达\)</span>T
<span class="math inline">\(的情况）组成一个SCC（为啥呢？首先\)</span>S
<span class="math inline">\(能到达它们，其次由于是最小割，因此这个点一定到达不了\)</span>T
<span class="math inline">\(，而原本是可以到达\)</span>T <span class="math inline">\(的，假设这个点是\)</span>x <span class="math inline">\(，那么一定是原本存在一条\)</span>S x T <span class="math inline">\(的路径被割掉了，也就是现在一定存在一条\)</span>x S
<span class="math inline">\(的路径）。最小割包含的边一定是这个集合和其它集合交界处的边。这是为啥呢？首先这些边一定组成了原图的一个割，其次，我们发现割不可能存在\)</span>S
<span class="math inline">\(所在SCC中，而割掉完全不连接\)</span>S <span class="math inline">\(的边可以发现不如割其中一个点在\)</span>S
$所在SCC的边。</p>
<h5><span id="example1luogup4313-文理分科">Example1(luoguP4313 文理分科)</span></h5>
<p>先把所有的满意值全部吃下,然后考虑放弃哪些.</p>
<p>对于每个人$u <span class="math inline">\(,将\)</span>S <span class="math inline">\(向他连一条流量为\)</span>art <span class="math inline">\(的边,它向\)</span>T <span class="math inline">\(连一条为\)</span>science
$的边,表示它自己要么放弃文科,要么放弃理科.</p>
<p>然后再对每个点建立一个虚点$u ’ <span class="math inline">\(,\)</span>S <span class="math inline">\(向\)</span>u ’ <span class="math inline">\(连一条为\)</span>sameart <span class="math inline">\(的边,\)</span>u ’ <span class="math inline">\(向相邻的实点连\)</span><span class="math inline">\(的边,表示要么放弃\)</span>sameart <span class="math inline">\(,要么那些点全都放弃理科.\)</span>samescience
$是同理的.</p>
<p>从这也可以看出来,大部分最小割的题目其实就是将冲突的选项放到一条路径中,然后考虑放弃哪些,将这个限制用最小割表示出来.</p>
<h5><span id="example2hnoi2013切糕">Example2([HNOI2013]切糕)</span></h5>
<p>也是显然的最小割,唯一难处理的地方在于相差$D $.</p>
<p>这个怎么做呢?建图后先每一竖轴都变成了一条链,我们在链之间加一些$<span class="math inline">\(的边,使得如果断开的两个点之差大于\)</span>D
$,那就可以通过这条边破坏最小割结构.</p>
<p>这题同样告诉我们:对于最小割题目中的限制条件,几乎都是需要考虑破坏最小割结构的(也有可能是用费用流限制).</p>
<h5><span id="example3uoj704">Example3(uoj704)</span></h5>
<p>二分图最小割计数.</p>
<p>先求出最小割,然后显然每个匹配的三条边一定会选择一条割掉.</p>
<p>不妨设$a _i = 0 / 1 / 2 <span class="math inline">\(表示第\)</span>i
$对匹配割掉了哪一条边.</p>
<p>考虑每个非匹配边$( u , v ) $对点权的限制:</p>
<ol type="1">
<li><p>$u <span class="math inline">\(在最大匹配\)</span>i <span class="math inline">\(中,\)</span>v <span class="math inline">\(不在.则\)</span>a _i = 0 $.</p></li>
<li><p>$v <span class="math inline">\(在最大匹配\)</span>i <span class="math inline">\(中,\)</span>u <span class="math inline">\(不在,则\)</span>a _i = 2 $.</p></li>
<li><p>$u <span class="math inline">\(在最大匹配\)</span>i <span class="math inline">\(中,\)</span>v <span class="math inline">\(在最大匹配\)</span>j <span class="math inline">\(中,则\)</span>a _i = 0 <span class="math inline">\(或\)</span>a _j = 2 $.</p></li>
</ol>
<p>前两种是好处理的,考虑第三种:显然所有都选$2 $或所有都选$0 <span class="math inline">\(是一种方案,更进一步地,我们将\)</span>i j
$,那么在一个强连通分量中的点一定都是$2 $或都是$0
$.这样可以缩点,缩点后发现DAG上的每一条路径的染色都形如$0 , 0 , 0 , , 0 ,
( 1 ) , 2 , , 2 , 2 , 2 $.</p>
<p>不妨折半搜索,按照拓扑排序,确定前一半哪些是$0 $,剩下是$1 / 2
$,那他们的后继必然全都是$2 $,这样后面的是$2
$的集合一定是这个后继集合的超集,高维后缀和.</p>
<p>接下来只需要判断哪些位置可以选$1 $.相当于前驱全都是$0
$并且后继全都是$2 $.</p>
<h4><span id="二分图匹配">二分图匹配</span></h4>
<h4><span id="二分图最小点覆盖">二分图最小点覆盖</span></h4>
<p>二分图最小点覆盖$= $二分图最小割.</p>
<p>问题在于如何求解方案.</p>
<p>我们从左侧的非匹配点开始dfs,走还有残留流量的路径.并将路径上所有的点全都打上标记.那么左侧所有的未标记点和右侧所有的标记点就是一组合法的方案.</p>
<p>这是为啥呢?首先我们注意到,左侧的非匹配点一定会被标记,右侧的非匹配点一定不会被标记.</p>
<p>为啥右侧的非匹配点一定不会被标记呢?因为如果被标记了,从左侧非匹配点到右侧非匹配点这条路径的起始边和终边就都是非匹配边,显然是一条增广路.</p>
<p>然后我们又注意到:对于一组匹配点,要么两者都被标记,要么两者都不被标记,因为一旦走到了右侧点,下一步必然走向左侧点.而如果走到了左侧点,也必然是从右侧点走过来的.</p>
<p>接下来我们讨论一下:</p>
<p>对于非匹配边,由于其必然连了一个左侧非匹配点,所以它的右边必然被选择了.</p>
<p>对于匹配边,不难发现它会被某个匹配点覆盖掉.</p>
<p>于是得证.</p>
<p>当然,上面的证明略显啰嗦.事实上我们这么考虑:</p>
<p>首先,我们按照套路,求出$S <span class="math inline">\(所有能到达的点.根据二分图的性质,这个点的集合必然不包括\)</span>T
$.</p>
<p>然后我们取所有不在这个点集的左侧点和所有在这个点集的右侧点,这样所有的点被分为了四个部分,边也自然被分为了四个部分,讨论一下就知道这四个部分中有一个部分是不存在边的.于是得证.</p>
<h4><span id="二分图最大独立集">二分图最大独立集</span></h4>
<p>二分图最大独立集$= n - $二分图最小点覆盖.</p>
<h5><span id="example1cf1404e">Example1(CF1404E)</span></h5>
<p>在两个可选矩形的边界处建立一个点,如果它被选了,那么说明这个矩形和上面那个矩形被一起覆盖了.然后注意到每有一个点被选,自然就多覆盖了一个矩形,显然一个矩形不可能又跟纵向的一起被覆盖又跟横向的一起被覆盖,在他俩之间连边跑最大独立集即可.</p>
<p>感觉还是类似于最小路径覆盖,将这种两个一起被覆盖就减少答案的东西转换成一整条流.</p>
<h4><span id="最大权闭合子图">最大权闭合子图</span></h4>
<p>原图的边流量设为$+ <span class="math inline">\(,然后对于每个点\)</span>x <span class="math inline">\(,如果\)</span>val _x &gt; 0 <span class="math inline">\(,那么\)</span>ans + = val _x <span class="math inline">\(,然后将\)</span>S x <span class="math inline">\(,流量为\)</span>val _x <span class="math inline">\(;不然,\)</span>x T <span class="math inline">\(,流量为\)</span>- val _x <span class="math inline">\(,然后求出最小割\)</span>w <span class="math inline">\(,答案即为\)</span>ans - w $.</p>
<h5><span id="example1luogup4177">Example1(luoguP4177)</span></h5>
<p>只需要把中间的$$边改为租用的代价即可.</p>
<h4><span id="最小路径覆盖覆盖点">最小路径覆盖(覆盖点)</span></h4>
<p>将每个点$x <span class="math inline">\(拆为两个点\)</span>A _x <span class="math inline">\(,\)</span>B _x <span class="math inline">\(,将\)</span>S <span class="math inline">\(向所有\)</span>A <span class="math inline">\(连边,\)</span>B <span class="math inline">\(向\)</span>T <span class="math inline">\(连边,如果图中存在一条路径\)</span>x y <span class="math inline">\(,则连边\)</span>A _x B _y $,流量均为$1 <span class="math inline">\(,然后求出最大流\)</span>w <span class="math inline">\(,答案即为\)</span>n - w $.</p>
<p>还有一个版本是可以重复走点,做一遍传递闭包就行.因为可重复相当于原图上的可跳点,这个版本又叫最小链覆盖.</p>
<h5><span id="example1网络流24题魔术球问题">Example1([网络流24题]魔术球问题)</span></h5>
<p>枚举球数,不断在残联网络上加边并在新图跑最小路径覆盖即可.</p>
<h4><span id="最长反链">最长反链</span></h4>
<p>反链是一个点的集合,满足这个集合中的点两两不可达.</p>
<p>最长反链$= $可重复走点的最小点覆盖(最小链覆盖).</p>
<p>为啥呢?因为发现做完传递闭包后等价于新图的最大独立集.当然图是有性质的,观察一下可重复走点的最小点覆盖就可以发现等价于传递闭包后在二分图上求最大独立集.</p>
<h5><span id="example1cf1630fmaking-itbipartite">Example1([CF1630F]Making It
Bipartite)</span></h5>
<p>首先显然的一点是,对于任意一个数字$x <span class="math inline">\(,这个序列中不能同时出现\)</span>px <span class="math inline">\(和\)</span>pqx <span class="math inline">\(,其中\)</span>p , q <span class="math inline">\(都是大于等于二的正整数.这是显然的.如果我们把图改为有向图,由\)</span>x
px $,那么整个图就只会有两种点:只有出边的点和只有入边的点.</p>
<p>那么我们该怎么办呢?如果是只能出现$x <span class="math inline">\(就不能出现\)</span>px <span class="math inline">\(,那这就是一个经典的最长反链问题.但多了一层,我们可以考虑类似分层图的思想:建立和原图完全一样的图\)</span>G
’ <span class="math inline">\(,并且将\)</span>G <span class="math inline">\(中的\)</span>x <span class="math inline">\(向\)</span>G ’ <span class="math inline">\(中的\)</span>x ’
$连有向边,然后跑最长反链.不难发现这样做是正确的.</p>
<h4><span id="平面图最小割">平面图最小割</span></h4>
<p>平面图最小割$= $对偶图最短路.</p>
<h4><span id="最小费用任意流">最小费用任意流</span></h4>
<p>一般费用流,但是当当前增广路代价为正的就停止增广.</p>
<p>和最小费用最大流不一样,这玩意是可以增量的.</p>
<p>只需要考虑所有新的从源到汇的增广路以及增加过程出现的负环即可.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<p>费用流模型很好建立,问题在于这个东西好像跑费用流有点慢.</p>
<p>那咋办呢?我们考虑到费用流是有凸性的.所以搭配一下wqs二分.</p>
<p>然后分一下三种情况讨论:</p>
<ol type="1">
<li><p>直接$S T <span class="math inline">\(的负增广路,相当于选取最小的\)</span>b <span class="math inline">\(和当前的\)</span>a $搭配.</p></li>
<li><p>有一条$S a b a S <span class="math inline">\(的负环,相当于以当前的\)</span>a <span class="math inline">\(代替前面的某个较大的\)</span>a $.</p></li>
<li><p>有一条$S a b T b a S <span class="math inline">\(的负环,注意到这个环必然没意义,因为不可能存在一条\)</span>T
S <span class="math inline">\(的负路径(不然反路径就是正的,而最小费用任意流不可能流正路径),所以这种情况不如直接选\)</span>S
T $的路径.</p></li>
</ol>
<p>讨论完拿堆模拟一下就行.</p>
<p>这引出了著名的模拟费用流算法.</p>
<h4><span id="负费用最小流">负费用最小流</span></h4>
<p>一般费用流,但是当增广当前增广路时费用变成正的就停止增广.</p>
<p>注意如果两条增广路代价相同选流量大的那条.</p>
<h4><span id="有负环的费用流">有负环的费用流</span></h4>
<p>首先注意到:如果初始图没有负环,那无论后面怎么流都不可能出来负环.因为这意味着要么是一开始流了个正环,要么是一开始有负路径不走走正路径,都不太可能.</p>
<p>对于所有的负边$u v <span class="math inline">\(,我们建立两个新点\)</span>S ’ <span class="math inline">\(和\)</span>T ’ <span class="math inline">\(,我们先将这条负边反向权值取相反数并让答案加上\)</span>f
v <span class="math inline">\(,之后令\)</span>u T ’ , S ’ v <span class="math inline">\(,跑\)</span>S ’ T ’ <span class="math inline">\(的费用流,这个时候再在残联网络上跑\)</span>s t
$的费用流就是答案.</p>
<p>为啥会这样呢?</p>
<p>首先先证明正确性,这个东西相当于一开始跑了一下$T ’ u v S ’ <span class="math inline">\(的图.然后我们在跑\)</span>S ’ T ’ <span class="math inline">\(的时候一定是可以把上面的那个东西所从\)</span>T ’ S
’
$的所有流量全都退回去,因为这是一个可以构造的上界.也就相当于我们跑了一个环流.而在费用流里跑环流显然是不会影响答案的.</p>
<p>好,那么为啥这么做就不会出现负环了呢?因为你不可能在跑$S ’ T ’
$的时候跑个正环出来,自然不可能出现负环.</p>
<p>另外有一点是,一个点可能向$S ’ <span class="math inline">\(或\)</span>T ’
$连很多边,其实是可以拼掉的,因为这些边全都是零权边,而构造完后的图是非负权边.</p>
<h4><span id="模拟费用流">模拟费用流</span></h4>
<p>对于特殊的图,模拟EK费用流的增广过程并进行操作.</p>
<p>对着例题记吧.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<h4><span id="散题">散题</span></h4>
<h5><span id="example1cqoi2014危桥">Example1([CQOI2014]危桥)</span></h5>
<p>有一个朴素的想法是:我们直接按题意建图,然后$S a _1 , b _1 <span class="math inline">\(,\)</span>T a _2 , b _2
$,跑最大流然后检查是否满流.</p>
<p>问题在于,这样有可能会出现$a _1 b _2
$的流量,我们怎么避免这种情况呢?</p>
<p>做法是,我们交换$b _1 , b _2
$并重复上面的过程,如果还是满流,我们声明一定合法.</p>
<p>为什么呢?我们注意到此时网络上的流量分为四种:$a _1 a _2 <span class="math inline">\(,\)</span>a _1 b _2 <span class="math inline">\(,\)</span>b _1 a _2 <span class="math inline">\(,\)</span>b _1 b _2 <span class="math inline">\(.不难发现\)</span>a _1 b _2 <span class="math inline">\(和\)</span>b _1 a _2 $的流量是相等的.</p>
<p>在第二次跑网络流时,我们不妨直接将$a _1 a _2 <span class="math inline">\(和\)</span>b _2 b _1 <span class="math inline">\(的流量加入答案并将这两条路径反向.此时,如果\)</span>a
_1 <span class="math inline">\(还是要走到\)</span>b _1 <span class="math inline">\(,你发现第一轮的时候已经找到了一条\)</span>b _1 a
_2 <span class="math inline">\(的路径,我们一定可以走这条来构造出只有\)</span>a _1
a _2 $的路径,另一边同理.</p>
<h3><span id="图的计数问题">图的计数问题</span></h3>
<h4><span id="prufer序列">Prufer序列</span></h4>
<p>我们可以将一颗有编号$n <span class="math inline">\(个点(\)</span>n
<span class="math inline">\()的无根树与一个长度为\)</span>n - 2 <span class="math inline">\(的Prufer序列建立双射.换句话说,一颗有编号\)</span>n
<span class="math inline">\(个节点的无根树总共有\)</span>n ^{ n - 2 }
$种(Cayley公式).</p>
<p>首先证明一个树可以对应到一个序列:每次选择一个度数为$1 <span class="math inline">\(的编号最小的点,把它连向的点加到序列中并把这个点删去,直到最后只剩下两个节点,这样我们就把一棵树对应到一个序列.不难发现每个点出现的次数是其度数\)</span>-
1 $.</p>
<p>然后证明一个序列可以还原成一棵树:</p>
<p>我们可以通过序列得知每个点的度数,每次找到度数中最小的那个点并把它与序列中的第一个元素连边并删去序列中的第一个元素,不断这么做显然可以还原树.</p>
<h5><span id="example">Example</span></h5>
<p>一个$n <span class="math inline">\(个点的图有\)</span>k <span class="math inline">\(个连通块,现在加入\)</span>k - 1
$条边使得图连通,求方案数.</p>
<p>令$s _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(个连通块的点数,\)</span>d _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(个连通块所新连上的边数,如果我们令\)</span> { c _1
, c _2 , . . . , c _m } = { c _1 ! c _2 ! . . . c <em>m ! } , </em>{ i =
1 } ^m c _i = n \ <span class="math inline">\(,也即将\)</span>n <span class="math inline">\(个位置拆分成\)</span>m <span class="math inline">\(个集合,第\)</span>i <span class="math inline">\(个集合有\)</span>c _i $个位置的方案数.</p>
<p>那我们所需要做的也就是枚举每个连通块所新连出的边数$d _i <span class="math inline">\(,于是答案即\)</span>_d [ d _i = 2 k - 2 ] { d _1 -
1 , d _2 - 1 , . . . , d <em>k - 1 } </em>{ i = 1 } ^k s _i ^{ d _i } \
$.</p>
<p>注意到我们有多项式定理:$( x _1 + x _2 + . . . + x <em>m ) ^n = </em>{
c } [ c _i = n ] { c _1 , c _2 , . . . , c <em>m } </em>{ i = 1 } ^m x
_i ^{ c _i } \ $.</p>
<p>于是原式$= n ^{ k - 2 } _{ i = 1 } ^k s _i $.</p>
<h4><span id="prufer序列的矩阵树定理理解">Prufer序列的矩阵树定理理解</span></h4>
<p>事实上,Prufer序列其实是可以拿矩阵树定理代替的(但是更麻烦一点).</p>
<p>我们先考虑证明Cayley公式:构造矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>其主余子式为:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>将所有行全部加到第一行:</p>
<p><span class="math display">\[
\begin{bmatrix}
- 1 &amp; - 1 &amp; \cdots &amp; - 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>全部加下来,然后就成了上三角矩阵,将对角线乘起来就是$n ^{ n - 2 }
$.</p>
<p>连通块的结论是类似的.</p>
<h4><span id="lgv引理">LGV引理</span></h4>
<p>设$G <span class="math inline">\(是一个有限的带权有向无环图,有点集\)</span>V <span class="math inline">\(的一个大小为\)</span>n <span class="math inline">\(的子集\)</span>A = { a _1 , a _2 , . . . , a _n }
<span class="math inline">\(作为起点集合,一个大小为\)</span>n <span class="math inline">\(的子集\)</span>B = { b _1 , b _2 , . . . , b _n }
$作为终点集合.</p>
<p>记边$i <span class="math inline">\(的权值为\)</span>w <em>i <span class="math inline">\(.对于有向路径\)</span>p <span class="math inline">\(,记路径上所有边的边权的乘积为\)</span>W ( p )
<span class="math inline">\(.记\)</span>e ( u , v ) = </em>{ p : u v } W
( p ) <span class="math inline">\(,即从\)</span>u <span class="math inline">\(到\)</span>v $的所有路径的边权乘积之和.</p>
<p>记$P : A B = ( p _1 , p _2 , . . . , p _n ) <span class="math inline">\(,\)</span>p _i <span class="math inline">\(表示从\)</span>a <em>i <span class="math inline">\(到\)</span>b </em>{ ( i ) } <span class="math inline">\(的一条路径,其中\)</span><span class="math inline">\(是一个排列,记\)</span>sign ( ) <span class="math inline">\(为\)</span>- 1 <span class="math inline">\(以这个排列的逆序对数量为幂的值.又记\)</span>( P )
<span class="math inline">\(为\)</span>P <span class="math inline">\(所对应终点的排列.若满足\)</span> i , j n , i j
<span class="math inline">\(,\)</span>p <em>i <span class="math inline">\(与\)</span>p <em>j <span class="math inline">\(没有公共点,则记作\)</span>P ^u <span class="math inline">\(,否则记作\)</span>P ^c <span class="math inline">\(,若不作区分记作\)</span>P <span class="math inline">\(.记\)</span>W </em>{ all } ( P ) = </em>{ i = 1 }
^n W ( p _i ) \ $,也就是所有路径的乘积.</p>
<p>设矩阵$M <span class="math inline">\(满足\)</span>M _{ i , j } = e (
a _i , b _j ) $,那么有:</p>
<p><span class="math display">\[
\det M = \sum _{ P ^u : A \rightarrow B  } sign ( \sigma ( P ^u ) ) W _{
all  } ( P ^u )
\]</span></p>
<p>证明:</p>
<p>根据行列式的定义,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\det M &amp; = \sum _{ \sigma  } sign ( \sigma ) \prod _{ i = 1  } ^n e
( a _i , b _{ \sigma ( i )  } ) \\
&amp; = \sum _{ \sigma  } sign ( \sigma ) \prod _{ i = 1  } ^n \sum _{ p
_i : a _i \rightarrow b _{ \sigma ( i )  }  } w ( p _i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑后面那部分,$<em>{ i = 1 } ^n </em>{ p _i : a <em>i b </em>{ ( i )
} } w ( p _i ) \ <span class="math inline">\(形如一个卷积的形式,所以这个式子等价于所有对应排列为\)</span><span class="math inline">\(的\)</span>P <span class="math inline">\(的\)</span>w ( P ) $,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\det M &amp; = \sum _{ \sigma  } sign ( \sigma ) ( \sum _{ P : \{ a _1 ,
. . . , a _n \} \rightarrow \{ b _{ \sigma ( 1 )  } , . . . , b _{
\sigma ( n )  } \}  } w ( P ) ) \\
&amp; = \sum _{ P : A \rightarrow B  } sign ( \sigma ( P ) ) w ( P ) \\
&amp; = \sum _{ P ^u : A \rightarrow B  } sign ( \sigma ( P ^u ) ) w ( P
^u ) + \sum _{ P ^c : A \rightarrow B  } sign ( \sigma ( P ^c ) ) w ( P
^c )
\end{aligned}
\]</span></p>
<p>接下来只需证明$_{ P ^c : A B } sign ( ( P ^c ) ) w ( P ^c ) = 0 \
$即可.</p>
<p>设所有$P ^c <span class="math inline">\(组成的集合为\)</span>E <span class="math inline">\(,考虑构造一个映射\)</span>f : E E
$满足如下条件:</p>
<ol type="1">
<li><p>$f ( P ^c ) P ^c $.</p></li>
<li><p>$f ( f ( P ^c ) ) = P ^c $.</p></li>
<li><p>$w ( f ( P ^c ) ) = w ( P ^c ) $.</p></li>
<li><p>$sign ( f ( P ^c ) ) = - sign ( P ^c ) $.</p></li>
</ol>
<p>上面的结论即得证.</p>
<p>我们不妨考虑$P ^c <span class="math inline">\(中的第一对相交的路径\)</span>p _i <span class="math inline">\(和\)</span>p _j
$,并交换它们的终点.显然满足上述条件,于是结论得证.</p>
<h5><span id="example">Example</span></h5>
<p>现在有$n <span class="math inline">\(个点,第\)</span>i <span class="math inline">\(个点位于\)</span>( a _i , 1 ) <span class="math inline">\(,需要走到\)</span>( b _i , n ) <span class="math inline">\(.一个在\)</span>( x , y ) <span class="math inline">\(的点可以走向\)</span>( x + 1 , y ) <span class="math inline">\(或\)</span>( x , y + 1 )
$.求路径不相交的方案数.</p>
<p>路径不相交,则终点排列只有可能是${ 1 , 2 , . . . , n }
$,直接使用LGV引理即可.</p>
<h4><span id="矩阵树定理">矩阵树定理</span></h4>
<h5><span id="无向图情况">无向图情况</span></h5>
定义无向图的度数矩阵$D ( G ) <span class="math inline">\(为:\)</span>D (
G ) _{ i , j } =
<span class="math display">\[\begin{cases}0 &amp; i \ne j \\ \deg _{
i  } &amp; i = j \end{cases}\]</span>
<p>$.</p>
令$w ( i , j ) <span class="math inline">\(为\)</span>i <span class="math inline">\(与\)</span>j <span class="math inline">\(之间直接相连的无向边个数,定义无向图的邻接矩阵\)</span>A
( G ) _{ i , j } =
<span class="math display">\[\begin{cases}0 &amp; i = j \\ w ( i , j )
&amp; i \ne j \end{cases}\]</span>
<p>$</p>
<p>定义无向图的基尔霍夫矩阵(又称拉普拉斯矩阵)$L ( G ) = D ( G ) - A ( G
) $.</p>
<p>记$t ( G ) <span class="math inline">\(为图\)</span>G <span class="math inline">\(的生成树个数,那么有:\)</span>t ( G )
$等于基尔霍夫矩阵任意一个主余子式.</p>
<p>引理:无向图的基尔霍夫矩阵的任意一个代数余子式都相等.</p>
<p>证明:考虑删去第$i <span class="math inline">\(行,设剩下的矩阵为\)</span>A = [ _1 , _2 , . . . ,
_n ] <span class="math inline">\(,根据基尔霍夫矩阵的性质,不难发现\)</span> = <span class="math inline">\(.\)</span> j &lt; k n <span class="math inline">\(,如果我们删去第\)</span>j <span class="math inline">\(列,考虑将除了第\)</span>k <span class="math inline">\(列的其它列全部加到第\)</span>k <span class="math inline">\(列,于是得到矩阵\)</span>[ <em>1 , . . . , </em>{ j
- 1 } , <em>{ j + 1 } , . . . , </em>{ k - 1 } , - <em>j , </em>{ k + 1
} , . . . , _n ] <span class="math inline">\(.我们接下来一路将第\)</span>k <span class="math inline">\(列交换到第\)</span>j + 1 <span class="math inline">\(列之前并取反,我们就得到了删去第\)</span>k <span class="math inline">\(列的矩阵,于是有\)</span>M <em>{ i , j } = ( - 1 )
^{ 1 + ( k - 1 ) - ( j + 1 ) + 1 } M </em>{ i , k } <span class="math inline">\(,也就是\)</span>C <em>{ i , j } = C </em>{ i , k }
<span class="math inline">\(,同理可证明\)</span>C <em>{ j , i } = C
</em>{ k , i } $.</p>
<p>接下来,用$T <span class="math inline">\(表示生成树的边的集合,设\)</span>w ( T ) = <em>{ e
T } w ( e ) <span class="math inline">\(,我们只需证明\)</span>C </em>{ 1
, 1 } = w ( T ) $.</p>
定义$( e , u ) = v , e = { u , v } <span class="math inline">\(,考虑构造一个\)</span>n m <span class="math inline">\(的矩阵\)</span>A <span class="math inline">\(满足\)</span>A _{ i , j } =
<span class="math display">\[\begin{cases}1 &amp; i \in e _j \land i
&lt; \zeta ( e _j , i ) \\ - 1 &amp; i \in e _j \land i &gt; \zeta ( e
_j , i ) \\ 0 &amp; other \end{cases}\]</span>
<p>\ $.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
AA ^T ( i , j ) &amp; = \sum _{ k = 1  } ^m A ( i , k ) A ^T ( k , j )
\\
&amp; = \sum _{ k = 1  } ^m A ( i , k ) A ( j , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>当$i = j <span class="math inline">\(时,不难发现\)</span>AA ^T ( i ,
j ) = _{ k = 1 } ^m [ i e _k ] = <em>i <span class="math inline">\(.不然,注意到显然为\)</span>- </em>{ k = 1 } ^m [ i
e _k ] [ j e _k ] <span class="math inline">\(.也就是说,\)</span>AA ^T =
L $.</p>
<p>定义$A <span class="math inline">\(删去第一行后得到的矩阵为\)</span>B
<span class="math inline">\(,则\)</span>BB ^T = M _{ 1 , 1 }
$.此时我们带入Cauchy-Binet公式,得到:</p>
<p><span class="math display">\[
\begin{aligned}
M _{ 1 , 1  } &amp; = \sum _{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . .
. , m \}  } \det ( B [ S ] B ^T [ S ] ) \\
&amp; = \sum _{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . . . , m \}  }
\det ( B [ S ] ) ^2
\end{aligned}
\]</span></p>
<p>接下来我们需要证明:如果$S <span class="math inline">\(集合构成了一棵生成树,那么\)</span>B [ S ] = <span class="math inline">\(.反之,\)</span>B [ S ] = 0 $.</p>
<p>如果集合没有构成一个生成树,则至少存在一个简单环.如果有某个点是孤立点那么答案肯定是$0
$,因此只需考虑每个点都与边连通的情况即可.</p>
<p>考虑这种情况下,如果有两条边$( u _1 , u _2 ) <span class="math inline">\(和\)</span>( u _2 , u _3 ) <span class="math inline">\(被选上了,那么我们可以通过列变换将它们改为\)</span>(
u _1 , u _2 ) <span class="math inline">\(和\)</span>( u _1 , u _3 )
$.这样不断进行下去,如果存在环,一定会出现重边选择的情况,这个时候行列式的值为$0
<span class="math inline">\(.如果不存在环,那么我们可以通过这个操作得到一个菊花图.所以行列式为\)</span>
$.</p>
<p>所以定理得证.</p>
<h6><span id="example省选联考-2020-a卷作业题">Example([省选联考 2020 A
卷]作业题)</span></h6>
<p>给定一个图,设第$i <span class="math inline">\(条边的权值为\)</span>w
<em>i <span class="math inline">\(,求所有生成树的\)</span>( w <em>1 , .
. . , w </em>{ n - 1 } ) </em>{ i = 1 } ^{ n - 1 } w _i $之和.</p>
<p>首先前面的$<span class="math inline">\(可以使用\)</span>I = id
$来处理.于是剩下的问题在于我们如何将一个生成树的边的和代替乘积作为贡献来求和.</p>
<p>不妨进行扩域,令$j ^2 = 0 , j <span class="math inline">\(,这样我们可以类比复数来将每个数写作\)</span>a + bj
<span class="math inline">\(的模式.考虑将每条边的边权改为\)</span>w _i j
+ 1 <span class="math inline">\(并定义新域的四则运算,取最后得到的数\)</span>a + bj
<span class="math inline">\(的\)</span>b $作为答案即可.</p>
<p>另外,注意到这样做复杂度$wn ^3 <span class="math inline">\(,很难通过.考虑每次只当边数大于等于\)</span>n - 1
<span class="math inline">\(的时候再跑行列式.不妨设\)</span>( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(的因数个数,考虑如果因数很分散,那肯定复杂度很低,不然,我们有复杂度\)</span>O
( n ^3 { n - 1 } ) $,可以通过.</p>
<h6><span id="example北京省选集训2019生成树计数">Example([北京省选集训2019]生成树计数)</span></h6>
<p>给定一个图,设第$i <span class="math inline">\(条边的权值为\)</span>w
<em>i <span class="math inline">\(,求所有生成树的\)</span>( </em>{ i = 1
} ^{ n - 1 } w _i ) ^k $之和.</p>
<p>考虑将第$e <span class="math inline">\(条边边权改为\)</span>_{ i = 0
} ^k { i ! } <span class="math inline">\(.根据多项式定理,显然最后取\)</span>[ x ^k ] <span class="math inline">\(并乘以\)</span>k ! $即可.</p>
<h5><span id="有向图情况">有向图情况</span></h5>
定义有向图的出度矩阵$D ^{ out } ( G ) =
<span class="math display">\[\begin{cases}0 &amp; i \ne j \\ \deg ^{
out  } _i &amp; i = j \end{cases}\]</span>
<p><span class="math inline">\(,类似地可以定义入度矩阵\)</span>D ^{ in }
( G ) $.</p>
令$cnte ( i , j ) <span class="math inline">\(为从\)</span>i <span class="math inline">\(直接连向\)</span>j <span class="math inline">\(的有向边个数,定义有向图的邻接矩阵\)</span>A ( G )
_{ i , j } =
<span class="math display">\[\begin{cases}0 &amp; i = j \\ cnte ( i , j
) &amp; i \ne j \end{cases}\]</span>
<p>$</p>
<p>定义有向图的出度基尔霍夫矩阵$L ^{ out } ( G ) = D ^{ out } ( G ) - A
( G ) <span class="math inline">\(,同理可以定义其入度基尔霍夫矩阵\)</span>L ^{ in }
( G ) $.</p>
<p>记$t ^{ root } ( r , G ) <span class="math inline">\(为图\)</span>G
<span class="math inline">\(以\)</span>r <span class="math inline">\(为根的根向生成树(\)</span>r <span class="math inline">\(为根时,所有边都从儿子指向父亲)个数,同理可以定义叶向生成树个数\)</span>t
^{ leaf } ( r , G ) $.</p>
<p>设$M ^{ out } <em>{ r , r } <span class="math inline">\(为\)</span>L
^{ out } <span class="math inline">\(的主余子式,有\)</span>t ^{ root } (
r , G ) = M ^{ out } </em>{ r , r } $.叶向同理.</p>
<p>下面只简单提到根向生成树的证明,叶向同理.</p>
<p>类似于无向图,我们考虑构造$n m <span class="math inline">\(矩阵\)</span>A <span class="math inline">\(和\)</span>( n - 1 ) m <span class="math inline">\(矩阵\)</span>B $:</p>
<p><span class="math display">\[
\begin{aligned}
A _{ i , j  } &amp; = \begin{cases}
1 &amp; e _j &#39; s \ head \ is \ i \\
- 1 &amp; e _j &#39; s \ tail \ is \ i \\
0 &amp; other
\end{cases} \\
B _{ i , j  } &amp; = \begin{cases}
1 &amp; e _j &#39; s \ head \ is \ i \\
0 &amp; other
\end{cases}
\end{aligned}
\]</span></p>
<p>剩下的部分与无向图类似.</p>
<h4><span id="best定理">BEST定理</span></h4>
<p>设$ec ( G ) <span class="math inline">\(为有向图\)</span>G
$的欧拉回路个数,若其存在欧拉回路,则:</p>
<p><span class="math display">\[
ec ( G ) = t ^{ root  } ( G , x ) \prod _{ i = 1  } ^n ( \deg _i - 1 ) !
\]</span></p>
<p>其中$_i = ^{ in } _i = _i ^{ out } $.</p>
<p>考虑如果勒令以$x <span class="math inline">\(为起点,我们保留除了\)</span>x <span class="math inline">\(以外每个点的最后经过的出边,最后一定会形成一棵根向树.而其他点可以随便选(由于我们勒令了每个点存在一个出边,所以不可能走到死胡同),这样的答案是\)</span>t
^{ root } ( G , x ) <em>x </em>{ i = 1 } ^n ( _i - 1 ) ! $.</p>
<p>但是如果没有规定起点,考虑循环重构,在我们选择不同的边当作初始边时,只需循环一下总体的顺序,就可以得到以另一条边为初始边的另一个图,所以答案要比规定起点的答案多除一个$_x
$.</p>
<h4><span id="格路计数问题">格路计数问题</span></h4>
<h5><span id="定义">定义</span></h5>
<ol type="1">
<li><p>在平面直角坐标系中,横坐标和纵坐标都是整数的点称为格点,平面格路是指从一个格点到另一格点只走格点的路,格路的长度是指其所走的路的步数.</p></li>
<li><p>对于一条从$( 0 , 0 ) <span class="math inline">\(到\)</span>( n ,
m ) <span class="math inline">\(的格路,若其只使用了上步\)</span>U = ( 0
, 1 ) <span class="math inline">\(,右步\)</span>L = ( 1 , 0 ) <span class="math inline">\(,则我们称其为\)</span>( n , m ) $自由路.</p></li>
<li><p>记$ ( n , m ) <span class="math inline">\(为\)</span>( n , m )
<span class="math inline">\(自由路的集合,\)</span>F ( n , m ) = # ( n ,
m ) <span class="math inline">\(为\)</span>( n , m ) <span class="math inline">\(自由路数量,即\)</span> ( n , m ) <span class="math inline">\(的元素个数,显然\)</span>F ( n , m ) = { n } \
$.</p></li>
<li><p>对于一条从$( 0 , 0 ) <span class="math inline">\(到\)</span>( n ,
m ) <span class="math inline">\(的自由路,若其始终不经过对角线\)</span>y
= { n } x <span class="math inline">\(下方,则我们称之为\)</span>( n , m
) - Dyck $路.</p></li>
<li><p>记$ ( n , m ) <span class="math inline">\(为\)</span>( n , m )
<span class="math inline">\(自由路的集合,\)</span>D ( n , m ) = # ( n ,
m ) <span class="math inline">\(为\)</span>( n , m ) <span class="math inline">\(自由路数量,即\)</span> ( n , m )
$的元素个数.</p></li>
<li><p>对于从$( 0 , 0 ) <span class="math inline">\(到\)</span>( n , m )
$的$2 <span class="math inline">\(条格路\)</span>P , Q <span class="math inline">\(,其中\)</span>P = u _1 u <em>2 . . . u </em>{ n +
m } , Q = v _1 v <em>2 . . . v </em>{ n + m } ( u <em>i , v <em>i , i =
1 , 2 , . . . , n + m ) $.若 $i , u </em>{ i + 1 } . . . u </em>{ n + m
} u _1 . . . u _i = v _1 v <em>2 . . . v </em>{ n + m } <span class="math inline">\(,则我们称格路\)</span>P , Q <span class="math inline">\(等价.将\)</span>P <span class="math inline">\(的等价格路全集记为\)</span>[ P ] $.</p></li>
<li><p>对于任意格路$P <span class="math inline">\(,记\)</span>P <em>k =
u </em>{ k + 1 } . . . u _{ n + m } u _1 . . . u _k <span class="math inline">\(,则\)</span>[ P ] = { P _k | k = 1 , 2 , 3 , · · ·
, n + m } <span class="math inline">\(.定义\)</span>P <span class="math inline">\(的周期为使得\)</span>P = P _k <span class="math inline">\(的最小数\)</span>k <span class="math inline">\(，用\)</span>period ( P ) <span class="math inline">\(表示,则显然有\)</span># [ P ] = period ( P )
$.</p></li>
</ol>
<h5><span id="定理">定理</span></h5>
<h4><span id="散模型">散模型</span></h4>
<h5><span id="多叉堆计数">多叉堆计数</span></h5>
<p>有一棵树,要求给每个点一个$[ 1 , n ]
$的权值且不同的点权值不同,满足父亲的权值小于儿子的权值,求方案数.</p>
<p>不妨设以$u <span class="math inline">\(为根节点的子树方案数为\)</span>f _u <span class="math inline">\(,\)</span>u <span class="math inline">\(的儿子是\)</span>v _1 , . . . , v _k <span class="math inline">\(,注意到\)</span>f <em>u = { siz </em>{ v <em>1 } ,
siz </em>{ v <em>2 } , . . . , siz </em>{ v <em>k } } f </em>{ v _i } =
( siz <em>u - 1 ) ! </em>{ u v } { siz _v ! } \ $.</p>
<p>那么考虑根的答案$f _1 <span class="math inline">\(,考虑不断将\)</span>f _1 <span class="math inline">\(中含有的其它\)</span>f _u $向下展开,自然的,除了$1
<span class="math inline">\(号点外,每个点对答案都贡献了一个\)</span> {
siz } <span class="math inline">\(,而根的贡献是\)</span>( n - 1 ) !
$.</p>
<p>也就是说,$ans = ( n - 1 ) ! _{ u = 2 } ^n { siz <em>u } = n ! </em>{
u = 1 } ^n { siz _u } \ $.</p>
<h6><span id="example1agc060c-large-heap">Example1([AGC060C] Large Heap)</span></h6>
<p>如果没有限制,就是一个简单的多叉堆计数.</p>
<p>而有了限制怎么做呢?我们考虑把$u $到$1 <span class="math inline">\(的路径和\)</span>v $到$1 <span class="math inline">\(的路径归并起来,会得到一条长链.我们只要确定了长链上的元素,通过组合数以及二叉堆计数,自然可以算出不在长链上的元素的答案.而对于长链上的元素,我们可以直接设计一个\)</span>O
( n ^2 ) $的dp即可.</p>
<h6><span id="example2heoi2013sao">Example2([HEOI2013]SAO)</span></h6>
<p>显然给出的是一张树形图,然后每条边有一个限制表示这条边所连接的两个点哪个更大.现在给每个点一个$[
1 , n ] $的权值且不同的点权值不同求方案数.</p>
<p>我们随便找一个点然后当成有根树做,然后如果只有父亲小于儿子的边就是简单的多叉堆计数.不然,我们可以做一个简单容斥.这样问题就又转化回多叉堆计数,容斥部分写一个树形dp就好.</p>
<p>补一下,这个树形dp没有那么简单.首先你注意到多叉堆计数是跟子树大小有关系的,所以你不能简单地设计$f
<em>{ i , j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(子树内选中了\)</span>j <span class="math inline">\(条边的代价,你必须加一维来处理子树大小,也就是设\)</span>f
</em>{ u , siz , cnt } <span class="math inline">\(表示\)</span>u <span class="math inline">\(所在连通块大小为\)</span>siz <span class="math inline">\(,子树中总共选择了\)</span>cnt $条边的代价.</p>
<p>但是注意到这题的容斥系数是$( - 1 ) ^k <span class="math inline">\(,其中\)</span>k <span class="math inline">\(是选择的儿子小于父亲的数量,然后其它的要求儿子大于父亲的边随便选.你发现你选中了一条边,无非是对答案乘以一个\)</span>-
1 <span class="math inline">\(,这是没有必要记录的.因此直接以\)</span>f
_{ u , siz } $的状态转移就行.</p>
<p>这个故事告诉我们别什么容斥都最后算,你能在做的过程中把$- 1
$乘上去就别惦记最后统一求和了.</p>
<h5><span id="三元环计数">三元环计数</span></h5>
<p>我们对原图建立一个新的有向图,在新图中,如果$u v <span class="math inline">\(,则在原图中\)</span>u &lt; v <span class="math inline">\(或\)</span>u = v u &lt; v <span class="math inline">\(.根据自然根号,每个点的出度不会超过\)</span>O ( )
$.</p>
<p>接下来枚举原图的一条边$u v <span class="math inline">\(,只要在新的图中找到\)</span>w <span class="math inline">\(满足\)</span>u v , u w , v w <span class="math inline">\(即可.打tag做一做,复杂度\)</span>O ( n ) $.</p>
<h5><span id="四元环计数">四元环计数</span></h5>
<p>仍然类似三元环计数那样建立新图.</p>
<p>考虑原图中的两条边$u v <span class="math inline">\(和\)</span>u v ’
<span class="math inline">\(,我们考虑对四元环中度数最大的那个点\)</span>w
<span class="math inline">\(计数,对于这个\)</span>w <span class="math inline">\(统计一个tag表示形如\)</span>u v w <span class="math inline">\(的数量,每次改变\)</span>u
$的时候清空一下全图tag.</p>
<h5><span id="有标号dag计数">有标号DAG计数</span></h5>
<p>即:</p>
$$
<span class="math display">\[\begin{aligned}
f _n &amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k -
1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明见反演与容斥-子集反演-Example2.</p>
<h6><span id="example1qoj5749">Example1(qoj5749)</span></h6>
<p>注意到一个环内部不能有任何边,那么其实也就是有标号DAG计数,只不过要乘上一个斯特林数.不妨设$g
_{ n , m } <span class="math inline">\(为\)</span>n <span class="math inline">\(个点\)</span>m <span class="math inline">\(条边的答案,再设\)</span>G _n
$为其生成函数.事实上,我们自然有:</p>
$$
<span class="math display">\[\begin{aligned}
G _n &amp; = \sum _{ k = 1  } \binom { n  } { k  } \sum _{ j = 1  } ^k {
k \brack j  } ( - 1 ) ^{ j - 1  } ( 1 + z ) ^{ k ( n - k )  } G _{ n -
k  } \\
&amp; = \sum _{ k = 1  } \binom { n  } { k  } ( 1 + z ) ^{ k ( n - k
)  } G _{ n - k  } \sum _{ j = 1  } ^k { k \brack j  } ( - 1 ) ^{ j -
1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>逆用斯特林公式,如果$n $:</p>
<p><span class="math display">\[
\sum _{ i  } { n \brack i  } ( - 1 ) ^{ i - 1  } = ( - 1 ) \times ( - 1
) ^{ \overline { n  }  } = [ n = 1 ]
\]</span></p>
<p>注意到$G _1 = 1 $,于是:</p>
<p><span class="math display">\[
\begin{aligned}
G _n &amp; = n ( 1 + z ) ^{ n - 1  } G _{ n - 1  } \\
&amp; = n ! ( 1 + z ) ^{ \frac { n ( n - 1 )  } { 2  }  } \\
[ z ^m ] G _n &amp; = n ! \binom { \frac { n ( n - 1 )  } { 2  }  } {
m  }
\end{aligned}
\]</span></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>反演与容斥</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="反演">反演</span></h2>
<p>假设有两个函数$f <span class="math inline">\(和\)</span>g <span class="math inline">\(满足:\)</span>f ( n ) = <em>{ k } a </em>{ n , k }
g ( k ) $,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( S ) &amp; = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S )
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
f ( S ) &amp; = \sum _{ S \subseteq T \subseteq U  } g ( T )
\Leftrightarrow g ( S ) &amp; = \sum _{ S \subseteq T \subseteq U  } ( -
1 ) ^{ | T | - | S |  } f ( T )
\end{aligned}
\]</span></p>
<p>证明:</p>
<p><span class="math display">\[
\begin{aligned}
g ( S ) &amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f (
T ) \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | T |  }
\sum _{ P \subseteq T  } g ( P ) \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) \sum _{ T
\subseteq S / P  } ( - 1 ) ^{ | T | + | P |  } \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) ( - 1 ) ^{
| P |  } \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T |  } \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) [ S &amp; =
P ] ( - 1 ) ^{ | P |  } \\
&amp; = g ( S )
\end{aligned}
\]</span></p>
<p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5>
<p>根据子集反演,设$cnt <em>S <span class="math inline">\(为集合为\)</span>S <span class="math inline">\(的数量,然后设\)</span>f <em>S = </em>{ S ’ S } cnt
</em>{ S ’ } <span class="math inline">\(,有:\)</span>ans = _{ S } 2 ^{
f _S } ( - 1 ) ^{ n - | S | } $.</p>
<p>做一遍高维前缀和就好,复杂度$O ( n 2 ^n ) <span class="math inline">\(,应该也可以用分治FMT无脑做到\)</span>O ( n ^2 2 ^n
) $.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5>
<p>设$f _{ i , j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(个点,其中有\)</span>j $个点的入度数为$0
$的方案数.(等一下,为撒子想到要记度数为$0
$的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这$j <span class="math inline">\(个点后,还剩下\)</span>k $个零度点.于是自然有:</p>
<p><span class="math display">\[
f _{ i , j  } = \binom { i  } { j  } \sum _{ k = 1  } ^{ i - j  } ( 2 ^j
- 1 ) ^k 2 ^{ j ( i - j - k )  } f _{ i - j , k  }
\]</span></p>
<p>等一下咧,这复杂度$O ( n ^3 ) $了,这咋办啊?</p>
<p>好像转移优化不太了,因为$k
$很难省去(在指数上).但我们注意到我们定义的时候说:$0 <span class="math inline">\(度点的数量恰好为\)</span>k
$,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少$k
$个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设$f ( n , S ) <span class="math inline">\(表示\)</span>n <span class="math inline">\(个点,其中只有\)</span>S $中的点的入度为$0 <span class="math inline">\(;类似定义\)</span>g ( n , S ) <span class="math inline">\(表示\)</span>n <span class="math inline">\(个点,至少\)</span>S $中的点的入度为$0 <span class="math inline">\(.显然我们所求也就是\)</span>g ( n , )
$,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n , S ) &amp; = 2 ^{ | S | ( n - | S | )  } g ( n - | S | ,
\emptyset ) \\
g ( n , S ) &amp; = \sum _{ S \subseteq T  } f ( n , T )
\end{aligned}
\]</span></p>
<p>对第二个式子用子集反演,有:</p>
<p><span class="math display">\[
f ( n , S ) = \sum _{ S \subseteq T  } ( - 1 ) ^{ | T | - | S |  } g ( n
, T )
\]</span></p>
<p>接下来使用反复带入大法:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , \emptyset ) &amp; = \sum _{ \emptyset \ne T  } f ( n , T ) \\
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } g ( n , S )
\\
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S |
( n - | S | )  } g ( n - | S | , \emptyset ) \\
&amp; = \sum _{ m = 1  } ^n \sum _{ | T | = m  } \sum _{ T \subseteq
S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S
| , \emptyset ) \\
&amp; = \sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n
\binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n
- m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k ,
\emptyset ) \\
&amp; = \sum _{ k = 1  } ^n \sum _{ m = 1  } ^k \binom { n  } { m  }
\binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \sum _{ m = 1  } ^k \binom { k  } { m  } ( - 1 ) ^{
k - m  } \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) ( ( 1 - 1 ) ^k - ( - 1 ) ^k ) \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) ( - 1 ) ^{ k - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到复杂度已经降到$O ( n ^2 ) $了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个$(
- 1 ) ^{ k - 1 }
$,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
$$
<span class="math display">\[\begin{aligned}
f _n &amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k -
1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是直接设,然后钦定其有至少$j $个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 0  } ^n C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
f ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } g (
k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k
\binom { n  } { k  } f ( k ) \\
f ( n ) &amp; = \sum _{ k = n  } ^N C _k ^n g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _k ^n f ( k ) \\
f ( n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } g (
k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^k
\binom { k  } { n  } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然以$( - 1 ) ^n g ( n ) <span class="math inline">\(代替\)</span>g
( n ) $即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k )
\\
&amp; = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^{ n - m  } ( - 1 ) ^k C _{
n - m  } ^k C _n ^m g ( m ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k \sum _{ m = 0  } ^{ n -
k  } C _{ n - k  } ^m g ( m ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k f ( n - k ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example1错排问题">Example1(错排问题)</span></h5>
<p>$n
$个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设$f ( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(个人随便站的方案数,\)</span>g ( n ) <span class="math inline">\(为\)</span>n $个人都站错的方案数.</p>
<p>如果知道$g <span class="math inline">\(的表达式,我们可以通过枚举有多少人站错位置来得到\)</span>f
<span class="math inline">\(,即:\)</span>f ( n ) = _{ k = 0 } ^n C _n ^k
g ( k ) $.</p>
<p>显然就是一个二项式反演,$g ( n ) = _{ k = 0 } ^n ( - 1 ) ^{ n - k } C
<em>n ^k f ( k ) = </em>{ k = 0 } ^n ( - 1 ) ^{ n - k } C _n ^k k !
$.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:$g
( n ) = n ! _{ 0 k n } { k ! } \ $.</p>
<p>不难发现$n ! <span class="math inline">\(的后面形如\)</span>e ^{ - 1
} $的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n ) &amp; = \cfrac { n !  } { e  } - n ! \sum _{ k &gt; n  } \cfrac
{ ( - 1 ) ^k  } { k !  } \\
&amp; = \cfrac { n !  } { e  } - \cfrac { ( - 1 ) ^{ n + 1  }  } { n +
1  } \sum _{ 0 \leq k  } ( - 1 ) ^k \cfrac { ( n + 1 ) !  } { ( k + n +
1 ) !  }
\end{aligned}
\]</span></p>
<p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有$g
( n ) = { e } + { 2 } + [ n = 0 ] $.</p>
<p>另外,观察$g <span class="math inline">\(关于\)</span>f <span class="math inline">\(的表达式,不难求出\)</span>g <span class="math inline">\(的递推式:\)</span>g ( n ) = ng ( n - 1 ) + ( - 1 )
^n $.</p>
<p>下面证明$g <em>n = ( n - 1 ) ( g </em>{ n - 1 } + g _{ n - 2 } )
$,事实上,右边等于:</p>
$$
<span class="math display">\[\begin{aligned}
( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) \\
&amp; = ( - 1 ) ^{ n - 1  } ( n - 1 ) + ( n - 1 ) \sum _{ k = 0  } ^{ n
- 2  } ( ( n - 1 ) ! \frac { ( - 1 ) ^k  } { k !  } + ( n - 2 ) ! \frac
{ ( - 1 ) ^k  } { k !  } ) \\
&amp; = n ! \sum _{ k = 0  } ^{ n - 2  } \frac { ( - 1 ) ^k  } { k !  }
- ( n - 1 ) ( - 1 ) ^n \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example2cf1750g">Example2(CF1750G)</span></h5>
<p>如果没有字典序限制就是经典的二项式反演:考虑能被分为$k <span class="math inline">\(段,说明有\)</span>n - k
$个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了$x
<span class="math inline">\(个数字,\)</span>y <span class="math inline">\(个区间,那么钦定\)</span>j <span class="math inline">\(对的方案是\)</span> { j } ( x - j ) ! <span class="math inline">\(.然后要乘上前面已经有了的,也就是乘上形如\)</span>(
1 + z ) ^k <span class="math inline">\(.这样复杂度\)</span>O ( n ^4 )
$.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的$x
, y , k <span class="math inline">\(有\)</span>O ( 1 ) <span class="math inline">\(种不同的取值,因此不用枚举.这样就是\)</span>O ( n
^3 ) <span class="math inline">\(.但是那个多项式乘法也可以规避,考虑最后的答案形如\)</span>(
1 + z ) ^k P <em>k ( x ) <span class="math inline">\(,我们考虑写成\)</span>P </em>{ n - 1 } ( z ) + = (
1 + z ) P _n ( z ) <span class="math inline">\(,然后不断这么做,就只需要\)</span>O ( n ^2 ) $.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5>
<p>不妨设至多有$i <span class="math inline">\(行\)</span>j $列最小值为$1
<span class="math inline">\(的答案是\)</span>f <em>{ i , j } <span class="math inline">\(,恰好有\)</span>i <span class="math inline">\(行\)</span>j $列最小值为$1 <span class="math inline">\(的答案是\)</span>g </em>{ i , j } $,注意到:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>令$h <em>{ n , m } = </em>{ j = 0 } ^m { j } g <em>{ n , j } \ <span class="math inline">\(,则\)</span>f </em>{ n , m } = <em>{ i = 0 } ^n {
i } h </em>{ i , m } \ <span class="math inline">\(,而\)</span>f _{ n ,
m } = k ^{ nm } ( k - 1 ) ^{ NM - nm } <span class="math inline">\(.做两次二项式反演得到\)</span>g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f
_{ n , m } { n } { m } k ^{ nm } ( k - 1 ) ^{ NM - nm }
$呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  }
g _{ s , t  } \\
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } &amp; = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ S , T  } &amp; = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S |
| T |  } \\
h _{ s , T  } &amp; = \sum _{ S \subseteq s  } ( - 1 ) ^{ | s | - | S
|  } f _{ S , T  } \\
g _{ s , t  } &amp; = \sum _{ T \subseteq t  } ( - 1 ) ^{ | t | - | T
|  } h _{ s , T  }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g <em>{ n , m } <span class="math inline">\(本身就包含了所有\)</span>| S | = n , | T | = m
<span class="math inline">\(的情况的和,并且在组合数\)</span> { j } <span class="math inline">\(那里就找到了唯一确定的\)</span>f </em>{ s , t }
<span class="math inline">\(,因此\)</span>f _{ n , m } <span class="math inline">\(是唯一确定的.这意味着这里\)</span>f <span class="math inline">\(的\)</span>n , m
$并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } f _i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个问题其实非常显然,我们的$g _{ i , j } <span class="math inline">\(定义为所有\)</span>| S | = i , | T | = j <span class="math inline">\(的答案之和.\)</span>f
$也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{
j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M } <span class="math inline">\(,那此时\)</span>g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,$g <span class="math inline">\(是已知的集合,\)</span>f <span class="math inline">\(是未知的集合.我们乘上组合数就可以得到对于\)</span>f
$来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f <span class="math inline">\(的定义改成\)</span>f _{ n , m } = k ^{ nm } ( k -
1 ) ^{ NM - nm } $就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知$n <span class="math inline">\(行\)</span>m <span class="math inline">\(列的集合的前提下,从中选出\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列并求\)</span>g <span class="math inline">\(.那么你从哪知道的\)</span>n <span class="math inline">\(行\)</span>m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } \sum _{
i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } {
j  } g _{ i , j  } \\
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } k ^{
nm  } ( k - 1 ) ^{ NM - nm  }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ’ <em>{ i ,
j } <span class="math inline">\(为至少有\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列不满足条件的方案数,自然有\)</span>f ’ </em>{ i ,
j } = f _{ N - i , M - j } $.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39; _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j
= m  } ^M \binom { j  } { m  } g &#39; _{ i , j  }
\]</span></p>
<p>最后答案就是$g ’ _{ 0 , 0 } $.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k
= 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\
f ( n ) &amp; = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k =
0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^{ n - k  } f ( k ) \\
f ( m ) &amp; = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left [
\begin{array}
{ c  } n \\
m
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) &amp; = \sum _{ k =
0  } ^M \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} f ( k ) \\
f ( m ) &amp; = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left \{
\begin{array}
{ c  } n \\
m
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) &amp; = \sum _{ k
= 0  } ^M \left [ \begin{array}
{ c  } k \\
m
\end{array} \right ] f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } &amp; = \sum _{ k = 0  } ^n
\left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} \left [ \begin{array}
{ c  } k \\
m
\end{array} \right ] ( - 1 ) ^{ n - k  } &amp; = [ m &amp; = n ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m = 0  } ^n [ m &amp; = n ] g ( m ) \\
&amp; = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( m ) \\
&amp; = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } \sum _{ m = 0  } ^k \left \{
\begin{array}
{ c  } k \\
m
\end{array} \right \} g ( m ) &amp; = \sum _{ k = 0  } ^n \left [
\begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( m ) &amp; = \sum _{ n = m  } ^M [ n &amp; = m ] g ( n ) \\
&amp; = \sum _{ n = m  } ^M \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( n ) \\
&amp; = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( n ) &amp; = \sum _{ d | n  } g ( d ) \Leftrightarrow g ( n ) &amp; =
\sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\
f ( n ) &amp; = \sum _{ n | d  } g ( d ) \Leftrightarrow g ( n ) &amp; =
\sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\
f ( x ) &amp; = \sum _{ 1 \leq d  } g ( d ) \Leftrightarrow g ( x )
&amp; = \sum _{ 1 \leq d  } f ( \cfrac { x  } { d  } ) \mu ( d )
\end{aligned}
\]</span></p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m | n  } [ \frac { n  } { m  } &amp; = 1 ] g ( m
) \\
&amp; = \sum _{ m | n  } \sum _{ d | \frac { n  } { m  }  } \mu ( d ) g
( m ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$[ d | { m } ] = [ md | n ] = [ m | { d } ] \ $.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ d | n  } \mu ( d ) \sum _{ m | \frac { n  } {
d  }  } g ( m ) \\
&amp; = \sum _{ d | n  } \mu ( d ) f ( \frac { n  } { d  } ) \\
&amp; = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第二个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ n | d  } [ \frac { d  } { n  } &amp; = 1 ] g ( d
) \\
&amp; = \sum _{ n | d  } \sum _{ c | \frac { d  } { n  }  } \mu ( c ) g
( d ) \\
&amp; = \sum _{ c | d  } \sum _{ nc | d  } \mu ( c ) g ( d ) \\
&amp; = \sum _{ c  } \mu ( c ) f ( nc ) \\
&amp; = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq d  } g ( \cfrac { x  } { d  } ) \mu ( d ) &amp; = \sum _{
d \geq 1  } \mu ( d ) \sum _{ k \geq 1  } f ( \cfrac { x  } { kd  } ) \\
&amp; = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d , k
\geq 1  } [ m &amp; = dk ] \mu ( d ) \\
&amp; = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d | m  }
\mu ( d ) \\
&amp; = f ( x )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>求长度为$n <span class="math inline">\(且仅包含小写英文字母且循环节长度恰为\)</span>n
$的字符串个数.</p>
<p>不妨设$f ( n ) <span class="math inline">\(表示长度为\)</span>n <span class="math inline">\(的字符串个数,\)</span>g ( n ) <span class="math inline">\(表示长度为\)</span>n <span class="math inline">\(且循环节长度恰为\)</span>n $的字符串个数.</p>
<p>有$f ( n ) = <em>{ d | n } g ( d ) <span class="math inline">\(,根据莫比乌斯反演,\)</span>g ( n ) = </em>{ d | n
} ( { d } ) f ( d ) $.</p>
<h4><span id="example2">Example2</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m gcd ( i , j ) \ $.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) &amp; = \sum
_{ i = 1  } ^n \sum _{ j = 1  } ^m id [ gcd ( i , j ) ] \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j
)  } \varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="交换枚举顺序">交换枚举顺序</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  }
\varphi ( d ) &amp; = \sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{
\lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac
{ m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="分离无关变量">分离无关变量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } {
d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  }
\rfloor  } _{ j = 1  } \varphi ( d ) &amp; = \sum ^{ \min ( n , m )  }
_{ d = 1  } \varphi ( d ) \times \lfloor \cfrac { n  } { d  } \rfloor
\times \lfloor \cfrac { m  } { d  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑使用数论分块,只需处理出$( d ) <span class="math inline">\(的前缀和即可在\)</span>O ( + )
$的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m [ gcd ( i , j ) = 1 ] \
$.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从$id <span class="math inline">\(变为了\)</span>$.</p>
<h4><span id="example4">Example4</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m [ gcd ( i , j ) prime ] \
$.</p>
<p>考虑增加枚举量,则:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ]
&amp; = \sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m \sum _{ p \in
prime  } [ gcd ( i , j ) &amp; = p ] \\
&amp; = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { d  }
\rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{
j = 1  } [ gcd ( pi , pj ) &amp; = p ] \\
&amp; = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { p  }
\rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { p  } \rfloor  } _{
j = 1  } [ gcd ( i , j ) &amp; = 1 ] \\
&amp; = \sum _{ p \in prime  } \sum _{ d = 1  } ^{ \min ( \lfloor \frac
{ m  } { p  } \rfloor , \lfloor \frac { n  } { p  } \rfloor )  } \mu ( d
) \lfloor \cfrac { n  } { pd  } \rfloor \lfloor \cfrac { m  } { pd  }
\rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5>
<p>考虑设$x = pd <span class="math inline">\(,则变为\)</span><em>{ x = 1
} ^{ ( n , m ) } </em>{ p prime p | x } ( { p } ) { x } { x } \ $.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4>
<p>首先先考虑去掉$lcm <span class="math inline">\(使得式子中只有\)</span>i , j , ( i , j ) $.</p>
<p>显然可以构造函数$f ( x ) = x ^{ c - d } , g ( x ) = x ^d , h ( x ) =
x ^d \ <span class="math inline">\(,然后将题目转化为\)</span>_{ j = 1 }
^n f ( gcd ( i , j ) ) g ( i ) h ( j ) x _j b _i ( p ) \ $.</p>
<p>$( i , j ) $很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出$f <em>r ( n ) <span class="math inline">\(使得\)</span>f ( n
) = </em>{ d | n } f _r ( d ) \ <span class="math inline">\(,也即\)</span>f <em>r ( n ) = </em>{ d | n } ( { d
} ) f ( d ) $.</p>
<p>则原式即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ j = 1  } ^n \sum _{ d  } [ d | i ] [ d | j ] f _r ( d ) g ( i )
h ( j ) x _j &amp; \equiv b _i ( \mod p ) \\
\sum _{ d | i  } f _r ( d ) \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j
&amp; \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$z <em>d = </em>{ j = 1 } ^n [ d | j ] h ( j ) x <em>j \ <span class="math inline">\(,有\)</span></em>{ d | i } f _r ( d ) z _d { g ( i
) } ( p ) \ $.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出$z _d $.</p>
<p>而$z <em>d = </em>{ j = 1 } ^n [ d | j ] h ( j ) x <em>j = </em>{ d |
j } ^n h ( j ) x _j <span class="math inline">\(,可以再次使用莫比乌斯反演求出\)</span>h ( j ) x _j
<span class="math inline">\(,进而求\)</span>x _j $.</p>
<p>无解条件显然是$g _i = 0 x _i $.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol type="1">
<li><p>通过增加枚举量消掉$lcm <span class="math inline">\(以及\)</span>$这些难以处理的项.</p></li>
<li><p>将$i <span class="math inline">\(与\)</span>j
$尽量分到式子两边.</p></li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p></li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4>
<p>首先注意到一个重要的事实:我们只需要询问所有$( x ) <span class="math inline">\(的\)</span>x <span class="math inline">\(,就可以得到全部信息,而这些\)</span>x
$的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \bigoplus _{ i \in A  } i [ \gcd ( i , n ) &amp; = 1 ]
\\
&amp; = \bigoplus _{ i \in A  } ^c i \sum _{ d | i , d | n  } \mu ( d )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$<em>{ d | i } ( d ) = </em>{ d | i } | ( d ) | $,于是:</p>
<p><span class="math display">\[
f ( n ) = \bigoplus _{ d | n  } | \mu ( d ) | \bigoplus _{ d | i , i \in
A  } i
\]</span></p>
<p>接下来只要我们形式上写作$n <span class="math inline">\(,我们就默认\)</span>( n ) <span class="math inline">\(,又令\)</span>g ( n ) = <em>{ n | i , i A } i
<span class="math inline">\(,此时自然有\)</span>f ( n ) = </em>{ d | n }
g ( d ) \ <span class="math inline">\(.这是一个经典的莫反形式,我们再反演回去就可以得到\)</span>g
( n ) = <em>{ d | n } ( { d } ) f ( d ) = </em>{ d | n } f ( d ) <span class="math inline">\(,也就是说我们可以求得所有的\)</span>g ( n ) <span class="math inline">\(,也就是这个集合中所有是\)</span>n
$的倍数的异或值.</p>
<p>注意一个事实:如果我们设$w ( m ) = <em>{ p prime , p | m } p <span class="math inline">\(,那么我们就可以按照\)</span>w <span class="math inline">\(的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进\)</span>A
<span class="math inline">\(的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设\)</span>S
( n ) = { x | w ( x ) = n } <span class="math inline">\(,又设\)</span>h
( n ) = </em>{ i A , i S ( n ) } i <span class="math inline">\(.考虑用\)</span>g ( n ) <span class="math inline">\(表示\)</span>h ( n ) $,我们有:</p>
<p><span class="math display">\[
g ( n ) = \bigoplus _{ n | d  } | \mu ( \frac { d  } { n  } ) | h ( d )
\]</span></p>
<p>反演,有$h ( n ) = _{ n | d } g ( d ) \ <span class="math inline">\(.于是我们可以求得所有的\)</span>h ( n ) $了.</p>
<p>现在的问题在于:对于数$n , ( n ) <span class="math inline">\(,我们要在\)</span>S ( n ) <span class="math inline">\(中选出若干个数,使得它们的异或和为\)</span>h ( n )
<span class="math inline">\(,并且选出的数字总共有\)</span>| A | $个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3>
<p>设$S $为可重集合.</p>
<p>一般形式:定义$( S ) <span class="math inline">\(,若\)</span>S
$包含重复元素则为$0 <span class="math inline">\(,否则为\)</span>( - 1 )
^{ | S | } $.</p>
$$
<span class="math display">\[\begin{aligned}
f ( S ) &amp; = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S )
&amp; = \sum _{ T \subseteq S  } \mu ( S - T ) f ( T ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3>
<p>一般形式($_n = e ^{ { n } } $):</p>
<p><span class="math display">\[
f _m = \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ mk  } g _k
\Leftrightarrow g _m = \frac { 1  } { n  } \sum _{ k = 0  } ^{ n - 1  }
\omega _n ^{ - mk  } f _k
\]</span></p>
<p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3>
<p>考虑莫比乌斯反演的过程,我们实际上使用的是$[ m | n ] _{ d | { m } } (
d ) = [ n = m ] \ $.</p>
<p>令$c = md <span class="math inline">\(,左边\)</span>= _{ c | n } [ m
| c ] ( { m } ) = ( [ c | n ] ) ( [ m | c ] ( { m } ) ) \ $.</p>
<p>令$A <em>{ c , n } = [ c | n ] <span class="math inline">\(,\)</span>B </em>{ m , c } = [ m | c ] ( { m } ) \
<span class="math inline">\(,那我们有\)</span>BA = I $.</p>
<p>刚才的过程相当于:</p>
$$
<span class="math display">\[\begin{aligned}
Ax &amp; = b \\
x &amp; = Ix \\
x &amp; = ( BA ) x \\
x &amp; = B ( Ax ) \\
x &amp; = Bb \\

\end{aligned}\]</span>
<p>$$</p>
<p>无论是二项式反演还是莫比乌斯反演,他们都满足$f ( n ) <span class="math inline">\(所依赖的\)</span>g ( k ) <span class="math inline">\(有\)</span>k n \ $.</p>
<p>根据上面的情况,我们发现$A <span class="math inline">\(是一个下三角矩阵,\)</span>B <span class="math inline">\(是\)</span>A ^{ - 1 } $.</p>
<p>现在来推导满足$k n $的一般情况反演:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 1  } ^n a _{ n , k  } g ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设算子$( n , m ) <span class="math inline">\(,满足\)</span><em>{
k = 1 } ^n a </em>{ n , k } ( k , m ) = <em>{ k = 1 } ^n ( n , k ) a
</em>{ k , m } = [ n = m ] \ $.</p>
<p>即$AB = BA = I \ $.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m = 1  } ^n [ n &amp; = m ] g ( m ) \\
&amp; = \sum _{ m = 1  } ^n \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k ,
m  } g ( m ) \\
&amp; = \sum _{ k = 1  } ^n \mu ( n , k ) f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
$$
<span class="math display">\[\begin{aligned}
c _r &amp; = \sum _{ p , q  } [ f ( p , q ) &amp; = r ] a _p b _q \\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们需要把$f
$分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2>
<h4><span id="一般形式">一般形式</span></h4>
<p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:$<em>{ i = 1 } ^n S <em>i = </em>{ T { 1 , . . . , n } } ( - 1
) ^{ | T - 1 | } </em>{ p T } S _p $.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属$m <span class="math inline">\(个集合\)</span>T _1 , . . . , T _m
$,而除了这些集合以外的集合,</p>
<p><span class="math display">\[
\begin{aligned}
cnt &amp; = \sum _{ i = 1  } ^m ( - 1 ) ^{ i - 1  } \binom { m  } { i  }
\\
&amp; = \binom { m  } { 0  } - \sum _{ i = 0  } ^m ( - 1 ) ^i \binom {
m  } { i  } \\
&amp; = 1 - [ m &amp; = 0 ]
\end{aligned}
\]</span></p>
<p>显然,当这个元素被包含的时候,贡献为$1 $,反之贡献为$0 $.</p>
<p>如果我们定义一类在集合上的函数$F ( S ) = _{ p S } F ( p )
$,那么自然也有:</p>
<p><span class="math display">\[
F ( \bigcup _{ i = 1  } ^n S _i ) = \sum _{ T \subseteq \{ 1 , . . . , n
\}  } ( - 1 ) ^{ | T | - 1  } F ( \bigcap _{ p \in T  } S _p )
\]</span></p>
<p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<p><span class="math display">\[
\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  }
^n \overline { S _i  } \mid
\]</span></p>
<p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5>
<p>考虑不定方程$_{ i = 1 } ^n x _i = m <span class="math inline">\(,和\)</span>n <span class="math inline">\(个限制条件\)</span>x _i b _i <span class="math inline">\(,其中\)</span>m <span class="math inline">\(和\)</span>b _i
$都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件):</p>
<ol type="1">
<li><p>$U <span class="math inline">\(是满足\)</span>_{ i = 1 } ^n x _i
= m $的所有非负整数解;</p></li>
<li><p>对于每个变量$i <span class="math inline">\(,都对应一个\)</span>P
_i = [ x _i b _i ] $.</p></li>
</ol>
<p>设所有满足$P <em>i <span class="math inline">\(的解构成集合\)</span>S
<em>i <span class="math inline">\(,那么我们需要求解的值就是\)</span></em>{ i = 1 }
^n S <em>i <span class="math inline">\(.而\)</span>U <span class="math inline">\(显然是\)</span> { n - 1 } <span class="math inline">\(.我们有:\)</span></em>{ i = 1 } ^n S <em>i = | U |
- </em>{ i = 1 } ^n <span class="math inline">\(.考虑对\)</span></em>{ i
= 1 } ^n <span class="math inline">\(使用容斥原理,注意到\)</span> <span class="math inline">\(的意义是满足\)</span>x <em>{ i } b </em>{ i } + 1
$的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5>
<p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件):</p>
<ol type="1">
<li><p>$U <span class="math inline">\(是长度为\)</span>n
$的所有排列;</p></li>
<li><p>对于每个变量$i <span class="math inline">\(,都对应一个\)</span>P
_i = [ p _i i ] $.</p></li>
</ol>
<p>注意到所求仍然是$<em>{ i = 1 } ^n S <em>i <span class="math inline">\(.于是我们仍然试图\)</span>| </em>{ k = 1 } ^m |
<span class="math inline">\(.考虑其意义,也即:有\)</span>m <span class="math inline">\(个位置被确定了,而其它位置没有限制,于是\)</span>|
</em>{ k = 1 } ^m | = { m } ( n - m ) ! <span class="math inline">\(.根据容斥,自然有:\)</span>d <em>n = n ! - </em>{ m
= 1 } ^n ( - 1 ) ^{ m - 1 } { m } ( n - m ) ! = n ! _{ m = 0 } ^n { m !
} $.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5>
<p>首先可以用dp+双指针得到$f _i <span class="math inline">\(表示勒令\)</span>i <span class="math inline">\(对满足条件的方案数.把\)</span>k <span class="math inline">\(的定义改为恰好\)</span>k
$对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a <span class="math inline">\(对的方案会被恰好\)</span>b <span class="math inline">\(对的方案计算\)</span> { a } <span class="math inline">\(次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为\)</span>k
$的方案贡献为$1 <span class="math inline">\(,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为\)</span>k
+ 1 $的方案贡献为$0 <span class="math inline">\(,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令\)</span>ans
= f <em>k <span class="math inline">\(,第二步除去其中被多算的\)</span>k
+ 1 <span class="math inline">\(,这一步令\)</span>ans - = { k } f </em>{
k + 1 } <span class="math inline">\(.这个时候,我们再考虑\)</span>k + 2
<span class="math inline">\(的贡献:它将在\)</span>f <em>k <span class="math inline">\(时贡献\)</span> { k } <span class="math inline">\(次,在\)</span>f </em>{ k + 1 } <span class="math inline">\(时贡献\)</span>- { k + 1 } { k } = - { k } { 1 }
<span class="math inline">\(次,那它现在的贡献还有:\)</span>- { k } <span class="math inline">\(次.以此类推,可以得到\)</span>ans = _{ i = k } ^n f
_i ( - 1 ) ^{ i - k } { k } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P
_i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i <span class="math inline">\(,因为只有这个时候,我们才能通过分析满不满足\)</span>P
_i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1
/ 0 $就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5>
<p>如果直接对于每次询问暴力做,复杂度显然是$O ( 4 ns )
$,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画$P
_i = [ use _i d _i ] <span class="math inline">\(,从而可以用容斥做.复杂度\)</span>O ( 4 m + n 2 ^4
) $.</p>
<h5><span id="example5">Example5</span></h5>
<p>Alice和Bob在玩游戏,他们有一个$n <span class="math inline">\(个点的无向完全图,设所有的边组成了集合\)</span>E
<span class="math inline">\(,他们想取遍\)</span>E <span class="math inline">\(的所有非空子集,对某个集合\)</span>S <span class="math inline">\(有一个估价\)</span>f ( S ) <span class="math inline">\(:考虑\)</span>n <span class="math inline">\(个点与\)</span>S <span class="math inline">\(中的边组成的图,我们用\)</span>m <span class="math inline">\(种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么\)</span>f
( S ) <span class="math inline">\(等于这个图的染色方案数.同时,Alice喜欢奇数,所以当\)</span>|
S | <span class="math inline">\(为奇数时,Alice的分值加上\)</span>f ( S )
<span class="math inline">\(,否则Alice的分值减去\)</span>f ( S ) <span class="math inline">\(,求最后的分值.\)</span>( n , m ^6 ) $.</p>
<p>一开始抄题的时候没有写染色而是直接写”设$k <span class="math inline">\(为连通块个数,则\)</span>f ( S ) = m ^k <span class="math inline">\(.&quot;然后发现做不了,因为\)</span>| S | <span class="math inline">\(相同的\)</span>f ( S ) <span class="math inline">\(不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个\)</span>m
$,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那$x y col _x = col _y <span class="math inline">\(.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与\)</span>-
1 <span class="math inline">\(有关的单位元素(从一开始就是点)和与\)</span>f
$有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令$F ( C ) <span class="math inline">\(表示在\)</span>C <span class="math inline">\(情况下的染色方案,\)</span>T _{ ( i , j ) } <span class="math inline">\(表示满足边\)</span>( i , j ) $限制的解集:</p>
<p><span class="math display">\[
ans = \sum _{ \emptyset \ne S \subseteq E  } ( - 1 ) ^{ | S | - 1  } F (
\bigcap _{ ( i , j ) \in S  } T _{ ( i , j )  } )
\]</span></p>
<p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出$ans
<span class="math inline">\(的意义:显然是\)</span>F ( _{ i = 1 } ^{ m }
P _i ) <span class="math inline">\(.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是\)</span>m
^n - m ^{ } $.</p>
<h5><span id="example6">Example6</span></h5>
<p>求$( n ) $.</p>
<p>考虑这么一个事实:假设$n = p _i ^{ q _i } <span class="math inline">\(,注意到令\)</span>P <em>i = [ ( i , n ) = 1 ]
<span class="math inline">\(,我们所求也就是\)</span></em>{ i = 1 } ^n S
_i $.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5>
<p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如$ABCABCAB
. . . $这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于$3
$并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5>
<p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的$1
$,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是$_{ i = 0 } ^{ ( n , m ) } ( - 1 ) ^i { i } { i
} i ! ( m + 1 ) ^{ n - i } ( n + 1 ) ^{ m - i } $.</p>
<h5><span id="example9">Example9</span></h5>
<p>给定若干个限制条件$( x , y ) <span class="math inline">\(,表示\)</span>a _x = y <span class="math inline">\(和\)</span>a _y = x
$必须满足至少一个,求排列方案数.</p>
<p>首先$i p _i
$把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为$2
<span class="math inline">\(的链,它自己成环的话是不用\)</span> $的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是$
$,所以一个有$1
$个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为$2
$的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-squareconstraints">Example10([AGC036F] Square
Constraints)</span></h5>
<p>由题意得:$n ^2 - i ^2 P _i ^2 ( 2 n ) ^2 - i ^2 $.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为$l
<em>i <span class="math inline">\(,那么只有上界的答案应该是什么呢?将\)</span>l <span class="math inline">\(从小到大排序,答案就是\)</span></em>{ i = 0 } ^{ 2
n - 1 } ( l <em>i - i ) <span class="math inline">\(.(注意到必须满足\)</span>l </em>{ 2 n - 1 } = 2 n
- 1 $.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个$
{ 4 } <span class="math inline">\(的圆弧.而通过圆弧的性质不难看出:最终的\)</span>l
<span class="math inline">\(分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道\)</span>l
<span class="math inline">\(按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照\)</span>l
<span class="math inline">\(的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度\)</span>O
( n ^3 ) $.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5>
<p>(下面将$n <span class="math inline">\(和\)</span>m $反着写)</p>
<p>设$p = { n } , q = n - p $.</p>
<p>首先注意到期望$= P [ len ] + P [ len ] + $.</p>
<p>考虑如何计算$P [ len x ] <span class="math inline">\(,如果我们设\)</span>a _i <span class="math inline">\(表示以\)</span>i <span class="math inline">\(作为开头的极长的带劲的长度大于等于\)</span>x <span class="math inline">\(的序列的集合,那么最后无非是要求所有\)</span>a
<span class="math inline">\(的并.考虑用容斥做到求所有\)</span>a
$的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5>
<p>给定$n , k <span class="math inline">\(和\)</span>n <span class="math inline">\(个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过\)</span>k
<span class="math inline">\(.\)</span>n $.</p>
<p>著名结论:$n <span class="math inline">\(个点\)</span>m <span class="math inline">\(个连通块任意连边成树的方案数是\)</span>n ^{ m - 2
} s <span class="math inline">\(,其中\)</span>s <span class="math inline">\(是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过\)</span>k
<span class="math inline">\(,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于\)</span>k
<span class="math inline">\(的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过\)</span>k
$,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数$( - 1 ) ^{ 块 数
- 1 } $.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4>
<p>对于:</p>
<p><span class="math display">\[
\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . .
, n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid
\]</span></p>
<p>考虑一个特例:$S _i = { 1 , 2 , , a _i } <span class="math inline">\(,那么上面的式子导出min-max容斥(我们设\)</span>S =
{ a _1 , a _2 , , a _n } $)(第二个式子可以把前缀改成后缀):</p>
<p><span class="math display">\[
\begin{aligned}
\max ( S ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{
| T | - 1  } \min ( T ) \\
\min ( S ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{
| T | - 1  } \max ( T )
\end{aligned}
\]</span></p>
<p>由于是集合,这个式子在期望意义下同样成立:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \max \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } (
- 1 ) ^{ | T | - 1  } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } (
- 1 ) ^{ | T | - 1  } E ( \max \{ S \} )
\end{aligned}
\]</span></p>
<p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<p><span class="math display">\[
\begin{aligned}
kth \max \{ S \} &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( -
1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \min \{ T \} \\
kth \min \{ S \} &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( -
1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \max \{ T \} \\
E ( kth \max \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne
\emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E
( \min \{ T \} ) \\
E ( kth \min \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne
\emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E
( \max \{ T \} )
\end{aligned}
\]</span></p>
<p>原理是消掉前$k - 1 $大的数字,让他们的贡献为$0
$,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5>
<p>不妨设$tim _i <span class="math inline">\(为\)</span>[ i , i + 1 ]
$第一次被覆盖的时间,答案就是:</p>
<p><span class="math display">\[
E ( \max _{ i = 1  } ^{ n - 1  } \{ tim _i \} ) = \sum _{ T \subseteq \{
1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E
( \min _{ j \in T  } \{ tim _j \} )
\]</span></p>
<p>设$f ( S ) <span class="math inline">\(为有多少个区间能覆盖至少一个\)</span>[ i , i + 1 ]
, i S <span class="math inline">\(,考虑\)</span>E = p <em>{ [ t ] } + p
</em>{ [ t ] } + p <em>{ [ t ] } + <span class="math inline">\(,于是\)</span>E ( </em>{ j S } { tim _j } ) = { f
( S ) } $.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne
\emptyset  } ( - 1 ) ^{ | T | - 1  } f ( T ) \\
&amp; = \sum _{ k = 0  } ^m \frac { m  } { k  } \sum _{ T \subseteq \{ 1
, 2 , \cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k  } ( - 1 ) ^{ |
T | - 1  }
\end{aligned}
\]</span></p>
<p>注意到$f ( S ) <span class="math inline">\(可能不那么好求,我们求\)</span>g ( S ) = m - f ( S
) <span class="math inline">\(,也就是不包含任何一个\)</span>[ i , i + 1
] , i S $的区间个数,我们有:</p>
<p><span class="math display">\[
ans = \sum _{ k = 0  } ^m \frac { m  } { m - k  } \sum _{ T \subseteq \{
1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k  } ( - 1 ) ^{
| T | - 1  }
\]</span></p>
<p>这里已经不难写出$O ( n ^3 ) $的dp了.</p>
<p>那么怎么优化呢?设$dp <em>{ i , j } <span class="math inline">\(表示只考虑\)</span>[ 1 , i ] <span class="math inline">\(时(\)</span>[ i - 1 , i ] <span class="math inline">\(必选),\)</span></em>{ g ( T ) = j } ( - 1 ) ^{ | T
| - 1 } <span class="math inline">\(的答案,不难发现每次加入一个区间\)</span>[ l , r ]
<span class="math inline">\(就会让\)</span>dp <em>{ i , j } , i &lt; = l
<span class="math inline">\(对\)</span>dp </em>{ r , j + 1 }
$的贡献乘一个$1 $.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度$O
( nm n ) $.</p>
<h4><span id="反射容斥">反射容斥</span></h4>
<p>一般形式:给定二维平面上两个点$S <span class="math inline">\(和\)</span>T <span class="math inline">\(,其中\)</span>T <span class="math inline">\(在\)</span>S <span class="math inline">\(的右方,给定两条线\)</span>y = a <span class="math inline">\(和\)</span>y = b <span class="math inline">\(,每次可以向右上或者右下走一步,求不碰线的从\)</span>S
<span class="math inline">\(到\)</span>T $的方案数.</p>
<p>我们不妨设$A <span class="math inline">\(表示一定碰了一次上界的方案数,\)</span>B <span class="math inline">\(表示一定碰了一次下界的方案数,\)</span>AB
$表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走$- A - B + AB + BA - ABA - BAB . . . $.</p>
<p>考虑设步数为$n <span class="math inline">\(,那显然长度最多为\)</span>
{ a - b } $.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3>
<p>$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,有\)</span>n <span class="math inline">\(颗石子,每次可以取\)</span>x $颗,其中$1 x m \ <span class="math inline">\(,求\)</span>A $是否能赢.</p>
<p>考虑直接令石子数量为状态,有$SG ( x ) = mex { SG ( y ) | { 0 , x - m }
y x - 1 } \ <span class="math inline">\(,注意到\)</span>SG ( x ) = 0
<span class="math inline">\(当且仅当\)</span>x ( m + 1 ) $.</p>
<p>我们使用数学归纳证明:</p>
<p>当$0 x m $时,显然成立.</p>
<p>而对于$x <span class="math inline">\(,如果\)</span>x ( m + 1 ) \
<span class="math inline">\(,那么集合\)</span>S = { y | { 0 , x - m } y
x - 1 } <span class="math inline">\(中一定\)</span>y <span class="math inline">\(满足\)</span>y ( m + 1 ) \ $.</p>
<p>也就是$y <span class="math inline">\(满足\)</span>SG ( y ) = 0 <span class="math inline">\(,那么\)</span>SG ( n ) = 0 $.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3>
<p>$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,有\)</span>n <span class="math inline">\(堆石子,第\)</span>i <span class="math inline">\(堆石子有\)</span>x _i
$个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果$x $均等于$0 <span class="math inline">\(一定先手必败.考虑令\)</span>w = x _1 x _2 . . . x
_n <span class="math inline">\((\)</span>w <span class="math inline">\(即为全游戏的\)</span>SG <span class="math inline">\(值),那么先手必败当且仅当\)</span>w = 0 \ $.</p>
<p>证明:</p>
<p>只需证明当$w <span class="math inline">\(时一定存在一种方法使得\)</span>w = 0 \ $.</p>
<p>考虑$w <span class="math inline">\(的最高位为第\)</span>k <span class="math inline">\(位,那么一定存在一个\)</span>x _i <span class="math inline">\(的第\)</span>k $位为$1 $.将它改为$0 <span class="math inline">\(,然后这个\)</span>x _i
$的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4>
<p>$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,有\)</span>n <span class="math inline">\(堆石子,第\)</span>i <span class="math inline">\(堆石子有\)</span>x _i <span class="math inline">\(个石子.每次可以任选不超过\)</span>k
$堆取走若干个石子,最后不能取的人输.</p>
<p>将$x _i $写成二进制,如果每一位的$1 <span class="math inline">\(的个数均是\)</span>k + 1
$的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4>
<p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于$2
$的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p>$SG ( x ) = mex { { SG ( v ) | x v } , { SG ( x - i ) SG ( i ) | 1 i
&lt; x } } \ $.</p>
<p>找一下规律可以发现:</p>
$$
<span class="math display">\[\begin{aligned}
SG ( x ) &amp; = \begin{cases}
x - 1 &amp; x \equiv 0 ( \mod 4 ) \\
x &amp; x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 &amp; x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设当$x k $时结论成立.</p>
<p>当$x = 4 k + 1 <span class="math inline">\(时,前半部分一定是取遍了\)</span>[ 1 , 4 k ] $.</p>
<p>但是一定不存在$a <span class="math inline">\(和\)</span>b <span class="math inline">\(满足\)</span>a + b = 4 k + 1 <span class="math inline">\(并且\)</span>SG ( a ) SG ( b ) = 4 k + 1 <span class="math inline">\(.讨论一下\)</span>a <span class="math inline">\(和\)</span>b <span class="math inline">\(在\)</span> $意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3>
<p>$n <span class="math inline">\(个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.\)</span>A
<span class="math inline">\(和\)</span>B
$每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用$SG ( u ) = mex { SG ( v ) | u v } $.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是$0 $.</p>
<p>首先如果$SG ( u ) = x <span class="math inline">\(,那么\)</span> y
&lt; x <span class="math inline">\(,\)</span>v <span class="math inline">\(使得\)</span>u v <span class="math inline">\(且\)</span>SG ( v ) = y
$.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能$y &gt; x $,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个$u ’ <span class="math inline">\(使得\)</span>SG ( u ’ ) = x $,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4>
<p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol type="1">
<li><p>游戏的SG函数不为$0 $且游戏中某个单一游戏的SG函数大于$1
$.</p></li>
<li><p>游戏的SG函数为$0 $且游戏中没有单一游戏的SG函数大于$1 $.</p></li>
</ol>
<p>如果没有单一游戏的SG函数大于$1 $,那么显然游戏的SG函数为$0
$就赢了,否则就输了.</p>
<p>而如果SG函数为$0 $且存在某个单一游戏的SG函数大于$1 $,一定是输的.</p>
<p>因为这个情况下,后手先按照正常$SG
$游戏压着先手,最后一定会剩两堆一样大于$1
$的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4>
<p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在$DAG <span class="math inline">\(上dp的时候除了\)</span>SG
$我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4>
<p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4>
<p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:$SG ( u ) = _{ u v } ( SG ( v ) + 1 ) $.</p>
<p>考虑归纳假设.如果$u <span class="math inline">\(只有\)</span>v <span class="math inline">\(一个儿子.那么要么将\)</span>v
$子树全删,要么删一部分,有:</p>
<p><span class="math display">\[
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 &lt; SG ( v ) ) = SG ( v )
+ 1
\]</span></p>
<p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的$SG
$为$0 <span class="math inline">\(,而显然\)</span>SG <span class="math inline">\(图中的其它节点的\)</span>SG <span class="math inline">\(均要\)</span>+ 1 $.</p>
<h4><span id="example4">Example4</span></h4>
<p>$n
$个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环$SG = 1 <span class="math inline">\(,偶环\)</span>SG = 0
$.</p>
<p>这么考虑:边数为$k <span class="math inline">\(的链的\)</span>SG <span class="math inline">\(为\)</span>k $.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到$1
$.偶环同理,不可能得到$0 $.</p>
<h4><span id="example5">Example5</span></h4>
<p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,$SG
$值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3>
<p>一个数$N
$,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当$N $是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当$N <span class="math inline">\(是斐波那契数时必败,不妨假设\)</span>N = N _0 + N
_1 $,</p>
<p>考虑将$N <span class="math inline">\(看成两堆,因为如果第一次取走了大于\)</span>N _1
<span class="math inline">\(颗石子,由于\)</span>N _0 N _1 \
$,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在$N _0 <span class="math inline">\(堆取石子,原因是如果取了大于\)</span>N _0 <span class="math inline">\(颗石子,由于\)</span>N = N _0 + N _1 N _0 \
$.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取$N _0 <span class="math inline">\(这一堆,如果在这一堆取的过程中,先手一直取得不超过\)</span>N
_0 <span class="math inline">\(剩下的数,那么根据归纳假设,后手一定可以取走\)</span>N
_0 <span class="math inline">\(堆的最后一个石子,此时局面变成了只剩\)</span>N _1
<span class="math inline">\(颗石子.只要此时先手不能一次取走\)</span>N _1
<span class="math inline">\(颗石子,先手就必败.而后手最后一步拿走石子最多会拿走\)</span>
{ 3 } N _0 <span class="math inline">\(的石子,但是,\)</span> { 3 } N _0
&lt; N _1 $,因此一定不可能.</p>
<p>否则,仍然是先手取走了$N _0 <span class="math inline">\(全部石子,又当了先手取\)</span>N _1
$的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设$N = <em>{ i = 1 } ^k f </em>{ p _i } <span class="math inline">\(,其中\)</span>p _1 &lt; p _2 &lt; p _3 &lt; . . .
&lt; p <em>k \ <span class="math inline">\(,先手取走\)</span>f </em>{ p
<em>1 } \ $.由于$2 f </em>{ p <em>1 } &lt; f </em>{ p <em>2 } <span class="math inline">\(,因此后手接下来无论如何不可能取得大于等于\)</span>f
</em>{ p <em>2 } \ <span class="math inline">\(,问题转化为一堆大小为\)</span>f </em>{ p _2 }
$的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3>
<p>给出一张二分图和起点$S <span class="math inline">\(,\)</span>A <span class="math inline">\(和\)</span>B
$轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点$S
$,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含$S <span class="math inline">\(,那么\)</span>A
<span class="math inline">\(只需要每次走到一个和\)</span>S <span class="math inline">\(匹配的点即可.\)</span>B <span class="math inline">\(无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含\)</span>S
$的点,与假设不符.</p>
<p>而如果存在一个匹配不包含$S <span class="math inline">\(,如果\)</span>A <span class="math inline">\(仍然第一步走到一个和\)</span>S <span class="math inline">\(匹配的点那么\)</span>B <span class="math inline">\(一定能想办法走到一个不在当前\)</span>A <span class="math inline">\(选择的最大匹配中的点而在一个不包含\)</span>S <span class="math inline">\(的最大匹配中的点,于是\)</span>B $必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4>
<p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设$dp <em>{ S , x } =
0 / 1 <span class="math inline">\(表示目前集合\)</span>S <span class="math inline">\(中的所有人都已经离场了,而目前金条在\)</span>x
<span class="math inline">\(手中,金条会不会被抢.显然,如果\)</span>y
<span class="math inline">\(满足\)</span>dp </em>{ S { x } , y } = 0
<span class="math inline">\(,也就是金条在\)</span>y <span class="math inline">\(手里不会被抢,那\)</span>x
$手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与$S
$匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果$S
<span class="math inline">\(和\)</span>x
$并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断$S <span class="math inline">\(是否一定在其中,只需要先删去\)</span>S <span class="math inline">\(,跑dinic,再在残联网络上加上\)</span>S
$,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3>
<h4><span id="example1zr23省选10连-day1clashmas">Example1(zr[23省选10连 day1]
Clashmas)</span></h4>
<p>注意到删点对树形态的影响,考虑重心</p>
<ol type="1">
<li>$n $为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol start="2" type="1">
<li>$n $为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时$n
$为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为$S
_A <span class="math inline">\(,B的点的集合为\)</span>S _B <span class="math inline">\(.以原重心为根建树,设其所有儿子组成的集合为\)</span>S
<em>C <span class="math inline">\(,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当\)</span></em>{
u S _A S _C } siz <em>u </em>{ u S _B S _C } siz _u $.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中$siz
$最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol start="3" type="1">
<li>$n $为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时$n
$为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol start="4" type="1">
<li>$n $为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol start="5" type="1">
<li>$n $为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3>
<h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5>
<p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设$f _i <span class="math inline">\(为还剩\)</span>i <span class="math inline">\(条蛇的时候能不能吃,那\)</span>f <em>i = 1 <span class="math inline">\(的话,要么\)</span>i = 2 <span class="math inline">\(,要么吃完后不是最小的,要么\)</span>f </em>{ i - 1
} = 0 $.</p>
<p>递归做就好了.另外这题需要复杂度$O ( n )
$,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5>
<p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5>
<p>首先考虑如果有人作为第$n - p + 1 <span class="math inline">\(个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读\)</span>n
- p $个人.</p>
<p>继续思考,如果有人作为第$n - 2 p + 1
$个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有$n p <span class="math inline">\(个人复读,并且一定是前\)</span>n p
$在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5>
<p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录$f
<em>{ i , j } <span class="math inline">\(表示当前的\)</span>G <span class="math inline">\(是\)</span>i <span class="math inline">\(,\)</span>G <span class="math inline">\(的倍数还剩下\)</span>j <span class="math inline">\(个,然后做转移,再进一步发现我们只关心\)</span>j
<span class="math inline">\(的奇偶性.于是记\)</span>f </em>{ i , 0 / 1 }
$即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5>
<p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在$[
l _i , r _i ] $,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为$0
$.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为$0
$.</p>
<p>换句话说,我们现在有$x _1 , x _2 , x _3 <span class="math inline">\(,我们要将其中一个\)</span>x _i <span class="math inline">\(改为\)</span>y _i $,其他不变,使得他们仨异或值为$0
<span class="math inline">\(.和Nim游戏类似,假设他们仨异或值的最高位为\)</span>k
<span class="math inline">\(.那么一定有一个\)</span>x _i <span class="math inline">\(的第\)</span>k $位为$1 $,将它改为$0
$,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的$[
l _i , r _i ] $求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5>
<p>Nim游戏,但是每堆石子有一个$K _i <span class="math inline">\(.如果这堆石子剩\)</span>x _i <span class="math inline">\(个每次最多取\)</span> { K _i }
$个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-n k,k)&amp;n(k)\</p>
<p>n k&amp;n=0(k)\</p>
<p>\end{cases}\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于$k <span class="math inline">\(是否大于\)</span>
<span class="math inline">\(讨论一下,如果\)</span>k &lt; <span class="math inline">\(暴力,最多只会做\)</span> <span class="math inline">\(次.否则,意识到此时可以通过求一个区间\)</span>[ l ,
r ] <span class="math inline">\(,满足\)</span>x , { k } <span class="math inline">\(均相等,加速一下.这种区间最多只会有\)</span>
$个.</p>
<h5><span id="problem7">Problem7</span></h5>
<p>一个数$N
$,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当$N = 2 ^k $,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5>
<p>A和B,有$n <span class="math inline">\(颗石子,每次可以取\)</span>x
$颗,其中$1 x { 2 } \ $.</p>
<p>仍然令石子数量为状态,注意到$SG ( x ) = 0 <span class="math inline">\(当且仅当\)</span>x + 1 = 2 ^k - 1 <span class="math inline">\(,也即\)</span>x = 2 ^k - 2 \ $.首先,注意到:</p>
$$
<span class="math display">\[\begin{aligned}
n - \lceil \frac { n  } { 2  } \rceil &amp; = \lfloor \frac { n  } {
2  } \rfloor \\
SG ( n ) &amp; = mex \{ SG ( y ) | \lfloor \frac { n  } { 2  } \rfloor
&amp; \leq y &amp; \leq n - 1 \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>设$n = 2 ^k - w $,其中:</p>
$$
<span class="math display">\[\begin{aligned}
- 2 ^{ k - 1  } + 2 &amp; \leq w &amp; \leq 2 \\
\lfloor \frac { 2 ^k - w  } { 2  } \rfloor &amp; = 2 ^{ k - 1  } -
\lfloor \frac { w  } { 2  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>当$w = 2 <span class="math inline">\(时,原式\)</span>= 2 ^{ k - 1 } -
1 &gt; 2 ^{ k - 1 } - 2 \ $.反之.$2 ^k - 2
$原式.因此数学归纳即可证明.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>北大相关选拔数学真题汇总</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3>
<h4><span id="problem4">Problem4</span></h4>
<p>设$G ( x ) = ( x ^2 + x - 1 ) ^{ 100 } = _{ k = 0 } ^{ 200 } a _k x
^k $,求$2 a _0 - a _1 - a _2 + 2 a <em>3 - a <em>4 - a <em>5 + + 2 a
</em>{ 198 } - a </em>{ 199 } - a </em>{ 200 } $.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑求出$<em>{ 0 k } { a </em>{ 3 k } } <span class="math inline">\(.直接取三次单位根\)</span>_3 = - { 2 } + { 2 } i
$,自然有$1 + _3 + _3 ^2 = 0 <span class="math inline">\(,所以\)</span>G
( 1 ) + G ( <em>3 ) + G ( <em>3 ^2 ) = 3 </em>{ 0 k } { a </em>{ 3 k } }
$.</p>
<p>所以答案显然是$G ( _3 ) + G ( _3 ^2 ) = ( - 2 ) ^{ 100 } + ( - 2 ) ^{
100 } = 2 ^{ 101 } $.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>等差数列中,$a <em>1 &gt; 0 <span class="math inline">\(,公差\)</span>d &lt; 0 , { a </em>{ 30 } } &lt; -
1 <span class="math inline">\(,求最大的正整数\)</span>n <span class="math inline">\(,使得\)</span>S _n &gt; 0 $.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>显然$S <em>{ 60 } = 30 ( a </em>{ 30 } + a <em>{ 31 } ) &lt; 0 , S
</em>{ 59 } = 59 a _{ 30 } &gt; 0 $.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>全为整数的等差数列,$d = 4 <span class="math inline">\(,求所有满足\)</span>S _n = 2024 <span class="math inline">\(的\)</span>n $的和.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>则$n ( 2 n - 2 + a _1 ) = 2024 = 2 ^3 <span class="math inline">\(.显然只要\)</span>n | 2024 $即可.</p>
<p>所有$n <span class="math inline">\(的和自然是\)</span>( 1 + 2 + 4 + 8
) ( 1 + 11 ) ( 1 + 23 ) = 15 = 4320 $.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>整数数列$U <em>n <span class="math inline">\(满足\)</span>U <em>0 = 1
<span class="math inline">\(,且当\)</span>n <span class="math inline">\(的时候\)</span>U </em>{ n + 1 } U </em>{ n - 1 } =
kU <em>n <span class="math inline">\(,其中\)</span>k <span class="math inline">\(是一个正整数.问能让\)</span>U </em>{ N } = N <span class="math inline">\(的\)</span>k <span class="math inline">\(的个数有多少个,其中\)</span>N = 2024 $.</p>
<h5><span id="solution14">Solution14</span></h5>
<p>则$U <em>{ n + 1 } = { U </em>{ n - 1 } } , { U <em>n } = k { U
</em>{ n - 1 } } { U _n } $.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设$T
<em>n = </em>{ k = 1 } ^n U _k , W _n = U <em>n </em>{ k = 1 } ^{ n - 2
} U _k $.</p>
<p>注意到$W <em>n = kW </em>{ n - 1 } , W <em>1 = U <em>1 , W <em>n = k
^{ n - 1 } U <em>1 <span class="math inline">\(.又注意到\)</span>T <em>n
= kU </em>{ n - 1 } W </em>{ n - 1 } = kW </em>{ n - 1 } { T </em>{ n -
2 } } = k ^{ n - 1 } U <em>1 { T </em>{ n - 2 } } = ( k ^{ n - 1 } U
<em>1 ) ( k ^{ n - 2 } U <em>1 ) { T </em>{ n - 3 } } <span class="math inline">\(,\)</span>T </em>{ n - 3 } = ( k ^{ n - 4 } U
<em>1 ) ( k ^{ n - 5 } U <em>1 ) { T </em>{ n - 6 } } <span class="math inline">\(.所以\)</span>T </em>{ n } = k ^6 T </em>{ n - 6 }
<span class="math inline">\(,所以\)</span>U $存在长度为$6 <span class="math inline">\(的循环节.所以\)</span>U <em>{ N } = { T </em>{ N -
1 } } = { T _1 } = U _2 = kU _1 $.(其实直接暴力找循环节也是可以的)</p>
<p>所以$k <span class="math inline">\(需要是\)</span>N $的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设$w = U _1 <span class="math inline">\(,则\)</span>U $的前六项是:$1
, w , kw , k ^2 , { w } , { w } <span class="math inline">\(.要求\)</span>kw = N , w | k <span class="math inline">\(,所以\)</span>( 11 ) | k <span class="math inline">\(,\)</span>k <span class="math inline">\(.所以\)</span>k = 4 <span class="math inline">\(或\)</span>k = 8 $.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>求使方程$ { x } = N = 2024 <span class="math inline">\(恰有两个整数解的正整数\)</span>n $的个数.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
N &amp; \leq \frac { 10 ^n  } { x  } &amp; &lt; N + 1 \\
xN &amp; \leq 10 ^n &amp; &lt; x ( N + 1 ) \\
\frac { 10 ^n  } { N + 1  } &amp; &lt; x &amp; \leq \frac { 10 ^n  } {
N  } \\
\lfloor \frac { 10 ^n  } { N + 1  } \rfloor &amp; &lt; x &amp; \leq
\lfloor \frac { 10 ^n  } { N  } \rfloor \\
\lfloor \frac { 10 ^n  } { N  } \rfloor - \lfloor \frac { 10 ^n  } { N +
1  } \rfloor &amp; = 2 \\
\frac { 10 ^n  } { N ( N + 1 )  } - \frac { 10 ^n \bmod N  } { N  } +
\frac { 10 ^n \bmod { ( N + 1 )  }  } { N + 1  } &amp; = 2
\end{aligned}
\]</span></p>
<p>显然$ { N ( N + 1 ) } = 1 , 2 , 3 <span class="math inline">\(.而\)</span>N ( N + 1 ) = 4098600 <span class="math inline">\(,所以只有\)</span>n = 7
$可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是$5 ! = 30 $.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>$f ( x ) = x + x + x + x , x <span class="math inline">\(,求其不超过\)</span>n = 2024
$的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>显然$f ( x + 1 ) = f ( x ) + 20 <span class="math inline">\(,因此我们先考虑\)</span>x , n = 2024 <span class="math inline">\(中分别独立随机两个正整数(可以相同)\)</span>a , b
$,则求$3 ^a + 7 ^b $的概率.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>考虑$( 10 ) = 4 <span class="math inline">\(,所以原题答案等价于\)</span>n = 4
$的时候的答案.在这$16 <span class="math inline">\(中可能性中满足条件的只有三种,概率为\)</span> { 16
} $.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3>
<h4><span id="problem3">Problem3</span></h4>
<p>已知$a <em>1 = { 2 } , a </em>{ n + 1 } = a _n ^2 - 2 <span class="math inline">\(,求\)</span>a _n , n = 2023 $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>这个一看就不是好解的,想都别想直接数学归纳,注意到$a _n = { 2 ^{ 2 ^{ n
- 1 } } } <span class="math inline">\(,那么\)</span>a _n = 2 ^{ 2 ^{ n -
1 } } $.</p>
<p>而$( 7 ) = 6 , ( 6 ) = 2 $.由扩展欧拉定理,立刻有:$2 ^{ 2 ^{ 2022 } }
^{ 2 ^{ 2022 } } ^{ 2 ^{ 6 } } $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>$50 <span class="math inline">\(个队伍两两打比赛,胜一场积分\)</span>+
1 $,负一场积分不变,无平局.</p>
<p>且任取$27 $支队伍,其中一定有一支队伍负于其它的$26
$支,也一定有一支队伍胜于其它的$26 $支.</p>
<p>问$50 $支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>答案是$50 $.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都$ <span class="math inline">\(的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都\)</span>&gt;
27 <span class="math inline">\(,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为\)</span>k
<span class="math inline">\(的简单环,由鸽笼原理,剩下的\)</span>n - k
<span class="math inline">\(个点中至少有\)</span> { 2 } <span class="math inline">\(个点对着\)</span>k <span class="math inline">\(个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要\)</span>k
+ { 2 } <span class="math inline">\(即可,此时\)</span>k
$即可.由于这是竞赛图,显然存在长度为$4 $的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为$u <span class="math inline">\(.我们任意取一个击败过它的点(如果有的话),假设为\)</span>v
$,再取$25 <span class="math inline">\(个被\)</span>u <span class="math inline">\(击败的点(显然这些点存在),设这些点集为\)</span>S
<span class="math inline">\(.则\)</span>u , v , S <span class="math inline">\(组成的集合中,有一个点可以击败其它所有点,根据假设,只能是\)</span>v
<span class="math inline">\(.由此,可以知道,只要是\)</span>u <span class="math inline">\(能击败的点,\)</span>v <span class="math inline">\(一定能击败,而且\)</span>v <span class="math inline">\(能击败\)</span>u <span class="math inline">\(,因此\)</span>_v &gt; _u <span class="math inline">\(,与假设不符.因此一定不存在一个\)</span>v <span class="math inline">\(可以击败\)</span>u <span class="math inline">\(.删掉\)</span>u
$后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>一只蚂蚁第一天在$( 0 , 0 ) <span class="math inline">\(,第\)</span>k
+ 1 <span class="math inline">\(天向上下左右随机一个方向移动\)</span> {
4 ^k } <span class="math inline">\(单位,求第\)</span>n <span class="math inline">\(天的可能位置数量,\)</span>n = 2023 $.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>不妨设第$n <span class="math inline">\(天不同位置数量为\)</span>S _n
<span class="math inline">\(,显然只要前面岔开了,后面永远无法走到一个点.所以\)</span>S
<em>1 = 1 , S </em>{ n + 1 } = 4 S <em>n , S </em>{ 2023 } = 4 ^{ 2022 }
$.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>集合$U = { 1 , 2 , , n } , n = 10 <span class="math inline">\(,求\)</span>U
$中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>集合是无序的,这个很难搞,我们先从$U $中把$1 $去掉最后再加上.</p>
<p>先考虑可以重复放$1 $的情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^{ n  } \sum _{ k = 1  } ^{ n  } [
\gcd ( i , j ) &amp; = 1 ] [ \gcd ( i , k ) &amp; = 1 ] [ \gcd ( j , k )
&amp; = 1 ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从$1 , 3 , 5 , 7 , 9 $中选,答案应该是$1 + 2
{ 2 } = 7 $.</p>
<p>接下来考虑选一个偶数,如果选$2 , 4 , 8 $是等价的,答案此时是$3 ( { 2 }
- 1 ) = 27 $.如果选$6 <span class="math inline">\(的话答案是\)</span> {
2 } = 3 $.如果选$10 <span class="math inline">\(的话方案数是\)</span> {
2 } - 1 = 5 $,加起来方案数是$42 $.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>集合$U = { 1 , 2 , , n } , n = 366 <span class="math inline">\(,则\)</span>U $的互不相交且各元素之和为$17
$的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5>
<p>考虑$ { 17 } = 21 , 366 $.答案显然是$21 + 10 + 1 = 179 $个.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>三个互不相同的数的$= 20 , = 20000
$,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然等价于$= 1 , = 1000 = 2 ^3 ^3 <span class="math inline">\(.先只分析其中一个质因子,方案应该是\)</span>( 0 , 0
, 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , ( 0 , 3 , 3 )
$,打乱一下顺序的话就共有$3 + 6 + 6 + 3 = 18
$种方案.如果可以重复,平方一下得到$324 $.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有$2
= 12 $种,于是答案为$312 $.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>求$ { n } , k , n = 2023 $种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5>
<p><span class="math display">\[
\begin{aligned}
\lfloor \frac { k ^2  } { n  } \rfloor &amp; = d \\
d &amp; \leq \frac { k ^2  } { n  } &amp; &lt; d + 1 \\
nd &amp; \leq k ^2 &amp; &lt; n ( d + 1 )
\end{aligned}
\]</span></p>
<p>由于两个完全平方数的差是固定的,不妨猜测存在一个$k _0 <span class="math inline">\(,\)</span>k _0 <span class="math inline">\(的\)</span>k <span class="math inline">\(会扎堆,但是这些\)</span>d <span class="math inline">\(全都能取到,\)</span>&gt; k _0 <span class="math inline">\(的则不会有两个\)</span>k <span class="math inline">\(得到相同的元素.所以前者统计不同的\)</span>d <span class="math inline">\(,后者统计不同的\)</span>k <span class="math inline">\(考虑\)</span>( k + 1 ) ^2 - k ^2 = 2 k + 1 <span class="math inline">\(.分界线应该是\)</span>k _0 = 1011 $.</p>
<p>所以答案应该是$n - k _0 + { 2 k _0 + 1 } + 1 = 1012 + 506 = 1518
$.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>对四元组$( a , b , c , d ) $计数,满足$101 | ( a + b + c + d ) $且$0
&lt; a &lt; b &lt; c &lt; d $.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>这题真的厉害啊.</p>
<p>不妨设$S _k <span class="math inline">\(为满足\)</span>( a + b + c +
d ) k $的满足$0 &lt; a &lt; b &lt; c &lt; d <span class="math inline">\(的四元组数量.不难发现\)</span>S _k = { 4 } $.</p>
<p>注意到$( a , b , c , d ) ( a + 1 , b + 1 , c + 1 , d + 1 ) <span class="math inline">\(,注意这里是\)</span> <span class="math inline">\(意义下的加法,这是一个双射,所以\)</span>S <em>{ k }
= S </em>{ k + 4 } <span class="math inline">\(,下标同样也是\)</span>
<span class="math inline">\(意义下进行的.又因为\)</span>( 101 , 4 ) = 1
<span class="math inline">\(,所以所有的\)</span>S _k <span class="math inline">\(均相等.\)</span>S _0 = { 101 } = 40425 $.</p>
<h4><span id="problem16">Problem16</span></h4>
<p>问方程$x x = 6 $的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5>
<p>$6 = x x x ^2 <span class="math inline">\(,所以\)</span>x = ,
$.显然都不可以.所以个数为$0 $.</p>
<h4><span id="problem17">Problem17</span></h4>
<p>设$R ( n ) = _{ k = 2 } ^{ 10 } ( n k ) <span class="math inline">\(,求满足\)</span>R ( n ) = R ( n + 1 ) <span class="math inline">\(的十进制下的两位数\)</span>n $的个数.</p>
<h5><span id="solution17">Solution17</span></h5>
<p>从$R ( n ) <span class="math inline">\(到\)</span>R ( n + 1 )
$,应该是加了若干个$1 <span class="math inline">\(,然后又丢了几个\)</span>k - 1
$这样的.那就一定需要丢掉的数字之和为$9 <span class="math inline">\(.枚举一下,丢了的只有可能是以下情况:\)</span>( 9 )
, ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 + 3 + 2 ) <span class="math inline">\(,分别对应了\)</span>n + 1 <span class="math inline">\(应该是分别以下数的倍数\)</span>( 9 ) , ( 14 ) , (
6 ) , ( 20 ) , ( 12 ) <span class="math inline">\(,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:\)</span>(
7 + 2 ) <span class="math inline">\(,并且分别不能是以下数字的倍数\)</span>( 3 , 4 , 5
) $.</p>
<p>取一下的话$n + 1 $可以是:$14 , 98 <span class="math inline">\(,\)</span>n = 13 , 97
$,验证一下均合法,所以答案为$2 $.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>已知$a &lt; b &lt; c &lt; d <span class="math inline">\(,而\)</span>x
, y , z , w <span class="math inline">\(是\)</span>a , b , c , d <span class="math inline">\(的一个排列,求\)</span>( x - y ) ^2 + ( y - z ) ^2
+ ( z - w ) ^2 + ( w - x ) ^2 $得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>圆排列个数是$3 ! = 6 $个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是$( x , y , z , w )
, ( x , z , w , y ) , ( x , w , y , z ) $.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 \\
&amp; = 2 ( x ^2 + z ^2 + y ^2 + w ^2 ) - 2 ( xy + yz + zw + wx )
\end{aligned}
\]</span></p>
<p>显然只要$xy + yz + zw + wx
$不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>已知$0 &lt; x _1 &lt; x _2 &lt; &lt; x <em>9 <span class="math inline">\(且\)</span></em>{ k = 1 } ^9 x <em>k = 220 <span class="math inline">\(,在\)</span></em>{ k = 1 } ^5 x _k <span class="math inline">\(最大的前提下,最小化\)</span>x _9 - x _1 $.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>不妨枚举一下$x _5 <span class="math inline">\(选啥,设\)</span>f ( S ,
m , k ) <span class="math inline">\(表示选出\)</span>k <span class="math inline">\(个互不相同的数,使得它们\)</span>m <span class="math inline">\(且总和为\)</span>S <span class="math inline">\(,是否可行.不难发现\)</span>f ( S , m , k ) = [ { 2
} S { 2 } ] $.</p>
<p>那我们要求的就是:</p>
<p><span class="math display">\[
\begin{aligned}
\max _{ 5 \leq x _5  } \{ S | f ( 220 - 4 x _5 - S , + \infty , 4 )
&amp; = 1 \land f ( S - x _5 , x _5 - 1 , 4 ) &amp; = 1 \} \\
&amp; = \max _{ 5 \leq x _5  } \{ S | 4 x _5 + S &amp; \leq 210 \land 10
+ x _5 &amp; \leq S &amp; \leq 5 x _5 - 10 \} \\
&amp; = \max _{ 5 \leq x _5  } ( \min \{ 5 x _5 - 10 , 210 - 4 x _5 \} )
\end{aligned}
\]</span></p>
<p>立刻得到$x _5 = 24 , 25 , S = 110
$,那么后面的选法就一定了,后面四个数一定是$26 , 27 , 28 , 29 <span class="math inline">\(,只需要让\)</span>x _1 $最大即可</p>
<p>$x _5 = 24 $时,此时最优显然是$20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 ,
29 <span class="math inline">\(,\)</span>x _9 - x _1 = 9 $.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>有一个$n <span class="math inline">\(边形,其中有\)</span> { 2 } <span class="math inline">\(条对角线,不存在三线交于一点的情况,问这些对角线将该\)</span>n
<span class="math inline">\(边形分成了多少个部分.\)</span>n = 10 $.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了$ { 4 }
$个点(任意四个点有且只有一种交法),每交一个点就会多出$2
$条边,所以多出来了$2 { 4 } + { 2 } $条边.</p>
<p>考虑内部的若干个部分一定是$a _3 <span class="math inline">\(个三角形,\)</span>a _4 <span class="math inline">\(个四边形,...,\)</span>a _k <span class="math inline">\(个\)</span>k $边形,总之我们发现:</p>
<p><span class="math display">\[
\begin{cases}
\sum _{ j = 3  } ^k ( j - 2 ) \pi a _j = ( n - 2 ) \pi + 2 \pi \binom {
n  } { 4  } \\
\sum _{ j = 3  } ^k ja _j = n + 4 \binom { n  } { 4  } + n ( n - 3 )
\end{cases}
\]</span></p>
<p>两式得到:$_{ j = 3 } ^k a _j = { 2 } + { 4 } $.</p>
<p>$n = 10 $的时候,答案为$246 $.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求$_{ i = 1 } ^n { 20 } , n = 2024 $.</p>
<h5><span id="solution1">Solution1</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \\
&amp; = \sum _{ i = 1  } ^n \lfloor \frac { \sum _{ k = 0  } ^i 20 ^k (
- 1 ) ^{ i - k  } \binom { i  } { k  }  } { 20  } \rfloor \\
&amp; = - \lfloor \frac { n  } { 2  } \rfloor + \sum _{ i = 1  } ^{ n  }
\frac { 19 ^i - ( - 1 ) ^i  } { 20  } \\
&amp; = - \lfloor \frac { n  } { 2  } \rfloor + \frac { \frac { 19  } {
18  } ( 19 ^n - 1 ) - ( \frac { ( - 1 ) ^n - 1  } { 2  } )  } { 20  }
\end{aligned}
\]</span></p>
<p>带入$n = 2024 <span class="math inline">\(并\)</span> $,原式为:</p>
<p><span class="math display">\[
\equiv - 4 + \frac { 5  } { 4  } ( 1 - 5 ^n ) \equiv - 4 + 3 ( 1 - 5 ^n
)
\]</span></p>
<p>注意到$2024 = 2 <span class="math inline">\(,原式\)</span>- 4 - 9
$.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>求长度为$n <span class="math inline">\(的排列个数,使得排列中\)</span>i , a <em>i = a
</em>{ i + 1 } - 1 <span class="math inline">\(.\)</span>n = 8 $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>一眼容斥,也就是每个长度为$k <span class="math inline">\(的连续段的容斥系数应该是\)</span>( - 1 ) ^{ k - 1
} <span class="math inline">\(.那么设分成了\)</span>w <span class="math inline">\(个段,总的容斥系数应该是\)</span>( - 1 ) ^{ n - w }
<span class="math inline">\(,答案就是\)</span>f <em>{ n ’ } = </em>{ w =
1 } ^n ( - 1 ) ^{ n - w } w ! { w - 1 } = <em>{ w = 0 } ^{ n ’ } ( - 1 )
^{ n ’ - w } { w } ( w + 1 ) ! = n ’ ! </em>{ w = 0 } ^{ n ’ } { w ! } (
n ’ - w + 1 ) $,此时已经能算出答案是$16687 $.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设$g <em>n <span class="math inline">\(为错排数量,显然有\)</span>f </em>{ n } = nf <em>{
n - 1 } + g </em>{ n } $,立刻算出答案是$16687 $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>已知数列$1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , <span class="math inline">\(,求其第\)</span>n <span class="math inline">\(项\)</span> <span class="math inline">\(的值,\)</span>n = 2024 $.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑第一个值为$k <span class="math inline">\(的地方应该在哪里.显然\)</span>a <em>{ { 2 } + 1 }
= k <span class="math inline">\(.注意到\)</span>a </em>{ 2081 } = 65
<span class="math inline">\(,所以\)</span>a _n = 64 <span class="math inline">\(,其\)</span> = 4 $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>求四元组$( a _1 , a _2 , a _3 , a _4 ) <span class="math inline">\(的个数,满足\)</span>a _1 , a _2 , a _3 , a _4 { 1
, 2 , 3 } $,且$10 &lt; a _1 a _2 a _3 a _4 &lt; 20 $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>排个序按照字典序开搜,只有三种可能:${ 3 , 3 , 2 , 1 } , { 3 , 2 , 2 ,
1 } , { 2 , 2 , 2 , 2 } $,打乱顺序的话就有$25 $种可能.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>求$ <span class="math inline">\(上方程\)</span>x ^2 - 13 x + 11 = 0
$的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>首先注意到$x = { 13 } $,那么自然有方程组:</p>
<p><span class="math display">\[
\begin{cases}
\frac { x ^2 + 11  } { 13  } \leq x \\
x &lt; \frac { x ^2 + 11  } { 13  } + 1
\end{cases}
\]</span></p>
<p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑$x ^2
$这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设$x = $的形式,带入有不等式:</p>
<p><span class="math display">\[
\begin{aligned}
k - x + 1 &amp; \leq 0 &amp; &lt; k - x + 2 \\
1 &amp; \leq \sqrt { 2 + 13 k  } - k &amp; &lt; 2 \\
\begin{cases}
0 &lt; k ^2 - 9 k + 2 \\
k ^2 - 11 k - 1 \leq 0
\end{cases}
\end{aligned}
\]</span></p>
<p>冷静一下!注意到$0 k <span class="math inline">\(,又根据第一个不等式得知大部分\)</span>k <span class="math inline">\(应该会很大,开始暴力枚举一下,合法的情况有:\)</span>k
= 0 , 9 , 10 , 11 $,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4>
<p>在一个体积为$1 <span class="math inline">\(的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积\)</span>
{ 8 } $的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5>
原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积$
{ 8 } <span class="math inline">\(.考虑设这个点是\)</span>( x , x , h )
<span class="math inline">\(,那么必然有\)</span>
<span class="math display">\[\begin{cases}( 1 - h ) x ^2 &gt; \frac {
1  } { 8  } \\ h ( 1 - x ) ^2 &gt; \frac { 1  } { 8  }
\end{cases}\]</span>
<p>$,化简,只要$8 &gt; { x ^2 } + { ( 1 - x ) ^2 }
$即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取$( 0 . 5 , 0 . 5 , 0 . 1 ) <span class="math inline">\(即可.那么是不是可以证明答案一定\)</span>&gt; 3
$呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积$ {
8 } <span class="math inline">\(的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为\)</span>(
x , y , h ) , x , y , h { 2 } $,然后证明$8 &gt; { xy } + { ( 1 - x ) ( 1
- y ) } , x , y { 2 } $这个不等式无解即可.</p>
<p>由基本不等式,$ { xy } + { ( 1 - x ) ( 1 - y ) } = 8 $,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>设$S ( n ) <span class="math inline">\(表示正整数\)</span>n <span class="math inline">\(的十进制数码和,求满足\)</span>S ( n ) S ( n + 1 )
<span class="math inline">\(的最小的\)</span>n $.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>显然必须发生进位,不妨设$n = 10 ^k a + 10 ^k - 1 <span class="math inline">\(,\)</span>a <span class="math inline">\(,\)</span>S ( n ) = S ( a ) + 9 k , S ( n + 1 ) =
S ( a ) + 1 $,</p>
<p>此时显然有$9 k - 1 <span class="math inline">\(,\)</span>k <span class="math inline">\(.\)</span>n _{ } = 49999 $.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>求满足以下条件的最大的正整数$n <span class="math inline">\(:十进制下每一位数字互不相同,且\)</span>m , 10 ^m n
, { 10 ^m } | n $.</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是$0 $.</p>
<p>不妨设其为$ <span class="math inline">\(,其中\)</span>b = 10 c <span class="math inline">\(,\)</span>a <span class="math inline">\(是\)</span>b <span class="math inline">\(的因子,不妨枚举一下\)</span>k = { a } <span class="math inline">\(.注意到因为\)</span>a $中不能有$0 <span class="math inline">\(,所以\)</span>k { 2 , 4 , 5 , 8 } <span class="math inline">\(.取\)</span>k = 2 $试出来$3570 <span class="math inline">\(是合法的,而且显然\)</span>k { 4 , 5 , 8 }
$的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>$a <em>1 = , a </em>{ n + 1 } = a _n + { a _n - a <em>n } <span class="math inline">\(,求\)</span></em>{ k = 1 } ^{ n } a _k , n = 2024
$.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>这一看就是个环,设$a _n = b _n + c _n $.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<p><span class="math display">\[
\begin{cases}
a _1 = 0 + \sqrt { 2  } \\
a _2 = 2 + \sqrt { 2  } \\
a _3 = 4 + \sqrt { 2  } \\
\cdots
\end{cases}
\]</span></p>
<p>容易猜测$b _n = 2 ( n - 1 ) , c _n = 1 <span class="math inline">\(.也就是\)</span>a _n = 2 ( n - 1 ) +
$,数学归纳一下即可.</p>
<p>那么$_{ k = 1 } ^n a _k = n ( n - 1 ) + n <span class="math inline">\(,带入\)</span>n = 2024 $即可.</p>
<h3><span id="2022图选">2022图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol type="1">
<li><p>任意两个正方形至多有一个顶点重合</p></li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol type="1">
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p></li>
<li><p>边可以相交,放到正十二边形的边上.</p></li>
</ol>
<h4><span id="problem2">Problem2</span></h4>
<p>求$( { 2 } ) ^{ 12 } $.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>考虑$( { 2 } ) ^3 = 2 + <span class="math inline">\(,\)</span>( { 2 }
) ^{ 12 } = 161 + = 321 $.</p>
<p>也可以考虑类似斐波那契数列,取$f <em>n = ( { 2 } ) ^{ n } + ( { 2 } )
^{ n } <span class="math inline">\(,其满足\)</span>f <em>n = f </em>{ n
- 1 } + f </em>{ n - 2 } , f _0 = 2 , f <em>1 = 1 <span class="math inline">\(,取\)</span>f </em>{ 12 } - 1 $就是答案$321 $.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于一个加法乘法环,要求你利用:</p>
<ol type="1">
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p></li>
<li><p>加法结合律、逆元.</p></li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>倒反天罡题.</p>
<p>注意到$( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a + 1 ) <span class="math inline">\(,所以\)</span>a + b = b + a $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你$n <span class="math inline">\(个数集\)</span>a _i <span class="math inline">\(,其中\)</span>| a _i | = i + 1 <span class="math inline">\(,要你选出\)</span>n <span class="math inline">\(个两两不同的数字满足\)</span>x _i a _i
$,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是$2 ^n $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice和Bob博弈.Alice先选一个数$m <span class="math inline">\(,然后Bob选一个数\)</span>n ( n &gt; m ) <span class="math inline">\(,并构造一个\)</span>n <span class="math inline">\(个点的竞赛图.Alice如果能从中选出\)</span>m <span class="math inline">\(个不同的点,满足不存在某个点\)</span>x <span class="math inline">\(到这\)</span>m
$个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是$( 1 - { 2 ^m } ) ^{
n - 2 } <span class="math inline">\(,因此期望为\)</span>E = { m } ( 1 -
{ 2 ^m } ) ^{ n - 2 } <span class="math inline">\(,只需\)</span>n <span class="math inline">\(足够大的时候期望\)</span>&lt; 1 $,则说明一定存在$0
$,也就是Bob总有必胜策略.</p>
<p>注意到只需证明$n <span class="math inline">\(,\)</span> { m } &lt; (
{ 2 ^m - 1 } ) ^{ n - 2 } <span class="math inline">\(,而\)</span> { m }
= { m ! } &lt; n ^m <span class="math inline">\(.下面证明\)</span>n , n
^m &lt; ( { 2 ^m - 1 } ) ^{ n - 2 } $.</p>
<p>两边取$<span class="math inline">\(,不妨假设\)</span>n <span class="math inline">\(,有\)</span>m n &lt; ( n - 2 ) ( { 2 ^m - 1 } ) ,
{ ( { 2 ^m - 1 } ) } &lt; { n } <span class="math inline">\(,\)</span> {
n } <span class="math inline">\(显然在\)</span>n <span class="math inline">\(的时候单增,所以一定存在这么一个\)</span>n $.</p>
<h3><span id="2023图选">2023图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>求正整数拆分成有序的$1 , 2 $序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>定义$* <span class="math inline">\(为集合\)</span>G
$上的二元运算,已知:</p>
<ol type="1">
<li><p>满足结合律$a ∗ b ∗ c = a ∗ ( b ∗ c ) $.</p></li>
<li><p>存在左单位元$e <span class="math inline">\(,对任意\)</span>a
<span class="math inline">\(满足\)</span>e ∗ a = a $.</p></li>
<li><p>对任意$a <span class="math inline">\(存在左逆元\)</span>b <span class="math inline">\(,使\)</span>b ∗ a = e $.</p></li>
</ol>
<p>问:</p>
<ol type="1">
<li><p>左单位元是否也为右单位元.</p></li>
<li><p>左逆元是否也为右逆元.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>看(2),考虑设$b <span class="math inline">\(是\)</span>a <span class="math inline">\(的左逆元,\)</span>c <span class="math inline">\(是\)</span>b <span class="math inline">\(的左逆元,则\)</span>cba = ce = a , ab = ceb = e
$.</p>
<p>看(1),设$b <span class="math inline">\(是\)</span>a <span class="math inline">\(的逆元,\)</span>ea = aba = ae
$,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明$ab <span class="math inline">\(的时候\)</span>b <span class="math inline">\(不能彻底损失信息,而观察\)</span>ab = eab <span class="math inline">\(知道\)</span>a $也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算$(
a _1 , b _1 ) ( a _2 , b _2 ) <span class="math inline">\(,想办法让其损失掉\)</span>( a _1 , b _1 ) <span class="math inline">\(中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到\)</span>(
a _1 , b _1 ) ( a _2 , b _2 ) = ( a _1 + a _2 , b _2 ) <span class="math inline">\(即可,存在左幺元为\)</span>( 0 , 0 ) <span class="math inline">\(,右逆元为\)</span>( - a , 0 ) $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>$f <span class="math inline">\(的定义域和值域都是正整数并且\)</span>f
( xy ) = f ( x ) + f ( y ) - 1 $,求:</p>
<ol type="1">
<li><p>是否存在这样的函数.</p></li>
<li><p>是否存在无数个这样的函数.</p></li>
<li><p>是否存在严格递增的函数.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>令$g ( x ) = f ( x ) - 1 <span class="math inline">\(,则\)</span>g (
xy ) = g ( x ) + g ( y ) $.</p>
<p>对于(1),取$g ( x ) = 0 , f ( x ) = 1 $即可.</p>
<p>对于(2),考虑$g ( p ^k ) = kg ( p ) <span class="math inline">\(,只需要让\)</span>g ( p ) $取不同的值即可.</p>
<p>对于(3),考虑$g ( 2 ^a ) = ag ( 2 ) <span class="math inline">\(,\)</span>g ( 3 ^b ) = bg ( 3 ) $.</p>
<p>考虑构造$a , b $,使得$2 ^a &lt; 3 ^b <span class="math inline">\(但是\)</span>ag ( 2 ) bg ( 3 ) <span class="math inline">\(.不妨取\)</span>a = { g ( 2 ) } $,那么必定有:</p>
$$
<span class="math display">\[\begin{aligned}
2 ^{ \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil  } &amp; &lt; 3 ^b
\\
\lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil &amp; &lt; b \log _2 3 \\
\frac { bg ( 3 )  } { g ( 2 )  } + \Delta &amp; \leq b \log _2 3 \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是如果存在,必定需要$ { g ( p <em>2 ) } </em>{ p _2 } p _1 { g ( p
<em>1 ) } </em>{ p _1 } p _2 <span class="math inline">\(,也就是\)</span> { g ( p <em>1 ) } = </em>{ p _1 }
p _2 $.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于任意$2 n - 1 <span class="math inline">\(个正整数(可重复),问其中是否一定有\)</span>n <span class="math inline">\(个数的和能被\)</span>n <span class="math inline">\(整除,这题\)</span>n = 50 $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑当$n <span class="math inline">\(是合数的时候,设\)</span>n = pq
<span class="math inline">\(,则可以将其拆成\)</span>q - 1 $组每组$2 p
$个数以及一组$2 p - 1 <span class="math inline">\(个数,因此只需要这些都可以找到\)</span>p <span class="math inline">\(个数使得其是\)</span>p $的倍数,组合起来就行了.</p>
<p>只需要解决$n $是质数的情况.</p>
<p>感觉场上的最优解应该是解决$n = 2 <span class="math inline">\(和\)</span>n = 5 <span class="math inline">\(的情况然后拼成\)</span>n = 50 $.</p>
<p>$n = 2 $的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然$S = <em>{ } ( x </em>{ p <em>1 } + x
</em>{ p <em>2 } + + x </em>{ p _n } ) ^{ p - 1 } { n } $.</p>
<p>但是考虑左边那个多项式的每一项,形如$c <em>{ i = 1 } ^k x </em>{ p _i
} ^{ e _i } <span class="math inline">\(.注意到\)</span>c <span class="math inline">\(一定是\)</span> { n - k } <span class="math inline">\(的倍数,而后者\)</span>n $为$0 $.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为$1 <span class="math inline">\(并不是对称的,而左边是个对称式子,某个\)</span>x
$增大也无所谓,这意味着左边应该是为$0 $的,我们要做的就是去证明它是$0
$.</p>
<h3><span id="2024图选">2024图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问在双曲线$xy = 1 $上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>不会做,取个特殊值知道答案应该是$[ 2 , + ) $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol type="1">
<li><p>如果$n , m <span class="math inline">\(都是好的,那么\)</span>nm
$是好的.</p></li>
<li><p>$2024 $不是好的.</p></li>
</ol>
<h5><span id="solution2">Solution2</span></h5>
<p>如果$n = a ^2 + b ^2 , m = c ^2 + d ^2 <span class="math inline">\(,那么\)</span>nm = a ^2 c ^2 + a ^2 d ^2 + b ^2 c
^2 + b ^2 d ^2 = ( ac - bd ) ^2 + ( ad + bc ) ^2 $.</p>
<p>$2024 = 2 ^3 <span class="math inline">\(,使用反证法,不妨设其可以被表示为\)</span>a ^2 + b
^2 $.</p>
<p>讨论一下:如果$a , b <span class="math inline">\(均为奇数,那么\)</span>a ^2 + b ^2 $,不符题意.</p>
<p>于是$a , b <span class="math inline">\(应该均为偶数,那么就有\)</span>a ’ ^2 + b ’ ^2 =
506 $.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于集合$G <span class="math inline">\(,\)</span>e G <span class="math inline">\(,定义域为\)</span>G <span class="math inline">\(的函数\)</span>f $满足以下性质:</p>
<ol type="1">
<li><p>$e G <span class="math inline">\(,但\)</span>e <span class="math inline">\(不在\)</span>f $的值域中.</p></li>
<li><p>$G <span class="math inline">\(关于\)</span>f $封闭.</p></li>
<li><p>若$A G <span class="math inline">\(,\)</span>e A <span class="math inline">\(且\)</span>A <span class="math inline">\(对\)</span>f <span class="math inline">\(封闭,则\)</span>A = G $.</p></li>
</ol>
<p>在$G <span class="math inline">\(上定义二元运算\)</span><span class="math inline">\(,满足\)</span>ae = a , af ( b ) = f ( ab ) $.</p>
<p>求证:</p>
<ol type="1">
<li><p>存在幺元.</p></li>
<li><p>运算满足交换律.</p></li>
<li><p>运算满足结合律.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往$A <span class="math inline">\(里面扔个\)</span>e <span class="math inline">\(,此时\)</span>A <span class="math inline">\(一定不满足条件.我们不断从\)</span>A <span class="math inline">\(中选出一个元素\)</span>w <span class="math inline">\(满足\)</span>f ( w ) A <span class="math inline">\(,并把\)</span>A : = A { f ( w ) } <span class="math inline">\(.不断做这个过程显然最后会得到\)</span>G <span class="math inline">\(,这意味着任何一个元素\)</span>a <span class="math inline">\(可以写成\)</span>f ( f ( f f ( e ) ) )
$的形式.</p>
<p>不妨将$f <span class="math inline">\(函数嵌套\)</span>k <span class="math inline">\(次记作\)</span>f ^{ ( k ) } <span class="math inline">\(,那么我们要证明的是\)</span>a = f ^{ ( A ) } ( e )
, b = f ^{ ( B ) } ( e ) <span class="math inline">\(,\)</span>ab = ba
$.</p>
<p>考虑$ab = f ^{ ( A ) } ( e ) f ^{ ( B ) } ( e ) = f ^{ ( B ) } ( f ^{
( A ) } ( e ) e ) = f ^{ ( A + B ) } ( e ) $,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给出一个具体函数满足:</p>
<ol type="1">
<li><p>$f ( x + y ) = f ( x ) + f ( y ) + xy $.</p></li>
<li><p>$f ( xy ) = f ( x ) f ( y ) + f ( x - 1 ) f ( y - 1 ) $.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>先注意到$f ( 0 ) = 0 , f ( 1 ) = 1 $.</p>
<p>以$x <span class="math inline">\(为主元两边求导,立刻得到\)</span>f ’
( x + y ) = f ’ ( x ) + y <span class="math inline">\(,因此\)</span>f ’
( x ) $是斜率为$1 <span class="math inline">\(的一次函数,立刻得到\)</span>f ( x ) = { 2 } + { 2
} $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于$r = <span class="math inline">\(,是否存在正整数\)</span>p <span class="math inline">\(和整数\)</span>q <span class="math inline">\(满足\)</span>| pr - q | &lt; { 2024 } <span class="math inline">\(且\)</span>p &lt; 2024 $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑取$0 , , 2 , 3 , <span class="math inline">\(的小数部分,记作\)</span>a _0 , a <em>1 , a </em>{
2023 } $.</p>
<p>由鸽笼原理,一定存在两个数$0 x &lt; y <span class="math inline">\(满足\)</span>| a _x - a _y | &lt; { 2024 }
$,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>在一个数轴上,你站在$0 <span class="math inline">\(点,并按照如下算法寻找\)</span>x ( x &gt; 0 )
$点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. $3 x $ B. $5 x $ C. $7 x $ D. $9 x $ E. 以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>考虑找到牛的时候$step $为多少,应该为$2 ^{ 2 k } <span class="math inline">\(,其中\)</span>k $满足$2 ^{ 2 k } x &gt; 2 ^{ 2 ( k
- 1 ) } <span class="math inline">\(.此时走的步数应该是\)</span>ans = 2
_{ i = 0 } ^{ 2 k - 1 } 2 ^i + x = 2 ^{ 2 k + 1 } - 1 + x <span class="math inline">\(步.而\)</span>x ^{ 2 k } &lt; 4 x <span class="math inline">\(,所以\)</span>ans &lt; 9 x - 1 $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定$10 <span class="math inline">\(个实数变量\)</span>x <em>1 , , x
</em>{ 10 } <span class="math inline">\(,满足它们均\)</span> <span class="math inline">\(且两两不同.你要寻找一组\)</span>{ x } <span class="math inline">\(和一个实数\)</span>a <span class="math inline">\(,使得存在尽可能多组\)</span>b , b <em>i = <span class="math inline">\(,满足\)</span></em>{ i = 1 } ^{ 10 } b _i x _i ( a
, a + 2 ) $.</p>
<p>最多存在多少组$b $?</p>
<p>A. $512 $ B. $252 $ C. $504 $ D. $684 $ E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>不妨猜测$x $全取$1 <span class="math inline">\(最优,此时的答案是\)</span> { 5 } = 252 $.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于$x <span class="math inline">\(,所以如果存在两组\)</span>b <span class="math inline">\(,使得\)</span>A <span class="math inline">\(组中选择取\)</span>+ 1 <span class="math inline">\(恰好是\)</span>B <span class="math inline">\(组的子集,那么\)</span>S _A S _B - 2
$,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让$x $尽可能接近$1
$,这样就是满足条件的.所以问题变为对于一个大小为$10 <span class="math inline">\(的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取\)</span>
{ 5 } $最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给定无向图$G = ( V , E ) $,我们称一个图是好的,如果:</p>
<ol type="1">
<li><p>每个点的度数均为$d $.</p></li>
<li><p>任何一个大小不超过$ { 2 } <span class="math inline">\(的联通集合\)</span>S <span class="math inline">\(,其邻居(不属于\)</span>S <span class="math inline">\(但和\)</span>S <span class="math inline">\(中的某个点存在直接相连的边)的大小\)</span> { 4 } |
S | $.</p></li>
</ol>
<p>求证:好的图中任意两个点$u , v <span class="math inline">\(之间的最短路径长度\)</span>dis ( u , v ) = O ( | V
| ) $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑以$u <span class="math inline">\(为起点一点一点往外扩张,这样一直扩张到\)</span> { 2
} + 1 <span class="math inline">\(时,集合中每个点到\)</span>u <span class="math inline">\(的距离不超过\)</span>O ( | V | ) $.</p>
<p>然后以$v <span class="math inline">\(做同样的事,由于这两个集合大小之和大于\)</span>| V
| <span class="math inline">\(,说明一定有交,且存在一条路径长度为\)</span>O ( | V
| ) $的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你两个完全相同的鸡蛋和一个$n = 100
$层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有$101
$个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设$f <em>{ i , 1 / 2 } <span class="math inline">\(表示一棵有\)</span>i $个叶子的树,最多向右走$1 / 2
<span class="math inline">\(步,深度最低为多少.显然\)</span>f </em>{ i ,
1 } = i - 1 $.</p>
<p>不妨设最后的最大深度为$k $,需要满足$1 + <em>{ i = 1 } ^k i = 1 + { 2
} , k ( k + 1 ) <span class="math inline">\(,\)</span>k </em>{ } = 14
$.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>$n <span class="math inline">\(个人要进行一场游戏.游戏设计者准备了\)</span>n
<span class="math inline">\(张卡片,正面分别写着\)</span>n <span class="math inline">\(个人的名字,背面写了\)</span>[ 1 , n ] <span class="math inline">\(共\)</span>n
$个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,$n <span class="math inline">\(个人可以经过充分的讨论,并依次进入房间,一张一张地翻开\)</span>
{ 2 }
$张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有$n
$个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过$0
. 1 $的胜率.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是$a
<span class="math inline">\(,如果\)</span>a <span class="math inline">\(就是自己的编号就下班;反之接下来翻开\)</span>a
<span class="math inline">\(位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于\)</span>
{ 2 } $的环.</p>
<p>考虑总方案数是$n ! <span class="math inline">\(.不妨枚举这个环的长度为\)</span>K <span class="math inline">\(,则存在一个长度\)</span>= K &gt; { 2 } <span class="math inline">\(的环的方案数是\)</span> { K } ( K - 1 ) ! ( n - K
) ! = { K } <span class="math inline">\(.所以此时的概率为\)</span> { K }
$.</p>
<p>那么失败的概率就是$H <em>n - H </em>{ { 2 } } $.</p>
<h3><span id="2022茶选">2022茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化$z = 5 x _1 + 8 x _2 + 4 x _3 $,其中:</p>
<ol type="1">
<li><p>$x _1 , x _2 , x _3 $</p></li>
<li><p>$ { 2 } x _1 + 5 x _2 + 9 x _3 $</p></li>
<li><p>$4 x _1 + 7 x _2 + 3 x _3 $</p></li>
</ol>
<p>再提一个问题:最小化$v = 3 y _1 + 6 y _2 $,其中:</p>
<ol type="1">
<li><p>$y _1 , y _2 $</p></li>
<li><p>$ { 2 } y _1 + 4 y _2 $</p></li>
<li><p>$5 y _1 + 7 y _2 $</p></li>
<li><p>$9 y _1 + 3 y _2 $</p></li>
</ol>
<p>现在请你证明:$z v $.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>下面乘一下配一下上面的系数,自然得证.</p>
写成矩阵形式,设$X =
<span class="math display">\[\begin{bmatrix}x _1 &amp; x _2 &amp; x _3
\end{bmatrix}\]</span>
, A =
<span class="math display">\[\begin{bmatrix}0 . 5 &amp; 4 \\ 5 &amp; 7
\\ 9 &amp; 3 \end{bmatrix}\]</span>
, Y =
<span class="math display">\[\begin{bmatrix}y _1 \\ y _2
\end{bmatrix}\]</span>
<p><span class="math inline">\(,不难发现\)</span>z XAY v $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>半径为$R $的球里放点,要求两两之间距离不能小于$1 <span class="math inline">\(,证明至多放\)</span>( 2 R + 1 ) ^3 $个.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>要求两两距离不能小于$1 $等价于往其中放半径为$0 . 5 <span class="math inline">\(的球,这种球体积为\)</span> { 3 } { 8 } <span class="math inline">\(.然后原球要扩大一圈,所以原球体积变为\)</span> { 3
} ( R + 0 . 5 ) ^3 $.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数$n $.</p>
<p>它每秒以$v <span class="math inline">\(的速度行驶,其中\)</span>v
$是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数$x <span class="math inline">\(,你会得知此时车的坐标是否是\)</span>x $(Yes or
No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>第$t <span class="math inline">\(秒的时候车应该在\)</span>n + vt
<span class="math inline">\(处.由于我们知道现在是第几秒,枚举\)</span>n ,
v <span class="math inline">\(然后不断check即可.这个是经典的证明\)</span> ^2
<span class="math inline">\(和\)</span> <span class="math inline">\(等势.按照\)</span>| n | + | v |
$排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对满足$i , | i - p _i | $的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>简单题,设$f _n <span class="math inline">\(为答案,考虑\)</span>p _n
$取什么.</p>
<p>当$p <em>n = n <span class="math inline">\(时,方案数为\)</span>f
</em>{ n - 1 } $.</p>
<p>当$p <em>n = n - 1 <span class="math inline">\(时,\)</span>p </em>{ n
- 1 } = n <span class="math inline">\(,方案数为\)</span>f _{ n - 2 }
$.</p>
<p>于是,$f _1 = 1 , f <em>2 = 2 <span class="math inline">\(,\)</span>f
<em>n = f </em>{ n - 1 } + f </em>{ n - 2 } $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>你有一个$n n $的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择$k
$个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数$k <span class="math inline">\(最小值是\)</span>n $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是$ { 4 } = n
$个.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>设$F = { S _1 , S <em>2 , S <em>3 , . . . , S </em>{ | F | } } <span class="math inline">\(,定义一个集合\)</span>T <span class="math inline">\(能被\)</span>F $ shattered为:$T <span class="math inline">\(的任意一个子集(包括它自己和空集),都可以由\)</span>T
S </em>{ i <em>1 } S </em>{ i <em>2 } . . . <span class="math inline">\(表示.其中\)</span>S </em>{ i _j } <span class="math inline">\(是\)</span>F <span class="math inline">\(中的集合(就是说每个子集都等于\)</span>T <span class="math inline">\(和某些\)</span>F $内集合的交.)</p>
<p>定义一个$F <span class="math inline">\(的&quot;VC-Dimension&quot;是,能被他shattered的集合\)</span>T
$的大小的最大值.</p>
<p>$F <span class="math inline">\(中的集合们只会包含某\)</span>n
$种不同的元素.证明:</p>
<ol type="1">
<li><p>任意一个$F <span class="math inline">\(能shattered的\)</span>T
<span class="math inline">\(至少有\)</span>| F | $个.</p></li>
<li><p>对于一个VC-Dimension的大小为$k <span class="math inline">\(的\)</span>F <span class="math inline">\(,其\)</span>| F | _{ i = 0 } ^k { i } $.</p></li>
</ol>
<h5><span id="solution6">Solution6</span></h5>
<p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的$S <span class="math inline">\(,满足\)</span>S , S { x } F <span class="math inline">\(,然后将这些\)</span>S { x } <span class="math inline">\(拎出来,假设有\)</span>t <span class="math inline">\(个,左边删去\)</span>x <span class="math inline">\(后再进行数学归纳得到\)</span>| F | - t <span class="math inline">\(个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有\)</span>t
<span class="math inline">\(个集合,在这\)</span>t <span class="math inline">\(个集合添上\)</span>x $这个元素即可.</p>
<p>$t = 0 <span class="math inline">\(怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为\)</span>S
<span class="math inline">\((选取最大的那个集合为新加入的),我们在前面的集合中找到一个与\)</span>S
<span class="math inline">\(有交的集合\)</span>T <span class="math inline">\(,根据上面的预处理,此集合显然存在.选出一个\)</span>x
S T <span class="math inline">\(,不妨设\)</span>S = S ’ { x } <span class="math inline">\(,令\)</span>T ’ = S ’ T <span class="math inline">\(,然后用\)</span>T ’ <span class="math inline">\(代替原本的\)</span>T $即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>令$p ( x ) <span class="math inline">\(表示\)</span>x <span class="math inline">\(的最大质因子,求所有\)</span>( x , y , z )
$使得:</p>
<ol type="1">
<li><p>$x &lt; y &lt; z <span class="math inline">\(且\)</span>x + z = 2
y $.</p></li>
<li><p>$p ( xyz ) $.</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>不妨令$g = ( x , y , z ) <span class="math inline">\(,令\)</span>x ’
= { g } <span class="math inline">\(,则只需要解:\)</span>x ’ + z ’ = 2 y
’ $.</p>
<p>我们有$y - x = z - y <span class="math inline">\(,则\)</span>( y ’ ,
x ’ ) = ( y ’ , y ’ - x ’ ) = ( y ’ , z ’ ) = 1
$,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol type="1">
<li><p>$2 x ’ , 2 z ’ $.</p></li>
<li><p>$2 x ’ , 2 z ’ , 2 y ’ $.</p></li>
</ol>
<p>先看(1),设$x ’ = 3 ^a , z ’ = 3 ^c , y ’ = 2 ^b $.方程变为$3 ^a ( 1 +
3 ^{ c - a } ) = 2 ^{ b + 1 } <span class="math inline">\(,一定有\)</span>a = 0 $,只需解$1 + 3 ^{ c } = 2 ^{
b + 1 } $.</p>
当$b <span class="math inline">\(的时候,经检验有\)</span>
<span class="math display">\[\begin{cases}c = 0 \\ b = 0
\end{cases}\]</span>
<span class="math inline">\((舍)和\)</span>
<span class="math display">\[\begin{cases}c = 1 \\ b = 1
\end{cases}\]</span>
<p>$两组解.</p>
<p>当$b $的时候,注意到$3 ^{ c } - 1 <span class="math inline">\(,所以\)</span>c $是偶数.又注意到$3 ^{ c } - 1
<span class="math inline">\(,但是奇数的平方\)</span> $应该是$1
$,不符.</p>
<p>再看(2),设$x ’ = 2 ^d , z ’ = 2 ^e , y ’ = 3 ^b $.</p>
<p>当$e = 1 $时,显然不符.</p>
当$d = 1 , e &gt; 1 $时,要解$2 ^{ e - 1 } + 1 = 3 ^{ b } <span class="math inline">\(.当\)</span>e = 2 <span class="math inline">\(的时候有一组解\)</span>
<span class="math display">\[\begin{cases}e = 2 \\ b = 1
\end{cases}\]</span>
<p><span class="math inline">\(.当\)</span>e $的时候,有$3 ^b <span class="math inline">\(,说明\)</span>b $是偶数.</p>
那必然有$2 ^{ e - 1 } = 3 ^b - 1 = ( 3 ^{ { 2 } } + 1 ) ( 3 ^{ { 2 } } -
1 ) <span class="math inline">\(.令\)</span>t = 3 ^{ { 2 } } - 1 $,则$2
^{ e - 1 } = t ( t + 2 ) <span class="math inline">\(.则要么\)</span>t =
2 <span class="math inline">\(,要么\)</span>t + 2 = 2 <span class="math inline">\(.解出\)</span>b - 2 <span class="math inline">\(,此时有\)</span>
<span class="math display">\[\begin{cases}e = 4 \\ b = 2
\end{cases}\]</span>
<p>$.</p>
综上,解出来的解有$
<span class="math display">\[\begin{cases}x &#39; = 2 \\ y &#39; = 3 \\
z &#39; = 4 \end{cases}\]</span>
,
<span class="math display">\[\begin{cases}x &#39; = 1 \\ y &#39; = 2 \\
z &#39; = 3 \end{cases}\]</span>
,
<span class="math display">\[\begin{cases}x &#39; = 2 \\ y &#39; = 9 \\
z &#39; = 16 \end{cases}\]</span>
<p>$.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程$2 ^x + 1 = 3 ^y <span class="math inline">\(,考虑两边\)</span> <span class="math inline">\(知道\)</span>x <span class="math inline">\(是奇数,于是\)</span>v _3 ( 2 ^x + 1 ) = v _3 ( 3 )
+ v _3 ( x ) = y , 3 ^{ y - 1 } | x , x ^{ y - 1 }
$,用这个放缩一下就行.</p>
<p>再看方程$2 ^x = 3 ^y + 1 <span class="math inline">\(.仍然考虑两边\)</span> <span class="math inline">\(,知道\)</span>y <span class="math inline">\(是奇数.\)</span>x = v _2 ( 3 ^y + 1 ) = v _2 ( 3 +
1 ) = 2 $,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定两个随机分布：</p>
<p>$x ∼ D _1 <span class="math inline">\(:从\)</span>{ 0 , 1 , … , p − 1
} <span class="math inline">\(中等概率随机一个\)</span>y <span class="math inline">\(,令\)</span>x = y     { 2 ^k } $.</p>
<p>$x ∼ D _1 <span class="math inline">\(:从\)</span>{ 0 , 1 , … , 2 ^k
- 1 } <span class="math inline">\(中等概率随机一个\)</span>y <span class="math inline">\(,令\)</span>x = y   $.</p>
<p>定义二者的统计距离为:$SD ( D <em>1 , D <em>2 ) = { 2 } </em>{ i = 0 }
^{ 2 ^k - 1 } | P </em>{ D <em>1 } ( x = i ) - P </em>{ D _2 } ( x = i )
| $.</p>
<p>求证:$SD ( D _1 , D _2 ) ≤ { 4 p } $.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>令$w = p <span class="math inline">\(.则\)</span>SD ( D _1 , D <em>2
) = { 2 } ( P </em>{ D <em>1 } ( x = 0 ) - P </em>{ D <em>2 } ( x = 0 )
) + { 2 } ( P </em>{ D <em>2 } ( x = w ) - P </em>{ D _1 } ( x = w ) )
$.</p>
<p>令$k = { 2 ^k } = { 2 ^k } <span class="math inline">\(不难发现\)</span>P _{ D <em>1 } ( x = 0 ) = { p }
, P </em>{ D _1 } ( x = w ) = { p } $.</p>
<p>则$SD ( D _1 , D _2 ) = { 2 } ( { p 2 ^k } - { 2 ^k } ) + { 2 } ( { 2
^k } - { p 2 ^k } ) = { 2 ^{ k + 1 } } ( { p } + { p } ) = { p 2 ^k }
$.</p>
<p>要证明$ { p 2 ^k } { 4 p } w ( 2 ^k - w ) ( 2 ^{ k - 1 } ) ^2
$.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给你一个单增函数$f <span class="math inline">\(,满足定义域和值域都是\)</span> <span class="math inline">\(,并且\)</span>f ( f ( n ) ) = 3 n <span class="math inline">\(,求\)</span>f ( 2023 ) $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>首先我们不妨先试一下$f ( f ( 1 ) ) = 3 <span class="math inline">\(.由于\)</span>f ( 1 ) <span class="math inline">\(,且\)</span>f ( 1 ) <span class="math inline">\(,所以\)</span>f ( 1 ) = 2 , f ( 2 ) = 3 $.</p>
<p>考虑$f ( 3 n ) <span class="math inline">\(,必然存在一个\)</span>n
&lt; m &lt; 3 n <span class="math inline">\(,使得\)</span>f ( n ) = m ,
f ( m ) = 3 n $.</p>
<p>用这个找前几项,发现规律是把$n $写成三进制形式,如果首位是$1 $就变成$2
$,首位是$2 $就改为$1 $再在后面加个$0 <span class="math inline">\(.容易验证这是合法的\)</span>f <span class="math inline">\(且\)</span>f ( 2023 ) = 3882 $.</p>
<p>但问题没有解决,需要证明它是唯一的$f $.</p>
<p>考虑数学归纳假设现在$f ( x ) , x $都确定了.</p>
<p>注意到如果$f ( n ) = m , f ( m ) = 3 n , f ( 3 n ) = 3 m , f ( 3 m )
= 9 n <span class="math inline">\(.所以如果\)</span>f ( n ) = m <span class="math inline">\(,我们实际上有\)</span>f ( 3 ^k m ) = 3 ^{ k + 1 }
n , f ( 3 ^k n ) = 3 ^k m <span class="math inline">\(.数学归纳即可以证明\)</span>f ( 3 k + 3 )
$一定是确定的.</p>
<p>接下来要证明$f ( 3 k + 1 ) <span class="math inline">\(和\)</span>f (
3 k + 2 ) $一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol type="1">
<li><p>$f ( 3 k ) + 3 = f ( 3 k + 3 ) $.</p></li>
<li><p>$n , f ( n ) = 3 k + w ( w { 1 , 2 } ) $.</p></li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当$k $在三进制下首位如果是$2 $,则一定满足(2).</p>
<p>当$k $在三进制下首位是$1 $,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对于一个$n n <span class="math inline">\(的包含\)</span>[ 1 , n ^2 ]
$各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol type="1">
<li><p>如果一个排列矩阵满足每行恰有模$n <span class="math inline">\(余\)</span>[ 0 , n - 1 ] <span class="math inline">\(的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第\)</span>i
<span class="math inline">\(行第\)</span>j <span class="math inline">\(列为\)</span>( i - 1 ) n + j
$的矩阵(不妨称为有序矩阵).</p></li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列$n <span class="math inline">\(不相同,可以先将每行按照\)</span>n
$排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将$n <span class="math inline">\(不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是\)</span>n
$正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>有$n ( ) <span class="math inline">\(个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称\)</span>n
$是好的.求证:</p>
<ol type="1">
<li><p>$4 $是好的.</p></li>
<li><p>如果$n <span class="math inline">\(是奇数,那么\)</span>n
$不是好的.</p></li>
<li><p>求出所有好的$n $.</p></li>
</ol>
<h5><span id="solution5">Solution5</span></h5>
<p>首先可以证明$2 $是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要$2
^n $步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样$0 $和$1 $就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到$1100 $来一个$1010 $之后啥也不变,但是$1010 $来一个$1010
$一定赢了.所以上来先来一个$1010 $,如果赢了就下班,没赢就来个$1100
$,这样$1100 $要么下班,要么变成了$1010 $,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:$0000 , 1111 , 1010 , 1111 , 1100 , 1111 ,
1010 , 1111 , 1000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111
$.</p>
<p>上面的构造启发我们手玩一下$n = 3 $,注意到此时的问题在于$100 $和$110
$,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全$0
$;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全$0
$.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全$0
<span class="math inline">\(的成功状态.我们不妨令一个成功状态的度为\)</span>d
<span class="math inline">\(表示它可以经过\)</span>d $步到达全$0
$,显然全$1 <span class="math inline">\(的\)</span>d = 1 <span class="math inline">\(,\)</span>n = 4 $的时候,$1010 <span class="math inline">\(的\)</span>d = 2
$,因为其可以通过一次操作转化为全$1 $,$1100 <span class="math inline">\(的\)</span>d = 3 $,因为其可以用一次操作转化为$1010
$.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向$d
$比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然$n = 3 <span class="math inline">\(的时候,\)</span>{ 110 , 100 }
$就是失败状态.</p>
<p>而对于$n <span class="math inline">\(取任意来说,一定得存在一个\)</span>d = 2 <span class="math inline">\(的成功状态.一个显然的\)</span>d = 2 <span class="math inline">\(的成功状态要满足的条件是,假设它是\)</span>a <span class="math inline">\(,那么存在一个数\)</span>b <span class="math inline">\(,使得\)</span>a b $是全$1 $或者全$0 <span class="math inline">\(.既然\)</span>a <span class="math inline">\(和\)</span>b <span class="math inline">\(旋转后只有两种结果,那么\)</span>b
$的循环节必定为$2 <span class="math inline">\(,也就是\)</span>b
$一定要是$101 <span class="math inline">\(这样的,于是\)</span>n
$是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找$d = 3 $的成功状态,现在我们已知的四种成功状态是$111 $,$000
$,$101 $,$010 $,所以考虑构造一个循环节长度为$4
$的串,使得异或完它是这上面四种其一,注意到$1100 $就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明$n = 2 ^k $一定是好的.考虑数学归纳,不妨这么干:构造一个长度为$2
^{ k - 1 } <span class="math inline">\(的串\)</span>b <span class="math inline">\(,使得其\)</span>b _i = a <em>i a </em>{ i + 2 ^{ k
- 1 } } <span class="math inline">\(.然后由数学归纳,可以造出\)</span>b
$全$0 <span class="math inline">\(的情况.而如果\)</span>b $全$0
$,则原串一定存在长为$2 ^{ k - 1 } <span class="math inline">\(的循环节,并且消除循环节的过程不会改变\)</span>b
$的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设$n = 2 ^k m $,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造$b <span class="math inline">\(数组,由于\)</span>b $数组都不可能全$0
$,显然也不可能成立.</p>
<p>这个能不能顺便证明$n $是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了$n - 1
$个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前$n - 1
$个位置的异或值为$1 $.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为$50
% $,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5>
简单题,设$f _0 , f _1 , f _2 , f _3 <span class="math inline">\(,然后有\)</span>
<span class="math display">\[\begin{cases}f _3 = 0 \\ f _2 = \frac {
1  } { 2  } f _3 + \frac { 1  } { 2  } f _0 + 1 \\ f _1 = \frac { 1  } {
2  } f _2 + \frac { 1  } { 2  } f _0 + 1 \\ f _0 = \frac { 1  } { 2  } f
_1 + \frac { 1  } { 2  } f _0 + 1 \end{cases}\]</span>
<p><span class="math inline">\(,算出\)</span>f _0 = 14 $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<p><span class="math display">\[
x ^3 + □ x ^2 + □ x + □ = 0
\]</span></p>
<h5><span id="solution2">Solution2</span></h5>
<p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为$- A , - B , - C <span class="math inline">\(,方程应该可以写作\)</span>( x + A ) ( x + B ) ( x
+ C ) = 0 $.</p>
<p>拆开有$x ^3 + ( A + B + C ) x ^2 + ( AB + AC + BC ) x + ABC = 0
$.</p>
<p>这么对称,不妨猜一手Alice先选择$0 $,讨论一下:</p>
<ol type="1">
<li>Bob令$ABC = 0 <span class="math inline">\(.不妨令\)</span>C = 0
$.</li>
</ol>
<p>此时方程变为$x ^2 + ( A + B ) x + AB = 0
$.直接秒了,随便选一个数就行(比如选$3 <span class="math inline">\(,如果Bob令\)</span>AB = 3 $,就再选$4 <span class="math inline">\(;如果令\)</span>A + B = 3 $,就再选$2 $)</p>
<ol start="2" type="1">
<li>Bob令$A + B + C = 0 , C = - A - B $.</li>
</ol>
<p>不妨令$C ’ = - C , D = AB <span class="math inline">\(,则\)</span>AB
+ AC + BC = D - C ’ ^2 , ABC = DC ’ $.</p>
<p>接下来Alice要选择一个数字$k <span class="math inline">\(,如果Bob又令\)</span>D - C ’ ^2 = k <span class="math inline">\(,发现在此时如果\)</span>k
$是一个负的完全平方数,并且Alice接下来选择$0 $,当场就下班了.</p>
<p>所以不妨直接让$k = - n ^2 <span class="math inline">\(,然后看当\)</span>DC ’ = - n ^2 <span class="math inline">\(的时候如何去解.此时有\)</span>AB ( A + B ) = n ^2
$.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择$- 3 ^2 ^2 ^2 $,这样就赢了.</p>
<ol start="3" type="1">
<li>Bob令$AB + AC + BC = 0 , C = - { A + B } $.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择$6 ^2 ^3
$,两种情况如下:</p>
<p><span class="math display">\[
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) &amp; = 0 \\
( x - 2 \times 6 ^2 \times 7 ^2 ) ( x + 3 \times 6 ^2 \times 7 ^2 ) ( x
+ 6 \times 6 ^2 \times 7 ^2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>后来又找人讨论了一下这个是咋得出来的啊.考虑$ABC <span class="math inline">\(,我们有的条件其实是\)</span> { A } + { B } + { C }
= 0 <span class="math inline">\(.方程现在是\)</span>x ^3 + ( A + B - { A
+ B } ) x ^2 - { A + B } = 0 <span class="math inline">\(.不妨令\)</span>a = A + B , b = AB <span class="math inline">\(,方程实际上是\)</span>x ^3 + ( a - { a } ) x ^2 -
{ a } = 0 <span class="math inline">\(.最好能让\)</span>a <span class="math inline">\(小一点,因此我们不妨直接取\)</span>a = 1 <span class="math inline">\(,此时\)</span>A = - n , B = n + 1 , C = n ( n + 1
) <span class="math inline">\(,只要能构造这样的两组\)</span>A , B , C
<span class="math inline">\(使得它们的\)</span>a _1 - { a _1 } = - { a
_2 } <span class="math inline">\(即可.直接造看上去没啥前途,但是不难发现\)</span>A =
- nk , B = ( n + 1 ) k , C = n ( n + 1 ) k <span class="math inline">\(依然合法.此时有\)</span>k _1 = a _1 , b _1 = - n (
n + 1 ) a _1 ^2 , k _2 = a _2 , b _2 = - n ( n + 1 ) a _2 ^2 <span class="math inline">\(,我们有\)</span>a _1 ( n ^2 + n + 1 ) = - n ^2 ( n
+ 1 ) ^2 a _2 ^3 <span class="math inline">\(.取\)</span>n = 2
$试试看!此时有$7 a _1 = - 36 a _2 ^3 <span class="math inline">\(.取\)</span>a _2 = 7 , a _1 = - 6 ^2 ^2
$,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外$3
$个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌$1
$个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>有公式:</p>
<p><span class="math display">\[
\sum _{ S \subseteq \{ 1 , 2 , \cdots , n \}  } ( P ( f ( R ) \oplus
\bigoplus _{ i \in S  } R _i = 0 ) - P ( f ( R ) \oplus \bigoplus _{ i
\in S  } R _i = 1 ) ) ^2 = 1
\]</span></p>
<p>其中$f <span class="math inline">\(是任意一个将\)</span>{ 0 , 1 } ^n
{ 0 , 1 } <span class="math inline">\(的函数,\)</span><span class="math inline">\(是二进制意义下的异或运算,\)</span>R <span class="math inline">\(是\)</span>{ 0 , 1 } ^n <span class="math inline">\(上的均匀分布,\)</span>R _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(位.再定义\)</span><em>S ( r ) = </em>{ i S } ( - 1
) ^{ r _i } $.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol type="1">
<li><p>$_S ( r ) _S ( r ’ ) = _S ( r r ’ ) $.</p></li>
<li><p>当$r <span class="math inline">\(时,\)</span>_{ S { 1 , , n } }
_S ( r ) = 0 $.</p></li>
<li><p>$[ f ( r ) _{ i S } r _i = 0 ] - [ f ( r ) _{ i S } r _i = 1 ] =
( - 1 ) ^{ f ( r ) } _S ( r ) $.</p></li>
<li><p>证明原命题.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>(1)显然.</p>
<p>(2)也很经典,挑选一个$j <span class="math inline">\(,使得\)</span>r _j
= 1 <span class="math inline">\(,然后所有的集合分为两类:一类是包含\)</span>j <span class="math inline">\(,一类不包含,两类集合一一对应并且\)</span>$互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到$P ( f ( R ) <em>{ i S } R <em>i = 0 ) = { 2 ^n }
</em>{ r } [ f ( r ) _{ i S } r _i = 0 ] <span class="math inline">\(,而\)</span></em>{ r } [ f ( r ) _{ i S } r _i = 0
] - [ f ( r ) _{ i S } r _i = 1 ] = _r ( - 1 ) ^{ f ( r ) } <em>S ( r )
<span class="math inline">\(,要证明的只是\)</span></em>{ S } { 4 ^n } (
_r ( - 1 ) ^{ f ( r ) } _S ( r ) ) ^2 = 1 $,而:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 \\
&amp; = \sum _S \sum _{ r  } \sum _{ r &#39;  } ( - 1 ) ^{ f ( r ) + f (
r &#39; )  } \chi _S ( r \oplus r &#39; ) \\
&amp; = \sum _{ r  } \sum _{ r &#39;  } ( - 1 ) ^{ f ( r ) + f ( r &#39;
)  } \sum _S \chi _S ( r \oplus r &#39; ) \\
&amp; = \sum _{ r  } 2 ^n &amp; = 4 ^n
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于$50
% $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数$x <span class="math inline">\(,然后随机一只手,看上面的数字\)</span>a <span class="math inline">\(,如果\)</span>a x <span class="math inline">\(就认为\)</span>a <span class="math inline">\(大,反之认为\)</span>b
$大.只要随机到一个区间内的实数的概率不为$0 $即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5>
<p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令$p <span class="math inline">\(为素数,把整个图形放大\)</span>p $倍(也就是长度$1
<span class="math inline">\(变成长度\)</span>p <span class="math inline">\().下面把每个交叉点\)</span>( x , y ) <span class="math inline">\(换成其整数部分\)</span>( x , y ) <span class="math inline">\(,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被\)</span>p
<span class="math inline">\(整除.这样这个新的大矩形的面积也能被\)</span>p
<span class="math inline">\(整除,所以它的有一边长能被\)</span>p
$整除.这条边只是被换成了它长度的整数部分,所以变化不超过$1
$,所以在放大之前这条边的长度和某个整数相差不超过$1 / p
$.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有$2
$条边或者$4
$条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点$(
x , y ) <span class="math inline">\(染色:如果\)</span>x <span class="math inline">\(是整数,染X颜色.如果\)</span>x <span class="math inline">\(不是整数但\)</span>y
$是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为$[ 0 , a ] <span class="math inline">\(,并假设\)</span>b <span class="math inline">\(不是整数.把所有小矩形的下边界去掉,然后令\)</span>f
( t ) <span class="math inline">\(为所有上边界\)</span>y <span class="math inline">\(坐标不是整数,并且与直线\)</span>y = t <span class="math inline">\(相交的小矩形的\)</span>x <span class="math inline">\(方向边长之和.那么\)</span>f ( 0 ) = 0 <span class="math inline">\(,而且当\)</span>f ( t ) <span class="math inline">\(变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以\)</span>f
( b ) <span class="math inline">\(是整数.而因为\)</span>b <span class="math inline">\(不是整数,\)</span>f ( b ) <span class="math inline">\(就是最靠上的所有小矩形的宽之和,等于\)</span>a
<span class="math inline">\(,所以\)</span>a $是整数.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划相关</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2>
<h3><span id="分析状态">分析状态</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个$[ 1 ,
m ] $中的数字,然后进行以下判断:</p>
<ol type="1">
<li><p>如果当前序列末尾两个数字相同且小于$t <span class="math inline">\(,假设都是\)</span>x <span class="math inline">\(,那就将它们都删去,加入一个\)</span>x + 1
$.</p></li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为$n
$,终止操作.</p></li>
</ol>
<p>给定$n , m , t $,求最终序列的元素和的期望.</p>
<p>$n , m ^3 , t ^9 $.</p>
<p>首先$t ^9 <span class="math inline">\(显然是没用的,因为它最多也就能这么凑:\)</span>m + n
- 2 , m + n - 3 , , m , m <span class="math inline">\(,合成一个\)</span>m + n - 1 <span class="math inline">\(,因此我们令\)</span>t = { t , m + n - 1 }
$即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置$i <span class="math inline">\(,有\)</span>a <em>i &lt; a </em>{ i + 1 } <span class="math inline">\(,那么无论后面怎么做,这里的\)</span>a <em>i <span class="math inline">\(都必不可能被删除.以此,我们不妨设\)</span>f </em>{
i , j } <span class="math inline">\(表示序列长度为\)</span>i <span class="math inline">\(,序列开头元素为\)</span>j
$的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过$t <span class="math inline">\(,另一个是序列的长度不能超过\)</span>n <span class="math inline">\(.我们不妨设\)</span>ans _{ n , t } <span class="math inline">\(表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移\)</span>ans
$需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下$ans <em>{ n , t } <span class="math inline">\(,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有\)</span>ans
</em>{ n , t } = _{ x = 1 } ^t E ( n 个 位 置 , 第 一 个 位 置 是 x 并
且 没 有 被 删 去 ) $.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:$3 , 3 , 3 $,最终的答案应该是$4 , 3 $.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了$3 , [ 3 , 3 ]
$,最终的答案就变成了$3 , 4 <span class="math inline">\(.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设\)</span>g
<em>{ i , j } <span class="math inline">\(表示当前后面还有\)</span>i - 1
<span class="math inline">\(个位置,当前前面已经放好了一个\)</span>j
<span class="math inline">\(,这个\)</span>j <span class="math inline">\(不能被删掉的期望,显然有\)</span>ans </em>{ n , t }
= <em>{ x } ^t g </em>{ n , x } P ( 最 终 序 列 中 , 这 里 是 k ) <span class="math inline">\(,问题只在于如何求\)</span>g <span class="math inline">\(.这个\)</span>g _{ n , k } <span class="math inline">\(是钦定了这个位置放\)</span>k <span class="math inline">\(的期望,后面我们需要将它乘上这个位置放\)</span>k
$的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个$g <em>{ n , k } = ( k + </em>{ j k } g <em>{ n -
1 , j } ) <span class="math inline">\(.但是实际上这个是不对的.这里的\)</span>k <span class="math inline">\(不能删掉不意味着后面的\)</span>j <span class="math inline">\(不能删掉,事实上后面的\)</span>j <span class="math inline">\(爱怎么删怎么删,只要不搞出一个\)</span>k <span class="math inline">\(来就可以.因此我们需要设\)</span>f </em>{ i , j }
<span class="math inline">\(表示当前后面还有\)</span>i <span class="math inline">\(个位置,第一个位置不能是\)</span>j <span class="math inline">\(,也不能曾经是\)</span>j <span class="math inline">\((因为这里只要是\)</span>j <span class="math inline">\(都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设\)</span>f
_{ i , j } <span class="math inline">\(表示后面还有\)</span>i <span class="math inline">\(个位置,第一个位置现在或曾经是过\)</span>j <span class="math inline">\(的期望.那么全集是什么呢?全集是\)</span>ans _i
$.</p>
<p>还没完啊,我们还需要求一下这里是$k <span class="math inline">\(的概率,由于还有一个类似的\)</span>f <span class="math inline">\(,我们还要求一下这里曾经是\)</span>k <span class="math inline">\(的概率.设前者为\)</span>q <em>{ i , k } <span class="math inline">\(,后者为\)</span>p </em>{ i , k } <span class="math inline">\(.我们来强调一下这里设计的原则:这里的\)</span>p
<span class="math inline">\(其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了\)</span>k
<span class="math inline">\(,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过\)</span>k
$了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是$k <span class="math inline">\(等价于这里是\)</span>k <span class="math inline">\(并且后面没有出现过\)</span>k <span class="math inline">\(,也就是\)</span>q <em>{ i , k } = p </em>{ i , k }
( 1 - p _{ i - 1 , k } ) <span class="math inline">\(.这里加一个限制是因为有不能超过\)</span>t
$的限制.</p>
<p>对于后者,这里的$k <span class="math inline">\(有很多种可能出现过,一种是直接加入,一种是合并而来,于是\)</span>p
<em>{ i , k } = { m } [ k m ] + p </em>{ i , k - 1 } p _{ i - 1 , k - 1
} $.</p>
<p>因此我们几经辗转,终于得到了$g $的转移式子:</p>
<p><span class="math display">\[
q _{ i , k  } g _{ n , k  } = p _{ i , k  } ( k + ans _{ i - 1  } - f _{
i - 1 , k  } p _{ i - 1 , k  } )
\]</span></p>
<p>就差$f <span class="math inline">\(了.\)</span>f <span class="math inline">\(有两种可能:要么最后仍然是\)</span>k <span class="math inline">\(,要么这个\)</span>k $已经被杀掉了.于是:</p>
<p><span class="math display">\[
p _{ i , k  } f _{ i , k  } = q _{ i , k  } g _{ i , k  } + ( p _{ i ,
k  } - q _{ i , k  } ) f _{ i , k + 1  }
\]</span></p>
<h5><span id="example2cf1007e">Example2(CF1007E)</span></h5>
<p>首先我们需要发现一个很强的性质:作用到了第$i <span class="math inline">\(个站台就会清空前面所有站台.清空后就和\)</span>a _i
<span class="math inline">\(无关了,而如果还没涉及到一定和\)</span>a _i
$有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设$f <em>{ i , j } <span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(个站台,要撑\)</span>j <span class="math inline">\(个单位时间需要的最少火车数量.\)</span>g </em>{ i ,
j } <span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(个站台,要撑\)</span>j <span class="math inline">\(个单位时间,并且\)</span>[ 1 , i - 1 ] <span class="math inline">\(全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为\)</span>+
<span class="math inline">\(表示无法满足(对于全局,我们在\)</span>n + 1
<span class="math inline">\(处放一个\)</span>a = + , b = 0 , c = + <span class="math inline">\(来保证一定会满载).为什么需要\)</span>g <span class="math inline">\(作为辅助dp数组呢?我们先对着\)</span>f $分析.</p>
<p>考虑$f _{ i , j } $的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前$j <span class="math inline">\(轮中根本没接走站台\)</span>i
<span class="math inline">\(的人.此时需要满足\)</span>f <em>{ i - 1 , j
} + a <em>i + j b <em>i c <em>i <span class="math inline">\(.那么这里怎么更新\)</span>g <span class="math inline">\(呢?设\)</span>L = sa </em>{ i - 1 } + sb </em>{ i
- 1 } j <span class="math inline">\(,显然\)</span>g </em>{ i , j } = { K
} <span class="math inline">\(,并且需要保证此时没有用到\)</span>i <span class="math inline">\(以后的站台,因此需要保证\)</span> { K } K sa </em>{
i } + sb <em>i j <span class="math inline">\(.注意到由于这里保证了\)</span>f </em>{ i - 1 , j }
<span class="math inline">\(是可以取到的,因此我们可以撑到第\)</span>j
<span class="math inline">\(秒,剩下的火车在\)</span>j + $秒全选.</p>
<p>第二种,前$j <span class="math inline">\(轮中有火车接走站台\)</span>i
<span class="math inline">\(的人.设最后一次是在\)</span>r <span class="math inline">\(时间接走的站台\)</span>i <span class="math inline">\(,那么此时必然清空了\)</span>[ 1 , i - 1 ] <span class="math inline">\(,这里用了\)</span>g <em>{ i , r } <span class="math inline">\(.然后为了防止这里在\)</span>[ r + 1 , j ] <span class="math inline">\(这段时间中爆掉,因此还需要\)</span>w = { K } <span class="math inline">\(,其中\)</span>rem <span class="math inline">\(是\)</span>r <span class="math inline">\(时刻\)</span>i <span class="math inline">\(剩下的人数.这些火车都要在\)</span>r <span class="math inline">\(时刻之前解决(因为我们设了最后一次在\)</span>r
<span class="math inline">\(时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在\)</span>r
<span class="math inline">\(这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有\)</span>wK
rem <span class="math inline">\(.但是,接下来在\)</span>[ r + 1 , j ]
<span class="math inline">\(时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设\)</span>f
</em>{ i , j , 0 } <span class="math inline">\(表示只考虑前\)</span>i
<span class="math inline">\(个站台,要撑\)</span>j <span class="math inline">\(个单位时间需要的最少火车数量,但是\)</span>[ 1 , i
] $都被清空为$0 $过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol type="1">
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p></li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将$g
_{ 1 , t , 0 / 1 } $全部设为$0 $,因为我觉得无论如何$0 <span class="math inline">\(位置都是清空的,但实际上这是错误的!因为在\)</span>t
$时刻的$1 <span class="math inline">\(位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前\)</span>i
<span class="math inline">\(个的合法性,并且如果我们想要让\)</span>i
<span class="math inline">\(位置合法,一定要求让\)</span>[ 1 , i - 1 ]
$合法.</p></li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从$r t
<span class="math inline">\(这个过程中会积累的量,这些量必然要在\)</span>r
$时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p></li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>定义一个有根树为大菊花,当且仅当这棵树的根的度数$m x root , ( x ) &gt;
2 <span class="math inline">\(.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.\)</span>(
n ^5 , m ) $</p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到$O
( nm ^2 ) $.</p>
<p>注意到这个背包是可删除的,所以就能做到$O ( nm ) $.</p>
<h3><span id="dp分界点">dp分界点</span></h3>
<h4><span id="example12022zrtg十连测day7permutation">Example1(2022zrtg十连测day7
Permutation)</span></h4>
<p>首先注意到$[ 3 , n ] $一定会被分成两段递减的序列,分别跟在$1 $和$2
$的后面,假设$1 $在$2 <span class="math inline">\(前面,这样算出答案后乘以\)</span>n $即可.</p>
<p>注意到$i + 1 <span class="math inline">\(一定可以放到\)</span>i <span class="math inline">\(的前面,设\)</span>f _i <span class="math inline">\(表示在\)</span>i <span class="math inline">\(和\)</span>i + 1 <span class="math inline">\(之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即\)</span>i
<span class="math inline">\(的倍数\)</span> <span class="math inline">\(之类的,于是可以实现,复杂度\)</span>O ( n n )
$.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3>
<h4><span id="example1cf1666e">Example1(CF1666E)</span></h4>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i
$条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最小值,\)</span>g _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最大值.假设我们目前二分的最大值要小于等于\)</span>mx
<span class="math inline">\(,最小值要大于等于\)</span>mn
$,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i + 1  } &amp; = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } &amp; = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$f <span class="math inline">\(与\)</span>g <span class="math inline">\(的转移是无关的,而显然对于第\)</span>i <span class="math inline">\(个分界点,它可以取\)</span>[ f _i , g _i ]
$中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans <em>{ i } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(条分界线是啥,那么我们\)</span>ans <em>i <span class="math inline">\(是可以取\)</span>[ ans <em>{ i + 1 } - mx , ans
</em>{ i + 1 } - mn ] <span class="math inline">\(中的任何一个数字的,我们将其和上面求出的\)</span>[
f _i , g _i ] <span class="math inline">\(求一下交集.如果交集为空,说明要么\)</span>ans
</em>{ i + 1 } - mn &lt; f <em>i , f </em>{ i + 1 } &lt; ans </em>{ i +
1 } &lt; f _i + mn <span class="math inline">\(,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差\)</span>mx
- mn $.</p>
<h3><span id="数位dp">数位dp</span></h3>
<h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4>
<p>首先设$f _{ i , j } <span class="math inline">\(表示长度为\)</span>i
<span class="math inline">\(的,以\)</span>S [ n - j + 1 . . . n ]
$为子序列的字符串个数.</p>
<p>考虑按位处理,每次将$T <span class="math inline">\(的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出\)</span>k
<span class="math inline">\(.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为\)</span>k
$.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4>
<p>第一反应就是枚举$x ’ <span class="math inline">\(和\)</span>y ’ <span class="math inline">\(,然后用数位dp枚举\)</span>d <span class="math inline">\(使得\)</span>x = dx ’ , y = dy ’ $.</p>
<p>但是有一个问题在于如果$( x ’ , y ’ ) <span class="math inline">\(怎么办,这样有可能会算重.我们发现我们只判断\)</span>(
x ’ , y ’ ) = 1 $的情况就行,然后写一个$2 ^8 <span class="math inline">\(判断\)</span>x ’ , 2 x ’ , 3 x ’ , 4 x ’ <span class="math inline">\(以及对应的\)</span>y ’ <span class="math inline">\(出现了没有.复杂度\)</span>( 9 ^4 ^8 _{ 10 } n )
$,有点难过.</p>
<p>但是我们发现这个$2 ^8
$可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有$3
^4 $的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3>
<h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4>
<p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是$O
( nd ^2 ) <span class="math inline">\(的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是\)</span>O
( nd ) $的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取$$转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>现在有一个$[ 1 , n ] <span class="math inline">\(的排列,现在要从中选出一个集合\)</span>S <span class="math inline">\(,满足\)</span>x S , 2 x S , 3 x S $,求方案数.</p>
<p>首先考虑将每个数分解为$a ^b ^c <span class="math inline">\(的形式,显然\)</span>a $不相同的数之间互不干扰.</p>
<p>对于$a <span class="math inline">\(相同的一群数,我们考虑将\)</span>(
b , c )
$作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>$n $个点的树,一开始位于一号点,每个点有一个颜色($0 $或$1 <span class="math inline">\(),每次随机选择一个点\)</span>v <span class="math inline">\(,从当前所在点移动到\)</span>v <span class="math inline">\(并将\)</span>v
$的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为$1
$,当然不为$1 $也能做).</p>
<p>$n $.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是$1
$还是$0 <span class="math inline">\(就可以.不妨设\)</span>f <em>{ i }
<span class="math inline">\(表示当前有\)</span>i $个点是$1 $,最后全$1
$或者全$0 <span class="math inline">\(所需要的期望步数,显然\)</span>f
<em>0 = f <em>n = 0 <span class="math inline">\(,\)</span>f </em>{ i } =
{ 2 } ( f </em>{ i + 1 } + f </em>{ i - 1 } ) + 1
$.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在$u
<span class="math inline">\(,只要当前没有结束,我们还要选点\)</span>v
<span class="math inline">\(,对答案的期望的贡献就是\)</span>u <span class="math inline">\(到这棵树上所有点的距离之和除以\)</span>n <span class="math inline">\(,而这是一个定值.也就是说,只要我们统计一下到了每个点\)</span>u
$多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设$f <em>{ i , j , 0 / 1 } <span class="math inline">\(表示当前场面上有\)</span>i $个$1 <span class="math inline">\(,\)</span>j $号点这里是$0 $还是$1 <span class="math inline">\(,它在结束前能被期望选多少次,注意\)</span>f </em>{
n / 0 , j , 0 / 1 } = 0 <span class="math inline">\(.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设\)</span>f
_{ i , 0 / 1 } <span class="math inline">\(表示当前有\)</span>i $个$1
$,$0 / 1 $染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ 0 / n , 0 / 1  } &amp; = 0 \\
f _{ i , 0  } &amp; = \frac { i  } { n  } f _{ i - 1 , 0  } + \frac { n
- i - 1  } { n  } f _{ i + 1 , 0  } + \frac { 1  } { n  } ( f _{ i + 1 ,
1  } + [ i + 1 \ne n ] ) \\
f _{ i , 1  } &amp; = \frac { i - 1  } { n  } f _{ i - 1 , 1  } + \frac
{ n - i  } { n  } f _{ i + 1 , 1  } + \frac { 1  } { n  } ( f _{ i - 1 ,
0  } + [ i - 1 \ne 0 ] )
\end{aligned}
\]</span></p>
<p>为啥最后加上了$[ i + 1 n ]
$呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了$f <em>{ i , 0 / 1 } <span class="math inline">\(和\)</span>f </em>{ i - 1 , 0 / 1 } <span class="math inline">\(,我们发现我们可以用这两个方程求出\)</span>f <em>{
i + 1 , 0 / 1 } <span class="math inline">\(,然后就比较典了:我们将所有的函数表示成\)</span>af
</em>{ 1 , 0 } + bf <em>{ 1 , 1 } + c <span class="math inline">\(的形式(之所以这么表示,是因为我们架设了\)</span>f
</em>{ 1 , 0 / 1 } <span class="math inline">\(已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出\)</span>f
<em>{ n , 0 / 1 } <span class="math inline">\(,而\)</span>f </em>{ n , 0
/ 1 } $我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3>
<h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4>
<p>首先注意到,$a _i = 1 <span class="math inline">\(的时候和\)</span>a
_i <span class="math inline">\(的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设\)</span>f
_i <span class="math inline">\(为\)</span>a _i = 1 <span class="math inline">\(,而其他\)</span>a $全都为$0 <span class="math inline">\(时的答案,不难发现最后的答案也就是\)</span> $.</p>
<p>而上面的转移自然是:$f _i = { b <em>i , w + </em>{ j = l } ^r f _j }
$.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次$f _i
$最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查$n
$次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5>
<p>考虑组合意义,$a _i ^2 <span class="math inline">\(的意义也即满足操作序列\)</span>u <span class="math inline">\(和操作序列\)</span>v <span class="math inline">\(的最终结果相同的二元组\)</span>( u , v )
$的数量.</p>
<p>不妨设$dp <em>{ i , j , k } <span class="math inline">\(为第一个装置上方已经动了\)</span>i <span class="math inline">\(个珠子,下放动了\)</span>j <span class="math inline">\(个珠子,第二个装置上方动了\)</span>k <span class="math inline">\(个珠子,下方动了\)</span>i + j - k <span class="math inline">\(个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然\)</span>dp
</em>{ n , m , n } $即答案.</p>
<h5><span id="example2">Example2</span></h5>
<p>求长度为$n <span class="math inline">\(的排列的\)</span>( _{ i = 2 }
^{ n - 1 } [ a <em>i &lt; a </em>{ i - 1 } a <em>i &lt; a </em>{ i + 1 }
] ) ^k <span class="math inline">\(的期望\)</span>( n ^9 , k ) $.</p>
<p>$O ( n ^2 k ^2 ) $是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是$ans ^k $,而加入$1 <span class="math inline">\(的时候,对于每个长度为\)</span>n - 1 <span class="math inline">\(的排列,有\)</span>( n - 2 - 2 ans )
$个位置加入后会使答案加一,那我们要求的也就是:</p>
<p><span class="math display">\[
\sum ( n - 1 - 2 ans ) ( ans + 1 ) ^k + \sum ( 2 ans + 2 ) ans ^k
\]</span></p>
<p>推一推式子就可以做到$O ( nk ^2 ) $,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,$ans ^k <span class="math inline">\(等价于从所有的地方中可重复地选出\)</span>k
$个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为$1 <span class="math inline">\(的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设\)</span>f
_{ i , j } <span class="math inline">\(表示已经选了\)</span>i <span class="math inline">\(段波动序列,其中有\)</span>j <span class="math inline">\(个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度\)</span>O
( k ^3 ) $.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>求$<em>{ i = 1 } ^n </em>{ j = 1 } ^n ( a _i a _j ) ^2 <span class="math inline">\(,\)</span>n ^5 <span class="math inline">\(,\)</span>a _i ^9 $.</p>
<p>考虑设$f _i <span class="math inline">\(表示只考虑前\)</span>i
$低的位置,高位全部默认为$0 <span class="math inline">\(的方案数.如果我们设\)</span>cnt <em>i <span class="math inline">\(表示\)</span>a <span class="math inline">\(中第\)</span>i $位为$1 <span class="math inline">\(的数个数,那根据\)</span>( a + b ) ^2 = a ^2 + 2 ab
+ b ^2 <span class="math inline">\(,我们只需要求出\)</span>g </em>{ i }
<span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(低的位置,第\)</span>i + 1 $位是$1 <span class="math inline">\(的数和第\)</span>i + 1 $位是$0 <span class="math inline">\(的数两两异或之和,显然有\)</span>f <em>i = f </em>{
i - 1 } + 2 cnt <em>i ^i g </em>{ i - 1 } + cnt _i 2 ^{ i + 1 } $.</p>
<p>$g <span class="math inline">\(可以用\)</span>O ( n a ) <span class="math inline">\(的复杂度求,这样总复杂度\)</span>O ( n ^2 a )
$.</p>
<h3><span id="线头dp">线头dp</span></h3>
<h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5>
<p>令$dp _{ i , j , k } <span class="math inline">\(表示目前倒到第\)</span>i <span class="math inline">\(个水杯,前面还有\)</span>j <span class="math inline">\(个延续过来的未结束的线头,目前已经选定了\)</span>k
<span class="math inline">\(个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是\)</span>O
( n ^5 ) <span class="math inline">\(的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了\)</span>O
( n ^4 ) $的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5>
<p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设$dp
_{ i , 0 / 1 / 2 } <span class="math inline">\(表示前\)</span>i
$个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212svjetlo">Example3([COCI2020-2021#2]
Svjetlo)</span></h5>
<p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设$dp _{ u , 0 / 1 , 1 / 2 } <span class="math inline">\(为\)</span>u $的状态为$0 / 1 <span class="math inline">\(,以\)</span>u $为根的子树内有$1 / 2
$个线头的方案数.注意如果子树内有$0 / 2 <span class="math inline">\(个线头,那么会在\)</span>u
$处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此$dp _{ u , s ,
2 } <span class="math inline">\(的两个接头实际上一个位于\)</span>u <span class="math inline">\(,另一个位于\)</span>u $的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5>
<p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设$dp _{ i , j , k } <span class="math inline">\(表示目前走到\)</span>i <span class="math inline">\(,前面分成\)</span>j <span class="math inline">\(组,总贡献不超过\)</span>k
$的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489-jtravel-in-sugar-country">Example5([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489) J]Travel in Sugar Country)</span></h5>
<p>一条线段上有$n ( ) <span class="math inline">\(个商店,要从中选出\)</span>k ( ) <span class="math inline">\(个不同的商店\)</span>s _1 , s _2 , , s _k <span class="math inline">\(,使得按顺序遍历这\)</span>k <span class="math inline">\(个商店的路径长度是\)</span>m ( )
$的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设$dp <em>{ i , j , w , l } <span class="math inline">\(表示目前在判断了\)</span>i <span class="math inline">\(个商店,选了\)</span>j <span class="math inline">\(个,并且目前整个图有\)</span>w <span class="math inline">\(条&quot;路径&quot;(连续走动),走过的路在\)</span>m
<span class="math inline">\(一意义下为\)</span>l <span class="math inline">\(的方案数.最后的答案就是\)</span>dp </em>{ n , k ,
1 , 0 } $.</p>
<p>首先,我们对每个点求出$D ( 1 , x ) <span class="math inline">\(,然后\)</span>D ( x , y ) = | D ( 1 , y ) - D ( 1
, x ) | <span class="math inline">\(,不难发现\)</span>x <span class="math inline">\(越大\)</span>D ( 1 , x ) <span class="math inline">\(越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的\)</span>D
$和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径($s _1
s _1 <span class="math inline">\(),接下来,我们每插入一个点\)</span>x
$,我们考虑它的贡献:</p>
<ol type="1">
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是$-
2 D ( 1 , x ) $,对方案数的贡献为$1 $.</p></li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为$0
$.</p></li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为$2 D ( 1 , x )
$.</p></li>
</ol>
<p>这样我们就做到了$O ( n ^4 km ) $的复杂度.如果我们加两维$0 / 1 <span class="math inline">\(表示目前起点和终点是否加入,就可以把复杂度优化到\)</span>O
( n ^2 km ) $.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3>
<p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4>
<p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3>
<p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4>
<p>先考虑数字两两不同的时候怎么做,我们先找到$A <span class="math inline">\(中的全局最大值所在位置和\)</span>B <span class="math inline">\(中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时\)</span>A
<span class="math inline">\(取出的数量和\)</span>B
$的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把$B <span class="math inline">\(序列分成两部分,这两部分将由\)</span>A <span class="math inline">\(中相等的两部分分别生成.不妨假设这个全局最大值的位置是\)</span>x
<span class="math inline">\(,那么对于\)</span>[ 1 , x ] <span class="math inline">\(这一段的\)</span>A <span class="math inline">\(生成的\)</span>B <span class="math inline">\(数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的\)</span>A
<span class="math inline">\(能生成的\)</span>B <span class="math inline">\(的数量.对于\)</span>[ 1 , x + 1 ] $则任意.</p>
<p>那么我们所需要做的就是求出$A <span class="math inline">\(的某一段删掉若干次最大值后的序列所能生成的\)</span>B
<span class="math inline">\(的数量.不妨设\)</span>dp _{ l , r , i }
<span class="math inline">\(表示\)</span>[ l , r ] <span class="math inline">\(中所有\)</span>i
$的数字组成的序列所能生成的数量.</p>
<p>如果$[ l , r ] <span class="math inline">\(这段区间中没有数字\)</span>i <span class="math inline">\(,那显然\)</span>dp <em>{ l , r , i } = dp </em>{ l
, r , i - 1 } <span class="math inline">\(,不然,我们可以枚举两端分开的位置,那这个位置一定在数字\)</span>i
$的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4>
<p>注意到第$n <span class="math inline">\(个元素一定是山峰.所以我们考虑用第\)</span>n
$个元素分割整个区间为两部分.</p>
<p>设$f _n <span class="math inline">\(为\)</span>n <span class="math inline">\(个元素且开头为山谷的答案.枚举第\)</span>n <span class="math inline">\(个元素在位置\)</span>k <span class="math inline">\((\)</span>k - 1 <span class="math inline">\(是奇数),则\)</span>f <em>k f </em>{ n - 1 - k } {
k } f _n $.</p>
<h4><span id="example3">Example3</span></h4>
<p>给定数组$a <span class="math inline">\(,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.\)</span>n
$.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设$f <em>{ l , r
} <span class="math inline">\(为将\)</span>[ l , r ] <span class="math inline">\(删干净后再去删\)</span>a </em>{ l - 1 } , a _{ r +
1 } <span class="math inline">\(的方案数,然后枚举\)</span>[ l , r ]
$中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairingpoints">Example4([AGC039E] Pairing
Points)</span></h4>
<p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从$1 $号点这里断开,枚举$1 <span class="math inline">\(号点连接哪个点,然后就可以让\)</span>( 2 , 2 n )
<span class="math inline">\(这些点断开了.我们设计\)</span>f <em>{ i , j
, k } <span class="math inline">\(或\)</span>[ i , j ] ( k ) <span class="math inline">\(表示区间\)</span>[ i , j ] <span class="math inline">\(中的\)</span>k $向外连了一条边.答案是枚举$1 <span class="math inline">\(号点连了哪个点,也就是\)</span></em>{ i = 3 } ^{ 2
n - 1 } f _{ 2 , 2 n , i } $.</p>
<p>于是我们现在的问题在于如何求$f _{ i , j , k } <span class="math inline">\(.由于边要联通,所以与\)</span>k <span class="math inline">\(相连的这条边必然被\)</span>[ i , j ] <span class="math inline">\(中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为\)</span>x
y <span class="math inline">\(.这样整个区间被分为了两个部分:\)</span>[ i
, k ] ( x ) , [ k , j ] ( y ) <span class="math inline">\(.但是问题并没有得到解决.因为\)</span>[ i , x ]
<span class="math inline">\(和\)</span>[ y , j ] <span class="math inline">\(之间的确不可能出现连边了,但\)</span>[ x , k ]
<span class="math inline">\(和\)</span>[ k , y ] <span class="math inline">\(之间仍然可能出现连边.但我们发现:在\)</span>[ i , k
] $中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为$p , q <span class="math inline">\(.现在整个区间被分为了三个部分:\)</span>[ i , p ] (
x ) , [ p , q ] ( k ) , [ q , j ] ( y )
$,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-andremove">Example5([AGC035D] Add and
Remove)</span></h4>
<p>首先自然想到区间dp.但是难以处理的是如果一个区间$[ l , r ] <span class="math inline">\(中间删掉一个点\)</span>p <span class="math inline">\(之后,\)</span>[ l , p - 1 ] <span class="math inline">\(和\)</span>[ p + 1 , r ]
$会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到$[ l + 1 , r - 1 ] <span class="math inline">\(中最后删除的点\)</span>p <span class="math inline">\(,这样区间\)</span>[ l , r ] <span class="math inline">\(的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除\)</span>[
l + 1 , p - 1 ] <span class="math inline">\(的时候,对\)</span>p <span class="math inline">\(产生的贡献和删除\)</span>[ p + 1 , r - 1 ] <span class="math inline">\(的时候对\)</span>p
$的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设$a
_l <span class="math inline">\(贡献了\)</span>x <span class="math inline">\(倍,\)</span>a _r <span class="math inline">\(贡献了\)</span>y <span class="math inline">\(倍,那么由于\)</span>a _p <span class="math inline">\(会两边都贡献到,所以\)</span>a _p <span class="math inline">\(会对答案贡献\)</span>x + y $倍.</p>
<p>于是设计一个dp是:$f <em>{ l , r , x , y } <span class="math inline">\(表示删除\)</span>[ l + 1 , r - 1 ] <span class="math inline">\(后,\)</span>xa <em>l + ya <em>r <span class="math inline">\(最小是多少.自然有\)</span>f </em>{ l , r , x , y }
= { f </em>{ l , p , x , x + y } + f </em>{ p , r , x + y , y } + ( x +
y ) a _p } $.</p>
<p>至于复杂度,前两维肯定是$n ^2 <span class="math inline">\(的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移\)</span>n
$层,因此是$2 ^n <span class="math inline">\(的空间,于是时间复杂度不会超过\)</span>O ( n ^3 2
^n ) <span class="math inline">\(,其实经过一些奇怪计算应该是不会超过\)</span>O ( 2
^n ) $的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4>
<p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设$f _{ l , r } <span class="math inline">\(表示删除\)</span>[ l , r ] <span class="math inline">\(区间的代价.接下来我们无非要枚举\)</span>k <span class="math inline">\(,使得\)</span>k $是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如$l <span class="math inline">\(,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果\)</span>a
<em>l = a <em>k <span class="math inline">\(,那么这等价于\)</span>f
</em>{ l + 1 , k - 1 } + [ l = k - 1 ] + f </em>{ k + 1 , r }
$.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4>
<p>首先考虑一下$m = 2 ^k - 1 $的情况,首先我们要判断有几个数最高位是$1
$,然后接下来判断第二位哪些数字是$1 $.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是$1
$的就一定大于最高位是$0 <span class="math inline">\(的了,这两个区间就没有影响了.因此可以设\)</span>f
_{ l , r , k } <span class="math inline">\(表示\)</span>[ l , r ] <span class="math inline">\(这个区间,前面已经有了\)</span>k $个$1
$的最大贡献.</p>
<p>那么对于$m ^k - 1 <span class="math inline">\(的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过\)</span>m
$就行了.</p>
<h3><span id="相互独立">相互独立</span></h3>
<h5><span id="example12019zrtg十连测day1origami">Example1(2019zrtg十连测day1
origami)</span></h5>
<p>看上去很不好做,先考虑宽为$1 $怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间$[
l , r ] <span class="math inline">\(,然后看\)</span>[ 1 , l - 1 ] <span class="math inline">\(和\)</span>[ r + 1 , m ] <span class="math inline">\(能不能折进来.也就是判断以\)</span>r <span class="math inline">\(和\)</span>r + 1
$为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设$f _i <span class="math inline">\(表示能不能折成以\)</span>[ 1 , i ] <span class="math inline">\(为最下层,\)</span>g _i <span class="math inline">\(表示能不能折成\)</span>[ i , n ] <span class="math inline">\(为最下层,那\)</span>[ l , r ] <span class="math inline">\(能折出来当且仅当\)</span>f _r = g _l = 1
$,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-anedge">Example2(CF1616G Just Add an
Edge)</span></h5>
<p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如$1 x y n $,并且$1 x <span class="math inline">\(和\)</span>y n <span class="math inline">\(不交,然后添加边\)</span>x y $.</p>
<p>那么什么时候$1 x <span class="math inline">\(和\)</span>y n <span class="math inline">\(没有交并且他们的并是\)</span>[ 1 , n ]
$呢?考虑将$1 x $这条路径上的点染色为$0 <span class="math inline">\(,\)</span>y n $上的点染色为$1 <span class="math inline">\(,由于边只有从前往后的,因此\)</span>[ 1 , y - 1 ]
$必然为$0 <span class="math inline">\(,\)</span>[ x + 1 , n ] $必然为$1
$.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了$y <span class="math inline">\(,现在想要找到\)</span>x <span class="math inline">\(,我们现在假设染色的末尾是\)</span>( i , i + 1 )
<span class="math inline">\(,也就是\)</span>i <span class="math inline">\(染色和\)</span>i + 1
$的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个$p <span class="math inline">\(,满足\)</span>p p + 1 <span class="math inline">\(,那么\)</span>p <span class="math inline">\(和\)</span>p + 1 <span class="math inline">\(永远不可能染同种颜色,我们直接以它为断点,自然发现\)</span>p
$的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了$p p + 1
$这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立$0
<span class="math inline">\(和\)</span>n + 1 $两个虚点,向所有点连边.</p>
<p>总之$O ( nm )
$的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3>
<p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5>
<p>首先考虑已知一个序列,如何快速求它最后有几个位置不是$0 <span class="math inline">\(.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其\)</span>-
1 $并重复判断操作,直到为$0 $或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是$0 <span class="math inline">\(相当于判断后面的已知序列的\)</span>mex <span class="math inline">\(,这个要记入状态中,于是考虑设\)</span>dp _{ i , j }
<span class="math inline">\(表示当前到了第\)</span>i <span class="math inline">\(个位置,后面的数的\)</span>mex - 1 <span class="math inline">\(是\)</span>j $的方案数.</p>
<p>但是如果直接这么设会发现,当前$i <span class="math inline">\(的加入有可能会改变\)</span>mex <span class="math inline">\(的值,而这个改变是很难处理的,因为如果\)</span>i
<span class="math inline">\(位置选择了\)</span>j + 1 <span class="math inline">\(这个数字,那么\)</span>mex <span class="math inline">\(要向上伸展到某一个值,而如果不选择\)</span>j + 1
<span class="math inline">\(,也有可能选择一个更大的值后不断落到\)</span>j + 1
<span class="math inline">\(,这意味着我们转移时需要枚举补上\)</span>j +
1 <span class="math inline">\(这个数字后的\)</span>mex
$并用刷表法转移.</p>
<p>不妨设这个数字是$k <span class="math inline">\(.如果我们插入一个数字后直接更新当前的答案,可以发现这个\)</span>k
<span class="math inline">\(是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起\)</span>mex
<span class="math inline">\(的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全\)</span>[
j + 2 , k ] $这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以$2
^{ n } $.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5>
<p>$O ( n ^3 ) <span class="math inline">\(的暴力是显然的:设\)</span>f
_{ i , j , k } <span class="math inline">\(表示目前考虑到第\)</span>i
<span class="math inline">\(个位置,前面还有\)</span>j <span class="math inline">\(个A,已经选了\)</span>k
$个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到$n ^2 $.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设$f
_{ i , j } <span class="math inline">\(表示目前考虑到\)</span>i <span class="math inline">\(,还需要\)</span>j <span class="math inline">\(个B才能凑齐\)</span>c _B
$个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3>
<h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5>
<p>设$f <em>{ i , j } <span class="math inline">\(表示长度为\)</span>i
<span class="math inline">\(,开头为山峰且高度为\)</span>j <span class="math inline">\(的方案数;\)</span>g </em>{ i , j } <span class="math inline">\(表示长度为\)</span>i <span class="math inline">\(,开头为山谷且高度为\)</span>j <span class="math inline">\(的方案数.注意到这俩显然是一个双射,也就是\)</span>f
<em>{ i , j } = g </em>{ i , i - j + 1 } $.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于$j
<span class="math inline">\(的数都向上平移一格,于是自然有:\)</span>f
<em>{ i , j } = </em>{ k = 1 } ^{ j - 1 } g <em>{ i - 1 , k } = </em>{ k
= 1 } ^{ j - 1 } f _{ i - 1 , i - k } $.</p>
<p>另外,这个式子可以稍微转化为:$f <em>{ i , j } = f </em>{ i - 1 , i - j
+ 1 } + f <em>{ i , j - 1 } = g </em>{ i - 1 , j - 1 } + f _{ i , j - 1
} $.</p>
<p>上式可以这么理解:我们讨论一下$j <span class="math inline">\(和\)</span>j - 1 <span class="math inline">\(是否相邻,如果相邻必然是\)</span>j <span class="math inline">\(是山峰,\)</span>j - 1
$是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1group">Example2(2019zrtg十连测day1
group)</span></h5>
<p>首先注意到$2 k n nk ^5 <span class="math inline">\(,不难发现\)</span>k $.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到$O
( nk ^2 ) $.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点$w <span class="math inline">\(,使得成为组长的经验\)</span>w <span class="math inline">\(,成为组员的经验\)</span>w
$,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5>
<p>双序列计数,考虑把$x $双射到某个东西上.</p>
<p>考虑最后的图一定是个$DAG
$,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设$dp _{ l , r , mx } <span class="math inline">\(表示只考虑\)</span>[ l , r ] <span class="math inline">\(这一段的线段,然后最大值所在位置需要\)</span>mx
$的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3>
<p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweightedincreasing-subsequences">Example1([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<h2><span id="动态规划的优化">动态规划的优化</span></h2>
<h3><span id="递进转移">递进转移</span></h3>
<p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5>
<p>有$m <span class="math inline">\(种礼物,每种礼物有无数个(有有限个也能做),\)</span>n
<span class="math inline">\(个朋友,第\)</span>i <span class="math inline">\(个朋友喜欢第\)</span>j <span class="math inline">\(个礼物的概率是\)</span>p <em>{ i , j } <span class="math inline">\(,\)</span>i , p </em>{ i , j } = 1 $.</p>
<p>现在你可以选$n
$件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p>$n , m $.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出$g
_{ i , j } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(种礼物一共选了\)</span>j
$个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么$g <span class="math inline">\(怎么求呢?这个是简单的,我们设\)</span>f <em>{ i , j
} <span class="math inline">\(表示喜欢第\)</span>i <span class="math inline">\(种礼物的人有\)</span>j <span class="math inline">\(个的概率,不难发现\)</span>g </em>{ i , j } = <em>{
k = 0 } ^n { j , k } f </em>{ i , k } <span class="math inline">\(.递推式就有\)</span>g <em>{ i , j } = g </em>{ i ,
j - 1 } + <em>{ k = j } ^n f </em>{ i , k } <span class="math inline">\(.\)</span>f $同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是$O ( n ^2 m )
$的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现$g _{ i , j } <span class="math inline">\(满足四边形不等式,而其转移是经典的\)</span>k
$点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于$g _i <span class="math inline">\(是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为\)</span>c
<em>i <span class="math inline">\(,每次选当前\)</span>g </em>{ i , c
<em>i + 1 } - g </em>{ i , c _i } <span class="math inline">\(最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为\)</span>c
_i <span class="math inline">\(越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度\)</span>O
( n ^2 n ) <span class="math inline">\(,不太确定有没有\)</span>O ( n ^2
) $的做法.</p>
<p>但是第二个背包,也就是$f <span class="math inline">\(怎么求呢?我们发现我们没有必要把\)</span>g <span class="math inline">\(全都求出来,只需要求目前需要的一部分就可以了,由于\)</span>f
= 1 <span class="math inline">\(,因此后缀和可以改为前缀和,考虑到每往后推一位是\)</span>O
( n ) <span class="math inline">\(的,但是只会往后推总共\)</span>O ( n )
<span class="math inline">\(位,因此这里复杂度\)</span>O ( n ^2 ) $.</p>
<h5><span id="example2">Example2</span></h5>
<p>给一个字符串,求一个最大长度$L { 2 } <span class="math inline">\(,使得前\)</span>L <span class="math inline">\(个字符与后\)</span>L $个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<p><span class="math display">\[
ABSBA
\]</span></p>
<p>我们枚举$A <span class="math inline">\(的长度,然后就只需要求\)</span>B <span class="math inline">\(,设\)</span>f <em>{ i } <span class="math inline">\(表示字符串去掉开头和结尾的\)</span>i <span class="math inline">\(个字符后的border,有\)</span>f </em>{ i - 1 } f _i
+ 1 $.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3>
<p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k <span class="math inline">\(暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取\)</span><span class="math inline">\(操作很艰难.但如果!我把这个dp反过来,我设\)</span>f
_{ i , j } <span class="math inline">\(表示**从后往前**dp到\)</span>i
<span class="math inline">\(,当前的最大前缀和是\)</span>j
$的概率是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i -
1  } \}  }
\]</span></p>
<p>最后在$f _{ 1 , j } <span class="math inline">\(处乘上\)</span>h _j
$.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g <em>{ i , j } <span class="math inline">\(表示如果初始只有\)</span>f </em>{ i , j } = 1
$,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g
_{ i , j  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>我认真考虑过这个$P <span class="math inline">\(应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些\)</span>P
$变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3>
<h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4>
<p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于$200
$.也就是说转移矩阵大概是$200 <span class="math inline">\(的,设状态数为\)</span>S $.</p>
<p>继续考虑,如果直接做的话复杂度是$O ( TS ^3 n ) $,过不了.</p>
<p>我们考虑将一个$n <span class="math inline">\(在\)</span>w <span class="math inline">\(进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了\)</span>O
( wS ^3 _w n + TS ^2 _w n ) <span class="math inline">\(,平衡一下复杂度即可,大概取\)</span>w = 4
$会比较优秀.</p>
<h4><span id="example2noionline3提高组魔法值">Example2([NOI
Online#3提高组]魔法值)</span></h4>
<p>重新定义矩阵乘法:用$<span class="math inline">\(替换原本的\)</span>+
$,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4>
<p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令$f <em>i = </em>{ j , a _j = a _i - 1 } f _j <span class="math inline">\(,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的\)</span><span class="math inline">\(的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的\)</span>f
$.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设$f _{
i , j } <span class="math inline">\(表示所有\)</span>a _x = i <span class="math inline">\(的\)</span>x <span class="math inline">\(中第\)</span>j <span class="math inline">\(小的\)</span>x $的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4>
<p>注意到$m <span class="math inline">\(和\)</span>k
$很小,这一定是突破口.</p>
<p>又注意到如果$a _{ i + 1 } &gt; a <em>i <span class="math inline">\(,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字\)</span>x
+ 1 <span class="math inline">\(,我们考虑它只能插入\)</span>[ x + 1 - m
, x ] <span class="math inline">\(后面,我们直接用一个二进制数\)</span>S
<span class="math inline">\(表示\)</span>[ x + 1 - m , x ] <span class="math inline">\(中的数字是否存在,然后就可以在转移上直接调用\)</span>popcount
( S ) <span class="math inline">\(.设\)</span>dp </em>{ i , j , S }
<span class="math inline">\(表示目前考虑完了数字\)</span>i <span class="math inline">\(,插入了\)</span>j <span class="math inline">\(个数字,存在情况是\)</span>S <span class="math inline">\(.直接对它做矩阵加速就可以做到\)</span>O ( ( 2 ^m k
) ^3 n ) $.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4>
<p>设$dp _{ i , j } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(天走到城市\)</span>j $的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上$k
$.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3>
<p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4>
<p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设$f _{ l , r } <span class="math inline">\(表示\)</span>a _l
<span class="math inline">\(和\)</span>a _r <span class="math inline">\(必选的前提下,\)</span>[ l , r ]
$这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设$dp <em>{ i , j } <span class="math inline">\(表示前\)</span>i
<span class="math inline">\(个点,最大值为\)</span>j <span class="math inline">\(的方案数,不难发现最后一个矩阵的最小值一定是\)</span>a
</em>{ i } <span class="math inline">\(.然后\)</span>dp <em>{ a , b } =
</em>{ i &lt; a , j &lt; b } dp <em>{ i , j } f </em>{ i + 1 , a }
$.</p>
<p>这个转移是$n ^4 <span class="math inline">\(的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到\)</span>n
^2 <span class="math inline">\(,这样我们就得到了一个复杂度\)</span>O ( n
^3 ) $的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点$i
<span class="math inline">\(,它所在矩阵的最左边的点\)</span>k <span class="math inline">\(,最右边的点\)</span>k <span class="math inline">\(,然后此时的答案为\)</span>pre [ j - 1 ] [ a [ k ]
- 1 ] nxt [ k + 1 ] [ a [ j ] + 1 ] f [ j ] [ i ] f [ i ] [ k ] $.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设$g <em>{ i , j } <span class="math inline">\(为接下来我们要选\)</span>[ i , j ] <span class="math inline">\(,\)</span>i <span class="math inline">\(是矩阵左端点,\)</span>j <span class="math inline">\(任意且这两个点必在矩阵中,左右两边的方案数.初始条件\)</span>g
</em>{ i , j } = pre [ i - 1 ] [ a [ j ] - 1 ] nxt [ j + 1 ] [ a [ i ] +
1 ] $.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3>
<h4><span id="example2022zrtg十连测day7zero">Example(2022zrtg十连测day7
Zero)</span></h4>
<p>设$k = { i , j } <span class="math inline">\(,首先可以求出\)</span>x
, y , z $分别表示:</p>
<ol type="1">
<li><p>$x <span class="math inline">\(:只包含第一行的格子的以\)</span>k
$为右端点的和为$0 <span class="math inline">\(的最小矩形的左端点\)</span>- 1 $.</p></li>
<li><p>$y <span class="math inline">\(:只包含第二行的格子的以\)</span>k
$为右端点的和为$0 <span class="math inline">\(的最小矩形的左端点\)</span>- 1 $.</p></li>
<li><p>$z <span class="math inline">\(:同时包含两行的格子的以\)</span>k
$为右端点的和为$0 <span class="math inline">\(的最小矩形的左端点\)</span>- 1 $.</p></li>
</ol>
<p>那么自然有转移:</p>
<p><span class="math display">\[
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z
, z ) + 1 \}
\end{gathered}
\]</span></p>
<p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到$f ( i , k ) <span class="math inline">\(关于\)</span>i <span class="math inline">\(不降,于是显然当\)</span>f ( i , y ) f ( i , k - 1
) <span class="math inline">\(的时候才会由\)</span>f ( i , y ) + 1 <span class="math inline">\(转移过来.我们不妨设\)</span>p _i <span class="math inline">\(表示最小的位置满足\)</span>f ( i , p _i ) = f ( i
, k - 1 ) <span class="math inline">\(,那转移也就是\)</span>f ( i , k )
f ( i , k - 1 ) + [ p _i y ] <span class="math inline">\(.并且每进行一次转移,都会满足\)</span>p _i y <span class="math inline">\(的\)</span>p _i <span class="math inline">\(设为\)</span>k $.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的$i <span class="math inline">\(在当前\)</span>k <span class="math inline">\(的\)</span>f <span class="math inline">\(值,将这个点放到\)</span>p _i <span class="math inline">\(位置上.然后我们每次找到\)</span>y <span class="math inline">\(并把所有在\)</span>y <span class="math inline">\(位置前的点都合并到\)</span>k <span class="math inline">\(这个点上,并打一个加法\)</span>tag
$,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的$p _k $.</p>
<p>最后还需要处理一下$f _{ k , k } $,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照${ i , j }
$为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3>
<p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5>
<p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是$ i
&lt; j &lt; k n <span class="math inline">\(,\)</span>a _i &gt; a _j
&gt; a _k $.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是$dp _{ i , j }
<span class="math inline">\(表示现在做到\)</span>i <span class="math inline">\(,另一个上升子序列的终点是\)</span>j
$,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在$i <span class="math inline">\(一定的情况下,\)</span>j <span class="math inline">\(的值越小越容易满足.所以设\)</span>dp _i <span class="math inline">\(表示一个上升子序列的终点是\)</span>i
$,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5>
<p>首先自然的设计是$dp _{ l , r , u , d } <span class="math inline">\(,然后优化一下就是\)</span>O ( n ^4 )
$.然后咋做?</p>
<p>注意到答案不超过$<span class="math inline">\(级别,所以设\)</span>dp
_{ l , r , u , c } <span class="math inline">\(表示答案为\)</span>c
<span class="math inline">\(的时候,最大的\)</span>d <span class="math inline">\(是多少.然后就\)</span>O ( n ^3 n ) $.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数$a _i <span class="math inline">\(减去\)</span>[ 1 , a _i ] $中的一个数字,减成$0
<span class="math inline">\(就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.\)</span>(
n ) $</p>
<p>先考虑一个$O ( n ^2 a ^2 ) $的dp,比较显然,因为一个人取数显然要么取$1
<span class="math inline">\(要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设\)</span>dp
_{ l , r , x , y } <span class="math inline">\(表示目前Alice在取第\)</span>l <span class="math inline">\(堆,Bob在取第\)</span>r <span class="math inline">\(堆,第\)</span>l <span class="math inline">\(堆为\)</span>x <span class="math inline">\(,第\)</span>r <span class="math inline">\(堆为\)</span>y $的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把$a
$存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是$1 <span class="math inline">\(还是更大的数好像无所谓.那:如果\)</span>a _1 = x
<span class="math inline">\(的时候,Alice能赢,那\)</span>a _1 = x + 1
$的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选$1
<span class="math inline">\(,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于\)</span>a
_l <span class="math inline">\(或\)</span>a _r $.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存$0 / 1 $是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设$dp _{ l , r } <span class="math inline">\(表示当前Alice在\)</span>l <span class="math inline">\(,Bob在\)</span>r <span class="math inline">\(,Bob还没动\)</span>a _r <span class="math inline">\(的前提下,\)</span>a <em>l <span class="math inline">\(至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较\)</span>dp
</em>{ 1 , 1 } <span class="math inline">\(和\)</span>a _1
$的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选$l <span class="math inline">\(,Bob开始选\)</span>r <span class="math inline">\(,那Alice的获胜条件显然是\)</span>dp _{ l , r } a
_r $</p>
<p>如果可以全选(也就是Alice开始选$l + 1 <span class="math inline">\(,Bob开始选\)</span>r <span class="math inline">\(的时候Alice能赢),就直接让\)</span>dp <em>{ l , r }
= 1 <span class="math inline">\(.不然,由于清空堆的人要输,所以Alice为了不输,必须要让\)</span>dp
</em>{ l , r - 1 } <span class="math inline">\(也满足条件,一个自然的想法是\)</span>dp <em>{ l , r
- 1 } + a <em>r + 1 <span class="math inline">\(,但是这个值好像没有必要:因为Bob并不是只有会不断清空\)</span>a
<em>r <span class="math inline">\(的,如果目前的\)</span>[ l + 1 , r ]
<span class="math inline">\(这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢\)</span>[
l + 1 , r ] <span class="math inline">\(的值,Bob就必须全清空,所以如果我们设\)</span>g
</em>{ l , r } <span class="math inline">\(是Bob的\)</span>dp <span class="math inline">\(数组,那其实这里应该是\)</span>a <em>r + 1 + dp
</em>{ l , r - 1 } - g </em>{ l + 1 , r } <span class="math inline">\(,因为Bob的策略一定是一步一步走到\)</span>g </em>{
l + 1 , r } $后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5>
<p>自然的想法是$dp _{ i , j } <span class="math inline">\(表示\)</span>i
<span class="math inline">\(子树内划分成\)</span>j <span class="math inline">\(个连通块是否合法,然后我们发现如果\)</span>j <span class="math inline">\(满足条件,那么\)</span>j + 2
$一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3>
<p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于$y
$轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5>
<p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3>
<p>能用WQS二分解决的问题通常形如:需要在$n <span class="math inline">\(个物品中选择恰好\)</span>m <span class="math inline">\(个,使得最后答案最大.并且如果令\)</span>f _i <span class="math inline">\(表示选了\)</span>i <span class="math inline">\(个的最大答案,\)</span>f _i
$必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数$C <span class="math inline">\(,每选择一个物品就减去\)</span>C <span class="math inline">\(的答案.不难发现这样我们一定能逼近\)</span>f _m
$.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3>
<p>对于定义在$ <span class="math inline">\(上的二元函数\)</span>w <span class="math inline">\(,若对定义域上任意\)</span>a , b , c , d ( a b c d
) <span class="math inline">\(都有\)</span>w ( a , c ) + w ( b , d ) w (
a , d ) + w ( b , c ) <span class="math inline">\(,也就是交叉小于包含,则称函数\)</span>w
$满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:$w
$所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于$0
$.</p>
<p>如果它还满足$ l ’ l r r ’ n , w ( l , r ) w ( l ’ , r ’ )
$，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理$<span class="math inline">\(型dp的问题,对于\)</span><span class="math inline">\(型dp需要取相反数改成\)</span>$.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p>若二元函数$w ( x , y ) <span class="math inline">\(满足\)</span>w ( a
, b ) + w ( a + 1 , b + 1 ) w ( a , b + 1 ) + w ( a + 1 , b ) <span class="math inline">\(.其中\)</span>a &lt; a + 1 b &lt; b + 1 <span class="math inline">\(,则\)</span>w $满足四边形不等式.</p>
<p>证明:</p>
<p>对于$a + 1 &lt; c $ 有</p>
$$
<span class="math display">\[\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1
, c ) \\
w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a
, c ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>同时有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) &amp; \leq w ( a + 1 , c + 1 ) + w
( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
+ 1 , c + 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
<p><span class="math display">\[
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
, c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) &amp; \leq w ( a + 1 , c ) + w ( a + 2
, c + 1 )
\end{aligned}
\]</span></p>
<p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个$2
$的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5>
<p>若$w _1 ( l , r ) , w _2 ( l , r ) <span class="math inline">\(满足四边形不等式(或区间包含单调性),则\)</span>c _1
, c _2 <span class="math inline">\(,\)</span>( c _1 w _1 + c _2 w _2 )
$满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若$f ( x ) , g ( x ) <span class="math inline">\(使得\)</span>w ( l ,
r ) = f ( r ) - g ( l ) <span class="math inline">\(,则\)</span>w <span class="math inline">\(满足四边形恒等式.当\)</span>f , g <span class="math inline">\(单调递增时,\)</span>w $还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>设$h <span class="math inline">\(是一个单调递增的下凸函数(一阶导数单调递增),若\)</span>w
( l , r ) <span class="math inline">\(满足四边形不等式和区间包含单调性,则复合函数\)</span>h
( w ( l , r ) ) $也满足四边形不等式和区间包含单调性.</p>
<p>令$l _1 l _2 r _1 r _2 <span class="math inline">\(,由于\)</span>w
$满足四边形不等式,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l _1 , r _1 ) + w ( l _2 , r _2 ) &amp; \leq w ( l _1 , r _2 ) + w (
l _2 , r _1 ) \\
0 &amp; \leq w ( l _1 , r _1 ) - w ( l _2 , r _1 ) &amp; \leq w ( l _1 ,
r _2 ) - w ( l _2 , r _2 )
\end{aligned}
\]</span></p>
<p>令$t = w ( l _1 , r _2 ) - w ( l _2 , r _2 ) $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l _1 , r _1 ) &amp; \leq w ( l _2 , r _1 ) + t \\
w ( l _1 , r _2 ) &amp; = w ( l _2 , r _2 ) + t \\
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) &amp; \leq h ( w ( l
_2 , r _1 ) + t ) - h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) &amp; = h ( w ( l _2 ,
r _2 ) + t ) - h ( w ( l _2 , r _2 ) )
\end{aligned}
\]</span></p>
<p>不妨令$h ( x ) = h ( x + t ) - h ( x ) <span class="math inline">\(,由于\)</span>h <span class="math inline">\(是下凸函数,所以\)</span>h $函数单调递增.</p>
<p>那么也就有:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) &amp; \leq \Delta h (
w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) &amp; = \Delta h ( w (
l _2 , r _2 ) )
\end{aligned}
\]</span></p>
<p>由于$w ( l _2 , r _1 ) w ( l _2 , r _2 ) <span class="math inline">\(,所以\)</span>h ( w ( l _2 , r _1 ) ) h ( w ( l _2
, r _2 ) ) $于是:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) &amp; \leq h ( w ( l
_1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) \\
h ( w ( l _1 , r _1 ) ) + h ( w ( l _2 , r _2 ) ) &amp; \leq h ( w ( l
_1 , r _2 ) ) + h ( w ( l _2 , r _1 ) )
\end{aligned}
\]</span></p>
<p>证毕.</p>
<h5><span id="定理5">定理5</span></h5>
<p>设$h <span class="math inline">\(是一个下凸函数(一阶导数单调递增),若\)</span>w ( l
, r ) <span class="math inline">\(满足四边形恒等式和区间包含单调性,则复合函数\)</span>h
( w ( l , r ) ) $也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到$h $单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4>
<p>对于形如$f <em>i = </em>{ 1 j &lt; i } { f _j + w ( j , i ) } <span class="math inline">\(的状态转移方程,记\)</span>p _i <span class="math inline">\(为\)</span>f _i <span class="math inline">\(的最优决策.若\)</span>p <span class="math inline">\(在\)</span>[ 1 , n ] <span class="math inline">\(上单调不降,则称\)</span>f $具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的$<span class="math inline">\(改为\)</span><span class="math inline">\(,并且把\)</span>+ w <span class="math inline">\(改为\)</span>- w $,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5>
<p>定理：对于形如$f <em>i = </em>{ 1 j &lt; i } { f _j + w ( j , i ) }
<span class="math inline">\(的状态转移方程,若\)</span>w <span class="math inline">\(满足四边形不等式,则\)</span>f $有决策单调性.</p>
<p>证明:</p>
<p>$i , j <span class="math inline">\(,根据\)</span>p $的定义,有:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ p _i  } + w ( p _i , i ) &amp; \leq f _j + w ( j , i ) \\
f _{ p _i  } - f _j &amp; \leq w ( j , i ) - w ( p _i , i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而对于$k <span class="math inline">\(,根据\)</span>w
$的四边形不等式,有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( j , i ) + w ( p _i , k ) &amp; \leq w ( j , k ) + w ( p _i , i ) \\
w ( j , i ) - w ( p _i , i ) &amp; \leq w ( j , k ) - w ( p _i , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ p _i  } - f _j &amp; \leq w ( j , k ) - w ( p _i , k ) \\
f _{ p _i  } + w ( p _i , k ) &amp; \leq w ( j , k ) + f _j \\

\end{aligned}\]</span>
<p>$$</p>
<p>即:$j <span class="math inline">\(对\)</span>k <span class="math inline">\(的更新一定不如\)</span>p _i <span class="math inline">\(对\)</span>k <span class="math inline">\(的更新更优,因此\)</span>p _k <span class="math inline">\(,因此\)</span>f $有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6>
<p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设$f <em>i <span class="math inline">\(表示价值为\)</span>i
<span class="math inline">\(的答案,自然有:\)</span>f <em>i = { f </em>{
i - kc } + sum </em>{ c , k } } $.</p>
<p>如果我们把$c <span class="math inline">\(相同的分层,那这显然是一个最短路型dp,其中\)</span>w
( i , j ) = sum _{ c , { c } } $.</p>
<p>显然这个转移只会让$c <span class="math inline">\(相同的相互转移,于是后面的\)</span>w ( i , j )
<span class="math inline">\(可以理解为一段数字的和,自然满足四边形不等式(\)</span>$也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5>
<p>对于形如$f <em>{ x , j } = </em>{ i = 1 } ^{ x - 1 } { f <em>{ i , j
- 1 } + w </em>{ i , x } } <span class="math inline">\(的状态转移方程,若\)</span>w <span class="math inline">\(满足四边形不等式,则\)</span>f
$有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如$f <em>x = </em>{ i = 1 } ^{ x - 1 } { w _{ i ,
x } } <span class="math inline">\(,我们也可以看作\)</span>k <span class="math inline">\(点最短路型的\)</span>k = 1 $的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6>
<p>令$f ( i , j ) <span class="math inline">\(为在第\)</span>j <span class="math inline">\(个位置建造第\)</span>i
$个基站的代价最小值,那么我们有转移:</p>
<p><span class="math display">\[
f ( i , j ) = \min _{ 1 \leq k &lt; j  } \{ f ( i - 1 , k ) + \sum _{ l
= k + 1  } ^{ j - 1  } w _l [ d _l - s _l &gt; d _k ] [ d _l + s _l &lt;
d _j ] + c _j \}
\]</span></p>
<p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时$d
_k <span class="math inline">\(单调递增,更新答案时\)</span>d _j <span class="math inline">\(单调递增,于是可以直接使用线段树维护,复杂度\)</span>O
( nk n ) $.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度$O ( nk ^2 n ) $.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度$O ( n k n ) $.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6>
<p>自然的设计是$f _{ i , j , k } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个,已经打了\)</span>j <span class="math inline">\(个,末尾有连续\)</span>k
$个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为$f <em>{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个,目前打了\)</span>j <span class="math inline">\(个且第\)</span>i <span class="math inline">\(个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成\)</span>f
</em>{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个,目前有\)</span>j <span class="math inline">\(个没打中而且第\)</span>i
$个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:$dp <em>{ i , j } = { dp </em>{ k , j -
1 } + <em>{ l = k + 1 } ^{ i - 1 } C </em>{ l - k } A _l + P } $.</p>
<p>令$w ( l , r ) = <em>{ k = l + 1 } ^{ r - 1 } C </em>{ k - l } A _k +
P <span class="math inline">\(,接下来我们证明:\)</span>w ( l + 1 , r ) +
w ( l , r - 1 ) w ( l , r ) + w ( l + 1 , r - 1 ) <span class="math inline">\(即可.讨论一下每个\)</span>A
$面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5>
<p>引理:在状态转移方程$f <em>{ i , j } = </em>{ i k &lt; j } { f <em>{ i
, k } + f </em>{ k + 1 , j } + w ( i , j ) } <span class="math inline">\(中(通常\)</span>f <em>{ i , i } = w ( i , i ) = 0
, f </em>{ i , i + 1 } = w _{ i , i + 1 } <span class="math inline">\(),如果\)</span>w <span class="math inline">\(满足四边形不等式和区间包含单调性,那么\)</span>f
$也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明$f <em>{ i , j } + f </em>{ i + 1 , j + 1 } f <em>{ i , j + 1
} + f </em>{ i + 1 , j } <span class="math inline">\(即可,考虑\)</span>j
- i = 1 $的时候,显然成立.</p>
<p>使用数学归纳,假设当$b - a &lt; k <span class="math inline">\(时,\)</span>f <span class="math inline">\(满足四边形不等式,考虑\)</span>j - i = k
$的情况:</p>
<p>设$f <em>{ i , j + 1 } <span class="math inline">\(的最优决策为\)</span>x <span class="math inline">\(,\)</span>f </em>{ i + 1 , j } <span class="math inline">\(的最优决策为\)</span>y $,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i , j + 1  } + f _{ i + 1 , j  } &amp; = f _{ i , x  } + f _{ x + 1
, j + 1  } + w ( i , j + 1 ) + f _{ i + 1 , y  } + f _{ y + 1 , j  } + w
( i + 1 , j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于$f <em>{ i , j } <span class="math inline">\(和\)</span>f </em>{
i + 1 , j + 1 } <span class="math inline">\(来说,\)</span>x <span class="math inline">\(和\)</span>y $不一定最优,所以有:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } &amp; \leq f _{ i , x  } + f _{ x
+ 1 , j  } + w ( i , j ) + f _{ i + 1 , y  } + f _{ y + 1 , j + 1  } + w
( i + 1 , j + 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>$w $和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } &amp; \leq f _{ i , j + 1  } + f
_{ i + 1 , j  } \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="定理">定理</span></h6>
<p>记$p <em>{ i , j } <span class="math inline">\(为\)</span>f </em>{ i
, j } <span class="math inline">\(的最优决策,若\)</span>f <span class="math inline">\(满足四边形不等式,那么对于\)</span>i &lt; j ， 有 p
<em>{ i , j - 1 } p </em>{ i , j } p _{ i + 1 , j } \ $.</p>
<p>证明:</p>
<p>记$p = p _{ i , j } <span class="math inline">\(,\)</span>k , i &lt;
k p <span class="math inline">\(,因为\)</span>f
$满足四边形不等式,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ i , k  } + f _{ i + 1 , p  } &amp; \leq f _{ i , p  } + f _{ i + 1
, k  } \\
f _{ i + 1 , p  } - f _{ i + 1 , j  } &amp; \leq f _{ i , p  } - f _{ i
, k  }
\end{aligned}
\]</span></p>
<p>根据$p $定义,有:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ i , p  } + f _{ p + 1 , j  } &amp; \leq f _{ i , k  } + f _{ k + 1
, j  } \\
f _{ i , p  } - f _{ i , k  } &amp; \leq f _{ k + 1 , j  } - f _{ p + 1
, j  }
\end{aligned}
\]</span></p>
<p>由上两式移项联立,得到:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i + 1 , p  } - f _{ i + 1 , k  } &amp; \leq f _{ k + 1 , j  } - f
_{ p + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } &amp; \leq f _{ i + 1 , k  } + f
_{ k + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } + w _{ i + 1 , j  } &amp; \leq f
_{ i + 1 , k  } + f _{ k + 1 , j  } + w _{ i + 1 , j  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>因此对于$f <em>{ i + 1 , j } <span class="math inline">\(,\)</span>p
<span class="math inline">\(比任意的\)</span>k &lt; p <span class="math inline">\(更优,因此\)</span>p </em>{ i + 1 , j } p _{ i , j
} $,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4>
<p>判断一个函数的凸性只需判断$f ( k ) + f ( k + 2 ) f ( k + 1 ) <span class="math inline">\(,而这只需证明\)</span>k <span class="math inline">\(的时候的答案和\)</span>k + 2 <span class="math inline">\(时的答案可以调整出两个\)</span>k + 1 <span class="math inline">\(的答案(不一定是最小答案)并且这两个\)</span>k + 1
<span class="math inline">\(的答案的和小于等于\)</span>k <span class="math inline">\(时和\)</span>k + 2 $时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5>
<p>首先考虑四个点$( a , b , c , d ) <span class="math inline">\(,注意到其一定满足四边形不等式,也就是\)</span>w
<em>{ ac } + w </em>{ bd } w <em>{ ad } + w </em>{ bc } $.</p>
<p>我们现在想证明,设$f <em>k <span class="math inline">\(为新增\)</span>k <span class="math inline">\(个传送机后的减少的答案,我们考虑证明\)</span>f
<em>k + f </em>{ k + 2 } f </em>{ k + 1 } $.</p>
<p>我们画出$f <em>k <span class="math inline">\(时选的点和\)</span>f
</em>{ k + 2 } <span class="math inline">\(时选的点,注意到我们可以用这两次调整出两个\)</span>k
+ 1 <span class="math inline">\(的答案,并且这两个答案的和小于等于\)</span>f <em>k
+ f </em>{ k + 2 } <span class="math inline">\(,于是证明了最小的\)</span>f _{ k + 1 }
$是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量$w <span class="math inline">\(,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于\)</span>w
$的最大的传送机数量,然后就可以做了.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能基础</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="常用激活函数">常用激活函数</span></h3>
<h4><span id="sigmoid函数">Sigmoid函数</span></h4>
<p>$f ( x ) = { 1 + e ^{ - x } } : ( - , + ) ( 0 , 1 ) $.</p>
<p>$f ’ ( x ) = f ( x ) ( 1 - f ( x ) ) $.</p>
<h4><span id="tanh函数">tanh函数</span></h4>
<p>$f ( x ) = { e ^x + e ^{ - x } } : ( - , + ) ( - 1 , 1 ) $.</p>
<p>$f ’ ( x ) = 1 - f ^2 ( x ) $.</p>
<h4><span id="relu函数">ReLU函数</span></h4>
<p>$f ( x ) = ( 0 , x ) : ( - , + ) ( 0 , + ) $.</p>
<h4><span id="leaky-relu函数">Leaky ReLU函数</span></h4>
<p>$f ( x ) = ( x , x ) , 0 &lt; &lt; 1 : ( - , + ) ( - , + ) $.</p>
<h4><span id="softmax函数">Softmax函数</span></h4>
<p>$f ( x _i ) = { _j e ^{ x _j } } $.</p>
<h3><span id="损失函数">损失函数</span></h3>
<h4><span id="least-square">Least Square</span></h4>
<p>即$_{ i = 1 } ^n ( f ( x _i ) - y _i ) ^2 = ( A - Y A - Y ) <span class="math inline">\(.用最小二乘法取\)</span>= ( A ^T A ) ^{ - 1 } A ^T
Y $.</p>
<h4><span id="cross-entropy">Cross Entropy</span></h4>
<p>用错误的分布$q <span class="math inline">\(来表示真实分布\)</span>p
$的样本,则平均编码长度应该是:</p>
<p><span class="math display">\[
H ( p , q ) = \sum _i p ( i ) \log ( \frac { 1  } { q ( i )  } ) = -
\sum _i p ( i ) \log { q ( i )  }
\]</span></p>
<p>此为交叉熵.</p>
<p>特别地,当最终样本只有两个的时候,例如Logistical
Regression问题,可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
H &amp; = - ( y \log a + ( 1 - y ) \log ( 1 - a ) ) \\
\frac { \partial H  } { \partial a  } &amp; = - ( \frac { y  } { a  } -
\frac { 1 - y  } { 1 - a  } )
\end{aligned}
\]</span></p>
<p>那如果有多个呢?考虑直接对归一化条件作偏导,先有:</p>
<p><span class="math display">\[
\begin{aligned}
H ( p , q ) &amp; = - \sum _i p _i ( \log { q _i  } - \log ( \sum _j q
_j ) ) \\
\frac { \partial H ( p , q )  } { \partial q _k  } &amp; = - \frac { p
_k  } { q _k  } + \frac { \sum p _k  } { \sum _j q _j  } \\
&amp; = - \frac { p _k  } { q _k  } + 1
\end{aligned}
\]</span></p>
<p>再乘以softmax那里的$q _k <span class="math inline">\(,得到\)</span>-
p _k + q _k = - y _k + f ( x _k ) $.</p>
<h3><span id="神经网络实现">神经网络实现</span></h3>
<p>通过若干隐藏层,假设最后的输出层为第$L $层,则:</p>
<ol type="1">
<li><p>对于第$l <span class="math inline">\(层,取\)</span> _l = ( W
<em>l ) ^t </em>{ l - 1 } + _l <span class="math inline">\(.这里对\)</span>W _l
$作转置的目的是写代码的时候需要用行向量.</p></li>
<li><p>对于第$l <span class="math inline">\(层,取\)</span> _l = f ( _l )
<span class="math inline">\(,这里意味着将每一个分量对\)</span>f
$操作.</p></li>
<li><p>对于最终答案,取误差$ = { m } ( - _L - _L ) $.</p></li>
</ol>
<h4><span id="梯度下降法">梯度下降法</span></h4>
<p>换言之就是让$w : = w - { w } <span class="math inline">\(,其中\)</span><span class="math inline">\(是一个选定的小常数,也可以采用类似模拟退火的方式动态决定.事实上可以把各个位置分开,写作\)</span>w
_j : = w _j - { w _j } $.</p>
<p>另外,虽然是这么写,应当见到去掉下标$k <span class="math inline">\(的记号仍然合理,无非是逐分量做此操作,因此下面如无特殊说明,运算均采用逐分量运算.例如可以定义\)</span>
<span class="math inline">\(为两个向量逐分量相乘后得到的新向量,为表区分用\)</span><span class="math inline">\(表示正常的矩阵乘法.甚至采取\)</span>( - ) ^2 <span class="math inline">\(表示其自点积.坦白而言,笔者对此符号相当无奈,可也想不出什么更好的写法了.但总之这种写法总是强于部分参考资料上所将下标放上面的写作\)</span>a
^L
$的做法.笔者所能维持的精神数院人的唯一做法也只能是在下面加上向量符号,藉此泄愤.</p>
<p>顺便一提,应当见到$<span class="math inline">\(和\)</span><span class="math inline">\(这两种运算比较随意,用线性映射来理解,你这个\)</span>W
$任意作用在一个向量上就行.</p>
<h4><span id="误差反向传播">误差反向传播</span></h4>
<p>既然要用梯度下降法,就应该把每一层的偏导都求出来.然而$
$是最后一层的结果,因此应该用链式法则一路求出前面的偏导.</p>
<p>更具体地,不妨设误差函数选的是$( - ) ^2 $,激活函数选的是cross
entropy有:</p>
<ol type="1">
<li><p>$ { <em>{ L } } = ( </em>{ L } - )
$.(如若选择不同的误差函数,这里作适当变化)</p></li>
<li><p>$ { <em>{ l } } = f ’ ( </em>{ l } ) = <em>{ l } ( 1 - </em>{ l }
) $.(如若选取不同的激活函数,这里作适当变化)</p></li>
<li><p>$ { <em>{ l } } = { </em>{ l } } { <em>{ l } } = ( W </em>{ l + 1
} ) ^t ( _l ( 1 - _l ) ) $.</p></li>
<li><p>$ { W <em>{ l } } = ( </em>{ l - 1 } ) <span class="math inline">\(.结果理应是一个矩阵,其实就是这个列向量不断复制若干遍,或者写成\)</span>(
_{ l - 1 } ) ^t M ( 1 ) <span class="math inline">\(,其中\)</span>M ( 1
) $是全$1 $矩阵.</p></li>
<li><p>$ { _{ l } } = 1 $.</p></li>
</ol>
<p>我们应当见到:</p>
<p>不妨设$_l = { _l } $.见到:</p>
<ol type="1">
<li><p>$_L = { <em>L } = { <em>L } { <em>L } = ( </em>{ L } - ) </em>{ L
} ( 1 - </em>{ L } )
$.前者会因为误差函数的选取而改变,后者会因为激活函数的选取而改变.</p></li>
<li><p>$<em>l = { <em>l } = </em>{ l + 1 } { <em>l } = </em>{ l + 1 } (
W </em>{ l + 1 } ) ^t ( <em>{ l } ( 1 - </em>{ l } ) ) $.</p></li>
<li><p>$ { W <em>{ l } } = { </em>{ l } } { W _{ l } } = <em>l a </em>{
l - 1 } ^t $.</p></li>
<li><p>$ { _l } = _l $.</p></li>
</ol>
<p>如此以上更新即可.</p>
<h3><span id="卷积神经网络cnn">卷积神经网络(CNN)</span></h3>
<p>神经网络受矩阵乘法的限制,导致对于真实的尺寸巨大的图像难以快速识别,因此产生了卷积神经网络的概念,大概有以下特征:</p>
<ol type="1">
<li><p>空间上权值共享:不同位置使用同一个卷积核(滤波器)</p></li>
<li><p>稀疏链接:每一层只链接前一层的感受野.</p></li>
<li><p>等变表示:卷积神经网络有某种平移不变性.</p></li>
</ol>
<p>对于2D卷积,其公式如下:</p>
<p><span class="math display">\[
S _{ r , c  } = ( X * W ) _{ r , c  } = \sum _i \sum _j X _{ r + i , c +
j  } \times w _{ i , j  }
\]</span></p>
<p>其中$W <span class="math inline">\(是卷积核,\)</span>X <span class="math inline">\(是输入图像,\)</span>S
$是输出的结果.如果一个图像有多个通道(比如色彩层之类的),每个通道上都需要应用一个卷积核.</p>
<p>下面引入一些名词:</p>
<ol type="1">
<li><p>input size:输入图像的尺寸.</p></li>
<li><p>padding:填充的像素数.</p></li>
<li><p>filter size:卷积核的尺寸.有时也写作两个变量:filter height和filter
width.3D卷积还会有一个filter depth的变量.</p></li>
<li><p>stride:步长.</p></li>
<li><p>output size:卷积后输出的尺寸.有时也写作feature size.</p></li>
<li><p>input channels:输入图像的通道数.</p></li>
<li><p>n filters:卷积核的数量.</p></li>
<li><p>dilation rate:膨胀率,用于空洞卷积.膨胀率为$d <span class="math inline">\(的时候,卷积核中间会插入\)</span>d - 1 $个$0
$间隔.</p></li>
</ol>
<h4><span id="感受野计算">感受野计算</span></h4>
<p>先看output
size的计算,容易见到,其各个维度方面计算是独立的.只要对于单个维度算出卷积核在上面移动的次数,最后将不同维度相乘即可.</p>
<p>对于单个维度,这个维度的移动次数应该是:</p>
$$
<span class="math display">\[\begin{aligned}
\text { output \_ size  } &amp; = \lceil \frac { \text { input \_
size  } + 2 \times \text { padding  } - \text { filter \_ size  } + 1  }
{ \text { stride  }  } \rceil \\
&amp; = \lfloor \frac { \text { input \_ size  } + 2 \times \text {
padding  } - \text { filter \_ size  }  } { \text { stride  }  } \rfloor
+ 1 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式相当容易理解,原因是$ = 1 <span class="math inline">\(的时候,上面恰好是移动的次数,而\)</span>
$变化的时候,当然要拿到一个上取整.</p>
<p>至于所谓的空洞卷积,只需在上面的基础上改$ $就好.</p>
<p>至于乘法操作,每得到一个$ <span class="math inline">\(当然都会需要\)</span> $次乘法操作.</p>
<p>再看感受野的计算,不妨设$S <em>i <span class="math inline">\(为前\)</span>i <span class="math inline">\(次卷积的\)</span> <span class="math inline">\(的乘积,设\)</span>k </em>{ i + 1 } <span class="math inline">\(表示第\)</span>i + 1 <span class="math inline">\(层的\)</span> $,则:</p>
<p><span class="math display">\[
RF _{ i + 1  } = RF _i + ( k _{ i + 1  } - 1 ) \times S _i
\]</span></p>
<p>这个公式的含义大概是每次先看对应了多大的原数据上的范围,再把原本的边界$RF
_i $给补上.</p>
<h4><span id="池化pooling">池化(Pooling)</span></h4>
<p>池化操作它没有一个可学习的参数,只是对输入数据进行固定的操作.简单来说就是降低输入的规模,以实现更好的鲁棒性以及提高效率.</p>
<p>常见的池化操作包括:</p>
<ol type="1">
<li><p>MaxPooling:取区域内的最大值.</p></li>
<li><p>MeanPooling:取区域内的平均值.</p></li>
<li><p>PyramidPooling:多次进行尺度不同的池化.</p></li>
</ol>
<h4><span id="常见卷积架构">常见卷积架构</span></h4>
<h5><span id="alexnet">AlexNet</span></h5>
<p>首次引入ReLU激活函数,Dropout
技术,以及数据增强,提高了模型的训练效率和泛化能力.</p>
<p>采用了$8 $层深的网络结构,证明了深度网络的潜力.</p>
<h5><span id="vgg">VGG</span></h5>
<p>开始堆叠小尺寸的卷积核,获得与大卷积核相似的感受野的同时可以增加网络深度.</p>
<h5><span id="resnet">ResNet</span></h5>
<p>引入残差的概念,直接将输入数据累加(跳跃连接)到最后的输出中,这样网络学习的实际上是输入和输出之间的残差,从而提高了网络学习能力.</p>
<h5><span id="squeezenet">SqueezeNet</span></h5>
<p>SqueezeNet的基本构建单元是Fire模块.Fire模块由一个squeeze层和一个expand层组成.squeeze层使用$1
$卷积核减少通道数,而expand层则使用$1 $和$3
$卷积核增加通道数.这种设计有效地减少了参数数量和计算量.</p>
<h5><span id="mobilenet">MobileNet</span></h5>
<ol type="1">
<li><p>深度卷积:在这个操作中,每个输入通道独立地进行卷积,这意味着在进行卷积时,不同通道之间没有交互.这样可以减少计算量和参数数量.</p></li>
<li><p>逐点卷积:逐点卷积使用$1
$的卷积核,它作用在深度卷积的输出上,将不同通道的信息整合在一起.逐点卷积可以减少参数数量,同时保持较高的性能.</p></li>
</ol>
<h5><span id="shufflenet">ShuffleNet</span></h5>
<ol type="1">
<li><p>组卷积(Group
Convolution):将通道分成几个组,并使用不同的卷积神经网络层执行标准卷积.</p></li>
<li><p>打乱层(Shuffle
layer):通过对通道进行洗牌,将不同组的信息合并.</p></li>
</ol>
<h5><span id="反卷积">反卷积</span></h5>
<p>也就是将较小的数据特征图扩大到较大的尺寸.有的时候也把这个操作说成上采样.</p>
<ol type="1">
<li><p>插值步骤(Interpolation
Step):首先,在输入特征图的元素之间插入零,增加特征图的尺寸.</p></li>
<li><p>卷积步骤(Convolution
Step):接下来,对扩大后的特征图应用一个标准的卷积操作.此步骤相当于在扩大的特征图上滑动卷积核,计算卷积输出.</p></li>
</ol>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中的线性代数</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#oi中的线性代数">OI中的线性代数</a>
<ul>
<li><a href="#线性基">线性基</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan
and Burgers)</a></li>
<li><a href="#example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337
[Ynoi2004] rsxc)</a></li>
<li><a href="#example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</a></li>
</ul></li>
<li><a href="#杂题">杂题</a>
<ul>
<li><a href="#example1cf1270ixor-on-figures">Example1([CF1270I]Xor on
Figures)</a></li>
<li><a href="#example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing
Finals)</a></li>
</ul></li>
<li><a href="#逆矩阵求解线性方程组">逆矩阵求解线性方程组</a>
<ul>
<li><a href="#example1codeforces-cf1266h-red-blue-graph">Example1(codeforces
CF1266H Red-Blue Graph)</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="oi中的线性代数">OI中的线性代数</span></h3>
<h4><span id="线性基">线性基</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定$n <span class="math inline">\(个非平方因子数\)</span>a _i <span class="math inline">\(,求有多少种选取一个子集的方式满足每个质因子都在子集中恰好出现偶数次.\)</span>n
^5 , a _i ^6 $.</p>
<p>考虑将每个数的质因子压成一个二进制数,那所求也就是问有多少种选取子集的方式使得子集内二进制数异或和为$0
$.自然想到线性基.$2 $的自由变量的数量次幂即答案.</p>
<p>但是直接做线性基不太对,因为质数级别是$10 ^6
$.我们冷静一下,把一个数中大于$1000
$的质因子拿出来,显然只会有一个.把所有数字根据这个质因子分类,那么显然一个组内必能插入一个数(作为这个质因子的主元),而其他数也必要异或上这个数,而异或后就只有小于等于$1000
$的质因子了,这种质因子只有不到$200 $个,可以拿bitset优化一下.</p>
<p>复杂度$O ( { w } ) $.</p>
<h5><span id="example2cf1100fivan-andburgers">Example2([CF1100F]Ivan and
Burgers)</span></h5>
<p>考虑扫描线,这样我们需要解决如何询问一段后缀$[ l , n ]
$的答案,以及如何根据上一个位置的后缀推出这一个位置的后缀.</p>
<p>考虑有一个暴力是直接把每个后缀的线性基建出来:注意在此过程中,能放到高位的数字一定出现地尽可能靠后,因为它一早就被放进来了.而只要满足这个条件,也就是能放高位的一定尽量放高位,并且高位出现时间要尽可能晚,那我们自然就得到了此时的线性基,删去那些出现太靠前的数字就行.</p>
<p>但有没有什么直接一点的理解方式呢?一个直觉是,我们现在要把出现时间太早的给删了,那肯定想要让高位出现时间尽可能晚.但是这样会有两个问题:</p>
<ol type="1">
<li><p>可能$l
$较小但是没那么小,高位即使不顶替,也会被选上,但是顶替了高位就无法顶替一个将被删除的低位.</p></li>
<li><p>由于线性基并非最简线性基,我们最后的答案有可能不会将某一位异或进答案,那此时尽量最优化它是不优秀的.</p></li>
<li><p>线性基中的元素不能受到非线性基中的元素的影响,我们删除一位的时候,这一位有可能在之前影响了比它低的一些位置.</p></li>
</ol>
<p>来一个一个解决.</p>
<p>(3)是最好解决的.对于因为出现时间太早而导致的删除来说,因为如果一个位置被高位影响了,根据我们的构造过程,这个位置出现时间必然不会晚于那个高位,高位都被删了,那这个位置也会被删.</p>
<p>对于因为被其他人而取代导致的删除来说,因为它被删了,因此它一定可以表示为其它线性基底的异或,因此有影响也无所谓.</p>
<p>再来看(1),考虑我们当前插入的数字是$v <span class="math inline">\(,如果\)</span>v <span class="math inline">\(本来就会被加入线性基,那它扔到高位,然后替换下来的那个数字也不可能被删除,一定会延续到低位.如果\)</span>v
<span class="math inline">\(本来不会被加入,必然因为有一些基底的异或值是\)</span>v
<span class="math inline">\(,那么把\)</span>v
$加入后,一路到最后,被删除的那个基底必然是出现时间最早的那个菜逼,删了就是了.</p>
<p>接下来是(2),考虑上面这个过程完全不耽误你把它变成最简线性基,最简线性基就没这个问题了.</p>
<p>当然这题还可以分治,注意到用线段树直接合并区间的线性基的复杂度达到了$^3
<span class="math inline">\(,但是如果我们用猫树的结构但是不必要在线,复杂度降到了\)</span>^2
$.</p>
<h5><span id="example3luogup8337-ynoi2004rsxc">Example3(luoguP8337 [Ynoi2004]
rsxc)</span></h5>
<p>注意到区间数字种类个数一定是二的整数次幂,假设为$2 ^k <span class="math inline">\(,先枚举\)</span>k $.</p>
<p>首先根据CF1100F,我们可以离线找出区间的线性基,这意味着区间不同整数个数是否是$2
^k $.</p>
<p>做完这两步之后呢?我们接下来需要求和.这里注意到随着扫描线的进行,左端点可能合法的区间左右端点均单调不降,我们对着二维坐标系做一个差分(就是把一条直线延伸到$y
= x <span class="math inline">\(这条直线上),于是可以\)</span>O ( 1 )
$求和.</p>
<p>这里详细解释一下上面的那个套路:当我们插入一个数字的时候,每当遇到了一个此位置是$1
$的出现次数早于该数字的数字,我们就交换它们.为啥这样是对的呢?首先如果插入的这个数字并不能被其他数字所表示,那无论怎么交换都不会有影响.而如果可以,那一定会与所有参与表示的数字都交换一次.注意到每次交换等价于找到两者中出现较早的那个,所以最后一定会删去出现最早的数字.</p>
<h5><span id="example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</span></h5>
<p>用一下构造能力不难发现,每个点的取值是它前面的数能表示出的所有数(也就是线性基)异或上他自己.</p>
<p>我们考虑从左往右加线性基(并保存旧的版本),每次如果一个数并不能更新线性基,说明这个数字能取的取值范围就是到它的线性基中的所有数字.进一步地,你注意到它的取值范围一定包括了它前面的所有数字,这个同样可以通过线性基的性质来得到.</p>
<p>注意到难点在于那些加入后更新线性基的点,称它们为关键点,这样的关键点最多$V
$个.所以我们可以暴力讨论它们的存在.而那些普通的点显然分成了若干个段,每段的取值是相等的.我们可以按照线性基的顺序走.如果我们必须要在关键点和其它的点中挑一个删了,显然我们要删关键点,因为其他的点能很完美地接上,但是关键点可不一定能接上.</p>
<p>也就是说对于一个非关键点,能选则一定要选.因此我们直接从后往前dp,如果遇到关键点的话讨论一下它选不选,遇到非关键点一定要选,如果选不了就更新答案.</p>
<p>我们不妨设计一个dp,设$f _{ i , j } <span class="math inline">\(表示从\)</span>n <span class="math inline">\(走到第\)</span>i <span class="math inline">\(个数字,中间取了\)</span>j <span class="math inline">\(个关键点,\)</span>a _i
$的最大值是多少.这样问题转化为:</p>
<ol type="1">
<li><p>对于一个数字$X $,找到线性基中最大的小于它的数字.</p></li>
<li><p>对于一个数字$X <span class="math inline">\(,将它与线性基中若干基底异或得到\)</span>X ’ <span class="math inline">\(,使得\)</span>X ’ &lt; Y <span class="math inline">\(并且\)</span>X ’ $尽可能大.</p></li>
</ol>
<p>不难发现第一个问题就是第二个问题中的$X = 0 , Y = X
$的情况.用最简线性基算排名可以轻松解决上面的问题.</p>
<h4><span id="杂题">杂题</span></h4>
<h5><span id="example1cf1270ixor-onfigures">Example1([CF1270I]Xor on
Figures)</span></h5>
<p>首先我们发现,它的平移操作和矩阵很相似,我们考虑将操作写成矩阵形式.</p>
<p>具体地,我们定义新的矩阵乘法为:$A B = C <span class="math inline">\(,其中\)</span>C <em>{ x , y } = </em>{ i = 0 } ^{
2 ^k - 1 } <em>{ j = 0 } ^{ 2 ^k - 1 } A </em>{ i , j } B _{ ( x - i )
^k , ( y - j ) ^k } $.</p>
<p>定义矩阵$F <span class="math inline">\(:\)</span>F _{ x _i , y _i } =
1 , 1 i t $,其他位置均为$0 <span class="math inline">\(.不难发现每次操作无非是将\)</span>F <span class="math inline">\(乘上一个只有\)</span>( X , Y ) <span class="math inline">\(位置是\)</span>w $,其余位置都是$0 <span class="math inline">\(的矩阵然后异或到\)</span>A <span class="math inline">\(上.我们发现这些操作也可以压缩成一个矩阵.这样问题就转化为:我们已知\)</span>F
$,求$0 <span class="math inline">\(的位置尽可能多的矩阵\)</span>C <span class="math inline">\(,满足\)</span>F C = A $.</p>
<p>我们看到这个形式,发现它很优美,这个时候自然有一个猜想:$F
$在这种形式下是否存在逆矩阵呢?</p>
<p>注意到$F <span class="math inline">\(的值是异或运算下,和取膜有一定关系,我们再大胆猜测:\)</span>m
, F ^m = I <span class="math inline">\(,其中\)</span>I _{ 0 , 0 } = 1
$,其他位置都是$0 <span class="math inline">\(.此时\)</span>F ^{ - 1 } =
F ^{ m - 1 } <span class="math inline">\(.打表可以发现\)</span>m = 2 ^k
$.</p>
<p>接下来我们只需要证明这个结论就行.其实也好证:注意到进行一次运算后,$F
_{ x _i , y <em>i } F </em>{ x _j , y <em>j } <span class="math inline">\(和\)</span>F </em>{ x _j , y <em>j } F </em>{ x _i
, y <em>i } <span class="math inline">\(都会更新到\)</span>F ^2 </em>{ x
_i + x _j , y _i + y <em>j } <span class="math inline">\(,因此他们俩互相抵消.这意味着\)</span>F ^2 <span class="math inline">\(中,只有\)</span>F ^2 </em>{ 2 x _i , 2 y _i }
$有可能非零.</p>
<p>进行$2 ^k $后,由于下标对$2 ^k <span class="math inline">\(取膜,容易发现这个时候只有\)</span>( 0 , 0 )
$有可能非零.而由于一共有奇数个$1 $,所以这里一定是$1 <span class="math inline">\(.得证.有\)</span>C = F ^{ 2 ^k - 1 } A $.</p>
<p>根据上面的证明过程不难发现,$F $的$2 <span class="math inline">\(的整次幂很好求,所以我们拆开幂,有\)</span>C = _{ i
= 0 } ^{ k - 1 } F ^{ 2 ^i } A <span class="math inline">\(.注意到\)</span>F <span class="math inline">\(很稀疏,最多只有\)</span>t <span class="math inline">\(个地方非零,所以做一次的复杂度是\)</span>O ( ( 2 ^k
) ^2 t ) <span class="math inline">\(,总复杂度\)</span>O ( kt 4 ^k )
$.</p>
<h5><span id="example2petrozavodskwinter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassingfinals">Example2([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing
Finals)</span></h5>
<p>给定一个$n n <span class="math inline">\(的矩阵,其中有\)</span>m
<span class="math inline">\(个位置(\)</span>m <span class="math inline">\()的数字缺失了.给定质数\)</span>P <span class="math inline">\(,现在要在这\)</span>m <span class="math inline">\(个位置上填上\)</span>[ 0 , p - 1 ] <span class="math inline">\(的数字,使得最后矩阵的行列式在\)</span>p <span class="math inline">\(意义下等于给定数字\)</span>C $,求任意一组方案,$1 n
$,$2 P ^9 $.</p>
<p>如果$m = 1 $,做代数余子式展开,显然如果这个位置对应的代数余子式为$0
$,那它填什么无所谓,随便填一个然后验证.不然,我们一定可以用逆元算出一个答案,使得满足条件.</p>
<p>同理,如果$m &gt; 1 <span class="math inline">\(,我们考虑随机\)</span>m - 1
$个位置并随机它们的值,然后验证.如果我们能找到一组随机满足剩下的那个位置对应的代数余子式非零就做完了.如果我们随机了若干次,还是没有找到,宣告无解.</p>
<h4><span id="逆矩阵求解线性方程组">逆矩阵求解线性方程组</span></h4>
<p>如果我们已知线性方程组的系数矩阵,但是多次询问,每次会给出不同的常数项,我们可以使用下文中提到的逆矩阵来求解.</p>
<h5><span id="example1codeforcescf1266h-red-blue-graph">Example1(codeforces
CF1266H Red-Blue Graph)</span></h5>
<p>如果我们设$x _i <span class="math inline">\(表示每个点被经历过多少次.注意到一共有\)</span>n -
1 <span class="math inline">\(个方程以及\)</span>n - 1 <span class="math inline">\(个未知数,我们实际上是要根据\)</span>s <span class="math inline">\(和\)</span>v <span class="math inline">\(求出一组\)</span>x $然后判定合法,我们先写方程:</p>
<p><span class="math display">\[
\begin{aligned}
x _i - [ i &amp; = 1 ] \\
&amp; = \sum _{ e : j \rightarrow i \ is \ blue  } \frac { x _j - [ s _e
= red ] - [ j = v ]  } { 2  } \\
+ \sum _{ e : j \rightarrow i \ is \ red  } \frac { x _j + [ s _e = red
] - [ j = v ]  } { 2  }
\end{aligned}
\]</span></p>
<p>化简一下:</p>
<p><span class="math display">\[
2 x _i - \sum _{ j \rightarrow i  } x _j = - \sum _{ e : j \rightarrow i
\ is \ blue  } [ s _e = red ] + \sum _{ e : j \rightarrow i \ is \
red  } [ s _e = red ] - \sum _{ j \rightarrow i  } [ j = v ] + 2 [ i = 1
]
\]</span></p>
<p>注意到这是一个系数恒定且常数项不确定的矩阵,可以先矩阵求逆再做.</p>
<p>另外有一个问题是,怎么证明这个系数矩阵一定存在逆矩阵,不难注意到这是个基尔霍夫矩阵,显然$$为$0
$.</p>
<p>这也就是说,我们一定可以求出唯一一组解.我们要做的只是判定它是否合法.</p>
<p>先通过数学归纳等方法证明一组满足流量平衡以及以下条件的$x , s , v
$一定合法:</p>
<p>对于任意一个点,都存在一条只经过激活边的路径到达最终点.</p>
<p>首先充分性,如果满足这个条件,我们只要不断地退流就可以得到一组一定合法的答案.</p>
<p>然后必要性,如果存在一个点没有这条路径,那这个点也必然不可能被回溯到,自然不可能出现一组解.</p>
<p>这题关键在于发现流量平衡这个等价条件,然后知道我们可以求出一组状态,并只需要判定状态是否合法,找判定条件.</p>
<p>然后写分数的人被卡常了,泪目.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中的常见套路</title>
    <url>/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="本质相同">本质相同</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>对于所有满足以下条件的长度为$n <span class="math inline">\(的序列\)</span>{ a } $,我们称它是好的:</p>
<p><span class="math display">\[
\begin{aligned}
a _1 &amp; = 1 \\
\forall 2 &amp; \leq i &amp; \leq n , a _i &amp; \leq \max \{ a _1 ,
\cdots , a _{ i - 1  } \} + 1
\end{aligned}
\]</span></p>
<p>对于每一个数$1 x n $,求它在每个好的序列中出现的次数的平方和.其中$1 n
$,任意模数.</p>
<p>首先注意到可以枚举每个数$x <span class="math inline">\(出现的次数,这样就转化为对满足某些位置是\)</span>x
$的好的序列计数.</p>
<p>对于一个没有限制的好的序列,设$f _{ i , j } <span class="math inline">\(表示\)</span>[ 1 , i ] <span class="math inline">\(中填了\)</span>[ 1 , j ] <span class="math inline">\((其中\)</span>j
$必填)的方案数,不难发现这就是第二类斯特林数.</p>
<p>这样,对于一个$x <span class="math inline">\(,我们可以枚举它第一次出现的位置以及出现的次数,以及它第一次出现的位置后面的大于等于它的数的数量,合并即可.复杂度\)</span>O
( n ^4 ) $.</p>
<p>再思考一下,似乎我们不用枚举它出现的次数,而是可以直接用$g _{ i , j , 0
/ 1 / 2 } <span class="math inline">\(表示在\)</span>[ 1 , i ] <span class="math inline">\(中填\)</span>[ 1 , j ] $,$1 <span class="math inline">\(出现次数的平方和.同样枚举后面有多少大于等于它的位置,然后就可以把这些位置抽出来作为一个子序列,这个子序列就可以认为\)</span>x
$就是$1 <span class="math inline">\(.复杂度\)</span>O ( n ^3 ) $.</p>
<p>如果写出上面的式子的话,会发现最难处理的是一个形如$x ^k <span class="math inline">\(的项,表示\)</span>x
$第一次出现的位置后面仍然选比它小的数字的位置的方案数.这个怎么办呢?自然的想法是想在dp中顺便把它算了.</p>
<p>再进一步想,我们之所以合并麻烦,是因为取了两段上升区间.如果我们能求出一个上升区间和一个下降区间,在交点处合并呢?</p>
<p>但是这样怎么统计平方和呢?我们发现如果在$[ 1 , k ] <span class="math inline">\(中选了\)</span>[ 1 , i ] <span class="math inline">\(,那么\)</span>[ 1 , i ] <span class="math inline">\(在\)</span>[ k + 1 , n ]
$中是本质完全相同的,因此还是可以用上面的dp求.</p>
<h3><span id="排列转环">排列转环</span></h3>
<h5><span id="example1p8416">Example1(P8416)</span></h5>
<p>这题牛逼.</p>
<p>首先考虑一维的情况,一维情况下最劣应该是$2 , 3 , . . . , n , 1
$这样的.</p>
<p>为啥捏?因为注意到操作数$= n - $排列环数,这样的排列环数为$1 <span class="math inline">\(,显然是最小的.加上列也差不多,所以\)</span>k _0 = 2
n ( n - 1 ) = 2 n ^2 - 2 n $.</p>
<p>而我们显然可以通过两次操作把一个位置归位,最后剩一行再随便做做,这样的答案就是$2
n ^2 - n + 1 <span class="math inline">\(,如果我们想赢,那就需要在上面的\)</span>n - 1
$行每行省出一步操作.</p>
<p>这咋做呢?类似上面的做法,也考虑找环然后省一步,对于一行,我们找到所有应该放在这里的值以及它们所在的列,把它们应该在的列和实际在的列连边,一定能找到至少一个环(自环也算),删环就可以省一步操作.</p>
<h5><span id="example2">Example2</span></h5>
<p>给序列$a <span class="math inline">\(和排列\)</span>b
$,有若干次操作:</p>
<ol type="1">
<li><p>修改操作:给定$x , y <span class="math inline">\(,将\)</span>a _x
<span class="math inline">\(改为\)</span>y $.</p></li>
<li><p>查询操作:给定$l , r , x <span class="math inline">\(,查区间\)</span>[ l , r ] <span class="math inline">\(内最长的子区间\)</span>[ l ’ , r ’ ] <span class="math inline">\(,使得对\)</span>l ’ i &lt; r ’ <span class="math inline">\(,有\)</span>a <em>{ i + 1 } = b </em>{ a _i }
<span class="math inline">\(,且存在\)</span>l ’ i r ’ <span class="math inline">\(使得\)</span>a _i = x
$.需要输出满足条件的子区间的长度最大值.</p></li>
</ol>
<p>一步一步来,首先处理出所有的极长的满足条件的段,不难发现修改一个点只会断掉一个段或者连接两个段,影响是$O
( 1 ) $的.</p>
<p>难点在于,我们如何处理要求其中存在一个$x $这种东西.</p>
<p>注意到$b <span class="math inline">\(是排列,上置换,不难发现\)</span>b
<span class="math inline">\(其实就是一个置换,也就是说每一个极长的段一定是一个置换环内部的元素,我们可以快速定位到\)</span>x
$所在的置换环.但这样还是不能做.</p>
<p>考虑由于是单点查询$x
$,我们可以直接将数组也做置换,这样一个置换环就在一个区间内部,意味着一个极长的段一定是一个区间或者两个区间(原区间的一段前缀和一段后缀).</p>
<p>现在对于区间查询,我们考虑特殊处理和端点相交的段,这个是平凡的.这样我们只需要处理出完全被区间包含的那些段该怎么做.把右端点缩一缩,就等价于左端点完全被区间包含的那些点.也就是以$a
<span class="math inline">\(为横坐标,\)</span>l <span class="math inline">\(为纵坐标,这样这些就相当于对一条横线取\)</span><span class="math inline">\(,然后查询一段竖着的线段的最大值.注意到一行不可能有两个横线,因此可以线段树分治+线段树维护,复杂度\)</span>O
( n ^2 n ) $.</p>
<h3><span id="规定转移顺序">规定转移顺序</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一张$n <span class="math inline">\(个点的图,每个点有一个\)</span>[ 1 , k ]
$的颜色,求这张图有多少个子图是一棵树并且在这棵树中每种颜色恰好出现了一次.</p>
<p>首先无根树转有根树计数,设$dp _{ i , S } <span class="math inline">\(表示以\)</span>i <span class="math inline">\(为根,已经选了\)</span>S <span class="math inline">\(集合中的颜色的方案数.转移的时候枚举出边(注意可能会算重,只要是会算重的都考虑钦定某种颜色在其中一个块里),复杂度\)</span>O
( m 3 ^k ) $.</p>
<p>冷静一下,想到斯坦纳树,于是再设一个$g _{ x , S } <span class="math inline">\(表示以\)</span>x <span class="math inline">\(为根且\)</span>x <span class="math inline">\(只有一个儿子,\)</span>S
$的定义类似的方案数.这样我们就可以用斯坦纳树的换根技巧计数.很厉害.</p>
<p>这个故事告诉我们:对于图论计数问题(尤其是和树有关),$m <span class="math inline">\(大概率可以转化为\)</span>n
$,但是需要一些小技巧(例如斯坦纳树)</p>
<h5><span id="example2p7142">Example2(P7142)</span></h5>
<p>类似宝藏那个题,我们考虑设$f _{ d , S _1 , S _2 } <span class="math inline">\(表示\)</span>S _1 $中的点到$1 <span class="math inline">\(的距离\)</span>&lt; d <span class="math inline">\(,\)</span>S _2 $中的点到$1 <span class="math inline">\(的距离\)</span>= d $.然后枚举到$1 <span class="math inline">\(的距离\)</span>= d + 1 <span class="math inline">\(的点集,这一部分复杂度是\)</span>O ( n 3 ^n )
$,预处理一下不同情况的答案即可.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<p>大概是如果多组询问那复杂度是错误的,但是如果我全局求,那我$$起来的总复杂度大概是对的.经典问题是树上背包.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定一颗二叉树,求对于每一个$x <span class="math inline">\(,满足\)</span>x , y , z <span class="math inline">\(互不相同的三元组\)</span>( x , y , z ) <span class="math inline">\(的价值(定义为两两距离之和对\)</span>L <span class="math inline">\(取膜)的最大值是多少.\)</span>n $.</p>
<p>乍一看,二叉树,想到换根后做dsu on tree+set.但是$O ( n ^2 ^2 n ) <span class="math inline">\(实在是跑不过去.冷静一下,除去三点共线的情况,考虑三个点在二叉树上的两两LCA一定只有两个点,枚举其中深度较浅的那个点并枚举其子树中的两个点和子树外的一个点.假设其子树内有\)</span>x
<span class="math inline">\(个点对,子树外有\)</span>y <span class="math inline">\(个点,注意到\)</span>x = n ^2 y n ^2 <span class="math inline">\(,于是总复杂度\)</span>O ( n ^2 n ) $.</p>
<h3><span id="字典序相关">字典序相关</span></h3>
<p>题目中询问满足条件的字典序第$k
$小之类的问题,通常采用转化为计数问题.</p>
<h5><span id="example12022noip十连测day88ady">Example1([2022noip十连测day8]8ady)</span></h5>
<p>首先,我们肯定想如果知道$a <span class="math inline">\(,我们怎么求出\)</span>b $.</p>
<p>首先不难发现,我们可以这么还原:先开一个堆,然后先将前$m - 1 <span class="math inline">\(个位置扔进堆里,从第\)</span>m <span class="math inline">\(个位置开始,假设现在到了第\)</span>i <span class="math inline">\(个位置\)</span>( m i n ) <span class="math inline">\(,每次将\)</span>a _i <span class="math inline">\(扔进堆里,并从堆中取最小元素扔到\)</span>i - m + 1
$位置,最后把堆清空到剩下的位置即可.</p>
<p>大量实验证明:这种反向构造思路,你用个堆通常是做不动的.</p>
<p>我们考虑有没有别的做法.</p>
<p>一个一个数地考虑,$b _1 <span class="math inline">\(在\)</span>a <span class="math inline">\(中的位置应该在哪?显然是应该在\)</span>[ 1 , m ]
<span class="math inline">\(中,而且根据上面的堆的做法,显然它应该是\)</span>[ 1
, m ] <span class="math inline">\(中最小的数字,换句话说,我们需要满足:\)</span>[ 1 ,
m ] $中除它以外的数字都比它大.</p>
<p>我们继续考虑$b _2 <span class="math inline">\(,显然它在\)</span>a
<span class="math inline">\(中应该在\)</span>[ 1 , m + 1 ] <span class="math inline">\(中,并且需要满足\)</span>[ 1 , m + 1 ] <span class="math inline">\(中的所有数字除了\)</span>b _1 $,都比它大.</p>
<p>以此类推.不难注意到对于一个数$b _i $,其中$1 i n - m + 1 <span class="math inline">\(,它能填回的原序列的位置一定最大最大是\)</span>[ 1
, m + i - 1 ] <span class="math inline">\(,并且如果它能填到区间\)</span>[ l , r ]
$中,这个区间中除去在它之前填进来的数字以外,均比它大.</p>
<p>但是,这显然是个上界.这个区间能不能缩小一下呢?</p>
<p>对于一个$i <span class="math inline">\(,我们找到最大的\)</span>j
$满足$1 j &lt; i <span class="math inline">\(并且\)</span>b _j &gt; b _i
$(有可能找不到).</p>
<p>冷静一下,显然,$b _i <span class="math inline">\(不能填到\)</span>[ 1
, j + m - 1 ] <span class="math inline">\(.(因为如果它扔在这里,那它就:在\)</span>j <span class="math inline">\(出堆前入堆,在\)</span>j
$出堆后出堆,显然不合法)</p>
<p>也就是说,我们将每个数能填的区间缩小为了$[ j + m , i + m - 1 ] $.</p>
<p>那是不是说每个数只要填在这个区间中,就一定合法呢?</p>
<p>我们考虑一个数$i <span class="math inline">\(以及所有比它小且在它后面的数字\)</span>j <span class="math inline">\(,当\)</span>j = i + 1 <span class="math inline">\(时,显然\)</span>j <span class="math inline">\(只有一种选择,直接填上;当\)</span>j = i + 2 <span class="math inline">\(时,若\)</span>i + 1 <span class="math inline">\(已经选择好了,那\)</span>j <span class="math inline">\(显然也只有一种选择,填上.这样,对于所有\)</span>i
$,如果它前面有一个大于它的数字,那它一定只有一个位置可以填.</p>
<p>这样我们就可以简化为:给定$b <span class="math inline">\(数组单调递增的问题.不难发现该条件下\)</span>i
<span class="math inline">\(可以选择的区间是\)</span>[ 1 , i + m - 1 ]
$,且满足条件一定有解.</p>
<p>冷静一下,这个时候假设新序列长度为$len <span class="math inline">\(,那显然一共有\)</span>m ^{ len } <span class="math inline">\(个满足条件的\)</span>a
$序列.注意到这个级别是指数级别.</p>
<p>所以前面一定是按顺序填,直到后面才会打乱顺序.而后面的长度大概也就是个$_m
k $,枚举枚举就行.</p>
<h3><span id="前缀和与差分">前缀和与差分</span></h3>
<h5><span id="example1loj3266">Example1(loj3266)</span></h5>
<p>把点都扔到坐标系上,显然到一个点曼哈顿距离相等的数一定在一个正方形(对角线平行于坐标轴)上.</p>
<p>我们考虑如果已知两个点,怎么找第三个点的坐标,显然是两个正方形的边界的交点,那也就是说,曼哈顿距离下,一个等边三角形必定有两个点所在直线与坐标轴成$45
$角,那这两个点必然和另一个点组成了一个等腰直角三角形(欧几里得意义下),我们枚举等腰直角三角形的直角顶点和直角边长就可以确认这两个点的坐标,而另一个点一定在一条与坐标轴成$45
$的斜线上,可以使用前缀和做.</p>
<p>注意到有的点对可能会被算两遍,要特判.</p>
<h5><span id="example2">Example2</span></h5>
<p>小孔在玩卡牌游戏.众所周知,在卡牌游戏里,过牌是很关键的,所以目前小孔的牌库中,只可能有数字牌$0
, 1 , 2 , 3 , 4 $.</p>
<p>数字牌$x <span class="math inline">\(的含义是当你打出它的时候,会从牌库的顶端抽\)</span>x
<span class="math inline">\(张牌到自己手里,若牌库中不足\)</span>x <span class="math inline">\(张牌,则将牌库抽空为止.打出的数字牌\)</span>x
$会放入弃牌堆中.在题目中你可以认为这张牌不会再被用到了.</p>
<p>目前,牌库里有$n <span class="math inline">\(张牌,从牌堆顶到牌堆底数第\)</span>i <span class="math inline">\(张牌为数字牌\)</span>a _i <span class="math inline">\(.在开始回合时,发牌员会进行一次切牌,切牌的结果是从牌堆顶到牌堆底的牌的顺序变为了\)</span>a
<em>s , a </em>{ s + 1 } , . . . , a _n , a <em>1 , . . . , a </em>{ s −
1 } $.</p>
<p>接着,小孔会抽$k <span class="math inline">\(张牌堆顶的牌到自己手上.每次小孔可以打出一张牌,但这一回合中小孔至多打出\)</span>p
$张牌.小孔可以在任意时刻结束回合.</p>
<p>请问,这一回合中若小孔使用最优策略,那么牌库里最少还剩多少牌.进一步地,有$q
<span class="math inline">\(次这样的询问,每次询问给定三个整数\)</span>s
, k , p <span class="math inline">\(,你需要输出牌库里最少还剩多少牌.\)</span>( n , q
^5 ) $.</p>
<p>每次询问是独立的,也就是说每次询问并不会以任何方式影响到之后的询问.</p>
<p>首先我们想一下我们需要知道什么:我们需要知道其在这一回合中打出的各种牌的数量是多少.而只要知道这一点,我们自然得到了答案是多少.注意到每次一定优先打出手头上最大的牌.</p>
<p>我们设$sum <em>{ t , i } <span class="math inline">\(表示从开始到抽完第\)</span>i <span class="math inline">\(张牌**之前**,在只用大于\)</span>t <span class="math inline">\(的牌的前提下,还能往下抽多少张牌.显然\)</span>sum
</em>{ t , 0 } = 0 <span class="math inline">\(并且\)</span>sum <em>{ t
, i } = sum </em>{ t , i - 1 } + a <em>{ i - 1 } [ a _{ i - 1 } &gt; t ]
- 1 <span class="math inline">\(.注意到\)</span>sum </em>{ t , i } = 0
<span class="math inline">\(就抽不了第\)</span>i <span class="math inline">\(张牌了.不考虑还能抽负数张牌的情况,注意到\)</span>sum
$数组具有可差分性!</p>
<p>那我们一开始抽了$k <span class="math inline">\(张牌,也就是令\)</span>sum <em>{ s + 1 } sum </em>{
s + 1 } + k <span class="math inline">\(,那第一个不能继续抽牌的地方显然也就是第一个满足\)</span>sum
<em>{ i } - sum </em>{ s } <span class="math inline">\(的地方,用原本的\)</span>sum <span class="math inline">\(数组表示也就是\)</span>sum <em>{ i } + k sum
</em>{ s } <span class="math inline">\(.那第二个地方呢?由于后面的\)</span>sum <span class="math inline">\(都加上\)</span>k <span class="math inline">\(了,第二个地方也就是满足\)</span>sum <em>j sum
</em>{ i } - t <span class="math inline">\(的地方(不过注意到后面要倍增,所以直接写\)</span>sum
_j &lt; sum _i <span class="math inline">\(也可以,这样方便用单调栈维护这个东西).以此类推,注意到这个东西和询问无关,可以使用倍增预处理,处理的过程中判断一下还有没有大小为\)</span>t
<span class="math inline">\(的牌以及用牌总数是否小于等于\)</span>p
$即可.都是可以用前缀和之类的东西预处理的.最后从小的牌开始选,选完之后的牌就可以当成$0
<span class="math inline">\(牌了.另外要注意:我们要保证目前一定有大小为\)</span>t
<span class="math inline">\(的牌选,所以需要在做之前判断一下最后一次选择大小为\)</span>t
$的牌的位置是在哪里.</p>
<p>等一下,注意到我们好像没啥办法判断还有没有大小为$t <span class="math inline">\(的牌.有一个方法是:我们直接令所有\)</span>t - 1
<span class="math inline">\(的牌变成\)</span>t <span class="math inline">\(,并处理出不用\)</span>t - 1 <span class="math inline">\(的牌能跑到的最右点,然后取个\)</span>$.</p>
<p>想出$sum <span class="math inline">\(数组并发现可差分性后,这个题突然就变可做了.问题来了:咋想到的\)</span>sum
$数组,又是怎么发现的可差分性?</p>
<p>首先,由于切牌这个环节会变化起点.所以有两种可能:要么是像倍增那样起点不定,要么是像差分一样其它起点的答案可以由原本的起点答案得到.那想到差分后呢?又注意到一定会先选较大的牌,所以大概率可以分层考虑:这样就先把问题转化为只有$0
/ 1 $或者是只有$0 / 1 / 2
$的情况再继续考虑.由于要多组询问,所以答案一定是可以通过某种方式迅速算出来的,考虑到只要得到每种牌选的次数就可以快速算答案.又有一定是比它大的牌都选完了才选它,于是考虑第一次选不了其它牌只能选它的地方.注意到这个地方可以使用前缀和在变换起点的情况下求.于是由前缀和判断差分性质.</p>
<h3><span id="二分答案">二分答案</span></h3>
<h5><span id="example12022qbxt国庆day6kth">Example1([2022qbxt国庆Day6]kth)</span></h5>
<p>考虑$f <span class="math inline">\(的取值不会很多,我们可以枚举\)</span>f <span class="math inline">\(的取值,并把相同取值的归类.也就是,对于\)</span>f =
i <span class="math inline">\(的类别里也就是后\)</span>i $位为$0 <span class="math inline">\(,第\)</span>i $位为$1 $的那些数.</p>
<p>注意到每个类别内部是很有序的,也就是说我们可以采取类似初赛归并排序的方法二分,找到前$k
$大的和.</p>
<p>调了一年,这个故事告诉我们,如果一个东西暴力调整能过/复杂度均摊,就不要写一些很丑的很难写的即使更快的东西去做.</p>
<h5><span id="example2">Example2</span></h5>
<p>给你一棵$n
$个点的树,每条边是一个字符(字符集是小写字母),一个点的所有相邻边边权不同.</p>
<p>有$m <span class="math inline">\(次操作:每次询问给出点\)</span>x
<span class="math inline">\(和字符串\)</span>S <span class="math inline">\(,\)</span>S <span class="math inline">\(中不包含相同字符,\)</span>| S | = 26
$,每次修改会修改一条边边权.</p>
<p>从$x <span class="math inline">\(点开始,每次对与\)</span>x <span class="math inline">\(点相邻的边,对这些边找出其边权在\)</span>S
$中出现的位置,找出边权出现位置最靠前的边,然后走过去.</p>
<p>每次询问走过的边直接从树上删除,一条边正反方向算同一条边,也就是说没法$x
y x $.</p>
<p>这个过程会停机,你需要输出在哪个点停下来,询问之间独立.</p>
<p>这题最重要的思想在于:我们首先需要将这个问题改成一个判定性问题:判定性问题显然弱于找到答案.</p>
<p>怎么判定呢?对于一条路径,如果我们要沿着它走,那么我们就可以确定每个点的最小边(或者次小边),这等价于给出若干个边之间的大小关系,可以使用bitset维护一下,最后判定即可.我们发现判定数组是可以合并的,于是这玩意可以扔到线段树上维护.</p>
<p>会了判定这题就做完了,做树链剖分,然后开始从下往上跳重链,能跳到顶端就跳,不然二分跳到哪里,下去是同理的,只不过下去的二分需要多个$n
$.</p>
<h3><span id="整体二分">整体二分</span></h3>
<p>通常解决在二分的情况下,单次check的复杂度比较高的问题.思想是把所有询问共同的check一起做.</p>
<p>整体二分的具体复杂度往往需要现场分析.</p>
<p>最常用的整体二分的写法是分治.但是有的问题(例如不能撤销)可能不太好写分治.</p>
<p>还有一种方式是,我们把所有询问一字排开,然后求出每个询问当前二分的$mid
<span class="math inline">\(,然后顺序处理或者别的什么处理方式做这些\)</span>mid
$.</p>
<h5><span id="example1agc002dstamp-rally">Example1([AGC002D]Stamp Rally)</span></h5>
<p>直接整体二分,注意需要做可撤销并查集之类的东西.</p>
<h3><span id="分治">分治</span></h3>
<h5><span id="example1平面最近点对">Example1(平面最近点对)</span></h5>
<p>按照$x <span class="math inline">\(轴排序,递归做两边的子问题,假设两边问题的最小值为\)</span>d
<span class="math inline">\(,对着\)</span>d $做中间的问题.</p>
<h5><span id="example2cf1764g3doremys-perfect-ds-class-hard-version">Example2([CF1764G3]
Doremy’s Perfect DS Class (Hard Version))</span></h5>
<p>有一个$[ 1 , n ] <span class="math inline">\(的排列\)</span>p <span class="math inline">\(,每次可以询问\)</span>l , r , k <span class="math inline">\(,交互库会返回\)</span> { k } , { k } , , { k }
$中不同数字的个数,你需要在$20 <span class="math inline">\(次询问内找到\)</span>p $中$1 $的位置.</p>
<p>第一反应就是令$k = 2 <span class="math inline">\(,然后如果\)</span>n
$是奇数,不难发现此时只有$1 <span class="math inline">\(自己一个人一组.一个自然的想法是,我们可以对于每个位置\)</span>i
<span class="math inline">\(,查询\)</span>[ 1 , i - 1 ] <span class="math inline">\(和\)</span>[ 1 , i ]
$的答案,如果答案一样,那这个位置肯定不是$1 <span class="math inline">\(.如果不一样,我们再查一下\)</span>[ i , n ] <span class="math inline">\(和\)</span>[ i + 1 , n ] $.由于$1
$不会和左右任意一个人配对,不难发现如果这两种情况都不一样,那这里一定是$1
$,这样我们就做到了$2 n - 2 $次查询.</p>
<p>那么如何优化呢?我们冷静一下,如果我们查询一个区间$[ l , r ] <span class="math inline">\(,那么得到的答案自然是\)</span>len - <span class="math inline">\(配对数字都在区间内的对数,因此我们自然也能得到这个区间的未配对数.这个时候发现,对于位置\)</span>i
<span class="math inline">\(,如果我们查询\)</span>[ 1 , i ] <span class="math inline">\(和\)</span>[ i + 1 , n ]
$,由于这两个区间内没配对的数字要么是$1
$,要么会和另一个区间中的数字配对,因此这两个区间中,未配对数多的那个一定包含$1
<span class="math inline">\(.这样就可以通过\)</span>k
$不断向下二分,最后只需要$20 <span class="math inline">\(步操作就可以解决\)</span>n $是奇数的情况.</p>
<p>那么$n $是偶数怎么办呢?这个时候$1 <span class="math inline">\(和\)</span>n <span class="math inline">\(都没人配对.我们需要找到\)</span>n <span class="math inline">\(并将它杀掉.注意到\)</span>k <span class="math inline">\(可以取别的数,我们如果只是让\)</span>k = 2
$未免有些弱,而且看上去也区分不了$1 <span class="math inline">\(和\)</span>n <span class="math inline">\(,而不难发现,令\)</span>k = n <span class="math inline">\(就可以找到\)</span>n <span class="math inline">\(在哪里,于是可以先找\)</span>n $再找$1 $,需要$40
$步.</p>
<p>那怎么继续优化呢?我们还是令$k = 2 <span class="math inline">\(,查询\)</span>[ 1 , i ] <span class="math inline">\(和\)</span>[ i + 1 , n ]
$,我们发现此时会有两种情况:</p>
<ol type="1">
<li><p>左右两边未配对数量相差$2 $,这个时候$1 <span class="math inline">\(和\)</span>n
$一定都在较大的那边,直接递归.</p></li>
<li><p>左右两边未配对数量相等,这个时候一定$1 <span class="math inline">\(在一边,\)</span>n <span class="math inline">\(在另一边,我们可以通过一次查询\)</span>k = n <span class="math inline">\(判断哪边是\)</span>n $.</p></li>
</ol>
<p>于是只需要$21 $次.</p>
<p>但是还是不够,我们从哪里抠出那一次呢?发现最后处理区间$[ i , i + 1 ]
$还需要两步操作,我们看看能不能省掉一步.</p>
<ol type="1">
<li><p>$1 <span class="math inline">\(和\)</span>n <span class="math inline">\(都在\)</span>[ i , i + 1 ] <span class="math inline">\(中,我们显然只需要查询一步就可以知道哪边是\)</span>n
$.</p></li>
<li><p>只有$1 <span class="math inline">\(在\)</span>[ i , i + 1 ] <span class="math inline">\(中,我们考虑利用一下前面的信息.注意到我们一定已经知道\)</span>[
1 , i - 1 ] , [ i , n ] , [ 1 , i + 1 ] , [ i + 2 , n ] <span class="math inline">\(的答案(如果区间为空或者区间为\)</span>[ 1 , n ]
$显然我们也知道答案),假设这个区间中的两个数是$1 <span class="math inline">\(和\)</span>x <span class="math inline">\(,\)</span>x ( 1 , n ) <span class="math inline">\(,那么\)</span>x <span class="math inline">\(一定有一个和它配对的数字,我们考虑通过\)</span>[ 1
, i - 1 ] <span class="math inline">\(和\)</span>[ 1 , i + 1 ] <span class="math inline">\(就可以知道和\)</span>x <span class="math inline">\(配对的数字在\)</span>[ 1 , i - 1 ] <span class="math inline">\(还是在\)</span>[ i + 2 , n ]
$.接下来只需要一步判断就可以找到$1 $了.</p></li>
</ol>
<h5><span id="example3xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopentraisncontest-1489d-nice-set-of-points">Example3(XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(opentraisn
contest 1489)D Nice Set of Points)</span></h5>
<p>给定一个点集$S = { ( x , y ) } <span class="math inline">\(,\)</span>( x _1 , y _1 ) <span class="math inline">\(和\)</span>( x _2 , y _2 ) <span class="math inline">\(可达当且仅当\)</span>x _1 = x _2 y _1 = y _2 <span class="math inline">\(.称一个点集是好的当且仅当这个点集中任意两个点的最短距离是它们的曼哈顿距离.给出一个点集,大小为\)</span>N
$,$1 N $,加入不多于$10000 - N $个点使得这个点集变成好的.</p>
<p>找一条分界线$x = d
$,我们将这条线左右两边的点全都作出在这条线上的投影点,将这些投影点全都加入,不难发现左右两边之间的路径就合法了,继续递归就行.</p>
<h5><span id="example4cf1442dsum">Example4([CF1442D]Sum)</span></h5>
<p>一个自然的想法是由于越靠后的可能越优秀,所以应该是要不断往后挖的.具体地,我们发现只可能有一个数组被选了一部分,剩下的数组要么不选,要么全选.</p>
<p>为什么呢?假设有两个数组各选了一部分,不妨假设它们最后选的数分别是$a
<span class="math inline">\(和\)</span>b <span class="math inline">\(,下一个未选的数分别是\)</span>c <span class="math inline">\(和\)</span>d <span class="math inline">\(,有\)</span>c a , d b <span class="math inline">\(,假设\)</span>a b <span class="math inline">\(,那么自然有\)</span>c b <span class="math inline">\(,于是我们把\)</span>b <span class="math inline">\(删掉换成\)</span>c $一定更优秀.</p>
<p>有了这个性质后,我们可以枚举是哪个数组只选了一部分,然后求出剩下部分的背包,背包部分可以求前缀和后缀最后合并起来,我们的复杂度就是$O
( nk ^2 ) $.</p>
<p>但这个复杂度还是不太够,如何优化呢?</p>
<p>注意到这里的背包是支持撤销操作的,我们考虑一个分治做法:每次做到$[ l ,
r ] <span class="math inline">\(的时候,假设此时\)</span>[ 1 , l - 1 ]
<span class="math inline">\(和\)</span>[ r + 1 , n ] <span class="math inline">\(都加入答案了,我们把\)</span>[ mid + 1 , r ] <span class="math inline">\(也加入背包,然后递归求解\)</span>[ l , mid ] <span class="math inline">\(,然后再撤销,同样的方法求解右边的答案.复杂度\)</span>O
( nk n ) $.</p>
<h5><span id="example5agc044d">Example5(AGC044D)</span></h5>
<p>这题在于分治后归并,考虑我们是可以快速判断一个串是否是原串的子序列的,就是判断它们的编辑距离是否恰好等于长度之差.而我们也可以快速判断每个字母在原串中出现了多少次,只需要询问$L
<span class="math inline">\(个这个字母然后看编辑距离就是替换的次数.这样我们考虑对字母分治,\)</span>[
l , r ] <span class="math inline">\(表示只用到\)</span>[ l , r ] <span class="math inline">\(中的字母,得到的极长的原串的子序列是什么.边界情况\)</span>[
l , l ] <span class="math inline">\(是好处理的,对于\)</span>[ l , r ]
<span class="math inline">\(,我们考虑归并,合并\)</span>[ l , mid ] <span class="math inline">\(和\)</span>[ mid + 1 , r ]
$的时候不断判断当前串是否是子序列就行.</p>
<h3><span id="倍增">倍增</span></h3>
<p>顺便一提,倍增比二分方便的一点在于:倍增能迅速确定答案的规模,这在复杂度与答案规模有关的时候至关重要.</p>
<h5><span id="example1scoi2015国旗计划">Example1([SCOI2015]国旗计划)</span></h5>
<p>先破环成链,然后设$f _{ i , j } <span class="math inline">\(表示从\)</span>i $这个人,途径$2 ^j
$个人后能到达的最远的人是谁,然后就可以直接通过倍增处理.</p>
<h5><span id="example2pkusc2018星际穿越">Example2([PKUSC2018]星际穿越)</span></h5>
<h5><span id="example3cf1523hhopping-around-the-array">Example3(CF1523H
Hopping Around the Array)</span></h5>
<p>类似国旗计划,只不过需要用背包合并一维.</p>
<p>不过吧,这题有个问题在于最后的询问,我们要每次判断当前越界的点的代价是否小于等于dp数组的代价,如果小就回撤dp数组(因为无论如何都必不可能在这里选择).</p>
<h5><span id="example4loj3665">Example4(loj3665)</span></h5>
<p>思考一下发现,走相同的步数能到的点一定是一段区间,于是考虑使用倍增算法,设$f
_{ x , i } <span class="math inline">\(表示从\)</span>x $走$2 ^i
$步能到的区间,转移是简单的RMQ问题.</p>
<p>但是初值怎么求呢?先考虑右端点怎么求.对于每个路线$j <span class="math inline">\(,它会把\)</span>[ A _j , A _j + k - 1 ] <span class="math inline">\(能到达的右端点与\)</span>B _j <span class="math inline">\(取\)</span>$,由于查询在修改之后,所以这个东西很好做.</p>
<h5><span id="example5cf1707e">Example5(CF1707E)</span></h5>
<p>引理1:如果$[ l , r ] <span class="math inline">\(,则\)</span>f ( ( l
, r ) ) f ( ( L , R ) ) $.</p>
<p>引理2:如果$[ L , R ] = [ l _1 , r _1 ] <span class="math inline">\(,则\)</span>f ( ( L , R ) ) = f ( ( l _1 , r _1 )
) f ( ( l _2 , r _2 ) ) $.</p>
<p>引理1显然,引理2是因为$[ L , R ]
$中的最大值和最小值一定都被后面的两个部分取到.</p>
<p>于是,考虑$[ l , r ] = _{ i = l } ^{ r - 1 } [ i , i + 1 ]
$,就可以倍增了.</p>
<p>考虑求出每个单点的倍增数组,那么总区间的倍增数组也就是这些数组的最小值和最大值.</p>
<p>大概做一下.</p>
<h5><span id="example622zr提高组十连测day6百分号">Example6([22zr提高组十连测day6]百分号)</span></h5>
<p>首先看上去多组询问给定起点终点看上去就很像倍增.</p>
<p>一个很自然的设计是$L <em>{ x , i } <span class="math inline">\(表示从\)</span>x $这个点跳$2 ^i <span class="math inline">\(所能到达的最左端的点,\)</span>R </em>{ x , i }
$同理.但是能跳到最远的点不一定能跳到一个较近的点,那咋办呢?</p>
<p>冷静一下,注意到我们好像还没有用到括号序列的性质:两个跳跃要么包含要么不交,不可能出现第三种情况.</p>
<p>所以,如果目前能跳到的最远的点为$l , r <span class="math inline">\(,那么再跳一步能到达的最远的点一定是从\)</span>l
<span class="math inline">\(或\)</span>r <span class="math inline">\(跳过去的.考虑反证这个结论,设能从\)</span>( l , r )
<span class="math inline">\(中的一个点\)</span>k <span class="math inline">\(跳到更远的点,那么由于之前没跳到过\)</span>k <span class="math inline">\(就跳到\)</span>l <span class="math inline">\(了,所以一定存在一个\)</span>i &gt; k <span class="math inline">\(,\)</span>i l <span class="math inline">\(,而如果存在\)</span>j &lt; l <span class="math inline">\(,\)</span>k j $,显然不满足性质.</p>
<p>同理,我们最后处理询问答案的时候,考虑从$x <span class="math inline">\(和\)</span>y <span class="math inline">\(都跳.先从\)</span>x <span class="math inline">\(跳到再跳一步就会跳过\)</span>y <span class="math inline">\(的位置,然后把\)</span>y <span class="math inline">\(跳到再跳一步就会跳过\)</span>x <span class="math inline">\(的位置,那么现在的\)</span>x <span class="math inline">\(和\)</span>y
$一定相邻,不然分别跳一步就会出现包含的情况,于是一定是最优解.</p>
<h3><span id="对称建立双射">对称/建立双射</span></h3>
<h5><span id="example1cf1627f">Example1(CF1627F)</span></h5>
<p>冷静一下考虑,分界线一定是一个中心对称图形,分成的两部分一定中心对称.那这条分界线一定过中心点.</p>
<p>我们考虑这么一点:如果所有点对都在矩阵一边,我们就可以直接求中心点到矩阵一边的最短路然后对称一下就好了.</p>
<p>而矩阵上遍布点对怎么办呢?我们在和每个点对对称的位置把这个点对复制一遍,然后从中心点找到一条到边界的最短路,把它对称一下即可.</p>
<h5><span id="example2ah2017hnoi2017抛硬币">Example2([AH2017/HNOI2017]抛硬币)</span></h5>
<p>设$A <span class="math inline">\(的正面朝上为\)</span>S _A <span class="math inline">\(,\)</span>B <span class="math inline">\(的为\)</span>S _B <span class="math inline">\(.设\)</span>p _1 = , p _2 = , p _3 = $.</p>
<p>当$a = b <span class="math inline">\(,翻转所有硬币,自然有\)</span>p
_1 = p _3 <span class="math inline">\(,又设\)</span>P = p _1 + p _2 + p
_3 = 2 ^{ a + b } <span class="math inline">\(,于是求得\)</span>p _2
<span class="math inline">\(即可得到答案.而\)</span>p <em>2 = </em>{ i =
0 } ^a { i } { i } <span class="math inline">\(,用范德蒙德卷积的变式,有\)</span>p _2 = { a }
$.</p>
<p>同样,当$a &gt; b <span class="math inline">\(时.我们设\)</span>p _4 =
, p _5 = , p _6 = <span class="math inline">\(.同样是翻转硬币的套路,自然有\)</span>p _4 = p _1 ,
p _5 = p _2 , p _6 = p _3 <span class="math inline">\(.注意到:\)</span>S
_A S _B a - S _A &gt; b - S _B <span class="math inline">\(,但逆命题不成立.不妨设\)</span>p _7 =
$.自然有:</p>
<p><span class="math display">\[
p _1 = p _4 = p _7 + p _2 + p _3 = p _7 + P - p _1
\]</span></p>
<p>于是只要求出$p _7 <span class="math inline">\(就可以求得\)</span>p _1
$.</p>
<p>考虑$p _7 <span class="math inline">\(如何求,注意到\)</span>[ S _A
&gt; S _B a - S _A &gt; b - S _B ] = [ 0 &lt; S _A - S _B &lt; a - b ]
<span class="math inline">\(,我们可以枚举\)</span>S _A - S _B
$,然后继续用范德蒙德卷积的变式.</p>
<h5><span id="example32022qbxt国庆day4c">Example3([2022qbxt国庆Day4]C)</span></h5>
<p>直接考虑对于每一对位置$( i , j ) , i &lt; j
$,计算它们可能产生的逆序对贡献.注意到每一对对答案的贡献会大概接近$0 . 5
$,我们考虑构造一个双射,判断双射左右是否都会贡献.</p>
<p>设$d <em>i <span class="math inline">\(为\)</span>i <span class="math inline">\(个数的错排数量,根据错排公式有\)</span>d <em>n = (
n - 1 ) ( d </em>{ n - 1 } + d </em>{ n - 2 } )
$.接下来讨论一下这两个位置的取值:</p>
<ol type="1">
<li><p>如果$a _i = j , a <em>j = i <span class="math inline">\(,那么一定贡献了逆序对,这里总共贡献为\)</span>d
</em>{ n - 2 } { 2 } <span class="math inline">\(,一半的贡献也就是\)</span> { 4 } $.</p></li>
<li><p>如果$a <em>i = j , a <em>j = k , k i a <em>i = k , a <em>j = i ,
k j <span class="math inline">\(,考虑前后两者形成双射.如果\)</span>k
<span class="math inline">\(在\)</span>i <span class="math inline">\(和\)</span>j <span class="math inline">\(之间,那么无论前者还是后者,都一定贡献逆序对;不然,则两种情况一定只有一种会贡献逆序对.前者多出的贡献应该是\)</span>
{ 6 } ( d </em>{ n - 2 } + d </em>{ n - 3 } ) <span class="math inline">\(,也就是先选出\)</span>i &lt; k &lt; j <span class="math inline">\(,如果\)</span>a <em>k = i <span class="math inline">\(,那么剩余的可能性就是\)</span>d </em>{ n - 3 }
<span class="math inline">\(;不然,也就是说\)</span>a <em>k i <span class="math inline">\(,类似于错排公式,剩余的可能性为\)</span>d </em>{ n
- 2 } <span class="math inline">\(.另外,由于\)</span>d </em>{ n - 2 } +
d </em>{ n - 3 } = { n - 2 } <span class="math inline">\(,所以上面的贡献也就是\)</span> { 6 } d _{ n - 1 }
$.</p></li>
<li><p>如果$i , j , a _i , a _j <span class="math inline">\(互不相同,那我们交换\)</span>a _i <span class="math inline">\(和\)</span>a _j
$一定可以构造出另一组答案,并且这两组答案中一定只有一组贡献了逆序对,于是二者形成双射.</p></li>
</ol>
<p>除去上面的部分的贡献是$ { 4 } <span class="math inline">\(.于是总贡献为:\)</span>n ( n - 1 ) ( { 6 } + { 4 }
) $.</p>
<h5><span id="example4arc115d">Example4(ARC115D)</span></h5>
<p>第一反应感觉完全不可做.</p>
<p>思考一下,如果我们随便选边肯定完蛋了:我们又不知道选出了几个奇度点,这不完蛋了?</p>
<p>先考虑要求全是偶度点怎么办?</p>
<p>由于点只有奇度点和偶度点两种,如果我能先随便选个边集,再把它删到全是偶度点好像就赢了.但是一方面我咋删啊,一方面这样删有可能删出重复的.又注意到删一条边就一定可以让两个点的奇偶性改变.</p>
<p>我们考虑求出原图的一棵生成树,然后剩下的边随便选.之后从生成树深度较大的点开始考虑:如果这个点是奇度点,我们就把它的父边删掉.容易发现这样是双射.而如果有奇度点的话可以先组合数选出来然后同样做上面的操作,容易发现是一样的.</p>
<p>不同的连通块可以分别做最后卷起来.</p>
<h5><span id="example5hihocoder1230">Example5(Hihocoder1230)</span></h5>
<p>这题最重要的一点在于观察到一组$a
$如果有解,那么一定是唯一解.为啥呢?我们考虑如何构造一个解:从小位到高位枚举,如果当前位所有数异或起来是$1
<span class="math inline">\(,那么\)</span>x $这一位也必然是$1 <span class="math inline">\(,然后加上后进位.这是由于序列长度是奇数.然后就每次对于\)</span>a
$计数,做FWT就行.</p>
<h5><span id="example623省选10连测-day5b">Example6(23省选10连测 day5B)</span></h5>
<p>首先我们要知道,一轮冒泡排序的过程等价于:从前往后考虑每一个点,如果它前面存在一个比它大的点,就将它和前面的点交换.</p>
<p>于是我们考虑令$b <em>i = </em>{ j = 1 } ^{ i - 1 } [ a _j &gt; a _i ]
<span class="math inline">\(.也就是每次冒泡排序,这个\)</span>b _i <span class="math inline">\(都会变成\)</span>{ b _i - 1 , 0 } <span class="math inline">\(.显然\)</span>b _i <span class="math inline">\(需要满足的条件是\)</span>b _i <span class="math inline">\(,接下来我们证明:只要满足这个条件,\)</span>b <span class="math inline">\(和\)</span>a <span class="math inline">\(就是双射关系.根据\)</span>a <span class="math inline">\(还原\)</span>b <span class="math inline">\(是简单的,那么如何根据\)</span>b <span class="math inline">\(还原\)</span>a
$呢?我们只需要从大向小考虑元素,就可以判断元素插入哪里.</p>
<p>有了这个条件后,我们不妨设原序列是$a ’ <span class="math inline">\(,其对应\)</span>b ’ <span class="math inline">\(,那么显然\)</span>b _i = { 0 , b _i ’ - m } { 0 ,
n - i - m } <span class="math inline">\(.也就是说,如果\)</span>b _i = 0
<span class="math inline">\(,那么\)</span>b _i ’ <span class="math inline">\(,反之\)</span>b _i ’ = b _i + m <span class="math inline">\(.但问题在于:我们如何保证\)</span>b _i ’ <span class="math inline">\(呢?不难发现,冒泡排序每次会把前面最大的数扔到后面,也就是说整个序列最后的\)</span>m
<span class="math inline">\(个数一定有序,那我们分开考虑:对于最后的\)</span>m
<span class="math inline">\(个数,它一开始在序列中的相对顺序是无所谓的:无论如何都会扔到最后.而对于其它的数,如果\)</span>b
_i = 0 <span class="math inline">\(,\)</span>b _i ’ <span class="math inline">\(,由于最后都已经凑出\)</span>m <span class="math inline">\(个数了,从大向小将数字插入,一定可以使这一部分满足条件.而如果\)</span>b
_i &gt; 0 <span class="math inline">\(,由于有判定条件\)</span>b _i { 0 ,
n - i - m } <span class="math inline">\(,显然满足.于是我们设一共有\)</span>k <span class="math inline">\(个\)</span>b _i = 0 <span class="math inline">\(的位置(也就是前缀最大值位置),于是自然有\)</span>f
( a , m ) = ( m + 1 ) ^k m ! <span class="math inline">\(.注意这个式子的前提在于判定每个\)</span>b <em>i {
0 , n - i - m } <span class="math inline">\(以及\)</span>a <span class="math inline">\(的最后\)</span>m <span class="math inline">\(个位置是\)</span>n - m + 1 , , n - 1 , n <span class="math inline">\(.到这里不难发现只要满足后者前者必定满足.现在只需要统计前缀最大值的个数就可以解决这个问题了.这个设计个\)</span>dp
</em>{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个数的最大值是\)</span>j $就行.</p>
<h3><span id="拆多项式">拆多项式</span></h3>
<p>通常适用于数据范围中有一项的范围不大的情况,然后拆成多项式后可以带入另一项较大的值.</p>
<h5><span id="example122zr提高组十连测day5可">Example1([22zr提高组十连测day5]可)</span></h5>
<p>首先考虑数位dp,每次枚举当前的$k <span class="math inline">\(个数中还有\)</span>x <span class="math inline">\(个数被limit,这次又有\)</span>y <span class="math inline">\(个数不用被limit,再枚举一下当前各位之和,然后可以写一个转移,复杂度\)</span>O
( k ^4 x ) $</p>
<p>然后想了好久发现这个东西好像优化不动了.</p>
<p>冷静一下,注意到问题在于枚举,我们不妨把枚举换成容斥试试.设$g ( x )
<span class="math inline">\(为\)</span>a <span class="math inline">\(为\)</span>x $的方案数,那么可以通过容斥得知:</p>
<p><span class="math display">\[
g ( n ) = \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \binom { n
- i ( x + 1 ) + k - 1  } { k - 1  }
\]</span></p>
<p>我们最后要求的答案也就是$f ( n ) g ( n ) $,继续推式子:</p>
<p><span class="math display">\[
ans = \sum _{ n = 0  } ^{ kx  } f ( n ) g ( n ) = \sum _{ n = 0  } ^{
kx  } f ( n ) \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \binom
{ n - i ( x + 1 ) + k - 1  } { k - 1  }
\]</span></p>
<p><span class="math display">\[
= \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \sum _{ n = 0  }
^{ kx  } f ( n ) \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }
\]</span></p>
<p>看上去好像推不动了.</p>
<p>冷静一下,会发现$n <span class="math inline">\(的取值远远大于\)</span>i , k <span class="math inline">\(的取值.于是我们选择把组合数拆成一个\)</span>k - 1
$次多项式,这样只需要处理出这个多项式的每一项的系数,然后就可以预处理后面的东西.</p>
<p>拆二项式系数的时候要注意特判上指标小于下指标的情况.</p>
<p><span class="math display">\[
ans = \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \sum _{ j =
0  } ^{ k - 1  } c _{ i , j  } \sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n
) n ^j
\]</span></p>
<p>其中$c _{ i , j } = [ n ^j ] { k - 1 } $.</p>
<p>这样我们就成功地分离出了一项$_{ n = i ( x + 1 ) } ^{ kx } f ( n ) n
^j $,接下来考虑怎么处理这一项.</p>
<p>考虑枚举$i <span class="math inline">\(,然后设\)</span>dp <em>{ j ,
limit } = </em>{ n = 0 } ^{ limit } f ( n ) n ^j <span class="math inline">\(,考虑拿数位dp做这个东西,枚举当前位置\)</span>cnt
<span class="math inline">\(的取值\)</span>w <span class="math inline">\(,根据二项式定理,\)</span>dp <em>{ a + b , limit }
{ b } dp </em>{ b , limit } f ( w ) ( w 10 ^{ cnt } ) ^a <span class="math inline">\(,那么\)</span><em>{ n = i ( x + 1 ) } ^{ kx } f (
n ) n ^j = dp </em>{ j , kx } - dp _{ j , i ( x + 1 ) - 1 } $.</p>
<p>这样我们需要枚举$i , a , b , cnt <span class="math inline">\(得到一组答案,然后还需要把这些答案合并起来,复杂度\)</span>O
( k ^3 x ) $.</p>
<h3><span id="抽屉原理">抽屉原理</span></h3>
<h5><span id="example1unr-6小火车">Example1([UNR #6]小火车)</span></h5>
<p>首先考虑证明一定有解:</p>
<p>注意到我们可以先选择出两个不完全相同的集合,如果这两个集合的和相等,那么我们把只在第一个集合的$b
<span class="math inline">\(设为\)</span>- 1 <span class="math inline">\(,只在第二个集合的\)</span>b $设为$1
$,都在或都不在的设为$0 $,那么这显然就是一组解.</p>
<p>而由于$p &lt; 2 ^n $,根据抽屉原理,显然存在这么两个集合.</p>
<p>考虑对于一个权值区间$[ l , r ] <span class="math inline">\(,如果有超过\)</span>r - l + 1
$个集合的和在这个区间内,那一定有两个集合可以组成一个解.</p>
<p>假设现在已知权值区间$[ l , r ] <span class="math inline">\(一定有解,我们判断\)</span>[ l , mid ] <span class="math inline">\(中是否有超过\)</span>mid - l + 1 <span class="math inline">\(个集合,使用折半搜索再合并可以快速求出权值和为某个定值的集合有多少个.然后可以使用双指针判断,继续递归下去判断即可.复杂度\)</span>O
( 2 ^{ { 2 } } n ) $.</p>
<h5><span id="example2noi2021量子通信">Example2([NOI2021]量子通信)</span></h5>
<p>考虑$k $,所以如果我们把两个零一串每$16 <span class="math inline">\(个分一块,那么两个零一串相差少于\)</span>k <span class="math inline">\(处,则一定有一块完全相等.由于数据随机,这个概率为\)</span>
{ 2 ^{ 16 } } $.</p>
<p>考虑把在一块中是某个数的零一串全都集合到一起,然后暴力判断,复杂度约为$O
( { 2 ^{ 16 } w } ) $.</p>
<h3><span id="拆贡献">拆贡献</span></h3>
<h5><span id="example12022qbxt国庆day7fenwick">Example1([2022qbxt国庆Day7]fenwick)</span></h5>
<p>注意到要变换多次,考虑每个值的贡献.</p>
<p>一个点要往后更新,不难通过平行求和法则一个值$v <span class="math inline">\(对它向后跳\)</span>w <span class="math inline">\(步的贡献为\)</span> { w } <span class="math inline">\(.但是有修改很难办,怎么办?注意到如果我们暴力跳,查询的时候复杂度是\)</span>O
( 1 ) <span class="math inline">\(的,我们没必要让它这么低.我们把所有值对\)</span>p
<span class="math inline">\(这个点的更新存到一个数组里,显然只有\)</span>n
$种步数.最后每次查询的时候用组合数一起更新即可.</p>
<h5><span id="example2qoj5097-小-p爱学习">Example2([QOJ5097] 小 P
爱学习)</span></h5>
<p>这个题的厉害之处在于完全将贡献拆开.</p>
<p>我们不妨设最后将所有的数分成了$k
$组,那么显然我们只要算出两个东西就可以得到此时的答案的和:</p>
<ol type="1">
<li><p>$<em>{ x </em>{ 1 , . . . , k } } <em>{ i = 1 } ^k a </em>{ x _i
} \ $.</p></li>
<li><p>$_{ 1 x _1 , . . . , x <em>k n , x = n } { </em>{ i = 1 } ^k ( x
_i m - 1 ) ! } \ $.</p></li>
</ol>
<p>第一个显然就是个背包,问题在于第二个的分子部分,我们用生成函数,设$F =
_{ i = 1 } ^{ n } { ( im - 1 ) ! } x ^i <span class="math inline">\(,我们要求的就是\)</span>[ x ^n ] F ^k , k n $.</p>
<p>这个东西可以做BSGS,也就是光速幂.这样就可以用$O ( n ^2 ) <span class="math inline">\(预处理,用\)</span>O ( n ) <span class="math inline">\(查询单个\)</span>k $.</p>
<h5><span id="example3luogu4211lnoi2014lca">Example3(Luogu4211
[LNOI2014]LCA)</span></h5>
<p>将$dep <span class="math inline">\(拆成到根节点的路径上的点的数量,差分一下\)</span>[
l , r ] <span class="math inline">\(,这样就只需要求\)</span>z <span class="math inline">\(和一个前缀点的LCA的\)</span>dep <span class="math inline">\(.将这个操作离线下来,我们对于每一个点把它到根节点的路径上的点全部\)</span>+
1 $,查询每个点到根节点上的权值和就行.</p>
<p>CF757G是一样的,只不过好像需要卡卡空间?</p>
<h3><span id="二进制拆位">二进制拆位</span></h3>
<h5><span id="example1luogu5354ynoi2017由乃的oj">Example1(Luogu5354
[Ynoi2017]由乃的OJ)</span></h5>
<p>对每一位分开处理,对于线段树上每个区间,设$f _{ 0 } <span class="math inline">\(表示一开始\)</span>v $的这一位是$0
$,最后的答案是$1 $还是$0 $,显然可以合并,拿bitset优化一下.</p>
<h3><span id="bitset优化暴力">bitset优化暴力</span></h3>
<h5><span id="example12022qbxt国庆day4d">Example1([2022qbxt国庆Day4]D)</span></h5>
<p>先想一个很明显的优化:我们记录一下每个字符出现的位置,当我们判断当前字符串是否出现过的时候,我们直接从这个字符串开头的字符存在的位置进行判断.</p>
<p>如果我们记录下每个字符在母串中的某个位置是否存在,我们就可以基本脱离母串进行判断.注意到只需要用bitset优化这个过程就可以做到$O
( tlen + { w } ) $.</p>
<h5><span id="example2noi2020-制作菜品">Example2([NOI2020] 制作菜品)</span></h5>
<p>这题首先要根据数据范围,注意到$m n - 1 $的时候存在贪心解法.</p>
<p>具体怎么做呢?我们将原料按照质量排序,每次选最小的那个,不够的话就选最大的那个的一部分,重新排序后递归处理.</p>
<p>为啥这个是对的呢?根据鸽笼原理,最大的那个的质量一定大于等于$ { n }
$,而最小的那个数和最大的那个数之和一定大于等于$0 + { n - 1 } k
$,因此一定有解.</p>
<p>接下来我们就只需要做$m = n - 2 $的情况.</p>
<p>那么这个怎么做呢?我们发现每道菜和两个原材料有关,于是不妨抽象成图论模型:将这两个原材料所代表的点用一条边连起来:我们发现有$n
- 2 <span class="math inline">\(条边和\)</span>n <span class="math inline">\(个点,这个图必不联通.也就是说如果有解,必然可以分成两个集合,这两个集合互不相关.如果我们分成了两个集合,一个集合有\)</span>a
<span class="math inline">\(个原材料,另一个集合有\)</span>n - a <span class="math inline">\(个原材料,我们就可以第一个集合做\)</span>a - 1
<span class="math inline">\(道菜,第二个集合做\)</span>n - a - 1
$道菜,自然解决了问题.</p>
<p>接下来的问题在于01背包,用bitset优化一下.</p>
<h3><span id="简化能更新答案的集合">简化能更新答案的集合</span></h3>
<p>简单来说就是当你注意到一个答案只有可能由某些地方贡献,我们就只判断这些地方的贡献.有的时候不仅需要减小集合,还需要使这个集合尽可能好维护,这个时候可能会向集合里放一些不合法但不可能更新答案的选项.</p>
<h5><span id="example1cf1149d-abandoningroads">Example1(CF1149D Abandoning
Roads)</span></h5>
<p>首先一个把只有$a $边的连通块缩起来,那$1 <span class="math inline">\(到\)</span>i <span class="math inline">\(的最短路显然是通过几个\)</span>b <span class="math inline">\(连接若干个连通块来到\)</span>i $.</p>
<p>由于防止用$b <span class="math inline">\(边链接连通块的时候连出环,我们需要用一个\)</span>dp
_{ S , x } $表示从$1 <span class="math inline">\(经过\)</span>S <span class="math inline">\(集合的连通块到\)</span>x $的最短路.</p>
<p>但是集合数量可能很多,怎么办?</p>
<p>注意到,如果这个集合只有一个点,那显然不可能重复经过;如果这个集合只有两个点,那重复经过意味着想用一条长度为$2
b <span class="math inline">\(的边代替一条长度为\)</span>a
$的边,显然也不优秀;同理集合只有三个点也不优秀.</p>
<p>于是只有点数$ <span class="math inline">\(的集合是有用的,复杂度\)</span>O ( 2 ^{ { 4 } } m n
) $.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定$n <span class="math inline">\(个正整数,要求将\)</span>n <span class="math inline">\(个正整数分到\)</span>k <span class="math inline">\(个集合中,每个集合恰好\)</span> { k } <span class="math inline">\(个数(保证\)</span>k | n <span class="math inline">\()且每个集合中不能有相同的数.设一个方案的代价是每个集合的极差之和,求最小代价,\)</span>n
$.</p>
<p>首先$O ( 3 ^n ) $很好设计不说了.</p>
<p>注意到这题看上去就不太能多项式复杂度,我们考虑简化一下状态数.考虑做$O
( 3 ^n ) <span class="math inline">\(的时候,我们是将\)</span> { k }
$个数打包成一个集合再塞进去,这样看上去就不太优秀,我们考虑能不能一个数一个数塞进去.</p>
<p>我们现在有$k
$个集合,要塞进去一个数到一个集合中.注意到最后的代价实际上和很多数是没啥关系的.考虑先把数字从小到大排序,然后挨个插入集合.如果插入一个数之前,这个集合是空的,那这个数对答案有负的贡献;如果插入一个数之后,这个集合是满的,那这个数对答案有正的贡献;反之无贡献.</p>
<p>于是我们可以枚举目前集合填成啥样了,这样状态数变成了$( { k } + 1 ) ^k
$.</p>
<p>这样还是过不去,我们再冷静一下,显然我们只关心每个集合填了多少个数而不关心具体是哪个集合,于是我们把每个集合的大小排序后再压成状态,这样状态数就是$_{
i = 0 } ^{ k } { { { k } } } \ <span class="math inline">\(,根据目前填到第几个数分一分类就会发现这部分上限是\)</span>O
( n { } ) $.</p>
<p>不过我们还需要保证一个集合里不能有相同的元素.这里我们考虑将相同的元素一起放并规定放的顺序.因为放进去的集合在放这种元素前是有大小顺序的,我们每次放进最大的集合中.换句话说,我们设$f
_{ i , j , S } <span class="math inline">\(表示目前放到\)</span>i <span class="math inline">\(,状态是\)</span>S <span class="math inline">\(,并且\)</span>a _i <span class="math inline">\(放进去的那个集合目前大小是\)</span>j + 1 <span class="math inline">\((放前是\)</span>j $).</p>
<p>算一下复杂度是$O ( n ^2 { } )
$的,实际上远远跑不满,甚至写了个map来做双射也跑过去了.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张有向图,多组询问,每次询问三个数$p , x , y <span class="math inline">\(,求是否能从\)</span>p <span class="math inline">\(出发只经过\)</span>[ x , y ]
$中的边且经过的边的编号单调递减到达$1 $号节点.</p>
<p>冷静一下,先加边,注意到如果加$u v <span class="math inline">\(这条边的时候,不存在一条从\)</span>v $到$1
$的路径,那这条边显然没有用.</p>
<p>做完这一步后,我们注意到可以在加边的过程中对于每个$u <span class="math inline">\(维护从\)</span>u $到$1 <span class="math inline">\(的所有合法路径经过的最小编号的边的最大值\)</span>maxn
_u <span class="math inline">\(,这样就可以对于每个点维护若干个二元组\)</span>( l
, r ) <span class="math inline">\(,只要对于\)</span>p <span class="math inline">\(,存在一个二元组\)</span>[ l , r ] $就合法.</p>
<h5><span id="example4petrozavodskwinter-2014-moscow-su-tapir-contestopenstrain-contest-1435ccombinations-strike-back">Example4([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435)
C]Combinations Strike Back)</span></h5>
<p>给定一个大小为$n <span class="math inline">\(的可重集,多次询问,每次询问查询插入一个数\)</span>x
<span class="math inline">\(后,这个集合大小为\)</span>k <span class="math inline">\(的可重子集共有多少个,每次询问互相独立.\)</span>n ,
q . 2 ^5 $,答案对$1051721729 = 1003 ^{ 20 } + 1 $取膜.</p>
<p>自然的想法是上生成函数.</p>
<p>假设数字$i <span class="math inline">\(在原集合中共有\)</span>b <em>i
<span class="math inline">\(个,那么原集合大小为\)</span>k <span class="math inline">\(的可重子集数量显然为\)</span>[ z ^k ] </em>{ i = 1
} ^n { z - 1 } $.</p>
<p>插入一个数字$x <span class="math inline">\(,自然就是乘上一个\)</span>
{ z ^{ b _x + 1 } - 1 } $.但如果每次都乘的话复杂度显然不行.怎么办?</p>
<p>注意到答案与插入的数字本身无关,只和这个数字在原集合中出现了多少次有关.而原集合最多有$
$(自然根号)个出现次数不同的数字,预处理一下就行.</p>
<h5><span id="example5cf1621gweightedincreasing-subsequences">Example5([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<p>一个自然的想法是拆出每个点$x <span class="math inline">\(的贡献,再枚举终点\)</span>y <span class="math inline">\(,这样问题就转化为了以\)</span>y <span class="math inline">\(结尾并且包含\)</span>x <span class="math inline">\(的LIS计数,这样做到\)</span>O ( n ^2 )
$的复杂度.</p>
<p>那么怎么继续优化呢?我们还是想拆出每个点的贡献,但是如何不枚举终点$y
<span class="math inline">\(呢?我们考虑枚举一下和它做贡献的点\)</span>z
<span class="math inline">\(满足\)</span>a _z &gt; a _x <span class="math inline">\(并且终点\)</span>y <span class="math inline">\(满足\)</span>y &lt; z <span class="math inline">\(,但是这样的\)</span>z <span class="math inline">\(有很多个,不难发现取最后一个就行.如果我们对整个序列取后缀\)</span><span class="math inline">\(,就可以得到所有可能被当作\)</span>z <span class="math inline">\(的点,而且更强的性质是,只要这些点不在LIS中,LIS的终点\)</span>y
<span class="math inline">\(必然有\)</span>y &lt; z <span class="math inline">\(,这是显然的.做一下补集转化,就变成了计数包含\)</span>x
<span class="math inline">\(和\)</span>z $的LIS数量.</p>
<p>注意到$z <span class="math inline">\(的数量不多,且所有数字按照权值排序后被这些\)</span>z
$分成了若干个区间.所以颠倒值域和下标重新做LIS就行.</p>
<h5><span id="example6cf919f-a-game-withnumbers">Example6(CF919F A Game With
Numbers)</span></h5>
<p>最小表示法表示每个人的手牌.</p>
<p>不过要注意有可能成环.我们考虑用刷表法更新,最后刷不出来的点就是和.</p>
<h5><span id="example7ioi2014holiday">Example7([IOI2014]holiday)</span></h5>
<p>首先发现走的一定是一个区间,然后发现这个区间$[ l , r ] <span class="math inline">\(的\)</span>l <span class="math inline">\(随\)</span>r
$的增大具有决策单调性,然后做完了,上主席树就行.</p>
<h5><span id="example8cf1446d2">Example8(CF1446D2)</span></h5>
<p>我们假设目前得到的答案区间是$[ l , r ] <span class="math inline">\(,也就是说\)</span>[ l , r ]
$无论如何不可能扩展成更大的区间了.那这需要满足什么条件呢?注意到全局众数一定是答案,如果它不是答案,我们就可以往两边拓展,直到满足区间众数是答案且区间合法.显然可以实现.然后做根号分治.</p>
<p>这个是怎么想到的呢?我们考虑一个区间如何拓展成更大的区间:如果每个数出现次数不降,显然是一个更大的区间.这同样是在说:如果我们能找到一段区间,使得加上这段区间后,原本不是区间众数的数成为了区间众数,并且区间仍然合法,那就一定更为优秀.再注意到如果一个数在全局出现次数多于区间众数,这一定可以实现,进而推出全局众数的结论.</p>
<p>你以为结束了?没有,我们下面给出一个$O ( n n ) $的做法:</p>
<p>首先,我们假设全局众数是$x <span class="math inline">\(,枚举和它一起成为区间众数的数字\)</span>y
$,剩下的数先不管,那么区间大概长这个样:xyxyyxyxxxxxx.</p>
<p>我们发现这一段x一定是没有意义的:xyxyyxyxx[xxxx].</p>
<p>我们对于每一个$y <span class="math inline">\(出现的位置,找到其左右两边离他最近的没有被标记的\)</span>x
<span class="math inline">\(标记一下,没有被标记的\)</span>x <span class="math inline">\(一定没有意义.这样对于一组解\)</span>( x , y )
<span class="math inline">\(,合法的端点数量只有\)</span>O ( y 出 现 的
次 数 ) <span class="math inline">\(次.每次判断每个端点是否可以做右端点,拿\)</span>set
<span class="math inline">\(维护一下后缀和就可以实现\)</span>O ( n n )
$.</p>
<p>当然,这里得到的区间不一定是合法的(有可能$x , y
$出现的次数都不是最多的,但没关系,这种一定不优秀).</p>
<p>【luoguP4062 [Code+#1]Yazid
的新生舞会】也是这个标记的思路,标记的话用一下链表之类的大概能做.</p>
<h4><span id="支配对问题">支配对问题</span></h4>
<p>lxl起的名字.</p>
<p>这里的思路其实大概就是:我们将一些很废物的二元组杀了,然后将剩下的二元组进行贡献答案.我们称这种一个二元组严格强于另一个二元组的限制称作支配关系.</p>
<h5><span id="第一类支配对">第一类支配对</span></h5>
<p>虽然总数很多,但是本质不同的很少.</p>
<h6><span id="example1luogup7880ynoi2006-rldcot">Example1(luoguP7880
[Ynoi2006] rldcot)</span></h6>
<p>我们这么考虑:如果现在有三个点$a , b , c , a &lt; b &lt; c <span class="math inline">\(,它们两两LCA都是\)</span>d <span class="math inline">\(,那么显然\)</span>( a , c ) <span class="math inline">\(这一对是没有用的,有用的是\)</span>( a , b ) <span class="math inline">\(和\)</span>( b , c ) <span class="math inline">\(.进一步你发现这等价于什么呢:我们从下往上合并子树,每次做启发式合并,假设当前要把子树\)</span>A
<span class="math inline">\(合并到子树\)</span>B <span class="math inline">\(上,考虑所有的点对\)</span>( a , b ) , a A , b B
<span class="math inline">\(的贡献,显然,能贡献到\)</span>a <span class="math inline">\(的\)</span>b <span class="math inline">\(只有\)</span>a <span class="math inline">\(的前驱和后继,这样我们就只找到了\)</span>O ( n n )
<span class="math inline">\(个点对,它们等价于\)</span>O ( n n ) <span class="math inline">\(个矩形,最后把\)</span>dep
$相等的合并一下,随便做做.</p>
<h6><span id="example2luogup8528ynoi2003-铃原露露">Example2(luoguP8528
[Ynoi2003] 铃原露露)</span></h6>
<p>和Example1基本差不多.</p>
<h5><span id="第二类支配对">第二类支配对</span></h5>
<p>虽然总数很多,但是有用的很少.</p>
<h6><span id="example1cf765f">Example1(CF765F)</span></h6>
<p>典.</p>
<h6><span id="example2codechef-minxorseg">Example2(CodeChef MINXORSEG)</span></h6>
<p>这个题比较厉害,仍然考虑$a &lt; b &lt; c <span class="math inline">\(,我们看如果\)</span>a c &gt; { a b , b c }
$的充要条件是什么.</p>
<p>简单分类讨论一下,不难发现这意味着$LCP ( a , c ) &gt; LCP ( a , b )
<span class="math inline">\(.于是有用的贡献对只有\)</span>O ( n v )
$个.</p>
<h6><span id="example3luogu9058-ynoi2004rpmtdq">Example3(Luogu9058 [Ynoi2004]
rpmtdq)</span></h6>
<p>这题更为逆天.</p>
<p>首先,这题有两个维度:树和序列,我们要先处理掉其中一维.lxl:树这一维度更加困难,因此我们应该是选择困难的那一维分治掉.</p>
<p>考虑边分治,然后就只需要处理两棵子树间的贡献.但是对于一棵子树内的点,我们要找到在另一棵子树中有可能和它产生贡献的点对,这个咋做呢?</p>
<p>牛逼的一步来了,我们考虑对于每个点,算出它到分治中心的距离$r <span class="math inline">\(,然后找另一棵子树中到分治中心距离\)</span>r <span class="math inline">\(的点\)</span>x <span class="math inline">\(与它贡献,但是这还是有很多点,其实只需要找这些点中的\)</span>x
<span class="math inline">\(的前驱后继就可以了.因为如果\)</span>x &lt; b
&lt; c <span class="math inline">\(,\)</span>b <span class="math inline">\(和\)</span>c <span class="math inline">\(在同一边,那么\)</span>( b , c ) <span class="math inline">\(一定比\)</span>( a , c ) $更加优秀.</p>
<h6><span id="example4cf1635f-closestpair">Example4(CF1635F Closest
Pair)</span></h6>
<p>首先,由于匹配无序,我们考虑对于一对数$( i , j ) <span class="math inline">\(,只在\)</span>w $较大的那个位置来更新答案.</p>
<p>不妨假设较大的为$i <span class="math inline">\(,我们考虑\)</span>i
$有可能和谁来更新答案.</p>
<p>如果现在有两个数$k &lt; j , w _k w _i w _j w _i <span class="math inline">\(,如果\)</span>w _k w _j <span class="math inline">\(,那肯定选\)</span>( j , i ) <span class="math inline">\(更优秀;不然,如果选\)</span>( k , i ) <span class="math inline">\(比选\)</span>( j , i ) <span class="math inline">\(更优秀,那么我们会发现\)</span>( k , j ) <span class="math inline">\(比\)</span>( k , i ) <span class="math inline">\(更要优秀,因此答案一定会由\)</span>( k , j ) <span class="math inline">\(更新而不是由\)</span>( k , i ) <span class="math inline">\(更新.通过这里的分析我们发现,每个数只有可能和它左右两边的第一个\)</span>w
$小于等于它的数更新.</p>
<p>于是我们可以找到$O ( n ) <span class="math inline">\(个可能更新答案的点对,设点对为\)</span>( x , y )
<span class="math inline">\(,我们每次查找一个区间\)</span>[ l , r ]
<span class="math inline">\(,即要找到所有在\)</span>[ l , r ]
$内的点对并将它们的答案取min.</p>
<p>这一步可以将$( x , y ) <span class="math inline">\(当作二维平面的点,查询当作一个左下角为\)</span>( l
, l ) <span class="math inline">\(,右上角为\)</span>( r , r )
$的矩阵,就是一个经典的矩阵取min的操作.</p>
<h6><span id="example5icpc2017wfmoney-for-nothing">Example5([ICPC2017
WF]Money for nothing)</span></h6>
<p>注意到抽象问题后等价于有若干个A点$( x _1 , y _1 ) <span class="math inline">\(和若干个B点\)</span>( x _2 , y _2 ) <span class="math inline">\(,我们想要找到一个A点和一个B点使得\)</span>( x _1 -
x _2 ) ( y _1 - y _2 )
$最大.也就是它们作为右上和左下顶点的矩形面积最大.</p>
<p>怎么做这个问题呢?首先我们必须要发现的一点是:对于A点来说,如果有两个点$(
a _1 , b _1 ) <span class="math inline">\(和\)</span>( a _2 , b _2 )
<span class="math inline">\(满足\)</span>a _1 a _2 <span class="math inline">\(,\)</span>b _1 b _2
$,那么前者一定更优秀.把那些废点删掉后,就会得到一个横坐标递增,纵坐标递减的点的序列.对于B点是同理的.</p>
<p>这个序列看上去就很亲切了,接下来简单证明一下是满足决策单调性的就可以判断答案了.</p>
<h3><span id="奇偶染色">奇偶染色</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一个$9 $的网格,一开始上面有$65
$个蚂蚁,每个蚂蚁每分钟会四联通移动一格,每个蚂蚁每三分钟所在的格子不能在一条直线上,求证:一定会有一个时间,两只蚂蚁在同一个格子里.</p>
<p>sol1:</p>
<p>注意到如果条件不成立,则一定存在若干条路径,蚂蚁在路径上转圈,也就是找到长度和尽可能大的路径不交地覆盖矩阵,注意到一定是使用$2
$的矩阵路径,于是最多有$64 $只蚂蚁.(感性理解)</p>
<p>sol2:</p>
考虑对奇偶染色,设$( i , j ) =
<span class="math display">\[\begin{cases}white &amp; 2 \nmid ( i + j )
\\ blue &amp; 2 \mid i \land 2 \mid j \\ yellow &amp; \text {
otherwise  } \end{cases}\]</span>
<p>$.</p>
<p>我们把黄格子和蓝格子称为彩格子,注意到如果一开始一只蚂蚁在白格子,一分钟后必定在彩格子.一开始一只蚂蚁在蓝格子,两分钟后必定在黄格子.</p>
<p>因为最多有$16 $个蓝格子,所以一开始黄格子和蓝格子上分别最多有$16
$只蚂蚁,从而白格子上最多有$32 $只蚂蚁,总共最多$64 $只,得证.</p>
<h5><span id="example2cf1521e">Example2(CF1521E)</span></h5>
<p>首先考虑我们显然可以一行空一行放,也就是说如果最大的$a _i &gt; n { 2 }
<span class="math inline">\(的话显然不可以,如果能放的位置少于\)</span>a
$显然也不可以.</p>
<p>类似lyz那个题,我们考虑删去行列编号均为偶数的点,这样就满足了一个子矩阵不能全放的限制.</p>
<p>然后呢?我们考虑将所有能放的位置排序.先把所有的位置分成三类:$( , ) , (
, ) , ( , ) <span class="math inline">\(,不同类位置按照这个顺序排,不然按照相对位置排.然后直接从头开始放.如果不合法,一定是同种颜色放到了\)</span>(
, ) <span class="math inline">\(和\)</span>( , ) <span class="math inline">\(,并且相同类别是按照相对位置排序的,于是一定不满足最大的\)</span>a
_i n { 2 } $的限制条件.所以这么做一定是对的.</p>
<p>好!冷静一下,咋想到的啊.</p>
<p>首先这种题肯定要找到一些看上去就很显然的边界,当你发现找不到的时候,大概率就一定有解了(大概率).</p>
<p>然后呢?注意到不合法一定是同种颜色放到了$( , ) <span class="math inline">\(和\)</span>( , )
$,又观察到每种位置的数量和一个边界限制条件很像,于是就可以构造出来了.</p>
<p>所以大概是说,这种构造题要先想判断边界的条件,然后对着做.</p>
<h5><span id="example3cf1615f">Example3(CF1615F)</span></h5>
<p>太牛逼了这个题.</p>
<p>首先,找边界条件:啥时候$s <span class="math inline">\(不能变成\)</span>t $呢?一个自然的想法是数$1
$的个数的奇偶性,但这样显然不对($01 $和$10
$不能互相转移),我们需要一个更强的条件.</p>
<p>然后:注意到每次操作是相邻的两个数,于是我们有:奇数位置的和-偶数位置的和是定值.但是:注意到这个操作是有限制的!它只能对相邻相同的位置做.</p>
<p>然后我也不知道咋想到的,可能是因为找到限制条件后只要不改变限制条件就可以随便转化?反正我们先把偶数位置全部取反,这样操作就变成了交换相邻数字(如果相邻数字不相同,取反后相同,交换无用).</p>
<p>就可以dp了.</p>
<h5><span id="example4cf1517g">Example4(CF1517G)</span></h5>
<p>按照横纵坐标的奇偶性,分四种情况染色.注意到四边形接下来的路径一定会形如$1
$,建立分层图跑最小割.</p>
<h3><span id="捆绑更新答案">捆绑更新答案</span></h3>
<h5><span id="example12022qbxt国庆day6binary">Example1([2022qbxt国庆Day6]binary)</span></h5>
<p>首先因为有$- 1 <span class="math inline">\(,我们先考虑一个朴素的暴力,从\)</span>L <span class="math inline">\(到\)</span>R <span class="math inline">\(枚举现在被匹配的数\)</span>i <span class="math inline">\(,我们假设之前匹配到\)</span>p - 1 <span class="math inline">\(,那我们接下来一定是要找到一个最小的\)</span>x p
<span class="math inline">\(能把\)</span>i <span class="math inline">\(给匹配掉,仔细思考这个过程,由于是二进制考虑最高位,不难发现我们只需要找到\)</span>(
p i ) i $的最高位$1 <span class="math inline">\(,然后把\)</span>p
$的这一位改成$1 $,然后后面的位置全部设成$0 <span class="math inline">\(,如果\)</span>i p $那么就不用改.</p>
<p>冷静一下,二进制大概率是没啥通项公式的,还是要一点一点做.但是我们枚举每一个数实在是太慢了,我们考虑一个地方:$i
p <span class="math inline">\(就不用改,下一步\)</span>i + = 1 , p + = 1
$,如果没有发生进位还是不用改,这个过程看上去就很可以优化.</p>
<p>所以我们考虑:当遇到$i p <span class="math inline">\(的时候,我们就捆绑更新.如果不满足就暴力更新.重复这个过程,每次不断暴力更新\)</span><span class="math inline">\(捆绑更新\)</span><span class="math inline">\(暴力更新\)</span>. . . <span class="math inline">\(.每次捆绑更新至少会更新一个\)</span>lowbit <span class="math inline">\(,而暴力更新的情况下,每次\)</span>p <span class="math inline">\(至少会多包含一位\)</span>i <span class="math inline">\(.就算后面进位把这一位消掉了,由于这里进位了,那下一步一定可以直接包含掉,于是复杂度也是\)</span>n
<span class="math inline">\(的,反复做一下就做完了,这里能分析复杂度\)</span>O (
T ^2 R )
$.我们冷静一下,发现二者复杂度算重了,捆绑更新会帮助暴力更新多匹配$1 <span class="math inline">\(,于是复杂度\)</span>O ( T R ) <span class="math inline">\(.但是肯定跑不满,考场甚至写了个上界\)</span>O ( T
^2 R ) $的仍然跑的飞快.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树和一个值域为$n <span class="math inline">\(序列\)</span>a
<span class="math inline">\(,每次询问给出\)</span>l , r , x $.</p>
<p>设$f ( x , y ) <span class="math inline">\(为点\)</span>x <span class="math inline">\(朝着\)</span>y <span class="math inline">\(的方向走一步后得到的点,求\)</span>x <span class="math inline">\(在经过\)</span>a [ l r ] $操作后得到的答案.</p>
<p>这么考虑:这题看上去就需要把任何一个数字$x <span class="math inline">\(,通过若干个点变成了一个\)</span>f ( x ) <span class="math inline">\(,我们要做的就是把\)</span>f ( x ) <span class="math inline">\(求出来,这玩意很难求,考虑分块,单点用长剖做\)</span>O
( 1 ) <span class="math inline">\(求\)</span>k <span class="math inline">\(级祖先,然后对于每个整块预处理出它的\)</span>f
$就可以了.</p>
<p>接下来的问题在于如何快速处理一个块的答案,考虑把所有的$x <span class="math inline">\(扔到树上,然后一起维护它们的\)</span>f ( x )
$.这玩意看上去好像有点不太能做.</p>
<p>牛逼的一步来了:考虑对于每个块内的$ <span class="math inline">\(个点,建立这些点的虚树,对于不在虚树上的点,它们一定会往虚树的方向跑(其实也就是向上跑),然后处理出时间扫描线转化成在虚树上的点的问题.对于在虚树上的点,考虑虚树一共有\)</span>O
( ) <span class="math inline">\(条边(也就是原树上的路径),我们用一个双端队列维护每条边上的点,显然每次每条边只会有\)</span>O
( 1 ) <span class="math inline">\(的入队和出队,这样就实现了\)</span>O (
n ) $的预处理单个块.</p>
<h3><span id="单独更新答案">单独更新答案</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一个数轴上有$n <span class="math inline">\(个小球,第\)</span>i <span class="math inline">\(个小球在\)</span>x _i <span class="math inline">\(坐标处.数轴上还有\)</span>m <span class="math inline">\(个洞.第\)</span>i <span class="math inline">\(个洞在\)</span>y _i
$坐标处.你每秒可以以相同矢量速度移动所有小球.当一个小球和一个洞重合时,小球就会进洞.求一共可能出现多少种最终情况.(我们认为,两种”最终情况”不同,当且仅当存在一个球在两种情况中进入了不同的魔法洞中)</p>
<p>考场的想法:按照洞分类,把被同样两个洞夹起来的球一起处理,显然会有一段区间往左走一段区间往右走,按照这种区间的长度排序,然后硬dp,复杂度$O
( n ^3 ) $.</p>
<p>实际的做法:我们抛弃区间,单独考虑每个球.对于每个球而言,有用的信息只有它到左端点的距离和它到右端点的距离.我们把这两个距离缩为$(
x _i , y _i ) $.接下来我们要给每个点$0 / 1 $染色,如果是$0
$代表它要到左边的洞里,如果是$1
$代表要到右边的洞里.那什么染色条件是无解的呢?</p>
<p>如果存在两个点$a <span class="math inline">\(和\)</span>b <span class="math inline">\(,\)</span>col _a = 0 <span class="math inline">\(,\)</span>col _b = 1 <span class="math inline">\(,那显然当\)</span>x _a x _b y _a y _b <span class="math inline">\(时无解.换句话说,如果\)</span>col _b = 1 x _a x _b
y _a y _b <span class="math inline">\(,那么\)</span>col _a = 1 <span class="math inline">\(.我们不妨按照\)</span>x <span class="math inline">\(降序排序,\)</span>x <span class="math inline">\(相同的按照\)</span>y <span class="math inline">\(升序排列.那就会先决定\)</span>b <span class="math inline">\(再决定\)</span>a <span class="math inline">\(.注意到:如果\)</span>a <span class="math inline">\(能确定\)</span>c <span class="math inline">\(的状态,那\)</span>b <span class="math inline">\(一定也能确定\)</span>c <span class="math inline">\(的状态.因此我们采取这个策略:如果\)</span>x _a x _b
y _a y _b col <em>b = 1 <span class="math inline">\(,那我们直接不管\)</span>a <span class="math inline">\(;反之,则考虑一下\)</span>a <span class="math inline">\(的两种取值即可.具体一点,我们设\)</span>f </em>{ i
, 0 / 1 } <span class="math inline">\(表示以\)</span>i <span class="math inline">\(结尾,\)</span>col _i = 0 / 1 <span class="math inline">\(的方案数,然后顺着做就好.注意到:我们其实不关心\)</span>col
_x $具体是啥,我们只关心最后的方案数.所以其实可以直接删去第二维.</p>
<p>zhq对这题的理解:</p>
<p>这可以等价成求一个上升子序列.上升子序列说的是如果$x _i &lt; x _j , y
_i &gt; y _j <span class="math inline">\(,\)</span>i <span class="math inline">\(&quot;选了&quot;,\)</span>j <span class="math inline">\(就必须&quot;不选&quot;.但是钦定必须选和必须不选,这两个限制是一样的.就是说,\)</span>j
$没有选择的权力了.</p>
<p>这个说法很有意思,但是要注意:类似说法成立当且仅当我们认为$j <span class="math inline">\(选了和认为\)</span>j $没选对后面不会产生影响.</p>
<h5><span id="example2petrozavodsksummer-2015-moscow-ipt-contestopenstrain-contest-1464-jtwoairlines">Example2([Petrozavodsk
Summer-2015. Moscow IPT Contest(openstrain contest 1464) J]Two
Airlines)</span></h5>
<p>这是一道交互题.给定一张$n
$个点的完全图,每两个点之间是红色的边或是蓝色的边.可以询问$2 n
$次某两个点之间的边的颜色,求一条哈密顿回路使得这条路上的颜色段最多有两个.</p>
<p>考虑将点逐个加入.假设现在的哈密顿回路的两种颜色分别是$r _s r _t <span class="math inline">\(和\)</span>b _s b _t <span class="math inline">\(,当前要加入\)</span>x <span class="math inline">\(,我们每次询问\)</span>x <span class="math inline">\(和\)</span>r _t <span class="math inline">\(和\)</span>b _t <span class="math inline">\(之间的颜色,如果可以加入链就加入.如果不能加入,必然意味着\)</span>x
<span class="math inline">\(和\)</span>r _t <span class="math inline">\(之间是蓝边,和\)</span>b _t <span class="math inline">\(之间是红边,我们查一下\)</span>r _t <span class="math inline">\(和\)</span>b _t <span class="math inline">\(之间是什么边,然后将其中一个点与\)</span>x
$一起扔到对面就行.</p>
<p>不过这样用了$3 n <span class="math inline">\(次询问,考虑先询问\)</span>r _t <span class="math inline">\(和\)</span>b _t $之间的颜色,这样就能省掉一种.</p>
<h3><span id="寻找不变量">寻找不变量</span></h3>
<h5><span id="example1noip2021-方差">Example1([NOIP2021] 方差)</span></h5>
<p>首先我们注意到:设$b <em>i = a <em>i - a </em>{ i - 1 } <span class="math inline">\(这个操作相当于交换\)</span>b </em>{ i - 1 } <span class="math inline">\(和\)</span>b _i $.</p>
<p>接下来推一下式子:</p>
<p><span class="math display">\[
\begin{aligned}
n ^2 S ^2 &amp; = n \sum _{ i = 1  } ^n a _i ^2 - ( \sum _{ i = 1  } ^n
a _i ) ^2 \\
&amp; = n \sum _{ i = 1  } ^n ( \sum _{ j = 1  } ^i b _j ) ^2 - ( \sum
_{ i = 1  } ^n ( n - i + 1 ) b _i ) ^2 \\
&amp; = n \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i b _j \sum _{ k = 1  }
^i b _k - \sum _{ j = 1  } ^n ( n - j + 1 ) b _j \sum _{ k = 1  } ^n ( n
- k + 1 ) b _k \\
&amp; = n \sum _{ j = 1  } ^n b _j \sum _{ k = 1  } ^n b _k \times ( n -
\max \{ j , k \} + 1 ) - \sum _{ j = 1  } ^n ( n - j + 1 ) b _j \sum _{
k = 1  } ^n ( n - k + 1 ) b _k \\
&amp; = n \sum _{ j = 1  } ^n b _{ n - j + 1  } \sum _{ k = 1  } ^n b _{
n - k + 1  } \times \min \{ j , k \} - \sum _{ j = 1  } ^n jb _{ n - j +
1  } \sum _{ k = 1  } ^n kb _{ n - k + 1  }
\end{aligned}
\]</span></p>
<p>令$c <span class="math inline">\(为\)</span>b $的倒置数组,则原式</p>
<p><span class="math display">\[
\begin{aligned}
&amp; = n \sum _{ j = 1  } ^n c _{ j  } \sum _{ k = 1  } ^n c _{ k  }
\times \min \{ j , k \} - \sum _{ j = 1  } ^n jc _{ j  } \sum _{ k =
1  } ^n kc _{ k  } \\
&amp; = 2 \sum _{ j = 1  } ^n nc _j \sum _{ k = 1  } ^j c _k k - 2 \sum
_{ j = 1  } ^n jc _{ j  } \sum _{ k = 1  } ^j kc _{ k  } + \sum _{ i =
1  } ^n c _i ^2 i ( i - 1 ) \\
&amp; = 2 \sum _{ j = 1  } ^n ( n - j ) c _j \sum _{ k = 1  } ^j c _k k
+ \sum _{ i = 1  } ^n c _i ^2 i ( i - 1 ) \\
&amp; = \sum _{ j = 1  } ^n ( n - j ) c _j \sum _{ k = 1  } ^n c _k k +
\sum _{ i = 1  } ^n ( n - 1 ) ic _i ^2
\end{aligned}
\]</span></p>
<p><del>推到这一步发现好像没啥用但是推了好久懒得删了</del></p>
<p>冷静一下,由于一开始的数列是单调递增的,所以改变后的数列一定也是单调递增的(差分数组均$
$).感性上理解,我们肯定是想让尽可能多的数接近绝对值,于是让重新排列后的差分数组呈现单最小值的峰看上去就很优秀.</p>
<p>这样我们设计$dp _{ i , S } <span class="math inline">\(表示现在填到第\)</span>i <span class="math inline">\(小的\)</span>b <span class="math inline">\(,\)</span>a = S <span class="math inline">\(的情况下最小的\)</span>a ^2 <span class="math inline">\(,复杂度\)</span>O ( n ^2 a ) $.</p>
<p>注意到$a <span class="math inline">\(很小的时候大部分\)</span>b
$都是$0 <span class="math inline">\(,于是可以优化为\)</span>O ( na ^2 )
$.</p>
<h5><span id="example2agc030e-less-than3">Example2([AGC030E] Less than
3)</span></h5>
<p>注意到:当我们把一个位置取反的时候,这个位置相邻的左右两个位置一定有一个$0
$和一个$1 $,所以我们的操作等价于移动$0 $和$1 $的分界线.</p>
<p>然后枚举一下从边界多产生了多少个分界线就行.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1arc110d">Example1(ARC110D)</span></h5>
<p>注意到这相当于先把一个长度等于$m <span class="math inline">\(的序列划分成\)</span>n + 1 <span class="math inline">\(段,再从第\)</span>i <span class="math inline">\(段选出\)</span>a <em>i <span class="math inline">\(,其中\)</span>a </em>{ n + 1 } = 0 $.</p>
<p>于是自然是$ { a + n } $.</p>
<h5><span id="example2abc231g">Example2(ABC231G)</span></h5>
<p>乍一看,感觉完全不可做.因为一开始给定$a
$了,感觉上好像也不太能组合意义.</p>
<p>如果没有$a _i <span class="math inline">\(怎么做?我们设\)</span>f _n
<span class="math inline">\(表示将\)</span>k <span class="math inline">\(个小球分到\)</span>n <span class="math inline">\(个盒子后的答案.那乘法相当于:分完后,在每个盒子中取出一个小球的方案数.于是\)</span>f
_n = { n } n ! n ^{ k - n } $.</p>
<p>那给定$a <span class="math inline">\(咋做呢?我们注意到上面的式子好像可以对于任意\)</span>n
<span class="math inline">\(快速求.于是将原式子拆为:\)</span>( a _i + b
_i ) <span class="math inline">\(,那答案就是选出\)</span>n - x <span class="math inline">\(个\)</span>a <span class="math inline">\(和选出\)</span>x <span class="math inline">\(个\)</span>b <span class="math inline">\(的答案.前者可以背包,后者也就是\)</span>f _x = { x
} x ! n ^{ k - x } $.</p>
<h5><span id="example3agc060d">Example3(AGC060D)</span></h5>
<p>不妨设$C _p = { i | p <em>i &gt; p </em>{ i + 1 } , 1 i &lt; n }
$.</p>
<p>用一下组合意义,注意到答案等于:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2
\]</span></p>
<p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2 = \sum _{ S  } ( \sum _{ S
\subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C
_p ] ) ^2
\]</span></p>
<p>这个咋做呢?我们考虑用组合意义展开:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | -
| S |  } [ T \subseteq C _p ] ) ^2 \\
&amp; = \sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T
_1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [
T _2 \subseteq C _p ] )
\end{aligned}
\]</span></p>
<p>注意到$S $屁用没有,直接交换枚举顺序.</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + |
T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2
\subseteq C _p ] ) \\
&amp; = \sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T
_1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [
T _2 \subseteq C _p ] )
\end{aligned}
\]</span></p>
<p>考虑$( _{ p } [ T _1 C _p ] ) <span class="math inline">\(怎么求,注意到这等价于所有\)</span>T _1 <span class="math inline">\(中的位置全都被钦定为\)</span>&gt; <span class="math inline">\(,而其他位置任意,如果我们设所有以大于号连接的部分的长度为\)</span>l
_1 , l _2 , . . . , l <em>k <span class="math inline">\(,那么这里的答案就是\)</span>n ! </em>{ i = 1 } ^k
{ l _i ! } $.</p>
<p>但我们很快发现了难点:$2 ^{ | T _1 T _2 | }
$这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在$T _1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(中都是\)</span>&gt; <span class="math inline">\(的位置,这个好像不太好求,因为\)</span>&gt;
$是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | +
| T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2
\subseteq C _p ] ) \\
&amp; = \sum _{ T _1 , T _2  } 2 ^{ ( ( n - 1 ) - | T _1 \cup T _2 | ) -
( n - 1 )  } ( - 2 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1
\subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
&amp; = 2 ^{ 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1
|  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 )
^{ | T _2 |  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - |
T _1 \cup T _2 |  }
\end{aligned}
\]</span></p>
<p>其中$n - 1 - | T _1 T _2 | <span class="math inline">\(意味着均不在\)</span>T _1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(中的位置的数量.为了给每一段连续的\)</span>&gt;
$都分配权值,我们进行一个细小的修改:</p>
<p><span class="math display">\[
2 ^{ - 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 | + 1  }
\frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ |
T _2 | + 1  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T
_1 \cup T _2 |  }
\]</span></p>
<p>写到这里应该就能发现,接下来必然要对$n - 1 - | T _1 T _2 | <span class="math inline">\(做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对\)</span>T
_1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了\)</span>&gt;
$,我们自然有:</p>
$$
<span class="math display">\[\begin{gathered}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T
_1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  }
( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{
2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时$| T _1 T _2 |
<span class="math inline">\(这个限制就显得尤其强,如果只是\)</span>S T _1
, T _2 <span class="math inline">\(就会好做很多:我们可以钦定\)</span>S
$作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
$$
<span class="math display">\[\begin{aligned}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T
_1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  }
( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{
2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\
&amp; = 2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } \sum _{ S \subseteq T
_1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } {
\prod l _{ 1 , i  } !  } ) \sum _{ S \subseteq T _2  } ( \frac { 1  } {
( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>令$f ( T ) = <em>{ S T } ( { ( - 2 ) ^{ | T | + 1 } } { l </em>{ 2 ,
i } ! } ) \ $,则原式即:</p>
<p><span class="math display">\[
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } ( \sum _{ S \subseteq T  } f ( T )
) ^2
\]</span></p>
<p>考虑下面这个东西怎么求:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2
\]</span></p>
<p>注意到,如果我们把每一段($[ T <em>i , T </em>{ i + 1 } ) <span class="math inline">\()的贡献求和,那么\)</span>f ( T ) <span class="math inline">\(相当于这些和乘起来,那么\)</span>( <em>{ S T } f (
T ) ) ^2 <span class="math inline">\(就是这些和的平方乘起来.换句话说,我们自然有\)</span>ans
<em>n = </em>{ m } ans </em>{ n - m } g ^2 _{ m } <span class="math inline">\(,其中\)</span>g <em>m <span class="math inline">\(表示长度为\)</span>m <span class="math inline">\(的一段的贡献之和.而\)</span>g </em>{ n } = <em>m g
</em>{ n - m } { - 2 m ! } <span class="math inline">\(.二者都可以使用分治FFT或多项式求逆解决.更进一步地,\)</span>h
_i = { - 2 i ! } , G = { 1 - H } , F = { 1 - G } $.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将$( &gt; , &gt; ) $容斥掉,这样我们有若干种对:$2 ( &lt;
, &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e ) <span class="math inline">\(,然后我们发现两个序列联系得太紧了,我们考虑分配系数:\)</span>&lt;
<span class="math inline">\(,\)</span>e - { } <span class="math inline">\(,但是这样发现\)</span>( e , e )
$算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h3><span id="复杂度抵消">复杂度抵消</span></h3>
<h5><span id="example1cf1439b">Example1(CF1439B)</span></h5>
<p>首先注意到度数小于$k - 1 <span class="math inline">\(的点一定没用,于是可以不断删点.删点后的图度数全部\)</span>k
- 1 $.</p>
<p>首先如果剩下的点度数全都$k <span class="math inline">\(那就直接找到答案,不然,我们看一下度数为\)</span>k -
1 <span class="math inline">\(的点:它要么在团里,要么没用.不妨直接暴力判断是否在团里,复杂度\)</span>O
( k ^2 ) $.</p>
<p>欸等一下,这总复杂度$O ( mk ^2 ) $了啊,这咋办?</p>
<p>首先,删完点后的度数全都$k - 1 <span class="math inline">\(,注意到此时的点数是\)</span>O ( { k } ) <span class="math inline">\(的.所以复杂度\)</span>O ( mk ) $.</p>
<p>好像还是过不去,这咋办?</p>
<p>冷静一下,如果$k <span class="math inline">\(,显然不可能存在团.于是复杂度\)</span>O ( m )
$.</p>
<h3><span id="寻找关系式">寻找关系式</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一张有向图,边有两种颜色,从$s <span class="math inline">\(开始随机游走,维护一个权值.经过第一种颜色的边,权值\)</span>+
1 $.经过第二种颜色的边,权值归$0 <span class="math inline">\(.保证\)</span>t <span class="math inline">\(没有出边,所有点均能到\)</span>t <span class="math inline">\(.询问到\)</span>t <span class="math inline">\(时权值的期望和方差.\)</span>n $.</p>
<p>(注意方差为平方的期望减去期望的平方.)</p>
<p>注意到难点在于权值归$0 <span class="math inline">\(.所以一个点到\)</span>t
$的期望权值一定和到达它时的权值有关系.</p>
<p>然后就来到了降维打击的时间:我们可以使用数学归纳法证明,如果到一个点$u
<span class="math inline">\(的权值是\)</span>x <span class="math inline">\(,那它到达\)</span>t <span class="math inline">\(的权值一定形如\)</span>a _u x + b _u $.</p>
<p>如果要严谨一点的话,我们发现第一种颜色的边会影响常数项,第二种颜色的边会影响一次项,因此最后的答案一定是一次函数.</p>
<p>最后可以使用高斯消元直接求出每个点权值的$a _u <span class="math inline">\(和\)</span>b _u $,就可以求出期望.</p>
<p>至于方差是同理的,你注意到平方的期望一定是一个二次函数.</p>
<h3><span id="特判边界">特判边界</span></h3>
<h5><span id="example12022icpc杭州e">Example1(2022ICPC杭州E)</span></h5>
<p>第一反应肯定是一点一点调整成${ 1 , 2 , . . . , n } <span class="math inline">\(的形式,写个暴力验证一下发现当\)</span>n
$的时候的确都可以调整成功.</p>
<p>假设目前形如:$[ 1 , k ] , A , k + 1 , B $.我们考虑如何调整:</p>
<ol type="1">
<li>$| B | $.</li>
</ol>
<p>我们有:</p>
<p><span class="math display">\[
\{ [ 1 , k ] , A , k + 1 , B \} \rightarrow \{ B , A , k + 1 , [ 1 , k ]
\} \rightarrow \{ [ 1 , k + 1 ] , B , A \}
\]</span></p>
<ol start="2" type="1">
<li>$| B | = 0 , | A | = 0 $.</li>
</ol>
<p>直接合并就行.</p>
<ol start="3" type="1">
<li>$| B | = 0 , | A | $.</li>
</ol>
<p>假设$A = A _1 A _2 $,我们有:</p>
<p><span class="math display">\[
\{ [ 1 , k ] , A _1 , A _2 , k + 1 \} \rightarrow \{ A _2 , k + 1 , A _1
, [ 1 , k ] \} \rightarrow \{ [ 1 , k + 1 ] , A _1 , A _2 \}
\]</span></p>
<ol start="4" type="1">
<li>$| B | = 0 , | A | = 1 $.</li>
</ol>
<p>此时一定有$k <span class="math inline">\(,发现有点难构造,但是我们猜测是可以构造出来的.不难证明这个问题等价于将\)</span>{
1 , 2 , 4 , 3 } <span class="math inline">\(调整为\)</span>{ 1 , 2 , 3 ,
4 } $,写个暴力跑一下就行.</p>
<h3><span id="摩尔投票">摩尔投票</span></h3>
<h5><span id="example1cf643gchoosing-ads">Example1([CF643G]Choosing Ads)</span></h5>
<p>将摩尔投票扩展一下.我们现在想求其中出现次数大于等于$ { p } <span class="math inline">\(的数字,令\)</span>k = { p } <span class="math inline">\(,我们考虑每次取出\)</span>k + 1
$个两两不同的数字并且全部杀掉,那么做完这一步操作后,该满足条件的仍然满足条件(讨论一下),于是拿线段树维护当前的五个数的出现数量,每次对着杀就行.</p>
<h3><span id="寻找周期性">寻找周期性</span></h3>
<h5><span id="example1cf1463fmax-correctset">Example1([CF1463F]Max Correct
Set)</span></h5>
<p>自然的想法是$O ( n 2 ^{ ( x , y ) } ) $作dp.</p>
<p>接下来比较牛逼的是,注意到如果$S _1 <span class="math inline">\(满足条件,令\)</span>m = x + y <span class="math inline">\(那么\)</span>S _1 ( S _1 + m ) $也满足条件.</p>
<p>我们考虑$S _1 <span class="math inline">\(中满足条件意味着什么,意味着\)</span>a , b S _1 , a
&lt; b <span class="math inline">\(,\)</span>b - a x b - a y <span class="math inline">\(,这意味着\)</span>m + b - a x m + b - a y <span class="math inline">\(,这同样意味着\)</span>m + a - b = x + y + a - b x
+ y - x m + a - b x + y - y $.</p>
<p>因此,只要我们找到了一个长度为$m
$的可行解,我们一定可以将其不断扩展到全部集合.</p>
<p>进一步地,我们一定能证明:原集合中的最优解是以一个长度为$m
$的可行解作为周期的.</p>
<p>这个是为啥呢?我们设$n = km + c <span class="math inline">\(,那么我们直接求出一个长度为\)</span>m <span class="math inline">\(的解,满足前\)</span>c <span class="math inline">\(位对答案的贡献的权值是\)</span>k + 1 <span class="math inline">\(,后\)</span>m - c <span class="math inline">\(位贡献的权值为\)</span>k
$,然后直接求答案.注意到如果最大答案另有其人,我们一定可以拿其中的某一段不断循环得到更大的答案,这就不符合我们的假设了.</p>
<h3><span id="补集转化">补集转化</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个$n <span class="math inline">\(个点\)</span>m
$条边的无向图,求给每一条边定向使得$1 $和$2 $能到达同一个点(可以是$1
$或$2 <span class="math inline">\()的方案数.\)</span>n , m { 2 } $.</p>
<p>考虑正难则反,算不存在的概率(事实上也确实很好理解,因为存在性问题通常都要取补集),这时候我们发现:此时$1
<span class="math inline">\(能到达一个集合\)</span>S $,$2 <span class="math inline">\(能到达一个集合\)</span>T <span class="math inline">\(,\)</span>S <span class="math inline">\(和\)</span>T <span class="math inline">\(无交,并且两个集合之间不可能存在边,因此我们只需要算\)</span>f
( S ) $表示$1 <span class="math inline">\(能到达\)</span>S
$中的点的方案数即可,$2 $同理.</p>
<p>那么这个怎么算呢?我们仍然考虑正难则反,如果$1 <span class="math inline">\(不能到达\)</span>S $中的所有点,那么$1 <span class="math inline">\(一定只能到达\)</span>S <span class="math inline">\(中的一部分点,枚举这一部分,假设是\)</span>T <span class="math inline">\(,就可以用\)</span>f ( T ) <span class="math inline">\(算\)</span>f ( S ) $的答案.</p>
<h3><span id="二进制分组">二进制分组</span></h3>
<h5><span id="example1loj3273">Example1(loj3273)</span></h5>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点$(
x , y ) <span class="math inline">\(,随着\)</span>x <span class="math inline">\(的增大\)</span>y
$不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.我们使用二进制分组,将所有点分为大小为$0 , 1 ,
2 , 4 , , 2 ^k
$大小的组,当然有些组可能没被分出来.然后如果有两个大小都是$2 ^k
$的组,我们暴力合并二者,得到一个还没被折线扫过的新的大小为$2 ^{ k + 1 }
$的组.</p>
<h5><span id="example2luogu7447ynoi2007-rgxsxrs">Example2(Luogu7447
[Ynoi2007] rgxsxrs)</span></h5>
<p>一眼看上去和CF702F很像,但是区间操作感觉很艰难,怎么做呢?</p>
<p>我们对值域分块:分成$[ 0 , 1 ) , [ 1 , 2 ) , [ 2 , 4 ) , [ 4 , 8 ) ,
<span class="math inline">\(,这样只会分成\)</span>V <span class="math inline">\(段,每段内部维护平衡树来处理下标.那么对于一个\)</span>x
<span class="math inline">\(,它会把后面的段全部打上一个\)</span>tag
<span class="math inline">\(,有些位置要掉落到下面的段上,这个维护每个段的最小值就可以处理(最多只会掉落\)</span>n
<span class="math inline">\(段),问题是和\)</span>x
$在同一块内的没有办法打tag,但这一部分一定会掉落到下面的段,一块处理.</p>
<p>好,下面开始思想总结:</p>
<p>首先,我们发现这个区间和值域都很难处理,但是感觉值域更加重要,应该是对值域做均摊(也就是类似CF702F的打tag操作和暴力修改操作分开),于是考虑到对值域分块然后内部平衡树,然后发现可以做了吧.不太清楚,也有可能只是值域分块的套路.</p>
<p>Luogu9069是同款思路,判一下负数.</p>
<h5><span id="example3cf1515i-phoenixand-diamonds">Example3(CF1515I Phoenix
and Diamonds)</span></h5>
<p>俗称带修T-shirt.</p>
<p>做法大概是这样的:我们考虑对于每次给出的$c <span class="math inline">\(,不妨假设它在\)</span>[ 2 ^k , 2 ^{ k + 1 } )
$这个块上,那么如果它减去了任何一个还在这个块里的数字,那就一定会掉落到下一个块中.这样就又有均摊了.</p>
<p>但是我们不一定能减去一个还在这个块里的数字,我们怎么做呢?</p>
<p>我们考虑最后的操作一定是减去若干个小于这个块的,最后有可能再减去一个这个块的,然后$c
<span class="math inline">\(就掉到了下一个块,考虑先按照价值排序,然后维护\)</span>f
_i <span class="math inline">\(表示排名在\)</span>i <span class="math inline">\(前面且代价在更小的块中的代价和,我们要找到最靠左的小于\)</span>c
- 2 ^k <span class="math inline">\(的\)</span>f
$,这个可以做线段树二分维护.</p>
<p>[IOI2021]地牢游戏 类似,但是因为是在图上做,所以把二分要改成倍增.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>英美戏剧与电影大作业</title>
    <url>/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<span id="more"></span>
<h3><span id="thebright-morning-stara-sequel-to-a-streetcar-named-desire">The
Bright Morning Star(A Sequel to <em>A Streetcar Named Desire</em>)</span></h3>
<p>MATRON: This is her room. [<em>She knocks on the door.</em>] Miss
DuBois,</p>
<p>here is someone who wants to visit you.</p>
<p>MITCH [<em>overwrought</em>]: Thank you. Has anyone visited her
before? And</p>
<p>has she recovered?</p>
<p>MATRON: No, no. Although she has recovered a lot, sometimes
she’ll</p>
<p>crouch over and tremble in corners as if someone will hurt her,
and</p>
<p>she’ll try to hit anyone who wants to touch her when she’s
insane.</p>
<p>[*She pushes the door open and lets Mitch in. The room where
Blanche</p>
<p>lives now is a pure white space without windows, and a naked bulb</p>
<p>brightens the whole room as if it were daylight. There is a
collapsible</p>
<p>bed in the corner of the room and a Bible on the table. Blanche sits
on</p>
<p>a chair in a blue dress and stares at Mitch, which makes Mitch feel
a</p>
<p>little guilty. Then the Matron goes out and leaves Mitch in the
room.*]</p>
<p>MITCH [<em>keeping his head lower, staring at his hands</em>]: Hello,
Miss</p>
<p>… DuBois.</p>
<p>BLANCHE [<em>happily</em>]: Hello, Mitch. I’m glad that you could
visit me.</p>
<p>You know, I haven’t spoken to anybody for a long time. I … I
didn’t</p>
<p>mean that the Doctor and the Matron treated me badly, and I also
didn’t</p>
<p>mean that you are just a … talkative partner in my heart. [*Her
voice</p>
<p>dies out nervously.*] You know that, you know that … did you
bring</p>
<p>some whiskey or lemon coke for me?</p>
<p>MITCH: No, the Matron said that you can’t have any liquor.</p>
<p>BLANCHE: That’s a pity. Did you bring some unwashed grapes for
me?</p>
<p>MITCH: What?</p>
<p>BLANCHE [<em>smiled</em>]: That’s just a joke.</p>
<p>MITCH [<em>relieved</em>]: It’s a relief to see you more delighted
and</p>
<p>energetic now. [<em>There is a pause.</em>] The room is so … white,
like a</p>
<p>… marble palace.</p>
<p>BLANCHE [<em>delightedly</em>]: Yes. Yes, I know that you mean to say
“Ivory</p>
<p>tower”. The room is neat and … it is better than Elysian Fields,</p>
<p>right? I feel like a new human being with the white walls, the
light,</p>
<p>and the Bible here. And Shep Huntleigh called me a few seconds ago.
Soon</p>
<p>I’ll leave here and go to the real palace, being old and full of
days.</p>
<p>The Lord will bless the latter end of mine more than my
beginning.</p>
<p>[*The music of the polka rises, faint in the distance. She gets</p>
<p>crazy<em>] No, no, I don’t want to hear it again! [</em>Mitch
gets</p>
<p>shocked.*] I’m sorry for that. I … I don’t know why sometimes I</p>
<p>behave like … like … Oh, how is your mother?</p>
<p>MITCH [<em>sadly</em>]: She has passed on.</p>
<p>BLANCHE: I’m sorry to hear that. [<em>There is a pause.</em>] Oh,
don’t let</p>
<p>silence ruin our meeting. We haven’t met for …</p>
<p>MITCH: Seven months.</p>
<p>BLANCHE: Yes, seven months … It’s difficult for me to count the
days</p>
<p>because there’s no calendar, nor sun … How about Stella’s baby? When
I</p>
<p>feel lonely at night, I will miss the lovely baby. I haven’t seen
him</p>
<p>… or her? Oh, it is not important, you know, Stella is my
precious</p>
<p>little sister, and her baby is my precious little nephew …
although</p>
<p>the baby’s father is … Stanley.</p>
<p>MITCH [<em>avoiding Blanche’s eyes</em>]: That’s why I came here,
Blanche, I</p>
<p>have known the brutal thing that Stanley had done. I feel angry and
…</p>
<p>sorry for it. I want to confess my behavior to you and … beseech
your</p>
<p>forgiveness. [<em>His voice dies out.</em>]</p>
<p>BLANCHE: What thing? I must forget something. Pardon me, let me
remember</p>
<p>for a moment … [*She starts shaking all over and panting for</p>
<p>breath.<em>] No, no, no! [</em>She screams*] That’s enough.</p>
<p>MITCH [<em>bravely</em>]: You know, Blanche. I … I’m sorry for what
Stanley</p>
<p>… and I have done.</p>
<p>BLANCHE: I forgive you! You are the man that is without sin.</p>
<p>MITCH [<em>shocked</em>]: No, no, I’m not …</p>
<p>BLANCHE [<em>raising her voice</em>]: You are the one! It is you who
lighten</p>
<p>my life … although just for a while. But that is not your fault.
I</p>
<p>don’t deserve the light for my sinful self. It must be God’s
punishment</p>
<p>…</p>
<p>MITCH [<em>restlessly</em>]: No, Blanche, you are …</p>
<p>BLANCHE: A courtesan, I’ve known it.</p>
<p>MITCH [<em>embarrassedly</em>]: No, Blanche, I didn’t mean that.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: So why do you come here? To
remind me</p>
<p>of the past which I try to forget, to sneer at my fate that I have
been</p>
<p>trapped in this prison, or just because you want to have a sweet
rest</p>
<p>without guilt?</p>
<p>MITCH [<em>embarrassedly</em>]: No, no, Blanche, I come here with
kindness. I</p>
<p>know the memory of Stanley is so harsh for you and I … I have no</p>
<p>hostility to mention it. And … and, you see, the room is not so bad
as</p>
<p>a prison. It is safe. No one will hurt you here.</p>
<p>BLANCHE [<em>coldly</em>]: And no one will love me here.</p>
<p>[<em>They keep silent for a while.</em>]</p>
<p>MITCH [<em>nervously</em>]: Maybe we can turn the light off. The room
is too</p>
<p>bright.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: Don’t touch the button. From
the</p>
<p>first day I came here, the merciful Doctor and the Matron kept the
bulb</p>
<p>on because they thought I’d be cured when there was no night. It
works!</p>
<p>Now I love the light, it makes the room like a … white coffin. Yes,
a</p>
<p>white coffin made of white woods.</p>
<p>MITCH: Don’t talk about death. You said you were afraid of it.</p>
<p>BLANCHE [<em>faintly</em>]: That was the past. In the past, I always
wanted</p>
<p>to get away from death. Before I met you, I escaped to desire; after
I</p>
<p>met you, I was lost in hope. In the past, I clutched at anything
that</p>
<p>would tell me that I’m alive, and when there was no solid thing
in</p>
<p>reality, I tried to clutch at myself … although I’m not solid
enough.</p>
<p>The seven months I have spent here helped me understand death.
Maybe</p>
<p>death isn’t just about crying and darkness but salvation and light.
I</p>
<p>thought I dreamt about Jesus a few days ago and he said, “Today
shalt</p>
<p>thou be with me in paradise.” I wanted to ask him what paradise is
like</p>
<p>but … I could speak no word, and then I woke up ... But, but I
could</p>
<p>imagine it! You see, the room is … is as stainless as heaven. You
see</p>
<p>I’m more delighted and energetic here! It is doubtless that I’ll
keep</p>
<p>delighted and energetic in heaven after I pass on … if I can go
to</p>
<p>heaven by entering in at the strait gate … Do you think I can?</p>
<p>MITCH: Yes, of course.</p>
<p>BLANCHE [<em>laughed</em>]: God love you for a liar! But let me tell
you the</p>
<p>truth: I’ve chosen a wide way that leadeth to destruction … it’s
real</p>
<p>… but why I talk about the truth …</p>
<p>MITCH: I’m serious. I have made up my mind to come here … and I
want</p>
<p>to take you away.</p>
<p>BLANCHE: I am not clean enough.</p>
<p>MITCH: Everyone is not clean enough. Everyone has … a sinful past.
The</p>
<p>world is broken, Blanche …</p>
<p>BLANCHE: No, Mitch. I'm too delicate and painful, but you … are</p>
<p>realistic and natural. How can we live together … just because we
long</p>
<p>for a partner? Sick people have such deep, sincere attachments. But
the</p>
<p>truth is that I’m sick and you’re not. How can you forbear me when
I’m</p>
<p>on the edge of lunacy and want magic?</p>
<p>MITCH: If we … get married, I swear that you won’t be on the edge
of</p>
<p>lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world
is …</p>
<p>always too harsh. [<em>There is a pause.</em>] It’s getting late.
Maybe the</p>
<p>bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend
my</p>
<p>funeral in the future? I have no idea when it will be held. But I
know</p>
<p>it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could
imagine</p>
<p>it. It will be quiet and stainless, with pretty flowers … right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t …
don’t</p>
<p>answer me. Let it be a mystery, a fantastic mystery, just like the
end</p>
<p>of a fairy tale. I had read so many fairy tales when I was young and
I</p>
<p>always imagined that I’m a princess living in a palace, in a
magic</p>
<p>palace, waiting for my prince and then having a happy ending.
Everyone</p>
<p>believes that the protagonists of stories will have a happy ending,
and</p>
<p>I’ll also believe it. Do you know the French story <em>La Porte
étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the
end</p>
<p>of the story, the hero and the heroine get married and have a
happy</p>
<p>ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry.
Tears</p>
<p>are so precious that you should save them for more precious
people.</p>
<p>[*Mitch covers his face with his hands. Blanche wants to wipe away
his</p>
<p>tears at first, but then she hesitates and turns back.*]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the
former</p>
<p>things are passed away.</p>
<p>MITCH [<em>raising his head with eyes full of tears,
hesitantly</em>]: Do you</p>
<p>… do you still remember the inscription?</p>
<p>BLANCHE: What inscription? I have forgotten about it.</p>
<p>MITCH: Alright … alright, I’ll go. Good night, Miss DuBois.</p>
<p>BLANCHE: I shall say “Good night” till it be morrow.</p>
<p>[<em>MITCH leaves.</em>]</p>
<p>BLANCHE: And if God choose, I shall but love thee better after
death.</p>
<p>[<em>The lights fade away.</em>]</p>
<p><strong>END</strong></p>
<h3><span id="summary">SUMMARY</span></h3>
<p>At the end of <em>A Streetcar Named Desire,</em> Blanche says she has
forgotten</p>
<p>something. In this sequel, Mitch visits the asylum where Blanche
is</p>
<p>living to express his wish to take Blanche away. Blanche refuses
him</p>
<p>despite her love for Mitch. While living in the asylum, Blanche
has</p>
<p>understood more about death and love. She knows she is not clean
enough</p>
<p>and wants to go to heaven and love Mitch after death.</p>
<p>Or is this sequel just Blanche’s another dream before death? In
the</p>
<p>Bible, there is no night nor sun in heaven, just like the room.</p>
<h3><span id="theme">THEME</span></h3>
<p>It’s an attempt to explain Blanche’s change after Stanley’s rape.
Before</p>
<p>that, she was afraid of death and tried to avoid harsh light. But
after</p>
<p>that, she claimed that she’d be buried at noon. I tend to link it to
her</p>
<p>chase for a fancy world like heaven.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙王子</title>
    <url>/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>我急匆匆进了酒吧，抬手看了看表上的时间，庆幸自己来得还早。</p>
<p>酒吧里只有稀稀拉拉几个人。我找了个没人的地方坐下，又拿手中的书占住旁边的一个位置。</p>
<p>我的左手紧握，攥着什么东西。我能感受到手心沁出的汗珠，黏糊糊的，以至于我不得不找服务员要了点纸。</p>
<p>“现在我该做些什么呢？”我想，离约定的时间还有半个小时。</p>
<p>这时，一个老乞丐凑了过来，一把移开我放在那里占位置的书，然后坐了下来。我正要发怒，那老乞丐却比了个噤声的手势，然后又忽然大笑起来。</p>
<p>“呦，这不是我们的大作家么，来这里等人么？”</p>
<p>我瞪了他一眼，站起身，拿起被他扔到一边的书，准备换个位置坐。但他竟一把按住我的肩让我坐下，然后笑嘻嘻地看着我。随后又把脸凑过来，漏出一口碎牙，“请我一杯酒，我可以为您讲个故事。”</p>
<p>我几乎快要为他的无礼而发疯了。我抡起书狠狠地将他打翻在地，但他仍旧笑嘻嘻地站起身来，“哎哟，早就听说您才华大脾气也大，写的故事怪而人也怪，今天算是见到了。但我敢打赌，您从来没有听过我讲的故事，那些吹捧你的俗人也从来没有听过我这个童话，它足以将您的所有作品都比下去呢。”</p>
<p>我对此嗤之以鼻，看了看表，时间尚且还早。于是我请了他一杯最便宜的啤酒，他看到酒端过来后笑嘻嘻地搓着手说，“哎呀，大作家出手就是阔绰。”然后他猛喝一大口，放下杯子来就开始讲。</p>
<p>“您一定听过青蛙王子的故事，一个女巫爱上了王子，因爱生恨而将他变成了一只青蛙。后来这个王子得到了一位公主的吻，爱的力量解除了诅咒，让他变回了俊俏的小王子。</p>
<p>“但这显然是个杜撰的故事，没有人见过青蛙变成王子。”</p>
<p>他露出一抹不屑的笑。</p>
<p>“但王子变成青蛙倒是可能的，这便是我接下来要讲的故事。</p>
<p>“其实真正的故事是，王子爱上了女巫，但女巫憎恶王子的骄傲和清高，于是施展魔法将他变成了一只青蛙。但女巫告诉王子，只要得到三样东西，他便可以重新变回王子的模样。</p>
<p>“于是王子问她是哪三样东西，女巫告诉王子，他需要拿到黄金的王冠，纯银的戒指，和一位公主的吻。</p>
<p>“黄金的王冠戴在巨人之王的手上，而巨人只会在一年一次的极夜陷入休眠，只有这个时候，青蛙王子才有机会从巨人的脚上一路向上爬，直到摘下那顶黄金的王冠。</p>
<p>“于是青蛙王子来到巨人国躲藏了一年，这一年它几乎时时胆战心惊，四处躲藏。终于等到了极夜，它一路紧紧攀着巨人发臭且粗糙的皮肤向上爬，直到摘下了那顶黄金的王冠。”</p>
<p>说到这里，他不禁又失声笑了起来。</p>
<p>“您知道嘛，那青蛙得了王冠，竟然真的觉得自己已经恢复了王子之身了。</p>
<p>“接下来是那枚纯银的戒指，它戴在蛇王的头上。青蛙这次没什么投机取巧的办法了，它唯有一条路可走，那就是苦练武艺，直到亲手杀死蛇王。</p>
<p>“这对于你我来说当然不是难事，但它是一只青蛙。它在一堆枯树枝中寻觅了良久才找到那根趁手的兵器，随后日夜勤加练习。直到那一天，它终于拿起树枝和蛇王苦战，最终遍身血肉模糊的它斩下了蛇王的头颅。”</p>
<p>我已然听入了迷，“那么公主的吻呢？”我问到。</p>
<p>那老乞丐笑着将杯中的酒一饮而尽。</p>
<p>“青蛙王子将黄金的王冠戴在头上，将纯银的戒指藏在舌头下，它此时真的像是一位王子了——但还少了一样东西，一样最重要的东西。’一位王子，就要有和他相配的公主’他想。</p>
<p>“他日夜思索那位公主的模样，那位公主一定有着一头乌黑的长发，穿着淡蓝色的裙子，举手投足间尽显优雅。一定饱读诗书，一定多愁善感，会因为书中英雄的落幕而垂泪，会因为书中少女的迟暮而感伤。</p>
<p>“‘哦！’他想，‘只要我见到了这位公主——我一定一眼就能认出她来——我就为她献上我的纯银的戒指，她会给我一个吻，然后我就彻底摆脱了诅咒，从此像所有童话书的结尾一样，过上幸福的生活。’</p>
<p>“‘哦！’他想，‘那位公主会在什么时候出现呢？也许就在下个路口的转角，等我走到那里，一辆镶金的带着异香的马车就会缓缓驶过，我一跃跳到那马车上，将银戒指轻轻吐到那位公主面前，抬头向她展示我头上的金冠，然后为她高歌一曲，赞颂她的美丽与优雅，讲述我的苦难与不幸。然后她便会为我的魅力所折服，为我献上一吻，我从此就可以变回王子的模样了！’</p>
<p>“青蛙王子如此幻想着，他当然有资格幻想。在青蛙中，他可是前无古人后无来者的。试问哪一只青蛙可以取得巨人手指上的金冠，拿到毒蛇头顶的银戒呢？他当然是有资格这么想的。我想他当时还自称自己是青蛙中的凤凰。</p>
<p>“他就如此跳跃着跳跃着，满怀对着未来的憧憬，去寻找他的公主。”</p>
<p>“那后来呢？”我问。</p>
<p>“有一天青蛙王子越过田间的时候，却突然被一只手给抓住了。他扭头一看，是一位美丽的姑娘。青蛙王子一眼就爱上了这位姑娘，尽管她有着一头棕色的短发，身上穿着亚麻色的衣裳。</p>
<p>“’啊，一只戴着金冠的青蛙！’那位姑娘惊呼道。青蛙王子立刻为自己头上的金冠，以及还未吐出的银戒而自豪了。说真的，从他历经磨难取下这两样事物的时候，他就有资格为它们而自豪。它们中的任何一件都是世间少有的珍宝。</p>
<p>“’但这不是一位公主，’青蛙王子想着，’我需要一位公主的吻才可以解除诅咒。’所以青蛙王子纵身一跃跳出了姑娘的手心。他往前跳了几步，却又不禁回头望向那位姑娘。望了两眼，又想到自己要破除诅咒的决心，扭头往前再跳几步，却最终又忍不住回头看。</p>
<p>“终于青蛙王子下定了决心，他连跳几步跳到姑娘面前，那位姑娘蹲下身来看着他，他们俩就这么四目相对。青蛙王子伸出舌头，将银戒放到姑娘的面前。然后开始大声唱起自己的赞美诗。</p>
<p>“但你猜怎么着，哈哈哈，在姑娘耳中，她根本听不懂青蛙在唱些什么，只听见青蛙‘呱呱’地大叫，大叫，大叫，哈哈哈哈哈哈……</p>
<p>“’真是一只奇怪的青蛙’姑娘嘟囔着，站起身来准备去继续做自己的事了。青蛙王子看到这几乎不敢相信，所以他又大声唱起来，有几句还是他现场为姑娘写的词。</p>
<p>“但具体是什么词又有什么所谓呢，在姑娘耳中，这一切都只不过是聒噪的叫声。他以为自己是受了诅咒的王子，但在她眼中它只是只戴着金冠的青蛙。”</p>
<p>老乞丐讲完了故事，笑眯眯地站起身来。“我的故事讲完了，大作家，你应该还给我一个故事了。”</p>
<p>我愣住了，“我没有什么可还给你的。”</p>
<p>老乞丐放声大笑，笑过之后，他又露出了一口碎牙。</p>
<p>“那把你左手的银戒还给我吧，大作家。”</p>
]]></content>
      <categories>
        <category>习作</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>海的女儿</title>
    <url>/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>你知道的，我是海的女儿，我是不应该离开大海的。</p>
<p>海底的确没有光，但我本就不依靠我这双眼睛。我依靠我的感觉在海底游逛，依靠我的歌声取悦自己。你一定没有听过我在海底唱过的歌。当我唱起歌来的时候，会有一群群游动的小鱼围绕着我旋转、旋转。我看不清她们的样子，也不知道她们的名字。但我仍然爱着她们，即使几分钟后就会有一条鲨鱼被鱼群吸引而来，然后周围就会散开一阵阵的血腥味。我闭上眼睛（虽然我本来也什么都看不见），闻着海水里的苦涩和血腥交织的味道，我有点想哭。可我为什么要哭呢，鲨鱼不会伤害我，我是海的女儿。</p>
<p>海底会有老人鱼给大家讲海面上的故事，她们会讲她们的祖先与陆地上的人相爱的传说。很多年轻的小人鱼都对这些故事心驰神往，可我对它们不以为然。她们有一次问我：</p>
<p>“你就从没幻想过一位王子会带你离开这里吗？”</p>
<p>“可如果那位王子不会唱歌的话，那我也一定不会跟他离开。”</p>
<p>我并不明白海面上有什么值得我向往的，我在海底拥有着我希望拥有的一切：我的歌声、我的小鱼们……除了光。</p>
<p>海底为数不多的亮光是鮟鱇发出来的，我小的时候还会被这种小而轻灵的光芒吸引，偏执地游向每一点星光。可是靠近后唯一能看见的只有鮟鱇满嘴獠牙的狞笑。最后一次的时候，那只鮟鱇朝我张开了嘴，散出一片暗红色的血雾，夹杂着破碎的鱼鳞和鱼骨。</p>
<p>我吓得转身逃走，连回头看都不敢，一味地向上游动，游动，游动。可周围的鮟鱇好像全都闻到了这边的血腥味，我看着一点又一点光逐渐变亮，逐步聚拢。我吓坏了，闭上双眼继续想前游。我在心里安慰自己：</p>
<p>“它们不会伤害我的，我是海的女儿。”</p>
<p>我就这么游了好久好久，直到我终于听不见鮟鱇獠牙错动的声音，我停下来，双手捂住自己的胸口。我睁开双眼，却发现周围几乎全是闪动的光点。我尖叫起来，拼命挥舞着双手，可什么也没有打到。这时我才发现那些光好像是凭空游在水里的，没有什么鮟鱇。那些光将整个海洋照的幽蓝，我发现自己能看清自己的双手，也能看清周围游动的小鱼。我抬头向上望去，上面是浮动的大块的光斑。</p>
<p>这是我第一次来到海面上，当我游出水面上的时候，阳光随着水花破碎在我眼前。我不知道该如何形容天空，那好像是另一片我永远无法触及的海洋；我也不知道该如何形容太阳。</p>
<p>正当我望着远处的日光出神的时候，却听见远处有人的呼喊。我转头看过去，一个男人正在船上挥舞着双手，大喊道：</p>
<p>“姑娘，你是溺水了吗？我们这就来救你！”</p>
<p>我想回他的话，我想告诉他我没事。可我张开嘴才发现我喊不出声音。离开了海洋，我发不出一点声音。</p>
<hr>
<p>我去找了海底的巫师，我恳求她教我如何到岸上去，她也教给我了方法。</p>
<p>那天我再次向上游去，只不过这次我睁着双眼。深海里往哪里游都是一片黑暗，但我选择向我感觉中的方向游去。这次我亲眼看着我身边的黑暗一点点褪去，大海本身的颜色从永夜中显现出来，眼前逐渐出现了海面上的破碎的光斑。我放平身子，任由海水将我一点点向上托出水面，任由阳光铺满了我全身的鳞片。然后我将刀刺进了我的身体，用刀刃一点点划开我的身体，将原本还紧紧相连血肉分开，鲜血从我的身体中涌出、散开在周围，在光下我第一次看到鲜红被光刺穿后的那么飘渺的色彩，我像是套上了一件血色的轻纱舞裙。</p>
<p>我继续将刀往下划去，一点一点。我有一次被游动的鱼鳍划伤过，那是一阵瞬间的疼痛，沿着伤口像水流一样蔓延。但此时的疼痛却如此漫长，已经被划开的身体浸在海水中，仿佛海水在拼了命侵占我的身躯；而正抵在刀刃上的血肉则咬住刀刃，黏住刀刃不让它继续往下割去，可刀片一点一点撕开血管，撕开肌肉，撕开所有不愿分开的部分。那是一种很奇怪的手感，会让你回想起你之前咀嚼鱼肉的记忆，我记得我用牙齿轻轻一压就将里面的鱼肉压断，但外面的鱼皮却还连接着，这时我会轻轻磨动牙齿，第一次下牙向前磨动的时候鱼皮几乎被卷了起来，第二次上牙往前磨动的时候卷起的鱼皮缓缓舒展而从中间断裂。但这和刀割还是有区别，刀割的时候我的鳞片外皮和里面的血肉几乎连成一起，你必须用刀上下不断磨动，一点一点划开里面的纤维。直到刀刃将我的整条鱼尾完全割开，我终于精疲力尽，昏死过去。</p>
<hr>
<p>等我醒来的时候，发现自己躺在海滩上，下半身已经完全变成了人的双腿，而且真的穿上了一件轻纱红裙。一位男子——这正是当时在船上呼喊过我的那位——正蹲在我身旁察看我的情况。看到我醒过来他很是高兴，正打算叫人过来，我却一下子抱住他。我原本想要哭，可我张开嘴，却发不出一点声音。</p>
<p>他背着我，把我带到了海边的小渔村里。原来他并不是什么王子，而只是海边的一个普通的渔夫。但这都无所谓了，只要能每天都见到阳光，只要能每天都见到他，这都是无所谓的对吧。想到这里，我趴在他的背上将他抱得更紧，将脸几乎埋在他的脖颈里。我听着路过的人对此议论纷纷，但我毫不在乎。</p>
<p>他就这么背着我一路到了他家里，然后他把我放下来，扶我躺到床上。然后转头向里屋喊了一声。一个女人走了出来，他们紧紧拥抱在一起。我听着他向他的妻子讲我的情况，我看着他的妻子的脸上露出同情的神色，我发现我全身穿着的根本不是什么红裙，我其实赤身裸体，全身都是血迹、伤口和淤青，皮肤上沾了薄薄一层沙子，左腿上插了一块贝壳碎片，现在还在流着血。我看着他打开了家里的灯，我看着那刺眼的白光射进我的双眼，我用尽全力将头别了过去，拼命捂住我的头，我想大声呼喊，可我什么声音也发不出来。我想掀起床单盖住自己，可我又发现自己已经弄脏了整张原本洁白的床，上面现在全是我的血和沙子，涂抹成诡异的图像。我转头看向他，他的渔夫装上也全都是血。这时门开了，我看着他们的女儿穿着一身白裙子蹦跳着走进了房间，转头看到了我，吓得尖叫着哭着抱紧了她的妈妈。</p>
<p>我跑下了床，在穿过门的时候被门槛绊了一下，整个人向下摔去，一头磕在了门口的石板上。他从背后跑过来把我扶起来，我看着那片石板上全是我的血。</p>
<p>我挥手用力地把他甩开，然后向街上跑去。</p>
<p>街边聚集了一群群的人，他们交头接耳，指指点点。我不知道哪个方向是海的方向，我跟着我的感觉的方向跑去。全身的伤口立刻痛起来，每一次我脚落在地上，整个小腿就是一阵痉挛。有几次我几乎因此跪在地上，但我还是拼了命跑，往海的方向跑。我是海的女儿。</p>
<p>我的感觉没有错，我跑到了海边，当我把双脚伸入海水的那一刹那，我感受到了从未有过的无比的温暖。一层又一层的波浪扑上来治愈我的伤口，我忽然感到全身都轻松起来，我想发笑，可我还是什么声音也发不出来。</p>
<p>我转头，回头看着村子。我想看看他在哪里。</p>
<p>一群又一群人开始聚集在海滩上，有的像是刚在酒馆里一起把酒言欢的朋友，有的则是十指相握的夫妻。他们有人在劝我回去，所以我拔下了左腿上的那片碎贝壳，把它抵在我的喉咙上，然后指着人群想命令他们安静。可我什么也说不出来，但他们仍然安静下来了。</p>
<p>渔村里的窗户开始探出一个又一个的头，他们全都看着我。这像是一场盛大的审判一样。我忽然发现我认出了其中的几个人，我不明白，我是海的女儿，为什么我会认出他们。</p>
<p>他终于来到了海滩，我看着他拨开人群站到最前面。我们就这么对视了好久好久好久好久好久，我咧开嘴冲他笑了笑，他却怎么低下头去了。</p>
<p>“他不愿意看到我了。”我想着，转头奔向海洋。</p>
<p>海浪一次又一次打在我身上，但我知道她们是想清洗我身上的淤血，我知道她们在赐予我新生，我知道我的双腿正在愈合在一起，我将重新拥有一条闪动着鳞片的鱼尾，我是海的女儿。</p>
<p>我忽然想起来他一定不知道这些，他可能以为我在跳海自杀，但其实不是这样的，我是海的女儿。我想回头告诉他这些，我不会死，我只是在重新回到我从前的生活罢了，但我忽然又好奇他会不会为我而哭，所以我决定不告诉他这些，继续往大海深处一步一步走去。</p>
<p>先是我的双腿，然后是我的双手，最后当我的脖子也被海水淹没的时候，我终于忍不住回头看了一眼。人群小的像是沙滩上的一个个光点，我确信其中的某一个就是他，虽然我其实根本看不清他们的脸。我转回头来，在海里张开双臂，向前拥抱海洋。当我终于全身都被海水淹没的时候，我张开了嘴，却被海水呛了一下。这不应该，一定只是我上岸后太久没歌唱了的原因。我抑制住自己的恶心和反胃，拼力再次张开了嘴，现在我终于可以歌唱了。我是海的女儿。</p>
<hr>
<p>没人知道那个哑女为什么要跳海自杀。她在很小的时候就被从外地卖到村里的妓院去了。人们总猜测是因为那些嫖客对她太过粗暴，但也有人说她当时跳海的时候脸上满是幸福的表情。总之，大家只好把这件事归结为大海的感召。</p>
]]></content>
      <categories>
        <category>习作</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
  <entry>
    <title>卖火柴的小女孩</title>
    <url>/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>“地上好冷。”这是莉娃丽尔冻死在街头前最后闪出的念头。</p>
<p>路人熙熙攘攘从她旁边走过，但没有人会为她停留的。今晚正是平安夜，明天就是圣诞节。</p>
<p>她不记得去年的平安夜她是怎么过的了，但她记得在前年的平安夜，当她卖掉了第十三盒火柴后，她看着空空的篮子，又抬头看了看刚买了火柴的绅士，忽然开口说：</p>
<p>“先生，请问您能送我一根火柴么？”</p>
<p>那位西装革履的绅士愣了一下，然后和善地笑着抽出一根火柴送给了她。</p>
<p>她将那根火柴用原本盖在篮子上的布包好，小心翼翼地放在篮子里，然后一路小跑着回了家。在家门口她看见了泽基华尔兹先生，他面前是一棵刚刚运来的圣诞树，他正抱起一包礼物准备放在树下。莉娃丽尔欢快地向他打招呼：</p>
<p>“泽基华尔兹先生，您好！圣诞节快乐！”</p>
<p>然后她转头进了自己住的地下室。从自己的枕头底下摸出一根蜡烛，那是她两天前卖剩下的蜡烛，她本应将其还给雇佣她的商店老板。但那天她突然决定将这根蜡烛拿回家去。她回到家翻找自己的存钱盒——那原本是一个火柴盒，后来莉娃丽尔偷偷拿泽基华尔兹先生的笔在上面画了朵小花——从里面拿出了一根蜡烛的钱（那本是她下个月应交的租金），然后混在她卖蜡烛得到的钱里，跟商店老板谎称自己已经把蜡烛卖完了。</p>
<p>莉娃丽尔将蜡烛小心翼翼地放在桌子上。她在街上卖火柴的时候经常透过窗户看到市民们这么做，他们往往在桌子上摆上一排蜡烛，让几个孩子依次点燃它们。</p>
<p>莉娃丽尔又拿出了她篮子里的包裹，轻轻地打开，从里面拿出那根绅士施舍的火柴。她没有火柴盒，但她知道该怎么点燃它，她见过一个躺在街边要死的流浪汉是如何向她奢求一根火柴，在她给他后又是如何擦着自己的手背将它擦着，然后小心翼翼地点燃路边捡来的烟头抽了起来。</p>
<p>所以莉娃丽尔也拿起那根火柴。她一开始怕把火柴折断，只敢轻轻地擦过她的手背。但除了她自己手上被擦出几根红印子以外，什么也没发生。莉娃丽尔有点着急，因为她听见了外面钟楼的报时：还有十分钟平安夜就要过去了。她深呼一口气，将火柴在手上用力一划——火柴就这么折断在她的手背上。</p>
<p>她看着那半根火柴，忽然哭了出来。但她又想起了自己的存钱盒，所以她连忙将那个小盒子找了出来，小心地捏着半根火柴，然后猛地在盒子的侧面一蹭。但她手一抖，刚刚点燃的火柴和盒子一起掉在了地上。她连忙拿手去扑，但立刻被烫得缩回了手。此时她站起来扫视她的小地下室，想找些什么东西来扑灭这堆小火——她跑到床前捧起自己的被子，然后转身，来不及了。她的小存钱盒被烧成了一堆灰，她的那半根火柴棍倒是还剩下一些木头，但是火柴头已经被烧没了，留下黑色的一小块昂着头，好像也在看着莉娃丽尔。</p>
<p>莉娃丽尔站在那里，两手还捧着她的小被子，不知道该做些什么。忽然她意识到自己好像应该哭，但她试了试发现她哭不出来。</p>
<p>她想到自己可以去找泽基华尔兹先生借一根火柴。</p>
<p>泽基华尔兹先生是她的房东，也算是她父母的朋友。莉娃丽尔的父母长年在外地打工，莉娃丽尔就这么被他们托付给泽基华尔兹先生照顾。但泽基华尔兹在她的父母走后第二天就将莉娃丽尔叫过去，命令她每个月初都要缴纳五戈比的房租。他带着他那顶黑色羊毛帽，将手插到兜里，然后望着面前的莉娃丽尔说：“小姑娘，你要知道，我是你父母的朋友。正是因此我才会只要你如此少的租金。当然了，您一个小姑娘，况且才刚刚十一岁，靠自己当然是没有办法找到工作的。您知道的，我是您父母的朋友，所以我和商店老板商量好了，您可以帮他在街上卖报纸、蜡烛这类东西，等到了冬天还可以卖些火柴。您知道的，市民们总是很需要火柴的。等您十四岁后，我当然就可以为您提供一些新的工作。”</p>
<p>莉娃丽尔又欢快起来了，她知道泽基华尔兹先生一定会帮她的，他是她父母的朋友。</p>
<p>她飞奔出地下室，刚好碰见正欣赏自己杰作的泽基华尔兹先生。他看到莉娃丽尔，忽然咧出笑容：</p>
<p>“莉娃丽尔，过了这个平安夜，你就要十四岁了对吧。”</p>
<p>莉娃丽尔点点头，然后张口问泽基华尔兹先生能否借给她一根火柴。</p>
<p>泽基华尔兹笑得更开心了：“当然可以，莉娃丽尔。我还答应过等您十四岁的时候要为您介绍工作。您知道的，我是您父母的朋友，我绝不会食言的，这您是知道的。这份工作当然要远比您上街卖火柴要舒服得多。您甚至可以在冬天用上属于自己的火炉，我亲爱的莉娃丽尔。您知道的，亚特太太就住在不远处，我将在她那里为您找一份新的工作。”</p>
<p>莉娃丽尔于是跟着泽基华尔兹先生一路去找亚特太太。然后泽基华尔兹先生领她到了一个房间并让她待在房间里。不久后她听到了泽基华尔兹先生和亚特太太的争吵。</p>
<p>“什么！一百卢布？亚特太太，我想您应该重新想想。这么漂亮的一个小女孩，而且才刚刚十四岁，接一次客就能收十个卢布！三年前我到您这来，您告诉我警察会因为您这里有十一岁的女孩而找您的麻烦，并承诺我三年后可以给我两百卢布，现在您倒是全不记得了！一百卢布，开什么玩笑！”</p>
<p>莉娃丽尔忽然觉得好害怕，她从来没见过泽基华尔兹先生这么发过火。此时她才意识到她没能把她的那支小蜡烛一块带来，所以她立刻跑出了房间。她听见泽基华尔兹先生在后面怒吼，但她不敢停留，一路狂奔回了她的小地下室。然后拿上那支小蜡烛，准备去街上。她忽然记起她父母跟她说过他们就在不远处的一个小城里打工，她立刻决定去找她的父母。但当她走到地下室门前的时候，她发现泽基华尔兹先生站在门口。他面色凶恶地看着莉娃丽尔，莉娃丽尔从来没见他这么生气过。</p>
<p>“把衣服脱掉！”他朝着莉娃丽尔大吼，然后转身带上了门，并上了锁。</p>
<hr>
<p>莉娃丽尔自那天之后就一直被关在地下室里。她开始出现幻觉，她有的时候会忽然觉得自己的父母就在房间里，有的时候又会忽然在地下室里叫起来：</p>
<p>“卖火柴啊，卖火柴啊。绅士们，买一盒火柴吧！”</p>
<p>后来莉娃丽尔忽然又有一天看着墙壁，想要在上面画些什么。所以她拿着那根小蜡烛在墙上画出一朵小花，正像她之前在火柴盒上画的一模一样。但泽基华尔兹先生为此十分生气，他那天晚上拿着小刀狠狠地划着墙壁，把莉娃丽尔的小花划得七零八落，然后狠狠地揍了她一顿。所以后来莉娃丽尔再也没用蜡烛画过画，她把蜡烛扔到角落里，然后开始用手蘸着唾沫抹在墙上，这样在墙上的唾沫干之前，她还是有一朵小花。</p>
<p>后来她画着画着，直到有一天她发现一块砖头松动了。她试图去挪动那块砖头，却一不小心将它整个从墙上拿了下来。她看着在手上的砖头尖叫起来，她知道泽基华尔兹先生一定会为此再揍她一顿的。但泽基华尔兹先生却恰好在这个时候走了进来。他看了看墙上的窟窿，怒不可遏地向莉娃丽尔冲过去，但他却在这个时候被地上的蜡烛绊倒了。他趴在地上，正准备起来——但莉娃丽尔将砖头狠狠地拍向了他的头上。</p>
<p>莉娃丽尔跑到街上才发现今天恰好是平安夜。她觉得离上一个平安夜过了好长时间，所以她认定这是两年后的平安夜。莉娃丽尔走在街上，她想去找她的父母，但她不知道该去哪里找他们了。她就这么走在路上，直到迎面撞上一位绅士。她抬头看，然后认出了他——那是两年前送给她一根火柴的那位绅士。</p>
<p>但绅士没有认出莉娃丽尔，他只是看着莉娃丽尔身上褴褛的衣服和脸上的淤青，在胸前画了个十字。“上帝保佑您，小姐。”</p>
<p>莉娃丽尔扑到绅士身上，紧紧抱住他放声大哭起来。她觉得绅士一定可以带她去找她的父母，他是多么好的一位人啊，比莉娃丽尔见过的所有人都要好。她想跟绅士讲她过去经历的故事，她忽然想给绅士画一画那朵小花，所以她松开了手，然后把手伸进嘴里想蘸上点唾沫，但手指拿出来的时候却沾满了血，但莉娃丽尔小姐反而更加兴奋，她知道红色的小花要更加漂亮。她举起手指，在绅士眼前晃了晃，开心地笑了。</p>
<p>然后她看见了绅士的妻子带着他们的女儿走到了绅士旁边，她盯着那个女孩，她正穿着一件白色的大衣，脸颊被冻得有点发红。她听见绅士跟她们解释自己遇到了一位“可怜的女孩”，并看见他将手伸进口袋里，拿出一枚五十戈比的硬币。她突然明白自己的出现意味着什么，是她打扰了他们一家的平安夜。她低头看了看自己满是伤痕的身体，看了看自己已经破烂发臭的衣服，她终于明白了自己出现在这里对这位绅士来说是一辈子遇到的最令人作呕的事情。</p>
<p>她转头向街上跑去。</p>
<p>绅士没有叫住她。</p>
]]></content>
      <categories>
        <category>习作</category>
      </categories>
      <tags>
        <tag>乱想</tag>
      </tags>
  </entry>
</search>
