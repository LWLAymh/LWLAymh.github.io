<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>红舞鞋</title>
    <url>/2024/10/26/%E4%B9%A0%E4%BD%9C-%E7%BA%A2%E8%88%9E%E9%9E%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f3caa0b2ba6ba47c410a30cd9ceb166a061703ac5236e843a296f598971e7090">bd8dcf3e2992ad8c393c447eb460bc1d8f73739945ef909a757ceaadaea451d0a7f1137772eeed1efa390d752487ae7cf77dc8ecd6f1a2ac10df996b5f473f0c8c4b050a8af2dc65a165e433fb5fa4343558226bf6af35e11b8ae54463cb85280756e25abdd77dbd5741a0754b3e6daae10e6764295b3f630715a56ef65355e474ac6f3c93a1cb230f37e9327f412ac82be0ff5d2e5b8debaa67661f0b624978397b5dc8b0f8f13f9f87c4e60d16e30c5a1862d24bb41aa06a1ed4960d8383b3c032079263ae0aff5c44b6523612239b6aaca656df95a9ce7f6f294e727e7fd403b4f5a534bc890198fe90bfcb5775054a7c318d85a4bf546dc7a0d951782955fcae906d44e8bb7a642c14fa7280540e8cd48cfd13461f33f590cddb721d1132e14a9475e7727de2266c81f3666094b65d31fd5e16b6f7b09b3e7a73aeceba9dba5974a772b69473f80604e92039e41759dbf7fdf4664b1d6cf0f284b2eb76cf98206760ae43c342c30e3beb9dc2241f10770c7d091446b06293415a55d3b3a94de54e1ff8e38eefc902b07802ffdd6cb65704b9997ef89355f26d241650ab003a2d729c3a63668e2c6712690b15fc641b3b22abb8978be050928ab9affd3b437083370962a7526f45e7e087dff9eed270b4f22c94d9219aa319c7408d464b80f2116552bd81062245e8908d46d0e8b186c3278fdd3001d82af0cfdbd8207c9f90f588462baeceb1558bad13ce3bbef20afa85dbf9648ae89a1e094ba57c7d97f244f996487364e93ccf618536f0a0cd3367ad8a4635241dd05a57173baeaa996a8eb09d896df59ae5d4aae3dd4b02fabc6195d7660442137a54ce4a335e85a4af44b4fc5b0696762fb71e19e4ea2791b4e3e22c90453b933bb7c1975cf86fb1babbb25587eef742507b913115849d33f479fbcce450b501a9acb734eb73c79133da0e22cf7ac237d2813d3b844dbb3c76eaddaaf4d5e1dd722c0d4dc77f34429f629a92d9a66c2e921e4ba07bd52590a599944b8f2683a1c384f178693139c485cbf3ea4af627bdb9e5f4072564684dcbf73a1734734d5e89da8acd08741408f47013220ae8f13bb4ba870e1f75dbd3ca6994178de0bbe8e3ee66fc91e52e7610798f89841411187a270e99a83fc24ee824bbe87a15a7f50dd7fe3681b7573b5cf1e3115e3de09bfecd7b2cbbd92bbfe211b88dbef07d304fccc99d2d637ab2412132f29126ecee820611e82fb2b68fa68f10d25c897774c82a863a7fe3695de799ab9ee4b394acb11a0fe7d5cdd04310d78002867404337e482b09ce479c59b7c4e3762fa4ba912e0b8e74f912d0f641c942a609d4a220e1494b9bc218587082e012822b6bbaf5cab6cbf8e48c014dfe806a4b642def08b75b49d55be668b53990eaaff56a90cf8ba666e2737bb8df984fb2feab698655fc6693591a36372e1c6e89b8375922d6e898cadf1f47b36b1bdbad9cd50552644bfbef6ed1aeb846e80ccf61e8c4a8affdaea09932625aed58f5238719836ed7a738a9dc9a39e4358d8441db973b76258f94bd04e8263ad1bc93f27b14499ba9a9a9ed93773ac2652556b97787185d0cdee2cd821fa8aa6d3c1c4ddf295ff72cb8b5917c69d4e315d6b13dc9b6f9c08edbb97a423a8f697810ac9374ffde9727e8fc3d1c449ff906c59f6ed74b2ee96095a86ce5006be6b7e470f5afa0721024bd9f4a772c455e9201136e0942b153c557ec153e7e574ec4f8385911153cf43d439e7a311f2b6ce39ab8f74e1b64b8d2471432e8d5d06c3c50798fd15e9b8b67f84134608d85ae6b41cfeee825bf678d99aa90d19593145cc0a82f98b8b9c80630cba3fdb1e7cfc59ef966edcde1b79bf945e04bb06d7a7fce76a8fa1b1b971c1fa550b94cd2b7267653a42e06d0680ee89856f7be39161781c46db659dd046dcddf93b5cf0fe0a79fe6b6c2154ab2d0e6826c9c15e2f9b80a682564485d55b087fc7fda9c50e0c5cd65bc97197d4fde7153958af6b1a2d8b3299c37cdd04ea80f4364ea220c42d85a5899280492580c132d4d57acf9b9955ac80722f10246439b06a68170f3d281a004e2dbddddd87f932af95916e2c7e1719750cc382bd3f763d6bee2879fee7e8698aad6a664d67f6b85f5ea7b71d5c5850df0eee54679080cb261c548c6bf606cfea6c85dbe82cb8601bff0ad507deb09fef8346f6336b96d938fd7fbfca7787334160bee4854399e64ceee543ce3f20682f6b20cf3a7573beebf318866b26955662ea9112771d637a3e0743f6d617ddd3a458c1063d21d38680af00b2caffab36c3a46b3ae9d6f8e977507c81e2209dfff8c0b50f90034b1f12b4cf687dbbb9a0ec2bd358c95254e0888c46bb6b341e9465d0bd9c5490574d3c317e0058605bf5a81109f2ad41283f536ff19481180fc55cfab616f00dd9053563051421e90409f4c62ae158e5c3fb7fdec3d810ddd96ae69771d3d3a69cbce2e8a0c422004faff9f20d13164e4626e1c3bf30c52b01be1cfd66cd0cdb5e78aa92d4681ac1aa2ef7bd7fb73f3026bffaacedf2e34c8c18d3b2ae2f2cbdbea4b009b234287794fe273645327d3ef484ab1abe0bfa6876f82e541a4cffe22c6465ca229f8511029bec46cb93703b8ca6e54b922fdbdbba54cd7c38ea894692b3ee5fd9f0d5cccb12a3ee07ad0dc738a1a32b54f92c064ea520cac6e22b8480cbf362a276b619fe5911bcbc52dd2fe1ebcb1d4fee92c3a457ce0ea3b29b44d5fca9b763556c9c5c81c6e39de31d7c718413647440f170b15b36c96edd0fb895ce659a978e5772c0b54db982923f08e181386b4639e6383db9d27f6beeade66dd4175c7ca9a71ff773f3954ad7c913219ccb900db8563cd2816a2cd1f045a40fcd214f431dc5c3bafb531afa1e80ac3c444d70c3939f3e68f4b26313e63988c9d42997cacb48be56264ad87232f367d0f67819ee38ef831dcef429d129a829f2cff9ce54d4682347eb877553583d0ebb4f2f149c8f35fc106a4dafde2b2516bf009c77d069e09de996ded7246beb5a99a644fbfb2223a965e8f04f7e3b1553fa2503a957696a983d805b460aa30ca1ff364b84e85b92c1fd516ced4e65fa9aed85bd756430a9111d8284b552613a95ca1839ba8fe406d45e9065753bc4fae6a69501672dcd872ed1195fae7131e3f12d304cd2b92c08bd8c3a49072214666522ca6123268122d1aca74750cff5a59d57e1e5c579653fac425a4d07d9a920d0fe0c49fbeb45469f1b68ab2c9147b5e57c50c3dc36d178eabd68e0969b0db6778be04b4454ff8476c90975375da8e4026a8d0800fad93ab77d827e2a83bba40eb9aa5d6afb02aaf29a48858b7303c3344f9a5863d016ae6a5e55a230f6c43de003f3c760f7eabf631983bd376640c567a270d0a79fb84a91b725179b68a66b0da2c2e7bb064db76090f71d6dfb8b48462123546ceb2653fefaff1de862c09b2bddd560dcd7babc3fcd28e6be5c69ffc7af7c040ae91c3b203576294e23b9d0bf32ab76591748ba68d6db33615b6f7f2bd0885b336b4fe253716672233aee98b67bf06c0f9c77bb1c1b9002eb07515721cd9db297a470302502ac9601d9bf6b61599491409f9674e42669f260b39c9c206eeb9bcac4b9f272846a7f030fa733d51cf06d6b23c05452f42e3891876bfcc46c17eae28e34bc688cd6505954030c650cfa4520125a74fa3d30070cd1ab28b75f32aa04dc9aaf2ea34f50f6a14d9acbcdc0bb57c32abf5092b7e45ccb26cf4918dcf595c7f18b7b807268437be1146fa8519dfa63450d2d7b1229b3a28400b6824c4f6b7cadb2967f2449d968f34e767acae880e5cefcb88f4ed8be5c0a1992ca1933099c11fe73db6f03b6024e173457ef9effa7785c715450d5ee146db2eabca5495524c5a2f88b5039521841af727ba501fbc1e7d93efd935dcd0c163ec68aa0c3e74007f15ece8b3125a3f3c2ffa77e23e3b92a13af4f4ec49a613e8537c93784fe06a1220f1fd46df3d5d95fedee0e6d99ccaf29fadadc1112373e87a04b2c412f9489a0e35d617f45288336f6a071d7dc23fd1ca1917fc687e3c7d2998d4a75bd11c283ca3db60b35066676486b26f3ef0d6bfbc8001ffc32cd51e15984eda6856f641ff1d0a377f20c46132531852a82bb039e904dc023ba226feb6ae3682e516c2eec96392657f7da318c36ae950ebf40d8117442815c5db268377b40a7d22e8319f44a4412cf4b9df10bc996dc96b73f2e03d072ff0341cbda2251f631b3fdd79de5eca904f186f77bf81eb1bf35a8cfafabbdf997199bc44e5da9c9bd995bc9cad0d26ad179f1b20716a5961b9b899c167d576571bec301d4c42aff9d27f1a0b09bf2d589f59ef27c7af2af39430db9d0aefbca8e9e2c28a8983ae80d98ba5bcdc6f8769cee1535d99e08816493a61efbcf5a604da034e4f391da7df772994561bf4b13545d6502c8c32482225e4e25a1baed7ad033fdfb8e85f861bbef235e5b7f6675d865ddef2b16e489ac3465429776ab4a274d820135a4f69aa155389562d86314d77688f90fc08ea4f2d39f33909cc737655a759166a73de0b5b2a2b4d9abb335f2f957c97222cfaaa7de8ff61169a9755905277b30847d47024f15fb13c6d5dd148783a3b73de831db109e8c198850c66e045e4ac69dda9844bf492b102169a1084c433927c6ba87c1974eef02f06a6a1d2364509f66cb6e8c3313eb177edbe84fc38892f1f62811bd9e6b4397edc3c65e9a8bfa0e6f45e892aa3fc1cb1e7307c546a464b7ae50fc32f1153709f5e0638bc06de636ac2fd2b9a70f9e39f729e701d249cc411a0a65df3674073dd7dc8c76a3db89d4724b8f987393f6ad5ebaa1ea497acb2d4530f004d7d67f29ba2758f4bc0146abf885cc0ce1c2bc4b1caa794229a0f719f924ff95c0072e4450d6b5e1cfdd19a4e802dc0b74fa01b5aeaf6638e46b7a31485d9283f3df220d11bcdd1fa241937a812eaa4221773bd5cb66789a22438f4609b649ab9770399ad3a7d9833c14c6bfe27a2397b20431b1b55ab330621e938c9097eee921060b508f4ee9097bcacfd13f953c728d15fdb60c1706c0d64e5829b4bb14028b00eb7fb5a75028d43418871ed4540a0b3f3fb9e02346d841c52e5083c67ee98954c7481f0d1cdb6f496154919770abb6e8b2176a4f08fe876ca660d946d0187b79a626aa871d566d0f35ebb0b5e30b1493d5f64ba05fe38270f266a371bf340cdaf673422609b7cc3e8c14c847af8c1113cd51537086bb1b486df87b939e4fee4bb76690fa84bca2dc38530fa62683f141130cc8613c0ff5ff8177f33f8f2e4df68d60cffaa3a7b9bb185120ed14d1fbaef6cbeffc9dee34580de4431711cddd0f0b8b4afd6d4d93e4eecd0d125f5f100876a85686dff73fb2320244e1e494592691388b367718f59b745bfbe2c92da294e70c94924a3e7492fd6b2fb697daab80bfc933696f1a8b54e87b763610d43bafe34c051a6ba531452512024859c6a8623d2fc1809c4767d91dd6cd84b00c98407f807a990f08c7e884d942fa6e79bd6eb1a3fc4a74ec8577af6928726c99fa59a6ed117ed2a1af2de8109c1955d55caae01295a1dac40a726eb8f3634a92dfb08d6b1e9844a5f29d9ade8135f7f0682d06cdafc1c9d72abe3387869bfd4390e27ae11723c359c8014f7032951fabe04f1c3cff31c206a673354b3a9ab8584d118f4ded450f4cf2a6c1c12de6447d909f99a6af8f266a538b62e7c4ee7bac45e2503ad657e40a2dd309d9caec5bf31d9d6a78cbe8739aed886c1aca683ef3796711acd6ea194e38b0b18dcba753832bbb3f816c209c4a4c0c81a622ef3dae2add8679987037e22babfbaca92e4fe9a9ccb4d6de312e438e6b4777fe32938e66a0f14e94a2e7d7629f2276cbb855238937248940ce93ab7c797b3eeaa1e9431e857c8d50dcc3d748bbb8655b0dd1a8b52e0743c29fa5159de9612dcd2e7891cd0f5ec34d838bd44a6f9f99ec56c4581334bc3da20f8f0b16952c3b01ada11a58db0e26bd9a26b6d317e6c6c54cceecc4ca74209c1cb9954758842fa665b6f4f3c68f59d8924529d6be3183d6e05cc92a9bce042d9b608c01d40ebfcf1b4e497c6e15b65f3fb14b19a236273084bc53704fc2db55bd1e4a6b53b0ac5833a08201f36a75c8d92a4ff987c8db1e823fe2b6c823d3c4c58ccc321a37fea52300e453765a2b3017773f894fd256765f681a7ea5130430ccad21f01f9754bc5e3cf6e4fe4e00452d08f893d21cb553ba762d73cf423a2fe398e856d40f17cb9a4f3a399819b3242f593fb2858557e23a4bc968c75a1aa923d9e66d8c79f0dea82c945c5e2a299d325aa892eb71004a6539c32cc6a3dc1139567a9cbf8f19f179b8c709363f4b9d45c61abd1b20ec70979f9f0cd5ddb729204360c7c0e76be60ae29cfbea7289edd2cdbb0a3b553c2153402fead784aaf4c128815e49e88c93feacd7b437d899721b47bdced27fddc83ee2067cfec12d9608175745e29d2ed66b21aaa392f27561d01a1563c7186c97b7c5a93ed5b83d7da4e602828e7202dd9daa6de1b18cddcdfb01b50511ad9ee5c57589f1032c05e7fe4d5d35b900d2b5a4928112d592ee03c72c6d3fe749e584598a2740a2e62128876bc93e40b60a1b9431a682580cf7fa35466dcc0fa1ad1c74cc2c4a152f9df17f620110fd24833d75ee33f6e082844f3f45dd0325e07050e0c686c795727c5482f23d08aea0a466da9870e159e67d318f707672ebfe2d6800b99aec0df01c70c2360c3dcad7e57d08d0e083552735f89168d0bc1bb0f245e4639fcca6983aa7c321a7df3721e2e54228c8f2cb0b61eed12308af814311672c338671fe68160fe3cc37f4cb7f954af9ed5154589afcf444d176e8e4f49ae82805a91ded963568cb7702696713fe081465d6d9b973c634b042d20b5be4824e4ead6fb3a05be5b0805497a9bf7c7a79c3ae06f5e59518187898c49524499956c97a4599552ca27541b3c9b88e30b5b7a0ae645eebf1935d7fe5ab4a3007dd45d2c3748a0c4ee7ceaed911d14da412cd5e086e960153d53e79fbb37e423601c5a04a3d8aaca95f2ea4498c76d311ba2b58b995ffac19703bd52943cfc493467fa603639b4c6925867df798a4f7e4f392c83a4726a42a12e9963415796604041122e7a9b381d057fbcb8d12e60a522b2040eb091763bf76da31f08de9197c7cf91f9970f1673f32c29384b674b82918352709511bea178bf1f5ee588fd3bd9afe4f509d605be81205599b39218c439e43bddf9cd560ee4a2d60c314755fbd45820e9d06ee5583ef666c562da6c28478892b3a6c6cf0340e87cf85afd97f52f9403c37cc6bd5084d504382215d23da8a24778d60fdb694d7bb96da8a58699f1dec1f8ebac1686a8a0b490feebeb52484b9b75f20f533a0d5a8269a584b4598eef3228ec26094022939a4b194b98d9206a26b014da85bd76d5d75cd04c219d3af995e913d24d06344024677b0be8d19ed148ef80e96a06f47b7eaaeb16612c36533be14ff940c02f269c24f75649fe76160a6818349e1cbb91b62a6e14b1ce3a6b0c5ef0b33682a540d97537f7f2e16ccbef62e9a86b5deec0723f36e75ef89ab6dc4217095fc6ec12a4767e0f862ca6cce256a1717031a3e020761bc0621bea28d6d3f23982e93f467229d8d207c2f34eb041a9afaafc46bdd7344fcde14188676093e89248faf460c125298cd3706e8fd75f1c250abc71bc5191958276e330736bcb54486ea1a50b6bdd40ed553759c051208a09a5862fb9e0cd708899e813486c89d08c11042e960889245e0b763700dd203eaaa1fd7e1b139b5f9d7c4c25aeb951664e3a9e139e53ee1fc60f44e3ff1b881680022522f70c7b5c6af897db83d722a0be9a84c8c3cd0dad3c16143fb75421ad1c2bfe5cbdc48a2c282d12ed98ab90d0241e00bdfa9737a8ae5d83dddad79bd268b5f2201f87baa7346d729eeb6957f3e491f55c038e2fe8c743b5543d08a8c30de1f4124768a89e2787cf5b820c26f09bb7c30363c76c670202031cc08593cbca290889fe760ae15a776afdd295e225ddc49db84642f702c2710332e46876ae4d7d2dadd31753eac8e11f127aa01eb67f184d537ca105c9257de7889647a6e48ef7e435669a3a2cee1129b221857da39322c956fa2a35ad1778094c26a946596ef5d058dddb8fb5e85c709e54ad3f02375e2f2b4ec646a190dd3fdbd6e4ff0b3d10fafc012ebd6afff779b23941cb7eb80b19cfb0054f04484446994a59cdaa0a165276917d898aec832897d474185c95fa82aa169833ef919f4f546ca66a56623f1515a101bd29b60b76afdc6d62f47077c22b65c7183bd3c83e9aacc532df7db66b879754e097585f5218f7e27c7349cad69f62befd797c7759499406aa206fa4712ea7c391cc1e392219624febb9c9812c4456fb85a8c37b6fe20e35004723c88fc3bf3bfca085643437f9679f8046bba895498798083ed32fa154bdfdef0e1303a3444138aab98f91fc26f1158617496c2f43e2fae164ecb9acb11b4e51181fdbd7de170e1af12be7f2fbbe1e4d407a9e5cad3d71ec6e71f13c3515e9b1321a7d8219b4a62fc51bf954d97d476746a77705dfc6732d9acc98a5707d3de128d4bf5bd9323fbb0933bd1ca49ace64013a40c112d65d32d8646f2d1f34a6ee7302e1979dc2ae55bdd5d7aac290683b48c3e0062e40d474cab72dd6de05a9c2c0c3dd4df4b4f43a362b8dbaf8e606d622583abee6d68683537abc103065069f3cc585d7dd359b3fc9c5cc33e52385dbd2ac13e86c8bc8c1c9edccd714abe2128f50248054791ce2e99d51826afb33a80165c1bd8682451870d84cf604f1a56cb2f17ca9eeb4341a8f45363ddb9283b626202190b3bd89cf2d0e10ffa5aafb67fd758834a8738aa9169c7ab5f7c6ad75d14b1832a5e941a1323b36b30c562c0f53ab8ae21acb27aee4d056452f13c8c35a80c4f16cd67dc57c9b98498b22c7f50bec75cf7fa8f3970a5f8815da78bdc530b12726f4c8b2aea65a878d606ab4a5f0884bfb860d76a513283bb015337f932d30684aab112be542c2de33a43d833606f725ff5636d068b3ef4f88cea388089fa0dc8ff09cfe98442b3a3a011af0b98353a052be447fe08198f064af5e81092412142e3b742d96d38ed084de996800292cefff874f50a87a0126c63ff64760fe73621f8782b2e5299f57fa043675aa7d9223658bee38e6dd9e5cea665b7f523d05e4082c9ce24f03a459e42fac00739dfb12252a1cfe98f7db1e9cf4b81ac127180df1178a6981cd1423ccbbea2314c6f8cce3edea915b19f296577b8441a664b38b8299bb7a566c7f5249b66b949bef5e800775ffed63c4a7b8bc3dea5ff56e54b38bc647b67ce9022a2e4e83623b538cd449bad46529e39d2046eb07506e2b3897b83bdb4af1ea6e925633da02a4d35223f9aeb94e24b5c81ca401fb7a968a8d4fe59af75cf9e4064ac5a96aa7d3cec913450be3bfd48005433457d74a1b90574aa63c18ea57e5b8f4e07fb3767882ca996143588b9f23b4afb2dc5bd313a561374a40adb846955a898f66a01c1d7ce947ea295a2061ebc556ba296828bb76636ef965443d0ea3f5526f9b99dca938c3705fec0d2322221c34e705c7dcc20c0675c735d68a8ccd424164d0b7e36654ab7371caa8b8e909565149d3842b2ad286c7839a557355f69d1a4f3eaef1ed3e1fd484e42f4447ae0a41046fcefeba249e128fc335cfbbf6f970b1466d76b1388675532c85775f8d461de5b8310d1c1bab5e2e418677f8c4e791f3363695bf1bdf10d8e665661fbd0960845bdfc4d4277c6ac976d9439526ec65e940fa433063b496cdc295c12b766931a90c8f5a6321046a7a9e9968540f8255fa5829274444e34d3244688e14e1a6cd98f38c98ba8e94ddc32c401dd09b9e944456688e5efcf50d33cefbe7e2f1d987b87df10831b8c3402cd98e5572087dad38da3b2af45c03c82e796640cc60899d2631847d8f4bb0e320d9636ae8956da7ca4ce2d9f9ffb059924abbc958a52e75e9583892b4699a0c5547892ce6f4c21b4cd1d21b7ebe581b0a2b6c575d98fb677834bd3b78b438650cae113ec8b3ff10b025e72229fe0d2e64aee7a9ee27d987251885251854ce1e8810006787d1d1ae71a979cf9b72444f321eeb99df8c7a39371788da7a5098444a45bf839e7396ca77007d45da891d6922023f58132b19041723e5237c9ea27a95aa8f4fe7a674a8e1cf74b56f143dc9b447ab6c5a70adef7d087498e4533070229485cb8b2908c3b606651a093d8a7eb1eec1abb93f031d258c3b718ff054ba6d030e249cde575984389c18fad5224027d7dfdc28a69479ef90c57ad755096ee222776f0092e24e30ca0a0ce8be4361078b33883317dbf1a15680fc44e5f711ba7d4fb0c013481f92684a85fb940a31a13c11163d67539a693fe9bc644a1db560b5dbad43fce21d7953183224f6bf6fb8e1e43eefbfa5c6610ffe9c6cdcc47e87da30fcfea21cdde264f4be20baa4262b6df45548ad146d7fdda99bb67ba970a6e7b23d81f02b72606139d33d6c462c169699d992bc123e8ecf260191df20835708c30262f78488d9dba2ccc411978be54194db1139b085057815ab19d5a319f35b6ef9c307d8031be39c930e67ed3ca3aeb068703f0c06253af9a7e1d2cb3f17e14609d0905b03428d6d5d6b43da3331e934df73df5f0018cb79b3a459a635251d4fe16fbbe97591676ed6e3dd930c29c8d44fbfa078bb68df47a2a69dcb26718c5b86a5904b8f783454eb012cb68f5e69e0d8e30c4db0f9ed69ec87a17190c7462a09a8c2bb85fbaea2c19ff6de5781a25255b468c00eb6a18b5f73cfce744302b343188cee0c6c247c80835d7240e723a64491023f62382539721076d10b9bc4892a768e6ef04ad8949e49036c869c7146ce19e0520d541eb8155206b7f73945f998cfc2f47f20b0936e3b690ee549c597f67b19ae0b546a57e6273e6d7f4aa92d8f027fad18b6a45722dfcf85ef82759e865fd6da5530c914e0ead0e3ae89288819c865cb6f4c59277a35d7142b2bf9112643b7525a96d227c8e8e46dd80a1ba4d0f3e104e1c7f8082c1b626a5f347fb912c0103a4fbe5ac9288fae01dcb76314327eec208edc8efab91521d3f05f04bee621eb39c6077c2ae515623e769d2e0dfcc15d9039aaa2fe2402cc038b38d0a92bbc03c76b4e482091e25b3a4790f14c812c20a82ab001fc042cc044a43e5d932fc1ad278ea1bb76e7f763d266040bd93f6fb25deb04d999951a6cbf64b9bd877fa925045e9c4b749ccbbbc885158703d4b498f60adfb67e45ef084fb46ad8381aafd6d69d3c8694d2f976fe47a6c6f43e20731f7da03aae118eb7cdaac2d73e27d74fb3f2c1c017f787d366f3786b1343316cacc900190f9effc2d9d3f73b55124eb46398bb673bb3c2ad56b998e312bffc2bcbdfd2419ab56f685f210a077ef074ca4cfe53b9dd4d12498d2e3b96f3103cb614611c83eb80feeb9962601f250ae6429f233dddae5c769e90a21b26b1e5dd63d2b4cf3c0018f63f9847deed24f029a59da02d21f02c0f9c32b6dad766273affc7114590c965b2296bf7427849cff32d8e2b114f9d78c593394e34312454640df57af4dbff78ca9634d9a37af0ae8204b91a900cdf57476f34264ed538dfc5cb61a237dc3764299c62d89a595caac649953f68225c109f3222b96ad3f777c4d0b3a9797b560b45f324a999b37a84a8b5b9d82149be6262324f71d8536dcc9a8c4acc946841374d2453529c9efedc03bd14d6a12a2c09382647c1489be1ee36f9d997477f05f9eb93bd2de5ce6ccbfed0eb2c3cfd67bd40fff5776de20a8834a93e0a7477d9961226b886ef909a63c441f093e76a4a8aed48394c318574c9a7451928cbf1a48d9e874fcefcd3fc5216f9327c26f4cd30cab8d1b0ac3e918831129744350dbcc0f96f8dcb43e721308d32c03c722a34d36fa1b83cff4af1fb395a5e0d4547751cf7e30c473783f6873840b21f8b0abc30ef4737c67b261356b0189ff294759de774dcb1e258ae9afe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title>卖火柴的小女孩</title>
    <url>/2024/11/10/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7237e4ca3d0dffed4bfb16f21c8370646514629000a8347163ba61cae3245ece">d37d36f7508c778cb007938a5ff0a1f8cd3887c4fe2a7275804b6b4a964a5bf687cf3ea787ce0e60c5150b7af1165b2a53cae1b75305d868b7ba510878f81997a0e06d59ff21cf76350d2fd3a0c0241e5d9ae8ceb139e0c5a979f06ea0bb837f9698f872819da8e4dc91a24260c745617f591de34cfadc7dca9349890f888ae48ef22c6202e0581a245584f8b083da0fecb898d6d89fed955654a5566402373710921481ba426a08cc30aeca330d197d01b087e17e5e335abb197847e6edc0c65d85fdeff15ea367b9f6ce2aba1c91dc0166a33dc0de9bb844b014a516811d9cf27a24e57c2e13288df410714c29274c8627582ecf3524beb05e0bfcb68c277076202138a3e7c3fe0d13010bf7fc469a8b0f571426e432b1c91ae037f2dee2158a06e7ba0d9573177daa1c0ba063fc07f3720317beb736a8c28d3ea1a5d6d87d2674e887e133d764a2b9fe5bd9215201a1fc70a46356ce5f1ef102ef399370866c233f43260b7ff69c4182eb1f324ff7c9b10ef878749288484cb6bf4d57b9aed38ecd6108e55543515c127161c4703d493d757b499b5658bf5b4471e9319849f202e584a734d5bc9641fcb42e65d9b52b47d51c573f1314a4a9c2eb100f726d2e5764ee2d6fe7f6f2df78605fb85ea4b4cbb9e997f5470d0694dc8dc5ec8c73a94d81615c1f6e5b32dac46487fa1e4340a4a6ba2d6456e93be630915fdcc2c27f42121a85da943e49c950ef1551a8a39ac54a2eaa4cf74526819d7f8443e27ee0700fa8f4d5febcde2280cdfa0e2e17b595165c195cf653163d5dc9c46bd90fc668be91372824d6e581a7349106f9e38010f44b24c10f7d16ebf589f74eb7b4d52e7c8e86cb1f88e7aed5039a01a0db75d2e3c872af732c78ac787d7a7d4d3e81068bcba595a14e442d8f5c9ec89bc3658edf832a5add8bb83a6bac0bcc574d95ac55f7e1eac2dcd029f75bfe874cee7383690f4529d1af494eb94852be0f712f9ad5e347b3a9b350983734c19114f2c7e8da6509df76de8e4d5c46c8e1329c77b5b5f0c24ac299b40dde17f24ce41d6f118f7c5c56ea950354a135248139046631597a285aeae1b196a2ff592f86b0dd7dca9a8e17f606dc466b0b0cd02009995bd9f8834fb8d0dd5757c12c9d22b8cec540aa63aa0955f4519b5a6785dacbf66d0742a5736fe64f087e2839c842e60f328d500bde753bd08160207b9af99fd516105f3012f7c0dd1be2a131284192a151f810f2695c35f2e225edb267d1eb066b92fce0f2d8fff9b660e0d5f0a4d7f443a9e5551a284a4d6a451d0167f80c02bde7123ba405066d0bd11c897b50f6c3ea901e54db96ec4300044e34582db4eb478d12e6dc2e5da823758c64c04eb003e07e6a390ac73ada440a2d22b50d8626b9a885be9db959ab5ce1c943cc8afbc873f19c87d762349e1b3bb6e2206d9512e8834b8cedca0ef839407603102aa44185fe4c78763b01957ab29b6f82a6386e5b2b917c4ee06e3f3ba9c4716f01fe27068b849936c3aecbfe6ab12f68017e57a4d5aacde2eb4369a5ce90113c06c1c39aab1b3f58f726451859ae82557960b745c480c6a7a7082aadbd7495be130133991094d15d6aef28544c5ac95fbcb8ccc6906af6fbde62430c316db1462da8e12dc87dafd287b2a962ab46feaebe1fc84c899fea92e0520cecbb5aa34da2a98a983f1f5fc1c78073d5e3227656274e7b438e23feec9a0ace259f5261f0d90328a63ecb31c40ac817401f0a8aeb9a56b960b421202aceb4a24f7d29fd43d4cb6c126dfbe09d68977a9d329ed5b62125fd2f11a55dca4fa3b3046024fe0eb48559f86dde99e456a775584814edb349cc713af77ad47b9974362d35fb53ca056549e4bd3289707eaa3380d93121fb3ca116424bdea54331db399edcf31ad023ab51f1d0b4a742ea276c387a769af638e9fb0a7e1b49a0c6a09ea6c09c41d613ea5eb6da6c009466e17ab800f315071c0cff38f07adfa0d8deb4799e51cc0d7a401c8f8a61be34bb7070bb09970e6fa220f7ccd1f594edc3af8d6892906bb41f6bcb8ddb69edaedc5b87c9eb8c06f22782526337848f1c1dd35c7f9364a2b56062b69dba75805a6bd8265ecba1c8b89229ea48c18d99e76111f43ee384090c7f01efdd9a9baa6fabf5e5d329f094e7aacd4096405e61060ad93bec1a32d05e8473dbf8e78911e57459aea02bd00319659d069adcc0e000216150eb3854c1c734ccf9d3b5deeae23c686c9b262b1f6efb5c25efd5fee85e3d51da50bce3880f20fc9823062e8bdfc7344160f6c206bc289411210042f1da1f3a9c0353976b551470bb7d5a675e4a55cca22552f0a664de0a57f89a19fe63d2200494a65d9b4b2cb86644c3728712c9fea31e44f9f97c29c7bd2a9aceeae8bb37b64b3ef07f02fb2edeae3b87f3de17465b35b6df00df5ab8154c8bfe78f2dae8ea94f7591b39318140ef5c39bf70f9d6c9d7b64f63cb7ebfa04f0e5f86df26963c44c27851a5390561fc1761702daaa386871bda3334993697b6257c6f5e4a6389df73427e3eddbf7ec8c6f1be72c53278ac10864da0b56112e3dd563988b470dd97506b272e5d564828c8c54f6c01dd42b9db5d8ef081d3e816b3c4395706706abc49731abc74fc96e126d0a37fa792730260b425d73b50be54634ab15919bb919259309f552c4f68304e329771bd49b99165b45320933db1591f62a9d7853319bf30bcd52d8cd1d6d57e68b989bfb9275d253bf0b0f6297b6028e7b1dca7864f55f883d5e16f2318c477a813a17033a43206cbabb6dfcac1a9fb49dfb8cf7d9483c0ec0dee18f1a9346fefdfbef7fc1019957e4bd616a850bb64b014fab52c4b7603517e81ada6c1992809735d68e28621e87e9411a050e2af59b03ba9f622659e6ff6f1f9f6903de5a7e07aadafe360ac8d92165cd1b3ea55c4c6ccffc476dd1f47a54c67fbebe4064f9c5782c8370cbb11d744288b5000f21e4638fb208055e2ec5f3354e7e8b1f0c2232a6c168afd14fcea13fea90b9e149f06a3a1c264f1c14461fd254cc2991a10bb37c6e63a666dc78875910c0f509c653ae95ead8ea2398f2d8d847fb8d8173ecc7ee80c66bd828106551b91e1467a73c40d4368386700e23b695d40f2ebc9555acd6e044b3112bef5db2f42844f3a9682bd14bf118cedcdb386592c54028904dcc193cc2de33ff7d46633f5ab5c34140cfd3903d25a89cde94efc644ef6886a2b3ff716de8c1bac9b3f4ed1b5fd226a1f72b4adafb3bd2a6889f5cc748cc61accc9559e949f80a149cb2412b90150bab9fdc27ee8109a7538190e6ac87828533ea758acb8348e566a34791379bb50caa18084d033a7affb722e53b30f1260a8a5aa76ef2d98ef202c254be126a1dadcaa886bf71af1719c5e4baf04585966aa1bd89d3e70fa7596f73d27f0f7d25c68a5f4274d1b6be45b1fa6f14ba00f8b028f5fed02437580f01151ee38955ef895a629d4743bb2c417fd4df1213b1f03035efd3f0571f30e0007440a4b1f44ed2d536f29a86b6aa46f0f982d80d78e586925c142351c6585799dac9515793b88ae94364a2441caa4b2dafa961b735f16780412bf32bdc1c4a4d8ce793f87cd9bb421bee9d98468ad676dda158ba10423e7c4dd4c3e9c0d4334973d22dd54b4ab89586204b35c8f2f79782cd7940e5bf5df4bf4002326fc33dc7a525f029d5458eb988497c55a5e9c82388911e78a14c9b8c41db5de650853c7f1ea85d2dd4a4a674345e331af5bd1e9cc6048acf9af34f0b70cb5d79742aaed8ce33dbaa000109c29172ba65b2ee8bc22c0019ec92d9ef599d1572f6447365e579f821cf4cd1658121d1622392fe43a5a122fab563752b7ba53cb887ab90027978f51662ebd2475e2478be8e3b15fb15a878f176c29e65949e78645ea0ed93cca39c6f2b7c5f9d7deb93afda0db4b96499a1cf03e7f957868177fbcc27c6e068c825f611d2b6f9c0ae97ca0052bdc0e2c6b6e97045c453946a923830fe0039cae4263245cbdcdc8db5a05b4ae4836bbe513bf9684e5f11d360c3974ec13f57001eb5277b7baa9e9ca12fa4420be1f8312d34012bb86bd21206c6621ab622127a508c92d15376f912b6d1e228b89d8e8b536ba7ebc4d662bea9d6dd2e59ffaed03d02a7bd237c6f6f2fdf1722c09867f690f1172c52d232ed50a5cb59587ec9465cf2f72857fe6f60f1836ceabafbc3c0b3fbffe359e0e384f24ef6c20f34a909ab4be8fb4f3ad712efae042f367fcb2dba15aef2b527c23caf272e186e080188e705f06fe9af8d8b8916910fdacc0f82a64cbe468edd140fb7957d41d47f6be289e6cfcf03effc0a66be1bfe1a9c71d5f988f6d98de756263202f19b2611359637391127b2e7dbc3669d9a4ae72de80959cb5ae53feb0b70f6ab608dff502d3ee6fb2039733305ffe282a871c525daa68cbabf8683281c35dc055a1e6fbb07312268aad63384521a1f38cc647fe92d52f20b2e14e946915bdf2062ca66c7c8aff0ba941614d58102c47eead103bf2efcf29ece3f4085ff226320743853a1518cb48546830c0e285cd91befed12f8edde086fd75dc9cd1ec9d88b6d6b089efe69c4c1dae48ac82109977ea56b4e0390cb528e959922fb80d6abf68c0d909ca72532cb70df525174cde168dbd29bbab0f5800ad9dfb21fb40b9d8e348a14907e382b133afb1d3cf8a7c4945ad99f6bc3575f14ef7889bdf2a9f09af235355b01a7d6727ee4dec23c0d2e6c0f1427c84af90bec8eb7bd2c5f5f70d3967dd5f7be19ad6186b57810496deaf0ef3e89a0d7d76a4a8b2a2b023adc6bc5aca53ddbf2dd3e35545d1759ab687a60b54104c604d7e2c56932b3055f9ff8cc0a1ff49459e43251bbf1f29d81f442994f72063f446f7094c50a4d8052d37301203cfe93bd65807f62152b4168bfff141be28359179fa831e361599d6a711cdfb4318b25f824720544a508138adf90f5cd34041d633b2158a61a075886a35dfd03e18334b24fe33ee98f12b0cf720e545f223a6426e69a6f237be9dd6fbb27c7a6e931ee0d424ce5e85551306c85aa565e1557dc344c07c7a67873642af102977250d7c1d9c99cd945fc6bc6ca9fa76018057b554e44f4806fa991ef1fae88e68723758cc771eb12c9d5144dca405e1ee5799de0853b4a7bc40b13d3c1a37e0b267aa2aef4a8022ed6ff597c5634eab36f364a99574f1d8460a5443a452043f328cf440af717f11fd8ba3175f4c1ae4bbd45f6e8eb4b3409e76e9a83ab1bf58b0f8d42705489b1276698df558e2b5433ce6740cf9b72c070ddfde68157c02160915d083959a353eb3754b5e2f3304913ba6efde6db34c9676d3242261ef03c6c222bcdbcde363647c59730122fbe4974d7bcdb33bca0f2958e07e58382096b010c99290e2571d2e3a0748f5a989aa0bfe70c0c57c7acf71cbebc950faa975a9daf1784a87c669e494ccf9f516644df0cf2e575e76b851a40faded3902c497cf46c80db7a35d68dab41c3096e08a2656f0954827c6bd6cdc2e9a318450a1e7fa5b600a533c4267bd70fd22cf237cdb3853a3302433a2a495b074de523fbd33af2e276e6d8f19190fcb646e625309af06379497255ebd88d40770be27000ab6209a63eadc80fc8999e7c7a94939054842860b604d45edd2cfa155322de91ccac99b420624d8ee683ea380364e22b7fc837863e3c1837f5622490e3612205cbd9548c05f67a42c3927c23b9af271b84ea54764a7c3fab78f835bc0b780dc057cb00c9fbbad01d7b334d554ff2a097dc781003c7b3953e84dcf46f5ea5dd0ae4dc8953be947a982b0bd80041f9eb53874f5333693a7da8ca14ceb33b156346155e277ce9777f6dde0f74050fb8ec54723845c077eb3493f3d02f4eb0fa8e0d3a7a943730f44c6fdc4baba8d90ca62f027bd74220b4fdce25347b64ea49b700d838cdd9a3d3dcec55e869e8667fb02b56db0a246f96680de4db05e15b8df361e74d210b961f81d5d486a1406e2cd94c4eff4795d2abce33216e6117e3a53c50949d47157a1842cb41ee4cfbb396c4e04cfe2eeeb91ee0ec9960316ce47b2f4825c7afe6c02ead66ca090a059b29e1bbb10d1ffc5f0a42d52dbd276cfc108d51217caf0c5e8da1053fd0684df7102cc645155e5121b41b61c62649829d9b8998a2aad7a4c1705b03e5047a63d2b281adc3e2b7240e9f1e35158c7e3ed77e7ea94be078cdd680fdd3bc896e095b64f26d24e0a4464088609fa5cf83f6a65de8ade77dc274df99dc4dbdb4e1f33153440be8e3234a18e166f1f7eba70dc82aebbec73e1a8fedab6fa68a51c78a5c6972bc7e24a49abc6e18454fb3e9d8ea1cd6394bae4618f8783f0d9bbedd245ad135c0ee047d8dc253ae7e2d2a6e26590edcb5848754493935d65665b94eab7361c37fccaf6c6099e8ba61da5577d7aaaf0db3b3c7f6e6075145bf797218a623f59f2e7a7b1b5b8010064906b0b5d5f4979f08ac41170d6e5f4ec8dd9647488b35b82ffbca5b20d56e3c4a51c07ca608363331548cc0fd27854b414de339af8a515797d957ff9c6a034229b67bcfdf9608bed7d194eddf920aeab977895154cbfdd0a02621b4670934bb1af4b53f39d17124834688cbadf65dd7f14820363ea39d04596c0e1f819321520759bfa27a65f4bdca5aef7007aa6b059b21b03c4ddff80691f100113862e174f0b9d19dd6291665e2900471cc810019a5a830027832b69c642e216d83fd2f21e36fd949d1c2ac67f54a2e4be92386df84228d5398ad443f0a9630ce62e45bd75934ff18335b4352a205d81ab0b91f34832ab80b5a0d05085fbe879a04d71a6d00d176a017460ca0061c55d9e5696b8384971d1b363891d46ab34209fcf8ef2f4ec1b4dfc780c179f80e01d97de28338d0d66aa3927f44edb9ab8eec7717ff0245b9780b56d8c498bd6ce426ac4312a368f1b21020c5adaf4e0195592d6cdb4ca56425b9ea44552f315a0d60f3f7e4aa506fe1cb3162e1fd6db7906fa19adaeae3932bef41abf470ad232a6a885aa3969b60241960e476083a24514684720905aa5f555308a3da69d275a1ec2f278d7a7fc4677fa72568f292d59b7daba5864734e3a851f903f75a9aa642cde011db4e77335ab1e510da3b0797e635273fd0332c33fc16c55f69a4fd731c99695a20f3f5ec3b99e7489bd4b0c7937b47219f5004c028d09535c0b289e5abb61a373ed8400579ed1ea1786175f1eeab585cff6dddba88476ed3f84df19e92765b9d48e51ffa15a3c1767de5401e556cac1c3205ae788318f3d41bffcff62ef49fd9ce606fb8fa0a5f9dd0d2d5185243a97f3c44d968827238c2fb1fd0120f5575636c6a404009d212c2ee8abc2b1f6c283075365792ba7c056a3a5357950a2db54cf19e5ee17b142db14e87adf59c37bf9dced6d7f7382dd823df31971db237848ff1c54ebf292037620b28d444b15dec6efb0a623971a968954cbc9b3836b81adc06671d286109744d6453c6aa7e469b4fb0b9f7d721d2ecf527ca0f5f5bc1511fefab73c6cf8c4f37f3bbe30e512499e5965df5ca6bb30a98fecbf9fb3b5e25ccb744321539e6014318870a0f1ad296e6e8125b3ec05babf844908a32ca8180bfd3864b7902c1a2a8a55bfbbd708db84fa7324102aacd881b09f1d53de75921245e030112cbe06869c840c1113adcd9befa5260f7c07fbc7c5d2e464252798fb54ba035d5d37b3849337a596a4b4905240cca448031c09e97852a593c4c67503b5c8d413af647840dfa532d628ef914f155efa691bb82bf2cc43bc8374be95e2d5f10ecc0e5f452e072b4fa36b7e54bfcdf13867b391c09050d556e56b6f13905465e58f0b35d52833227ca3b80d27df5d19bff843ff3a5cc530150ec07d545f41369c4da8d73ab3135392c46092f708df586d89c28f7d55b29d775d8270c36a68da2682414da6d5310d30dc3025f157859e7be760c07e512ae0ace9baa38e684c6e593d9eb8ffb4ca75c164b47c60b19a16e2668de54aac5dc7b8163e9079fe5a685882f45d1d37873c8228017d81b707697512eb7c23f494f249217259f6fa1e2bbd07e1098ad11245f91cca3abb9bace5a35bc80ed84e313f6b3c17e38517055af52fa25d936675d9907dc30ea2704fb0f3706bf5945adde454334cb47f6e79c0652bd70dffee32714fffdddb731890f4b1da062b75c7513d51ed46a63415bd8f135d6670128b3a8d8383673aef2e1c0b33130a2fa868f8bca4d3604fb3387164da414be1c30f8a22b0d273d1639ba75238bd6a301c0ed0087a7d8ff5bd208ec7dde3f8afdb67cde7881f1341f1a10f2a301a4759a35c73657775dee1d328c6244983f690cf0c6ec26f1d546b157a872e06fd06b1c0176e97972199b6150145d60dc5b37b18dc4c1ddd0bb98f228f1f92b07e84909fca182120eb97c3b3d858eedd9958ab3e04166ba3abbd20c2f6abdaea5675e1e17024238280da46ba368a55b0f2bc8bb1a17035ec3330c2b7f8db3c84e93f190e860ae8be15153fde30b5c7218df0c06fc8be4f620aaa74d2b3fe55cb7d5ef3c0f05197b4b9396a275b08ec27f9fedfd724359cb95de447f95968f2b33bb61b15d643c9c4143ddcd057d8405d70a02cad999748bcb878b1e6965bae99a1d0df1a3f5cbc59985bfc1262945a67181e12eea604e4adc060693f643b68d6a27edd7bfd08e25898ce4dd711d939dcdbdcac31d552e6ad453445acecd15f4524f1ef9e28b1394de2c4cc1917ee00c2f9c8bcdfba239a5b818fb809e20d6ff1b8cab8d89b368e81feeff19e45f55761a23521809b2b991c7884260b6da06aabc5297e76199ea8458a5da11231092b590d200e0eba9922cb4674012b82a2e2acd5b36e86ca4fd76396932251069419d99283679866811d6554872fca14ae0a22a6d328bd09a1847373209b7f0d17866de2eb1b7e166da777ddee8306a42c9a1a0c4d3abfe1e13cbda45ad97f0beec1e5a3d6da853b9d9f347487e1bcd680aed49364967cbd684450dbb22633a07cd5b99290c924a3af466b189bf50c107bbe2b63bf579aedfe4179be4eb1acd6666b458d827d5d3cbe2e3214696954099b565e95321e879d371f3bace4e5ac3d7b2cbf22c4471b953c2f2909c065a93af657a1ef33d03094323bdbb78e0a0b91ca98aeff0c4b9d463984694df6a7abbd0a81730e0ab2e8f5c159c671609fd14eb8b94ae730f64fb2da729acd0ed0e49fdedb5ca9a4ef9105544730cda0c7d1769f2f4852f18030107667cc60853a3a36c48dfa15f288d40bac63dccef48e2f9be93ed687092b8170fdf80223b0698945ad563cc148c57978049c9a4fdb4beabbf8e8ffc7730f0f00b1496641a3adb0008bf1d8cc14b7986140d85d26997d9416eacf5940d4eccbb3826926e5564d025a82275f8a3f91d1ab6f8f2f4644ef76c8be74443eea65f3c70ef2ad9c0c5f1ed9328a76a2e75cce1411aef08a5304cd02f31b19a880805a409d49d65ce0dcf67a8f2d2c78aefd0524826ae1103c9af320fb8106c87763842acb806afcdcc7682e52c82cb526218e7ca13fe652951c9c982004d54c0f09500aff4aba57deb068de346ea1e9d5015084c8b3d76779bff7ad4ad45b4def8e578f0e8ef50b03caaa2cbccd38c535206d74e5cd09ad3a749370241d04fb1cfa270df6808bd0f05958829b56ad43cfa95d86dc3d58272e658a27c529c0c08e9e3bc46a91d8a34ab25c5c34de1b041fc5a5068928cc8ef383fa02053e8dee78a3e2e9d52ac7f50431d854cf3406f7d46766ce8b35225907e765573d34c4e69ee301932067c755eff05f7dc5766b2089b694ce684ab6e4c7f3c62a5ff8d549aa22bc890427322907683c0d036916c05a8fdb22e54ff7b8773e9586893337110519e008aa69414a41918d4a3c733d8b1fb63c8950cb677490d50f169939b7906f6ee2d9e34a213667e9737bfebe8064608c09291c4431767814b90a19c7ded2bfaee04c3a66a86220938fe7c91790f3137cdc449e440a94d578d73f4ed9862139618d5f205a2ac72a898e2925b85152d45b98717744a0ad048176e28281683e8cc8590f65e6e652be04134743d65f867966fbcdf54fb3203e66c63f513fedb065d9131db9035ef97f57682cbbdb6066ce3881002e3459976e7a68e09845bb8895b66a93a4d2e6a2144181747d86854566dbfda8a3be300c665d9a057892394bd46c398cfd3e6b411227527e231695ae818d1caa68e64b269739a42f226cd896c952f04dfec0cbe6e736f90021222f700607989083a0264b0fa6e06fac9f3ebc798a870a5679944b7671191c9afd3b6e6000ea986c5c1cfbd339f4c44fd38d1a78cdfde49fcf49ebf8b4fcd2c9c37020a7867717b15aa492bd27d4664be6c683e5b5b8e29f8742ef51230015f6ad9a357b1c2837adf4dc97c374a42bf94ee0511c1fd2d66b9e7e70bdf4e43c019ed7ce05dd830933f1e3a917b2e4493952a54ae8fd9d02b9014d0d2d6fad0b9bfae57671fa928d71909f7763d896b747486a6f53af06b93e896a9321c34db449a1953871b8e5485c5373781c07a7fbcfd5189df45b5e6381e277c1c8608f2a9558bde831c62fe9a6131d1acc288232e836fbadb167c758f8affd71cc6f716a165f48f94a1bfcd47828d3de8388e8ece6148158719b7d5417f3bcd176a2d53a68e8ab3f48a9dcec86b524ab7640ed69bc8eaed61c3302a997c4779dc8941baf15e22927bed51c9122ce92974d50b6dd50dfe939c09e2b0502a2b7bd2f0817973f17eba322ba2c34dbd53d77a814bd3f607fa9371630d49efc4433f57847d5cce48c20c7fd9f6b49b68e054178c640e09b0d7535c30258f3a1e14b0699c498586c0257e7eeeaa43f82a6b1af6f3e39f51ba88db04ce53eac5021a1b2b5cf00f3173dea16d6f5de5bef3b29a33f01d49a4b08f067733e6e0bee56571061695cddbe2d6e87b67df8d7aeb4c7ac5c464abfd31929a42534457e5befcaca2858b1cea09e40d77ffcd9be50e53b5279db77cde433f6816e68c8abd882a7d4d3d30a40480d7dab3632fb3f5adc5cb3e9bbf81f72ec179a095b75b6659bf55037b3ebb67c5e8d39b1d659dd2b458feaf1d1094ccc13f05735c46f9f6b9bd7e5b683326a6793048e7e7e0047c9c1159fea9c170282599f1a15c15b520d680b6553120a6c8a746b70870a734819cb5952f7c965fc47aaacc169cd2bc66c51008ec7762e49ea32ee6262a099b8e5c87934c2dcff2c546c7ba85a215d5014da94ad589884052ce2f726e8d00b4a6895b2f0ddc70c163a0ecefc56d7e277891c8f7becd09e282971511feeda3d95300ae65bb8306c8258443051e0ea37c58ccf782be7e9bca5b5f9a552a3332b7c3937b1251ba3fc275ff1298f5e343d238554f5007bfe5e84bac0940b46444f4bb2036dfc8b838b2012f4bcc58ef4f053d5827fcef1ff75bf20753bceb4d9c2ed326820ef19079f07389baa62df7e3196173ab8cb10e969575d7e7c84c018a298446a5a669bbfb388439d2aa6c937dc9ddad171d7492820c447fe4d59d276583cc0fd70e99f82e6252b4be357b68fcd9b997d125968fd240b581cffe7b5051d2bc7d9faba2ecd956cd8bcf4ad48a844583312642c6d0cf6ab667163607eb39c9f82ed5c5cf9181580fe53a49ded11737e362486617879542fa82a4097f3fc2f5f6a034a2ca302ab4b262c4ae4fe3726354ad93854b31c4d8655e2b4485afad72a88dcbd67e6f87ea176c76c8bdd912fbc8bf84e7dca3c233859ffcdb9772c5098acc903569c68c50c47c8e48ebf7e739ad0dc6f33759d8a83a097212e762af685b633d192763ac0c51c692b5ab73a7a33518edbc45c084131a06e667af5501567a8a79f178a9cd89c7f71d488311db0af7b47a63f7e786b98a20478306386f5d3b4f9e89f3301fd8a0c83a9a91cf0e2e57ac239baad11c98f4878a7f81771de557bf8994f6f5010701b7ff7bfda06b6d9c5a4399e2bad8b6901862739b5ad72d4c0883dd732506af2d9b1e2b891df6fc8fd12e6e8968a11f6ce997fee57dc9ec69b6fc34b3535b842c8dd966f0585aeafbccfe5a3460e058b25b3819f994a3ed115a89fe2eeb850afcc2117113f51e85a73bdca805322888cdab4cacabbe9ce2c10a563bb44e000c0434a0c7a7d91db0999a6c344c92c17dd76f938c676a752558f7974f90da2f0cf2f445918455e023ed1e09cb2f4c50ae1420eee75ed69c19227525a9a289120602e0e93f4389b1e4674cbbb6c303be7d1dc41c5510cf21818ef330813d74a35a90c75f4e1880e3463a8707c591fc6597af0f2d5a7cdb13ffab2cf91dcffdb1ad0766103b193058885e3fa880f007687b06660d90c6cf6f89c620884cb4b78a896d14b1ce8fb0520ab55459065f83acc3cb48adf8b487b7a6cd80726c917b3618b3a6d5c48e44b79c22b1da7ae03124216c6cabd0773455ef168f2e2a1f3d8cb8787bcc992c9ce2d40d4aaec24c5f9cd6857f895b82d8889bf184c0e2a963761970febbdbe51629738c514d7ae4a1a879b11950f62186a817a10048ad7dea39d43db4a8465db3d7298992580a3f23bd846e61481109f57457914c001e51bf62b45f878d899e3f23fda2ab5fba33daedccef69727b7184c1afd6c9e7a97188f14b5776a93755f0a8a1317545c4e5c3b64a902d667105d9cf55e388da2e8ec399e2cc5711c69cf8b7dec644c85a7087650bcc25e55aa576da710941f08bbe3d8455e375d499801e03e74ab0c7081c02d83f9142e6f99bd12e9adb9e2e3c6fdd6b3d4b83e0329ef6184587ad6f605c3b32ebf8f08b95d3968efa1670375242926b08f2a49eca392e0c71f2b9a99ff0801b730c3dba67bc7605fafd20aec1cd35c1af8f7013352ea9d8532d98a9292df86dcb276a3f95d6ab3632bfa7ba989daa511a8aa163a74d8c0de0ddbcfe7a7778b4f604b9673ba4034d4e2439a7f4e65c737c4c33fcbda0700417dafcd0f3701c9c7e9b0ac2cc6d5fb9c27df26b738757d6d80d95b136d6a4d9ebc89b9b33dac0cb3bc230029773bb89927de87db76094866ad6bfa347dc69ee85ca346ffa8ca2d8b705df8c9e03cc260e7e9445cba49f235979b47fd1d1074ebbbbc2967e5e03268d27c5a28eb67695c441f00aab995e207d670c99774340ed2f15809ac171cacdcb197130f7637d0d06c1a224d25977825a8d4449cf6dd491875ff685775f295eee9d1bcd098af11817f06b2f24b32c9b46835348dc479fc73f4326e71ebb7f62ed69a0a9d549b613c420753196743b295c3a621412223b380f149da1b11e7a49705edf4e0e5a2aa923f95bcd0879599c49fa8bd0c8a0e60519af643773890766c7e4c248fa6821053608ebe30f3274c88b65832b4add15f55a653c075642e3a14b0e5bfca70346ad3218d474b0398f398a11de552ed04e55de6cb23b6af55118ba80062fbdb64b236b5bd6a74e26ec1734cb2a9f016e3f6bbcce25a8575a7f8c2646e8c437aa323d82c3d7471ab27ecc75830d81e1368a0323d633c2d968d3e423214f2939b7d000c9ea354de2eec8245792d7d877ff36c099160a99b9f511f3cc7868feff41a69bf03e9873d74606dcf6962afd10742914003aa13bdc5a3063bc5af6c8009a13b112283d3aadc4891b61ad9f0a6906142c4341aced74ec0f0722cac20e0bbdc3188a103862712a8bfd86c3f4e1602690eb3437bbf9b36e32c7fc6ca8def75a0b4cd424603d0262c1ff4d15df7bbf4196e19842ec426ad7731cc5932607e2e53207f25f2ddecf65ecb107c7ed1eb9c6d40e056f6aa46cc70966ecbeb39900d2317c34cb9944f6571e29be80237914b7aeb35a17aba51348ebe857da7bec8b32fee52ea01cbeea39b8ca63022db0a8d0be25aab57535b0518258b0e184b1107652d62df3354578514fbc54643f6872a9077b68aa527ffa9f1aec86ced7d3738e00137e352ad23a1bb507ae5065b72ae5f62414ac01e87e423df4d3b32f69d4189cd7b766b7fbd8a71d31fa21183b4abe95a657ce1216f3c9bfa2277ede18af8b3679fae7b8ce5415370c171cf8f79be613279122a36699c99f1e3f379e29f197d0c4ae314ced445fd7ce2c82ec76b94fb29a9b92cb2b667a335a008b954423fba312879316947ac50ce46680f748e374906183b76facb6e7f1200807efce6872b294d3b09fdceed73cbc6b215d4401f8f7ed29ebd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title>薄荷养护日志</title>
    <url>/2025/03/29/%E4%B9%A0%E4%BD%9C-%E8%96%84%E8%8D%B7%E5%85%BB%E6%8A%A4%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7399ae81e1e50ce502b3ba0cb07bfd4bc095c8c0e9361a7d9754d2c7951e6281">3bb9165ff5e6bbea951b9b42679dea8a662b3d45e31ac8fce9da89a8e8610618e947d1bef1c130687f65b0c4024445f3902466c50fbc5c0b96c1f7c0cb5c53d14c2481ce19823c3d6d5467e6405936d357d212120c2ea12e27c8abde964a7aefbb804a906da39b47571c08c04c29857d019d391d5ab82bb3f61fe312b0071961039905d1c54623120606064d1f13b5d9820010190c914607ef3570b4e9318fbe75fb96454debfee73e0b28f59a074e5e19a9b348daddc7c9e1d1763c9b4bcceba57f6ccfdf742d66fe3c2df4964f0f71e45ec72ed43f5d68b6ba4a2843c0405c27cb6c697b3cb48499d7d8e8ef4e52c262593f8e0fa6c0a1e1e6583c079eed6c8e791030e24f06788baa87d4a0a96424729e7c31910220603a0091255687829ec5fdd01a7faaecc4aeaf2a37b0e1803c7b2929707f2b56624ef94d32795b04b965639011b34f10ae4e5b1f4785f8f193bc316143c58914d9d34fd014aad709b92f6f9e8c9c3b66cddd4ef24c68a9f0072a04a1c06c6dcc351a8f13f4ba816fb8c7effcb9cc36d9798958de560f69b0e8f0cb21928dd87e101be24c5c987946fdc937cb4bf3d1204b4a63c3a0a24e0bece90c916e9817125b94805aa63556ee9b15e496a0234bae8791ed40158d6501780be8f8b9339667cf783cb9efcf1b077a717923d44d820212ec996a20c3b48578cb4fbe247ec89120a945a48f863b34df9e267d371ec1ddf53f05e71b6a55f6cf13ef539c43a2f211a04ee17f3c24a9208bd9c91a5ccd80ca49a106f252a30405726dc2498ddd86bdc0632b885435890358537adebdc67a48e44ef9ce051c90b101d789eb42f6a5e7346279da2a0981952d3fb7d47db4c5b073f49d0e957ef973301d8ce54e9c92f6d63c9e2980fdd299fedd485599b9c094b8a885b996620d0b5bba3c716c8be49eb8ff482d508544c80bb79338d2c77b77a681591987b48413a90a124862835819607a76d539f50d64d1158003a0005eaf94126192b4cb49960f31d99face1ee9cb4a338bfeef38a267c7c67ea9eff4c29399f27d15bf3f6987a4dc8b3c3b62a82ef5a5ef07ef62e5667fe02a060524f185dd53e5d35d3c49e32b601df6a98fedc56542070a6058bdd4fc9a0872f70a25f5992337a2fb8a5d14c39bd563f8a6325d87f77aeaa42e8cf9782939942bc3655f3d84328b7b8e7528e9a477924d04b97e6252d7dc9af6e037a64c22f9681e56c4172f9c9706a0514649c4a1ea512167a8325971d85f0b52ea7c4a462ce89b913668e4ba96bf8016754d42717df28bbae602b9cca1520d965fe752349573f74e2d503e88366434549ca814e932c71d124d6c6e271b8cd453883812c55d5b75784b605b61dd142508e6dece4fd7a2d58cd771ed9635c7cb0420a8193f212bf2d8f62f5c1c3c593750269d1db551cb0c6370a452af50c568d358d9df37d8b839c0eadc5e8419ac3c4ddc1a88d248ae075354e7efb6c6695f51f5f8aa64f9a74e03bfa5ce118ae3211c4f9008eac00acc33054ba5fa2e1082e8d1e0e5eaf79545815db9b9fe191ae02a5a0562b67aeb631b1fbbe9197f7e23c28a58623e274505164a32f390157f9935943f5fbbbd5012452ce6f67cad597940a947295fa46fe8c8e5e9fee74d43de982fde74d9c1a24ab5dfe36931d9cca1ddbc5aece454b0300298414d31bdaa9913521beca3f937cfe18db3aaf9520220f18d8f52aa583f1121c76d101a0b004f9b7f6903773a7b97cf573496ff301c6fd37f9b828926e603de83a05c3920ad631dd1fb3f994dfb0fcad1667d860fe52310ec21af0ca9adf3e82fa093b8cccba41c26c8634a36ffcd6cc1eb56ea658bb3b30d71b5336d44ad1ed65edb53e0e6b2ed80d10d5009dd15b5229203e2cfd715da65420f01c578a89e3ee26fcc7f3a364a468cea69e463dee8eaf994de87c73c2249a352a07b38ee9ab86736b87a32343e4fecd86dbc307a88efb08bb2fd492692b5152b73f70cbff0a070e8c76a482cb9bbef710d309636227a63b5a06a4589c184bc145f63adecfd7ac456175312263e9c8dfce6e3277c1806a894f79a493455e690f151f8538b62faceea820e41fc0d2067c236b16176d33295b1aa20dc5b3f7a4f41d62771928c22c5dbcd7b5983562e440bb7f3bd8c794ff1fbfdfc578f349e2b25f3d4675f287108b46308548a3d2c6e51e85e5c5b8607fb29f4b3a23964d8e5fb03c1a57671b9dc0a1f543773ffa370e84616bc484c93bc96e31a8371f1d58d078d259405edc4a52eadd955b6f852e3ff83db17ac07e402ba5a47717d8e7a99e5c6702199e4e978c0287a27110a753478e4f301e0361f6d6b20797497aed9cccc6f8f16edc720063e3b72e19fdf4e75fcba69780c74aebd6e7e9d4add76e49c263196ce7ba6d27af02ae47f268bd286f6b0c8af935011ee31ac5479343e0e28ad73743bfc2798d1550a3e81443dc122ca80453eeac6377e3c35346971f78031c961d4c80129e89e1c1090c8723b91576a1e1a792dee7c24cda11c2a259c167fc32e83aea98327e29c0b6005d0f61003d65eabb0fc65418d903cd72a67bf0783648a0383883f2cc6dc2455779ebcac98d0f49fd9aa2079328dd09cdb9d0134ac1692f48b93732743bdb7d26c3e02475e4609eb20bb41ddd8306762cf79dd42305ad5dc87cfcf4f02060f1387ef576c1472096ff34f2ce1e484322500af4f1f0a10d16b386b339b72d73cecd044eefe1674ff49d00225d607dfa29f99a337de81a27a5138b5b2b71146d52e55cd2716457926b8e2d39e6ee896964348863e9f36f0be450d55f134bd9549cbcc785f1fa869538c43dfd75b980374ca9002ba4d9a5c838b3261410a61b86a12c54ac8b4cc649f3b0b43426e55b883e31a4a2dda44d615130e1a1727afcb62e0b9e7a8923676570f49e4c02f1b22489e3d1f7373132574868eef6547f5a6332698cf33ba94c30a5ba0f1be51e6a0f65cfc54efc550d0ed641cd8d698845849330e9ca8a8490b95c8bfeb650267b95a77b68496b3f80c929b8f1d8583879d1f9616bb86e70c9f52dfe4544b4bde931e2f4db7479e76cf97c431401d039285a624bfcfd5b6444c527076d5b0511e9bd755b56f934723ed043cdeb185cbd9be42c521ccb731587b7fc0638a46b60bc4703e924bd253408fc128764ff8ddedbc4fa2df566cf0a88366a51ee50e943af7bc467d7ee7cf950b36df4831281444a2b68822e3beb3b5893ea0328d490bea0e17bdf1ec8bbd3f8e6296597818a317a313cc64a2fab0db50b8de4839b9caea7103001971309a16d8309dd854c67c8c24f58f502083afd5767ea2d776c120c81465bff1a1a214d55e5ca35a6f2248a8367f6781332efccb0edd7add802c9e377cf70358bb3c454c4a665cc20794a9f3f6a9722b420e477c77998dc8f6f4e9da778e4157489b46d33ec2fcaea6b19fdb434e0c1b1dd08070fa605b150e365a297b2a43308db890b2683391ccaf51d67c1a1e5420a4171bab4794a236f017f18626f15d01cca248c284661c8b2bb148b7aed9b39381300d49852b3b9cf7ff13003523e13011e5a9dd931b447c1c6dcd07318568ddddda879c30aa5f740b32c9fac37b8ff9965105a4eafbf9922330ace30186d2b344ad8cb4cb276b807712d57f294187ef8c37063120939c2dfbc0e0084313bc39ecc637eed810dfe44038d9c2d1541fbc5e8315a1fc05d7df3701f29e0ea77ee782e706cad24edb682c20dad6688e759aad0cc7451cb2c2f480672df0fd4252fbfdc26466e57621a6c32073c5cf5ee10c90a6306b05f0bd73737778697968425f3dada42938bd6558196a1af08d061e95734d86dfdd10835241e651c274b9ee2cc321104be1e8aec0e5d54160aea6261a2ad4a73d74bf49e743113f9f797aa484666039c4b955ef24101c244dfa58c9126154bd9243c5a9a52022fc8bee5e404e443ba993d5ebf680049b2d8264a78049db9cced00b061e6220cda6c669afd1512446717a860a1ea14562db277ade7f8f987cbb8ddc5dd183dcecc9ee0c053837281ab2fa5131e96c969c96f099410e82650a7c0b505512b3aae22560f32e747470d16870be085d1799fcbefc2e86235cb919396c7aae22e531d78ccbe6222743d3a4b17348c6d7c16ca2c815633171121ce0fccd3e82d0505f4b430456dbd945e1c394aaae844c7865ef7362b87f874a1952af3cd8e016143a35e2c9fca8edd3adcbee22c5b437bc817f65bdd8122dd6a15b28bf0f1f3a9e5ff0db3cc513627f54813915932164c91f75cf024db9bb74185dca34b80ebb8667b536fe63d708f9226336a49ad4cae554184b829bd3953b11d005edb5de6cc1acecf03ea54c66ece36c885468c4d84503453d40365fe8171198adf9912a3ae59274389356f7c4f935764382b97de975f0dd468ce1d0478977619cbb21517be7c14f7106646b27964f39a518063c09877ce3724a2fa8deb168745ba0ba3e54603fd75f1657ba9f8a11fdab583052715a87412bae1d48322b12e63e64a584a72db1698944995e71ac8daad1280e7a1a12d4879d273ce99344b2af165c01f50c1fb8e732d8c1fe92a2b556dd3dd650aefe39353d1d46fc843d2efe7ead6f9c90031a5f6f32bbf5f5800b9df60d7569acf7768714ce634d5e595acd4c20e6bad8f066a990a212bc1fe9b339bb2907dcd8a9a3438535ff3114afd9b49a4f3e84bffe5dd99c39708e015b508502704d65e6a7cab9c9333fa1f9ee93d85a1e0ac6e122b1680d92fa036639dbf797531b9b60ccc6fa9c3a37cbf67a8ef62216046bb90507c7cd47dbdd36bbb9c9b2ac73a956aaee975ae84cf6b0ff59bfebabd3c8cda008572de9086ea580c79aae0ba6fed64da318ebaee81b361fa06cda6c426da851b6c5c908cc9be2c7d706c5552f0f89c71c7a2253bb0b059e4d45a41146ad7186595efc36b35b282f06a1983ba861a345ba85f3cd5cb2f58e45aa30f4197dec14dab6641da6ad5cfb56c8791b5bb138c3892905e61f5bbf11a52cec8982165f04d852d4cd02b00171f27e370d885daeedf7045ea15c1a9633853bbba09a98e3c185ba8683ba5e7daf69e5e4ca8b966c65266eef425ce5f3bf3c0a4d3aacd03403e5cde15ec7dc9eff6ae95bbd2cf460706e8f155a68d9c9d45889e691e6b1f85e8f5c1cc5b7b91f528af751ff9cccff4ea2807176bbcf86a6dd303a1328c4ff0fe233bb1af18f4bb1d57f07f5299f76253765a38885d79a3121f445217f700f42eb2d268ea5b3afba5ef1375380ee76b7dc721d19f75c6ff43c0f257a372c5df941574c0ff43df887fc7854541063a9ee841255bfd2fbae270e3ebb25335b4410b02943f357009a6b6732fa8176f8561c0cbddb6698f28d6c0ef9ae98754f13e592f1fef14445e4c327a06e32b685444a929efa5ddb5e6dbe98b4e260fa019ca522d0ee3cd2f1fa08ff748c2f105e8431cd3b6d46183ef41cd95178b17d86259f03d4cd5fef110ff8be4b55f1cb632b63ba3bc9cd5bd98e9ba82c159035d6f5fba44bbe58259f07e1c2602dacaa74ef1f004e467513ecbbf17f4adc371af26253a50660e37ddf13e96469004f6eb4265846805805a2f9b86316d87e2208f7d0bd16e079f872f9c19cccc281564c39e7e4e656061184c035bfce1fb305645eea670d10d4978579c4a97ef6670d52118a28e09bcb3f9fc361f53377b0cc8c9c2bb953c80f54fc0ea065ae8b74bb63df3e6842684579b5b0526a0340a8d7efdb89ab7e902745b4e9b698777f8d5119080ce550a3acefa0e2e8a7cf11fe452af235f7e6631ffb2978175f16aca763e0f5a52b0ddacfe1acec0c39217937b09b4c912bad68bfe2345d96d56f05015bbded3b56649a2dd4914e7185b53eac96a0d42f51a36adc43a3e4a2a00665454c314edc957f1ea4a6b9cb86aea6737632ec60be96583364d858c25fb455e2108b5445273465db30c2b8c0de714cb2451c248dd2f78acb1829c5c85adc0e285469e56a773abd2c53457984b6015c787ba164de2c75551a81efd641e5a882bfd5985db38bfc6ad80701aea24012b90cb718475a5655e6635e36d388edfbb4611d87c2b2686dcbc60e517f5f504e5aebefc75397f55d7aa0d130e1c7a562c8734fbd89c0ef375803c035e6b4c0d00084efa0b56024c840408ad0602509fec7fa670dba76da57f2d75c964b76ce25c2a4e27bfe029ab3bd4a95c48f97ccd68c5411b2d48c76ec653baf884ab1a46b7f2292bbdcbda8c1a1d86e92b12c17151812c402a76ea96c2f8cd6789d43aa6accb51eb192d1f2a44ab9e9aa21671e06cc8a5e23b053914513bd0a89032a85f270da9f28b900a92066a6d45ffc567da0949bcf347ed35a363dd7721558e039b3e3a5267e713ce96f41e53412920d04255518889b98979436d12f33d01b4e8d45018a9fbf1735f4e547ce99744da6e3f46002e4e9b4616bfdafc2fc72409b75dd5798a25f11ba3e7d97c8c1c01b7ce0f082455fca832a1f6e7a2dcdc6c1c0e8da25fbb76bd93f3c5287d8ffaba682fa771e2e7231b2f860ab7d927c4dce357502e58f511dd59ae8c377bb2c5f5b874f3fce02a5ecb70ad5d88f019557246bec015a30ebfa273cd6052dc9c36362f0317e4119735dffd6e70d0ff073d9709522392a4c1b625c627ecb524bdcc4e741fc2e867f71395baf290839657ebc5b5fd2f74104d529c0df6f8b369b026f16b4c74b08ceafee747a4955c87aec7d9f4a028f72a4375c23dca1f1dbf40f2563b0add07a06bb2297dcb41bf9bf9dd96e73e78dd84d14d630778a35dc856630f1a19a14c77edf63ff64282e56119017a04b9960eb0cb70f02bb1d02032b00588be168d5015f8d460bfcfe99165d8576a8380a9064574ed41799ce8fa04ebf1ec7d04b0da8d19f7b46cf6e8cb34430be86a62d77ec74b5d8a7b742712b18242ad68447780665a38440dfe3abd86f04985acdec104ef471150c6fbf2b99c2b8979d1c41f1f1d79499ea6019904b6effb21be6c5b0a0f1db63ab0feb7e38f2c71e1914005f15323453064cc844c1f0155aa1467cef63191a997e03e54730e3fb4f4486907f26c15406e3114ae889d3152d3ce7c7309da061ae44e0a7df8c93fd6851599dcbb4299d8deb2fd3d803e4ce03865c9fc45ef41381ce14df7574069dcfda78d5fc636ebb89d68308d6060c2ffce74afccab36b46808b730fed0240ce218456ab5be5b5d3731ab01cd98d1fd13140b95407c5721c76c723d7842d0e4d123a7754dccc04ddc18827f981cbc296335830eff7837daf78bdbbbaf8ecc064e60c55ee7a9f74ed5590d5b7efb499400c30e01ef885648adc8a94575eb24a57d04acafb4d6b5afcb90c251799c79f53be2f349ace5f1e0f65d59e58a123953b96f4e3c3d1d9ce90dd1edb73d2766b694c99aaec694e23999c0acbf1787ec31e78df0e2c52c7fd15892c9e32564b2bf9181c345938f2eccc205fef948fe39e299831b1d241b6eacc9ec9b3ca291f7c78597bdf6e746953a31a18d645840403ef3f3172b075900d7b01f2c388ef93ee3637f43960656bd71ecf8507ee13943a46310aa065207c61852552e63a4cdc9717cb457860237617f01cc1ea455f88b4495956a7813c3e3dac91b55ebe0ed003faa894de237a2e3aa92a38b39f9550989eadc78fa5888c05634059124809549480ab751ee54a10cf0d31daa7d228f4cad298ca01e367b4cbebcac82ee4860e54102bfd1edcfb3a0d85e7bcd20df1edeb785b95af4bd189ce8ceff3e587f407024d370f2a50f6ac6e6b73824037e38451af170ac4cff23bdd80be71306ca2657d8cf29fa2cbc9abbb265b153538af5e62297d35f91e567b93b35cd45389aaa3ea31acd1e147459aaa2e12e24e0923d68387d2ac9841f96d852ce6f7e0a66bea1452fdb942842fca5a33115e85b287e7cb5b2115afa3a0dc2bdac8db292115f0ad6a9f85233018030d8d9af40ada03f7d688d1fc2db620d8e4a760925706419bb16d30e7ac48a1b50a6f009fe647cba5a9c6dbe1f3771dd72bbcfce72968f1697ba221a5471f8b143aeee0db6e6c805add9382586e8ab59c000167fba2d9b6259dba7f461a8a2ef7b49ba3d2880cd6ef7afed5da5d7ef63b011406b30d527d62b7baccd1c6ee97c67f92a555f875dee9b5c4a7cfeaa6c4a441eb9fa93cc761ca838b06a50eab9614c6e04aee85b4e719604aa486f84daed31a6e4dc7c0c6cf2545a351ebfa2cf7a495bee8663a86cc90428b6ea8b1fcfe1bc6e1be7f12e7b689f6e19c9430cf7002237d2c74496c260418d8bce5f2bdab170134c20f35279b365d8a9df994ab3e3107a50b7e6cf4ee6c35fae23bb4aa7b6ebd14f55814b87535374d17d4b994997660417ff5f36c318fa6ff42813d2d661bbe5570d21e1b2f2afc4a079b5f53e0f71646755b8da63ee3e893b9f50c931d034aa3d5a006e242579db85af09c838b601841abaca587feae44c51e4d01accb8f2a95297312ac6c578f57a0cad65096131946b30b8286238806473cbaf586afb8564fa88ca31847fd95e84e83d43f521bb0bfe38e4f79df66eabe47a8e239813c3f64ddb7aff34619cdceb62b5dd3aff91238d73d5f08063d0c004ec1aa990f4717264ba85172a2c60dd27c9d82ee93b1501c27f51c4b9bc5a0fc0fd9872fa9b73e941ab21d8acfb4a4cb395457012879314127a339eef00e90b01d4bd31ac4d4129efafb0f10cfe55b2a698ed7680e42186b64e29fd1a795f81fecc412b4c22c14453eb2882c993f61da8e1b113de70a41162b9b20b415ecb3f024b6b0993f7e0ae960574b413592babb7229d2662d69ca08871da03138da9497635e95f3efb92fc5f7d3ac05ca87e1d06ed700c088622c7b09ec38896132d5743b9815adce350005a9c03f632f0d135f6479ebd9bce57d1d13134d4cf7e66da2aab680b4fb005a66cc92be0c0253918cff47c428aea36a03c75bd1238b24a339b1ecdd9b08f698fcbbe88a44b46f692e7b3c32727c2467be355c70a0ac226b7592833d90a7f1981e895bd56c0041c1420181001ea3bfd8ea2ab7f8b0b3b128502d59cb41f41212d379e1fb77539c983f92ab131cd1a4e00bac7e5ad66e923267e8ae91e9ad1f393212474e9cb2981d3d67d864186a918f61310ba7deb3cd682583bb949df7ff4ddc1c66a3833cb64b48d44bc4b1c4ed6e3e93f9de189023a6ba1bc41c74bfed84348e8593d12d790a3f6b90184abb33a5614ebd1b75ab813696ee59e46597f0bedac925d363eef4118b04fea21567f27b5b2914e58b2310947d8d43a215b6dd1d484477e6122311698340381eaf01c2ac755494e1afac351f91e8ea819dd5cd5eb9f6d14dc093a876d83175f3f7856df8686ac498cba168faa67c58581ca7b508f9c28282738c6ef36b0ee729a9f86dce1aa807c83ad41ebec88e63fcdfb868fe09ec5aaaa2500d42b541ab69e81f3facd618557ea6e4961aee603364988e2ec1a096325e1aea0ed3b4b061bf9d16ea129628a83606d7cdc724799d6864f7c51feb32fa1bec3036d033cffcb0fc4d3085b0f930cd6758cc6758c32d0321c8c048374d2e8f87d836f41d30022b5e51fe1eb9363f208c9b89f157d9cf8cd5f4c8ed2463920c3a140f716ef68c5a6b15036dfed133980e19e55dadf48b48bcede748959dc6b21c93efb412b44f3a45d25e6bd5afdb9df4c036fadbb08c461bacf70d12ff4e2143f563f2948c8b85b5f0f764b69ec47d7bdef12056fe9ae21c43ff2d60523243c4b3aee7c25bd9ccc5c29ae4baa17d74484e12a744f65e8fbb62957049552eb9184730553ba40a0deab0610de76181a60385c4cb2c392ac079f5f8fdb691cecde593ad62bf8e6b486d7f3b9cec40eb05471992b333f76123ac7e5c596d7bf6fff964c38b25b2d243ac2e8ee17b23d5793a0310cdd5235ac276b1f485971dc2175b759b38e34b9254e17b242bd315b24975d20f504dcd8b285382ef6d7a13377e800acebbae7ad32577e594d0235c0409bf361a063c9a7b60784ebd88845683399bb4f446a09588c410498a3a435809a627ea36a9b4ee90cc906b7f17ab6e39778b107ee06a712212438c58e9d24dc96672958a8306043252292b168f7a63a639c8a25e89264baed02af99e3507e573cf3826d10d47201918bac57503c2bc24f38b32bd874b68d6d751650471863ac5144ea740f3ca109a227cf0daf464e46e2a3858abb1af3ffff3b9226f61a90f46cb1d602e66bc0bfd7950f8175257e0083c3c47943e27490bf74a2fdde43a5b5e86dd5fd307bb035871831eb03b5a02a42ae0fede96cd2f2e9ed9291e49762f7bb698a88343cc04efb588b1500729e97a7fd63d68593190bc719d369bf614e636d94dc61f3cd3063a36a96d20ab0e3fd916c3aa954d38b68bd76377a23f88dcd928d88b1e0f3cd22b92fc61350bb9e1f0e22e52db393cb0b2d1f4558bd8b9e14afacdac3721a6998392089c25f1091aeb9f97d3e7cc030a2f88c51fc47a56af953b81236db95c97f43af7631cbc9402966f6d43ccb57e7943ae8195460c0b8e9441a04f3c7c25111adefabaff481cca85b72915fd38ea59b3cecbb817e1f9e8d9b51b2c122eaba1ef8134efebe3558241078f2d195a6adc653f031d5327aecf11c9a89a65a28b49bcc1ddd2c07a0dc9cb0a3741eec081b330773887334306ab117c0901e09592f7321c21dbff5d36f27cd3fa21efd8b61bd981647748f003e84382cd66b999849487dd7c4d907b94228ffb6fb715b4ef64f5327f358f1a715d2fa3ef72021a48be323b8e925545aee5aad8e034c18134b64b72f9348b5876da27c9ed3494ad024e08a678620d962de99adc0a7e9d7aa10860e30e4ef71e9ceb907e70310b59c801d80ace3e29280201e4ed94cd5b5d77656da6c5477339254ecb52eac9180215ce4fad8bc9a6a715a2ec61aafbedf4707461c2f3a3e85e82184337afd3c5f0e80f82f0d4e3a0277e19de525f018d4fce41531db26ea2c2db7a98b3e67304c9eb19f64bd7430f326f0c23c93262091f89f0df7012073c304f481c9b781cffc815b8fa5b5f87c2e27b45b7c8fef5e6329fc452ebce508a218551cdf0e1f5d8ae9579989c911c2572bebd814608f43f8fbe47322c1aee865a83f7eef181a382c47bf2161bc343cb56d22f8b7071e1c916753401d6ffb22e53c31e1c31ed21caa6533472877c0c702ebf4dc5eaf443cd6d4376b2b5d3c12b20e5098f2f670d559e34765b9e1290ee562a7491fd876fbc74e5f2bef968f7a54ab39c69a0c000c890a0da800b9855689064ba4229c077ca81b01722a4e91ade51fc7a54819e41173a7494b18d797ab9697bfc6b703db6c89f1f41af37f499e7288d1e0ef6222f58e8155e041d3d8741cc1a5639d000766a4340e3abb8860138ae69c169053ed01e7f74c249aeda43bbab5dce639ce8d829b0f72d7df787f59e055ad3b827121a9818496a5430498539b52344d7131f5b0d7a11417e1f9cb55da3f43df0bb270e763c5a3b102291c2c9f30cbce93685aee8b2b4d06f10ffd8bc799ea962d138bb4c073e46ef86f0bfd5d0a6421139fd341b13b1d794ddc42797a5cf2a63090fa01a5ebb112ab2de2b24f23e9429671b04a26bcb53e798a5a5cc29c56f97db7ed465c8b1b3fde77a7540a30dfb16dd297d29895223d55490bb1606448b8fa85d8dc84fdf6743f1b16af7431b6bd674a05e735811da5fbd0b917567ff4bf876d357b8baaa277b379daa4de5443095e4427d3282f033c98a845044c750220e177dceeb6360966bed385fe1ec75b8037c9fe78af7dc92d8e0dfcbe892c34400ee8028a76ec8d83656e654fa44f6f13ee3085024b76edba80b01406a5ca22759d528e15de13f390be48a95c4dabdebabfac040472d817077d0e2714795bfe8fc62451716ac0d3c1e27e1bb719dd64cca6c9139cb948d8801a80fd4fb9d34313fdb055a2645fcd4613ebdbd67d90fd0b26c874451bac3a02111a509e3b76901914bc9bbd869beae3b952d54a181cfd085ef72a5165fc741af8c5f3c02dd3acaba0dc7a62ba15484848e5f71745eb43353a74039de1dcf8b667d3083d60e9fa8c87e4aaf7b106d64822c1c347809c97634f50eb988b226bf2d479c8e682e244e608f478317b2d0bef89f54b43de0d2729adb82658edcb9c658ae2e42e458016de76f4091e2e736e896262faece55e5eb73aebd4fb764ac0901113facba1d262ea175f94c5c9d6b095592e529bc7bef161b16c77ded7dca09cc7cbf82202f6941fc22bd98280e8d14d39a45dcfa63fdc5952e973ede93eca507f3b17f4b98522c86ab0bba263dc70f63f9fdc9056dad2e390ff79c8d12faa82832c484a8e96ec01664bd9e1aa506164eb282abc59c54e840c9a84027f43366c78a622da17b24870d01d018753cc782d91c4e5ffe3216805d31fadb213fc66460ac969ce8bb4817bb1f3640e8e4a800f11fc3800fb8e370f5b1e101bdf8958d7cfb0bbad5cc172a24e701951468a185ad8a5a3c4df2cf27eb762a95c3ec30ae091acd3f421610e4fafe347e4927d595a718533f7f25a9a579c527fa59583c5ebfba9c1e97ce8883d87add040ec7a4d7353242488162cee55fe634b558276768bdccde28426da1126c8aa64dff67293cd8cc416365c554d9cf7ffe2d2dc628f5cb09011e427e43bd14d1340389de4aae3ee0a9c914e0882e1eed69edd5fb4dc977be4d02b6ad989f333d4707f364d2e398aa1b5873a7e4ef8bf018a040b20d2940d24808ec32497e410bd2bf041f8013972058700e844aa27be89a8917fe41e5d9b1e10b22c67599735461c7837d732a50f45b75dff9273b45941bbd4f790105972e93aba4bee9f471ad4f0f0150ae7a10ad823ca24711cb93af3e4ce5cecfe084dd98104f1882a6927316d3205092f77e6c7d4eac845d4dcaa6c886a3c062149ca785f8b93f0e1fda9e25f83d5394a83b6002cb2bc68fda2c1ab8fcab82f355c8bc09073d734eba30f18f288f350ec4c276fad2d0b868662f800cc33f6656ff51a994a3d813b29ff6765adbffa3597aa3398f51b5869eb6ec204e6988e5004e36e649a7bd765853610c3cdef0dfd15a570f8529f6745310e3eb01a43fa0ea028f18f0eef3aaf7a099d7d2e181ab257991e2db525bd525b5f72b983cde16c911eca800fc9a0debe6819d4dab4c7d3eb10b9cd2d7709bd8f559f8a88e11ef454112602051450294ea5830a20382cfa048944fb5ad83ad3f8cd662ed863dbfff4f0f283b461cdcf2d62d065426bd8cabd122b32080bb695680a3f9ae0b4e978712e3ffba1266f09a86eb25effb9351c3d3f672f1b08708d81e1067a1c69cb88107a186e8779af04ff113e61084c0a67b1ef90f64d42243c1e29af4b0ad6f78fa90cb3f905029b1a62839c736b95e7ae9ddf8e85181662bb00497276811be19a92b833a98df114256bdba6c386026731ff97d24b99966c76e304bdcf4cf8fe3a84948386f156f76e45c768b730bcab08609e0e56a0ac007438861b16083bd6565403a2c22f6480b8d702058c8fb81bb233024912b01b836dff5037ec3f66dbbf4c7371e754ee1c174831f6bdd676ab47a69d605fe30e21654677dad637e2a077593bdfdc05afb399a2eaae0946bcecadb60e576f484d0675808fe30fd1cd44c2b13b052e6f4cb83a779dbc5c7d5a3ffc141236f8a3ecb7559671a9b328e3d21135fd3e224ed7a9a925da1564498bd6718c04b34de604488eef73d4eb7760a43233931e73f9fd41523c01569164c6d1a2747fab093465286a0eb428ad6f223338f3f973c07f76c92063cbc34b795a60615cb2c1ade3413912797281e277754e0da6858b89c28d716d63d0835230acb3bb9a3c66aa7e8bf2f3597e614c5cf3a4c1faad63260f16e0d8c7e4e66753bc6240b6d798a486bf4e6674cad383bb7857f1c469eee9f70afb4c1c106d71e1e0f79419622508bb5338137777588c3ef70312b3de845c4cd8e400e9fb3791fa308c7b5d71b7d03a28ecd623386765ea60fb1965c4f04c951cbc4614e078ee3d18718672b3812b365c51326521cbbee4b93332b9540f0cbc780395431b60306e7d2867f37de9d7417e4c3173809159316136b1538327320f12a332ee6eeb2635e2c9c2fd2524b99dbf13904d065ce0ed93948b711768a48917a3342f529f467abc302f4b11838f56dfb3364f550bf1af85eeb4d1347db749ac26a57751a98ff3fb48d523a1dc677ee148ae39437e6089b3c71634a1f6fb1c54697753271c13b043c4eacdfd90d4f5e9174be0256a0121bab5fbc0e545de06642083ad20fc0ca2f9e2e327f4e7561373346e1a2718d6315dd6db44d4bbf2a312244472102a6c13ba1beca29ca4e2d8268b13b8be4d996fa17a8172f5cbeff3c1ca52425cc1022a5e6ba67bc761484c5dfae239f80eafa3849f111ce8af094d2fd3c2def691bab6adaccaf0ce64789dab36eb384d8f8738c47bc025057396f7a3f2a7ab9c478a1c212b23232584600efb2581e8949ef8bd8f9167cec898ba472c2b537333b0aeb404ab8f9dd205e6c10e801437376ed02af420dffa718bda5612e6ca4f7a80491e64ffb4fd7b4196afb9dfbec9f1bca1cc8a41173b468abe8bc1afc19a1cba186f06cfe0d0538b78a6fe39b72683e9d82e82c3ca95ab6376ba51e6b12fca1df34945a507e4bcd6dde2e0f0ca1aa97c306165048f442ef2e6d65c1f1c4c132e9d97a5d439ec7608b305918c202428893c7367487815f8ae72f300335d5c989acee1e527ef93e978d6033f2dea4105f0dfed4a6472f1e028e21e54fb5e320b259efe528b63524560cbf77f5c8a823e18adcfe8533a6c49611f24e97636c068b4a9d06cf96d81c2cf7817c476693964ad5c031a0fd9fa1be3e5065e0cc005aafa147d656c1e888493c72379641f0709e7ac985bf153ea2f1e9a9823f7ec84ca1c54b7b878430928ab266c1565ab09304956ddaf6c8c47cb3a23626c4b24ebe2159778f9f35e475b1c4e83d121e4f35b87925d472698283481cc46bc0439073cd766aeab0a20d11944c4ed36c433aa1ea14bd0ceedefd9beaacec5cd80b189df77caa3b12e8fb216fcdfe51e801d32477d7d08a876b7f96ad3187b71976e94a46a8251cf7e440a690bc87242eaf2d0342b543e1c886d7387d59593dfdbbc56bec44014e658daea9392a11f034e7d2f3273e0f73222bda505daa585ad8bfb7f989cae9944d17d0c498c1f510ce03f6623f1dde128e3c793e3127fd627644b8ebdfee715390babbdf2c20d1e97db1cb2c61ef007d78a6ad07bfa6b628d7e4e8eb22601562e5a058100ef2df4f65501dc0f7c94fb69e282b6554c2c53b147558e1800475ad3c5e38252a042ec4dd9ab3f20806ab5262f17c7616c52a0cc171c84ac9d0bcaecf897d2711576ce602ba089c5e6be6d5c7731329b84cdd959118d19d0838e5c2f3889dd0ce56986f5db2d598e3b4807cdc14ae44d0aee51ebb42913ed7af1dac7990a93683f1d030b6fc997788e969c73ee01950d27ceb9ece74ca20ce64309c72385cddcbe8952d6f51265a1f6b4124fe3727b8cc11807ad05ca5fcb050960c7b6e086aaa957e52cf25d92995c5a41e397b70c328adba550a47c85641b0132fbebfb83ea730bce50419f80f394159cadececda6a2454bbe6a93f34ad86c0307aec5daeba0402ac31cc61dbb80a82e1c9ce0cea091c72b0f461d42d83e842787f5bdc593e98a68fa44dcf6487a68c8846f12f42917b6557480e849a106db9463822f1c7df1029134df55c7e488e7958e2fd9a18426fd3e4a7378ddb25288cc056d74d4622c71d0a14377d56b4c5189e0be7821a1c5c10c843b6ea235c0eae1e3a36bc3e837e7b1e28859ccba21e9ef72f9056b42c1c771e2a53f59e857d8af857e17980041254c33c0bee28cc1d82df9ea5173de31ac691ebc38c5f47f7151f04985e8840dc032e284f99db27793d2256a7b8625364778e19c6a2d6f726d9ee5eb76065c0112d68dcd7f50d15819e9d36e96894789f1565ec9e4651024d42c30e256a6cfb2b8d4c23b2d18c6c15eb7d49455b947b324c1d153bf9e4e97c83760e69baa0e2119c943130b7ab49aa5c2d958cf532d030322102a8b63e6dae04b1f95f81ad920066ae6be80a35fc530ebeb8afb0fe9c21c8fc5b573326d92362b3ecf603c77d393095c4b87c4d850f4832b2dd2501cc8022d537350a3e882be656a5af9705e7955fd77d92833310e746c02e449315d27ed3cae4770443b52cef049729853b100809986bef8d5ee6dc84a5f85ad5d9f120439e26d56a010cbab52528474fc82fee8bcaaefefa7552e090c2094b3d0d91abd36dd0356f4acc1727503712ddf99fadca1b5a79524d70fbb74b601b30edddbc941a325018dd002f05b04a7007710353f1d5060aefc8e52387735e2b2efa411a00cd35a9404b53e6c0d276f8270bd61bbbe20affb1ab46cfb70c9e8ce95c2884704632d89abf78a537288f996b046c7d4f8b1dcbf37155e483d5ef8146619bb4b478702d3de45996e5153930ef4761622f34edf382d8e1ad98fe27b320049b4f325f90231653432c3e3743deb31a1e799f4beeab4bfb856d38c60cf166f29b839755aa2ec516b5dc437ce2857b97f3245f75f38bfee8eea00fd0a9367048107c7ecc2f078fcc19026b03358f17ba1907c082819a1fa598cd395cf96ca4169b99c5a5210acea526352a06e1fb15b90e9749a0fab64892d89f7417ba11cf965d54f807bac1bf14995bcea495bdd9d10108ce9ab1fdf3144d2f49e4b4bc775545cb3739316fb2ab48326eb3ba9c9eba65a8838504ad059358cfe6322f3899687fe558fc7a4a75063a673eaa10e1b84f83c377ef63d0c0be0da5faeb6e5e69798c70f554585796262a653d4780f98c6dab867700528d5910c876711c0e9e65038237cb4aee9ee19fe9085455c18dd64360ed2d0ed4aa26987c5f8d94fd91659ad52bc9c83d0eb16a9bdab341be7093703cd3c17258e4831d20e90e736b820f49622ae89eba60978d38429d36d0cb18f6be096d8bd2e5248bf880b5fe320ff99b926fe051558060f01e7c25ea880ef0e6f58411572e7ffefc989cde5f0983372b2583d0d36a97476e497eeb4b41265c5984c4576bd7b7cfd2a50038b04a3873751822cdf2c9140a2cce32a9517a15d1bb96bf9cea0af6324514731bb2b8e496dd84d5017a1411d1ca1a0344bc1438756ecd25f53ac673f6cfa263ee076be7369569703c6fc636705ccf791fb0ba6c6c301590ab17dfa00c805a35998a6be055fc21786aa081d2d8a18ee1a35e98431784b49109511f403dad34ad0e16feb3e5b39baa1f96c182d59d1ab588f511cfb9aba1990af86d3748658036c051d5134357b83a8342d7a7f49f62a8ba9c942f946feb4c55bc3e4f2b88771874f29aff0a48e623dc3324398a5148b6a963262d19a00fd439ec6e4cd439759bb413bc839a7a55f7b4b861a15b0a685c88852155c37d9aa1964a010725a45d9e6eadfaabf93938150616d3d67ffe4dda1948a5798717f22540c4359568b594f24c751614be4ffdb28133af49d56350bcc5b64a9e4f2c6b7fb839b7422a966bda4830e83f781e41f34443be588a453ab053e9dc6568ca41fdc1e5ebc60b27f954f3a2597de771260a4de21baad454f9e169463281fc0e99011285791a050a8eb83eb8773cf0bbcc814d3aeaa39b64ee3cf6ec80109306a78a444f71aa2fcabf8135adc0b54535f29b90ba05d32a3b58c8566764d800840a5f001b6477014afc351a15fed9673f2d3a084ee87566a7adf9e1c99ef29889d85a72d270db4c17325bcd59e2aa681110a79a492f79dc78260d255c6cf2ad8b72f6f23c9ae312e2d7a7821e81bd3e6ecd68f675dd3169a72128c71eae7dc9d95eef1047185b3c3b2c4d5bcc9f97bfbc16441ffe9051e4107d78900569315bfbaf0305a7b88afdafa04876d5bf8414b0d785c926f6dec6d39b093c9fa93526aea72a6bc168b55b74854ea2442fc82688b428b96234212108a7584f70171b7639910aeb295efd1d55147cdd125a43210154228ded1f52d6e1bbf8f88be2265d423d72d711885edbd8a84315c669df49840f30b337cbd651541ee7ba21bca7e8b96e5fb402084174585d171d90732813b7eea239e312dc74e5371a665738a03c2b26b4a6224c97bc4d863edcc0c4ed878807e5662d4b9c41879a9eaab841168a9ef087e3297cb585404d9ce72ab2124e8e3d1f2397735cee4035c40b7bee0775d077b95f1862dffadf5aef634ca1c77a0bcb6fc78a99f3b379c09eeec39e937c30d183fa696da400a9f2f022c32ee4b908f812b7a70071a25ed4c59c47713e05ad6ae193e1bafd9ddc2b206a8ab08aed211869316c0fa75c68247dc5abae6f70e03083939efb16664faaa067f3444d0f6d933a7aee6a8929440321241db8862e11bcde77712076896e5c7038245bf0a96d2200da2bed3322e1ae8d5998a9e85a1ae64a60094f76fcfe5fb69da82ad1f2faf0ab254fa17b34bbc450c9df9485ce94bbbacdf3a2f9866e2182446b6a5a52a56f29bac18aceb2f5b9eabc9b638cc7c36098f689e4500f124a4e81601d3a806534dbc59886914342c0c52f972fd1d42b2413299af6074b170154aa2f297b47e99150561ca0a2e801700bf7f8525d1b2f90a9141afe19462348fd2ed3fc65291bff6a8a1cef2f6781ce7acf9e1610b8a9ed1b25885498181bf8356f28c64787c97f3677db756ca1bb77a4b79fc9437ea72f846bb4208c5838b5feb866178c0977b47dffa615917cffc7154afd104c7d47ed45a36f098fae49201c0f2ed4d90ebecf4f37a5e7a1eb45bf9b1bf46e9006dc3e4f73eb1d7be6f3e15c2d75879e1399a3d95713f58004493ab6859612488a2ba5ed749fdd46b05ac4adc67c72586b52467c33e278ee9fd456ba9e121ca8bd3e6e57b0e13c56ac9ea5fca80994af66c9c4591ffe9098ad9b5dc8a9e74998e786cb30dfa62058f821a2838b109304232615c19038e3b7a18a1d31c7b620e811f0c8bbb3a18353608a6cdb4e661707a4e298d8117df9076fb54d1583e54e4bf58c2d1a41d90252a1101530157dd8e8f0bbbdc2e1b033470e1ee374c7ff05cb9d4b23628d50d4395da82063ab5553895b90a8f57d841869eee82ad7c352de2783da60b4e7a363fd68b98619b2c4552a2571ca83989171a9b437e383919054a60c2369b0c46a09e6151eb7fa5dee7cb4ea00b7273db273c15d8ad70f1853e06c8e1ede9c568b2100080c2f35ecf6a073835d3e5c3fa796ed6940c08996396cf678d0ef2a2c99dcab72562da6b54f1fc0082ea9a7fad6783402fa02e43691bfea38c9ff864759b759fc49a40b5428b953216fb84950766d87ea55c65d1efe4be0acb0d26961808c1e984f288c855c7138294cd1b16d1c2df7e945437e4da3040ec985e66a84fec25cbe6d6483281406288b2b6c223f283075fa98eb09ec07c82f34b17d9c172b01f191c400a892e6e3588cc81a5ee5f59180c4c23eb60537109dc0435dbfd46db83b907170651f0fe81b583eb229c32dbca28ee164c529ea6446dbaef7d0830f06b080ac221781ae04e0bbf9f369f2c7904e59031f25fcb5419b6c790d4a1bbba9b3307dd38c3a93bd7e8e9a629de4dc56644412147d619724b1b15dc707a483dd021ccebb8180456db72575ed7a471349efe24216f0ed1de360af289d124a13ac15fcd9013933525394e360805000012dd53360bb93bb0bd9ffc80b560c934dd869028fee2f57e37ef56236254d9f8723fc5caf6b77d2c7ff7a5b2a4c536a33751dcd6b33458add869a79ff327c01366e89996ee95d5fefe0f0665f367eb97933cdeffc9fd57454c2643d4b50f1b32b9c10fb9a12c07eddba76513d42be32ed7899090bc6d4c3fb5d3c707d2300ab3d98e40f547931edbb771754e3a8a2a2b1c19a1213c7cb4f65e59cab6f847921f24aa625694bc65d50f522513427b16ffac78fd177001bf2908b0d003cd7bc89163276d098ebf5151e3328718cf1a69e607d960e02e9825aad0da4ecad4f10ee9ee40abc1ef17dd4b707db156866bfa54db265f012dd34b698ff78824e7b01b16cba187a8e716352715f7469469be60075b9ae1fba7f806c56a2b089a5da4dfd799fdaf0ddf972608eb607da8734d1459833f63c34bbbeb2b534c1e98f4e31a9b3daaa919d5ede57e008c6bdbaae9f650936c197d6b1d1a1c55fbd4b4a7fd466426fa574eb1aed8930f16eb1b5448dc3bef9c4eb378c6d263f5be1f7df28e02e03adce66bf534ae505177c0994bb5eb6f7a378370236bf0a0d263709b635017a5d601854903327c91114a7be1d9f812e2bae75bdc07bd6258001bd7166315920aa6c57f7835f1f4137bfb738bf1c7b10266367f694182562df944370e04b95529da42b5d1a515cc9aa804b0935a3f9f3bec6bcf10c02848551443b91a647f71f37d5e5cf1d7afd7db04293d7cb5c72c37199aa7c9a4781600d9be8c6d1457235f03fa0253f62a68c044219bdf4a078d7e6a9dc879056db14ab03f7f61fe3186cac8e58c80d7333443afe453f37c3fef4b4d96edbc493e9a48febee7f08eef61e7105ff4039032d44a4935e8e012d5ec96620fe56e52fccc72c6ad24e06896070d9f34735962a169d21bbf52a5042b6bc242386f06fc54e2840b508925a7dce31fa795d6447df6740733dfe551f355792e3baf2b4c872bc1929c0ea834abb25b57f4b00e4f089b2d4431e79e91f0b6d50152bf0e0e9ddf97cdf12c2336993f388c8ee792b879bf5c8c6abc91f955435a495f1f022fae948c562d7a07159eaec11c936a5b9d7d3797151644ab86dce3ce5d726be0140f119b00e5873f7122237249722bdbff7e8486792a3c087bdac19805afd605a4323717991cb8ae6c2b7a8165f6790c0b2cebb6a3ea3fba9428910a0648da22cf8d32e771d9d0e1ab04199ccb249b303695a02e064fd5bb291ed264a1db7be389ce2bf25b36482f414ce238a4ef7a13b4767be213f3bdcd058b87f81cb4bed19bae026cc88857429c047da718462517342495b2b4cdbc46cbc850c8a74bbc31c363ba975502c7512af3bbcce3d0481bd38ae55dd9d4c8c55ab2bc29d6323f7fe80898c88aa917d33017285fd20b4e2351b054fb32b025b9a6dabd7664bcfc4e406abae566a7eeeebe5f112ed5c8cb9a38af08191d16c9c8ac90b1c5994dd5281a55bfcc55c2063a9d221a6c34bf96f75741893a41e948ef9393653a59efa0f71a83559f6e70fabdc46d173608726eb32c4fd2cf86cbfd03df4010833ff2162d8e124ba048046e7c9b9b1c78ceec5cbd157e72fba61d0a72f30d0fc1c4eab8d7bf53a0e48b9954cf269ae3488f631a09fad7edd8578adb907bd1b0fb7b3030705e80d4c25c739e0a6ce1a17a5dacd05e7274d73db9327971b9dc504f6180192d1c211945ea61bb4a6d189625ca21813d8796cc31e000b7f3ed03a8cbc40d73d0d166b85c2bf08f3fa5299ec24628593a8041b115d4116f712d4bddd5b596f1ba05ffc3494eb3ccb93f265893d7720f95aeef9d40cc175b89c0ff89917f42b301fa96d293717af1efcb49ef7a90c6bef675b443346f5b2543e6dd48af687575b38fa79bc05ddaafbd13391c75ff6bac30988a543eac6c86b61d669e31f4afa3fe56792801a2e500e0f7a041fd24da146e28ae5cb10614d69b7c24bbf4ace8296714f6dbea64d97149f6ea885c09b239ae367c68d3ff1ff9fde4abf7c52a1ae30fd30a8451044eff904db66363ec89125a55f76648b61804ddafb4140dc966245d2a68a7e5c986c9a0171e594229265e5f50d1c143975c1405b813ee1dcd1908f636230ca6a6fef685f0db2060d08727ab5e8f404326c0073e9ce59591e1bb599808a548498434e05edbd8ca25f76adcee5d4fe6d8d935b0b79390a37ea93e6df12d6b2bbc86a4e13530cd6df7b647df50e948591126651bf8698d032f63256bc2f4376895d54171ea9903b9e9be029d45152434e09f49d95fb75b4138cca360dda3aefb8c518502bb5abc6b9a2a9572c13cf4ddc70742f59ff253b34487d45458895ccd24c9e01f68272763a9b99934734741ab9546e27b30a4526e64785868e5c63687627626c2f21bb1e5bae151b99b82506217cfdc0cad8df3aac64c141e0a9817dc3184fae2bd1b60db08a996ecb2134e72c7665857adb61bdc410a6d8453fdc4bca1dd96df795b312691b22b10176d77c530b33bcee35c7e185c853ec3b628282e9bcfa424f7e7a4f3ff33c8ef47f869a2dd3e279d8db4027243ddbdc462932a8b2fd46b2ffc21122feeb081a2bd64e09e2147979335fb75c099fb217986925f3c7b8f49f13c35afe45f1b6b45a6dc1c31e6b3af4681a23379b280ed1fe9bee17be4e8062ecfd4a901b329b067e42ecace05c96a3653ed369b49df1e4d0e21f64ac867bc85145e2692825c977534748bcc621cf28e6a7b2f379f0c1ebb28e2b4043600e85a6230d545a0af31019a1ce84ac78664c33f95fbe4349072b65fbf912bed006e56e4fda1289469447e3015febe9697c753174fbd817c13d974d67d705f1f1b3fbc9208e0ecb3e2a75eab53b7e5f69ef09388f9e2456643b3820a03d27727554320a3fd1ce7bbf55fe9960c55d0f3a0cdab88021716175b616b6596b8773af27f0f27d67d7ebbf09aa4a9062c6e7d9dafbc173054d5d79b6b21c6bea1933cfb521a9a489078733c43920cc409d4139526001206df57b90d69d51f0cb35e934d347b34649e9c466c6fba80db722be53368d6936e8f32eda6ea6cceef5a657b48d9f4123a98c1adbedb0d77e2831bd7db87f6aee346997d8b8ace91004f5a02c2c85c15e217718f2effe6ea2883fd48eec0037425cefeda668a10b62bb19e13dda514fdeeb188b865ddf882d16ce9b71baa43ea9c3e0ee4d6ac924e0685e5cad3b86e6130eaa66b0f425777337af72cf0b0073ac95cc7f75cbd9390ac136f8318cf0d6b279c8438f49f72bab1a5ecbfb2f3deac293050ddcf9c88ce45d46e98cd22694eac5b713706fdfe8ab9e3bcd606751be517409785f46bb63504a0cce7ee423c621fdc7e628f86bfe52c86e1773e7841fa1e0ec2a43fa066b6346686b786d5bdec56beb320b116c5c1a4ad7b373603f532085874b1c746dfb66852b7538a8470035f2c558178f19f23ea3e61eea45c64d2331aa74b8eb0684d7a3a12cf145c27fbf7cde1da69256e9379c4072dc44a4b2671c08e641161bce729e22ef7d679bbb1c62f86d356be4070668ed5c555130f7a981b1fe2767a2fd0eb5b2da9e9040effad52cf9b1bdbb5fe4552ea29f74df744c2d492f2e893d67939d1370c6bbf4e90182bd8a27cdcf2ca8de4c9d10dd714a25500a988faa5d09f5b2d3c84b641fbf2f92c70a1fd92016829f1761932047aa63aa4f637f431a249da8de29a849183a0c800c16f47990815bc18bc94f872c4c1f83a37be746d1956d7eec56b691092741a7efc07ec109d637ddb48889e9554574d121ca997014a8b430727710e1c61cef7a9600155fd5bf357839e8bdbf75af413be960fef1ecce2ff1736d04a68e5db8411c7c726dd384122ce8ef93c133c5db0f5c47ee0824493307756368d5c97a29a9b9cc7eb14591e02706d8fb4950558843d19328b205509899b7482f6a08700f1eabb75888d0ada16c2193a74da0a5f64e16998cccfcb412b3bca3442ccecb6ad6a484d47c6f217059001c8b7777f5403e8fcf62c6201f3976c7d12b836d611f8d511a4a8f63306a9298c5293e13cb3e36a57b3162eaecae4c97387191a88f4623e3186b6d56eab51f5b2a49fe89fda247278ca96a13e145771f1f6cd1c1ce4242bae94b5bfe49de2a7c326057c379e985cf18006a480e5695784d0a7f71c8f279aa81646eb3ab2da5ead3f34d2b864992016bb14dcf690eccf64e0532d22ba19caa5d0ed49d268b4f38d963d1bebccd9ded865dad707e136398ea819a81d6c4d014d6cd7db1c1ac80a2dcf6956126c0e70aca6312667a2703337cc2ca83a5b47fcff10eee64e58d09821c947062b8d729dbd1d97767001bfa5c11078fc296fc47a7a2e4708b6363494e83e533c188778db86753213c556d314f6a6ab350bf11fc94d7a2e3354ab302b48dc77571d8fb6e0f8291ce64b8c9bc2d801277bbc57af4f0240708f9e92c5a9ff7d58edb80f42f72511213d0bd8f2fa34a34eacb1b9268f9c2482df64563701ec786f20a41041cde46ff40d29ba314d23dd54b1344c83c139650f1b8a7ba5a27567e05c642f4701ca0669a744d00c7ebbe78b82142e8d52818d677d62aafad37eaa299de3b776d5349d4b084c593546ffee414c25bda5bf24844bf58c1a23061e135fd775df36ea28fe85c3626a0888c6210d9ac4d174afb8a4a2bd6fc29cf897059dae5d5573a19920b067dd7570244728188276e7c9a77c56e2fb99bcf164cfe7f8d846f052ed6158ebd48dd262de14de5531aea29adce692668676984a163f62a9d2a8a90f82dba8201b63f7c7cb0ed04ae5f441480f74f577dad06904473d9e6549e20054f0892e486b74761ee918f9fbd90b01a56d190fa080d8b5fe6ded7a054f1464b5181494065a3c2c75ee395dd32a42ea100d7d23ce2f5225fc62ee39b181e529228e3fa10ade1ae47bce2bae92eb2fdfa854f13480a47bb41e88c735af6d970a30b00b7a422e9526100582f5332eae68f2fcc69ef8ac748ddb5ab0ed6201c78956e7059bcd9fde77910d69f6d4df85a0a0c0ab917ae7a196b37eca362e6a48d129f13fc611807cb0bdb7709bb8e88c4e82e1693e6551a195b76f9477f1356a90e8f77b8a473925604ac8fccd28177ad4c78ab96668b0966f7e12ccfdae0fa2c622d51e3e91fd4cb10bb18b19b3c6b1f3b80c1a793c883299be09de8105037a0ae5fd980126422c0ae746cc9b3748de542cd69c498e4ffe8c83465ac19315e9f1f618021d9e09b34e9c8fb1e566a239df46e27556ddbcf017e3aa5cccb3ecaa42667c13b304fd3b5c7b10476ea63dec4b7eef695d393f86565632fc2ca45b38edc5b36482c634a98e4445cf2eca70c1f7b6c920e706696a9085b6558985b680508bac43033bf3a7182ba83f003c5e3b0d0ed403a558c4cd1ee816fc8702c2fd77d45487329e19ef24e76dbb586bb56987a4312235b27b33f1995d8f3853589e492a54399ede94509c5b53669d6faf88eee83ef0c0fc194d21a0c7061d6118241fb845fd1aafe249bb8f5b5c4866369efe71beeae3cab7e8448dcc3a4178865ee03c1a37db3c4c7d76ec7ff10bffe89dc6f8c0e34766bd4165493f04eadd0e8159b9cab97f54c939668652e65f506a4e234d670e84612165d1341a730baa449142328a7a76cad7bdd5b2a1fde6b6d79c24d9428bb6903ed68419b09a02b9657b41de70516f13bfed4e8c487b477243b947376191ea37eedc6ccf34eb80e8aabf32237cbae03579d5a2e140f37156bdda477363afcdc3c57f7893c66ccd9e0edf70d039373f3eb996e28b9c00e154377a1e0e8d9af83ab55d59f3afcb330cd43c3f80d4fa83e4f9af66d206c4b43ca1fd61fa693b189f2e84edc1a75c3eb380e6221d86af61946cb748e5ddc8c6b3571410bf59f5ac19d8c021cfe8ab2afb3f540a3b634748c9a5e01d282a19d57ad5c1a37c779e9888fa19863f011177084a7c402b44584989226e8d07387a3d85dabe923ba947aa8b713125bccca5e0ea669f6e9d71795ad71c19912d3e15d306baef0d79adaa8a26a88ed5609a8218b0313b0d08e77a5b42560803427724b0c8ab040adb78819caf5b9c61c321b3a66f04496401f0305bd8667568dc4f39955fc20e017485a7250554675470f68bef3f251e40eb7f494b7b786d137c7cc1ce5808c80891c10b26c45c8144d8806cec36ad80e62c39727a5ab134c7cdcb0579187e2902217b096d6ec7a2891cdbeb6b0ee565441984988ed90d5cfdee106fb29221e33ccbe27a3711eb6ed7d0e3798f534c2f644f03da54130906aa7a584d0c935cd89d2750ea873729fdcbe05f996d53ea87c46247f162f9add070eebca70a82eb18e6f8d29a5a8bca20357d82989f04193272cd980ff579d876d26f33f9030a07c0c59f0428a6aa344a5ae34abced91e2573eff9de61e14bf7bdedfbc2572d42edf1d31d62c01cab562c8def2e8d86a73b0bd6e930e40206793c0553e3913348ea4a8ff13d34bf6138e2aa08acaade863111e5ee7433b1c97adced67b8fc170d1837d3c386a57f6e3143d62119a7fa1bd3a30f96ef534e61caac63d790d0ab570b171621ee0b589012c140017d5b1ec2d85e38b29383c787bb2e97151fa60a907aeb2e2f1ea106e2e741e554bd14d63524a861042178e5ff70961b24231ec65d46497e17392ea9562823dcbd1dfff6733532975702ad1071a4791f3419619800c45e67df3e2901584717cd889f7df9af2b9f19dbcddb85d17b854c135daec7c23589306131c7a2acda82560f03a6364114489d19734d9d8baba8e6b6b341344d817a40b8a451a5a17878f6e035b90445c18a5a29c30883d7ffe3cd65012c2c4259440b59b03b8950283ce475213d4c73b928dd5e5843e535a4795a2c37935c438606040c530a1acd0adb3ea640a84a59d2e80bb9a899ba39f897684c59184a018a0182ddeacea745d0330bbe63ef7cfd4d1448ac8668aaf026a11b9ceee7d21625b5a50a0c6690f0d790d1a2dd8a85e07ea5f0f1c39331d049e617be82795e116e3b5cb2a71638452fb3d55c2a186dd3019636c9997a1d05e6c46d351fbf36f0c0df49aadb8cdbb5c1ac16c7a368bf9faa05e10a6769774778ebfc2267f1bad25ea84048c2e426da47aa157260a2852971ad05d77efa1182e0571f1e6aaba202b0de197c8c5c8e44c0bc6b44f1a7287b2934b9dc505b3736705cc2ca62a2c74976dcfe6865d75920c851240a5dc343849a7c1b0bd34bdd98c79d1384975e754accc0537416b02cb43ecacd25c1751d607d8c5a8b6349053767f3f39f67f9a953db82e109f1fd819c4821f2de7a084872793b24da0f628e8b5d2fdf1357df47e30cb38d2914d8b672466401a71353aa04fc5f4153e2903a954df32f24309174b5f08aa6daa2d547fbb57cebf9d634ef27c61c46d4d8dc8784615b96228c1fc329509d54b51b7b35f775fc4ca84e0af6a4ab2af1ae090a40335754a8fe37a7a5fc71d9b462a5beddf1b0e62b5d11daf8c4db4215b1744701d4a534aa75264178b5571a3ab10b2453b576d26954cc3cf69adfa7ae3e00a500f1fef8693d16210af2fb8fd1af0770f60219922e174225fa98a8207cef659648847e6b7e3c9cfdb31c686cb0e37ed81d3056c5442a93ab541b3de7ffe439c060b3cad56b37928c0427f1702c2d2879e34665d1aefd20f2262e88e1623e2a332798278bb30da50c2685aced9a57be6e7a97dc272fdf7cbe5b32f2ddf154fa93eb2e471c1c6fb76c3214e77d3ec1c0423041fbf630803a841e1e0835d3ed702b689f999263d7dc005cbae3974ae85ade0691e3f1d93b5913df14730347b2d0e65b9b24ff7cde8d7de1e080c4a31efc062da0fca4768452b477669a2581925c9c3577710176fbfcc42254f9d6c08b01787c6f9419d1c31b3d421c143c5eb8a6625d4a7197d1e10e95f39f39ff6594ee5b6b9d0eca4305f0e62975cb0aedcedcc38a6ca8bbb67703cbfbab32a9b24215b4721bb09f9cff3547a7f1f961020c283a83bb485cafd6c11887da6f31031c6d1f4b7e5960ea21bb845b926dbbe36f311aaecbae230720e00eff671290a9f0b4d5f51413bc29b09255dfda8022d0466e83a04368887d4c0279d0dfb0f0c205a312aa616a8da6c9dc3d3b45243f3e4c2fa99d0120750d8766020ef67000c66947719fa9fe1e6356763e00b1eaa610062fcf3e862a968bf12f5d6648d1c3c1be8f3f4d7a1530fe161d38f352c9657a73928fec7ea4ef8d39ecd91473cd859b64b6de0e3e20aa9fb7efeee4f73c3ac4dc1065569f2a69ee69b0f0ea1f5e6fbda00d737013c8d5d016f5bd8a9be3bda5abf753f5b5717779c2cc5db1d9423833a39b8de276c9456f21b1ea4474ba1a26afcd2929c66d4505a7c2668aced392b4a9047addef20b2dddbd8553034a9b015d0e5da53141276056381dc197e2c8d6d4e07188716570ed166b0a375d7ddb9e160c6ddfcc921a94ea4284abd8400ad7524e5b52a23e05475fba7d30603eb7f6176c13cf5ef4bccf90b546bb5ff80afb3cd678bff4c5a986b4c657cbda17557e6a0b9d366851236d164ec28bd2f5e8409792d3cd3989d9908bfe1b4293344d7b8d0c5cee59003d831999518875d3621ae0eba625c6c3c7452e4f9c07577043ab0b90a00a1656f33abb3911cafb10c88e0772b87ae106fa72fa6a1b9c606e343457aceda152890cab68e63e538c6bb1eaebf8a028fa7ebd1d4f3d34c3d30d1badfb49bba4a75ea5a70016ac3bef680371fd71a6239b3d60ffc49c24be4e3f2ee13ae2df3d95cd852d6139c955bc220c8b2e6a644705d3facca51e0fd2769d282022e8d104633a144374a0d27b0d4257bd54cd0ddac8571f9f541e4edd45c4491687da6718a0dc7668cc44632e8d7aa0911131ad0fdbeb61dde89835dab3db762bf20e67e1211e4470ca2d2472f049b447bc6f50f7bb8590a99967192f40909e28dc851e28fc7c0d8d9905a9dbbf9e87451e067e30390f6bb8782d75d58062f0f6289e5feb49aedf8122ba63d8acbba29744c068d62b6cfb3944cbfdfebefff62fe2d4afac97b69c0ff29ce462e9ba2d72d5966828d8d21f6d377e541b03de6c76b82fe30af8204fb8a3901e1b018ba0999fba9269c2c57a63e31b7fcc6023b137a0868d9de176af3341447c816fea36a36a1aa3dd5f463ae57f7b71bec0dd4579fe409c6cfc4f49586fdb8d637908ed78b06628601957b1c7ec6615cf4d06c856fc95969a64488f1848f1a57aad4bd546b726ef0021a87a5b383a142b2dd917522e8b975d17a2d0fa662e8ce0ca0890f709e97f55e64ed6ceb38cb6dcfd8720d58e2a43260a4ba7bf7cc1c670d2e409f38aee91185a5c8cd3c92dee6fa5ac93032ca0ac707bb0e7b039f829772ec7dad3b313b02988c63f6b4bc940995450bcd43573dd064d043eca423ad10043682b96d563dfe8237e48d1f94f5aca21fe05d782439c24d5a3bef40935846722d3b2fba432f57017dd69ce5cb855da178a5581b043725891fd480400e550fe1ccaad017ef89e841181fb3ce8e8c7c2501ee04267b1dd7f35ae74a8c301f5245be5b7ea70816934fe5f6ded744142b2ca52b31532682cda05fa99c31b6b09d52174b67b985e9c89d15f8732a91480dd833e1df2e544c677c91788a02905c0b2753a1f4d37f8f793f7331946e3127fcddafb35a02be27277557cbecde30d3874a8339aa249bbac866e74b63360e336e61073426f987f7c44229cff843c9319cb3fd1319631eb4ae5e07b554742356b9e653bb128f608fa21500a4611d7519e61e9d843a9e1a2c3d90c2de72585e4bad968549694d85b46998b69975d699dbec7dfa437dd7d5b2114593a1c1e1405ebdf7b87c1c89ef664ef5abd7def72f43aad936eed4eef63b2097403af04d4a723c18448a7fdcf439f40ce4587fd64ed84464076da2c2e3d093a27ec629590da6219283265dc34ce3982e489c0f443011220a8f4b80985fcea795d5f8d7ddf38da37069f468126ff769856af76e3eba1b62565f2d26bde743361fe28c6506f7d5858bba66e4eece662f81bfc1f364f4170671b4de94d9a8ec75b91c76d59f62fabb3b935622401e3de58728e72f43c5a7083adeae9a028b52cc5dbf9bb120b0add998d1e30c3a58ee33cb065aefad6db748428bd1e2ad8819e92eb0bcd85d03c8b253fc4fa4b99a4cb48e057921bc6171afc691f3ee3e0ca09b00ed8f3390b20e8e3a08dc3cfaf97c9aa627d7490c187c9ac2370a7be9086bf32b39f4b4c876f877e6be889544ca95ddb1eaf862f1cb899b46bde08ddc67b59900e0ddce13c24b08faeb8a2d24bb8cc355ddefe268da050cc19c9b42a74449f09517d9aa5631a5da07734ef6bf2dc7f9fa6801d67c6b1be09cd598b2034a7b7d67a24dbbefefcab392f816b26019e1aaec5309d63d2d19d357370708b8d17fc06d48aec557d590154dc973c1437be488d8920ba30ab989cbc79c20b7dcc2032791b7af4df3edbe0b09b5fb007d96f2363c5789327b447c7b00af038e1018cd11f7bb76e02e95fe346dcd318b38c5f688732a4f68e2f46144a6785190b7099009173a99f565d37c57869a5e39482a7149c848ccd193a07ea9b48e17be287af9a071346bc0fb34b93491b9ea317de47f455f1e4e47ace3fdde2938a03ed1eb61172489e1d83acc84ce369c57d073a5d8aff355eaf216556463ea33e789d632a7f83174b17e3a416b49c7c6e7c45c9a02314968ac4dd2246c9e5e0d73f7d8960a629ee39598677e692037f5146a97f71f930728576fd7b833f193f5b9fd31be977800a2964cf8d1a523b1581683e30d31bb2b8fc8ab26c89e3400ac683858590b08b422ca9ce4c37be50036e27a4979ba30d9af225771e727d80198ae39c91c7baacf48b8237adb8d008ea3c6b5fb2642d234dcc3adee06dddfe2c5b9237790592d14670e95570b6db04d1ad869ea1af66c9b98286f2bc656684d06a8477fd22a3aa1a265d5084353ce9fd153691c172ff768e98ec9f8fca161e647e15969192c247d8998bc327b12654f08bd67c1dea6fd2cf738d7821a86ce384b36b7c44aec8befda3f3b4d0754fd1b753ba1f2e03fc38f1735bd3209ca09d27d04b2133a60b18859d5f1cd506bc753163b6176040c70d712d864f614ce6eade7b8863a663815c7acfbaf66bf163247be51d056e75f7d5ab4cc19a1b42c938d7faedd8b2ccf5adf56f6577d63efd2a832ca1db06f404c21d3fcbe97e6f01044650773433cf8f93abbef002e73e9301aaf060385e804fd8f701a75e99e903ac3c1c4475e9696cf39a3a3ef83d8b6878e8604158df878b4ad81c70b2d1c37db5a5809113e37855de2f0f710e6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙王子</title>
    <url>/2024/10/05/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="35e864ebdea4438a55274302c21c9f17caa8c3e4e10e350576ee7fe85ffeb1ec">adba944712a73720e1f31df1fce53744aff4acde6f2ff01426d8007fea30a0106672f77db4111c54b2531360773db75664f559f8c6573bf0d7b42da54c603141929bea2a2c3099d553438ed5e521a7df9685cc63dd663cc7c2eee248260a216f6c52d2029d0c22bd2d8375fed93992d2d760dffa4c1d00c2f8d9ca0f17ed18d082308275f1c57c1537bfdc3baebfe0f987f716cf608938e126def7e969207e6bd289da4f5790ca9c9bbf2c1142869643a8d4ef0b27ba051fbbe692fa935498d6800f22f1226f425b85a2c560475dedc0d4edbf0e625e78c9af2c80dbe119db23ef3f29cf3a6935ba9704a349beb3322e421bf37e17a36347258101314a84565e9076978c0f41c6c3e06d065003f80f7962809a3f3044eb6e805acfc9800b1c503ac0fe3fdd787f6053cbd278f8690e7f10fe392228888b26d983136f4c12b89260312bc904a2737c43da5f9157d6cd654bdea1add6a70dbeb041944a1322bae74f72f868bea31c64578fcb859e33be539526e58a08c8c89ed0ab7c359d66e4ba981c91f3ae544f426370187f818717f7db8638f41cf62721337f1e3cfe5862b150b5398e58025821561ebc67b55fa5687984897f201a7c30fb50bd58ee00fca3bf1397e616b8fb829c0e8feef60d02415894a5e39b5dad229bc6ffaea826aa9ebb3eadadae3dfcc32f50cb5fd322d24229e6f08de6f5dce88dba0ab216f447ea30783f89c297e17045df666de0e3b79c66d5e6394f05d196d867fe529a16cef33ea5001fc9a9ea0ee2914457a61cbaeb1e26a5a3dd72a9f587a1ee41f631565869aafc1dd4a9a7b3a687dfbc84024683140a12b4b6aec949ed4df27d0369d3bdc21442996d17bd37f217543ad9792d1dc72996cf755ba66e9a928b4ffbd25794b693ccd60ee311358a2d4f2267a07f32407ff4435a84a87b11748716a54a3e058a9ffbb0d4995e4e55cd05416170181c6dd558b1e30ec1cc93ddc58b0350008fc4d33b1b8c2a99e0010a1ed1f823bb7cf44380c5b72a6c0e49bbd53b0e2473f570a9936e94c05712fc2fe02576c539971235397d3e12895f609c2ca9b1e8230e186c9832c9ca4e940f5c0bd9fe33a4f928e8a8dfe0876b09b6d55b5b2ec94c4273e07ceb649f6c8316f8879726fba60ae66736d760aa5b3b4383f997b42f5498c7091b123b36583538df2bb29c266a3cd63041785698c3924f320337d6def79ca968673905df76a8ca6dbde8b115c103c27591099a8fad531e310e49d1dd584f46371e19faf37b00ee56078bb40e0981e1da95115713e883b14fa4458e9c946ec4e5450d5354963f5fb9925769b03d0cc180979e73ac98d0e478c7e0efd6234765b77ebcaac66617d1316d428a5935fec264814279f77a767b5c087daecc1027a8583284d7489b64c54a48ef9481ddada931f37d22019f1ff9657cc56d4079b30963ea21232d68456e919414700c52cb10189a6ed4938e919757f502c1adfaab5228650c90e45d89e5b3f89acf991dbecb78ed48e10bdf451d4e9dd41b241d336f37b5072958e6d915a0310691c3605cf3867d8c8aaf9bceade4780c94d51f0f464ec51ce08fc6cf56bbbedc07500bf236fcf16cf31c9acd53147a46a244536a44ed17c37ba876fa3c8f624f388a69e50f599b25becc5ebbf41abdcf59ebd49041e7cf3f971cbfee1130eb37616c53ed9544218c73ce19af4062ded2825d5f8501f00f80a51a68405457eb65adbc94bb44dfcc00bf4ef2c114273c95a93ae9e9c52a376276a8c74c44979091e0cbb2975ae41364fdbc67b432f34b9588ad5127552043596c8d670f8636e1f242a9212f8cebee3e67b70d3276b1bfd937d8b2d036bb97c1ca0a16ec079e11641e091dce68d383c20976957928cdc17bdd7379762b7ddd1395d43a32f467e14f2f0ee532692818b63bdd251264be656a37e45481dbfab1af35ff999b142009aabc257c9b244d31d29b72354de5b928f846279cddd8c96f8a9a8ba94a599283e1c3d6424563786f42b4cf4c01d7d0d6c661dc58a5ac8110bb0c2f185b7fdfd5a6ccb8e534dff3e5e953591b5b6b68950eaf830c49c3f9dc87b3df2d36b33f647eadd0895b1dfed0fb968111538b3aed164d0cde626988193f288e90db99d41d673f269b3d20eb7e331e341a5d7df322186bbdd011b21ed1d673ada3c2f38e3f35a84b8e8a60e0e06119187a4d0b31c4c8acd61151338ca089e552d12c5be33323ee73bd22c932f6b38bbc467f5b6ec078c5a1cafd22abbb47fd96a5e34044f9ad9950005aa4a98090a1c0b3d6b825c0d376fe61b8b8c72fad0f9e113e9c1c6df984f619c5ec431d00405d6d7d8f8f00d33d1cb7db8792cd2f09279547f13e18fad52e6cec8b19b051ed6ba0ff9ab1573d4727411bc3e31025a0eea276220dcdc658c8212e8d5d740682a89f195cb95eef09c71c9c836d8a07c3a4481a94bf840a214ad0fb67a1dea836b36cd72d295cbddc33a0c4880935c77cbc0024df59546d8b95050d48a53f9d912e4ee07d65bb102ef0c4d49ad6000dfc12235133366d0055aefbb9bc624eff8fc6d73f7dcc71433c5ed765ddc58af57de2388559fc825f556e2739d6019b2317deb49312261e1e48d39d2f94f7ded72ad78dabcc40e864a746cc69f1280edbad1fb133f2a2095fe9e500ef6c408a6a6782606d0219dd2bf3e8d0d3cde2a2ff2ddf9ea49317e4385ede11fb08c8cb19e5d061171ae23d368b9bdb24973a421340d1b905ec3dce74e25a1a121ea9a103df8e0773be84353b096ac5fe3988b158ede04b625f1e0259fbb816ef5bab4c49780a8f7840bb577904afa289e98c64a85d86233f5e933f007a2b41db8e9c577172641a7a4c9bd84b3f2cf52bc850e039a1648e9b84138c1158141902a75557afa9d11780a7cafd455ff2131c669e7003a14ed3da9f2ff9a618a9c188868eb439cc50ed6225e85f83cfe10622c940f5058c8909bb206c1c8aeabcd9336dd90c4103e8235c5cff7cc6edd1371832ffc00d17d4e1475a3df1338125f3e9c865061f2e8c0c075986a7af2d71d7daedf279f1ab38d336f3e947783256c3e6bdf0f8a52096f8e3e472331034e805fdef9c1c0af8e2f2b63107fc4c1f928dfad840ec3cf14c1373fea1ddc07061710a567b48601d23c541094b0b487b7123987965cd459497ce340aa8cd4d7486fa3f41a45ee7e99004e4204fb76449b363218573cc5521c66a2e9d2fad44d031a8637c11dd09ddfa7c0b8d414d62ca269eecb9d8834818b3b0ab1021d68a4e772065c0212a260a4bda1dba07440f078bc5cd9b2aa1d69b2e7edb605a4e10290b6066b9b87e5dda7f6d00b8a634c122b57173b0f1ade80ff23c13bb93228cf273791b4ea25139548ac02508ebb3378d799d4148868223e32f765ac6107950e9f5e7b6c630ea9335a1a06d8b747283aab6387c2124d4f456d5f81b1873db14155ee0c8c47ddb68be7f31313d6a4aa1a1a5cc7aa4a4c892092bc5925c531eca9e8ed536688029d42754fe893a57e081048b7170750680a9b0ff36f249e23f33813ac01fd42397aa2e5220c7fcc43ba7430964130d84a676f9240336be815a9045d5a4147e356d899eaab3f64beb6a92e67065ba36e363de03b01cc394d8cdeb3cf1e995c78626dd7cc80dbf5dacb9528c1e4b2f5ed2cdf6dd818c3bb425b2f562027ed32df35b96b83ed523ace4c6789a0bf438cf2d76a6250d3ac9dabe5ac99febe680ac3ce22c1bba902eb764df11b12825265e1ac33927e99abebbe3988298c9c4501cf762a84eecf3141d21198f7ea2fdae4ec7d2769028d3046494ec73cf5a4903f427e5217e3a24e6ce7efce1ed0e0eba79a83ebafbba02370b08ca119398cae235662713356c9448c446be69f89ab12d9de71e5114824da89d147e2e6e137409cd74a488dc594b8ccd8cde28aadc7a4b1d3d91fff56bc814b664de475ce80001d6d4210f10a5219150522eb54c6d6fd82dea2319e94e054cc1dcb2d96ff5ab0906bfccb1c6d4c13f95af9f319fe840badce9335e888c6617e8b9d026ad986d3d0c35c7ad4fbf17b78e50cd1f9b52a1f9e13b66b5b3adf325b6d9fab84f9ea99816fc3e6c294721668267b117483aa8be34964bc62322c2ae984087f2c62ac855e09856febdd7485ff045b32f944f3de898c9bb0a2bebc28ef106cac8f3724495be94254002c2e2cdb3e7b6decd4bdf265ab5ed420d6eb7de081124a747a70dcd38ef28405dc94a4acc82aa1b2f9b4540d152b67d6992d980c7c7a6fb261c8b9e8975aaf71188d88b7bccf5d80a3a41435c9fb45e4ea0e4ca21e940ae042777285d8707abb8d617798fe52166549466fd2fb8e6ffd48ce1f5a9005d06ea4f756d4bd5f5456dbb45032fb4dcc75d71358a16da7cb7bec02af0789efe7bd9e8cc48e9871a2907d3076a23af36c2ae5c5fcd66aa6d85a8eb4e6e52440995be780bf63106fc65e5f828c0fcac7dc12820e9d7c92ec2370b35ae1967dbe91c64701c414ab10a9995a8fc7a104665409dd878557eaf3a30670d57912475c3a63ed5e25613b1f500734aa1efc378b761c37fe67e493b30194c6ac891fd751c1c36d70c9f936b20533cf381d382244fb0a55ae13d0eea65ba043bd1625b3e3412dd3181471e3b474a2751f9c2536c9d17b6edb71bfefb1e658edad4fec317333a35315cc3149c8d2af7057f89b88dd43593598cd8def09545be253b49b395664a86a116e50fb34877235e01ffde2f94325d49a168c627d5f064b4019c130127d40ad47dac6e0af02e959848b16124201775de12289d0aa53b37630869b786085f96969784ea1af45d1d013c7f527c918219946d6d9cbfa8b529ad8487bebd75aab9eb4ec5b5f895418005089c9dd528587f06bf0589e6afeda7aa3ffd9b9324180a6d6fbc11a000b76d881babd1b9e737b0a522fc7512663cc045256940e4f197caa29c2a3ab76e065cd44075aff30904209f1ad50253a095a23601907e03a91a22a1ca38d56035c2703e05e43bb6df5854acebe91e3a218930904894678983d8e88a77388ef3b6f1c1ae6fdf8e61d702c07b6ebb7777782320fe4c74d20afafd848c70bf161adbf1e90d65f9a2321f201a1a7876f86c40cc81ccf5a601e6137226869aa9302120ead9f44874782ffe2770fae9248cb796043a87a7d63baa5cfbc795db0e17b574a2bfa63de9d1d9ae2e53873b1730910deb29ab5790d5b6e988c60038dc64b94b05e2ffd38a9ed1ff4431735f2214c619e769f5efd5019442248d57a93b4c777cadfcd97580f36311f84b65e597aea6f8fbc14b075dd4fbcb641c2625267874e4ec217ada80dc5fa5a986ff4e34406e9c7672071584714a452385e34e61736f62cac3eb2cb307df69730d1f11d1dcbbcd768db126b9b3752ed27756589e7ca289cf83db3208ef4559cfe7b6c2d21b58ec6ab8d3d6c799c1e786899f11b8e7ceb013c5a141e9c0e90eaf6b637cc966a8f61dbb8c9463aad006d8037438ac0fb2a9d775f6f8e64383961aae19f322220378243ecd3274a19ef36572c8cd51ae1dc00f2461695cb5df1635175c8093fb0fc3dd6e0c9194a71bdf6561b93206f06070e3eba1fa93dd5c1c8bdcf1f0a9fc4834c402868af7374e1d76e10169ed1ae86995b459355668005bfc3c24904ddbf197bd9f266f6757048dfd8e997d6e89c3f8d8536436d0ccd5541d834336766c47f8b84efd51f4989c0ba70063c85c6f6b137d1436d9a4c69b94d046c897695ff383d7430eab19d39d074b81f1d7375680a3d645eef9c2840c96aee55d28285b090ae99526d99eaed16bfba90ddf93b3273526606564389cef1d77f4406789aa30de7b61c57f020e657672a327915784277cad62e957c202f8943751fc7fec22365720158b6dc61f0ff0fada72c6fe925547fe5f8ac0305f2a0beb061b8f04820911deef70ee15ce74299ff92f2c8151d874ccce88f575ab3d09a60a3a013dcd9239fe92059e93a964a49d81011bb24630049ac534050ea18954262edcc64d627455a08ffc5e31f857d3636cc90c7230025a6cf16690265f9930148cae037ff0fb5320a242571dbf2923fcd4d36217ef7ddc48587e81959de6e202331afe786a71e1bebe1682b491c285916675b753c2a89e97a17f32f4991bf8afc64e86abcfbad3b958d0c268f7571a0612c62d31b38427974c2fc82ac6d570f77c63db908a063d4008274ea8eff8b90f412ec9cc98270281010672885ff85f35a638d12a721e6ed8629b72a7bffe2e990542280becb8e5ae8f13d64cd17ebb1317058fc96a53561ba50fc21b6e7c16e951294c6c17514c9f5be69d51e2001abf0561a8991d618f0f5a11a9fe117a244aa0c9cd2b400606343ea9d2301938f9305e156c10578141fafc633a0d5434874a1bcc71d8029df810607cfd2421413f5fc6f560a910b932cac1179102a12b1e311a70847f0e105c3946c0981a8b989b593156f6e961f867ce747a29eb39d67c226669a9b0217892cca25f5aebf8ba75ba4dac8f2020e56811fef74b4aa32db1b23f626b6355f593444b8cae430f9eec071b5ef85ecb3cdcc2f9c62c22286953ffada6b733e1ec12a0dcbacfcb8132506859186ac63d5697e34952d80204a5010ab559a6288bbb3c3b713ee2c7c2f753ca63faecf3a186697482eec40f26b06046d192fdbcd09035d2b18c71311b7829733b098ec61af258d768227fe4d6b2a5984f78d56cd72eb2b13c7b685d22eab3d8e645d398e6115e511e65e6332b699451f9efddec0a6ddd67c4070d940556a266dfea3bc4ef267593ed085b836c3a10a4fbacf3f7e6cfc14e842ed9efb8885a58825ada5e72d2602934b69b40715cf95ac0d16876655ea346f1eeb0e0d38e9b73e7e55cde4a609f2600e0c06219f7528db16880ecf02267506c43815964bd799c4054d40d1c223fc216cc088a32c04695f2becf3df77d2aab0e14eb28d902f2260020ebf71d90271f269e93fdda48c5c618a3793754b2eb2aea917e897f0b3d7d44b0186b7cf01489113b91bcf9461d1fd2d7bd5bcdae4610ee8f5f0e07dabe82ed8856df90b9c2fb810a972498ddc632c614b7a30dab520f10490fcd11940178afdfa870edb320eb2dd6a9900717ac19874c2cb6b0bcb802558adcd922d3c472f6c39ad8dc58e4ef11895b24cfcbe0fef4af378f8bc99f407d91b7c469a37dc53821d0975d2f54bc5ea4c6516e6d7c3f7b44dc0b1010187b39dc020f9edef20b5f7f9eb5e95d15b6238ea5b3fc877332b618832719f3d5606e0f82deff31c29442e8814a619c98c58165211c45d7cd450acab7811ac8e2ea65d382719eb2c0fb24c74d91f961833d328f10b2e490238d09f8977dbea52e8795fe1acf38ea9d0f6aeacdc31f467b469bd4360e741a3be33af15ee2bf412241238ee450bc23466bde1275c1fd3ab70949ca4bb533bc389a40d07e5089fe96c63168f729c3480e5a08f201bbd968d1ae40339e67110d989b82b313b3a1e49a278b1afb0cc7f1850e62f42716c6a9bfc0fae33e61e27fc0bc450fb8ed60523307f8d2d196d93b8e03af3ec56d02dd551bb277f6aa511a7e110f295d65c32e9e43e3e5612b74236f7eb6e399618fdf4fd34c57621e1dd1f2353407f496ae447e9acd7c920fba27acf6a0b302e569ee8b91eaf524031b3ad0bd0b455d706af499cbb8fc6917807edc58e7fbfe3ef9193abc42e2ff7c2ef3e25f6db6968305a2f5d78b2bdb9d5b9867b195bdcbb1e69fbdb96f60581db7d1923eacd59e54e7a0a41bd6ad80a590f6d7f1d521abeb96dd6dc7b9b73a5f003787ab633eef948b488c338725988e833afe18f18b309f3a69e6f5d5da881cf25d77f272f9b76be22445ab4c20d430c62f0d3dcb6fec57b448c9426084ee444839206bed867ef2161dfa4e94476489699621c683897af5864660f1d2e5c552b00a2e5ad1c238fa2f28e3d7f926f9f17b5a53172e05d7ec37952a968d001774903c7bb19f3b4903809c46c48c36e0b0de98a6ab0537634c217d09b1b489fd250105ea83927cf39c5bdfbff7c10f43d94970631242586dbdd0c91b3b2d58866836877a201669e3ca2730bd9ee0fe877b42c0fbaae660cc3699af23584d347c33356c92437937ebd4037439633e8681d032d5a967442cdefaada225b41506aad6c6c1585ed6bd4808c430079ac30cd9d0d2b765a4ad74ab35b68d427e84c6b74bf72d0d852217c15b08e46e05666e1d883ec407e75e9aeb4f75ade30d6f6a555ad3b9df0d37a365dfd66bd29ce82f762b6f600cad703bcb24906e351fed02c934cd164a22ca7883bee70addb96683c0e061532df46b6733921be1a89add36d3d5da5abe53e12ebe8ca00ee39e6078100b85678e9da68f670d12e21fe1fd8f331891326cc1f5fc9534ac886ab18a9ae8b447a6d1abf9169a7f3e36536955f6f0595f3b0c486fc67aa7ccb1ff3a4fb1faefaeabb46b6457022ef717113bcc706aeafdd805ea862faafa85776bbdc83dec19adddb1d6a66111db199af0a3f7eddabf9e335386176695f43812c1db45b386346e15e7df8b788699821406f0f2323125ba076916c97afa37e6719d5c343cdb8cd3e7aa216e08b0c4ac3ac3756fb5eed3bb3f0eb5e0eb35f0f9cda604fabc25351258717849d5677e3fb149eeb55d51f8a47f20c431c86b0ec1736d8d4bf578bbdb685299c145fa8f2bf9ab5a1d33209c80c40b7bc9c827a3f462e51559df175d6e9e6484253c61d3b5f7331940abb97963a1ff5949aaed2449c5734a337385759544adf37a60933caf3eea6e53d4ddfdbe3b5fd6b3f53aa1ed1cfc997f2425583c10d61538cfcfe5f258c2983a8538ce69c8cf01d85bfcf5f1dcb6c9edfb39f26abbf1b47596104c4874a4adb5b45262919dbd654a97bf4e3904bc54290a19daf94cb09aa7e38b0b0299fca1bc528f738456f891e15c789f58f4b8f58827fd6a95f3563dff8eb72def798598a5786d8015699c788b6dadba5cd86822704ff7fd56513fcb0a10115f8e1cba5609435803f6c6362fab8b6e6b7bcca85c6b49170dbf1bde88bfd5e7f23c5b6b1bdb79459cf6bb4062b14c847934c1e54a9e065c7d232a75cbb419951407de00ce6d05a35a5ab53876b9696344403ddde860ebdc84ee832f2b72f9461d12039bf088169f380b8923d51f1e2b30424087e9f077dce941b6ed0217858d3129ab1934748cd9ccc6f54358f8d02a57989923b94ca28635aa345ef7335ad8a3dcf570a44c9f32c1fed9ede3ce813003cf096d81667230833719801d272c329cafc475f871025466713fbfb1a34b5fa1864fb9c5e68d0a3f43e98115eb9d98378c3ab0868d0308531cf82196de257b7aaec3eaa3d860dfd5fc4b871b49945c0e0836072b551b108db802d435746c0baeac2ac3caed24f4085cfe8b307d6728a84b947e935cde4b9788fc9078f491c3de8883ca23945db921bf5fe80534fa237b5a73d6f3f0a8c5dc311d646865d7cb4ff9d09a1cf9519eae150e2a872fae2911c534a348ec8063a2c8b7db6c26e47d2a13ac16e7b1f4f49857c627d5c041b916cec5893b9fc1d9b6760eb484253779358f152399bb34d4b9e6726815988781b2331d0b147104eb9886386f8b4ae3c413531b2f71e1c213e2fe513da02277de1c9c6aee5101edfede82d698e73a67017996248a0f0b926cb94548f3d26a60806f4ac754aceb582330ce06f719cac060bb2e6dcdf26dc2538e2dbe3fbc4c89d5568f8263c5cb9aeab6807ad0d26621a7ea4f5d2ab9e06cfe222652fa8f55aa0fd16567967bac66dd34f91c22978be9d0c3ebfbe37b4a6c646684041dc414b1667b3da8cd36d87b5b0ffd4c30a4fc437d21558710bc1b3a659f07b0ee531aa437e5bf26e349de02c5603517e8473ea333163b91b12f8cb538ed0662fa0020cbddd3b7cf2f458024408d750338ea675c27e52a250ecb872b997b258ef52f549887e65511d1245f42bfa6f28ca2f00b328d3a1fb47cdccea825f3406f960d509308c5d5402c5ebc11966fbc58eded468d69d969b7ff20f4ec9cc9c4a9a1df4ecab34140e76896cba18da8388f7c4fb2172cb4b09f81f9fb836197f8dda5b16eb2f632151d400247fa14eb44a4107acd0199ab803569898e9e297a4a4c7678298984a9d5a57a6c484f9bfe75e7a61643f91abca53a5cf42c138570ce8d54659a6030675317dbc5c573a1b2d895792b28ddcb83a683153c9936a969168ff64d011f05c1aa034fdbd888e2f86c1bef5e84e5066ebae82c5372fed1745542bc6a216e0cabfc8095e7358bdd5e70eb6494204ebbb9dd56c172b7ecca489e395815e7f79ddbdd725e79f56bb948f6014b11613dbdcdc65d14a5a95f56e47f83618ed3b96bfb1cdb0a3986eb1173ddca4b1baed58feaa733e2b1361cbfdcf56976a46e738d8148e0d6f216f657f57c0a37647edb1d86d07a78865722d8183713a98adb833fa4e918dfc0372fb618da2c3dd5bf1087d60de02e3de74fc1c3bfca9f4df22b0b0cf84a0e6135ca48e4eef1f06895f55cc6cbff8c2a87741ee0cbe38001c95bab80ffd7412e6f8077b85a1874d1dbe35c4de016d8a7c3ed0cdcb1badf40c424f26f3161585572fb858b30302d33ea798afa882e480814da9d50410e2bf5d9a2a81dd74858263ce67cee1e19a05b3c1465df79ef10b0f5892a71e76c80094d078e4055fe9abf7ff1cd0a8c831fbc80e91475a0d2ea326e1b994d3710ce62a8299e429a2e23aaf53f82e5e5c17c941823a483ed754af9134f29dd4c53b1896aef6e467214d08266408855a47be43f92712ff675a1c4a39cebf9a8edf7e71b73f63a893128b817cb313a07cdfe03d89e447f2a6c3382a0e8dc564af6fdefb06f8d2fb5ce6d1b480c0fb2588b65b57d899e73a826f54ba1a7d9d7c233bb2695cff4137b5503513efaf8a9f9bec7b4dbe730e423b12f3e430897546b25c146fb4572fd659f59dfddb92872a9728fac8ff498eb27f00c3d080b4ebd14b95c4839b96e8d94</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title>海的女儿</title>
    <url>/2024/11/21/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="380472343a30d4796f1eff5e6bf9ae4eeef7272237eb387a09f24912f06da966">d61778d788d6bbfc8ba95eb204a364f7f5a073f3158b5fe99aed3272a4b770b0f1dd051574fc56a4c70840cb6baaaead41860c13519a5d9629f127e223a17579cd7e323bd0a99e81ffc41e27b72f23032ea058fe7c45ec29801dd195572b254b4ed3f337bc06f243a4859e9007dd834701664791b5b957bdc0a7f401a11b6c69376a9640dcc0b75e873016cb642dd5a6bb7a970bc8f7fdb6567e317655f28ac64fd672568ccbe8f65f6f34d6a004326c270ba068216cf09ed0c1412dae84af4fdb6f78b530f68b838765876a04b4a7d7dd27726bbd2c590742fcddd74aca4ef05d7b59d95934ff61f48e53626f9faadfa06221b4a062c323153a24e8005787948f87b49f18f83c3d38938006d700f07858df52f107865fbb8e077fa728ec93ccf49a27d03777ced365b8ea07219f825fecddc969e9e6443b44b76d0994684bfa30dca207cd527335c2c2016ead8dc62f8d8eb0d74579873f9ceb5935fed1576048e3c945457dfaac365888a40d884bb4da5547acb358a31928edf1bf677b49a60f7bb7e9820e75d1ffbdecd2c4af1018987d50ea131b486fbb29eaf14817401018ff1ad056cbc0a8ab05fa83e1cf8dd02efab5e50618b34010c71435182fef71adb75977a20769652988c3cfae6f0b0de454f9c528c8f0a73918a9ec1086fdc7b951c93a158d8de99dadf7c0a46575efa2ef921f24f6b7f28d0fcabf17f78b5b418fb62944e02dbc6e10e01c57015bf796c86d5848b5c52d42024f0e8ad7605f1af139e0a122060eed49ba13e450241c053fe66c5745ea164bc942697d6fa5af6b6f45dba252dd8911ac041cb744b5170dd24f1dcebf96e1a33a10d6f2cd3192240be5912892d1203b36e531fd364cd207952a3533109afedff381acc78ce82f99fb6d82dadb31e89797f4fb7a76d49b5e1e43554abbea6e6c13a76423481015059b3068b2309c6e05be4d88cfff38707d10f1b11b3d428c982e1e87232161f18567f48f6dd6f5c19b47692810ce4231cade68e1f9e64ea88166200fc8db2ee85905780ace0f8cc658549369588b01f0431de03efb63b4756bb83bdb6f97493eec37f9e2f847bffcfbd883fcb1b3ec77dbf7a158420e8396cc84050ed222cae2916ee5f525cc978eb7c717b4dc95bc7f74afae6bfea6c5dd66c5fb19162e9636c3837a5352b4e8d8713a04d73fb5054871d7f79f49b5bd775e51f88999e18a80b58dc604ebec5a5242b2a9b5907c23475662fb10a3706e724cd92ad0ca89088e18453a03c7f1fb2b20db5bddd935f9836ce572bcf2cdbfbdd5d99347d58aa1921524fe9eb62dcac60ec849fae612c668e93e0e82e832abcc33acc9c7097b370cc671b6b871d209e435b99c49ba3edcce81c9bd5be653b030871c1b62633ee749ac59285acae9cb84f94b125540cd6a36e73ccaea0673340b9ac56bbf2f84b086cf4b6e2f643d7a3c8d0c4176a039c739e8bf4e321fa39e335445d78056cb370bf4f8f758f9f08f0393365f61be33c5653705f7923018ac27e2200678ba1eaaf20cd0d5c18b14a9dd962e232bdabf6ae7b96aa60ac659306a75613eae210f362d9ead9a45a687d364b012643cb7a1944adaa7e04fbc9699994c46e236093283fa4d9a4617d4bfaa5b927662232fd5bd3bf1b88b56585759f930c252bb4091885f567ae40fe651f49c2d82768b8977179fc692f3295abdb43cc1466781794ff53a6936fae9a1f31bcfd7082748d9fee4c4855ef1861ef401abe6e7df206a95240823376f75a03406ae7a164885c88a7632017cf10cb8e732e62f5303056013569fe073eb15b19801f9e12c8c3bffb2717a0b49ffb08aa3bd4ce792460d060364f35f6dcc3518ef04f626b0563dbe06eda33eaea2a7951dae526f61ab9c845c024bd6cd266f78fe65567bee9a885a47a82af84e780a7d13620c1a5a82fff5ecd3d825d1df4890384bee92b4f90e1cd3db8cceb4dc94d879583322ff5a8138ca987769bdcf5e7a81d41f1a62ebaee5334948f76e9760a16b09465f1557c095e16c7087346684265f46bf4c8b9a6858a4393c100b9300cac492e75982881e7e2596bdf2a947f9931f5245d479ef469b9ba5be643d67c22615a69701d20030bdb44cf752eea74c667d7c69a0e912639c115c001805a52dd31ce56066a030de8487c2163cc1819dab78114896b38f6f8a251bc61f8fe05b7a1dfa753f0ac07c39168778473fc17a7ae40481a0abe4b074d5d1c09faf94f36413e351cff847313e2f26ee4d1d216a69dbd9460c7f255fe6bfa2d4ce8a7c3ed02caae75761da5e16184e5bb41e3a442f4c723ad35104c73e2aafb9d28b856df7898117a0de304cb33e31fe55d94b29aaf2db0549d961af7e081546bb1573283145b5a00afd70f5fd558781dde14be425631e11e39c4bcc610ac0176ea69398d6dc3447f8ea2f84bea9c0ace48543e9bf530697af72a51ac28d20d89d2d9e68a40d7927c3a965b0283c9cbdaf52533c9d268058705fb8d367142832793f5376d61a24eddc65bac7fa9132f3e504c820a38360b4123c54aad12d9a3e3c52d83ddc9dda1dbab375c10c03c1a26498bab9cf25d09cb0387102f11de34fc7e033df7ac9fbae4015f513cee9aca4353ffd7151ad256a30139d8e3215e8b45fab57b2132c4ef7c974f202f0493178da290b47c3c3b8e1c395cc7fc18becf92c5cd37c0fc5ba873e9d43d40ae674335835e028a8b44196a80e89ed57230b322ae140e761d29ec64390b8086aca6756aaa78b7c104b46df9c851b48f21eb06252ef5c424b2577a1ccc29d096eff91481a3ad473359fd4a69f3b384d311792852dc0e7505ce725120ee3ab32cd56db0c3281645a300b5e9ac201f59de1f3c908f372156302fc5db274ae1bda1f5e63c41c49b011d71b3c98d6d2b4b228f522df545d9819c45aa658d266f5784cb4f8916c232a2c1ae56e095946f39bb0133dc7de3b51e9a1b0053d6ca58e01f5fe47d715ce0693e674e0bc82d87c5b68d258fcae81817c6af8b195c6a26296e0f1584f329451599d81b1c32b155221c5993b2104b57ba8b686e79f37a4cca09f878e7fc8695a4eefcca58896a2cef3753f9c399682c14e5268b8a553c4af4634daf38986c300b228971acdd9b861a82ea6251cbfd78108ba7804a5ed4edd5c12b1b0cc53e88e896a569f7608fd6d2961c344d829cf27c9de4df41c2647127bc67a12232a6143f64f9a3ba33b2bfa256265f4a7f4c778f38295398b91b1494c4c8886a7f16993042c7e5e6955a1878ab66287f096324a47f5c7be59ff68fd8e3651b1ff0c16c0222bdf507972697b776bb7793b7ccbb3326ca6afcce47a9b469e8deeac96b606037d006b661e1d0dee5b17bd935467e415e895cb6e9fd92a1d157fcbfe5cd1785e52ecb9228359c28fb141cee458358a744e3dbec263ab3d7fdea7024b15dab688e70132ebe7ace5242d62fc1f2e0db0c0d9ab440f0cd01f5d3c6061dfdac51f478f6d2cc176852b14717d13608f3cb13ade985138a4df0149b16819d3937d7865045166173c7bf264d20586119dd268f5fecf081cdd0364eed27c80c19c0127767b5c258a3fb61f6a9aff0e1e8de181e9359be938cdbda6991f25750fac141fe819bfce99d65988f046063cd77c6def7d5ec74997fbd38db80a0d230a48a96b7b544bc15c4ff18539af68f11978ff5fc2e92ee04281c5fc26c567270c7afe2a11e77a43e2f3d72995424ee0f86f70bfc44d0c7e16c0f2fc277fe8e8c7b3b338ad0b67ece9b75d165560658315351cbe5d57e2399094a95e609211438e831efed8d2af620280dc55526e988bbeb504fc33fae56b3cf31cff5387a5e0881b98ac275ab262cd98b215c70239a59f2cd8bc273bfadb8080c9f9b5ca0fe79c760f57dd587e987e069094921421de2329d793fc8d8aa17fc204ac5c76cabedcbca47c3f260ebfce133fcb6f52f41630d6b97fe4308e78e40d3fdf5020527aadfb7a84bf136f920e2c765488ea213fae542428501cd76eb2eb512557570c0d6834e7358fa8d27f0efa3f005edef373575c81cfa01941412d2748605e19252662f9b1dab9fb13287010e2208f58bd63d8ca517e1bfacad6d641f4d69e6d5fb67cc1bb5fd3129bb977d290a831062d335dd1cebeed5a65552609a2967f015f03fd24349d13a6ed873385c0093265d17e1c9db7e8eed184c06acf42cbef1b4c3de68c8b8180fb5893d37547919da80ee04c1fce4b6a6969ba5160ee4f9648464e6b65cae5a74e1de3041fb7e419d04c1a3c72779e2d27317929053e354a572a552cc9dfa36265e0f76474b5003af758e4f08117274fa6b0da4cb7d801e507941e0c5e15e4582dda068af9e2206039151997481a2275fee905c5d61ab026f4dda19525333235c82b45e6c80bc5b7007e459605c8bd22cc1ae1d80dfd54c341d5eb26f0cb865b84be29ed72e6ada0023f1921c5b9ae43219c28ee9799605a5f34591786a5f6471c7d52613996759b8bc08db4fd40be93f4eea70e8fe583e138014bb3ce21dac656748b986cce47cae3fad3141601bcdd3258708ae1dc3ea9de6f1e03da05ebdcbc3e06127e86fe9a89a0affae31671aab4175c27d8d3db3ab6b5f2de91f872c7ef3ecb3eeb2bfcf42a8375748dc2d2f33ced98e357e09348d8e0402f808d76af26de2f1144cae19a9245a79c5f3e21d1883e1976ecd98c726115b3eb2404425789214f93b5258e94613a2424079afb27ea8704187de224c8b699d45c060f8fe03b66748f1b3d4f2ead99bf165caa3b807eb1644f095882fb8c6aede68d6b11c19244a58a10f7143e7eb726c3b87063a1bb5416d0294ecdf20873b1c5f448de72d9b785edffb85db58f72c88c2acf83c8883c4465bd90bceec149dfea7498c3e9d4c342f2e01b8dfa6ee53dc3945eff3485bc358d8e94710d892cea0129413275de13f120da1f9cd5a523b052cb104d1cdbb75bee1ad99eb8c66783c74cb992ff88459f746aef73c4ebd6d3ba7b26f19f9209a5c4c398aa4a9d1a5af090018853cf2d1fbfd35f95d47690050d3ea95de0a1722adcc305a3e6717f1cadae95e54cd468ab7c6f842d49315bc4af319bea3d6694ae680d2d816beaf369463d7a66cc8614c74511401f074123a6683b50210781dd9f039c43726d5d97b8dee13238e709473f0de81b1434bd1d5e72d190c06674fc70f671639f4693dfdfc2261e708cf7156346269591f455225d4e8ba72992ab36bebc895dd4fc9a25df20989defd077cd43b9a2f2eb1616e3969247c8ed4d917bf905a96c6054f717a2529ac8028164d23a4691ecfbd8a9e077299fa52bafd235a30ad7db1f6275fc9ac05b7d3dcb3c7eacb7f506130f1e4d7ddad487a0bcb3c1ad0718ec83e7a4e1bfead7621c52735aa898b7b3b87cb23d32bf457fb700265d203890a6a4bfcaaf24e7518c68c47a1d0c4318d2b42871a2b392668aea84b9b899bb036a93c06aa7e5ee15ca351b6052fc70851320e0bab6d1cd83cf555b1c2e2e1f776d50c90abae5c9f4a658057213c874479ab08d820472904e0a9dc3e2127564ee5a9ca12146d29f37547201c255b19011b62078d8d630e2cc49fd73baebf135947653a7c0a2d7e8e98cebaec2eafd2061fd2e8d80ce1e39f46767e3a634847d52efabda4d9b0a273abcf2f78f687f601a1c64d2412a3201ed4adc5bcc44da7805579f15463a9204eae5817b7cc028ae55f705e019f15053c70b1c559e7bbff5aa9af87eab39d1d2bfc9670ba3c058d416608015bea090c541108c49c977dcd7cd615edd507f2b87bb914ff41c9f8d578beb56d619fadfc65592b59c3f982f0815d393c3927b9826062ce8478e2a5f581014f900d5b50280f40988afeab9f3a5d16bc4bfb7eb421bec4d67ff1272532d1d32cba4d75cd3c24629614def036df249f148bf6b511bb21ed959b3117e11aff03ab496abb885db6c64deb0ac489cf957c93d00baeb99a49bbfc891783e5a6eee0b34ffa3fb7bbef7f3291fe254b8ccf43e9c434030850ae4b1850c4767863a0cc7c6d6a8dc1e786395b1bb043c23db8582e01502ceb5497f5d371c285286ce9753f95883170ea2dd60f3511f340cacc98849942f6de1afa7ee3e08924696e5751b410c55db5add3b22674a0aaf1a3cfd72c0ca5ef27d2045df3e02a162b075b617c0baaad9a7d2507136b155f57b63801f2255a3c14eda8a1563708130c2fe9b6faf7b97671c283d1d91d10d783df3245b979e29403cd03598c2db47badb72b7d590a5ce4fcf626a458535a5e687c96cd10ec92c9c9732839c0c182dc93c22f919ddbea689af67a116c27bc55de0eb2c6ae7fbd93b1907d9be1bbd938d26073a17383518f48549ee7dcb9044c37587d6fe8d9e9f6a18644e97dbaf3542290e93c9136253df59351509a70984cc4951e3bed5088ee6da5a7f18ba8b244afb5120b7aa686d1763f9d4d625a152fdb6056ef623526e52d6412db96966978d86230d434dc5da654057c685fc2ceb6e4a63b671ade5a3e60988815e4f585aadae310e1a3604968c7f95ba6092f881d12cbbb0d4b728775fb523d568fd1446ef72337dec1602c6ef540bf740ae502f63b1be96646708e4e2aa26e27ac899c54474164a2be7835a87e3330c51eeeae165ae15b6da157e9a02c7c2f1c65312cf6f954110c2d0ae35acb40b5a32b9e7abe2bb1ba6370b29a099e56a9d016199844844a638df4687bcad0244e10d95bad37ffb00ef5124de0d87f82c92bb571e7996cf69dcfa70eaa885d71b4523157b5a5d38832013a4eb7616ff15e5edcca4958e78087161f7d0cda7cbe332872128dd1f78c0e9d6cc7b659d5d7ca3a0382b57129e841aa55d7ed2e3dfb1307b0c290c2bbc34b5d306fe3703933ea01d5cbb6efbf3d1c2eccfd22f53e94330702779eb796a5b02af57f0eb312b65e0b5b2659a79d5b70ee64b41f4b26e5924d24f9fa32edcc9f6ed52e9c69e36b48f41f034b218900e93b38d82c790787c19b02e10fa1ba287a223a847781f2b83f6b884795bc2d72496edbd562904bd8f7c2fb1ce55a0d61ebe84d3710be600f04ff7b6331931b7a96ca4021547dc82af28c106d6e1ed934dd46730896e0cade79e0fdbeaa91fd30c70da520c4c56dbc045f8be0c33ccca5e897efee3183c071576ee64fec17b9f59f829fbb9ecf0ac614e2fc811f1f499ab0276719cda912acfe51d3f1f32cca6689e4cf9530a86b6be80b58ecfb02d4da28d70f3424caf28aa37e9ead103a7d2c0660ac027eac2709a2f5346f1f6ae12a3e0a225308e043e970d75da7cd23766bbab11ac5db697dff55ae538f7890899658465fba02a3378fd1fc0cbe835bb0e0da87fc80aa40b35b7245a2de51d6f0461f41c0cb1a29df0b20370d5dbf89888a14c4fc8a2054e8d87764e6c5eb3ae6ac1cc1363427b362cff67b95051c018305f21f06b9738f51e64ac5a2d9ad136dad611291902cb3e51f848edd0fb1ee1e0bc3613788cce2e9ecec5d4d4541670fc71acdc790b4a4fde34a56a739461540b24a177a0d70a5561dd2a7b0ce506da7a3e3f07254d115632f1eeaaee8efba72f32655a19123289263b5c8b3e5ff651b5dd007a1b7cbe7e2a8b5dd598302c2f242a32d9bd39db61ad1a8fdc1f829937b7d52c5e29d83f6e1ba13372bf1b56ccdabb85d239bce29af31c809c7b09ca6e032c205e939d1798bc374b41c8224aa1dc0e34d2f671f2855a646040c9bd8855c31c9e1ed95afcfc18b949eb571b2d781d4e59aa2e923fb472cf9bca083cd9a0d64a42574e7eb38fcec37ee2178b464f09004d609aaaeb99975ae1f472aca88b7d3dac0e7494f648029d4a5c9a9c6e8bd0079827eb386e0c65fb6d5331876d257e3f4435706a0f428940cf82f25b71629034c832f7b6cdc5f43841f5abc89a8a6c6fff62872d703919d6630312f75edec9ed571746908fe23722d69b7d2465d9dc37a1ae01be4f215081c1f0837c1fdb3a514c22ee813a59b4d1b1d98d9214773b3e58d6b2f98a445837a52dc2722ce279923a7ca0e2845df6d8b68ae6ec41d92117ab951305c19682d8302b6ba47ef6df467fda24bfa4f0efeee16fc676a95204e62b66dd984b9fdb65212b13e1c5e46735e6be5a66ae4a1afea9217fb695738b188148dd1f0f7806cb892abeba6c73f5e3f4bbcdac7619805a9beab360f3e3de300ce21bff88f80a34db7372fe83240d5dc590180cbe56ad52cfd7cbd45f70055ce6eef51b73fc2a570fb1ddca407f374c7129bd5ce7d3a9100ca816e204f4df179c588c32033a8681a1c4c90d8f244ecdf3f915694f3de0aae3af02762b8cc349ae05efd717ffec17f9072635b4455c45e900a0471610caa004914b3193b94ebef7f9f3d9884d5f9aa8ba0587aee2cbed17065cd036834080d8ea4fad52fd266b65a66f14c270a734e73b5e441ae8d08cecfa21629fb8fef6e9866e34cf6ed1a4607f86d128815e5d4bda6be0d73e6dd19ba8fb50bbd3479b21c0f54c2a4294e320f8a6a2fad6f5578cb8082ce1b21b5f1c33acc16a65d35437295e0accfb2283204fe3b82a5530655f69c51c04572abee7175987cd8cee3f6ae7fe6c2047f5604fa948b9433cde222e4ffca4296c3c1914c197c30cadafd34dc19bb91dac6937c6ace10951e52c6b6b629e9f5e905481a4d144c5bbf7e10be6c9271722ddb91fec8bcfce0f8c7ee88362c92f9215e94f926fc800e991576bc3f606ad4527c49854080836196d5057006dd26937e0c6a041d3b1a91c589698b2746ab040a27110e5d4760f5d91eff8dddf86ef74e8f67b0d017514cb3e4f02cf37fede5da831898387e172dd77052ba44b6245b3708f4e3f915ea8fb08591f0105eed4132e43f772da709413de2d038542949ba2237601654325a9fd44a42604b061dbf0afef6c7e1d1ac00c6bac4679b238c4f3f0cc08d7af6fc611790d31a558a392225ecdf89aec791b0426ccc4fbc1f8262032b51679cfa04fb60c221f0e67221ca0ebeb63d89be81bdb02beb5f994c32852836fa815c07f58ce5825d9c55115dd66dc8723da4272bb95f57c89e6a8fd1a1abd79caf7d6dd77694e0f19290492b011b7f3b437e1c1b947e566e5f966902161835ec779cf60a19a3d09de342299559c621642f1d991cc4e784184d5dd539007a4ed2ceb8b3909f394e5a86e675f9076a45228477f99be2ad8e9f77d3c4067afed8a2721ef3ac32c7fdcd0d944cc8e0711bc822f329695c01dc1ceb3b93bd67afdb0bb43597ade5aaca6b03ec8eb01a65a1c38ab68a85b83d1095d5065a5567f7b9c534ac9e58529bc49b859e7e0bc6d9c1a190d9a5fdd9b1dc863dd15a3cf0af46a037c299e87ab77ca168e0b66caf97231fa2ce037a6048fc3167759f2b7d33e03f2d8dbc572e3b20eea432d27e862341e5a9724b1b39ce30bd45a534fd592a59652e9df6e9fe8ef4fabe2993408b4c92b24130b43ae2b9cef1fe514684c3120b2be8c614810ebb45620af65d546324c17fd51168109f16e1c12a64575be9b68aa6f2cf246e9926a80499a01f011639c2b4bcf67430fdcd7c6da8e4cfb9b54a876d092f81ee0c3e9c07b85d4f2eb6247fbc0864ff412a8f92678240721b13be319a5b5b60dbd4782dbcf9431cfe3adc0b241938d083aa2fab00595c24eafa209de01412745be76b5d9e80b5a27dbca493d2ff0fea442fe22af4b015e163ac4a8e22cd8e69915a1186f17bd261984cffd32edf166a466f6aee5d74ffd5db680c24c2cf628856dbadeb9c9e10a8006886e3f1624e4adec49bd83d2b76ca2c6ea159464c5d93a97dbe20c92ea43d4e72a961b0533f81cc56c3c601cc7ff0de82c8bc15c2a7f406651845bdf9850d68c21262dbb2d5b4ef34c4368e69b09d66d04b764c1299ade590db6148cda3d817f39b43028d033cc8693e5f73c56c108f9546e0e96c3b62f6bbea89c3e461a0b4b12a7a834ad375dcfa3dcd46921e3af7aa3775a3434465973807438952ea14c1ef4c1f30df89d77d0c92d22ee818304b319e7b8740e179144f40d084bf9dc30c84f179f019471e8466d3616be4317f56a286921f2d8a9f13eb26e4d3327b8378aef663c109baa88ac429fa5dd58d246d8eb2a963f3593ff7dba732e37335a0e8d76fded2fbf3bf934d8b23eb3587de4feb6365119d2546f009816d3f07ff9d5f3d4f4800a372f2666f98e95d365ea0ef2c198e6790f135bec8f9e2788f7608fb03a67294c1202626ed063fc34987b10b940fdd7cd8be13488f371028b7a955278a78172dfc6826ef3648a58da2cccee4c90f38a3a592f898cb384d4ba8a41801205a371261937bbf660d65bd55f2e4430b97f0cd8d67ce6971711f57724cd52ac036661e2d338c68fe80ab3de452d458ef99cb079e17ad851e9f480f6cfa46196ca74cd098075735079882b52078c1d8e7cd42ca68627965b07a5bc5605d73fe8acd2da65777069e158a5f6202dfdceb2a29d48776979b4f79404a37a045f1c514017af0dafcd28c070680a75d9e803f1d946e25886ea80f9f3c9d5f551a1ee4b4c8e5cbbf4020d4e44c12d8bf3c3155728a766e5a70613af436d2d62a2f1bd6182a482bdf34fd559bf73d9c2203c64c76ec2b05853f12da01b9c8fb4241e0f6929923d5226419e2dbb4023dad6f05e3d570e48fd222cd7c4970ccd80e394a9df8b4d03d6d6256eb1734a291d4a0cea4f7f520bd4d924671294433f4e34757820c48b8e907cce51825f0e44e47399ea6314ab557c20fa95dc646f379a5c691e3945d462fc88cb39d0314b38d4d7e21c5f4064fe1b1cd1b9b1654e4794426121c76917d8b3f67d55f1cbafab703b9da8cfca5519b27e1a8668452961113911965c0be6ce9c08fa1a25e30bff9c7ed03356ce00c9009a2ac5993a2518a9af901d778beb2848d9ae240bd0fc4fd2bb76268c8622e3214511649f8ca3d21274ee9e399b754a1701ddbd5fa3c9227e988a8fe9e12395c1a6ad40941452eb9fbb2bfae89305937ee79371d23a87d4d8b5dd5ab6dffbd9a2474155d44ddb9cf67f2a6cf8374816bcca21264063a61e0dc7a809c787f13596e59da9df700679ef5b16534b1b024749e3208113b18a9c8c902736ccd57eb3c6557222390ffd428068b857588eafb366041cbc9d73db4ea871e5cff178333a0ca08e1036144028c466a480c040f92e2dcdc4f7a93a62ca246aa28dbf85083be8cb71271b674e1c452b473a33b570266ff44b4cd94c3bf7b725290f4432eedbe6b27992128078c521268dbae3d8266684c5af816e4d506c77ee577e11e3c964e2dfcf4bd7693c89c826d0a8bfbd5283f586a5c0e968d67e9c64fe15927d057c5f743784e72a3c06daffe6ba491152cdc521f0974d67ab6f406af6139b94c365334437c3d09b76da3f3ea26fa15e71242e0ecc9732296691a56a3e8c6a04eb9ab2cc99e1de528baf3d6a00e5da440293aeaaf4d59df1cc61933e27f0f407e7baa83385c58b71dd3a06951df1b2a6615db9ddc8e5b30b1de04cf86f2b228ded57154324c7470800a2faa9ef838b8add64498ffaab1dc87a618f4b225c63fa0bc0878abff509f8e9cc326266063f8f89d904157725fab896bda80f9d59270bdcf54206855f298fcba7851ca1fa3c8ea3616904ec0f8548fb369c3cbecece79cc4a629e95e127c877ee412e8e20c18de2e79902505c11c09d25403f3043d36f07fcabc09b23a2f74bf09288235434f193a843dfb012cdc3f9f90d933e96017cbda97017e0a004b3208a920f20f1701064008ffbd117d1efc72654699d77eb0e77c8a4581f70fce4bd7cba627349caf40cff80203f81f150421204de44af79eabe949df3082c4b61ff02fe768a413c7a25af56421714978f344d70a618514747efd11f21d2541842c2a9260e50476b653ebd41f4650241b012d1d8aa36ddf410ea540605f7300e192f8768e5ee84c628b35741872bfb9f04947467a264b903ce55df8254002a3f4cae90d75fbf313f2caf6915bda5b088badc3d7e777a13b8ae04a7f77fe9dd9b7af9d6ff00c2c922daa6e0c920ef4811ce0f20ac1afd885180bf81ab01c202c37d76dc9a6ccf40934cfe59a2fd1d9125d721334048e1254b3a3341ede813c58d97f4d08bd5e3e19c11f80704ec1642e2cd1902f9b4c1e80791d0a3d4c0e0ff97018bcb6091e54d992403c3468a697e6b145f2c2d5a7266fcb503f639ba69c38365f53519e6644122268bd151d6a205cd5ecaa523306bfbe95b5128d939030092f1578c8aa6a4e52d65654acc2f59ad580741df23a356ce4c25d0b69da155fc251075d0e0384ae7ac3387a206daaf80b4579e68e0f219f588c83a386475378f77e100cb66a4ec172d4bbef78ad192e0585e314e7e2396e62ed2e5def1201eb68289522303eda880a6eaacff51540e5bfb81e639d52208e14d74af382db1b4540b42ec3c03aedda4ff54332de21fb20393fb383a2988c184841dcdd90e5b67d9757f30e1f50eb261d0459e9cf94f6ac2acd71215751953c9ebc0797db5a76b4e63d1b12ba70bb95f90dc3909f0df4b1c8ac8278567da86505105b759188d0e7ab651eadffef3987035795964c2a7a1f0f8cc4bf1e99c89cc96d581cd64683cddacc7a850f24c13b55bdd9eb8bb5b266ca6107a271e368b78b66cb1c6f4f9ca5386d4b2c22171e6def028c95ba49dcac2813f4ec04454f3ca0bdb6ff4d92735c9845e54bd40340ae61cc59dc5c74d32b46e1f2f7eacb84e5f6b35ab16461bfc7ddf8e1243d49ec1319479bbfa64f35b582b86313da8bf81946c29ed9944955c2bffdd2dcfbe0b617754c03773e3bc6661932c7efbbe5a5670cfc406fc5ef10b90e257b72d7af83fd770f16a2fd69ccb56940a7397660212cdd976720dc3da206f0903e49fb116916409fd50c80fac3a7cd97e4155d6cfacf4c3a16cfd4d9f1d5eb973747ad8cbd2e5580d29006e629266ee5c8d6d4a81abc16b29187264ac723200e2fbc17eacd41ba4414f359392c2788736605be2c46c07f0e6d9b2b50d3cbd33c07c39981c3abdea64732a4ef3797224cf86f1093eee60f0ba091d94d31b73e239fd3907d3bc97114561c879e52df04d8100224638a786c1baafa47ea58528ec17a12331c6a2872787f54a01ff9b83a10fcfee010b7da735cbff584a178e096d6398008a288fe415da569553f283cfd311106a200130105c8b3f009ec71e980c277dcec31760f857c13cdcae96ca94d12956c40ac93b06777bf90dcd48d75f1cb3e0fccb987c6de47c5624733c7a22706774fe188bf1d13ff73617c970b94604633f5e7501553b41130019dc189f3478e989aec0675ce8e06f13506fe32a8d05c3a129d71172c64c6932a04bfcd13dd2722faa0a48d3e7b4f7aabed9f16d9f107186d349f71f56038a0f3017b0f9215d1dfe8edf7c9eb49f3563df515ba7060f12067deb49acb18b61fb5e80a9e74a2ff33d9573057c1656e85d474d4f26607de9b27d73795e997e96d8fa0c71369ca2a6d913b198f85d53b8b23a9beee78ac067fff20910998634a6d279e4fbc5a83509b66c61530ec4cf092e85c661064642cbb3a4e612d3f08d9542c4998f41b1c84434b47664d443787abbebcf914d63b691d12159914e1aa7d5965319e0d335650880e7d7f053fd0228e7f4df193dd3c9e7c58e882739c933c1e7d09929354453bcd6c4fd180239d1950cfce7a9a794b350551f91ee23bd2ea1e13a06dd3bcf98ffc99069624598b7a4b32182d736b2c36fd07234ee88273ba67000624b2e1a34e978366140037e300f891f5537ff1940e64ecfcb80d1b2f0da86a863d0e92788822675a2c4d5f3c9a480d8ea630761c20e6050474b2d36f0c943d0b67e7e7d0e85941d015e8d73e72cfe5291788ab9259c71ad0b7974172f68d35b39e9db8f52ccc04e1d4c0e0a6398eaace83f10acd7cfb1c0c34c3b342c163ecac83b8ccea133d32370f8b9e3c55f60768e605ab340f0f035d61c42010f8160b167bcf9d1009198592c82ccf9606c8edd81eee478a52deebc6c9518765bc1b4590fa3eccb6a3e68b2944489219accd3fba13b58b867de076d1e28503ddfe7df40468433bb6ffd7306b030ffae191a9f397643a94cae1ac8782e314018a0f4f46b859c322514755f382ba3f104be6015790680bd7957b93b5434a957291e7fef950b0a144a6895d764bd9701c2f3cc05229d6c70e845fba8da7ae591654728b6b2347e4b9ad176804d7df9fe36b1e4d79a300f611d39acbeb38e895afe67d00d6f9dac7fe8212da4d74c992231bf123920e796ea5c2c0dce8952e8c3ab728c24341932521366259a44834751d64ac5c33383f3d107953b4a3e39ccf6d5a660e495bce2bcb645b790a0c15f7ec171866e4cbbffce394dd372b3ac8657c74bcf4f7b294fdb9c22f8b11fff0dce76adb1533211352823c4554dd2786480864aa729cd2b4465b49fea33b14ef3247557d1c091500f0d7c5d3cbe9b558b18c31766cbaa4676135cd0e1dce726974c92eddb835d646b017b4bd02e9942358f36e3556388e6217fb970a22ccaaf9cae45f0ac65b612ec325b87084a2d4a24f9a75f8215d8633f4137b02a1c46154ae203bf63f217cb858992c645212ae193418ba9995bad479366968a8ef6d31be33715c89418f43adf106e795d4ecfc33e3135f99f0c641ad5d65916efe12f8492b814da5a368706d67d5caae322e81fa901b901ef2aee2e6bf5dabf92a4c3c3b2b201c7e9b8d8069fdbcc6973beecf3606b6f4b51b58e26967bebac73b3718a1482039c3e21b7dbb7ed83d642334044daaa99ad16b8b84bb69d6e45de0cfc7f34750239a06a42768a8e34027d3aa9c9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>习作</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能基础</title>
    <url>/2025/03/21/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#常用激活函数">常用激活函数</a>
<ul>
<li><a href="#sigmoid函数">Sigmoid函数</a></li>
<li><a href="#tanh函数">tanh函数</a></li>
<li><a href="#relu函数">ReLU函数</a></li>
<li><a href="#leaky-relu函数">Leaky ReLU函数</a></li>
<li><a href="#softmax函数">Softmax函数</a></li>
</ul></li>
<li><a href="#损失函数">损失函数</a>
<ul>
<li><a href="#least-square">Least Square</a></li>
<li><a href="#cross-entropy">Cross Entropy</a></li>
</ul></li>
<li><a href="#神经网络实现">神经网络实现</a>
<ul>
<li><a href="#梯度下降法">梯度下降法</a></li>
<li><a href="#误差反向传播">误差反向传播</a></li>
</ul></li>
<li><a href="#卷积神经网络cnn">卷积神经网络(CNN)</a>
<ul>
<li><a href="#感受野计算">感受野计算</a></li>
<li><a href="#池化pooling">池化(Pooling)</a></li>
<li><a href="#常见卷积架构">常见卷积架构</a>
<ul>
<li><a href="#alexnet">AlexNet</a></li>
<li><a href="#vgg">VGG</a></li>
<li><a href="#resnet">ResNet</a></li>
<li><a href="#squeezenet">SqueezeNet</a></li>
<li><a href="#mobilenet">MobileNet</a></li>
<li><a href="#shufflenet">ShuffleNet</a></li>
<li><a href="#反卷积">反卷积</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="常用激活函数">常用激活函数</span></h3>
<h4><span id="sigmoid函数">Sigmoid函数</span></h4>
<p><span class="math inline">\(f(x)=\frac{1}{1+e^{-x}}:(-\infty,+\infty)\to(0,1)\)</span>.</p>
<p><span class="math inline">\(f&#39;(x)=f(x)(1-f(x))\)</span>.</p>
<h4><span id="tanh函数">tanh函数</span></h4>
<p><span class="math inline">\(f(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}:(-\infty,+\infty)\to(-1,1)\)</span>.</p>
<p><span class="math inline">\(f&#39;(x)=1-f^2(x)\)</span>.</p>
<h4><span id="relu函数">ReLU函数</span></h4>
<p><span class="math inline">\(f(x)=\max(0,x):(-\infty,+\infty)\to(0,+\infty)\)</span>.</p>
<h4><span id="leaky-relu函数">Leaky ReLU函数</span></h4>
<p><span class="math inline">\(f(x)=\max(\alpha
x,x),0&lt;\alpha&lt;1:(-\infty,+\infty)\to(-\infty,+\infty)\)</span>.</p>
<h4><span id="softmax函数">Softmax函数</span></h4>
<p><span class="math inline">\(f(x_i)=\frac{e^{x_i}}{\sum_j
e^{x_j}}\)</span>.</p>
<h3><span id="损失函数">损失函数</span></h3>
<h4><span id="least-square">Least Square</span></h4>
<p>即<span class="math inline">\(\arg \min
\sum_{i=1}^n(f(x_i)-y_i)^2=\arg \min(A\beta-Y\mid
A\beta-Y)\)</span>.用最小二乘法取<span class="math inline">\(\hat
\beta=(A^TA)^{-1}A^TY\)</span>.</p>
<h4><span id="cross-entropy">Cross Entropy</span></h4>
<p>用错误的分布<span class="math inline">\(q\)</span>来表示真实分布<span class="math inline">\(p\)</span>的样本,则平均编码长度应该是: <span class="math display">\[
H(p,q)=\sum_i p(i)\log(\frac{1}{q(i)})=-\sum_i p(i)\log{q(i)}
\]</span> 此为交叉熵.</p>
<p>特别地,当最终样本只有两个的时候,例如Logistical
Regression问题,可以写成: <span class="math display">\[
H=-(y\log a+(1-y)\log(1-a))\\
\frac{\partial H}{\partial a}=-(\frac{y}{a}-\frac{1-y}{1-a})
\]</span></p>
<p>那如果有多个呢?考虑直接对归一化条件作偏导,先有: <span class="math display">\[
H(p,q)=-\sum_i p_i(\log{q_i}-\log(\sum_j q_j))\\
\frac{\partial H(p,q)}{\partial q_k}=-\frac{p_k}{q_k}+\frac{\sum
p_k}{\sum_j q_j}\\
=-\frac{p_k}{q_k}+1
\]</span> 再乘以softmax那里的<span class="math inline">\(q_k\)</span>,得到<span class="math inline">\(-p_k+q_k\)</span>.</p>
<h3><span id="神经网络实现">神经网络实现</span></h3>
<p>通过若干隐藏层,假设最后的输出层为第<span class="math inline">\(L\)</span>层,则:</p>
<ol type="1">
<li>对于第<span class="math inline">\(l\)</span>层,取<span class="math inline">\(\vec z_l=(W_l)^t \vec a_{l-1}+\vec
b_l\)</span>.这里对<span class="math inline">\(W_l\)</span>作转置的目的是写代码的时候需要用行向量.</li>
<li>对于第<span class="math inline">\(l\)</span>层,取<span class="math inline">\(\vec a_l=f(\vec
z_l)\)</span>,这里意味着将每一个分量对<span class="math inline">\(f\)</span>操作.</li>
<li>对于最终答案,取误差<span class="math inline">\(\mathcal
L=\frac{1}{m}(\vec y-\vec a_L\mid \vec y-\vec a_L)\)</span>.</li>
</ol>
<h4><span id="梯度下降法">梯度下降法</span></h4>
<p>换言之就是让<span class="math inline">\(w:=w-\alpha\frac{\partial
\mathcal{L}}{\partial w}\)</span>,其中<span class="math inline">\(\alpha\)</span>是一个选定的小常数,也可以采用类似模拟退火的方式动态决定.事实上可以把各个位置分开,写作<span class="math inline">\(w_j:=w_j-\alpha
\frac{\partial\mathcal{L}}{\partial w_j}\)</span>.</p>
<p>另外,虽然是这么写,应当见到去掉下标<span class="math inline">\(k\)</span>的记号仍然合理,无非是逐分量做此操作,因此下面如无特殊说明,运算均采用逐分量运算.例如可以定义<span class="math inline">\(\vec a\circ \vec
b\)</span>为两个向量逐分量相乘后得到的新向量,为表区分用<span class="math inline">\(\times\)</span>表示正常的矩阵乘法.甚至采取<span class="math inline">\((\vec a-\vec
y)^2\)</span>表示其自点积.坦白而言,笔者对此符号相当无奈,可也想不出什么更好的写法了.但总之这种写法总是强于部分参考资料上所将下标放上面的写作<span class="math inline">\(a^L\)</span>的做法.笔者所能维持的精神数院人的唯一做法也只能是在下面加上向量符号,藉此泄愤.</p>
<p>顺便一提,应当见到<span class="math inline">\(\times\)</span>和<span class="math inline">\(\circ\)</span>这两种运算比较随意,用线性映射来理解,你这个$W$任意作用在一个向量上就行.</p>
<h4><span id="误差反向传播">误差反向传播</span></h4>
<p>既然要用梯度下降法,就应该把每一层的偏导都求出来.然而<span class="math inline">\(\mathcal
L\)</span>是最后一层的结果,因此应该用链式法则一路求出前面的偏导.</p>
<p>更具体地,不妨设误差函数选的是<span class="math inline">\((\vec a-\vec
y)^2\)</span>,激活函数选的是cross entropy有:</p>
<ol type="1">
<li><span class="math inline">\(\frac{\partial{\mathcal L}}{\partial
\vec a_{L}}=(\vec a_{L}-\vec
y)\)</span>.(如若选择不同的误差函数,这里作适当变化)</li>
<li><span class="math inline">\(\frac{\partial \vec a_{l}}{\partial \vec
z_{l}}=f&#39;( \vec z_{l})=\vec a_{l}\circ (1-\vec
a_{l})\)</span>.(如若选取不同的激活函数,这里作适当变化)</li>
<li><span class="math inline">\(\frac{\partial \vec z_{l+1}}{\partial
\vec z_{l}}=\frac{\partial \vec z_{l+1}}{\partial \vec
a_{l}}\frac{\partial \vec a_{l}}{\partial \vec z_{l}}=(
W_{l+1})^t\times(\vec a_l\circ (1-\vec a_l))\)</span>.</li>
<li><span class="math inline">\(\frac{\partial \vec z_{l}}{\partial
W_{l}}=(\vec
a_{l-1})\)</span>.结果理应是一个矩阵,其实就是这个列向量不断复制若干遍,或者写成<span class="math inline">\((\vec a_{l-1})^tM(1)\)</span>,其中<span class="math inline">\(M(1)\)</span>是全<span class="math inline">\(1\)</span>矩阵.</li>
<li><span class="math inline">\(\frac{\partial \vec z_{l}}{\partial \vec
b_{l}}=1\)</span>.</li>
</ol>
<p>我们应当见到:</p>
<p>不妨设<span class="math inline">\(\delta_l=\frac{\partial {\mathcal
L}}{\partial \vec z_l}\)</span>.见到:</p>
<ol type="1">
<li><span class="math inline">\(\delta_L=\frac{\partial\mathcal
L}{\partial \vec z_L}=\frac{\partial\mathcal L}{\partial \vec
a_L}\frac{\partial\vec a_L}{\partial \vec z_L}=(\vec a_{L}-\vec y)\circ
\vec a_{L}\circ (1-\vec
a_{L})\)</span>.前者会因为误差函数的选取而改变,后者会因为激活函数的选取而改变.</li>
<li><span class="math inline">\(\delta_l=\frac{\partial {\mathcal
L}}{\partial \vec z_l}=\delta_{l+1}\frac{\partial \vec z_{l+1}}{\partial
\vec z_l}=\delta_{l+1}\circ  (W_{l+1})^t\times (\vec a_{l}\circ (1-\vec
a_{l}))\)</span>.</li>
<li><span class="math inline">\(\frac{\partial \mathcal L}{\partial
W_{l}}=\frac{\partial \mathcal L}{\partial \vec z_{l}}\frac{\partial
\vec z_l}{\partial W_{l}}=\delta_l\times a_{l-1}^t\)</span>.</li>
<li><span class="math inline">\(\frac{\partial \mathcal L}{\partial \vec
b_l}=\delta_l\)</span>.</li>
</ol>
<p>如此以上更新即可.</p>
<h3><span id="卷积神经网络cnn">卷积神经网络(CNN)</span></h3>
<p>神经网络受矩阵乘法的限制,导致对于真实的尺寸巨大的图像难以快速识别,因此产生了卷积神经网络的概念,大概有以下特征:</p>
<ol type="1">
<li>空间上权值共享:不同位置使用同一个卷积核(滤波器)</li>
<li>稀疏链接:每一层只链接前一层的感受野.</li>
<li>等变表示:卷积神经网络有某种平移不变性.</li>
</ol>
<p>对于2D卷积,其公式如下: <span class="math display">\[
S_{r,c}=(X*W)_{r,c}=\sum_i\sum_j X_{r+i,c+j}\times w_{i,j}
\]</span> 其中<span class="math inline">\(W\)</span>是卷积核,<span class="math inline">\(X\)</span>是输入图像,<span class="math inline">\(S\)</span>是输出的结果.如果一个图像有多个通道(比如色彩层之类的),每个通道上都需要应用一个卷积核.</p>
<p>下面引入一些名词:</p>
<ol type="1">
<li>input size:输入图像的尺寸.</li>
<li>padding:填充的像素数.</li>
<li>filter size:卷积核的尺寸.有时也写作两个变量:filter height和filter
width.3D卷积还会有一个filter depth的变量.</li>
<li>stride:步长.</li>
<li>output size:卷积后输出的尺寸.有时也写作feature size.</li>
<li>input channels:输入图像的通道数.</li>
<li>n filters:卷积核的数量.</li>
<li>dilation rate:膨胀率,用于空洞卷积.膨胀率为<span class="math inline">\(d\)</span>的时候,卷积核中间会插入<span class="math inline">\(d-1\)</span>个<span class="math inline">\(0\)</span>间隔.</li>
</ol>
<h4><span id="感受野计算">感受野计算</span></h4>
<p>先看output
size的计算,容易见到,其各个维度方面计算是独立的.只要对于单个维度算出卷积核在上面移动的次数,最后将不同维度相乘即可.</p>
<p>对于单个维度,这个维度的移动次数应该是: <span class="math display">\[
\text{output\_size}=\lceil\frac{\text{input\_size}+2\times
\text{padding}-\text{filter\_size}+1}{\text{stride}}\rceil\\
=\lfloor\frac{\text{input\_size}+2\times
\text{padding}-\text{filter\_size}}{\text{stride}}\rfloor+1\\
\]</span> 这个公式相当容易理解,原因是<span class="math inline">\(\text{stride}=1\)</span>的时候,上面恰好是移动的次数,而<span class="math inline">\(\text{stride}\)</span>变化的时候,当然要拿到一个上取整.</p>
<p>至于所谓的空洞卷积,只需在上面的基础上改<span class="math inline">\(\text{filter\_size}\)</span>就好.</p>
<p>至于乘法操作,每得到一个<span class="math inline">\(\text{output}\)</span>当然都会需要<span class="math inline">\(\text{filter\_size}\)</span>次乘法操作.</p>
<h4><span id="池化pooling">池化(Pooling)</span></h4>
<p>池化操作它没有一个可学习的参数,只是对输入数据进行固定的操作.简单来说就是降低输入的规模,以实现更好的鲁棒性以及提高效率.</p>
<p>常见的池化操作包括:</p>
<ol type="1">
<li>MaxPooling:取区域内的最大值.</li>
<li>MeanPooling:取区域内的平均值.</li>
<li>PyramidPooling:多次进行尺度不同的池化.</li>
</ol>
<h4><span id="常见卷积架构">常见卷积架构</span></h4>
<h5><span id="alexnet">AlexNet</span></h5>
<p>首次引入ReLU激活函数,Dropout
技术,以及数据增强,提高了模型的训练效率和泛化能力.</p>
<p>采用了<span class="math inline">\(8\)</span>层深的网络结构,证明了深度网络的潜力.</p>
<h5><span id="vgg">VGG</span></h5>
<p>开始堆叠小尺寸的卷积核,获得与大卷积核相似的感受野的同时可以增加网络深度.</p>
<h5><span id="resnet">ResNet</span></h5>
<p>引入残差的概念,直接将输入数据累加(跳跃连接)到最后的输出中,这样网络学习的实际上是输入和输出之间的残差,从而提高了网络学习能力.</p>
<h5><span id="squeezenet">SqueezeNet</span></h5>
<p>SqueezeNet的基本构建单元是Fire模块.Fire模块由一个squeeze层和一个expand层组成.squeeze层使用<span class="math inline">\(1\times1\)</span>卷积核减少通道数,而expand层则使用<span class="math inline">\(1\times 1\)</span>和<span class="math inline">\(3\times
3\)</span>卷积核增加通道数.这种设计有效地减少了参数数量和计算量.</p>
<h5><span id="mobilenet">MobileNet</span></h5>
<ol type="1">
<li>深度卷积:在这个操作中,每个输入通道独立地进行卷积,这意味着在进行卷积时,不同通道之间没有交互.这样可以减少计算量和参数数量.</li>
<li>逐点卷积:逐点卷积使用<span class="math inline">\(1\times
1\)</span>的卷积核,它作用在深度卷积的输出上,将不同通道的信息整合在一起.逐点卷积可以减少参数数量,同时保持较高的性能.</li>
</ol>
<h5><span id="shufflenet">ShuffleNet</span></h5>
<ol type="1">
<li>组卷积(Group
Convolution):将通道分成几个组,并使用不同的卷积神经网络层执行标准卷积.</li>
<li>打乱层(Shuffle layer):通过对通道进行洗牌,将不同组的信息合并.</li>
</ol>
<h5><span id="反卷积">反卷积</span></h5>
<p>也就是将较小的数据特征图扩大到较大的尺寸.有的时候也把这个操作说成上采样.</p>
<ol type="1">
<li>插值步骤(Interpolation
Step):首先,在输入特征图的元素之间插入零,增加特征图的尺寸.</li>
<li>卷积步骤(Convolution
Step):接下来,对扩大后的特征图应用一个标准的卷积操作.此步骤相当于在扩大的特征图上滑动卷积核,计算卷积输出.</li>
</ol>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中的线性代数</title>
    <url>/2025/02/18/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#oi中的线性代数">OI中的线性代数</a>
<ul>
<li><a href="#线性基">线性基</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan
and Burgers)</a></li>
<li><a href="#example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337
[Ynoi2004] rsxc)</a></li>
<li><a href="#example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</a></li>
</ul></li>
<li><a href="#杂题">杂题</a>
<ul>
<li><a href="#example1cf1270ixor-on-figures">Example1([CF1270I]Xor on
Figures)</a></li>
<li><a href="#example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing
Finals)</a></li>
</ul></li>
<li><a href="#逆矩阵求解线性方程组">逆矩阵求解线性方程组</a>
<ul>
<li><a href="#example1codeforces-cf1266h-red-blue-graph">Example1(codeforces
CF1266H Red-Blue Graph)</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="oi中的线性代数">OI中的线性代数</span></h3>
<h4><span id="线性基">线性基</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定<span class="math inline">\(n\)</span>个非平方因子数<span class="math inline">\(a_i\)</span>,求有多少种选取一个子集的方式满足每个质因子都在子集中恰好出现偶数次.<span class="math inline">\(n\leq 2\times 10^5,a_i\leq 10^6\)</span>.</p>
<p>考虑将每个数的质因子压成一个二进制数,那所求也就是问有多少种选取子集的方式使得子集内二进制数异或和为<span class="math inline">\(0\)</span>.自然想到线性基.<span class="math inline">\(2\)</span>的自由变量的数量次幂即答案.</p>
<p>但是直接做线性基不太对,因为质数级别是<span class="math inline">\(10^6\)</span>.我们冷静一下,把一个数中大于<span class="math inline">\(1000\)</span>的质因子拿出来,显然只会有一个.把所有数字根据这个质因子分类,那么显然一个组内必能插入一个数(作为这个质因子的主元),而其他数也必要异或上这个数,而异或后就只有小于等于<span class="math inline">\(1000\)</span>的质因子了,这种质因子只有不到<span class="math inline">\(200\)</span>个,可以拿bitset优化一下.</p>
<p>复杂度<span class="math inline">\(O(\cfrac{\pi(\sqrt
a)^2n}{w})\)</span>.</p>
<h5><span id="example2cf1100fivan-andburgers">Example2([CF1100F]Ivan and
Burgers)</span></h5>
<p>考虑扫描线,这样我们需要解决如何询问一段后缀<span class="math inline">\([l,n]\)</span>的答案,以及如何根据上一个位置的后缀推出这一个位置的后缀.</p>
<p>考虑有一个暴力是直接把每个后缀的线性基建出来:注意在此过程中,能放到高位的数字一定出现地尽可能靠后,因为它一早就被放进来了.而只要满足这个条件,也就是能放高位的一定尽量放高位,并且高位出现时间要尽可能晚,那我们自然就得到了此时的线性基,删去那些出现太靠前的数字就行.</p>
<p>但有没有什么直接一点的理解方式呢?一个直觉是,我们现在要把出现时间太早的给删了,那肯定想要让高位出现时间尽可能晚.但是这样会有两个问题:</p>
<ol type="1">
<li>可能<span class="math inline">\(l\)</span>较小但是没那么小,高位即使不顶替,也会被选上,但是顶替了高位就无法顶替一个将被删除的低位.</li>
<li>由于线性基并非最简线性基,我们最后的答案有可能不会将某一位异或进答案,那此时尽量最优化它是不优秀的.</li>
<li>线性基中的元素不能受到非线性基中的元素的影响,我们删除一位的时候,这一位有可能在之前影响了比它低的一些位置.</li>
</ol>
<p>来一个一个解决.</p>
<p>(3)是最好解决的.对于因为出现时间太早而导致的删除来说,因为如果一个位置被高位影响了,根据我们的构造过程,这个位置出现时间必然不会晚于那个高位,高位都被删了,那这个位置也会被删.</p>
<p>对于因为被其他人而取代导致的删除来说,因为它被删了,因此它一定可以表示为其它线性基底的异或,因此有影响也无所谓.</p>
<p>再来看(1),考虑我们当前插入的数字是<span class="math inline">\(v\)</span>,如果<span class="math inline">\(v\)</span>本来就会被加入线性基,那它扔到高位,然后替换下来的那个数字也不可能被删除,一定会延续到低位.如果<span class="math inline">\(v\)</span>本来不会被加入,必然因为有一些基底的异或值是<span class="math inline">\(v\)</span>,那么把<span class="math inline">\(v\)</span>加入后,一路到最后,被删除的那个基底必然是出现时间最早的那个菜逼,删了就是了.</p>
<p>接下来是(2),考虑上面这个过程完全不耽误你把它变成最简线性基,最简线性基就没这个问题了.</p>
<p>当然这题还可以分治,注意到用线段树直接合并区间的线性基的复杂度达到了<span class="math inline">\(\log^3\)</span>,但是如果我们用猫树的结构但是不必要在线,复杂度降到了<span class="math inline">\(\log^2\)</span>.</p>
<h5><span id="example3luogup8337-ynoi2004rsxc">Example3(luoguP8337 [Ynoi2004]
rsxc)</span></h5>
<p>注意到区间数字种类个数一定是二的整数次幂,假设为<span class="math inline">\(2^k\)</span>,先枚举<span class="math inline">\(k\)</span>.</p>
<p>首先根据CF1100F,我们可以离线找出区间的线性基,这意味着区间不同整数个数是否是<span class="math inline">\(2^k\)</span>.</p>
<p>做完这两步之后呢?我们接下来需要求和.这里注意到随着扫描线的进行,左端点可能合法的区间左右端点均单调不降,我们对着二维坐标系做一个差分(就是把一条直线延伸到<span class="math inline">\(y=x\)</span>这条直线上),于是可以<span class="math inline">\(O(1)\)</span>求和.</p>
<p>这里详细解释一下上面的那个套路:当我们插入一个数字的时候,每当遇到了一个此位置是<span class="math inline">\(1\)</span>的出现次数早于该数字的数字,我们就交换它们.为啥这样是对的呢?首先如果插入的这个数字并不能被其他数字所表示,那无论怎么交换都不会有影响.而如果可以,那一定会与所有参与表示的数字都交换一次.注意到每次交换等价于找到两者中出现较早的那个,所以最后一定会删去出现最早的数字.</p>
<h5><span id="example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</span></h5>
<p>用一下构造能力不难发现,每个点的取值是它前面的数能表示出的所有数(也就是线性基)异或上他自己.</p>
<p>我们考虑从左往右加线性基(并保存旧的版本),每次如果一个数并不能更新线性基,说明这个数字能取的取值范围就是到它的线性基中的所有数字.进一步地,你注意到它的取值范围一定包括了它前面的所有数字,这个同样可以通过线性基的性质来得到.</p>
<p>注意到难点在于那些加入后更新线性基的点,称它们为关键点,这样的关键点最多<span class="math inline">\(\log
V\)</span>个.所以我们可以暴力讨论它们的存在.而那些普通的点显然分成了若干个段,每段的取值是相等的.我们可以按照线性基的顺序走.如果我们必须要在关键点和其它的点中挑一个删了,显然我们要删关键点,因为其他的点能很完美地接上,但是关键点可不一定能接上.</p>
<p>也就是说对于一个非关键点,能选则一定要选.因此我们直接从后往前dp,如果遇到关键点的话讨论一下它选不选,遇到非关键点一定要选,如果选不了就更新答案.</p>
<p>我们不妨设计一个dp,设<span class="math inline">\(f_{i,j}\)</span>表示从<span class="math inline">\(n\)</span>走到第<span class="math inline">\(i\)</span>个数字,中间取了<span class="math inline">\(j\)</span>个关键点,<span class="math inline">\(a_i\)</span>的最大值是多少.这样问题转化为:</p>
<ol type="1">
<li>对于一个数字<span class="math inline">\(X\)</span>,找到线性基中最大的小于它的数字.</li>
<li>对于一个数字<span class="math inline">\(X\)</span>,将它与线性基中若干基底异或得到<span class="math inline">\(X&#39;\)</span>,使得<span class="math inline">\(X&#39;&lt;Y\)</span>并且<span class="math inline">\(X&#39;\)</span>尽可能大.</li>
</ol>
<p>不难发现第一个问题就是第二个问题中的<span class="math inline">\(X=0,Y=X\)</span>的情况.用最简线性基算排名可以轻松解决上面的问题.</p>
<h4><span id="杂题">杂题</span></h4>
<h5><span id="example1cf1270ixor-onfigures">Example1([CF1270I]Xor on
Figures)</span></h5>
<p>首先我们发现,它的平移操作和矩阵很相似,我们考虑将操作写成矩阵形式.</p>
<p>具体地,我们定义新的矩阵乘法为:<span class="math inline">\(A\times
B=C\)</span>,其中<span class="math inline">\(C_{x,y}=\bigoplus_{i=0}^{2^k-1}\bigoplus_{j=0}^{2^k-1}A_{i,j}\times
B_{(x-i)\mod 2^k,(y-j)\mod 2^k}\)</span>.</p>
<p>定义矩阵<span class="math inline">\(F\)</span>:<span class="math inline">\(F_{x_i,y_i}=1,1\leq i\leq
t\)</span>,其他位置均为<span class="math inline">\(0\)</span>.不难发现每次操作无非是将<span class="math inline">\(F\)</span>乘上一个只有<span class="math inline">\((X,Y)\)</span>位置是<span class="math inline">\(w\)</span>,其余位置都是<span class="math inline">\(0\)</span>的矩阵然后异或到<span class="math inline">\(A\)</span>上.我们发现这些操作也可以压缩成一个矩阵.这样问题就转化为:我们已知<span class="math inline">\(F\)</span>,求<span class="math inline">\(0\)</span>的位置尽可能多的矩阵<span class="math inline">\(C\)</span>,满足<span class="math inline">\(F\times
C=A\)</span>.</p>
<p>我们看到这个形式,发现它很优美,这个时候自然有一个猜想:<span class="math inline">\(F\)</span>在这种形式下是否存在逆矩阵呢?</p>
<p>注意到<span class="math inline">\(F\)</span>的值是异或运算下,和取膜有一定关系,我们再大胆猜测:<span class="math inline">\(\exists m,F^m=I\)</span>,其中<span class="math inline">\(I_{0,0}=1\)</span>,其他位置都是<span class="math inline">\(0\)</span>.此时<span class="math inline">\(F^{-1}=F^{m-1}\)</span>.打表可以发现<span class="math inline">\(m=2^k\)</span>.</p>
<p>接下来我们只需要证明这个结论就行.其实也好证:注意到进行一次运算后,<span class="math inline">\(F_{x_i,y_i}\times F_{x_j,y_j}\)</span>和<span class="math inline">\(F_{x_j,y_j}\times
F_{x_i,y_i}\)</span>都会更新到<span class="math inline">\(F^2_{x_i+x_j,y_i+y_j}\)</span>,因此他们俩互相抵消.这意味着<span class="math inline">\(F^2\)</span>中,只有<span class="math inline">\(F^2_{2x_i,2y_i}\)</span>有可能非零.</p>
<p>进行<span class="math inline">\(2^k\)</span>后,由于下标对<span class="math inline">\(2^k\)</span>取膜,容易发现这个时候只有<span class="math inline">\((0,0)\)</span>有可能非零.而由于一共有奇数个<span class="math inline">\(1\)</span>,所以这里一定是<span class="math inline">\(1\)</span>.得证.有<span class="math inline">\(C=F^{2^k-1}A\)</span>.</p>
<p>根据上面的证明过程不难发现,<span class="math inline">\(F\)</span>的<span class="math inline">\(2\)</span>的整次幂很好求,所以我们拆开幂,有<span class="math inline">\(C=\prod_{i=0}^{k-1}F^{2^i}A\)</span>.注意到<span class="math inline">\(F\)</span>很稀疏,最多只有<span class="math inline">\(t\)</span>个地方非零,所以做一次的复杂度是<span class="math inline">\(O((2^k)^2t)\)</span>,总复杂度<span class="math inline">\(O(kt4^k)\)</span>.</p>
<h5><span id="example2petrozavodskwinter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassingfinals">Example2([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing
Finals)</span></h5>
<p>给定一个<span class="math inline">\(n\times
n\)</span>的矩阵,其中有<span class="math inline">\(m\)</span>个位置(<span class="math inline">\(m\leq
5\)</span>)的数字缺失了.给定质数<span class="math inline">\(P\)</span>,现在要在这<span class="math inline">\(m\)</span>个位置上填上<span class="math inline">\([0,p-1]\)</span>的数字,使得最后矩阵的行列式在<span class="math inline">\(\bmod p\)</span>意义下等于给定数字<span class="math inline">\(C\)</span>,求任意一组方案,<span class="math inline">\(1\leq n\leq 100\)</span>,<span class="math inline">\(2\leq P\leq 10^9\)</span>.</p>
<p>如果<span class="math inline">\(m=1\)</span>,做代数余子式展开,显然如果这个位置对应的代数余子式为<span class="math inline">\(0\)</span>,那它填什么无所谓,随便填一个然后验证.不然,我们一定可以用逆元算出一个答案,使得满足条件.</p>
<p>同理,如果<span class="math inline">\(m&gt;1\)</span>,我们考虑随机<span class="math inline">\(m-1\)</span>个位置并随机它们的值,然后验证.如果我们能找到一组随机满足剩下的那个位置对应的代数余子式非零就做完了.如果我们随机了若干次,还是没有找到,宣告无解.</p>
<h4><span id="逆矩阵求解线性方程组">逆矩阵求解线性方程组</span></h4>
<p>如果我们已知线性方程组的系数矩阵,但是多次询问,每次会给出不同的常数项,我们可以使用下文中提到的逆矩阵来求解.</p>
<h5><span id="example1codeforcescf1266h-red-blue-graph">Example1(codeforces
CF1266H Red-Blue Graph)</span></h5>
<p>如果我们设<span class="math inline">\(x_i\)</span>表示每个点被经历过多少次.注意到一共有<span class="math inline">\(n-1\)</span>个方程以及<span class="math inline">\(n-1\)</span>个未知数,我们实际上是要根据<span class="math inline">\(s\)</span>和<span class="math inline">\(v\)</span>求出一组<span class="math inline">\(x\)</span>然后判定合法,我们先写方程: <span class="math display">\[
x_i-[i=1]\\=\sum_{e:j\rightarrow i \ is\
blue}\frac{x_j-[s_e=red]-[j=v]}{2}\\+\sum_{e:j\rightarrow i \ is\
red}\frac{x_j+[s_e=red]-[j=v]}{2}
\]</span> 化简一下: <span class="math display">\[
2x_i-\sum_{j\rightarrow i}x_j=-\sum_{e:j\rightarrow i \ is\
blue}[s_e=red]+\sum_{e:j\rightarrow i \ is\
red}[s_e=red]-\sum_{j\rightarrow i}[j=v]+2[i=1]
\]</span>
注意到这是一个系数恒定且常数项不确定的矩阵,可以先矩阵求逆再做.</p>
<p>另外有一个问题是,怎么证明这个系数矩阵一定存在逆矩阵,不难注意到这是个基尔霍夫矩阵,显然$$为<span class="math inline">\(0\)</span>.</p>
<p>这也就是说,我们一定可以求出唯一一组解.我们要做的只是判定它是否合法.</p>
<p>先通过数学归纳等方法证明一组满足流量平衡以及以下条件的<span class="math inline">\(x,s,v\)</span>一定合法:</p>
<p>对于任意一个点,都存在一条只经过激活边的路径到达最终点.</p>
<p>首先充分性,如果满足这个条件,我们只要不断地退流就可以得到一组一定合法的答案.</p>
<p>然后必要性,如果存在一个点没有这条路径,那这个点也必然不可能被回溯到,自然不可能出现一组解.</p>
<p>这题关键在于发现流量平衡这个等价条件,然后知道我们可以求出一组状态,并只需要判定状态是否合法,找判定条件.</p>
<p>然后写分数的人被卡常了,泪目.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>英美戏剧与电影大作业</title>
    <url>/2025/01/25/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#the-bright-morning-stara-sequel-to-a-streetcar-named-desire">The
Bright Morning Star(A Sequel to <em>A Streetcar Named
Desire</em>)</a></li>
<li><a href="#summary">SUMMARY</a></li>
<li><a href="#theme">THEME</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="thebright-morning-stara-sequel-to-a-streetcar-named-desire">The
Bright Morning Star(A Sequel to <em>A Streetcar Named Desire</em>)</span></h3>
<p>MATRON: This is her room. [<em>She knocks on the door.</em>] Miss
DuBois, here is someone who wants to visit you.</p>
<p>MITCH [<em>overwrought</em>]: Thank you. Has anyone visited her
before? And has she recovered?</p>
<p>MATRON: No, no. Although she has recovered a lot, sometimes she’ll
crouch over and tremble in corners as if someone will hurt her, and
she’ll try to hit anyone who wants to touch her when she’s insane.
[<em>She pushes the door open and lets Mitch in. The room where Blanche
lives now is a pure white space without windows, and a naked bulb
brightens the whole room as if it were daylight. There is a collapsible
bed in the corner of the room and a Bible on the table. Blanche sits on
a chair in a blue dress and stares at Mitch, which makes Mitch feel a
little guilty. Then the Matron goes out and leaves Mitch in the
room.</em>]</p>
<p>MITCH [<em>keeping his head lower, staring at his hands</em>]: Hello,
Miss … DuBois.</p>
<p>BLANCHE [<em>happily</em>]: Hello, Mitch. I’m glad that you could
visit me. You know, I haven’t spoken to anybody for a long time. I … I
didn’t mean that the Doctor and the Matron treated me badly, and I also
didn’t mean that you are just a … talkative partner in my heart.
[<em>Her voice dies out nervously.</em>] You know that, you know that …
did you bring some whiskey or lemon coke for me?</p>
<p>MITCH: No, the Matron said that you can’t have any liquor.</p>
<p>BLANCHE: That’s a pity. Did you bring some unwashed grapes for
me?</p>
<p>MITCH: What?</p>
<p>BLANCHE [<em>smiled</em>]: That’s just a joke.</p>
<p>MITCH [<em>relieved</em>]: It’s a relief to see you more delighted
and energetic now. [<em>There is a pause.</em>] The room is so … white,
like a … marble palace.</p>
<p>BLANCHE [<em>delightedly</em>]: Yes. Yes, I know that you mean to say
“Ivory tower”. The room is neat and … it is better than Elysian Fields,
right? I feel like a new human being with the white walls, the light,
and the Bible here. And Shep Huntleigh called me a few seconds ago. Soon
I’ll leave here and go to the real palace, being old and full of days.
The Lord will bless the latter end of mine more than my beginning.
[<em>The music of the polka rises, faint in the distance. She gets
crazy</em>] No, no, I don’t want to hear it again! [<em>Mitch gets
shocked.</em>] I’m sorry for that. I … I don’t know why sometimes I
behave like … like … Oh, how is your mother?</p>
<p>MITCH [<em>sadly</em>]: She has passed on.</p>
<p>BLANCHE: I’m sorry to hear that. [<em>There is a pause.</em>] Oh,
don’t let silence ruin our meeting. We haven’t met for …</p>
<p>MITCH: Seven months.</p>
<p>BLANCHE: Yes, seven months … It’s difficult for me to count the days
because there’s no calendar, nor sun … How about Stella’s baby? When I
feel lonely at night, I will miss the lovely baby. I haven’t seen him …
or her? Oh, it is not important, you know, Stella is my precious little
sister, and her baby is my precious little nephew … although the baby’s
father is … Stanley.</p>
<p>MITCH [<em>avoiding Blanche’s eyes</em>]: That’s why I came here,
Blanche, I have known the brutal thing that Stanley had done. I feel
angry and … sorry for it. I want to confess my behavior to you and …
beseech your forgiveness. [<em>His voice dies out.</em>]</p>
<p>BLANCHE: What thing? I must forget something. Pardon me, let me
remember for a moment … [<em>She starts shaking all over and panting for
breath.</em>] No, no, no! [<em>She screams</em>] That’s enough.</p>
<p>MITCH [<em>bravely</em>]: You know, Blanche. I … I’m sorry for what
Stanley … and I have done.</p>
<p>BLANCHE: I forgive you! You are the man that is without sin.</p>
<p>MITCH [<em>shocked</em>]: No, no, I’m not …</p>
<p>BLANCHE [<em>raising her voice</em>]: You are the one! It is you who
lighten my life … although just for a while. But that is not your fault.
I don’t deserve the light for my sinful self. It must be God’s
punishment …</p>
<p>MITCH [<em>restlessly</em>]: No, Blanche, you are …</p>
<p>BLANCHE: A courtesan, I’ve known it.</p>
<p>MITCH [<em>embarrassedly</em>]: No, Blanche, I didn’t mean that.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: So why do you come here? To
remind me of the past which I try to forget, to sneer at my fate that I
have been trapped in this prison, or just because you want to have a
sweet rest without guilt?</p>
<p>MITCH [<em>embarrassedly</em>]: No, no, Blanche, I come here with
kindness. I know the memory of Stanley is so harsh for you and I … I
have no hostility to mention it. And … and, you see, the room is not so
bad as a prison. It is safe. No one will hurt you here.</p>
<p>BLANCHE [<em>coldly</em>]: And no one will love me here.</p>
<p>[<em>They keep silent for a while.</em>]</p>
<p>MITCH [<em>nervously</em>]: Maybe we can turn the light off. The room
is too bright.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: Don’t touch the button. From
the first day I came here, the merciful Doctor and the Matron kept the
bulb on because they thought I’d be cured when there was no night. It
works! Now I love the light, it makes the room like a … white coffin.
Yes, a white coffin made of white woods.</p>
<p>MITCH: Don’t talk about death. You said you were afraid of it.</p>
<p>BLANCHE [<em>faintly</em>]: That was the past. In the past, I always
wanted to get away from death. Before I met you, I escaped to desire;
after I met you, I was lost in hope. In the past, I clutched at anything
that would tell me that I’m alive, and when there was no solid thing in
reality, I tried to clutch at myself … although I’m not solid enough.
The seven months I have spent here helped me understand death. Maybe
death isn’t just about crying and darkness but salvation and light. I
thought I dreamt about Jesus a few days ago and he said, “Today shalt
thou be with me in paradise.” I wanted to ask him what paradise is like
but … I could speak no word, and then I woke up ... But, but I could
imagine it! You see, the room is … is as stainless as heaven. You see
I’m more delighted and energetic here! It is doubtless that I’ll keep
delighted and energetic in heaven after I pass on … if I can go to
heaven by entering in at the strait gate … Do you think I can?</p>
<p>MITCH: Yes, of course.</p>
<p>BLANCHE [<em>laughed</em>]: God love you for a liar! But let me tell
you the truth: I’ve chosen a wide way that leadeth to destruction … it’s
real … but why I talk about the truth …</p>
<p>MITCH: I’m serious. I have made up my mind to come here … and I want
to take you away.</p>
<p>BLANCHE: I am not clean enough.</p>
<p>MITCH: Everyone is not clean enough. Everyone has … a sinful past.
The world is broken, Blanche …</p>
<p>BLANCHE: No, Mitch. I'm too delicate and painful, but you … are
realistic and natural. How can we live together … just because we long
for a partner? Sick people have such deep, sincere attachments. But the
truth is that I’m sick and you’re not. How can you forbear me when I’m
on the edge of lunacy and want magic?</p>
<p>MITCH: If we … get married, I swear that you won’t be on the edge of
lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world
is … always too harsh. [<em>There is a pause.</em>] It’s getting late.
Maybe the bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend
my funeral in the future? I have no idea when it will be held. But I
know it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could
imagine it. It will be quiet and stainless, with pretty flowers …
right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t … don’t
answer me. Let it be a mystery, a fantastic mystery, just like the end
of a fairy tale. I had read so many fairy tales when I was young and I
always imagined that I’m a princess living in a palace, in a magic
palace, waiting for my prince and then having a happy ending. Everyone
believes that the protagonists of stories will have a happy ending, and
I’ll also believe it. Do you know the French story <em>La Porte
étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the
end of the story, the hero and the heroine get married and have a happy
ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry.
Tears are so precious that you should save them for more precious
people.</p>
<p>[<em>Mitch covers his face with his hands. Blanche wants to wipe away
his tears at first, but then she hesitates and turns back.</em>]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the former
things are passed away.</p>
<p>MITCH [<em>raising his head with eyes full of tears,
hesitantly</em>]: Do you … do you still remember the inscription?</p>
<p>BLANCHE: What inscription? I have forgotten about it.</p>
<p>MITCH: Alright … alright, I’ll go. Good night, Miss DuBois.</p>
<p>BLANCHE: I shall say “Good night” till it be morrow.</p>
<p>[<em>MITCH leaves.</em>]</p>
<p>BLANCHE: And if God choose, I shall but love thee better after
death.</p>
<p>[<em>The lights fade away.</em>]</p>
<p><strong>END</strong></p>
<h3><span id="summary">SUMMARY</span></h3>
<p>At the end of <em>A Streetcar Named Desire,</em> Blanche says she has
forgotten something. In this sequel, Mitch visits the asylum where
Blanche is living to express his wish to take Blanche away. Blanche
refuses him despite her love for Mitch. While living in the asylum,
Blanche has understood more about death and love. She knows she is not
clean enough and wants to go to heaven and love Mitch after death.</p>
<p>Or is this sequel just Blanche’s another dream before death? In the
Bible, there is no night nor sun in heaven, just like the room.</p>
<h3><span id="theme">THEME</span></h3>
<p>It’s an attempt to explain Blanche’s change after Stanley’s rape.
Before that, she was afraid of death and tried to avoid harsh light. But
after that, she claimed that she’d be buried at noon. I tend to link it
to her chase for a fancy world like heaven.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>反演与容斥</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#子集反演">子集反演</a>
<ul>
<li><a href="#example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</a></li>
<li><a href="#example2有标号dag计数">Example2(有标号DAG计数)</a></li>
</ul></li>
<li><a href="#二项式反演">二项式反演</a>
<ul>
<li><a href="#example1错排问题">Example1(错排问题)</a></li>
<li><a href="#example2cf1750g">Example2(CF1750G)</a></li>
<li><a href="#example3cf1228e">Example3(CF1228E)</a></li>
</ul></li>
<li><a href="#斯特林反演">斯特林反演</a></li>
<li><a href="#莫比乌斯反演">莫比乌斯反演</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a>
<ul>
<li><a href="#增加枚举量">增加枚举量</a></li>
<li><a href="#交换枚举顺序">交换枚举顺序</a></li>
<li><a href="#分离无关变量">分离无关变量</a></li>
</ul></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a>
<ul>
<li><a href="#换元">换元</a></li>
</ul></li>
<li><a href="#example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</a></li>
</ul></li>
<li><a href="#多重子集反演">多重子集反演</a></li>
<li><a href="#单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</a></li>
<li><a href="#一般情况">一般情况</a>
<ul>
<li><a href="#一般形式">一般形式</a>
<ul>
<li><a href="#example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</a></li>
<li><a href="#example2错排问题">Example2(错排问题)</a></li>
<li><a href="#example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</a></li>
<li><a href="#example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
<li><a href="#example7agc058d">Example7(AGC058D)</a></li>
<li><a href="#example8agc035f">Example8(AGC035F)</a></li>
<li><a href="#example9">Example9</a></li>
<li><a href="#example10agc036f-square-constraints">Example10([AGC036F]
Square Constraints)</a></li>
<li><a href="#example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</a></li>
<li><a href="#example12">Example12</a></li>
</ul></li>
<li><a href="#min-max容斥">Min-Max容斥</a>
<ul>
<li><a href="#example123省选10连测-day6a">Example1([23省选10连测
day6]A)</a></li>
</ul></li>
<li><a href="#反射容斥">反射容斥</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p>##反演</p>
<p>假设有两个函数<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>满足:<span class="math inline">\(f(n)=\sum_{k}a_{n,k}g(k)\)</span>,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3>
<p>一般形式: <span class="math display">\[
f(S)=\sum_{T\subseteq S}g(T)\Leftrightarrow g(S)=\sum_{T\subseteq
S}(-1)^{|S|-|T|}f(T)\\
f(S)=\sum_{S\subseteq T\subseteq U}g(T)\Leftrightarrow
g(S)=\sum_{S\subseteq T\subseteq U}(-1)^{|T|-|S|}f(T)
\]</span> 证明: <span class="math display">\[
g(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}f(T)\\
=(-1)^{|S|}\sum_{T\subseteq S}(-1)^{|T|}\sum_{P\subseteq T}g(P)\\
=(-1)^{|S|}\sum_{P\subseteq S}g(P)\sum_{T\subseteq S/P}(-1)^{|T|+|P|}\\
=(-1)^{|S|}\sum_{P\subseteq S}g(P)(-1)^{|P|}\sum_{T\subseteq
S/P}(-1)^{|T|}\\
=(-1)^{|S|}\sum_{P\subseteq S}g(P)[S=P](-1)^{|P|}\\
=g(S)
\]</span></p>
<p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5>
<p>根据子集反演,设<span class="math inline">\(cnt_S\)</span>为集合为<span class="math inline">\(S\)</span>的数量,然后设<span class="math inline">\(f_S=\sum_{S&#39;\subseteq
S}cnt_{S&#39;}\)</span>,有:<span class="math inline">\(ans=\sum_{S}2^{f_S}(-1)^{n-|S|}\)</span>.</p>
<p>做一遍高维前缀和就好,复杂度<span class="math inline">\(O(n2^n)\)</span>,应该也可以用分治FMT无脑做到<span class="math inline">\(O(n^22^n)\)</span>.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5>
<p>设<span class="math inline">\(f_{i,j}\)</span>表示<span class="math inline">\(i\)</span>个点,其中有<span class="math inline">\(j\)</span>个点的入度数为<span class="math inline">\(0\)</span>的方案数.(等一下,为撒子想到要记度数为<span class="math inline">\(0\)</span>的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这<span class="math inline">\(j\)</span>个点后,还剩下<span class="math inline">\(k\)</span>个零度点.于是自然有: <span class="math display">\[
f_{i,j}=\binom{i}{j}\sum_{k=1}^{i-j}(2^j-1)^k2^{j(i-j-k)}f_{i-j,k}
\]</span> 等一下咧,这复杂度<span class="math inline">\(O(n^3)\)</span>了,这咋办啊?</p>
<p>好像转移优化不太了,因为<span class="math inline">\(k\)</span>很难省去(在指数上).但我们注意到我们定义的时候说:<span class="math inline">\(0\)</span>度点的数量恰好为<span class="math inline">\(k\)</span>,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少<span class="math inline">\(k\)</span>个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设<span class="math inline">\(f(n,S)\)</span>表示<span class="math inline">\(n\)</span>个点,其中只有<span class="math inline">\(S\)</span>中的点的入度为<span class="math inline">\(0\)</span>;类似定义<span class="math inline">\(g(n,S)\)</span>表示<span class="math inline">\(n\)</span>个点,至少<span class="math inline">\(S\)</span>中的点的入度为<span class="math inline">\(0\)</span>.显然我们所求也就是<span class="math inline">\(g(n,\empty)\)</span>,注意到: <span class="math display">\[
g(n,S)=2^{|S|(n-|S|)}g(n-|S|,\empty)\\
g(n,S)=\sum_{S\subseteq T}f(n,T)
\]</span> 对第二个式子用子集反演,有: <span class="math display">\[
f(n,S)=\sum_{S\subseteq T}(-1)^{|T|-|S|}g(n,T)
\]</span> 接下来使用反复带入大法: <span class="math display">\[
g(n,\empty)=\sum_{\empty\ne T}f(n,T)\\
=\sum_{T\subseteq S}(-1)^{|S|-|T|}g(n,S)\\
=\sum_{T\subseteq S}(-1)^{|S|-|T|}2^{|S|(n-|S|)}g(n-|S|,\empty)\\
=\sum_{m=1}^n\sum_{|T|=m}\sum_{T\subseteq
S}(-1)^{|S|-|T|}2^{|S|(n-|S|)}g(n-|S|,\empty)\\
=\sum_{m=1}^n\binom{n}{m}\sum_{k=m}^n\binom{n-m}{k-m}(-1)^{k-m}2^{k(n-k)}g(n-k,\empty)\\
\]</span>
可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简: <span class="math display">\[
\sum_{m=1}^n\binom{n}{m}\sum_{k=m}^n\binom{n-m}{k-m}(-1)^{k-m}2^{k(n-k)}g(n-k,\empty)\\
=\sum_{k=1}^n\sum_{m=1}^k\binom{n}{m}\binom{n-m}{k-m}(-1)^{k-m}2^{k(n-k)}g(n-k,\empty)\\
=\sum_{k=1}^n\binom{n}{k}2^{k(n-k)}g(n-k,\empty)\sum_{m=1}^k\binom{k}{m}(-1)^{k-m}\\
=\sum_{k=1}^n\binom{n}{k}2^{k(n-k)}g(n-k,\empty)((1-1)^k-(-1)^k)\\
=\sum_{k=1}^n\binom{n}{k}2^{k(n-k)}g(n-k,\empty)(-1)^{k-1}\\
\]</span> 注意到复杂度已经降到<span class="math inline">\(O(n^2)\)</span>了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个<span class="math inline">\((-1)^{k-1}\)</span>,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:
<span class="math display">\[
f_n=\sum_{k=1}^n\binom{n}{k}(-1)^{k-1}2^{k(n-k)}f_{n-k}\\
\]</span> 也就是直接设,然后钦定其有至少<span class="math inline">\(j\)</span>个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<p>一般形式: <span class="math display">\[
f(n)=\sum_{k=0}^nC_n^kg(k)\Leftrightarrow
g(n)=\sum_{k=0}^n(-1)^{n-k}C_n^kf(k)\\
f(n)=\sum_{k=0}^n(-1)^k\binom{n}{k}g(k)\Leftrightarrow
g(n)=\sum_{k=0}^n(-1)^k\binom{n}{k}f(k)\\
f(n)=\sum_{k=n}^NC_k^ng(k)\Leftrightarrow
g(n)=\sum_{k=n}^N(-1)^{k-n}C_k^nf(k)\\
f(n)=\sum_{k=n}^N(-1)^k\binom{k}{n}g(k)\Leftrightarrow
g(n)=\sum_{k=n}^N(-1)^k\binom{k}{n}f(k)\\
\]</span> 显然以<span class="math inline">\((-1)^ng(n)\)</span>代替<span class="math inline">\(g(n)\)</span>即可从第一个式子推导第二个式子,下面证明第一个式子:
<span class="math display">\[
g(n)=\sum_{k=0}^n(-1)^{n-k}C_n^kf(k)\\
=\sum_{m=0}^n\sum_{k=0}^{n-m}(-1)^kC_{n-m}^kC_n^mg(m)\\
=\sum_{k=0}^n(-1)^kC_n^k\sum_{m=0}^{n-k}C_{n-k}^mg(m)\\
=\sum_{k=0}^n(-1)^kC_n^kf(n-k)\\=\sum_{k=0}^n(-1)^{n-k}C_n^kf(k)\\
\]</span></p>
<h5><span id="example1错排问题">Example1(错排问题)</span></h5>
<p><span class="math inline">\(n\)</span>个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设<span class="math inline">\(f(n)\)</span>为<span class="math inline">\(n\)</span>个人随便站的方案数,<span class="math inline">\(g(n)\)</span>为<span class="math inline">\(n\)</span>个人都站错的方案数.</p>
<p>如果知道<span class="math inline">\(g\)</span>的表达式,我们可以通过枚举有多少人站错位置来得到<span class="math inline">\(f\)</span>,即:<span class="math inline">\(f(n)=\sum_{k=0}^nC_n^kg(k)\)</span>.</p>
<p>显然就是一个二项式反演,<span class="math inline">\(g(n)=\sum_{k=0}^n(-1)^{n-k}C_n^kf(k)=\sum_{k=0}^n(-1)^{n-k}C_n^kk!\)</span>.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:<span class="math inline">\(g(n)=n!\sum_{0\leq k\leq
n}\cfrac{(-1)^k}{k!}\\\)</span>.</p>
<p>不难发现<span class="math inline">\(n!\)</span>的后面形如<span class="math inline">\(e^{-1}\)</span>的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:
<span class="math display">\[
g(n)=\cfrac{n!}{e}-n!\sum_{k&gt;n}\cfrac{(-1)^k}{k!}\\
=\cfrac{n!}{e}-\cfrac{(-1)^{n+1}}{n+1}\sum_{0\leq
k}(-1)^k\cfrac{(n+1)!}{(k+n+1)!}
\]</span>
用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有<span class="math inline">\(g(n)=\lfloor\cfrac{n!}{e}+\cfrac{1}{2}\rfloor+[n=0]\)</span>.</p>
<p>另外,观察<span class="math inline">\(g\)</span>关于<span class="math inline">\(f\)</span>的表达式,不难求出<span class="math inline">\(g\)</span>的递推式:<span class="math inline">\(g(n)=ng(n-1)+(-1)^n\)</span>.</p>
<p>下面证明<span class="math inline">\(g_n=(n-1)(g_{n-1}+g_{n-2})\)</span>,事实上,右边等于:
<span class="math display">\[
(n-1)(g_{n-1}+g_{n-2})\\
=(-1)^{n-1}(n-1)+(n-1)\sum_{k=0}^{n-2}((n-1)!\frac{(-1)^k}{k!}+(n-2)!\frac{(-1)^k}{k!})\\
=n!\sum_{k=0}^{n-2}\frac{(-1)^k}{k!}-(n-1)(-1)^n\\
\]</span></p>
<h5><span id="example2cf1750g">Example2(CF1750G)</span></h5>
<p>如果没有字典序限制就是经典的二项式反演:考虑能被分为<span class="math inline">\(k\)</span>段,说明有<span class="math inline">\(n-k\)</span>个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了<span class="math inline">\(x\)</span>个数字,<span class="math inline">\(y\)</span>个区间,那么钦定<span class="math inline">\(j\)</span>对的方案是<span class="math inline">\(\binom{x-y}{j}(x-j)!\)</span>.然后要乘上前面已经有了的,也就是乘上形如<span class="math inline">\((1+z)^k\)</span>.这样复杂度<span class="math inline">\(O(n^4)\)</span>.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的<span class="math inline">\(x,y,k\)</span>有<span class="math inline">\(O(1)\)</span>种不同的取值,因此不用枚举.这样就是<span class="math inline">\(O(n^3)\)</span>.但是那个多项式乘法也可以规避,考虑最后的答案形如<span class="math inline">\(\sum (1+z)^kP_k(x)\)</span>,我们考虑写成<span class="math inline">\(P_{n-1}(z)+=(1+z)P_n(z)\)</span>,然后不断这么做,就只需要<span class="math inline">\(O(n^2)\)</span>.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5>
<p>不妨设至多有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(f_{i,j}\)</span>,恰好有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(g_{i,j}\)</span>,注意到: <span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}
\]</span> 令<span class="math inline">\(h_{n,m}=\sum_{j=0}^m\binom{m}{j}g_{n,j}\\\)</span>,则<span class="math inline">\(f_{n,m}=\sum_{i=0}^n\binom{n}{i}h_{i,m}\\\)</span>,而<span class="math inline">\(f_{n,m}=k^{nm}(k-1)^{NM-nm}\)</span>.做两次二项式反演得到<span class="math inline">\(g\)</span>.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥<span class="math inline">\(f_{n,m}\ne
\binom{N}{n}\binom{M}{m}k^{nm}(k-1)^{NM-nm}\)</span>呢?我们写成子集反演形式看看:
<span class="math display">\[
f_{S,T}=\sum_{s\subseteq S}\sum_{t\subseteq T}g_{s,t}\\
f_{S,T}=\sum_{s\subseteq S}h_{s,T}\\
h_{S,T}=\sum_{t\subseteq T}g_{S,t}\\
\]</span> 做子集反演: <span class="math display">\[
f_{S,T}=k^{|S|\times |T|}(k-1)^{NM-|S||T|}\\
h_{s,T}=\sum_{S\subseteq s}(-1)^{|s|-|S|}f_{S,T}\\
g_{s,t}=\sum_{T\subseteq t}(-1)^{|t|-|T|}h_{s,T}
\]</span> 把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,<span class="math inline">\(g_{n,m}\)</span>本身就包含了所有<span class="math inline">\(|S|=n,|T|=m\)</span>的情况的和,并且在组合数<span class="math inline">\(\binom{m}{j}\)</span>那里就找到了唯一确定的<span class="math inline">\(f_{s,t}\)</span>,因此<span class="math inline">\(f_{n,m}\)</span>是唯一确定的.这意味着这里<span class="math inline">\(f\)</span>的<span class="math inline">\(n,m\)</span>并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:
<span class="math display">\[
f_i=2^{2^{n-i}}\binom{n}{i}\\
f_k=\sum_{i=k}^n\binom{i}{k}g_i\\
g_k=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}f_i
\]</span>
冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:
<span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}
\]</span> 这个问题其实非常显然,我们的<span class="math inline">\(g_{i,j}\)</span>定义为所有<span class="math inline">\(|S|=i,|T|=j\)</span>的答案之和.<span class="math inline">\(f\)</span>也是这么定义的,那这个式子就是错的,应该写成:
<span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{N-i}{n-i}\sum_{j=0}^m\binom{M-j}{m-j}g_{i,j}
\]</span>
这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求<span class="math inline">\(g_{N,M}\)</span>,那此时<span class="math inline">\(g\)</span>怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子: <span class="math display">\[
f_k=\sum_{i=k}^n\binom{i}{k}g_i\\
\]</span> 这个定义式就非常良性,<span class="math inline">\(g\)</span>是已知的集合,<span class="math inline">\(f\)</span>是未知的集合.我们乘上组合数就可以得到对于<span class="math inline">\(f\)</span>来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把<span class="math inline">\(f\)</span>的定义改成<span class="math inline">\(f_{n,m}=k^{nm}(k-1)^{NM-nm}\)</span>就对了呢?</p>
<p>再看看这个式子: <span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}
\]</span> 这个式子的右边在干这样一件事:那就是在已知<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的集合的前提下,从中选出<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列并求<span class="math inline">\(g\)</span>.那么你从哪知道的<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列呢?你得组合数啊!</p>
<p>所以,实际上的<span class="math inline">\(f\)</span>是这样的: <span class="math display">\[
f_{n,m}=\binom{N}{n}\binom{M}{m}\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}\\
f_{n,m}= \binom{N}{n}\binom{M}{m}k^{nm}(k-1)^{NM-nm}
\]</span> 好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式: <span class="math display">\[
f(n)=\sum_{k=n}^NC_n^kg(k)\Leftrightarrow
g(n)=\sum_{k=n}^N(-1)^{k-n}C_n^kf(k)\\
\]</span>
不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设<span class="math inline">\(f&#39;_{i,j}\)</span>为至少有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列不满足条件的方案数,自然有<span class="math inline">\(f&#39;_{i,j}=f_{N-i,M-j}\)</span>.你发现此时一定有:
<span class="math display">\[
f&#39;_{n,m}=\sum_{i=n}^N\binom{i}{n}\sum_{j=m}^M\binom{j}{m}g&#39;_{i,j}
\]</span> 最后答案就是<span class="math inline">\(g&#39;_{0,0}\)</span>.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3>
<p>一般形式: <span class="math display">\[
f(n)=\sum_{k=0}^n\left\{ \begin{array}{c}n\\k\end{array}
\right\}g(k)\Leftrightarrow g(n)=\sum_{k=0}^n\left[
\begin{array}{c}n\\k\end{array} \right](-1)^{n-k}f(k)\\
f(n)=\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array}
\right]g(k)\Leftrightarrow g(n)=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array} \right\}(-1)^{n-k}f(k)\\
f(m)=\sum_{n=m}^M(-1)^{m-n}\left[ \begin{array}{c}n\\m\end{array}
\right]g(n)\Leftrightarrow g(m)=\sum_{k=0}^M\left\{
\begin{array}{c}k\\m\end{array} \right\}f(k)\\
f(m)=\sum_{n=m}^M(-1)^{m-n}\left\{ \begin{array}{c}n\\m\end{array}
\right\}g(n)\Leftrightarrow g(m)=\sum_{k=0}^M\left[
\begin{array}{c}k\\m\end{array} \right]f(k)\\
\]</span>
考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式: <span class="math display">\[
\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array} \right]\left\{
\begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array} \right\}\left[
\begin{array}{c}k\\m\end{array} \right](-1)^{n-k}=[m=n]\\
\]</span> 第一个式子的证明: <span class="math display">\[
g(n)=\sum_{m=0}^n[m=n]g(m)\\
=\sum_{m=0}^n\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array}
\right]\left\{ \begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}g(m)\\
=\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array}
\right](-1)^{n-k}\sum_{m=0}^k\left\{ \begin{array}{c}k\\m\end{array}
\right\}g(m)=\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array}
\right](-1)^{n-k}f(k)\\
\]</span> 第三个式子的证明: <span class="math display">\[
g(m)=\sum_{n=m}^M[n=m]g(n)\\
=\sum_{n=m}^M\sum_{k=0}^M\left[ \begin{array}{c}n\\k\end{array}
\right]\left\{ \begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}g(n)\\
=\sum_{k=0}^M\left\{ \begin{array}{c}k\\m\end{array} \right\}f(k)\\
\]</span></p>
<h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3>
<p>一般形式: <span class="math display">\[
f(n)=\sum_{d|n}g(d)\Leftrightarrow g(n)=\sum_{d|n}\mu(\frac n d)f(d)\\
f(n)=\sum_{n|d}g(d)\Leftrightarrow g(n)=\sum_{n|d}\mu(\frac d n)f(d)\\
f(x)=\sum_{1\leq d}g(d)\Leftrightarrow g(x)=\sum_{1\leq
d}f(\cfrac{x}d)\mu(d)
\]</span></p>
<p>第一个式子的证明: <span class="math display">\[
g(n)=\sum_{m|n}[\frac n m=1]g(m)\\
=\sum_{m|n}\sum_{d|\frac n m}\mu(d)g(m)\\
\]</span> 注意到<span class="math inline">\([d|\frac n
m]=[md|n]=[m|\frac n d]\\\)</span>. <span class="math display">\[
g(n)=\sum_{d|n}\mu(d)\sum_{m|\frac n d}g(m)\\=\sum_{d|n}\mu(d)f(\frac n
d)\\=\sum_{d|n}\mu(\frac n d)f(d)\\
\]</span> 第二个式子的证明: <span class="math display">\[
g(n)=\sum_{n|d}[\frac d n=1]g(d)\\=\sum_{n|d}\sum_{c|\frac d
n}\mu(c)g(d)\\=\sum_{c|d}\sum_{nc|d}\mu(c)g(d)\\=\sum_{c}\mu(c)f(nc)
\\=\sum_{n|d}\mu(\frac d n)f(d)\\
\]</span> 第三个式子的证明: <span class="math display">\[
\sum_{1\leq d}g(\cfrac{x}d)\mu(d)=\sum_{d\geq 1}\mu(d)\sum_{k\geq
1}f(\cfrac{x}{kd})\\
=\sum_{m\geq 1}f(\cfrac{x}{m})\sum_{d,k\geq 1}[m=dk]\mu(d)\\
=\sum_{m\geq 1}f(\cfrac{x}{m})\sum_{d|m}\mu(d)\\
=f(x)
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>求长度为<span class="math inline">\(n\)</span>且仅包含小写英文字母且循环节长度恰为<span class="math inline">\(n\)</span>的字符串个数.</p>
<p>不妨设<span class="math inline">\(f(n)\)</span>表示长度为<span class="math inline">\(n\)</span>的字符串个数,<span class="math inline">\(g(n)\)</span>表示长度为<span class="math inline">\(n\)</span>且循环节长度恰为<span class="math inline">\(n\)</span>的字符串个数.</p>
<p>有<span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span>,根据莫比乌斯反演,<span class="math inline">\(g(n)=\sum_{d|n}\mu(\cfrac{n}{d})f(d)\)</span>.</p>
<h4><span id="example2">Example2</span></h4>
<p>求<span class="math inline">\(\sum_{i=1}^{n}\sum_{j=1}^mgcd(i,j)\\\)</span>.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5>
<p><span class="math display">\[
\sum_{i=1}^{n}\sum_{j=1}^mgcd(i,j)=\sum_{i=1}^n\sum_{j=1}^mid[gcd(i,j)]\\=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}\varphi(d)\\
\]</span></p>
<h5><span id="交换枚举顺序">交换枚举顺序</span></h5>
<p><span class="math display">\[
\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}\varphi(d)=\sum_{d=1}^{\min(n,m)}\sum^{\lfloor\frac
n d\rfloor}_{i=1}\sum^{\lfloor\frac m d\rfloor}_{j=1}\varphi(d)\\
\]</span></p>
<h5><span id="分离无关变量">分离无关变量</span></h5>
<p><span class="math display">\[
\sum_{d=1}^{\min(n,m)}\sum^{\lfloor\frac n
d\rfloor}_{i=1}\sum^{\lfloor\frac m
d\rfloor}_{j=1}\varphi(d)=\sum^{\min(n,m)}_{d=1}\varphi(d)\times\lfloor\cfrac
n d\rfloor\times \lfloor\cfrac m d\rfloor\\
\]</span></p>
<p>考虑使用数论分块,只需处理出<span class="math inline">\(\varphi(d)\)</span>的前缀和即可在<span class="math inline">\(O(\sqrt{n}+\sqrt{m})\)</span>的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4>
<p>求<span class="math inline">\(\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)=1]\\\)</span>.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从<span class="math inline">\(id\)</span>变为了<span class="math inline">\(\epsilon\)</span>.</p>
<h4><span id="example4">Example4</span></h4>
<p>求<span class="math inline">\(\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)\in
prime]\\\)</span>.</p>
<p>考虑增加枚举量,则: <span class="math display">\[
\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)\in
prime]=\sum_{i=1}^{n}\sum_{j=1}^m\sum_{p\in prime}[gcd(i,j)=p]\\
=\sum_{p\in prime}\sum^{\lfloor\frac n d\rfloor}_{i=1}\sum^{\lfloor\frac
m d\rfloor}_{j=1}[gcd(pi,pj)=p]\\
=\sum_{p\in prime}\sum^{\lfloor\frac n p\rfloor}_{i=1}\sum^{\lfloor\frac
m p\rfloor}_{j=1}[gcd(i,j)=1]\\=\sum_{p\in
prime}\sum_{d=1}^{\min(\lfloor\frac m p\rfloor,\lfloor\frac n
p\rfloor)}\mu(d)\lfloor\cfrac n {pd}\rfloor\lfloor\cfrac m {pd}\rfloor\\
\]</span> 于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5>
<p>考虑设<span class="math inline">\(x=pd\)</span>,则变为<span class="math inline">\(\sum_{x=1}^{\min(n,m)}\sum_{p\in prime\and
p|x}\mu(\frac{x}{p})\lfloor\frac n {x}\rfloor\lfloor\frac m
{x}\rfloor\\\)</span>.</p>
<p>####Example5([UR #5]怎样跑得更快)</p>
<p>首先先考虑去掉<span class="math inline">\(lcm\)</span>使得式子中只有<span class="math inline">\(i,j,\gcd(i,j)\)</span>.</p>
<p>显然可以构造函数<span class="math inline">\(f(x)=x^{c-d},g(x)=x^d,h(x)=x^d\\\)</span>,然后将题目转化为<span class="math inline">\(\sum_{j=1}^nf(gcd(i,j))g(i)h(j)x_j\equiv b_i(\mod
p)\\\)</span>.</p>
<p><span class="math inline">\(\gcd(i,j)\)</span>很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出<span class="math inline">\(f_r(n)\)</span>使得<span class="math inline">\(f(n)=\sum_{d|n}f_r(d)\\\)</span>,也即<span class="math inline">\(f_r(n)=\sum_{d|n}\mu(\cfrac{n}{d})f(d)\)</span>.</p>
<p>则原式即: <span class="math display">\[
\sum_{j=1}^n\sum_{d}[d|i][d|j]f_r(d)g(i)h(j)x_j\equiv b_i(\mod p)\\
\sum_{d|i}f_r(d)\sum_{j=1}^n[d|j]h(j)x_j\equiv \frac{b_i}{g(i)}(\mod
p)\\
\]</span> 令<span class="math inline">\(z_d=\sum_{j=1}^n[d|j]h(j)x_j\\\)</span>,有<span class="math inline">\(\sum_{d|i}f_r(d)z_d\equiv \frac{b_i}{g(i)}(\mod
p)\\\)</span>.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出<span class="math inline">\(z_d\)</span>.</p>
<p>而<span class="math inline">\(z_d=\sum_{j=1}^n[d|j]h(j)x_j=\sum_{d|j}^nh(j)x_j\)</span>,可以再次使用莫比乌斯反演求出<span class="math inline">\(h(j)x_j\)</span>,进而求<span class="math inline">\(x_j\)</span>.</p>
<p>无解条件显然是<span class="math inline">\(g_i=0\and x_i\ne
0\)</span>.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol type="1">
<li>通过增加枚举量消掉<span class="math inline">\(lcm\)</span>以及<span class="math inline">\(\gcd\)</span>这些难以处理的项.</li>
<li>将<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>尽量分到式子两边.</li>
<li>先通过莫比乌斯反演求出一些值,再通过这些值反推.</li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4>
<p>首先注意到一个重要的事实:我们只需要询问所有<span class="math inline">\(\mu(x)\ne 0\)</span>的<span class="math inline">\(x\)</span>,就可以得到全部信息,而这些<span class="math inline">\(x\)</span>的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:
<span class="math display">\[
f(n)=\bigoplus_{i\in A}i[\gcd(i,n)=1]\\
=\bigoplus_{i\in A}^ci\sum_{d|i,d|n}\mu(d)\\
\]</span> 注意到<span class="math inline">\(\sum_{d|i}\mu(d)=\bigoplus_{d|i}|\mu(d)|\)</span>,于是:
<span class="math display">\[
f(n)=\bigoplus_{d|n}|\mu(d)|\bigoplus_{d|i,i\in A}i
\]</span> 接下来只要我们形式上写作<span class="math inline">\(n\)</span>,我们就默认<span class="math inline">\(\mu(n)\ne 0\)</span>,又令<span class="math inline">\(g(n)=\bigoplus_{n|i,i\in
A}i\)</span>,此时自然有<span class="math inline">\(f(n)=\bigoplus_{d|n}g(d)\\\)</span>.这是一个经典的莫反形式,我们再反演回去就可以得到<span class="math inline">\(g(n)=\bigoplus_{d|n}\mu(\frac{n}{d})f(d)=\bigoplus_{d|n}f(d)\)</span>,也就是说我们可以求得所有的<span class="math inline">\(g(n)\)</span>,也就是这个集合中所有是<span class="math inline">\(n\)</span>的倍数的异或值.</p>
<p>注意一个事实:如果我们设<span class="math inline">\(w(m)=\prod_{p\in
prime,p|m}p\)</span>,那么我们就可以按照<span class="math inline">\(w\)</span>的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进<span class="math inline">\(A\)</span>的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设<span class="math inline">\(S(n)=\{x|w(x)=n\}\)</span>,又设<span class="math inline">\(h(n)=\bigoplus_{i\in A,i\in
S(n)}i\)</span>.考虑用<span class="math inline">\(g(n)\)</span>表示<span class="math inline">\(h(n)\)</span>,我们有: <span class="math display">\[
g(n)=\bigoplus_{n|d}|\mu(\frac{d}{n})|h(d)
\]</span> 反演,有<span class="math inline">\(h(n)=\bigoplus_{n|d}g(d)\\\)</span>.于是我们可以求得所有的<span class="math inline">\(h(n)\)</span>了.</p>
<p>现在的问题在于:对于数<span class="math inline">\(n,\mu(n)\ne
0\)</span>,我们要在<span class="math inline">\(S(n)\)</span>中选出若干个数,使得它们的异或和为<span class="math inline">\(h(n)\)</span>,并且选出的数字总共有<span class="math inline">\(|A|\)</span>个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3>
<p>设<span class="math inline">\(S\)</span>为可重集合.</p>
<p>一般形式:定义<span class="math inline">\(\mu(S)\)</span>,若<span class="math inline">\(S\)</span>包含重复元素则为<span class="math inline">\(0\)</span>,否则为<span class="math inline">\((-1)^{|S|}\)</span>. <span class="math display">\[
f(S)=\sum_{T\subseteq S}g(T)\Leftrightarrow g(S)=\sum_{T\subseteq
S}\mu(S-T)f(T)\\
\]</span> 证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3>
<p>一般形式(<span class="math inline">\(\omega_n=e^{\frac {2\pi
i}{n}}\)</span>): <span class="math display">\[
f_m=\sum_{k=0}^{n-1}\omega_n^{mk}g_k
\Leftrightarrow g_m=\frac 1 n\sum_{k=0}^{n-1}\omega_n^{-mk}f_k
\]</span> 可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3>
<p>考虑莫比乌斯反演的过程,我们实际上使用的是<span class="math inline">\([m|n]\sum_{d|\frac n
m}\mu(d)=[n=m]\\\)</span>.</p>
<p>令<span class="math inline">\(c=md\)</span>,左边<span class="math inline">\(=\sum_{c|n}[m|c]\mu(\frac c
m)=\sum([c|n])([m|c]\mu(\frac c m))\\\)</span>.</p>
<p>令<span class="math inline">\(A_{c,n}=[c|n]\)</span>,<span class="math inline">\(B_{m,c}=[m|c]\mu(\frac c
m)\\\)</span>,那我们有<span class="math inline">\(BA=I\)</span>.</p>
<p>刚才的过程相当于: <span class="math display">\[
Ax=b\\
x=Ix\\
x=(BA)x\\
x=B(Ax)\\
x=Bb\\
\]</span> 无论是二项式反演还是莫比乌斯反演,他们都满足<span class="math inline">\(f(n)\)</span>所依赖的<span class="math inline">\(g(k)\)</span>有<span class="math inline">\(k\leq
n\\\)</span>.</p>
<p>根据上面的情况,我们发现<span class="math inline">\(A\)</span>是一个下三角矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(A^{-1}\)</span>.</p>
<p>现在来推导满足<span class="math inline">\(k\leq
n\)</span>的一般情况反演: <span class="math display">\[
f(n)=\sum_{k=1}^na_{n,k}g(k)\\
\]</span> 不妨设算子<span class="math inline">\(\mu(n,m)\)</span>,满足<span class="math inline">\(\sum_{k=1}^na_{n,k}\mu(k,m)=\sum_{k=1}^n\mu(n,k)a_{k,m}=[n=m]\\\)</span>.
即<span class="math inline">\(AB=BA=I\\\)</span>. <span class="math display">\[
g(n)=\sum_{m=1}^n[n=m]g(m)\\=\sum_{m=1}^n\sum_{k=1}^n\mu(n,k)a_{k,m}g(m)\\=\sum_{k=1}^n\mu(n,k)f(k)\\
\]</span> 由上我们发现,反演解决了一些在下标上的二元运算卷积: <span class="math display">\[
c_r=\sum_{p,q}[f(p,q)=r]a_pb_q\\
\]</span> 而我们需要把<span class="math inline">\(f\)</span>分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<p>##容斥</p>
<h4><span id="一般形式">一般形式</span></h4>
<p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:<span class="math inline">\(\mid \bigcup_{i=1}^nS_i
\mid=\sum_{T\subseteq \{1,...,n\}}(-1)^{|T-1|}\mid\bigcap_{p\in T}S_p
\mid\)</span>.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属<span class="math inline">\(m\)</span>个集合<span class="math inline">\(T_1,...,T_m\)</span>,而除了这些集合以外的集合,
<span class="math display">\[
cnt=\sum_{i=1}^m(-1)^{i-1}\binom{m}{i}\\
=\binom{m}{0}-\sum_{i=0}^m(-1)^i\binom{m}{i}\\
=1-[m=0]
\]</span> 显然,当这个元素被包含的时候,贡献为<span class="math inline">\(1\)</span>,反之贡献为<span class="math inline">\(0\)</span>.</p>
<p>如果我们定义一类在集合上的函数<span class="math inline">\(F(S)=\sum_{p\in S}F(p)\)</span>,那么自然也有:
<span class="math display">\[
F(\bigcup_{i=1}^nS_i)=\sum_{T\subseteq
\{1,...,n\}}(-1)^{|T|-1}F(\bigcap_{p\in T}S_p)
\]</span></p>
<p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:
<span class="math display">\[
\mid\bigcap_{i=1}^nS_i\mid=|U|-\mid\bigcup_{i=1}^n \overline{S_i}\mid
\]</span> 这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5>
<p>考虑不定方程<span class="math inline">\(\sum_{i=1}^nx_i=m\)</span>,和<span class="math inline">\(n\)</span>个限制条件<span class="math inline">\(x_i\leq b_i\)</span>,其中<span class="math inline">\(m\)</span>和<span class="math inline">\(b_i\)</span>都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件):</p>
<ol type="1">
<li><span class="math inline">\(U\)</span>是满足<span class="math inline">\(\sum_{i=1}^nx_i=m\)</span>的所有非负整数解;</li>
<li>对于每个变量<span class="math inline">\(i\)</span>,都对应一个<span class="math inline">\(P_i=[x_i\leq b_i]\)</span>.</li>
</ol>
<p>设所有满足<span class="math inline">\(P_i\)</span>的解构成集合<span class="math inline">\(S_i\)</span>,那么我们需要求解的值就是<span class="math inline">\(\mid\bigcap_{i=1}^nS_i\mid\)</span>.而<span class="math inline">\(\mid U\mid\)</span>显然是<span class="math inline">\(\binom{m+n-1}{n-1}\)</span>.我们有:<span class="math inline">\(\mid
\bigcap_{i=1}^nS_i\mid=|U|-\mid\bigcup_{i=1}^n\overline{S_i}\mid\)</span>.考虑对<span class="math inline">\(\mid\bigcup_{i=1}^n\overline{S_i}\mid\)</span>使用容斥原理,注意到<span class="math inline">\(\overline{S_i}\)</span>的意义是满足<span class="math inline">\(x_{i}\geq
b_{i}+1\)</span>的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5>
<p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件):</p>
<ol type="1">
<li><span class="math inline">\(U\)</span>是长度为<span class="math inline">\(n\)</span>的所有排列;</li>
<li>对于每个变量<span class="math inline">\(i\)</span>,都对应一个<span class="math inline">\(P_i=[p_i\ne i]\)</span>.</li>
</ol>
<p>注意到所求仍然是<span class="math inline">\(\mid\bigcap_{i=1}^nS_i\mid\)</span>.于是我们仍然试图<span class="math inline">\(|\bigcap_{k=1}^m\overline
{S_{a_k}}|\)</span>.考虑其意义,也即:有<span class="math inline">\(m\)</span>个位置被确定了,而其它位置没有限制,于是<span class="math inline">\(|\bigcap_{k=1}^m\overline
{S_{a_k}}|=\binom{n}{m}(n-m)!\)</span>.根据容斥,自然有:<span class="math inline">\(d_n=n!-\sum_{m=1}^n(-1)^{m-1}\binom{n}{m}(n-m)!=n!\sum_{m=0}^n\cfrac{(-1)^m}{m!}\)</span>.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5>
<p>首先可以用dp+双指针得到<span class="math inline">\(f_i\)</span>表示勒令<span class="math inline">\(i\)</span>对满足条件的方案数.把<span class="math inline">\(k\)</span>的定义改为恰好<span class="math inline">\(k\)</span>对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好<span class="math inline">\(a\)</span>对的方案会被恰好<span class="math inline">\(b\)</span>对的方案计算<span class="math inline">\(\binom{b}{a}\)</span>次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为<span class="math inline">\(k\)</span>的方案贡献为<span class="math inline">\(1\)</span>,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为<span class="math inline">\(k+1\)</span>的方案贡献为<span class="math inline">\(0\)</span>,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令<span class="math inline">\(ans=f_k\)</span>,第二步除去其中被多算的<span class="math inline">\(k+1\)</span>,这一步令<span class="math inline">\(ans-=\binom{k+1}{k}f_{k+1}\)</span>.这个时候,我们再考虑<span class="math inline">\(k+2\)</span>的贡献:它将在<span class="math inline">\(f_k\)</span>时贡献<span class="math inline">\(\binom{k+2}k\)</span>次,在<span class="math inline">\(f_{k+1}\)</span>时贡献<span class="math inline">\(-\binom{k+2}{k+1}\binom{k+1}{k}=-\binom{k+2}{k}\binom{2}{1}\)</span>次,那它现在的贡献还有:<span class="math inline">\(-\binom{k+2}k\)</span>次.以此类推,可以得到<span class="math inline">\(ans=\sum_{i=k}^nf_i(-1)^{i-k}\binom{i}{k}\)</span>.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个<span class="math inline">\(P_i\)</span>.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画<span class="math inline">\(P_i\)</span>,因为只有这个时候,我们才能通过分析满不满足<span class="math inline">\(P_i\)</span>的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成<span class="math inline">\(1/0\)</span>就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5>
<p>如果直接对于每次询问暴力做,复杂度显然是<span class="math inline">\(O(4ns)\)</span>,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画<span class="math inline">\(P_i=[use_i\leq
d_i]\)</span>,从而可以用容斥做.复杂度<span class="math inline">\(O(4m+n2^4)\)</span>.</p>
<h5><span id="example5">Example5</span></h5>
<p>Alice和Bob在玩游戏,他们有一个<span class="math inline">\(n\)</span>个点的无向完全图,设所有的边组成了集合<span class="math inline">\(E\)</span>,他们想取遍<span class="math inline">\(E\)</span>的所有非空子集,对某个集合<span class="math inline">\(S\)</span>有一个估价<span class="math inline">\(f(S)\)</span>:考虑<span class="math inline">\(n\)</span>个点与<span class="math inline">\(S\)</span>中的边组成的图,我们用<span class="math inline">\(m\)</span>种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么<span class="math inline">\(f(S)\)</span>等于这个图的染色方案数.同时,Alice喜欢奇数,所以当<span class="math inline">\(|S|\)</span>为奇数时,Alice的分值加上<span class="math inline">\(f(S)\)</span>,否则Alice的分值减去<span class="math inline">\(f(S)\)</span>,求最后的分值.<span class="math inline">\((n,m\leq 10^6)\)</span>.</p>
<p>一开始抄题的时候没有写染色而是直接写”设<span class="math inline">\(k\)</span>为连通块个数,则<span class="math inline">\(f(S)=m^k\)</span>.”然后发现做不了,因为<span class="math inline">\(|S|\)</span>相同的<span class="math inline">\(f(S)\)</span>不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个<span class="math inline">\(m\)</span>,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那<span class="math inline">\(x\leftrightarrow y\Rightarrow
col_x=col_y\)</span>.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与<span class="math inline">\(-1\)</span>有关的单位元素(从一开始就是点)和与<span class="math inline">\(f\)</span>有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令<span class="math inline">\(F(C)\)</span>表示在<span class="math inline">\(C\)</span>情况下的染色方案,<span class="math inline">\(T_{(i,j)}\)</span>表示满足边<span class="math inline">\((i,j)\)</span>限制的解集: <span class="math display">\[
ans=\sum_{\empty\ne S\subseteq E}(-1)^{|S|-1}F(\bigcap_{(i,j)\in
S}T_{(i,j)})
\]</span>
冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出<span class="math inline">\(ans\)</span>的意义:显然是<span class="math inline">\(F(\bigcup_{i=1}^{m}P_i)\)</span>.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是<span class="math inline">\(m^n-m^{\underline{n}}\)</span>.</p>
<h5><span id="example6">Example6</span></h5>
<p>求<span class="math inline">\(\varphi(n)\)</span>.</p>
<p>考虑这么一个事实:假设<span class="math inline">\(n=\prod
p_i^{q_i}\)</span>,注意到令<span class="math inline">\(P_i=[\gcd(i,n)=1]\)</span>,我们所求也就是<span class="math inline">\(\mid\bigcap_{i=1}^nS_i\mid\)</span>.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5>
<p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如<span class="math inline">\(ABCABCAB...\)</span>这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于<span class="math inline">\(3\)</span>并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5>
<p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的<span class="math inline">\(1\)</span>,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是<span class="math inline">\(\sum_{i=0}^{\min(n,m)}(-1)^i\binom{n}{i}\binom{m}{i}i!(m+1)^{n-i}(n+1)^{m-i}\)</span>.</p>
<h5><span id="example9">Example9</span></h5>
<p>给定若干个限制条件<span class="math inline">\((x,y)\)</span>,表示<span class="math inline">\(a_x=y\)</span>和<span class="math inline">\(a_y=x\)</span>必须满足至少一个,求排列方案数.</p>
<p>首先<span class="math inline">\(i\rightarrow
p_i\)</span>把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为<span class="math inline">\(2\)</span>的链,它自己成环的话是不用<span class="math inline">\(\times 2\)</span>的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是<span class="math inline">\(\times 2\)</span>,所以一个有<span class="math inline">\(1\)</span>个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为<span class="math inline">\(2\)</span>的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-squareconstraints">Example10([AGC036F] Square
Constraints)</span></h5>
<p>由题意得:<span class="math inline">\(n^2-i^2\leq P_i^2\leq
(2n)^2-i^2\)</span>.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为<span class="math inline">\(l_i\)</span>,那么只有上界的答案应该是什么呢?将<span class="math inline">\(l\)</span>从小到大排序,答案就是<span class="math inline">\(\prod_{i=0}^{2n-1}(l_i-i)\)</span>.(注意到必须满足<span class="math inline">\(l_{2n-1}=2n-1\)</span>.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个<span class="math inline">\(\frac{1}4\)</span>的圆弧.而通过圆弧的性质不难看出:最终的<span class="math inline">\(l\)</span>分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道<span class="math inline">\(l\)</span>按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照<span class="math inline">\(l\)</span>的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度<span class="math inline">\(O(n^3)\)</span>.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5>
<p>(下面将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>反着写)</p>
<p>设<span class="math inline">\(p=\frac{2k}{n},q=n-p\)</span>.</p>
<p>首先注意到期望<span class="math inline">\(=P[len\geq 1]+P[len\geq
2]+\cdots\)</span>.</p>
<p>考虑如何计算<span class="math inline">\(P[len\geq
x]\)</span>,如果我们设<span class="math inline">\(a_i\)</span>表示以<span class="math inline">\(i\)</span>作为开头的极长的带劲的长度大于等于<span class="math inline">\(x\)</span>的序列的集合,那么最后无非是要求所有<span class="math inline">\(a\)</span>的并.考虑用容斥做到求所有<span class="math inline">\(a\)</span>的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5>
<p>给定<span class="math inline">\(n,k\)</span>和<span class="math inline">\(n\)</span>个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过<span class="math inline">\(k\)</span>.<span class="math inline">\(n\leq
300\)</span>.</p>
<p>著名结论:<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>个连通块任意连边成树的方案数是<span class="math inline">\(n^{m-2}\prod s\)</span>,其中<span class="math inline">\(s\)</span>是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过<span class="math inline">\(k\)</span>,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于<span class="math inline">\(k\)</span>的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过<span class="math inline">\(k\)</span>,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数<span class="math inline">\((-1)^{块数-1}\)</span>.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4>
<p>对于: <span class="math display">\[
\mid \bigcup_{i=1}^nS_i \mid=\sum_{T\subseteq
\{1,...,n\}}(-1)^{|T-1|}\mid\bigcap_{p\in T}S_p \mid
\]</span> 考虑一个特例:<span class="math inline">\(S_i=\{1,2,\cdots,a_i\}\)</span>,那么上面的式子导出min-max容斥(我们设<span class="math inline">\(S=\{a_1,a_2,\cdots,a_n\}\)</span>)(第二个式子可以把前缀改成后缀):
<span class="math display">\[
\max(S)=\sum_{T\subseteq S,T\ne \empty}(-1)^{|T|-1}\min(T)\\
\min(S)=\sum_{T\subseteq S,T\ne \empty}(-1)^{|T|-1}\max(T)
\]</span> 由于是集合,这个式子在期望意义下同样成立: <span class="math display">\[
E(\max\{S\})=\sum_{T\subseteq S,T\ne \empty}(-1)^{|T|-1}E(\min\{S\})\\
E(\min\{S\})=\sum_{T\subseteq S,T\ne \empty}(-1)^{|T|-1}E(\max\{S\})
\]</span>
进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:
<span class="math display">\[
kth\max\{S\}=\sum_{T\subseteq S,T\ne
\empty}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min\{T\}\\
kth\min\{S\}=\sum_{T\subseteq S,T\ne
\empty}(-1)^{|T|-k}\binom{|T|-1}{k-1}\max\{T\}\\
E(kth\max\{S\})=\sum_{T\subseteq S,T\ne
\empty}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min\{T\})\\
E(kth\min\{S\})=\sum_{T\subseteq S,T\ne
\empty}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\max\{T\})
\]</span> 原理是消掉前<span class="math inline">\(k-1\)</span>大的数字,让他们的贡献为<span class="math inline">\(0\)</span>,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5>
<p>不妨设<span class="math inline">\(tim_i\)</span>为<span class="math inline">\([i,i+1]\)</span>第一次被覆盖的时间,答案就是: <span class="math display">\[
E(\max_{i=1}^{n-1}\{tim_i\})=\sum_{T\subseteq \{1,2,\cdots,n-1\},T\ne
\empty}(-1)^{|T|-1}E(\min_{j\in T}\{tim_j\})
\]</span> 设<span class="math inline">\(f(S)\)</span>为有多少个区间能覆盖至少一个<span class="math inline">\([i,i+1],i\in S\)</span>,考虑<span class="math inline">\(E=p_{[t\geq 0]}+p_{[t\geq 1]}+p_{[t\geq
2]}+\cdots\)</span>,于是<span class="math inline">\(E(\min_{j\in
S}\{tim_j\})=\frac{m}{f(S)}\)</span>.</p>
<p>于是: <span class="math display">\[
ans=\sum_{T\subseteq \{1,2,\cdots,n-1\},T\ne \empty}(-1)^{|T|-1}f(T)\\
=\sum_{k=0}^m\frac{m}{k}\sum_{T\subseteq \{1,2,\cdots,n-1\},T\ne
\empty,f(T)=k}(-1)^{|T|-1}
\]</span> 注意到<span class="math inline">\(f(S)\)</span>可能不那么好求,我们求<span class="math inline">\(g(S)=m-f(S)\)</span>,也就是不包含任何一个<span class="math inline">\([i,i+1],i\in S\)</span>的区间个数,我们有: <span class="math display">\[
ans=\sum_{k=0}^m\frac{m}{m-k}\sum_{T\subseteq \{1,2,\cdots,n-1\},T\ne
\empty,g(T)=k}(-1)^{|T|-1}
\]</span> 这里已经不难写出<span class="math inline">\(O(n^3)\)</span>的dp了.</p>
<p>那么怎么优化呢?设<span class="math inline">\(dp_{i,j}\)</span>表示只考虑<span class="math inline">\([1,i]\)</span>时(<span class="math inline">\([i-1,i]\)</span>必选),<span class="math inline">\(\sum_{g(T)=j}(-1)^{|T|-1}\)</span>的答案,不难发现每次加入一个区间<span class="math inline">\([l,r]\)</span>就会让<span class="math inline">\(dp_{i,j},i&lt;=l\)</span>对<span class="math inline">\(dp_{r,j+1}\)</span>的贡献乘一个<span class="math inline">\(1\)</span>.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度<span class="math inline">\(O(nm\log n)\)</span>.</p>
<h4><span id="反射容斥">反射容斥</span></h4>
<p>一般形式:给定二维平面上两个点<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>,其中<span class="math inline">\(T\)</span>在<span class="math inline">\(S\)</span>的右方,给定两条线<span class="math inline">\(y=a\)</span>和<span class="math inline">\(y=b\)</span>,每次可以向右上或者右下走一步,求不碰线的从<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的方案数.</p>
<p>我们不妨设<span class="math inline">\(A\)</span>表示一定碰了一次上界的方案数,<span class="math inline">\(B\)</span>表示一定碰了一次下界的方案数,<span class="math inline">\(AB\)</span>表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走<span class="math inline">\(-A-B+AB+BA-ABA-BAB...\)</span>.</p>
<p>考虑设步数为<span class="math inline">\(n\)</span>,那显然长度最多为<span class="math inline">\(\cfrac{n}{a-b}\)</span>.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>北大相关选拔数学真题汇总</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#2024寒假学堂部分">2024寒假学堂(部分)</a>
<ul>
<li><a href="#problem4">Problem4</a>
<ul>
<li><a href="#solution4">Solution4</a></li>
</ul></li>
<li><a href="#problem10">Problem10</a>
<ul>
<li><a href="#solution10">Solution10</a></li>
</ul></li>
<li><a href="#problem11">Problem11</a>
<ul>
<li><a href="#solution11">Solution11</a></li>
</ul></li>
<li><a href="#problem14">Problem14</a>
<ul>
<li><a href="#solution14">Solution14</a></li>
</ul></li>
<li><a href="#problem15">Problem15</a>
<ul>
<li><a href="#solution15">Solution15</a></li>
</ul></li>
<li><a href="#problem18">Problem18</a>
<ul>
<li><a href="#solution18">Solution18</a></li>
</ul></li>
<li><a href="#problem19">Problem19</a>
<ul>
<li><a href="#solution19">Solution19</a></li>
</ul></li>
<li><a href="#problem20">Problem20</a>
<ul>
<li><a href="#solution20">Solution20</a></li>
</ul></li>
</ul></li>
<li><a href="#2023强基部分">2023强基(部分)</a>
<ul>
<li><a href="#problem3">Problem3</a>
<ul>
<li><a href="#solution3">Solution3</a></li>
</ul></li>
<li><a href="#problem4-1">Problem4</a>
<ul>
<li><a href="#solution4-1">Solution4</a></li>
</ul></li>
<li><a href="#problem8">Problem8</a>
<ul>
<li><a href="#solution8">Solution8</a></li>
</ul></li>
<li><a href="#problem10-1">Problem10</a>
<ul>
<li><a href="#solution10-1">Solution10</a></li>
</ul></li>
<li><a href="#problem11-1">Problem11</a>
<ul>
<li><a href="#solution11-1">Solution11</a></li>
</ul></li>
<li><a href="#problem12">Problem12</a>
<ul>
<li><a href="#solution12">Solution12</a></li>
</ul></li>
<li><a href="#problem14-1">Problem14</a>
<ul>
<li><a href="#solution14-1">Solution14</a></li>
</ul></li>
<li><a href="#problem15-1">Problem15</a>
<ul>
<li><a href="#solution15-1">Solution15</a></li>
</ul></li>
<li><a href="#problem16">Problem16</a>
<ul>
<li><a href="#solution16">Solution16</a></li>
</ul></li>
<li><a href="#problem17">Problem17</a>
<ul>
<li><a href="#solution17">Solution17</a></li>
</ul></li>
<li><a href="#problem18-1">Problem18</a>
<ul>
<li><a href="#solution18-1">Solution18</a></li>
</ul></li>
<li><a href="#problem19-1">Problem19</a>
<ul>
<li><a href="#solution19-1">Solution19</a></li>
</ul></li>
<li><a href="#problem20-1">Problem20</a>
<ul>
<li><a href="#solution20-1">Solution20</a></li>
</ul></li>
</ul></li>
<li><a href="#2024强基部分">2024强基(部分)</a>
<ul>
<li><a href="#problem1">Problem1</a>
<ul>
<li><a href="#solution1">Solution1</a></li>
</ul></li>
<li><a href="#problem3-1">Problem3</a>
<ul>
<li><a href="#solution3-1">Solution3</a></li>
</ul></li>
<li><a href="#problem4-2">Problem4</a>
<ul>
<li><a href="#solution4-2">Solution4</a></li>
</ul></li>
<li><a href="#problem5">Problem5</a>
<ul>
<li><a href="#solution5">Solution5</a></li>
</ul></li>
<li><a href="#problem8-1">Problem8</a>
<ul>
<li><a href="#solution8-1">Solution8</a></li>
</ul></li>
<li><a href="#problem9">Problem9</a>
<ul>
<li><a href="#solution9">Solution9</a></li>
</ul></li>
<li><a href="#problem11-2">Problem11</a>
<ul>
<li><a href="#solution11-2">Solution11</a></li>
</ul></li>
<li><a href="#problem12-1">Problem12</a>
<ul>
<li><a href="#solution12-1">Solution12</a></li>
</ul></li>
<li><a href="#problem20-2">Problem20</a>
<ul>
<li><a href="#solution20-2">Solution20</a></li>
</ul></li>
</ul></li>
<li><a href="#2022图选">2022图选</a>
<ul>
<li><a href="#problem1-1">Problem1</a>
<ul>
<li><a href="#solution1-1">Solution1</a></li>
</ul></li>
<li><a href="#problem2">Problem2</a>
<ul>
<li><a href="#solution2">Solution2</a></li>
</ul></li>
<li><a href="#problem3-2">Problem3</a>
<ul>
<li><a href="#solution3-2">Solution3</a></li>
</ul></li>
<li><a href="#problem4-3">Problem4</a>
<ul>
<li><a href="#solution4-3">Solution4</a></li>
</ul></li>
<li><a href="#problem5-1">Problem5</a>
<ul>
<li><a href="#solution5-1">Solution5</a></li>
</ul></li>
</ul></li>
<li><a href="#2023图选">2023图选</a>
<ul>
<li><a href="#problem1-2">Problem1</a>
<ul>
<li><a href="#solution1-2">Solution1</a></li>
</ul></li>
<li><a href="#problem2-1">Problem2</a>
<ul>
<li><a href="#solution2-1">Solution2</a></li>
</ul></li>
<li><a href="#problem3-3">Problem3</a>
<ul>
<li><a href="#solution3-3">Solution3</a></li>
</ul></li>
<li><a href="#problem4-4">Problem4</a>
<ul>
<li><a href="#solution4-4">Solution4</a></li>
</ul></li>
<li><a href="#problem5-2">Problem5</a>
<ul>
<li><a href="#solution5-2">Solution5</a></li>
</ul></li>
</ul></li>
<li><a href="#2024图选">2024图选</a>
<ul>
<li><a href="#problem1-3">Problem1</a>
<ul>
<li><a href="#solution1-3">Solution1</a></li>
</ul></li>
<li><a href="#problem2-2">Problem2</a>
<ul>
<li><a href="#solution2-2">Solution2</a></li>
</ul></li>
<li><a href="#problem3-4">Problem3</a>
<ul>
<li><a href="#solution3-4">Solution3</a></li>
</ul></li>
<li><a href="#problem4-5">Problem4</a>
<ul>
<li><a href="#solution4-5">Solution4</a></li>
</ul></li>
<li><a href="#problem5-3">Problem5</a>
<ul>
<li><a href="#solution5-3">Solution5</a></li>
</ul></li>
</ul></li>
<li><a href="#2019茶选">2019茶选</a>
<ul>
<li><a href="#problem1-4">Problem1</a>
<ul>
<li><a href="#solution1-4">Solution1</a></li>
</ul></li>
<li><a href="#problem2-3">Problem2</a>
<ul>
<li><a href="#solution2-3">Solution2</a></li>
</ul></li>
<li><a href="#problem3-5">Problem3</a>
<ul>
<li><a href="#solution3-5">Solution3</a></li>
</ul></li>
<li><a href="#problem4-6">Problem4</a>
<ul>
<li><a href="#solution4-6">Solution4</a></li>
</ul></li>
<li><a href="#problem5-4">Problem5</a>
<ul>
<li><a href="#solution5-4">Solution5</a></li>
</ul></li>
</ul></li>
<li><a href="#2022茶选">2022茶选</a>
<ul>
<li><a href="#problem1-5">Problem1</a>
<ul>
<li><a href="#solution1-5">Solution1</a></li>
</ul></li>
<li><a href="#problem2-4">Problem2</a>
<ul>
<li><a href="#solution2-4">Solution2</a></li>
</ul></li>
<li><a href="#problem3-6">Problem3</a>
<ul>
<li><a href="#solution3-6">Solution3</a></li>
</ul></li>
<li><a href="#problem4-7">Problem4</a>
<ul>
<li><a href="#solution4-7">Solution4</a></li>
</ul></li>
<li><a href="#problem5-5">Problem5</a>
<ul>
<li><a href="#solution5-5">Solution5</a></li>
</ul></li>
<li><a href="#problem6">Problem6</a>
<ul>
<li><a href="#solution6">Solution6</a></li>
</ul></li>
</ul></li>
<li><a href="#2023茶选">2023茶选</a>
<ul>
<li><a href="#problem1-6">Problem1</a>
<ul>
<li><a href="#solution1-6">Solution1</a></li>
</ul></li>
<li><a href="#problem2-5">Problem2</a>
<ul>
<li><a href="#solution2-5">Solution2</a></li>
</ul></li>
<li><a href="#problem3-7">Problem3</a>
<ul>
<li><a href="#solution3-7">Solution3</a></li>
</ul></li>
<li><a href="#problem4-8">Problem4</a>
<ul>
<li><a href="#solution4-8">Solution4</a></li>
</ul></li>
<li><a href="#problem5-6">Problem5</a>
<ul>
<li><a href="#solution5-6">Solution5</a></li>
</ul></li>
</ul></li>
<li><a href="#2024茶选">2024茶选</a>
<ul>
<li><a href="#problem1-7">Problem1</a>
<ul>
<li><a href="#solution1-7">Solution1</a></li>
</ul></li>
<li><a href="#problem2-6">Problem2</a>
<ul>
<li><a href="#solution2-6">Solution2</a></li>
</ul></li>
<li><a href="#problem3-8">Problem3</a>
<ul>
<li><a href="#solution3-8">Solution3</a></li>
</ul></li>
<li><a href="#problem4-9">Problem4</a>
<ul>
<li><a href="#solution4-9">Solution4</a></li>
</ul></li>
<li><a href="#problem5-7">Problem5</a>
<ul>
<li><a href="#solution5-7">Solution5</a></li>
</ul></li>
<li><a href="#problem6-1">Problem6</a>
<ul>
<li><a href="#solution6-1">Solution6</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3>
<h4><span id="problem4">Problem4</span></h4>
<p>设<span class="math inline">\(G(x)=(x^2+x-1)^{100}=\sum_{k=0}^{200}a_kx^k\)</span>,求<span class="math inline">\(2a_0-a_1-a_2+2a_3-a_4-a_5+\cdots+2a_{198}-a_{199}-a_{200}\)</span>.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑求出<span class="math inline">\(\sum_{0\leq k\leq
66}{a_{3k}}\)</span>.直接取三次单位根<span class="math inline">\(\omega_3=-\frac{1}{2}+\frac{\sqrt
3}{2}i\)</span>,自然有<span class="math inline">\(1+\omega_3+\omega_3^2=0\)</span>,所以<span class="math inline">\(G(1)+G(\omega_3)+G(\omega_3^2)=3\sum_{0\leq k\leq
66}{a_{3k}}\)</span>.</p>
<p>所以答案显然是<span class="math inline">\(G(\omega_3)+G(\omega_3^2)=(-2)^{100}+(-2)^{100}=2^{101}\)</span>.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>等差数列中,<span class="math inline">\(a_1&gt;0\)</span>,公差<span class="math inline">\(d&lt;0,\frac{a_{31}}{a_{30}}&lt;-1\)</span>,求最大的正整数<span class="math inline">\(n\)</span>,使得<span class="math inline">\(S_n&gt;0\)</span>.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>显然<span class="math inline">\(S_{60}=30(a_{30}+a_{31})&lt;0,S_{59}=59a_{30}&gt;0\)</span>.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>全为整数的等差数列,<span class="math inline">\(d=4\)</span>,求所有满足<span class="math inline">\(S_n=2024\)</span>的<span class="math inline">\(n\)</span>的和.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>则<span class="math inline">\(n(2n-2+a_1)=2024=2^3\times 11\times
23\)</span>.显然只要<span class="math inline">\(n|2024\)</span>即可.</p>
<p>所有<span class="math inline">\(n\)</span>的和自然是<span class="math inline">\((1+2+4+8)(1+11)(1+23)=15\times 12\times
24=4320\)</span>.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>整数数列<span class="math inline">\(U_n\)</span>满足<span class="math inline">\(U_0=1\)</span>,且当<span class="math inline">\(n\geq 1\)</span>的时候<span class="math inline">\(U_{n+1}U_{n-1}=kU_n\)</span>,其中<span class="math inline">\(k\)</span>是一个正整数.问能让<span class="math inline">\(U_{N}=N\)</span>的<span class="math inline">\(k\)</span>的个数有多少个,其中<span class="math inline">\(N=2024\)</span>.</p>
<h5><span id="solution14">Solution14</span></h5>
<p>则<span class="math inline">\(U_{n+1}=\frac{kU_n}{U_{n-1}},\frac{U_{n+1}}{U_n}=k\frac{U_n}{U_{n-1}}\frac{1}{U_n}\)</span>.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设<span class="math inline">\(T_n=\prod_{k=1}^nU_k,W_n=U_n\prod_{k=1}^{n-2}U_k\)</span>.</p>
<p>注意到<span class="math inline">\(W_n=kW_{n-1},W_1=U_1,W_n=k^{n-1}U_1\)</span>.又注意到<span class="math inline">\(T_n=kU_{n-1}W_{n-1}=kW_{n-1}\frac{T_{n-1}}{T_{n-2}}=k^{n-1}U_1\frac{T_{n-1}}{T_{n-2}}=(k^{n-1}U_1)(k^{n-2}U_1)\frac{1}{T_{n-3}}\)</span>,<span class="math inline">\(T_{n-3}=(k^{n-4}U_1)(k^{n-5}U_1)\frac{1}{T_{n-6}}\)</span>.所以<span class="math inline">\(T_{n}=k^6T_{n-6}\)</span>,所以<span class="math inline">\(U\)</span>存在长度为<span class="math inline">\(6\)</span>的循环节.所以<span class="math inline">\(U_{N}=\frac{T_N}{T_{N-1}}=\frac{T_2}{T_1}=U_2=kU_1\)</span>.(其实直接暴力找循环节也是可以的)</p>
<p>所以<span class="math inline">\(k\)</span>需要是<span class="math inline">\(N\)</span>的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设<span class="math inline">\(w=U_1\)</span>,则<span class="math inline">\(U\)</span>的前六项是:<span class="math inline">\(1,w,kw,k^2,\frac{k^2}{w},\frac{k}{w}\)</span>.要求<span class="math inline">\(kw=N,w|k\)</span>,所以<span class="math inline">\((11\times 23)|k\)</span>,<span class="math inline">\(k\equiv 0\pmod 4\)</span>.所以<span class="math inline">\(k=4\times 11\times 23\)</span>或<span class="math inline">\(k=8\times 11\times 23\)</span>.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>求使方程<span class="math inline">\(\lfloor\frac{10^n}{x}\rfloor=N=2024\)</span>恰有两个整数解的正整数<span class="math inline">\(n\)</span>的个数.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>我们有: <span class="math display">\[
N\leq \frac{10^n}{x}&lt;N+1\\
xN\leq 10^n&lt;x(N+1)\\
\frac{10^n}{N+1}&lt;x\leq \frac{10^n}{N}\\
\lfloor\frac{10^n}{N+1}\rfloor&lt;x\leq \lfloor\frac{10^n}{N}\rfloor\\
\lfloor\frac{10^n}{N}\rfloor-\lfloor\frac{10^n}{N+1}\rfloor=2\\
\frac{10^n}{N(N+1)}-\frac{10^n\bmod N}{N}+\frac{10^n\bmod
{(N+1)}}{N+1}=2
\]</span> 显然<span class="math inline">\(\lfloor
\frac{10^n}{N(N+1)}\rfloor=1,2,3\)</span>.而<span class="math inline">\(N(N+1)=4098600\)</span>,所以只有<span class="math inline">\(n=7\)</span>可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是<span class="math inline">\(5\times 3!=30\)</span>.</p>
<h4><span id="problem19">Problem19</span></h4>
<p><span class="math inline">\(f(x)=\lfloor2x\rfloor+\lfloor4x\rfloor+\lfloor6x\rfloor+\lfloor8x\rfloor,x\in\mathbb{R}\)</span>,求其不超过<span class="math inline">\(n=2024\)</span>的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>显然<span class="math inline">\(f(x+1)=f(x)+20\)</span>,因此我们先考虑<span class="math inline">\(x\in [0,1)\)</span>的情况.</p>
<p>手动枚举一下知道此时<span class="math inline">\(f(x)\)</span>有<span class="math inline">\(12\)</span>种不同的取值,前六种是<span class="math inline">\(\{0,1,2,4,5,6\}\)</span>,后六种对应了前六种<span class="math inline">\(+10\)</span>.而<span class="math inline">\(2024=101\times 20+4\)</span>,所以共有<span class="math inline">\(101\times 12-1+4=1215\)</span>种取值.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>从<span class="math inline">\([1,n],n=2024\)</span>中分别独立随机两个正整数(可以相同)<span class="math inline">\(a,b\)</span>,则求<span class="math inline">\(3^a+7^b\equiv 8\pmod{10}\)</span>的概率.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>考虑<span class="math inline">\(\varphi(10)=4\)</span>,所以原题答案等价于<span class="math inline">\(n=4\)</span>的时候的答案.在这<span class="math inline">\(16\)</span>中可能性中满足条件的只有三种,概率为<span class="math inline">\(\frac{3}{16}\)</span>.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3>
<h4><span id="problem3">Problem3</span></h4>
<p>已知<span class="math inline">\(a_1=\frac{5}{2},a_{n+1}=a_n^2-2\)</span>,求<span class="math inline">\(\lfloor a_n\rfloor\bmod 7,n=2023\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>这个一看就不是好解的,想都别想直接数学归纳,注意到<span class="math inline">\(a_n=\frac{4^{2^{n-1}}+1}{2^{2^{n-1}}}\)</span>,那么<span class="math inline">\(\lfloor a_n\rfloor=2^{2^{n-1}}\)</span>.</p>
<p>而<span class="math inline">\(\varphi(7)=6,\varphi(6)=2\)</span>.由扩展欧拉定理,立刻有:<span class="math inline">\(2^{2^{2022}}\equiv 2^{2^{2022}\bmod 6}\equiv
2^{2^{6}}\equiv 16\equiv 2\pmod 7\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p><span class="math inline">\(50\)</span>个队伍两两打比赛,胜一场积分<span class="math inline">\(+1\)</span>,负一场积分不变,无平局.</p>
<p>且任取<span class="math inline">\(27\)</span>支队伍,其中一定有一支队伍负于其它的<span class="math inline">\(26\)</span>支,也一定有一支队伍胜于其它的<span class="math inline">\(26\)</span>支.</p>
<p>问<span class="math inline">\(50\)</span>支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>答案是<span class="math inline">\(50\)</span>.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都<span class="math inline">\(\leq
27\)</span>的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都<span class="math inline">\(&gt;27\)</span>,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为<span class="math inline">\(k\)</span>的简单环,由鸽笼原理,剩下的<span class="math inline">\(n-k\)</span>个点中至少有<span class="math inline">\(\frac{n-k}{2}\)</span>个点对着<span class="math inline">\(k\)</span>个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要<span class="math inline">\(k+\frac{n-k}{2}\geq 27\)</span>即可,此时<span class="math inline">\(k\geq
4\)</span>即可.由于这是竞赛图,显然存在长度为<span class="math inline">\(4\)</span>的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为<span class="math inline">\(u\)</span>.我们任意取一个击败过它的点(如果有的话),假设为<span class="math inline">\(v\)</span>,再取<span class="math inline">\(25\)</span>个被<span class="math inline">\(u\)</span>击败的点(显然这些点存在),设这些点集为<span class="math inline">\(S\)</span>.则<span class="math inline">\(u,v,S\)</span>组成的集合中,有一个点可以击败其它所有点,根据假设,只能是<span class="math inline">\(v\)</span>.由此,可以知道,只要是<span class="math inline">\(u\)</span>能击败的点,<span class="math inline">\(v\)</span>一定能击败,而且<span class="math inline">\(v\)</span>能击败<span class="math inline">\(u\)</span>,因此<span class="math inline">\(\deg_v&gt;\deg_u\)</span>,与假设不符.因此一定不存在一个<span class="math inline">\(v\)</span>可以击败<span class="math inline">\(u\)</span>.删掉<span class="math inline">\(u\)</span>后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>一只蚂蚁第一天在<span class="math inline">\((0,0)\)</span>,第<span class="math inline">\(k+1\)</span>天向上下左右随机一个方向移动<span class="math inline">\(\frac{1}{4^k}\)</span>单位,求第<span class="math inline">\(n\)</span>天的可能位置数量,<span class="math inline">\(n=2023\)</span>.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>不妨设第<span class="math inline">\(n\)</span>天不同位置数量为<span class="math inline">\(S_n\)</span>,显然只要前面岔开了,后面永远无法走到一个点.所以<span class="math inline">\(S_1=1,S_{n+1}=4S_n,S_{2023}=4^{2022}\)</span>.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>集合<span class="math inline">\(U=\{1,2,\cdots
,n\},n=10\)</span>,求<span class="math inline">\(U\)</span>中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>集合是无序的,这个很难搞,我们先从<span class="math inline">\(U\)</span>中把<span class="math inline">\(1\)</span>去掉最后再加上.</p>
<p>先考虑可以重复放<span class="math inline">\(1\)</span>的情况: <span class="math display">\[
\sum_{i=1}^n\sum_{j=1}^{n}\sum_{k=1}^{n}[\gcd(i,j)=1][\gcd(i,k)=1][\gcd(j,k)=1]\\
\]</span> 这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从<span class="math inline">\(1,3,5,7,9\)</span>中选,答案应该是<span class="math inline">\(1+2\binom{3}{2}=7\)</span>.</p>
<p>接下来考虑选一个偶数,如果选<span class="math inline">\(2,4,8\)</span>是等价的,答案此时是<span class="math inline">\(3(\binom{5}{2}-1)=27\)</span>.如果选<span class="math inline">\(6\)</span>的话答案是<span class="math inline">\(\binom{3}{2}=3\)</span>.如果选<span class="math inline">\(10\)</span>的话方案数是<span class="math inline">\(\binom{4}{2}-1=5\)</span>,加起来方案数是<span class="math inline">\(42\)</span>.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>集合<span class="math inline">\(U=\{1,2,\cdots,n\},n=366\)</span>,则<span class="math inline">\(U\)</span>的互不相交且各元素之和为<span class="math inline">\(17\)</span>的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5>
<p>考虑<span class="math inline">\(\lfloor\frac{366}{17}\rfloor=21,366\equiv 9\pmod
{17}\)</span>.答案显然是<span class="math inline">\(21\times
8+10+1=179\)</span>个.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>三个互不相同的数的<span class="math inline">\(\gcd=20,\text{lcm}=20000\)</span>,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然等价于<span class="math inline">\(\gcd=1,\text{lcm}=1000=2^3\times
5^3\)</span>.先只分析其中一个质因子,方案应该是<span class="math inline">\((0,0,3),(0,1,3),(0,2,3),(0,3,3)\)</span>,打乱一下顺序的话就共有<span class="math inline">\(3+6+6+3=18\)</span>种方案.如果可以重复,平方一下得到<span class="math inline">\(324\)</span>.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有<span class="math inline">\(2\times 2\times 3=12\)</span>种,于是答案为<span class="math inline">\(312\)</span>.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>求<span class="math inline">\(\lfloor\frac{k^2}{n}\rfloor,k\in[1,n],n=2023\)</span>种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5>
<p><span class="math display">\[
\lfloor\frac{k^2}{n}\rfloor=d\\
d\leq \frac{k^2}{n}&lt;d+1\\
nd\leq k^2&lt;n(d+1)
\]</span></p>
<p>由于两个完全平方数的差是固定的,不妨猜测存在一个<span class="math inline">\(k_0\)</span>,<span class="math inline">\(\leq
k_0\)</span>的<span class="math inline">\(k\)</span>会扎堆,但是这些<span class="math inline">\(d\)</span>全都能取到,<span class="math inline">\(&gt;k_0\)</span>的则不会有两个<span class="math inline">\(k\)</span>得到相同的元素.所以前者统计不同的<span class="math inline">\(d\)</span>,后者统计不同的<span class="math inline">\(k\)</span>考虑<span class="math inline">\((k+1)^2-k^2=2k+1\)</span>.分界线应该是<span class="math inline">\(k_0=1011\)</span>.</p>
<p>所以答案应该是<span class="math inline">\(n-k_0+\lfloor\frac{k_0^2}{2k_0+1}\rfloor+1=1012+506=1518\)</span>.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>对四元组<span class="math inline">\((a,b,c,d)\)</span>计数,满足<span class="math inline">\(101|(a+b+c+d)\)</span>且<span class="math inline">\(0&lt;a&lt;b&lt;c&lt;d\leq 101\)</span>.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>这题真的厉害啊.</p>
<p>不妨设<span class="math inline">\(S_k\)</span>为满足<span class="math inline">\((a+b+c+d)\equiv k\pmod {101}\)</span>的满足<span class="math inline">\(0&lt;a&lt;b&lt;c&lt;d\leq
101\)</span>的四元组数量.不难发现<span class="math inline">\(\sum
S_k=\binom{101}{4}\)</span>.</p>
<p>注意到<span class="math inline">\((a,b,c,d)\mapsto
(a+1,b+1,c+1,d+1)\)</span>,注意这里是<span class="math inline">\(\pmod
{101}\)</span>意义下的加法,这是一个双射,所以<span class="math inline">\(S_{k}=S_{k+4}\)</span>,下标同样也是<span class="math inline">\(\pmod {101}\)</span>意义下进行的.又因为<span class="math inline">\(\gcd(101,4)=1\)</span>,所以所有的<span class="math inline">\(S_k\)</span>均相等.<span class="math inline">\(S_0=\frac{\binom{101}{4}}{101}=40425\)</span>.</p>
<h4><span id="problem16">Problem16</span></h4>
<p>问方程<span class="math inline">\(x\lfloor
x\rfloor=6\)</span>的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5>
<p><span class="math inline">\(6=x\lfloor x\rfloor\geq \lfloor
x\rfloor^2\)</span>,所以<span class="math inline">\(\lfloor x\rfloor=\pm
1,\pm 2\)</span>.显然都不可以.所以个数为<span class="math inline">\(0\)</span>.</p>
<h4><span id="problem17">Problem17</span></h4>
<p>设<span class="math inline">\(R(n)=\sum_{k=2}^{10}(n\bmod
k)\)</span>,求满足<span class="math inline">\(R(n)=R(n+1)\)</span>的十进制下的两位数<span class="math inline">\(n\)</span>的个数.</p>
<h5><span id="solution17">Solution17</span></h5>
<p>从<span class="math inline">\(R(n)\)</span>到<span class="math inline">\(R(n+1)\)</span>,应该是加了若干个<span class="math inline">\(1\)</span>,然后又丢了几个<span class="math inline">\(k-1\)</span>这样的.那就一定需要丢掉的数字之和为<span class="math inline">\(9\)</span>.枚举一下,丢了的只有可能是以下情况:<span class="math inline">\((9),(7+2),(6+3),(5+4),(4+3+2)\)</span>,分别对应了<span class="math inline">\(n+1\)</span>应该是分别以下数的倍数<span class="math inline">\((9),(14),(6),(20),(12)\)</span>,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:<span class="math inline">\((7+2)\)</span>,并且分别不能是以下数字的倍数<span class="math inline">\((3,4,5)\)</span>.</p>
<p>取一下的话<span class="math inline">\(n+1\)</span>可以是:<span class="math inline">\(14,98\)</span>,<span class="math inline">\(n=13,97\)</span>,验证一下均合法,所以答案为<span class="math inline">\(2\)</span>.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>已知<span class="math inline">\(a&lt;b&lt;c&lt;d\)</span>,而<span class="math inline">\(x,y,z,w\)</span>是<span class="math inline">\(a,b,c,d\)</span>的一个排列,求<span class="math inline">\((x-y)^2+(y-z)^2+(z-w)^2+(w-x)^2\)</span>得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>圆排列个数是<span class="math inline">\(3!=6\)</span>个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是<span class="math inline">\((x,y,z,w),(x,z,w,y),(x,w,y,z)\)</span>.</p>
<p>考虑: <span class="math display">\[
(x-y)^2+(y-z)^2+(z-w)^2+(w-x)^2\\
=2(x^2+z^2+y^2+w^2)-2(xy+yz+zw+wx)
\]</span> 显然只要<span class="math inline">\(xy+yz+zw+wx\)</span>不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>已知<span class="math inline">\(0&lt;x_1&lt;x_2&lt;\cdots
&lt;x_9\)</span>且<span class="math inline">\(\sum_{k=1}^9
x_k=220\)</span>,在<span class="math inline">\(\sum_{k=1}^5x_k\)</span>最大的前提下,最小化<span class="math inline">\(x_9-x_1\)</span>.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>不妨枚举一下<span class="math inline">\(x_5\)</span>选啥,设<span class="math inline">\(f(S,m,k)\)</span>表示选出<span class="math inline">\(k\)</span>个互不相同的数,使得它们<span class="math inline">\(\leq m\)</span>且总和为<span class="math inline">\(S\)</span>,是否可行.不难发现<span class="math inline">\(f(S,m,k)=[\frac{k(k+1)}{2}\leq S\leq
\frac{k(2m-k+1)}{2}]\)</span>.</p>
<p>那我们要求的就是: <span class="math display">\[
\max_{5\leq x_5}\{S|f(220-4x_5-S,+\infty,4)=1\and f(S-x_5,x_5-1,4)=1\}\\
=\max_{5\leq x_5}\{S|4x_5+S\leq 210\and 10+x_5\leq S\leq 5x_5-10\}\\
=\max_{5\leq x_5}(\min\{5x_5-10,210-4x_5\})
\]</span> 立刻得到<span class="math inline">\(x_5=24,25,S=110\)</span>,那么后面的选法就一定了,后面四个数一定是<span class="math inline">\(26,27,28,29\)</span>,只需要让<span class="math inline">\(x_1\)</span>最大即可</p>
<p><span class="math inline">\(x_5=24\)</span>时,此时最优显然是<span class="math inline">\(20,21,22,23,24,26,27,28,29\)</span>,<span class="math inline">\(x_9-x_1=9\)</span>.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>有一个<span class="math inline">\(n\)</span>边形,其中有<span class="math inline">\(\binom{n}{2}\)</span>条对角线,不存在三线交于一点的情况,问这些对角线将该<span class="math inline">\(n\)</span>边形分成了多少个部分.<span class="math inline">\(n=10\)</span>.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了<span class="math inline">\(\binom{n}{4}\)</span>个点(任意四个点有且只有一种交法),每交一个点就会多出<span class="math inline">\(2\)</span>条边,所以多出来了<span class="math inline">\(2\binom{n}{4}+\frac{n(n-3)}{2}\)</span>条边.</p>
<p>考虑内部的若干个部分一定是<span class="math inline">\(a_3\)</span>个三角形,<span class="math inline">\(a_4\)</span>个四边形,…,<span class="math inline">\(a_k\)</span>个<span class="math inline">\(k\)</span>边形,总之我们发现: <span class="math display">\[
\begin{cases}
\sum_{j=3}^k(j-2)\pi a_j=(n-2)\pi+2\pi\binom{n}{4}\\
\sum_{j=3}^kja_j=n+4\binom{n}{4}+n(n-3)
\end{cases}
\]</span> 两式得到:<span class="math inline">\(\sum_{j=3}^ka_j=\frac{(n-1)(n-2)}{2}+\binom{n}{4}\)</span>.</p>
<p><span class="math inline">\(n=10\)</span>的时候,答案为<span class="math inline">\(246\)</span>.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求<span class="math inline">\(\sum_{i=1}^n\lfloor\frac{19^i}{20}\rfloor\bmod
7,n=2024\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p><span class="math display">\[
\sum_{i=1}^n\lfloor\frac{19^i}{20}\rfloor\\
=\sum_{i=1}^n\lfloor\frac{\sum_{k=0}^i20^k(-1)^{i-k}\binom{i}{k}}{20}\rfloor\\
=-\lfloor\frac{n}{2}\rfloor+\sum_{i=1}^{n}\frac{19^i-(-1)^i}{20}\\
=-\lfloor\frac{n}{2}\rfloor+\frac{\frac{19}{18}(19^n-1)-(\frac{(-1)^n-1}{2})}{20}
\]</span></p>
<p>带入<span class="math inline">\(n=2024\)</span>并<span class="math inline">\(\bmod 7\)</span>,原式为: <span class="math display">\[
\equiv -4+\frac{5}{4}(1-5^n)
\equiv -4+3(1-5^n)
\]</span> 注意到<span class="math inline">\(2024\bmod
6=2\)</span>,原式<span class="math inline">\(\equiv -4-9\equiv
1\)</span>.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>求长度为<span class="math inline">\(n\)</span>的排列个数,使得排列中<span class="math inline">\(\nexists i\in[1,n-1],a_i=a_{i+1}-1\)</span>.<span class="math inline">\(n=8\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>一眼容斥,也就是每个长度为<span class="math inline">\(k\)</span>的连续段的容斥系数应该是<span class="math inline">\((-1)^{k-1}\)</span>.那么设分成了<span class="math inline">\(w\)</span>个段,总的容斥系数应该是<span class="math inline">\((-1)^{n-w}\)</span>,答案就是<span class="math inline">\(f_{n&#39;}=\sum_{w=1}^n(-1)^{n-w}w!\binom{n-1}{w-1}=\sum_{w=0}^{n&#39;}(-1)^{n&#39;-w}\binom{n&#39;}{w}(w+1)!=n&#39;!\sum_{w=0}^{n&#39;}\frac{(-1)^w}{w!}(n&#39;-w+1)\)</span>,此时已经能算出答案是<span class="math inline">\(16687\)</span>.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设<span class="math inline">\(g_n\)</span>为错排数量,显然有<span class="math inline">\(f_{n}=nf_{n-1}+g_{n}\)</span>,立刻算出答案是<span class="math inline">\(16687\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>已知数列<span class="math inline">\(1,2,2,3,3,3,4,4,4,4,\cdots\)</span>,求其第<span class="math inline">\(n\)</span>项<span class="math inline">\(\bmod
5\)</span>的值,<span class="math inline">\(n=2024\)</span>.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑第一个值为<span class="math inline">\(k\)</span>的地方应该在哪里.显然<span class="math inline">\(a_{\frac{k(k-1)}{2}+1}=k\)</span>.注意到<span class="math inline">\(a_{2081}=65\)</span>,所以<span class="math inline">\(a_n=64\)</span>,其<span class="math inline">\(\bmod 5=4\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>求四元组<span class="math inline">\((a_1,a_2,a_3,a_4)\)</span>的个数,满足<span class="math inline">\(a_1,a_2,a_3,a_4\in\{1,2,3\}\)</span>,且<span class="math inline">\(10&lt;a_1a_2a_3a_4&lt;20\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>排个序按照字典序开搜,只有三种可能:<span class="math inline">\(\{3,3,2,1\},\{3,2,2,1\},\{2,2,2,2\}\)</span>,打乱顺序的话就有<span class="math inline">\(25\)</span>种可能.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>求<span class="math inline">\(\mathbb{R}\)</span>上方程<span class="math inline">\(x^2-13\lfloor
x\rfloor+11=0\)</span>的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>首先注意到<span class="math inline">\(\lfloor
x\rfloor=\frac{x^2+11}{13}\)</span>,那么自然有方程组: <span class="math display">\[
\begin{cases}\frac{x^2+11}{13}\leq
x\\x&lt;\frac{x^2+11}{13}+1\end{cases}
\]</span> 只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑<span class="math inline">\(x^2\equiv 2\pmod
{13}\)</span>这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设<span class="math inline">\(x=\sqrt{2+13k}\)</span>的形式,带入有不等式: <span class="math display">\[
k-x+1\leq 0&lt;k-x+2\\
1\leq \sqrt{2+13k}-k&lt;2\\
\begin{cases}0&lt;k^2-9k+2\\k^2-11k-1\leq 0\end{cases}
\]</span> 冷静一下!注意到<span class="math inline">\(0\leq k\leq
13\)</span>,又根据第一个不等式得知大部分<span class="math inline">\(k\)</span>应该会很大,开始暴力枚举一下,合法的情况有:<span class="math inline">\(k=0,9,10,11\)</span>,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4>
<p>在一个体积为<span class="math inline">\(1\)</span>的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积<span class="math inline">\(\leq \frac{1}{8}\)</span>的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5>
<p>原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积<span class="math inline">\(\leq \frac{1}{8}\)</span>.考虑设这个点是<span class="math inline">\((x,x,h)\)</span>,那么必然有<span class="math inline">\(\begin{cases}(1-h)x^2&gt;\frac{1}{8}\\h(1-x)^2&gt;\frac{1}{8}\end{cases}\)</span>,化简,只要<span class="math inline">\(8&gt;\frac{1}{x^2}+\frac{1}{(1-x)^2}\)</span>即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取<span class="math inline">\((0.5,0.5,0.1)\)</span>即可.那么是不是可以证明答案一定<span class="math inline">\(&gt;3\)</span>呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积<span class="math inline">\(\leq
\frac{1}{8}\)</span>的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为<span class="math inline">\((x,y,h),x,y,h\leq
\frac{1}{2}\)</span>,然后证明<span class="math inline">\(8&gt;\frac{1}{xy}+\frac{1}{(1-x)(1-y)},x,y\leq
\frac{1}{2}\)</span>这个不等式无解即可.</p>
<p>由基本不等式,<span class="math inline">\(\frac{1}{xy}+\frac{1}{(1-x)(1-y)}\geq
2\sqrt{\frac{1}{x(1-x)y(1-y)}}\geq 2\sqrt{4\times
4}=8\)</span>,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>设<span class="math inline">\(S(n)\)</span>表示正整数<span class="math inline">\(n\)</span>的十进制数码和,求满足<span class="math inline">\(S(n)\equiv S(n+1)\equiv 0\pmod
5\)</span>的最小的<span class="math inline">\(n\)</span>.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>显然必须发生进位,不妨设<span class="math inline">\(n=10^ka+10^k-1\)</span>,<span class="math inline">\(a\ne 9\pmod {10}\)</span>,<span class="math inline">\(S(n)=S(a)+9k,S(n+1)=S(a)+1\)</span>,</p>
<p>此时显然有<span class="math inline">\(9k-1\equiv 0\pmod
5\)</span>,<span class="math inline">\(k\equiv 4\pmod 5\)</span>.<span class="math inline">\(n_{\min}=49999\)</span>.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>求满足以下条件的最大的正整数<span class="math inline">\(n\)</span>:十进制下每一位数字互不相同,且<span class="math inline">\(\forall m,10^m\leq
n,\lfloor\frac{n}{10^m}\rfloor|n\)</span>.</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是<span class="math inline">\(0\)</span>.</p>
<p>不妨设其为<span class="math inline">\(\overline{ab}\)</span>,其中<span class="math inline">\(b=10c\)</span>,<span class="math inline">\(a\)</span>是<span class="math inline">\(b\)</span>的因子,不妨枚举一下<span class="math inline">\(k=\frac{b}{a}\)</span>.注意到因为<span class="math inline">\(a\)</span>中不能有<span class="math inline">\(0\)</span>,所以<span class="math inline">\(k\in\{2,4,5,8\}\)</span>.取<span class="math inline">\(k=2\)</span>试出来<span class="math inline">\(3570\)</span>是合法的,而且显然<span class="math inline">\(k\in\{4,5,8\}\)</span>的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4>
<p><span class="math inline">\(a_1=\sqrt 2,a_{n+1}=\lfloor
a_n\rfloor+\frac{1}{a_n-\lfloor a_n\rfloor}\)</span>,求<span class="math inline">\(\sum_{k=1}^{n}a_k,n=2024\)</span>.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>这一看就是个环,设<span class="math inline">\(a_n=b_n+c_n\sqrt
2\)</span>.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到: <span class="math display">\[
\begin{cases}a_1=0+\sqrt 2\\a_2=2+\sqrt 2\\a_3=4+\sqrt
2\\\cdots\end{cases}
\]</span> 容易猜测<span class="math inline">\(b_n=2(n-1),c_n=1\)</span>.也就是<span class="math inline">\(a_n=2(n-1)+\sqrt 2\)</span>,数学归纳一下即可.</p>
<p>那么<span class="math inline">\(\sum_{k=1}^na_k=n(n-1)+n\sqrt
2\)</span>,带入<span class="math inline">\(n=2024\)</span>即可.</p>
<h3><span id="2022图选">2022图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol type="1">
<li>任意两个正方形至多有一个顶点重合</li>
<li>每个正方形的每个顶点都与其他某个正方形的顶点重合</li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol type="1">
<li>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</li>
<li>边可以相交,放到正十二边形的边上.</li>
</ol>
<h4><span id="problem2">Problem2</span></h4>
<p>求<span class="math inline">\(\lfloor(\frac{1+\sqrt
5}{2})^{12}\rfloor\)</span>.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>考虑<span class="math inline">\((\frac{1+\sqrt 5}{2})^3=2+\sqrt
5\)</span>,<span class="math inline">\(\lfloor(\frac{1+\sqrt
5}{2})^{12}\rfloor=161+\lfloor72\sqrt 5\rfloor=321\)</span>.</p>
<p>也可以考虑类似斐波那契数列,取<span class="math inline">\(f_n=(\frac{1+\sqrt 5}{2})^{n}+(\frac{1-\sqrt
5}{2})^{n}\)</span>,其满足<span class="math inline">\(f_n=f_{n-1}+f_{n-2},f_0=2,f_1=1\)</span>,取<span class="math inline">\(f_{12}-1\)</span>就是答案<span class="math inline">\(321\)</span>.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于一个加法乘法环,要求你利用:</p>
<ol type="1">
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p></li>
<li><p>加法结合律、逆元.</p></li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>倒反天罡题.</p>
<p>注意到<span class="math inline">\((a+1)(b+1)=(b+1)(a+1)\)</span>,所以<span class="math inline">\(a+b=b+a\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你<span class="math inline">\(n\)</span>个数集<span class="math inline">\(a_i\)</span>,其中<span class="math inline">\(|a_i|=i+1\)</span>,要你选出<span class="math inline">\(n\)</span>个两两不同的数字满足<span class="math inline">\(x_i\in a_i\)</span>,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是<span class="math inline">\(2^n\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice和Bob博弈.Alice先选一个数<span class="math inline">\(m\)</span>,然后Bob选一个数<span class="math inline">\(n(n&gt;m)\)</span>,并构造一个<span class="math inline">\(n\)</span>个点的竞赛图.Alice如果能从中选出<span class="math inline">\(m\)</span>个不同的点,满足不存在某个点<span class="math inline">\(x\)</span>到这<span class="math inline">\(m\)</span>个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是<span class="math inline">\((1-\frac{1}{2^m})^{n-2}\)</span>,因此期望为<span class="math inline">\(E=\binom{n}{m}(1-\frac{1}{2^m})^{n-2}\)</span>,只需<span class="math inline">\(n\)</span>足够大的时候期望<span class="math inline">\(&lt;1\)</span>,则说明一定存在<span class="math inline">\(0\)</span>,也就是Bob总有必胜策略.</p>
<p>注意到只需证明<span class="math inline">\(\exists n\)</span>,<span class="math inline">\(\binom{n}{m}&lt;(\frac{2^m}{2^m-1})^{n-2}\)</span>,而<span class="math inline">\(\binom{n}{m}=\frac{n^{\underline{m}}}{m!}&lt;n^m\)</span>.下面证明<span class="math inline">\(\exists
n,n^m&lt;(\frac{2^m}{2^m-1})^{n-2}\)</span>.</p>
<p>两边取<span class="math inline">\(\ln\)</span>,不妨假设<span class="math inline">\(n\geq 3\)</span>,有<span class="math inline">\(m\ln
n&lt;(n-2)\ln(\frac{2^m}{2^m-1}),\frac{m}{\ln(\frac{2^m}{2^m-1})}&lt;\frac{n-2}{\ln
n}\)</span>,<span class="math inline">\(\frac{n-2}{\ln
n}\)</span>显然在<span class="math inline">\(n\geq
3\)</span>的时候单增,所以一定存在这么一个<span class="math inline">\(n\)</span>.</p>
<h3><span id="2023图选">2023图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>求正整数拆分成有序的<span class="math inline">\(1,2\)</span>序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>定义<span class="math inline">\(*\)</span>为集合<span class="math inline">\(G\)</span>上的二元运算,已知:</p>
<ol type="1">
<li>满足结合律<span class="math inline">\(a∗b∗c=a∗(b∗c)\)</span>.</li>
<li>存在左单位元<span class="math inline">\(e\)</span>,对任意<span class="math inline">\(a\)</span>满足<span class="math inline">\(e∗a=a\)</span>.</li>
<li>对任意<span class="math inline">\(a\)</span>存在左逆元<span class="math inline">\(b\)</span>,使<span class="math inline">\(b∗a=e\)</span>.</li>
</ol>
<p>问:</p>
<ol type="1">
<li>左单位元是否也为右单位元.</li>
<li>左逆元是否也为右逆元.</li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>看(2),考虑设<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的左逆元,<span class="math inline">\(c\)</span>是<span class="math inline">\(b\)</span>的左逆元,则<span class="math inline">\(cba=ce=a,ab=ceb=e\)</span>.</p>
<p>看(1),设<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的逆元,<span class="math inline">\(ea=aba=ae\)</span>,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明<span class="math inline">\(ab\)</span>的时候<span class="math inline">\(b\)</span>不能彻底损失信息,而观察<span class="math inline">\(ab=eab\)</span>知道<span class="math inline">\(a\)</span>也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算<span class="math inline">\((a_1,b_1)(a_2,b_2)\)</span>,想办法让其损失掉<span class="math inline">\((a_1,b_1)\)</span>中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到<span class="math inline">\((a_1,b_1)(a_2,b_2)=(a_1+a_2,b_2)\)</span>即可,存在左幺元为<span class="math inline">\((0,0)\)</span>,右逆元为<span class="math inline">\((-a,0)\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p><span class="math inline">\(f\)</span>的定义域和值域都是正整数并且<span class="math inline">\(f(xy)=f(x)+f(y)-1\)</span>,求:</p>
<ol type="1">
<li>是否存在这样的函数.</li>
<li>是否存在无数个这样的函数.</li>
<li>是否存在严格递增的函数.</li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>令<span class="math inline">\(g(x)=f(x)-1\)</span>,则<span class="math inline">\(g(xy)=g(x)+g(y)\)</span>.</p>
<p>对于(1),取<span class="math inline">\(g(x)=0,f(x)=1\)</span>即可.</p>
<p>对于(2),考虑<span class="math inline">\(g(p^k)=kg(p)\)</span>,只需要让<span class="math inline">\(g(p)\)</span>取不同的值即可.</p>
<p>对于(3),考虑<span class="math inline">\(g(2^a)=ag(2)\)</span>,<span class="math inline">\(g(3^b)=bg(3)\)</span>.</p>
<p>考虑构造<span class="math inline">\(a,b\)</span>,使得<span class="math inline">\(2^a&lt;3^b\)</span>但是<span class="math inline">\(ag(2)\geq bg(3)\)</span>.不妨取<span class="math inline">\(a=\lceil\frac{bg(3)}{g(2)}\rceil\)</span>,那么必定有:
<span class="math display">\[
2^{\lceil\frac{bg(3)}{g(2)}\rceil}&lt;3^b\\
\lceil\frac{bg(3)}{g(2)}\rceil&lt;b\log_23\\
\frac{bg(3)}{g(2)}+\Delta\leq b\log_23\\
\]</span> 于是如果存在,必定需要<span class="math inline">\(\frac{g(p_1)}{g(p_2)}\geq \log_{p_2}p_1\and
\frac{g(p_2)}{g(p_1)}\geq \log_{p_1}p_2\)</span>,也就是<span class="math inline">\(\frac{g(p_2)}{g(p_1)}=\log_{p_1}p_2\)</span>.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于任意<span class="math inline">\(2n-1\)</span>个正整数(可重复),问其中是否一定有<span class="math inline">\(n\)</span>个数的和能被<span class="math inline">\(n\)</span>整除,这题<span class="math inline">\(n=50\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑当<span class="math inline">\(n\)</span>是合数的时候,设<span class="math inline">\(n=pq\)</span>,则可以将其拆成<span class="math inline">\(q-1\)</span>组每组<span class="math inline">\(2p\)</span>个数以及一组<span class="math inline">\(2p-1\)</span>个数,因此只需要这些都可以找到<span class="math inline">\(p\)</span>个数使得其是<span class="math inline">\(p\)</span>的倍数,组合起来就行了.</p>
<p>只需要解决<span class="math inline">\(n\)</span>是质数的情况.</p>
<p>感觉场上的最优解应该是解决<span class="math inline">\(n=2\)</span>和<span class="math inline">\(n=5\)</span>的情况然后拼成<span class="math inline">\(n=50\)</span>.</p>
<p><span class="math inline">\(n=2\)</span>的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然<span class="math inline">\(S=\sum_{}(x_{p_1}+x_{p_2}+\cdots+x_{p_n})^{p-1}\equiv
\binom{2n-1}{n}\equiv 1\pmod n\)</span>.</p>
<p>但是考虑左边那个多项式的每一项,形如<span class="math inline">\(c\prod_{i=1}^kx_{p_i}^{e_i}\)</span>.注意到<span class="math inline">\(c\)</span>一定是<span class="math inline">\(\binom{2n-1-k}{n-k}\)</span>的倍数,而后者<span class="math inline">\(\bmod n\)</span>为<span class="math inline">\(0\)</span>.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为<span class="math inline">\(1\)</span>并不是对称的,而左边是个对称式子,某个<span class="math inline">\(x\)</span>增大也无所谓,这意味着左边应该是为<span class="math inline">\(0\)</span>的,我们要做的就是去证明它是<span class="math inline">\(0\)</span>.</p>
<h3><span id="2024图选">2024图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问在双曲线<span class="math inline">\(xy=1\)</span>上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>不会做,取个特殊值知道答案应该是<span class="math inline">\([2\sqrt
6,+\infty)\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol type="1">
<li>如果<span class="math inline">\(n,m\)</span>都是好的,那么<span class="math inline">\(nm\)</span>是好的.</li>
<li><span class="math inline">\(2024\)</span>不是好的.</li>
</ol>
<h5><span id="solution2">Solution2</span></h5>
<p>如果<span class="math inline">\(n=a^2+b^2,m=c^2+d^2\)</span>,那么<span class="math inline">\(nm=a^2c^2+a^2d^2+b^2c^2+b^2d^2=(ac-bd)^2+(ad+bc)^2\)</span>.</p>
<p><span class="math inline">\(2024=2^3\times 11\times
23\)</span>,使用反证法,不妨设其可以被表示为<span class="math inline">\(a^2+b^2\)</span>.</p>
<p>讨论一下:如果<span class="math inline">\(a,b\)</span>均为奇数,那么<span class="math inline">\(a^2+b^2\equiv 2\pmod 8\)</span>,不符题意.</p>
<p>于是<span class="math inline">\(a,b\)</span>应该均为偶数,那么就有<span class="math inline">\(a&#39;^2+b&#39;^2=506\)</span>.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于集合<span class="math inline">\(G\)</span>,<span class="math inline">\(e\in G\)</span>,定义域为<span class="math inline">\(G\)</span>的函数<span class="math inline">\(f\)</span>满足以下性质:</p>
<ol type="1">
<li><span class="math inline">\(e\in G\)</span>,但<span class="math inline">\(e\)</span>不在<span class="math inline">\(f\)</span>的值域中.</li>
<li><span class="math inline">\(G\)</span>关于<span class="math inline">\(f\)</span>封闭.</li>
<li>若<span class="math inline">\(\exists A\subseteq G\)</span>,<span class="math inline">\(e\in A\)</span>且<span class="math inline">\(A\)</span>对<span class="math inline">\(f\)</span>封闭,则<span class="math inline">\(A=G\)</span>.</li>
</ol>
<p>在<span class="math inline">\(G\)</span>上定义二元运算<span class="math inline">\(\circ\)</span>,满足<span class="math inline">\(ae=a,af(b)=f(ab)\)</span>.</p>
<p>求证:</p>
<ol type="1">
<li>存在幺元.</li>
<li>运算满足交换律.</li>
<li>运算满足结合律.</li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往<span class="math inline">\(A\)</span>里面扔个<span class="math inline">\(e\)</span>,此时<span class="math inline">\(A\)</span>一定不满足条件.我们不断从<span class="math inline">\(A\)</span>中选出一个元素<span class="math inline">\(w\)</span>满足<span class="math inline">\(f(w)\notin A\)</span>,并把<span class="math inline">\(A:=A\cup
\{f(w)\}\)</span>.不断做这个过程显然最后会得到<span class="math inline">\(G\)</span>,这意味着任何一个元素<span class="math inline">\(a\)</span>可以写成<span class="math inline">\(f(f(f\cdots f(e)))\)</span>的形式.</p>
<p>不妨将<span class="math inline">\(f\)</span>函数嵌套<span class="math inline">\(k\)</span>次记作<span class="math inline">\(f^{(k)}\)</span>,那么我们要证明的是<span class="math inline">\(a=f^{(A)}(e),b=f^{(B)}(e)\)</span>,<span class="math inline">\(ab=ba\)</span>.</p>
<p>考虑<span class="math inline">\(ab=f^{(A)}(e)f^{(B)}(e)=f^{(B)}(f^{(A)}(e)e)=f^{(A+B)}(e)\)</span>,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给出一个具体函数满足:</p>
<ol type="1">
<li><span class="math inline">\(f(x+y)=f(x)+f(y)+xy\)</span>.</li>
<li><span class="math inline">\(f(xy)=f(x)f(y)+f(x-1)f(y-1)\)</span>.</li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>先注意到<span class="math inline">\(f(0)=0,f(1)=1\)</span>.</p>
<p>以<span class="math inline">\(x\)</span>为主元两边求导,立刻得到<span class="math inline">\(f&#39;(x+y)=f&#39;(x)+y\)</span>,因此<span class="math inline">\(f&#39;(x)\)</span>是斜率为<span class="math inline">\(1\)</span>的一次函数,立刻得到<span class="math inline">\(f(x)=\frac{x^2}{2}+\frac{x}{2}\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于<span class="math inline">\(r=\sqrt
2\)</span>,是否存在正整数<span class="math inline">\(p\)</span>和整数<span class="math inline">\(q\)</span>满足<span class="math inline">\(|pr-q|&lt;\frac{1}{2024}\)</span>且<span class="math inline">\(p&lt;2024\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑取<span class="math inline">\(0,\sqrt 2,2\sqrt 2,3\sqrt 2,\cdots
2023\sqrt 2\)</span>的小数部分,记作<span class="math inline">\(a_0,a_1,\cdots a_{2023}\)</span>.</p>
<p>由鸽笼原理,一定存在两个数<span class="math inline">\(0\leq x&lt;y\leq
2023\)</span>满足<span class="math inline">\(|a_x-a_y|&lt;\frac{1}{2024}\)</span>,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>在一个数轴上,你站在<span class="math inline">\(0\)</span>点,并按照如下算法寻找<span class="math inline">\(x(x&gt;0)\)</span>点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">    沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">    如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. <span class="math inline">\(3x\)</span> B. <span class="math inline">\(5x\)</span> C. <span class="math inline">\(7x\)</span> D. <span class="math inline">\(9x\)</span> E. 以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>考虑找到牛的时候<span class="math inline">\(step\)</span>为多少,应该为<span class="math inline">\(2^{2k}\)</span>,其中<span class="math inline">\(k\)</span>满足<span class="math inline">\(2^{2k}\geq
x&gt;2^{2(k-1)}\)</span>.此时走的步数应该是<span class="math inline">\(ans=2\sum_{i=0}^{2k-1}2^i+x=2^{2k+1}-1+x\)</span>步.而<span class="math inline">\(x\leq 2^{2k}&lt;4x\)</span>,所以<span class="math inline">\(ans&lt;9x-1\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定<span class="math inline">\(10\)</span>个实数变量<span class="math inline">\(x_1,\cdots,x_{10}\)</span>,满足它们均<span class="math inline">\(\geq 1\)</span>且两两不同.你要寻找一组<span class="math inline">\(\{x\}\)</span>和一个实数<span class="math inline">\(a\)</span>,使得存在尽可能多组<span class="math inline">\(\langle b\rangle,b_i=\pm 1\)</span>,满足<span class="math inline">\(\sum_{i=1}^{10}b_ix_i\in (a,a+2)\)</span>.</p>
<p>最多存在多少组<span class="math inline">\(\langle
b\rangle\)</span>?</p>
<p>A. <span class="math inline">\(512\)</span> B. <span class="math inline">\(252\)</span> C. <span class="math inline">\(504\)</span> D. <span class="math inline">\(684\)</span> E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>不妨猜测<span class="math inline">\(x\)</span>全取<span class="math inline">\(1\)</span>最优,此时的答案是<span class="math inline">\(\binom{10}{5}=252\)</span>.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于<span class="math inline">\(x\geq 1\)</span>,所以如果存在两组$b<span class="math inline">\(,使得\)</span>A<span class="math inline">\(组中选择取\)</span>+1<span class="math inline">\(恰好是\)</span>B<span class="math inline">\(组的子集,那么\)</span>S_AS_B-2$,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让<span class="math inline">\(x\)</span>尽可能接近<span class="math inline">\(1\)</span>,这样就是满足条件的.所以问题变为对于一个大小为<span class="math inline">\(10\)</span>的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取<span class="math inline">\(\binom{10}{5}\)</span>最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给定无向图<span class="math inline">\(G=(V,E)\)</span>,我们称一个图是好的,如果:</p>
<ol type="1">
<li>每个点的度数均为<span class="math inline">\(d\)</span>.</li>
<li>任何一个大小不超过<span class="math inline">\(\frac{|V|}{2}\)</span>的联通集合<span class="math inline">\(S\)</span>,其邻居(不属于<span class="math inline">\(S\)</span>但和<span class="math inline">\(S\)</span>中的某个点存在直接相连的边)的大小<span class="math inline">\(\geq \frac{5}{4}|S|\)</span>.</li>
</ol>
<p>求证:好的图中任意两个点<span class="math inline">\(u,v\)</span>之间的最短路径长度<span class="math inline">\(dis(u,v)=O(\log |V|)\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑以<span class="math inline">\(u\)</span>为起点一点一点往外扩张,这样一直扩张到<span class="math inline">\(\frac{|V|}{2}+1\)</span>时,集合中每个点到<span class="math inline">\(u\)</span>的距离不超过<span class="math inline">\(O(\log |V|)\)</span>.</p>
<p>然后以<span class="math inline">\(v\)</span>做同样的事,由于这两个集合大小之和大于<span class="math inline">\(|V|\)</span>,说明一定有交,且存在一条路径长度为<span class="math inline">\(O(\log
|V|)\)</span>的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你两个完全相同的鸡蛋和一个<span class="math inline">\(n=100\)</span>层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有<span class="math inline">\(101\)</span>个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设<span class="math inline">\(f_{i,1/2}\)</span>表示一棵有<span class="math inline">\(i\)</span>个叶子的树,最多向右走<span class="math inline">\(1/2\)</span>步,深度最低为多少.显然<span class="math inline">\(f_{i,1}=i-1\)</span>.</p>
<p>不妨设最后的最大深度为<span class="math inline">\(k\)</span>,需要满足<span class="math inline">\(1+\sum_{i=1}^ki=1+\frac{k(k+1)}{2}\geq
101,k(k+1)\geq 200\)</span>,<span class="math inline">\(k_{\min}=14\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p><span class="math inline">\(n\)</span>个人要进行一场游戏.游戏设计者准备了<span class="math inline">\(n\)</span>张卡片,正面分别写着<span class="math inline">\(n\)</span>个人的名字,背面写了<span class="math inline">\([1,n]\)</span>共<span class="math inline">\(n\)</span>个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,<span class="math inline">\(n\)</span>个人可以经过充分的讨论,并依次进入房间,一张一张地翻开<span class="math inline">\(\lfloor\frac{n}{2}\rfloor\)</span>张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有<span class="math inline">\(n\)</span>个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过<span class="math inline">\(0.1\)</span>的胜率.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是<span class="math inline">\(a\)</span>,如果<span class="math inline">\(a\)</span>就是自己的编号就下班;反之接下来翻开<span class="math inline">\(a\)</span>位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于<span class="math inline">\(\frac{n}{2}\)</span>的环.</p>
<p>考虑总方案数是<span class="math inline">\(n!\)</span>.不妨枚举这个环的长度为<span class="math inline">\(K\)</span>,则存在一个长度<span class="math inline">\(=K&gt;\frac{n}{2}\)</span>的环的方案数是<span class="math inline">\(\binom{n}{K}(K-1)!(n-K)!=\frac{n!}{K}\)</span>.所以此时的概率为<span class="math inline">\(\frac{1}{K}\)</span>.</p>
<p>那么失败的概率就是<span class="math inline">\(H_n-H_{\frac{n}{2}}\approx \ln 2\)</span>.</p>
<h3><span id="2022茶选">2022茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化<span class="math inline">\(z=5x_1+8x_2+4x_3\)</span>,其中:</p>
<ol type="1">
<li><span class="math inline">\(x_1,x_2,x_3\geq 0\)</span></li>
<li><span class="math inline">\(\frac 1 2 x_1+5x_2+9x_3\leq
3\)</span></li>
<li><span class="math inline">\(4x_1+7x_2+3x_3\leq 6\)</span></li>
</ol>
<p>再提一个问题:最小化<span class="math inline">\(v=3
y_1+6y_2\)</span>,其中:</p>
<ol type="1">
<li><span class="math inline">\(y_1,y_2\geq 0\)</span></li>
<li><span class="math inline">\(\frac{1}{2}y_1+4y_2\geq 5\)</span></li>
<li><span class="math inline">\(5y_1+7y_2\geq 8\)</span></li>
<li><span class="math inline">\(9y_1+3y_2\geq 4\)</span></li>
</ol>
<p>现在请你证明:<span class="math inline">\(z\leq v\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>下面乘一下配一下上面的系数,自然得证.</p>
<p>写成矩阵形式,设<span class="math inline">\(X=\begin{bmatrix}x_1&amp;x_2&amp;x_3\end{bmatrix},A=\begin{bmatrix}0.5&amp;4\\5&amp;7\\9&amp;3\end{bmatrix},Y=\begin{bmatrix}y_1\\y_2\end{bmatrix}\)</span>,不难发现<span class="math inline">\(z\leq XAY\leq v\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>半径为<span class="math inline">\(R\)</span>的球里放点,要求两两之间距离不能小于<span class="math inline">\(1\)</span>,证明至多放<span class="math inline">\((2R+1)^3\)</span>个.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>要求两两距离不能小于<span class="math inline">\(1\)</span>等价于往其中放半径为<span class="math inline">\(0.5\)</span>的球,这种球体积为<span class="math inline">\(\frac{4}{3}\pi
\frac{1}{8}\)</span>.然后原球要扩大一圈,所以原球体积变为<span class="math inline">\(\frac{4}{3}\pi(R+0.5)^3\)</span>.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数<span class="math inline">\(n\)</span>.</p>
<p>它每秒以<span class="math inline">\(v\)</span>的速度行驶,其中<span class="math inline">\(v\)</span>是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数<span class="math inline">\(x\)</span>,你会得知此时车的坐标是否是<span class="math inline">\(x\)</span>(Yes or No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>第<span class="math inline">\(t\)</span>秒的时候车应该在<span class="math inline">\(n+vt\)</span>处.由于我们知道现在是第几秒,枚举<span class="math inline">\(n,v\)</span>然后不断check即可.这个是经典的证明<span class="math inline">\(\mathbb{Z}^2\)</span>和<span class="math inline">\(\mathbb{N}\)</span>等势.按照<span class="math inline">\(|n|+|v|\)</span>排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对满足<span class="math inline">\(\forall i,|i-p_i|\leq
1\)</span>的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>简单题,设<span class="math inline">\(f_n\)</span>为答案,考虑<span class="math inline">\(p_n\)</span>取什么.</p>
<p>当<span class="math inline">\(p_n=n\)</span>时,方案数为<span class="math inline">\(f_{n-1}\)</span>.</p>
<p>当<span class="math inline">\(p_n=n-1\)</span>时,<span class="math inline">\(p_{n-1}=n\)</span>,方案数为<span class="math inline">\(f_{n-2}\)</span>.</p>
<p>于是,<span class="math inline">\(f_1=1,f_2=2\)</span>,<span class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>你有一个<span class="math inline">\(n\times
n\)</span>的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择<span class="math inline">\(k\)</span>个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数<span class="math inline">\(k\)</span>最小值是<span class="math inline">\(n\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是<span class="math inline">\(\frac{4n}{4}=n\)</span>个.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>设<span class="math inline">\(F=\{S_1,S_2,S_3,...,S_{|F|}\}\)</span>,定义一个集合<span class="math inline">\(T\)</span>能被<span class="math inline">\(F\)</span> shattered为:<span class="math inline">\(T\)</span>的任意一个子集(包括它自己和空集),都可以由<span class="math inline">\(T\cap S_{i_1}\cap
S_{i_2}...\)</span>表示.其中<span class="math inline">\(S_{i_j}\)</span>是<span class="math inline">\(F\)</span>中的集合(就是说每个子集都等于<span class="math inline">\(T\)</span>和某些<span class="math inline">\(F\)</span>内集合的交.)</p>
<p>定义一个<span class="math inline">\(F\)</span>的”VC-Dimension”是,能被他shattered的集合<span class="math inline">\(T\)</span>的大小的最大值.</p>
<p><span class="math inline">\(F\)</span>中的集合们只会包含某<span class="math inline">\(n\)</span>种不同的元素.证明:</p>
<ol type="1">
<li>任意一个<span class="math inline">\(F\)</span>能shattered的<span class="math inline">\(T\)</span>至少有<span class="math inline">\(|F|\)</span>个.</li>
<li>对于一个VC-Dimension的大小为<span class="math inline">\(k\)</span>的<span class="math inline">\(F\)</span>,其<span class="math inline">\(|F|\leq
\sum _{i=0}^k \binom{n}{i}\)</span>.</li>
</ol>
<h5><span id="solution6">Solution6</span></h5>
<p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的<span class="math inline">\(S\)</span>,满足<span class="math inline">\(S,S\cup
\{x\}\in F\)</span>,然后将这些<span class="math inline">\(S\cap
\{x\}\)</span>拎出来,假设有<span class="math inline">\(t\)</span>个,左边删去<span class="math inline">\(x\)</span>后再进行数学归纳得到<span class="math inline">\(|F|-t\)</span>个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有<span class="math inline">\(t\)</span>个集合,在这<span class="math inline">\(t\)</span>个集合添上<span class="math inline">\(x\)</span>这个元素即可.</p>
<p><span class="math inline">\(t=0\)</span>怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为<span class="math inline">\(S\)</span>(选取最大的那个集合为新加入的),我们在前面的集合中找到一个与<span class="math inline">\(S\)</span>有交的集合<span class="math inline">\(T\)</span>,根据上面的预处理,此集合显然存在.选出一个<span class="math inline">\(x\in S\setminus T\)</span>,不妨设<span class="math inline">\(S=S&#39;\cup\{x\}\)</span>,令<span class="math inline">\(T&#39;=S&#39;\cap T\)</span>,然后用<span class="math inline">\(T&#39;\)</span>代替原本的<span class="math inline">\(T\)</span>即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>令<span class="math inline">\(p(x)\)</span>表示<span class="math inline">\(x\)</span>的最大质因子,求所有<span class="math inline">\((x,y,z)\)</span>使得:</p>
<ol type="1">
<li><span class="math inline">\(x&lt;y&lt;z\)</span>且<span class="math inline">\(x+z=2y\)</span>.</li>
<li><span class="math inline">\(p(xyz)\leq 3\)</span>.</li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>不妨令<span class="math inline">\(g=\gcd(x,y,z)\)</span>,令<span class="math inline">\(x&#39;=\frac{x}{g}\)</span>,则只需要解:<span class="math inline">\(x&#39;+z&#39;=2y&#39;\)</span>.</p>
<p>我们有<span class="math inline">\(y-x=z-y\)</span>,则<span class="math inline">\(\gcd(y&#39;,x&#39;)=\gcd(y&#39;,y&#39;-x&#39;)=\gcd(y&#39;,z&#39;)=1\)</span>,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol type="1">
<li><span class="math inline">\(2\nmid x&#39;,2\nmid
z&#39;\)</span>.</li>
<li><span class="math inline">\(2\mid x&#39;,2\mid z&#39;,2\nmid
y&#39;\)</span>.</li>
</ol>
<p>先看(1),设<span class="math inline">\(x&#39;=3^a,z&#39;=3^c,y&#39;=2^b\)</span>.方程变为<span class="math inline">\(3^a(1+3^{c-a})=2^{b+1}\)</span>,一定有<span class="math inline">\(a=0\)</span>,只需解<span class="math inline">\(1+3^{c}=2^{b+1}\)</span>.</p>
<p>当<span class="math inline">\(b\leq 2\)</span>的时候,经检验有<span class="math inline">\(\begin{cases}c=0\\b=0\end{cases}\)</span>(舍)和<span class="math inline">\(\begin{cases}c=1\\b=1\end{cases}\)</span>两组解.</p>
<p>当<span class="math inline">\(b\geq 3\)</span>的时候,注意到<span class="math inline">\(3^{c}\equiv -1\pmod 4\)</span>,所以<span class="math inline">\(c\)</span>是偶数.又注意到<span class="math inline">\(3^{c}\equiv -1\pmod 8\)</span>,但是奇数的平方<span class="math inline">\(\bmod 8\)</span>应该是<span class="math inline">\(1\)</span>,不符.</p>
<p>再看(2),设<span class="math inline">\(x&#39;=2^d,z&#39;=2^e,y&#39;=3^b\)</span>.</p>
<p>当<span class="math inline">\(e=1\)</span>时,显然不符.</p>
<p>当<span class="math inline">\(d=1,e&gt;1\)</span>时,要解<span class="math inline">\(2^{e-1}+1=3^{b}\)</span>.当<span class="math inline">\(e=2\)</span>的时候有一组解<span class="math inline">\(\begin{cases}e=2\\b=1\end{cases}\)</span>.当<span class="math inline">\(e\geq 3\)</span>的时候,有<span class="math inline">\(3^b\equiv 1\pmod 4\)</span>,说明<span class="math inline">\(b\)</span>是偶数.</p>
<p>那必然有<span class="math inline">\(2^{e-1}=3^b-1=(3^{\frac{b}{2}}+1)(3^{\frac{b}{2}}-1)\)</span>.令<span class="math inline">\(t=3^{\frac{b}{2}}-1\)</span>,则<span class="math inline">\(2^{e-1}=t(t+2)\)</span>.则要么<span class="math inline">\(t=2\)</span>,要么<span class="math inline">\(t+2=2\)</span>.解出<span class="math inline">\(b-2\)</span>,此时有<span class="math inline">\(\begin{cases}e=4\\b=2\end{cases}\)</span>.</p>
<p>综上,解出来的解有<span class="math inline">\(\begin{cases}x&#39;=2\\y&#39;=3\\z&#39;=4\end{cases},\begin{cases}x&#39;=1\\y&#39;=2\\z&#39;=3\end{cases},\begin{cases}x&#39;=2\\y&#39;=9\\z&#39;=16\end{cases}\)</span>.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程<span class="math inline">\(2^x+1=3^y\)</span>,考虑两边<span class="math inline">\(\bmod 3\)</span>知道<span class="math inline">\(x\)</span>是奇数,于是<span class="math inline">\(v_3(2^x+1)=v_3(3)+v_3(x)=y,3^{y-1}|x,x\geq
3^{y-1}\)</span>,用这个放缩一下就行.</p>
<p>再看方程<span class="math inline">\(2^x=3^y+1\)</span>.仍然考虑两边<span class="math inline">\(\bmod 4\)</span>,知道<span class="math inline">\(y\)</span>是奇数.<span class="math inline">\(x=v_2(3^y+1)=v_2(3+1)=2\)</span>,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定两个随机分布：</p>
<p><span class="math inline">\(x∼D_1\)</span>:从<span class="math inline">\({0,1,…,p−1}\)</span>中等概率随机一个<span class="math inline">\(y\)</span>,令<span class="math inline">\(x=y \bmod {2^k}\)</span>.</p>
<p><span class="math inline">\(x∼D_1\)</span>:从<span class="math inline">\({0,1,…,2^k-1}\)</span>中等概率随机一个<span class="math inline">\(y\)</span>,令<span class="math inline">\(x=y \)</span>.</p>
<p>定义二者的统计距离为:<span class="math inline">\(SD(D_1,D_2)=\frac{1}{2}\sum_{i=0}^{2^k-1}|P_{D_1}(x=i)-P_{D_2}(x=i)|\)</span>.</p>
<p>求证:<span class="math inline">\(SD(D_1,D_2)≤\frac{2^k}{4p}\)</span>.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>令<span class="math inline">\(w=p\bmod {2^k}\)</span>.则<span class="math inline">\(SD(D_1,D_2)=\frac{w}{2}(P_{D_1}(x=0)-P_{D_2}(x=0))+\frac{2^k-w}{2}(P_{D_2}(x=w)-P_{D_1}(x=w))\)</span>.</p>
<p>令<span class="math inline">\(k=\lfloor\frac{p}{2^k}\rfloor=\frac{p-w}{2^k}\)</span>不难发现<span class="math inline">\(P_{D_1}(x=0)=\frac{k+1}{p},P_{D_1}(x=w)=\frac{k}{p}\)</span>.</p>
<p>则<span class="math inline">\(SD(D_1,D_2)=\frac{w}{2}(\frac{p-w+2^k}{p2^k}-\frac{1}{2^k})+\frac{2^k-w}{2}(\frac{1}{2^k}-\frac{p-w}{p2^k})=\frac{1}{2^{k+1}}(\frac{w(2^k-w)}{p}+\frac{w(2^k-w)}{p})=\frac{w(2^k-w)}{p2^k}\)</span>.</p>
<p>要证明<span class="math inline">\(\frac{w(2^k-w)}{p2^k}\leq
\frac{2^k}{4p}\Leftrightarrow w(2^k-w)\leq
(2^{k-1})^2\)</span>.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给你一个单增函数<span class="math inline">\(f\)</span>,满足定义域和值域都是<span class="math inline">\(\mathbb{N}\)</span>,并且<span class="math inline">\(f(f(n))=3n\)</span>,求<span class="math inline">\(f(2023)\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>首先我们不妨先试一下<span class="math inline">\(f(f(1))=3\)</span>.由于<span class="math inline">\(f(1)\geq 2\)</span>,且<span class="math inline">\(f(1)\ne 3\)</span>,所以<span class="math inline">\(f(1)=2,f(2)=3\)</span>.</p>
<p>考虑<span class="math inline">\(f(3n)\)</span>,必然存在一个<span class="math inline">\(n&lt;m&lt;3n\)</span>,使得<span class="math inline">\(f(n)=m,f(m)=3n\)</span>.</p>
<p>用这个找前几项,发现规律是把<span class="math inline">\(n\)</span>写成三进制形式,如果首位是<span class="math inline">\(1\)</span>就变成<span class="math inline">\(2\)</span>,首位是<span class="math inline">\(2\)</span>就改为<span class="math inline">\(1\)</span>再在后面加个<span class="math inline">\(0\)</span>.容易验证这是合法的<span class="math inline">\(f\)</span>且<span class="math inline">\(f(2023)=3882\)</span>.</p>
<p>但问题没有解决,需要证明它是唯一的<span class="math inline">\(f\)</span>.</p>
<p>考虑数学归纳假设现在<span class="math inline">\(f(x),x\in[1,3k]\)</span>都确定了.</p>
<p>注意到如果<span class="math inline">\(f(n)=m,f(m)=3n,f(3n)=3m,f(3m)=9n\)</span>.所以如果<span class="math inline">\(f(n)=m\)</span>,我们实际上有<span class="math inline">\(f(3^km)=3^{k+1}n,f(3^kn)=3^km\)</span>.数学归纳即可以证明<span class="math inline">\(f(3k+3)\)</span>一定是确定的.</p>
<p>接下来要证明<span class="math inline">\(f(3k+1)\)</span>和<span class="math inline">\(f(3k+2)\)</span>一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol type="1">
<li><span class="math inline">\(f(3k)+3=f(3k+3)\)</span>.</li>
<li><span class="math inline">\(\exists n,f(n)=3k+w(w\in
\{1,2\})\)</span>.</li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当<span class="math inline">\(k\)</span>在三进制下首位如果是<span class="math inline">\(2\)</span>,则一定满足(2).</p>
<p>当<span class="math inline">\(k\)</span>在三进制下首位是<span class="math inline">\(1\)</span>,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对于一个<span class="math inline">\(n\times n\)</span>的包含<span class="math inline">\([1,n^2]\)</span>各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol type="1">
<li>如果一个排列矩阵满足每行恰有模<span class="math inline">\(n\)</span>余<span class="math inline">\([0,n-1]\)</span>的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列为<span class="math inline">\((i-1)n+j\)</span>的矩阵(不妨称为有序矩阵).</li>
<li>求证:任意排列矩阵可以通过一次操作变为好的.</li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列<span class="math inline">\(\bmod
n\)</span>不相同,可以先将每行按照<span class="math inline">\(\bmod
n\)</span>排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将<span class="math inline">\(\bmod
n\)</span>不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是<span class="math inline">\(n\)</span>正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>有<span class="math inline">\(n(\geq
2)\)</span>个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称<span class="math inline">\(n\)</span>是好的.求证:</p>
<ol type="1">
<li><span class="math inline">\(4\)</span>是好的.</li>
<li>如果<span class="math inline">\(n\)</span>是奇数,那么<span class="math inline">\(n\)</span>不是好的.</li>
<li>求出所有好的<span class="math inline">\(n\)</span>.</li>
</ol>
<h5><span id="solution5">Solution5</span></h5>
<p>首先可以证明<span class="math inline">\(2\)</span>是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要<span class="math inline">\(2^n\)</span>步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到<span class="math inline">\(1100\)</span>来一个<span class="math inline">\(1010\)</span>之后啥也不变,但是<span class="math inline">\(1010\)</span>来一个<span class="math inline">\(1010\)</span>一定赢了.所以上来先来一个<span class="math inline">\(1010\)</span>,如果赢了就下班,没赢就来个<span class="math inline">\(1100\)</span>,这样<span class="math inline">\(1100\)</span>要么下班,要么变成了<span class="math inline">\(1010\)</span>,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:<span class="math inline">\(0000,1111,1010,1111,1100,1111,1010,1111,1000,1111,1010,1111,1100,1111,1010,1111\)</span>.</p>
<p>上面的构造启发我们手玩一下<span class="math inline">\(n=3\)</span>,注意到此时的问题在于<span class="math inline">\(100\)</span>和<span class="math inline">\(110\)</span>,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全<span class="math inline">\(0\)</span>;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全<span class="math inline">\(0\)</span>.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全<span class="math inline">\(0\)</span>的成功状态.我们不妨令一个成功状态的度为<span class="math inline">\(d\)</span>表示它可以经过<span class="math inline">\(d\)</span>步到达全<span class="math inline">\(0\)</span>,显然全<span class="math inline">\(1\)</span>的<span class="math inline">\(d=1\)</span>,<span class="math inline">\(n=4\)</span>的时候,<span class="math inline">\(1010\)</span>的<span class="math inline">\(d=2\)</span>,因为其可以通过一次操作转化为全<span class="math inline">\(1\)</span>,<span class="math inline">\(1100\)</span>的<span class="math inline">\(d=3\)</span>,因为其可以用一次操作转化为<span class="math inline">\(1010\)</span>.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向<span class="math inline">\(d\)</span>比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然<span class="math inline">\(n=3\)</span>的时候,<span class="math inline">\(\{110,100\}\)</span>就是失败状态.</p>
<p>而对于<span class="math inline">\(n\)</span>取任意来说,一定得存在一个<span class="math inline">\(d=2\)</span>的成功状态.一个显然的<span class="math inline">\(d=2\)</span>的成功状态要满足的条件是,假设它是<span class="math inline">\(a\)</span>,那么存在一个数<span class="math inline">\(b\)</span>,使得<span class="math inline">\(a\oplus
b\)</span>是全<span class="math inline">\(1\)</span>或者全<span class="math inline">\(0\)</span>.既然<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>旋转后只有两种结果,那么<span class="math inline">\(b\)</span>的循环节必定为<span class="math inline">\(2\)</span>,也就是<span class="math inline">\(b\)</span>一定要是<span class="math inline">\(101\cdots 010\)</span>这样的,于是<span class="math inline">\(n\)</span>是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找<span class="math inline">\(d=3\)</span>的成功状态,现在我们已知的四种成功状态是<span class="math inline">\(111\cdots111\)</span>,<span class="math inline">\(000\cdots000\)</span>,<span class="math inline">\(101\cdots010\)</span>,<span class="math inline">\(010\cdots101\)</span>,所以考虑构造一个循环节长度为<span class="math inline">\(4\)</span>的串,使得异或完它是这上面四种其一,注意到<span class="math inline">\(1100\cdots1100\)</span>就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明<span class="math inline">\(n=2^k\)</span>一定是好的.考虑数学归纳,不妨这么干:构造一个长度为<span class="math inline">\(2^{k-1}\)</span>的串<span class="math inline">\(b\)</span>,使得其<span class="math inline">\(b_i=a_i\oplus
a_{i+2^{k-1}}\)</span>.然后由数学归纳,可以造出<span class="math inline">\(b\)</span>全<span class="math inline">\(0\)</span>的情况.而如果<span class="math inline">\(b\)</span>全<span class="math inline">\(0\)</span>,则原串一定存在长为<span class="math inline">\(2^{k-1}\)</span>的循环节,并且消除循环节的过程不会改变<span class="math inline">\(b\)</span>的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设<span class="math inline">\(n=2^km\)</span>,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造<span class="math inline">\(b\)</span>数组,由于<span class="math inline">\(b\)</span>数组都不可能全<span class="math inline">\(0\)</span>,显然也不可能成立.</p>
<p>这个能不能顺便证明<span class="math inline">\(n\)</span>是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了<span class="math inline">\(n-1\)</span>个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前<span class="math inline">\(n-1\)</span>个位置的异或值为<span class="math inline">\(1\)</span>.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为<span class="math inline">\(50\%\)</span>,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>简单题,设<span class="math inline">\(f_0,f_1,f_2,f_3\)</span>,然后有<span class="math inline">\(\begin{cases}f_3=0\\f_2=\frac{1}{2}f_3+\frac{1}{2}f_0+1\\f_1=\frac{1}{2}f_2+\frac{1}{2}f_0+1\\f_0=\frac{1}{2}f_1+\frac{1}{2}f_0+1\end{cases}\)</span>,算出<span class="math inline">\(f_0=14\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.
<span class="math display">\[
x^3+□x^2+□x+□=0
\]</span></p>
<h5><span id="solution2">Solution2</span></h5>
<p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为<span class="math inline">\(-A,-B,-C\)</span>,方程应该可以写作<span class="math inline">\((x+A)(x+B)(x+C)=0\)</span>.</p>
<p>拆开有<span class="math inline">\(x^3+(A+B+C)x^2+(AB+AC+BC)x+ABC=0\)</span>.</p>
<p>这么对称,不妨猜一手Alice先选择<span class="math inline">\(0\)</span>,讨论一下:</p>
<ol type="1">
<li>Bob令<span class="math inline">\(ABC=0\)</span>.不妨令<span class="math inline">\(C=0\)</span>.</li>
</ol>
<p>此时方程变为<span class="math inline">\(x^2+(A+B)x+AB=0\)</span>.直接秒了,随便选一个数就行(比如选<span class="math inline">\(3\)</span>,如果Bob令<span class="math inline">\(AB=3\)</span>,就再选<span class="math inline">\(4\)</span>;如果令<span class="math inline">\(A+B=3\)</span>,就再选<span class="math inline">\(2\)</span>)</p>
<ol start="2" type="1">
<li>Bob令<span class="math inline">\(A+B+C=0,C=-A-B\)</span>.</li>
</ol>
<p>不妨令<span class="math inline">\(C&#39;=-C,D=AB\)</span>,则<span class="math inline">\(AB+AC+BC=D-C&#39;^2,ABC=DC&#39;\)</span>.</p>
<p>接下来Alice要选择一个数字<span class="math inline">\(k\)</span>,如果Bob又令<span class="math inline">\(D-C&#39;^2=k\)</span>,发现在此时如果<span class="math inline">\(k\)</span>是一个负的完全平方数,并且Alice接下来选择<span class="math inline">\(0\)</span>,当场就下班了.</p>
<p>所以不妨直接让<span class="math inline">\(k=-n^2\)</span>,然后看当<span class="math inline">\(DC&#39;=-n^2\)</span>的时候如何去解.此时有<span class="math inline">\(AB(A+B)=n^2\)</span>.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择<span class="math inline">\(-3^2\times
4^2\times 5^2\)</span>,这样就赢了.</p>
<ol start="3" type="1">
<li>Bob令<span class="math inline">\(AB+AC+BC=0,C=-\frac{AB}{A+B}\)</span>.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择<span class="math inline">\(6^2\times 7^3\)</span>,两种情况如下: <span class="math display">\[
(x+2\times 7)(x-3\times 7)(x-6\times 7)=0\\
(x-2\times 6^2\times 7^2)(x+3\times 6^2\times 7^2)(x+6\times 6^2\times
7^2)=0
\]</span></p>
<p>后来又找人讨论了一下这个是咋得出来的啊.考虑<span class="math inline">\(ABC\ne 0\)</span>,我们有的条件其实是<span class="math inline">\(\frac{1}{A}+\frac{1}{B}+\frac{1}{C}=0\)</span>.方程现在是<span class="math inline">\(x^3+(A+B-\frac{AB}{A+B})x^2-\frac{A^2B^2}{A+B}=0\)</span>.不妨令<span class="math inline">\(a=A+B,b=AB\)</span>,方程实际上是<span class="math inline">\(x^3+(a-\frac{b}{a})x^2-\frac{b^2}{a}=0\)</span>.最好能让<span class="math inline">\(a\)</span>小一点,因此我们不妨直接取<span class="math inline">\(a=1\)</span>,此时<span class="math inline">\(A=-n,B=n+1,C=n(n+1)\)</span>,只要能构造这样的两组<span class="math inline">\(A,B,C\)</span>使得它们的<span class="math inline">\(a_1-\frac{b_1}{a_1}=-\frac{b_2^2}{a_2}\)</span>即可.直接造看上去没啥前途,但是不难发现<span class="math inline">\(A=-nk,B=(n+1)k,C=n(n+1)k\)</span>依然合法.此时有<span class="math inline">\(k_1=a_1,b_1=-n(n+1)a_1^2,k_2=a_2,b_2=-n(n+1)a_2^2\)</span>,我们有<span class="math inline">\(a_1(n^2+n+1)=-n^2(n+1)^2a_2^3\)</span>.取<span class="math inline">\(n=2\)</span>试试看!此时有<span class="math inline">\(7a_1=-36a_2^3\)</span>.取<span class="math inline">\(a_2=7,a_1=-6^2\times
7^2\)</span>,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外<span class="math inline">\(3\)</span>个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌<span class="math inline">\(1\)</span>个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>有公式: <span class="math display">\[
\sum_{S\subseteq \{1,2,\cdots,n\}}(P(f(R)\oplus \bigoplus_{i\in
S}R_i=0)-P(f(R)\oplus \bigoplus_{i\in S}R_i=1))^2=1
\]</span> 其中<span class="math inline">\(f\)</span>是任意一个将<span class="math inline">\(\{0,1\}^n\rightarrow \{0,1\}\)</span>的函数,<span class="math inline">\(\oplus\)</span>是二进制意义下的异或运算,<span class="math inline">\(R\)</span>是<span class="math inline">\(\{0,1\}^n\)</span>上的均匀分布,<span class="math inline">\(R_i\)</span>表示第<span class="math inline">\(i\)</span>位.再定义<span class="math inline">\(\chi_S(r)=\prod_{i\in S}(-1)^{r_i}\)</span>.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol type="1">
<li><span class="math inline">\(\chi_S(r)\times
\chi_S(r&#39;)=\chi_S(r\oplus r&#39;)\)</span>.</li>
<li>当<span class="math inline">\(r\ne 0\)</span>时,<span class="math inline">\(\sum_{S\subseteq
\{1,\cdots,n\}}\chi_S(r)=0\)</span>.</li>
<li><span class="math inline">\([f(r)\oplus \bigoplus_{i\in
S}r_i=0]-[f(r)\oplus \bigoplus_{i\in
S}r_i=1]=(-1)^{f(r)}\chi_S(r)\)</span>.</li>
<li>证明原命题.</li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>(1)显然.</p>
<p>(2)也很经典,挑选一个<span class="math inline">\(j\)</span>,使得<span class="math inline">\(r_j=1\)</span>,然后所有的集合分为两类:一类是包含<span class="math inline">\(j\)</span>,一类不包含,两类集合一一对应并且<span class="math inline">\(\chi\)</span>互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到<span class="math inline">\(P(f(R)\oplus
\bigoplus_{i\in S}R_i=0)=\frac{1}{2^n}\sum_{r}[f(r)\oplus \bigoplus
_{i\in S}r_i=0]\)</span>,而<span class="math inline">\(\sum_{r}[f(r)\oplus \bigoplus _{i\in
S}r_i=0]-[f(r)\oplus \bigoplus _{i\in
S}r_i=1]=\sum_r(-1)^{f(r)}\chi_S(r)\)</span>,要证明的只是<span class="math inline">\(\sum_{S}\frac{1}{4^n}(\sum_r(-1)^{f(r)}\chi_S(r))^2=1\)</span>,而:
<span class="math display">\[
\sum_{S}(\sum_r(-1)^{f(r)}\chi_S(r))^2
\\=\sum_S\sum_{r}\sum_{r&#39;}(-1)^{f(r)+f(r&#39;)}\chi_S(r\oplus
r&#39;)\\
=\sum_{r}\sum_{r&#39;}(-1)^{f(r)+f(r&#39;)}\sum_S\chi_S(r\oplus
r&#39;)\\
=\sum_{r}2^n=4^n
\]</span> 于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于<span class="math inline">\(50\%\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数<span class="math inline">\(x\)</span>,然后随机一只手,看上面的数字<span class="math inline">\(a\)</span>,如果<span class="math inline">\(a\geq
x\)</span>就认为<span class="math inline">\(a\)</span>大,反之认为<span class="math inline">\(b\)</span>大.只要随机到一个区间内的实数的概率不为<span class="math inline">\(0\)</span>即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5>
<p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令<span class="math inline">\(p\)</span>为素数,把整个图形放大<span class="math inline">\(p\)</span>倍(也就是长度<span class="math inline">\(1\)</span>变成长度<span class="math inline">\(p\)</span>).下面把每个交叉点<span class="math inline">\((x,y)\)</span>换成其整数部分<span class="math inline">\((\lfloor x\rfloor,\lfloor
y\rfloor)\)</span>,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被<span class="math inline">\(p\)</span>整除.这样这个新的大矩形的面积也能被<span class="math inline">\(p\)</span>整除,所以它的有一边长能被<span class="math inline">\(p\)</span>整除.这条边只是被换成了它长度的整数部分,所以变化不超过<span class="math inline">\(1\)</span>,所以在放大之前这条边的长度和某个整数相差不超过<span class="math inline">\(1/p\)</span>.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有<span class="math inline">\(2\)</span>条边或者<span class="math inline">\(4\)</span>条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点<span class="math inline">\((x,y)\)</span>染色:如果<span class="math inline">\(x\)</span>是整数,染X颜色.如果<span class="math inline">\(x\)</span>不是整数但<span class="math inline">\(y\)</span>是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为<span class="math inline">\([0,a]\times[0,b]\)</span>,并假设<span class="math inline">\(b\)</span>不是整数.把所有小矩形的下边界去掉,然后令<span class="math inline">\(f(t)\)</span>为所有上边界<span class="math inline">\(y\)</span>坐标不是整数,并且与直线<span class="math inline">\(y=t\)</span>相交的小矩形的<span class="math inline">\(x\)</span>方向边长之和.那么<span class="math inline">\(f(0)=0\)</span>,而且当<span class="math inline">\(f(t)\)</span>变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以<span class="math inline">\(f(b)\)</span>是整数.而因为<span class="math inline">\(b\)</span>不是整数,<span class="math inline">\(f(b)\)</span>就是最靠上的所有小矩形的宽之和,等于<span class="math inline">\(a\)</span>,所以<span class="math inline">\(a\)</span>是整数.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#bash游戏">Bash游戏</a></li>
<li><a href="#nim游戏">Nim游戏</a>
<ul>
<li><a href="#example1nimk游戏">Example1(Nimk游戏)</a></li>
<li><a href="#example2multi-nim游戏">Example2(Multi-Nim游戏)</a></li>
</ul></li>
<li><a href="#sg游戏">SG游戏</a>
<ul>
<li><a href="#example1anti-sg游戏">Example1(Anti-SG游戏)</a></li>
<li><a href="#example2every-sg">Example2(Every-SG)</a></li>
<li><a href="#example25every-sg">Example2.5(Every-SG)</a></li>
<li><a href="#example3nim-on-tree">Example3(Nim on tree)</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
</ul></li>
<li><a href="#斐波那契博弈">斐波那契博弈</a></li>
<li><a href="#二分图博弈">二分图博弈</a>
<ul>
<li><a href="#example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</a></li>
</ul></li>
<li><a href="#树上博弈">树上博弈</a>
<ul>
<li><a href="#example1zr23省选10连-day1-clashmas">Example1(zr[23省选10连
day1] Clashmas)</a></li>
</ul></li>
<li><a href="#散题">散题</a>
<ul>
<li><a href="#problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</a></li>
<li><a href="#problem2agc023dgo-home">Problem2([AGC023D]Go
Home)</a></li>
<li><a href="#problem3牛客38727e">Problem3(牛客38727E)</a></li>
<li><a href="#problem4arc155d">Problem4(arc155D)</a></li>
<li><a href="#problem5">Problem5</a></li>
<li><a href="#problem6">Problem6</a></li>
<li><a href="#problem7">Problem7</a></li>
<li><a href="#problem8">Problem8</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>颗石子,每次可以取<span class="math inline">\(x\)</span>颗,其中<span class="math inline">\(1\leq
x\leq m\\\)</span>,求<span class="math inline">\(A\)</span>是否能赢.</p>
<p>考虑直接令石子数量为状态,有<span class="math inline">\(SG(x)=mex\{SG(y)|\max\{0,x-m\}\leq y\leq
x-1\}\\\)</span>,注意到<span class="math inline">\(SG(x)=0\)</span>当且仅当<span class="math inline">\(x\equiv 0(\mod m+1)\)</span>.</p>
<p>我们使用数学归纳证明:</p>
<p>当<span class="math inline">\(0\leq x\leq m\)</span>时,显然成立.</p>
<p>而对于<span class="math inline">\(x\)</span>,如果<span class="math inline">\(x\equiv 0(\mod m+1)\\\)</span>,那么集合<span class="math inline">\(S=\{y\in \mathbb{Z}|\max\{0,x-m\}\leq y\leq
x-1\}\)</span>中一定<span class="math inline">\(\nexists
y\)</span>满足<span class="math inline">\(y\equiv0(\mod
m+1)\\\)</span>.</p>
<p>也就是<span class="math inline">\(\nexists y\)</span>满足<span class="math inline">\(SG(y)=0\)</span>,那么<span class="math inline">\(SG(n)=0\)</span>.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>堆石子,第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(x_i\)</span>个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果<span class="math inline">\(x\)</span>均等于<span class="math inline">\(0\)</span>一定先手必败.考虑令<span class="math inline">\(w=x_1\oplus x_2\oplus...\oplus x_n\)</span>(<span class="math inline">\(w\)</span>即为全游戏的<span class="math inline">\(SG\)</span>值),那么先手必败当且仅当<span class="math inline">\(w=0\\\)</span>.</p>
<p>证明: 只需证明当<span class="math inline">\(w\ne
0\)</span>时一定存在一种方法使得<span class="math inline">\(w=0\\\)</span>.</p>
<p>考虑<span class="math inline">\(w\)</span>的最高位为第<span class="math inline">\(k\)</span>位,那么一定存在一个<span class="math inline">\(x_i\)</span>的第<span class="math inline">\(k\)</span>位为<span class="math inline">\(1\)</span>.将它改为<span class="math inline">\(0\)</span>,然后这个<span class="math inline">\(x_i\)</span>的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>堆石子,第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(x_i\)</span>个石子.每次可以任选不超过<span class="math inline">\(k\)</span>堆取走若干个石子,最后不能取的人输.</p>
<p>将<span class="math inline">\(x_i\)</span>写成二进制,如果每一位的<span class="math inline">\(1\)</span>的个数均是<span class="math inline">\(k+1\)</span>的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4>
<p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于<span class="math inline">\(2\)</span>的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p><span class="math inline">\(SG(x)=mex\{\{SG(v)|x\rightarrow
v\},\{SG(x-i)\oplus SG(i)|1\leq i&lt;x\}\}\\\)</span>.</p>
<p>找一下规律可以发现: <span class="math display">\[
SG(x)=\begin{cases}
x-1&amp;x\equiv 0(\mod 4)\\
x&amp;x\equiv 1或2(\mod 4)\\
x+1&amp;x\equiv 3(\mod 4)\\
\end{cases}\\
\]</span> 不妨设当<span class="math inline">\(x\leq
4k\)</span>时结论成立.</p>
<p>当<span class="math inline">\(x=4k+1\)</span>时,前半部分一定是取遍了<span class="math inline">\([1,4k]\)</span>.</p>
<p>但是一定不存在<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>满足<span class="math inline">\(a+b=4k+1\)</span>并且<span class="math inline">\(SG(a)\oplus SG(b)=4k+1\)</span>.讨论一下<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>在<span class="math inline">\(\mod
4\)</span>意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3>
<p><span class="math inline">\(n\)</span>个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用<span class="math inline">\(SG(u)=mex\{SG(v)|u\rightarrow
v\}\)</span>.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是<span class="math inline">\(0\)</span>.</p>
<p>首先如果<span class="math inline">\(SG(u)=x\)</span>,那么<span class="math inline">\(\forall 0\leq y&lt;x\)</span>,<span class="math inline">\(\exists v\)</span>使得<span class="math inline">\(u\rightarrow v\)</span>且<span class="math inline">\(SG(v)=y\)</span>.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能<span class="math inline">\(\exists
y&gt;x\)</span>,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个<span class="math inline">\(u&#39;\)</span>使得<span class="math inline">\(SG(u&#39;)=x\)</span>,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4>
<p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol type="1">
<li>游戏的SG函数不为<span class="math inline">\(0\)</span>且游戏中某个单一游戏的SG函数大于<span class="math inline">\(1\)</span>.</li>
<li>游戏的SG函数为<span class="math inline">\(0\)</span>且游戏中没有单一游戏的SG函数大于<span class="math inline">\(1\)</span>.</li>
</ol>
<p>如果没有单一游戏的SG函数大于<span class="math inline">\(1\)</span>,那么显然游戏的SG函数为<span class="math inline">\(0\)</span>就赢了,否则就输了.</p>
<p>而如果SG函数为<span class="math inline">\(0\)</span>且存在某个单一游戏的SG函数大于<span class="math inline">\(1\)</span>,一定是输的.</p>
<p>因为这个情况下,后手先按照正常<span class="math inline">\(SG\)</span>游戏压着先手,最后一定会剩两堆一样大于<span class="math inline">\(1\)</span>的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4>
<p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在<span class="math inline">\(DAG\)</span>上dp的时候除了<span class="math inline">\(SG\)</span>我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4>
<p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4>
<p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:<span class="math inline">\(SG(u)=\bigoplus_{u\rightarrow
v}(SG(v)+1)\)</span>.</p>
<p>考虑归纳假设.如果<span class="math inline">\(u\)</span>只有<span class="math inline">\(v\)</span>一个儿子.那么要么将<span class="math inline">\(v\)</span>子树全删,要么删一部分,有: <span class="math display">\[
SG(u)=mex(x|x=0\or 0\leq x-1&lt; SG(v))=SG(v)+1
\]</span>
而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的<span class="math inline">\(SG\)</span>为<span class="math inline">\(0\)</span>,而显然<span class="math inline">\(SG\)</span>图中的其它节点的<span class="math inline">\(SG\)</span>均要<span class="math inline">\(+1\)</span>.</p>
<h4><span id="example4">Example4</span></h4>
<p><span class="math inline">\(n\)</span>个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环<span class="math inline">\(SG=1\)</span>,偶环<span class="math inline">\(SG=0\)</span>.</p>
<p>这么考虑:边数为<span class="math inline">\(k\)</span>的链的<span class="math inline">\(SG\)</span>为<span class="math inline">\(k\)</span>.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到<span class="math inline">\(1\)</span>.偶环同理,不可能得到<span class="math inline">\(0\)</span>.</p>
<h4><span id="example5">Example5</span></h4>
<p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,<span class="math inline">\(SG\)</span>值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3>
<p>一个数<span class="math inline">\(N\)</span>,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当<span class="math inline">\(N\)</span>是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当<span class="math inline">\(N\)</span>是斐波那契数时必败,不妨假设<span class="math inline">\(N=N_0+N_1\)</span>, 考虑将<span class="math inline">\(N\)</span>看成两堆,因为如果第一次取走了大于<span class="math inline">\(N_1\)</span>颗石子,由于<span class="math inline">\(N_0\leq
N_1\\\)</span>,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在<span class="math inline">\(N_0\)</span>堆取石子,原因是如果取了大于<span class="math inline">\(N_0\)</span>颗石子,由于<span class="math inline">\(N=N_0+N_1\leq
3N_0\\\)</span>.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取<span class="math inline">\(N_0\)</span>这一堆,如果在这一堆取的过程中,先手一直取得不超过<span class="math inline">\(N_0\)</span>剩下的数,那么根据归纳假设,后手一定可以取走<span class="math inline">\(N_0\)</span>堆的最后一个石子,此时局面变成了只剩<span class="math inline">\(N_1\)</span>颗石子.只要此时先手不能一次取走<span class="math inline">\(N_1\)</span>颗石子,先手就必败.而后手最后一步拿走石子最多会拿走<span class="math inline">\(\frac 2 3N_0\)</span>的石子,但是,<span class="math inline">\(\frac 4 3N_0&lt;N_1\)</span>,因此一定不可能.</p>
<p>否则,仍然是先手取走了<span class="math inline">\(N_0\)</span>全部石子,又当了先手取<span class="math inline">\(N_1\)</span>的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设<span class="math inline">\(N=\sum_{i=1}^k
f_{p_i}\)</span>,其中<span class="math inline">\(p_1&lt;p_2&lt;p_3&lt;...&lt;p_k\\\)</span>,先手取走<span class="math inline">\(f_{p_1}\\\)</span>.由于<span class="math inline">\(2f_{p_1}&lt;f_{p_2}\)</span>,因此后手接下来无论如何不可能取得大于等于<span class="math inline">\(f_{p_2}\\\)</span>,问题转化为一堆大小为<span class="math inline">\(f_{p_2}\)</span>的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3>
<p>给出一张二分图和起点<span class="math inline">\(S\)</span>,<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点<span class="math inline">\(S\)</span>,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含<span class="math inline">\(S\)</span>,那么<span class="math inline">\(A\)</span>只需要每次走到一个和<span class="math inline">\(S\)</span>匹配的点即可.<span class="math inline">\(B\)</span>无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含<span class="math inline">\(S\)</span>的点,与假设不符.</p>
<p>而如果存在一个匹配不包含<span class="math inline">\(S\)</span>,如果<span class="math inline">\(A\)</span>仍然第一步走到一个和<span class="math inline">\(S\)</span>匹配的点那么<span class="math inline">\(B\)</span>一定能想办法走到一个不在当前<span class="math inline">\(A\)</span>选择的最大匹配中的点而在一个不包含<span class="math inline">\(S\)</span>的最大匹配中的点,于是<span class="math inline">\(B\)</span>必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4>
<p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设<span class="math inline">\(dp_{S,x}=0/1\)</span>表示目前集合<span class="math inline">\(S\)</span>中的所有人都已经离场了,而目前金条在<span class="math inline">\(x\)</span>手中,金条会不会被抢.显然,如果<span class="math inline">\(\exists y\)</span>满足<span class="math inline">\(dp_{S\cup\{x\},y}=0\)</span>,也就是金条在<span class="math inline">\(y\)</span>手里不会被抢,那<span class="math inline">\(x\)</span>手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与<span class="math inline">\(S\)</span>匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果<span class="math inline">\(S\)</span>和<span class="math inline">\(x\)</span>并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断<span class="math inline">\(S\)</span>是否一定在其中,只需要先删去<span class="math inline">\(S\)</span>,跑dinic,再在残联网络上加上<span class="math inline">\(S\)</span>,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3>
<h4><span id="example1zr23省选10连-day1clashmas">Example1(zr[23省选10连 day1]
Clashmas)</span></h4>
<p>注意到删点对树形态的影响,考虑重心</p>
<ol type="1">
<li><span class="math inline">\(n\)</span>为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol start="2" type="1">
<li><span class="math inline">\(n\)</span>为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时<span class="math inline">\(n\)</span>为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为<span class="math inline">\(S_A\)</span>,B的点的集合为<span class="math inline">\(S_B\)</span>.以原重心为根建树,设其所有儿子组成的集合为<span class="math inline">\(S_C\)</span>,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当<span class="math inline">\(\sum_{u\in S_A\cap S_C}siz_u\geq\sum_{u\in S_B\cap
S_C}siz_u\)</span>.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中<span class="math inline">\(siz\)</span>最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol start="3" type="1">
<li><span class="math inline">\(n\)</span>为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时<span class="math inline">\(n\)</span>为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol start="4" type="1">
<li><span class="math inline">\(n\)</span>为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol start="5" type="1">
<li><span class="math inline">\(n\)</span>为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3>
<h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5>
<p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设<span class="math inline">\(f_i\)</span>为还剩<span class="math inline">\(i\)</span>条蛇的时候能不能吃,那<span class="math inline">\(f_i=1\)</span>的话,要么<span class="math inline">\(i=2\)</span>,要么吃完后不是最小的,要么<span class="math inline">\(f_{i-1}=0\)</span>.</p>
<p>递归做就好了.另外这题需要复杂度<span class="math inline">\(O(n)\)</span>,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5>
<p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5>
<p>首先考虑如果有人作为第<span class="math inline">\(n-p+1\)</span>个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读<span class="math inline">\(n-p\)</span>个人.</p>
<p>继续思考,如果有人作为第<span class="math inline">\(n-2p+1\)</span>个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有<span class="math inline">\(n\mod
p\)</span>个人复读,并且一定是前<span class="math inline">\(n\mod
p\)</span>在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5>
<p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录<span class="math inline">\(f_{i,j}\)</span>表示当前的<span class="math inline">\(G\)</span>是<span class="math inline">\(i\)</span>,<span class="math inline">\(G\)</span>的倍数还剩下<span class="math inline">\(j\)</span>个,然后做转移,再进一步发现我们只关心<span class="math inline">\(j\)</span>的奇偶性.于是记<span class="math inline">\(f_{i,0/1}\)</span>即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.
##### Problem5</p>
<p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在<span class="math inline">\([l_i,r_i]\)</span>,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为<span class="math inline">\(0\)</span>.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为<span class="math inline">\(0\)</span>.</p>
<p>换句话说,我们现在有<span class="math inline">\(x_1,x_2,x_3\)</span>,我们要将其中一个<span class="math inline">\(x_i\)</span>改为<span class="math inline">\(y_i\)</span>,其他不变,使得他们仨异或值为<span class="math inline">\(0\)</span>.和Nim游戏类似,假设他们仨异或值的最高位为<span class="math inline">\(k\)</span>.那么一定有一个<span class="math inline">\(x_i\)</span>的第<span class="math inline">\(k\)</span>位为<span class="math inline">\(1\)</span>,将它改为<span class="math inline">\(0\)</span>,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的<span class="math inline">\([l_i,r_i]\)</span>求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5>
<p>Nim游戏,但是每堆石子有一个<span class="math inline">\(K_i\)</span>.如果这堆石子剩<span class="math inline">\(x_i\)</span>个每次最多取<span class="math inline">\(\lfloor\frac {x_i}
{K_i}\rfloor\)</span>个石子.求先手是否必胜.</p>
<p>结论是<span class="math inline">\(SG(n,k)=\begin{cases}
SG(n-\lfloor\frac n k\rfloor,k)&amp;n\ne 0(\mod k)\\
\frac n k&amp;n=0(\mod k)\\
\end{cases}\\\)</span></p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于<span class="math inline">\(k\)</span>是否大于<span class="math inline">\(\sqrt n\)</span>讨论一下,如果<span class="math inline">\(k&lt;\sqrt n\)</span>暴力,最多只会做<span class="math inline">\(\sqrt
n\)</span>次.否则,意识到此时可以通过求一个区间<span class="math inline">\([l,r]\)</span>,满足<span class="math inline">\(\forall x\in [l,r],\lfloor\frac x
k\rfloor\)</span>均相等,加速一下.这种区间最多只会有<span class="math inline">\(\sqrt n\)</span>个.</p>
<h5><span id="problem7">Problem7</span></h5>
<p>一个数<span class="math inline">\(N\)</span>,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当<span class="math inline">\(N=2^k\)</span>,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5>
<p>A和B,有<span class="math inline">\(n\)</span>颗石子,每次可以取<span class="math inline">\(x\)</span>颗,其中<span class="math inline">\(1\leq
x\leq \lceil\frac n 2\rceil\\\)</span>.</p>
<p>仍然令石子数量为状态,注意到<span class="math inline">\(SG(x)=0\)</span>当且仅当<span class="math inline">\(x+1=2^k-1\)</span>,也即<span class="math inline">\(x=2^k-2\\\)</span>.首先,注意到: <span class="math display">\[
n-\lceil\frac n 2\rceil=\lfloor\frac{n}{2}\rfloor\\
SG(n)=mex\{SG(y)|\lfloor\frac{n}{2}\rfloor\leq y\leq n-1\}\\
\]</span> 设<span class="math inline">\(n=2^k-w\)</span>,其中: <span class="math display">\[
-2^{k-1}+2\leq w\leq 2\\
\lfloor \frac {2^k-w}2\rfloor=2^{k-1}-\lfloor\frac w 2\rfloor\\
\]</span> 当<span class="math inline">\(w=2\)</span>时,原式<span class="math inline">\(=2^{k-1}-1&gt;2^{k-1}-2\\\)</span>.反之.<span class="math inline">\(2^k-2\leq\)</span>原式.因此数学归纳即可证明.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划相关</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#动态规划的设计">动态规划的设计</a>
<ul>
<li><a href="#分析状态">分析状态</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1007e">Example2(CF1007E)</a></li>
</ul></li>
<li><a href="#可删除dp">可删除dp</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
</ul></li>
<li><a href="#dp分界点">dp分界点</a>
<ul>
<li><a href="#example12022zrtg十连测day7-permutation">Example1(2022zrtg十连测day7
Permutation)</a></li>
</ul></li>
<li><a href="#基于贪心的dp">基于贪心的dp</a>
<ul>
<li><a href="#example1cf1666e">Example1(CF1666E)</a></li>
</ul></li>
<li><a href="#数位dp">数位dp</a>
<ul>
<li><a href="#example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</a></li>
<li><a href="#example2cf1194g">Example2([CF1194G])</a></li>
</ul></li>
<li><a href="#树形dp">树形dp</a>
<ul>
<li><a href="#example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</a></li>
</ul></li>
<li><a href="#轮廓线dp插头dp">轮廓线dp(插头dp)</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
<li><a href="#高斯消元处理后效性">高斯消元处理后效性</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
<li><a href="#最短路处理后效性">最短路处理后效性</a>
<ul>
<li><a href="#example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</a></li>
</ul></li>
<li><a href="#组合意义">组合意义</a>
<ul>
<li><a href="#example1noi2009-管道取珠">Example1([NOI2009]
管道取珠)</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#二项式定理展开">二项式定理展开</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
</ul></li>
<li><a href="#线头dp">线头dp</a>
<ul>
<li><a href="#example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</a></li>
<li><a href="#example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</a></li>
<li><a href="#example3coci2020-20212-svjetlo">Example3([COCI2020-2021#2]
Svjetlo)</a></li>
<li><a href="#example4cf626f">Example4(CF626F)</a></li>
<li><a href="#example5xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489-jtravel-in-sugar-country">Example5([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489) J]Travel in Sugar Country)</a></li>
</ul></li>
<li><a href="#相对顺序不变">相对顺序不变</a>
<ul>
<li><a href="#example1bzoj4621tc605">Example1([bzoj4621]Tc605)</a></li>
</ul></li>
<li><a href="#拆分区间">拆分区间</a>
<ul>
<li><a href="#example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</a></li>
<li><a href="#example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4agc039e-pairing-points">Example4([AGC039E] Pairing
Points)</a></li>
<li><a href="#example5agc035d-add-and-remove">Example5([AGC035D] Add and
Remove)</a></li>
<li><a href="#example6cf607bzuma">Example6([CF607B]Zuma)</a></li>
<li><a href="#example7loj-3215">Example7(LOJ 3215)</a></li>
</ul></li>
<li><a href="#相互独立">相互独立</a>
<ul>
<li><a href="#example12019zrtg十连测day1-origami">Example1(2019zrtg十连测day1
origami)</a></li>
<li><a href="#example2cf1616g-just-add-an-edge">Example2(CF1616G Just
Add an Edge)</a></li>
</ul></li>
<li><a href="#费用提前延后计算">费用提前/延后计算</a>
<ul>
<li><a href="#example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</a></li>
<li><a href="#example22019zrtg十连测day1-group">Example2(2019zrtg十连测day1
group)</a></li>
<li><a href="#example3agc056b">Example3(AGC056B)</a></li>
</ul></li>
<li><a href="#分维处理">分维处理</a>
<ul>
<li><a href="#example1cf1621gweighted-increasing-subsequences">Example1([CF1621G]Weighted
Increasing Subsequences)</a></li>
</ul></li>
</ul></li>
<li><a href="#动态规划的优化">动态规划的优化</a>
<ul>
<li><a href="#递进转移">递进转移</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
</ul></li>
<li><a href="#反向操作">反向操作</a>
<ul>
<li><a href="#example1cf1810g">Example1(CF1810G)</a></li>
</ul></li>
<li><a href="#矩阵加速">矩阵加速</a>
<ul>
<li><a href="#example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</a></li>
<li><a href="#example2noi-online3提高组魔法值">Example2([NOI
Online#3提高组]魔法值)</a></li>
<li><a href="#example3cf-1474f">Example3([CF 1474F])</a></li>
<li><a href="#example4cf-1152f2">Example4([CF 1152F2])</a></li>
<li><a href="#example5noi2020-美食家">Example5([NOI2020]
美食家)</a></li>
</ul></li>
<li><a href="#分步合并">分步合并</a>
<ul>
<li><a href="#example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</a></li>
</ul></li>
<li><a href="#合并更新">合并更新</a>
<ul>
<li><a href="#example2022zrtg十连测day7-zero">Example(2022zrtg十连测day7
Zero)</a></li>
</ul></li>
<li><a href="#交换状态和值">交换状态和值</a>
<ul>
<li><a href="#example1cf1620f">Example1(CF1620F)</a></li>
<li><a href="#example2agc033d">Example2(AGC033D)</a></li>
<li><a href="#example3-1">Example3</a></li>
<li><a href="#example4uoj708">Example4(uoj708)</a></li>
</ul></li>
<li><a href="#斜率优化">斜率优化</a>
<ul>
<li><a href="#example1codechef-tsum2">Example1(Codechef TSUM2)</a></li>
</ul></li>
<li><a href="#wqs二分">WQS二分</a></li>
<li><a href="#四边形不等式">四边形不等式</a>
<ul>
<li><a href="#判定性质定理">判定/性质定理</a>
<ul>
<li><a href="#定理2">定理2</a></li>
<li><a href="#定理3">定理3</a></li>
<li><a href="#定理4">定理4</a></li>
<li><a href="#定理5">定理5</a></li>
</ul></li>
<li><a href="#决策单调性">决策单调性</a>
<ul>
<li><a href="#最短路型dp">最短路型dp</a>
<ul>
<li><a href="#example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</a></li>
</ul></li>
<li><a href="#k点最短路型dp">k点最短路型dp</a>
<ul>
<li><a href="#example1-基站选址">Example1 基站选址</a></li>
<li><a href="#example2cf-gym-102984f">Example2(CF gym 102984F)</a></li>
</ul></li>
<li><a href="#区间型dp">区间型dp</a>
<ul>
<li><a href="#定理">定理</a></li>
</ul></li>
</ul></li>
<li><a href="#四边形不等式判断凸性">四边形不等式判断凸性</a>
<ul>
<li><a href="#example1cf1661f">Example1(CF1661F)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2>
<h3><span id="分析状态">分析状态</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个<span class="math inline">\([1,m]\)</span>中的数字,然后进行以下判断:</p>
<ol type="1">
<li>如果当前序列末尾两个数字相同且小于<span class="math inline">\(t\)</span>,假设都是<span class="math inline">\(x\)</span>,那就将它们都删去,加入一个<span class="math inline">\(x+1\)</span>.</li>
<li>如果当前序列没有可以删的数字,并且序列长度为<span class="math inline">\(n\)</span>,终止操作.</li>
</ol>
<p>给定<span class="math inline">\(n,m,t\)</span>,求最终序列的元素和的期望.</p>
<p><span class="math inline">\(n,m\leq 10^3,t\leq 10^9\)</span>.</p>
<p>首先<span class="math inline">\(t\leq
10^9\)</span>显然是没用的,因为它最多也就能这么凑:<span class="math inline">\(m+n-2,m+n-3,\cdots,m,m\)</span>,合成一个<span class="math inline">\(m+n-1\)</span>,因此我们令<span class="math inline">\(t=\min\{t,m+n-1\}\)</span>即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置<span class="math inline">\(i\)</span>,有<span class="math inline">\(a_i&lt;a_{i+1}\)</span>,那么无论后面怎么做,这里的<span class="math inline">\(a_i\)</span>都必不可能被删除.以此,我们不妨设<span class="math inline">\(f_{i,j}\)</span>表示序列长度为<span class="math inline">\(i\)</span>,序列开头元素为<span class="math inline">\(j\)</span>的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过<span class="math inline">\(t\)</span>,另一个是序列的长度不能超过<span class="math inline">\(n\)</span>.我们不妨设<span class="math inline">\(ans_{n,t}\)</span>表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移<span class="math inline">\(ans\)</span>需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下<span class="math inline">\(ans_{n,t}\)</span>,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有<span class="math inline">\(ans_{n,t}=\sum_{x=1}^tE(n个位置,第一个位置是x并且没有被删去)\)</span>.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:<span class="math inline">\(3,3,3\)</span>,最终的答案应该是<span class="math inline">\(4,3\)</span>.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了<span class="math inline">\(3,[3,3]\)</span>,最终的答案就变成了<span class="math inline">\(3,4\)</span>.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设<span class="math inline">\(g_{i,j}\)</span>表示当前后面还有<span class="math inline">\(i-1\)</span>个位置,当前前面已经放好了一个<span class="math inline">\(j\)</span>,这个<span class="math inline">\(j\)</span>不能被删掉的期望,显然有<span class="math inline">\(ans_{n,t}=\sum_{x}^tg_{n,x}P(最终序列中,这里是k)\)</span>,问题只在于如何求<span class="math inline">\(g\)</span>.这个<span class="math inline">\(g_{n,k}\)</span>是钦定了这个位置放<span class="math inline">\(k\)</span>的期望,后面我们需要将它乘上这个位置放<span class="math inline">\(k\)</span>的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个<span class="math inline">\(g_{n,k}=(k+\sum_{j\ne
k}g_{n-1,j})\)</span>.但是实际上这个是不对的.这里的<span class="math inline">\(k\)</span>不能删掉不意味着后面的<span class="math inline">\(j\)</span>不能删掉,事实上后面的<span class="math inline">\(j\)</span>爱怎么删怎么删,只要不搞出一个<span class="math inline">\(k\)</span>来就可以.因此我们需要设<span class="math inline">\(f_{i,j}\)</span>表示当前后面还有<span class="math inline">\(i\)</span>个位置,第一个位置不能是<span class="math inline">\(j\)</span>,也不能曾经是<span class="math inline">\(j\)</span>(因为这里只要是<span class="math inline">\(j\)</span>都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设<span class="math inline">\(f_{i,j}\)</span>表示后面还有<span class="math inline">\(i\)</span>个位置,第一个位置现在或曾经是过<span class="math inline">\(j\)</span>的期望.那么全集是什么呢?全集是<span class="math inline">\(ans_i\)</span>.</p>
<p>还没完啊,我们还需要求一下这里是<span class="math inline">\(k\)</span>的概率,由于还有一个类似的<span class="math inline">\(f\)</span>,我们还要求一下这里曾经是<span class="math inline">\(k\)</span>的概率.设前者为<span class="math inline">\(q_{i,k}\)</span>,后者为<span class="math inline">\(p_{i,k}\)</span>.我们来强调一下这里设计的原则:这里的<span class="math inline">\(p\)</span>其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了<span class="math inline">\(k\)</span>,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过<span class="math inline">\(k\)</span>了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是<span class="math inline">\(k\)</span>等价于这里是<span class="math inline">\(k\)</span>并且后面没有出现过<span class="math inline">\(k\)</span>,也就是<span class="math inline">\(q_{i,k}=p_{i,k}(1-p_{i-1,k}\times
[k&lt;t])\)</span>.这里加一个限制是因为有不能超过<span class="math inline">\(t\)</span>的限制.</p>
<p>对于后者,这里的<span class="math inline">\(k\)</span>有很多种可能出现过,一种是直接加入,一种是合并而来,于是<span class="math inline">\(p_{i,k}=\frac{1}{m}[k\leq
m]+p_{i,k-1}p_{i-1,k-1}\)</span>.</p>
<p>因此我们几经辗转,终于得到了<span class="math inline">\(g\)</span>的转移式子: <span class="math display">\[
q_{i,k}g_{n,k}=p_{i,k}(k+ans_{i-1}-f_{i-1,k}p_{i-1,k})
\]</span> 就差<span class="math inline">\(f\)</span>了.<span class="math inline">\(f\)</span>有两种可能:要么最后仍然是<span class="math inline">\(k\)</span>,要么这个<span class="math inline">\(k\)</span>已经被杀掉了.于是: <span class="math display">\[
p_{i,k}f_{i,k}=q_{i,k}g_{i,k}+(p_{i,k}-q_{i,k})f_{i,k+1}
\]</span></p>
<h5><span id="example2cf1007e">Example2(CF1007E)</span></h5>
<p>首先我们需要发现一个很强的性质:作用到了第<span class="math inline">\(i\)</span>个站台就会清空前面所有站台.清空后就和<span class="math inline">\(a_i\)</span>无关了,而如果还没涉及到一定和<span class="math inline">\(a_i\)</span>有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设<span class="math inline">\(f_{i,j}\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间需要的最少火车数量.<span class="math inline">\(g_{i,j}\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间,并且<span class="math inline">\([1,i-1]\)</span>全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为<span class="math inline">\(+\infty\)</span>表示无法满足(对于全局,我们在<span class="math inline">\(n+1\)</span>处放一个<span class="math inline">\(a=+\infty,b=0,c=+\infty\)</span>来保证一定会满载).为什么需要<span class="math inline">\(g\)</span>作为辅助dp数组呢?我们先对着<span class="math inline">\(f\)</span>分析.</p>
<p>考虑<span class="math inline">\(f_{i,j}\)</span>的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前<span class="math inline">\(j\)</span>轮中根本没接走站台<span class="math inline">\(i\)</span>的人.此时需要满足<span class="math inline">\(f_{i-1,j}\ne +\infty\and a_i+j\times b_i\leq
c_i\)</span>.那么这里怎么更新<span class="math inline">\(g\)</span>呢?设<span class="math inline">\(L=sa_{i-1}+sb_{i-1}\times j\)</span>,显然<span class="math inline">\(g_{i,j}=\lceil\frac{L}{K}\rceil\)</span>,并且需要保证此时没有用到<span class="math inline">\(i\)</span>以后的站台,因此需要保证<span class="math inline">\(\lceil\frac{L}{K}\rceil K\leq sa_{i}+sb_i\times
j\)</span>.注意到由于这里保证了<span class="math inline">\(f_{i-1,j}\)</span>是可以取到的,因此我们可以撑到第<span class="math inline">\(j\)</span>秒,剩下的火车在<span class="math inline">\(j+\varepsilon\)</span>秒全选.</p>
<p>第二种,前<span class="math inline">\(j\)</span>轮中有火车接走站台<span class="math inline">\(i\)</span>的人.设最后一次是在<span class="math inline">\(r\)</span>时间接走的站台<span class="math inline">\(i\)</span>,那么此时必然清空了<span class="math inline">\([1,i-1]\)</span>,这里用了<span class="math inline">\(g_{i,r}\)</span>.然后为了防止这里在<span class="math inline">\([r+1,j]\)</span>这段时间中爆掉,因此还需要<span class="math inline">\(w=\lceil\frac{\max\{0,rem+(j-r)b_i-c_i\}}{K}\rceil\)</span>,其中<span class="math inline">\(rem\)</span>是<span class="math inline">\(r\)</span>时刻<span class="math inline">\(i\)</span>剩下的人数.这些火车都要在<span class="math inline">\(r\)</span>时刻之前解决(因为我们设了最后一次在<span class="math inline">\(r\)</span>时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在<span class="math inline">\(r\)</span>这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有<span class="math inline">\(wK\leq rem\)</span>.但是,接下来在<span class="math inline">\([r+1,j]\)</span>时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设<span class="math inline">\(f_{i,j,0}\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间需要的最少火车数量,但是<span class="math inline">\([1,i]\)</span>都被清空为<span class="math inline">\(0\)</span>过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol type="1">
<li>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</li>
<li>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将<span class="math inline">\(g_{1,t,0/1}\)</span>全部设为<span class="math inline">\(0\)</span>,因为我觉得无论如何<span class="math inline">\(0\)</span>位置都是清空的,但实际上这是错误的!因为在<span class="math inline">\(t\)</span>时刻的<span class="math inline">\(1\)</span>位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前<span class="math inline">\(i\)</span>个的合法性,并且如果我们想要让<span class="math inline">\(i\)</span>位置合法,一定要求让<span class="math inline">\([1,i-1]\)</span>合法.</li>
<li>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从<span class="math inline">\(r\rightarrow
t\)</span>这个过程中会积累的量,这些量必然要在<span class="math inline">\(r\)</span>时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>定义一个有根树为大菊花,当且仅当这棵树的根的度数<span class="math inline">\(\leq m\and\nexists x\ne
root,\deg(x)&gt;2\)</span>.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.<span class="math inline">\((n\leq 5\times 10^5,m\leq 50)\)</span></p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到<span class="math inline">\(O(nm^2)\)</span>.</p>
<p>注意到这个背包是可删除的,所以就能做到<span class="math inline">\(O(nm)\)</span>.</p>
<h3><span id="dp分界点">dp分界点</span></h3>
<h4><span id="example12022zrtg十连测day7permutation">Example1(2022zrtg十连测day7
Permutation)</span></h4>
<p>首先注意到<span class="math inline">\([3,n]\)</span>一定会被分成两段递减的序列,分别跟在<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的后面,假设<span class="math inline">\(1\)</span>在<span class="math inline">\(2\)</span>前面,这样算出答案后乘以<span class="math inline">\(n\)</span>即可.</p>
<p>注意到<span class="math inline">\(i+1\)</span>一定可以放到<span class="math inline">\(i\)</span>的前面,设<span class="math inline">\(f_i\)</span>表示在<span class="math inline">\(i\)</span>和<span class="math inline">\(i+1\)</span>之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即<span class="math inline">\(i\)</span>的倍数<span class="math inline">\(\pm
1\)</span>之类的,于是可以实现,复杂度<span class="math inline">\(O(n\ln
n)\)</span>.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3>
<h4><span id="example1cf1666e">Example1(CF1666E)</span></h4>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移: <span class="math display">\[
f_{i+1}=\max\{a_{i+1},f_i+mn\}\\
g_{i+1}=\min\{a_{i+2},g_i+mx\}\\
\]</span> 注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([f_i,g_i]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{i}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ans_{i+1}-mx,ans_{i+1}-mn]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([f_i,g_i]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{i+1}-mn&lt;f_i,f_{i+1}&lt;ans_{i+1}&lt;f_i+mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx-mn\)</span>.</p>
<h3><span id="数位dp">数位dp</span></h3>
<h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4>
<p>首先设<span class="math inline">\(f_{i,j}\)</span>表示长度为<span class="math inline">\(i\)</span>的,以<span class="math inline">\(S[n-j+1...n]\)</span>为子序列的字符串个数.</p>
<p>考虑按位处理,每次将<span class="math inline">\(T\)</span>的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出<span class="math inline">\(k\)</span>.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为<span class="math inline">\(k\)</span>.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4>
<p>第一反应就是枚举<span class="math inline">\(x&#39;\)</span>和<span class="math inline">\(y&#39;\)</span>,然后用数位dp枚举<span class="math inline">\(d\)</span>使得<span class="math inline">\(x=dx&#39;,y=dy&#39;\)</span>.</p>
<p>但是有一个问题在于如果<span class="math inline">\(\gcd(x&#39;,y&#39;)\ne
1\)</span>怎么办,这样有可能会算重.我们发现我们只判断<span class="math inline">\(\gcd(x&#39;,y&#39;)=1\)</span>的情况就行,然后写一个<span class="math inline">\(2^8\)</span>判断<span class="math inline">\(x&#39;,2x&#39;,3x&#39;,4x&#39;\)</span>以及对应的<span class="math inline">\(y&#39;\)</span>出现了没有.复杂度<span class="math inline">\((9^4\times 2^8\times
\log_{10}n)\)</span>,有点难过.</p>
<p>但是我们发现这个<span class="math inline">\(2^8\)</span>可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有<span class="math inline">\(3^4\times 2\)</span>的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3>
<h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4>
<p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是<span class="math inline">\(O(nd^2)\)</span>的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是<span class="math inline">\(O(nd)\)</span>的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取<span class="math inline">\(\min\)</span>转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>现在有一个<span class="math inline">\([1,n]\)</span>的排列,现在要从中选出一个集合<span class="math inline">\(S\)</span>,满足<span class="math inline">\(\forall
x\in S,2x\notin S,3x\notin S\)</span>,求方案数.</p>
<p>首先考虑将每个数分解为<span class="math inline">\(a\times 2^b\times
3^c\)</span>的形式,显然<span class="math inline">\(a\)</span>不相同的数之间互不干扰.</p>
<p>对于<span class="math inline">\(a\)</span>相同的一群数,我们考虑将<span class="math inline">\((b,c)\)</span>作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3>
<h4><span id="example1">Example1</span></h4>
<p><span class="math inline">\(n\)</span>个点的树,一开始位于一号点,每个点有一个颜色(<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>),每次随机选择一个点<span class="math inline">\(v\)</span>,从当前所在点移动到<span class="math inline">\(v\)</span>并将<span class="math inline">\(v\)</span>的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为<span class="math inline">\(1\)</span>,当然不为<span class="math inline">\(1\)</span>也能做).</p>
<p><span class="math inline">\(n\leq 100000\)</span>.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>就可以.不妨设<span class="math inline">\(f_{i}\)</span>表示当前有<span class="math inline">\(i\)</span>个点是<span class="math inline">\(1\)</span>,最后全<span class="math inline">\(1\)</span>或者全<span class="math inline">\(0\)</span>所需要的期望步数,显然<span class="math inline">\(f_0=f_n=0\)</span>,<span class="math inline">\(f_{i}=\frac{1}{2}(f_{i+1}+f_{i-1})+1\)</span>.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在<span class="math inline">\(u\)</span>,只要当前没有结束,我们还要选点<span class="math inline">\(v\)</span>,对答案的期望的贡献就是<span class="math inline">\(u\)</span>到这棵树上所有点的距离之和除以<span class="math inline">\(n\)</span>,而这是一个定值.也就是说,只要我们统计一下到了每个点<span class="math inline">\(u\)</span>多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设<span class="math inline">\(f_{i,j,0/1}\)</span>表示当前场面上有<span class="math inline">\(i\)</span>个<span class="math inline">\(1\)</span>,<span class="math inline">\(j\)</span>号点这里是<span class="math inline">\(0\)</span>还是<span class="math inline">\(1\)</span>,它在结束前能被期望选多少次,注意<span class="math inline">\(f_{n/0,j,0/1}=0\)</span>.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设<span class="math inline">\(f_{i,0/1}\)</span>表示当前有<span class="math inline">\(i\)</span>个<span class="math inline">\(1\)</span>,<span class="math inline">\(0/1\)</span>染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移: <span class="math display">\[
f_{0/n,0/1}=0\\
f_{i,0}=\frac{i}{n}f_{i-1,0}+\frac{n-i-1}{n}f_{i+1,0}+\frac{1}{n}(f_{i+1,1}+[i+1\ne
n])\\
f_{i,1}=\frac{i-1}{n}f_{i-1,1}+\frac{n-i}{n}f_{i+1,1}+\frac{1}{n}(f_{i-1,0}+[i-1\ne
0])
\]</span> 为啥最后加上了<span class="math inline">\([i+1\ne
n]\)</span>呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了<span class="math inline">\(f_{i,0/1}\)</span>和<span class="math inline">\(f_{i-1,0/1}\)</span>,我们发现我们可以用这两个方程求出<span class="math inline">\(f_{i+1,0/1}\)</span>,然后就比较典了:我们将所有的函数表示成<span class="math inline">\(af_{1,0}+bf_{1,1}+c\)</span>的形式(之所以这么表示,是因为我们架设了<span class="math inline">\(f_{1,0/1}\)</span>已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出<span class="math inline">\(f_{n,0/1}\)</span>,而<span class="math inline">\(f_{n,0/1}\)</span>我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3>
<h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4>
<p>首先注意到,<span class="math inline">\(a_i=1\)</span>的时候和<span class="math inline">\(a_i\ne
1\)</span>的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设<span class="math inline">\(f_i\)</span>为<span class="math inline">\(a_i=1\)</span>,而其他<span class="math inline">\(a\)</span>全都为<span class="math inline">\(0\)</span>时的答案,不难发现最后的答案也就是<span class="math inline">\(\sum{a_if_i}\)</span>.</p>
<p>而上面的转移自然是:<span class="math inline">\(f_i=\min\{b_i,w+\sum_{j=l}^rf_j\}\)</span>.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次<span class="math inline">\(f_i\)</span>最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查<span class="math inline">\(\log n\)</span>次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5>
<p>考虑组合意义,<span class="math inline">\(\sum
a_i^2\)</span>的意义也即满足操作序列<span class="math inline">\(u\)</span>和操作序列<span class="math inline">\(v\)</span>的最终结果相同的二元组<span class="math inline">\((u,v)\)</span>的数量.</p>
<p>不妨设<span class="math inline">\(dp_{i,j,k}\)</span>为第一个装置上方已经动了<span class="math inline">\(i\)</span>个珠子,下放动了<span class="math inline">\(j\)</span>个珠子,第二个装置上方动了<span class="math inline">\(k\)</span>个珠子,下方动了<span class="math inline">\(i+j-k\)</span>个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然<span class="math inline">\(dp_{n,m,n}\)</span>即答案.</p>
<h5><span id="example2">Example2</span></h5>
<p>求长度为<span class="math inline">\(n\)</span>的排列的<span class="math inline">\((\sum_{i=2}^{n-1}[a_i&lt;a_{i-1}\And
a_i&lt;a_{i+1}])^k\)</span>的期望<span class="math inline">\((n\leq
10^9,k\leq 500)\)</span>.</p>
<p><span class="math inline">\(O(n^2k^2)\)</span>是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是<span class="math inline">\(\sum
ans^k\)</span>,而加入<span class="math inline">\(1\)</span>的时候,对于每个长度为<span class="math inline">\(n-1\)</span>的排列,有<span class="math inline">\((n-2-2ans)\)</span>个位置加入后会使答案加一,那我们要求的也就是:
<span class="math display">\[
\sum(n-1-2ans)(ans+1)^k+\sum(2ans+2)ans^k
\]</span> 推一推式子就可以做到<span class="math inline">\(O(nk^2)\)</span>,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,<span class="math inline">\(ans^k\)</span>等价于从所有的地方中可重复地选出<span class="math inline">\(k\)</span>个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为<span class="math inline">\(1\)</span>的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设<span class="math inline">\(f_{i,j}\)</span>表示已经选了<span class="math inline">\(i\)</span>段波动序列,其中有<span class="math inline">\(j\)</span>个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度<span class="math inline">\(O(k^3)\)</span>.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>求<span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^n(a_i\oplus
a_j)^2\)</span>,<span class="math inline">\(n\leq 10^5\)</span>,<span class="math inline">\(a_i\leq 10^9\)</span>.</p>
<p>考虑设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>低的位置,高位全部默认为<span class="math inline">\(0\)</span>的方案数.如果我们设<span class="math inline">\(cnt_i\)</span>表示<span class="math inline">\(a\)</span>中第<span class="math inline">\(i\)</span>位为<span class="math inline">\(1\)</span>的数个数,那根据<span class="math inline">\((a+b)^2=a^2+2ab+b^2\)</span>,我们只需要求出<span class="math inline">\(g_{i}\)</span>表示只考虑前<span class="math inline">\(i\)</span>低的位置,第<span class="math inline">\(i+1\)</span>位是<span class="math inline">\(1\)</span>的数和第<span class="math inline">\(i+1\)</span>位是<span class="math inline">\(0\)</span>的数两两异或之和,显然有<span class="math inline">\(f_i=f_{i-1}+2cnt_i\times2^i\times
g_{i-1}+cnt_i2^{i+1}\)</span>.</p>
<p><span class="math inline">\(g\)</span>可以用<span class="math inline">\(O(n\log a)\)</span>的复杂度求,这样总复杂度<span class="math inline">\(O(n\log^2 a)\)</span>.</p>
<h3><span id="线头dp">线头dp</span></h3>
<h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5>
<p>令<span class="math inline">\(dp_{i,j,k}\)</span>表示目前倒到第<span class="math inline">\(i\)</span>个水杯,前面还有<span class="math inline">\(j\)</span>个延续过来的未结束的线头,目前已经选定了<span class="math inline">\(k\)</span>个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是<span class="math inline">\(O(n^5)\)</span>的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了<span class="math inline">\(O(n^4)\)</span>的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5>
<p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设<span class="math inline">\(dp_{i,0/1/2}\)</span>表示前<span class="math inline">\(i\)</span>个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212svjetlo">Example3([COCI2020-2021#2]
Svjetlo)</span></h5>
<p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设<span class="math inline">\(dp_{u,0/1,1/2}\)</span>为<span class="math inline">\(u\)</span>的状态为<span class="math inline">\(0/1\)</span>,以<span class="math inline">\(u\)</span>为根的子树内有<span class="math inline">\(1/2\)</span>个线头的方案数.注意如果子树内有<span class="math inline">\(0/2\)</span>个线头,那么会在<span class="math inline">\(u\)</span>处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此<span class="math inline">\(dp_{u,s,2}\)</span>的两个接头实际上一个位于<span class="math inline">\(u\)</span>,另一个位于<span class="math inline">\(u\)</span>的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5>
<p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设<span class="math inline">\(dp_{i,j,k}\)</span>表示目前走到<span class="math inline">\(i\)</span>,前面分成<span class="math inline">\(j\)</span>组,总贡献不超过<span class="math inline">\(k\)</span>的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489-jtravel-in-sugar-country">Example5([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489) J]Travel in Sugar Country)</span></h5>
<p>一条线段上有<span class="math inline">\(n(\leq
100)\)</span>个商店,要从中选出<span class="math inline">\(k(\leq
10)\)</span>个不同的商店<span class="math inline">\(s_1,s_2,\cdots,s_k\)</span>,使得按顺序遍历这<span class="math inline">\(k\)</span>个商店的路径长度是<span class="math inline">\(m(\leq 30)\)</span>的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设<span class="math inline">\(dp_{i,j,w,l}\)</span>表示目前在判断了<span class="math inline">\(i\)</span>个商店,选了<span class="math inline">\(j\)</span>个,并且目前整个图有<span class="math inline">\(w\)</span>条”路径”(连续走动),走过的路在<span class="math inline">\(\bmod m\)</span>一意义下为<span class="math inline">\(l\)</span>的方案数.最后的答案就是<span class="math inline">\(dp_{n,k,1,0}\)</span>.</p>
<p>首先,我们对每个点求出<span class="math inline">\(D(1,x)\)</span>,然后<span class="math inline">\(D(x,y)=|D(1,y)-D(1,x)|\)</span>,不难发现<span class="math inline">\(x\)</span>越大<span class="math inline">\(D(1,x)\)</span>越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的<span class="math inline">\(D\)</span>和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径(<span class="math inline">\(s_1\rightarrow
s_1\)</span>),接下来,我们每插入一个点<span class="math inline">\(x\)</span>,我们考虑它的贡献:</p>
<ol type="1">
<li>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是<span class="math inline">\(-2D(1,x)\)</span>,对方案数的贡献为<span class="math inline">\(1\)</span>.</li>
<li>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为<span class="math inline">\(0\)</span>.</li>
<li>作为中心点合并两条路径,此时对总长度的贡献为<span class="math inline">\(2D(1,x)\)</span>.</li>
</ol>
<p>这样我们就做到了<span class="math inline">\(O(n^4km)\)</span>的复杂度.如果我们加两维<span class="math inline">\(0/1\)</span>表示目前起点和终点是否加入,就可以把复杂度优化到<span class="math inline">\(O(n^2km)\)</span>.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3>
<p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4>
<p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3>
<p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4>
<p>先考虑数字两两不同的时候怎么做,我们先找到<span class="math inline">\(A\)</span>中的全局最大值所在位置和<span class="math inline">\(B\)</span>中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时<span class="math inline">\(A\)</span>取出的数量和<span class="math inline">\(B\)</span>的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把<span class="math inline">\(B\)</span>序列分成两部分,这两部分将由<span class="math inline">\(A\)</span>中相等的两部分分别生成.不妨假设这个全局最大值的位置是<span class="math inline">\(x\)</span>,那么对于<span class="math inline">\([1,x]\)</span>这一段的<span class="math inline">\(A\)</span>生成的<span class="math inline">\(B\)</span>数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的<span class="math inline">\(A\)</span>能生成的<span class="math inline">\(B\)</span>的数量.对于<span class="math inline">\([1,x+1]\)</span>则任意.</p>
<p>那么我们所需要做的就是求出<span class="math inline">\(A\)</span>的某一段删掉若干次最大值后的序列所能生成的<span class="math inline">\(B\)</span>的数量.不妨设<span class="math inline">\(dp_{l,r,i}\)</span>表示<span class="math inline">\([l,r]\)</span>中所有<span class="math inline">\(\leq i\)</span>的数字组成的序列所能生成的数量.</p>
<p>如果<span class="math inline">\([l,r]\)</span>这段区间中没有数字<span class="math inline">\(i\)</span>,那显然<span class="math inline">\(dp_{l,r,i}=dp_{l,r,i-1}\)</span>,不然,我们可以枚举两端分开的位置,那这个位置一定在数字<span class="math inline">\(i\)</span>的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4>
<p>注意到第<span class="math inline">\(n\)</span>个元素一定是山峰.所以我们考虑用第<span class="math inline">\(n\)</span>个元素分割整个区间为两部分.</p>
<p>设<span class="math inline">\(f_n\)</span>为<span class="math inline">\(n\)</span>个元素且开头为山谷的答案.枚举第<span class="math inline">\(n\)</span>个元素在位置<span class="math inline">\(k\)</span>(<span class="math inline">\(k-1\)</span>是奇数),则<span class="math inline">\(f_kf_{n-1-k}\binom{n-1}{k}\rightarrow
f_n\)</span>.</p>
<h4><span id="example3">Example3</span></h4>
<p>给定数组<span class="math inline">\(a\)</span>,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.<span class="math inline">\(n\leq 500\)</span>.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设<span class="math inline">\(f_{l,r}\)</span>为将<span class="math inline">\([l,r]\)</span>删干净后再去删<span class="math inline">\(a_{l-1},a_{r+1}\)</span>的方案数,然后枚举<span class="math inline">\([l,r]\)</span>中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairingpoints">Example4([AGC039E] Pairing
Points)</span></h4>
<p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从<span class="math inline">\(1\)</span>号点这里断开,枚举<span class="math inline">\(1\)</span>号点连接哪个点,然后就可以让<span class="math inline">\((2,2n)\)</span>这些点断开了.我们设计<span class="math inline">\(f_{i,j,k}\)</span>或<span class="math inline">\([i,j](k)\)</span>表示区间<span class="math inline">\([i,j]\)</span>中的<span class="math inline">\(k\)</span>向外连了一条边.答案是枚举<span class="math inline">\(1\)</span>号点连了哪个点,也就是<span class="math inline">\(\sum_{i=3}^{2n-1} f_{2,2n,i}\)</span>.</p>
<p>于是我们现在的问题在于如何求<span class="math inline">\(f_{i,j,k}\)</span>.由于边要联通,所以与<span class="math inline">\(k\)</span>相连的这条边必然被<span class="math inline">\([i,j]\)</span>中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为<span class="math inline">\(x\leftrightarrow
y\)</span>.这样整个区间被分为了两个部分:<span class="math inline">\([i,k](x),[k,j](y)\)</span>.但是问题并没有得到解决.因为<span class="math inline">\([i,x]\)</span>和<span class="math inline">\([y,j]\)</span>之间的确不可能出现连边了,但<span class="math inline">\([x,k]\)</span>和<span class="math inline">\([k,y]\)</span>之间仍然可能出现连边.但我们发现:在<span class="math inline">\([i,k]\)</span>中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为<span class="math inline">\(p,q\)</span>.现在整个区间被分为了三个部分:<span class="math inline">\([i,p](x),[p,q](k),[q,j](y)\)</span>,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-andremove">Example5([AGC035D] Add and
Remove)</span></h4>
<p>首先自然想到区间dp.但是难以处理的是如果一个区间<span class="math inline">\([l,r]\)</span>中间删掉一个点<span class="math inline">\(p\)</span>之后,<span class="math inline">\([l,p-1]\)</span>和<span class="math inline">\([p+1,r]\)</span>会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到<span class="math inline">\([l+1,r-1]\)</span>中最后删除的点<span class="math inline">\(p\)</span>,这样区间<span class="math inline">\([l,r]\)</span>的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除<span class="math inline">\([l+1,p-1]\)</span>的时候,对<span class="math inline">\(p\)</span>产生的贡献和删除<span class="math inline">\([p+1,r-1]\)</span>的时候对<span class="math inline">\(p\)</span>的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设<span class="math inline">\(a_l\)</span>贡献了<span class="math inline">\(x\)</span>倍,<span class="math inline">\(a_r\)</span>贡献了<span class="math inline">\(y\)</span>倍,那么由于<span class="math inline">\(a_p\)</span>会两边都贡献到,所以<span class="math inline">\(a_p\)</span>会对答案贡献<span class="math inline">\(x+y\)</span>倍.</p>
<p>于是设计一个dp是:<span class="math inline">\(f_{l,r,x,y}\)</span>表示删除<span class="math inline">\([l+1,r-1]\)</span>后,<span class="math inline">\(xa_l+ya_r\)</span>最小是多少.自然有<span class="math inline">\(f_{l,r,x,y}=\min\{f_{l,p,x,x+y}+f_{p,r,x+y,y}+(x+y)a_p\}\)</span>.</p>
<p>至于复杂度,前两维肯定是<span class="math inline">\(n^2\)</span>的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移<span class="math inline">\(n\)</span>层,因此是<span class="math inline">\(2^n\)</span>的空间,于是时间复杂度不会超过<span class="math inline">\(O(n^32^n)\)</span>,其实经过一些奇怪计算应该是不会超过<span class="math inline">\(O(2^n)\)</span>的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4>
<p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设<span class="math inline">\(f_{l,r}\)</span>表示删除<span class="math inline">\([l,r]\)</span>区间的代价.接下来我们无非要枚举<span class="math inline">\(k\)</span>,使得<span class="math inline">\(k\)</span>是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如<span class="math inline">\(l\)</span>,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果<span class="math inline">\(a_l=a_k\)</span>,那么这等价于<span class="math inline">\(f_{l+1,k-1}+[l=k-1]+f_{k+1,r}\)</span>.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4>
<p>首先考虑一下<span class="math inline">\(m=2^k-1\)</span>的情况,首先我们要判断有几个数最高位是<span class="math inline">\(1\)</span>,然后接下来判断第二位哪些数字是<span class="math inline">\(1\)</span>.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是<span class="math inline">\(1\)</span>的就一定大于最高位是<span class="math inline">\(0\)</span>的了,这两个区间就没有影响了.因此可以设<span class="math inline">\(f_{l,r,k}\)</span>表示<span class="math inline">\([l,r]\)</span>这个区间,前面已经有了<span class="math inline">\(k\)</span>个<span class="math inline">\(1\)</span>的最大贡献.</p>
<p>那么对于<span class="math inline">\(m\ne
2^k-1\)</span>的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过<span class="math inline">\(m\)</span>就行了.</p>
<h3><span id="相互独立">相互独立</span></h3>
<h5><span id="example12019zrtg十连测day1origami">Example1(2019zrtg十连测day1
origami)</span></h5>
<p>看上去很不好做,先考虑宽为<span class="math inline">\(1\)</span>怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间<span class="math inline">\([l,r]\)</span>,然后看<span class="math inline">\([1,l-1]\)</span>和<span class="math inline">\([r+1,m]\)</span>能不能折进来.也就是判断以<span class="math inline">\(r\)</span>和<span class="math inline">\(r+1\)</span>为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设<span class="math inline">\(f_i\)</span>表示能不能折成以<span class="math inline">\([1,i]\)</span>为最下层,<span class="math inline">\(g_i\)</span>表示能不能折成<span class="math inline">\([i,n]\)</span>为最下层,那<span class="math inline">\([l,r]\)</span>能折出来当且仅当<span class="math inline">\(f_r=g_l=1\)</span>,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-anedge">Example2(CF1616G Just Add an
Edge)</span></h5>
<p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如<span class="math inline">\(1\rightarrow
x\cup y\rightarrow n\)</span>,并且<span class="math inline">\(1\rightarrow x\)</span>和<span class="math inline">\(y\rightarrow n\)</span>不交,然后添加边<span class="math inline">\(x\rightarrow y\)</span>.</p>
<p>那么什么时候<span class="math inline">\(1\rightarrow
x\)</span>和<span class="math inline">\(y\rightarrow
n\)</span>没有交并且他们的并是<span class="math inline">\([1,n]\)</span>呢?考虑将<span class="math inline">\(1\rightarrow x\)</span>这条路径上的点染色为<span class="math inline">\(0\)</span>,<span class="math inline">\(y\rightarrow n\)</span>上的点染色为<span class="math inline">\(1\)</span>,由于边只有从前往后的,因此<span class="math inline">\([1,y-1]\)</span>必然为<span class="math inline">\(0\)</span>,<span class="math inline">\([x+1,n]\)</span>必然为<span class="math inline">\(1\)</span>.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了<span class="math inline">\(y\)</span>,现在想要找到<span class="math inline">\(x\)</span>,我们现在假设染色的末尾是<span class="math inline">\((i,i+1)\)</span>,也就是<span class="math inline">\(i\)</span>染色和<span class="math inline">\(i+1\)</span>的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个<span class="math inline">\(p\)</span>,满足<span class="math inline">\(p\nrightarrow p+1\)</span>,那么<span class="math inline">\(p\)</span>和<span class="math inline">\(p+1\)</span>永远不可能染同种颜色,我们直接以它为断点,自然发现<span class="math inline">\(p\)</span>的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了<span class="math inline">\(p\rightarrow
p+1\)</span>这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立<span class="math inline">\(0\)</span>和<span class="math inline">\(n+1\)</span>两个虚点,向所有点连边.</p>
<p>总之<span class="math inline">\(O(nm)\)</span>的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3>
<p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<p>#####Example1([22zr提高组十连测day3]多)</p>
<p>首先考虑已知一个序列,如何快速求它最后有几个位置不是<span class="math inline">\(0\)</span>.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其<span class="math inline">\(-1\)</span>并重复判断操作,直到为<span class="math inline">\(0\)</span>或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是<span class="math inline">\(0\)</span>相当于判断后面的已知序列的<span class="math inline">\(mex\)</span>,这个要记入状态中,于是考虑设<span class="math inline">\(dp_{i,j}\)</span>表示当前到了第<span class="math inline">\(i\)</span>个位置,后面的数的<span class="math inline">\(mex-1\)</span>是<span class="math inline">\(j\)</span>的方案数.</p>
<p>但是如果直接这么设会发现,当前<span class="math inline">\(i\)</span>的加入有可能会改变<span class="math inline">\(mex\)</span>的值,而这个改变是很难处理的,因为如果<span class="math inline">\(i\)</span>位置选择了<span class="math inline">\(j+1\)</span>这个数字,那么<span class="math inline">\(mex\)</span>要向上伸展到某一个值,而如果不选择<span class="math inline">\(j+1\)</span>,也有可能选择一个更大的值后不断落到<span class="math inline">\(j+1\)</span>,这意味着我们转移时需要枚举补上<span class="math inline">\(j+1\)</span>这个数字后的<span class="math inline">\(mex\)</span>并用刷表法转移.</p>
<p>不妨设这个数字是<span class="math inline">\(k\)</span>.如果我们插入一个数字后直接更新当前的答案,可以发现这个<span class="math inline">\(k\)</span>是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起<span class="math inline">\(mex\)</span>的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全<span class="math inline">\([j+2,k]\)</span>这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以<span class="math inline">\(2^{n}\)</span>.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5>
<p><span class="math inline">\(O(n^3)\)</span>的暴力是显然的:设<span class="math inline">\(f_{i,j,k}\)</span>表示目前考虑到第<span class="math inline">\(i\)</span>个位置,前面还有<span class="math inline">\(j\)</span>个A,已经选了<span class="math inline">\(k\)</span>个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到<span class="math inline">\(n^2\)</span>.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设<span class="math inline">\(f_{i,j}\)</span>表示目前考虑到<span class="math inline">\(i\)</span>,还需要<span class="math inline">\(j\)</span>个B才能凑齐<span class="math inline">\(c_B\)</span>个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<p>###建立双射</p>
<p>#####Example1([SDOI2010]地精部落)</p>
<p>设<span class="math inline">\(f_{i,j}\)</span>表示长度为<span class="math inline">\(i\)</span>,开头为山峰且高度为<span class="math inline">\(j\)</span>的方案数;<span class="math inline">\(g_{i,j}\)</span>表示长度为<span class="math inline">\(i\)</span>,开头为山谷且高度为<span class="math inline">\(j\)</span>的方案数.注意到这俩显然是一个双射,也就是<span class="math inline">\(f_{i,j}=g_{i,i-j+1}\)</span>.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于<span class="math inline">\(j\)</span>的数都向上平移一格,于是自然有:<span class="math inline">\(f_{i,j}=\sum_{k=1}^{j-1}g_{i-1,k}=\sum_{k=1}^{j-1}f_{i-1,i-k}\)</span>.</p>
<p>另外,这个式子可以稍微转化为:<span class="math inline">\(f_{i,j}=f_{i-1,i-j+1}+f_{i,j-1}=g_{i-1,j-1}+f_{i,j-1}\)</span>.</p>
<p>上式可以这么理解:我们讨论一下<span class="math inline">\(j\)</span>和<span class="math inline">\(j-1\)</span>是否相邻,如果相邻必然是<span class="math inline">\(j\)</span>是山峰,<span class="math inline">\(j-1\)</span>是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1group">Example2(2019zrtg十连测day1
group)</span></h5>
<p>首先注意到<span class="math inline">\(2k\leq n\and nk\leq
10^5\)</span>,不难发现<span class="math inline">\(k\leq
500\)</span>.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到<span class="math inline">\(O(nk^2)\)</span>.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点<span class="math inline">\(w\)</span>,使得成为组长的经验<span class="math inline">\(\geq w\)</span>,成为组员的经验<span class="math inline">\(\leq w\)</span>,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5>
<p>双序列计数,考虑把<span class="math inline">\(x\)</span>双射到某个东西上.</p>
<p>考虑最后的图一定是个<span class="math inline">\(DAG\)</span>,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设<span class="math inline">\(dp_{l,r,mx}\)</span>表示只考虑<span class="math inline">\([l,r]\)</span>这一段的线段,然后最大值所在位置需要<span class="math inline">\(\geq
mx\)</span>的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3>
<p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweightedincreasing-subsequences">Example1([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<h2><span id="动态规划的优化">动态规划的优化</span></h2>
<h3><span id="递进转移">递进转移</span></h3>
<p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5>
<p>有<span class="math inline">\(m\)</span>种礼物,每种礼物有无数个(有有限个也能做),<span class="math inline">\(n\)</span>个朋友,第<span class="math inline">\(i\)</span>个朋友喜欢第<span class="math inline">\(j\)</span>个礼物的概率是<span class="math inline">\(p_{i,j}\)</span>,<span class="math inline">\(\forall i,\sum p_{i,j}=1\)</span>.</p>
<p>现在你可以选<span class="math inline">\(n\)</span>件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p><span class="math inline">\(n\leq 3000,m\leq 300\)</span>.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出<span class="math inline">\(g_{i,j}\)</span>表示第<span class="math inline">\(i\)</span>种礼物一共选了<span class="math inline">\(j\)</span>个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么<span class="math inline">\(g\)</span>怎么求呢?这个是简单的,我们设<span class="math inline">\(f_{i,j}\)</span>表示喜欢第<span class="math inline">\(i\)</span>种礼物的人有<span class="math inline">\(j\)</span>个的概率,不难发现<span class="math inline">\(g_{i,j}=\sum_{k=0}^n\min\{j,k\}f_{i,k}\)</span>.递推式就有<span class="math inline">\(g_{i,j}=g_{i,j-1}+\sum_{k=j}^nf_{i,k}\)</span>.<span class="math inline">\(f\)</span>同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是<span class="math inline">\(O(n^2m)\)</span>的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现<span class="math inline">\(g_{i,j}\)</span>满足四边形不等式,而其转移是经典的<span class="math inline">\(k\)</span>点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于<span class="math inline">\(g_i\)</span>是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为<span class="math inline">\(c_i\)</span>,每次选当前<span class="math inline">\(g_{i,c_i+1}-g_{i,c_i}\)</span>最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为<span class="math inline">\(c_i\)</span>越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度<span class="math inline">\(O(n^2\log n)\)</span>,不太确定有没有<span class="math inline">\(O(n^2)\)</span>的做法.</p>
<p>但是第二个背包,也就是<span class="math inline">\(f\)</span>怎么求呢?我们发现我们没有必要把<span class="math inline">\(g\)</span>全都求出来,只需要求目前需要的一部分就可以了,由于<span class="math inline">\(\sum
f=1\)</span>,因此后缀和可以改为前缀和,考虑到每往后推一位是<span class="math inline">\(O(n)\)</span>的,但是只会往后推总共<span class="math inline">\(O(n)\)</span>位,因此这里复杂度<span class="math inline">\(O(n^2)\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>给一个字符串,求一个最大长度<span class="math inline">\(L\leq
\frac{n}{2}\)</span>,使得前<span class="math inline">\(L\)</span>个字符与后<span class="math inline">\(L\)</span>个字符循环同构.</p>
<p>不难发现循环同构一定长这样: <span class="math display">\[
ABSBA
\]</span> 我们枚举<span class="math inline">\(A\)</span>的长度,然后就只需要求<span class="math inline">\(B\)</span>,设<span class="math inline">\(f_{i}\)</span>表示字符串去掉开头和结尾的<span class="math inline">\(i\)</span>个字符后的border,有<span class="math inline">\(f_{i-1}\leq f_i+1\)</span>.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3>
<p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个<span class="math inline">\(k\)</span>暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取<span class="math inline">\(\max\)</span>操作很艰难.但如果!我把这个dp反过来,我设<span class="math inline">\(f_{i,j}\)</span>表示<strong>从后往前</strong>dp到<span class="math inline">\(i\)</span>,当前的最大前缀和是<span class="math inline">\(j\)</span>的概率是多少,这个dp的转移极其简单: <span class="math display">\[
P\times f_{i,j}\rightarrow f_{i-1,\max\{0,j+a_{i-1}\}}
\]</span> 最后在<span class="math inline">\(f_{1,j}\)</span>处乘上<span class="math inline">\(h_j\)</span>.</p>
<p>但是这样是<span class="math inline">\(O(n^3)\)</span>的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设<span class="math inline">\(g_{i,j}\)</span>表示如果初始只有<span class="math inline">\(f_{i,j}=1\)</span>,dp到最后的答案是多少.于是只需要:
<span class="math display">\[
P\times g_{i-1,\max\{0,j+a_{i-1}\}}\rightarrow g_{i,j}\\
\]</span> 我认真考虑过这个<span class="math inline">\(P\)</span>应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些<span class="math inline">\(P\)</span>变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3>
<h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4>
<p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于<span class="math inline">\(200\)</span>.也就是说转移矩阵大概是<span class="math inline">\(200\times 200\)</span>的,设状态数为<span class="math inline">\(S\)</span>.</p>
<p>继续考虑,如果直接做的话复杂度是<span class="math inline">\(O(TS^3\log
n)\)</span>,过不了.</p>
<p>我们考虑将一个<span class="math inline">\(n\)</span>在<span class="math inline">\(w\)</span>进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了<span class="math inline">\(O(wS^3\log_wn+TS^2\log_w
n)\)</span>,平衡一下复杂度即可,大概取<span class="math inline">\(w=4\)</span>会比较优秀.</p>
<h4><span id="example2noionline3提高组魔法值">Example2([NOI
Online#3提高组]魔法值)</span></h4>
<p>重新定义矩阵乘法:用<span class="math inline">\(\oplus\)</span>替换原本的<span class="math inline">\(+\)</span>,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4>
<p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令<span class="math inline">\(f_i=\sum_{j,a_j=a_i-1}f_j\)</span>,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的<span class="math inline">\(\sum\)</span>的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的<span class="math inline">\(f\)</span>.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设<span class="math inline">\(f_{i,j}\)</span>表示所有<span class="math inline">\(a_x=i\)</span>的<span class="math inline">\(x\)</span>中第<span class="math inline">\(j\)</span>小的<span class="math inline">\(x\)</span>的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4>
<p>注意到<span class="math inline">\(m\)</span>和<span class="math inline">\(k\)</span>很小,这一定是突破口.</p>
<p>又注意到如果<span class="math inline">\(a_{i+1}&gt;a_i\)</span>,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字<span class="math inline">\(x+1\)</span>,我们考虑它只能插入<span class="math inline">\([x+1-m,x]\)</span>后面,我们直接用一个二进制数<span class="math inline">\(S\)</span>表示<span class="math inline">\([x+1-m,x]\)</span>中的数字是否存在,然后就可以在转移上直接调用<span class="math inline">\(popcount(S)\)</span>.设<span class="math inline">\(dp_{i,j,S}\)</span>表示目前考虑完了数字<span class="math inline">\(i\)</span>,插入了<span class="math inline">\(j\)</span>个数字,存在情况是<span class="math inline">\(S\)</span>.直接对它做矩阵加速就可以做到<span class="math inline">\(O((2^mk)^3\log n)\)</span>.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4>
<p>设<span class="math inline">\(dp_{i,j}\)</span>表示第<span class="math inline">\(i\)</span>天走到城市<span class="math inline">\(j\)</span>的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上<span class="math inline">\(k\)</span>.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3>
<p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4>
<p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设<span class="math inline">\(f_{l,r}\)</span>表示<span class="math inline">\(a_l\)</span>和<span class="math inline">\(a_r\)</span>必选的前提下,<span class="math inline">\([l,r]\)</span>这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设<span class="math inline">\(dp_{i,j}\)</span>表示前<span class="math inline">\(i\)</span>个点,最大值为<span class="math inline">\(j\)</span>的方案数,不难发现最后一个矩阵的最小值一定是<span class="math inline">\(a_{i}\)</span>.然后<span class="math inline">\(dp_{a,b}=\sum_{i&lt;
a,j&lt;b}dp_{i,j}f_{i+1,a}\)</span>.</p>
<p>这个转移是<span class="math inline">\(n^4\)</span>的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到<span class="math inline">\(n^2\)</span>,这样我们就得到了一个复杂度<span class="math inline">\(O(n^3)\)</span>的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点<span class="math inline">\(i\)</span>,它所在矩阵的最左边的点<span class="math inline">\(k\)</span>,最右边的点<span class="math inline">\(k\)</span>,然后此时的答案为<span class="math inline">\(pre[j-1][a[k]-1]\times nxt[k+1][a[j]+1]\times
f[j][i]\times f[i][k]\)</span>.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设<span class="math inline">\(g_{i,j}\)</span>为接下来我们要选<span class="math inline">\([i,j]\)</span>,<span class="math inline">\(i\)</span>是矩阵左端点,<span class="math inline">\(j\)</span>任意且这两个点必在矩阵中,左右两边的方案数.初始条件<span class="math inline">\(g_{i,j}=pre[i-1][a[j]-1]\times
nxt[j+1][a[i]+1]\)</span>.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3>
<h4><span id="example2022zrtg十连测day7zero">Example(2022zrtg十连测day7
Zero)</span></h4>
<p>设<span class="math inline">\(k=\max\{i,j\}\)</span>,首先可以求出<span class="math inline">\(x,y,z\)</span>分别表示:</p>
<ol type="1">
<li><span class="math inline">\(x\)</span>:只包含第一行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(-1\)</span>.</li>
<li><span class="math inline">\(y\)</span>:只包含第二行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(-1\)</span>.</li>
<li><span class="math inline">\(z\)</span>:同时包含两行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(-1\)</span>.</li>
</ol>
<p>那么自然有转移: <span class="math display">\[
f(i,k)\leftarrow \max\{f(i,k-1),f(i,y)+1\}\\
f(k,j)\leftarrow \max\{f(k-1,j),f(x,j)+1\}\\
f(k,k)\leftarrow \max\{f(k,k-1),f(k-1,k),f(z,z)+1\}
\]</span> 转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到<span class="math inline">\(f(i,k)\)</span>关于<span class="math inline">\(i\)</span>不降,于是显然当<span class="math inline">\(f(i,y)\ne f(i,k-1)\)</span>的时候才会由<span class="math inline">\(f(i,y)+1\)</span>转移过来.我们不妨设<span class="math inline">\(p_i\)</span>表示最小的位置满足<span class="math inline">\(f(i,p_i)=f(i,k-1)\)</span>,那转移也就是<span class="math inline">\(f(i,k)\leftarrow f(i,k-1)+[p_i\leq
y]\)</span>.并且每进行一次转移,都会满足<span class="math inline">\(p_i\leq y\)</span>的<span class="math inline">\(p_i\)</span>设为<span class="math inline">\(k\)</span>.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的<span class="math inline">\(i\)</span>在当前<span class="math inline">\(k\)</span>的<span class="math inline">\(f\)</span>值,将这个点放到<span class="math inline">\(p_i\)</span>位置上.然后我们每次找到<span class="math inline">\(y\)</span>并把所有在<span class="math inline">\(y\)</span>位置前的点都合并到<span class="math inline">\(k\)</span>这个点上,并打一个加法<span class="math inline">\(tag\)</span>,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的<span class="math inline">\(p_k\)</span>.</p>
<p>最后还需要处理一下<span class="math inline">\(f_{k,k}\)</span>,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照<span class="math inline">\(\max\{i,j\}\)</span>为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3>
<p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5>
<p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是<span class="math inline">\(\nexists 1\leq i&lt;j&lt;k\leq n\)</span>,<span class="math inline">\(a_i&gt;a_j&gt;a_k\)</span>.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是<span class="math inline">\(dp_{i,j}\)</span>表示现在做到<span class="math inline">\(i\)</span>,另一个上升子序列的终点是<span class="math inline">\(j\)</span>,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在<span class="math inline">\(i\)</span>一定的情况下,<span class="math inline">\(j\)</span>的值越小越容易满足.所以设<span class="math inline">\(dp_i\)</span>表示一个上升子序列的终点是<span class="math inline">\(i\)</span>,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5>
<p>首先自然的设计是<span class="math inline">\(dp_{l,r,u,d}\)</span>,然后优化一下就是<span class="math inline">\(O(n^4)\)</span>.然后咋做?</p>
<p>注意到答案不超过<span class="math inline">\(\log\)</span>级别,所以设<span class="math inline">\(dp_{l,r,u,c}\)</span>表示答案为<span class="math inline">\(c\)</span>的时候,最大的<span class="math inline">\(d\)</span>是多少.然后就<span class="math inline">\(O(n^3\log n)\)</span>.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数<span class="math inline">\(a_i\)</span>减去<span class="math inline">\([1,a_i]\)</span>中的一个数字,减成<span class="math inline">\(0\)</span>就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.<span class="math inline">\((n\leq 2000)\)</span></p>
<p>先考虑一个<span class="math inline">\(O(n^2a^2)\)</span>的dp,比较显然,因为一个人取数显然要么取<span class="math inline">\(1\)</span>要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设<span class="math inline">\(dp_{l,r,x,y}\)</span>表示目前Alice在取第<span class="math inline">\(l\)</span>堆,Bob在取第<span class="math inline">\(r\)</span>堆,第<span class="math inline">\(l\)</span>堆为<span class="math inline">\(x\)</span>,第<span class="math inline">\(r\)</span>堆为<span class="math inline">\(y\)</span>的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把<span class="math inline">\(a\)</span>存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是<span class="math inline">\(1\)</span>还是更大的数好像无所谓.那:如果<span class="math inline">\(a_1=x\)</span>的时候,Alice能赢,那<span class="math inline">\(a_1=x+1\)</span>的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选<span class="math inline">\(1\)</span>,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于<span class="math inline">\(a_l\)</span>或<span class="math inline">\(a_r\)</span>.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存<span class="math inline">\(0/1\)</span>是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设<span class="math inline">\(dp_{l,r}\)</span>表示当前Alice在<span class="math inline">\(l\)</span>,Bob在<span class="math inline">\(r\)</span>,Bob还没动<span class="math inline">\(a_r\)</span>的前提下,<span class="math inline">\(a_l\)</span>至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较<span class="math inline">\(dp_{1,1}\)</span>和<span class="math inline">\(a_1\)</span>的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选<span class="math inline">\(l\)</span>,Bob开始选<span class="math inline">\(r\)</span>,那Alice的获胜条件显然是<span class="math inline">\(dp_{l,r}\leq a_r\)</span></p>
<p>如果可以全选(也就是Alice开始选<span class="math inline">\(l+1\)</span>,Bob开始选<span class="math inline">\(r\)</span>的时候Alice能赢),就直接让<span class="math inline">\(dp_{l,r}=1\)</span>.不然,由于清空堆的人要输,所以Alice为了不输,必须要让<span class="math inline">\(dp_{l,r-1}\)</span>也满足条件,一个自然的想法是<span class="math inline">\(dp_{l,r-1}+a_r+1\)</span>,但是这个值好像没有必要:因为Bob并不是只有会不断清空<span class="math inline">\(a_r\)</span>的,如果目前的<span class="math inline">\([l+1,r]\)</span>这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢<span class="math inline">\([l+1,r]\)</span>的值,Bob就必须全清空,所以如果我们设<span class="math inline">\(g_{l,r}\)</span>是Bob的<span class="math inline">\(dp\)</span>数组,那其实这里应该是<span class="math inline">\(a_r+1+dp_{l,r-1}-g_{l+1,r}\)</span>,因为Bob的策略一定是一步一步走到<span class="math inline">\(g_{l+1,r}\)</span>后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5>
<p>自然的想法是<span class="math inline">\(dp_{i,j}\)</span>表示<span class="math inline">\(i\)</span>子树内划分成<span class="math inline">\(j\)</span>个连通块是否合法,然后我们发现如果<span class="math inline">\(j\)</span>满足条件,那么<span class="math inline">\(j+2\)</span>一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3>
<p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于<span class="math inline">\(y\)</span>轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5>
<p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3>
<p>能用WQS二分解决的问题通常形如:需要在<span class="math inline">\(n\)</span>个物品中选择恰好<span class="math inline">\(m\)</span>个,使得最后答案最大.并且如果令<span class="math inline">\(f_i\)</span>表示选了<span class="math inline">\(i\)</span>个的最大答案,<span class="math inline">\(f_i\)</span>必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数<span class="math inline">\(C\)</span>,每选择一个物品就减去<span class="math inline">\(C\)</span>的答案.不难发现这样我们一定能逼近<span class="math inline">\(f_m\)</span>.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3>
<p>对于定义在<span class="math inline">\(\mathbb{Z}\)</span>上的二元函数<span class="math inline">\(w\)</span>,若对定义域上任意<span class="math inline">\(a,b,c,d(a\leq b\leq c\leq d)\)</span>都有<span class="math inline">\(w(a,c)+w(b,d)\leq
w(a,d)+w(b,c)\)</span>,也就是交叉小于包含,则称函数<span class="math inline">\(w\)</span>满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:<span class="math inline">\(w\)</span>所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于<span class="math inline">\(0\)</span>.</p>
<p>如果它还满足<span class="math inline">\(\forall 1\leq l&#39;\leq
l\leq r\leq r&#39;\leq n,w(l,r)\leq
w(l&#39;,r&#39;)\)</span>，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理<span class="math inline">\(\min\)</span>型dp的问题,对于<span class="math inline">\(\max\)</span>型dp需要取相反数改成<span class="math inline">\(\min\)</span>.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4>
<p>#####定理1</p>
<p>若二元函数<span class="math inline">\(w(x,y)\)</span>满足<span class="math inline">\(w(a,b)+w(a+1,b+1)\leq
w(a,b+1)+w(a+1,b)\)</span>.其中<span class="math inline">\(a&lt;a+1\leq
b&lt;b+1\)</span>,则<span class="math inline">\(w\)</span>满足四边形不等式.</p>
<p>证明:</p>
<p>对于<span class="math inline">\(a+1&lt;c\)</span> 有 <span class="math display">\[
w(a,c)+w(a+1,c+1)\leq w(a,c+1)+w(a+1,c)\\
w(a+1,c+1)\leq w(a,c+1)+w(a+1,c)-w(a,c)\\
\]</span> 同时有: <span class="math display">\[
w(a+1,c)+w(a+2,c+1)\leq w(a+1,c+1)+w(a+2,c)\\
w(a+1,c)+w(a+2,c+1)-w(a+2,c)\leq w(a+1,c+1)\\
\]</span> 联立得到: <span class="math display">\[
w(a+1,c)+w(a+2,c+1)-w(a+2,c)\leq w(a,c+1)+w(a+1,c)-w(a,c)\\
w(a+2,c+1)+w(a,c)\leq w(a+1,c)+w(a+2,c+1)
\]</span> 同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个<span class="math inline">\(2\times
2\)</span>的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5>
<p>若<span class="math inline">\(w_1(l,r),w_2(l,r)\)</span>满足四边形不等式(或区间包含单调性),则<span class="math inline">\(\forall c_1,c_2\geq 0\)</span>,<span class="math inline">\((c_1w_1+c_2w_2)\)</span>满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若<span class="math inline">\(\exists f(x),g(x)\)</span>使得<span class="math inline">\(w(l,r)=f(r)-g(l)\)</span>,则<span class="math inline">\(w\)</span>满足四边形恒等式.当<span class="math inline">\(f,g\)</span>单调递增时,<span class="math inline">\(w\)</span>还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>设<span class="math inline">\(h\)</span>是一个单调递增的下凸函数(一阶导数单调递增),若<span class="math inline">\(w(l,r)\)</span>满足四边形不等式和区间包含单调性,则复合函数<span class="math inline">\(h(w(l,r))\)</span>也满足四边形不等式和区间包含单调性.</p>
<p>令<span class="math inline">\(l_1\leq l_2\leq r_1\leq
r_2\)</span>,由于<span class="math inline">\(w\)</span>满足四边形不等式,于是有: <span class="math display">\[
w(l_1,r_1)+w(l_2,r_2)\leq w(l_1,r_2)+w(l_2,r_1)\\
0\leq w(l_1,r_1)-w(l_2,r_1)\leq w(l_1,r_2)-w(l_2,r_2)
\]</span> 令<span class="math inline">\(t=w(l_1,r_2)-w(l_2,r_2)\)</span>,我们有: <span class="math display">\[
w(l_1,r_1)\leq w(l_2,r_1)+t\\
w(l_1,r_2)=w(l_2,r_2)+t\\
h(w(l_1,r_1))-h(w(l_2,r_1))\leq h(w(l_2,r_1)+t)-h(w(l_2,r_1))\\
h(w(l_1,r_2))-h(w(l_2,r_2))=h(w(l_2,r_2)+t)-h(w(l_2,r_2))
\]</span> 不妨令<span class="math inline">\(\Delta
h(x)=h(x+t)-h(x)\)</span>,由于<span class="math inline">\(h\)</span>是下凸函数,所以<span class="math inline">\(\Delta h\)</span>函数单调递增.</p>
<p>那么也就有: <span class="math display">\[
h(w(l_1,r_1))-h(w(l_2,r_1))\leq \Delta h(w(l_2,r_1))\\
h(w(l_1,r_2))-h(w(l_2,r_2))=\Delta h(w(l_2,r_2))
\]</span> 由于<span class="math inline">\(w(l_2,r_1)\leq
w(l_2,r_2)\)</span>,所以<span class="math inline">\(\Delta
h(w(l_2,r_1))\leq \Delta h(w(l_2,r_2))\)</span>于是: <span class="math display">\[
h(w(l_1,r_1))-h(w(l_2,r_1))\leq h(w(l_1,r_2))-h(w(l_2,r_2))\\
h(w(l_1,r_1))+h(w(l_2,r_2))\leq h(w(l_1,r_2))+h(w(l_2,r_1))
\]</span> 证毕.</p>
<h5><span id="定理5">定理5</span></h5>
<p>设<span class="math inline">\(h\)</span>是一个下凸函数(一阶导数单调递增),若<span class="math inline">\(w(l,r)\)</span>满足四边形恒等式和区间包含单调性,则复合函数<span class="math inline">\(h(w(l,r))\)</span>也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到<span class="math inline">\(h\)</span>单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4>
<p>对于形如<span class="math inline">\(f_i=\min_{1 \leq
j&lt;i}\{f_j+w(j,i)\}\)</span>的状态转移方程,记<span class="math inline">\(p_i\)</span>为<span class="math inline">\(f_i\)</span>的最优决策.若<span class="math inline">\(p\)</span>在<span class="math inline">\([1,n]\)</span>上单调不降,则称<span class="math inline">\(f\)</span>具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的<span class="math inline">\(\min\)</span>改为<span class="math inline">\(\max\)</span>,并且把<span class="math inline">\(+w\)</span>改为<span class="math inline">\(-w\)</span>,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5>
<p>定理：对于形如<span class="math inline">\(f_i=\min_{1 \leq
j&lt;i}{f_j+w(j,i)}\)</span>的状态转移方程,若<span class="math inline">\(w\)</span>满足四边形不等式,则<span class="math inline">\(f\)</span>有决策单调性.</p>
<p>证明:</p>
<p><span class="math inline">\(\forall i\in[1,n],\forall
j\in[0,p_i-1]\)</span>,根据<span class="math inline">\(p\)</span>的定义,有: <span class="math display">\[
f_{p_i}+w(p_i,i)\leq f_j+w(j,i)\\
f_{p_i}-f_j\leq w(j,i)-w(p_i,i)\\
\]</span> 而对于<span class="math inline">\(k\in[i+1,n]\)</span>,根据<span class="math inline">\(w\)</span>的四边形不等式,有: <span class="math display">\[
w(j,i)+w(p_i,k)\leq w(j,k)+w(p_i,i)\\
w(j,i)-w(p_i,i)\leq w(j,k)-w(p_i,k)\\
\]</span> 联立得到: <span class="math display">\[
f_{p_i}-f_j\leq w(j,k)-w(p_i,k)\\
f_{p_i}+w(p_i,k)\leq w(j,k)+f_j\\
\]</span> 即:<span class="math inline">\(j\)</span>对<span class="math inline">\(k\)</span>的更新一定不如<span class="math inline">\(p_i\)</span>对<span class="math inline">\(k\)</span>的更新更优,因此<span class="math inline">\(p_k\in[p_i,n]\)</span>,因此<span class="math inline">\(f\)</span>有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6>
<p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设<span class="math inline">\(f_i\)</span>表示价值为<span class="math inline">\(i\)</span>的答案,自然有:<span class="math inline">\(f_i=\max\{f_{i-kc}+sum_{c,k}\}\)</span>.</p>
<p>如果我们把<span class="math inline">\(c\)</span>相同的分层,那这显然是一个最短路型dp,其中<span class="math inline">\(w(i,j)=sum_{c,\frac{i-j}{c}}\)</span>.</p>
<p>显然这个转移只会让<span class="math inline">\(\mod
c\)</span>相同的相互转移,于是后面的<span class="math inline">\(w(i,j)\)</span>可以理解为一段数字的和,自然满足四边形不等式(<span class="math inline">\(\max\)</span>也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5>
<p>对于形如<span class="math inline">\(f_{x,j}=\min_{i=1}^{x-1}\{f_{i,j-1}+w_{i,x}\}\)</span>的状态转移方程,若<span class="math inline">\(w\)</span>满足四边形不等式,则<span class="math inline">\(f\)</span>有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如<span class="math inline">\(f_x=\min_{i=1}^{x-1}{w_{i,x}}\)</span>,我们也可以看作<span class="math inline">\(k\)</span>点最短路型的<span class="math inline">\(k=1\)</span>的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6>
<p>令<span class="math inline">\(f(i,j)\)</span>为在第<span class="math inline">\(j\)</span>个位置建造第<span class="math inline">\(i\)</span>个基站的代价最小值,那么我们有转移: <span class="math display">\[
f(i,j)=\min_{1\leq
k&lt;j}\{f(i-1,k)+\sum_{l=k+1}^{j-1}w_l[d_l-s_l&gt;d_k][d_l+s_l&lt;d_j]+c_j\}
\]</span>
考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时<span class="math inline">\(d_k\)</span>单调递增,更新答案时<span class="math inline">\(d_j\)</span>单调递增,于是可以直接使用线段树维护,复杂度<span class="math inline">\(O(nk\log
n)\)</span>.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度<span class="math inline">\(O(nk\log^2n)\)</span>.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度<span class="math inline">\(O(n\log k\log n)\)</span>.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6>
<p>自然的设计是<span class="math inline">\(f_{i,j,k}\)</span>表示前<span class="math inline">\(i\)</span>个,已经打了<span class="math inline">\(j\)</span>个,末尾有连续<span class="math inline">\(k\)</span>个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为<span class="math inline">\(f_{i,j}\)</span>表示前<span class="math inline">\(i\)</span>个,目前打了<span class="math inline">\(j\)</span>个且第<span class="math inline">\(i\)</span>个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成<span class="math inline">\(f_{i,j}\)</span>表示前<span class="math inline">\(i\)</span>个,目前有<span class="math inline">\(j\)</span>个没打中而且第<span class="math inline">\(i\)</span>个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:<span class="math inline">\(dp_{i,j}=\max\{dp_{k,j-1}+\sum_{l=k+1}^{i-1}C_{l-k}A_l+P\}\)</span>.</p>
<p>令<span class="math inline">\(w(l,r)=\sum_{k=l+1}^{r-1}C_{k-l}A_k+P\)</span>,接下来我们证明:<span class="math inline">\(w(l+1,r)+w(l,r-1)\geq
w(l,r)+w(l+1,r-1)\)</span>即可.讨论一下每个<span class="math inline">\(A\)</span>面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5>
<p>引理:在状态转移方程<span class="math inline">\(f_{i,j}=\min_{i\leq
k&lt;j}\{f_{i,k}+f_{k+1,j}+w(i,j)\}\)</span>中(通常<span class="math inline">\(f_{i,i}=w(i,i)=0,f_{i,i+1}=w_{i,i+1}\)</span>),如果<span class="math inline">\(w\)</span>满足四边形不等式和区间包含单调性,那么<span class="math inline">\(f\)</span>也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明<span class="math inline">\(f_{i,j}+f_{i+1,j+1}\leq
f_{i,j+1}+f_{i+1,j}\)</span>即可,考虑<span class="math inline">\(j-i=1\)</span>的时候,显然成立.</p>
<p>使用数学归纳,假设当<span class="math inline">\(b-a&lt;k\)</span>时,<span class="math inline">\(f\)</span>满足四边形不等式,考虑<span class="math inline">\(j-i=k\)</span>的情况:</p>
<p>设<span class="math inline">\(f_{i,j+1}\)</span>的最优决策为<span class="math inline">\(x\)</span>,<span class="math inline">\(f_{i+1,j}\)</span>的最优决策为<span class="math inline">\(y\)</span>,则有: <span class="math display">\[
f_{i,j+1}+f_{i+1,j}=f_{i,x}+f_{x+1,j+1}+w(i,j+1)+f_{i+1,y}+f_{y+1,j}+w(i+1,j)\\
\]</span> 对于<span class="math inline">\(f_{i,j}\)</span>和<span class="math inline">\(f_{i+1,j+1}\)</span>来说,<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>不一定最优,所以有: <span class="math display">\[
f_{i,j}+f_{i+1,j+1}\leq
f_{i,x}+f_{x+1,j}+w(i,j)+f_{i+1,y}+f_{y+1,j+1}+w(i+1,j+1)\\
\]</span> <span class="math inline">\(w\)</span>和归纳假设都可以比较两个式子右边的大小,最终得到:
<span class="math display">\[
f_{i,j}+f_{i+1,j+1}\leq f_{i,j+1}+f_{i+1,j}\\
\]</span> ###### 定理</p>
<p>记<span class="math inline">\(p_{i,j}\)</span>为<span class="math inline">\(f_{i,j}\)</span>的最优决策,若<span class="math inline">\(f\)</span>满足四边形不等式,那么对于<span class="math inline">\(\forall i&lt;j，有p_{i,j-1}\leq p_{i,j}\leq
p_{i+1,j}\\\)</span>.</p>
<p>证明:</p>
<p>记<span class="math inline">\(p=p_{i,j}\)</span>,<span class="math inline">\(\forall k,i&lt;k\leq p\)</span>,因为<span class="math inline">\(f\)</span>满足四边形不等式,所以有: <span class="math display">\[
f_{i,k}+f_{i+1,p}\leq f_{i,p}+f_{i+1,k}\\
f_{i+1,p}-f_{i+1,j}\leq f_{i,p}-f_{i,k}
\]</span> 根据<span class="math inline">\(p\)</span>定义,有: <span class="math display">\[
f_{i,p}+f_{p+1,j}\leq f_{i,k}+f_{k+1,j}\\
f_{i,p}-f_{i,k}\leq f_{k+1,j}-f_{p+1,j}
\]</span> 由上两式移项联立,得到: <span class="math display">\[
f_{i+1,p}-f_{i+1,k}\leq f_{k+1,j}-f_{p+1,j}\\
f_{i+1,p}+f_{p+1,j}\leq f_{i+1,k}+f_{k+1,j}\\
f_{i+1,p}+f_{p+1,j}+w_{i+1,j}\leq f_{i+1,k}+f_{k+1,j}+w_{i+1,j}\\
\]</span> 因此对于<span class="math inline">\(f_{i+1,j}\)</span>,<span class="math inline">\(p\)</span>比任意的<span class="math inline">\(k&lt;p\)</span>更优,因此<span class="math inline">\(p_{i+1,j}\geq p_{i,j}\)</span>,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4>
<p>判断一个函数的凸性只需判断<span class="math inline">\(f(k)+f(k+2)\geq
2f(k+1)\)</span>,而这只需证明<span class="math inline">\(k\)</span>的时候的答案和<span class="math inline">\(k+2\)</span>时的答案可以调整出两个<span class="math inline">\(k+1\)</span>的答案(不一定是最小答案)并且这两个<span class="math inline">\(k+1\)</span>的答案的和小于等于<span class="math inline">\(k\)</span>时和<span class="math inline">\(k+2\)</span>时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5>
<p>首先考虑四个点<span class="math inline">\((a,b,c,d)\)</span>,注意到其一定满足四边形不等式,也就是<span class="math inline">\(w_{ac}+w_{bd}\geq w_{ad}+w_{bc}\)</span>.</p>
<p>我们现在想证明,设<span class="math inline">\(f_k\)</span>为新增<span class="math inline">\(k\)</span>个传送机后的减少的答案,我们考虑证明<span class="math inline">\(f_k+f_{k+2}\geq 2f_{k+1}\)</span>.</p>
<p>我们画出<span class="math inline">\(f_k\)</span>时选的点和<span class="math inline">\(f_{k+2}\)</span>时选的点,注意到我们可以用这两次调整出两个<span class="math inline">\(k+1\)</span>的答案,并且这两个答案的和小于等于<span class="math inline">\(f_k+f_{k+2}\)</span>,于是证明了最小的<span class="math inline">\(f_{k+1}\)</span>是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量<span class="math inline">\(w\)</span>,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于<span class="math inline">\(w\)</span>的最大的传送机数量,然后就可以做了.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中的常见套路</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#本质相同">本质相同</a>
<ul>
<li><a href="#example1">Example1</a></li>
</ul></li>
<li><a href="#排列转环">排列转环</a>
<ul>
<li><a href="#example1p8416">Example1(P8416)</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#规定转移顺序">规定转移顺序</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2p7142">Example2(P7142)</a></li>
</ul></li>
<li><a href="#复杂度均摊">复杂度均摊</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
<li><a href="#字典序相关">字典序相关</a>
<ul>
<li><a href="#example12022noip十连测day88ady">Example1([2022noip十连测day8]8ady)</a></li>
</ul></li>
<li><a href="#前缀和与差分">前缀和与差分</a>
<ul>
<li><a href="#example1loj3266">Example1(loj3266)</a></li>
<li><a href="#example2-1">Example2</a></li>
</ul></li>
<li><a href="#二分答案">二分答案</a>
<ul>
<li><a href="#example12022qbxt国庆day6kth">Example1([2022qbxt国庆Day6]kth)</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
<li><a href="#整体二分">整体二分</a>
<ul>
<li><a href="#example1agc002dstamp-rally">Example1([AGC002D]Stamp
Rally)</a></li>
<li><a href="#example1平面最近点对">Example1(平面最近点对)</a></li>
<li><a href="#example2cf1764g3-doremys-perfect-ds-class-hard-version">Example2([CF1764G3]
Doremy’s Perfect DS Class (Hard Version))</a></li>
<li><a href="#example3xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopentraisn-contest-1489d-nice-set-of-points">Example3(XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(opentraisn
contest 1489)D Nice Set of Points)</a></li>
<li><a href="#example4cf1442dsum">Example4([CF1442D]Sum)</a></li>
<li><a href="#example5agc044d">Example5(AGC044D)</a></li>
</ul></li>
<li><a href="#倍增">倍增</a>
<ul>
<li><a href="#example1scoi2015国旗计划">Example1([SCOI2015]国旗计划)</a></li>
<li><a href="#example4loj3665">Example4(loj3665)</a></li>
<li><a href="#example5cf1707e">Example5(CF1707E)</a></li>
<li><a href="#example622zr提高组十连测day6百分号">Example6([22zr提高组十连测day6]百分号)</a></li>
</ul></li>
<li><a href="#对称建立双射">对称/建立双射</a>
<ul>
<li><a href="#example1cf1627f">Example1(CF1627F)</a></li>
<li><a href="#example2ah2017hnoi2017抛硬币">Example2([AH2017/HNOI2017]抛硬币)</a></li>
<li><a href="#example4arc115d">Example4(ARC115D)</a></li>
<li><a href="#example5hihocoder1230">Example5(Hihocoder1230)</a></li>
<li><a href="#example623省选10连测-day5b">Example6(23省选10连测
day5B)</a></li>
</ul></li>
<li><a href="#拆多项式">拆多项式</a>
<ul>
<li><a href="#example122zr提高组十连测day5可">Example1([22zr提高组十连测day5]可)</a></li>
</ul></li>
<li><a href="#抽屉原理">抽屉原理</a>
<ul>
<li><a href="#example1unr-6小火车">Example1([UNR #6]小火车)</a></li>
<li><a href="#example2noi2021量子通信">Example2([NOI2021]量子通信)</a></li>
</ul></li>
<li><a href="#拆贡献">拆贡献</a>
<ul>
<li><a href="#example12022qbxt国庆day7fenwick">Example1([2022qbxt国庆Day7]fenwick)</a></li>
<li><a href="#example2qoj5097-小-p-爱学习">Example2([QOJ5097] 小 P
爱学习)</a></li>
<li><a href="#example3luogu4211-lnoi2014lca">Example3(Luogu4211
[LNOI2014]LCA)</a></li>
</ul></li>
<li><a href="#二进制拆位">二进制拆位</a>
<ul>
<li><a href="#example1luogu5354-ynoi2017由乃的oj">Example1(Luogu5354
[Ynoi2017]由乃的OJ)</a></li>
</ul></li>
<li><a href="#bitset优化暴力">bitset优化暴力</a>
<ul>
<li><a href="#example12022qbxt国庆day4d">Example1([2022qbxt国庆Day4]D)</a></li>
<li><a href="#example2noi2020-制作菜品">Example2([NOI2020]
制作菜品)</a></li>
</ul></li>
<li><a href="#简化能更新答案的集合">简化能更新答案的集合</a>
<ul>
<li><a href="#example1cf1149d-abandoning-roads">Example1(CF1149D
Abandoning Roads)</a></li>
<li><a href="#example2-3">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-ccombinations-strike-back">Example4([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435)
C]Combinations Strike Back)</a></li>
<li><a href="#example5cf1621gweighted-increasing-subsequences">Example5([CF1621G]Weighted
Increasing Subsequences)</a></li>
<li><a href="#example6cf919f-a-game-with-numbers">Example6(CF919F A Game
With Numbers)</a></li>
<li><a href="#example7ioi2014holiday">Example7([IOI2014]holiday)</a></li>
<li><a href="#example8cf1446d2">Example8(CF1446D2)</a></li>
<li><a href="#支配对问题">支配对问题</a>
<ul>
<li><a href="#第一类支配对">第一类支配对</a>
<ul>
<li><a href="#example1luogup7880-ynoi2006-rldcot">Example1(luoguP7880
[Ynoi2006] rldcot)</a></li>
<li><a href="#example2luogup8528-ynoi2003-铃原露露">Example2(luoguP8528
[Ynoi2003] 铃原露露)</a></li>
</ul></li>
<li><a href="#第二类支配对">第二类支配对</a>
<ul>
<li><a href="#example1cf765f">Example1(CF765F)</a></li>
<li><a href="#example2codechef-minxorseg">Example2(CodeChef
MINXORSEG)</a></li>
<li><a href="#example3luogu9058-ynoi2004-rpmtdq">Example3(Luogu9058
[Ynoi2004] rpmtdq)</a></li>
<li><a href="#example4cf1635f-closest-pair">Example4(CF1635F Closest
Pair)</a></li>
<li><a href="#example5icpc2017-wfmoney-for-nothing">Example5([ICPC2017
WF]Money for nothing)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#奇偶染色">奇偶染色</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
<li><a href="#example2cf1521e">Example2(CF1521E)</a></li>
<li><a href="#example3cf1615f">Example3(CF1615F)</a></li>
<li><a href="#example4cf1517g">Example4(CF1517G)</a></li>
</ul></li>
<li><a href="#捆绑更新答案">捆绑更新答案</a>
<ul>
<li><a href="#example12022qbxt国庆day6binary">Example1([2022qbxt国庆Day6]binary)</a></li>
<li><a href="#example2-4">Example2</a></li>
</ul></li>
<li><a href="#单独更新答案">单独更新答案</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
<li><a href="#example2petrozavodsk-summer-2015-moscow-ipt-contestopenstrain-contest-1464-jtwo-airlines">Example2([Petrozavodsk
Summer-2015. Moscow IPT Contest(openstrain contest 1464) J]Two
Airlines)</a></li>
</ul></li>
<li><a href="#寻找不变量">寻找不变量</a>
<ul>
<li><a href="#example1noip2021-方差">Example1([NOIP2021] 方差)</a></li>
<li><a href="#example2agc030e-less-than-3">Example2([AGC030E] Less than
3)</a></li>
</ul></li>
<li><a href="#组合意义">组合意义</a>
<ul>
<li><a href="#example1arc110d">Example1(ARC110D)</a></li>
<li><a href="#example2abc231g">Example2(ABC231G)</a></li>
<li><a href="#example3agc060d">Example3(AGC060D)</a></li>
</ul></li>
<li><a href="#复杂度抵消">复杂度抵消</a>
<ul>
<li><a href="#example1cf1439b">Example1(CF1439B)</a></li>
</ul></li>
<li><a href="#寻找关系式">寻找关系式</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
</ul></li>
<li><a href="#特判边界">特判边界</a>
<ul>
<li><a href="#example12022icpc杭州e">Example1(2022ICPC杭州E)</a></li>
</ul></li>
<li><a href="#摩尔投票">摩尔投票</a>
<ul>
<li><a href="#example1cf643gchoosing-ads">Example1([CF643G]Choosing
Ads)</a></li>
</ul></li>
<li><a href="#寻找周期性">寻找周期性</a>
<ul>
<li><a href="#example1cf1463fmax-correct-set">Example1([CF1463F]Max
Correct Set)</a></li>
</ul></li>
<li><a href="#补集转化">补集转化</a>
<ul>
<li><a href="#example1-6">Example1</a></li>
</ul></li>
<li><a href="#二进制分组">二进制分组</a>
<ul>
<li><a href="#example1loj3273">Example1(loj3273)</a></li>
<li><a href="#example2luogu7447-ynoi2007-rgxsxrs">Example2(Luogu7447
[Ynoi2007] rgxsxrs)</a></li>
<li><a href="#example3cf1515i-phoenix-and-diamonds">Example3(CF1515I
Phoenix and Diamonds)</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="本质相同">本质相同</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>对于所有满足以下条件的长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(\{a\}\)</span>,我们称它是好的: <span class="math display">\[
a_1=1\\
\forall 2\leq i\leq n,a_i\leq \max\{a_1,\cdots,a_{i-1}\}+1
\]</span> 对于每一个数<span class="math inline">\(1\leq x\leq
n\)</span>,求它在每个好的序列中出现的次数的平方和.其中<span class="math inline">\(1\leq n\leq 3000\)</span>,任意模数.</p>
<p>首先注意到可以枚举每个数<span class="math inline">\(x\)</span>出现的次数,这样就转化为对满足某些位置是<span class="math inline">\(x\)</span>的好的序列计数.</p>
<p>对于一个没有限制的好的序列,设<span class="math inline">\(f_{i,j}\)</span>表示<span class="math inline">\([1,i]\)</span>中填了<span class="math inline">\([1,j]\)</span>(其中<span class="math inline">\(j\)</span>必填)的方案数,不难发现这就是第二类斯特林数.</p>
<p>这样,对于一个<span class="math inline">\(x\)</span>,我们可以枚举它第一次出现的位置以及出现的次数,以及它第一次出现的位置后面的大于等于它的数的数量,合并即可.复杂度<span class="math inline">\(O(n^4)\)</span>.</p>
<p>再思考一下,似乎我们不用枚举它出现的次数,而是可以直接用<span class="math inline">\(g_{i,j,0/1/2}\)</span>表示在<span class="math inline">\([1,i]\)</span>中填<span class="math inline">\([1,j]\)</span>,<span class="math inline">\(1\)</span>出现次数的平方和.同样枚举后面有多少大于等于它的位置,然后就可以把这些位置抽出来作为一个子序列,这个子序列就可以认为<span class="math inline">\(x\)</span>就是<span class="math inline">\(1\)</span>.复杂度<span class="math inline">\(O(n^3)\)</span>.</p>
<p>如果写出上面的式子的话,会发现最难处理的是一个形如<span class="math inline">\(x^k\)</span>的项,表示<span class="math inline">\(x\)</span>第一次出现的位置后面仍然选比它小的数字的位置的方案数.这个怎么办呢?自然的想法是想在dp中顺便把它算了.</p>
<p>再进一步想,我们之所以合并麻烦,是因为取了两段上升区间.如果我们能求出一个上升区间和一个下降区间,在交点处合并呢?</p>
<p>但是这样怎么统计平方和呢?我们发现如果在<span class="math inline">\([1,k]\)</span>中选了<span class="math inline">\([1,i]\)</span>,那么<span class="math inline">\([1,i]\)</span>在<span class="math inline">\([k+1,n]\)</span>中是本质完全相同的,因此还是可以用上面的dp求.</p>
<h3><span id="排列转环">排列转环</span></h3>
<h5><span id="example1p8416">Example1(P8416)</span></h5>
<p>这题牛逼.</p>
<p>首先考虑一维的情况,一维情况下最劣应该是<span class="math inline">\(2,3,...,n,1\)</span>这样的.</p>
<p>为啥捏?因为注意到操作数<span class="math inline">\(=n-\)</span>排列环数,这样的排列环数为<span class="math inline">\(1\)</span>,显然是最小的.加上列也差不多,所以<span class="math inline">\(k_0=2n(n-1)=2n^2-2n\)</span>.</p>
<p>而我们显然可以通过两次操作把一个位置归位,最后剩一行再随便做做,这样的答案就是<span class="math inline">\(2n^2-n+1\)</span>,如果我们想赢,那就需要在上面的<span class="math inline">\(n-1\)</span>行每行省出一步操作.</p>
<p>这咋做呢?类似上面的做法,也考虑找环然后省一步,对于一行,我们找到所有应该放在这里的值以及它们所在的列,把它们应该在的列和实际在的列连边,一定能找到至少一个环(自环也算),删环就可以省一步操作.</p>
<h5><span id="example2">Example2</span></h5>
<p>给序列<span class="math inline">\(a\)</span>和排列<span class="math inline">\(b\)</span>,有若干次操作:</p>
<ol type="1">
<li>修改操作:给定<span class="math inline">\(x,y\)</span>,将<span class="math inline">\(a_x\)</span>改为<span class="math inline">\(y\)</span>.</li>
<li>查询操作:给定<span class="math inline">\(l,r,x\)</span>,查区间<span class="math inline">\([l,r]\)</span>内最长的子区间<span class="math inline">\([l&#39;,r&#39;]\)</span>,使得对<span class="math inline">\(\forall l&#39;\leq i&lt;r&#39;\)</span>,有<span class="math inline">\(a_{i+1}=b_{a_i}\)</span>,且存在<span class="math inline">\(l&#39;\leq i\leq r&#39;\)</span>使得<span class="math inline">\(a_i=x\)</span>.需要输出满足条件的子区间的长度最大值.</li>
</ol>
<p>一步一步来,首先处理出所有的极长的满足条件的段,不难发现修改一个点只会断掉一个段或者连接两个段,影响是<span class="math inline">\(O(1)\)</span>的.</p>
<p>难点在于,我们如何处理要求其中存在一个<span class="math inline">\(x\)</span>这种东西.</p>
<p>注意到<span class="math inline">\(b\)</span>是排列,上置换,不难发现<span class="math inline">\(b\)</span>其实就是一个置换,也就是说每一个极长的段一定是一个置换环内部的元素,我们可以快速定位到<span class="math inline">\(x\)</span>所在的置换环.但这样还是不能做.</p>
<p>考虑由于是单点查询<span class="math inline">\(x\)</span>,我们可以直接将数组也做置换,这样一个置换环就在一个区间内部,意味着一个极长的段一定是一个区间或者两个区间(原区间的一段前缀和一段后缀).</p>
<p>现在对于区间查询,我们考虑特殊处理和端点相交的段,这个是平凡的.这样我们只需要处理出完全被区间包含的那些段该怎么做.把右端点缩一缩,就等价于左端点完全被区间包含的那些点.也就是以<span class="math inline">\(a\)</span>为横坐标,<span class="math inline">\(l\)</span>为纵坐标,这样这些就相当于对一条横线取<span class="math inline">\(\max\)</span>,然后查询一段竖着的线段的最大值.注意到一行不可能有两个横线,因此可以线段树分治+线段树维护,复杂度<span class="math inline">\(O(n\log ^2n)\)</span>.</p>
<h3><span id="规定转移顺序">规定转移顺序</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一张<span class="math inline">\(n\)</span>个点的图,每个点有一个<span class="math inline">\([1,k]\)</span>的颜色,求这张图有多少个子图是一棵树并且在这棵树中每种颜色恰好出现了一次.</p>
<p>首先无根树转有根树计数,设<span class="math inline">\(dp_{i,S}\)</span>表示以<span class="math inline">\(i\)</span>为根,已经选了<span class="math inline">\(S\)</span>集合中的颜色的方案数.转移的时候枚举出边(注意可能会算重,只要是会算重的都考虑钦定某种颜色在其中一个块里),复杂度<span class="math inline">\(O(m3^k)\)</span>.</p>
<p>冷静一下,想到斯坦纳树,于是再设一个<span class="math inline">\(g_{x,S}\)</span>表示以<span class="math inline">\(x\)</span>为根且<span class="math inline">\(x\)</span>只有一个儿子,<span class="math inline">\(S\)</span>的定义类似的方案数.这样我们就可以用斯坦纳树的换根技巧计数.很厉害.</p>
<p>这个故事告诉我们:对于图论计数问题(尤其是和树有关),<span class="math inline">\(m\)</span>大概率可以转化为<span class="math inline">\(n\)</span>,但是需要一些小技巧(例如斯坦纳树)</p>
<h5><span id="example2p7142">Example2(P7142)</span></h5>
<p>类似宝藏那个题,我们考虑设<span class="math inline">\(f_{d,S_1,S_2}\)</span>表示<span class="math inline">\(S_1\)</span>中的点到<span class="math inline">\(1\)</span>的距离<span class="math inline">\(&lt;d\)</span>,<span class="math inline">\(S_2\)</span>中的点到<span class="math inline">\(1\)</span>的距离<span class="math inline">\(=d\)</span>.然后枚举到<span class="math inline">\(1\)</span>的距离<span class="math inline">\(=d+1\)</span>的点集,这一部分复杂度是<span class="math inline">\(O(n3^n)\)</span>,预处理一下不同情况的答案即可.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<p>大概是如果多组询问那复杂度是错误的,但是如果我全局求,那我<span class="math inline">\(\sum\)</span>起来的总复杂度大概是对的.经典问题是树上背包.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定一颗二叉树,求对于每一个<span class="math inline">\(x\)</span>,满足<span class="math inline">\(x,y,z\)</span>互不相同的三元组<span class="math inline">\((x,y,z)\)</span>的价值(定义为两两距离之和对<span class="math inline">\(L\)</span>取膜)的最大值是多少.<span class="math inline">\(n\leq 3000\)</span>.</p>
<p>乍一看,二叉树,想到换根后做dsu on tree+set.但是<span class="math inline">\(O(n^2\log^2n)\)</span>实在是跑不过去.冷静一下,除去三点共线的情况,考虑三个点在二叉树上的两两LCA一定只有两个点,枚举其中深度较浅的那个点并枚举其子树中的两个点和子树外的一个点.假设其子树内有<span class="math inline">\(x\)</span>个点对,子树外有<span class="math inline">\(y\)</span>个点,注意到<span class="math inline">\(\sum x=n^2\and \sum y\leq
n^2\)</span>,于是总复杂度<span class="math inline">\(O(n^2\log
n)\)</span>.</p>
<h3><span id="字典序相关">字典序相关</span></h3>
<p>题目中询问满足条件的字典序第<span class="math inline">\(k\)</span>小之类的问题,通常采用转化为计数问题.</p>
<h5><span id="example12022noip十连测day88ady">Example1([2022noip十连测day8]8ady)</span></h5>
<p>首先,我们肯定想如果知道<span class="math inline">\(a\)</span>,我们怎么求出<span class="math inline">\(b\)</span>.</p>
<p>首先不难发现,我们可以这么还原:先开一个堆,然后先将前<span class="math inline">\(m-1\)</span>个位置扔进堆里,从第<span class="math inline">\(m\)</span>个位置开始,假设现在到了第<span class="math inline">\(i\)</span>个位置<span class="math inline">\((m\leq
i\leq n)\)</span>,每次将<span class="math inline">\(a_i\)</span>扔进堆里,并从堆中取最小元素扔到<span class="math inline">\(i-m+1\)</span>位置,最后把堆清空到剩下的位置即可.</p>
<p>大量实验证明:这种反向构造思路,你用个堆通常是做不动的.</p>
<p>我们考虑有没有别的做法.</p>
<p>一个一个数地考虑,<span class="math inline">\(b_1\)</span>在<span class="math inline">\(a\)</span>中的位置应该在哪?显然是应该在<span class="math inline">\([1,m]\)</span>中,而且根据上面的堆的做法,显然它应该是<span class="math inline">\([1,m]\)</span>中最小的数字,换句话说,我们需要满足:<span class="math inline">\([1,m]\)</span>中除它以外的数字都比它大.</p>
<p>我们继续考虑<span class="math inline">\(b_2\)</span>,显然它在<span class="math inline">\(a\)</span>中应该在<span class="math inline">\([1,m+1 ]\)</span>中,并且需要满足<span class="math inline">\([1,m+1]\)</span>中的所有数字除了<span class="math inline">\(b_1\)</span>,都比它大.</p>
<p>以此类推.不难注意到对于一个数<span class="math inline">\(b_i\)</span>,其中<span class="math inline">\(1\leq
i\leq n-m+1\)</span>,它能填回的原序列的位置一定最大最大是<span class="math inline">\([1,m+i-1]\)</span>,并且如果它能填到区间<span class="math inline">\([l,r]\)</span>中,这个区间中除去在它之前填进来的数字以外,均比它大.</p>
<p>但是,这显然是个上界.这个区间能不能缩小一下呢?</p>
<p>对于一个<span class="math inline">\(i\)</span>,我们找到最大的<span class="math inline">\(j\)</span>满足<span class="math inline">\(1\leq
j&lt;i\)</span>并且<span class="math inline">\(b_j&gt;b_i\)</span>(有可能找不到).</p>
<p>冷静一下,显然,<span class="math inline">\(b_i\)</span>不能填到<span class="math inline">\([1,j+m-1]\)</span>.(因为如果它扔在这里,那它就:在<span class="math inline">\(j\)</span>出堆前入堆,在<span class="math inline">\(j\)</span>出堆后出堆,显然不合法)</p>
<p>也就是说,我们将每个数能填的区间缩小为了<span class="math inline">\([j+m,i+m-1]\)</span>.</p>
<p>那是不是说每个数只要填在这个区间中,就一定合法呢?</p>
<p>我们考虑一个数<span class="math inline">\(i\)</span>以及所有比它小且在它后面的数字<span class="math inline">\(j\)</span>,当<span class="math inline">\(j=i+1\)</span>时,显然<span class="math inline">\(j\)</span>只有一种选择,直接填上;当<span class="math inline">\(j=i+2\)</span>时,若<span class="math inline">\(i+1\)</span>已经选择好了,那<span class="math inline">\(j\)</span>显然也只有一种选择,填上.这样,对于所有<span class="math inline">\(i\)</span>,如果它前面有一个大于它的数字,那它一定只有一个位置可以填.</p>
<p>这样我们就可以简化为:给定<span class="math inline">\(b\)</span>数组单调递增的问题.不难发现该条件下<span class="math inline">\(i\)</span>可以选择的区间是<span class="math inline">\([1,i+m-1]\)</span>,且满足条件一定有解.</p>
<p>冷静一下,这个时候假设新序列长度为<span class="math inline">\(len\)</span>,那显然一共有<span class="math inline">\(m^{len}\)</span>个满足条件的<span class="math inline">\(a\)</span>序列.注意到这个级别是指数级别.</p>
<p>所以前面一定是按顺序填,直到后面才会打乱顺序.而后面的长度大概也就是个<span class="math inline">\(\log_m k\)</span>,枚举枚举就行.</p>
<h3><span id="前缀和与差分">前缀和与差分</span></h3>
<h5><span id="example1loj3266">Example1(loj3266)</span></h5>
<p>把点都扔到坐标系上,显然到一个点曼哈顿距离相等的数一定在一个正方形(对角线平行于坐标轴)上.</p>
<p>我们考虑如果已知两个点,怎么找第三个点的坐标,显然是两个正方形的边界的交点,那也就是说,曼哈顿距离下,一个等边三角形必定有两个点所在直线与坐标轴成<span class="math inline">\(45\degree\)</span>角,那这两个点必然和另一个点组成了一个等腰直角三角形(欧几里得意义下),我们枚举等腰直角三角形的直角顶点和直角边长就可以确认这两个点的坐标,而另一个点一定在一条与坐标轴成<span class="math inline">\(45\degree\)</span>的斜线上,可以使用前缀和做.</p>
<p>注意到有的点对可能会被算两遍,要特判.</p>
<h5><span id="example2">Example2</span></h5>
<p>小孔在玩卡牌游戏.众所周知,在卡牌游戏里,过牌是很关键的,所以目前小孔的牌库中,只可能有数字牌<span class="math inline">\(0,1,2,3,4\)</span>.</p>
<p>数字牌<span class="math inline">\(x\)</span>的含义是当你打出它的时候,会从牌库的顶端抽<span class="math inline">\(x\)</span>张牌到自己手里,若牌库中不足<span class="math inline">\(x\)</span>张牌,则将牌库抽空为止.打出的数字牌<span class="math inline">\(x\)</span>会放入弃牌堆中.在题目中你可以认为这张牌不会再被用到了.</p>
<p>目前,牌库里有<span class="math inline">\(n\)</span>张牌,从牌堆顶到牌堆底数第<span class="math inline">\(i\)</span>张牌为数字牌<span class="math inline">\(a_i\)</span>.在开始回合时,发牌员会进行一次切牌,切牌的结果是从牌堆顶到牌堆底的牌的顺序变为了<span class="math inline">\(a_s,a_{s+1},...,a_n,a_1,...,a_{s−1}\)</span>.</p>
<p>接着,小孔会抽<span class="math inline">\(k\)</span>张牌堆顶的牌到自己手上.每次小孔可以打出一张牌,但这一回合中小孔至多打出<span class="math inline">\(p\)</span>张牌.小孔可以在任意时刻结束回合.</p>
<p>请问,这一回合中若小孔使用最优策略,那么牌库里最少还剩多少牌.进一步地,有<span class="math inline">\(q\)</span>次这样的询问,每次询问给定三个整数<span class="math inline">\(s,k,p\)</span>,你需要输出牌库里最少还剩多少牌.<span class="math inline">\((n,q\leq 3\times 10^5)\)</span>.</p>
<p>每次询问是独立的,也就是说每次询问并不会以任何方式影响到之后的询问.</p>
<p>首先我们想一下我们需要知道什么:我们需要知道其在这一回合中打出的各种牌的数量是多少.而只要知道这一点,我们自然得到了答案是多少.注意到每次一定优先打出手头上最大的牌.</p>
<p>我们设<span class="math inline">\(sum_{t,i}\)</span>表示从开始到抽完第<span class="math inline">\(i\)</span>张牌<strong>之前</strong>,在只用大于<span class="math inline">\(t\)</span>的牌的前提下,还能往下抽多少张牌.显然<span class="math inline">\(sum_{t,0}=0\)</span>并且<span class="math inline">\(sum_{t,i}=sum_{t,i-1}+a_{i-1}[a_{i-1}&gt;t]-1\)</span>.注意到<span class="math inline">\(sum_{t,i}=0\)</span>就抽不了第<span class="math inline">\(i\)</span>张牌了.不考虑还能抽负数张牌的情况,注意到<span class="math inline">\(sum\)</span>数组具有可差分性!</p>
<p>那我们一开始抽了<span class="math inline">\(k\)</span>张牌,也就是令<span class="math inline">\(sum_{s+1}\leftarrow
sum_{s+1}+k\)</span>,那第一个不能继续抽牌的地方显然也就是第一个满足<span class="math inline">\(sum_{i}-sum_{s}\leq 0\)</span>的地方,用原本的<span class="math inline">\(sum\)</span>数组表示也就是<span class="math inline">\(sum_{i}+k\leq
sum_{s}\)</span>.那第二个地方呢?由于后面的<span class="math inline">\(sum\)</span>都加上<span class="math inline">\(k\)</span>了,第二个地方也就是满足<span class="math inline">\(sum_j\leq
sum_{i}-t\)</span>的地方(不过注意到后面要倍增,所以直接写<span class="math inline">\(sum_j&lt;
sum_i\)</span>也可以,这样方便用单调栈维护这个东西).以此类推,注意到这个东西和询问无关,可以使用倍增预处理,处理的过程中判断一下还有没有大小为<span class="math inline">\(t\)</span>的牌以及用牌总数是否小于等于<span class="math inline">\(p\)</span>即可.都是可以用前缀和之类的东西预处理的.最后从小的牌开始选,选完之后的牌就可以当成<span class="math inline">\(0\)</span>牌了.另外要注意:我们要保证目前一定有大小为<span class="math inline">\(t\)</span>的牌选,所以需要在做之前判断一下最后一次选择大小为<span class="math inline">\(t\)</span>的牌的位置是在哪里.</p>
<p>等一下,注意到我们好像没啥办法判断还有没有大小为<span class="math inline">\(t\)</span>的牌.有一个方法是:我们直接令所有<span class="math inline">\(\leq t-1\)</span>的牌变成<span class="math inline">\(t\)</span>,并处理出不用<span class="math inline">\(\leq t-1\)</span>的牌能跑到的最右点,然后取个<span class="math inline">\(\min\)</span>.</p>
<p>想出<span class="math inline">\(sum\)</span>数组并发现可差分性后,这个题突然就变可做了.问题来了:咋想到的<span class="math inline">\(sum\)</span>数组,又是怎么发现的可差分性?</p>
<p>首先,由于切牌这个环节会变化起点.所以有两种可能:要么是像倍增那样起点不定,要么是像差分一样其它起点的答案可以由原本的起点答案得到.那想到差分后呢?又注意到一定会先选较大的牌,所以大概率可以分层考虑:这样就先把问题转化为只有<span class="math inline">\(0/1\)</span>或者是只有<span class="math inline">\(0/1/2\)</span>的情况再继续考虑.由于要多组询问,所以答案一定是可以通过某种方式迅速算出来的,考虑到只要得到每种牌选的次数就可以快速算答案.又有一定是比它大的牌都选完了才选它,于是考虑第一次选不了其它牌只能选它的地方.注意到这个地方可以使用前缀和在变换起点的情况下求.于是由前缀和判断差分性质.</p>
<h3><span id="二分答案">二分答案</span></h3>
<h5><span id="example12022qbxt国庆day6kth">Example1([2022qbxt国庆Day6]kth)</span></h5>
<p>考虑<span class="math inline">\(f\)</span>的取值不会很多,我们可以枚举<span class="math inline">\(f\)</span>的取值,并把相同取值的归类.也就是,对于<span class="math inline">\(f=i\)</span>的类别里也就是后<span class="math inline">\(i\)</span>位为<span class="math inline">\(0\)</span>,第<span class="math inline">\(i\)</span>位为<span class="math inline">\(1\)</span>的那些数.</p>
<p>注意到每个类别内部是很有序的,也就是说我们可以采取类似初赛归并排序的方法二分,找到前<span class="math inline">\(k\)</span>大的和.</p>
<p>调了一年,这个故事告诉我们,如果一个东西暴力调整能过/复杂度均摊,就不要写一些很丑的很难写的即使更快的东西去做.</p>
<h5><span id="example2">Example2</span></h5>
<p>给你一棵<span class="math inline">\(n\)</span>个点的树,每条边是一个字符(字符集是小写字母),一个点的所有相邻边边权不同.</p>
<p>有<span class="math inline">\(m\)</span>次操作:每次询问给出点<span class="math inline">\(x\)</span>和字符串<span class="math inline">\(S\)</span>,<span class="math inline">\(S\)</span>中不包含相同字符,<span class="math inline">\(|S|=26\)</span>,每次修改会修改一条边边权.</p>
<p>从<span class="math inline">\(x\)</span>点开始,每次对与<span class="math inline">\(x\)</span>点相邻的边,对这些边找出其边权在<span class="math inline">\(S\)</span>中出现的位置,找出边权出现位置最靠前的边,然后走过去.</p>
<p>每次询问走过的边直接从树上删除,一条边正反方向算同一条边,也就是说没法<span class="math inline">\(x\rightarrow y\rightarrow x\)</span>.</p>
<p>这个过程会停机,你需要输出在哪个点停下来,询问之间独立.</p>
<p>这题最重要的思想在于:我们首先需要将这个问题改成一个判定性问题:判定性问题显然弱于找到答案.</p>
<p>怎么判定呢?对于一条路径,如果我们要沿着它走,那么我们就可以确定每个点的最小边(或者次小边),这等价于给出若干个边之间的大小关系,可以使用bitset维护一下,最后判定即可.我们发现判定数组是可以合并的,于是这玩意可以扔到线段树上维护.</p>
<p>会了判定这题就做完了,做树链剖分,然后开始从下往上跳重链,能跳到顶端就跳,不然二分跳到哪里,下去是同理的,只不过下去的二分需要多个<span class="math inline">\(\log n\)</span>.</p>
<h3><span id="整体二分">整体二分</span></h3>
<p>通常解决在二分的情况下,单次check的复杂度比较高的问题.思想是把所有询问共同的check一起做.</p>
<p>整体二分的具体复杂度往往需要现场分析.</p>
<p>最常用的整体二分的写法是分治.但是有的问题(例如不能撤销)可能不太好写分治.</p>
<p>还有一种方式是,我们把所有询问一字排开,然后求出每个询问当前二分的<span class="math inline">\(mid\)</span>,然后顺序处理或者别的什么处理方式做这些<span class="math inline">\(mid\)</span>.</p>
<h5><span id="example1agc002dstamp-rally">Example1([AGC002D]Stamp Rally)</span></h5>
<p>直接整体二分,注意需要做可撤销并查集之类的东西.</p>
<p>###分治</p>
<h5><span id="example1平面最近点对">Example1(平面最近点对)</span></h5>
<p>按照<span class="math inline">\(x\)</span>轴排序,递归做两边的子问题,假设两边问题的最小值为<span class="math inline">\(d\)</span>,对着<span class="math inline">\(d\)</span>做中间的问题.</p>
<h5><span id="example2cf1764g3doremys-perfect-ds-class-hard-version">Example2([CF1764G3]
Doremy’s Perfect DS Class (Hard Version))</span></h5>
<p>有一个<span class="math inline">\([1,n]\)</span>的排列<span class="math inline">\(p\)</span>,每次可以询问<span class="math inline">\(l,r,k\)</span>,交互库会返回<span class="math inline">\(\lfloor\frac{p_l}{k}\rfloor,\lfloor\frac{p_{l+1}}{k}\rfloor,\cdots,\lfloor\frac{p_r}{k}\rfloor\)</span>中不同数字的个数,你需要在<span class="math inline">\(20\)</span>次询问内找到<span class="math inline">\(p\)</span>中<span class="math inline">\(1\)</span>的位置.</p>
<p>第一反应就是令<span class="math inline">\(k=2\)</span>,然后如果<span class="math inline">\(n\)</span>是奇数,不难发现此时只有<span class="math inline">\(1\)</span>自己一个人一组.一个自然的想法是,我们可以对于每个位置<span class="math inline">\(i\)</span>,查询<span class="math inline">\([1,i-1]\)</span>和<span class="math inline">\([1,i]\)</span>的答案,如果答案一样,那这个位置肯定不是<span class="math inline">\(1\)</span>.如果不一样,我们再查一下<span class="math inline">\([i,n]\)</span>和<span class="math inline">\([i+1,n]\)</span>.由于<span class="math inline">\(1\)</span>不会和左右任意一个人配对,不难发现如果这两种情况都不一样,那这里一定是<span class="math inline">\(1\)</span>,这样我们就做到了<span class="math inline">\(2n-2\)</span>次查询.</p>
<p>那么如何优化呢?我们冷静一下,如果我们查询一个区间<span class="math inline">\([l,r]\)</span>,那么得到的答案自然是<span class="math inline">\(len-\)</span>配对数字都在区间内的对数,因此我们自然也能得到这个区间的未配对数.这个时候发现,对于位置<span class="math inline">\(i\)</span>,如果我们查询<span class="math inline">\([1,i]\)</span>和<span class="math inline">\([i+1,n]\)</span>,由于这两个区间内没配对的数字要么是<span class="math inline">\(1\)</span>,要么会和另一个区间中的数字配对,因此这两个区间中,未配对数多的那个一定包含<span class="math inline">\(1\)</span>.这样就可以通过<span class="math inline">\(k\)</span>不断向下二分,最后只需要<span class="math inline">\(20\)</span>步操作就可以解决<span class="math inline">\(n\)</span>是奇数的情况.</p>
<p>那么<span class="math inline">\(n\)</span>是偶数怎么办呢?这个时候<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>都没人配对.我们需要找到<span class="math inline">\(n\)</span>并将它杀掉.注意到<span class="math inline">\(k\)</span>可以取别的数,我们如果只是让<span class="math inline">\(k=2\)</span>未免有些弱,而且看上去也区分不了<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>,而不难发现,令<span class="math inline">\(k=n\)</span>就可以找到<span class="math inline">\(n\)</span>在哪里,于是可以先找<span class="math inline">\(n\)</span>再找<span class="math inline">\(1\)</span>,需要<span class="math inline">\(40\)</span>步.</p>
<p>那怎么继续优化呢?我们还是令<span class="math inline">\(k=2\)</span>,查询<span class="math inline">\([1,i]\)</span>和<span class="math inline">\([i+1,n]\)</span>,我们发现此时会有两种情况:</p>
<ol type="1">
<li>左右两边未配对数量相差<span class="math inline">\(2\)</span>,这个时候<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>一定都在较大的那边,直接递归.</li>
<li>左右两边未配对数量相等,这个时候一定<span class="math inline">\(1\)</span>在一边,<span class="math inline">\(n\)</span>在另一边,我们可以通过一次查询<span class="math inline">\(k=n\)</span>判断哪边是<span class="math inline">\(n\)</span>.</li>
</ol>
<p>于是只需要<span class="math inline">\(21\)</span>次.</p>
<p>但是还是不够,我们从哪里抠出那一次呢?发现最后处理区间<span class="math inline">\([i,i+1]\)</span>还需要两步操作,我们看看能不能省掉一步.</p>
<ol type="1">
<li><span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>都在<span class="math inline">\([i,i+1]\)</span>中,我们显然只需要查询一步就可以知道哪边是<span class="math inline">\(n\)</span>.</li>
<li>只有<span class="math inline">\(1\)</span>在<span class="math inline">\([i,i+1]\)</span>中,我们考虑利用一下前面的信息.注意到我们一定已经知道<span class="math inline">\([1,i-1],[i,n],[1,i+1],[i+2,n]\)</span>的答案(如果区间为空或者区间为<span class="math inline">\([1,n]\)</span>显然我们也知道答案),假设这个区间中的两个数是<span class="math inline">\(1\)</span>和<span class="math inline">\(x\)</span>,<span class="math inline">\(x\in(1,n)\)</span>,那么<span class="math inline">\(x\)</span>一定有一个和它配对的数字,我们考虑通过<span class="math inline">\([1,i-1]\)</span>和<span class="math inline">\([1,i+1]\)</span>就可以知道和<span class="math inline">\(x\)</span>配对的数字在<span class="math inline">\([1,i-1]\)</span>还是在<span class="math inline">\([i+2,n]\)</span>.接下来只需要一步判断就可以找到<span class="math inline">\(1\)</span>了.</li>
</ol>
<h5><span id="example3xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopentraisncontest-1489d-nice-set-of-points">Example3(XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(opentraisn
contest 1489)D Nice Set of Points)</span></h5>
<p>给定一个点集<span class="math inline">\(S=\{(x,y)\}\)</span>,<span class="math inline">\((x_1,y_1)\)</span>和<span class="math inline">\((x_2,y_2)\)</span>可达当且仅当<span class="math inline">\(x_1=x_2\or
y_1=y_2\)</span>.称一个点集是好的当且仅当这个点集中任意两个点的最短距离是它们的曼哈顿距离.给出一个点集,大小为<span class="math inline">\(N\)</span>,<span class="math inline">\(1\leq N\leq
1000\)</span>,加入不多于<span class="math inline">\(10000-N\)</span>个点使得这个点集变成好的.</p>
<p>找一条分界线<span class="math inline">\(x=d\)</span>,我们将这条线左右两边的点全都作出在这条线上的投影点,将这些投影点全都加入,不难发现左右两边之间的路径就合法了,继续递归就行.</p>
<h5><span id="example4cf1442dsum">Example4([CF1442D]Sum)</span></h5>
<p>一个自然的想法是由于越靠后的可能越优秀,所以应该是要不断往后挖的.具体地,我们发现只可能有一个数组被选了一部分,剩下的数组要么不选,要么全选.</p>
<p>为什么呢?假设有两个数组各选了一部分,不妨假设它们最后选的数分别是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,下一个未选的数分别是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>,有<span class="math inline">\(c\geq
a,d\geq b\)</span>,假设<span class="math inline">\(a\geq
b\)</span>,那么自然有<span class="math inline">\(c\geq
b\)</span>,于是我们把<span class="math inline">\(b\)</span>删掉换成<span class="math inline">\(c\)</span>一定更优秀.</p>
<p>有了这个性质后,我们可以枚举是哪个数组只选了一部分,然后求出剩下部分的背包,背包部分可以求前缀和后缀最后合并起来,我们的复杂度就是<span class="math inline">\(O(nk^2)\)</span>.</p>
<p>但这个复杂度还是不太够,如何优化呢?</p>
<p>注意到这里的背包是支持撤销操作的,我们考虑一个分治做法:每次做到<span class="math inline">\([l,r]\)</span>的时候,假设此时<span class="math inline">\([1,l-1]\)</span>和<span class="math inline">\([r+1,n]\)</span>都加入答案了,我们把<span class="math inline">\([mid+1,r]\)</span>也加入背包,然后递归求解<span class="math inline">\([l,mid]\)</span>,然后再撤销,同样的方法求解右边的答案.复杂度<span class="math inline">\(O(nk\log n)\)</span>.</p>
<h5><span id="example5agc044d">Example5(AGC044D)</span></h5>
<p>这题在于分治后归并,考虑我们是可以快速判断一个串是否是原串的子序列的,就是判断它们的编辑距离是否恰好等于长度之差.而我们也可以快速判断每个字母在原串中出现了多少次,只需要询问<span class="math inline">\(L\)</span>个这个字母然后看编辑距离就是替换的次数.这样我们考虑对字母分治,<span class="math inline">\([l,r]\)</span>表示只用到<span class="math inline">\([l,r]\)</span>中的字母,得到的极长的原串的子序列是什么.边界情况<span class="math inline">\([l,l]\)</span>是好处理的,对于<span class="math inline">\([l,r]\)</span>,我们考虑归并,合并<span class="math inline">\([l,mid]\)</span>和<span class="math inline">\([mid+1,r]\)</span>的时候不断判断当前串是否是子序列就行.</p>
<h3><span id="倍增">倍增</span></h3>
<p>顺便一提,倍增比二分方便的一点在于:倍增能迅速确定答案的规模,这在复杂度与答案规模有关的时候至关重要.</p>
<h5><span id="example1scoi2015国旗计划">Example1([SCOI2015]国旗计划)</span></h5>
<p>先破环成链,然后设<span class="math inline">\(f_{i,j}\)</span>表示从<span class="math inline">\(i\)</span>这个人,途径<span class="math inline">\(2^j\)</span>个人后能到达的最远的人是谁,然后就可以直接通过倍增处理.</p>
<p>#####Example2([PKUSC2018]星际穿越)</p>
<p>#####Example3(CF1523H Hopping Around the Array)</p>
<p>类似国旗计划,只不过需要用背包合并一维.</p>
<p>不过吧,这题有个问题在于最后的询问,我们要每次判断当前越界的点的代价是否小于等于dp数组的代价,如果小就回撤dp数组(因为无论如何都必不可能在这里选择).</p>
<h5><span id="example4loj3665">Example4(loj3665)</span></h5>
<p>思考一下发现,走相同的步数能到的点一定是一段区间,于是考虑使用倍增算法,设<span class="math inline">\(f_{x,i}\)</span>表示从<span class="math inline">\(x\)</span>走<span class="math inline">\(2^i\)</span>步能到的区间,转移是简单的RMQ问题.</p>
<p>但是初值怎么求呢?先考虑右端点怎么求.对于每个路线<span class="math inline">\(j\)</span>,它会把<span class="math inline">\([A_j,A_j+k-1]\)</span>能到达的右端点与<span class="math inline">\(B_j\)</span>取<span class="math inline">\(\max\)</span>,由于查询在修改之后,所以这个东西很好做.</p>
<h5><span id="example5cf1707e">Example5(CF1707E)</span></h5>
<p>引理1:如果<span class="math inline">\([l,r]\subseteq[L,R]\)</span>,则<span class="math inline">\(f((l,r))\subseteq f((L,R))\)</span>.</p>
<p>引理2:如果<span class="math inline">\([L,R]=[l_1,r_1]\cup[l_2,r_2]\)</span>,则<span class="math inline">\(f((L,R))=f((l_1,r_1))\cup
f((l_2,r_2))\)</span>.</p>
<p>引理1显然,引理2是因为<span class="math inline">\([L,R]\)</span>中的最大值和最小值一定都被后面的两个部分取到.</p>
<p>于是,考虑<span class="math inline">\([l,r]=\cup_{i=l}^{r-1}[i,i+1]\)</span>,就可以倍增了.</p>
<p>考虑求出每个单点的倍增数组,那么总区间的倍增数组也就是这些数组的最小值和最大值.</p>
<p>大概做一下.</p>
<h5><span id="example622zr提高组十连测day6百分号">Example6([22zr提高组十连测day6]百分号)</span></h5>
<p>首先看上去多组询问给定起点终点看上去就很像倍增.</p>
<p>一个很自然的设计是<span class="math inline">\(L_{x,i}\)</span>表示从<span class="math inline">\(x\)</span>这个点跳<span class="math inline">\(2^i\)</span>所能到达的最左端的点,<span class="math inline">\(R_{x,i}\)</span>同理.但是能跳到最远的点不一定能跳到一个较近的点,那咋办呢?</p>
<p>冷静一下,注意到我们好像还没有用到括号序列的性质:两个跳跃要么包含要么不交,不可能出现第三种情况.</p>
<p>所以,如果目前能跳到的最远的点为<span class="math inline">\(l,r\)</span>,那么再跳一步能到达的最远的点一定是从<span class="math inline">\(l\)</span>或<span class="math inline">\(r\)</span>跳过去的.考虑反证这个结论,设能从<span class="math inline">\((l,r)\)</span>中的一个点<span class="math inline">\(k\)</span>跳到更远的点,那么由于之前没跳到过<span class="math inline">\(k\)</span>就跳到<span class="math inline">\(l\)</span>了,所以一定存在一个<span class="math inline">\(i&gt;k\)</span>,<span class="math inline">\(i\rightarrow l\)</span>,而如果存在<span class="math inline">\(j&lt;l\)</span>,<span class="math inline">\(k\rightarrow j\)</span>,显然不满足性质.</p>
<p>同理,我们最后处理询问答案的时候,考虑从<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>都跳.先从<span class="math inline">\(x\)</span>跳到再跳一步就会跳过<span class="math inline">\(y\)</span>的位置,然后把<span class="math inline">\(y\)</span>跳到再跳一步就会跳过<span class="math inline">\(x\)</span>的位置,那么现在的<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>一定相邻,不然分别跳一步就会出现包含的情况,于是一定是最优解.</p>
<h3><span id="对称建立双射">对称/建立双射</span></h3>
<h5><span id="example1cf1627f">Example1(CF1627F)</span></h5>
<p>冷静一下考虑,分界线一定是一个中心对称图形,分成的两部分一定中心对称.那这条分界线一定过中心点.</p>
<p>我们考虑这么一点:如果所有点对都在矩阵一边,我们就可以直接求中心点到矩阵一边的最短路然后对称一下就好了.</p>
<p>而矩阵上遍布点对怎么办呢?我们在和每个点对对称的位置把这个点对复制一遍,然后从中心点找到一条到边界的最短路,把它对称一下即可.</p>
<h5><span id="example2ah2017hnoi2017抛硬币">Example2([AH2017/HNOI2017]抛硬币)</span></h5>
<p>设<span class="math inline">\(A\)</span>的正面朝上为<span class="math inline">\(S_A\)</span>,<span class="math inline">\(B\)</span>的为<span class="math inline">\(S_B\)</span>.设<span class="math inline">\(p_1=\sum[S_A&gt;S_B],p_2=\sum[S_A=S_B],p_3=\sum[S_A&lt;S_B]\)</span>.</p>
<p>当<span class="math inline">\(a=b\)</span>,翻转所有硬币,自然有<span class="math inline">\(p_1=p_3\)</span>,又设<span class="math inline">\(P=p_1+p_2+p_3=2^{a+b}\)</span>,于是求得<span class="math inline">\(p_2\)</span>即可得到答案.而<span class="math inline">\(p_2=\sum_{i=0}^a\binom{a}{i}\binom{b}{i}\)</span>,用范德蒙德卷积的变式,有<span class="math inline">\(p_2=\binom{a+b}{a}\)</span>.</p>
<p>同样,当<span class="math inline">\(a&gt;b\)</span>时.我们设<span class="math inline">\(p_4=\sum[a-S_A&gt;b-S_B],p_5=\sum[a-S_A=b-S_B],p_6=\sum[a-S_A&lt;b-S_B]\)</span>.同样是翻转硬币的套路,自然有<span class="math inline">\(p_4=p_1,p_5=p_2,p_6=p_3\)</span>.注意到:<span class="math inline">\(S_A\leq S_B\Rightarrow
a-S_A&gt;b-S_B\)</span>,但逆命题不成立.不妨设<span class="math inline">\(p_7=\sum[S_A&gt;S_B\and
a-S_A&gt;b-S_B]\)</span>.自然有: <span class="math display">\[
p_1=p_4=p_7+p_2+p_3=p_7+P-p_1
\]</span> 于是只要求出<span class="math inline">\(p_7\)</span>就可以求得<span class="math inline">\(p_1\)</span>.</p>
<p>考虑<span class="math inline">\(p_7\)</span>如何求,注意到<span class="math inline">\([S_A&gt;S_B\and
a-S_A&gt;b-S_B]=[0&lt;S_A-S_B&lt;a-b]\)</span>,我们可以枚举<span class="math inline">\(S_A-S_B\)</span>,然后继续用范德蒙德卷积的变式.</p>
<p>#####Example3([2022qbxt国庆Day4]C)</p>
<p>直接考虑对于每一对位置<span class="math inline">\((i,j),i&lt;j\)</span>,计算它们可能产生的逆序对贡献.注意到每一对对答案的贡献会大概接近<span class="math inline">\(0.5\)</span>,我们考虑构造一个双射,判断双射左右是否都会贡献.</p>
<p>设<span class="math inline">\(d_i\)</span>为<span class="math inline">\(i\)</span>个数的错排数量,根据错排公式有<span class="math inline">\(d_n=(n-1)(d_{n-1}+d_{n-2})\)</span>.接下来讨论一下这两个位置的取值:</p>
<ol type="1">
<li>如果<span class="math inline">\(a_i=j,a_j=i\)</span>,那么一定贡献了逆序对,这里总共贡献为<span class="math inline">\(d_{n-2}\cfrac{n(n-1)}{2}\)</span>,一半的贡献也就是<span class="math inline">\(\cfrac{d_{n-2}n(n-1)}{4}\)</span>.</li>
<li>如果<span class="math inline">\(a_i=j,a_j=k,k\ne i\or
a_i=k,a_j=i,k\ne j\)</span>,考虑前后两者形成双射.如果<span class="math inline">\(k\)</span>在<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间,那么无论前者还是后者,都一定贡献逆序对;不然,则两种情况一定只有一种会贡献逆序对.前者多出的贡献应该是<span class="math inline">\(\cfrac{n(n-1)(n-2)}{6}(d_{n-2}+d_{n-3})\)</span>,也就是先选出<span class="math inline">\(i&lt;k&lt;j\)</span>,如果<span class="math inline">\(a_k=i\)</span>,那么剩余的可能性就是<span class="math inline">\(d_{n-3}\)</span>;不然,也就是说<span class="math inline">\(a_k\ne
i\)</span>,类似于错排公式,剩余的可能性为<span class="math inline">\(d_{n-2}\)</span>.另外,由于<span class="math inline">\(d_{n-2}+d_{n-3}=\cfrac{d_{n-1}}{n-2}\)</span>,所以上面的贡献也就是<span class="math inline">\(\cfrac{n(n-1)}{6}d_{n-1}\)</span>.</li>
<li>如果<span class="math inline">\(i,j,a_i,a_j\)</span>互不相同,那我们交换<span class="math inline">\(a_i\)</span>和<span class="math inline">\(a_j\)</span>一定可以构造出另一组答案,并且这两组答案中一定只有一组贡献了逆序对,于是二者形成双射.</li>
</ol>
<p>除去上面的部分的贡献是<span class="math inline">\(\cfrac{d_nn(n-1)}{4}\)</span>.于是总贡献为:<span class="math inline">\(n(n-1)(\cfrac{d_{n-1}}{6}+\cfrac{d_n+d_{n-2}}{4})\)</span>.</p>
<h5><span id="example4arc115d">Example4(ARC115D)</span></h5>
<p>第一反应感觉完全不可做.</p>
<p>思考一下,如果我们随便选边肯定完蛋了:我们又不知道选出了几个奇度点,这不完蛋了?</p>
<p>先考虑要求全是偶度点怎么办?</p>
<p>由于点只有奇度点和偶度点两种,如果我能先随便选个边集,再把它删到全是偶度点好像就赢了.但是一方面我咋删啊,一方面这样删有可能删出重复的.又注意到删一条边就一定可以让两个点的奇偶性改变.</p>
<p>我们考虑求出原图的一棵生成树,然后剩下的边随便选.之后从生成树深度较大的点开始考虑:如果这个点是奇度点,我们就把它的父边删掉.容易发现这样是双射.而如果有奇度点的话可以先组合数选出来然后同样做上面的操作,容易发现是一样的.</p>
<p>不同的连通块可以分别做最后卷起来.</p>
<h5><span id="example5hihocoder1230">Example5(Hihocoder1230)</span></h5>
<p>这题最重要的一点在于观察到一组<span class="math inline">\(a\)</span>如果有解,那么一定是唯一解.为啥呢?我们考虑如何构造一个解:从小位到高位枚举,如果当前位所有数异或起来是<span class="math inline">\(1\)</span>,那么<span class="math inline">\(x\)</span>这一位也必然是<span class="math inline">\(1\)</span>,然后加上后进位.这是由于序列长度是奇数.然后就每次对于<span class="math inline">\(a\in [x,m+x]\)</span>计数,做FWT就行.</p>
<h5><span id="example623省选10连测-day5b">Example6(23省选10连测 day5B)</span></h5>
<p>首先我们要知道,一轮冒泡排序的过程等价于:从前往后考虑每一个点,如果它前面存在一个比它大的点,就将它和前面的点交换.</p>
<p>于是我们考虑令<span class="math inline">\(b_i=\sum_{j=1}^{i-1}[a_j&gt;a_i]\)</span>.也就是每次冒泡排序,这个<span class="math inline">\(b_i\)</span>都会变成<span class="math inline">\(\max\{b_i-1,0\}\)</span>.显然<span class="math inline">\(b_i\)</span>需要满足的条件是<span class="math inline">\(b_i\in[0,n-i]\)</span>,接下来我们证明:只要满足这个条件,<span class="math inline">\(b\)</span>和<span class="math inline">\(a\)</span>就是双射关系.根据<span class="math inline">\(a\)</span>还原<span class="math inline">\(b\)</span>是简单的,那么如何根据<span class="math inline">\(b\)</span>还原<span class="math inline">\(a\)</span>呢?我们只需要从大向小考虑元素,就可以判断元素插入哪里.</p>
<p>有了这个条件后,我们不妨设原序列是<span class="math inline">\(a&#39;\)</span>,其对应<span class="math inline">\(b&#39;\)</span>,那么显然<span class="math inline">\(b_i=\max\{0,b_i&#39;-m\}\leq
\max\{0,n-i-m\}\)</span>.也就是说,如果<span class="math inline">\(b_i=0\)</span>,那么<span class="math inline">\(b_i&#39;\in[0,m]\)</span>,反之<span class="math inline">\(b_i&#39;=b_i+m\)</span>.但问题在于:我们如何保证<span class="math inline">\(b_i&#39;\in[0,n-i]\)</span>呢?不难发现,冒泡排序每次会把前面最大的数扔到后面,也就是说整个序列最后的<span class="math inline">\(m\)</span>个数一定有序,那我们分开考虑:对于最后的<span class="math inline">\(m\)</span>个数,它一开始在序列中的相对顺序是无所谓的:无论如何都会扔到最后.而对于其它的数,如果<span class="math inline">\(b_i=0\)</span>,<span class="math inline">\(b_i&#39;\in[0,m]\)</span>,由于最后都已经凑出<span class="math inline">\(m\)</span>个数了,从大向小将数字插入,一定可以使这一部分满足条件.而如果<span class="math inline">\(b_i&gt;0\)</span>,由于有判定条件<span class="math inline">\(b_i\leq
\max\{0,n-i-m\}\)</span>,显然满足.于是我们设一共有<span class="math inline">\(k\)</span>个<span class="math inline">\(b_i=0\)</span>的位置(也就是前缀最大值位置),于是自然有<span class="math inline">\(f(a,m)=(m+1)^km!\)</span>.注意这个式子的前提在于判定每个<span class="math inline">\(b_i\leq \max\{0,n-i-m\}\)</span>以及<span class="math inline">\(a\)</span>的最后<span class="math inline">\(m\)</span>个位置是<span class="math inline">\(n-m+1,\cdots,n-1
,n\)</span>.到这里不难发现只要满足后者前者必定满足.现在只需要统计前缀最大值的个数就可以解决这个问题了.这个设计个<span class="math inline">\(dp_{i,j}\)</span>表示前<span class="math inline">\(i\)</span>个数的最大值是<span class="math inline">\(j\)</span>就行.</p>
<h3><span id="拆多项式">拆多项式</span></h3>
<p>通常适用于数据范围中有一项的范围不大的情况,然后拆成多项式后可以带入另一项较大的值.</p>
<h5><span id="example122zr提高组十连测day5可">Example1([22zr提高组十连测day5]可)</span></h5>
<p>首先考虑数位dp,每次枚举当前的<span class="math inline">\(k\)</span>个数中还有<span class="math inline">\(x\)</span>个数被limit,这次又有<span class="math inline">\(y\)</span>个数不用被limit,再枚举一下当前各位之和,然后可以写一个转移,复杂度<span class="math inline">\(O(k^4\lg x)\)</span></p>
<p>然后想了好久发现这个东西好像优化不动了.</p>
<p>冷静一下,注意到问题在于枚举,我们不妨把枚举换成容斥试试.设<span class="math inline">\(g(x)\)</span>为<span class="math inline">\(\sum
a\)</span>为<span class="math inline">\(x\)</span>的方案数,那么可以通过容斥得知:</p>
<p><span class="math display">\[
g(n)=\sum_{i=0}^k(-1)^i\binom{k}{i}\binom{n-i(x+1)+k-1}{k-1}
\]</span> 我们最后要求的答案也就是<span class="math inline">\(\sum
f(n)g(n)\)</span>,继续推式子:</p>
<p><span class="math display">\[
ans=\sum_{n=0}^{kx}f(n)g(n)=\sum_{n=0}^{kx}f(n)\sum_{i=0}^k(-1)^i\binom{k}{i}\binom{n-i(x+1)+k-1}{k-1}
\]</span> <span class="math display">\[
=\sum_{i=0}^k(-1)^i\binom{k}{i}\sum_{n=0}^{kx}f(n)\binom{n-i(x+1)+k-1}{k-1}
\]</span> 看上去好像推不动了.</p>
<p>冷静一下,会发现<span class="math inline">\(n\)</span>的取值远远大于<span class="math inline">\(i,k\)</span>的取值.于是我们选择把组合数拆成一个<span class="math inline">\(k-1\)</span>次多项式,这样只需要处理出这个多项式的每一项的系数,然后就可以预处理后面的东西.</p>
<p>拆二项式系数的时候要注意特判上指标小于下指标的情况.</p>
<p><span class="math display">\[
ans=\sum_{i=0}^k(-1)^i\binom{k}{i}\sum_{j=0}^{k-1}c_{i,j}\sum_{n=i(x+1)}^{kx}f(n)n^j
\]</span> 其中<span class="math inline">\(c_{i,j}=[n^j]\binom{n-i(x+1)+k-1}{k-1}\)</span>.</p>
<p>这样我们就成功地分离出了一项<span class="math inline">\(\sum_{n=i(x+1)}^{kx}f(n)n^j\)</span>,接下来考虑怎么处理这一项.</p>
<p>考虑枚举<span class="math inline">\(i\)</span>,然后设<span class="math inline">\(dp_{j,limit}=\sum_{n=0}^{limit}f(n)n^j\)</span>,考虑拿数位dp做这个东西,枚举当前位置<span class="math inline">\(cnt\)</span>的取值<span class="math inline">\(w\)</span>,根据二项式定理,<span class="math inline">\(dp_{a+b,limit}\leftarrow
\binom{a+b}{b}dp_{b,limit}f(w)(w10^{cnt})^a\)</span>,那么<span class="math inline">\(\sum_{n=i(x+1)}^{kx}f(n)n^j=dp_{j,kx}-dp_{j,i(x+1)-1}\)</span>.</p>
<p>这样我们需要枚举<span class="math inline">\(i,a,b,cnt\)</span>得到一组答案,然后还需要把这些答案合并起来,复杂度<span class="math inline">\(O(k^3\lg x)\)</span>.</p>
<h3><span id="抽屉原理">抽屉原理</span></h3>
<h5><span id="example1unr-6小火车">Example1([UNR #6]小火车)</span></h5>
<p>首先考虑证明一定有解:</p>
<p>注意到我们可以先选择出两个不完全相同的集合,如果这两个集合的和相等,那么我们把只在第一个集合的<span class="math inline">\(b\)</span>设为<span class="math inline">\(-1\)</span>,只在第二个集合的<span class="math inline">\(b\)</span>设为<span class="math inline">\(1\)</span>,都在或都不在的设为<span class="math inline">\(0\)</span>,那么这显然就是一组解.</p>
<p>而由于<span class="math inline">\(p&lt;2^n\)</span>,根据抽屉原理,显然存在这么两个集合.</p>
<p>考虑对于一个权值区间<span class="math inline">\([l,r]\)</span>,如果有超过<span class="math inline">\(r-l+1\)</span>个集合的和在这个区间内,那一定有两个集合可以组成一个解.</p>
<p>假设现在已知权值区间<span class="math inline">\([l,r]\)</span>一定有解,我们判断<span class="math inline">\([l,mid]\)</span>中是否有超过<span class="math inline">\(mid-l+1\)</span>个集合,使用折半搜索再合并可以快速求出权值和为某个定值的集合有多少个.然后可以使用双指针判断,继续递归下去判断即可.复杂度<span class="math inline">\(O(2^{\frac{n}{2}}n)\)</span>.</p>
<h5><span id="example2noi2021量子通信">Example2([NOI2021]量子通信)</span></h5>
<p>考虑<span class="math inline">\(k\leq
15\)</span>,所以如果我们把两个零一串每<span class="math inline">\(16\)</span>个分一块,那么两个零一串相差少于<span class="math inline">\(k\)</span>处,则一定有一块完全相等.由于数据随机,这个概率为<span class="math inline">\(\cfrac{1}{2^{16}}\)</span>.</p>
<p>考虑把在一块中是某个数的零一串全都集合到一起,然后暴力判断,复杂度约为<span class="math inline">\(O(\cfrac{n^2q}{2^{16}w})\)</span>.</p>
<h3><span id="拆贡献">拆贡献</span></h3>
<h5><span id="example12022qbxt国庆day7fenwick">Example1([2022qbxt国庆Day7]fenwick)</span></h5>
<p>注意到要变换多次,考虑每个值的贡献.</p>
<p>一个点要往后更新,不难通过平行求和法则一个值<span class="math inline">\(v\)</span>对它向后跳<span class="math inline">\(w\)</span>步的贡献为<span class="math inline">\(\binom{w+k}{w}\)</span>.但是有修改很难办,怎么办?注意到如果我们暴力跳,查询的时候复杂度是<span class="math inline">\(O(1)\)</span>的,我们没必要让它这么低.我们把所有值对<span class="math inline">\(p\)</span>这个点的更新存到一个数组里,显然只有<span class="math inline">\(\log
n\)</span>种步数.最后每次查询的时候用组合数一起更新即可.</p>
<h5><span id="example2qoj5097-小-p爱学习">Example2([QOJ5097] 小 P
爱学习)</span></h5>
<p>这个题的厉害之处在于完全将贡献拆开.</p>
<p>我们不妨设最后将所有的数分成了<span class="math inline">\(k\)</span>组,那么显然我们只要算出两个东西就可以得到此时的答案的和:</p>
<ol type="1">
<li><span class="math inline">\(\sum_{x_{1,...,k}}\prod_{i=1}^ka_{x_i}\\\)</span>.</li>
<li><span class="math inline">\(\sum_{1\leq x_1,...,x_k\leq n,\sum
x=n}\frac{(nm-k)!}{\prod_{i=1}^k(x_im-1)!}\\\)</span>.</li>
</ol>
<p>第一个显然就是个背包,问题在于第二个的分子部分,我们用生成函数,设<span class="math inline">\(F=\sum_{i=1}^{n}\frac{1}{(im-1)!}x^i\)</span>,我们要求的就是<span class="math inline">\([x^n]F^k,\forall 1\leq k\leq n\)</span>.</p>
<p>这个东西可以做BSGS,也就是光速幂.这样就可以用<span class="math inline">\(O(n^2\sqrt n)\)</span>预处理,用<span class="math inline">\(O(n)\)</span>查询单个<span class="math inline">\(k\)</span>.</p>
<h5><span id="example3luogu4211lnoi2014lca">Example3(Luogu4211
[LNOI2014]LCA)</span></h5>
<p>将<span class="math inline">\(dep\)</span>拆成到根节点的路径上的点的数量,差分一下<span class="math inline">\([l,r]\)</span>,这样就只需要求<span class="math inline">\(z\)</span>和一个前缀点的LCA的<span class="math inline">\(dep\)</span>.将这个操作离线下来,我们对于每一个点把它到根节点的路径上的点全部<span class="math inline">\(+1\)</span>,查询每个点到根节点上的权值和就行.</p>
<p>CF757G是一样的,只不过好像需要卡卡空间?</p>
<h3><span id="二进制拆位">二进制拆位</span></h3>
<h5><span id="example1luogu5354ynoi2017由乃的oj">Example1(Luogu5354
[Ynoi2017]由乃的OJ)</span></h5>
<p>对每一位分开处理,对于线段树上每个区间,设<span class="math inline">\(f_{0}\)</span>表示一开始<span class="math inline">\(v\)</span>的这一位是<span class="math inline">\(0\)</span>,最后的答案是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>,显然可以合并,拿bitset优化一下.</p>
<h3><span id="bitset优化暴力">bitset优化暴力</span></h3>
<h5><span id="example12022qbxt国庆day4d">Example1([2022qbxt国庆Day4]D)</span></h5>
<p>先想一个很明显的优化:我们记录一下每个字符出现的位置,当我们判断当前字符串是否出现过的时候,我们直接从这个字符串开头的字符存在的位置进行判断.</p>
<p>如果我们记录下每个字符在母串中的某个位置是否存在,我们就可以基本脱离母串进行判断.注意到只需要用bitset优化这个过程就可以做到<span class="math inline">\(O(\sum tlen+\cfrac{nq}{w})\)</span>.</p>
<h5><span id="example2noi2020-制作菜品">Example2([NOI2020] 制作菜品)</span></h5>
<p>这题首先要根据数据范围,注意到<span class="math inline">\(m\geq
n-1\)</span>的时候存在贪心解法.</p>
<p>具体怎么做呢?我们将原料按照质量排序,每次选最小的那个,不够的话就选最大的那个的一部分,重新排序后递归处理.</p>
<p>为啥这个是对的呢?根据鸽笼原理,最大的那个的质量一定大于等于<span class="math inline">\(\frac{mk}{n}\)</span>,而最小的那个数和最大的那个数之和一定大于等于<span class="math inline">\(0+\frac{mk}{n-1}\geq k\)</span>,因此一定有解.</p>
<p>接下来我们就只需要做<span class="math inline">\(m=n-2\)</span>的情况.</p>
<p>那么这个怎么做呢?我们发现每道菜和两个原材料有关,于是不妨抽象成图论模型:将这两个原材料所代表的点用一条边连起来:我们发现有<span class="math inline">\(n-2\)</span>条边和<span class="math inline">\(n\)</span>个点,这个图必不联通.也就是说如果有解,必然可以分成两个集合,这两个集合互不相关.如果我们分成了两个集合,一个集合有<span class="math inline">\(a\)</span>个原材料,另一个集合有<span class="math inline">\(n-a\)</span>个原材料,我们就可以第一个集合做<span class="math inline">\(a-1\)</span>道菜,第二个集合做<span class="math inline">\(n-a-1\)</span>道菜,自然解决了问题.</p>
<p>接下来的问题在于01背包,用bitset优化一下.</p>
<h3><span id="简化能更新答案的集合">简化能更新答案的集合</span></h3>
<p>简单来说就是当你注意到一个答案只有可能由某些地方贡献,我们就只判断这些地方的贡献.有的时候不仅需要减小集合,还需要使这个集合尽可能好维护,这个时候可能会向集合里放一些不合法但不可能更新答案的选项.</p>
<h5><span id="example1cf1149d-abandoningroads">Example1(CF1149D Abandoning
Roads)</span></h5>
<p>首先一个把只有<span class="math inline">\(a\)</span>边的连通块缩起来,那<span class="math inline">\(1\)</span>到<span class="math inline">\(i\)</span>的最短路显然是通过几个<span class="math inline">\(b\)</span>连接若干个连通块来到<span class="math inline">\(i\)</span>.</p>
<p>由于防止用<span class="math inline">\(b\)</span>边链接连通块的时候连出环,我们需要用一个<span class="math inline">\(dp_{S,x}\)</span>表示从<span class="math inline">\(1\)</span>经过<span class="math inline">\(S\)</span>集合的连通块到<span class="math inline">\(x\)</span>的最短路.</p>
<p>但是集合数量可能很多,怎么办?</p>
<p>注意到,如果这个集合只有一个点,那显然不可能重复经过;如果这个集合只有两个点,那重复经过意味着想用一条长度为<span class="math inline">\(2b\)</span>的边代替一条长度为<span class="math inline">\(a\)</span>的边,显然也不优秀;同理集合只有三个点也不优秀.</p>
<p>于是只有点数<span class="math inline">\(\geq
4\)</span>的集合是有用的,复杂度<span class="math inline">\(O(2^{\frac{n}{4}}m\log n)\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个正整数,要求将<span class="math inline">\(n\)</span>个正整数分到<span class="math inline">\(k\)</span>个集合中,每个集合恰好<span class="math inline">\(\cfrac{n}{k}\)</span>个数(保证<span class="math inline">\(k|n\)</span>)且每个集合中不能有相同的数.设一个方案的代价是每个集合的极差之和,求最小代价,<span class="math inline">\(n\leq 70\)</span>.</p>
<p>首先<span class="math inline">\(O(3^n)\)</span>很好设计不说了.</p>
<p>注意到这题看上去就不太能多项式复杂度,我们考虑简化一下状态数.考虑做<span class="math inline">\(O(3^n)\)</span>的时候,我们是将<span class="math inline">\(\cfrac{n}{k}\)</span>个数打包成一个集合再塞进去,这样看上去就不太优秀,我们考虑能不能一个数一个数塞进去.</p>
<p>我们现在有<span class="math inline">\(k\)</span>个集合,要塞进去一个数到一个集合中.注意到最后的代价实际上和很多数是没啥关系的.考虑先把数字从小到大排序,然后挨个插入集合.如果插入一个数之前,这个集合是空的,那这个数对答案有负的贡献;如果插入一个数之后,这个集合是满的,那这个数对答案有正的贡献;反之无贡献.</p>
<p>于是我们可以枚举目前集合填成啥样了,这样状态数变成了<span class="math inline">\((\cfrac{n}{k}+1)^k\)</span>.</p>
<p>这样还是过不去,我们再冷静一下,显然我们只关心每个集合填了多少个数而不关心具体是哪个集合,于是我们把每个集合的大小排序后再压成状态,这样状态数就是<span class="math inline">\(\sum_{i=0}^{k}{\binom{i+\frac{n}{k}}{\frac{n}{k}}}\\\)</span>,根据目前填到第几个数分一分类就会发现这部分上限是<span class="math inline">\(O(n\binom{2\sqrt n}{\sqrt n})\)</span>.</p>
<p>不过我们还需要保证一个集合里不能有相同的元素.这里我们考虑将相同的元素一起放并规定放的顺序.因为放进去的集合在放这种元素前是有大小顺序的,我们每次放进最大的集合中.换句话说,我们设<span class="math inline">\(f_{i,j,S}\)</span>表示目前放到<span class="math inline">\(i\)</span>,状态是<span class="math inline">\(S\)</span>,并且<span class="math inline">\(a_i\)</span>放进去的那个集合目前大小是<span class="math inline">\(j+1\)</span>(放前是<span class="math inline">\(j\)</span>).</p>
<p>算一下复杂度是<span class="math inline">\(O(n^2\binom{2\sqrt n}{\sqrt
n})\)</span>的,实际上远远跑不满,甚至写了个map来做双射也跑过去了.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张有向图,多组询问,每次询问三个数<span class="math inline">\(p,x,y\)</span>,求是否能从<span class="math inline">\(p\)</span>出发只经过<span class="math inline">\([x,y]\)</span>中的边且经过的边的编号单调递减到达<span class="math inline">\(1\)</span>号节点.</p>
<p>冷静一下,先加边,注意到如果加<span class="math inline">\(u\rightarrow
v\)</span>这条边的时候,不存在一条从<span class="math inline">\(v\)</span>到<span class="math inline">\(1\)</span>的路径,那这条边显然没有用.</p>
<p>做完这一步后,我们注意到可以在加边的过程中对于每个<span class="math inline">\(u\)</span>维护从<span class="math inline">\(u\)</span>到<span class="math inline">\(1\)</span>的所有合法路径经过的最小编号的边的最大值<span class="math inline">\(maxn_u\)</span>,这样就可以对于每个点维护若干个二元组<span class="math inline">\((l,r)\)</span>,只要对于<span class="math inline">\(p\)</span>,存在一个二元组<span class="math inline">\([l,r]\in[x,y]\)</span>就合法.</p>
<h5><span id="example4petrozavodskwinter-2014-moscow-su-tapir-contestopenstrain-contest-1435ccombinations-strike-back">Example4([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435)
C]Combinations Strike Back)</span></h5>
<p>给定一个大小为<span class="math inline">\(n\)</span>的可重集,多次询问,每次询问查询插入一个数<span class="math inline">\(x\)</span>后,这个集合大小为<span class="math inline">\(k\)</span>的可重子集共有多少个,每次询问互相独立.<span class="math inline">\(n,q\leq 1.2\times 10^5\)</span>,答案对<span class="math inline">\(1051721729=1003\times 2^{20}+1\)</span>取膜.</p>
<p>自然的想法是上生成函数.</p>
<p>假设数字<span class="math inline">\(i\)</span>在原集合中共有<span class="math inline">\(b_i\)</span>个,那么原集合大小为<span class="math inline">\(k\)</span>的可重子集数量显然为<span class="math inline">\([z^k]\prod_{i=1}^n\frac{z^{b_i+1}-1}{z-1}\)</span>.</p>
<p>插入一个数字<span class="math inline">\(x\)</span>,自然就是乘上一个<span class="math inline">\(\frac{z^{b_x+2}-1}{z^{b_x+1}-1}\)</span>.但如果每次都乘的话复杂度显然不行.怎么办?</p>
<p>注意到答案与插入的数字本身无关,只和这个数字在原集合中出现了多少次有关.而原集合最多有<span class="math inline">\(\sqrt
n\)</span>(自然根号)个出现次数不同的数字,预处理一下就行.</p>
<h5><span id="example5cf1621gweightedincreasing-subsequences">Example5([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<p>一个自然的想法是拆出每个点<span class="math inline">\(x\)</span>的贡献,再枚举终点<span class="math inline">\(y\)</span>,这样问题就转化为了以<span class="math inline">\(y\)</span>结尾并且包含<span class="math inline">\(x\)</span>的LIS计数,这样做到<span class="math inline">\(O(n^2)\)</span>的复杂度.</p>
<p>那么怎么继续优化呢?我们还是想拆出每个点的贡献,但是如何不枚举终点<span class="math inline">\(y\)</span>呢?我们考虑枚举一下和它做贡献的点<span class="math inline">\(z\)</span>满足<span class="math inline">\(a_z&gt;a_x\)</span>并且终点<span class="math inline">\(y\)</span>满足<span class="math inline">\(y&lt;z\)</span>,但是这样的<span class="math inline">\(z\)</span>有很多个,不难发现取最后一个就行.如果我们对整个序列取后缀<span class="math inline">\(\max\)</span>,就可以得到所有可能被当作<span class="math inline">\(z\)</span>的点,而且更强的性质是,只要这些点不在LIS中,LIS的终点<span class="math inline">\(y\)</span>必然有<span class="math inline">\(y&lt;z\)</span>,这是显然的.做一下补集转化,就变成了计数包含<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>的LIS数量.</p>
<p>注意到<span class="math inline">\(z\)</span>的数量不多,且所有数字按照权值排序后被这些<span class="math inline">\(z\)</span>分成了若干个区间.所以颠倒值域和下标重新做LIS就行.</p>
<h5><span id="example6cf919f-a-game-withnumbers">Example6(CF919F A Game With
Numbers)</span></h5>
<p>最小表示法表示每个人的手牌.</p>
<p>不过要注意有可能成环.我们考虑用刷表法更新,最后刷不出来的点就是和.</p>
<h5><span id="example7ioi2014holiday">Example7([IOI2014]holiday)</span></h5>
<p>首先发现走的一定是一个区间,然后发现这个区间<span class="math inline">\([l,r]\)</span>的<span class="math inline">\(l\)</span>随<span class="math inline">\(r\)</span>的增大具有决策单调性,然后做完了,上主席树就行.</p>
<h5><span id="example8cf1446d2">Example8(CF1446D2)</span></h5>
<p>我们假设目前得到的答案区间是<span class="math inline">\([l,r]\)</span>,也就是说<span class="math inline">\([l,r]\)</span>无论如何不可能扩展成更大的区间了.那这需要满足什么条件呢?注意到全局众数一定是答案,如果它不是答案,我们就可以往两边拓展,直到满足区间众数是答案且区间合法.显然可以实现.然后做根号分治.</p>
<p>这个是怎么想到的呢?我们考虑一个区间如何拓展成更大的区间:如果每个数出现次数不降,显然是一个更大的区间.这同样是在说:如果我们能找到一段区间,使得加上这段区间后,原本不是区间众数的数成为了区间众数,并且区间仍然合法,那就一定更为优秀.再注意到如果一个数在全局出现次数多于区间众数,这一定可以实现,进而推出全局众数的结论.</p>
<p>你以为结束了?没有,我们下面给出一个<span class="math inline">\(O(n\log
n)\)</span>的做法:</p>
<p>首先,我们假设全局众数是<span class="math inline">\(x\)</span>,枚举和它一起成为区间众数的数字<span class="math inline">\(y\)</span>,剩下的数先不管,那么区间大概长这个样:xyxyyxyxxxxxx.</p>
<p>我们发现这一段x一定是没有意义的:xyxyyxyxx[xxxx].</p>
<p>我们对于每一个<span class="math inline">\(y\)</span>出现的位置,找到其左右两边离他最近的没有被标记的<span class="math inline">\(x\)</span>标记一下,没有被标记的<span class="math inline">\(x\)</span>一定没有意义.这样对于一组解<span class="math inline">\((x,y)\)</span>,合法的端点数量只有<span class="math inline">\(O(y出现的次数)\)</span>次.每次判断每个端点是否可以做右端点,拿<span class="math inline">\(set\)</span>维护一下后缀和就可以实现<span class="math inline">\(O(n\log n)\)</span>.</p>
<p>当然,这里得到的区间不一定是合法的(有可能<span class="math inline">\(x,y\)</span>出现的次数都不是最多的,但没关系,这种一定不优秀).</p>
<p>【luoguP4062 [Code+#1]Yazid
的新生舞会】也是这个标记的思路,标记的话用一下链表之类的大概能做.</p>
<h4><span id="支配对问题">支配对问题</span></h4>
<p>lxl起的名字.</p>
<p>这里的思路其实大概就是:我们将一些很废物的二元组杀了,然后将剩下的二元组进行贡献答案.我们称这种一个二元组严格强于另一个二元组的限制称作支配关系.</p>
<h5><span id="第一类支配对">第一类支配对</span></h5>
<p>虽然总数很多,但是本质不同的很少.</p>
<h6><span id="example1luogup7880ynoi2006-rldcot">Example1(luoguP7880
[Ynoi2006] rldcot)</span></h6>
<p>我们这么考虑:如果现在有三个点<span class="math inline">\(a,b,c,a&lt;b&lt;c\)</span>,它们两两LCA都是<span class="math inline">\(d\)</span>,那么显然<span class="math inline">\((a,c)\)</span>这一对是没有用的,有用的是<span class="math inline">\((a,b)\)</span>和<span class="math inline">\((b,c)\)</span>.进一步你发现这等价于什么呢:我们从下往上合并子树,每次做启发式合并,假设当前要把子树<span class="math inline">\(A\)</span>合并到子树<span class="math inline">\(B\)</span>上,考虑所有的点对<span class="math inline">\((a,b),a\in A,b\in
B\)</span>的贡献,显然,能贡献到<span class="math inline">\(a\)</span>的<span class="math inline">\(b\)</span>只有<span class="math inline">\(a\)</span>的前驱和后继,这样我们就只找到了<span class="math inline">\(O(n\log n)\)</span>个点对,它们等价于<span class="math inline">\(O(n\log n)\)</span>个矩形,最后把<span class="math inline">\(dep\)</span>相等的合并一下,随便做做.</p>
<h6><span id="example2luogup8528ynoi2003-铃原露露">Example2(luoguP8528
[Ynoi2003] 铃原露露)</span></h6>
<p>和Example1基本差不多.</p>
<h5><span id="第二类支配对">第二类支配对</span></h5>
<p>虽然总数很多,但是有用的很少.</p>
<h6><span id="example1cf765f">Example1(CF765F)</span></h6>
<p>典.</p>
<h6><span id="example2codechef-minxorseg">Example2(CodeChef MINXORSEG)</span></h6>
<p>这个题比较厉害,仍然考虑<span class="math inline">\(a&lt;b&lt;c\)</span>,我们看如果<span class="math inline">\(a\oplus c&gt;\max\{a\oplus b,b\oplus
c\}\)</span>的充要条件是什么.</p>
<p>简单分类讨论一下,不难发现这意味着<span class="math inline">\(LCP(a,c)&gt;LCP(a,b)\)</span>.于是有用的贡献对只有<span class="math inline">\(O(n\log v)\)</span>个.</p>
<h6><span id="example3luogu9058-ynoi2004rpmtdq">Example3(Luogu9058 [Ynoi2004]
rpmtdq)</span></h6>
<p>这题更为逆天.</p>
<p>首先,这题有两个维度:树和序列,我们要先处理掉其中一维.lxl:树这一维度更加困难,因此我们应该是选择困难的那一维分治掉.</p>
<p>考虑边分治,然后就只需要处理两棵子树间的贡献.但是对于一棵子树内的点,我们要找到在另一棵子树中有可能和它产生贡献的点对,这个咋做呢?</p>
<p>牛逼的一步来了,我们考虑对于每个点,算出它到分治中心的距离<span class="math inline">\(r\)</span>,然后找另一棵子树中到分治中心距离<span class="math inline">\(\leq r\)</span>的点<span class="math inline">\(x\)</span>与它贡献,但是这还是有很多点,其实只需要找这些点中的<span class="math inline">\(x\)</span>的前驱后继就可以了.因为如果<span class="math inline">\(x&lt;b&lt;c\)</span>,<span class="math inline">\(b\)</span>和<span class="math inline">\(c\)</span>在同一边,那么<span class="math inline">\((b,c)\)</span>一定比<span class="math inline">\((a,c)\)</span>更加优秀.</p>
<h6><span id="example4cf1635f-closestpair">Example4(CF1635F Closest
Pair)</span></h6>
<p>首先,由于匹配无序,我们考虑对于一对数<span class="math inline">\((i,j)\)</span>,只在<span class="math inline">\(w\)</span>较大的那个位置来更新答案.</p>
<p>不妨假设较大的为<span class="math inline">\(i\)</span>,我们考虑<span class="math inline">\(i\)</span>有可能和谁来更新答案.</p>
<p>如果现在有两个数<span class="math inline">\(k&lt;j,w_k\leq w_i\and
w_j\leq w_i\)</span>,如果<span class="math inline">\(w_k\geq
w_j\)</span>,那肯定选<span class="math inline">\((j,i)\)</span>更优秀;不然,如果选<span class="math inline">\((k,i)\)</span>比选<span class="math inline">\((j,i)\)</span>更优秀,那么我们会发现<span class="math inline">\((k,j)\)</span>比<span class="math inline">\((k,i)\)</span>更要优秀,因此答案一定会由<span class="math inline">\((k,j)\)</span>更新而不是由<span class="math inline">\((k,i)\)</span>更新.通过这里的分析我们发现,每个数只有可能和它左右两边的第一个<span class="math inline">\(w\)</span>小于等于它的数更新.</p>
<p>于是我们可以找到<span class="math inline">\(O(n)\)</span>个可能更新答案的点对,设点对为<span class="math inline">\((x,y)\)</span>,我们每次查找一个区间<span class="math inline">\([l,r]\)</span>,即要找到所有在<span class="math inline">\([l,r]\)</span>内的点对并将它们的答案取min.</p>
<p>这一步可以将<span class="math inline">\((x,y)\)</span>当作二维平面的点,查询当作一个左下角为<span class="math inline">\((l,l)\)</span>,右上角为<span class="math inline">\((r,r)\)</span>的矩阵,就是一个经典的矩阵取min的操作.</p>
<h6><span id="example5icpc2017wfmoney-for-nothing">Example5([ICPC2017
WF]Money for nothing)</span></h6>
<p>注意到抽象问题后等价于有若干个A点<span class="math inline">\((x_1,y_1)\)</span>和若干个B点<span class="math inline">\((x_2,y_2)\)</span>,我们想要找到一个A点和一个B点使得<span class="math inline">\((x_1-x_2)(y_1-y_2)\)</span>最大.也就是它们作为右上和左下顶点的矩形面积最大.</p>
<p>怎么做这个问题呢?首先我们必须要发现的一点是:对于A点来说,如果有两个点<span class="math inline">\((a_1,b_1)\)</span>和<span class="math inline">\((a_2,b_2)\)</span>满足<span class="math inline">\(a_1\leq a_2\)</span>,<span class="math inline">\(b_1\leq
b_2\)</span>,那么前者一定更优秀.把那些废点删掉后,就会得到一个横坐标递增,纵坐标递减的点的序列.对于B点是同理的.</p>
<p>这个序列看上去就很亲切了,接下来简单证明一下是满足决策单调性的就可以判断答案了.</p>
<h3><span id="奇偶染色">奇偶染色</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一个<span class="math inline">\(9\times
9\)</span>的网格,一开始上面有<span class="math inline">\(65\)</span>个蚂蚁,每个蚂蚁每分钟会四联通移动一格,每个蚂蚁每三分钟所在的格子不能在一条直线上,求证:一定会有一个时间,两只蚂蚁在同一个格子里.</p>
<p>sol1:</p>
<p>注意到如果条件不成立,则一定存在若干条路径,蚂蚁在路径上转圈,也就是找到长度和尽可能大的路径不交地覆盖矩阵,注意到一定是使用<span class="math inline">\(2\times 2\)</span>的矩阵路径,于是最多有<span class="math inline">\(64\)</span>只蚂蚁.(感性理解)</p>
<p>sol2:</p>
<p>考虑对奇偶染色,设<span class="math inline">\((i,j)=\begin{cases}white
&amp; 2\nmid (i+j)\\blue&amp; 2\mid i\and 2\mid
j\\yellow&amp;otherwise\end{cases}\)</span>.</p>
<p>我们把黄格子和蓝格子称为彩格子,注意到如果一开始一只蚂蚁在白格子,一分钟后必定在彩格子.一开始一只蚂蚁在蓝格子,两分钟后必定在黄格子.</p>
<p>因为最多有<span class="math inline">\(16\)</span>个蓝格子,所以一开始黄格子和蓝格子上分别最多有<span class="math inline">\(16\)</span>只蚂蚁,从而白格子上最多有<span class="math inline">\(32\)</span>只蚂蚁,总共最多<span class="math inline">\(64\)</span>只,得证.</p>
<h5><span id="example2cf1521e">Example2(CF1521E)</span></h5>
<p>首先考虑我们显然可以一行空一行放,也就是说如果最大的<span class="math inline">\(a_i&gt; n\times
\lceil\frac{n}2\rceil\)</span>的话显然不可以,如果能放的位置少于<span class="math inline">\(\sum a\)</span>显然也不可以.</p>
<p>类似lyz那个题,我们考虑删去行列编号均为偶数的点,这样就满足了一个子矩阵不能全放的限制.</p>
<p>然后呢?我们考虑将所有能放的位置排序.先把所有的位置分成三类:<span class="math inline">\((even,odd),(odd,odd),(odd,even)\)</span>,不同类位置按照这个顺序排,不然按照相对位置排.然后直接从头开始放.如果不合法,一定是同种颜色放到了<span class="math inline">\((even,odd)\)</span>和<span class="math inline">\((odd,even)\)</span>,并且相同类别是按照相对位置排序的,于是一定不满足最大的<span class="math inline">\(a_i\leq n\times
\lceil\frac{n}2\rceil\)</span>的限制条件.所以这么做一定是对的.</p>
<p>好!冷静一下,咋想到的啊.</p>
<p>首先这种题肯定要找到一些看上去就很显然的边界,当你发现找不到的时候,大概率就一定有解了(大概率).</p>
<p>然后呢?注意到不合法一定是同种颜色放到了<span class="math inline">\((even,odd)\)</span>和<span class="math inline">\((odd,even)\)</span>,又观察到每种位置的数量和一个边界限制条件很像,于是就可以构造出来了.</p>
<p>所以大概是说,这种构造题要先想判断边界的条件,然后对着做.</p>
<h5><span id="example3cf1615f">Example3(CF1615F)</span></h5>
<p>太牛逼了这个题.</p>
<p>首先,找边界条件:啥时候<span class="math inline">\(s\)</span>不能变成<span class="math inline">\(t\)</span>呢?一个自然的想法是数<span class="math inline">\(1\)</span>的个数的奇偶性,但这样显然不对(<span class="math inline">\(01\)</span>和<span class="math inline">\(10\)</span>不能互相转移),我们需要一个更强的条件.</p>
<p>然后:注意到每次操作是相邻的两个数,于是我们有:奇数位置的和-偶数位置的和是定值.但是:注意到这个操作是有限制的!它只能对相邻相同的位置做.</p>
<p>然后我也不知道咋想到的,可能是因为找到限制条件后只要不改变限制条件就可以随便转化?反正我们先把偶数位置全部取反,这样操作就变成了交换相邻数字(如果相邻数字不相同,取反后相同,交换无用).</p>
<p>就可以dp了.</p>
<h5><span id="example4cf1517g">Example4(CF1517G)</span></h5>
<p>按照横纵坐标的奇偶性,分四种情况染色.注意到四边形接下来的路径一定会形如<span class="math inline">\(1\rightarrow
2\rightarrow3\rightarrow4\)</span>,建立分层图跑最小割.</p>
<h3><span id="捆绑更新答案">捆绑更新答案</span></h3>
<h5><span id="example12022qbxt国庆day6binary">Example1([2022qbxt国庆Day6]binary)</span></h5>
<p>首先因为有<span class="math inline">\(-1\)</span>,我们先考虑一个朴素的暴力,从<span class="math inline">\(L\)</span>到<span class="math inline">\(R\)</span>枚举现在被匹配的数<span class="math inline">\(i\)</span>,我们假设之前匹配到<span class="math inline">\(p-1\)</span>,那我们接下来一定是要找到一个最小的<span class="math inline">\(x\geq p\)</span>能把<span class="math inline">\(i\)</span>给匹配掉,仔细思考这个过程,由于是二进制考虑最高位,不难发现我们只需要找到<span class="math inline">\((p\and i)\oplus i\)</span>的最高位<span class="math inline">\(1\)</span>,然后把<span class="math inline">\(p\)</span>的这一位改成<span class="math inline">\(1\)</span>,然后后面的位置全部设成<span class="math inline">\(0\)</span>,如果<span class="math inline">\(i\subseteq p\)</span>那么就不用改.</p>
<p>冷静一下,二进制大概率是没啥通项公式的,还是要一点一点做.但是我们枚举每一个数实在是太慢了,我们考虑一个地方:<span class="math inline">\(i\subseteq p\)</span>就不用改,下一步<span class="math inline">\(i+=1,p+=1\)</span>,如果没有发生进位还是不用改,这个过程看上去就很可以优化.</p>
<p>所以我们考虑:当遇到<span class="math inline">\(i\subseteq
p\)</span>的时候,我们就捆绑更新.如果不满足就暴力更新.重复这个过程,每次不断暴力更新<span class="math inline">\(\rightarrow\)</span>捆绑更新$<span class="math inline">\(暴力更新\)</span>…<span class="math inline">\(.每次捆绑更新至少会更新一个\)</span>lowbit<span class="math inline">\(,而暴力更新的情况下,每次\)</span>p<span class="math inline">\(至少会多包含一位\)</span>i<span class="math inline">\(.就算后面进位把这一位消掉了,由于这里进位了,那下一步一定可以直接包含掉,于是复杂度也是\)</span>n<span class="math inline">\(的,反复做一下就做完了,这里能分析复杂度\)</span>O(T^2R)$.我们冷静一下,发现二者复杂度算重了,捆绑更新会帮助暴力更新多匹配<span class="math inline">\(1\)</span>,于是复杂度<span class="math inline">\(O(T\log
R)\)</span>.但是肯定跑不满,考场甚至写了个上界<span class="math inline">\(O(T\log^2 R)\)</span>的仍然跑的飞快.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树和一个值域为<span class="math inline">\(n\)</span>序列<span class="math inline">\(a\)</span>,每次询问给出<span class="math inline">\(l,r,x\)</span>.</p>
<p>设<span class="math inline">\(f(x,y)\)</span>为点<span class="math inline">\(x\)</span>朝着<span class="math inline">\(y\)</span>的方向走一步后得到的点,求<span class="math inline">\(x\)</span>在经过<span class="math inline">\(a[l\cdots r]\)</span>操作后得到的答案.</p>
<p>这么考虑:这题看上去就需要把任何一个数字<span class="math inline">\(x\)</span>,通过若干个点变成了一个<span class="math inline">\(f(x)\)</span>,我们要做的就是把<span class="math inline">\(f(x)\)</span>求出来,这玩意很难求,考虑分块,单点用长剖做<span class="math inline">\(O(1)\)</span>求<span class="math inline">\(k\)</span>级祖先,然后对于每个整块预处理出它的<span class="math inline">\(f\)</span>就可以了.</p>
<p>接下来的问题在于如何快速处理一个块的答案,考虑把所有的<span class="math inline">\(x\)</span>扔到树上,然后一起维护它们的<span class="math inline">\(f(x)\)</span>.这玩意看上去好像有点不太能做.</p>
<p>牛逼的一步来了:考虑对于每个块内的<span class="math inline">\(\sqrt
n\)</span>个点,建立这些点的虚树,对于不在虚树上的点,它们一定会往虚树的方向跑(其实也就是向上跑),然后处理出时间扫描线转化成在虚树上的点的问题.对于在虚树上的点,考虑虚树一共有<span class="math inline">\(O(\sqrt
n)\)</span>条边(也就是原树上的路径),我们用一个双端队列维护每条边上的点,显然每次每条边只会有<span class="math inline">\(O(1)\)</span>的入队和出队,这样就实现了<span class="math inline">\(O(n)\)</span>的预处理单个块.</p>
<h3><span id="单独更新答案">单独更新答案</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一个数轴上有<span class="math inline">\(n\)</span>个小球,第<span class="math inline">\(i\)</span>个小球在<span class="math inline">\(x_i\)</span>坐标处.数轴上还有<span class="math inline">\(m\)</span>个洞.第<span class="math inline">\(i\)</span>个洞在<span class="math inline">\(y_i\)</span>坐标处.你每秒可以以相同矢量速度移动所有小球.当一个小球和一个洞重合时,小球就会进洞.求一共可能出现多少种最终情况.(我们认为,两种”最终情况”不同,当且仅当存在一个球在两种情况中进入了不同的魔法洞中)</p>
<p>考场的想法:按照洞分类,把被同样两个洞夹起来的球一起处理,显然会有一段区间往左走一段区间往右走,按照这种区间的长度排序,然后硬dp,复杂度<span class="math inline">\(O(n^3)\)</span>.</p>
<p>实际的做法:我们抛弃区间,单独考虑每个球.对于每个球而言,有用的信息只有它到左端点的距离和它到右端点的距离.我们把这两个距离缩为<span class="math inline">\((x_i,y_i)\)</span>.接下来我们要给每个点<span class="math inline">\(0/1\)</span>染色,如果是<span class="math inline">\(0\)</span>代表它要到左边的洞里,如果是<span class="math inline">\(1\)</span>代表要到右边的洞里.那什么染色条件是无解的呢?</p>
<p>如果存在两个点<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,<span class="math inline">\(col_a=0\)</span>,<span class="math inline">\(col_b=1\)</span>,那显然当<span class="math inline">\(x_a\geq x_b\and y_a\leq
y_b\)</span>时无解.换句话说,如果<span class="math inline">\(col_b=1\and
x_a\geq x_b\and y_a\leq y_b\)</span>,那么<span class="math inline">\(col_a=1\)</span>.我们不妨按照<span class="math inline">\(x\)</span>降序排序,<span class="math inline">\(x\)</span>相同的按照<span class="math inline">\(y\)</span>升序排列.那就会先决定<span class="math inline">\(b\)</span>再决定<span class="math inline">\(a\)</span>.注意到:如果<span class="math inline">\(a\)</span>能确定<span class="math inline">\(c\)</span>的状态,那<span class="math inline">\(b\)</span>一定也能确定<span class="math inline">\(c\)</span>的状态.因此我们采取这个策略:如果<span class="math inline">\(x_a\geq x_b\and y_a\leq y_b\and
col_b=1\)</span>,那我们直接不管<span class="math inline">\(a\)</span>;反之,则考虑一下<span class="math inline">\(a\)</span>的两种取值即可.具体一点,我们设<span class="math inline">\(f_{i,0/1}\)</span>表示以<span class="math inline">\(i\)</span>结尾,<span class="math inline">\(col_i=0/1\)</span>的方案数,然后顺着做就好.注意到:我们其实不关心<span class="math inline">\(col_x\)</span>具体是啥,我们只关心最后的方案数.所以其实可以直接删去第二维.</p>
<p>zhq对这题的理解:</p>
<p>这可以等价成求一个上升子序列.上升子序列说的是如果<span class="math inline">\(x_i&lt;x_j,y_i&gt;y_j\)</span>,<span class="math inline">\(i\)</span>“选了”,<span class="math inline">\(j\)</span>就必须”不选”.但是钦定必须选和必须不选,这两个限制是一样的.就是说,<span class="math inline">\(j\)</span>没有选择的权力了.</p>
<p>这个说法很有意思,但是要注意:类似说法成立当且仅当我们认为<span class="math inline">\(j\)</span>选了和认为<span class="math inline">\(j\)</span>没选对后面不会产生影响.</p>
<h5><span id="example2petrozavodsksummer-2015-moscow-ipt-contestopenstrain-contest-1464-jtwoairlines">Example2([Petrozavodsk
Summer-2015. Moscow IPT Contest(openstrain contest 1464) J]Two
Airlines)</span></h5>
<p>这是一道交互题.给定一张<span class="math inline">\(n\)</span>个点的完全图,每两个点之间是红色的边或是蓝色的边.可以询问<span class="math inline">\(2n\)</span>次某两个点之间的边的颜色,求一条哈密顿回路使得这条路上的颜色段最多有两个.</p>
<p>考虑将点逐个加入.假设现在的哈密顿回路的两种颜色分别是<span class="math inline">\(r_s\rightarrow r_t\)</span>和<span class="math inline">\(b_s\rightarrow b_t\)</span>,当前要加入<span class="math inline">\(x\)</span>,我们每次询问<span class="math inline">\(x\)</span>和<span class="math inline">\(r_t\)</span>和<span class="math inline">\(b_t\)</span>之间的颜色,如果可以加入链就加入.如果不能加入,必然意味着<span class="math inline">\(x\)</span>和<span class="math inline">\(r_t\)</span>之间是蓝边,和<span class="math inline">\(b_t\)</span>之间是红边,我们查一下<span class="math inline">\(r_t\)</span>和<span class="math inline">\(b_t\)</span>之间是什么边,然后将其中一个点与<span class="math inline">\(x\)</span>一起扔到对面就行.</p>
<p>不过这样用了<span class="math inline">\(3n\)</span>次询问,考虑先询问<span class="math inline">\(r_t\)</span>和<span class="math inline">\(b_t\)</span>之间的颜色,这样就能省掉一种.</p>
<h3><span id="寻找不变量">寻找不变量</span></h3>
<h5><span id="example1noip2021-方差">Example1([NOIP2021] 方差)</span></h5>
<p>首先我们注意到:设<span class="math inline">\(b_i=a_i-a_{i-1}\)</span>这个操作相当于交换<span class="math inline">\(b_{i-1}\)</span>和<span class="math inline">\(b_i\)</span>.</p>
<p>接下来推一下式子: <span class="math display">\[
n^2S^2=n\sum_{i=1}^na_i^2-(\sum_{i=1}^na_i)^2\\
=n\sum_{i=1}^n(\sum_{j=1}^ib_j)^2-(\sum_{i=1}^n(n-i+1)b_i)^2\\
=n\sum_{i=1}^n\sum_{j=1}^ib_j\sum_{k=1}^ib_k-\sum_{j=1}^n(n-j+1)b_j\sum_{k=1}^n(n-k+1)b_k\\
=n\sum_{j=1}^nb_j\sum_{k=1}^nb_k\times
(n-\max\{j,k\}+1)-\sum_{j=1}^n(n-j+1)b_j\sum_{k=1}^n(n-k+1)b_k\\
=n\sum_{j=1}^nb_{n-j+1}\sum_{k=1}^nb_{n-k+1}\times
\min\{j,k\}-\sum_{j=1}^njb_{n-j+1}\sum_{k=1}^nkb_{n-k+1}
\]</span> 令<span class="math inline">\(c\)</span>为<span class="math inline">\(b\)</span>的倒置数组,则原式 <span class="math display">\[
=n\sum_{j=1}^nc_{j}\sum_{k=1}^nc_{k}\times
\min\{j,k\}-\sum_{j=1}^njc_{j}\sum_{k=1}^nkc_{k}\\
=2\sum_{j=1}^nnc_j\sum_{k=1}^jc_kk-2\sum_{j=1}^njc_{j}\sum_{k=1}^jkc_{k}+\sum_{i=1}^nc_i^2i(i-1)\\
=2\sum_{j=1}^n(n-j)c_j\sum_{k=1}^jc_kk+\sum_{i=1}^nc_i^2i(i-1)\\
=\sum_{j=1}^n(n-j)c_j\sum_{k=1}^nc_kk+\sum_{i=1}^n(n-1)ic_i^2
\]</span> <del>推到这一步发现好像没啥用但是推了好久懒得删了</del></p>
<p>冷静一下,由于一开始的数列是单调递增的,所以改变后的数列一定也是单调递增的(差分数组均<span class="math inline">\(\geq
0\)</span>).感性上理解,我们肯定是想让尽可能多的数接近绝对值,于是让重新排列后的差分数组呈现单最小值的峰看上去就很优秀.</p>
<p>这样我们设计<span class="math inline">\(dp_{i,S}\)</span>表示现在填到第<span class="math inline">\(i\)</span>小的<span class="math inline">\(b\)</span>,<span class="math inline">\(\sum
a=S\)</span>的情况下最小的<span class="math inline">\(\sum
a^2\)</span>,复杂度<span class="math inline">\(O(n^2a)\)</span>.</p>
<p>注意到<span class="math inline">\(a\)</span>很小的时候大部分<span class="math inline">\(b\)</span>都是<span class="math inline">\(0\)</span>,于是可以优化为<span class="math inline">\(O(na^2)\)</span>.</p>
<h5><span id="example2agc030e-less-than3">Example2([AGC030E] Less than
3)</span></h5>
<p>注意到:当我们把一个位置取反的时候,这个位置相邻的左右两个位置一定有一个<span class="math inline">\(0\)</span>和一个<span class="math inline">\(1\)</span>,所以我们的操作等价于移动<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>的分界线.</p>
<p>然后枚举一下从边界多产生了多少个分界线就行.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1arc110d">Example1(ARC110D)</span></h5>
<p>注意到这相当于先把一个长度等于<span class="math inline">\(m\)</span>的序列划分成<span class="math inline">\(n+1\)</span>段,再从第<span class="math inline">\(i\)</span>段选出<span class="math inline">\(a_i\)</span>,其中<span class="math inline">\(a_{n+1}=0\)</span>.</p>
<p>于是自然是<span class="math inline">\(\binom{n+m}{\sum
a+n}\)</span>.</p>
<h5><span id="example2abc231g">Example2(ABC231G)</span></h5>
<p>乍一看,感觉完全不可做.因为一开始给定<span class="math inline">\(a\)</span>了,感觉上好像也不太能组合意义.</p>
<p>如果没有<span class="math inline">\(a_i\)</span>怎么做?我们设<span class="math inline">\(f_n\)</span>表示将<span class="math inline">\(k\)</span>个小球分到<span class="math inline">\(n\)</span>个盒子后的答案.那乘法相当于:分完后,在每个盒子中取出一个小球的方案数.于是<span class="math inline">\(f_n=\binom{k}{n}n!n^{k-n}\)</span>.</p>
<p>那给定<span class="math inline">\(a\)</span>咋做呢?我们注意到上面的式子好像可以对于任意<span class="math inline">\(n\)</span>快速求.于是将原式子拆为:<span class="math inline">\(\prod(a_i+b_i)\)</span>,那答案就是选出<span class="math inline">\(n-x\)</span>个<span class="math inline">\(a\)</span>和选出<span class="math inline">\(x\)</span>个<span class="math inline">\(b\)</span>的答案.前者可以背包,后者也就是<span class="math inline">\(f_x=\binom{k}{x}x!n^{k-x}\)</span>.</p>
<h5><span id="example3agc060d">Example3(AGC060D)</span></h5>
<p>不妨设<span class="math inline">\(C_p=\{i|p_i&gt;p_{i+1},1\leq
i&lt;n\}\)</span>.</p>
<p>用一下组合意义,注意到答案等于: <span class="math display">\[
\sum_{S}(\sum_{p}[S=C_p])^2
\]</span> 中间那个地方看上去是经典的计数容斥,我们对着它做容斥: <span class="math display">\[
\sum_{S}(\sum_{p}[S=C_p])^2=\sum_{S}(\sum_{S\subseteq
T}\sum_{p}(-1)^{|T|-|S|}[T\subseteq C_p])^2
\]</span> 这个咋做呢?我们考虑用组合意义展开: <span class="math display">\[
\sum_{S}(\sum_{S\subseteq T}\sum_{p}(-1)^{|T|-|S|}[T\subseteq
C_p])^2\\=\sum_{S}\sum_{S\subseteq
T_1,T_2}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])
\]</span> 注意到<span class="math inline">\(S\)</span>屁用没有,直接交换枚举顺序. <span class="math display">\[
\sum_{S}\sum_{S\subseteq
T_1,T_2}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])\\=\sum_{T_1,T_2}2^{|T_1\cap
T_2|}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq C_p])(\sum_p[T_2\subseteq
C_p])
\]</span> 考虑<span class="math inline">\((\sum_{p}[T_1\subseteq
C_p])\)</span>怎么求,注意到这等价于所有<span class="math inline">\(T_1\)</span>中的位置全都被钦定为<span class="math inline">\(&gt;\)</span>,而其他位置任意,如果我们设所有以大于号连接的部分的长度为<span class="math inline">\(l_1,l_2,...,l_k\)</span>,那么这里的答案就是<span class="math inline">\(n!\prod_{i=1}^k\frac{1}{l_i!}\)</span>.</p>
<p>但我们很快发现了难点:<span class="math inline">\(2^{|T_1\cap
T_2|}\)</span>这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中都是<span class="math inline">\(&gt;\)</span>的位置,这个好像不太好求,因为<span class="math inline">\(&gt;\)</span>是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:
<span class="math display">\[
\sum_{T_1,T_2}2^{|T_1\cap T_2|}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])\\
=\sum_{T_1,T_2}2^{((n-1)-|T_1\cup
T_2|)-(n-1)}(-2)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])\\
=2^{1-n}(n!)^2\sum_{T_1}((-2)^{|T_1|}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}((-2)^{|T_2|}\frac{1}{\prod
l_{2,i}!})2^{n-1-|T_1\cup T_2|}
\]</span> 其中<span class="math inline">\(n-1-|T_1\cup
T_2|\)</span>意味着均不在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中的位置的数量.为了给每一段连续的<span class="math inline">\(&gt;\)</span>都分配权值,我们进行一个细小的修改:
<span class="math display">\[
2^{-1-n}(n!)^2\sum_{T_1}((-2)^{|T_1|+1}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}((-2)^{|T_2|+1}\frac{1}{\prod
l_{2,i}!})2^{n-1-|T_1\cup T_2|}
\]</span> 写到这里应该就能发现,接下来必然要对<span class="math inline">\(n-1-|T_1\cup
T_2|\)</span>做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了<span class="math inline">\(&gt;\)</span>,我们自然有: <span class="math display">\[
2^{1+n}(n!)^2\sum_{T_1}(\frac{1}{(-2)^{|T_1|+1}}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}(\frac{1}{(-2)^{|T_2|+1}}\frac{1}{\prod
l_{2,i}!})2^{|T_1\cap T_2|}\\
\]</span> 这里已经很显然了,我们大概要做一个不断加段的做法,那此时<span class="math inline">\(|T_1\cap
T_2|\)</span>这个限制就显得尤其强,如果只是<span class="math inline">\(S\subseteq
T_1,T_2\)</span>就会好做很多:我们可以钦定<span class="math inline">\(S\)</span>作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:
<span class="math display">\[
2^{1+n}(n!)^2\sum_{T_1}(\frac{1}{(-2)^{|T_1|+1}}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}(\frac{1}{(-2)^{|T_2|+1}}\frac{1}{\prod
l_{2,i}!})2^{|T_1\cap T_2|}\\
=2^{1+n}(n!)^2\sum_{S}\sum_{S\subseteq
T_1}(\frac{1}{(-2)^{|T_1|+1}}\frac{1}{\prod l_{1,i}!})\sum_{S\subseteq
T_2}(\frac{1}{(-2)^{|T_2|+1}}\frac{1}{\prod l_{2,i}!})\\
\]</span> 令<span class="math inline">\(f(T)=\sum_{S\subseteq
T}(\frac{1}{(-2)^{|T|+1}}\frac{1}{\prod l_{2,i}!})\\\)</span>,则原式即:
<span class="math display">\[
2^{1+n}(n!)^2\sum_{S}(\sum_{S\subseteq T}f(T))^2
\]</span> 考虑下面这个东西怎么求: <span class="math display">\[
\sum_{S}(\sum_{S\subseteq T}f(T))^2
\]</span> 注意到,如果我们把每一段(<span class="math inline">\([T_i,T_{i+1})\)</span>)的贡献求和,那么<span class="math inline">\(f(T)\)</span>相当于这些和乘起来,那么<span class="math inline">\((\sum_{S\subseteq
T}f(T))^2\)</span>就是这些和的平方乘起来.换句话说,我们自然有<span class="math inline">\(ans_n=\sum_{m}ans_{n-m}g^2_{m}\)</span>,其中<span class="math inline">\(g_m\)</span>表示长度为<span class="math inline">\(m\)</span>的一段的贡献之和.而<span class="math inline">\(g_{n}=\sum_m
g_{n-m}\frac{1}{-2m!}\)</span>.二者都可以使用分治FFT或多项式求逆解决.更进一步地,<span class="math inline">\(h_i=\frac{1}{-2i!},G=\frac{1}{1-H},F=\frac{1}{1-G}\)</span>.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将<span class="math inline">\((&gt;,&gt;)\)</span>容斥掉,这样我们有若干种对:<span class="math inline">\(2(&lt;,&lt;),1(e,e),-(e,&lt;),-(&lt;,e)\)</span>,然后我们发现两个序列联系得太紧了,我们考虑分配系数:<span class="math inline">\(&lt;\rightarrow \sqrt 2\)</span>,<span class="math inline">\(e\rightarrow -\frac{1}{\sqrt
2}\)</span>,但是这样发现<span class="math inline">\((e,e)\)</span>算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h3><span id="复杂度抵消">复杂度抵消</span></h3>
<h5><span id="example1cf1439b">Example1(CF1439B)</span></h5>
<p>首先注意到度数小于<span class="math inline">\(k-1\)</span>的点一定没用,于是可以不断删点.删点后的图度数全部<span class="math inline">\(\geq k-1\)</span>.</p>
<p>首先如果剩下的点度数全都<span class="math inline">\(\geq
k\)</span>那就直接找到答案,不然,我们看一下度数为<span class="math inline">\(k-1\)</span>的点:它要么在团里,要么没用.不妨直接暴力判断是否在团里,复杂度<span class="math inline">\(O(k^2)\)</span>.</p>
<p>欸等一下,这总复杂度<span class="math inline">\(O(mk^2)\)</span>了啊,这咋办?</p>
<p>首先,删完点后的度数全都<span class="math inline">\(\geq
k-1\)</span>,注意到此时的点数是<span class="math inline">\(O(\frac{m}{k})\)</span>的.所以复杂度<span class="math inline">\(O(mk)\)</span>.</p>
<p>好像还是过不去,这咋办?</p>
<p>冷静一下,如果<span class="math inline">\(k\geq \sqrt
m\)</span>,显然不可能存在团.于是复杂度<span class="math inline">\(O(m\sqrt m)\)</span>.</p>
<h3><span id="寻找关系式">寻找关系式</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一张有向图,边有两种颜色,从<span class="math inline">\(s\)</span>开始随机游走,维护一个权值.经过第一种颜色的边,权值<span class="math inline">\(+1\)</span>.经过第二种颜色的边,权值归<span class="math inline">\(0\)</span>.保证<span class="math inline">\(t\)</span>没有出边,所有点均能到<span class="math inline">\(t\)</span>.询问到<span class="math inline">\(t\)</span>时权值的期望和方差.<span class="math inline">\(n\leq 100\)</span>.</p>
<p>(注意方差为平方的期望减去期望的平方.)</p>
<p>注意到难点在于权值归<span class="math inline">\(0\)</span>.所以一个点到<span class="math inline">\(t\)</span>的期望权值一定和到达它时的权值有关系.</p>
<p>然后就来到了降维打击的时间:我们可以使用数学归纳法证明,如果到一个点<span class="math inline">\(u\)</span>的权值是<span class="math inline">\(x\)</span>,那它到达<span class="math inline">\(t\)</span>的权值一定形如<span class="math inline">\(a_ux+b_u\)</span>.</p>
<p>如果要严谨一点的话,我们发现第一种颜色的边会影响常数项,第二种颜色的边会影响一次项,因此最后的答案一定是一次函数.</p>
<p>最后可以使用高斯消元直接求出每个点权值的<span class="math inline">\(a_u\)</span>和<span class="math inline">\(b_u\)</span>,就可以求出期望.</p>
<p>至于方差是同理的,你注意到平方的期望一定是一个二次函数.</p>
<h3><span id="特判边界">特判边界</span></h3>
<h5><span id="example12022icpc杭州e">Example1(2022ICPC杭州E)</span></h5>
<p>第一反应肯定是一点一点调整成<span class="math inline">\(\{1,2,...,n\}\)</span>的形式,写个暴力验证一下发现当<span class="math inline">\(n\geq 4\)</span>的时候的确都可以调整成功.</p>
<p>假设目前形如:<span class="math inline">\([1,k],A,k+1,B\)</span>.我们考虑如何调整:</p>
<ol type="1">
<li><span class="math inline">\(|B|\ne 0\)</span>.</li>
</ol>
<p>我们有: <span class="math display">\[
\{[1,k],A,k+1,B\}\rightarrow \{B,A,k+1,[1,k]\}\rightarrow
\{[1,k+1],B,A\}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(|B|=0,|A|=0\)</span>.</li>
</ol>
<p>直接合并就行.</p>
<ol start="3" type="1">
<li><span class="math inline">\(|B|=0,|A|\geq 2\)</span>.</li>
</ol>
<p>假设<span class="math inline">\(A=A_1A_2\)</span>,我们有: <span class="math display">\[
\{[1,k],A_1,A_2,k+1\}\rightarrow \{A_2,k+1,A_1,[1,k]\}\rightarrow
\{[1,k+1],A_1,A_2\}
\]</span></p>
<ol start="4" type="1">
<li><span class="math inline">\(|B|=0,|A|=1\)</span>.</li>
</ol>
<p>此时一定有<span class="math inline">\(k\geq
2\)</span>,发现有点难构造,但是我们猜测是可以构造出来的.不难证明这个问题等价于将<span class="math inline">\(\{1,2,4,3\}\)</span>调整为<span class="math inline">\(\{1,2,3,4\}\)</span>,写个暴力跑一下就行.</p>
<h3><span id="摩尔投票">摩尔投票</span></h3>
<h5><span id="example1cf643gchoosing-ads">Example1([CF643G]Choosing Ads)</span></h5>
<p>将摩尔投票扩展一下.我们现在想求其中出现次数大于等于<span class="math inline">\(\lfloor\frac{n}{p}\rfloor\)</span>的数字,令<span class="math inline">\(k=\lfloor\frac{100}{p}\rfloor\)</span>,我们考虑每次取出<span class="math inline">\(k+1\)</span>个两两不同的数字并且全部杀掉,那么做完这一步操作后,该满足条件的仍然满足条件(讨论一下),于是拿线段树维护当前的五个数的出现数量,每次对着杀就行.</p>
<h3><span id="寻找周期性">寻找周期性</span></h3>
<h5><span id="example1cf1463fmax-correctset">Example1([CF1463F]Max Correct
Set)</span></h5>
<p>自然的想法是<span class="math inline">\(O(n2^{\max(x,y)})\)</span>作dp.</p>
<p>接下来比较牛逼的是,注意到如果<span class="math inline">\(S_1\)</span>满足条件,令<span class="math inline">\(m=x+y\)</span>那么<span class="math inline">\(S_1\cup(S_1+m)\)</span>也满足条件.</p>
<p>我们考虑<span class="math inline">\(S_1\)</span>中满足条件意味着什么,意味着<span class="math inline">\(\forall a,b\in S_1,a&lt;b\)</span>,<span class="math inline">\(b-a\ne x\and b-a\ne y\)</span>,这意味着<span class="math inline">\(m+b-a\ne x\and m+b-a\ne
y\)</span>,这同样意味着<span class="math inline">\(m+a-b=x+y+a-b\ne
x+y-x\and m+a-b\ne x+y-y\)</span>.</p>
<p>因此,只要我们找到了一个长度为<span class="math inline">\(m\)</span>的可行解,我们一定可以将其不断扩展到全部集合.</p>
<p>进一步地,我们一定能证明:原集合中的最优解是以一个长度为<span class="math inline">\(m\)</span>的可行解作为周期的.</p>
<p>这个是为啥呢?我们设<span class="math inline">\(n=km+c\)</span>,那么我们直接求出一个长度为<span class="math inline">\(m\)</span>的解,满足前<span class="math inline">\(c\)</span>位对答案的贡献的权值是<span class="math inline">\(k+1\)</span>,后<span class="math inline">\(m-c\)</span>位贡献的权值为<span class="math inline">\(k\)</span>,然后直接求答案.注意到如果最大答案另有其人,我们一定可以拿其中的某一段不断循环得到更大的答案,这就不符合我们的假设了.</p>
<h3><span id="补集转化">补集转化</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的无向图,求给每一条边定向使得<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>能到达同一个点(可以是<span class="math inline">\(1\)</span>或<span class="math inline">\(2\)</span>)的方案数.<span class="math inline">\(n\leq 15,m\leq \frac{n(n-1)}{2}\)</span>.</p>
<p>考虑正难则反,算不存在的概率(事实上也确实很好理解,因为存在性问题通常都要取补集),这时候我们发现:此时<span class="math inline">\(1\)</span>能到达一个集合<span class="math inline">\(S\)</span>,<span class="math inline">\(2\)</span>能到达一个集合<span class="math inline">\(T\)</span>,<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>无交,并且两个集合之间不可能存在边,因此我们只需要算<span class="math inline">\(f(S)\)</span>表示<span class="math inline">\(1\)</span>能到达<span class="math inline">\(S\)</span>中的点的方案数即可,<span class="math inline">\(2\)</span>同理.</p>
<p>那么这个怎么算呢?我们仍然考虑正难则反,如果<span class="math inline">\(1\)</span>不能到达<span class="math inline">\(S\)</span>中的所有点,那么<span class="math inline">\(1\)</span>一定只能到达<span class="math inline">\(S\)</span>中的一部分点,枚举这一部分,假设是<span class="math inline">\(T\)</span>,就可以用<span class="math inline">\(f(T)\)</span>算<span class="math inline">\(f(S)\)</span>的答案.</p>
<h3><span id="二进制分组">二进制分组</span></h3>
<h5><span id="example1loj3273">Example1(loj3273)</span></h5>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点<span class="math inline">\((x,y)\)</span>,随着<span class="math inline">\(x\)</span>的增大<span class="math inline">\(y\)</span>不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.我们使用二进制分组,将所有点分为大小为<span class="math inline">\(0,1,2,4,\cdots
,2^k\)</span>大小的组,当然有些组可能没被分出来.然后如果有两个大小都是<span class="math inline">\(2^k\)</span>的组,我们暴力合并二者,得到一个还没被折线扫过的新的大小为<span class="math inline">\(2^{k+1}\)</span>的组.</p>
<h5><span id="example2luogu7447ynoi2007-rgxsxrs">Example2(Luogu7447
[Ynoi2007] rgxsxrs)</span></h5>
<p>一眼看上去和CF702F很像,但是区间操作感觉很艰难,怎么做呢?</p>
<p>我们对值域分块:分成<span class="math inline">\([0,1),[1,2),[2,4),[4,8),\cdots\)</span>,这样只会分成<span class="math inline">\(\log
V\)</span>段,每段内部维护平衡树来处理下标.那么对于一个<span class="math inline">\(x\)</span>,它会把后面的段全部打上一个<span class="math inline">\(tag\)</span>,有些位置要掉落到下面的段上,这个维护每个段的最小值就可以处理(最多只会掉落<span class="math inline">\(\log n\)</span>段),问题是和<span class="math inline">\(x\)</span>在同一块内的没有办法打tag,但这一部分一定会掉落到下面的段,一块处理.</p>
<p>好,下面开始思想总结:</p>
<p>首先,我们发现这个区间和值域都很难处理,但是感觉值域更加重要,应该是对值域做均摊(也就是类似CF702F的打tag操作和暴力修改操作分开),于是考虑到对值域分块然后内部平衡树,然后发现可以做了吧.不太清楚,也有可能只是值域分块的套路.</p>
<p>Luogu9069是同款思路,判一下负数.</p>
<h5><span id="example3cf1515i-phoenixand-diamonds">Example3(CF1515I Phoenix
and Diamonds)</span></h5>
<p>俗称带修T-shirt.</p>
<p>做法大概是这样的:我们考虑对于每次给出的<span class="math inline">\(c\)</span>,不妨假设它在<span class="math inline">\([2^k,2^{k+1})\)</span>这个块上,那么如果它减去了任何一个还在这个块里的数字,那就一定会掉落到下一个块中.这样就又有均摊了.</p>
<p>但是我们不一定能减去一个还在这个块里的数字,我们怎么做呢?</p>
<p>我们考虑最后的操作一定是减去若干个小于这个块的,最后有可能再减去一个这个块的,然后<span class="math inline">\(c\)</span>就掉到了下一个块,考虑先按照价值排序,然后维护<span class="math inline">\(f_i\)</span>表示排名在<span class="math inline">\(i\)</span>前面且代价在更小的块中的代价和,我们要找到最靠左的小于<span class="math inline">\(c-2^k\)</span>的<span class="math inline">\(f\)</span>,这个可以做线段树二分维护.</p>
<p>[IOI2021]地牢游戏 类似,但是因为是在图上做,所以把二分要改成倍增.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式与生成函数</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#高数基础补档">高数基础补档</a>
<ul>
<li><a href="#复数相关">复数相关</a>
<ul>
<li><a href="#分圆多项式">分圆多项式</a>
<ul>
<li><a href="#example尺规做正n边形问题">Example(尺规做正n边形问题)</a>
<ul>
<li><a href="#正五边形问题">正五边形问题</a></li>
<li><a href="#正七边形">正七边形</a></li>
<li><a href="#正n边形">正n边形</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#泰勒展开">泰勒展开</a></li>
</ul></li>
<li><a href="#多项式">多项式</a>
<ul>
<li><a href="#多项式基础">多项式基础</a>
<ul>
<li><a href="#点值表示法和系数表示法">点值表示法和系数表示法</a></li>
<li><a href="#拉格朗日插值">拉格朗日插值</a></li>
</ul></li>
<li><a href="#多项式运算">多项式运算</a>
<ul>
<li><a href="#多项式乘法">多项式乘法</a>
<ul>
<li><a href="#快速傅里叶变换fft">快速傅里叶变换(FFT)</a>
<ul>
<li><a href="#dft">DFT</a></li>
</ul></li>
<li><a href="#范德蒙德矩阵理解">范德蒙德矩阵理解</a></li>
</ul></li>
<li><a href="#分治fft">分治FFT</a></li>
<li><a href="#多项式除法">多项式除法</a></li>
<li><a href="#多项式ln">多项式ln</a></li>
<li><a href="#牛顿迭代">牛顿迭代</a></li>
<li><a href="#多项式开方">多项式开方</a></li>
<li><a href="#多项式exp">多项式exp</a></li>
<li><a href="#多项式快速幂">多项式快速幂</a></li>
<li><a href="#多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</a></li>
</ul></li>
<li><a href="#集合幂级数">集合幂级数</a>
<ul>
<li><a href="#与或卷积">与/或卷积</a></li>
<li><a href="#异或卷积">异或卷积</a></li>
<li><a href="#快速沃尔什变换">快速沃尔什变换</a>
<ul>
<li><a href="#线性代数角度">线性代数角度</a>
<ul>
<li><a href="#或卷积">或卷积</a></li>
<li><a href="#与卷积">与卷积</a></li>
<li><a href="#异或卷积-1">异或卷积</a></li>
</ul></li>
<li><a href="#生成函数角度">生成函数角度</a></li>
</ul></li>
<li><a href="#子集卷积">子集卷积</a></li>
<li><a href="#集合占位幂级数">集合占位幂级数</a></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example1agc034f-rng-and-xor">Example1([AGC034F] RNG and
XOR)</a></li>
<li><a href="#example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</a></li>
<li><a href="#example3cf1034e-little-c-loves-3-iii">Example3(CF1034E
Little C Loves 3 III)</a></li>
<li><a href="#example4cf1336e2-chiori-and-doll-picking">Example4(CF1336E2
Chiori and Doll Picking)</a></li>
<li><a href="#example5cf-1326f2">Example5(CF 1326F2)</a></li>
<li><a href="#example6qoj5019">Example6(qoj5019)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#生成函数">生成函数</a>
<ul>
<li><a href="#普通生成函数ogf">普通生成函数(OGF)</a>
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#运算">运算</a></li>
<li><a href="#常见序列生成函数">常见序列生成函数</a></li>
</ul></li>
<li><a href="#指数生成函数egf">指数生成函数(EGF)</a>
<ul>
<li><a href="#基本运算">基本运算</a></li>
<li><a href="#封闭式">封闭式</a></li>
<li><a href="#exp的组合意义">EXP的组合意义</a></li>
<li><a href="#example-1">Example</a>
<ul>
<li><a href="#example1poj3734">Example1(POJ3734)</a></li>
<li><a href="#example2圆排列">Example2(圆排列)</a></li>
<li><a href="#example3错排数">Example3(错排数)</a></li>
<li><a href="#example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</a></li>
<li><a href="#example5不动点计数">Example5(不动点计数)</a></li>
<li><a href="#example6cf891elust">Example6([CF891E]Lust)</a></li>
<li><a href="#example7">Example7</a></li>
</ul></li>
</ul></li>
<li><a href="#狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</a>
<ul>
<li><a href="#基本运算-1">基本运算</a></li>
<li><a href="#封闭式-1">封闭式</a></li>
<li><a href="#example-2">Example</a>
<ul>
<li><a href="#example1luogup3768">Example1(luoguP3768)</a></li>
</ul></li>
</ul></li>
<li><a href="#阶乘的扩展定义">阶乘的扩展定义</a></li>
<li><a href="#超几何级数">超几何级数</a>
<ul>
<li><a href="#超几何函数">超几何函数</a></li>
<li><a href="#特殊的超几何函数">特殊的超几何函数</a>
<ul>
<li><a href="#合流超几何函数">合流超几何函数</a></li>
<li><a href="#高斯超几何函数">高斯超几何函数</a></li>
</ul></li>
<li><a href="#超几何级数的应用">超几何级数的应用</a>
<ul>
<li><a href="#example-3">Example</a></li>
<li><a href="#二项式系数与超几何函数">二项式系数与超几何函数</a></li>
</ul></li>
</ul></li>
<li><a href="#求微分方程">求微分方程</a>
<ul>
<li><a href="#example1luogu4931">Example1(luogu4931)</a></li>
<li><a href="#求解递归关系">求解递归关系</a></li>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2qoj5169-夹娃娃">Example2([QOJ5169]
夹娃娃)</a></li>
<li><a href="#example3十二省联考-2019-皮配">Example3([十二省联考 2019]
皮配)</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2>
<h3><span id="复数相关">复数相关</span></h3>
<p>棣莫弗定理:<span class="math inline">\((cos\theta+i\sin\theta)^n=\cos(n\theta)+i\sin(n\theta)\)</span>.</p>
<p>欧拉公式:<span class="math inline">\(e^{i\pi}=-1\)</span>.</p>
<p>也就是<span class="math inline">\(e^{2i\pi}=1\)</span>,同时又有<span class="math inline">\(e^{i\theta}=cos\theta+i·sin\theta\)</span>,证明直接使用泰勒展开.</p>
<p>单位根:对于<span class="math inline">\(x^n=1\)</span>,我们会有<span class="math inline">\(n\)</span>个根,设第<span class="math inline">\(k\)</span>个根为<span class="math inline">\(\omega_n^k\)</span>.那么我们有:<span class="math inline">\(\omega_n^k=e^{2\pi\frac k ni}=cos(2\pi\frac
kn)+i·sin(2\pi\frac kn)\)</span>.</p>
<p>单位根有以下性质:</p>
<ol type="1">
<li>折半引理:<span class="math inline">\(\omega_{2n}^{2k}=\omega_n^k\\\)</span>,由我们上面推导的通项公式即可证明.</li>
<li>消去引理:<span class="math inline">\(\omega_n^{k+\frac n
2}=-\omega_n^k\\\)</span>,同样使用通项，运用三角恒等变换可证明.</li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4>
<p>上复平面,设<span class="math inline">\(S_k=(\cos\frac{2k\pi}{n},\sin\frac{2k\pi}{n})\)</span>,也就是<span class="math inline">\(z_k=\cos\frac{2k\pi}{n}+i\sin\frac{2k\pi}{n}\)</span>是方程<span class="math inline">\(z^n-1=0\)</span>的复根.我们把这个方程写开: <span class="math display">\[
z^n-1=(z-1)(z^{n-1}+z^{n-2}+\cdots+1)=0
\]</span> 不难发现<span class="math inline">\(z=1\)</span>是平凡解.</p>
<p>我们不妨定义<span class="math inline">\(f(x)=\prod_{k=1}^n(1+X^k)=\sum_{k\geq
0}a_kX^k\)</span>,事实上我们有: <span class="math display">\[
\frac{1}{n}\sum_{j=1}^nf(\omega_n^j)=\frac{1}{n}\sum_{j=1}^n\sum_{k\geq
0}a_k\omega^{kj}_n\\
=\frac{1}{n}\sum_{k\geq 0}a_k\sum_{j=1}^n\omega_{n}^{kj}\\
=\sum_{j\geq 0}a_{jn}+\frac{1}{n}\sum_{k\geq 0,n\nmid
k}a_k\frac{1-\omega^{nj}_n}{1-\omega^{k}_n}\omega_{n}^j\\
=\sum_{j\geq 0}a_{jn}
\]</span> 事实上,我们令<span class="math inline">\(d=\frac{n}{\gcd(j,n)}\)</span>,容易发现<span class="math inline">\(f(\omega_n^j)=(\prod_{k=1}^d(1+\omega_n^{kj}))^{\frac{n}{d}}\)</span>,又容易发现<span class="math inline">\(n|jd\)</span>.</p>
<p>接下来观察<span class="math inline">\(X^d-1=\prod_{k=1}^d(X-\omega_{n}^{kj})\)</span>,带入<span class="math inline">\(X=-1\)</span>得到<span class="math inline">\(f(\omega_n^j)=\begin{cases}2^{\frac{n}{d}}&amp;d\in
\text{odd}\\0&amp;d\in\text{even}\end{cases}\)</span>.</p>
<p>接下来考虑拿到<span class="math inline">\(\sum_{j}a_{jn}\)</span>,只需求<span class="math inline">\(\frac{1}{n}\sum_{j=1}^nf(\omega_n^j)=\frac{1}{n}\sum
_{d\in
\text{odd},\gcd(j,n)=\frac{n}{d}}2^{\frac{n}{d}}=\frac{1}{n}\sum_{d\in\text{odd}}\varphi(d)2^{\frac{n}{d}}\)</span>.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5>
<p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现<span class="math inline">\(+,-,\times,\div,\sqrt[2]{}\)</span>五种操作.而对于正<span class="math inline">\(n\)</span>边形,显然只要我们能将<span class="math inline">\(\cos\frac{2\pi}{n}\)</span>用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6>
<p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令: <span class="math display">\[
\sigma_1=z_1+z_4\\
\sigma_2=z_2+z_3
\]</span> 不难验证: <span class="math display">\[
\sigma_1+\sigma_2=-1\\
\sigma_1\sigma_2=-1
\]</span> 可以求出复合条件的解,将<span class="math inline">\(z\)</span>带入又有: <span class="math display">\[
\sigma_1=2\cos\frac{2\pi}{5}\\
\sigma_2=2\cos\frac{4\pi}{5}
\]</span> 于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6>
<p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6>
<p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设<span class="math inline">\(n\in prime\)</span>,我们用<span class="math inline">\(p\)</span>代替<span class="math inline">\(n\)</span>.</p>
<p>我们有<span class="math inline">\(z_1=\cos\frac{2\pi}{p}+i\sin\frac{2\pi}{p}\)</span>,由于其它的<span class="math inline">\(z\)</span>都可以表示成它的幂,因此我们记<span class="math inline">\(\varepsilon =z_1\)</span>.</p>
<p>我们现在想要这么分组: <span class="math display">\[
\sigma_{k+1}=\sum_{1\leq l\leq p-1,f(l,k)=1}\varepsilon^l
\]</span></p>
<h3><span id="泰勒展开">泰勒展开</span></h3>
<p>即<span class="math inline">\(f(x)=g(x)=f(x_0)+\sum_{k\geq
1}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k\\\)</span>.<span class="math inline">\(x_0=0\)</span>的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2>
<h3><span id="多项式基础">多项式基础</span></h3>
<h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4>
<p>代数基本定理:一个<span class="math inline">\(n-1\)</span>次方程在复数域上有且只有<span class="math inline">\(n-1\)</span>个根.</p>
<p>定理:一个<span class="math inline">\(n-1\)</span>次多项式在<span class="math inline">\(n\)</span>个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个<span class="math inline">\(n-1\)</span>次多项式<span class="math inline">\(A(x)\)</span>和<span class="math inline">\(B(x)\)</span>且有<span class="math inline">\(\forall i\in[0,n-1],A(x_i)=B(x_i)\\\)</span>.</p>
<p>令<span class="math inline">\(C(x)=A(x)-B(x)\)</span>,那么<span class="math inline">\(C(x)\)</span>至多是一个<span class="math inline">\(n-1\)</span>次多项式且<span class="math inline">\(\forall
i\in[0,n-1],C(x_i)=0\\\)</span>,也就是<span class="math inline">\(C(x)\)</span>有<span class="math inline">\(n\)</span>个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:<span class="math inline">\(A(x)=\sum_{i=0}^{n-1}a_ix^i\\\)</span>.</p>
<p>点值表示法:<span class="math inline">\(y_i=\sum_{j=0}^{n-1}a_jx_i^j\\\)</span>.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式<span class="math inline">\(\sum_{i=0}^{n-1}y_i(\prod_{j=0\and j\ne
i}^{n-1}\frac {x-x_j}{x_i-x_j})\\\)</span>.显然当<span class="math inline">\(x=x_i\)</span>时,该多项式的答案为<span class="math inline">\(y_i\)</span>.</p>
<p>另外,如果<span class="math inline">\(x_i=i\)</span>,不难发现这个式子可以写成: <span class="math display">\[
\sum_{i=1}^{n}y_i(\prod_{j=1\and j\ne i}^{n}\frac {x-x_j}{x_i-x_j})\\\\
=\sum_{i=1}^ny_i(\prod_{j=1\and j\ne i}^n\cfrac{x-j}{i-j})\\
=\sum_{i=1}^ny_i(-1)^{n-i}(\cfrac{1}{(i-1)!(n-i)!}\prod_{j=1,j\ne
i}^{n}(x-j))
\]</span></p>
<h3><span id="多项式运算">多项式运算</span></h3>
<p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4>
<h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5>
<h6><span id="dft">DFT</span></h6>
<p>将<span class="math inline">\(n\)</span>次单位根(默认<span class="math inline">\(n\)</span>是二的整次幂,如果少了的话补零,设<span class="math inline">\(n=2^w\)</span>)分别带入<span class="math inline">\(A(x)\)</span>得到点值向量<span class="math inline">\(A(\omega_n^k)\\\)</span>.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑: <span class="math display">\[
A(x)=\sum_{i=0}^{n-1}a_ix^i\\=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^i+\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^i\\
=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{2k}+x\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{2k}\\
\]</span> 令<span class="math inline">\(A_1(x)=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{k},
A_2(x)=\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{k}\\\)</span>,那么<span class="math inline">\(A(x)=A_1(x^2)+xA_2(x^2)\\\)</span>.</p>
<p>接下来分类讨论:</p>
<p><span class="math inline">\(\forall 0\leq k\leq \frac n
2-1,k\in\mathbb{N}\\\)</span>,我们有: <span class="math display">\[
A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})\\
\]</span> 根据折半引理: <span class="math display">\[
A(\omega_n^k)=A_1(\omega_{\frac n 2}^k)+\omega_n^kA_2(\omega^k_{\frac n
2})\\
\]</span> 这样我们处理完了前半部分.</p>
<p><span class="math inline">\(\forall \frac n 2\leq k+\frac n 2\leq
n-1,k\in\mathbb{N}\\\)</span>,我们有: <span class="math display">\[
A(\omega_n^{k+\frac n 2})=A_1(\omega_n^{2k+n})+\omega_n^{k+\frac n
2}A_2(\omega_n^{2k+n})\\
\]</span> 根据消去引理: <span class="math display">\[
A(\omega_n^{k+\frac n 2})=A_1(\omega_{\frac n
2}^k)-\omega_n^kA_2(\omega_{\frac n 2}^k)\\
\]</span> 综上,我们可以递归处理<span class="math inline">\(A_1\)</span>和<span class="math inline">\(A_2\)</span>,然后合并得到<span class="math inline">\(A\)</span>的答案,可以分治.</p>
<p>######IDFT</p>
<p>设<span class="math inline">\(A(\omega_n^k)=d_k\\\)</span>,构造多项式<span class="math inline">\(F(x)=\sum_{i=0}^{n-1}d_ix^i\\\)</span>.</p>
<p>我们求出<span class="math inline">\(F(x)\)</span>的点值表示,设<span class="math inline">\(c_k=F(\omega_n^{-k})\\\)</span>,也即: <span class="math display">\[
c_k=\sum_{i=0}^{n-1}d_i(\omega_n^{-k})^i\\=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i\\
=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}\\
\]</span> 当<span class="math inline">\(j=k\)</span>时,显然<span class="math inline">\(\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n\\\)</span>.</p>
<p>否则根据等比数列求和公式,<span class="math inline">\(\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=\frac{\omega^0_n[(\omega_n^{j-k})^n-1]}{\omega_n^{j-k}-1}=0\\\)</span>.</p>
<p>所以<span class="math inline">\(\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n[j=k]\\\)</span>.</p>
<p>那么我们有<span class="math inline">\(c_k=na_k,
a_k=\frac{c_k}{n}\\\)</span>.</p>
<p>######写法</p>
<p>递归写法显然.</p>
<p>递归过程中,第<span class="math inline">\(k\)</span>层相当于在根据数在第<span class="math inline">\(k\)</span>位的二进制数是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">			ll w=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">				ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">				ll ak=a[i+k];</span><br><span class="line">				a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">				a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">		ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">			a[i]=a[i]*inv%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####快速数论变换(NTT)</p>
<p>由于FFT中的单位根会产生精度误差,因此在膜<span class="math inline">\(998244353\)</span>意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为<span class="math inline">\(g\)</span>,<span class="math inline">\(g_n=g^{\frac
{p-1}n}\\\)</span>,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol type="1">
<li><span class="math inline">\(g_n^n=g_n^0=1\)</span>且<span class="math inline">\(\forall 0\leq i&lt;j&lt;n,g_n^i\ne
g_n^j\)</span>,证明由原根的性质.</li>
<li>折半引理:<span class="math inline">\(g_{2n}^{2k}=g_{n}^k\)</span>,证明显然.</li>
<li>消去引理:<span class="math inline">\(g_{n}^{k+\frac n
2}=-g^k_n\\\)</span>.由于<span class="math inline">\(g^{\frac
{p-1}2}=-1\)</span>,该结论显然成立.</li>
</ol>
<p>由上我们证明了,我们完全可以使用<span class="math inline">\(g_n\)</span>代替<span class="math inline">\(\omega_n\)</span>进行变换.</p>
<p>另外,注意到<span class="math inline">\(998244352=2^{23}\times 7\times
17\\\)</span>,而<span class="math inline">\(2^{23}\approx 8\times
10^6\\\)</span>.因而,当<span class="math inline">\(n\leq 8\times
10^6\)</span>的时候,<span class="math inline">\(g_n\)</span>可以直接求出.这也是为什么大部分NTT题目都使用<span class="math inline">\(998244353\)</span>作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5>
<p>范德蒙德矩阵形如: <span class="math display">\[
\begin{bmatrix}1&amp;\alpha_1&amp;\cdots&amp;\alpha_1^{n-1}\\1&amp;\alpha_2&amp;\cdots&amp;\alpha_2^{n-1}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;\alpha_m&amp;\cdots&amp;\alpha_m^{n-1}\end{bmatrix}\in\mathbb{R}^{m\times
n}
\]</span> 如果取单位根,我们有: <span class="math display">\[
\begin{bmatrix}1&amp;1&amp;\cdots&amp;1\\1&amp;\omega_n^1&amp;\cdots&amp;\omega_2^{n-1}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;\omega_n^{n-1}&amp;\cdots&amp;\omega_n^{(n-1)^2}\end{bmatrix}\in\mathbb{R}^{n\times
n}
\]</span> 这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:
<span class="math display">\[
\begin{bmatrix}1&amp;1&amp;\cdots&amp;1\\1&amp;\omega_n^1&amp;\cdots&amp;\omega_2^{n-1}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;\omega_n^{n-1}&amp;\cdots&amp;\omega_n^{(n-1)^2}\end{bmatrix}^{-1}=\frac{1}{n}\begin{bmatrix}1&amp;1&amp;\cdots&amp;1\\1&amp;\omega_n^{-1}&amp;\cdots&amp;\omega_2^{-(n-1)}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;\omega_n^{-(n-1)}&amp;\cdots&amp;\omega_n^{-(n-1)^2}\end{bmatrix}
\]</span></p>
<h4><span id="分治fft">分治FFT</span></h4>
<p>给定<span class="math inline">\(g(x)\)</span>和<span class="math inline">\(f(0)\)</span>,求<span class="math inline">\(f(x)=\sum_{y=1}^xf(x-y)g(y)\)</span>,答案对<span class="math inline">\(998244353\)</span>取膜.</p>
<p>考虑分治,假如我们已经知道了<span class="math inline">\(f(x),x\in[1,\frac n
2]\)</span>.那我们可以计算出这段部分对<span class="math inline">\(f(y)，y\in[\frac n 2+1,n]\)</span>的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>的乘积并贡献上去.</p>
<p>####多项式求逆</p>
<p>对于多项式<span class="math inline">\(P(x)\)</span>,找到<span class="math inline">\(Q(x)\)</span>使得<span class="math inline">\(Q(x)P(x)\equiv 1\pmod {x^{n}}\\\)</span>.显然<span class="math inline">\(Q(x)\)</span>是唯一的.</p>
<p>首先不妨设<span class="math inline">\(n=2^k\\\)</span>.</p>
<p>如果我们已知<span class="math inline">\(P(x)Q_{k-1}(x)\equiv 1\pmod
{x^{2^{k-1}}}\\\)</span>,同时肯定有<span class="math inline">\(P(x)Q_{k}(x)\equiv 1\pmod
{x^{2^{k-1}}}\\\)</span>,相减得到<span class="math inline">\(Q_k(x)-Q_{k-1}(x)\equiv 0\pmod
{x^{2^{k-1}}}\\\)</span>.</p>
<p>两边平方: <span class="math display">\[
Q_k^2(x)+Q^2_{k-1}(x)-2Q_k(x)Q_{k-1}(x)\equiv 0\pmod {x^{2^k}}\\
\]</span> 两边乘一下<span class="math inline">\(P(x)\)</span>: <span class="math display">\[
Q_k(x)-2Q_{k-1}(x)+P(x)Q_{k-1}^2(x)\equiv 0\pmod {x^n}\\
Q_k(x)\equiv 2Q_{k-1}(x)-P(x)Q_{k-1}^2(x)\pmod {x^n}\\
\]</span> 根据主定理，这么做复杂度是<span class="math inline">\(O(n\log_2n)\)</span>的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:
<span class="math display">\[
F(x)\equiv F(x)G(x)+f_0\pmod {x^{n+1}}\\
F(x)=\frac{f(0)}{1-G(x)}\pmod {x^{n+1}}
\]</span> 于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4>
<p>对于<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(F(x)\)</span>和<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(G(x)\)</span>,找到<span class="math inline">\(Q(x),R(x)\)</span>使得<span class="math inline">\(F(x)=G(x)Q(x)+R(x)\\\)</span>.</p>
<p>考虑对于<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(F(x)\)</span>,令<span class="math inline">\(F_R(x)=x^n F(\cfrac{1}{x})\)</span>,如果设<span class="math inline">\(f_i\)</span>为其<span class="math inline">\(x^i\)</span>项前的系数,不难发现<span class="math inline">\(f_R(i)=f(n-i)\)</span>.</p>
<p>那么我们有: <span class="math display">\[
F(x)=G(x)Q(x)+R(x)\\
F(\cfrac{1}{x})=G(\cfrac{1}{x})Q(\cfrac{1}{x})+R(\cfrac{1}x)\\
x^nF(\cfrac{1}{x})=x^mG(\cfrac{1}{x})x^{n-m}Q(\cfrac{1}{x})+x^{n-m+1}x^{m-1}R(\cfrac{1}{x})\\
F_R(x)=G_R(x)Q_R(x)+x^{n-m+1}R_R(x)\\
F_R(x)\equiv G_R(x)Q_R(x)\pmod {x^{n-m+1}}\\
Q_R(x)\equiv F_R(x)G_R^{-1}(x)\pmod {x^{n-m+1}}
\]</span> 于是只要做一遍多项式求逆即可求得<span class="math inline">\(Q(x)\)</span>,再做一遍相减既可以得到<span class="math inline">\(R(x)\)</span>.</p>
<h4><span id="多项式ln">多项式ln</span></h4>
<p>给出<span class="math inline">\(n-1\)</span>次多项式<span class="math inline">\(A(x)\)</span>,求一个多项式<span class="math inline">\(B(x)\)</span>,满足<span class="math inline">\(B(x)\equiv \ln A(x)\)</span>.</p>
<p>我们有: <span class="math display">\[
B(x)\equiv \ln A(x)\pmod {x^n}\\
B&#39;(x)\equiv \cfrac{A&#39;(x)}{A(x)}\pmod {nx^{n-1}}\\
B(x)\equiv \int \cfrac{A&#39;(x)}{A(x)}dx\pmod {x^n}\\
\]</span></p>
<p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当<span class="math inline">\([x^0]f(x)=1\)</span>的时候,<span class="math inline">\(f(x)\)</span>有对数多项式.</p>
<p>我们对最后再做一步: <span class="math display">\[
B(x)\equiv \int_0^x \cfrac{A&#39;(t)}{A(t)}dt+B(0)\pmod {x^n}\\
\]</span> 首先<span class="math inline">\(B(0)=\ln A(0)=\ln
a_0\)</span>,如果<span class="math inline">\(a_0\in\mathbb{Q}\and a_0\ne
1\)</span>,则<span class="math inline">\(B(0)\notin
\mathbb{Q}\)</span>,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若<span class="math inline">\([x^0]f(x)=1\)</span>的时候,<span class="math inline">\(B(0)=0\)</span>,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>给定多项式<span class="math inline">\(G(x)\)</span>,求一个多项式<span class="math inline">\(F(x)\)</span>满足<span class="math inline">\(G(F(x))\equiv 0\pmod {x^n}\)</span>.</p>
<p>首先<span class="math inline">\(n=1\)</span>的时候,也就是求<span class="math inline">\(G(F(x))\equiv 0\pmod
x\)</span>.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在<span class="math inline">\(\bmod
x^{\lceil\frac{n}{2}\rceil}\)</span>意义下的答案<span class="math inline">\(F_0(x)\)</span>,我们考虑在<span class="math inline">\(F_0(x)\)</span>处做泰勒展开: <span class="math display">\[
G(F(x))=\sum_{k=0}^{+\infty}\frac{G^{(k)}(F_0(x))}{k!}(F(x)-F_0(x))^k\equiv
0\pmod{x^n}\\
\]</span> 考虑<span class="math inline">\(F(x)-F_0(x)\)</span>,由于<span class="math inline">\(F_0(x)\equiv
F(x)\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>,因此,因此<span class="math inline">\((F(x)-F_0(x))^2\equiv 0\pmod{x^n}\)</span>.</p>
<p>于是我们有: <span class="math display">\[
\sum_{k=0}^{+\infty}\frac{G^{(k)}(F_0(x))}{k!}(F(x)-F_0(x))^k\equiv
0\pmod{x^n}\\
G(F_0(x))+G&#39;(F_0(x))(F(x)-F_0(x))\equiv 0\pmod{x^n}\\
F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G&#39;(F_0(x))}\pmod{x^n}
\]</span> 牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4>
<p>给定<span class="math inline">\(h(x)\)</span>,设<span class="math inline">\(g(f(x))=f^2(x)-h(x)\)</span>,求零点.</p>
<p>根据牛顿迭代,有: <span class="math display">\[
f(x)\equiv f_0(x)-\frac{f^2(x)-h(x)}{2f_0(x)}\equiv
\frac{f^2(x)+h(x)}{2f_0(x)}\pmod{x^n}
\]</span> 还没完,用牛顿迭代前一定要求<span class="math inline">\(g(a)\equiv 0\pmod {x^n}\)</span>的解,也就是<span class="math inline">\([x^0]h(x)\)</span>的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4>
<p>给定<span class="math inline">\(h(x)\)</span>,设<span class="math inline">\(g(f(x))=\ln f(x)-h(x)\)</span>,求零点.</p>
<p>根据牛顿迭代,有: <span class="math display">\[
f(x)\equiv f_0(x)-\frac{\ln f_0(x)-h(x)}{\frac{1}{f_0(x)}}\pmod{x^n}\\
\equiv f_0(x)(1-\ln f_0(x)+h(x))\pmod{x^n}
\]</span> 还没完,还需要求<span class="math inline">\(g(a)\equiv 0\pmod
{x^n}\)</span>的解,注意到存在<span class="math inline">\(\exp\)</span>当且仅当<span class="math inline">\([x^0]g(x)\equiv 0\)</span>,此时<span class="math inline">\(f(x)\equiv 1\pmod{x}\)</span>.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4>
<p>求<span class="math inline">\(\ln\)</span>后求<span class="math inline">\(\exp\)</span>即可,唯一的问题是为什么指数可以对<span class="math inline">\(p\)</span>取膜.</p>
<p>我们有一个结论: <span class="math display">\[
f(x^p)\equiv f(x)^p\pmod p
\]</span> 这个结论很简单,注意到<span class="math inline">\((a+b)^p\equiv
a^p+b^p\pmod p\)</span>即可.</p>
<p>而又由于<span class="math inline">\(n&lt;p\)</span>,因此<span class="math inline">\(f(x)^p\equiv f(0)\pmod p\)</span>,通常取<span class="math inline">\(f(0)=1\)</span>,于是就可以直接对<span class="math inline">\(p\)</span>取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4>
<p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做<span class="math inline">\(\exp\)</span>的时候的直接数组传参,会导致<span class="math inline">\(\exp\)</span>的复杂度退化到<span class="math inline">\(O(n\log^2n)\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">	ll x[qwq];</span><br><span class="line">	<span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">			ll w=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">				ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">				ll ak=(a-&gt;x[i+k]);</span><br><span class="line">				a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">				a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">		ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">			a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">	x.k=k;</span><br><span class="line">	x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">	x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">	x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">	x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">	x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">		y.x[i]=x*y.x[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">	x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">	y.limit=x.limit;y.k=x.k;</span><br><span class="line">	<span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">		q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">			tmp_inv.x[i]=x.x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">		tmp_inv.k=q_inv.k=k;</span><br><span class="line">		q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">	&#125;</span><br><span class="line">	q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line">	<span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line">	<span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">	x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x.limit=lim,x.k=k;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">		x.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">		x.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">		q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">		tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">		tmp_exp.k=q_exp.k=k;</span><br><span class="line">		q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> q_exp;</span><br><span class="line">&#125; </span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">	q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">		tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">		tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">		q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">	x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3>
<p>集合幂级数形如<span class="math inline">\(\sum_{i=0}^{2^n-1}a_ix^i\)</span>,其中二进制数<span class="math inline">\(i\)</span>表示<span class="math inline">\(\{1,2,...,n\}\)</span>的一个子集,用<span class="math inline">\(|i|\)</span>表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4>
<p>高维前缀和:<span class="math inline">\(c_i=\sum_{j\subseteq
i}a_j\\\)</span>.</p>
<p>高维后缀和:<span class="math inline">\(c_i=\sum_{j\supseteq
i}a_j\\\)</span>.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:<span class="math inline">\(c_i=\sum_{j}\sum_{k}[j \or
k=i]a_jb_k\\\)</span>.</p>
<p>与卷积:<span class="math inline">\(c_i=\sum_{j}\sum_{k}[j\and
k=i]a_jb_k\\\)</span>.</p>
<p>二者求法类似,考虑如何求<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的或卷积:</p>
<p>引理:</p>
<p>若<span class="math inline">\(j,k\subseteq i\)</span>,则<span class="math inline">\(j\or k\subseteq i\)</span>,逆命题同样成立.</p>
<p>若<span class="math inline">\(j,k\supseteq i\)</span>,则<span class="math inline">\(j\and k\supseteq i\)</span>,逆命题同样成立.</p>
<p>设<span class="math inline">\(a,b,c\)</span>的高维前缀和分别为<span class="math inline">\(A,B,C\)</span>,我们有: <span class="math display">\[
A_iB_i=(\sum_{j\subseteq i}a_j)(\sum_{k\subseteq
i}b_k)\\=\sum_{j,k\subseteq i}a_ib_k\\=\sum_{k\or j\subseteq
i}a_ib_k\\=C_i\\
\]</span> 现在考虑已知<span class="math inline">\(C\)</span>求<span class="math inline">\(c\)</span>,本质上是一个反演.注意到<span class="math inline">\(\sum_{r\subseteq
p}(-1)^{|r|}=\sum_{k=0}^{|p|}C_{|p|}^k(-1)^k=[p=0]\\\)</span>,我们有:
<span class="math display">\[
c(p)=\sum_{q\subseteq p}[p-q=0]c(q)\\=\sum_{q\subseteq
p}\sum_{r\subseteq (p-q)}(-1)^{|r|}c(q)\\
=\sum_{r\subseteq p}(-1)^{|r|}\sum_{q\subseteq
(p-r)}c(q)\\=\sum_{r\subseteq p}(-1)^{r}C(p-r)\\=\sum_{r\subseteq
p}(-1)^{|p|-|r|}C(r)\\
\]</span> 于是有<span class="math inline">\(c(S)=\sum_{T\subseteq
S}(-1)^{|S|-|T|}C(T)\\\)</span>(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度<span class="math inline">\(O(2^nn)\)</span>.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4>
<p>异或卷积:<span class="math inline">\(c_i=\sum_j\sum_k[j\oplus
k=i]a_jb_k\\\)</span>.</p>
<p>引理:<span class="math inline">\((i\oplus j)\and k=(i\and k)\oplus
(j\and k)\)</span>.</p>
<p>证明的话考虑如果<span class="math inline">\(k=0\)</span>,二者显然相等;当<span class="math inline">\(k=1\)</span>的时候,左右都等价于<span class="math inline">\((i\oplus j)\)</span>.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数<span class="math inline">\(FWT(a)\)</span>,满足<span class="math inline">\(FWT(a)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and
j|}a_j\\\)</span>.</p>
<p>那么有: <span class="math display">\[
FWT(c)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and
j|}c_j\\=\sum_{j=0}^{2^n-1}(-1)^{|i\and
j|}\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}[k\oplus l=j]a_kb_l\\
=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|(k\oplus l)\and
i|}a_kb_l\\=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|k\and
i|}a_k(-1)^{|l\and i|}b_l\\
=FWT(a)_iFWT(b)_i\\
\]</span> 时间复杂度<span class="math inline">\(O(2^nn)\)</span>.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的<span class="math inline">\(\frac{1}2\)</span>都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">				a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">				a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">		ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4>
<h5><span id="线性代数角度">线性代数角度</span></h5>
<p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换<span class="math inline">\(FWT\)</span>,使得</p>
<ol type="1">
<li>若<span class="math inline">\(c_i=\sum_{j\oplus
k}a_jb_k\)</span>,则<span class="math inline">\(FWT(c)=FWT(a)FWT(b)\)</span>.</li>
<li>这个线性变换是可逆的.</li>
<li>做这个线性变换和其逆变换的复杂度都可以接受.</li>
</ol>
<p>我们设<span class="math inline">\(FWT(A)_i=\sum_{j}w(i,j)A_j\)</span>,我们想要做的就是构造一组满足上述条件的<span class="math inline">\(w\)</span>.</p>
<p>考虑: <span class="math display">\[
FWT(C)_i=FWT(A)_iFWT(B)_i\\
\sum_{j}w(i,j)C_j=\sum_{j,k}w(i,j)w(i,k)A_jB_k
\]</span> 再考虑: <span class="math display">\[
C=A*B\\
C_i=\sum_{k\oplus l=i}A_kB_l\\
\sum_{j}w(i,j)C_j=\sum_jw(i,j)\sum_{k\oplus l=j}A_kB_l\\
\sum_{j,k}w(i,j)w(i,k)A_jB_k=\sum_jw(i,j)\sum_{k\oplus l=j}A_kB_l\\
\sum_{j,k}w(i,j)w(i,k)A_jB_k=\sum_{j,k}A_jB_kw(i,j\oplus k)
\]</span> 比较两边系数,有<span class="math inline">\(w(i,j)w(i,k)=w(i,j\oplus
k)\)</span>.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于<span class="math inline">\(\oplus\)</span>是集合的运算,我们可以对二进制分开考虑.换句话说,如果<span class="math inline">\(a=\sum_{i=0}a_i2^i,b=\sum_{i=0}b_i2^i\)</span>,那么<span class="math inline">\(w(a,b)=\prod_{i=0}w(a_i,b_i)\)</span>一定是满足条件的.</p>
<p>这样我们就可以只求一个<span class="math inline">\(2\times
2\)</span>的线性变换矩阵就好.我们接下来将对三种常见的基础位运算(<span class="math inline">\(\or,\and,xor(\oplus)\)</span>)分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出<span class="math inline">\(FWT(a)\)</span>呢?</p>
<p>考虑和FFT一样折半,令<span class="math inline">\(i_0\)</span>为<span class="math inline">\(i\)</span>的最高位是否是<span class="math inline">\(1\)</span>,<span class="math inline">\(i&#39;\)</span>为<span class="math inline">\(i\)</span>去掉最高位后的二进制数字,令<span class="math inline">\(n=2^m\)</span>我们有: <span class="math display">\[
FWT(A)_i=\sum_{j=0}^{2^m-1}w(i,j)A_j\\
=\sum_{j=0}^{2^{m-1}-1}w(i,j)A_j+\sum_{j=2^{m-1}}^{2^m-1}w(i,j)A_j\\
=w(i_0,0)\sum_{j=0}^{2^{m-1}-1}w(i&#39;,j&#39;)A_j+w(i_0,1)\sum_{j=2^{m-1}}^{2^m-1}w(i&#39;,j&#39;)A_j
\]</span> 这样就实现了规模减半,复杂度<span class="math inline">\(O(mn)\)</span>.</p>
<p>下面我们设FWT的变换矩阵为<span class="math inline">\(\begin{bmatrix}w(0,0)&amp;w(0,1)\\w(1,0)&amp;w(1,1)\end{bmatrix}\)</span>.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}1&amp;0\\-1&amp;1\end{bmatrix}\)</span>.</p>
<h6><span id="与卷积">与卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}1&amp;-1\\0&amp;1\end{bmatrix}\)</span>.</p>
<h6><span id="异或卷积">异或卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}\frac{1}2&amp;\frac12\\\frac12&amp;-\frac12\end{bmatrix}\)</span>.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5>
<p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:<span class="math inline">\(x^Sx^T=x^{S\oplus
T}\)</span>,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子: <span class="math display">\[
FWT(A)_S=\sum_{T=0}^{2^n-1}(-1)^{|S\and T|}a_T\\
IFWT(A)_S=\frac{1}{2^n}FWT(A)_S
\]</span> 这等价于: <span class="math display">\[
[x^S]FWT(A)=\sum_{T=0}^{2^n-1}(-1)^{|S\and T|}a_T\\
[x^S]IFWT(A)=[x^S]\frac{1}{2^n}FWT(A)
\]</span></p>
<h4><span id="子集卷积">子集卷积</span></h4>
<p>子集卷积:<span class="math inline">\(c_i=\sum_{j}\sum_{k}[j\and
k=\empty,j\or k=i]a_jb_k\\\)</span>.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些<span class="math inline">\([j\and k\ne \empty]\)</span>的答案,而<span class="math inline">\([j\and k=\phi,j\or k=i]=[|j|+|k|=|i|,j\or
k=i]\\\)</span>.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再<span class="math inline">\(n^2\)</span>次结合,并做IFMT,最终将结果累计,复杂度<span class="math inline">\(O(2^nn^2)\)</span>.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4>
<p>其实就是设<span class="math inline">\(g_{i,j}=z^if_j\)</span>,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1agc034f-rng-andxor">Example1([AGC034F] RNG and
XOR)</span></h5>
<p>设<span class="math inline">\(f_i(n)\)</span>表示操作<span class="math inline">\(n\)</span>次后第一次变成<span class="math inline">\(i\)</span>的概率,<span class="math inline">\(g_i(n)\)</span>表示操作<span class="math inline">\(n\)</span>次后变成<span class="math inline">\(i\)</span>的概率.<span class="math inline">\(F,G\)</span>分别是其生成函数.</p>
<p>注意到<span class="math inline">\(G_i=F_iG_0,F_i=\frac{G_i}{G_0}\)</span>,而<span class="math inline">\(F_i&#39;(1)\)</span>就是期望.接下来的问题在于如何求<span class="math inline">\(G\)</span>.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把<span class="math inline">\(a_i\rightarrow \frac{a_i}{\sum
a}\)</span>,然后做<span class="math inline">\(A=FWT(a)\)</span>,注意这里<span class="math inline">\(A_0=\sum a=1\)</span>,FWT自身有很好的性质:<span class="math inline">\(a=\frac{1}{2^N}FWT(A)\)</span>.我们做<span class="math inline">\(n\)</span>次操作后得到的概率数组也就是<span class="math inline">\(\frac{1}{2^N}FWT(A^n)\)</span>.展开FWT的式子,自然有:
<span class="math display">\[
g_i(n)=\sum_{j=0}^{2^N-1}(-1)^{|i\and j|}A_j^nx^n\\
G_i=\sum_{j=0}^{2^N-1}(-1)^{|i\and j|}\frac{1}{1-A_jx}\\
F_i=\frac{G_i}{G_0}\\
F_i&#39;=\frac{G_i&#39;G_0-G_0&#39;G_i}{G_0^2}\\
=\frac{(\sum_{j=0}^{2^N-1}(-1)^{|i\and
j|}\frac{A_j}{(1-A_jx)^2})(\sum_{j=0}^{2^N-1}\frac{1}{1-A_jx})-(\sum_{j=0}^{2^N-1}\frac{A_j}{(1-A_jx)^2})(\sum_{j=0}^{2^N-1}(-1)^{|i\and
j|}\frac{1}{1-A_jx})}{(\sum_{j=0}^{2^N-1}\frac{1}{1-A_jx})^2}
\]</span> <del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求<span class="math inline">\(F&#39;_i(1)\)</span>,因此我们直接把<span class="math inline">\(x=1\)</span>带入算一算就好.不过由于<span class="math inline">\(A_0=1\)</span>,我们必须要解决分母为<span class="math inline">\(0\)</span>的情况,解决的方法是分母乘上<span class="math inline">\((1-x)\)</span>,这样就消掉了<span class="math inline">\(j=0\)</span>的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5>
<p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边<span class="math inline">\(u\leftrightarrow v\)</span>就异或上<span class="math inline">\((2^u+2^v)\)</span>.最后要求这个二进制数是<span class="math inline">\(0\)</span>.我们用一个二元组<span class="math inline">\((a,F)\)</span>表示在集合幂级数上异或上<span class="math inline">\(a\)</span>,在多项式上乘上<span class="math inline">\(F\)</span>.显然一条边是<span class="math inline">\((0,1)+(2^u+2^v,x)\)</span>.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上<span class="math inline">\(1+x\)</span>要么乘上<span class="math inline">\(1-x\)</span>,做完FWT得到的每一个<span class="math inline">\(FWT_i\)</span>一定形如<span class="math inline">\((1+x)^k(1-x)^{m-k}\)</span>,做IFWT的时候直接求<span class="math inline">\(\frac{1}{2^N}\sum
(1+x)^k(1-x)^{m-k}\)</span>即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:<span class="math inline">\((0,1)\)</span>和<span class="math inline">\((2^u+2^v,x)\)</span>,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个<span class="math inline">\(i\)</span>求<span class="math inline">\(k\)</span>,也就是对于每个<span class="math inline">\(i\)</span>求有多少条边满足<span class="math inline">\(|i\and(2^u+2^v)|=1\)</span>,也就是求有多少条边一段链接在了<span class="math inline">\(i\)</span>的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-cloves-3-iii">Example3(CF1034E Little C
Loves 3 III)</span></h5>
<p>仍然是子集卷积,转化为<span class="math inline">\(c_i=\sum_{j}\sum_{k}[|j|+|k|=|i|,j\or
k=i]a_jb_k\\\)</span>.然后我们将<span class="math inline">\(a_j\)</span>乘上<span class="math inline">\(4^j\)</span>,将<span class="math inline">\(b_k\)</span>乘上<span class="math inline">\(4^k\)</span>,最后把<span class="math inline">\(c_i\)</span>除去<span class="math inline">\(4^i\)</span>对<span class="math inline">\(4\)</span>取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2chiori-and-doll-picking">Example4(CF1336E2
Chiori and Doll Picking)</span></h5>
<p>先考虑easy version.首先求出线性基,如果线性基的大小<span class="math inline">\(k\)</span>比较小,我们可以直接<span class="math inline">\(2^k\)</span>枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个<span class="math inline">\(1\)</span>取决于选了多少个元素,其他位置共有<span class="math inline">\(m-k\)</span>个,可以直接状压进状态.这样复杂度就是<span class="math inline">\(O(\min\{2^k,m^22^{m-k}\})\)</span>.</p>
<p>那么我们怎么优化呢?首先<span class="math inline">\(k\)</span>较大的时候有点难做,我们看看能不能优化到<span class="math inline">\(2^{m-k}\)</span>.</p>
<p>考虑设<span class="math inline">\(f_i^c=[|i|=c]\)</span>,将线性基能做出的线性空间设为<span class="math inline">\(A\)</span>,<span class="math inline">\(A_S=1\)</span>当且仅当线性基能异或出<span class="math inline">\(S\)</span>(最后再把那些废元素贡献到答案里).那么<span class="math inline">\(popcount=c\)</span>的答案就是<span class="math inline">\(IFWT(FWT(F)FWT(A))_0\)</span>.考虑<span class="math inline">\(IFWT_0=\frac{1}{2^m}\sum_{i=0}^{2^m-1}FWT(F)_iFWT(A)_i\)</span>,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:<span class="math inline">\(FWT(A)\)</span>要么是<span class="math inline">\(2^k\)</span>,要么是<span class="math inline">\(0\)</span>.</p>
<p>考虑: <span class="math display">\[
A* A=A\times 2^k
\]</span> 这句是为啥呢?因为对于右边的每一个数字<span class="math inline">\(x\)</span>和左边的一个数字<span class="math inline">\(y\)</span>,如果它们都在线性基中,一定存在一个数字<span class="math inline">\(z\)</span>满足<span class="math inline">\(y\oplus
z=x\)</span>,不然就是<span class="math inline">\(0\)</span>.</p>
<p>于是我们有: <span class="math display">\[
FWT(A)_i\cdot FWT(A)_i=FWT(A)_i\times 2^k\\
FWT(A)_i=0\or2^k
\]</span> 引理2:<span class="math inline">\(FWT(A)_i=2^k\Leftrightarrow
\forall x,A_x\ne 0,|i\and x|\equiv 0\pmod 2\)</span>.</p>
<p>直接展开上面的式子,用<span class="math inline">\(\sum_{S\subseteq
T}(-1)^{|S|}=[T=\empty]\)</span>.</p>
<p>引理3:<span class="math inline">\(FWT(A)\)</span>中值为<span class="math inline">\(2^k\)</span>的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果<span class="math inline">\(i\)</span>满足条件,<span class="math inline">\(j\)</span>满足条件,一开始做FWT时我们已经注意到:<span class="math inline">\((i\oplus j)\and x=(i\and x)\oplus (j\and
x)\)</span>.于是这个引理也显然成立.</p>
<p>引理4:<span class="math inline">\(FWT(A)\)</span>中值为<span class="math inline">\(2^k\)</span>的位置构成的线性基的大小是<span class="math inline">\(m-k\)</span>.</p>
<p>设这些位置构成的空间是<span class="math inline">\(B\)</span>,<span class="math inline">\(B_S=1\)</span>当且仅当<span class="math inline">\(S\)</span>在这个空间中.我们有: <span class="math display">\[
FWT(A)=B\times 2^k\\
A=IFWT(B)\times 2^k
\]</span> 注意到<span class="math inline">\(a_0=1\)</span>,也就是<span class="math inline">\(\frac{2^k}{2^m}\sum b=1,\sum
b=2^{m-k}\)</span>,这就证明了引理.</p>
<p>引理5:将<span class="math inline">\(A\)</span>的线性基对应的矩阵从前往后消成最简,<span class="math inline">\(B\)</span>的线性基对应的矩阵从后往前消成最简,上<span class="math inline">\(A\)</span>下<span class="math inline">\(B\)</span>拼成一个<span class="math inline">\(m\times
m\)</span>的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据<span class="math inline">\(rank(A)+rank(B)=k+m-k=m\)</span>可以知道主对角线一定全是<span class="math inline">\(1\)</span>,然后我们任取<span class="math inline">\(A\)</span>中的一个基<span class="math inline">\(x\)</span>和<span class="math inline">\(B\)</span>中的一个基<span class="math inline">\(y\)</span>,应该有<span class="math inline">\(|x\and y|\equiv 0\pmod
2\)</span>.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由<span class="math inline">\(A\)</span>得知<span class="math inline">\(B\)</span>长什么样.</p>
<p>引理6:<span class="math inline">\(FWT(F^c)_i\)</span>只和<span class="math inline">\(|i|\)</span>有关.</p>
<p>因为<span class="math inline">\(F^c_i\)</span>只和<span class="math inline">\(|i|\)</span>有关,这里考虑一下对称性就可以.因此设<span class="math inline">\(w_{d}^c=FWT(F^c)_i,|i|=d\)</span>.</p>
<p>然后注意到<span class="math inline">\(w_d^c=\sum_{i=0}^{2^m-1}(-1)^{|i\and
(2^d-1)|}[|i|=c]\)</span>.组合意义展开一下: <span class="math display">\[
w_d^c=\sum_{j=0}^{d}(-1)^{j}\binom{d}{j}\binom{m-d}{c-j}
\]</span> 接下来怎么做呢?令<span class="math inline">\(g_d=\sum_{i=0}^{2^m-1}[A_i=1][|i|=d]\)</span>,这里可以<span class="math inline">\(O(2^{m-k})\)</span>,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5>
<p>首先发现”如果没有边那么是<span class="math inline">\(0\)</span>“这个限制太强了,如果我们能改为”如果是<span class="math inline">\(0\)</span>,那么可有边可无边”的话,整个序列就会被<span class="math inline">\(1\)</span>的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设<span class="math inline">\(g_{len,S}\)</span>表示长度为<span class="math inline">\(len\)</span>,一段长度为<span class="math inline">\(len-1\)</span>的连续的<span class="math inline">\(1\)</span>对应的集合是<span class="math inline">\(S\)</span>的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个<span class="math inline">\(0\)</span>).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5>
<p>首先可以类似数位dp设计一个<span class="math inline">\(dp_{i,S}\)</span>表示目前dp到了第<span class="math inline">\(i\)</span>位,然后前面的<span class="math inline">\(limit\)</span>是<span class="math inline">\(S\)</span>.接下来分类讨论当前的最大值限制是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2>
<h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3>
<h4><span id="概念">概念</span></h4>
<p>我们定义一个幂级数形如<span class="math inline">\(A(z)=\sum_{k\geq
0}a_kz^k\)</span>,并使<span class="math inline">\([z^n]A(z)=a_n\)</span>.则称<span class="math inline">\(A(z)\)</span>是<span class="math inline">\(\langle
a_0,a_1,...\rangle\)</span>的生成函数.</p>
<h4><span id="运算">运算</span></h4>
<ol type="1">
<li><span class="math inline">\(\alpha A(z)+\beta B(z)=\sum_{n\geq
0}(\alpha f_n+\beta g_n)z^n\)</span>.</li>
<li><span class="math inline">\(z^mA(z)=\sum_{n\geq
0}g_{n}z^{n+m}=\sum_{n\geq m}g_{n-m}z^n\)</span>.</li>
<li><span class="math inline">\(A(cz)=\sum_{n\geq
0}c^nf_nz^n\)</span>.</li>
<li><span class="math inline">\(A&#39;(z)=\sum_{n\geq
1}ig_iz^{i-1}\)</span>.</li>
<li><span class="math inline">\(\int A(z)dz=\sum_{n\geq
0}\cfrac{1}{n+1}g_nz^{n+1}\)</span>.</li>
<li><span class="math inline">\(A(z)B(z)=\sum_{n\geq
0}(\sum_{k=0}^nf_kg_{n-k})z^n\)</span>.</li>
<li><span class="math inline">\(\cfrac{1}{1-z}A(z)=\sum_{n\geq
0}(\sum_{k=0}^ng_k)z^n\)</span>.</li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4>
<ol type="1">
<li><span class="math inline">\(\cfrac{1}{1-z}=\sum_{k\geq
0}z^k\\\)</span>,<span class="math inline">\(\cfrac{1}{1-cz}=\sum_{k\geq
0}c^kz^k\\\)</span>.</li>
</ol>
<p>证明显然.</p>
<ol start="2" type="1">
<li><span class="math inline">\((1+z)^r=\sum_{k\geq
0}\binom{r}{k}z^k\\\)</span>,<span class="math inline">\((1-z)^r=\sum_{k\geq
0}(-1)^k\binom{r}{k}z^k\\\)</span>.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\cfrac{1}{1-z^m}=\sum_{n\geq
0}[n|m]z^n\\\)</span>.</li>
</ol>
<p>证明显然.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\cfrac{1}{(1-z)^{n+1}}=\sum_{k\geq
0}\binom{n+k}{n}z^k,n\in\mathbb{N}\\\)</span>,<span class="math inline">\(\cfrac{z^n}{(1-z)^{n+1}}=\sum_{k\geq
0}\binom{k}{n}z^k,n\in\mathbb{N}\\\)</span></li>
</ol>
<p>直接使用二项式定理展开<span class="math inline">\((1-z)^{-n-1}\)</span>,可以得到: <span class="math display">\[
(1-z)^{-n-1}=\sum_{k\geq 0}(-1)^k\binom{-n-1}{k}z^k
\]</span> 反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:
<span class="math display">\[
\cfrac{1}{(1-z)^2}=\sum_{n\geq
0}(n+1)z^n\\\cfrac{z}{(1-z)^2}=\sum_{n\geq 0}nz^n
\]</span></p>
<p>根据<span class="math inline">\((1)\)</span>求导即可得到此式.</p>
<ol start="5" type="1">
<li><span class="math inline">\(e^z=\sum_{k\geq
0}\cfrac{z^k}{k!}\\\)</span>.</li>
<li><span class="math inline">\(\ln(\cfrac{1}{1-z})=\sum_{n\geq
1}\cfrac{1}{n}z^n\)</span>.</li>
<li><span class="math inline">\(\ln(1+z)=\sum_{k\geq
0}(-1)^k\cfrac{z^{k+1}}{k+1}\\\)</span>.</li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\frac{1-\sqrt {1-4x}}{2x}=\sum_{k\geq
0}\frac{\binom{2k}{k}}{k+1}x^k\)</span>.</li>
</ol>
<p>也即卡特兰数<span class="math inline">\(C_k\)</span>的生成函数,证明考虑: <span class="math display">\[
xC^2+1=C
\]</span> 然后得到两个根,带入<span class="math inline">\(x=0\)</span>舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3>
<p>https://zhuanlan.zhihu.com/p/53079223</p>
<p>序列<span class="math inline">\(\{a\}\)</span>的指数生成函数定义为形式幂级数<span class="math inline">\(\hat F(x)=\sum
a_n\frac{x^n}{n!}\)</span>.注意<span class="math inline">\([x^n]\hat
F(x)=a_n\)</span>.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>我们有: <span class="math display">\[
\hat F(x)\hat G(x)=\sum_{j\geq 0}a_j\frac{x^j}{j!}\sum_{k\geq
0}b_k\frac{x^k}{k!}\\
=\sum_{k\geq
0}x^k\sum_{j=0}^ka_jb_{k-j}\frac{k!}{j!(k-j)!}\frac{1}{k!}\\
=\sum_{k\geq 0}\frac{x^k}{k!}\sum_{j=0}^ka_jb_{k-j}\binom{k}{j}
\]</span> 即<span class="math inline">\(\lang\sum_{i=0}^n\binom{n}{i}a_ib_{n-i}\rang\)</span>的EFG.</p>
<p>注意到有一个特例是<span class="math inline">\(x\hat
F(x)\)</span>就是<span class="math inline">\(\lang\binom{n}{n-1}a_i\rang\)</span>的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li><span class="math inline">\(e^x=\sum_{k\geq
0}\frac{x^k}{k!}\)</span></li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol start="2" type="1">
<li><span class="math inline">\(e^{px}=\sum_{k\geq
0}p^k\frac{x^k}{k!}\)</span></li>
</ol>
<p>换元后可以得到.一个经典特例是<span class="math inline">\(e^{-x}=\sum_{k\geq
0}(-1)^k\frac{x^k}{k!}\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\frac{e^x+e^{-x}}{2}=\sum_{k\geq
0}[2|k]\frac{x^k}{k!}\)</span>.</li>
</ol>
<p>显然.</p>
<ol start="4" type="1">
<li><span class="math inline">\((1+x)^n=\sum_{k\geq
0}n^{\underline{k}}\frac{x^k}{k!}\)</span>.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\ln(1+x)=\sum_{k\geq
1}(-1)^{k-1}(k-1)!\frac{x^k}{k!}\)</span>.</li>
<li><span class="math inline">\(\ln(1-x)=\sum_{k\geq
1}(k-1)!\frac{x^k}{k!}\)</span>.</li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4>
<p>我们设<span class="math inline">\(F_k(n)\)</span>为<span class="math inline">\(n\)</span>个有标号元素划分成<span class="math inline">\(k\)</span>个非空无序集合的情况,<span class="math inline">\(f_i\)</span>为<span class="math inline">\(i\)</span>个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和<span class="math inline">\(|S|\)</span>有关的定义在集合上的函数),有: <span class="math display">\[
F_k(n)=\frac{n!}{k!}\sum_{\sum_{i=1}^ka_i=n}\prod_{j=1}^k\frac{f_{a_j}}{a_j!}
\]</span> 设<span class="math inline">\(\hat{F}(x)=\sum_{n\geq
0}f_n\frac{x^n}{n!}\)</span>,再设: <span class="math display">\[
\hat G_k(x)=\sum_{n\geq 0}F_k(n)\frac{x^n}{n!}\\
=\sum_{n\geq
0}x^n\frac{1}{k!}\sum_{\sum_{i=1}^ka_i=n}\prod_{j=1}^k\frac{f_{a_j}}{a_j!}\\
=\sum_{n\geq
0}\frac{1}{k!}\sum_{\sum_{i=1}^ka_i=n}\prod_{j=1}^k\frac{f_{a_j}x^{a_j}}{a_j!}\\
=\frac{1}{k!}\hat F^k(x)
\]</span></p>
<p><span class="math display">\[
\sum_{k\geq 0}\hat G_k(x)=\exp \hat F(x)
\]</span></p>
<p>或者直接递推: <span class="math display">\[
F_k(x)=\sum_{i=1}^{n-k+1}\binom{n}{i}F_{k-1}(n-i)f_i\frac{1}{k}\\
\]</span></p>
<p><span class="math display">\[
\hat G_k(x)=\sum_{n\geq 0}\frac{x^n}{n!}F_k(n)\\
=\sum_{n\geq
0}\frac{x^n}{n!}\sum_{i=1}^{n-k+1}\binom{n}{i}F_{k-1}(n-i)f_i\frac{1}{k}\\
=\frac{1}{k}\sum_{n\geq
0}\frac{x^n}{n!}\sum_{i=1}^{n-k+1}\binom{n}{i}F_{k-1}(n-i)f_i\\
=\frac{1}{k}\hat G_{k-1}(x)\hat F(x)\\
=\frac{1}{k!}\hat F^k(x)
\]</span></p>
<p>简而言之,<span class="math inline">\([x^n]\hat F(x)\)</span>是将<span class="math inline">\(n\)</span>个有标号的元素放到同一个无序集合的方案数,而<span class="math inline">\([x^n]\exp \hat F(x)\)</span>是将<span class="math inline">\(n\)</span>个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poj3734">Example1(POJ3734)</span></h5>
<p>对于红黄色砖块,其选取方案为<span class="math inline">\(\{1,0,1,0,\cdots\}\)</span>,对应的EGF是<span class="math inline">\(\frac{e^x+e^{-x}}{2}\)</span>.</p>
<p>对于蓝绿色砖块,选取方案是<span class="math inline">\(e^x\)</span>.</p>
<p>乘起来有: <span class="math display">\[
\hat F(x)=(\frac{e^x+e^{-x}}{2})^2e^{2x}\\
=\frac{(e^{2x}+2+e^{-2x})e^{2x}}{4}\\
=\frac{e^{4x}+2e^{2x}+1}{4}\\
=\frac{1}{4}+\sum_{k\geq 0}\frac{4^i+2^{i+1}}{4}\frac{x^i}{i!}
\]</span> 于是有<span class="math inline">\([x^n]\hat
F(x)=4^{n-1}+2^{n-1}\)</span>.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5>
<p>长度为<span class="math inline">\(n\)</span>的排列数的指数生成函数是<span class="math inline">\(\hat P(x)=\sum_{n\geq
0}\frac{n!x^n}{n!}=\frac{1}{1-x}\)</span>.</p>
<p>长度为<span class="math inline">\(n\)</span>的圆排列的指数生成函数是<span class="math inline">\(\hat Q(x)=\sum_{n\geq
0}\frac{(n-1)!x^n}{n!}=\frac{x^n}{n}=-\ln
(1-x)=\ln\frac{1}{1-x}\)</span>.</p>
<p>于是有<span class="math inline">\(\exp\hat Q(x)=\hat
P(x)\)</span>.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5>
<p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为<span class="math inline">\(1\)</span>的置换环,其EGF显然是<span class="math inline">\(\sum_{n\geq
2}\frac{x^n}{n}=-\ln(1-x)-x\)</span>,错排数的EGF对其取<span class="math inline">\(\exp\)</span>即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5>
<p>考虑如果<span class="math inline">\(n\)</span>个点带编号的无向连通图的EGF是<span class="math inline">\(\hat F(x)\)</span>,那么<span class="math inline">\(n\)</span>个点带标号无向图的EGF就是<span class="math inline">\(\exp \hat
F(x)\)</span>,后者直接计数,前者对后者做一次<span class="math inline">\(\ln\)</span>就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5>
<p>求有多少个映射<span class="math inline">\(f:\{1,2,\cdots,n\}\mapsto\{1,2,\cdots,n\}\)</span>满足<span class="math inline">\(f\circ f\circ \cdots \circ f\)</span>(共<span class="math inline">\(k\)</span>个<span class="math inline">\(f\)</span>)<span class="math inline">\(=f\circ
f\circ \cdots\circ f\)</span>(共<span class="math inline">\(k-1\)</span>个<span class="math inline">\(f\)</span>).</p>
<p>考虑将<span class="math inline">\(i\rightarrow
f_i\)</span>,这等价于对深度不超过<span class="math inline">\(k\)</span>的基环树(环的长度为<span class="math inline">\(1\)</span>)计数,等价于对深度不超过<span class="math inline">\(k\)</span>的有根树计数.注意到删去根节点后等价于对深度不超过<span class="math inline">\(k-1\)</span>的有根树计数,因此<span class="math inline">\(\hat F_k(x)=x\exp \hat F_{k-1}(x)\)</span>.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5>
<p>假设<span class="math inline">\(k\)</span>次操作后<span class="math inline">\(a_i\)</span>减少了<span class="math inline">\(b_i\)</span>,实际上要求的就是<span class="math inline">\(\prod_{i=1}^na_i-\prod_{i=1}^n(a_i-b_i)\)</span>.</p>
<p>考虑对所有情况下的<span class="math inline">\(\prod_{i=1}^n(a_i-b_i)\)</span>求和,注意到<span class="math inline">\(k\)</span>次操作,使得<span class="math inline">\(i\)</span>出现<span class="math inline">\(b_i\)</span>次的方案数是<span class="math inline">\(\frac{k!}{\prod_{i=1}^nb_i!}\)</span>.直接设<span class="math inline">\(a_j\)</span>的EGF是 <span class="math display">\[
\hat F_{j}(x)=\sum_{i\geq 0}(a_j-i)\frac{x^i}{i!}\\=\sum_{i\geq
0}a_j\frac{x^i}{i!}-\sum_{i\geq 1}\frac{x^i}{(i-1)!}\\
=a_je^x-xe^x=(a_j-x)e^x
\]</span> 答案就是<span class="math inline">\([x^k]\prod_{j=1}^n\hat
F_j(x)\)</span>.</p>
<h5><span id="example7">Example7</span></h5>
<h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3>
<p>对于序列<span class="math inline">\(f_n\)</span>,定义其DGF为<span class="math inline">\(\tilde F(x)=\sum_{i\geq
1}\frac{f_i}{i^x}\)</span>.注意到若<span class="math inline">\(f\)</span>是积性函数,那么<span class="math inline">\(\tilde{F}(x)=\prod_{p\in prime}\sum_{i\geq
0}\frac{f_{p^i}}{p^{ix}}\\\)</span>.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>对于两个序列<span class="math inline">\(f,g\)</span>,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:
<span class="math display">\[
\tilde{F}(x)\tilde{G}(x)=\sum_{i}\sum_{j}\frac{f(i)g(j)}{(ij)^x}\\
=\sum_{i}\frac{1}{i^x}\sum_{d|i}f(d)g(\frac{i}{d})
\]</span></p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li><span class="math inline">\(\epsilon(x)=[x=1]\)</span>.</li>
</ol>
<p>显然为<span class="math inline">\(\tilde{E}(x)=1\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(I(x)=1\)</span>.</li>
</ol>
<p>其封闭式是黎曼函数<span class="math inline">\(\zeta(x)\)</span>,事实上,我们有: <span class="math display">\[
\zeta(x)=\prod_{i\geq 1}\frac{1}{i^x}\\=\prod_{p\in prime}\sum_{i\geq
0}\frac{1}{p^{ix}}\\=\prod_{p\in prime}\frac{1}{1-p^{-x}}
\]</span></p>
<ol start="3" type="1">
<li><span class="math inline">\(\mu(n)\)</span>.</li>
</ol>
<p>其DGF为<span class="math inline">\(\tilde{M}(x)=\prod_{p\in
prime}(1-p^{-x})\)</span>.注意到<span class="math inline">\(\zeta(x)\tilde{M}(x)=1,\tilde{M}(x)=\frac{1}{\zeta(x)}\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(id(n)=n\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\tilde{ID}(n)=\prod_{i\geq
1}\frac{i}{i^x}=\prod_{i\geq
1}\frac{1}{i^{x-1}}=\zeta(x-1)\)</span>.</p>
<ol start="5" type="1">
<li><span class="math inline">\(I_k(n)=n^k\)</span>.</li>
</ol>
<p><span class="math display">\[
\tilde{I_k}(x)=\prod_{i\geq 1}\frac{1}{i^{x-k}}=\zeta(x-k)
\]</span></p>
<ol start="6" type="1">
<li><span class="math inline">\(\varphi(n)\)</span>.</li>
</ol>
<p>注意到: <span class="math display">\[
\tilde{\Phi}(x)=\prod_{p\in
prime}(1+\frac{p-1}{p^x}+\frac{p(p-1)}{p^{2x}}+\cdots)\\
=\prod_{p\in prime}\frac{1-p^{-x}}{1-p^{1-x}}\\
=\tilde{\Phi}(x)=\frac{\zeta(x-1)}{\zeta(x)}
\]</span> 也注意到<span class="math inline">\(\tilde{\Phi}(x)I(x)=\zeta(x-1)=\tilde{ID}(x)\)</span>.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sigma_k(n)=\sum_{d|n}d^k\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\(\sigma_k(n)=I_k(n)*I_0(n)\)</span>,也就是说<span class="math inline">\(\tilde{S}(x)=\zeta(x-k)\zeta(x)\)</span>.</p>
<ol start="8" type="1">
<li><span class="math inline">\(u(n)=|\mu(n)|\)</span>.</li>
</ol>
<p><span class="math inline">\(\tilde{u}(n)=\frac{\zeta(n)}{\zeta(2n)}\)</span>.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5>
<p>考虑对于<span class="math inline">\(f(n)=n^2\varphi(n)\)</span>构造积性函数<span class="math inline">\(g(n),h(n)\)</span>使得<span class="math inline">\(f*g=h\)</span>.</p>
<p>注意到: <span class="math display">\[
\tilde{F}(x)=\prod_{p\in prime}(1+\sum_{k\geq
1}\frac{p^{3k-1}(p-1)}{p^{kx}})\\=\prod_{p\in
prime}\frac{1-p^{2-x}}{1-p^{3-x}}=\frac{\zeta(x-3)}{\zeta(x-2)}
\]</span> 也就是<span class="math inline">\(f*I_2=I_3\)</span>.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3>
<p>对于复数的阶乘,我们通常定义: <span class="math display">\[
\cfrac{1}{z!}=\lim_{n\rightarrow +\infin}\binom{n+z}{z}n^{-z}
\]</span> 同时我们定义<span class="math inline">\(\Gamma(z+1)=z!\)</span>,有:<span class="math inline">\((-z)!\Gamma(z)=\cfrac{\pi}{\sin(\pi
z)}\)</span>.</p>
<p>这样我们还可以定义广义阶乘幂: <span class="math display">\[
z^{\underline{w}}=\cfrac{z!}{(z-w)!}\\
z^{\overline{w}}=\cfrac{\Gamma(z+w)}{\Gamma(z)}
\]</span> 通过以上我们还可以有二项式系数的定义: <span class="math display">\[
\binom{z}{w}=\lim_{\zeta\rightarrow z,\omega\rightarrow
w}\cfrac{\zeta!}{\omega!(\zeta-\omega)!}
\]</span></p>
<h3><span id="超几何级数">超几何级数</span></h3>
<h4><span id="超几何函数">超几何函数</span></h4>
<p>我们定义超几何函数<span class="math inline">\(F(a_1,...,a_m;b_1,...b_n;z)=F\left(\begin{array}{r|}a_1,...,a_m\\b_1,...,b_n\end{array}z\right)=\sum_{k\geq
0}\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}\)</span>.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似<span class="math inline">\(\cfrac{0}{0}=1\)</span>之类的式子,可以发现当<span class="math inline">\(z=0\)</span>时任意超几何函数总是<span class="math inline">\(=1\)</span>.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为<span class="math inline">\(0\)</span>或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4>
<h5><span id="合流超几何函数">合流超几何函数</span></h5>
<p>我们通常把形如<span class="math inline">\(M(a;b;z)=F\left(\begin{array}{r|}a\\b\end{array}z\right)=\sum_{k\geq
0}\cfrac{z^ka^{\overline{k}}}{b^{\overline{k}}k!}\)</span>的函数称为合流超几何函数.</p>
<p>不难发现我们有: <span class="math display">\[
F\left(\begin{array}{r|}1\\1\end{array}z\right)=e^z
\]</span> 也即常见生成函数中的<span class="math inline">\((6)\)</span>.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5>
<p>我们把形如<span class="math inline">\(F\left(\begin{array}{r|}a,b\\c\end{array}z\right)=\sum_{k\geq
0}\cfrac{z^ka^{\overline{k}}b^{\overline{k}}}{c^{\overline{k}}k!}\)</span>的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol type="1">
<li><span class="math inline">\(F\left(\begin{array}{r|}1,1\\1\end{array}z\right)=\cfrac{1}{1-z}\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\((1)\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(F\left(\begin{array}{r|}-a,1\\1\end{array}-z\right)=(1+z)^a\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\((2)\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(F\left(\begin{array}{r|}a,1\\1\end{array}z\right)=\cfrac{1}{(1-z)^a}\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\((4)\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(F\left(\begin{array}{r|}1,1\\2\end{array}-z\right)=\cfrac
{\ln(1+z)}z\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\((7)\)</span>.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4>
<p>我们先考虑改写超几何级数的形式:</p>
<p><span class="math inline">\(F\left(\begin{array}{r|}a_1,...,a_m\\b_1,...,b_n\end{array}z\right)=\sum_{k\geq
0}t_k,t_k=\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}\)</span>.</p>
<p>不难发现<span class="math inline">\(t_0=1\)</span>,而: <span class="math display">\[
\cfrac{t_{k+1}}{t_k}=\cfrac{z^{k+1}}{z^k}\cfrac{k!}{(k+1)!}\cfrac{\prod_{i=1}^ma_i^{\overline{k+1}}}{\prod_{i=1}^ma_i^{\overline{k}}}\cfrac{\prod_{i=1}^nb_i^{\overline{k}}}{\prod_{i=1}^nb_i^{\overline{k+1}}}\\
=\cfrac{\prod_{i=1}^m(k+a_i)}{\prod_{i=1}^n(k+b_i)}\cfrac{z}{k+1}
\]</span> 换句话说,<span class="math inline">\(\cfrac{t_{k+1}}{t_k}\)</span>是关于<span class="math inline">\(k\)</span>的一个有理函数.而根据代数基本定理,任意<span class="math inline">\(k\)</span>的有理函数在<span class="math inline">\(\mathbb{C}\)</span>内都可以分解为以上的形式(如果缺少<span class="math inline">\(k+1\)</span>项则需要上下同时乘以<span class="math inline">\(k+1\)</span>以补上).</p>
<p>换句话说,对于一个无穷级数<span class="math inline">\(\sum_{k\geq
0}t_k\)</span>,我们先将<span class="math inline">\(\cfrac{t_{k+1}}{t_k}\)</span>表示回超几何函数,设为<span class="math inline">\(F\)</span>.</p>
<p>那么有:<span class="math inline">\(\sum_{k\geq
0}t_k=t_0F\)</span>.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和<span class="math inline">\(\Gamma\)</span>函数的定义)来使这些公式全部成立.But
who
cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5>
<p>求证:<span class="math inline">\(\sum_{k\leq
n}\binom{r+k}{k}=\binom{r+n+1}{n}\Leftrightarrow
F\left(\begin{array}{r|}1,-n\\-n-r\end{array}1\right)=\cfrac{r+n+1}{r+1},n\in\mathbb{N}\\\)</span>.</p>
<p>首先考虑: <span class="math display">\[
\sum_{k\leq n}\binom{r+k}{k}=\sum_{k\geq 0}\binom{r+n-k}{n-k}
\]</span>
有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到: <span class="math display">\[
\binom{r+n}{n}F\left(\begin{array}{r|}1,-n\\-n-r\end{array}1\right)=\binom{r+n+1}{n}
\]</span></p>
<p>两边同时除以<span class="math inline">\(\binom{r+n}{n}\)</span>得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5>
<p>通过范德蒙德卷积,不难验证: <span class="math display">\[
F\left(\begin{array}{r|}a,b\\c\end{array}1\right)=\cfrac{\Gamma(c-a-b)\Gamma(c)}{\Gamma(c-a)\Gamma(c-b)},-b\in\mathbb{N}
\]</span> 这个公式的一个特例是: <span class="math display">\[
F\left(\begin{array}{r|}a,-n\\c\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\
\sum_{k\geq
0}\cfrac{a^{\overline{k}}(-n)^{\overline{k}}}{c^{\overline{k}}k!}=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\
\]</span>
这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式: <span class="math display">\[
F\left(\begin{array}{r|}a,b,-n\\c,a+b-n-c+1\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}(c-b)^{\overline{n}}}{c^{\overline{n}}(c-a-b)^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}(b-c)^{\underline{n}}}{(-c)^{\underline{n}}(a+b-c)^{\overline{n}}},n\in\mathbb{N}\\
\]</span>
事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3>
<h4><span id="example1luogu4931">Example1(luogu4931)</span></h4>
<p>二项式反演: <span class="math display">\[
ans_k=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}\binom{n}{i}\binom{n}{i}i!(2n-2i)!2^i\\
=\sum_{i=k}^n(-1)^{i-k}\frac{1}{k!(i-k)!}\frac{n!}{(n-i)!}\frac{n!}{(n-i)!}(2n-2i)!2^i\\
=(n!)^2\frac{2^k}{k!}\sum_{i=k}^n(-1)^{i-k}\frac{1}{(i-k)!}\binom{2n-2i}{n-i}2^{i-k}\\
=(n!)^2\frac{2^k}{k!}\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}
\]</span> 注意到后者只与<span class="math inline">\(n-k\)</span>有关,不妨设其为<span class="math inline">\(f_{n}=\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}\)</span>,预处理一下就可以做到<span class="math inline">\(O(n^2+nT)\)</span>.</p>
<p>加强版咋做?我们继续看看式子: <span class="math display">\[
ans=(n!)^2\frac{2^k}{k!}f_{n-k}\\
f_{n}=\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}
\]</span> 注意到<span class="math inline">\(f\)</span>是一个卷积的形式,设其生成函数为<span class="math inline">\(F_n\)</span>,<span class="math inline">\(g_n=\frac{(-2)^n}{n!},h_n=\binom{2n}{n}\)</span>,我们自然有<span class="math inline">\(F=GH\)</span>.</p>
<p>考虑<span class="math inline">\(G\)</span>和<span class="math inline">\(H\)</span>的生成函数形式,先看<span class="math inline">\(G\)</span>,显然用泰勒展开: <span class="math display">\[
G=\sum_{n\geq 0}\frac{(-2x)^n}{n!}=e^{-2x}
\]</span> 再看<span class="math inline">\(H\)</span>,是卡特兰数的生成函数,有: <span class="math display">\[
H=\frac{1}{\sqrt{1-4x}}
\]</span> 这下简单了,答案是: <span class="math display">\[
(n!)^2\frac{2^k}{k!}[x^{n-k}]\frac{e^{-2x}}{\sqrt {1-4x}}
\]</span> 现在看<span class="math inline">\(F\)</span>,平方一下有: <span class="math display">\[
(1-4x)F^2=e^{-4x}
\]</span> 两边求导: <span class="math display">\[
-4F^2+(1-4x)2F\times F&#39;=-4e^{-4x}\\
-4F^2+(1-4x)2F\times F&#39;=-4(1-4x)F^2\\
(2-8x)F&#39;=16xF\\
\]</span> 得到了一个线性递推形式,更进一步地: <span class="math display">\[
2(i+1)f_{i+1}-8if_i=16f_{i-1}\\
if_i=4(i-1)f_{i-1}+8f_{i-2}
\]</span>
技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<p>###生成函数的应用</p>
<h4><span id="求解递归关系">求解递归关系</span></h4>
<p>我们假设已经有了<span class="math inline">\(R(z)=\sum_{k\geq
0}g_kz^k\)</span>,并且<span class="math inline">\(R(z)=\cfrac{P(z)}{Q(z)}\)</span>,其中<span class="math inline">\(P(z)\)</span>和<span class="math inline">\(Q(z)\)</span>都是多项式,我们想要找到一种方式求解<span class="math inline">\([z^n]R(z)\)</span>.</p>
<p>考虑有理函数<span class="math inline">\(S(z)=\sum_{k=1}^m\cfrac{a_k}{1-\rho_kz}\\\)</span>,不难发现<span class="math inline">\([z^n]S(z)=\sum_{k=1}^ma_k\rho_k^n\\\)</span>.</p>
<p>那么可以证明,只要<span class="math inline">\(Q(z)=0\)</span>无重根并且无零根,那么就存在一组系数满足<span class="math inline">\(S(z)=R(z)\)</span>.</p>
<p>我们这么定义”反射”运算,若<span class="math inline">\(Q(z)=\sum_{k=0}^mq_kz^k\\\)</span>,则其反射多项式为<span class="math inline">\(Q^R(z)=\sum_{k=0}^mq_kz^{m-k}\\\)</span>.</p>
<p>若<span class="math inline">\(Q(z)=q_0\prod_{k=1}^m(1-\rho_kz)\)</span>,则显然有<span class="math inline">\(Q^R(z)=q_0\prod_{k=1}^m(z-\rho_k)\\\)</span>.</p>
<p>那么显然这里求出来的这组数<span class="math inline">\(\rho\)</span>就是<span class="math inline">\(S(z)\)</span>中的那组<span class="math inline">\(\rho\)</span>.</p>
<p>而我们有<span class="math inline">\(a_k=\cfrac{-\rho_kP(\cfrac{1}{\rho_k})}{Q&#39;(\rho_k)}\)</span>.</p>
<h4><span id="example1">Example1</span></h4>
<p>已知<span class="math inline">\(n!=\sum_{k}\binom{n}{k}g_{n-k},n\in\mathbb{N}\\\)</span>,求<span class="math inline">\(g_n\)</span>.</p>
<p>首先两边同时除以<span class="math inline">\(n!\)</span>并将组合数用阶乘形式展开,我们有: <span class="math display">\[
1=\sum_{k}\cfrac{g_{n-k}}{k!(n-k)!}.
\]</span> 如果我们令<span class="math inline">\(D(z)=\sum_{k\geq
0}\cfrac{g_{k}}{k!}z^k\)</span>,则有: <span class="math display">\[
\cfrac{1}{1-z}=e^zD(z)\\
D(z)=\cfrac{1}{1-z}e^{-z}\\
D(z)=(\sum_{k\geq 0}z^k)(\sum_{k\geq 0}(-1)^k\cfrac{z^k}{k!})\\
[z^n]D(z)=\sum_{k=0}^n\cfrac{(-1)^k}{k!}
\]</span> 于是<span class="math inline">\(g_n=n!\sum_{k=0}^n\cfrac{(-1)^k}{k!}\\\)</span>.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4>
<p>首先设<span class="math inline">\(F_i(x)\)</span>为第<span class="math inline">\(i\)</span>家的生成函数,这个是显然可以快速预处理出来的.令<span class="math inline">\(M=520\)</span>.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有<span class="math inline">\(n\)</span>个多项式,最高次数是<span class="math inline">\(M\)</span>,因此一共要插入<span class="math inline">\(nM\)</span>个值,又要处理每个后缀,复杂度来到<span class="math inline">\(O(n^2M^3)\)</span>.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到<span class="math inline">\(O(n^2M^2)\)</span>.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到<span class="math inline">\(O(n^2Mq)\)</span>.但<span class="math inline">\(n\)</span>如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下<span class="math inline">\(2^n\)</span>的答案,复杂度来到<span class="math inline">\(O(nM2^nq)\)</span>.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到<span class="math inline">\(O(\frac{n}{B}B2^BMnM)\)</span>,单次询问复杂度来到<span class="math inline">\(O(\frac{n}{B}Mnq)\)</span>.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以<span class="math inline">\(k\)</span>要大于<span class="math inline">\(m\)</span>,就直接输出<span class="math inline">\(0\)</span>.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要<span class="math inline">\(O((nM)^2q)\)</span>的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到<span class="math inline">\(O(nMq)\)</span>.</p>
<h4><span id="example3十二省联考-2019皮配">Example3([十二省联考 2019]
皮配)</span></h4>
<p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为<span class="math inline">\(xy,y,x,1\)</span>,这样最后判断幂在一个区间内的<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是<span class="math inline">\(\prod
(x^{s_i}y^{s_i}+x^{s_i})+\prod(y^{s_i}+1)=(\prod
(x^{s_i}+1))(\prod(y^{s_i}+1))\)</span>.也就是<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于<span class="math inline">\(O(mk^2s)\)</span>.最后两部分合并一下.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#约定">约定</a></li>
<li><a href="#树的性质">树的性质</a>
<ul>
<li><a href="#example3cf1628e-groceries-in-meteor-town">Example3(CF1628E
Groceries in Meteor Town)</a></li>
<li><a href="#example4loj3692">Example4(loj3692)</a></li>
<li><a href="#树的直径">树的直径</a>
<ul>
<li><a href="#example1sdoi2013直径">Example1([SDOI2013]直径)</a></li>
</ul></li>
<li><a href="#树的重心">树的重心</a>
<ul>
<li><a href="#example1csp-s2019树的重心">Example1([CSP-S2019]树的重心)</a></li>
</ul></li>
<li><a href="#树的结构的维护">树的结构的维护</a>
<ul>
<li><a href="#example1">Example1</a></li>
</ul></li>
<li><a href="#dfs树的性质">dfs树的性质</a>
<ul>
<li><a href="#example1cf1361ejames-and-the-chase">Example1([CF1361E]James and
the Chase)</a></li>
<li><a href="#example2loj-6276">Example2(Loj 6276)</a></li>
</ul></li>
</ul></li>
<li><a href="#圆方树的性质">圆方树的性质</a></li>
<li><a href="#任意图的性质">任意图的性质</a></li>
<li><a href="#dsu-on-tree">dsu on tree</a>
<ul>
<li><a href="#exampleqoj5020">Example(QOJ5020)</a></li>
</ul></li>
<li><a href="#最小生成树">最小生成树</a>
<ul>
<li><a href="#example1cf1550f-jumping-around">Example1(CF1550F Jumping
Around)</a></li>
</ul></li>
<li><a href="#kruskal重构树">Kruskal重构树</a></li>
<li><a href="#最短路">最短路</a>
<ul>
<li><a href="#example1cf1753d-the-beach">Example1(CF1753D The
Beach)</a></li>
<li><a href="#example2cf843ddynamic-shortest-path">Example2([CF843D]Dynamic
Shortest Path)</a></li>
<li><a href="#example3-同余最短路luogup2371墨墨的等式">Example3
同余最短路([luoguP2371]墨墨的等式)</a></li>
</ul></li>
<li><a href="#差分约束">差分约束</a>
<ul>
<li><a href="#example1agc056c-01-balanced">Example1([AGC056C] 01
Balanced)</a></li>
</ul></li>
<li><a href="#2-sat">2-SAT</a>
<ul>
<li><a href="#example1cf1697f">Example1(CF1697F)</a></li>
<li><a href="#example22021集训队互测-序列">Example2(2021集训队互测
序列)</a></li>
</ul></li>
<li><a href="#对偶图">对偶图</a>
<ul>
<li><a href="#example1csp-s-2021-交通规划">Example1([CSP-S 2021]
交通规划)</a></li>
</ul></li>
<li><a href="#广义串并联图三度化">广义串并联图/三度化</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#删一度点">删一度点</a></li>
<li><a href="#缩二度点">缩二度点</a></li>
<li><a href="#叠合重边">叠合重边</a></li>
<li><a href="#正确性证明">正确性证明</a>
<ul>
<li><a href="#引理1">引理1</a></li>
<li><a href="#引理2">引理2</a></li>
<li><a href="#引理3">引理3</a></li>
</ul></li>
<li><a href="#example122zr提高十连测day6摆件">Example1(22zr提高十连测day6摆件)</a></li>
<li><a href="#example2joi-open-2022-放学路">Example2([JOI Open 2022]
放学路)</a></li>
</ul></li>
<li><a href="#点分治">点分治</a>
<ul>
<li><a href="#example1cfgym101002k">Example1(CFgym101002K)</a></li>
<li><a href="#点分树的性质">点分树的性质</a>
<ul>
<li><a href="#example1codechef-btree">Example1(codechef
[BTREE])</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
</ul></li>
<li><a href="#边分治">边分治</a>
<ul>
<li><a href="#边分树的性质">边分树的性质</a></li>
</ul></li>
<li><a href="#二分图">二分图</a>
<ul>
<li><a href="#定理">定理</a>
<ul>
<li><a href="#最大流-最小割定理">最大流-最小割定理</a></li>
<li><a href="#hall定理">Hall定理</a></li>
<li><a href="#vizing定理">Vizing定理</a></li>
</ul></li>
<li><a href="#二分图最大权匹配">二分图最大权匹配</a></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example1-xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489-bpoint-pairs">Example1([
XVII Open Cup named after E.V. Pankratiev. Grand Prix of
Japan(openstrain contest 1489) B]Point Pairs)</a></li>
<li><a href="#example1luogup4313-文理分科">Example1(luoguP4313
文理分科)</a></li>
<li><a href="#example2hnoi2013切糕">Example2([HNOI2013]切糕)</a></li>
<li><a href="#example3uoj704">Example3(uoj704)</a></li>
<li><a href="#example1cf1404e">Example1(CF1404E)</a></li>
<li><a href="#example1luogup4177">Example1(luoguP4177)</a></li>
<li><a href="#example1网络流24题魔术球问题">Example1([网络流24题]魔术球问题)</a></li>
</ul></li>
<li><a href="#最长反链">最长反链</a>
<ul>
<li><a href="#example1cf1630fmaking-it-bipartite">Example1([CF1630F]Making It
Bipartite)</a></li>
</ul></li>
<li><a href="#最小费用任意流">最小费用任意流</a>
<ul>
<li>[Example1(luoguP4694 <a href="#example1luogup4694-pa2013raper">PA2013]Raper)</a></li>
</ul></li>
<li><a href="#负费用最小流">负费用最小流</a></li>
<li><a href="#有负环的费用流">有负环的费用流</a></li>
<li><a href="#模拟费用流">模拟费用流</a>
<ul>
<li>[Example1(luoguP4694 <a href="#example1luogup4694-pa2013raper-1">PA2013]Raper)</a></li>
</ul></li>
<li><a href="#散题">散题</a>
<ul>
<li><a href="#example1cqoi2014危桥">Example1([CQOI2014]危桥)</a></li>
</ul></li>
<li><a href="#prufer序列的矩阵树定理理解">Prufer序列的矩阵树定理理解</a></li>
<li><a href="#格路计数问题">格路计数问题</a>
<ul>
<li><a href="#定义-1">定义</a></li>
<li><a href="#定理-1">定理</a></li>
</ul></li>
<li><a href="#散模型">散模型</a>
<ul>
<li><a href="#多叉堆计数">多叉堆计数</a>
<ul>
<li><a href="#example1agc060c-large-heap">Example1([AGC060C] Large
Heap)</a></li>
<li><a href="#example2heoi2013sao">Example2([HEOI2013]SAO)</a></li>
</ul></li>
<li><a href="#三元环计数">三元环计数</a></li>
<li><a href="#四元环计数">四元环计数</a></li>
<li><a href="#有标号dag计数">有标号DAG计数</a>
<ul>
<li><a href="#example1qoj5749">Example1(qoj5749)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="约定">约定</span></h3>
<p><span class="math inline">\(K_n\)</span>为<span class="math inline">\(n\)</span>个点的完全图</p>
<h3><span id="树的性质">树的性质</span></h3>
<p>#####Example1([HDU6035]Colorful Tree)</p>
<p>考虑每种颜色的贡献,一种颜色的贡献显然是删去所有这个颜色的边后,剩下的联通块之间的路径.</p>
<p>#####Example2([2022qbxt国庆Day1]tree)</p>
<p>首先考虑分开处理每个点,在做每个点的时候假设它的所有子节点全部已经满足条件了,最终我们再通过计算组合数的方式计算即可.</p>
<p>那么最后,我们需要对于每个点进行处理,假设我们已知这个子树的集合是<span class="math inline">\(S\)</span>,那么我们需要用容斥计算如果当前子树集合是<span class="math inline">\(S\)</span>的子集的情况,不难发现容斥式子: <span class="math display">\[
ans=\sum_{k=\max\{f_v|x\rightarrow
v\}}^{f_x}(-1)^{f_x-k}k\binom{f_x}{k}\sum_{x\rightarrow v}\binom{k}{f_v}
\]</span> 其实也就是个二项式反演的形式.</p>
<p>这题还需要一些技巧优化,我们首先发现由于<span class="math inline">\(f_v\)</span>有可能有重复的,我们可以提前把重复的<span class="math inline">\(f_v\)</span>压缩到一起再用快速幂求,于是后面的部分最多不过<span class="math inline">\(\sqrt{n}\)</span>级别.而前面是一个类似于树上启发式合并的东西,于是复杂度<span class="math inline">\(O(n\sqrt{n}\log n)\)</span>.</p>
<h5><span id="example3cf1628egroceries-in-meteor-town">Example3(CF1628E
Groceries in Meteor Town)</span></h5>
<p>因为要求路径最大值,所以先建Kruskal重构树.然后问题转化为求一个点和一群白点的LCA是谁.</p>
<p>树上多点LCA有个经典性质:也就相当于其中<span class="math inline">\(dfn\)</span>序最大的和最小的两个点的LCA.</p>
<p>至于区间覆盖可以用线段树.</p>
<h5><span id="example4loj3692">Example4(loj3692)</span></h5>
<p>注意到<span class="math inline">\(D\)</span>很小.</p>
<p>我们考虑处理邻域乘,设<span class="math inline">\(f_{x,i}\)</span>表示<span class="math inline">\(x\)</span>的<span class="math inline">\(i\)</span>级儿子需要乘上的答案.每次修改时,先将<span class="math inline">\(f_{x,D}\)</span>和<span class="math inline">\(f_{x,D-1}\)</span>乘上<span class="math inline">\(W\)</span>,然后令<span class="math inline">\(x=fa_x\)</span>,<span class="math inline">\(D=D-2\)</span>,继续此操作直到<span class="math inline">\(D\)</span>为<span class="math inline">\(0\)</span>.</p>
<p>然后询问的时候直接暴力跳<span class="math inline">\(D\)</span>层父亲找答案,不难发现这样做是对的.</p>
<p>同样的思路可以脱离点分治处理很多邻域问题.</p>
<h4><span id="树的直径">树的直径</span></h4>
<ol type="1">
<li>定义:树中最长的一条简单路径.</li>
<li>树的直径可能有多个.</li>
<li>直径的两个端点一定是两个叶子节点.</li>
<li>如果树有多条直径,树的不同的直径的中点/中边一定是相同的.</li>
<li>到一个点距离最远的点一定是直径的一个端点.</li>
<li>对于两棵树,如果第一棵树直径两端点为<span class="math inline">\((u,v)\)</span>,第二棵树直径两端点为<span class="math inline">\((x,y)\)</span>,用一条边将两棵树连接,那么新树的直径一定是<span class="math inline">\(u,v,x,y\)</span>中的两个点.</li>
</ol>
<p>上述的证明大都是考虑反证法:如果不成立,则一定存在一条更长的直径.</p>
<h5><span id="example1sdoi2013直径">Example1([SDOI2013]直径)</span></h5>
<p>有一个做法是:考虑找到直径的中点/中边,找到它到两边的最远距离的点,显然两边的点分别的以中点/中边的两个端点为根的LCA中间的部分就是一定会被包含的边.</p>
<h4><span id="树的重心">树的重心</span></h4>
<ol type="1">
<li>定义:树的重心是删去后所有剩余子树大小最大值最小的点.</li>
<li>树的重心是删去后所有剩余子树大小全部小于等于<span class="math inline">\(\lfloor\cfrac{n}{2}\rfloor\)</span>的点.</li>
<li>树的重心只有可能有一个或两个.</li>
<li>如果树有两个重心,那么这两个重心相邻.</li>
<li>树的重心是所有点到其距离之和最小的点.</li>
<li>把一个树添加或删除一个叶子,那么它的重心最多只移动一条边的距离.</li>
<li>把两个树通过一条边相连得到一个新的树,那么新的树的重心在连接原来两个树的重心的路径上.</li>
</ol>
<p>(2)的证明如下:</p>
<p>如果重心是<span class="math inline">\(u\)</span>,且删去<span class="math inline">\(u\)</span>后剩余最大子树大小大于<span class="math inline">\(\lfloor\cfrac{n}{2}\rfloor\)</span>,设这棵子树中与<span class="math inline">\(u\)</span>相邻的点为<span class="math inline">\(v\)</span>,则我们删去<span class="math inline">\(v\)</span>后,最大子树大小一定会减少,不满足假设,所以(2)得证.</p>
<p>另外,如果一个点删去后所有剩余子树大小全部小于等于<span class="math inline">\(\lfloor\cfrac{n}{2}\rfloor\)</span>,那它也一定是重心.因为不存在除了重心以外的满足条件的点:考虑调整法,与重心相邻的点一定都不满足条件,因为它们的子树大小全都小于等于<span class="math inline">\(\lfloor\cfrac{n}{2}\rfloor\)</span>,移动后最大子树一定不小于<span class="math inline">\(n-\lfloor\cfrac{n}{2}\rfloor\)</span>.</p>
<p>(3)(4)的证明如下:</p>
<p>首先证明:如果有两个点都是重心,那它们一定相邻.</p>
<p>考虑如果二者不相邻,那删去它们后剩下的最大子树大小一定相等,设这两个点分别为<span class="math inline">\(x,y\)</span>,那删去<span class="math inline">\(x\)</span>后,剩下的最大子树一定包含了<span class="math inline">\(y\)</span>,而这个子树的大小一定小于等于<span class="math inline">\(\lfloor\cfrac{n}{2}\rfloor\)</span>.那删去<span class="math inline">\(y\)</span>后,剩下的最大子树大小必定大于<span class="math inline">\(\lfloor\cfrac{n}{2}\rfloor\)</span>,一定不合法.</p>
<p>而树上不可能有超过两个点两两相邻,于是最多只有两个重心,且它们一定相邻.</p>
<p>(5)的证明如下:</p>
<p>考虑如果<span class="math inline">\(u\)</span>是树的重心,我们看能不能将<span class="math inline">\(u\)</span>调整到另一个点使得所有点到其距离之和更小.</p>
<p>由于调整是一步一步做的,显然只需要判断所有和<span class="math inline">\(u\)</span>相邻的点是否符合条件即可.设这个点为<span class="math inline">\(x\)</span>,那我们把<span class="math inline">\(u\)</span>改为<span class="math inline">\(x\)</span>,会使答案减小<span class="math inline">\(siz_x\)</span>,增加<span class="math inline">\(n-siz_x\)</span>,由于<span class="math inline">\(siz_x\leq
\lfloor\cfrac{n}{2}\rfloor\)</span>,所以这么做一定不优.</p>
<p>(6)的证明如下:</p>
<p>首先,如果加入一个叶子节点后,各个子树大小仍然都<span class="math inline">\(&lt;
\lfloor\cfrac{n}{2}\rfloor\)</span>,那显然不必调整.</p>
<p>不然,显然是往叶子节点移动一格或者加入一个相邻的重心.</p>
<p>(7)的证明如下:</p>
<p>不妨设两棵树大小分别为<span class="math inline">\(siz_a\leq
siz_b\)</span>,然后令相连的两个点是这两棵树的根.</p>
<p>对于<span class="math inline">\(b\)</span>中的重心,肯定是会往根跳,并且不可能跳出<span class="math inline">\(b\)</span>原本的树.</p>
<h5><span id="example1csp-s2019树的重心">Example1([CSP-S2019]树的重心)</span></h5>
<p>首先取重心<span class="math inline">\(rt\)</span>为根,如果有两个就随便取一个.</p>
<p>接下来我们考虑对于每个点<span class="math inline">\(x\)</span>,它在什么情况下会成为重心.首先,删掉的边不可能在<span class="math inline">\(x\)</span>的子树内,不然一定不可能取到<span class="math inline">\(x\)</span>的.然后,我们假设删掉的子树大小为<span class="math inline">\(S\)</span>,<span class="math inline">\(x\)</span>的子树内最大的一个子树大小为<span class="math inline">\(g_x\)</span>,那么根据重心的性质有: <span class="math display">\[
2(n-S-siz_x)\leq n-S\\
2g_x\leq n-S\\
\]</span> 整理得到: <span class="math display">\[
2g_x\leq n-S\leq 2siz_x
\]</span> 考虑这个怎么计算:如果没有删边必须在<span class="math inline">\(x\)</span>子树外的限制,那显然可以直接遍历一遍存下<span class="math inline">\(n-S\)</span>,然后统一使用值域树状数组做.而我们接下来考虑删去<span class="math inline">\(x\)</span>子树内的贡献,类似colorful
tree的做法,每次dfs到一个点,记录下来当前树状数组的答案,然后dfs子树,回溯时拿新答案减去旧答案就是子树内的答案.</p>
<p>接下来我们需要考虑<span class="math inline">\(x=rt\)</span>怎么做.</p>
<p>考虑<span class="math inline">\(x\)</span>的子树中最大的那个和次大的那个,如果我们删去的节点不在最大的子树中,那只需要保证最大的子树大小满足条件;不然,只需保证次大的子树大小满足条件,也是好维护的.</p>
<h4><span id="树的结构的维护">树的结构的维护</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定一棵树,树上点有点权<span class="math inline">\(val\)</span>.现在有一个值<span class="math inline">\(sum\)</span>,初始为<span class="math inline">\(0\)</span>.从<span class="math inline">\(1\)</span>号点出发,每第一次到一个点<span class="math inline">\(u\)</span>,就会使<span class="math inline">\(sum+=val_u\)</span>.求在时刻保证<span class="math inline">\(sum\geq 0\)</span>的前提下,<span class="math inline">\(sum\)</span>最终的最大值.</p>
<p>首先注意到为了保证<span class="math inline">\(sum\geq
0\)</span>这个性质,一个节点应该有两个值:<span class="math inline">\(lim\)</span>表示能走到这个点所需要的最小的<span class="math inline">\(sum\)</span>,<span class="math inline">\(val\)</span>表示到了这个点后能获得的价值.显然如果<span class="math inline">\(val\leq 0\)</span>则无意义.</p>
<p>如果我们能一开始处理出根的所有儿子的<span class="math inline">\(lim\)</span>和<span class="math inline">\(val\)</span>,我们就可以使用先走<span class="math inline">\(lim\)</span>小的点,并不断累计<span class="math inline">\(sum\)</span>的方式做.</p>
<p>所以考虑不断向上合并信息.不难发现此时一个点要处理出多对<span class="math inline">\((lim,val)\)</span>.考虑用一个左偏树维护这个东西.</p>
<p>但是,我们还需要保证不能跳着选点.也就是说我们要保证选中一个点,这个点的父亲必须选,怎么办呢?</p>
<p>一个方式是,我们把排序方法从只看<span class="math inline">\(lim\)</span>变成先判是否存在祖先后代关系,再判断<span class="math inline">\(lim\)</span>.</p>
<p>另一个方式是,我们每次直接把当前子树根节点扔到堆顶.但是需要满足堆的性质.不难发现如果这个点<span class="math inline">\(val&lt;0\)</span>,我们可以将它与下面的<span class="math inline">\(lim\)</span>最的节点合并直到这个点<span class="math inline">\(val\geq 0\)</span>.而如果这个点的<span class="math inline">\(lim\)</span>太大,我们同样可以合并.注意到这样我们采取了一种很聪明的方式维护了树的形态.</p>
<h4><span id="dfs树的性质">dfs树的性质</span></h4>
<h5><span id="example1cf1361ejames-andthe-chase">Example1([CF1361E]James and
the Chase)</span></h5>
<p>如何判断一个点是否是好的呢?首先,如果要求是任意路径,那一个点是好的当且仅当它是一个叶向有根树的根.</p>
<p>现在要求是简单路径,那也就是说如果走了重复点是可以忽略的,这也就是说这个叶向有根树可以有反走边,而显然不能有横插边.不难发现这是充要条件.</p>
<p>另一个问题是:如何快速判断一个点是否满足上述条件呢?首先我们求出以一个好的点为根的dfs树(随机选取一定数量的点,如果一个都不是好点直接输出<span class="math inline">\(-1\)</span>),然后我们发现:一个点<span class="math inline">\(u\)</span>是好的必要条件是它的子树内只有一条反走边,证明显然.假设<span class="math inline">\(u\)</span>通过这条反走边走到了点<span class="math inline">\(v\)</span>,那么<span class="math inline">\(u\)</span>是好的点当且仅当<span class="math inline">\(v\)</span>也是好的点.</p>
<p>这是为啥呢?首先,因为我们是以一个好点为根跑的dfs树,所以<span class="math inline">\(u\)</span>走到子树内的点必定只有一种方式.那子树外的点呢?走到<span class="math inline">\(v\)</span>后,显然就要从它走到其它点,而它到<span class="math inline">\(u\)</span>的子树内显然只有一种方案,那如果<span class="math inline">\(v\)</span>到其它点也只有一种方案,那么根据<span class="math inline">\(u\rightarrow v\)</span>这条路径,<span class="math inline">\(u\)</span>显然也是好点.</p>
<h5><span id="example2loj-6276">Example2(Loj 6276)</span></h5>
<p>找到所有颜色相同的点对<span class="math inline">\((x,y)\)</span>,经过它们的路径都不合法,显然经过它们的路径可以用dfs序刻画成矩阵,最后要求矩阵面积并.</p>
<h3><span id="圆方树的性质">圆方树的性质</span></h3>
<ol type="1">
<li>对于任意的非空无向图<span class="math inline">\(G\)</span>,一定存在一个<span class="math inline">\(G\)</span>的点双连通分量<span class="math inline">\(B\)</span>,使得<span class="math inline">\(B\)</span>中只有不超过<span class="math inline">\(1\)</span>个节点是<span class="math inline">\(G\)</span>的割点.其中,若<span class="math inline">\(B\)</span>中没有<span class="math inline">\(G\)</span>的割点,则有<span class="math inline">\(B=G\)</span>.</li>
<li>若一个点双连通分量不为<span class="math inline">\(K_2\)</span>,则该点双连通分量中至少有一个简单环.</li>
<li>在仙人掌上的每个点双连通分量要么是<span class="math inline">\(K_2\)</span>,要么是一个简单环.</li>
<li>对于一个不是<span class="math inline">\(K_2\)</span>的点双连通分量中的任意一个点<span class="math inline">\(u\)</span>,一定存在一个简单环<span class="math inline">\(C\)</span>使得<span class="math inline">\(u\)</span>在<span class="math inline">\(C\)</span>上.</li>
<li>对于一个不是<span class="math inline">\(K_2\)</span>的点双连通分量中的任意两个点<span class="math inline">\(u,v\)</span>,一定存在一个简单环<span class="math inline">\(C\)</span>使得<span class="math inline">\(u,v\)</span>在<span class="math inline">\(C\)</span>上.</li>
<li>对于一个不是<span class="math inline">\(K_2\)</span>的点双,任给一点<span class="math inline">\(x\)</span>和一边<span class="math inline">\(e\)</span>,一定存在经过<span class="math inline">\(x,e\)</span>的简单环.</li>
<li>对于一个不是<span class="math inline">\(K_2\)</span>的点双,任给两点<span class="math inline">\(s,t\)</span>和一边<span class="math inline">\(e\)</span>,一定存在一条<span class="math inline">\(s-e-t\)</span>的简单路径.</li>
</ol>
<p>(6)的证明非常变魔术,你考虑把<span class="math inline">\(e:u\leftrightarrow v\)</span>这条边给改成<span class="math inline">\(u\leftrightarrow w\leftrightarrow
v\)</span>,然后<span class="math inline">\(w\)</span>和<span class="math inline">\(x\)</span>在一个简单环上,意味着<span class="math inline">\(u,w,v,x\)</span>在一个简单环上.</p>
<p>(7)考虑(6)就行,先找到<span class="math inline">\(s\)</span>和<span class="math inline">\(e\)</span>所在的简单环,然后从这个环上连到<span class="math inline">\(t\)</span>.</p>
<h3><span id="任意图的性质">任意图的性质</span></h3>
<ol type="1">
<li>若一张无向连通图<span class="math inline">\(G\)</span>中存在<span class="math inline">\(3\)</span>个不同的一度点<span class="math inline">\(x, y,z\)</span>,则一定存在一个点<span class="math inline">\(u\notin\{x,y,z\}\)</span>使得存在<span class="math inline">\(3\)</span>条两两没有公共边的简单路径满足其中一个端点均为<span class="math inline">\(u\)</span> 且另一个端点分别为<span class="math inline">\(x,y,z\)</span>.(证明考虑求生成树后讨论LCA)</li>
</ol>
<h3><span id="dsu-on-tree">dsu on tree</span></h3>
<h5><span id="exampleqoj5020">Example(QOJ5020)</span></h5>
<p>我们考虑树链剖分,这样将问题转化为三部分:</p>
<ol type="1">
<li>对于某个点而言,到它距离<span class="math inline">\(\leq
d\)</span>的点数量.这个问题可以使用点分治解决.</li>
<li>对于某条重链的上半部分而言,它连接的所有轻子树中,到它距离<span class="math inline">\(\leq d\)</span>的点数量.这个问题直接dsu on
tree.</li>
<li>对于某个点而言,在它子树内到它距离<span class="math inline">\(\leq
d\)</span>的点数量.这个问题也可以直接dsu on tree.</li>
</ol>
<p>为什么转化为三个部分就能求解呢?我们考虑一条链<span class="math inline">\(u\rightarrow w\rightarrow v\)</span>,其中<span class="math inline">\(w\)</span>是这条链上深度最浅的点.那么首先我们统计在<span class="math inline">\(w\)</span>子树外的,这一个部分可以由(1)和(3)做差求出来.然后我们要求的就是在<span class="math inline">\(w\)</span>子树内,到这条链的距离<span class="math inline">\(\leq
d\)</span>的点的数量.这个怎么求呢?我们考虑差分,求一下<span class="math inline">\(1\rightarrow u\)</span>和<span class="math inline">\(1\rightarrow
w\)</span>的答案然后做差.这样我们对这条到根的路径重链剖分,只需要处理重链的上半部分以及两条重链的连接处.不难发现两条重链的连接处会被多算一次,拿(3)减一下就好.以及这条路径所叉出去的重儿子也需要用(3).</p>
<p>现在的问题在于怎么求(2)和(3),先考虑(2),我们对于每一条重链从顶端走到低端不断地加入轻儿子,然后维护BIT就行.(3)是类似的,只不过是需要从底端走到顶端.</p>
<p>注意如果把重儿子和轻儿子分开处理,那么可能会在一些奇怪的地方算重,解决方法是特判<span class="math inline">\(w\)</span>处的答案,然后拆成两条互相之间完全没有影响的链,当然这也有可能会发生跳重链的时候轻儿子算重的情况,同样需要判断一下.</p>
<h3><span id="最小生成树">最小生成树</span></h3>
<h5><span id="example1cf1550f-jumpingaround">Example1(CF1550F Jumping
Around)</span></h5>
<p>首先考虑离线.注意到每次肯定跳到一个自己能跳到的点,而这个点应该是所需灵活度最小的点.</p>
<p>考虑boruvka算法,建立最小生成树并判断.</p>
<h3><span id="kruskal重构树">Kruskal重构树</span></h3>
<p>最小生成树时,每一次加边的时候把那个边变成虚点,两个点连到这条边上.任意两个点的LCA就是它们路径上的最小边权.</p>
<h3><span id="最短路">最短路</span></h3>
<h5><span id="example1cf1753d-the-beach">Example1(CF1753D The Beach)</span></h5>
<p>首先,自然的想法是把格子图黑白染色.</p>
<p>然后,我们注意到一个床是不可能被移动两次及以上的.因为如果是横着动两次,那不动自然就有一对空位置了;如果是转两次,考虑转的目的一定是为了空出某个位置或某两个位置(不可能为了空出三个位置,显然这么做很闲),一次操作足矣;如果是动一次转一次也是一样的,要么转的很闲要么原本就存在这么一对空位置.</p>
<p>我们再进行一步转化,考虑把动床改为动格子.换句话说,每个格子可以通过一定的代价移动到和它相邻的床的与它不相邻的那个位置上.注意到移动格子的过程只会把黑格子移动到黑格子,白格子移动到白格子.</p>
<p>于是建立超级源点跑两边最短路,枚举最后床放在哪里即可.不过这里有一点是一个床有没有可能被黑白最短路同时跑了一遍,是有可能的,但这么跑一定不优秀,不可能是最小答案.</p>
<h5><span id="example2cf843ddynamicshortest-path">Example2([CF843D]Dynamic
Shortest Path)</span></h5>
<p>注意到<span class="math inline">\(O(nq)\)</span>能过.而且每次修改只是对于若干条边<span class="math inline">\(+1\)</span>,自然想到每次修改完后跑01bfs.</p>
<p>但是怎么跑呢?注意到维护每个点最短路的增量,并且在路径的增量上跑01bfs,自然可求.</p>
<h5><span id="example3同余最短路luogup2371墨墨的等式">Example3
同余最短路([luoguP2371]墨墨的等式)</span></h5>
<p>因为<span class="math inline">\(a_i\)</span>无序,假设<span class="math inline">\(a_1\)</span>最小,那么所有的数字都可以按<span class="math inline">\(\mod a_1\)</span>的结果分成<span class="math inline">\(a_1\)</span>类.我们按照余数设置<span class="math inline">\(a_1\)</span>个点,编号为<span class="math inline">\(0\)</span>至<span class="math inline">\(a_1-1\)</span>.</p>
<p>设<span class="math inline">\(dis_i\)</span>为所有能组成的数中且<span class="math inline">\(\mod a_1\)</span>余数为<span class="math inline">\(i\)</span>的最小数.那么,所有能表示出来的<span class="math inline">\(\bmod a_1\)</span>余数为<span class="math inline">\(i\)</span>的数都可以写作<span class="math inline">\(dis_i+k\times a_1,k\in
\mathbb{N}\)</span>的形式,求得<span class="math inline">\(dis_i\)</span>后可以很轻易算出.</p>
<p>那么怎么求<span class="math inline">\(dis_i\)</span>呢?我们考虑:对于任意一个数<span class="math inline">\(k\)</span>,它可以怎么得到.注意到如果<span class="math inline">\(k-a_j\)</span>(其中<span class="math inline">\(i\ne j\)</span>)可行,那么<span class="math inline">\(k\)</span>一定可行.自然有:<span class="math inline">\(dis_i=\min\{dis_j+a_k|0\leq j&lt; a_i,k\ne
i\}\)</span>.</p>
<p>这显然是一个最短路问题.</p>
<h3><span id="差分约束">差分约束</span></h3>
<h5><span id="example1agc056c-01balanced">Example1([AGC056C] 01
Balanced)</span></h5>
<p>将<span class="math inline">\(1\)</span>看成<span class="math inline">\(-1\)</span>,<span class="math inline">\(0\)</span>看成<span class="math inline">\(+1\)</span>,不难发现字典序最小也就是让前缀和序列字典序最小,并且有<span class="math inline">\(sum_{r_i}=sum_{l_i-1}\)</span>以及<span class="math inline">\(-1\leq sum_{i}-sum_{i-1}\leq
1\)</span>,然后做<span class="math inline">\(01\)</span>bfs跑最短路,显然最短路可以保证每个<span class="math inline">\(sum\)</span>都尽可能小.</p>
<p>然后另一个问题在于这玩意为啥不会让<span class="math inline">\(sum_i=sum_{i-1}\)</span>,这个建图后观察一下就知道不会发生这种情况.</p>
<h3><span id="2-sat">2-SAT</span></h3>
<h5><span id="example1cf1697f">Example1(CF1697F)</span></h5>
<p>对每个点建立<span class="math inline">\(k\)</span>对点表示<span class="math inline">\(a_i\geq x\)</span>和<span class="math inline">\(a_i&lt;x\)</span>,就能做了.</p>
<h5><span id="example22021集训队互测-序列">Example2(2021集训队互测 序列)</span></h5>
<p>注意到如果<span class="math inline">\(a_i&lt;x\)</span>,那么<span class="math inline">\(a_j\geq x\and a_k\geq
x\)</span>,这样就可以刻画所有的条件.</p>
<p>而且一定可以刻画所有的条件.</p>
<h3><span id="对偶图">对偶图</span></h3>
<h5><span id="example1csp-s-2021交通规划">Example1([CSP-S 2021]
交通规划)</span></h5>
<p>先考虑如果附加点的颜色全都相同,那肯定输出<span class="math inline">\(0\)</span>即可.</p>
<p>考虑附加点的数量为<span class="math inline">\(2\)</span>的时候,那显然最优情况需要将整个图分成各自联通的两部分,一部分染成黑色,一部分染成白色.可以发现这就是一个对偶图.</p>
<p>而如果附加点的数量很多怎么做呢?稍微思考一下</p>
<h3><span id="广义串并联图三度化">广义串并联图/三度化</span></h3>
<h4><span id="定义">定义</span></h4>
<p>定义:不存在<span class="math inline">\(4\)</span>个点使得任意两点之间存在一条简单路径,且这六条路径不在<span class="math inline">\(4\)</span>个点之外的地方相交.</p>
<h4><span id="删一度点">删一度点</span></h4>
<p>经典问题引入:树上带权最大独立集.</p>
<p>首先dp是可以实现的,我们考虑是否存在贪心算法.</p>
<p>首先,如果不带权,我们显然可以每次选取一度点或零度点,并删去所有相连的点.这样做显然是最优的.</p>
<p>但怎么做带权的方法呢?我们注意到可以先删掉所有负点权的点,然后可以加入剩下的所有零度点.</p>
<p>那么对于一度点呢?对于一个一度点<span class="math inline">\(u\)</span>和它的相邻点<span class="math inline">\(v\)</span>,我们不能盲目选<span class="math inline">\(u\)</span>的原因是可能选取<span class="math inline">\(v\)</span>会更优秀.考虑做一个带悔贪心,我们先把<span class="math inline">\(u\)</span>选上,然后把<span class="math inline">\(v\)</span>的权值设为<span class="math inline">\(val_v-val_u\)</span>,相当于我们仍然可以选<span class="math inline">\(v\)</span>,但是要花费<span class="math inline">\(val_u\)</span>的代价把<span class="math inline">\(u\)</span>删去.</p>
<p>我们把类似这样的操作称为<strong>删一度点</strong>.</p>
<h4><span id="缩二度点">缩二度点</span></h4>
<p>问题引入:给定一个仙人掌,每个点可以染色为<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>,<span class="math inline">\(u\)</span>节点染成<span class="math inline">\(0\)</span>会有<span class="math inline">\(b_u\)</span>的贡献,不然有<span class="math inline">\(w_u\)</span>的贡献.若一条边<span class="math inline">\(e\)</span>相邻的两点颜色相同则有<span class="math inline">\(s_e\)</span>的贡献,不然有<span class="math inline">\(d_e\)</span>的贡献,求最大答案.</p>
<p>首先如果有一度点和零度点,我们仍然可以使用删一度点的操作.</p>
<p>如果没有,考虑仙人掌上的一个点双一定是一个简单环.而且一定存在一个点双<span class="math inline">\(B\)</span>满足<span class="math inline">\(B\)</span>只包含一个割点.</p>
<p>那么对于这个点双上的一个非割点<span class="math inline">\(x\)</span>以及和它相邻的两个点<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>,我们考虑<span class="math inline">\(x\)</span>的染色有可能改变<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的答案,那么怎么办呢?</p>
<p>冷静思考一下,我们想办法把<span class="math inline">\(x\)</span>给删掉.简单来说,我们把<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>之间连一条边权为<span class="math inline">\([w_{0,0},w_{0,1},w_{1,0},w_{1,1}]\)</span>的边,分别表示<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的染色为以上四种情况时这条边(也就是原本的<span class="math inline">\(x\)</span>)的最大贡献是什么,这显然可以通过讨论<span class="math inline">\(x\)</span>的取值而求得.这样初始边权实际上就是<span class="math inline">\([s,d,d,s]\)</span>,于是我们就可以删掉一个二度点并连起来与它相邻的两个点,我们把类似这样的操作称为<strong>缩二度点</strong>.</p>
<h4><span id="叠合重边">叠合重边</span></h4>
<p>注意到使用缩二度点的时候,会把一个三元环缩成两个点及链接它们的两条重边,但是我们可以直接把重边合起来,我们把类似这样的操作称为<strong>叠合重边</strong>.</p>
<h4><span id="正确性证明">正确性证明</span></h4>
<p>接下来我们证明:任何广义串并联图都可以通过以上三种操作缩为一个点.</p>
<h5><span id="引理1">引理1</span></h5>
<p>对于一个无向图<span class="math inline">\(G\)</span>,若进行若干次删一度点操作,缩<span class="math inline">\(2\)</span>度点操作以及叠合重边操作后得到的图不是广义串并联图,那么<span class="math inline">\(G\)</span>也不是广义串并联图.</p>
<p>考虑用逆操作还原原图.删一度点的逆操作是加入一个点,叠合重边的逆操作是将一条边变成两条边,这两个操作显然不会使一个不是广义串并联图的图变成广义串并联图.接下来考虑缩二度点的逆操作:删掉一条边<span class="math inline">\((u,v)\)</span>并加入一个点<span class="math inline">\(w\)</span>和两条边<span class="math inline">\((u,w)\)</span>和<span class="math inline">\((w,v)\)</span>.</p>
<p>由于这个图不是广义串并联图,所以一定存在一组反例点<span class="math inline">\(\{a,b,c,d\}\)</span>.如果我们删掉的边不在作为反例的六条边上,那显然不影响;如果在,由于新加入的两条边仍然可以作为路径,所以也不影响.</p>
<p>于是引理得证.</p>
<h5><span id="引理2">引理2</span></h5>
<p>任意一张所有点的度数都大于等于<span class="math inline">\(3\)</span>的简单无向连通图,一定不是广义串并联图.</p>
<p>这个引理的严格证明有些麻烦.我们冷静一下,一个四个点的完全图满足以上条件且不是广义串并联图.而其他的图感性理解一下应该可以通过缩路径的方式变成一个四个点的完全图.</p>
<p>结合引理1,我们得知任意一个操作后不能变成单个节点的图的无向连通图不是广义串并联图.</p>
<h5><span id="引理3">引理3</span></h5>
<p>任意一个满足<span class="math inline">\(m\leq
n+k\)</span>的图,通过删一度点,缩二度点,叠合重边操作后,<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都会到达一个<span class="math inline">\(O(k)\)</span>的量级.</p>
<p>考虑缩完点后,所有点的度数<span class="math inline">\(\geq
3\)</span>,于是有<span class="math inline">\(2m\geq
3n\)</span>,而在操作过程中,<span class="math inline">\(m-n\)</span>的值显然是不增的,于是有<span class="math inline">\(m-n\leq k\)</span>,解一下方程得到<span class="math inline">\(n\leq 2k,m\leq 3k\)</span>.</p>
<h4><span id="example122zr提高十连测day6摆件">Example1(22zr提高十连测day6摆件)</span></h4>
<p>首先考虑颜色之间没啥区别,所以对于一棵树来说,朴素的dp是可以的.</p>
<p>简单来说,设<span class="math inline">\(dp_i\)</span>表示第<span class="math inline">\(i\)</span>棵子树的答案.合并的时候考虑设<span class="math inline">\(f_v=\cfrac{1}{k}dp_vsam_e+\cfrac{k-1}{k}dp_vdif_e\)</span>,自然有<span class="math inline">\(dp_u=\prod_{u\rightarrow v}f_v\\\)</span>.</p>
<p>接下来考虑先随便找一棵生成树,然后暴力枚举多余的反走边的深度较低的叶子节点的颜色,再进行dp即可.</p>
<p>另外也可以缩点后做,不过对于这题没啥区别.</p>
<h4><span id="example2joi-open-2022放学路">Example2([JOI Open 2022]
放学路)</span></h4>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>在一个点双中,我们找到两个点<span class="math inline">\(u,v\)</span>,使得<span class="math inline">\(u\rightarrow v\)</span>,并且<span class="math inline">\(u\)</span>的出度至少是<span class="math inline">\(2\)</span>,<span class="math inline">\(v\)</span>的入度至少是<span class="math inline">\(2\)</span>,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为<span class="math inline">\(2\)</span>的点<span class="math inline">\(v\)</span>,找到它的入点<span class="math inline">\(u\)</span>,如果<span class="math inline">\(u\)</span>的出度不是<span class="math inline">\(2\)</span>,那么<span class="math inline">\(u\)</span>也是一个入度至少为<span class="math inline">\(2\)</span>的点.这样往前推一定至少能推到一个点(因为不可能<span class="math inline">\(S\)</span>贡献了俩入度).</p>
<p>如何保证<span class="math inline">\(S,T\)</span>在一个点双中呢?其实只需要添加一条边<span class="math inline">\((S,T,dis_{S\rightarrow
T})\)</span>就行了.显然加了后不会对答案产生影响.然后不在<span class="math inline">\(S,T\)</span>这个边双内的点也没有用了.</p>
<h3><span id="点分治">点分治</span></h3>
<h5><span id="example1cfgym101002k">Example1(CFgym101002K)</span></h5>
<p>点分治,假设当前分治重心是<span class="math inline">\(g\)</span>,将每个数缩成一个二元组<span class="math inline">\((w_i,d_i)\)</span>,所求就是<span class="math inline">\(w_iw_j+d_i+d_j\)</span>最小,直接排序做斜率优化.</p>
<h4><span id="点分树的性质">点分树的性质</span></h4>
<ol type="1">
<li>点分树的高度是<span class="math inline">\(O(\log
n)\)</span>级别.</li>
<li>两个点在原树上的路径一定经过其在点分树上的LCA.</li>
</ol>
<h5><span id="example1codechef-btree">Example1(codechef [BTREE])</span></h5>
<p>这题用到了一个经典套路:一个树形连通图的点数减去边数为<span class="math inline">\(1\)</span>,把虚树建出来,能到达一个点的守卫必然是一个树形连通图(虚树中原本没有守卫的点可以加个不同覆盖范围的守卫).于是我们只需要求出每个守卫能覆盖多少点以及两个守卫之间的那条路径能覆盖多少个点,前者用点分树轻松维护,后者的话找一下这条边上的某个满足条件的点就行.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树,现在在上面选定<span class="math inline">\(m\)</span>对不同的点,要求每对点的距离之和最大.</p>
<p>考虑如果确定了<span class="math inline">\(2m\)</span>个点,我们如何匹配他们.对每条边算贡献,假设这条边两侧分别有<span class="math inline">\(a,b\)</span>个点,那么这条边最大的贡献就是<span class="math inline">\(\min\{a,b\}\)</span>.不难发现这个上界可以取到,只需要取这<span class="math inline">\(2m\)</span>个点的带权重心,由于不存在绝对众数,所以直接两两匹配.枚举带权重心是啥,这样复杂度<span class="math inline">\(O(n^2)\)</span>.</p>
<p>那么怎么优化呢?我们注意到如果以一个点<span class="math inline">\(x\)</span>作为根,而它有一个儿子<span class="math inline">\(y\)</span>,<span class="math inline">\(y\)</span>的子树中选了少于<span class="math inline">\(m\)</span>个点,那么我们以<span class="math inline">\(y\)</span>为根一定是不优秀的,不然一开始就不可能只选少于<span class="math inline">\(m\)</span>个点,再考虑带权重心这个东西,上点分树.</p>
<p>具体来说,我们建立点分树,然后从点分树的根开始枚举带权重心,如果当前没有一棵子树选了<span class="math inline">\(m\)</span>个点,就停止,不然往选了<span class="math inline">\(m\)</span>个点的那棵子树走(如果有两个的话选第<span class="math inline">\(m\)</span>大更大的那个),这样就只会选取<span class="math inline">\(O(\log n)\)</span>个带权重心.</p>
<h3><span id="边分治">边分治</span></h3>
<p>需要建立虚点转二叉树.</p>
<h4><span id="边分树的性质">边分树的性质</span></h4>
<ol type="1">
<li>非叶子节点代表边,叶子节点代表点.</li>
<li>边分树的高度是<span class="math inline">\(O(\log
n)\)</span>级别.</li>
<li>边分树上每棵子树中的叶子节点一定联通.</li>
<li>是一棵完全二叉树.</li>
<li>两个点在原树上的路径一定经过其在边分树上的LCA所代表的边.</li>
</ol>
<h3><span id="二分图">二分图</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="最大流-最小割定理">最大流-最小割定理</span></h5>
<h5><span id="hall定理">Hall定理</span></h5>
<p>对于二分图<span class="math inline">\(\lang V_1,V_2,E\rang,|V_1|\leq
|V_2|\)</span>,那么该图存在完备匹配的充要条件是<span class="math inline">\(\forall Q\subseteq V_1,|Q|\leq
|N(Q)|\)</span>,其中<span class="math inline">\(N(Q)\)</span>指的是所有与<span class="math inline">\(Q\)</span>中点有边相连的点的集合.</p>
<p>必要性很显然,接下来说明充分性.设<span class="math inline">\(T\)</span>为最小点覆盖,也就是最大匹配的数量,再设<span class="math inline">\(M\)</span>为最大匹配,此时自然有: <span class="math display">\[
|M|=|T|=|T_1|+|T_2|\geq |T_1|+|N(V_1/T_1)|\geq |T_1|+|V_1/T_1|=|V_1|
\]</span> 显然<span class="math inline">\(|M|\leq
|V_1|\)</span>,于是<span class="math inline">\(|M|=|V_1|\)</span>.</p>
<p>另外,Hall定理有一个推论:正则二分图一定存在完美匹配.什么叫正则二分图,就是所有的点的度数(不为<span class="math inline">\(0\)</span>)都相等的图.</p>
<p><span class="math inline">\(2^d\)</span>-正则二分图求完美匹配的话,可以不断求欧拉回路并给边定向,每次把一个方向的边全都删掉,这样就转化成了<span class="math inline">\(2^{d-1}\)</span>-正则二分图,不断递归到<span class="math inline">\(d=0\)</span>.</p>
<h5><span id="vizing定理">Vizing定理</span></h5>
<p>设<span class="math inline">\(f(G)\)</span>表示将<span class="math inline">\(G\)</span>边染色,使得有公共点的边的颜色不同,最少需要的颜色数量.</p>
<p>设<span class="math inline">\(\delta(G)\)</span>表示<span class="math inline">\(G\)</span>中的点的最大度数.</p>
<p>对于一般图,我们有:<span class="math inline">\(\delta(G)\leq f(G)\leq
\delta(G)+1\)</span>,对于二分图有<span class="math inline">\(\delta(G)=f(G)\)</span>.</p>
<p>考虑这个的证明:我们每次将一对点<span class="math inline">\((x,y)\)</span>染色,考虑设它们当前没染色的最小的颜色是<span class="math inline">\(l_x,l_y(l_x\leq
l_y)\)</span>,如果相等就直接选,不然类似增广路更新.</p>
<h4><span id="二分图最大权匹配">二分图最大权匹配</span></h4>
<p>假定二分图两边两两有边(不是的话可以补上<span class="math inline">\(-\infty\)</span>的边),这样就一定存在完美匹配.</p>
<p>我们给每个点一个顶标权值<span class="math inline">\(v\)</span>,对于任意一条边<span class="math inline">\(e:a\leftrightarrow b\)</span>,它的权值是<span class="math inline">\(w_e\)</span>,我们要求<span class="math inline">\(v\)</span>满足<span class="math inline">\(v_a+v_b\geq w_e\)</span>.</p>
<p>如果我们规定了一组顶标后,取出所有满足<span class="math inline">\(v_a+v_b=w_e\)</span>的边后的图(称作相等子图)存在完美匹配,那这组完美匹配就一定是最大权匹配.</p>
<p>这是为啥呢?考虑此时的最大权其实也就是<span class="math inline">\(\sum
v\)</span>,而由于<span class="math inline">\(v_a+v_b\geq
w_e\)</span>,因此最大权匹配一定不会超过<span class="math inline">\(\sum
v\)</span>.这就是一个可达的上界.</p>
<p>那么我们该怎么得到一个相等子图呢?考虑先构造一组合法的顶标,让左部端点取边的最大值,右部端点取<span class="math inline">\(0\)</span>,然后开始增广.</p>
<p>从左侧任意一个非匹配点出发,在相等子图上走增广路并增广.如果增广失败,我们将访问过的左部端点全部减去<span class="math inline">\(d\)</span>,右部端点全部加上<span class="math inline">\(d\)</span>,注意到此时匹配边一定不会变化,因为匹配边要么两个端点都没被访问过,要么都被访问过.而左端点被访问过,右端点没被访问过的边有可能加入相等子图,我们考虑取所有这种边的需要的差值的最小值并进行更新.但是直接这么做的复杂度有点高.</p>
<p>使用bfs优化,可以发现只会扩大<span class="math inline">\(O(n^2)\)</span>次子图,每次复杂度<span class="math inline">\(O(n)\)</span>,增广的复杂度类似,于是总复杂度<span class="math inline">\(O(n^3)\)</span>.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-ofjapanopenstrain-contest-1489-bpoint-pairs">Example1([
XVII Open Cup named after E.V. Pankratiev. Grand Prix of
Japan(openstrain contest 1489) B]Point Pairs)</span></h5>
<p>看到这种要求横坐标或纵坐标相同的题,有一个自然的想法是建立二分图,对于点<span class="math inline">\((x,y)\)</span>,将二分图左边的<span class="math inline">\(x\)</span>和右边的<span class="math inline">\(y\)</span>连一条边.那么配对等价于要每次找两条相邻的边删掉.那么如何删掉呢?</p>
<p>首先发现的是,二分图不同的连通块可以分开处理,我们接下来只讨论一个连通块的情况.如果这个连通块有奇数条边,显然一定不行.而又可以发现,如果这个连通块有一个点度数仅为<span class="math inline">\(1\)</span>,那这条边如何删是确定的,我们可以把它和另一条边删掉,不难发现怎么删最后得到的新图仍然联通.而如果不存在度数为<span class="math inline">\(1\)</span>的点呢?由于这是一个二分图,不存在奇环,所以我们可以找一个简单环删掉,之后显然也是一个连通块.我们到这里就可以发现问题了.运用数学归纳不难证明:只要一个连通块的边数是偶数就一定合法.</p>
<p>然后我们可以使用可撤销的分治解决这个问题.</p>
<p>###网络流常见模型</p>
<p>####最大流</p>
<p>####最小费用最大流</p>
<p>####最小割</p>
<p>最大流<span class="math inline">\(=\)</span>最小割,证明显然.</p>
<p>最小割求方案。这个是简单的，我们删去所有流量<span class="math inline">\(0\)</span>的边后从<span class="math inline">\(S\)</span>开始bfs，找到所有<span class="math inline">\(S\)</span>能到达的点，显然这些点（注意如果这个点一开始就不能到达<span class="math inline">\(T\)</span>，那它是废物，不用管它，下面只讨论它能到达<span class="math inline">\(T\)</span>的情况）组成一个SCC（为啥呢？首先<span class="math inline">\(S\)</span>能到达它们，其次由于是最小割，因此这个点一定到达不了<span class="math inline">\(T\)</span>，而原本是可以到达<span class="math inline">\(T\)</span>的，假设这个点是<span class="math inline">\(x\)</span>，那么一定是原本存在一条<span class="math inline">\(S\rightarrow x\rightarrow
T\)</span>的路径被割掉了，也就是现在一定存在一条<span class="math inline">\(x\rightarrow
S\)</span>的路径）。最小割包含的边一定是这个集合和其它集合交界处的边。这是为啥呢？首先这些边一定组成了原图的一个割，其次，我们发现割不可能存在<span class="math inline">\(S\)</span>所在SCC中，而割掉完全不连接<span class="math inline">\(S\)</span>的边可以发现不如割其中一个点在<span class="math inline">\(S\)</span>所在SCC的边。</p>
<h5><span id="example1luogup4313-文理分科">Example1(luoguP4313 文理分科)</span></h5>
<p>先把所有的满意值全部吃下,然后考虑放弃哪些.</p>
<p>对于每个人<span class="math inline">\(u\)</span>,将<span class="math inline">\(S\)</span>向他连一条流量为<span class="math inline">\(art\)</span>的边,它向<span class="math inline">\(T\)</span>连一条为<span class="math inline">\(science\)</span>的边,表示它自己要么放弃文科,要么放弃理科.</p>
<p>然后再对每个点建立一个虚点<span class="math inline">\(u&#39;\)</span>,<span class="math inline">\(S\)</span>向<span class="math inline">\(u&#39;\)</span>连一条为<span class="math inline">\(sameart\)</span>的边,<span class="math inline">\(u&#39;\)</span>向相邻的实点连<span class="math inline">\(\infty\)</span>的边,表示要么放弃<span class="math inline">\(sameart\)</span>,要么那些点全都放弃理科.<span class="math inline">\(samescience\)</span>是同理的.</p>
<p>从这也可以看出来,大部分最小割的题目其实就是将冲突的选项放到一条路径中,然后考虑放弃哪些,将这个限制用最小割表示出来.</p>
<h5><span id="example2hnoi2013切糕">Example2([HNOI2013]切糕)</span></h5>
<p>也是显然的最小割,唯一难处理的地方在于相差<span class="math inline">\(\leq D\)</span>.</p>
<p>这个怎么做呢?建图后先每一竖轴都变成了一条链,我们在链之间加一些<span class="math inline">\(\infty\)</span>的边,使得如果断开的两个点之差大于<span class="math inline">\(D\)</span>,那就可以通过这条边破坏最小割结构.</p>
<p>这题同样告诉我们:对于最小割题目中的限制条件,几乎都是需要考虑破坏最小割结构的(也有可能是用费用流限制).</p>
<h5><span id="example3uoj704">Example3(uoj704)</span></h5>
<p>二分图最小割计数.</p>
<p>先求出最小割,然后显然每个匹配的三条边一定会选择一条割掉.</p>
<p>不妨设<span class="math inline">\(a_i=0/1/2\)</span>表示第<span class="math inline">\(i\)</span>对匹配割掉了哪一条边.</p>
<p>考虑每个非匹配边<span class="math inline">\((u,v)\)</span>对点权的限制:</p>
<ol type="1">
<li><span class="math inline">\(u\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(v\)</span>不在.则<span class="math inline">\(a_i=0\)</span>.</li>
<li><span class="math inline">\(v\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(u\)</span>不在,则<span class="math inline">\(a_i=2\)</span>.</li>
<li><span class="math inline">\(u\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(v\)</span>在最大匹配<span class="math inline">\(j\)</span>中,则<span class="math inline">\(a_i=0\)</span>或<span class="math inline">\(a_j=2\)</span>.</li>
</ol>
<p>前两种是好处理的,考虑第三种:显然所有都选<span class="math inline">\(2\)</span>或所有都选<span class="math inline">\(0\)</span>是一种方案,更进一步地,我们将<span class="math inline">\(i\rightarrow
j\)</span>,那么在一个强连通分量中的点一定都是<span class="math inline">\(2\)</span>或都是<span class="math inline">\(0\)</span>.这样可以缩点,缩点后发现DAG上的每一条路径的染色都形如<span class="math inline">\(0,0,0,\cdots,0,(1),2,\cdots ,2,2,2\)</span>.</p>
<p>不妨折半搜索,按照拓扑排序,确定前一半哪些是<span class="math inline">\(0\)</span>,剩下是<span class="math inline">\(1/2\)</span>,那他们的后继必然全都是<span class="math inline">\(2\)</span>,这样后面的是<span class="math inline">\(2\)</span>的集合一定是这个后继集合的超集,高维后缀和.</p>
<p>接下来只需要判断哪些位置可以选<span class="math inline">\(1\)</span>.相当于前驱全都是<span class="math inline">\(0\)</span>并且后继全都是<span class="math inline">\(2\)</span>.</p>
<p>####二分图匹配</p>
<p>####二分图最小点覆盖</p>
<p>二分图最小点覆盖<span class="math inline">\(=\)</span>二分图最小割.</p>
<p>问题在于如何求解方案.</p>
<p>我们从左侧的非匹配点开始dfs,走还有残留流量的路径.并将路径上所有的点全都打上标记.那么左侧所有的未标记点和右侧所有的标记点就是一组合法的方案.</p>
<p>这是为啥呢?首先我们注意到,左侧的非匹配点一定会被标记,右侧的非匹配点一定不会被标记.</p>
<p>为啥右侧的非匹配点一定不会被标记呢?因为如果被标记了,从左侧非匹配点到右侧非匹配点这条路径的起始边和终边就都是非匹配边,显然是一条增广路.</p>
<p>然后我们又注意到:对于一组匹配点,要么两者都被标记,要么两者都不被标记,因为一旦走到了右侧点,下一步必然走向左侧点.而如果走到了左侧点,也必然是从右侧点走过来的.</p>
<p>接下来我们讨论一下:</p>
<p>对于非匹配边,由于其必然连了一个左侧非匹配点,所以它的右边必然被选择了.</p>
<p>对于匹配边,不难发现它会被某个匹配点覆盖掉.</p>
<p>于是得证.</p>
<p>当然,上面的证明略显啰嗦.事实上我们这么考虑:</p>
<p>首先,我们按照套路,求出<span class="math inline">\(S\)</span>所有能到达的点.根据二分图的性质,这个点的集合必然不包括<span class="math inline">\(T\)</span>.</p>
<p>然后我们取所有不在这个点集的左侧点和所有在这个点集的右侧点,这样所有的点被分为了四个部分,边也自然被分为了四个部分,讨论一下就知道这四个部分中有一个部分是不存在边的.于是得证.</p>
<p>####二分图最大独立集</p>
<p>二分图最大独立集<span class="math inline">\(=n-\)</span>二分图最小点覆盖.</p>
<h5><span id="example1cf1404e">Example1(CF1404E)</span></h5>
<p>在两个可选矩形的边界处建立一个点,如果它被选了,那么说明这个矩形和上面那个矩形被一起覆盖了.然后注意到每有一个点被选,自然就多覆盖了一个矩形,显然一个矩形不可能又跟纵向的一起被覆盖又跟横向的一起被覆盖,在他俩之间连边跑最大独立集即可.</p>
<p>感觉还是类似于最小路径覆盖,将这种两个一起被覆盖就减少答案的东西转换成一整条流.</p>
<p>####最大权闭合子图</p>
<p>原图的边流量设为<span class="math inline">\(+\infty\)</span>,然后对于每个点<span class="math inline">\(x\)</span>,如果<span class="math inline">\(val_x&gt;0\)</span>,那么<span class="math inline">\(ans+=val_x\)</span>,然后将<span class="math inline">\(S\rightarrow x\)</span>,流量为<span class="math inline">\(val_x\)</span>;不然,<span class="math inline">\(x\rightarrow T\)</span>,流量为<span class="math inline">\(-val_x\)</span>,然后求出最小割<span class="math inline">\(w\)</span>,答案即为<span class="math inline">\(ans-w\)</span>.</p>
<h5><span id="example1luogup4177">Example1(luoguP4177)</span></h5>
<p>只需要把中间的<span class="math inline">\(\infty\)</span>边改为租用的代价即可.</p>
<p>####最小路径覆盖(覆盖点)</p>
<p>将每个点<span class="math inline">\(x\)</span>拆为两个点<span class="math inline">\(A_x\)</span>,<span class="math inline">\(B_x\)</span>,将<span class="math inline">\(S\)</span>向所有<span class="math inline">\(A\)</span>连边,<span class="math inline">\(B\)</span>向<span class="math inline">\(T\)</span>连边,如果图中存在一条路径<span class="math inline">\(x\rightarrow y\)</span>,则连边<span class="math inline">\(A_x\rightarrow B_y\)</span>,流量均为<span class="math inline">\(1\)</span>,然后求出最大流<span class="math inline">\(w\)</span>,答案即为<span class="math inline">\(n-w\)</span>.</p>
<p>还有一个版本是可以重复走点,做一遍传递闭包就行.因为可重复相当于原图上的可跳点,这个版本又叫最小链覆盖.</p>
<h5><span id="example1网络流24题魔术球问题">Example1([网络流24题]魔术球问题)</span></h5>
<p>枚举球数,不断在残联网络上加边并在新图跑最小路径覆盖即可.</p>
<h4><span id="最长反链">最长反链</span></h4>
<p>反链是一个点的集合,满足这个集合中的点两两不可达.</p>
<p>最长反链<span class="math inline">\(=\)</span>可重复走点的最小点覆盖(最小链覆盖).</p>
<p>为啥呢?因为发现做完传递闭包后等价于新图的最大独立集.当然图是有性质的,观察一下可重复走点的最小点覆盖就可以发现等价于传递闭包后在二分图上求最大独立集.</p>
<h5><span id="example1cf1630fmaking-itbipartite">Example1([CF1630F]Making It
Bipartite)</span></h5>
<p>首先显然的一点是,对于任意一个数字<span class="math inline">\(x\)</span>,这个序列中不能同时出现<span class="math inline">\(px\)</span>和<span class="math inline">\(pqx\)</span>,其中<span class="math inline">\(p,q\)</span>都是大于等于二的正整数.这是显然的.如果我们把图改为有向图,由<span class="math inline">\(x\rightarrow
px\)</span>,那么整个图就只会有两种点:只有出边的点和只有入边的点.</p>
<p>那么我们该怎么办呢?如果是只能出现<span class="math inline">\(x\)</span>就不能出现<span class="math inline">\(px\)</span>,那这就是一个经典的最长反链问题.但多了一层,我们可以考虑类似分层图的思想:建立和原图完全一样的图<span class="math inline">\(G&#39;\)</span>,并且将<span class="math inline">\(G\)</span>中的<span class="math inline">\(x\)</span>向<span class="math inline">\(G&#39;\)</span>中的<span class="math inline">\(x&#39;\)</span>连有向边,然后跑最长反链.不难发现这样做是正确的.</p>
<p>####平面图最小割</p>
<p>平面图最小割<span class="math inline">\(=\)</span>对偶图最短路.</p>
<h4><span id="最小费用任意流">最小费用任意流</span></h4>
<p>一般费用流,但是当当前增广路代价为正的就停止增广.</p>
<p>和最小费用最大流不一样,这玩意是可以增量的.</p>
<p>只需要考虑所有新的从源到汇的增广路以及增加过程出现的负环即可.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<p>费用流模型很好建立,问题在于这个东西好像跑费用流有点慢.</p>
<p>那咋办呢?我们考虑到费用流是有凸性的.所以搭配一下wqs二分.</p>
<p>然后分一下三种情况讨论:</p>
<ol type="1">
<li>直接<span class="math inline">\(S\rightarrow
T\)</span>的负增广路,相当于选取最小的<span class="math inline">\(b\)</span>和当前的<span class="math inline">\(a\)</span>搭配.</li>
<li>有一条<span class="math inline">\(S\rightarrow a\rightarrow
b\rightarrow a\rightarrow S\)</span>的负环,相当于以当前的<span class="math inline">\(a\)</span>代替前面的某个较大的<span class="math inline">\(a\)</span>.</li>
<li>有一条<span class="math inline">\(S\rightarrow a\rightarrow
b\rightarrow T\rightarrow b\rightarrow a\rightarrow
S\)</span>的负环,注意到这个环必然没意义,因为不可能存在一条<span class="math inline">\(T\rightarrow
S\)</span>的负路径(不然反路径就是正的,而最小费用任意流不可能流正路径),所以这种情况不如直接选<span class="math inline">\(S\rightarrow T\)</span>的路径.</li>
</ol>
<p>讨论完拿堆模拟一下就行.</p>
<p>这引出了著名的模拟费用流算法.</p>
<h4><span id="负费用最小流">负费用最小流</span></h4>
<p>一般费用流,但是当增广当前增广路时费用变成正的就停止增广.</p>
<p>注意如果两条增广路代价相同选流量大的那条.</p>
<h4><span id="有负环的费用流">有负环的费用流</span></h4>
<p>首先注意到:如果初始图没有负环,那无论后面怎么流都不可能出来负环.因为这意味着要么是一开始流了个正环,要么是一开始有负路径不走走正路径,都不太可能.</p>
<p>对于所有的负边<span class="math inline">\(u\rightarrow
v\)</span>,我们建立两个新点<span class="math inline">\(S&#39;\)</span>和<span class="math inline">\(T&#39;\)</span>,我们先将这条负边反向权值取相反数并让答案加上<span class="math inline">\(f\times v\)</span>,之后令<span class="math inline">\(u\rightarrow T&#39;, S&#39;\rightarrow
v\)</span>,跑<span class="math inline">\(S&#39;\rightarrow
T&#39;\)</span>的费用流,这个时候再在残联网络上跑<span class="math inline">\(s\rightarrow t\)</span>的费用流就是答案.</p>
<p>为啥会这样呢?</p>
<p>首先先证明正确性,这个东西相当于一开始跑了一下<span class="math inline">\(T&#39;\rightarrow u\rightarrow v\rightarrow
S&#39;\)</span>的图.然后我们在跑<span class="math inline">\(S&#39;\rightarrow
T&#39;\)</span>的时候一定是可以把上面的那个东西所从<span class="math inline">\(T&#39;\rightarrow
S&#39;\)</span>的所有流量全都退回去,因为这是一个可以构造的上界.也就相当于我们跑了一个环流.而在费用流里跑环流显然是不会影响答案的.</p>
<p>好,那么为啥这么做就不会出现负环了呢?因为你不可能在跑<span class="math inline">\(S&#39;\rightarrow
T&#39;\)</span>的时候跑个正环出来,自然不可能出现负环.</p>
<p>另外有一点是,一个点可能向<span class="math inline">\(S&#39;\)</span>或<span class="math inline">\(T&#39;\)</span>连很多边,其实是可以拼掉的,因为这些边全都是零权边,而构造完后的图是非负权边.</p>
<h4><span id="模拟费用流">模拟费用流</span></h4>
<p>对于特殊的图,模拟EK费用流的增广过程并进行操作.</p>
<p>对着例题记吧.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<h4><span id="散题">散题</span></h4>
<h5><span id="example1cqoi2014危桥">Example1([CQOI2014]危桥)</span></h5>
<p>有一个朴素的想法是:我们直接按题意建图,然后<span class="math inline">\(S\rightarrow a_1,b_1\)</span>,<span class="math inline">\(T\rightarrow
a_2,b_2\)</span>,跑最大流然后检查是否满流.</p>
<p>问题在于,这样有可能会出现<span class="math inline">\(a_1\rightarrow
b_2\)</span>的流量,我们怎么避免这种情况呢?</p>
<p>做法是,我们交换<span class="math inline">\(b_1,b_2\)</span>并重复上面的过程,如果还是满流,我们声明一定合法.</p>
<p>为什么呢?我们注意到此时网络上的流量分为四种:<span class="math inline">\(a_1\rightarrow a_2\)</span>,<span class="math inline">\(a_1\rightarrow b_2\)</span>,<span class="math inline">\(b_1\rightarrow a_2\)</span>,<span class="math inline">\(b_1\rightarrow b_2\)</span>.不难发现<span class="math inline">\(a_1\rightarrow b_2\)</span>和<span class="math inline">\(b_1\rightarrow a_2\)</span>的流量是相等的.</p>
<p>在第二次跑网络流时,我们不妨直接将<span class="math inline">\(a_1\rightarrow a_2\)</span>和<span class="math inline">\(b_2\rightarrow
b_1\)</span>的流量加入答案并将这两条路径反向.此时,如果<span class="math inline">\(a_1\)</span>还是要走到<span class="math inline">\(b_1\)</span>,你发现第一轮的时候已经找到了一条<span class="math inline">\(b_1\rightarrow
a_2\)</span>的路径,我们一定可以走这条来构造出只有<span class="math inline">\(a_1\rightarrow a_2\)</span>的路径,另一边同理.</p>
<p>###图的计数问题</p>
<p>####Prufer序列</p>
<p>我们可以将一颗有编号<span class="math inline">\(n\)</span>个点(<span class="math inline">\(n\geq 2\)</span>)的无根树与一个长度为<span class="math inline">\(n-2\)</span>的Prufer序列建立双射.换句话说,一颗有编号<span class="math inline">\(n\)</span>个节点的无根树总共有<span class="math inline">\(n^{n-2}\)</span>种(Cayley公式).</p>
<p>首先证明一个树可以对应到一个序列:每次选择一个度数为<span class="math inline">\(1\)</span>的编号最小的点,把它连向的点加到序列中并把这个点删去,直到最后只剩下两个节点,这样我们就把一棵树对应到一个序列.不难发现每个点出现的次数是其度数<span class="math inline">\(-1\)</span>.</p>
<p>然后证明一个序列可以还原成一棵树:</p>
<p>我们可以通过序列得知每个点的度数,每次找到度数中最小的那个点并把它与序列中的第一个元素连边并删去序列中的第一个元素,不断这么做显然可以还原树.</p>
<p>#####Example</p>
<p>一个<span class="math inline">\(n\)</span>个点的图有<span class="math inline">\(k\)</span>个连通块,现在加入<span class="math inline">\(k-1\)</span>条边使得图连通,求方案数.</p>
<p>令<span class="math inline">\(s_i\)</span>为第<span class="math inline">\(i\)</span>个连通块的点数,<span class="math inline">\(d_i\)</span>为第<span class="math inline">\(i\)</span>个连通块所新连上的边数,如果我们令<span class="math inline">\(\binom{n}{c_1,c_2,...,c_m}=\cfrac{n!}{c_1!c_2!...c_m!},\sum_{i=1}^mc_i=n\\\)</span>,也即将<span class="math inline">\(n\)</span>个位置拆分成<span class="math inline">\(m\)</span>个集合,第<span class="math inline">\(i\)</span>个集合有<span class="math inline">\(c_i\)</span>个位置的方案数.</p>
<p>那我们所需要做的也就是枚举每个连通块所新连出的边数<span class="math inline">\(d_i\)</span>,于是答案即<span class="math inline">\(\sum_d[\sum
d_i=2k-2]\binom{k-2}{d_1-1,d_2-1,...,d_k-1}\prod_{i=1}^ks_i^{d_i}\\\)</span>.</p>
<p>注意到我们有多项式定理:<span class="math inline">\((x_1+x_2+...+x_m)^n=\sum_{c}[\sum
c_i=n]\binom{n}{c_1,c_2,...,c_m}\prod_{i=1}^mx_i^{c_i}\\\)</span>.</p>
<p>于是原式<span class="math inline">\(=n^{k-2}\prod_{i=1}^k
s_i\)</span>.</p>
<h4><span id="prufer序列的矩阵树定理理解">Prufer序列的矩阵树定理理解</span></h4>
<p>事实上,Prufer序列其实是可以拿矩阵树定理代替的(但是更麻烦一点).</p>
<p>我们先考虑证明Cayley公式:构造矩阵: <span class="math display">\[
\begin{bmatrix}-n+1&amp;1&amp;\cdots&amp;1\\1&amp;-n+1&amp;\cdots&amp;1\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;1&amp;\cdots&amp;-n+1\end{bmatrix}
\]</span> 其主余子式为: <span class="math display">\[
\begin{bmatrix}-n+1&amp;1&amp;\cdots&amp;1\\1&amp;-n+1&amp;\cdots&amp;1\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;1&amp;\cdots&amp;-n+1\end{bmatrix}
\]</span> 将所有行全部加到第一行: <span class="math display">\[
\begin{bmatrix}-1&amp;-1&amp;\cdots&amp;-1\\1&amp;-n+1&amp;\cdots&amp;1\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;1&amp;\cdots&amp;-n+1\end{bmatrix}
\]</span> 全部加下来,然后就成了上三角矩阵,将对角线乘起来就是<span class="math inline">\(n^{n-2}\)</span>.</p>
<p>连通块的结论是类似的.</p>
<p>####LGV引理</p>
<p>设<span class="math inline">\(G\)</span>是一个有限的带权有向无环图,有点集<span class="math inline">\(V\)</span>的一个大小为<span class="math inline">\(n\)</span>的子集<span class="math inline">\(A=\{a_1,a_2,...,a_n\}\)</span>作为起点集合,一个大小为<span class="math inline">\(n\)</span>的子集<span class="math inline">\(B=\{b_1,b_2,...,b_n\}\)</span>作为终点集合.</p>
<p>记边<span class="math inline">\(i\)</span>的权值为<span class="math inline">\(w_i\)</span>.对于有向路径<span class="math inline">\(p\)</span>,记路径上所有边的边权的乘积为<span class="math inline">\(W(p)\)</span>.记<span class="math inline">\(e(u,v)=\sum_{p:u\rightarrow
v}W(p)\)</span>,即从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的所有路径的边权乘积之和.</p>
<p>记<span class="math inline">\(P:A\rightarrow
B=(p_1,p_2,...,p_n)\)</span>,<span class="math inline">\(p_i\)</span>表示从<span class="math inline">\(a_i\)</span>到<span class="math inline">\(b_{\sigma(i)}\)</span>的一条路径,其中<span class="math inline">\(\sigma\)</span>是一个排列,记<span class="math inline">\(sign(\sigma)\)</span>为<span class="math inline">\(-1\)</span>以这个排列的逆序对数量为幂的值.又记<span class="math inline">\(\sigma(P)\)</span>为<span class="math inline">\(P\)</span>所对应终点的排列.若满足<span class="math inline">\(\forall 1\leq i,j\leq n,i\ne j\)</span>,<span class="math inline">\(p_i\)</span>与<span class="math inline">\(p_j\)</span>没有公共点,则记作<span class="math inline">\(P^u\)</span>,否则记作<span class="math inline">\(P^c\)</span>,若不作区分记作<span class="math inline">\(P\)</span>.记<span class="math inline">\(W_{all}(P)=\prod_{i=1}^n
W(p_i)\\\)</span>,也就是所有路径的乘积.</p>
<p>设矩阵<span class="math inline">\(M\)</span>满足<span class="math inline">\(M_{i,j}=e(a_i,b_j)\)</span>,那么有: <span class="math display">\[
\det M=\sum_{P^u:A\rightarrow B}sign(\sigma(P^u))W_{all}(P^u)
\]</span> 证明:</p>
<p>根据行列式的定义,我们有: <span class="math display">\[
\det M=\sum_{\sigma}sign(\sigma)\prod_{i=1}^ne(a_i,b_{\sigma(i)})\\
=\sum_{\sigma}sign(\sigma)\prod_{i=1}^n\sum_{p_i:a_i\rightarrow
b_{\sigma(i)}}w(p_i)\\
\]</span> 考虑后面那部分,<span class="math inline">\(\prod_{i=1}^n\sum_{p_i:a_i\rightarrow
b_{\sigma(i)}}w(p_i)\\\)</span>形如一个卷积的形式,所以这个式子等价于所有对应排列为<span class="math inline">\(\sigma\)</span>的<span class="math inline">\(P\)</span>的<span class="math inline">\(w(P)\)</span>,所以有: <span class="math display">\[
\det M=\sum_{\sigma}sign(\sigma)(\sum_{P:\{a_1,...,a_n\}\rightarrow
\{b_{\sigma(1)},...,b_{\sigma(n)}\}}w(P))\\
=\sum_{P:A\rightarrow B}sign(\sigma(P))w(P)\\
=\sum_{P^u:A\rightarrow B}sign(\sigma(P^u))w(P^u)+\sum_{P^c:A\rightarrow
B}sign(\sigma(P^c))w(P^c)
\]</span> 接下来只需证明<span class="math inline">\(\sum_{P^c:A\rightarrow
B}sign(\sigma(P^c))w(P^c)=0\\\)</span>即可.</p>
<p>设所有<span class="math inline">\(P^c\)</span>组成的集合为<span class="math inline">\(E\)</span>,考虑构造一个映射<span class="math inline">\(f:E\rightarrow E\)</span>满足如下条件:</p>
<ol type="1">
<li><span class="math inline">\(f(P^c)\ne P^c\)</span>.</li>
<li><span class="math inline">\(f(f(P^c))=P^c\)</span>.</li>
<li><span class="math inline">\(w(f(P^c))=w(P^c)\)</span>.</li>
<li><span class="math inline">\(sign(f(P^c))=-sign(P^c)\)</span>.</li>
</ol>
<p>上面的结论即得证.</p>
<p>我们不妨考虑<span class="math inline">\(P^c\)</span>中的第一对相交的路径<span class="math inline">\(p_i\)</span>和<span class="math inline">\(p_j\)</span>,并交换它们的终点.显然满足上述条件,于是结论得证.</p>
<p>#####Example</p>
<p>现在有<span class="math inline">\(n\)</span>个点,第<span class="math inline">\(i\)</span>个点位于<span class="math inline">\((a_i,1)\)</span>,需要走到<span class="math inline">\((b_i,n)\)</span>.一个在<span class="math inline">\((x,y)\)</span>的点可以走向<span class="math inline">\((x+1,y)\)</span>或<span class="math inline">\((x,y+1)\)</span>.求路径不相交的方案数.</p>
<p>路径不相交,则终点排列只有可能是<span class="math inline">\(\{1,2,...,n\}\)</span>,直接使用LGV引理即可.</p>
<p>####矩阵树定理</p>
<p>#####无向图情况</p>
<p>定义无向图的度数矩阵<span class="math inline">\(D(G)\)</span>为:<span class="math inline">\(D(G)_{i,j}=\begin{cases}0&amp;i\ne
j\\\deg_{i}&amp;i=j\end{cases}\)</span>.</p>
<p>令<span class="math inline">\(w(i,j)\)</span>为<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>之间直接相连的无向边个数,定义无向图的邻接矩阵<span class="math inline">\(A(G)_{i,j}=\begin{cases}0&amp;i=j\\w(i,j)&amp;i\ne
j\end{cases}\)</span></p>
<p>定义无向图的基尔霍夫矩阵(又称拉普拉斯矩阵)<span class="math inline">\(L(G)=D(G)-A(G)\)</span>.</p>
<p>记<span class="math inline">\(t(G)\)</span>为图<span class="math inline">\(G\)</span>的生成树个数,那么有:<span class="math inline">\(t(G)\)</span>等于基尔霍夫矩阵任意一个主余子式.</p>
<p>引理:无向图的基尔霍夫矩阵的任意一个代数余子式都相等.</p>
<p>证明:考虑删去第<span class="math inline">\(i\)</span>行,设剩下的矩阵为<span class="math inline">\(A=[\vec r_1,\vec r_2,...,\vec
r_n]\)</span>,根据基尔霍夫矩阵的性质,不难发现<span class="math inline">\(\sum{\vec r_i}=\vec 0\)</span>.<span class="math inline">\(\forall 1\leq j&lt;k\leq
n\)</span>,如果我们删去第<span class="math inline">\(j\)</span>列,考虑将除了第<span class="math inline">\(k\)</span>列的其它列全部加到第<span class="math inline">\(k\)</span>列,于是得到矩阵<span class="math inline">\([\vec r_1,...,\vec r_{j-1},\vec r_{j+1},...,\vec
r_{k-1},-\vec r_j,\vec r_{k+1},...,\vec
r_n]\)</span>.我们接下来一路将第<span class="math inline">\(k\)</span>列交换到第<span class="math inline">\(j+1\)</span>列之前并取反,我们就得到了删去第<span class="math inline">\(k\)</span>列的矩阵,于是有<span class="math inline">\(M_{i,j}=(-1)^{1+(k-1)-(j+1)+1}M_{i,k}\)</span>,也就是<span class="math inline">\(C_{i,j}=C_{i,k}\)</span>,同理可证明<span class="math inline">\(C_{j,i}=C_{k,i}\)</span>.</p>
<p>接下来,用<span class="math inline">\(T\)</span>表示生成树的边的集合,设<span class="math inline">\(w(T)=\prod_{e\in T}w(e)\)</span>,我们只需证明<span class="math inline">\(C_{1,1}=\sum w(T)\)</span>.</p>
<p>定义<span class="math inline">\(\zeta(e,u)=v,e=\{u,v\}\)</span>,考虑构造一个<span class="math inline">\(n\times m\)</span>的矩阵<span class="math inline">\(A\)</span>满足<span class="math inline">\(A_{i,j}=\begin{cases}1&amp;i\in e_j\and
i&lt;\zeta(e_j,i)\\-1&amp;i\in e_j\and
i&gt;\zeta(e_j,i)\\0&amp;other\end{cases}\\\)</span>.</p>
<p>注意到: <span class="math display">\[
AA^T(i,j)=\sum_{k=1}^mA(i,k)A^T(k,j)\\
=\sum_{k=1}^mA(i,k)A(j,k)\\
\]</span> 当<span class="math inline">\(i=j\)</span>时,不难发现<span class="math inline">\(AA^T(i,j)=\sum_{k=1}^m [i\in
e_k]=\deg_i\)</span>.不然,注意到显然为<span class="math inline">\(-\sum_{k=1}^m[i\in e_k][j\in
e_k]\)</span>.也就是说,<span class="math inline">\(AA^T=L\)</span>.</p>
<p>定义<span class="math inline">\(A\)</span>删去第一行后得到的矩阵为<span class="math inline">\(B\)</span>,则<span class="math inline">\(BB^T=M_{1,1}\)</span>.此时我们带入Cauchy-Binet公式,得到:
<span class="math display">\[
M_{1,1}=\sum_{|S|=n-1,S\subseteq\{1,2,...,m\}}\det(B[S]B^T[S])\\
=\sum_{|S|=n-1,S\subseteq\{1,2,...,m\}}\det(B[S])^2
\]</span> 接下来我们需要证明:如果<span class="math inline">\(S\)</span>集合构成了一棵生成树,那么<span class="math inline">\(\det B[S]=\pm 1\)</span>.反之,<span class="math inline">\(\det B[S]=0\)</span>.</p>
<p>如果集合没有构成一个生成树,则至少存在一个简单环.如果有某个点是孤立点那么答案肯定是<span class="math inline">\(0\)</span>,因此只需考虑每个点都与边连通的情况即可.</p>
<p>考虑这种情况下,如果有两条边<span class="math inline">\((u_1,u_2)\)</span>和<span class="math inline">\((u_2,u_3)\)</span>被选上了,那么我们可以通过列变换将它们改为<span class="math inline">\((u_1,u_2)\)</span>和<span class="math inline">\((u_1,u_3)\)</span>.这样不断进行下去,如果存在环,一定会出现重边选择的情况,这个时候行列式的值为<span class="math inline">\(0\)</span>.如果不存在环,那么我们可以通过这个操作得到一个菊花图.所以行列式为<span class="math inline">\(\pm 1\)</span>.</p>
<p>所以定理得证.</p>
<p>######Example([省选联考 2020 A 卷]作业题)</p>
<p>给定一个图,设第<span class="math inline">\(i\)</span>条边的权值为<span class="math inline">\(w_i\)</span>,求所有生成树的<span class="math inline">\(\gcd(w_1,...,w_{n-1})\sum_{i=1}^{n-1}w_i\)</span>之和.</p>
<p>首先前面的<span class="math inline">\(\gcd\)</span>可以使用<span class="math inline">\(\varphi*I=id\)</span>来处理.于是剩下的问题在于我们如何将一个生成树的边的和代替乘积作为贡献来求和.</p>
<p>不妨进行扩域,令<span class="math inline">\(j^2=0,j\ne
0\)</span>,这样我们可以类比复数来将每个数写作<span class="math inline">\(a+bj\)</span>的模式.考虑将每条边的边权改为<span class="math inline">\(w_ij+1\)</span>并定义新域的四则运算,取最后得到的数<span class="math inline">\(a+bj\)</span>的<span class="math inline">\(b\)</span>作为答案即可.</p>
<p>另外,注意到这样做复杂度<span class="math inline">\(wn^3\)</span>,很难通过.考虑每次只当边数大于等于<span class="math inline">\(n-1\)</span>的时候再跑行列式.不妨设<span class="math inline">\(\sigma(n)\)</span>为<span class="math inline">\(n\)</span>的因数个数,考虑如果因数很分散,那肯定复杂度很低,不然,我们有复杂度<span class="math inline">\(O(n^3\cfrac{\sum_{i=1}^m\sigma(w_i)}{n-1})\)</span>,可以通过.</p>
<p>######Example([北京省选集训2019]生成树计数)</p>
<p>给定一个图,设第<span class="math inline">\(i\)</span>条边的权值为<span class="math inline">\(w_i\)</span>,求所有生成树的<span class="math inline">\((\sum_{i=1}^{n-1}w_i)^k\)</span>之和.</p>
<p>考虑将第<span class="math inline">\(e\)</span>条边边权改为<span class="math inline">\(\sum_{i=0}^k\cfrac{w_e^ix^i}{i!}\)</span>.根据多项式定理,显然最后取<span class="math inline">\([x^k]\)</span>并乘以<span class="math inline">\(k!\)</span>即可.</p>
<p>#####有向图情况</p>
<p>定义有向图的出度矩阵<span class="math inline">\(D^{out}(G)=\begin{cases}0&amp;i\ne
j\\\deg^{out}_i&amp;i=j\end{cases}\)</span>,类似地可以定义入度矩阵<span class="math inline">\(D^{in}(G)\)</span>.</p>
<p>令<span class="math inline">\(cnte(i,j)\)</span>为从<span class="math inline">\(i\)</span>直接连向<span class="math inline">\(j\)</span>的有向边个数,定义有向图的邻接矩阵<span class="math inline">\(A(G)_{i,j}=\begin{cases}0&amp;i=j\\cnte(i,j)&amp;i\ne
j\end{cases}\)</span></p>
<p>定义有向图的出度基尔霍夫矩阵<span class="math inline">\(L^{out}(G)=D^{out}(G)-A(G)\)</span>,同理可以定义其入度基尔霍夫矩阵<span class="math inline">\(L^{in}(G)\)</span>.</p>
<p>记<span class="math inline">\(t^{root}(r,G)\)</span>为图<span class="math inline">\(G\)</span>以<span class="math inline">\(r\)</span>为根的根向生成树(<span class="math inline">\(r\)</span>为根时,所有边都从儿子指向父亲)个数,同理可以定义叶向生成树个数<span class="math inline">\(t^{leaf}(r,G)\)</span>.</p>
<p>设<span class="math inline">\(M^{out}_{r,r}\)</span>为<span class="math inline">\(L^{out}\)</span>的主余子式,有<span class="math inline">\(t^{root}(r,G)=M^{out}_{r,r}\)</span>.叶向同理.</p>
<p>下面只简单提到根向生成树的证明,叶向同理.</p>
<p>类似于无向图,我们考虑构造<span class="math inline">\(n\times
m\)</span>矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\((n-1)\times m\)</span>矩阵<span class="math inline">\(B\)</span>: <span class="math display">\[
A_{i,j}=\begin{cases}1&amp;e_j&#39;s\ head\ is \ i\\-1&amp;e_j&#39;s\
tail\ is \ i\\0&amp;other\end{cases}\\
B_{i,j}=\begin{cases}1&amp;e_j&#39;s\ head\ is \
i\\0&amp;other\end{cases}
\]</span> 剩下的部分与无向图类似.</p>
<p>####BEST定理</p>
<p>设<span class="math inline">\(ec(G)\)</span>为有向图<span class="math inline">\(G\)</span>的欧拉回路个数,若其存在欧拉回路,则:
<span class="math display">\[
ec(G)=t^{root}(G,x)\prod_{i=1}^n(\deg_i-1)!
\]</span> 其中<span class="math inline">\(\deg_i=\deg^{in}_i=\deg_i^{out}\)</span>.</p>
<p>考虑如果勒令以<span class="math inline">\(x\)</span>为起点,我们保留除了<span class="math inline">\(x\)</span>以外每个点的最后经过的出边,最后一定会形成一棵根向树.而其他点可以随便选(由于我们勒令了每个点存在一个出边,所以不可能走到死胡同),这样的答案是<span class="math inline">\(t^{root}(G,x)\deg_x\prod_{i=1}^n(\deg_i-1)!\)</span>.</p>
<p>但是如果没有规定起点,考虑循环重构,在我们选择不同的边当作初始边时,只需循环一下总体的顺序,就可以得到以另一条边为初始边的另一个图,所以答案要比规定起点的答案多除一个<span class="math inline">\(\deg_x\)</span>.</p>
<h4><span id="格路计数问题">格路计数问题</span></h4>
<h5><span id="定义">定义</span></h5>
<ol type="1">
<li>在平面直角坐标系中,横坐标和纵坐标都是整数的点称为格点,平面格路是指从一个格点到另一格点只走格点的路,格路的长度是指其所走的路的步数.</li>
<li>对于一条从<span class="math inline">\((0,0)\)</span>到<span class="math inline">\((n,m)\)</span>的格路,若其只使用了上步<span class="math inline">\(U=(0,1)\)</span>,右步<span class="math inline">\(L=(1,0)\)</span>,则我们称其为<span class="math inline">\((n,m)\)</span>自由路.</li>
<li>记<span class="math inline">\(\mathcal{F}(n,m)\)</span>为<span class="math inline">\((n,m)\)</span>自由路的集合,<span class="math inline">\(F(n,m)=\#\mathcal{F}(n,m)\)</span>为<span class="math inline">\((n,m)\)</span>自由路数量,即<span class="math inline">\(\mathcal{F}(n,m)\)</span>的元素个数,显然<span class="math inline">\(F(n,m)=\binom{n+m}{n}\\\)</span>.</li>
<li>对于一条从<span class="math inline">\((0,0)\)</span>到<span class="math inline">\((n,m)\)</span>的自由路,若其始终不经过对角线<span class="math inline">\(y=\cfrac{m}{n}x\)</span>下方,则我们称之为<span class="math inline">\((n,m)-Dyck\)</span>路.</li>
<li>记<span class="math inline">\(\mathcal{D}(n,m)\)</span>为<span class="math inline">\((n,m)\)</span>自由路的集合,<span class="math inline">\(D(n,m)=\#\mathcal{D}(n,m)\)</span>为<span class="math inline">\((n,m)\)</span>自由路数量,即<span class="math inline">\(\mathcal{D}(n,m)\)</span>的元素个数.</li>
<li>对于从<span class="math inline">\((0,0)\)</span>到<span class="math inline">\((n,m)\)</span>的<span class="math inline">\(2\)</span>条格路<span class="math inline">\(P,Q\)</span>,其中<span class="math inline">\(P =
u_1u_2...u_{n+m},Q=
v_1v_2...v_{n+m}(u_i,v_i\in{L,U},i=1,2,...,n+m)\)</span>.若 <span class="math inline">\(\exists
i,u_{i+1}...u_{n+m}u_1...u_i=v_1v_2...v_{n+m}\)</span>,则我们称格路<span class="math inline">\(P,Q\)</span>等价.将<span class="math inline">\(P\)</span>的等价格路全集记为<span class="math inline">\([P]\)</span>.</li>
<li>对于任意格路<span class="math inline">\(P\)</span>,记<span class="math inline">\(P_k=u_{k+1}...u_{n+m}u_1...u_k\)</span>,则<span class="math inline">\([P] = \{P_k | k = 1, 2, 3, · · · , n+
m\}\)</span>.定义<span class="math inline">\(P\)</span>的周期为使得<span class="math inline">\(P = P_k\)</span>的最小数<span class="math inline">\(k\)</span>，用<span class="math inline">\(period(P)\)</span>表示,则显然有<span class="math inline">\(\#[P] = period(P)\)</span>.</li>
</ol>
<h5><span id="定理">定理</span></h5>
<h4><span id="散模型">散模型</span></h4>
<h5><span id="多叉堆计数">多叉堆计数</span></h5>
<p>有一棵树,要求给每个点一个<span class="math inline">\([1,n]\)</span>的权值且不同的点权值不同,满足父亲的权值小于儿子的权值,求方案数.</p>
<p>不妨设以<span class="math inline">\(u\)</span>为根节点的子树方案数为<span class="math inline">\(f_u\)</span>,<span class="math inline">\(u\)</span>的儿子是<span class="math inline">\(v_1,...,v_k\)</span>,注意到<span class="math inline">\(f_u=\binom{siz_u-1}{siz_{v_1},siz_{v_2},...,siz_{v_k}}\prod
f_{v_i}=(siz_u-1)!\prod_{u\rightarrow
v}\frac{f_{v}}{siz_v!}\\\)</span>.</p>
<p>那么考虑根的答案<span class="math inline">\(f_1\)</span>,考虑不断将<span class="math inline">\(f_1\)</span>中含有的其它<span class="math inline">\(f_u\)</span>向下展开,自然的,除了<span class="math inline">\(1\)</span>号点外,每个点对答案都贡献了一个<span class="math inline">\(\frac{1}{siz}\)</span>,而根的贡献是<span class="math inline">\((n-1)!\)</span>.</p>
<p>也就是说,<span class="math inline">\(ans=(n-1)!\prod_{u=2}^n\frac{1}{siz_u}=n!\prod_{u=1}^n\frac{1}{siz_u}\\\)</span>.</p>
<h6><span id="example1agc060c-large-heap">Example1([AGC060C] Large Heap)</span></h6>
<p>如果没有限制,就是一个简单的多叉堆计数.</p>
<p>而有了限制怎么做呢?我们考虑把<span class="math inline">\(u\)</span>到<span class="math inline">\(1\)</span>的路径和<span class="math inline">\(v\)</span>到<span class="math inline">\(1\)</span>的路径归并起来,会得到一条长链.我们只要确定了长链上的元素,通过组合数以及二叉堆计数,自然可以算出不在长链上的元素的答案.而对于长链上的元素,我们可以直接设计一个<span class="math inline">\(O(n^2)\)</span>的dp即可.</p>
<h6><span id="example2heoi2013sao">Example2([HEOI2013]SAO)</span></h6>
<p>显然给出的是一张树形图,然后每条边有一个限制表示这条边所连接的两个点哪个更大.现在给每个点一个<span class="math inline">\([1,n]\)</span>的权值且不同的点权值不同求方案数.</p>
<p>我们随便找一个点然后当成有根树做,然后如果只有父亲小于儿子的边就是简单的多叉堆计数.不然,我们可以做一个简单容斥.这样问题就又转化回多叉堆计数,容斥部分写一个树形dp就好.</p>
<p>补一下,这个树形dp没有那么简单.首先你注意到多叉堆计数是跟子树大小有关系的,所以你不能简单地设计<span class="math inline">\(f_{i,j}\)</span>表示<span class="math inline">\(i\)</span>子树内选中了<span class="math inline">\(j\)</span>条边的代价,你必须加一维来处理子树大小,也就是设<span class="math inline">\(f_{u,siz,cnt}\)</span>表示<span class="math inline">\(u\)</span>所在连通块大小为<span class="math inline">\(siz\)</span>,子树中总共选择了<span class="math inline">\(cnt\)</span>条边的代价.</p>
<p>但是注意到这题的容斥系数是<span class="math inline">\((-1)^k\)</span>,其中<span class="math inline">\(k\)</span>是选择的儿子小于父亲的数量,然后其它的要求儿子大于父亲的边随便选.你发现你选中了一条边,无非是对答案乘以一个<span class="math inline">\(-1\)</span>,这是没有必要记录的.因此直接以<span class="math inline">\(f_{u,siz}\)</span>的状态转移就行.</p>
<p>这个故事告诉我们别什么容斥都最后算,你能在做的过程中把<span class="math inline">\(-1\)</span>乘上去就别惦记最后统一求和了.</p>
<h5><span id="三元环计数">三元环计数</span></h5>
<p>我们对原图建立一个新的有向图,在新图中,如果<span class="math inline">\(u\rightarrow v\)</span>,则在原图中<span class="math inline">\(\deg u&lt;\deg v\)</span>或<span class="math inline">\(\deg u=\deg v\and
u&lt;v\)</span>.根据自然根号,每个点的出度不会超过<span class="math inline">\(O(\sqrt n)\)</span>.</p>
<p>接下来枚举原图的一条边<span class="math inline">\(u\leftrightarrow
v\)</span>,只要在新的图中找到<span class="math inline">\(w\)</span>满足<span class="math inline">\(u\rightarrow v,u\rightarrow w,v\rightarrow
w\)</span>即可.打tag做一做,复杂度<span class="math inline">\(O(n\sqrt
n)\)</span>.</p>
<h5><span id="四元环计数">四元环计数</span></h5>
<p>仍然类似三元环计数那样建立新图.</p>
<p>考虑原图中的两条边<span class="math inline">\(u\leftrightarrow
v\)</span>和<span class="math inline">\(u\leftrightarrow
v&#39;\)</span>,我们考虑对四元环中度数最大的那个点<span class="math inline">\(w\)</span>计数,对于这个<span class="math inline">\(w\)</span>统计一个tag表示形如<span class="math inline">\(u\leftrightarrow v\rightarrow
w\)</span>的数量,每次改变<span class="math inline">\(u\)</span>的时候清空一下全图tag.</p>
<h5><span id="有标号dag计数">有标号DAG计数</span></h5>
<p>即: <span class="math display">\[
f_n=\sum_{k=1}^n\binom{n}{k}(-1)^{k-1}2^{k(n-k)}f_{n-k}\\
\]</span> 证明见反演与容斥-子集反演-Example2.</p>
<h6><span id="example1qoj5749">Example1(qoj5749)</span></h6>
<p>注意到一个环内部不能有任何边,那么其实也就是有标号DAG计数,只不过要乘上一个斯特林数.不妨设<span class="math inline">\(g_{n,m}\)</span>为<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的答案,再设<span class="math inline">\(G_n\)</span>为其生成函数.事实上,我们自然有: <span class="math display">\[
G_n=\sum_{k=1}\binom{n}{k}\sum_{j=1}^k{k \brack
j}(-1)^{j-1}(1+z)^{k(n-k)}G_{n-k}\\
=\sum_{k=1}\binom{n}{k}(1+z)^{k(n-k)}G_{n-k}\sum_{j=1}^k{k \brack
j}(-1)^{j-1}\\
\]</span> 逆用斯特林公式,如果<span class="math inline">\(n\geq
1\)</span>: <span class="math display">\[
\sum_{i}{n\brack i}(-1)^{i-1}=(-1)\times (-1)^{\overline{n}}=[n=1]
\]</span> 注意到<span class="math inline">\(G_1=1\)</span>,于是: <span class="math display">\[
G_n=n(1+z)^{n-1}G_{n-1}\\
=n!(1+z)^{\frac{n(n-1)}{2}}\\
[z^m]G_n=n!\binom{\frac{n(n-1)}{2}}{m}
\]</span></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#kmp">KMP</a>
<ul>
<li><a href="#example1zr23省选第一轮集训day5b">Example1(zr23省选第一轮集训day5b)</a></li>
<li><a href="#example2noi2014-动物园">Example2(NOI2014 动物园)</a></li>
</ul></li>
<li><a href="#border理论">border理论</a>
<ul>
<li><a href="#定理">定理</a>
<ul>
<li><a href="#定理1">定理1</a></li>
<li><a href="#定理2周期引理">定理2(周期引理)</a></li>
<li><a href="#定理3">定理3</a></li>
<li><a href="#定理4">定理4</a></li>
<li><a href="#定理5">定理5</a></li>
<li><a href="#定理6">定理6</a></li>
</ul></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example1poi2011okr-periodicity">Example1([POI2011]OKR-Periodicity)</a></li>
</ul></li>
</ul></li>
<li><a href="#sa">SA</a>
<ul>
<li><a href="#example1">Example1</a></li>
</ul></li>
<li><a href="#acam">ACAM</a>
<ul>
<li><a href="#example1uoj772企鹅游戏">Example1(uoj772企鹅游戏)</a></li>
<li><a href="#example2loj3396-novel">Example2(loj3396 novel)</a></li>
</ul></li>
<li><a href="#pam">PAM</a>
<ul>
<li><a href="#引理">引理</a></li>
<li><a href="#算法">算法</a></li>
</ul></li>
<li><a href="#sam">SAM</a>
<ul>
<li><a href="#引理-1">引理</a></li>
<li><a href="#约定">约定</a></li>
<li><a href="#算法-1">算法</a></li>
<li><a href="#应用">应用</a>
<ul>
<li><a href="#检查字符串是否出现">检查字符串是否出现</a></li>
<li><a href="#不同子串个数">不同子串个数</a></li>
</ul></li>
<li><a href="#例题">例题</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="kmp">KMP</span></h3>
<h5><span id="example1zr23省选第一轮集训day5b">Example1(zr23省选第一轮集训day5b)</span></h5>
<p>必须提一下的是,能用KMP的前提是可以比较两个字符串是否相等,不一定是比较两个字母相等.只要能比较两个字符串是否相等,并且已知<span class="math inline">\(A=B\)</span>能快速判断是否有<span class="math inline">\(A+a=B+b\)</span>,那么就可以使用KMP.并不要求<span class="math inline">\(A=B\)</span>并且<span class="math inline">\(a=b\)</span>才有<span class="math inline">\(A+a=B+b\)</span>.</p>
<p>因此,我们取<span class="math inline">\(p\)</span>的置换<span class="math inline">\(q\)</span>,然后找到所有和<span class="math inline">\(q\)</span>的大小关系一样的区间即可,要证明这是个等价关系,然后就可以上KMP了.</p>
<h5><span id="example2noi2014-动物园">Example2(NOI2014 动物园)</span></h5>
<p>自然的想法是先求border数组,然后每次暴力跳border直到当前前后缀不重叠.根据border的定义显然是对的.但这样复杂度不对.</p>
<p>另一个想法是我们能不能在做KMP的时候,直接判掉当前长度是否超过,如果超过就放弃呢?也不对,因为这样往前跳也会用到这个border数组,但往前跳有可能跳的很少.</p>
<p>因此我们先求border,再第二遍做KMP,用另一个数组,但是往前跳的时候用border跳,其他情况正常做就行.</p>
<h3><span id="border理论">border理论</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p><span class="math inline">\(s\)</span>的某个border长度为<span class="math inline">\(k\)</span>等价于<span class="math inline">\(|s|-k\)</span>是<span class="math inline">\(s\)</span>的周期.</p>
<p>证明显然.</p>
<h5><span id="定理2周期引理">定理2(周期引理)</span></h5>
<p>弱周期引理:如果<span class="math inline">\(p,q\)</span>是<span class="math inline">\(s\)</span>的周期且<span class="math inline">\(p+q\leq |s|\)</span>,那么<span class="math inline">\(\gcd(p,q)\)</span>是<span class="math inline">\(s\)</span>的周期.</p>
<p>考虑分开两面证明,不妨设<span class="math inline">\(p&gt;q,r=p-q\)</span>,先证明<span class="math inline">\(\forall i&gt;q,s_i=s_{i+r}\)</span>,事实上<span class="math inline">\(s_i=s_{i-q}=s_{i-q+p}=s_{i+r}\)</span>.再考虑证明<span class="math inline">\(i\leq |s|-p,s_i=s_{i+r}\)</span>,事实上<span class="math inline">\(s_i=s_{i+p}=s_{i+p-q}=s_{i+r}\)</span>.</p>
<p>由于<span class="math inline">\(p+q\leq
|s|\)</span>,因此上面那个证明对所有<span class="math inline">\(i\)</span>成立,由此得证.</p>
<p>强周期引理:如果<span class="math inline">\(p,q\)</span>是<span class="math inline">\(s\)</span>的周期且<span class="math inline">\(p+q-\gcd(p,q)\leq |s|\)</span>,那么<span class="math inline">\(\gcd(p,q)\)</span>是<span class="math inline">\(s\)</span>的周期.</p>
<p>这个有一个生成函数证明.简单来说我们不妨设长度为<span class="math inline">\(p\)</span>的那个周期的生成函数为<span class="math inline">\(P(z)\)</span>,它是一个<span class="math inline">\(p-1\)</span>次的生成函数.同理定义<span class="math inline">\(Q(z)\)</span>.不妨设<span class="math inline">\(S_p(z)=\frac{P(z)}{1-z^p}\)</span>,同理定义<span class="math inline">\(S_q(z)\)</span>.</p>
<p>如果我们能说明<span class="math inline">\(S_p(z)=S_q(z)\)</span>,由于这两个都是无穷项,由欧几里得算法立刻得到<span class="math inline">\(\gcd(p,q)\)</span>是其周期.考虑: <span class="math display">\[
S_p(z)-S_q(z)\\
=\frac{P(z)}{1-z^p}-\frac{Q(z)}{1-z^q}\\
=\frac{1-z^g}{(1-z^p)(1-z^q)}(\frac{1-z^q}{1-z^g}P(z)-\frac{1-z^p}{1-z^g}Q(z))
\]</span> 此时注意到括号里面的那个东西的次数有限,设其为<span class="math inline">\(H(z)\)</span>,不难发现<span class="math inline">\(H(z)\)</span>的次数是<span class="math inline">\(p+q-g-1\)</span>.若<span class="math inline">\(H(z)\ne 0\)</span>,又因为<span class="math inline">\(\frac{1-z^g}{(1-z^p)(1-z^q)}\)</span>的常数项不为<span class="math inline">\(0\)</span>,因此<span class="math inline">\(\exists
0\leq k\leq p+q-g-1,[z^k](S_p(z)-S_q(z))\ne 0\)</span>,但根据假设,<span class="math inline">\(\forall 0\leq k\leq n-1\leq
p+q-g-1\)</span>,应该有<span class="math inline">\([z^k](S_p(z)-S_q(z))=0\)</span>,因此<span class="math inline">\(H(z)=0\)</span>,因此<span class="math inline">\(S_p(z)=S_q(z)\)</span>.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若<span class="math inline">\(S\)</span>是<span class="math inline">\(T\)</span>的前缀,且<span class="math inline">\(T\)</span>有周期<span class="math inline">\(a\)</span>,<span class="math inline">\(S\)</span>有整周期<span class="math inline">\(b\)</span>,<span class="math inline">\(b|a,|S|\geq
a\)</span>,则<span class="math inline">\(T\)</span>有周期<span class="math inline">\(b\)</span>.证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>若<span class="math inline">\(2|S|\geq |T|\)</span>,则<span class="math inline">\(S\)</span>在<span class="math inline">\(T\)</span>中的匹配位置必为等差序列.</p>
<p>证明考虑WPL就行.</p>
<h5><span id="定理5">定理5</span></h5>
<p><span class="math inline">\(S\)</span>的长度大于等于<span class="math inline">\(\frac{n}{2}\)</span>的border长度构成一个等差序列.</p>
<p>不妨设最长的border长度为<span class="math inline">\(n-p\)</span>,还有一个border长度是<span class="math inline">\(n-q\)</span>,<span class="math inline">\(q&gt;p\)</span>,那么必有长度为<span class="math inline">\(n-\gcd(p,q)\)</span>的border.注意到<span class="math inline">\(n-p\)</span>是最长的border,则<span class="math inline">\(\gcd(p,q)\geq p\)</span>,<span class="math inline">\(p|q\)</span>.</p>
<h5><span id="定理6">定理6</span></h5>
<p>一个串的所有border按照长度排序后,可以被划分成<span class="math inline">\(O(\log n)\)</span>个等差序列.</p>
<p>首先,将该串的长度<span class="math inline">\(\geq
\frac{n}{2}\)</span>的border拿出作为一个等差序列.考虑这些中长度最小的<span class="math inline">\(T\)</span>.</p>
<p>再考虑最小循环节<span class="math inline">\(d\)</span>,如果<span class="math inline">\(d\leq \frac{n}{4}\)</span>,那么不断减小一定有<span class="math inline">\(|T|\leq
\frac{3}{4}n\)</span>.反之则最长border本身就<span class="math inline">\(\leq
\frac{3}{4}n\)</span>,于是剩下的border都是<span class="math inline">\(T\)</span>的border.这样就证明了<span class="math inline">\(O(\log n)\)</span>,事实上更紧凑的界是<span class="math inline">\(\lceil\log_2 |S|\rceil\)</span>,不会证.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poi2011okr-periodicity">Example1([POI2011]OKR-Periodicity)</span></h5>
<p>注意到一个事实:如果这个字符串存在长度为<span class="math inline">\(k\)</span>的周期,等价于存在长度为<span class="math inline">\(len-k\)</span>的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设<span class="math inline">\(q\)</span>为最小周期,如果<span class="math inline">\(2q&lt;n\)</span>,也就是原串能写成<span class="math inline">\(tt\cdots t&#39;\)</span>的形式.我们不妨先求<span class="math inline">\(tt&#39;\)</span>对应的答案,然后在前面拼<span class="math inline">\(t\)</span>.根据<span class="math inline">\(\leq
\frac{n}{2}\)</span>的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果<span class="math inline">\(2q\geq n\)</span>,此时必定有<span class="math inline">\(s=tat\)</span>,其中<span class="math inline">\(t\)</span>是border.考虑递归求解<span class="math inline">\(t\)</span>,然后就只需要找到一个<span class="math inline">\(a\)</span>满足条件,最小的<span class="math inline">\(a\)</span>是全<span class="math inline">\(0\)</span>,能放的话肯定放,不然我们就放一个<span class="math inline">\(0\cdots01\)</span>.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全<span class="math inline">\(0\)</span>不合法:</p>
<ol type="1">
<li>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l\leq|t|+|a|\)</span>:考虑<span class="math inline">\(l\)</span>的最后一段是一段全<span class="math inline">\(0\)</span>,也就必然意味着<span class="math inline">\(t\)</span>的最后一段是全<span class="math inline">\(0\)</span>,这么不断推下去就可以说明整个序列都是全<span class="math inline">\(0\)</span>,此时放上<span class="math inline">\(0\cdots 01\)</span>必定合法.</li>
<li>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l&gt;|t|+|a|\)</span>:不妨设当前的<span class="math inline">\(l\)</span>是最大的那个(最小的无意义,因为需要保证<span class="math inline">\(|l|&gt;|t|\)</span>),此时最短周期必然是<span class="math inline">\(d=2|t|+|a|-l\)</span>.由于<span class="math inline">\(|t|+|a|\)</span>也是周期并且二者之和<span class="math inline">\(\leq n\)</span>,因此必然有<span class="math inline">\(d|(|t|+|a|)\)</span>.把<span class="math inline">\(ta\)</span>按照<span class="math inline">\(d\)</span>长度划分.如果<span class="math inline">\(d\geq|a|\)</span>必有该串是全<span class="math inline">\(0\)</span>串,不然考虑此时<span class="math inline">\(d=|b|+|a|\)</span>,<span class="math inline">\(b\)</span>是<span class="math inline">\(t\)</span>的一段后缀.考虑此时的周期必然<span class="math inline">\(&lt;|b|+|a|\)</span>,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比<span class="math inline">\(|b|-|a|\)</span>少了<span class="math inline">\(w\)</span>,那么此时必定有<span class="math inline">\(b\)</span>的前<span class="math inline">\(w\)</span>个字符是<span class="math inline">\(0\)</span>,但是由于<span class="math inline">\(0\cdots01\)</span>后面第一个<span class="math inline">\(b\)</span>也往前平移了<span class="math inline">\(w\)</span>格,因此它的第<span class="math inline">\(w\)</span>个字符必定是<span class="math inline">\(1\)</span>,这就保证了<span class="math inline">\(0\cdots 0 1\)</span>必定合法.</li>
</ol>
<h3><span id="sa">SA</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个长度为<span class="math inline">\(n\)</span>的字符串,要从中从左往右选出若干段不相交的子串,使得选出的这些串中,每个串都是上一个串的严格子串.求最多能选出多少段.<span class="math inline">\(n\leq 5\times 10^5\)</span>.</p>
<p>不难发现一定有一组答案每段的长度是<span class="math inline">\(k,k-1,\cdots
,2,1\)</span>,我们不妨把串反过来,这样就是<span class="math inline">\(1,2,\cdots,k-1,k\)</span>.这样就可以设计一个简单的dp是<span class="math inline">\(f_{i,j}\)</span>表示以<span class="math inline">\(i\)</span>结尾,<span class="math inline">\(i\)</span>这段长度为<span class="math inline">\(j\)</span>是否可行,发现单调性后把dp状态扔进值里,<span class="math inline">\(f_i\)</span>表示以<span class="math inline">\(i\)</span>结尾的最大长度是多少,这样用SA做lcp就可以实现<span class="math inline">\(O(n^2)\)</span>.仔细观察转移过程,我们可以二分答案,然后用主席树+SA判断答案是否可行.复杂度<span class="math inline">\(O(n\log^2 n)\)</span>.</p>
<p>那么怎么优化呢?我们考虑类似height的证明:<span class="math inline">\(f_i\leq f_{i-1}+1\)</span>,原因很简单,如果<span class="math inline">\(f_i&gt;f_{i-1}+1\)</span>,那么我们把<span class="math inline">\(f_i\)</span>那个序列的末尾字符全部删掉,自然得到了一个以<span class="math inline">\(i-1\)</span>结尾,长度为<span class="math inline">\(f_i-1&gt;f_{i-1}\)</span>的串,于是就可以类似height那样去掉二分,很厉害.</p>
<h3><span id="acam">ACAM</span></h3>
<p>用于对于每个文本串的前缀,求出它以哪些模式串为后缀.</p>
<h5><span id="example1uoj772企鹅游戏">Example1(uoj772企鹅游戏)</span></h5>
<p>考虑一个暴力:建出<span class="math inline">\(s\)</span>的AC自动机,然后我们记录fail树结构,然后把<span class="math inline">\(t\)</span>放上去跑,每次暴力向上跳fail树上的匹配节点,这样的复杂度就是<span class="math inline">\(O(\sum 匹配节点个数)\)</span>.</p>
<p>但是这个复杂度是正确的.</p>
<p>为啥呢?首先对于任意节点,它在fail树上的祖先中匹配节点个数不可能超过<span class="math inline">\(O(\sqrt
L)\)</span>个,这是个自然根号,因此复杂度至少是<span class="math inline">\(O(L\sqrt L)\)</span>.</p>
<p>但还没完,考虑所有长度小于等于<span class="math inline">\(B\)</span>的模式串,他们会被匹配<span class="math inline">\(O(B|t|)\)</span>次.对于所有长度大于<span class="math inline">\(B\)</span>的模式串,考虑只有长度大于<span class="math inline">\(B\)</span>的文本串会匹配到他们,于是复杂度<span class="math inline">\(O(\frac{L^2}{B^2})\)</span>,<span class="math inline">\(B=L^{\frac{1}{3}}\)</span>得到<span class="math inline">\(O(L^{\frac{4}{3}})\)</span>.</p>
<h5><span id="example2loj3396-novel">Example2(loj3396 novel)</span></h5>
<p>offline.</p>
<h3><span id="pam">PAM</span></h3>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li>本质不同回文串最多只有<span class="math inline">\(n\)</span>个.</li>
</ol>
<p>证明:考虑类似manacher,每次将<span class="math inline">\(S\rightarrow
S+c\)</span>,新产生的回文串一定是<span class="math inline">\(S+c\)</span>的最长回文后缀.</p>
<h4><span id="算法">算法</span></h4>
<p>回文自动机由转移边和fail树构成,经过一条转移边的影响是在前后均添加一个该字符,一个状态在fail树上指向它的最长回文border.</p>
<p>我们记录两个根:长度为<span class="math inline">\(-1\)</span>的奇根和长度为<span class="math inline">\(0\)</span>的偶根,偶根的失配指针指向奇根.</p>
<p>增量构造,每次加入个新字符,然后在fail树上跳祖先直到<span class="math inline">\(s_i=s_{i-len-1}\)</span>.</p>
<p>继续跳这个节点,直到又遇到一个位置,那这个位置就是当前节点的fail指针所指向的点.这个操作是<span class="math inline">\(O(n)\)</span>的,因为这个fail指针只有一个永远不会访问,另外的都会访问至少一次,在访问的时候就会均摊掉求的时候往上跳的复杂度,因为深度直接减去这玩意了.</p>
<h3><span id="sam">SAM</span></h3>
<ol type="1">
<li><span class="math inline">\(endpos(T)\)</span>表示子串<span class="math inline">\(T\)</span>在<span class="math inline">\(S\)</span>中出现位置的末尾集合,特别地,我们设<span class="math inline">\(endpos(\empty)=\{1,\cdots
,|S|-1,|S|\}\)</span>.</li>
<li>若两个不同的子串的<span class="math inline">\(endpos\)</span>相等,则称它们为一个<span class="math inline">\(endpos\)</span>等价类.</li>
</ol>
<p>下面开始证明引理:</p>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li><p>字符串<span class="math inline">\(s\)</span>的两个非空子串<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>的<span class="math inline">\(endpos\)</span>相同(假设<span class="math inline">\(|u|\leq |w|\)</span>),当且仅当字符串<span class="math inline">\(u\)</span>在<span class="math inline">\(s\)</span>中的每次出现,都是以<span class="math inline">\(w\)</span>后缀的形式存在.</p></li>
<li><p>字符串<span class="math inline">\(s\)</span>的两个非空子串<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>的<span class="math inline">\(endpos\)</span>集合的交为空(假设<span class="math inline">\(|u|\leq |w|\)</span>),当且仅当字符串<span class="math inline">\(u\)</span>不是<span class="math inline">\(w\)</span>的后缀.</p></li>
<li><p>字符串<span class="math inline">\(s\)</span>的两个非空子串<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>的<span class="math inline">\(endpos\)</span>集合的交为<span class="math inline">\(endpos(w)\)</span>(假设<span class="math inline">\(|u|\leq |w|\)</span>),当且仅当字符串<span class="math inline">\(u\)</span>是<span class="math inline">\(w\)</span>的后缀.</p></li>
</ol>
<p>证明都是显然的.</p>
<ol start="4" type="1">
<li>对于一个<span class="math inline">\(endpos\)</span>等价类中的子串<span class="math inline">\(u\)</span>,要么<span class="math inline">\(u\)</span>是这个等价类中最短的子串,要么存在一个子串<span class="math inline">\(w\)</span>且<span class="math inline">\(|w|+1=|u|\)</span>,<span class="math inline">\(w\)</span>是<span class="math inline">\(u\)</span>的后缀</li>
</ol>
<p>由前面的引理,容易证明.</p>
<ol start="5" type="1">
<li>对于一个<span class="math inline">\(endpos\)</span>等价类中最短的子串<span class="math inline">\(w\)</span>,不妨设<span class="math inline">\(v\)</span>是<span class="math inline">\(w\)</span>去掉最前面的元素后得到的子串,那么<span class="math inline">\(v\)</span>在另一个<span class="math inline">\(endpos\)</span>等价类中,我们将<span class="math inline">\(endpos(w)\rightarrow endpos(v)\)</span>,记<span class="math inline">\(link(w)=v\)</span>或<span class="math inline">\(fa(w)=v\)</span>,这就是后缀链接link,这些关系构成树.</li>
</ol>
<p>首先除了<span class="math inline">\(\empty\)</span>,每个<span class="math inline">\(w\)</span>的出度都是<span class="math inline">\(1\)</span>,而我们发现所有的子串都会以<span class="math inline">\(\empty\)</span>作为祖先,这就证明了连通性.</p>
<ol start="6" type="1">
<li><span class="math inline">\(endpos\)</span>等价类的数量有<span class="math inline">\(O(n)\)</span>个.</li>
</ol>
<p>考虑后缀链接树,显然一个点的<span class="math inline">\(endpos\)</span>集合包含它的所有儿子的<span class="math inline">\(endpos\)</span>集合的并,并且它所有儿子的<span class="math inline">\(endpos\)</span>集合两两无交,这等价于一个合并的过程.</p>
<h4><span id="约定">约定</span></h4>
<ol type="1">
<li>记<span class="math inline">\(longest(v)\)</span>为<span class="math inline">\(v\)</span>这个<span class="math inline">\(endpos\)</span>等价类中最长的一个字符串,记<span class="math inline">\(len(v)\)</span>为它的长度.类似地定义<span class="math inline">\(shortest(v)\)</span>和<span class="math inline">\(minlen(v)\)</span>,不难发现<span class="math inline">\(minlen(v)=len(fa(v))+1\)</span>.每个节点的子串数量也就是<span class="math inline">\(len(v)-len(fa(v))\)</span>.</li>
<li>记<span class="math inline">\(siz(v)\)</span>为<span class="math inline">\(v\)</span>这个<span class="math inline">\(endpos\)</span>等价类的<span class="math inline">\(endpos\)</span>集合的大小.</li>
</ol>
<h4><span id="算法">算法</span></h4>
<p>先来捋一下整个过程:整个SAM分为两部分:</p>
<p>第一部分:后缀链接树(parent tree).</p>
<p>它的信息由下文中的fa记录.对于每一个节点:它对应一个endpos等价类,因此它拥有一个父亲节点,也就是后缀链接link指向的节点.同时它拥有一个len,表示这个endpos等价类中最长的子串的长度.</p>
<p>第二部分:trie图.</p>
<p>它的信息由下文中的son记录,表示一个endpos(设为x)通过一条trie边走到另一个endpos(设为y),不难发现x中的所有endpos+1所形成的集合包含y.我们注意这一点后,会发现只要从<span class="math inline">\(\empty\)</span>所代表的节点不断地走trie边,最后走到的节点的对应长度的子串就是我们想要的子串.这也意味着我们要保证对应长度的子串一定在走到节点的子串集合中.另外有个结论是trie图的边数是<span class="math inline">\(O(n)\)</span>的.这必然要求走trie走到的那个节点的<span class="math inline">\(len\)</span>的长度的区间包含了这个节点的<span class="math inline">\(len\)</span>的长度的区间<span class="math inline">\(+1\)</span>.</p>
<p>也就是说,走trie边的过程是不断在字符串后面添加字符的过程,而走link的过程是不断在字符串前面删去字符串的过程(当然,反向link自然是不断在字符串前面加上另一个字符串集合的过程).</p>
<p>下面给出构造代码.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>&#123;</span><br><span class="line">	<span class="type">int</span> fa;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">27</span>];</span><br><span class="line">	<span class="type">int</span> len,siz;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cntp=<span class="number">1</span>,las=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> End[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_c</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=++cntp;</span><br><span class="line">	End[i]=x;tr[x].siz=<span class="number">1</span>;<span class="comment">//新建一个endpos=&#123;i&#125;</span></span><br><span class="line">    <span class="comment">//End[i]存的是前缀[1,i]的结束位置,由于我们当前正在插入i,自然是x.</span></span><br><span class="line">	<span class="type">int</span> prex=las;</span><br><span class="line">	las=cntp;</span><br><span class="line">    <span class="comment">//las存储的是当前的终止节点,其实也就是End[i],我们每次要找到上一次的终止节点,根据它来操作.</span></span><br><span class="line">	tr[x].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==<span class="number">0</span>;prex=tr[prex].fa)tr[prex].son[c]=x;</span><br><span class="line">    <span class="comment">//考虑当前的串:[1,i-1]+&#x27;c&#x27;,如果前面存在一个endpos集合包含[j,i-1](这个集合可能是空子串所在的集合)并且它存在一条&#x27;c&#x27;边,那么就存在这么一个子串[j,i-1]+&#x27;c&#x27;,它的endpos应该是&#123;i&#125;这个集合的祖先.</span></span><br><span class="line">    <span class="comment">//如果在判断[j,i-1]的时候,发现[j,i-1]+&#x27;c&#x27;在原串中不存在,那么我们就直接连过来.可以发现在这个跳跃的过程中就是不断探索当前x的shortest的过程.</span></span><br><span class="line">	<span class="keyword">if</span>(!prex)&#123;</span><br><span class="line">        <span class="comment">//说明一直到最后都没有找到字母c,这也意味着c在前面根本没出现过,于是endpos=&#123;i&#125;的等价类是[1,i],[2,i],...,[i,i],所以父亲设为1.</span></span><br><span class="line">		tr[x].fa=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> y=tr[prex].son[c];</span><br><span class="line">    <span class="comment">//考虑这里的prex到底是什么意义,它意味着我们找到了一个最长的[j,i-1]的子串所在的endpos集合,并且[j,i-1]+&#x27;c&#x27;这个子串在原串存在,这也意味着[j,i-1]+&#x27;c&#x27;这个子串所在的endpos集合必然真包含&#123;i&#125;,而这个子串的长度是tr[prex].len+1.</span></span><br><span class="line">	<span class="keyword">if</span>(tr[y].len==tr[prex].len+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果y这个节点的长度恰好也是tr[prex].len+1,那么必然意味着[j,i]这个子串完全就在y这里,而[j-1,i]这些子串不在y这里,但被y表示的endpos集合包含.</span></span><br><span class="line">		tr[x].fa=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之,这里y这个节点的endpos集合就可以分成两部分了:第一部分的endpos集合在加入[j,i]这个子串后不变:因为它们的长度都大于tr[prex].len+1,它们必然不可能存在一个endpos是i.而第二部分,其实也只包含一个子串:就是长度等于tr[prex].len+1的子串,它的endpos集合必然是第一部分的endpos集合并上&#123;i&#125;,根据我们上面所发现的parent tree的本质是合并endpos集合的性质,它应该是第一部分以及&#123;i&#125;的父亲(也就是这两部分合并的结果),我们把第二部分拿出来单独建点.</span></span><br><span class="line">		<span class="type">int</span> fay=++cntp;</span><br><span class="line">		tr[fay]=tr[y];</span><br><span class="line">		tr[fay].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line">		tr[y].fa=tr[x].fa=fay;</span><br><span class="line">		<span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==y;prex=tr[prex].fa)tr[prex].son[c]=fay;</span><br><span class="line">        <span class="comment">//注意单独建点后,原本指向y的trie边要改向.这是为什么呢?考虑当前这条边是什么意义:它必然指向一个endpos集合要包含&#123;i&#125;的点,因为这样才能保证trie图的性质.此时指向y的点就不能是包含&#123;i-1&#125;的点了.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> que[MAXN&lt;&lt;<span class="number">1</span>],l,r;</span><br><span class="line"><span class="type">int</span> ind[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work_siz</span><span class="params">()</span></span>&#123;<span class="comment">//通过一次拓扑排序处理出siz</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">		++ind[tr[i].fa];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ind[i]==<span class="number">0</span>)que[++r]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="type">int</span> x=que[l];++l;</span><br><span class="line">		tr[tr[x].fa].siz+=tr[x].siz;</span><br><span class="line">		--ind[tr[x].fa];</span><br><span class="line">		<span class="keyword">if</span>(ind[tr[x].fa]==<span class="number">0</span>)que[++r]=tr[x].fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是省掉了很多说明:比如这里的复杂度证明以及边数证明,但是我们咕了吧.</p>
<h4><span id="应用">应用</span></h4>
<h5><span id="检查字符串是否出现">检查字符串是否出现</span></h5>
<p>从根开始跳trie边就行.</p>
<h5><span id="不同子串个数">不同子串个数</span></h5>
<p>显然是<span class="math inline">\(\sum len_i-len_{fa_i}\)</span>.</p>
<h4><span id="例题">例题</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给出一个长度为<span class="math inline">\(n\)</span>的小写字母串,你需要计算有多少对非空字符串<span class="math inline">\((A,B)\)</span>满足:</p>
<ol type="1">
<li><span class="math inline">\(AB\)</span>是原串的子串.</li>
<li>每次<span class="math inline">\(A\)</span>在原串中作为子串出现后,要么紧跟着出现一个子串<span class="math inline">\(B\)</span>,要么<span class="math inline">\(A\)</span>后面放不下一个子串<span class="math inline">\(B\)</span>.</li>
</ol>
<p>两个字符串被认为是不同的当且仅当他们在某个位置上字母不同,<span class="math inline">\(|S|\leq 2\times 10^5\)</span>.</p>
<p>首先,我们考虑确定<span class="math inline">\((AB,A)\)</span>这个二元组,对反串建立SAM,我们自然有:</p>
<ol type="1">
<li><span class="math inline">\(AB\)</span>的endpos集合是<span class="math inline">\(A\)</span>的endpos集合的后缀.</li>
<li><span class="math inline">\(A\)</span>的endpos集合中存在的最大的不存在于<span class="math inline">\(AB\)</span>的endpos集合的endpos的大小小于<span class="math inline">\(|AB|\)</span>.</li>
</ol>
<p>看到这里你可能有疑问:为啥要建立反串.因为不建立反串的话<span class="math inline">\((AB,B)\)</span>的endpos可能根本没啥区别,这个很难处理<span class="math inline">\(A\)</span>.SAM最强大的武器还是在于它能快速处理endpos.</p>
<p>那么接下来我们要在SAM上判断这两件事,我们需要一些更方便判断的条件.首先一个自然的发现是,<span class="math inline">\(A\)</span>的最大的endpos必然也是<span class="math inline">\(AB\)</span>的最大的endpos,我们进行一个类似重链剖分的操作:将每个点的重儿子设为它所有儿子中最大的endpos最大的那个.不难发现此时的<span class="math inline">\(A\)</span>与<span class="math inline">\(AB\)</span>必然在同一条重链上,且<span class="math inline">\(A\)</span>是<span class="math inline">\(AB\)</span>的祖先.不过显然这并不能保证一定是后缀,我们开始补条件,直到补到它充要:另一个显然的条件是,设<span class="math inline">\(mx_v\)</span>表示节点<span class="math inline">\(v\)</span>的轻儿子中最大的endpos最大是多少,那么<span class="math inline">\(A\)</span>与<span class="math inline">\(AB\)</span>间的所有<span class="math inline">\(mx\)</span>的最大值就是<span class="math inline">\(A\)</span>的endpos集合中存在的最大的不存在于<span class="math inline">\(AB\)</span>的endpos集合的endpos的大小,它需要小于<span class="math inline">\(|AB|\)</span>.进一步发现这个数字必然需要小于<span class="math inline">\(AB\)</span>的endpos的集合中最小的那个(不然就不是后缀),这被包含于小于<span class="math inline">\(|AB|\)</span>这个条件.</p>
<p>接下来就拆重链,写单调栈就行.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>数论相关</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#整除性及相关">整除性及相关</a>
<ul>
<li><a href="#欧几里得算法">欧几里得算法</a></li>
<li><a href="#一些性质">一些性质</a>
<ul>
<li><a href="#example1cf1656hequal-lcm-subsets">Example1([CF1656H]Equal
LCM Subsets)</a></li>
</ul></li>
<li><a href="#基于值域预处理的快速-gcd">基于值域预处理的快速
GCD</a></li>
<li><a href="#裴蜀定理">裴蜀定理</a></li>
<li><a href="#扩展欧几里得算法">扩展欧几里得算法</a>
<ul>
<li><a href="#example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489eeel-and-grid">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</a></li>
</ul></li>
</ul></li>
<li><a href="#素数及相关">素数及相关</a>
<ul>
<li><a href="#定义">定义</a>
<ul>
<li><a href="#example1具体数学422">Example1(《具体数学》4.22)</a></li>
</ul></li>
<li><a href="#唯一分解定理算数基本定理">唯一分解定理(算数基本定理)</a>
<ul>
<li><a href="#example1cf986foppa-funcan-style-remastered">Example1([CF986F]Oppa
Funcan Style Remastered)</a></li>
</ul></li>
<li><a href="#素数的个数">素数的个数</a>
<ul>
<li><a href="#example1具体数学420">Example1(《具体数学》4.20)</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#欧几里得数">欧几里得数</a></li>
<li><a href="#费马数">费马数</a>
<ul>
<li><a href="#example1具体数学417">Example1(《具体数学》4.17)</a></li>
<li><a href="#example2具体数学418">Example2(《具体数学》4.18)</a></li>
</ul></li>
<li><a href="#miller-rabin算法">Miller-Rabin算法</a></li>
<li><a href="#pollard-rho算法">Pollard-Rho算法</a></li>
<li><a href="#狄利克雷前缀和">狄利克雷前缀和</a></li>
</ul></li>
<li><a href="#阶乘">阶乘</a>
<ul>
<li><a href="#example具体数学455">Example(《具体数学》4.55)</a></li>
</ul></li>
<li><a href="#互素">互素</a>
<ul>
<li><a href="#example1具体数学442">Example1(《具体数学》4.42)</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3具体数学463">Example3(《具体数学》4.63)</a></li>
<li><a href="#stern-brocot-树">Stern-Brocot 树</a></li>
<li><a href="#升幂引理">升幂引理</a>
<ul>
<li><a href="#形式一">形式一</a></li>
<li><a href="#形式二">形式二</a></li>
</ul></li>
</ul></li>
<li><a href="#同余">同余</a>
<ul>
<li><a href="#example具体数学431">Example(《具体数学》4.31)</a></li>
<li><a href="#威尔逊定理">威尔逊定理</a>
<ul>
<li><a href="#example1具体数学448">Example1(《具体数学》4.48)</a></li>
<li><a href="#example2具体数学440">Example2(《具体数学》4.40)</a></li>
<li><a href="#example3具体数学453">Example3(《具体数学》4.53)</a></li>
</ul></li>
<li><a href="#费马小定理">费马小定理</a>
<ul>
<li><a href="#example1具体数学441">Example1(《具体数学》4.41)</a></li>
<li><a href="#example2具体数学446">Example2(《具体数学》4.46)</a></li>
</ul></li>
<li><a href="#中国剩余定理crt">中国剩余定理(crt)</a></li>
<li><a href="#扩展中国剩余定理excrt">扩展中国剩余定理(excrt)</a>
<ul>
<li><a href="#example1noi2018屠龙勇士">Example1([NOI2018]屠龙勇士)</a></li>
<li><a href="#example2cf571egeometric-progressions">Example2([CF571E]Geometric
Progressions)</a></li>
</ul></li>
<li><a href="#二次剩余">二次剩余</a>
<ul>
<li><a href="#example1cf1091gnew-year-and-the-factorisation-collaboration">Example1([CF1091G]New
Year and the Factorisation Collaboration)</a></li>
<li><a href="#example2qoj5021">Example2(qoj5021)</a></li>
<li><a href="#example3">Example3</a></li>
</ul></li>
<li><a href="#bsgs">BSGS</a></li>
<li><a href="#exbsgs">exBSGS</a></li>
<li><a href="#原根和阶">原根和阶</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2具体数学447">Example2(《具体数学》4.47)</a></li>
</ul></li>
</ul></li>
<li><a href="#积性函数">积性函数</a>
<ul>
<li><a href="#example具体数学458">Example(《具体数学》4.58)</a></li>
<li><a href="#狄利克雷卷积">狄利克雷卷积</a></li>
<li><a href="#欧拉函数">欧拉函数</a>
<ul>
<li><a href="#和法里级数的关系">和法里级数的关系</a></li>
<li><a href="#麦克马洪和式">麦克马洪和式</a></li>
<li><a href="#burnside定理">Burnside定理</a>
<ul>
<li><a href="#example1hnoi2009图的同构计数">Example1([HNOI2009]图的同构计数)</a></li>
</ul></li>
<li><a href="#欧拉定理">欧拉定理</a></li>
<li><a href="#扩展欧拉定理">扩展欧拉定理</a>
<ul>
<li><a href="#example2六省联考-2017-相逢是问候">Example2([六省联考 2017]
相逢是问候)</a></li>
<li><a href="#example3具体数学454">Example3(《具体数学》4.54)</a></li>
</ul></li>
<li><a href="#example1具体数学457">Example1(《具体数学》4.57)</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
<li><a href="#莫比乌斯函数">莫比乌斯函数</a>
<ul>
<li><a href="#莫比乌斯反演">莫比乌斯反演</a></li>
</ul></li>
<li><a href="#min25筛">min25筛</a>
<ul>
<li><a href="#example1uoj188sanrd">Example1([uoj188]Sanrd)</a></li>
</ul></li>
<li><a href="#杜教筛">杜教筛</a></li>
<li><a href="#powerful-number筛">Powerful Number筛</a>
<ul>
<li><a href="#example1sp20174divcnt3">Example1([SP20174]DIVCNT3)</a></li>
</ul></li>
</ul></li>
<li><a href="#整值函数">整值函数</a>
<ul>
<li><a href="#定义-1">定义</a></li>
<li><a href="#整值函数的基本性值">整值函数的基本性值</a></li>
<li><a href="#整值函数的应用">整值函数的应用</a>
<ul>
<li><a href="#一类函数与整值函数">一类函数与整值函数</a></li>
<li><a href="#迪利克雷抽屉原理">迪利克雷抽屉原理</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
</ul></li>
<li><a href="#计算区间内整数个数">计算区间内整数个数</a></li>
<li><a href="#谱">谱</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#整值函数的递归式">整值函数的递归式</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
<li><a href="#整值函数的恒等式">整值函数的恒等式</a></li>
<li><a href="#整值函数的和式">整值函数的和式</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
<li><a href="#example2类欧几里得算法">Example2(类欧几里得算法)</a></li>
<li><a href="#example4uoj42sum">Example4([uoj42]Sum)</a></li>
<li><a href="#example5loj6440万能欧几里得算法">Example5([loj6440]万能欧几里得算法)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p>本文除特殊说明,所涉及数均为整数.</p>
<h3><span id="整除性及相关">整除性及相关</span></h3>
<p>如果<span class="math inline">\(m&gt;0\)</span>且<span class="math inline">\(\cfrac{n}{m}\)</span>是一个整数,我们就说<span class="math inline">\(m\)</span>整除<span class="math inline">\(n\)</span>,记作<span class="math inline">\(m|n\)</span>.</p>
<p>能同时整除两个数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的数称为<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子,所有公因子中最大的那个称为最大公因子,记作<span class="math inline">\(\gcd(n,m)\)</span>.而最小的能同时被<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>整除的非零数被称为他们的最小公倍数,记作<span class="math inline">\(lcm(n,m)\)</span>.不难发现<span class="math inline">\(lcm(n,m)\gcd(n,m)=nm\)</span>.</p>
<h4><span id="欧几里得算法">欧几里得算法</span></h4>
<p>欧几里得算法基于以下定理:</p>
<p><span class="math inline">\(\gcd(0,n)=n\)</span>且<span class="math inline">\(\gcd(n,m)=\gcd(n\mod m,m),m&gt;0\)</span>.</p>
<p>考虑证明,首先,<span class="math inline">\(\forall
k\in\mathbb{Z}\)</span>,<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子一定是<span class="math inline">\(n\)</span>和<span class="math inline">\(m+kn\)</span>的公因子,这是显然的.因此,<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子一定是<span class="math inline">\(m\)</span>和<span class="math inline">\(n-m\lfloor\cfrac{n}{m}\rfloor\)</span>的公因子,而反之亦然.</p>
<p>另外有如下性质:</p>
<ol type="1">
<li><span class="math inline">\(\gcd(kn,km)=k\gcd(n,m)\)</span>以及<span class="math inline">\(lcm(kn,km)=k\ lcm(n,m)\)</span>.</li>
<li>若<span class="math inline">\(a\bot b\)</span>,则<span class="math inline">\(\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(n,m)}-b^{\gcd(n,m)}\)</span>.</li>
<li>如果<span class="math inline">\(n^a\equiv 1\pmod m\and n^b\equiv
1\pmod m\)</span>,则<span class="math inline">\(n^{\gcd(a,b)}\equiv
1\pmod m\)</span>.</li>
</ol>
<p>(1)的证明较为显然,我们考虑(2)的证明.</p>
<p>不妨假设<span class="math inline">\(n\leq m\)</span>,当<span class="math inline">\(n=m\)</span>时显然成立.</p>
<p>当<span class="math inline">\(n&lt;m\)</span>时:</p>
<p>假设<span class="math inline">\(a&gt;b\)</span>,考虑<span class="math inline">\(\gcd(a^m-b^m,a^n-b^n)=\gcd(a^m-b^m-k(a^n-b^n),a^n-b^n)\)</span>.</p>
<p>取<span class="math inline">\(k=b^{m-n}\)</span>,则: <span class="math display">\[
\gcd(a^m-b^m,a^n-b^n)=\gcd(a^m-b^{m-n}a^n,a^n-b^n)\\
=\gcd(a^n(a^{m-n}-b^{m-n}),a^n-b^n)
\]</span> 由于<span class="math inline">\(a\bot b\)</span>,所以显然<span class="math inline">\(a^n-b^n\bot a^n\)</span>,于是: <span class="math display">\[
\gcd(a^m-b^m,a^n-b^n)=\gcd(a^{m-n}-b^{m-n},a^n-b^n)
\]</span> 自然得证.</p>
<p>接下来考虑(3)的证明:</p>
<p>如果<span class="math inline">\(a=b\)</span>,显然得证.不然,不妨设<span class="math inline">\(a&gt;b\)</span>注意到: <span class="math display">\[
n^a\equiv 1\pmod m\\
n^a-n^{a-b}n^b\equiv 1-n^{a-b}\pmod m\\
n^{a-b}\equiv 1\pmod m
\]</span> 自然得证.</p>
<h4><span id="一些性质">一些性质</span></h4>
<p>令<span class="math inline">\(n,m\in\mathbb{N_+}\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(k|n\and k|m\Leftrightarrow
k|\gcd(n,m)\)</span>.</li>
<li><span class="math inline">\(\sum_{m|n}a_m=\sum_{m|n}a_{\frac{n}{m}}\)</span>.</li>
<li><span class="math inline">\(\sum_{m|n}\sum_{k|m}a_{k,m}=\sum_{k|n}\sum_{l|(\frac{n}{k})}a_{k,kl}\)</span>.</li>
</ol>
<p>另外,<span class="math inline">\(\gcd\)</span>有一个很著名的性质:对于数字<span class="math inline">\(n,m\)</span>,找到最小的正整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(\exists
y\in \mathbb N\)</span>,<span class="math inline">\(xn=ym\)</span>.</p>
<p>首先令<span class="math inline">\(g=\gcd(n,m)\)</span>,我们自然有<span class="math inline">\(x\frac{n}{g}=y\frac{m}{g}\)</span>,也就相当于<span class="math inline">\(x\frac{n}{g}\equiv
0\pmod{\frac{m}{g}}\)</span>,由于<span class="math inline">\(\gcd(\frac{n}{g},\frac{m}{g})=1\)</span>,所以左边的<span class="math inline">\(\frac{n}{g}\)</span>可以用逆元消掉,显然最小正整数解为<span class="math inline">\(x=\frac{m}{g}\)</span>.</p>
<h5><span id="example1cf1656hequal-lcmsubsets">Example1([CF1656H]Equal LCM
Subsets)</span></h5>
<p>注意到插入可能有点小困难,我们考虑从全集中删除:注意到如果对于一个数字的某一个质因子,如果它的指数大于了对方集合中相同质因子的最大指数,那这个数一定不可能存在,直接删掉.不难发现删完后就是合法的了.</p>
<p>首先,数据范围不允许我们判断质因子,那么怎么做呢?</p>
<p>显然合法的条件等价于<span class="math inline">\(a_i|lcm(b),\forall
1\leq i\leq
n\)</span>(当然这个还要反过来再写一遍,两个式子一起才是充要条件,这里为了方便只写一个),这个条件等价于<span class="math inline">\(\gcd_{j=1}^n(\frac{a_i}{\gcd(b_j,a_i)})=1\)</span>.后者是方便做的.</p>
<p>然后上线段树处理一下,好像先random_shuffle一下再暴力删除也是对的.</p>
<h4><span id="基于值域预处理的快速-gcd">基于值域预处理的快速 GCD</span></h4>
<p>存在一种<span class="math inline">\(O(n)\)</span>预处理,<span class="math inline">\(O(1)\)</span>求任意两个小于等于<span class="math inline">\(n\)</span>的数的<span class="math inline">\(\gcd\)</span>的方法:</p>
<p>引理:</p>
<p>对于任意整数<span class="math inline">\(n\)</span>,存在一种划分方式<span class="math inline">\(n=abc\)</span>,<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>,<span class="math inline">\(c\)</span>三个数要么是质数,要么<span class="math inline">\(\leq \sqrt n\)</span>.</p>
<p>证明:</p>
<p>如果<span class="math inline">\(n\)</span>存在一个大于等于<span class="math inline">\(\sqrt n\)</span>的质因子,显然成立.</p>
<p>否则,使用数学归纳,我们考虑<span class="math inline">\(n\)</span>的最小质因子为<span class="math inline">\(p\)</span>,设<span class="math inline">\(\frac n
p=xyz\)</span>,不妨设<span class="math inline">\(x\leq y\leq
z\)</span>.</p>
<p>如果<span class="math inline">\(x=1\)</span>,显然成立.</p>
<p>不然有<span class="math inline">\(p\leq x\leq y\leq
z\)</span>,而<span class="math inline">\(pxyz=n\)</span>,那么<span class="math inline">\(p^4\leq n\)</span>,<span class="math inline">\(p\leq n^{\frac 1 4}\)</span>.</p>
<p>现在我们想要证明不存在<span class="math inline">\(xp&gt;\sqrt
n\)</span>,<span class="math inline">\(yp&gt;\sqrt n\)</span>,<span class="math inline">\(zp&gt;\sqrt n\)</span>.</p>
<p>如果存在,我们有: <span class="math display">\[
xyzp^3&gt;n^{\frac 3 2}\\
np^2&gt;n^{\frac 3 2}\\
p^2&gt;\sqrt n\\
p&gt;n^{\frac 1 4}
\]</span> 与我们前面的结论不符合.</p>
<p>因而该引理成立,并且给出了<span class="math inline">\(O(n)\)</span>预处理所有数<span class="math inline">\(abc\)</span>的方法.</p>
<p>接下来，设<span class="math inline">\(m=\sqrt
n\)</span>,考虑使用<span class="math inline">\(O(n)\)</span>的时间求出每个小于等于<span class="math inline">\(m\)</span>的数对的<span class="math inline">\(\gcd\)</span>,如果我们要求<span class="math inline">\(\gcd(x,y)\)</span>,设<span class="math inline">\(x=abc\)</span>,显然<span class="math inline">\(\gcd(x,y)=\gcd(a,y)\times\gcd(b,\frac{y}{\gcd(a,y)})\times\gcd(c,\frac{y}{\gcd(ab,y)})\)</span>.</p>
<p>如果<span class="math inline">\(a\)</span>是质数，只需要判断<span class="math inline">\(a\)</span>是否整除<span class="math inline">\(y\)</span>.</p>
<p>否则<span class="math inline">\(\gcd(a,y)=\gcd(y\mod
a,a)\)</span>,因为<span class="math inline">\(a\leq \sqrt
n\)</span>,因而可以直接查表.</p>
<h4><span id="裴蜀定理">裴蜀定理</span></h4>
<p><span class="math inline">\(\forall
a,b,m\in\mathbb{Z}\)</span>,则<span class="math inline">\(\exists x,y\in
\mathbb{Z}\)</span>满足<span class="math inline">\(ax+by=m\)</span>,当且仅当<span class="math inline">\(\gcd(a,b)|m\)</span>.</p>
<p>证明如下:</p>
<p>若<span class="math inline">\(a=0\)</span>或<span class="math inline">\(b=0\)</span>,显然成立.</p>
<p>不然,设集合<span class="math inline">\(A=\{xa+yb|x,y\in\mathbb{Z}\}\)</span>中的最小正元素<span class="math inline">\(d_0=x_0a+y_0b\)</span>,该集合中显然一定有正元素.</p>
<p>考虑取该集合中另一个正整数<span class="math inline">\(d_1=x_1a+y_1b&gt;d_0\)</span>,注意到<span class="math inline">\(d_1-d_0=(x_1-x_0)a+(y_1-y_0)b\in
A\)</span>,所以<span class="math inline">\(\gcd (d_1,d_0)\in
A\)</span>,如果<span class="math inline">\(d_0\nmid
d_1\)</span>,那么<span class="math inline">\(0&lt;\gcd
(d_1,d_0)&lt;d_0\)</span>,与假设不符.所以这个集合里的所有数一定都是<span class="math inline">\(d_0\)</span>的倍数.</p>
<p>事实上还有另一种证明方式:</p>
<p>如果我们定义一个非空集合<span class="math inline">\(I\subseteq
\Z\)</span>,满足其对加法和数乘(<span class="math inline">\(\forall a\in
\Z,x\in I,ax\in
I\)</span>)均封闭,那么我们可以证明其中存在一个唯一的数字<span class="math inline">\(g\)</span>满足所有数都是<span class="math inline">\(g\)</span>的倍数.</p>
<p>如果<span class="math inline">\(I=\{0\}\)</span>,可以取<span class="math inline">\(g=0\)</span>.</p>
<p>反之,显然其中有正有负(因为可以取<span class="math inline">\(a=-1\)</span>),我们设<span class="math inline">\(I_+=\{k\in I|k\geq 1\}\)</span>取<span class="math inline">\(g=\min I_+\)</span>.<span class="math inline">\(\forall a\in I\)</span>,不妨设<span class="math inline">\(a=gq+r,r\in [0,g)\)</span>,那么<span class="math inline">\(r=a+(-q)g\in I\)</span>,由于<span class="math inline">\(r&lt;g\)</span>,所以<span class="math inline">\(r\notin I_+\)</span>,所以<span class="math inline">\(r=0\)</span>,<span class="math inline">\(a\)</span>是<span class="math inline">\(g\)</span>的倍数,且显然<span class="math inline">\(g\)</span>唯一.</p>
<h4><span id="扩展欧几里得算法">扩展欧几里得算法</span></h4>
<p>考虑求方程<span class="math inline">\(ax+by=\gcd(a,b)\)</span>的一组解.</p>
<p>首先,如果<span class="math inline">\(b=0\)</span>,那这组解显然就是<span class="math inline">\(\begin{cases}x=1\\y=0\end{cases}\)</span>.</p>
<p>反之,我们令<span class="math inline">\(c=a\mod
b\)</span>,考虑求方程<span class="math inline">\(cz+bw=\gcd(c,b)\)</span>的一组解.</p>
<p>接下来呢,考虑带入<span class="math inline">\(c\)</span>,则我们求出来的即方程<span class="math inline">\((a-b\lfloor\cfrac a
b\rfloor)z+bw=\gcd(a,b)\)</span>的一组解.不难发现这也就是方程<span class="math inline">\(az+(w-\lfloor\cfrac a b\rfloor
z)b=\gcd(a,b)\)</span>的一组解,所以原本的方程的解也就是<span class="math inline">\(\begin{cases}x=z\\y=(w-\lfloor\cfrac a b\rfloor
z)\end{cases}\)</span>.</p>
<p>另外,这个算法也可以使用矩阵形式:</p>
<p>首先有<span class="math inline">\(\left[\begin{matrix}
a\\
b
\end{matrix}\right]
=\left[\begin{matrix}
a\\
b
\end{matrix}\right]\)</span>,令<span class="math inline">\(q=\lfloor\frac a b\rfloor\)</span>,那么我们有<span class="math inline">\(\left[\begin{matrix}
0&amp;1\\
1&amp;-q
\end{matrix}\right]
\left[\begin{matrix}
a\\
b
\end{matrix}\right]=
\left[\begin{matrix}
b\\
a\mod b
\end{matrix}\right]\)</span>.</p>
<p>同样我们可以得到:<span class="math inline">\(\left[\begin{matrix}
x_1&amp;y_1\\
x_2&amp;y_2
\end{matrix}\right]
\left[\begin{matrix}
a\\
b
\end{matrix}\right]=
\left[\begin{matrix}
\gcd(a,b)\\
0
\end{matrix}\right]\)</span>,即<span class="math inline">\(ax_1+by_1=\gcd(a,b)\)</span>,<span class="math inline">\((x_1,y_1)\)</span>就是一组特解.</p>
<h5><span id="example1xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489eeel-and-grid">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</span></h5>
<p>题意:<span class="math inline">\(h\times w(h,w\leq
10^6)\)</span>的格子图,只能往下往右走,走到边界会循环,问从<span class="math inline">\((0,0)\)</span>开始走遍历走一个哈密顿回路的方案数.</p>
<p>这题最重要的地方其实在于观察到,由于每个点只会被走到一次(除了<span class="math inline">\((0,0)\)</span>,它会被走到两次,但只会由其它格子走来一次),因此如果抽象成图,每个格子只会有一个出边和一个入边.这意味着每个格子上面的和左边的格子必定只有一个指向它,进一步地,这意味着这两个格子的状态必然相同.</p>
<p>由此我们发现,每条副对角线(取膜意义下)的状态必然相同,而取膜意义下的副对角线有多少条呢?不难注意到是<span class="math inline">\(d=\frac{hw}{\text
{lcm}(h,w)}=\gcd(h,w)\)</span>条.也就是说,我们只需要确定这<span class="math inline">\(d\)</span>条对角线的值,就可以确定整个矩阵的答案.假设<span class="math inline">\(R\)</span>表示向右走,<span class="math inline">\(D\)</span>表示向下走,<span class="math inline">\(a_i\)</span>表示第<span class="math inline">\(i\)</span>条副对角线的状态,最后的操作序列自然是<span class="math inline">\(a_0a_1...a_{d-1}a_0a_1...\)</span>.</p>
<p>那么我们接下来要做的就是给这<span class="math inline">\(d\)</span>条副对角线定向,并判断一个方案是否合法.注意到一个方案不合法当且仅当出现了多于<span class="math inline">\(1\)</span>个环.那这又意味着什么呢?意味着存在一个点,它可以通过少于<span class="math inline">\(hw\)</span>次走动走回自己.这显然是不被我们允许的.另一件不难发现的事是,第一个走回自己的点一定是<span class="math inline">\((0,0)\)</span>.再不难发现的是,走回自己的时候一定是经过了若干个周期:<span class="math inline">\(a_0a_1...a_{d-1}a_0...a_{d-1}\)</span>,因为每次向下或者向右走都会走到下一条副对角线,而且最后要回到自己.这就注意到每一个循环<span class="math inline">\(a_0a_1...a_{d-1}\)</span>内部具体什么情况是不在乎的,只在乎经历过这个过程之后会发生什么样的变化.</p>
<p>我们不妨假设序列<span class="math inline">\(\{a\}\)</span>中有<span class="math inline">\(k\)</span>个<span class="math inline">\(R\)</span>,<span class="math inline">\(d-k\)</span>个<span class="math inline">\(D\)</span>,那会产生这种情况当且仅当<span class="math inline">\(\exists x\in \mathbb{N_+},x&lt;
\frac{hw}{d}\)</span>,<span class="math inline">\(\begin{cases}h|x(d-k)\\w|xk\end{cases}\)</span>.注意到这等价于寻找最小的<span class="math inline">\(x\)</span>,判断其是否小于<span class="math inline">\(\frac{hw}{d}\)</span>,于是条件等价于自然有<span class="math inline">\(x=lcm(\frac{h}{\gcd(d-k,h)},\frac{w}{\gcd(w,k)})\)</span>,枚举<span class="math inline">\(k\)</span>并判断即可.</p>
<h3><span id="素数及相关">素数及相关</span></h3>
<h4><span id="定义">定义</span></h4>
<p>可以利用裴蜀定理证明素数的定义等价于<span class="math inline">\(\forall a,b,p|ab\Rightarrow p|a\or
p|b\)</span>.</p>
<p>考虑先用最基础的定义得到这个命题,考虑<span class="math inline">\(p|ab,p\nmid a\)</span>,则<span class="math inline">\(1=px+ay\)</span>有解,则<span class="math inline">\(b=pxb+(ab)y\)</span>,右边都是<span class="math inline">\(p\)</span>的倍数,所以<span class="math inline">\(p|b\)</span>.</p>
<p>这个命题反推的话,考虑设<span class="math inline">\(p=ab,a,b\ne
1\)</span>,则<span class="math inline">\(p|ab\)</span>且<span class="math inline">\(p\nmid a,p\nmid b\)</span>,不符.</p>
<h5><span id="example1具体数学422">Example1(《具体数学》4.22)</span></h5>
<p>证明:在<span class="math inline">\(n\)</span>进制下,若<span class="math inline">\((11...1)_n\)</span>的<span class="math inline">\(1\)</span>的个数不是质数则其一定不是质数..</p>
<p>设<span class="math inline">\(1\)</span>的个数为<span class="math inline">\(m\)</span>,则<span class="math inline">\((11...1)_n=\sum_{i=0}^{m-1}n^i\)</span>.</p>
<p>如果<span class="math inline">\(m\notin prime\)</span>,不妨设则<span class="math inline">\(m=cd,c\ne 1\and d\ne 1\)</span>.</p>
<p>则 <span class="math display">\[
\sum_{i=0}^{m-1}n^i=\sum_{i=0}^{c-1}n^{di}\sum_{j=0}^{d-1}n^{j}\\=(\sum_{i=0}^{c-1}n^{di})(\sum_{j=0}^{d-1}n^j)
\]</span> 显然不是质数.</p>
<h4><span id="唯一分解定理算数基本定理">唯一分解定理(算数基本定理)</span></h4>
<p>任何正整数都只有一种方式以素数非减的次序写成素数的乘积.</p>
<p>证明:</p>
<p>考虑数学归纳法,设小于<span class="math inline">\(n\)</span>的数全部满足.</p>
<p>则对于<span class="math inline">\(n\)</span>,如果它不满足条件,一定存在两种分解方式<span class="math inline">\(n=\prod_{i=1}^mp_i=\prod_{i=1}^kq_i\)</span>.</p>
<p>首先,如果<span class="math inline">\(p_1=q_1\)</span>,根据归纳假设,显然不成立.</p>
<p>不失一般性,设<span class="math inline">\(p_1&lt;q_1\)</span>.则<span class="math inline">\(q_1|p_1\prod_{i=2}^mp_i\)</span>,显然<span class="math inline">\(q_1\nmid p_1\)</span>,所以<span class="math inline">\(q_1|\prod_{i=2}^mp_i\)</span>,设<span class="math inline">\(s=\prod_{i=2}^mp_i\)</span>,但这是不可能的,因为<span class="math inline">\(s&lt;n\)</span>,根据归纳假设,它只有一种分解方式,这种方式中显然不可能存在<span class="math inline">\(p_1\)</span>.</p>
<p>那么根据上述证明,我们可以将一个数表示为以下形式:<span class="math inline">\(n=\prod_p p^{n_p},n_p\geq 0\)</span>.</p>
<p>另外不难证明的一点是,假设<span class="math inline">\(\sum
n_p=k\)</span>,那么最小质因子一定不大于<span class="math inline">\(\sqrt[k]{n}\)</span>.</p>
<h5><span id="example1cf986foppafuncan-style-remastered">Example1([CF986F]Oppa
Funcan Style Remastered)</span></h5>
<p>首先对<span class="math inline">\(k\)</span>做pollard-Rho算法.注意到我们可以默认<span class="math inline">\(q_i\)</span>是质因子,这显然不会影响答案.</p>
<p>然后,如果只有一个质因子,显然直接判断.</p>
<p>如果有两个质因子,是经典的二元不定方程.</p>
<p>如果有三个质因子,此时最小质因子的大小就不大于<span class="math inline">\(\sqrt[3]{k}\)</span>,做同余最短路即可.</p>
<h4><span id="素数的个数">素数的个数</span></h4>
<p>首先,欧几里得证明了素数有无穷多个:</p>
<p>假设素数有有限个,分别为<span class="math inline">\(p_1,p_2,...p_m\)</span>,则<span class="math inline">\(\prod_{i=1}^mp_i+1\)</span>无法被其中任何素数整除,则假设不成立.</p>
<p>在此基础上,我们可以定义欧几里得数:</p>
<p><span class="math inline">\(e_1=2,e_n=1+\prod_{i=1}^{n-1}e_i\)</span>.</p>
<p>令<span class="math inline">\(\pi(n)\)</span>表示小于等于<span class="math inline">\(n\)</span>的素数个数,有<span class="math inline">\({\lim_{n\rightarrow+\infty}\cfrac{\pi(n)\times \ln
n}{n}}=1\)</span>.</p>
<p>有切比雪夫定理(又称贝特朗假设):若<span class="math inline">\(n&gt;1,\exist p\in prime,p\in(n,2n)\)</span>.</p>
<p>又有狄利克雷定理:若<span class="math inline">\(\gcd(a,b)=1,\{an+b\}\)</span>中包含了无穷个素数.</p>
<p>(顺便一提,当<span class="math inline">\(a=4\)</span>或者<span class="math inline">\(a=6\)</span>,<span class="math inline">\(b=-1\)</span>的时候是好证明的,由于素数要么形如<span class="math inline">\(6n-1\)</span>要么形如<span class="math inline">\(6n+1\)</span>,或者要么形如<span class="math inline">\(4n-1\)</span>要么形如<span class="math inline">\(4n+1\)</span>,只需要类似证明素数无限那样乘一乘)</p>
<p>同时,我们还有以下结论:<span class="math inline">\(\sum_{1\leq p\leq
n\and p\in prime}\cfrac{1}{p}\approx \log\log n\)</span>.</p>
<p>证明如下: <span class="math display">\[
\sum_{1\leq p\leq n\and p\in
prime}\cfrac{1}{p}=\sum^n_{k=1}\cfrac{\pi(k)-\pi(k-1)}{k}=\sum^n_{k=1}\cfrac{\pi(k)}{k}-\sum^n_{k=1}\cfrac{\pi(k-1)}{k}\\
=\sum^n_{k=1}\cfrac{\pi(k)}{k}-\sum^{n-1}_{k=0}\cfrac{\pi(k)}{k+1}\\
=\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k}+\cfrac{\pi(n)}{n}-\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k+1}-\cfrac{\pi(0)}{1}\\
=\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k(k+1)}+\cfrac{\pi(n)}{n}\\
= \sum^{n-1}_{k=1}{(\cfrac{1}{k\log k})}+O(\frac{1}{\log n})= O(\log
\log n)+O(\frac1{\log n})
\]</span></p>
<h5><span id="example1具体数学420">Example1(《具体数学》4.20)</span></h5>
<p>证明:存在一个常数<span class="math inline">\(b\)</span>满足<span class="math inline">\(\lfloor2^b\rfloor,\lfloor2^{2^b}\rfloor,\lfloor2^{2^{2^b}}\rfloor.,..\)</span>都是质数.</p>
<p>如此构造数列:设<span class="math inline">\(p_1=2\)</span>,且<span class="math inline">\(p_n\)</span>为满足<span class="math inline">\(2^{p_{n-1}}&lt;p_n&lt;2^{p_{n-1}+1}\)</span>的最小质数.</p>
<p>通过构造不难发现:<span class="math inline">\(p_{n-1}=\lfloor\log_2
p_n\rfloor\)</span>.</p>
<p>根据整值函数的性质,我们有<span class="math inline">\(\lfloor\log_2
x\rfloor=\lfloor\log_2\lfloor
x\rfloor\rfloor\)</span>.考虑反向数学归纳,考虑当<span class="math inline">\(n\rightarrow
+\infty\)</span>时构造满足题目条件,那么<span class="math inline">\(p^{n-1}=\lfloor
\log_2\lfloor2^{2^{2^{...^{b}}}}\rfloor\rfloor=\lfloor2^{2^{...^{b}}}\rfloor\)</span>,自然也满足条件.所以如果设<span class="math inline">\(\log_2^{(n)}x\)</span>为不断对<span class="math inline">\(x\)</span>迭代求<span class="math inline">\(\log_2\)</span>做<span class="math inline">\(n\)</span>次后的答案,只需构造<span class="math inline">\(b=\lim_{n\rightarrow
+\infty}\log_2^{(n)}p_n\)</span>即可.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证: <span class="math display">\[
\mu(\gcd(a,b))=0\Leftrightarrow \forall n&gt;0,\mu(an+b)=0
\]</span> 左推右是简单的.接下来考虑右推左.</p>
<p>考虑狄利克雷定理,数列<span class="math inline">\(\{\frac{an+b}{\gcd(a,b)}\}\)</span>.不妨反证,假设<span class="math inline">\(\mu(\gcd(a,b))\ne 0\)</span>,不妨设<span class="math inline">\(p=\frac{an+b}{\gcd(a,b)}\)</span>,<span class="math inline">\(p\gcd(a,b)=ax+b\)</span>,也就是<span class="math inline">\(\mu(p\gcd(a,b))=0\)</span>,注意到<span class="math inline">\(\mu(\gcd(a,b))\ne 0\)</span>,此时必有<span class="math inline">\(p|\gcd(a,b)\)</span>,而<span class="math inline">\(p\)</span>无限,<span class="math inline">\(\gcd(a,b)\)</span>的素因子有限,这就导出了矛盾.</p>
<h4><span id="欧几里得数">欧几里得数</span></h4>
<p>定义欧几里得数:<span class="math inline">\(e_1=2,e_n=1+\prod_{i=1}^{n-1}e_i\)</span>.不难发现<span class="math inline">\(e_n=e_{n-1}(e_{n-1}-1)\)</span>.</p>
<h4><span id="费马数">费马数</span></h4>
<p>定义费马数<span class="math inline">\(f_n=2^{2^n}+1\)</span>.不难发现<span class="math inline">\(f_n=(f_{n-1}-1)^2+1\)</span>.</p>
<p>另外,费马数还满足<span class="math inline">\(f_n=\prod_{i=0}^{n-1}f_i+2\)</span>,我们考虑这个式子的证明:显然后面那一个连乘会得到若干项<span class="math inline">\(2\)</span>的次幂,并且这些项两两不同,根据几何级数,我们有<span class="math inline">\(\prod _{i=0}^{n-1}f_i+1\)</span>=<span class="math inline">\(2^{2^{n}}\)</span>,于是显然得证.</p>
<h5><span id="example1具体数学417">Example1(《具体数学》4.17)</span></h5>
<p>求证:如果<span class="math inline">\(m\ne n\)</span>,则<span class="math inline">\(f_m\bot f_n\)</span>.</p>
<p>不妨假设<span class="math inline">\(m&lt;n\)</span>,有:<span class="math inline">\(\gcd(f_m,f_n)=\gcd(f_m,2)=1\)</span>.</p>
<h5><span id="example2具体数学418">Example2(《具体数学》4.18)</span></h5>
<p>求证:若<span class="math inline">\(2^n+1\)</span>是质数,则<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的整数幂.</p>
<p>如果<span class="math inline">\(n=qm\)</span>且<span class="math inline">\(q\)</span>是奇数,我们有:<span class="math inline">\(2^n+1=(2^m+1)(2^{n-m}-2^{n-2m}+2^{n-3m}...-2^m+1)\)</span>.</p>
<h4><span id="miller-rabin算法">Miller-Rabin算法</span></h4>
<p>如果判断<span class="math inline">\(n\)</span>是否是质数,取<span class="math inline">\(a&lt;n\)</span>,设<span class="math inline">\(n-1=d\times2^r\)</span>.</p>
<p>则要么<span class="math inline">\(a^d\equiv 1(\mod n)\)</span>.</p>
<p>要么<span class="math inline">\(\exists i\)</span>,使得<span class="math inline">\(0\leq i&lt;r\)</span>,<span class="math inline">\(a^{d\times 2^i}\equiv -1(\mod n)\)</span>.</p>
<p>若一个都不满足,则n一定不是质数,不然可能是质数.</p>
<p>但是若取足够多的不同的<span class="math inline">\(a\)</span>(如果选<span class="math inline">\(m\)</span>个),那么<span class="math inline">\(n\)</span>是质数的可能性更大.</p>
<p>此为Miller-Rabin算法,复杂度<span class="math inline">\(O(m\times
log_2n)\)</span>.不保证正确性.</p>
<p>其中a通常取质数,原因不详.（事实上，如果a取前八个小质数，在<span class="math inline">\(2^{64}\)</span>内是不会出错的）</p>
<h4><span id="pollard-rho算法">Pollard-Rho算法</span></h4>
<p>对<span class="math inline">\(n\)</span>做质因数分解,若能找到<span class="math inline">\(a\)</span>使得<span class="math inline">\(a|n\)</span>,则考虑对<span class="math inline">\(\cfrac{n}{a}\)</span>和<span class="math inline">\(a\)</span>分别进行质因数分解.</p>
<p>考虑随机<span class="math inline">\(a\)</span>,若<span class="math inline">\(n\)</span>有<span class="math inline">\(m\)</span>个因数,那么显然随机到<span class="math inline">\(a\)</span>使得<span class="math inline">\(a|n\)</span>的概率为<span class="math inline">\(\cfrac{m}{n}\)</span>,显然不太优秀.</p>
<p>考虑改变随机策略,我们考虑随机一个<span class="math inline">\(a\)</span>使得<span class="math inline">\(\gcd(a,n)\ne 1\)</span>,那么<span class="math inline">\(\gcd(a,n)\)</span>就是<span class="math inline">\(n\)</span>的一个因子.</p>
<p>这种情况下,随机的概率是<span class="math inline">\(\cfrac{\varphi(n)}{n}\)</span>,仍然很不优秀.</p>
<p>考虑使用生日悖论优化,随机<span class="math inline">\(k\)</span>个数<span class="math inline">\(a\)</span>.两两匹配得到<span class="math inline">\(k^2\)</span>个值,这些值全都不整除<span class="math inline">\(n\)</span>的概率可以用生日悖论来计算.</p>
<p>当<span class="math inline">\(k=10\sqrt{n}\)</span>时,错误的概率会很小,但是复杂度仍然很高,无法接受.</p>
<p>考虑构造<span class="math inline">\(a_i=[(a_{i-1})^2+b]\mod
n\)</span>.</p>
<p>考虑该数列的性质,当<span class="math inline">\(b\)</span>确定时,<span class="math inline">\(a\)</span>一定有循环节.</p>
<p>显然当<span class="math inline">\(x|(a_i-a_j)\)</span>,则<span class="math inline">\(x|[(a_i-a_j)\times(a_i+a_j)-b+b]\)</span>,<span class="math inline">\(x|(a_{i+1}-a_{j+1})\)</span>.</p>
<p>因此,我们可以利用floyd判环法(双指针法)找出循环节.</p>
<p>并且在这个过程中,我们可以预处理出大量的<span class="math inline">\(a_{i+len}-a_i\)</span>.</p>
<p>复杂度极其玄学,但是实际应用中不差.</p>
<h4><span id="狄利克雷前缀和">狄利克雷前缀和</span></h4>
<p>已知数列<span class="math inline">\(a\)</span>,求数列<span class="math inline">\(b\)</span>满足<span class="math inline">\(b_n=\sum_{d|n}a_d\)</span>.</p>
<p>我们将一个数的质因数分解看作它的向量表示.更直接地,如果<span class="math inline">\(n=\prod_{i=1}^kp_i^{q_i}\)</span>,其中<span class="math inline">\(p_i\)</span>是第<span class="math inline">\(i\)</span>大的质数.我们将其写作向量<span class="math inline">\((q_1,q_2,...,q_k)\)</span>的形式,并做高位前缀和.</p>
<p>可以用<span class="math inline">\(O(n\log\log
n)\)</span>的时间复杂度解决问题.</p>
<h3><span id="阶乘">阶乘</span></h3>
<p>我们定义<span class="math inline">\(n!=\prod_{i=1}^ni\)</span>,特别地,<span class="math inline">\(0!=1\)</span>.</p>
<p>考虑估计<span class="math inline">\(n!\)</span>的大小,不难发现<span class="math inline">\((n!)^2=\prod_{i=1}^ni(n+1-i)\)</span>.</p>
<p>而函数<span class="math inline">\(y=i(n+1-i),i\in[1,n]\)</span>显然在<span class="math inline">\(i=1\)</span>和<span class="math inline">\(i=n\)</span>时取最小值,而在<span class="math inline">\(i=\cfrac{n+1}2\)</span>时取最大值.</p>
<p>那么我们有<span class="math inline">\(\prod_{i=1}^nn\leq (n!)^2\leq
\prod _{i=1}^n\cfrac{(n+1)^2}{4}\)</span>.</p>
<p>于是<span class="math inline">\(n^{\frac{n}2}\leq n!\leq
\cfrac{(n+1)^n}{2^n}\)</span>.</p>
<p>还有一种估计方式是考虑<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{n}{\sqrt[n]
n!}\)</span>,由Stolz定理及其推论,我们知道若<span class="math inline">\(a_n&gt;0,\frac{a_{n+1}}{a_n}=a\)</span>,那么<span class="math inline">\(\lim_{n\rightarrow
\infty}\sqrt[n]{a_n}=a\)</span>.而我们令<span class="math inline">\(a_n=\frac{n^n}{n!}\)</span>,<span class="math inline">\(\frac{a_{n+1}}{a_n}=(1+\frac{1}{n})^n\)</span>,所以<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{n}{\sqrt[n]{n!}}=e\)</span>,于是我们可以估计<span class="math inline">\(n!\sim (\frac{n}{e})^n\)</span>.</p>
<p>事实上有一种更准确的估计方法:<span class="math inline">\(n!\sim
\sqrt{2\pi n}(\cfrac{n}e)^n\)</span>.</p>
<p>考虑设<span class="math inline">\(\varepsilon_p(n!)\)</span>为<span class="math inline">\(n!\)</span>中质因子<span class="math inline">\(p\)</span>的个数,我们分析一下这个函数:</p>
<p>首先显然有:<span class="math inline">\(\varepsilon_p(n!)=\sum_{k\geq
1}\lfloor\cfrac{n}{p^k}\rfloor\leq\frac{n}{p-1}\)</span>.</p>
<p>我们考虑以<span class="math inline">\(v_p(n)\)</span>表示<span class="math inline">\(n\)</span>在<span class="math inline">\(p\)</span>进制下各位数字之和,不妨设第<span class="math inline">\(k\)</span>位数字为<span class="math inline">\(w\)</span>.那么这个数字对于最后的答案的贡献为<span class="math inline">\(w(p^{k-1}+p^{k-2}+...+1)=w\cfrac{p^k-1}{p-1}=\cfrac{wp^k-w}{p-1}\)</span>.求和得到<span class="math inline">\(\varepsilon_p(n!)=\cfrac{n-v_p(n)}{p-1}\)</span>.</p>
<h5><span id="example具体数学455">Example(《具体数学》4.55)</span></h5>
<p>令<span class="math inline">\(P_n=\prod
_{i=1}^ni!\)</span>,求证:<span class="math inline">\(P_n^4(n+1)\mid
P_{2n}\)</span>.</p>
<p>考虑对于每个质因子,分开考虑它在前者和后者内出现的次数.</p>
<p>我们不妨将<span class="math inline">\(p\)</span>和<span class="math inline">\(p^k\)</span>分开考虑,于是显然下面的式子是上面的式子成立的充分条件:
<span class="math display">\[
\sum_{m\geq
1}\sum_{i=1}^{2n}\lfloor\cfrac{i}{p^m}\rfloor\geq4\sum_{m\geq 1}
\sum_{i=1}^n\lfloor\cfrac{i}{p^m}\rfloor+[p^m\mid (n+1)]
\]</span> 我们不妨对上面这个式子使用数学归纳,也就是说它的充分条件是:
<span class="math display">\[
\lfloor\cfrac{2n-1}{p^m}\rfloor+\lfloor\cfrac{2n}{p^m}\rfloor\geq
4\lfloor\cfrac{n}{p^m}\rfloor+[n\equiv -1\pmod {p^m}]-[n\equiv 0\pmod
{p^m}]
\]</span> 这个式子,当<span class="math inline">\(1\leq n\leq
p^m\)</span>时显然成立.而当<span class="math inline">\(n\)</span>每增大<span class="math inline">\(p^m\)</span>的时候,左右两边同时增大<span class="math inline">\(4\)</span>,于是也是成立的,由此可以数学归纳.</p>
<h3><span id="互素">互素</span></h3>
<p>如果两个数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>满足<span class="math inline">\(\gcd(n,m)=1\)</span>,我们称他们互素,记作<span class="math inline">\(n\bot m\)</span>.</p>
<p>我们显然有这样两条性质:</p>
<ol type="1">
<li><span class="math inline">\(\cfrac{n}{\gcd(n,m)}\bot
\cfrac{m}{\gcd(n,m)}\)</span>.</li>
<li><span class="math inline">\(k\bot n\and k\bot m\Leftrightarrow k\bot
nm\)</span>.</li>
</ol>
<h5><span id="example1具体数学442">Example1(《具体数学》4.42)</span></h5>
<p>证明:如果两个分数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>满足<span class="math inline">\(n\bot m\)</span>且<span class="math inline">\(n&#39;\bot m&#39;\)</span>,则<span class="math inline">\((mn&#39;+m&#39;n)\bot(nn&#39;)\)</span>的充分必要条件是<span class="math inline">\(n\bot n&#39;\)</span>.</p>
<p>首先,如果<span class="math inline">\(\gcd(n,n&#39;)\ne
1\)</span>,显然不可能满足条件,必要性得证.</p>
<p>考虑充分性,如果<span class="math inline">\(n\bot
n&#39;\)</span>,则只需证明<span class="math inline">\(n\bot
(mn&#39;+m&#39;n)\and n&#39;\bot (mn&#39;+m&#39;n)\)</span>即可.</p>
<p>而<span class="math inline">\(\gcd(n,mn&#39;+m&#39;n)=\gcd(n,mn&#39;)=1\)</span>,另一个式子同理,于是得证.</p>
<h5><span id="example2">Example2</span></h5>
<p>证明:<span class="math inline">\(\sum_{0\leq
k&lt;m}f(k)=\sum_{d|m}\sum_{0\leq k&lt;d}f(\frac{km}{d})[k\bot
d]\\\)</span>.</p>
<p>考虑: <span class="math display">\[
\sum_{0\leq k&lt;m}f(k)=\sum_{d|m}\sum_{0\leq
k&lt;m,d|k}f(k)[\gcd(k,m)=d]\\
=\sum_{d|m}\sum_{0\leq k&lt;m,d|k}f(k)[\frac{k}{d}\bot \frac{m}{d}]\\
=\sum_{d|m}\sum_{0\leq k&lt;\frac{m}d}f(kd)[k\bot \frac{m}{d}]\\
=\sum_{d|m}\sum_{0\leq k&lt;d}f(\frac{km}{d})[k\bot d]
\]</span></p>
<h5><span id="example3具体数学463">Example3(《具体数学》4.63)</span></h5>
<p>证明:满足<span class="math inline">\(a^n+b^n=
c^n(n\in\mathbb{N_+},n&gt;2)\)</span>的最小的(<span class="math inline">\(n\)</span>为第一关键字,<span class="math inline">\(c\)</span>为第二关键字)一组正整数解(即费马大定理最小的反例)一定满足以下性质:(另外,<span class="math inline">\(n=4\)</span>的情况早被证明了无解)</p>
<ol type="1">
<li><span class="math inline">\(n\in prime\)</span>.</li>
<li><span class="math inline">\(\exists m\in
\mathbb{N_+},a+b=\begin{cases}m^n &amp; n\nmid c\\n^{n-1}m^n&amp;n\mid
c\end{cases}\)</span>.</li>
</ol>
<p>首先证明(1),如果<span class="math inline">\(n\)</span>是最小的满足条件的数但并不是质数,我们不妨设<span class="math inline">\(n=xy,x&gt;2\)</span>,则<span class="math inline">\((a^y)^x+(b^y)^x=(c^y)^x\)</span>,显然这是更小的一组反例,于是(1)得证.</p>
<p>接下来考虑性质(2),注意到<span class="math inline">\(a,b,c\)</span>必然两两互质,不然可以两边同时除以一个数构造出更小的解,又注意到:
<span class="math display">\[
\gcd(a+b,\cfrac{a^n+b^n}{a+b})=\gcd(a+b,(a^{n-1}-a^{n-2}b+...+b^{n-1}))\\
\gcd(a+b,\cfrac{c^n}{a+b})=\gcd(a+b,na^{n-1})\\
\gcd(a+b,\cfrac{c^n}{a+b})=\gcd(a+b,n)
\]</span> 如果<span class="math inline">\(\gcd(a+b,n)=1\)</span>,那么我们有<span class="math inline">\((a+b)\bot
\cfrac{c^n}{a+b}\)</span>.接下来考虑每一个质因子<span class="math inline">\(p\)</span>,如果<span class="math inline">\((a+b)\)</span>中有<span class="math inline">\(x\)</span>个<span class="math inline">\(p\)</span>,<span class="math inline">\(c\)</span>中有<span class="math inline">\(y\)</span>个<span class="math inline">\(p\)</span>,于是<span class="math inline">\(c^n\)</span>中有<span class="math inline">\(ny\)</span>个<span class="math inline">\(p\)</span>,我们自然有:<span class="math inline">\(x=ny\)</span>,于是<span class="math inline">\(\exists m\in \mathbb{N_+}\)</span>满足<span class="math inline">\(a+b=m^n\)</span>.</p>
<p>如果<span class="math inline">\(n\mid (a+b)\)</span>,我们就有:<span class="math inline">\(\gcd(a+b,\cfrac{c^n}{a+b})=n\)</span>,此时必有<span class="math inline">\(n\mid c\)</span>,<span class="math inline">\(n^n\mid c^n\)</span>,并且不难发现:<span class="math inline">\(n^k\mid \cfrac{c^n}{a+b}\Leftrightarrow
n^{n-k}\mid (a+b)\)</span>,由于上面提到的<span class="math inline">\(\gcd\)</span>的原因,<span class="math inline">\(\min\{k,n-k\}=1\)</span>,显然<span class="math inline">\(k=1\)</span>或者<span class="math inline">\(k=n-1\)</span>.下面只需要证明<span class="math inline">\(k\ne n-1\)</span>.</p>
<p>冷静一下,如果<span class="math inline">\(n|(a+b),n^2\nmid
(a+b)\)</span>,令<span class="math inline">\(m=a+b\)</span>,此时必有:
<span class="math display">\[
c^n=a^n+(m-a)^n\\
=a^n+(-a)^n+nm(-a)^{n-1}+\frac{n(n-1)}{2}m^2(-a)^{n-2}+\cdots
\]</span> 注意到<span class="math inline">\(n\)</span>是奇数,<span class="math inline">\(a^n+(-a)^n=0\)</span>,而<span class="math inline">\(n^n|c^n\Rightarrow n^3|c^n\)</span>,又注意到<span class="math inline">\(n^3|nm^2\)</span>,我们把两边对<span class="math inline">\(n^3\)</span>取模: <span class="math display">\[
0\equiv nx(-a)^{n-1}\pmod {n^3}
\]</span> 注意到若<span class="math inline">\(n^2\nmid
m\)</span>,则该式子必不成立.</p>
<h4><span id="stern-brocot-树">Stern-Brocot 树</span></h4>
<p>Stern-Brocot树是一种可以不重不漏列举有理数的方式,它的构造如下:</p>
<p>一开始,序列中有两个分数:<span class="math inline">\(\cfrac{0}{1}\)</span>和<span class="math inline">\(\cfrac{1}{0}\)</span>,这里使用了<span class="math inline">\(0\)</span>作分母,但我们暂且认为它是正确的,因为这样会出现很多方便的性质.</p>
<p>接下来,不断地对这个序列进行以下操作:在两个相邻的分数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>之间插入一个新分数<span class="math inline">\(\cfrac{m+m&#39;}{n+n&#39;}\)</span>.</p>
<p>这么无限构造下去得到的序列满足两个性质:</p>
<ol type="1">
<li>所得到的分数全都是最简分数.</li>
<li>所得到的分数不重不漏,换句话说,任意非负有理数都在这个序列中出现恰好一次.</li>
</ol>
<p>我们不妨认为<span class="math inline">\(\cfrac{1}{0}=+\infty\)</span>,那么不难发现这么构造序列,所得到的序列一定是单调递增的.</p>
<p>这是因为如果我们有<span class="math inline">\(\cfrac{m}{n}&lt;\cfrac{m&#39;}{n&#39;}\)</span>,那么我们一定有:<span class="math inline">\(\cfrac{m}{n}&lt;\cfrac{m+m&#39;}{n+n&#39;}&lt;\cfrac{m&#39;}{n&#39;}\)</span>,其中<span class="math inline">\(n,n&#39;,m,m&#39;\geq0\)</span>,这一点不难验证.</p>
<p>而正因为如此,我们可以证明所得到的所有分数不重.</p>
<p>然后,如果当前所得到的序列中有两个数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>相邻,则<span class="math inline">\(m&#39;n-mn&#39;=1\)</span>,这一点不难通过数学归纳证明.而根据裴蜀定理,显然<span class="math inline">\(m\bot n\)</span>且<span class="math inline">\(m&#39;\bot n&#39;\)</span>.</p>
<p>我们最后需要证明任意非负有理数都可以通过这个序列构造出来,考虑类似二分的方法构造.换句话说,我们有两个序列中的分数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>,要构造的有理数为<span class="math inline">\(\cfrac ab\)</span>且满足<span class="math inline">\(\cfrac{m}n&lt;\cfrac a b&lt;\cfrac
{m&#39;}{n&#39;}\)</span>.</p>
<p>我们考虑判断<span class="math inline">\(\cfrac{m+m&#39;}{n+n&#39;}\)</span>与<span class="math inline">\(\cfrac{a}{b}\)</span>的大小关系,这样就可以类似二分的方法一直往下找下去.</p>
<p>问题在于为什么我们最后一定可以找到这个数呢?如果我们一直找不到这个数,意味着无论我们怎么做,都有<span class="math inline">\(\cfrac{m}n&lt;\cfrac a b&lt;\cfrac
{m&#39;}{n&#39;}\)</span>成立,而这也就意味着<span class="math inline">\(an-bm\geq 1\and bm&#39;-an&#39;\geq
1\)</span>,处理一下不等式并合并,我们有<span class="math inline">\((m&#39;+n&#39;)(an-bm)+(n+m)(bm&#39;-an&#39;)\geq
n+m+n&#39;+m&#39;\)</span>.</p>
<p>化简这个式子得到<span class="math inline">\(a+b\geq
m&#39;+n&#39;+m+n\)</span>,而我们在操作过程中<span class="math inline">\(m,n,m&#39;,n&#39;\)</span>显然会有两个数不变,另外两个数变大,因此迟早会大于<span class="math inline">\(a+b\)</span>,也就意味着这个数迟早会被找到.</p>
<p>之所以称其为”树”,则是因为我们如果每次都在任意两个数之间插入一个数,然后将进行若干次操作得到的序列放到二叉搜索树上,会得到一些很好的性质,譬如一个数是由它所有祖先中最大的小于它的数和最小的大于它的数生成的,以及关于根中心对称的两点互为倒数.</p>
<p>另外,如果我们定义法里级数<span class="math inline">\(\mathcal{F}_n\)</span>表示所有在<span class="math inline">\([0,1]\)</span>范围内且分母小于等于<span class="math inline">\(n\)</span>的最简分数的集合.不难发现,<span class="math inline">\(\mathcal{F}_n\)</span>对应着整棵树的一棵子树的一部分.而<span class="math inline">\(\mathcal{F}_n\)</span>可以由<span class="math inline">\(\mathcal{F}_{n-1}\)</span>得到,只需要判断<span class="math inline">\(\mathcal
F_{n-1}\)</span>中每两个相邻数能否生成一个满足条件的数即可.</p>
<p>我们回到它的树形态上,如果我们定义<span class="math inline">\(\cfrac 1
1\)</span>为这棵二叉搜索树的根,那么每个有理数显然都可以表示为从根到它的一个<span class="math inline">\(LR\)</span>序列,表示从根向下搜索时每一步向左走还是向右走.特别地,我们定义根的序列为<span class="math inline">\(I\)</span>.</p>
<p>不难发现,通过这样的操作,我们将每一个非负有理数都对应到了一个<span class="math inline">\(LR\)</span>序列.</p>
<p>那么我们来考虑第一个问题:已知<span class="math inline">\(LR\)</span>序列如何求这个数.</p>
<p>我们可以设当前点是<span class="math inline">\(x\)</span>,且它由<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>生成,其中<span class="math inline">\(y&lt;x&lt;z\)</span>,那么不难发现它的右儿子由<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>生成,左儿子由<span class="math inline">\(y\)</span>和<span class="math inline">\(x\)</span>生成.</p>
<p>那么我们显然可以使用记录<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>的方式,反复迭代求得答案.注意<span class="math inline">\(x\)</span>是可以通过<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>求得的,因此没有必要存储.</p>
<p>而这一过程可以简化为矩阵运算:</p>
<p>我们令<span class="math inline">\(y=\cfrac{m}n\)</span>,<span class="math inline">\(z=\cfrac{m&#39;}{n&#39;}\)</span>,<span class="math inline">\(S=\begin{bmatrix}n&amp;n&#39;\\m&amp;m&#39;\end{bmatrix}\)</span>,<span class="math inline">\(f(S)=\cfrac{m+m&#39;}{n+n&#39;}\)</span>.</p>
<p>那么不难发现它的每一次操作只需右乘一个变换矩阵即可.</p>
<p>其中:<span class="math inline">\(L=\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix},R=\begin{bmatrix}1
&amp;0\\1&amp;1\end{bmatrix}\)</span>.</p>
<p>使用数学归纳不难证明:</p>
<p><span class="math inline">\(L^k=\begin{bmatrix}1&amp;k\\0&amp;1\end{bmatrix},R^k=\begin{bmatrix}1
&amp;0\\k&amp;1\end{bmatrix}\)</span>.</p>
<p>至于已知数字求它的序列表示,首先可以直接在树上搜索.</p>
<p>而如果要脱离树,我们仍然可以回到矩阵上,意识到<span class="math inline">\(f(RS)=f(S)+1\)</span>,再加上关于根中心对称两点互为倒数的性质,我们可以推导出以下法则:</p>
<p>如果<span class="math inline">\(m&gt;n\)</span>,那么<span class="math inline">\(f(RS)=\cfrac{m}{n}\Leftrightarrow
f(S)=\cfrac{m-n}{n}\)</span>.</p>
<p>如果<span class="math inline">\(m&lt;n\)</span>,那么<span class="math inline">\(f(LS)=\cfrac{m}n\Leftrightarrow
f(S)=\cfrac{m}{n-m}\)</span>.</p>
<p>借助这一点,我们就可以求一个数的<span class="math inline">\(LR\)</span>序列表示了.</p>
<p>在某些情形下,这种表示可以解决二进制下某些分数无法精确表示的问题.</p>
<h4><span id="升幂引理">升幂引理</span></h4>
<h5><span id="形式一">形式一</span></h5>
<p>对于素数<span class="math inline">\(p\)</span>,<span class="math inline">\(p\nmid x,p\nmid y\)</span>,对于满足<span class="math inline">\(\gcd(n,p)=1\)</span>的<span class="math inline">\(n\)</span>:</p>
<ol type="1">
<li>若<span class="math inline">\(p|(x-y)\)</span>,则<span class="math inline">\(v_p(x^n-y^n)=v_p(x-y)\)</span>.</li>
<li>若<span class="math inline">\(p|(x+y)\)</span>,<span class="math inline">\(n\)</span>是奇数,则<span class="math inline">\(v_p(x^n+y^n)=v_p(x+y)\)</span>.</li>
</ol>
<p>考虑(1)的证明,由于<span class="math inline">\(p|(x-y),x\equiv y\pmod
p\)</span>,因此<span class="math inline">\(\sum_{k=0}^{n-1}x^ky^{n-1-k}\equiv nx^{n-1}\ne
0\pmod p\)</span>.有次方差公式,显然.</p>
<p>(2)类似.</p>
<h5><span id="形式二">形式二</span></h5>
<p>对于奇素数<span class="math inline">\(p\)</span>,<span class="math inline">\(p\nmid x,p\nmid y\)</span>:</p>
<ol type="1">
<li>若<span class="math inline">\(p|(x-y)\)</span>,则<span class="math inline">\(v_p(x^n-y^n)=v_p(x-y)+v_p(n)\)</span>.</li>
<li>若<span class="math inline">\(p|(x+y)\)</span>,<span class="math inline">\(n\)</span>是奇数,则<span class="math inline">\(v_p(x^n+y^n)=v_p(x+y)+v_p(n)\)</span>.</li>
</ol>
<p>和形式一的证明完全类似.</p>
<h3><span id="同余">同余</span></h3>
<p>如果<span class="math inline">\(a\mod m=b\mod m\)</span>,我们称<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>关于模<span class="math inline">\(m\)</span>同余,记作<span class="math inline">\(a\equiv b(\mod m)\)</span>.</p>
<p>根据同余的定义,若<span class="math inline">\(a,b,c,d,k\in
\mathbb{Z}\)</span>,<span class="math inline">\(n,m\in\mathbb{N_+}\)</span>,我们有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(a\equiv b\pmod m\Leftrightarrow
a-b=km\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\and c\equiv d\pmod
m\Rightarrow a+c\equiv b+d\pmod m\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\and c\equiv d\pmod
m\Rightarrow ac\equiv bd\pmod m\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\Rightarrow a^k\equiv
b^k\pmod m\)</span>.</li>
<li><span class="math inline">\(ad\equiv bd\pmod m\Leftrightarrow
a\equiv b\pmod m,m\bot d\)</span>.</li>
<li><span class="math inline">\(ad\equiv bd\pmod {md}\Leftrightarrow
a\equiv b\pmod m,d\ne 0\)</span>.</li>
<li><span class="math inline">\(ad\equiv bd\pmod m\Leftrightarrow
a\equiv b\pmod {\cfrac{m}{\gcd(m,d)}}\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod {md}\Rightarrow a\equiv
b\pmod m,d\ne 0\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\and a\equiv b\pmod
n\Leftrightarrow a\equiv b\pmod {lcm(n,m)}\)</span>.</li>
</ol>
<p>我们考虑第五条的证明:由于<span class="math inline">\(m\bot
d\)</span>,则根据扩展欧几里得算法,可以求得一个数<span class="math inline">\(d&#39;\)</span>满足<span class="math inline">\(dd&#39;+mm&#39;=1\)</span>,也就是<span class="math inline">\(dd&#39;\equiv 1(\mod
m)\)</span>,那么如果我们有<span class="math inline">\(ad\equiv bd(\mod
m)\)</span>,只需要两边同时乘以<span class="math inline">\(d&#39;\)</span>就可以得到右边.值得一提的是,我们通常称<span class="math inline">\(d&#39;\)</span>是<span class="math inline">\(d\)</span>在模<span class="math inline">\(m\)</span>意义下的逆元,记作<span class="math inline">\(inv(d,m)\)</span>或<span class="math inline">\(d^{-1}\)</span>.</p>
<p>逆元有一种线性预处理的求法:</p>
<p>考虑<span class="math inline">\(1\leq i\leq n\)</span>,设<span class="math inline">\(p=ki+r\)</span>,则有<span class="math inline">\(ki+r\equiv 0(\mod p)\)</span>,则有<span class="math inline">\(kr^{-1}+i^{-1}\equiv 0(\mod p)\)</span>.</p>
<p>于是有<span class="math inline">\(i^{-1}\equiv -kr^{-1}(\mod
p)\)</span>,即<span class="math inline">\(i^{-1}\equiv
-\lfloor\cfrac{p}{i}\rfloor\times r^{-1}(\mod p)\)</span>.</p>
<p>现在,我们给出一个结论:数列<span class="math inline">\(0\mod m,n\mod
m,2n\mod m,...,(m-1)n\mod m\)</span>在排序去重后恰好为数列<span class="math inline">\(0,d,2d,...,m-d\)</span>,<span class="math inline">\(d=\gcd(n,m)\)</span>,而且其中每个数字在原数列中恰好出现了<span class="math inline">\(d\)</span>次.</p>
<p>恰好出现<span class="math inline">\(d\)</span>次是好证明的:考虑<span class="math inline">\(jn\equiv kn(\mod m)\)</span>可以推导出<span class="math inline">\(j\equiv k(\mod
\cfrac{m}d),d=\gcd(n,m)\)</span>,则显然这些数是一个序列复制<span class="math inline">\(d\)</span>次得到的.</p>
<p>由上,我们要证明<span class="math inline">\(kn\mod
m\)</span>一定是<span class="math inline">\(d\)</span>的倍数.不难发现<span class="math inline">\(kn\mod m=dk\cfrac{n}d(\mod \cfrac m d
d)=d(\cfrac{kn}d\mod \cfrac{m}d)\)</span>.</p>
<p>接下来,不妨假设<span class="math inline">\(n\bot
m\)</span>,并在此条件下证明<span class="math inline">\(0\mod m,n\mod
m,2n\mod m,...,(m-1)n\mod m\)</span>两两不同即可.而由于<span class="math inline">\(n\bot m\)</span>,则<span class="math inline">\(kn\equiv jn(\mod m)\)</span>的充分必要条件是<span class="math inline">\(k\equiv j(\mod
m)\)</span>,因此它们显然两两不同.</p>
<h5><span id="example具体数学431">Example(《具体数学》4.31)</span></h5>
<p><span class="math inline">\(n\)</span>进制下,各位数字之和是<span class="math inline">\(m\)</span>的倍数,则这个数是<span class="math inline">\(m\)</span>的倍数的充分必要条件是?</p>
<p>令<span class="math inline">\(a_i\)</span>表示这个数字在<span class="math inline">\(n\)</span>进制下的第<span class="math inline">\(i\)</span>位,则这条性质也就是: <span class="math display">\[
\sum_{i=0}a_in^i\equiv 0\pmod m\Leftrightarrow\sum_{i=0}a_i\equiv 0\pmod
m
\]</span> 不难发现,当<span class="math inline">\(n\equiv 1\pmod
m\)</span>时,满足该性质.</p>
<h4><span id="威尔逊定理">威尔逊定理</span></h4>
<p><span class="math inline">\((p-1)!\equiv \begin{cases}
-1(\mod p)&amp;p\in prime\\
2(\mod p)&amp;p=4\\
0(\mod p)&amp;other
\end{cases}\)</span></p>
<p>证明:</p>
<p>当<span class="math inline">\(p\)</span>为质数时，考虑对于<span class="math inline">\(a\)</span>和<span class="math inline">\(b=a^{-1}(\mod p)\)</span>,若<span class="math inline">\(a=b\)</span>,此时可证明<span class="math inline">\(a=1\)</span>或<span class="math inline">\(a=p-1\)</span>(需要用到下面独立剩余知识).</p>
<p>如果<span class="math inline">\(a\ne b\)</span>那么一定可以在<span class="math inline">\([1,p-1]\)</span>找到一对数,它们相乘为<span class="math inline">\(1\)</span>.原因是若<span class="math inline">\(a_1\ne a_2\)</span>,那么<span class="math inline">\(a_1^{-1}\ne a_2^{-1}\)</span>.</p>
<p>若<span class="math inline">\(p\)</span>不是质数,则设<span class="math inline">\(p=ab\)</span>,当<span class="math inline">\(a\ne
b\)</span>时,由于<span class="math inline">\(a,b\leq
p\)</span>,因此<span class="math inline">\((p-1)!\)</span>一定是<span class="math inline">\(p\)</span>的倍数.</p>
<p>若<span class="math inline">\(a=b\)</span>,除非<span class="math inline">\(p=4\)</span>,不然一定能在<span class="math inline">\([1,p-1]\)</span>里找到<span class="math inline">\(a\)</span>和<span class="math inline">\(2a\)</span>,此时<span class="math inline">\((p-1)!\)</span>也是<span class="math inline">\(p\)</span>的倍数.</p>
<p>另外,当<span class="math inline">\(p\)</span>是奇质数的时候,威尔逊定理可以写成如下形式:
<span class="math display">\[
\prod_{k=1}^{\frac{p-1}{2}}k(p-k)\equiv -1\pmod p\\
\prod_{k=1}^{\frac{p-1}2}-k^2\equiv -1\pmod p\\
(-1)^{\frac{p-1}{2}}((\cfrac{p-1}{2})!)^2\equiv -1\pmod p
\]</span></p>
<p>另外,通过以上推导过程,不难发现威尔逊定理还可以写成: <span class="math display">\[
(p-2)!\equiv \begin{cases}
1(\mod p)&amp;p\in prime\\
2(\mod p)&amp;p=4\\
0(\mod p)&amp;other
\end{cases}
\]</span></p>
<h5><span id="example1具体数学448">Example1(《具体数学》4.48)</span></h5>
<p>求<span class="math inline">\(\prod_{1\leq n&lt;m,n\bot m}n\pmod
m\\\)</span>.</p>
<p>首先,类似威尔逊定理的推导,不难注意到这个式子也就等价于: <span class="math display">\[
\prod_{1\leq n&lt;m,n^2\equiv 1\pmod m}n\pmod m
\]</span> 首先考虑满足<span class="math inline">\(n^2\equiv 1\pmod
m\)</span>的<span class="math inline">\(n\)</span>满足什么性质,根据我们在二次剩余的推导,先考虑<span class="math inline">\(2\nmid m\)</span>的情况,此时我们将<span class="math inline">\(m\)</span>分解为了若干个形如<span class="math inline">\(p^k\)</span>的质因数的乘积,对于每个<span class="math inline">\(p^k\)</span>作为模数时,<span class="math inline">\(n\)</span>有两个解:<span class="math inline">\(1\)</span>和<span class="math inline">\(p^k-1\)</span>.</p>
<p>当<span class="math inline">\(m=p^k\)</span>的时候,显然答案就是<span class="math inline">\(-1\)</span>.</p>
<p>不然,由于此时有很多解,我们考虑设答案为<span class="math inline">\(ans\)</span>并对于每个<span class="math inline">\(p^k\)</span>求出$ans <span class="math inline">\(的答案,再使用中国剩余定理合并.不难发现只要\)</span>m<span class="math inline">\(有多个不同的质因子,那么中国剩余定理合并的时候,一定会有偶数个\)</span>n<span class="math inline">\((事实上,假设\)</span>m<span class="math inline">\(有\)</span>a$个质因子,那么有<span class="math inline">\(2^{a-1}\)</span>个这样的<span class="math inline">\(n\)</span>)满足<span class="math inline">\(n\equiv
-1\pmod {p^k}\)</span>,也有同样数目的<span class="math inline">\(n\)</span>满足<span class="math inline">\(n\equiv
1\pmod {p^k}\)</span>.那么此时的<span class="math inline">\(ans\equiv
1\pmod {p^k}\)</span>.多次合并后的<span class="math inline">\(ans\)</span>显然还是<span class="math inline">\(1\)</span>.</p>
<p>至于<span class="math inline">\(2\mid
m\)</span>的情况并没有麻烦很多,当<span class="math inline">\(2\mid m\and
4\nmid m\)</span>,显然有没有这个<span class="math inline">\(2\)</span>作为质因子都一样.当<span class="math inline">\(4\mid m\and 8\nmid
m\)</span>,这个质因子和其它质因子并没有多少区别.</p>
<p>于是我们最后得到结论: <span class="math display">\[
\prod_{1\leq n&lt;m,n\bot m}n\equiv \begin{cases}
-1\pmod m&amp;m=p^k\or m=2p^k\or m=4,p\in prime\and p\ne 2\\
1\pmod m&amp;other\\
\end{cases}
\]</span></p>
<h5><span id="example2具体数学440">Example2(《具体数学》4.40)</span></h5>
<p>如果我们设<span class="math inline">\(n=\sum_{k\geq
0}a_kp^k\)</span>,求证:<span class="math inline">\(\cfrac{n!}{p^{\varepsilon_p(n!)}}=(-1)^{\varepsilon_p(n!)}\prod_{k\geq
0}a_k!\pmod p\)</span>.</p>
<p>证明考虑数学归纳:如果<span class="math inline">\(n\rightarrow
n+1\)</span>的过程中没有发生进位,那么该公式显然成立.</p>
<p>如果发生进位了,假设进到了第<span class="math inline">\(k\)</span>位,第<span class="math inline">\(k\)</span>位原本是<span class="math inline">\(w\)</span>,现在是<span class="math inline">\(w+1\)</span>,那么要证其对于<span class="math inline">\(n+1\)</span>成立,即证明下式成立: <span class="math display">\[
\cfrac{n!(n+1)}{p^{\varepsilon_p(n!)+k}}=(-1)^{\varepsilon_p(n!)+k}(w+1)!\prod_{i\geq
k+1}a_i!\pmod p
\]</span> 考虑<span class="math inline">\((p-1)\equiv -1\pmod
p\)</span>,于是上式也即: <span class="math display">\[
\cfrac{n!(n+1)}{p^{\varepsilon_p(n!)+k}}=(-1)^{\varepsilon_p(n!)}(w+1)\prod_{i\geq
0}a_i!\pmod p\\
\cfrac{n!}{p^{\varepsilon_p(n!)}}\cfrac{n+1}{p^k}=(-1)^{\varepsilon_p(n!)}(w+1)\prod_{i\geq
0}a_i!\pmod p\\
\cfrac{n!}{p^{\varepsilon_p(n!)}}(w+1)=(-1)^{\varepsilon_p(n!)}(w+1)\prod_{i\geq
0}a_i!\pmod p
\]</span> 于是化到<span class="math inline">\(n\)</span>的情况,于是<span class="math inline">\(n+1\)</span>时该式子成立.</p>
<h5><span id="example3具体数学453">Example3(《具体数学》4.53)</span></h5>
<p>求所有满足<span class="math inline">\(n|\lceil\cfrac{(n-1)!}{n+1}\rceil\)</span>的整数<span class="math inline">\(n\)</span>.</p>
<p>首先这个形式看上去就是威尔逊定理的形式,所以第一步我们先暴力验证<span class="math inline">\(n\in[1,4]\)</span>的答案,注意到此时当且仅当<span class="math inline">\(n=1\)</span>时成立.接下来我们尝试找到<span class="math inline">\(n\geq 5\)</span>时的解.</p>
<p>考虑当<span class="math inline">\(n+1\in
prime\)</span>时,根据威尔逊定理,要求化为:<span class="math inline">\(n\mid\cfrac{(n-1)!+n}{n+1}\)</span>.注意到此时<span class="math inline">\(n\)</span>一定不是质数,又因为<span class="math inline">\(n\bot (n+1)\)</span>,于是要求化为<span class="math inline">\(n\mid {(n-1)!+n}\)</span>,显然成立.</p>
<p>当<span class="math inline">\(n+1\notin
prime\)</span>时,要求则化为<span class="math inline">\(n\mid
\cfrac{(n-1)!}{n+1}\)</span>.当<span class="math inline">\(n\in
prime\)</span>时,显然不成立.反之显然成立.</p>
<p>于是要么<span class="math inline">\(n=1\)</span>,要么<span class="math inline">\(n\geq 5\and n\notin prime\)</span>.</p>
<h4><span id="费马小定理">费马小定理</span></h4>
<p><span class="math inline">\(n^{p-1}\equiv 1(\mod p),n\bot p,p\in
prime\)</span>.</p>
<p>我们有: <span class="math display">\[
\prod _{k=1}^{p-1}kn\equiv \prod _{k=1}^{p-1}(kn\mod p)(\mod p)\\
n^{p-1}(p-1)!\equiv (p-1)!(\mod p)
\]</span> 根据威尔逊定理,显然可以推得费马小定理.</p>
<p>根据费马小定理,我们可以考虑证明一个结论:<span class="math inline">\(n^{p^k}\equiv n^{p^{k-1}}(\mod p^k)\)</span>.</p>
<p>由于<span class="math inline">\(n^{p-1}\equiv 1(\mod
p)\)</span>,那么我们有<span class="math inline">\(n^p\equiv n(\mod
p)\)</span>,也即<span class="math inline">\(\exist
q\in\mathbb{Z}\)</span>满足<span class="math inline">\(n^p=n+pq\)</span>,不断两边取<span class="math inline">\(p\)</span>次方即可得到上述结论.</p>
<p>另外,费马小定理还可以如下证明:</p>
<p>考虑证明<span class="math inline">\(n^p\equiv n\pmod
p\)</span>,也就是要证明<span class="math inline">\((\sum_{i=1}^n1)^p\equiv n\pmod p\)</span>.</p>
<p>注意到根据多项式定理,<span class="math inline">\((\sum_{i=1}^n1)^p=\sum_{\sum
a=p}\cfrac{p!}{a_1!...a_n!}\)</span>.而如果<span class="math inline">\(\max\{a\}\ne p\)</span>,则后面的式子在<span class="math inline">\(\mod p\)</span>意义下显然为<span class="math inline">\(0\)</span>,不然,考虑<span class="math inline">\(\max\{a\}=p\)</span>的序列一共会出现<span class="math inline">\(n\)</span>次且每次对答案的贡献都是<span class="math inline">\(1\)</span>,自然有<span class="math inline">\(n^p\equiv n(\mod p)\)</span>.</p>
<h5><span id="example1具体数学441">Example1(《具体数学》4.41)</span></h5>
<p>求证:如果质数<span class="math inline">\(p\)</span>满足<span class="math inline">\(p\equiv 3\pmod 4\)</span>,则不存在整数<span class="math inline">\(n\)</span>满足<span class="math inline">\(p|(n^2+1)\)</span>;如果其满足<span class="math inline">\(p\equiv 1\pmod 4\)</span>,则一定存在一个整数<span class="math inline">\(n\)</span>满足条件.</p>
<p>先考虑证明前半部分,如果存在这样一个整数<span class="math inline">\(n\)</span>,考虑<span class="math inline">\(p|(n^2+1)\)</span>也就等价于<span class="math inline">\(n^2\equiv -1\pmod p\)</span>,则<span class="math inline">\(n^4\equiv 1\pmod p\)</span>.显然<span class="math inline">\(p\bot n\)</span>,根据费马小定理,我们有<span class="math inline">\(n^{p-1}\equiv 1\pmod p\)</span>,也就有<span class="math inline">\(n^{p+1}\equiv -1\pmod p\)</span>.</p>
<p>而由于<span class="math inline">\(p\equiv 3\pmod 4\)</span>,所以<span class="math inline">\(4|(p+1)\)</span>,所以<span class="math inline">\(n^{p+1}\equiv 1\pmod
p\)</span>,不符,因此一定不存在.</p>
<p>反之,考虑威尔逊定理的变形<span class="math inline">\(\prod_{k=1}^{\frac{p-1}2}-k^2\equiv -1\pmod
p\\\)</span>.由于<span class="math inline">\(p-1\equiv 0\pmod
4\)</span>,所以这个式子也就等价于<span class="math inline">\(\prod
_{k=1}^{\frac{p-1}2}k^2\equiv -1\pmod p\)</span>,也就是<span class="math inline">\(((\cfrac{p-1}{2})!)^2\equiv -1\pmod
p\)</span>,这就是一个解.</p>
<h5><span id="example2具体数学446">Example2(《具体数学》4.46)</span></h5>
<p>求证:如果<span class="math inline">\(n&gt;1\)</span>,则<span class="math inline">\(2^n\ne 1\pmod n\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>是质数,根据费马小定理,显然得证.</p>
<p>不然,设<span class="math inline">\(n=pq\)</span>,且<span class="math inline">\(p\)</span>是<span class="math inline">\(n\)</span>的最小质因子,若<span class="math inline">\(2^{n}\equiv 1\pmod n\)</span>,则<span class="math inline">\(2^n\equiv 1\pmod p\)</span>.</p>
<p>若<span class="math inline">\(p=2\)</span>,显然不成立.不然,有<span class="math inline">\(2^{p-1}\equiv 1\pmod p\)</span>,由于<span class="math inline">\((p-1)\bot n\)</span>,则<span class="math inline">\(2^{\gcd(p-1,n)}\equiv 2\equiv 1\pmod
p\)</span>,显然不成立.</p>
<p>另外,上面的过程显然可以推广为:</p>
<p>如果<span class="math inline">\(n&gt;1\)</span>,则对于任意质数<span class="math inline">\(p\)</span>,<span class="math inline">\(p^n\ne
1\pmod n\)</span>.</p>
<h4><span id="中国剩余定理crt">中国剩余定理(crt)</span></h4>
<p>对于方程组<span class="math inline">\(x\equiv a_i(\mod
m_i)\)</span>,其中<span class="math inline">\(m_i\)</span>两两互质,求<span class="math inline">\(x\)</span>.</p>
<p>令<span class="math inline">\(m=\prod^k_{i=1}m_i\)</span>,设<span class="math inline">\(M_i=\cfrac{m}{m_i}\)</span>,<span class="math inline">\(N_i\)</span>是<span class="math inline">\(M_i\)</span>在<span class="math inline">\(\mod
m_i\)</span>意义下逆元.</p>
<p>则<span class="math inline">\(x\equiv \sum^k_{i=1}M_iN_ia_i(\mod
m)\)</span>.</p>
<p>中国剩余定理的证明类似拉格朗日插值:</p>
<p>由于<span class="math inline">\(x\)</span>在<span class="math inline">\(\mod m_i\)</span>意义下,<span class="math inline">\(\sum\)</span>中枚举的所有不等于<span class="math inline">\(i\)</span>的项都会成<span class="math inline">\(0\)</span>，等于<span class="math inline">\(i\)</span>的项会成<span class="math inline">\(a_i\)</span>.</p>
<p>考虑每次合并两项，显然有:<span class="math inline">\(a=a_1+(a_2-a_1)\times m_1\times
inv(m_1,m_2)\)</span>,<span class="math inline">\(m=m_1m_2\)</span>.</p>
<p>中国剩余定理的本质是一个环同构<span class="math inline">\(\varphi:\Z/m_1m_2\Z\rightarrow (\Z/m_1\Z)\times
(\Z/m_2\Z)\)</span>,当<span class="math inline">\(m_1\bot
m_2\)</span>.</p>
<p>由于映射两边都是大小相同的有限环,所以只需证明它是单射就行.而容易发现<span class="math inline">\(\ker \varphi=\{[1]\}\)</span>.</p>
<p>下面的扩展中国剩余定理亦然同理,用一下裴蜀定理证明映射两边的有限环大小相等,再注意到<span class="math inline">\(|\ker \varphi|=1\)</span>.</p>
<h4><span id="扩展中国剩余定理excrt">扩展中国剩余定理(excrt)</span></h4>
<p>对于方程组<span class="math inline">\(x\equiv a_i(\mod
m_i)\)</span>,若<span class="math inline">\(m_i\)</span>两两不互质.</p>
<p>我们考虑每次合并两个方程:<span class="math inline">\(\begin{cases}
x\equiv a_1(\mod m_1)\\
x\equiv a_2(\mod m_2)
\end{cases}\)</span> 那这个方程组等价于:<span class="math inline">\(\begin{cases}
x=k_1m_1+a_1\\
x=k_2m_2+a_2
\end{cases}\)</span> 合并上下方程,有: <span class="math display">\[
k_1m_1+a_1=k_2m_2+a_2\\
a_2-a_1=k_1m_1-k_2m_2
\]</span> 设<span class="math inline">\(g=\gcd(m_1,m_2)\)</span>,显然若<span class="math inline">\(g\nmid (a_2-a_1)\)</span>,方程无解.</p>
<p>不然,有: <span class="math display">\[
\frac {a_2-a_1}g=k_1\frac {m_1}{g}-k_2\frac{m_2}{g}\\
k_1\frac{m_1}{g}=k_2\frac {m_2}g+\frac {a_2-a_1}g\\
k_1\frac{m_1}g\equiv \frac {a_2-a_1}{g}(\mod \frac {m_2}g)\\
\]</span> 令<span class="math inline">\(inv(a,p)\)</span>表示<span class="math inline">\(a\)</span>在<span class="math inline">\(\mod
p\)</span>意义下的逆元,有: <span class="math display">\[
k_1\equiv inv(\frac {m_1}{g},\frac {m_2}g)\frac{a_2-a_1}{g}(\mod \frac
{m_2}g)\\
k_1=inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+k_3\frac{m_2}g\\
\]</span> 带回第一个方程: <span class="math display">\[
x=m_1(inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+k_3\frac{m_2}g)+a_1\\
x\equiv m_1inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+a_1(\mod
\frac{m_1m_2}g)
\]</span></p>
<h5><span id="example1noi2018屠龙勇士">Example1([NOI2018]屠龙勇士)</span></h5>
<p>考虑拿个set之类的维护,然后问题转化为求: <span class="math display">\[
\begin{cases}
b_1x\equiv a_1(\mod m_1)\\
b_2x\equiv a_2(\mod m_2)\\
...\\
b_nx\equiv a_n(\mod m_n)
\end{cases}
\]</span> 的一个<span class="math inline">\(x\)</span>的最小解.</p>
<p>对于一个式子<span class="math inline">\(b_ix\equiv a_i\pmod
{m_i}\)</span>,设<span class="math inline">\(g=\gcd(b_i,m_i)\)</span>,那么若<span class="math inline">\(g\nmid a_i\)</span>,显然无解;不然,我们有:<span class="math inline">\(\cfrac{b_i}{g}x\equiv \cfrac{a_i}g\pmod
{\cfrac{m_i}{g}}\)</span>,而<span class="math inline">\(\cfrac{b_i}{g}\bot
\cfrac{m_i}{g}\)</span>,可以求逆元.</p>
<h5><span id="example2cf571egeometricprogressions">Example2([CF571E]Geometric
Progressions)</span></h5>
<p>首先分解质因子,这样问题转化为判断等差数列中是否出现.我们随便挑一个数列,假设这个数列中第<span class="math inline">\(x\)</span>个数字是答案,显然最小化<span class="math inline">\(x\)</span>即可.</p>
<p>但是直接对所有质因子做excrt复杂度不可接受.我们考虑如果对于质因子<span class="math inline">\(p\)</span>,<span class="math inline">\(\exists
i,j\in[1,n],i\ne j\)</span>有<span class="math inline">\(p|b_j,p\nmid
a_i,p\nmid b_i\)</span>,显然无解.如果有<span class="math inline">\(p|b_j,p|a_i,p\nmid
b_i\)</span>,显然要么无解,要么有唯一解,而且可以快速求出唯一解是谁,直接验证就行.</p>
<p>这样,我们就保证了所有需要做excrt的质因子必然全部出现,容易发现这样的质因子数量很少.</p>
<h4><span id="二次剩余">二次剩余</span></h4>
<p>求方程<span class="math inline">\(x^2=k(\mod m)\)</span>的解.</p>
<p>我们先考虑一个特殊情况:<span class="math inline">\(k=1\)</span>,<span class="math inline">\(m=p^k,p\in prime\)</span>.</p>
<p>那么也就相当于求方程<span class="math inline">\((x-1)(x+1)\equiv
0(\mod p^k)\)</span>.</p>
<p>如果<span class="math inline">\(p&gt;2\)</span>,那么显然<span class="math inline">\(x-1\)</span>和<span class="math inline">\(x+1\)</span>只有一个能被<span class="math inline">\(p^k\)</span>整除,所以有<span class="math inline">\(x=\pm 1\)</span>.</p>
<p>如果<span class="math inline">\(p=2\)</span>,那么显然<span class="math inline">\(x-1\)</span>和<span class="math inline">\(x+1\)</span>有一个能被<span class="math inline">\(2\)</span>整除但不能被<span class="math inline">\(4\)</span>整除,另一个能被<span class="math inline">\(2^{k-1}\)</span>整除,如果<span class="math inline">\(k=1\)</span>时,显然只有一个解.当<span class="math inline">\(k=2\)</span>时,同上.反之,有<span class="math inline">\(x=\pm 1\)</span>或<span class="math inline">\(x=2^{k-1}\pm 1\)</span>.考虑一个性质:<span class="math inline">\((2k+1)^2\equiv 1(\mod 8)\)</span>.</p>
<p>那么如果:<span class="math inline">\(k=1,m\in\mathbb{N_+}\)</span>,也是一样的.先把<span class="math inline">\(m\)</span>作质因数分解,然后再用中国剩余定理合并,那么显然不同质数的解会累乘到总的解上,若<span class="math inline">\(m\)</span>有<span class="math inline">\(r\)</span>个不同大于<span class="math inline">\(2\)</span>的质因子,总的解的个数是<span class="math inline">\(2^r\)</span>.而如果考虑<span class="math inline">\(p=2\)</span>的情况,<span class="math inline">\(m\)</span>有<span class="math inline">\(r\)</span>个不同的质因子,则解的个数为<span class="math inline">\(2^{r+[8|m]+[4|m]-[2|m]}\)</span>.</p>
<p>下面开始讲正经的二次剩余.</p>
<p>我们称<span class="math inline">\(a\)</span>是<span class="math inline">\(p\)</span>的二次剩余,当且仅当<span class="math inline">\(\exists b,b^2\equiv a\pmod p\)</span>并且<span class="math inline">\(a\ne 0\pmod p\)</span>,这里的<span class="math inline">\(p\)</span>是奇素数,如果<span class="math inline">\(a\)</span>不是<span class="math inline">\(p\)</span>的倍数且<span class="math inline">\(\nexists b,b^2\equiv a\pmod
p\)</span>,则称为二次非剩余.我们引入勒让德符号来表示这个东西: <span class="math display">\[
\left(\frac{a}{p}\right)=\begin{cases}1&amp;a是二次剩余\\0&amp;a\equiv
0\pmod p\\-1&amp;a为二次非剩余\end{cases}
\]</span> 那么这玩意怎么求呢?我们有欧拉判别准则: <span class="math display">\[
\left(\frac{a}{p}\right)\equiv a^{\frac{p-1}{2}}\pmod p
\]</span> 先证明个引理:若<span class="math inline">\(g\)</span>为<span class="math inline">\(\bmod p\)</span>意义下的原根,且<span class="math inline">\(a\equiv g^k\)</span>,那么<span class="math inline">\(x^2\equiv a\pmod p\)</span>有解的充要条件是<span class="math inline">\(k\)</span>是偶数.</p>
<p>充分性显然,而必要性,我们考虑费马小定理:<span class="math inline">\(g^{p-1}\equiv 1\pmod p\)</span>,而<span class="math inline">\(p-1\)</span>是偶数,因此无论如何奇偶性都不会变.</p>
<p>接下来证明欧拉判别准则: <span class="math display">\[
g^{p-1}\equiv 1\pmod p\\
g^{p-1}-1\equiv 0\pmod p\\
(g^{\frac{p-1}{2}}+1)(g^{\frac{p-1}{2}}-1)\equiv 0\pmod p\\
g^{\frac{p-1}{2}}\equiv -1\pmod p\\
a^{\frac{p-1}{2}}=(g^k)^{\frac{p-1}{2}}=(g^{p-1})^{\frac{k}{2}}
\]</span> 于是得证.另外通过这个证明过程,我们可以发现<span class="math inline">\([1,p-1]\)</span>中有正好一半的数是二次剩余,我们还能得知<span class="math inline">\(x^2\equiv a\pmod p\)</span>的解的数量是<span class="math inline">\(\left(\frac{a}{p}\right)+1\\\)</span>.</p>
<h5><span id="example1cf1091gnewyear-and-the-factorisation-collaboration">Example1([CF1091G]New
Year and the Factorisation Collaboration)</span></h5>
<p>考虑随机一个<span class="math inline">\(x\)</span>,令<span class="math inline">\(x&#39;=\sqrt{x^2}\pmod n\)</span>,如果<span class="math inline">\(x&#39;=x\)</span>则放弃这次询问,不然自然有<span class="math inline">\((x&#39;-x)(x&#39;+x)\equiv 0\pmod n\)</span>.</p>
<p><span class="math inline">\(\forall p|n,p\in
prime\)</span>,注意到一定满足<span class="math inline">\(p|(x&#39;-x)\)</span>或<span class="math inline">\(p|(x&#39;+x)\)</span>,我们可以多做几次,可以理解为这样将<span class="math inline">\(n\)</span>随机分割了.</p>
<h5><span id="example2qoj5021">Example2(qoj5021)</span></h5>
<p>整个题就强调一个字:双射!</p>
<p>先把模数质因数分解.</p>
<p>从头开始看,这种多元组计数肯定要一点一点确定,我们考虑固定<span class="math inline">\((a,a&#39;)\)</span>求解<span class="math inline">\((b,b&#39;)\)</span>,这个时候发现只要<span class="math inline">\((a,a&#39;)\)</span>不全为<span class="math inline">\(0\)</span>,那么就有<span class="math inline">\(p\)</span>组<span class="math inline">\((b,b&#39;)\)</span>满足条件,这个可以通过移项求逆元发现.发现这个全为<span class="math inline">\(0\)</span>的条件很烦,我们先把它处理掉.</p>
<p>显然只有<span class="math inline">\(r=0\)</span>会出现这种情况,讨论一下<span class="math inline">\((a,a&#39;)\)</span>全为<span class="math inline">\(0\)</span>或<span class="math inline">\((b,b&#39;)\)</span>全为<span class="math inline">\(0\)</span>的情况,简单分类讨论可以得到共有<span class="math inline">\(2p^3+p^2-2p\)</span>种方案.</p>
<p>好了,困难的部分被我们解决了,不过这样我们需要多讨论一下<span class="math inline">\(r\)</span>是否等于<span class="math inline">\(0\)</span>,不过问题不大.</p>
<p>先考虑<span class="math inline">\(r=0\)</span>的情况:</p>
<p>注意到此时固定<span class="math inline">\((a,a&#39;)\)</span>会有<span class="math inline">\(p-1\)</span>组(有一组全<span class="math inline">\(0\)</span>)<span class="math inline">\((b,b&#39;)\)</span>满足条件,此时有方程<span class="math inline">\(\begin{cases}ac+a&#39;c&#39;\equiv 0\pmod
p\\bc+b&#39;c&#39;\equiv 0\pmod p\end{cases}\)</span>.显然若<span class="math inline">\((b,b&#39;)\equiv
k(a,a&#39;)\)</span>,那么该方程有<span class="math inline">\(p\)</span>组解,不然只有一组解.而前者相当于<span class="math inline">\((a,a&#39;)\)</span>满足<span class="math inline">\(ka^2+ka&#39;^2\equiv 0\)</span>,我们设<span class="math inline">\(C_k\)</span>是方程<span class="math inline">\(a^2+a&#39;^2\equiv k\pmod
p\)</span>的解的数量,把上面的全部加起来,答案是: <span class="math display">\[
(C_0-1)(p-1)p+((p^2-1)(p-1)-(C_0-1)(p-1))
\]</span> 化简一下得到:<span class="math inline">\((C_0-1)(p-1)^2+p^3-p^2-p+1\)</span>.</p>
<p>再考虑<span class="math inline">\(r\ne 0\)</span>的情况:</p>
<p>注意到此时不可能有全为<span class="math inline">\(0\)</span>的二元组了.所以固定<span class="math inline">\((a,a&#39;)\)</span>的话,<span class="math inline">\((b,b&#39;)\)</span>共有<span class="math inline">\(p\)</span>组解,此时有方程<span class="math inline">\(\begin{cases}ac+a&#39;c&#39;\equiv r\pmod
p\\bc+b&#39;c&#39;\equiv r\pmod p\end{cases}\)</span>.</p>
<p>若<span class="math inline">\((b,b&#39;)\equiv
k(a,a&#39;)\)</span>,显然当<span class="math inline">\(k=1\)</span>时有<span class="math inline">\(p\)</span>组解,否则无解,此时<span class="math inline">\(a^2+a&#39;^2\equiv r\pmod p\)</span>.</p>
<p>不然有唯一解.</p>
<p>而<span class="math inline">\((b,b&#39;)=k(a,a&#39;)\)</span>的方案有多少呢,显然是<span class="math inline">\(\sum_{k=1}^{p-1}C_{\frac{r}{k}}=\sum_{k=1}^{p-1}C_k=p^2-C_0\)</span>,这里用到了这篇题解的第一个双射,<span class="math inline">\([1,p-1]/k\mapsto [1,p-1]\)</span>.</p>
<p>于是这里的答案就是: <span class="math display">\[
C_rp+((p^2-1)p-(p^2-C_0))
\]</span> 化简一下得到<span class="math inline">\(p^3-p^2-p+C_0+C_rp\)</span>.</p>
<p>现在的问题是如何求<span class="math inline">\(C_0,C_r\)</span>.</p>
<p>先来技术总结一下,这种多元组计数通常要确定一些数字,然后对另一些数字进行计数,如果确定的那些数字不能进行枚举,那就得进行一些别的操作来在不同的情况下判断数量.</p>
<p>那么<span class="math inline">\(C_r\)</span>怎么求呢?考虑<span class="math inline">\(x^2\equiv a\pmod p\)</span>的解数为<span class="math inline">\(\left(\frac{a}{p}\right)+1\)</span>,我们有: <span class="math display">\[
C_r=\sum_{i=0}^{p-1}(\left(\frac{i}{p}\right)+1)(\left(\frac{r-i}{p}\right)+1)\\
=\sum_{i=0}^{p-1}\left(\frac{i(r-i)}{p}\right)+2\sum_{i=0}^{p-1}\left(\frac{i}{p}\right)+p\\
=\sum_{i=1}^{p-1}\left(\frac{\frac{r}{i}-1}{p}\right)+p
\]</span> <del>(这是干啥啊)</del></p>
<p>我们来一步一步分析这个式子是怎么得到的:</p>
<p>首先,第一步仍然是枚举其中一个,然后求另一个.然后将整个式子乘开,做一个双射<span class="math inline">\(r-[0,p-1]\mapsto
[0,p-1]\)</span>就可以合并其中两项,而至于前两项则是根据欧拉判别准则直接将上指标乘起来合并.然后我们发现<span class="math inline">\(\sum_{i=0}^{p-1}\left(\frac{i}{p}\right)=0\)</span>,因为<span class="math inline">\([0,p-1]\)</span>中一半是<span class="math inline">\(1\)</span>一半是<span class="math inline">\(-1\)</span>,又可以发现<span class="math inline">\(i=0\)</span>时显然为<span class="math inline">\(0\)</span>,<span class="math inline">\(x^2=i(r-i)\Leftrightarrow
(\frac{x}{i})^2=\frac{r}{i}-1\)</span>,做双射<span class="math inline">\([1,p-1]\times i^{-1}\mapsto [1,p-1]\)</span>.</p>
<p>做到这一步,自然有<span class="math inline">\(C_0=(p-1)\left(\frac{-1}{p}\right)+p\)</span>.</p>
<p>而对于<span class="math inline">\(r\ne
0\)</span>的时候,我们再做双射<span class="math inline">\(r/[1,p-1]\mapsto [1,p-1]\)</span>,于是<span class="math inline">\(C_r=\sum_{i=0}^{p-2}\left(\frac{i}{p}\right)+p=p-\left(\frac{-1}{p}\right)\)</span>.</p>
<p>只能说模质数意义下的加法乘法减法以及不含<span class="math inline">\(0\)</span>的乘法都是群,而且所有运算都是双射,很牛逼,计数题直接起飞.</p>
<p>不过这题需要特别判断一下<span class="math inline">\(p=2\)</span>的情况,也容易,暴力就行.</p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(2^a=3^b+1\)</span>和<span class="math inline">\(3^a=2^b+1\)</span>的所有解.</p>
<p>先看<span class="math inline">\(2^a=3^b+1\)</span>,显然<span class="math inline">\((2,1)\)</span>是一组解.当<span class="math inline">\(y\geq 3\)</span>的时候,显然有<span class="math inline">\(3^a+1\equiv 0\pmod 8\)</span>,而考虑<span class="math inline">\(3^{2k}\equiv 1\pmod 8\)</span>,这自然不可能.</p>
<p>再看<span class="math inline">\(3^a=2^b+1\)</span>.显然<span class="math inline">\((1,1)\)</span>和<span class="math inline">\((2,3)\)</span>是两组解.当<span class="math inline">\(b\geq 2\)</span>的时候<span class="math inline">\(3^a\equiv 1\pmod 4\)</span>,根据欧拉定理知道<span class="math inline">\(a\in \text {even}\)</span>,令<span class="math inline">\(a=2k\)</span>.自然有<span class="math inline">\((3^k-1)(3^k+1)=2^b\)</span>,这是形如<span class="math inline">\(t(t+2)=2^b\)</span>的形式,只有<span class="math inline">\(t=2\)</span>是一个解.</p>
<h4><span id="bsgs">BSGS</span></h4>
<p>求<span class="math inline">\(a^x\equiv b(\mod
p)\)</span>的一组解,其中<span class="math inline">\(p\in
prime\)</span>且<span class="math inline">\(1\leq p\leq
10^9\)</span>.</p>
<p>直接枚举显然是<span class="math inline">\(O(p)\)</span>的,非常不合理,考虑如何优化.</p>
<p>求出<span class="math inline">\(s=\lfloor\sqrt{p}\rfloor\)</span>,并求出所有<span class="math inline">\(a^i\)</span>,其中<span class="math inline">\(i\in
[0,s-1]\)</span>.</p>
<p>若<span class="math inline">\(x\leq
s-1\)</span>.则可以直接判断是否被求出来过.</p>
<p>否则,则将<span class="math inline">\(x=x\mod
(s-1)\)</span>,一直操作直到<span class="math inline">\(x\leq
s-1\)</span>.</p>
<h4><span id="exbsgs">exBSGS</span></h4>
<p>求<span class="math inline">\(a^x\equiv b(\mod
p)\)</span>的一组解,其中<span class="math inline">\(1\leq p\leq
10^9\)</span>.</p>
<p>设<span class="math inline">\(g=\gcd(a,p)\)</span>,那么根据膜的性质,原方程即<span class="math inline">\(\frac {a^x} g\equiv \frac b g (\mod \frac p
g)\)</span>.</p>
<p>显然若<span class="math inline">\(g\nmid b\)</span>并且<span class="math inline">\(b\ne 1\)</span>,方程定无解.(若<span class="math inline">\(b=1\)</span>,那么<span class="math inline">\(x=0\)</span>就是一个解)</p>
<p>那么现在的方程就是<span class="math inline">\(a^{x-1}\frac a g\equiv
\frac b g(\mod \frac p g)\)</span>.</p>
<p>继续进行这个过程,不断求<span class="math inline">\(a\)</span>和当前模数的<span class="math inline">\(\gcd\)</span>.并将当前模数除以该<span class="math inline">\(\gcd\)</span>,这样最后我们得到了方程:</p>
<p><span class="math inline">\(a^{x-k}\prod_{i=1}^k \frac a {g_i}\equiv
\frac b {\prod_{i=1}^k g_i}(\mod \frac p {\prod_{i=1}^k
g_i})\\\)</span></p>
<p>不妨设<span class="math inline">\(A=\prod_{i=1}^k \frac a
{g_i},B=\frac b {\prod_{i=1}^k g_i},P=\frac p {\prod_{i=1}^k
g_i}\\\)</span></p>
<p>那么现在方程就是<span class="math inline">\(a^{x-k}\equiv \frac B
A\pmod P\)</span>,可以使用BSGS求解.</p>
<p>ps：<span class="math inline">\(p=1\)</span>的时候要特判.</p>
<h4><span id="原根和阶">原根和阶</span></h4>
<p>阶:找到一个最小的<span class="math inline">\(k\)</span>使得<span class="math inline">\(a^k\equiv1(\mod p)\)</span>,则称<span class="math inline">\(k\)</span>是<span class="math inline">\(a\)</span>在膜<span class="math inline">\(p\)</span>意义下的阶.</p>
<p>原根:如果<span class="math inline">\(a\)</span>在膜<span class="math inline">\(p\)</span>意义下的阶是<span class="math inline">\(\varphi(p)\)</span>且<span class="math inline">\(a&lt;p\)</span>,则称<span class="math inline">\(a\)</span>是<span class="math inline">\(p\)</span>的一个原根.</p>
<p>若<span class="math inline">\(m\)</span>有原根,则<span class="math inline">\(m\)</span>一定是<span class="math inline">\(2\)</span>,<span class="math inline">\(4\)</span>或是<span class="math inline">\(p^a,2p^a\)</span>,其中<span class="math inline">\(p\in prime\)</span>且<span class="math inline">\(2\nmid p\)</span>.</p>
<p>由于对于大部分<span class="math inline">\(m\)</span>来说,都存在一个很小的原根,所以在实际应用中只需要暴力找就可以了.</p>
<p>根据阶的定义,我们如果要判断一个<span class="math inline">\(a\)</span>不是<span class="math inline">\(p\)</span>的原根,只需判断是否<span class="math inline">\(\exists i\)</span>使得<span class="math inline">\(a^i\equiv 1(\mod p)\)</span>.</p>
<p>而由于<span class="math inline">\(a^{\varphi(p)}\equiv 1(\mod
p)\)</span>,因此一定有<span class="math inline">\(i|\varphi(p)\)</span>,因此只需判断<span class="math inline">\(\varphi(p)\)</span>的所有因数,复杂度<span class="math inline">\(O(\sqrt{\varphi(p)})\)</span>.</p>
<p>事实上,只需要判断对于<span class="math inline">\(\varphi(p)\)</span>的所有质因子<span class="math inline">\(w\)</span>,是否有<span class="math inline">\(a^{\frac {\varphi(p)} w}\equiv 1(\mod
p)\)</span>即可,复杂度<span class="math inline">\(O(\omega
(p))\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定<span class="math inline">\(k\)</span>,<span class="math inline">\(p\)</span>,<span class="math inline">\(a\)</span>,求<span class="math inline">\(x^k\equiv
a(\mod p)\)</span>的所有解,其中<span class="math inline">\(p\in
prime\)</span>,<span class="math inline">\(1\leq k \leq
10^5\)</span>.</p>
<p>考虑求出<span class="math inline">\(p\)</span>的原根<span class="math inline">\(g\)</span>,得到<span class="math inline">\(g^r\equiv a(\mod p)\)</span>,同时由于<span class="math inline">\(x\equiv g^y(\mod p)\)</span>,因此原方程变为:<span class="math inline">\(g^{yk}\equiv g^r(\mod p)\)</span>.</p>
<p>于是有:<span class="math inline">\(yk\equiv r(\mod
p-1)\)</span>,即可求解.</p>
<h5><span id="example2具体数学447">Example2(《具体数学》4.47)</span></h5>
<p>证明:如果<span class="math inline">\(\exist n,n^{m-1}\equiv 1\pmod
m\)</span>,且对于所有满足<span class="math inline">\(p|(m-1)\)</span>的<span class="math inline">\(p\)</span>都满足<span class="math inline">\(n^{\frac{m-1}{p}}\ne 1\pmod m\)</span>,那么<span class="math inline">\(m\)</span>是素数.</p>
<p>首先不难发现,<span class="math inline">\(m\in\ prime\Leftrightarrow
\varphi(m)=m-1\)</span>.</p>
<p>考虑上面的过程中,不可能存在一个数<span class="math inline">\(k\)</span>满足<span class="math inline">\(0\leq
k&lt;m-1,n^k\equiv 1\pmod m\)</span>.因此<span class="math inline">\(\nexists 0\leq i,j&lt;m,i\ne j,n^i\equiv n^j\pmod
m\)</span>.</p>
<p>根据欧拉定理,<span class="math inline">\(m-1=\varphi(m)\)</span>,因此得证.</p>
<h3><span id="积性函数">积性函数</span></h3>
<p>若函数<span class="math inline">\(f(x)\)</span>满足<span class="math inline">\(\forall n,m\in \mathbb{N_+},n\bot
m\)</span>,有<span class="math inline">\(f(1)=1,f(nm)=f(n)f(m)\)</span>,则称其为积性函数.若<span class="math inline">\(\forall n,m\in \mathbb{N_+}\)</span>,有<span class="math inline">\(f(1)=1,f(nm)=f(n)f(m)\)</span>,则称其为完全积性函数.</p>
<p>若函数<span class="math inline">\(g(x)\)</span>是积性函数并且有<span class="math inline">\(g(m)=\sum_{d|m}f(d)\)</span>,则<span class="math inline">\(f(x)\)</span>也是积性函数,证明如下:</p>
<p>不妨考虑数学归纳,首先<span class="math inline">\(g(1)=f(1)=1\)</span>.</p>
<p>令<span class="math inline">\(m=m_1m_2,m_1\bot m_2\)</span>,则<span class="math inline">\(g(m)=\sum_{d|m}f(d)=\sum_{d_1|m_1}\sum_{d_2|m_2}f(d_1d_2)\)</span>.由于归纳假设,此时只有<span class="math inline">\(d_1=m_1\and d_2=m_2\)</span>的时候,<span class="math inline">\(f(d_1d_2)\)</span>可能不等于<span class="math inline">\(f(d_1)f(d_2)\)</span>.</p>
<p>于是有 <span class="math display">\[
g(m)=\sum_{d_1|m_1}\sum_{d_2|m_2}f(d_1)f(d_2)-f(m_1)f(m_2)+f(m_1m_2)\\=g(m_1m_2)-f(m_1)f(m_2)+f(m_1m_2)
\]</span> 于是<span class="math inline">\(f(m_1)f(m_2)=f(m_1m_2)\)</span>.</p>
<p>该命题的逆命题也是同样成立的.有一些常见的积性函数,比如:<span class="math inline">\(id(x)=x\)</span>,<span class="math inline">\(I(x)=1\)</span>,<span class="math inline">\(\varepsilon(x)=[x=1]\)</span>.</p>
<h5><span id="example具体数学458">Example(《具体数学》4.58)</span></h5>
<p>求:<span class="math inline">\(f(m)=\sum_{d|m}d\)</span>是<span class="math inline">\(2\)</span>的整数次幂的充分必要条件.</p>
<p>不难发现<span class="math inline">\(f\)</span>是一个积性函数,于是考虑<span class="math inline">\(f(p^k)=1+p+p^2+...+p^k\)</span>.</p>
<p>当<span class="math inline">\(p=2\)</span>的时候,显然不满足条件.</p>
<p>不然,只有<span class="math inline">\(k\)</span>是奇数的时候,<span class="math inline">\(f(p^k)\)</span>才是一个偶数.</p>
<p>而此时<span class="math inline">\(f(p^k)=(1+p)(1+p^2+p^4+...+p^{k-1})=(1+p)(1+p^2)(1+p^4+...+p^{k-3})\)</span>.其是<span class="math inline">\(2\)</span>的整数次幂的一个必要条件是<span class="math inline">\(p\)</span>是一个梅森素数,而且不难发现只有当<span class="math inline">\(k=1\)</span>的时候才满足条件.</p>
<p>于是充分必要条件是:<span class="math inline">\(m\)</span>是若干个不同的梅森素数的乘积.</p>
<h4><span id="狄利克雷卷积">狄利克雷卷积</span></h4>
<p><span class="math inline">\(f*g=\sum_{d|n}{f(d)g(\cfrac n
d)}\)</span>.</p>
<p>不难证明狄利克雷卷积满足:</p>
<ol type="1">
<li>交换律:<span class="math inline">\(f*g=g*f\)</span>.</li>
<li>结合律:<span class="math inline">\(f*(g*h)=(f*g)*h\)</span>.</li>
<li>分配律:<span class="math inline">\(f*(g+h)=f*g+f*h\)</span>.</li>
<li>若<span class="math inline">\(f,g\)</span>是积性函数,则<span class="math inline">\(f*g\)</span>也是积性函数.</li>
</ol>
<p>考虑第四条的证明: <span class="math display">\[
f*g(nm)=\sum_{d|(nm)}f(d)g(\cfrac{n}d)\\
=\sum_{c|n}\sum_{d|m}f(cd)g(\cfrac{nm}{cd})\\
=\sum_{c|n}\sum_{d|m}f(c)f(d)g(\cfrac{n}{c})g(\cfrac{m}{d})\\
=(f*g(n))\times (f*g(m))
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(\forall f,f(1)\ne 0\)</span>,<span class="math inline">\(\exists f^{-1}\)</span>,<span class="math inline">\(f*f^{-1}=\epsilon\)</span>.</li>
</ol>
<p>构造<span class="math inline">\(g(x)\)</span>满足<span class="math inline">\(f(1)g(x)=\epsilon(x)-\sum_{d|x,d\ne
1}f(d)g(\frac{x}{d})\)</span>显然就是满足条件的.</p>
<ol start="6" type="1">
<li>积性函数的逆元也是积性函数.</li>
</ol>
<h4><span id="欧拉函数">欧拉函数</span></h4>
<p>定义欧拉函数<span class="math inline">\(\varphi(m)\)</span>为所有满足<span class="math inline">\(1\leq n\leq m\land n\perp m\)</span>的<span class="math inline">\(n\)</span>的个数.</p>
<p>令<span class="math inline">\(m=m_1m_2\)</span>,其中<span class="math inline">\(m_1\bot m_2\)</span>.由于若<span class="math inline">\(n\bot m_1,n\bot m_2\)</span>,显然有<span class="math inline">\((n\mod m_1)\bot m_1\)</span>且<span class="math inline">\((n\mod m_2)\bot
m_2\)</span>,则根据中国剩余定理,不难有<span class="math inline">\(\varphi(m)=\varphi(m_1)\varphi(m_2)\)</span>,也即<span class="math inline">\(\varphi(x)\)</span>是积性函数.</p>
<p>若<span class="math inline">\(n=\prod^{k}_{i=1}p_i^{a_i}\)</span>,则:</p>
<p><span class="math inline">\(\varphi(n)=\prod^k_{i=1}\varphi(p_i^{a_i})=\prod^k_{i=1}{p_i^{a_i}-p_i^{a_i-1}}=\prod^k_{i=1}{p^{a_i-1}(p_i-1)}\)</span>.</p>
<p>考虑改变枚举方式,因为<span class="math inline">\(n=\prod_{p|n}p^{a_p}\)</span>,则:<span class="math inline">\(\varphi(n)=\prod_{p|n}{p^{a_p-1}(p-1)}=\prod_{p|n}{(p^{a_p}\times
\cfrac{p-1}{p})}=n\times\prod_{p|n}\cfrac{p-1}{p}\)</span>.</p>
<p>我们考虑一个事实:现在有<span class="math inline">\(m\)</span>个不同的分数<span class="math inline">\(\cfrac{k}m,k\in[1,m]\)</span>,这些分数进行约分后,它们的分母即<span class="math inline">\(m\)</span>的若干因数,而它们的分子就是与这些因数互质的数,同时这些数的个数总共是<span class="math inline">\(m\)</span>个,我们可以得到:<span class="math inline">\(\sum_{d|m}\varphi(d)=m\)</span>.</p>
<p>上面这个结论还有另一种证明方法:</p>
<p>由于<span class="math inline">\(\varphi\)</span>是积性函数,若<span class="math inline">\(n\ne1\)</span>,设<span class="math inline">\(n=\prod_{i=1}^kp_i^{q_i}\)</span>,则<span class="math inline">\(\varphi(n)=\prod_{i=1}^k\varphi(p_i^{q_i})\)</span>,则有:
<span class="math display">\[
\sum_{d|n}\varphi(d)=\sum_{w_1=0}^{q_1}\sum_{w_2=0}^{q_2}......\sum_{w_k=0}^{q_k}{\varphi(p_1^{w_1})\varphi(p_2^{w_2})......\varphi(p_k^{w_k})}\\
\]</span> 而<span class="math inline">\(\varphi(p^q)=p^q-p^{q-1}\)</span>,于是有<span class="math inline">\(\sum_{i=1}^{q_i}{(p_x^i-p_x^{i-1})}=(p_x^{q_x}-1)\)</span>,则有<span class="math inline">\(\sum_{i=0}^{q_x}\varphi(p_x^{i})=p_x^{q_x}\)</span>.</p>
<p>则原式等于<span class="math inline">\(\prod_{i=1}^kp_i^{q_i}=n\)</span>.</p>
<h5><span id="和法里级数的关系">和法里级数的关系</span></h5>
<p>我们考虑之前提到的法里级数<span class="math inline">\(\mathcal{F}_n\)</span>,令<span class="math inline">\(\Phi(x)=\sum_{1\leq k\leq
x}\varphi(k)\)</span>,那么<span class="math inline">\(\mathcal{F}_n\)</span>的个数显然是<span class="math inline">\(\Phi(x)+1\)</span>.</p>
<p>接下来我们思考如何计算<span class="math inline">\(\Phi(x)\)</span>.事实上,我们有<span class="math inline">\(\sum_{d=1}^n\Phi(\lfloor\cfrac{n}d\rfloor)=\cfrac{1}2(n+1)n\)</span>.这里的证明是:考虑满足<span class="math inline">\(0\leq a&lt;b\leq n\)</span>的分数<span class="math inline">\(\cfrac{a}{b}\)</span>共有<span class="math inline">\(\cfrac{1}2n(n+1)\)</span>个,而如果我们枚举<span class="math inline">\(d=\gcd(a,b)\)</span>,那么显然右边也等于这些分数个数,于是得证.</p>
<p>而事实上,如果我们用<span class="math inline">\(n=\lfloor
x\rfloor\)</span>来带入上面的式子,可以得到<span class="math inline">\(\sum_{d=1}\Phi(\cfrac{x}d)=\cfrac{1}2\lfloor
x\rfloor\lfloor1+x\rfloor\)</span>.</p>
<p>根据第三种莫比乌斯反演的形式,我们有:<span class="math inline">\(\Phi(x)=\cfrac1 2\sum_{1\leq
d}\mu(d)\lfloor\cfrac{x }d\rfloor\lfloor\cfrac x
d+1\rfloor\)</span>.</p>
<h5><span id="麦克马洪和式">麦克马洪和式</span></h5>
<p>考虑这个问题:我们现在有<span class="math inline">\(m\)</span>种颜色,要对一个长度为<span class="math inline">\(n\)</span>的圆环进行染色,旋转后相同算一种方案,求方案数.</p>
<p>我们先设答案为<span class="math inline">\(N(n,m)\)</span>,并将这些答案全部列举出来,然后将它们进行旋转,进行<span class="math inline">\(n-1\)</span>次.这样我们就得到了<span class="math inline">\(nN(n,m)\)</span>个圆环,但是这些圆环是有重复的.</p>
<p>那么我们显然有: <span class="math display">\[
nN(n,m)=\sum_{a_0a_1...a_{n-1}}\sum_{0\leq
k&lt;n}[a_0a_1...a_{n-1}=a_k...a_{n-1}a_0...a_{k-1}]\\
=\sum_{0\leq
k&lt;n}\sum_{a_0a_1...a_{n-1}}[a_0a_1...a_{n-1}=a_k...a_{n-1}a_0...a_{k-1}]
\]</span> 接下来我们只需要知道,当已知<span class="math inline">\(k\)</span>的时候,右边和式的贡献是多少.显然此时有<span class="math inline">\(a_i=a_{(i+k)\mod n}\)</span>,也就是<span class="math inline">\(a_i=a_{(i+kl)\mod n}\)</span>,此时答案为<span class="math inline">\(m^{\gcd({n,k})}\)</span>.</p>
<p>为啥答案为<span class="math inline">\(m^{\gcd(n,k)}\)</span>呢?我们考虑这一定会不断在<span class="math inline">\(a\)</span>中取数,那么会取多少数呢?显然会取<span class="math inline">\(x-1\)</span>个数,其中<span class="math inline">\(i+xk=i+yn\)</span>,不难解得此时<span class="math inline">\(x=\frac{n}{\gcd(k,n)}\)</span>,因此一共有<span class="math inline">\(\gcd(n,k)\)</span>个轨道.</p>
<p>也就是说:<span class="math inline">\(nN(n,m)=\sum_{0\leq
k&lt;n}m^{\gcd(n,k)},N(n,m)=\cfrac{1}n\sum_{0\leq
k&lt;n}m^{\gcd(n,k)}\\\)</span>.</p>
<p>如果我们对这个式子进行化简: <span class="math display">\[
N(n,m)=\cfrac{1}{n}\sum_{d|n}m^d\sum_{0\leq k&lt;n}[d=\gcd(n,k)]\\
=\cfrac{1}{n}\sum_{d|n}m^d\sum_{d|k,k&lt;n}[\cfrac{k}{d}\bot
\cfrac{n}{d}]\\
=\cfrac{1}{n}\sum_{d|n}m^d\sum_{0\leq k&lt;\frac{n}d}[k\bot
\cfrac{n}d]\\
=\cfrac{1}{n}\sum_{d|n}\varphi(d)m^{\frac{n}{d}}.
\]</span> 这个式子被称为麦克马洪公式.</p>
<p>另外,如果我们考虑<span class="math inline">\(n|(\sum_{d|n}\varphi(d)n^{\frac{n}{d}})\)</span>这件事的证明,考虑如果<span class="math inline">\(n=p^k\)</span>,那么根据费马小定理,显然可证明.</p>
<p>而由于<span class="math inline">\(\varphi(x)\)</span>是积性函数,令<span class="math inline">\(n=n_1n_2,n_1\bot n_2\)</span>,有: <span class="math display">\[
\sum_{d|n}\varphi(d)n^{\frac{n}d}=\sum_{d_1|n_1,d_2|n_2}\varphi(d_1d_2)n^{\frac{n_1n_2}{d_1d_2}}\\
=\sum_{d_1|n_1}\varphi(d_1)(\sum_{d_2|n_2}\varphi(d_2)(n^{\frac{n_1}{d_1}})^{\frac{n_2}{d_2}})
\]</span> 我们可以通过数学归纳来证明.</p>
<h5><span id="burnside定理">Burnside定理</span></h5>
<p>现在让我们来进行一些抽象代数的计算.</p>
<p>置换群:运算<span class="math inline">\((a_1,a_2,...,a_k)\)</span>表示将<span class="math inline">\(a_1\)</span>放到<span class="math inline">\(a_2\)</span>位置…把<span class="math inline">\(a_i\)</span>放到<span class="math inline">\(a_{i+1}\)</span>的位置…把<span class="math inline">\(a_k\)</span>放到<span class="math inline">\(a_1\)</span>的位置,而幺元<span class="math inline">\(e=(1)(2)(3)...(n)\)</span>.</p>
<p>由麦克马洪和式的证明,我们不难推导出Polya定理:设要对<span class="math inline">\(n\)</span>个元素用<span class="math inline">\(m\)</span>种颜色染色,若通过某种旋转得到的染色方案算同一种,考虑旋转一定是一种置换,则本质不同的染色方案数<span class="math inline">\(=\cfrac{\sum_{s\in
S}m^{\eta(s)}}{|S|}\)</span>,其中<span class="math inline">\(\eta(s)\)</span>表示<span class="math inline">\(s\)</span>的轨道数,即有多少组置换.</p>
<h6><span id="example1hnoi2009图的同构计数">Example1([HNOI2009]图的同构计数)</span></h6>
<p>首先看到循环同构,第一反应就是Burnside定理.考虑将每条边的状态设为两种:选或不选,那么我们就对点的编号进行置换,然后找到不动边的数量.</p>
<p>我们先考虑对于一个置换,该如何求得它的不动边的数量.考虑置换是一个排列,对它做置换环分解.</p>
<p>现在问题在于置换环内和置换环间要分别求不动点的数量.</p>
<p>先来考虑置换环内:由于是一个置换环,我们假设它的大小是<span class="math inline">\(b\)</span>,将这<span class="math inline">\(b\)</span>个点排成一个正<span class="math inline">\(b\)</span>边形(<span class="math inline">\(b\)</span>个点的完全图),考虑一个一条边转多少次才能转回来,如果不是<span class="math inline">\(b\)</span>是偶数并且这条边正好平分整个多边形的话,显然需要转<span class="math inline">\(n\)</span>次,简单判掉特殊情况,发现轨道数量<span class="math inline">\(\lfloor\frac{b}{2}\rfloor\)</span>.</p>
<p>接下来考虑置换环外:对于两个置换环间,对于一条边,我们考虑不断做置换,做多少次才能使这条边回归原位置.注意到需要做<span class="math inline">\(lcm(b_1,b_2)\)</span>次.而总共有<span class="math inline">\(b_1b_2\)</span>条边,于是轨道数量<span class="math inline">\(\frac{b_1b_2}{lcm(b_1,b_2)}=\gcd(b_1,b_2)\)</span>.</p>
<p>这样对于一个<span class="math inline">\(k\)</span>个环的置换,它的答案就是<span class="math inline">\(\sum_{i=1}^k\lfloor\frac{b_i}{2}\rfloor+\sum_{i=1}^k\sum_{j=i+1}^k\gcd(b_i,b_j)\)</span>.</p>
<p>接下来发现本质不同的置换不多,搜出来每个置换环的大小,暴力判断.</p>
<h5><span id="欧拉定理">欧拉定理</span></h5>
<p>当<span class="math inline">\(a\perp m\)</span>时,<span class="math inline">\(a^{\varphi(m)}\equiv 1(\mod m)\)</span>.</p>
<p>证明考虑取出<span class="math inline">\([1,m]\)</span>中所有和<span class="math inline">\(m\)</span>互质的数,设它们为<span class="math inline">\(b_1,b_2,\cdots,b_{\varphi(m)}\)</span>.我们有:
<span class="math display">\[
\prod _{k=1}^{\varphi(m)}ab_k\equiv \prod _{k=1}^{\varphi(m)}(ab_k\bmod
p)(\mod p)\\
a^{\varphi(m)}\prod _{k=1}^{\varphi(m)}b_k\equiv \prod
_{k=1}^{\varphi(m)}b_k(\mod p)
\]</span></p>
<p>欧拉定理可以用来求逆元:<span class="math inline">\(a^{\varphi(p)}\equiv 1(\mod p)\)</span>,则有<span class="math inline">\(a^{-1}\equiv a^{\varphi(p)-1}(\mod
p)\)</span>.</p>
<h5><span id="扩展欧拉定理">扩展欧拉定理</span></h5>
<p><span class="math inline">\(a^b\equiv a^c(\mod m)\)</span>,其中<span class="math inline">\(c=
\begin{cases}
b\bmod \varphi(m) &amp;a\perp m\\
b &amp;b&lt;\varphi(m)\\
(b\bmod \varphi(m))+\varphi(m) &amp;other
\end{cases}\)</span></p>
<p>证明如下:</p>
<p>设<span class="math inline">\(m=\prod^k_{i=1}p_i^{e_i}\)</span>,则要证<span class="math inline">\(a^b\equiv a^{(b\mod \varphi(m))+\varphi(m)}(\mod
m)\)</span>,即证<span class="math inline">\(\forall i\)</span>都有<span class="math inline">\(a^b\equiv a^{(b\mod \varphi(m))+\varphi(m)}(\mod
p_i^{e_i})\)</span>.</p>
<p>分情况讨论:</p>
<p>若<span class="math inline">\(p_i^{e_i}\perp
a\)</span>,则为普通欧拉定理情况,即证明<span class="math inline">\(\varphi(p_i^{e_i})\)</span>是<span class="math inline">\(b-c\)</span>的因数.由于<span class="math inline">\(\varphi(p_i^{e_i})\)</span>是<span class="math inline">\(\varphi(m)\)</span>的因数,而<span class="math inline">\(\varphi(m)\)</span>是<span class="math inline">\(b-c\)</span>的因数,显然得证.</p>
<p>不然,发现<span class="math inline">\(e_i\leq\varphi(p_i^{e_i})\leq\varphi(m)\leq
b\)</span>且<span class="math inline">\(\varphi(m)\leq
c\)</span>,又发现<span class="math inline">\(p_i^{e_i}|a^{e_i}\)</span>,所以<span class="math inline">\(p_i^{e_i}|a^b\)</span>,<span class="math inline">\(p_i^{e_i}|a^c\)</span>,左右两边均为<span class="math inline">\(0\)</span>,得证.</p>
<p>######Example1(CF906D Power Tower)</p>
<p>考虑每次暴力做扩展欧拉定理,注意到每次会把<span class="math inline">\(p\)</span>变成<span class="math inline">\(\varphi(p)\)</span>,如果<span class="math inline">\(p\)</span>是奇数,那它下一步会变为偶数,如果<span class="math inline">\(p\)</span>是偶数,则下一步至少减半,于是迭代次数是<span class="math inline">\(\log n\)</span>级别的.</p>
<h6><span id="example2六省联考-2017相逢是问候">Example2([六省联考 2017]
相逢是问候)</span></h6>
<p>同上.</p>
<h6><span id="example3具体数学454">Example3(《具体数学》4.54)</span></h6>
<p>求<span class="math inline">\(1000!\pmod {10^{250}}\)</span>.</p>
<p>首先,根据前面的例题,不难发现<span class="math inline">\(5^{249}\times
2^{994}\mid (1000!)\)</span>.</p>
<p>我们有: <span class="math display">\[
1000!\equiv ans \pmod {10^{250}}\\
\cfrac{1000!}{10^{249}}\equiv \cfrac{ans}{10^{249}}\pmod {10}
\]</span> 由于模数现在变成了<span class="math inline">\(10\)</span>,考虑<span class="math inline">\(1\times 3\times 3\times 7\times 9\mod
{10}=7\)</span>,于是我们有: <span class="math display">\[
\cfrac{ans}{10^{249}}\equiv 2^{745}\times 7^{100}\pmod {10}\\
\]</span> 而<span class="math inline">\(\varphi(10)=4\)</span>,根据扩展欧拉定理: <span class="math display">\[
\cfrac{ans}{10^{249}}\equiv 2^{5}\pmod {10}\\
ans\equiv 2\times 10^{249}\pmod {10^{250}}
\]</span></p>
<h5><span id="example1具体数学457">Example1(《具体数学》4.57)</span></h5>
<p>求证:<span class="math inline">\(\sum_{1\leq k\leq
n+m}\varphi(k)[(m\mod k)+(n\mod k)\geq k]=nm\\\)</span>.</p>
<p>先考虑将条件改为一个更好处理的式子,不难发现: <span class="math display">\[
[m\bmod k+n\bmod k\geq
k]=\lfloor\cfrac{n+m}{k}\rfloor-\lfloor\cfrac{n}{k}\rfloor-\lfloor\cfrac{m}{k}\rfloor
\]</span> 于是接下来我们要处理的式子形如<span class="math inline">\(\sum_{1\leq k\leq
n}\varphi(k)\lfloor\cfrac{n}{k}\rfloor\\\)</span>.</p>
<p>对其增加枚举量: <span class="math display">\[
\sum_{1\leq k\leq n}\varphi(k)\lfloor\cfrac{n}{k}\rfloor=\sum_{1\leq
k\leq n}\varphi(k)\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}1\\
=\sum_{k=1}^n\sum_{d|k}\varphi(d)\\
=\sum_{k=1}^nk=\cfrac{(n+1)n}{2}
\]</span> 带入即可证明.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{1\leq a,b\leq p(p-1)}[a^b\equiv
b^a(\mod p)],p\in prime\)</span>.</p>
<p>考虑<span class="math inline">\(p\bot
(p-1)\)</span>,使用中国剩余定理,我们有: <span class="math display">\[
\sum_{1\leq a,b\leq p(p-1)}[a^b\equiv b^a(\mod p)]\\
=\sum_{0\leq a,b&lt; p}\sum_{0\leq c,d&lt;p-1}[a^c\equiv b^d(\mod p)]\\
=(p-1)^2+\sum_{1\leq a,b&lt; p}\sum_{0\leq c,d&lt;p-1}[a^c\equiv
b^d(\mod p)]
\]</span> 后面那部分的答案是: <span class="math display">\[
\sum_{1\leq a,b&lt; p}\sum_{0\leq c,d&lt;p-1}[a^c\equiv b^d(\mod p)]\\
=\sum_{1\leq x&lt; p}\sum_{0\leq a,b&lt; p}\sum_{1\leq
c,d&lt;p-1}[a^c\equiv x(\mod p)][b^d\equiv x(\mod p)]\\
=\sum_{1\leq x&lt;p}(\sum_{1\leq a&lt;p,0\leq c&lt;p-1}[a^c\equiv x(\mod
p)])^2
\]</span> 令<span class="math inline">\(g\)</span>为<span class="math inline">\(p\)</span>的原根,令<span class="math inline">\(a=g^b\)</span>,<span class="math inline">\(x=g^{x&#39;}\)</span>有: <span class="math display">\[
\sum_{1\leq x&lt;p}(\sum_{1\leq a&lt;p,0\leq c&lt;p-1}[a^c\equiv x(\mod
p)])^2\\
=\sum_{0\leq x&#39;&lt;p-1}(\sum_{0\leq b&lt; p-1,0\leq
c&lt;p-1}[bc\equiv x&#39;(\mod p-1)])^2\\
=\sum_{0\leq x&lt;p-1}(\sum_{0\leq a,b&lt;p-1}[ab\equiv x(\mod
p-1)])^2\\
\]</span> 考虑前面那个式子,如果我们令<span class="math inline">\(x=x_0x_1,x_0\bot x_1\)</span>,<span class="math inline">\(p-1=p_0p_1,p_0\bot p_1\)</span>,其中<span class="math inline">\(0\leq x_0&lt;p_0,0\leq
x_1&lt;p_1\)</span>,后面那个式子为<span class="math inline">\(f(p-1,x)\)</span>,由于中国剩余定理,有<span class="math inline">\(f(p-1,x)=f(p_0,x_0)f(p_1,x_1)\)</span>.</p>
<p>于是令<span class="math inline">\(p-1=\prod_{i=1}^kp_i^{q_i}\)</span>上面的式子可以改为:
<span class="math display">\[
\prod_{i=1}^k(\sum_{0\leq x_i&lt;p_i^{q_i}}(\sum_{0\leq
a,b&lt;p_i^{q_i}}[ab\equiv x_i(\mod p_i^{q_i})])^2)
\]</span> 我们只考虑其中一项,形如: <span class="math display">\[
\sum_{0\leq x&lt;p^{q}}(\sum_{0\leq a,b&lt;p^q}[ab\equiv x(\mod
p^{q})])^2
\]</span> 我们不妨用<span class="math inline">\(ap^{\alpha}\)</span>代替<span class="math inline">\(a\)</span>,<span class="math inline">\(bp^\beta\)</span>代替<span class="math inline">\(b\)</span>,<span class="math inline">\(xp^t\)</span>代替<span class="math inline">\(x\)</span>,其中<span class="math inline">\(a,b,x\bot p\)</span>那么有: <span class="math display">\[
\sum_{0\leq x&lt;p^{q-t}}(\sum_{0\leq a&lt; p^{q-\alpha},0\leq
b&lt;p^{q-\beta}}[abp^{\alpha+\beta}\equiv xp^t(\mod p^{q})])^2
\]</span> 则我们要做的即对四元组<span class="math inline">\((a,b,\alpha,\beta)\)</span>计数.由于<span class="math inline">\(a,b,x\bot p\)</span>,我们有: <span class="math display">\[
\alpha+\beta=t,\alpha,\beta\in\mathbb{N}\\
ab\equiv x\pmod {p^{q-t}},0\leq a&lt;p^{q-\alpha},0\leq b&lt;p^{q-\beta}
\]</span> 第一个式子对四元组的贡献显然是<span class="math inline">\(t+1\)</span>,而第二个式子,由于<span class="math inline">\([1,p^{q-t})\in[1,p^{q-\alpha})\)</span>,所以我们可以先求出<span class="math inline">\(1\leq a&lt;p^{q-t}\)</span>的答案,然后乘以<span class="math inline">\(p^{t-\alpha}\)</span>得到答案,<span class="math inline">\(b\)</span>是类似的,于是: <span class="math display">\[
ans=\sum_{1\leq x&lt;p^{q-t}}((t+1)p^{t-\alpha}p^{t-\beta}\sum_{1\leq
a,b&lt; p^{q-t}}[ab\equiv x\pmod {p^{q-t}}])^2+(\sum_{1\leq a,b\leq
p^q}[ab\equiv 0\pmod {p^{q}}])^2\\
=\sum_{1\leq x&lt;p^{q-t}}((t+1)p^{t-\alpha}p^{t-\beta}\sum_{1\leq
a,b&lt; p^{q-t}}[ab\equiv x\pmod {p^{q-t}}])^2+q(p-1)p^{q-1}+p^q
\]</span> 后面,由于<span class="math inline">\(a\bot
p\)</span>,显然一个<span class="math inline">\(a\)</span>唯一对应一个<span class="math inline">\(b\)</span>.于是我们得到了答案为: <span class="math display">\[
\sum_{1\leq x&lt;p^{q-t}}((t+1)p^{t}\varphi(p^{q-t}))^2
\]</span> 而后面的式子显然跟<span class="math inline">\(x\)</span>无关,所以有: <span class="math display">\[
\sum_{0&lt; x&lt;p^{q-t}}((t+1)p^{t}\varphi(p^{q-t}))^2\\
=\sum_{0\leq t&lt; q}(\varphi(p^{q-t}))((t+1)p^{t}\varphi(p^{q-t}))^2\\
=\sum_{0\leq t&lt;q}(t+1)^2p^{2t}(p-1)^3p^{3q-3t-3}\\
=\sum_{0\leq t&lt;q}(t+1)^2(p-1)^3p^{3q-t-3}
\]</span> 其实到这一步,由于<span class="math inline">\(\sum
t\)</span>是<span class="math inline">\(O(\log
n)\)</span>级别的,这题已经可以做了.</p>
<h4><span id="莫比乌斯函数">莫比乌斯函数</span></h4>
<p>莫比乌斯函数<span class="math inline">\(\mu(x)\)</span>是一个满足<span class="math inline">\(\sum_{d|n}\mu(n)=1\)</span>的函数,根据定义其显然是积性函数.根据定义可以求出它的封闭形式:</p>
<p><span class="math inline">\(\mu(m)=\begin{cases}0&amp;\exist m_i\geq
2\\(-1)^k&amp;\forall m_i\leq
1\end{cases},m=\prod_{i=1}^kp_i^{m_i}\)</span>.</p>
<h5><span id="莫比乌斯反演">莫比乌斯反演</span></h5>
<p>见”反演.md”.</p>
<p>另外,值得一提的是,根据莫比乌斯反演,我们可以发现<span class="math inline">\(\mu*id=\varphi\)</span>.</p>
<p>有公式:<span class="math inline">\(\mu^2(x)=\sum_{i^2|x}\mu(i)\)</span>.原因很简单,我们设<span class="math inline">\(x&#39;\)</span>为<span class="math inline">\(x\)</span>中所有的质因子的幂先除二下取整再乘二后变成的答案,显然<span class="math inline">\(\mu^2(x)=\mu^2(x&#39;)\)</span>,我们有<span class="math inline">\(\sum_{i|\sqrt {x&#39;}}\mu(y)=[\sqrt
{x&#39;}=1],\sum_{i^2|x&#39;}\mu(y)=[x&#39;=1]\)</span>.</p>
<h4><span id="min25筛">min25筛</span></h4>
<p>如果我们考虑积性函数的值,理论上来说,设<span class="math inline">\(S(n,k)\)</span>表示最小质因子大于等于<span class="math inline">\(p_k\)</span>的所有<span class="math inline">\(f\)</span>的和加上<span class="math inline">\(f(1)\)</span>,其实我们自然有: <span class="math display">\[
S(n,k)=\sum_{e\geq 0}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)
\]</span> 问题在于这么做需要枚举<span class="math inline">\([1,n]\)</span>中的全部质数,这是根本无法接受的.</p>
<p>我们考虑一些很大的质数,换言之,最小质因子大于<span class="math inline">\(\sqrt n\)</span>的数在<span class="math inline">\([1,n]\)</span>中只有可能是质数本身.</p>
<p>因此你会发现,这个过程只需要把质数单独拿出来做,复杂度就可以得到相当的飞跃.</p>
<p>考虑: <span class="math display">\[
\sum_{i=1}^nf(i)=\sum_{p\in prime}f(p)+\sum_{p\notin prime\and p\ne
1}f(p)+f(1)
\]</span></p>
<p>令<span class="math inline">\(g(N,i)=\sum_{j=1}^N[j\in prime \or
Min_j&gt;p_i]F(j)\\\)</span>,其中<span class="math inline">\(Min_j\)</span>表示<span class="math inline">\(j\)</span>最小的质因数,<span class="math inline">\(p_i\)</span>表示第<span class="math inline">\(i\)</span>个质数.</p>
<p>注意到<span class="math inline">\(g(N,i)\)</span>实际上就是<span class="math inline">\(N\)</span>以内的数在第<span class="math inline">\(i\)</span>轮埃氏筛后剩余的数的<span class="math inline">\(F\)</span>的和.</p>
<p><span class="math inline">\(F(i)\)</span>表示若干完全积性函数之和且当<span class="math inline">\(p\in prime\)</span> 时,<span class="math inline">\(F(p)=f(p)\)</span>,下文为了方便书写,直接认为<span class="math inline">\(F\)</span>是完全积性函数.</p>
<p>而<span class="math inline">\(g(N,\sqrt N)\)</span>实际上就是<span class="math inline">\(N\)</span>以内的质数的<span class="math inline">\(F\)</span>之和,那么有: <span class="math display">\[
g(n,0)=\sum_{i=2}^nF(i)\\
g(i,j)=g(i,j-1)-F(p_j)(\ g(\lfloor\frac{i}{p_j}\rfloor,j-1)-\sum_{2\leq
p\leq p_{j-1},p\in prime}F(p)\ )\\
\]</span> ps1:</p>
<p>第<span class="math inline">\(j\)</span>个质数会比第<span class="math inline">\(j-1\)</span>个多筛若干个数,即最小质因数是<span class="math inline">\(p_j\)</span>的数.这些数形如<span class="math inline">\(\{p_j,2p_j,3p_j...\}\)</span>,同时除以<span class="math inline">\(p_j\)</span>得到<span class="math inline">\(\{1,2,3...\}\)</span>.</p>
<p>我们要的就是其中最小质因数大于等于<span class="math inline">\(p_j\)</span>的数,也就是最小质因数大于<span class="math inline">\(p_{j-1}\)</span>的数,因而就是<span class="math inline">\(g(\lfloor\frac{i}{p_j}\rfloor,j-1)\)</span>.</p>
<p>但还有一些质数会被重复计算,我们把他删掉就可以了.</p>
<p>考虑到<span class="math inline">\(g\)</span>后面的维度最多走到<span class="math inline">\(\sqrt
n\)</span>,所以我们所枚举的最小质因子一定小于等于<span class="math inline">\(\sqrt n\)</span>,所以一定有<span class="math inline">\(p_{j-1}&lt;\lfloor\frac{i}{p_j}\rfloor\)</span>,所以直接删去一定不会多删.</p>
<p>ps2:</p>
<p>注意到以下事实:<span class="math inline">\(\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor=\lfloor\frac{a}{bc}\rfloor\\\)</span>.</p>
<p>因而,如果我们有以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[n])<span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="keyword">else</span> f[n]=......;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">solve</span>(n);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码复杂度为<span class="math inline">\(O(\sqrt
n)\)</span>.原因在于,根据整数分块,<span class="math inline">\(\lfloor\frac{n}{i}\rfloor\)</span>有<span class="math inline">\(\sqrt n\)</span>种取值.</p>
<p>而如果递归下去,继续枚举<span class="math inline">\(j\)</span>,并往下递归到<span class="math inline">\(\lfloor\frac{\lfloor\frac{n}{i}\rfloor}{j}\rfloor\)</span>,那他就相当于枚举<span class="math inline">\(k=ij\)</span>,并递归到<span class="math inline">\(\lfloor\frac{n}{k}\rfloor\)</span>,因而复杂度得到保证.</p>
<p>由此可知,求<span class="math inline">\(g\)</span>的复杂度为<span class="math inline">\(O(\sqrt n\times \sqrt {\sqrt n})=O(n^{\frac3
4})\)</span>.</p>
<p>令<span class="math inline">\(S(n,m)\)</span>表示前<span class="math inline">\(n\)</span>个数中,最小质因数大于等于<span class="math inline">\(p_m\)</span>的数的<span class="math inline">\(f\)</span>之和,可知: <span class="math display">\[
S(n,m)=g(n,+\infty)-\sum_{k=1}^{m-1}f(p_k)+\sum_{k\geq m,e\geq
1,p_k^{e+1}\leq
n}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)+\sum_{k\geq
m,e=2,p_k^e\leq n}f(p_k^e)\\
=g(n,+\infty)-\sum_{k=1}^{m-1}f(p_k)+\sum_{k\geq m,e\geq 1,p_k^{e+1}\leq
n}[f(p_k^e) S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)+f(p_k^{e+1})]\\
\]</span> ps1:</p>
<p>前半段求出质数部分的和,后半段开始枚举最小质因子.</p>
<p>由于<span class="math inline">\(p_k\)</span>是当前数的最小质因子,<span class="math inline">\(e\)</span>是他的幂.则这个数其他的质因子应该均大于<span class="math inline">\(p_k\)</span>,因而大于等于<span class="math inline">\(p_{k+1}\)</span>.</p>
<p>注意到由于<span class="math inline">\(S\)</span>中不包含<span class="math inline">\(1\)</span>,所以应特殊处理只含有<span class="math inline">\(p_k\)</span>一个质因子的情况.</p>
<p>又注意到,如果<span class="math inline">\(p_k^e&lt;
n&lt;p_k^{e+1}\)</span>,那么此时<span class="math inline">\(\lfloor\frac{n}{p_k^e}\rfloor\)</span>一定小于<span class="math inline">\(p_k\)</span>,则不可能拥有比<span class="math inline">\(p_k\)</span>更大的质因子.</p>
<p>该形式与上面一致,因而复杂度同样为<span class="math inline">\(O(n^{\frac 3
4})\)</span>.我们最终要求的答案即<span class="math inline">\(S(n,1)+f(1)\)</span>.</p>
<p>一些后记:</p>
<ol type="1">
<li>事实上,复杂度的计算只是上限,实际上应该约为<span class="math inline">\(O(\frac{n^{\frac3 4}}{\log_2 n})\)</span>.</li>
<li>如果使用map会导致复杂度较差,考虑如下事实: (1).<span class="math inline">\(\forall 1\leq x\leq n\)</span>,则要么<span class="math inline">\(x\leq \sqrt n\)</span>,要么<span class="math inline">\(\lfloor\frac{n}{x}\rfloor\leq \sqrt n\\\)</span>.
(2).<span class="math inline">\(\forall a\)</span>形如<span class="math inline">\(\lfloor\frac{n}{x}\rfloor\)</span>,则<span class="math inline">\(\lfloor\frac{n}{a}\rfloor\)</span>应为<span class="math inline">\(x_{max}\)</span>,互不相同.
因而可以分别特判,从而做到比map或离散化都优秀的复杂度.</li>
<li>我们在代码中所求出的<span class="math inline">\(w\)</span>是倒序的,而我们转移的过程也是倒序的,因而枚举的时候可以直接正序枚举.</li>
<li>考虑做的时候由于进行了滚动数组,因而继承操作可以直接使用,为了方便可以直接判掉可以直接继承的情况.</li>
<li>求<span class="math inline">\(S\)</span>的过程可以使用递归,因为我们只关心一个<span class="math inline">\(S\)</span>的量.</li>
</ol>
<h5><span id="example1uoj188sanrd">Example1([uoj188]Sanrd)</span></h5>
<p>注意到这题显然可以写埃筛的暴力.考虑使用类似min15筛的方式,定义<span class="math inline">\(f(n)\)</span>为<span class="math inline">\(n\)</span>的次大质因子(若<span class="math inline">\(n=1\or n\in prime\)</span>则<span class="math inline">\(f(n)=0\)</span>),<span class="math inline">\(S(n,k)=\sum_{i=1}^n[Min_i\geq
p_k]f(i)\)</span>.不难发现我们要求的就是<span class="math inline">\(S(n,1)\)</span>,而显然<span class="math inline">\(S(n,\sqrt n)=0\)</span>.</p>
<p>注意到: <span class="math display">\[
S(n,m)=\sum_{i\geq m,e\geq 1,p_i^{e+1}\leq
n}S(\lfloor\frac{n}{p_i^e}\rfloor,i+1)+p_i\sum_{i=p_i+1}^{\lfloor\frac{n}{p_i^e}\rfloor}[i\in
prime]
\]</span> 区间素数个数可以拿min25筛的前半部分做.</p>
<h4><span id="杜教筛">杜教筛</span></h4>
<p>令<span class="math inline">\(F(n)=\sum_{i=1}^nf(i)\\\)</span>,我们考虑构造两个函数<span class="math inline">\(g\)</span>和<span class="math inline">\(s\)</span>.使得<span class="math inline">\(f*g=s\)</span>.</p>
<p>令<span class="math inline">\(G(n)=\sum_{i=1}^ng(i),S(n)=\sum_{i=1}^ns(i)\\\)</span>.若<span class="math inline">\(G(i)\)</span>和<span class="math inline">\(S(i)\)</span>都很方便求,<span class="math inline">\(g(1)=1\)</span>,我们就可以求出<span class="math inline">\(F(n)\)</span>. <span class="math display">\[
f*g=s\\
\sum_{j|i}f(j)g(\frac i j)=s(i)\\
\]</span> 由于<span class="math inline">\(g(1)=1\)</span>,我们有<span class="math inline">\(f(i)=s(i)-\sum_{j|i,j\ne i}f(j)g(\frac i
j)\\\)</span>.</p>
<p>那么: <span class="math display">\[
F(n)=\sum_{i=1}^nf(i)\\=\sum_{i=1}^n(s(i)-\sum_{j|i,j\ne i}f(j)g(\frac i
j))\\
=S(n)-\sum_{j=1}^n\sum_{k=2}^{\lfloor\frac n
j\rfloor}g(k)f(j)\\=S(n)-\sum_{k=2}^ng(k)\sum_{j=1}^{\lfloor\frac n
k\rfloor}f(j)\\
=S(n)-\sum_{k=2}^ng(k)F(\lfloor\frac n k\rfloor)\\
\]</span> 复杂度证明和min25筛是一样的,不同点在于我们可以预处理<span class="math inline">\(n^{\frac 2 3}\)</span>以内的<span class="math inline">\(F\)</span>,这样复杂度可以降到<span class="math inline">\(O(n^{\frac 2 3})\)</span>.</p>
<p>#####Example1</p>
<p>求<span class="math inline">\(\sum_{i=1}^N\mu(i)\\\)</span>.</p>
<p>由于<span class="math inline">\(\mu*I=\epsilon\)</span>,于是考虑<span class="math inline">\(g=I\)</span>.</p>
<p>#####Example2</p>
<p>求<span class="math inline">\(\sum_{i=1}^N\varphi(i)\\\)</span>.</p>
<p>由于<span class="math inline">\(\varphi*I=id\)</span>,于是考虑<span class="math inline">\(g=I\)</span>.</p>
<p>#####Example3</p>
<p>求<span class="math inline">\(\sum_{i=1}^N{\varphi(i)\times
i}\\\)</span> 由于<span class="math inline">\(\sum^N_{i=1}(f*g)(i)=\sum_{d|N}{f(i)\times
g(\cfrac n d)}=\sum_{d|N}{\varphi(d)\times d\times g(\cfrac n
d)}\\\)</span> 由于中间过程中乘出来的<span class="math inline">\(d\)</span>很难处理,需要消掉它,于是考虑<span class="math inline">\(g=id\)</span>.</p>
<p>#####Example4</p>
<p><span class="math inline">\(\sum_{i=1}^N{\varphi(i)\times
i^2}\\\)</span>. 由Example3,于是考虑<span class="math inline">\(g=id^2\)</span>.</p>
<h4><span id="powerful-number筛">Powerful Number筛</span></h4>
<p>定义Powerful Number为满足所有质因子的指数都<span class="math inline">\(&gt;1\)</span>的数,不难证明这样的数在<span class="math inline">\([1,n]\)</span>中最多只有<span class="math inline">\(O(\sqrt
n)\)</span>个(使用积分).同时对于质因子的幂分奇偶讨论:奇数分成一个<span class="math inline">\(3\)</span>加上一个偶数,那么不难证明这个数一定有:<span class="math inline">\(a^2b^3\)</span>的形式.找到这些数字可以直接dfs搜指数.</p>
<p>现在我们要求积性函数<span class="math inline">\(f(n)\)</span>的前缀和.假设<span class="math inline">\(f=h*g\)</span>,其中<span class="math inline">\(h(1)=1,g(p)=f(p),\forall p\in
prime\)</span>且<span class="math inline">\(g(n)\)</span>的前缀和容易计算.</p>
<p>接下来我们证明:<span class="math inline">\(h(n)\ne0\Rightarrow n\ is\
Powerful\ Number\)</span>.</p>
<p><span class="math inline">\(\forall p\in prime\)</span>,<span class="math inline">\(f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)\)</span>,于是<span class="math inline">\(h(p)=0\)</span>.根据积性函数的性质有<span class="math inline">\(\forall x\notin \text{PN},h(x)=0\)</span>.</p>
<p>注意到: <span class="math display">\[
F(n)=\sum_{i=1}^nf(i)\\
=\sum_{i=1}^n\sum_{j|i}h(j)g(\frac{i}j)\\
=\sum_{j=1}^nh(j)G(\lfloor\frac{n}{j}\rfloor)
\]</span> 于是可以快速求,复杂度<span class="math inline">\(O(\sqrt
n)\)</span>.</p>
<h5><span id="example1sp20174divcnt3">Example1([SP20174]DIVCNT3)</span></h5>
<p>首先我们需要构造<span class="math inline">\(g(p)=f(p),p\in
prime\)</span>.注意到<span class="math inline">\(f(p)=d(p^3)=4\)</span>,我们构造<span class="math inline">\(g(p)=(d*d)(p)\)</span>.这样问题在于求<span class="math inline">\(G(n)\)</span>.我们有: <span class="math display">\[
G(n)=\sum_{i=1}^n(d*d)(i)\\
=\sum_{ij\leq n}d(i)d(j)\\
=\sum_{i=1}^nd(i)D(\lfloor\frac{n}{i}\rfloor)
\]</span> 而<span class="math inline">\(D(n)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor\)</span>,自然可以做.复杂度算一算是<span class="math inline">\(O(n^{\frac{2}{3}})\)</span>.</p>
<p>感觉Powerful Number筛的关键在于构造.</p>
<h2><span id="整值函数">整值函数</span></h2>
<h3><span id="定义">定义</span></h3>
<p>若<span class="math inline">\(x\in\mathbb{R}\)</span>,则:</p>
<p><span class="math inline">\(\lfloor
x\rfloor=\)</span>小于等于x的最大的整数.</p>
<p><span class="math inline">\(\lceil
x\rceil=\)</span>大于等于x的最小的整数.</p>
<p>我们有时称<span class="math inline">\(\lfloor
x\rfloor\)</span>为<span class="math inline">\(x\)</span>的整数部分,并定义<span class="math inline">\(x-\lfloor
x\rfloor\)</span>为分数部分,有时记作<span class="math inline">\(\{x\}\)</span>.</p>
<p>我们定义<span class="math inline">\(x\mod
y=x-y\lfloor\cfrac{x}{y}\rfloor\)</span>,<span class="math inline">\(x\
mumble\ y=y\lceil\cfrac{x}{y}\rceil-x\)</span>,其中<span class="math inline">\(x,y\in \mathbb{N_+}\)</span>.</p>
<p>当然,我们也可以使用上述定义将<span class="math inline">\(mod\)</span>和<span class="math inline">\(mumble\)</span>的定义扩展到实数域,不过<span class="math inline">\(y=0\)</span>的时候需要特殊处理.</p>
<h3><span id="整值函数的基本性值">整值函数的基本性值</span></h3>
<p>若<span class="math inline">\(x\in \mathbb{R},n\in
\mathbb{Z}\)</span>,则有:</p>
<ol type="1">
<li><span class="math inline">\(\lfloor x\rfloor=x \Leftrightarrow
\lceil x\rceil=x\Leftrightarrow x\in \mathbb{Z}\)</span>.</li>
<li><span class="math inline">\(\lceil x\rceil-\lfloor x\rfloor=[x\notin
\mathbb{Z}]\)</span>.</li>
<li><span class="math inline">\(x-1&lt;\lfloor x\rfloor\leq x\leq \lceil
x\rceil&lt;x+1\)</span>.</li>
<li><span class="math inline">\(\lfloor-x\rfloor=-\lceil x\rceil,\lceil
-x\rceil=-\lfloor x\rfloor\)</span>.</li>
<li><span class="math inline">\(\lfloor x \rfloor=n\Leftrightarrow n\leq
x&lt;n+1 \Leftrightarrow x-1&lt;n\leq x\)</span>.</li>
<li><span class="math inline">\(\lceil x\rceil =n\Leftrightarrow
n-1&lt;x\leq n\Leftrightarrow x\leq n&lt;x+1\)</span>.</li>
<li><span class="math inline">\(x&lt;n\Leftrightarrow \lfloor
x\rfloor&lt;n\)</span>.</li>
<li><span class="math inline">\(x\leq n\Leftrightarrow \lceil
x\rceil\leq n\)</span>.</li>
<li><span class="math inline">\(x&gt;n\Leftrightarrow \lceil
x\rceil&gt;n\)</span>.</li>
<li><span class="math inline">\(x\geq n\Leftrightarrow \lfloor
x\rfloor\geq n\)</span>.</li>
<li><span class="math inline">\(\lfloor x+n\rfloor=\lfloor
x\rfloor+n\)</span>.</li>
<li><span class="math inline">\(\lceil x+n\rceil=\lceil
x\rceil+n\)</span>.</li>
<li><span class="math inline">\(\lfloor nx\rfloor=n\lfloor
x\rfloor\Leftrightarrow n=0\or x-\lfloor x\rfloor&lt;
\cfrac{1}n\)</span>.</li>
<li><span class="math inline">\(\lceil nx\rceil=n\lceil
x\rceil\Leftrightarrow n=0\or x-\lceil x\rceil&lt;
\cfrac{1}n\)</span>.</li>
<li><span class="math inline">\(\lceil\cfrac{n}{m}\rceil=\lfloor\cfrac{n-1}{m}\rfloor+1,m\in\mathbb{N_+}\)</span>.</li>
<li><span class="math inline">\(m\lceil x\rceil-\lceil m(\lceil
x\rceil-x)\rceil=\lfloor mx\rfloor\)</span>.</li>
<li><span class="math inline">\((x\mod ny)\mod y=x\mod
y,n\in\mathbb{N_+}\)</span>.</li>
<li>分配律:<span class="math inline">\(c(x\mod y)=(cx)\mod
(cy)\)</span>.</li>
</ol>
<h3><span id="整值函数的应用">整值函数的应用</span></h3>
<h4><span id="一类函数与整值函数">一类函数与整值函数</span></h4>
<p>设<span class="math inline">\(f(x)\)</span>是一个有以下性质且在一个实数区间连续的单调递增函数:</p>
<p><span class="math inline">\(f(x)\in \mathbb{Z}\Rightarrow x\in
\mathbb{Z}\)</span>.</p>
<p>那么,只要<span class="math inline">\(f(x),f(\lfloor
x\rfloor),f(\lceil x\rceil)\)</span>都有定义,我们有:</p>
<p><span class="math inline">\(\lfloor f(x)\rfloor=\lfloor f(\lfloor
x\rfloor) \rfloor\)</span>和<span class="math inline">\(\lceil
f(x)\rceil=\lceil f(\lceil x\rceil) \rceil\)</span>.</p>
<p>由于底和顶是类似的,我们考虑先对顶进行证明,这样也可以类似证明底:</p>
<p>若<span class="math inline">\(x=\lceil x\rceil\)</span>,显然得证;</p>
<p>不然,有<span class="math inline">\(x&lt;\lceil
x\rceil\)</span>,那么有<span class="math inline">\(f(x)&lt;f(\lceil
x\rceil)\)</span>,也就有<span class="math inline">\(\lceil
f(x)\rceil\leq \lceil f(\lceil x\rceil) \rceil\)</span>.</p>
<p>考虑反证法,不妨令<span class="math inline">\(\lceil
f(x)\rceil&lt;\lceil f(\lceil x\rceil)
\rceil\)</span>.则一定存在一个整数<span class="math inline">\(y\)</span>使得<span class="math inline">\(\lceil
f(x)\rceil=y&lt;\lceil f(\lceil x\rceil) \rceil\)</span>,此时必有<span class="math inline">\(x\leq y&lt;\lceil x\rceil\)</span>.由于<span class="math inline">\(f\)</span>的性值,显然有<span class="math inline">\(y\)</span>是整数,但根据整值函数的性值,不可能存在这样一个整数<span class="math inline">\(y\)</span>满足<span class="math inline">\(x\leq
y&lt;\lceil x\rceil\)</span>,因此得证.</p>
<p>另外,我们考虑函数<span class="math inline">\(f(x)=\cfrac{x+m}{n}\)</span>,显然这是一个满足条件的函数,因此显然满足上述的条件.再考虑<span class="math inline">\(m=0\)</span>的特殊情况:<span class="math inline">\(\lfloor
\cfrac{\lfloor\cfrac{x}{n}\rfloor}{m}\rfloor=\lfloor\cfrac{x}{nm}\rfloor\)</span>.</p>
<p>而单调递减函数可以取相反数转化为单调递增函数.</p>
<h4><span id="迪利克雷抽屉原理">迪利克雷抽屉原理</span></h4>
<p><span class="math inline">\(n\)</span>个物体放进<span class="math inline">\(m\)</span>个盒子里,那么必定有一个盒子中放入了大于等于<span class="math inline">\(\lceil\cfrac n
m\rceil\)</span>个物品,有一个盒子放入了小于等于<span class="math inline">\(\lfloor\cfrac n m\rfloor\)</span>个物体.</p>
<h5><span id="example1">Example1</span></h5>
<p>求证:每个由<span class="math inline">\(n^2+1\)</span>个不同实数构成的序列都包含一个长为<span class="math inline">\(n+1\)</span>的严格递增子序列或严格递减子序列.</p>
<p>设<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>个实数,<span class="math inline">\(c_i\)</span>为以这个数为开头的最长的递增子序列,<span class="math inline">\(d_i\)</span>表示以这个数为开头的最长的递减子序列.考虑反证法,如果不成立,那么<span class="math inline">\(\forall 1\leq i\leq n^2+1\)</span>,<span class="math inline">\(1\leq c_i\leq n\and 1\leq d_i\leq
n\)</span>.那么一共有<span class="math inline">\(n^2\)</span>种不同的有序对.</p>
<p>根据抽屉原理,一共有<span class="math inline">\(n^2+1\)</span>个有序对,所以一定有两个有序对相等.由于这些数字两两不同,所以一定可以把其中一个数字加到另一个数字的递增或递减子序列的后面,这样那个数字的<span class="math inline">\(c_i\)</span>或者<span class="math inline">\(d_i\)</span>就要<span class="math inline">\(+1\)</span>,与我们的假设不符,因此该定理成立.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证:若任意两个人间只有两种关系:朋友或敌人.那么对于六个人而言,一定有三个人两两都是朋友或者两两都是敌人.</p>
<p>令<span class="math inline">\(A\)</span>是这六个人中其中一个,根据抽屉原理,一定有大于等于<span class="math inline">\(3\)</span>个人都是<span class="math inline">\(A\)</span>的敌人或者都是<span class="math inline">\(A\)</span>的朋友,不妨假设这三个人都是<span class="math inline">\(A\)</span>的朋友.</p>
<p>如果这三个人中有两个人是朋友,那么它们和A就一起构成了一组人.不然,他们三个人就构成了一组人.</p>
<h4><span id="计算区间内整数个数">计算区间内整数个数</span></h4>
<p>整值函数的另一个应用是计算区间内整数个数:</p>
<p>考虑基本性值<span class="math inline">\(7,8,9,10\)</span>,不难发现:</p>
<ol type="1">
<li><span class="math inline">\([\alpha,\beta]\)</span>包含<span class="math inline">\(\lfloor\beta\rfloor-\lceil\alpha\rceil+1\)</span>个整数.</li>
<li><span class="math inline">\((\alpha,\beta)\)</span>包含<span class="math inline">\(\lceil\beta\rceil-\lfloor\alpha\rfloor-1\)</span>个整数.</li>
<li><span class="math inline">\((\alpha,\beta]\)</span>包含<span class="math inline">\(\lfloor\beta\rfloor-\lfloor\alpha\rfloor\)</span>个整数.</li>
<li><span class="math inline">\([\alpha,\beta)\)</span>包含<span class="math inline">\(\lceil\beta\rceil-\lceil\alpha\rceil\)</span>个整数.</li>
</ol>
<h4><span id="谱">谱</span></h4>
<p>我们定义一个实数<span class="math inline">\(\alpha\)</span>的<strong>谱</strong>是以下集合:</p>
<p><span class="math inline">\(Spec(\alpha)=\{\lfloor\alpha\rfloor,\lfloor2\alpha\rfloor,\lfloor3\alpha\rfloor...\}\)</span>.</p>
<p>不难发现,只要<span class="math inline">\(\alpha\ne\beta\)</span>,则<span class="math inline">\(Spec(\alpha)\ne Spec(\beta)\)</span>.</p>
<h5><span id="example">Example</span></h5>
<p>求证:<span class="math inline">\(Spec(\sqrt2)\cup
Spec(2+\sqrt2)=\mathbb{N_+}\)</span>且<span class="math inline">\(Spec(\sqrt2)\cap
Spec(2+\sqrt2)=\phi\)</span>,即这两个集合构成了正整数集的一个划分.</p>
<p>我们考虑这样一个事实:对于任意正整数<span class="math inline">\(n\)</span>,如果我们能求出来<span class="math inline">\(Spec(\sqrt2)\)</span>中有<span class="math inline">\(a\)</span>个元素<span class="math inline">\(\leq
n\)</span>,<span class="math inline">\(Spec(2+\sqrt2)\)</span>中有<span class="math inline">\(b\)</span>个元素<span class="math inline">\(\leq
n\)</span>,并且<span class="math inline">\(a+b=n\)</span>,则结论显然成立.</p>
<p>不妨令函数<span class="math inline">\(N(\alpha,n)\)</span>表示<span class="math inline">\(Spec(\alpha)\)</span>中有多少个元素<span class="math inline">\(\leq n\)</span>,其中<span class="math inline">\(\alpha\)</span>是正数,我们有: <span class="math display">\[
N(\alpha,n)=\sum_{k\in\mathbb{N_+}}[\lfloor k\alpha\rfloor\leq n]\\
=\sum_{k\in\mathbb{N_+}}[\lfloor k\alpha\rfloor&lt; n+1]\\
=\sum_{k\in\mathbb{N_+}}[k\alpha&lt; n+1]\\
=\sum_k[0&lt;k&lt;(n+1)/\alpha]\\
=\lceil(n+1)/\alpha\rceil-1
\]</span> 则我们要证明的就是: <span class="math display">\[
\lceil\cfrac{n+1}{\sqrt2}\rceil-1+\lceil\cfrac{n+1}{2+\sqrt2}\rceil-1=n\\
\lfloor\cfrac{n+1}{\sqrt2}\rfloor+\lfloor\cfrac{n+1}{2+\sqrt2}\rfloor=n\\
\cfrac{n+1}{\sqrt2}-\{\cfrac{n+1}{\sqrt2}\}+\cfrac{n+1}{2+\sqrt2}-\{\cfrac{n+1}{2+\sqrt2}\}=n
\]</span> 而由于我们有恒等式:<span class="math inline">\(\cfrac1{\sqrt2}+\cfrac{1}{2+\sqrt2}=1\)</span>,且两个相加为整数的数的分数部分相加显然为<span class="math inline">\(1\)</span>,原式得证.</p>
<p>事实上,如果两个集合<span class="math inline">\(Spec(\alpha)\)</span>和<span class="math inline">\(Spac(\beta)\)</span>构成正整数集一个划分,可以同上证明<span class="math inline">\(\cfrac1\alpha+\cfrac1\beta=1\)</span>且<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>都是无理数.</p>
<h4><span id="整值函数的递归式">整值函数的递归式</span></h4>
<p>得到递归式的封闭形式的确很有用,它可以让我们在很快的时间内求出答案,但大部分时候是很麻烦的.</p>
<p>而如果我们对时间的要求没有那么紧,我们不妨考虑一种较慢但更容易的方法:</p>
<h5><span id="example">Example</span></h5>
<p>约瑟夫问题,但是每隔两个人处死一个人,求最后存活者的编号.</p>
<p>我们不妨这样考虑:我们每略过两个人,就将他们重新编号.</p>
<p>例如,我们杀掉了三号,就将一号和二号重新编号为<span class="math inline">\(n+1\)</span>号和<span class="math inline">\(n+2\)</span>号,杀掉了六号,就将四号和五号重新编号为<span class="math inline">\(n+3\)</span>号和<span class="math inline">\(n+4\)</span>号,这样,我们在做游戏的时候,场上人员的编号一定是连续的.</p>
<p>我们把最后存活者改为最后死亡者,这样它的最后编号就是<span class="math inline">\(3n\)</span>.</p>
<p>并且不难发现,第<span class="math inline">\(k\)</span>个死亡的人的最后编号就是<span class="math inline">\(3k\)</span>.</p>
<p>我们考虑已知新编号如何求旧编号,设新编号为<span class="math inline">\(N\)</span>:</p>
<p>如果<span class="math inline">\(N\leq n\)</span>,则<span class="math inline">\(N\)</span>是初始编号,反之,我们考虑在编号<span class="math inline">\(N\)</span>的时候被杀死的人的编号.</p>
<p>假设现在进行完了<span class="math inline">\(k+1\)</span>轮,令<span class="math inline">\(N=n+2k+w\)</span>,其中<span class="math inline">\(w\in\{1,2\}\)</span>,则编号<span class="math inline">\(N\)</span>的时候被杀死的即是<span class="math inline">\(3(k+1)\)</span>,那么<span class="math inline">\(N\)</span>之前的编号就是<span class="math inline">\(3k+w=N-(n-k)=N-n+k\)</span>.</p>
<p>而<span class="math inline">\(k=\lfloor\cfrac
{(N-n-1)}{2}\rfloor\)</span>,我们可以不断进行迭代.</p>
<p>如果我们令<span class="math inline">\(D=3n+1-N\)</span>,换句话说即改变编号的顺序,我们可以有以下的赋值操作:</p>
<p><span class="math inline">\(3n+1-D&#39;=3n+1-D-n+\lfloor\cfrac
{(3n+1-D-n-1)}{2}\rfloor\)</span>.</p>
<p>化简这个式子,我们有:<span class="math inline">\(D&#39;=D+n-\lfloor\cfrac
{(2n-D)}{2}\rfloor=D+\lceil\cfrac{D}{2}\rceil=\lceil\cfrac{3D}2\rceil\)</span>.</p>
<p>事实上,我们可以证明:如果我们每隔<span class="math inline">\(q\)</span>个人就杀掉一个人的话,那么<span class="math inline">\(D&#39;=\lceil\cfrac{(q+1)D}{q}\rceil\)</span>,一直迭代到<span class="math inline">\(D&#39;&gt;qn\)</span>时.</p>
<p>而最后的答案就是<span class="math inline">\((q+1)n+1-D\)</span>.</p>
<h4><span id="整值函数的恒等式">整值函数的恒等式</span></h4>
<p>考虑公式<span class="math inline">\(\lceil\cfrac{n-k+1}{m}\rceil\)</span>,不难发现它在<span class="math inline">\(1\leq k\leq n\mod m\)</span>时的值为<span class="math inline">\(\lceil\cfrac{n}{m}\rceil\)</span>,而在<span class="math inline">\(n\mod m&lt;k\leq m\)</span>的值为<span class="math inline">\(\lfloor\cfrac n m\rfloor\)</span>.</p>
<p>那么我们可以得到以下恒等式:</p>
<p><span class="math inline">\(n=\sum_{k=1}^m\lceil\cfrac{n-k+1}{m}\rceil\)</span>.</p>
<p>类似地,有:</p>
<p><span class="math inline">\(n=\sum_{k=1}^m\lfloor\cfrac{n+k-1}{m}\rfloor\)</span>.</p>
<p>用<span class="math inline">\(\lfloor
mx\rfloor\)</span>替换上面的<span class="math inline">\(n\)</span>有<span class="math inline">\(\lfloor
mx\rfloor=\sum_{k=1}^m\lfloor x+\cfrac{k-1}{m}\rfloor\)</span>.</p>
<p>同样的,有<span class="math inline">\(\lceil
mx\rceil=\sum_{k=1}^m\lceil x-\cfrac{k-1}{m}\rceil\)</span>.</p>
<h4><span id="整值函数的和式">整值函数的和式</span></h4>
<p>通常情况下,处理含整值函数的和式时,通过引入新变量进行代替以及通过转化为区间进行化简.</p>
<p>如果遇到难以处理的情况,我们不妨考虑直接处理其中一段的和,使得剩下部分求和更为简单.</p>
<p>处理整值函数的另一个方法是:考虑将整值函数内的东西移出,并且让里面的东西形如等差序列,这样我们就可以尝试使用恒等式来化简.</p>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{k=0}^{n-1}\lfloor\sqrt
k\rfloor\)</span>.</p>
<p>我们有: <span class="math display">\[
\sum_{k=0}^{n-1}\lfloor\sqrt k\rfloor=\sum_{0\leq
k,m}[k&lt;n][m=\lfloor\sqrt k\rfloor]m\\
=\sum_{0\leq k,m}[k&lt;n][m^2\leq k&lt;(m+1)^2]m\\
=\sum_{0\leq k,m}m[m^2\leq k&lt;n&lt;(m+1)^2]+\sum_{0\leq k,m}m[m^2\leq
k&lt;(m+1)^2\leq n]
\]</span> 考虑<span class="math inline">\(n=a^2\)</span>的特殊情况,则前面那一项显然是<span class="math inline">\(0\)</span>,那么: <span class="math display">\[
ans=\sum_{0\leq k,m}m[m^2\leq k&lt;(m+1)^2\leq n]\\
=\sum_{0\leq m}m(2m+1)[m&lt;a]\\
=\sum_{m=0}^{a-1}(2m^2+m)\\
=\cfrac{(a-1)a(2a-1)}{3}+\cfrac{a(a-1)}{2}\\
=\cfrac{(4a+1)a(a-1)}{6}
\]</span> 而如果<span class="math inline">\(n\ne
a^2\)</span>,我们令<span class="math inline">\(a=\lfloor\sqrt
n\rfloor\)</span>,而当<span class="math inline">\(k\in
[a^2,n)\)</span>的部分的贡献显然是<span class="math inline">\(a(n-a^2)\)</span>.</p>
<p>于是最后的结果就是:<span class="math inline">\(\cfrac{(4a+1)a(a-1)}{6}+a(n-a^2),a=\lfloor\sqrt
n\rfloor\)</span>.</p>
<p>另一个做法是,我们考虑增加枚举量,有: <span class="math display">\[
\sum_{k=0}^{n-1}\lfloor\sqrt k\rfloor=\sum_{j,k}[1\leq j\leq \sqrt
k][0\leq k&lt;a^2]\\
=\sum_{1\leq j&lt;a}\sum_{k}[j^2\leq k&lt;a^2]\\
=\sum_{1\leq j&lt;a}a^2-j^2=a^3-\cfrac{a(2a+1)(a+1)}{6}
\]</span></p>
<h5><span id="example2类欧几里得算法">Example2(类欧几里得算法)</span></h5>
<p>求<span class="math inline">\(\sum_{k=0}^{m-1}\lfloor\cfrac{nk+x}{m}\rfloor,m\in\mathbb{N_+},n\in
\mathbb{Z}\)</span>.</p>
<p>由于<span class="math inline">\(kn-(kn\mod
m)=m\lfloor\cfrac{kn}{m}\rfloor\)</span>,我们有:</p>
<p><span class="math display">\[
\lfloor\cfrac{x+kn}{m}\rfloor=\lfloor\cfrac{x+(kn\mod
m)}{m}\rfloor+\cfrac{kn}{m}-\cfrac{kn\mod m}{m}
\]</span>
这样,我们将整个式子的求和分为了三部分,第二项显然是等差数列求和,而如果我们令<span class="math inline">\(g=\gcd(n,m)\)</span>,不难发现第三项的分子是一个等差数列<span class="math inline">\(0,g,2g,...m-g\)</span>重复了<span class="math inline">\(g\)</span>次,而且正因为这,第一项里面的数也就自然组成了等差数列,由于我们有恒等式,那么这一项也就自然可以计算了.</p>
<p>分别求和后加起来,得到答案为<span class="math inline">\(g\lfloor\cfrac{x}{g}\rfloor+\cfrac{(m-1)n}{2}+\cfrac{g-m}{2}\)</span>.</p>
<p>另外,对这个式子进行化简,我们可以得到:<span class="math inline">\(g\lfloor\cfrac{x}{g}\rfloor+\cfrac{(m-1)(n-1)}{2}+\cfrac{g-1}2\)</span>,而这个式子关于<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>是对称的.</p>
<p>也就是说:<span class="math inline">\(\sum_{k=0}^{m-1}\lfloor\cfrac{nk+x}{m}\rfloor=\sum_{k=0}^{n-1}\lfloor\cfrac{mk+x}{n}\rfloor,m,n\in\mathbb{N_+}\)</span>.</p>
<p>另外,如果要求<span class="math inline">\(\sum^n_{i=0}\lfloor\cfrac{ai+b}{c}\rfloor\)</span>,我们也有一种<span class="math inline">\(O(\log n)\)</span>的做法(类欧几里得算法):</p>
<p>若<span class="math inline">\(c\leq a\)</span>,原式化为<span class="math inline">\(\sum^n_{i=0}{(i\times\lfloor\frac{a}{c}\rfloor+\lfloor\cfrac{(a\mod
c)i+b}{c}\rfloor)}\)</span>.</p>
<p>若<span class="math inline">\(c\leq b\)</span>,原式化为<span class="math inline">\(\sum^n_{i=0}{\lfloor\cfrac{b}{c}\rfloor+\lfloor\cfrac{ai+(b\mod
c)}{c}\rfloor}\)</span>.</p>
<p>考虑<span class="math inline">\(a,b&lt;c\)</span>的情况,设<span class="math inline">\(m=\lfloor\cfrac{an+b}{c}\rfloor\)</span>,原式化为
<span class="math display">\[
\sum^n_{i=0}\sum^m_{j=1}[j\leq
\lfloor\cfrac{ai+b}{c}\rfloor]\\=\sum^n_{i=0}\sum^m_{j=1}[cj\leq
ai+b]\\=nm-\sum^n_{i=0}\sum^m_{j=1}[ai\leq
cj-b-1]\\=nm-\sum^m_{i=1}\lfloor\cfrac{ci-b-1}{a}\rfloor
\]</span></p>
<p>#####Example3</p>
<p>求<span class="math inline">\(\sum_{n=1}^{1000}[\lfloor\sqrt[3]n\rfloor|n]\)</span>.
<span class="math display">\[
ans=\sum_{n,k}[k=\lfloor\sqrt[3]n\rfloor][k|n][1\leq n\leq 1000]\\
=\sum_{k,m,n}[k^3\leq n&lt;(k+1)^3][n=km][1\leq n\leq 1000]\\
=1+\sum_{k,m}[k^3\leq km&lt;(k+1)^3][1\leq k&lt; 10]\\
=1+\sum_{k,m}[k^2\leq m&lt;\frac{(k+1)^3}k][1\leq k&lt;10]\\
=1+\sum_{k=1}^9(\lceil k^2+3k+3+\frac1 k\rceil-\lceil k^2\rceil)\\
=1+\sum_{k=1}^9(3k+4)=172
\]</span> 上述推理过程将<span class="math inline">\(n=1000\)</span>的情况特殊讨论了一下,不难发现,如果我们要求的式子是<span class="math inline">\(\sum_{n=1}^{N}[\lfloor\sqrt[3]n\rfloor|n]\)</span>,也仍然可以使用将<span class="math inline">\([K^3,N],K=\lfloor\sqrt[3]N\rfloor\)</span>中的数特殊处理的方式做掉,因为这些数的三次根下取整一定是<span class="math inline">\(K\)</span>,式子就不难化简了.</p>
<h5><span id="example4uoj42sum">Example4([uoj42]Sum)</span></h5>
<p>这题的重点在于将幂通过<span class="math inline">\(-1\)</span>的性质拿下来.</p>
<p>我们有<span class="math inline">\((-1)^a=1-2(a\mod
2)=1-2(a-2\lfloor\frac{a}{2}\rfloor)\)</span>.</p>
<p>于是我们有: <span class="math display">\[
\sum_{d=1}^n(-1)^{\lfloor d\sqrt r\rfloor}\\=n-2\sum_{d=1}^n\lfloor
d\sqrt r\rfloor+4\sum_{d=1}^n\lfloor\frac{\lfloor d\sqrt
r\rfloor}{2}\rfloor\\
\]</span> 令<span class="math inline">\(f(x)=\frac{x}2\)</span>,根据整值函数的性质,不难发现<span class="math inline">\(\lfloor\frac{\lfloor d\sqrt
r\rfloor}{2}\rfloor=\lfloor\frac{d\sqrt r}{2}\rfloor\)</span>.</p>
<p>于是我们有: <span class="math display">\[
ans=n-2\sum_{d=1}^n\lfloor d\sqrt
r\rfloor+4\sum_{d=1}^n\lfloor\frac{d\sqrt r}{2}\rfloor\\
\]</span> 记<span class="math inline">\(t=\sqrt
r\)</span>,我们所要解决的问题是<span class="math inline">\(\sum_{d=1}^n\lfloor
d\frac{Pt+R}{Q}\rfloor\)</span>.如果<span class="math inline">\(\frac{Pt+R}{Q}\geq
1\)</span>,我们可以把整数部分取出来单独算.于是接下来我们只讨论<span class="math inline">\(0\leq
\frac{Pt+R}{Q}&lt;1\)</span>的情况.相当于求一条斜率小于<span class="math inline">\(1\)</span>的直线下方的整点个数.我们可以反转坐标系,这样就变成了斜率大于<span class="math inline">\(1\)</span>的直线,继续做上面的操作.</p>
<p>这个问题引出万能欧几里得算法.</p>
<h5><span id="example5loj6440万能欧几里得算法">Example5([loj6440]万能欧几里得算法)</span></h5>
<p>解决形如<span class="math inline">\(\sum_{x=1}^{L}A^xB^{\lfloor\frac{Px+R}{Q}\rfloor}\)</span>的问题,其中<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是<span class="math inline">\(n\times
n\)</span>的矩阵.默认<span class="math inline">\(P,Q,R\geq
0\)</span>.</p>
<p>我们将问题抽象为下面的模型:</p>
<p>首先将坐标系中所有经过整数点的与坐标轴平行的直线全都标记出来.</p>
<p>考虑将问题转化为:有一条<span class="math inline">\(y=\frac{Px+R}{Q}\)</span>的直线,我们从<span class="math inline">\((0,\frac{R}{Q})\)</span>(不包含这个点)处开始沿直线向右走.每遇到一条横线,就进行<span class="math inline">\(U_w\)</span>操作;每遇到一条竖线,就进行<span class="math inline">\(R_w\)</span>操作.如果遇到了整数格点,就先进行<span class="math inline">\(U_w\)</span>操作,再进行<span class="math inline">\(R_w\)</span>操作.</p>
<p>例如上面那个例子就是:现在有一个矩阵二元组<span class="math inline">\((X,Y)\)</span>,初始为<span class="math inline">\((A,B^{\lfloor\frac{R}{Q}\rfloor})\)</span>,<span class="math inline">\(R_w\)</span>操作是:<span class="math inline">\((X,Y)\rightarrow (AX,Y+X)\)</span>,<span class="math inline">\(U_w\)</span>操作是:<span class="math inline">\((X,Y)\rightarrow(XB,Y)\)</span>.一直走到<span class="math inline">\(x=L\)</span>的点为止,最后矩阵<span class="math inline">\(Y\)</span>就是答案.不过这个形式不好写成矩阵,我们可以记录<span class="math inline">\((A^a,B^b,Y)\)</span>.这样最后就可以带入操作,不难发现这个操作是个环.</p>
<p>操作要满足可合并性,也就是我可以将<span class="math inline">\(U_wR_w\)</span>变成一个操作进行.</p>
<p>接下来我们分情况讨论一下:</p>
<p>当<span class="math inline">\(P\geq Q\)</span>时,注意到<span class="math inline">\(y=\frac{Px+R}{Q}=\lfloor\frac{P}{Q}\rfloor
x+\frac{(P\mod Q)x+R}{Q}\)</span>,此时任意一个<span class="math inline">\(R_w\)</span>操作前必然有至少<span class="math inline">\(\lfloor\frac{P}{Q}\rfloor\)</span>个<span class="math inline">\(U_w\)</span>,我们令<span class="math inline">\(R_w&#39;=U_w^{\lfloor\frac{P}{Q}\rfloor}R_w\)</span>,不难发现:<span class="math inline">\(solve(P,Q,R,L,U_w,R_w)=solve(P\mod
Q,Q,R,L,U_w,R_w&#39;)\)</span>.</p>
<p>当<span class="math inline">\(P&lt;Q\and P\ne
0\)</span>时,我们想要让<span class="math inline">\(P\)</span>与<span class="math inline">\(Q\)</span>互换,假设第<span class="math inline">\(a\)</span>个<span class="math inline">\(R_w\)</span>在第<span class="math inline">\(b\)</span>个<span class="math inline">\(U_w\)</span>之前,考虑这个<span class="math inline">\(R_w\)</span>前会有<span class="math inline">\(\lfloor\frac{Pa+R}{Q}\rfloor-\lfloor\frac{R}{Q}\rfloor\)</span>个<span class="math inline">\(U_w\)</span>,而对于后者,变换坐标系得到<span class="math inline">\(x=\frac{yQ-R}{P}\)</span>,由于遇到整点时,先<span class="math inline">\(U_w\)</span>再进行<span class="math inline">\(R_w\)</span>,也就是说,第<span class="math inline">\(b\)</span>个<span class="math inline">\(U_w\)</span>前会有<span class="math inline">\(\lfloor\frac{Qb-R-1}{P}\rfloor\)</span>个<span class="math inline">\(R_w\)</span>(这个并没有忽略初始位置).我们考虑如何让这个数和上面的<span class="math inline">\(\lfloor\frac{Pa+R}{Q}\rfloor\)</span>的差分写成一样的形式.注意到<span class="math inline">\(b=1\)</span>需要特殊处理!</p>
<p>显然操作序列一共有<span class="math inline">\(cntU=\lfloor\frac{PL+R}{Q}\rfloor-\lfloor\frac{R}{Q}\rfloor\)</span>,将二者对应一下,这里的答案就是<span class="math inline">\(solve(Q,P,(Q-R-1)\bmod
P,cntU-1,R_w,U_w)\)</span>.</p>
<p>然后是开头部分,开头部分一共有<span class="math inline">\(\lfloor\frac{Q-R-1}{P}\rfloor\)</span>个<span class="math inline">\(R_w\)</span>和一个<span class="math inline">\(U_w\)</span>.</p>
<p>但是注意到末尾部分同样是不规整的,注意到末尾一共有<span class="math inline">\(L-\lfloor\frac{QcntU-R-1}{P}\rfloor\)</span>个<span class="math inline">\(R_w\)</span>,拼到末尾即可.</p>
<p>最后<span class="math inline">\(P=0\)</span>的时候直接返回<span class="math inline">\(R_w^{L}\)</span>即可.</p>
<p>假设合并的复杂度是<span class="math inline">\(c\)</span>,注意到每层的复杂度是<span class="math inline">\(O(c\log(\frac{Q}{P}))=O(c(\log Q-\log
P))\)</span>,但是每两层会抵消,因此复杂度<span class="math inline">\(O(C\log(P+Q))\)</span>.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>平邑一中集训作业</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#反悔贪心">反悔贪心</a></li>
<li><a href="#扫描线">扫描线</a>
<ul>
<li><a href="#第一题">第一题</a></li>
<li><a href="#第二题">第二题</a></li>
</ul></li>
<li><a href="#二分图hall定理">二分图HALL定理</a>
<ul>
<li><a href="#第一题-1">第一题</a></li>
<li><a href="#第二题-1">第二题</a></li>
<li><a href="#第三题">第三题</a></li>
<li><a href="#第四题">第四题</a></li>
<li><a href="#第五题">第五题</a></li>
<li><a href="#第六题">第六题</a></li>
<li><a href="#第七题">第七题</a></li>
<li><a href="#第八题">第八题</a></li>
</ul></li>
<li><a href="#轮廓线dp">轮廓线dp</a>
<ul>
<li><a href="#第一题-2">第一题</a></li>
<li><a href="#第二题-2">第二题</a></li>
<li><a href="#第五题-1">第五题</a></li>
<li><a href="#第六题-1">第六题</a></li>
</ul></li>
<li><a href="#广义串并联图">广义串并联图</a>
<ul>
<li><a href="#第一题-3">第一题</a></li>
<li><a href="#第二题-3">第二题</a></li>
<li><a href="#第三题-1">第三题</a></li>
</ul></li>
<li><a href="#动态规划第一期">动态规划第一期</a>
<ul>
<li><a href="#第一题-4">第一题</a></li>
<li><a href="#第二题-4">第二题</a></li>
<li><a href="#第三题-2">第三题</a></li>
<li><a href="#第四题-1">第四题</a></li>
<li><a href="#第五题-2">第五题</a></li>
<li><a href="#第六题-2">第六题</a></li>
</ul></li>
<li><a href="#组合数学">组合数学</a>
<ul>
<li><a href="#第一题-5">第一题</a></li>
<li><a href="#第二题第三题">第二题/第三题</a></li>
<li><a href="#第四题-2">第四题</a></li>
<li><a href="#第五题-3">第五题</a></li>
<li><a href="#第六题-3">第六题</a></li>
<li><a href="#第七题-1">第七题</a></li>
</ul></li>
<li><a href="#二项式反演">二项式反演</a>
<ul>
<li><a href="#第一题-6">第一题</a></li>
<li><a href="#第二题-5">第二题</a></li>
<li><a href="#第三题-3">第三题</a></li>
<li><a href="#第四题-3">第四题</a></li>
<li><a href="#第五题-4">第五题</a></li>
<li><a href="#第六题-4">第六题</a></li>
<li><a href="#第七题-2">第七题</a></li>
<li><a href="#第八题-1">第八题</a></li>
<li><a href="#第九题">第九题</a></li>
<li><a href="#第十题第十一题">第十题/第十一题</a></li>
<li><a href="#第十二题">第十二题</a></li>
<li><a href="#第十三题">第十三题</a></li>
</ul></li>
<li><a href="#字符串算法">字符串算法</a>
<ul>
<li><a href="#第一题-7">第一题</a></li>
<li><a href="#第二题-6">第二题</a></li>
<li><a href="#第三题-4">第三题</a></li>
<li><a href="#第四题-4">第四题</a></li>
<li><a href="#第五题-5">第五题</a></li>
<li><a href="#第六题-5">第六题</a></li>
<li><a href="#第七题-3">第七题</a></li>
<li><a href="#第八题-2">第八题</a></li>
<li><a href="#第九题-1">第九题</a></li>
</ul></li>
<li><a href="#动态规划第二期">动态规划第二期</a>
<ul>
<li><a href="#第一题-8">第一题</a></li>
<li><a href="#第二题-7">第二题</a></li>
<li><a href="#第三题-5">第三题</a></li>
<li><a href="#第四题-5">第四题</a></li>
<li><a href="#第五题-6">第五题</a></li>
<li><a href="#第六题-6">第六题</a></li>
</ul></li>
<li><a href="#数据结构">数据结构</a>
<ul>
<li><a href="#第一题-9">第一题</a></li>
<li><a href="#第二题-8">第二题</a></li>
<li><a href="#第三题-6">第三题</a></li>
<li><a href="#第四题-6">第四题</a></li>
<li><a href="#第五题-7">第五题</a></li>
<li><a href="#第六题-7">第六题</a></li>
<li><a href="#第七题-4">第七题</a></li>
<li><a href="#第八题-3">第八题</a></li>
</ul></li>
<li><a href="#图论">图论</a>
<ul>
<li><a href="#第一题-10">第一题</a></li>
<li><a href="#第二题-9">第二题</a></li>
<li><a href="#第三题-7">第三题</a></li>
<li><a href="#第四题-7">第四题</a></li>
<li><a href="#第五题-8">第五题</a></li>
<li><a href="#第六题-8">第六题</a></li>
<li><a href="#第七题-5">第七题</a></li>
<li><a href="#第八题-4">第八题</a></li>
</ul></li>
<li><a href="#线性代数">线性代数</a>
<ul>
<li><a href="#第一题-11">第一题</a></li>
<li><a href="#第二题-10">第二题</a></li>
<li><a href="#第三题-8">第三题</a></li>
<li><a href="#第四题-8">第四题</a></li>
<li><a href="#第五题-9">第五题</a></li>
<li><a href="#第六题-9">第六题</a></li>
<li><a href="#第七题-6">第七题</a></li>
<li><a href="#第八题-5">第八题</a></li>
<li><a href="#第九题-2">第九题</a></li>
<li><a href="#第十题">第十题</a></li>
<li><a href="#第十一题">第十一题</a></li>
</ul></li>
<li><a href="#计算几何">计算几何</a>
<ul>
<li><a href="#第一题-12">第一题</a></li>
<li><a href="#第二题-11">第二题</a></li>
<li><a href="#第三题-9">第三题</a></li>
<li><a href="#第四题-9">第四题</a></li>
<li><a href="#第五题第六题第七题">第五题/第六题/第七题</a></li>
<li><a href="#第九题-3">第九题</a></li>
<li><a href="#第十题-1">第十题</a></li>
<li><a href="#第十一题-1">第十一题</a></li>
<li><a href="#第十二题-1">第十二题</a></li>
</ul></li>
<li><a href="#网络流建图">网络流建图</a>
<ul>
<li><a href="#第一题-13">第一题</a></li>
<li><a href="#第二题-12">第二题</a></li>
<li><a href="#第三题-10">第三题</a></li>
<li><a href="#第四题-10">第四题</a></li>
<li><a href="#第五题-10">第五题</a></li>
<li><a href="#第六题-10">第六题</a></li>
<li><a href="#第七题-7">第七题</a></li>
</ul></li>
<li><a href="#交互题练习">交互题练习</a>
<ul>
<li><a href="#第一题-14">第一题</a></li>
<li><a href="#第二题-13">第二题</a></li>
<li><a href="#第三题-11">第三题</a>
<ul>
<li><a href="#sub1">Sub1</a></li>
<li><a href="#sub2">Sub2</a></li>
<li><a href="#sub3">Sub3</a></li>
<li><a href="#sub4">Sub4</a></li>
<li><a href="#sub5">Sub5</a></li>
</ul></li>
<li><a href="#第四题-11">第四题</a></li>
<li><a href="#第五题-11">第五题</a></li>
<li><a href="#第六题-11">第六题</a></li>
</ul></li>
<li><a href="#模拟退火">模拟退火</a>
<ul>
<li><a href="#第一题-15">第一题</a></li>
<li><a href="#第二题-14">第二题</a></li>
<li><a href="#第三题-12">第三题</a></li>
<li><a href="#第五题-12">第五题</a></li>
<li><a href="#第六题-12">第六题</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="反悔贪心">反悔贪心</span></h3>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6940</p>
<p>首先发现,从上往下扫行,然后对于每个右下角匹配一个列最近的左上角是最优秀的.所以拿set维护上述过程.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3268</p>
<p>这题比较厉害,直接扫,然后维护每个圆当前与这条线的两个交点,注意到这些交点的顺序是固定的,于是可以拿set维护.</p>
<h3><span id="二分图hall定理">二分图HALL定理</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc076_d</p>
<p>根据Hall定理,我们只要找到一个子集的人,使得人数与它们的区间的并所包含的椅子数量之差最大,这个最大值就是答案.而它们区间的并显然是同样类型的区间,也就是中间扣去一段.考虑枚举中间扣去的那一段是啥,就可以快速算答案.这玩意可以扫描线维护.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF981F</p>
<p>一眼丁真,鉴定为二分+Hall定理.</p>
<p>这题真正的难点在于如何check.考虑我们现在有了若干个区间<span class="math inline">\([l,r]\)</span>,每个整数点上都有一个人.然后要check.那就必须满足<span class="math inline">\(r_j-l_i\geq j-i\)</span>,这意味着<span class="math inline">\(r_j-j\geq l_i-i\)</span>,然后就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3488</p>
<p>比较简单,考虑如果最后找的若干个区间是分开的,那它们必然其中有一个区间自己就不合法.因此找到这个区间就行,然后每个位置减去<span class="math inline">\(k\)</span>,用线段树维护区间小子段和判断加上<span class="math inline">\(k\times d\)</span>是否小于<span class="math inline">\(0\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>这题比较厉害啊.首先猜到要用网络流.</p>
<p>然后注意到选的集合<span class="math inline">\(=\)</span>选的数字等价于不选的集合<span class="math inline">\(+\)</span>选的数字<span class="math inline">\(=n\)</span>.考虑最小割.先将边权全部取反,这样变成求最大权值,</p>
<p>然后集合连权值加上一个极大值<span class="math inline">\(M\)</span>,单点连极大值<span class="math inline">\(M\)</span>.这样割掉一个单点意味着选这个单点,割掉一个集合意味着不选这个集合.由于存在完美匹配,因此一定会跑出答案.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc106_e</p>
<p>首先答案显然不会超过<span class="math inline">\(2nk\)</span>,考虑二分,这样每一天会有哪些人来就知道了.然后对着上面的信息做高维前缀和就可以知道对于一个人的集合,它会来哪些天.这样就可以check.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc037_d</p>
<p>考虑最后<span class="math inline">\(C\rightarrow
D\)</span>显然需要把该放的位置归位,这样我们的<span class="math inline">\(a\)</span>里面存的完全可以是它应该在第几行这个信息.</p>
<p>再考虑<span class="math inline">\(B\rightarrow
C\)</span>,显然只需要保证每列的<span class="math inline">\(a\)</span>互不相同,这一步就可以满足上面的要求.</p>
<p>于是,<span class="math inline">\(A\rightarrow
B\)</span>只需要保证每列的<span class="math inline">\(a\)</span>互不相同.这个可以使用网络流实现.</p>
<p>那么,如何证明一定有解呢?这是一张正则二分图,根据Hall定理推论,一定存在完美匹配.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc029_f</p>
<p>这题好牛啊.发现如果几个集合的并的点数过少,那么一定无解.因为怎么连都会连出环来.这直接将整个题的思路引向Hall定理.</p>
<p>考虑直接做二分图匹配.左边是点右边是集合,然后连边.</p>
<p>那么根据Hall定理一定存在<span class="math inline">\(n-1\)</span>的匹配,并且恰好有一个点没被匹配到.我们干脆删掉这个点,最后再加回来.事实上理论上来说我删掉哪个点都应该存在完美匹配,我们先只删一个.然后从<span class="math inline">\(r\)</span>开始不断dfs找到一条遍历所有边的交错树,对着交错树构造就行.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1519F</p>
<p>首先注意到,只要任意一个宝箱集合需要的钥匙集合的权值大于等于自己,那Bob就输了.这类似Hall定理.我们把钥匙和宝箱都拆点,然后判断拆点后的图是否存在完美匹配.求完美匹配可以使用状压.</p>
<h3><span id="轮廓线dp">轮廓线dp</span></h3>
<p>这个板块好像没啥说的,因为思维难度远低于代码难度.而且思路都比较直接.</p>
<p>放一下我做的题.</p>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5056</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2289</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3886</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P1933</p>
<h3><span id="广义串并联图">广义串并联图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6790</p>
<p>比较简单,首先这个图这么简单,那它大概率是个广义串并联图.感性理解一下,<span class="math inline">\(n\geq
4\)</span>的时候肯定是存在度数较小的边的,并且你在合并的过程中它也一直是仙人掌+至多一条边的形状.</p>
<p>然后简单做做.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P8426</p>
<p>ps:本题选入笔记:图论-广义串并联图/三度化-Example2.</p>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>在一个点双中,我们找到两个点<span class="math inline">\(u,v\)</span>,使得<span class="math inline">\(u\rightarrow v\)</span>,并且<span class="math inline">\(u\)</span>的出度至少是<span class="math inline">\(2\)</span>,<span class="math inline">\(v\)</span>的入度至少是<span class="math inline">\(2\)</span>,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为<span class="math inline">\(2\)</span>的点<span class="math inline">\(v\)</span>,找到它的入点<span class="math inline">\(u\)</span>,如果<span class="math inline">\(u\)</span>的出度不是<span class="math inline">\(2\)</span>,那么<span class="math inline">\(u\)</span>也是一个入度至少为<span class="math inline">\(2\)</span>的点.这样往前推一定至少能推到一个点(因为不可能<span class="math inline">\(S\)</span>贡献了俩入度).</p>
<p>如何保证<span class="math inline">\(S,T\)</span>在一个点双中呢?其实只需要添加一条边<span class="math inline">\((S,T,dis_{S\rightarrow
T})\)</span>就行了.显然加了后不会对答案产生影响.然后不在<span class="math inline">\(S,T\)</span>这个边双内的点也没有用了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://loj.ac/p/3076</p>
<p>这题没啥好说的,小E的集训队论文讲的很清楚.简单来说就是用三度化求出一棵决策树,然后做动态dp.</p>
<h3><span id="动态规划第一期">动态规划第一期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1810G</p>
<p>ps:本题选入笔记:动态规划-动态规划的优化-反向操作-Example1.</p>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个<span class="math inline">\(k\)</span>暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取<span class="math inline">\(\max\)</span>操作很艰难.但如果!我把这个dp反过来,我设<span class="math inline">\(f_{i,j}\)</span>表示<strong>从后往前</strong>dp到<span class="math inline">\(i\)</span>,当前的最大前缀和是多少,这个dp的转移极其简单:
<span class="math display">\[
P\times f_{i,j}\rightarrow f_{i-1,\max\{0,j+a_{i-1}\}}
\]</span> 最后在<span class="math inline">\(f_{1,j}\)</span>处乘上<span class="math inline">\(h_j\)</span>.</p>
<p>但是这样是<span class="math inline">\(O(n^3)\)</span>的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设<span class="math inline">\(g_{i,j}\)</span>表示如果初始只有<span class="math inline">\(f_{i,j}=1\)</span>,dp到最后的答案是多少.于是只需要:
<span class="math display">\[
P\times g_{i-1,\max\{0,j+a_{i-1}\}}\rightarrow g_{i,j}\\
\]</span> 我认真考虑过这个<span class="math inline">\(P\)</span>应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些<span class="math inline">\(P\)</span>变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<p>回来简单提下容斥做法,其实是有一个自然的想法是只要这个序列中出现过前缀和为<span class="math inline">\(x\)</span>的位置,我们就加上一个<span class="math inline">\(h_x-h_{x-1}\)</span>.然后我们要统计的是出现过的,因此用容斥把这个条件删了就行.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc061_c</p>
<p>这题纯容斥,首先考虑找到一种统计答案序列而非操作序列的方式:一般而言会选择建立某种双射.考虑一个答案序列可以怎么被操作到:或者说,对于一个答案序列,判断它能否操作到.</p>
<p>注意到序列中第一个元素,肯定是选择左端点比较合理.因为这样它对后面的限制要少一些.那么其实双射方式就呼之欲出了:就是从左往右扫,能取左端点就取左端点.我们就可以对这个操作序列进行计数.</p>
<p>这个操作序列怎么计数呢?考虑这个序列满足啥条件:其实就是能选左边的就不会选右边的,那也就是不可能出现一个空的区间,这个区间没有任何数字.对着这个条件容斥即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc134_e</p>
<p>这题见过两次了.大概是按部就班一点一点去找条件.</p>
<p>至于考试怎么办,考试打表啊!</p>
<p>下面抄一下演算纸上的结论,注意这些判定条件的优先级从前往后:</p>
<ol type="1">
<li>如果序列全<span class="math inline">\(1\)</span>,显然后手获胜.</li>
<li>如果序列不是全<span class="math inline">\(1\)</span>并且存在奇数,选择<span class="math inline">\(m=2\)</span>,先手获胜.</li>
<li>如果序列全<span class="math inline">\(2\)</span>,显然后手获胜.</li>
<li>如果序列全是偶数并且不全是<span class="math inline">\(4\)</span>的倍数,取<span class="math inline">\(m=4\)</span>转化为(3),先手获胜.</li>
<li>如果序列全是<span class="math inline">\(4\)</span>的倍数,考虑取<span class="math inline">\(m=3\)</span>,如果序列中只有<span class="math inline">\(\bmod 3=1\)</span>或者只有<span class="math inline">\(\bmod
3=2\)</span>的数字,显然先手获胜.不然,如果同时存在,考虑先手取<span class="math inline">\(m=12\)</span>,序列中就会只剩下<span class="math inline">\(\{4,8\}\)</span>.此时如果后手取一个奇数,显然会剩下奇数,根据(2)先手获胜;如果后手取一个偶数,讨论一下全部的偶数,都是先手获胜.</li>
</ol>
<p>综上,除非所有的数字都是<span class="math inline">\(12\)</span>的倍数,不然后手获胜当且仅当序列是<span class="math inline">\(\{1\},\{2\},\{4,8\}\)</span>.</p>
<p>如果所有的数字都是<span class="math inline">\(12\)</span>的倍数,最多只有<span class="math inline">\(16\)</span>个,状压即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_abc290_h</p>
<p>显然对于猫来说,它的<span class="math inline">\(d\)</span>(定义为左右狗的数量之差,对于狗同理)是一个从左到右先减少再增加的东西.因此一个<span class="math inline">\(O(n^4)\)</span>的dp是简单设计的,也就是<span class="math inline">\(f_{i,j,k,l}\)</span>表示目前用了<span class="math inline">\(i\)</span>只猫,有<span class="math inline">\(j\)</span>只放在前面,<span class="math inline">\(i-j\)</span>只放在后面,狗同理.</p>
<p>这个怎么优化呢?我们仔细思考,如果要放,是不是最好放的平均一点.因此引出一个结论:那就是一定存在一个分界点,使得左右猫的数量相同,狗的数量也相同.你可能会好奇<span class="math inline">\(n,m\)</span>都是奇数怎么办,这种情况下会把中间的两个点当作分界点.如果<span class="math inline">\(n+m\)</span>是奇数就找中间的那个点,不然就找中间的那个空格.</p>
<p>这个是怎么证明的呢?我们考虑对于猫来说,先找到能平分猫的分界点.然后考虑这个点左右两侧的狗的数量是否相同(这里先假设狗的数量是偶数,奇数是同理的,只是要多说几步).我们选择狗多的那一边,把这边最靠近分界线的那只狗恰好移过分界线.注意到这样一定更优秀.</p>
<p>那么上面的结论证明了啥呢?证明了整个序列一定可以分成两部分(左右两部分).这有什么用?这去掉了前两维.具体来讲,对于一部分,如果可以填某只猫或某只狗二者之一,一定选择权值较小的先填,这样的话这一对的贡献就会少一些.其实就是把权值转化为每个序列中每一对的贡献.于是这个结论就是对的,我们可以把猫狗放在一起排序来处理第一维.复杂度<span class="math inline">\(O(n^3)\)</span>.</p>
<p>测完样例发现一个问题啊,上面那个结论还真不能简单地拓展到奇数.因为会出现权值相等的情况.对于偶数来讲,权值相等是无所谓的.但是奇数不行.因此我们选择如果<span class="math inline">\(n\)</span>是奇数,就挑出最大的那只强行放在中间,<span class="math inline">\(m\)</span>同理.</p>
<p>但是,这题被爆标了.存在<span class="math inline">\(O(n\log
n)\)</span>的做法:</p>
<p>注意到,<span class="math inline">\(\sum
d\)</span>总是一样的.因为这个猫前面的狗会因为它而贡献<span class="math inline">\(1\)</span>,然后这个猫和后面的狗也会贡献<span class="math inline">\(1\)</span>.于是考虑从大到小开始放,优先放中间.然后先把狗堆一边,猫堆另一边,堆不动了再放对边,这样就是满足让<span class="math inline">\(a\)</span>较大的<span class="math inline">\(d\)</span>较小.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9338</p>
<p>首先能划分就一定需要是一个合法括号序列.同时这意味着一定可以划分出<span class="math inline">\(N\)</span>个合法的序列.</p>
<p>也就是说,我们其实只在乎这个序列最少能划分出多少,并且判断这个数字是否小于等于<span class="math inline">\(K\)</span>.那么如何求这个数字呢?</p>
<p>考虑第一个<span class="math inline">\(B\)</span>,它一定会和它左边的某个<span class="math inline">\(A\)</span>配对,不妨设它左边有<span class="math inline">\(i\)</span>个<span class="math inline">\(A\)</span>,那么最好的办法显然是这<span class="math inline">\(i\)</span>个<span class="math inline">\(A\)</span>和后面紧接着的<span class="math inline">\(i\)</span>个<span class="math inline">\(B\)</span>合并成一个序列.这是为什么呢?因为第一个<span class="math inline">\(B\)</span>需要配对,因此它需要在一个序列中,把它删掉后后面的一个<span class="math inline">\(B\)</span>也需要配对,而此时它前面的<span class="math inline">\(A\)</span>其实都是等价的,于是选择最早的那个,以此类推.</p>
<p>然后题解开始变魔术了.设<span class="math inline">\(f[x]\)</span>表示第<span class="math inline">\(x\)</span>个<span class="math inline">\(B\)</span>前有多少个<span class="math inline">\(A\)</span>,那我们做的实际上就是<span class="math inline">\(x=1\)</span>,然后不断做<span class="math inline">\(x:=f[x]+1\)</span>直到<span class="math inline">\(x&gt;n\)</span>.发现这样其实顺便把合法括号序列那个条件一起满足了,因为如果不合法一定会跳跳跳跳跳然后死循环.</p>
<p>那么我们的交换操作实际上是啥呢?首先不可能交换两个相同的,那实际上就是给一个<span class="math inline">\(f\pm 1\)</span>,实际上显然不可能给一个<span class="math inline">\(f\)</span>减一.</p>
<p>但是这样会出现一个问题是,我们其实并不能选择任意一个<span class="math inline">\(f\)</span>进行更改.那怎么办呢?事实上,只要过程中满足<span class="math inline">\(\forall 1&lt;i\leq n,f_i\geq
f_{i-1}\)</span>,那我们的修改就一定可以实现.因为这等价于把后面的一个<span class="math inline">\(A\)</span>挪前面去了.这样我们一开始进行操作使得整个序列满足<span class="math inline">\(f_i\geq i\)</span>.</p>
<p>于是就有了一个<span class="math inline">\(O(n^3)\)</span>的dp,即设<span class="math inline">\(dp_{i,k}\)</span>表示跳到<span class="math inline">\(i\)</span>跳了<span class="math inline">\(k\)</span>步的最小花费,每次跳到<span class="math inline">\(j\)</span>的话要求把<span class="math inline">\([i,n]\)</span>上的所有<span class="math inline">\(f\)</span>对<span class="math inline">\(j-1\)</span>取<span class="math inline">\(\max\)</span>.</p>
<p>仔细观察上面的过程,不难发现答案关于<span class="math inline">\(k\)</span>是凸的,用wqs二分去掉第二维,于是现在就有了一个<span class="math inline">\(O(n^2\log n)\)</span>的一维dp.</p>
<p>不妨设<span class="math inline">\(sum_x\)</span>表示<span class="math inline">\(f_i\leq x\)</span>的<span class="math inline">\(f_i\)</span>之和,<span class="math inline">\(cnt_x\)</span>表示这样的<span class="math inline">\(f_i\)</span>的个数,再设<span class="math inline">\(pre_i\)</span>为<span class="math inline">\(f\)</span>的前缀和.由于<span class="math inline">\(f_i\geq i\)</span>,不难发现: <span class="math display">\[
dp_i=dp_j+\\(i-1)(cnt_{i-1}-j+1)-sum_{i-1}+pre_{j-1}-val
\]</span> 其中<span class="math inline">\(val\)</span>是wqs二分出来的惩罚量.然后如果能选前面的<span class="math inline">\(i\)</span>尽量选靠前的.再就是dp过程中需要记录跳了几步,但是不作为dp的维度而是内容.</p>
<p>显然可以斜率优化,于是复杂度<span class="math inline">\(O(n\log
n)\)</span>.</p>
<h4><span id="第六题">第六题</span></h4>
<p>考虑Hall定理,设最后的盒子是<span class="math inline">\(x_1,x_2,\cdots
,x_k\)</span>,将它们<strong>从大到小</strong>排序,那么合法当且仅当:</p>
<ol type="1">
<li><span class="math inline">\(\sum x=\sum a\)</span>.</li>
<li><span class="math inline">\(\forall k,\sum_{i=1}^kx_i\leq
\sum_{i=1}^n\min\{k,a_i\}\)</span>.</li>
</ol>
<p>为啥是这个方向的Hall定理呢?因为我们肯定要对<span class="math inline">\(x\)</span>做一个背包的问题,这个时候肯定是对后面那一个已知的操作会比较好.</p>
<p>然后就直接dp.把<span class="math inline">\(b\)</span>从大到小排序,<span class="math inline">\(f_{i,j,k}\)</span>表示当前考虑前<span class="math inline">\(i\)</span>个<span class="math inline">\(b\)</span>,选了<span class="math inline">\(j\)</span>个,和为<span class="math inline">\(k\)</span>是否可行,用bitset优化一下得到<span class="math inline">\(O(\frac{mS^2}{w})\)</span>的算法.</p>
<p>但是实际上,考虑到<span class="math inline">\(m\)</span>其实是<span class="math inline">\(\sqrt S\)</span>级别的,再注意到dp的过程中,<span class="math inline">\(j\leq \frac{S}{b_i}\)</span>,因此<span class="math inline">\(\sum max_j=O(S\log S)\)</span>,所以这个算法是<span class="math inline">\(O(\frac{S^2\log S}{w})\)</span>的.</p>
<p>实现可以使用滚动数组.然后压位的话要压掉最后一维.</p>
<p>dp的话是下面这样的: <span class="math display">\[
dp_{i,j,k}\rightarrow dp_{i+1,j,k}\\
dp_{i,j,k}\rightarrow dp_{i,j+1,k+b_i}
\]</span> 算的时候记得删掉过大的<span class="math inline">\(k\)</span>.</p>
<p>看到这种dp可能第一反应是考虑能不能交换dp状态和dp值,但是这个哪一维状态也不是和状态是单调的.</p>
<p>至于构造方案,暴力用堆一个一个做.</p>
<h3><span id="组合数学">组合数学</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_jsc2019_qual_f</p>
<p>比较牛.首先千万要看清楚不是每个点的值在<span class="math inline">\([L,R]\)</span>之间而是和在<span class="math inline">\([L,R]\)</span>之间!</p>
<p>然后考虑后者怎么做.注意到如果是第<span class="math inline">\(M\)</span>大等于第<span class="math inline">\(M+1\)</span>大的话,中间那一段会是一段连续的,这个特别难搞.所以我们考虑求第<span class="math inline">\(M\)</span>大不等于第<span class="math inline">\(M+1\)</span>大,这样前<span class="math inline">\(M\)</span>个和后<span class="math inline">\(N-M\)</span>个数字其实就分开了.而且因为前后没有相等的数字,我们很容易把它们乱序合并起来.</p>
<p>因此接下来的关键在于把前后分开,假设<span class="math inline">\(a_M=x\)</span>,那么前<span class="math inline">\(M\)</span>个数字大于等于<span class="math inline">\(x\)</span>,后<span class="math inline">\(M\)</span>个数字小于<span class="math inline">\(x\)</span>.不妨假设此时全局和为<span class="math inline">\(s\)</span>,那我们如何解决这个问题呢?</p>
<p>首先较大的那几个可以隔板法做,较小的那几个是个经典容斥:枚举有几个大于等于<span class="math inline">\(x\)</span>的,这个数量不会超过<span class="math inline">\(\frac{R}{x}\)</span>,然后剩下的暴力隔板.</p>
<p>写式子之前考虑上面那个<span class="math inline">\(s\)</span>怎么办,总不能暴力枚举,其实写出来也可以用二项式技巧去掉,但是更重要的是,为啥你不转化成和在<span class="math inline">\([0,R]\)</span>的答案减去和在<span class="math inline">\([0,L-1]\)</span>的答案呢?这下做完了.</p>
<p>于是我们只考虑限制是<span class="math inline">\([0,R]\)</span>.</p>
<p>这个时候我还在想要把左右两边分开求答案然后卷起来,但是这样还是避免不了枚举一边的和.事实上,我们可以把二者放在一起做容斥.下面式子会给出一个显式的表达.另外就是,有一个很大的问题在于我们如何钦定<span class="math inline">\(a_M=x\)</span>,这一点其实是难以做到的.但我们可以钦定<span class="math inline">\(a_M\geq x,a_{M+1}&lt;x\)</span>,然后再减去<span class="math inline">\(a_M\geq
x+1,a_{M+1}&lt;x\)</span>.为了方便,我们不妨设<span class="math inline">\(a_M\geq x,a_{M+1}\leq y\)</span>的答案是<span class="math inline">\(f(x,y)\)</span>,然后我们要求的就是<span class="math inline">\(\sum_{x}f(x,x-1)-f(x+1,x-1)\)</span>.</p>
<p>接下来写一下<span class="math inline">\(f(x,y)\)</span>的式子: <span class="math display">\[
f(x,y)=\sum_{i=0}\binom{N-M}{i}(-1)^i\binom{R-Mx-i(y+1)+N}{N}
\]</span> 乍一看不太能算,实际上注意到<span class="math inline">\(R-Mx-i(y+1)\geq 0\)</span>,由于<span class="math inline">\(x,y\)</span>同级别,这意味着<span class="math inline">\(i\)</span>大致是<span class="math inline">\(\frac{R}{x}\)</span>级别的.于是就是一个调和级数复杂度.</p>
<h4><span id="第二题第三题">第二题/第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1264D2</p>
<p>直接做的hard version.</p>
<p>首先我们发现,不妨我们最后取出来的串一定是个<span class="math inline">\((((\cdots)))\)</span>这样的结构.再进一步,我们找到这个结构在原串上的分界点,设其左侧有<span class="math inline">\(s_l\)</span>个<span class="math inline">\((\)</span>,右侧有<span class="math inline">\(s_r\)</span>个<span class="math inline">\()\)</span>,那么这个串的长度一定形如<span class="math inline">\(\min\{s_l,s_r\}\)</span>,由于随着分界点的右移,<span class="math inline">\(s_l\)</span>增大,<span class="math inline">\(s_r\)</span>减小,因此一定是它俩相等的时候最优秀.</p>
<p>于是我们考虑枚举分界点,对于每个分界点枚举答案.不妨设左侧有<span class="math inline">\(a_l\)</span>个问号,总共有<span class="math inline">\(a\)</span>个问问号,答案显然是: <span class="math display">\[
\sum_{k}k\binom{a_l}{k-s_l}\binom{a-a_l}{k-s_r}\\
=\sum_{k}(k-s_l)\binom{a_l}{k-s_l}\binom{a-a_l}{k-s_r}+\sum_{k}s_l\binom{a_l}{k-s_l}\binom{a-a_l}{k-s_r}\\
=a_l\sum_{k}\binom{a_l-1}{k-s_l-1}\binom{a-a_l}{k-s_r}+s_l\sum_{k}\binom{a_l}{k-s_l}\binom{a-a_l}{k-s_r}\\
=a_l\sum_{k}\binom{a_l-1}{a_l-k+s_l}\binom{a-a_l}{k-s_r}+s_l\sum_{k}\binom{a_l}{a_l-k+s_l}\binom{a-a_l}{k-s_r}\\
=a_l\binom{a-1}{a_l+s_l-s_r}+s_l\binom{a}{a_l+s_l-s_r}
\]</span> 不过这里有个问题啊,那就是<span class="math inline">\(a=0\)</span>怎么办,扩域的二项式我其实是不太会算的.于是我特判了<span class="math inline">\(a=0\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc146_e</p>
<p>由于相同值域相互间有限制,不妨考虑值域那一维扫一下.</p>
<p>进一步地,我们考虑维护若干个上升的直线,然后每次可以选择把两条直线并起来成为一个峰,或者凭空分裂出两条直线作为一个谷.维护直线数量并且从下往上扫就可以了.</p>
<p>但是你注意一个问题,我们是不能先分裂出两条直线,再把它俩合并起来的.考虑能不能设计一点自适应的东西.当前的直线数量一定是偶数,然后我们每隔一个判断是否要合并,或者直接在一半的空位置上判断是否要分裂就行.更具体地,我们设<span class="math inline">\(f_{i,j}\)</span>表示当前有<span class="math inline">\(j\)</span>个位置能放<span class="math inline">\(i\)</span>的答案.显然<span class="math inline">\(j=b_i\)</span>,所以这一维看上去是没用的.</p>
<p>但是我们仔细想一想,我们要维护若干条折线.这些折线是有左右端点的,我们需要做的就是要么加入一条折线,要么合并两条折线,这两个操作都会带来一个空位置.而一条不操作的折线会带来两个空位置.其实相当于每个操作减少了一个空位置.不过有一个问题啊,我们只能通过<span class="math inline">\(b_i\)</span>得知有多少个空位置,却不知道有多少条折线.事实上空位置数量=折线端点数量+操作次数.也就是说,和dp关系比较大的是折线数量,但我们只能推测出空位置数量.这下这下了.</p>
<p>但是但是但是,我们写一个<span class="math inline">\(O(n^2)\)</span>的dp,<span class="math inline">\(f_{i,j,0/1,0/1}\)</span>表示当前做到<span class="math inline">\(i\)</span>,有<span class="math inline">\(j\)</span>条折线,左端点是否已经选定,右端点是否已经选定.为啥要记录后两维呢?因为这不是环,这是一个排列,最左侧端点和最右侧端点是有可能直接停步的.因此我们还得讨论这个.说实话有点麻烦,所以我们先忽略左右端点,假设它们一直延伸.不妨设<span class="math inline">\(k=cnt_{merge}-cnt_{split}\)</span>,自然有<span class="math inline">\(k=2j-b_i\)</span>.不放在设<span class="math inline">\(w=cnt_{split},cnt_{merge}=k+w\)</span>,再设<span class="math inline">\(F(n,m)\)</span>为将<span class="math inline">\(n\)</span>个无编号球放到<span class="math inline">\(m\)</span>个有编号盒子(盒子可空)的方案数,不难发现<span class="math inline">\(F(n,m)=\binom{n+m-1}{m-1}\)</span>.那我们有: <span class="math display">\[
f_{i-1,j}\sum_{w\geq 0}\binom{j-1}{k+w}F(w,j-w-k+1)\rightarrow
f_{i,j-k}\\
f_{i-1,j}\sum_{w}\binom{j-1}{k+w}\binom{j-k}{j-w-k}\rightarrow
f_{i,j-k}\\
f_{i-1,j}\binom{2j-k-1}{j}\rightarrow f_{i,j-k}\\
\]</span>
用范德蒙德卷积的时候一定要注意,这个东西是扩域后的二项式,因此一定要在意一下枚举量是否取遍整数,这里是发现如果<span class="math inline">\(w&lt;0\)</span>,那么后面那个组合数一定是<span class="math inline">\(0\)</span>.</p>
<p>原本其实很怕这个转移,因为觉得很麻烦,但其实写出来就不麻烦了.甚至加两维也是好做的,我们不妨设后两维的和为<span class="math inline">\(t\)</span>,就是几个端点是挂的,我们仍然有: <span class="math display">\[
b_i=2(j-k)+cnt_{merge}-cnt_{split}-t+\Delta t\\
k=2j-t+\Delta t-b_i
\]</span> 其中<span class="math inline">\(\Delta
t\)</span>是决定在这里停步的端点数量,<span class="math inline">\(t\)</span>是停步后的端点数量,<span class="math inline">\(j-k\)</span>是做完选择后,在<span class="math inline">\(i\)</span>处的折线数量,两个<span class="math inline">\(cnt\)</span>都是在做选择的<strong>过程中</strong>所做的merge和split的抉择数量.这样我们就完成了转移.</p>
<p>没完没完,差点就寄了.如果左右端点没有确认,那么我们是可以在左边或者右边split的.令<span class="math inline">\(t&#39;=t-\Delta t\)</span>,于是重推一下式子: <span class="math display">\[
f_{i-1,j}\sum_{w\geq 0}\binom{j-1}{k+w}F(w,j-w-k+1-t&#39;)\rightarrow
f_{i,j-k}\\
f_{i-1,j}\sum_{w}\binom{j-1}{k+w}\binom{j-k-t&#39;}{j-w-k-t&#39;}\rightarrow
f_{i,j-k}\\
f_{i-1,j}\binom{2j-k-1-t&#39;}{j-t&#39;}\rightarrow f_{i,j-k}\\
f_{i-1,j}\binom{b_i-1}{j-t&#39;}\rightarrow f_{i,j-k}\\
\]</span>
这一步步是怎么加上去的呢?实际上是按照先merge,再slipt,再stop来做的.因为split一定要放在最后,防止split了一个stop的点或者split在了一个merge好了的区间中.</p>
<p>但是这个转移是<span class="math inline">\(O(n\sum
b)\)</span>的,咋办呢?我们本着先冷静再冷静始终冷静的想法,去考虑一下<span class="math inline">\(j\)</span>的取值:不难发现在上面的操作过程中,基本都是一个<span class="math inline">\(j\)</span>对应一个<span class="math inline">\(j-k\)</span>,只有在<span class="math inline">\(t\)</span>变化的时候才会增加一个状态,这意味着<span class="math inline">\(O(\sum cnt_t)=O(\sum
cnt_j)\)</span>,因此总空间是<span class="math inline">\(O(n)\)</span>的,于是时间也是<span class="math inline">\(O(n)\)</span>的,拿map维护一下这个dp就行,时间退化至<span class="math inline">\(O(n\log n)\)</span>.</p>
<p>再有一个细节就是组合数怎么办,哦,<span class="math inline">\(b\)</span>这么小,那没事了.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P6276</p>
<p>首先显然不会破坏环的形态.也就是说,你把所有置换环的长度求出来然后求lcm就是一个排列的阶.这直接启发我们对于每个质数分开求贡献.</p>
<p>更进一步地,我们发现只要排列中有<span class="math inline">\(p^k\)</span>的倍数,我们就直接贡献一个<span class="math inline">\(p\)</span>作为答案.因此我们枚举<span class="math inline">\(q=p^k\)</span>并统计有多少个排列至少有长度为<span class="math inline">\(q\)</span>的倍数的环.这都至少了,直接容斥就行,我们设当前有<span class="math inline">\(i\)</span>个点,自然有: <span class="math display">\[
f_{i}=\sum_{q|k}-f_{i-k,j-1}\binom{i-1}{k-1}(k-1)!\\
=\sum_{q|k}-{(i-1)}^{\underline{k-1}}f_{i-k,j-1}
\]</span> <span class="math inline">\(\sum_{q|i}-f_i\times (n-i)!\times
\binom{n}{i}\)</span>就是答案.这样复杂度是<span class="math inline">\(O(\sum(\frac{n}{q})^2)=O(n^2)\)</span>,事实上要更少,因为你发现我们只会对某个<span class="math inline">\(q=p^k\)</span>做这个东西.</p>
<p>另外由于模数不确定,我们还要对着每个<span class="math inline">\(i\)</span>预处理下降幂,有点难蚌的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc060_d</p>
<p>ps:本题选入笔记:常见套路-组合意义-Example3.</p>
<p>这题听了三遍,直接抄笔记.</p>
<p>不妨设<span class="math inline">\(C_p=\{i|p_i&gt;p_{i+1},1\leq
i&lt;n\}\)</span>.</p>
<p>用一下组合意义,注意到答案等于: <span class="math display">\[
\sum_{S}(\sum_{p}[S=C_p])^2
\]</span> 中间那个地方看上去是经典的计数容斥,我们对着它做容斥: <span class="math display">\[
\sum_{S}(\sum_{p}[S=C_p])^2=\sum_{S}(\sum_{S\subseteq
T}\sum_{p}(-1)^{|T|-|S|}[T\subseteq C_p])^2
\]</span> 这个咋做呢?我们考虑用组合意义展开: <span class="math display">\[
\sum_{S}(\sum_{S\subseteq T}\sum_{p}(-1)^{|T|-|S|}[T\subseteq
C_p])^2\\=\sum_{S}\sum_{S\subseteq
T_1,T_2}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])
\]</span> 注意到<span class="math inline">\(S\)</span>屁用没有,直接交换枚举顺序. <span class="math display">\[
\sum_{S}\sum_{S\subseteq
T_1,T_2}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])\\=\sum_{T_1,T_2}2^{|T_1\cap
T_2|}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq C_p])(\sum_p[T_2\subseteq
C_p])
\]</span> 考虑<span class="math inline">\((\sum_{p}[T_1\subseteq
C_p])\)</span>怎么求,注意到这等价于所有<span class="math inline">\(T_1\)</span>中的位置全都被钦定为<span class="math inline">\(&gt;\)</span>,而其他位置任意,如果我们设所有以大于号连接的部分的长度为<span class="math inline">\(l_1,l_2,...,l_k\)</span>,那么这里的答案就是<span class="math inline">\(n!\prod_{i=1}^k\frac{1}{l_i!}\)</span>.</p>
<p>但我们很快发现了难点:<span class="math inline">\(2^{|T_1\cap
T_2|}\)</span>这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中都是<span class="math inline">\(&gt;\)</span>的位置,这个好像不太好求,因为<span class="math inline">\(&gt;\)</span>是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:
<span class="math display">\[
\sum_{T_1,T_2}2^{|T_1\cap T_2|}(-1)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])\\
=\sum_{T_1,T_2}2^{((n-1)-|T_1\cup
T_2|)-(n-1)}(-2)^{|T_1|+|T_2|}(\sum_{p}[T_1\subseteq
C_p])(\sum_p[T_2\subseteq C_p])\\
=2^{1-n}(n!)^2\sum_{T_1}((-2)^{|T_1|}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}((-2)^{|T_2|}\frac{1}{\prod
l_{2,i}!})2^{n-1-|T_1\cup T_2|}
\]</span> 其中<span class="math inline">\(n-1-|T_1\cup
T_2|\)</span>意味着均不在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中的位置的数量.为了给每一段连续的<span class="math inline">\(&gt;\)</span>都分配权值,我们进行一个细小的修改:
<span class="math display">\[
2^{-1-n}(n!)^2\sum_{T_1}((-2)^{|T_1|+1}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}((-2)^{|T_2|+1}\frac{1}{\prod
l_{2,i}!})2^{n-1-|T_1\cup T_2|}
\]</span> 写到这里应该就能发现,接下来必然要对<span class="math inline">\(n-1-|T_1\cup
T_2|\)</span>做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了<span class="math inline">\(&gt;\)</span>,我们自然有: <span class="math display">\[
2^{1+n}(n!)^2\sum_{T_1}(\frac{1}{(-2)^{|T_1|+1}}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}(\frac{1}{(-2)^{|T_2|+1}}\frac{1}{\prod
l_{2,i}!})2^{|T_1\cap T_2|}\\
\]</span> 这里已经很显然了,我们大概要做一个不断加段的做法,那此时<span class="math inline">\(|T_1\cap
T_2|\)</span>这个限制就显得尤其强,如果只是<span class="math inline">\(S\subseteq
T_1,T_2\)</span>就会好做很多:我们可以钦定<span class="math inline">\(S\)</span>作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:
<span class="math display">\[
2^{1+n}(n!)^2\sum_{T_1}(\frac{1}{(-2)^{|T_1|+1}}\frac{1}{\prod
l_{1,i}!})\sum_{T_2}(\frac{1}{(-2)^{|T_2|+1}}\frac{1}{\prod
l_{2,i}!})2^{|T_1\cap T_2|}\\
=2^{1+n}(n!)^2\sum_{S}\sum_{S\subseteq
T_1}(\frac{1}{(-2)^{|T_1|+1}}\frac{1}{\prod l_{1,i}!})\sum_{S\subseteq
T_2}(\frac{1}{(-2)^{|T_2|+1}}\frac{1}{\prod l_{2,i}!})\\
\]</span> 令<span class="math inline">\(f(T)=\sum_{S\subseteq
T}(\frac{1}{(-2)^{|T|+1}}\frac{1}{\prod l_{2,i}!})\\\)</span>,则原式即:
<span class="math display">\[
2^{1+n}(n!)^2\sum_{S}(\sum_{S\subseteq T}f(T))^2
\]</span> 考虑下面这个东西怎么求: <span class="math display">\[
\sum_{S}(\sum_{S\subseteq T}f(T))^2
\]</span> 注意到,如果我们把每一段(<span class="math inline">\([T_i,T_{i+1})\)</span>)的贡献求和,那么<span class="math inline">\(f(T)\)</span>相当于这些和乘起来,那么<span class="math inline">\((\sum_{S\subseteq
T}f(T))^2\)</span>就是这些和的平方乘起来.换句话说,我们自然有<span class="math inline">\(ans_n=\sum_{m}ans_{n-m}g^2_{m}\)</span>,其中<span class="math inline">\(g_m\)</span>表示长度为<span class="math inline">\(m\)</span>的一段的贡献之和.而<span class="math inline">\(g_{n}=\sum_m
g_{n-m}\frac{1}{-2m!}\)</span>.二者都可以使用分治FFT或多项式求逆解决.更进一步地,<span class="math inline">\(h_i=\frac{1}{-2i!},G=\frac{1}{1-H},F=\frac{1}{1-G}\)</span>.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将<span class="math inline">\((&gt;,&gt;)\)</span>容斥掉,这样我们有若干种对:<span class="math inline">\(2(&lt;,&lt;),1(e,e),-(e,&lt;),-(&lt;,e)\)</span>,然后我们发现两个序列联系得太紧了,我们考虑分配系数:<span class="math inline">\(&lt;\rightarrow \sqrt 2\)</span>,<span class="math inline">\(e\rightarrow -\frac{1}{\sqrt
2}\)</span>,但是这样发现<span class="math inline">\((e,e)\)</span>算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1188E</p>
<p>首先发现肯定不可能所有颜色都点过,那么至少有一个颜色没点过.</p>
<p>然后呢?考虑操作序列和答案序列是否一一对应,事实上确实是这样,因为至少有一个颜色没点过,因此可以找到下降最多的那个颜色,这样就知道了总共操作过程.然后由每个颜色减少的次数,就可以知道每种颜色操作的次数.接下来就只需要对于每种操作次数判断是否能在全程非负的前提下做完.</p>
<p>一个显然的必要条件是,不妨设<span class="math inline">\(l_i\)</span>为第<span class="math inline">\(i\)</span>种颜色操作次数,<span class="math inline">\(a_i+l_ik\geq \sum
l\)</span>.但是操作过程中有可能有负数,这个怎么办呢?注意到为了让<span class="math inline">\(a\)</span>不变负数,我们必须要让它在<span class="math inline">\(a_i+1\)</span>时刻前完成至少一次操作,在<span class="math inline">\(a_i+k+1\)</span>时刻前完成至少两次操作……</p>
<p>注意到只需要满足第一个条件就行,因为后面的条件只需要把当前所有需要做的人排个序,挨个做.显然就一定会满足条件.根据Hall定理,从前往后判断每一时刻是不是能填满前面的每个人,并将它和<span class="math inline">\(\max a\)</span>取<span class="math inline">\(\min\)</span>得到<span class="math inline">\(maxt\)</span>,这就是<span class="math inline">\(\sum l\)</span>的最大值.不难发现只要<span class="math inline">\(\sum l\leq maxt\)</span>就一定有解.枚举<span class="math inline">\(t\)</span>计算每个<span class="math inline">\(a\)</span>需要的次数,剩下的次数随意分配,注意要保证<span class="math inline">\(\min l=0\)</span>,要减去<span class="math inline">\(\min l\geq 1\)</span>的情况.</p>
<p>事实上啊,只要我们得知了前一个要求条件然后枚举<span class="math inline">\(t\)</span>就行,时刻维护着复杂度就对,根本不用管后面的东西.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1595</p>
<p>弱智题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://darkbzoj.cc/problem/4665</p>
<p>直接容斥,用dp出前<span class="math inline">\(i\)</span>个人,钦定<span class="math inline">\(j\)</span>个人拿到了自己的糖果的方案数.然后容斥起来就行.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4859</p>
<p>ps:本题选入笔记:容斥与反演-容斥-Example3.</p>
<p>首先可以用dp+双指针得到<span class="math inline">\(f_i\)</span>表示勒令<span class="math inline">\(i\)</span>对满足条件的方案数.把<span class="math inline">\(k\)</span>的定义改为恰好<span class="math inline">\(k\)</span>对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好<span class="math inline">\(a\)</span>对的方案会被恰好<span class="math inline">\(b\)</span>对的方案计算<span class="math inline">\(\binom{b}{a}\)</span>次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为<span class="math inline">\(k\)</span>的方案贡献为<span class="math inline">\(1\)</span>,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为<span class="math inline">\(k+1\)</span>的方案贡献为<span class="math inline">\(0\)</span>,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令<span class="math inline">\(ans=f_k\)</span>,第二步除去其中被多算的<span class="math inline">\(k+1\)</span>,这一步令<span class="math inline">\(ans-=\binom{k+1}{k}f_{k+1}\)</span>.这个时候,我们再考虑<span class="math inline">\(k+2\)</span>的贡献:它将在<span class="math inline">\(f_k\)</span>时贡献<span class="math inline">\(\binom{k+2}k\)</span>次,在<span class="math inline">\(f_{k+1}\)</span>时贡献<span class="math inline">\(-\binom{k+2}{k+1}\binom{k+1}{k}=-\binom{k+2}{k}\binom{2}{1}\)</span>次,那它现在的贡献还有:<span class="math inline">\(-\binom{k+2}k\)</span>次.以此类推,可以得到<span class="math inline">\(ans=\sum_{i=k}^nf_i(-1)^{i-k}\binom{i}{k}\)</span>.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个<span class="math inline">\(P_i\)</span>.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画<span class="math inline">\(P_i\)</span>,因为只有这个时候,我们才能通过分析满不满足<span class="math inline">\(P_i\)</span>的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成<span class="math inline">\(1/0\)</span>就行.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://darkbzoj.cc/problem/2839</p>
<p>简单二项式反演.(埋下伏笔)</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://codeforces.com/gym/101933/problem/K</p>
<p>考虑如果用小于等于<span class="math inline">\(k\)</span>种是好计算的(设为<span class="math inline">\(f_k\)</span>),显然<span class="math inline">\(f_k=k(k-1)^{n-1}\)</span>,对着做二项式反演.</p>
<p>一开始想直接拿<span class="math inline">\(f_k-f_{k-1}\)</span>,实际上不行,因为颜色之间是有区别的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6478</p>
<p>这个题面真你妈逆天.</p>
<p>发现我们要求恰好<span class="math inline">\(k\)</span>个,自然的想法是想到钦定<span class="math inline">\(k\)</span>个,不妨假设钦定<span class="math inline">\(k\)</span>个的答案是<span class="math inline">\(f_k\)</span>,自然有: <span class="math display">\[
f_k=\sum_{i=k}^n\binom{i}{k}ans_i\\
ans_k=\sum_{i=k}^n\binom{i}{k}(-1)^{i-k}f_i
\]</span> 至于<span class="math inline">\(f\)</span>怎么求,你直接dp,设<span class="math inline">\(dp_{i,j}\)</span>表示当前在<span class="math inline">\(i\)</span>,子树内部选了<span class="math inline">\(j\)</span>对祖先后代,那我们就知道目前子树内还有多少可以和<span class="math inline">\(i\)</span>配对.合并是个树形背包.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1228E</p>
<p>ps:本题选入笔记:容斥与反演-反演-二项式反演-Example3.</p>
<p>不妨设至多有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(f_{i,j}\)</span>,恰好有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(g_{i,j}\)</span>,注意到: <span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}
\]</span> 令<span class="math inline">\(h_{n,m}=\sum_{j=0}^m\binom{m}{j}g_{n,j}\\\)</span>,则<span class="math inline">\(f_{n,m}=\sum_{i=0}^n\binom{n}{i}h_{i,m}\\\)</span>,而<span class="math inline">\(f_{n,m}=k^{nm}(k-1)^{NM-nm}\)</span>.做两次二项式反演得到<span class="math inline">\(g\)</span>.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥<span class="math inline">\(f_{n,m}\ne
\binom{N}{n}\binom{M}{m}k^{nm}(k-1)^{NM-nm}\)</span>呢?我们写成子集反演形式看看:
<span class="math display">\[
f_{S,T}=\sum_{s\subseteq S}\sum_{t\subseteq T}g_{s,t}\\
f_{S,T}=\sum_{s\subseteq S}h_{s,T}\\
h_{S,T}=\sum_{t\subseteq T}g_{S,t}\\
\]</span> 做子集反演: <span class="math display">\[
f_{S,T}=k^{|S|\times |T|}(k-1)^{NM-|S||T|}\\
h_{S,T}=\sum_{s\subseteq S}(-1)^{|s|-|S|}f_{s,T}\\
g_{S,T}=\sum_{t\subseteq T}(-1)^{|t|-|T|}h_{S,t}
\]</span> 把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,<span class="math inline">\(g_{n,m}\)</span>本身就包含了所有<span class="math inline">\(|S|=n,|T|=m\)</span>的情况的和,并且在组合数<span class="math inline">\(\binom{m}{j}\)</span>那里就找到了唯一确定的<span class="math inline">\(f_{s,t}\)</span>,因此<span class="math inline">\(f_{n,m}\)</span>是唯一确定的.这意味着这里<span class="math inline">\(f\)</span>的<span class="math inline">\(n,m\)</span>并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:
<span class="math display">\[
f_i=2^{2^{n-i}}\binom{n}{i}\\
f_k=\sum_{i=k}^n\binom{i}{k}g_i\\
g_k=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}f_i
\]</span>
冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:
<span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}
\]</span> 这个问题其实非常显然,我们的<span class="math inline">\(g_{i,j}\)</span>定义为所有<span class="math inline">\(|S|=i,|T|=j\)</span>的答案之和.<span class="math inline">\(f\)</span>也是这么定义的,那这个式子就是错的,应该写成:
<span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{N-i}{n-i}\sum_{j=0}^m\binom{M-j}{m-j}g_{i,j}
\]</span>
这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求<span class="math inline">\(g_{N,M}\)</span>,那此时<span class="math inline">\(g\)</span>怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子: <span class="math display">\[
f_k=\sum_{i=k}^n\binom{i}{k}g_i\\
\]</span> 这个定义式就非常良性,<span class="math inline">\(g\)</span>是已知的集合,<span class="math inline">\(f\)</span>是未知的集合.我们乘上组合数就可以得到对于<span class="math inline">\(f\)</span>来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把<span class="math inline">\(f\)</span>的定义改成<span class="math inline">\(f_{n,m}=k^{nm}(k-1)^{NM-nm}\)</span>就对了呢?</p>
<p>再看看这个式子: <span class="math display">\[
f_{n,m}=\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}
\]</span> 这个式子的右边在干这样一件事:那就是在已知<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的集合的前提下,从中选出<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列并求<span class="math inline">\(g\)</span>.那么你从哪知道的<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列呢?你得组合数啊!</p>
<p>所以,实际上的<span class="math inline">\(f\)</span>是这样的: <span class="math display">\[
f_{n,m}=\binom{N}{n}\binom{M}{m}\sum_{i=0}^n\binom{n}{i}\sum_{j=0}^m\binom{m}{j}g_{i,j}\\
f_{n,m}= \binom{N}{n}\binom{M}{m}k^{nm}(k-1)^{NM-nm}
\]</span> 好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式: <span class="math display">\[
f(n)=\sum_{k=n}^NC_n^kg(k)\Leftrightarrow
g(n)=\sum_{k=n}^N(-1)^{k-n}C_n^kf(k)\\
\]</span>
不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设<span class="math inline">\(f&#39;_{i,j}\)</span>为至少有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列不满足条件的方案数,自然有<span class="math inline">\(f&#39;_{i,j}=f_{N-i,M-j}\)</span>.你发现此时一定有:
<span class="math display">\[
f&#39;_{n,m}=\sum_{i=n}^N\binom{i}{n}\sum_{j=m}^M\binom{j}{m}g&#39;_{i,j}
\]</span> 最后答案就是<span class="math inline">\(g&#39;_{0,0}\)</span>.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF997C</p>
<p>和上一题差不多,不妨设<span class="math inline">\(g_{n,m}\)</span>表示恰好有<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列同色的答案,<span class="math inline">\(f_{i,j}\)</span>为钦定<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列同色的答案,自然有: <span class="math display">\[
g_{n,m}=\sum_{i=n}^N(-1)^{i-n}\binom{N}{i}\binom{i}{n}\sum_{j=m}^N(-1)^{j-m}\binom{N}{j}\binom{j}{m}f_{i,j}
\]</span> 可以求出<span class="math inline">\(g_{0,0}\)</span>然后再拿全集减一下.</p>
<p>我们求一下<span class="math inline">\(g_{0,0}\)</span>: <span class="math display">\[
g_{0,0}=\sum_{i=0}^N(-1)^{i}\binom{N}{i}\sum_{j=0}^N(-1)^{j}\binom{N}{j}f_{i,j}
\]</span> 注意到<span class="math inline">\([i=0\or
j=0]\)</span>的时候算的挺特殊的,因此先把那些算掉,我们就只需要算下面这个东西:
<span class="math display">\[
3\sum_{i=1}^N(-1)^{i}\binom{N}{i}\sum_{j=1}^N(-1)^{j}\binom{N}{j}3^{(N-i)(N-j)}
\]</span> 看后面那一块: <span class="math display">\[
\sum_{j=1}^N(-1)^{j}\binom{N}{j}{(3^{(N-i)})}^{(N-j)}\\
=(-1)^{[N\ne 0\pmod
2]}\sum_{j=1}^N(-1)^{N-j}\binom{N}{N-j}{(3^{(N-i)})}^{(N-j)}
\]</span> 再看后面那一块: <span class="math display">\[
\sum_{j=1}^N(-1)^{N-j}\binom{N}{N-j}{(3^{(N-i)})}^{(N-j)}\\
=\sum_{j=0}^{N-1}(-1)^j\binom{N}{j}{(3^{N-i})}^{j}\\
=\sum_{j=0}^{N}(-1)^j\binom{N}{j}{(3^{N-i})}^{j}-(-1)^N{(3^{N-i})}^N\\
=(1-3^{N-i})^N-(-1)^N{(3^{N-i})}^N
\]</span> 这样就做完了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4491</p>
<p>直接二项式反演: <span class="math display">\[
f_k=\sum_{i=k}^{m}(-1)^{i-k}\binom{m}{i}\binom{i}{k}\binom{n}{iS}\frac{(iS)!}{(S!)^i}(m-i)^{n-iS}\\
=\sum_{i=k}^{m}(-1)^{i-k}\frac{m!}{(m-i)!}\frac{1}{k!(i-k)!}\frac{n!}{(n-iS)!}\frac{1}{(S!)^i}(m-i)^{n-iS}
\]</span> 令<span class="math inline">\(tag=m!n!\)</span>,自然有: <span class="math display">\[
\frac{k!f_k}{tag}=\sum_{i=k}^m\frac{(-1)^{i-k}}{(i-k)!}\frac{(m-i)^{n-iS}}{(m-i)!(n-iS)!(S!)^i}
\]</span> 注意到枚举量即<span class="math inline">\(i,k,i-k\)</span>,是一个卷积的形式,更进一步地,我们设<span class="math inline">\(F_k=\frac{k!f_k}{tag},g_{i}=\frac{(-1)^i}{i!},h_i=\frac{(m-i)^{n-iS}}{(m-i)!(n-iS)!(S!)^i}\\\)</span>.自然有:
<span class="math display">\[
F_k=g_{i-k}h_i
\]</span> 再设<span class="math inline">\(g_k=G_{m-k},G_k=g_{m-k}\)</span>,自然有: <span class="math display">\[
F_k=G_{m-i+k}h_i
\]</span> ntt即可.</p>
<h4><span id="第十题第十一题">第十题/第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4931</p>
<p>ps:本题选入笔记:多项式与生成函数-生成函数-求微分方程</p>
<p>二项式反演: <span class="math display">\[
ans_k=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}\binom{n}{i}\binom{n}{i}i!(2n-2i)!2^i\\
=\sum_{i=k}^n(-1)^{i-k}\frac{1}{k!(i-k)!}\frac{n!}{(n-i)!}\frac{n!}{(n-i)!}(2n-2i)!2^i\\
=(n!)^2\frac{2^k}{k!}\sum_{i=k}^n(-1)^{i-k}\frac{1}{(i-k)!}\binom{2n-2i}{n-i}2^{i-k}\\
=(n!)^2\frac{2^k}{k!}\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}
\]</span> 注意到后者只与<span class="math inline">\(n-k\)</span>有关,不妨设其为<span class="math inline">\(f_{n}=\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}\)</span>,预处理一下就可以做到<span class="math inline">\(O(n^2+nT)\)</span>.</p>
<p>加强版咋做?我们继续看看式子: <span class="math display">\[
ans=(n!)^2\frac{2^k}{k!}f_{n-k}\\
f_{n}=\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}
\]</span> 注意到<span class="math inline">\(f\)</span>是一个卷积的形式,设其生成函数为<span class="math inline">\(F_n\)</span>,<span class="math inline">\(g_n=\frac{(-2)^n}{n!},h_n=\binom{2n}{n}\)</span>,我们自然有<span class="math inline">\(F=GH\)</span>.</p>
<p>考虑<span class="math inline">\(G\)</span>和<span class="math inline">\(H\)</span>的生成函数形式,先看<span class="math inline">\(G\)</span>,显然用泰勒展开: <span class="math display">\[
G=\sum_{n\geq 0}\frac{(-2x)^n}{n!}=e^{-2x}
\]</span> 再看<span class="math inline">\(H\)</span>,是一个类似卡特兰数的生成函数,有: <span class="math display">\[
H=\frac{1}{\sqrt{1-4x}}
\]</span> 这下简单了,答案是: <span class="math display">\[
(n!)^2\frac{2^k}{k!}[x^{n-k}]\frac{e^{-2x}}{\sqrt {1-4x}}
\]</span> 现在看<span class="math inline">\(F\)</span>,平方一下有: <span class="math display">\[
(1-4x)F^2=e^{-4x}
\]</span> 两边求导: <span class="math display">\[
-4F^2+(1-4x)2F\times F&#39;=-4e^{-4x}\\
-4F^2+(1-4x)2F\times F&#39;=-4(1-4x)F^2\\
(2-8x)F&#39;=16xF\\
\]</span> 得到了一个线性递推形式,更进一步地: <span class="math display">\[
2(i+1)f_{i+1}-8if_i=16f_{i-1}\\
if_i=4(i-1)f_{i-1}+8f_{i-2}
\]</span>
技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P5339</p>
<p>简单题,不妨设当前这个序列中不同颜色的分别有<span class="math inline">\(a,b,c,d\)</span>个(区别于题面中的<span class="math inline">\(A,B,C,D\)</span>),自然有: <span class="math display">\[
ans=\sum_{k=0}^n(-1)^k\binom{k}{0}\binom{n-3k}{k}\frac{(n-4k)!}{(a-k)!(b-k)!(c-k)!(d-k)!}\\
=\sum_{k=0}^n(-1)^k\binom{n-3k}{k}\frac{(n-4k)!}{(a-k)!(b-k)!(c-k)!(d-k)!}
\]</span> 然后对最后那个东西做背包就行.</p>
<h4><span id="第十三题">第十三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5400</p>
<h3><span id="字符串算法">字符串算法</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P7114</p>
<p>调和级数加哈希,简单题,场切了.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3526</p>
<p>注意到一个事实:如果这个字符串存在长度为<span class="math inline">\(k\)</span>的周期,等价于存在长度为<span class="math inline">\(len-k\)</span>的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设<span class="math inline">\(q\)</span>为最小周期,如果<span class="math inline">\(2q\leq n\)</span>,也就是原串能写成<span class="math inline">\(tt\cdots t&#39;\)</span>的形式.我们不妨先求<span class="math inline">\(tt&#39;\)</span>对应的答案,然后在前面拼<span class="math inline">\(t\)</span>.根据<span class="math inline">\(\leq
\frac{n}{2}\)</span>的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果<span class="math inline">\(2q&gt; n\)</span>,此时必定有<span class="math inline">\(s=tat\)</span>,其中<span class="math inline">\(t\)</span>是border.考虑递归求解<span class="math inline">\(t\)</span>,然后就只需要找到一个<span class="math inline">\(a\)</span>满足条件,最小的<span class="math inline">\(a\)</span>是全<span class="math inline">\(0\)</span>,能放的话肯定放,不然我们就放一个<span class="math inline">\(0\cdots01\)</span>.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全<span class="math inline">\(0\)</span>不合法:</p>
<ol type="1">
<li>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l\leq|t|+|a|\)</span>:考虑<span class="math inline">\(l\)</span>的最后一段是一段全<span class="math inline">\(0\)</span>,也就必然意味着<span class="math inline">\(t\)</span>的最后一段是全<span class="math inline">\(0\)</span>,这么不断推下去就可以说明整个序列都是全<span class="math inline">\(0\)</span>,此时放上<span class="math inline">\(0\cdots 01\)</span>必定合法.</li>
<li>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l&gt;|t|+|a|\)</span>:不妨设当前的<span class="math inline">\(l\)</span>是最大的那个(最小的无意义,因为需要保证<span class="math inline">\(|l|&gt;|t|\)</span>),此时最短周期必然是<span class="math inline">\(d=2|t|+|a|-l\)</span>.由于<span class="math inline">\(|t|+|a|\)</span>也是周期并且二者之和<span class="math inline">\(\leq n\)</span>,因此必然有<span class="math inline">\(d|(|t|+|a|)\)</span>.把<span class="math inline">\(ta\)</span>按照<span class="math inline">\(d\)</span>长度划分.如果<span class="math inline">\(d\geq|a|\)</span>必有该串是全<span class="math inline">\(0\)</span>串,不然考虑此时<span class="math inline">\(d=|b|+|a|\)</span>,<span class="math inline">\(b\)</span>是<span class="math inline">\(t\)</span>的一段后缀.考虑此时的周期必然<span class="math inline">\(&lt;|b|+|a|\)</span>,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比<span class="math inline">\(|b|-|a|\)</span>少了<span class="math inline">\(w\)</span>,那么此时必定有<span class="math inline">\(b\)</span>的前<span class="math inline">\(w\)</span>个字符是<span class="math inline">\(0\)</span>,但是由于<span class="math inline">\(0\cdots01\)</span>后面第一个<span class="math inline">\(b\)</span>也往前平移了<span class="math inline">\(w\)</span>格,因此它的第<span class="math inline">\(w\)</span>个字符必定是<span class="math inline">\(1\)</span>,这就保证了<span class="math inline">\(0\cdots 0 1\)</span>必定合法.</li>
</ol>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6623</p>
<p>考虑怎么维护所有点权值<span class="math inline">\(+1\)</span>后的结果.一个自然的想法是,如果前<span class="math inline">\([0,k-1]\)</span>位都是<span class="math inline">\(1\)</span>,或者说<span class="math inline">\(v\equiv -1\pmod{2^k}\)</span>,那加一后会让第<span class="math inline">\(k\)</span>位取反.所以我们设<span class="math inline">\(t_{i,j,k}\)</span>表示<span class="math inline">\(i\)</span>的子树内,<span class="math inline">\(\bmod 2^k\)</span>的结果为<span class="math inline">\(j\)</span>的权值的数量.发现这个非常容易维护,用启发式合并可以做到<span class="math inline">\(O(n\log ^2 n)\)</span>.</p>
<p>考虑这个权值的变化其实比较有规律,因为是树上的距离的差.我们考虑把距离这个东西做树上差分,设<span class="math inline">\(v_i=c_i+dis(i,1)\)</span>,我们要找到子树内部满足条件的其实就是在找满足:
<span class="math display">\[
v_i-dis(x,1)-1\equiv -1\pmod {2^k}\\
v_i\equiv dis(x,1)\pmod{2^k}
\]</span> 也就是说我们每次对这个桶中要找的元素很固定,用一下colorful
tree的trick可以做到<span class="math inline">\(O(n\log n)\)</span>.</p>
<p>然后然后,这题还有一个无脑做法是,我们倒着建01trie,这样<span class="math inline">\(+1\)</span>后可以快速更新.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1535F</p>
<p>我一开始第一反应是对<span class="math inline">\(n\times len\leq
2\times 10^5\)</span>这玩意根号分治,但是麻烦得很.</p>
<p>我们来看我当时想的根号分治部分:首先枚举两个字符串然后判断是好做的.我们来看<span class="math inline">\(n\)</span>很大,<span class="math inline">\(len\)</span>较小的时候:此时枚举某个串的后缀,并同时枚举其前缀,然后前缀相同的若干个字符是一个trie上的子树,dfn是一个区间,后缀同理,这样就是一个二维数点问题.</p>
<p>冷静看一下上面的过程,你需要判断中间那一段<span class="math inline">\([l+1,r-1]\)</span>是否是单调不降的序列.那如果我们枚举<span class="math inline">\(r\)</span>,然后直接看满足单调不降的序列最靠左的<span class="math inline">\(l\)</span>是谁,再看<span class="math inline">\([1,l]\cup
[r,n]\)</span>相同,这样不就直接做完了嘛?总之,先按照字符不同分类,再按照字典序排序,然后枚举<span class="math inline">\(r\)</span>,二分找LCP满足条件的区间,和trie上dfn区间构成一个二维数点,总复杂度<span class="math inline">\(O(n\times len\log len)\)</span>.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3311</p>
<p>简单题,ACAM上做数位dp.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1437G</p>
<p>首先肯定可以fail树上树剖,这个做法一眼秒.</p>
<p>然后我看题解发现这个题也可以colorful
tree.大概就是你先离线,然后维护时间维的答案,那么所有的修改操作就可以改成将时间在<span class="math inline">\([l,r]\)</span>这段的字数答案取<span class="math inline">\(\max\)</span>.这个是一个二维的问题.</p>
<p>但是,我们按照colorful
tree的思路去搞,每次dfs到一个点的时候,把答案加入线段树,在返回的时候撤销.注意colorful
tree其实不用撤销,因为它的信息满足可减性,这题不行.然后就实现了单<span class="math inline">\(\log\)</span>做法.可以使用吉司机,但是没必要,因为查询是单点查询,在每个节点上标记永久化然后一路取<span class="math inline">\(\min\)</span>就行.</p>
<p>总结一下上面的这个东西是啥啊,就是说,你发现我们查询的内容是到根的一条链的最大值,这个还挺难做的,因为这条链不满足什么区间的性质,但是子树满足,因此想到了我们可以把操作改成对子树取<span class="math inline">\(\min\)</span>.但是这个操作不满足可减性,难以消去.</p>
<p>如果不满足可删除性,我们一般要想想它是不是满足可撤销性,显然是满足的.因此自然想到了colorful
tree.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1483F</p>
<p>这题可能比较像lxl当时讲的那个支配对问题.我们考虑合法的<span class="math inline">\((i,j)\)</span>的数量的一个上界.一个自然的发现是,考虑先把所有的串按照长度排个序,然后对于较长的串,去找较小的串是否和它满足条件,一个自然的观察是,对于这个较长的串的每个位置<span class="math inline">\(i\)</span>,最多只有一个串是满足条件的<span class="math inline">\([1,i]\)</span>的后缀.因为如果有多个后缀可以选取最长的那个(注意当<span class="math inline">\(i=len\)</span>的时候要选次长的那个,最长的是这个串本身),于是合法的<span class="math inline">\((i,j)\)</span>数量只有<span class="math inline">\(\sum len\)</span>个.首先这些<span class="math inline">\((i,j)\)</span>是有重复的,不过去重很简单.我们现在需要判定是否统计上了<span class="math inline">\((i,j)\)</span>和<span class="math inline">\((k,j)\)</span>使得<span class="math inline">\(i\)</span>是<span class="math inline">\(k\)</span>的子串,<span class="math inline">\(k\)</span>是<span class="math inline">\(j\)</span>的子串.不难发现如果有这种情况出现,必然是因为<span class="math inline">\(k\)</span>在<span class="math inline">\(j\)</span>中的出现位置在某一个<span class="math inline">\(i\)</span>之后,但是<span class="math inline">\(k\)</span>中又出现了<span class="math inline">\(i\)</span>,因此它的左端点必然在<span class="math inline">\(i\)</span>之前.我们维护一个单调栈,每次弹出左端点比当前左端点靠右的那些点,这些一定不会贡献答案.</p>
<p>我本来以为这样就做完了,实际上没有,上面的过程出了什么问题呢?我们确实能删掉所有的<span class="math inline">\((i,j)\)</span>使得存在<span class="math inline">\((k,j)\)</span>满足<span class="math inline">\(i\)</span>是<span class="math inline">\(k\)</span>的子串,并且<span class="math inline">\(i\)</span>不是<span class="math inline">\(k\)</span>的后缀.但是如果是后缀的话我们是有可能删不掉的.</p>
<p>这个问题怎么解决呢?考虑这种事情会发生当且仅当<span class="math inline">\(i\)</span>所代表的ACAM的节点是<span class="math inline">\(k\)</span>的父亲.于是我们用树状数组维护这个东西,具体来说,从大到小判断<span class="math inline">\(i\)</span>是否合法,并且在这个点上<span class="math inline">\(+1\)</span>,用树状数组统计子树内部是否有点就行.注意即使被弹出栈的那些字符串,也需要在这个过程中删去它所有的后缀.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1110H</p>
<p>考虑一个暴力的想法是,这个<span class="math inline">\([l,r]\)</span>的限制条件其实等价于要求<span class="math inline">\([l,r]\)</span>内的所有数字作为子串出现的次数加起来.把所有的这些字符串全部扔进ACAM,然后对着它dp.不妨设<span class="math inline">\(dp_{i,j}\)</span>表示当前走到<span class="math inline">\(i\)</span>节点,然后后面还可以填<span class="math inline">\(j\)</span>个位置的答案,自然有: <span class="math display">\[
dp_{i,j}=\max\{dp_{son,j-1}\}+cnt_i
\]</span> 其中<span class="math inline">\(cnt_i\)</span>表示<span class="math inline">\(i\)</span>节点是多少子串的endn,构造方案是简单的.</p>
<p>考虑如何优化,注意到dp部分看上去挺优秀的,难搞的是ACAM的建树.我们不能把所有数字全扔进去.这种区间信息看上去就是如果走到当前,后面全填<span class="math inline">\(0\)</span>或者后面全填<span class="math inline">\(9\)</span>都能满足条件,那我们就开摆.更具体地来说,我们发现当前的最靠前的那一位没有用了:以它为开头的一定可以找到一个答案(其实因为填的数位).所以我们直接跳fail把那一位跳掉.</p>
<p>如果说的再形象一点的话就是,我们插入的过程其实很废,对于一些特定的前缀<span class="math inline">\(x\)</span>,它的子树内部会形成一个满十叉树.这个是我们无法接受的.来考虑这个东西怎么办,我们一路dfs到叶子后肯定要跳fail,根据ACAM的建树过程,这等价于跳到<span class="math inline">\(x\)</span>的fail,因此其实就等价于把<span class="math inline">\(x\)</span>这一位(或者后面的几位)跳掉.</p>
<p>但是,如果你顺着这个思路想,你开始逐渐剥掉满十叉树,然后一点一点搞,你会做的巨他妈复杂.</p>
<p>我们完全没有必要只在满十叉树的时候才跳跃.换句话说,如果后面填<span class="math inline">\(len\in[l,r]\)</span>长度的字符串全部合法,我们就在这里统计答案,然后继续跳son而不是fail.</p>
<p>我们考虑既然这里填<span class="math inline">\(len\in[l,r]\)</span>都可以,那填<span class="math inline">\(l-1\)</span>的长度或者填<span class="math inline">\(r+1\)</span>的长度就不一定能全部合法了.只有后面几位填的满足某种条件才能合法.但是你注意啊,我们并不在左端点统计答案,而是在这个串填到某一位(可能是最后一位),然后后面都可以随便填的时候,才统计这里的答案,不一定跳fail.而我们跳fail的时候,会删去若干个前缀字符,这些答案会随着fail链一路传过来.还有一个问题是,如果我们跳fail跳到了被删去的虚拟节点怎么办?这种情况压根不会有贡献:这个被删去的虚拟节点的贡献会被传到它的某个祖先上,然后早早地贡献掉.我们跳到的fail应该是第一个不是虚拟节点的位置.因此这里也不会被更新答案.</p>
<p>这样整个题就是简单的了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4218</p>
<p>首先有一个<span class="math inline">\(O(n^2)\)</span>的暴力是,我们暴力在<span class="math inline">\(SAM\)</span>上跑一遍所有的串.我们考虑怎么优化这个东西.</p>
<p>树上路径,想到点分治,我们考虑对于一个分治中心<span class="math inline">\(x\)</span>,求出所有经过它的路径.这个怎么求呢?我们考虑先求出所有<span class="math inline">\(u\rightarrow x\)</span>的路径,以及所有<span class="math inline">\(x\rightarrow
v\)</span>的路径,假设前者的终点为<span class="math inline">\(p\)</span>,后者的起点为<span class="math inline">\(p\)</span>,那我们可以在<span class="math inline">\(p\)</span>节点统计答案.但是发现<span class="math inline">\(u\rightarrow
x\)</span>这个东西需要往前加字符,不过这个好做,首先往前加字符等价于在parent
tree上跳儿子,而所有的儿子前面的第一个字符肯定是不同的,我们处理出<span class="math inline">\(son_{x,c}\)</span>表示在<span class="math inline">\(x\)</span>这个节点,往前加一个字符<span class="math inline">\(c\)</span>会到哪个节点.当然这个你实在不行把串反过来也行.</p>
<p>以及为了不让<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>在同一棵子树内,我们需要对其做容斥.不难发现每次操作和每次容斥的复杂度都是<span class="math inline">\(O(m+size)\)</span>的.总复杂度<span class="math inline">\(O(n\log n+nm)\)</span>,好像不太行.</p>
<p>冷静一下,我们把<span class="math inline">\(siz\)</span>较小的那些拿上面的暴力处理掉,这样就只有<span class="math inline">\(siz\)</span>较大的那些会有用了.这个复杂度怎么证明呢?我们考虑点分树.不妨假设它是一棵二叉树(其它的情况是类似的).</p>
<p>考虑将它的第<span class="math inline">\(B\)</span>层以下的树全部暴力,这里一共有<span class="math inline">\(2^{B}\)</span>棵树,每棵复杂度是<span class="math inline">\(O(2^{2(\log n-B)})\)</span>的.</p>
<p>它的第<span class="math inline">\(B\)</span>层以上的跑上面的点分树,这里一共有<span class="math inline">\(2^B\)</span>个节点,每个节点要跑一次<span class="math inline">\(O(n+m)\)</span>的做法.</p>
<p>平衡一下复杂度,设<span class="math inline">\(B=\frac{\log
n}{2}\)</span>,此时复杂度<span class="math inline">\(O((n+m)\sqrt
n)\)</span>.</p>
<h3><span id="动态规划第二期">动态规划第二期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P9318</p>
<p>不合法的情况如此方便,因为两边直接独立了,因此直接考虑二项式反演,设<span class="math inline">\(f_k\)</span>表示恰好有<span class="math inline">\(k\)</span>个裂缝,<span class="math inline">\(g_k\)</span>表示钦定有<span class="math inline">\(k\)</span>个裂缝,自然有: <span class="math display">\[
g_k=\sum_{i=k}^w\binom{i}{k}f_i\\
f_k=\sum_{i=k}^w\binom{i}{k}(-1)^{i-k}g_i\\
ans=f_0=\sum_{i=0}^w(-1)^{i}g_i
\]</span> 考虑设一个高为<span class="math inline">\(h\)</span>,长为<span class="math inline">\(k\)</span>的段随便填的方案数,显然就是每一层都随便填的方案数,也就是<span class="math inline">\(w_k=(F_k)^h(w_0=0)\)</span>,其中<span class="math inline">\(F_k\)</span>是斐波那契数列的第<span class="math inline">\(k\)</span>项,那么<span class="math inline">\(g_i\)</span>就是这玩意做卷积.更具体地,我们设<span class="math inline">\(g_{i,j}\)</span>表示目前长度为<span class="math inline">\(j\)</span>,分成了<span class="math inline">\(i\)</span>段的答案,自然有: <span class="math display">\[
g_{i,j}=\sum_{k&lt;j}g_{i-1,k}w_{j-k}\\
G_i=W^i
\]</span> 这个生成函数形式其实没啥用,因为模数是<span class="math inline">\(10^9+7\)</span>.上述dp的复杂度是<span class="math inline">\(O(n^3)\)</span>的.</p>
<p>冷静一下不要魔怔,我们考虑别二项式反演,直接补集转化,这样就只需要知道最靠前的裂缝.换句话说,我们设<span class="math inline">\(f_i\)</span>表示当前考虑到前<span class="math inline">\(i\)</span>列,然后没有裂缝的方案数,不难发现<span class="math inline">\(f_n=w_n-\sum_{k=1}^{n-1}f_kw_{n-k}\)</span>.这样就是<span class="math inline">\(O(w^2)\)</span>的.</p>
<p>冷静一下,注意到<span class="math inline">\(wh\)</span>有限制,因此复杂度应该要和<span class="math inline">\(wh\)</span>有关,考虑对于一个联通的块的答案,你的最右侧一定不是平的,应该是有凹凸的.我们设<span class="math inline">\(f_{i,j}\)</span>表示当前dp完了前<span class="math inline">\(i\)</span>列,在第<span class="math inline">\(i+1\)</span>列凸出来了<span class="math inline">\(j\)</span>个位置.转移的话考虑凹的位置填什么,如果填<span class="math inline">\(2\)</span>就往后再凸一格,如果填<span class="math inline">\(1\)</span>就没啥事.具体地: <span class="math display">\[
f_{n,m}\binom{h-m}{k}\rightarrow f_{n+1,k},k\in[0,h-m]
\]</span> 这个dp的复杂度为<span class="math inline">\(O(wh^2)\)</span>.注意到这两个dp的复杂度不同,于是分治,不妨设<span class="math inline">\(N=wh\)</span>,</p>
<p>第一个dp的复杂度是<span class="math inline">\(O(\frac{N^2}{h^2})\)</span>,第二个dp的复杂度是<span class="math inline">\(O(Nh)\)</span>,当<span class="math inline">\(h\leq
N^{\frac{1}{3}}\)</span>的时候使用第二个dp,不然使用第一个,复杂度<span class="math inline">\(O(N^{\frac{4}{3}})\)</span>.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1250D</p>
<p>最重要的观察在于,这题等价于保留最多的区间,使得若其中某两个区间有交,那么它们必定颜色相同,但是同时需要满足一些形如某个区间只能染某种颜色的限制条件.原因很简单,首先原题的意思自然是找到染色方式,使得满足与其有交的区间颜色必定和它相同.那么对于一个满足条件的区间,如果与它有交的区间不满足条件,我们把那个区间删了这个区间也不会不满足条件.于是合法的不会变成不合法,接下来需要说明不合法的不会变成合法.首先是原本已经确定了颜色的区间,这个限制好做.然后是如果一个区间没有确定颜色,那它不能被包括在多个确定了的区间.这等价于,我们对于与右端点相交的所有无色区间全部作为新的右端点来更新.这样后面选的时候就不会错误更新右端点了.</p>
<p>或者我们换一个更清晰的描述,我们现在想要得到一些极长的段,使得这些段两两不交,并且与这些段相交的区间都是一个颜色.那么被完全包含在这个段内的区间显然就是答案,我们要最大化这个.</p>
<p>然后上面形成若干限制条件,但是这个在下面的dp中是好处理的.不过有个细节是,如果有两个相邻的连续段(不一定紧邻)的颜色相同,那么我们上一个区间的后面拖着的无色区间是不必对此产生影响的.这怎么办呢?特判一下同色.</p>
<p>这样的dp就很好设计了,更具体地,设<span class="math inline">\(f_{r,k}\)</span>表示目前<span class="math inline">\([1,r]\)</span>,包含<span class="math inline">\(r\)</span>的那个区间颜色是<span class="math inline">\(k\)</span>,最多能保留多少个区间.自然有: <span class="math display">\[
[l,r]=k\Rightarrow f_{r,k}\leftarrow
cnt_{l,r,k}+\max_{i=0}^{l-1}f_{i,k&#39;}
\]</span> 设<span class="math inline">\(g_{i}=\max_{k}f_{i,k}\)</span>,我们有: <span class="math display">\[
[l,r]=k\Rightarrow f_{r,k}\leftarrow cnt_{l,r,k}+\max_{i=0}^{l-1}g_{i}
\]</span> 对于<span class="math inline">\(g_i\)</span>做前缀<span class="math inline">\(\max\)</span>,这样就只需要枚举<span class="math inline">\(r,k\)</span>.复杂度<span class="math inline">\(O(n^2c)\)</span>.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1158F</p>
<p>考虑如何判断一个串的密度,不妨设它密度为<span class="math inline">\(P\)</span>,我们从左往右找到第一个位置,使得前缀的密度为<span class="math inline">\(1\)</span>,那么显然这个位置的后缀的密度是<span class="math inline">\(P-1\)</span>,如果小了,那么这个第一个位置所代表的那个数字开头的子序列就不全.如果多了,那显然可以构造出密度至少为<span class="math inline">\(P+1\)</span>的子序列.由上面这个描述,我们发现一个密度为<span class="math inline">\(P\)</span>的序列一定可以分成<span class="math inline">\(P\)</span>个子段,使得每个子段都出现了<span class="math inline">\([1,c]\)</span>中所有的数字.更进一步地,我们如果不是划分,那么<span class="math inline">\(P\)</span>中一定存在<span class="math inline">\(P\)</span>个互不相交的子段,使得每个子段都出现了<span class="math inline">\([1,c]\)</span>中所有的数字并且每个子段最后的那个元素只出现了一次.顺便我们还可以发现<span class="math inline">\(p\leq \frac{n}{c}\)</span>.</p>
<p>由上面,我们可以发现一个状压dp,也就是设<span class="math inline">\(dp_{i,j,S}\)</span>表示当前走到<span class="math inline">\(i\)</span>,前面的密度为<span class="math inline">\(j\)</span>,然后如果在后面全出现了<span class="math inline">\(S\)</span>中的数字,那么密度会变大<span class="math inline">\(1\)</span>.这样给出了一个<span class="math inline">\(\frac{n^2}{c}2^c\)</span>的做法.</p>
<p>质数感觉不太行啊,考虑考虑dp,上面的形式看上去就很好dp,设<span class="math inline">\(dp_{i,j}\)</span>表示当前在<span class="math inline">\(i\)</span>然后密度是<span class="math inline">\(j\)</span>的方案数,再设<span class="math inline">\(f_{l,r}\)</span>表示在<span class="math inline">\([l,r]\)</span>中选出一个子序列,<span class="math inline">\(r\)</span>必选且<span class="math inline">\(a_r\)</span>只出现了一次的方案数.不妨设<span class="math inline">\(T_i\)</span>表示<span class="math inline">\(i\)</span>在这个区间出现的次数,不难发现<span class="math inline">\(f_{l,r}=\prod_{i\ne
a_r}(2^{T_i}-1)\)</span>.这个只需要枚举<span class="math inline">\(l\)</span>扫<span class="math inline">\(r\)</span>就可以<span class="math inline">\(O(n^2)\)</span>算.自然有转移: <span class="math display">\[
dp_{i,j}=\sum_{k&lt;i}dp_{k,j-1}f_{k+1,i}
\]</span> 不过吧这么转移有一个小问题,那就是我们的<span class="math inline">\(dp_{i,j}\)</span>必须是最后一段以<span class="math inline">\(i\)</span>结尾.那么我们最后统计答案还要算上最后的那一段没有选出<span class="math inline">\([1,c]\)</span>的答案.不过这个也好算.</p>
<p>但是还有一个方式,那就是从后往前dp,然后每次放这么一段,对dp取一个后缀和来转移.</p>
<p>总之,这个dp的复杂度是<span class="math inline">\(O(\frac{n^3}{c})\)</span>的.取<span class="math inline">\(c=\log
n\)</span>为两个复杂度的边界,这样总复杂度是<span class="math inline">\(O(n^2\log n)\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1175G</p>
<p>显然设<span class="math inline">\(f_{i,j}\)</span>为前<span class="math inline">\(j\)</span>个划分了<span class="math inline">\(i\)</span>段,自然有: <span class="math display">\[
f_{i,j}=\min_{k&lt;j}\{f_{i-1,k}+(j-k)\max_{l=k+1}^ja_l\}
\]</span> 第一反应是决策单调性,可惜没有.</p>
<p>不过后面那个形式很简单,我们暴力一点维护这个东西.用单调栈维护出当前哪些后缀的最大值相等,不妨记这个最大值为<span class="math inline">\(m\)</span>.我们改成刷表更新: <span class="math display">\[
f_{i-1,k}+(j-k)\max_{l=k+1}^ja_l\rightarrow f_{i,j}
\]</span> 对于每层<span class="math inline">\(i\)</span>从左往右扫<span class="math inline">\(k\)</span>,然后维护单调栈,然后对于每个点,它对右边的贡献在<span class="math inline">\(\max_{l=k+1}^ja_l\)</span>不变的情况下,就是一条稳定的一次函数.但是这样还有一个问题,就是我们如何快速求出一个区间的所有的直线.这个的话,我们考虑对于不同的<span class="math inline">\(\max_{l=k+1}^ja_l\)</span>,求出最小的<span class="math inline">\(f_{i-1,k}-k\max_{l=k+1}^ja_l\)</span>,这相当于一个凸包,然后用斜率为<span class="math inline">\(m\)</span>的直线来切点.然后合并两个凸包可以启发式合并,用链表维护队列.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9312</p>
<p>首先观察到我们可以限制手上的灯笼能照亮的海拔是一段区间,因为我们可以先选择不断扩张,而不是提前买,等到了需要用的时候再买就行.</p>
<p>一个自然的想法是<span class="math inline">\(f_{s,l,r}\)</span>表示以<span class="math inline">\(s\)</span>为起点,当前能走到的海拔高度是<span class="math inline">\([l,r]\)</span>.为什么需要记录<span class="math inline">\(s\)</span>呢?因为可能有不同的区间走出来的海拔高度都是<span class="math inline">\([l,r]\)</span>.那我们设<span class="math inline">\(f_{l,r}\)</span>为当前海拔最低的那个灯编号是<span class="math inline">\(l\)</span>,最高的那个编号是<span class="math inline">\(r\)</span>.然后我们要知道的就是<span class="math inline">\(f_{s,s}\)</span>.然后按照区间从大到小dp.这样有一个<span class="math inline">\(O(k^3)\)</span>的做法.</p>
<p>考虑如何优化,不妨假设当前新买的灯笼是第<span class="math inline">\(u\)</span>个,那么我们分情况讨论一下:</p>
<ol type="1">
<li><span class="math inline">\(f_{i,u}+c_u\rightarrow
f_{i,j}\)</span>.这种情况需要保证<span class="math inline">\(u\)</span>能买的地方在<span class="math inline">\(i,j\)</span>的控制区域里,并且需要满足<span class="math inline">\(u\)</span>的区间和<span class="math inline">\(i,j\)</span>的区间是相交的.这种情况上也就是需要<span class="math inline">\(u\)</span>的下界小于等于<span class="math inline">\(j\)</span>的上界.这个比较好处理,我们从大到小枚举<span class="math inline">\(j\)</span>,等<span class="math inline">\(f_{i,u}\)</span>不合法的时候把它删了就是了.</li>
<li><span class="math inline">\(f_{u,u}+c_u\rightarrow
f_{i,j}\)</span>.和上面是类似的.</li>
</ol>
<p>也就是说,我们现在唯一最需要搞定的就是怎么让<span class="math inline">\(u\)</span>能买的地方在<span class="math inline">\(i,j\)</span>的控制区域里,不难发现这是一个看上去比较典的线段树维护dp.</p>
<p>事实上有一种更简单的写法,不妨设<span class="math inline">\(L,R\)</span>为实际控制的海拔范围,<span class="math inline">\(S,T\)</span>为实际控制的山峰范围,我们先把转移仔细写一下:</p>
<ol type="1">
<li><span class="math inline">\(f_{l,u}+c_u\rightarrow
f_{l,r}(R_u&gt;R_r\geq L_u\and u\in[S_l,T_r])\)</span>.</li>
<li><span class="math inline">\(f_{u,r}+c_u\rightarrow
f_{l,r}(L_u&lt;L_l\leq R_u\and u\in[S_l,T_r])\)</span>.</li>
<li><span class="math inline">\(f_{u,u}+c_u\rightarrow
f_{l,r}(L_u&lt;L_l\leq R_u\and R_u&gt;R_r\geq L_u\and
u\in[S_l,T_r])\)</span>.</li>
</ol>
<p>按照<span class="math inline">\(L\)</span>从小到大枚举,按照<span class="math inline">\(R\)</span>从大到小枚举,那上面的所有转移都是无后效性的.</p>
<p>注意到第三种转移没有意义,我们可以直接改写成:</p>
<ol type="1">
<li><span class="math inline">\(\min\{f_{l,u},f_{u,u}\}+c_u\rightarrow
f_{l,r}(R_u&gt;R_r\geq L_u\and u\in[S_l,T_r])\)</span>.</li>
<li><span class="math inline">\(\min\{f_{u,r},f_{u,u}\}+c_u\rightarrow
f_{l,r}(L_u&lt;L_l\leq R_u\and u\in[S_l,T_r])\)</span>.</li>
</ol>
<p>原因在于,我们其实只想要让<span class="math inline">\(u\)</span>与<span class="math inline">\(l,r\)</span>所代表的区间相交,这个比较重要,其它的都不重要.就算转移是错误的,那样转移一定不优秀.</p>
<p>此刻对于(1)我们想知道的就是固定<span class="math inline">\(l\)</span>的情况下,按照<span class="math inline">\(R\)</span>从大到小枚举的贡献,以及对称情况,不难发现这个用堆也是能做的.也就是在<span class="math inline">\(l\)</span>相同的前提下,如果<span class="math inline">\(R_i&lt;R_j&lt;R_k\)</span>,如果<span class="math inline">\(k\)</span>不能贡献到<span class="math inline">\(j\)</span>,那么<span class="math inline">\(k\)</span>必然不能贡献到<span class="math inline">\(i\)</span>,这就保证了堆的正确性.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P8294</p>
<p>毛估估的话就是设<span class="math inline">\(f_{x,s,t}\)</span>表示在断开<span class="math inline">\(x\)</span>到父亲这条边时,<span class="math inline">\(x\)</span>的值来自子树内的点<span class="math inline">\(s\)</span>,然后从父亲换下来的值将要去子树内的<span class="math inline">\(t\)</span>.不难发现<span class="math inline">\((x,s,t)\)</span>合法当且仅当<span class="math inline">\(x=lca(s,t)\)</span>,这样状态数就是<span class="math inline">\(O(n^2)\)</span>的.</p>
<p>来细细写一写转移:</p>
<p>首先,如果<span class="math inline">\(cnt_{son}=0\)</span>,显然<span class="math inline">\(f_{x,x,x}=d_x\)</span>.</p>
<p>如果<span class="math inline">\(cnt_{son}=1\)</span>,不妨设其儿子是<span class="math inline">\(u\)</span>,不难发现此时必有<span class="math inline">\(s_x=x\or t_x=x\)</span>,讨论一下:</p>
<p>若<span class="math inline">\(s_x=x\)</span>,那么之间换出去就行,然后因为要一路换下去:
<span class="math display">\[
f_{x,x,t_x}\leftarrow f_{u,s_u,t_x}+d_x
\]</span> 反之,那么要先把<span class="math inline">\(s_x\)</span>换到<span class="math inline">\(x\)</span>这里,然后再换出去,此时有: <span class="math display">\[
f_{x,s_x,x}\leftarrow f_{u,s_x,t_u}+d_x+d_{s_x}(dep_{s_x}-dep_{x})
\]</span> 注意到上述复杂度均为<span class="math inline">\(O(n^2)\)</span>.因为枚举一下<span class="math inline">\((s_u,t_x)\)</span>或<span class="math inline">\((s_x,t_u)\)</span>就可以确定<span class="math inline">\(u\)</span>,而<span class="math inline">\(x\)</span>是<span class="math inline">\(u\)</span>的父亲,自然也可以确定.</p>
<p>这个式子已经给了我们启发了,剩下的类似.有时间再补这个题吧,太精神污染了.</p>
<h3><span id="数据结构">数据结构</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1648D</p>
<p>不妨设<span class="math inline">\(f_i\)</span>表示从<span class="math inline">\((1,1)\)</span>走到<span class="math inline">\((2,i)\)</span>的最大收益,显然求出这个后再拼一下第三行的后缀和就是答案.我们枚举覆盖<span class="math inline">\((2,i)\)</span>的区间是<span class="math inline">\(k\)</span>,此时必然需要满足<span class="math inline">\(l_k\leq i\leq r_k\)</span>.</p>
<p>不妨设<span class="math inline">\(sum\)</span>表示每一行的前缀和,<span class="math inline">\(sufsum\)</span>表示第三行的后缀和,注意到转移:
<span class="math display">\[
-c_k+\max_{l_k-1\leq j&lt;i\leq r_k}\{f_j\}\rightarrow f_i\\
-c_k+\max_{l_k\leq j\leq i\leq r_k}\{sum_{1,j}-sum_{2,j-1}\}\rightarrow
f_i
\]</span> 这个东西即使我们枚举<span class="math inline">\(k,i\)</span>,然后数据结构优化<span class="math inline">\(j\)</span>来转移它也是艰难的.那咋办呢?我们考虑我们枚举<span class="math inline">\(k\)</span>的原因是,我们需要保证<span class="math inline">\(i\leq r_k\)</span>.如果我们钦点<span class="math inline">\(i=r_k\)</span>,那我们上面的枚举就只有一维了.也就是需要保证<span class="math inline">\(i\)</span>右边的点一定走不到,这样我们上面的转移仍然是正确的.至于计算答案,一个反应是把这个<span class="math inline">\(f\)</span>做一下后缀<span class="math inline">\(\max\)</span>.但其实不对!因为你往后多走点可能多吃到了一点<span class="math inline">\(a\)</span>.</p>
<p>那么怎么处理这个东西呢?考虑如果当前选的这个区间不是最后一个区间,那我从后面的<span class="math inline">\(r\)</span>走到前面的一个<span class="math inline">\(i\)</span>再拐到第三行去,显然只会有第二行的一段和的差别,我们把这个差别统计进去就行.但是如果只开了一个区间,也就是从第一行拐下来没到结尾直接拐下第三行了,那么第一行的贡献也要减去.我们可以把<span class="math inline">\(f_{i}\)</span>改成<span class="math inline">\(f_{i,0/1}\)</span>来解决这种问题.</p>
<p>于是吧,我们就有了下面这个转移: <span class="math display">\[
-c_k+\max_{l_k-1\leq j&lt;r_k}\{f_{j,0},f_{j,1}\}\rightarrow f_{r_k,1}\\
-c_k+\max_{l_k\leq j\leq r_k}\{sum_{1,j}-sum_{2,j-1}\}\rightarrow
f_{r_k,0}
\]</span>
然后怎么贡献答案呢?首先你不能往左走太多,至少不能超过最后选的那个区间.事实上我们发现最后一定只有一个区间的右端点超过了拐点.因为选择的所有区间一定没有包含关系,而右端点可以对拐点取<span class="math inline">\(\min\)</span>.因此我们枚举当前最靠右的那个区间<span class="math inline">\(k\)</span>,以及最后拐到第三行的点<span class="math inline">\(i\)</span>,自然有: <span class="math display">\[
-c_k+\max_{l_k-1\leq j&lt;r_k}\{f_{j,0},f_{j,1}\}+\max_{j&lt;i\leq
r_k}\{sum_{2,i}+sufsum_{i}\}\rightarrow ans\\
-c_k+\max_{l_k\leq j\leq i\leq
r_k}\{sum_{1,j}-sum_{2,j-1}+sum_{2,i}+sufsum_i\}\rightarrow ans
\]</span> 要统计所有<span class="math inline">\(j&lt;i\)</span>或者<span class="math inline">\(j\leq
i\)</span>的点对的答案在线段树上都是好做的.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P9371</p>
<p>考虑如何判断<span class="math inline">\(x\)</span>是否是这个区间的中位数:我们把大于<span class="math inline">\(x\)</span>的记作<span class="math inline">\(1\)</span>,小于<span class="math inline">\(x\)</span>的记作<span class="math inline">\(-1\)</span>,<span class="math inline">\(x\)</span>记作<span class="math inline">\(0\)</span>,如果区间和的绝对值小于等于<span class="math inline">\(x\)</span>的出现次数,那么<span class="math inline">\(x\)</span>满足条件.</p>
<p>我们先扫值域,这样修改每个点的取值的总复杂度均摊.对于每一个权值<span class="math inline">\(v\)</span>,枚举权值是<span class="math inline">\(v\)</span>的一个点作为这个区间中最靠左的<span class="math inline">\(v\)</span>,然后考虑找到最大的右端点使得合法,而由于确定了最靠左的<span class="math inline">\(v\)</span>,我们其实是不在乎这个区间左端点是啥的,只要包含这个点就行,不妨设这个点为<span class="math inline">\(l\)</span>.</p>
<p>接下来在每个点记录以这个点的为结尾的所有后缀和(要求左端点小于等于<span class="math inline">\(l\)</span>)的集合.不难发现,这个集合一定是一段区间,因为每个值只有可能是<span class="math inline">\(\pm 1\)</span>或<span class="math inline">\(0\)</span>.于是我们要维护的就是这些点的最大后缀和以及最小后缀和,然后判断这个值与<span class="math inline">\(x\)</span>的大小关系.用线段树维护这两个东西的<span class="math inline">\(\max\)</span>和<span class="math inline">\(\min\)</span>,能往右跳就往右跳.</p>
<p>有个细节是我们需要保证这些后缀和的左端点小于等于<span class="math inline">\(l\)</span>,这其实等价于直接求<span class="math inline">\(l\)</span>这里的最小后缀和以及最大后缀和,然后在每个点上只需要存这个点与<span class="math inline">\(l\)</span>这段区间和即可,这个在<span class="math inline">\(l\)</span>的移动过程中是好维护的.</p>
<p>至于最大后缀和的合并是简单的.</p>
<p>写起来发现上面那个东西其实不太好搞啊,我们考虑改改描述,上面等价于将每个区间改成最小后缀和<span class="math inline">\(-x\)</span>出现次数,以及最大后缀和<span class="math inline">\(+x\)</span>出现次数,然后只需要判断这个区间是否包含<span class="math inline">\(0\)</span>.好像还是不太好做???</p>
<p>冷静一下,注意到相邻两个位置的最大后缀和相差不超过<span class="math inline">\(1\)</span>,这意味着我们可以维护一段区间的所有区间的并,这必定还是一个区间.然后判断这个并是否包含<span class="math inline">\(0\)</span>,这个就方便线段树上二分了.至于我们的修改操作,无非是以下几种操作:</p>
<ol type="1">
<li>对于每个<span class="math inline">\(l\)</span>以及它的一对后缀和,在线段树上找到最靠右的一个叶子使得这个区间在加上这对后缀和更改后包含<span class="math inline">\(0\)</span>.</li>
<li>在更改当前处理的值<span class="math inline">\(v\)</span>的时候,将所有点的值恢复为前缀和.</li>
<li>在更改当前处理的值<span class="math inline">\(v\)</span>的时候,将某些点的值置为<span class="math inline">\(-1\)</span>,将某些点的值置为<span class="math inline">\(0\)</span>.</li>
</ol>
<p>显然都好做.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P7220</p>
<p>ps:本题选入笔记:常见套路-二进制分组-Example1</p>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点<span class="math inline">\((x,y)\)</span>,随着<span class="math inline">\(x\)</span>的增大<span class="math inline">\(y\)</span>不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.考虑求出所有能影响到一个询问的区间,把它们扔到线段树上,然后就可以用线段树分治维护这个东西.具体来说,我们在线段树上dfs,每次遇到一个区间,把该搞得全部搞完,然后这个点的位置就留在这里了,在后面dfs到其它的区间后再改.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9168</p>
<p>场上写了<span class="math inline">\(48pts\)</span>,简单来说就是对于每个<span class="math inline">\(m\)</span>,从下往上合并,然后当某一个时刻某棵子树内人数大于子树大小,就把最菜的那几个给删了.根据Hall定理,这样做显然是正确的.</p>
<p>接下来看怎么优化,首先第一反应肯定是线段树分治,这样我们只需要做加入和撤销,就不需要做删除了.撤销总是好做的.</p>
<p>那么只有加入怎么做呢?这个点能造成的影响无非是以下几种:</p>
<ol type="1">
<li>它被加入,没有别的点被删除.</li>
<li>它被加入,另一个点被删除.</li>
<li>它没有被加入.</li>
</ol>
<p>注意到(1)发生当且仅当这个点到根的路径上没有节点是满节点,这个判一下就行.</p>
<p>然后考虑(2),(3),淘汰必然会发生,并且必定是在离插入点最近的那个满的祖先.</p>
<p>这样的话我们需要实现的就是两件事:</p>
<ol type="1">
<li>对于一个点,找到离他最近的满的祖先.</li>
<li>查询子树内部点的最小值.</li>
<li>支持在点上插入和删除.</li>
</ol>
<p>这三个操作显然都可以用树剖维护.算上线段树分治,这样就是<span class="math inline">\(O(n\log^3 n)\)</span>.</p>
<p>不过吧,我们需要说明一件事情:那就是为啥选择子树内最小的那个点一定是优秀的.我们可以简单举个例子来反对这个直觉:如果有两个点权值相同,一个点是另一个点的祖先,那显然选择祖先会优秀一点,因为这个祖先对下面子树的限制要小一些.</p>
<p>我们可以这么干:我们在一开始那个暴力中这么规定:每次满员了之后,删掉权值最小的,权值相同的则按照编号删.对于一个子树<span class="math inline">\(x\)</span>,假设它所有儿子的子树都合法了,并且它需要删,此时:</p>
<ol type="1">
<li>如果我们之前想删的那个点已经死了,那就完事了.</li>
<li>如果我们之前想删的那个点没死,注意到我们接下来插入的点一定排序比当时想删它的时候只大不小,那此时必然还要删掉它.</li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF464E</p>
<p>之前做过,就是最短路.但是我们要实现高精度加法和高精度比较大小,注意到加上一个<span class="math inline">\(2^x\)</span>在二进制上的体现是某段<span class="math inline">\(1\)</span>变成<span class="math inline">\(0\)</span>,某一个<span class="math inline">\(0\)</span>变成<span class="math inline">\(1\)</span>,这个可以用主席树实现.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1801E</p>
<p>简单题,考虑暴力显然是直接大力并查集,而并查集的操作其实是不多的:一次有用的并查集操作必定是会让连通块个数减少<span class="math inline">\(1\)</span>,因此操作均摊.于是考虑二分+哈希找到第一个有用的并查集操作.这就必然要求我们快速求出一条路径的哈希值.考虑哈希是可以差分的,因此处理每个点到根的哈希值(注意要维护两个方向)即可.每改变一个点就把子树内全部更改一下,这样就做完了.使用启发式合并可以做到<span class="math inline">\(O(n\log^2n)\)</span>.</p>
<p>不过发现这个过程只有区间加法和单点查询,可以使用树状数组.</p>
<p>然后就卡了一晚上常数.事实上这题存在二进制分组做法:我们发现我们要做的无非是将两段直上直下的序列,然后定义它们对应数字相等.我们可以将一个点到它的<span class="math inline">\(2^k\)</span>级祖先所形成的这么一段拆成一段,这样就可以直接倍增然后处理.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF702F</p>
<p>典典典.考虑维护人的平衡树,然后每次check一个衬衫.注意到它会把大于等于它的人给减去这个值.我们考虑将这个splay分裂开来,然后对大于等于它的那些点打个减法tag,再与小于它的那个分裂出去的树合并起来.但是splay无法支持快速合并两棵无大小关系的树(ye不能启发式合并,因为以后还要裂开),我们考虑当前衬衫的价格是<span class="math inline">\(v\)</span>,将所有人分成<span class="math inline">\([0,v),[v,2v),[2v,+\infty)\)</span>,三个部分,第一个部分不用管,第二个部分减去<span class="math inline">\(v\)</span>后变成第一个部分,我们把它们暴力插入第一个部分.第三个部分直接打tag并合并,由于第二个部分的暴力插入会使得权值减半,因此总复杂度<span class="math inline">\(O(n\log^2n)\)</span>.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P6072</p>
<p>考虑对于每一条边,求出以这条边为界限,两边的最大值然后加起来,显然就是答案.</p>
<p>还有一点是,一条路径<span class="math inline">\(x-y\)</span>的权值可以表示为<span class="math inline">\(dep_x\oplus
dep_y\)</span>,这就启发我们用01trie维护最大异或值.</p>
<p>现在相当于求出<span class="math inline">\(f_x\)</span>表示<span class="math inline">\(x\)</span>的子树内的答案,再求出<span class="math inline">\(g_x\)</span>表示<span class="math inline">\(x\)</span>的子树外的答案.这个怎么求呢?首先<span class="math inline">\(f_x\)</span>可以启发式合并01trie.</p>
<p>对于<span class="math inline">\(g_x\)</span>,也很好做.你考虑求出全局最大的那条路径,显然只要分割点不在这条路径上,就会选取它.反之的话,就是两条路径往下dfs,这个直接暴力做01trie就是<span class="math inline">\(O(n\log w)\)</span>.</p>
<p>做到这里我们冷静一下看看<span class="math inline">\(f\)</span>,注意到只有临近上面我们说的那条链的<span class="math inline">\(f\)</span>,或者是就在这条链上的<span class="math inline">\(f\)</span>.我们只需要求出这些<span class="math inline">\(f\)</span>,因为再往下也没啥用,这样就能让总复杂度变成<span class="math inline">\(O(n\log w)\)</span>.</p>
<h3><span id="图论">图论</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4768</p>
<p>典中典,求kruskal重构树,以及<span class="math inline">\(1\)</span>到所有点的最短路即可.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1408G</p>
<p>首先你需要发现,一个点集内部的边全部小于它与外界相连的边,那么如果我们从小到大加边,那么必然有一个时刻是这个点集成为了一个和外界分离的团.因此,考虑从小到大加边,并考虑kruskal重构树的结构,我们就可以将这个过程展现在树上.并且这个过程等价于区间合并.因此我们的问题转化为了有若干区间,选取若干不交的区间覆盖全集的方案数,简单的.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P9167</p>
<p>我们设题面中的<span class="math inline">\(t\)</span>座城市是关键城市,根据题面,断掉这<span class="math inline">\(t\)</span>座城市之间的边,会使得图分裂成若干个大小相差至多为<span class="math inline">\(k\)</span>的连通块.我们不妨认为在一个连通块中,关键城市控制着里面的所有点,那么被不同城市控制的点一定没有边相连.如果此时图是树的话我们已经做完了,无非是要在树上划分点集.反之,我们考虑dfs树,维护出点双意义下的<span class="math inline">\(dfn,low\)</span>.注意到一个连通块必定在dfs树上也是连通块.</p>
<p>那么一个点能作为关键点,当且仅当它在dfs树上的某些子树所组成的城市都被控制,这个可以通过<span class="math inline">\(low\)</span>来判断.枚举连通块大小,并设<span class="math inline">\(dp_{i,j}\)</span>表示<span class="math inline">\(i\)</span>子树上部还有<span class="math inline">\(j\)</span>个城市没决定被控制,这样就可以dp.注意到第二维有用的信息不多,这样就可以优化到<span class="math inline">\(O(n\sqrt n)\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9170</p>
<p>先看Bob,先把<span class="math inline">\(|T|=1\)</span>的选了,然后删掉.不断做这个过程直到所有的<span class="math inline">\(|T|=2\)</span>,此时将这两个点之间连一条边,那就会形成一张图.对于每个连通块,若<span class="math inline">\(|E|&gt;|V|\)</span>,则必然无解.其它的情况必然有解,这就解决了第一个问题.</p>
<p>不过其实没必要删<span class="math inline">\(|T|=1\)</span>,直接连自环就行.</p>
<p>对于Alice,考虑以下几种情况:</p>
<ol type="1">
<li><span class="math inline">\(|S\and
T|=0\)</span>,显然Alice选啥都没用.</li>
<li><span class="math inline">\(|S\and
T|=1\)</span>,此时Alice必然选那个和Bob有交的.</li>
<li><span class="math inline">\(|S\and
T|=2\)</span>,此时Alice可以选择其中一个.</li>
</ol>
<p>这样的话,Alice就已经确定了一些东西,而不确定另一些东西.Alice必然是要让Bob能选的最小情况最大,我们考虑再讨论一下:</p>
<ol type="1">
<li><span class="math inline">\(|E|=|V|\)</span>,此时连通块是一个基环树.那么除了环以外的点一定都选好了.如果是自环那么怎么选都行.反之,环上有两种选择方式(就是一个点会在哪条边上被选).考虑对于两种方式,Alice已经确定必选的数量分别是<span class="math inline">\(c_1,c_2\)</span>,而Alice现在还可以选的个数是<span class="math inline">\(c\)</span>,我们也就是要选取<span class="math inline">\(i\)</span>,最大化<span class="math inline">\(\min\{c_1+i,c_2+c-i\}\)</span>,显然取<span class="math inline">\(c_1+i=c_2+c-i,i=\lfloor\frac{c_2+c-c_1}{2}\rfloor\)</span>,注意如果<span class="math inline">\(i\)</span>要对<span class="math inline">\(0\)</span>取<span class="math inline">\(\max\)</span>,对<span class="math inline">\(c\)</span>取<span class="math inline">\(\min\)</span>.</li>
<li><span class="math inline">\(|E|=|V|-1\)</span>,此时连通块是一棵树,并且有一个点不会被选择.不妨设<span class="math inline">\(f_i\)</span>表示<span class="math inline">\(i\)</span>这个点不会被选的方案数,那Alice对于一条边的定向,会让这条边其中一侧的子树的<span class="math inline">\(f\)</span>整体<span class="math inline">\(+1\)</span>.这个看上去极其熟悉.典中典套路是,考虑两条边选择使得<span class="math inline">\(V_1,V_2\)</span>分别加了<span class="math inline">\(1\)</span>,如果<span class="math inline">\(V_1\cap
V_2=\empty\)</span>,同时取反这两条边的选择,一定不劣.于是选择的边会让加<span class="math inline">\(1\)</span>的点集两两有交.枚举交集中的一个点<span class="math inline">\(x\)</span>,则所有边的选择全部确定:每条边都选择深度较低的那个点.仔细考虑此时,Bob的最优选择是啥.如果Bob选择了一个点<span class="math inline">\(y\)</span>,那么<span class="math inline">\(f_y\)</span>显然是<span class="math inline">\(f_x\)</span>减去<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>的路径上Alice能选的数量加上Alice只有一种选择,并且在这里为反向选择的数量.我们要最大化这个东西,也就是最小化<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>的路径上Alice能选的数量,其实也就是最小化一棵树的深度,这个是方便dp的.</li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF235D</p>
<p>这个形式看上去极其复杂,考虑简单化一下:我们考虑对当前图选一个分治中心,对答案的贡献是<span class="math inline">\(|G|\)</span>,不难发现,这相当于每个点贡献了一次.进一步地,这等价于对于每个点,判断它会在多少个点作为分治重心的时候,仍然在那个点所在的连通块中.</p>
<p>如果原图是树,这等价于对于<span class="math inline">\(u,v\)</span>,<span class="math inline">\(u\)</span>是<span class="math inline">\((u,v)\)</span>路径上第一个被删除的点的概率,这等价于<span class="math inline">\(\frac{1}{len}\)</span>.这样树的情况就做完了.</p>
<p>考虑基环树怎么做:如果两个点<span class="math inline">\((u,v)\)</span>之间路径唯一,那上面做的显然还是对的.反之,我们有公式<span class="math inline">\(P(A\or B)=P(A)+P(B)-P(A\and
B)\)</span>,因此你把这两条路径求出来,加起来,减去它们同时发生的概率即可.注意同时发生的概率不是<span class="math inline">\(P(A)P(B)\)</span>,因为这两件事不独立,事实上应该是这两条路径的点集并的大小分之一.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4429</p>
<p>如果图不连通可以对于每个块分开考虑,下面只考虑图连通的情况:</p>
<p>显然,如果图不是二分图一定无解.</p>
<p>其次,我们注意到孤立点和一度点一定都可以删去,前者显然,后者是因为与它相邻的那个点的颜色如果确定,那它一定有一种和它选不一样的方法.这样当前所有点的度数<span class="math inline">\(\geq 2\)</span>.</p>
<p>接下来,青鱼说得好,我们把很多比较能看出来有解的情况判掉,剩下的就是无解.</p>
<ol type="1">
<li>偶环一定有解.</li>
</ol>
<p>如果偶环上的颜色全都一样,那直接二分图染色.不然,一定存在相邻的两个点<span class="math inline">\(x,y\)</span>使得<span class="math inline">\(x\)</span>有一种颜色,<span class="math inline">\(y\)</span>没有,直接让<span class="math inline">\(x\)</span>染这种颜色,<span class="math inline">\(x-y\)</span>这条边就没用了,断掉,然后顺着<span class="math inline">\(x\)</span>平推过去,一定有解.</p>
<p>妈的,剩下的不会了,先咕着.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1672G</p>
<p>发现个事情:如果当前所有行和所有列的异或值都是<span class="math inline">\(0\)</span>,那么我们可以每次选取四个点然后点击,这样这四个点会改变,而其它点都不改变,从左上开始一直点相邻的四个点,这样最后左上角的<span class="math inline">\((n-1)(m-1)\)</span>的矩阵就全空,而由于每行每列<span class="math inline">\(1\)</span>的个数都是偶数,这个过程不改变这个性质,因此最后一定全图是空的.</p>
<p>而由于最后的状态是全空,因此在变化过程中总有一个时刻使得每行每列异或值为<span class="math inline">\(0\)</span>.</p>
<p>考虑异或的过程,如果<span class="math inline">\(n\)</span>是偶数,那么这么一次异或会使得除了一列以外的所有列都异或上<span class="math inline">\(1\)</span>.如果<span class="math inline">\(n\)</span>是奇数,则会使得全局异或上<span class="math inline">\(1\)</span>.</p>
<p>现在我们来讨论一下<span class="math inline">\(n,m\)</span>的奇偶性(对称情况可以反转,不讨论):</p>
<ol type="1">
<li><span class="math inline">\(n,m\)</span>均为偶数.只考虑第一行,从第二列开始,如果当前这一列和第一列不一样就把它操作掉.这样最后所有列的异或值都相同.如果最后是全<span class="math inline">\(1\)</span>,我们把第一行轮着点一遍,这样每一列都被点了<span class="math inline">\(m-1\)</span>次,而行的奇偶性不变.也就是说,此时无论怎么填都是有解的.行再一样做</li>
<li><span class="math inline">\(n\)</span>是奇数,<span class="math inline">\(m\)</span>是偶数.此时必须要求所有列的异或值相同.每一行如何做可以(1)一样使得每一行异或值都是<span class="math inline">\(0\)</span>.枚举所有列是<span class="math inline">\(0\)</span>还是是<span class="math inline">\(1\)</span>,留一个?来调整,剩下的?随便选.</li>
<li>都是奇数,此时要求所有行和所有列的奇偶性分别相同.枚举这四种奇偶性情况,然后将<span class="math inline">\(?\)</span>看成连在横坐标和纵坐标之间的边.那也就相当于确定了每个点的度数,然后问有多少种选边方式.典中典.对于每个连通块,求出一棵生成树,然后剩下的边随便选,用生成树一路调整上去.注意这要求所有点的度数之和是偶数,也就是至少得是一张合法的图.</li>
</ol>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc117_f</p>
<p>考虑求出前缀和,此时要满足条件,不妨设全局和为<span class="math inline">\(x\)</span>,此时必然有: <span class="math display">\[
\forall 0\leq i&lt;n,s_{i+n}-s_i\geq a_i\\
\forall n\leq i&lt;2n,x-(s_{i}-s_{i-n})\geq a_i,s_i-s_{i-n}\leq x-a_i\\
\forall 0\leq i&lt;2n,s_i\leq s_{i+1}
\]</span> 注意上面的限制条件限制住了<span class="math inline">\(s_{i+n}-s_{i}\)</span>的上下界,我们不妨设它的上下界分别为<span class="math inline">\(l\)</span>和<span class="math inline">\(r\)</span>.但是这俩需要知道<span class="math inline">\(x\)</span>才能求出来,于是不妨二分<span class="math inline">\(x\)</span>.</p>
<p>贪心地构造,考虑每次要求<span class="math inline">\(s_{i+n}\)</span>尽可能地小,于是如果<span class="math inline">\(l_i\leq s_{i-1+n}-s_{i-1}\leq
r_i\)</span>,我们就继承前面的答案.反之,如果<span class="math inline">\(l_i&gt;s_{i-1+n}-s_{i-1}\)</span>,我们就提升<span class="math inline">\(s_{i+n}=s_{i-1}+l_i\)</span>,<span class="math inline">\(r\)</span>同理.这样走到最后一定是最小的,只需要满足<span class="math inline">\(s_{n-1}\leq s_n\and s_{2n-1}\leq
x\)</span>即可.</p>
<p>但是你发现个事情,我们前面一直在保证<span class="math inline">\(s\)</span>尽可能小,却没有保证<span class="math inline">\(s_{n-1}\leq s_n\)</span>.我们怎么处理这里的<span class="math inline">\(s_n\)</span>呢?考虑再次二分,每次找到最小的<span class="math inline">\(s_n\)</span>满足前一个条件.那我们就需要说明两件事情:</p>
<ol type="1">
<li>满足前一个条件的<span class="math inline">\(s_n\)</span>满足单调性.</li>
<li><span class="math inline">\(s_n\)</span>越小,越有可能满足第二个条件.</li>
</ol>
<p>先来说(2),这个比较显然.因为如果<span class="math inline">\(s_n\)</span>在前面较小不满足的话,我们可以在后面某个地方给提升得大一点,显然由于<span class="math inline">\(s_n\)</span>的提升比较自由,这个是可以做到的.</p>
<p>再来看(1),如果一个<span class="math inline">\(s_n\)</span>满足条件,我们把这个<span class="math inline">\(s_n\)</span>增大<span class="math inline">\(1\)</span>.考虑将前面的所有<span class="math inline">\(s_{0\cdots n-1}\)</span>全部提升<span class="math inline">\(1\)</span>,这样所有的差都不变,因此仍然满足条件.</p>
<p>冷静总结一下这个题,其实就是我们首先要发现很多可二分的性质:</p>
<ol type="1">
<li><span class="math inline">\(s_{2n}\)</span>可二分.</li>
</ol>
<p>这个是显然的,放更多显然不会更劣.但是我们要在这个基础上找到一种方法,使得如果当前二分的值合法,一定能构造出一组答案.我们发现如果没有<span class="math inline">\(s_{n}\geq
s_{n-1}\)</span>这个限制,一切都是好做的:因为我们可以贪心地使得当前的<span class="math inline">\(s\)</span>最小.</p>
<ol start="2" type="1">
<li><span class="math inline">\(s_n\)</span>可二分.</li>
</ol>
<p>这个是怎么发现的呢?因为我们发现我们勒令<span class="math inline">\(s_n\)</span>是啥,似乎对这个贪心过程没有啥影响.如果<span class="math inline">\(s_n\)</span>过小,上面的贪心过程就会在<span class="math inline">\(s_n\geq s_{n-1}\)</span>这里判出错.如果<span class="math inline">\(s_n\)</span>过大,则会在<span class="math inline">\(s_{2n-1}\leq s_{2n}\)</span>上判错.这意味着<span class="math inline">\(s_n\)</span>可能需要是一个区间才合法.接下来就是去证明它确实是一个区间是合法的,并且证明我们的贪心过程能在这个贪心过程中正确地check.</p>
<h3><span id="线性代数">线性代数</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1224</p>
<p>首先显然的一点是,我们把它搞成一个矩阵<span class="math inline">\(A\)</span>,然后拿<span class="math inline">\(A\times
A^T\)</span>.注意到如果最后的答案矩阵存在<span class="math inline">\(0\)</span>就有解,这个解就是<span class="math inline">\(B_{i,j}=0\)</span>的那对<span class="math inline">\((i,j)\)</span>.到这里已经可以猜到,这题不是什么正经题,应该要搞一些随机化东西.</p>
<p>想起来之前那个经典判断<span class="math inline">\(A\times
B=C\)</span>的题,就是随机几个向量然后乘起来.这个我们想想能不能类似做.</p>
<p>先考虑<span class="math inline">\(k=2\)</span>,如果<span class="math inline">\(A\times A^T\)</span>是全<span class="math inline">\(1\)</span>矩阵,那么我们随机一个向量去乘它,得到的向量每一位必然都是这个向量所有数字之和.不难发现如果这个向量每一位差别足够大就可以check,这就提供了一个<span class="math inline">\(O(nd)\)</span>的做法,不过我们实现肯定造不出差别足够大的向量,因此可以多check几次.然后如果第<span class="math inline">\(i\)</span>行不满足条件,一定存在一组<span class="math inline">\((i,j)\)</span>作为答案,枚举<span class="math inline">\(j\)</span>即可.</p>
<p>再考虑<span class="math inline">\(k=3\)</span>,这个有点难搞.实际上是一个牛逼发现:<span class="math inline">\(1^2\equiv 2^2\equiv 1\pmod
3\)</span>.因此我们考虑将<span class="math inline">\(B\)</span>矩阵的每一位平方后与一个向量相乘.考虑<span class="math inline">\(\sum_{j}B_{i,j}^2r_j=\sum_{j}B_{i,j}r_jB^T_{j,i}\)</span>,考虑构造矩阵<span class="math inline">\(R\)</span>,使得<span class="math inline">\(R_{i,i}=r_i,R_{i,j}=0,i\ne
j\)</span>,不难发现<span class="math inline">\((BR)_{i,j}=B_{i,j}R_{j,j}\)</span>,于是<span class="math inline">\((BRB^T)_{i,i}=\sum_{j}B_{i,j}R_{j,j}B^T_{j,i}\)</span>.接下来我们只要check
<span class="math inline">\(BRB^T\)</span>的对角线即可.然后<span class="math inline">\(B^T=(AA^T)^T={A^T}^TA^T=AA^T\)</span>.于是有:
<span class="math display">\[
BRB^T=AA^TRAA^T
\]</span> 考虑<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n\times d\)</span>的矩阵,<span class="math inline">\(A^T\)</span>是一个<span class="math inline">\(d\times
n\)</span>的矩阵.不妨假设我们已经算出了<span class="math inline">\(A^TRA\)</span>,那这里是好算的,因为<span class="math inline">\((ABC)_{i,i}=\sum_{j,k}A_{i,k}B_{k,j}C_{j,i}\)</span>,这里可以<span class="math inline">\(O(nd^2)\)</span>地check每一个位置.</p>
<p>那我们现在面临的问题就是如何去求出来<span class="math inline">\(A^TRA\)</span>.注意到<span class="math inline">\(RA\)</span>是一个<span class="math inline">\(n\times d\)</span>的矩阵,因此如果知道<span class="math inline">\(RA\)</span>,<span class="math inline">\(A^T(RA)\)</span>是好求的.我们现在需要求出<span class="math inline">\(RA\)</span>.由于<span class="math inline">\(R\)</span>是对角线矩阵,<span class="math inline">\((RA)_{i,j}=R_{i,i}A_{i,j}\)</span>,这样就可以<span class="math inline">\(O(nd)\)</span>求.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P6772</p>
<p>典中典,首先如果是边权的话有个经典dp:设<span class="math inline">\(dp_{i,x}\)</span>表示当前经过了<span class="math inline">\(i\)</span>条边,目前在<span class="math inline">\(x\)</span>点的最优答案,自然有转移: <span class="math display">\[
dp_{i,x}=\max\{dp_{i-1,y}+val_{y\rightarrow x}\}
\]</span> 这是一个经典的<span class="math inline">\(\{\max,+\}\)</span>矩阵,可以矩阵加速.</p>
<p>这个题不是边权,但是点权可以改成入边的边权,只不过起点需要特判.</p>
<p>还有一个问题是边权不是<span class="math inline">\(1\)</span>,拆边的话复杂度太高,考虑拆点,每个点拆成五个,然后只有最后一个点才会连出边,剩下的按照距离出边的距离连到前面的点.</p>
<p>至于美食节,一个想法是直接矩阵加速到那一天,然后把对应的点加上美食节的权值,继续做完每个美食节即可.但这样复杂度是<span class="math inline">\(O(kN^3\log T)\)</span>的.</p>
<p>冷静一下,预处理出矩阵的二的次幂,这样就是<span class="math inline">\(O(kN^2\log T+N^3\log T)\)</span>.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6125</p>
<p>简单题,建ACAM,然后对于每个人求答案.枚举每个人,对于每个点,设<span class="math inline">\(p_i\)</span>为以它为起点,最后这个人胜利的概率,做高斯消元即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3706</p>
<p>ps:本题选入笔记:概率与期望-概率生成函数-Example3.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{k,i}\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F,G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><span class="math inline">\(1+xG(x)=\sum_kF_k(x)+G(x)\)</span>.</li>
<li><span class="math inline">\((\frac{1}{2}x)^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=0}^{L-1}(\frac{1}{2}x)^i[A_k^{(L-i)}={A_j}_{(L-i)}]\)</span>.</li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x=1\)</span>,发现<span class="math inline">\(\sum_{k}F_k(1)=1\)</span>.</p>
<p>把(2)化简一下,有: <span class="math display">\[
x^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=0}^{L-1}(\frac{1}{2}x)^{i-L}[A_k^{(L-i)}={A_j}_{(L-i)}]\\
x^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=1}^{L}(\frac{1}{2}x)^{-i}[A_k^{(i)}={A_j}_{(i)}]
\]</span> 带入<span class="math inline">\(x=1\)</span>,有: <span class="math display">\[
G(1)=\sum_{j=1}^nF_j(1)\sum_{i=1}^{L}2^i[A_k^{(i)}={A_j}_{(i)}]
\]</span> 不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n+1\)</span>个等式,可以算出<span class="math inline">\(G(1),F_{1\cdots n}(1)\)</span>这<span class="math inline">\(n+1\)</span>个未知数.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3292</p>
<p>首先第一反应是树剖+线段树上合并线性基,轻松做到<span class="math inline">\(O(q\log^2 n\log^2 v)\)</span>.</p>
<p>但是过不太去!注意到<span class="math inline">\(n\)</span>要小一点,考虑离线点分治.记录下从分治中心到每个点的线性基,这样只需要做<span class="math inline">\(q\)</span>次线性基合并,复杂度是<span class="math inline">\(O(q\log^2v+n\log n\log v)\)</span>.</p>
<p>不过如果你做过CF1100F,那这题就是上个树.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4151</p>
<p>典中典,注意到一个值异或两遍就会没掉.我们考虑随便求一条<span class="math inline">\(S\rightarrow
T\)</span>的路径,然后再求出来所有的环上的异或值.我们发现我们可以走到一个简单环上,走一圈再原路返回,这样答案只会异或上简单环的异或值.对这个东西用线性基就行.</p>
<p>至于这个东西的正确性,首先考虑<span class="math inline">\(S\rightarrow
T\)</span>唯一的情况,这样的话你如果要扩展就必须走环.不然,则<span class="math inline">\(S\rightarrow
T\)</span>有边在环上,只要溜达一圈就行.</p>
<p>接下来的问题在于找简单环.我们直接dfs,就可以找到一部分环.但是其实是没有找到全部的环的.但是没关系,在dfs的过程中,dfs树不可能有横插边,也就是所有找到的的环不在树上的边一定是反走边.而没有找到的环可能是若干个反走边拼起来的.这必然意味着它可以由那些反走边所代表的环拼起来:原因比较简单,考虑从上往下遍历这个没找到的环,那么每条边一定被经过了两次:下去一次,上来一次.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P6178</p>
<p>板子题</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P4455</p>
<p>板子题</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4336</p>
<p>简单题,无脑矩阵树定理+容斥.复杂度<span class="math inline">\(O(2^nn^3)\)</span>.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P5807</p>
<p>板子题</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF917D</p>
<p>一眼二项式反演.不妨设<span class="math inline">\(f_i\)</span>表示钦定<span class="math inline">\(i\)</span>条边已经选上了的答案.显然: <span class="math display">\[
ans_k=\sum_{i\geq k}(-1)^{i-k}\binom{i}{k}f_i
\]</span> 对于<span class="math inline">\(f_i\)</span>,考虑Prufer序列的推论:<span class="math inline">\(k\)</span>个大小分别为<span class="math inline">\(s_1,s_2,\cdots,s_k\)</span>的连通块,任意加边使得连通块成树的方案数是<span class="math inline">\(n^{k-2}\prod s\)</span>.于是考虑dp,不妨设<span class="math inline">\(dp_{x,i,j}\)</span>表示当前<span class="math inline">\(x\)</span>为根的子树内部,当前<span class="math inline">\(x\)</span>所在连通块的大小是<span class="math inline">\(i\)</span>的方案数,这样可以做到<span class="math inline">\(O(n^3)\)</span>.</p>
<p>看了看题解发现可以做到<span class="math inline">\(O(n^2)\)</span>.简单来说就是考虑<span class="math inline">\(\prod
s\)</span>的组合意义,是在每个连通块内选一个点的方案数.那我们可以用<span class="math inline">\(f_{i,j,0/1}\)</span>表示当前<span class="math inline">\(i\)</span>子树内选了<span class="math inline">\(j\)</span>个点,然后<span class="math inline">\(i\)</span>所在连通块内是否选点了的方案数.</p>
<h3><span id="计算几何">计算几何</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2742</p>
<p>板子题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3829</p>
<p>简单题,注意到圆弧之和一定是一个圆,因此把角上的四个点拿出来做凸包即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4196</p>
<p>板子题.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3256</p>
<p>板子题.甚至</p>
<h4><span id="第五题第六题第七题">第五题/第六题/第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P1742</p>
<p>https://www.luogu.com.cn/problem/P2533</p>
<p>https://www.luogu.com.cn/problem/P4288</p>
<p>三个题全是一样的.</p>
<p>大概是这么做的啊,就是说我们增量构造,每次对于前<span class="math inline">\(i\)</span>个点的最小覆盖圆,考虑<span class="math inline">\(i+1\)</span>个点在不在圆上.如果在就忽略,不在的话,那它必然是新圆的一个卡着边的点.考虑再找到另两个卡着边的点,我们暴力枚举这两个点.并且计算出所有的圆,挑选面积最大的那个.事实上,可以直接每次更新圆,直到这个圆包含了前<span class="math inline">\(i+1\)</span>个点,显然总会遇到,然后之后就不会更新这个圆了.</p>
<p>这个写法导致了复杂度正确.具体来说,考虑一个点成为卡着圆边界的点的概率是<span class="math inline">\(\frac{3}{n}\)</span>,这三层循环的调用次数分别是:
<span class="math display">\[
T_3(n)=O(n)\\
T_2(n)=O(n)+\sum_{i=1}^n\frac{3}{i}T_3(i)\\
T_1(n)=O(n)+\sum_{i=1}^n\frac{3}{i}T_2(n)
\]</span> 显然<span class="math inline">\(T_1(n)=O(n)\)</span>.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P2287</p>
<p>枚举三个点,然后判断这三个点所在平面是否是三维凸包的一个面.注意四点共面就完蛋了,因此每个点加上一个随机扰动量.这个量首先得在eps范围内显著体现出来,其次还不能对答案影响太大.这个题是直接给了一个小于<span class="math inline">\(10^{-10}\)</span>的扰动量,然后因为没有判相等操作,直接用了c++的浮点数比较.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P1452</p>
<p>板子题.</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6247</p>
<p>板子题.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3187</p>
<p>旋转卡壳的时候维护三个边界就行.</p>
<h3><span id="网络流建图">网络流建图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>Hall引理的时候做过.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF311E</p>
<p>发现变<span class="math inline">\(0\)</span>变<span class="math inline">\(1\)</span>这个操作可逆,不妨先把所有位置都变成<span class="math inline">\(1\)</span>.</p>
<p>接下来考虑把若干个<span class="math inline">\(1\)</span>变成<span class="math inline">\(0\)</span>.不难发现:一个全<span class="math inline">\(0\)</span>的要求合法$$所有包含位置都是<span class="math inline">\(0\)</span><span class="math inline">\(\Leftrightarrow\)</span>所有包含位置都不是<span class="math inline">\(1\)</span>$$包含这些的全<span class="math inline">\(1\)</span>要求不合法.这是一个最大权闭合子图问题.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF884F</p>
<p>直接费用流,考虑左边每个点是字母,然后连到右边的点上,拆一下点保证对应的位置不会有相同字母.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF802C</p>
<p>牛逼题,考虑我们不好搞这个丢弃的东西,因为你也不知道你留下来的是谁.因此我们考虑如果一本书不在当天丢弃,那就一定会对下本书产生贡献,我们把它当成将书卖出.</p>
<p>也就是说,考虑将每一天建点,上面这个过程保证了我们每一天的书都会买,这就保证了最大流量.</p>
<p>将每一天建点并以流量为<span class="math inline">\(k-1\)</span>的边相连(因为下一天必须买书),然后如果这本书要留着,就在前一天卖掉.</p>
<p>但是这样需要保证,我们卖书的时候必定在前面没有丢弃这本书,拆点维护,用一个点同时维护当天丢弃和卖书两种操作即可.</p>
<p>点数是<span class="math inline">\(2n\)</span>的,边数有拆点的<span class="math inline">\(n\)</span>条,连接相邻两天的<span class="math inline">\(n\)</span>条,卖出的和丢弃的共<span class="math inline">\(2n\)</span>条,这样总共是<span class="math inline">\(4n\)</span>条边.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF786E</p>
<p>一眼最小割,然后线段树+树剖优化建图.注意这样是<span class="math inline">\(O(n\log
^2n)\)</span>的建图,我们把树剖跳topn的过程建一个点,这样就是<span class="math inline">\(O(n\log n)\)</span>的建图.</p>
<p>考虑点数,原图有<span class="math inline">\(n\)</span>个点,线段树是<span class="math inline">\(2n\)</span>个点,树剖只会贡献<span class="math inline">\(n\)</span>个点,点数是<span class="math inline">\(4n\)</span>的.</p>
<p>考虑边数,注意到一个点会连<span class="math inline">\(2\log
n\)</span>条边到树剖上,在最后一下会连<span class="math inline">\(\log
n\)</span>个点到线段树上,因此总边数是<span class="math inline">\(2n+3m\log n\leq
10^6\)</span>,但是显然远远跑不满.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1139E</p>
<p>第一反应是二分答案,然后拿网络流二分图匹配check,这样复杂度是<span class="math inline">\(O(n^2\sqrt n\log n)\)</span>的.</p>
<p>事实上注意删人后答案只减不增,因此复杂度<span class="math inline">\(O(n^2\sqrt n)\)</span>.</p>
<p>但是这样过不去,考虑把删除改成增加,这样就可以在残留网络上跑,然后就能过了.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1061E</p>
<p>考虑每个问题,其实是形如要保证子树内有一定数量的点不能选.也就是这个限制要和修建港口抢城市.</p>
<p>但是不同的限制可能限制了同一城市,我们发现深度更浅的那个限制数量可以减去深度较深的限制数量,毕竟较深的满足较浅的也就满足了.</p>
<p>但是这个思路建图好像有点不太对.因为两个树的港口是通用的,那考虑让一个限制是入,另一个限制是出.换句话说,让一个限制被源点流,另一个限制流向汇点,中间是树节点,源点连出去的边有一个权值,跑费用流.</p>
<p>注意到每个点只会被连一次,因此边数大概是<span class="math inline">\(2n\)</span>级别,点数是<span class="math inline">\(3n\)</span>级别.</p>
<p>总之这种网络流题,主要还是要考虑谁连着源点,谁连着汇点.这个题我一开始以为是限制连源点,然后城市连汇点,发现做不了,那就两种限制分别连源点和汇点.</p>
<h3><span id="交互题练习">交互题练习</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5875</p>
<p>这是广义串并联图嘛?好像显然不是.</p>
<p>但是仍然有性质,如果没有点权的话,注意到(1)一定会选新加入的点,(3)也一定会选新加入的点,(2)则一定要么两者都选要么都不选.</p>
<p>现在有点权,考虑把新加入的点删了,不妨设新加入的点为<span class="math inline">\(i\)</span>,主持人为<span class="math inline">\(x\)</span>,自然有:</p>
<ol type="1">
<li><span class="math inline">\(a_i\rightarrow
ans,a_x:=\max\{0,a_x-a_i\}\)</span>.</li>
<li><span class="math inline">\(a_x:=a_x+a_i\)</span>.</li>
<li><span class="math inline">\(a_x:=\max\{a_x,a_i\}\)</span>.</li>
</ol>
<p>不难发现每一步操作做完后,答案都不会改变.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3641</p>
<p>牛逼题.</p>
<p>考虑答案最小是什么,根据鸽笼原理,显然是<span class="math inline">\(B=\lceil\frac{a_n-a_1}{n-1}\rceil\)</span>.</p>
<p>所以我们按照值域每<span class="math inline">\(B\)</span>长度分块,然后考虑答案不可能出现在块内,也就是块内的点对不可能贡献答案,答案只有可能由上一个数字(也就是上一个查询到的<span class="math inline">\(mx\)</span>)和当前块的<span class="math inline">\(mn\)</span>贡献.这样一开始的贡献是<span class="math inline">\(n+1\)</span>,中间问了<span class="math inline">\(n-1\)</span>次,总共涉及到了<span class="math inline">\(n-2\)</span>个数字,这样就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3777</p>
<h5><span id="sub1">Sub1</span></h5>
<p>minValue是好求的,我们考虑选取<span class="math inline">\(\{1,0,\cdots,0\}\)</span>,这样的话对手必然放弃一个,被放弃的那个就是最小的.</p>
<h5><span id="sub2">Sub2</span></h5>
<p>一个显然的想法是,如果我们一开始全选<span class="math inline">\(1\)</span>,那么对手一定会选取<span class="math inline">\([51,100]\)</span>中的所有数字.</p>
<p>然后呢?我们接下来考虑继续在<span class="math inline">\([51,100]\)</span>这些数字中找到最大的.我们肯定要让它们全选<span class="math inline">\(2\)</span>,这样对方可能会放弃一些这个区间中较小的数字,然后去选取<span class="math inline">\([1,50]\)</span>中较大的一些.持续这个过程,发现正好需要四次操作.</p>
<h5><span id="sub3">Sub3</span></h5>
<p>考虑结合sub1和sub2,我们不妨询问<span class="math inline">\(\{x,x,0,0,\cdots\}\)</span>,这样直觉上总是存在一个<span class="math inline">\(x\)</span>使得前两个数字有一个被放弃.</p>
<p>事实上也确实.考虑前两个数字中较小的那一个,设为<span class="math inline">\(v\)</span>,当<span class="math inline">\(\sum_{i=x}^{2x}i=\frac{3x(x+1)}{2}\geq
v\)</span>的时候,显然它就会被放弃,对于这个最小的<span class="math inline">\(x\)</span>,会发现两个数字中较大的那个(设为<span class="math inline">\(w)\)</span>一定不会被放弃,因为如果它被放弃了,一定是因为<span class="math inline">\(w\leq x-1\)</span>,而我们知道<span class="math inline">\(\frac{(3x-3)x}{2}&lt;v&lt; w\leq
x-1\)</span>,又因为<span class="math inline">\(x\geq
1\)</span>,因此显然不成立.</p>
<p>二分这个<span class="math inline">\(x\)</span>,由于<span class="math inline">\(v_{\max}=99\)</span>,发现<span class="math inline">\(x\in[1,8]\)</span>,直接二分需要四次.</p>
<p>然后有个牛逼做法是,考虑每个<span class="math inline">\(x\)</span>能控制一个区间的<span class="math inline">\(v\)</span>,发现<span class="math inline">\(x=7\)</span>的那个区间全部被覆盖了两次,因此不用选取<span class="math inline">\(x=7\)</span>.</p>
<h5><span id="sub4">Sub4</span></h5>
<p>这个简单,不难发现只需要在<span class="math inline">\(B_i=B_j=100\)</span>,那么对手就必然需要在这两者中选一个留下来,这样我们就可以比较任意两个位置的大小,使用stable_sort即可.</p>
<h5><span id="sub5">Sub5</span></h5>
<p>一种想法是sub4+sub3,但过不去.</p>
<p>冷静思考,注意到sub2,我们其实是知道了某些位置在哪个权值区间的.对着这个分治下去,这样实现了划分区间的功能,按理说应该是会有<span class="math inline">\(2n-1\)</span>个节点.</p>
<p>冷静一下,<span class="math inline">\(l=r\)</span>的叶子节点是不用计算的,因此刚好玩了<span class="math inline">\(n-1\)</span>次.</p>
<p>现在唯一的问题是,我们怎么找到一个<span class="math inline">\(w\)</span>,使得这个区间内我都选<span class="math inline">\(w\)</span>后,然后这个区间一定会被划分呢?考虑<span class="math inline">\(sub3\)</span>告诉我们如果<span class="math inline">\(r-l+1\leq 12\)</span>一定有解,考虑<span class="math inline">\((r,100]\)</span>的数字肯定要被选,那对方只剩下<span class="math inline">\(r\)</span>个石子,不妨直接令<span class="math inline">\(w=\lfloor\frac{r}{r-l+1}\rfloor+1\)</span>,注意到这个区间一定选不满.并且由于<span class="math inline">\(r-l+1&gt;12\)</span>,因此你会发现前面即使全选了也有剩余.</p>
<p>实际的写法选择了直接枚举<span class="math inline">\(w\)</span>,然后判断是否合法.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P4373</p>
<p>这怎么做!考虑分块.(这谁想得到啊)</p>
<p>不妨设<span class="math inline">\(f_i\)</span>表示<span class="math inline">\([i,i+k-1]\)</span>的最小值,我们先求出来<span class="math inline">\(f_{0},f_{B},f_{2B},\cdots\)</span>的值.这个怎么求呢?考虑一个值什么时候有用:如果它比队列末尾优秀肯定有用,不然只有它是<span class="math inline">\(B\)</span>的倍数,它才有可能有用.我们只去维护这两种情况,就可以做到<span class="math inline">\(O(\sqrt n)\)</span>的空间.</p>
<p>然后考虑剩下的<span class="math inline">\((iB,(i+1)B)\)</span>这些答案怎么求.不难发现这些的<span class="math inline">\(f\)</span>一定大于等于<span class="math inline">\(f_{iB}\)</span>并且小于等于<span class="math inline">\(f_{(i+1)B}\)</span>.如果直接对这个做单调队列空间还是不足,但我们发现做单调队列的时候,会被弹出的只有<span class="math inline">\([f_{iB},(i+1)B)\)</span>这些数字,剩下的只要右端点卡到它,就一定不会被弹出.因此只需要对前面这个东西做单调队列,直到做到<span class="math inline">\(f_{(i+1)B}\)</span>出现,那我们就停下来,把前面该输出的答案全部输出.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P5473</p>
<p>考虑异或能实现的是判断奇偶性,具体来说,我们很容易判断一个点到一个集合内部点的奇偶性.考虑这样其实已经能<span class="math inline">\(O(n)\)</span>找到一个点了:我们每修改一个前缀,然后check所有不在这个前缀内的点,这样就可以知道它俩是有边的.</p>
<p>这个过程能不能二分呢?好像不能,那我们随机化.</p>
<p>换句话说,我们random_shuffle一下序列,然后分治,每次把左侧的点全部点亮,然后看右侧的点有没有发生变化.如果发生了,则说明左侧的点到右侧的点的边的数量是奇数,递归下去处理,就可以至少连一条边,把这条边删了继续做.</p>
<p>然后发现这么写有个<span class="math inline">\(L_c=0\)</span>的<span class="math inline">\(B\)</span>包过不去啊,那个包可以考虑我们对于一个点<span class="math inline">\(x\)</span>,二分<span class="math inline">\([0,x-1]\)</span>中谁是它的父亲.不难发现如果把<span class="math inline">\([0,k]\)</span>这个前缀全部modify掉,并且它父亲在里面,那它当前状态一定是<span class="math inline">\(1\)</span>.用整体二分解决这个问题.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6541</p>
<p>考虑动态点分树.每次找到一对点<span class="math inline">\(x,y\)</span>,<span class="math inline">\(x\)</span>已知,<span class="math inline">\(y\)</span>未知,然后explore(x,y).如果得到的是未知的点,那就不断操作直到得到<span class="math inline">\(y\)</span>.</p>
<p>反之,考虑得到了<span class="math inline">\(z\)</span>,由于<span class="math inline">\(z\)</span>已知,因此<span class="math inline">\(z\)</span>在我们的点分树上.不妨从<span class="math inline">\(z\)</span>暴力向上跳到<span class="math inline">\(x\)</span>,这样就可以知道<span class="math inline">\(y\)</span>在<span class="math inline">\(x\)</span>的哪个方向,往那个方向的点分树儿子走一步即可.</p>
<p>至于动态点分树怎么做,替罪羊重构即可.</p>
<p>至于链,我们每次随机一个没有搞定的点,走过去即可.期望的错误次数是<span class="math inline">\(O(\log n)\)</span>的.</p>
<h3><span id="模拟退火">模拟退火</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2503</p>
<p>考虑如果要求有序划分,可以直接写一个dp.</p>
<p>因此我们考虑每次交换几个位置,然后当成有序的跑dp,用这个来模拟退火.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2538</p>
<p>随机交换两个城市的状态即可.如果为了复杂度更好一点可以要求交换的城市状态必然不同.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5544</p>
<p>这题退火退半天退不出来,但是爬山直接过了.</p>
<p>这是为啥呢?原因在于,这题我们既然要对坐标进行跳跃,很有可能大部分坐标的答案都是<span class="math inline">\(0\)</span>.这就必然导致了我们一开始可能跳到了很远的地方,但是由于一直是<span class="math inline">\(0\)</span>,因此不断地跳过去.很难蚌.</p>
<p>而爬山不会有这种问题.</p>
<p>有没有什么改良的方式?一种是改变估价函数,通过精细实现估价函数导致其估价为连续实数函数,这样退火的效果就会好很多.</p>
<p>总的来说,退火失败的地方在于它一开始跳跃得太远了.而由于前几次操作我们跳出去的概率很大,因此极难得到答案.对于这种跳跃性不确定的题,反而你发现爬山不会拘束于局部最优解,而是会跳出去的.这也就是爬山在这题表现极其良好的原因.</p>
<p>有没有什么更优秀的方式呢?我们考虑先爬几次山,爬到一个好地方,然后以这个位置开始退火往旁边跳.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P7218</p>
<p>考虑一个显然的贪心是,直接枚举每个<span class="math inline">\(W\)</span>,能放就放.</p>
<p>考虑把一开始所有能放的<span class="math inline">\(W\)</span>全拿出来作为一个操作序列,然后用模拟退火打乱.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1105E</p>
<p>不妨考虑满足某个人要求,就一定要在一段时间内全是它的id.也就是说如果两个人都抢了一段时间,那这两个人不能同时选择.</p>
<p>这也就是一个最大团问题,模拟退火解决一下.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计实习</title>
    <url>/2025/02/19/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#随机化算法">随机化算法</a>
<ul>
<li><a href="#基本分析">基本分析</a>
<ul>
<li><a href="#union-bound">Union Bound</a></li>
<li><a href="#markov-不等式">Markov 不等式</a>
<ul>
<li><a href="#examplemax-cut算法">Example(Max-Cut算法)</a></li>
</ul></li>
<li><a href="#chernoff-bound">Chernoff Bound</a>
<ul>
<li><a href="#examplemedian-trick">Example(Median Trick)</a></li>
</ul></li>
<li><a href="#hoeffding-不等式">Hoeffding 不等式</a></li>
</ul></li>
<li><a href="#编程中的随机性">编程中的随机性</a></li>
<li><a href="#数值概率算法">数值概率算法</a></li>
<li><a href="#monte-carlo算法">Monte Carlo算法</a>
<ul>
<li><a href="#求解最优化问题的monte-carlo算法">求解最优化问题的Monte
Carlo算法</a></li>
<li><a href="#求解判定性问题的monte-carlo算法">求解判定性问题的Monte
Carlo算法</a></li>
<li><a href="#正确率与复杂度">正确率与复杂度</a></li>
<li><a href="#算法设计思路1">算法设计思路1</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#算法设计思路2">算法设计思路2</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法-1">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度-1">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example-1millar-rabin算法">Example
1(Millar-Rabin算法)</a></li>
<li><a href="#example2codechef-mstone">Example2(CodeChef
MSTONE)</a></li>
<li><a href="#example3cf364d-ghd">Example3(CF364D Ghd)</a></li>
<li><a href="#example4poi2014couriers">Example4([POI2014]Couriers)</a></li>
</ul></li>
<li><a href="#example5noi2013-向量内积">Example5([NOI2013]
向量内积)</a></li>
</ul></li>
<li><a href="#las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</a>
<ul>
<li><a href="#算法设计思路">算法设计思路</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法-2">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度-2">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#example-1">Example</a>
<ul>
<li><a href="#快速排序算法">快速排序算法</a></li>
<li><a href="#一类由monte-carlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</a></li>
<li><a href="#example3cf329c-graph-reconstruction">Example3(CF329C Graph
Reconstruction)</a></li>
<li><a href="#example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</a></li>
</ul></li>
</ul></li>
<li><a href="#爬山与模拟退火">爬山与模拟退火</a>
<ul>
<li><a href="#爬山">爬山</a></li>
<li><a href="#模拟退火">模拟退火</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2>
<h3><span id="基本分析">基本分析</span></h3>
<h4><span id="union-bound">Union Bound</span></h4>
<p>即:<span class="math inline">\(Pr[\bigcup_i X_i]\leq \sum
Pr[X_i]\)</span>,取等当且仅当所有<span class="math inline">\(X_i\)</span>互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4>
<p>若<span class="math inline">\(X\geq 0\)</span>,则<span class="math inline">\(Pr[X\geq t\mathbb E[X]]\leq
\frac{1}{t}\)</span>.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6>
<p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有<span class="math inline">\(\frac{1}{2}\)</span>的概率是割边,因此期望自然是<span class="math inline">\(\frac{1}{2}|E|\geq
\frac{1}{2}|\text{max-cut}|\)</span>.</p>
<p>由此立即见到,<span class="math inline">\(Pr[|ans|\leq
(\frac{1}{2}-\epsilon)|E|]=Pr[|E|-|ans|\geq
(\frac{1}{2}+\epsilon)|E|]\leq \frac{1}{1+2\epsilon}\)</span>.</p>
<p>由于每次独立操作,因此如果有<span class="math inline">\(P\)</span>的概率失败,那么运行<span class="math inline">\(T\)</span>次后至少成功一次的概率应当为<span class="math inline">\(1-P^T\)</span>.从而<span class="math inline">\(T=O(\log_P{\delta})=O(\cfrac{\ln
\frac{1}{\delta}}{\ln (1+{2\epsilon})})\approx O(\cfrac{\ln
\frac{1}{\delta}}{\epsilon})\)</span>即可拿到<span class="math inline">\(\delta\)</span>失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>设<span class="math inline">\(X_1,\cdots,X_n\in
[0,1]\)</span>是独立,同期望(期望为<span class="math inline">\(\mu\geq
t\)</span>)的随机变量,令<span class="math inline">\(X=\frac{\sum_k
X_k}{n}\)</span>,对于任何失败概率<span class="math inline">\(\delta \in
(0,1)\)</span>,应当有: <span class="math display">\[
Pr\left[|X-\mu|\geq \sqrt{\cfrac{\log(1/\delta)}{nt}}\mu\right]\leq
\delta
\]</span></p>
<h6><span id="examplemedian-trick">Example(Median Trick)</span></h6>
<p>现在有一个黑盒能够以<span class="math inline">\(p&gt;\frac{1}{2}\)</span>的概率正确回答Yes或者No,问重复<span class="math inline">\(T\)</span>选多少次能拿到<span class="math inline">\(1-\delta\)</span>的成功概率.</p>
<p>考虑重复<span class="math inline">\(T\)</span>次后应当有期望<span class="math inline">\(pT\)</span>个正确答案,因此直接取中位数.称此算法为Median
Trick.</p>
<p>Chernoff Bound 告诉我们<span class="math inline">\(T=O(\log
\frac{1}{\delta})\)</span>足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4>
<p>设独立随机变量<span class="math inline">\(x_1,\cdots,x_m\in
[s,t]\)</span>,令<span class="math inline">\(X=\sum_i x_i\)</span>,则:
<span class="math display">\[
Pr[X-E[X]\geq z]\leq 2\exp\left(-\cfrac{2z^2}{m(t-s)^2}\right)
\]</span></p>
<h3><span id="编程中的随机性">编程中的随机性</span></h3>
<p>一般采用伪随机,也即是给定初值<span class="math inline">\(X_0\)</span>,通过某个确定性的函数来生成<span class="math inline">\(X_{n+1}=f(X_n)\)</span>这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</li>
<li>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</li>
<li>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O(f(n))\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1-(1-p)^k\)</span>,时间复杂度为<span class="math inline">\(O(kf(n))\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要枚举一些元素.</li>
<li>设这个算法的复杂度为<span class="math inline">\(O(f(n)g(n))\)</span>,其中<span class="math inline">\(f(n)\)</span>为枚举部分的复杂度,<span class="math inline">\(g(n)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g(n)\)</span>不会很大.</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机化寻找元素来降低复杂度.</li>
<li>计算随机化情况下的正确率以及复杂度.</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要用到一个或多个传入的元素.</li>
<li>这个元素的值不应该依赖于输入数据.</li>
<li>我们可以通过check这个元素来得到与答案有关的信息.</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机这个元素.</li>
<li>计算随机化情况下的正确率以及复杂度</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n\leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O(n^3)\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil\frac{n}{7}\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{1}{7}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{1}{49}\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1-(\frac{48}{49})^{1000}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{n}{2}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n\leq
10^6\)</span>,<span class="math inline">\(a_i\leq 10^{12}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{1}{2}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O(n\sqrt a)\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt
a\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([l,r]\)</span>,问<span class="math inline">\(a[l,r]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\((n,m\leq 500000,1\leq a_i\leq n)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k=2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O(n^2d)\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A=\begin{bmatrix}\vec{a_1},\vec{a_2},...,\vec{a_n}\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B=AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{i,j}\)</span>在<span class="math inline">\(\mod
2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B=C\)</span>,那么对于任意一个<span class="math inline">\(X_{m\times n}\)</span>都应该满足<span class="math inline">\(XB=XC\)</span>,取<span class="math inline">\(m=1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB\ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O(nd)\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O(n)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D=B-C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{i,j}\ne 0\)</span>.我们令<span class="math inline">\(E=X\times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j=\sum_{k}X_kD_{k,j}\)</span>,不难解得:<span class="math inline">\(E_i=-\frac{1}{D_{i,j}}\sum_{k\ne
i}X_kD_{k,j}\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{1}2\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O(nd)\)</span>.</p>
<p><span class="math inline">\(k=3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{j}B_{i,j}^2X_j=\sum_{j}B_{i,j}X_jB_{h,i}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要枚举全排列.</li>
<li>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机化寻找排列来降低复杂度.</li>
<li>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T(n)\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:
<span class="math display">\[
T(0)=0\\
T(n)=n+\frac{1}{n}\sum_{i=0}^{n-1}(T_i+T_{n-i-1})
\]</span> 做放缩(可能有些地方需要<span class="math inline">\(+1\)</span>或者<span class="math inline">\(-1\)</span>或者加取整,但是问题不大,反正是期望):
<span class="math display">\[
T(n)=n+\frac{1}{n}\sum_{i=0}^{n-1}(T_i+T_{n-i-1})\\
=n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{n-1}(T_i+T_{n-i-1})\\
=n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{\frac{3n}{4}}(T(i)+T(n-i-1))+\frac{2}{n}\sum_{i=\frac{3n}{4}}^{n}(T(i)+T(n-i-1))
\]</span> 由于<span class="math inline">\(T(n)\geq
n\)</span>,所以对于<span class="math inline">\(\frac{n}2\leq i\leq
j\)</span>,我们显然有:<span class="math inline">\(T(i)+T(n-i)\leq
T(j)+T(n-j)\)</span>.</p>
<p>因此: <span class="math display">\[
T(n)\leq
n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{\frac{3n}{4}}(T(\frac{3n}{4})+T(\frac{n}{4}))+\frac{2}{n}\sum_{i=\frac{3n}{4}}^{n}(T(n-1)+T(0))\\
\leq n+\frac{1}{2}(T(\frac{3n}{4})+T(\frac{n}{4})+T(n-1))
\]</span> 我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T(n)\leq cn\log n\)</span>,考虑使用数学归纳法,则:
<span class="math display">\[
T(n)\leq
n+\frac{1}2(\frac{3cn}4\log(\frac{3n}{4})+\frac{cn}4\log(\frac{n}{4})+c(n-1)\log(n-1))\\
\leq n+c(\frac{3n}{8}\log n-\frac{3n}{8}\log\frac{4}{3}+\frac{n}{8}\log
n-\frac{n}{4}+\frac{n}{2}\log n)\\
=cn\log n+n(1-\frac{3c}{8}\log(\frac{4}{3})-\frac{c}{4})
\]</span> 于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O(f(n))\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则: <span class="math display">\[
k=\sum_{i=1}^{\infty}p(1-p)^{i-1}i\\
(1-p)k=\sum_{i=1}^{\infty}p(1-p)^ii\\
pk=\sum_{i=2}^{\infty}p(1-p)^{i-1}=p\sum_{i=0}^{\infty}(1-p)^i\\
k=\frac 1 p
\]</span> 则期望复杂度为<span class="math inline">\(O(\frac{f(n)}{p})\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([x_1,x_2)\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1\times 2\leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{1}{2}\)</span>),而此时的<span class="math inline">\([x_1,x_2)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1,2,4,...\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式: <span class="math display">\[
P=\begin{cases}1&amp;E_{t+1}&gt;E_t\\e^{\frac{E_{t+1}-E_t}{T}}&amp;E_{t+1}\leq
E_t\end{cases}
\]</span> 具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k\in(0,1)\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T=kT\)</span>,直到其小于终止温度.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构相关</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#数据结构理论">数据结构理论</a>
<ul>
<li><a href="#维度">维度</a>
<ul>
<li><a href="#b维正交范围">B维正交范围</a></li>
</ul></li>
<li><a href="#矩阵乘法归约">矩阵乘法归约</a>
<ul>
<li><a href="#矩阵乘法">矩阵乘法</a></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example1链颜色数问题">Example1(链颜色数问题)</a></li>
<li><a href="#example2区间逆序对">Example2(区间逆序对)</a></li>
<li><a href="#example3">Example3</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数据结构">数据结构</a>
<ul>
<li><a href="#分块">分块</a>
<ul>
<li><a href="#example1luogup8527-ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</a></li>
<li><a href="#example2luoguynoi2079-riapq">Example2(luogu[Ynoi2079]
riapq)</a></li>
<li><a href="#example3cts2022-普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</a></li>
<li><a href="#example4walking-plan-hdu-6331">Example4(Walking Plan HDU
6331)</a></li>
<li><a href="#example5p5063-ynoi2014-置身天上之森">Example5(P5063
[Ynoi2014] 置身天上之森)</a></li>
<li><a href="#example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</a></li>
</ul></li>
<li><a href="#二次离线">二次离线</a>
<ul>
<li><a href="#example1luogup5047-ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</a></li>
</ul></li>
<li><a href="#二维分块">二维分块</a>
<ul>
<li><a href="#example1luogup7448-ynoi2007-rdiq">Example1(luoguP7448
[Ynoi2007] rdiq)</a></li>
<li><a href="#example2luogup8530-ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</a></li>
</ul></li>
<li><a href="#trie树">trie树</a>
<ul>
<li><a href="#example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</a></li>
</ul></li>
<li><a href="#线段树">线段树</a>
<ul>
<li><a href="#普通线段树">普通线段树</a>
<ul>
<li><a href="#example1luogup6780-ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</a></li>
</ul></li>
<li><a href="#线段树分治">线段树分治</a>
<ul>
<li><a href="#example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</a></li>
</ul></li>
<li><a href="#线段树上二分">线段树上二分</a>
<ul>
<li><a href="#example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#线段树合并">线段树合并</a></li>
<li><a href="#线段树维护矩阵乘法">线段树维护矩阵乘法</a></li>
<li><a href="#吉司机线段树">吉司机线段树</a></li>
<li><a href="#李超线段树">李超线段树</a></li>
</ul></li>
<li><a href="#珂朵莉树">珂朵莉树</a>
<ul>
<li><a href="#example1luogup8512-ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</a></li>
</ul></li>
<li><a href="#猫树">猫树</a></li>
<li><a href="#kd-tree">KD-Tree</a>
<ul>
<li><a href="#1d-tree">1D-Tree</a></li>
<li><a href="#2d-tree">2D-Tree</a></li>
</ul></li>
<li><a href="#笛卡尔树">笛卡尔树</a>
<ul>
<li><a href="#example1cfgym101613factor-free-tree">Example1([CFgym101613]Factor-free
tree)</a></li>
<li><a href="#example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</a></li>
</ul></li>
<li><a href="#单调队列">单调队列</a>
<ul>
<li><a href="#exampleloj3151">Example(loj3151)</a></li>
</ul></li>
<li><a href="#树套树">树套树</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2luogu4054-jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</a></li>
</ul></li>
</ul></li>
<li><a href="#数据结构常见套路">数据结构常见套路</a>
<ul>
<li><a href="#分开考虑">分开考虑</a>
<ul>
<li><a href="#example1p6105-ynoi2010-y-fast-trie">Example1(P6105
[Ynoi2010] y-fast trie)</a></li>
</ul></li>
<li><a href="#合并信息">合并信息</a>
<ul>
<li><a href="#example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</a></li>
<li><a href="#example2p4198-楼房重建">Example2(P4198 楼房重建)</a></li>
<li><a href="#example3cf1017g">Example3(CF1017G)</a></li>
</ul></li>
<li><a href="#去除冗余信息">去除冗余信息</a>
<ul>
<li><a href="#example1luogup6617">Example1(luoguP6617)</a></li>
</ul></li>
<li><a href="#set维护颜色">set维护颜色</a>
<ul>
<li><a href="#example1luogup5278-算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</a></li>
</ul></li>
<li><a href="#复杂度均摊">复杂度均摊</a>
<ul>
<li><a href="#example1cf702f-t-shirts">Example1(CF702F
T-Shirts)</a></li>
<li><a href="#example2uoj228">Example2(uoj228)</a></li>
<li><a href="#example3luogu-4690-ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</a></li>
</ul></li>
<li><a href="#根号分治">根号分治</a>
<ul>
<li><a href="#example1luogup7722-ynoi2007-tmpq">Example1(luoguP7722
[Ynoi2007] tmpq)</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3-1">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5shoi2006-homework">Example5(SHOI2006
Homework)</a></li>
<li><a href="#example6">Example6</a></li>
</ul></li>
<li><a href="#重链分治">重链分治</a>
<ul>
<li><a href="#example1luogu5314-ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</a></li>
</ul></li>
<li><a href="#扫描线">扫描线</a>
<ul>
<li><a href="#一维扫描线">一维扫描线</a></li>
<li><a href="#二维扫描线">二维扫描线</a></li>
<li><a href="#example-1">Example</a>
<ul>
<li><a href="#example1cf1609f-interesting-sections">Example1(CF1609F
Interesting Sections)</a></li>
<li><a href="#example2cf833e">Example2(CF833E)</a></li>
<li><a href="#example3loj3489">Example3(loj3489)</a></li>
<li><a href="#example4luogup7709-wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</a></li>
<li><a href="#example5luogu3863">Example5(luogu3863)</a></li>
<li><a href="#example6qoj6304">Example6(qoj6304)</a></li>
</ul></li>
</ul></li>
<li><a href="#莫队">莫队</a>
<ul>
<li><a href="#回滚莫队">回滚莫队</a></li>
<li><a href="#带修莫队">带修莫队</a></li>
<li><a href="#树上莫队">树上莫队</a></li>
<li><a href="#二次离线莫队">二次离线莫队</a></li>
<li><a href="#example-2">Example</a>
<ul>
<li><a href="#example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</a></li>
<li><a href="#example2hnoi2016大数">Example2([HNOI2016]大数)</a></li>
<li><a href="#example3luogup3604-美好的每一天">Example3(luoguP3604
美好的每一天)</a></li>
</ul></li>
</ul></li>
<li><a href="#区间子区间问题">区间子区间问题</a>
<ul>
<li><a href="#example1cf997e">Example1(CF997E)</a></li>
</ul></li>
<li><a href="#时间倒流">时间倒流</a>
<ul>
<li><a href="#example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</a></li>
<li><a href="#example2wc2006水管局长">Example2([WC2006]水管局长)</a></li>
</ul></li>
<li><a href="#数据结构维护分段函数">数据结构维护分段函数</a>
<ul>
<li><a href="#example1cf1540d-inverse-inversions">Example1(CF1540D
Inverse Inversions)</a></li>
</ul></li>
<li><a href="#根号平衡">根号平衡</a>
<ul>
<li><a href="#example-3">Example</a>
<ul>
<li><a href="#example1区间众数">Example1(区间众数)</a></li>
<li><a href="#example2codechef-chef-and-churu">Example2(CodeChef Chef
and Churu)</a></li>
<li><a href="#example3ahoi2013作业">Example3([Ahoi2013]作业)</a></li>
<li><a href="#example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2>
<h3><span id="维度">维度</span></h3>
<h4><span id="b维正交范围">B维正交范围</span></h4>
<p>对于一个<span class="math inline">\(B\)</span>维的点<span class="math inline">\(x\)</span>,满足<span class="math inline">\(\forall
1\leq i\leq B,l_i\leq x_i\leq
r_i\)</span>,称所有这样的点组成的集合为一个<span class="math inline">\(B\)</span>维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果<span class="math inline">\(l,r\)</span>有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个<span class="math inline">\(B\)</span>维正交范围有<span class="math inline">\(k\)</span>个有用限制,称它为<span class="math inline">\(k-side\)</span>的.</p>
<p>例如,找到区间<span class="math inline">\([l,r]\)</span>中<span class="math inline">\(&lt;x\)</span>的元素,这个矩形是<span class="math inline">\(3-side\)</span>的.找到区间<span class="math inline">\([1,l]\)</span>中<span class="math inline">\(&lt;x\)</span>的元素,这个矩形是<span class="math inline">\(2-side\)</span>的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3>
<h4><span id="矩阵乘法">矩阵乘法</span></h4>
<p>做<span class="math inline">\(n\times
n\)</span>的矩阵乘法目前得到的最优秀复杂度也是<span class="math inline">\(O(n^{2.373})\)</span>.</p>
<p>另外可以归约:<span class="math inline">\(01\)</span>矩阵和整数矩阵在去除<span class="math inline">\(\log n\)</span>后的复杂度相同.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5>
<p>考虑构造一棵树:他有<span class="math inline">\(\sqrt
n\)</span>个叉,每个叉上有<span class="math inline">\(\sqrt
n\)</span>个点.我们将这些叉编号为<span class="math inline">\([1,\sqrt
n]\)</span>.然后我们考虑询问两个叉所组成的链的答案,设<span class="math inline">\(f_{i,j}\)</span>表示数字<span class="math inline">\(j\)</span>是否在<span class="math inline">\(i\)</span>的叉上出现过,不难发现它们合并的时候要对<span class="math inline">\(f\)</span>做或运算,<span class="math inline">\(01\)</span>矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5>
<p>考虑对序列和值域同时分块,考虑序列中第<span class="math inline">\(L\)</span>到第<span class="math inline">\(R\)</span>个块的答案,设为<span class="math inline">\(f(L,R)\)</span>,这两块间的答案设为<span class="math inline">\(g(L,R)\)</span>,显然<span class="math inline">\(f(L,R)=f(L+1,R)+f(L,R-1)-f(L+1,R-1)+g(L,R)\)</span>,而由于对值域分块,<span class="math inline">\(g(L,R)=\sum a\times
b\)</span>的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5>
<p>平面上有若干点,两个操作:每次将横坐标小于等于<span class="math inline">\(A\)</span>的点加上<span class="math inline">\(v\)</span>,或者查询纵坐标小于等于<span class="math inline">\(B\)</span>的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="分块">分块</span></h3>
<h5><span id="example1luogup8527ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</span></h5>
<p>首先将<span class="math inline">\(a\)</span>分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的<span class="math inline">\(L\)</span>的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为<span class="math inline">\(B\)</span>,暴力处理散块的复杂度是<span class="math inline">\(O(Bm)\)</span>,处理整块的复杂度是<span class="math inline">\(O(\frac{n}{B}(m+n\log n))\)</span>.取<span class="math inline">\(B^2=\frac{n}{m}(m+n\log n)=500\)</span>最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了<span class="math inline">\(B=2048\)</span>.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079riapq">Example2(luogu[Ynoi2079]
riapq)</span></h5>
<p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了<span class="math inline">\([1,l-1]\)</span>对<span class="math inline">\([l,r]\)</span>的贡献.</p>
<p>先序列分块.然后<span class="math inline">\([1,l-1]\)</span>中的整块对<span class="math inline">\([l,r]\)</span>的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将<span class="math inline">\([1,l-1]\)</span>中的整块的树状数组进行一个<span class="math inline">\([l,r]\)</span>的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到<span class="math inline">\(O(Bq\log n)\)</span>的时间复杂度和<span class="math inline">\(O(Bn)\)</span>的空间复杂度.</p>
<p>问题在于<span class="math inline">\([1,l-1]\)</span>中的散块咋办.首先<span class="math inline">\([1,l-1]\)</span>中的散块对<span class="math inline">\([l,r]\)</span>中的散块的贡献是好处理的,因为总共就<span class="math inline">\(O(\frac n
B)\)</span>个数字,直接全部存下来排序做归并就可以统计,时间复杂度<span class="math inline">\(O(Bq\log n)\)</span>.</p>
<p>现在的问题在于<span class="math inline">\([1,l-1]\)</span>中的散块对<span class="math inline">\([l,r]\)</span>中的整块如何贡献.能不能把<span class="math inline">\([l,r]\)</span>的信息统计在<span class="math inline">\([1,l-1]\)</span>的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有<span class="math inline">\(\frac{n}{B}\)</span>个,整块一共有<span class="math inline">\(B\)</span>个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为<span class="math inline">\(O(n\sqrt n\log
n)\)</span>,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</span></h5>
<p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu6331">Example4(Walking Plan HDU
6331)</span></h5>
<p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度<span class="math inline">\(O(nq)\)</span>.</p>
<h5><span id="example5p5063-ynoi2014置身天上之森">Example5(P5063 [Ynoi2014]
置身天上之森)</span></h5>
<p>考虑如果<span class="math inline">\(n=2^k\)</span>,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的<span class="math inline">\(a\)</span>(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是<span class="math inline">\(n\)</span>不一定是<span class="math inline">\(2^k\)</span>,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5>
<p>大概是对于每个块处理出它的值域范围:一开始是<span class="math inline">\([1,n]\)</span>,然后每次操作都会将整个块分为两部分:<span class="math inline">\([1,x)\)</span>和<span class="math inline">\([x,maxn]\)</span>,讨论一下<span class="math inline">\(maxn\)</span>和<span class="math inline">\(2x\)</span>的大小,就可以用<span class="math inline">\(\min(x,maxn-x)\)</span>的复杂度使得<span class="math inline">\(maxn\)</span>变成<span class="math inline">\(maxn-x\)</span>,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3>
<h5><span id="example1luogup5047ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5>
<p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到<span class="math inline">\(O(n\sqrt n\log n)\)</span>.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为<span class="math inline">\([l,r]\)</span>对<span class="math inline">\(r\)</span>的贡献实际上就是<span class="math inline">\([1,r]\)</span>对<span class="math inline">\(r\)</span>的贡献减去<span class="math inline">\([1,l-1]\)</span>对<span class="math inline">\(r\)</span>的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这<span class="math inline">\(O(n\sqrt
n)\)</span>次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入<span class="math inline">\(O(n)\)</span>次但是需要查询<span class="math inline">\(O(n\sqrt
n)\)</span>次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了<span class="math inline">\(O(n\sqrt
n)\)</span>,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到<span class="math inline">\(O(n)\)</span>.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3>
<p>我们现在有一个需要维护的<span class="math inline">\(n\times
n\)</span>的平面,我们现在对其进行分块:</p>
<ol type="1">
<li>将平面分成<span class="math inline">\(n^{\frac{1}{2}}\)</span>个<span class="math inline">\(n^{\frac{3}{4}}\times
n^{\frac{3}{4}}\)</span>的<span class="math inline">\(A\)</span>块,以<span class="math inline">\(A\)</span>块为单位做二维前缀和.</li>
<li>每个<span class="math inline">\(A\)</span>块内部分成<span class="math inline">\(n^{\frac{1}{2}}\)</span>个<span class="math inline">\(n^{\frac{1}{2}}\times
n^{\frac{1}{2}}\)</span>的<span class="math inline">\(B\)</span>块,在<span class="math inline">\(A\)</span>块内部以<span class="math inline">\(B\)</span>块为单位做二维前缀和.</li>
<li>将整个平面横着分别分成一个个<span class="math inline">\(n\times
n^{\frac{3}{4}}\)</span>的<span class="math inline">\(C\)</span>块.(竖着也要分成一个个<span class="math inline">\(n^{\frac{3}{4}}\times
n\)</span>的块,是类似的,略去)</li>
<li>每个<span class="math inline">\(C\)</span>块内部分成<span class="math inline">\(\sqrt n\)</span>个<span class="math inline">\(n^{\frac{3}{4}}\times
n^{\frac{1}{2}}\)</span>个<span class="math inline">\(D\)</span>块,在<span class="math inline">\(C\)</span>块内部以<span class="math inline">\(D\)</span>块为单位做二位前缀和.</li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度<span class="math inline">\(O(\sqrt n)\)</span>.同时注意到空间复杂度是<span class="math inline">\(O(n)\)</span>的.</p>
<p>查询显然是分四种情况讨论:<span class="math inline">\(A,B,D\)</span>块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应<span class="math inline">\(O(1)\)</span>个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个<span class="math inline">\(l\)</span>对应<span class="math inline">\(O(1)\)</span>个<span class="math inline">\(r\)</span>,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有<span class="math inline">\(O(\sqrt
n)\)</span>个查询,记录一下即可.这样就做到了<span class="math inline">\(O(\sqrt n)\)</span>单点改,<span class="math inline">\(O(1)\)</span>查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现<span class="math inline">\(O(1)\)</span>单点改,那这种情况下如何实现<span class="math inline">\(O(\sqrt n)\)</span>求和呢?首先还是可以<span class="math inline">\(O(\sqrt n)\)</span>求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度<span class="math inline">\(&lt;n^{\frac{1}{2}}\)</span>,我们就可以在每次查询的时候用<span class="math inline">\(\sqrt
n\)</span>的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以<span class="math inline">\(O(\sqrt n)\)</span>求散块.</p>
<h5><span id="example1luogup7448-ynoi2007rdiq">Example1(luoguP7448 [Ynoi2007]
rdiq)</span></h5>
<p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和<span class="math inline">\(a_r\)</span>颜色相同的点是<span class="math inline">\(r&#39;\)</span>,则显然新增的逆序对只可能出现在<span class="math inline">\([r&#39;,r]\)</span>中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从<span class="math inline">\(n\rightarrow
1\)</span>扫左端点,总共做<span class="math inline">\(O(n)\)</span>次单点修改,做<span class="math inline">\(O(n\sqrt n)\)</span>次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为<span class="math inline">\((r&#39;+1,a_r)\)</span>,右上角是<span class="math inline">\((r,\infty)\)</span>的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令<span class="math inline">\(rev(x)=n-x+1\)</span>.然后将所有点的纵坐标<span class="math inline">\(rev\)</span>掉,现在我们要查询的也就是左下角为<span class="math inline">\((r&#39;+1,1)\)</span>,右上角是<span class="math inline">\((r,rev(a_r))\)</span>的矩阵,这玩意可以拆前缀和拆成形如左下角是<span class="math inline">\((1,1)\)</span>,右上角是<span class="math inline">\((i,rev(a_i))\)</span>的矩阵.也就是说我们的<span class="math inline">\(O(n\sqrt n)\)</span>次矩阵查询本质上只有<span class="math inline">\(O(n)\)</span>种.</p>
<p>拆到这里发现其实到这一步<span class="math inline">\(a_r\)</span>和<span class="math inline">\(a_{r&#39;}\)</span>是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</span></h5>
<p>首先自然的想法是拿莫队扫掉<span class="math inline">\([l_1,r_1]\)</span>这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维<span class="math inline">\([l_2,r_2]\)</span>扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点<span class="math inline">\((a,a)\)</span>上加上一个相应的<span class="math inline">\(b\)</span>,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点<span class="math inline">\(A(x_1,x_1)\)</span>和<span class="math inline">\(B(x_2,x_2)\)</span>之间的<span class="math inline">\((x_1,x_2)\)</span>上加上一个<span class="math inline">\(-b\)</span>,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol type="1">
<li>莫队时查询一个点的前驱后继,这个操作就需要<span class="math inline">\(O(1)\)</span>完成.</li>
<li><span class="math inline">\(n\sqrt
n\)</span>次单点修改,这个操作需要<span class="math inline">\(O(1)\)</span>完成.</li>
<li><span class="math inline">\(n\)</span>次矩阵求和,这个操作需要在小于<span class="math inline">\(O(\sqrt n)\)</span>的时间完成.</li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为<span class="math inline">\(O(n\sqrt
n)\)</span>,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3>
<h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5>
<p>首先反应是扔到trie上然后异或就是打个tag,但是<span class="math inline">\(+1\)</span>很难处理,因为它形如在trie上找到所有长度连续为<span class="math inline">\(1\)</span>到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是<span class="math inline">\(+1\)</span>的话就相当于反转一条从根开始均为<span class="math inline">\(1\)</span>的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3>
<h4><span id="普通线段树">普通线段树</span></h4>
<h5><span id="example1luogup6780ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</span></h5>
<p>感觉这题比较厉害.</p>
<p>先扔做法:对<span class="math inline">\(c\)</span>分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求<span class="math inline">\(\max\)</span>.而对于块间如何做呢?</p>
<p>我们设<span class="math inline">\(suf_i\)</span>为前一个块的后<span class="math inline">\(i\)</span>个数之和,<span class="math inline">\(pre_i\)</span>为后一个块的前<span class="math inline">\(i\)</span>个数之和.注意到我们要求的就是<span class="math inline">\(\max\{suf_i+pre_j|i+j\leq
c\}\)</span>.这个咋做呢?</p>
<p>你注意到这个<span class="math inline">\(i+j\leq
c\)</span>的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用<span class="math inline">\(j\rightarrow
c-j+1\)</span>的话,这个限制就转化为了<span class="math inline">\(i+c-j+1\leq c\)</span>,也就是<span class="math inline">\(i&lt;j\)</span>,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对<span class="math inline">\(c\)</span>分块?</p>
<p>一方面,题目中的<span class="math inline">\(c\)</span>是给定的.另一方面,我们注意到我们需要维护一个和<span class="math inline">\(c\)</span>有关的东西,而如果没有<span class="math inline">\(c\)</span>,或者说<span class="math inline">\(c=n\)</span>的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了<span class="math inline">\(c=n\)</span>的条件.考虑到这一点,对<span class="math inline">\(c\)</span>分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将<span class="math inline">\(a[l-1]\)</span>和<span class="math inline">\(a[r+1]\)</span>都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个<span class="math inline">\(maxn\)</span>设成<span class="math inline">\(-\infty\)</span>的.如果这两个东西设成等大的<span class="math inline">\(-\infty\)</span>,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比<span class="math inline">\(-\infty\)</span>还要小的数字,最底层的<span class="math inline">\(maxn\)</span>有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4>
<p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5>
<p>注意到每个点其实只需要找到<span class="math inline">\([i-r_i,i-1]\)</span>和<span class="math inline">\([i+1,i+r_i]\)</span>这两段的最大值,设为<span class="math inline">\(x\)</span>,则最后的答案就是<span class="math inline">\(\max\{a_i+x\}\)</span>.</p>
<p>思考这个过程,我们将<span class="math inline">\([i-r_i,i-1]\)</span>和<span class="math inline">\([i+1,i+r_i]\)</span>这两条线段以<span class="math inline">\(a_i\)</span>的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的<span class="math inline">\(a_i\)</span>的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4>
<h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5>
<p>考虑全局的和是<span class="math inline">\(sum\)</span>,则我们要在这些数中找到一个分界点,使得左边的和大于等于<span class="math inline">\(sum\)</span>,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(a_i,b_i\)</span>,选定至多<span class="math inline">\(k\)</span>个位置使这里的值为<span class="math inline">\(a_i-b_i\)</span>,其它位置的值是<span class="math inline">\(a_i\)</span>,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的<span class="math inline">\(mid\)</span>,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出<span class="math inline">\(\min_{k=1}^r\{\max(\max_{i=k+1}^n\{sum_{i}\},-b_k+\max_{i=1}^k\{sum_i\})\}\)</span>.注意改掉一个位置后要把它的<span class="math inline">\(b\)</span>变成<span class="math inline">\(0\)</span>.</p>
<p>那么什么样的<span class="math inline">\(b\)</span>有可能是我们要选中的呢?显然可能被选中的<span class="math inline">\(b\)</span>一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:<span class="math inline">\(\min_{k=1}^r\{\max(\max_{i=k+1}^n\{sum_{i}\},-\max_{i=k}^n\{b_i\}+\max_{i=1}^k\{sum_i\})\}\)</span>,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的<span class="math inline">\(\max\)</span>尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是: <span class="math display">\[
\min_{k=1}^r\{\max(sufmax(sum)_{k+1},-sufmax(b)_k+premax(sum)_k\}\\
=\min_{k=1}^r\{\max(sufmax(sum)_{k+1},-\max(sufmax(b)_{k+1},b_k)+premax(sum)_k\}\\
\]</span> 这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的<span class="math inline">\(k\)</span>后面最大的<span class="math inline">\(b\)</span>,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响<span class="math inline">\(sufmax
(b)\)</span>的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的<span class="math inline">\(b\)</span>,这个<span class="math inline">\(b\)</span>必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4>
<h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4>
<h4><span id="吉司机线段树">吉司机线段树</span></h4>
<h4><span id="李超线段树">李超线段树</span></h4>
<h3><span id="珂朵莉树">珂朵莉树</span></h3>
<h5><span id="example1luogup8512ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</span></h5>
<p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3>
<h3><span id="kd-tree">KD-Tree</span></h3>
<p>处理<span class="math inline">\(K\)</span>维正交范围(给定<span class="math inline">\(n\)</span>个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度<span class="math inline">\(O(n^{1-\frac{1}{k}}+\log
n)\)</span>.(单调修改复杂度只是<span class="math inline">\(O(\log
n)\)</span>)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4>
<p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4>
<p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> siz;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">	<span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">	tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">	tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">	tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">		tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">		tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">		tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">		tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">		tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">		tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">		tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">		tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">		tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">		tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">	ll d=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line">	<span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line">	<span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line">	<span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">		avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">	&#125;</span><br><span class="line">	avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">		varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">		vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> cnt=cur[mid];</span><br><span class="line">	tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line">	<span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line">	<span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">	tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">	tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">	tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(cnt);</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3>
<h5><span id="example1cfgym101613factor-freetree">Example1([CFgym101613]Factor-free
tree)</span></h5>
<p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是<span class="math inline">\(\sum dep_u\)</span>,是可以被卡成<span class="math inline">\(O(n^2)\)</span>的.</p>
<p>但我们考虑类似dsu on
tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5>
<p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为<span class="math inline">\([l,r]\)</span>,这样会有:<span class="math inline">\([l-1,i-1]\rightarrow
[i,r]\)</span>.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3>
<h5><span id="exampleloj3151">Example(loj3151)</span></h5>
<p>首先自然地,我们设<span class="math inline">\(f_{i,j}\)</span>表示前<span class="math inline">\(i\)</span>个测试点已经分成了<span class="math inline">\(j\)</span>段的方案数,然后做转移,复杂度<span class="math inline">\(O(T^2S)\)</span>.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到<span class="math inline">\(k\)</span>最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把<span class="math inline">\([l,r]\)</span>分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点<span class="math inline">\(r\)</span>,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3>
<p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5>
<p>维护一个序列支持把<span class="math inline">\(x\)</span>位置的值改为<span class="math inline">\(y\)</span>或查询一个区间中小于<span class="math inline">\(y\)</span>的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</span></h5>
<p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开<span class="math inline">\(100\)</span>个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2>
<h3><span id="分开考虑">分开考虑</span></h3>
<h5><span id="example1p6105-ynoi2010y-fast-trie">Example1(P6105 [Ynoi2010]
y-fast trie)</span></h5>
<p>考虑只有两种可能:</p>
<ol type="1">
<li><span class="math inline">\(x+y&lt;C\)</span>,取<span class="math inline">\(x+y\)</span>作为答案.</li>
<li><span class="math inline">\(x+y\geq C\)</span>,取<span class="math inline">\(x+y-C\)</span>作为答案.</li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在<span class="math inline">\([0,\lceil\frac{C}{2}\rceil)\)</span>中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,<span class="math inline">\(x+y&lt;C\)</span>也就是<span class="math inline">\(x&lt;C-y\)</span>,我们把第二个集合中的元素全部变成<span class="math inline">\(C-y\)</span>后插入,只需最小化<span class="math inline">\(C-x-y\)</span>,这个只需要维护最大的<span class="math inline">\(x\)</span>和最小的<span class="math inline">\(C-y\)</span>就行.</p>
<h3><span id="合并信息">合并信息</span></h3>
<p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</span></h5>
<p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5>
<p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用<span class="math inline">\(O(\log
n)\)</span>的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5>
<p>设<span class="math inline">\(w_i\)</span>为从上往下延伸到<span class="math inline">\(i\)</span>这个点后,还能多往下延伸多少,一开始<span class="math inline">\(w\)</span>都是<span class="math inline">\(-1\)</span>,每次操作会让<span class="math inline">\(w+=1\)</span>.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3>
<h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5>
<p>自然的想法是考虑找到每个点前面第一个和它之和为<span class="math inline">\(w\)</span>的数字,但这样就炸了,因为每修改一个点可能要影响<span class="math inline">\(O(n)\)</span>个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为<span class="math inline">\(w\)</span>的数字,而显然只有两个数互相匹配才可行.如果<span class="math inline">\(i&lt;j&lt;k,(i,j),(i,k)\)</span>分别配对,那么显然<span class="math inline">\((i,k)\)</span>没有用.这样每个点只有<span class="math inline">\(O(1)\)</span>个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3>
<h5><span id="example1luogup5278算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</span></h5>
<p>首先考虑<span class="math inline">\(k=1\)</span>怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p><span class="math inline">\(k\ne
1\)</span>怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在<span class="math inline">\(\bmod
k\)</span>意义下全部相等,维护差分数组的区间<span class="math inline">\(\gcd\)</span>就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5>
<p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为<span class="math inline">\(q\)</span>的衣服,<span class="math inline">\([0,q)\)</span>的人肯定买不了,<span class="math inline">\([q,2q-1]\)</span>的人买完后,手上的钱至少减半,我们暴力处理,至于<span class="math inline">\([2q,+\infty)\)</span>,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5>
<p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到<span class="math inline">\(0\)</span>,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</span></h5>
<p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是<span class="math inline">\(pre[i]=i-1\)</span>).</p>
<h3><span id="根号分治">根号分治</span></h3>
<h5><span id="example1luogup7722-ynoi2007tmpq">Example1(luoguP7722 [Ynoi2007]
tmpq)</span></h5>
<p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改<span class="math inline">\(a,b,c\)</span>中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个数字<span class="math inline">\(x\)</span>,每次随机在<span class="math inline">\([1,x]\)</span>中一个数<span class="math inline">\(y\)</span>并令<span class="math inline">\(x\leftarrow x\bmod y\)</span>,初始值为<span class="math inline">\(n\)</span>,求期望几次能变成<span class="math inline">\(0\)</span>.</p>
<p>注意到如果<span class="math inline">\(y\)</span>很小就直接做,<span class="math inline">\(y\)</span>很大的话<span class="math inline">\(\lfloor\frac{x}{y}\rfloor\)</span>很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5>
<p>给定序列,每次询问给出两个数字<span class="math inline">\(x,y\)</span>,求最小的<span class="math inline">\(|i-j|\)</span>满足<span class="math inline">\(a_i=x,a_j=y\)</span>.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果<span class="math inline">\(x,y\)</span>出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5>
<p>首先对于<span class="math inline">\(Y\)</span>很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于<span class="math inline">\(Y\)</span>很大的情况,<span class="math inline">\(\frac{n}{Y}\)</span>一定很小,我们不断查询大于等于<span class="math inline">\(kY\)</span>的最小元素即可,这个可以值域分块来根号平衡做到<span class="math inline">\(O(1)\)</span>查询,<span class="math inline">\(O(\sqrt
n)\)</span>单点修改.具体地,我们对每个块处理出大于等于这个块的最小的<span class="math inline">\(X\)</span>,以及块内每个点后面最小的<span class="math inline">\(X\)</span>(必须在块内),然后定位到<span class="math inline">\(kY\)</span>的块.</p>
<h5><span id="example6">Example6</span></h5>
<p>给定<span class="math inline">\(n,m\)</span>,以及序列<span class="math inline">\(a\)</span>和长度为<span class="math inline">\(n\)</span>的排列<span class="math inline">\(y\)</span>,你需要回答<span class="math inline">\(m\)</span>个询问.对每个询问,给定<span class="math inline">\(l,r\)</span>,查询: <span class="math display">\[
\sum_{i=1}^n\sum_{j=i+1}^n[a_i=a_j]\prod_{k=i}^j[l\leq y_k\leq r]
\]</span> 注意到<span class="math inline">\(y_i=i\)</span>的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点<span class="math inline">\((x,y),a_x=a_y,\nexists
x&lt;z&lt;y,a_z=a_x\)</span>,对于<span class="math inline">\((x,y)\)</span>这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于<span class="math inline">\(\sqrt
n\)</span>的数字,它们最多只有<span class="math inline">\(\sqrt
n\)</span>个,考虑莫队复杂度<span class="math inline">\(O(n\sqrt
m+m)\)</span>,因此我们可以对每个分别做莫队,总复杂度<span class="math inline">\(O(n\sqrt m+m\sqrt
n)\)</span>,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于<span class="math inline">\(\sqrt
n\)</span>的数字,这些数字一共最多有<span class="math inline">\(n\)</span>个,每个点暴力配对就有<span class="math inline">\(O(n\sqrt n)\)</span>个点对,然后<span class="math inline">\(O(m)\)</span>次询问,用根号平衡做扫描线,这里复杂度<span class="math inline">\(O(n\sqrt n+m\sqrt n)\)</span>.</p>
<h3><span id="重链分治">重链分治</span></h3>
<h5><span id="example1luogu5314ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</span></h5>
<p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为<span class="math inline">\(1\)</span>,支持把一条链上所有点加上<span class="math inline">\(k\)</span>,或者查询距离一个点<span class="math inline">\(&lt;=1\)</span>的所有点的点权<span class="math inline">\(kth\)</span>.<span class="math inline">\(n\leq
2\times 10^5\)</span>.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改<span class="math inline">\(O(\log n)\)</span>个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="一维扫描线">一维扫描线</span></h4>
<p>最经典的应用是对于一个<span class="math inline">\(B\)</span>维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个<span class="math inline">\(B-1\)</span>维的动态问题.不过扫描线处理的时候可能需要是低<span class="math inline">\(side\)</span>的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4>
<p>也就是莫队.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1cf1609finteresting-sections">Example1(CF1609F
Interesting Sections)</span></h5>
<p>首先枚举每个数的<span class="math inline">\(popcount\)</span>,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点<span class="math inline">\(x\)</span>作为最大值的影响区间<span class="math inline">\([l,r]\)</span>,也就是如果一个区间左端点在<span class="math inline">\([l,x]\)</span>,右端点在<span class="math inline">\([x,r]\)</span>即可满足条件.我们考虑放入一个左下角坐标为<span class="math inline">\((l,x)\)</span>,右上角坐标为<span class="math inline">\((x,r)\)</span>的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5>
<p>离散化,设<span class="math inline">\(S=\{l\}\cup\{r\}\)</span>,考虑用<span class="math inline">\(len_i\)</span>表示<span class="math inline">\(i\)</span>节点及以前最多能有多少阳光.我们考虑用<span class="math inline">\(len_{i-1}\)</span>更新<span class="math inline">\(len_i\)</span>,如果<span class="math inline">\([i-1,i]\)</span>没被覆盖,显然直接加上这段的长度.如果<span class="math inline">\([i-1,i]\)</span>被覆盖大于两次,那显然直接继承<span class="math inline">\(len_{i-1}\)</span>.</p>
<p>先考虑<span class="math inline">\([i-1,i]\)</span>被两朵云覆盖了怎么办,我们考虑用<span class="math inline">\(h_{j,k}\)</span>表示当前被且只被<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>共同覆盖的区间长度,不难发现<span class="math inline">\(h_{j,k}\)</span>有值的地方很少,用map.然后还要加上它们各自的贡献,用<span class="math inline">\(g_j\)</span>表示当前被且只被<span class="math inline">\(j\)</span>覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断<span class="math inline">\([i-1,i]\)</span>是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果<span class="math inline">\([i-1,i]\)</span>被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为<span class="math inline">\(k\)</span>,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是<span class="math inline">\(g_j+g_k\)</span>,用线段树处理出当前代价和小于等于<span class="math inline">\(C\)</span>的<span class="math inline">\(k\)</span>的<span class="math inline">\(g_k\)</span>的最大值就行.</p>
<p>再考虑有交的情况,答案应该为<span class="math inline">\(g_j+g_k+h_{j,k}\)</span>,我们在每次遇到<span class="math inline">\((j,k)\)</span>的时候都在对方那里打个tag就好,也就是对于每个<span class="math inline">\(j\)</span>,处理出和它有交的云中<span class="math inline">\(g_j+g_k+h_{j,k}\)</span>的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5>
<p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成<span class="math inline">\(0\)</span>后那些数一定没清空).</p>
<h5><span id="example4luogup7709wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5>
<p>如果初始序列全为<span class="math inline">\(0\)</span>:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5>
<p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5>
<p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是<span class="math inline">\(L&lt;R\)</span>,自然有<span class="math inline">\(L\leq \min\{r_i\},R\geq \max
\{l_i\}\)</span>,那么当我们确定<span class="math inline">\(L\)</span>后,我们有<span class="math inline">\(R\in[\max\{l_i\},f(L)]\)</span>.接下来我们考虑如何计算<span class="math inline">\(f(L)\)</span>.</p>
<p>注意到<span class="math inline">\(L&lt;l_i\Rightarrow R\leq
r_i\)</span>,我们考虑将<span class="math inline">\(l_i\)</span>这个点的权值设成<span class="math inline">\(r_i\)</span>,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3>
<h4><span id="回滚莫队">回滚莫队</span></h4>
<h4><span id="带修莫队">带修莫队</span></h4>
<p>也就是维护三维的扫描线,根据KDT不难发现复杂度是<span class="math inline">\(O(nm^{\frac{2}{3}})\)</span>,<span class="math inline">\(B=n^{\frac{2}{3}}\)</span>,排序原则是<span class="math inline">\((ls,rs,t)\)</span>,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4>
<h4><span id="二次离线莫队">二次离线莫队</span></h4>
<p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个<span class="math inline">\(\log
n\)</span>的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带<span class="math inline">\(\log
n\)</span>的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有<span class="math inline">\(n\sqrt n\)</span>次询问,每次询问<span class="math inline">\(f(l,r,r+1)\)</span>表示区间<span class="math inline">\([l,r]\)</span>对<span class="math inline">\(r+1\)</span>的逆序对贡献.考虑差分成<span class="math inline">\(f(1,r,r+1)-f(1,l-1,r+1)\)</span>,前者显然可以迅速求出.而后者的右端点需要移动<span class="math inline">\(n\)</span>次,需要查询总共<span class="math inline">\(n\sqrt n\)</span>次,zhe’ge</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5>
<p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都<span class="math inline">\(4-side\)</span>了,但是有可减性,减成<span class="math inline">\(2-side\)</span>就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5>
<p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉<span class="math inline">\(p=2\)</span>和<span class="math inline">\(p=5\)</span>的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字<span class="math inline">\(\bmod p\)</span>的值,设为<span class="math inline">\(suf_i\)</span>,假设存在两个点<span class="math inline">\(l,r\)</span>满足<span class="math inline">\(p|(suf_l-suf_{r+1})\)</span>,那么<span class="math inline">\([l,r]\)</span>就是合法的,这是自然的,也就等价于<span class="math inline">\(suf_l=suf_{r+1}\)</span>,相当于要对满足<span class="math inline">\(suf_l=suf_{r+1}\)</span>的二元组<span class="math inline">\((l,r)\)</span>计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604美好的每一天">Example3(luoguP3604
美好的每一天)</span></h5>
<p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3>
<p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的<span class="math inline">\((l,r)\)</span>的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5>
<p>考虑转化为二维平面,<span class="math inline">\(a_{l,r}=maxn-minn-(r-l)\)</span>,显然只需要找到为<span class="math inline">\(0\)</span>的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有<span class="math inline">\(3-side\)</span>的,但是可差分成<span class="math inline">\(2-side\)</span>.</p>
<h3><span id="时间倒流">时间倒流</span></h3>
<h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5>
<p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5>
<p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3>
<h5><span id="example1cf1540d-inverseinversions">Example1(CF1540D Inverse
Inversions)</span></h5>
<p>考虑对于一个数列怎么构造:假设只考虑前<span class="math inline">\(k\)</span>个数,它们的取值是<span class="math inline">\([1,k]\)</span>,现在加入第<span class="math inline">\(k+1\)</span>个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都<span class="math inline">\(+1\)</span>,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道<span class="math inline">\(p_i\)</span>是多少,根据上面的构造过程,首先将<span class="math inline">\(p_i=a_i\)</span>,然后不断向后遍历,每遇到一个<span class="math inline">\(a_j\)</span>,如果<span class="math inline">\(a_j\leq p_i\)</span>,则把<span class="math inline">\(p_i+=1\)</span>.</p>
<p>我们将数列分块,设块长为<span class="math inline">\(B\)</span>,那一个值经过一个块的时候最多加块长个<span class="math inline">\(1\)</span>.也就是经过整块的时候是一个<span class="math inline">\(B\)</span>段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是<span class="math inline">\(\sum{\cfrac{B}{2^i}}=B\)</span>的,</p>
<p>于是最后复杂度为<span class="math inline">\(O(T(B+\cfrac{n}{B}\log
n))\)</span>,取<span class="math inline">\(B=\sqrt{n\log
n}\)</span>即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3>
<p>根号平衡主要用到下面四个东西:</p>
<ol type="1">
<li><span class="math inline">\(O(1)\)</span>单点加,<span class="math inline">\(O(\sqrt n)\)</span>区间和:维护块内的和即可.</li>
<li><span class="math inline">\(O(\sqrt n)\)</span>单点加,<span class="math inline">\(O(1)\)</span>区间和:维护块内和块间的前缀和即可.</li>
<li><span class="math inline">\(O(\sqrt n)\)</span>区间加,<span class="math inline">\(O(1)\)</span>单点和:差分转化为<span class="math inline">\((2)\)</span>.当然打标记也是可以的.</li>
<li><span class="math inline">\(O(1)\)</span>区间加,<span class="math inline">\(O(\sqrt n)\)</span>单点和:差分转化为<span class="math inline">\((1)\)</span>.当然打标记也是可以的.</li>
</ol>
<p>还有一些拓展的东西:</p>
<ol start="5" type="1">
<li>维护值域<span class="math inline">\(O(n)\)</span>的集合,支持<span class="math inline">\(O(1)\)</span>插入,<span class="math inline">\(O(\sqrt n)\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块就可以.</li>
<li>维护值域<span class="math inline">\(O(n)\)</span>的集合,支持<span class="math inline">\(O(\sqrt n)\)</span>插入,<span class="math inline">\(O(1)\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块,然后暴力改变每个点所属的块就行.</li>
</ol>
<h4><span id="example">Example</span></h4>
<h5><span id="example1区间众数">Example1(区间众数)</span></h5>
<p>首先分块,处理出<span class="math inline">\(f_{l,r}\)</span>表示块<span class="math inline">\([l,r]\)</span>的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是<span class="math inline">\(\log n\)</span>的,因此复杂度<span class="math inline">\(O(n\sqrt {n\log n})\)</span>.</p>
<p>但是可以优化,我们设<span class="math inline">\(mx\)</span>表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于<span class="math inline">\(mx\)</span>可以<span class="math inline">\(O(1)\)</span>判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然<span class="math inline">\(mx\)</span>增加总次数也不会超过<span class="math inline">\(O(\sqrt n)\)</span>,因此做到<span class="math inline">\(O(n\sqrt n)\)</span>.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-andchuru">Example2(CodeChef Chef and
Churu)</span></h5>
<p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个<span class="math inline">\(O(1)\)</span>查询区间和,<span class="math inline">\(O(\sqrt n)\)</span>单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5>
<p>莫队,发现有<span class="math inline">\(m\)</span>次查询,<span class="math inline">\(n\sqrt m\)</span>次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5>
<p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有<span class="math inline">\(O(n)\)</span>种,用值域分块就可以平衡复杂度.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#离散概率">离散概率</a>
<ul>
<li><a href="#基本定义">基本定义</a></li>
<li><a href="#期望的简单运算">期望的简单运算</a></li>
<li><a href="#方差的简单运算">方差的简单运算</a></li>
<li><a href="#随机抽样调查">随机抽样调查</a></li>
<li><a href="#条件概率">条件概率</a>
<ul>
<li><a href="#贝叶斯公式">贝叶斯公式</a></li>
</ul></li>
<li><a href="#概率生成函数">概率生成函数</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2penney游戏">Example2(Penney游戏)</a></li>
<li><a href="#example3sdoi2017-硬币游戏">Example3([SDOI2017]
硬币游戏)</a></li>
</ul></li>
<li><a href="#二项式分布">二项式分布</a></li>
<li><a href="#模型">模型</a>
<ul>
<li><a href="#树上随机游走">树上随机游走</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#计数与期望的转换">计数与期望的转换</a>
<ul>
<li><a href="#examplecodechef-secplayer">Example(CodeChef
Secplayer)</a></li>
</ul></li>
<li><a href="#一些小技巧">一些小技巧</a>
<ul>
<li><a href="#example1cf865c">Example1(CF865C)</a></li>
<li><a href="#example2猎人杀">Example2(猎人杀)</a></li>
<li><a href="#example3agc019f">Example3(AGC019F)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数据随机下的性质">数据随机下的性质</a>
<ul>
<li><a href="#树">树</a></li>
<li><a href="#数">数</a></li>
<li><a href="#序列">序列</a></li>
</ul></li>
<li><a href="#随机化算法的分类">随机化算法的分类</a>
<ul>
<li><a href="#数值概率算法">数值概率算法</a></li>
<li><a href="#monte-carlo算法">Monte Carlo算法</a>
<ul>
<li><a href="#求解最优化问题的monte-carlo算法">求解最优化问题的Monte
Carlo算法</a></li>
<li><a href="#求解判定性问题的monte-carlo算法">求解判定性问题的Monte
Carlo算法</a></li>
<li><a href="#正确率与复杂度">正确率与复杂度</a></li>
<li><a href="#算法设计思路1">算法设计思路1</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#算法设计思路2">算法设计思路2</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法-1">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度-1">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example-1millar-rabin算法">Example
1(Millar-Rabin算法)</a></li>
<li><a href="#example2codechef-mstone">Example2(CodeChef
MSTONE)</a></li>
<li><a href="#example3cf364d-ghd">Example3(CF364D Ghd)</a></li>
<li><a href="#example4poi2014couriers">Example4([POI2014]Couriers)</a></li>
</ul></li>
<li><a href="#example5noi2013-向量内积">Example5([NOI2013]
向量内积)</a></li>
</ul></li>
<li><a href="#las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</a>
<ul>
<li><a href="#算法设计思路">算法设计思路</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法-2">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度-2">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#example-1">Example</a>
<ul>
<li><a href="#快速排序算法">快速排序算法</a></li>
<li><a href="#一类由monte-carlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</a></li>
<li><a href="#example3cf329c-graph-reconstruction">Example3(CF329C Graph
Reconstruction)</a></li>
<li><a href="#example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</a></li>
</ul></li>
</ul></li>
<li><a href="#爬山与模拟退火">爬山与模拟退火</a>
<ul>
<li><a href="#爬山">爬山</a></li>
<li><a href="#模拟退火">模拟退火</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间<span class="math inline">\(\Omega\)</span>:在一个给定问题中可能发生的所有情况.</p>
<p>事件:<span class="math inline">\(\Omega\)</span>的一个子集.</p>
<p>基本事件<span class="math inline">\(\omega\)</span>:<span class="math inline">\(\Omega\)</span>中的单个元素,也可以看作集合大小为<span class="math inline">\(1\)</span>的事件.</p>
<p>概率:若<span class="math inline">\(\omega\in
\Omega\)</span>,我们称它发生的概率为<span class="math inline">\(\Pr(\omega)\)</span>,有<span class="math inline">\(\Pr(\omega)\geq 0\)</span>且<span class="math inline">\(\sum_{\omega\in\Omega}\Pr(\omega)=1\)</span>.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>定义在同一个概率空间<span class="math inline">\(\Omega\)</span>上,对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,我们称<span class="math inline">\(\Pr(X=x\and Y=y)\)</span>为它们的联合分布.</p>
<p>独立:如果对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,<span class="math inline">\(\Pr(X=x\and
Y=y)=\Pr(X=x)\times \Pr(Y=y)\)</span>,我们称<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是独立的.</p>
<p>期望(均值)<span class="math inline">\(E
X\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的期望<span class="math inline">\(EX=\sum_{x\in X(\Omega)}x\times
\Pr(X=x)=\sum_{w\in\Omega}X(\omega)\Pr(\omega)\)</span>.</p>
<p>中位数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的中位数为满足<span class="math inline">\(\Pr(X\leq x)\geq 0.5\and \Pr(X\geq x)\geq
0.5\)</span>的<span class="math inline">\(x\in
X(\Omega)\)</span>所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的众数为满足<span class="math inline">\(\Pr(X= x)\geq \Pr(X=x&#39;),\forall x&#39;\in
X(\Omega)\)</span>的<span class="math inline">\(x\in
X(\Omega)\)</span>所组成的集合.</p>
<p>方差<span class="math inline">\(VX\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的方差<span class="math inline">\(VX=E((X-EX)^2)\)</span>.</p>
<p>标准差<span class="math inline">\(\sigma\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的标准差<span class="math inline">\(\sigma=\sqrt{VX}\)</span>.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果<span class="math inline">\(X,Y\)</span>是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><span class="math inline">\(E(X+Y)=EX+EY\)</span>.</li>
<li><span class="math inline">\(E(\alpha X)=\alpha EX\)</span>.</li>
<li>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>互相独立,那么<span class="math inline">\(E(XY)=(EX)(EY)\)</span>.</li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式: <span class="math display">\[
E((X-EX)^2)=E(X^2-2X(EX)+(EX)^2)\\
=E(X^2)-2(EX)(EX)+(EX)^2\\
=E(X^2)-(EX)^2
\]</span> 也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为独立的随机变量时,我们有: <span class="math display">\[
V(X+Y)=E((X+Y)^2)-(EX+EY)^2\\
=E((X+Y)^2)-(EX)^2-2(EX)(EY)-(EY)^2
\]</span> 而又有: <span class="math display">\[
E((X+Y)^2)=E(X^2+2XY+Y^2)\\
=E(X^2)+2(EX)(EY)+E(Y^2)
\]</span> 则: <span class="math display">\[
V(X+Y)=E(X^2)+2(EX)(EY)+E(Y^2)-(EX)^2-2(EX)(EY)-(EY)^2
\\=VX+VY
\]</span> 即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式: <span class="math display">\[
\Pr((X-EX)^2\geq \alpha)\leq \cfrac{VX}{\alpha},\alpha&gt;0
\]</span> 证明如下: <span class="math display">\[
VX=\sum_{\omega\in \Omega}(X(\omega)-EX)^2\Pr(\omega)\\
\geq
\sum_{\omega\in\Omega}(X(\omega)-EX)^2\Pr(\omega)[(X(\omega)-EX)^2\geq
\alpha]\\
\geq \sum_{\omega\in\Omega}\alpha\Pr(\omega)[(X(\omega)-EX)^2\geq
\alpha]\\=\alpha \Pr((X-EX)^2\geq \alpha)
\]</span> 如果我们用<span class="math inline">\(c^2VX\)</span>代替<span class="math inline">\(\alpha\)</span>,我们就有:</p>
<p><span class="math inline">\(\Pr(|X-EX|\geq c\sigma)\leq
\cfrac{1}{c^2}\)</span>.</p>
<p>简单来说,这个不等式说明:<span class="math inline">\(X\)</span>落在<span class="math inline">\((EX-c\sigma,EX+c\sigma)\)</span>之外的概率至多为<span class="math inline">\(\cfrac{1}{c^2}\)</span>.</p>
<p>另外,如果我们取<span class="math inline">\(n\)</span>个独立的样本<span class="math inline">\(X_1,X_2,...,X_n\)</span>,令<span class="math inline">\(S=\sum_{i=1}^nX_i\)</span>,那么它的均值是<span class="math inline">\(nEX\)</span>,标准差是<span class="math inline">\(\sqrt n\sigma\)</span>,也就是说,<span class="math inline">\(\cfrac{S}{n}\)</span>落在<span class="math inline">\((EX-\cfrac{c\sigma}{\sqrt
n},EX+\cfrac{c\sigma}{\sqrt n})\)</span>之外的概率小于等于<span class="math inline">\(\cfrac{1}{c^2}\)</span>.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了<span class="math inline">\(n\)</span>个值<span class="math inline">\(X_1,X_2,...,X_n\)</span>,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p><span class="math inline">\(\hat
EX=\cfrac{\sum_{i=1}^nX_i}{n}\)</span>.</p>
<p><span class="math inline">\(\hat
VX=\cfrac{\sum_{i=1}^nX_i^2}{n-1}-\cfrac{(\sum_{i=1}^nX_i)^2}{n(n-1)}\)</span>.</p>
<p>这里的<span class="math inline">\(\hat
VX\)</span>似乎与定义不是那么相符.但是它拥有更好的性质:<span class="math inline">\(E(\hat VX)=VX\)</span>.</p>
<p>证明如下: <span class="math display">\[
E(\hat
VX)=\cfrac{1}{n-1}E(\sum_{i=1}^nX_i^2-\cfrac{1}{n}\sum_{j=1}^n\sum_{k=1}^nX_jX_k)\\
=\cfrac{1}{n-1}(\sum_{i=1}^nE(X_i^2)-\cfrac{1}{n}\sum_{i=1}^n\sum_{j=1}^nE(X_iX_j))\\
=\cfrac{1}{n-1}(\sum_{i=1}^nE(X^2)-\cfrac{1}{n}\sum_{i=1}^n\sum_{j=1}^n((EX)^2[j\ne
k]+E(X^2)[j=k]))\\
=\cfrac{1}{n-1}(nE(X^2)-\cfrac{1}{n}(nE(X^2)+n(n-1)(EX)^2))\\
=E(X^2)-(EX)^2\\
=VX
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\\\)</span>.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有<span class="math inline">\(\{B_i\}\)</span>是样本空间的一个划分,即<span class="math inline">\(\forall i,j\)</span>,有<span class="math inline">\(B_i\cap B_j=\empty\)</span>,并且有<span class="math inline">\(\bigcup_{i=1}^nB_i=\Omega\)</span>.则有<span class="math inline">\(P(B_i|A)=\frac{P(AB_i)}{P(A)}=\frac{P(AB_i)}{P(A)\sum
P(B_j)}=\frac{P(A B_i)}{\sum_{j=1}^n P(A
B_j)}=\frac{P(A|B_i)P(B_i)}{\sum_{j=1}^n P(A|B_j)P(B_j)}\\\)</span>.</p>
<p>简化形式:<span class="math inline">\(P(B|A)=\frac{P(A|B)P(B)}{P(A)}\\\)</span>.</p>
<p>另外,我们考虑设<span class="math inline">\(O(B)=\cfrac{P(B)}{P(\lnot
B)}\)</span>,称<span class="math inline">\(\cfrac{P(B|E)}{P(\lnot
B|E)}\)</span>为贝叶斯算子,则同理可得: <span class="math display">\[
O(B|E)=O(B)\cfrac{P(B|E)}{P(\lnot B|E)}
\]</span>
这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果<span class="math inline">\(X\)</span>是定义在概率空间<span class="math inline">\(\Omega\)</span>上的随机变量,那么它的概率生成函数为<span class="math inline">\(G_X(z)=\sum_{k\geq
0}\Pr(X=k)z^k=E(z^X)\)</span>.</p>
<p>不难发现<span class="math inline">\(G_X(z)\)</span>需要满足的条件:所有系数都非负并且<span class="math inline">\(G_X(1)=1\)</span>.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:
<span class="math display">\[
EX=G_X&#39;(1)\\
E(X^2)=G&#39;&#39;_X(1)+G_X&#39;(1)\\
VX=G_X&#39;&#39;(1)+G_X&#39;(1)-(G_X&#39;(1))^2
\]</span>
通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义: <span class="math display">\[
Mean(G)=G&#39;(1)\\
Var(G)=G&#39;&#39;(1)+G&#39;(1)-(G&#39;(1))^2
\]</span> 不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:
<span class="math display">\[
G(1+t)=\sum_{i\geq 0}\cfrac{G^{(i)}(1)}{i!}t^i
\]</span> 另外,我们不难发现:<span class="math inline">\(G_{X+Y}(z)=G_X(z)G_Y(z)\)</span>.</p>
<p>根据前面的推导,我们有: <span class="math display">\[
Mean(G_{X+Y})=Mean(G_X)+Mean(G_Y)\\
Var(G_{X+Y})=Var(G_X)+Var(G_Y)
\]</span> 换句话说,若<span class="math inline">\(G_X(1)=1,G_Y(1)=1\)</span>,那么这个式子与直接对<span class="math inline">\(G_{X+Y}\)</span>使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则: <span class="math display">\[
Mean(G_X)=Mean(G_{X+Y})-Mean(G_Y)\\
Var(G_X)=Var(G_{X+Y})-Var(G_Y)
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为<span class="math inline">\(p\)</span>,反面向上的概率为<span class="math inline">\(q\)</span>,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设<span class="math inline">\(N\)</span>为所有不包含THTTH的硬币序列的生成函数,<span class="math inline">\(S\)</span>为所有只有结尾为THTTH的硬币序列的生成函数,令<span class="math inline">\(H=pz,T=qz\)</span>,<span class="math inline">\(1\)</span>为空集,我们显然有: <span class="math display">\[
1+N\times (H+T)=N+S\\
N\times THTTH=S+S\times TTH
\]</span> 解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设<span class="math inline">\(A\)</span>是我们要找到的字符串,<span class="math inline">\(m\)</span>是它的长度,令<span class="math inline">\(A^{(k)}\)</span>表示<span class="math inline">\(A\)</span>字符串的前<span class="math inline">\(k\)</span>个字符所组成的字符串,<span class="math inline">\(A_{(k)}\)</span>表示<span class="math inline">\(A\)</span>字符串的后<span class="math inline">\(k\)</span>个字符所组成的字符串.这样的形式与<span class="math inline">\(k\)</span>阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为: <span class="math display">\[
1+N(H+T)=N+S\\
N\times A=S(\sum_{k=0}^{m-1}A^{(k)}[A^{(m-k)}=A_{(m-k)}])
\]</span> 如果我们设<span class="math inline">\(\tilde
A\)</span>为将字符串<span class="math inline">\(A\)</span>中的H替换成<span class="math inline">\(\cfrac{1}{p}z\)</span>,T替换成<span class="math inline">\(\cfrac{1}{q}z\)</span>之后的值,那么显然有: <span class="math display">\[
N\times A=A\times S\times (\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}])\\
N=S\times (\sum_{k=1}^{m}\tilde A_{(k)}[A^{(k)}=A_{(k)}])\\
\cfrac{S-1}{H+T-1}=S\times (\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}])\\
S\times(1+(1-H-T)\times (\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}]))=1
\]</span> 这显然是一个卷积的形式.</p>
<p>令<span class="math inline">\(w=\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}]\)</span>.</p>
<p>令<span class="math inline">\(H(z)=1\)</span>,<span class="math inline">\(F(z)=(1+(1-z)\times w)\)</span>,<span class="math inline">\(G(z)=S\)</span>.</p>
<p>那么我们显然可以直接求<span class="math inline">\(G(z)\)</span>的期望和方差,事实上: <span class="math display">\[
EX=\sum_{k=1}^{m}\tilde A_{(k)}[A^{(k)}=A_{(k)}]\\
VX=(EX)^2-\sum_{k=1}^m(2k-1)\tilde A_{(k)}[A^{(k)}=A_{(k)}]
\]</span> 如果硬币是均匀的(<span class="math inline">\(p=q=\cfrac 1
2\)</span>)我们引入另一个符号:我们设<span class="math inline">\(A:A=\sum_{k=1}^m2^{k}[A^{(k)}=A_{(k)}]\)</span>.那么显然期望需要的抛硬币次数就是<span class="math inline">\((A:A)\)</span>.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设<span class="math inline">\(S_A\)</span>为所有以HHT结尾的硬币序列的生成函数,设<span class="math inline">\(S_B\)</span>为所有以HTT结尾的硬币序列的生成函数.<span class="math inline">\(N\)</span>为其它的硬币序列的生成函数,令<span class="math inline">\(H=T=0.5z\)</span>.</p>
<p>我们显然有: <span class="math display">\[
1+N(H+T)=N+S_A+S_B\\
N\times HHT=S_A\\
N\times HTT=S_A\times T+S_B
\]</span> 解方程并带入<span class="math inline">\(z=1\)</span>,可以有得知以HHT结尾的概率为<span class="math inline">\(\cfrac{2}3\)</span>.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,那么可以求出: <span class="math display">\[
\cfrac{S_A}{S_B}=\cfrac{B:B-B:A}{A:A-A:B}
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{k,i}\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F,G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><span class="math inline">\(1+xG(x)=\sum_kF_k(x)+G(x)\)</span>.</li>
<li><span class="math inline">\((\frac{1}{2}x)^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=0}^{L-1}(\frac{1}{2}x)^i[A_k^{(L-i)}={A_j}_{(L-i)}]\)</span>.</li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x=1\)</span>,发现<span class="math inline">\(\sum_{k}F_k(1)=1\)</span>.</p>
<p>把(2)化简一下,有: <span class="math display">\[
x^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=0}^{L-1}(\frac{1}{2}x)^{i-L}[A_k^{(L-i)}={A_j}_{(L-i)}]\\
x^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=1}^{L}(\frac{1}{2}x)^{-i}[A_k^{(i)}={A_j}_{(i)}]
\]</span> 带入<span class="math inline">\(x=1\)</span>,有: <span class="math display">\[
G(1)=\sum_{j=1}^nF_j(1)\sum_{i=1}^{L}2^i[A_k^{(i)}={A_j}_{(i)}]
\]</span> 不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n+1\)</span>个等式,可以算出<span class="math inline">\(G(1),F_{1\cdots n}(1)\)</span>这<span class="math inline">\(n+1\)</span>个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为<span class="math inline">\(n+1\)</span>的概率空间,其中<span class="math inline">\(\Pr(\omega_k)=\binom{n}{k}p^kq^{n-k}\\\)</span>,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令<span class="math inline">\(H(z)=q+pz\)</span>,不难发现二项式分布的生成函数为<span class="math inline">\(H(z)^n\)</span>.</p>
<p>不难发现,满足二项式分布的随机变量的均值是<span class="math inline">\(np\)</span>,方差是<span class="math inline">\(npq\)</span>.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:<span class="math inline">\(G(z)^n=(\cfrac{p}{1-qz})^n=\sum_{k}\binom{n+k-1}{k}p^nq^kz^k\)</span>.</p>
<p>我们考虑如何求<span class="math inline">\(G(z)\)</span>的方差和均值,不妨设<span class="math inline">\(F(z)=\cfrac{1-qz}{p}=\cfrac{1}{p}-\cfrac{q}{p}z\)</span>,则<span class="math inline">\(G(z)^n=F(z)^{-n}\)</span>.</p>
<p>不难发现<span class="math inline">\(F(z)\)</span>满足二项式分布.也就是说,以<span class="math inline">\((n,p,q)\)</span>为参数的负二项式分布也就是以<span class="math inline">\((-n,-\cfrac{q}{p},\cfrac{1}{p})\)</span>为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为<span class="math inline">\(1\)</span>的<span class="math inline">\(n\)</span>个点的树,问所有点对<span class="math inline">\((i,j)(1\leq i,j\leq n)\)</span>中,从<span class="math inline">\(i\)</span>走到<span class="math inline">\(j\)</span>的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设<span class="math inline">\(f_u\)</span>表示<span class="math inline">\(u\)</span>随机走到它父亲的期望,<span class="math inline">\(g_v\)</span>表示<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的期望.</p>
<p>对于<span class="math inline">\(f_u\)</span>,我们有: <span class="math display">\[
f_u=\cfrac{\sum_{u\rightarrow v}(f_v+f_u)}{\deg_u}+1\\
f_u=\deg_u+\sum_{u\rightarrow v}f_v
\]</span> 对于<span class="math inline">\(g_v\)</span>,我们有: <span class="math display">\[
g_v=\cfrac{g_u+g_v+\sum_{u\rightarrow w,w\ne v}(g_v+f_w)}{\deg_u}+1\\
g_v=g_u+\sum_{u\rightarrow w,w\ne v}f_w+\deg_u
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵<span class="math inline">\(n\)</span>个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从<span class="math inline">\(1\)</span>号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案<span class="math inline">\(+1\)</span>.当走到度数为<span class="math inline">\(1\)</span>的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设<span class="math inline">\(f_u\)</span>表示以<span class="math inline">\(u\)</span>为起点的路径的期望长度,不难注意到<span class="math inline">\(f_{leaf}=1\)</span>且<span class="math inline">\(f_u=1+\cfrac{1}{\deg_u}\sum_{u\rightarrow v\or
v\rightarrow
u}f_v\)</span>.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得<span class="math inline">\(f_u=k_uf_{fa}+b_u\)</span>,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出<span class="math inline">\(g_v\)</span>表示从<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的概率,再令<span class="math inline">\(f_u\)</span>表示从<span class="math inline">\(u\)</span>走到父亲的概率,类似Example1,我们有:
<span class="math display">\[
f_u=\cfrac{1}{\deg_u}(1+\sum_{u\rightarrow v} f_vf_u)\\
g_v=\cfrac{1}{\deg_u}(1+g_vg_u+\sum_{u\rightarrow w,w\ne v}f_wg_v)
\]</span> 最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为<span class="math inline">\(\frac{1}{\binom{n}{2}}\)</span>.</p>
<p>把所有人权值从大到小排序,设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>个人的时候的期望,不难发现:<span class="math inline">\(f_{i}=\frac{1}{\binom{i}{2}}v_i+(1-\frac{1}{\binom{i}{2}})f_{i-1}\)</span>.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设<span class="math inline">\(f_{i,j}\)</span>表示过了<span class="math inline">\(i\)</span>关,花费为<span class="math inline">\(j\)</span>的期望,不难发现所有的<span class="math inline">\(f\)</span>都需要与<span class="math inline">\(f_{0,0}\)</span>取<span class="math inline">\(\min\)</span>,这咋办?</p>
<p>我们考虑二分这个<span class="math inline">\(f_{0,0}\)</span>,做的时候直接取<span class="math inline">\(\min\)</span>,这样最后还会求出一个<span class="math inline">\(f_{0,0}\)</span>,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的<span class="math inline">\(f_{0,0}\)</span>越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取<span class="math inline">\(\min\)</span>的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张<span class="math inline">\(n\times
m\)</span>的图(假设<span class="math inline">\(n\geq
m\)</span>),其中格点<span class="math inline">\((a,b)\)</span>表示现在还剩<span class="math inline">\(a\)</span>个Yes,<span class="math inline">\(b\)</span>个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从<span class="math inline">\((n,m)\)</span>走到<span class="math inline">\((0,0)\)</span>的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线<span class="math inline">\(y=x\)</span>翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从<span class="math inline">\((n,m)\)</span>走到<span class="math inline">\((0,0)\)</span>一定会经过<span class="math inline">\(n\)</span>条有向边,所以期望贡献一定要加上一个<span class="math inline">\(n\)</span>.而如果我走到了直线<span class="math inline">\(y=x\)</span>上,那接下来的贡献是<span class="math inline">\(\frac{1}{2}\)</span>.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2>
<h3><span id="树">树</span></h3>
<ol type="1">
<li>随机树树高为<span class="math inline">\(\sqrt n\)</span>.</li>
<li>点的度数期望为<span class="math inline">\(\log n\)</span>.</li>
</ol>
<h3><span id="数">数</span></h3>
<ol type="1">
<li>数字的期望因数个数为<span class="math inline">\(\log
V\)</span>.</li>
</ol>
<h3><span id="序列">序列</span></h3>
<ol type="1">
<li>随机序列的LIS长度期望为<span class="math inline">\(O(\sqrt
n)\)</span>.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</li>
<li>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</li>
<li>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O(f(n))\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1-(1-p)^k\)</span>,时间复杂度为<span class="math inline">\(O(kf(n))\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要枚举一些元素.</li>
<li>设这个算法的复杂度为<span class="math inline">\(O(f(n)g(n))\)</span>,其中<span class="math inline">\(f(n)\)</span>为枚举部分的复杂度,<span class="math inline">\(g(n)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g(n)\)</span>不会很大.</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机化寻找元素来降低复杂度.</li>
<li>计算随机化情况下的正确率以及复杂度.</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要用到一个或多个传入的元素.</li>
<li>这个元素的值不应该依赖于输入数据.</li>
<li>我们可以通过check这个元素来得到与答案有关的信息.</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机这个元素.</li>
<li>计算随机化情况下的正确率以及复杂度</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n\leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O(n^3)\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil\frac{n}{7}\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{1}{7}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{1}{49}\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1-(\frac{48}{49})^{1000}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{n}{2}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n\leq
10^6\)</span>,<span class="math inline">\(a_i\leq 10^{12}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{1}{2}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O(n\sqrt a)\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt
a\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([l,r]\)</span>,问<span class="math inline">\(a[l,r]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\((n,m\leq 500000,1\leq a_i\leq n)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k=2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O(n^2d)\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A=\begin{bmatrix}\vec{a_1},\vec{a_2},...,\vec{a_n}\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B=AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{i,j}\)</span>在<span class="math inline">\(\mod
2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B=C\)</span>,那么对于任意一个<span class="math inline">\(X_{m\times n}\)</span>都应该满足<span class="math inline">\(XB=XC\)</span>,取<span class="math inline">\(m=1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB\ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O(nd)\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O(n)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D=B-C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{i,j}\ne 0\)</span>.我们令<span class="math inline">\(E=X\times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j=\sum_{k}X_kD_{k,j}\)</span>,不难解得:<span class="math inline">\(E_i=-\frac{1}{D_{i,j}}\sum_{k\ne
i}X_kD_{k,j}\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{1}2\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O(nd)\)</span>.</p>
<p><span class="math inline">\(k=3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{j}B_{i,j}^2X_j=\sum_{j}B_{i,j}X_jB_{h,i}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要枚举全排列.</li>
<li>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机化寻找排列来降低复杂度.</li>
<li>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T(n)\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:
<span class="math display">\[
T(0)=0\\
T(n)=n+\frac{1}{n}\sum_{i=0}^{n-1}(T_i+T_{n-i-1})
\]</span> 做放缩(可能有些地方需要<span class="math inline">\(+1\)</span>或者<span class="math inline">\(-1\)</span>或者加取整,但是问题不大,反正是期望):
<span class="math display">\[
T(n)=n+\frac{1}{n}\sum_{i=0}^{n-1}(T_i+T_{n-i-1})\\
=n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{n-1}(T_i+T_{n-i-1})\\
=n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{\frac{3n}{4}}(T(i)+T(n-i-1))+\frac{2}{n}\sum_{i=\frac{3n}{4}}^{n}(T(i)+T(n-i-1))
\]</span> 由于<span class="math inline">\(T(n)\geq
n\)</span>,所以对于<span class="math inline">\(\frac{n}2\leq i\leq
j\)</span>,我们显然有:<span class="math inline">\(T(i)+T(n-i)\leq
T(j)+T(n-j)\)</span>.</p>
<p>因此: <span class="math display">\[
T(n)\leq
n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{\frac{3n}{4}}(T(\frac{3n}{4})+T(\frac{n}{4}))+\frac{2}{n}\sum_{i=\frac{3n}{4}}^{n}(T(n-1)+T(0))\\
\leq n+\frac{1}{2}(T(\frac{3n}{4})+T(\frac{n}{4})+T(n-1))
\]</span> 我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T(n)\leq cn\log n\)</span>,考虑使用数学归纳法,则:
<span class="math display">\[
T(n)\leq
n+\frac{1}2(\frac{3cn}4\log(\frac{3n}{4})+\frac{cn}4\log(\frac{n}{4})+c(n-1)\log(n-1))\\
\leq n+c(\frac{3n}{8}\log n-\frac{3n}{8}\log\frac{4}{3}+\frac{n}{8}\log
n-\frac{n}{4}+\frac{n}{2}\log n)\\
=cn\log n+n(1-\frac{3c}{8}\log(\frac{4}{3})-\frac{c}{4})
\]</span> 于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O(f(n))\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则: <span class="math display">\[
k=\sum_{i=1}^{\infty}p(1-p)^{i-1}i\\
(1-p)k=\sum_{i=1}^{\infty}p(1-p)^ii\\
pk=\sum_{i=2}^{\infty}p(1-p)^{i-1}=p\sum_{i=0}^{\infty}(1-p)^i\\
k=\frac 1 p
\]</span> 则期望复杂度为<span class="math inline">\(O(\frac{f(n)}{p})\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([x_1,x_2)\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1\times 2\leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{1}{2}\)</span>),而此时的<span class="math inline">\([x_1,x_2)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1,2,4,...\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式: <span class="math display">\[
P=\begin{cases}1&amp;E_{t+1}&gt;E_t\\e^{\frac{E_{t+1}-E_t}{T}}&amp;E_{t+1}\leq
E_t\end{cases}
\]</span> 具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k\in(0,1)\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T=kT\)</span>,直到其小于终止温度.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>文化课数学导论</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#文化课数学导论">文化课数学导论</a>
<ul>
<li><a href="#概统导论">概统导论</a>
<ul>
<li><a href="#习惯的更改">习惯的更改</a></li>
<li><a href="#从线性角度审视">从线性角度审视</a></li>
<li><a href="#分布列">分布列</a>
<ul>
<li><a href="#两点分布">两点分布</a></li>
<li><a href="#二项式分布">二项式分布</a></li>
<li><a href="#超几何分布">超几何分布</a></li>
<li><a href="#正态分布">正态分布</a></li>
</ul></li>
<li><a href="#成对数据的统计">成对数据的统计</a>
<ul>
<li><a href="#样本相关系数">样本相关系数</a></li>
<li><a href="#最小二乘法">最小二乘法</a></li>
<li><a href="#独立性检验">独立性检验</a></li>
</ul></li>
</ul></li>
<li><a href="#函数导论">函数导论</a>
<ul>
<li><a href="#常用对数表">常用对数表</a></li>
<li><a href="#常用指数表">常用指数表</a></li>
<li><a href="#基本函数的图像及性质">基本函数的图像及性质</a>
<ul>
<li><a href="#fxxex"><span class="math inline">\(f(x)=xe^x\)</span></a>
<ul>
<li><a href="#图像">图像</a></li>
<li><a href="#极值与极限">极值与极限</a></li>
</ul></li>
<li><a href="#fxxln-x"><span class="math inline">\(f(x)=x\ln
x\)</span></a>
<ul>
<li><a href="#图像-1">图像</a></li>
<li><a href="#极值与极限-1">极值与极限</a></li>
</ul></li>
<li><a href="#fxfracexx"><span class="math inline">\(f(x)=\frac{e^x}{x}\)</span></a>
<ul>
<li><a href="#图像-2">图像</a></li>
<li><a href="#极值与极限-2">极值与极限</a></li>
</ul></li>
<li><a href="#fxfracln-xx"><span class="math inline">\(f(x)=\frac{\ln
x}{x}\)</span></a>
<ul>
<li><a href="#图像-3">图像</a></li>
<li><a href="#极值与极限-3">极值与极限</a></li>
</ul></li>
<li><a href="#fxx-ln-x"><span class="math inline">\(f(x)=x-\ln
x\)</span></a>
<ul>
<li><a href="#图像-4">图像</a></li>
<li><a href="#极值与极限-4">极值与极限</a></li>
</ul></li>
<li><a href="#fxfracxex"><span class="math inline">\(f(x)=\frac{x}{e^x}\)</span></a>
<ul>
<li><a href="#图像-5">图像</a></li>
<li><a href="#极值与极限-5">极值与极限</a></li>
</ul></li>
</ul></li>
<li><a href="#预处理函数">预处理函数</a>
<ul>
<li><a href="#分离对数">分离对数</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#消去指数">消去指数</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#消元法">消元法</a>
<ul>
<li><a href="#变化条件">变化条件</a>
<ul>
<li><a href="#example-2">Example</a></li>
</ul></li>
<li><a href="#变化所求">变化所求</a>
<ul>
<li><a href="#example-3">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#换元法">换元法</a>
<ul>
<li><a href="#普通参数方程">普通参数方程</a>
<ul>
<li><a href="#example-4">Example</a></li>
</ul></li>
<li><a href="#齐次化构造">齐次化构造</a>
<ul>
<li><a href="#example1对数平均不等式">Example1(对数平均不等式)</a></li>
<li><a href="#example2">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
</ul></li>
<li><a href="#同构化构造">同构化构造</a>
<ul>
<li><a href="#example1">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#不等式相关">不等式相关</a>
<ul>
<li><a href="#基本不等式相关">基本不等式相关</a>
<ul>
<li><a href="#方程角度的审视">方程角度的审视</a></li>
<li><a href="#example-5">Example</a></li>
</ul></li>
<li><a href="#泰勒展开">泰勒展开</a>
<ul>
<li><a href="#抽象函数的泰勒展开">抽象函数的泰勒展开</a></li>
<li><a href="#常用泰勒展开公式">常用泰勒展开公式</a></li>
</ul></li>
<li><a href="#极值点偏移">极值点偏移</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul></li>
<li><a href="#切割线放缩">切割线放缩</a>
<ul>
<li><a href="#基本的切割线不等式">基本的切割线不等式</a></li>
<li><a href="#一般的切割线放缩">一般的切割线放缩</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#凹凸性反转">凹凸性反转</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
<li><a href="#比较大小">比较大小</a>
<ul>
<li><a href="#example1-4">Example1</a>
<ul>
<li><a href="#二阶导数">二阶导数</a></li>
<li><a href="#估算定积分">估算定积分</a></li>
<li><a href="#泰勒展开-1">泰勒展开</a></li>
<li><a href="#正经做法">正经做法</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数列导论">数列导论</a>
<ul>
<li><a href="#递归式的求解">递归式的求解</a>
<ul>
<li><a href="#特征根法">特征根法</a>
<ul>
<li><a href="#特征方程">特征方程</a></li>
<li><a href="#二阶线性齐次递推">二阶线性齐次递推</a></li>
<li><a href="#更一般的情况">更一般的情况</a>
<ul>
<li><a href="#重定义向">重定义向</a></li>
<li><a href="#引入矩阵">引入矩阵</a></li>
<li><a href="#再进一步">再进一步</a></li>
<li><a href="#再再进一步">再再进一步</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数列中的求和问题">数列中的求和问题</a>
<ul>
<li><a href="#和式的基本运算">和式的基本运算</a></li>
<li><a href="#交换顺序法">交换顺序法</a>
<ul>
<li><a href="#example1等差数列求和">Example1(等差数列求和)</a></li>
<li><a href="#example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</a></li>
<li><a href="#example3拉格朗日恒等式">Example3(拉格朗日恒等式)</a></li>
</ul></li>
<li><a href="#扰动法">扰动法</a>
<ul>
<li><a href="#example1等比数列求和">Example1(等比数列求和)</a></li>
<li><a href="#example2平方和公式">Example2(平方和公式)</a></li>
</ul></li>
<li><a href="#展开和收缩">展开和收缩</a>
<ul>
<li><a href="#example1平方和公式">Example1(平方和公式)</a></li>
<li><a href="#problme3">Problme3</a></li>
<li><a href="#solution3">Solution3</a></li>
<li><a href="#problemex2">ProblemEX2</a></li>
<li><a href="#solutionex2">SolutionEX2</a></li>
</ul></li>
<li><a href="#有限微积分">有限微积分</a>
<ul>
<li><a href="#移位算子">移位算子</a></li>
<li><a href="#差分算子">差分算子</a></li>
<li><a href="#逆差分算子">逆差分算子</a></li>
<li><a href="#定和式">定和式</a></li>
<li><a href="#一些基本的公式">一些基本的公式</a></li>
<li><a href="#分部求和法则abel求和法">分部求和法则(Abel求和法)</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#基础数论在数列中的应用">基础数论在数列中的应用</a>
<ul>
<li><a href="#example-6">Example</a></li>
</ul></li>
<li><a href="#构造双射在数列中的应用">构造双射在数列中的应用</a></li>
<li><a href="#不等式放缩在数列中的应用">不等式放缩在数列中的应用</a></li>
</ul></li>
<li><a href="#几何导论">几何导论</a>
<ul>
<li><a href="#三角相关">三角相关</a>
<ul>
<li><a href="#三角恒等变换">三角恒等变换</a>
<ul>
<li><a href="#两角和差公式">两角和差公式</a></li>
<li><a href="#倍角公式">倍角公式</a></li>
<li><a href="#半角公式">半角公式</a></li>
<li><a href="#和差化积">和差化积</a></li>
<li><a href="#积化和差">积化和差</a></li>
<li><a href="#万能公式">万能公式</a></li>
<li><a href="#补充公式">补充公式</a></li>
</ul></li>
<li><a href="#周期函数与初等数论">周期函数与初等数论</a>
<ul>
<li><a href="#example1-6">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#向量相关">向量相关</a>
<ul>
<li><a href="#旋转模型">旋转模型</a>
<ul>
<li><a href="#example1-7">Example1</a></li>
</ul></li>
<li><a href="#爪子模型">爪子模型</a>
<ul>
<li><a href="#example1-8">Example1</a></li>
</ul></li>
<li><a href="#奔驰定理及三角形四心">奔驰定理及三角形四心</a>
<ul>
<li><a href="#奔驰定理">奔驰定理</a></li>
<li><a href="#外心">外心</a>
<ul>
<li><a href="#example1-9">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
</ul></li>
<li><a href="#重心">重心</a></li>
<li><a href="#垂心">垂心</a></li>
<li><a href="#内心">内心</a></li>
</ul></li>
</ul></li>
<li><a href="#立体几何相关">立体几何相关</a>
<ul>
<li><a href="#基本概念">基本概念</a>
<ul>
<li><a href="#直线">直线</a></li>
<li><a href="#平面">平面</a></li>
<li><a href="#夹角">夹角</a>
<ul>
<li><a href="#两直线夹角">两直线夹角.</a></li>
<li><a href="#直线与平面的夹角">直线与平面的夹角</a></li>
</ul></li>
<li><a href="#交点">交点</a></li>
</ul></li>
<li><a href="#基本定理">基本定理</a>
<ul>
<li><a href="#三余弦定理最小角定理">三余弦定理(最小角定理)</a></li>
<li><a href="#三正弦定理最大角定理">三正弦定理(最大角定理)</a></li>
</ul></li>
</ul></li>
<li><a href="#圆锥曲线">圆锥曲线</a>
<ul>
<li><a href="#约定">约定</a></li>
<li><a href="#椭圆">椭圆</a>
<ul>
<li><a href="#定义">定义</a>
<ul>
<li><a href="#第一定义">第一定义</a></li>
<li><a href="#第二定义">第二定义</a></li>
<li><a href="#第三定义">第三定义</a></li>
</ul></li>
<li><a href="#椭圆方程">椭圆方程</a>
<ul>
<li><a href="#标准方程">标准方程</a></li>
<li><a href="#一般方程">一般方程</a></li>
</ul></li>
<li><a href="#椭圆重要元素">椭圆重要元素</a>
<ul>
<li><a href="#焦半径">焦半径</a></li>
<li><a href="#焦点弦">焦点弦</a></li>
<li><a href="#焦点三角形">焦点三角形</a></li>
</ul></li>
<li><a href="#example-7">Example</a>
<ul>
<li><a href="#example1-10">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#双曲线">双曲线</a>
<ul>
<li><a href="#定义-1">定义</a>
<ul>
<li><a href="#第一定义-1">第一定义</a></li>
<li><a href="#第二定义-1">第二定义</a></li>
<li><a href="#第三定义-1">第三定义</a></li>
</ul></li>
<li><a href="#双曲线重要元素">双曲线重要元素</a>
<ul>
<li><a href="#焦半径-1">焦半径</a></li>
<li><a href="#渐近线">渐近线</a></li>
<li><a href="#焦点三角形-1">焦点三角形</a></li>
</ul></li>
</ul></li>
<li><a href="#抛物线">抛物线</a>
<ul>
<li><a href="#定义-2">定义</a>
<ul>
<li><a href="#第一定义-2">第一定义</a></li>
</ul></li>
<li><a href="#抛物线重要元素">抛物线重要元素</a>
<ul>
<li><a href="#焦点弦-1">焦点弦</a></li>
</ul></li>
</ul></li>
<li><a href="#通用解法">通用解法</a>
<ul>
<li><a href="#联立方程">联立方程</a>
<ul>
<li><a href="#点参">点参</a></li>
<li><a href="#小联立">小联立</a></li>
<li><a href="#大联立">大联立</a></li>
<li><a href="#配凑法">配凑法</a></li>
<li><a href="#应用">应用</a></li>
</ul></li>
<li><a href="#极点极线">极点极线</a>
<ul>
<li><a href="#定义-3">定义</a></li>
<li><a href="#基本性质">基本性质</a></li>
<li><a href="#使用方法">使用方法</a></li>
</ul></li>
<li><a href="#隐函数求导">隐函数求导</a></li>
<li><a href="#线性变换">线性变换</a>
<ul>
<li><a href="#旋转矩阵">旋转矩阵</a></li>
<li><a href="#椭圆转化成圆">椭圆转化成圆</a></li>
<li><a href="#双曲线转化为反比例函数">双曲线转化为反比例函数</a></li>
<li><a href="#抛物线转化为二次函数">抛物线转化为二次函数</a></li>
</ul></li>
<li><a href="#极坐标">极坐标</a>
<ul>
<li><a href="#圆的极坐标方程">圆的极坐标方程</a></li>
<li><a href="#直线的极坐标方程">直线的极坐标方程</a></li>
<li><a href="#圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</a></li>
</ul></li>
<li><a href="#参数方程">参数方程</a>
<ul>
<li><a href="#圆的参数方程">圆的参数方程</a></li>
<li><a href="#直线的参数方程">直线的参数方程</a></li>
<li><a href="#椭圆的参数方程">椭圆的参数方程</a></li>
<li><a href="#双曲线的参数方程">双曲线的参数方程</a></li>
<li><a href="#抛物线的参数方程">抛物线的参数方程</a></li>
</ul></li>
<li><a href="#蒙日圆">蒙日圆</a>
<ul>
<li><a href="#定义-4">定义</a></li>
<li><a href="#方程">方程</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h1><span id="文化课数学导论">文化课数学导论</span></h1>
<h2><span id="概统导论">概统导论</span></h2>
<h3><span id="习惯的更改">习惯的更改</span></h3>
<p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将<span class="math inline">\(C_{n}^k\)</span>写作<span class="math inline">\(\binom{n}{k}\)</span>,而文化课中不允许此类更改,再者文化课中将<span class="math inline">\(C_{n}^ka^{n-k}b^k\)</span>称作二项式的第<span class="math inline">\(k+1\)</span>项(从第<span class="math inline">\(1\)</span>项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3>
<p>首先我们有<span class="math inline">\(E(aX+b)=aE(X)+b,D(aX+b)=a^2D(X)\)</span>.</p>
<p>我们都知道期望满足线性可加,也就是<span class="math inline">\(E(X_1+X_2)=E(X_1)+E(X_2)\)</span>,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若<span class="math inline">\(X_1\)</span>和<span class="math inline">\(X_2\)</span>相互独立,<span class="math inline">\(E(X_1X_2)=E(X_1)E(X_2)\)</span>,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要<span class="math inline">\(X_1\)</span>和<span class="math inline">\(X_2\)</span>相互独立,<span class="math inline">\(D(X_1+X_2)=D(X_1)+D(X_2)\)</span>.从形式上证明是好证明的,我们考虑:
<span class="math display">\[
D(X_1+X_2)=E((X_1+X_2)^2)-E^2(X_1+X_2)\\
=E(X_1^2)+E(2X_1X_2)+E(X_2^2)-E^2(X_1+X_2)\\
=E(X_1^2)+2E(X_1)E(X_2)+E(X_2^2)-(E(X_1)+E(X_2))^2\\
=E(X_1^2)-E^2(X_1)+E(X_2^2)-E^2(X_2)\\
=D(X_1)+D(X_2)
\]</span> 或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为<span class="math inline">\(0\)</span>,不然<span class="math inline">\(D(X_1+X_2)\)</span>要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为<span class="math inline">\(0\)</span>,并且缩放权值,使得方差恰好为<span class="math inline">\(1\)</span>.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为<span class="math inline">\(0\)</span>的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3>
<h4><span id="两点分布">两点分布</span></h4>
<p>直接写的话也就是<span class="math inline">\(P(X)=\begin{cases}p&amp;X=1\\1-p&amp;X=0\\0&amp;other\end{cases}\)</span>,事实上这么写可能不太严谨,因为两点分布的<span class="math inline">\(X=1\)</span>和<span class="math inline">\(X=0\)</span>两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是<span class="math inline">\(G(x)=(1-p)+px\)</span>.由此式子轻松推得<span class="math inline">\(E(x)=G&#39;(1)=p,D(x)=E(x^2)-E^2(x)=G&#39;&#39;(1)+G&#39;(1)-(G&#39;(1))^2=p-p^2=p(1-p)\)</span>.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4>
<p>所谓<span class="math inline">\(n\)</span>重伯努利试验,也就是<span class="math inline">\(n\)</span>次两点分布的累计,满足<span class="math inline">\(P(X=k)=C_{n}^k(1-p)^{n-k}p^k\)</span>,我们关注两个事情,也就是二项式分布的<span class="math inline">\(E(X)=np,D(X)=np(1-p)\)</span>,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4>
<p>所谓不放回取球,考虑目前有<span class="math inline">\(N\)</span>个数字,有<span class="math inline">\(M\)</span>个是<span class="math inline">\(1\)</span>,剩下<span class="math inline">\(N-M\)</span>个是<span class="math inline">\(0\)</span>,取出<span class="math inline">\(n\)</span>次,取出了<span class="math inline">\(m\)</span>个<span class="math inline">\(1\)</span>的概率.简单组合一下得到此概率为<span class="math inline">\(\frac{C_{M}^mC_{N-M}^{n-m}}{C_{N}^n}\\\)</span>,注意这里必须保证<span class="math inline">\(n\leq N\)</span>.</p>
<p>由范德蒙德卷积得知,<span class="math inline">\(\sum_{m}C_{M}^mC_{N-M}^{n-m}=C_{N}^n\)</span>,因此该分布列所有情况之和为<span class="math inline">\(1\)</span>.</p>
<p>考虑其均值,从感性上讲必定是<span class="math inline">\(\frac{nM}{N}\)</span>.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如<span class="math inline">\(01101\)</span>之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到<span class="math inline">\(1\)</span>的概率,和第二次取得到<span class="math inline">\(1\)</span>的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是<span class="math inline">\(n\frac{N(N-M)(N-n)}{N^2(N-1)}\)</span>,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4>
<p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写<span class="math inline">\(f(x)=\frac{e^{-\frac{(x-\mu)^2}{2\sigma^2}}}{\sigma\sqrt{2\pi}}\\\)</span>,是不是看着非常震撼!其中的方差是<span class="math inline">\(\sigma^2\)</span>,期望是<span class="math inline">\(\mu\)</span>.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足<span class="math inline">\(\sigma=1,\mu=0\)</span>,此时的函数也就是<span class="math inline">\(f(x)=\frac{e^{-\frac{x^2}{2}}}{\sqrt
{2\pi}}\)</span>.一个好奇是,你凭啥说所有情况下的概率之和为<span class="math inline">\(1\)</span>,事实上这其实是因为<span class="math inline">\(g(x)=e^{-x^2}\)</span>的积分是<span class="math inline">\(\sqrt \pi\)</span>,不会求这个积分.</p>
<p>观察<span class="math inline">\(g(x)=e^{-x^2}\)</span>这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数<span class="math inline">\(e^{-|x|}\)</span>模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是<span class="math inline">\(\sigma\)</span>的由来,将<span class="math inline">\(x\rightarrow \sigma x\)</span>,也就是在<span class="math inline">\(x\)</span>那里除去一个<span class="math inline">\(\sigma\)</span>.而对这个曲线进行横向移动,也就是将<span class="math inline">\(x\rightarrow x-\mu\)</span>.</p>
<p>这也就引出所谓的<span class="math inline">\(3\sigma\)</span>原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3>
<h4><span id="样本相关系数">样本相关系数</span></h4>
<p>对于若干数据<span class="math inline">\((x_i,y_i)\)</span>,我们先进行标准化,也就是减去均值后再除以方差,这样做使得<span class="math inline">\(x,y\)</span>分别的均值为<span class="math inline">\(0\)</span>,方差为<span class="math inline">\(1\)</span>.下面默认已经标准化过了.</p>
<p>不妨构造<span class="math inline">\(n\)</span>维向量<span class="math inline">\(\vec x=(x_1,x_2,\cdots ,x_n),\vec
y=(y_1,y_2,\cdots ,y_n)\)</span>,考虑它们的点乘<span class="math inline">\(\vec x\sdot \vec
y\)</span>,不难发现由于方差为<span class="math inline">\(1\)</span>,因此<span class="math inline">\(|\vec
x|=|\vec y|=\sqrt n\)</span>,因此它们的点乘为<span class="math inline">\(n\cos \theta\)</span>,设<span class="math inline">\(r=\frac{\vec x\sdot \vec y}n=\cos
\theta\)</span>.</p>
<p>如果<span class="math inline">\(\exist k\)</span>,<span class="math inline">\(\forall i,y_i=kx_i\)</span>,此时必有<span class="math inline">\(|r|=1\)</span>,因此我们断言(为啥呢?其实是不太理解的啊)当<span class="math inline">\(|r|\)</span>越靠近<span class="math inline">\(1\)</span>的时候,<span class="math inline">\(x,y\)</span>之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4>
<p>我们在上面的角度审视中提出了一个观点:在满足均值为<span class="math inline">\(0\)</span>的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:<span class="math inline">\(Y=bx+a+e,E(e)=0,D(e)=\sigma^2\)</span>.</p>
<p>现在我们要做的就是,已知若干组数据<span class="math inline">\((x_i,y_i)\)</span>,去构造一组<span class="math inline">\(a,b\)</span>满足上面的条件.不妨令<span class="math inline">\(e_i=y_i-(bx_i+a)\)</span>,若<span class="math inline">\(\sum e_i=0\)</span>,必有<span class="math inline">\(a=\bar y-b\bar x\)</span>,带入解得当<span class="math inline">\(\sigma\)</span>最小的时候,<span class="math inline">\(b=\frac{\sum_{i}(x_i-\bar x)(y_i-\bar
y)}{\sum_{i}(x_i-\bar x)^2}\\\)</span>.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个<span class="math inline">\(b\)</span>使得<span class="math inline">\(\sigma\)</span>最小,标准化说到底只是为了保证<span class="math inline">\(\sigma=1\)</span>的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4>
<p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知<span class="math inline">\(P(AB)=P(A)P(B)\)</span>,那么我们反推,如果我们在现实中的估计中,发现<span class="math inline">\(P(AB)\)</span>和<span class="math inline">\(P(A)P(B)\)</span>差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:<span class="math inline">\(P(00)=\frac{a}{n},P(01)=\frac{b}n,P(10)=\frac
cn,P(11)=\frac dn\)</span>.那么<span class="math inline">\(P(A=0)P(B=0)=\frac{(a+b)(a+c)}{n^2}\)</span>.我们计算它与<span class="math inline">\(P(00)\)</span>的差,平方后除以<span class="math inline">\(P(A=0)P(B=0)\)</span>然后做四遍求和化简,得到<span class="math inline">\(\chi^2=\frac{n(ad-bc)^2}{(a+b)(a+c)(c+d)(b+d)}\)</span>.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么<span class="math inline">\(P(\chi^2\geq
x_\alpha)=\alpha\)</span>.或者给出我们经验上的准则:</p>
<p>选取一个较小的<span class="math inline">\(\alpha\)</span>,并得知其对应的<span class="math inline">\(x_\alpha\)</span>,如果<span class="math inline">\(\chi^2\geq
x_\alpha\)</span>,推断独立性不成立,犯错的概率是<span class="math inline">\(\alpha\)</span>.反之断言其独立性成立,犯错的概率不可知,肯定<span class="math inline">\(\alpha\)</span>越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2>
<h3><span id="常用对数表">常用对数表</span></h3>
<ol type="1">
<li><span class="math inline">\(\ln2=0.693\)</span>.</li>
<li><span class="math inline">\(\ln3=1.099\)</span>.</li>
<li><span class="math inline">\(\ln 5=1.609\)</span>.</li>
<li><span class="math inline">\(\ln 0.1=-2.303\)</span>.</li>
<li><span class="math inline">\(\ln0.5=-0.693\)</span>.</li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3>
<ol type="1">
<li><span class="math inline">\(e=2.718\)</span>.</li>
<li><span class="math inline">\(e^2=7.389\)</span>.</li>
<li><span class="math inline">\(e^3=20.086\)</span>.</li>
<li><span class="math inline">\(e^5=148.413\)</span>.</li>
<li><span class="math inline">\(e^{0.1}=1.105\)</span>.</li>
<li><span class="math inline">\(e^{0.5}=1.649\)</span>.</li>
<li><span class="math inline">\(e^\pi=23.147\)</span>.</li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3>
<h4><span id="fxxex"><span class="math inline">\(f(x)=xe^x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f&#39;(x)=(x+1)e^x\)</span>,<span class="math inline">\(x=-1\)</span>的时候,取最小值<span class="math inline">\(-\frac{1}{e}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{x\rightarrow
-\infty}f(x)=0\\\)</span>.</p>
<hr>
<h4><span id="fxxln-x"><span class="math inline">\(f(x)=x\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f&#39;(x)=1+\ln
x,x=\frac{1}{e}\)</span>的时候,有最小值<span class="math inline">\(-\frac{1}{e}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{x\rightarrow
0^{+}}f(x)=0\\\)</span>.</p>
<hr>
<h4><span id="fxfracexx"><span class="math inline">\(f(x)=\frac{e^x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e%5Exdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f&#39;(x)=\frac{e^x(x-1)}{x^2},x=1\)</span>的时候,有极小值<span class="math inline">\(e\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{x\rightarrow
-\infty}f(x)=0\\\)</span>.</p>
<hr>
<h4><span id="fxfraclnxx"><span class="math inline">\(f(x)=\frac{\ln
x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f&#39;(x)=\frac{1-\ln
x}{x^2},x=e\)</span>的时候,有极大值<span class="math inline">\(\frac{1}{e}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{x\rightarrow
+\infty}f(x)=0\\\)</span>.</p>
<hr>
<h4><span id="fxx-ln-x"><span class="math inline">\(f(x)=x-\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f&#39;(x)=1-\frac{1}{x},x=1\)</span>的时候,有最小值<span class="math inline">\(1\)</span>.</p>
<hr>
<h4><span id="fxfracxex"><span class="math inline">\(f(x)=\frac{x}{e^x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f&#39;(x)=\frac{1-x}{e^x},x=1\)</span>的时候,有最大值<span class="math inline">\(\frac{1}{e}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{x\rightarrow
+\infty}f(x)=0\\\)</span>.</p>
<h3><span id="预处理函数">预处理函数</span></h3>
<h4><span id="分离对数">分离对数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令<span class="math inline">\(f(x)=(2+x+ax^2)\ln(x+1)-2x\)</span>,已知<span class="math inline">\(x=0\)</span>是极大值点,求<span class="math inline">\(a\)</span>.</p>
<p>考虑分离对数后操作多项式,我们显然可找到<span class="math inline">\(0&lt;t&lt;1,2+t+at^2&gt;0,2-t+at^2&gt;0\)</span>,下面只考虑<span class="math inline">\(x\in[-t,t]\)</span>.此时<span class="math inline">\(f(x)=(2+x+ax^2)(\ln(x+1)-\frac{2x}{2+x+ax^2})\)</span>.</p>
<p>考虑令<span class="math inline">\(g(x)=\ln(x+1)-\frac{2x}{2+x+ax^2}\)</span>,由于<span class="math inline">\(f(0)=0\)</span>,只需证明<span class="math inline">\(g(x)\leq 0,x\in[-t,t]\)</span>即可.</p>
<p>而: <span class="math display">\[
g&#39;(x)=\frac{1}{x+1}-\frac{4-2ax^2}{(2+x+ax^2)^2}\\
=\frac{x^2(a^2x^2+4ax+6a+1)}{(x+1)(2+x+ax^2)}\\
\text{sign}(g&#39;(x))=\text{sign}(a^2x^2+4ax+6a+1)
\]</span> 则<span class="math inline">\(a^20^2+4a0+6a+1=0\)</span>,<span class="math inline">\(a=-\frac{1}{6}\)</span>.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令<span class="math inline">\(f(x)=e^x-\ln(x+1)+ax^3-x^2-1\)</span>,若<span class="math inline">\(\forall x\in(-1,1),f(x)\geq 0\)</span>,求<span class="math inline">\(a\)</span>.</p>
<p><span class="math inline">\(f(0)=0\)</span>,于是上面的条件等价于<span class="math inline">\(0\)</span>是<span class="math inline">\((-1,1)\)</span>的最小值点.</p>
<p>考虑<span class="math inline">\(f&#39;(x)=e^x-\frac{1}{x+1}+3ax^2-2x\)</span>,则<span class="math inline">\(f&#39;(0)=0\)</span>恒成立.</p>
<p>讨论<span class="math inline">\(g(x)=1+e^{-x}(3ax^2-2x-\frac{1}{x+1})\)</span>的正负,看<span class="math inline">\(g&#39;(x)=\frac{x(-3ax^3+2x^2+(9a+2)x+6a-1)}{(x+1)^2e^x}\)</span>.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3>
<h4><span id="变化条件">变化条件</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(x+2y=1\)</span>,求<span class="math inline">\(x^2+y^2\)</span>的最小值.</p>
<p>直接令<span class="math inline">\(x=1-2y\)</span>,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(x^2+y^3=2\)</span>,求<span class="math inline">\(x+y\)</span>的最小值.</p>
<p>这个的话不妨设其最小值为<span class="math inline">\(C\)</span>,有<span class="math inline">\(x+y\geq
C\)</span>,移项得到<span class="math inline">\(y\geq
C-x\)</span>,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3>
<h4><span id="普通参数方程">普通参数方程</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(x^2+y^2-xy=1\)</span>,求<span class="math inline">\(x+y\)</span>的最小值.</p>
<p>这个的话大概是这样,我们找到一个<span class="math inline">\(t\)</span>,使得<span class="math inline">\(x=f(t),y=g(t)\)</span>,然后换元.</p>
<p>比如这个题,你就可以凑成<span class="math inline">\((x-\frac{y}{2})^2+(\frac{\sqrt
3}{2}y)^2=1\)</span>,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4>
<h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5>
<p>求证<span class="math inline">\(\sqrt {ab}&lt;\frac{a-b}{\ln a-\ln
b}&lt; \frac{a+b}{2}\)</span>.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.
<span class="math display">\[
\frac{a-b}{\ln a-\ln b}&lt; \frac{a+b}{2}\\
\frac{a-b}{a+b}&lt;\frac{\ln\frac{a}{b}}{2}\\
\frac{\frac{a}{b}-1}{\frac{a}{b}+1}&lt;\frac{\ln\frac{a}{b}}{2}
\]</span> 换元,令<span class="math inline">\(t=\frac{a}{b}\)</span>,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知函数<span class="math inline">\(f(x)=3\ln x-ax\)</span>,若<span class="math inline">\(x_1&lt;x_2\)</span>是<span class="math inline">\(f(x)\)</span>的两个零点,求证<span class="math inline">\(f&#39;(\frac{x_1+3x_2}{4})&lt;0\)</span>.</p>
<p>我们来分析已知,我们目前知道的是: <span class="math display">\[
\begin{cases}3\ln x_1=ax_1\\3\ln x_2=ax_2\end{cases}
\]</span> 我们想要知道的是:<span class="math inline">\(\frac{12}{x_1+3x_2}&lt;a\)</span>.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把<span class="math inline">\(a\)</span>给换掉,事实上我们根据前面的方程有<span class="math inline">\(a=\frac{3\ln\frac{x_2}{x_1}}{x_2-x_1}\)</span>.</p>
<p>于是我们只需要证明:<span class="math inline">\(\frac{x_1+3x_2}{4}&gt;\frac{x_2-x_1}{\ln\frac{x_2}{x_1}}\)</span>,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5>
<p>已知函数<span class="math inline">\(f(x)=\ln
x-ax\)</span>,其有两个零点<span class="math inline">\(x_1\ne
x_2\)</span>,求证<span class="math inline">\(x_1x_2&gt;e^2\)</span>.</p>
<p>同样分析已知,我们得到的是: <span class="math display">\[
\begin{cases}\ln x_1=ax_1\\\ln x_2=ax_2\end{cases}
\]</span>
通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:
<span class="math display">\[
\begin{cases}\ln x_2-\ln x_1=a(x_2-x_1)\\\ln x_2+\ln
x_1=a(x_2+x_1)\end{cases}
\]</span> 这里先把所求变形一下,我们把它改成<span class="math inline">\(\ln x_1+\ln x_2&gt;2\)</span>.</p>
<p>发现了什么?这个东西等价于<span class="math inline">\(a(x_2+x_1)&gt;2\)</span>,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换<span class="math inline">\(a\)</span>即可.</p>
<h5><span id="example4">Example4</span></h5>
<p>已知<span class="math inline">\(f(x)=x^2+axe^x-ae^{2x}\)</span>有三个不同的零点<span class="math inline">\(x_1&lt;x_2&lt;x_3\)</span>,求<span class="math inline">\(a\)</span>的范围,并求证<span class="math inline">\((1-\frac{x_1}{e^{x_1}})^2(1-\frac{x_2}{e^{x_2}})(1-\frac{x_3}{e^{x_3}})=1\)</span>.</p>
<p>考虑两边同时除以<span class="math inline">\(e^{2x}\)</span>,这样得到<span class="math inline">\(g(x)=(\frac{x}{e^x})^2+a\frac{x}{e^x}-a\)</span>,令<span class="math inline">\(t=\frac{x}{e^x}\)</span>得到<span class="math inline">\(g(t)=t^2+at-a=0\)</span>.</p>
<p>考察<span class="math inline">\(g(t)=0\)</span>的两根<span class="math inline">\(t_1&lt;t_2\)</span>,根据韦达定理,首先需要满足<span class="math inline">\(\Delta=a^2+4a&gt;0\Rightarrow
a&gt;0\)</span>,然后<span class="math inline">\(t_1+t_2=-a,t_1t_2=-a\)</span>.</p>
<p>接下来考察函数<span class="math inline">\(\frac{x}{e^x}\)</span>,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为<span class="math inline">\(t_1,t_2\)</span>中必有一负,因此<span class="math inline">\(t_2\in(0,\frac{1}{e})\)</span>.由此立得<span class="math inline">\(0&lt;a&lt;\frac{1}{e(e-1)}\)</span>.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>若<span class="math inline">\(x&gt;0\)</span>时,<span class="math inline">\(ax(e^{ax}+1)\geq 2(x^2+1)\ln
x\)</span>恒成立,求<span class="math inline">\(a\)</span>取值范围.</p>
<p>一般这种题先判<span class="math inline">\(a\)</span>的正负,注意到<span class="math inline">\(x&gt;1\)</span>的时候右边恒大于<span class="math inline">\(0\)</span>,因此<span class="math inline">\(a&gt;0\)</span>.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数<span class="math inline">\(2\)</span>放进<span class="math inline">\(\ln\)</span>,自然有:<span class="math inline">\(ax(e^{ax}+1)\geq (x^2+1)\ln x^2\)</span>.</p>
<p>考虑令<span class="math inline">\(t_1=ax,t_2=\ln x^2\)</span>,则:
<span class="math display">\[
t_1(e^{t_1}+1)\geq t_2(e^{t_2}+1)
\]</span> 接下来分析函数<span class="math inline">\(f(x)=x(e^x+1)\)</span>的单调性,就可以得到<span class="math inline">\(a\geq\frac{2}{e}\)</span>.</p>
<h3><span id="不等式相关">不等式相关</span></h3>
<h4><span id="基本不等式相关">基本不等式相关</span></h4>
<h5><span id="方程角度的审视">方程角度的审视</span></h5>
<p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造<span class="math inline">\(\frac{m}{n}=k\)</span>.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(n,m&gt;0,2m+n=nm\)</span>,求<span class="math inline">\(n+m+\sqrt {n^2+m^2}\)</span>的最小值.</p>
<p>这个题有一个方式是观察到<span class="math inline">\(n,m,\sqrt{n^2+m^2}\)</span>是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:
<span class="math display">\[
n+m+\sqrt {n^2+m^2}\geq k
\\\Leftarrow \sqrt{n^2+m^2}\geq k-n-m\\
\]</span> 如果<span class="math inline">\(n+m\geq
k\)</span>,那么不等式显然成立,下面只需要证明<span class="math inline">\(n+m&lt;k\)</span>的情况: <span class="math display">\[
\sqrt{n^2+m^2}\geq k-n-m\\
\Leftarrow n^2+m^2\geq (k-(n+m))^2\\
\Leftarrow k^2+(n+m)^2-2k(n+m)\leq n^2+m^2\\
\Leftarrow k^2+2nm-2k(n+m)\leq 0\\
\Leftarrow k^2+n(2-2k)+m(4-2k)\leq 0\\
\Leftarrow k^2\leq n(2k-2)+m(2k-4)
\]</span> 变形方程得到<span class="math inline">\(\frac{2}{n}+\frac{1}{m}=1\)</span>,使用这个式子来降次:
<span class="math display">\[
n(2k-2)+m(2k-4)=6k-8+\frac{n}{m}(2k-2)+\frac{m}{n}(4k-8)\\
\]</span> 要严谨一点的话我们需要证明<span class="math inline">\(4k-8\geq
0\)</span>,<span class="math inline">\(k\geq
2\)</span>.这非常简单,因为<span class="math inline">\(k\geq
n+m&gt;3\)</span>.</p>
<p>这就足够了么?不需要证明存在一个<span class="math inline">\(w=\frac{n}{m}\)</span>使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么: <span class="math display">\[
n(2k-2)+m(2k-4)\geq 6k-8+2\sqrt{8(k-1)(k-2)}
\]</span> 这个等号可以取到,也就是说,只要满足: <span class="math display">\[
k^2\leq6k-8+2\sqrt{8(k-1)(k-2)}
\]</span> 那么这个<span class="math inline">\(k\)</span>就是一个下界,特别地,如果满足: <span class="math display">\[
k^2=6k-8+2\sqrt{8(k-1)(k-2)}
\]</span> 那么这个<span class="math inline">\(k\)</span>就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到<span class="math inline">\(k=10\)</span>是一个解了),接下来我们必须求出一个<span class="math inline">\(k\)</span>. <span class="math display">\[
k^2=6k-8+2\sqrt{8(k-1)(k-2)}\\
k^2-6k+8=2\sqrt{8(k-1)(k-2)}\\
(k-4)(k-2)=2\sqrt{8(k-1)(k-2)}\\
\sqrt{k-2}=\frac{2\sqrt{8(k-1)}}{k-4}
\]</span>
我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个<span class="math inline">\(\sqrt{k-2}\)</span>带入到上面去! <span class="math display">\[
(k-4)(k-2)=2\sqrt{8(k-1)}\frac{2\sqrt{8(k-1)}}{k-4}\\
(k-4)(k-2)=\frac{32(k-1)}{k-4}\\
\]</span>
我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说<span class="math inline">\(k=0\)</span>是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出<span class="math inline">\(k=10\)</span>.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4>
<h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5>
<p><span class="math display">\[
f(x)=\sum_{k\geq 0}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k\\
f(x)=\sum_{k\geq 0}\frac{f^{(k)}(0)}{k!}x^k\\
\]</span></p>
<h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5>
<ol type="1">
<li><span class="math inline">\(\frac{1}{1-x}=\sum_{k\geq
0}x^k=1+x+x^2+\cdots\\\)</span>.</li>
<li><span class="math inline">\(e^x=\sum_{k\geq
0}\frac{x^k}{k!}=1+x+\frac{1}{2!}x^2+\cdots\\\)</span>.</li>
<li><span class="math inline">\(\ln(1+x)=\sum_{k\geq
1}(-1)^{k-1}\frac{x^k}{k}=x-\frac{1}{2}x^2+\frac{1}{3}x^3+\cdots\\\)</span>.</li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>已知函数<span class="math inline">\(f(x)=\ln
x-ax\)</span>,其有两个零点<span class="math inline">\(x_1\ne
x_2\)</span>,求证<span class="math inline">\(x_1x_2&gt;e^2\)</span>.</p>
<p>极值点偏移的形式,应该是形如<span class="math inline">\(g(x)=a\)</span>有两个解<span class="math inline">\(x_1,x_2\)</span>,然后使得<span class="math inline">\(x_1+x_2\)</span>满足一定条件.因此我们先变形条件:
<span class="math display">\[
\begin{cases}\frac{\ln x_1}{x_1}=a\\\frac{\ln x_2}{x_2}=a\end{cases}
\]</span> 也就是目前我们构造出了函数<span class="math inline">\(g(x)=\frac{\ln x}{x}\)</span>,观察<span class="math inline">\(g(x)\)</span>图像立得<span class="math inline">\(x_1+x_2&gt;2e\)</span>.</p>
<p>我们发现,<span class="math inline">\(x_1x_2\leq
\frac{(x_1+x_2)^2}{4}\)</span>,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为<span class="math inline">\(\ln x_1+\ln x_2&lt;2\)</span>,然后令<span class="math inline">\(t_1=\ln x_1,t_2=\ln x_2\)</span>,带入立有: <span class="math display">\[
\begin{cases}\frac{t_1}{e^{t_1}}=a\\\frac{t_2}{e^{t_2}}=a\end{cases}
\]</span> 而<span class="math inline">\(g(x)=\frac{x}{e^x}\)</span>恰好也是满足<span class="math inline">\(x_1+x_2&gt;2\)</span>的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5>
<p><span class="math inline">\(f(x)=x(1-\ln x)\)</span>,<span class="math inline">\(b\ln a-a\ln b=a-b\)</span>,求证<span class="math inline">\(2&lt;\frac{1}{a}+\frac{1}{b}&lt;e\)</span>.</p>
<p>首先变形条件得到<span class="math inline">\(b(1+\ln a)=a(1+\ln
b)\)</span>,得到<span class="math inline">\(f(\frac{1}a)=f(\frac{1}{b})\)</span>,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p><span class="math inline">\(f&#39;(x)=-\ln x\)</span>,其在<span class="math inline">\((0,1)\uparrow,(1,+\infty)\downarrow\)</span>,考察极值点偏移,我们想要证明<span class="math inline">\(\frac{1}{b}&lt;e-\frac{1}{a}\)</span>,我们就想办法把<span class="math inline">\(\frac{1}{b}\)</span>和<span class="math inline">\(e-\frac{1}{a}\)</span>扔到同一个区间里,而它们确实同在<span class="math inline">\((1,+\infty)\)</span>这个区间内.</p>
<p>比较有启发性的是,你发现<span class="math inline">\(\frac{1}{b},e-\frac{1}{a}\)</span>和<span class="math inline">\(\frac{1}{a},e-\frac{1}{b}\)</span>这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了: <span class="math display">\[
\frac{1}{b}&lt;e-\frac{1}{a}\\
f(\frac{1}{a})=f(\frac{1}{b})&gt;f(e-\frac{1}{a})
\]</span> 对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5>
<p><span class="math inline">\(f(x)=e^{x-1}-ax\)</span>在<span class="math inline">\((0,2)\)</span>有两个零点<span class="math inline">\(x_1,x_2\)</span>,求证<span class="math inline">\(x_1x_2&gt;\frac{1}{a}\)</span>.</p>
<p>首先要证明<span class="math inline">\(a\)</span>的范围啊,我们不加证明地给出:<span class="math inline">\(a\in(1,\frac{e}{2})\)</span>,并且<span class="math inline">\((-\infty,1+\ln a)\downarrow,(1+\ln
a,+\infty)\uparrow\)</span>.</p>
<p>这个其实差不多啊,简单来说就是首先列方程: <span class="math display">\[
\begin{cases}ax_1=e^{x_1-1}\\
ax_2=e^{x_2-1}\end{cases}
\]</span>
我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取<span class="math inline">\(\ln\)</span>,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取<span class="math inline">\(\ln\)</span>,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到<span class="math inline">\(x_1x_2\)</span>和<span class="math inline">\(x_1+x_2\)</span>之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如<span class="math inline">\(0&lt;f(2+\ln a-x_2)\)</span>,也就是<span class="math inline">\(0&lt;ae^{1-x_2}-a(2+\ln a-x_2)\)</span>.</p>
<p>但是这样有一个问题,我们把<span class="math inline">\(f\)</span>带进去,你会发现最后我们的式子同时带有<span class="math inline">\(a,x_2\)</span>,这个就难做了,咋办呢?考虑拿<span class="math inline">\(ax_2=e^{x_2-1}\)</span>操作一下把<span class="math inline">\(a\)</span>消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4>
<h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5>
<ol type="1">
<li><span class="math inline">\(e^x\geq x+1\)</span>.</li>
<li><span class="math inline">\(\frac{x-1}{x}\leq \ln x\leq
x-1\)</span>.</li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol start="3" type="1">
<li><span class="math inline">\(\ln(n+1)&lt;\sum_{k=1}^n\frac{1}{k}\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(\ln(\frac{n+1}{n})&lt;\frac{1}{n}\)</span>,左右两边分别求和得到上面的式子.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\ln
n&gt;\sum_{k=2}^n\frac{1}{k},n&gt;1\)</span>.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明<span class="math inline">\(\ln\frac{1}{n}&lt;-\sum_{k=2}^n\frac{1}{k}\)</span>.</p>
<p>考虑<span class="math inline">\(\ln(\frac{n-1}{n})\leq
-\frac{1}{n}\)</span>,两边求和得到上式.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\sum_{k=1}^n(\frac{k}{n})^n&lt;\frac{e}{e-1}\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(n\ln(\frac{k}{n})\leq
k-n\)</span>,也就有<span class="math inline">\((\frac{k}{n})^n\leq
e^{k-n}\)</span>,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f(x)=x\ln x\)</span>,若<span class="math inline">\(f(x)=b\)</span>有两个实数根<span class="math inline">\(x_1,x_2(x_1&lt;x_2)\)</span>,求证:<span class="math inline">\(be+1&lt;x_2-x_1&lt;\frac{e^{-3}+2+3b}{2}\)</span>.</p>
<p>注意到<span class="math inline">\(f(x)\)</span>下凸,考虑求出两条切线,那么这两条切线与<span class="math inline">\(y=b\)</span>的交点之差要大于等于<span class="math inline">\(x_2-x_1\)</span>,两条割线交点之差要小于等于<span class="math inline">\(x_2-x_1\)</span>.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是<span class="math inline">\(b\rightarrow-\frac{1}{e}\)</span>的情况,为了让这种情况有解,我们的割线必过<span class="math inline">\((\frac{1}{e},-\frac{1}{e})\)</span>.</p>
<p>考虑直接选取<span class="math inline">\((0,0)\)</span>和<span class="math inline">\((1,0)\)</span>作为另外两个点,这两条割线就是<span class="math inline">\(x=-y\)</span>和<span class="math inline">\(x=(e-1)y+1\)</span>.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得<span class="math inline">\((x_2-x_1)_{\max}\)</span>尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是<span class="math inline">\(u\)</span>,另一个是<span class="math inline">\(v\)</span>,其中<span class="math inline">\(v&lt;\frac{1}{e}&lt;u\)</span>,那么两条切线分别是:
<span class="math display">\[
\begin{cases}x=\frac{y-f(u)}{f&#39;(u)}+u\\x=\frac{y-f(v)}{f&#39;(v)}+v\end{cases}
\]</span> 那么,现在我们要做的就是找到一组<span class="math inline">\((u,v)\)</span>,使得: <span class="math display">\[
\frac{b-f(u)}{f&#39;(u)}+u-\frac{b-f(v)}{f&#39;(v)}-v=\frac{e^{-3}+2+3b}{2}
\]</span> 感觉很难搞啊,我们不妨让<span class="math inline">\(u=1\)</span>,自然有: <span class="math display">\[
\frac{(f&#39;(v)-1)b+f(v)-vf&#39;(v)}{f&#39;(v)}=\frac{e^{-3}+3b}{2}
\]</span> 然后我们凑系数,上面的式子,我们大胆猜测: <span class="math display">\[
\begin{cases}\frac{f&#39;(v)-1}{f&#39;(v)}=\frac{3}{2}\\
\frac{f(v)-vf&#39;(v)}{f&#39;(v)}=\frac{e^{-3}}{2}\end{cases}
\]</span> 考虑让<span class="math inline">\(f&#39;(v)=-2\)</span>,则<span class="math inline">\(v=e^{-3}\)</span>,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求证:<span class="math inline">\(\forall x\in(0,+\infty),\ln
x+1&gt;\frac{1}{e^{x+1}}-\frac{2}{e^2x}\)</span>.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以<span class="math inline">\(x\)</span>,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为<span class="math inline">\(x\ln
x+x&gt;\frac{x}{e^{x+1}}-\frac{2}{e^2}\)</span>,然后证明左边的最小值$$右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4>
<p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5>
<p>已知<span class="math inline">\(a=0.1e^{0.1},b=\frac{1}{9},c=-\ln0.9\)</span>,求比较<span class="math inline">\(a,b,c\)</span>的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6>
<p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算<span class="math inline">\(a\)</span>和<span class="math inline">\(c\)</span>的大小关系.</p>
<p>构造函数<span class="math inline">\(f(x)=xe^x+\ln(1-x)\)</span>,则<span class="math inline">\(f(0.1)&gt;0\Rightarrow a&gt;c\)</span>.</p>
<p>考察<span class="math inline">\(f(0)=0\)</span>,<span class="math inline">\(f&#39;(0)=0\)</span>,<span class="math inline">\(f&#39;&#39;(0)=4&gt;0\)</span>,则<span class="math inline">\(f(0)=0\)</span>是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算<span class="math inline">\(f(0.1)&gt;0\)</span>.</p>
<h6><span id="估算定积分">估算定积分</span></h6>
<p>考察<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的大小关系,不妨设<span class="math inline">\(f(x)=(1-x)e^{1-x}-\frac{1}{10x}\)</span>,则<span class="math inline">\(f(0.9)&lt;0\Rightarrow b&gt;a\)</span>.</p>
<p>注意到<span class="math inline">\(f(1)=-\frac{1}{10}\)</span>,<span class="math inline">\(f&#39;(1)=-\frac{9}{10}\)</span>,考虑估算一下积分,那么<span class="math inline">\(f(0.9)\approx
f(1)-f&#39;(1)0.1=-\frac{1}{100}&lt;0\)</span>.</p>
<p>你可能会觉得这个<span class="math inline">\(-\frac{1}{100}\)</span>,是不是不太能那么肯定地估算啊.但是实际上,我们考察<span class="math inline">\(f&#39;(x)=(x-2)e^{1-x}+\frac{1}{10x^2}\)</span>,这个东西在<span class="math inline">\([0.9,1]\)</span>上直觉上平均值是大于<span class="math inline">\(-\frac{9}{10}\)</span>的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6>
<p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6>
<p>接下来开抄标答.</p>
<p>令<span class="math inline">\(f_a(x)=xe^x,f_b(x)=\frac{x}{1-x},f_c(x)=-\ln(1-x)\)</span>.</p>
<p>这样当<span class="math inline">\(x=0.1\)</span>的时候所有的数字都被正确表示了.</p>
<p>比较<span class="math inline">\(a,b\)</span>:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有: <span class="math display">\[
y=\ln(a)-\ln(b)=x+\ln(1-x)\\
y&#39;=1-\frac{1}{1-x}=\frac{-x}{1-x}
\]</span> 注意到<span class="math inline">\(x=0\)</span>的时候<span class="math inline">\(y=0\)</span>,又注意到其在<span class="math inline">\((0,0.1)\)</span>上单减,这样立有<span class="math inline">\(a&lt;b\)</span>.</p>
<p>比较<span class="math inline">\(a,c\)</span>: <span class="math display">\[
y=a-c=xe^x+\ln(1-x)\\
y&#39;=(x+1)e^x-\frac{1}{1-x}=\frac{(1+x)(1-x)e^x-1}{1-x}\\
\]</span> 注意到<span class="math inline">\(x=0\)</span>的时候<span class="math inline">\(y=0\)</span>,又注意到其在<span class="math inline">\((0,0.1)\)</span>上单增,这样立有<span class="math inline">\(a&gt;c\)</span>.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2>
<h3><span id="递归式的求解">递归式的求解</span></h3>
<h4><span id="特征根法">特征根法</span></h4>
<p>一个常系数的<span class="math inline">\(k\)</span>阶线性递推关系形如:
<span class="math display">\[
a_n=P_n+\sum_{i=1}^kc_ia_{n-i},n\geq k\\
a_0=C_0,a_1=C_1,...,a_{k-1}=C_{k-1}
\]</span></p>
<p>当<span class="math inline">\(P=0\)</span>时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程<span class="math inline">\(r^k=\sum_{i=1}^kc_ir^{k-i}\)</span>是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根<span class="math inline">\(r_1\)</span>和<span class="math inline">\(r_2\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n=\alpha_1r_1^n+\alpha_2r_2^n\)</span>.</p>
<p>若其特征方程有两个相同的根<span class="math inline">\(r\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n=\alpha_1r^n+\alpha_2nr^n\)</span>.</p>
<p>先考虑前者的证明,首先考虑对于<span class="math inline">\(n=0\)</span>或者<span class="math inline">\(n=1\)</span>的情况,我们考虑求出一组<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>来满足: <span class="math display">\[
C_0=\alpha_1+\alpha_2\\
C_1=\alpha_1r_1+\alpha_2r_2
\]</span> 若<span class="math inline">\(r_1\ne r_2\)</span>,可以解得:
<span class="math display">\[
\alpha_1=\cfrac{C_1-C_0r_2}{r_1-r_2}\\
\alpha_2=C_0-\alpha_1
\]</span> 接下来考虑数学归纳: <span class="math display">\[
a_n=c_1a_{n-1}+c_2a_{n-2}\\
=c_1(\alpha_1r_1^{n-1}+\alpha_2r_2^{n-1})+c_2(\alpha_1r_1^{n-2}+\alpha_2r_2^{n-2})\\
=\alpha_1(c_1r_1^{n-1}+c_2r_1^{n-2})+\alpha_2(c_1r_2^{n-1}+c_2r_2^{n-2})\\
=\alpha_1r_1^n+\alpha_2r_2^n
\]</span> 接下来考虑后者,首先我们有<span class="math inline">\(\Delta=c_1^2+4c_2=0\)</span>,考虑初始条件: <span class="math display">\[
C_0=\alpha_1\\
C_1=\alpha_1r+\alpha_2r\\
\]</span> 接下来我们考虑数学归纳: <span class="math display">\[
a_n=c_1a_{n-1}+c_2a_{n-2}\\
=c_1(\alpha_1r^{n-1}+\alpha_2nr^{n-1}-\alpha_2r^{n-1})+c_2(\alpha_1r^{n-2}+\alpha_2nr^{n-2}-2\alpha_2r^{n-2})\\
=a_n-c_1\alpha_2r^{n-1}-2c_2\alpha_2r^{n-2}
\]</span> 我们接下来只需证明<span class="math inline">\(c_1r+2c_2=0\)</span>即可.根据方程,不难发现<span class="math inline">\(r=\cfrac{c_1}{2}\)</span>,根据<span class="math inline">\(\Delta=0\)</span>,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>在上面做<span class="math inline">\(k=2\)</span>的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6>
<p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定<span class="math inline">\(a_0,...,a_n\)</span>,其中<span class="math inline">\(a_0\ne 0\)</span>,对于所有的<span class="math inline">\(k\in \mathbb{N}\)</span>,若有下列式子成立: <span class="math display">\[
a_0y_{k+n}+a_1y_{k+n-1}+\cdots+a_ny_k=z_k
\]</span> 则称为一个<span class="math inline">\(n\)</span>阶线性差分方程(或递归关系).为了简化,通常取<span class="math inline">\(a_0=1\)</span>.若<span class="math inline">\(\{z_k\}\)</span>是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6>
<p>我们注意到,对于齐次差分方程而言,如果不给定<span class="math inline">\(y_0,\cdots
y_{n-1}\)</span>,只是构造一组满足条件的<span class="math inline">\(y\)</span>的话,自然的想法是令<span class="math inline">\(y_k=r^k\)</span>.其中<span class="math inline">\(r\)</span>是辅助方程<span class="math inline">\(a_0r^{n}+a_1r^{n-1}+\cdots+a_n=0\)</span>的一个根.</p>
<p>注意到如果我们将上面的内容看作是<span class="math inline">\(T:\{y_k\}\mapsto
\{z_k\}\)</span>这样一个映射,这显然是一个线性变换.这意味着齐次方程<span class="math inline">\(a_0y_{k+n}+a_1y_{k+n-1}+\cdots+a_ny_k=0\)</span>的解集就是<span class="math inline">\(T\)</span>的核,设为<span class="math inline">\(H\)</span>,不难发现只要给定<span class="math inline">\(y_0,\cdots
y_{n-1}\)</span>,这个解就唯一确定,将它们看作自由变量,这意味着<span class="math inline">\(\dim H=n\)</span>.</p>
<p>还没完,注意到我们解方程可以解出<span class="math inline">\(n\)</span>个根,如果这<span class="math inline">\(n\)</span>个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了<span class="math inline">\(y_0,\cdots
y_{n-1}\)</span>,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这<span class="math inline">\(n\)</span>个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的<span class="math inline">\(\mathbb{R}^k\)</span>的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共<span class="math inline">\(n\)</span>个线性无关的根,然后拟合初值.我们如此做:对于一个出现了<span class="math inline">\(m\)</span>次的根<span class="math inline">\(r\)</span>,我们注意到<span class="math inline">\(r^k,kr^k,\cdots,k^{m-1}r^k\)</span>都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以<span class="math inline">\(kr^k\)</span>作为例子,即证明: <span class="math display">\[
a_0nr^n+a_1(n-1)r^{n-1}+\cdots +a_1r=0
\]</span> 是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个<span class="math inline">\(r\)</span>作为根,必然意味着原方程形如<span class="math inline">\((y-r)^2P\)</span>,其中<span class="math inline">\(P\)</span>是一个关于<span class="math inline">\(y\)</span>的多项式.</p>
<p>我们把它写开:<span class="math inline">\((y^2-2ry+r^2)P=0\)</span>,然后我们用<span class="math inline">\(kr^k\)</span>去代替<span class="math inline">\(r^k\)</span>,不难发现代替后右边还是个多项式,而左边变成了<span class="math inline">\(0\)</span>,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导. <span class="math display">\[
a_0r^{n+k}+a_1r^{n+k-1}+\cdots +a_1r^k=0\\
a_0(n+k)r^{n+k-1}+a_1(n+k-1)r^{n+k-2}+\cdots+a_1kr^{k-1}=0\\
a_0(n+k)r^{n+k}+a_1(n+k-1)r^{n+k-1}+\cdots+a_1kr^{k}=0\\
\]</span> 这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:<span class="math inline">\(((y-r)^2P)&#39;=(y-r)((y-r)P)&#39;+(y-r)&#39;(y-r)P=(y-r)[(y-r)&#39;P+((y-r)P)&#39;]\)</span>,<span class="math inline">\(r\)</span>一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6>
<p>我们注意到齐次差分方程一定能写成<span class="math inline">\(\vec
x_k=A\vec x_{k-1}\)</span>的形式.如果我们取<span class="math inline">\(A\)</span>的特征向量的线性组合作为<span class="math inline">\(\vec x_0\)</span>,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为<span class="math inline">\(1\)</span>的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是<span class="math inline">\(\vec
x_{k+1}=A\vec x\)</span>,<span class="math inline">\(\vec x_{n}=A^n\vec
x_0\)</span>.而我们又知道CH定理:<span class="math inline">\(p(A)=0\)</span>,我们用多项式取膜,有<span class="math inline">\(A^n=p(A)F(A)+G(A)=G(A)\)</span>,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3>
<h4><span id="和式的基本运算">和式的基本运算</span></h4>
<p>分配律:<span class="math inline">\(\\\sum_{i\in S}ca_i=c\sum_{i\in
S}a_i\\\)</span>.</p>
<p>结合律:<span class="math inline">\(\\\sum_{i\in
S}(a_i+b_i)=\sum_{i\in S}a_i+\sum_{i\in S}b_i\)</span>.</p>
<p>交换律:<span class="math inline">\(\sum_{i\in S}a_i=\sum_{p(i)\in
S}a_{p(i)}\)</span>,其中<span class="math inline">\(p\)</span>是<span class="math inline">\(S\)</span>集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum_{i}\sum_{j}a_{i,j}[P(i,j)]=\sum_{j}\sum_{i}a_{i,j}[P(i,j)]\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{i=1}^n\sum_{j=i}^na_{i,j}=\sum_{j=1}^n\sum_{i=1}^ja_{i,j}\)</span>.</p></li>
</ol>
<p>一般分配律:<span class="math inline">\(\sum_{i}\sum_{j}a_{i}b_j=(\sum_{i}a_i)(\sum_jb_j)\)</span>.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6>
<p>等差数列求和：</p>
<p><span class="math display">\[
S_n=\sum_{i=0}^n(ai+b)=\sum_{i=0}^n(a(n-i)+b)\\
2S_n=\sum_{i=0}^n(an+2b)=an(n+1)+2b(n+1)\\
S_n=(n+1)(\frac{an}{2}+b)
\]</span></p>
<h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6>
<p>令<span class="math inline">\(S=\sum_{1\leq i&lt;j\leq
n}(a_j-a_i)(b_j-b_i)=\sum_{1\leq j&lt;i\leq
n}(a_j-a_i)(b_j-b_i)\)</span>.</p>
<p>考虑恒等式<span class="math inline">\([1\leq j&lt;i\leq n]+[1\leq
i&lt;j\leq n]=[1\leq j,i\leq n]-[1\leq i=j\leq n]\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
2S=\sum_{1\leq i,j\leq n}(a_j-a_i)(b_j-b_i)-\sum_{1\leq i=j\leq
n}(a_j-a_i)(b_j-b_i)\\=\sum_{1\leq i,j\leq n}(a_j-a_i)(b_j-b_i)\\
=2n\sum_{i=1}^na_ib_i-2(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\\
\]</span> 又有<span class="math inline">\((\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)=n\sum_{i=1}^na_ib_i-\sum_{1\leq
i&lt;j\leq n}(a_j-a_i)(b_j-b_i)\)</span>,显然有以下式子: <span class="math display">\[
(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\leq n\sum_{i=1}^na_ib_i,\forall
i&lt;j,a_i\leq a_j\and b_i\leq b_j\\
(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\geq n\sum_{i=1}^na_ib_i,\forall
i&lt;j,a_i\leq a_j\and b_i\geq b_j\\
\]</span> 上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6>
<p>即<span class="math inline">\(\sum_{1\leq j&lt;k\leq
n}(a_jb_k-a_kb_j)^2=(\sum_{i=1}^na_i^2)(\sum_{i=1}^nb_i^2)-(\sum_{i=1}^na_ib_i)^2\\\)</span>.</p>
<p>令<span class="math inline">\(S_n=\sum_{1\leq j&lt;k\leq
n}(a_jb_k-a_kb_j)^2\\\)</span>,有:</p>
<p><span class="math display">\[
2S_n=\sum_{j=1}^n\sum_{k=1}^n(a_jb_k-a_kb_j)^2\\=\sum_{j=1}^n\sum_{k=1}^n(a_j^2b_k^2-2a_ja_kb_jb_k-a_k^2b_j^2)\\=2(\sum_{i=1}^na_i^2)(\sum_{i=1}^nb_i^2)-2(\sum_{i=1}^na_ib_i)^2
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6>
<p><span class="math display">\[
S_n=\sum_{i=0}^nax^i\\=a+\sum_{i=1}^nax^i\\=a+x\sum_{i=0}^{n-1}ax^i\\=a+xS_{n-1}
\]</span></p>
<p>而<span class="math inline">\(S_{n-1}+ax^n=S_n=a+xS_{n-1}\)</span>,有<span class="math inline">\(S_n+ax^{n+1}=a+xS_n,S_n=a\frac{x^{n+1}-1}{x-1}\)</span>，其中<span class="math inline">\(x\ne1\)</span>.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6>
<p><span class="math inline">\(S_n=\sum_{i=0}^ni^2\)</span>.</p>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
S_n=\sum_{i=0}^{n-1}i^2+n^2\\=\sum_{i=1}^n(i-1)^2+n^2\\=S_n-2\sum_{i=1}^ni+n+n^2
\]</span> 我们无法得到<span class="math inline">\(S_n\)</span>的封闭形式,但我们发现我们得到了<span class="math inline">\(\sum_{i=1}^ni\)</span>的封闭形式.</p>
<p>那以此类推，我们设<span class="math inline">\(W_n=\sum_{i=0}i^3\)</span></p>
<p><span class="math display">\[
W_n=\sum_{i=0}^{n-1}i^3+n^3\\=\sum_{i=1}^n(i-1)^3+n^3\\=\sum_{i=1}^ni^3-3\sum_{i=1}^ni^2+3\sum_{i=1}^ni-n+n^3\\=W_n-3S_n+3\frac{n+n^2}2-n+n^3\\
S_n=\frac{n+n^2}2-\frac{n-n^3}3\\=\frac{n+3n^2+2n^3}6\\=\frac{n(1+3n+2n^2)}{6}\\=\frac{n(2n+1)(n+1)}{6}
\]</span></p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h6><span id="example1平方和公式">Example1(平方和公式)</span></h6>
<p><span class="math display">\[
S_n=\sum_{k=1}^nk^2\\=\sum_{k=1}^n\sum_{i=1}^kk
\\=\sum_{i=1}^n\sum_{k=i}^nk\\=\sum_{i=1}^n\frac 1
2(i+n)(n-i+1)\\=\sum_{i=1}^n\frac{1}2(in-i^2+i+n^2-ni+n)\\
=\frac{1}2(\sum_{i=1}^ni-\sum_{i=1}^ni^2+n^3+n^2)\\=\frac{1}4n(n+1)-\frac1
2S_n+\frac{n^3+n^2}2
\]</span></p>
<p>整理得到<span class="math inline">\(S_n\)</span>.</p>
<p>######Example2</p>
<p>求<span class="math inline">\(\sum_{i=1}^n i^3\\\)</span>.</p>
<p><span class="math display">\[
S(n)=\sum_{i=1}^n
i^3\\=\sum_{i=1}^n\sum_{j=1}^ii^2\\=\sum_{j=1}^n\sum_{i=j}^ni^2\\=\sum_{j=1}^n(\frac{n(n+1)(2n+1)}{6}-\frac{(j-1)j(2j-1)}{6})\\=\frac{n^2(n+1)(2n+1)}{6}-\frac
1 3
S(n)+\frac{n(n+1)(2n+1)}{12}-\frac{n(n+1)}{12}\\S(n)=\frac{n^2(n+1)^2}{4}
\]</span></p>
<h5><span id="problme3">Problme3</span></h5>
<p>求<span class="math inline">\(\sum_{i=1}^niq^i(q\ne 1)\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p><span class="math display">\[
\sum_{i=1}^niq^i=\sum_{j=1}^n\sum_{i=j}^nq^i\\
=\sum_{j=1}^n\frac{q^j-q^{n+1}}{1-q}\\
=\frac{1}{q-1}\sum_{j=1}^n(q^{n+1}-q^j)\\
=\frac{1}{q-1}(nq^{n+1}-\frac{q^{n+1}-q}{q-1})\\
\]</span></p>
<h5><span id="problemex2">ProblemEX2</span></h5>
<p>求<span class="math inline">\(\sum_{i=1}^n(ai+b)q^{i-1}(q\ne
1)\)</span>.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令<span class="math inline">\(A=\frac{a}{q-1},B=\frac{b-A}{q-1}\)</span>,答案为<span class="math inline">\((An+B)q^n-B\)</span>.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子<span class="math inline">\(E\)</span>，使得<span class="math inline">\(Ef(x)=f(x+1)\)</span>.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子<span class="math inline">\(\Delta
f(x)=f(x+1)-f(x)\)</span>，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有<span class="math inline">\(\Delta=E-1\)</span>.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子<span class="math inline">\(\Sigma\)</span>,可以得到有限微积分的基本定理:</p>
<p><span class="math inline">\(g(x)=\Delta f(x)\Leftrightarrow \sum
g(x)\delta x=f(x)+C\\\)</span></p>
<p>这里的<span class="math inline">\(\Sigma\)</span>又被称为不定和式,是差分等于<span class="math inline">\(g\)</span>的一个函数类.</p>
<p>值得一提的是,这里的<span class="math inline">\(C\)</span>与无限微积分中的<span class="math inline">\(C\)</span>有一定区别,这里的<span class="math inline">\(C\)</span>可以是满足<span class="math inline">\(p(x)=p(x+1)\)</span>的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果<span class="math inline">\(g(x)=\Delta f(x)\)</span>,那么有<span class="math inline">\(\sum\nolimits_{a}^b g(x)\delta
x=f(x)|^{b}_a=f(b)-f(a)\\\)</span>.</p>
<p>值得一提的是,如果<span class="math inline">\(a\leq
b\)</span>,显然有<span class="math inline">\(\sum\nolimits_{a}^bg(x)\delta
x=\sum_{x=a}^{b-1}g(x)\\\)</span>.</p>
<p>但如果<span class="math inline">\(a&gt;b\)</span>,那么<span class="math inline">\(\sum\nolimits_{a}^bg(x)\delta x=-\sum\nolimits_b^a
g(x)\delta x\\\)</span>.</p>
<p>事实上,我们一定有:<span class="math inline">\(\sum\nolimits_a^bg(x)\delta
x+\sum\nolimits_b^cg(x)\delta x=\sum\nolimits_a^cg(x)\delta
x\\\)</span>.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的<span class="math inline">\(D(x^m)=mx^{m-1}\)</span>，有:</p>
<p>$ (x<sup>{})=mx</sup>{}，mx<sup>{}x=x</sup>{}+C，m\ \$
类比无限微积分中的<span class="math inline">\(D(\ln x)=\frac 1
x\)</span>，有:</p>
<p>$ 令H(x)=_{i=1}<sup>x\(H(x))=x</sup>{}，x^{}x =H(x)+C\ \$
类比无限微积分中的<span class="math inline">\(D(e^x)=e^x\)</span>,有:</p>
<p><span class="math inline">\(\Delta(2^x)=2^x，\sum 2^x\delta
x=2^x+C\\\)</span></p>
<p><span class="math inline">\(\Delta (c^x)=(c-1)c^x，\sum c^x\delta
x=\frac{c^x}{c-1}+C,c\ne 1\\\)</span></p>
<p><span class="math inline">\(\Delta
(c^{\underline{x}})=\frac{c^{\underline{x+2}}}{c-x},\sum
\frac{c^{\underline{x+2}}}{c-x}\delta x=c^{\underline{x}}+C,c-x\ne
0\\\)</span>.</p>
<p>根据组合数公式,有:</p>
<p><span class="math inline">\(\Delta(\binom{x}{k})=\binom{x}{k-1}\\\)</span>.</p>
<p>######Example1</p>
<p>仍然考虑平方和公式：</p>
<p>我们有:<span class="math inline">\(k^2=k^{\underline{2}}+k^{\underline{1}}\\\)</span>.</p>
<p>那么:</p>
<p><span class="math display">\[
S_{n-1}=\sum_{i=0}^{n-1}i^2\\=\sum_{i=0}^{n-1}(i^{\underline{2}}+i^{\underline{1}})\\=\sum\nolimits_{0}^nx^{\underline2}\delta
x+\sum\nolimits_{0}^nx^{\underline 1}\delta
x\\=\frac{n^\underline{3}}{3}+\frac{n^{\underline{2}}}{2}
\]</span> 整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
<p><span class="math display">\[
\Delta(uv)=u(x+1)v(x+1)-u(x)v(x)\\
=u(x+1)v(x+1)-u(x)v(x+1)+u(x)v(x+1)-u(x)v(x)\\
=v(x+1)\Delta u+u(x)\Delta v=Ev\Delta u+u\Delta v\\
\]</span></p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p><span class="math inline">\(\sum u\Delta v=uv-\sum Ev\Delta
u\\\)</span>.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math inline">\(\sum_{i=l}^{r-1}(a_{i+1}-a_i)b_i=a_rb_r-a_lb_l-\sum_{i=l}^{r-1}a_{i+1}(b_{i+1}-b_i)\\\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{k=0}^nk2^k\\\)</span>.</p>
<p>根据分部求和法则，我们有:</p>
<p><span class="math inline">\(\sum x2^x\delta x=x2^x-\sum2^{x+1}\delta
x=x2^x-2^{x+1}+C\\\)</span>.</p>
<p>改为定和式形式，显然有:</p>
<p><span class="math display">\[
\sum_{k=0}^nk2^k\\=\sum\nolimits_0^{n+1}x2^x\delta
x\\=(n+1)2^{n+1}-2^{n+2}+2\\=(n-1)2^{n+1}+2\\
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{k=0}^{n-1}kH_k\\\)</span>.</p>
<p>令<span class="math inline">\(u(x)=H_x,v(x)=\frac 1
2x^{\underline{2}}\\\)</span>.</p>
<p>带入分部求和法则，显然有:</p>
<p><span class="math inline">\(\sum xH_x\delta
x=\frac{x^\underline{2}}2H_x-\frac{x^\underline{2}}4+C\\\)</span>.</p>
<p>带入即可求出原式<span class="math inline">\(=\frac{n^\underline{2}}2(H_n-\frac{1}2)\\\)</span>.</p>
<p>######Example3</p>
<p>求<span class="math inline">\(\sum_{i=1}^n\frac{2i+1}{i(i+1)}\\\)</span>.</p>
<p>令<span class="math inline">\(u=(2n+1),v=-\frac{1}{i}\)</span>,则<span class="math inline">\(\Delta u=2,\Delta v=\frac{1}{i(i+1)}\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\sum_{i=1}^n\frac{2i+1}{i(i+1)}=(2n+3)\times
(-\frac{1}{n+1})+3-\sum_{i=1}^n(-\frac{2}{i+1})\\=-\frac{2n+3}{n+1}+2H_n+\frac{n+3}{n+1}\\=2H_n-\frac{n}{n+1}
\]</span></p>
<p>######Example4</p>
<p>求<span class="math inline">\(\sum_{i=0}^{n-1}\frac{H_k}{(k+1)(k+2)}\\\)</span>.</p>
<p>令<span class="math inline">\(u=H_n,v=-\frac{1}{n+1},\Delta
u=\frac{1}{n+1},\Delta v=\frac{1}{(n+1)(n+2)}\\\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\sum_{i=0}^{n-1}\frac{H_k}{(k+1)(k+2)}=-\frac{H_n}{n+1}-\sum_{i=0}^{n-1}(-\frac{1}{(i+2)(i+1)})\\=-\frac{H_n}{n+1}+\sum_{i=0}^{n-1}(\frac{1}{i+1}-\frac{1}{i+2})\\=-\frac{H_n}{n+1}+H_n-(H_n-1+\frac{1}{n+1})\\=1-\frac{H_n+1}{n+1}
\]</span></p>
<h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3>
<h5><span id="example">Example</span></h5>
<p>令<span class="math inline">\(A=\{2n-1|n\in
\mathbb{N}_{+}\},B=\{3n-1|n\in \mathbb{N}_{+}\}\)</span>.求<span class="math inline">\(A\cap B\)</span>,以及<span class="math inline">\(A\cup B\)</span>的最小的一百项之和.</p>
<p>对于前者,我们知道: <span class="math display">\[
a\in A\Leftrightarrow a\equiv -1\pmod 2\\
b\in B\Leftrightarrow b\equiv -1\pmod 6\\
\]</span> 所以<span class="math inline">\(A\cap B=\{6n-1|n\in
\mathbb{N}_{+}\}\)</span>.</p>
<p>而同理,<span class="math inline">\(x\in A\cup B\Leftrightarrow
x\equiv -1/-2/-3/-5\pmod 6\)</span>.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3>
<p>设<span class="math inline">\(A=\{x|x=2n-1,n\in
\mathbb{N}_+\},B=\{x|x=2^n,n\in \mathbb{N}_+\}\)</span>,现在将<span class="math inline">\(A\cup B\)</span>中的元素排序并提取成一个数列<span class="math inline">\(a\)</span>,求使得<span class="math inline">\(S_n&gt;12a_n\)</span>最小的正整数<span class="math inline">\(n\)</span>.</p>
<p>写出数列,它长这样: <span class="math display">\[
\begin{matrix}1&amp;2\\3&amp;4\\5&amp;7&amp;8\\9&amp;11&amp;13&amp;15&amp;16\\&amp;&amp;\cdots\end{matrix}
\]</span> 不妨设<span class="math inline">\(n\)</span>在第<span class="math inline">\(r\)</span>行<span class="math inline">\(c\)</span>列,显然<span class="math inline">\((r,c)\)</span>和<span class="math inline">\(n\)</span>构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的<span class="math inline">\(n\)</span>能快速表达<span class="math inline">\((r,c)\)</span>,要么反之.显然反之比较简单.</p>
<p>考虑设前<span class="math inline">\(k\)</span>行共有<span class="math inline">\(W_k\)</span>个数,不难发现<span class="math inline">\(W_{k+1}=W_k+2^{k-1}+1,W_k=2^{k-1}+k\)</span>.</p>
<p>显然,对于<span class="math inline">\((r,c)\)</span>来说,它对应的<span class="math inline">\(n\)</span>就是<span class="math inline">\(W_{r-1}+c\)</span>.</p>
<p>令<span class="math inline">\(SR_{r}\)</span>为前<span class="math inline">\(r\)</span>行数字之和,不难发现<span class="math inline">\(SR_r=2^{r+1}-2+(2^{r-1})^2\)</span>.</p>
<p>接下来考虑找到这个最小的<span class="math inline">\(n\)</span>,显然<span class="math inline">\(r\ne
1\)</span>,接下来只考虑<span class="math inline">\(r\geq
2\)</span>的情况.</p>
<p>那么我们可以轻松写出<span class="math inline">\(S_n\)</span>和<span class="math inline">\(a_n\)</span>的表达式,下面直接给出: <span class="math display">\[
S_n=SR_{r-1}+\sum_{k=1}^c(2^{r-1}+2k-1)-[c=2^{r-2}+2]\\
S_n=2^r-2+4^{r-2}+2^{r-1}c+c^2-[c=2^{r-2}+1]\\
a_n=2^{r-1}+2c-1-[c=2^{r-2}+1]
\]</span> 讨论一下<span class="math inline">\([c=2^{r-2}+1]\)</span>这个判定式取<span class="math inline">\(0\)</span>还是取<span class="math inline">\(1\)</span>,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3>
<h2><span id="几何导论">几何导论</span></h2>
<h3><span id="三角相关">三角相关</span></h3>
<h4><span id="三角恒等变换">三角恒等变换</span></h4>
<h5><span id="两角和差公式">两角和差公式</span></h5>
<p><span class="math display">\[
\sin(A+B)=\sin A\cos B+\sin B\cos A\\
\sin(A-B)=\sin A\cos B-\sin B\cos A\\
\cos(A+B)=\cos A\cos B-\sin A\sin B\\
\cos(A-B)=\cos A\cos B+\sin A\sin B\\
\tan(A+B)=\frac{\tan A+\tan B}{1-\tan A\tan B}\\
\tan (A-B)=\frac{\tan A-\tan B}{1+\tan A\tan B}
\]</span></p>
<h5><span id="倍角公式">倍角公式</span></h5>
<p><span class="math display">\[
\tan(2A)=\frac{2\tan A}{1-\tan^2 A}\\
\sin(2A)=2\sin A\cos A\\
\cos(2A)=\cos^2A-\sin^2A=2\cos^2A-1=1-2\sin^2A
\]</span></p>
<h5><span id="半角公式">半角公式</span></h5>
<p><span class="math display">\[
\sin(\frac A 2)=\pm\sqrt{\frac{1-\cos A}2}\\
\cos(\frac A 2)=\pm\sqrt{\frac{1+\cos A}{2}}\\
\tan(\frac A 2)=\frac{\sin A}{1+\cos A}=\frac{1-\cos A}{\sin
A}=\pm\sqrt{\frac{1-\cos A}{1+\cos A}}
\]</span></p>
<h5><span id="和差化积">和差化积</span></h5>
<p><span class="math display">\[
\sin A+\sin B=2\sin (\frac{A+B}{2})\cos(\frac{A-B}{2})\\
\sin A-\sin B=2\cos (\frac{A+B}{2})\sin(\frac{A-B}{2})\\
\cos A+\cos B=2\cos (\frac{A+B}{2})\cos(\frac{A-B}2)\\
\cos A-\cos B=-2\sin(\frac{A+B}{2})\sin(\frac{A-B}2)\\
\tan A+\tan B=\frac{\sin(A+B)}{\cos A\cos B}
\]</span></p>
<p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子: <span class="math display">\[
\sin^2A-\sin^2B=\sin (A-B)\sin(A+B)
\]</span>
如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5>
<p><span class="math display">\[
\sin A\sin B=-\frac{1}2[\cos(A+B)-\cos(A-B)]\\
\cos A\cos B=\frac{1}2[\cos(A+B)+\cos(A-B)]\\
\sin A\cos B=\frac{1}2[\sin(A+B)+\sin(A-B)]\\
\cos A\sin B=\frac{1}2[\sin(A+B)-\sin (A-B)]
\]</span></p>
<h5><span id="万能公式">万能公式</span></h5>
<p>令<span class="math inline">\(w=\tan\frac{A}2\)</span>,则: <span class="math display">\[
\sin A=\frac{2w}{1+w^2}\\
\cos A=\frac{1-w^2}{1+w^2}\\
\tan A=\frac{2w}{1-w^2}
\]</span></p>
<p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式: <span class="math display">\[
\cos(x)=\frac{e^{ix}+e^{-ix}}{2}\\
\sin(x)=\frac{e^{ix}-e^{-ix}}{2i}
\]</span></p>
<h5><span id="补充公式">补充公式</span></h5>
<p><span class="math display">\[
1+\sin A=(\sin \frac{A}2+\cos \frac{A}{2})^2\\
1-\sin A=(\sin \frac{A}{2}-\cos \frac{A}{2})^2
\]</span></p>
<h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4>
<p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的<span class="math inline">\(k\)</span>来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6>
<p>已知函数<span class="math inline">\(f(x)=\sin(\omega
x+\varphi),w&gt;0\)</span>,<span class="math inline">\(f(-\frac{\pi}{6})=0,f(\frac{\pi}{2})=-1\)</span>,求<span class="math inline">\(w\)</span>和<span class="math inline">\(\varphi\)</span>的表达式.</p>
<p>正确做法应该是强设<span class="math inline">\(k_1,k_2\)</span>,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的<span class="math inline">\(\omega\)</span>和<span class="math inline">\(\varphi\)</span>都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令<span class="math inline">\(\frac{\pi}{2}\)</span>为单位<span class="math inline">\(1\)</span>,我们必有以下式子: <span class="math display">\[
-\frac{\omega}{3}+\varphi\equiv 0\pmod 2\\
\omega+\varphi\equiv 3\pmod 4
\]</span> 下面推导<span class="math inline">\(\omega\)</span>,首先将上面两个式子直接相减,立有:
<span class="math display">\[
\frac{4}{3}\omega\equiv 1\pmod 2
\]</span> 对于<span class="math inline">\(\varphi\)</span>,考虑类似的做法,将第一个式子乘以<span class="math inline">\(3\)</span>后与第二个式子相加,立有: <span class="math display">\[
4\varphi\equiv 1\pmod 2
\]</span> 这样我们得到的必须满足的条件就有以下几条: <span class="math display">\[
\frac{4}{3}\omega\equiv 1\pmod 2\\
4\varphi\equiv 1\pmod 2\\
\omega+\varphi\equiv 3\pmod 4
\]</span></p>
<h3><span id="向量相关">向量相关</span></h3>
<h4><span id="旋转模型">旋转模型</span></h4>
<p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6>
<p>已知<span class="math inline">\(AB=2,AC=1,\angle
A=\theta\)</span>,<span class="math inline">\(BC\)</span>绕<span class="math inline">\(B\)</span>点顺时针旋转<span class="math inline">\(\frac{\pi}{3}\)</span>得到<span class="math inline">\(BD\)</span>,求以<span class="math inline">\(\theta\)</span>表示<span class="math inline">\(S_{\triangle CBD}\)</span>.</p>
<p>先来说文化课做法,我们直接表示<span class="math inline">\(S\)</span>,令<span class="math inline">\(\alpha=\angle ABC\)</span>: <span class="math display">\[
S=|BD|\sin(\alpha+\frac{\pi}{3})\\
\]</span> 对于这个式子,我们发现如果我们能得到<span class="math inline">\(|BD|\sin(\alpha)\)</span>和<span class="math inline">\(|BD|\cos(\alpha)\)</span>就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现<span class="math inline">\(BD\)</span>是<span class="math inline">\(\alpha\)</span>的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出<span class="math inline">\(|BD|\sin\alpha\)</span>,余弦定理可以帮助我们求出<span class="math inline">\(|BD|\cos\alpha\)</span>.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出<span class="math inline">\(\overrightarrow{AB}\)</span>和<span class="math inline">\(\overrightarrow{BC}\)</span>的坐标表示,将<span class="math inline">\(\overrightarrow
{BC}\)</span>用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4>
<p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol type="1">
<li>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</li>
<li>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作<span class="math inline">\(1\)</span>是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(\triangle ABC\)</span>中,<span class="math inline">\(b^2=ac\)</span>,点<span class="math inline">\(D\)</span>在<span class="math inline">\(AC\)</span>上且满足<span class="math inline">\(BD=b\)</span>,有<span class="math inline">\(\overrightarrow{AD}=2\overrightarrow{DC}\)</span>,求<span class="math inline">\(\cos\angle ABC\)</span>.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定<span class="math inline">\(c=1\)</span>,于是有<span class="math inline">\(b^2=a\)</span>.</p>
<p>考虑我们要求<span class="math inline">\(\cos\angle
ABC\)</span>,而我们有一条很奇怪的边<span class="math inline">\(BD\)</span>,似乎不满足任何性质,我们立刻想到要把它用<span class="math inline">\(\angle
ABC\)</span>的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让<span class="math inline">\(c=1\)</span>,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4>
<h5><span id="奔驰定理">奔驰定理</span></h5>
<p>对于<span class="math inline">\(\triangle ABC\)</span>内一点<span class="math inline">\(P\)</span>,立有<span class="math inline">\(S_{\triangle PBC}\overrightarrow{PA}+S_{\triangle
PAC}\overrightarrow{PB}+S_{\triangle PAB}\overrightarrow{PC}=\vec
0\)</span>.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令<span class="math inline">\(a=PA,b=PB,c=PC\)</span>,我们要证奔驰定理,也就是要证明:
<span class="math display">\[
bc\sin\alpha \overrightarrow{PA}+ac\sin\beta
\overrightarrow{PB}+ab\sin\gamma \overrightarrow{PC}=\vec 0\\
abc\sin\alpha \frac{\overrightarrow{PA}}{a}+abc\sin\beta
\frac{\overrightarrow{PB}}{b}+abc\sin\gamma
\frac{\overrightarrow{PC}}{c}=\vec 0\\
\sin\alpha \frac{\overrightarrow{PA}}{a}+\sin\beta
\frac{\overrightarrow{PB}}{b}+\sin\gamma
\frac{\overrightarrow{PC}}{c}=\vec 0\\
\]</span> 考虑<span class="math inline">\(|\frac{\overrightarrow{PA}}{a}|=|
\frac{\overrightarrow{PB}}{b}|=|
\frac{\overrightarrow{PC}}{c}|=1\)</span>,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5>
<p>有正弦定理,<span class="math inline">\(|\overrightarrow{OA}|=|\overrightarrow{OB}|=|\overrightarrow{OC}|=\frac{a}{2\sin
A}\)</span>.</p>
<p>考虑三个三角形的面积可以表示为<span class="math inline">\(\frac{r^2}{2}\sin
\theta\)</span>,又考虑到圆中的<span class="math inline">\(\theta\)</span>是圆心角是圆周角的两倍,立有<span class="math inline">\(\sin(2A)\overrightarrow{OA}+\sin(2B)\overrightarrow{OB}+\sin(2C)\overrightarrow{OC}=\vec
0\)</span>.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6>
<p>在<span class="math inline">\(\triangle ABC\)</span>中,<span class="math inline">\(AB=2,BC=\sqrt {10},AC=3\)</span>,若<span class="math inline">\(O\)</span>是其外心,且<span class="math inline">\(\overrightarrow{AO}=p\overrightarrow{AB}+q\overrightarrow{AC}\)</span>.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用<span class="math inline">\(|OA|=|OB|=|OC|\)</span>,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于<span class="math inline">\(p,q\)</span>的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了<span class="math inline">\(|OA|\)</span>,用上<span class="math inline">\(|OB|\)</span>,这样的话我们两边同时加上<span class="math inline">\(\overrightarrow{BA}\)</span>,就可以得到<span class="math inline">\(p,q\)</span>的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据<span class="math inline">\(|OC|\)</span>也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理: <span class="math display">\[
\overrightarrow{AO}=p\overrightarrow{AB}+q\overrightarrow{AC}\\
\vec 0=(p+q-1)\overrightarrow
{OA}+p\overrightarrow{OB}+q\overrightarrow{OC}
\]</span> 考察奔驰定理,立有<span class="math inline">\(\frac{p+q-1}{\sin(2A)}=\frac{p}{\sin(2B)}=\frac{q}{\sin(2C)}\)</span>,简单题.</p>
<h6><span id="example2">Example2</span></h6>
<p>已知相异两点<span class="math inline">\(O,H\)</span>分别为<span class="math inline">\(\triangle ABC\)</span>的外心和垂心,若<span class="math inline">\(\overrightarrow{OH}=m(\overrightarrow{OA}+\overrightarrow{OB}+\overrightarrow{OC})\)</span>,求<span class="math inline">\(m\)</span>.</p>
<p>这题要用到的性质是,我们一定要知道<span class="math inline">\((\overrightarrow{OB}+\overrightarrow{OC})\sdot
\overrightarrow{BC}=0\)</span>,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出<span class="math inline">\(\overrightarrow{AH}\)</span>,然后两边同时乘以<span class="math inline">\(\overrightarrow{BC}\)</span>就可以解决.注意到最后解方程的时候要么<span class="math inline">\(m=1\)</span>,要么三角形等边,但是我们声明过<span class="math inline">\(O,H\)</span>相异两点.</p>
<h5><span id="重心">重心</span></h5>
<p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的<span class="math inline">\(1:2\)</span>的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若<span class="math inline">\(O\)</span>是重心,则必有<span class="math inline">\(\overrightarrow{OA}+\overrightarrow{OB}+\overrightarrow{OC}=\vec
0\)</span>.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5>
<p>若<span class="math inline">\(O\)</span>是重心,立有<span class="math inline">\(\overrightarrow{OA}\sdot\overrightarrow{BC}=0\)</span>,将<span class="math inline">\(\overrightarrow {BC}=\overrightarrow
{BO}+\overrightarrow {OC}\)</span>,立有<span class="math inline">\(\overrightarrow{OA}\sdot\overrightarrow{OB}=\overrightarrow{OA}\sdot\overrightarrow{OC}=\overrightarrow{OB}\sdot\overrightarrow{OC}\)</span>.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有<span class="math inline">\(\overrightarrow{OA}\tan
A+\overrightarrow{OB}\tan B+\overrightarrow{OC}\tan C=\vec
0\)</span>.</p>
<h5><span id="内心">内心</span></h5>
<p>根据奔驰定理,立有<span class="math inline">\(a\overrightarrow{OA}+b\overrightarrow{OB}+c\overrightarrow{OC}=\vec
0\)</span>.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3>
<h4><span id="基本概念">基本概念</span></h4>
<h5><span id="直线">直线</span></h5>
<p>使用直线的方向向量<span class="math inline">\(\vec
s=(n,m,p)\)</span>和直线上一点<span class="math inline">\(M_0=(x_0,y_0,z_0)\)</span>.那么方程显然为: <span class="math display">\[
\frac{x-x_0}{n}=\frac{y-y_0}{m}=\frac{z-z_0}{p}
\]</span> 如果换元,我们还有参数方程: <span class="math display">\[
\begin{cases}x=x_0+nt\\y=y_0+mt\\z=z_0+pt\end{cases}
\]</span></p>
<h5><span id="平面">平面</span></h5>
<p>使用平面上的一点<span class="math inline">\(P_0(x_0,y_0,z_0)\)</span>和该平面的法向量<span class="math inline">\(\vec n\)</span>来表示一个平面,不妨设<span class="math inline">\(\vec n=(A,B,C)\)</span>,则该平面的方程显然为:
<span class="math display">\[
A(x-x_0)+B(y-y_0)+C(z-z_0)=0
\]</span> 如果我们令<span class="math inline">\(D=-(Ax_0+By_0+Cz_)\)</span>,那么平面方程为: <span class="math display">\[
Ax+By+Cz+D=0
\]</span></p>
<h5><span id="夹角">夹角</span></h5>
<h6><span id="两直线夹角">两直线夹角.</span></h6>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是<span class="math inline">\(\vec
{s_1}=(n_1,m_1,p_1),\vec{s_2}=(n_2,m_2,p_2)\)</span>,也就有<span class="math inline">\(\varphi=\arccos(\frac{|\vec s_1\sdot \vec
s_2|}{|\vec s_1||\vec s_2|})\\\)</span>.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6>
<p>同样使用向量,不妨设方向向量<span class="math inline">\(\vec
s=(n,m,p)\)</span>,法向量<span class="math inline">\(\vec
f=(a,b,c)\)</span>,那么<span class="math inline">\(\varphi=\arcsin(\frac{|\vec s\sdot \vec f|}{|\vec
s||\vec f|})\)</span>.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li>若直线与平面平行,则<span class="math inline">\(am+bn+cp=0\)</span>.</li>
<li>若直线与平面垂直,则<span class="math inline">\(\frac{a}{m}=\frac{b}{n}=\frac{c}{p}\)</span>.注意这里分母可能除以<span class="math inline">\(0\)</span>,我们实际上应该是三个形如<span class="math inline">\(a=mt\)</span>的参数方程,这里简化了.</li>
</ol>
<h5><span id="交点">交点</span></h5>
<p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3>
<h4><span id="约定">约定</span></h4>
<p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可(<span class="math inline">\(mx+ny=1\)</span>需要判断过原点的直线,<span class="math inline">\(y=kx+b\)</span>需要判断平行于<span class="math inline">\(y\)</span>轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点<span class="math inline">\(F_1,F_2\)</span>距离之和为常数(<span class="math inline">\(&gt; |F_1F_2|\)</span>)的点轨迹.即:<span class="math inline">\(\{P\mid
|F_1P|+|F_2P|=2a,F_1(-c,0),F_2(c,0)\}\)</span>.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线(<span class="math inline">\(x=\pm
\frac{a^2}c\)</span>)的距离比是常数<span class="math inline">\(e=\frac{c}a\)</span>的点轨迹,即<span class="math inline">\(\{P\mid
\frac{|PF_1|}{d_1}=\frac{|PF_2|}{d_2}=\frac{c}{a}=e,F_1(-c,0),F_2(c,0)\}\)</span>.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点<span class="math inline">\(A_1(-a,0),A_2(a,0)\)</span>的斜率乘积等于定值<span class="math inline">\(e^2-1\)</span>的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5>
<h6><span id="标准方程">标准方程</span></h6>
<p>由定义不难得到椭圆的标准方程:<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(b^2=a^2-c^2,a&gt;b&gt;0)\)</span>.</p>
<h6><span id="一般方程">一般方程</span></h6>
<p><span class="math inline">\(nx^2+my^2=1(n,m\geq
0)\)</span>,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若<span class="math inline">\(P(x_0,y_0)\)</span>,则<span class="math inline">\(|PF_1|=a+ex_0\)</span>,<span class="math inline">\(|PF_2|=a-ex_0\)</span>.</p>
<h6><span id="焦点弦">焦点弦</span></h6>
<p>过<span class="math inline">\(F_1\)</span>的弦<span class="math inline">\(|AB|=2a+e(x_1+x_2)\)</span>.</p>
<p>过<span class="math inline">\(F_2\)</span>的弦<span class="math inline">\(|AB|=2a-e(x_1+x_2)\)</span>.</p>
<p>注意到焦点弦最短时<span class="math inline">\(x_1=x_2\)</span>.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即<span class="math inline">\(\bigtriangleup PF_1F_2\)</span>,令<span class="math inline">\(\theta=\angle F_1PF_2\)</span>,有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(C=2a+2c\)</span>.</li>
<li><span class="math inline">\(S=b^2\tan\frac{\theta}{2}=c|y_P|\)</span>.</li>
<li><span class="math inline">\(\cos\theta\geq 1-2e^2\)</span>(当<span class="math inline">\(P\)</span>在短轴上取等).</li>
<li><span class="math inline">\(|PF_1||PF_2|=\frac{2b^2}{1+\cos\theta}\)</span>.</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>已知椭圆<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\)</span>,<span class="math inline">\(P\)</span>是椭圆上一点,<span class="math inline">\(\angle F_1PF_2\)</span>的角平分线交<span class="math inline">\(x\)</span>轴于<span class="math inline">\(Q(\frac{c}4,0)\)</span>,求离心率取值范围.</p>
<p>注意到<span class="math inline">\(S_{\bigtriangleup
QPF_1}=\frac{5}{3}S_{\bigtriangleup QPF_2}\)</span>,又有<span class="math inline">\(Q\)</span>到<span class="math inline">\(PF_1\)</span>和<span class="math inline">\(PF_2\)</span>的距离相等,用等积法,显然<span class="math inline">\(PF_1=\frac{5}4a,PF_2=\frac{3}4a\)</span>.</p>
<p>然后用三角形不等式做差就行.<span class="math inline">\(2c&gt;\frac{1}{2}a,\frac{1}{4}&lt;e\)</span></p>
<h4><span id="双曲线">双曲线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点<span class="math inline">\(F_1,F_2\)</span>距离之差为常数(<span class="math inline">\(&gt; |F_1F_2|\)</span>)的点轨迹.即:<span class="math inline">\(\{P\mid
||F_1P|-|F_2P||=2a,F_1(-c,0),F_2(c,0)\}\)</span>.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线(<span class="math inline">\(x=\pm
\frac{a^2}c\)</span>)的距离比是常数<span class="math inline">\(e=\frac{c}a\)</span>的点轨迹,即<span class="math inline">\(\{P\mid
\frac{|PF_1|}{d_1}=\frac{|PF_2|}{d_2}=\frac{c}{a}=e,F_1(-c,0),F_2(c,0)\}\)</span>.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点<span class="math inline">\(A_1(-a,0),A_2(a,0)\)</span>的斜率乘积等于定值<span class="math inline">\(e^2-1\)</span>的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若<span class="math inline">\(P(x_0,y_0),(x_0&gt;0)\)</span>,则<span class="math inline">\(|PF_1|=a+ex_0\)</span>,<span class="math inline">\(|PF_2|=-a+ex_0\)</span>.</p>
<h6><span id="渐近线">渐近线</span></h6>
<p><span class="math inline">\(y=\pm \frac{b}ax\)</span>.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成<span class="math inline">\(0\)</span>得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即<span class="math inline">\(\bigtriangleup PF_1F_2\)</span>,令<span class="math inline">\(\theta=\angle F_1PF_2\)</span>,有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(S=\frac{b^2}{\tan\frac{\theta}{2}}\)</span>.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5>
<h6><span id="焦点弦">焦点弦</span></h6>
<p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线<span class="math inline">\(AB\)</span>为过<span class="math inline">\(y^2=2px(p&gt;0)\)</span>焦点的弦,<span class="math inline">\(A(x_1,y_1),B(x_2,y_2)\)</span>,倾斜角为<span class="math inline">\(\theta\)</span>,准线与<span class="math inline">\(x\)</span>轴交点为<span class="math inline">\(E(-\frac{p}2,0)\)</span>,作<span class="math inline">\(AA_1\)</span>,<span class="math inline">\(BB_1\)</span>垂直于准线于<span class="math inline">\(A_1,B_1\)</span>,则:</p>
<ol type="1">
<li><span class="math inline">\(|AF|=x_1+\frac{p}2\)</span>,<span class="math inline">\(|BF|=x_2+\frac{p}2\)</span>,<span class="math inline">\(|AB|=x_1+x_2+p,\frac{1}{|FA|}+\frac{1}{|FB|}=\frac{2}p\)</span>.</li>
<li><span class="math inline">\(|AF|=\frac{p}{1-\cos\theta},|BF|=\frac{p}{1+\cos\theta},|AB|=\frac{2p}{\sin^2\theta}\)</span>.</li>
<li><span class="math inline">\(x_1x_2=\frac{p^2}4\)</span>,<span class="math inline">\(y_1y_2=-p^2\)</span>.</li>
<li><span class="math inline">\(S_{\bigtriangleup
AOB}=\frac{p^2}{2\sin\theta}\)</span>.</li>
<li><span class="math inline">\(k_{AE}+k_{BE}=0\)</span>.</li>
<li><span class="math inline">\(A,O,B_1\)</span>三点共线,<span class="math inline">\(B,O,A_1\)</span>三点共线.</li>
<li>以<span class="math inline">\(AB\)</span>为直径的圆与抛物线的准线相切.</li>
<li>以<span class="math inline">\(A_1B_1\)</span>为直径的圆与<span class="math inline">\(AB\)</span>相切.</li>
<li>以<span class="math inline">\(AF\)</span>或<span class="math inline">\(BF\)</span>为直径的圆与<span class="math inline">\(y\)</span>轴相切.</li>
</ol>
<h4><span id="通用解法">通用解法</span></h4>
<h5><span id="联立方程">联立方程</span></h5>
<h6><span id="点参">点参</span></h6>
<p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线<span class="math inline">\(l\)</span>上有两点<span class="math inline">\(N(x_1,y_1),M(x_2,y_2)\)</span>,这条直线的斜率为<span class="math inline">\(k\)</span>,那么<span class="math inline">\(|NM|=\sqrt{1+k^2}|x_1-x_2|=\sqrt{1+\frac{1}{k^2}}|y_1-y_2|\)</span>.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点<span class="math inline">\(A(x_1,y_1),B(x_2,y_2)\)</span>,其中点<span class="math inline">\(M(x_0,y_0)\)</span>,有<span class="math inline">\(2x_0=x_1+x_2,2y_0=y_1+y_2\)</span>.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线<span class="math inline">\(l\)</span>与曲线交于两点<span class="math inline">\(N(x_1,y_1),M(x_2,y_2)\)</span>,这条直线的斜率为<span class="math inline">\(k\)</span>,<span class="math inline">\(MN\)</span>的中点为<span class="math inline">\(P(x_0,y_0)\)</span>,那么:</p>
<ol type="1">
<li>在椭圆<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}=1(a&gt;b&gt;0)\)</span>中,<span class="math inline">\(k\frac{y_0}{x_0}=-\frac{b^2}{a^2}=e^2-1\)</span>.</li>
<li>在双曲线<span class="math inline">\(\frac{x^2}{a^2}-\frac{y^2}{b^2}=1\)</span>中,<span class="math inline">\(k\frac{y_0}{x_0}=\frac{b^2}{a^2}=e^2-1\)</span>.</li>
<li>在抛物线<span class="math inline">\(y^2=2px(p&gt;0)\)</span>中,<span class="math inline">\(k=\frac{p}{y_0}=\frac{x_0}p\)</span>.</li>
</ol>
<h6><span id="小联立">小联立</span></h6>
<p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6>
<p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线<span class="math inline">\(PA\)</span>,<span class="math inline">\(PB\)</span>,我们可以将公共点<span class="math inline">\(P\)</span>平移至原点,这样<span class="math inline">\(PA\)</span>和<span class="math inline">\(PB\)</span>的方程都方便表达.然后设<span class="math inline">\(AB\)</span>的方程为<span class="math inline">\(mx+ny=1\)</span>(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以<span class="math inline">\(mx+ny\)</span>,零次项乘以<span class="math inline">\((mx+ny)^2\)</span>,这样就得到了一个齐次式子.将两边同时除以<span class="math inline">\(x^2\)</span>后就得到了一个和<span class="math inline">\(k=\frac{y}x\)</span>有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的<span class="math inline">\(x_1x_2\)</span>和<span class="math inline">\(x_1+x_2\)</span>之间的关系来做.</p>
<p>当然还有一种情况是问形如<span class="math inline">\(\frac{Ax_1+Bx_2}{Cx_1+Dx_2}\)</span>是定值的问题,这个时候一定有<span class="math inline">\(\frac{A}C=\frac{B}{D}\)</span>.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令<span class="math inline">\(w=\frac{x_1}{x_2}\)</span>,自然有<span class="math inline">\(w+\frac{1}{w}+2=\frac{(x_1+x_2)^2}{x_1x_2}\)</span>.</p>
<p>还比如有<span class="math inline">\(y_2=ny_1+m\)</span>,我们可以用配凑技巧改写作<span class="math inline">\((y_2+w)=k(y_1+w)\)</span>,也就有<span class="math inline">\(\frac{y_2+w}{y_1+w}=k\)</span>,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线<span class="math inline">\(y=kx+\varphi\)</span>与曲线<span class="math inline">\(\frac{x^2}{m}+\frac{y^2}{n}=1\)</span>相交于<span class="math inline">\(A(x_1,y_1)\)</span>和<span class="math inline">\(B(x_2,y_2)\)</span>.</p>
<p>那么联立方程是:<span class="math inline">\((n+mk^2)x^2+2k\varphi
mx+m(\varphi^2-n)=0\)</span>.</p>
<p>判别式:<span class="math inline">\(\Delta=4mn(n+mk^2-\varphi^2)\)</span>.</p>
<p>韦达定理: <span class="math display">\[
x_1+x_2=\frac{-2km\varphi}{n+mk^2}\\
x_1x_2=\frac{m(\varphi^2-n)}{n+mk^2}\\
|x_1-x_2|=\frac{\sqrt{\Delta}}{n+mk^2}
\]</span></p>
<h6><span id="配凑法">配凑法</span></h6>
<p>参考:https://zhuanlan.zhihu.com/p/521025768.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6>
<p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线<span class="math inline">\(y^2=4x\)</span>,若<span class="math inline">\(A,B\)</span>位于抛物线上<span class="math inline">\(x\)</span>轴上方不同的两点,直线<span class="math inline">\(OA,OB\)</span>的斜率分别为<span class="math inline">\(k_1,k_2\)</span>,且满足<span class="math inline">\(k_1k_2-4=4k_1+4k_2\)</span>,求证:<span class="math inline">\(AB\)</span>过定点,并求出<span class="math inline">\(k_{AB}\)</span>的取值范围.</p>
<p>注意到<span class="math inline">\(k_1\)</span>和<span class="math inline">\(k_2\)</span>之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设<span class="math inline">\(AB:y=kx+b\)</span>,则<span class="math inline">\(A(x_1,kx_1+b),B(x_2,kx_2+b)\)</span>,显然<span class="math inline">\(k_1=k+\frac{b}{x_1},k_2=k+\frac{b}{x_2}\)</span>.</p>
<p>直接带入方程,有: <span class="math display">\[
(k+\frac{b}{x_1})(k+\frac{b}{x_2})-4=4(2k+\frac{b}{x_1}+\frac{b}{x_2})\\
k^2+kb(\frac{1}{x_1}+\frac{1}{x_2})+\frac{b^2}{x_1x_2}-4=8k+4b(\frac{1}{x_1}+\frac{1}{x_2})\\
\]</span> 而直接大联立得到的式子是: <span class="math display">\[
k^2x^2+(2kb-4)x+b^2=0\\
\Delta=16-16kb&gt;0,kb&lt;1\\
x_1x_2=\frac{b^2}{k^2},x_1+x_2=\frac{4-2kb}{k^2},\frac{1}{x_1}+\frac{1}{x_2}=\frac{4-2kb}{b^2}
\]</span> 带入,得到<span class="math inline">\(k-b=4\)</span>,因此过定点<span class="math inline">\((-1,-4)\)</span>,与<span class="math inline">\(kb&lt;1\)</span>联立得到<span class="math inline">\(k&lt;2+\sqrt 5\)</span>.</p>
<p>还没完,这种题一定要检查一遍条件.注意到<span class="math inline">\(AB\)</span>为<span class="math inline">\(x\)</span>轴上方两点的性质没用到,这意味着<span class="math inline">\(y_1y_2&gt;0\and
y_1+y_2&gt;0\)</span>,带入方程得到: <span class="math display">\[
b^2+b(\frac{4-2kb}{k})+b^2&gt;0\\
\frac{4-2kb}{k}+2b&gt;0
\]</span> 化简得到<span class="math inline">\(\begin{cases}b&gt;0\\k&gt;0\end{cases}\)</span>,解得<span class="math inline">\(k&gt;4\)</span>,于是<span class="math inline">\(k\in(4,2+\sqrt 5)\)</span>.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,<span class="math inline">\(OA\)</span>和<span class="math inline">\(OB\)</span>的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参: <span class="math display">\[
k_{OA}=\frac{y_1}{x_1},k_{OB}=\frac{y_2}{x_2}\\
\frac{y_1y_2}{x_1x_2}-4=4(\frac{y_1}{x_1}+\frac{y_2}{x_2})\\
16-4y_1y_2=16(y_1+y_2)
\]</span>
我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:
<span class="math display">\[
AB:\\x-x_1=(y-y_1)\frac{x1-x_2}{y_1-y_2}\\
x-\frac{y_1^2}{4}=(y-y_1)\frac{1}{4}(y_1+y_2)\\
x=\frac{y_1+y_2}{4}y-\frac{y_1y_2}{4}\\
x=\frac{y_1+y_2}{4}y-1+(y_1+y_2)
\]</span> 显然过定点<span class="math inline">\((-1,-4)\)</span>,并且通过<span class="math inline">\(y_1\)</span>和<span class="math inline">\(y_2\)</span>的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个<span class="math inline">\(\frac{x-x_1}{x_1-x_2}=\frac{y-y_1}{y_1-y_2}\)</span>的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{x^2}{4}+y^2=1\)</span>,<span class="math inline">\(P,Q\)</span>在椭圆上,<span class="math inline">\(A(2,0)\)</span>,<span class="math inline">\(k_{AP}k_{AQ}=\frac{1}{20}\)</span>,求证:<span class="math inline">\(PQ\)</span>过定点.</p>
<p>注意到<span class="math inline">\(A(2,0)\)</span>,设<span class="math inline">\(P(x_1,y_1),Q(x_2,y_2)\)</span>,<span class="math inline">\(PQ:m(x-2)+yn=1\)</span>,那么我们要求的也就是<span class="math inline">\(x-2\)</span>和<span class="math inline">\(y\)</span>之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然<span class="math inline">\(\frac{x^2}{4}+y^2=1\Rightarrow
\frac{(x-2)^2}{4}+(x-2)+y^2=0\)</span>.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令<span class="math inline">\(x&#39;=x-2,y&#39;=y\)</span>,我们有<span class="math inline">\(x=x&#39;+2,y=y&#39;\)</span>,带入就可以得到关于<span class="math inline">\(x&#39;,y&#39;\)</span>的方程,然后再带回<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>就行.</p>
<p>我们开始推导: <span class="math display">\[
\begin{aligned}
\frac{(x-2)^2}{4}+(x-2)+y^2=0\\
(x-2)^2+4(x-2)+4y^2=0\\
(x-2)^2+4n(x-2)^2+4my(x-2)+4y^2=0\\
(4n+1)(x-2)^2+4my(x-2)+4y^2=0\\
4n+1+4m\frac{y}{x-2}+4(\frac{y}{x-2})^2=0\\
\end{aligned}
\]</span> 令<span class="math inline">\(k=\frac{y}{x-2}\)</span>,也就得到了<span class="math inline">\(4n+1+4mk+4k^2=0\)</span>.用一遍韦达定理,有:<span class="math inline">\(k_1k_2=\frac{4n+1}{4}=\frac{1}{20},n=-\frac{1}{5}\)</span>.</p>
<p>也就有:<span class="math inline">\(PQ:-\frac{1}{5}(x-2)+my=1\)</span>,显然过定点<span class="math inline">\((-3,0)\)</span>.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{x^2}{9}+y^2=1\)</span>,<span class="math inline">\(P,Q\)</span>是该椭圆上两动点,<span class="math inline">\(M,N\)</span>分别为<span class="math inline">\(P,Q\)</span>在<span class="math inline">\(x\)</span>轴上的射影,而且<span class="math inline">\(k_{OP}k_{OQ}=-1\)</span>,记<span class="math inline">\(S=S_{\bigtriangleup OPM}+S_{\bigtriangleup
OQN}\)</span>,求<span class="math inline">\(S\)</span>的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线<span class="math inline">\(PQ\)</span>很重要的时候,而这个题除了<span class="math inline">\(P,Q\)</span>两点以外,和<span class="math inline">\(PQ\)</span>半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设<span class="math inline">\(P(x_1,y_1),Q(x_2,y_2)\)</span>,<span class="math inline">\(k=\frac{y_1}{x_1},-\frac{1}k=\frac{y_2}{x_2}\)</span>:
<span class="math display">\[
2S=|x_1y_1|+|x_2y_2|\\
=|x_1^2k-\frac{1}kx_2^2|\\
\]</span> 而联立方程,有: <span class="math display">\[
x_1^2=\frac{1}{\frac{1}9+k},x_2^2=\frac{1}{\frac{1}9-\frac{1}k}
\]</span> 代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线<span class="math inline">\(PQ\)</span>有两个未知量,我们还需要拿<span class="math inline">\(k_{OP}k_{OQ}=-1\)</span>限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{x^2}{2}+y^2=1\)</span>,<span class="math inline">\(F(1,0)\)</span>,直线<span class="math inline">\(l\)</span>过<span class="math inline">\(F\)</span>且交椭圆于<span class="math inline">\(A,B\)</span>两点.求问:<span class="math inline">\(x\)</span>轴上是否存在异于<span class="math inline">\(F\)</span>的一点<span class="math inline">\(Q\)</span>,使得<span class="math inline">\(\frac{k_{QA}}{k_{QB}}\)</span>是定值.</p>
<p>直接设<span class="math inline">\(AB:x=ky+1\)</span>,<span class="math inline">\(Q(q,0)\)</span>.我们有: <span class="math display">\[
\frac{k_{QA}}{k_{QB}}=\frac{y_1(q-x_2)}{y_2(q-x_1)}\\
=-\frac{ky_1y_2+y_1-qy_1}{ky_1y_2+y_2-qy_2}
\]</span> 坏了,这咋做.</p>
<p>我们用一下韦达定理得到: <span class="math display">\[
(k^2+2)y^2+2ky-1=0\\
\Delta=8k^2+8&gt;0\\
y_1+y_2=-\frac{2k}{k^2+2}\\
y_1y_2=-\frac{1}{k^2+2}\\
\]</span> 注意到<span class="math inline">\(\frac{(y_1+y_2)}2=k(y_1y_2)\)</span>,代入,有:
<span class="math display">\[
\frac{k_{QA}}{k_{QB}}
=-\frac{y_1+y_2+2y_1-2qy_1}{y_1+y_2+2y_2-2qy_2}\\
=-\frac{(3-2q)y_1+y_2}{(3-2q)y_2+y_1}
\]</span> 若是定值,那么就有:<span class="math inline">\(\frac{3-2q}{1}=\frac{1}{3-2q}\)</span>,解得<span class="math inline">\(q_1=1(F)\)</span>,<span class="math inline">\(q_2=2(Q)\)</span>.</p>
<p>所以<span class="math inline">\(Q(2,0)\)</span>.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{x^2}4+\frac{y^2}3=1\)</span>,过<span class="math inline">\(F(-1,0)\)</span>的直线交椭圆于<span class="math inline">\(M,N\)</span>两点,过<span class="math inline">\(M\)</span>作直线<span class="math inline">\(x=-4\)</span>的垂线,垂足为<span class="math inline">\(E\)</span>,求证:<span class="math inline">\(EN\)</span>过定点.</p>
<p>根据对称原理,显然这个定点一定在<span class="math inline">\(x\)</span>轴上.</p>
<p>我们先写大联立的式子:设<span class="math inline">\(MN:x=-1+ky\)</span>,带入有<span class="math inline">\((3m^2+4)y^2-6my-9=0\)</span>.再设<span class="math inline">\(M(x_1,y_1),N(x_2,y_2)\)</span>,自然有: <span class="math display">\[
\begin{cases}\Delta=144k^2+144\\y_1+y_2=\frac{6k}{3k^2+4}\\y_1y_2=\frac{-9}{3k^2+4}\end{cases}
\]</span> 接下来呢,我们想一下我们要求什么:我们要求出<span class="math inline">\(EN\)</span>的表达式:形如<span class="math inline">\(y-m=k(x-n)\)</span>,然后声明<span class="math inline">\((n,m)\)</span>是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有<span class="math inline">\(k=\frac{y-m}{x-n}\)</span>.而我们现在有两个点<span class="math inline">\(E(-4,y_1)\)</span>和<span class="math inline">\(N(x_2,y_2)\)</span>,又猜出<span class="math inline">\(m=0\)</span>,也就是我们要找到一个<span class="math inline">\(n\)</span>满足<span class="math inline">\(\frac{y_1}{-4-n}=\frac{y_2}{x_2-n}\)</span>.</p>
<p>我们倒着推: <span class="math display">\[
\frac{y_1}{-4-n}=\frac{y_2}{x_2-n}\\
\frac{y_1}{-4-n}=\frac{y_2}{ky_2-1-n}
\]</span> 这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有: <span class="math display">\[
ky_1y_2+\frac{3}{2}(y_1+y_2)=0\\
(x_2+\frac{5}{2})y_1=-\frac{3}{2}y_2\\
y_1=\frac{-3}{2}\frac{y_2}{x_2+\frac{5}{2}}\\
\frac{y_1}{-\frac{3}{2}}=\frac{y_2}{x_2+\frac{5}{2}}\\
\frac{y_1}{-4+\frac{5}{2}}=\frac{y_2}{x_2+\frac{5}{2}}\\
\]</span> 做到这一步发现要做完了,不难发现<span class="math inline">\(n=\frac{5}{2}\)</span>.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了<span class="math inline">\(m=0\)</span>了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5>
<h6><span id="定义">定义</span></h6>
<p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点<span class="math inline">\(P\)</span>作直线<span class="math inline">\(l\)</span>交二次曲线于<span class="math inline">\(M,N\)</span>两点(离<span class="math inline">\(P\)</span>近的是<span class="math inline">\(M\)</span>),则在<span class="math inline">\(l\)</span>上有且只有一点<span class="math inline">\(Q\)</span>,使得<span class="math inline">\(|MQ||NP|=|MP||NQ|\)</span>(即<span class="math inline">\(P,Q,M,N\)</span>构成一调和点列).当<span class="math inline">\(l\)</span>绕着<span class="math inline">\(P\)</span>旋转时,<span class="math inline">\(Q\)</span>的轨迹是一条直线<span class="math inline">\(p\)</span>(或一部分),这条直线<span class="math inline">\(p\)</span>叫做点<span class="math inline">\(P\)</span>关于二次曲线的极线,而<span class="math inline">\(P\)</span>叫做<span class="math inline">\(p\)</span>关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:<span class="math inline">\(p:\frac{x_0x}{a^2}+\frac{y_0y}{b^2}=1\)</span>.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线<span class="math inline">\(C:Ax^2+Bxy+Cy^2+Dx+Ey+F=0\)</span>上的一点<span class="math inline">\(P(x_0,y_0)\)</span>,我们称它的极线为<span class="math inline">\(p:Axx_0+B\frac{x_0y+y_0x}{2}+Cyy_0+D\frac{x+x_0}{2}+E\frac{y+y_0}{2}+F=0\)</span>.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6>
<p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线<span class="math inline">\(C\)</span>,如果点<span class="math inline">\(P\)</span>的极线经过点<span class="math inline">\(Q\)</span>,那么点<span class="math inline">\(Q\)</span>的极线经过点<span class="math inline">\(P\)</span>.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol type="1">
<li>设四边形<span class="math inline">\(ABCD\)</span>(对边不平行)内接于二次曲线<span class="math inline">\(C\)</span>,则对角线交点<span class="math inline">\(P\)</span>的极线是两组对边交点的连线.反之同理,若<span class="math inline">\(P\)</span>在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</li>
<li>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</li>
<li>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6>
<p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知<span class="math inline">\(\frac{\cos \theta}{a}+\frac{\sin
\theta}{b}=1\)</span>,求证:<span class="math inline">\(\frac{1}{a^2}+\frac{1}{b^2}\geq 1\)</span>.</p>
<p>设直线<span class="math inline">\(l:\frac{x}{a}+\frac{y}{b}=1\)</span>,<span class="math inline">\(M(\cos\theta,\sin\theta)\)</span>,则<span class="math inline">\(M\)</span>在<span class="math inline">\(l\)</span>上.</p>
<p>又注意到<span class="math inline">\(M\)</span>显然是在单位圆上,而<span class="math inline">\(l\)</span>是单位圆关于<span class="math inline">\(P(\frac{1}{a},\frac{1}{b})\)</span>的极点.又注意到<span class="math inline">\(l\)</span>与单位圆至少有一个交点,因此<span class="math inline">\(P\)</span>要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{x^2}{4}+\frac{y^2}{3}=1\)</span>,<span class="math inline">\(A_1(-2,0),A_2(2,0),D(\frac{1}{2},0)\)</span>,过<span class="math inline">\(D\)</span>的直线交椭圆于<span class="math inline">\(P,Q\)</span>两点(不与<span class="math inline">\(A_1,A_2\)</span>重合).<span class="math inline">\(A_1P\cap A_2Q=M\)</span>,<span class="math inline">\(A_1Q\cap A_2P=N\)</span>,设<span class="math inline">\(k_1=k_{A_1P},k_2=k_{A_1Q}\)</span>.求证:<span class="math inline">\(k_1k_2\)</span>是定值,求出这个定值并求出<span class="math inline">\(\bigtriangleup DMN\)</span>面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知<span class="math inline">\(MN:x=8\)</span>.</p>
<p>我们先来看已知<span class="math inline">\(MN:x=8\)</span>之后怎么做:</p>
<p>设<span class="math inline">\(P(x_1,y_1),Q(x_2,y_2)\)</span>,再设<span class="math inline">\(PQ:x=ky+\frac{1}2\)</span>,则:<span class="math inline">\(k_1k_2=\frac{y_1}{x_1+2}\frac{y_2}{x_2+2}\)</span>,不难算出<span class="math inline">\(k_1k_2=-\frac{9}{20}\)</span>.</p>
<p>此时<span class="math inline">\(S_{\bigtriangleup
DMN}=|MN||8-\frac{1}2|\frac{1}{2}\)</span>.不难发现只需求出<span class="math inline">\(|MN|_{\min}\)</span>即可.而<span class="math inline">\(MN\bot x\)</span>轴,所以<span class="math inline">\(|MN|=|y_M-y_N|\)</span>.</p>
<p>接下来咋做?第一问求得<span class="math inline">\(k_1\)</span>和<span class="math inline">\(k_2\)</span>的关系不能白求啊!</p>
<p>我们有<span class="math inline">\(A_1P:x=-2+\frac{1}{k_1}y,A_1Q:x=-2+\frac{1}{k_2}y\)</span>,带入<span class="math inline">\(x=8\)</span>,求得<span class="math inline">\(y_M=10k_1,y_N=10k_2\)</span>.</p>
<p>于是<span class="math inline">\(|MN|=10|k_1-k_2|\)</span>.注意到<span class="math inline">\(k_1&gt;0\and -k_2&gt;0\and
k_1(-k_2)=\frac{9}{20}\)</span>,显然可以用基本不等式计算,最后得到<span class="math inline">\(S_{\min}=\frac{45\sqrt 5}{2}\)</span>.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出<span class="math inline">\(A_1Q:x=-2+\frac{y_2}{x_2+2}y,A_2P:x=2+\frac{y_1}{x_1-2}y\)</span>,然后我们声明这两条直线的交点的横坐标一定是<span class="math inline">\(8\)</span>,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5>
<p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\)</span>.</p>
<p>我们将<span class="math inline">\(y\)</span>看作<span class="math inline">\(x\)</span>的函数,对两边求导,自然得到: <span class="math display">\[
\frac{2x}{a^2}+\frac{2yy&#39;}{b^2}=0
\]</span> 这是个方程,你可以解得<span class="math inline">\(y&#39;=-\frac{b^2x}{a^2y}\)</span>.而这就是椭圆过<span class="math inline">\((x,y)\)</span>这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5>
<p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6>
向量<span class="math inline">\(\vec{b}=(x,y)\)</span>逆时针旋转<span class="math inline">\(\theta\)</span>后得到的答案是<span class="math inline">\(A\vec{b}\)</span>,其中$A=
<span class="math display">\[\begin{bmatrix}
\cos\theta,-\sin\theta\\
\sin\theta,\cos\theta
\end{bmatrix}\]</span>
<p>$.</p>
<p>你要不喜欢矩阵表示也不是不行,那向量<span class="math inline">\((x,y)\)</span>旋转<span class="math inline">\(\theta\)</span>得到<span class="math inline">\((x&#39;,y&#39;)\)</span>,其中<span class="math inline">\(x&#39;=xcos\theta-ysin\theta\\
y&#39;=xsin\theta+ycos\theta\)</span>.</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6>
<p>我们注意到圆的方程是<span class="math inline">\((x&#39;)^2+(y&#39;)^2=1\)</span>,而椭圆的方程形如<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\)</span>.</p>
<p>我们注意到上面的式子等价于:<span class="math inline">\((\frac{x}{a})^2+(\frac{y}{b})^2=1\)</span>.我们将原坐标系中的所有坐标<span class="math inline">\((x,y)\)</span>全部变成<span class="math inline">\((\frac{x}a,\frac{y}b)\)</span>之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令<span class="math inline">\(\vec
f=(x,y)\)</span>满足椭圆方程,令<span class="math inline">\(\vec
g=(x&#39;,y&#39;)\)</span>满足圆的方程,自然有: <span class="math display">\[
\begin{bmatrix}\frac{1}a,0\\0,\frac{1}{b}\end{bmatrix}\vec{f}=\vec{g}\\
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}a,0\\0,{b}\end{bmatrix}\vec{g}=\vec{f}
\]</span></p>
<h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6>
<p>注意到反比例函数的方程是<span class="math inline">\(x&#39;y&#39;=1\)</span>,而双曲线的方程是<span class="math inline">\(\frac{x^2}{a^2}-\frac{y^2}{b^2}=1\)</span>.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
<p>首先先转化为<span class="math inline">\(x^2-y^2=2\)</span>的形式,需要左乘矩阵<span class="math inline">\(\begin{bmatrix}\frac{\sqrt{2}}a,0\\0,\frac{\sqrt{2}}{b}\end{bmatrix}\)</span>.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转<span class="math inline">\(\frac{\pi}4\)</span>了.旋转矩阵为<span class="math inline">\(\begin{bmatrix}
\frac{1}{\sqrt{2}},-\frac{1}{\sqrt{2}}\\
\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}
\end{bmatrix}\)</span>.</p>
<p>把两个东西乘起来得到矩阵<span class="math inline">\(\begin{bmatrix}
\frac{1}{a},-\frac{1}{b}\\
\frac{1}{a},\frac{1}{b}
\end{bmatrix}\)</span>.</p>
<p>验证一下,我们有<span class="math inline">\(x&#39;=\frac{x}{a}-\frac{y}{b},y&#39;=\frac{x}{a}+\frac{y}{b}\)</span>.带入反比例函数的方程:
<span class="math display">\[
x&#39;y&#39;=\frac{x^2}{a^2}-\frac{y^2}{b^2}=1
\]</span> 对着矩阵求逆一下得到:逆矩阵为<span class="math inline">\(\begin{bmatrix}
\frac{a}{2},\frac{a}{2}\\
-\frac{b}{2},\frac{b}{2}
\end{bmatrix}\)</span>.</p>
<p>验证一下,我们有<span class="math inline">\(x=\frac{a}{2}(x&#39;+y&#39;),y=\frac{b}{2}({y&#39;-x&#39;})\)</span>,带入双曲线方程得到:
<span class="math display">\[
(\frac{x}{a})^2-(\frac{y}{b})^2=1\\
(x&#39;+y&#39;)^2-(x&#39;-y&#39;)^2=4\\
x&#39;y&#39;=1
\]</span> 要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6>
<p>这个比较简单,交换<span class="math inline">\(x,y\)</span>即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5>
<p>平面内取一点<span class="math inline">\(O\)</span>为极点,引一条射线<span class="math inline">\(Ox\)</span>叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点<span class="math inline">\(M\)</span>,令<span class="math inline">\(\rho=|OM|\)</span>,<span class="math inline">\(\theta\)</span>为以<span class="math inline">\(Ox\)</span>为始边,沿角度正方向(一般是逆时针方向)转到<span class="math inline">\(OM\)</span>的夹角.那么我们称<span class="math inline">\((\rho,\theta)\)</span>为<span class="math inline">\(M\)</span>的极坐标,其中<span class="math inline">\(\rho\)</span>叫做极径,<span class="math inline">\(\theta\)</span>叫做极角.</p>
<p><span class="math inline">\(\rho\)</span>有可能取负,我们通常认为<span class="math inline">\((-\rho,\theta)=(\rho,\theta+\pi)\)</span>.</p>
<p>通常情况下默认<span class="math inline">\(0\leq
\theta&lt;2\pi,\rho\geq
0\)</span>.如果遇到和直角坐标系结合的问题,通常默认原点为极点,<span class="math inline">\(x\)</span>轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若<span class="math inline">\(M\)</span>在直角坐标系中坐标为<span class="math inline">\((x,y)\)</span>,在极坐标中坐标为<span class="math inline">\((\rho,\theta)\)</span>,若<span class="math inline">\(M\ne O\)</span>自然有: <span class="math display">\[
x=\rho\cos\theta,y=\rho\sin\theta\\
\rho^2=x^2+y^2,\theta=\begin{cases}\frac{\pi}{2}&amp;x=0\and
y&gt;0\\\frac{3\pi}{2}&amp;x=0\and y&lt;0\\\arctan(\frac{y}{x})&amp;x\ne
0\end{cases}
\]</span>
看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6>
<p>显然是<span class="math inline">\(\rho^2=r^2\)</span>.</p>
<p>另外,如果中心在<span class="math inline">\(C(\rho_0,\theta_0)\)</span>,半径为<span class="math inline">\(r\)</span>的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有: <span class="math display">\[
r^2=(\rho\cos\theta-\rho_0\cos\theta_0)^2+(\rho\sin\theta-\rho_0\sin\theta_0)\\r^2=\rho^2+\rho_0^2-2\rho\rho_0\cos\theta\cos\theta_0-2\rho\rho_0\sin\theta\sin\theta_0\\
r^2=\rho^2+\rho_0^2-2\rho\rho_0\cos(\theta-\theta_0)
\]</span> 另外由于<span class="math inline">\(\cos\theta=\cos(-\theta)\)</span>,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6>
<p>过定点<span class="math inline">\((\rho_1,\theta_1)\)</span>,且倾斜角为<span class="math inline">\(\alpha\)</span>:<span class="math inline">\(\rho\sin(\alpha-\theta)=\rho_1\sin(\alpha-\theta_1)\)</span>.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点<span class="math inline">\((x_1,y_1)\)</span>,倾斜角为<span class="math inline">\(\alpha\)</span>,我们自然有<span class="math inline">\((x-x_1)\sin\alpha=(y-y_1)\cos\alpha\)</span>.</p>
<p>于是有: <span class="math display">\[
(x-x_1)\sin\alpha=(y-y_1)\cos\alpha\\
(\rho\cos\theta-\rho_1\cos\theta_1)\sin\alpha=(\rho\sin\theta-\rho_1\sin\theta_1)\cos\alpha\\
\rho\sin(\alpha-\theta)=\rho_1\sin(\alpha-\theta_1)
\]</span> 其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点<span class="math inline">\((\rho_1,\theta_1)\)</span>和<span class="math inline">\((\rho_2,\theta_2)\)</span>的直线方程.</p>
<p>同理的: <span class="math display">\[
(x-x_1)(y_2-y_1)=(y-y_1)(x_2-x_1)\\\\
(\rho\cos\theta-\rho_1\cos\theta_1)(\rho_2\sin\theta_2-\rho_1\sin\theta_1)\\=(\rho_2\cos\theta_2-\rho_1\cos\theta_1)(\rho\sin\theta-\rho_1\sin\theta_1)\\
\\
\rho\rho_2(\cos\theta\sin\theta_2-\cos\theta_2\sin\theta)\\+\rho\rho_1(-\cos\theta\sin\theta_1+\sin\theta\cos\theta_1)\\
+\rho_1\rho_2(-\cos\theta_1\sin\theta_2+\cos\theta_2\sin\theta_1)\\=0\\\\
\rho\rho_2\sin(\theta_2-\theta)+\rho\rho_1\sin(\theta-\theta_1)+\rho_1\rho_2\sin(\theta_1-\theta_2)=0
\]</span> 太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6>
<p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离<span class="math inline">\(d\)</span>和到定点距离<span class="math inline">\(r\)</span>之比为常数的曲线.令<span class="math inline">\(e=\frac{r}d\)</span>.</p>
<p>假定定点为原点,极轴垂直于准线,<span class="math inline">\(h\)</span>为定点到准线的距离,又设曲线上一点为<span class="math inline">\(M(\rho,\theta)\)</span>,自然有:<span class="math inline">\(r=\rho,d=h+\rho\cos\theta\)</span>.</p>
<p>于是有: <span class="math display">\[
e=\frac{\rho}{h+\rho \cos \theta}\\
he+e\rho\cos\theta=\rho\\
\rho=\frac{he}{1-e\cos \theta}
\]</span> 值得一提的是这玩意不能将圆理解为<span class="math inline">\(e=0\)</span>的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5>
<p>在平面直角坐标系中,曲线上任意一点的坐标<span class="math inline">\(x,y\)</span>都是某个变量<span class="math inline">\(t\)</span>的函数<span class="math inline">\(\begin{cases}x=f(t)\\y=g(t)\end{cases}\)</span>.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6>
<p><span class="math inline">\(M(r\cos\theta,r\sin\theta)\)</span>,其中<span class="math inline">\(\theta\)</span>是<span class="math inline">\(\angle OMx\)</span>.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6>
<p><span class="math inline">\(M(x_0+t\cos\theta,y_0+t\sin\theta)\)</span>,其中<span class="math inline">\(\theta\)</span>是倾斜角,<span class="math inline">\(t\)</span>是参数,<span class="math inline">\(M_0(x_0,y_0)\)</span>.</p>
<p>注意到<span class="math inline">\(|M_0M|=|t|\)</span>.事实上,设<span class="math inline">\(\vec{e}=(\cos \theta,\sin
\theta)\)</span>,也就是直线的单位方向向量,则<span class="math inline">\(\overrightarrow{M_0M}=t\vec{e}\)</span>.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6>
<p><span class="math inline">\(M(a\cos\theta,b\sin\theta)\)</span>,其中<span class="math inline">\(\theta\)</span>称为<span class="math inline">\(M\)</span>的离心角.</p>
<p>值得注意的是,这里的<span class="math inline">\(\theta\)</span>并非<span class="math inline">\(\angle
MOx\)</span>,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆<span class="math inline">\(\frac{x^2}{9}+\frac{y^2}4=1\)</span>上求一点<span class="math inline">\(M\)</span>,使<span class="math inline">\(M\)</span>到直线<span class="math inline">\(x+2y-10=0\)</span>的距离最小.</p>
<p>直接令<span class="math inline">\(M=(3\cos \theta,2\sin
\theta)\)</span>,则<span class="math inline">\(d=\frac{|3\cos
\theta+4\sin\theta -10|}{\sqrt 5}=|\sqrt5\sin(\theta+\varphi)-2\sqrt
5|\)</span>,其中<span class="math inline">\(\varphi=\arcsin\frac{3}5\)</span>.</p>
<p>于是<span class="math inline">\(d_{\min}=\sqrt 5\)</span>,此时<span class="math inline">\(\sin(\theta+\varphi)=1=\sin{\frac{\pi}{2}}\)</span>,那么就有<span class="math inline">\(\theta=\frac{\pi}2-\varphi\)</span>,<span class="math inline">\(\sin\theta=\cos\varphi=\frac{4}5,\cos\theta=\sin\varphi=\frac{3}5\)</span>.</p>
<p>则<span class="math inline">\(M=(\frac{9}5,\frac{8}5)\)</span>.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{x^2}{100}+\frac{y^2}{64}=1\)</span>,有一内接矩阵<span class="math inline">\(ABCD\)</span>(<span class="math inline">\(AB//x,BC// y\)</span>),求矩阵最大面积.</p>
<p>直接令<span class="math inline">\(A=(10\cos \theta,8\sin
\theta)\)</span>,则<span class="math inline">\(S=20\cos \theta\times
16\sin \theta=160\sin(2\theta)\)</span>,<span class="math inline">\(S_{\max}=160\)</span>.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6>
<p><span class="math inline">\(M(\frac
a{\cos\theta},b\tan\theta)=M(a\sec\theta,b\tan
\theta)\)</span>,其中<span class="math inline">\(\theta\)</span>称为<span class="math inline">\(M\)</span>的离心角,通常规定<span class="math inline">\(\theta\in[0,2\pi]\and
\theta\ne\frac{\pi}{2}\and\theta\ne\frac{3\pi}2\)</span>.</p>
<p>其实本质也就是三角恒等式<span class="math inline">\(\sec^2\theta=1+\tan ^2\theta\)</span>.</p>
<p><strong>Example1</strong></p>
<p>圆<span class="math inline">\(O:x^2+(y-2)^2=1\)</span>上有一点<span class="math inline">\(P\)</span>,双曲线<span class="math inline">\(x^2-y^2=1\)</span>上有一点<span class="math inline">\(Q\)</span>,求<span class="math inline">\(|PQ|_{\min}\)</span>.</p>
<p>设<span class="math inline">\(Q(\sec\theta,\tan\theta)\)</span>,则:
<span class="math display">\[
|OQ|^2=\sec^2\theta+(\tan\theta-2)^2\\=\tan^2\theta+1(\tan\theta-2)^2\\=2(\tan\theta-1)^2+3
\]</span> <span class="math inline">\(|OQ|_{\min}=\sqrt
3,|PQ|_{\min}=\sqrt 3-1\)</span>.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设<span class="math inline">\(P(a\sec \theta,a\tan
\theta),Q(-a\sec\theta,a\tan \theta)\)</span>,则<span class="math inline">\(k_P=\frac{a\tan\theta}{a\sec\theta-a},k_Q=\frac{a\tan\theta}{-a\sec\theta-a}\)</span>.注意到<span class="math inline">\(k_P\sdot k_Q=-1\)</span>.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线<span class="math inline">\(\frac{x^2}{a^2}-\frac{y^2}{b^2}=1\)</span>,<span class="math inline">\(A,B\)</span>是双曲线同支上相异两点,线段<span class="math inline">\(AB\)</span>的垂直平分线与<span class="math inline">\(x\)</span>轴相交于点<span class="math inline">\(P(x_0,0)\)</span>,求证:<span class="math inline">\(|x_0|&gt;\frac{c^2}{a}=\frac{a^2+b^2}a\)</span>.</p>
<p>设<span class="math inline">\(A(a\sec\alpha,b\tan\alpha),B(a\sec
\beta,b\tan\beta)\)</span>,则中点<span class="math inline">\(M(\frac{a}2(\sec\alpha+\sec\beta),\frac{b}2(\tan
\alpha+\tan\beta))\)</span>.</p>
<p>于是中垂线方程为<span class="math inline">\(y-\frac{b}2(\tan
\alpha+\tan\beta))=-\frac{a(\sec\alpha-\sec\beta)}{b(\tan
\alpha-\tan\beta)}[x-\frac{a}2(\sec \alpha+\sec\beta)]\)</span>.</p>
<p>代入<span class="math inline">\(P(x_0,0)\)</span>,求得<span class="math inline">\(x_0=\frac{c^2}{2a}(\sec\alpha+\sec\beta)\)</span>.</p>
<p>也就是要比较<span class="math inline">\(|\sec\alpha+\sec
\beta|\)</span>和<span class="math inline">\(2\)</span>的大小关系,注意到<span class="math inline">\(A,B\)</span>同支,所以<span class="math inline">\(|\sec\alpha+\sec \beta|&gt;2\)</span>.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6>
<p><span class="math inline">\(M(\frac{2p}{\tan^2\theta},\frac{2p}{\tan\theta})\)</span>,其中<span class="math inline">\(\theta\)</span>称为<span class="math inline">\(M\)</span>的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:<span class="math inline">\(M(2pk^2,2pk)\)</span>,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
<p>若抛物线<span class="math inline">\(\begin{cases}x=2pt^2\\y=2pt\end{cases}\)</span>上有不同两点<span class="math inline">\(M_1,M_2\)</span>,所对应的参数分别是<span class="math inline">\(t_1,t_2\)</span>,求直线<span class="math inline">\(M_1M_2\)</span>所在直线的斜率.</p>
<p><span class="math inline">\(k_{M_1M_2}=\frac{2pt_1-2pt_2}{2pt_1^2-2pt_2^2}=\frac{1}{t_1+t_2}\)</span>.</p>
<p><strong>Example2</strong></p>
<p><span class="math inline">\(A,B\)</span>是抛物线<span class="math inline">\(y^2=2px\)</span>上异于顶点的两动点,且<span class="math inline">\(OA\bot OB\)</span>,<span class="math inline">\(AB\)</span>上有一点<span class="math inline">\(M\)</span>满足<span class="math inline">\(OM\bot
AB\)</span>,求<span class="math inline">\(M\)</span>的轨迹方程.</p>
<p>设<span class="math inline">\(M(x,y),A(2pt_1^2,2pt_1),B(2pt_2^2,2pt_2)\)</span>,注意到:
<span class="math display">\[
\overrightarrow{OM}=(x,y)\\\overrightarrow{OA}=(2pt_1^2,2pt_1)\\\overrightarrow{OB}=(2pt_2^2,2pt_2)\\\overrightarrow
{AB}=(2p(t_2^2-t_1^2),2p(t_2-t_1))
\]</span> 因为<span class="math inline">\(\overrightarrow{OA}\bot\overrightarrow{OB}\)</span>,所以<span class="math inline">\((2pt_1t_2)^2+(2p)^2t_1t_2=0\)</span>,<span class="math inline">\(t_1t_2=-1\)</span>.</p>
<p>因为<span class="math inline">\(\overrightarrow{AB}\bot\overrightarrow{OM}\)</span>,又有<span class="math inline">\(k_{AB}=\frac1{t_1+t_2}\)</span>,所以<span class="math inline">\(k_{OM}=-(t_1+t_2)\)</span>,<span class="math inline">\(\frac{y}x=-(t_1+t_2)\)</span>.</p>
<p>接下来咋做捏?注意到我们好像忘记了<span class="math inline">\(ABM\)</span>三点共线的性质,拿向量做这个东西.</p>
<p><span class="math inline">\(\overrightarrow{AM}=(x-2pt_1^2,y-2pt_1),\overrightarrow{MB}=(2pt_2^2-x,2pt_2-y)\)</span>.</p>
<p>那么有<span class="math inline">\((x-2pt_1^2)(2pt_2-y)=(2pt_2^2-x)(y-2pt_1)\)</span>.</p>
<p>化简得到<span class="math inline">\(x^2+y^2-2px=0(x\ne
0)\)</span>.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点<span class="math inline">\(A,B\)</span>,自然要设出它们的参数方程.然后呢?然后我们发现最后<span class="math inline">\(M\)</span>一定和<span class="math inline">\(t_1,t_2\)</span>有关.但是我们要求的是<span class="math inline">\(M\)</span>的方程,其中不能带有<span class="math inline">\(t_1,t_2\)</span>,因此考虑把<span class="math inline">\(M\)</span>的坐标设出来,再用这个坐标表示<span class="math inline">\(t_1,t_2\)</span>,表示不出来表示<span class="math inline">\(t_1t_2,t_1+t_2\)</span>也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到<span class="math inline">\(M\)</span>一定在以<span class="math inline">\(|OA|\)</span>为直径的圆上,<span class="math inline">\(B\)</span>同理,这两个圆的方程分别为: <span class="math display">\[
x^2+y^2-2pt_1^2x-2pt_1y=0\\
x^2+y^2-2pt_2^2x-2pt_2y=0
\]</span> 也就是说,<span class="math inline">\(t_1,t_2\)</span>是同一个方程的两个根,根据韦达定理自然有<span class="math inline">\(t_1t_2=\frac{-(x^2+y^2)}{2px}=-1\)</span>,于是直接有<span class="math inline">\(x^2+y^2-2px=0\)</span>.</p>
<p>还没完,注意到<span class="math inline">\(O\)</span>一定是一个根,要去掉,所以答案就是<span class="math inline">\(x^2+y^2-2px=0(x\ne 0)\)</span>.</p>
<p><strong>Example3</strong></p>
<p>已知<span class="math inline">\(A,B,C\)</span>是抛物线<span class="math inline">\(y^2=2px(p&gt;0)\)</span>上的三个点,且<span class="math inline">\(BC\)</span>与<span class="math inline">\(x\)</span>轴垂直,直线<span class="math inline">\(AB\)</span>和<span class="math inline">\(AC\)</span>分别与抛物线的轴交于<span class="math inline">\(D,E\)</span>两点,求证:抛物线的顶点平分<span class="math inline">\(DE\)</span>.</p>
<p>设<span class="math inline">\(A(2pt_1^2,2pt_1),B(2pt_2^2,2pt_2),C(2pt_2^2,-2pt_2)\)</span>,注意到<span class="math inline">\(AB:y-2pt_1=\frac{1}{t_1+t_2}(x-2pt_1^2)\)</span>,<span class="math inline">\(AC:t-2pt_1=\frac{1}{t_1-t_2}(x-2pt_1^2)\)</span>.</p>
<p>可求得<span class="math inline">\(D(-2pt_1t_2,0),E(2pt_1t_2,0)\)</span>,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5>
<p>参考:https://zhuanlan.zhihu.com/p/591258689</p>
<h6><span id="定义">定义</span></h6>
<p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6>
<p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\)</span>,其蒙日圆方程为<span class="math inline">\(x^2+y^2=a^2+b^2\)</span>.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为<span class="math inline">\(\frac{x^2}{a^2}-\frac{y^2}{b^2}=1\)</span>,其蒙日圆方程为<span class="math inline">\(x^2+y^2=a^2-b^2\)</span>.</p>
<p>证明:其实注意到椭圆的证明中设<span class="math inline">\(b\)</span>是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线<span class="math inline">\(y^2=2px\)</span>,其蒙日圆方程为<span class="math inline">\(x=-\frac{p}{2}\)</span>.</p>
<p>有一说一,直线是半径无穷大的圆.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>范畴论初步</title>
    <url>/2025/02/23/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#基础集合论">基础集合论</a>
<ul>
<li><a href="#映射">映射</a></li>
<li><a href="#二元运算与二元关系">二元运算与二元关系</a>
<ul>
<li><a href="#保序映射">保序映射</a></li>
<li><a href="#dilworth定理">Dilworth定理</a></li>
<li><a href="#商集">商集</a></li>
</ul></li>
<li><a href="#zfc公理体系">ZFC公理体系</a>
<ul>
<li><a href="#外延公理">外延公理</a></li>
<li><a href="#配对公理">配对公理</a></li>
<li><a href="#分离公理模式">分离公理(模式)</a></li>
<li><a href="#并集公理">并集公理</a></li>
<li><a href="#幂集公理">幂集公理</a></li>
<li><a href="#无穷公理">无穷公理</a></li>
<li><a href="#替换公理模式">替换公理(模式)</a></li>
<li><a href="#正则公理">正则公理</a></li>
<li><a href="#选择公理">选择公理</a>
<ul>
<li><a href="#zorn引理">Zorn引理</a></li>
<li><a href="#良序定理">良序定理</a></li>
</ul></li>
</ul></li>
<li><a href="#集合的基数">集合的基数</a>
<ul>
<li><a href="#cantor-bernstein定理">Cantor-Bernstein定理</a></li>
<li><a href="#可数无穷与不可数无穷">可数无穷与不可数无穷</a></li>
</ul></li>
</ul></li>
<li><a href="#简单范畴论">简单范畴论</a>
<ul>
<li><a href="#范畴">范畴</a></li>
<li><a href="#函子">函子</a></li>
<li><a href="#范畴实例">范畴实例</a>
<ul>
<li><a href="#kleisli范畴">Kleisli范畴</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2>
<h3><span id="映射">映射</span></h3>
<p>设<span class="math inline">\(A,B\)</span>为两个集合,<span class="math inline">\(\varphi\)</span>称为从<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的一个<strong>映射</strong>,如果对于任意<span class="math inline">\(a\in A\)</span>,<span class="math inline">\(\exists b\in B,b=\varphi(a)\)</span>.此时<span class="math inline">\(b\)</span>称为<span class="math inline">\(a\)</span>在<span class="math inline">\(\varphi\)</span>下的像,<span class="math inline">\(a\)</span>称为<span class="math inline">\(b\)</span>在<span class="math inline">\(\varphi\)</span>下的原像或反像.一般地,这个定义可以拓展到<span class="math inline">\(S\subseteq A\)</span>,<span class="math inline">\(\varphi(S)=\{\varphi(a)\mid a\in
S\}\)</span>,定义<span class="math inline">\(\varphi^{-1}(T)=\{a|\varphi(a)\in T,a\in
S\}\)</span>.</p>
<p>如果<span class="math inline">\(\forall a_1,a_2\in A,a_1\ne
a_2,\varphi(a_1)\ne \varphi(a_2)\)</span>,称<span class="math inline">\(\varphi\)</span>是<strong>单射</strong>.</p>
<p>如果<span class="math inline">\(\forall b\in B,\exists a\in
A,\varphi(a)=b\)</span>.称<span class="math inline">\(\varphi\)</span>为<strong>满射</strong>.</p>
<p>如果<span class="math inline">\(\varphi\)</span>既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果<span class="math inline">\(A=B\)</span>,我们又称<span class="math inline">\(\varphi\)</span>为一个<strong>变换</strong>.</p>
<p>设<span class="math inline">\(f:A\rightarrow B,g:B\rightarrow
A\)</span>,那么:</p>
<ol type="1">
<li>如果<span class="math inline">\(g\circ f=id_A\)</span>,称<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的一个<strong>左逆</strong>,不难发现<span class="math inline">\(f\)</span>存在左逆当且仅当<span class="math inline">\(f\)</span>是单射.</li>
<li>如果<span class="math inline">\(f\circ g=id_B\)</span>,称<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的一个<strong>右逆</strong>,不难发现<span class="math inline">\(f\)</span>存在右逆当且仅当<span class="math inline">\(f\)</span>是满射.</li>
<li>如果<span class="math inline">\(g\)</span>既是<span class="math inline">\(f\)</span>的左逆又是<span class="math inline">\(f\)</span>的右逆,则称<span class="math inline">\(g\)</span>为<span class="math inline">\(f\)</span>的<strong>逆</strong>,不难发现<span class="math inline">\(f\)</span>存在逆当且仅当<span class="math inline">\(f\)</span>是双射,并且逆唯一.</li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3>
<p>集合<span class="math inline">\(A,B\)</span>的<strong>笛卡尔积</strong>或<strong>直积</strong>是指<span class="math inline">\(A\)</span>的元素与<span class="math inline">\(B\)</span>的元素构成的有序对的集合,即<span class="math inline">\(A\times B=\{(a,b)\mid a\in A,b\in
B\}\)</span>.可以推广到多元对.</p>
<p>集合<span class="math inline">\(A\)</span>上的一个<strong>二元运算</strong>是由<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(A\)</span>的一个映射.对于定义在<span class="math inline">\(U\)</span>上的一个二元运算,不妨用<span class="math inline">\(+\)</span>来表示,集合<span class="math inline">\(A,B\subseteq
U\)</span>的<strong>闵可夫斯基和</strong>定义为<span class="math inline">\(A+B=\{a+b\mid a\in A,b\in
B\}\)</span>.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合<span class="math inline">\(A\)</span>上的一个<strong>二元关系</strong><span class="math inline">\(R\)</span>定义为<span class="math inline">\(A\times
A\)</span>的一个子集(可以理解为满足二元关系的解集),如果<span class="math inline">\((a_1,a_2)\in R\)</span>,就称<span class="math inline">\(a_1,a_2\)</span>有关系<span class="math inline">\(R\)</span>,记作<span class="math inline">\(a_1Ra_2\)</span>,注意这里有序.</p>
<p>如果<span class="math inline">\(R\)</span>满足以下三个性质:</p>
<ol type="1">
<li>反身性:<span class="math inline">\(\forall a\in A,aRa\)</span>.</li>
<li>对称性:<span class="math inline">\(a_1Ra_2\Leftrightarrow
a_2Ra_1\)</span>.</li>
<li>传递性:<span class="math inline">\(a_1Ra_2,a_2Ra_3\Leftrightarrow
a_1Ra_3\)</span>.</li>
</ol>
<p>则称<span class="math inline">\(R\)</span>是一个<strong>等价关系</strong>,不难发现满足等价关系的元素构成了若干个集合,称作<strong>等价类</strong>.等价关系通常记作<span class="math inline">\(\sim\)</span>.</p>
<p>如果将等价关系的(2)改作:</p>
<ol start="2" type="1">
<li>反对称性:<span class="math inline">\(a_1Ra_2,a_2Ra_1\Leftrightarrow
a_1=a_2\)</span>.</li>
</ol>
<p>则称<span class="math inline">\(R\)</span>是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$$.</p>
<h4><span id="保序映射">保序映射</span></h4>
<p>对于映射<span class="math inline">\(f:A\rightarrow
B\)</span>,如果<span class="math inline">\(\forall a,a&#39;\in A,a\leq
a&#39;\Rightarrow f(a)\leq f(a&#39;)\)</span>,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4>
<p>对于偏序集<span class="math inline">\((A,R)\)</span>来说,定义:</p>
<ol type="1">
<li>链:<span class="math inline">\(A&#39;\subseteq A,\forall x,y\in
A&#39;,[xRy\lor yRx]=1\)</span>.</li>
<li>反链:<span class="math inline">\(A&#39;\subseteq A,\forall x,y\in
A&#39;,[xRy\lor yRx]=0\)</span>.</li>
<li>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,<span class="math inline">\(|A|\leq
3\)</span>显然成立.</p>
<p>当<span class="math inline">\(|A|&gt;3\)</span>时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为<span class="math inline">\(d\)</span>,下面证明其最小链覆盖也是<span class="math inline">\(d\)</span>.</p>
<p>考虑取一条尽可能长的链<span class="math inline">\(A&#39;\)</span>,设其中最大的为<span class="math inline">\(M\)</span>,最小的为<span class="math inline">\(m\)</span>(如果有多个就任取一个).</p>
<p>考虑<span class="math inline">\(T=A\setminus
A&#39;\)</span>,如果<span class="math inline">\(T\)</span>中的最长反链数小于<span class="math inline">\(d\)</span>,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链<span class="math inline">\(S\)</span>,使得<span class="math inline">\(S\cap
A&#39;=\empty\)</span>.考虑设<span class="math inline">\(A^{+}=\{x|x\in
A\land \exists s\in S,sRx\}\)</span>,<span class="math inline">\(A^{-}=\{x|x\in A\land \exists s\in
S,xRs\}\)</span>.不难发现<span class="math inline">\(m\)</span>一定不在<span class="math inline">\(|A^{+}|\)</span>中,不然取出的那条链<span class="math inline">\(A&#39;\)</span>可以更长.同理<span class="math inline">\(M\)</span>一定不在<span class="math inline">\(|A^{-}|\)</span>中,也即<span class="math inline">\(|A^+|,|A^-|&lt;|A|\)</span>.</p>
<p>我们又发现<span class="math inline">\(A^+\cup
A^-=A\)</span>,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,<span class="math inline">\(S\subseteq
A^{+}\cap A^{-}\)</span>.</p>
<p>由数学归纳,<span class="math inline">\(A^+\)</span>和<span class="math inline">\(A^-\)</span>中的最小链覆盖均为<span class="math inline">\(d\)</span>,并且一个以<span class="math inline">\(S\)</span>中元素开头,一个以<span class="math inline">\(S\)</span>中元素结尾,我们把它俩拼起来就是一个大小为<span class="math inline">\(d\)</span>的新的大小为<span class="math inline">\(d\)</span>的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4>
<p>考虑定义一种等价关系<span class="math inline">\(\sim\)</span>,我们可以在此基础上定义商集<span class="math inline">\(A/\sim=\{[a]|a\in A\}\)</span>,其中<span class="math inline">\([a]\)</span>是<span class="math inline">\(a\)</span>所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过<span class="math inline">\(\N\)</span>来定义<span class="math inline">\(\Z\)</span>.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系<span class="math inline">\(\sim\)</span>,<span class="math inline">\((n,m)\sim(n&#39;,m&#39;)\)</span>当且仅当<span class="math inline">\(n+m&#39;=m+n&#39;\)</span>.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将<span class="math inline">\(\N/\sim\)</span>定义为整数,更确切地,对于任意一组<span class="math inline">\((n,m)\)</span>其代表的就是<span class="math inline">\(n-m\)</span>这个整数.</p>
<p>容易定义加法:<span class="math inline">\((n,m)+(n&#39;,m&#39;)=(n+n&#39;,m+m&#39;)\)</span>,乘法<span class="math inline">\((n,m)\times
(n&#39;,m&#39;)=(mm&#39;+nn&#39;,mn&#39;+m&#39;n)\)</span>.也可以定义大小关系<span class="math inline">\((n,m)\leq (n&#39;,m&#39;)\Leftrightarrow
n+m&#39;\leq m+n&#39;\)</span>.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义<span class="math inline">\(-(n,m)=(m,n)\)</span>即可,容易验证二者之和处于<span class="math inline">\((0,0)\)</span>这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用<span class="math inline">\(\Z\)</span>构造<span class="math inline">\(\mathbb Q\)</span>,构造二元组<span class="math inline">\(\Z\times \N_+\)</span>,定义<span class="math inline">\((r,s)\sim (r&#39;,s&#39;)\Leftrightarrow
rs&#39;=r&#39;s\)</span>,容易验证其满足等价关系的性质.实际上其对应的就是<span class="math inline">\(\frac{r}{s}\)</span>这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3>
<h4><span id="外延公理">外延公理</span></h4>
<p><span class="math inline">\(A=B\Leftrightarrow (A\subset B)\and
(B\subset A)\)</span>.</p>
<h4><span id="配对公理">配对公理</span></h4>
<p>对于任意元素<span class="math inline">\(a,b\)</span>,存在集合<span class="math inline">\(\{a,b\}\)</span>.特别地,当<span class="math inline">\(a=b\)</span>的时候存在集合<span class="math inline">\(\{a\}\)</span>.</p>
<p>值得一提的是可以将数对<span class="math inline">\((a,b)\)</span>定义为<span class="math inline">\(\{\{a\},\{a,b\}\}\)</span>,下面的幂集公理说明了数对属于<span class="math inline">\(2^{2^{A\cup B}},a\in A,b\in B\)</span>.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4>
<p>对于一个集合<span class="math inline">\(A\)</span>,和一个性质<span class="math inline">\(P\)</span>,若<span class="math inline">\(\alpha\)</span>满足性质<span class="math inline">\(P\)</span>则称<span class="math inline">\(P(\alpha)\)</span>.那么存在集合: <span class="math display">\[
\{x|x\in A\and P(x)\}
\]</span>
注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质<span class="math inline">\(P\)</span>都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4>
<p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4>
<p>一个集合的所有子集构成一个新的集合(可以记作<span class="math inline">\(2^A\)</span>).</p>
<h4><span id="无穷公理">无穷公理</span></h4>
<p>称满足以下性质的集合为归纳集:</p>
<ol type="1">
<li><span class="math inline">\(\empty \in A\)</span>.</li>
<li>若<span class="math inline">\(\alpha \in A\)</span>,则<span class="math inline">\(\{\alpha \}\cup \alpha \in A\)</span>.</li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4>
<p>对于集合<span class="math inline">\(A\)</span>和一种定义在集合<span class="math inline">\(A\)</span>上的映射<span class="math inline">\(F\)</span>,存在集合<span class="math inline">\(A&#39;\)</span>使得<span class="math inline">\(x\in A&#39;\Leftrightarrow x=F(a),a\in
A\)</span>.</p>
<p>用替换公理可以证明映射也是一种集合,并且从<span class="math inline">\(A\rightarrow
B\)</span>的所有映射可以构成集合,可以记作<span class="math inline">\(B^A\)</span>.</p>
<h4><span id="正则公理">正则公理</span></h4>
<p>对任何非空集合<span class="math inline">\(A\)</span>,存在<span class="math inline">\(a\in A\)</span>使得<span class="math inline">\(\forall a&#39;\in A\)</span>,<span class="math inline">\(a&#39;\notin a\)</span>,也就是<span class="math inline">\(a\cap A=\empty\)</span>.</p>
<h4><span id="选择公理">选择公理</span></h4>
<p>说对于任何一族非空集<span class="math inline">\(A\)</span>,总能从其中的每个集合<span class="math inline">\(a\)</span>选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5>
<p>如果<span class="math inline">\(X\)</span>上的一个偏序关系<span class="math inline">\(\leq\)</span>,满足其每条链<span class="math inline">\(A\)</span>都存在上界(<span class="math inline">\(\exists x\in X,\forall a\in A,x\geq
a\)</span>),那么<span class="math inline">\(X\)</span>存在极大元<span class="math inline">\((\exists x\in X,\forall a\in X,a\geq x\Rightarrow
a=x)\)</span>.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系<span class="math inline">\((A&#39;&#39;,g&#39;&#39;)\leq
(A&#39;,g&#39;)\)</span>当且仅当<span class="math inline">\(A&#39;&#39;\subseteq A&#39;\)</span>并且<span class="math inline">\(\forall x\in
A&#39;&#39;,g&#39;&#39;(x)=g&#39;(x)\)</span>.这样拿出来的极大元就是我们需要的<span class="math inline">\(A\rightarrow g(A)\)</span>.</p>
<h5><span id="良序定理">良序定理</span></h5>
<p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对<span class="math inline">\((S,R)\)</span>组成的集合,其中满足<span class="math inline">\(S\)</span>对于偏序关系<span class="math inline">\(R\)</span>来说是良序的,我们定义两个二元对<span class="math inline">\(a,b\)</span>满足<span class="math inline">\(a\leq
b\)</span>当且仅当它们的<span class="math inline">\(R\)</span>相等并且<span class="math inline">\(S_a\subseteq
S_b\)</span>.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)<span class="math inline">\((S,R)\)</span>,注意到如果<span class="math inline">\(S\)</span>是全集则证毕,如果不是,则取一个全集中不在<span class="math inline">\(S\)</span>的元素<span class="math inline">\(x\)</span>接到<span class="math inline">\(S\)</span>的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3>
<p>如果存在单射<span class="math inline">\(\varphi:A\rightarrow
B\)</span>,则称<span class="math inline">\(|A|\leq
|B|\)</span>.如果存在双射,则称<span class="math inline">\(|A|=|B|\)</span>.</p>
<p>如果使用选择公理的话,可以说明如果存在满射<span class="math inline">\(\varphi:A\rightarrow B\)</span>,则称<span class="math inline">\(|A|\geq |B|\)</span>.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有<span class="math inline">\(A,B\)</span>两个集合,接下来我们证明一定存在一个从<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的映射,且其要么为单射要么为满射.</p>
<p>我们记<span class="math inline">\(X\)</span>为所有<span class="math inline">\(A\)</span>的子集到<span class="math inline">\(B\)</span>的单射组成的集合,并且我们定义这样一种偏序关系:若<span class="math inline">\(f:A_f\rightarrow B,g:A_g\rightarrow B,A_f\subseteq
A_g,\forall a\in A_f,f(a)=g(a)\)</span>.</p>
<p>这样的话,我们不妨取出<span class="math inline">\(X\)</span>的一个全序的子集<span class="math inline">\(I\)</span>,显然其存在上界.</p>
<p>根据Zorn引理,<span class="math inline">\(X\)</span>存在极大元<span class="math inline">\(g:A_g\rightarrow B\)</span>,此时我们开始讨论:</p>
<p>如果<span class="math inline">\(A_g=A\)</span>,那么找到了一个单射<span class="math inline">\(g:A\rightarrow B\)</span>.</p>
<p>反之,如果<span class="math inline">\(A_g\subsetneq
A\)</span>,考虑如果<span class="math inline">\(g(A_g)=B\)</span>,也就是找到了一个满射;反之,考虑取<span class="math inline">\(a&#39;\in A\setminus A_g,b&#39;\in B\setminus
g(A_g)\)</span>,在<span class="math inline">\(g\)</span>的基础上加上映射<span class="math inline">\(a&#39;\mapsto b&#39;\)</span>,这是一个比<span class="math inline">\(g\)</span>还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4>
<p>如果<span class="math inline">\(|A|\leq |B|\and |B|\leq
|A|\)</span>,则<span class="math inline">\(|A|=|B|\)</span>.</p>
<p>不妨设<span class="math inline">\(f:A\rightarrow B,g:B\rightarrow
A\)</span>我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用<span class="math inline">\(f,f^{-1}\)</span>来构造双射,只有一种除外:那就是以一个<span class="math inline">\(B\)</span>中节点开始不断延伸的无限的,我们在这里使用<span class="math inline">\(g,g^{-1}\)</span>来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取<span class="math inline">\(C_0=B\setminus f(A)\)</span>,<span class="math inline">\(C_n=f(g(C_{n-1}))\)</span>,那么对于<span class="math inline">\(C=\cup_{n\geq 0}C_n\)</span>,使用<span class="math inline">\(g,g^{-1}\)</span>构造双射,剩下的使用<span class="math inline">\(f,f^{-1}\)</span>构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4>
<p>我们称集合<span class="math inline">\(A\)</span>是<strong>可数</strong>的,当且仅当<span class="math inline">\(|A|=|\N|\)</span>.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是<span class="math inline">\(0\)</span>)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>显然都是代数数.</p>
<p>我们接下来看两个代数数<span class="math inline">\(x,y\)</span>.考虑如何构造<span class="math inline">\(x+y\)</span>作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程: <span class="math display">\[
X=\sum_{k=0}^na_kx^k=0\\
Y=\sum_{k=0}^mb_ky^k=0
\]</span></p>
<p>对于加法,考虑:<span class="math inline">\((x+y)^0,(x+y)^1,\cdots\)</span>,这些东西,先把它们对<span class="math inline">\(X\)</span>取膜再对<span class="math inline">\(Y\)</span>取膜,得到的一定是<span class="math inline">\(nm\)</span>维的,只需要取<span class="math inline">\(nm+1\)</span>个就会出现线性相关.乘法同理考虑<span class="math inline">\((xy)^0,(xy)^1,\cdots\)</span>即可.</p>
<p>值得一提的是,<span class="math inline">\(|\R|=2^{|\N|}\)</span>.这个是怎么构造的呢?只需要证明<span class="math inline">\([0,1]\)</span>上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果<span class="math inline">\(k\)</span>在取出的自然数子集中,那么小数点后第<span class="math inline">\(k+1\)</span>位为<span class="math inline">\(1\)</span>否则为<span class="math inline">\(0\)</span>,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是<span class="math inline">\(0.1=0.0111\cdots\)</span>,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明<span class="math inline">\(|\R|\leq 2^{|\N|}\)</span>并且<span class="math inline">\(|\R|\geq 2^{|\N|}\)</span>,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2>
<h3><span id="范畴">范畴</span></h3>
<p>一个<strong>范畴</strong><span class="math inline">\(\mathcal
C\)</span>应当包含以下:</p>
<ol type="1">
<li>一个类<span class="math inline">\(\rm{Ob}(\mathcal
C)\)</span>,其元素称作<span class="math inline">\(\mathcal
C\)</span>的<strong>对象</strong>.</li>
<li>对于<span class="math inline">\(X,Y\in \rm{Ob}(\mathcal
C)\)</span>指定一个集合<span class="math inline">\(\text{Hom}_{\mathcal
C}(X,Y)\)</span>,称作<span class="math inline">\(\mathcal
C\)</span>中从<span class="math inline">\(X\)</span>到<span class="math inline">\(Y\)</span>的<strong>态射</strong>.</li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol type="1">
<li>对于<span class="math inline">\(X\in \text{Ob}(\mathcal
C)\)</span>存在其到自身的<strong>恒等态射</strong><span class="math inline">\(\text{id}_X\in \text{Hom}_{\mathcal
C}(X,X)\)</span>.</li>
<li>态射间可以进行合成,换言之存在<strong>合成映射</strong><span class="math inline">\(\circ:\text{Hom}_{\mathcal C}(Y,Z)\times
\text{Hom}_{\mathcal C}(X,Y)\to \text{Hom}_{\mathcal
C}(X,Z),(g,f)\mapsto g\circ f\)</span>.</li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol type="1">
<li><strong>结合律</strong>:对于<span class="math inline">\(\mathcal
C\)</span>中的态射<span class="math inline">\(h,g,f\)</span>,如果合成有意义,那么<span class="math inline">\(h(gf)=(hg)f\)</span>.</li>
<li><strong>单位元</strong>:对于<span class="math inline">\(f\in
\text{Hom}_{\mathcal C}(X,Y)\)</span>,<span class="math inline">\(f\circ
\text{id}_X=f=\text{id}_Y\circ f\)</span>.</li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有<span class="math inline">\(\text{id}_X=\text{id}_X\text{id&#39;}_X=\text{id&#39;}_X\)</span>.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:
<span class="math display">\[
\xymatrix{
R\ar[r]^u\ar[d]_x&amp;S\ar[d]^v\\
T\ar[r]_y&amp;U
}
\]</span> 这意味着<span class="math inline">\(yx=vu\)</span>.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol type="1">
<li>如果对于<span class="math inline">\(f\in
\text{Hom}(X,Y)\)</span>,<span class="math inline">\(\exists g\in
\text{Hom}(Y,X)\)</span>使得<span class="math inline">\(gf=\text{id}_X\)</span>,那么称<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的一个<strong>左逆</strong>,称<span class="math inline">\(f\)</span>是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</li>
<li>如果<span class="math inline">\(f\)</span>左右均可逆,易见左右逆相等,记作<span class="math inline">\(f^{-1}\)</span>,易见<span class="math inline">\(f^{-1}\)</span>可逆而且<span class="math inline">\((f^{-1})^{-1}=f\)</span>.此时称<span class="math inline">\(f\)</span>是<strong>同构</strong>的.</li>
</ol>
<p>同构还有以下性质:</p>
<ol type="1">
<li><span class="math inline">\((\text{id}_X)^{-1}=\text{id}_X\)</span>.</li>
<li>如果<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>均为同构并且合成有意义,那么<span class="math inline">\(gf\)</span>是同构并且<span class="math inline">\((gf)^{-1}=f^{-1}g^{-1}\)</span>.</li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol type="1">
<li>自同态幺半群:<span class="math inline">\(\text{End}_{\mathcal
C}(X)=\text{Hom}_{\mathcal C}(X,X)\)</span>.</li>
<li>自同构群:<span class="math inline">\(\text{Aut}_{\mathcal
C}(X)=(\text{End}_{\mathcal C}(X))^\times\)</span>.</li>
</ol>
<p>如此起名的原因是由抽象代数知识见到<span class="math inline">\(\text{End}\)</span>对二元运算<span class="math inline">\(\circ\)</span>构成幺半群,<span class="math inline">\(\text{Aut}\)</span>则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称<span class="math inline">\(\mathcal C&#39;\)</span>是<span class="math inline">\(\mathcal C\)</span>的子范畴当且仅当:</p>
<ol type="1">
<li><span class="math inline">\(\text{Ob}(\mathcal C&#39;)\subseteq
\text{Ob}(\mathcal C)\)</span>.</li>
<li><span class="math inline">\(\forall X,Y\in\text{Ob}(\mathcal
C&#39;)\)</span>都有<span class="math inline">\(\text{Hom}_{\mathcal
C&#39;}(X,Y)\subseteq \text{Hom}_{\mathcal C}(X,Y)\)</span>.</li>
<li><span class="math inline">\(\forall X\in \text{Ob}(\mathcal
C&#39;)\)</span>,<span class="math inline">\(\text{id}_X=\text{id}_X&#39;\)</span>.</li>
<li>态射在<span class="math inline">\(\mathcal
C&#39;\)</span>中的合成运算应从<span class="math inline">\(\mathcal
C\)</span>中继承而来.</li>
</ol>
<p>特别地,如果<span class="math inline">\(\forall X,Y\in
\text{Ob}(\mathcal C&#39;),\text{Hom}(X,Y)_{\mathcal
C&#39;}=\text{Hom}_{\mathcal C}(X,Y)\)</span>,则称<span class="math inline">\(\mathcal C&#39;\)</span>是<span class="math inline">\(\mathcal C\)</span>的一个全子范畴.</p>
<h3><span id="函子">函子</span></h3>
<p>我们定义从<span class="math inline">\(\mathcal C&#39;\)</span>到<span class="math inline">\(\mathcal C\)</span>的<strong>函子</strong><span class="math inline">\(F\)</span>需要有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(\forall X\in \text{Ob}(\mathcal
C&#39;)\)</span>,指定一个<span class="math inline">\(\mathcal
C\)</span>中的对象<span class="math inline">\(FX\)</span>.或记作<span class="math inline">\(F:\text{Ob}(\mathcal C&#39;)\to\text{Ob}(\mathcal
C)\)</span>.</li>
<li><span class="math inline">\(\forall X,Y\in \text{Ob}(\mathcal
C&#39;)\)</span>,对于态射<span class="math inline">\(f:X\to
Y\)</span>指定一个<span class="math inline">\(\mathcal
C\)</span>中的对象<span class="math inline">\(Ff\)</span>.或记作<span class="math inline">\(F:\text{Hom}_\mathcal
C&#39;(X,Y)\to\text{Hom}_\mathcal C(FX,FY)\)</span>.</li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol type="1">
<li><span class="math inline">\(\forall g,f\in \text{Hom}_{\mathcal
C&#39;}\)</span>,它们的合成有意义,则<span class="math inline">\(F(gf)=F(g)F(f)\)</span>.</li>
<li><span class="math inline">\(\forall X\in \text{Ob}(\mathcal
C&#39;)\)</span>,<span class="math inline">\(F(\text{id}_X)=\text{id}_{FX}\)</span>.</li>
</ol>
<p>我们一般也将上述函子记作<span class="math inline">\(F:\mathcal
C&#39;\to \mathcal
C\)</span>.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然<span class="math inline">\(F\)</span>可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol type="1">
<li>如果<span class="math inline">\(\forall T\in \text{Ob}(\mathcal
C),\exists X\in \text{Ob}(\mathcal C&#39;)\)</span>使得<span class="math inline">\(T\cong FX\)</span>,则称<span class="math inline">\(F\)</span>是<strong>本质满</strong>的.</li>
<li>如果<span class="math inline">\(\forall X,Y\in \text{Ob}(\mathcal
C&#39;)\)</span>,<span class="math inline">\(F:\text{Hom}_{\mathcal
C&#39;}(X,Y)\to \text{Hom}_{\mathcal
C}(FX,FY)\)</span>均为单射,则称<span class="math inline">\(F\)</span>是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">	fmap :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">	(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">	(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓<span class="math inline">\(\text{Hom}\)</span>函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴<span class="math inline">\(\mathcal
C\)</span>以及其对象<span class="math inline">\(X\)</span>,我们定义函子<span class="math inline">\(\text{Hom}_{\mathcal C}(X,\sdot):\mathcal C\to
Set\)</span>,它映对象<span class="math inline">\(Y\)</span>为集合<span class="math inline">\(\text{Hom}_{\mathcal C}(X,Y)\)</span>,映态射<span class="math inline">\(f:Y\to Z\)</span>为映射<span class="math inline">\(\text{Hom}_{\mathcal
C}(X,\sdot)f:\text{Hom}_{\mathcal C}(X,Y)\to \text{Hom}_{\mathcal
C}(X,Z),h\mapsto f\circ h\)</span>.</p>
<p>同理可以定义函子<span class="math inline">\(\text{Hom}_{\mathcal
C}(\sdot,X)\)</span>.</p>
<p>对于函子<span class="math inline">\(\text{Hom}_{\mathcal
C}(X,\sdot)\)</span>,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line">  <span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line">  fmap fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line">  <span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line">  <span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line">  pure tb = \ta -&gt; tb</span><br><span class="line">  (&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  <span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">  (&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3>
<h4><span id="kleisli范畴">Kleisli范畴</span></h4>
<p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol type="1">
<li>加上修饰.</li>
<li>合并修饰.</li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">  fmap        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  (&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">  (&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  return = pure</span><br><span class="line">  join :: m(m a)-&gt; m a</span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  ma &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  m &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>简单乐理</title>
    <url>/2025/04/01/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#泛音列">泛音列</a>
<ul>
<li><a href="#拍音理论">拍音理论</a></li>
<li><a href="#mersenne定律">Mersenne定律</a></li>
<li><a href="#管乐器">管乐器</a></li>
<li><a href="#泛音列重合理论">泛音列重合理论</a></li>
</ul></li>
<li><a href="#律制">律制</a>
<ul>
<li><a href="#音程">音程</a></li>
<li><a href="#五度相生律">五度相生律</a></li>
<li><a href="#纯律">纯律</a></li>
<li><a href="#十二平均律">十二平均律</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="前言">前言</span></h3>
<p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3>
<h4><span id="拍音理论">拍音理论</span></h4>
<p>假设两个正弦单音的频率分别是<span class="math inline">\(\omega,\omega+\delta\)</span>,那么它们叠加后是:
<span class="math display">\[
\sin(2\pi(\omega+\delta)t)+\sin(2\pi\omega t)\\
=2\sin\left(2\pi(\omega+\frac{\delta}{2})t\right)\cos(\pi\delta t)
\]</span> 注意到这个声音受到<span class="math inline">\(\cos(\pi\delta
t)\)</span>的控制.因此会以<span class="math inline">\(\frac{\delta}{2}\)</span>的频率振动,由于<span class="math inline">\(\delta\)</span>应该远小于<span class="math inline">\(\omega\)</span>,这里就会产生<span class="math inline">\(\delta=|\omega_1-\omega_2|\)</span>个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4>
<p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol type="1">
<li>弦长<span class="math inline">\(L\)</span>.</li>
<li>张力<span class="math inline">\(T\)</span>.</li>
<li>线密度<span class="math inline">\(\rho\)</span>.</li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,最终得到的会是一个无穷级数,这个无穷级数的每一项都会以正弦规律振动,其中第<span class="math inline">\(n\)</span>项的频率满足: <span class="math display">\[
f_n=\frac{n}{2L}\sqrt{\frac{T}{\rho}}
\]</span> 其中我们将<span class="math inline">\(f_1\)</span>称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中<span class="math inline">\(f_n,n\geq 2\)</span>对应的是第<span class="math inline">\(n-1\)</span>泛音.</p>
<p>特别地,如果我们干脆记<span class="math inline">\(f=f_1\)</span>,上述结果告诉我们弦的振动产生的一列频率是:
<span class="math display">\[
f,2f,3f,\cdots
\]</span> 这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的<span class="math inline">\(n\)</span>,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0"></p>
<p>其中标注的点在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的<span class="math inline">\(f_{2k+1}\)</span>,泛音列中只剩下<span class="math inline">\(2f,4f,\cdots\)</span>.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按<span class="math inline">\(\frac{1}{3}\)</span>处呢?那泛音列中就会只剩下<span class="math inline">\(3f,6f,9f,\cdots\)</span>,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是<span class="math inline">\(f,3f,5f,\cdots\)</span>.</p>
<h4><span id="管乐器">管乐器</span></h4>
<p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列: <span class="math display">\[
f,2f,3f,4f,\cdots
\]</span> 闭管的泛音列: <span class="math display">\[
f,3f,5f,7f
\]</span> 另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4>
<p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:
<span class="math display">\[
f,2f,3f,4f,\cdots\\
2f,4f,6f,8f,\cdots
\]</span> 或是: <span class="math display">\[
f,2f,3f,4f,\cdots\\
\frac{3}{2}f,3f,\frac{9}{2}f,6f,\cdots
\]</span> 这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3>
<p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是<span class="math inline">\(L_p=20\log_{10}(\frac{p}{p_0})\)</span>,其中<span class="math inline">\(p_0=20\mu Pa\)</span>.</p>
<h4><span id="音程">音程</span></h4>
<p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<table>
<thead>
<tr>
<th>度数</th>
<th>半音数</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>一</td>
<td>0</td>
<td>纯一度</td>
</tr>
<tr>
<td>二</td>
<td>1</td>
<td>小二度</td>
</tr>
<tr>
<td>二</td>
<td>2</td>
<td>大二度</td>
</tr>
<tr>
<td>三</td>
<td>3</td>
<td>小三度</td>
</tr>
<tr>
<td>三</td>
<td>4</td>
<td>大三度</td>
</tr>
<tr>
<td>四</td>
<td>5</td>
<td>纯四度</td>
</tr>
<tr>
<td>四</td>
<td>6</td>
<td>增四度</td>
</tr>
<tr>
<td>五</td>
<td>6</td>
<td>减五度</td>
</tr>
<tr>
<td>五</td>
<td>7</td>
<td>纯五度</td>
</tr>
<tr>
<td>六</td>
<td>8</td>
<td>小六度</td>
</tr>
<tr>
<td>六</td>
<td>9</td>
<td>大六度</td>
</tr>
<tr>
<td>七</td>
<td>10</td>
<td>小七度</td>
</tr>
<tr>
<td>七</td>
<td>11</td>
<td>大七度</td>
</tr>
<tr>
<td>八</td>
<td>12</td>
<td>纯八度</td>
</tr>
</tbody>
</table>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<table>
<thead>
<tr>
<th>音程</th>
<th>频率比</th>
</tr>
</thead>
<tbody>
<tr>
<td>纯八度</td>
<td><span class="math inline">\(2:1\)</span></td>
</tr>
<tr>
<td>纯五度</td>
<td><span class="math inline">\(3:2\)</span></td>
</tr>
<tr>
<td>纯四度</td>
<td><span class="math inline">\(4:3\)</span></td>
</tr>
<tr>
<td>大三度</td>
<td><span class="math inline">\(5:4\)</span></td>
</tr>
<tr>
<td>小三度</td>
<td><span class="math inline">\(6:5\)</span></td>
</tr>
</tbody>
</table>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4>
<p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定<span class="math inline">\(C\)</span>的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为<span class="math inline">\(1\)</span>,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求<span class="math inline">\(\{7k\}\pmod{12}\)</span>这个数列对吧,简单数论知识告诉我们它必然能遍历<span class="math inline">\(12\)</span>种情况,具体而言: <span class="math display">\[
\begin{aligned}
C\to &amp;&amp; G\to &amp;&amp;D\to &amp;&amp;A\to &amp;&amp;E\to
&amp;&amp;B\to\\
1\to&amp;&amp;\frac{3}{2}\to&amp;&amp;\frac{3^2}{2^3}\to&amp;&amp;\frac{3^3}{2^4}\to&amp;&amp;\frac{3^4}{2^6}\to&amp;&amp;\frac{3^5}{2^7}\to\\
\\
\\
\#F\to &amp;&amp;\#C\to &amp;&amp;\#G\to &amp;&amp;\#D\to
&amp;&amp;\#A\to &amp;&amp;\#E\\
\frac{3^6}{2^9}\to&amp;&amp;\frac{3^7}{2^{11}}\to&amp;&amp;\frac{3^8}{2^{12}}\to&amp;&amp;\frac{3^9}{2^{14}}\to&amp;&amp;\frac{3^{10}}{2^{15}}\to&amp;&amp;\frac{3^{11}}{2^{17}}\\
\end{aligned}
\]</span>
我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度<span class="math inline">\(CE\)</span>的比是<span class="math inline">\(\frac{81}{64}&gt;\frac{80}{64}=\frac{5}{4}\)</span>.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的<span class="math inline">\(\#E\ne F\)</span>,你对着这个<span class="math inline">\(\#E\)</span>往上再升一个音得到的理应是<span class="math inline">\(C&#39;=\frac{3^{12}}{2^{18}}&gt;2\)</span>,具体来说<span class="math inline">\(\frac{3^{12}}{2^{19}}\approx
1.013643\)</span>,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于<span class="math inline">\(1\)</span>的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升<span class="math inline">\(12\)</span>个纯五度,再下降<span class="math inline">\(7\)</span>个纯八度理应回到原点,可是: <span class="math display">\[
(\frac{3}{2})^{12}\times (\frac{1}{2})^7&gt;1
\]</span> 这下这下了.</p>
<h4><span id="纯律">纯律</span></h4>
<p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定<span class="math inline">\(C\)</span>的频率为<span class="math inline">\(1\)</span>.接下来用正三和弦(一个大三度和一个小三度)<span class="math inline">\(C-E-G\)</span>,<span class="math inline">\(F-A-C&#39;\)</span>,<span class="math inline">\(G-B-D&#39;\)</span>的比例是<span class="math inline">\(4:5:6\)</span>确定剩下的: <span class="math display">\[
\begin{aligned}
C&amp;&amp;D&amp;&amp;E&amp;&amp;F&amp;&amp;G&amp;&amp;A&amp;&amp;B&amp;&amp;C&#39;&amp;&amp;D&#39;\\
1&amp;&amp;\frac{9}{8}&amp;&amp;\frac{5}{4}&amp;&amp;\frac{4}{3}&amp;&amp;\frac{3}{2}&amp;&amp;\frac{5}{3}&amp;&amp;\frac{15}{8}&amp;&amp;2&amp;&amp;\frac{9}{4}
\end{aligned}
\]</span> 所以现在大三度和小三度都准了.但问题又来了:</p>
<ol type="1">
<li>五度音程<span class="math inline">\(D-A\)</span>不协和,比例为<span class="math inline">\(\frac{80}{54}&lt;\frac{81}{54}=\frac{3}{2}\)</span>.这直接导致了转调会出错.</li>
<li>有两种不同的大二度:音程<span class="math inline">\(C-D,F-G,A-B\)</span>的比例是<span class="math inline">\(\frac{9}{8}\)</span>而音程<span class="math inline">\(D-E,G-A\)</span>的比例为<span class="math inline">\(\frac{10}{9}\)</span>.</li>
<li><strong>谐调音差</strong>:从<span class="math inline">\(C\)</span>出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:<span class="math inline">\((\frac{3}{2})^4\times (\frac{1}{2})^2\times
\frac{4}{5}=\frac{81}{80}=1.0125&gt;1\)</span>.</li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4>
<p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用<span class="math inline">\(\sqrt[12]{2}\)</span>来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是<span class="math inline">\(f_1,f_2\)</span>,则它们的音分数定义为<span class="math inline">\(1200\log_2(\frac{f_2}{f_1})\)</span>,容易见到十二平均律拿到的一个半音恰好是<span class="math inline">\(100\)</span>音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#二维计算几何">二维计算几何</a>
<ul>
<li><a href="#基本函数">基本函数</a>
<ul>
<li><a href="#eps">eps</a></li>
<li><a href="#sign">sign</a></li>
<li><a href="#myabs">myabs</a></li>
<li><a href="#mysqr">mysqr</a></li>
<li><a href="#pointvector">Point/Vector</a></li>
<li><a href="#向量内积">向量内积</a></li>
<li><a href="#向量叉积">向量叉积</a></li>
<li><a href="#向量旋转">向量旋转</a></li>
<li><a href="#line">Line</a></li>
<li><a href="#判断线段相交">判断线段相交</a></li>
<li><a href="#求直线交点">求直线交点</a></li>
<li><a href="#点到线的最短距离">点到线的最短距离</a></li>
<li><a href="#凸多边形面积">凸多边形面积</a></li>
</ul></li>
<li><a href="#基本算法">基本算法</a>
<ul>
<li><a href="#排序算法">排序算法</a>
<ul>
<li><a href="#极角排序">极角排序</a></li>
<li><a href="#水平序排序">水平序排序</a></li>
</ul></li>
<li><a href="#二维凸包">二维凸包</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#实现">实现</a></li>
</ul></li>
<li><a href="#旋转卡壳">旋转卡壳</a>
<ul>
<li><a href="#定义-1">定义</a></li>
<li><a href="#实现-1">实现</a></li>
</ul></li>
<li><a href="#闵可夫斯基和">闵可夫斯基和</a>
<ul>
<li><a href="#定义-2">定义</a></li>
<li><a href="#实现-2">实现</a></li>
</ul></li>
<li><a href="#半平面交">半平面交</a>
<ul>
<li><a href="#定义-3">定义</a></li>
<li><a href="#实现-3">实现</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#三维计算几何">三维计算几何</a>
<ul>
<li><a href="#基本概念">基本概念</a>
<ul>
<li><a href="#直线">直线</a></li>
<li><a href="#平面">平面</a></li>
<li><a href="#夹角">夹角</a>
<ul>
<li><a href="#两直线夹角">两直线夹角.</a></li>
<li><a href="#直线与平面的夹角">直线与平面的夹角</a></li>
</ul></li>
<li><a href="#交点">交点</a></li>
</ul></li>
<li><a href="#基本定理">基本定理</a>
<ul>
<li><a href="#三余弦定理最小角定理">三余弦定理(最小角定理)</a></li>
<li><a href="#三正弦定理最大角定理">三正弦定理(最大角定理)</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2>
<p>参考:https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3>
<h4><span id="eps">eps</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">        x=X;y=Y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec a\sdot \vec b=|\vec a||\vec
b|\cos \theta=x_ax_b+y_ay_b\)</span>.也就等于<span class="math inline">\(\vec a\)</span>在<span class="math inline">\(b\)</span>上的投影与<span class="math inline">\(\vec b\)</span>的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol type="1">
<li>如果<span class="math inline">\(\vec a\sdot \vec
b=0\)</span>,则说明<span class="math inline">\(\vec a\bot \vec
b\)</span>.</li>
<li>如果<span class="math inline">\(\vec a\sdot \vec
b&gt;0\)</span>,则说明<span class="math inline">\(\vec a\)</span>和<span class="math inline">\(\vec b\)</span>正方向的夹角小于<span class="math inline">\(90\degree\)</span>.</li>
<li>如果<span class="math inline">\(\vec a\sdot \vec
b&lt;0\)</span>,则说明<span class="math inline">\(\vec a\)</span>和<span class="math inline">\(\vec b\)</span>正方向的夹角大于<span class="math inline">\(90\degree\)</span>.</li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec a\times\vec
b=x_ay_b-y_ax_b\)</span>.也就等于<span class="math inline">\(\vec a,\vec
b\)</span>两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol type="1">
<li>如果<span class="math inline">\(\vec a\times \vec
b=0\)</span>,说明二者共线.</li>
<li>如果<span class="math inline">\(\vec a\times \vec
b&lt;0\)</span>,说明从<span class="math inline">\(\vec a\)</span>到<span class="math inline">\(\vec b\)</span>的方向是顺时针.</li>
<li>如果<span class="math inline">\(\vec a\times \vec
b&gt;0\)</span>,说明从<span class="math inline">\(\vec a\)</span>到<span class="math inline">\(\vec b\)</span>的方向是逆时针.</li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵<span class="math inline">\(\begin{bmatrix}\cos \theta&amp;-\sin \theta\\\sin
\theta &amp;\cos \theta\end{bmatrix}\)</span>.</p>
<h4><span id="line">Line</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">    Point a,b;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">           (<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">           (<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">           (<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">           (<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line">    <span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line">    <span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下<span class="math inline">\(x_{L_1},x_{L_2},y_{L_1},y_{L_2}\)</span>围成的四边形,计算面积后用等高不等底计算.注意<span class="math inline">\(ls\)</span>和<span class="math inline">\(rs\)</span>所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4>
<p>利用叉乘,任取平面上一点<span class="math inline">\(O\)</span>,则<span class="math inline">\(S=\frac1 2\sum_{i=1}^n\overrightarrow {OP_i}\times
\overrightarrow{OP_{i+1}}\)</span>.证明的话考虑分<span class="math inline">\(O\)</span>在内部和<span class="math inline">\(O\)</span>在外部两种情况分类讨论.注意此时的<span class="math inline">\(P\)</span>必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为<span class="math inline">\(a\)</span>,它的边上(包括顶点)的整点数为<span class="math inline">\(b\)</span>,则它的面积<span class="math inline">\(S=a+\frac{b}{2}-1\)</span>.</p>
<h3><span id="基本算法">基本算法</span></h3>
<h4><span id="排序算法">排序算法</span></h4>
<h5><span id="极角排序">极角排序</span></h5>
<p>定义原点<span class="math inline">\(O\)</span>并建立坐标系,所有点按照和<span class="math inline">\(O\)</span>所连直线与<span class="math inline">\(x\)</span>轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">    A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(x\)</span>相同比<span class="math inline">\(y\)</span>,否则比<span class="math inline">\(x\)</span>.</p>
<h4><span id="二维凸包">二维凸包</span></h4>
<h5><span id="定义">定义</span></h5>
<p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5>
<p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否<span class="math inline">\(ABC\)</span>三点是一个上凸的(注意<span class="math inline">\(ABC\)</span>三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5>
<p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4>
<p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5>
<p>两个区域<span class="math inline">\(A,B\)</span>的闵可夫斯基和定义为<span class="math inline">\(\{a+b\mid a\in A,b\in B\}\)</span>.</p>
<h5><span id="实现">实现</span></h5>
<p>事实上,新的区域所形成的凸包,一定是原本<span class="math inline">\(A,B\)</span>的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下<span class="math inline">\(A,B\)</span>,使得<span class="math inline">\(B\)</span>有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是<span class="math inline">\(B\)</span>这个边加上<span class="math inline">\(A\)</span>的最右边的点.这样这条边必定还在最终的凸包上.就算<span class="math inline">\(A\)</span>最右边的是一条边,你也会发现最终的凸包最右边也一定是由<span class="math inline">\(A\)</span>的这条边和<span class="math inline">\(B\)</span>的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义半平面为满足<span class="math inline">\(ax+by+c&gt;0\)</span>或<span class="math inline">\(ax+by+c\geq 0\)</span>的点对<span class="math inline">\((x,y)\)</span>组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5>
<p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2>
<p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3>
<h4><span id="直线">直线</span></h4>
<p>使用直线的方向向量<span class="math inline">\(\vec
s=(n,m,p)\)</span>和直线上一点<span class="math inline">\(M_0=(x_0,y_0,z_0)\)</span>.那么方程显然为: <span class="math display">\[
\frac{x-x_0}{n}=\frac{y-y_0}{m}=\frac{z-z_0}{p}
\]</span> 如果换元,我们还有参数方程: <span class="math display">\[
\begin{cases}x=x_0+nt\\y=y_0+mt\\z=z_0+pt\end{cases}
\]</span></p>
<h4><span id="平面">平面</span></h4>
<p>使用平面上的一点<span class="math inline">\(P_0(x_0,y_0,z_0)\)</span>和该平面的法向量<span class="math inline">\(\vec n\)</span>来表示一个平面,不妨设<span class="math inline">\(\vec n=(A,B,C)\)</span>,则该平面的方程显然为:
<span class="math display">\[
A(x-x_0)+B(y-y_0)+C(z-z_0)=0
\]</span> 如果我们令<span class="math inline">\(D=-(Ax_0+By_0+Cz_)\)</span>,那么平面方程为: <span class="math display">\[
Ax+By+Cz+D=0
\]</span></p>
<h4><span id="夹角">夹角</span></h4>
<h5><span id="两直线夹角">两直线夹角.</span></h5>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是<span class="math inline">\(\vec
{s_1}=(n_1,m_1,p_1),\vec{s_2}=(n_2,m_2,p_2)\)</span>,也就有<span class="math inline">\(\varphi=\arccos(\frac{|\vec s_1\sdot \vec
s_2|}{|\vec s_1||\vec s_2|})\\\)</span>.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5>
<p>同样使用向量,不妨设方向向量<span class="math inline">\(\vec
s=(n,m,p)\)</span>,法向量<span class="math inline">\(\vec
f=(a,b,c)\)</span>,那么<span class="math inline">\(\varphi=\arcsin(\frac{|\vec s\sdot \vec f|}{|\vec
s||\vec f|})\)</span>.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li>若直线与平面平行,则<span class="math inline">\(am+bn+cp=0\)</span>.</li>
<li>若直线与平面垂直,则<span class="math inline">\(\frac{a}{m}=\frac{b}{n}=\frac{c}{p}\)</span>.注意这里分母可能除以<span class="math inline">\(0\)</span>,我们实际上应该是三个形如<span class="math inline">\(a=mt\)</span>的参数方程,这里简化了.</li>
</ol>
<h4><span id="交点">交点</span></h4>
<p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#二项式系数">二项式系数</a>
<ul>
<li><a href="#上升幂和下降幂">上升幂和下降幂</a></li>
<li><a href="#二项式系数的定义">二项式系数的定义</a></li>
<li><a href="#基本的二项式恒等式">基本的二项式恒等式</a></li>
<li><a href="#扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</a></li>
<li><a href="#拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</a></li>
<li><a href="#卡特兰数">卡特兰数</a>
<ul>
<li><a href="#examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</a></li>
<li><a href="#example223省选10连测day7b">Example2([23省选10连测day7]b)</a></li>
</ul></li>
<li><a href="#二项式系数的处理">二项式系数的处理</a>
<ul>
<li><a href="#通过恒等式变形求解">通过恒等式变形求解</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
</ul></li>
<li><a href="#转化为递归式和式求解">转化为递归式/和式求解</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
</ul></li>
<li><a href="#利用微积分求解">利用微积分求解</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#转化为二维平面">转化为二维平面</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#lucas定理">Lucas定理</a>
<ul>
<li><a href="#example1cf1770fkoxia-and-sequence">Example1([CF1770F]Koxia
and Sequence)</a></li>
</ul></li>
<li><a href="#扩展lucas定理">扩展Lucas定理</a></li>
</ul></li>
<li><a href="#斯特林数">斯特林数</a>
<ul>
<li><a href="#第一类斯特林数">第一类斯特林数</a></li>
<li><a href="#第二类斯特林数">第二类斯特林数</a></li>
<li><a href="#斯特林数的扩展">斯特林数的扩展</a></li>
<li><a href="#基本斯特林恒等式">基本斯特林恒等式</a></li>
<li><a href="#补充斯特林恒等式">补充斯特林恒等式</a></li>
</ul></li>
<li><a href="#欧拉数">欧拉数</a>
<ul>
<li><a href="#欧拉数与二项式系数">欧拉数与二项式系数</a></li>
</ul></li>
<li><a href="#伯努利数">伯努利数</a></li>
<li><a href="#斐波那契数">斐波那契数</a>
<ul>
<li><a href="#斐波那契数的扩展定义">斐波那契数的扩展定义</a></li>
<li><a href="#斐波那契数与数论">斐波那契数与数论</a></li>
<li><a href="#斐波那契数系">斐波那契数系</a></li>
<li><a href="#斐波那契数的封闭形式">斐波那契数的封闭形式</a></li>
<li><a href="#连项式">连项式</a></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2>
<h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3>
<p>定义下降幂<span class="math inline">\(x^{\underline{k}}=\prod_{i=0}^{k-1}(x-i)=\frac{x!}{(x-k)!}\)</span>.</p>
<p>定义上升幂<span class="math inline">\(x^{\overline{k}}\prod_{i=0}^{k-1}(x+i)=\frac{(x+k-1)!}{(x-1)!}\)</span>.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:<span class="math inline">\(r^{\underline{k}}(r-0.5)^{\underline{k}}=\cfrac{(2r)^{\underline{2k}}}{2^{2k}},k\in\mathbb{N}\)</span>.</p>
<p>他们之间存在转换:<span class="math inline">\(x^{\underline{n}}=(-1)^n(-x)^{\overline{n}}\)</span>.</p>
<p>同时存在大小关系:<span class="math inline">\(x^{\underline{n}}\leq
x^n\leq x^{\overline{n}}\)</span>,其中<span class="math inline">\(0\leq
n&lt;x\)</span>.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3>
<p>考虑令<span class="math inline">\(\binom{n}{m}\)</span>表示从一个大小为<span class="math inline">\(n\)</span>的子集中选出大小为<span class="math inline">\(m\)</span>的子集的方案数.第一次有<span class="math inline">\(n\)</span>个选择,第二次有<span class="math inline">\(n-1\)</span>个选择……第m次有<span class="math inline">\(n-m+1\)</span>个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是<span class="math inline">\(m!\)</span>,因此显然有<span class="math inline">\(\binom{n}m=\cfrac{n^{\underline{m}}}{m!}\)</span>.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
<p><span class="math inline">\(\binom{r}{k}=\begin{cases}\cfrac{r^{\underline{k}}}{k!}&amp;k\geq
0\\0&amp;k&lt;0\end{cases},r\in\mathbb{C},k\in\mathbb{Z}\)</span>.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把<span class="math inline">\(\binom{r}k\)</span>看作了一个关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式.</p>
<p>另外根据定义,<span class="math inline">\(r\in\mathbb{Z}\and
r&lt;k\)</span>时,该公式给出<span class="math inline">\(0\)</span>.</p>
<p>值得一提的是,为了使二项式系数在面对<span class="math inline">\(0\)</span>的时候更加简洁,通常直接定义<span class="math inline">\(0!=1,0^0=1\)</span>.</p>
<p>另外不难发现<span class="math inline">\(\binom{2n}{n}\)</span>是所有<span class="math inline">\(\binom{2n}{k}\)</span>中最大的.事实上我们有Wallis公式:<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{(\frac{2^{2n}}{\binom{2n}{n}})^2}{2n+1}=\frac{\pi}{2}\)</span>.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3>
<ol type="1">
<li>阶乘展开式:<span class="math inline">\(\binom{n}{k}=\cfrac{n!}{k!(n-k)!},n,k\in\mathbb{N},n\geq
k\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="2" type="1">
<li>对称恒等式:<span class="math inline">\(\binom{n}{k}=\binom{n}{n-k},n\in\mathbb{N},k\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\((1)\)</span>,<span class="math inline">\(0\leq k\leq
n\)</span>时是显然的.而其他情况两边都会给出<span class="math inline">\(0\)</span>,因此也是成立的.</p>
<ol start="3" type="1">
<li>吸收恒等式:<span class="math inline">\(\binom{r}{k}=\cfrac{r}{k}\binom{r-1}{k-1},k\in\mathbb{Z}\and
k\ne 0\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="4" type="1">
<li>吸收恒等式的变式:<span class="math inline">\(k\binom{r}{k}=r\binom{r-1}{k-1},k\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\((3)\)</span>,只需要验证<span class="math inline">\(k=0\)</span>的情况即可,也是显然的.</p>
<ol start="5" type="1">
<li>相伴恒等式:<span class="math inline">\((r-k)\binom{r}{k}=r\binom{r-1}{k},k\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>证明如下: <span class="math display">\[
(r-k)\binom{r}{k}=(r-k)\binom{r}{r-k}\\
=r\binom{r-1}{r-k-1}\\
=r\binom{r-1}{k}
\]</span> 问题在于:我们在上述描述中并未提到<span class="math inline">\(r\)</span>的范围,但是推导过程要求<span class="math inline">\(r\in\mathbb{N}\)</span>.不过,我们已经说明了二项式系数是关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式,因此只需要有<span class="math inline">\(k+1\)</span>个<span class="math inline">\(r\)</span>满足这个公式即可.而根据推导过程显然有无限个<span class="math inline">\(r\)</span>满足,因此这个公式对<span class="math inline">\(r\in\mathbb{C}\)</span>也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明: <span class="math display">\[
k\binom{r}{k}=r\binom{r-1}{k-1}\\
(r-k)\binom{r}{r-k}=r\binom{r-1}{r-k-1}\\
(r-k)\binom{r}{k}=r\binom{r-1}{k}
\]</span></p>
<ol start="6" type="1">
<li>加法公式:<span class="math inline">\(\binom{r}{k}=\binom{r-1}{k}+\binom{r-1}{k-1},k\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>证明可以使用定义,也可以先用<span class="math inline">\(r\in\mathbb{N}\)</span>的情况给出组合意义,再使用多项式推理法证明.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\binom{r}{m}\binom{m}{k}=\binom{r}{k}\binom{r-k}{m-k},n,k\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol start="8" type="1">
<li>平行求和法:<span class="math inline">\(\sum_{k\leq
n}\binom{r+k}{k}=\binom{r+n+1}{n},n\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p><span class="math inline">\(\binom{r+n+1}{n}=\binom{r+n}{n}+\binom{r+n}{n-1}=\binom{r+n}{n}+\binom{r+n-1}{n-1}+\binom{r+n-1}{n-2}=...\\\)</span>,最终下标会减成负数,这样后面的项就全都是<span class="math inline">\(0\)</span>了.</p>
<p>也可以考虑组合意义:如果<span class="math inline">\(r\in\mathbb{N}\)</span>,那么我们考虑从右到左第一个没有被选上的数,假设它是<span class="math inline">\(r+k+1\)</span>,那么在它右边的数全部选择了,一共是<span class="math inline">\(n-k\)</span>个数,而还需要在左边的<span class="math inline">\(r+k\)</span>中选择<span class="math inline">\(k\)</span>个数.</p>
<ol start="9" type="1">
<li>上指标求和法:<span class="math inline">\(\sum_{0\leq k\leq
n}\binom{k}{m}=\binom{n+1}{m+1},n,m\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是<span class="math inline">\(k+1\)</span>,接下来就还需要在<span class="math inline">\([1,k]\)</span>中选择<span class="math inline">\(m\)</span>个.</p>
<p>如果我们将这个公式两边同时乘以<span class="math inline">\(m!\)</span>,我们可以得到公式:<span class="math inline">\(\sum_{0\leq k\leq
n}k^{\underline{m}}=\cfrac{(n+1)^{\underline{m+1}}}{m+1},n,m\in\mathbb{N}\\\)</span>,这也就是有限微积分的公式中的一个.</p>
<ol start="10" type="1">
<li>二项式定理:<span class="math inline">\((x+y)^r=\sum_{k}\binom{r}{k}x^ky^{r-k},r\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况: <span class="math display">\[
\sum_{0\leq k\leq n}\binom{n}{k}=2^n,n\in\mathbb{N}\\
\]</span> 在二项式定理中令<span class="math inline">\(x=y=1\)</span>即可证明. <span class="math display">\[
\sum_{0\leq k\leq n}(-1)^k\binom{n}{k}=0^n=[n=0],n\in\mathbb{N}\\
\]</span> 在二项式定理中令<span class="math inline">\(x=-1,y=1\)</span>即可证明,值得一提的是,当<span class="math inline">\(n=0\)</span>的时候这个式子给出<span class="math inline">\(1\)</span>,并在其他情况下给出<span class="math inline">\(0\)</span>,这个式子是二项式反演的基础.</p>
<ol start="11" type="1">
<li>三项式定理:<span class="math inline">\((x+y+z)^n=\sum_{0\leq
a,b,c\leq
n}[a+b+c=n]\cfrac{n!}{a!b!c!}x^ay^bz^c,n\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,<span class="math inline">\(\cfrac{n!}{a!b!c!}=\binom{n}{b+c}\binom{b+c}{c}\)</span>.</p>
<ol start="12" type="1">
<li>多项式定理:<span class="math inline">\((\sum_{i=1}^mx_i)^n=\sum_{\forall i\in[1,m],0\leq
a_i\leq
n}[\sum_{i=1}^ma_i=n]\cfrac{n!}{\prod_{i=1}^ma_i!}\prod_{i=1}^mx_i^{a_i},n\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol start="13" type="1">
<li>范德蒙德卷积:<span class="math inline">\(\sum_{k}\binom{r}{m+k}\binom{s}{n-k}=\binom{r+s}{n+m},n,m\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol start="14" type="1">
<li>范德蒙德卷积的变式:<span class="math inline">\(\sum_{k}\binom{l}{m+k}\binom{s}{n+k}=\binom{l+s}{l-m+n},l\in\mathbb{N},n,m\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\binom{l}{m+k}=\binom{l}{l-m-k}\)</span>,然后运用范德蒙德卷积即可得到答案.</p>
<ol start="15" type="1">
<li>上指标反转公式:<span class="math inline">\(\binom{r}{k}=(-1)^k\binom{k-r-1}{k}\\\)</span>.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\sum_{k\leq
m}\binom{r}{k}(-1)^k=(-1)^m\binom{r-1}{m},m\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>证明如下: <span class="math display">\[
\sum_{k\leq m}\binom{r}{k}(-1)^k=\sum_{k\leq m}\binom{k-r-1}{k}\\
=\binom{-r+m}{m}=(-1)^m\binom{r-1}{m}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(\sum_{-q\leq k\leq
l}\binom{l-k}{m}\binom{q+k}{n}=\binom{l+q+1}{m+n+1},n,m\in\mathbb{N},l+q\geq
0\\\)</span>.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\sum_{k}\binom{a+b}{a+k}\binom{a+b}{b+k}(-1)^k=\binom{a+b}{a},a,b\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{k=0}^m\cfrac
{\binom{m}{k}}{\binom{n}{k}}=\cfrac{n+1}{n+1-m},n,m\in\mathbb{N},n\geq
m\\\)</span>.</li>
</ol>
<p>我们有<span class="math inline">\(\binom{n}{m}\binom{m}{k}=\binom{n}{k}\binom{n-k}{m-k}\\\)</span>,两边同时除以<span class="math inline">\(\binom{n}{m}\binom{n-k}{m-k}\\\)</span>,于是我们得到了<span class="math inline">\(\cfrac {\binom{m}{k}}{\binom{n}{k}}=\cfrac
{\binom{n-k}{m-k}}{\binom{n}{m}}\\\)</span>.</p>
<p>有: <span class="math display">\[
\sum_{k=0}^m\cfrac {\binom{m}{k}}{\binom{n}{k}}=\sum_{k=0}^m\cfrac
{\binom{n-k}{m-k}}{\binom{n}{m}}\\
=\cfrac{1}{\binom{n}{m}}\sum_{k=0}^m\binom{n-k}{m-k}\\
=\cfrac{1}{\binom{n}{m}}\sum_{k=0}^m\binom{n-m+k}{k}\\
=\cfrac{\binom{n+1}{m}}{\binom{n}{m}}\\
=\cfrac{n+1}{n+1-m}
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\((-1)^m\binom{-n-1}{m}=(-1)^n\binom{-m-1}{n},n,m\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于<span class="math inline">\(\binom {n+m} m\\\)</span>.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{k\leq
m}\binom{r}{k}(\cfrac{r}2-k)=\cfrac{m+1}2\binom{r}{m+1},m\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{k\leq
m}\binom{m+r}{k}x^ky^{m-k}=\sum_{k\leq
m}\binom{-r}{k}(-x)^k(x+y)^{m-k},m\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>不妨令左边的值为<span class="math inline">\(S_m\)</span>,我们有:
<span class="math display">\[
S_m=\sum_{k\leq m}\binom{m+r}{k}x^ky^{m-k}=\sum_{k\leq
m}\binom{m+r-1}{k}x^ky^{m-k}+\sum_{k\leq
m}\binom{m+r-1}{k-1}x^ky^{m-k}\\
=y\sum_{k&lt;m}\binom{m-1+r}{k}x^ky^{m-1-k}+\binom{m+r-1}{m}x^m+x\sum_{k\leq
m}\binom{m+r-1}{k-1}x^{k-1}y^{m-k}\\
=(x+y)S_{m-1}+\binom{m+r-1}{m}x^m\\
=(x+y)S_{m-1}+\binom{r}{m}(-x)^m
\]</span> 左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{k\leq
m}\binom{m+k}{k}2^{-k}=2^m,m\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\((7)\)</span>,将<span class="math inline">\(x=y=1,r=m+1\)</span>带入,得到: <span class="math display">\[
\sum_{k\leq m}\binom{2m+1}{k}=\sum_{k\leq m}\binom{m+k}{k}2^{m-k}\\
2^{2m}=\sum_{k\leq m}\binom{m+k}{k}2^{m-k}\\
2^m=\sum_{k\leq m}\binom{m+k}{k}2^{-k}
\]</span></p>
<ol start="9" type="1">
<li><span class="math inline">\(\sum_{k}\binom{l}{m+k}\binom{s+k}{n}(-1)^k=(-1)^{l+m}\binom{s-m}{n-l},l\in\mathbb{N},n,m\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\sum_{k\leq
l}\binom{l-k}{m}\binom{s}{k-n}(-1)^k=(-1)^{l+m}\binom{s-m-1}{l-n-m},l,n,m\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\binom{r}{k}\binom{r-\cfrac{1}{2}}{k}=\cfrac{\binom{2r}{2k}\binom{2k}{k}}{2^{2k}},k\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>将加倍公式两边同时除以<span class="math inline">\(k!^2\)</span>即可得到这个公式.</p>
<ol start="2" type="1">
<li><span class="math inline">\(\binom{n-\cfrac1
2}{n}=\cfrac{\binom{2n}{n}}{2^{2n}},n\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>将<span class="math inline">\((1)\)</span>中令<span class="math inline">\(r=k=n\)</span>即可得到这个公式.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\binom{-\cfrac{1}2}{n}=(\cfrac{-1}{4})^n\binom{2n}{n},n\in\mathbb{Z}\\\)</span>.</li>
</ol>
<p>即<span class="math inline">\((2)\)</span>的变形.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{k}\binom{n}{2k}\binom{2k}{k}2^{-2k}=\binom{n-\cfrac
1 2}{\lfloor\cfrac{n}2\rfloor},n\in\mathbb{N}\\\)</span></li>
</ol>
<p>首先根据<span class="math inline">\((1)\)</span>,左边<span class="math inline">\(=\sum_{k}\binom{\cfrac{n}{2}}{k}\binom{\cfrac{n-1}{2}}{k}\\\)</span>,而考虑到<span class="math inline">\(\cfrac{n}{2}\)</span>和<span class="math inline">\(\cfrac{n-1}{2}\)</span>必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\sum_{k}\binom{-\cfrac1
2}{k}\binom{-\cfrac 1 2}{n-k}=(-1)^n,n\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{k}\binom{2k}{k}\binom{2n-2k}{n-k}=4^n,n\in\mathbb{N}\\\)</span>.</li>
</ol>
<p>由<span class="math inline">\((5)\)</span>和<span class="math inline">\((3)\)</span>不难推出.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{k}\binom{n}{k}\cfrac{(-1)^k}{x+k}=x^{-1}\binom{x+n}{n}^{-1},x\notin\{0,-1,...,-n\}\\\)</span>.</li>
</ol>
<p>令<span class="math inline">\(f(x)=(x-1)^{\underline{-1}}\)</span>,直接做高阶差分即可得到这个式子.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{k=0}^n\binom{r}{k}\binom{r}{n-k}(-1)^k=[n\
is\ even](-1)^{\cfrac{n}{2}}\binom{r}{\cfrac{n}2}\\\)</span>.</li>
</ol>
<p>首先不难发现,<span class="math inline">\((1-z)^r=\sum_{k\geq
0}(-1)^k\binom{r}{k}\\\)</span>.</p>
<p>考虑<span class="math inline">\((1-z)^r(1+z)^r=(1-z^2)^r\)</span>.</p>
<p>我们有<span class="math inline">\([z^n](1-z)^r(1+z)^r=[z^n](1-z^2)^r\)</span>,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3>
<p>卡特兰数<span class="math inline">\(f_n\)</span>表示:长度为<span class="math inline">\(2n\)</span>的合法括号序列个数.</p>
<p>卡特兰数的前几项为<span class="math inline">\(1,1,2,5,14,42,132\cdots\)</span>.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:<span class="math inline">\(f_n=\sum_{i=0}^{n-1}f_if_{n-1-i}\)</span>.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如<span class="math inline">\((A)B\)</span>.</p>
<p>考虑将其删成<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,则<span class="math inline">\(A\)</span>一定合法,因为若<span class="math inline">\(A\)</span>不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:<span class="math inline">\(f_n=\frac 1
{n+1}C_{2n}^n=C_{2n}^n-C_{2n}^{n-1}\)</span>.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从<span class="math inline">\((0,0)\)</span>走到<span class="math inline">\((2n,0)\)</span>不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到<span class="math inline">\((2n,0)\)</span>的方案数是<span class="math inline">\(C_{2n}^n\)</span>.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点<span class="math inline">\((x,-1)\)</span>.</p>
<p>考虑将<span class="math inline">\(x\)</span>以后的折线以直线<span class="math inline">\(y=-1\)</span>为对称轴反转,那么终点到了<span class="math inline">\((2n,-2)\)</span>.</p>
<p>不难发现,任意从<span class="math inline">\((0,0)\)</span>走到<span class="math inline">\((2n,-2)\)</span>的方案一定唯一对应了一种从<span class="math inline">\((0,0)\)</span>走到<span class="math inline">\((2n,0)\)</span>的不合法方案.因为从<span class="math inline">\((0,0)\)</span>走到<span class="math inline">\((2n,-2)\)</span>一定会经过直线<span class="math inline">\(y=-1\)</span>,将后半部分对称后就是其对应方案.而从<span class="math inline">\((0,0)\)</span>走到<span class="math inline">\((2n,-2)\)</span>的方案数为<span class="math inline">\(C_{2n}^{n-1}\)</span>.</p>
<p>因而<span class="math inline">\(f_n=C_{2n}^n-C_{2n}^{n-1}\\\)</span>.</p>
<p>而<span class="math inline">\(C_{2n}^n-C_{2n}^{n-1}=\frac{(2n)!}{n!n!}-\frac{(2n)!}{(n-1)!(n+1)!}=\frac{(2n)!}{n!(n+1)!}=\frac{C_{2n}^n}{n+1}\\\)</span>.</p>
<p>递推定义:<span class="math inline">\(f_n=\frac
{4n-2}{n+1}f_{n-1}\\\)</span>.</p>
<p>使用一下上一步的通项公式:<span class="math inline">\(\begin{cases}
f_n=\frac{(2n)!}{n!(n+1)!}\\
f_{n-1}=\frac{(2n-2)!}{(n-1)!(n)!}
\end{cases}\\\)</span> 不难发现<span class="math inline">\(f_n=\frac{(2n-1)(2n)}{n(n+1)}f_{n-1}\\\)</span>.整理,得到<span class="math inline">\(f_n=\frac{4n-2}{n+1}f_{n-1}\\\)</span>.</p>
<p>换个记号,设<span class="math inline">\(C_n\)</span>为卡特兰数的第<span class="math inline">\(n\)</span>项,卡特兰数有一个著名的结论是<span class="math inline">\(k\)</span>次卷积: <span class="math display">\[
C^{(k)}_n=\sum_{\sum_{j=1}^k a_j=n}\prod
C_{a_i}=\frac{k}{n+k}\binom{2n+k-1}{n}
\]</span> 我们可以这么理解它:它指的是一个长度为<span class="math inline">\(n+k-1\)</span>的括号序列,前<span class="math inline">\(k-1\)</span>个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成<span class="math inline">\((((A)B)C)D\)</span>之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有: <span class="math display">\[
C^{(k)}_n=\binom{2n+k-1}{n}-\binom{2n+k-1}{n-1}\\
=\frac{k}{n+k}\binom{2n+k-1}{n}
\]</span></p>
<h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5>
<p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是<span class="math inline">\(\binom{2n}{n}\)</span>.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5>
<p>给定<span class="math inline">\(x,n\)</span>,对<span class="math inline">\(y\in[1,n]\)</span>,固定<span class="math inline">\(p_x=y\)</span>做笛卡尔树的<strong>形态</strong>计数.<span class="math inline">\(n\leq 5\times 10^5\)</span>.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现<span class="math inline">\(a_x=y\)</span>只要满足:</p>
<ol type="1">
<li><span class="math inline">\(x\)</span>节点的祖先数量不超过<span class="math inline">\(y-1\)</span>个(深度小于等于<span class="math inline">\(y\)</span>).</li>
<li><span class="math inline">\(x\)</span>节点的子树大小不超过<span class="math inline">\(n-y+1\)</span>.</li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出<span class="math inline">\(f_p\)</span>表示<span class="math inline">\(x\)</span>的深度为<span class="math inline">\(p\)</span>的答案,<span class="math inline">\(g_p\)</span>表示<span class="math inline">\(x\)</span>的子树大小为<span class="math inline">\(p\)</span>的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:<span class="math inline">\(x\)</span>的祖先有两种:一种在序列中在<span class="math inline">\(x\)</span>的左边,一种在<span class="math inline">\(x\)</span>的右边.我们设前者为<span class="math inline">\(0=l_0&lt;l_1&lt;l_2&lt;\cdots
l_p&lt;l_{p+1}=x\)</span>,设后者为<span class="math inline">\(n+1=r_0&gt;r_1&gt;r_2&gt;\cdots
&gt;r_{q}&gt;r_{q+1}=x\)</span>.这么分类有什么用呢?我们考虑<span class="math inline">\((l_{i-1},l_{i})\)</span>这一段数能放在哪里,它只能是<span class="math inline">\(l_{i}\)</span>的左儿子,独立于整棵树,因此这一段的答案就是<span class="math inline">\(C_{l_i-l_{i-1}-1}\)</span>.</p>
<p>记: <span class="math display">\[
L_p=\sum_{l}\prod_{i=1}^{p+1}
C_{l_i-l_{i-1}-1}\\R_q=\sum_{r}\prod_{i=1}^{q+1}C_{r_{i-1}-r_i-1}\\
\]</span> 注意到这等价于卡特兰数的<span class="math inline">\(k\)</span>次卷积,有: <span class="math display">\[
L_p=C_{x-p-1}^{(p+1)}\\
R_q=C^{(q+1)}_{n-x-q}\\
\]</span> 此时的答案自然是<span class="math inline">\(f_{p+q+1}=L_pR_q\binom{p+q}{q}\)</span>,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把<span class="math inline">\(x\)</span>的子树从原树中删去,然后插入<span class="math inline">\(x\)</span>一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为<span class="math inline">\(p\)</span>,右子树大小为<span class="math inline">\(q\)</span>,我们有<span class="math inline">\(g_{p+q+1}=C_pC_qC_{n-(p+q+1)}=C_{n-1}^{(3)}\)</span>,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3>
<h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{k=0}^nk\binom{m-k-1}{m-n-1},n,m\in\mathbb{N}\and
m&gt;n\\\)</span>.</p>
<p>这个式子乘了个系数<span class="math inline">\(k\)</span>导致很难处理,一个自然的想法是使用吸收恒等式将<span class="math inline">\(k\)</span>消去,然后对后面的式子使用上指标求和.</p>
<p>于是: <span class="math display">\[
\sum_{k=0}^nk\binom{m-k-1}{m-n-1}=\sum_{k=0}^nm\binom{m-k-1}{m-n-1}-\sum_{k=0}^n(m-k)\binom{m-k-1}{m-n-1}\\
=m\sum_{k=0}^{m-1}\binom{m-k-1}{m-n-1}-(m-n)\sum_{k=0}^m\binom{m-k}{m-n}
\]</span> 不妨令<span class="math inline">\(S_m=\sum_{k=0}^m\binom{m-k}{m-n}\\\)</span>,不难发现我们有:
<span class="math display">\[
S_m=\sum_{k=0}^m\binom{k}{m-n}=\binom{m+1}{m-n+1}
\]</span> 于是原式<span class="math inline">\(=mS_{m-1}-(m-n)S_m=\cfrac{n}{m-n+1}\binom{m}{m-n}\\\)</span>.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将<span class="math inline">\(k=\binom{k}{1}\)</span>带入: <span class="math display">\[
\sum_{k=0}^nk\binom{m-k-1}{m-n-1}=\sum_{k=0}^n\binom{k}{1}\binom{m-k-1}{m-n-1}\\
=\binom{m}{m-n+1}\\
=\cfrac{n}{m-n+1}\binom{m}{m-n}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{k}k\binom{n}{k}\binom{s}{k},n\in\mathbb{N}\\\)</span>.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到<span class="math inline">\(n\)</span>和<span class="math inline">\(s\)</span>的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:
<span class="math display">\[
\sum_{k}k\binom{n}{k}\binom{s}{k}=s\sum_{k}\binom{n}{k}\binom{s-1}{k-1}\\
=s\binom{n+s-1}{n-1}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(\sum_{0\leq
k}\binom{n+k}{2k}\binom{2k}{k}\cfrac{(-1)^k}{k+1},n\in\mathbb{N}\\\)</span>.</p>
<p>我们有: <span class="math display">\[
\sum_{0\leq
k}\binom{n+k}{2k}\binom{2k}{k}\cfrac{(-1)^k}{k+1}=\sum_{0\leq
k}\binom{n+k}{k}\binom{n}{k}\cfrac{(-1)^k}{k+1},n\in\mathbb{N}\\
=\cfrac{1}{n+1}\sum_{0\leq k}\binom{n+k}{k}\binom{n+1}{k+1}{(-1)^k}\\
=\cfrac{1}{n+1}\sum_{0\leq
k}\binom{-n-1}{k}\binom{n+1}{k+1}\\=\cfrac{1}{n+1}\binom{0}{n}\\=[n=0]
\]</span></p>
<h5><span id="example4">Example4</span></h5>
<p>求<span class="math inline">\(\sum_{k\geq
0}\binom{n+k}{m+2k}\binom{2k}{k}\cfrac{(-1)^k}{k+1},n,m\in\mathbb{N_+}\\\)</span>.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的<span class="math inline">\((1)\)</span>,我们有: <span class="math display">\[
\sum_{k\geq
0}\binom{n+k}{m+2k}\binom{2k}{k}\cfrac{(-1)^k}{k+1}=\sum_{k\geq
0}\sum_{0\leq j\leq
n+k-1}\binom{n+k-1-j}{2k}\binom{j}{m-1}\binom{2k}{k}\cfrac{(-1)^k}{k+1}\\
=\sum_{0\leq j\leq n-1}\binom{j}{m-1}\sum_{j+1-n\leq k,0\leq
k}\binom{n+k-1-j}{2k}\binom{2k}{k}\cfrac{(-1)^k}{k+1}
\]</span> 注意到如果<span class="math inline">\(j+1-n\geq
0\)</span>,则<span class="math inline">\(\binom{n+k-1-j}{2k}\\\)</span>应为<span class="math inline">\(0\)</span>.所以有: <span class="math display">\[
\sum_{0\leq j\leq n-1}\binom{j}{m-1}\sum_{j+1-n\leq k,0\leq
k}\binom{n+k-1-j}{2k}\binom{2k}{k}\cfrac{(-1)^k}{k+1}\\
=\sum_{0\leq j&lt;n}\binom{j}{m-1}[n-1-j=0]=\binom{n-1}{m-1}
\]</span></p>
<h5><span id="example5">Example5</span></h5>
<p>求<span class="math inline">\(\sum_{k=0}^n(C_n^k)^2\)</span>. <span class="math display">\[
\sum_{k=0}^n(C_n^k)^2=\sum_{k=0}^nC_{n}^k\times C_{n}^{n-k}=C_n^{2n}
\]</span></p>
<h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(Q_n=\sum_{k\leq
2^n}\binom{2^n-k}{k}(-1)^k,n\in\mathbb{N}\\\)</span>.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于<span class="math inline">\(Q_n\)</span>的式子中实际上只与<span class="math inline">\(2^n\)</span>有关,我们不妨令<span class="math inline">\(R_n=\sum_{k\leq
n}\binom{n-k}{k}(-1)^k\\\)</span>,显然有<span class="math inline">\(Q_n=R_{2^n}\)</span>.</p>
<p>而我们有: <span class="math display">\[
R_n=\sum_{k\leq n}\binom{n-1-k}{k}(-1)^k+\sum_{k\leq
n}\binom{n-1-k}{k-1}(-1)^k\\
=\sum_{k\leq n}\binom{n-1-k}{k}(-1)^k+\sum_{k\leq
n-1}\binom{n-k-2}{k}(-1)^{k+1}\\
=\sum_{k\leq n-1}\binom{n-1-k}{k}(-1)^k+\binom{-1}{n}(-1)^n-(\sum_{k\leq
n-2}\binom{n-2-k}{k}(-1)^k+\binom{-1}{n-1}(-1)^{n-1})\\
=\sum_{k\leq n-1}\binom{n-1-k}{k}(-1)^k-\sum_{k\leq
n-1}\binom{n-2-k}{k}(-1)^k\\
=R_{n-1}-R_{n-2}\\
=R_{n-2}-R_{n-3}-R_{n-2}\\
=-R_{n-3}\\
=R_{n-6}
\]</span> 也即<span class="math inline">\(R_n\)</span>具有周期性,不难计算前几项答案,最后有<span class="math inline">\(Q_n\begin{cases}1&amp;n=0\\0&amp;n\ is \
odd\\-1&amp;n&gt;0\and n\ is\ even\end{cases}\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\((\sum^{+\infty}_{i=0}C^{ik+r}_{nk})\mod
p\)</span>.</p>
<p>考虑设<span class="math inline">\(f(n,r)=\sum^{+\infty}_{i=0}C^{ik+r}_{nk}\\\)</span>,则有:
<span class="math display">\[
f(n,r)=\sum^{+\infty}_{i=0}C^{ik+r}_{nk}\\=\sum_{i=0}^{+\infty}\sum_{j=0}^k
C_{nk-k}^{ik+r-j}\times C_k^j\\
=\sum^k_{j=0}C_k^j\sum_{i=0}^{+\infty}C_{nk-k}^{ik+r-j}\\=\sum_{j=0}^kC_k^jf(n-1,r-j)\\
\]</span> 整理上式,得到:<span class="math inline">\(f(n,r)=\sum_{j=0}^kC_k^jf(n-1,r-j)\\\)</span>.</p>
<p>于是我们得到了关于<span class="math inline">\(f\)</span>的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4>
<h5><span id="example">Example</span></h5>
<p>求<span class="math inline">\(\sum_{k=1}^nk^2C_n^k\)</span>. <span class="math display">\[
((1+x)^n)=(\sum_{k=0}^nC_n^kx^{k})\\
((1+x)^n)&#39;=(\sum_{k=0}^nC_n^kx^{k})&#39;\\
n(1+x)^{n-1}=\sum_{k=0}^nkC_n^kx^{k-1}\\
nx(1+x)^{n-1}=\sum_{k=0}^nkC_n^kx^{k}\\
(nx(1+x)^{n-1})&#39;=(\sum_{k=0}^nkC_n^kx^{k})&#39;\\
n((1+x)^{n-1}+(n-1)x(1+x)^{n-2})=\sum_{k=0}^nk^2C_n^kx^{k-1}\\
\]</span> 取<span class="math inline">\(x=1\)</span>,则原式<span class="math inline">\(=n(n+1)2^{n-2}\)</span>.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>多次询问给定<span class="math inline">\(k,r\)</span>,<span class="math inline">\(\sum k\leq 2n,r&lt; 2n-k\)</span>,求<span class="math inline">\(\sum_{i=0}^{r}\frac{1}{2^i}\binom{i}{n-k}\)</span>,.</p>
<p>我们把模型抽象成:在二维平面上,从<span class="math inline">\((0,0)\)</span>随机游走到<span class="math inline">\((n-k+1,r-n+k)\)</span>正下方(包含这个点)的概率,容易发现此时向右走了<span class="math inline">\(n-k\)</span>步,总共走了<span class="math inline">\(\leq
r\)</span>步,然后再向右走一步保证第一次走到了<span class="math inline">\((n-k+1,r-n+k)\)</span>下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到<span class="math inline">\(x+y=r+1\)</span>这条直线时横坐标<span class="math inline">\(\geq
n-k+1\)</span>的概率.枚举一下总共向上走了几步,就得到<span class="math inline">\(\frac{1}{2^{r}}\sum_{j=0}^{r-n+k}\binom{r+1}{j}\)</span>,注意这里是<span class="math inline">\(\frac{1}{2^r}\)</span>,因为从一开始钦定了一步,因此映射过来需要多乘个<span class="math inline">\(\frac{1}{2}\)</span>,反映射就要乘个<span class="math inline">\(2\)</span>.但是这个式子还是做不了,因为<span class="math inline">\(r\)</span>并不满足<span class="math inline">\(\sum
r\leq 2n\)</span>.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于<span class="math inline">\(1-\frac{1}{2^{r}}\sum_{i=0}^{n-k}\binom{r+1}{i}\)</span>.我们考虑暴力预处理出<span class="math inline">\(f_r=\sum_{i=0}^{n}\binom{r}{i}\)</span>,每次删掉一个后缀的组合数就行.现在的问题在于<span class="math inline">\(f\)</span>怎么做.</p>
<p>直接拆组合数,我们有: <span class="math display">\[
f_r=\sum_{i=0}^n\binom{r}{i}\\
=\sum_{i=0}^n\binom{r-1}{i-1}+\sum_{i=0}^n\binom{r-1}{i}\\
=2\sum_{i=0}^n\binom{r-1}{i}-\binom{r-1}{n}\\
=2f_{r-1}-\binom{r-1}{n}
\]</span></p>
<h3><span id="lucas定理">Lucas定理</span></h3>
<p>若<span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(C_n^m\mod p=C_{n\mod p}^{m\mod p}\times
C_{\lfloor\frac n p\rfloor}^{\lfloor\frac m p\rfloor}\mod
p\\\)</span>.</p>
<p>或者说,将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>在<span class="math inline">\(p\)</span>进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若<span class="math inline">\(i\ne 0\)</span>且<span class="math inline">\(i\ne p\)</span>,<span class="math inline">\(C_{p}^i\equiv\frac p iC_{p-1}^{i-1}\equiv 0(\mod
p)\\\)</span>.</p>
<p>而根据二项式定理,<span class="math inline">\((1+x)^p\equiv
\sum_{i=0}^pC_{p}^ix^i=1+x^p(\mod p)\\\)</span>.</p>
<p>令<span class="math inline">\(n=k_1p+b_1\)</span>,<span class="math inline">\(m=k_2p+b_2\)</span>,则<span class="math inline">\((1+x)^n=(1+x)^{k_1p}(1+x)^{b_1}\\\)</span>.</p>
<p>而<span class="math inline">\((1+x)^{k_1p}\equiv (1+x^p)^{k_1}(\mod
p)\\\)</span>,有<span class="math inline">\((1+x)^n\equiv
(1+x^p)^{k_1}(1+x)^{b_1}\\\)</span>.</p>
<p>根据二项式定理,<span class="math inline">\(C_n^m\bmod
p\)</span>即<span class="math inline">\(x^m\)</span>项的系数.</p>
<p>我们可以得出,<span class="math inline">\(C_n^mx^m\equiv
C_{k_1}^{k_2}x^{k_2p}C_{b1}^{b_2}x^{b_2}\pmod p\\\)</span>,那么有<span class="math inline">\(C_a^b\equiv C_{k_1}^{k_2}C_{b_1}^{b_2}\pmod
p\\\)</span>.</p>
<p>另外,Lucas定理有一个很重要的推论是: <span class="math display">\[
\binom{n}{m}\equiv [m\subseteq n]\pmod 2
\]</span></p>
<h5><span id="example1cf1770fkoxia-andsequence">Example1([CF1770F]Koxia and
Sequence)</span></h5>
<p>首先观察样例并思考,可以发现当<span class="math inline">\(n\)</span>为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是<span class="math inline">\(0\)</span>),所以异或值为<span class="math inline">\(0\)</span>.不然,我们可以翻转<span class="math inline">\(a[2...n]\)</span>,得出答案应该是所有<span class="math inline">\(a_1\)</span>的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有<span class="math inline">\(y&#39;\subseteq y\)</span>,求出满足<span class="math inline">\(a_i\subseteq y&#39;,\sum a_i=x\)</span>时,<span class="math inline">\(a_1\)</span>异或和.接下来怎么做呢?我们考虑拆位,若<span class="math inline">\(2^k\subseteq y&#39;\)</span>,假设<span class="math inline">\(a_1\)</span>的第<span class="math inline">\(k\)</span>位是<span class="math inline">\(1\)</span>,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第<span class="math inline">\(k\)</span>位贡献是: <span class="math display">\[
[2^k\subseteq y&#39;]\bigoplus_{\sum a=x}[2^k\subseteq
a_1]\prod_{i=1}^n[a_i\subseteq y&#39;]
\]</span>
这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:<span class="math inline">\([x\subseteq y]\equiv \binom{y}{x}\pmod
2\)</span>.</p>
<p>所以原式化简为: <span class="math display">\[
\binom{y&#39;}{2^k}\sum_{\sum
a=x}\binom{a_1}{2^k}\prod_{i=1}^n\binom{y&#39;}{a_i}\pmod 2\\
=\binom{y&#39;}{2^k}\sum_{a_1}\binom{y&#39;-2^k}{a_1-2^k}\sum_{\sum
a=x-a_1}\prod_{i=2}^n\binom{y&#39;}{a_i}\pmod 2\\
\]</span> 然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:
<span class="math display">\[
\binom{y&#39;}{2^k}\sum_{a_1}\binom{y&#39;-2^k}{a_1-2^k}\binom{(n-1)y&#39;}{x-a_1}\pmod
2\\
=\binom{y&#39;}{2^k}\binom{ny&#39;-2^k}{x-2^k}\pmod 2\\
=[2^k\subseteq y&#39;][(x-2^k)\subseteq(ny&#39;-2^k)]
\]</span></p>
<h3><span id="扩展lucas定理">扩展Lucas定理</span></h3>
<p>令<span class="math inline">\(p=\prod
p_i^{e_i}\)</span>,那我们只要对于每个<span class="math inline">\(i\)</span>求出<span class="math inline">\(C_n^m\mod
p_i^{e_i}\)</span>,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求<span class="math inline">\(C_n^m\mod
p^k\)</span>,其中<span class="math inline">\(p\in prime\)</span>.</p>
<p>原式<span class="math inline">\(=\frac{n!}{m!(n-m)!}\mod p^k=\frac
{\frac {n!}{p^x}}{\frac{m!}{p^y}\frac{(n-m)!}{p^z}}p^{x-y-z}\mod
p^k\\\)</span>.</p>
<p>现在问题转化为求<span class="math inline">\(\frac{n!}{p^x}\mod
p^k以及p^x\\\)</span>.</p>
<p>注意到: <span class="math display">\[
n!=\prod_{i=1}i\\=(\prod_{i=wp,w\in \mathbb{Z}}i)(\prod_{i\ne
wp,w\in\mathbb{Z}}i)\\= p^{\lfloor n p\rfloor}(\lfloor n
p\rfloor!)(\prod_{i\ne wp,w\in\mathbb{Z}}i)\\
\equiv p^{\lfloor \frac{n}{ p}\rfloor}(\lfloor \frac{n}{
p}\rfloor!)(\prod_{i=1,i\ne wp,w\in\mathbb{Z}}^{p^k}i)^{\lfloor \frac n
{p^k}\rfloor}(\prod^{n\ \bmod {p^k}} _{i=p^k\lfloor\frac
n{p^k}\rfloor,i\ne wp,w\in\mathbb{Z}}i)(\mod p^k)
\]</span> 递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将<span class="math inline">\([1,n]\)</span>的所有数全部排成一个宽为<span class="math inline">\(p^k\)</span>的矩阵.</p>
<p>那右边第一项就是把那些<span class="math inline">\(p\)</span>的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2>
<h3><span id="第一类斯特林数">第一类斯特林数</span></h3>
<p>$ nk\<span class="math inline">\(:长度为\)</span>n<span class="math inline">\(的排列划分成\)</span>k$个轮换的方案数.</p>
<p>考虑现在已经将<span class="math inline">\(n-1\)</span>个数分成了若干轮换,现在新加入第<span class="math inline">\(n\)</span>个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然<span class="math inline">\(\left[ \begin{array}{c}n\\k\end{array}
\right]=(n-1)\left[ \begin{array}{c}n-1\\k\end{array} \right]+\left[
\begin{array}{c}n-1\\k-1\end{array} \right]\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left[
\begin{array}{c}0\\k\end{array} \right]=[k=0]\\\)</span>.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:<span class="math inline">\(\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array}
\right]=n!\)</span>.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3>
<p><span class="math inline">\(\left\{ \begin{array}{c}n\\k\end{array}
\right\}\)</span>:将<span class="math inline">\(n\)</span>个本质不同的物品划分成k个非空集合的方案数.</p>
<p>考虑现在已经放好<span class="math inline">\(n-1\)</span>个物品,正要放入第<span class="math inline">\(n\)</span>个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然<span class="math inline">\(\left\{ \begin{array}{c}n\\k\end{array}
\right\}=k\left\{ \begin{array}{c}n-1\\k\end{array} \right\}+\left\{
\begin{array}{c}n-1\\k-1\end{array} \right\}\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left\{
\begin{array}{c}0\\k\end{array} \right\}=[k=0]\\\)</span>.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3>
<p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:<span class="math inline">\({n\brack m}={-m\brace -n}\\\)</span>.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3>
<ol type="1">
<li><span class="math inline">\(x^n=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array}
\right\}x^{\underline{k}}=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array}
\right\}(-1)^{n-k}x^{\overline{k}}\\\)</span>.</li>
</ol>
<p>证明:先考虑前半段,不妨使用数学归纳.若<span class="math inline">\(x^{n-1}=\sum_{k=0}^{n-1}\left\{
\begin{array}{c}n-1\\k\end{array}
\right\}x^{\underline{k}}\\\)</span>,我们要证<span class="math inline">\(x^{n}=\sum_{k=0}^{n}\left\{
\begin{array}{c}n\\k\end{array} \right\}x^{\underline{k}}
\\\)</span>.也就是证明: <span class="math display">\[
x\sum_{k=0}^{n-1}\left\{ \begin{array}{c}n-1\\k\end{array}
\right\}x^{\underline{k}}=\sum_{k=0}^{n}\left\{
\begin{array}{c}n\\k\end{array} \right\}x^{\underline{k}}\\
\]</span> 考虑<span class="math inline">\((x-k)x^{\underline{k}}=x^{\underline{k+1}}\)</span>,所以<span class="math inline">\(x\cdot
x^{\underline{k}}=x^{\underline{k+1}}+kx^{\underline{k}}\\\)</span>.那么左边即:
<span class="math display">\[
\sum_{k=0}^{n-1}\left\{ \begin{array}{c}n-1\\k\end{array}
\right\}x^{\underline{k+1}}+\sum_{k=0}^{n-1}\left\{
\begin{array}{c}n-1\\k\end{array} \right\}kx^{\underline{k}}\\
=\sum_{k=1}^{n}\left\{ \begin{array}{c}n-1\\k-1\end{array}
\right\}x^{\underline{k}}+\sum_{k=1}^{n}\left\{
\begin{array}{c}n-1\\k\end{array} \right\}kx^{\underline{k}}\\
=\sum_{k=0}^n\left\{ \begin{array}{c}n\\k\end{array}
\right\}x^{\underline{k}}\\
\\
\]</span> 至于后半段,由于<span class="math inline">\(x^{\underline{n}}=(-1)^n(-x)^{\overline{n}}\\\)</span>,所以<span class="math inline">\(x^n=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array}
\right\}(-1)^k(-x)^{\overline{k}}\\\)</span>. 不妨用<span class="math inline">\(x\)</span>来代替<span class="math inline">\(-x\)</span>,我们有: <span class="math display">\[
(-x)^n=\sum_{k=0}^n\left\{ \begin{array}{c}n\\k\end{array}
\right\}(-1)^k(x)^{\overline{k}}\\
x^n=\sum_{k=0}^n\left\{ \begin{array}{c}n\\k\end{array}
\right\}(-1)^{n-k}x^{\overline{k}}
\]</span></p>
<ol start="2" type="1">
<li><p><span class="math inline">\(x^{\overline{n}}=\sum_{k=0}^n\left[
\begin{array}{c}n\\k\end{array} \right]x^k\\\)</span>.</p></li>
<li><p><span class="math inline">\(x^{\underline{n}}=\sum_{k=0}^n\left[
\begin{array}{c}n\\k\end{array}
\right](-1)^{n-k}x^k\\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于<span class="math inline">\((x+n-1)x^k=x^{k+1}+(n-1)x^k\\\)</span>,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol start="4" type="1">
<li>反转公式:<span class="math inline">\(\sum_{k=0}^n\left[
\begin{array}{c}n\\k\end{array} \right]\left\{
\begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array} \right\}\left[
\begin{array}{c}k\\m\end{array} \right](-1)^{n-k}=[m=n]\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑先证明后半部分,将(3)带入(1),得到<span class="math inline">\(x^n=\sum_{k=0}^n\left\{
\begin{array}{c}n\\k\end{array}
\right\}x^{\underline{k}}=\sum_{k=0}^n\sum_{m=0}^k\left\{
\begin{array}{c}n\\k\end{array} \right\}\left[
\begin{array}{c}k\\m\end{array} \right](-1)^{n-k}x^m\\\)</span>.</p>
<p>由于这对任意<span class="math inline">\(x\)</span>都成立,因此右边除了<span class="math inline">\(x^n\)</span>以外的项系数均为<span class="math inline">\(0\)</span>,而<span class="math inline">\(x^n\)</span>的系数为<span class="math inline">\(1\)</span>.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(\left\{
\begin{array}{c}n+1\\m+1\end{array} \right\}=\sum_{k=m}^n\left(
\begin{array}{c}n\\k\end{array} \right)\left\{
\begin{array}{c}k\\m\end{array} \right\}\\\)</span>.</p></li>
<li><p><span class="math inline">\(\left[
\begin{array}{c}n+1\\m+1\end{array} \right]=\sum_{k=m}^n\left(
\begin{array}{c}n\\k\end{array} \right)\left[
\begin{array}{c}k\\m\end{array} \right]\\\)</span>.</p></li>
</ol>
<p>证明:对于前者,考虑组合意义,将<span class="math inline">\(n+1\)</span>个分为<span class="math inline">\(m+1\)</span>组,也就是先找一部分分成<span class="math inline">\(m\)</span>组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3>
<ol start="7" type="1">
<li><p><span class="math inline">\(\left\{
\begin{array}{c}n\\m\end{array} \right\}=\sum_{k=m}^n\left(
\begin{array}{c}n\\k\end{array} \right)\left\{
\begin{array}{c}k+1\\m+1\end{array}
\right\}(-1)^{n-k}\\\)</span>.</p></li>
<li><p><span class="math inline">\(\left[
\begin{array}{c}n\\m\end{array} \right]=\sum_{k=m}^n\left(
\begin{array}{c}n\\k\end{array} \right)\left[
\begin{array}{c}k+1\\m+1\end{array}
\right](-1)^{n-k}\\\)</span>.</p></li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol start="9" type="1">
<li><span class="math inline">\(m!\left\{
\begin{array}{c}n\\m\end{array}
\right\}=\sum_{k=0}^mC_m^kk^n(-1)^{m-k}\\\)</span>.</li>
</ol>
<p>证明:首先有<span class="math inline">\(m^n=\sum_{k=0}^mm^{\underline{k}}\left\{
\begin{array}{c}m\\k\end{array} \right\}=\sum_{k=0}^mk!C_m^k\left\{
\begin{array}{c}m\\k\end{array}
\right\}\\\)</span>,对这个式子进行二项式反演即可.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\left\{
\begin{array}{c}n+1\\m+1\end{array} \right\}=\sum_{k=0}^n\left\{
\begin{array}{c}k\\m\end{array} \right\}(m+1)^{n-k}\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前<span class="math inline">\(k\)</span>个分为<span class="math inline">\(m\)</span>组,把第<span class="math inline">\(k+1\)</span>个数放到第<span class="math inline">\(m+1\)</span>组.然后剩下<span class="math inline">\((n+1)-(k+1)=n-k\)</span>个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第<span class="math inline">\(m+1\)</span>组(最小值最大的那组)在<span class="math inline">\(k\)</span>不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol start="11" type="1">
<li><span class="math inline">\(\left[\begin{array}{c}n+1\\m+1\end{array}
\right]=\sum_{k=0}^n\left[ \begin{array}{c}k\\m\end{array}
\right]C_{n}^k(n-k)!=n!\sum_{k=0}^n\frac{\left[
\begin{array}{c}k\\m\end{array} \right]}{k!}\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果<span class="math inline">\(n&gt;0\)</span>,我们有<span class="math inline">\(\left[ \begin{array}{c}n\\1\end{array}
\right]=(n-1)!\\\)</span>.这个式子很显然,我们现在有一个长度为<span class="math inline">\(n-1\)</span>的环,想要往里插入第<span class="math inline">\(n\)</span>个数有<span class="math inline">\(n-1\)</span>种选择,所以我们有:<span class="math inline">\(\left[ \begin{array}{c}n\\1\end{array}
\right]=\left[ \begin{array}{c}n-1\\1\end{array}
\right](n-1)\\\)</span>,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将<span class="math inline">\(n+1\)</span>个数划分成<span class="math inline">\(m+1\)</span>个环,我们先将其中<span class="math inline">\(k\)</span>个数划分成<span class="math inline">\(m\)</span>个环,剩下<span class="math inline">\(n+1-k\)</span>个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第<span class="math inline">\(n+1\)</span>个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于<span class="math inline">\(C_n^k(n-k)!=C_n^{n-k}(n-k)!=n^{\underline{n-k}}=\frac{n!}{k!}\\\)</span>.因此后半部分也得证.</p>
<ol start="12" type="1">
<li><p><span class="math inline">\(\left\{
\begin{array}{c}n+m+1\\m\end{array} \right\}=\sum_{k=0}^mk\left\{
\begin{array}{c}n+k\\k\end{array} \right\}\\\)</span>.</p></li>
<li><p><span class="math inline">\(\left[
\begin{array}{c}n+m+1\\m\end{array} \right]\sum_{k=0}^m(n+k)\left[
\begin{array}{c}n+k\\k\end{array} \right]\\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将<span class="math inline">\(n+k\)</span>个位置分到<span class="math inline">\(k\)</span>个集合之后.还剩下<span class="math inline">\((n+m+1)-(n+k)=(m-k+1)\)</span>个数,剩下<span class="math inline">\((m-k)\)</span>个集合.</p>
<p>拿出来<span class="math inline">\((n+k+1)\)</span>这个数,剩下的数刚好够每个集合放一个.最后枚举一下把<span class="math inline">\((n+k+1)\)</span>放在哪里即可.由于每个划分一定存在一段(可能是<span class="math inline">\(0\)</span>)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol start="14" type="1">
<li><span class="math inline">\(C_n^m(n-1)^{\underline{n-m}}=\sum_{k=m}^n\left[
\begin{array}{c}n\\k\end{array} \right]\left\{
\begin{array}{c}k\\m\end{array} \right\}\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑<span class="math inline">\((n-1)^{\underline{n-m}}=\frac{(n-1)!}{(m-1)!}\\\)</span>,不妨设<span class="math inline">\(f(n,m)=\sum_{k=m}^n\left[
\begin{array}{c}n\\k\end{array} \right]\left\{
\begin{array}{c}k\\m\end{array} \right\}\\\)</span>,相当于将<span class="math inline">\(n\)</span>个数分成非空<span class="math inline">\(m\)</span>组,然后组内的数要形成若干轮换的方案数.那么知道<span class="math inline">\(f(n,m)=f(n-1,m-1)+(n-1+m)f(n-1,m)\\\)</span>.</p>
<p>设<span class="math inline">\(g(n,m)=C_n^m\frac{(n-1)!}{(m-1)!}=\frac{n!(n-1)!}{m!(n-m)!(m-1)!}\\\)</span>,那么知道:
<span class="math display">\[
g(n-1,m-1)=\frac{(n-1)!(n-2)!}{(m-1)!(n-m)!(m-2)!}\\
g(n-1,m)=\frac{(n-1)!(n-2)!}{m!(n-1-m)!(m-2)!}\\
\]</span> 显然<span class="math inline">\(g(n,m)=g(n-1,m-1)+(n-1+m)g(n-1,m)\\\)</span>,数学归纳即可.</p>
<ol start="15" type="1">
<li><p><span class="math inline">\(C_n^m=\frac{n!}{m!(n-m)!}=\sum_{k=m}^n\left\{
\begin{array}{c}n+1\\k+1\end{array} \right\}\left[
\begin{array}{c}k\\m\end{array} \right](-1)^{m-k}\\\)</span>.</p></li>
<li><p><span class="math inline">\(n^{\underline{n-m}}=\frac{n!}{m!}=\sum_{k=m}^n\left[
\begin{array}{c}n+1\\k+1\end{array} \right]\left\{
\begin{array}{c}k\\m\end{array} \right\}(-1)^{m-k}，其中m\leq
n\\\)</span>.</p></li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol start="17" type="1">
<li><p><span class="math inline">\(\left\{
\begin{array}{c}n\\l+m\end{array} \right\}C_{l+m}^l=\sum_{k=l}^n\left\{
\begin{array}{c}k\\l\end{array} \right\}\left\{
\begin{array}{c}n-k\\m\end{array} \right\}C_n^k\\\)</span>.</p></li>
<li><p><span class="math inline">\(\left[
\begin{array}{c}n\\l+m\end{array} \right]C_{l+m}^l=\sum_{k=l}^n\left[
\begin{array}{c}k\\l\end{array} \right]\left[
\begin{array}{c}n-k\\m\end{array} \right]C_n^k\\\)</span>.</p></li>
</ol>
<p>证明:先考虑前者,左边即先将<span class="math inline">\(n\)</span>个数分为<span class="math inline">\(l+m\)</span>个集合,然后再挑出<span class="math inline">\(l\)</span>个集合.那不妨枚举这<span class="math inline">\(l\)</span>个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2>
<p>记<span class="math inline">\(\left\langle\begin{array}\\n\\k\end{array}\right\rangle\)</span>表示<span class="math inline">\(\{1,2,...,n\}\)</span>的排列<span class="math inline">\(a\)</span>中满足这条性质的排列个数:存在且只存在<span class="math inline">\(k\)</span>个升高,换句话说,存在且只存在<span class="math inline">\(k\)</span>个<span class="math inline">\(i\)</span>,满足<span class="math inline">\(1\leq
i&lt;n\)</span>,<span class="math inline">\(a_i&lt;a_{i+1}\)</span>.不难发现<span class="math inline">\(\left\langle\begin{array}\\n\\k\end{array}\right\rangle=\left\langle\begin{array}\\n\\n-k-1\end{array}\right\rangle\)</span>.</p>
<p>考虑在一个<span class="math inline">\(\{1,2,...,n-1\}\)</span>的排列中插入<span class="math inline">\(n\)</span>,设插入的位置是原本<span class="math inline">\(a_i\)</span>的后面,那么要么原本<span class="math inline">\(a_i&lt;a_{i+1}\)</span>,要么反之.前者不会改变排列的升高的数量,后者则会增加<span class="math inline">\(1\)</span>.另外还有一种情况是插入到了序列最前面.于是我们自然得到:<span class="math inline">\(\left\langle\begin{array}\\n\\k\end{array}\right\rangle=(k+1)\left\langle\begin{array}\\n-1\\k\end{array}\right\rangle+(n-k)\left\langle\begin{array}\\n-1\\k-1\end{array}\right\rangle\)</span>.</p>
<p>特别地,我们令<span class="math inline">\(\left\langle\begin{array}\\0\\k\end{array}\right\rangle=[k=0]\)</span>,若<span class="math inline">\(k&lt;0\)</span>,则<span class="math inline">\(\left\langle\begin{array}\\n\\k\end{array}\right\rangle=0\)</span>.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3>
<p>我们有Worpitzky恒等式: <span class="math display">\[
x^n=\sum_{k\geq
0}\binom{x+k}{n}\left\langle\begin{array}\\n\\k\end{array}\right\rangle,n\in\mathbb{N}
\]</span> 还有另一个恒等式: <span class="math display">\[
\left\langle\begin{array}\\n\\m\end{array}\right\rangle=\sum_{k=0}^m\binom{n+1}{k}(m+1-k)^n(-1)^k
\]</span> 剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2>
<p>定义<span class="math inline">\(B_j\)</span>为第<span class="math inline">\(j\)</span>个伯努利数,且满足<span class="math inline">\(\sum_{j=0}^m\binom{m+1}{j}B_j=[m=0],m\geq
0\\\)</span>.</p>
<p>定义<span class="math inline">\(S_m(n)=\sum_{i=0}^{n-1}i^m\)</span>.</p>
<p>伯努利数满足公式:<span class="math inline">\(S_m(n)=\cfrac{1}{m+1}\sum_{k=0}^m\binom{m+1}{k}B_kn^{m+1-k}\\\)</span>.</p>
<p>证明如下:</p>
<p>对<span class="math inline">\(S_{m+1}(n)\)</span>使用扰动法,我们有:
<span class="math display">\[
S_{m+1}(n)+n^{m+1}=\sum_{k=0}^{n-1}(k+1)^{m+1}\\
=\sum_{k=0}^{n-1}\sum_{j=0}^{m+1}\binom{m+1}{j}k^j\\
=\sum_{j=0}^{m+1}\binom{m+1}{j}S_j(n)\\
=\sum_{j=0}^{m}\binom{m+1}{j}S_j(n)+S_{m+1}(n)\\
n^{m+1}=\sum_{j=0}^m\binom{m+1}{j}S_j(n)\\
\]</span> 接下来使用数学归纳,假设<span class="math inline">\(0\leq
j&lt;m\)</span>时该公式成立,并假设有<span class="math inline">\(S_m(n)=\cfrac{1}{m+1}\sum_{k=0}^m\binom{m+1}{k}B_kn^{m+1-k}+\Delta\\\)</span>,我们只需要证明<span class="math inline">\(\Delta=0\)</span>. <span class="math display">\[
n^{m+1}=\sum_{j=0}^m\binom{m+1}{j}\cfrac{1}{j+1}\sum_{k=0}^j\binom{j+1}{k}B_kn^{j+1-k}+(m+1)\Delta\\
=\sum_{0\leq k\leq j\leq
m}\binom{j+1}{k}\binom{m+1}{j}\cfrac{1}{j+1}B_kn^{j+1-k}+(m+1)\Delta\\
=\sum_{0\leq k\leq j\leq
m}\binom{j+1}{j-k}\binom{m+1}{j}\cfrac{1}{j+1}B_{j-k}n^{k+1}+(m+1)\Delta\\
=\sum_{0\leq k\leq j\leq
m}\binom{j+1}{k+1}\binom{m+1}{j}\cfrac{1}{j+1}B_{j-k}n^{k+1}+(m+1)\Delta\\
=\sum_{0\leq k\leq
m}\cfrac{n^{k+1}}{k+1}\sum_{j=k}^mB_{j-k}\binom{m+1}{j}\binom{j}{k}+(m+1)\Delta\\
=\sum_{0\leq k\leq
m}\cfrac{n^{k+1}}{k+1}\binom{m+1}{k}\sum_{j=k}^mB_{j-k}\binom{m+1-k}{j-k}+(m+1)\Delta\\
=\sum_{k=0}^m\cfrac{n^{k+1}}{k+1}\binom{m+1}{k}\sum_{j=0}^{m-k}B_{j}\binom{m+1-k}{j}+(m+1)\Delta\\
=\sum_{k=0}^m\cfrac{n^{k+1}}{k+1}\binom{m+1}{k}[m-k=0]+(m+1)\Delta\\
=n^{m+1}+(m+1)\Delta
\]</span> 显然<span class="math inline">\(\Delta=0\)</span>,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2>
<p>定义斐波那契数<span class="math inline">\(F_n=\begin{cases}0&amp;n=0\\1&amp;n=1\\F_{n-1}+F_{n-2}&amp;n&gt;1\end{cases}\)</span>.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3>
<p>首先根据数学归纳,不难证明卡西尼恒等式: <span class="math display">\[
F_{n+1}F_{n-1}-F_n^2=(-1)^n,n&gt;0
\]</span> 事实上,如果我们将斐波那契数的递推式改写作:<span class="math inline">\(F_n=F_{n+2}-F_{n+1}\)</span>,我们可以在<span class="math inline">\(n\in\mathbb{Z}\)</span>的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:
<span class="math display">\[
F_{-n}=(-1)^{n-1}F_n,n\in\mathbb{Z}
\]</span></p>
<h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3>
<p>如果我们考虑不断使用斐波那契递推式展开,不难发现: <span class="math display">\[
F_{n+k}=F_kF_{n+1}+F_{k-1}F_n\\
F_{n+m+1}=F_{n+1}F_{m+1}+F_nF_m
\]</span> 另外,如果我们在上面这个式子中取<span class="math inline">\(k=wn,w\in\mathbb{N}\)</span>并使用归纳法,我们又可以得到一个性质:<span class="math inline">\(F_{kn}\)</span>是<span class="math inline">\(F_n\)</span>的倍数,<span class="math inline">\(k\in\mathbb{Z}\)</span>.</p>
<p>再观察这个式子,使用归纳法可以证明<span class="math inline">\(\gcd(F_{n},F_{n-1})=1\)</span>,进一步有:<span class="math inline">\(\gcd(F_{n+m},F_m)=\gcd(F_n,F_m)\)</span>.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质: <span class="math display">\[
\gcd(F_m,F_n)=F_{\gcd(n,m)}
\]</span> 如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理: <span class="math display">\[
F_n^2|F_m\Leftrightarrow nF_n|m,n&gt;2
\]</span> 这个引理的证明如下:</p>
<p>由于<span class="math inline">\(F_{n+1}\equiv F_{n-1}\pmod
{F_n}\)</span>.于是我们有:<span class="math inline">\(F_{2n}=F_nF_{n+1}+F_{n-1}F_n\)</span>,也就是<span class="math inline">\(F_{2n}\equiv 2F_nF_{n+1}\pmod
{F_n^2}\)</span>.</p>
<p>另外我们有:<span class="math inline">\(F_{2n+1}\equiv
F_{n+1}^2\pmod{F_n^2}\)</span>.</p>
<p>同理,使用归纳法可以证明:<span class="math inline">\(F_{kn}\equiv
kF_nF_{n+1}^{k-1}\pmod{F_n^2},F_{kn+1}\equiv
F_{n+1}^k\pmod{F_n^2}\)</span>.</p>
<p>而<span class="math inline">\(F_{n+1}\bot F_n\)</span>,于是<span class="math inline">\(F_{kn}\equiv 0\pmod {F_n^2}\Leftrightarrow k\equiv
0\pmod {F_n},n&gt;2\)</span>.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3>
<p>我们如果定义<span class="math inline">\(j\gg k\Leftrightarrow j\geq
k+2\)</span>,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:<span class="math inline">\(n=\sum_{i=1}^rF_{k_i},\forall 1\leq i&lt; r,k_i\gg
k_{i+1}\gg 0\)</span>.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果<span class="math inline">\(\exist k\)</span>满足<span class="math inline">\(F_k=n\)</span>,则显然成立,不然,应<span class="math inline">\(\exist k\)</span>满足<span class="math inline">\(F_k&lt;n&lt;F_{k+1}\)</span>,而<span class="math inline">\(n-F_k\)</span>的表示已经存在了.另外,由于<span class="math inline">\(n-F_k&lt;F_{k+1}-F_k=F_{k-1}\)</span>,因此必定不可能出现选了<span class="math inline">\(F_k\)</span>又选了<span class="math inline">\(F_{k-1}\)</span>的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择<span class="math inline">\(F_k\)</span>而是选择<span class="math inline">\(F_{k-1}\)</span>,那么显然接下来无论怎么选,它们的加和都不可能大于等于<span class="math inline">\(F_k\)</span>,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数<span class="math inline">\(n\)</span>以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3>
<p>使用生成函数,令<span class="math inline">\(F(z)=\sum_{k\geq
0}F_kz^k\)</span>.那么不难发现<span class="math inline">\(F(z)-zF(z)-z^2F(z)=z\)</span>,也就是<span class="math inline">\(F(z)=\cfrac{z}{1-z-z^2}\)</span>.</p>
<p>考虑这个形式一定可以分解为<span class="math inline">\(F(z)=\cfrac{a}{1-\alpha z}+\cfrac{b}{1-\beta
z}\)</span>的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令<span class="math inline">\(\phi=\cfrac{1+\sqrt
5}{2},\hat\phi=\cfrac{1-\sqrt 5}{2}\)</span>,那么可以得到<span class="math inline">\(F_n=\cfrac{1}{\sqrt
5}(\phi^n-\hat\phi^n)\)</span>.</p>
<p>另外,由于<span class="math inline">\(\hat\phi^n\)</span>的影响很小,于是又有<span class="math inline">\(F_n=\lfloor\cfrac{\phi^n}{\sqrt
5}+0.5\rfloor\)</span>.</p>
<h3><span id="连项式">连项式</span></h3>
<p>连项式多项式<span class="math inline">\(K_n(x_1,x_2,...,x_n)\)</span>定义为:<span class="math inline">\(K_n(x_1,x_2,...,x_n)=\begin{cases}1&amp;n=0\\x_1&amp;n=1\\x_nK_{n-1}(x_1,x_2,...x_{n-1})+K_{n-2}(x_1,x_2,...,x_{n-2})&amp;n\geq
2\end{cases}\)</span>.</p>
<p>通过定义不难发现:<span class="math inline">\(K_n(1,1,...,1)=F_{n+1}\)</span>.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数<span class="math inline">\((x_{n-1},x_n)\)</span>.我们考虑用这样一种形式的字符串来表示最后某一项的情况:‘.’为还没有消除掉的项,长度为<span class="math inline">\(1\)</span>;’-‘为已经消除了的两项,长度为<span class="math inline">\(2\)</span>.那么<span class="math inline">\(K_n(x_1,x_2,...,x_n)\)</span>就可以表示为一个长度为<span class="math inline">\(n\)</span>的字符串,其中若有<span class="math inline">\(k\)</span>个’-‘,有<span class="math inline">\(n-2k\)</span>个’.’,则有<span class="math inline">\(\binom{n-k}{k}\)</span>种不同的排列方式.</p>
<p>于是我们有: <span class="math display">\[
K_n(z,z,...,z)=\sum_{k=0}^n\binom{n-k}{k}z^{n-2k}\\
\]</span> 另外,这也导出:<span class="math inline">\(F_{n+1}=\sum_{k=0}^n\binom{n-k}{k}\\\)</span>.</p>
<p>考虑上面的构造过程,不难发现<span class="math inline">\(K_n(x_1,x_2,...,x_n)=K_n(x_n,x_{n-1},...,x_1)\)</span>.</p>
<p>于是递归式可以写成:<span class="math inline">\(K_n(x_1,x_2,...,x_n)=x_1K_{n-1}(x_2,x_3,...x_{n})+K_{n-2}(x_3,x_4,...,x_{n})\)</span>.</p>
<p>进一步地,不断展开后得到: <span class="math display">\[
K_{m+n}(x_1,...,x_m,x_{m+1},...,x_{n+m})=\\K_m(x_1,...,x_m)K_n(x_{m+1},...,x_{n+m})+K_{m-1}(x_1,...,x_{m-1})K_{n-1}(x_{m+2},...,x_{n+m})
\]</span> 另外,根据连项式的定义,不难导出<span class="math inline">\(K_n(x_1,...,x_n+y)=K_n(x_1,...,x_n)+K_{n-1}(x_1,...,x_{n-1})y\)</span>.</p>
<p>由这个公式可以推出:<span class="math inline">\(\cfrac{K_{n+1}(a_0,...,a_n)}{K_n(a_1,...,a_n)}=\cfrac{K_n(a_0,...,a_{n-1}+\cfrac{1}{a_n})}{K_{n-1}(a_1,...,a_{n-1}+\cfrac{1}{a_n})}\)</span>.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系: <span class="math display">\[
\cfrac{K_{n+1}(a_0,...,a_n)}{K_n(a_1,...,a_n)}=a_0+\cfrac{1}{a_1+\cfrac{1}{a_2+\cfrac{1}{a_3+...}}}
\]</span> 另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>递归式与和式</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#汉诺塔问题">汉诺塔问题</a>
<ul>
<li><a href="#example1具体数学12">Example1(《具体数学》1.2)</a></li>
<li><a href="#solution-1">Solution 1</a></li>
<li><a href="#example2具体数学14">Example2(《具体数学》1.4)</a></li>
<li><a href="#solution-2">Solution 2</a></li>
<li><a href="#example3具体数学110">Example3(《具体数学》1.10)</a></li>
<li><a href="#solution-3">Solution 3</a></li>
<li><a href="#example4具体数学111">Example4(《具体数学》1.11)</a></li>
<li><a href="#solution-4">Solution 4</a></li>
<li><a href="#example5具体数学112">Example5(《具体数学》1.12)</a></li>
<li><a href="#solution-5">Solution 5</a></li>
</ul></li>
<li><a href="#递归式的封闭形式">递归式的封闭形式</a>
<ul>
<li><a href="#寻找循环节">寻找循环节</a>
<ul>
<li><a href="#example具体数学18">Example(《具体数学》1.8)</a></li>
<li><a href="#solution">Solution</a></li>
</ul></li>
<li><a href="#数学归纳法">数学归纳法</a>
<ul>
<li><a href="#example具体数学19">Example(《具体数学》1.9)</a></li>
<li><a href="#solution-1">Solution</a></li>
</ul></li>
<li><a href="#换元">换元</a></li>
<li><a href="#转化和式">转化和式</a>
<ul>
<li><a href="#example1快速排序时间复杂度">Example1(快速排序时间复杂度)</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#成套方法">成套方法</a></li>
<li><a href="#线性递推">线性递推</a>
<ul>
<li><a href="#特征方程">特征方程</a></li>
<li><a href="#二阶线性齐次递推">二阶线性齐次递推</a></li>
<li><a href="#更一般的情况">更一般的情况</a>
<ul>
<li><a href="#再再进一步">再再进一步</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#约瑟夫问题">约瑟夫问题</a>
<ul>
<li><a href="#example具体数学115">Example(《具体数学》1.15)</a></li>
<li><a href="#solution-2">Solution</a></li>
</ul></li>
<li><a href="#和式">和式</a>
<ul>
<li><a href="#和式的基本运算">和式的基本运算</a></li>
<li><a href="#和式的封闭形式">和式的封闭形式</a>
<ul>
<li><a href="#交换顺序法">交换顺序法</a>
<ul>
<li><a href="#example1等差数列求和">Example1(等差数列求和)</a></li>
<li><a href="#example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</a></li>
<li><a href="#example3拉格朗日恒等式">Example3(拉格朗日恒等式)</a></li>
</ul></li>
<li><a href="#扰动法">扰动法</a>
<ul>
<li><a href="#example1等比数列求和">Example1(等比数列求和)</a></li>
<li><a href="#example2平方和公式">Example2(平方和公式)</a></li>
<li><a href="#example3具体数学220">Example3(《具体数学》2.20)</a></li>
<li><a href="#solution3">Solution3</a></li>
<li><a href="#example4具体数学221">Example4(《具体数学》2.21)</a></li>
<li><a href="#solution-4-1">Solution 4</a></li>
</ul></li>
<li><a href="#转化为递归式">转化为递归式</a>
<ul>
<li><a href="#example1具体数学213">Example1(《具体数学》2.13)</a></li>
<li><a href="#solution1">Solution1</a></li>
</ul></li>
<li><a href="#转化为积分形式">转化为积分形式</a>
<ul>
<li><a href="#example1平方和公式">Example1(平方和公式)</a></li>
<li><a href="#example2某浙江高考题">Example2(某浙江高考题)</a></li>
</ul></li>
<li><a href="#展开和收缩">展开和收缩</a>
<ul>
<li><a href="#example1平方和公式-1">Example1(平方和公式)</a></li>
<li><a href="#example2具体数学214">Example2(《具体数学》2.14)</a></li>
<li><a href="#solution-2-1">Solution 2</a></li>
<li><a href="#example3具体数学215">Example3(《具体数学》2.15)</a></li>
<li><a href="#solution-3-1">Solution 3</a></li>
<li><a href="#exampleex">ExampleEX</a></li>
<li><a href="#solutionex">SolutionEX</a></li>
<li><a href="#exampleex2">ExampleEX2</a></li>
<li><a href="#solutionex2">SolutionEX2</a></li>
</ul></li>
<li><a href="#有限微积分">有限微积分</a>
<ul>
<li><a href="#移位算子">移位算子</a></li>
<li><a href="#差分算子">差分算子</a></li>
<li><a href="#逆差分算子">逆差分算子</a></li>
<li><a href="#定和式">定和式</a></li>
<li><a href="#一些基本的公式">一些基本的公式</a></li>
<li><a href="#高阶差分">高阶差分</a>
<ul>
<li><a href="#exampleyloi2020灼">Example([yLOI2020]灼)</a></li>
</ul></li>
<li><a href="#牛顿级数">牛顿级数</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#分部求和法则abel求和法">分部求和法则(Abel求和法)</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3>
<p>三个柱子,<span class="math inline">\(n\)</span>个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令<span class="math inline">\(T_n\)</span>表示答案,显然<span class="math inline">\(T_0=0,T_1=1\)</span>.</p>
<p>而我们一定可以找到一种方案,使得前<span class="math inline">\(n-1\)</span>个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把<span class="math inline">\(n-1\)</span>个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:<span class="math inline">\(T_n\leq 2T_{n-1}+1\)</span>.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:<span class="math inline">\(2T_{n-1}+1\leq T_n\)</span>.于是有<span class="math inline">\(T_n=2T_{n-1}+1\)</span>.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4>
<p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4>
<p>考虑设$ T_n<span class="math inline">\(为n个圆盘时的最小操作次数.假设已知\)</span>T_{n-1}$,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:<span class="math inline">\(T_{n}=3T_{n-1}+2,T_0=0\)</span>.</p>
<p>考虑如何求该式子的封闭形式,令<span class="math inline">\(W_n=T_n+1\)</span>,显然有<span class="math inline">\(W_n=3W_{n-1},W_0=1\)</span>,显然<span class="math inline">\(W_n=3^n\)</span>,有<span class="math inline">\(T_n=3^n-1\)</span>.</p>
<p>注意到<span class="math inline">\(T_n\)</span>刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4>
<p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于<span class="math inline">\(2^n-1\)</span>.</p>
<h4><span id="solution-2">Solution 2</span></h4>
<p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4>
<p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4>
<p>令<span class="math inline">\(Q_n\)</span>为将n个圆盘从A移动到B的最小操作次数,令<span class="math inline">\(R_n\)</span>为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,<span class="math inline">\(Q_0=0,R_0=0\)</span>.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此<span class="math inline">\(Q_n\)</span>的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,<span class="math inline">\(R_n\)</span>的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有<span class="math inline">\(Q_n=2R_{n-1}+1,1\leq
n\)</span>.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有<span class="math inline">\(R_n=R_{n-1}+1+Q_{n-1}+1+R_{n-1}=Q_n+Q_{n-1}+1,1\leq
n\)</span>.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4>
<p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4>
<p>a.仍然令<span class="math inline">\(T_n\)</span>为n对圆盘的最小操作次数,显然<span class="math inline">\(T_n=2T_{n-1}+2,T_0=0\)</span>,可解得<span class="math inline">\(T_n=2^{n+1}-2\)</span>.</p>
<p>b.令<span class="math inline">\(Q_n\)</span>为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现<span class="math inline">\(Q_n=T_{n-1}+1+T_{n-1}+1+T_{n-1}+1+T_{n-1}=4T_{n-1}+3=2^{n+2}-5\)</span>.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的<span class="math inline">\(Q_n\)</span>就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4>
<p>类似Problem11,但第<span class="math inline">\(i\)</span>大的圆盘有<span class="math inline">\(k_i\)</span>个.</p>
<h4><span id="solution-5">Solution 5</span></h4>
<p>无区别,只是<span class="math inline">\(T_n=2T_{n-1}+k_n,T_0=0\)</span>.</p>
<p>如果求封闭形式的话,显然有<span class="math inline">\(T_n=\sum_{i=1}^n2^{n-i}k_i\)</span>.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3>
<p>在上述问题中，我们已经有了以下式子：</p>
<p><span class="math inline">\(T_n=2T_{n-1}+1,n&gt;0,T_0=0\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出<span class="math inline">\(T_n\)</span>的方法.</p>
<p>换句话说，我们想要把<span class="math inline">\(T_n\)</span>表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4>
<h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5>
<p>解递归式:<span class="math inline">\(Q_n=\begin{cases}\alpha&amp;n=0\\\beta&amp;n=1\\\frac{(1+Q_{n-1})}
{Q_{n-2}}&amp;n&gt;1\end{cases}\)</span>,保证<span class="math inline">\(\forall n,Q_n&gt;0\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>注意到<span class="math inline">\(Q_2=\frac{\beta+1}{\alpha},Q_3=\frac{\beta+\alpha+1}{\beta\alpha},Q_4=\frac{1+\alpha}{\beta},Q_5=\alpha,Q_6=\beta\)</span>.</p>
<p>显然该递归式存在长度为<span class="math inline">\(5\)</span>的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4>
<p>观察T序列的前几项，可以发现似乎有<span class="math inline">\(T_n=2^n-1\)</span>.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于<span class="math inline">\(n=0\)</span>成立，显然可验证.</p>
<p>2.若该公式对<span class="math inline">\(n=k\)</span>时成立，那该公式必然对<span class="math inline">\(n=k+1\)</span>成立.</p>
<p>因为有<span class="math inline">\(T_{k+1}=2T_k+1=2\times
2^k+2-1=2^{k+1}-1\)</span>.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5>
<p>求证:<span class="math inline">\(\prod_{i=1}^nx_i\leq
(\frac{\sum_{i=1}^nx_i}{n})^n,\forall i\in N_+,1\leq i\leq n,0\leq
x_i\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>使用反向归纳法.</p>
<p>1.<span class="math inline">\(n=2\)</span>时,即基本不等式,显然成立.</p>
<p>2.若该式子对<span class="math inline">\(n=k\)</span>时成立,则该式子对n=2k时也成立.</p>
<p>不妨令<span class="math inline">\(A_1=\sqrt[k]{\prod _{i=1}^k
x_i},B_1=\sqrt[k]{\prod
_{i=k+1}^{2k}x_i},A_2=(\frac{\sum_{i=1}^kx_i}{k}),B_2=(\frac{\sum_{i=k+1}^{2k}x_i}k)\)</span>,显然有<span class="math inline">\(A_1\leq A_2,B_1\leq B_2\)</span>.</p>
<p>同时有<span class="math inline">\((\frac{A_2+B_2}{2})\geq
\sqrt{A_2B_2}\geq \sqrt{A_1B_1}\)</span>.</p>
<p>3.若该式子对<span class="math inline">\(n=k\)</span>时成立,则该式子对<span class="math inline">\(n=k-1\)</span>的时候也成立.</p>
<p>令<span class="math inline">\(x_k=\frac{\sum_{i=1}^{k-1}x_i}{k-1}\)</span>,有<span class="math inline">\(x_k\prod_{i=1}^{k-1}x_i\leq (x_k)^k\)</span>.</p>
<p>则显然<span class="math inline">\(n=k-1\)</span>时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4>
<p>考虑令<span class="math inline">\(U_n=T_n+1\)</span>,显然有:<span class="math inline">\(T_n+1=2T_{n-1}+2\)</span>.即<span class="math inline">\(U_n=2U_{n-1}\)</span>,显然<span class="math inline">\(U_n=2^n\)</span>,则<span class="math inline">\(T_n=2^n-1\)</span>.</p>
<p>这个做法可以做掉所有形如<span class="math inline">\(a_{n+1}=pa_n+q\)</span>的递归式.我们有: <span class="math display">\[
a_{n+1}+\frac{q}{p-1}=p(a_n+\frac{q}{p-1})
\]</span> 换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4>
<p>考虑递归式<span class="math inline">\(a_nT_n=b_nT_{n-1}+c_n\)</span>.如果我们能找到一个不为0的求和因子<span class="math inline">\(s_n\)</span>并满足<span class="math inline">\(s_nb_n=s_{n-1}a_{n-1}\)</span>.那么我们两面同时乘以<span class="math inline">\(s_n\)</span>,显然有：<span class="math inline">\(s_na_nT_n=s_{n-1}a_{n-1}T_{n-1}+c_ns_n\)</span>.</p>
<p>令<span class="math inline">\(S_n=s_na_nT_n\)</span>.显然有<span class="math inline">\(S_n=s_0a_0T_0+\sum_{i=1}^ns_ic_i\)</span>,则<span class="math inline">\(T_n=\frac{S_n}{s_na_n}\)</span>.</p>
<p>而我们也会发现<span class="math inline">\(s_n=\frac{\prod_{i=1}^{n-1}a_i}{\prod_{i=1}^nb_i}\)</span>.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5>
<p>结论:排序<span class="math inline">\(n\)</span>个数时,其期望复杂度满足: <span class="math display">\[
C_n=\begin{cases}0&amp;n=0,1\\n+1+\frac{2}{n}\sum_{i=0}^{n-1}C_k&amp;n&gt;1\end{cases}
\]</span> 不妨考虑两边同时乘以<span class="math inline">\(n\)</span>,有
$ nC_n=n^2+n+2_{i=0}^{n-1}C_i,n&gt;1 $ .</p>
<p>显然也有<span class="math inline">\((n-1)C_{n-1}=(n-1)^2+n-1+2\sum_{i=0}^{n-2}C_i,n&gt;2\)</span>.</p>
<p>二式相消,有<span class="math inline">\(nC_n-(n-1)C_{n-1}=2n+2C_{n-1},n&gt;2\)</span>.</p>
<p>而同时有<span class="math inline">\(C_2=3\)</span>.即:<span class="math inline">\(nC_n=(n+1)C_{n-1}+2n,n&gt;2\)</span>,可以使用转化和式的方法,两边乘以<span class="math inline">\(\frac{1}{n(n+1)}\)</span>解决.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知<span class="math inline">\(a_1=1\)</span>,<span class="math inline">\(a_n=\sqrt{S_n}+\sqrt{S_{n-1}}\)</span>,求<span class="math inline">\(a_n\)</span>.</p>
<p>注意到<span class="math inline">\(a_n=S_n-S_{n-1}\)</span>,则有<span class="math inline">\(\sqrt{S_n}-\sqrt{S_{n-1}}=1\)</span>,于是<span class="math inline">\(\sqrt{S_n}=n\)</span>,<span class="math inline">\(S_n=n^2\)</span>,<span class="math inline">\(a_n=2n-1\)</span>.</p>
<h4><span id="成套方法">成套方法</span></h4>
<p>如果我们有 <span class="math inline">\(f(n)=\begin{cases}
\alpha &amp; n=1\\
2f(\frac n 2)+\beta &amp; n=2k,k\in \mathbb{N_+}\\
2f(\frac {n-1}2)+\gamma &amp;n=2k+1,k\in \mathbb{N_+}
\end{cases}\)</span></p>
<p>其中<span class="math inline">\(n=2^m+l\)</span>且<span class="math inline">\(2^m\leq n&lt;2^{m+1}\)</span>.</p>
<p>该如何求出<span class="math inline">\(f(n)\)</span>的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有<span class="math inline">\(f(n)=A(n)\alpha+B(n)\beta+C(n)\gamma\)</span>,而有<span class="math inline">\(A、B、C\)</span>互不影响且<span class="math inline">\(\alpha\beta\gamma\)</span>与<span class="math inline">\(ABC\)</span>无关.</p>
<p>那无论<span class="math inline">\(\beta\)</span>和<span class="math inline">\(\gamma\)</span>的取值如何,<span class="math inline">\(A(n)\)</span>都不会受到影响,我们考虑<span class="math inline">\(\beta=\gamma=0\)</span>的特殊情况,此时显然有<span class="math inline">\(A(n)=2^m\)</span>.</p>
<p>接下来,我们考虑取<span class="math inline">\(\alpha\beta\gamma\)</span>的特殊值,去得到ABC之间的关系.</p>
<p>例如，当<span class="math inline">\(f(n)=1\)</span>时，由递推式可知<span class="math inline">\(\alpha=1,\beta=\gamma=-1\)</span>,那么有<span class="math inline">\(A(n)-B(n)-C(n)=f(n)=1\)</span>.</p>
<p>同理，<span class="math inline">\(f(n)=n\)</span>时，可知<span class="math inline">\(\alpha=1,\beta=0,\gamma=1\)</span>,此时有<span class="math inline">\(A(n)+C(n)=f(n)=n\)</span>.</p>
<p>显然可以通过解方程求得<span class="math inline">\(B(n)\)</span>和<span class="math inline">\(C(n)\)</span>.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明<span class="math inline">\(ABC\)</span>互不影响且<span class="math inline">\(\alpha\beta\gamma\)</span>与<span class="math inline">\(ABC\)</span>无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4>
<p>一个常系数的<span class="math inline">\(k\)</span>阶线性递推关系形如:
<span class="math display">\[
a_n=P_n+\sum_{i=1}^kc_ia_{n-i},n\geq k\\
a_0=C_0,a_1=C_1,...,a_{k-1}=C_{k-1}
\]</span></p>
<p>当<span class="math inline">\(P=0\)</span>时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程<span class="math inline">\(r^k=\sum_{i=1}^kc_ir^{k-i}\)</span>是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根<span class="math inline">\(r_1\)</span>和<span class="math inline">\(r_2\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n=\alpha_1r_1^n+\alpha_2r_2^n\)</span>.</p>
<p>若其特征方程有两个相同的根<span class="math inline">\(r\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n=\alpha_1r^n+\alpha_2nr^n\)</span>.</p>
<p>先考虑前者的证明,首先考虑对于<span class="math inline">\(n=0\)</span>或者<span class="math inline">\(n=1\)</span>的情况,我们考虑求出一组<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>来满足: <span class="math display">\[
C_0=\alpha_1+\alpha_2\\
C_1=\alpha_1r_1+\alpha_2r_2
\]</span> 若<span class="math inline">\(r_1\ne r_2\)</span>,可以解得:
<span class="math display">\[
\alpha_1=\cfrac{C_1-C_0r_2}{r_1-r_2}\\
\alpha_2=C_0-\alpha_1
\]</span> 接下来考虑数学归纳: <span class="math display">\[
a_n=c_1a_{n-1}+c_2a_{n-2}\\
=c_1(\alpha_1r_1^{n-1}+\alpha_2r_2^{n-1})+c_2(\alpha_1r_1^{n-2}+\alpha_2r_2^{n-2})\\
=\alpha_1(c_1r_1^{n-1}+c_2r_1^{n-2})+\alpha_2(c_1r_2^{n-1}+c_2r_2^{n-2})\\
=\alpha_1r_1^n+\alpha_2r_2^n
\]</span> 接下来考虑后者,首先我们有<span class="math inline">\(\Delta=c_1^2+4c_2=0\)</span>,考虑初始条件: <span class="math display">\[
C_0=\alpha_1\\
C_1=\alpha_1r+\alpha_2r\\
\]</span> 接下来我们考虑数学归纳: <span class="math display">\[
a_n=c_1a_{n-1}+c_2a_{n-2}\\
=c_1(\alpha_1r^{n-1}+\alpha_2nr^{n-1}-\alpha_2r^{n-1})+c_2(\alpha_1r^{n-2}+\alpha_2nr^{n-2}-2\alpha_2r^{n-2})\\
=a_n-c_1\alpha_2r^{n-1}-2c_2\alpha_2r^{n-2}
\]</span> 我们接下来只需证明<span class="math inline">\(c_1r+2c_2=0\)</span>即可.根据方程,不难发现<span class="math inline">\(r=\cfrac{c_1}{2}\)</span>,根据<span class="math inline">\(\Delta=0\)</span>,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>直接在复数域上定义<span class="math inline">\(f_k(x)=\{n^kx^n\}_{n=0}^\infty\)</span>,此时我们规定<span class="math inline">\(0^0=1\)</span>.特别地,当<span class="math inline">\(x=0\)</span>的时候,定义<span class="math inline">\(f_k(x)\)</span>的第<span class="math inline">\(k\)</span>项是<span class="math inline">\(1\)</span>,其余项是<span class="math inline">\(0\)</span>.在此基础上定义线性映射<span class="math inline">\(T:(a_n)_{n=0}^\infty\mapsto
(a_{n+1})_{n=0}^\infty\)</span>,立刻见到:<span class="math inline">\((T-x)^{k+1}f_k(x)=0,(T-x)^kf_k(x)\ne
0\)</span>.原因只需简单数学归纳.而此还可以引出<span class="math inline">\(f_0(x),f_1(x),\cdots\)</span>线性无关.</p>
<p>在此基础上观察线性递推<span class="math inline">\(a_{n+d}=c_{d-1}a_{n+d-1}+\cdots+c_0a_n\)</span>,不妨取<span class="math inline">\(G(x)=x^d-c_{d-1}x^{d-1}-\cdots-c_0\)</span>,立刻应当见到如果<span class="math inline">\(a\)</span>是<span class="math inline">\(G\)</span>的根并且重数为<span class="math inline">\(e(a)\)</span>,那么<span class="math inline">\(f_{0}(x),\cdots,f_{e(a)-1}(a)\)</span>都在<span class="math inline">\(\ker
f(T)\)</span>中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如<span class="math inline">\(\sum_j w_if_i(y)=\sum_j
w_jf_j(x)\)</span>的情况,此时对右边直接操作若干次<span class="math inline">\((T-x)\)</span>就可以把右边全部消成<span class="math inline">\(0\)</span>,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于<span class="math inline">\(n\)</span>的多项式右边的<span class="math inline">\((T-x)\)</span>是不会改变左边这边的每一个位置多项式的<span class="math inline">\(\deg\)</span>,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是<span class="math inline">\(\vec
x_{k+1}=A\vec x\)</span>,<span class="math inline">\(\vec x_{n}=A^n\vec
x_0\)</span>.而我们又知道CH定理:<span class="math inline">\(p(A)=0\)</span>,我们用多项式取膜,有<span class="math inline">\(A^n=p(A)F(A)+G(A)=G(A)\)</span>,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3>
<p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是<span class="math inline">\(2,4,6,8,10,3,7,1,9\)</span>.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有<span class="math inline">\(J(2n)=2J(n)-1\)</span>;当人数是奇数时,我们杀掉一号,然后有<span class="math inline">\(J(2n+1)=2J(n)+1\)</span>.</p>
<p>整理得到: <span class="math display">\[
J(n)=\begin{cases}
1 &amp; n=1\\
2J(\frac n 2)-1 &amp; n=2k,k\in \mathbb{N_+}\\
2J(\frac {n-1}2)+1 &amp;n=2k+1,k\in \mathbb{N_+}
\end{cases}
\]</span> 仍然可以使用数学归纳，如果令<span class="math inline">\(n=2^m+l且2^m\leq n&lt;2^{m+1}\)</span>. 有<span class="math inline">\(J(n)=2l+1\)</span>.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从<span class="math inline">\(0\)</span>开始编号: <span class="math display">\[
J(n)=\begin{cases}
0 &amp; n=1\\
2J(\frac n 2) &amp; n=2k,k\in \mathbb{N_+}\\
2J(\frac {n-1}2)+2 &amp;n=2k+1,k\in \mathbb{N_+}
\end{cases}
\]</span> 这下相信<span class="math inline">\(J(n)\)</span>是多少就很显然了,将<span class="math inline">\(n\)</span>写成二进制的形式,这个就相当于把首位<span class="math inline">\(1\)</span>抹去然后在末尾加个<span class="math inline">\(0\)</span>.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4>
<p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4>
<p>显然有: <span class="math display">\[
J(n)=\begin{cases}
2 &amp; n=2\\
1&amp;n=3\\
2J(\frac n 2)-1 &amp; n=2k+2,k\in \mathbb{N_+}\\
2J(\frac {n-1}2)+1 &amp;n=2k+3,k\in \mathbb{N_+}
\end{cases}
\]</span> 从<span class="math inline">\(0\)</span>开始编号,自然有: <span class="math display">\[
J(n)=\begin{cases}
1 &amp; n=2\\
0&amp;n=3\\
2J(\frac n 2) &amp; n=2k+2,k\in \mathbb{N_+}\\
2J(\frac {n-1}2)+2 &amp;n=2k+3,k\in \mathbb{N_+}
\end{cases}
\]</span> 显然<span class="math inline">\(J(n)\)</span>也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2>
<h3><span id="和式的基本运算">和式的基本运算</span></h3>
<p>分配律: <span class="math display">\[
\sum_{i\in S}ca_i=c\sum_{i\in S}a_i
\]</span> 一般分配律: <span class="math display">\[
\sum_{i}\sum_{j}a_{i}b_j=(\sum_{i}a_i)(\sum_jb_j)
\]</span> 结合律: <span class="math display">\[
\sum_{i\in S}(a_i+b_i)=\sum_{i\in S}a_i+\sum_{i\in S}b_i
\]</span> 交换律: <span class="math display">\[
\sum_{i\in S}a_i=\sum_{p(i)\in S}a_{p(i)}
\]</span> 交换求和顺序:</p>
<p><span class="math display">\[
\sum_{i}\sum_{j}a_{i,j}[P(i,j)]=\sum_{j}\sum_{i}a_{i,j}[P(i,j)]\\
\sum_{i=1}^n\sum_{j=i}^na_{i,j}=\sum_{j=1}^n\sum_{i=1}^ja_{i,j}
\]</span></p>
<h3><span id="和式的封闭形式">和式的封闭形式</span></h3>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5>
<p>我们有: <span class="math display">\[
S_n=\sum_{i=0}^n(ai+b)=\sum_{i=0}^n(a(n-i)+b)\\
2S_n=\sum_{i=0}^n(an+2b)=an(n+1)+2b(n+1)\\
S_n=(n+1)(\frac{an}{2}+b)
\]</span></p>
<h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5>
<p>令<span class="math inline">\(S=\sum_{1\leq i&lt;j\leq
n}(a_j-a_i)(b_j-b_i)=\sum_{1\leq j&lt;i\leq
n}(a_j-a_i)(b_j-b_i)\)</span>.</p>
<p>考虑恒等式<span class="math inline">\([1\leq j&lt;i\leq n]+[1\leq
i&lt;j\leq n]=[1\leq j,i\leq n]-[1\leq i=j\leq n]\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
2S=\sum_{1\leq i,j\leq n}(a_j-a_i)(b_j-b_i)-\sum_{1\leq i=j\leq
n}(a_j-a_i)(b_j-b_i)\\=\sum_{1\leq i,j\leq n}(a_j-a_i)(b_j-b_i)\\
=2n\sum_{i=1}^na_ib_i-2(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\\
(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)=n\sum_{i=1}^na_ib_i-\sum_{1\leq
i&lt;j\leq n}(a_j-a_i)(b_j-b_i)
\]</span> 显然有以下式子:</p>
<p><span class="math inline">\((\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\leq
n\sum_{i=1}^na_ib_i，\forall i&lt;j，a_i\leq a_j且b_i\leq b_j\\
(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\geq n\sum_{i=1}^na_ib_i，\forall
i&lt;j，a_i\leq a_j且b_i\geq b_j\\\)</span></p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5>
<p>证明: <span class="math display">\[
\sum_{1\leq j&lt;k\leq
n}(a_jb_k-a_kb_j)^2=(\sum_{i=1}^na_i^2)(\sum_{i=1}^nb_i^2)-(\sum_{i=1}^na_ib_i)^2\\
\]</span> 有: <span class="math display">\[
S_n=\sum_{1\leq j&lt;k\leq n}(a_jb_k-a_kb_j)^2\\
2S_n=\sum_{j=1}^n\sum_{k=1}^n(a_jb_k-a_kb_j)^2\\
=\sum_{j=1}^n\sum_{k=1}^n(a_j^2b_k^2-2a_ja_kb_jb_k+a_k^2b_j^2)\\
=2(\sum_{i=1}^na_i^2)(\sum_{i=1}^nb_i^2)-2(\sum_{i=1}^na_ib_i)^2
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5>
<p><span class="math display">\[
S_n=\sum_{i=0}^nax^i\\=a+\sum_{i=1}^nax^i\\=a+x\sum_{i=0}^{n-1}ax^i\\=a+xS_{n-1}
\]</span></p>
<p>而<span class="math inline">\(S_{n-1}+ax^n=S_n=a+xS_{n-1}\)</span>,有<span class="math inline">\(S_n+ax^{n+1}=a+xS_n,S_n=a\frac{x^{n+1}-1}{x-1}\)</span>，其中<span class="math inline">\(x\ne1\)</span>.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
S_n=\sum_{i=0}^ni^2=\sum_{i=0}^{n-1}i^2+n^2\\=\sum_{i=1}^n(i-1)^2+n^2\\=S_n-2\sum_{i=1}^ni+n+n^2
\]</span> 我们无法得到<span class="math inline">\(S_n\)</span>的封闭形式,但我们发现我们得到了<span class="math inline">\(\sum_{i=1}^ni\)</span>的封闭形式.</p>
<p>那以此类推,我们设<span class="math inline">\(W_n=\sum_{i=0}i^3\)</span>.</p>
<p><span class="math display">\[
W_n=\sum_{i=0}^{n-1}i^3+n^3\\=\sum_{i=1}^n(i-1)^3+n^3\\=\sum_{i=1}^ni^3-3\sum_{i=1}^ni^2+3\sum_{i=1}^ni-n+n^3\\=W_n-3S_n+3\frac{n+n^2}2-n+n^3\\
S_n=\frac{n+n^2}2-\frac{n-n^3}3\\=\frac{n+3n^2+2n^3}6\\=\frac{n(1+3n+2n^2)}{6}\\=\frac{n(2n+1)(n+1)}{6}
\]</span></p>
<h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5>
<p>令<span class="math inline">\(H_n=\sum_{k=1}^n\frac{1}{k}\)</span>,求<span class="math inline">\(\sum_{i=0}^nH_i\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>不妨考虑<span class="math inline">\(\sum_{i=0}^niH_{i}\)</span>的值.</p>
<p><span class="math display">\[
\sum_{i=0}^niH_{i}=\sum_{i=1}^n[(i-1+1)H_{i-1}+1]\\=n+\sum_{i=0}^{n-1}H_i+\sum_{i=0}^{n}iH_i-nH_n\\
\sum_{i=0}^{n-1}H_i=n(H_n-1)\\
\sum_{i=0}^nH_i=(n+1)(H_{n+1}-1)\\
\]</span></p>
<h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5>
<p>求<span class="math inline">\(S_n=\sum_{i=0}^n(-1)^{n-i},T_n=\sum_{i=0}^n(-1)^{n-i}i,U_n=\sum_{i=0}^n(-1)^{n-i}i^2\)</span>.</p>
<h5><span id="solution-4">Solution 4</span></h5>
<p><span class="math display">\[
S_n=\sum_{i=1}^{n}(-1)^{n-i}+(-1)^n\\-S_{n-1}+1=(-1)^n+\sum_{i=0}^{n-1}(-1)^{n-1-i}\\-S_{n-1}+1=(-1)^n+S_{n-1}\\S_{n-1}=\frac{1-(-1)^n}{2}\\S_n=\frac{1+(-1)^n}{2}
\]</span></p>
<p><span class="math display">\[
T_{n}=\sum_{i=1}^n(-1)^{n-i}i\\-T_{n-1}+n=\sum_{i=1}^n(-1)^{n-i}(i-1)+\sum_{i=1}^n(-1)^{n-i}\\-T_{n-1}+n=\sum_{i=0}^{n-1}(-1)^{n-i-1}i+\sum_{i=0}^n(-1)^{n-i}-(-1)^n\\-T_{n-1}+n=T_{n-1}+S_n-(-1)^n\\n-\frac{1-(-1)^n}2=2T_{n-1}\\T_n=\frac{1}{2}(n+1+\frac{-1-(-1)^n}2)=\frac{1}{2}(n+\frac{1-(-1)^n}2)
\]</span></p>
<p><span class="math display">\[
U_n=\sum_{i=1}^n(-1)^{n-i}i^2\\-U_{n-1}+n^2=\sum_{i=1}^n(-1)^{n-i}(i-1+1)^2\\-U_{n-1}+n^2=\sum_{i=1}^n(-1)^{n-i}(i-1)^2+2\sum_{i=1}^n(-1)^{n-i}(i-1)+\sum_{i=1}^n(-1)^{n-i}\\-U_{n-1}+n^2=\sum_{i=0}^{n-1}(-1)^{n-i-1}i^2+2\sum_{i=0}^{n-1}(-1)^{n-i-1}i+\sum_{i=0}^{n-1}(-1)^{n-i-1}\\-U_{n-1}+n^2=U_{n-1}+2T_{n-1}+S_{n-1}\\2U_{n-1}=n^2-2T_{n-1}-S_{n-1}\\2U_{n-1}=n^2-(n-\frac{1-(-1)^n}2)-\frac{1-(-1)^n}{2}\\2U_{n-1}=n^2-n\\U_n=\frac{n(n+1)}{2}
\]</span></p>
<h4><span id="转化为递归式">转化为递归式</span></h4>
<p>考虑和式<span class="math inline">\(S_n=\sum_{i=0}^nf(i)=S_{n-1}+f(n)\\\)</span>，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5>
<p>求<span class="math inline">\(\sum_{i=0}^n(-1)^ii^2\\\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>令<span class="math inline">\(S(n)=\sum_{i=0}^n(-1)^ii^2=S(n-1)+(-1)^nn^2\)</span>,考虑使用成套方法.</p>
<p>不妨令<span class="math inline">\(S(n)=S(n-1)+(-1)^n(\alpha+\beta
n+\gamma n^2)=\alpha A(n)+\beta B(n)+\gamma C(n)\)</span>.</p>
<p>令<span class="math inline">\(S(n)=(-1)^nn,可以解得\alpha=-1,\beta=2,\gamma=0\)</span>,有<span class="math inline">\((-1)^nn=-A(n)+2B(n)\)</span>.</p>
<p>令<span class="math inline">\(S(n)=(-1)^nn^2,可以解得\alpha=1,\beta=-2,\gamma=2\)</span>,有<span class="math inline">\((-1)^nn^2=A(n)-2B(n)+2C(n)\)</span>.</p>
<p>显然可解得<span class="math inline">\(2C(n)=(-1)^nn^2+(-1)^nn,C(n)=(-1)^n\frac{n(n+1)}{2}\)</span>.</p>
<p>而原式中,<span class="math inline">\(S(n)=C(n)=(-1)^n\frac{n(n+1)}{2}\)</span>.</p>
<p>#####Example2(《具体数学》2.19)</p>
<p>有<span class="math inline">\(2T_n=nT_{n-1}+3n!,T_0=5\)</span>,求<span class="math inline">\(T_n\)</span>.</p>
<p>#####Solution 2</p>
<p>令<span class="math inline">\(s_n=\frac{2^{n-1}}{n!}\)</span>,两边同时乘以<span class="math inline">\(s_n\)</span>,有<span class="math inline">\(\frac{2^n}{n!}T_n=\frac{2^{n-1}}{(n-1)!}T_{n-1}+3\times
2^{n-1}\\\)</span>.</p>
<p>令<span class="math inline">\(S_n=\frac{2^n}{n!}T_n\)</span>,有:</p>
<p><span class="math display">\[
S_n=S_{n-1}+3\times 2^{n-1}\\=5+3\sum_{i=0}^{n-1}2^i\\=5+3\times
2^{n+1}-3\\=3\times 2^{n}+2\\T_n=3n!+\frac{n!}{2^{n-1}}
\]</span></p>
<h4><span id="转化为积分形式">转化为积分形式</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数<span class="math inline">\(f(x)=x^2\)</span>,显然<span class="math inline">\(\int_0^nx^2dx=\frac{n^3}{3}\sim
S_n\\\)</span>.</p>
<p>接下来,我们考虑求得二者之间的误差,设<span class="math inline">\(E_n=S_n-\frac{n^3}{3}\\\)</span>,对其使用扰动法:</p>
<p><span class="math display">\[
E_n=S_n-\frac{n^3}3\\=S_{n-1}+n^2-\frac{(n-1+1)^3}{3}
\\=S_{n-1}+n^2-\frac{(n-1)^3}3-(n-1)^2-(n-1)-\frac 1 3
\\=E_{n-1}+n^2-n^2+2n-1-n+1-\frac 1 3\\=E_{n-1}+n-\frac{1}3
\]</span> 这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是: <span class="math display">\[
E_n=S_n-\int_0^nx^2dx\\=\sum_{k=1}^n(k^2-\int_{k-1}^kx^2dx)
\\=\sum_{k=1}^n(k^2-\frac{k^3-(k-1)^3}{3})\\=\sum_{k=1}^n(k-\frac1 3)
\]</span> 这是一个简单的和式.而<span class="math inline">\(S_n=E_n+\frac{n^3}3\\\)</span>,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5>
<p>已知<span class="math inline">\(a_1=1,a_{n+1}-a_n=-\frac{1}{3}a_n^2\)</span>,估计<span class="math inline">\(a_n\)</span>的值.</p>
<p>考虑构造一个函数<span class="math inline">\(f(n)\)</span>使得<span class="math inline">\(f(n)\approx a_n\)</span>,那我们就可以将<span class="math inline">\(a_{n+1}-a_n\approx f_n\)</span>.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,<span class="math inline">\(\exists
x_0\in[n,n+1],f&#39;(x_0)=f(n+1)-f(n)\)</span>,而对于增长率变化不大的函数,直接认为<span class="math inline">\(f&#39;(x_0)=f&#39;(n)\)</span>是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入<span class="math inline">\(f(1)=1\)</span>解得<span class="math inline">\(f(n)=\frac{3}{n+2}\)</span>.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令<span class="math inline">\(a_n=\frac{3}{n+2}-b_n\)</span>,带入化简,得到<span class="math inline">\(\{b_n\}\)</span>的递推式:</p>
<p><span class="math display">\[
\frac{3}{n+3}-b_{n+1}=(\frac{3}{n+2}-b_n)(1-\frac{1}{n+2}+\frac{b_n}{3})\\
b_{n+1}-\frac{3}{n+3}=(b_n-\frac{3}{n+2})(\frac{n+1}{n+2}+\frac{b_n}{3})\\b_1=0,b_{n+1}=\frac{b_n^2}{3}+\frac{n}{n+2}b_n+\frac{3}{(n+2)^2(n+3)}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出<span class="math inline">\(b_n\leq
\frac{1}{4n}\)</span>,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个<span class="math inline">\(b_n\)</span>的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设<span class="math inline">\(b_n^2&lt;&lt;b_n\)</span>:</p>
<p>那么这个<span class="math inline">\(b_n\)</span>是<span class="math inline">\(O(\frac{\ln n}{n^2})\)</span>级别的.</p>
<p>如何理解这个级别?考虑别乱动<span class="math inline">\(b_n\)</span>的系数,我们有:</p>
<p><span class="math display">\[
b_{n+1}=\frac{n}{n+2}b_n+\frac{1}{n(n+1)(n+2)}\\
(n+1)(n+2)b_{n+1}=n(n+1)b_n+\frac{1}{n}\\
g(n)=n(n+1)b_n,g&#39;(n)=\frac{1}{n},g(n)=\ln n\\
b_n=\frac{\ln n}{n^2}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把<span class="math inline">\(O(n^{\epsilon})\)</span>和<span class="math inline">\(O(1)\)</span>搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现<span class="math inline">\(b_n\leq
\frac{3\ln n}{n(n+1)}\)</span>.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>我们有: <span class="math display">\[
S_n=\sum_{k=1}^nk^2\\=\sum_{k=1}^n\sum_{i=1}^kk
\\=\sum_{i=1}^n\sum_{k=i}^nk\\=\sum_{i=1}^n\frac 1
2(i+n)(n-i+1)\\=\sum_{i=1}^n\frac{1}2(in-i^2+i+n^2-ni+n)\\
=\frac{1}2(\sum_{i=1}^ni-\sum_{i=1}^ni^2+n^3+n^2)\\=\frac{1}4n(n+1)-\frac1
2S_n+\frac{n^3+n^2}2
\]</span></p>
<p>整理得到<span class="math inline">\(S_n\)</span>.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5>
<p>求<span class="math inline">\(\sum_{i=1}^ni2^i\\\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p><span class="math display">\[
\sum_{i=1}^ni2^i=\sum_{i=1}^n\sum_{j=1}^i2^i\\=\sum_{j=1}^n\sum_{i=j}^n2^i\\=\sum_{j=1}^n(2^{n+1}-2^j)\\=n2^{n+1}-(2^{n+1}-2)\\=(n-1)2^{n+1}+2
\]</span></p>
<h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5>
<p>求<span class="math inline">\(\sum_{i=1}^n i^3\\\)</span>.</p>
<h5><span id="solution-3">Solution 3</span></h5>
<p><span class="math display">\[
S(n)=\sum_{i=1}^n
i^3\\=\sum_{i=1}^n\sum_{j=1}^ii^2\\=\sum_{j=1}^n\sum_{i=j}^ni^2\\=\sum_{j=1}^n(\frac{n(n+1)(2n+1)}{6}-\frac{(j-1)j(2j-1)}{6})\\=\frac{n^2(n+1)(2n+1)}{6}-\frac
1 3
S(n)+\frac{n(n+1)(2n+1)}{12}-\frac{n(n+1)}{12}\\S(n)=\frac{n^2(n+1)^2}{4}
\]</span></p>
<h5><span id="exampleex">ExampleEX</span></h5>
<p>求<span class="math inline">\(\sum_{i=1}^niq^i(q\ne 1)\)</span>.</p>
<h5><span id="solutionex">SolutionEX</span></h5>
<p><span class="math display">\[
\sum_{i=1}^niq^i=\sum_{j=1}^n\sum_{i=j}^nq^i\\
=\sum_{j=1}^n\frac{q^j-q^{n+1}}{1-q}\\
=\frac{1}{q-1}\sum_{j=1}^n(q^{n+1}-q^j)\\
=\frac{1}{q-1}(nq^{n+1}-\frac{q^{n+1}-q}{q-1})\\
\]</span></p>
<h5><span id="exampleex2">ExampleEX2</span></h5>
<p>求<span class="math inline">\(\sum_{i=1}^n(ai+b)q^{i-1}(q\ne
1)\)</span>.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令<span class="math inline">\(A=\frac{a}{q-1},B=\frac{b-A}{q-1}\)</span>,答案为<span class="math inline">\((An+B)q^n-B\)</span>.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子<span class="math inline">\(E\)</span>，使得<span class="math inline">\(Ef(x)=f(x+1)\)</span>.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子<span class="math inline">\(\Delta
f(x)=f(x+1)-f(x)\)</span>，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有<span class="math inline">\(\Delta=E-1\)</span>.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子<span class="math inline">\(\Sigma\)</span>,可以得到有限微积分的基本定理:</p>
<p><span class="math display">\[
g(x)=\Delta f(x)\Leftrightarrow \sum g(x)\delta x=f(x)+C\\
\]</span> 这里的<span class="math inline">\(\Sigma\)</span>又被称为不定和式,是差分等于<span class="math inline">\(g\)</span>的一个函数类.</p>
<p>值得一提的是,这里的<span class="math inline">\(C\)</span>与无限微积分中的<span class="math inline">\(C\)</span>有一定区别,这里的<span class="math inline">\(C\)</span>可以是满足<span class="math inline">\(p(x)=p(x+1)\)</span>的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果<span class="math inline">\(g(x)=\Delta f(x)\)</span>,那么有<span class="math inline">\(\sum\nolimits_{a}^b g(x)\delta
x=f(x)|^{b}_a=f(b)-f(a)\\\)</span>.</p>
<p>值得一提的是,如果<span class="math inline">\(a\leq
b\)</span>,显然有<span class="math inline">\(\sum\nolimits_{a}^bg(x)\delta
x=\sum_{x=a}^{b-1}g(x)\\\)</span>.</p>
<p>但如果<span class="math inline">\(a&gt;b\)</span>,那么<span class="math inline">\(\sum\nolimits_{a}^bg(x)\delta x=-\sum\nolimits_b^a
g(x)\delta x\\\)</span>.</p>
<p>事实上,我们一定有:<span class="math inline">\(\sum\nolimits_a^bg(x)\delta
x+\sum\nolimits_b^cg(x)\delta x=\sum\nolimits_a^cg(x)\delta
x\\\)</span>.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的<span class="math inline">\(D(x^m)=mx^{m-1}\)</span>，有:</p>
<p><span class="math display">\[
\Delta(x^{\underline{m}})=mx^{\underline{m-1}}\\\sum
mx^{\underline{m-1}}\delta x=x^{\underline{m}}+C,m\ne 0\\
\\
\]</span> 类比无限微积分中的<span class="math inline">\(D(\ln x)=\frac 1
x\)</span>,有: <span class="math display">\[
\Delta(H(x))=x^{\underline{-1}}=\frac{1}{x+1}\\
\sum x^{\underline{-1}}\delta x =H(x)+C\\
\\
\]</span> 类比无限微积分中的<span class="math inline">\(D(e^x)=e^x\)</span>,有: <span class="math display">\[
\Delta(2^x)=2^x,\sum 2^x\delta x=2^x+C\\
\Delta (c^x)=(c-1)c^x,\sum c^x\delta x=\frac{c^x}{c-1}+C,c\ne 1\\
\Delta (c^{\underline{x}})=\frac{c^{\underline{x+2}}}{c-x},\sum
\frac{c^{\underline{x+2}}}{c-x}\delta x=c^{\underline{x}}+C,c-x\ne 0\\
\]</span> 根据组合数公式,有:</p>
<p><span class="math display">\[
\Delta(\binom{x}{k})=\binom{x}{k-1}\\\sum\binom{x}{k-1}\delta
x=\binom{x}{k}+C
\]</span></p>
<p>######Example(平方和公式)</p>
<p>我们有:<span class="math inline">\(k^2=k^{\underline{2}}+k^{\underline{1}}\\\)</span>.</p>
<p>那么:</p>
<p><span class="math display">\[
S_{n-1}=\sum_{i=0}^{n-1}i^2\\=\sum_{i=0}^{n-1}(i^{\underline{2}}+i^{\underline{1}})\\=\sum\nolimits_{0}^nx^{\underline2}\delta
x+\sum\nolimits_{0}^nx^{\underline 1}\delta
x\\=\frac{n^\underline{3}}{3}+\frac{n^{\underline{2}}}{2}
\]</span> 整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5>
<p>考虑一阶差分是<span class="math inline">\(\Delta
f(x)=f(x+1)-f(x)\)</span>,那么二阶差分就是<span class="math inline">\(\Delta^2f(x)=f(x+2)-2f(x+1)+f(x)\)</span>.</p>
<p>类似地,我们可以通过归纳法证明<span class="math inline">\(\Delta^nf(x)=\sum_{k}\binom{n}{k}(-1)^{n-k}f(x+k)\\\)</span>.</p>
<p>事实上有一种更简单的证明方法,由于<span class="math inline">\(\Delta=E-1\)</span>,于是<span class="math inline">\(\Delta^n=(E-1)^n=\sum_{k}\binom{n}{k}(-1)^{n-k}E^k\\\)</span>,由于<span class="math inline">\(E^kf(x)=f(x+k)\)</span>,即可证明原式.</p>
<p>另外,不难发现如果<span class="math inline">\(f(x)\)</span>是一个关于<span class="math inline">\(x\)</span>的<span class="math inline">\(d\)</span>次多项式,那么<span class="math inline">\(\Delta f(x)\)</span>是一个<span class="math inline">\(d-1\)</span>次多项式.同理,<span class="math inline">\(\Delta^d f(x)\)</span>会是一个常数而<span class="math inline">\(\Delta^{d+1}f(x)\)</span>会是<span class="math inline">\(0\)</span>,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6>
<p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为<span class="math inline">\(x_1,x_2\)</span>.</p>
<p>不难写出期望转移式子:<span class="math inline">\(f_i=\cfrac{1}{2}(f_{i-1}+f_{i+1})+1\)</span>,并且<span class="math inline">\(f_{x_1}=f_{x_2}=0\)</span>.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形: <span class="math display">\[
f_i=\cfrac{1}{2}(f_{i-1}+f_{i+1})+1\\
2f_i=f_{i-1}+f_{i+1}+2\\
f_i-f_{i-1}=f_{i+1}-f_i+2\\
\Delta f_{i-1}=\Delta f_{i}+2\\
\Delta f_i-\Delta f_{i-1}=-2\\
\Delta^2 f_{i-1}=-2
\]</span> <span class="math inline">\(f\)</span>的二阶差分是常数,也就是说<span class="math inline">\(f\)</span>是二次多项式,不难求得其二次项系数为<span class="math inline">\(-1\)</span>又知道两个零点,显然可以得到<span class="math inline">\(f\)</span>的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5>
<p>令<span class="math inline">\(f(x)=\sum_{0\leq i\leq
d}a_ix^i\\\)</span>.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为<span class="math inline">\(f(x)=\sum_{0\leq i\leq
d}b_ix^{\underline{i}}\\\)</span>.</p>
<p>我们设<span class="math inline">\(c_i=i!b_i\)</span>,于是有:<span class="math inline">\(f(x)=\sum_{0\leq i\leq
d}c_i\binom{x}{i}\\\)</span>.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为<span class="math inline">\(f(x)\)</span>的牛顿级数.</p>
<p>于是不难发现有:<span class="math inline">\(\Delta^nf(x)=\sum_{0\leq
i\leq d}c_i\binom{x}{i-n}\\\)</span>.如果我们令<span class="math inline">\(x=0\)</span>,则有:<span class="math inline">\(\Delta^nf(0)=\begin{cases}c_n&amp;n\leq
d\\0&amp;n&gt;d\end{cases}\)</span>.那么牛顿级数的另一种表示即:<span class="math inline">\(f(x)=\sum_{0\leq i\leq
d}\Delta^if(0)\binom{x}{d}\\\)</span>.</p>
<p>另外,如果我们展开一下<span class="math inline">\(c_n=\Delta^nf(0)\)</span>,我们可以得到公式:</p>
<p><span class="math inline">\(\sum_{k}\binom{n}{k}(-1)^k(\sum_{0\leq
i\leq n}c_i\binom{k}{i})=(-1)^nc_n,n\in\mathbb{N}\\\)</span>.</p>
<p>如果我们将多项式还原,由于<span class="math inline">\(a_n=b_n\)</span>,有:</p>
<p><span class="math inline">\(\sum_{k}\binom{n}{k}(-1)^k(\sum_{0\leq
i\leq n}a_ik^i)=(-1)^nn!a_n,n\in\mathbb{N}\\\)</span>.</p>
<p>另外,如果<span class="math inline">\(x\in\mathbb{N}\)</span>,那么我们有:<span class="math inline">\(f(x)=\sum_{0\leq
k}\Delta^kf(0)\binom{x}{0}\)</span>,根据多项式推理法,这个公式对<span class="math inline">\(\forall x\in\mathbb{Z}\)</span>都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数: <span class="math display">\[
g(a+x)=\sum_{0\leq k}\cfrac{\Delta^kg(a)}{k!}x^{\underline{k}}
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>求<span class="math inline">\(\sum_{k}\binom{n}{k}\binom{r-sk}{n}(-1)^k,n\in\mathbb{N}\\\)</span>.</p>
<p>如果我们令<span class="math inline">\(f(k)=\binom{r-sk}{n}=\sum_{0\leq i\leq
n}a_ik^i\\\)</span>,不难发现<span class="math inline">\(a_n=\cfrac{(-1)^ns^n}{n!}\)</span>,于是显然原式<span class="math inline">\(=s^n\)</span>.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
<p><span class="math display">\[
\Delta(uv)=u(x+1)v(x+1)-u(x)v(x)\\
=u(x+1)v(x+1)-u(x)v(x+1)+u(x)v(x+1)-u(x)v(x)\\
=v(x+1)\Delta u+u(x)\Delta v=Ev\Delta u+u\Delta v\\
\]</span></p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p><span class="math inline">\(\sum u\Delta v=uv-\sum Ev\Delta
u\\\)</span>.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math display">\[
\sum_{i=l}^{r-1}(a_{i+1}-a_i)b_i=a_rb_r-a_lb_l-\sum_{i=l}^{r-1}a_{i+1}(b_{i+1}-b_i)\\
\sum_{i=l}^{r-1}(\Delta
a_i)b_i=a_rb_r-a_lb_l-\sum_{i=l}^{r-1}a_{i+1}(\Delta b_i)
\]</span></p>
<p>对于<span class="math inline">\(l=0,r=n,a_0=b_0=0\)</span>的特殊情况,应当有: <span class="math display">\[
\sum_{i=0}^{n-1}(\Delta a_i)b_i=a_nb_n-\sum_{i=0}^{n-1}a_{i+1}(\Delta
b_i)\\
\sum_{i=1}^na_i(b_{i+1}-b_i)=a_nb_n-\sum_{i=0}^{n-1}(\Delta a_i)b_i
\]</span> 取两组数列<span class="math inline">\(\alpha,\beta\)</span>,并令<span class="math inline">\(\sum_{i=1}^n \beta_i=B_i\)</span>,立刻有: <span class="math display">\[
\sum_{i=1}^n
\alpha_i\beta_i=\alpha_nB_n-\sum_{i=1}^{n-1}(\alpha_{i+1}-\alpha_i)B_i
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{k=0}^nk2^k\\\)</span>.</p>
<p>根据分部求和法则，我们有:</p>
<p><span class="math inline">\(\sum x2^x\delta x=x2^x-\sum2^{x+1}\delta
x=x2^x-2^{x+1}+C\\\)</span>.</p>
<p>改为定和式形式，显然有:</p>
<p><span class="math inline">\(\sum_{k=0}^nk2^k=\sum\nolimits_0^{n+1}x2^x\delta
x=(n+1)2^{n+1}-2^{n+2}+2=(n-1)2^{n+1}+2\\\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{k=0}^{n-1}kH_k\\\)</span>.</p>
<p>令<span class="math inline">\(u(x)=H_x,v(x)=\frac 1
2x^{\underline{2}}\\\)</span>.</p>
<p>带入分部求和法则，显然有:</p>
<p><span class="math inline">\(\sum xH_x\delta
x=\frac{x^\underline{2}}2H_x-\frac{x^\underline{2}}4+C\\\)</span>.</p>
<p>带入即可求出原式<span class="math inline">\(=\frac{n^\underline{2}}2(H_n-\frac{1}2)\\\)</span>.</p>
<p>######Example3(《具体数学》2.23)</p>
<p>求<span class="math inline">\(\sum_{i=1}^n\frac{2i+1}{i(i+1)}\\\)</span>.</p>
<p>######Solution 3</p>
<p>令<span class="math inline">\(u=(2n+1),v=-\frac{1}{i}\)</span>,则<span class="math inline">\(\Delta u=2,\Delta v=\frac{1}{i(i+1)}\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\sum_{i=1}^n\frac{2i+1}{i(i+1)}=(2n+3)\times
(-\frac{1}{n+1})+3-\sum_{i=1}^n(-\frac{2}{i+1})\\=-\frac{2n+3}{n+1}+2H_n+\frac{n+3}{n+1}=2H_n-\frac{n}{n+1}
\]</span></p>
<p>######Problem 4(《具体数学》2.24)</p>
<p>求<span class="math inline">\(\sum_{i=0}^{n-1}\frac{H_k}{(k+1)(k+2)}\\\)</span>.</p>
<p>######Solution 4</p>
<p>令<span class="math inline">\(u=H_n,v=-\frac{1}{n+1},\Delta
u=\frac{1}{n+1},\Delta v=\frac{1}{(n+1)(n+2)}\\\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\sum_{i=0}^{n-1}\frac{H_k}{(k+1)(k+2)}=-\frac{H_n}{n+1}-\sum_{i=0}^{n-1}(-\frac{1}{(i+2)(i+1)})\\=-\frac{H_n}{n+1}+\sum_{i=0}^{n-1}(\frac{1}{i+1}-\frac{1}{i+2})\\=-\frac{H_n}{n+1}+H_n-(H_n-1+\frac{1}{n+1})\\=1-\frac{H_n+1}{n+1}
\]</span></p>
]]></content>
      <categories>
        <category>具体数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>被兔子创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%85%94%E5%AD%90%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>没想到这个系列博客都出到第三节了.</p>
<p>之所以起这么个名字,是因为下面要开搞的数列很像真理元素的<a href="https://www.bilibili.com/video/BV1B7411W7LB">这个视频</a>.但其实下面的操作和这个视频并没有什么关系.</p>
<p><del>而且其实理论上,这篇博客的名字应该叫《被qyc创飞了(1)》</del></p>
<p>前天,qyc给我发了一个<a href="https://www.luogu.com/article/5gal95wp">博客</a>,里面提供了一种非常厉害的估计数列的方法.我一看就觉得超级厉害啊,因为这个题我之前也做过然后被爆杀了,而竟然可以拿科技秒掉.</p>
<p>大概讲一下qyc的神仙操作:</p>
<p><span class="math inline">\(a_1=1,a_{n+1}-a_n=-\frac{1}{3}a_n^2\)</span></p>
<p>考虑构造一个函数<span class="math inline">\(f(n)\)</span>使得<span class="math inline">\(f(n)\approx a_n\)</span>,那我们就可以将<span class="math inline">\(a_{n+1}-a_n\approx f_n\)</span>.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,<span class="math inline">\(\exists
x_0\in[n,n+1],f&#39;(x_0)=f(n+1)-f(n)\)</span>,而对于增长率变化不大的函数,直接认为<span class="math inline">\(f&#39;(x_0)=f&#39;(n)\)</span>是有理可循的!</p>
<p><span class="citation" data-cites="Minuses在知乎上找到了这个东西的">@Minuses在知乎上找到了这个东西的</span><a href="https://zhuanlan.zhihu.com/p/342641401">系统理论</a>.<del>但是我没有看</del>.</p>
<p>然后,原式子就变成了一个微分方程了,带入<span class="math inline">\(f(1)=1\)</span>解得<span class="math inline">\(f(n)=\frac{3}{n+2}\)</span>.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>但是我不满意!具体数学上教过我们可以用数列估计误差项,那现在我们来考虑一下它的误差项吧!</p>
<p>令<span class="math inline">\(a_n=\frac{3}{n+2}-b_n\)</span>,带入化简,得到<span class="math inline">\(\{b_n\}\)</span>的递推式:</p>
<p><span class="math display">\[
\frac{3}{n+3}-b_{n+1}=(\frac{3}{n+2}-b_n)(1-\frac{1}{n+2}+\frac{b_n}{3})\\
b_{n+1}-\frac{3}{n+3}=(b_n-\frac{3}{n+2})(\frac{n+1}{n+2}+\frac{b_n}{3})\\b_1=0,b_{n+1}=\frac{b_n^2}{3}+\frac{n}{n+2}b_n+\frac{3}{(n+2)^2(n+3)}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出<span class="math inline">\(b_n\leq
\frac{1}{4n}\)</span>,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个<span class="math inline">\(b_n\)</span>的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设<span class="math inline">\(b_n^2&lt;&lt;b_n\)</span>:</p>
<p><span class="math inline">\(b_{n+1}=O(1)b_n+O(\frac{1}{n^3})\)</span>.</p>
<p>那么<span class="math inline">\(b_n\)</span>应该是<span class="math inline">\(O(\frac{1}{n^2})\)</span>级别的对吧!然后我就开始算,算了一晚上也没放出来一个式子,相当自闭.</p>
<p>晚上回家咨询了一下汪神wzm,得知了这个<span class="math inline">\(b_n\)</span>是<span class="math inline">\(O(\frac{\ln
n}{n^2})\)</span>级别的,这下白算一晚上了.</p>
<p>如何理解这个级别?考虑别乱动<span class="math inline">\(b_n\)</span>的系数,我们有:</p>
<p><span class="math display">\[
b_{n+1}=\frac{n}{n+2}b_n+\frac{1}{n(n+1)(n+2)}\\
(n+1)(n+2)b_{n+1}=n(n+1)b_n+\frac{1}{n}\\
g(n)=n(n+1)b_n,g&#39;(n)=\frac{1}{n},g(n)=\ln n\\
b_n=\frac{\ln n}{n^2}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把<span class="math inline">\(O(n^{\epsilon})\)</span>和<span class="math inline">\(O(1)\)</span>搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现<span class="math inline">\(b_n\leq
\frac{3\ln n}{n(n+1)}\)</span>.</p>
<p>但是如果你尝试带入数学归纳,会发现完全做不动.怎么办呢?</p>
<p>在这个问题被搞出来后两个周,我妈的一位同事给出了纯文化课的牛逼做法,下面来介绍一下这个做法并且终结此题:</p>
<p>首先换元,上面等价于下面这个数列放缩: <span class="math display">\[
a_1=\frac1 3,a_{n+1}=-a_n(a_n-1)
\]</span></p>
<p>观察形式,注意到<span class="math inline">\(a_n(a_n-1)\)</span>这个东西很像一个类似裂项的东西,因此两边取倒数,自然有:
<span class="math display">\[
\frac{1}{a_{n+1}}-\frac{1}{a_n}=\frac{1}{1-a_n}
\]</span></p>
<p>考虑<span class="math inline">\(0&lt;a_n\leq \frac 1
3\)</span>,于是我们有下面这个不等式:</p>
<p><span class="math display">\[
1&lt; \frac{1}{a_{n+1}}-\frac{1}{a_n}\leq \frac{3}{2}
\]</span></p>
<p>两边求和有: <span class="math display">\[
n\leq \frac{1}{a_{n+1}}-3\leq \frac{3}{2}n\\
\frac{2}{3(n+1)}\leq a_n\leq \frac{1}{n+2}
\]</span></p>
<p>仔细观察下面这个式子: <span class="math display">\[
\frac{1}{a_{n+1}}-\frac{1}{a_n}=\frac{1}{1-a_n}
\]</span> 我们上面的操作实质上是使用这个式子将<span class="math inline">\(0&lt;a_n\leq \frac 1
3\)</span>这个放缩给缩紧了,所以我们再用一次这个式子再紧一遍.</p>
<p><span class="math display">\[
\frac{1}{a_{n+1}}-\frac{1}{a_n}\leq
\frac{1}{1-\frac{1}{n+2}}=\frac{n+2}{n+1}=1+\frac{1}{n+1}\\
\]</span></p>
<p>两边求和自然有:</p>
<p><span class="math display">\[
\frac{1}{a_{n+1}}-3\leq n+\sum_{k=2}^{n+1}\frac{1}{k}\leq n+\ln (n+1)\\
a_n\geq \frac{1}{n+2+\ln n}
\]</span></p>
<p>这个界甚至比我们给出的界还要紧.而且似乎继续迭代可以得到更紧的解!相当牛逼!</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>数学分析</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#数学分析i">数学分析I</a>
<ul>
<li><a href="#实数">实数</a>
<ul>
<li><a href="#戴德金分割定理">戴德金分割定理</a></li>
<li><a href="#确界存在定理">确界存在定理</a>
<ul>
<li><a href="#example1">Example1</a></li>
</ul></li>
<li><a href="#阿基米德性质">阿基米德性质</a></li>
</ul></li>
<li><a href="#实数集上的一元函数">实数集上的一元函数</a>
<ul>
<li><a href="#性质">性质</a>
<ul>
<li><a href="#奇偶性">奇偶性</a></li>
<li><a href="#有界性">有界性</a></li>
<li><a href="#单调性">单调性</a></li>
<li><a href="#周期性">周期性</a></li>
</ul></li>
<li><a href="#基本初等函数">基本初等函数</a></li>
<li><a href="#初等函数">初等函数</a></li>
<li><a href="#代数函数">代数函数</a></li>
</ul></li>
<li><a href="#数列极限">数列极限</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#性质-1">性质</a></li>
<li><a href="#单调收敛准则">单调收敛准则</a></li>
<li><a href="#自然对数的底数">自然对数的底数</a></li>
<li><a href="#开区间与闭区间">开区间与闭区间</a></li>
<li><a href="#区间套定理">区间套定理</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#有限覆盖定理">有限覆盖定理</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
</ul></li>
<li><a href="#外测度与零测集">外测度与零测集</a></li>
<li><a href="#vitali覆盖引理">Vitali覆盖引理</a></li>
<li><a href="#聚点原理">聚点原理</a></li>
<li><a href="#baire纲定理">Baire纲定理</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
<li><a href="#致密性定理">致密性定理</a></li>
<li><a href="#柯西收敛准则">柯西收敛准则</a></li>
<li><a href="#上下极限">上下极限</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
</ul></li>
<li><a href="#stolz定理">Stolz定理</a></li>
</ul></li>
<li><a href="#实数的完备性基本定理">实数的完备性基本定理</a></li>
<li><a href="#函数极限">函数极限</a>
<ul>
<li><a href="#定义-1">定义</a>
<ul>
<li><a href="#单侧极限">单侧极限</a></li>
<li><a href="#双侧极限">双侧极限</a></li>
<li><a href="#自变量趋于无穷时的极限">自变量趋于无穷时的极限</a></li>
</ul></li>
<li><a href="#上下极限-1">上下极限</a></li>
<li><a href="#第一可数公理">第一可数公理</a></li>
<li><a href="#无穷大量和无穷小量">无穷大量和无穷小量</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
</ul></li>
<li><a href="#连续函数">连续函数</a>
<ul>
<li><a href="#一致连续">一致连续</a></li>
<li><a href="#李氏连续">李氏连续</a></li>
</ul></li>
<li><a href="#闭区间下的连续函数">闭区间下的连续函数</a>
<ul>
<li><a href="#介值定理零点存在定理">介值定理(零点存在定理)</a>
<ul>
<li><a href="#example1-6">Example1</a></li>
</ul></li>
<li><a href="#有界定理">有界定理</a></li>
<li><a href="#最值定理">最值定理</a></li>
<li><a href="#康托尔定理">康托尔定理</a></li>
</ul></li>
<li><a href="#不动点和周期点">不动点和周期点</a>
<ul>
<li><a href="#压缩映照原理">压缩映照原理</a></li>
<li><a href="#李-约克定理">李-约克定理</a>
<ul>
<li><a href="#引理一">引理一</a></li>
<li><a href="#引理二">引理二</a></li>
<li><a href="#引理三">引理三</a></li>
<li><a href="#李-约克定理-1">李-约克定理</a></li>
</ul></li>
<li><a href="#sharkovskii定理">Sharkovskii定理</a>
<ul>
<li><a href="#引理">引理</a></li>
<li><a href="#sharkovskii定理">sharkovskii定理</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#导数">导数</a>
<ul>
<li><a href="#导数基本运算">导数基本运算</a></li>
<li><a href="#反函数的导数">反函数的导数</a></li>
<li><a href="#隐函数求导">隐函数求导</a>
<ul>
<li><a href="#example1-7">Example1</a></li>
</ul></li>
<li><a href="#参数方程的求导">参数方程的求导</a>
<ul>
<li><a href="#example1-8">Example1</a></li>
</ul></li>
<li><a href="#初等函数的导数">初等函数的导数</a>
<ul>
<li><a href="#常函数">常函数</a></li>
<li><a href="#三角函数">三角函数</a></li>
<li><a href="#反三角函数">反三角函数</a></li>
<li><a href="#指数函数">指数函数</a></li>
<li><a href="#对数函数">对数函数</a></li>
<li><a href="#幂函数">幂函数</a></li>
<li><a href="#一般初等函数">一般初等函数</a></li>
</ul></li>
<li><a href="#单调函数的导数">单调函数的导数</a></li>
<li><a href="#李氏连续函数的导数">李氏连续函数的导数</a></li>
<li><a href="#微分">微分</a>
<ul>
<li><a href="#微分与导数微商">微分与导数(微商)</a></li>
</ul></li>
<li><a href="#导函数的性质">导函数的性质</a>
<ul>
<li><a href="#费马定理">费马定理</a></li>
<li><a href="#罗尔中值定理">罗尔中值定理</a></li>
<li><a href="#拉格朗日中值定理">拉格朗日中值定理</a>
<ul>
<li><a href="#example1-9">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul></li>
<li><a href="#柯西中值定理">柯西中值定理</a></li>
<li><a href="#广义微分中值定理">广义微分中值定理</a>
<ul>
<li><a href="#广义罗尔中值定理">广义罗尔中值定理</a></li>
<li><a href="#广义拉格朗日中值定理">广义拉格朗日中值定理</a></li>
</ul></li>
<li><a href="#导函数与间断点">导函数与间断点</a></li>
<li><a href="#函数的升降性">函数的升降性</a></li>
<li><a href="#函数的极值">函数的极值</a></li>
<li><a href="#达布定理">达布定理</a></li>
<li><a href="#函数的凹凸性">函数的凹凸性</a></li>
</ul></li>
<li><a href="#经典不等式">经典不等式</a>
<ul>
<li><a href="#琴生不等式">琴生不等式</a>
<ul>
<li><a href="#example1-10">Example1</a></li>
</ul></li>
<li><a href="#均值不等式">均值不等式</a></li>
<li><a href="#柯西-赫尔德不等式">柯西-赫尔德不等式</a></li>
<li><a href="#闵可夫斯基minkovski不等式">闵可夫斯基(Minkovski)不等式</a></li>
</ul></li>
<li><a href="#洛必达法则">洛必达法则</a>
<ul>
<li><a href="#00型">0/0型</a></li>
<li><a href="#inftyinfty型"><span class="math inline">\(\infty\)</span>/<span class="math inline">\(\infty\)</span>型</a></li>
</ul></li>
<li><a href="#泰勒公式">泰勒公式</a>
<ul>
<li><a href="#拉格朗日余项">拉格朗日余项</a></li>
</ul></li>
<li><a href="#解析函数">解析函数</a></li>
<li><a href="#拉格朗日插值">拉格朗日插值</a></li>
<li><a href="#函数的作图">函数的作图</a>
<ul>
<li><a href="#渐近线">渐近线</a></li>
<li><a href="#作图">作图</a></li>
</ul></li>
<li><a href="#牛顿迭代">牛顿迭代</a></li>
</ul></li>
<li><a href="#积分">积分</a>
<ul>
<li><a href="#不定积分">不定积分</a>
<ul>
<li><a href="#不定积分的运算">不定积分的运算</a></li>
<li><a href="#积分表">积分表</a></li>
<li><a href="#换元法">换元法</a>
<ul>
<li><a href="#example1-11">Example1</a></li>
</ul></li>
<li><a href="#分部积分">分部积分</a>
<ul>
<li><a href="#example1-12">Example1</a></li>
<li><a href="#example2-4">Example2</a></li>
<li><a href="#example3-2">Example3</a></li>
<li><a href="#example4-1">Example4</a></li>
<li><a href="#example5-1">Example5</a></li>
</ul></li>
<li><a href="#有理分式的不定积分">有理分式的不定积分</a></li>
<li><a href="#有理三角函数的不定积分">有理三角函数的不定积分</a></li>
<li><a href="#无理函数的不定积分">无理函数的不定积分</a></li>
<li><a href="#双曲换元">双曲换元</a>
<ul>
<li><a href="#example1-13">Example1</a></li>
<li><a href="#example2-5">Example2</a></li>
<li><a href="#example3-3">Example3</a></li>
</ul></li>
<li><a href="#椭圆积分">椭圆积分</a></li>
</ul></li>
<li><a href="#黎曼积分">黎曼积分</a>
<ul>
<li><a href="#可积性与连续性的关系勒贝格定理">可积性与连续性的关系(勒贝格定理)</a></li>
<li><a href="#可积函数的简单性质">可积函数的简单性质</a></li>
<li><a href="#广义原函数">广义原函数</a></li>
<li><a href="#牛顿-莱布尼茨公式微积分基本定理">牛顿-莱布尼茨公式(微积分基本定理)</a>
<ul>
<li><a href="#example1-14">Example1</a></li>
<li><a href="#example2黎曼引理">Example2(黎曼引理)</a></li>
<li><a href="#example3-4">Example3</a></li>
<li><a href="#example4-2">Example4</a></li>
<li><a href="#example5-2">Example5</a></li>
</ul></li>
<li><a href="#换元法-1">换元法</a>
<ul>
<li><a href="#example1-15">Example1</a></li>
<li><a href="#example2-6">Example2</a></li>
<li><a href="#example3-5">Example3</a></li>
</ul></li>
<li><a href="#分部积分-1">分部积分</a>
<ul>
<li><a href="#example1-16">Example1</a></li>
<li><a href="#example2-7">Example2</a></li>
<li><a href="#example3wallis公式">Example3(Wallis公式)</a></li>
</ul></li>
<li><a href="#泰勒公式的积分余项">泰勒公式的积分余项</a></li>
<li><a href="#积分第一中值定理">积分第一中值定理</a>
<ul>
<li><a href="#example1-17">Example1</a></li>
<li><a href="#example2-8">Example2</a></li>
</ul></li>
<li><a href="#积分第二中值定理">积分第二中值定理</a>
<ul>
<li><a href="#example1-18">Example1</a></li>
</ul></li>
<li><a href="#有界变差函数">有界变差函数</a></li>
<li><a href="#定积分的应用">定积分的应用</a>
<ul>
<li><a href="#example1图形证明不等式">Example1(图形证明不等式)</a></li>
<li><a href="#example2参数方程曲线面积">Example2(参数方程曲线面积)</a></li>
<li><a href="#example3极坐标的面积">Example3(极坐标的面积)</a></li>
<li><a href="#example4参数方程曲线的弧长">Example4(参数方程曲线的弧长)</a></li>
<li><a href="#example5极坐标下的弧长公式">Example5(极坐标下的弧长公式)</a></li>
<li><a href="#example6等周不等式">Example6(等周不等式)</a></li>
<li><a href="#example7求多面体体积">Example7(求多面体体积)</a></li>
<li><a href="#example8旋转体的侧面积公式">Example8(旋转体的侧面积公式)</a></li>
<li><a href="#example9pi的无理性证明">Example9(<span class="math inline">\(\pi\)</span>的无理性证明)</a></li>
<li><a href="#example10古鲁金第一定理">Example10(古鲁金第一定理)</a></li>
<li><a href="#example11古鲁金第二定理">Example11(古鲁金第二定理)</a></li>
<li><a href="#example12转动惯量">Example12(转动惯量)</a></li>
</ul></li>
<li><a href="#定积分近似计算">定积分近似计算</a></li>
<li><a href="#广义积分">广义积分</a>
<ul>
<li><a href="#example1-19">Example1</a></li>
<li><a href="#example2-9">Example2</a></li>
<li><a href="#example3-6">Example3</a></li>
<li><a href="#example4-3">Example4</a></li>
<li><a href="#example5-3">Example5</a></li>
<li><a href="#example6-1">Example6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#example8欧拉积分">Example8(欧拉积分)</a></li>
<li><a href="#example9frullani积分">Example9(Frullani积分)</a></li>
<li><a href="#example10">Example10</a></li>
<li><a href="#example11">Example11</a></li>
<li><a href="#example12">Example12</a></li>
<li><a href="#example13">Example13</a></li>
<li><a href="#example14">Example14</a></li>
<li><a href="#example15">Example15</a></li>
<li><a href="#example16">Example16</a></li>
<li><a href="#example17">Example17</a></li>
<li><a href="#example18磨光核函数">Example18(磨光核函数)</a></li>
</ul></li>
</ul></li>
<li><a href="#rs积分">RS积分</a></li>
</ul></li>
<li><a href="#级数">级数</a> * <a href="#example1-20">Example1</a> * <a href="#example2-10">Example2</a> * <a href="#example3-7">Example3</a>
<ul>
<li><a href="#正项级数">正项级数</a>
<ul>
<li><a href="#example1-21">Example1</a></li>
<li><a href="#example2-11">Example2</a></li>
<li><a href="#example3-8">Example3</a></li>
<li><a href="#example4-4">Example4</a></li>
<li><a href="#example5-4">Example5</a></li>
<li><a href="#example6-2">Example6</a></li>
<li><a href="#example7-1">Example7</a></li>
<li><a href="#example8">Example8</a></li>
<li><a href="#example9">Example9</a></li>
<li><a href="#example10-1">Example10</a></li>
</ul></li>
<li><a href="#交错级数">交错级数</a>
<ul>
<li><a href="#example1-22">Example1</a></li>
<li><a href="#example2-12">Example2</a></li>
</ul></li>
<li><a href="#积分判别法">积分判别法</a>
<ul>
<li><a href="#example1-23">Example1</a></li>
</ul></li>
<li><a href="#级数的交换顺序">级数的交换顺序</a>
<ul>
<li><a href="#example11-1">Example11</a></li>
</ul></li>
<li><a href="#级数的乘法">级数的乘法</a></li>
<li><a href="#无穷乘积">无穷乘积</a>
<ul>
<li><a href="#example1-24">Example1</a></li>
<li><a href="#example2-13">Example2</a></li>
<li><a href="#example3-9">Example3</a></li>
<li><a href="#example4-5">Example4</a></li>
<li><a href="#example5-5">Example5</a></li>
<li><a href="#example6-3">Example6</a></li>
</ul></li>
</ul></li>
<li><a href="#函数项数列">函数项数列</a> * <a href="#example1-25">Example1</a> * <a href="#example2-14">Example2</a> *
<a href="#example3-10">Example3</a> * <a href="#example4-6">Example4</a>
* <a href="#example5-6">Example5</a>
<ul>
<li><a href="#一致收敛">一致收敛</a>
<ul>
<li><a href="#example1-26">Example1</a></li>
<li><a href="#example2-15">Example2</a></li>
<li><a href="#example3-11">Example3</a></li>
<li><a href="#example4-7">Example4</a></li>
<li><a href="#example5-7">Example5</a></li>
<li><a href="#example6-4">Example6</a></li>
<li><a href="#example7-2">Example7</a></li>
</ul></li>
<li><a href="#函数项级数">函数项级数</a>
<ul>
<li><a href="#example1-27">Example1</a></li>
<li><a href="#example2-16">Example2</a></li>
<li><a href="#m判别法">M判别法</a></li>
<li><a href="#da判别法">DA判别法</a>
<ul>
<li><a href="#example1-28">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#连续性">连续性</a>
<ul>
<li><a href="#example1-29">Example1</a></li>
<li><a href="#example2-17">Example2</a></li>
</ul></li>
<li><a href="#可积性">可积性</a>
<ul>
<li><a href="#example1-30">Example1</a></li>
</ul></li>
<li><a href="#可微性">可微性</a>
<ul>
<li><a href="#example1-31">Example1</a></li>
<li><a href="#example2-18">Example2</a></li>
</ul></li>
<li><a href="#部分应用">部分应用</a>
<ul>
<li><a href="#borel引理">Borel引理</a></li>
<li><a href="#维尔斯特拉斯函数">维尔斯特拉斯函数</a></li>
<li><a href="#连续曲线充满平面">连续曲线充满平面</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="数学分析i">数学分析I</span></h2>
<h3><span id="实数">实数</span></h3>
<p>首先我们拿到了有理数,然后我们按照以下步骤定义无理数:</p>
<p>首先我们注意到有理数是不连续的.问题在于我们要将其中不连续的部分给补上.首先我们应当去发现一下如何去发现有理数中的一个断点:</p>
<p>设<span class="math inline">\(S\)</span>是一个全序非空集合,我们找到它的两个非空子集<span class="math inline">\(A,B\)</span>,若满足:</p>
<ol type="1">
<li><span class="math inline">\(A\cap B=\empty,A\cup B=S\)</span>.</li>
<li><span class="math inline">\(\forall a\in A,b\in
B,a&lt;b\)</span>.</li>
<li><span class="math inline">\(A\)</span>中无最大元素.</li>
</ol>
<p>则称这是<span class="math inline">\(S\)</span>的一个<strong>分划</strong>,记作<span class="math inline">\((A|B)\)</span>.接下来我们先考虑<span class="math inline">\(S=\mathbb Q\)</span>的情况.</p>
<p>我们注意到一些事,比如说注意到<span class="math inline">\(B\)</span>中有可能没有最小元素.举个例子的话,我们令<span class="math inline">\(S=\mathbb Q,A=\{x|x\leq 0\or (x&gt;0\and
x^2&lt;2)\}\)</span>,显然<span class="math inline">\(A\)</span>中无最大元素,此时取<span class="math inline">\(B=S\setminus A\)</span>,则显然<span class="math inline">\(B\)</span>中无最小元素(反证法),假设存在最小元素则可以调整到更小的元素,因为容易证明不存在一个有理数的平方为<span class="math inline">\(2\)</span>.</p>
<p>通过上面的铺垫我们知道,有理数并非连续的,因此如果<span class="math inline">\(B\)</span>中有最小元素,则称这是一个<strong>有理分划</strong>;如果<span class="math inline">\(B\)</span>中无最小元素,则称这是一个<strong>无理分划</strong>.容易发现有理分划与有理数一一对应.我们将无理分划也去对应到一些数上,这就产生了无理数的定义.只需比较<span class="math inline">\(A\)</span>集合的大小包含关系就可以比较两个实数的大小.</p>
<p>那我们还需要做的一件事是去证明无理数也有四则运算法则.不妨直接拿分划去验证四则运算法则:</p>
<ol type="1">
<li>加法:对于<span class="math inline">\((A_c|B_c)+(A_d|B_d)\)</span>,我们取<span class="math inline">\(A_{c+d}=\{x+y|x\in A_c,y\in
A_d\}\)</span>即可.</li>
<li>减法:只需定义加法逆元.如果是无理分划的话,直接把<span class="math inline">\(A,B\)</span>中的元素全部取反再交换即可;如果是有理分划的话,需要注意取反再交换后<span class="math inline">\(A\)</span>中出现了最大元素,只需要在这里把那个元素给提出来就行.</li>
<li>乘法:两个正数相乘可以直接模仿加法,如果有负数的话就把负号提出来再把绝对值作乘法即可.</li>
<li>除法:只需定义乘法逆元,这个有点麻烦需要判断<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>哪个集合是同号的,但总之这个是平凡的.</li>
</ol>
<h4><span id="戴德金分割定理">戴德金分割定理</span></h4>
<p>对<span class="math inline">\(\R\)</span>的任一分划<span class="math inline">\((A|B)\)</span>,<span class="math inline">\(B\)</span>中必定有最小元素.</p>
<p>这个怎么证明呢?对于分划<span class="math inline">\((A|B)\)</span>,我们直接取<span class="math inline">\(A&#39;=A\cap \Q,B&#39;=B\cap
\Q\)</span>,不难发现<span class="math inline">\((A&#39;|B&#39;)\)</span>一定是<span class="math inline">\(\Q\)</span>的一个分划,也就是说<span class="math inline">\((A&#39;|B&#39;)\)</span>对应了一个实数<span class="math inline">\(x\)</span>.</p>
<p>既然如此就可以考虑<span class="math inline">\(x\)</span>应该属于哪个集合.我们注意到:如果<span class="math inline">\(x\in A\)</span>,那么<span class="math inline">\(x\)</span>必定是<span class="math inline">\(A\)</span>中的最大元素;如果<span class="math inline">\(x\in B\)</span>,那么<span class="math inline">\(x\)</span>必定是<span class="math inline">\(B\)</span>中的最小元素.</p>
<p>两部分是类似的,只考虑前一部分.考虑反证,如果<span class="math inline">\(\exists y&gt;x,y\in A,x\in A\)</span>,那么<span class="math inline">\(A&#39;\subsetneq A_y\)</span>,那么<span class="math inline">\(A_y\)</span>就一定不是<span class="math inline">\(A\)</span>的子集.换言之,<span class="math inline">\(\exists w\in A_y\)</span>,<span class="math inline">\(\forall z\in A,w&gt;z\)</span>.但我们有<span class="math inline">\(y&gt;w\)</span>,这必然意味着<span class="math inline">\(y\notin A\)</span>,与假设不符.</p>
<h4><span id="确界存在定理">确界存在定理</span></h4>
<p>若<span class="math inline">\(M\)</span>有上(下)界,则必然有上(下)确界.</p>
<p>设<span class="math inline">\(M\)</span>有上界<span class="math inline">\(c\)</span>,由于它是一个实数,它应该可以写作<span class="math inline">\((A_c|B_c)\)</span>的形式.<span class="math inline">\(\forall \alpha\in M,A_\alpha \subset
A_c\)</span>.</p>
<p>于是我们取<span class="math inline">\(A=\bigcup_{\alpha\in
M}A_\alpha,B=\Q\setminus A\)</span>,我们来说明<span class="math inline">\((A|B)\)</span>是一个分划.</p>
<p>首先由于有上界,显然<span class="math inline">\(A,B\ne \empty,A\cap
B=\empty,A\cup B=\Q\)</span>.</p>
<p>如果<span class="math inline">\(\exists b\in B,a\in
A,b&lt;a\)</span>,这是不可能的,因为如果<span class="math inline">\(b&lt;a\)</span>,那么<span class="math inline">\(b\in A,b\notin B\)</span>.</p>
<p>因为所有的<span class="math inline">\(A_\alpha\)</span>中都没有最大元素,反证即可说明<span class="math inline">\(A\)</span>中无最大元素.</p>
<p>那么<span class="math inline">\((A|B)\)</span>就是<span class="math inline">\(M\)</span>的上确界.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明对于单增函数<span class="math inline">\(f:[0,1]\rightarrow
[0,1]\)</span>,<span class="math inline">\(f([0,1])\subseteq
(0,1)\)</span>,则<span class="math inline">\(f\)</span>与<span class="math inline">\(y=x\)</span>一定有交点.</p>
<p>取<span class="math inline">\(A=\{x|f(x)&lt;x\}\)</span>,则<span class="math inline">\(1\in A,A\subseteq [0,1]\)</span>.取<span class="math inline">\(a=\inf A\)</span>.</p>
<p>此时我们断言<span class="math inline">\(f(a)=a\)</span>,否则:</p>
<p>如果<span class="math inline">\(f(a)&lt;a\)</span>,取<span class="math inline">\(\epsilon=a-f(a)\)</span>,注意到<span class="math inline">\(f(a-\frac{\epsilon}{2})&lt;f(a)&lt;a-\frac{\epsilon}{2}\)</span>,因此<span class="math inline">\((a-\frac{\epsilon}{2})\in A\)</span>,与<span class="math inline">\(a\)</span>是下确界矛盾.</p>
<p>如果<span class="math inline">\(f(a)&gt;a\)</span>,取<span class="math inline">\(\epsilon=f(a)-a\)</span>.考虑由于<span class="math inline">\(a\)</span>是下确界,因此<span class="math inline">\(\exists b\in A,b\in
(a,a+\frac{\epsilon}{2})\)</span>.那么<span class="math inline">\(b&lt;a+\frac{\epsilon}{2}&lt;f(a)&lt;f(b)\)</span>,这与<span class="math inline">\(b\in A\)</span>矛盾.</p>
<h4><span id="阿基米德性质">阿基米德性质</span></h4>
<p>以下命题等价,任取其一均可作为阿基米德性质:</p>
<ol type="1">
<li><span class="math inline">\(\forall y\in \R\)</span>,<span class="math inline">\(\exists n\in \N,n&gt;y\)</span>.</li>
<li><span class="math inline">\(\forall x\in \R_+,\exist n\in
\N\)</span>,<span class="math inline">\(nx&gt;1\)</span>.</li>
<li><span class="math inline">\(\{\frac{1}{n}\}\)</span>有聚点.</li>
<li><span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{1}{n}\)</span>存在.</li>
<li><span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{1}{n}=0\)</span>.</li>
<li><span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{1}{2^n}=0\)</span>.</li>
</ol>
<p>(1)$<span class="math inline">\((2)\)</span><span class="math inline">\((3)\)</span><span class="math inline">\((4)\)</span>(5)<span class="math inline">\(是显然的.又考虑\)</span>{}<span class="math inline">\(是\)</span>{}<span class="math inline">\(的子列,所以\)</span>(5)(6)<span class="math inline">\(.而取一个\)</span>&lt;<span class="math inline">\(即可(6)\)</span>$(1).</p>
<p>阿基米德性质可以由确界存在定理推来,简单来说考虑<span class="math inline">\(x\in \R_+,A=\{nx|nx&lt;1\}\)</span>.反证,如果<span class="math inline">\(A\)</span>是无限集合,那么根据确界存在定理一定存在最小上确界<span class="math inline">\(\alpha\leq 1\)</span>有<span class="math inline">\(\forall
n,nx&lt;\alpha,(n+1)x&lt;\alpha,nx&lt;\alpha-x\)</span>,这就说明<span class="math inline">\(\alpha-x\)</span>是一个更小的上界,这就矛盾了.</p>
<h3><span id="实数集上的一元函数">实数集上的一元函数</span></h3>
<h4><span id="性质">性质</span></h4>
<h5><span id="奇偶性">奇偶性</span></h5>
<p>首先需要定义域关于原点对称.</p>
<p>然后注意到取<span class="math inline">\(f(x)=\frac{f(x)+f(-x)}{2}+\frac{f(x)-f(-x)}{2}\)</span>,可将任意定义域关于原点对称的函数写作奇偶函数之和.</p>
<p>事实上,对于一个可以求任意次导数的偶函数<span class="math inline">\(f\)</span>,是否总存在一个可以求任意次导数的函数<span class="math inline">\(g\)</span>使得<span class="math inline">\(f(x)=g(x^2)\)</span>.</p>
<p>这个问题的难点肯定在于<span class="math inline">\(0\)</span>附近对吧.</p>
<p>这个证明要用到泰勒展开. <span class="math display">\[
f(\sqrt{x})=\sum_{k=0}^n\frac{f^{(k)}(0)}{k!}x^\frac{k}{2}+\frac{f^{(n+1)}(\xi_n)}{(n+1)!}x^\frac{n+1}{2}
\]</span> 两边求导,应该有: <span class="math display">\[
(f(\sqrt{x}))^{(t)}=\sum_{k=0}^n\frac{f^{(k)}(0)\prod\limits_{i=0}^{t-1}(\frac{k}{2}-i)}{k!}x^{\frac{k}{2}-t}+\frac{f^{(n+1)}(\xi_n)\prod\limits_{i=0}^{t-1}(\frac{n+1}{2}-i)}{(n+1)!}x^{\frac{n+1}{2}-t}
\]</span> 我们知道<span class="math inline">\(f\)</span>任意阶导数存在,所以在闭区间<span class="math inline">\([-1,1]\)</span>上任意阶导数有界.这就意味着,对于固定的<span class="math inline">\(t\)</span>.只要取足够大的<span class="math inline">\(n=2t+2\)</span>满足<span class="math inline">\(\frac{n+1}{2}-t&gt;1\)</span>,就可以让余项趋于<span class="math inline">\(0\)</span>.</p>
<p>现在来数学归纳,用多项式的特殊情况,假设<span class="math inline">\(g^{(t)}(0)=\frac{t!}{(2t)!}f^{(2t)}(0)\)</span>,考虑:
<span class="math display">\[
g^{(t+1)}(0)=\frac{(f(\sqrt x))^{(t)}-\frac{t!}{(2t)!}f^{(2t)}(0)}{x}\\
=\cfrac{\sum_{k=0}^{2t+2}\frac{f^{(k)}(0)\prod\limits_{i=0}^{t-1}(\frac{k}{2}-i)}{k!}x^{\frac{k}{2}-t}-\frac{t!}{(2t)!}f^{(2t)}(0)}{x}\\
=\cfrac{\sum_{k=0}^{2t+2}\frac{f^{(k)}(0)\prod\limits_{i=0}^{t-1}(\frac{k}{2}-i)}{k!}x^{\frac{k}{2}}-\frac{t!}{(2t)!}f^{(2t)}(0)x^t}{x^{1+t}}\\
\]</span> 一片混乱,考虑一下下面这项: <span class="math display">\[
\frac{f^{(k)}(0)\prod\limits_{i=0}^{t-1}(\frac{k}{2}-i)}{k!}x^{\frac{k}{2}}\\
=\frac{f^{(k)}(0)\prod\limits_{i=0}^{t-1}(k-2i)}{k!2^t}x^{\frac{k}{2}}\\
\]</span> 这个时候我们注意到,当<span class="math inline">\(k\)</span>是奇数的时候应该有<span class="math inline">\(f^{(k)}(0)=0\)</span>,当<span class="math inline">\(k\)</span>是偶数并且<span class="math inline">\(k\leq t-1\)</span>的时候应该有<span class="math inline">\(\prod\limits_{i=0}^{t-1}(k-2i)=0\)</span>,这意味着这个求和最后只会剩下<span class="math inline">\(\frac{f^{(2t)}(0)t!}{(2t)!}x^{t}+\frac{f^{2t+2}(0)(t+1)!}{(2t+2)!}x^{t+1}\)</span>,然而前半部分和后面的刚好消掉了,这就数学归纳成立了.</p>
<h5><span id="有界性">有界性</span></h5>
<h5><span id="单调性">单调性</span></h5>
<h5><span id="周期性">周期性</span></h5>
<p>周期函数不一定有最小正周期,比如狄利克雷函数.</p>
<p>还有个思考题:</p>
<p>如果<span class="math inline">\(f,g\)</span>是定义域为<span class="math inline">\(R\)</span>的最小正周期分别为<span class="math inline">\(T_1,T_2\)</span>的周期函数,求问:</p>
<ol type="1">
<li>若<span class="math inline">\(\frac{T_1}{T_2}\in\Q\)</span>,则<span class="math inline">\(f+g\)</span>是周期函数.</li>
<li>若<span class="math inline">\(\frac{T_1}{T_2}\in \R\setminus
\Q\)</span>,结论如何.</li>
<li>若<span class="math inline">\(f,g\)</span>均连续,结论如何.</li>
</ol>
<p>(1)显然,(3)必定不是周期函数,原因是考虑反证:</p>
<p>如果是的话,必定有: <span class="math display">\[
f(x+T)+g(x+T)=f(x)+g(x)\\
f(x+T)-f(x)=g(x)-g(x+T)
\]</span> 令<span class="math inline">\(h(x)=f(x+T)-f(x)=g(x)-g(x+T)\)</span>,则<span class="math inline">\(h(x)\)</span>以<span class="math inline">\(T_1,T_2\)</span>为周期,那么其以<span class="math inline">\(pT_1+qT_2\)</span>为周期,可逼近这个无理数使得其周期趋近于<span class="math inline">\(0\)</span>,用<span class="math inline">\(h\)</span>的连续性,于是<span class="math inline">\(h(x)\)</span>为常函数,不符题意.</p>
<p>(2)怎么办呢?有没有一种构造方式使得它是周期函数呢?</p>
<p>构造<span class="math inline">\(d_{p,q}(x)=\begin{cases}1&amp;\exists
m,n\in \Z,mp+nq=x\\0&amp;\forall m,n\in \Z,mp+nq\ne
x\end{cases}\)</span>.</p>
<p>取<span class="math inline">\(f(x)=d_{1,\sqrt 2}(x)-d_{\sqrt 2,\sqrt
3}(x),g(x)=d_{\sqrt 2,\sqrt 3}(x)-d_{1,\sqrt{3}}\)</span>,容易见到<span class="math inline">\(f+g\)</span>的周期为<span class="math inline">\(1\)</span>,下面证明<span class="math inline">\(f\)</span>的最小正周期是<span class="math inline">\(\sqrt 2\)</span>,而<span class="math inline">\(g\)</span>的最小正周期是<span class="math inline">\(\sqrt 3\)</span>.</p>
<p>二者相似,只考虑证明前者,如若存在一个<span class="math inline">\(T\)</span>,使得<span class="math inline">\(f(x)=f(x+T)\)</span>,则有:</p>
<p><span class="math display">\[
d_{1,\sqrt 2}(x)-d_{\sqrt 2,\sqrt 3}(x)=d_{1,\sqrt 2}(x+T)-d_{\sqrt
2,\sqrt 3}(x+T)\\
d_{1,\sqrt 2}(x)-d_{1,\sqrt 2}(x+T)=d_{\sqrt 2,\sqrt 3}(x)-d_{\sqrt
2,\sqrt 3}(x+T)
\]</span></p>
<p>取<span class="math inline">\(x=\sqrt 3\)</span>得到:</p>
<p><span class="math display">\[
d_{\sqrt 2,\sqrt 3}(\sqrt 3+T)-d_{1,\sqrt 2}(\sqrt 3+T)=1
\]</span></p>
<p>这就意味着:</p>
<p><span class="math display">\[
\begin{cases}
d_{\sqrt 2,\sqrt 3}(\sqrt 3+T)=1\\
d_{1,\sqrt 2}(\sqrt 3+T)=0\\
\end{cases}
\]</span></p>
<p>从而<span class="math inline">\(T=n\sqrt 2+m\sqrt
3\)</span>,其中<span class="math inline">\(m\ne -1\)</span>.再取<span class="math inline">\(x=0\)</span>得到:</p>
<p><span class="math display">\[
d_{1,\sqrt 2}(T)=d_{\sqrt 2,\sqrt 3}(T)=1
\]</span></p>
<p>这就必然意味着<span class="math inline">\(T=n\sqrt
2\)</span>,从而<span class="math inline">\(f\)</span>的最小正周期恰好就是<span class="math inline">\(\sqrt 2\)</span>.</p>
<h4><span id="基本初等函数">基本初等函数</span></h4>
<ol type="1">
<li>常值函数</li>
<li>指数函数</li>
<li>对数函数</li>
<li>幂函数</li>
<li>三角函数</li>
<li>反三角函数</li>
</ol>
<p>其中有一些函数的定义其实有一些缺陷,我们将在讨论完连续性后给出.</p>
<h4><span id="初等函数">初等函数</span></h4>
<p>由基本初等函数经过有限次四则运算和复合得到的函数.</p>
<p>举个逆天例子: <span class="math display">\[
f(x)=\begin{cases}\sqrt{-x}&amp;x&lt;0\\0&amp;x\in[0,1]\\\ln
x&amp;x&gt;1\end{cases}
\]</span> 注意到<span class="math inline">\(f(x)=\sqrt{\frac{\sqrt
{x^2}-x}{2}}+\ln\frac{x+\sqrt{(x-1)^2}+1}{2}\)</span>.</p>
<h4><span id="代数函数">代数函数</span></h4>
<p>存在多项式<span class="math inline">\(F(x,y)\)</span>满足<span class="math inline">\(F(x,f(x))\equiv 0\)</span>的函数<span class="math inline">\(f(x)\)</span>称为代数函数.</p>
<h3><span id="数列极限">数列极限</span></h3>
<h4><span id="定义">定义</span></h4>
<p>设<span class="math inline">\(\{a_n\}\)</span>是一个给定的序列,若<span class="math inline">\(\exists l\)</span>,<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists N\in\mathbb{N}\)</span>,<span class="math inline">\(\forall n&gt; N,|a_n-l|&lt;
\epsilon\)</span>.我们称<span class="math inline">\(l\)</span>是这个序列的<strong>极限</strong>,记作<span class="math inline">\(\lim_{n\rightarrow \infty}a_n=l\\\)</span>.</p>
<h4><span id="性质">性质</span></h4>
<ol type="1">
<li>若数列存在极限,则极限唯一.</li>
<li>有极限的数列有界.</li>
<li>数列的极限可以四则运算.</li>
<li>设序列<span class="math inline">\(\{a_n\},\{b_n\}\)</span>有极限并且分别为<span class="math inline">\(l_a,l_b\)</span>,若<span class="math inline">\(\exists N\in\mathbb{N}\)</span>,<span class="math inline">\(\forall n&gt;N,a_n\geq b_n\)</span>,则<span class="math inline">\(l_a\geq l_b\)</span>.</li>
<li>设序列<span class="math inline">\(\{a_n\},\{b_n\}\)</span>有极限并且分别为<span class="math inline">\(l_a,l_b\)</span>,如果<span class="math inline">\(l_a&gt;l_b\)</span>,则<span class="math inline">\(\exists N\in\mathbb{N}\)</span>,<span class="math inline">\(\forall n&gt;N,a_n&gt;b_n\)</span>.</li>
<li>夹逼定理:设<span class="math inline">\(\{a_n\},\{b_n\},\{c_n\}\)</span>是三个序列,且<span class="math inline">\(\exists N_0,\forall n&gt;n_0,a_n\leq b_n\leq
c_n\)</span>.那么如果<span class="math inline">\(\lim_{n\rightarrow
\infty}a_n=\lim_{n\rightarrow \infty}c_n=l\\\)</span>,则<span class="math inline">\(\lim_{n\rightarrow \infty}b_n=l\\\)</span>.</li>
<li>对于原序列,若它有极限<span class="math inline">\(l\)</span>,取出它的无穷项子序列,那这个子序列的极限必然也是<span class="math inline">\(l\)</span>.(如果一个序列能取出两个无穷项子序列使得极限不相同,那么原序列必然无极限)</li>
</ol>
<p>大部分的证明都很显然,只需要套用极限定义即可,这里举几个证明为例.</p>
<p>(3):</p>
<p>设序列<span class="math inline">\(\{a_n\},\{b_n\}\)</span>有极限并且分别为<span class="math inline">\(l_a,l_b\)</span>,则要证<span class="math inline">\(\lim_{n\rightarrow \infty}(a_n\pm b_n)=l_a\pm
l_b\\\)</span>,<span class="math inline">\(\lim_{n\rightarrow
\infty}(a_nb_n)=l_al_b\\\)</span>,若<span class="math inline">\(l_b\ne
0\)</span>,<span class="math inline">\(\lim_{n\rightarrow
\infty}(\frac{a_n}{b_n})=\frac{l_a}{l_b}\\\)</span>.</p>
<p>先证明加减法,取<span class="math inline">\(\frac{1}{2}\epsilon\)</span>然后合并起来就行.</p>
<p>乘法也类似,首先有: <span class="math display">\[
l_a-\epsilon_1&lt;a_n&lt;l_a+\epsilon_1\\
l_b-\epsilon_2&lt;b_n&lt;l_b+\epsilon_2
\]</span> 于是自然有: <span class="math display">\[
|a_nb_n-l_al_b|=|(a_n-l_a)b_n+l_a(b_n-l_b)|
\\\leq |b_n||a_n-l_a|+|l_a||b_n-l_b|\\
&lt;|b_n|\epsilon_1+|l_a|\epsilon_2
\\&lt;|l_b\pm \epsilon_2|\epsilon_1+|l_a|\epsilon_2
\]</span> 不妨令<span class="math inline">\(\epsilon_1=\epsilon_2\)</span>,尝试构造一组解使得<span class="math inline">\(\forall \epsilon&gt;0,\exists
\epsilon_1&gt;0\)</span>,<span class="math inline">\(|l_b\pm\epsilon_1|\epsilon_1+|l_a|\epsilon_1&lt;\epsilon\)</span>.限制一下<span class="math inline">\(\epsilon&lt;1,\epsilon_1&lt;1\)</span>,取<span class="math inline">\(\epsilon_1=\frac{\epsilon}{1+|l_b|+|l_a|}\)</span>即可.</p>
<p>接下来证明除法,实际上只需要证明若<span class="math inline">\(l_b\ne
0\)</span>,<span class="math inline">\(\lim_{n\rightarrow
\infty}(\frac{1}{b_n})=\frac{1}{l_b}\\\)</span>.</p>
<p>考虑:<span class="math inline">\(l_b\lim_{n\rightarrow
\infty}b_n=l_b^2&gt;0\\\)</span>,这意味着当<span class="math inline">\(\exists N_0,\forall
n&gt;N_0,l_bb_n&gt;0\\\)</span>,或者更强一点,<span class="math inline">\(\exists N_0,\forall
n&gt;N_0,l_bb_n&gt;\frac{1}{2}l_b^2\\\)</span>.</p>
<p>不妨设<span class="math inline">\(\epsilon&#39;&gt;0,\exists
N_1,\forall n&gt;N_1,|l_b-b_n|&lt;\epsilon&#39;\)</span></p>
<p>取<span class="math inline">\(n&gt;\max(N_0,N_1)\)</span>此时自然有:
<span class="math display">\[
|\frac{1}{b_n}-\frac{1}{l_b}|=\frac{|l_b-b_n|}{|b_nl_b|}\leq
\frac{2}{l_b^2}\epsilon&#39;
\]</span> 取<span class="math inline">\(\epsilon&#39;=\frac{l_b^2}{2}\epsilon\)</span>即可得证.</p>
<p>(4):</p>
<p>反证,设<span class="math inline">\(l_a&lt;l_b\)</span>,那么取<span class="math inline">\(\epsilon=\frac{l_b-l_a}{2}\)</span>,立刻有: <span class="math display">\[
|a_N-l_a|&lt;\epsilon\\
a_N&lt; \frac{l_a+l_b}{2}&lt;b_N
\]</span> 这是不可能的.</p>
<h4><span id="单调收敛准则">单调收敛准则</span></h4>
<p>单调有界无穷数列有极限.</p>
<p>不妨设<span class="math inline">\(\{a_n\}\)</span>是一个单调有界无穷数列(不妨假设其单增,不然可以取反变成单增),且<span class="math inline">\(\forall n,a_n\leq l_a\)</span>.</p>
<p>考虑集合<span class="math inline">\(A=\{x_n|n\in
\N_+\}\)</span>,根据确界存在定理,其一定有上确界.令<span class="math inline">\(a\)</span>是它的上确界,我们来证明<span class="math inline">\(a\)</span>一定是数列的极限.</p>
<p>由于<span class="math inline">\(a\)</span>是上确界,这意味着<span class="math inline">\(\forall
\epsilon&gt;0,a-\epsilon\)</span>不是上确界,所以<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists N\)</span>,<span class="math inline">\(\forall n&gt;N,a-\epsilon&lt;a_n\leq
a&lt;a+\epsilon\)</span>,这就是极限的定义.</p>
<h4><span id="自然对数的底数">自然对数的底数</span></h4>
<p>定义<span class="math inline">\(e=\lim_{n\rightarrow
\infty}(1+\frac{1}{n})^n\\\)</span>.如何证明它存在极限呢?考虑单调有界无穷序列必定存在极限,定义<span class="math inline">\(x_n=(1+\frac{1}n)^n\)</span>,于是先证明它有界:
<span class="math display">\[
(1+\frac{1}{n})^n=\sum_{k=0}^n\frac{n^{\underline{k}}}{k!}\frac{1}{n^k}\\
&lt;\sum_{k=0}^n\frac{1}{k!}\\
&lt;2+\sum_{k=2}^n\frac{1}{k(k-1)}\\
=2+\sum_{k=2}^n(\frac{1}{k-1}-\frac{1}{k})
&lt;3
\]</span> 接下来证明单调,只需证明: <span class="math display">\[
\sqrt[n+1]{(1+\frac 1 n)^n}&lt;\frac{n+2}{n+1}\\
\sqrt[n+1]{1(1+\frac 1 n)^n}&lt;\frac{1+n(1+\frac{1}{n})}{n+1}
\]</span> 由均值不等式显然.</p>
<p>如果我们考虑另一个极限<span class="math inline">\(y_n=(1+\frac{1}{n})^{n+1}\)</span>,注意到: <span class="math display">\[
\frac{1}{y_n}=(\frac{n}{n+1})^{n+1}\times 1&lt;
(\frac{n+1}{n+2})^{n+2}=\frac{1}{y_{n+1}}
\]</span> 发现<span class="math inline">\(y_n\)</span>单调递减且<span class="math inline">\(y_n&gt;x_n\)</span>,并且<span class="math inline">\(\lim_{n\rightarrow
\infty}y_n-x_n=0\)</span>,这就意味着二者必然同时趋向于一个常数的两侧,定义为<span class="math inline">\(e=2.7182818284\cdots\)</span>.</p>
<p>这里还可以推出一些结论.因为我们知道: <span class="math display">\[
x_n&lt;e&lt;y_n\\
n\ln(1+\frac{1}{n})&lt;1&lt;(n+1)\ln (1+\frac{1}{n})\\
\frac{1}{n+1}&lt;\ln(n+1)-\ln (n)&lt;\frac{1}{n}\\
H_{n+1}-1&lt;\ln (n+1)&lt;H_n
\]</span> 用这个可以注意到定义<span class="math inline">\(z_n=H_n-\ln
n\)</span>,这个东西肯定<span class="math inline">\(\geq
0\)</span>且<span class="math inline">\(\leq 1\)</span>,而且注意到<span class="math inline">\(z_{n+1}-z_n=\frac{1}{n+1}-\ln
\frac{n+1}{n}&lt;0\)</span>,所以单调有界,这个极限就是欧拉常数<span class="math inline">\(\gamma=0.57\cdots\)</span>.</p>
<p>接下来证明<span class="math inline">\(e\)</span>是无理数.</p>
<p>考虑<span class="math inline">\(e=\lim_{n\rightarrow
\infty}(1+\frac{1}{n})^n\)</span>,取二项式定理,取<span class="math inline">\(x_k=\sum_{k=0}^n\frac{n^{\underline{k}}}{k!n^k}\leq
\sum_{k=0}^n\frac{1}{k!}=U_n\)</span>.</p>
<p>而又注意到<span class="math inline">\(x_n=\sum_{k=0}^n\frac{n^{\underline{k}}}{k!n^k}\)</span>,取定一个确定的上界<span class="math inline">\(m\leq n\)</span>,则<span class="math inline">\(x_n\geq
\sum_{k=0}^m\frac{n^{\underline{k}}}{k!n^k}=y_n\)</span>.由于<span class="math inline">\(m\)</span>有限,所以当<span class="math inline">\(n\rightarrow \infty\)</span>时,<span class="math inline">\(y_n\rightarrow U_n\)</span>的前<span class="math inline">\(m\)</span>项,此时再令<span class="math inline">\(m\to \infty\)</span>,根据夹逼定理,立刻得到<span class="math inline">\(x_n\rightarrow U_n\)</span>.换言之,<span class="math inline">\(m\)</span>增大引起的误差总可以被后面的<span class="math inline">\(n\)</span>的增大抹平.</p>
<p>考虑一下计算误差,设<span class="math inline">\(r_n=e-U_n\)</span>,则<span class="math inline">\(r_n=\sum_{k\geq
n+1}\frac{1}{k!}=\frac{1}{(n+1)!}\sum_{k\geq
0}\frac{1}{(n+2)^{\overline{k}}}&lt;\frac{1}{(n+1)!}\sum_{k\geq
0}\frac{1}{(n+2)^k}=\frac{1}{(n+1)!}\frac{n+2}{n+1}&lt;\frac{1}{n\times
n!}\)</span>.</p>
<p>如果<span class="math inline">\(e\)</span>是有理数,设<span class="math inline">\(e=\frac{m}{n}\in \Q\)</span>,考虑: <span class="math display">\[
0&lt;r_n=\frac{m}{n}-U_n&lt;\frac{1}{n\times n!}\\
0&lt;m\times (n-1)!-U_n\times n!&lt;\frac{1}{n}
\]</span> 这立刻导出矛盾,因为<span class="math inline">\(U_n\times
n!\)</span>一定是整数.</p>
<h4><span id="开区间与闭区间">开区间与闭区间</span></h4>
<p>定义一个集合的内部点:<span class="math inline">\(x,\exists
\delta&gt;0,(x-\delta,x+\delta)\subseteq
A\)</span>.我们将一个集合的所有内部点组成的集合记作<span class="math inline">\(A^{\degree}\)</span>.</p>
<p>这样就可以定义一个集合是内部为空的,就是其没有内部点.反之,如果每个点都是其内部点,那么称其为稠密的.</p>
<p>定义一个集合的边界点:<span class="math inline">\(x,\forall
\delta&gt;0,(x-\delta,x+\delta)\cap A\ne \empty,(x-\delta,x+\delta)\cap
A^C\ne \empty\)</span>.</p>
<p>一个集合称为开集合,当且仅当<span class="math inline">\(A=A^{\degree}\)</span>.</p>
<p>一个集合称为闭集合,当且仅当对于集合中的任何一个数列,数列极限也存在于这个集合中.</p>
<p>当然也可以用补集来用开集合定义闭集合(补集是开集合的集合是闭集合)或者反之.</p>
<p>由此我们知道开集的并是开集,有限个开集的交是开集;闭集的交是闭集,有限个闭集的并是闭集.</p>
<p>容易发现包含于<span class="math inline">\(A\)</span>的所有开集的并是<span class="math inline">\(A^{\degree}\)</span>.</p>
<p>我们类似定义<span class="math inline">\(A\)</span>的闭包是<span class="math inline">\(\bar A\)</span>.</p>
<p>而且容易发现如果<span class="math inline">\(f\)</span>是连续函数,那么如果<span class="math inline">\(U\)</span>是开集,那么<span class="math inline">\(f^{-1}(U)\)</span>(也就是<span class="math inline">\(U\)</span>的原像)也是开集.</p>
<h4><span id="区间套定理">区间套定理</span></h4>
<p>设<span class="math inline">\(I_n=[a_n,b_n]\ne
\empty,I_{n+1}\subseteq I_{n}\)</span>,则<span class="math inline">\(I=\bigcap_{n\geq
1}I_n\)</span>存在且是一个非空闭区间.</p>
<p>怎么证明?考虑<span class="math inline">\(a_n\)</span>单增,<span class="math inline">\(b_n\)</span>单减并且<span class="math inline">\(a_1\leq a_n\leq b_n\leq b_1\)</span>,所以<span class="math inline">\(a_n\)</span>存在极限,不妨设为<span class="math inline">\(l_a\)</span>,同理<span class="math inline">\(b_n\)</span>也存在极限,设为<span class="math inline">\(l_b\)</span>.容易验证<span class="math inline">\(I=[l_a,l_b]\)</span>.</p>
<p>类似地,设<span class="math inline">\(I_n=(a_n,b_n)\ne
\empty,I_{n+1}\subseteq I_{n}\)</span>,并且<span class="math inline">\(a_n,b_n\)</span>不会从某一项开始往后全都是常数(换言之其极限不等于其每一项,且不会上下波动),则<span class="math inline">\(I=\bigcap_{n\geq
1}I_n\)</span>存在且是一个非空闭区间.</p>
<p>特别地,当<span class="math inline">\(\lim
|b_n-a_n|=0\)</span>的时候,上述给出一个单点.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(x_1=a,x_2=b,a\ne
b,x_{n+2}=\frac{x_{n+1}+x_n}{2}\)</span>,问<span class="math inline">\(\lim_{n\rightarrow
\infty}x_n\)</span>是否存在.</p>
<p>可以设<span class="math inline">\(c_n=\min\{x_n,x_{n+1}\},d_n=\max\{x_n,x_{n+1}\}\)</span>,讨论<span class="math inline">\(x_{n+1}\)</span>和<span class="math inline">\(x_n\)</span>的大小关系(二者显然不相等)可以知道<span class="math inline">\([c_n,d_n]\)</span>满足区间套定理的条件,又注意到<span class="math inline">\(|I_{n+1}|=|x_{n+2}-x_{n+1}|=\frac{1}{2}|I_n|\)</span>,所以区间长度趋近于<span class="math inline">\(0\)</span>,这样的话<span class="math inline">\(\lim_{n\rightarrow\infty}c_n=\lim_{n\rightarrow\infty}x_n=\lim_{n\rightarrow\infty}d_n\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(a_1&gt;b_1&gt;0\)</span>,<span class="math inline">\(a_{n+1}=\frac{a_n+b_n}{2},b_{n+1}=\sqrt
{a_nb_n}\)</span>.求证<span class="math inline">\(a_n,b_n\)</span>极限都存在且相等.</p>
<p>还是区间套定理,容易验证满足区间套定理的条件,那么要注意到<span class="math inline">\(|I_{n+1}|=\frac{a_n+b_n}{2}-\sqrt
{a_nb_n}&lt;\frac{a_n+b_n}{2}-b_n=\frac{1}{2}|I_n|\)</span>,所以<span class="math inline">\(\lim_{n\rightarrow\infty}|I_n|=0\)</span>,这就证明了二者存在且相等.</p>
<p>其实先用单调有界数列有极限,再对着递推式两边求下极限就可以了.</p>
<h4><span id="有限覆盖定理">有限覆盖定理</span></h4>
<p>覆盖:<span class="math inline">\(\Sigma:\)</span>由一些开区间组成的集合.若<span class="math inline">\(M\subset \R\)</span>,称<span class="math inline">\(M\)</span>被<span class="math inline">\(\Sigma\)</span>覆盖,当且仅当<span class="math inline">\(M\subseteq \bigcup_{\sigma\in \Sigma
}\sigma\)</span>.</p>
<p>有限覆盖定理是说,如果<span class="math inline">\(M=[a,b]\)</span>是一个有界闭区间,且<span class="math inline">\(M\)</span>被<span class="math inline">\(\Sigma\)</span>覆盖,则一定存在一个<span class="math inline">\(\Sigma\)</span>的有限子集<span class="math inline">\(\Sigma_1\)</span>,使得<span class="math inline">\(M\)</span>能被<span class="math inline">\(\Sigma_1\)</span>覆盖.</p>
<p>换言之,有界闭区间若能被开区间覆盖,则一定能被有限个开区间覆盖.</p>
<p>反证:如果<span class="math inline">\(M\)</span>不能被有限覆盖,那么<span class="math inline">\([a,\frac{a+b}{2}]\)</span>和<span class="math inline">\([\frac{a+b}{2},b]\)</span>至少有一个不能被有限覆盖(如果它俩都能那<span class="math inline">\([a,b]\)</span>肯定也能).不妨取出二者中任意一个不能被有限覆盖的区间,设为<span class="math inline">\([a_1,b_1]\)</span>,再进行上面的操作就可以得到<span class="math inline">\([a_2,b_2]\)</span>,以此类推,如此我们得到了一个满足区间套定理的区间序列而且均不能被有限覆盖,根据区间套定理,可以取出它们交集的那个元素<span class="math inline">\(c\)</span>.由于<span class="math inline">\(\{c\}\in M\)</span>,所以<span class="math inline">\(\exists \sigma\in \Sigma,c\in
\sigma\)</span>.因为<span class="math inline">\(\sigma\)</span>是开区间,所以<span class="math inline">\(\exists \epsilon&gt;0,[c-\epsilon,c+\epsilon]\in
\sigma\)</span>,而显然可以找到一个<span class="math inline">\(N&gt;0\)</span>,<span class="math inline">\(\forall n\geq N\)</span>,<span class="math inline">\([a_n,b_n]\in
[c-\epsilon,c+\epsilon]\)</span>,这就矛盾了.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:有界闭区间上的局部有界(对于每一个点,它都存在一个开区间邻域是有界的)函数是整体有界函数.</p>
<p>设定义域为<span class="math inline">\([a,b]\)</span>,考虑<span class="math inline">\(\forall x_0\in [a,b],\exists
\sigma&gt;0\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\((x_0-\sigma,x_0+\sigma)\)</span>上有界,注意到设<span class="math inline">\(I_{x_0}=(x_0-\sigma,x_0+\sigma)\)</span>,那么<span class="math inline">\([a,b]\)</span>一定被<span class="math inline">\(I\)</span>这个区间集合开覆盖,那么就能被有限开覆盖,取出那有限个区间对应的值域并起来就行.</p>
<h6><span id="example2">Example2</span></h6>
<p>证明:有界闭区间上的局部增(对于每一个点,它都存在一个开区间邻域是增的)函数是整体增函数.</p>
<p>证明和上面一样,合并两个开区间的时候找任意一个交集元素即可.</p>
<h4><span id="外测度与零测集">外测度与零测集</span></h4>
<p>定义<strong>外测度:</strong>对于<span class="math inline">\(E\subseteq \R\)</span>,定义<span class="math inline">\(m^*(E)\)</span>为<span class="math inline">\(E\)</span>的外测度,<span class="math inline">\(m^*(E)=\inf\{(\sum |I_k|)\mid \bigcup I_k\supseteq
E\}\)</span>,也就是找一列区间使得其并起来能包含<span class="math inline">\(E\)</span>.</p>
<p>定义<strong>零测集</strong>:外测度为<span class="math inline">\(0\)</span>的集合.容易发现<span class="math inline">\(m^*(\bigcup E_k)\leq \sum
m^*(E_k)\)</span>.于是可数个零测集的并仍然是零测集.</p>
<p>如果一个集合的势可数,那它当然是零测集,原因是可以构造<span class="math inline">\(I_n=(x_n-\delta,x_n+\delta),\delta=\frac{1}{2^{n+1}}\)</span>.由这个构造<span class="math inline">\(\epsilon_k=\frac{\epsilon}{2^{k+1}}\)</span>可以说明可数个零测集的并仍然是零测集.</p>
<p>反之,一个集合是零测集不一定代表其可数,例如康托三分集:先把<span class="math inline">\([0,1)\)</span>上扣去<span class="math inline">\([\frac{1}{3},\frac{2}{3})\)</span>,然后再对剩下的线段也做类似的操作,每次扣掉中间一段.算一下每次扣去的长度,发现长度恰好为<span class="math inline">\(1\)</span>,于是当然是零测集.但注意到这对应着一个三进制小数并且每一位只能是<span class="math inline">\(0,2\)</span>,那这当然势仍然是<span class="math inline">\(2^\N\)</span>,于是不可数.</p>
<h4><span id="vitali覆盖引理">Vitali覆盖引理</span></h4>
<p>当<span class="math inline">\(E\subseteq R\)</span>,称一族区间<span class="math inline">\(\Gamma=\{I_\alpha\}\)</span>是<span class="math inline">\(E\)</span>的一个Vitali覆盖,若对<span class="math inline">\(\forall x\in E,\epsilon&gt;0\)</span>,<span class="math inline">\(\exists I_{\alpha}\in
\Gamma,|I_\alpha|&lt;\epsilon,x\in
I_\alpha\)</span>.也就是对于任何一个点都存在足够小的区间把它盖住.</p>
<p>Vitali覆盖引理是说,如果<span class="math inline">\(E\)</span>是一个有界集(或者推广到外测度有限的集合),<span class="math inline">\(\Gamma\)</span>是<span class="math inline">\(E\)</span>的一个Vitali覆盖,则<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\Gamma\)</span>中可以拿出有限个两两不交的区间<span class="math inline">\(I_j\in \Gamma\)</span>,满足<span class="math inline">\(m^*(E\setminus (\bigcup
I_j))&lt;\epsilon\)</span>.注意这里取区间的方式依赖于<span class="math inline">\(\epsilon\)</span>的选取.</p>
<p>取一个开集<span class="math inline">\(G\supseteq
E,m^*(G)&lt;\infty\)</span>,不妨设<span class="math inline">\(\Gamma\)</span>中的每个区间都<span class="math inline">\(\subseteq
G\)</span>(原因在于Vitali覆盖保证了任意小的区间覆盖,而开集的性质使得总有区间在其中).在此基础上,由于上面的<span class="math inline">\(\Gamma\)</span>是任意一个Vitali覆盖,所以我们不妨假设<span class="math inline">\(\Gamma\)</span>中的每个区间都是闭区间(也就是把端点加进去,那当然仍然是Vitali覆盖而且更难满足限制,因为闭区间更难以两两不交),这当然仍是可以的.</p>
<p>现在我们归纳取区间,我们任取一个<span class="math inline">\(I_1\in
\Gamma\)</span>,开始不断往上添区间.设<span class="math inline">\(I_1,\cdots,I_k\)</span>已经被我们拿到,而且两两不交.</p>
<p>如果此时<span class="math inline">\(E\subseteq \bigcup_{j=1}^k
I_j\)</span>,当然直接满足条件.</p>
<p>反之,令<span class="math inline">\(\delta_k=\sup\{(|I|)\mid I\in
\Gamma,I\cap I_j=\empty,1\leq j\leq k\}\)</span>.容易发现<span class="math inline">\(\delta_k&lt;\infty\)</span>.那我们取<span class="math inline">\(I_{k+1}\)</span>使得<span class="math inline">\(\forall 1\leq j\leq k,I_{k+1}\cap
I_j=\empty,|I_{k+1}|&gt;\frac{1}{2}\delta_k\)</span>,这当然做得到.</p>
<p>如果一直做下去都没有使得<span class="math inline">\(E\subseteq
\bigcup I_j\)</span>,那我们就可以拿到一个区间列.接下来我们考虑<span class="math inline">\(\sum |I_k|\)</span>,此时由于<span class="math inline">\(I_k\)</span>两两不交,当然有<span class="math inline">\(\sum|I_k|\leq
m^*(G)&lt;\infty\)</span>,那么根据单调收敛准则,<span class="math inline">\(\sum |I_k|\)</span>趋于一个极限,于是<span class="math inline">\(|I_k|\)</span>当然趋近于<span class="math inline">\(0\)</span>,那么<span class="math inline">\(\delta
_k\)</span>趋近于<span class="math inline">\(0\)</span>.在此基础上,我们当然可以取一个<span class="math inline">\(N&gt;0\)</span>,<span class="math inline">\(\forall n\geq N,\sum_{k\geq
n+1}|I_k|&lt;\frac{1}{5}\epsilon\)</span>.</p>
<p>此时<span class="math inline">\(\forall x\in E\setminus
(\bigcup_{k\leq N} I_k)\)</span>.由于<span class="math inline">\(I_k\)</span>均为闭区间,所以<span class="math inline">\(E\setminus (\bigcup_{k\leq N}
I_k)\)</span>必定是开区间,这也就是说<span class="math inline">\(x\)</span>存在一个小邻域<span class="math inline">\(I&#39;\in \Gamma\)</span>并且<span class="math inline">\(I&#39;\subseteq E\setminus (\bigcup_{k\leq N}
I_k)\)</span>.那当然有<span class="math inline">\(I&#39;\cap
(\bigcup_{k\leq N}I_k)=\empty\)</span>,也就是<span class="math inline">\(I&#39;\cap I_k=\empty,1\leq k\leq
N\)</span>.由于<span class="math inline">\(|I&#39;|\)</span>有限且不为<span class="math inline">\(0\)</span>,而<span class="math inline">\(\delta
_n\rightarrow 0\)</span>.一定<span class="math inline">\(\exists n\geq
N\)</span>,使得<span class="math inline">\(I&#39;\cap (\bigcup_{k\leq
n}I_k)=\empty,I&#39;\cap I_{n+1}\ne \empty\)</span>.发现此时<span class="math inline">\(|I&#39;|\leq \delta_n&lt;2|I_{n+1}|\)</span>.</p>
<p>此时会出个什么事呢?由于<span class="math inline">\(|I&#39;|&lt;2|I_{n+1}|\)</span>,所以我们把<span class="math inline">\(I_{n+1}\)</span>这个区间扩大五倍(中心不变,半径扩大到原本的五倍)就一定能盖住<span class="math inline">\(I&#39;\)</span>.</p>
<p>那会怎么样呢?那<span class="math inline">\(m^*(E\setminus
(\bigcup_{k\leq N} I_k))\leq 5\sum_{k\geq
N+1}|I_k|&lt;\epsilon\)</span>.于是证毕.</p>
<h4><span id="聚点原理">聚点原理</span></h4>
<p>假设<span class="math inline">\(M\)</span>是一个实数集,称<span class="math inline">\(x_0\)</span>是<span class="math inline">\(M\)</span>的聚点,当且仅当<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(((x_0-\epsilon,x_0)\cup(x_0,x_0+\epsilon))\cap
M\ne \empty\)</span>,或说,<span class="math inline">\(\forall
\epsilon&gt;0,(x_0-\epsilon,x_0+\epsilon)\cap
M\)</span>是一个无限集.可以理解为,<span class="math inline">\(x_0\)</span>不是一个孤点.</p>
<p>引理:<span class="math inline">\(x_0\)</span>为<span class="math inline">\(M\)</span>的聚点,当且仅当<span class="math inline">\(\exists \{x_n\}\in M\setminus
\{x_0\},\lim_{n\rightarrow
\infty}x_n=x_0\)</span>.充分性显然,必要性的话只需取<span class="math inline">\(\epsilon=2^{-n}\)</span>然后从上面的交集拿点就行.</p>
<p>聚点原理:有界无穷集<span class="math inline">\(M\)</span>必有聚点.</p>
<p>我们可以找一个<span class="math inline">\(I_0=[a,b],M\subset
I_0\)</span>,我们找<span class="math inline">\([a,\frac{a+b}{2}],[\frac{a+b}{2},b]\)</span>,其中至少有一个和<span class="math inline">\(M\)</span>的交集为无穷集,我们取其为<span class="math inline">\([a_1,b_1]\)</span>,不断这么做又会得到一个闭区间套列,交起来得到的那个元素<span class="math inline">\(c\)</span>就是聚点,因为<span class="math inline">\(\forall \epsilon&gt;0,\exists N&gt;0,\forall n\geq
N,|b_n-a_n|&lt;\epsilon\)</span>,那么<span class="math inline">\([a_n,b_n]\subseteq
(c-\epsilon,c+\epsilon)\)</span>,立刻证毕.</p>
<h4><span id="baire纲定理">Baire纲定理</span></h4>
<ol type="1">
<li>设<span class="math inline">\(\{F_n\}\)</span>是一列内部为空(没有除空集以外的开子集)的闭集,则<span class="math inline">\(\bigcup_{n=1}^{\infty}F_n\)</span>内部为空.</li>
<li>设<span class="math inline">\(\{G_n\}\)</span>是一列稠密(补集内部为空)的开集,则<span class="math inline">\(\bigcap_{n=1}^{\infty}G_n\)</span>稠密.</li>
</ol>
<p>(1)(2)等价,下面只证明(1):</p>
<p>反证,假设<span class="math inline">\(F=\bigcup_{n=1}^{\infty}F_n\)</span>内部不为空,也就是其存在一个内部开集<span class="math inline">\((x_0-\delta_0,x_0+\delta_0)\subseteq
F\)</span>.由于<span class="math inline">\(F_1\)</span>是一个闭集,因此<span class="math inline">\((x_0-\delta_0,x_0+\delta_0)\setminus
F_1\)</span>当然是一个开集,于是其就存在一个子区间<span class="math inline">\([x_1-\delta_1,x_1+\delta_1]\subseteq
(x_0-\delta_0,x_0+\delta_0)\)</span>并且<span class="math inline">\([x_1-\delta_1,x_1+\delta_1]\cap
F_1=\empty\)</span>,同理可以找到一列闭区间<span class="math inline">\(\{[x_k-\delta_k,x_k+\delta_k]\}\)</span>使得<span class="math inline">\([x_k-\delta_k,x_k+\delta_k]\cap \bigcup_{j=1}^k
F_j=\empty\)</span>.</p>
<p>容易见到我们可以任意调小<span class="math inline">\(\delta_k\)</span>的大小,调整使得<span class="math inline">\(\delta_k&lt;\frac{1}{k}\)</span>总成立就得到了一列闭区间套,必然拿到了一个单独的点<span class="math inline">\(\xi\)</span>,那么<span class="math inline">\(\xi\in (x_0-\delta_0,x_0+\delta_0)\subseteq
F\)</span>,然而对于任意区间都有<span class="math inline">\(\xi\notin
F_n\)</span>,因此<span class="math inline">\(\xi \notin
F\)</span>,这就导出了矛盾.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\(f(x)\)</span>连续,并且<span class="math inline">\(\forall x&gt;0,\lim_{n\rightarrow
\infty}f(nx)=0\)</span>,则<span class="math inline">\(\lim
_{x\rightarrow \infty}f(x)=0\)</span>.</p>
<p>对于一个<span class="math inline">\(\epsilon&gt;0\)</span>,考虑构造内部为空的闭集<span class="math inline">\(F_n=\{x|\forall k\geq n,f(kx)\leq
\epsilon\}\)</span>(为什么这是闭集呢?因为当你设<span class="math inline">\(F_{n,k}\)</span>满足上述定义,那<span class="math inline">\(F_{n,k}\)</span>肯定是闭集,然后<span class="math inline">\(F_n\)</span>就是上述这些的交,当然也是闭集).容易发现<span class="math inline">\(F_n\)</span>的并是<span class="math inline">\(\R_+\)</span>,那就一定至少有一个闭集内部不为空,我们就可以取出其中的一个区间设为<span class="math inline">\((a,b)\)</span>,然后用这个区间在若干倍后覆盖后半部分数轴,原因是当<span class="math inline">\(n\)</span>足够大的时候,一定有<span class="math inline">\(nb&gt;(n+1)a\)</span>存在.</p>
<h4><span id="致密性定理">致密性定理</span></h4>
<p>有界无穷数列有收敛的子列.</p>
<p>考虑数列值域<span class="math inline">\(M=\{x|x=x_n,n\in
\N_+\}\)</span>.</p>
<p>如果<span class="math inline">\(M\)</span>是有限集合,那<span class="math inline">\(\exists a\)</span>,<span class="math inline">\(I=\{n|x_n=a\}\)</span>是无限集合,把这些数拿出来就是一个无限的常数列.</p>
<p>如果<span class="math inline">\(M\)</span>是无限集,那其存在聚点,设<span class="math inline">\(a\)</span>为其中一个聚点.则<span class="math inline">\(M_k=((a-\frac{1}{k},a+\frac{1}{k})\setminus
\{a\})\cap M,k\in \N_+\)</span>是个无限集.</p>
<p>那只需要取<span class="math inline">\(x_{n_k}\)</span>为<span class="math inline">\(M_k\)</span>中的某个<span class="math inline">\(x_{n&#39;}\)</span>满足<span class="math inline">\(n&#39;&gt;n_{k-1}\)</span>即可,由于这是无限集,所以显然可以取出.拿出来的这个数列显然以<span class="math inline">\(a\)</span>为极限.</p>
<h4><span id="柯西收敛准则">柯西收敛准则</span></h4>
<p>称一个数列为柯西数列,当且仅当<span class="math inline">\(\forall
\epsilon&gt;0,\exists N&gt;0,\forall n,m\geq
N,|x_n-x_m|&lt;\epsilon\)</span>.</p>
<p>一个数列收敛的充要条件是他是一个柯西数列.</p>
<p>先证必要性:</p>
<p><span class="math inline">\(\forall \epsilon&gt;0,\exists
N&gt;0,\forall n,m\geq
N,|a-x_n|&lt;\frac{\epsilon}{2},|a-x_m|&lt;\frac{\epsilon}{2},|x_n-x_m|\leq
|x_n-a|+|a-x_m|&lt;\epsilon\)</span>.</p>
<p>再证充分性:</p>
<p>考虑取<span class="math inline">\(\epsilon=1\)</span>,则<span class="math inline">\(\exists N_1,\forall n\geq
N_1,|x_n-x_{N_1}|&lt;1\)</span>,于是<span class="math inline">\(|x_n|&lt;|x_{N_1}|+1\)</span>,于是<span class="math inline">\(\forall
n,|x_n|&lt;\max_{k=1}^{N_1}\{|x_k|\}+1\)</span>,于是这个数列有界,那么存在无穷子列有极限<span class="math inline">\(a\)</span>.</p>
<p>那么<span class="math inline">\(\forall \epsilon&gt;0,\exists
N&gt;0,\forall n_k,m\geq N,|x_{n_k}-x_m|&lt;\epsilon\)</span>,其中<span class="math inline">\(\{x_{n_k}\}\)</span>以<span class="math inline">\(a\)</span>为极限,于是可以取足够远的<span class="math inline">\(x_{n_k}\)</span>.接下来就是简单说明的环节了.</p>
<p>柯西收敛准则的充分性还可以用上下极限证明:</p>
<p>取<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall
n\geq N,x_n\in
(x_N-\epsilon,x_N+\epsilon)\)</span>,那么上下极限之差<span class="math inline">\(\leq 2\epsilon\)</span>.</p>
<p>于是引出了实数的第二种定义方式:我们定义两个柯西列等价,有<span class="math inline">\(\{x_n\}\sim \{y_n\}\Leftrightarrow
\lim_{n\rightarrow
\infty}|x_n-y_n|=0\)</span>.那么所有有理数组成的柯西列的等价类构成实数集合.不难证明这样定义出来的实数和戴德金分割等价.</p>
<p>这个定义方式只依赖于距离的定义.而且我们可以证明任何一次扩充后得到的空间一定是封闭的.用这个例子就是说你对于一个实数的柯西列,证明它一定收敛到一个实数.那么就可以把这个柯西列的每一个数(作为实数,实际上对应了一个柯西列)中抽出一个数来,然后证明这些数组成的新的柯西列与刚才那个柯西列等价,这样就证明了其封闭性.其实只要第<span class="math inline">\(k\)</span>个数把其代表的任意一个柯西列中选第<span class="math inline">\(k\)</span>个元素构造即可.</p>
<h4><span id="上下极限">上下极限</span></h4>
<p>我们推广广义极限,也就是一个数列可以以<span class="math inline">\(+\infty\)</span>或者<span class="math inline">\(-\infty\)</span>为极限.这个容易用<span class="math inline">\(\epsilon-N\)</span>语言写出来.这样的话我们立刻得到单调数列有极限.</p>
<p>那我们取任意一个数列从某一项往后的上确界<span class="math inline">\(h_n=\sup_{k\geq n}\{x_k\}\)</span>和下确界<span class="math inline">\(l_n=\inf_{k\geq n}\{x_k\}\)</span>,那么注意到<span class="math inline">\(\{l_n\}\)</span>单调不降,<span class="math inline">\(\{h_n\}\)</span>单调不增,所以二者都存在极限.由此可以定义上下极限,并且任意数列都一定存在上下极限.</p>
<p>注意到<span class="math inline">\(\lim_{n\rightarrow \infty}
l_n=\sup_{n\geq 1}\inf_{k\geq n}\{x_k\},\lim_{n\rightarrow \infty}
h_n=\inf_{n\geq 1}\sup_{k\geq n}\{x_k\}\)</span>,于是<span class="math inline">\(\varliminf_{n\rightarrow \infty} x_n=
\lim_{n\rightarrow \infty}l_n\leq
\lim_{n\rightarrow\infty}h_n=\varlimsup_{n\rightarrow \infty}
x_n\)</span>.</p>
<p>那么<span class="math inline">\(x_n\)</span>存在极限当且仅当<span class="math inline">\(\varlimsup_{n\rightarrow
\infty}x_n=\varliminf_{n\rightarrow \infty} x_n\)</span>.</p>
<p>充分性很好证明,只需要使用夹逼定理即可.</p>
<p>必要性也很好说如果极限不是<span class="math inline">\(\infty\)</span>,<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall n\geq
N,a-\epsilon&lt;x_n&lt;a+\epsilon\)</span>,那么<span class="math inline">\(a-\epsilon&lt;l_n\leq
h_n&lt;a+\epsilon\)</span>.自然得到两者极限相等.是<span class="math inline">\(\infty\)</span>也很好说.</p>
<p>上下极限同样有保序性,相反数有<span class="math inline">\(\varlimsup
(-x)=-\varliminf x\)</span>,但是不能简单的四则运算,而是有<span class="math inline">\(\varliminf x_n+\varliminf y_n\leq \varliminf
(x_n+y_n)\leq \varlimsup(x_n+y_n)\leq \varlimsup x_n+\varlimsup
y_n\)</span>,我们这里先不讨论出现<span class="math inline">\(\infty-\infty\)</span>的情况.</p>
<p>证明的话只需注意到<span class="math inline">\(\inf_{k\geq
n}x_k+\inf_{k\geq n}y_k\leq x_m+y_m,\forall m\geq
n\)</span>,因此对右边可以取下确界,然后两边一起取极限即可.</p>
<p>另外还有结论是<span class="math inline">\(\varliminf (x_n+y_n)\leq
\varlimsup x_n+\varliminf y_n\)</span>.这个又如何证明呢?只需证明: <span class="math display">\[
\varliminf (x_n+y_n)-\varlimsup x_n\leq \varliminf y_n\\
\varliminf (x_n+y_n)+\varliminf (-x_n)\leq \varliminf y_n\\
\]</span> 于是证毕.</p>
<p>乘法的话需要规定<span class="math inline">\(x_n,y_n&gt;0\)</span>,然后和加法的不等式形式是类似的(同样先不考虑<span class="math inline">\(0\times \infty\)</span>的情况).</p>
<p>如果<span class="math inline">\(\{x_n\},\{y_n\}\)</span>其中一个存在极限,那么上面的不等式就可以取等了(当然仍然不讨论出现<span class="math inline">\(\infty-\infty\)</span>和<span class="math inline">\(0\times \infty\)</span>的情况).如果<span class="math inline">\(x_n=y_n&gt;0\)</span>的话上面的乘法不等式也可以取等,换言之<span class="math inline">\(x_n&gt;0\)</span>的时候<span class="math inline">\(\varlimsup x_n^2=(\varlimsup
x_n)^2\)</span>成立.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于数列<span class="math inline">\(\{a_n\}\)</span>,满足<span class="math inline">\(a_n&gt;0\)</span>,<span class="math inline">\(a_{n+2}=\frac{2}{a_{n+1}+a_n}\)</span>.</p>
<p>求证:</p>
<ol type="1">
<li><span class="math inline">\(\{a_n\}\)</span>有界.</li>
<li><span class="math inline">\(\lim_{n\rightarrow
\infty}a_n=1\)</span>.</li>
<li><span class="math inline">\(\exists
\lambda\in(0,1),c&gt;0\)</span>,<span class="math inline">\(\forall
n,|a_n-1|&lt;c\lambda^n\)</span>.</li>
<li>对所有满足条件的数列,求<span class="math inline">\(\min(\lambda)=\frac{\sqrt 2}{2}\)</span>.</li>
</ol>
<p>对于(1),取<span class="math inline">\(M=\max(\max(a_1,a_2),\frac{1}{\min(a_1,a_2)})\)</span>,数学归纳可证明<span class="math inline">\(a_n\in [\frac{1}{M},M]\)</span>.</p>
<p>两边取一下上极限和下极限,立刻得到<span class="math inline">\(1\leq
\overline{a}\underline{a}\leq 1\)</span>,于是<span class="math inline">\(\overline{a}\underline{a}=1\)</span>.</p>
<p>后面不会了(乐).</p>
<h4><span id="stolz定理">Stolz定理</span></h4>
<p>如果<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{a_{n+1}-a_n}{b_{n+1}-b_n}=A\)</span>,并且<span class="math inline">\(\{b_n\}\)</span>单调递增且发散,那么<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{a_n}{b_n}=A\)</span>.</p>
<p>这个怎么证明呢?先取<span class="math inline">\(c_n=a_n-Ab_n\)</span>,考虑<span class="math inline">\(\forall \epsilon&gt;0,\exists N&gt;0,\forall n\geq
N\)</span>,有: <span class="math display">\[
c_{n+1}-c_n\leq  |c_{n+1}-c_n|&lt;\epsilon(b_{n+1}-b_n)
\]</span> 两边求和,立刻有: <span class="math display">\[
c_{n}-c_N&lt; \epsilon(b_{n}-b_N)\\
\frac{c_n-c_N}{b_n-b_N}&lt; \epsilon\\
\frac{\frac{c_n}{b_n}-\frac{c_N}{b_n}}{1-\frac{b_N}{b_n}}&lt;\epsilon
\]</span> 由于<span class="math inline">\(b_n\)</span>发散,对左边取极限就得到<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{c_n}{b_n}=0\)</span>,也就证明了原结论.</p>
<p>如果将上述条件改为:</p>
<ol type="1">
<li><span class="math inline">\(\{b_n\}\)</span>单调递减且<span class="math inline">\(\lim b_n=0\)</span>.</li>
<li><span class="math inline">\(\lim a_n=0\)</span>.</li>
</ol>
<p>上述定理也是成立的.</p>
<p>证明仍然是上面那个过程,只是做一些小修改:</p>
<p><span class="math display">\[
c_{N}-c_n&lt; \epsilon(b_{N}-b_n)\\
\frac{c_N-c_n}{b_N-b_n}&lt; \epsilon\\
\frac{\frac{c_N}{b_N}-\frac{c_n}{b_N}}{1-\frac{b_n}{b_N}}&lt;\epsilon
\]</span></p>
<p>两边取极限.</p>
<p>把Stolz定理推广到上下极限上.换言之,当:</p>
<ol type="1">
<li><span class="math inline">\(\{b_n\}\)</span>单调上升且趋近于无穷.</li>
</ol>
<p>或:</p>
<ol type="1">
<li><span class="math inline">\(\{b_n\}\)</span>单调递减且<span class="math inline">\(\lim b_n=0\)</span>.</li>
<li><span class="math inline">\(\lim a_n=0\)</span>.</li>
</ol>
<p>此时应当有:</p>
<p><span class="math display">\[
\varliminf\frac{a_{n+1}-a_n}{b_{n+1}-b_n} \leq \varliminf
\frac{a_n}{b_n}\leq \varlimsup \frac{a_n}{b_n}\leq \varlimsup
\frac{a_{n+1}-a_n}{b_{n+1}-b_n}
\]</span></p>
<p>上述命题的一个平凡推论是:</p>
<p><span class="math display">\[
\varliminf (a_{n+1}-a_n)\leq \varliminf\frac{a_n}{n}\leq \varlimsup
\frac{a_n}{n}\leq \varlimsup(a_{n+1}-a_n)
\]</span></p>
<h3><span id="实数的完备性基本定理">实数的完备性基本定理</span></h3>
<p>我们将以下定理称作实数的完备性的基本定理:</p>
<ol start="0" type="1">
<li>戴德金分割定理</li>
<li>确界存在定理</li>
<li>单调收敛准则</li>
<li>闭区间套定理(+阿基米德性质)</li>
<li>有限覆盖定理</li>
<li>聚点原理</li>
<li>致密性定理</li>
<li>柯西收敛准则(+阿基米德性质)</li>
</ol>
<p>这七条定理(除了3和7,它们需要与阿基米德性质配合使用)全部与戴德金分割定理等价.</p>
<p>我们上面已经论证了其中的部分推导关系,我们在下面声称它们分为若干组推导链条,分别代表了实数的不同性质.</p>
<h3><span id="函数极限">函数极限</span></h3>
<h4><span id="定义">定义</span></h4>
<p>函数的极限类型比较多:</p>
<ol type="1">
<li><span class="math inline">\(x\)</span>是从一点<span class="math inline">\(a\)</span>的右侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x\rightarrow a+0\)</span>.</li>
<li><span class="math inline">\(x\)</span>是从一点<span class="math inline">\(a\)</span>的左侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x\rightarrow a-0\)</span>.</li>
<li><span class="math inline">\(x\)</span>同时从一点<span class="math inline">\(a\)</span>的两侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x\rightarrow a\)</span>.</li>
<li><span class="math inline">\(x\)</span>无限制增大,记作<span class="math inline">\(x\rightarrow +\infty\)</span>.</li>
<li><span class="math inline">\(x\)</span>无限制减小,记作<span class="math inline">\(x\rightarrow -\infty\)</span>.</li>
<li><span class="math inline">\(|x|\)</span>无限制增大,<span class="math inline">\(x\)</span>同时增大或减小,记作<span class="math inline">\(x\rightarrow \infty\)</span>.</li>
</ol>
<p>序列极限的定理在函数极限的条件下几乎也全都成立.</p>
<h5><span id="单侧极限">单侧极限</span></h5>
<p>即<span class="math inline">\(x\rightarrow a+0\)</span>和<span class="math inline">\(x\rightarrow
a-0\)</span>,这两种是对称的,我们只讨论前一种.</p>
<p>若<span class="math inline">\(\exists l,\forall \epsilon&gt;0,\exists
\delta&gt;0,\forall
0&lt;x-a&lt;\delta,|f(x)-l|&lt;\epsilon\)</span>.我们称<span class="math inline">\(l\)</span>是<span class="math inline">\(x\rightarrow a+0\)</span>时<span class="math inline">\(f(x)\)</span>的<strong>右极限</strong>,记作<span class="math inline">\(\lim_{x\rightarrow
a+0}f(x)=l\\\)</span>,同理可以定义<strong>左极限</strong>.</p>
<h5><span id="双侧极限">双侧极限</span></h5>
<p>若左右极限都存在且相等,那么双侧极限也存在并且<span class="math inline">\(\lim_{x\rightarrow a}f(x)=\lim_{x\rightarrow
a+0}f(x)=\lim_{x\rightarrow a-0}f(x)\\\)</span>.</p>
<h5><span id="自变量趋于无穷时的极限">自变量趋于无穷时的极限</span></h5>
<p>设函数<span class="math inline">\(f(x)\)</span>在<span class="math inline">\((a,+\infty)\)</span>上有定义,若<span class="math inline">\(\exists l\)</span>,<span class="math inline">\(\forall \epsilon,\exists A\geq a,\forall
x&gt;A,|f(x)-l|&lt;\epsilon\)</span>,则记<span class="math inline">\(\lim_{x\rightarrow
+\infty}f(x)=l\\\)</span>,同理定义<span class="math inline">\(\lim_{x\rightarrow
-\infty}\)</span>,若二者均存在且相等,定义<span class="math inline">\(\lim_{x\rightarrow \infty}=\lim_{x\rightarrow
+\infty}=\lim_{x\rightarrow -\infty}\)</span>.</p>
<h4><span id="上下极限">上下极限</span></h4>
<p>定义去心邻域<span class="math inline">\(U_0(x_0,\delta)=(x_0-\delta,x_0+\delta)\setminus
\{x_0\}\)</span>.</p>
<p>定义<span class="math inline">\(\varlimsup_{x\rightarrow
x_0}f(x)=\lim_{\delta\rightarrow +0}\sup_{x\in
U_0(x_0,\delta)}f(x)\)</span>,下极限同理.</p>
<p>显然<span class="math inline">\(\lim_{x\rightarrow
x_0}f(x)=A\Leftrightarrow \varlimsup_{x\rightarrow
x_0}f(x)=\varliminf_{x\rightarrow x_0}f(x)=A\)</span>.</p>
<h4><span id="第一可数公理">第一可数公理</span></h4>
<p>函数极限当然满足四则运算法则,保序性,夹逼定理,单调收敛准则,柯西收敛准则.</p>
<p>事实上函数极限和数列极限满足关系:</p>
<p><span class="math inline">\(\forall \{x_n\}\in
U_0(x_0)\)</span>,如果<span class="math inline">\(\lim_{n\rightarrow
\infty}x_n=x_0\)</span>,那么<span class="math inline">\(\lim_{n\rightarrow
\infty}f(x_n)=\lim_{x\rightarrow
x_0}f(x)\)</span>,前提是这两个极限都存在.</p>
<p>证明是堆<span class="math inline">\(\delta-\epsilon\)</span>语言,不再赘述.</p>
<p>而它们之间关系的本质其实是:<span class="math inline">\(x_0\)</span>处的”任意小邻域”其实可以用某列邻域替代.</p>
<p>我们定义邻域基:一个由<span class="math inline">\(x_0\)</span>的邻域组成的集合<span class="math inline">\(U\)</span>,如果对于任意小邻域,<span class="math inline">\(U\)</span>中都存在一个邻域比这个邻域更小,那么就称<span class="math inline">\(U\)</span>是一个邻域基.<span class="math inline">\(\R\)</span>的特殊之处在于任意一个点都有可数邻域基,这被称为第一可数公理(<span class="math inline">\(C_1\)</span>公理).</p>
<p>另外<span class="math inline">\(\R\)</span>是可分的,也就是它存在可数稠密集(<span class="math inline">\(\Q\)</span>).</p>
<h4><span id="无穷大量和无穷小量">无穷大量和无穷小量</span></h4>
<p>如果<span class="math inline">\(x\rightarrow x_0\)</span>时,<span class="math inline">\(f(x)\)</span>有界,称<span class="math inline">\(f(x)=O(1)\)</span>.</p>
<p>如果<span class="math inline">\(x\rightarrow x_0\)</span>的时候,<span class="math inline">\(f(x)\rightarrow 0\)</span>,称<span class="math inline">\(f(x)=o(1)\)</span>.</p>
<p>如果<span class="math inline">\(f,g=o(1)\)</span>,<span class="math inline">\(\frac{f}{g}\rightarrow
1\)</span>,那么称二者为<strong>等价无穷小</strong>;如果<span class="math inline">\(\frac{f}{g}=c\ne
0\)</span>,则称二者为同阶无穷小(可记作<span class="math inline">\(f\sim
g\)</span>);如果<span class="math inline">\(\frac{f}{g}=0\)</span>,则称<span class="math inline">\(f\)</span>为<span class="math inline">\(g\)</span>的<strong>高阶无穷小</strong>,可记作<span class="math inline">\(f=o(g)\)</span>.</p>
<p>同阶无穷小在做乘除法的时候是可以替换的.</p>
<p>如果<span class="math inline">\(\frac{f}{g}\)</span>是有界的,那么可以写作<span class="math inline">\(f=O(g)\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(\lim_{x\rightarrow 0}\frac{\sin
x}{x}=1\)</span>.</p>
<p>因为其左右对称,考虑取<span class="math inline">\(x\in
(0,\frac{\pi}{2})\)</span>我们有<span class="math inline">\(\sin
x&lt;x&lt;\tan x\)</span>(用单位元的面积证明).</p>
<p>那么考虑<span class="math inline">\(\frac{\sin
x}{x}&lt;1\)</span>,又注意到:</p>
<p><span class="math display">\[
\frac{\sin x}{x}&gt;\frac{\sin x}{\tan x}=\cos x
\]</span></p>
<p>夹逼定理一下就行.</p>
<p>类似可以证明<span class="math inline">\(\lim_{x\rightarrow
0}\frac{\tan x}{x}=1,\lim_{x\rightarrow 0}\frac{1-\cos
x}{x^2}=\frac{1}{2},\)</span></p>
<h6><span id="example2">Example2</span></h6>
<p><span class="math inline">\(\lim_{x\rightarrow 0}\frac{x-\sin
x}{x^3}=\frac{1}{6}\)</span>.</p>
<p>下面有个三次方,考虑套用一下三倍角公式,我们知道:</p>
<p><span class="math display">\[
f(x)=\frac{x-\sin x}{x^3}=\frac{x-(3\sin
\frac{x}{3}-4\sin^3\frac{x}{3})}{x^3}\\
=\frac{3(\frac{x}{3}-\sin \frac{x}{3})+4\sin
^3\frac{x}{3}}{(\frac{x}{3})^3}\frac{1}{27}\\
=\frac{1}{9}f(\frac{x}{3})+\frac{4}{27}(\frac{\sin\frac{x}{3}}{\frac{x}{3}})^3
\]</span></p>
<p>看上去两边取上下极限就做完了对吧!但是还差一点,因为我们要证明上下极限都不是无穷,起码得说明它有界.</p>
<p>注意到<span class="math inline">\(\frac{x-\sin x}{x^3}&lt;\frac{\tan
x-\sin x}{x^3}=\frac{\sin x}{x}(\frac{1-\cos x}{x^2\cos x})=\frac{\sin
x}{x}(\frac{2\sin^2\frac{x}{2}}{x^2\cos
x})\)</span>,这样两边限定一下范围再取上极限可以说明原式上极限有界.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\lim_{x\rightarrow 0}\frac{\sin x-\tan
x}{x^3}\)</span>.</p>
<p>考虑<span class="math inline">\(\frac{\sin x-\tan x}{x^3}=\frac{\sin
x}{x}\frac{1}{x^2}\frac{\cos x-1}{\cos x}=\frac{\tan x}{x}\frac{\cos
x-1}{x^2}=-\frac{1}{2}\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p><span class="math inline">\(\lim_{t\rightarrow
0}\frac{\log_{a}(1+t)}{t}=\frac{1}{\ln a}\)</span>. <span class="math display">\[
\lim_{t\rightarrow 0}\frac{\log_{a}(1+t)}{t}=\log_a\lim_{t\rightarrow
0}(1+t)^{\frac{1}{t}}=\log_ae=\frac{1}{\ln a}
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(\lim_{t\rightarrow 0}\frac{a^t-1}{t}=\ln
a\)</span>.</p>
<p>令<span class="math inline">\(s=a^t-1\)</span>,则原式等于<span class="math inline">\(\lim_{s\rightarrow 0}\frac{s}{\log_a(s+1)}=\ln
a\)</span>.</p>
<h6><span id="example6">Example6</span></h6>
<p><span class="math inline">\(\lim_{t\rightarrow
0}\frac{(1+t)^\mu-1}{t}=\mu\)</span>.</p>
<p>令<span class="math inline">\(s=(1+t)^\mu-1\)</span>,那么原式等于<span class="math inline">\(\lim_{t\rightarrow 0,s\rightarrow
0}\mu\frac{s}{\ln(1+s)}\frac{\ln(1+t)}{t}=\mu\)</span>.</p>
<h4><span id="连续函数">连续函数</span></h4>
<p>不妨设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\((a,b)\)</span>上有定义,若对于<span class="math inline">\(x_0\in(a,b)\)</span>,<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处有双侧极限且<span class="math inline">\(\lim_{x\rightarrow
x_0}f(x)=f(x_0)\)</span>,称其在<span class="math inline">\(x_0\)</span>处<strong>连续</strong>,<span class="math inline">\(x_0\)</span>称为<strong>连续点</strong>,若<span class="math inline">\(\forall x_0\in (a,b)\)</span>,<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处连续,则称其在<span class="math inline">\((a,b)\)</span>上<strong>连续</strong>.连续性相当于说:取极限和<span class="math inline">\(f\)</span>可以交换顺序,换言之<span class="math inline">\(\lim_{x\rightarrow x_0}f(x)=f(\lim_{x\rightarrow
x_0}x)\)</span>.</p>
<p>我们也可以类似上面定义<strong>左连续</strong>和<strong>右连续</strong>,若<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义,且在<span class="math inline">\((a,b)\)</span>上连续,在<span class="math inline">\(a\)</span>处右连续,在<span class="math inline">\(b\)</span>处左连续,称其在<span class="math inline">\([a,b]\)</span>上连续.</p>
<p>如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>附近有定义且不连续,则称<span class="math inline">\(x_0\)</span>是一个<strong>间断点</strong>,间断点有以下几种:</p>
<ol type="1">
<li>如果<span class="math inline">\(\lim_{x\rightarrow
x_0+0}f(x)\)</span>和<span class="math inline">\(\lim_{x\rightarrow
x_0-0}f(x)\)</span>都存在但不相等或者不等于<span class="math inline">\(f(x_0)\)</span>,则称为<strong>第一类间断点</strong>.如果是后者情况,可以通过修改<span class="math inline">\(f(x_0)\)</span>的定义来去掉这个间断点,因而一般被称为<strong>可去间断点</strong>.</li>
<li>反之,如果<span class="math inline">\(\lim_{x\rightarrow
x_0+0}f(x)\)</span>和<span class="math inline">\(\lim_{x\rightarrow
x_0-0}f(x)\)</span>至少有一个不存在,则称为<strong>第二类间断点</strong>.</li>
</ol>
<p>使用单调收敛准则,可证明单调函数没有第二类间断点.并且单调函数的间断点只有可数个(几乎处处连续).</p>
<p>这个怎么证明呢?考虑设<span class="math inline">\(M\)</span>是函数<span class="math inline">\(f\)</span>的第一类间断点集,取<span class="math inline">\(x\in
M,I_x=(f(x_0-0),f(x_0+0))\)</span>,由于函数单调,所以这些<span class="math inline">\(I_x\)</span>两两不交.考虑映射<span class="math inline">\(M\rightarrow \Q,x\mapsto \min(I_x\cap
\Q)\)</span>,也就是考虑每一个<span class="math inline">\(I_x\)</span>中都有若干个有理数,且互不相交,那么显然这个映射是个单射,<span class="math inline">\(M\)</span>可数.</p>
<p>事实上有更强的结论:任意函数的第一类间断点集都是可数的.</p>
<p>设<span class="math inline">\(M\)</span>是函数<span class="math inline">\(f\)</span>的第一类间断点集,取<span class="math inline">\(M_n=\{x\in M\mid
|f(x+0)-f(x-0)|&gt;\frac{1}{n}\},M&#39;=\{x\in M|f(x+0)=f(x-0)\ne
f(x)\}\)</span>.</p>
<p>注意到<span class="math inline">\(M=(\bigcup_{n\geq 1}M_n)\cup
M&#39;\)</span>.</p>
<p>我们定义孤立点:如果<span class="math inline">\(x\in A,\exists
\sigma,(x-\sigma,x+\sigma)\nsubseteq A\)</span>,则称<span class="math inline">\(x\)</span>是<span class="math inline">\(A\)</span>中的一个孤立点.类似刚才证明可数性,我们每个孤立点都可以取一段邻域,领域中一定存在有理数,所以任意一个集合中的孤立点个数一定是可数的.</p>
<p>又发现所有的<span class="math inline">\(x\in M_n\)</span>,<span class="math inline">\(x\)</span>都是孤立点,原因很显然因为在<span class="math inline">\(x\)</span>的两侧小区间都在趋近于一个极限,所以它们肯定不是第一类间断点.所以所有的<span class="math inline">\(M_n\)</span>都是可数集.</p>
<p>那怎么证明<span class="math inline">\(M&#39;\)</span>是可数集呢?考虑取<span class="math inline">\(M&#39;_n=\{x\in M|
|f(x)-f(x-0)|&gt;\frac{1}{n}\}\)</span>,现在<span class="math inline">\(M&#39;=\bigcup_{n\geq 1}M&#39;_n\)</span>,而<span class="math inline">\(M&#39;_n\)</span>一定是孤立点集,所以<span class="math inline">\(M&#39;\)</span>可数.</p>
<p>综上就可以看出<span class="math inline">\(M\)</span>是一个可数集.</p>
<p>而第二类间断点则是可以有任意多个,例如对于迪利克雷函数,其处处都是第二类间断点.</p>
<p>由于连续性由极限定义,这意味着在<span class="math inline">\((a,b)\)</span>上的连续函数的有定义的四则运算必定得到的还是在<span class="math inline">\((a,b)\)</span>上的连续函数.那么,如果我们对于一个区间<span class="math inline">\(I\)</span>,定义<span class="math inline">\(C(I)\)</span>为所有在<span class="math inline">\(I\)</span>上连续的函数组成的集合,<span class="math inline">\(C(I)\)</span>就是一个线性空间.且不难发现,连续函数的复合仍然是连续函数.这其实对应着<span class="math inline">\(\lim_{x\rightarrow a}g(f(x))=g(\lim_{x\rightarrow
a}f(x))=g(f(a))\\\)</span>.</p>
<p>另外,如果一个连续函数有单值反函数,则反函数必连续.</p>
<p>不难证明,所有的初等函数在定义域上都是连续的.</p>
<p>另外:连续周期非常值函数一定有最小正周期.</p>
<p>考虑设正周期的集合是<span class="math inline">\(\{t\}\)</span>,取<span class="math inline">\(T=\inf \{t\}\)</span>.</p>
<p>当<span class="math inline">\(T=0\)</span>的时候,取一个正周期的数列<span class="math inline">\(\{t_n\}\rightarrow 0\)</span>,然后<span class="math inline">\(\forall x&lt;y,x_n=x+\lfloor\frac{y-x}{t_n}\rfloor
t_n,|y-x_n|\leq t_n\rightarrow 0\)</span>,于是<span class="math inline">\(\lim_{n}f(x_n)=f(y)\)</span>,而恒有<span class="math inline">\(f(x)=f(x_n)\)</span>于是这是一个常值函数.</p>
<p>反之,则取<span class="math inline">\(\{t_n\}\rightarrow
T,f(x+T)=\lim_{n}f(x+t_n)=f(x)\)</span>.</p>
<h5><span id="一致连续">一致连续</span></h5>
<p>假设<span class="math inline">\(f:I\rightarrow \R\)</span>,若<span class="math inline">\(\forall \epsilon&gt;0,\exists \delta&gt;0,\forall
x_1,x_2\in
I,|x_1-x_2|&lt;\delta,|f(x_1)-f(x_2)|&lt;\epsilon\)</span>,则称其<strong>一致连续</strong>.一致连续性是一个比连续性强得多的性质,例如<span class="math inline">\(f(x)=x^2\)</span>就不是一致连续的.</p>
<h5><span id="李氏连续">李氏连续</span></h5>
<p>假设<span class="math inline">\(f:I\rightarrow \R\)</span>,若<span class="math inline">\(\exists L,\forall x_1,x_2\in I,|f(x_1)-f(x_2)|\leq
L|x_1-x_2|\)</span>,则称其<strong>李氏连续</strong>.李氏连续当然强于一致连续.</p>
<h4><span id="闭区间下的连续函数">闭区间下的连续函数</span></h4>
<h5><span id="介值定理零点存在定理">介值定理(零点存在定理)</span></h5>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义且连续,<span class="math inline">\(f(a)\ne f(b)\)</span>,则<span class="math inline">\(\forall \eta\in(f(a),f(b)),\exists c\in
(a,b),f(c)=\eta\)</span>.这当然等价于<span class="math inline">\(f(a)f(b)&lt;0\Rightarrow \exists c\in
(a,b),f(c)=0\)</span>.</p>
<p>考虑取<span class="math inline">\(f(\frac{a+b}{2})\)</span>,如果<span class="math inline">\(f(\frac{a+b}{2})=0\)</span>那就完事了.不然的话考虑<span class="math inline">\(f(a)f(\frac{a+b}{2})\)</span>和<span class="math inline">\(f(\frac{a+b}{2})f(b)\)</span>中必定有恰好一个小于<span class="math inline">\(0\)</span>,这当然给出一个闭区间套,不妨设最后套出了一个单点<span class="math inline">\(c\)</span>.此时取极限立刻有<span class="math inline">\(0\geq \lim f(a_n)f(b_n)=f(c)^2\)</span>,于是<span class="math inline">\(f(c)=0\)</span>.</p>
<p>也有一个存在性证明:反证,如果<span class="math inline">\(\forall x\in
[a,b]\)</span>,<span class="math inline">\(f(x)\ne 0\)</span>.那么<span class="math inline">\(\forall x\in [a,b],\exists
\delta(x)&gt;0\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\((x-\delta(x),x+\delta(x))\)</span>与<span class="math inline">\(f(x)\)</span>同号.根据有限覆盖定理,我们可以拿出有限个开区间来覆盖整个区间.此时可以将这些开区间排序,相邻两个区间两两有交,自然导出矛盾.</p>
<p>介质定理还有两个推论:</p>
<ol type="1">
<li><strong>介值定理的推论1</strong>:设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义且连续,那么<span class="math inline">\([f(a),f(b)]\subseteq\)</span>其值域.</li>
<li><strong>介值定理的推论2</strong>:单调连续函数的反函数仍然是单调连续函数.</li>
</ol>
<p>推论(1)显然,考虑推论(2)的证明:</p>
<p>考虑对于连续单增函数<span class="math inline">\(f(x)\in
C(a,b),\alpha=f(a+0),\beta=f(b-0)\)</span>.先要证明其存在反函数<span class="math inline">\(\varphi\in C(\alpha,\beta)\)</span>.</p>
<p>这里有一点小问题是我们要用介值定理要把定义域控制在闭区间,但这当然是好做的,对于任何一个<span class="math inline">\(c\in (a,b)\)</span>,你一定可以取一个<span class="math inline">\(a_1,b_1\)</span>使得<span class="math inline">\(f(a_1)&lt; f(c)&lt; f(b_1)\)</span>,这样<span class="math inline">\(f(x)\in C[a_1,b_1]\)</span>.</p>
<p>这样的话容易说明<span class="math inline">\(f\)</span>是<span class="math inline">\((a,b)\rightarrow
(\alpha,\beta)\)</span>的双射,于是反函数是存在的.反函数的单调性是好证的.</p>
<p>对于反函数的连续性,反证,假设其在某一点<span class="math inline">\(c\in
(\alpha,\beta)\)</span>处不连续,必然意味着<span class="math inline">\(a&lt;\varphi(c-0)&lt;\varphi(c+0)&lt;b\)</span>.此时容易说明<span class="math inline">\(\varphi(x)\in (a,b)\setminus
(\varphi(c-0),\varphi(c+0))\cup\{\varphi(c)\}\)</span>,那只需要取<span class="math inline">\(w\in
(\varphi(c-0),\varphi(c+0))\setminus\{\varphi(c)\}\)</span>,<span class="math inline">\(\nexists
x,\varphi(x)=w\)</span>,这当然与我们上述结论不符.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于连续函数<span class="math inline">\(f\in C[a,b],\forall x_0\in
[a,b]\setminus \Q,\varlimsup _{\Delta x\rightarrow
0+0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}\geq 0\)</span>,求证:<span class="math inline">\(f\)</span>单调递增.</p>
<p>先考虑把条件改成<span class="math inline">\(\forall x_0\in
[a,b]\)</span>怎么做.</p>
<p>一个想法是反证,如果不单调的话,找一个点使得它的右上导数小于<span class="math inline">\(0\)</span>.最自然的想法是找最大值,但最大值有可能只能证明右上导数<span class="math inline">\(\leq
0\)</span>.所以有一个想法是拿一条稍微斜一点(也就是斜率为较小的负数)的直线去截整个曲线.</p>
<p>下面反证,如果其不单增,总能找到两个点<span class="math inline">\(a&#39;&lt;b&#39;\)</span>,使得<span class="math inline">\(f(a&#39;)&gt;f(b&#39;)\)</span>.此时任意取一个<span class="math inline">\(\epsilon_0&lt;f(a&#39;)-f(b&#39;)\)</span>,然后取一个点<span class="math inline">\(B=(b&#39;,f(b&#39;)+\epsilon_0)\)</span>.当然可以再取一个<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(\epsilon+\epsilon_0&lt;f(a&#39;)-f(b&#39;)\)</span>,然后取一个点<span class="math inline">\(A=(a&#39;,f(b&#39;)+\epsilon_0+\epsilon)\)</span>,这样<span class="math inline">\(AB\)</span>这条直线确定了一条斜率<span class="math inline">\(k&lt;0\)</span>的一次函数<span class="math inline">\(g(x)\)</span>,不妨设<span class="math inline">\(h(x)=f(x)-g(x)\)</span>,容易发现<span class="math inline">\(h(a&#39;)&gt;0,h(b&#39;)&lt;0\)</span>,所以可以取一个变号零点<span class="math inline">\(x_\epsilon=\sup\{x|h(x)\geq 0,x\in
[a&#39;,b&#39;]\}\)</span>.当<span class="math inline">\(\epsilon\)</span>取值不一样的时候当然可以取不同的而且是不可数个<span class="math inline">\(x_\epsilon\)</span>,此时可以取出一个无理数<span class="math inline">\(x_0\)</span>,那考虑<span class="math inline">\(\varlimsup _{\Delta x\rightarrow
0+0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}=\varlimsup_{\Delta
x\rightarrow 0+0} \frac{h(x_0+\Delta x)}{\Delta x}+k\leq
k&lt;0\)</span>,这就矛盾了.</p>
<h5><span id="有界定理">有界定理</span></h5>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义且连续,<span class="math inline">\(\exists A,B\)</span>,<span class="math inline">\(\forall x_0\in[a,b],A\leq f(x_0)\leq
B\)</span>.</p>
<p>可以用之前的有限覆盖定理所证明的闭区间上的局部有界函数是有界函数,然后还有另一个证明:</p>
<p>假设无界,则存在一个数列<span class="math inline">\(\{x_n\}\)</span>使得<span class="math inline">\(|f(x_n)|\rightarrow +\infty\)</span>.由于<span class="math inline">\(\{x_n\}\)</span>是有界数列,其一定有收敛子列<span class="math inline">\(\{x&#39;_n\}\)</span>收敛于<span class="math inline">\(x&#39;\)</span>,当然<span class="math inline">\(|f(x&#39;)|=\lim_{n\rightarrow
\infty}|f(x_n)|=+\infty\)</span>,这当然产生了矛盾.</p>
<p>还有一个闭区间套的证明方式:你考虑每次区间分两半,一定有其中一半是无界的,然后做闭区间套.</p>
<h5><span id="最值定理">最值定理</span></h5>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义且连续,<span class="math inline">\(\exists x_1,x_2\in[a,b]\)</span>,<span class="math inline">\(\forall x_0\in[a,b],f(x_1)\leq f(x_0)\leq
f(x_2)\)</span>.</p>
<p>考虑先用有界定理得知<span class="math inline">\(f(x)\in
C[a,b]\)</span>有界,然后就可以拿到其上下确界<span class="math inline">\(m\leq f(x)\leq
M\)</span>,只需证明其上下确界均能取到就行.</p>
<p>反证,考虑若<span class="math inline">\(M\)</span>取不到,那考虑定义<span class="math inline">\(g(x)=\frac{1}{M-f(x)}&gt;0\)</span>,根据有界定理<span class="math inline">\(g(x)\)</span>有上界<span class="math inline">\(C\)</span>,于是<span class="math inline">\(\frac{1}{M-f(x)}\leq C\Rightarrow f(x)\leq
M-\frac{1}{C}\)</span>,矛盾.</p>
<p>或者我们知道<span class="math inline">\(M\)</span>是上确界则<span class="math inline">\(M-\frac{1}{n}\)</span>不是上界,取出<span class="math inline">\(\{x_n\}\)</span>使得<span class="math inline">\(M-\frac{1}{n}&lt;f(x_n)\leq M\)</span>,那么<span class="math inline">\(\{x_n\}\)</span>必然有收敛子列,设其收敛于<span class="math inline">\(x_0\)</span>,那么根据夹逼定理必然能得到<span class="math inline">\(f(x_0)=M\)</span>.</p>
<h5><span id="康托尔定理">康托尔定理</span></h5>
<p>有界闭区间上的连续函数必然一致连续.</p>
<p>考虑反证,反命题是<span class="math inline">\(\exists
\epsilon_0&gt;0,\forall n&gt;0,\exists
x&#39;_n,x&#39;&#39;_n,|x&#39;_n-x&#39;&#39;_n|&lt;\frac{1}{n},|f(x&#39;_n)-f(x&#39;&#39;_n)|\geq
\epsilon_0\)</span>.</p>
<p>用致密性定理,取出<span class="math inline">\(\{x&#39;_n\}\)</span>的收敛子列,可以拿到<span class="math inline">\(\{x&#39;&#39;_n\}\)</span>与其对应的数列,二者必然同时收敛于一个值<span class="math inline">\(x_0\)</span>,那么<span class="math inline">\(|f(x&#39;_n)-f(x&#39;&#39;_n)|=0\geq
\epsilon_0\)</span>,当然矛盾.</p>
<p>如果是开区间呢?如果<span class="math inline">\(f(x)\in
C(a,b]\)</span>,其在开区间<span class="math inline">\((a,b]\)</span>上一致连续,这需要等价于<span class="math inline">\(\forall x_n\in (a,b),x_n\rightarrow
a\)</span>,<span class="math inline">\(\{f(x_n)\}\)</span>是柯西列(也就是<span class="math inline">\(f(a+0)\)</span>极限存在),由此看出开区间上的一致连续函数必然能延拓称闭区间上的连续函数.</p>
<h4><span id="不动点和周期点">不动点和周期点</span></h4>
<p>定义<span class="math inline">\(f(x)\)</span>的<strong>不动点</strong><span class="math inline">\(\text{fix} f(x)\Leftrightarrow
f(x)=x\)</span>,<strong>周期点</strong><span class="math inline">\(P_n=\{x|f^{[n]}(x)=x\and \forall
0&lt;m&lt;n,f^{[m]}(x)\ne x\}\)</span>,其中<span class="math inline">\(f^{[n]}(x)\)</span>表示将<span class="math inline">\(f\)</span>复合<span class="math inline">\(n\)</span>次.</p>
<h5><span id="压缩映照原理">压缩映照原理</span></h5>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义并且<span class="math inline">\(f([a,b])\subseteq [a,b]\)</span>,并且满足<span class="math inline">\(\exists 0\leq q&lt;1,\forall x,y\in
[a,b],|f(x)-f(y)|\leq q|x-y|\)</span>,那么<span class="math inline">\([a,b]\)</span>上存在唯一的不动点<span class="math inline">\(c\)</span>.</p>
<p>任取一个点<span class="math inline">\(x_0\in [a,b]\)</span>,考虑<span class="math inline">\(x_{n+1}=f(x_n)\)</span>,然后尝试判断这个数列的极限,注意到:
<span class="math display">\[
|x_{n+1}-x_n|=|f(x_n)-f(x_{n-1})|\leq q|x_n-x_{n-1}|\leq
q^{n}|x_1-x_0|\\
|x_{n+p}-x_n|\leq \sum_{k=1}^p|x_{n+k}-x_{n+k-1}|\\\leq
\sum_{k=0}^{p-1}q^{n+k}|x_1-x_0|=|x_1-x_0|q^n\frac{1-q^{p}}{1-q}
\]</span> 所以<span class="math inline">\(\{x_n\}\)</span>是柯西列,其极限存在,取<span class="math inline">\(c=\lim x_n\)</span>,容易发现: <span class="math display">\[
|f(x_n)-f(c)|\leq q|x_n-c|
\]</span> 两边取极限得知<span class="math inline">\(f(c)=c\)</span>,于是<span class="math inline">\(c\)</span>是一个不动点.如果还存在一个不动点<span class="math inline">\(c&#39;\ne c\)</span>,那么: <span class="math display">\[
|c-c&#39;|=|f(c)-f(c&#39;)|\leq q|c-c&#39;|
\]</span> 不符.</p>
<h5><span id="李-约克定理">李-约克定理</span></h5>
<p>对于一个<span class="math inline">\(f(x)\in C[a,b]\)</span>,如果<span class="math inline">\(P_3\ne \empty\)</span>,那么<span class="math inline">\(\forall n\in \N_+\)</span>,<span class="math inline">\(P_n\ne \empty\)</span>.</p>
<h6><span id="引理一">引理一</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(G:J\rightarrow \R\)</span>是连续函数,<span class="math inline">\(\forall I=[a,b]\subseteq G(J)\)</span>,<span class="math inline">\(\exists Q=[a&#39;,b&#39;]\subseteq
J,G(Q)=I\)</span>.</p>
<p>根据介值定理,当然存在一对点<span class="math inline">\(p,q\)</span>,<span class="math inline">\(I=[G(p),G(q)]\)</span>.不妨设<span class="math inline">\(p&lt;q\)</span>,那么<span class="math inline">\(a&#39;=\sup \{x\in
[p,q]|G(x)=G(p)\},b&#39;=\inf\{x\in
[a&#39;,q]|G(x)=G(q)\}\)</span>即可.</p>
<p>换言之,我们可以拿到一个区间使得它的像正是我们想要的区间.感性理解的话我们可以对一个区间求原像并且原像当然也是一个区间.那我们自然可以对区间进行迭代.这样迭代的区间有什么性质么?</p>
<h6><span id="引理二">引理二</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(F:J\rightarrow
J\)</span>是连续函数,取一列闭区间<span class="math inline">\(I_n\)</span>,满足<span class="math inline">\(\forall n\geq 0,I_n\subseteq J,I_{n+1}\subseteq
F(I_n)\)</span>.不妨把这种区间列记作<span class="math inline">\(I_0\Rightarrow I_1\Rightarrow I_2\Rightarrow
\cdots\)</span>.</p>
<p>那么我们可以找到一列闭区间<span class="math inline">\(I_0=Q_0\supseteq Q_1\supseteq
Q_2\cdots\)</span>,<span class="math inline">\(\forall n\geq
0\)</span>,有<span class="math inline">\(F^{[n]}(Q_n)=I_n\)</span>.</p>
<p>考虑数学归纳,假设对于<span class="math inline">\(\leq
n\)</span>的都已经满足,现在有<span class="math inline">\(I_{n+1}\subseteq
F(I_n)=F^{[n+1]}(Q_n)\)</span>,令<span class="math inline">\(G=F^{[n+1]}\)</span>然后用引理一就可以.</p>
<p>这个引理的意义在于,<span class="math inline">\(\{I_n\}\)</span>当然不必是一条链,但是只要其满足一定的性质,我们就可以在它们中找到一条链,也就是每迭代一次都可能会将射出去的那个集合变小,或者是射出需要的集合所需要的初始集合变小.</p>
<p>这个当然也是给我们求原像的机会.我们尝试感性理解一下这个在干什么:</p>
<p>如果一个函数操作完一个区间后会把这个区间变小,那显然我如果想求<span class="math inline">\(F^{[-n]}(I)\)</span>,<span class="math inline">\(n\)</span>越大得到的原像就越大对吧.反之,如果会把这个区间变大,那<span class="math inline">\(n\)</span>越大得到的原像就越小对吧.</p>
<p>这个讨论显然是不好的,我们得想办法刻画一下这个东西.那当然要在这里蕴含一个<span class="math inline">\(F\)</span>本身.</p>
<p>于是用上面的定义会发现,即使<span class="math inline">\(F\)</span>会把这个区间扩张到奇怪的大小,只要我们能把它缩回去,那不断取原像的过程照样是可行的.</p>
<h6><span id="引理三">引理三</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(G:J\rightarrow \R\)</span>是连续函数,<span class="math inline">\(I\subseteq J\)</span>是闭区间,并且<span class="math inline">\(I\subseteq G(I)\)</span>或者<span class="math inline">\(G(I)\subseteq I\)</span>,都可以推出<span class="math inline">\(\exists p\in I,G(p)=p\)</span>.</p>
<p>只需构造函数<span class="math inline">\(H(x)=x-G(x)\)</span>然后用介值定理即可.</p>
<h6><span id="李-约克定理">李-约克定理</span></h6>
<p>设<span class="math inline">\(q_3\in P_3\)</span>,则<span class="math inline">\(F(q_3),F(F(q_3))\in
P_3\)</span>,容易看出,这三个点中必然有一个点<span class="math inline">\(a\in P_3\)</span>,使得<span class="math inline">\(a,b=F(a),c=F(F(a))\)</span>这三个数单调递增或单调递减.不妨设<span class="math inline">\(a&lt;b&lt;c\)</span>.</p>
<p>下面证明对于任意<span class="math inline">\(k&gt;0\)</span>,存在<span class="math inline">\(k\)</span>周期点.</p>
<p>我们接下来取<span class="math inline">\(K=[a,b],L=[b,c]\)</span>,立刻由介值定理发现<span class="math inline">\(F(K)\supseteq L\)</span>以及<span class="math inline">\(F(L)\supseteq [a,c]=K\cup L\)</span>.</p>
<p>接下来我们开始构造一列满足引理二的闭区间,我们考虑:</p>
<ol type="1">
<li>当<span class="math inline">\(k=1\)</span>的时候,我们直接取<span class="math inline">\(\forall n,I_n=L\)</span>.</li>
<li>当<span class="math inline">\(k&gt;1\)</span>的时候,取<span class="math inline">\(I_n=\begin{cases}K&amp;n\equiv 0\pmod
k\\L&amp;otherwise\end{cases}\)</span></li>
</ol>
<p>现在我们可以用引理二立刻拿到区间列<span class="math inline">\(\{Q_n\}\)</span>,我们发现<span class="math inline">\(Q_k\subseteq
Q_0=I_0=I_k=F^{[k]}(Q_k)\)</span>,根据引理三立刻得到<span class="math inline">\(\exists q\in Q_k,F^{[k]}(q)=q\)</span>.</p>
<p>那么这个<span class="math inline">\(q\)</span>有没有可能存在更小的周期<span class="math inline">\(d\)</span>呢?如果有的话,不妨取其中最小的那个<span class="math inline">\(d\)</span>,辗转相除一下自然有<span class="math inline">\(d|k\)</span>,那么当然要有<span class="math inline">\(F^{[k]}(q)=F^{[k-d]}(q)=q\)</span>.</p>
<p>此时我们发现<span class="math inline">\(q\in Q_k\subseteq
Q_{k-d}\)</span>,<span class="math inline">\(q\in I_{k}\cap
I_{k-d}=K\cap L=\{b\}\)</span>,于是<span class="math inline">\(F^{[k]}(q)=b,F^{[k+1]}(q)=c,F^{[k+2]}(q)=a\)</span>.</p>
<p>这说明此时<span class="math inline">\(d=3\)</span>.</p>
<p>而当<span class="math inline">\(k\geq 4\)</span>的时候,<span class="math inline">\(F^{[k+2]}(q)=a\notin L\)</span>,这当然与<span class="math inline">\(I_{k+2}=L\)</span>矛盾.</p>
<p>仔细观察一下上面的过程,我们到底依赖于什么东西得到了这个?</p>
<p>首先找到<span class="math inline">\(q\)</span>使得<span class="math inline">\(F^{[k]}(q)=q\)</span>这个其实反而并不是最主要的,因为只要<span class="math inline">\(F(q)=q\)</span>那么显然<span class="math inline">\(F^{[k]}(q)=q\)</span>,真正离谱的是竟然要让这个点在之前从未跳到过<span class="math inline">\(q\)</span>.这也是这个证明的最精髓的部分,那就是证明任何一个<span class="math inline">\(d&lt;q\)</span>都不是周期.</p>
<p>那我们考虑取一个区间(也就是<span class="math inline">\(K\)</span>),在<span class="math inline">\(K\)</span>中取一个合法的<span class="math inline">\(q\)</span>,然后我们只要找到一个闭区间(也就是<span class="math inline">\(Q_k\subseteq K\)</span>),使得它当且仅当复合<span class="math inline">\(k\)</span>次的时候才会打到<span class="math inline">\(K\)</span>上,在其它时候都得打在<span class="math inline">\(K\)</span>的外面(在这里是<span class="math inline">\(L\)</span>)上,那自然是可行的了对吧.而数字<span class="math inline">\(3\)</span>恰好完美地给出了这个构造.</p>
<p>如果我们再总结一下上面的过程,我们需要找到两个区间<span class="math inline">\(K,L\)</span>,找到一个<span class="math inline">\(Q_k\subseteq K\)</span>,使得<span class="math inline">\(F^k(Q_k)\)</span>可以打到<span class="math inline">\(K\)</span>上但是对于<span class="math inline">\(d&lt;k\)</span>,<span class="math inline">\(F^d(Q_k)\)</span>打到<span class="math inline">\(L\)</span>上.于是根据引理三其存在<span class="math inline">\(k\)</span>周期点,但是几乎不可能存在<span class="math inline">\(d\)</span>周期点(这里就需要简单判断一下<span class="math inline">\(L\cap K\)</span>的部分了)</p>
<p>这样的<span class="math inline">\(K\)</span>和<span class="math inline">\(L\)</span>怎么构造呢?如果我们构造<span class="math inline">\(F(K)\)</span>打到<span class="math inline">\(L\)</span>上,<span class="math inline">\(F(L)\)</span>打到<span class="math inline">\(K\)</span>上显然是吧不合理的,那就可以一个打到另一个,另一个打到全集上再用引理一缩一下,这个看上去合理多了.这当然就是<span class="math inline">\(F(K)\supseteq L\)</span>以及<span class="math inline">\(F(L)\supseteq [a,c]=K\cup L\)</span>.</p>
<h5><span id="sharkovskii定理">Sharkovskii定理</span></h5>
<p>定义如下的一种序关系<span class="math inline">\(\prec\)</span>(称为Sharkovskii序): <span class="math display">\[
3\prec 5\prec 7\prec \cdots \\
\prec 2\times 3\prec 2\times 5\prec \cdots \\
\cdots\\
\prec 2^k\times 3\prec 2^k\times 5\prec \cdots \\
\cdots\\
\cdots\prec 2^n\prec 2^{n-1}\prec \cdots\prec 4\prec 2\prec 1
\]</span> 对于<span class="math inline">\(f(x)\in
C[l,r],f:[l,r]\rightarrow [l,r]\)</span>.那么如果<span class="math inline">\(m\prec n,P_m\ne \empty\Rightarrow P_n\ne
\empty\)</span>.</p>
<p>(首先发现当然存在不动点)</p>
<p>这咋办呢?我们刚才用了<span class="math inline">\(3\)</span>的最重要的性质就是<span class="math inline">\(3\)</span>个点可以排成有序的一列,如果有类似的引理,那我们就可以尝试推广上面的结论.</p>
<h6><span id="引理">引理</span></h6>
<p>设<span class="math inline">\(f:I\rightarrow
I\)</span>是连续函数,<span class="math inline">\(f\)</span>有<span class="math inline">\(2n+1\)</span>周期点但无更小非一奇数阶周期点,我们取出其一个周期轨<span class="math inline">\(x_0\rightarrow x_1\rightarrow \cdots
x_{2n}\)</span>,必有以下两者成立其一:</p>
<ol type="1">
<li><span class="math inline">\(x_{2n}&lt;x_{2n-2}&lt;\cdots
&lt;x_2&lt;x_0&lt;x_1&lt;\cdots &lt;x_{2n-3}&lt;x_{2n-1}\)</span>.</li>
<li><span class="math inline">\(x_{2n}&gt;x_{2n-2}&gt;\cdots
&gt;x_2&gt;x_0&gt;x_1&gt;\cdots &gt;x_{2n-3}&gt;x_{2n-1}\)</span>.</li>
</ol>
<p>这个引理怎么证明呢?考虑把周期轨排一下序然后归纳,我们不妨假设排好序后的结果是<span class="math inline">\(y_0&lt;y_1&lt;\cdots&lt;y_{2n}\)</span>.</p>
<p>如果引理成立,(第一种情况下)取<span class="math inline">\(I_0=[x_0,x_1]\)</span>,则<span class="math inline">\(I_0\Rightarrow I_0\)</span>.容易发现其实只有<span class="math inline">\(I_0\)</span>有这个性质,那我们不妨来看看满足<span class="math inline">\([y_k,y_{k+1}]\Rightarrow
[y_k,y_{k+1}]\)</span>的情况是什么样子的,尝试去满足<span class="math inline">\([f(y_{k+1}),f(y_{k})]\supseteq
[y_k,y_{k+1}]\)</span>.这个时候注意到我们可以把所有点分成两类:满足<span class="math inline">\(f(y_i)\geq y_{i+1}\)</span>(称为<span class="math inline">\(\alpha\)</span>类点,容易见到这里也就等价于<span class="math inline">\(f(y_i)&gt;y_i\)</span>)和<span class="math inline">\(f(y_i)\leq y_{i-1}\)</span>(称为<span class="math inline">\(\beta\)</span>类点)的.那我们就是要找到一个<span class="math inline">\(k\)</span>使得<span class="math inline">\(y_k\)</span>是<span class="math inline">\(\alpha\)</span>类点并且<span class="math inline">\(y_{k+1}\)</span>是<span class="math inline">\(\beta\)</span>类点.</p>
<p>由于<span class="math inline">\(f(y_0)\geq y_1,f(y_{2n})\leq
y_{2n-1}\)</span>,这两类点显然都有,那就一定存在交界的地方,这样我们就可以拿出这个分界的地方记作<span class="math inline">\(I_0=[y_k,y_{k+1}]\)</span>,其中<span class="math inline">\(y_k\)</span>是<span class="math inline">\(\alpha\)</span>类点,<span class="math inline">\(y_{k+1}\)</span>是<span class="math inline">\(\beta\)</span>类点.</p>
<p>我们不妨定义一个集合<span class="math inline">\(S\)</span>的张成区间<span class="math inline">\(A\)</span>为<span class="math inline">\(A=[\inf
S,\sup S]\)</span>,那我们现在取<span class="math inline">\(S_0=\{y_k,y_{k+1}\}\)</span>,设周期轨为<span class="math inline">\(O_f=\{x_0,\cdots
x_{2n}\}\)</span>,我们递归定义<span class="math inline">\(S_{k+1}=f(A_k)\cap
O_f\)</span>,容易根据上面对<span class="math inline">\(S_0\)</span>的构造发现<span class="math inline">\(S_0\subsetneq S_1\)</span>,并且<span class="math inline">\(S_k\)</span>中因为取了一段极大的区间(但并没有包含所有周期点),所以一定能跳出这个区间(不然这个区间内部就可以自己射自己),所以<span class="math inline">\(S_k\subsetneq S_{k+1}\)</span>.</p>
<p>那由此我们当然可以得到一条链: <span class="math display">\[
S_0\subsetneq S_1\subsetneq \cdots\subsetneq S_t=O_f
\]</span> 按理来说应该有<span class="math inline">\(t=2n-1\)</span>(这就会给出每次<span class="math inline">\(S\)</span>扩张只会多一个数),让我们先来证明这个结论:</p>
<p>反证,假设<span class="math inline">\(t&lt;2n-1\)</span>,尝试找到一个更小的奇数周期来推出矛盾,不妨尝试找到一个<span class="math inline">\(2n-1\)</span>的周期(当然,如果<span class="math inline">\(2n+1=3\)</span>的话,这个结论我们在李约克定理已经证明了,所以下面假设<span class="math inline">\(2n+1\geq 5\)</span>).</p>
<p>我不说你也知道我要干啥,我们考虑在末尾补<span class="math inline">\(2n-t-1\)</span>个<span class="math inline">\(A_t\)</span>,并把最后一个缩成<span class="math inline">\(A_0\)</span>,当然有: <span class="math display">\[
A_0\Rightarrow A_1\Rightarrow A_2\Rightarrow\cdots\Rightarrow
A_t\Rightarrow A_t\supseteq A_0
\]</span>
但这样并不太行,因为这些区间的交不是空的,我们起码得把其中的一个区间给挪出去,不妨考虑改掉最后一个<span class="math inline">\(A_t\)</span>,试图取一个<span class="math inline">\(l\ne k\)</span>使得<span class="math inline">\([y_l,y_{l+1}]\Rightarrow
A_0=[y_k,y_{k+1}]\)</span>.如果我们结合一下下面的主定理的证明部分,其实我们可以发现这里的<span class="math inline">\([y_l,y_{l+1}]\)</span>也就是<span class="math inline">\(I_{2n-1}\)</span>.</p>
<p>我们上面已经保证了<span class="math inline">\(f(y_{k+1})\leq
y_k\)</span>,如果有<span class="math inline">\(f(y_{k+2})\geq
y_{k+1}\)</span>,那当然可以取<span class="math inline">\(l=k+1\)</span>.也就是如果我们的这一列点类别中出现了<span class="math inline">\(\alpha\beta\alpha\)</span>这样的结构就完事了.如果找不到,那说明<span class="math inline">\(f(y_{k+2})\leq
y_{k+1}\)</span>.我们继续往后找,如果可以遇到第一个$f(y_i)y_{k+1} <span class="math inline">\(,那\)</span>[y_{i-1},y_i]<span class="math inline">\(自然是满足条件的.如果一直都找不到,说明始终有\)</span>f(y_i)&lt;
y_{k+1}y_{i-1},i<span class="math inline">\(,那说明后面全是\)</span>$点.</p>
<p>同理如果出现了<span class="math inline">\(\beta\alpha\beta\)</span>这样的结构也找到了.不然类似同理,如果一直找不到就说明前面全是<span class="math inline">\(\alpha\)</span>点,前面的点始终满足<span class="math inline">\(f(y_i)\geq y_{k+1},i\in [0,k]\)</span>.</p>
<p>这已经推导出了矛盾,因为我们发现前面的点射到后面,后面的点射到前面,问题在于前面有<span class="math inline">\(k+1\)</span>个点,后面有<span class="math inline">\(2n-k\)</span>个点,于是<span class="math inline">\(k+1= 2n-k\Rightarrow
2k+1=2n\)</span>,这导出了矛盾.</p>
<p>所以确实可以找到这样的<span class="math inline">\(l\ne
k,[y_l,y_{l+1}]\Rightarrow
[y_k,y_{k+1}]\)</span>,那我们用上面的区间列自然可以推导出存在一个<span class="math inline">\(2n-1\)</span>周期点(或者其因子周期点,不过那也导出矛盾了).</p>
<p>于是<span class="math inline">\(t=2n-1\)</span>,这表示我们拿到的这条链<span class="math inline">\(S_0\subsetneq S_1\subsetneq \cdots\subsetneq
S_t=O_f\)</span>每次只增加一个元素.如果<span class="math inline">\(S_0\)</span>到<span class="math inline">\(S_1\)</span>是只增加了一个元素,当然说明<span class="math inline">\(f(y_k)=y_{k+1}\)</span>或者<span class="math inline">\(f(y_{k+1})=y_k\)</span>.两者的证明是一样的,不妨设<span class="math inline">\(f(y_k)=y_{k+1}\)</span>.</p>
<p>此时我们取<span class="math inline">\(x_0=y_k,x_1=y_{k+1}\)</span>,此时其实也可以发现<span class="math inline">\(x_2&lt;x_0&lt;x_1\)</span>.并且根据上面的说法,我们知道<span class="math inline">\(A_{k}\subsetneq
A_{k+1}\)</span>,那这个扩张一定是每次在边界上往外跑一个,也就是每次取一个新的迭代出来的结果扔到左边或者扔到右边.</p>
<p>网络上有关于这一点的证明往往是反证,假设不按规则走的话然后去尝试构造三周期点推到矛盾,但我们这里给出另一个证明方法:</p>
<p>考虑由于每次只增大一个数,那么如果我们能证明这一列<span class="math inline">\(y\)</span>形如<span class="math inline">\(\alpha\cdots\alpha\beta\cdots\beta\)</span>的形式就做完了,这等价于<span class="math inline">\(I_0\)</span>的唯一性.</p>
<p>假设还有另一个区间也满足要求,对于这个新的区间,我们设其是<span class="math inline">\([y_l,y_{l+1}]\)</span>,我们再拿一个周期点<span class="math inline">\(y_{l+2}\)</span>出来,假设这三个数按照顺序是<span class="math inline">\(a&lt;b&lt;c\)</span>,那么根据上面的结论一定有<span class="math inline">\(b\rightarrow c\rightarrow a\)</span>或者<span class="math inline">\(b\rightarrow a\rightarrow
c\)</span>成立,这就说明<span class="math inline">\(b\)</span>被夹在了中间.而我们从一个<span class="math inline">\(I_0\)</span>扩张当然是逐步的,会将<span class="math inline">\(x_3,x_4\cdots\)</span>逐个加入,这必然意味着在<span class="math inline">\(b\)</span>加入之前,<span class="math inline">\(a,c\)</span>中已经有一个加进去了,但这是不可能的,只有<span class="math inline">\(b\)</span>加入后才能把<span class="math inline">\(a,c\)</span>给加进去.</p>
<h6><span id="sharkovskii定理">sharkovskii定理</span></h6>
<p>有了引理就可以开始类比了,不妨假设<span class="math inline">\(x_{2n}&lt;x_{2n-2}&lt;\cdots
&lt;x_2&lt;x_0&lt;x_1&lt;\cdots &lt;x_{2n-3}&lt;x_{2n-1}\)</span>.</p>
<p>现在我们要取区间列了,显然有一些奇偶对跳的现象,事实上我们取<span class="math inline">\(I_0=[x_0,x_1],I_{2k-1}=[x_{2k},x_{2k-2}],I_{2k}=[x_{2k-1},x_{2k+1}]\)</span>显然就是满足条件的.而且这些区间除了端点外完全不相交(而且任意三个区间的交都是空集).这一列一共有<span class="math inline">\(2n\)</span>个区间.我们事实上可以取<span class="math inline">\(J=[x_{0},x_{2n-1}]=\bigcup
I_{2k}\)</span>放到整个区间的最后.</p>
<p>接下来我们用这些东西去对于多种情况来对跳.</p>
<p><strong>Case1</strong></p>
<p>(假设<span class="math inline">\(2n+1\)</span>是最小的非空的非一奇数周期)首先证明<span class="math inline">\(P_{2n+1}\ne \empty\Rightarrow \forall
0&lt;k,P_{k+2n}\ne \empty\)</span>.</p>
<p>在前面补<span class="math inline">\(k\)</span>个<span class="math inline">\(I_0\)</span>,在最后也补一个<span class="math inline">\(I_0\)</span>,构造区间列: <span class="math display">\[
I_0\Rightarrow I_0\Rightarrow \cdots\Rightarrow I_0\Rightarrow
I_1\Rightarrow I_2\Rightarrow \cdots\Rightarrow I_{2n-1}\Rightarrow I_0
\]</span> 也就是在前面补<span class="math inline">\(I_0\)</span>直到整个区间列的数量为<span class="math inline">\(k+2n+1\)</span>,此时当然存在<span class="math inline">\(x_0\in Q_{k+2n}\)</span>使得<span class="math inline">\(f^{[k+2n]}(x_0)=x_0\)</span>,只需证明<span class="math inline">\(\nexists d|(k+2n)\)</span>,<span class="math inline">\(f^{[d]}(x_0)=x_0\)</span>即可.这当然好证,因为<span class="math inline">\(d\leq \frac{k+2n}{2}\leq
\max(k,2n)\)</span>,因为你只需要把它卡在那一堆<span class="math inline">\(I_0\)</span>和<span class="math inline">\(I_k\)</span>的分界线上就行.</p>
<p><strong>Case2</strong></p>
<p>(假设<span class="math inline">\(2n+1\)</span>是最小的非空的非一奇数周期)接下来我们来证明<span class="math inline">\(P_{2n+1}\ne \empty\Rightarrow \forall
0&lt;m,P_{2m}\ne \empty\)</span>.</p>
<p>当<span class="math inline">\(2m&gt;2n+1\)</span>的时候我们已经证完了,接下来考虑<span class="math inline">\(2m&lt;2n+1\)</span>的情况.</p>
<p>由于<span class="math inline">\(\forall k,I_{2n-1}\Rightarrow
I_{2k}\)</span>,我们考虑取出<span class="math inline">\(2m+1\)</span>个区间列,恰好有: <span class="math display">\[
I_{2n-2m}\Rightarrow I_{2n-2m+1}\Rightarrow \cdots\Rightarrow
I_{2n-1}\Rightarrow I_{2n-2m}
\]</span> 接下来就是简单说明的过程了.</p>
<p><strong>Case3</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{4}\ne \empty\Rightarrow
P_2\ne \empty\)</span>.</p>
<p>这个证明就比较无聊了,我们进行暴力讨论,不妨假设<span class="math inline">\(a&lt;b&lt;c&lt;d\)</span>,那么:</p>
<ol type="1">
<li><span class="math inline">\(a\rightarrow b\rightarrow c\rightarrow
d\rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([a,b]\Rightarrow [b,c]\Rightarrow
[c,d]\Rightarrow [a,d]\supseteq
[a,b]\)</span>,于是可证明有三周期点,当然有二周期点.</p>
<ol start="2" type="1">
<li><span class="math inline">\(a\rightarrow b\rightarrow d\rightarrow
c\rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([a,b]\Rightarrow [b,d]\Rightarrow
[c,d]\Rightarrow [a,c]\supseteq
[a,b]\)</span>,于是可证明有三周期点,当然有二周期点.</p>
<ol start="3" type="1">
<li><span class="math inline">\(a\rightarrow c\rightarrow b\rightarrow
d\rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([a,b]\Rightarrow [c,d]\Rightarrow
[a,b]\)</span>,当然有二周期点.</p>
<ol start="4" type="1">
<li><span class="math inline">\(a\rightarrow c\rightarrow d\rightarrow
b\rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([a,c]\Rightarrow [c,d]\Rightarrow
[b,d]\Rightarrow [a,b]\Rightarrow [a,c]\supseteq [b,c]\Rightarrow
[a,d]\supseteq [a,c]\)</span>.于是有五周期点,于是有二周期点.</p>
<ol start="5" type="1">
<li><span class="math inline">\(a\rightarrow d\rightarrow b\rightarrow
c\rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([a,b]\Rightarrow [c,d]\Rightarrow
[a,b]\)</span>,当然有二周期点.</p>
<ol start="6" type="1">
<li><span class="math inline">\(a\rightarrow d\rightarrow c\rightarrow
b\rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([b,c]\Rightarrow [a,b]\Rightarrow
[a,d]\supseteq [b,c]\)</span>,于是有二周期点.</p>
<p><strong>Case4</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{2^{n+1}}\ne
\empty\Rightarrow P_{2^n}\ne \empty\)</span>.</p>
<p>考虑上面命题等价于<span class="math inline">\(f^{[2^{n-1}]}\)</span>有四周期点,则其有二周期点.</p>
<p><strong>Case5</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{2^{n}p}\ne
\empty\Rightarrow P_{2^nq}\ne \empty\)</span>,其中<span class="math inline">\(p,q\in \text{odd},p&lt;q\)</span>.</p>
<p>考虑<span class="math inline">\(f^{[2^n]}\)</span>有<span class="math inline">\(p\)</span>周期点,当然也就有<span class="math inline">\(q\)</span>周期点.</p>
<p><strong>Case6</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{2^{n}p}\ne
\empty\Rightarrow P_{2^mq}\ne \empty\)</span>,其中<span class="math inline">\(p,q\in \text{odd},m&gt;n\)</span>.</p>
<p>考虑<span class="math inline">\(f^{[2^n]}\)</span>有<span class="math inline">\(p\)</span>周期点,当然也就有<span class="math inline">\(q2^{m-n}\)</span>周期点.</p>
<p><strong>Case7</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{2^{n}p}\ne
\empty\Rightarrow P_{2^m}\ne \empty\)</span>,其中<span class="math inline">\(p\in \text{odd}\)</span>.</p>
<p>选取<span class="math inline">\(N=\max(n+1,m+1)\)</span>,则考虑<span class="math inline">\(f^{[2^n]}\)</span>有<span class="math inline">\(p\)</span>周期点,则其有<span class="math inline">\(2^{N-n}\)</span>周期点,<span class="math inline">\(P_{2^N}\ne \empty\)</span>.于是<span class="math inline">\(P_{2^m}\ne \empty\)</span>.</p>
<h3><span id="导数">导数</span></h3>
<p>设函数<span class="math inline">\(f(x)\)</span>在一个区间<span class="math inline">\((a,b)\)</span>上有定义,对于给定的<span class="math inline">\(x_0\in(a,b)\)</span>,考虑增量<span class="math inline">\(\Delta x\ne 0\and x_0+\Delta
x\in(a,b)\)</span>,则<span class="math inline">\(\Delta y=f(x_0+\Delta
x)-f(x_0)\)</span>称为关于<span class="math inline">\(\Delta
x\)</span>的<strong>增量</strong>.若极限<span class="math inline">\(\lim_{\Delta x\rightarrow 0}\frac{\Delta y}{\Delta
x}\\\)</span>存在则称这个函数在<span class="math inline">\(x_0\)</span>处<strong>可导</strong>,并称这个值为这个函数在<span class="math inline">\(x_0\)</span>处的<strong>导数</strong>或者<strong>微商</strong>,记作<span class="math inline">\(f&#39;(x_0)\)</span>或<span class="math inline">\(\frac{\text df}{\text
dx}|_{x=x_0}\)</span>.同理可以定义出<strong>左导数</strong>和<strong>右导数</strong>.如果某个函数的导数构成一个函数,我们称这个函数为其对应的<strong>导函数</strong>.</p>
<p>显然右可导能推出右连续,左可导能推出左连续.换言之,可导一定连续.</p>
<p>但是连续不一定可导,相当漂亮的一个反例是<span class="math inline">\(f(x)=\begin{cases}0&amp;x=0\\x\sin
\frac{1}{x}&amp;otherwise\end{cases}\)</span>,其在零点没有左右导数.</p>
<p>如果<span class="math inline">\(f\)</span>的<span class="math inline">\(n-1\)</span>次导数存在,记作<span class="math inline">\(f^{(n-1)}(x)\)</span>,如果该函数可导则其导数称作<span class="math inline">\(f^{(n)}(x)\)</span>.</p>
<p>如果<span class="math inline">\(f^{(n)}(x)\)</span>在<span class="math inline">\(I\)</span>上连续,则称<span class="math inline">\(f\in C^{n}(I)\)</span>.如果其任意阶可导,则称<span class="math inline">\(f\in C^{\infty}(I)\)</span>.</p>
<p>特别地,如果称一个函数是<span class="math inline">\(\alpha\)</span>次可导,即<span class="math inline">\(|f(x)-f(y)|\leq|x-y|^\alpha\)</span>.</p>
<h4><span id="导数基本运算">导数基本运算</span></h4>
<p>导数也可以类似求出四则运算以及复合的法则:</p>
<ol type="1">
<li><span class="math inline">\([cf(x)]&#39;=cf&#39;(x)\)</span>.</li>
<li><span class="math inline">\([f(x)\pm g(x)]&#39;=f&#39;(x)\pm
g&#39;(x)\)</span>.</li>
<li><span class="math inline">\([f(x)g(x)]&#39;=f&#39;(x)g(x)+g&#39;(x)f(x)\)</span>.</li>
<li>(莱布尼茨公式):<span class="math inline">\([f(x)g(x)]^{(n)}=\sum_{k=0}^n\binom{n}{k}f^{(k)}(x)g^{(n-k)}(x)\)</span>.</li>
<li><span class="math inline">\([\frac{f(x)}{g(x)}]&#39;=\frac{f&#39;(x)g(x)-g&#39;(x)f(x)}{g^2(x)},g(x)\ne
0\)</span>.</li>
<li><span class="math inline">\([g(f(x))]&#39;=g&#39;(f(x))f&#39;(x)\)</span>.</li>
</ol>
<p>(1)(2)比较平凡.</p>
<p>(3)(4)的证明的话,考虑: <span class="math display">\[
\frac{f(x+\Delta x)g(x+\Delta x)-f(x)g(x)}{\Delta x}\\
=\frac{f(x+\Delta x)-f(x)}{\Delta x}g(x+\Delta x)+f(x)\frac{g(x+\Delta
x)-g(x)}{\Delta x}
\]</span> 取一下极限就行.</p>
<p>(5)的话,其实求出<span class="math inline">\((\frac{1}{g(x)})&#39;\)</span>就行了,我们来看:
<span class="math display">\[
(\frac{1}{g(x)})&#39;=\lim_{\Delta x\rightarrow
0}\frac{\frac{1}{g(x+\Delta x)}-\frac{1}{g(x)}}{\Delta x}\\
=\lim_{\Delta x\rightarrow 0}\frac{\frac{g(x)-g(x+\Delta x)}{g(x+\Delta
x)g(x)}}{\Delta x}\\
=\frac{-g&#39;(x)}{g^2(x)}
\]</span> 对于(6),不妨设<span class="math inline">\(f(x_0)=y_0\)</span>.</p>
<p>当<span class="math inline">\(\Delta y\ne 0\)</span>的时候,我们有:
<span class="math display">\[
\lim_{\Delta y\rightarrow 0}\frac{g(y_0+\Delta y)-g(y_0)}{\Delta
y}=g&#39;(y_0)\\
\lim_{\Delta y\rightarrow 0}[\frac{g(y_0+\Delta y)-g(y_0)}{\Delta
y}-g&#39;(y_0)]=0
\]</span> 令<span class="math inline">\(\eta(\Delta
y)=\frac{g(y_0+\Delta y)-g(y_0)}{\Delta y}-g&#39;(y_0)=\frac{\Delta
z}{\Delta y}-g&#39;(y_0),\Delta y\ne 0\)</span>,那么<span class="math inline">\(\lim_{\Delta y\rightarrow 0}\eta(\Delta
y)=0\)</span>.</p>
<p>此时有: <span class="math display">\[
\frac{\Delta z}{\Delta x}=\frac{\Delta z}{\Delta y}\frac{\Delta
y}{\Delta x}=\eta(\Delta y)\frac{\Delta y}{\Delta
x}+g&#39;(y_0)\frac{\Delta y}{\Delta x}\\
\]</span> 带上极限,前者为<span class="math inline">\(0\)</span>.</p>
<p>但这个讨论<span class="math inline">\(\Delta y\ne
0\)</span>的情况很烦,能不能把这个东西去掉呢?</p>
<p>类似上面的讨论,我们这里有一些无穷小量,而且(除了<span class="math inline">\(\frac{\Delta z}{\Delta
x}\)</span>以外)也不会出现无穷小量之间的除法,用一下当然有,<span class="math inline">\(g(y+\Delta y)-g(y)=(g&#39;(y)+o(1))\Delta
y,f(x+\Delta x)-f(x)=(f&#39;(x)+o(1))\Delta x\)</span>.</p>
<p>考虑: <span class="math display">\[
\Delta z=(g&#39;(y)+o(1))\Delta y\\
=(g&#39;(y)+o(1))(f&#39;(x)+o(1))\Delta x\\
\]</span> 两边除一下<span class="math inline">\(\Delta
x\)</span>两边求极限就行.</p>
<p>不难发现上面的过程等价于啥呢?等价于: <span class="math display">\[
\frac{\text d z}{\text d x}=\frac{\text dz}{\text dy}\frac{\text
dy}{\text dx}
\]</span></p>
<h4><span id="反函数的导数">反函数的导数</span></h4>
<p>我们首先声称:如果$x=(y),’$<span class="math inline">\(\varphi\)</span>有反函数<span class="math inline">\(f=\varphi^{-1}\)</span>.这当然是显然的</p>
<p>然后我们声称:如果<span class="math inline">\(x=\varphi(y)\in
C(c,d)\)</span>,并且其严格单调且连续.如果<span class="math inline">\((x_0,y_0)\)</span>处其导数存在,则<span class="math inline">\(f&#39;(x_0)=\frac{1}{\varphi&#39;(f(x_0))}\)</span>.</p>
<p>这个可以用极限证明,我们有: <span class="math display">\[
f&#39;(x_0)=\lim_{x\rightarrow x_0}\frac{f(x)-f(x_0)}{x-x_0}\\
=\lim_{y\rightarrow y_0}\frac{y-y_0}{\varphi(y)-\varphi(y_0)}\\
=\lim_{y\rightarrow
y_0}\frac{1}{\frac{\varphi(y)-\varphi(y_0)}{y-y_0}}\\
=\frac{1}{\varphi&#39;(y_0)}
\]</span></p>
<p>现在我们证明了反函数有导数,立即有: <span class="math display">\[
f(g(x))=x\Rightarrow f&#39;(x)g&#39;(f(x))=1
\]</span></p>
<h4><span id="隐函数求导">隐函数求导</span></h4>
<p>这里我们不加证明地给出隐函数求导法则,也就是暂且把<span class="math inline">\(y\)</span>当成<span class="math inline">\(x\)</span>的函数.</p>
<h6><span id="example1">Example1</span></h6>
<p>举例的话,我们来看方程: <span class="math display">\[
x=y+\epsilon\sin y
\]</span> 两边对<span class="math inline">\(x\)</span>求导: <span class="math display">\[
1=y&#39;+y&#39;\epsilon \cos y\\
y&#39;=\frac{1}{1+\epsilon\cos y}
\]</span></p>
<h4><span id="参数方程的求导">参数方程的求导</span></h4>
<p>如果<span class="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>,考虑求导<span class="math inline">\(\frac{\text d y}{\text d x}\)</span>.</p>
<p>这个做法就是反函数+链式法则.当然要保证下面需要的地方导数都不是<span class="math inline">\(0\)</span>.</p>
<p>不妨设<span class="math inline">\(t=t(x)\)</span>,当然有<span class="math inline">\(y=y(t(x))\)</span>,那么<span class="math inline">\(\frac{\text d y}{\text d
x}=y&#39;(t(x))t&#39;(x)=\frac{y&#39;(t)}{x&#39;(t)}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>极坐标的求导: <span class="math display">\[
\begin{cases}x=r(\theta)\cos\theta\\y=r(\theta)\sin\theta\end{cases}
\]</span> 当然<span class="math inline">\(\frac{\text d y}{\text d
x}=\frac{r&#39;\sin\theta+r\cos\theta}{r&#39;\cos\theta-r\sin\theta}=\frac{\tan\theta+\frac{r}{r&#39;}}{1-\tan\theta\frac{r}{r&#39;}}=\tan(\theta+\arctan(\frac{r}{r&#39;}))=\tan\alpha\)</span>.</p>
<p>而容易发现<span class="math inline">\(\tan\alpha\)</span>其实是切线和<span class="math inline">\(x\)</span>轴正半轴的夹角.</p>
<h4><span id="初等函数的导数">初等函数的导数</span></h4>
<p>下面给出若干初等函数的导数.</p>
<h5><span id="常函数">常函数</span></h5>
<p>常函数的连续性显然.</p>
<p>导数有: <span class="math display">\[
f(x)=c\Rightarrow f&#39;(x)=0
\]</span></p>
<p>证明显然.</p>
<h5><span id="三角函数">三角函数</span></h5>
<p>三角函数的连续性比较有意思,考虑只需证明<span class="math inline">\(\sin x\)</span>连续即可,使用和差化积得到<span class="math inline">\(|\sin x-\sin x_0|=|2\sin
\frac{x-x_0}{2}\cos\frac{x+x_0}{2}|\leq 2|\sin \frac{x-x_0}{2}|\leq
|x-x_0|\)</span>.</p>
<p>导数有: <span class="math display">\[
\sin&#39;(x)=\cos(x)\\
\cos&#39;(x)=-\sin(x)
\]</span></p>
<p>只给出前者的证明,后者类似,或者换个元做诱导公式也行.</p>
<p>我们有和差化积: <span class="math display">\[
\sin(x+\Delta x)-\sin (x)\\
=2\sin(\frac{\Delta x}{2})\cos(x+\frac{\Delta x}{2})
\]</span> 自然有: <span class="math display">\[
\lim_{\Delta x\rightarrow 0}\frac{\Delta y}{\Delta x}=\lim_{\Delta
x\rightarrow 0}\frac{2\sin(\frac{\Delta x}{2})\cos(x+\frac{\Delta
x}{2})}{\Delta x}\\
=\lim_{\Delta x\rightarrow 0}\frac{\sin(\frac{\Delta
x}{2})}{\frac{\Delta x}{2}}\cos(x+\frac{\Delta x}{2})\\
=\cos(x)
\]</span></p>
<p>进一步,我们可以考虑高阶导数: <span class="math display">\[
(\sin x)^{(n)}=\sin(x+\frac{n\pi}{2})\\
(\cos x)^{(n)}=\cos(x+\frac{n\pi}{2})
\]</span></p>
<p>而考虑<span class="math inline">\((\tan x)&#39;\)</span>,我们有:
<span class="math display">\[
(\tan x)&#39;=\lim_{\Delta x\rightarrow 0}\frac{\frac{\sin (x+\Delta
x)}{\cos(x+\Delta x)}-\frac{\sin x}{\cos x}}{\Delta x}\\
=\lim_{\Delta x\rightarrow 0}\frac{\sin \Delta x}{\Delta x}\frac{1}{\cos
x\cos (x+\Delta x)}\\
=\frac{1}{\cos ^2 x}
\]</span></p>
<h5><span id="反三角函数">反三角函数</span></h5>
<p>使用反函数的导数公式: <span class="math display">\[
\arctan&#39;(x)=\frac{1}{1+x^2}\\
\arccos&#39;(x)=\frac{-1}{\sqrt{1-x^2}}\\
\arcsin&#39;(x)=\frac{1}{\sqrt{1-x^2}}
\]</span></p>
<p>反三角函数的高阶导数比较困难,我们来看个例子:</p>
<p>考虑<span class="math inline">\(y=\arctan x\)</span>,<span class="math inline">\(y&#39;=\frac{1}{1+x^2}=\frac{1}{1+\tan^2 y}=\cos^2
y\)</span>,那么<span class="math inline">\(y&#39;&#39;=-2\cos y\sin
y\times y&#39;=-\cos^2y\sin 2y\)</span>,事实上容易用归纳法证明<span class="math inline">\(y^{(n)}=(n-1)!\cos^n y\sin
(n(y+\frac{\pi}{2}))\)</span>.</p>
<p>不过还有一种办法,那就是我们考虑<span class="math inline">\(y&#39;=-\frac{1}{2i}(\frac{1}{i+x}+\frac{1}{i-x})\)</span>,用这个归纳立刻得到<span class="math inline">\(y^{(n)}=-\frac{(n-1)!}{2i}((i-x)^{-n}-(-1)^n(i+x)^{-n})\)</span>.</p>
<p>然而<span class="math inline">\(y=\arcsin
x\)</span>要麻烦得多.下面我们来看一下: <span class="math display">\[
y&#39;=\frac{1}{\sqrt{1-x^2}}\\
(y&#39;)^2(1-x^2)=1\\
(1-x^2)2y&#39;y&#39;&#39;-2x(y&#39;)^2\equiv 0\\
(1-x^2)2y&#39;&#39;-2xy&#39;\equiv 0
\]</span> 两边求<span class="math inline">\(n-2\)</span>次导,利用莱布尼茨公式,化简后得到:
<span class="math display">\[
(1-x^2)y^{(n)}+(3-2n)xy^{(n-1)}-(n-2)^2y^{(n-2)}\equiv 0
\]</span></p>
<h5><span id="指数函数">指数函数</span></h5>
<p>我们需要首先拿到指数为有理数的东西.</p>
<p>首先整数次方是有定义的,我们需要拿到形如<span class="math inline">\(f(x)=a^{\frac{1}{x}}\)</span>的东西,这个考虑取一下反函数即可.然后二者嵌套一下得到形如<span class="math inline">\(a^{\frac{q}{p}}\)</span>的幂函数,取反一下得到形如<span class="math inline">\(a^{-\frac{q}{p}}\)</span>的幂函数.</p>
<p>然后要定义无理数指数幂,类似戴德金分割,定义<span class="math inline">\(a^x=\sup_{q\leq x,q\in Q}a^q\)</span>.</p>
<p>当然我们要验证那些指数的运算法则,还有一些单调性(两个无理数之间插入两个有理数就可以拆成单调的,这里还需要讨论一下和<span class="math inline">\(1\)</span>的大小关系),这些当然都是对的.</p>
<p>然后我们就可以拿出指数函数,用反函数定义对数函数.</p>
<p>指数函数的连续性:考虑对于<span class="math inline">\(f(x)=a^x\)</span>,<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists
N&gt;0,a&lt;(1+\epsilon)^N\)</span>,此时取<span class="math inline">\(q_1&lt;x_0&lt;q_2\)</span>,<span class="math inline">\(q_2-q_1&lt;\frac{1}{N}\)</span>,这当然能做得到.考虑<span class="math inline">\(a^{x_0}\leq f(x_0+0)\leq f(q_2)\)</span>,于是<span class="math inline">\(1\leq \frac{a^{q_2}}{a^{q_1}}\leq
a^{\frac{1}{N}}\leq 1+\epsilon\)</span>.</p>
<p>先来看最特殊的指数函数: <span class="math display">\[
f(x)=e^x\Rightarrow f&#39;(x)=e^x
\]</span> 事实上我们还有: <span class="math display">\[
f(x)=a^x\Rightarrow f&#39;(x)=a^x\ln a,a&gt;0
\]</span></p>
<p>下面来看下为啥: <span class="math display">\[
f&#39;(x)=\lim_{\Delta x\rightarrow 0}\frac{a^{x+\Delta x}-a^x}{\Delta
x}\\
=a^x\lim_{\Delta x\rightarrow 0}\frac{a^{\Delta x}-1}{\Delta x}\\
=a^x\ln a
\]</span></p>
<p>而高阶导数有: <span class="math display">\[
f(x)=e^{ax}\Rightarrow f^{(n)}=a^ne^{ax}
\]</span></p>
<h5><span id="对数函数">对数函数</span></h5>
<p>先看: <span class="math display">\[
f(x)=\log_a(x)\Rightarrow f&#39;(x)=\frac{1}{x\ln a}
\]</span> 证明的话考虑: <span class="math display">\[
f&#39;(x)=\lim_{\Delta x\rightarrow 0}\frac{\log_a(1+\frac{\Delta
x}{x})}{\Delta x}\\
=\lim_{\Delta x\rightarrow 0}\frac{\log_a(1+\frac{\Delta
x}{x})}{\frac{\Delta x}{x}}\frac{1}{x}\\
=\frac{1}{x\ln a}
\]</span> 再看: <span class="math display">\[
f(x)=\ln |x|\Rightarrow f&#39;(x)=\frac{1}{x}
\]</span> 考虑<span class="math inline">\(f(x)=\ln |x|=\frac{1}{2}\ln
x^2\)</span>.</p>
<p>考虑对数函数的高阶导数: <span class="math display">\[
f(x)=\ln x\Rightarrow f^{(n)}(x)=(-1)^{n-1}(n-1)!x^{-n}
\]</span></p>
<h5><span id="幂函数">幂函数</span></h5>
<p>我们只需要定义<span class="math inline">\(x^{\alpha}=e^{\alpha\ln
x}\)</span>即可.</p>
<p>导数有: <span class="math display">\[
f(x)=x^\mu\Leftrightarrow f&#39;(x)=\mu x^{\mu-1}
\]</span></p>
<p>证明的话,考虑<span class="math inline">\(x=0\)</span>的时候根据定义显然,如果<span class="math inline">\(x\ne 0\)</span>,那么: <span class="math display">\[
f&#39;(x)=\lim_{\Delta x\rightarrow 0}\frac{(x+\Delta
x)^\mu-x^\mu}{\Delta x}\\
=\lim_{\frac{\Delta x}{x}\rightarrow 0}\frac{(1+\frac{\Delta
x}{x})^\mu-1}{\frac{\Delta x}{x}}x^{\mu-1}\\
=\mu x^{\mu -1}
\]</span></p>
<p>容易发现其高阶导数是: <span class="math display">\[
f(x)=x^\alpha\Rightarrow f^{(n)}(x)=\alpha^{\underline{n}}x^{\alpha-n}
\]</span></p>
<h5><span id="一般初等函数">一般初等函数</span></h5>
<p>定理:初等函数在其定义域上除了至多一个孤立点集外,可求导并且导函数也是初等函数.</p>
<h4><span id="单调函数的导数">单调函数的导数</span></h4>
<p>定义右上导数<span class="math inline">\(D^+
f(x_0)=\varlimsup_{h\rightarrow
0+0}\frac{f(x_0+h)-f(x_0)}{h}\)</span>,同理定义右下导数<span class="math inline">\(D_+\)</span>,左上导数<span class="math inline">\(D^{-}\)</span>,左下导数<span class="math inline">\(D_-\)</span>.那么<span class="math inline">\(f&#39;(x_0)\)</span>存在的充要条件当然是<span class="math inline">\(D_+=D^+=D_-=D^-\)</span>并且有限.</p>
<p>下面证明单调(不妨设为单增)函数<span class="math inline">\(f:[a,b]\rightarrow \R\)</span>几乎处处有导数.</p>
<p>我们接下来尝试证明<span class="math inline">\(E_1=\{x\in [a,b]\mid
D^+f(x)&gt;D_- f(x)\},E_2=\{x\in [a,b]\mid
D^-f(x)&gt;D_+f(x)\}\)</span>两个集合是零测集.此时<span class="math inline">\(E_1\cup E_2\)</span>就是零测集,而<span class="math inline">\(\R\setminus(E_1\cup E_2)\)</span>中的点都满足<span class="math inline">\(D^{+}f(x)\leq D_-f(x)\leq D^-f(x)\leq D_+f(x)\leq
D^+f(x)\)</span>,于是它们都相等(可能等于<span class="math inline">\(+\infty\)</span>).</p>
<p>二者类似,我们下面挑选前者进行证明:</p>
<p>考虑设<span class="math inline">\(A_{r,s}=\{x|D^+f(x)&gt;r&gt;s&gt;D_-f(x)\}\)</span>,其中<span class="math inline">\(r,s\)</span>都是正有理数(因为是单调递增).这当然是可数个集合,所以只需要证明其中任意一个是零测集就可以.我们取<span class="math inline">\(A=A_{r,s}\)</span>,下面证明<span class="math inline">\(A\)</span>是零测集.</p>
<p>反证,先假设<span class="math inline">\(A\)</span>不是零测集,<span class="math inline">\(m^*(A)&gt;0\)</span>且有限(最大是<span class="math inline">\(b-a\)</span>).</p>
<p>首先删除<span class="math inline">\(A\)</span>中的孤立点集.由于孤立点集是零测集,这当然不会对答案有什么影响,也不会删成空集.这样下面可以直接假设<span class="math inline">\(A\)</span>是开集.</p>
<p>根据定义,存在任意小的<span class="math inline">\(h&gt;0\)</span>使得<span class="math inline">\(\frac{f(x-j)-f(x)}{-h}&lt;s\Rightarrow
f(x)-f(x-j)&lt;sh\)</span>,那么我们取出这些<span class="math inline">\(I_{x,h}=[x-h,x]\)</span>,并且满足<span class="math inline">\(I_{x,h}\subseteq A\)</span>.它们当然构成<span class="math inline">\(A\)</span>的一个Vitali覆盖.</p>
<p>根据Vitali覆盖引理我们有<span class="math inline">\(\exists
I_{k}=[x_k-h_k,x_k]\)</span>两两不交并且满足<span class="math inline">\(m^*(A\setminus(\bigcup
I_k))&lt;\epsilon\)</span>.而考虑<span class="math inline">\(m^*(A\setminus(\bigcup I_k))+m^*(\bigcup I_k)\geq
m^*(A)\)</span>,不妨令<span class="math inline">\(B=\bigcup
I_k\)</span>于是我们得到了<span class="math inline">\(m^*(B)&gt;m^*(A)-\epsilon\)</span>.</p>
<p>这里我曾经以为可以直接写<span class="math inline">\(m^*(B)=m^*(A)\)</span>,但实际上是不行的,因为我们<span class="math inline">\(B\)</span>的构造依赖于<span class="math inline">\(\epsilon\)</span>.</p>
<p>同时由于所有的<span class="math inline">\(I_k\subseteq
A\)</span>并且两两不交,我们还有<span class="math inline">\(\sum h_j\leq
m^*(A)&lt;(1+\epsilon)m^*(A)\)</span>.</p>
<p>而我们发现我们又有<span class="math inline">\(f(x_j)-f(x_j-h_j)&lt;sh_j\)</span>,两边求和就有<span class="math inline">\(\sum f(x_j)-f(x_j-h_j)&lt;sm^*(A)\)</span>.</p>
<p>而接下来考虑<span class="math inline">\(B\)</span>,<span class="math inline">\(B\)</span>当然仍然是一个开集.对于<span class="math inline">\(\forall y\in
B\)</span>,当然应该存在一个任意小的<span class="math inline">\(k&gt;0\)</span>使得<span class="math inline">\(f(y+k)-f(y)&gt;rk\)</span>.取出这些区间<span class="math inline">\([y,y+k]\)</span>当然仍然构成<span class="math inline">\(B\)</span>的一个Vitali覆盖.类似上面,我们当然有结论<span class="math inline">\(\sum
f(y_j+k_j)-f(y_j)&gt;rm^*(B)&gt;r(m^*(A)-\epsilon)\)</span>.但考虑<span class="math inline">\([y_j,y_j+k_j]\)</span>一定被包含在某个<span class="math inline">\([x_j-h_j,x_j]\)</span>中,又根据函数的单调性,自然可以知道<span class="math inline">\(sm^*(A)&gt;\sum f(x_j)-f(x_j-h_j)\geq \sum
f(y_j+k_j)-f(y_j)&gt;r(m^*(A)-\epsilon)\)</span>.于是<span class="math inline">\(sm^*(A)\geq rm^*(A)\)</span>,这当然导出<span class="math inline">\(m^*(A)=0\)</span>,与条件不符!</p>
<p>接下来的修补工作是证明<span class="math inline">\(E=\{x|f&#39;(x)=+\infty\}\)</span>的集合是零测集.这意味着对于<span class="math inline">\(\forall N&gt;0,\exists  \Delta x&gt;0,f(x+\Delta
x)-f(x)&gt;N\Delta x\)</span>,取<span class="math inline">\([x,x+\Delta
x]\)</span>当然仍然是一个Vitali覆盖.同样根据Vitali覆盖引理得知<span class="math inline">\(\sum \Delta
x&gt;m^*(E)-\epsilon\)</span>,如果<span class="math inline">\(m^*(E)\ne
0\)</span>,做Vitali覆盖后对<span class="math inline">\(f(x+\Delta
x)-f(x)&gt;N\Delta x\)</span>左右两边分别求和,左边是有界,上界当然是<span class="math inline">\(f(b)-f(a)\)</span>,但右边无界.这就给出矛盾了.</p>
<p>理解一下上面的过程的话就是,由于该单调函数定义在一个闭区间上,那么这个单调函数应该有某种最值性.这必然会限制其大小,而如果哪里的大小崩坏了导致没有导数,这些地方的外测度一定要是<span class="math inline">\(0\)</span>,不然整体的最值性无法保证.</p>
<h4><span id="李氏连续函数的导数">李氏连续函数的导数</span></h4>
<p>注意到李氏连续的定义<span class="math inline">\(|f(x)-f(y)|\leq
L|x-y|\)</span>,注意到<span class="math inline">\(f(x)=f(x)-Lx+Lx\)</span>.</p>
<p>如果钦定<span class="math inline">\(x&lt;y\)</span>,那李氏连续等价于<span class="math inline">\(f(y)-f(x)\leq |f(x)-f(y)|\leq L(y-x),f(y)-Ly\leq
f(x)-Lx\)</span>,于是<span class="math inline">\(f(x)-Lx\)</span>是单调降函数,当然几乎处处可导,而<span class="math inline">\(Lx\)</span>作为初等函数当然处处可导.</p>
<p>李氏连续几乎等价于导函数有界.</p>
<p>下面我们证明:如果<span class="math inline">\(f(x)\in
C^1(a,b)\)</span>,那么<span class="math inline">\(|f&#39;|\leq
L\Leftrightarrow |f(x_1)-f(x_2)|\leq L|x_1-x_2|\)</span>.</p>
<p>右推左是显然的,除一下然后取极限即可.</p>
<p>左推右也很显然,只需用一下拉格朗日中值定理即可.</p>
<h4><span id="微分">微分</span></h4>
<p>设<span class="math inline">\(y=f(x)\)</span>在<span class="math inline">\(x_0\)</span>处有定义,假设有一个常数<span class="math inline">\(A\)</span>使得<span class="math inline">\(f(x_0+\Delta x)-f(x_0)=A\Delta x+o(\Delta
x),\Delta x\rightarrow 0\)</span>,称<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处<strong>可微</strong>,并把<span class="math inline">\(\text df=\text dy=A\Delta x\)</span>称为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处的<strong>微分</strong>,由于后半部分是一个更高阶的无穷小量,我们说微分是函数改变量的线性主要部分.</p>
<h5><span id="微分与导数微商">微分与导数(微商)</span></h5>
<p>结合导数极限的定义,就可以得到<span class="math inline">\(\text d
y=f&#39;(x)\text d x\)</span>,<span class="math inline">\(f&#39;(x)=\frac{\text d y}{\text d
x}\\\)</span>.这就是我们将导数称作<strong>微商</strong>的原因.换言之,一阶可微一定一阶可导,反之亦然.但容易发现,可微的定义要比可导好得多,可微可以往外拓展到平面等拓扑结构,但可导不行.</p>
<p>一阶微分具有<strong>形式不变性</strong>.换言之就是,我们在求导的时候是需要选定一个自变量的,当选定的自变量是<span class="math inline">\(y\)</span>的时候,根据上面自然会有<span class="math inline">\(z=g(y),\text d z=g&#39;(y)\text d y\)</span>.</p>
<p>但是当选定的自变量不是<span class="math inline">\(y\)</span>的时候,上面的形式是同样成立的.我们下面证明这个结论,令<span class="math inline">\(y=f(x)\)</span>: <span class="math display">\[
[g(f(x))]&#39;=g&#39;(f(x))f&#39;(x)\\
\text d z=g&#39;(f(x))f&#39;(x)\text d x\\
\text d z=g&#39;(y)\text d y\\
\]</span> 必须提出高阶微分不存在形式不变性,换句话说,<span class="math inline">\(z=g(y)\)</span>的二阶微分的形式不等价于<span class="math inline">\(z=g(y=f(x))\)</span>的二阶微分,你不能乱换元.</p>
<p>一般将高阶微分记作<span class="math inline">\(\frac{\text d^n
y}{\text d x^n}\)</span>.</p>
<h4><span id="导函数的性质">导函数的性质</span></h4>
<h5><span id="费马定理">费马定理</span></h5>
<p>如果<span class="math inline">\(f(x)\)</span>在邻域<span class="math inline">\(U(\xi,\delta)\)</span>上有定义,<span class="math inline">\(\xi\)</span>是其的一个极值点,在<span class="math inline">\(\xi\)</span>处存在导数,那么<span class="math inline">\(f&#39;(\xi)=0\)</span>.</p>
<p>不妨考虑最大值情况,<span class="math inline">\(f&#39;(\xi)=\lim_{\Delta x\to +0}\frac{f(\xi
+\Delta x)-f(\xi)}{\Delta x}=\lim_{\Delta x\to -0}\frac{f(\xi+\Delta
x)-f(\xi)}{\Delta x}\)</span>,前者<span class="math inline">\(\leq
0\)</span>,后者<span class="math inline">\(\geq 0\)</span>,此时当然<span class="math inline">\(f&#39;(\xi)=0\)</span>.</p>
<h5><span id="罗尔中值定理">罗尔中值定理</span></h5>
<p>如果<span class="math inline">\(f\in C[a,b]\)</span>且可导,并且<span class="math inline">\(f(a)=f(b)\)</span>.则<span class="math inline">\(\exists \xi \in (a,b)\)</span>,<span class="math inline">\(f&#39;(\xi)=0\)</span>.</p>
<p>即:可导函数两个零点间一定有导数的零点.</p>
<p>设<span class="math inline">\(M\)</span>为<span class="math inline">\(f[a,b]\)</span>上的最大值,<span class="math inline">\(m\)</span>是最小值,当二者相等即常值函数的时候,当然成立.</p>
<p>当<span class="math inline">\(M&gt;m\)</span>的时候,则<span class="math inline">\(M&gt;f(a)\)</span>和<span class="math inline">\(m&lt;f(a)\)</span>至少有一个成立.不妨设<span class="math inline">\(f(M)&gt;f(a)=f(b)\)</span>.</p>
<p>根据费马定理,这个极值点的导数为<span class="math inline">\(0\)</span>.</p>
<p>由此可以推论:函数的零点数量<span class="math inline">\(|\{x|f(x)=0\}|\leq
1+|\{x|f&#39;(x)=0\}|\)</span>.</p>
<p>这当然可以推出<span class="math inline">\(n\)</span>次多项式至多<span class="math inline">\(n\)</span>个实根.</p>
<p>事实上可以证明更强的结论,当<span class="math inline">\(c_i\)</span>不全为<span class="math inline">\(0\)</span>的时候,取<span class="math inline">\(n\)</span>个不同实数<span class="math inline">\(\lambda_k\)</span>,<span class="math inline">\(f(x)=\sum_{i=1}^n
c_ix^{\lambda_i}\)</span>至多有<span class="math inline">\(n-1\)</span>个正根.</p>
<p>归纳法,<span class="math inline">\(n=1\)</span>的时候显然成立.<span class="math inline">\(n-1\)</span>时成立的话,考虑<span class="math inline">\(f(x)=0\Leftrightarrow
x^{-\lambda_n}f(x)=0\)</span>,而后者有一项是常数项,求导后少一项.</p>
<h5><span id="拉格朗日中值定理">拉格朗日中值定理</span></h5>
<p><span class="math inline">\(f\in C[a,b]\)</span>,并且在<span class="math inline">\((a,b)\)</span>上可导，<span class="math inline">\(\exists \xi\in
(a,b),f&#39;(\xi)=\frac{f(b)-f(a)}{b-a}\)</span>.</p>
<p>考虑先把函数放平,设<span class="math inline">\(g(x)=f(x)-\frac{f(b)-f(a)}{b-a}(x-a)-f(a)\)</span>,容易发现<span class="math inline">\(g(a)=g(b)=0\)</span>,根据罗尔中值定理,<span class="math inline">\(\exists
\xi,g&#39;(\xi)=0=f&#39;(\xi)-\frac{f(b)-f(a)}{b-a},f&#39;(\xi)=\frac{f(b)-f(a)}{b-a}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\(f&#39;(x)\equiv 0\Rightarrow
f(x)\equiv C\)</span>.</p>
<p>考虑<span class="math inline">\(\forall x,y,x\ne y\)</span>,<span class="math inline">\(\exists
\xi,f&#39;(\xi)=\frac{f(y)-f(x)}{y-x}=0\Rightarrow
f(x)=f(y)\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>证明:如果<span class="math inline">\(f&#39;(x)\equiv
g&#39;(x)\)</span>,那么<span class="math inline">\(f(x)=g(x)+C\)</span>.</p>
<p>考虑<span class="math inline">\(h(x)=f(x)-g(x),h&#39;(x)\equiv
0\Rightarrow h(x)=C\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑对抛物线用拉格朗日中值定理,设<span class="math inline">\(f(x)=px^2+qx+r\)</span>,则<span class="math inline">\(\frac{f(b)-f(a)}{b-a}=\frac{p(b^2-a^2)+q(b-a)}{b-a}=p(b+a)+q=f&#39;(\frac{a+b}{2})\)</span>.</p>
<p>反过来,如果恒有<span class="math inline">\(\frac{f(b)-f(a)}{b-a}=f&#39;(\frac{a+b}{2})\)</span>,事实上也可以推出<span class="math inline">\(f(x)\)</span>是抛物线.</p>
<p>此时我们有<span class="math inline">\(f(x+y)-f(x-y)=2yf&#39;(x)\)</span>,取<span class="math inline">\(y=1\)</span>,知道<span class="math inline">\(f(x)\in C^{\infty}\)</span>,于是可以两边对<span class="math inline">\(y\)</span>求两次导数,得到<span class="math inline">\(f&#39;&#39;(x+y)-f&#39;&#39;(x-y)\equiv
0\)</span>,这当然意味着<span class="math inline">\(f&#39;&#39;(x)\)</span>是常函数.</p>
<h5><span id="柯西中值定理">柯西中值定理</span></h5>
<p><span class="math inline">\(f,g\in C[a,b]\)</span>,并且均在<span class="math inline">\((a,b)\)</span>上可导,其中<span class="math inline">\(g&#39;(x)\ne 0\)</span>.则<span class="math inline">\(\exists \xi\in (a,b)\)</span>,<span class="math inline">\(\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f&#39;(\xi)}{g&#39;(\xi)}\)</span>.</p>
<p>此时注意到<span class="math inline">\(g(b)\ne
g(a)\)</span>,原因是根据拉格朗日中值定理,如果<span class="math inline">\(g(b)=g(a),\exists \xi \in
(a,b),g&#39;(\xi)=0\)</span>,这与<span class="math inline">\(g&#39;(x)\ne 0\)</span>矛盾.</p>
<p>令<span class="math inline">\(F(x)=f(x)(g(b)-g(a))-g(x)(f(b)-f(a))\)</span>.</p>
<p>接下来注意到上述命题等价于<span class="math inline">\(\exists \xi\in
(a,b),F&#39;(\xi)=0\)</span>.</p>
<p>而注意到<span class="math inline">\(F(a)=f(a)g(b)-g(a)f(b)=F(b)\)</span>,根据罗尔中值定理立刻得到答案.</p>
<p>然而这个东西竟然还能推广,我们有:</p>
<p>如果<span class="math inline">\(f,g,h\in C[a,b]\)</span>并且在<span class="math inline">\((a,b)\)</span>上可导,<span class="math inline">\(\exists \xi\in (a,b),\)</span>有: <span class="math display">\[
\left
|\begin{matrix}f&#39;(\xi)&amp;g&#39;(\xi)&amp;h&#39;(\xi)\\f(a)&amp;g(a)&amp;h(a)\\f(b)&amp;g(b)&amp;h(b)\end{matrix}\right
|=0
\]</span> 证明的话考虑构造: <span class="math display">\[
F(x)=\left
|\begin{matrix}f(x)&amp;g(x)&amp;h(x)\\f(a)&amp;g(a)&amp;h(a)\\f(b)&amp;g(b)&amp;h(b)\end{matrix}\right
|
\]</span> 注意到<span class="math inline">\(F(a)=F(b)=0\)</span>.</p>
<h5><span id="广义微分中值定理">广义微分中值定理</span></h5>
<h6><span id="广义罗尔中值定理">广义罗尔中值定理</span></h6>
<p>如果<span class="math inline">\(f\in C[a,b]\)</span>且<span class="math inline">\(\forall x\in
(a,b),f&#39;_\pm(x)\)</span>均存在,并且<span class="math inline">\(f(a)=f(b)=0\)</span>.则<span class="math inline">\(\exists \xi \in (a,b)\)</span>,<span class="math inline">\(f_+&#39;(\xi)f_-&#39;(\xi)\leq 0\)</span>.</p>
<p>证明和罗尔中值定理没区别,仍然是找最值.</p>
<h6><span id="广义拉格朗日中值定理">广义拉格朗日中值定理</span></h6>
<p>如果<span class="math inline">\(f\in C[a,b]\)</span>且<span class="math inline">\(\forall x\in
(a,b),f&#39;_\pm(x)\)</span>均存在,<span class="math inline">\(\eta=\frac{f(a)-f(b)}{a-b}\)</span>,则<span class="math inline">\(\exists \xi \in (a,b)\)</span>,<span class="math inline">\((f_+&#39;(\xi)-\eta) (f_-&#39;(\xi)-\eta)\leq
0\)</span>.</p>
<p>证明差不多,仍然是把函数放平然后用广义罗尔中值定理就行.</p>
<h5><span id="导函数与间断点">导函数与间断点</span></h5>
<p>导函数不存在第一类间断点.</p>
<p>证明的话,考虑设<span class="math inline">\(f(x)\in
C^1(a,b)\)</span>,<span class="math inline">\(\exists
x_n&lt;x_0&lt;y_n\)</span>,<span class="math inline">\(x_n,y_n\rightarrow x_0\)</span>,并且满足<span class="math inline">\(\lim f&#39;(x_n)=\lim
f&#39;(y_n)=f&#39;(x_0)\)</span>.</p>
<p>原因根据拉格朗日中值定理,<span class="math inline">\(\exists x_n\in
(x_0-\frac{1}{n},x_0)\)</span>,<span class="math inline">\(f&#39;(x_n)=\frac{f(x_0)-f(x_0-\frac{1}{n})}{\frac{1}{n}}\)</span>,直接这么取当然就是可行的.</p>
<h5><span id="函数的升降性">函数的升降性</span></h5>
<p><span class="math inline">\(f\in C[a,b]\)</span>并且在<span class="math inline">\((a,b)\)</span>上可导,<span class="math inline">\(f\)</span>单调不减$$<span class="math inline">\(f&#39;(x)\geq 0\)</span>.</p>
<p>左推右当然是导数定义,右推左可以用拉格朗日微分中值定理.</p>
<p>另外由于保号性,<span class="math inline">\(f&#39;(x)&gt;0\Rightarrow
f\uparrow\)</span>,但反之不成立.</p>
<h5><span id="函数的极值">函数的极值</span></h5>
<p>若<span class="math inline">\(f\)</span>在<span class="math inline">\((x_0-\delta,x_0+\delta)\)</span>上<span class="math inline">\(n-1\)</span>次可导,<span class="math inline">\(\forall 1\leq k\leq
n-1,f^{(k)}(x_0)=0\)</span>.而且<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处存在<span class="math inline">\(n\)</span>阶导数并有<span class="math inline">\(f^{(n)}(x_0)\ne 0\)</span>.我们有以下结论:</p>
<ol type="1">
<li><span class="math inline">\(n\)</span>是奇数的时候,<span class="math inline">\(x_0\)</span>不是极值点.</li>
<li><span class="math inline">\(n\)</span>是偶数且<span class="math inline">\(f^{(n)}(x_0)&lt;0\)</span>时,<span class="math inline">\(x_0\)</span>是极大值点.</li>
<li><span class="math inline">\(n\)</span>是偶数且<span class="math inline">\(f^{(n)}(x_0)&gt;0\)</span>时,<span class="math inline">\(x_0\)</span>是极小值点.</li>
</ol>
<p>证明考虑泰勒公式: <span class="math display">\[
f(x)=f(x_0)+\sum_{k=1}^n\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+o((x-x_0)^n)\\
f(x)-f(x_0)=(x-x_0)^n(\frac{f^{(n)}(x_0)}{n!}+o(1))
\]</span> 于是取极小邻域并且<span class="math inline">\(n\)</span>是偶数的时候<span class="math inline">\(f(x)-f(x_0)\)</span>和<span class="math inline">\(f^{(n)}(x_0)\)</span>同号,上述命题立见.</p>
<h5><span id="达布定理">达布定理</span></h5>
<p>也即:导函数拥有介值性.</p>
<p>如果<span class="math inline">\(f\)</span>在<span class="math inline">\([a,b]\)</span>上可导,<span class="math inline">\(f&#39;(a)f&#39;(b)&lt;0\)</span>,那么<span class="math inline">\(\exists \xi\in (a,b),f&#39;(\xi)=0\)</span>.</p>
<p>不妨设<span class="math inline">\(f&#39;(a)&gt;0&gt;f&#39;(b)\)</span>,那么<span class="math inline">\(f\)</span>在<span class="math inline">\(a\)</span>处附近递增,在<span class="math inline">\(b\)</span>处附近递减.那我们取一下<span class="math inline">\(f(\xi)=\max_{[a,b]}\{f(x)\}\)</span>,那么<span class="math inline">\(\xi \ne a,\xi \ne b\)</span>,于是<span class="math inline">\(\xi\in (a,b)\)</span>,<span class="math inline">\(f&#39;(\xi)=0\)</span>.</p>
<p>那我们加个一次函数就可以把这个推广到导函数的介值性.</p>
<p>然而这个介值性比连续性弱得多,例如下面这个函数的导函数就在闭区间<span class="math inline">\([0,1]\)</span>上有界但没有最值: <span class="math display">\[
f(x)=\begin{cases}-x^2(1+\sin{\frac{1}{x}})&amp;x\ne
0\\0&amp;x=0\end{cases}
\]</span> 其构造思路是让其在<span class="math inline">\(0\)</span>附近的导数在<span class="math inline">\((-1,1)\)</span>上下波动,这样上确界为<span class="math inline">\(1\)</span>,但<span class="math inline">\(0\)</span>处跳出去,所以取不到<span class="math inline">\(1\)</span>.</p>
<p>下面这个函数更极端,其导函数在闭区间<span class="math inline">\([0,1]\)</span>上无界: <span class="math display">\[
f(x)=\begin{cases}x^2\sin{\frac{1}{x^2}}&amp;x\ne
0\\0&amp;x=0\end{cases}
\]</span> 其构造思路应当是让其在<span class="math inline">\(0\)</span>处相当厉害地波动.</p>
<h5><span id="函数的凹凸性">函数的凹凸性</span></h5>
<p>定义一个函数是下凸的,若对<span class="math inline">\(\forall
x_1,x_2\in I,\forall\lambda\in [0,1],f(\lambda x_1+(1-\lambda)x_2)\leq
\lambda f(x_1)+(1-\lambda)f(x_2)\)</span>.</p>
<p>如果一个函数是下凸的,那么其充要条件是<span class="math inline">\(\forall x_1,x_2,x_3\in I\)</span>满足<span class="math inline">\(x_1&lt;x_2&lt;x_3\)</span>,<span class="math inline">\(\left|\begin{matrix}1&amp;x_1&amp;f(x_1)\\1&amp;x_2&amp;f(x_2)\\1&amp;x_3&amp;f(x_3)\end{matrix}\right|\geq
0\)</span>.只需设<span class="math inline">\(x_2=\lambda
x_1+(1-\lambda)x_3\)</span>然后简单变形即可.</p>
<p>还可以证明如果一个函数是下凸的,那么其充要条件是<span class="math inline">\(\forall x_1,x_2,x_3\in
I,x_1&lt;x_2&lt;x_3\)</span>,斜率有<span class="math inline">\(k(x_1,x_2)\leq k(x_1,x_3)\leq
k(x_2,x_3)\)</span>,即所谓三弦引理.这个性质容易证明,而且该性质立刻说明开区间上的下凸函数一定是李氏连续函数.这意味着其应当几乎处处可导.另外三弦引理还可以改为<span class="math inline">\(k(x_1,x_2)\leq
k(x_2,x_3)\)</span>,原因是中间项一定是两项的带权平均.</p>
<p>另外显然的是:</p>
<ol type="1">
<li>如果<span class="math inline">\(f\)</span>可导,那么<span class="math inline">\(f\)</span>下凸<span class="math inline">\(\Leftrightarrow\)</span><span class="math inline">\(f&#39;\)</span>不降.</li>
<li>如果<span class="math inline">\(f\)</span>可二阶导,那么<span class="math inline">\(f\)</span>下凸<span class="math inline">\(\Leftrightarrow\)</span><span class="math inline">\(f&#39;&#39;\geq 0\)</span>.</li>
</ol>
<p>如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>附近连续并且在<span class="math inline">\(x_0\)</span>左右小邻域内凸性相反,称其为<span class="math inline">\(f(x)\)</span>的一个<strong>拐点</strong>.</p>
<p>容易说明<span class="math inline">\(f&#39;&#39;(x_0)=0\)</span>是拐点的必要条件,原因是拐点处<span class="math inline">\(f&#39;(x)\)</span>的增减性相反,<span class="math inline">\(x_0\)</span>必定是<span class="math inline">\(f&#39;(x)\)</span>的极值点.由此还可以套用之前的极值点结论:</p>
<p>若<span class="math inline">\(f\)</span>在<span class="math inline">\((a,b)\)</span>上<span class="math inline">\(n\)</span>次可导,<span class="math inline">\(\exists x_0\in (a,b),\forall 1\leq k\leq
n-1,f^{(k)}(x_0)=0\)</span>.并且<span class="math inline">\(\forall x\in
(a,b),f^{(n)}(x)&gt;0\)</span>我们有以下结论:</p>
<ol type="1">
<li><span class="math inline">\(n\)</span>是奇数的时候,<span class="math inline">\(f(x)\)</span>是严格单增函数.</li>
<li><span class="math inline">\(n\)</span>是偶数的时候,<span class="math inline">\(f(x)\)</span>是严格下凸函数.</li>
</ol>
<p>但上述条件疑似有点过强,能不能放弱一点呢?</p>
<p>可以发现一个在开区间<span class="math inline">\((a,b)\)</span>上的函数是下凸的充要条件应当是以下条件同时成立:</p>
<ol type="1">
<li><span class="math inline">\(\forall x\in (a,b)\)</span>,<span class="math inline">\(f&#39;_\pm(x)\)</span>均存在,并且<span class="math inline">\(f&#39;_-(x)\leq f&#39;_+(x)\)</span>.</li>
<li><span class="math inline">\(\forall x_1,x_2\in
(a,b),x_1&lt;x_2\)</span>,<span class="math inline">\(f&#39;_+(x_1)\leq
f&#39;_-(x_2)\)</span>.</li>
</ol>
<p>必要性几乎是显然的,只需用三弦引理然后在每个点都卡一下极限就行.</p>
<p>充分性略有麻烦.考虑反证,只需反推三弦引理即可.设其不是凸的,那就<span class="math inline">\(\exists x_1,x_2,x_3\in
(a,b),x_1&lt;x_2&lt;x_3,k(x_1,x_2)&gt;k(x_2,x_3)\)</span>.不妨设<span class="math inline">\(\eta_1=k(x_1,x_2),\eta_2=k(x_2,x_3)\)</span>那么根据广义拉格朗日中值定理,<span class="math inline">\(\exists \xi_1\in(x_1,x_2),\xi_2\in
(x_2,x_3)\)</span>,使得<span class="math inline">\((f_+&#39;(\xi_1)-\eta_1)(f&#39;_-(\xi_1)-\eta_1)\leq
0,(f_+&#39;(\xi_2)-\eta_2)(f&#39;_-(\xi_2)-\eta_2)\leq 0\)</span>.</p>
<p>立刻得到<span class="math inline">\(f&#39;_+(\xi_1)\geq \eta_1\geq
f_-&#39;(\xi_1),f&#39;_+(\xi_2)\geq \eta_2\geq
f_-&#39;(\xi_2)\)</span>,由于<span class="math inline">\(\eta_1&gt;\eta_2\)</span>,所以<span class="math inline">\(f&#39;_+(\xi_1)\geq \eta_1&gt;\eta_2\geq
f&#39;_-(\xi_2)\)</span>,但<span class="math inline">\(\xi_1&lt;\xi_2\)</span>,这就出现了矛盾.</p>
<p>还可以证明下凸函数除了可数个点以外都可导,并且几乎处处有二阶导数.</p>
<p>这个怎么证明呢?考虑由(1)(2),可以发现<span class="math inline">\(f&#39;_+(x)\)</span>和<span class="math inline">\(f_-&#39;(x)\)</span>都是单调函数,那么除了可数个点以外它们均连续,而它们在连续处必定可导,原因是<span class="math inline">\(f_+&#39;(x_0-\epsilon)\leq f&#39;_-(x_0)\leq
f&#39;_+(x_0)\)</span>,夹逼一下就可以了.而这样的话其导数单调,于是处处二阶可导.</p>
<p>由此还可以发现:<span class="math inline">\(f\)</span>在开区间<span class="math inline">\(I\)</span>上,是下凸的等价于:</p>
<ol type="1">
<li><span class="math inline">\(\forall x_0\in
I,f&#39;_\pm(x_0)\)</span>存在.</li>
<li><span class="math inline">\(\forall x\in I,f(x)\geq
f(x_0)+f&#39;_\pm(x_0)(x-x_0)\)</span>.</li>
</ol>
<p>必要性:</p>
<p>考虑已知凸函数,只需证明<span class="math inline">\(f(x)-f(x_0)\geq
f&#39;_\pm(x_0)(x-x_0)\)</span>.不妨假设<span class="math inline">\(x&gt;x_0\)</span>(另一方向同理),于是只需证明<span class="math inline">\(\frac{f(x)-f(x_0)}{x-x_0}\geq
f&#39;_\pm(x_0)\)</span>,用广义拉格朗日微分中值定理立刻得见此成立.</p>
<p>充分性:</p>
<p>任取两点<span class="math inline">\(x_1,x_2\in
I,x_1&lt;x_2\)</span>,有<span class="math inline">\(\frac{f(x_2)-f(x_1)}{x_2-x_1}\geq
f_-&#39;(x_1)\)</span>,那么左边那个东西取极限得到<span class="math inline">\(f&#39;_+(x_1)\)</span>,这样就说明了任何一个点都有<span class="math inline">\(f&#39;_+(x)\geq f&#39;_-(x)\)</span>.</p>
<p>接下来仍然容易得到: <span class="math display">\[
f(x_2)\geq f(x_1)+f&#39;_+(x_1)(x_2-x_1)\\
f(x_1)\geq f(x_2)+f&#39;_-(x_2)(x_1-x_2)
\]</span> 由上述式子立刻得到<span class="math inline">\(f_+&#39;(x_1)&#39;\leq
f_-&#39;(x_2)\)</span>.这样就证明了充分性.</p>
<h4><span id="经典不等式">经典不等式</span></h4>
<h5><span id="琴生不等式">琴生不等式</span></h5>
<p>如果<span class="math inline">\(f\)</span>在<span class="math inline">\(I\)</span>上是下凸的,则<span class="math inline">\(\forall x_i\in I,\lambda_i\in [0,1],\sum
\lambda_i=1\)</span>,那么<span class="math inline">\(f(\sum
\lambda_ix_i)\leq \sum \lambda_i f(x_i)\)</span>.</p>
<p>当所有<span class="math inline">\(x_i\)</span>均相等的时候显然成立.</p>
<p>不然考虑直接取<span class="math inline">\(x_0=\sum
\lambda_ix_i\)</span>,此时发现<span class="math inline">\(x_0\)</span>一定在区间内部.于是我们知道<span class="math inline">\(f(x_i)\geq
f(x_0)+f&#39;_+(x_0)(x_i-x_0)\)</span>,求和得到<span class="math inline">\(\sum \lambda_if(x_i)\geq f(x_0)+f_+&#39;(x_0)\sum
\lambda_i (x_i-x_0)=f(x_0)\)</span>,这样就证毕了.</p>
<p>容易将琴生不等式推广到积分形式,当<span class="math inline">\(\varphi(x)\)</span>是下凸连续函数的时候,当然有<span class="math inline">\(\varphi(\int_0^1 f\text d x)\leq
\int_0^1\varphi(f(x))\text d x\)</span>,证明只需对黎曼和求极限.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:圆内接<span class="math inline">\(n\)</span>边形以正<span class="math inline">\(n\)</span>边形面积和周长最大.</p>
<p>不妨设其为单位元,用圆心向顶点连边,会得到一圈圆心角<span class="math inline">\(\alpha_1,\ldots,\alpha_n\)</span>,它们之和应当是<span class="math inline">\(2\pi\)</span>并且范围均在<span class="math inline">\((0,\pi]\)</span>里(原因是圆心肯定得包含在正<span class="math inline">\(n\)</span>边形里,不然肯定不算大),此范围内$<span class="math inline">\(是下凸函数,那么\)</span>S=_i=<span class="math inline">\(,\)</span>L=22n=2n$.</p>
<p>同理还可以证明圆外接<span class="math inline">\(n\)</span>边形以正<span class="math inline">\(n\)</span>边形面积和周长最小,证明可以考虑取切线然后用<span class="math inline">\(\tan\)</span>的凸性.</p>
<h5><span id="均值不等式">均值不等式</span></h5>
<p>当<span class="math inline">\(x_i&gt;0\)</span>时: <span class="math display">\[
\frac{n}{\sum \frac{1}{x_i}}\leq (\prod x_i)^{\frac{1}{n}}\leq
\frac{\sum x_i}{n}
\]</span> 取<span class="math inline">\(f(x)=\ln x\)</span>,<span class="math inline">\(f(x)\)</span>是上凸的,于是<span class="math inline">\(\ln \frac{\sum x_i}{n}\geq \frac{1}{n}\sum \ln
x_i\)</span>,右边得证,取倒数得到左边.</p>
<h5><span id="柯西-赫尔德不等式">柯西-赫尔德不等式</span></h5>
<p>当<span class="math inline">\(a_i,b_i&gt; 0\)</span>并且<span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>时,有<span class="math inline">\(\sum a_ib_i\leq (\sum a_i^p)^{\frac{1}{p}}(\sum
b_i^q)^{\frac{1}{q}}\)</span>.其特例给出柯西不等式.</p>
<p>套用琴生不等式,取<span class="math inline">\(f(x)=x^{\frac{1}{q}},\lambda_i=\frac{a_i^p}{\sum_j
a_j^p},x_i=\frac{b_i^q}{a_i^p}\)</span>,容易发现<span class="math inline">\(f(x)\)</span>上凸.</p>
<p>这样就会得到: <span class="math display">\[
f(\sum \lambda_ix_i)\geq \sum \lambda_i f(x_i)\\
(\sum_i \frac{b_i^p}{\sum_j a_j^p})^{\frac{1}{q}}\geq \sum_i
\frac{a_ib_i}{\sum_j a_j^p}\\
\]</span> 化简一下就可以了.</p>
<p>在这里也可以将此形式拓展到积分形式,注意到当<span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>时,<span class="math inline">\(a^{\frac{1}{p}}b^{\frac{1}{q}}=e^{\frac{\ln
a}{p}+\frac{\ln b}{q}}\leq
\frac{a}{p}+\frac{b}{q}\)</span>,原因是琴生不等式.此时令<span class="math inline">\(F=(\int_a^b |f(x)|^p\text d
x)^{\frac{1}{p}},G=(\int_a^b |g(x)|^q\text d
x)^{\frac{1}{q}}\)</span>,再令<span class="math inline">\(a=\frac{|f(x)|^p}{F^p},b=\frac{|g(x)|^q}{G^q}\)</span>,根据上面的不等式立刻得到<span class="math inline">\(\frac{|f(x)g(x)|}{FG}\leq\frac{a}{p}+\frac{b}{q}\)</span>,此时做两边积分,注意到<span class="math inline">\(\int a=\int b=1\)</span>,立刻得到<span class="math inline">\((\int_a^b |f(x)|^p\text d
x)^{\frac{1}{p}}(\int_a^b |g(x)|^q\text d x)^{\frac{1}{q}}\geq
\int_a^b|f(x)g(x)|\text d x\)</span>.</p>
<h5><span id="闵可夫斯基minkovski不等式">闵可夫斯基(Minkovski)不等式</span></h5>
<p><span class="math inline">\(x_i,y_i\geq 0,p\geq 1\)</span>,则<span class="math inline">\((\sum(x_i+y_i)^p)^{\frac{1}{p}}\leq (\sum
x_i^p)^{\frac{1}{p}}+(\sum y_i^p)^{\frac{1}{p}}\)</span>.</p>
<p>套用琴生不等式,取<span class="math inline">\(f(x)=(1-x^{\frac{1}{p}})^p,x\in
(0,1)\)</span>.求导得到<span class="math inline">\(f&#39;(x)=-(1-x^{\frac{1}{p}})^{p-1}x^{\frac{1}{p}-1}\)</span>,再来一次化简得到<span class="math inline">\(f&#39;&#39;(x)=(1-\frac{1}{p})(1-x^{\frac{1}{p}})^{p-2}x^{\frac{1}{p}-2}\geq
0\)</span>.于是<span class="math inline">\(f(x)\)</span>下凸.</p>
<p>取<span class="math inline">\(\lambda_i=\frac{(x_i+y_i)^p}{\sum_j
(x_j+y_j)^p}\)</span>,<span class="math inline">\(u_i=(\frac{x_i}{x_i+y_i})^p\)</span>.这样得到:
<span class="math display">\[
(1-\frac{(\sum x_i^p)^{\frac{1}{p}}}{(\sum_j
(x_j+y_j)^p)^{\frac{1}{p}}})^p\leq \sum_i \frac{(x_i+y_i)^p}{\sum_j
(x_j+y_j)^p}(\frac{y_i}{x_i+y_i})^p\\
((\sum (x_i+y_i)^p)^{\frac{1}{p}}-(\sum x_i^p)^{\frac{1}{p}})^p\leq \sum
y_i^p
\]</span> 化简一下就做完了.</p>
<h4><span id="洛必达法则">洛必达法则</span></h4>
<p>来看几个抽象的问题:</p>
<ol type="1">
<li><span class="math inline">\(\infty-\infty\)</span>.</li>
<li><span class="math inline">\(0\times \infty\)</span>.</li>
<li><span class="math inline">\(\frac{0}{0}\)</span>.</li>
<li><span class="math inline">\(\frac{\infty}{\infty}\)</span>.</li>
<li><span class="math inline">\(0^0\)</span>.</li>
<li><span class="math inline">\(1^\infty\)</span>.</li>
<li><span class="math inline">\(\infty^0\)</span>.</li>
</ol>
<p>(1)可以写成<span class="math inline">\(\infty(1-\frac{\infty}{\infty})\)</span>,这样就转化成了(2).</p>
<p>(2)可以写成<span class="math inline">\(\frac{0}{\frac{1}{\infty}}\)</span>,就转化成了(3).</p>
<p>(5)可以写成<span class="math inline">\(e^{0\ln
0}\)</span>,就转化成了(2).</p>
<p>(6)可以写成<span class="math inline">\(e^{\infty\ln
1}\)</span>,就转化成了(2).</p>
<p>(7)可以写成<span class="math inline">\(e^{0\ln
\infty}\)</span>,就转化成了(2).</p>
<p>这样的话我们只需要解决俩问题就行了,也就是<span class="math inline">\(\frac{0}{0}\)</span>和<span class="math inline">\(\frac{\infty}{\infty}\)</span>.</p>
<h5><span id="00型">0/0型</span></h5>
<p>如果<span class="math inline">\(f,g\)</span>在<span class="math inline">\(U_0(a,\delta)\)</span>上可导,<span class="math inline">\(g&#39;(x)\ne 0\)</span>,<span class="math inline">\(\lim_{x\rightarrow a}f(x)=\lim_{x\rightarrow
a}g(x)=0\)</span>.那么若<span class="math inline">\(\lim_{x\rightarrow
a}\frac{f&#39;(x)}{g&#39;(x)}=k\Rightarrow \lim_{x\rightarrow
a}\frac{f(x)}{g(x)}=k\)</span>.</p>
<p>这个只需要定义<span class="math inline">\(f(a)=g(a)=0\)</span>,这样这俩函数就连续了.然后直接跑柯西中值定理就可以对<span class="math inline">\(\frac{f(x)-f(a)}{g(x)-g(a)}=\frac{f&#39;(\xi)}{g&#39;(\xi)}\)</span>.</p>
<p>这里可以看出洛必达法则是单向的,因为我们取得<span class="math inline">\(\xi\)</span>并不是连续变化的,只是取了一个<span class="math inline">\(\rightarrow 0\)</span>的<span class="math inline">\(\xi\)</span>的子列.</p>
<p>而如果<span class="math inline">\(a=\infty\)</span>,那就考虑取<span class="math inline">\(t\rightarrow 0\)</span>,然后把<span class="math inline">\(x\)</span>换成<span class="math inline">\(\frac{1}{t}\)</span>,做复合函数求导即可.</p>
<h5><span id="inftyinfty型"><span class="math inline">\(\infty\)</span>/<span class="math inline">\(\infty\)</span>型</span></h5>
<p>如果<span class="math inline">\(f,g\)</span>在<span class="math inline">\(U_0(a,\delta)\)</span>上可导,<span class="math inline">\(g&#39;(x)\ne 0\)</span>,<span class="math inline">\(\lim_{x\rightarrow
a}g(x)=\infty\)</span>.那么若<span class="math inline">\(\lim_{x\rightarrow
a}\frac{f&#39;(x)}{g&#39;(x)}=k\Rightarrow \lim_{x\rightarrow
a}\frac{f(x)}{g(x)}=k\)</span>.</p>
<p>这个证明麻烦一点,先来讨论<span class="math inline">\(k\ne \pm
\infty\)</span>的情况.</p>
<p>考虑<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists \delta &gt;0,\forall \xi\in
(a,a+\delta)\)</span>,应当有<span class="math inline">\(k-\epsilon&lt;\frac{f&#39;(\xi)}{g&#39;(\xi)}&lt;k+\epsilon\)</span>,那么<span class="math inline">\(\forall x\in (a,a+\delta)\)</span>,取<span class="math inline">\(x_1=a+\delta\)</span>当然有: <span class="math display">\[
\frac{f(x)-f(x_1)}{g(x)-g(x_1)}=\frac{f&#39;(\xi)}{g&#39;(\xi)}\\
\frac{f(x)}{g(x)}=\frac{f&#39;(\xi)}{g&#39;(\xi)}(1-\frac{g(x_1)}{g(x)})+\frac{f(x_1)}{g(x)}
\]</span> 两边取上下极限就做完了.</p>
<p>当<span class="math inline">\(k=\pm
\infty\)</span>的时候容易发现上面那个还能用.</p>
<h4><span id="泰勒公式">泰勒公式</span></h4>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处有<span class="math inline">\(n\)</span>阶导数,则<strong>泰勒公式</strong>声称<span class="math inline">\(x\rightarrow x_0\)</span>时<span class="math inline">\(f(x)=\sum_{k=0}^nf^{(k)}(x_0)\frac{(x-x_0)^k}{k!}+o((x-x_0)^n)\)</span>,其中<span class="math inline">\(o((x-x_0)^n)\)</span>称作<strong>皮亚诺余项</strong>.特别地,当<span class="math inline">\(x_0=0\)</span>的时候,称其为<strong>麦克劳林公式</strong>.</p>
<p>要证明这个式子只需证明<span class="math inline">\(\lim_{x\rightarrow
x_0}\frac{f(x)-\sum_{k=0}^nf^{(k)}(x_0)\frac{(x-x_0)^k}{k!}}{(x-x_0)^n}=0\)</span>.对上下分别用<span class="math inline">\(n-1\)</span>次洛必达法则后,那么只需要证明<span class="math inline">\(\lim_{x\rightarrow
x_0}\frac{f^{(n-1)}(x)-f^{(n-1)(x_0)}}{(x-x_0)}-f^{(n)}(x_0)=0\)</span>.而这当然就是导数的定义,于是就证毕了.</p>
<h5><span id="拉格朗日余项">拉格朗日余项</span></h5>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\((a,b)\)</span>上有<span class="math inline">\(n+1\)</span>阶导数,并且<span class="math inline">\(f(x)\in C^n[a,b]\)</span>,泰勒公式有<span class="math inline">\(f(x)=\sum_{k=0}^nf^{(k)}(x_0)\frac{(x-x_0)^k}{k!}+\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\)</span>,其中<span class="math inline">\(\xi\in (x_0,x)\)</span>.一般将<span class="math inline">\(\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\)</span>称作<strong>拉格朗日余项</strong>.</p>
<p>证明的话,考虑对于一个固定的<span class="math inline">\(x\)</span>,构造<span class="math inline">\(F(t)=f(x)-\sum_{k=0}^nf^{(k)}(t)\frac{(x-t)^k}{k!}\)</span>,<span class="math inline">\(G(t)=(x-t)^{n+1}\)</span>.不难发现<span class="math inline">\(F(x)=G(x)=0\)</span>,此时考虑必定有一个<span class="math inline">\(\xi\in (x_0,x)\)</span>满足<span class="math inline">\(\frac{F&#39;(\xi)}{G&#39;(\xi)}=\frac{F(x_0)-F(x)}{G(x_0)-G(x)}=\frac{F(x_0)}{G(x_0)}\)</span>.</p>
<p>这个时候研究一下他们的导数,注意到<span class="math inline">\(G&#39;(t)=-(n+1)(x-t)^{n}\)</span>,<span class="math inline">\(F&#39;(t)=-\sum_{k=0}^nf^{(k+1)}(t)\frac{(x-t)^k}{k!}+\sum_{k=1}^nf^{(k)}(t)\frac{(x-t)^{k-1}}{(k-1)!}=-f^{(n+1)}(t)\frac{(x-t)^n}{n!}\)</span>.</p>
<p>于是<span class="math inline">\(\frac{F(x_0)}{G(x_0)}=\frac{f^{(n+1)}(\xi)}{(n+1)!}\)</span>,<span class="math inline">\(F(x_0)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\)</span>.</p>
<p>下面给出一些常见的泰勒展开公式(其中<span class="math inline">\(0&lt;\theta&lt;1\)</span>):</p>
<ol type="1">
<li><span class="math inline">\(e^x=\sum_{k=0}^n\frac{x^k}{k!}+\frac{e^{\theta
x}x^{n+1}}{(n+1)!}=1+\frac{x}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+o(x^3)\)</span>.</li>
<li><span class="math inline">\(\sin
x=\sum_{k=0}^{n}\frac{(-1)^kx^{2k+1}}{(2k+1)!}+(-1)^{n+1}\frac{\cos\theta
x}{(2n+3)!}x^{2n+3}=x-\frac{1}{3!}x^3+o(x^4)\)</span>.</li>
<li><span class="math inline">\(\cos
x=\sum_{k=0}^n\frac{(-1)^kx^{2k}}{(2k)!}+(-1)^{n+1}\frac{\cos\theta
x}{(2n+2)!}x^{2n+2}=1-\frac{1}{2!}x^2+\frac{1}{4!}x^4+o(x^5)\)</span>.</li>
<li><span class="math inline">\(\tan
x=x+\frac{1}{3}x^3+\frac{2}{15}x^5+o(x^6)\)</span>.</li>
<li><span class="math inline">\(\ln
(1+x)=\sum_{k=1}^n\frac{(-1)^{k-1}x^k}{k}+(-1)^n\frac{x^{n+1}}{(n+1)(1+\theta
x)^{n+1}}=x-\frac{1}{2}x^2+\frac{1}{3}x^3+o(x^3)\)</span>.</li>
<li><span class="math inline">\((1+x)^\alpha=\sum_{k=0}^n\frac{\alpha^{\underline
k}}{k!}x^k+\frac{\alpha^{\underline{n+1}}}{(n+1)!}(1+\theta
x)^{\alpha-n-1}x^{n+1}\)</span>.</li>
</ol>
<h4><span id="解析函数">解析函数</span></h4>
<p>不妨设<span class="math inline">\(f_n(x,x_0)=\sum_{k=0}^nf^{(k)}(x_0)\frac{(x-x_0)^k}{k!}\)</span>.我们称<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处解析,若<span class="math inline">\(\exists \delta&gt;0\)</span>,<span class="math inline">\(\lim_{n\rightarrow
\infty}f_n(x,x_0)=f(x)\)</span>,也即泰勒展式在一个邻域上可以逼近原函数.</p>
<p>如果其在<span class="math inline">\((a,b)\)</span>上任何一点都解析,那么称其在<span class="math inline">\((a,b)\)</span>上解析,记作<span class="math inline">\(f\in C^\omega(a,b)\)</span>.</p>
<p>解析函数应当有如下性质:</p>
<ol type="1">
<li><span class="math inline">\(f,g\)</span>在<span class="math inline">\(x_0\)</span>处解析,那么<span class="math inline">\(f,g\)</span>的四则运算在<span class="math inline">\(x_0\)</span>处也解析.</li>
<li><span class="math inline">\(f,g\)</span>均解析,并且<span class="math inline">\(f\circ g\)</span>有意义,那么<span class="math inline">\(f\circ g\)</span>也解析.</li>
<li><span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处解析,那么<span class="math inline">\(f^{-1}\)</span>在<span class="math inline">\(f(x_0)\)</span>处解析.</li>
<li>初等函数基本是解析函数.</li>
</ol>
<p>对于(1):</p>
<p><span class="math inline">\(f\pm g\)</span>当然是平凡的,至于<span class="math inline">\(fg\)</span>和<span class="math inline">\(\frac{f}{g}\)</span>如何证明解析性,我们回头再说.</p>
<p>对于(2):</p>
<p>回头再说.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式<span class="math inline">\(P_n=\sum_{i=0}^{n}y_i(\prod_{j=0\and j\ne
i}^{n}\frac {x-x_j}{x_i-x_j})\\\)</span>.显然当<span class="math inline">\(x=x_i\)</span>时,该多项式的答案为<span class="math inline">\(y_i\)</span>.</p>
<p>用这个在一个函数<span class="math inline">\(f\in
C^{n+1}(a+b)\)</span>上打<span class="math inline">\(n+1\)</span>个点并且取出这个多项式<span class="math inline">\(P_n\)</span>,考虑它们的误差.取<span class="math inline">\(\omega
(x)=\prod_{k=0}^n(x-x_k)\)</span>,事实上有:<span class="math inline">\(f(x)=P_n(x)+\frac{f^{(n+1)}(\xi)}{(n+1)!}\omega(x)\)</span>.</p>
<p>取<span class="math inline">\(h(t)=f(t)-P_n(t)\)</span>,考虑对于一个固定的<span class="math inline">\(x\)</span>,取<span class="math inline">\(g(t)=\frac{h(x)}{\omega(x)}\omega(t)-h(t)\)</span>.注意到<span class="math inline">\(g(x)=0,g(x_i)=0\)</span>,所以<span class="math inline">\(g\)</span>有<span class="math inline">\(n+2\)</span>个零点,所以<span class="math inline">\(g^{(n+1)}\)</span>一定有一个零点,记为<span class="math inline">\(\xi\)</span>.</p>
<p>那么我们就有<span class="math inline">\(g^{(n+1)}(\xi)=\frac{h(x)}{\omega(x)}(n+1)!-f^{(n+1)}(\xi)=0\)</span>.上述命题就得证了.</p>
<p>那么怎么样能让<span class="math inline">\(\omega(x)\)</span>这个东西的最大值尽可能小呢?</p>
<p>我们定义所谓<span class="math inline">\(n\)</span>次切比雪夫多项式<span class="math inline">\(f\)</span>,使得对于任何一个首项为<span class="math inline">\(1\)</span>的多项式<span class="math inline">\(T_n\)</span>,<span class="math inline">\(\max
_{(a,b)}|T_n|\geq \max_{(a,b)}|f|\)</span>.</p>
<p>事实上<span class="math inline">\([-1,1]\)</span>上的切比雪夫多项式可以用递推关系描述:
<span class="math display">\[
P_n=\begin{cases}1&amp;n=0\\x&amp;n=1\\x^2-\frac{1}{2}&amp;n=2\\xP_{n-1}-\frac{1}{4}P_{n-2}&amp;otherwise\end{cases}
\]</span> 还可以写成<span class="math inline">\(P_n=\frac{1}{2^{n-1}}\cos(n\arccos
x)\)</span>.</p>
<h4><span id="函数的作图">函数的作图</span></h4>
<h5><span id="渐近线">渐近线</span></h5>
<p>如果对于一个函数<span class="math inline">\(y=f(x)\)</span>,存在一条直线<span class="math inline">\(l\)</span>使得函数上一点<span class="math inline">\(P(x,f(x))\)</span>距离原点距离<span class="math inline">\(\to +\infty\)</span>的时候,<span class="math inline">\((x,f(x))\)</span>与<span class="math inline">\(l\)</span>的距离<span class="math inline">\(\to
0\)</span>.</p>
<p>大概可以有以下几类渐近线:</p>
<ol type="1">
<li>水平渐近线:<span class="math inline">\(f(+\infty)=C\)</span>或<span class="math inline">\(f(-\infty)=C\)</span>.</li>
<li>垂直渐近线:<span class="math inline">\(f(x_0-0)=\infty\)</span>或<span class="math inline">\(f(x_0+0)=\infty\)</span>.</li>
<li>斜渐近线:<span class="math inline">\(l=kx+b\)</span>,那么<span class="math inline">\(\lim_{x\to+\infty}\frac{f(x)}{x}=a,\lim_{x\to
\infty}(f(x)-ax)=b\)</span>.</li>
</ol>
<h5><span id="作图">作图</span></h5>
<ol type="1">
<li>确定定义域和值域.</li>
<li>研究其奇偶性,周期性.</li>
<li>研究<span class="math inline">\(f&#39;(x)=0\)</span>的根以确定极值点和升降区间.</li>
<li>研究<span class="math inline">\(f&#39;&#39;(x)=0\)</span>的根找出拐点.</li>
<li>求出渐近线.</li>
</ol>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>目的是找到一个函数<span class="math inline">\(f\)</span>的零点,尝试取上面任何一点并作切线,找到切线与<span class="math inline">\(x\)</span>轴的交点.或者说任取<span class="math inline">\(x_0\)</span>,取<span class="math inline">\(x_{n+1}=x_n-\frac{f(x_n)}{f&#39;(x_n)}\)</span>.</p>
<p>我们需要证明这个做法的正确性,事实上:</p>
<p>如果<span class="math inline">\(f&#39;,f&#39;&#39;\)</span>在<span class="math inline">\([a,b]\)</span>上非零,<span class="math inline">\(\exists c\in [a,b],f(c)=0\)</span>,那我们取<span class="math inline">\(x_0\in [a,b]\)</span>满足<span class="math inline">\(f(x_0)f&#39;&#39;(x_0)&gt;0\)</span>,那么取<span class="math inline">\(x_{n+1}=x_n-\frac{f(x_n)}{f&#39;(x_n)}\)</span>的数列<span class="math inline">\(\{x_n\}\rightarrow c\)</span>.事实上:</p>
<ol type="1">
<li>当<span class="math inline">\(f&#39;f&#39;&#39;&gt;0\)</span>,<span class="math inline">\(x_n\)</span>单调下降趋近于<span class="math inline">\(c\)</span>.</li>
<li>当<span class="math inline">\(f&#39;f&#39;&#39;&lt;0\)</span>,<span class="math inline">\(x_n\)</span>单调上升趋近于<span class="math inline">\(c\)</span>.</li>
</ol>
<p>并且<span class="math inline">\(|x_n-c|\sim O(2^{-2^n})\)</span>.</p>
<p>上述讨论情况有点多,我们下面只讨论其中一种进行证明:</p>
<p>当<span class="math inline">\(f&#39;&gt;0,f&#39;&#39;&gt;0\)</span>的时候,<span class="math inline">\(f\)</span>是一个单调上升的下凸函数.容易发现这个数列单调下降并且应当大于<span class="math inline">\(c\)</span>,那它就有极限,两边取极限得知<span class="math inline">\(\lim_{n\to\infty}f(x_n)=0\)</span>.</p>
<p>接下来看一下逼近速度,泰勒公式展开一下知道<span class="math inline">\(0=f(c)=f(x_n)+f&#39;(x_n)(c-x_n)+\frac{f&#39;&#39;(\xi)}{2}(c-x_n)^2\)</span>.从上面的结果容易看出<span class="math inline">\(n\geq 1\)</span>的时候,<span class="math inline">\(|x_{n+1}-c|=\frac{|f(x_n)+f&#39;(x_n)(c-x_n)|}{|f&#39;(x_n)|}=\frac{f&#39;&#39;(\xi)}{2|f&#39;(x_n)|}(c-x_n)^2\)</span>.前面那个系数是有界的,可以看作一个常数.于是这一次的误差应当是上一次误差的平方级别.</p>
<h3><span id="积分">积分</span></h3>
<h4><span id="不定积分">不定积分</span></h4>
<p>如果存在可导函数<span class="math inline">\(F\)</span>满足<span class="math inline">\(F&#39;(x)=f(x)\)</span>,则称一个函数<span class="math inline">\(f\)</span>是<strong>可积</strong>的,<span class="math inline">\(F(x)\)</span>是<span class="math inline">\(f(x)\)</span>的<strong>原函数</strong>,或称其为<span class="math inline">\(f(x)\)</span>的不定积分.</p>
<p>我们之前已经证明过导数相等的两个函数最多只差一个常数,因此一个函数的原函数是有唯一的<span class="math inline">\(F(x)+C\)</span>的形式的.</p>
<h5><span id="不定积分的运算">不定积分的运算</span></h5>
<p>只给出以下两个运算法则: <span class="math display">\[
\int(f(x)\pm g(x))\text d x=\int f(x)\text d x\pm \int g(x)\text d x\\
\int \alpha f(x)\text d x=\alpha\int f(x)\text d x
\]</span></p>
<h5><span id="积分表">积分表</span></h5>
<ol type="1">
<li><span class="math inline">\(\int x^\alpha \text d
x=\frac{x^{\alpha+1}}{\alpha+1}+C,\alpha\ne -1\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{x}=\ln
|x|+C\)</span>.</li>
<li><span class="math inline">\(\int e^x\text d x=e^x+C\)</span>.</li>
<li><span class="math inline">\(\int \cos x \text d x=\sin
x+C\)</span>.</li>
<li><span class="math inline">\(\int \sin x \text d x=-\cos
x+C\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{\cos^2 x}=\tan
x+C\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{\sin^2 x}=-\cot
x+C=-\frac{1}{\tan x}+C\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{1+x^2}=\arctan
x+C\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{\sqrt
{1-x^2}}=\arcsin x+C\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{\sqrt{x^2\pm
a^2}}=\ln |x+\sqrt{x^2\pm a^2}|+C\)</span>.</li>
<li><span class="math inline">\(\int \sqrt{a^2-x^2}\text d
x=\frac{1}{2}(x\sqrt {a^2-x^2}+a^2\arcsin\frac{x}{a})+C\)</span>.</li>
<li><span class="math inline">\(\int \sqrt{x^2\pm a^2}\text d
x=\frac{1}{2}(x\sqrt{x^2\pm a^2}\pm a^2\ln|x+\sqrt {x^2\pm
a^2}|)+C\)</span>.</li>
</ol>
<h5><span id="换元法">换元法</span></h5>
<p>第一换元法:设<span class="math inline">\(\int g(t)\text d
t=G(t)+C\)</span>,<span class="math inline">\(w(x)\)</span>可导,则<span class="math inline">\(\int g(w(x))w&#39;(x)\text d
x=G(w(x))+C\)</span>.证明只需对右边求导即可.</p>
<p>第二换元法:设<span class="math inline">\(x(t)\)</span>可导,且有反函数<span class="math inline">\(t(x)\)</span>,那么如果<span class="math inline">\(\int f(x(t))x&#39;(t)\text d
t=G(t)+C\)</span>,则<span class="math inline">\(\int f\text d
x=G(t(x))+C\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I_n=\int \tan^n
x\text{d}x\)</span>.</p>
<p>注意到: <span class="math display">\[
I_n=\int \tan^{n-2}(\frac{1}{\cos^2 x}-1)\text dx\\=\int
\tan^{n-2}x(\text d\tan x)-I_{n-2}\\=\frac{\tan ^{n-1}x}{n-2}-I_{n-2}
\]</span> 边界条件的话<span class="math inline">\(I_0=x+C,I_1=\int
\frac{\sin x}{\cos x}\text d x=-\int\frac{1}{\cos x}(\text d\cos x)=-\ln
(\cos x)+C\)</span>.</p>
<h5><span id="分部积分">分部积分</span></h5>
<p>我们应当有<span class="math inline">\((uv)&#39;=u&#39;v+v&#39;u\)</span>,两边积分得到<span class="math inline">\(uv=\int u&#39;v\text dx+\int v&#39;u\text d
x\)</span>,变形得到<span class="math inline">\(\int v\text d u=uv-\int
u\text d v\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I_n=\int \cos^n x\text d
x\)</span>.</p>
<p>注意到: <span class="math display">\[
I_n=\int \cos^{n-1}x(\text d \sin x)\\=\cos^{n-1}x\sin x+(n-1)\int
\sin^2 x\cos ^{n-2}x\text d x\\
=\cos^{n-1}x\sin x+(n-1)\int (1-\cos^2 x) \cos ^{n-2}x\text d x\\
=\cos^{n-1}\sin x+(n-1)I_{n-2}-(n-1)I_n
\]</span> 整理得到<span class="math inline">\(I_n=\frac{1}{n}\cos^{n-1}x\sin
x+\frac{n-1}{n}I_{n-2}\)</span>.</p>
<p>边界条件当然是<span class="math inline">\(I_0=x+C,I_1=\sin
x+C\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I_n=\int \frac{\text d x}{\cos^n
x}\)</span>.</p>
<p>注意到: <span class="math display">\[
I_n=\int \frac{\text d \tan x}{\cos^{n-2} x}\\
=\frac{ \tan x}{\cos^{n-2} x}-\int \tan x(\text d \cos^{2-n}x)\\
=\frac{ \tan x}{\cos^{n-2} x}+(2-n)\int \cos^{-n} x\sin^2 x\text d x\\
=\frac{ \tan x}{\cos^{n-2} x}+(2-n)\int \cos^{-n} x(1-\cos^2 x)\text d
x\\
=\frac{ \tan x}{\cos^{n-2} x}+(2-n)I_n-(2-n)I_{n-2}
\]</span> 整理得到<span class="math inline">\(I_n=\frac{1}{n-1}\frac{\tan
x}{\cos^{n-2}x}+\frac{n-2}{n-1}I_{n-2}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(I_{m,n}=\int \sin^m x\cos (nx)\text d
x\)</span>,其中<span class="math inline">\(m&lt;n\)</span>.</p>
<p>注意到: <span class="math display">\[
I_{m,n}=\int \sin^m x\cos(nx)\text d x\\
=\frac{1}{n}\int \sin^m x\text d \sin (nx)\\
=\frac{1}{n}(\sin^m x\sin (nx)-\frac{m}{n}\int \sin (nx)\sin^{m-1}x\cos
x\text d x)
\]</span> 然后观察到: <span class="math display">\[
\int \sin (nx)\sin^{m-1}x\cos x\text d x\\
=-\frac{1}{n}\int \sin^{m-1} x\cos x\text d \cos(nx)\\
=-\frac{1}{n}(\cos (nx)\sin^{m-1}x\cos x-\int \cos (nx)(\text
d\sin^{m-1}x\cos x))
\]</span> 观察到: <span class="math display">\[
\int \cos (nx)(\text d\sin^{m-1}x\cos x)\\
=\int \cos(nx)(-\sin^{m}+(m-1)\sin^{m-2}x\cos^2x)\text d x\\
=\int \cos(nx)((m-1)\sin^{m-2}x-m\sin^m x))\text d x\\
=(m-1)I_{m-2,n}-mI_{m,n}
\]</span> 往回倒腾倒腾,边界条件是: <span class="math display">\[
I_{0,n}=\int \cos(nx)\text dx=\frac{\sin(nx)}{n}+C\\
I_{1,n}=\int \sin x\cos(nx)\text d
x\\=\frac{1}{2}\int(\sin((n+1)x)-\sin((n-1)x))\text d x\\
=\frac{1}{2}(\frac{-\cos((n+1)x)}{n+1}+\frac{\cos ((n-1)x)}{n-1})+C
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(I_n=\int \frac{\text d
x}{(x^2+a^2)^n}\)</span>.</p>
<p>注意到: <span class="math display">\[
I_n=\frac{x}{(x^2+a^2)^n}-\int x\text d \frac{1}{(x^2+a^2)^n}\\
=\frac{x}{(x^2+a^2)^n}+2n\int \frac{x^2+a^2-a^2}{(x^2+a^2)^{n+1}}\text d
x\\
=\frac{x}{(x^2+a^2)^n}+2nI_{n}-2a^2nI_{n+1}
\]</span> 边界是<span class="math inline">\(I_1=\frac{1}{a}\arctan
\frac{x}{a}+C\)</span>.</p>
<h6><span id="example5">Example5</span></h6>
<p>求<span class="math inline">\(I=\int x \cos ^3 x\text d
x\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
I=\int x \cos ^3 x\text d x=\int x\cos^2 x\text d(\sin x)\\
=x\cos^2 x\sin x-\int \sin x(\cos^2 x\text d x-2x\cos x\sin x)\\
=x\cos^2 x\sin x+\int \cos^2 x (\text d \cos x) +2\int x\cos x\sin^2
x\text d x\\
=x\cos^2 x\sin x+\frac{\cos^3 x}{3} +2\int x\cos x(1-\cos^2 x)\text d
x\\
=x\cos^2 x\sin x+\frac{\cos^3 x}{3} +2\int x\cos x\text d x-2I\\
=x\cos^2 x\sin x+\frac{\cos^3 x}{3} +2\int x(\text d \sin x)-2I\\
=x\cos^2 x\sin x+\frac{\cos^3 x}{3} +2(x\sin x+\cos x)-2I+C\\
\]</span> 也就是<span class="math inline">\(3I=x\cos^2 x\sin
x+\frac{\cos^3 x}{3} +2(x\sin x+\cos x)+C\)</span>.</p>
<h5><span id="有理分式的不定积分">有理分式的不定积分</span></h5>
<p>考虑真分式<span class="math inline">\(R(x)=\frac{P(x)}{Q(x)}\)</span>,其中<span class="math inline">\(\deg P(x)&lt;\deg
Q(x)\)</span>.至于其他分式可以做长除法变成真分式.</p>
<p>定义最简真分式形如<span class="math inline">\(\frac{A}{(x-a)^m},\frac{Bx+C}{(x^2+px+q)^n}\)</span>.</p>
<p>先证明一个引理:实数域上,任何一个多项式可以分解为若干不可约的一次多项式和二次多项式的乘积.</p>
<p>原因是复根一定成对出现,如果<span class="math inline">\(z\)</span>是复根,那么<span class="math inline">\(\bar z\)</span>一定也是复根,原因是<span class="math inline">\(\overline{zw}=\bar z\bar
w\)</span>,对一个多项式两边逐项取共轭就可以发现上述结论.那只需要把成对的复根扔到一个二次多项式里就行.</p>
<p>再证明一个引理:实数上,任何一个真分式都可以转化为若干最简真分式的线性组合.</p>
<p>先拆一次项,如上将<span class="math inline">\(Q(x)=(x-a)^mR(x)\)</span>,其中<span class="math inline">\(R(a)\ne 0\)</span>,那我们考虑: <span class="math display">\[
\frac{P(x)}{Q(x)}-\frac{A_1}{(x-a)^m}=\frac{P(x)-A_1R(x)}{(x-a)^mR(x)}\\
\]</span> 此时取<span class="math inline">\(A_1=\frac{P(a)}{R(a)}\)</span>,立刻见到<span class="math inline">\((x-a)|(P(x)-A_1R(x))\)</span>,于是上下至少少一次,这样就可以继续分解了.</p>
<p>再拆二次项,如上将<span class="math inline">\(Q(x)=(x^2+px+q)^mR(x)\)</span>,其中<span class="math inline">\((x^2+px+q)\nmid R(x)\)</span>,那: <span class="math display">\[
\frac{P(x)}{Q(x)}-\frac{A_1x+B_1}{(x^2+px+q)^m}=\frac{P(x)-(A_1x+B_1)R(x)}{(x^2+px+q)^mR(x)}
\]</span> 令<span class="math inline">\(T(x)=P(x)-(A_1x+B_1)R(x)\)</span>,类似上面应当要确定<span class="math inline">\(A_1,B_1\)</span>使得上面那部分是<span class="math inline">\(x^2+px+q\)</span>的倍数就可以.直接取<span class="math inline">\(x^2+px+q\)</span>的某个复根<span class="math inline">\(\alpha\)</span>,则只需<span class="math inline">\(T(\alpha)=0\)</span>即可,这是两个方程(实部虚部),而我们有两个未知数,理应可以解出答案.具体解得过程其实也可以直接把<span class="math inline">\(P(x)\)</span>和<span class="math inline">\(R(x)\)</span>直接先用多项式长除法杀一杀然后剩的部分判一下方程.</p>
<p>这样最后就只需要对拆出来的东西逐项积分就行.意味着有理函数的原函数是初等函数.</p>
<h5><span id="有理三角函数的不定积分">有理三角函数的不定积分</span></h5>
<p>即<span class="math inline">\(\sin x,\cos
x\)</span>经过有限步四则运算得到的函数.</p>
<p>我们定义二元有理函数<span class="math inline">\(R(u,v)\)</span>,那么有理三角函数实际上是<span class="math inline">\(R(\cos x,\sin x)\)</span>.</p>
<p>下面给出以下命题:</p>
<ol type="1">
<li>如果其对于<span class="math inline">\(u\)</span>是奇函数,也即<span class="math inline">\(R(u,v)=-R(-u,v)\)</span>,那么<span class="math inline">\(R(u,v)=uR_1(u^2,v)\)</span>,其中<span class="math inline">\(R_1\)</span>是另一个二元有理函数.如果对于<span class="math inline">\(v\)</span>是奇函数则同理.</li>
<li>当<span class="math inline">\(R(-u,-v)=R(u,v)\)</span>时,那么<span class="math inline">\(R(u,v)=R_1(\frac{u}{v},v^2)\)</span>.</li>
</ol>
<p>证明只需要拆做<span class="math inline">\(R(u,v)=\frac{P(u,v)}{Q(u,v)}\)</span>,其中<span class="math inline">\(P,Q\)</span>是两个多项式,然后只需简单书写即可证明.</p>
<p>对于(1)形式的有理三角函数,注意到: <span class="math display">\[
\int R(\cos x,\sin x)\text d x\\
=\int \cos xR(\cos^2x,\sin x)\text d x\\\\
=\int R_1(1-\sin ^2 x,\sin x)\text d(\sin x)\\
=\int R_1(1-t^2,t)\text d t
\]</span> 对于(2)形式的有理三角函数,我们有: <span class="math display">\[
\int R(\cos x,\sin x)\text d x\\
=\int R_1(\cot x,\sin^2 x)\text d x\\
\int R_1(\cot x,\frac{1}{1+\cot^2 x})\text d x\\
=\int R_1(t,\frac{1}{1+t^2})\frac{\text d t}{1+t^2}
\]</span>
有了这两种形式后呢?我们注意到任意的有理三角函数都可以表示为以上两种函数之和,原因是:
<span class="math display">\[
R(u,v)\\=\frac{R(u,v)-R(-u,v)}{2}\\+\frac{R(-u,v)-R(-u,-v)}{2}\\+\frac{R(-u,-v)+R(u,v)}{2}
\]</span> 或者,令<span class="math inline">\(t=\tan
\frac{x}{2}\)</span>,那么<span class="math inline">\(\sin
x=\frac{2t}{1+t^2},\cos x=\frac{1-t^2}{1+t^2},\text d x=2\frac{\text d
t}{1+t^2}\)</span>.</p>
<h5><span id="无理函数的不定积分">无理函数的不定积分</span></h5>
<p>我们考虑以下几类无理函数:</p>
<p>第一类是<span class="math inline">\(R(x,\sqrt[m]{\frac{ax+b}{cx+d}})\)</span>的形式.只需做换元<span class="math inline">\(t^m=\frac{a_1x+b_1}{a_2x+b_2}\)</span>,立刻得到原式其实就是<span class="math inline">\(R(\frac{b_2t^m-b_1}{a_1-a_2t^m},t)\)</span>,并且<span class="math inline">\(\text d x\)</span>也可以转化到<span class="math inline">\(\text d t\)</span>.</p>
<p>第二类是形如<span class="math inline">\(\int x^m(a+bx^n)^p\text d
x\)</span>,其中<span class="math inline">\(m,n,p\in \mathbb
Q\)</span>.</p>
<p>令<span class="math inline">\(t=x^n\)</span>,上式就变成了<span class="math inline">\(\frac{1}{n}\int t^{\frac{m+1}{n}-1}(a+bt)^p\text d
t\)</span>.令<span class="math inline">\(q=\frac{m+1}{n}-1\)</span>.我们只需要做<span class="math inline">\(\frac{1}{n}\int t^q(a+bt)^p\text d
t=\frac{1}{n}\int
t^{p+q}(\frac{a+bt}{t})^p\)</span>.事实上,下面三种情况可以积出来:</p>
<ol type="1">
<li><span class="math inline">\(p\in \Z\)</span>.</li>
<li><span class="math inline">\(q\in \Z\)</span>.</li>
<li><span class="math inline">\(p+q\in \Z\)</span>.</li>
</ol>
<p>其它的都无初等形式.</p>
<p>第三类是形如<span class="math inline">\(R(x,\sqrt
{ax^2+bx+c})\)</span>,不妨假设<span class="math inline">\(b^2-4ac\ne
0,a\ne 0\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(b^2-4ac&gt;0\)</span>,则有两个实根<span class="math inline">\(\alpha&gt;\beta\)</span>,此时提一下实根就可以知道原式等于<span class="math inline">\(R(x,(x-\beta)\sqrt{\frac{a(x-\alpha)}{x-\beta}})\)</span>,这就能做了.</li>
<li><span class="math inline">\(b^2-4ac&lt;0\)</span>,则无实根,不妨假设<span class="math inline">\(a&gt;0\)</span>.则做<span class="math inline">\(t-\sqrt a
x=\sqrt{ax^2+bx+c}\)</span>并两边平方就可以反解出<span class="math inline">\(x=\frac{t^2-c}{b+2\sqrt a
t}\)</span>,原本的积分就变成了关于<span class="math inline">\(t\)</span>的有理函数的积分.</li>
</ol>
<h5><span id="双曲换元">双曲换元</span></h5>
<p>引入双曲三角函数<span class="math inline">\(\sinh
(x)=\frac{e^x-e^{-x}}{2},\cosh=\frac{e^x+e^{-x}}{2}\)</span>以及<span class="math inline">\(\tanh(x)=\frac{\sinh(x)}{\cosh(x)}\)</span>.留意到<span class="math inline">\(\cosh^2-\sinh^2=1\)</span>.以及:</p>
<ol type="1">
<li><span class="math inline">\(\frac{\text d }{\text d
x}\sinh(x)=\cosh(x)\)</span></li>
<li><span class="math inline">\(\frac{\text d }{\text d
x}\cosh(x)=\sinh(x)\)</span></li>
<li><span class="math inline">\(\frac{\text d }{\text d
x}\tanh(x)=\frac{1}{\cosh^2(x)}=1-\tanh^2(x)\)</span></li>
</ol>
<p>应当发现:</p>
<ol type="1">
<li><span class="math inline">\(\sinh(2x)=2\sinh(x)\cosh(x)\)</span></li>
<li><span class="math inline">\(\cosh(2x)=\cosh^2(x)+\sinh^2(x)=2\cosh^2(x)-1=1+2\sinh^2(x)\)</span></li>
</ol>
<p>另外其反函数应当是:</p>
<ol type="1">
<li><span class="math inline">\(\text{arsinh}(x)=\ln(x+\sqrt{x^2+1})\)</span></li>
<li><span class="math inline">\(\text{arcosh}(x)=\ln(x+\sqrt{x^2-1})\)</span></li>
</ol>
<p>应当发现:</p>
<ol type="1">
<li><span class="math inline">\(\frac{\text d }{\text d
x}\text{arsinh}(x)=\frac{1}{\sqrt{x^2+1}}\)</span></li>
<li><span class="math inline">\(\frac{\text d }{\text d
x}\text{arcosh}(x)=\frac{1}{\sqrt{x^2-1}}\)</span></li>
<li><span class="math inline">\(\frac{\text d }{\text d
x}\text{artanh}(x)=\frac{1}{1-x^2}\)</span></li>
</ol>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I=\int \frac{\text d x}{\sqrt{x^2\pm
a^2}}\)</span>,其中<span class="math inline">\(a&gt;0\)</span>.</p>
<p>留意到:</p>
<ol type="1">
<li><span class="math inline">\(\text{arsinh}(x)=\ln(x+\sqrt{x^2+1})\)</span></li>
<li><span class="math inline">\(\text{arcosh}(x)=\ln(x+\sqrt{x^2-1})\)</span></li>
</ol>
<p>而且:</p>
<ol type="1">
<li><span class="math inline">\(\frac{\text d }{\text d
x}\text{arsinh}(x)=\frac{1}{\sqrt{x^2+1}}\)</span></li>
<li><span class="math inline">\(\frac{\text d }{\text d
x}\text{arcosh}(x)=\frac{1}{\sqrt{x^2-1}}\)</span></li>
</ol>
<p>于是<span class="math inline">\(\int \frac{\text d x}{\sqrt{x^2\pm
a^2}}=\ln |x+\sqrt{x^2\pm a^2}|+C\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I=\int \sqrt{a^2-x^2}\text d
x\)</span>.</p>
<p>考虑三角换元,应当小心符号,这里注意到<span class="math inline">\(x\in
[-a,a]\)</span>,因此直接取<span class="math inline">\(x=a\sin
t\)</span>,<span class="math inline">\(t\in
[-\frac{\pi}{2},\frac{\pi}{2}]\)</span>,此时<span class="math inline">\(\cos t \geq 0\)</span>恒成立,则有:</p>
<p><span class="math display">\[
I=a^2\int \cos^2 t\text d t\\
=a^2\int \frac{1+\cos(2t)}{2}\text d t\\
=\frac{a^2t}{2}+\frac{a^2}{4}\sin (2t)+C\\
=\frac{1}{2}(x\sqrt {a^2-x^2}+a^2\arcsin\frac{x}{a})+C
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(I=\int \sqrt{x^2\pm a^2}\text d
x\)</span>.</p>
<p>使用双曲换元,先考虑<span class="math inline">\(\int \sqrt{x^2+
a^2}\text d x\)</span>的情况,此时换<span class="math inline">\(x=a\sinh
t\)</span>,<span class="math inline">\(\cosh t\geq
0\)</span>,根号是平凡开出的,应当有:</p>
<p><span class="math display">\[
I=a^2\int \cosh^2 t\text d t\\
=a^2\int\frac{1+\cosh (2t)}{2}\text d t\\
=\frac{a^2t}{2}+\frac{a^2}{4}\sinh (2t)+C\\
=\frac{1}{2}(x\sqrt {x^2+a^2}+a^2\text{arsinh}\frac{x}{a})+C
\]</span></p>
<p>另一个同理,仍然使用双曲换元,结果是<span class="math inline">\(\frac{1}{2}(x\sqrt
{x^2-a^2}+a^2\text{arcosh}\frac{x}{a})+C\)</span></p>
<h5><span id="椭圆积分">椭圆积分</span></h5>
<p>以下是几个常见的无初等形式的积分:</p>
<ol type="1">
<li><span class="math inline">\(\int \frac{e^x}{x}\text d
x\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d x}{\ln
x}\)</span>.</li>
<li><span class="math inline">\(\int \frac{\sin x}{x}\text d
x\)</span>.</li>
<li><span class="math inline">\(\int \frac{\cos x}{x}\text d
x\)</span>.</li>
<li><span class="math inline">\(\int e^{x^2}\text d x\)</span>.</li>
</ol>
<p>另外还有一类椭圆积分也无初等形式:设<span class="math inline">\(R(x,y)\)</span>是二元有理函数,其中<span class="math inline">\(y=\sqrt {P_3(x)}\)</span>或<span class="math inline">\(\sqrt
{P_4(x)}\)</span>,也即根号下放了个三次或者四次多项式,那么<span class="math inline">\(\int R(x,y)\text d
x\)</span>可能很难有初等形式.这样的积分可以被归结为三类椭圆积分.</p>
<p>首先说明<span class="math inline">\(R(x,\sqrt
{P_3(x)})\)</span>可以转化,原因是<span class="math inline">\(P_3(x)=0\)</span>一定有至少一个实数解,任意取出一个设为<span class="math inline">\(\lambda\)</span>,则<span class="math inline">\(P_3(x)=(x-\lambda)P_2(x)\)</span>,令<span class="math inline">\(t^2+\lambda=x\)</span>,带入可以转化为<span class="math inline">\(R(t^2+\lambda,\sqrt
{P_2(t^2+\lambda)})=R_1(t,\sqrt
{P_4(t)})\)</span>.这就意味着其实根号下四次多项式是更本质一些的.</p>
<p>而四次多项式可以分解为<span class="math inline">\(P_4(x)=a(x^2+p_1x+q_1)(x^2+p_2x+q_2)\)</span>.不妨假设其无重根(如果有重根的话,那么根号下就可以开出去一部分,那就可积了),设其四个根(可能有复根)分别为<span class="math inline">\(\alpha_1,\beta_1,\alpha_2,\beta_2\)</span>,并且<span class="math inline">\(\alpha_1,\beta_1\)</span>是上述分解中前半部分的根,特别地,如果这是四个实根,则不妨调整它们的顺序使得<span class="math inline">\(\alpha_1&gt;\beta_1&gt;\alpha_2&gt;\beta_2\)</span>.那么根据韦达定理总有:<span class="math inline">\(p_1=-(\alpha_1+\beta_1),q_1=\alpha_1\beta_1\)</span>,后半部分同理.</p>
<p>我们尝试把这两个式子的一次项都去掉,当<span class="math inline">\(p_1=p_2\)</span>的时候可以直接一起配方令<span class="math inline">\(x=t-\frac{p}{2}\)</span>.当<span class="math inline">\(p_1\ne p_2\)</span>的时候,尝试换元用<span class="math inline">\(t\)</span>代替<span class="math inline">\(x\)</span>,不妨设<span class="math inline">\(x=\frac{u t+v}{1+t}\)</span>,那么<span class="math inline">\((x^2+p_1x+q_1)=\frac{P_2&#39;(t)}{(1+t)^2}\)</span>.为了让其没有一次项应当解以下方程:
<span class="math display">\[
\begin{cases}
2u v+p_1(u +v)+2q_1=0\\
2u v+p_2(u +v)+2q_2=0
\end{cases}
\]</span> 此时可以解出来<span class="math inline">\(\begin{cases}u+v=-\frac{2(q_1-q_2)}{p_1-p_2}\\u
v=\frac{p_2q_1-p_1q_2}{p_1-p_2}\end{cases}\)</span>,为了解出<span class="math inline">\(u ,v\)</span>是两个实数,应当检验<span class="math inline">\((u+v)^2-4uv\geq
0\)</span>是否成立.带入韦达定理发现左边等于<span class="math inline">\((\alpha_1-\alpha_2)(\alpha_1-\beta_2)(\beta_1-\alpha_2)(\beta_1-\beta_2)&gt;0\)</span>.原因是如果是四个实根,则根据假设立刻得到.如果存在复根则配对一下复根也可以立刻得到.</p>
<p>总之,在上面的一系列操作后,我们要研究的形式统一成了<span class="math inline">\(R(t,y=\sqrt{A(1+m_1t^2)(1+m_2t^2)})=\frac{a(t)+b(t)y}{c(t)+d(t)y}=B_1(t)+B_2(t)y\)</span>,其中<span class="math inline">\(B_1(t),B_2(t)\)</span>都是<span class="math inline">\(t\)</span>的有理函数.前者可以直接积分拆出去,那我们关心的就只剩下后面的<span class="math inline">\(B_2(t)y=\frac{B_2(t)y}{y}\)</span>的部分.</p>
<p>我们之前已经提过可以将一个函数拆为偶函数和奇函数之和,事实上: <span class="math display">\[
R(t)=\frac{R(t)+R(-t)}{2}+\frac{R(t)-R(-t)}{2}=R_1(t^2)+tR_2(t^2)
\]</span> 那么后者立刻可以换元积分,只剩下前者做不动.剩下的形式是:<span class="math inline">\(\int \frac{R(t^2)}{\sqrt
{A(1+m_1t^2)(1+m_2t^2)}}\text d t\)</span>,其中<span class="math inline">\(A\)</span>可以先扔出去一些,使得<span class="math inline">\(A=\pm
1\)</span>.而且由于被积函数是偶函数,所以还可以不妨设<span class="math inline">\(t\geq
0\)</span>.由于根号下不能变成二次函数(不然就直接做完了),还不妨设<span class="math inline">\(m_1\ne m_2,m_1\ne 0,m_2\ne
0\)</span>.下面开始讨论:</p>
<ol type="1">
<li><span class="math inline">\(A=1\)</span>,<span class="math inline">\(m_1=-h_1^2,m_2=-h_2^2,h_1&gt;h_2&gt;0\)</span>.</li>
</ol>
<p>此时令<span class="math inline">\(t=\frac{z}{h_1}\)</span>带入化简变形再扔出去点常数得到原式变化为<span class="math inline">\(\int \frac{R(z^2)}{\sqrt{(1-z^2)(1-k^2z^2)}}\text
d z\)</span>,其中<span class="math inline">\(k=\frac{h_2}{h_1}\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(A=1\)</span>,<span class="math inline">\(m_1=-h_1^2,m_2=h_2^2,h_1&gt;0,h_2&gt;0\)</span>.</li>
</ol>
<p>此时令<span class="math inline">\(t=\frac{\sqrt{1-z^2}}{h_1}\)</span>.扔出去一些常数仍然可以化简成(1)的形式,只是<span class="math inline">\(k=\frac{h_2}{\sqrt{h_1^2+h_2^2}}\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(A=1,m_1=h_1^2,m_2=h_2^2,h_1&gt;h_2&gt;0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t=\frac{z}{h_1\sqrt{1-z^2}}\)</span>.扔出去一些常数仍然是(1)的形式,只是<span class="math inline">\(k=\frac{\sqrt{h_1^2-h_2^2}}{h_1}\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(A=-1\)</span>,<span class="math inline">\(m_1=-h_1^2,m_2=h_2^2,h_1&gt;0,h_2&gt;0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t=\frac{1}{h_1\sqrt{1-z^2}}\)</span>,还是(1)的形式,只是<span class="math inline">\(k=\frac{h_1}{\sqrt{h_1^2+h_2^2}}\)</span>.</p>
<ol start="5" type="1">
<li><span class="math inline">\(A=-1\)</span>,<span class="math inline">\(m_1=-h_1^2,m_2=-h_2^2,h_1&gt;h_2&gt;0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t=\frac{\sqrt{1-\frac{h_1^2-h^2_2}{h_1^2}z^2}}{h_2}\)</span>,还是(1),只是<span class="math inline">\(k=\frac{\sqrt{h_1^2-h_2^2}}{h_1}\)</span>.</p>
<p>这样就全都转化为了<span class="math inline">\(\int
\frac{R(z^2)}{\sqrt{(1-z^2)(1-k^2z^2)}}\text d
z\)</span>的形式了.然后把<span class="math inline">\(R(z^2)\)</span>给拆开,那么这个式子就应该是<span class="math inline">\(I_n=\int\frac{z^{2n}}{\sqrt{(1-z^2)(1-k^2z^2)}}\text
d z\)</span>和<span class="math inline">\(H_m=\int\frac{\text d
z}{(z^2-a)^m\sqrt{(1-z^2)(1-k^2z^2)}}\)</span>的线性组合,注意这里系数有可能是复数.</p>
<p>此时注意到 <span class="math display">\[
(z^{2n-3}\sqrt{(1-z^2)(1-k^2z^2)})&#39;\\
=(2n-3)z^{2n-4}\sqrt{(1-z^2)(1-k^2z^2)}+z^{2n-3}\frac{2k^2z^3-(k^2+1)z}{\sqrt{(1-z^2)(1-k^2z^2)}}\\
=\frac{(2n-3)z^{2n-4}{(1-z^2)(1-k^2z^2)}+z^{2n-3}(2k^2z^3-(k^2+1)z)}{\sqrt{(1-z^2)(1-k^2z^2)}}\\
=\frac{(2n-1)k^2z^{2n}-(2n-2)(k^2+1)z^{2n-2}+(2n-3)z^{2n-4}}{\sqrt{(1-z^2)(1-k^2z^2)}}
\]</span> 两边积分得到: <span class="math display">\[
(2n-1)k^2I_n-(2n-2)(k^2+1)I_{n-1}+(2n-3)I_{n-2}\\
=z^{2n-3}\sqrt{(1-z^2)(1-k^2z^2)}
\]</span> 上述只要<span class="math inline">\(n\)</span>是整数就行,甚至不需要<span class="math inline">\(n\)</span>是正的.所以所有的<span class="math inline">\(I_n\)</span>,包括负整数<span class="math inline">\(n\)</span>,都可以被<span class="math inline">\(I_0,I_1\)</span>表示.</p>
<p>接下来看<span class="math inline">\(H_m\)</span>,当<span class="math inline">\(a=0\)</span>的时候无非是<span class="math inline">\(H_m=I_{-m}\)</span>,</p>
<p>接下来注意到: <span class="math display">\[
(\frac{z}{(z^2-a)^{m-1}}\sqrt{(1-z^2)(1-k^2z^2)})&#39;\\
=\frac{(2-2m)z^2+z^2-a}{(z^2-a)^m}\sqrt{(1-z^2)(1-k^2z^2)}\\
+\frac{2k^2z^4-(k^2+1)z^2}{\sqrt{(1-z^2)(1-k^2z^2)}}\frac{1}{(z^2-a)^{m-1}}\\
\]</span> 令<span class="math inline">\(C=\sqrt{(1-z^2)(1-k^2z^2)}\)</span>,<span class="math inline">\(W=z^2-a\)</span>,那么<span class="math inline">\(C^2=k^2(W+a)^2-(k^2+1)(W+a)+1\)</span>.上式化简为:
<span class="math display">\[
=\frac{(2-2m)(W+a)C^2}{W^mC}+\frac{C^2+2k^2(W+a)^2-(k^2+1)(W+a)}{W^{m-1}C}\\
=\frac{(2-2m)(W+a)(k^2(W+a)^2-(k^2+1)(W+a)+1)}{W^mC}\\+\frac{3k^2(W+a)^2-2(k^2+1)(W+a)+1}{W^{m-1}C}
\]</span> 接下来是繁复的化简,然后两边积分得到: <span class="math display">\[
\frac{z}{(z^2-a)^{m-1}}\sqrt{(1-z^2)(1-k^2z^2)}\\
=(2m-2)(-a+(k^2+1)a^2-k^2a^3)H_m\\
-(2m-3)(1-2a(k^2+1)+3k^2a^2)H_{m-1}\\
+(2m-4)(k^2+1-3k^2a)H_{m-2}\\
-(2m-5)k^2H_{m-3}
\]</span> 而注意到<span class="math inline">\(H_0=I_0,H_{-1}=I_1-aI_0\)</span>.</p>
<p>综上,所有的椭圆积分都可以由<span class="math inline">\(I_0,I_1,H_1\)</span>表示.也就是椭圆积分可以转化为以下三种积分:</p>
<ol type="1">
<li><span class="math inline">\(\int\frac{\text d
z}{\sqrt{(1-z^2)(1-k^2z^2)}}\)</span>.</li>
<li><span class="math inline">\(\int \frac{z^2\text d
z}{\sqrt{(1-z^2)(1-k^2z^2)}}\)</span>.</li>
<li><span class="math inline">\(\int \frac{\text d
z}{(1+hz^2)\sqrt{(1-z^2)(1-k^2z^2)}}\)</span>,其中<span class="math inline">\(h\)</span>可以是复数.</li>
</ol>
<p>有意思的是如果令<span class="math inline">\(z=\sin
\varphi\)</span>,<span class="math inline">\(\text d z=\sqrt{1-z^2}\text
d
\varphi\)</span>,这样形式就好看了很多.椭圆积分可以用以下的优美形式表示:</p>
<ol type="1">
<li><span class="math inline">\(E(k,\varphi)=\int\frac{\text d
\varphi}{\sqrt{1-k^2\sin^2\varphi}}\)</span>.</li>
<li><span class="math inline">\(F(k,\varphi)=\int\sqrt{1-k^2\sin^2\varphi}\ \text
d \varphi\)</span>.</li>
<li><span class="math inline">\(\Pi(h,k,\varphi)=\int \frac{\text d
\varphi}{(1+h\sin^2\varphi)\sqrt{1-k^2\sin^2\varphi}}\)</span>,其中<span class="math inline">\(h\)</span>可以是复数.</li>
</ol>
<p>其中: <span class="math display">\[
\int \frac{z^2\text d z}{\sqrt{(1-z^2)(1-k^2z^2)}}=\int
\frac{\sin^2\varphi\text d
\varphi}{\sqrt{1-k^2\sin^2\varphi}}\\=\int(\frac{1}{k^2\sqrt{1-k^2\sin^2\varphi}}\text
)-\frac{1-k^2\sin^2\varphi}{k^2\sqrt{1-k^2\sin^2\varphi}}\text )d
\varphi\\
=\frac{E(k,\varphi)}{k^2}-\frac{F(k,\varphi)}{k^2}
\]</span></p>
<h4><span id="黎曼积分">黎曼积分</span></h4>
<p>设<span class="math inline">\(f(x)\)</span>是定义在<span class="math inline">\([a,b]\)</span>上的函数,对于区间<span class="math inline">\([a,b]\)</span>插入分点<span class="math inline">\(x_i(i=0,1,\cdots,n)\)</span>,且有<span class="math inline">\(a=x_0&lt;x_1&lt;\cdots&lt;x_n=b\)</span>,我们称之为对区间<span class="math inline">\([a,b]\)</span>的一种<strong>分割</strong>,并记为<span class="math inline">\(\Delta\)</span>.又记<span class="math inline">\(\Delta x_i=x_i-x_{i-1},i\in[1,n]\)</span>,<span class="math inline">\(\lambda(\Delta)=\max\{\Delta x_i\mid
i\in[1,n]\}\)</span>,并定义黎曼和<span class="math inline">\(S_\Delta=\sum_{i=1}^nf(\xi_i)\Delta
x_i\)</span>.</p>
<p>若存在实数<span class="math inline">\(J\)</span>,对<span class="math inline">\(\forall \epsilon&gt;0,\exists
\delta&gt;0\)</span>,对于任意分划,只要<span class="math inline">\(\lambda(\Delta)&lt;\delta\)</span>,都有<span class="math inline">\(|S_\Delta -J|&lt;\epsilon\\\)</span>,则称<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上<strong>黎曼可积</strong>,这个<span class="math inline">\(J\)</span>为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上的<strong>定积分</strong>,记作<span class="math inline">\(\int_{a}^b f(x)\text d
x\\\)</span>.容易见到定积分唯一,证明无非也是拿<span class="math inline">\(\epsilon\)</span>去卡.</p>
<p>对于<span class="math inline">\([a,b]\)</span>上的连续函数,定积分实际上就是其与<span class="math inline">\(f(x)\)</span>围成面积的代数和.</p>
<p>由此可以顺便定义<strong>达布上下和</strong>,即令<span class="math inline">\(m_i=\inf_{[x_{i-1},x_i]}f(x),M_i=\sup_{[x_{i-1},x_i]}f(x)\)</span>,并定义<strong>振幅</strong><span class="math inline">\(w_i=M_i-m_i\)</span>,特别地定义<span class="math inline">\(M=\sup(M_i),m=\inf(m_i)\)</span>.定义<span class="math inline">\(\overline S_\Delta=\sum M_i\Delta x_i,\underline
S_{\Delta}=\sum m_i\Delta
x_i\)</span>.并在此基础上定义上下积分,上积分<span class="math inline">\(\overline{\int_a^b}f(x)\text d x=\inf \overline
S_\Delta,\underline{\int_a^b}f(x)\text d x=\sup \underline
S_\Delta\)</span>.我们会在后面证明可积等价于上下积分存在且相等.</p>
<p>为了方便,我们约定:</p>
<ol type="1">
<li><span class="math inline">\(a=b\)</span>,<span class="math inline">\(\int _a^b f(x)\text d x=0\)</span>.</li>
<li><span class="math inline">\(a&gt;b\)</span>,<span class="math inline">\(\int _a^b f(x)\text d x=-\int _b^a f(x)\text d
x\)</span>.</li>
</ol>
<p>下列性质应当是成立的:</p>
<ol type="1">
<li>(必要条件)如果一个函数黎曼可积,则它在该闭区间上有界.</li>
<li>对于任意分划任取<span class="math inline">\(\xi\)</span>,<span class="math inline">\(\underline{S}_\Delta\leq S_\Delta(\xi)\leq
\overline S_\Delta\)</span>.</li>
<li><span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists \xi_1,\xi_2\)</span>,使得<span class="math inline">\(\underline S_\Delta-\epsilon\leq
S_\Delta(\xi_1)\)</span>,<span class="math inline">\(\overline
S_\Delta+\epsilon\geq S_\Delta(\xi_2)\)</span>.</li>
</ol>
<p>再定义所谓加细:如果<span class="math inline">\(\Delta_1\subseteq
\Delta_2\)</span>,那么称<span class="math inline">\(\Delta_2\)</span>是<span class="math inline">\(\Delta_1\)</span>的加细.此时应当有<span class="math inline">\(\overline S_{\Delta_1}\geq \overline
S_{\Delta_2},\underline S_{\Delta_1}\leq \underline
S_{\Delta_2}\)</span>.另外容易注意到如果<span class="math inline">\(|\Delta_2\setminus \Delta_1|=k\)</span>,那么<span class="math inline">\(0\leq \overline S_{\Delta_1}-\overline
S_{\Delta_2} \leq
k\lambda(\Delta_1)(M-m)\)</span>,原因是考虑把这些新的断点一个一个加上去,每次加一个会新断开原本的断点,此时最多造成<span class="math inline">\((M-m)\Delta x\leq
(M-m)\lambda(\Delta_1)\)</span>的差.注意到此时这些东西似乎全都可以被限制住.</p>
<p>这同样给出了原因:为什么我们会定义上下积分呢?因为随着分点的加多,也就是随着划分的加细,达布上下和会分别单调递减或递增,这样就应当存在一个极限,然而问题在于我们难以在划分上定义序,这样就少了某种极限的方式.然而,我们试图绕开来找到一种确定的能探到极限的方式.</p>
<p>另外的结论是对于任意两个分划<span class="math inline">\(\Delta_1,\Delta_2\)</span>,总有<span class="math inline">\(\underline S_{\Delta_1}\leq \overline
S_{\Delta_2}\)</span>.原因是<span class="math inline">\(\Delta=\Delta_1\cup
\Delta_2\)</span>,立刻见到<span class="math inline">\(\underline
S_{\Delta_1}\leq \underline S_{\Delta}\leq \overline S_\Delta\leq
\overline S_{\Delta_2}\)</span>.这意味着<span class="math inline">\(\overline \int f\geq \underline \int
f\)</span>.</p>
<p>接下来证明定积分中的达布定理,也就是<span class="math inline">\(\forall \epsilon&gt;0,\exists
\delta&gt;0\)</span>,<span class="math inline">\(\forall
\Delta,\lambda(\Delta)&lt;\delta\)</span>的时候,<span class="math inline">\(0\leq \overline S_\Delta-\overline
{\int_a^b}f(x)\text d x\leq \epsilon\)</span>.换言之<span class="math inline">\(\lim_{\lambda(\Delta)\to 0}\overline
S_{\Delta}=\overline{\int_a^b}f(x)\text d
x\)</span>,当然下积分也是同理的.</p>
<p>这个的证明考虑先用上积分的定义,应当存在一个<span class="math inline">\(\Delta&#39;\)</span>,满足<span class="math inline">\(0\leq \overline S_{\Delta&#39;}-\overline
{\int_a^b}f(x)\text d x\leq \frac \epsilon 2\)</span>.不妨设<span class="math inline">\(|\Delta&#39;|=n_0\)</span>,接下来取<span class="math inline">\(\delta&lt;\frac{\epsilon}{2n_0(M-m)}\)</span>,那么接下来对于<span class="math inline">\(\forall
\Delta,\lambda(\Delta)&lt;\delta\)</span>的时候,取<span class="math inline">\(\Delta^*=\Delta&#39;\cup
\Delta\)</span>,根据上面我们证明的步骤,这里最多会多<span class="math inline">\(n_0\)</span>个断点,自然得知<span class="math inline">\(\overline S_{\Delta}-\overline S_{\Delta^*}\leq
n_0\lambda(\Delta)(M-m)&lt;\frac{\epsilon}{2}\)</span>.</p>
<p>这样的话就可以注意到: <span class="math display">\[
\overline S_\Delta-\overline{\int_a^b}f(x)\text d x\\=(\overline
S_{\Delta&#39;}-\overline{\int_a^b}f(x)\text d x)-(\overline
S_{\Delta&#39;}-\overline S_{\Delta})\\
&lt;\frac{\epsilon}{2}-(\overline S_{\Delta^*}-\overline
S_\Delta)&lt;\epsilon
\]</span></p>
<p>这里可以证明原函数可积的充分必要条件是上下积分相等.</p>
<p>首先证明充分性:当上下积分相等的时候,设其为<span class="math inline">\(J\)</span>,取足够小的<span class="math inline">\(\epsilon\)</span>,由上知道<span class="math inline">\(\exists \delta&gt;0\)</span>,使得<span class="math inline">\(J-\epsilon&lt;\underline S_\Delta\leq
S_\Delta(\xi)\leq\overline
S_\Delta&lt;J+\epsilon\)</span>,夹逼一下立刻知道其满足.</p>
<p>然后证明必要性:当原函数可积分的时候,应当有<span class="math inline">\(J-\epsilon&lt;\underline S_\Delta\leq
\underline{\int}f(x)\text d x\leq\overline{\int}f(x)\text d
x\leq\overline S_\Delta&lt; J+\epsilon\)</span>.</p>
<p>而由于我们可以见到上和和下和应当是错开来的,而如果它们中间能接上自然意味着上下积分相等.因此推论为:如果<span class="math inline">\(f\)</span>在闭区间上有界并且<span class="math inline">\(\forall \epsilon,\exists \Delta\)</span>使得<span class="math inline">\(0\leq \overline S_\Delta- \underline S_\Delta\leq
\epsilon\)</span>,则<span class="math inline">\(f\)</span>可积.我们最初拿到的那个定义也可以这么改:只需要存在一个分划而不需要使得任意分划都这么满足.方式就是用我们已经找到的这个去并我们想要限制的那个,然后把限制延后一点使得这些全被限制住.</p>
<p>由上述可以证明闭区间上的连续函数一定是闭区间上的可积函数.原因是闭区间上的连续函数一定是一致连续函数,那么对于一个<span class="math inline">\(\epsilon\)</span>,可以找到一个<span class="math inline">\(\delta\)</span>控制住区间长度,使得极差<span class="math inline">\(&lt;\epsilon\)</span>.此时直接找一个<span class="math inline">\(\Delta\)</span>,注意到<span class="math inline">\(\overline S-\underline S=\sum (M_i-m_i)\Delta
x_i\leq \sum \epsilon \Delta x\leq (b-a)\epsilon\)</span>,只需取<span class="math inline">\(\epsilon\to 0\)</span>就可以证明二者相等.</p>
<p>还可以证明如果<span class="math inline">\(f\)</span>在闭区间上有界并且只有有限个间断点,那么<span class="math inline">\(f\)</span>可积.原因也很简单,只需要拿足够小的区间把这有限个间断点盖住,然后外面继续如上操作,间断点处尽可能缩小区间长度来取出其影响.</p>
<p>还可以证明单调函数一定可积,原因是<span class="math inline">\(\overline S-\underline S\leq \delta(f(b)-f(a))\to
0\)</span>.</p>
<h5><span id="可积性与连续性的关系勒贝格定理">可积性与连续性的关系(勒贝格定理)</span></h5>
<p>我们还可以进一步探索黎曼可积和连续性的关系,例如,我们可以证明:<span class="math inline">\(\forall f\in R[a,b],\forall \epsilon&gt;0,\exists
g\in C[a,b] \int_a^b |f(x)-g(x)|\text d x&lt;\epsilon\)</span>.</p>
<p>如何证明呢?感觉上只需要用分段线性函数去逼近一下就可以了对吧.所以我们考虑对于划分<span class="math inline">\(\Delta\)</span>,直接把所有的<span class="math inline">\((x_i,f(x_i))\)</span>连起来形成一个分段线性函数.然后观察此时的<span class="math inline">\(|f-g|\)</span>,不妨分段考虑,对于<span class="math inline">\(\int_{x_{i-1}}^{x_i}(f-g)(x)\text d x\leq
(M_i-m_i)\Delta x_i\)</span>,而后者求和之后实际上就是<span class="math inline">\(\overline S-\underline S\)</span>,当<span class="math inline">\(f\)</span>可积的时候这个当然会趋近于<span class="math inline">\(0\)</span>.</p>
<p>我们还可以证明<span class="math inline">\(f\in
R[a,b]\)</span>的连续点在<span class="math inline">\([a,b]\)</span>上稠密,只需要证明<span class="math inline">\(\forall [\alpha,\beta]\in
R[a,b],\alpha&lt;\beta\)</span>,<span class="math inline">\([\alpha,\beta]\)</span>这个区间内存在连续点即可.考虑定义一点处的振幅<span class="math inline">\(w_{f}(x_0)=\lim_{\delta\to
+0}w_f(x_0-\delta,x_0+\delta)\)</span>,这个随着<span class="math inline">\(\delta\)</span>缩小当然应当是单调变化的,因此一定有非负极限(但可能是无穷大).我们注意到<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处连续的充要条件是<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处的振幅为<span class="math inline">\(0\)</span>.必要性和充分性都容易证明.</p>
<p>我们考虑用区间套来找到这个连续点,考虑对于<span class="math inline">\([\alpha_0,\beta_0]\in [a,b]\)</span>,取分划<span class="math inline">\(\Delta_0\)</span>使得<span class="math inline">\(\sum w_i\Delta
x_i&lt;\frac{1}{2}(\beta_0-\alpha_0)\)</span>,并且加细使得<span class="math inline">\(\lambda(\Delta_0)&lt;\frac{1}{2}(\beta_0-\alpha_0)\)</span>,此时考虑由于<span class="math inline">\(\sum \Delta
x_i=\beta_0-\alpha_0\)</span>,所以一定存在一个<span class="math inline">\(w_i&lt;\frac{1}{2}\)</span>,拿出这个区间作为<span class="math inline">\([\alpha_1,\beta_1]\)</span>,则区间长度至少折半,并且只需在上述对<span class="math inline">\([\alpha_n,\beta_n]\)</span>时取<span class="math inline">\(\sum w_i\Delta
x_i&lt;\frac{1}{2^{n+1}}(\beta_0-\alpha_0)\)</span>就可以使得<span class="math inline">\(w_i\)</span>也趋近于<span class="math inline">\(0\)</span>,这样就能用区间套找到一个点使得它是连续点.</p>
<p>事实上可以证明一个函数黎曼可积的充分必要条件是其有界并且几乎处处连续.</p>
<p>为了方便不妨把<span class="math inline">\(f\)</span>延拓到整个实轴,令<span class="math inline">\(f(x)=\begin{cases}f(a)&amp;x\leq a\\f(b)&amp;x\geq
b\\f(x)&amp;otherwise\end{cases}\)</span>.</p>
<p>下面定义<span class="math inline">\(E_r=\{x_0\mid w_f(x_0)\geq
\frac{1}{r}\}\)</span>.我们考虑证明其是闭集,也就是证明其补集<span class="math inline">\(E_r^c=\{x_0\in (a,b)\mid
w_f(x_0)&lt;\frac{1}{r}\}\)</span>是开集.如果<span class="math inline">\(x_0\in E_r^c\)</span>,注意到此时<span class="math inline">\(\exists
\delta&gt;0,w_f(x_0-\delta,x_0+\delta)&lt;\frac{1}{r}\)</span>,那么这必然意味着<span class="math inline">\(x_0\)</span>邻域中的点的振幅也会<span class="math inline">\(&lt;\frac{1}{r}\)</span>,这当然意味着其是开集.</p>
<p>令<span class="math inline">\(D\)</span>是<span class="math inline">\(f\)</span>的间断点集,容易见到<span class="math inline">\(D=\bigcup_{n=1}^{\infty}E_n\)</span>,下面只需要证明每个<span class="math inline">\(E_n\)</span>都是零测集即可.</p>
<p>先证明必要性:当<span class="math inline">\(f\in
R[a,b]\)</span>时,则<span class="math inline">\(f\)</span>有界,现在对于固定的<span class="math inline">\(m\)</span>,尝试证明<span class="math inline">\(E_m\)</span>是零测的,由达布定理,<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists \Delta\)</span>,使得<span class="math inline">\(\sum w_i\Delta x_i=\overline S_\Delta-\underline
S_\Delta&lt;\epsilon\)</span>.</p>
<p>观察前者,注意到:</p>
<p><span class="math display">\[
\epsilon&gt;\sum w_i\Delta x_i=\overline S_\Delta-\underline S_\Delta\\
=\sum_{E_m\cap (x_{k-1},x_k)\ne \empty}w_k\Delta x_k+\sum_{E_m\cap
(x_{k-1},x_k)=\empty}w_k\Delta x_k\\
\geq \frac{1}{m}\sum_{E_m\cap (x_{k-1},x_k)}\Delta x_k
\]</span></p>
<p>因此<span class="math inline">\(\sum_{E_m\cap (x_{k-1},x_k)}\Delta
x_k&lt;m\epsilon\)</span>,由于<span class="math inline">\(m\)</span>一开始就固定,<span class="math inline">\(\epsilon\)</span>可以尽量小,所以这意味着<span class="math inline">\(E_m\)</span>是零测集.必要性得证.</p>
<p>再证明充分性:当每一个<span class="math inline">\(E_m\)</span>都是零测集的时候,<span class="math inline">\(\forall \epsilon&gt;0\)</span>,取<span class="math inline">\(r\in
N_+,r&gt;\frac{1}{\epsilon}\)</span>.此时见到<span class="math inline">\(E_{r}^c\)</span>是开集,那它可以写成若干两两不交开区间的并,不妨记作<span class="math inline">\(E_r^c=\bigcup_{k=1}^{\infty}T_k\)</span>.由于此时<span class="math inline">\(E_m\)</span>是零测集,这意味着<span class="math inline">\(\sum |T_k|=b-a\)</span>.接下来可以取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\sum_1^n
|T_k|&gt;b-a-\frac{\epsilon}{2}\)</span>,接下来取<span class="math inline">\(T_k\)</span>的闭子区间<span class="math inline">\(J_k\)</span>,使得<span class="math inline">\(\sum_1^n
|J_k|&gt;b-a-\epsilon\)</span>.这里为什么要把开区间再进一步缩成闭区间呢?原因是你这里如果直接用开区间构造分划可能会把端点处给包进去,因此我们不得不设其端点处的一部分值拿到闭区间,这样那些振幅较大的就被舍弃了.</p>
<p>接下来考虑由于每个点<span class="math inline">\(x_0\in
J_k\)</span>的<span class="math inline">\(w_f(x_0)&lt;\frac{1}{r}&lt;\epsilon\)</span>,必定有其一个小邻域<span class="math inline">\((x_0-\delta,x_0+\delta)\)</span>满足整个邻域的振幅<span class="math inline">\(&lt;\epsilon\)</span>,用有限覆盖定理拿出一个开覆盖,然后缩掉这些开覆盖的区间就能拿到一个<span class="math inline">\(J_k\)</span>的分划(或者干脆将这些开区间的端点和<span class="math inline">\(J_k\)</span>的端点直接当作一个分划),把这些分划全都并起来就得到了一个划分<span class="math inline">\(\Delta\)</span>.</p>
<p>此时观察这个划分,应当有:</p>
<p><span class="math display">\[
\overline S_\Delta-\underline S_\Delta\\
=\sum w_k\Delta x_k\\
=\sum_{[x_{k-1},x_k]\subseteq \bigcup J_i}w_k\Delta
x_k+\sum_{[x_{k-1},x_k]\subsetneq \bigcup J_i}w_k\Delta
x_k\\&lt;\epsilon(b-a)+(M-m)\epsilon
\]</span></p>
<p>这样就可以使其任意小.</p>
<p>上述证明同样声明了:黎曼可积的充要条件是震荡区间超过某个值的区间长度之和随着细分的增加应当尽可能小.</p>
<p>上述结论立刻能见到比如黎曼函数是黎曼可积的,因为其间断点集就是有理点集,就是零测集.</p>
<h5><span id="可积函数的简单性质">可积函数的简单性质</span></h5>
<p>不妨设<span class="math inline">\(f,g\in R[a,b]\)</span>,则:</p>
<ol type="1">
<li><span class="math inline">\(m(b-a)\leq \int_a^b f(x)\text d x\leq
M(b-a)\)</span>.</li>
<li><span class="math inline">\(f\geq 0\)</span>则<span class="math inline">\(\int_a^b f(x)\text d x\geq 0\)</span>.</li>
<li><span class="math inline">\(\int_{a}^b(f\pm g)\text d
x=\int_a^bf\text d x\pm \int_a^bg\text d x\)</span>.</li>
<li><span class="math inline">\(\int_{a}^bCf\text d x=C\int_a^bf\text d
x\)</span>.</li>
<li>(保序性)<span class="math inline">\(f\geq g\)</span>则<span class="math inline">\(\int_a^b f\text d x\geq \int_a^bg\text d
x\)</span>.事实上只要<span class="math inline">\(f\geq
g\)</span>在一个稠密子集上成立即可.</li>
<li>如果<span class="math inline">\(c\in [a,b]\)</span>,那么此时<span class="math inline">\(f\in R[a,c],f\in R[c,b]\)</span>,并且<span class="math inline">\(\int_a^b f\text d x=\int_a^c f\text d x+\int_c^b
f\text d x\)</span>.</li>
<li>如果<span class="math inline">\(g\)</span>是连续函数,那么<span class="math inline">\(g(f(x))\in R[a,b]\)</span>.</li>
<li><span class="math inline">\(|f|\in R[a,b]\)</span>,并且<span class="math inline">\(|\int_a^b f(x)\text d x|\leq \int_a^b|f(x)|\text d
x\)</span>.</li>
<li>如果除了一个有限的点集以外,<span class="math inline">\(g=f\)</span>,则<span class="math inline">\(g\in
R[a,b]\)</span>并且<span class="math inline">\(\int_a^bg\text d
x=\int_a^b f\text d x\)</span>.</li>
<li>如果<span class="math inline">\(f\geq 0,\int_a^b f\text d
x=0\)</span>,那么<span class="math inline">\(f\)</span>在其连续点集合上恒等于<span class="math inline">\(0\)</span>.</li>
</ol>
<p>(1)(2)是显然的,(3)(4)(5)只需将积分看作黎曼和的极限,(6)的话考虑在<span class="math inline">\([a,b]\)</span>上间断点集都是零测的了,那么其子集<span class="math inline">\([a,c],[c,b]\)</span>上的间断点集当然也是零测集.</p>
<p>(7)的话考虑一个几乎处处连续的函数在外面套一层连续函数当然也是几乎处处连续的.</p>
<p>(8)的话考虑绝对值函数是连续函数,然后注意到<span class="math inline">\(-|f(x)|\leq f(x)\leq
|f(x)|\)</span>使用保序性就可以了.</p>
<p>(9)的证明是简单的.但是为什么是有限点集而不是零测集呢?因为如果是无限个点,那么它们不仅会影响自己的连续性,还会影响旁边点的连续性,例如迪利克雷函数.这里可以看出来黎曼函数是有其限制性的,推广到勒贝格积分后会消除这个问题.</p>
<p>(10)的话只需考虑反证法,对于一个连续点<span class="math inline">\(x_0\)</span>,如果<span class="math inline">\(f(x_0)&gt;0\)</span>,那么周围应当有一个小邻域也大于<span class="math inline">\(0\)</span>,或者干脆用介值定理取<span class="math inline">\(&gt;\frac{f(x)}{2}\)</span>的一个小邻域,这样就反证完了.</p>
<h5><span id="广义原函数">广义原函数</span></h5>
<p>对于<span class="math inline">\(f(x):I\to R\)</span>,称<span class="math inline">\(F(x)\)</span>为其<strong>广义原函数</strong>,若<span class="math inline">\(\forall c,d\in I,c&lt;d\)</span>满足<span class="math inline">\(\frac{F(d)-F(c)}{d-c}\in[\inf_{[c,d]}
f(x),\sup_{[c,d]}
f(x)]\)</span>.容易见到原函数一定是广义原函数,原因是拉格朗日中值定理.</p>
<p>应当容易注意到以下命题:</p>
<ol type="1">
<li>局部有界函数的广义原函数是局部李氏连续的,故几乎处处有导数.</li>
<li><span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处连续,<span class="math inline">\(F(x)\)</span>是<span class="math inline">\(f(x)\)</span>的广义原函数,则<span class="math inline">\(F&#39;(x_0)\)</span>存在并且恰好等于<span class="math inline">\(f(x_0)\)</span>.</li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的证明的话,考虑<span class="math inline">\(|\frac{F(x)-F(x_0)}{x-x_0}-f(x_0)|\leq
w_f[x_0,x]\)</span>,由于<span class="math inline">\(f(x_0)\)</span>连续,那么此时其振幅<span class="math inline">\(w_f[x_0,x]\)</span>在<span class="math inline">\(x\to x_0\)</span>时应当趋近于<span class="math inline">\(0\)</span>,于是证毕.</p>
<h5><span id="牛顿-莱布尼茨公式微积分基本定理">牛顿-莱布尼茨公式(微积分基本定理)</span></h5>
<p>先证明一个引理:如果<span class="math inline">\(f(x)\in
[a,b]\)</span>,<span class="math inline">\(F(x)\)</span>是其广义原函数,那么$f(x)d
xF(b)-F(a)f(x)d x $.</p>
<p>证明的话,只需证明对于任意分划<span class="math inline">\(\Delta\)</span>都有<span class="math inline">\(\underline{S}_\Delta (f)\leq F(b)-F(a)\leq
\overline{S}_\Delta f(x)\)</span>.而注意到<span class="math inline">\(F(b)-F(a)=\sum F(x_i)-F(x_{i-1})=\sum
\frac{F(x_i)-F(x_{i-1})}{x_i-x_{i-1}}\Delta
x_i\)</span>.而根据广义原函数的定义,<span class="math inline">\(m_i\leq
\frac{F(x_i)-F(x_{i-1})}{x_i-x_{i-1}}\leq M_i\)</span>,立刻证毕.</p>
<p>由此显然证明了牛顿-莱布尼茨公式(LN公式):设<span class="math inline">\(f(x)\in
R[a,b]\)</span>,并且能找到其一个广义原函数<span class="math inline">\(F(x)\)</span>,则<span class="math inline">\(F(b)-F(a)=\int_a^b f(x)\text d x\)</span>.</p>
<p>接下来声明一个定理:如果一个函数<span class="math inline">\(f(x)\in
R[a,b]\)</span>,它就存在广义原函数,而且不同的广义原函数最多相差一个常数.</p>
<p>先证明存在性,我们注意到变限积分<span class="math inline">\(F(x)=\int_a^x f(t)\text d t\)</span>显然是<span class="math inline">\(f(x)\)</span>的广义原函数,只需套用定义就可以证明.</p>
<p>再证唯一性,设<span class="math inline">\(F_1(x),F_2(x)\)</span>都是<span class="math inline">\(f(x)\)</span>的广义原函数.根据LN公式,有<span class="math inline">\(F_1(x)-F_1(a)=\int_{a}^xf(t)\text d
t=F_2(x)-F_2(a)\)</span>,立刻有<span class="math inline">\(F_1(x)-F_2(x)=F_1(a)-F_2(a)=C\)</span>.</p>
<p>此时回忆到<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处连续可以推出<span class="math inline">\(F(x)\)</span>可导,那么反过来是否成立呢?考虑以下经典反例:</p>
<p><span class="math display">\[
F(x)=\begin{cases}0&amp;x=0\\x^2\sin
\frac{1}{x}&amp;otherwise\end{cases}\\
f(x)=F&#39;(x)=\begin{cases}0&amp;x=0\\2x\sin\frac{1}{x}-\cos\frac{1}{x}&amp;otherwise\end{cases}
\]</span></p>
<p>但总之可以看到连续函数一定有原函数,原因是连续函数是黎曼可积的.</p>
<p>此时回忆到我们曾经定义过左右上下导数<span class="math inline">\((F_\pm)&#39;\)</span>和<span class="math inline">\((F^\pm)&#39;\)</span>.设<span class="math inline">\(f\in R[a,b]\)</span>,<span class="math inline">\(F\)</span>是<span class="math inline">\(f\)</span>的广义原函数,不妨直接设<span class="math inline">\(F(x)=\int_a^x f(t)\text d
t\)</span>,那么我们声明<span class="math inline">\(\int_a^b(F_\pm)&#39;\text d
x=\int_a^b(F^\pm)&#39;\text d x=\int_a^b f(x)\text d x\)</span>.</p>
<p>四个证明类似,只考虑其中之一<span class="math inline">\(F_+&#39;\)</span>如何证明.取<span class="math inline">\(m&#39;=\inf_{[c,d]}f\)</span>,下面令<span class="math inline">\(G(x)=F(x)-F(c)+m&#39;(x-c)=\int_c^x(f(t)-m&#39;)\text
d t\)</span>.当<span class="math inline">\(x\in
[c,d]\)</span>时,容易发现<span class="math inline">\(G(x)\)</span>单增.既然如此,其任意左右上下导数当然都<span class="math inline">\(\geq 0\)</span>,也就是<span class="math inline">\((G_+)&#39;=(F_+)&#39;-m&#39;\geq
0\)</span>.同理如果取<span class="math inline">\(M&#39;=\sup_{[c,d]}f\)</span>的话还可以证明<span class="math inline">\((F_+)&#39;\leq M&#39;\)</span>.</p>
<p>那么就有<span class="math inline">\(w_{F_+&#39;}[c,d]\leq
w_{f}[c,d]\)</span>,我们知道<span class="math inline">\(f\)</span>是黎曼可积的,也就是<span class="math inline">\(0\leq \sum w_{F_+&#39;}[x_{i-1},x_i]\Delta x_i\leq
\sum w_f[x_{i-1},x_i]\Delta
x_i&lt;\epsilon\)</span>,此时就可以证明其可积性.</p>
<p>而注意到<span class="math inline">\(f\)</span>几乎处处连续,<span class="math inline">\(F\)</span>几乎处处可导,并且在<span class="math inline">\(f\)</span>的连续点处<span class="math inline">\(f(x)=F_+&#39;\)</span>,这个连续点集当然是稠密集,因此它们的积分相等,这样就做完了.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\int_a^b\text{sgn}(x)\text d
x\)</span>.</p>
<p>注意到<span class="math inline">\(\text{sgn}(x)\)</span>的广义原函数是<span class="math inline">\(|x|\)</span>,所以<span class="math inline">\(\int_a^b\text{sgn}(x)\text d
x=|b|-|a|\)</span>.</p>
<h6><span id="example2黎曼引理">Example2(黎曼引理)</span></h6>
<p>设<span class="math inline">\(f\in R[a,b],g\in
R[0,T]\)</span>并且<span class="math inline">\(g\)</span>在<span class="math inline">\(\R\)</span>上以<span class="math inline">\(T\)</span>为周期.求证:<span class="math inline">\(\lim_{\lambda\to \infty}\int_a^bf(x)g(\lambda
x)\text d x=\cfrac{\int_0^T g(x)\text d x}{T}\int_a^b f(x)\text d
x\)</span>.</p>
<p>首先注意到:</p>
<p><span class="math display">\[
\lim_{\lambda\to \infty}\int_a^bf(x)g(\lambda x)\text d x\\
=\lim_{\lambda\to \infty}\int_a^bf(x)(g(\lambda x)-\cfrac{\int_0^T
g(x)\text d x}{T}+\cfrac{\int_0^T g(x)\text d x}{T})\text d x\\
\]</span></p>
<p>因此可以用<span class="math inline">\(g(\lambda x)-\cfrac{\int_0^T
g(x)\text d x}{T}\)</span>代替<span class="math inline">\(g\)</span>,这样就能满足<span class="math inline">\(\int_0^T g(x)\text d x=0\)</span>.</p>
<p>接下来只需证明<span class="math inline">\(\lim_{\lambda\to
\infty}\int_a^bf(x)g(\lambda x)\text d x=0\)</span>,不妨设<span class="math inline">\(|f(x)|\leq M,|g(x)|\leq M\)</span>.</p>
<p>考虑对分划<span class="math inline">\(\Delta\)</span>,满足<span class="math inline">\(\sum w_i\Delta x_i\leq \epsilon\)</span>:</p>
<p><span class="math display">\[
|\int_a^b f(x)g(\lambda x)\text d x|\\
=|\sum \int_{x_{i-1}}^{x_i}(f(x)-f(x_i)+f(x_i))g(\lambda x)\text d x|\\
\leq |\sum \int_{x_{i-1}}^{x_i}f(x_i)g(\lambda x)\text d x|+|\sum
\int_{x_{i-1}}^{x_i}(f(x)-f(x_i))g(\lambda x)\text d x|\\
\leq \sum |f(x_i)|\sdot|\int_{x_{i-1}}^{x_i}g(\lambda x)\text d x|+M\sum
w_i\Delta x_i\\
\leq M\sum |\int_{x_{i-1}}^{x_i}g(\lambda x)\text d x|+M\sum w_i\Delta
x_i\\
\leq M\sum |\frac{1}{\lambda}\int_{\lambda x_{i-1}}^{\lambda
x_i}g(x)\text d x|+M\epsilon
\]</span></p>
<p>接下来设<span class="math inline">\(G(x)=\int_0^x g(t)\text d
t\)</span>,由于<span class="math inline">\(g\)</span>的周期性,而且其在任何一个长度为<span class="math inline">\(T\)</span>的区间上积分为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(|G(x)|\leq W\)</span>,那么<span class="math inline">\(\forall x,y,|G(x)-G(y)|\leq 2W\)</span>.</p>
<p>那么上式就<span class="math inline">\(\leq
2MW\frac{n}{\lambda}+M\epsilon\)</span>,这里虽然有个无穷大的<span class="math inline">\(n\)</span>,但由于<span class="math inline">\(\lambda\)</span>可以尽可能大且在<span class="math inline">\(n\)</span>之后决定取值,因此这个影响可以被消除.</p>
<p>这个命题的一个平凡推论是<span class="math inline">\(g(x)=\sin
(nx)\)</span>:</p>
<p><span class="math display">\[
\lim_{\lambda\to \infty}\int_a^b f(x)\sin(\lambda x){\rm
d}x=\lim_{\lambda \to \infty}\int_a^b f(x)\cos(\lambda x){\rm d}x=0
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\lim_{n\to\infty}I_n\)</span>,其中<span class="math inline">\(I_n=\frac{1}{n^{1+\alpha}}(\sum_{k=1}^nk^\alpha)=\frac{1}{n}\sum_{k=1}^n(\frac{k}{n})^\alpha\)</span>.</p>
<p>注意到<span class="math inline">\(n\to
\infty\)</span>的时候,上面就等于<span class="math inline">\(\int_0^1
x^\alpha\text d x=\frac{1}{1+\alpha}\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\int_0^{\frac{\pi}{2}}\frac{\sin((2n+1)x)}{\sin
x}\text d x\)</span>.</p>
<p>注意到根据积化和差有:</p>
<p><span class="math display">\[
\int_0^{\frac{\pi}{2}}\frac{\sin((2n+1)x)}{\sin x}\text d x\\
=\int_0^{\frac{\pi}{2}}(1+2\sum_k \cos(2kx))\text d x\\
=\frac{\pi}{2}+2\sum_{k}\frac{1}{2k}\sin(k\pi)\\
=\frac{\pi}{2}
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p>考虑<span class="math inline">\(f\in R\)</span>,<span class="math inline">\(\forall a&lt;b\)</span>,都有<span class="math inline">\(f\in R[a,b]\)</span>,已知<span class="math inline">\(f(x)=\int_0^xf(t)\text d t\)</span>,求证<span class="math inline">\(f\equiv 0\)</span>.</p>
<p>首先注意到变限积分是李氏连续的,因此<span class="math inline">\(f\)</span>当然就是局部李氏连续的,因此自然看出<span class="math inline">\(f\)</span>在<span class="math inline">\(\R\)</span>上都是连续的.既然如此,那<span class="math inline">\(f\)</span>就在<span class="math inline">\(\R\)</span>上处处可导并且<span class="math inline">\(f&#39;(x)\equiv f(x)\)</span>,同理还可以看出<span class="math inline">\(f\)</span>实际上任意阶可导.理应见到<span class="math inline">\(f\)</span>应当和<span class="math inline">\(e^x\)</span>有关,凑<span class="math inline">\(g(x)=\frac{f(x)}{e^x}\)</span>,则<span class="math inline">\(g&#39;(x)=\frac{f&#39;-f}{e^x}\equiv
0\)</span>,这立刻得到<span class="math inline">\(g(x)\equiv
C\)</span>.</p>
<p>然而<span class="math inline">\(g(0)=f(0)=0\)</span>,于是<span class="math inline">\(g\equiv C\equiv 0\)</span>,所以<span class="math inline">\(f\equiv 0\)</span>.</p>
<h5><span id="换元法">换元法</span></h5>
<p>不妨设<span class="math inline">\(f\in R[a,b],F&#39;=f\)</span>,<span class="math inline">\(\varphi(t):[\alpha,\beta]\to [a,b]\)</span>,<span class="math inline">\(\varphi(\alpha)=a,\varphi(\beta)=b\)</span>,并且<span class="math inline">\(\varphi\)</span>可导,而且<span class="math inline">\(f(\varphi(t))\varphi&#39;(t)\in
R[\alpha,\beta]\)</span>,则:</p>
<p><span class="math display">\[
\int_a^b f(x)\text d x=\int_\alpha^\beta
f(\varphi(t))\varphi&#39;(t)\text d t
\]</span></p>
<p>证明的话,考虑考虑NL公式,应当有:</p>
<p><span class="math display">\[
(F(\varphi(t)))&#39; = f(\varphi(t))\varphi&#39;(t)\\
\int_\alpha^\beta (F(\varphi(t)))&#39; = \int_\alpha^\beta
f(\varphi(t))\varphi&#39;(t)\\
F(b)-F(a)=\int_\alpha^\beta f(\varphi(t))\varphi&#39;(t)
\]</span></p>
<p>然而回忆到有原函数和是否黎曼可积之间是有区别的,适当调整条件可以得到另一个策略的换元法:不妨设<span class="math inline">\(f\in R[a,b],\varphi(t):[\alpha,\beta]\to
[a,b]\)</span>,并且<span class="math inline">\(\varphi(t)\)</span>单增,<span class="math inline">\(\varphi(\alpha)=a,\varphi(\beta)=b\)</span>,<span class="math inline">\(\varphi\)</span>可导并且<span class="math inline">\(\varphi&#39;\in R[\alpha,\beta]\)</span>,则<span class="math inline">\(f(\varphi(t))\varphi&#39;(t)\in
R[\alpha,\beta]\)</span>且上述积分仍然成立.</p>
<p>策略是对两边做黎曼和,利用<span class="math inline">\(\varphi\)</span>的单调性和一致连续性,可以取<span class="math inline">\(S_{\Delta}=\sum f(\eta_k)\Delta
x_k\)</span>,利用中值定理可以写作<span class="math inline">\(S_{\Delta}=\sum
f(\varphi(\xi_k))\varphi&#39;(\mu_k)\Delta t_k\)</span>.</p>
<p>而另一边的黎曼和<span class="math inline">\(\sigma_{\Delta&#39;}=\sum
f(\varphi(\xi_k))\varphi&#39;(\xi_k)\Delta t_k\)</span>.</p>
<p>只需证明二者之差趋近于<span class="math inline">\(0\)</span>,令<span class="math inline">\(M=\sup |f|,\)</span>做差得到:</p>
<p><span class="math display">\[
|\sum f(\varphi(\xi_k))(\varphi&#39;(\xi_k)-\varphi&#39;(\mu_k))\Delta
t_k|\\
\leq M|\sum (\varphi&#39;(\xi_k)-\varphi&#39;(\mu_k))\Delta t_k|\\
\leq M|\sum w_k\Delta t_k|
\]</span></p>
<p>而<span class="math inline">\(\varphi\)</span>可积,上述趋近于<span class="math inline">\(0\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\int_0^{\frac{\pi}{2}} \frac{\sin
x}{\sin x +\cos x}\text d x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\int_0^a\frac{f(x)}{f(x)+f(x-a)}\text d x=\frac{a}{2}
\]</span></p>
<p>于是上式<span class="math inline">\(=\frac{\pi}{4}\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I=\int_0^\pi\frac{\theta\sin
\theta}{a+b\cos^2\theta}\text d \theta\)</span>,其中<span class="math inline">\(a,b&gt;0\)</span>.</p>
<p>令<span class="math inline">\(\theta=\pi-\varphi\)</span>,应当有:</p>
<p><span class="math display">\[
I=-\int_\pi^0 \frac{(\pi-\varphi)\sin \varphi}{a+b\cos^2\varphi}\text d
\varphi\\
=\int_0^\pi \frac{(\pi-\varphi)\sin \varphi}{a+b\cos^2\varphi}\text d
\varphi\\
=\pi\int_{0}^\pi\frac{\sin\varphi}{a+b\cos^2\varphi}\text d \varphi-I
\]</span></p>
<p>移项得到:</p>
<p><span class="math display">\[
I=\frac{\pi}{2}\int_0^\pi\frac{-\text d \cos \theta}{a+b\cos^2\theta}\\
=\frac{\pi}{\sqrt{ab}}\arctan\sqrt{\frac{b}{a}}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>如果<span class="math inline">\(\forall a&lt;b,f\in
R[a,b]\)</span>,并且<span class="math inline">\(f(x+y)=f(x)+f(y)\)</span>恒成立,求证<span class="math inline">\(f(x)\equiv f(1)x\)</span>.</p>
<p>固定<span class="math inline">\(x\)</span>,对<span class="math inline">\(y\)</span>从<span class="math inline">\([0,1]\)</span>积分,得到:</p>
<p><span class="math display">\[
f(x)=\int_x^{x+1} f(t)\text d t-\int_0^1 f(y)\text d y
\]</span></p>
<p>而变限积分是局部李氏连续的,所以<span class="math inline">\(f(x)\)</span>局部连续,所以<span class="math inline">\(f(x)\)</span>整体连续,立刻得到<span class="math inline">\(f(x)\)</span>可导,立刻得到其是<span class="math inline">\(C^\infty\)</span>的.</p>
<p>那就可以两边求导,得到<span class="math inline">\(f&#39;(x+y)=f&#39;(y)\)</span>,因此<span class="math inline">\(f&#39;\equiv C\)</span>.</p>
<h5><span id="分部积分">分部积分</span></h5>
<p>设<span class="math inline">\(u,v\in
R[a,b]\)</span>并且均可导,而且<span class="math inline">\(u&#39;,v&#39;\in R[a,b]\)</span>,则:</p>
<p><span class="math display">\[
(uv)&#39;=u&#39;v+uv&#39;
\]</span></p>
<p>从这里能看出<span class="math inline">\((uv)&#39;\)</span>也是黎曼可积的,那就可以用牛顿莱布尼茨公式两边积分得到:</p>
<p><span class="math display">\[
\int_a^buv&#39;\text d x= uv\mid_a^b - \int_a^b u&#39;v\text d x
\]</span></p>
<p>这个版本当然是简单的,那能不能上点难度呢?</p>
<p>不妨考虑<span class="math inline">\(f,g\in
R[a,b]\)</span>,那它们的广义原函数可以取为<span class="math inline">\(F(x)=\int_a^x f(t)\text d t+A,G(x)=\int_a^x
g(t)\text d t +B\)</span>.</p>
<p>则<span class="math inline">\(\int_a^bFg\text d x=FG\mid_a^b-\int_a^b
Gf\text d x\)</span>.</p>
<p>先证明一个引理:</p>
<p><span class="math display">\[
\lim \sum_k^n f(\xi_k)\int_{x_{i-1}}^{x_i}g(t)\text d
t=\int_a^bf(x)g(x)\text d x
\]</span></p>
<p>证明无非是用黎曼和,设<span class="math inline">\(M=\sup|f|\)</span>,直接考虑:</p>
<p><span class="math display">\[
|\sum_k^n f(\xi)\int_{x_{i-1}}^{x_i}-\sum_k^n\int_{x_{i-1}}^{x_i}fg\text
d t|\\
\leq \sum|f(\xi_k)|\int_{x_{i-1}}^{x_i}|g(t)-g(\xi_k)|\text d t+|\sum
f(\xi_k)g(\xi_k)\Delta t_k-\int_a^bf g \text d t|\\
\leq M\sum w_k(g)\text d t+\sum w_k(fg)\Delta t_i
\]</span></p>
<p>这个当然趋向于<span class="math inline">\(0\)</span>.</p>
<p>使用abel求和法则,得到:</p>
<p><span class="math display">\[
(FG)\mid_a^b = \sum_k(F(x_k)G(x_k)-F(x_{k-1})G(x_{k-1}))\\
=\sum_{k}^n G(x_k)(F(x_k)-F(x_{k-1}))+\sum_{k}
F(x_{k-1})(G(x_i)-G(x_{i-1}))\\
=\sum_k^n G(x_i)\int_{x_{i-1}}^{x_i}f(x)\text d x+\sum_{k}^n
F(x_{i-1})\int_{x_{i-1}}^{x_i}g(x)\text d x
\]</span></p>
<p>使用引理就完事了.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:</p>
<p><span class="math display">\[
\int_a^x(\int_a^t f(u)\text d u)\text d t=\int_a^x(x-t)f(t)\text d t
\]</span></p>
<p>令<span class="math inline">\(F(x)=\int_a^t f(t)\text d
t\)</span>,<span class="math inline">\(g(x)=1,G(x)=x-a\)</span>就可以直接套用分部积分公式得到:</p>
<p><span class="math display">\[
LHS=\int_a^x F(t)g(t)\text d t\\
=FG\mid_a^x-\int_a^x f(t)G(t)\text d t\\
=(x-a)\int_a^x f(t)\text d t-\int_a^x f(t)(t-a)\text d t\\
\]</span></p>
<p>这样就做完了.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I=\int_0^{\frac{\pi}{2}}\frac{x\sin
x\cos x}{(a^2\cos^2x+b^2\sin^2x)^2}\text d x\)</span>,其中<span class="math inline">\(a,b&gt;0\)</span>.</p>
<p>有:</p>
<p><span class="math display">\[
\int_0^{\frac{\pi}{2}}\frac{x\sin x\cos
x}{(a^2\cos^2x+b^2\sin^2x)^2}\text d x\\
=\frac{-1}{2(b^2-a^2)}\int_0^{\frac{\pi}{2}}x\text{d}(\frac{1}{a^2+(b^2-a^2)\sin^2
x})\\
=\frac{-1}{2(b^2-a^2)}(\frac{\pi}{2b^2}-\int_0^{\frac{\pi}{2}}\frac{\text
d x}{a^2\cos^2 x+b^2\sin^2 x})\\
=\frac{1}{2(b^2-a^2)}(-\frac{\pi}{2b^2}+\int_0^{\frac{\pi}{2}}\frac{\text
d \tan x}{a^2+b^2\tan^2 x})\\
=\frac{1}{2(b^2-a^2)}(-\frac{\pi}{2b^2}+\frac{\pi}{2ab})\\
=\frac{\pi}{4ab^2(a+b)}
\]</span></p>
<h6><span id="example3wallis公式">Example3(Wallis公式)</span></h6>
<p>求<span class="math inline">\(I_n=\int_0^{\frac{\pi}{2}} \sin^n
x\text d x\)</span>.</p>
<p>换元后直接分部积分:</p>
<p><span class="math display">\[
I_n=-\int_0^{\frac{\pi}{2}}\sin^{n-1}x\text d \cos x\\
=\int_0^{\frac{\pi}{2}}\cos x\text d (\sin^{n-1}x)\\
=(n-1)\int_0^{\frac{\pi}{2}}\sin^{n-2}x(1-\sin^2 x)\text d x\\
=(n-1)I_{n-2}-(n-1)I_n\\
\]</span></p>
<p>于是<span class="math inline">\(I_n=\frac{n-1}{n}I_{n-2}\)</span>.</p>
<p>注意到<span class="math inline">\(I_0=\frac{\pi}{2},I_1=1\)</span>,所以<span class="math inline">\(I_{2m}=\frac{(2m-1)!!}{(2m)!!}\frac{\pi}{2},I_{2m+1}=\frac{(2m)!!}{(2m+1)!!}\)</span>.</p>
<p>然而注意到<span class="math inline">\(I_n\)</span>随着<span class="math inline">\(n\)</span>增大而减小,于是应该有<span class="math inline">\(I_{2m+1}\leq  I_{2m}\leq
I_{2m-1}\)</span>,展开得到:</p>
<p><span class="math display">\[
a_n=\frac{1}{2n+1}(\frac{(2n)!!}{(2n-1)!!})^2\\
\leq \frac{\pi}{2}\leq\\
\frac{1}{2n}(\frac{(2n)!!}{(2n-1)!!})^2=b_n
\]</span></p>
<p>而<span class="math inline">\(\lim a_n=\lim b_n\)</span>,因此<span class="math inline">\(\lim a_n=\lim b_n= \frac{\pi}{2}\)</span>.</p>
<h5><span id="泰勒公式的积分余项">泰勒公式的积分余项</span></h5>
<p>回忆到泰勒公式的余项:</p>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(a\)</span>处有<span class="math inline">\(n\)</span>阶导数,则<span class="math inline">\(f(x)=\sum_{k=0}^n\frac{f^{(k)}(a)}{k!}(x-a)^k+o((x-a)^n)\)</span>.</p>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\((\alpha,\beta)\)</span>上有<span class="math inline">\(n+1\)</span>阶导数,则<span class="math inline">\(f(x)=\sum_{k=0}^n\frac{f^{(k)}(a)}{k!}(x-a)^k+\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1}\)</span>.</p>
<p>事实上还可以写积分余项,若<span class="math inline">\(f^{(n+1)}\in
R[\alpha,\beta]\)</span>,则<span class="math inline">\(f(x)=\sum_{k=0}^n\frac{f^{(k)}(a)}{k!}(x-a)^k+\frac{1}{n!}\int_a^x(x-t)^nf^{(n+1)}(t)\text
d t\)</span>.</p>
<p>首先能写出<span class="math inline">\(f(x)=f(a)+\int_a^x
f&#39;(t)\text d t\)</span>,考虑不断展开后面那一项,用分部积分注意到:</p>
<p><span class="math display">\[
\int_a^xf^{(m+1)}(t)\frac{(x-t)^m}{m!}\text d t\\
=\int_a^x f^{(m+1)}(t)\text d (-\frac{(x-t)^{m+1}}{(m+1)!})\\
=f^{(m+1)}(a)\frac{(x-a)^{m+1}}{(m+1)!}+\frac{1}{(m+1)!}\int_a^x
(x-t)^{m+1}f^{(m+2)}(t)\text d t
\]</span></p>
<h5><span id="积分第一中值定理">积分第一中值定理</span></h5>
<p>设<span class="math inline">\(f,g\in R[a,b]\)</span>并且<span class="math inline">\(g\)</span>不变号.不妨设<span class="math inline">\(f\)</span>的连续点集为<span class="math inline">\(A\)</span>,称它的<strong>本性上界</strong>为<span class="math inline">\(M=\inf_{x\in
A}(f(x))\)</span>,同理定义<strong>本性下界</strong><span class="math inline">\(m\)</span>.则<span class="math inline">\(\exists
\mu\in [m,M]\)</span>使得:</p>
<p><span class="math display">\[
\int_a^b fg(x)\text d x=\mu\int_a^b g(x)\text d x
\]</span></p>
<p>来证明这个事,不妨设<span class="math inline">\(g(x)\geq
0\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b g(x)\text d
x=0\)</span>的时候,此时由于<span class="math inline">\(g(x)\geq
0\)</span>,因此<span class="math inline">\(g(x)\)</span>一定几乎处处为零(否则,存在一个<span class="math inline">\(g\)</span>的连续点处不为<span class="math inline">\(0\)</span>,在这个点邻域附近卡一下就能卡掉),那左右两边都等于<span class="math inline">\(0\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b g(x)\text d
x&gt;0\)</span>的时候,由于<span class="math inline">\(mg\leq gf\leq
Mg\)</span>对于<span class="math inline">\(f\)</span>的连续点集<span class="math inline">\(A\)</span>成立,而这是个稠密集,立刻见到<span class="math inline">\(\int_a^b mf\text d x\leq \int_a^b gf\text d x\leq
\int_a^b Mf\text d x\)</span>.于是<span class="math inline">\(\mu=\frac{\int_a^b f g \text d x}{\int_a^b g \text
d x}\in [m,M]\)</span>.</p>
<p>作为更加常见的版本,当<span class="math inline">\(f\in
C[a,b]\)</span>的时候,<span class="math inline">\(\exists \xi\in
(a,b)\)</span>使得:</p>
<p><span class="math display">\[
\int_a^b fg(x)\text d x=f(\xi)\int_a^b g(x)\text d x
\]</span></p>
<p>该版本与之前的区别在于要断言<span class="math inline">\(\xi\ne a,\xi
\ne b\)</span>.使用反证法,在<span class="math inline">\(\int_a^b
g(x)\text d x&gt; 0\)</span>的时候,不妨假设<span class="math inline">\(\xi =b\)</span>,此时前面<span class="math inline">\((a,b)\)</span>中不能有和<span class="math inline">\(f(b)\)</span>相同的,又因为其是连续函数,因此不妨设<span class="math inline">\((a,b)\)</span>中<span class="math inline">\(f(x)\)</span>均比<span class="math inline">\(f(b)\)</span>要小,用极限把端点用保号性卡出来就知道<span class="math inline">\([a,b]\)</span>中<span class="math inline">\(f(x)\leq f(b)\)</span>.</p>
<p>由于此时<span class="math inline">\(\int_a^b g(x)\text d x&gt;
0\)</span>,于是一定存在一个<span class="math inline">\(x_0,g(x_0)&gt;0\)</span>,并且<span class="math inline">\(x_0\)</span>是一个连续点.此时就存在其一个小邻域都<span class="math inline">\(&gt;\frac{1}{2}g(x_0)\)</span>.在这个邻域上立刻可以发现:</p>
<p><span class="math display">\[
\int_a^b (M-f(x))g(x)\text d x&gt;0
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(f\in R[a,b]\)</span>,<span class="math inline">\(f(+0)\)</span>存在,则:</p>
<p><span class="math display">\[
\lim_{n\to +\infty}\int_0^1\frac{n f(x)}{1+n^2x^2}\text d
x=\frac{\pi}{2}f(+0)
\]</span></p>
<p>不妨设<span class="math inline">\(f(0)=f(+0)\)</span>,因为改变有限个点的取值是不会改变其积分的.</p>
<p>此时:</p>
<p><span class="math display">\[
\int_0^1\frac{n f(x)}{1+n^2x^2}\text d x\\
=\int_0^{\frac{1}{\sqrt n}}\frac{n f(x)}{1+n^2x^2}\text d
x+\int_{\frac{1}{\sqrt n}}^{1}\frac{n f(x)}{1+n^2x^2}\text d x
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\int_0^{\frac{1}{\sqrt n}}\frac{n f(x)}{1+n^2x^2}\text d x\\
=\mu\int_0^{\frac{1}{\sqrt n}}\frac{n}{1+n^2x^2}\text d x\\
=\mu \arctan\sqrt n\to f(0)\frac{\pi}{2}
\]</span></p>
<p>而后者:</p>
<p><span class="math display">\[
|\int_{\frac{1}{\sqrt n}}^{1}\frac{n f(x)}{1+n^2x^2}\text d x|\\
\leq \sup|f|(\arctan\mid_{\frac{1}{\sqrt n}}^1)\to 0
\]</span></p>
<p>这样就做完了.这里拆成两部分可能是难以想到的,事实上这么做的意义是使得<span class="math inline">\(\mu \to f(0)\)</span>而放缩,其中这个<span class="math inline">\(nx\)</span>的变化量很大,因此可以稍微匀一下变化.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f\)</span>二阶可导,并且一,二阶导可积,则<span class="math inline">\(\exists \xi\in (a,b)\)</span>,使得<span class="math inline">\(\int_a^bf(x)\text d
x=(b-a)f(\frac{a+b}{2})+\frac{(b-a)^3}{24}f&#39;&#39;(\xi)\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\int_a^b f(x)\text d x\\
=\int_{a}^{\frac{a+b}{2}}f(x)\text d x+\int_{\frac{a+b}{2}}^{b}f(x)\text
d x\\
=\int_0^{\frac{b-a}{2}}f(a+t)\text d t+\int_0^{\frac{b-a}{2}}f(b-t)\text
d t\\
=\int_0^{\frac{b-a}{2}}f(a+t)+f(b-t)\text d t\\
=t(f(a+t)+f(b-t))\mid_0^{\frac{b-a}{2}}-\int_0^{\frac{b-a}{2}}t(f&#39;(a+t)-f&#39;(b-t))\text
d t\\
=(b-a)f(\frac{a+b}{2})-\int_0^{\frac{b-a}{2}}t(f&#39;(a+t)-f&#39;(b-t))\text
d t
\]</span></p>
<p>前半部分已经完事了,接下来看后半部分,继续分部积分:</p>
<p><span class="math display">\[
\int_0^{\frac{b-a}{2}}t(f&#39;(a+t)-f&#39;(b-t))\text d t\\
=\frac{1}{2}\int_0^{\frac{b-a}{2}}(f&#39;(a+t)-f&#39;(b-t))\text
d(t^2)\\
=(\frac{t^2}{2}(f&#39;(a+t)-f&#39;(b-t)))\mid_{0}^{\frac{b-a}{2}}-\int_0^{\frac{b-a}{2}}\frac{t^2}{2}(f&#39;&#39;(a+t)+f&#39;&#39;(b-t))\text
d t\\
=-\int_0^{\frac{b-a}{2}}\frac{t^2}{2}(f&#39;&#39;(a+t)+f&#39;&#39;(b-t))\text
d t\\
=\mu\int_0^{\frac{b-a}{2}}\frac{t^2}{2}\text d t\\
=\mu \frac{(b-a)^3}{48}
\]</span></p>
<p>接下来看<span class="math inline">\(\mu\)</span>,<span class="math inline">\(\mu\in [\inf
(f&#39;&#39;(a+t)+f&#39;&#39;(b-t)),\sup(f&#39;&#39;(a+t)+f&#39;&#39;(b-t))
]\)</span>,由导函数介值性,意味着必然<span class="math inline">\(\exists
\xi_1\in [0,\frac{b-a}{2}]\)</span>使得<span class="math inline">\(\mu=
f&#39;&#39;(a+\xi_1)+f&#39;&#39;(b-\xi_1)\)</span>.再用一次<span class="math inline">\(2f&#39;&#39;\)</span>的介值性得到<span class="math inline">\(\mu=2f&#39;&#39;(\xi),\xi\in
(a+\xi_1,b-\xi_1)\subseteq (a,b)\)</span>.</p>
<h5><span id="积分第二中值定理">积分第二中值定理</span></h5>
<p>设<span class="math inline">\(g\in R[a,b],f\geq 0\)</span>,并且<span class="math inline">\(f\)</span>单调,则:</p>
<ol type="1">
<li><span class="math inline">\(f\)</span>单调递减时,<span class="math inline">\(\exists \xi\in [a,b]\)</span>,<span class="math inline">\(\int_a^b f g \text d x=f(a+0)\int_a^\xi g(x)\text
d x\)</span>.</li>
<li><span class="math inline">\(f\)</span>单调递增时,<span class="math inline">\(\exists \xi\in [a,b]\)</span>,<span class="math inline">\(\int_a^b f g \text d x=f(b-0)\int_\xi^b g(x)\text
d x\)</span>.</li>
<li><span class="math inline">\(\exists \xi\in [a,b]\)</span>,<span class="math inline">\(\int_a^b f g \text d x=f(a+0)\int_a^\xi g\text d
x+f(b-0)\int_\xi^b g\text d x\)</span>.</li>
<li>在上述基础上,如果<span class="math inline">\(f\)</span>不是几乎常值函数,那么上述的<span class="math inline">\(\xi\in (a,b)\)</span>.</li>
</ol>
<p>(1)(2)相似,下面只对(1)进行证明:</p>
<p>不妨设<span class="math inline">\(f(a)=f(a+0),G=\int_a^x g(x)\text d
x\)</span>是<span class="math inline">\(g\)</span>的广义原函数,其满足<span class="math inline">\(G(a)=0\)</span>,不妨设<span class="math inline">\(M=\sup G,m=\inf G\)</span>,回忆到:</p>
<p><span class="math display">\[
\int_a^b f g\text d x=\lim_{\lambda(\Delta)\to 0} \sum_{i=1}^n
f(x_{i-1})\int_{x_{i-1}}^{x_i}g\text d x\\
=\sum_{i=1}^nf(x_{i-1})(G(x_i)-G(x_{i-1}))\\
=f(x_{n-1})G(x_n)-\sum_{i=1}^{n-1}(f(x_{i})-f(x_{i-1}))G(x_i)\\
\leq f(a)M
\]</span></p>
<p>在最后一步放缩进行修改就可以改为<span class="math inline">\(\geq
f(a)m\)</span>,而我们已经得知<span class="math inline">\(G\)</span>的连续性,因此用介值性就可以解决上述问题.</p>
<p>难点在于(4)如何证明.</p>
<p>当其不是几乎常值函数的时候,应该满足<span class="math inline">\(f(a+0)&gt;f(b-0)\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b f g\text d
x=0\)</span>的时候,如果迫不得已必须取端点就应当有<span class="math inline">\(\forall \xi\in (a,b)\)</span>,都有<span class="math inline">\(\int_a^\xi g\text d x\ne
0\)</span>,由于其介值性那就当然拿到了<span class="math inline">\(G\)</span>的保号性.我们上面已经用Abel变换得到了:</p>
<p><span class="math display">\[
\int_a^b f g\text d x
=\sum_{i=1}^nf(x_{i-1})(G(x_i)-G(x_{i-1}))\\
=f(x_{n-1})G(x_n)+\sum_{i=1}^{n-1}(f(x_{i-1})-f(x_{i}))G(x_i)\\
\]</span></p>
<p>此时考虑取<span class="math inline">\(c,d\)</span>使得<span class="math inline">\(a&lt;c&lt;d&lt;b\)</span>,并且满足<span class="math inline">\(f(c)&gt;f(d)\)</span>,由于<span class="math inline">\(f\)</span>并不是几乎常值函数,这当然可以做到,上式每一项都是<span class="math inline">\(\geq 0\)</span>的,那就可以把区间从<span class="math inline">\([a,b]\)</span>重新控制到<span class="math inline">\([c,d]\)</span>中.于是此时上式立刻:</p>
<p><span class="math display">\[
\int_a^b f g\text d x\\
\geq \min_{[c,d]}G(x)(f(c)-f(d))&gt;0
\]</span></p>
<p>然而我们假设中<span class="math inline">\(\int_a^b f g\text d
x=0\)</span>,这样就导出了矛盾.</p>
<p>接下来考虑<span class="math inline">\(\int_a^b f g\text d x\ne
0\)</span>的情况,如果其迫不得已必须取在端点的话当然要取到右端点此时应该有<span class="math inline">\(\int_a^b f g\text d x=f(a)\int_a^b g\text d
x\)</span>.</p>
<p>仍然看上面的Abel变换后的结果,同时按照上面同样的办法取出一个子区间<span class="math inline">\([c,d]\)</span>.回忆到为了保证前面都没有能和<span class="math inline">\(G(b)\)</span>相同的,因此<span class="math inline">\(G(b)\)</span>必然是前面的最大值.再回忆到<span class="math inline">\(G(a)=0\)</span>,立刻能得到<span class="math inline">\(G(b)&gt;\sup_{[a,c]}G(x)\)</span>,设后者为<span class="math inline">\(M\)</span>,应当有:</p>
<p><span class="math display">\[
\int_a^b f g\text d x\\
=f(x_{n-1})G(b)+\sum_{i=1}^{n-1}(f(x_{i-1})-f(x_{i}))G(x_i)\\
\leq f(x_{n-1})G(b)+M(f(a)-f(c))+G(b)(f(c)-f(b))\\
\]</span></p>
<p>这里这个<span class="math inline">\(f(x_{n-1})\)</span>很烦,但是当<span class="math inline">\(\lambda(\Delta)\to 0\)</span>的时候当然会使得<span class="math inline">\(f(x_{n-1})\to f(b-0)\)</span>,上式变更为:</p>
<p><span class="math display">\[
\int_a^b f g\text d x\\
\leq f(b)G(b)+M(f(a)-f(c))+G(b)(f(c)-f(b))\\
=M(f(a)-f(c))+G(b)f(c)\\
&lt;f(a)G(b)
\]</span></p>
<p>这就导出了矛盾.</p>
<p>最后来看(3),不妨设<span class="math inline">\(f\)</span>单减,设<span class="math inline">\(\varphi(x)=f(x)-f(b)\geq
0\)</span>且单减,用(1)的结论得到<span class="math inline">\(\exists
\xi\in [a,b]\)</span>使得<span class="math inline">\(\int_a^b \varphi g
\text d x=\varphi(a)\int_a^\xi g \text d
x\)</span>.变形后就可以得到原本的式子.单增是同理的.总之,(3)是(1)(2)的一个更为优美的推论.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f\in C^1[a,b]\)</span>,并且满足<span class="math inline">\(f&#39;\)</span>单调递减,且<span class="math inline">\(f&#39;(b)\geq M&gt;0\)</span>.求证:<span class="math inline">\(|\int_a^b \cos f(x)\text d x|\leq
\frac{2}{M}\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\int_a^b \cos f(x)\text d x\\
=\int_a^b \frac{f&#39;\cos f}{f&#39;}\text d x\\
=\frac{1}{f&#39;(b)}\int_\xi^bf&#39;\cos f\text d x\\
=\frac{1}{f&#39;(b)}(\sin f(b)-\sin f(a))\\
\]</span></p>
<p>这就完事了.</p>
<h5><span id="有界变差函数">有界变差函数</span></h5>
<p>对于一个<span class="math inline">\(f:[a,b]\to
R\)</span>的函数,做分划<span class="math inline">\(\Delta
:a=x_0&lt;\cdots&lt;x_n=b\)</span>,定义其变差为<span class="math inline">\(V_\Delta=\sum_k
|f(x_i)-f(x_{i-1})|\)</span>,定义其全变差为<span class="math inline">\(V_{[a,b]}(f)=\sup_\Delta
V_\Delta\)</span>.当全变差为有限的时候,称<span class="math inline">\(f\)</span>是有界变差函数.</p>
<p>应当容易见到,闭区间上的单调函数是有界变差的,且<span class="math inline">\(V_{|f|}\leq V_f,V_{f+g}\leq V_f+V_g\)</span>.</p>
<p>接下来我们来证明:<span class="math inline">\(f\)</span>是有界变差函数,当且仅当<span class="math inline">\(f\)</span>是两个单调(不一定严格)函数的差.或者更严格一点,可以写成两个单调不减函数的差.另外,作为这个命题的平凡推论,我们知道有界变差函数几乎处处可导,并且有至多可数个间断点,且只有第一类间断点.</p>
<p>充分性显然,下面来看必要性.假设<span class="math inline">\(f\)</span>是有界变差的,此时类似积分可以定义一个变上限函数<span class="math inline">\(V_f(x)=V_f[a,x]\)</span>,其显然是单调不降的.</p>
<p>接下来定义<span class="math inline">\(g=V_f(x)-f(x)\)</span>,我们来说明它一定也是单调不减的.</p>
<p>那考虑当<span class="math inline">\(x_2&gt;x_1\)</span>时,观察<span class="math inline">\(g(x_2)-g(x_1)=V_f(x_2)-V_f(x_1)-(f(x_2)-f(x_1))\)</span>.</p>
<p>既然全变差的定义依赖于分划,我们当然可以加分点,自然有<span class="math inline">\(V_f(x_2)-V_f(x_1)=V_{f,[x_1,x_2]}\geq
|f(x_2)-f(x_1)|\geq f(x_2)-f(x_1)\)</span>.</p>
<p>自然得证.</p>
<p>可应当意识到连续函数不一定是有界变差函数,原因仍然考虑<span class="math inline">\(f(x)=\begin{cases}0&amp;x=0\\x\sin\frac{1}{x}&amp;otherwise\end{cases}\)</span>.在闭区间<span class="math inline">\([0,1]\)</span>上取<span class="math inline">\(x_k=\frac{1}{(k+\frac{1}{2})\pi}\)</span>,这样<span class="math inline">\(\sin
\frac{1}{x_i}\)</span>的取值正负交替,容易见到出现了调和级数.</p>
<p>然而,稍微加点条件,我们可以证明李氏连续是有界变差的.可以直接套用定义,也可以回忆到<span class="math inline">\(f(x)=f(x)-Lx+Lx=Lx-(Lx-f(x))\)</span>.因此导函数有界就一定有界变差.并且此时,可以让其拆出两个不降的可导函数.</p>
<h5><span id="定积分的应用">定积分的应用</span></h5>
<h6><span id="example1图形证明不等式">Example1(图形证明不等式)</span></h6>
<p>回忆到我们证明积分形式的柯西不等式的时候,证明了当<span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>时,<span class="math inline">\(a^{\frac{1}{p}}b^{\frac{1}{q}}=e^{\frac{\ln
a}{p}+\frac{\ln b}{q}}\leq \frac{a}{p}+\frac{b}{q}\)</span>.</p>
<p>下面可以用类似的策略理解这个式子,首先等价于证明<span class="math inline">\(ab\leq
\frac{a^p}{p}+\frac{b^q}{q}\)</span>.原因是考虑设<span class="math inline">\(S_1=\frac{a^p}{p},S_2=\frac{b^q}{q}\)</span>,设<span class="math inline">\(f(x)=x^{p-1}\)</span>,留意到<span class="math inline">\(f(x)\)</span>的积分表示出了<span class="math inline">\(S_1\)</span>,而<span class="math inline">\(f^{-1}(x)\)</span>恰好表示出了<span class="math inline">\(S_2\)</span>.</p>
<h6><span id="example2参数方程曲线面积">Example2(参数方程曲线面积)</span></h6>
<p>回忆到换元法,取参数方程<span class="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>,此时不妨假设<span class="math inline">\(x(\alpha)=a,x(\beta)=b\)</span>,且<span class="math inline">\(x(t)\)</span>单调递增且连续,<span class="math inline">\(x&#39;(t)\)</span>除有限点外都存在且黎曼可积.那当然应当有:</p>
<p><span class="math display">\[
\int_a^b f(x)\text d x=\int_\alpha^\beta y(t)x&#39;(t)\text d t
\]</span></p>
<p>注意到如果反之条件使得<span class="math inline">\(x(\alpha)=b,x(\beta)=a\)</span>,则需要补一个<span class="math inline">\(-1\)</span>.</p>
<p>由此可见,对于不自交的任意参数方程表示的曲线,直接积分的正负号一抵消,仍然可以求出曲线下方的面积.如果自交,就是要把自交部分的面积减去.顺便而言,简单封闭曲线(例如圆或者椭圆)当然是上述我们所说的特殊情况.</p>
<p>不过对于封闭曲线,由于转一圈会回到同一个点处,使用分部积分得到:</p>
<p><span class="math display">\[
\int_\alpha^\beta y x&#39; \text d t\\=\int_\alpha^\beta y\text d
x\\=xy|_a^b-\int_\alpha^\beta xy&#39;\text d t
\\=-\int_\alpha^\beta xy&#39;\text d t
\]</span></p>
<p>兼顾一下对称性,可以写作<span class="math inline">\(S=\frac{1}{2}|\int_\alpha^\beta(x&#39;y-y&#39;x)\text
d t|\)</span>.由此立刻得到椭圆面积为<span class="math inline">\(ab\pi\)</span>.</p>
<h6><span id="example3极坐标的面积">Example3(极坐标的面积)</span></h6>
<p>设<span class="math inline">\(r=r(\theta),\theta\in[\alpha,\beta],r(\theta)\in
C(\alpha,\beta)\)</span>.</p>
<p>此时考虑对<span class="math inline">\(\theta\)</span>做划分,取<span class="math inline">\(\Delta:\alpha=\theta_0&lt;\cdots&lt;\theta_n=\beta\)</span>,并取<span class="math inline">\(m_i=\inf_{[\theta_{i-1},\theta_i]}r,M_i=\sup_{[\theta_{i-1},\theta_i]}\)</span>,立刻得到<span class="math inline">\(\frac{1}{2}m_i^2\Delta \theta_i\leq \Delta S_i\leq
\frac{1}{2}\sum M_i^2\Delta \theta_i\)</span>,这样加密后得到<span class="math inline">\(S=\frac{1}{2}\int_\alpha^\beta r^2(\theta)\text d
\theta\)</span>.</p>
<h6><span id="example4参数方程曲线的弧长">Example4(参数方程曲线的弧长)</span></h6>
<p>取参数方程<span class="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>,并且假设<span class="math inline">\(x,y\)</span>均连续.首先我们应当定义其”弧长”的含义.</p>
<p>可以使用折线逼近的策略定义弧长.具体而言,直接取分划<span class="math inline">\(\Delta
:\alpha=t_0&lt;\cdots&lt;t_n=\beta\)</span>.定义一个点<span class="math inline">\(P_i=(x(t_i),y(t_i))\)</span>,这样我们当然就得到了若干个点,在这些点上就可以将相邻两个点求出折线,设折线长为<span class="math inline">\(\overline{M_{i-1}M_i}\)</span>.</p>
<p>接下来,称曲线是可求长的,当且仅当取出的折线的上确界是有限的,并将此上确界定义为曲线长.</p>
<p>我们接下来证明,其可求长当且仅当<span class="math inline">\(x(t)\)</span>和<span class="math inline">\(y(t)\)</span>都是有界变差的.</p>
<p>先看必要性,任取分划<span class="math inline">\(\Delta :
\alpha=t_0&lt;\cdots&lt;t_n=\beta\)</span>.立刻得到<span class="math inline">\(V_\Delta(x)=\sum |x_i-x_{i-1}|\leq \sum
\overline{M_{i-1}M_i}\)</span>,当然是有界的,对于<span class="math inline">\(y(t)\)</span>同理.</p>
<p>另外,斜边小于两条直角边的和(三角形不等式),于是充分性也显然.</p>
<p>然而真要实际应用需要稍加条件,即:<span class="math inline">\(x(t),y(t)\)</span>可导且导函数黎曼可积(说明其导函数有界,为李氏连续函数,那自然是有界变差函数).则弧长为<span class="math inline">\(\int_\alpha^\beta
\sqrt{(x&#39;(t))^2+(y&#39;(t))^2}\text d t\)</span>.</p>
<p>证明比较容易,考虑勾股定理,<span class="math inline">\(\overline{M_{i-1}M_i}=\sqrt{(x(t_i)-x(t_{i-1}))^2+(y(t_i)-y(t_{i-1}))^2}\)</span>.使用微分中值定理,得到其等于<span class="math inline">\(\Delta
t_i\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\eta_i))^2}\)</span>.这里强行换成一个东西,于是就会得到<span class="math inline">\(\Delta
t_i\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\xi_i))^2}+w_i\)</span>的形式,其中<span class="math inline">\(w_i\)</span>恰为两项之差.然后换黎曼和,只需证明后者<span class="math inline">\(w_i\)</span>随着加密而趋向于<span class="math inline">\(0\)</span>.而这个根号差可以做分子有理化.具体而言:</p>
<p><span class="math display">\[
w_i=\Delta
t_i\left(\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\eta_i))^2}-\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\xi_i))^2}\right)\\
=\Delta
t_i\frac{y&#39;(\eta_i)^2-y&#39;(\xi_i)^2}{\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\eta_i))^2}+\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\xi_i))^2}}\\
=\Delta
t_i\frac{(y&#39;(\eta_i)+y&#39;(\xi_i))}{\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\eta_i))^2}+\sqrt{(x&#39;(\xi_i))^2+(y&#39;(\xi_i))^2}}(y&#39;(\eta_i)-y&#39;(\xi_i))\\
\leq \Delta t_i(y&#39;(\eta_i)-y&#39;(\xi_i))
\]</span></p>
<p>最后会得到<span class="math inline">\(\leq \sum\omega_{y&#39;}\Delta
t_i\)</span>,立刻得到其趋向于<span class="math inline">\(0\)</span>.顺便还要证明这个是上确界,只需要证明加点后答案增加即可,然后用黎曼积分那一部分的对划分取并的技巧即可.</p>
<p>由此应当能推出直角坐标系下弧长公式,即<span class="math inline">\(l=\int_a^b\sqrt{1+(f&#39;(x))^2}\text d
x\)</span>.</p>
<h6><span id="example5极坐标下的弧长公式">Example5(极坐标下的弧长公式)</span></h6>
<p>此时应当有<span class="math inline">\(x&#39;=r&#39;\cos \theta-r\sin
\theta,y&#39;=r&#39;\sin \theta+r\cos \theta\)</span>,注意到<span class="math inline">\((x&#39;)^2+(y&#39;)^2=r^2+(r&#39;)^2\)</span>,于是极坐标下的公式当然是<span class="math inline">\(l=\int_\alpha^\beta\sqrt{r^2+(r&#39;)^2}\text d
\theta\)</span>.</p>
<h6><span id="example6等周不等式">Example6(等周不等式)</span></h6>
<p>求给定长度的闭合曲线能围出的最大面积.</p>
<p>设<span class="math inline">\(\Gamma\)</span>是一个周长为<span class="math inline">\(l\)</span>的简单可求长闭曲线,其面积为<span class="math inline">\(A\)</span>,我们下面证明<span class="math inline">\(A\leq \frac{l^2}{4\pi}\)</span>.</p>
<p>先考虑<span class="math inline">\(\Gamma\)</span>比较光滑的情况,也就是其有导函数且导函数可积.参数方程给出<span class="math inline">\(l=\int_\alpha^\beta\sqrt{(x&#39;)^2+(y&#39;)^2}\text
d \theta\)</span>而<span class="math inline">\(A=\int_\alpha^\beta
xy&#39;\text d \theta\)</span>.注意这里假设曲线是逆时针方向旋转的.</p>
<p>接下来,考虑在原基础上画个圆,这个圆的参数方程横坐标继承自上述<span class="math inline">\(x(\theta)\)</span>而纵坐标由圆定义为<span class="math inline">\(\bar y=\pm\sqrt {r^2-x^2}\)</span>,这里的<span class="math inline">\(2r=\sup x-\inf
x\)</span>.也就是横着的最长距离.为了使得这个圆转起来是合理的,实际上应该找到上述曲线的左右端点然后分段函数定义,我们这里略去此细节.</p>
<p>然后呢,此时观察到应当有<span class="math inline">\(\pi
r^2=-\int_\alpha^\beta\bar y x&#39;\text d
\theta\)</span>,发挥注意力得到:</p>
<p><span class="math display">\[
2\sqrt{A\pi r^2}\leq A+\pi r^2\\
=\int_\alpha^\beta (xy&#39;+\bar y x&#39;) \text d \theta\\
\leq \int_\alpha^\beta \sqrt{x^2+(\bar
y)^2}\sqrt{y&#39;^2+x&#39;^2}\text d t\\
=rl
\]</span></p>
<p>于是证毕.</p>
<p>那么不光滑怎么办呢?可以用分段光滑函数(比如折线)逼近,这样就行了.</p>
<h6><span id="example7求多面体体积">Example7(求多面体体积)</span></h6>
<p>体积的定义无非类似面积,用夹逼定理定义任意形状的体积.</p>
<p>考虑对于每个<span class="math inline">\(x\)</span>,在<span class="math inline">\(x\)</span>那里做截面,设得到的截面面积是<span class="math inline">\(S(x)\)</span>,那么体积感觉上应当是<span class="math inline">\(V=\int_a^b S(x)\text d x\)</span>.</p>
<p>然而这个结论的准确证明可能需要一些重积分知识.我们尝试越级打怪,加一个很神秘的条件:就是两个截面之间一定存在包含关系以及<span class="math inline">\(S(x)\)</span>是关于<span class="math inline">\(x\)</span>连续变化的.然后看看能不能把这个结论证出来.</p>
<p>考虑<span class="math inline">\(x\)</span>的范围是<span class="math inline">\([a,b]\)</span>,接下来对其作分划<span class="math inline">\(\Delta :
a=x_0&lt;\cdots&lt;x_n=b\)</span>.接下来取<span class="math inline">\(\eta_i,\xi_i\)</span>满足<span class="math inline">\(S(\xi_i)=\max_{[x_{i-1},x_i]}S(x),S(\eta_i)=\min_{[x_{i-1},x_i]}S(x)\)</span>.此时回忆到包含关系,那么我们拿出来的<span class="math inline">\(\xi_i\)</span>和<span class="math inline">\(\eta_i\)</span>当然就是包含别人以及被包含的两个截面,以它们为底面积做柱体,留意到此时当然有:</p>
<p><span class="math display">\[
S(\eta_i)(x_{i}-x_{i-1})\leq V_{[x_{i-1},x_i]}\leq S(\xi_i)(x_i-x_{i-1})
\]</span></p>
<p>回忆到假设<span class="math inline">\(S(x)\)</span>是连续变化的因此黎曼可积,于是这个东西两边其实就是达布上下和,立刻得到积分的结论.</p>
<p>旋转体当然满足以上条件,易见旋转体的体积为<span class="math inline">\(\pi\int_a^b f^2(x){\rm d}
x\)</span>,参数方程同理.</p>
<h6><span id="example8旋转体的侧面积公式">Example8(旋转体的侧面积公式)</span></h6>
<p>曲面的面积难以定义,所以我们现在暂时成为物理系学生.下面只考虑旋转体.</p>
<p>对于旋转体来说,先用折线逼近原曲线,然后旋转后得到若干圆台,用圆台的侧面积之和去逼近旋转体的侧面积.</p>
<p>对于<span class="math inline">\([a,b]\)</span>,我们先做一个分划<span class="math inline">\(\Delta: a=x_0&lt;\cdots&lt;x_n=b\)</span>,<span class="math inline">\(y_i=f(x_i)\)</span>.圆台侧面积给出<span class="math inline">\(\Delta
S_i=\pi(y_{i-1}+y_i)|\overline{M_{i-1}M_i}|=\pi(y_{i-1}+y_i)\sqrt{1+(\cfrac{y_i-y_{i-1}}{x_i-x_{i-1}})^2}\Delta
x_i\)</span>,利用微分中值定理,就有:</p>
<p><span class="math display">\[
S_i=\pi(y_{i-1}+y_i)\sqrt{1+(f&#39;(\xi_i))^2}\Delta x_i\\
=2\pi f(\xi_i)\sqrt{1+(f&#39;(\xi_i))^2}\Delta x_i+(y_i+y_{i-1}-2\pi
f(\xi_i))\sqrt{1+(f&#39;(\xi_i))^2}\Delta x_i
\]</span></p>
<p>加密后第二项可以用振幅控制住,所以答案就是<span class="math inline">\(2\pi \int_a^bf(x)\sqrt{1+(f&#39;(x))^2}{\rm d}
x\)</span>.</p>
<p>对于参数方程当然也是平凡的,答案应当是<span class="math inline">\(2\pi
\int_a^b y\sqrt{1+(\frac{y&#39;}{x&#39;})^2}x&#39;{\rm d}
t=2\pi\int_a^by\sqrt{(x&#39;)^2+(y&#39;)^2}{\rm d}
t\)</span>,注意这里是按照<span class="math inline">\(x\)</span>轴翻转.应当看到由此一段球面上的环的面积就是<span class="math inline">\(2\pi r\Delta x\)</span>.</p>
<h6><span id="example9pi的无理性证明">Example9(<span class="math inline">\(\pi\)</span>的无理性证明)</span></h6>
<p>假设<span class="math inline">\(\pi=\frac{p}{q}\in
\mathbb{Q}\)</span>并且<span class="math inline">\(p\bot q,p,q\in
\mathbb{N_+}\)</span>.</p>
<p>考虑设<span class="math inline">\(f_n(x)=q^nx^n(p-qx)^n\)</span>,留意到<span class="math inline">\(\forall 0\leq i\leq n-1\)</span>,有<span class="math inline">\(f_n^{(i)}(0)=f_n^{(i)}(\pi)=0\)</span>.</p>
<p>接下来考察<span class="math inline">\(\forall n\leq i\leq
2n\)</span>,此时留意到<span class="math inline">\(f_n^{(i)}(0)\)</span>和<span class="math inline">\(f_n^{(i)}(\pi)\)</span>都应当是整数并且是<span class="math inline">\(n!\)</span>的倍数.</p>
<p>考虑积分<span class="math inline">\(I_n=\frac{1}{n!}\int_0^\pi
f_n(x)\sin x{\rm d}x&gt;0\)</span>.对其狂暴使用分部积分:</p>
<p><span class="math display">\[
I_n=\frac{1}{n!}\int_0^\pi f_n(x)\sin x{\rm d}x\\
=\frac{1}{n!}\int_0^\pi f_n(x){\rm d}(-\cos x)\\
\]</span></p>
<p>不断做分部积分,前面扔出来的项也就是<span class="math inline">\(f_n^{(i)}(0)\)</span>或者<span class="math inline">\(f_n^{(i)}(\pi)\)</span>然后再乘上<span class="math inline">\(\sin,\cos\)</span>在<span class="math inline">\(0,\pi\)</span>之类取值的问题.总之,这个东西算出来一定是<span class="math inline">\(n!\)</span>的倍数,前面乘了个<span class="math inline">\(\frac{1}{n!}\)</span>,他就一定是整数.又因为其大于<span class="math inline">\(0\)</span>,他就一定<span class="math inline">\(\geq 1\)</span>.</p>
<p>那么矛盾在哪呢?留意到<span class="math inline">\(f_n=(qx(p-qx))^n\leq
(\frac{p}{2})^{2n},\sin x\leq 1\)</span>,所以<span class="math inline">\(I_n\leq \frac{1}{n!}(\frac{p}{2})^{2n}\pi\to
0\)</span>.</p>
<h6><span id="example10古鲁金第一定理">Example10(古鲁金第一定理)</span></h6>
<p>躲开微元法,要证明一些东西可以扔进去的话(比如密度函数),应当可以通过”平均密度”的概念用之前那个引理(分部积分那里,步骤是先积分,乘系数,后求和),总之都是平凡的.</p>
<p>考虑一个旋转体,反正用上面那套东西,搞出来质心应当有<span class="math inline">\(\bar y=\frac{\int_\alpha^\beta
y\sqrt{x&#39;^2+y&#39;^2}{\rm d}t}{l}\)</span>.移项得到<span class="math inline">\(2\pi\bar y l=2\pi\int_\alpha^\beta
y\sqrt{x&#39;^2+y&#39;^2}{\rm
d}t\)</span>.也就是:旋转线转一圈,质心周长乘以曲线的弧长等于侧面积.</p>
<h6><span id="example11古鲁金第二定理">Example11(古鲁金第二定理)</span></h6>
<p>考虑两条曲线夹起来的部分,也就是设<span class="math inline">\([a,b]\)</span>上有<span class="math inline">\(f(x)\geq g(x)\geq
0\)</span>,那这两条线就会围出一块二维出来.这一块的质心能不能求呢?当然也可以,只不过略有区别,<span class="math inline">\(\bar x=\frac{\int_a^bx(f(x)-g(x){\rm d}
x)}{S}\)</span>,而<span class="math inline">\(\bar
y=\frac{1}{2}\frac{\int_a^b(f^2(x)-g^2(x){\rm d}
x)}{S}\)</span>.移项得到<span class="math inline">\(2S\bar
y=\int_a^b(f^2(x)-g^2(x){\rm d}
x)\)</span>,也就是旋转面转一圈,质心周长乘以面积等于体积.</p>
<h6><span id="example12转动惯量">Example12(转动惯量)</span></h6>
<p>定义为<span class="math inline">\(J=\int mr^2\)</span>.</p>
<p>考虑以<span class="math inline">\(x\)</span>轴为旋转轴,先考虑线的情况,无非是分成小段每一段分别处理,对于每一段用长度和密度的乘积来逼质量,关于<span class="math inline">\(x\)</span>轴的转动惯量<span class="math inline">\(J=\int_\alpha^\beta
x^2(t)\rho(t)\sqrt{(x&#39;(t))^2+(y&#39;(t))^2}\text d t\)</span>.</p>
<h5><span id="定积分近似计算">定积分近似计算</span></h5>
<p>考虑对<span class="math inline">\(\int_a^b f(x){\rm
d}x\)</span>做数值近似,将<span class="math inline">\([a,b]\)</span>等分,取<span class="math inline">\(x_k=a+\frac{k}{n}(b-a)\)</span>,其中<span class="math inline">\(0\leq k\leq n\)</span>,而<span class="math inline">\(\Delta x=\frac{b-a}{n}\)</span>,<span class="math inline">\(x_{k-\frac{1}{2}}=\frac{x_k+x_{k-1}}{2}\)</span>.</p>
<p>那么用黎曼和逼积分,那么无非三种方式:要么算左端点的函数值,要么算右端点的函数值,要么算中间点的函数值.</p>
<p>问题在于计算误差,我们下面证明,如果<span class="math inline">\(f\)</span>一阶可导,则:</p>
<ol type="1">
<li><span class="math inline">\(\int_a^b f(x){\rm
d}x=\frac{b-a}{n}\sum_{k=1}^n
y_k-\frac{(b-a)^2}{2n}f&#39;(\xi)\)</span></li>
<li><span class="math inline">\(\int_a^b f(x){\rm
d}x=\frac{b-a}{n}\sum_{k=1}^n
y_{k-1}+\frac{(b-a)^2}{2n}f&#39;(\eta)\)</span></li>
</ol>
<p>两个是类似的,只证第一个,考虑:</p>
<p><span class="math display">\[
\int_a^b f(x){\rm d}x-\frac{b-a}{n}\sum_{k=1}^n y_k\\
=\sum_{k=1}^n\int_{x_{k-1}}^{x_k}(f(x)-f(x_k)){\rm d}x\\
=\sum_{k=1}^n\int_{x_{k-1}}^{x_k}(f(x)-f(x_k)){\rm d}(x-x_{k-1})\\
=-\sum_{k=1}^n\int_{x_{k-1}}^{x_k}(x-x_{k-1})f&#39;(x){\rm d}x\\
=-\sum_{k=1}^nf&#39;(\xi_k)\int_{x_{k-1}}^{x_k}(x-x_{k-1}){\rm d}x\\
=-\sum_{k=1}^nf&#39;(\xi_k)\frac{(b-a)^2}{2n^2}\\
=-\frac{(b-a)^2}{2n}f&#39;(\xi)
\]</span></p>
<p>最后一步是因为求均值也可以用介值定理.</p>
<p>那么在中点估计会怎么样呢?考虑给<span class="math inline">\(f\)</span>更好的条件,让<span class="math inline">\(f\)</span>二阶可导,则:</p>
<p><span class="math display">\[
\int_a^b f(x){\rm d}x=\frac{b-a}{n}\sum_{k=1}^n
y_{k-\frac{1}{2}}-\frac{(b-a)^3}{24n^2}f&#39;&#39;(\xi)
\]</span></p>
<p>在<span class="math inline">\(x_{k-\frac{1}{2}}\)</span>处做泰勒展开,应当有:</p>
<p><span class="math display">\[
f(x)-f(x_{k-\frac{1}{2}})=(x-x_{k-\frac{1}{2}})f&#39;(x_{k-\frac{1}{2}})+\frac{1}{2}(x-x_{k-\frac{1}{2}})^2f&#39;&#39;(\xi_k)\\
\]</span></p>
<p>不妨设<span class="math inline">\(m_k\leq f&#39;&#39;(\xi_k)\leq
M_k\)</span>,则:</p>
<p><span class="math display">\[
\int_{x_{k-1}}^{x_k}(f(x)-f(x_{k-\frac{1}{2}})){\rm d}x\leq
\frac{M_k}{2}\int_{x_{k-1}}^{x_k}(x-x_{k-\frac{1}{2}})^2{\rm d}x\\
=M_k\frac{(b-a)^3}{24n^3}
\]</span></p>
<p>用介值定理就可以求和,原命题自然得证.</p>
<p>而上面的做法是矩形逼近,能不能用梯形逼近呢?用梯形逼近的话其实无非是<span class="math inline">\(\frac{b-a}{n}(\frac{y_0+y_n}{2}\sum_{k=1}^{n-1}
y_k)\)</span>,然而,对于<span class="math inline">\(f\in
C^2[a,b]\)</span>,我们声明:</p>
<p><span class="math display">\[
\int_a^b f(x){\rm d}x=\frac{b-a}{n}(\frac{y_0+y_n}{2}\sum_{k=1}^{n-1}
y_k)-\frac{(b-a)^3}{12n^2}f&#39;&#39;(\xi)
\]</span></p>
<p>证明当然还是分部积分,考虑:</p>
<p><span class="math display">\[
\int_{x_{k-1}}^{x_k}f(x){\rm d}x\\
=\int_{x_{k-1}}^{x_k}f(x){\rm d}(x-x_{k-1})\\
=f(x_k)\frac{b-a}{n}-\int_{x_{k-1}}^{x_k}(x-x_{k-1})f&#39;(x){\rm d}x\\
=f(x_k)\frac{b-a}{n}-\frac{1}{2}\int_{x_{k-1}}^{x_k}f&#39;(x){\rm
d}(x-x_{k-1})^2\\
=f(x_k)\frac{b-a}{n}-\frac{1}{2}f&#39;(x_k)(\frac{b-a}{n})^2+\frac{1}{2}\int_{x_{k-1}}^{x_k}f&#39;&#39;(x)(x-x_{k-1})^2{\rm
d}x\\
\]</span></p>
<p>同理,在上面换<span class="math inline">\(x-x_k\)</span>而非<span class="math inline">\(x-x_{k-1}\)</span>,就可以得到:</p>
<p><span class="math display">\[
\int_{x_{k-1}}^{x_k}f(x){\rm d}x\\
=f(x_{k-1})\frac{b-a}{n}+\frac{1}{2}f&#39;(x_{k-1})(\frac{b-a}{n})^2+\frac{1}{2}\int_{x_{k-1}}^{x_k}f&#39;&#39;(x)(x-x_{k})^2{\rm
d}x\\
\]</span></p>
<p>此时用NL公式,应当能见到把上面两式子相加可以得到:</p>
<p><span class="math display">\[
\int_{x_{k-1}}^{x_k}f(x){\rm d}x\\
=\frac{f(x_{k-1})+f(x_k)}{2}\frac{b-a}{n}+\frac{1}{4}\int_{x_{k-1}}^{x_k}f&#39;&#39;(x)((x-x_{k})^2+(x-x_{k-1})^2-(\frac{b-a}{n})^2){\rm
d}x\\
=\frac{f(x_{k-1})+f(x_k)}{2}\frac{b-a}{n}+\frac{1}{2}\int_{x_{k-1}}^{x_k}f&#39;&#39;(x)(x-x_k)(x-x_{k-1}){\rm
d}x\\
=\frac{f(x_{k-1})+f(x_k)}{2}\frac{b-a}{n}+\frac{1}{2}f&#39;&#39;(\xi_k)\int_{x_{k-1}}^{x_k}(x-x_k)(x-x_{k-1}){\rm
d}x\\
=\frac{y_{k-1}+y_k}{2}\Delta
x-\frac{1}{12}f&#39;&#39;(\xi_k)\frac{(b-a)^3}{n^3}
\]</span></p>
<p>这样就完事了,接下来对<span class="math inline">\(n\)</span>求个和就能得到之前的公式.</p>
<p>接下来是二次曲线逼近.考虑用<span class="math inline">\((x_{k-1},y_{k-1}),(x_{k-\frac{1}{2}},y_{k-\frac{1}{2}}),(x_k,y_k)\)</span>三个点确定一条二次曲线.不妨设这条二次曲线为<span class="math inline">\(Q_k(x)=px^2+qx+r\)</span>.然而,此时观察到:</p>
<p><span class="math display">\[
\int_{x_{k-1}}^{x_k}Q_k(x){\rm d}x\\
=\frac{p}{3}(x_k^3-x_{k-1}^3)+\frac{q}{2}(x_k^2-x_{k-1}^2)+r(x_k-x_{k-1})\\
=\frac{x_k-x_{k-1}}{6}(Q_k(x_k)+Q_k(x_{k-1})+Q_k(x_{k-\frac{1}{2}}))\\
=\frac{b-a}{6n}(y_{k-1}+y_k+4y_{k-\frac{1}{2}})
\]</span></p>
<p>这也很合理,观察一下就可以知道这个恰好是在尝试把梯形逼近和中点逼近两种方式尝试约掉后面的误差项系数.</p>
<p>定理是,如果<span class="math inline">\(f\in
C^4[a,b]\)</span>,误差项为<span class="math inline">\(-\frac{(b-a)^5}{2880n^4}f^{(4)}(\xi)\)</span>.这就是所谓辛普森积分法.</p>
<h5><span id="广义积分">广义积分</span></h5>
<p>考虑函数<span class="math inline">\(f:[a,+\infty)\to
\mathbb{R}\)</span>,如果其<span class="math inline">\(\forall
b&gt;a\)</span>,<span class="math inline">\(f\in
R[a,b]\)</span>,我们称其<strong>内闭可积</strong>.那我们就定义其广义积分为<span class="math inline">\(\int_a^{+\infty}f {\rm d}x=\lim_{b\to
+\infty}\int_a^b f{\rm
d}x\)</span>,当后者极限存在时.同理当然可以定义区间<span class="math inline">\((-\infty,b]\)</span>上的广义积分.而如果<span class="math inline">\(\int_0^{+\infty}f{\rm d}x\)</span>和<span class="math inline">\(\int_{-\infty}^0f{\rm
d}x\)</span>都收敛,则定义它们的和为<span class="math inline">\(\int_{-\infty}^{+\infty}f{\rm d}x\)</span>.</p>
<p>称一个函数的<strong>瑕点</strong>为其局部无界的点,则考虑<span class="math inline">\(f:[a,b)\to \mathbb{R}\)</span>,其中<span class="math inline">\(b\)</span>是<span class="math inline">\(f\)</span>的瑕点,且<span class="math inline">\(f\)</span>内闭可积,则<span class="math inline">\(\int_a^b f(x){\rm d}x=\lim_{A\to
b-0}\int_a^Af(x){\rm
d}x\)</span>,若后者极限存在.瑕积分和上述广义积分并无明显区别,下述也不再区分.</p>
<p>在进一步讨论前,我们应当再仔细研究一下广义积分的收敛性,也就是当什么时候其极限存在呢?我们有以下命题:</p>
<ol type="1">
<li><span class="math inline">\(f(x)\geq 0,x\in
[a,+\infty)\)</span>时,<span class="math inline">\(F(A)=\int_a^A
f(x){\rm d}x\)</span>单增.那么此时<span class="math inline">\(F(+\infty)\)</span>存在当且仅当<span class="math inline">\(F(A)\)</span>有界.</li>
<li>比较原理:<span class="math inline">\(0\leq f\leq
cg,c&gt;0\)</span>,若<span class="math inline">\(\int_a^{+\infty}g{\rm
d}x\)</span>收敛,则<span class="math inline">\(\int_a^{+\infty}f{\rm
d}x\)</span>收敛.该结论可以移植到瑕积分上.</li>
<li>比较原理的推论:<span class="math inline">\(f,g\geq 0,0&lt;c_1\leq
\frac{f}{g}\leq c_2\)</span>,则<span class="math inline">\(\int f{\rm
d}x,\int g{\rm d}x\)</span>收敛性相同.进一步地,如果<span class="math inline">\(f,g\geq 0\)</span>,在趋近于某个瑕点的时候,<span class="math inline">\(\frac{f}{g}\)</span>趋近于某个非零常数,那它们在这一点的收敛性相同.</li>
</ol>
<p>(1)是根据单调收敛准则,而(2)则是(1)的推论,只是给出了一个界.</p>
<p>定义函数<span class="math inline">\(f\)</span>是<strong>绝对收敛</strong>,当<span class="math inline">\(\int_a^{+\infty}|f|{\rm
d}x&lt;\infty\)</span>时.而考虑<span class="math inline">\(f=|f|-(|f|-f)\)</span>,而<span class="math inline">\(0\leq |f|-f\leq
2|f|\)</span>,所以绝对收敛可以推出收敛,但反之不可.因此,我们将收敛但不绝对收敛的函数称为<strong>条件收敛</strong>.该结论也可以移植到瑕积分上.</p>
<p>接下来,我们有<strong>柯西收敛原理</strong>:<span class="math inline">\(\int_a^{+\infty}f{\rm
d}x\)</span>收敛的充要条件是对于<span class="math inline">\(\forall
\epsilon&gt;0,\exists M&gt;a\)</span>使得<span class="math inline">\(\forall A&gt;B\geq M\)</span>,都有<span class="math inline">\(|\int_{B}^Af{\rm d}x|&lt;\epsilon\)</span>.</p>
<p>证明当然无非是函数部分柯西收敛准则的重复应用.</p>
<p>柯西收敛原理推到瑕积分上的话,考虑<span class="math inline">\(F(x)=\int_a^x f(t){\rm d}t\)</span>,则瑕积分<span class="math inline">\(\lim_{t\to b-0}F(t)\)</span>存在当且仅当<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists \delta&gt;0\)</span>,当<span class="math inline">\(x_1,x_2\in (b-\delta,b)\)</span>的时候,有<span class="math inline">\(|F(x_1)-F(x_2)|&lt;\epsilon\)</span>.</p>
<p>接下来还有<strong>Dirichlet-Abel判别法</strong>,设<span class="math inline">\(f,g:[a,+\infty)\to
\mathbb{R}\)</span>内闭可积,<span class="math inline">\(f\)</span>单调,那有:</p>
<ol type="1">
<li>Dirichlet判别法:如果<span class="math inline">\(f(+\infty)=0\)</span>,<span class="math inline">\(G(A)=\int_a^A g{\rm d}x\)</span>有界,则<span class="math inline">\(\int_a^{+\infty}fg{\rm d}x\)</span>收敛.</li>
<li>Abel判别法:如果<span class="math inline">\(f\)</span>有界,<span class="math inline">\(\int_a^{\infty} g{\rm d}x\)</span>收敛,则<span class="math inline">\(\int_a^{+\infty}fg{\rm d}x\)</span>收敛.</li>
</ol>
<p>用第二积分中值定理,就有<span class="math inline">\(\int_A^B f g{\rm
d}x=f(A)\int_A^\xi g{\rm d}x+f(B)\int_{\xi}^B g{\rm
d}x\)</span>.用柯西收敛原理则上述两条均为显然.结论当然可以推广到瑕积分上.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f\)</span>在<span class="math inline">\((-\infty,+\infty)\)</span>上内闭可积,且<span class="math inline">\(f(+\infty)=A,f(-\infty)=B\)</span>,对于<span class="math inline">\(a&gt;0\)</span>,求证<span class="math inline">\(\int_{-\infty}^{+\infty}\left(f(x+a)-f(x)\right){\rm
d}x\)</span>收敛并求其值.</p>
<p>注意到:</p>
<p><span class="math display">\[
\int_0^{C}\left(f(x+a)-f(x)\right){\rm d}x
=\int_{a}^{C+a}f(x){\rm d}x-\int_0^C f(x){\rm d}x\\
=\int_{C}^{C+a}f(x){\rm d}x-\int_0^a f(x){\rm d}x\\
\to aA-\int_0^af(x){\rm d}x
\]</span></p>
<p>另一侧同理为:</p>
<p><span class="math display">\[
\int_{-C}^{0}\left(f(x+a)-f(x)\right){\rm d}x
=\int_{-C+a}^{a}f(x){\rm d}x-\int_{-C}^0 f(x){\rm d}x\\
=-\int_{-C}^{-C+a}f(x){\rm d}x+\int_0^a f(x){\rm d}x\\
\to -aB+\int_0^af(x){\rm d}x
\]</span></p>
<p>于是答案是<span class="math inline">\(a(A-B)\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:</p>
<p><span class="math display">\[
\int_{1}^{+\infty}\frac{ {\rm d}x}{x^p}
=
\begin{cases}
\lt \infty &amp; p\gt1\\
\infty &amp; p\leq 1
\end{cases}
\]</span></p>
<p>显然.</p>
<h6><span id="example3">Example3</span></h6>
<p>求证:<span class="math inline">\(\int_a^{+\infty}\frac{\sin^2
x}{x^2}{\rm d}x\)</span>收敛.</p>
<p>原因是由比较原理,所以<span class="math inline">\(0\leq \frac{\sin^2
x}{x^2}\leq \frac{1}{x^2}\)</span>,立刻知其收敛性.</p>
<h6><span id="example4">Example4</span></h6>
<p>判断<span class="math inline">\(\int_0^{+\infty}\frac{x{\rm
d}x}{1+x^4\sin^2 x}\)</span>的收敛性.</p>
<p>考虑取<span class="math inline">\(F(A)=\int_0^A\frac{x{\rm
d}x}{1+x^4\sin^2 x}\)</span>,接下来考虑<span class="math inline">\(F(n\pi)=\sum_{k=1}^nU_k\)</span>,其中<span class="math inline">\(U_k=\int_{(k-1)\pi}^{k\pi}\frac{x{\rm
d}x}{1+x^4\sin^2 x}\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
U_k=\int_{(k-1)\pi}^{k\pi}\frac{x{\rm d}x}{1+x^4\sin^2 x}\\
\geq (k-1)\pi\int_{(k-1)\pi}^{k\pi}\frac{x{\rm d}x}{1+(k\pi)^4\sin^2
x}\\
\geq 2(k-1)\pi\int_{0}^{\frac{\pi}{2}}\frac{x{\rm d}x}{1+(k\pi)^4(\sin
x)^2}\\
\geq 2(k-1)\pi\int_{0}^{\frac{\pi}{2}}\frac{x{\rm d}x}{1+(k\pi)^4x^2}\\
=\frac{2(k-1)\pi}{k^2\pi^2}\arctan(k^2\pi^2x)|_0^{\frac{\pi}{2}}\\
\geq \frac{2(k-1)\pi}{k^2\pi^2}\arctan(\frac{\pi^3}{2})
\]</span></p>
<p>这就证完了,每一项都大于一个常数,必然发散.</p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(f:(-\infty,+\infty)\to
\mathbb{R}\)</span>且内闭可积,<span class="math inline">\(p&gt;0\)</span>,并且<span class="math inline">\(\int_{-\infty}^{+\infty}|f|^p{\rm
d}x&lt;\infty\)</span>,求证<span class="math inline">\(\lim_{h\to
0}\int_{-\infty}^{+\infty}\left|f(x+h)-f(x)\right|^p{\rm
d}x\)</span>收敛并求其值.</p>
<p>既然<span class="math inline">\(\int_{-\infty}^{+\infty}|f|^p{\rm
d}x&lt;\infty\)</span>,那么一定存在一个足够大的<span class="math inline">\(A\)</span>,使得<span class="math inline">\(\int_{A}^{+\infty}|f|^p{\rm
d}x\)</span>足够小,不妨取足够大的<span class="math inline">\(A&gt;0\)</span>使得<span class="math inline">\(\int_{A-1}^{+\infty}|f|^p{\rm
d}x&lt;\epsilon_1\)</span>.更进一步地,这必然意味着<span class="math inline">\(f(-\infty)=f(+\infty)=0\)</span>.</p>
<p>事实上考虑<span class="math inline">\(|u+v|\leq |u|+|v|\leq
2\max(|u|,|v|)\)</span>,那么<span class="math inline">\(|u+v|^p\leq
2^p(|u|^p+|v|^p)\)</span>,取<span class="math inline">\(|h|&lt;1\)</span>,则:</p>
<p><span class="math display">\[
\int_{A}^{+\infty}\left|f(x+h)-f(x)\right|^p{\rm d}x\\
\leq 2^p\int_{A}^{+\infty}|f(x+h)|^p{\rm
d}x+2^p\int_{A}^{+\infty}|f(x)|^p{\rm d}x\\
=2^p\int_{A+h}^{+\infty}|f(x)|^p{\rm
d}x+2^p\int_{A}^{+\infty}|f(x)|^p{\rm d}x\\
\leq 2^{p+1}\int_{A-1}^{+\infty}|f|^p{\rm d}x\\
\leq 2^{p+1}\epsilon_1
\]</span></p>
<p>同理,另一侧也可以放掉.现在的问题在于<span class="math inline">\((-A+1,A-1)\)</span>中间这一段.</p>
<p>考虑用一个线性函数逼近,做分划<span class="math inline">\(\Delta:
-A+1=x_0&lt;\cdots&lt;x_n=A-1\)</span>,取线性函数逼近,策略为<span class="math inline">\(x\in[x_{k-1},x_k]\)</span>的时候<span class="math inline">\(g(x)=\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}(x-x_{k-1})+f(x_{k-1})\)</span>.接下来考虑对于每一段,设<span class="math inline">\(M_k=\sup_{[x_{k-1},x_k]}f,m_k=\inf_{[x_{k-1},x_k]}f\)</span>,则每一段可以被控制为<span class="math inline">\(M_k-m_k\)</span>.我们早在之前就提过黎曼可积的函数可被线性函数逼近,于是取足够小的划分使得<span class="math inline">\(\sum_{k=1}^n(M_k-m_k)\Delta
x_k&lt;\epsilon_2^2\)</span>.</p>
<p>接下来常规分治,取<span class="math inline">\(A=\{1\leq k\leq
n|M_k-m_k\geq \epsilon_2\}\)</span>而<span class="math inline">\(B=\{1\leq k\leq n|M_k-m_k&lt;
\epsilon_2\}\)</span>.见到<span class="math inline">\(\sum_{k\in
A}\Delta x_k&lt;\epsilon_2\)</span>.不妨设<span class="math inline">\(M=\sup_{[-A+1,A-1]} f,m=\inf_{[-A+1,A-1]}
f\)</span>立刻有:</p>
<p><span class="math display">\[
\int_{-A+1}^{A-1}\left|f-g\right|^p{\rm d}x\\
\leq \sum_{k}|M_k-m_k|^p\Delta x_k\\
=\sum_{k\in A}|M_k-m_k|^p\Delta x_k+\sum_{k\in A}|M_k-m_k|^p\Delta x_k\\
\leq |M-m|^p\epsilon_2+\epsilon_2^p(2A-2)
\]</span></p>
<p>这样这里就被限制住了,而考虑:</p>
<p><span class="math display">\[
\int_{-\infty}^{+\infty}\left|f(x+h)-f(x)\right|^p{\rm d}x\\
\leq
\int_{-\infty}^{+\infty}3^p\left(\left|f(x+h)-g(x+h)\right|^p+\left|g(x+h)-g(x)\right|^p+\left|f(x)-g(x)\right|^p\right){\rm
d}x\\
\]</span></p>
<p>前后两项都能被上述控制住,只剩中间的<span class="math inline">\(|g(x+h)-g(x)|^p\)</span>是<span class="math inline">\(O(h^p)\)</span>的,只需调整<span class="math inline">\(h\)</span>就能控制住.</p>
<h6><span id="example6">Example6</span></h6>
<p>求证:<span class="math inline">\(\int_1^{+\infty}\frac{\sin x}{x}{\rm
d}x\)</span>是条件收敛的.</p>
<p>用DA判别法,取<span class="math inline">\(f=\frac{1}{x}\)</span>当然趋近于<span class="math inline">\(0\)</span>,而<span class="math inline">\(|\int_1^A
\sin x {\rm d}x|\leq 2\)</span>,于是收敛.</p>
<p>那接下来就要证明它并非绝对收敛.只需考虑:</p>
<p><span class="math display">\[
\int_1^{+\infty}\frac{|\sin x|}{x}{\rm d}x\\
\geq \int_1^{+\infty}\frac{\sin^2 x}{x}{\rm d}x\\
=\int_1^{+\infty}\frac{1-\cos^2 x}{x}{\rm d}x
\]</span></p>
<p>当然并不绝对收敛.</p>
<p>事实上还可以直接求出来这个积分的值.</p>
<p>接下来考虑<span class="math inline">\(f(x)=\begin{cases}0&amp;x=0\\\frac{1}{x}-\frac{1}{2\sin\frac{x}{2}}&amp;x\in
[-\pi,\pi]\setminus
\{0\}\end{cases}\)</span>.只需泰勒展开就知道它是解析的.回忆到黎曼引理:</p>
<p><span class="math display">\[
\int_0^{\infty}\frac{\sin x}{x}{\rm d}x\\
=\lim_{n\to +\infty}\int_{0}^{(n+\frac{1}{2})\pi}\frac{\sin x}{x}{\rm
d}x\\
=\lim_{n\to +\infty}\int_{0}^{\pi}\frac{\sin ((n+\frac{1}{2})t)}{t}{\rm
d}t\\
=\lim_{n\to +\infty}\int_{0}^{\pi}\left(f(t)+\frac{1}{2\sin
\frac{t}{2}}\right)\sin ((n+\frac{1}{2})t){\rm d}t\\
=\lim_{n\to +\infty}\int_{0}^{\pi}\frac{1}{2\sin \frac{t}{2}}\sin
((n+\frac{1}{2})t){\rm d}t\\
=\lim_{n\to +\infty}\int_{0}^{\pi}\frac{1}{2\sin
\frac{t}{2}}\left(\frac{1}{2}+\sum_{k=1}^n\cos(kt)\right){\rm d}t\\
=\frac{\pi}{2}
\]</span></p>
<h6><span id="example7">Example7</span></h6>
<p>给定<span class="math inline">\(f\in C[0,+\infty]\)</span>,<span class="math inline">\(\int_0^{+\infty}f^2{\rm
d}x&lt;+\infty\)</span>,取<span class="math inline">\(g(x)=\int_0^xf(t){\rm d}t\)</span>,求证:<span class="math inline">\(\int_0^{+\infty}\frac{g^2(x)}{x^2}{\rm d}x\leq
4\int_0^{+\infty}f^2{\rm d}x\)</span>以证明前者存在.</p>
<p>当然是分部积分,用洛必达法则知道<span class="math inline">\(\lim_{x\to
0}\frac{g}{x}\to 0\)</span>,考虑:</p>
<p><span class="math display">\[
\int_0^A \frac{g^2}{x^2}{\rm d}x=\int_0^A g^2{\rm d}(-\frac{1}{x})\\
=-\frac{g^2(x)}{x}|_0^A+\int_0^A\frac{2gf}{x}{\rm d}x\\
=-\frac{g^2(A)}{A}+2\int_0^A\frac{g}{x}f{\rm d}x\\
\leq 2(\int_0^A \frac{g^2}{x^2}{\rm d}x)^{\frac{1}{2}}(\int_0^A f^2{\rm
d}x)^{\frac{1}{2}}
\]</span></p>
<p>整理一下就做完了.</p>
<h6><span id="example8欧拉积分">Example8(欧拉积分)</span></h6>
<p>求<span class="math inline">\(\int_0^{+\infty}\frac{x^{p-1}}{1+x}{\rm
d}x,0&lt;p&lt;1\)</span>的收敛性和值.</p>
<p>考虑<span class="math inline">\(\frac{x^{p-1}}{1+x}\)</span>在<span class="math inline">\(x\to 0\)</span>的时候趋近于<span class="math inline">\(x^{p-1}\)</span>,而在<span class="math inline">\(x\to \infty\)</span>的时候趋近于<span class="math inline">\(x^{p-2}\)</span>,因此绝对收敛.</p>
<p>难点在于把这个东西求出来.接下来将采取一些不严谨的说法.</p>
<p>考虑<span class="math inline">\(0\leq x&lt;1\)</span>的时候,有:</p>
<p><span class="math display">\[
\frac{x^{p-1}}{1+x}=x^{p-1}\sum_{j=0}^\infty(-x)^j\\=\sum_{j=0}(-1)^jx^{p+j-1}\\
\]</span></p>
<p>暂时抛开多余的思量,两边做积分:</p>
<p><span class="math display">\[
\int_0^1 \frac{x^{p-1}}{1+x}{\rm d}x=\sum_{j=0}(-1)^j\int_0^1
x^{p+j-1}{\rm d}x\\
=\sum_{j=0}(-1)^j\frac{1}{p+j}
\]</span></p>
<p>另一边,其实只需换元,可以发现:</p>
<p><span class="math display">\[
\int_1^{+\infty}\frac{x^{p-1}}{1+x}{\rm d}x\\
=\int_0^1\frac{t^{1-p}}{1+t^{-1}}\frac{ {\rm d}t}{t^2}\\
=\int_0^1\frac{t^{-p}}{1+t}{\rm d}t\\
=\int_0^1\frac{t^{1-p-1}}{1+t}{\rm d}t\\
=\sum_{j=0}^{\infty}(-1)^j\frac{1}{1-p+j}\\
=\sum_{j=0}^{\infty}(-1)^{j+1}\frac{1}{p-(j+1)}\\
=\sum_{j=1}^{\infty}(-1)^{j}\frac{1}{p-j}\\
\]</span></p>
<p>结合起来,答案当然就是<span class="math inline">\(\sum_{j=-\infty}^{+\infty}\frac{(-1)^j}{p+j}\)</span>.</p>
<p>我们暂且断言上面那个无穷级数等于<span class="math inline">\(\frac{\pi}{\sin
(p\pi)}\)</span>,原因是我们权且承认下述级数是正确的:</p>
<p><span class="math display">\[
\frac{1}{\sin t}=\sum_{j=-\infty}^{+\infty}\frac{(-1)^j}{p+j\pi}
\]</span></p>
<h6><span id="example9frullani积分">Example9(Frullani积分)</span></h6>
<p>当<span class="math inline">\(f\in C[0,+\infty)\)</span>,且<span class="math inline">\(\int_0^{+\infty}\frac{f(x)}{x}{\rm
d}x\)</span>收敛,求证<span class="math inline">\(\int_0^{+\infty}\frac{f(ax)-f(bx)}{x}{\rm
d}x=f(0)\ln\frac{b}{a}\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\int_A^{B}\frac{f(ax)-f(bx)}{x}{\rm d}x\\
=\int_{aA}^{aB}\frac{f(x)}{x}{\rm d}x-\int_{bA}^{bB}\frac{f(x)}{x}{\rm
d}x\\
=\int_{aA}^{bA}\frac{f(x)}{x}{\rm d}x-\int_{aB}^{bB}\frac{f(x)}{x}{\rm
d}x\\
=\int_{a}^{b}\frac{f(Ax)}{x}{\rm d}x-\int_{aB}^{bB}\frac{f(x)}{x}{\rm
d}x\\
\]</span></p>
<p>前者当<span class="math inline">\(A\to
0\)</span>的时候当然转化为<span class="math inline">\(\int_{a}^{b}\frac{f(0)}{x}{\rm
d}x\)</span>,而后者用欧拉判准知道趋近于<span class="math inline">\(0\)</span>,立刻完事.</p>
<h6><span id="example10">Example10</span></h6>
<p>求<span class="math inline">\(I=\int_0^{\frac{\pi}{2}}\ln(\sin x){\rm
d}x\)</span>.</p>
<p>考虑<span class="math inline">\(x\to 0\)</span>的时候,<span class="math inline">\(\ln(\sin x)\sim \ln x\)</span>,而<span class="math inline">\(\int \ln x=x\ln x-x\)</span>,因此是绝对收敛的.</p>
<p>那怎么求这个积分呢?考虑一些对称技巧,立刻有:</p>
<p><span class="math display">\[
I=\int_0^{\frac{\pi}{2}}\ln(\sin x){\rm d}x\\
=\int_{\frac{\pi}{2}}^{\pi}\ln(\sin x){\rm d}x\\
=\int_{0}^{\frac{\pi}{2}}\ln(\cos x){\rm d}x\\
\]</span></p>
<p>那么:</p>
<p><span class="math display">\[
I=\frac{1}{2}\int_0^\pi\ln(\sin x){\rm d}x\\
=\int_0^{\frac{\pi}{2}}\ln(\sin 2t){\rm d}t\\
=\int_0^{\frac{\pi}{2}}\left(\ln 2+\ln (\sin t)+\ln (\cos t)\right){\rm
d}t\\
=\frac{\pi}{2}\ln 2+2I
\]</span></p>
<p>所以<span class="math inline">\(I=-\frac{\pi}{2}\ln 2\)</span>.</p>
<h6><span id="example11">Example11</span></h6>
<p>讨论<span class="math inline">\(\int_0^1\frac{\ln
x}{x^{\alpha}},\alpha&gt;0\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(x\in (0,1]\)</span>的时候,<span class="math inline">\(\frac{\ln x}{x^{\alpha}}\leq
0\)</span>,因此其收敛性当然等价于绝对收敛性.取<span class="math inline">\(x\to 0\)</span>的部分,而考虑:</p>
<p>当<span class="math inline">\(0&lt;\alpha&lt;1\)</span>,任取一个足够小的<span class="math inline">\(\delta&gt;0\)</span>使得<span class="math inline">\(0&lt;\alpha+\delta&lt;1\)</span>,都可以取足够逼近的<span class="math inline">\(x\to 0\)</span>使得<span class="math inline">\(|\frac{\ln
x}{x^{\alpha}}|&lt;\frac{1}{x^{\alpha+\delta}}\)</span>.于是此时绝对收敛.反之,当<span class="math inline">\(\alpha\geq 1\)</span>的时候,<span class="math inline">\(|\frac{\ln
x}{x^\alpha}|&gt;\frac{1}{x}\)</span>,此时发散.</p>
<h6><span id="example12">Example12</span></h6>
<p>讨论<span class="math inline">\(p,q&gt;0\)</span>,<span class="math inline">\(\int_2^{+\infty}\frac{ {\rm d}x}{x^p\ln^q
x}\)</span>的收敛性.</p>
<p>当<span class="math inline">\(p&gt;1\)</span>的时候,显然<span class="math inline">\(\frac{1}{x^p\ln ^q
x}&lt;\frac{1}{x^p}\)</span>,因此当然绝对收敛.</p>
<p>当<span class="math inline">\(p&lt;1\)</span>的时候,同Example11,只需放掉<span class="math inline">\(\ln x\)</span>就行,因此是发散的.</p>
<p>当<span class="math inline">\(p=1\)</span>的时候,估计出了点问题,此时做换元<span class="math inline">\(t=\ln x\)</span>,则原式变为:</p>
<p><span class="math display">\[
\int_{\ln 2}^{+\infty}e^{-t}e^{t}\frac{1}{t^q}{\rm d}t\\
=\int_{\ln 2}^{+\infty}\frac{1}{t^q}{\rm d}t\\
\]</span></p>
<p>所以当<span class="math inline">\(q&gt;1\)</span>的时候收敛,当<span class="math inline">\(q\leq 1\)</span>的时候发散.</p>
<h6><span id="example13">Example13</span></h6>
<p>讨论<span class="math inline">\(I=\int_0^{\frac{\pi}{2}}\frac{\sin
x}{x^p}{\rm d}x\)</span>的收敛性.</p>
<p>设<span class="math inline">\(f=\frac{\sin
x}{x}\)</span>,容易见到<span class="math inline">\(f\)</span>在<span class="math inline">\((0,\frac{\pi}{2})\)</span>上是单调递减的,那就应当有:</p>
<p><span class="math display">\[
\frac{2}{\pi}\frac{1}{x^{p-1}}\leq \frac{\sin x}{x^p}=\frac{\sin
x}{x}\frac{1}{x^{p-1}}\leq  \frac{1}{x^{p-1}}
\]</span></p>
<p>因此其收敛性等价于<span class="math inline">\(\int_{0}^{\frac{\pi}{2}}
\frac{1}{x^{p-1}}\)</span>的收敛性,当<span class="math inline">\(p&lt;2\)</span>时收敛.</p>
<h6><span id="example14">Example14</span></h6>
<p>设<span class="math inline">\(f\in C^2[a,+\infty)\)</span>,若<span class="math inline">\(\int_a^{+\infty} f^2(x){\rm
d}x&lt;+\infty,\int_a^{+\infty} (f&#39;&#39;)^2(x){\rm
d}x&lt;+\infty\)</span>,求证<span class="math inline">\(\int_a^{+\infty}
(f&#39;)^2(x){\rm d}x&lt;+\infty\)</span>.</p>
<p>此时考虑做分部积分,当然有:</p>
<p>$$ _a^x f(t)f’‘(t){}t=f(x)f’(x)-f(a)f’(a)-_a^x (f’(t))^2{}t\</p>
<p>f(x)f’(x)=_a^x f(t)f’‘(t){}t+f(a)f’(a)+_a^x (f’(t))^2{}t\ $$</p>
<p>此时回忆到柯西不等式:</p>
<p><span class="math display">\[
(\int_a^x f(t)f&#39;&#39;(t){\rm d}t)\leq (\int_a^x f^2(t){\rm
d}t)(\int_a^x (f&#39;&#39;(t))^2{\rm d}t)
\]</span></p>
<p>因此这一项被控制住了,我们知道<span class="math inline">\(f(x)f&#39;(x)\)</span>和<span class="math inline">\(\int_a^x (f&#39;(t))^2{\rm
d}t\)</span>收敛性相同.反证原结论,假设后者并不收敛而是趋近<span class="math inline">\(+\infty\)</span>.那<span class="math inline">\(f(x)f&#39;(x)\to
+\infty\)</span>,对其做积分,则:</p>
<p><span class="math display">\[
\int_a^{+\infty}f(x)f&#39;(x){\rm d}x=f^2(x)-f^2(a)
\]</span></p>
<p>因此<span class="math inline">\(f^2(x)\to
+\infty\)</span>,这当然与<span class="math inline">\(\int_a^{+\infty}
f^2(x){\rm d}x&lt;+\infty\)</span>相违背.</p>
<h6><span id="example15">Example15</span></h6>
<p>判断<span class="math inline">\(\int_1^{+\infty}\tan\left(\cfrac{\sin
x}{x}\right){\rm d}x\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(\int_1^{+\infty} \frac{\sin x}{x}{\rm
d}x\)</span>当然是收敛的,而对<span class="math inline">\(tan\frac{\sin
x}{x}\)</span>做泰勒展开应该和<span class="math inline">\(\frac{\sin
x}{x}\)</span>同阶,于是:</p>
<p><span class="math display">\[
\int_1^{+\infty}\tan\left(\cfrac{\sin x}{x}\right){\rm d}x\\
=\int_1^{+\infty}\frac{\sin x}{x}{\rm
d}x+\int_1^{+\infty}\left(\tan\left(\cfrac{\sin x}{x}\right)-\frac{\sin
x}{x}\right){\rm d}x\\
\]</span></p>
<p>前半部分当然收敛,后半部分取绝对值放缩后是<span class="math inline">\(O(\frac{1}{x^2})\)</span>的,当然也收敛.</p>
<h6><span id="example16">Example16</span></h6>
<p>讨论<span class="math inline">\(\int_1^{+\infty}\frac{\sin
x}{x^p}(\arctan x){\rm d}x,p&gt;0\)</span>的收敛性.</p>
<p><span class="math inline">\(\int_1^{+\infty}\frac{\sin x}{x^p}{\rm
d}x\)</span>收敛,而<span class="math inline">\(\arctan
x\)</span>单调有界,立刻知道收敛.</p>
<h6><span id="example17">Example17</span></h6>
<p>讨论<span class="math inline">\(\int_2^{+\infty}\frac{\cos \sqrt
x}{x^p\ln x}{\rm d}x\)</span>的收敛性.</p>
<p>当然先做换元<span class="math inline">\(t=\sqrt
x\)</span>,那么原式变成:</p>
<p><span class="math display">\[
\int_{\sqrt 2}^{+\infty}\frac{2t\cos t{\rm d}t}{t^{2p}\ln t^2}\\
=\int_{\sqrt 2}^{+\infty}\frac{\cos t{\rm d}t}{t^{2p-1}\ln t}\\
\]</span></p>
<p><span class="math inline">\(2p-1&gt;1,p&gt;1\)</span>的时候当然绝对收敛,而<span class="math inline">\(0\leq 2p-1\leq
1\)</span>的时候用DA判准知道收敛,<span class="math inline">\(2p-1&lt;0\)</span>的时候当然发散.</p>
<h6><span id="example18磨光核函数">Example18(磨光核函数)</span></h6>
<p>构造一个<span class="math inline">\(C^{\infty}\)</span>的函数<span class="math inline">\(g(x)\)</span>,满足当<span class="math inline">\(x\leq 0\)</span>的时候,<span class="math inline">\(g(x)=0\)</span>;而当<span class="math inline">\(x\geq 1\)</span>的时候,<span class="math inline">\(g(x)=1\)</span>.也就是你要造一个函数把两段直线焊接起来.</p>
<p>考虑<span class="math inline">\(h(x)=\begin{cases}e^{-\frac{1}{x^2}
&amp;x\ne 0\\0&amp;x=0}\end{cases}\)</span>.这个<span class="math inline">\(h(x)\)</span>容易检验是<span class="math inline">\(C^{\infty}\)</span>的,只需看<span class="math inline">\(0\)</span>点处的可导性即可.</p>
<p>取<span class="math inline">\(H(x)=\int_{-\infty}^xh(t)h(1-t){\rm
d}t\)</span>.容易见到这函数在<span class="math inline">\(0\)</span>处和<span class="math inline">\(1\)</span>处都无穷阶可导.稍微乘下常数就可以搞定.</p>
<h4><span id="rs积分">RS积分</span></h4>
<p>设<span class="math inline">\(\alpha(x):[a,b]\to \mathbb
R\)</span>是一个单调不减的函数,对于有界函数<span class="math inline">\(f(x):[a,b]\to
\mathbb{R}\)</span>,考虑一个分划<span class="math inline">\(P:a=x_0&lt;\cdots&lt;x_n=b\)</span>,定义<span class="math inline">\(\Delta \alpha_k=\alpha(x_k)-\alpha(x_{k-1})\geq
0\)</span>,并定义<span class="math inline">\(M_k=\sup_{[x_{k-1},x_k]}f(x),m_k=\inf_{[x_{k-1},x_k]}f(x)\)</span>.在此基础上定义<strong>上和</strong><span class="math inline">\(U(P,f,\alpha)=\sum_{k=1}^n M_k\Delta
\alpha_k\)</span>,同理定义<strong>下和</strong><span class="math inline">\(L(P,f,\alpha)=\sum_{k=1}^n m_k\Delta
\alpha_k\)</span>.定义<strong>上积分</strong><span class="math inline">\(\overline{\int_{a}^b}f(x){\rm d}\alpha=\inf_P
{U(P,f,\alpha)}\)</span>,同理定义<strong>下积分</strong><span class="math inline">\(\underline{\int_{a}^b}f(x){\rm d}\alpha=\inf_P
{L(P,f,\alpha)}\)</span>.那么如果有以下<span class="math inline">\(\overline{\int_{a}^b}f(x){\rm
d}\alpha=\underline{\int_{a}^b}f(x){\rm d}\alpha\)</span>,称<span class="math inline">\(f\)</span>在<span class="math inline">\([a,b]\)</span>上关于<span class="math inline">\(\alpha\)</span><strong>RS可积</strong>,记作<span class="math inline">\(f\in {R}_\alpha[a,b]\)</span>,而将此值称作<span class="math inline">\(f\)</span>关于<span class="math inline">\(\alpha\)</span>的RS积分,记作<span class="math inline">\(\int_a^bf(x){\rm d}\alpha\)</span>.</p>
<p>类比黎曼积分那套理论,应当有以下显而易见的性质:</p>
<ol type="1">
<li>分划<span class="math inline">\(P^*\)</span>如果是<span class="math inline">\(P\)</span>的加密,那么<span class="math inline">\(L(P,f,\alpha)\leq
L(P^*,f,\alpha),U(P,f,\alpha)\geq U(P^*,f,\alpha)\)</span>.</li>
<li><span class="math inline">\(L(P_1,f,\alpha)\leq
U(P_2,f,\alpha)\)</span>.</li>
<li><span class="math inline">\(\underline{\int_{a}^b}f(x){\rm
d}\alpha\leq \overline{\int_{a}^b}f(x){\rm d}\alpha\)</span>.</li>
<li><span class="math inline">\(f\in
{R}_\alpha\)</span>,其充要条件是<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,存在分划<span class="math inline">\(P\)</span>使得<span class="math inline">\(0\leq
U(P,f,\alpha)-L(P,f,\alpha)&lt;\epsilon\)</span>.</li>
</ol>
<p>接下来考虑证明一些性质:</p>
<ol type="1">
<li><span class="math inline">\(f_1,f_2\in
{R}_\alpha[a,b]\)</span>,则<span class="math inline">\(f_1+f_2\in
{R}_\alpha[a,b]\)</span>,并且<span class="math inline">\(\int_a^b
(f_1+f_2){\rm d}\alpha=\int_a^b f_1{\rm d}\alpha+\int_a^b f_2{\rm
d}\alpha\)</span>.</li>
<li><span class="math inline">\(f\in {R}_\alpha[a,b]\)</span>,则<span class="math inline">\(cf\in {R}_\alpha[a,b]\)</span>,并且<span class="math inline">\(\int_a^b (cf){\rm d}\alpha=c\int_a^b f{\rm
d}\alpha\)</span>.</li>
<li><span class="math inline">\(f_1,f_2\in {R}_\alpha[a,b],f_1\leq
f_2\)</span>,则<span class="math inline">\(\int_a^b f_1{\rm d}\alpha\leq
\int_a^b f_2{\rm d}\alpha\)</span>.</li>
<li><span class="math inline">\(f\in {R}_\alpha[a,b],c\in
[a,b]\)</span>,那么<span class="math inline">\(f\in {R}_\alpha[a,c],f\in
{R}_\alpha[c,b]\)</span>,且<span class="math inline">\(\int_a^b f{\rm
d}\alpha=\int_a^c f{\rm d}\alpha+\int_c^b f{\rm d}\alpha\)</span>.</li>
<li><span class="math inline">\(f\in {R}_\alpha[a,b],|f|\leq
M\)</span>,则<span class="math inline">\(|\int_a^b f{\rm d}\alpha|\leq
M\left(\alpha(b)-\alpha(a)\right)\)</span>.</li>
<li><span class="math inline">\(f\in
{R}_{\alpha_1}[a,b]\)</span>并且<span class="math inline">\(f\in
{R}_{\alpha_2}[a,b]\)</span>,则<span class="math inline">\(f\in
{R}_{\alpha_1+\alpha_2}[a,b]\)</span>,并且<span class="math inline">\(\int_a^b f{\rm d}(\alpha_1+\alpha_2)=\int_a^b
f{\rm d}\alpha_1+\int_a^b f{\rm d}\alpha_2\)</span>.</li>
<li><span class="math inline">\(f\in
{R}_\alpha[a,b],c&gt;0\)</span>.则<span class="math inline">\(f\in
{R}_{c\alpha}[a,b]\)</span>,并且<span class="math inline">\(\int_a^b
f{\rm d}(c\alpha)=c\int_a^b f{\rm d}\alpha\)</span>.</li>
<li><span class="math inline">\(f\in {R}_\alpha[a,b],m\leq f\leq M,g \in
C[m,M]\)</span>.则<span class="math inline">\(g(f(x))\in
{R}_\alpha[a,b]\)</span>.</li>
<li><span class="math inline">\(f\in {R}_\alpha[a,b]\)</span>,则<span class="math inline">\(|f|\in {R}_\alpha[a,b]\)</span>,且<span class="math inline">\(|\int_a^b f{\rm d} \alpha|\leq \int_a^b |f|{\rm d}
\alpha\)</span>.</li>
<li><span class="math inline">\(f_1,f_2\in
{R}_\alpha[a,b]\)</span>,则<span class="math inline">\(f_1f_2\in
{R}_\alpha[a,b]\)</span>.</li>
<li>如果极限<span class="math inline">\(\lim_{\lambda(P)\to 0}(\sum
f(t_k)\Delta \alpha_k),t_k\in [x_{k-1},x_k]\)</span>存在,则<span class="math inline">\(f\in
{R}_\alpha[a,b]\)</span>并且其RS积分就是上述极限.然而,逆命题未必成立.</li>
</ol>
<p>对于(1),考虑对于分划<span class="math inline">\(P_1,P_2\)</span>而言:</p>
<p><span class="math display">\[
L(P_1,f_1,\alpha)+L(P_2,f_2,\alpha)\leq L(P_1\cup
P_2,f_1,\alpha)+L(P_1\cup P_2,f_2,\alpha)\\
\leq L(P_1\cup P_2,f_1+f_2,\alpha)\\
\leq U(P_1\cup P_2,f_1+f_2,\alpha)\\
\leq U(P_1\cup P_2,f_1,\alpha)+U(P_1\cup P_2,f_2,\alpha)
\leq U(P_1,f_1,\alpha)+U(P_2,f_2,\alpha)
\]</span></p>
<p>对此式子两边同取上下确界可以证明<span class="math inline">\(\forall
\epsilon&gt;0,U(P_1\cup P_2,f_1+f_2,\alpha)-L(P_1\cup
P_2,f_1+f_2,\alpha)&lt;\epsilon\)</span>,即可得证(1).</p>
<p>对于(2),显然<span class="math inline">\(U(P,cf,\alpha)=cU(P,f,\alpha)\)</span>,下和同理,于是立即得证.</p>
<p>对于(3),由(1),显然<span class="math inline">\(f_2\geq
f_1\)</span>时,<span class="math inline">\(\int_a^b(f_2-f_1){\rm
d}\alpha\geq 0\)</span>,于是<span class="math inline">\(\int_a^b f_2{\rm
d}\alpha\geq \int_a^b f_1{\rm d}\alpha\)</span>.</p>
<p>对于(4),考虑既然<span class="math inline">\(f\in
R_\alpha[a,b]\)</span>,那么<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,都应该<span class="math inline">\(\exists
P\)</span>使得<span class="math inline">\(U_{[a,b]}(P,f,\alpha)-L_{[a,b]}(P,f,\alpha)&lt;\epsilon\)</span>,而令<span class="math inline">\(P&#39;=P\cup\{c\}\)</span>,也就是将<span class="math inline">\(c\)</span>强行作为一个分点,上式仍然成立,而可以将<span class="math inline">\(P&#39;\)</span>拆分为两个部分,不妨记作<span class="math inline">\(P_1,P_2\)</span>,应该有:</p>
<p><span class="math display">\[
U_{[a,b]}(P&#39;,f,\alpha)-L_{[a,b]}(P&#39;,f,\alpha)\\
=U_{[a,c]}(P_1,f,\alpha)-L_{[a,c]}(P_1,f,\alpha)+U_{[c,b]}(P_2,f,\alpha)-L_{[c,b]}(P_2,f,\alpha)&lt;\epsilon
\]</span></p>
<p>此二项均为正,因此分别<span class="math inline">\(&lt;\epsilon\)</span>,那也就说明了<span class="math inline">\(f\in R_\alpha[a,c]\)</span>且<span class="math inline">\(f\in R_\alpha[c,b]\)</span>,并且仍然是钦定<span class="math inline">\(c\)</span>为分点就可以见到<span class="math inline">\(\int_a^b f{\rm d}\alpha=\int_a^c f{\rm
d}\alpha+\int_c^b f{\rm d}\alpha\)</span>.</p>
<p>对于(5),由(3)可以得知:</p>
<p><span class="math display">\[
-\int_a^b M{\rm d}\alpha\leq \int_a^b f{\rm d}\alpha\leq \int_a^b M{\rm
d}\alpha
\]</span></p>
<p>而由定义立刻见到<span class="math inline">\(\int_a^b M{\rm
d}\alpha=M(\alpha(b)-\alpha(a))\)</span>.</p>
<p>对于(6),考虑<span class="math inline">\(\Delta(\alpha_1+\alpha_2)_k=\Delta \alpha_1+\Delta
\alpha_2\)</span>,因此<span class="math inline">\(U(P,f,\alpha_1+\alpha_2)=U(P,f,\alpha_1)+U(P,f,\alpha_2)\)</span>.因此证明与(4)无异.</p>
<p>对于(7),只需考虑<span class="math inline">\(\Delta(c\alpha)=c\Delta\alpha\)</span>,于是<span class="math inline">\(U(P,f,c\alpha)=cU(P,f,\alpha)\)</span>,于是证明与(2)无异.</p>
<p>考虑(8)的证明,由于<span class="math inline">\(g\)</span>是闭区间上的连续函数,立刻知道其一致连续.也就是<span class="math inline">\(\forall \epsilon&gt;0,\exists
0&lt;\delta&lt;\epsilon\)</span>,使得<span class="math inline">\(|s-t|&lt;\delta\)</span>时一定有<span class="math inline">\(|g(s)-g(t)|&lt;\epsilon\)</span>.接下来考虑由于<span class="math inline">\(f\in
R_\alpha[a,b]\)</span>,应当可以取一组划分<span class="math inline">\(P:
a=x_0&lt;\cdots&lt;x_n=b\)</span>,使得<span class="math inline">\(U(P,f,\alpha)-L(P,f,\alpha)&lt;\delta^2\)</span>.考虑将划分分为两类:<span class="math inline">\(A=\{1\leq k\leq n\mid
M_k-m_k&lt;\delta\}\)</span>和<span class="math inline">\(B=\{1\leq
k\leq n\mid M_k-m_k\geq
\delta\}\)</span>.这个思路就会和根号分治很像.那接下来考虑定义<span class="math inline">\(M_k^*=\sup_{[x_{k-1},x_k]}g(f(x)),m_k^*=\inf_{[x_{k-1},x_k]}g(f(x))\)</span>.</p>
<p>那这就会使得当<span class="math inline">\(k\in
A\)</span>的时候,由于<span class="math inline">\(g\)</span>的一致连续性,立刻可以知道<span class="math inline">\(M_k^*-m_k^*\leq \epsilon\)</span>.而当<span class="math inline">\(k\in B\)</span>的时候,考虑:</p>
<p><span class="math display">\[
\delta\sum _{k\in B}\Delta \alpha_k\leq \sum_{k\in B}(M_k-m_k)\Delta
\alpha_k\\
=U(P,f,\alpha)-L(P,f,\alpha)&lt;\delta^2
\]</span></p>
<p>于是<span class="math inline">\(\sum _{k\in B}\Delta
\alpha_k&lt;\delta\)</span>.如此一来:</p>
<p><span class="math display">\[
U(P,g\circ f,\alpha)-L(P,g\circ f,\alpha)\\
=\sum_{k\in A}(M_k^*-m_k^*)\Delta \alpha_k+\sum_{k\in
B}(M_k^*-m_k^*)\Delta \alpha_k\\
&lt;\epsilon(\alpha(b)-\alpha(a))+2(\sup |g|)\delta\\
&lt;\epsilon\left(\alpha(b)-\alpha(a)+2\sup |g|\right)
\]</span></p>
<p>这样就证毕了.</p>
<p>考虑(9)的证明,首先由(8)知道<span class="math inline">\(|f|\in
{R}_\alpha[a,b]\)</span>.而我们可以说存在<span class="math inline">\(c=\pm 1\)</span>,使得<span class="math inline">\(|\int_a^b f{\rm d} \alpha|=c(\int_a^b f{\rm d}
\alpha)\)</span>.而<span class="math inline">\(cf(x)\leq
|f(x)|\)</span>,由(3)的保序性得证.</p>
<p>考虑(10)的证明,嵌套函数<span class="math inline">\(g=x^2\)</span>并利用(9),则我们可以知道如果<span class="math inline">\(f\in {R}_\alpha[a,b]\)</span>,那么<span class="math inline">\(f^2\in {R}_\alpha[a,b]\)</span>.此时观察到<span class="math inline">\(4f_1f_2=(f_1+f_2)^2-(f_1-f_2)^2\)</span>,立即得证.</p>
<p>(11)的证明比较显然.(11)直接的逆命题的话有个反例是考虑<span class="math inline">\(f(x)=\begin{cases}1&amp;x\geq
0\\0&amp;x&lt;0\end{cases},\alpha(x)=\begin{cases}1&amp;x&gt;
0\\0&amp;x\leq 0\end{cases}\)</span>.此时会发现<span class="math inline">\(x=0\)</span>这个点取不取在分划里是重要的,只要不取在分划里,怎么加密也没有用.</p>
<p>接下来当然应当研究一下连续性对RS可积的意义.我们声明:</p>
<ol type="1">
<li>如果<span class="math inline">\(f\in C[a,b]\)</span>,则<span class="math inline">\(f\in {R}_\alpha[a,b]\)</span>且对<span class="math inline">\(\forall \epsilon&gt;0,\exists
\delta&gt;0\)</span>,并且只要<span class="math inline">\(|P|&lt;\delta\)</span>,那么<span class="math inline">\(|\sum f(t_k)\Delta \alpha_k-\int_a^b f{\rm
d}\alpha|&lt;\epsilon\)</span>,其中<span class="math inline">\(t_k\in
[x_{k-1},x_k]\)</span>.</li>
<li>(1)中的条件如果改成<span class="math inline">\(f\in
R_\alpha[a,b],\alpha\in C[a,b]\)</span>,结论仍然成立.</li>
<li>如果<span class="math inline">\(f\)</span>单调,但是<span class="math inline">\(\alpha\)</span>连续,则我们也能证明<span class="math inline">\(f_\alpha\in {R}_\alpha[a,b]\)</span>.</li>
<li>作为(3)的推论,如果<span class="math inline">\(f\)</span>是有界变差函数,<span class="math inline">\(\alpha\)</span>连续,也能证明<span class="math inline">\(f_\alpha\in {R}_\alpha[a,b]\)</span>.</li>
<li>如果<span class="math inline">\([a,b]\)</span>上的有界函数<span class="math inline">\(f\)</span>只有有限个间断点,并且<span class="math inline">\(f\)</span>和<span class="math inline">\(\alpha\)</span>的间断点集交集为空,则<span class="math inline">\(f\in
R_\alpha[a,b]\)</span>.同时,(1)中的性质仍然成立.</li>
</ol>
<p>(1)的证明,考虑<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,取<span class="math inline">\(\gamma&gt;0\)</span>,使得<span class="math inline">\(\left(\alpha(b)-\alpha(a)\right)\gamma&lt;\epsilon\)</span>.此时,<span class="math inline">\(f\)</span>是闭区间上的连续函数,那它就一定是一致连续的函数.那么<span class="math inline">\(\exists \delta&gt;0\)</span>,当<span class="math inline">\(|x-y|&lt;\delta\)</span>的时候,有<span class="math inline">\(|f(x)-f(y)|&lt;\gamma\)</span>.此时只需考虑<span class="math inline">\(U(P,f,\alpha)-L(P,f,\alpha)&lt;\epsilon\)</span>就做完了.</p>
<p>(2)的证明,考虑既然<span class="math inline">\(f\in
R_{\alpha}[a,b]\)</span>,因此一定存在一组分划<span class="math inline">\(P^*\)</span>使得<span class="math inline">\(U(P^*,f,\alpha)&lt;\int_a^b f{\rm
d}\alpha+\epsilon\)</span>.</p>
<p>那么接下来对于任意一组分划<span class="math inline">\(P:a=x_0&lt;\cdots&lt;x_m=b\)</span>,将其分为两组:一组是<span class="math inline">\(A=\{k\mid \exists i,x_i^*\in
(x_{k-1},x_k)\}\)</span>,<span class="math inline">\(B=\{1,2,\cdots,m\}\setminus A\)</span>.也即<span class="math inline">\(B\)</span>中的每个区间都被包含在<span class="math inline">\(P^*\)</span>的分划中.既然如此,在<span class="math inline">\(B\)</span>上的和的部分当然就要<span class="math inline">\(\leq U(P^*,f,\alpha)&lt;\int_a^b f{\rm
d}\alpha+\epsilon\)</span>.只要我们能证明<span class="math inline">\(A\)</span>能被控制住即可.</p>
<p>而由于<span class="math inline">\(\alpha\)</span>连续,其在<span class="math inline">\([a,b]\)</span>上绝对连续,可以取足够小的分划使得<span class="math inline">\(\Delta \alpha\)</span>足够小.既然如此,<span class="math inline">\(\sum_{k\in A}f(t_k)\Delta \alpha_k\leq
nM\max\{\Delta\alpha_k\}\)</span>,其中<span class="math inline">\(M\)</span>是<span class="math inline">\(f\)</span>在<span class="math inline">\([a,b]\)</span>上的上界,这个立刻可以被<span class="math inline">\(\max\{\Delta\alpha_k\}\)</span>控制住.</p>
<p>(3)的证明,不妨设<span class="math inline">\(f\)</span>单调不降,此时考虑取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\frac{\alpha(b)-\alpha(a)}{n}(f(b)-f(a))&lt;\epsilon\)</span>.那么由于<span class="math inline">\(\alpha\)</span>连续,所以其有介值性,可以通过选取划分使得<span class="math inline">\(\Delta \alpha_k\equiv
\frac{\alpha(b)-\alpha(a)}{n}(f(b)-f(a))\)</span>,那还是考虑<span class="math inline">\(U(P,f,\alpha)-L(P,f,\alpha)&lt;\epsilon\)</span>即可.</p>
<p>(5)的证明相当平凡,只需用闭区间上的连续函数是一致连续处理间断点即可,在此略过.</p>
<p>于上述基础上进一步拓展,可以拓展到<span class="math inline">\(\alpha\)</span>是有界变差的情况.原因是有界变差函数可以表示为两个不降函数的差,不妨设<span class="math inline">\(\alpha(x)=\beta(x)-\gamma(x)\)</span>,则我们定义<span class="math inline">\(\int_a^b f {\rm d}\alpha=\int_a^b f {\rm
d}\beta-\int_a^b f {\rm d}\gamma\)</span>.</p>
<p>这个还要证明是良定的,原因是如果一个有界变差函数能表示成两种情形,有<span class="math inline">\(\beta_1(x)-\gamma_1(x)=\beta_2(x)-\gamma_2(x)\)</span>,那么<span class="math inline">\(\beta_1(x)+\gamma_2(x)=\beta_2(x)+\gamma_1(x)\)</span>,这两边都是不降函数,那根据<span class="math inline">\(\alpha\)</span>部分可以加减的性质就完事了.</p>
<p>既然如此,对拓展的版本进一步寻找性质,不妨设<span class="math inline">\(V(x)=V_a^x\alpha\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(f\in C[a,b]\)</span>且<span class="math inline">\(\alpha\)</span>是有界变差,或<span class="math inline">\(f,\alpha\)</span>都是有界变差且<span class="math inline">\(f\)</span>连续时,<span class="math inline">\(|\int_a^b f {\rm d}\alpha|\leq \int_a^b f {\rm
d}V\)</span></li>
<li>作为(1)的推论,上述条件时,<span class="math inline">\(|\int_a^b f{\rm
d}\alpha|\leq \sup|f|\times V_a^b\alpha\)</span></li>
<li>(分部积分):当<span class="math inline">\(\alpha,f\)</span>都是有界变差,并且它们有一个是连续的时候,<span class="math inline">\(\int_a^b f {\rm d}\alpha=f\alpha\mid_a^b-\int_a^b
\alpha {\rm d}f\)</span>.应当见到其实该定理只需要<span class="math inline">\(\alpha,f\)</span>有一个是连续就行.</li>
<li>(第一积分中值定理):<span class="math inline">\(f\in
C[a,b]\)</span>且<span class="math inline">\(\alpha\)</span>不降,则<span class="math inline">\(\int_a^b f {\rm
d}\alpha=f(\xi)\left(\alpha(b)-\alpha(a)\right)\)</span>.</li>
<li>(第二积分中值定理):<span class="math inline">\(f\)</span>在<span class="math inline">\([a,b]\)</span>上单调,<span class="math inline">\(\alpha\)</span>是连续有界变差.则<span class="math inline">\(\int_a^b f {\rm
d}\alpha=f(a)\left(\alpha(\xi)-\alpha(a)\right)+f(b)\left(\alpha(b)-\alpha(\xi)\right)\)</span>.</li>
<li>(变量替换公式):如果<span class="math inline">\(f,g\in
C[a,b]\)</span>并且<span class="math inline">\(g\)</span>严格增,取<span class="math inline">\(h=g^{-1}\)</span>,<span class="math inline">\(c=g(a),d=g(b)\)</span>,那么<span class="math inline">\(\int_a^b f(x){\rm d}x=\int_c^d f(h(y)){\rm
d}h(y)\)</span>.</li>
<li>(和黎曼可积的关系):<span class="math inline">\(f\in
R[a,b]\)</span>,<span class="math inline">\(\alpha\)</span>可导并且<span class="math inline">\(\alpha&#39;\in R[a,b]\)</span>,则<span class="math inline">\(f\in R_\alpha[a,b]\)</span>,且<span class="math inline">\(\int_a^b f {\rm d}\alpha=\int_a^b f
\alpha&#39;{\rm d}x\)</span></li>
</ol>
<p>考虑(1)的证明,由于此时已经可以使用求和来逼近,那不妨考虑:</p>
<p><span class="math display">\[
|S(P,f,\alpha)|=|\sum f(t_k)\Delta \alpha_k|\\
\leq |\sum f(t_k)|\sdot|\Delta \alpha_k|\\
\leq |\sum f(t_k)|\Delta V_k
\]</span></p>
<p>于是证毕.(2)自是(1)的推论.</p>
<p>(3)的话,当然是Abel求和,考虑:</p>
<p><span class="math display">\[
S(P,f,\alpha)=\sum_{k=1}^n f(t_k)(\alpha(x_k)-\alpha(x_{k-1}))\\
=f(b)\alpha(b)-f(a)\alpha(a)-\sum_{k=1}^{n+1}\alpha(x_{k-1})(f(t_k)-f(t_{k-1}))\\
=f\alpha|_a^b-S(Q,\alpha,f)
\]</span></p>
<p>容易见到<span class="math inline">\(|P|\to 0\)</span>会导致<span class="math inline">\(|Q|\to 0\)</span>,便是显然.</p>
<p>考虑(4),由于<span class="math inline">\(f\)</span>是连续的,直接取<span class="math inline">\(f\)</span>的上下界并介值定理一下即是显然.</p>
<p>考虑(5),用分部积分公式,立刻有:</p>
<p><span class="math display">\[
\int_a^b f{\rm d}\alpha=f(b)\alpha(b)-f(a)\alpha(a)-\int_a^b\alpha{\rm
d}f\\
=f(b)\alpha(b)-f(a)\alpha(a)-\alpha(\xi)(f(b)-f(a))
\]</span></p>
<p>整理一下即可.</p>
<p>考虑(6),由于连续性,因此对<span class="math inline">\(x\)</span>做的划分同样通过一个<span class="math inline">\(h\)</span>成为了新的一组划分,而且由于闭区间上的连续函数是一致连续的,这个划分当然也趋近于<span class="math inline">\(0\)</span>,立即见到成立.</p>
<p>对于(7),首先用介值定理得到<span class="math inline">\(\Delta
\alpha_k=\alpha&#39;(\xi_k)\Delta x_k\)</span>,那当然有:</p>
<p><span class="math display">\[
S(P,f,\alpha)=\sum f(t_k)\Delta \alpha_k\\
=\sum f(t_k)\alpha&#39;(t_k)\Delta x_k+\sum
f(t_k)(\alpha&#39;(\xi_k)-\alpha&#39;(t_k))\Delta x_k
\]</span></p>
<p>而后面那一项绝对值不超过<span class="math inline">\(|\sup f|\sum
\omega_{\alpha&#39;}\)</span>,当然趋近于<span class="math inline">\(0\)</span>.</p>
<h3><span id="级数">级数</span></h3>
<p>对于数列<span class="math inline">\(\{a_n\}\)</span>,定义<span class="math inline">\(S_n=\sum_{k=1}^n a_k\)</span>.如果<span class="math inline">\(\lim_{n\to\infty}S_n\)</span>存在,则称级数<span class="math inline">\(\sum_{k=1}^{\infty}a_n\)</span><strong>收敛</strong>,记作<span class="math inline">\(S=\sum_{k}^{\infty}a_n\)</span>,否则如若上述极限不存在,称其<strong>发散</strong>.</p>
<p>用柯西准则立刻见到如若<span class="math inline">\(\lim _{n\to
\infty}S_n\)</span>收敛则必有<span class="math inline">\(\lim_{n\to
\infty}a_n=0\)</span>.但反命题当然不成立.这是相当重要的,正是因为<span class="math inline">\(\lim_{n\to
\infty}a_n=0\)</span>,所以我们才总能使用泰勒展开等手段进行估计和放缩.</p>
<p>容易见到以下性质显然成立,然而逆命题并不总是成立:</p>
<ol type="1">
<li><span class="math inline">\(\sum^{+\infty}a_n=A,\sum^{+\infty}b_n=B\)</span>,则<span class="math inline">\(\sum^{+\infty}(a_n+b_n)=A+B\)</span>.</li>
<li><span class="math inline">\(\sum^{+\infty}a_n=A\)</span>,则<span class="math inline">\(\sum^{+\infty}c a_n=cA\)</span>.</li>
<li>结合律:<span class="math inline">\(\sum^{+\infty}a_n=A\)</span>,若<span class="math inline">\(\{n_k\}\)</span>是递增正整数序列且<span class="math inline">\(n_0=1\)</span>,设<span class="math inline">\(C_k=\sum_{n=n_{k-1}}^{n_k-1}a_n\)</span>,则<span class="math inline">\(\sum_k^{+\infty}C_k=A\)</span>.</li>
</ol>
<p>(1)(2)显然,(3)当然是因为原数列收敛立刻能推出其子列收敛.</p>
<p>如果<span class="math inline">\(\sum
|a_n|&lt;\infty\)</span>,则称此级数<strong>绝对收敛</strong>.考虑<span class="math inline">\(a_n=|a_n|-(|a_n|-a_n)\)</span>,前后两者都是正项数列而且<span class="math inline">\(|a_n|-a_n\leq
2|a_n|\)</span>,所以绝对收敛当然能推出收敛,而反之不可.将收敛但不绝对收敛的级数称作<strong>条件收敛</strong>.绝对收敛的两个级数之和当然也绝对收敛,乘一个系数后也绝对收敛.</p>
<p>我们有<strong>柯西收敛原理</strong>:<span class="math inline">\(\sum
a_n\)</span>收敛的充要条件是<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,<span class="math inline">\(\exists
N&gt;0,\forall m&gt;n\geq N\)</span>,<span class="math inline">\(|\sum_{k=n}^m a_k|&lt;\epsilon\)</span>.</p>
<p>再还有Abel-Dirichlet判别法,设<span class="math inline">\(a_n\)</span>单调,<span class="math inline">\(B_n=\sum_{k=1}^n b_k\)</span>,<span class="math inline">\(B_n\)</span>有界,<span class="math inline">\(|B_n|\leq M\)</span>:</p>
<ol type="1">
<li>引理:<span class="math inline">\(|\sum_{k=1}^n a_kb_k|\leq
M(|a_1|+2|a_n|)\)</span>.</li>
<li>Dirichlet判别法:若<span class="math inline">\(a_n\to
0\)</span>,则<span class="math inline">\(\sum a_kb_k\)</span>收敛.</li>
<li>Abel判别法:若<span class="math inline">\(B_n\)</span>收敛,<span class="math inline">\(a_n\)</span>有界,则<span class="math inline">\(\sum a_kb_k\)</span>收敛.</li>
</ol>
<p>(1)的话当然只需使用Abel变换,有:</p>
<p><span class="math display">\[
\sum_{k=1}^n a_kb_k=\sum_{k=1}^na_k(B_k-B_{k-1})\\
=a_nB_n+\sum_{k=1}^{n-1}(a_k-a_{k+1})B_k
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
|\sum_{k=1}^n a_kb_k|\\
\leq |a_nB_n|+\sum_{k=1}^{n-1}|a_k-a_{k+1}|\sdot |B_k|\\
\leq M(|a_1-a_n|+|a_n|)\\
\leq M(|a_1|+2|a_n|)
\]</span></p>
<p>(2)(3)的话用柯西判准,考虑任意一段求和<span class="math inline">\(|B_{n+p}-B_{n-1}|\leq 2M\)</span>,于是:</p>
<p><span class="math display">\[
|\sum_{k=n}^{n+p}a_kb_k|\leq 2M(|a_n|+2|a_{n+p}|)
\]</span></p>
<p>则属显然.</p>
<p>DA判别法的一个推论是,对于<span class="math inline">\(\sum
b_k\)</span>和<span class="math inline">\(\sum
c_k\)</span>来说,如果<span class="math inline">\(\frac{b_k}{c_k}\)</span>单调有界,那么它们敛散性相同.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum
\frac{\sin(nx)}{n}\)</span>的收敛性.</p>
<p>首先当<span class="math inline">\(x=2k\pi\)</span>的时候当然收敛,否则使用DA判别法,考虑证明<span class="math inline">\(\sum \sin(nx)\)</span>有界.</p>
<p>用积化和差,考虑:</p>
<p><span class="math display">\[
|\sum_{k=1}^n\sin (kx)|=\left|\frac{\sum
2\sin\frac{x}{2}\sin(kx)}{2\sin(\frac{x}{2})}\right|\\
=\left|\frac{\sum
\cos(k-\frac{1}{2})x-\cos(k+\frac{1}{2})x}{2\sin(\frac{x}{2})}\right|\\
\leq \frac{1}{|\sin\frac{x}{2}|}
\]</span></p>
<p>这就完事.</p>
<p>能不能进一步把上面的这个级数求出来呢?考虑欧拉公式,令<span class="math inline">\(z=e^{ix}\)</span>,知道<span class="math inline">\(e^{inx}=\cos (nx)+i\sin(nx)\)</span>,所以<span class="math inline">\(\sum
\frac{z^n}{n}=-\ln(1-z)\)</span>的虚部就是所求.</p>
<p>而:</p>
<p><span class="math display">\[
-\ln(1-z)=-\ln(1-\cos x-i\sin x)\\
=-\ln(2\sin\frac{x}{2}(\sin \frac{x}{2}-i\cos \frac{x}{2}))\\
=-\ln(2\sin\frac{x}{2}e^{\frac{x-\pi}{2}i})\\
=-\ln(2\sin\frac{x}{2})+\frac{\pi - x}{2}i
\]</span></p>
<p>这就顺便解决了<span class="math inline">\(\sum
\frac{\cos(nx)}{n}\)</span>的情况.</p>
<h6><span id="example2">Example2</span></h6>
<p>判断<span class="math inline">\(\sum
\frac{(-1)^n}{n^p+(-1)^n},p&gt;0\)</span>的收敛性.</p>
<p>观察到:</p>
<p><span class="math display">\[
\frac{(-1)^n}{n^p+(-1)^n}\\
=\frac{(-1)^n}{n^p}\frac{1}{1+\frac{(-1)^n}{n^p}}\\
=\frac{(-1)^n}{n^p}\frac{1-\frac{(-1)^n}{n^p}}{1-\frac{1}{n^{2p}}}\\
=\frac{(-1)^n}{n^p-\frac{1}{n^p}}-\frac{1}{n^{2p}-1}
\]</span></p>
<p>前半部分当然收敛,于是<span class="math inline">\(p\leq
\frac{1}{2}\)</span>的时候发散,<span class="math inline">\(\frac{1}{2}&lt;p\leq 1\)</span>的时候条件收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum
\frac{\sin(\frac{n\pi}{4})}{n^p+\sin(\frac{n\pi}{4})}\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\frac{\sin(\frac{n\pi}{4})}{n^p+\sin(\frac{n\pi}{4})}\\
=\frac{\sin(\frac{n\pi}{4})}{n^p}
\frac{1}{1+\frac{\sin(\frac{n\pi}{4})}{n^p}}\\
=\frac{\sin(\frac{n\pi}{4})}{n^p}\left(1-\frac{\sin(\frac{n\pi}{4})}{n^p}+o(\frac{1}{n^p})\right)\\
=\frac{\sin(\frac{n\pi}{4})}{n^p}-\frac{\sin^2(\frac{n\pi}{4})}{n^{2p}}+o(\frac{1}{n^{2p}})
\]</span></p>
<p>见到应该是<span class="math inline">\(p\leq
\frac{1}{2}\)</span>发散,<span class="math inline">\(\frac{1}{2}&lt;p\leq
1\)</span>的时候条件收敛,<span class="math inline">\(p&gt;1\)</span>的时候绝对收敛.</p>
<h4><span id="正项级数">正项级数</span></h4>
<ol type="1">
<li>当<span class="math inline">\(a_n\geq 0\)</span>的时候,<span class="math inline">\(S_n\)</span>有界$$<span class="math inline">\(S_n\)</span>有极限.</li>
<li>当<span class="math inline">\(0\leq a_n\leq b_n\)</span>,若<span class="math inline">\(\sum^{+\infty}b_n&lt;\infty\)</span>,则<span class="math inline">\(\sum^{+\infty}a_n&lt;\infty\)</span>.</li>
<li>若<span class="math inline">\(a_n,b_n&gt;0\)</span>,则若<span class="math inline">\(\varlimsup_{n\to
\infty}\frac{a_n}{b_n}&lt;\infty\)</span>,则<span class="math inline">\(\sum^{+\infty}b_n&lt;\infty\Rightarrow
\sum^{+\infty}a_n&lt;\infty\)</span>.</li>
<li>若<span class="math inline">\(a_n,b_n&gt;0\)</span>,则若<span class="math inline">\(\varliminf_{n\to
\infty}\frac{a_n}{b_n}&gt;0\)</span>,则<span class="math inline">\(\sum^{+\infty}b_n=\infty\Rightarrow
\sum^{+\infty}a_n=\infty\)</span>.</li>
<li>若<span class="math inline">\(a_n\)</span>单调递减趋近于<span class="math inline">\(0\)</span>.则<span class="math inline">\(\sum^{+\infty}_na_n&lt;\infty\Leftrightarrow
\sum_{k}^{+\infty}2^ka_{2^k}&lt;\infty\)</span>.</li>
<li><span class="math inline">\(\sum_{k=1}^{+\infty}\frac{1}{n^p}\)</span>,当<span class="math inline">\(p\leq 1\)</span>的时候发散,而当<span class="math inline">\(p&gt;1\)</span>的时候收敛.</li>
<li><span class="math inline">\(\sum_{k=2}^{+\infty}\frac{1}{n\ln^p
n}\)</span>,当<span class="math inline">\(p\leq
1\)</span>的时候发散,而当<span class="math inline">\(p&gt;1\)</span>的时候收敛.</li>
<li>设单调递减连续正函数<span class="math inline">\(f(x)\)</span>满足<span class="math inline">\(a_n=f(n)\)</span>,则<span class="math inline">\(\sum_{k=1}^{+\infty}a_k&lt;\infty\Leftrightarrow
\int_1^{+\infty}f(x){\rm d}x&lt;\infty\)</span>.</li>
<li>比值判别法:对于<span class="math inline">\(a_n&gt;0\)</span>,如果<span class="math inline">\(\varlimsup_{n\to
\infty}\frac{a_{n+1}}{a_n}&lt;1\)</span>,则<span class="math inline">\(\sum a_n&lt;\infty\)</span>.</li>
<li>比值判别法:对于<span class="math inline">\(a_n&gt;0\)</span>,如果<span class="math inline">\(\varliminf_{n\to
\infty}\frac{a_{n+1}}{a_n}&gt;1\)</span>,则<span class="math inline">\(\sum a_n=\infty\)</span>.</li>
<li>根值判别法:对于<span class="math inline">\(a_n&gt;0\)</span>,设<span class="math inline">\(l=\varlimsup_{n\to\infty}(a_n)^{\frac{1}{n}}\)</span>,如果<span class="math inline">\(l&lt;1\)</span>,则<span class="math inline">\(\sum
a_n&lt;\infty\)</span>;若<span class="math inline">\(l&gt;1\)</span>,则<span class="math inline">\(\sum
a_n=\infty\)</span>.</li>
<li>对于<span class="math inline">\(a_n&gt;0\)</span>,如果<span class="math inline">\(\varliminf_{n\to \infty}n\ln
\frac{a_n}{a_{n+1}}&gt;1\)</span>,则<span class="math inline">\(\sum
a_n&lt;\infty\)</span>.</li>
<li>对于<span class="math inline">\(a_n&gt;0\)</span>,如果<span class="math inline">\(\varlimsup_{n\to \infty}n\ln
\frac{a_n}{a_{n+1}}&lt;1\)</span>,则<span class="math inline">\(\sum
a_n=\infty\)</span>.</li>
<li>拉贝判别法:对于<span class="math inline">\(a_n&gt;0\)</span>,若<span class="math inline">\(\varliminf_{n\to
\infty}n(\frac{a_n}{a_{n+1}}-1)&gt;1\)</span>,则<span class="math inline">\(\sum a_n&lt;\infty\)</span>.</li>
<li>拉贝判别法:对于<span class="math inline">\(a_n&gt;0\)</span>,若<span class="math inline">\(\varlimsup_{n\to
\infty}n(\frac{a_n}{a_{n+1}}-1)&lt;1\)</span>,则<span class="math inline">\(\sum a_n=\infty\)</span>.</li>
</ol>
<p>(1)当然是单调收敛准则.(2)只是(1)的推论.</p>
<p>(3)(4)只需套用定义即可.</p>
<p>(5)的话,不妨设<span class="math inline">\(S_n=\sum_{k=1}^n
a_k\)</span>而<span class="math inline">\(T_n=\sum_{k=1}^n2^ka_{2^k}\)</span>考虑当<span class="math inline">\(2^k\leq n\)</span>的时候,有:</p>
<p><span class="math display">\[
S_n\geq \sum_{j=1}^{2^k}a_j\\
=a_1+\sum_{j=0}^{k-1}\sum_{i=2^j+1}^{2^{j+1}}a_i\\
\geq \frac{1}{2}T_k
\]</span></p>
<p>当<span class="math inline">\(n&lt;2^{k+1}\)</span>的时候,则有:</p>
<p><span class="math display">\[
S_n\leq \sum_{j=1}^{2^k}a_j\\
=\sum_{j=0}^{k-1}\sum_{i=2^j}^{2^{j+1}-1}a_i\\
\leq T_k
\]</span></p>
<p>(6)的话,首先<span class="math inline">\(p\leq 1\)</span>的时候<span class="math inline">\(\frac{1}{n^p}\geq
\frac{1}{n}\)</span>于是显然,而当<span class="math inline">\(p&gt;1\)</span>的时候,考虑用(5),观察<span class="math inline">\(\sum 2^k\frac{1}{2^{pk}}=\sum
2^{(1-p)k}\)</span>,当然收敛.</p>
<p>(7)的话亦然考虑(5),等价于<span class="math inline">\(\sum
2^k\frac{1}{2^kk^p\ln^p 2}=\sum \frac{1}{k^p\ln^p
2}\)</span>,等价于(6)了.这个结论还可以推广到<span class="math inline">\(\sum\frac{1}{n\ln n(\ln\ln
n)^p}\)</span>,总之都是类似的做法,结论也类似.</p>
<p>(8)的证明只需考虑:</p>
<p><span class="math display">\[
a_{n+1}=f(n+1)\leq \int_n^{n+1}f(t){\rm d}t\leq f(n)=a_n
\]</span></p>
<p>立刻证毕.</p>
<p>而且这个估计还可以更精细,事实上我们可以证明下列极限总是存在:</p>
<p><span class="math display">\[
\lim_{n\to \infty}(\sum_{k=m}^n f(k)-\int_m^n f(x){\rm d}x)=\alpha
\]</span></p>
<p>而且还满足<span class="math inline">\(0\leq \alpha\leq
f(m)\)</span>.</p>
<p>考虑固定<span class="math inline">\(m\)</span>,设<span class="math inline">\(g(n)=\sum_{k=m}^n f(k)-\int_m^n f(x){\rm
d}x\)</span>,用单调收敛准则,我们先证明它单调递减且有下界,注意到:</p>
<p><span class="math display">\[
g(n)-g(n+1)=-f(n+1)+\int_{n}^{n+1}f(x){\rm d}x\geq 0
\]</span></p>
<p>这就证明了其单调递减,而又有:</p>
<p><span class="math display">\[
g(n)=\sum_{k=m}^{n-1}(f(k)-\int_{k}^{k+1}f(x){\rm d}x)+f(n)\geq f(n)\geq
0
\]</span></p>
<p>因此有下界.同时注意到<span class="math inline">\(g(m)=f(m)\)</span>,因此总有<span class="math inline">\(0\leq \alpha\leq f(m)\)</span>成立.</p>
<p>不仅如此,如果<span class="math inline">\(f(n)\)</span>还满足<span class="math inline">\(\lim_{x\to
\infty}f(x)=0\)</span>,我们还可以把这个极限收敛的速度求出来.我们有:</p>
<p><span class="math display">\[
|\sum_{k=m}^nf(k)-\int_m^n f(x){\rm d}x-\alpha|\leq f(n)
\]</span></p>
<p>干脆令<span class="math inline">\(l&gt;n\)</span>,考虑LHS应该是:</p>
<p><span class="math display">\[
\sum_{k=m}^nf(k)-\int_m^n f(x){\rm d}x-\alpha\\
=\sum_{k=m}^nf(k)-\int_m^n f(x){\rm d}x-\left(\lim_{l\to
\infty}(\sum_{k=m}^l f(k)-\int_m^l f(x){\rm d}x)\right)\\
=\lim_{l\to \infty}\left(\int_n^lf(x){\rm d}x-\sum_{k=n+1}^l
f(k)\right)\\
=\lim_{l\to \infty}\left(\sum_{k=n+1}^l(\int_{k-1}^kf(k){\rm
d}x-f(k))\right)\\
\leq \lim_{l\to \infty}\left(\sum_{k=n+1}^l(f(k-1)-f(k))\right)\\
\leq f(n)
\]</span></p>
<p>而上式换个方向放缩就可以知道<span class="math inline">\(\geq
0\)</span>,这就搞定.</p>
<p>(9)(10)类似(3)(4),用等比数列控制住即可.</p>
<p>(11)的话,如若<span class="math inline">\(l=\varlimsup_{n\to\infty}(a_n)^{\frac{1}{n}}\)</span>.</p>
<p>当<span class="math inline">\(l&lt;1\)</span>的时候,取<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(l+\epsilon&lt;1\)</span>,则<span class="math inline">\(\exists N_0&gt;0\)</span>,<span class="math inline">\(\forall n\geq N_0\)</span>,<span class="math inline">\((a_n)^{\frac{1}{n}}&lt;l+\epsilon\)</span>,意味着<span class="math inline">\(a_n&lt;(l+\epsilon)^n\)</span>,立刻见到其收敛.</p>
<p>当<span class="math inline">\(l&gt;1\)</span>的时候,取<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(l-\epsilon&gt;1\)</span>,则存在原数列的一个无穷子列<span class="math inline">\(\{n_k\}\)</span>,使得<span class="math inline">\(a_{n_k}&gt;(l-\epsilon)^n\to
\infty\)</span>,当然发散.</p>
<p>而注意到:</p>
<p><span class="math display">\[
\varliminf \frac{a_{n+1}}{a_n}\leq \varliminf \sqrt[n]{a_n}\leq
\varlimsup \sqrt[n]{a_n}\leq \varlimsup \frac{a_{n+1}}{a_n}
\]</span></p>
<p>证明的话,前后两个不等式类似,下面只证明<span class="math inline">\(\sqrt[n]{a_n}\leq \varlimsup
\frac{a_{n+1}}{a_n}\)</span>,取<span class="math inline">\(\varlimsup
\frac{a_{n+1}}{a_n}=l\)</span>,不妨设<span class="math inline">\(l&lt;\infty\)</span>,否则上式自然成立.那么此时,就可以取<span class="math inline">\(\epsilon&gt;0\)</span>,然后取<span class="math inline">\(N_0&gt;0\)</span>使得<span class="math inline">\(\forall n\geq  N_0\)</span>都有<span class="math inline">\(\frac{a_{n+1}}{a_n}&lt;l+\epsilon\)</span>,则<span class="math inline">\(a_n\leq
(l+\epsilon)^{n-N_0}a_{N_0}\)</span>,也就是<span class="math inline">\(\sqrt[n]{a_n}\leq
(l+\epsilon)^{1-\frac{N_0}{n}}\sqrt[n]{a_{N_0}}\)</span>,两边取上极限再由<span class="math inline">\(\epsilon\)</span>任意性当然拿到了<span class="math inline">\(\sqrt[n]{a_n}\leq l\)</span>.</p>
<p>这就意味着根值判别法理论上严格强于比值判别法.</p>
<p>(12)(13)的证明,考虑当<span class="math inline">\(l=\varliminf_{n\to
\infty}n\ln \frac{a_n}{a_{n+1}}&gt;1\)</span>的时候,取<span class="math inline">\(\epsilon&gt;0,p=l-\epsilon&gt;1\)</span>,那么就有<span class="math inline">\(\exists N_0&gt;0,\forall n\geq
N_0\)</span>,都有:</p>
<p><span class="math display">\[
n\ln\frac{a_n}{a_{n+1}}&gt;p\\
\frac{a_n}{a_{n+1}}&gt;e^{\frac{p}{n}}&gt;\left((1+\frac{1}{n})^n\right)^{\frac{p}{n}}\\
\frac{a_{n+1}}{a_n}&lt;\cfrac{\frac{1}{(n+1)^p}}{\frac{1}{n^p}}
\]</span></p>
<p>取<span class="math inline">\(b_n=\frac{1}{n^p}\)</span>,由上见到<span class="math inline">\(a_n&lt;\frac{a_{N_0}}{b_{N_0}}b_n\)</span>,这就控制住了.(13)同理.控制<span class="math inline">\(e\)</span>的时候改用不等式<span class="math inline">\(e&lt;(1+\frac{1}{n-1})^n\)</span>即可.</p>
<p>(14)(15)仍然类似,设<span class="math inline">\(b_n=n(\frac{a_n}{a_{n+1}}-1)\)</span>.</p>
<p>当<span class="math inline">\(l=\varliminf_{n\to
\infty}b_n&gt;1\)</span>的时候,取<span class="math inline">\(\epsilon&gt;0\)</span>,<span class="math inline">\(l-\epsilon&gt;1\)</span>,则<span class="math inline">\(\exists N_0&gt;0,\forall n\geq N_0\)</span>,<span class="math inline">\(b_n&gt;l-\epsilon=l&#39;\)</span>.而:</p>
<p><span class="math display">\[
\frac{a_n}{a_{n+1}}=1+\frac{b_n}{n}\\
\ln
\frac{a_n}{a_{n+1}}=\ln(1+\frac{b_n}{n})&gt;\ln(1+\frac{l&#39;}{n})\\
\varliminf n\ln\frac{a_n}{a_{n+1}}\geq \varliminf
\ln(1+\frac{l&#39;}{n})^{n}=l&#39;&gt;1
\]</span></p>
<p>这就做完了.(15)同理.</p>
<h6><span id="example1">Example1</span></h6>
<p>斐波那契数列<span class="math inline">\(f_0=0,f_1=1\)</span>,求<span class="math inline">\(\sum \frac{1}{f_k}\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(a_{n-1}\leq
2a_{n-2}\)</span>,所以<span class="math inline">\(a_n=a_{n-1}+a_{n-2}\geq \frac{3}{2}a_{n-1}\geq
(\frac{3}{2})^{n-1}\)</span>.原本的数列有上界,这就做完了.</p>
<h6><span id="example2">Example2</span></h6>
<p>假设<span class="math inline">\(0&lt;a_n\)</span>单调递增且有界,求证:<span class="math inline">\(\sum(1-\frac{a_k}{a_{k+1}})&lt;\infty\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\sum(1-\frac{a_k}{a_{k+1}})\\
=\sum \frac{1}{a_k}(\frac{1}{a_k}-\frac{1}{a_{k+1}})\\
\leq \sup{a}\sum(\frac{1}{a_k}-\frac{1}{a_{k+1}})\\
\leq \frac{\sup{a}}{a_1}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum
\frac{1}{n^p-n^q},p&gt;q&gt;0\)</span>的收敛性.</p>
<p>直接考虑<span class="math inline">\(\lim_{n\to
\infty}\cfrac{\frac{1}{n^p-n^q}}{\frac{1}{n^p}}=1\)</span>,所以<span class="math inline">\(p\leq 1\)</span>的时候发散,<span class="math inline">\(p&gt;1\)</span>的时候收敛.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum \sin
\frac{1}{n^2}\)</span>的收敛性.</p>
<p>直接考虑<span class="math inline">\(\lim_{n\to \infty}\cfrac{\sin
\frac{1}{n^2}}{\frac{1}{n^2}}=1\)</span>,所以收敛.</p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(a_n=(1-\sqrt[3]{\frac{n-1}{n+1}})^p,p&gt;0\)</span>,讨论<span class="math inline">\(\sum a_n\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
(1-\sqrt[3]{\frac{n-1}{n+1}})=(1-\frac{1}{n})^{\frac{1}{3}}(1+\frac{1}{n})^{-\frac{1}{3}}\\
=(1-\frac{1}{3n}+O(\frac{1}{n^2}))(1-\frac{1}{3n}+O(\frac{1}{n^2}))\\
=1-\frac{2}{3n}+O(\frac{1}{n^2})
\]</span></p>
<p>所以<span class="math inline">\(a_n\)</span>和<span class="math inline">\(\frac{1}{n^p}\)</span>同敛散.</p>
<h6><span id="example6">Example6</span></h6>
<p>求<span class="math inline">\(S_n=\sum_{k=1}^n\frac{1}{\sqrt
k}-2\sqrt n\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
a_{n+1}=S_{n+1}-S_n\\
=\frac{1}{\sqrt{n+1}}-2\sqrt{n+1}+2\sqrt{n}\\
=\frac{1}{\sqrt{n+1}}-\frac{2}{\sqrt{n+1}+\sqrt{n}}\\
=\frac{\sqrt{n}-\sqrt{n+1}}{\sqrt{n+1}(\sqrt{n+1}+\sqrt{n})}\\
=\frac{-1}{\sqrt{n+1}(\sqrt{n+1}+\sqrt{n})^2}
=O(-n^{-\frac{3}{2}})
\]</span></p>
<p>所以收敛.</p>
<h6><span id="example7">Example7</span></h6>
<p>求<span class="math inline">\(a_n=\frac{1}{\sqrt
n}-\sqrt{\ln(1+\frac{1}{n})}\)</span>的收敛性.</p>
<p>注意到:</p>
<p><span class="math display">\[
a_n=\frac{1}{\sqrt n}-\sqrt{\ln(1+\frac{1}{n})}\\
=\frac{1}{\sqrt n}-\sqrt{\frac{1}{n}-\frac{1}{2n^2}+o(\frac{1}{n^2})}\\
=\frac{1}{\sqrt
n}\left(1-\frac{1}{2n}+o(\frac{1}{n})\right)^{\frac{1}{2}}\\
=\frac{1}{\sqrt n}\left(1-\frac{1}{4n}+o(\frac{1}{n})\right)\\
=O(n^{-\frac{3}{2}})
\]</span></p>
<p>所以收敛.</p>
<h6><span id="example8">Example8</span></h6>
<p>设<span class="math inline">\(\zeta(a)=\sum_{k=1}^{\infty}
\frac{1}{k^a}\)</span>,求<span class="math inline">\(\lim_{\sigma\to
0+0}\sigma\zeta(1+\sigma)\)</span>和<span class="math inline">\(\lim_{\sigma\to
0+0}\zeta(1+\sigma)-\frac{1}{\sigma}\)</span>.</p>
<p>取<span class="math inline">\(f(x)=\frac{1}{x^{1+\sigma}}\)</span>,设<span class="math inline">\(F(x)=\int_1^xf(t){\rm d}t\)</span>考虑:</p>
<p><span class="math display">\[
\sum_{k=n+1}^{\infty}a_k\leq F(+\infty)-F(n)\leq
\sum_{k=n}^{\infty}a_k\\
F(+\infty)-F(n+1)\leq \sum_{k=n+1}^{\infty}a_k\leq F(+\infty)-F(n)\\
\frac{1}{\sigma}\frac{1}{(n+1)^\sigma}\leq \sum_{k=n+1}^{\infty}a_k\leq
\frac{1}{\sigma}\frac{1}{n^\sigma}\\
\frac{1}{(n+1)^\sigma}\leq \sigma\sum_{k=n+1}^{\infty}a_k\leq
\frac{1}{n^\sigma}
\]</span></p>
<p>取<span class="math inline">\(n=0\)</span>得到<span class="math inline">\(1\leq \sigma\zeta(1+\sigma)\leq
\sigma+1\)</span>,于是<span class="math inline">\(\lim_{\sigma\to
0+0}\sigma\zeta(1+\sigma)=1\)</span>.</p>
<p>而同理,见到:</p>
<p><span class="math display">\[
\zeta(1+\sigma)=1+\frac{1}{2^{1+\sigma}}+\cdots+\frac{1}{n^{1+\sigma}}+\sum_{k=n+1}^{\infty}\frac{1}{k^{1+\sigma}}
\]</span></p>
<p>而:</p>
<p><span class="math display">\[
1+\frac{1}{2^{1+\sigma}}+\cdots+\frac{1}{n^{1+\sigma}}+\frac{1}{\sigma}\frac{1}{(n+1)^\sigma}\\\leq\zeta(1+\sigma)\leq
\\1+\frac{1}{2^{1+\sigma}}+\cdots+\frac{1}{n^{1+\sigma}}+\frac{1}{\sigma}\frac{1}{n^\sigma}\\
\]</span></p>
<p>用上述不等式: <span class="math display">\[
1+\frac{1}{2^{1+\sigma}}+\cdots+\frac{1}{n^{1+\sigma}}+\frac{1}{\sigma}\left(\frac{1}{(n+1)^\sigma}-1\right)\\\leq\zeta(1+\sigma)-\frac{1}{\sigma}\leq
\\1+\frac{1}{2^{1+\sigma}}+\cdots+\frac{1}{n^{1+\sigma}}+\frac{1}{\sigma}\left(\frac{1}{n^\sigma}-1\right)\\
\]</span></p>
<p>两边对<span class="math inline">\(\sigma\to 0+0\)</span>取极限,见到:
<span class="math display">\[
1+\frac{1}{2}+\cdots+\frac{1}{n}-\ln(n+1)\\\leq \varliminf_{\sigma\to
0+0}(\zeta(1+\sigma)-\frac{1}{\sigma})\leq \varlimsup_{\sigma\to
0+0}(\zeta(1+\sigma)-\frac{1}{\sigma})\leq
\\1+\frac{1}{2}+\cdots+\frac{1}{n}-\ln(n)
\]</span></p>
<p>两边对<span class="math inline">\(n\)</span>取极限得到<span class="math inline">\(\lim_{\sigma\to
0+0}\zeta(1+\sigma)-\frac{1}{\sigma}=\gamma\)</span>.</p>
<h6><span id="example9">Example9</span></h6>
<p><span class="math inline">\(a_n&gt;0\)</span>,证明:若<span class="math inline">\(\varlimsup_{n\to\infty}a_n^{\frac{1}{\ln
n}}&lt;\frac{1}{e}\)</span>则收敛.若<span class="math inline">\(\varliminf_{n\to\infty}a_n^{\frac{1}{\ln
n}}&gt;\frac{1}{e}\)</span>则收敛.</p>
<p>只证前者,则存在<span class="math inline">\(p&gt;1\)</span>使得<span class="math inline">\(\varlimsup_{n\to\infty}a_n^{\frac{1}{\ln
n}}&lt;\frac{1}{e^p}\)</span>,两边取<span class="math inline">\(\ln\)</span>就做完了.</p>
<h6><span id="example10">Example10</span></h6>
<p><span class="math inline">\(a_n&gt;0\)</span>,证明:若<span class="math inline">\(\varliminf_{n\to\infty}\cfrac{\ln
\frac{1}{a_n}}{\ln n}&gt;1\)</span>则收敛.若<span class="math inline">\(\varlimsup_{n\to\infty}\cfrac{\ln
\frac{1}{a_n}}{\ln n}&lt;1\)</span>则收敛.</p>
<p>只证前者,考虑前者等价于<span class="math inline">\(\varlimsup_{n\to\infty}\ln a_n^{\frac{1}{\ln
n}}&lt;-1\)</span>,转化为Example9.</p>
<h4><span id="交错级数">交错级数</span></h4>
<p>考虑<span class="math inline">\(\sum (-1)^{n-1}
a_n\)</span>,其中<span class="math inline">\(a_n&gt;0\)</span>.</p>
<p>Leibniz定理:如果<span class="math inline">\(a_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>,则交错级数收敛.</p>
<p>考虑<span class="math inline">\(S_{2n}=(a_1-a_2)+(a_3-a_4)+\cdots\)</span>而<span class="math inline">\(S_{2n+1}=a_1-(a_2-a_3)-(a_4-a_5)-\cdots\)</span>,所以见到<span class="math inline">\(S_{2n}\)</span>单调上升,<span class="math inline">\(S_{2n+1}\)</span>单调下降.并且显然<span class="math inline">\(S_{2n}&lt;S_{2n+1}\)</span>.而且<span class="math inline">\(S_{2n+1}-S_{2n}=a_{2n+1}\to
0\)</span>,所以二者均收敛且极限相同极限相同.</p>
<p>当然,这也只是DA判别法的一个特例.</p>
<p>Leibniz定理还可以如此理解:由于后面的项正负抵消,我们发现:</p>
<p><span class="math display">\[
|\sum_{k=n}^\infty (-1)^ka_k|\leq a_n\to 0
\]</span></p>
<p>也就是后面的交错都可以被首项控制住.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(\sum (-1)^{n}\frac{\ln^2
n}{n}\)</span>的收敛性.</p>
<p>取<span class="math inline">\(f(x)=\frac{\ln^2 x}{x}\)</span>,则<span class="math inline">\(f&#39;=\frac{2\ln x-\ln^2
x}{x^2}\)</span>,显然当<span class="math inline">\(x\)</span>足够大的时候<span class="math inline">\(f&#39;(x)&lt;0\)</span>且<span class="math inline">\(f(+\infty)=0\)</span>,所以原式收敛.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(a_n&gt;0\)</span>,求证:若<span class="math inline">\(\varliminf
n(\frac{a_n}{a_{n+1}}-1)&gt;0\)</span>,则<span class="math inline">\(\sum (-1)^na_n\)</span>收敛.</p>
<p>考虑<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(\exists \epsilon &gt;0\)</span>,使得<span class="math inline">\(n(\frac{a_n}{a_{n+1}}-1)&gt;\epsilon\)</span>,也就是<span class="math inline">\(\frac{a_{n+1}}{a_n}&lt;\frac{n}{n+\epsilon}&lt;1\)</span>,这就能证明<span class="math inline">\(a_n\)</span>单调递减.下面只需要证明<span class="math inline">\(\lim a_n=0\)</span>即可.</p>
<p>而考虑取定<span class="math inline">\(N&gt;0\)</span>,对于<span class="math inline">\(n\geq N\)</span>,有<span class="math inline">\(\frac{a_n}{a_N}=\prod_{k=N}^{n-1}\frac{a_{k+1}}{a_{k}}\)</span>,<span class="math inline">\(a_N\)</span>是定死的,下面只需要证明后面那个乘积趋近于<span class="math inline">\(0\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\prod_{k=N}^{n-1}\frac{a_{k+1}}{a_{k}}\\
&lt;\prod_{k=N}^{n-1}\frac{n}{n+\epsilon}\\
=\prod_{k=N}^{n-1}\frac{1}{1+\frac{\epsilon}{n}}\\
\]</span></p>
<p>然而注意到:</p>
<p><span class="math display">\[
\prod_{k=N}^{n-1}\frac{1}{1+\frac{\epsilon}{n}}\\
\geq 1+\frac{\epsilon}{N}+\cdots+\frac{\epsilon}{n-1}\to \infty
\]</span></p>
<p>这就完事.</p>
<h4><span id="积分判别法">积分判别法</span></h4>
<p>取<span class="math inline">\(\omega_n=\sup_{[n,n+1]} f-\inf_{n,n+1}
f\geq 0\)</span>.我们声称若<span class="math inline">\(\sum
\omega_n&lt;\infty\)</span>,则<span class="math inline">\(\int_1^{\infty}f(x){\rm d}x\)</span>与<span class="math inline">\(\sum f(n)\)</span>收敛性相同.</p>
<p>考虑:</p>
<p><span class="math display">\[
\sum_{k=1}^n (f_k)-\int_1^{n+1}f(x){\rm d}x\\
=\sum_{k=1}^n\int_k^{k+1}(f(k)-f(x)){\rm d}x\\
\]</span></p>
<p>考虑证明右式绝对收敛,有:</p>
<p><span class="math display">\[
\sum_{k=1}^n\int_k^{k+1}|f(k)-f(x)|{\rm d}x\\
\leq \sum_{k=1}^n\int_k^{k+1}\omega_k{\rm d}x\\
=\sum_{k=1}^{n+1}\omega_k
\]</span></p>
<p>这就证毕.</p>
<p>问题又来到如何搞定<span class="math inline">\(\sum
\omega_n&lt;\infty\)</span>的条件,我们断言:如果<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f&#39;\)</span>可积且<span class="math inline">\(\int_1^{\infty}|f&#39;|{\rm
d}x&lt;\infty\)</span>则<span class="math inline">\(\sum
\omega_n&lt;\infty\)</span>.</p>
<p>对于<span class="math inline">\(\omega_n\)</span>,不妨<span class="math inline">\([n,n+1]\)</span>的上界在<span class="math inline">\(x_1\)</span>处取到,下界在<span class="math inline">\(x_2\)</span>处取到,于是:</p>
<p><span class="math display">\[
\omega_n=f(x_1)-f(x_2)\\
=|\int_{x_1}^{x_2}f&#39;{\rm d}x|\\
\leq |\int_{x_1}^{x_2}|f&#39;|{\rm d}x|\\
\leq \int_{n}^{n+1}|f&#39;|{\rm d}x\\
\]</span></p>
<p>于是<span class="math inline">\(\sum \omega\leq \int_1^{+\infty}
|f&#39;|{\rm d}x\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum \frac{\sin (n^\alpha
x)}{n^\beta}\)</span>的收敛性,其中<span class="math inline">\(\beta&gt;\alpha&gt;0,\alpha+\beta&gt;1\)</span>.</p>
<p>用积分判别法,考虑取<span class="math inline">\(f(t)=\frac{\sin
(t^\alpha x)}{t^\beta}\)</span>,考虑:</p>
<p><span class="math display">\[
f&#39;(t)=\frac{x\alpha t^{\alpha-1+\beta}\cos(t^\alpha x)-\beta
t^{\beta-1}\sin(t^\alpha x)}{t^{2\beta}}
\]</span></p>
<p>逐项观察,都是<span class="math inline">\(O(\frac{1}{t^{\beta-\alpha+1}})\)</span>级别,这样<span class="math inline">\(\int |f&#39;|{\rm d}t\)</span>就收敛了.</p>
<p>那就只需要看积分的收敛性,取<span class="math inline">\(s=t^\alpha\)</span>考察:</p>
<p><span class="math display">\[
\int_1^{\infty}f(t){\rm d}t=\int_1^{\infty}\frac{\sin (t^\alpha
x)}{t^\beta}{\rm d}t\\
=\int_1^{\infty}\frac{\sin (s
x)\frac{1}{\alpha}s^{\frac{1}{\alpha}-1}}{s^\frac{\beta}{\alpha}}{\rm
d}s\\
\]</span></p>
<p>后者用DA判法知道收敛.</p>
<h4><span id="级数的交换顺序">级数的交换顺序</span></h4>
<p>定义<span class="math inline">\(\mathbb{N}_+\)</span>的一个重排<span class="math inline">\(f\)</span>,当且仅当<span class="math inline">\(f(1),f(2),\cdots\)</span>这个数列中,每个正整数都恰好出现一次.</p>
<p>我们声称正项级数满足:<span class="math inline">\(\sum a_n=\sum
a_{f(n)}\)</span>.</p>
<p>如何证明呢?</p>
<p>当<span class="math inline">\(\sum
a_n&lt;\infty\)</span>的时候,考虑设<span class="math inline">\(A_n=\sum_{k=1}^n a_k,B_n=\sum_{k=1}^n
a_{f(k)}\)</span>.考虑取<span class="math inline">\(N_n=\max_{1\leq
k\leq n} f(k)\)</span>,那就有:</p>
<p><span class="math display">\[
B_n=\sum_{k=1}^n a_{f(k)}\leq A_{N_n}\leq \sum_{1}^{\infty} a_n
\]</span></p>
<p>于是<span class="math inline">\(B_n\)</span>当然是收敛的,并且<span class="math inline">\(\sum a_{f(n)}\leq \sum a_n\)</span>,而如果<span class="math inline">\(a_{f(n)}\)</span>是<span class="math inline">\(a_n\)</span>的重排,那么反之,<span class="math inline">\(a_n\)</span>是<span class="math inline">\(a_{f(n)}\)</span>的重排,于是<span class="math inline">\(\sum a_{f(n)}\geq  \sum
a_n\)</span>,这就证明了二者相同.</p>
<p>既如此,如果<span class="math inline">\(\sum
a_n\)</span>发散的时候,就可以反证法证明<span class="math inline">\(\sum
a_{f(n)}\)</span>不可能收敛.这样就完成了证明.</p>
<p>下面我们证明,如果<span class="math inline">\(\sum
a_n\)</span>绝对收敛,换言之<span class="math inline">\(\sum
|a_n|&lt;\infty\)</span>,那么仍有<span class="math inline">\(\sum
a_n=\sum a_{f(n)}\)</span>.</p>
<p>考虑取<span class="math inline">\(a_n^+=\frac{|a_n|+a_n}{2},a_n^-=\frac{|a_n|-a_n}{2}\)</span>.那考虑<span class="math inline">\(0\leq a_n^+\leq |a_n|,0\leq a_n^-\leq
|a_n|\)</span>,所以它们当然都绝对收敛,那当然有:</p>
<p><span class="math display">\[
\sum a_n=\sum(a_n^+-a_n^-)\\
=(\sum a_n^+) - (\sum a_n^-)
\]</span></p>
<p>而后者当然可以随意重排.</p>
<p>那么对于条件收敛呢?我们有<strong>黎曼重排定理</strong>:如果<span class="math inline">\(\sum a_n\)</span>条件收敛,则<span class="math inline">\(\forall B\leq A\)</span>,其中<span class="math inline">\(A,B\in \mathbb{R}\cup\{\pm
\infty\}\)</span>,则存在重排<span class="math inline">\(f\)</span>,令<span class="math inline">\(S_n=\sum_{k=1}^n a_{f(k)}\)</span>,有:</p>
<p><span class="math display">\[
\varliminf S_n=B,\varlimsup S_n=A
\]</span></p>
<p>为证明此,考虑设<span class="math inline">\(I_+=\{n\in
\mathbb{N}_+\mid a_n\geq 0\}=\{n_1&lt;n_2\cdots\}\)</span>,<span class="math inline">\(I_-\)</span>类似设出.</p>
<p>容易见到首先<span class="math inline">\(\lim a_n\to
0\)</span>,并且<span class="math inline">\(\sum_{n\in
I_+}a_n=+\infty,\sum_{n\in I_-}a_n=-\infty\)</span>.</p>
<p>考虑先从<span class="math inline">\(I_+\)</span>里取数,然后不断加加加加加直到超过<span class="math inline">\(A\)</span>,由于正的部分相加是正无穷,这当然能做到,然后就继续从<span class="math inline">\(I_-\)</span>里取数开始回退,退退退退到<span class="math inline">\(B\)</span>之下,再重复上述过程.由于<span class="math inline">\(a_n\to 0\)</span>,这玩意当然会满足条件.</p>
<p>那么如果<span class="math inline">\(A\)</span>是正无穷呢?那没关系,我就每次加数的时候变化<span class="math inline">\(A\)</span>,第一次个循环令<span class="math inline">\(A=1\)</span>,第二次令<span class="math inline">\(A=2\)</span>,以此类推.由此见上述命题的合理性.而且具体的论证过程只需要对这上面写抽象语言就行.</p>
<p>可是,难道一般的级数就真的不能交换顺序了嘛?事实上使用柯西准则,我们可以证明如果重排是局部的,或者说<span class="math inline">\(\exists M&gt;0,\forall n,|n-f(n)|\leq
M&lt;\infty\)</span>,换言之交换的距离有上界,那交换后敛散性不变.</p>
<p>这个怎么证明呢?首先如果原级数收敛的话,用柯西准则,因为通项趋于<span class="math inline">\(0\)</span>,所以往外扩张适当长度(实际上就是<span class="math inline">\(M\)</span>)应当无影响.如果原级数发散的话,如果通项还是不趋于<span class="math inline">\(0\)</span>那当然还是完蛋,否则的话还可以用上面的证明.这就证毕了.</p>
<h6><span id="example11">Example11</span></h6>
<p><span class="math inline">\(a_n&gt;0\)</span>,当<span class="math inline">\(\sum
\frac{1}{a_n}&lt;\infty\)</span>的时候,求证<span class="math inline">\(\sum \frac{n}{\sum_{k=1}^n
a_k}&lt;\infty\)</span>.</p>
<p>首先考虑<span class="math inline">\(\{a_n\}\)</span>单增的情况,如果不单增的话,可以直接对其进行排序.</p>
<p>考虑<span class="math inline">\(\frac{2n}{\sum_{k=1}^{2n}
a_k}&lt;\frac{2n}{na_n}=\frac{2}{a_n}\)</span>,同理<span class="math inline">\(\frac{2n-1}{\sum_{k=1}^{2n}
a_k}&lt;\frac{2n-1}{na_n}&lt;\frac{2}{a_n}\)</span>,于是证毕.</p>
<h4><span id="级数的乘法">级数的乘法</span></h4>
<p>考虑<span class="math inline">\((\sum a_j)(\sum b_k)=\sum
a_jb_k\)</span>,首要的问题在于如何指定后者的求和顺序.</p>
<p>柯西策略是,考虑取<span class="math inline">\(c_n=\sum_{j+k=n+1}a_jb_k\)</span>,然后取原式顺序为<span class="math inline">\(\sum
c_n\)</span>.此好处是可以求解生成函数乘积,<span class="math inline">\((\sum a_jx^j)(\sum b_kx^k)\)</span>.</p>
<p>矩形策略是,考虑取<span class="math inline">\(c_n=\sum_{\max(j,k)=n}a_jb_k\)</span>,然后取原式顺序为<span class="math inline">\(\sum c_n\)</span>.此好处是它的求和天然是<span class="math inline">\((\sum_{j=1}^n a_j)(\sum_{k=1}^n
b_k)\)</span>的极限.所以此方法天然有如果<span class="math inline">\(\sum
a_j=A,\sum b_k=B\)</span>,则<span class="math inline">\(\sum
c=AB\)</span>.</p>
<p>接下来我们证明,如果<span class="math inline">\(\sum a\)</span>和<span class="math inline">\(\sum
b\)</span>都绝对收敛,那它们的乘积任意排列都是相等的.换言之只要双重指标集合<span class="math inline">\(\{(j_i,k_i)\}=\{(j,k)\}\)</span>那就都收敛于同一值.</p>
<p>证明策略类似,取<span class="math inline">\(N_n=\max_{1\leq i\leq
n}(j_i,k_i)\)</span>,那么当然有:</p>
<p><span class="math display">\[
\sum_{i=1}^n|a_{j_i}b_{k_i}|\leq
(\sum_{j=1}^{N_n}|a_{j}|)(\sum_{k=1}^{N_n}|b_{k}|)
\]</span></p>
<p>那当然就绝对收敛,再类似之前的可以证明其与顺序无关,这个时候用矩形策略就可以知道最终就收敛于<span class="math inline">\((\sum a)(\sum b)\)</span>.</p>
<p>如果是条件收敛,矩形和当然没问题,仍然收敛,难点当然在于柯西和何时收敛?我们声称:如果<span class="math inline">\(\sum a_n\)</span>收敛,<span class="math inline">\(\sum
|b_n|&lt;\infty\)</span>,也就是一个收敛一个绝对收敛,我们就能推出柯西和是收敛的.</p>
<p>考虑设矩形法的<span class="math inline">\(u_k=\sum_{\max(i,j)=k}a_ib_j\)</span>,柯西法的<span class="math inline">\(c_k=\sum_{i+j=k+1}a_ib_j\)</span>,考虑求:</p>
<p><span class="math display">\[
|\sum_{k=1}^n u_k-c_k|\\
=|\sum_{i_j&gt;n+1,i\leq n,j\leq n}a_ib_j|\\
\leq \sum_{i=2}^n|b_i||\sum_{j=n-i+2}^n a_j|\\
=\sum_{i=2}^N|b_i||\sum_{j=n-i+2}^n
a_j|+\sum_{i=N+1}^n|b_i||\sum_{j=n-i+2}^n a_j|
\]</span></p>
<p>接下来用柯西收敛原理,先取<span class="math inline">\(N\)</span>,只要<span class="math inline">\(N\)</span>足够大,由于<span class="math inline">\(|\sum_{j=n-i+2}^n
a_j|\)</span>当然是有界的,因为<span class="math inline">\(\sum
a\)</span>收敛,只要<span class="math inline">\(N\)</span>足够大,不管<span class="math inline">\(n\)</span>如何,<span class="math inline">\(\sum_{i=N+1}^n|b_i|\)</span>用柯西收敛原理就足够小.这样后半项就解决了.</p>
<p>前半项同理,在<span class="math inline">\(N\)</span>取定的时候<span class="math inline">\(\sum_{i=2}^N|b_i|\)</span>就取定有界了.而只要在此基础上使得<span class="math inline">\(n\)</span>尽可能大,<span class="math inline">\(|\sum_{j=n-i+2}^n
a_j|\)</span>用柯西收敛原理就控制住了,于是整体就很小.那就证明了此时柯西和恰好就是矩形和.</p>
<p>一般的柯西和没有这么好的结论,但其实证明可以类似上面,具体地,我们取<span class="math inline">\(A_n=\sum_{k=1}^na_k,B_n=\sum_{k=1}^nb_k\)</span>并且<span class="math inline">\(\lim A,\lim B\)</span>都存在,取柯西和<span class="math inline">\(c_n=\sum_{k=1}^n
a_kb_{n-k+1}\)</span>,我们断言<span class="math inline">\(C_n=\sum_{k=1}^n c_k\)</span>收敛当且仅当极限<span class="math inline">\(\lim_{n\to
\infty}\sum_{k=1}^na_k\sum_{j=n-k+1}^nb_j\)</span>存在.</p>
<p>原因是:</p>
<p><span class="math display">\[
\sum_{k=1}^na_k\sum_{j=n-k+1}^nb_j\\
=\sum_{k=1}^na_k(B_n-B_{n-k})\\
=B_nA_n-(\sum_{k=1}^{n-1}a_kB_{n-k})\\
=B_nA_n-C_{n-1}
\]</span></p>
<p>这就证毕,而且当然见到只有上述极限为<span class="math inline">\(0\)</span>的时候,柯西和才会有<span class="math inline">\(\lim C=(\lim A)(\lim B)\)</span>.</p>
<h4><span id="无穷乘积">无穷乘积</span></h4>
<p>对于数列<span class="math inline">\(\{a_n\}\)</span>,设<span class="math inline">\(A_n=\prod_{k=1}^na_k\)</span>,若<span class="math inline">\(\lim_{n\to\infty}A_n\)</span>存在且非零,则称<span class="math inline">\(\prod_{k=1}^{+\infty}a_k\)</span>收敛.为什么这里要求非零呢?因为我们希望类似无穷和,这里去掉前有限项后,敛散性不变.这就要求我们最好判掉零的情况.如若其极限为<span class="math inline">\(0\)</span>,则仍称其发散,但有的时候发散到零也会有一些性质,到时我们会单独讨论.</p>
<p>既然如此,不妨设<span class="math inline">\(a_n\ne
0\)</span>.有以下性质:</p>
<ol type="1">
<li>若<span class="math inline">\(\prod a_n\)</span>收敛,则<span class="math inline">\(\lim a_n=1\)</span>.既然如此,<span class="math inline">\(a_n\)</span>从某一项开始就满足<span class="math inline">\(a_n&gt;0\)</span>.之后不妨干脆设<span class="math inline">\(a_n&gt;0\)</span>.</li>
<li><span class="math inline">\(A_n\)</span>有非<span class="math inline">\(0\)</span>极限当且仅当<span class="math inline">\(\ln A_n\)</span>有极限.</li>
<li>柯西收敛准则:<span class="math inline">\(A_n\)</span>有非零极限的必要条件是<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall N\leq
n\leq m\)</span>,<span class="math inline">\(|1-\prod_{k=n}^m
a_k|&lt;\epsilon\)</span>.特别地,如果<span class="math inline">\(\forall
a_n\ne 0\)</span>,则上式为充要条件.</li>
</ol>
<p>(1)(2)显然.</p>
<p>(3)的话也比较显然.</p>
<p>总之,既然<span class="math inline">\(\lim a_n\to
1\)</span>,不妨干脆设其为<span class="math inline">\(1+a_n\)</span>,其中<span class="math inline">\(\lim a_n=0\)</span>,从而原本要研究的<span class="math inline">\(\prod (1+a_n)\)</span>可以转为研究<span class="math inline">\(\sum \ln(1+a_n)\)</span>.</p>
<ol type="1">
<li>当<span class="math inline">\(a_n\)</span>定号的时候,<span class="math inline">\(\sum \ln(1+a_n)\)</span>和<span class="math inline">\(\sum a_n\)</span>的敛散性相同.</li>
<li>当<span class="math inline">\(a_n\)</span>不定号的时候,若<span class="math inline">\(\sum a_n^2&lt;\infty\)</span>,则<span class="math inline">\(\sum \ln(1+a_n)\)</span>和<span class="math inline">\(\sum a_n\)</span>的敛散性相同.同理如若<span class="math inline">\(\sum
a_n^2\)</span>发散,则上述两个级数至少一个发散.</li>
<li><span class="math inline">\(|\sum \ln(1+a_n)|\)</span>和<span class="math inline">\(\sum |a_n|\)</span>的敛散性相同.</li>
</ol>
<p>(1)是因为<span class="math inline">\(\lim
\frac{\ln(1+a_n)}{a_n}=1\)</span>.</p>
<p>(2)是因为<span class="math inline">\(a_n-\ln(1+a_n)\)</span>可以被<span class="math inline">\(a_n^2\)</span>控制住,原因是<span class="math inline">\(a_n\to 0\)</span>,换言之存在<span class="math inline">\(c_1,c_2\)</span>使得<span class="math inline">\(c_1 x^2&lt;a_n-\ln(1+a_n)&lt;c_2
x^2\)</span>,只需要对<span class="math inline">\(0\)</span>附近做个简单放缩.既然它们的差收敛,那它们当然敛散性相同.</p>
<p>(3)还是因为<span class="math inline">\(\lim
\frac{|\ln(1+x)|}{|x|}=1\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(|x|&lt;1\)</span>的时候,求<span class="math inline">\(\prod_{k=1}(1+x^{2^{k-1}})\)</span>的极限.</p>
<p>容易见到<span class="math inline">\(A_n=\prod_{k=1}^n(1+x^{2^{k-1}})=\frac{1-x^{2^n}}{1-x}\)</span>,这样自然就收敛了.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\prod_{k=1}\cos\frac{\varphi}{2^n}\)</span>.</p>
<p>当<span class="math inline">\(\varphi\ne 0\)</span>的时候,考虑<span class="math inline">\(A_n=\prod_{k=1}^n\cos\frac{\varphi}{2^n}=\frac{\sin
\varphi}{2^n\sin\frac{\varphi}{2^n}}\)</span>.虽然这里当<span class="math inline">\(\varphi=2^k\pi\)</span>的时候会有若干项分母为<span class="math inline">\(0\)</span>,但由于我们可以干脆去掉这前几项,而只看后几项分母均不为<span class="math inline">\(0\)</span>,当然收敛于<span class="math inline">\(\frac{\sin \varphi}{\varphi}\)</span>.</p>
<p>而<span class="math inline">\(\varphi=0\)</span>的时候每一项都是<span class="math inline">\(1\)</span>,乘起来仍然收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑<span class="math inline">\(\Gamma(x)=\frac{1}{x}\prod_{n=1}^{\infty}\frac{(1+\frac{1}{n})^x}{1+\frac{x}{n}}\)</span>敛散性,其中<span class="math inline">\(x\ne 0,-1,-2,\cdots\)</span>.</p>
<p>直接泰勒展开,见到:</p>
<p><span class="math display">\[
\frac{(1+\frac{1}{n})^x}{1+\frac{x}{n}}\\
=(1+\frac{x}{n}+\frac{x(x-1)}{2n^2}+o(\frac{1}{n^2}))(1-\frac{x}{n}+\frac{x^2}{n^2}+o(\frac{1}{n^2}))\\
=1+\frac{x(x-1)}{2n^2}+o(\frac{1}{n^2})
\]</span></p>
<p>这就绝对收敛了.</p>
<p>而我们观察<span class="math inline">\(A_n\)</span>,有:</p>
<p><span class="math display">\[
A_n=\prod_{k=1}^{n}\frac{(\frac{k+1}{k})^x}{1+\frac{x}{k}}\\
=\frac{(n+1)^x}{x(1+\frac{x}{1})\cdots(1+\frac{x}{n})}\\
=(\frac{n+1}{n})^x\frac{n!n^x}{x^{\overline{n+1}}}\\
\]</span></p>
<p>于是见到:</p>
<p><span class="math display">\[
\frac{\Gamma(x+1)}{\Gamma(x)}=\lim_{n\to \infty}\frac{nx}{x+1+n}=x
\]</span></p>
<p>所以<span class="math inline">\(\Gamma(x+1)=x\Gamma(x)\)</span>,而且<span class="math inline">\(\Gamma(1)=1\)</span>,所以<span class="math inline">\(\Gamma(n)=n!\)</span>,这实际上是阶乘函数的一个推广.</p>
<p>而此时有<span class="math inline">\(\Gamma(x+1)=x
\Gamma(x)=\prod_{k=1}^\infty\frac{(1+\frac{1}{n})^x}{1+\frac{x}{n}}\)</span>.</p>
<p>而观察这个级数:</p>
<p><span class="math display">\[
\prod_{n=1}^\infty\frac{e^{\frac{1}{n}} }{1+\frac{1}{n}}\\
=\frac{e^{1+\frac{1}{2}+\cdots +\frac{1}{n}}}{n+1}\\
=\frac{e^{\ln n+\gamma+c_n}}{n+1}
\to e^\gamma
\]</span></p>
<p>其中<span class="math inline">\(\gamma\)</span>是欧拉常数,误差项<span class="math inline">\(c_n=H_n-\ln n-\gamma \to 0\)</span>.</p>
<p>从而观察到:</p>
<p><span class="math display">\[
e^{\gamma x}\Gamma(x+1)\\
=\prod_{n=1}^\infty \frac{e^{\frac{x}{n}}}{1+\frac{x}{n}}
\]</span></p>
<p>从而<span class="math inline">\(\frac{1}{\Gamma(x+1)}=e^{\gamma
x}\prod_{n=1}^\infty (1+\frac{x}{n})e^{-\frac{x}{n}}\)</span>.</p>
<p>在此基础上,如若设<span class="math inline">\(b_n=\frac{n!
n^x}{x^{\overline{n+1}}}\)</span>.容易见到<span class="math inline">\(\lim b_n=\lim A_n=Gamma(x)\)</span>,而观察到:</p>
<p><span class="math display">\[
\frac{b_{n+1}}{b_n}=\frac{(1+\frac{1}{n})^{x+1}}{1+\frac{x+1}{n}}\\
=1+\frac{x(x+1)}{2n^2}+o(\frac{1}{n^2})\\
\to 1
\]</span></p>
<p>而且如若<span class="math inline">\(x(x+1)&gt;0\)</span>,并且取<span class="math inline">\(n\)</span>足够大,则上式大于<span class="math inline">\(1\)</span>,反之上式小于<span class="math inline">\(1\)</span>.因此当<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(b_n\)</span>单调有界(原因是其极限存在).</p>
<p>因此还可以得到结论:<span class="math inline">\(\sum \frac{n!
a_n}{x^{\overline{n+1}} }\)</span>和<span class="math inline">\(\sum
\frac{a_n}{n^x}\)</span>敛散性相同,其中<span class="math inline">\(x\ne
0,-1,-2,\cdots\)</span>.原因只是因为这俩的比值恰好是<span class="math inline">\(b_n\)</span>单调有界,根据DA判别法知道二者同敛散.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum_{n=1}^\infty
\frac{(nx)^n}{n!}\)</span>的收敛性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\frac{a_{n+1}}{a_n}=(\frac{n+1}{n})^n x\to ex
\]</span></p>
<p>根据比值判法,当<span class="math inline">\(|x|&lt;\frac{1}{e}\)</span>的时候绝对收敛,而当<span class="math inline">\(|x|&gt;\frac{1}{e}\)</span>的时候发散,问题只在于<span class="math inline">\(|x|=\frac{1}{e}\)</span>的时候如何.</p>
<p>当<span class="math inline">\(x=\frac{1}{e}\)</span>的时候,使用拉贝判法:</p>
<p><span class="math display">\[
n(\frac{a_n}{a_{n+1}}-1)=n((1-\frac{1}{n+1})^n e-1)\\
=n(e^{n\ln(1-\frac{1}{n+1})+1}-1)\\
=n(e^{n(-\frac{1}{n+1}-\frac{1}{2(n+1)^2}+o(\frac{1}{n^2}))+1}-1)\\
=n(e^{\frac{1}{n+1}-\frac{n}{2(n+1)^2}+o(\frac{1}{n})}-1)\\
=n(\frac{1}{n+1}-\frac{n}{2(n+1)^2}+o(\frac{1}{n}))-1\\
\to \frac{1}{2}&lt;1
\]</span></p>
<p>所以发散.</p>
<p>当<span class="math inline">\(x=-\frac{1}{e}\)</span>的时候,使用DA判法:应当见到<span class="math inline">\(a_n=(-1)^n|a_n|\)</span>,此时<span class="math inline">\(|a_n|\)</span>单调递减且趋于<span class="math inline">\(0\)</span>,用DA判法知道其收敛.</p>
<p>所以条件收敛.</p>
<h6><span id="example5">Example5</span></h6>
<p>求证<span class="math inline">\(\sum
a_n(x^2-1)(x^2-2^2)\cdots(x^2-n^2)\)</span>对<span class="math inline">\(\forall x\notin
\mathbb{Z}\)</span>,其都有相同的敛散性.就是对于一个确定的<span class="math inline">\(\{a_n\}\)</span>,对所有的<span class="math inline">\(x\)</span>,要么都收敛,要么都发散.</p>
<p>考虑设<span class="math inline">\(f_n(x)=(x^2-1)(x^2-2^2)\cdots(x^2-n^2)\)</span>,观察到:</p>
<p><span class="math display">\[
\frac{f_n(x)}{f_n(x_0)}=\frac{(x^2-1)(x^2-2^2)\cdots(x^2-n^2)}{(x_0^2-1)(x_0^2-2^2)\cdots(x_0^2-n^2)}
\]</span></p>
<p>这当然是个无穷乘积,观察到<span class="math inline">\(\frac{x^2-n^2}{x_0^2-n^2}=1+\frac{x^2-x_0^2}{x_0^2-n^2}=1+O(\frac{1}{n^2})\)</span>,所以<span class="math inline">\(\lim_{n\to \infty}
\frac{f_n(x)}{f_n(x_0)}\)</span>存在且非零.</p>
<p>而且,当<span class="math inline">\(n\)</span>足够大的时候,或者更进一步说<span class="math inline">\(|n|&gt;\max(|x|,|x_0|)\)</span>的时候<span class="math inline">\(\frac{f_n(x)}{f_n(x_0)}\)</span>当然就定号了,而且<span class="math inline">\(\frac{x^2-n^2}{x_0^2-n^2}=1+\frac{x^2-x_0^2}{x_0^2-n^2}\)</span>,其与<span class="math inline">\(1\)</span>比较只取决于<span class="math inline">\(x^2-x_0^2\)</span>,这就意味着<span class="math inline">\(\frac{f_n(x)}{f_n(x_0)}\)</span>在<span class="math inline">\(n\)</span>足够大的时候是单调有界的,于是DA判法知道同敛散.</p>
<h6><span id="example6">Example6</span></h6>
<p>求证<span class="math inline">\(\sin
x=x\prod_{k=1}^{\infty}(1-\frac{x^2}{k^2\pi^2})\)</span>.</p>
<p>先看<span class="math inline">\(\sin x=0\)</span>的根,假设其根为<span class="math inline">\(u+iv\)</span>,考虑:</p>
<p><span class="math display">\[
\sin x=\frac{e^{ix}-e^{-ix}}{2i}=0\\
e^{2ix}=1\\
e^{2iu-2v}=1\\
|e^{2iu-2v}|=1\\
e^{-2v}=1\\
v=0
\]</span></p>
<p>所以其只有实根,用多项式理论知道如若<span class="math inline">\(\sin
x\)</span>的根只有<span class="math inline">\(2k\pi\)</span>,应该有:</p>
<p><span class="math display">\[
\sin x=cx\prod_{k=1}^{\infty}(1-\frac{x^2}{k^2\pi^2})
\]</span></p>
<p>容易见到这个无穷乘积的确收敛,而<span class="math inline">\(x\to
0\)</span>的时候<span class="math inline">\(\frac{\sin
x}{x}=1\)</span>,所以<span class="math inline">\(c=1\)</span>.</p>
<p>那么考虑<span class="math inline">\(\sin x\)</span>的泰勒展开,有:</p>
<p><span class="math display">\[
1-\frac{x^2}{6}+\cdots=\prod_{k=1}(1-\frac{x^2}{k^2\pi^2})\\
=1-(\frac{1}{\pi^2}\frac{1}{k^2})x^2+\cdots
\]</span></p>
<p>这就能知道<span class="math inline">\(\sum_{k=1}^\infty
\frac{1}{k^2}=\frac{\pi^2}{6}\)</span>.</p>
<p>然而上述的多项式理论还是太过粗糙,下面提供一种更加严谨的证明:</p>
<p>我们有欧拉公式:</p>
<p><span class="math display">\[
(\cos x + i\sin x)^{2n+1}=\cos(2n+1)x+i\sin(2n+1)x\\
\]</span></p>
<p>然而左侧可以使用二项式定理展开,有:</p>
<p><span class="math display">\[
(\cos x + i\sin x)^{2n+1}=\sum \binom{2n+1}{k}\cos^k x(i\sin x)^{2n+1-k}
\]</span></p>
<p>容易见到为了贡献虚部,<span class="math inline">\(k\)</span>必须是偶数,那此时<span class="math inline">\(\cos^k x=(1-\sin^2
x)^{\frac{k}{2}}\)</span>,总之,我们发现应该存在一个<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(P_n\)</span>,使得:</p>
<p><span class="math display">\[
\sin(2n+1)x=(\sin x)P_n(\sin^2 x)\\
\]</span></p>
<p>这个多项式的根应该怎么取呢?考虑当<span class="math inline">\(\varphi_k=\frac{k\pi}{2n+1},1\leq k\leq
n\)</span>的时候,左侧为<span class="math inline">\(0\)</span>,而右侧<span class="math inline">\(\sin
\varphi_k\)</span>不该为<span class="math inline">\(0\)</span>,更进一步地,<span class="math inline">\(\sin ^2
\varphi_k\)</span>两两不同,这就知道它们确实是<span class="math inline">\(P_n\)</span>的<span class="math inline">\(n\)</span>个根.同时见到<span class="math inline">\(P(0)=\lim_{x\to 0}P_n(\sin ^2
x)=2n+1\)</span>,从而我们已经能唯一确定这个有限项多项式<span class="math inline">\(P_n(x)=(2n+1)\prod_{k=1}^n(1-\frac{x}{\sin^2
\varphi_k})\)</span>.</p>
<p>接下来,将原本上式中的<span class="math inline">\(x\)</span>换成<span class="math inline">\(\frac{x}{2n+1}\)</span>,我们就能得到:</p>
<p><span class="math display">\[
\sin
x=(2n+1)\sin(\frac{x}{2n+1})\prod_{k=1}^n(1-\frac{\sin^2\frac{x}{2n+1}}{\sin^2
\varphi_k})
\]</span></p>
<p>这里已经十分接近我们想要的答案了,但是这个项数和<span class="math inline">\(n\)</span>一起增大,策略当然是大小步极限,考虑取:</p>
<p><span class="math display">\[
U_m=(2n+1)\sin\frac{x}{2n+1}\prod_{k=1}^m(1-\frac{\sin^2\frac{x}{2n+1}}{\sin^2
\varphi_k})\\
V_m=\prod_{k=m+1}^n(1-\frac{\sin^2\frac{x}{2n+1}}{\sin^2 \varphi_k})\\
\]</span></p>
<p>取定<span class="math inline">\(m\)</span>,当然总能取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(U_m\to
x\prod_{k=1}^m(1-\frac{x^2}{k^2\pi^2})\)</span>.</p>
<p>而用柯西准则,当<span class="math inline">\(m\)</span>足够大的时候,如果能证明<span class="math inline">\(V_m\to 1\)</span>就完事了.我们考虑:</p>
<p><span class="math display">\[
1\geq V_m\geq \prod_{k=m+1}^\infty(1-\frac{\sin^2\frac{x}{2n+1}}{\sin^2
\varphi_k})\\
\]</span></p>
<p>而回忆到当<span class="math inline">\(\sin^2 x\leq
x^2\)</span>恒成立,在<span class="math inline">\(x\in
[0,\frac{\pi}{2}]\)</span>的时候,<span class="math inline">\(\sin x\geq
\frac{2}{\pi}x\)</span>也成立,所以:</p>
<p><span class="math display">\[
V_m\geq \prod_{k=m+1}^\infty(1-\frac{\sin^2\frac{x}{2n+1}}{\sin^2
\varphi_k})\\
\geq \prod_{k=m+1}^\infty(1-\frac{x^2}{4k^2})\\
\]</span></p>
<p>此时回忆到<span class="math inline">\(\prod_{k=1}^\infty(1-\frac{x^2}{4k^2})\)</span>是收敛的,所以由柯西准则,当<span class="math inline">\(m\)</span>足够大的时候,<span class="math inline">\(\prod_{k=m+1}^\infty(1-\frac{x^2}{4k^2})\)</span>趋近于<span class="math inline">\(1\)</span>,这就证毕了.</p>
<h3><span id="函数项数列">函数项数列</span></h3>
<p>也就是每一项都是一个函数的数列,假设定义域在<span class="math inline">\(I\subseteq \mathbb{R}\)</span>上,写作<span class="math inline">\(\{f_n(x)\}\)</span>.此时对于一个固定的<span class="math inline">\(x_0\in I\)</span>,则<span class="math inline">\(\{f_n(x_0)\}\)</span>就是一个普通的数列.当然不一定<span class="math inline">\(I\)</span>中的每一个<span class="math inline">\(x_0\)</span>都收敛,我们将<strong>收敛点</strong>的集合称为函数项级数的<strong>收敛域</strong>,其它的点称为<strong>发散点</strong>,发散点组成的集合称为<strong>发散域</strong>.</p>
<p>对于收敛域,直接记<span class="math inline">\(f(x)=\lim_{n\to
\infty}f_n(x)\)</span>,我们将这里的<span class="math inline">\(f(x)\)</span>就是这个函数列的<strong>极限函数</strong>.既然有了极限就可以定义级数,也就是可以定义<span class="math inline">\(S_n=\sum_{k=1}^nf_k(x)\)</span>,然后取其极限拿到<span class="math inline">\(\sum_{k=1}^\infty f_n(x)=S(x)\)</span>.</p>
<p>我们要解决的问题大概有以下三个:</p>
<ol type="1">
<li>如果<span class="math inline">\(f_n\)</span>均是连续的,那么要求什么条件,可以满足<span class="math inline">\(f\)</span>连续.</li>
<li>如果<span class="math inline">\(f_n\)</span>均是黎曼可积的,那么要求什么条件,可以满足<span class="math inline">\(f\)</span>黎曼可积并且<span class="math inline">\(\lim \int f_n=\int
f\)</span>,也就是极限和积分什么时候可以交换顺序.</li>
<li>如果<span class="math inline">\(f_n\)</span>均可导,那么什么时候<span class="math inline">\(f\)</span>也可导,并且<span class="math inline">\(\lim
f_n&#39;=f&#39;\)</span>,也就是极限和导数什么时候可以交换顺序.</li>
</ol>
<p>如果不加条件,上述三条全都是不满足的,下述Example会给出若干例子.</p>
<h6><span id="example1">Example1</span></h6>
<p>取<span class="math inline">\(f_n(x)=x^n,x\in
[0,1]\)</span>,求其极限函数.</p>
<p>显然<span class="math inline">\(f(x)=\begin{cases}1&amp;x=1\\0&amp;\text{otherwise}\end{cases}\)</span>,由此可以见到,连续函数的极限函数不一定连续.</p>
<h6><span id="example2">Example2</span></h6>
<p>取<span class="math inline">\(f_n(x)=\begin{cases}1&amp;n!x\in
\mathbb{Z}\\0&amp;\text{otherwise}\end{cases}\)</span>,求其极限函数.</p>
<p>显然是迪利克雷函数.</p>
<p>则<span class="math inline">\(f_n(x)\)</span>只有有限个间断点,容易见到其黎曼可积,然而迪利克雷函数并不黎曼可积.可积函数的极限函数不一定可积.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f_n(x)=nx(1-x^2)^n,x\in
[0,1]\)</span>,求其极限函数.</p>
<p>容易见到<span class="math inline">\(\lim
f_n(x)=0\)</span>,也就是这个函数处处收敛到<span class="math inline">\(0\)</span>.</p>
<p>然而,对其求积分:</p>
<p><span class="math display">\[
\int_0^1 f_n(x){\rm d}x=\int_0^1 nx(1-x^2)^n{\rm d}x\\
=-\frac{n}{2}\int_0^1(1-x^2)^n{\rm d}(1-x^2)\\
=-\frac{n}{2(n+1)}(1-x^2)^{n+1}|_0^1\\
=\frac{n}{2(n+1)}\to \frac{1}{2}
\]</span></p>
<p>由此见到,极限函数的积分不一定等于积分的极限.极限和积分不一定可交换.</p>
<h6><span id="example4">Example4</span></h6>
<p>考虑<span class="math inline">\(f_n(x)=\begin{cases}2n^2x\\x\in[0,\frac{1}{2n}]\\2n^2(x-\frac{1}{n})&amp;x\in(\frac{1}{2n},\frac{1}{n}]\\0&amp;\text{otherwise}\end{cases}\)</span>,也就是这个函数在<span class="math inline">\(\frac{1}{2n}\)</span>处高度为<span class="math inline">\(n\)</span>,底长为<span class="math inline">\(\frac{1}{n}\)</span>的一个小三角形.求其极限函数.</p>
<p>对于每一个点,这个函数当然逐点收敛于<span class="math inline">\(0\)</span>.然而也可以见到,这个函数的积分对于每一个<span class="math inline">\(n\)</span>来说都是<span class="math inline">\(\frac{1}{2}\)</span>.</p>
<p>再次说明了极限函数的积分不一定等于积分的极限.极限和积分不一定可交换.</p>
<h6><span id="example5">Example5</span></h6>
<p>考虑<span class="math inline">\(f_n(x)=\frac{\sin(nx)}{\sqrt
n}\)</span>,求其极限函数.</p>
<p>当然逐点收敛于<span class="math inline">\(0\)</span>,然而观察到<span class="math inline">\(f_n&#39;(x)=\sqrt n \cos nx\)</span>,<span class="math inline">\(f&#39;(x)=0\)</span>.因此,光滑函数列的导数的极限又不一定等于极限的导数.</p>
<h4><span id="一致收敛">一致收敛</span></h4>
<p>我们称一列函数<span class="math inline">\(\{f_n(x)\}\)</span>是<strong>一致收敛</strong>到<span class="math inline">\(f(x)\)</span>,当且仅当<span class="math inline">\(\forall \epsilon&gt;0\)</span>,<span class="math inline">\(\exists N=N(\epsilon)\)</span>,使得当<span class="math inline">\(n\geq N\)</span>的时候,<span class="math inline">\(|f(x)-f_n(x)|&lt;\epsilon,\forall x\in
I\)</span>.注意这里的<span class="math inline">\(N\)</span>不取决于<span class="math inline">\(x\)</span>的选取,这就是和极限不同的地方,一致收敛要求整个函数都在逐步地贴向最终的函数.此时,记<span class="math inline">\(f_n(x)\rightrightarrows
f(x)\)</span>.还可以定义<strong>内闭一致收敛</strong>的概念,也就是对于一个<span class="math inline">\(I\)</span>的任意的子紧集(在<span class="math inline">\(\mathbb{R}\)</span>上表现为有界闭集)都一致收敛.</p>
<p>一致收敛的等价定义当然是,取<span class="math inline">\(M_n=\sup_{x\in
I}|f_n(x)-f(x)|\)</span>,那么一致收敛等价于<span class="math inline">\(\lim M_n=0\)</span>.</p>
<p>一致收敛强大的地方在于,对于收敛来说,是取定了<span class="math inline">\(x\)</span>再挪动<span class="math inline">\(n\)</span>,因此<span class="math inline">\(n\)</span>可以控制<span class="math inline">\(x\)</span>.然而,一致收敛要求先取定<span class="math inline">\(n\)</span>再挪动<span class="math inline">\(x\)</span>.这种天然的交换能力赋予了一致收敛的强大.另外还容易见到,当<span class="math inline">\(I\)</span>的点集是有限的时候,一定一致收敛.</p>
<p>我们还可以定义<strong>一致有界</strong>的概念,当存在一个上界<span class="math inline">\(M\)</span>,使得<span class="math inline">\(\forall
n,|f_n|\leq
M\)</span>恒成立.显然,如果一个函数列一致有界,则极限函数肯定有界.</p>
<p>另外,我们可以见到,如果<span class="math inline">\(f_n\rightrightarrows f\)</span>,那么如果<span class="math inline">\(f\)</span>有界,则<span class="math inline">\(f_n\)</span>一致有界.反之,如果<span class="math inline">\(f_n\)</span>有界,则<span class="math inline">\(f_n\)</span>一致有界.</p>
<p>考虑前者,是因为:</p>
<p><span class="math display">\[
|f_n|\leq |f_n-f|+|f|
\]</span></p>
<p>这俩当然是有界的.</p>
<p>对于后者,考虑反证,假设<span class="math inline">\(f\)</span>无界(因为如果有界则前者即可推出),那么:</p>
<p><span class="math display">\[
|f|\leq |f-f_n|+|f_n|
\]</span></p>
<p>由于<span class="math inline">\(|f-f_n|\)</span>必然需要有界,因此前者无界,后者无论对于哪个<span class="math inline">\(n\)</span>来说,必然也得无界.</p>
<p>我们有以下性质:</p>
<ol type="1">
<li>$f_nf,g_ng,xI <span class="math inline">\(,则\)</span>c_1f_n+c_2g_nc_1f+c_2g,xI$.</li>
<li>$f_nf,g_ng,xI <span class="math inline">\(,而且\)</span>f,g<span class="math inline">\(有界,则\)</span>f_ng_nfg,xI$.</li>
<li>如果<span class="math inline">\(x\in I\)</span>的时候<span class="math inline">\(f_n\rightrightarrows f\)</span>,<span class="math inline">\(x\in J\)</span>的时候也<span class="math inline">\(f_n\rightrightarrows f\)</span>,则当<span class="math inline">\(x\in I\cup J\)</span>的时候也有<span class="math inline">\(f_n\rightrightarrows f\)</span>.</li>
</ol>
<p>对于(1),考虑令<span class="math inline">\(M_{n}=\sup |f_n-f|,K_n=\sup
|g_n-g|\)</span>,则:</p>
<p><span class="math display">\[
|(c_1f_n+c_2g_n)-(c_1f+c_2g)|\\
\leq |c_1|M_n+|c_2|K_n\to 0
\]</span></p>
<p>立刻证毕.</p>
<p>对于(2),经典的做法:</p>
<p><span class="math display">\[
|f_ng_n-fg|\\
=|f_n(g_n-g)+g(f_n-f)|\\
\leq |f_n|\sdot |g_n-g|+|g|\sdot |f_n-f|
\]</span></p>
<p>而<span class="math inline">\(|f_n|\)</span>一致有界,<span class="math inline">\(|g_n|\)</span>一致有界得到<span class="math inline">\(|g|\)</span>有界,所以上式就被控制住了.</p>
<p>对于(3),只需要把两部分的<span class="math inline">\(\sup\)</span>分开算就可以见到仍能被控制住.</p>
<p>这里也有<strong>柯西准则</strong>:对于一列函数<span class="math inline">\(\{f_n\}\)</span>,其一致收敛的充要条件是,<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall n,m\geq
N,|f_n(x)-f_m(x)|&lt;\epsilon\)</span>.</p>
<p>必要性显然,只证充分性,对于此时固定一个确定的<span class="math inline">\(x\)</span>,那么<span class="math inline">\(\{f_n(x)\}\)</span>就是一个柯西列且存在极限.逐点取极限就可以拿到<span class="math inline">\(f(x)=\lim_{n\to \infty} f_n(x)\)</span>.而<span class="math inline">\(|f_n(x)-f_m(x)|&lt;\epsilon\)</span>中只需要让<span class="math inline">\(m\to \infty\)</span>就拿到了<span class="math inline">\(|f_n(x)-f(x)|\leq
\epsilon\)</span>,这恰好是一致收敛的定义.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:<span class="math inline">\(f_n(x)=\frac{x}{1+n^2x^2}\)</span>一致收敛.</p>
<p>当然处处收敛于<span class="math inline">\(0\)</span>了,考虑用均值不等式,有<span class="math inline">\(|f_n(x)|\leq
\frac{|x|}{2n|x|}=\frac{1}{2n}\)</span>,这就搞定.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:<span class="math inline">\(f_n(x)=x^n,x\in
[0,1)\)</span>并不一致收敛.</p>
<p>当然处处收敛到<span class="math inline">\(0\)</span>,但是<span class="math inline">\(\sup f_n(x)=1\)</span>,所以并不一致收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f_n(x)=\frac{1}{n},g_n(x)=x,x\in
(0,+\infty)\)</span>,容易见到<span class="math inline">\(f_n\rightrightarrows 0,g_n\rightrightarrows
x\)</span>.而且<span class="math inline">\(f_n(x)\)</span>当然一致有界.然而,<span class="math inline">\(f_ng_n\not \rightrightarrows 0\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p>当<span class="math inline">\(g\in C[0,1],g(1)=0\)</span>,求证:<span class="math inline">\(f_n(x)=g(x)x^n\rightrightarrows 0\)</span>.</p>
<p>由于<span class="math inline">\(g\)</span>在闭区间上连续,则其必然在闭区间上一致连续.因此<span class="math inline">\(\forall \epsilon&gt;0\)</span>,取<span class="math inline">\(\delta\in (0,1)\)</span>,使得<span class="math inline">\(x\in [\delta,1]\)</span>的时候,<span class="math inline">\(|g(x)|&lt;\epsilon\)</span>,而取<span class="math inline">\(M=\sup_{[0,1]} |g|\)</span>,那么<span class="math inline">\(|f_n(x)|\leq
M\delta^n+\epsilon\)</span>,注意这里的<span class="math inline">\(\delta\)</span>不取决于<span class="math inline">\(n\)</span>的选取这就搞定.</p>
<h6><span id="example5">Example5</span></h6>
<p>设<span class="math inline">\(f_n(x)=n\left(\sqrt{x+\frac{1}{n}}-\sqrt{x}\right),x\in(0,+\infty)\)</span>,判断其收敛性.</p>
<p>容易发现<span class="math inline">\(f_n(x)=\frac{1}{\sqrt{x+\frac{1}{n}}+\sqrt x}\to
\frac{1}{2\sqrt x}\)</span>,因此其收敛.问题在于判断其是否一致收敛.</p>
<p>观察到:</p>
<p><span class="math display">\[
|f_n(x)-\frac{1}{2\sqrt x}|\\
=\frac{\sqrt{x+\frac{1}{n}}-\sqrt
x}{2\sqrt{x}\left(\sqrt{x+\frac{1}{n}}+\sqrt x\right)}\\
=\frac{1}{2n\sqrt x\left(\sqrt{x+\frac{1}{n}}+\sqrt x\right)^2}
\]</span></p>
<p>一个策略是直接对此式子求导,但也可以采取另一种分析策略,考虑:</p>
<p><span class="math display">\[
\sqrt{x+\frac{1}{n}}=\sqrt{x}\left(1+\frac{1}{nx}\right)^{\frac{1}{2}}\\
=\sqrt x\left(1+\frac{1}{2nx}+O(\frac{1}{n^2})\right)
\]</span></p>
<p>所以当<span class="math inline">\(x\)</span>足够小的时候可能会出问题,直接取<span class="math inline">\(x=\frac{1}{n}\)</span>,误差为:</p>
<p><span class="math display">\[
\frac{1}{2\sqrt n\left(\frac{1+\sqrt 2}{\sqrt n}\right)^2}=O(\sqrt n)
\]</span></p>
<p>这就证明了并非一致收敛.</p>
<h6><span id="example6">Example6</span></h6>
<p><span class="math inline">\([0,1]\)</span>上的<span class="math inline">\(f_n(x)\)</span>满足<span class="math inline">\(\exists L&gt;0,\forall x\ne y,|f_n(x)-f_n(y)|\leq
L|x-y|\)</span>.并且<span class="math inline">\(\forall x\in
[0,1],f_n(x)\to f(x)\)</span>.求证:<span class="math inline">\(f_n(x)\rightrightarrows
f(x)\)</span>.也就是:一致李氏连续的收敛函数列一定一致收敛.</p>
<p>李氏连续意味着我们可以用控制自变量的方式控制因变量.回忆到定义在有限集上的收敛函数列一定是一致收敛的.因此我们选择在数轴上打足够密的点来控制.</p>
<p>具体地,<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,我们将<span class="math inline">\([0,1]\)</span>拆为长度不超过<span class="math inline">\(\frac{\epsilon}{3L}\)</span>的小区间.假设分点是<span class="math inline">\(x_1,\cdots,x_K\)</span>.这当然对于一个<span class="math inline">\(\epsilon\)</span>来说是有限个点,我们可以让它们同时趋近于一致收敛,用柯西准则,也就是拿到一个<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n,m\geq N\)</span>,<span class="math inline">\(|f_n(x_i)-f_m(x_i)|&lt;\frac{\epsilon}{3}\)</span>.</p>
<p>现在<span class="math inline">\(\forall x\in [0,1],\exists
x_i,|x-x_i|&lt;\frac{\epsilon}{3L}\)</span>.于是:</p>
<p><span class="math display">\[
|f_n(x)-f_m(x)|\\\leq
|f_n(x)-f_n(x_i)|+|f_n(x_i)-f_m(x_i)|+|f_m(x_i)-f_m(x)|\\
&lt;\epsilon
\]</span></p>
<p>这就搞定.</p>
<h6><span id="example7">Example7</span></h6>
<p>设<span class="math inline">\(g\in C[0,1]\)</span>,令<span class="math inline">\(f_n(x)=x^ng(x)\)</span>,求证:<span class="math inline">\(f_n(x)\)</span>在<span class="math inline">\([0,1]\)</span>上一致收敛当且仅当<span class="math inline">\(f(1)=0\)</span>.</p>
<p>首先<span class="math inline">\(f(1)=0\)</span>的时候,只需要用一致连续将区间分成<span class="math inline">\([0,1-\delta),[1-\delta,1]\)</span>两部分,前半部分用<span class="math inline">\(x^n\)</span>控制,后半部分用<span class="math inline">\(f(1)\)</span>控制即可.这就证明了充分性.</p>
<p>接下来看必要性.如果<span class="math inline">\(f_n(x)\)</span>一致收敛,它收敛到的函数肯定是连续的,因此<span class="math inline">\(f(1)=0\)</span>.</p>
<h4><span id="函数项级数">函数项级数</span></h4>
<p>函数项级数上也有柯西准则,也就是函数项级数的一致收敛性等价于<span class="math inline">\(\forall \epsilon,\exists N,\forall n,m\geq
N,|\sum_{k=n}^m f_k(x)|&lt;\epsilon,\forall x\in I\)</span>.</p>
<p>还可以在这里定义<strong>绝对收敛</strong>:也就是<span class="math inline">\(\sum
|f_n(x)|\)</span>收敛.当然仍有绝对收敛推收敛.如果<span class="math inline">\(\sum
|f_n(x)|\)</span>还一致收敛,则称原级数<strong>绝对一致收敛</strong>.注意,这里的绝对一致收敛是定义在<span class="math inline">\(|f_n|\)</span>的基础上.也就是说,一个函数既绝对收敛,又一致收敛,但它可能并不绝对一致收敛.然而反之是成立的,如果一个函数绝对一致收敛,可以推出它一致收敛,原因是<span class="math inline">\(\sum |f_n|\geq |\sum
f_n|\)</span>,用柯西准则就可以得知.</p>
<p>另外,用柯西准则可以见到如果<span class="math inline">\(\sum
f_n\rightrightarrows f\)</span>,那么<span class="math inline">\(f_n(x)\rightrightarrows 0\)</span>.</p>
<p>容易见到绝对收敛的和仍然绝对收敛,绝对一致收敛的和仍然绝对一致收敛.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑函数项级数<span class="math inline">\(\sum (-x)^n(1-x),x\in
[0,1]\)</span>.</p>
<p>直接考虑其余项,<span class="math inline">\(R_n(x)=\sum_{k=n+1}^\infty
(-x)^k(1-x)=\frac{(-x)^{n+1}(1-x)}{1+x}\)</span>.此时考虑:</p>
<p><span class="math display">\[
|R_n|\leq x^{n+1}(1-x)\\=\frac{1}{n+1}(n+1)(1-x)x^{n+1}\\\leq
\frac{1}{n+1}(\frac{n+1}{n+2})^{n+2}\\\leq \frac{1}{n+1}\to 0
\]</span></p>
<p>所以该级数一致收敛.</p>
<p>那么是否绝对收敛呢?考虑:</p>
<p><span class="math display">\[
\sum_{k=1}^n |(-x)^n(1-x)|\\
=\sum_{k=1}^n (x^k-x^{k+1})\\
=x-x^{n+1}
\]</span></p>
<p>所以当然也绝对收敛到<span class="math inline">\(\begin{cases}x&amp;x\in
[0,1)\\0&amp;x=1\end{cases}\)</span>.</p>
<p>可是,它并不是绝对一致收敛的.考虑<span class="math inline">\(\sup_{[0,1)}|S(x)-S_n(x)|=\sup_{[0,1)}|x^{n+1}|=1\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum \left(\cos\frac{\pi
x}{n}\right)^{n^3}\)</span>的收敛域.</p>
<p>不妨设<span class="math inline">\(u_n(x)=\left(\cos\frac{\pi
x}{n}\right)^{n^3}\)</span>,考虑:</p>
<p><span class="math display">\[
\sqrt[n]{u_n(x)}=\left(\cos\frac{\pi x}{n}\right)^{n^2}\\
=\left(1-\frac{\pi^2x^2}{2n^2}+O(\frac{1}{n^4})\right)^{n^3}\\
=\exp(n^2\ln\left(1-\frac{\pi^2x^2}{2n^2}+O(\frac{1}{n^4})\right))\\
=\exp(n^2\left(-\frac{\pi^2x^2}{2n^2}+O(\frac{1}{n^4})\right))\\
=\exp(-\frac{\pi^2 x^2}{2}+O(\frac{1}{n^2}))\\
\to e^{-\frac{\pi^2x^2}{2}}
\]</span></p>
<p>所以最后模拟成了一个等比数列,那收敛域就是<span class="math inline">\(\mathbb{R}\setminus\{0\}\)</span>.</p>
<h5><span id="m判别法">M判别法</span></h5>
<p>若<span class="math inline">\(|f_n(x)|\leq a_n,x\in
I\)</span>,如果<span class="math inline">\(\sum
a_n&lt;\infty\)</span>,则<span class="math inline">\(\sum
f_n(x)\)</span>绝对一致收敛.</p>
<p>证明的话,考虑用一般级数可以拿到<span class="math inline">\(\forall
\epsilon&gt;0,\exists N,\forall n,m\geq N,\sum_{k=n}^m
|a_n|&lt;\epsilon\)</span>,但又有<span class="math inline">\(\sum_{k=n}^m |f_n(x)|\leq \sum_{k=n}^m
a_k\)</span>,这就知道其绝对一致收敛.</p>
<h5><span id="da判别法">DA判别法</span></h5>
<p>假设<span class="math inline">\(\{a_n(x)\},\{b_n(x)\}\)</span>是两个函数列.对于任意固定的<span class="math inline">\(x\in I\)</span>,<span class="math inline">\(\{a_n(x)\}\)</span>是一个单调数列.注意这里其实不要求大家都递增或递减,只要对于每一个点都是单调的.而取<span class="math inline">\(B_n(x)=\sum_{k=1}^n b_k(x)\)</span>.则当:</p>
<ol type="1">
<li>Dirichlet判别法:当<span class="math inline">\(a_n(x)\rightrightarrows 0\)</span>,<span class="math inline">\(B_n(x)\)</span>一致有界时,则<span class="math inline">\(\sum a_nb_n\)</span>一致收敛.</li>
<li>Able判别法:当<span class="math inline">\(\{a_n(x)\}\)</span>一致有界,<span class="math inline">\(B_n(x)\)</span>一致收敛时,则<span class="math inline">\(\sum a_nb_n\)</span>一致收敛.</li>
</ol>
<p>证明和级数部分完全一样,只需要对于任意的<span class="math inline">\(x\)</span>都这么搞即可:</p>
<p><span class="math display">\[
|\sum_{k=n+1}^{n+p}a_k(x)b_k(x)|\\
=|\sum_{k=n+1}^{n+p}a_k(x)(B_{k}(x)-B_{k-1}(x))|\\
=|a_{n+p}B_{n+p}(x)+\sum_{k=n+1}^{n+p-1}(a_k(x)-a_{k+1}(x))B_k(x)|\\
\leq M(a_{n+1}(x)+2a_{n+p}(x))
\]</span></p>
<p>其中<span class="math inline">\(M=\sup_{1\leq i\leq
p}\{|\sum_{k=n+1}^{n+i}b_k(x)|\}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(b_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>的时候,求证:<span class="math inline">\(\sum_{k=1}^\infty b_n\sin(nx),x\in
\mathbb{R}\)</span>一致收敛的充要条件是<span class="math inline">\(b_n=o(\frac{1}{n})\)</span>.</p>
<p>先证必要性,设<span class="math inline">\(S_{n,p}=\sum_{k=n}^p
b_k\sin(kx)\)</span>.由柯西原理,<span class="math inline">\(\forall
\epsilon&gt;0,\exists N,\forall n,p\geq
N,|S_{n,p}|&lt;\epsilon\)</span>.此时取<span class="math inline">\(p=2n-1,x=\frac{\pi}{4n}\)</span>,此时当<span class="math inline">\(n\leq k\leq p\)</span>的时候,<span class="math inline">\(\sin (k\pi)&gt;\sin
\frac{\pi}{4}\)</span>,立刻有:</p>
<p><span class="math display">\[
\epsilon&gt;|S_{n,p}(x)|\\
&gt;nb_{2n}\sin\frac{\pi}{4}=\frac{\sqrt 2}{2}n b_{2n}
\]</span></p>
<p>这就搞定了<span class="math inline">\(b_{2n}=o(\frac{1}{n})\)</span>,又因为<span class="math inline">\(b_n\)</span>是单调下降的,那当然搞定了.</p>
<p>再证充分性,只要证明在<span class="math inline">\([0,\pi]\)</span>上一致收敛,由于<span class="math inline">\(\sin(nx)\)</span>是奇函数,那么在<span class="math inline">\([-\pi,0]\)</span>上当然也一致收敛,那就搞定了.</p>
<p>设<span class="math inline">\(\mu_n=\max_{m\geq
n}{mb_m}\)</span>,注意到<span class="math inline">\(\mu_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>.下面开始讨论:</p>
<p>当<span class="math inline">\(x\in
[0,\frac{\pi}{p}]\)</span>的时候,此时<span class="math inline">\(S_{n,p}\)</span>中的每一项都同号.自然有:</p>
<p><span class="math display">\[
\sum_{k=n}^p b_k \sin(kx)\leq \sum_{k=n}^p b_k kx\\
\leq \frac{\pi}{p}\sum_{k=n}^p b_k k\\
\leq \frac{\pi}{p}(p-n)\mu_n\\
\leq \pi\mu_n
\]</span></p>
<p>这就完事.</p>
<p>当<span class="math inline">\(x\in
[\frac{\pi}{n},\pi]\)</span>的时候,和差化积公式给出:</p>
<p><span class="math display">\[
|\sum_{k=1}^n \sin(kx)|\\
=\left|\frac{\cos(k-\frac{1}{2})x-\cos(k+\frac{1}{2})}{2\sin
\frac{x}{2}}\right|\\
\leq \frac{1}{|\sin\frac{x}{2}|}\\
&lt;n
\]</span></p>
<p>原因是当<span class="math inline">\(\frac{x}{2}\leq
\frac{\pi}{2}\)</span>的时候,<span class="math inline">\(\sin
\frac{x}{2}\geq \frac{2}{\pi}\frac{x}{2}\geq n\)</span>.</p>
<p>回忆到Abel变换给出<span class="math inline">\(|S_{n,p}|\leq
n(2b_n+b_p)&lt;3nb_n\to 0\)</span>.这就搞定.</p>
<p>当<span class="math inline">\(x\in
(\frac{\pi}{p},\frac{\pi}{n})\)</span>的时候,取<span class="math inline">\(m=\lfloor\frac{\pi}{x}\rfloor\leq
\frac{\pi}{x}\)</span>.那我们就有:<span class="math inline">\(\frac{\pi}{m+1}\leq x\leq
\frac{\pi}{m}\)</span>.</p>
<p>当<span class="math inline">\(k\in [n,m]\)</span>的时候,<span class="math inline">\(kx\leq \pi\)</span>,那<span class="math inline">\(\sin(kx)\leq kx\)</span>就成立,那么和上面一样:</p>
<p><span class="math display">\[
|S_{n,m}|\leq \pi \mu_n
\]</span></p>
<p>当<span class="math inline">\(k\in[m+1,p]\)</span>的时候,此时<span class="math inline">\(\frac{1}{|\sin \frac{x}{2}|}\geq
\frac{1}{m+1}\)</span>,因此:</p>
<p><span class="math display">\[
|S_{m+1,n}\leq (m+1)(2b{m+1}+b_p)&lt;3\mu_{m+1}|
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
|S_{n,p}|\leq |S_{n,m}|+|S_{m+1,p}|&lt;\pi\mu_n+3\mu_{m+1}
\]</span></p>
<p>这就搞定.</p>
<h4><span id="连续性">连续性</span></h4>
<p>我们还可以定义<strong>等度连续</strong>的概念:我们说<span class="math inline">\(f_n\)</span>等度连续,当<span class="math inline">\(\forall \epsilon&gt;0,\exists
\delta&gt;0\)</span>,使得<span class="math inline">\(\forall
x,y\)</span>,若<span class="math inline">\(|x-y|&lt;\delta\)</span>,则<span class="math inline">\(\forall
n,|f_n(x)-f_n(y)|&lt;\epsilon\)</span>.其实就是某种一致(函数列)的一致(定义域上)连续.</p>
<p>我们可以证明:如果<span class="math inline">\(f_n(x)\in
C[a,b]\)</span>,而且其等度连续,则如果<span class="math inline">\(\lim_{n\to \infty}f_n(x)=f(x),x\in
[a,b]\)</span>,则<span class="math inline">\(f_n\rightrightarrows f,x\in
[a,b]\)</span>.</p>
<p>证明与下述Example6类似,事实上Example6是这个的一个推论.我们取定<span class="math inline">\(\delta\)</span>,使得<span class="math inline">\(|x-y|&lt;\delta\)</span>时一定有<span class="math inline">\(\forall
n,|f_n(x)-f_n(y)|&lt;\frac{\epsilon}{3}\)</span>,此时再令<span class="math inline">\(n\to
\infty\)</span>,就有|f(x)-f(y)|,再取一个分划<span class="math inline">\(\Delta
:a=x_0&lt;\cdots&lt;x_m=b\)</span>并要求<span class="math inline">\(\lambda (\Delta)&lt;\delta\)</span>.</p>
<p>自然有:</p>
<p><span class="math display">\[
|f_n(x)-f(x)|\leq |f_n(x)-f_n(x_i)|+|f_n(x_i)-f(x_i)|+|f(x_i)-f(x)|\\
\leq \epsilon
\]</span></p>
<p>原因仍是有限点集上的收敛一定是一致收敛.</p>
<p>下面要探索的就是一致连续是否保持了原函数项级数的作用.</p>
<p>先看一个引理:当<span class="math inline">\(x_0\in
[a,b]\)</span>的时候,如若当<span class="math inline">\(x\in
[a,b]\setminus\{x_0\}\)</span>,<span class="math inline">\(f_n(x)\rightrightarrows f(x)\)</span>,已知<span class="math inline">\(\lim_{x\to
x_0}f_n(x)=\alpha_n\)</span>存在.则<span class="math inline">\(\lim_{n\to \infty}\alpha_n\)</span>存在而且<span class="math inline">\(\lim_{x\to x_0}f(x)=\lim_{n\to
\infty}\alpha_n\)</span>.换言之,<span class="math inline">\(\lim_{x\to
x_0}\lim_{n\to \infty}f_n(x)=\lim_{n\to \infty}\lim_{x\to
x_0}f_n(x)\)</span>.</p>
<p>证明的话,首先要证明<span class="math inline">\(\lim_{n\to\infty}\alpha_n\)</span>存在,考虑<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall n,m\geq
N\)</span>,有<span class="math inline">\(|f_n(x)-f_m(x)|&lt;\frac{\epsilon}{3}\)</span>,取极限知道<span class="math inline">\(|\alpha_n-\alpha_m|\leq
\frac{\epsilon}{3}\)</span>,这说明<span class="math inline">\(\{\alpha_n\}\)</span>是柯西列,当然收敛.不妨设<span class="math inline">\(\alpha=\lim_{n\to \infty}\alpha_n\)</span>.</p>
<p>此时有:</p>
<p><span class="math display">\[
|f(x)-\alpha|\leq |f(x)-f_N(x)|+|f_N(x)-\alpha_N|+|\alpha_N-\alpha|
\]</span></p>
<p>两边一取极限使得<span class="math inline">\(x\to
x_0\)</span>,立刻见到<span class="math inline">\(|f(x)-\alpha|&lt;\epsilon\)</span>.这已经能看出一致连续的强大了.正是因为一致连续可以先固定<span class="math inline">\(N\)</span>,我们才可以在这里对<span class="math inline">\(x\to
x_0\)</span>取极限.所以这里有一个天然的可交换性.</p>
<p>这个引理的一个推论是:如果<span class="math inline">\(f_n\rightrightarrows f,x\in
[a,b]\)</span>,则对于<span class="math inline">\(x_0\in
[a,b]\)</span>,如果<span class="math inline">\(f_n(x)\)</span>在<span class="math inline">\(x_0\)</span>处连续,则<span class="math inline">\(f\)</span>也在<span class="math inline">\(x_0\)</span>处连续.原因是既然连续,则<span class="math inline">\(\alpha_n=\lim_{x\to
x_0}f_n(x)=f_n(x_0)\)</span>,所以<span class="math inline">\(\lim_{x\to
x_0}f(x)=\lim_{n\to \infty}f_n(x_0)=f(x_0)\)</span>.这就说明在<span class="math inline">\(x_0\)</span>处连续.更有推论:如果<span class="math inline">\(f_n\in C[a,b],f_n\rightrightarrows
f\)</span>,则<span class="math inline">\(f\in
C[a,b]\)</span>.从而还可以见到,如果一串连续函数收敛到一个不连续函数,那这肯定也不是一致收敛的.</p>
<p>那么反过来,如果连续函数列收敛到连续函数,能不能推出一致收敛呢?我们事实上有<strong>迪尼定理</strong>:如果<span class="math inline">\(f_n(x)\in C[a,b]\)</span>,当<span class="math inline">\(n&lt;m\)</span>的时候,<span class="math inline">\(\forall x\in [a,b],f_n(x)\leq
f_m(x)\)</span>,此时如若<span class="math inline">\(f_n\rightarrow
f\)</span>,而且<span class="math inline">\(f\in C[a,b]\)</span>,则<span class="math inline">\(f_n\rightrightarrows
f\)</span>.也就是只要有一定的单调性,我们就可以说连续函数列收敛到连续函数是一致连续的充要条件.</p>
<p>取<span class="math inline">\(R_n(x)=f(x)-f_n(x)\geq
0\)</span>,注意到<span class="math inline">\(\lim_{n\to
\infty}R(x)=0\)</span>而且<span class="math inline">\(R_n(x)\)</span>连续且逐点随<span class="math inline">\(n\)</span>单调递减,则必有<span class="math inline">\(R_n\to 0\)</span>.如果我们能证明<span class="math inline">\(R_n(x)\rightrightarrows
0\)</span>,那就万事大吉.不妨设<span class="math inline">\(M_n=\max_{x\in
[a,b]}R_n(x)=R_n(x_n)\)</span>,那么只要证明<span class="math inline">\(M_n\to 0\)</span>就可以搞定一致收敛.然而<span class="math inline">\(M_n\)</span>本身是单调下降的.反证,如果<span class="math inline">\(\lim_{n\to \infty}M_n=c&gt;
0\)</span>,此时观察<span class="math inline">\(x_n\in
[a,b]\)</span>,既然如此,<span class="math inline">\(\{x_n\}\)</span>必定有收敛子列,任取一个收敛子列<span class="math inline">\(\{x_{n_k}\}\)</span>并假设其收敛到<span class="math inline">\(x_0\)</span>,接下来看:</p>
<p><span class="math display">\[
\lim_{m\to \infty}R_m(x_0)\\
=\lim_{m\to \infty}\lim_{x_{n_k}\to x_0}R_m(x_{n_k})\\
\geq \lim_{m\to \infty}\lim_{n_k&gt;m,x_{n_k}\to x_0}R_{n_k}(x_{n_k})\\
=\lim_{x_{n_k}\to x_0}R_{n_k}(x_{n_k})&gt;0
\]</span></p>
<p>可这就出事了.于是矛盾,反证成立.</p>
<p>迪尼定理的一个推论是如果<span class="math inline">\(f_n(x)\geq
0\)</span>,那么此时<span class="math inline">\(S_n(x)=\sum_k^n
f(x)\)</span>就是逐点单调的了.因此我们可以看到此时<span class="math inline">\(\sum f_n\)</span>一致收敛性也就等价于其连续性.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(f_n\geq 0\)</span>,而且<span class="math inline">\(\forall n,f_n\)</span>单增的时候,如若<span class="math inline">\(\sum f_n(x)\leq M,\forall x\in
[a,b)\)</span>.求证此时<span class="math inline">\(\lim_{x\to
b-0}\sum_{n=1}^\infty f_n(x)=\sum_{n=1}^\infty f_n(b-0)\)</span>.</p>
<p>设<span class="math inline">\(S_n=\sum_k^n f_k(x)\)</span>,取定<span class="math inline">\(m\)</span>,此时<span class="math inline">\(\forall
x\in [a,b)\)</span>,<span class="math inline">\(S(x)\geq
S_m(x)\)</span>.令<span class="math inline">\(x\to
b-0\)</span>,自然有<span class="math inline">\(\sum_{n=1}^m f_n(b-0)\leq
\lim_{x\to b-0}S(x)\)</span>.直接令<span class="math inline">\(S(b-0)=\lim_{x\to
b-0}S(x)\)</span>,这个极限存在,原因是<span class="math inline">\(S(x)\)</span>是单调的.从而取极限得到<span class="math inline">\(\sum_{n=1}^\infty f_n(b-0)\leq
S(b-0)\)</span>.</p>
<p>接下来另一个方向,考虑:</p>
<p><span class="math display">\[
\sum_{n=1}^m f_n(x)\leq \sum_{n=1}^m f_n(b-0)
\leq \sum_{n=1}^\infty f_n(b-0)\\
S(x)\leq \sum_{n=1}^\infty f_n(b-0)\\
S(b-0)\leq \sum_{n=1}^\infty f_n(b-0)
\]</span></p>
<p>这就搞定.</p>
<h6><span id="example2">Example2</span></h6>
<p><span class="math inline">\(f_n\)</span>在<span class="math inline">\([a,b]\)</span>上可微而且<span class="math inline">\(f_n&#39;\in R[a,b]\)</span>,若<span class="math inline">\(\forall x\in [a,b],\forall n,|\sum_{k=1}^n
f_k&#39;(x)|\leq M\)</span>,<span class="math inline">\(\sum
f_n(x)\)</span>在<span class="math inline">\([a,b]\)</span>上收敛.求证其在<span class="math inline">\([a,b]\)</span>上一致收敛.</p>
<p>容易观察到<span class="math inline">\(\sum
f_n(x)\)</span>一致李氏连续,用之前等度连续的结论就可以做掉.</p>
<h4><span id="可积性">可积性</span></h4>
<p>如果<span class="math inline">\(f_n\in R[a,b],f_n\rightrightarrows
f\)</span>,则我们声明<span class="math inline">\(f\in
R[a,b]\)</span>且<span class="math inline">\(\int_a^b f{\rm
d}x=\lim_{n\to \infty}\int_a^b f_n{\rm d}x\)</span>.</p>
<p>考虑证明,首先<span class="math inline">\(f_n\)</span>是有界的,又因为一致收敛,所以能推出<span class="math inline">\(f\)</span>也是有界的.</p>
<p>一个想法是使用勒贝格定理.直接取<span class="math inline">\(K_n\)</span>是<span class="math inline">\(f_n\)</span>的间断点集,立刻得到<span class="math inline">\(K_n\)</span>是零测集.接下来令<span class="math inline">\(K=\bigcup K_n\)</span>,那<span class="math inline">\(K\)</span>还是零测集(可数个零测集的并),此时对于<span class="math inline">\(\forall x\in [a,b]\setminus K\)</span>,<span class="math inline">\(\forall n,f_n\)</span>都在<span class="math inline">\(x\)</span>处连续,那<span class="math inline">\(f\)</span>肯定也在<span class="math inline">\(x\)</span>处连续,所以<span class="math inline">\(f\)</span>的间断点集就一定被包含于零测集<span class="math inline">\(K\)</span>,所以黎曼可积.</p>
<p>接下来的问题是是否积分相等,取<span class="math inline">\(M_n=\sup_{[a,b]}|f-f_n|\)</span>,注意到:</p>
<p><span class="math display">\[
|\int_a^b f{\rm d}x-\int_a^b f_n{\rm d}x|\\
\leq \int_a^b|f-f_n|{\rm d}x\\
\leq \int_a^bM_n{\rm d}x\\
=M_n(b-a)\to 0
\]</span></p>
<p>这就搞定.然而注意到这里需要依赖于<span class="math inline">\(b-a\)</span>的有界性.</p>
<p>另一个策略是直接用分划达布和证明<span class="math inline">\(f\in
R[a,b]\)</span>.不妨设<span class="math inline">\(|f_n|\leq M,|f|\leq
M\)</span>.则<span class="math inline">\(\forall \epsilon&gt;0,\exists
n\)</span>,<span class="math inline">\(|f_n(x)-f(x)|&lt;\epsilon\)</span>.由于<span class="math inline">\(f_n(x)\in R[a,b]\)</span>,可以取定分划<span class="math inline">\(\Delta:a=x_0&lt;\cdots&lt;x_p=b\)</span>,使得<span class="math inline">\(\sum(M_i-m_i)\Delta x_i&lt;\epsilon\)</span>.</p>
<p>于此,我们取<span class="math inline">\(\bar M_i=\sup_{[x_{i-1},x_i]}
f(x),\bar m_i\)</span>同理.观察到<span class="math inline">\(\forall
x\in [x_{i-1},x_i],f(x)\leq f_n(x)+\epsilon\leq
M_i+\epsilon\)</span>,所以一定有<span class="math inline">\(\bar M_i\leq
M_i+\epsilon\)</span>.对于<span class="math inline">\(\bar
m_i\)</span>同理.此时:</p>
<p><span class="math display">\[
\sum (\bar M_i-\bar m_i)\Delta x_i\\
\leq \sum(M_i-m_i)\Delta x_i+2\epsilon(b-a)\\
\leq \epsilon(1+2(b-a))
\]</span></p>
<p>这就搞定.</p>
<p>事实上这个结论可以更强,可以放弃一致收敛的条件.我们有<strong>控制收敛定理</strong>:假设<span class="math inline">\(f_n\in R[a,b]\)</span>,而且它们一致有界,<span class="math inline">\(\forall n,\forall x\in [a,b],|f_n|\leq
M\)</span>.并且<span class="math inline">\(f(x)=\lim_{n\to
\infty}f_n(x)\in R[a,b]\)</span>,则<span class="math inline">\(\int_a^b
f(x){\rm d}x=\lim_{n\to \infty}\int_a^b f_n(x){\rm d}x\)</span>.</p>
<p>为证明此,先引入一些相关的定义:</p>
<p>定义<strong>阶梯函数</strong>为分段常值函数,假设<span class="math inline">\(f\in R[a,b]\)</span>,则我们可以用阶梯函数逼近<span class="math inline">\(f\)</span>,具体而言,假设<span class="math inline">\(g\)</span>是阶梯函数,并且<span class="math inline">\(g\leq f\)</span>,那么我们可以将<span class="math inline">\(g\)</span>类似达布下和而分划够细,以使得<span class="math inline">\(\int_a^b f{\rm d}x=\sup_{g\leq f,\text{g is a step
function}}\{\int_a^b g(x){\rm d}x\}\)</span>.</p>
<p>定义<strong>初等集</strong>:有限个不交区间的并,可以见到其测度<span class="math inline">\(m(E)\)</span>就是所有不交区间的长度之和.</p>
<p>定义<strong>闭初等集</strong>:有限个不交闭区间的并.</p>
<p>定义<strong>有界闭初等集列</strong>:<span class="math inline">\(A_n\)</span>是闭初等集.容易见到,如果<span class="math inline">\(A_n\ne \empty\)</span>,而且<span class="math inline">\(A_{n+1}\subseteq A_n\)</span>,则<span class="math inline">\(\bigcap_{n=1}^\infty A_n\ne
\empty\)</span>,证明的话只需类似区间套定理,每个<span class="math inline">\(A_n\)</span>内取一个点,这个点列是有界的,那它就一定有收敛子列,收敛到的那个点一定被含在每一个<span class="math inline">\(A_n\)</span>中.这就搞定.</p>
<p>不妨设<span class="math inline">\(A_n\)</span>是有界非空集列,满足<span class="math inline">\(A_{n+1}\subseteq A_n,A_n\ne
\empty,\bigcap_{n=1}^\infty A_n=\empty\)</span>.此时定义<span class="math inline">\(\alpha_n=\sup\{m(E)\mid E\subseteq,\text{E is a
closed elementary set}\}\)</span>.我们下面证明<span class="math inline">\(\lim_{n\to \infty}\alpha_n=0\)</span>.</p>
<p>首先显然<span class="math inline">\(\alpha_n\)</span>单调递减.如若其不以<span class="math inline">\(0\)</span>为极限,则一定有正下界<span class="math inline">\(\alpha_n&gt;\delta&gt;0\)</span>.我们可以取<span class="math inline">\(A_n\)</span>的闭初等子集<span class="math inline">\(E_n\subseteq A_n\)</span>满足<span class="math inline">\(m(E_n)&gt;\alpha_n-\frac{\delta}{2^n}\)</span>.</p>
<p>接下来定义<span class="math inline">\(H_n=\bigcap_{k=1}^n
E_k\)</span>,这当然是初等集,此时见到<span class="math inline">\(H_{n+1}\subseteq H_n\)</span>.接下来对<span class="math inline">\(A_n\setminus H_n\)</span>的任意初等子集<span class="math inline">\(E\)</span>,显然:</p>
<p><span class="math display">\[
E=E\setminus H_n\\
=E\setminus(\bigcap_{k=1}^n E_k)\\
=\bigcup_{k=1}^n (E\setminus E_k)
\]</span></p>
<p>而<span class="math inline">\(E\subseteq A_n\subseteq
A_k\)</span>,所以<span class="math inline">\(E_k\)</span>和<span class="math inline">\(E\setminus E_k\)</span>都是<span class="math inline">\(A_k\)</span>的初等子集.所以:</p>
<p><span class="math display">\[
m(E\setminus E_k)+m(E_k)\leq \alpha_k\\
m(E\setminus E_k)\leq \frac{\delta }{2^k}
\]</span></p>
<p>所以<span class="math inline">\(m(E)\leq \delta\)</span>.如果<span class="math inline">\(H_n=\empty\)</span>,那么<span class="math inline">\(m(E)=\alpha_n\)</span>,这就不符.所以<span class="math inline">\(H_n\ne \empty\)</span>,所以<span class="math inline">\(\bigcap_{n=1}^\infty H_n\ne
\empty\)</span>,所以<span class="math inline">\(\bigcap A_n\ne
\empty\)</span>.矛盾,这就证明了原本的结论.</p>
<p>接下来考虑<span class="math inline">\(f(x)-f_n(x)\)</span>,当没有一致连续的条件时,可能出现问题的地方在于有的地方两者不一定靠的足够近.</p>
<p>对于<span class="math inline">\(\forall \epsilon&gt;0,A_n=\{x\in
[a,b]\mid \exists j\geq n,|f_j(x)-f(x)|\geq
\epsilon\}\)</span>.容易见到<span class="math inline">\(A_{n+1}\subseteq
A_n\)</span>,由于<span class="math inline">\(f_n\to f\)</span>,所以<span class="math inline">\(\bigcap_{n=1}^\infty
A_n=\empty\)</span>.引理告诉我们<span class="math inline">\(\alpha_n\to
0\)</span>.既然如此,存在<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall n\geq N\)</span>,<span class="math inline">\(A_n\)</span>的任意初等子集<span class="math inline">\(E\)</span>都有<span class="math inline">\(m(E)&lt;\epsilon\)</span>.取<span class="math inline">\(F=[a,b]\setminus E\)</span></p>
<p>此时取阶梯函数<span class="math inline">\(S(x)\)</span>满足<span class="math inline">\(0\leq S(x)\leq
|f(x)-f_n(x)|\)</span>.这个时候看<span class="math inline">\(S(x)\)</span>的积分:</p>
<p><span class="math display">\[
\int_a^b S(x){\rm d}x=\int_E S(x){\rm d}x+\int_F S(x){\rm d}x\\
\leq 2M\epsilon+\epsilon(b-a)
\]</span></p>
<p>这个对任意<span class="math inline">\(S(x)\)</span>都成立,由于我们之前说的阶梯函数的上界可以逼近原函数,所以这就意味着:</p>
<p><span class="math display">\[
|\int_a^bf_n(x)-f(x){\rm d}x|\\
\leq \int_a^b|f_n(x)-f(x)|{\rm d}x\\
\leq 2M\epsilon+\epsilon(b-a)
\]</span></p>
<p>这就搞定.</p>
<p>还有另一个结论:假设<span class="math inline">\(f_n\in
R[a,b],|f_n|\leq M\)</span>,已知<span class="math inline">\(\lim_{n\to
\infty} f_n(x)=f(x)\)</span>存在(注意这里并不要求<span class="math inline">\(f(x)\in R[a,b]\)</span>),我们就可以证明<span class="math inline">\(\lim_{n\to \infty}\int_a^b f_n(x){\rm
d}x\)</span>存在.</p>
<p>考虑<span class="math inline">\(|\int_a^b f_n{\rm d}x|\leq
M(b-a)\)</span>有界,所以其可以取上下极限操作.令<span class="math inline">\(\overline F=\varlimsup_{n\to \infty}\int_a^b
f_n{\rm d}x,\underline F=\varliminf_{n\to \infty}\int_a^b f_n{\rm
d}x\)</span>.既然如此,就一定存在两列<span class="math inline">\(\{n_k\}\)</span>和<span class="math inline">\(\{m_k\}\)</span>,使得<span class="math inline">\(\overline F=\lim_{k\to \infty}\int_a^b f_{n_k}{\rm
d}x,\underline F=\lim_{k\to \infty}\int_a^b f_{m_k}{\rm
d}x\)</span>.然而:</p>
<p><span class="math display">\[
\overline F-\underline F=\lim_{k\to \infty}\int_a^b(f_{n_k}-f_{m_k}){\rm
d}x\\
=\int_a^b\lim_{k\to \infty}(f_{n_k}-f_{m_k}){\rm d}x
=0
\]</span></p>
<p>这你就可以见到,我们其实可以把这个极限干脆定义成<span class="math inline">\(f\)</span>的积分.这实际上就是勒贝格积分.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:<span class="math inline">\(\int_0^1 \frac{1}{x^x}{\rm
d}x=\sum_{n=1}^\infty\frac{1}{n^n}\)</span>.</p>
<p>展开:</p>
<p><span class="math display">\[
\frac{1}{x^x}=e^{-x\ln x}\\
=\sum_{n\geq 0}\frac{(-x\ln x)^n}{n!}
\]</span></p>
<p>容易证明这个函数项级数是一致收敛的,那我们就可以逐项积分,而且积分内可以做多少次分部积分都无所谓(反正是有限逼近无限).</p>
<p>那么:</p>
<p><span class="math display">\[
\int_0^1 \frac{1}{x^x}{\rm d}x\\
=\int_0^1\sum_{n\geq 0}\frac{(-x\ln x)^n}{n!}{\rm d}x\\
=\sum_{n\geq 0}\int_0^1\frac{(-x\ln x)^n}{n!}{\rm d}x
\]</span></p>
<p>令<span class="math inline">\(x=e^{-t}\)</span>,换元:</p>
<p><span class="math display">\[
\sum_{n\geq 0}\int_0^1\frac{(-x\ln x)^n}{n!}{\rm d}x\\
=-\sum_{n\geq 0}\frac{1}{n!}\int_0^{+\infty}e^{-(n+1)t}t^n{\rm d}t
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\int_0^{+\infty}e^{-(n+1)t}t^n{\rm d}t\\
=\frac{-1}{n+1}\int_0^{+\infty}t^n{\rm d}e^{-(n+1)t}\\
=\frac{-1}{n+1}\left(e^{-(n+1)t}t^{n}|_0^{+\infty}-n\int_0^{+\infty}e^{-(n+1)t}t^{n-1}\right)\\
=\frac{n}{n+1}\int_0^{+\infty}e^{-(n+1)t}t^{n-1}\\
=\cdots\\
=\frac{n!}{(n+1)^{n}}\int_0^{+\infty}e^{-{n+1}t}{\rm d}t\\
=-\frac{n!}{(n+1)^{n+1}}
\]</span></p>
<p>和上面结合一下就证毕.</p>
<h4><span id="可微性">可微性</span></h4>
<p>先看一个平凡的命题:假设<span class="math inline">\(f_n\in
C^1[a,b],x_0\in [a,b]\)</span>,已知<span class="math inline">\(\{f_n(x_0)\}\)</span>收敛,而且<span class="math inline">\(f_n&#39;\rightrightarrows g\)</span>.则<span class="math inline">\(f_n\rightrightarrows f\)</span>,其中<span class="math inline">\(f\in C^1[a,b]\)</span>,并且恰好满足<span class="math inline">\(f&#39;=g\)</span>.</p>
<p>考虑<span class="math inline">\(g(x)=\lim_{n\to
\infty}f_n&#39;(x),x\in [a,b]\)</span>当然能得到<span class="math inline">\(g(x)\)</span>是连续函数.</p>
<p>接下来考虑NL公式给出:</p>
<p><span class="math display">\[
f_n(x)=f_n(x_0)+\int_{x_0}^x f&#39;_n(t){\rm d}t\\
\lim_{n\to \infty}f_n(x)=\lim_{n\to \infty}f_n(x_0)+\lim_{n\to
\infty}\int_{x_0}^x f&#39;_n(t){\rm d}t\\
\lim_{n\to \infty}f_n(x)=\lim_{n\to
\infty}f_n(x_0)+\int_{x_0}^x\lim_{n\to \infty} f&#39;_n(t){\rm d}t\\
f(x)=\lim_{n\to \infty}f_n(x_0)+\int_{x_0}^xg(t){\rm d}t\\
\]</span></p>
<p>这就见到<span class="math inline">\(f_n\to f,f\in
C^1[a,b]\)</span>而且<span class="math inline">\(f&#39;=g\)</span>.现在的问题是能否推出一致收敛<span class="math inline">\(f_n\rightrightarrows f\)</span>.有:</p>
<p><span class="math display">\[
|f_n(x)-f(x)|\\
=|f_n(x_0)+\int_{x_0}^xf_n&#39;(t){\rm d}t-f(x_0)-\int_{x_0}^xg(t)|\\
\leq |f_n(x_0)-f(x_0)|+|\int_{x_0}^xf_n&#39;(t){\rm
d}t-\int_{x_0}^xg(t)|\\
\leq|f_n(x_0)-f(x_0)|+(b-a)\sup|f_n&#39;-g|
\]</span></p>
<p>这就完事.</p>
<p>上述结果能不能加强呢?事实上有一个更一般的结果:假设对于一串连续函数<span class="math inline">\(f_n(x)\in C[a,b]\)</span>,已知<span class="math inline">\(\exists x_0\in [a,b]\)</span>,<span class="math inline">\(\lim_{n\to
\infty}f_n(x_0)\)</span>存在.若对于<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,<span class="math inline">\(\exists
N&gt;0,\forall n,m\geq N\)</span>,函数<span class="math inline">\(g(x)=f_n(x)-f_m(x)\)</span>的李氏常数<span class="math inline">\(&lt;\epsilon\)</span>.则我们可以推出<span class="math inline">\(\{f_n(x)\}\)</span>一致收敛,设<span class="math inline">\(f_n(x)\rightrightarrows
f(x)\)</span>,若对于某个<span class="math inline">\(x\in
[a,b]\)</span>,如果<span class="math inline">\(f_n&#39;(x)\)</span>恒存在,而且<span class="math inline">\(\lim_{n\to \infty}
f_n&#39;(x)\)</span>存在,则<span class="math inline">\(f&#39;(x)\)</span>存在而且<span class="math inline">\(f&#39;(x)=\lim_{n\to \infty}
f_n&#39;(x)\)</span>.</p>
<p>这个结论当然要严格强于原本的结论,因为闭区间上的可导函数自然是李氏连续函数,如若<span class="math inline">\(f_n&#39;(x)\)</span>一致连续,当然能推出上述的李氏连续性质,立刻得到原本结论.</p>
<p>下面考虑证明:<span class="math inline">\(\forall
\epsilon&gt;0,\exists N,\forall n,m\geq N\)</span>,都有<span class="math inline">\(|f_n(x_0)-f_m(x_0)|&lt;\frac{\epsilon}{2}\)</span>,并且<span class="math inline">\(f_n(x)-f_m(x)\)</span>的李氏常数<span class="math inline">\(&lt;\frac{\epsilon}{2(b-a)}\)</span>.注意到此时:</p>
<p><span class="math display">\[
|f_n(x)-f_m(x)|\\
\leq |f_n(x)-f_m(x)-(f_n(x_0)-f_m(x_0))|+|f_n(x_0)-f_m(x_0)|\\
&lt; \frac{\epsilon}{2(b-a)}|x-x_0|+\frac{\epsilon}{2}\leq \epsilon
\]</span></p>
<p>这就证明了<span class="math inline">\(f_n\)</span>一致收敛,不妨设<span class="math inline">\(f_n\rightrightarrows f\)</span>.</p>
<p>接下来对于某个<span class="math inline">\(x\in
[a,b]\)</span>,定义<span class="math inline">\(\varphi_n(t)=\frac{f_n(t)-f_n(x)}{t-x},t\in
[a,b]\setminus \{x\}\)</span>,并补定义<span class="math inline">\(\varphi(t)=\frac{f(t)-f(x)}{t-x},t\in
[a,b]\setminus \{x\}\)</span>.显然<span class="math inline">\(\varphi_n(t)\in C[a,b]\setminus \{x\}\)</span></p>
<p>首先注意到:</p>
<p><span class="math display">\[
|\varphi_n(t)-\varphi_m(t)|\\
=\frac{1}{|t-x|}|f_n(t)-f_m(t)-(f_n(x)-f_m(x))|\\
\leq \frac{1}{|t-x|}\frac{\epsilon}{2(b-a)}|t-x|\\
=\frac{\epsilon}{2(b-a)}
\]</span></p>
<p>于是<span class="math inline">\(\varphi_n(t)\)</span>一致收敛,而且容易见到<span class="math inline">\(\varphi_n\rightrightarrows
\varphi\)</span>.从而:</p>
<p><span class="math display">\[
f&#39;(x)=\lim_{t\to x}\varphi(t)\\
=\lim_{t\to x}\lim_{n\to \infty}\varphi_n(t)\\
=\lim_{n\to \infty}\lim_{t\to x}\varphi_n(t)\\
=\lim_{n\to \infty}f_n&#39;(x)
\]</span></p>
<p>这就搞定了.</p>
<p>容易发现上述的推论是可导函数列的收敛性质(并不需要<span class="math inline">\(C^1\)</span>).而且我们还可以推出一个推论:那就是导函数一致收敛到的函数也是导函数.</p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(\{q_n\}\)</span>是<span class="math inline">\([0,1]\)</span>中的全体有理数排成的数列.定义<span class="math inline">\(f(x)=\sum_{n=1}^\infty \frac{|x-q_n|}{3^n},x\in
[0,1]\)</span>.</p>
<p>首先用大M判别法,注意到<span class="math inline">\(\frac{|x-q_n|}{3^n}\leq
\frac{1}{3^n}\)</span>,而每一项都是连续的,所以总的<span class="math inline">\(f(x)\)</span>是连续函数,而且这个定义也是收敛的.而且对于<span class="math inline">\(x_0\in [0,1]\setminus \mathbb{Q}\)</span>,<span class="math inline">\(f_n&#39;(x_0)\)</span>当然都是存在的,而且见到<span class="math inline">\(f_n&#39;(x_0)=\sum_{k=1}^n\frac{\text{sgn}(x_0-q_k)}{3^k}\)</span>,并且这个导数还足够小.因此立刻见到当<span class="math inline">\(n,m\)</span>足够大的时候,立刻见到<span class="math inline">\(f_n-f_m\)</span>的李氏常数可以尽可能小.</p>
<p>于是套用上面的结论可以知道<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([0,1]\setminus
\mathbb{Q}\)</span>处可导.那么其在<span class="math inline">\(\mathbb{Q}\cap [0,1]\)</span>上可导么?如若<span class="math inline">\(x\in \mathbb{Q}\)</span>,不妨设<span class="math inline">\(x=q_n\)</span>,则考虑<span class="math inline">\(f(x)=\frac{|x-q_n|}{3^n}+\sum_{k\ne
n}\frac{|x-q_k|}{3^k}\)</span>,前半部分在<span class="math inline">\(q_n\)</span>处不可导可后半部分在<span class="math inline">\(q_n\)</span>处可导,于是总和当然不可导.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f(x)=\sum_{n=1}^\infty\frac{\sin
(nx)}{n^3}\)</span>,求其导函数.</p>
<p>观察到<span class="math inline">\(\sum_{n=1}^\infty|(\frac{\sin
(nx)}{n^3})&#39;|\leq \sum
\frac{1}{n^2}&lt;\infty\)</span>,所以其导函数也绝对一致收敛.立刻能推出<span class="math inline">\(f\in
C^1(-\infty,+\infty)\)</span>,而且导函数就是逐项求导的<span class="math inline">\(f&#39;(x)=\sum_{n=1}^\infty\frac{\cos(nx)}{n^2}\)</span>.</p>
<h4><span id="部分应用">部分应用</span></h4>
<h5><span id="borel引理">Borel引理</span></h5>
<p>对任何一个实数列<span class="math inline">\(\{a_n\}\)</span>,都存在一个函数<span class="math inline">\(f(x)\in C^{\infty}(\mathbb{R})\)</span>,满足<span class="math inline">\(f^{(n)}(0)=a_n\)</span>.</p>
<p>考虑造一个<span class="math inline">\(g(x)=\begin{cases}1&amp;0\leq
x\leq \frac{1}{2}\\0&amp;x\geq
1\end{cases}\)</span>,其中中间少了一段用磨光核连起来.考虑造一个单调递增无界正数列<span class="math inline">\(\{\lambda_n\}\)</span>,并取:</p>
<p><span class="math display">\[
f(x)=\sum_{n=0}^\infty\frac{a_nx^n}{n!}g(\lambda_n|x|)
\]</span></p>
<p>这个的好处是什么呢?我们发现当<span class="math inline">\(\lambda_n|x|\geq 1\)</span>,<span class="math inline">\(|x|\geq \frac{1}{\lambda_n}\)</span>的时候<span class="math inline">\(g(\lambda_n|x|)=0\)</span>,又因为<span class="math inline">\(\lambda_n\)</span>单调递增趋近于无穷,所以除了<span class="math inline">\(0\)</span>以外的所有点上都是有限和,因此全都收敛而且全都可导,所以<span class="math inline">\(f\in C^{\infty}(\mathbb{R}\setminus
\{0\})\)</span>.</p>
<p>考虑<span class="math inline">\(f_n(x)=\frac{a_nx^n}{n!}g(\lambda_n|x|)\)</span>,这个当然是<span class="math inline">\(C^{\infty}\)</span>的.并且当然有<span class="math inline">\(f_n^{(n)}(0)=a_n\)</span>.现在如果我们能搞定这个导数级数的收敛性就搞定了<span class="math inline">\(0\)</span>处的可导性了对吧.取<span class="math inline">\(M_k=\max_{0\leq l\leq
k}|g^{(l)}|\)</span>,考虑:</p>
<p><span class="math display">\[
|f_n^{(k)}(x)|\leq
\frac{|a_n|}{n!}\sum_{m=0}^k\left|\binom{k}{m}n^{\underline{k-m}}x^{n-k+m}g^{(m)}(\lambda_n|x|)\lambda_n^m\right|\\
\leq
\frac{|a_n|}{n!}\sum_{m=0}^k\left|\binom{k}{m}n^{\underline{k-m}}x^{n-k+m}M_k\lambda_n^m\right|\\
\]</span></p>
<p>注意这里的<span class="math inline">\(x\)</span>一定很小,<span class="math inline">\(|x|&lt;\frac{1}{\lambda_n}\)</span>的时候上式才有意义,开始放缩:</p>
<p><span class="math display">\[
|f_n^{(k)}(x)|\leq
\frac{|a_n|}{n!}\sum_{m=0}^k\left|\frac{k!}{m!(k-m)!}n^{\underline{k-m}}M_k\frac{1}{\lambda_n^{n-k}}\right|\\
\leq
\frac{|a_n|}{n!}\sum_{m=0}^k\left|\frac{k!}{m!(k-m)!}n^{\underline{k-m}}M_k\frac{1}{\lambda_n^{n-k}}\right|\\
=\frac{|a_n|}{n!}\sum_{m=0}^k\left|\frac{k!}{m!(k-m)!}\frac{n!}{(n-k+m)!}M_k\frac{1}{\lambda_n^{n-k}}\right|\\
\leq |a_n|M_k\frac{1}{\lambda_n^{n-k}}k!
\]</span></p>
<p>显然只需取足够小的<span class="math inline">\(\lambda_n\)</span>就控制住了.</p>
<h5><span id="维尔斯特拉斯函数">维尔斯特拉斯函数</span></h5>
<p>考虑造一个处处连续处处不可导的函数,首先它应该在任何一个区间上都没有单调性(因为单调函数几乎处处可导).</p>
<p>首先造一个连续的<span class="math inline">\(2\)</span>周期函数<span class="math inline">\(h(x)=\begin{cases}x&amp;0\leq x\leq
1\\2-x&amp;1\leq x\leq
2\\h(x-2)&amp;otherwise\end{cases}\)</span>.或者我们干脆定义<span class="math inline">\(h(x)=\sin(\frac{\pi}{2}4^nx)\)</span>,这样这个函数更光滑一点,但对论证没有区别.</p>
<p>考虑造<span class="math inline">\(f(x)=\sum_{n=0}^{\infty}(\frac{3}{4})^n
h(4^nx)\)</span>,注意到:</p>
<p><span class="math display">\[
f(x)\leq \sum(\frac{3}{4})^n&lt;\infty
\]</span></p>
<p>根据大M判别法,所以这个函数的确绝对一致收敛.那这个函数就确实继承了连续性.</p>
<p>首先有引理:如果<span class="math inline">\(f&#39;(x_0)\)</span>存在,而且<span class="math inline">\(\alpha_n\leq x_0\leq
\beta_n,0&lt;\beta_n-\alpha_n\to 0\)</span>,则<span class="math inline">\(\lim_{n\to
\infty}\frac{f(\beta_n)-f(\alpha_n)}{\beta_n-\alpha_n}\to
f&#39;(x_0)\)</span>.取<span class="math inline">\(\lambda_n=\frac{\beta_n-x_0}{\beta_n-\alpha_n}\)</span>,容易见到<span class="math inline">\(0\leq \lambda_n\leq 1\)</span>,见到:</p>
<p><span class="math display">\[
\frac{f(\beta_n)-f(\alpha_n)}{\beta_n-\alpha_n}-f&#39;(x_0)\\
=\lambda_n(\frac{f(\beta_n)-f(x_0)}{\beta_n-x_0}-f&#39;(x_0))+(1-\lambda_n)(\frac{\alpha_n-f(x_0)}{\alpha_n-x_0}-f&#39;(x_0))
\]</span></p>
<p>容易见到趋近于<span class="math inline">\(0\)</span>.不过要简单判断一下<span class="math inline">\(\alpha_n=x_0\)</span>的情况.</p>
<p>既然如此,<span class="math inline">\(\forall x\in
\mathbb{R}\)</span>,考虑定义<span class="math inline">\(\alpha_m=\frac{\lfloor4^m
x\rfloor}{4^m},\beta_m=\alpha_m+\frac{1}{4^m}\)</span>,容易见到<span class="math inline">\(\alpha_m\leq x&lt; \beta_m\)</span>.并且当<span class="math inline">\(n\leq m\)</span>的时候，<span class="math inline">\((4^n\alpha_m,4^n\beta_m)\)</span>上不存在整数.</p>
<p>见到:</p>
<p><span class="math display">\[
4^n(\beta_m-\alpha_m)=\begin{cases}\in
4\mathbb{N}&amp;n&gt;m\\1&amp;n=m\\&lt;1&amp;otherwise\end{cases}
\]</span></p>
<p>于是:</p>
<p><span class="math display">\[
|h(4^n \beta_m)-h(4^n\alpha_m)|=\begin{cases}0&amp;n&gt;m\\
|4^n\beta_m-4^n\alpha_m|=4^{n-m}&amp;n\leq m\end{cases}
\]</span></p>
<p>把<span class="math inline">\(n&lt;m\)</span>的地方往负了放,自然有:</p>
<p><span class="math display">\[
|f(\beta_m)-f(\alpha_m)|=\begin{cases}\sum_{n=0}^m(\frac{3}{4})^n(h(4^n\beta_m)-h(4^n\alpha_m))\end{cases}\\
\geq (\frac{3}{4})^m-\sum_{k=0}^{m-1}(\frac{3}{4})^n4^{n-m}\\
=(\frac{3}{4})^m-\frac{1}{4^m}\frac{3^m-1}{2}\\
=\frac{1}{4^m}\frac{3^m+1}{2}
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
\frac{|f(\beta_m)-f(\alpha_m)|}{\beta_m-\alpha_m}\geq \frac{3^m+1}{2}
\]</span></p>
<p>然而如若这点导数存在,那么这里的导数就是<span class="math inline">\(\lim_{m\to
\infty}\frac{3^m+1}{2}=\infty\)</span>,这就矛盾了.因此这个函数处处不可导.</p>
<h5><span id="连续曲线充满平面">连续曲线充满平面</span></h5>
<p>存在充满<span class="math inline">\([0,1]\times
[0,1]\)</span>的连续曲线.连续曲线在这里定义为<span class="math inline">\((x(t),y(t)),t\in [0,1]\)</span>满足<span class="math inline">\(x(t),y(t)\in C[0,1]\)</span>,任意<span class="math inline">\((a,b)\in [0,1]\times [0,1]\)</span>,都存在<span class="math inline">\(t\)</span>使得<span class="math inline">\(a=x(t),b=y(t)\)</span>.</p>
<p>搞一个连续函数<span class="math inline">\(g(t)\)</span>满足:</p>
<p><span class="math display">\[
g(t)=\begin{cases}
0&amp;t\in [0,\frac{1}{3}]\cup [\frac{5}{3},2]\\
3t-1&amp;t\in [\frac{1}{3},\frac{2}{3}]\\
1&amp;t\in [\frac{2}{3},\frac{4}{3}]\\
3t+5&amp;t\in [\frac{4}{3},\frac{5}{3}]\\
\end{cases}
\]</span></p>
<p>并且满足<span class="math inline">\(g(t+2)=g(t)\)</span>,也就是一个周期梯形函数.</p>
<p>接下来定义:</p>
<p><span class="math display">\[
x(t)=\sum_{n=1}^\infty\frac{1}{2^n}g(3^{2n-2}t)\\
y(t)=\sum_{n=1}^\infty\frac{1}{2^n}g(3^{2n-1}t)
\]</span></p>
<p>容易发现<span class="math inline">\(0\leq x(t),y(t)\leq
\sum_{n=1}^\infty
\frac{1}{2^n}=1\)</span>,所以的确绝对一致收敛,继承了连续性而且确实在<span class="math inline">\([0,1]\times [0,1]\)</span>中.</p>
<p>接下来<span class="math inline">\(\forall (a,b)\in [0,1]\times
[0,1]\)</span>,我们尝试找到一个<span class="math inline">\(t\)</span>使得<span class="math inline">\(a=x(t),b=y(t)\)</span>.考虑取二者的二进制表示<span class="math inline">\(a=\sum_{n=1}^\infty\frac{a_n}{2^n},b=\sum_{n=1}^\infty\frac{b_n}{2^n}\)</span>,其中<span class="math inline">\(a_n,b_n\in \{0,1\}\)</span>.取一个新的数列<span class="math inline">\(c_{2n-1}=a_n,c_{2n}=b_n\)</span>.取<span class="math inline">\(0\leq c=2\sum_{n=1}^\infty \frac{c_n}{3^n}\leq
1\)</span>,下面我们证明<span class="math inline">\(x(c)=a,x(c)=b\)</span>.</p>
<p>考虑<span class="math inline">\(3^kc=2\sum_{n=1}^k\frac{c_n}{3^{n-k}}+2\sum_{n=k+1}^\infty\frac{c_n}{3^{n-k}}\)</span>.其中前半部分是个偶整数,因此在带入函数<span class="math inline">\(g\)</span>后会消失,观察后半部分,容易见到:如果<span class="math inline">\(c_{k+1}=0\)</span>,则后半部分<span class="math inline">\(\leq \frac{1}{3}\)</span>;如果<span class="math inline">\(c_{k+1}=1\)</span>,则后半部分<span class="math inline">\(\geq \frac{2}{3}\)</span>,因此<span class="math inline">\(g(3^kc)=c_{k+1}\)</span>.带入原式定义就看到<span class="math inline">\(x(c)=a,y(c)=b\)</span>.</p>
<p>甚至说,这里的<span class="math inline">\(c\)</span>其实就在康托尔三分集中,所以事实上这个曲线上的零测集就足以覆盖整个平面.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>被地球创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%9C%B0%E7%90%83%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#开普勒第二定律">开普勒第二定律</a></li>
<li><a href="#开普勒第三定律">开普勒第三定律</a></li>
<li><a href="#开普勒第一定律">开普勒第一定律</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p>大家高中都学过开普勒三定律对吧!下面我们来证明它们是对的.</p>
<p>由于难度不太一样,我们微调一下顺序.</p>
<h3><span id="开普勒第二定律">开普勒第二定律</span></h3>
<p>根据角动量守恒,当然有<span class="math inline">\(\vec r\times \vec
p=C\)</span>为定值.又根据机械能守恒,其在某一个点的机械能应该为<span class="math inline">\(-\frac{GmM}{r}+\frac{p^2}{2m}\)</span>.</p>
<p>先考虑证明开普勒第二定律,取一段极小时间<span class="math inline">\(\text d t\)</span>,考虑掠过的面积应该是<span class="math inline">\(\text d S=\frac {1}{2}\vec r\times (\vec r+\text d
\vec r)=\frac {1}{2}\vec r\times \text d \vec
r\)</span>,于是掠面速度<span class="math inline">\(V=\frac{\text d
S}{\text d t}=\frac {1}{2m}\vec r\times \vec p\)</span>是一个常数.</p>
<h3><span id="开普勒第三定律">开普勒第三定律</span></h3>
<p>那么<span class="math inline">\(T=\frac{S}{V}=\frac{2m\times
ab\pi}{\vec r\times \vec p}=mab\frac{2\pi}{C}\)</span>.</p>
<p>那么<span class="math inline">\(\frac{T^2}{a^3}=\frac{4\pi^2
m^2b^2}{aC^2}\)</span>.</p>
<p>根据机械能守恒,当然应该有在近日点和远日点机械能相等,那自然有: <span class="math display">\[
-\frac{GmM}{a+c}+\frac{C^2}{2m(a+c)^2}=-\frac{GmM}{a-c}+\frac{C^2}{2m(a-c)^2}\\
m^2=C^2\frac{a}{b^2GM}
\]</span> 带入得到<span class="math inline">\(\frac{T^2}{a^3}=\frac{4\pi^2}{GM}\)</span>是一个定值.</p>
<h3><span id="开普勒第一定律">开普勒第一定律</span></h3>
<p>我们知道圆锥曲线的极坐标方程是:</p>
<p><span class="math display">\[
r(\theta)=\frac{ep}{1-e\cos\theta}
\]</span></p>
<p>其中<span class="math inline">\(e\)</span>是离心率,<span class="math inline">\(p\)</span>是准焦距(焦点到准线的距离).</p>
<p>后面不会了,开摆!</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心与构造</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#排除不优策略">排除不优策略</a>
<ul>
<li><a href="#example1cf1612e">Example1(CF1612E)</a></li>
<li><a href="#example2cf1592f1">Example2(CF1592F1)</a></li>
<li><a href="#example3cf1592f2">Example3(CF1592F2)</a></li>
<li><a href="#example4cf1666e">Example4(CF1666E)</a></li>
<li><a href="#example52022zrtg十连测day7-palindrome">Example5(2022zrtg十连测day7
Palindrome)</a></li>
<li><a href="#example623省选10连测-day9-c">Example6(23省选10连测 day9
C)</a></li>
<li><a href="#example7异或粽子">Example7(异或粽子)</a></li>
<li><a href="#example8">Example8()</a></li>
</ul></li>
<li><a href="#带悔贪心">带悔贪心</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
<li><a href="#example1eer1代价">Example1([EER1]代价)</a></li>
<li><a href="#example2loj3318">Example2(loj3318)</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</a></li>
<li><a href="#example5cf1098deels">Example5([CF1098D]Eels)</a></li>
<li><a href="#example6称球游戏">Example6(称球游戏)</a>
<ul>
<li><a href="#信息论">信息论</a></li>
<li><a href="#判定树">判定树</a></li>
<li><a href="#子问题1已知次品重量">子问题1(已知次品重量)</a></li>
<li><a href="#子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</a></li>
<li><a href="#子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</a></li>
<li><a href="#子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</a></li>
</ul></li>
<li><a href="#example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8
H)</a></li>
<li><a href="#模型1">模型1</a>
<ul>
<li><a href="#example1国王游戏">Example1(国王游戏)</a></li>
<li><a href="#模型通解">模型通解</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul></li>
<li><a href="#模型2">模型2</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#构造">构造</a>
<ul>
<li><a href="#增量构造">增量构造</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
<li><a href="#example3cf1770h">Example3(CF1770H)</a></li>
<li><a href="#example4abc232h">Example4(ABC232H)</a></li>
</ul></li>
<li><a href="#找中间状态">找中间状态</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p>##贪心</p>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了<span class="math inline">\(t\)</span>个消息<span class="math inline">\(a_1,a_2,...,a_t\)</span>,那么答案就是<span class="math inline">\(\sum[\exists
j,m_i=a_j]\cfrac{\min(t,k_i)}{t}\)</span>.显然如果<span class="math inline">\(t\)</span>固定,那么每个<span class="math inline">\(a_j\)</span>的贡献是独立的.于是只需要枚举<span class="math inline">\(t\)</span>然后取贡献最大的.</p>
<p>但是,如果<span class="math inline">\(t&gt;\max\{k_i\}\)</span>,这个时候<span class="math inline">\(t-1\)</span>的答案是<span class="math inline">\(t-1\)</span>个数之和除以<span class="math inline">\(t-1\)</span>,<span class="math inline">\(t\)</span>的答案是这<span class="math inline">\(t-1\)</span>个数之和加上另一个更小的数除以<span class="math inline">\(t\)</span>,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度<span class="math inline">\(O(n\max\{k_i\})\)</span>.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分(<span class="math inline">\(b_{i,j}=a_{i,j}\oplus a_{i+1,j}\oplus
a_{i,j+1}\oplus
a_{i+1,j+1}\)</span>)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是<span class="math inline">\(0\)</span>了,那么矩阵外不可能是<span class="math inline">\(1\)</span>,也就是原矩阵也全都是<span class="math inline">\(0\)</span>了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成<span class="math inline">\(0\)</span>才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对<span class="math inline">\((x,y)\)</span>使用操作四,那我们不可能再对一个<span class="math inline">\((x,i)\)</span>使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有<span class="math inline">\(b_{x,y},b_{n,y},b_{x,m}\)</span>都是<span class="math inline">\(1\)</span>的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个<span class="math inline">\(1\)</span>,所以一定不如直接用一操作来的划算.不然,如果三个都是<span class="math inline">\(1\)</span>,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后<span class="math inline">\(b_{n,m}\)</span>变成<span class="math inline">\(1\)</span>了,再不行也可以使用一次<span class="math inline">\(1\)</span>操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果<span class="math inline">\(b_{x,y},b_{n,y},b_{x,m}\)</span>都是<span class="math inline">\(1\)</span>,我们就把<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移: <span class="math display">\[
f_{i+1}=\max\{a_{i+1},f_i+mn\}\\
g_{i+1}=\min\{a_{i+2},g_i+mx\}\\
\]</span> 注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([f_i,g_i]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{i}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ans_{i+1}-mx,ans_{i+1}-mn]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([f_i,g_i]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{i+1}-mn&lt;f_i,f_{i+1}&lt;ans_{i+1}&lt;f_i+mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx-mn\)</span>.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对<span class="math inline">\((l,r)\)</span>,我们想给每一个点对赋值:<span class="math inline">\(a_l=i,a_r=n-i+1\)</span>(注意如果<span class="math inline">\(n\)</span>是奇数,那么中心点应该是<span class="math inline">\(a_{mid}=\frac{n+1}{2}\)</span>),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对<span class="math inline">\((l_1,r_1)\)</span>,<span class="math inline">\((l_2,r_2)\)</span>之间的三种可能的关系:不交,包含,相交且不包含.会发现若<span class="math inline">\(l\)</span>小则让<span class="math inline">\(a_l\)</span>尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个<span class="math inline">\(\pm
1\)</span>操作很奇怪.我们不妨这么考虑:设最后的答案序列为<span class="math inline">\(b\)</span>,那么答案其实就是<span class="math inline">\(\sum
|b_i-a_i|\)</span>.这实际上是什么呢?实际上是数轴上<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>之间的距离.既然这样,那么我们同时反转<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个<span class="math inline">\(a\)</span>,将它和<span class="math inline">\(x\)</span>同时反转,那么答案不变.这么做后我们可以直接清空所有<span class="math inline">\(a\)</span>的最高位,只剩下<span class="math inline">\(x\)</span>可能有最高位.</p>
<p>那<span class="math inline">\(x\)</span>的最高位一定会让若干<span class="math inline">\(a\)</span>往上变成它.注意到最多只会有一个<span class="math inline">\(a\)</span>会向上满足<span class="math inline">\(x\)</span>的最高位.证明的话同样考虑取反,如果有两个<span class="math inline">\(a\)</span>满足<span class="math inline">\(a_i\oplus b_i\)</span>和<span class="math inline">\(a_j\oplus b_j\)</span>这一位是<span class="math inline">\(1\)</span>,我们仍然考虑数轴,有<span class="math inline">\(|not(b_i)-a_i|\leq |a_i-b_i|\)</span>,这由<span class="math inline">\(a_i\oplus b_i\)</span>最高位是<span class="math inline">\(1\)</span>导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个<span class="math inline">\(a\)</span>上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的<span class="math inline">\(a\)</span>可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作<span class="math inline">\([l,r,k]\)</span>表示可以将<span class="math inline">\(a[l\cdots r]\)</span>减一进行至多<span class="math inline">\(k\)</span>次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个<span class="math inline">\(-1\)</span>,另一个<span class="math inline">\(-2\)</span>,求使得整个序列都小于等于<span class="math inline">\(0\)</span>的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</li>
<li>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</li>
<li>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做<span class="math inline">\((-2,-1)\)</span>,最后不够了再加个<span class="math inline">\((-1,-2)\)</span>补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候<span class="math inline">\((-1,-2)+(-1,-2)\)</span>比<span class="math inline">\((-2,-1)\)</span>更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做<span class="math inline">\((-2,-1)\)</span>,最后不够了再加个<span class="math inline">\((-1,-2)\)</span>补一下.我们通过样例以及其它栗子发现:有的时候<span class="math inline">\((-1,-2)+(-1,-2)\)</span>比<span class="math inline">\((-2,-1)\)</span>更优秀,这启发我们:能不能在做后面位置的时候将前面的<span class="math inline">\((-2,-1)\)</span>变成<span class="math inline">\((-1,-2)+(-1,-2)\)</span>呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个<span class="math inline">\((-2,-1)\)</span>操作,那么我可以在这个位置进行一个<span class="math inline">\((0,-3)\)</span>操作.显然<span class="math inline">\((0,-3)+(-2,-1)=(-1,-2)+(-1,-2)\)</span>.我们完成了反悔的操作!</p>
<p>但是,我们直接认为<span class="math inline">\((-1,-2)\)</span>不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个<span class="math inline">\((-1,-2)+(-1,-2)\)</span>,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑<span class="math inline">\((-3,0)\)</span>怎么反悔.这个看上去很疑惑:我们为了使<span class="math inline">\((-2,-1)\)</span>变成<span class="math inline">\((-1,-2)+(-1,-2)\)</span>而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在<span class="math inline">\((-2,-1)\)</span>的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:<span class="math inline">\((-3,0)\)</span>这个技能的发动是有前提条件的:前面必须有<span class="math inline">\((-2,-1)\)</span>才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个<span class="math inline">\((-2,-1)\)</span>,也很清楚每个地方用了几个<span class="math inline">\((-3,0)\)</span>.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:<span class="math inline">\((-3,0)\rightarrow
(-1,-2)+(-2,-1)=(-3,0)+(0,-3)\)</span>,或者<span class="math inline">\((-3,0)\rightarrow
(-1,-2)+(-1,-2)+(-1,-2)=(-3,0)+(0,-3)+(0,-3)\)</span>.</p>
<p>最后遇到一个点,能用<span class="math inline">\((0,-3)\)</span>就用<span class="math inline">\((0,-3)\)</span>,不够用的再补齐.这个原因也很简单:如果我们在这里不用<span class="math inline">\((-3,0)\)</span>而用其它的代替的话,你会发现无论如何都等价于<span class="math inline">\((-3,0)\)</span>然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的<span class="math inline">\((-2,-1)\)</span>和<span class="math inline">\((-1,-2)\)</span>的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的<span class="math inline">\((-3,0)\)</span>操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<p>###寻找下界并证明</p>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,保证<span class="math inline">\(a_1=a_n=1\)</span>.每次你可以选择一个<span class="math inline">\(i(1&lt;i&lt;n)\)</span>将<span class="math inline">\(a_i\)</span>删去并付出<span class="math inline">\(a_{i-1}a_ia_{i+1}\)</span>的代价.删去<span class="math inline">\(a_i\)</span>后序列两端会接起来,求删成两个<span class="math inline">\(1\)</span>的最小代价.</p>
<p>首先注意到,如果有一个<span class="math inline">\(1&lt;i&lt;n\)</span>满足<span class="math inline">\(a_i=1\)</span>,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要<span class="math inline">\(1\)</span>的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个<span class="math inline">\(1\)</span>所划分.接下来我们只考虑中间所有数<span class="math inline">\(\geq 2\)</span>的情况.</p>
<p>再思考一个事实:当<span class="math inline">\(a,b\geq
2\)</span>时,一定有<span class="math inline">\(ab\geq
a+b\)</span>.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是<span class="math inline">\(\sum_{i=2}^{n-2}a_ia_{i+1}+\min_{i=2}^{n-1}{a_i}\)</span>.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造<span class="math inline">\(a\)</span>数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值<span class="math inline">\(a_i\)</span>,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑<span class="math inline">\(a_i\)</span>互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数<span class="math inline">\(\leq\)</span>还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在<span class="math inline">\(a_i\)</span>相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的<span class="math inline">\((a_i,a_{i+1})\)</span>,然后这么选:<span class="math inline">\(a_i,a_{i+1},a_n,a_{i-1},a_{n-1},a_{i-2}...\)</span>,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在<span class="math inline">\(a_i\)</span>上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,其中<span class="math inline">\(2a&lt;b\)</span>.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果<span class="math inline">\(b\)</span>之前吃过别的鱼,假设是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>(不妨假设<span class="math inline">\(d\geq c\)</span>),有<span class="math inline">\(b=c+d\)</span>,由鸽笼原理,发现<span class="math inline">\(d&gt;a\)</span>.这意味着:如果<span class="math inline">\(a\)</span>都没被操作掉,那么<span class="math inline">\(d\)</span>必不可能被操作掉,这也就是说<span class="math inline">\(b\)</span>不可能出现.因此<span class="math inline">\(b\)</span>在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于<span class="math inline">\(b\)</span>,且<span class="math inline">\(a\)</span>就是所有一开始小于<span class="math inline">\(b\)</span>的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是<span class="math inline">\(w_i&gt;2\sum_{j=1}^{i-1}w_j\)</span>,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多<span class="math inline">\(\log
w\)</span>个,我们考虑一下这个两倍的用处,我们按照值域<span class="math inline">\([1,1],[2,2],[3,4],[5,8],...,[2^{k-1}+1,2^k]\)</span>将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><span class="math inline">\(S\)</span>表示标准球.</li>
<li><span class="math inline">\(&lt;A,B&gt;\)</span>表示称量集合<span class="math inline">\(A\)</span>和集合<span class="math inline">\(B\)</span>,<span class="math inline">\(&lt;A,B&gt;=0\)</span>表示平衡,<span class="math inline">\(&lt;A,B&gt;=A\)</span>表示<span class="math inline">\(A\)</span>较重,<span class="math inline">\(&lt;A,B&gt;=B\)</span>表示<span class="math inline">\(B\)</span>较重.</li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量<span class="math inline">\(x\)</span>有<span class="math inline">\(n\)</span>种取值,出现概率分别为<span class="math inline">\(p_1,p_2,\cdots,p_n\)</span>,则其熵为<span class="math inline">\(H(x)=f(p_1,p_2,\cdots ,p_n)=\sum{C p_i\ln
\frac{1}{p_i}}\)</span>,<span class="math inline">\(C\)</span>为正整数,通常取<span class="math inline">\(1\)</span>.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量<span class="math inline">\(x\)</span>的一个熵为<span class="math inline">\(h\)</span>的信息后,<span class="math inline">\(x\)</span>的熵会减少<span class="math inline">\(h\)</span>.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有<span class="math inline">\(n\)</span>个球,每个球等概率成为次品,因此总熵是<span class="math inline">\(\ln
n\)</span>,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是<span class="math inline">\(\ln 3\)</span>,也就是说我们至少要猜<span class="math inline">\(\frac{\ln n}{\ln 3}=\log_3
n\)</span>次.如果我们不知道次品的轻重,那么至少要猜<span class="math inline">\(\frac{\ln 2n}{\ln 3}=\log_3 2n\)</span>次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p><span class="math inline">\(n\)</span>个叶子的树的最小深度是<span class="math inline">\(\lceil\log_3
n\rceil\)</span>,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设<span class="math inline">\(f(n)\)</span>表示有<span class="math inline">\(n\)</span>个球的最少次数,注意到<span class="math inline">\(f(3)=1\)</span>.</p>
<p>根据信息论,<span class="math inline">\(f(n)\geq \lceil\log_3
n\rceil\)</span>,下面证明等号成立:</p>
<p>首先考虑证明<span class="math inline">\(f(3^m)=m\)</span>,<span class="math inline">\(m=1\)</span>时已经得证.<span class="math inline">\(m&gt;1\)</span>时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此<span class="math inline">\(f(3^m)\leq
f(3^{m-1})+1\)</span>.综合信息论下界<span class="math inline">\(f(3^m)\geq
m\)</span>,我们不难得出以上结论.至于<span class="math inline">\(n\ne
3^m\)</span>的情况,我们类似这个过程按照<span class="math inline">\(n\bmod 3\)</span>的值讨论一下即可,于是有<span class="math inline">\(f(n)\leq f(\lceil\frac n3\rceil)+1\)</span>.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,<span class="math inline">\(f(n)\geq \lceil\log_3
2n\rceil\)</span>.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有<span class="math inline">\(n\)</span>个球,第二堆有<span class="math inline">\(m\)</span>个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是<span class="math inline">\(g(n,m)\)</span>,则<span class="math inline">\(g(n,m)=\lceil\log_3(n+m)\rceil\)</span>.</p>
<p>先证明信息论下界,不难发现仍然是<span class="math inline">\(g(n,m)=\lceil\log_3(n+m)\rceil\)</span>.</p>
<p>首先不难发现,<span class="math inline">\(g(1,0)=g(0,1)=0,g(1,1)=g(2,0)=g(0,2)=1\)</span>.</p>
<p>仍然使用数学归纳,假设<span class="math inline">\(n+m&lt;k(k\geq
3)\)</span>的时候成立,我们接下来证明<span class="math inline">\(n+m=k\)</span>的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若<span class="math inline">\(n=3p,m=3q\)</span>,我们将<span class="math inline">\(n\)</span>分成等数量的三堆:<span class="math inline">\(A_1,B_1,C_1\)</span>,将<span class="math inline">\(m\)</span>分成等质量的三堆<span class="math inline">\(A_2,B_2,C_2\)</span>.</p>
<p>接下来称量<span class="math inline">\(\lang
A_1+A_2,B_1+B_2\rang\)</span>.</p>
<ol type="1">
<li>如果<span class="math inline">\(\langle A_1+A_2,B_1+B_2\rang=
0\)</span>,那么答案在<span class="math inline">\(C_1\cup
C_2\)</span>中,此时有<span class="math inline">\(g(n,m)=g(\frac{n}{3},\frac{m}{3})+1\)</span>.</li>
<li>如果<span class="math inline">\(\lang A_1+A_2,B_1+B_2\rang=
A_1+A_2\)</span>,由于若次品在<span class="math inline">\(A_2\)</span>中,那么它不可能是重球,因此次品不可能在<span class="math inline">\(A_2\)</span>中,同理不可能在<span class="math inline">\(B_1\)</span>中,只可能在<span class="math inline">\(A_1\cup B_2\)</span>中,此时有<span class="math inline">\(g(n,m)=g(\frac{n}{3},\frac{m}{3})+1\)</span>.</li>
<li><span class="math inline">\(\lang A_1+A_2,B_1+B_2\rang=
B_1+B_2\)</span>,同理.</li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p><span class="math inline">\(n=3p+1,m=3q+2\)</span>.此时我们将第一堆分成<span class="math inline">\(A_1(p),B_1(p),C_1(p+1)\)</span>,将第二堆分成<span class="math inline">\(A_2(q+1),B_2(q+1),C_2(q)\)</span>,然后<span class="math inline">\(\lang A_1
+A_2,B_1+B_2\rang\)</span>,接下来和情况1一样,于是有<span class="math inline">\(g(n,m)=\max\{g(p,q+1),g(p+1,q)\}=\lceil\log_3
\frac{n+m}3\rceil+1\)</span>.</p>
<p>同理,当<span class="math inline">\(n,m\bmod
3\)</span>的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论<span class="math inline">\(n\bmod 3\)</span>的值.</p>
<p><strong>情况1</strong></p>
<p>当<span class="math inline">\(n=3p\)</span>时,直接分成<span class="math inline">\(A(p),B(p),C(p)\)</span>,然后<span class="math inline">\(\lang A,B\rang\)</span>.如果平衡则接下来需要<span class="math inline">\(f(p)=\lceil\log_3
2p\rceil\)</span>次,不然根据引理,需要<span class="math inline">\(\lceil\log_3(p+p)\rceil\)</span>次,因此<span class="math inline">\(f(n)=\lceil\log_3 2p\rceil+1=\lceil\log_3
6p\rceil=\lceil\log_3 2n\rceil\)</span>.</p>
<p><strong>情况2</strong></p>
<p>当<span class="math inline">\(n=3p+1\)</span>时,一种自然的想法是分成<span class="math inline">\(A(p+1),B(p),C(p)\)</span>,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了<span class="math inline">\(2p+2,2p,2p\)</span>,这显然是不优秀的.正确的做法是分成<span class="math inline">\(A=\{S,1,\cdots p\},B=\{p+1,\cdots
2p+1\},C=\{2p+2,\cdots 3p+1\}\)</span>.由于存在标准球,此时如果<span class="math inline">\(\lang A,B\rang=A\ or\ B\)</span>,那么转化成<span class="math inline">\(g(p,p+1)=\lceil\log_3(2p+1)\rceil\)</span>,不然转化成<span class="math inline">\(f(p)=\lceil\log_32p\rceil\)</span>.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有<span class="math inline">\(n\bmod
3=1\)</span>的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题<span class="math inline">\(f(n)=\lceil\log_3(2n+2)\rceil\)</span>.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将<span class="math inline">\(a\)</span>个球放左边,<span class="math inline">\(b\)</span>个球放右边,<span class="math inline">\(a\leq b\)</span>,在左边补上<span class="math inline">\(b-a\)</span>个标准球.</p>
<ol type="1">
<li>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要<span class="math inline">\(\lceil\log_3(a+b)\rceil+1\)</span>步.</li>
<li>如果天平平衡,需要<span class="math inline">\(f(n-a-b)+1\)</span>步.</li>
</ol>
<p>我们有<span class="math inline">\(f(n)=\min_{a,b}\{\max\{f(n-a-b),\lceil\log_3(a+b)\rceil\}\}+1\)</span>.</p>
<p>注意到接下来的步数只与<span class="math inline">\(a+b\)</span>有关,取<span class="math inline">\(b-a\leq 1\)</span>,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到<span class="math inline">\(f(n)=\lceil\log_3(2n-1)\rceil\)</span>.</p>
<p>接下来归纳法就简单了,只需要对于<span class="math inline">\(n\bmod
3\)</span>的余数讨论一下,然后再讨论一下<span class="math inline">\(a\)</span>的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求<span class="math inline">\(n\)</span>所在位置.要求询问次数<span class="math inline">\(\leq \lceil1.5\log_2
n\rceil\)</span>,询问区间总长度<span class="math inline">\(\leq
3n\)</span>.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设<span class="math inline">\(T(n)\)</span>表示长度为<span class="math inline">\(n\)</span>的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程<span class="math inline">\(T(n)=\min_{m&lt;n}\{\max\{T(m)+1,T(n-m)+2\}\}\)</span>.</p>
<p>当然有<span class="math inline">\(m_n\leq
m_{n+1}\)</span>,于是直接dp即可.</p>
<p>###Exchange Arguments</p>
<h4><span id="模型1">模型1</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1,...,x_n\)</span>,以及一个定义域为这些元素的序列,定义域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,表达式<span class="math inline">\(F(\{x_{p_1},x_{p_2},...,x_{p_n}\})\)</span>最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个二元正整数对<span class="math inline">\((a_i,b_i)\)</span>,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的<span class="math inline">\(a\)</span>乘上序列中这个二元组之后的所有二元组的<span class="math inline">\(b\)</span>之和的总和,求最小代价.<span class="math inline">\(n,a_i,b_i\leq 10^6\)</span>.</p>
<p>转化为上面的形式,也即:<span class="math inline">\(F(\{(a_1,b_1),...,(a_n,b_n)\})=\sum_{1\leq
i&lt;j\leq k}a_ib_j\)</span>.</p>
<p>考虑调整法,令排列<span class="math inline">\((q_1,...,q_n)=(p_1,...,p_{i-1},p_{i+1},p_i,p_{i+2},...,p_n)\)</span>.则:
<span class="math display">\[
F(\{(a_{p_1},b_{p_1}),...,(a_{p_n},b_{p_n})\})-F(\{(a_{q_1},b_{q_1}),...,(a_{q_n},b_{q_n})\})=a_{p_i}b_{p_{i+1}}-a_{p_{i+1}}b_{p_i}
\]</span> 因而如果<span class="math inline">\(a_{p_i}b_{p_{i+1}}-a_{p_{i+1}}b_{p_i}&gt;0\)</span>,则<span class="math inline">\(F(\{(a_{p_1},b_{p_1}),...,(a_{p_n},b_{p_n})\})&gt;F(\{(a_{q_1},b_{q_1}),...,(a_{q_n},b_{q_n})\})\)</span>,也就是说<span class="math inline">\((p_1,...,p_n)\)</span>不是最优解.因此只有满足<span class="math inline">\(\forall 1\leq i&lt;n\)</span>,<span class="math inline">\(\cfrac{a_{p_i}}{b_{p_i}}\leq
\cfrac{a_{p_{i+1}}}{b_{p_{i+1}}}\)</span>可能是最优解.</p>
<p>如果一个<span class="math inline">\(p\)</span>满足这样的性质,则所有<span class="math inline">\(\cfrac{a}{b}\)</span>相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换<span class="math inline">\(\cfrac{a}{b}\)</span>相等的两个位置,是不会使答案改变的.因此直接按照<span class="math inline">\(\cfrac{a}{b}\)</span>排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为<span class="math inline">\(S\)</span>,定义<span class="math inline">\(S\)</span>上的一种二元比较关系<span class="math inline">\(\leq\)</span>,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li>强完全性:<span class="math inline">\(\forall a,b\in S\)</span>,<span class="math inline">\(a\leq b\or b\leq a=1\)</span>.</li>
<li>传递性:<span class="math inline">\(\forall a,b,c\in S\)</span>,<span class="math inline">\(a\leq b,b\leq c\Rightarrow a\leq c\)</span>.</li>
<li><span class="math inline">\(\forall a,b\in S\)</span>,如果<span class="math inline">\(a\leq b\)</span>,则对于任意一个包含<span class="math inline">\(\{a,b\}\)</span>作为子段的元素序列<span class="math inline">\(\{s_1,...,s_{k-1},a,b,s_{k+2},...,s_n\}\)</span>和<span class="math inline">\(\{s_1,...,s_{k-1},b,a,s_{k+2},...,s_n\}\)</span>都有:<span class="math inline">\(F(\{s_1,...,s_{k-1},a,b,s_{k+2},...,s_n\})\leq
F(\{s_1,...,s_{k-1},b,a,s_{k+2},...,s_n\})\)</span>.</li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义<span class="math inline">\(\leq\)</span>后自然也就定义了<span class="math inline">\(=\)</span>,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到<span class="math inline">\(\leq\)</span>的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个包含小写字符的字符串<span class="math inline">\(s_1,...,s_n\)</span>,找到一个<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,将<span class="math inline">\(s_{p_1},s_{p_2},...,s_{p_n}\)</span>顺序拼接得到<span class="math inline">\(S\)</span>,使<span class="math inline">\(S\)</span>的字典序最小.</p>
<p>令<span class="math inline">\(s\leq t\)</span>当且仅当<span class="math inline">\(s+t\)</span>的字典序<span class="math inline">\(\leq\)</span><span class="math inline">\(t+s\)</span>的字典序.显然满足性质(1)和(3).接下来只需要证明其满足传递性即可.</p>
<p>此时我们注意到:<span class="math inline">\(s+t\)</span>的字典序小于等于<span class="math inline">\(t+s\)</span>的字典序当且仅当<span class="math inline">\(s^{\infty}\leq
t^{\infty}\)</span>.原因是:不妨设<span class="math inline">\(s\)</span>的长度<span class="math inline">\(\leq
t\)</span>的长度.若<span class="math inline">\(s\)</span>不是<span class="math inline">\(t\)</span>的前缀,那显然只需比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(s\)</span>的字典序即可,此时上面两个条件等价;若<span class="math inline">\(s\)</span>是<span class="math inline">\(t\)</span>的前缀,则我们需要比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(t\)</span>的后缀,注意到<span class="math inline">\(t\)</span>的前缀还是<span class="math inline">\(s\)</span>,于是需要比较<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有<span class="math inline">\(n\)</span>个箱子,第<span class="math inline">\(i\)</span>个箱子有重量<span class="math inline">\(w_i\)</span>和承载量<span class="math inline">\(v_i\)</span>,<span class="math inline">\((w_i,v_i&gt;0)\)</span>,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化<span class="math inline">\(\min_{i=1}^n\{v_i-\sum_{j=1}^{i-1}w_j\}\)</span>,并判断是否<span class="math inline">\(\geq 0\)</span>.</p>
<p>我们令<span class="math inline">\(b_i=-(v_i+w_i),a_i=-v_i\)</span>,则我们要最大化<span class="math inline">\(\min\{\sum_{j=1}^{i-1}b_i-\sum_{j=1}^ia_i\}\)</span>.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义<span class="math inline">\(x\leq y\)</span>当且仅当<span class="math inline">\(F(\{x,y\})\leq
F(\{y,x\})\)</span>,那么对于两个元素<span class="math inline">\((a_1,b_1),(a_2,b_2)\)</span>,显然<span class="math inline">\((a_1,b_1)\leq (a_2,b_2)\)</span>当且仅当<span class="math inline">\(\min\{-a_1,b_1-a_1-a_2\}\geq\min\{-a_2,b_2-a_1-a_2\}\)</span>.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li>都大于等于第一个元素,则相当于<span class="math inline">\(a_1\leq
a_2\and b_1-a_1\geq 0\)</span>.</li>
<li>都大于等于第二个元素,则相当于<span class="math inline">\(b_1\geq
b_2\and b_2-a_2\leq 0\)</span>.</li>
</ol>
<p>可能这里后面和<span class="math inline">\(0\)</span>比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对<span class="math inline">\(b-a\)</span>的符号进行讨论:</p>
<ol type="1">
<li>若<span class="math inline">\(sgn(b_1-a_1)&gt;sgn(b_2-a_2)\)</span>,则不等式成立.</li>
<li>若<span class="math inline">\(sgn(b_1-a_1)=sgn(b_2-a_2)=1\)</span>,则不等式成立当且仅当<span class="math inline">\(a_1\leq a_2\)</span>.</li>
<li>若<span class="math inline">\(sgn(b_1-a_1)=sgn(b_2-a_2)=0\)</span>,则不等式成立.</li>
<li>若<span class="math inline">\(sgn(b_1-a_1)=sgn(b_2-a_2)=-1\)</span>,则不等式成立当且仅当<span class="math inline">\(b_1\geq b_2\)</span>.</li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时<span class="math inline">\(b_1=a_1\)</span>,<span class="math inline">\(b_2=a_2\)</span>,两条件必有一真.(1)则是因为此时满足<span class="math inline">\(b_1-a_1&gt;b_2-a_2\and sgn(b_1-a_1)\geq 0\and
sgn(b_2-a_2)\leq 0\)</span>.也就有<span class="math inline">\(a_2-a_1&gt;b_2-b_1\and b_1\geq a_1\and b_2\leq
a_2\)</span>.怎么着都能成立.</p>
<p>由此发现,对于<span class="math inline">\(sgn(b-a)\)</span>相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为: <span class="math display">\[
(a_1,b_1)\leq (a_2,b_2)\\\Updownarrow \\
(sgn(b_1-a_1)&gt;sgn(b_2-a_2))\\\or(sgn(b_1-a_1)=sgn(b_2-a_2)\and
F(\{1,2\})\leq F(\{2,1\})
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1,...,x_n\)</span>,以及一个定义域为这些元素的序列,值域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于给定整数<span class="math inline">\(k\)</span>,所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>的长度为<span class="math inline">\(k\)</span>的子序列,表达式<span class="math inline">\(F(\{x_{p_1},x_{p_2},...,x_{p_k}\})\)</span>最小值.</p>
<p>如果<span class="math inline">\(k=n\)</span>,则就是模型1.不然,我们考虑先选出一个大小为<span class="math inline">\(k\)</span>的子集,然后使用模型1.不难发现,我们最后取出的<span class="math inline">\(\{x_{p_1},x_{p_2},...,x_{p_k}\}\)</span>一定是<span class="math inline">\(n=k\)</span>时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有<span class="math inline">\(n\)</span>个物品,第<span class="math inline">\(i\)</span>个物品有非负费用<span class="math inline">\(c_i\)</span>和价值<span class="math inline">\(v_i\)</span>,两个人进行如下博弈:</p>
<ol type="1">
<li>第一个人要么选择一个物品,付出<span class="math inline">\(c_i\)</span>的代价;要么选择结束游戏.</li>
<li>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行<span class="math inline">\(k\)</span>次);也可以选择不操作,此时第一个人获得<span class="math inline">\(v_i\)</span>的收益,博弈结束.</li>
<li>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.<span class="math inline">\((n\leq 1.5\times 10^5,k\leq 9)\)</span></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择<span class="math inline">\(k+1\)</span>个,然后收益为<span class="math inline">\(\min_{i=1}^{k-1}\{v_{x_i}-\sum_{j=1}^ic_{x_j}\}\)</span>(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度<span class="math inline">\(O(n\log n+nk)\)</span>.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有<span class="math inline">\(n\)</span>条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有<span class="math inline">\(n\)</span>条直线的答案,求<span class="math inline">\(n+1\)</span>条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度<span class="math inline">\(a_1,\cdots,a_n\in
\{90\degree ,270\degree\}\)</span>,要求构造一个<span class="math inline">\(n\)</span>边形(边必须平行于坐标轴),使得其内角依次是<span class="math inline">\(a_1,\cdots,a_n\)</span>.</p>
<p>首先有解条件显然是判定它们的和是否是<span class="math inline">\(180\degree(n-2)\)</span>.</p>
<p>注意到相邻的<span class="math inline">\(90\degree\)</span>和<span class="math inline">\(270\degree\)</span>无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让<span class="math inline">\(S\rightarrow
T\)</span>.这个时候可以找一个中间状态<span class="math inline">\(A\)</span>,让<span class="math inline">\(S\rightarrow A,T\rightarrow A\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有<span class="math inline">\((X,0)\)</span>亮着,每次把<span class="math inline">\((x,y)\)</span>,<span class="math inline">\((x,y+1)\)</span>,<span class="math inline">\((x+1,y)\)</span>状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p><span class="math inline">\(n\leq 10^5\)</span>,坐标的绝对值均<span class="math inline">\(\leq 10^{17}\)</span>.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线<span class="math inline">\(y=-inf\)</span>,然后比对.我们注意到<span class="math inline">\((X,0)\)</span>向下推的过程类似一个组合数递推的过程,由经典公式<span class="math inline">\(\binom{S}{T}\equiv [T\subseteq S]\bmod
2\)</span>可知,我们取<span class="math inline">\(inf=2^{63}-1\)</span>即可.然后最后在这条线上一定是有一个区间是<span class="math inline">\(1\)</span>,我们需要找到区间左端点,我们选择在直线上随便找到一个<span class="math inline">\(1\)</span>,由于<span class="math inline">\(inf\)</span>很大,大于<span class="math inline">\(10^{17}\)</span>,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,<span class="math inline">\(n\leq
10^4\)</span>,但是初始点可能是<span class="math inline">\((X,Y)\)</span>.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点<span class="math inline">\((j,-inf)\)</span>和<span class="math inline">\((k,-inf)\)</span>是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>.而上述条件满足当且仅当<span class="math inline">\([j-X \subseteq Y+inf]\)</span>.</p>
<p>如果我们随便找一个点<span class="math inline">\((p,-inf)\)</span>满足条件,那我们接下来只需要枚举<span class="math inline">\(w\)</span>,判断<span class="math inline">\((p-2^w,-inf)\)</span>是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间<span class="math inline">\([l,r]\)</span>中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>被小船创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E5%B0%8F%E8%88%B9%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>众所周知,高中物理有一道很经典的分解速度的题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1t04v0mr.png"></p>
<p>物理老师在上课讲这个题的时候,将速度分解为两个正交的速度,这两个速度的矢量和就是原速度.</p>
<p>乍一看好像非常合理,然而随即大家可能就会见到这个题:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ajz7jb.png"></p>
<p>其中中间的物体下落的速度为<span class="math inline">\(v\)</span>,这个时候沿绳子分解速度的时候,两个分速度应该均是<span class="math inline">\(v\cos
\theta\)</span>,而这个时候两个速度的矢量和并不是原速度啊!</p>
<p>老师讲到这里的时候,往往会说这是因为:“速度的分解和力的分解并不一样.”但你可能会疑问:同样是矢量的分解,为什么会不一样呢?</p>
<p>先提前给出我的思考:在这个滑轮组模型中,我们做的操作并不是将原速度分解为了这两个速度,这两个速度也并非由原速度一下分解出来的,而分别只是原速度分解出的速度的一部分.</p>
<hr>
<p>先看这个最经典的模型:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1t04v0mr.png"></p>
<p>不妨设高度差为<span class="math inline">\(h\)</span>,此时绳子长度为<span class="math inline">\(L\)</span>,物体距离墙的距离为<span class="math inline">\(x\)</span>.</p>
<p>有勾股定理: <span class="math inline">\(L^2=h^2+x^2\)</span>,注意到此时<span class="math inline">\(h\)</span>是一个常量.</p>
<p>两边对<span class="math inline">\(t\)</span>求导,自然有:</p>
<p><span class="math display">\[
2Lv_L=2xv_x\\
v_L=\frac{x}{L}v_x=v_x\cos \theta
\]</span></p>
<p>此时的另一个分速度自然是<span class="math inline">\(v_h=v_x\sin
\theta\)</span>.在物理课上,物理老师会这么解释这种分解:</p>
<p><span class="math inline">\(v_L\)</span>这个速度提供了绳子缩短的速度,而<span class="math inline">\(v_h\)</span>提供了绳子转动的速度.</p>
<p>那么这个<span class="math inline">\(v_h\)</span>听上去应该是此时绳子与物体接触点的转动的线速度对吧.也就是说角速度应该是<span class="math inline">\(\omega=\frac{v_h}{L}=\frac{h}{L^2}v_x\)</span>,令绳子与转轴夹角为<span class="math inline">\(\alpha,\sin
\alpha=\frac{x}{L}\)</span>而我们有:</p>
<p><span class="math display">\[
\omega=\frac{\text d\alpha}{\text d t}\\
=\frac{\text d \alpha}{\text d \sin \alpha}\frac{\text d \sin
\alpha}{\text d t}\\
=\frac{1}{\frac{\text d \sin \alpha}{\text d \alpha}}\frac{\text d \sin
\alpha}{\text d t}\\
=\frac{1}{\cos \alpha}\frac{v_xL-v_Lx}{L^2}\\
=\frac{h}{L^2}v_x
\]</span></p>
<p>这就证明了<span class="math inline">\(v_h\)</span>的确是线速度,这也与我们直观感受相当匹配.</p>
<hr>
<p>解释完上面这个分解的正确性,我们又要开始考虑了:那么为什么力和速度的分解不一样呢?</p>
<p>有一个很形象的比喻,那就是如果两个人同时以速度<span class="math inline">\(v\)</span>的速度拉一个物体,这个物体的速度是<span class="math inline">\(v\)</span>;但如果两个人同时以力<span class="math inline">\(F\)</span>拉一个物体,这个物体的受力是<span class="math inline">\(2F\)</span>.</p>
<p>这是为什么呢?动量定理实际上将力在时间上的积累与动量等价起来了对吧,由于速度并非是动量,因此自然像力那样叠加.这么思考也许是正确的:两个受力均为<span class="math inline">\(F\)</span>的物体的合力是<span class="math inline">\(2F\)</span>,两个速度均为<span class="math inline">\(v\)</span>的物体合速度为<span class="math inline">\(v\)</span>,两个动量均为<span class="math inline">\(p\)</span>的速度相同的物体合动量为<span class="math inline">\(2p\)</span>.</p>
<p>或者换而言之,力的作用之间是有牛顿第三定律作保证的,这就可以让力在物体间存在一种类似传递的效果.但是速度并没有这种效果,速度并非是外界对物体做出的改变,而是物体的性质本身.</p>
<p>从这个角度,我们回到滑轮的那个题,我们就可以明白为什么要这么分解了:原因很简单,这两个沿绳的速度并不是一次分解分解出来的,而是让原本的速度先沿其中一个绳分解为两个速度,一个是沿绳的速度<span class="math inline">\(v\cos
\theta\)</span>,另一个是提供绳转动的线速度<span class="math inline">\(v\sin \theta\)</span>.</p>
<p>而速度是不能叠加的,因此右边也做这个操作,这就使得沿绳的分速度均为<span class="math inline">\(v\cos \theta\)</span>.</p>
<hr>
<p>回看开头的那个滑轮题,这题其实还有个很好玩的地方:那就是C的动能最大点可不是C的受力平衡点:原因很简单,C的受力平衡点由于滑轮作用仍然存在角速度上的加速度.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被摆球创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E6%91%86%E7%90%83%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>今晚学弟问了我这么一个问题:</p>
<p>对于一个圆锥摆,设其绳上拉力为<span class="math inline">\(T\)</span>,我们有:</p>
<p><span class="math display">\[
T\sin\theta=m\omega^2\sin\theta L \\
T=m\omega^2L
\]</span></p>
<p>那么问题来了:当小球自然下垂的时候,<span class="math inline">\(T=mg\)</span>,但是<span class="math inline">\(\omega=0\)</span>,左边不等于右边???</p>
<p>怎么处理这个问题呢?</p>
<hr>
<p>下面是我个人的想法啊,不一定正确.</p>
<p>冷静一下,<span class="math inline">\(\omega=\frac{v}{r}\)</span>,我们的确能确认自然下垂的时候<span class="math inline">\(v=0\)</span>,但由于<span class="math inline">\(r\)</span>也是<span class="math inline">\(0\)</span>,我们没道理判定<span class="math inline">\(\omega=0\)</span>.</p>
<p>那么我们把角速度换成线速度就有:</p>
<p><span class="math display">\[
T\sin\theta=m\frac{v^2}{\sin\theta L}\\
T\sin^2\theta=\frac{mv^2}{L}
\]</span></p>
<p>这样极限情况下两边就相等了(均为<span class="math inline">\(0\)</span>).</p>
<hr>
<p>或者说我们还可以这么干:</p>
<p>考虑<span class="math inline">\(T=\frac{mg}{\cos\theta}\)</span>,所以<span class="math inline">\(\omega^2=\frac{g}{L\cos\theta}\)</span>,注意到其实<span class="math inline">\(\omega\)</span>是随着小球下落而单调递减的,但是不可能减到<span class="math inline">\(0\)</span>.</p>
<hr>
<p>另一个想法是:考虑先放一个实体圆锥(可提供支持力),让球在圆锥上转圈,然后逐渐加速到支持力<span class="math inline">\(N=0\)</span>,此时小球会飘起来.我们观察一下这个式子是啥:</p>
<p>考虑引入离心力,只需要让离心力,重力,支持力和拉力四力平衡即可,设绳子与竖直方向的夹角为<span class="math inline">\(\theta\)</span>,作正交分解后立刻有:</p>
<p><span class="math display">\[
\begin{cases}
N\cos\theta=T\sin\theta-m\omega^2L\sin\theta\\
N\sin\theta=mg-T\cos\theta
\end{cases}
\]</span></p>
<p>替换掉其中的<span class="math inline">\(N\)</span>,得到:</p>
<p><span class="math display">\[
mg\cos\theta-T\cos^2\theta=T\sin^2\theta-m\omega^2L\sin^2\theta\\
T=mg\cos\theta+m\omega^2L\sin^2\theta
\]</span></p>
<p>考虑<span class="math inline">\(T\)</span>和<span class="math inline">\(\omega^2\)</span>的函数关系,小球从在圆锥摆上的状态到飘起来的状态应该是连续的两段直线,注意到当<span class="math inline">\(\theta\rightarrow
0\)</span>的时候,它俩的关系是<span class="math inline">\(T=mg\)</span>的平行于<span class="math inline">\(\omega^2\)</span>轴的直线,这段直线会一直延伸到<span class="math inline">\(\omega\)</span>的最低点,也就是<span class="math inline">\(\omega=\sqrt{\frac{g}{L}}\)</span>的点然后再转上去.</p>
<hr>
<p>如果这个文章就这么结束还是有点无聊,不如让我们来看个类似的问题: <img src="https://cdn.luogu.com.cn/upload/image_hosting/k0eufkm2.png"></p>
<p>先来看第一问:</p>
<p>设水平向左为正方向,设小球相对于滑块的水平速度为<span class="math inline">\(v_1\)</span>,滑块速度为<span class="math inline">\(v_2\)</span>.</p>
<p>水平方向动量守恒,当然有<span class="math inline">\(m(v_1-v_2)=Mv_2\)</span>.</p>
<p>此时小球的总速度应该为<span class="math inline">\(v=\sqrt{(v_1-v_2)^2+(\frac{v_1\sin\theta}{\cos\theta})^2}=v_2\sqrt{(\frac{M}{m})^2+\frac{(M+m)^2\sin^2\theta}{m^2\cos^2\theta}}\)</span>.</p>
<p>小球和滑块的总机械能守恒,当然有:<span class="math inline">\(\frac{1}{2}mv^2+\frac{1}{2}Mv_2^2=mgR\cos\theta\)</span>.</p>
<p>两式联立,解得:<span class="math inline">\(v_2=\sqrt{\frac{2m^2gR\cos\theta}{(Mm+M^2)+(M+m)^2\tan^2\theta}}=\sqrt{\frac{2m^2gR\cos^3\theta}{(m+M)(M+m\sin^2\theta)}}\)</span>.</p>
<p>看上去只是麻烦而已,也没那么难嘛.</p>
<p>再来看第二问:</p>
<p>考虑<span class="math inline">\(a_n=\frac{(\frac{v_1}{\cos\theta})^2}{R}=\frac{v_2^2(M+m)^2}{m^2R\cos^2\theta}=\frac{2g(M+m)\cos\theta}{M+m\sin^2\theta}\)</span>,</p>
<p>而滑块的水平加速度大小应该是<span class="math inline">\(a&#39;=-\frac{N\sin\theta}{M}\)</span>,那么惯性力<span class="math inline">\(F&#39;=-a&#39;m=\frac{mN\sin\theta}{M}\)</span>.</p>
<p>而<span class="math inline">\(a_nm=N-mg\cos\theta+F&#39;\sin\theta\)</span>,<span class="math inline">\(\frac{M+m\sin^2\theta}{M}N=ma_n+mg\cos\theta=\frac{2gm(M+m)\cos\theta}{M+m\sin^2\theta}+mg\cos\theta=mg\cos\theta(\frac{3M+2m+m\sin^2\theta}{M+m\sin^2\theta})\)</span>,整理得到<span class="math inline">\(N=Mm\cos\theta(\frac{3M+3m-m\cos^2\theta}{(M+m\sin^2\theta)^2})\)</span>.方向沿半径方向朝向圆心.</p>
<p>这里就要用惯性力了.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被蝴蝶创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%9D%B4%E8%9D%B6%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#约定">约定</a></li>
<li><a href="#抛物线">抛物线</a>
<ul>
<li><a href="#定理1">定理1</a></li>
<li><a href="#定理2">定理2</a></li>
<li><a href="#定理3">定理3</a>
<ul>
<li><a href="#引理">引理</a></li>
</ul></li>
</ul></li>
<li><a href="#圆">圆</a>
<ul>
<li><a href="#定理坎迪定理">定理(坎迪定理)</a>
<ul>
<li><a href="#特例">特例</a></li>
<li><a href="#通解">通解</a></li>
</ul></li>
</ul></li>
<li><a href="#椭圆">椭圆</a>
<ul>
<li><a href="#定理1-1">定理1</a></li>
</ul></li>
<li><a href="#其它">其它</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p>事情是这样的,很久很久很久以前,我做了一个圆锥曲线压轴题,大概就是椭圆<span class="math inline">\(x\)</span>轴上蝴蝶定理硬算题给我整傻眼了.今天我闲的没事乱想突然意识到椭圆可以仿射变换到圆来解决,那么圆肯定有很优美的做法了吧!</p>
<p>然而我瞪了半天也没看出来,没办法最后拿联消判韦把圆的结论搓出来了.</p>
<p>这个时候我又想看看其它的圆锥曲线,发现双曲线好像有点不太会,因为我不是很懂双曲线的内部是啥,然后我发现抛物线的蝴蝶定理更加优美.</p>
<p>所以我就把这一坨东西出了思考题,下面是整理.</p>
<h3><span id="约定">约定</span></h3>
<p>下文称<span class="math inline">\(A,B,C\)</span>三点满足蝴蝶定理,当且仅当A,B,C三点都在圆锥曲线内部,并且过A的直线与圆锥曲线交于<span class="math inline">\(P,Q\)</span>两点,<span class="math inline">\(PB,QB\)</span>分别与圆锥曲线交于<span class="math inline">\(P&#39;,Q&#39;\)</span>两点,而且<span class="math inline">\(P&#39;Q&#39;\)</span>恒过<span class="math inline">\(C\)</span>点.</p>
<h3><span id="抛物线">抛物线</span></h3>
<h4><span id="定理1">定理1</span></h4>
<p>对于任何一条抛物线<span class="math inline">\(y^2=2px\)</span>以及与其内部一点<span class="math inline">\(A(a,0)\)</span>,过<span class="math inline">\(A\)</span>点与抛物线相交的两个点的横坐标之积等于<span class="math inline">\(a^2\)</span>.</p>
<p>证明:联立即可.</p>
<h4><span id="定理2">定理2</span></h4>
<p>对于任何一条抛物线<span class="math inline">\(y^2=2px\)</span>以及其内部的三点<span class="math inline">\(A(a,0),B(b,0),C(c,0)\)</span>,三点满足蝴蝶定理当且仅当<span class="math inline">\(b^2=ac\)</span>.</p>
<p>证明:由定理1,我们有:</p>
<p><span class="math inline">\(\begin{cases}x_Px_Q=a^2\\x_Px_{P&#39;}=b^2\\
x_Qx_{Q&#39;}=b^2\\x_{P&#39;}x_{Q&#39;}=c^2\end{cases}\)</span></p>
<p>简单解一下就可以.</p>
<h4><span id="定理3">定理3</span></h4>
<p>对于任何一条抛物线<span class="math inline">\(y^2=2px\)</span>以及其内部的两点<span class="math inline">\(A(x_a,y_a),B(x_b,y_b)\)</span>,要么存在一个点<span class="math inline">\(C\)</span>使得<span class="math inline">\(A,B,C\)</span>三点满足蝴蝶定理,要么<span class="math inline">\(P&#39;Q&#39;\)</span>的斜率恒定.</p>
<p>证明:</p>
<h5><span id="引理">引理</span></h5>
<p>如果一条动直线<span class="math inline">\(Ax+By+C=0\)</span>中,<span class="math inline">\(A,B,C\)</span>满足一次方程<span class="math inline">\(pA+qB+C=0\)</span>,那么这条直线肯定过定点<span class="math inline">\((p,q)\)</span>.</p>
<p>而如果可以找到一个参数<span class="math inline">\(t\)</span>,使得可以做到将<span class="math inline">\(A,B,C\)</span>分别表示为<span class="math inline">\(f(t),g(t),h(t)\)</span>的形式,其中<span class="math inline">\(f,g,h\)</span>都是关于<span class="math inline">\(t\)</span>的一次函数或常函数,那么这条直线要么过定点,要么斜率恒定.</p>
<p>对于<span class="math inline">\(P&#39;Q&#39;\)</span>这条直线,这个<span class="math inline">\(t\)</span>相当好找,可以是<span class="math inline">\(k_{PQ}\)</span>,可以是<span class="math inline">\(y_Py_Q\)</span>,可以是<span class="math inline">\(y_P+y_Q\)</span>,然后带入简单检验一下即可.</p>
<h3><span id="圆">圆</span></h3>
<h4><span id="定理坎迪定理">定理(坎迪定理)</span></h4>
<h5><span id="特例">特例</span></h5>
<p>对于任何一个圆<span class="math inline">\(x^2+y^2=r^2\)</span>以及其内部三点<span class="math inline">\(A(a,0),B(b,0),C(c,0)\)</span>,若三点满足蝴蝶定理,当且仅当<span class="math inline">\((a+c)(b^2+r^2)=2b(ac+r^2)\)</span>.</p>
<h5><span id="通解">通解</span></h5>
<p>对于任何一个圆,我们有下图(图源自百度百科)</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ah1ipl9o.png"></p>
<p>那么<span class="math inline">\(\frac{1}{GP}-\frac{1}{HP}=\frac{1}{AP}-\frac{1}{BP}\)</span>.</p>
<p><del>该定理的几何/代数证明好像都略麻烦,笔者决定开摆</del></p>
<p><span class="citation" data-cites="Querainy">@Querainy</span>
牛逼,下面给出他提供的曲线系<a href="https://www.luogu.com.cn/blog/uakioi/qu-xian-xi">证明</a>:</p>
<p>我们尝试把这个做法拓展到坎迪定理上.</p>
<p>照葫芦画瓢,设圆心为<span class="math inline">\((x_0,y_0)\)</span>,得到<span class="math inline">\((CE,DF):(1+\lambda
k_1k_2)x^2-2x_0x+x_0^2+y_0^2-r^2=0\)</span>.</p>
<p>此时,<span class="math inline">\(|AB|=\sqrt{r^2-y_0^2}\)</span>,<span class="math inline">\(|AP|=|AB|-x_0,|BP|=|AB|+x_0\)</span>,<span class="math inline">\(\frac{1}{AP}-\frac{1}{BP}=\frac{2x_0}{r^2-y_0^2-x_0^2}\)</span>.</p>
<p>而<span class="math inline">\(\frac{1}{GP}-\frac{1}{HP}=-\frac{y_1+y_2}{y_1y_2}=\frac{2x_0}{r^2-y_0^2-x_0^2}\)</span>.</p>
<p>笔者后来思考了一下为什么这个是二次曲线系啊.</p>
<p>我们考虑求过四个定点的二次曲线系,不妨假设这些二次曲线均为<span class="math inline">\(Ax^2+By^2+Cxy+Dx+Ey+F=0\)</span>\</p>
<p>带入四个定点坐标,就可以得到关于<span class="math inline">\((A,B,C,D,E,F)\)</span>的四个方程.不妨先假设这四个方程线性无关.那么就有两个自由元,那么方程的任何一个解,就可以表示为两组线性无关的特解的线性组合.</p>
<p>注意到两个二次曲线线性相关,当且仅当它们是同一条曲线,这就证明了二次曲线系的正确性!</p>
<p>那么怎么证明这四个方程线性无关呢,不太会啊,这次真摆了.</p>
<h3><span id="椭圆">椭圆</span></h3>
<h4><span id="定理1">定理1</span></h4>
<p>对于任何一个椭圆<span class="math inline">\(\frac{x^2}{r^2}+\frac{y^2}{d^2}=1(r&gt;d)\)</span>以及其内部三点<span class="math inline">\(A(a,0),B(b,0),C(c,0)\)</span>,若三点满足蝴蝶定理,当且仅当<span class="math inline">\((a+c)(b^2+r^2)=2b(ac+r^2)\)</span>.</p>
<p>证明:</p>
<p>注意到圆的坎迪定理的特例,然后发现我们如果将椭圆的纵轴拉长使其成为一个圆,换言之就是对椭圆进行仿射变换,那么<span class="math inline">\(A,B,C\)</span>三点坐标不变并且仍然满足蝴蝶定理.</p>
<h3><span id="其它">其它</span></h3>
<p>众所周知,极点极线有一个经典内切四边形结论,其实也就是所谓的完全四边形啊.</p>
<p>给张图,</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9uzi7mgg.png"></p>
<p>其中<span class="math inline">\(G,D,H,A\)</span>成调和点列.</p>
<p>我们冷静一下,注意到<span class="math inline">\((AF,AE)\)</span>就是一个二次曲线,而且<span class="math inline">\(F,C,B,E\)</span>是二次曲线上四个点,所以这个还可以用曲线系方程来证明这四个点成调和点列,非常有实力.</p>
<p>当然,为了应对文化课,我们有更加简单的证明完全四边形调和点列的做法:</p>
<p>不妨设<span class="math inline">\(d=\frac{BC}{EF}\)</span>,令<span class="math inline">\(\vec e=\vec{AE},\vec f=\vec{AF}\)</span>,则<span class="math inline">\(\vec{AD}=\lambda_1\vec e+\mu_1d\vec
f=\lambda_2d\vec e+\mu_2\vec f\)</span>,对比系数得到两个方程,再加上<span class="math inline">\(\mu_1+\lambda_1=1,\mu_2+\lambda_2=1\)</span>,立刻解出结论.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被炮弹创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E7%82%AE%E5%BC%B9%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>高中物理的时候有这么一个题,然后今天刚好信物讲到了,顺手来总结一下.</p>
<p>先来个简单版本:我从一个点打炮弹,目标与我的距离为<span class="math inline">\(x\)</span>,且目标比我高<span class="math inline">\(h\)</span>,问以什么样的角度打出炮弹能使得击中目标并且初速度最小.</p>
<p>我们当然会第一反应认为这是一个很简单的问题,考虑<span class="math inline">\(t=\frac{x}{v_0\cos
\theta}\)</span>,因为我们很容易写出方程:</p>
<p><span class="math display">\[
x\frac{\sin\theta}{\cos\theta}-\frac{gx^2}{2v_0^2\cos^2\theta}=h\\
\frac{1}{v_0^2}=\frac{1}{gx^2}(x\sin(2\theta)-h\cos(2\theta)-h)\\
\frac{1}{v_0^2}=\frac{1}{gx^2}(\sqrt{x^2+h^2}\sin(2\theta-\varphi)-h),\varphi=\arctan(\frac{h}{x})
\]</span></p>
<p>只需要对后面那个东西用辅助角公式就可以了对吧,非常简单啊!</p>
<p>然而,我们稍微改下题面:</p>
<p>我从一个高度为<span class="math inline">\(h\)</span>的点打炮弹,初速度确定为<span class="math inline">\(v_0\)</span>,问以什么样的角度打炮弹能打得最远.</p>
<p>这有啥区别啊,只需要改个正负号就行了是吧,让我们看看: <span class="math display">\[
\frac{1}{v_0^2}=\frac{1}{gx^2}(x\sin(2\theta)+h\cos(2\theta)+h)
\]</span></p>
<p>这下发现问题了,这个<span class="math inline">\(x\)</span>根本拿不出来啊.</p>
<p>重新按部就班,发现只能用求根公式得到<span class="math inline">\(x\)</span>的表达式,更进一步地,我们有: <span class="math display">\[
x=\frac{v_0\cos\theta(v_0\sin\theta+\sqrt{v_0^2\sin^2\theta+2gh})}{g}
\]</span></p>
<p>怎么办呢?yth老师给出了一个想法是使用柯西不等式,注意到: <span class="math display">\[
x=\frac{v_0\cos\theta(v_0\sin\theta+\sqrt{v_0^2\sin^2\theta+2gh})}{g}\\
=\frac{v_0\sin\theta
v_0\cos\theta+v_0\cos\theta\sqrt{v_0^2\sin^2\theta+2gh}}{g}\\
\leq \frac{1}{g}(v_0\sqrt{v_0^2+2gh})
\]</span> 当且仅当<span class="math inline">\(v_0^2\cos^2\theta=v_0\sin\theta\sqrt{v_0^2\sin^2\theta+2gh},\frac{1}{\tan^2\theta}=\frac{2gh}{v_0^2}+1\)</span>的时候取等.</p>
<p>还有一种策略是考虑对隐函数求导然后令<span class="math inline">\(\frac{\text d x}{\text d
\theta}=0\)</span>,这样得到情况会和我们一开始的初始问题得到的答案相等,也就是当<span class="math inline">\(\tan (2\theta)=-\frac{x}{h}\)</span>的时候<span class="math inline">\(x\)</span>会取极限.这也很好理解,因为我们如果当前的速度没有用到极限打到最远,总能调整使得得到一个更小的速度打到当前的距离,因此距离还有提高的空间.</p>
<p>有没有更聪明一点的办法呢?</p>
<p>我们注意到初速度是定值,根据机械能守恒定律,末速度的大小一定是个定值,我们考虑:
<span class="math display">\[
\vec v=\vec v_0+\Delta \vec v
\]</span></p>
<p>通过机械能守恒定律可以算出<span class="math inline">\(|\vec
v|=\sqrt{v_0^2+2gh}\)</span>.</p>
<p>注意到<span class="math inline">\(\vec v\)</span>和<span class="math inline">\(\vec
v_0\)</span>的水平方向分速度是相同的.然后有一个天才的想法是,考虑上述那个向量式的三角形法则,设那个三角形的面积为<span class="math inline">\(S\)</span>,注意到<span class="math inline">\(\Delta \vec v=gt\)</span>,而<span class="math inline">\(x=v_0\cos\theta t=\frac{2S}{g}\leq
\frac{v_0\sqrt{v_0^2+2gh}}{g}\)</span>,也就是面积最大的时候应该是<span class="math inline">\(\vec v_0\)</span>和<span class="math inline">\(\vec v\)</span>夹角为<span class="math inline">\(\frac{\pi}{2}\)</span>的时候.</p>
<p>直接从形式上来看:</p>
<p><span class="math display">\[
\frac{v_0\sin\theta
v_0\cos\theta+v_0\cos\theta\sqrt{v_0^2\sin^2\theta+2gh}}{g}
\]</span></p>
<p>我们知道正交分解的时候从结果上来说可以作分方向的动能定理,因此初速度是<span class="math inline">\((v_0\cos\theta,v_0\sin\theta)\)</span>,末速度是<span class="math inline">\((v_0\cos\theta,-\sqrt{v_0^2\sin^2\theta+2gh}))\)</span>,因此<span class="math inline">\(x=\frac{\vec v\times \vec v_0}{g}\)</span>.</p>
<p>这个想法过于震惊了,以至于我在之后多次回忆起这个题,想去找到初速度与末速度叉积的物理意义.但直到如今我也没有完全理解这个做法.</p>
<p>写到这发现没活整了,顺便在这写一下另一个斜抛题:</p>
<p>抛射质量为<span class="math inline">\(m\)</span>的小球,抛射倾角为<span class="math inline">\(\theta\)</span>,初速度大小为<span class="math inline">\(v_0\)</span>,所受空气阻力<span class="math inline">\(\vec F\)</span>与速度<span class="math inline">\(\vec v\)</span>的关系为<span class="math inline">\(\vec F=-k\vec v\)</span>,其中<span class="math inline">\(k\)</span>为固定系数,求小球在空气中运行的轨迹曲线.</p>
<p>考虑<span class="math inline">\(\frac{\text d \vec v}{\text dt}=\vec
a=\frac{\vec F+\vec G}{m}=\frac{1}{m}(-k\vec v+m\vec g)\)</span>.</p>
<p>于是: <span class="math display">\[
\text d \vec v=\frac{1}{m}(-k\vec v+m\vec g)\text d t\\
\int_{\vec v_0}^{\vec v}\text d \vec v=\int_{0}^t\frac{1}{m}(-k\vec
v+m\vec g)\text d t\\
\vec v=\frac{-k\vec x}{m}+\vec g t+\vec v_0\\
\begin{cases}\frac{\text d x}{\text d
t}=\frac{-kx}{m}+v_0\cos\theta\\\frac{\text d y}{\text d
t}=\frac{-ky}{m}+v_0\sin\theta+gt\end{cases}
\]</span> 对于第一个式子,令<span class="math inline">\(w=\frac{-kx}{m}+v_0\cos\theta\)</span>我们有:
<span class="math display">\[
\frac{-m}{k}\frac{\text d w}{\text d t}=w\\
\frac{-m}{k}\int_{v_0\cos\theta}^{w}\frac{\text d w}{w}=\int_{0}^t\text
d t\\
\ln(\frac{\frac{-kx}{m}+v_0\cos\theta}{v_0\cos\theta})=\frac{-k}{m}t\\
\frac{-kx}{mv_0\cos\theta}+1=e^{\frac{-k}{m}t}\\
x=\frac{mv_0\cos\theta}{k}(1-e^{-\frac{k}{m}t})
\]</span> 同理解出<span class="math inline">\(y=\frac{m}{k}((v_0\sin\theta+\frac{mg}{k})(1-e^{-\frac{k}{m}t})-gt)\)</span>.</p>
<p>综上参数方程是:<span class="math inline">\(\begin{cases}x=\frac{mv_0\cos\theta}{k}(1-e^{-\frac{k}{m}t})\\y=\frac{m}{k}((v_0\sin\theta+\frac{mg}{k})(1-e^{-\frac{k}{m}t})-gt)\end{cases}\)</span>.</p>
<p>轨迹方程是:<span class="math inline">\(y=(v_0\sin\theta+\frac{mg}{k})\frac{x}{v_0\cos\theta}+\frac{mg}{k}\ln(1-\frac{kx}{mv_0\cos\theta})\)</span>.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被火车创飞了</title>
    <url>/2025/04/14/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E7%81%AB%E8%BD%A6%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>为啥这篇文章总是传不上去???</p>
<p>为啥这篇文章总是传不上去???</p>
<p>事情是这样的,几天前,我们班被出了这么一道物理思考题(为表述方便略有简化).</p>
<p>有一辆以<span class="math inline">\(v_0\)</span>行驶的质量超级大的火车,上面站了一个质量为<span class="math inline">\(m\)</span>的人随火车一起运动.突然，这个人相对于火车以<span class="math inline">\(\Delta
v\)</span>的速度向前平跳(也就是说此时他相对于地面的速度为<span class="math inline">\(v_0+\Delta
v\)</span>),求这个人做这个起跳需要多少能量.</p>
<p>注意这里火车质量很大,所以火车在此人跳跃过程中始终以<span class="math inline">\(v_0\)</span>速度前进.</p>
<p>我看到这个题觉得很简单啊,肯定是<span class="math inline">\(\frac{m}{2}((v_0+\Delta
v)^2-v_0^2)\)</span>.然后发现答案竟然是<span class="math inline">\(\frac{m}{2}(\Delta v)^2\)</span>.</p>
<p>下面是我们物理课代表给出的解释:</p>
<p>虽然人的动能变化确实是<span class="math inline">\(\frac{m}{2}((v_0+\Delta
v)^2-v_0^2)\)</span>,但是在他起跳的过程中,火车对他是有一个力的.而且,因为火车在运动,所以虽然起跳的时候人相对于火车没有运动,但这个力的作用点相对于地面竟然是运动着的!</p>
<p>因此,不妨设这个力为<span class="math inline">\(F\)</span>,注意这里的<span class="math inline">\(F\)</span>不一定是常数,而是一个关于时间<span class="math inline">\(t\)</span>的函数,我们自然有:<span class="math inline">\(W=\int_{t_0}^{t_1}Fx
\text{d}t\)</span>,注意到作用点的速度恒为<span class="math inline">\(v_0\)</span>,因此<span class="math inline">\(W=v_0\int_{t_0}^{t_1}F \text{d}t=v_0\Delta
p=v_0\Delta vm\)</span>,把这个加上后恰好得出答案.</p>
<p>这时我意识到这个事情其实就等价于任何惯性参考系参考下能量都是守恒的.所以我们直接以火车为参考系,立即得出答案.</p>
<p>但是为啥呢?而且我总觉得上面那个力的分析非常诡异,因为我总感觉起跳是瞬间的,这个力理论上不应该做功啊.</p>
<p>通过在网上海量搜索后,我大概找到了这么两种理解方式啊.</p>
<p>第一种是,我们冷静一下.如果没有外力干扰,那么火车其实<strong>并不能匀速前进</strong>.设火车质量为<span class="math inline">\(M\)</span>,当人的速度为<span class="math inline">\(v_0+\Delta
v\)</span>的时候,根据动量守恒,火车的速度应该为<span class="math inline">\(v_0-\frac{m}{M}\Delta v\)</span>.</p>
<p>注意这个时候不能以火车为参考系了,因为火车不再是惯性参考系了,所以我们加入一个以<span class="math inline">\(v_0\)</span>匀速前进的青蛙作为新的参考系.不难发现在青蛙参考系和在地面参考系下,火车和人的系统的动能增量是相等的,都是<span class="math inline">\(\frac{1}{2}(m(\Delta v)^2+M(\frac{m}{M}\Delta
v)^2)\)</span>.</p>
<p>然后,因为火车质量非常非常非常大,我们注意到<span class="math inline">\(\lim_{M\rightarrow +\infty}\frac{m}{M}\Delta
v=0\)</span>,完活.</p>
<p>但是这个过程别说还是进行了近似估计了,就是和现实也不符啊.你火车肯定要有动力来源使得其能进行匀速直线运动.但是这个理解方式的优越性在于,它试图将火车和人视作一个系统来观察,这个角度下我们完全不要去管二者分别的动能了,而是直接分析系统动能.</p>
<p>所以我反思了一下为什么我觉得一开始的那个做法很奇怪,我注意到对人做功的力同时一定对火车作负功,那么也就是一定还有一个对火车作正功的外力,这个力同时也是整个系统的外力.</p>
<p>对这个施加在火车上的外力进行完全一样的分析,就可以得到相同的答案.</p>
<p>或者更一般地,我们来证明惯性参考系下的所需要的能量恒定:</p>
<p>我们已知: <span class="math display">\[
\int_{t_0}^{t_1}Fv\ \text{d}t=\frac{m}{2}(v_1^2-v_0^2)+\Delta E
\]</span> 要证: <span class="math display">\[
\int_{t_0}^{t_1}F(v-v_w)\
\text{d}t=\frac{m}{2}((v_1-v_w)^2-(v_0-v_w)^2)+\Delta E
\]</span></p>
<p>而注意到: <span class="math display">\[
\int_{t_0}^{t_1}F(v-v_w)\ \text{d}t=\int_{t_0}^{t_1}F(v)\
\text{d}t-\int_{t_0}^{t_1}Fv_w\
\text{d}t=\frac{m}{2}(v_1^2-v_0^2)-v_wm(v_1-v_0)+\Delta E
\]</span></p>
<p>这就证明了该结论!</p>
<p><del>不过这个做法虽然相当理性但是一点都不直观啊,为什么两个平方竟然可以在这里线性加减,我其实还是没找到更加易于理解的方式啊,如果有大佬知道可以联系我一下qwq</del></p>
<p>哦哦我突然瞎想出了一个相当简洁的方式啊,就是我们不难注意到只要满足动量守恒以及做功的方程<span class="math inline">\(W=Fx\)</span>,我们很自然可以推导出动能差的表达式,而这两个基础的表达式都是线性的,因此动能差也一定与选取哪个惯性参考系无关!</p>
<p>换句话说,这个动能差的表达式中的平方是我们积分积出来的,但是积分是可以加减的!</p>
<hr>
<p>在大半夜和Querainy 和Minuses
深入交流之后,我发现上面的过程还是太感性理解了,我们来添加一些细节.</p>
<p>首先,Minuses
提供了在宏观下动量定理和牛二等价的证明(他原本的形式用的全是向量,但是我比较懒,所以换成一维情况了):</p>
<p><span class="math display">\[
F\ \text{d}t=m\ \text{d}v
\]</span></p>
<p><span class="math display">\[
F=\frac{\text{d}v}{\text{d}t}m=am
\]</span></p>
<p>然后,他又提供了只要有牛顿第二定律和<span class="math inline">\(W=Fx\)</span>的定义,我们就可以推导惯性参考系下动能定理的证明:</p>
<p><span class="math display">\[
F=m\frac{\text{d}v}{\text{d}t}
\]</span></p>
<p><span class="math display">\[
F\text{d}x=m\frac{\text{d}v}{\text{d}t}\text{d}x=mv\ \text{d}v
\]</span></p>
<p><span class="math display">\[
W=\int_{t_0}^{t_1}F\text{d}x=m\int_{t_0}^{t_1}v\text{d}v=\frac{1}{2}m(v_1^2-v_0^2)
\]</span></p>
<p>Minuses 无敌,可让天下一先.</p>
<hr>
<p>Querainy提出我之前的说法是错误的,因为在不同参考系下牛顿第二定律的确不会有影响,但是<span class="math inline">\(W=Fx\)</span>是受到了影响的.例如在上面的例子中,如果以火车为参考系,那么火车与人之间的力对人是没有做功的.但是以地面为参考系,那么这个力因为作用点在变所以是做功了的.</p>
<p>然而这个做功的改变在上面的积分形式中就可以发现,由于速度的改变导致平方项不能完美消除,因此这个做功的改变会抵消切换参考系(伽利略变换)带来的<strong>动能形式的改变</strong>.</p>
<p>这个自我修正bug看上去相当诡异,但是一想到动能定理本身就是从<span class="math inline">\(W=Fx\)</span>和牛顿第二定律推导出来的,因此有自洽性也非常合理.</p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<tbody>
<tr>
<td>追根溯源看上面整个问题,我们会发现,如果我们换参考系然后看动能,动能的变化量的确是不一样的.</td>
</tr>
<tr>
<td>但是问题在于,我们在意的不是动能的变化量,而是我引起这个变化需要外加多少能量.如果我引起这个变化所需要外加的能量不变,那么就仍然满足能量守恒定律.</td>
</tr>
<tr>
<td>如果我们换参考系,动能的变化量改变,但是同时原本不做功的力也会随之进行做功.事实上由于力的作用点最多只在一个惯性参考系下才是静止的,因此换参考系几乎一定会引起力的做功.</td>
</tr>
</tbody>
</table>
<p>所以我们其实还可以再举一个类似的例子:</p>
<p>考虑一个劲度系数为<span class="math inline">\(k\)</span>的弹簧连在地上,上面放了一个重物<span class="math inline">\(M\)</span>,我们来观察一下这个东西.</p>
<p>不妨取<strong>重物放上弹簧后的平衡位置</strong>为重力势能和弹性势能的零点,设弹簧原长位置相对于此位置距离为<span class="math inline">\(x_0\)</span>,此时当然有<span class="math inline">\(kx_0=Mg\)</span>那考虑系统的弹性势能:</p>
<p><span class="math display">\[
E_{p1}=\frac{k}{2}(x-x_0)^2- \frac{k}{2}(x_0)^2=\frac{k}{2}x^2-kx_0x
\]</span></p>
<p>重力势能:</p>
<p><span class="math display">\[
E_{p2}=Mgx
\]</span></p>
<p>那么总势能当然是:</p>
<p><span class="math display">\[
E_p=\frac{1}{2}kx^2-kx_0x+Mgx=\frac{1}{2}kx^2
\]</span></p>
<hr>
<p>时隔不知道多长时间,现在我们来证明柯尼希定理:质点系在参考系<span class="math inline">\(A\)</span>中的总动能等于质点系在质心系中的动能与质心在参考系<span class="math inline">\(A\)</span>中的动能之和.</p>
<p>不妨设质心系下质点系的总动能为<span class="math inline">\(E_{kS}\)</span>,参考系<span class="math inline">\(A\)</span>下的总动能为<span class="math inline">\(E_{kA}\)</span>,质心相对于<span class="math inline">\(A\)</span>参考系的速度为<span class="math inline">\(\vec v_C\)</span>,我们当然有:</p>
<p>$$ E_{kS}=m_i(v_i-v_C)^2\</p>
<p>=E_{kA}+(M(v_C)^2-2m_iv_iv_C)\</p>
<p>=E_{kA}+(M(v_C)<sup>2-2(v_C)</sup>2m_i)\</p>
<p>=E_{kA}-M(v_C)^2 $$</p>
<p>那这就给出了一个更强的结论,而且这里的质心参考系甚至不需要是惯性系.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被豌豆创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%B1%8C%E8%B1%86%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>在YT2S 2021级生2课上有一个著名的open
problem,也就是在计算自由交配的时候能否拆开考虑,下面我来尝试写一点自己的理解.</p>
<p>首先来看两个问题(前置条件均为孟德尔第二次杂交实验):</p>
<ol type="1">
<li>将F2中双显性植株自由交配,求后代表现型及比例.</li>
<li>将F2中单显性植株(包括两种单显性植株)自由交配,求后代表现型及比例.</li>
</ol>
<p>为了方便笔者书写,不妨设这两对基因是<span class="math inline">\(A/a\)</span>和<span class="math inline">\(B/b\)</span>.</p>
<p>先来看第一个问题,双显性植株中应该有:<span class="math inline">\(\frac{1}{9}AABB,\frac{2}{9}AABb,\frac{2}{9}AaBB,\frac{4}{9}AaBb\)</span>.先让第一组基因自由交配,也就是只看<span class="math inline">\(A/a\)</span>,我们有<span class="math inline">\(\frac{1}{3}AA\)</span>和<span class="math inline">\(\frac{2}{3}Aa\)</span>,产生<span class="math inline">\(\frac{2}{3}A\)</span>和<span class="math inline">\(\frac{1}{3}a\)</span>配子,得到<span class="math inline">\(AA:Aa:aa=4:4:1\)</span>,也就是<span class="math inline">\(A\_:aa=8:1\)</span>.对另一对也这么考虑,最终得到<span class="math inline">\(A\_B\_:A\_bb:aaB\_:aabb=64:8:8:1\)</span>.</p>
<p>非常合理且简洁对吧,但如果你同样拆开考虑第二个问题,会发现这么做是错误的.</p>
<p>我们生物老师LL老师给出的解释是,单显性植株的个体是<span class="math inline">\(A\_bb\)</span>和<span class="math inline">\(aaB\_\)</span>,它们的基因型并没有组合的非常彻底,也就是并没有出现<span class="math inline">\(aabb\)</span>和<span class="math inline">\(A\_B\_\)</span>个体,导致不能乱拆开.</p>
<p>而直觉上感觉这个东西和独立性有关对吧,我们来简单证明一下:</p>
<p>约定<span class="math inline">\(X\)</span>是<span class="math inline">\(AA,Aa\)</span>或<span class="math inline">\(aa\)</span>,<span class="math inline">\(Y\)</span>则是<span class="math inline">\(BB,Bb,bb\)</span>,那么:<span class="math inline">\(P(XY)=P(Y|X)P(X)\)</span>.如果可以拆开,那么<span class="math inline">\(P(XY)=P(X)P(Y)\)</span>,于是有:<span class="math inline">\(P(Y|X)=P(Y)\)</span>,也就是这两种基因型互相独立就行,老师说的对啊!</p>
<p>如果只是这样就水了一篇博客非常无聊对吧,能不能证明一点更好玩的结论呢?</p>
<p>考虑设产生四种配子<span class="math inline">\(AB,Ab,aB,ab\)</span>的概率分别是<span class="math inline">\(x,y,z,w\)</span>,其中<span class="math inline">\(x+y+z+w=1\)</span>.</p>
<p>使用生成函数技巧,配子法给出的答案应该是:<span class="math inline">\((x\ AB+y\ Ab+z\ aB+w\
ab)^2\)</span>,而拆分再乘起来的答案应该是<span class="math inline">\(((x+y)A+(z+w)a)^2((x+z)B+(y+w)b)^2\)</span>,其中<span class="math inline">\(A,B,a,b\)</span>均为形式幂.</p>
<p>如果两边相等,有:</p>
<p><span class="math display">\[
(x\ AB+y\ Ab+z\ aB+w\ ab)^2=((x+y)A+(z+w)a)^2((x+z)B+(y+w)b)^2\\
(x+y+z+w)(x\ AB+y\ Ab+z\ aB+w\ ab)=((x+y)A+(z+w)a)((x+z)B+(y+w)b)\\
\]</span> 两边展开,就可以知道它的充分必要条件是<span class="math inline">\(P(ab)=P(a)P(b)\)</span>,也就是产生<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的配子概率是独立的.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>被轮子创飞了</title>
    <url>/2025/02/16/%E6%96%87%E5%8C%96%E8%AF%BE-%E8%A2%AB%E8%BD%AE%E5%AD%90%E5%88%9B%E9%A3%9E%E4%BA%86/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<p>2024的烟台一模数学压轴题是一道新定义题,是说证明<a href="https://baike.baidu.com/item/%E6%91%86%E7%BA%BF/5893005">摆线</a>上一点<span class="math inline">\(M(x_0,y_0)\)</span>的切线的倾斜角为<span class="math inline">\(\theta\)</span>,求证<span class="math inline">\(\frac{1+\cos
2\theta}{y_0}=1\)</span>.在这个题下选用的参数方程是<span class="math inline">\(x=t-\sin t,y=1-\cos t\)</span>.</p>
<p>这个怎么做呢?我的文化课同学们纷纷使用强大的隐函数求导技巧把它杀穿了啊.可惜我不会隐函数求导,我只会链式法则.但是我考场只记得链式法则怎么用了而完全忘记了这个东西为啥是对的,所以就有了这篇复健博客.</p>
<p>首先来复习一下微分<span class="math inline">\(\text d
y\)</span>的定义啊,下面这段抄自我原本的高数笔记:</p>
<p>考察<span class="math inline">\(\Delta y=f(x_0+\Delta
x)-f(x_0)\)</span>,不妨假设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处导数存在,自然有<span class="math inline">\(\lim_{\Delta x\rightarrow 0}\frac{\Delta y}{\Delta
x}=f&#39;(x_0)\\\)</span>.考察<span class="math inline">\(\eta(\Delta
x)=\frac{\Delta y}{\Delta x}-f&#39;(x_0)\)</span>,显然<span class="math inline">\(\Delta x\rightarrow 0\)</span>时<span class="math inline">\(\eta(\Delta x)\)</span>是一个无穷小量.</p>
<p>那么,我们自然有: <span class="math display">\[
\Delta y=f&#39;(x_0)\Delta x+\eta(\Delta x)\Delta x\\
=f&#39;(x_0)\Delta x+o(\Delta x),\Delta x\rightarrow 0
\]</span> 同时,如果我们有这个式子,可以两边同时除以<span class="math inline">\(\Delta x\)</span>以证明可导.</p>
<p>这就将一阶导数转化成了无穷小量的形式,我们借此给出微分的定义:</p>
<p>设<span class="math inline">\(y=f(x)\)</span>在<span class="math inline">\(x_0\)</span>处有定义,假设有一个常数<span class="math inline">\(A\)</span>使得<span class="math inline">\(f(x_0+\Delta x)-f(x_0)=A\Delta x+o(\Delta
x),\Delta x\rightarrow 0\)</span>,称<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处<strong>可微</strong>,并把<span class="math inline">\(\text df=\text dy=A\Delta x\)</span>称为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处的<strong>微分</strong>,由于后半部分是一个更高阶的无穷小量,我们说微分是函数改变量的线性主要部分.这个时候结合导数极限的定义,就可以得到<span class="math inline">\(\text d y=f&#39;(x)\text d x\)</span>,<span class="math inline">\(f&#39;(x)=\frac{\text d y}{\text d
x}\\\)</span>.这就是我们将导数称作<strong>微商</strong>的原因.</p>
<p>一阶微分具有<strong>形式不变性</strong>.换言之就是,我们在求导的时候是需要选定一个自变量的,当选定的自变量是<span class="math inline">\(y\)</span>的时候,根据上面自然会有<span class="math inline">\(z=g(y),\text d z=g&#39;(y)\text d y\)</span>.</p>
<p>但是当选定的自变量不是<span class="math inline">\(y\)</span>的时候,上面的形式是同样成立的.我们下面证明这个结论,令<span class="math inline">\(y=f(x)\)</span>: <span class="math display">\[
[g(f(x))]&#39;=g&#39;(f(x))f&#39;(x)\\
\text d z=g&#39;(f(x))f&#39;(x)\text d x\\
\text d z=g&#39;(y)\text d y\\
\]</span> 必须提出高阶微分不存在形式不变性,换句话说,<span class="math inline">\(z=g(y)\)</span>的二阶微分的形式不等价于<span class="math inline">\(z=g(y=f(x))\)</span>的二阶微分,你不能乱换元.</p>
<p>根据上面的操作,我们很自然引出了链式法则,也就是: <span class="math display">\[
\frac{\text d y}{\text d x}=\frac{\text d y}{\text d t}\frac{\text d
t}{\text d x}=\frac{\text d y}{\text d t}\frac{1}{\frac{\text d x}{\text
d t}}
\]</span></p>
<p>这样上面的题就可以迎刃而解了.</p>
]]></content>
      <categories>
        <category>被文化课创飞了</category>
      </categories>
      <tags>
        <tag>文化课</tag>
      </tags>
  </entry>
  <entry>
    <title>一半</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E4%B8%80%E5%8D%8A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b4dd43344e5c1919d9b1c29af1b1d02dadeb684588c14aec5602697658555f02">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e6b9306cd99a79ef4fe2bedca4c3b94080bcc80094fdd12fc2e2ff8b9b994c45fd7d36bed9f07364087ccf5ae7e5f6ceed9fabb5ede3922d8b79d5db4aceb957044f918e37b0228bad5a52ac6e23be59900c8fce48a39d01ec47b67623f014e96c991b1dbd2013fc622b74b886d88bb2f12299d23b6f88293605115995293d8964f814cf61a3b5c4023c8bbd4f28fa6617487de7e77d9b2347dcf5329a3f8574e3d03c2569f64fe0e483ffe78e757c78990b7218178a898e10cf8ca10b9938f7f34664e19593a3ae81cb01b286eda2c07e09792a09c2b4731b6ee9715f4dca07e275a7ce281c6d24b50300187006c2a1f0736582fc988935c3f3307c15cf9a4b3ea3b479b708c12b0b27e0a9f6d6536768911148fd67f8832c51842b02f459364fc3b5fb594ed22faf51e30647d846f993cfe9460c89cba46076564cf7ed166d0cb9abe7bec8e57ada40a1076615fed501bdfa894c740ac279f502a33a2cb97575496818af8ef5dd496db0845330412a1f7a652e6faf8a3414c54ea93505303fa98e25ae535738e9be25723593b59656a306625c0cbf29f6ed76c28940995d308a8b61c3e969ef2b8741dfabf677f2caa314c8528a2276a015546b7c9b41b37c73c5a7fa704432fbc818baa43f9af1c26f9eb985c4e4e17018dc63346a71af63530a872ea39b2fb6322afd2e58d2e279a1cbbb6a99b32d8c5215f228ec85d6e49c4f0d39cbbe5f35f5c627f618ca92e8dd6d0e297b04948d8c3af03cd2f9a57d709edf3be88d6656f64e5b2ae9c5f00698dc5a381cc0dedac02b911d3799574ea33960ac5eb9ac256602b522c77f8d216fd56cbb8c9da898a2131c6ef54a73a7168d823ca33c6cb652eb7f855c58ff4181d1684ac01cd924537a7126824e2bc1bdd693885e1d4a794fb44fed3317dcc86959849d98c8edd4769c2c79b4b1a1f684fb4b9b3ef88619d5bbab01f180087c60f982ffe99afb2cd73800e1fd152411b4089e4143adddcd54364f5ab1e80fe0ac6c0e3a7c8f71c527402ded8ca47ca34c6286bc90ceaebcd096c14951c99667032843a15b221d8f5ca7a8e0188f6988395828e7f14c373cb4345a0d22a13e9e75be40c6b3d9faa98dc0d31c6dd800e25c5704ee4988119837497adb17fcc9d9e4e3176737d9e9c891ab25d947acaf2958c4dfb68fb26025b2a4c8f3105964e2f6aa6dfdf3af74f5bd960ab387b18d9ca5cc44030a4ef87e688c05651fb16f800f7eb762b4c884399c5bb586b39adebcd37049bacfb6670c09240e2c9f7b6439cd2fa82abad389c6e2df161a50709575745dd5b71bb0e9999db53da47c68a0d9212ef2d14874c19508d3c28797542e070f45ddbb8244b5b08bc2d5971090afdb2cf8d7aa4448cf33945056949c9763bd3fd8d8fa6218e9b6bf6ce83eb0b08c805ed1103a8c8e96fcac2d1e6d34e7c8c8d48ff38e8085b0ae71bc0cd4c07bb7a6363558b448650733d98a4f11be11c7cad337bfa69e9730d2acd8c40217b128ccff91d2f576a7e01e587ea7b2cba6f1fd26b13f52489d99eca292173049797889e4249fa5e36e24d7793a24388740b2b22d3145ee83c019bea1099a488b7ed60d3faf8fe8f4d6422af3d3f37a06772d79f9e62436194463719fd2518c177ccd163cf16ee08ac3b836447606b36254e72d7c4dbfeaf6391142d886f113ce529ff4031584cb56d1657d38fbf59307bfb4b4381f03eedc4e7a6e6fac8cec2424bf3e7414c581489db93135158b040d0c79355725bf3ff0daa60fd07bb12390c83b4b49533d6cdbb34f95db9ff3989a8c95bb49b294c03a224db12bb2732d197de68464e3cf203a72169cef4fcbfed7f8de41848e0f7e2ea7ac76522a34600833ceca961d9ef33fcf2fef35781decf9aed7ccd394e7f7920bdc1274990e64425de027c924fa12524c165582445cb03763444a17cfdd53e90fa46f222726b6d929fc1b348f83f089de6fd89b95229fcfbf8c00b4593f636e5657023d450571d80d27dbc14a17681c2d8d31ef183f359ae4728768641b084eefc8044bc0d03ea21f129700bd27d220c7eba8d24726e6485f335d1113ca3bbfc2ffb17baf991b60db1d7e8871463f5e5cfbe5213115e6b5482d9ae5414ad811001afa19488d53b5ba33c71f59438b2cf4c820157c4858cf85d1a91315f4473d0bc6461f70b014686614679ab7f7f8401085d8c8000498aac1f5416e68f9f986f0bb582e70cf26e0e91b44e2109be9a9e34d63e1399083aacdb91481fa75f150308080d9997d1a36cfde415be7e13f0e77313eea27ea1ca3ba92fee1a8a0074c6c48f18d00c08861702aaaebcd2460e354409a521c4b68f2abc24d7fe74b48763dd3b2441f1f24b1d77421472fb9d89cc89d4f4e96ab6201925de64754f1783977315ac5179934044aa74f2510268c7664f7147c76b2e8c66d0b2555a921778d343f9a375491e5aa007e1afb59429d78dcb6b19222a8bf3574fec437073b7391cd44d368b3a7c92588c585051b4f95cf9fc7654ac69c2961337a87091a13e7942780f9f8a7ce18e683aecf58c7f31b852d4035276144ed904d282122801fec371a71f598835f3a93298128ba8df5085f527e591f7d86ea19e53c5c87a202477e4a7d4b24b044e3752cf87e68ff8b56bfd43b6d2f7d1a7daf75fc6ed7de8ffea980c4ca646afa50c16072a718789f7ba36a47f404eff83c1c628c6432c30cc2f8c6b52f8c6d5a2105d018bfc1f4f94ed19f79fa3db73a40f204e185161f786408d56b0055742a95c9b20774c4882dc2110c65157ade07a11d7f3ea7f49639021a43b035b0e31bba60be2e167aae2e158ba6303a03bcaed723c2973cf7a49ec9a4ce668e4aa48afca91e4563e355dc19da6111e933773e20a6307bf8f82963bcf1e1967b81eb1a63eb3ed31d61ee40b31ce1762a2cd073ab55f36a729624750a907613b72881251ee0332ccce80975163db7fcf116ca3252384e70c5c08e12f92f11a41d40f977dfb6ebb728da1193e64b7050c85c6d56ce8a65d9f564855bfde105431779b2cb84f6426085a6fed69d194240d0ed6f6314a65c2d1310e42c3bf84cc873ee97171c90225319db75a74880e98be861319b98dd4180ec1be5a5fb6badc490fc6f13afa8b7aad2c8d9c7d24b1153b3e9c566291501db624914f8a3de94ecf6056ed6074690f98b7f0e954064fa3eb8e653617e157eea598a1ffd83c18c276965645493fa49b53478f770b6999bebaff62f036447f2c77df3b6399afbae80eae82332ed2131db97e809d9e3d16466c3cb8dbb48b070abe2768b0b291a780d57c9450230c83aa2169c3c09248a2f199b62e1d583e136474b2b416018aa52b957559d359d47386ee9d3c1c689fa1aece80abe321b93f0cb9ce6a3e98b3fa5c41f4e9dbe7d08e6fc2c04b67e4d7ff9f3af972fa331de857fe67c0c0bcdfaf82f0e8f283ae291c0c30fe7f75fbd6f4bf558cb451f78a5d4cf629fcd7d510b89800a6b9adfb8fa18b6fbd7e8334e0c7407b0ef63055106d7a96b3d3e1ebabcc9b99fd8f4bb4a401ce596fc9386871a26cd6c6fe3eaad396bf7af13be657063b2ff5839730cd12b449c1ce6355b9aef2b06fddb6f88fccee52077e01c35784984b64dba1a74d9c7a39ce9cd8dbba4da2a3922d40301306fe84de29ee82d95b53f29c385acf893e1567e4b35ce5ffb3aa10f115a43d2cee3d742d9f63580437094467779f5d6ac7d613b9e21b706a3a27f171bfe851cf2aac898cec335d3a4ad5756011503f9756d625a0ab8fb598c88966aab7471a2e67394fe6634a5456a6ba47bb3a1e4408aea24f895c28d8f0fd552aff4ddfa032d1026598f479a5358e77a9cff2fc909f06c21f319e6875d98ad291fab40fbb171a2315142b2ffdb94a7fa3081c08ca3b30ee8124663eee39308640ac042afab73e4f0c347722b134ba66cc2f91345309ab34a91d634214aeb42eb66822b18ee71c48324f4361a7b854293745bd1bfa331dd4e3439b908c05ab3caed5ae68658688c4308fbcfd81ac3d93d7ec17111dad901cb073ac3b41c143fdb6d86ec00199e6e6677a7e3e7fc14b351b48ba3b15efbcf7a57a9ac7d73b35a45e99cf61e404b8a01b9f7c2aefaf41b286a94d870d344d7270a0172cb70767143095879392c50ea962fd2e494e38e01b5bcfc962f17d1b70d6202b6bc96d277f779a265f97c508e2c99e91fa3b21398bfce74767d909f92fa15921a7bd66f93de145320993c514112d9df14b1885a495c4e1df7bbaa0db1d0d91aa9832440599339427e347f57f23386bb9063b6c8dc32d32942c0d1bb68f2be27e71427e7974f053895962c31e74e72b37276cd3181612f1ef7c3370f6b23e1d717179149eab3f0137ac68ac777e03eee42d4ad993054370b996e48617f27fb9de1817ae4fcdfaf23797b10394c15efcdf427873df62114f268cdccd40f65200e70e3a82d4f81e0c552e60dc9410626a1e87a55ebc38f4ed5c7ccbdcdf4af77ea7f7c12715127cbe4a46a5277f6056c801b8c658ca3d6b437ebd910b19c8dfacb0e6b190e1e9e6002a3b2e663db1b98b5af2ea1146c823da249bb8cabe379caf5a7f5e8494d0150353fa2ad7d62f89420c1766a068425d0bcb86dcee2a7b100a9ba289b3deb7139ddb0203f5ed5be10c2e8ea46ce7abe3e9bbe1a2a969f5cffa363537a929348406dfeaa5bc2cc4967dcfc9c4392b46c2beb73cc940c162757f177d5edacb294484218aa2c48fd398e3e36d36d9b47b534a81c78e5a26ef30ed7e4a95831c91c6424ea7e9941dabde134895300cb083247ed52e78c9d58c86ab091ba4610a2b1d7197d2fd5f06712345d4275621d442c4246bf248919e619c76d5a6e3fef5e2445e6574e80c52ffe7f842afeb2066311b32e1d394e4834a3e5986ae07dd606b50808138da4a31de98b52c816125af2d2aff60d3021abdf26b37dba4043d8cbae90abfb1e69f08f92e336d4322bdefd890f5ebb18a5e5cec80757227005ccba57878471b59eae50f9fc0e2c9767a15386238d223fdf0ffbcc7b13b35cf1f5cd2f3bf31ab70cce897a2e1fd738988a5b850b880ea3a2f9870a0b06d5042d0746cd151af8b62ec9316405270931b9598d55f65499def2a2e51e8bbe3be9569d9328fde40270a1a929a3cc80aeba338733a8e34b4b106e17c863842d7da68c77b56eff7e7662c3827b2e01410e810f015e1ffd1a19d27c71472d1055604b5214bed83ebb8b25ac397f634d37cabf59cb93aae5c110f246707d2956948453734c7428cdc184b9e0ff3f6ad76e67e265bb9edd3655f021c56c81e33ad162776dfdebbc5e6b225d7659f755430fb4ed82435e09cab905e29b5db28b045e5363b2b6a935abd128bf162e32bafa0a878077dc5b55a2ccc13b041efc08c91e6bb3cc546e8e0899e9a75359ae87a9918c908e8d212178fd84e2cdf196b731a10aed66f55df130c1cdd5d326361a2f2719a46dd4eed29889bfcf8114de086fe05504db14f2377264a34d29f475c64e887371d8ba789f8547787722e88d1ec188339d52efee54cde62d10c130666c13be97d61580e5958a0f600003eb06437a2f0ac16fbf73d8787aae36d9a626cce042ac15214af519e2f0ec91569f8e95af08f50844263ca9c3070915684453f7a2f361d063ba9c1b2f62a9d8f153dae86b109c697f02a15ba3a49b4487cc1a31e397393548da1a8691e6ad3a58ecefc81688c21012ab1db82796b0e5b9e21afc5fbeaead96f026bdfe1fe242a70a53338947600a3b46ff116cca7adc0491cd0cd76c6d602436dac11e8ca2dde461d244363fc5ab4ff042dc092c955cead5dddbe0763e5018f6bb454b69a586e7a22dd85f27383ef95268f10706cf94c708f916c7ad77072f1af41721c47c1a7d1a1a0c465c4cf4d1c6768f34fe155354964dfa8a72d3a1526c9076c3f7a15444f84d27e0524bc18b31cd25b9039c34efc25a9526979adf03138638beb31e576383b195bb4bfadd029c64fed94720db75718f6e00902714b382ab0ae22858ce6cef08ee7d3d08bd09a44b30ac271b806163dab3b4a61a42edef13ce9b21c70632dce5da96ad6807e26ada3a394a987fcc11bdf17c88a449860e795dc70b394d0d67e45c6c0b7091f3bdc32da3535f801f31d37ea3712d84b314d99891569d701c679c1333fcaeaa76bb09e21715ab180b457a7f10a9bcd029026fe869994b17e927448e4f2a5eef6c8040894a24884c879fc19508e8ebebe2a3ae5638115a20ca2338739b69cf85ddb6609ad0e61e1a0604655ba2fe7869c2ad269ca26c22ea117228a5ffc7f2b623968548f3d47da91198b4a23ecc76a39579ba73656e04c6c7cb9ab9c44d332cbca13e4716c3aaa39481d1ac36a245265706f1025d76e6f9a4918bef93d12fc7be8170160a956d4d35f237efc981276fe17d93c94ceaeac670dd855ea5d327377cf7208204133253f5464b41038cc832478b96aeba56bbdeb7d16b1e1084fcb73c6d57c6dea15badfd19b7209535fb0fd1a1821ec00c465ddcaed01273e8854a48818cf8ee21789e010664020e8d0e74a995db6be553ae9efe16e5fcd9be0190c0435934c90458fcf54baed1715777317be1b00e55a003e7e555b0e0d20b4e8529c7f5f37d614c8a3f5930fff34c8ee191a6d6fdf1b9525f5d58d6b846bf468f1abe4c8a67fcdd6a98b12df5eed467144f3830954315d3d7680b6b844f48f7e846868c9cf9820ea767c369112e80d04abf35e78b2f8da3a1b8af9402f6c053699812208d77dbc34ba17c9bd8d187a7c7e6b9084681fadfb400e2221d22ee01f86bc4e38ee4c93abc0a5bed613cde7021d391aeb73e70ebd2652318badfceee01ada19c83c5f408ff8993e997474979a48554c0d5e6c894eda2bfa757042441e21586268aa59e181dc8960322a5d391f5bd8bc51d9d11183d39058ca569578977ed708093605a2c02412b99c2ad637ae7df60245a6420d33ceaf495e52a11cfc3ecb97ae1cf436dabc514c9b03f6cc6352b07fdbb876571a324954a2c6cca8264c4cd369633fa225856976b567849611765a261c70770dea13021842eb00525c69e7fc43173a8559b86ce6f59413c70c0046f6ed39e062851abada03c065065dcbfb439b7a4de730fcf271af43e1b526173e08b0a895dc055716f8f9255720ad0eaed292c5cf547b3a8389e16b199089d3cc93f969aa29478d80bd61d55e3b4307062b01b54bd6c1eb34b04e12e8acb373910a08ec504968babc32afd1e7cd8a04a35f297c94a27049e26dc117b102aaec79f53a84cce9c3a500e338d4675ca33df38ed2dcdb4e7244804c9baf64ce5009202744266567af3f7ea555102a0e2ab2a619b3dcfed1cb92912067d91a08ccba4781e81704fc8cd074ccb36677a37b271bc5597218be683f59801d192f2fe557fda05f92c1304890830870b93b7560c9642d618e4da7f2862d8953d0e10ba589f45ab6730e3cfb4060d48f7db5533fea4a74feb6026b0d8f2e9bb40158439dc89a6c3b2ec011190c95a49819bc97eaf5f69f631b8091a057876be797917b9735f0add305f1e501ce2544caeea34ca8adc041c6be740114830dbc037238ce2c65d7959196c5580f448df12654011c5590b19c1e9c2a5b71873feab4979a77a9ca4a0182b7149e96ee800c759abf4d94556ab3e24893104783f868daac53afe2c42163953671a20f9d92069c119e316ebecf0c2e0801b51a8b75c47a3a43373531ce48a7b7a8183f390a27e7397eb3dd0c263f4eb53a0744758829f26ad048bff5462acdc82c7e288491811c7aaa2b08956f59183de56bbc92c0a75c71bf91bbeb013e782f74a7d61398f296bd9dcab527e30dff6676226d4ee059aae0e5035aeeb915c4501e60a96c11d6d8be9b2543b053f808d52ca76653381f4eae2a2b398a9a448060c1fd4754dba6b9ac6083bdb56c84777670328299b17cb728d660a9676fbf2156df1382a98c3b216aeb4aa9e2bb36e972b2530b07fa4711e59d57901b654d98cda4d4c6e753a3f7d1735ccbc498ce04f739dfe95af9353a6ca845994b0f78cdfb0d358352971ca31314251b6f7d98a0107ba6d69609518e46dbb51231c827dfc34226e2faccee50fad9cbf4e69203d32b247f27623f28df07a4314bb3567777ecb8a33f4e1485c40c569fd3f83e3685746ead5b19c1edb09259a623ea271c2354c2b76786f1dc8429eca593cdbec8ba51728376f066b10369edf442fa8acdb32a53bbf2eb7241ab8ad38ac2355534f055031c586c46c9138d30a9a6425c16888d1cf12be474f7f6e43b61897374c84e71d3f96502fb63d646cdcf0a17002a2c6493a5df2949aee3f3afd9be0d30b2668df8191bdfa064088458827ba3c5185cccf6e3e0a0de91ccd6ecf7585aed5ef82a3a1d66e641434f8c3b09e7d338ed34a310aa48264ece02c5d9dac7de9ebed233a85c9804afd5b04855b4cda3266c32825390bf8f9545d71532fa1e398e015767b768863e3f224639347c6e4548b7a9913ef803d06230b4cac1609cee2d68b52c1bf5d3a787ae8dc85b1b69f38d6b19d5cf9442492d8a58f2374637273d6f8237f9ea07c8a832a4109ac06086781d156ae815d8bb2966bee213cdfe23312a0f1da280214accf3d75bb189129684043635c88966b03b2ce790fad9371363958e79b8ce45bebeb478bb607789c881739c612d5f87cb90278f4a11cd1a0ad85bbfe2805f5ce39eaed3fc903bf5d725815a6897de01620c3e6825f6db480711d4d577ef92d476402e1a5bfeee73d9ef9c093c30f1982c2ee8ee7e37e6b3db1d1fc0a42c5f866821c6aca446377184992bd47782bd119772082b28e69a8ee5b0aa0d5fe36880cc43d487b0d90673e827a4b175e9602e3d2c72423060bbb761cde7422066c76d0a8dd479b4f9e2085f67edba59420460ebafca4ca154b6f3eb06a569ca9516ed10f683b225c8009a28bb94ec556226dd6d3b4e92b6d99a693d62715e583863b79985f0d62cb2cd033d480471ae7bf1434c6d221d70ddf4fd8a3312b4187c375201a57a1121ae55c34d8bdcfc81c9fc2d01f23aba2c59c3f8b2793f6210c2b6b7a48c90477f4a60c6d7866a1a7b04e02d9c0e7156ce324f5ba6658ecc2e517b46eb5287b08fa07ee52eeeee0fc8664a05bba56505ee6750ee2bd056227b4f2972ce6c283b9cb503d08d5e582a993b561ef9a34cab7e4f6dce55caa6b1fd4298a81c8dc5ccd1e6af09128df778619addea7a45c93ff2ae69be59050b688ff27087c6e7d088f66f635e98cc8f6a25a6d92d1e9b7baf3054ea8e8616c1f5de5811eb10be9d74477a73ccf3c6f280e3675cc813e827a5cab7005da5f02fdb6651d6ace371f00ffd87e841eafe4c652366bff67a1f1b50773d22e9d108c46e15f585f78d1f3069c1d664db6413a0c6a7bac02fd20a6582844c7f4e6881c1cdd041ca521642df11f6345c1e178be7c2615cdef66fec0eaf8034fbda0bf7306a29ba39aac00d5728472cfe49c4e8083b0007507d310106ee282aded1b32f25f8eaf62e5b3ce8e0c1113a130716d7563f4055478e9f72c83a6335fabca70b9957ba5fc1dc9791081070c001b9be0f67233c8d2d826cdad1a3df858fbadd9526393bbd0e77abda69c2557857333bb8554a3ad174d2184508ede939e72666d0685805632270b3e6e0c207220168f0f8c45d4fb17c989843d2dba79cce6bb7c03680b4474bdde78487022adb987b84755c87643dea9db0635f6282f91e44748f151763b8a11f184b07bf35fa9183c203be567211a6b2dd54f689b19ad57c2f7daeb4105f4c5e6728829d6097034668e3fdbe2dec657d55d17231c8352be7c9c783946dd8b3570f40f5b3964191fc1d099f2de0869928131fb71a0716238c488fd51b7fa29916c1851f326995bd5e8ee9d21b70a05533d539252865fd9e22d8f08226afb4d52bc53251071dad631e25a3fa7d8925c7aba283f93bfd04c48aec903e4b678879e4ae9352c9a117338ec6b8c48e30438499e382d6c0c288f3c34a76aaf0b21cf66e60a15eb264657f73fbf8e8b24cfb8c6f544c0c0fe70d9962c11f34e8647115db61c5f010b9c957c4a25707c469631fc3cefd27e3b1dbe07851987d8931f48c058263f8314dcd397eb95da8e67a758b3354042245f9cc2d6a8251aca2fc853bf66a9540e64efc2ae45f4a29d241ea2c44e8c10e272ea6256e30844cb07a540daa0d39a17670c8d50167a70c3ab0f5bd1c77a9f500344f76ef842c76764c832940063c6e1af3094bf3116b2e6f4a0ebf8bdf27ca43a69ff6599a9bb6111f50146448500c0e95c57db66616a27e4ae01e8d82d58a476cf18de42a8cf90d74e5efe3c6e880072c5307c64361bd8026f1e6ed402bef24e3b21753c8176147fd5d092df0af395c509908c875185d20a8d55e4291895da6d596abe195d7a2b23b7c19d247967de6f3e2e7ef60c735b9da756ee13dc06db7e3f34f303c0313607cabbc8d4a033ab18d776f2ecdcd249c072a80bb4b6e7fb33e36ac98432edf1fbab94ced77f6321e4b9eaf436c88fb27c5338bb399a43cfd8312539a580063cdd896c0d45c15518b6d6dacbe7e41b23b3b1f6565a315988cf03898bc45c716c1eb2c187a1f9e3b835f7717d8708f45764e505516dd18a757927dff9ee5654789352bcf946e539c32d8df2c341a1db0608150b353d4fb2ca75bd9fd4b45d8c906c4126a398f003c5c74ead3076921d51717d4e9b0e7a9b8f46529b0c47f3de9fcfb5f23d611fd07dd7c6fb06de3d15ed9b37b2a001b4007b55a81effc6f48f63a1ff80117473dfe07c082c93fef1ce49d414e347bc008c542ae4ce58c2c945a40d83d9479b23d6a39a991dd58610237f81be5e2c0c1bf1d10cccdd2c01c3ed0fd95d95ae26acbd08f0f0de066864378cc054a33fcc130dab86aec19f5c57bb8c6cf2ee14fe37ba2b50bd8bd8bd15ca3b7b54768704e93356ff7e4b54230b5016966e4bbc335025b96780090a9341219582657fab2caa11f572416de0bedf5cc5f3e0d563c38694de275cd8676b1feaffce443bacc1fc97cadbe73a00c8e3919a7bde3a7432452181c8cefe1a97859ec02bede9dffb0d394a060a39dd7581aec3058e5aa1d6a3e2f960bbe18ab149a4982e30025679b874299d5aa6356421592994daa4297562402ffa26ae195947d275ff1f4be73191546180dba7839a3f54cdc64e2b5c89ade37654893d657fdf56100a9c6e4018cfc65fdc50b1c785c5af7fb17c297162f72ed302c12cbba702840b826b15fb9f26ea9d31685f51f8a2add994c264e97740881e5a061044ad6f6fb50610d52e5d03793a6435b1f8beda3e5c20f163cc3af002b830e89a03777b9efd22765c2fc086c975b6c082ed576d3400c9aacfa031f368ee06398fa1c84f233ac109f44ed3ab66d4a3f04740cdd96e0520d0d1b3d1d4bcdb8691db3f306e78f095e69626b4b45ad380ce629bdb7038a03cb6148283f5a86c7e4f0f82810a874c3eba4ceeaa8a3a2167b9ec73974d8198bef3573f97eb77235f7b803894b463cc80bce5bf335578c38ebca9fc04d931209b1ced958cdc0b8265de4c3f9c92eb037b6d7f68f27425d9e2481b979c15ac7eafd205cdf8d8b2b7d5b981c918bbb4d38999e8b31ed18ac3f40cae2bda9a60bfca8f4174283bcbe9f5a4fea1bdb5a03a30fb8a7bc11795402f4ab96035991ba636bbb3457c8896f70fb44a58e101a4a97d3e8643a47851c0af47ac114b9931d708ec310cc6dc15981e53acdb712fc5948b505f40647242c80eef1080702b1a997c36b3eff7548ada6df502f6ec6b5d35dbe13eb16cdf205f90caa0372263d44f9c54214af4ead0507be4549d8ff27dcf04101479f6d7f148dbf6aab036ff28522d9901e4a41331ea7fb9f8fa16b386b835d24c526e4e1af204a8483e84a2485b7a69c29b63ccd1b594a926ee0a46b6973f1ebe1223ec5a7b8292a22a10c797f65cf3b2cdc902ac12f52ab5b761cdba0e554a0cfc6f079506ee80a69a30357b6f18c8e3a9ad767929ec4cfcd57da63ce0bd6700facecdd836372749b625801c60c5e79654b1701e092a32adae1d33b398b6d3989dc49395da6f487b1f8cf78339fc5bc578b782788d4d6cd2e3f19e9cf8f8e3059c0f5c0ae4990f5042382e62d4f985ce67a521ac25484674f9c1028e5f1fdd182777c9134b37e8966d11f63b3f30a3a68bbdd756b40fd3889255d3109271583b3457921c276a196f4feaf7f42590e41d688649faf5ffd48913dee5a387d1925259bdcf26b8d7e9a58b23152c21002b82bb490720d9fd18cc8c15ea6611b2ea10e89afc76b871c02c5deccc3244d5fe675a9d779382ae5240c3b93d1b760a81c204ea679dc603e66e071f4ec1320fcf45f7f09f456bfe66b9097084f1b457d23699235fed5dabac9ab57d6368e695b1a3b4230eb35cec9e693a564c1849ec3c11dd0521f23fe67670102f23527669da56c5068b547fe5572f1bbf0ea5d5c71038d12194d9c771d04871a7d61a5d0b01c5056d0da75da21e55dcbb131abb79ff3406c9388343d19d3dd32cbae0964c320c480efef5533594f39d68f8157c60a13c04d3a4faba180da7403fe068f8a15dadbdcf4f0ae904d084cfa160a63ccbcb71441bfc3ccdd5855cc0498616686b4be706593e5bc669afcb81cf253a097df4f082cfb3d26c6821be282fd82db8135aca7327641e078f94820e8bcec22fb79c09b26948385191a5be5c6dc8f9963fa73f7d4e3d2c40a68e8dba66a0ba368150efc085bc67a284d5eb01fa17b13be8ec3d49a9583de5cfdb6e05b791bfd88ff173fbafc74030a122772015980721f831fc2853b3379a1849b1b7574aedf78373e4da54d405d3379f2c829104f528e0f68532d74011fbdff5300acbee63838a61b5c2cac7ae3d4a0b08f2c10d6152258d30305f2bfa5a839dd07fa58bb782b3da19c866b663c5b799e1768938636ae06beae6d2e3efeb2f0c335c1877783aab3dd171e4ca40e1378f92a70ce4d4005bce84c6b991b6ae2f84e71580c094703e306005cf8fa5d638e2d3fec9c50b046c5b14501c433aef882c7f062f9e1b4ec15e13d3c348e2d415cb73415aef3dc68fd6bef14eb12f26694f356fcaac3a9fb9af8561686b8cb6dbef947ba53576f246d7bff1567c8a0726fe1b439aafc1fa66773c225941b9dbe263fd52fe3a05ddac79d526f7665410d390aff4012e966f53b431380b8f692b49ffc848162450975e0c73716bf86f6a464ccf166397242fcc10e71b2bf4e22b37b0b97b7e77502a49a161bfd5c366a2684015b666b55ec341635341f7008432ca8465e9399e892e728a7db2cdf304f075fb53623536ce36e4dc52e55bdcd0f04cfdda2d0bb530fe3333f50d4bf4c68c9b39a492d1ec57b83866a037a7a4733ddd3795d3d8e14025868fc11f6639f3ec35048126d7e310794420da15f072e7a23a476eb43ae8399086485f6aa3b0bea9ff7d55eb3c40fcb804c308db21c42f6f90d71795a81342a376b0585c54d098cfd2de97e854f640e810de317beff3366b9ad7b6637e8d42b54f8b216f043aeea89730e3ef325734ec48cfea0f4e22093d1afd52aa31ae3d8c78fe9fd0e342b7b40eef3d6c0f9e20e8aad1aaadaabb3fa25ecdd1e65fe42686f92d2c372c0e1ba3848143d3dc29eecb0e87631c1cd41c7752379b138f19c9354b360dfec54565048fa7e51af06dbd779fe88b0b1e580ffedc40462307a745ae27a49a91a1f20a59c510471385abb89735b3c972b9e17a9b5ba4748f2f22578c93b76dc4b5b84b5a5569281c07b5a7ed43b45392ab6b24e89578c1c6113f51803d53ba33519a4e7e2cb2fe409211189451386c59dc6cd4af5da7f1cb65fb5b7c4b4803f72238a85018798edc2f6a6a0d2185e6c77d24dc4be1db857f963d6b8fdbbb3bcec37544f5b84e155de4b64c79ba3891f108b8687083b0b19eb50377c1c73fce4b79c16e3add4a65db4981bbf19aad4bd4697467517b722673bb8a6192ac1b376c80a44bc63396bd56b2828870fd4e8434727fe9f7de378b3f2fa5393c8487dd03cc74fc6f1e57ce1b9e49ef8032f4f60d97a561a15f51913f367c2e2de021da4cf162753d088ec3ae907da59a088c45e325a16bfe8f81b7ff03d22688f26338c403f4a240bf90074c01986fda40ca0673f5db0917b224ec06622a229e9997c3c55048f4528266b4df0d278e418034e2492f25e231b1a12af3f9f313cace19af3a5c06e67dc6bdb8cefc9186ac466356331d2bcac4e06fbc3cf45c0809b5ef568d1fa3434b0702a6fd3e147b7d3ebedbc92a9dbc5031663702903030120306ca4925342d2b713c99f3084c5175ac23dd63235315bf610bdc342de5af779c71a13015fc2a2f82b688b679c3e22711f6ea44033fed1b817d79aa3eaa0d770a46b716596fb72aaa0dac7d0e0f127168876cb376f5b81f55b5119d2877fb44a51a204705276d6937d8606b3eca7b82b31e769b2b959aa27983bbcda694f26626b95aec2ee15a8f928df0304e8fcdab9bae8a8c97113bb3c23247c48f42a8d6662c317856df94dd7ccd15f87af2a7f204a0a1245c42c7c605b4d0e35445f5fd911c5ee1ad748c15cb10aa13bf251b471ddfb7393dd35a7db357b7183eab4b1aba29fea3181261101279fb0e48a263c0a7da6db91dff9d33d560cfed898dd82527588aa06ae8a72578e259f3caabc3a6a215629db11d81d29e025f3955632fca50232cf1c3de4d3b27c1a2bbf522a7c765f13067b001e54d0537d2820084e6d0218c842bfddf5cfd4405657ec888356409997fa1bdc5e147e3d755371378a8ba5cbb42ed68ec224765204c42eef0fd2689c2ae7247a5db6f51ba4ac81be9a4d0e5e3450b7d7f1e6c6221891aa0e8e11950b1ad75f42aa70e3dac66db254b8449160b6e77edd01c3ef6aa7c27fee4c9fe7b7284d086aaef60da513704d7117cc91e944fc806a772db391059b6064254e53e17963cf44a0ab209e2497e722942efafe0dfcd8093905d0cf81b2162e3d8fc9f1af52e287628755c74b4d6327f823eef2680dc5d0d8549fbc2b5a9a9ac507168a4af3f47e549ea28fa02a924a96a16a3e5127ec7d76f8ee448a84ccfebf05ae62286d5a5f472b24ad8546186df7c92c843a8b849df3d3aa7352772636294f98ccf3c47cbbdf74b8355f899ae01348cbe2d6d9ae2e1c24ccf3d880bd0e44998924dc6211d8323e304df00ab7dcec88e78b978d9bfeba60b9075c5c300f753214c5c4c5fd5d8dd873e8e2a5283da9f7e336666050acf72f07f0e9ab1c9bf80f2dc3b276074565f1c64c84dc1968ae2aef86ffed39ab4284d1b6b7c023e72cd17e352237d29f5ea2cc148b826fd9c8376ec26e451f3d1b4fc37cd7b4fb37fb610bb512cb291473e24ed751272407c8406098619eaa771c84cb5e893169965b01328678597b8e55a174a986a87469bdeb534a62959745d499845a5352c4f4fc2ad471275dae0827ddb07ec0b61852d68c6f05ea32ffcf667744dd4208782a1b74afa5ee37ead5974411b6669277232598362e7bea5e7ac90b18d72a70822f5c8c6adbd78e08697a2507b8412c055059dee65315187b431bbc727b9e33f2cff97dd8fa15352bba3372c77958e660683ee292f24545e78a2bba12546feabf0d5224a4eff6137763eddafcb0c901f2e13949268413b37f1f8df715b4d18e1c025a9fd81b4bfcee3064a157f40d6022b305ff5b38023447dfa486b53d19b16256de5a68ee41d4b03599c4d50f17e1e9bc686b12749f6a45d7ffea52c57effae1ba661f0e675c49137656153c65546b53d72cc5387c0568ec3cf6ad1abcd958abf66988187eb74800124452284b9d7908b7d1c813bced1f759352b3f79764f8916ce900c0c87396f172b5d0366055d72f143069b5263a91dbc54dc712c383829ba03e9b550532bc592c7b0709cfaeff180c2c6625ddd57cad67e1cfbc885a41202fe495e053dee8ed69fd813ba0d11679f7308fc56f8bda6cdeebffa1fe6e0f384a039b86bebacd537e1c0e5aca90a790ec25b74143d397dc9456db0c47e41c43b34f108cdaf6095f10fcbfc325cfda3d23369d186e2de06968870d8f5f4efefd4c50d4238ebde60750a26efcc6638c7fe617a8bf17555a07c67388c6ebb79bcffe9487cb3475856f87f0bd62676666197c104560ec61b7cb27e532f4635c0d0b195fbd2cc47da19b48caec47782b571284cd519f41787b34053a69a514d9da9bc1f351c51749a2be446fa4436ac95d3ffe79e1cedf0b557501c70eb04bc770e230bf08f0532138e4373089af868b953f548cf3a26163e3422d7d75dbeb8e8065555e498f98b83870c8315adad9c6f9fb7fc77338208d7610b4c9cbc7846d457c9e6f41162423aec63bf35a8b0aab61c1141b3ea2a7a916ce9d1576b568578aca342ec78a9b62ad443e503bb36845fed73ecf5140cde2671bc81e6ec71acd3938be9fb8806f4bc0bf472ddaed566b3f38abe5485b8c5509cad4b52111d18af1f41b2a3b127c658e47af2ac305d952ce3554bfe32cff63e3cf4cd1c7514a55816c893d640486c2ab82e3b41b4e7ae7fcf6e0c47100027b31c3d50f6e9a4ce20bcd74617eea504064e30803bbd57d696ae334dd93e4d7a0e181458aee9a51283c94439e9077d7264adbb3b94e9aab96d4b4b94a0cf9acf7f5bd4ee98c0edfffdabdafaff4562b137fee2fb0451541fa16c273139ef088e1ccd97c0a37d38a81982e13dcc385ddbc9a92a3c8f4eedbe365d12caa0dd7036e39cf0cb6c30234c7eee125cdd7dc41dbbc057202ae3d5c2b3edff3e33e571cb7996071b5db674c272584e980478b6e7c9ec16d7b7c7ffcaaa9f60111aceebd5b610a5c07ba5d1d97b55e4fe35b6452790e7d32f0b4bbac1d3c9b91a586a9a6d6a37dfec57a19a1453ee9e03d154bcf788d5863c92fb8068809f762c208679e4331e7601eb9ee70063b03dc7dff2c4fea3a9ad038fc4daeb3b7cc6702f90c46a2c34ff26690566932d0eda17eccb0ea60edae9700710bd0942b6f47306cde9aa01dcddd0112f87c33fb862d68b25c3ed0b57f99df907fcb2c68f91859a34eec7a1702ec8df39c0590079a26f879643ec815cf0721e9e87a3cc4501594bc1e7880532a0e004d261cbeeb0ff918b012deea69510309c36dcbe0f35d3829481392c3b646efd211344a2e3cc6487fcde9f5990a62ce0b2eef402862487b0904932fb6dc3fbb6e5c68cf09d85b9a54205810e86a5229c6e976aa5e5bad97e227ea60724ca9526e641f0c282e00e926a4f160abd85c67df5a90a2bb24cb6e2f43980f256bfe116de53fa92985980a2d472d6cef2ffacc581601792e165f2ec4e35276ebb0a0e14fb14c82a79e39e2d706d7e562a5e85fae58f2cd5ea380af4c5c905a23a19cfaa2c38aff1d4e07b4d0021e9946a989607180bd282637ac103cc558a11fb085733287b281ba7e8d7b39cf59fb3937df8148e9da80825f2659155d932fb42881f0dbfc5c501ea13d9cece3031ae8e375f8baca17c24098b4f9d6f9c3b6a130d17669d97576929940ff2d7742b478286f449fe589fe0de92995c339b2571c282fe7078acf8f6e390c09a33f05ef08173e1bfce41b81689bd7670c9a2a3473c01511427e9db33d4a2b7f6492b7b6049b16ca9824233344cc3b64d43f969a32f01113dd5be902035b02cee4e64b09c5a3685252e3d4fa3fbe84e06f4033d7adf70122203d450551600e75e41c41e5acea3149290e146d5d2de0f0eb0d484b0131b826dd574c198fdbb38c36859a932ce1882bd1e6d3a1881f60bb5708e722117a91349d2cd56d9b81dfdec9ea043abae7fabbada58c41230c1cc0443020ea218cb6bea52007054ed8fa227e1819b94a8b53e9c6a326fc9d8432fca3841425eb5e500fc1791759775d575b25ea38e33d12f143a95260ec78456c314e3e7f8c518afdfa9efaf4ff155d97a77f08986165d66ba2cc27e4526902e2a894997f7ecd9a1357105072de1b904fb8c892002d62217a43e1f9403355e313636ea208d7a1ef82d5c0f109ffd8d80ec01531cf5ffae2852c5f41f11d3fbebf402ced1b07fd6877d8e2d8ea964ce3d73f763b854229dc08c836115237bc0172c65a6a9821b7528231e8a1f3495d740906c176ebc417ed868888bdcaa38c399031133b2d84751b35de4ad7f5003adfd2396367dade5765162271663b295aeca5fca2afe93ec53ab0a560064422f70245b4152cce77fd6c7fbf5b4978e17e95c4b4cc5cb34ddbee5842f12305f013e5cad81e95a0e2102d629da40efc8dcaba95d4548b514b9cfaea574c1280fb7e5caf8e141a29bd094bfc9ec54ed44eeada93475630317a8700a070d2fa718fc275294968e79a6978fd6478aa071f85f3954bdc63c690f691d0ef2daa90d84f23b5f89cfb669bd0321341a80669f27c766f3fbfa220a014f26709a30394b83e2c470a92fbd4899811eac20a304c6fc2889997383c92c682e6d92c049ed56b88c7500e8a6378819797e595797ca70bd8c1c42321515737183df8813c0b391fc462e3bf2852c6e041b62a9736c0d19eaf0292f6865a41b9ec29a1c5211e66db49bac91caded2606f5cf9fe2692b50c73a54738ee9dbe3e543ababbbdbdd469a107453d08dc09705d541232f673246c68e4c6ad472e44f641932dcb9981da6a3d1ebf306c043738a461c947f9ebdb43c5fbac86cdb4749c4cf0ba66a0c9eaaaf3fffd8a6e361f318e593c3e2a90db88ab5801fb5cbe35ea7c66ce630423a85d331f0992046d3509c6416992836cac41eef55222e0f4f802a8f14484d4aee263c28ea961b9c8dbf4314e834c807309a63e23db0ced95bdf34aedddee6f2848567d8ff51955e788eaebb1e8c4b708676b023a939e5b28434cd1e1c3acdef2fc1865265dcdadb6f504beb0d21befe4aa18d7d512abc023ba3f446d5273dc6e5e41b10f768c71cb95006cd2d5442e0a0768656cd78a3baff475a39c3790063c25ea04ff4d8274ff820d5f0e44b3c541d86282bf8cb7ec4c5c3e1a4719dfbd8b2a2178a2754a98a1ed06077396860e25d0b6f08f78830bc82993a86ca6a10ada0ca87a37300d690e97460f85689b52765e573f5ef2fd4901b1ed455f5f80b7ba79f5796ee79bf4a2054852500b1514bfa3f858f1f14fca338f563c359402ae6bff7ec924d3e8d7b47294607f80ed3735c098c712dbb75f33a5ac2730bd18225b644a1ce6904717cb1b571a0893aff3ec67ac77f6f6f9f543415c0ff4da90e8dc6bd1d2b10df1759dff92aec7edbd04b851487b0f01daff38ea491411537b848d235f28829a03ae559ae73eae053c32fc2af9d222e874717430b7571b2c60107e89594e5b5f4d27a56448e801773bb35e9c27b7abf0a78d0e2e5d110f292fdfe7fabe34d409b1e791f35991df69c5a27b7a825dda9d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>七月</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E4%B8%83%E6%9C%88/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="31148ba9a65b81a116a77a66b1d6a92a0e306d086ce6f91ef5457206a628e4ed">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e6b9306cd99a79ef4fe2bedca4c3b94085bd082a31af65556655b615893926e8254d6500cf88fd10abc9947172fc4ecd8e46fe76599dfc250f60b49616482cbfadbea77ddbbb8eb55dd21190365f8e9e72db1c37f561e54fc903ab250b36586759a7d971386d09339cf181fae9043c70f891c767738574b7e6038034cdce8b778f749ffb56ab27b4a8c4c5b9d6a243a9a4db2bf31a62f7eeb19d0cb90facd7f099bad11744a36a02859b98f4619856b811e19bbbc81f0faf8c95132a93074448b9e7985f90a27f4bc4fca185ccd1a13e8c0ddffaa9c76de746f73436928588f8837770e71caf7f11ff2e7ead393c255cd463542a15470932c3560a57b649e9a46823fc9586272ca7a1c4e4f470509e6ae60e8d3d8490412bd15b9aa20288a4872cfe4ea738722f1d8478dcd933369cb82614a597c35380e566fb134372f6b0234b8eb9f7c3d659f23b4818d9925ea120b9b85c1a8c8f0a4c2abaec22d720d0a6eb457f91676695d144ee63155f91b48a4fbc08da77fcd1c9ec1c022d86edff3d98a0c91bbc5a8e3b4a4d3c8f24f96307a6de668894d569f1a70e4f8d04f78e9ff99e896b68d5618a1174916aea1d36b191028258460372d7eb68a6a2681f76aa42c208eef7e234c4828859d699ae470e3f546bbcedd740ca9ef24bb1defb7887933197d2d70345eb96e7d1db57d7409e2662cab6ffa1d36f3768101844920fe323a35bc5fcf6c6d9f7c0a0a3077eced0a93d1e4ffd20f31ec0e5e726d5761d84ead25387fe783555535e3ee571ecf1d49ce73de9a7b686ac6d1f1fe6aebcf96d6e4cee924ba7c034ce7493db4226036c05485142f42d9aac29e73f3a0a32167b3a946dde3aaaa2f2993d7ecd9a44ebafe6838ebedda2f58b3645f1554c772ce166db19365bbabd890217e2b1b64ed2b45a0f04101fbe93f37bb1723966e8a8b3074b53cdacf7901227e1e3057f2ae297524c9b691f790b83c290d6221b7dd32cf4232aa424d235da75a4d12fd157dbc4a427f97c6a83a768aaa5aacf059a306ce88265aba8b8e3968c48f38626884d1a96dced066998666563afe1f330c078be3efff6d6432b4fa427b160e8b24152376f310d334c0da1bca1ec361ef5b5ea3be1218a7c959711cab94c1a13872c09f22e0d44882d2f9c026af376c08d50bc5843c3731d5c88a7628e19beb12cf0fde9a29c33019917d21cf8b09b7c28bb8d777624d78478e9e32958f0df2dd43514290ee2bd6f8f4246fe4335ddbb6b9d2956dfc4e4c39b8b92a3b8548cc1c72c85e56e9bc2bb349616c3b83fd7e755e27bebc48b8519b34314197d5fbfb9007feaf7f9abae6a7858e9d332cbb4ae38ec4f5058ccf701dcd4c1b6e9b8a02b44f325276061654c7f3a44ad013948918b1af60bd2691b03138f3f857e536ff4507a06fd9578921285eaff0a678b8139d309ec572dc10b6a6616db421c4bb6e04347c8fd51997fe818a060a197f2ec321239c276c9822c8410a9d32588d7a48bd1cbcf73826b530d27d7211f1e1b36dffe1165ac6782ab754edc4f68cd59a9bd640b517747f5152043c77f094c2827b276cd187c42ea655014f73ea7981d4fa76a3b98615f503a148bc44cb5469dca74a99192f8926287036ac446a5b3367b5732b0cfb1c3be4134e12ea7b0d8fbeaacb7ccdde0dcbe246372621798bf7312870f07c4131d0cabd692adcf6fe5774bd638e5b70d3374194bf3741ab57bbca703aa80c87c3d985ef07dc08b34cc453adf4b1c7bdd1deb605983c224c205179e33f66b672b18a837dbe3640d3cc07d54e7ea56027e5225c0d93586d5ae3d222ae51777c5bb6c734cffd62110f09e29f695348b39510fbff85d82554696e97565cb8158d0da6ddd5c5a515097633e7bb7e3c853eca7a3f1d8d816b7a52f9eb69522244dca815895f12702bd54f47b6fcd81de5382c3fd07cb42eb60318f65838c080b4f0f3cb21b5cb2bc483fa38d3a48ac8f3ab44d6a51fbd7765ebbdc3796eb4e5d24b4dea3891594cdb56e348d695088be01acb66ea8e4f4bf24c3fd0222f287a0c4d975c9efaeb488de353586d5e238ed43ffcdf4e150031de2603e6e886683cf01213cb536317a7eb6cf7184e9cbea4143870b87f5226991808473cc119fb95e17925c7babc8158d8ae9b0fbefb808105a2bca7f99d5fc6982219f7d9e07be9fc017523500261e8ea5cb85c108d811ecd481a32a3e9492b08db6f8aec9a1f125c47eb8cbfd3793a39fc349ce7d52a15e4792c4b9bb4b3fef7d5d2fef39ea12ec93b429a4df4f4fd46b87c7e365db8b339e109e24c2e5197084c01c482c2556293af14bbdf96f00967f4a6d3209587085b26d2cd510ed0bcefc51ec22b1361a991c43a5f829fffd2d2f22f2fadbc9e0d899a7770b0764375f122311c4bf7f1fe7ebb1a871d45863bacb4cac15fcad94b558c1c084d8e48c2f1b77a99264faf4808bd48c32f74681d9849760108011ff8a10d708617c4b184c5a96252b2d5a2499e7bad4d3288b5a7db8c26ea8d785b93abaccde1b99446fc803a432ba84b43f14ba103219751ef84fd00ad9f57439773e5142f755c05d7c54f0f14bccaae938410c369dad38484fd23f079f8987d0f508826d197ea8b036c50eac9369b26176eb79cccc5ba788868628ae934aa7982fee9198d06c3e80d9ddea6556f90c9a050a243afeffb4385b756b8ed13b18dc279ef33d29387b8c9c49c32a0a4ac282195e649fd81f9b340e21c126b12382697a4bd783e8db51051a54f13a616a33b19de66dbf9177b7b5cf39d7f162203d40c43d5fbaaba301505c0d8e198327bd8350e31b66e11abdb2da744ae57fc9c5d23158ecddc653086fd90b15c0fd5f64e9ba8c3e6321eed76f743c067178873ceab00a96c2eb6cfb099593769b07e756779a9d695921003e3ed77d258b7ddbaca89dc982ee15a035084f07c6ca8ee60685731f318300876d4ec10257bc1c898e05c3f3b6022fa3302b2f88f50520466d35f603051965171053cab8ed282ce38d60bb1a35b4bb0e32e93577e3535c7c9d05392bf0def95b0ba6d659b269a85ee7709ae6f113793062e5f5c7a98c8c1913dd02746501aa9c36920d310d3c5dc4422762059c84f1b81b8ff05405c712c74aee388bafe369fa983268f08586bc508ab7a3bd2203ecd7f6a5d03c41c5bbd292a3d8cd3c2a73b9a87b31217f5e0212f93cac4bb74200d38188d5938d0ac4fd9326c7456fb9451be1561e73a32d4f2b0e4c972bae98922a8f8419c2bf949c59f8eff7bf409a7910250e563d2fddce5883d70cc2a9ed1ffb5a588ed19c350892a03d58cb935653c189a57b5613a69e836458f91c47373d858e5e899eaae464d52b7a7da2f4ddd4ca82f124cbb3ebeb9b8fef52992b9ab8be11c862e684f50498bcdf3a5ef043df1630fd3d4ade1254e79929a3529aa82b17cf0b3bf4b8146bbefc22e88148f3aa71571521fde73c92b789d18941523c40c039548eb4943a58dad0bbbec75ecc38db4f16ae8c82c795fd52e6a82383f5eb67f9219480db0075e674e41d488e73eaa44a37c3854b2aa68dd60ffb47dcc19b829169063e31da2bcd5d6ad2241a61b88bfe824a1da2db3769b2e7dd8dd7e441e36ada4e894bd0e04b1cd4f7d99cf10679a1bbe8e456eea2d77ce8b84e489f738b1e274af0ef0310beb2fdfaa01e017fc4152cd60a55ab86ba49ec59c9890a76759edfbea3238604439037a56719f4b32a706fc3513c9cbada21f8583f3e816a06159a0f2af00c62a2394937adaedcbd307de72b1e3e027eb202056ec20e047624694518799ddef671f489017cdbce62aa970f1a6a0233a9e2d98fbd8042bd36586f84531b5b7d04469c307ebedde7e753c1a94f2f5aedfa0beb6d00e32797c37624a7cabbfac87a7a7eeac54ce0971eb9624e7869cac674309b3fcd84124953827d83eaf102d053beee956c591fa67adcc59218141b801a34e1aa4e27b8f20599031d0c83a752e060f68efe142340f9823d26ce6365e5976b049b5eb96ec4f13e7991ce233a789f133e5067b85646b47035b1e4510c265fee501833fc677728158fa501387de1a56ebe3dc5c8ceb2adf5a0f7b96e7a90c7091c7712e5d56e056dc7549b92a150b49ba3141d349b772664161d9bcbd7b43c1f7473775b39e2ee7d67c4e6c413c2b13026cde7057d74eeec3d064b5ded79cab1e0c1cca0001f248f6f9db811f966e92896fed6a6e5fb0cabfdd8d14a35072f7bf2ddc4fa316b5aeae64075e3d669a67f405d2331f15e9b481abc6ba74c217084baa68fde3d76113e2cda5718a8284ad829a47b39a7b7eb6f3ff975c5e73e3e85c8265e3475271d00f4bbbb3439e00479e9d071857ca6d220aae62e927beb1d88e3e29e2dd731d22a50519b78dd9d05d2fea36c920d3b55d2d7c9994963397177276b572af2eb0bbeb981de23a2bd320e9a06bec7c025677e0fcf62d789705b818e3836dbd1b29a0035264a22ff621ef1719d2d1c0cb1036cf480bf5604d175b7bd1ad70b4864e7542313caff4a8253cd3ceace3d570136e88a074fb8e33ed8f583e886b229a4838d910a96aacc009ecd38c1ffe23c866a015c4425a53882fadbf15a53083f8d3331f40c8c167a3e939e02d7bed20cc63d135e38ad1916d99b19b9e1d84674aa0e8531b33ef5bdd0a2db7e50c999e28bfa575fbf6d6b7196dfcc0eb37f32c0a01e28a7b7bd9eacae394b80d1c9d023a23a290dbfcfd98c74b3c44295a914e165bd520d3e5614ae613a450ba692d11659a3438299c893b198972240de8eb3bddc0a31cdcb4f9c6d3d9f826b867aef946fe230b1b91391543adc384a9c966663d5eb2243aeda31b7196e52990bc7dd869e930f76560f45387f08146a466ae411e7a3d6e8205333f8f31c0bc48add86b1dd441d75c0fb2629ab5383777dddbcc70cdad2951c992240cacd3dc2eedec1017c9734f6d70c4391c784244a1c29cb0892f668c37b0cbf8821757c09970bb71296cb7308bbfdc800b937fa923a2735bd365ebf783d624185119897b149a4b1a8c7bb0bb667181f7a8a4367c74a29226c7bbc2fc8047c87433d52a08e9df011f97b6651ae0087ea8b3b4c5bd9fa53e75e02da23ded8f7bd177a03f3b6862c8522c4def013d2091168dafa73cb4ba1e4d57cd4af3b770281f3ae36facf43066a64d36e88d881930184218f6aba56bf5b2ef77c8554cee8d644a81f659ecb59e40b1d601fabb960c932ce2fbc35417909666730a03039c4e4e4d242de1e70c906199d4921e06239f81c24ed2863a360d74564e35804ee32fb78ee19c45311fe136523c791f7e685643c92dbb7cce8babf0063a81b70a8b08855ec76adaa8344d7f85f4cec2a280c92116c3de2b1c70cef30f26464297bbdf8b452f4e54230655c0a638d346d9e3968bdb284126de0b97ca07307cdcd9a38d459cf0f378dcaa14f7e451e9cfb75a4439697f07d1b6fd52e1e53b414baa4873dd1c675902e53a139d8d04af33d514a8ac1de224610a8103a23213f3bc7fbcaeb5b8c687e918faf59ea30375a3a6e17969feb4c1a39302087037d9917cd0f7e861a0c8ffaeff3fa094a57faabc745c9420c49ac3619a495f0157d8c422f8be7166084ac722695a5971d27fd41908d98627c3410476564fa0302e6b1167f98bbbcc15ec75262f1e31fa55f34e32d313bc1f7b78e9ce9cfec048f2af9258e378bc10180f86c45e1da8ac1bdbcd13c93db3f315895fcd741e1378fad217099a6de0a0c70e9c30784f1016f73897fda17d532b27ea39613a59f70c78eeebe3de0ab7cfe0bcbeb161e514988b5157bd4aefa20c067415fbb7f45f68c46624d118656abe794c604295ba71deaaf39c471b06e0e6791533ec69bbc8128b05d25134e1140d3f8d930c2cf6efb70d20eae49882f28e475feee907b84cc21b43b475b3523ab4b02a3e13adcc5e1287376e6258c2ac89754c2a2514ee5a87b7f34bce09b1882301b8c3449e06057cc31f033d95f704971afdc18004ad5e4b71a1ea0d545a4d3f6701329fd98f441daeb039f314be40d29ba160bc714e8141503a5766ef09a84aa2ea07c95b5ddb419d3c4c1ce1a1e25f42bfca9fc3ff01beb057ce74cb7a4d640c1944e29965888be90fd75e2957698987438e026cf90f05e49d95f6af4f5cc4f70634262f63eb79f175e57f9c4435c951f1aec06a916e0a23c4127c757a169e2ca7cf851b480724c42fc488d514c59b05c66710c5f6d56a87d48b8cbc749091a6bc86c87ded3bab57b4e01b326d1e280b34e3d969fdde867f7cec155175b6621a69051f7fc5ed8447f962d3b25f529c81c1aeb99e9d39f1d4fe20ee5f0bdce45c86c079c762761d62afcf8c1000be649985b4c484fb6db2365d662d49e4609c31eac393b365d734b64e91d50e0b2352b089d8ba9bc130b77b4081d5caab65642eaea342923e9c6b55a0351df3acceda8385595f255d23e4b6384dd18c33457feea18478a11c60e11d806d1890f9cbef62e726fbf1a9aa2efc8e30ab758990d567b4f76695d6cf809987ef5d62b6d7d504df23ede0b30fef652e2f750a90544b36afc2ec1cad67fed5e8567e7efa636d825c8b802bea5f5212ee1730243878dac434f72bb24e453b9fef36b94e4a91994c506ca53985931eaee59743b2cc74f896476477c42848763762f2fba36b42c5bf64c5c0ce08c038eeb23596f72a9ad62a99f6a5e240f0ad0c061ce7e024a70d5acc0fbb07a819dbde3695630615ec1cea76ef2c93b3ab8b6c7491810bbefc6dc1d569455b95fd1cdedeac0723016e77b9cd1ca2e1fa571e1be16dcfb7904d85f66093cd8346999049dfeeaf0873bd2a751dddf90961ac659fa04a79f1bc39302ca5977a20e2940e898ef489631d79200c0502c1695384d99885d546b88889b93ca21985dea5d0b6fcc3e84c33f61a8a76e1c29f8c60440af3dd7ae55ae702f47466820d41ed1fbaf65d146f968f4060bbf035cf5706770e39275c580b7de16ad0d705c3a74b6191768487a8c86e858fe08a0c12748c54304018c4797178868402e8a89acb1f31ebfe1d1e9480b69078e2dd6868cf66e824aea9a90bc8f3a8c90478e232188c25cbb2929208ec0a8c868e9feddcba05bb4b91b64c52270b4bc90ac5d199a8b9ea45802c2a189354663f18a353ccdb7ad7053ae1e65e95731afe66a42a9a19daa0bf61c26ea7375441d9ebc32e118aafd037f8a0c03b360f434416098091a132ba8313b102696d46d3f0f1e054a95d747ff26346820aa9ee429867e405ebe10d8ad1b150f3156108b96bb3ef533f162778d2dcd82ee83e473772f5dca11562288be05d1b222f25c9fcc1945bc7c4bb99070c474eafbb3bc681dca33522c2171a37016a0d8674abd53e428f2fc7f17d26f5a7dd5e461bf7ddec06e881760815f0d538e78d40effd926badf9eb095c92903c6943286bea79459212fbff9a9bfa6733306526133a06ca79c00145a6bb3024f0d566267bab5f20c627f421569e67678e2bc2545ee0e63caa3aeec3e48f47c407f70b52bf31e5b85775bd1cff983b35ee0f38fbb42fb49142a68a925fd7ed2e1a0bc8914aab0c74f6023ee988fda3193ab5c18ec5cabd3eab79affc9d1eb12acbb39d0ad8292a96059a545758241d0c6901885eb9664d9fd6121c139d756926b745f33a26771216a938bb6cfb5928243b39f47201b1c4e8bc43dce23939c24b93a838fd849786292561fd6f1594ac82875050acbed4bfc7faadbb114a852125ee67766aba6599a95acac529b4ef4b81f16ee06fb234136ae00dcc48edb200294bdd3ada0a28e35884badccc3b6ed9647cc6b023d7dc92ba8e1171e49d440803df904d254cf67095bdc49d3fb6e8ac7547b709085d4f040dacd5b9cf6a7a0cfee545631440e10bcbd9bd0ffc9ab046b14f8d2eb60258192342765ebe2f7495b1320841990598ec02e3043bcf451bc4e73e48ccc27d08df4e4979b1502802d7630704ed8387c8cb41b7b096f77042ccafce2bbb51217c3aa2586be187cf1ba01167a104cb10af3438637b4e49e29f16bfa7a3ddd5cb15045bf29865eda08820e973027773f7cb13172c83bac6221469d5328ab6305f58e46139de929d3bdac5d1682f30648a9cc6c4006906f55a21f85b697352a19cef4049d4f099da7ffffa4b217a3f65c297748092644e2bebe56880c9e3135669ad25a321f096688e3998c7fe76a0af531393413a179550059eed7b5c22ae16a6bcb1bf65784a671da9eb69f9677dd9abc7e9077013e74511651a8eade5936be07ec9dc9cea7b4a33e84cec0880ba703858306749a82699868126e78b57a5cbf62268dbf97132a8ccc2b86649f5a3899fec1ba78fcdf6781a181db5db18c92308b2dccd4b2207caff0eb92f6cdb41af03afa9ffe49e1cc78d83ae62bfa359850d90ed545e9f9fdc52d768785afda84d5dbdc10ed671e8281a334e2de1eedfa13f61bea25df532a39850648fd5d6b8a826965a757e3fd26f586051b7e9ecd203d3315969ae470f7687cce128d8b661bbe40279d6bae5a6edd48de2687e6d9f1c6cb2966eba41348dbd64e54ec7030d87ee4e05acbef92438f0cf5b53b897dedd288f7652861439904c8fb101bc8223d2c49090ff99d9a3466ad6e7a0a457f93ceb3a6a96226a8c2f26a345c55c0676f106e13f50f573bd1f59fd2e92d001e4396a051f718eed16321ff5d483ad952261272a1ca9cbd6c5e3c1f4d317fc73f64506d7ca42dcdc58e93664f0f06293ed3324effc42e165f5873d842a8bc12dd7987ca0e0489c2fcc2316cfed669c0b731a443b6313e27c3705d540e32df33f26515c2c2a484c35b92131ad75223cd3cdcedc7593498f694d82fb6e63ed51b19ac3dc44e852fc87fa0fecd2f2d877fd0905e07c4675cce6d8be0ec3e9ee862495c201826a02a6dcb9a7042e676ff04d73eaac07a9d0bc3be1a17a3120fc062dcc17fd704966d382090a21857cb5df888fb7e55704b70c5d1ed2a38e8f2da289dd84ca8adffd4c9eff05bfc03825c32824212945e2ab2bac3da7afed0f39a3845b415a2a395cf2f546d0d8e240dc9b726a2204537a506d9de9ed5ee301fc98505822700dbbfb72be831be24a07686e49a0e31e7c4b49f95826134105f06713ad5fc7e8e8debdc045837ad8a48082d4c6d660ba70aa42379f29e08c7865d9c211179d26c8648e041f6580d043c2cf66581124206847aa726312af086eb96237333cb95d589bcd198a885335dad4fd78053bbbac9178b6415fc921204ac6ebaed82ae43c1cb30f394061dfa8aa830b71da9864b262abb1c5a2ad6f4ca4856bb0304af9e9cc9bd10bb183770a0dc251050cb146f881b5f827f6575cfe0701a55120c4222770d2b7fab68561c442ba97dea47e47873fbd7c37b77a47bd467eec03a3d4be4f1a606860b50f4cceee6677e702671093750fcc069c0f5612f2db390db0f8ced03ab74a81a85ec9ca842f5bdbb4f7eaf09ea46b4bdb2a13b07f51b466ff3a455772499dfcfc0fcec51b0a36b400b1b61936c3b29da4d7fbfd982284cecfd0b1fc4103ab7f334e74e8d94e72a328b3b72f58058a00ed9c4ea265e7dbf8cb7eac1ce293c6d921068b60a1d6a706395110208751783bae92160700f1fd9579aa165673acfb8be14b070f0cd41d9d83d6b8e54aaa218afc8216352df7cc4dfcf920e0ca99ecac2d15a2146466da67262c653c8134abc4ab05ac91015e26dbbe2d68d2338f4bf51bba77555541f1e3e377fe129a4c7f876abb579a13da84ef240b0250d77a6806e635e929aa6b92c37a2ed598aa67d658dcd670f98b5197cffd6bca04e01fb91681fa828f3fd4ca29ccb48729140c8ee967e336ac859fba8fd974a4ddc5df2c1fdd5632a9ad9603f61bb02bf21e9dd3af04df831485cd4c843ea5fd75b42ac1044d30d2fa0f9e4e93a3fa6083c69d676d3f5640ab952521c8016ff954fc11c346d53a2ee323946b3c93d6a19c7336bcaf6b4f1f6b8fc2cae10bed5690e1071979ce0ae4550a0cf08e12fe3694bf8e4b60cda2d4808ae1dad53d171eda4b39f4131b4be86e11d7d8b53cf6a72e5c47f04ec28d2d1e691acd15f28e8f528d4210011f51bb1891e3ccca7beaf6311c33a86884cb5f4303fe28262d648e76c3a98d7d9c54999d81921f1a3c74e6e9a028d1b6816c94cedb0ff13f2a69f0a7eda9816037d7cb6c5e5af236970e54c97751d560afaffe55149225daa992c0ffe0593abb5b34d3247eec4da945875bcd493e099bca59b48512a06b4e1634dd0e9577992fdf987bec7a5e966d3736ed806f0947dfe86ba88b63eea79f24f49db7d099d41f21abeb29798b15ff8bcd8a1d7125a87c2eab7ded2689c4427435b9ea673dcba5902654c3321ad53bb573f5799eb849f43ac69945e77d58ff65490b92834269719bb72568dd3a6b8ad71d29e055d8ffc45c1c7b80a4859b04c84e1e362691a532993cacdf7b7b1166a7d2841adae00378c044bfef959ba60be8ff97cfe50f7fb389dec42d96c7aa4917d5201bc983f6c0913a0e8b09211016c1ec6345812a0ad20bdd22237e779a1861335924d4df16af815d7b655de114f5a023111a65b21264dfb883cc811239105d1a25f5301af82eeae024ddfa7271647e7dd0ecc3594d390ef537edbc59d0c634f9f5bdb3672bd24e9c00fc6e5eb7eb9fa61103a2c42a08931df376357aaf827d60a95b2f646cb371c9d9675049023d6238b59ae55a434e3c87e2b05f7911189d53086ddffca0b669c1bab09b06e4d6cd7c1899f4100fa26107e0350a5ff92baa033a3c255130ea5be8a71302baca32088fcc2d3755dcfb65576d665b524cfb2dfeeb10b73f9d32c71d2bd5f6c76c6bbd46e1741181748a8fe4dfbefd4e46a0574dd74342ad32ad260f91d9c1e4b97c64f401b9b73a1191a37296ee7521033c12a6de6dd73b1ba54a941b25c20f75a74a2eecedb20fe774d679ac9bac153839394cb8c0b6acdf95475ac3b0619ecee3363e132920bd233f279f9b31506a75f460d21f0adfef4001a0946524b326568a8ee03711840a02b205996b9be04ff9da0d65057bf18ab859713ff421e43be5990f12888f3d2164d52c7bdb033e2a93438d8b35e91fff59ec0cde4d02908192df73c2bf1c869b6b1e01c726ad6b446ea321f731c4d794d73d430824cd2910e3ed1f9ae0d102f74de75ea5688b937dc285a2ce71a92b135ee627cd690795cd404f6a9e1d730b6b38b0fbe5a0cfb54e8bbf0ec0308dfd2da33db554f9da76d26526a3762818845364cbd1627da777fdc50e07ca9d64a26372d0600ac39c3918b993d8db35e5ff06a50ff07739df1009404a54a3d64ea68534739ba0247a609d0e1e208f309fa3428e00581cb9886015d24c37d5f1fa464bd6d086d839ea04c308f5faf07309d63fa0f709499e6bd071a3427f2de0d53296adad9e63b25e7c27e43f5305da479ec18567a8cfe43d1c1c3ddb6980a9cd762b42ca341f49630cb92db0681cef514ceace8048830d7b68268eb653efd822700a9ff4ff72a0b4b8bea51479f47b4ac87b4f281e46b3f62910f75f711391f998bf00b8d2662c0e95b9ecd3de3b0c7177e2e6ba6c186983a18616cf666bf1809ab2a88330cd3c1dafb95156859177854ed319900e9fed23a30740d6c7c0dd03ecd087d51d242419347a2a713d7aaa3512876a18293f576c581fdd5c4a0273f0dd34a37b43da6a3b6edca6a10594c14851399ddc5a68f4ab6bb4d51e207581391caf4a6d307525bf0c5fe1a59ae43fb5321bc1868ddfebcc1fb41321ce63bb05f9ec3950d2909fca1d3671e9933020a5c71d409070028e3fa0b3edab9070c0439d1c275cad797617f3f8ed060c908ac0dc06e078c87283442d7de12b68c17184dc49b0cf166aac2ab3f5643a627668b8db2aff9fa517e719c8cad19db767975e8859cc25f0ae10c4200f7e06936fe4cc4b954e564817362e8681a4b0246128bcc79c363ac9b51ed4c878bd267c52cad0f410929db0ede5157252a67e5acef61b5ac3d2fc708129a741e63b7603db25e0a494e8b55a6331e5ff832e805400058ee4720319f53c71a5cb74bcce85fa3827bd48f3b97e97e833ab699da51ae35c8189f13c7e499ffb471e4ee078c658e5a4dc9d4b5d1086479924eeaf27c75d8057596d539956fb38a799e1a6b72ce7f4e1896d207f3e8b084d2e29f44a8c3564b4e1b8f3418c076cb528ccfd878a15865e0f5f8cedc330acb9162eaf13279fa0120eda7f69bfdc4e83db9b4ecb652ddbe535b60177d9a10b363f344a41e1c8cc80e77288b48154144d2c8be60921f1ed6b0693a4aafc70faa22dfaea0ba61d05c3e8505b9e5a1ef68ead8b410e80dac76354828e3fe23f8beb2d8da8cf9de38e2439b31dbd89c060859945b27bb2fae506ed38b23423e7adb6be6500cabfb0d009cef4ae6217fa9195aab8a1eba6ccf2a233784eff2673325eccc6c8130a54e77741bd18dbd60ed83db33a157558ed018dfa9e3dada73d622bf962d833ca42b42533dd4020c8f730e4cfb6cb48a6a9d6644635c17be7300937f4068bb05a71a68b16fc9b36570c704b4658933fc227cf4dc3d29f1d765b1445598fc254748bfb3af6b8bf6ebb95f341049abdb242c829048382e74b6640db365605d13ca44f51db3f0d9210da7cc9441f283f3b7b0a482562598683e1a6c601f5b58dc9eb2bf0ff3a8c6bd6d2d304e6c40467319bc427b6c3c25a14a04317c522f5210832cd632e4ead3085fe0651fcb64c5984a9f5ae94cc47baa8eb24df741877e4b65b930983957db4a61047731302d58f76d37d65c9227bfb1b39955a291ca6161715ddb33812ba6086d644439e95b995e20ddae304cf79b3facfcc17f4235d3513e4bc0d618809a40342f98a99953169e5040f94cf4ed65d0bbaebf743b527a3e58238cebff71f4153cce83cb073f7ddf08ac877ddff5192d96e891f78ee2856cb1d16d3366ad7bdb8c95293c62585026d4c2841ed0921247a79a884384729d2e3ec494b72b7e203743a783e210d078314258bcf80fd3683dede3c860da417aed68fb263f2363d8ad067227229d9faf49b5560407b034aeb153371e01547bd7094c3b9e8ea5a79fd5eeb549a47ff047b49a63d0684fca47df7e961e0a828a143ca69a56396d457c1e9bf45ca1904153141f3617d1b250d2d263bdd97edfbb6887439d1d4608b6662387c8e753f0309572727118ef625b0181c0425d03c6e2e46c0c4485dd5530ff44a9175ea0dad8bf08ed928ef658d96e199c4e73870a27df3562ef7a66e490974b67ee5a03667d1a6ace2ebe37c062ee86f76b15c9a7c119894ba93ed98056c6c51b412f541dd1151bee407dacab6ae026974433c0a4c9f72a9d883ae89c6b65e0b1ecae35dcb54204561027a6819a3081ab3858cb6c41fed690a2ee474eeb96ad744f3a57c6384e9f463dcea8703581dd85fcca74ab6e6464c4b7d2ffee5d8045ea4debd107197843815741b7003e28c2c38390f2d8e030a5b544b2c0d6e0569f36007582c173baea34d6491704e556f511b50b1fc7f065d2beb0fb6d3962fe423525c66c27268b97689842ecbaea9364285359cf7fcc358cf2b1688a88dc7ab54d1f40fbb7bde2f850e2c163a58b1d800ebf4c367a7c7713b2d8876456966c8cc63a9600e6a5850b32e5feed2603bd88bd046fb69c7a4a8a6bb727ceb192c798e8b48a39a80890220ff70304668356b57221c9a374435f0dc1a835561a391cce84360d4cfe654c7be8be7a5dea78d4af5ae54d49b524f360ef4981a483fb0ca888012900ce8f9a134e9a2121ca85620b9bbd9e983bc0a3e6ad6de85f452b52d1e0dd87d838862845ddd4a35fb492c26e4c3ce22068a6b44827f7598b93d38aa8e7ebdb4e84f527577135f4a27ffc5a1345adabe4edc4adeff51b7874fd9f0518e03b8241c707a911f302fd32f23b9545644e6c0cb0104f398648f12040326771bc823ad05e075d475b8c65aedb9ad4d6395238b2a75a88247390bb2a74509caa2e70b4cafa2adeed7be6952d7191b645ae0280c8681ae466b44a53e3799d4ab684892b764a334257641cb9121b9a5afca17b107feb515dd3ea875161ecdc9f935ed6e7e560ee0411f9086fd2b840ff40cf6805f30ef5a8140aa990ed21aa9b8f64af96e507ab92bee14b55f74f739a30726233936e5fd450989e22d19ee2d0f81e0a7e1c2120d336f6677d60050913dcae6864439b66747124fdee9d4cbbcfcf2585666a03d8127f901628b58ecea504553997ed96d932dc85f622db04e8e3d196ad3b3697a356ff4b9ca3df04559e0ffa5e1b1aaf72fb3f4d0e48636c77b9dd84c5472a66bc24e522d92d2e5739342fe165123eb6a56f38dd7bd7616307cac10d3b6d19890ef0f61bcaa9ff16fc7736e76ac41b9f9100235e394ee4cc40aaebab3fb6fb88d26390470c2dc3da7ed015341d242362ec9976b6fe9665849c5f551aef8ba6cc66448fa9e0083c470240390df1ab13abdcee440579cc0502450e2e380a985d862b1838654ed00dd2c0194df3b29ccab5b96a6e6636f3210c3864645ee0a6683e2256744eafd07a86c2c23e53706bb3c47a08c7125f0b04824a037255dcbb1889a39d3dfcd14ee25f3fe1edebeda059c8d69e920dfc71beb6efebf14653145eb4afbbd386e09035f7e0b456f423a9834a44cab164a61552fa342d0d78848fd6bb7d9f264eb866009e2be8f579ed55018eb2d9c435032b288e49a6120372790cb6f2aae6766a382e707d6b7eb72c6bf65105abb0e1e6c1f3c19bf93995e767c44db6e71d47ffdae72c8d1b870f48e1ef1cdbb7abfc810290879ec7174757a9147c92b5cc8543407aa4a55720c5bec16f61474e8624dd5f5b71253c044a9eb2e9d19bde9df84e3852310c72e150b19c79039eb1d96c3efdb90ead7213c4852c72c2f73e0fad4116103fefff559758c5e22bf066788416470f90757d6fc26d5af4756b2964661e4798db59bf3967ac57ce480856fbdebdecb520683f0963cf97062d55285716a1c59b54a5364ff63666622a591052c77158d93116ba58d8795159c06902ccf159c3216a5ea37073be733355dcf09906187b018d505c7778511f14de8173c719d8830837f837865c26ddf231f910780af550674fcf698c72b7f6cc2133f515f065905e803c05a1b10b1c44585bfac0d01f462d210906c077ceadcd4f1835f62366e9e73e2aa3b9b82687d8f6454a31150afc5f06094df5b5a063983f0fcdd73c1d264e14e64f4d84dbbac1fe710f8c175b4f5c4a2f266f9bdaf26df725308b9bb1b5fbab8c626da5aaf6e4e8d6815938cc950440627e49ae3e2f358395486fbc68afa4020666baeb564ed2bc0925d11a3106d0c9356929625a45cba8bc83515971b86bb1d32ae7e44791aae5c04f06e3ca6263ce69129c0c29ba1c9da29bff697788a2b5d7eadf8ac5086c48b09bf590455723b80acddefe6ddcf28ff691546717f6db6ca06c815f92dec88f2dfc105dea67501e2ed58f4adee47ee47b89721c804038d1a90a6fddf437a7be1e3f709346ff32b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>其实悲伤早已死去</title>
    <url>/2024/12/28/%E9%9A%8F%E7%AC%94-%E5%85%B6%E5%AE%9E%E6%82%B2%E4%BC%A4%E6%97%A9%E5%B7%B2%E6%AD%BB%E5%8E%BB/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a3edbcd33ee3c5563c77c63046a75d97484ce7a93c40ebca7327e5c93c427446">1c9d8b8c792a241d8f66f0fd62fc81bbcf4281d289f3e43a236615c5579744466b80b210d0f997fa0609e0fbe759c5d8c00bc6482e44f5e6ea4fe5dfcb3b562f468bd4d8a7f3cd5db7aad094bc073181f1c2ac812bd96b60cf9cc15931a05c7fc5259d1fbb0331553dc40c1f4452866feb975eb51f89bc6215dbed2fee203c5709c55b087926a2a83d1c3cf5c9093c9b9f6712fc53d619249a35f558b93b3d2984c2e5b3d2a453fcd9dc073cd7b18b27f1c4ea40e4472343dd05ee627d416d4dc4262b32c4933736549d6dff69e07992099951f68a95e74f55f8dbb4e1b4d28cd3352b2668accc746d92383931dc35f23c288c22ebd7df71fb06bf3c12968debd930fe90a90a51cc7532da6e108f0a03f3170525dabc9500300f08817ca518d8aa09ed35ae4f12a5d9f99b7617bd16e718ac62f5e6306d22973e5ba31f3e982446160d1c6d39b932cb4e587343e44d5e8b5f67731951737776db1023eca93cb1cc42f7182377049a64f6f2bd9dc105ec1650891d90ae40103330e2b39a90756ec92efb7a5f84520727a5d03731fbc3270eaa7add2614fd0c53a9837ea4571af5f04153666c6f09469cd64e0965866d9999b8e900d96221fc43a3e5785ed618388a9abd29347179b43f31e9fdfb55b5590143690accecf8ed7d2a0ce6a0dc7ef1f91c1969015f6e20bffdedb9957c7f6f8a0332c1ba8c15f154c62ca85b846d1fca088530e5df06e2fc33c7a9742116d27f436d1b3202d7d5d7e38cfc0ac57fbaddaddf9ea0c24826b47baf0c7e9773f18e314f17805497c8c9cb7c5939eaa4b5c322f42bfb2aa0549ffa5dd6fa3ea61e23aa1f5dc7d2b563a24148a612ea82b371aa4be3ede5937dcafb39a8fdccd123f0e6716acd7e9b223900696df122f85521298bc32575fb26f43700fa5cbed1e1c60b1cbb2d2113afa8041c71ec99c133cd7e2f60d34606634882e86d76b44c8119896ac16ecb94521f4aa688acae6d0dc591569c417f7cd752b0242c274110600b76a92ea7cc0a56cf45c1c8aa1b909f6b83968c5d59d7c6c91ab5283f3a5ee73e194dcd220f8ec54a9da0d9a2fcc715df1020777d67e65c64fd8661f290dcb4ad0c44b1bdb280ae80f468e44bd629aff79d63f9f92d1794821013c20aa77a086f85ae07e457d301e2392a13c5bbaec01441dff3ab3d537c76f08e422e705a250dbaac52cc10871dee2f252599f57bccc64dc24244645a2792fc75320993376b4635948c4bb2bb9f39844503d37b908ccb6943f095f5b81598f6ce4259854e0d9a2cf21ca0f84badd1a8570c14b593718147a7e2c3e3d42066a3e77024ebfdbd5a356828ea25f8e9284cf0c25ec3242d50294f2413a60ddf1f8f9107bb2ef521c4940e0c4b93bbcd5e189bd5ef86ab703e81699621a6c10fda9e742589209dcdcce0461dcc91f7b01025fa3293ce328647597ab57d99f54c6bc788cbb8d2082c288dfc59f88cb08f390f21c5caa6d5f92159a05ee57cf411e669a9a7b95108ca84750549d8912f316a007486a228f72035442df186770413374888c36822780ec68b9ab5f0a7a8ee361923e14f3aebaac5c0af80f35e791820ff91166d11d982417696cd3b394f78b53f1dda8d56d20b1eb6f7dbbc9d94140cee58ae6d8f9c69968c23c25d16ed65d0116bddd7e2973787028db6f2754469ec256df7cb7a2c5cb75962731bf4b22407039230807b4f3ee0b479e88428273925aba0e5fefa7ac95f64ab4971b0951a4dcce3ecd3ee1d2f667ea384979f66288b66710a0e91175ff777201c688289fc85a606dd5ec7044504653fb8198e03f98f2392506a8cf4cfe941dbba61039902df097885fc01d4cd3341f4ce8c48ea19720043c418a2946b2f7ddb4390b6da8ca5e90b988f680c6c3adf622503482124cd5bd19dd3c719f994340759b03dd85cd1c4ff5d2f92d6113e1a0d284c45c21516a367f2cddff4d4cca865145b3847674e70ee81bb38915815a85191ba7049360910abf297a9ca5f84a684a1269a5cb5cf2cd6ea95a8d8d8c5260830b7fe04dff444e31abb3ae5196aee9c805a22d95e91284474a989a303908416d9d1feab2ffb32946b5054f97d77044a6560583926316ee774b05262e95d08bc85ddcd787bc51e894a016a52b0f7e26379d4477b61004af0d685b7578f6f1c910ec488403ef5dbae60e3da0a26a0e7138d6456921019e0c8006e558ed5b13ddecfefbc6e505105d625af5b7a3a15a25730cbc6bce90c4a4f7febf16e2553234d1af322ae1fa2ee145455e7e5d0d1db8c67d805800148b126e630a4b8188c89ba9b905f1a551fb0908d110d03acf62fef2d5a092dbd771d5ae5669a8ba85e7086eab16fddacce5ca87f1998447377b5c663a2120e4a6e16140240914315f1bf61756d662b6d82c80dba051560b5707bb2185851eced58d80123e723cb18df27cacc01c0a082dbb68594691e64c909d7e9137ee815f0220aee7d46d0e7f5bd4e9deafbbce1d0897fbc8aea2220903ba2f4d932b7cf501e234f41886dd8b67afb95873113d4e37a920d91a11f5ce623ab8c9857c4e86997fd10cb5124a410934f5f5e98daa43097f04c1c1cec62197eb65dba54741e8bff0a2cdbc87d47fe1c8018372b7756ed97198a387d141b87d13d469eded49f4511bdd5d17b90d49546782d19de9dbd4f2defc3226b20c0408078abd377f7d66ff5d902dae243e2dbbca3341dcde39ad4dbf9473fe49d2ea24904b34b90312069432478202d6c91f624532f7beab5ed5bbaba588ad17b85106372687112b8b41aa3a449d83dcf4bf59be2ff2c651c9db2d6d9138a1dbe7c5a3f7e6198b2c89bec159ffd658032d860424e3e49a24a5babcae6e9848c6adabff188b804659b1ffe85eef8f54149734eb432870059dfb670ffa71a53145340df044507ce29eabf59de5c8a210f00796ec199da40b7ac6d8d09edf0005d1583f648d3365bd690fc1cd6ee43467f21e4b8678cb2225d21e27eafd740bf5f7f7709599234361664ed8d55ed7ad41a14c9a925f4b9f550a9819074c975668d57e30010a9f9a071388f8ce0e86760b5b23adc4470213fc6ed343b6c31fc6ba730b22cc41535ac554085e187a27f8befaaf1e37fd182868813f08bafc29eeeba627bfc25617d45d2f6a9be6d36c32bd1379244aea40b9da4e400e7a52b37a9fb183353f003c61eeb07d17cd4442f6293ada56d0448a92f16a9d3646cbe8a16ab7a909b3c760909db143a033f3e85f5061eb07062c0d851229b8a371f250e691d6a1f4b2d383577d55dd9d06eda8964f8e6b7c01b95615c240d56cf2628ac3c709a80efaced8e66881e0c0e9f03f55e5c418ad5a58f3a606d45d89475ee4c25d754bb2561d5b80f72f2421f542659889109c357b40f21411286468b867b5ebc50c42ca506a333a3fc044cad9519a9f052d817cde647b8d87893562af6aaebda963223d9530857e669ede809917904129a19b82309457922649578bf1b4385861d3cb0c3b3323f9fd58f89853b6135b016d7fd0f53dc74c212ed634e09605a740e9a8ec85d391a6e10b7643d46a31d01aacc3f3ba56dca2eac507e9dc9c64ecf8433afdb919f350703ecfa354a2d0d1fa4774768e74da35f5b6710d55fddcf70c0e5a16e3ea00b72cc58337ea615b8b489ecfc5feb33cfad55ceb370d3ef15e0962fdc63a8ec6efb521da6c10101db89d66e4a4d100bc05eaa9c80c1aedb6788f15629cc3a56736941d492fc419578cc2d6cda896011eeb33a18d63a6ea91f5bd6d310dc7b679d2962dacd563f0825b3ae67b4ff2852fd6c7794286c8ba2a7acda079bbf8aa1c4d6bbd8f5f200e24f87e95065302673c3e54cce88dddded84a9682886d8abce2cb5ed1a9ed1f41e0fb52d8f0d8b400cfbb6d4cc13b92b0b03a5ff0dcc4133b584562a828171c464ab918fac8a46bcfc7d9bf284bb643733e7f2186cd9687e3b0874e8afd953d68baee8423c80aac878be861fd1afb81d0c193010cf85c2f3feeb66b85e7dfc8180c60840315e28dac1847e771d08d3ee9cf0027b398763d14642bd625fd042151a4f53b3cd509b64319f67cf8093f69a427059e31ee4ffd9faea1275672c37fc35fc4de0e0e049e5b0bccc089654f0829fcd0e6c547dfe9c84e4cffa22651d3b9a66247d22a1d47729142ae068270621f54de1d0a5d6ef13c5f986bc730e2c2e6cfad8e8c5a244f6e44852ae88b7b48fbe3e019be66774291aa7ae231e25c4206280deea1ea6d76a025c21846fafaacfc27c9a2bb1c5dfdb29228f2d2180d2754ad6c6bc19665ca240bb93634c06273d44ad63da593d01915c52aed1212927a18e4f498a7d3cd564ddeadf88d556b91de2f31738fd302d52407dab1b1221df0de8cd33786889b584eb8a0b0314991a7a778606ba7bbe1d8fd72e2a1fda88cbf21977030224f17235fa1e2eb592dcff7cac9523e0b1548a661a7a8aadb6ed5ff41b8cf6a7b7548e6caa106a49dac13c900d56e8ac347297e9ae85aaf041e4cf552c90d98a7eb7d08338beb0691db1ad2296bc89e8ba938459317c055cda62f77369a30d27d0e9efa4cdd841e7eb777ce1f64749470e6af18d3800f26d1e3615e88df9b9334a958f2f760d00a043d8b7f8b441bfc7faef11008623e2f75da357f24c815857ddc815d17ea230e55207b1c5f0d20b0403f1b4310e987135d0c21fb81254a4e4c8f767b70b30206f737defa21c312a0453f7b2f55467eae13a52d6366b7ae8127875d436a217f4f080d63aac00d2dfdb3b3ceaa91f050e060b3a23f3247492d881478cac59e99891dd93d7af6b1c02b1f40e16d4f843eaee7eecd77ac61ac7824aa233dbf0e8706d47889d152261c7435efac4bb56b07dd82cc734fee5b6b788d33b7cf3fa1da952f140c036efef9c050d5e8b74a3cd7eb3dfe1ada198665297bb8dedf776582c527725ce56d11eb790817b415463649ba9b1d29d3377aaae3dcff720e764935e0bced199c030945d6202cc61b57c66e677d26aa21a4b26e46c884aa75ee4b5a6ef4181b4d2a5c8775b38742c728d01828d395d6d51a5db107f47aa84a9fea220d0502a5f6b0c2825214c928106f9afd52a35085bea076ab8660fe448f2ce826d217741349ab56f8ec4f14e4f509bc68e10f4f209e459dbe247c50feda0af8bc19917e26de6b907b9c1a47e6f1409ad06724e4944ac7ae6b30b3f1e3ef3d6bdbbe3423e5c8445a222f7edfee73ea01b57a7cc3cd2e1fb00e26a39dd6387874bf4cf9c97fbfec4b5031272c378238044e60c07528a3d2b598fe6a82f76d0dab5417964e26676d42aa00be56bbeb65e0831353e3a8d19bcd3e93999930ade730396b1485442f7ecfc92d12267206adc16252d0f427a9d59683a6f86ba45fdd83104d29300c1e47a904a9a372b5ae45d492cbd4c38391fea859fcac3e9c8f4bf9c31edd555a36dfae1c292e9bf156358fa7ee6475c3589283a9f6e2106595860f15541399ded4f6e7c2318854c3192accb899b4c78056b72e73f7cd02ee4f65178e5892df40032105221145fb67c0ecd83635e68245835aae31c2bf8b457e858e2479a3dde451980eebf9892bc554d3447702eb585a878fd83ded49436532f47856560e2cbb12fa56988bd3736819db59fdb1b0b55af1528d33abe8689592778be6c5968bdd8aa7afd405d6b762bf03d0fe398b178b66abcd00640fdbeb3337628d866c6dfe823a6ebc6241fb211b665563516d9bc03ae00cd0a4db053ffeb9105f80f8e18875a817a81f4c9bf38250018cba6f202ed8bb27a89e3e8fac9c883ef84795b215f59da6c696d4bdbb95d7f04009e6ddf8f206b13322d738f3946d06711919247da22f3024a2cd8dbc5255473d6fb091c61799694f2c8abe3a840c4017fe939bdd615b9c29fb7740ff905e99cce3f6215ea5af3dfcf3ee48fac7b50e9b80960ed45f38113ad23655f986b68e9f3a3c8aff85f05be4e6561fa397bd29c934ce4b0f88db8eda3ef5205da52f6c9a4c2fb32c442d7313ad907c1fba411053f7975ad8c79fce460342547f271c5ea0a3eddf993c687928b0930def0d23d66c5e783883afcfc0e25226126e03d49a6362625b61651ac4c3db1f35501c43cb2cd4d9cc00130e4bdedf212feaa8e025827f4a8af84caf7001df243e8cc3268a835ef4df57f251ab2bd2b9a5666a7b483c7050e304a2a84f32d2a8b519d9480bb46daddaa05988e7a3ee3b9606a619b0fcb514068f0e1a428d64da46ac2ecdf4ed98626ddad900c3cf2df46303dc92026475b6003a7c5fbdc7c2ecb305e9b69f8e280cf26d4eeff33342b986968a6deab8c03993807c298dfafb6668c2acbe8730773cd9c0b1b1e5a2a290c10d4c0b4b4961a6ba97ecdfa910be3599e2080a6bb375b0858acda1a526358ceed5bb7ef1140b8a929befe9fb1ef594d51ea6e97d4f3961f1e91c4d99f393754f4aed17bb641064235de6a3c728de54d2e155f11d0d5bc04b337564b8ebe8aad28e5160bdc7c6c2d55b277fcdc3323de2654afd222759701beb7a52e365cbb8ca306aa1d0f2125cae5ebbd6e0b7cb6007715f7aa2444d33fc06a9a3ee1320982d4463c2bdd366b61b6f550743162e0d7abc8044431e8b54eb56e35e0d93411511edad926ee676f57597a786c0c3a4683c66d94f8a51464d5f5d87a87f7c556de4c389912cb2b6f2a654ce9ca7a9299cb1cbb12748a823ac85491b1507ec8e2b6264be1f844432f72315ce30079d46af3f4061dac88a88e08d432d89d83b0939b10f59cae516650ea2b283326df2f13f3fc0a2402e1374d7a4fa40ee72b7dec500e1a04d73fdfca45c0179f5c4d104343502ef9f433068a9dee2451ff007d4ac9acfb3f2a85ff21ddc3ab5aa4d1c35fcb47381f1018980b26bca517c019ffe96dd718251ba31af4a9f0578be83f282890a6dedd2b0c83647301bbee59356614ae1ebb2c7ebce33ec325d07c69c649a7b3716ad8dffc7f716a15ed17f617f3062f113c5793c24f41f6ed6ec65bcf8a90eda3c1b26a04b74b63ccd333609085fe04f1203a39d81d9aef19ca3e99286029dcddae3599acfafb02ab4740ac387193d27e53da45bf5de02efd237ab75ed0c9af95be7553a184b72a607873d6eaba4bfef939e70f2bdd3667eb0106c1ac00c19ecf3b0d63702f621d3f1b3226be8d5cae9426d913707811a95c1c91b15b3ac5e01b62c75a6890eed5c9872be8f7104efbdeb0c0d99bb9969422b8e573b4b847bfafee456888781e537cf2e0ed6c255b8f6661f7542a28a59f6a8417719905ed6f1299d956585590b46552dbd24471412b13369c0921df8c7de023dde09e4bcab61a527cefdae846fd3b42990563aceabeb47efb928b11e29e1497addcccd3132a3f1b6d1461f775c74ae468fd6871725eb9415f3bd4db4c87bf0b96cfc6dee272c4bc71ca101a3de42b2b0b95a7582ef0d7082cd2b45151e7511bc79d9cc7e77bdb13ccba34db340d8e0ee60434e2feedfa84d4f04a124bac716fddbbab318949cc60e35d550042c167592815d100a3b68abe2d83b8a0fa9d7367050f2e16ed1f728c22d606a07597848a5a0e1d8485e3790824619c747b0e9f61421f52330bebc42f02c750655631bf77c0daf0c1345336fbf0edac5c775ba7b2a89b9e2b1aef56b621c001d121a6ecf96697dc564d9f9de2ea462584c315d64e3a4be90662d778f58db455ecba59ba506f13e586dff4ff06b01812313726c8dafaa4c29cd95ffbbbac52f52af96e608ecd8b720f905a41d1d12ae226bc366bde74ee2c0eaf683b01602ad29432a002f88986fb09ade6a1cb614b35b498d30310919a911c65fb9d02eb829209a5409f2bc75f71631d6e467a809c5ab5b955a372616ded6754199f1e147606266c36e3bd94dd085405ddafb0d81494bfbe8eb5f9f80137a56ab4929a815bdb2994785f605a33229f5d78eca592eefa29462352bbe8ed08a0cc5b0e3f43dbf904242b0bfe9786a9a1032b4e9f63c23bfc7ce0d94d6b92c145b59be319e6fede886cdf0221a0b1bdf5449a9fc0f6a1e423de8f6d6621f52a0076501042365ab792a08fb88a0597bdc849fdfbe199b7e3b8c746ecea4a2c915f4c54f6b53d5d2f178477a3d45c5ff8ad69af10723c559974cec728692e39ae7d00582dabf9cf75b731c2b2c83eca09569fed75811b28f5c1183104c38e6c54d7acfc212c3a37d6df1a90f90610bd6bb5b2e791d5dee1ef147b955b04ff8a10cc067d15a7b123193a07e977c34a11b56ae0bc22033f6091507b1324e69c3fc6f6773de21ff49d2b5b828e816b3baef8c03f4a0fe8f659bd4019ff230adcca7dc461c3407a3945c067b62541ef3850597960ed7c49b4c1d276d3f6c233fe396a2cb297940c0d9dd7e64900d5b67cf99486061c1c53b075161d35b78a78c3b9cbaa5f6854a5cc70c5717ca04dd08e1bcb1d6a81e628ad94419ceb6edc9f56a9c5205ceda45932d9f1c1168f822d4431bd569ebf5fd3172a6b5b24fe66ec2d0bc89c7408b5d3f2ac866d2ce79e0370e3f68dcaac4efff95c622f367986049705bd4c40a4523705f42d547a6570cee93cb1d24474d3654991fd705fcb0d55aebb7ec811d0f6ef33a370fade3640058ecdd47c7011536b6df0442cd5916889fcc0e89429bca4967faab0fab2d167877bcb4c6c11ecee909b55bf3f48b62c65e10f76702450d2f6f06e6776c9c8c329f25953ec3fb0c05988ab596c827d7bae2381d0bd90fe3aea8a5f788c4476d5bdd6ca25acd32505e0bebf95a1380ab5273d3bddab24773c304f8a71ebfc255815814475d1ef73d2cfd9ef4f11229e5425f7467c8b2fb261809974b764bc7e0c096f61aeb1278c991a2b62ba4404c384df93ca799fc46f10efb9e5b024ff0bf36c0d7954d59024824a1fb11d15f00b7803447d8a57d5f7318ab2d6f471e876b3adf1a824c6948cf5c89ac85c11de398bd6dd53da3bfe8b42038ac035795d3adf0770cb019e77d5bd4d96309424671160ba730fa3b489b1883e9e1e31e8a55cdfa1469a351c2b203127630234408c7f15f97d499e966e25f1af99f61cd34e1e9eba0705d5c835e86b8946cccde04b1546f5a55deb04b1236a0808675c531155904ea099a4f12c8e7690ebd35ce88c6c32990a9abcb3e6a14bc07c5ef5288a10c2d65807af4924305554f74f3b25340b7248f231bd37ad70813c4e46877d5d73abcdfbb36976c1407b8f2c30cb0b1ce6ebfb536c0f9fca2ba978254b92b2b67de9b9c78b915e4251b05f818d635aebb53650a7cf448818fe307055c41afad9e274d5207fbbb485b4187d605e811c3c92f6651e3d81b4f09962ea57431c7adae12edc6768f381a921f172f92751a5dc053409d14ded3e104beafef360ee09639ec438932fce2cd4352494586fd5905343a71d656261e3301a91b9da994de5424a7304ff6a55e909aa416bec4a0861bd5fb6dd580f42490900b31e029693d5c4b36430d96527a65709309a02cfdcd97faf5766e14b6f9b2206e8ed4f30149d195bfba53b91583cff90cf5f4e91f73d002919cad0151f87722c6dab904f0751409ca04ba2900e9fabf61d5e4dc1cb6b02de14ef5fa8ca49aaacf54fb66053e8b94a5fe64b04abe054e729d004e9c4ec2e6a9de8110b7383f2c7abd6fae14b9cc5ea2ae0ba2ceb2ad37893e6c19819a4f9fced41ce4668b05c77b84337be7d37984e00567c1e8447f8fc2c0d268d5d44d682bd749a18db2b63728ef5062aacfeb7d9b8bc89319f9449f7b6e018f5fb6cd2f3564018954f98c47b55437cc9034304c9381f1b66a9636bd443075c25994d79c1137d287f798f31832095148f58989f994709ed8f255a31fa3eda8e326389b59cb92f20906ee6ef7913d86e4aa6504357e391dc56f070bd590f84e877617151e83b2b175ddf5eec0a7489dbf18744fd83d48a661f7b31cd7c355b7c9c06b56ba9941f35996a5c9d3a62cdd592fa375e27066f19f95c08007f4d11fe593efb8f042f0caf6b689872100fab607e4104bd8ba0c05a34e1b6f88b835fd4692460f742856cf3e79ee20967b1cd45b74066025e4665f01712b997b88e85df1dfd5b66ab9f84e82de39c8612a154f4912e96366473fbce6670163df6c4bf79e2833a65e0e5ff426cab85a3eba841c50adcc6c1973eca8623fa62835d64b23d1a0c1b85b06016038fe488f88a96ebbc6d1ec5d167a4e3e83332f720a5669eecd19240909e17c869b03f3de9fd56b047bb9fdec25fd5afe676bf30c6ccbfda0b14a9ebd535769f0b7bf859d37be93f8d828ee8fc179ba02b1e5411a59104f03f902cc90131b8d7217b70aa61725ba4f8ed996ebd834f2b4678ff61a213958aff4a7ed098768f2cb80b3ce3784e17f46d62e06f4ac0fe73e31f9a9ac288d1b5489f6f47d9dce1c054809ae30c2289d0334398f53ddb91893e7856fabba8b6c458e33517268e58bec9f183e91bd17ef0f07b8456d55252724b9fe499e2d7c7cc6cfba28c38365a63b2b7e54fe7590f82269903a1520cd5cbf05fdeec833db9a69df4986f04630258cce42c9f7997d9891e0890b84eead9baba72ca7848f64e0fdacfd9c3add921ae3c1d3e7cde8c8f75ee18a86125b1b1d951c9915ba165a2547557990890013558375ce50aa382e533cca4f852a486baa28ac11db8a883c056264e5073ae1cebc25fcac8755768e91e4c05acfc08630b9626b957de6e3949cc5ba73afde2cae4adfb2b8c4856774ea5a0c57f3acb238ae3106ff58e75e98e78c4b2e1a9c1728a096860dbed823e43cd4826e69605f1d8bb19019710a51b1ea632d0d90a05d31a8cbb2cca56c8f6556f6f3815ee63bdde3df69dd84359d58c0f60d3b445984ed305444dcabe4c7b24df4a3f2ca3df559b0b259d8acbd5d1852d05a8366bbf77c1f5543f6b1a0960c2e1a596671d6c0fc1383d7bb79262459d478a759fd824243d7f048f2ec73b594ae76103a4327c6c0b22bf44e7c56537774b722c467f6f957033c3bfb639b0bc6443f06cc98de92f708090d6ddd63c73f36343cc494066a0eab7a4fda9f1bea59e796d5980dc9d53cfef83dbe10f66ef413dcf739701b128c5e5357992f9716278d2d3abb419750e5c09d582e0b67aaa552b2bed75a5d95facc5d57c81f144ddea3b82bc9322b6a91768ddb80a9e81aeb235e1d09da21085e5d794a27a2570bcdea1db229e2f83e44a8c51ec6604b4e13ea9c07f6e185d84a43c6748e654a8eacfc9a99798655b2870eee065caa5079f76ee053da9eb8a905a54dbc9c85c2dc012e274801ff2490c09c7a1dbae82e8b1ff03b74fb6211effdf33b011da157f25bc7c5fef2c53db28b072c006a7f8cbd36919c0fb4863277ff33c390cb2de34b561db7ee8ffa1d55a4e1d464e207e1b988140ecce52a73aa7767219c9ac8dd1f4e06a5cf3da61cd214c172a86eef2bfaff33412fd24e2b55b354062f201cc617594231b0bbdfb7cabc6bbff6810501cb10ea1a195abc7c6cf2e4df5622cce98b13b275539b79185a3c0fa39ce78ee004bcd677486df8a4cb51596836580e92815b6a32ea1d86d41a833aa9a482b8e930919c262cf4331864a4ebf9b0b411004dd2f3ac54ce93ef6fb00615d466b9d66d17a019b104fced531ae5255e271784c85768f0df58d3786272d4b8a111e49946f87661d9ca03d19337837c3cc90fd0b684c47234b4794680ccd48de6beb232cf0638d123f0f66b9a45c2408f6c5db6f42e0361f5a55519e81dc417630e4713b76f6851f9713db181305ce9b8739968cb92c10d628deab5c907243979f7d3bd018e7e88982d7afdbb6cc17d95e476371b721872dcdf9d5613950655ea68710620a71e53938abb2bb24ee40e8c3d26e9eca8590a60536753fa66b64e57edc074d8b6c487c194380dd46abc3ad7a98fe03431e94504b3d837727a733369ff96dfe2c0cc07be81c5aa4d5656077bd8e95a4cdfa6d4b32bc53b4b92dd545ef05ece0724967db01cbe9ed799682fa6c14754123b5f05100d06f2360e6850c862b5df9d913d25336a15c84cfbfe70a839fd44f4e4273effa9e3f62d2ed501c0b6439006768d630eaead2fcdf57ff4d77e1ad657cf31b947d9b03e6a4101066970d69bcf6999aad0c7cb3c45ebcb2f88a85470ea309b1d099481aabc49d9eba7e1f5318fccb2cfc1e8e86ae58871fd2a7dc0bbc00d8ea4110b9cb070df4bca8f63d8499a3459e80a1212b072a9785408e108f429e8103c281eaada40d44557c50922a28b97e8361603d6ef7c50f3a8248f78cfa6e1347006bbf62d2c33eedb2d39f2b1a9e7b52427c5d8c464de6a35f22aba2d616cf68b772b76953b96098a1f63686f79dd684ee60ae9c5eb60465c4278252ce9e748033e59070244413b6bcfe66e0e2bb4219edb23f396b70f3ce31a5593c15b40fb425b85c35f944291ac6b581a0572021f25a863222a0a5951f78006ee908e98b619bbba2a732e6dfd05292d43c4e973471b683bfebdc435c3e130bd4818671f0893196fa779d2890e54df35e08f2cf717dbe041eedd8d1ef86819d8f1360d4cbd667c148fb2fedce6dd31c1625e948fbdcf4180fdea0dbdd9e8ff8f6ed6303bdd702593902d90e661000db6d6b060166a894e66963526790507b244c7e3b3f912f58dbb3d45eaef6c2c84e778fb9f26eba99a6b0346bef2025ac1e15e229fadfa4a508c1bdd376d6fe2a2422df22e2b3f976ec2a147ed6eaad7bf8d9c5af40928c5f92c74c9b9daf0ed3715f726d405acd0b2229ce4e1928a50d666c39f4f51bd75bc56351b77437d5a5f14fdb89d6393984ca261137354ecec4598b31f29de8f6041d19bf2b413d0ce0258359d75e6f122304ee0ce2b20a18e9148af814ea330b00804d337e9de48000d0973b0b58fb4463e310e9a02ba0bf418d156f0c9c894fdf5025bcc00595db30d0b64e5b427e97f4796fbe5fb39999054b37636221968648a6d1fd72117b464b3de52d9a26ef2921d24b76bc4379fde170a174cd7984108288b4bd1502072f29a6c0ed73c778d1f5000e594051a7edb7b16af94f30a1df774987b90cee8c44a777372c1705538d911832f0af2f86eb0c2755f973596f4b3f69c8d5a608fb4b89598ba1deb575af14748a1fa93298dbd868b49b8d82c2cd7b870c3684d0ea1e331ed03adf638c5eff44cf3fbcffadf31152202dc52b91f3cce8e1db1db919ebf821a8c79448ec38898473a0721d301f4f1fd2d5530b5ccdd468aea55933fc78198c8a621fc9face2df64e9f52a69fce9c156acd2da8b5693321094875f781bea2c33cbac16b47bc41cea3f60ffcbbcbdcd6af60fa1db748caf637f76f4a5f7001b56e73460f87b9c52c9ed9c1ae4d28b5a9e08e332395a414f00a274b93cdb7c23712b87a9bb02461029336e84cd4b7e9fd5e916b78c264162ecf9db9d57768a1e9ecf007df6a949353d4671863605d456be57b5314d678470fe089d91ad2d79958f40580985d5dd874e32315037ee73c95da05f2eca22d28f9f2a75d01073c529111ea7fec965a5321c48816918462e0975d0eacdfcbe5c310526bd35f93b9e4f04aff30fd1647b4f0ff8ec1e7a267233c4acff6815a979b86a88710e3d3548d83d40ab79a52e440a503a35a29968878b04b298832d8d8ef37ade72ea625c3c2cb2e93e8cc27a6838d42f5c234c406f6f2d4d110784741485719e4fb30ba3a6ef47dd45f599fba9cc70069a93629e19900672585d2e0100515d1520b3f00fe7ce093256e4019affd4d83fb1a5a520032c290b71e3febd6958f3e12c39fb14dd80fc5ee4c7c4d921e778e200b4b10110efea6eeae3e420067df1c4bae2c6d188a0fa3bae8cdcf813f2384bbca84388520359bc1deccea2b1432ae886cc38a4f15b95bac1b85518b4cda165ac6ff463aaf981b91bd44fecd67df5caddde856754d47bb6def37d1177305dbd7af30b011e7eb3ea2c6f65964e45f1e84eaaa0f00e221a912168ff7789739514def44e13d547482bd18e3ad25cfc8e64ee5ebb4ec7224d1669c85fcdc8f340cc7c012803130eae4683f2d4ad5d67fc090f7c810c7225b04383bf54ba96c6f58ee02df52da55de7c0d84af1afc17dc802f2d3e7a9a902ff62bb6e6cc79cc5a4b220babd36b48f3f1c9d6bf475e4200f2fe4bb37b28b6bf1fb2862b00e14f921f9ad734485c580e34277068d375b50654bccd7ffc689491c0d1553520d03abf235d61f527c3ff25a6d74a2b1bd7b948951a1dec11c649ee231279ab59803df6d73c3a566f3b425a8d5ea160f77bb292ed8b6a3ded6301c6b76943b6362300ebeedab973212894dfa1445290435791125ff363923430865c00e566237b2175c1e549412278022b227fbb91fca4519398e42a5b9194e5f8d5c113d7f4b7a0ca1fac5e4d1a9d9d93b7e3551e4ef7f566d6f00dacb0c36ac770b751aa602c38d792e6c53fd5ea316ec3b12134ec4a42df31110cc45ef76e39de3b6548420716a7fd35353b376a5ace4d0be3f2d7d14f3394244791e468328ed63db6db8d7c7e4c9b30ab83cbfa034722ed0d203dfee7920e029a6e25f619b7b6289284aea2e1ca12e64dfa2e89b41a29468df99d5cc1fd0f7f276e5140d0a8e596f0a93ec0358ae3b18b7f919a3c42a347a0f8f306c3b423ef6542bb82356bff2dac490d31736624f7e7af48a302f4d5a424b55d9a1e386739ed5f1e93de96fe5f526fc0254d0f01a0fdb7b719784bd0f5f4dfde94d5d7541f7ec98a15149fb548f7791131e9c285d6b9f762d1b5e57a31afd6d46854a89e36e0ac1c0dc37f7a44284fe9529952626c765a793934eb58431592b7ad008d2835fee9e821444f80b983dafe90a49d767f559e8ef635bbd3693563fba4dbb15d6a4db857efe9c697e594273a47450759f33d012211c454cc1ae20e053f2de138a3c3ef673dae2ed44979164e3a477b232a0c6bead6eec52003dbd32da4460525d40cd867f4ee3dfe0011e3974797af250e7920b20bff79a43a0e01a6e5fdb35174c3d23f5e6fd8c97d64e6a4120655eed7a10147921102d105b6e0e5b5ea0ed63fa3e5ecbf177ee79509e25908bbfde43cda1d7c861f65344528029879d8570f4ee47131db4509c529a89f5a57d528efe45e0e702f4cf4061cc66cdc4612ffe81798b72f9419858ee0ef8dca99097f98203ce8d7c5a1460e0ecd23c3d07735bd2d75bac34b792b36d52848fd715f31f4aec4d44890efea9aba818af04de79681c5ccbd466011fe1c2be599c1cb373510f17f49bbe84e6d43fb037a2729852906634e364b406a6946314074011e130c69e30a6d17f4627e5249057c304a92b4909ff7d28527fe586e7093dafacc8aa7302b73388f1db90f77545b9b33cc55ac4277709f9f4b05507e829504401a73392549790d96d38b41e1da6dedc898916fa233c3fe24b73671fbfd7d16eacae32db53652095137c0c7c8fd7961a511c6af968dd0a33871679521584079159626612095129d1558eb3e4011452d0014559d3e540789bef80a4870412da9d6afa725ef5cf6be4dec973d9cb0deb99ae37aa3a2b4e24b13eaf2d24b12b226a1095cd1ddcceda972ead4904988101f2e8bd4b71aaf35cd296594d3c42ec62539423eb9fbc9b04aa3cfc066cbb65d487f5ff426bf420dc63bf68cca614a41e779ede3739a167b39a950e8f081cb6d3a5211c33e054e0ece5216394e32c57158206ce7b469647d44ad4350b619d5129691c7c9358fbe3f57625333176bd14f88ee603e6ad3610622bc8c7163e398c7a0d8f6e04f4acaa31c8a64fef502b61119a42f0fbf06ce7b731e3fa97c3b28c529413d2d763bb0b3cf749f3f4b417ee9cb50d876312c754c3ee61997c225b615eea22cd0cb4c6a362b328ef23f07eac9d47dea226808f169dd710660f51bdfe884c8ef49cffbcb6d25bdc857d2977a221128cc481a30906f5e523b03a247ad97bb6ad8acd7593b036d528b68ac38b918e0d97aad69ea3c0dfef8571818813e250d8ba1019a104c0e6ce99b84a0884e7de5ea134380c5f99084ed68311c47265f079e5a02b67e75cb424cc36c738247d80c9c2e89739c2e90d124cce9bf5b800f1077625a00943063e3bdd2e8c7cdbc2157080d7ca949ba84cc326aed06c21ce76f3a6a39c91c63a6e9e852d0ece6a9b102cacbdfdd698719c28a0e934cea4a0b8753f1cb2ec095098e66cccced0b0cf42bbb5cdcbe170736b98dd0980d7ded52d390901b1b9f827fd189fbeb57067cf24996a256b49fce9a7b7e84deeeb22c095e13dc22f3a4e17b0d1aac9a80bfce0b5052f7b95fd0e459df7ac0d7cc557bd93b161537a0f518e4d7c05c4c2591bc052a360e9040105c5255651cea4960b31b8087e0c8c3e5369f83ed67a05ebdeec87e345d7c11480472c5febe08d2183f7b1ba350cde289fecebf4ec7350914d455f9c47489782119fef539d284aa109997821261e766330daf94e486f5a1452cbd5acda7e0c7ce487f33e8b117993d7f6580c44bd9a8ae9f9f64c12749c4d7eb806718dc54738f9a8e23a4a970d5f7edad6a9f271b4f524ac5345d3349b2670b0993182d6af9640b6503f58a73701ed9a2ce88b40bff84bf5cb50936254924b1c194d5e2e8cb949863505fd244f43410eac05fae0791f9e5883236ede567c24ed0f61962987b0fcae10266a80da5cb84e0ce41e171a32367258287ee846b77323a20cb8a29fee9211a55e72a091dcaecf04fe41e48c9b7239fb3dfec04dd21270d531f912a4cc4d517bb2cd640512886d6b775117a8b71f9c0119358b1dc49e61b0daab9fafc5e1e13ab8c8c5260eff7e2b60f84372d9c864bc2011d5f78d7d1a74d569d1c01e98ec149d9f9a281e6f692bddf05aa597f46ef1741fd96b9dfd03e68672fb0eb4541645b3a40c3baf40e619345d1adda3d6b669eaaab0d08f33dd488f88dc2d373d04b5637abd9fa36820bbe2d6c390cbe8928613372c53639102e37de14389b82616c25e4c736b92a93c394b9cb5680febeb034e70b5f0254f4fa681d7a93cf55da8fb28265c181740d988b32b567fd4989e09d8076edc9b7cfa3b9924ac28991721d9a8173013f10a90f1f929b2b2614aa7d9410fb35a849ad12d3d774fb226c8c82ca38bc0ebd92140d3639ed1353dd2375f6b633f443f6834592d2bdd506fe868c1bc92b6d286cb1760caba78238c0db8ed9c4768161ba35f41bce68a135e89d3e963f481588581aaf1e0c29d88b3f96f30363827ba102554a53fb2fc893e0ae0cd45f46cae9d1e62e89969aa7a570622d3ecb353fde599ca7896d916919c3a68fd73d886d30943aa8906809cfe94b45b3f2bdc623eaba45381d511552706def69a17b49a8821d24133c687b2f5e937f3a3737521001db8f9bf71c1a8304c84da521ef3576b682575b3eb10793871adb359b2b5eb5885618a12bc24ab3862473274f9ffca5d95f1e84281f52d9bcc4122c7d91d09b522bf45ea613b3fa08822aa5341f0ede5ee3e115d602e53234835d02f5617921632e6d40fb538bb3de426f6231c0f0b272bcb67cabd0c9683ed2be8647f6a1bb05669971c411542fd0bd44474d77bf511af5229a837daa6797e7f27a5bdfc56ad2109e0f07257fce1cace72cf473c543d566f768e2074bb1fe913711360aeeccbc69806f293fe80a504486103767f1c6a934d2b401c1121de1fb5d85c0c9f139bc00ff73ac362bb18cce18a2730c047c8ebf29416253f5fdbdafbf5e3287c6d37fdb69057e98ff9ee3a977440bc46f98a7885c6cc08bdf6f994d816011e7e71e81b1bf9ee6861a5d292b3c4ab2f4555d6543453547cb031f4e018c031cee5995276d03d0b84074907bb915bd38a9a8205fb688bc8b4e9cb4f477e3056d7473d2ea2954a9d2281a30b311dd97da4e55b50aba11b9690cf58a3fb9fa4bd910c86b2ed39b2afde774a2de5585823b5f0ce9ad96a2d27877eb15052ca092629ca7ae8976dd3eac2bf92311068445e96865eed150994c84e46306b1d3cadf77b2f52362e00178400568e89d94fbb1302ad008e6d35a9323f7488930c5c56c92a3d12563ff8800dcf2b9f4bd0e13a6833ca87490e9bf9bec6d50828837d427dca261b4e99ab55c2e3ff42a9ac8c59c1032b01f83ae53aebec281e6c3dcd733a3c6b9ba46bc1d124da49d094f64e1d09930f64a46a83c6539eb63372b611ba8a15f0dfdb1ba8eded5d1f8650a9d5c729774546098dc95b569e9c29aefdd0817250ef20a2c76731595cb112a758ddbde25c844dfc614eac62d2f114a4326f5a08480781f4fcb3a95f978e57d16c455746d0313a96e8d522dd040e35efcabc03f60e45ec50c0aeb35d2b75b3b40d58c72054d656c2d4be6042142317efb349f83a77def2d5b542ed1d2aa1e37835461ed2a601803614b02ce5a8895a5920956820448fbda590e6a6ee686f123329d2cfd5635cb27c4b2a165554534a94f013398151a33ae144be75017d95bbcc8b5861aa4403666cd93c04c43b4d4f92fe36fc49c3f993f54da2aeee75a5c2c8124fe7ab33fa03452f33cda7dde28f2fac235b4871576972395704acab33670fedc80810119ad52aae3c6aa99832735e7df507e552d10aef4176ab3afcbca7288dba2f83a926cd961e9cde9a4cf738d44b478c5550ef34c60a858f05d9fa21dd3051e80195924719a73bef7fe672b7c7d809d8b311b01d8391d37560e2990d657d106d9fc7669ec3421856379cb729cfa00a00c186f6d5379cb2a7984242c161b501bb473b906068e9e5ace30df99048bb1e29de034cb7e0ad67620820da4fddf887fe757102ac09e168cf4e858029c5b01624ba6cbe3950666806d2c8f47c95a5c47525cd706b4d23026c10eb978457562d331f237f0bb8b40e0f74ee73ed79f455ef660476202599311754e7fbbf34a5c6b7ffe9b16332b3bf29b4b8c4b94b13e75106659dd00a2e4d6e3c667a3f9df838707764b23a62a6b11009978f6550862552e426b41e7ad22b15e7106e732c83c44711d33437576a2b17da353c791d47f27d69c3cdb99661b578875e4f65f471c776aea4d840494732ac772b6a8cefe5255628eb4e3e5f585afc63fe0cf34e2bdfd78ad3b01f437d88ae1f3fed3c9085e0c218323f463029b6d6e7471650e376a6c11f56d98c6ac26da3775318e9cc35c4ebb4189673020f3cdc741b5c36d9989d47d5835a6123a6410afdfd8fd57c336d6b1b1af4f55fad59e585ad8b00350cb422a5230c0046da3db9dd14017c1d36b926aaa20ff545476e3ef40e27a91014b269a30d1cd6bcb2c94ec015f2e9ceba6d4398a6fa4cf2723042d21d648db8274ccd088218f29a47c135b67c8a12d6148aaac1d4cdef4fa110aef75f17ec331af90d138a4619473679fd9bed82162a40965d9bf1074eb2520d1bf430dbe47fb575433bb5d7433c15150f64ea3b986f27defaa4484ec4c167a4a137b1a7122104bc9fdf09de38aac92b49afcc6abe93bd9d4d953ae67e395ec280df8cc3ccedf785262e4f0c0bec4a84387fa9fc43627e41fee5231ff9591a2d69fddc4a898319bb63379397a77cc89d613c0c5d59b158a240cddb84e6aab82555d153b94965236a0a3873f316621951cfa1305ab52ba7e029e35b67e4face9e4919b01a56d312d8b9b4985bcd296de976b3709c386705b6e4a3e2e281e58e16833e2d7e62d9c49259136c013b011ae3deb16b0d6b35e663186e03e1b51f79a061871d90d9be2f349d0499dabf227f8640f6c517ef5ace0b3b368df1fa476cf9c0c2aab328e0e9218716c804851f1731e71dbf8ae2d1e6210a03d5cd11cbeb8d2b18059add02fde38f7d850465965496a5607719185c0b363e46e8b090de0782cb95db1931e5b80c56e5ea020d95cd4876a065a2cbef7726428345420a00532f0ff6c94928d3c6b35dd52059edd18bae5d93e3dd2e3d766164eaa3525d4d5c071b292e3e3988102911ddcffecc1a064d63bf2b5f5e26fbcb7fbec693dfd3c399ab9f1fa0877795aa67579e82700b6a36935a854b8dc225e0d448cf41503a98fe31a2b0be1ff144ea16dc23968b97ca5be1ffdb0fe0c2927eb6883204f7f979e6e318a033cecb6825e847a399ee5d888d5f52cc1b9957d855cbcb3b9e5bd42811ed4d142d6132d9db516695ea60dbc6c860906b62827abbb4eece6da9fe589eade30961d8340ad9bf8965ef2e0ec9455aa6f08765da60cbc7eebc53313dc013623b050bce5bd6e0cf796c81299b103cff6993c4fa945415dd6533ffc808993ad8372c8df56cc5ac18be80549eb69584a95d6234c01169554f297c25529afb9a410d272552e7de213f651dfdaeaf0c01f2c86b3be110e78f5de2d513221b8dfd1e6a0a9fa1c70858c65441655c1b54ac7dee77a4287b40ae1a633efdbb953427c79c15677f919ce49de713f51eb83fc6cd07985b29093b7c3969caf7c339a9c10937b6d92f0530eeddc037556381adb49fb2a8c2278711c9b6f5388e6588d51a5f1641cde8028795eb4285ef3a355d9c81084b5f05edf1ff0ba1708191e014d65e5f0984a5b37e95af8ca887d1a9f6abcae7f22e0fc675350e0bb36d549be49907728dece3267d9b07cff3294796a4046623d318614e00eff4ac6dbff0d461ea7bbc600132d38902b30aa8f1dda7ad109762163a306fcc1297966a75b2cf6a700392278622bf22ddca2bc4c612ea037f45b7a3f529e4bae28f365c3f7b78f2e10f43629d440458936298780f87dc5bd66a05fcd79d8a98a79b16a2b616141f287cb17df003b44c294e5bdd53da23f0e9c331c05dc5a027bd6787bab8212cc946b49a2e08582ce1e3f7f5dc963321561d4d6523b03d090ca5b89646107f9c6659295f83b234199ec45fba4cc9c3458f7f5134563ef4d62010fe3728bd12cb546486fbec412ec9a5a50b1fc4d34d4228e5fedb759452453a9e1287bd500745c629441cf0eb471a48e64255b48a0243801560de4815259abc4f73d786a4d407153c9c032ba67601ac6053e8126a5a5e8a50e55506971f12604826123684babad9e35a0c3fbeea48934f8a487a9f790bca93b4fa598368488d4d8e45941933e325b982554933eeb9313b108edc7611859fc4435c93a8e71351fc289fb272dc18999a66952836c3b8c09fbbf12866530902fc4163b28e8168e646575ec9b752aae8a1e956b775a5711b1864b39fa8542537455944be94abd76a7b5084c138ccd1b1fd3696212d7425c1290b633b52fb9a5486cdf36b14d11f619abb44b712ff394af6610fe018113a154a75f38294275598def99b2575c3f6672408d0970a7abff8e7f6525cdd3882ba163a22f0375ee46dbed48690277f4e9b20c01cf09f7d92d53db6857b41f0efa8c28748b3de6373e28435e386e28d7f07a5ef88d35183c0f444a644c67336b0bc5c99ffc4ef406d89a082a24719917061d3cf2dfcb6d82161ca0dcb277d906986eb2948b71fbb3c888b235455a16a1d9ff3c96ccc44518f4dd448048c6ef0cd088f72480ecfa78e140f5d29f03cb61985cdda6065d94ed02a10521da60443337dc9f0c31ea6dc024e386878581e75f5d4d47afc49a441cc411ab044d433f5fac24c87f9d51a23ea40ae02d9bab7c34fe7ac412ed9ece5cab433750e6c08ea4eec5bd39a50ca51de5e47c454d38dfac332f95bc91f3c5eae247855d4dde38b1631fcf909bce8a693383181fc3436b1faf5c8b91b847c594447aab27e4797f46962aa18f77345a0c948ae226e61a55cdca2dafef667c003de1075640afc6fb75a98cd70163e74aed944b1f16e5edd152d3b8f619de02c369f1eb62f9c4a590b4d3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一个个慢慢暗淡</title>
    <url>/2024/11/24/%E9%9A%8F%E7%AC%94-%E4%B8%80%E4%B8%AA%E4%B8%AA%E6%85%A2%E6%85%A2%E6%9A%97%E6%B7%A1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d06623704ce1ce0f93529f2c5d3db3cf0fc8db7dbaef351a58f81687a17fe96b">1c9d8b8c792a241d8f66f0fd62fc81bbe386c44fc11bf6f72ebc9ba93fccdcb0ff3ccc227f9112b9ef2f41baf09a9602f19e993d18969004502cbcacf961236784a3e3c6759c8d93edd43c2f1e3c0882694dda124346bb5e1961c1208e93d6f3bb968c1752735afc23e26fd382a86169479451adfe2ae632e13f23cf385f06dd429d36e507f4d202f2d15122094f089a2578b60ed06cf033a6038fdf86631d212931b7610aae5a1a29c11229af7a58c179838f1951c57b91adf2d0f6ca0cf255464df3c98c57342e1a687df87823ac0f6be5cb48aeeb2791741ca31d0b5d99179ed3c81f35410cfd674f10dbed48d6ada4d3efbcbee2e20d5c506fff20a0058aacc89ede57ca8dad3796a702a4475fdaf14e7dae4c226d614ff45f8c1eb760a594b31bcf66af35c8cbbe63faaffb108f9e50bb9c526180ad97c82450158517e8a2fbb242963cd8f53e1d15ea4da1045033f50ffb23f8673733db5fbc833f36869ae98ea4e1943268e7660d5bb3a97a42a89cf7182d226f9bf3b9d049f0bca118aecd0fb89eda99aeb796ff673f8120f7c400844c811ef63a1f78e877395c9426bac2d8f1ea10a955e07b86f3d89e422cf1eb75b9f0cd654886be8b0874d56a8025709e00f6c97fce711f80a6bb4571a4a120206a9a9f5e4341d551b51a9c916473f0bf038fdb3826007232c3bc4ab994873ea603a7f91ab8469f10fb8ce7307154dc5168948abc6850c1c3c2b5305f0fe8ce7435d84232a8dbdb2784d6ea8aa73c222ea5694f08da0665bb9eecb69cad5814519a37a0f9b9e1851835c5b852d061716aebb94ec5287c8fe8e84876cdf5ce5342eb41d0ecd9c335dba3a68f974f5becced520f4ff30f5ed9b9fb4dc7ebd77575cff8a77b0f826f45bb99703bd1b46073ead55078ef75245207df6226c0a5d6e7c94a86c906e410106229a0c19186e01faac6ee9f5c24e39dfbaa35efa2b7a7baba108b8b0f26d9c903c69f395862d5679db0680ff9f678bbe6294adc8560b64d16443235e9c1092733edaab29071cb07905858b75fd88c87463b3c8ef3affb22c5b582f8853faf5c727a70f9e9db45e9bac60d3e38ff828d84945edee0b00fe47ecb94c830e2c09ce7763055672b5f45dbd40531cc73ab8db1ed24cda4a3e8c5699e6f96330bf2b1a3ff69d865f7db77f7f3beb7aefbaa822d0b9e7d2aebb076cf452cb2640c6f52b7f313b75757b4388f66808646a31b59cb41105c93ce035624defe3285eb7ab19b2ce3133bd7b9fbea8f5a123b26a33c549fe562959761d1728ce4a468a4c001f456c7da269b37b387b96b0c64b9def2b039c3b29575b607f5c706613aa4f5d07303b901a0886aed541601d1efd329378eb7b9f6f7c6dee8affb89245c088c42fdd0d97b14a82917e1ce80afecf2da5704d0326adee0560f4722a9f89c1a6274a020a03254c714a1e4b9c8d78d71f33be4fe36d4bcbc6460b567dc1632b87b79c6615fc334f73958ea4f9c00885ee72a63c808beda8e30e45f63c695b2bc7bccbf3e8d4736f531d262cc11df5fa4a9481447ba0e6d37e1b000e60ddc2402d7954c0b48741c20de8dfeff55aad7471d839a52c402869f0cd4a225c8a7d9ed96beb20f0bb1ebb1dc72dbab19b1922a0e5f4c222959691d90d6770b6c386945a5667f4b6bd9143e7ed4e576b0aeea73a88bc411afd7cb8ecfb593246165ec79c1e52e5949368d86306ed8d444dae2fede9f65059f4395e119aea2d55d6f156ccd9abd9a6e246e0047843763faab24e238a420f5618191a896bff5d7679542a4f2d18ef41cf7091c8419c32452c8b4cf91da5d5d4a3ba1c19406af18dee88e2b356a7d79afe9cb107535e499e2eb9e8a8b2af691adc3ceccb5e80c380d4a24160ed74356e28d3166a92463707d4542aceb9087ead93167681842b59ca06ad0c52b6d2f9ede4f80ddcf7e134a74bdfb530e17f0a53db5b03443bec676d75c2d9f20c2be63bf3c76b0571d2e3d65f3422abbb9bdeacdf8626a775a9f7d42bd8448ee27f164bf03cccbdb0b91ca15a4c8d8f9102425abe941f1821aab34ff3f6607e2fcecf46b162a4d489468507dea6ad8899c83254c7ee2b79c458e978b3b33453c9f7ede6a50855f3b6da810df9008c09bfe5e787f3e8941e1f96409ac0e02e72d22b5597e6f7df2775a47eccf5f90102f04c86ef7c6b503bb9552c90607a036408dfb8fca6a4f90924eb14bebf3f6eef435cdfe957459f35510f880ede19cb284bc55601d36959bd03318134fc34287ff25fd93fcddc5785ef707d453704262041021d1242ea05becb4a9ae42e1989b98460ad932ab90070003ad3fc253a4cda8894674860fcc2cd698b40004ad54be7cfc0d1d19709d84e6ac3b541d7d915a56c3004480d16b1c40c29daf92e305a1ccfe322cc400908c14f8db1b4ec8d68e1100d7f027f84ddfd678432d3b69644f5538dc079f11d1bfb8bd95c3b0ca745f2ab03da42ab3ee9a613c0619253d93f59f3cd7e98b747042c50c385b6e9bbb8c320c32f42b976b35bc0eebfcc8593e65b5ab7ec8bb226452d55f68fdf1f4cde948998fe25228f882f209570cade1a845c095007eb7955b432b11744c934d44ca80c7223c670ce0ad643a75da092d8ba6284d4f62314a1614bc0f083a7d615c8c85921c18358f806d3925709484e30f96d285c0805c0eeddb7fdefb30cd6f5b44a3fde7d1bb710d1ee68697fbdc02490ad81e42bd68918f6ea4a768c021f2128cd3b4ce3cf08861fe376888ee7cd5de6b1b0a383bec2cd40b7880457afa9936b9f80b8252a40b07b26e29714e663cb7bee051b955acc11b245407bf071aa73ac517e347ebc862116076e8552f5d6282f214cd91ac2790dce0a7bcc01ff3cfa9e8da63c49b120b7401b94b97b77b2a17ef9c8ef9f8f021bd806aebb737d09bdbb5c1707e2790756a7e72ebe1bf739cf419ecfd9b9a5bdf7cb42dea6c5c4ead61afe2da83ca6deb9786446936424b1107cbb1aa8577d4cef3fb0766595b4a7c081315a50ed453eaa968f647bd2e9881701127bad1efc5c55a61662f6a6e6dec88b97edef35d1a957a4d066bffb3724d5593108578081175f9f1b8ae59259fae3235d18b462bb2b7af70c95b4dc062c403ed0daa06f4e2d2fbd3384e77b4c87ea06ecffb9ea39c4d043f9516b2a1e33af6f4b4c52858755bcc814141d1bd729ecf33bb6383f3ea4920c01b906c75bbffb1ffaa31fadeecc4d457de4fd8f0c83cabc457a01159f950020acf78fdfe26f9d4b9ea9841d1e081cefb186b0bdd0e016ee7462bccbe007b2631927d2d72d585512ede8618c82eae2584c14e61b301d1edaacbc757b973681ca724a224867f9b08eb2883d23484f236f9aadc944f99426e3bb6fe9d2ee17645845f7f49b3a47f4f44447abbe3d1d7294f2ba7602a43e5f1ab74c5855cc3eaa35169a7da319e81aa6b5835450e817c9fe6d05f6a471a2b592109131078e81d4d8222dbb125d563cbbd1b26b9463b37b7cf3b4add15492ff99044d9028740e7426beb174fea0386824a6d629166acb7a869fa8cbe4e3a97d5317ba652cc85dc68d3c273ceebf582db2e86e301c2e949b6346a91d63eeea903c419bd732262b2439f3dc201968c945f47b0c84998387373e60e7bf7a30e2b2c4d0a90367c51af08c582abcbf81fff61d1eeac99eb1d5f5b79062167608cc087f8769449ea9e16cc1455d989078dde3bfd0c8b3a036366f4d8b010496b478dc8d6d1c666f2bb299af5a45428479e0a4f15c069c8e377b29d034e6e41dc5ef73dc625d0a8a9d270050f9035d8f7ea4fbfe4b5783e3db5d0ae730e7e54134810f5b73cef65e2d5419205bd54d225a17c841cc2e0e64dda120d84d7320887c0435810da775cbb906b5be4703fd96e1324eed8e10cfd1a28bec6b3a75aca7c73a42aca5118a30371bd24199bea32d4427cf2885a5c74c34ec44cf8f8e6a7aec4a102f5bad6442032f3aef27322c6cfa0dadcd3bcf7f29b83e1ebf3a9848605976f0d6659598596b6c632dc747dd1925ada83fa6490243aad941a6d9a6fcec59c582bb0ac249d58938d76d493771d492bf1085fb3c26c9b8350e65f762c16a06461ff13467cccd38cd174f0b8e62df627330b511c67d717b335239a36508f9b36113df643224584a98cdaaa6750052246fd3056d848b73ebcfe397c2c385999347bc14badcedbdb8b2296cf459e7861555b40c0d52e69d1ab9efacf082277a19c9807ee16e11799c14cdfc016a952964ebb0634330f9522bb8cf0d4f35212f156e6f487bb179f6ae3b83d298fb4ad4cd46c7a1f645447bfa17670daff3ff2b40be18b74c1fc2e4eb4ac718ac8b44b1188b0320a33d4badc492ab8be3d1431e4e6801f6ab40d9ab555c93a9b2b0cdd8b1c8a724c8d060d818c1431b816da0d574c707fe3ce65f114cc8200856e040d44745e0f37163e81423712ded434438ab04f5cefef447e195045a6eaa108c9afb8857477ec48b6067a2f2f01974d687bdf494f31c07f3e8506fd6410d2a496452eebf2e2aefb77c3e67d846d4bc95df0b25da89a869a875be832a4e18c268fb546f64e1411afffd3c6ced0007851ddb3fa9d86d5993075319729988a486dc458b258a1b78ccfa9acc4e8034ba5cf65a27abeb9c72fc7936a9cf43fe2895c46aa8111e7534b334b35022d4f8eee746a3d53e7d5ccfb18efa76adf3d7497f6aeb7b7b37ab3c6ac231152c9672eb0d968ee5bb0f4b355deaa1e1536e5b08076fbbdceb98b684fd0338023818192b3a8fcdb2300756d526abdadc5b5648712ff01df7d3848ebd1a3d5ddd684917226bbcbd1c5ed0f6db7e915b1e5ca31771ef4764ecd2f4da8b17aee60cb003cf3507f47371011360fc883a7eadb3a96412a37e84c427c3d4fc132c8a00d36324b654318c08f70b16580c4813f61445da6762faf4236a09cecee91eb5cdd6f47fc0f829ec57769ce3603a1ecf4c6cf8c615ad17c7d12dc8b1572e6602c77105032325f7906605a401b9a0f47dd8b66319c241b29c9bf7098bd24b44d5c437f791aa3126b178929e838d249997eb6ca47bc655f85dbf50637323829feaafcb0de99540f1c5e87776aa151d0fc29314cc67c9c7c57821a02e5d587d6a2f15fe520f1ff516d91285e8e9cef4b00c5614af46f88dad0817e88b97803efb058870da67ec4c02a1165d59f708a24baf798596bee14d50c6ab7d1f790d9cfffee6d9c5ba9456436df6cc47d01ca7cb89e32c5e361e2a31cf7afe940bd513239c17a5d8b845188c86f74e311b8a9bd445cd6a563fefc8a8714fc444e0131563fd57193737614221e325c0cdeac4acb29376bec18f1d5866a5e6c58f2575ddbdb7f816295effa1ff0b35f9e0a5c87e4cdd11842fbaa43ce03470c43e2769e4da95da59d0d4cd8fc3c00802cdcb1da69257ffceb656bdad4e723507b2e66354d2b6576e39bfa4759ff0f5769a518b17071c8432dc770a78ebb703f93040862f853d071b4344ebb91788d936560c9d32b58f5a02c17bf376738f2b4b1032d010ef35a20b61cc9695f4eb6a918547c52b6fd3288ed3ea217e60034e89b8840d4eb2e6e8cb9a222d30f094eca8270cdeda2f170005d0a4480be9188b733f71abf1061b279fb6d41135185f5344262168ac5c034a1681d34588a97a825a80892114b4985fefdcd8a86f7e7acbc23614284a0036b19df7309d825770de350dd3d9ddd0ebfbffcc1b32b0d4875772bf101760e4508aeedc1bbd1c0fdd0d5189f63a247f562ef24d9d829c81603d0958bca571362bbc36066a415da24bc9f87b351381d4a1d786586eaa25b509fd5b1d6a0aa6a20085cc30ebce70eef75098348486fab3882160c15478f89975d1d13c0d881501a47799b48e8a489fbdf1f5293ac280bef995cd3ce5b4dda2b25263bf44d612fbf4f9bc26de1da7cfda4e632b5adffbc5515da1f6f919b1e801ec60a3bb94f59cf15a55767d5d92074ab0e2b830e92118adc8548cc5fa3c3d8579fde40e02c970a478b7df138d9f1f8c87ab35f050308ecc4554085488905b158f58346e9ce700460fd750f45ddf45d25ef83c07c93913a910cc4ad11001f992e24b1f149e50d669726cbf44d8d74460cea619039c0864e48ebb6896daea8008d650ff09aea270670a830b040c21931af21ca94679d566bc1cb222aa096b36ed4b2a853ab8490c674b74da580f134159440f6cd0f064b5b883b900ca53ce0475a959e5cd1d4f9f314346c9f1c0926e8e036ac37b47ce78004e13f5ae2e1852d8cad4d7106eadbf0d351d77c2604bac0f0baaf9dd23336edc80ce4e5fc615220cd2659a568360538f2db02c190ea22d6f80530a3002add47348b2dc3152f0339529eb670851433b00ad481a8f700492fe7aef61de13abb094d5dfdbc90637c0bcc03a3aff1c662f8c147c985d3c5fe935f263530dcfbd5061090a296d39802497946ca68fe25e3e90255f02caa6f284201ac7744626471835adf437909eda878c9670e0c61afcacf5f7aa86222b7395a2cab985ca5c628211ae5bd271b747f1c36edc8c6086ca7e0240a74808ead2f55a131e9bf6d9f1b819fc9941efa05a681dcd73cee12392a76d56424b08e11f43a07cd437c6f11c243acbeed37f50a128384da9cd579af74973679b3b95d6e3bb0a098895c7e956833fba4030d5f312083b807476540700cc5f620c2eb039eeca9333f50829efa84d183a3b25c787f6c760254245b7a1041a91701751e0ef3a20e1e4a525f5a1d1e0836699546924e8b5ebed8a0d6e54035d4818b6528c5b20598e69db8b5b27f24e601e887ddcb20d149b5ce0c461f13ec98a66e010b193fb05358a3f1a1b8d08ea50880d2bd6685693f764f459d138f096d806ee9500e87ea3089939b998f1f453e9a575803ca4f8e3e1e74c1367ed0955fbb5894b82ccc6d466eb33c7b98f8349bb5366b29cb27208abc508b8d22cea9e63eb266242917eeda0105293c5f534ba72c41634af47f4bad40c546b79674dcb6dca8ee56e09f6deb5e81a7180e01e2a6bd71d612bea54b555977968a0ce34be2944e396a99ed4071d85d14718d1c3ad0647369cfe82663fa5e65f6c640c730dd18f0a1a42bd50817944b89c5959877a9be99ecfe69e5cc775d0d0c6adca6111f94421ce54a9af8c5201805a88d7e2ec60f3ba71a775bc0d3e8ca16f112b761ce8f1801f20f705d11622712254e6360e054e0b20827a53e9d8d8b6cfb7d95e82bfd8951e394459a336f342dae43aa84235261ad0c155a94981b73e01f65cfaf09cb2875d1c707af5b55e53fefd165178955e749e171358b3296157e82e42e45b5e0e31ad63b9df269d95bb610d76c0eb48f269ce8061e3a218ebdbd38dc690b00d6119a9047194a6c0452aff60bc5b46c73192c57934c69f6c713c6ba6b6c618d7a27a677372932360c101d98ea3bbca4425d9b59fa2</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>刺杀</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E5%88%BA%E6%9D%80/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4a008c41eb06db89196be589e211c0d5d3f8181925da189fdef5e89c24459cb0">adba944712a73720e1f31df1fce5374437facb60f406548d8cd1a592f11521c4fc77ac30ca3525d544520ed08223f279f869a36289e229e8acbaf28bf5b062353348e7ddfe9a0318ec09b9800208d4d317456867e1f9e4df12ca80a32da49aba97c618f256f3ca158fd5b87ba21ec38d1b644021fb50058573d8956fbb1df15e583c5b889c3a1e2e9189a273f436ec2270b5a6a2fc5379700bb990a92f482d69bd21f29135ef2671a8981faa3adf92a3fffea31e0d38c06d3f3756956c9b473f1837749c62b1f151deec7bf24b919159941a837781582e0d8a91be0138b295539625acc7e7d4d6609363d2d9271221dc773ecd86830f838b09e48f2002c4c199a0a3928a79352bdfe93dd3f22097a819fda2879e806539022388136224391604caf082682fd294e2df1f7cc4cedc17358e2ea6f96b1b2e9a5e11101849344ebd7c99b67bb81914104c3549db0594e6efa5bf89152fcdbf583812f5c5a267379899a0da2cc48a32e1a34401bbc3437c521c5c9c76321a214c2d7acf69b61d0add84bda98a54618e1ee4589d6e42ecfc8e91cc6e16627d2556cabc3c37fa8405890277eeba19077631e32c020486c894651daa1bc733237e645a9a5aaf80a98b470b491076bff07ce2b660be41006d19489b514ecefe5e9479dd83cf77409e6b170ee79219e0a05de8ea16532c352945d6e8df28b4e3920ce945388f8dddaafe5ed7e0d4a890574a9eb0d78d9c5dd455442c5850c6ad2688eef6cfb26a0833afc6a5c2460191514f6c441f676c45243ee0fd72b005c32d15bd945eb2c82ea7ee1e30111421220bca845bf6e8e1edc0b247ec9875d550bd791a984ab8e541482e416472ed27c76f0f1d4c929d64820cb45becc5f97ddb604ce2fd0289e21600204820c3760d6bb2d517c9ee1c5c3295218e2819bc57c7f159e992ef12bec55d7de2965222d6315a9c6b7e5066cf5fecd1de66ed9b2cc6622c9d5f0ca0166f0a8112405b3750f9526743a7805dd055cde6c1824628d4f7a0eaeb52c760de8a159d912fc0de19e0f54d50789d25aa806a49e5bf717c8168a043926a9c432b3e2a93a441f35bc1d690ebe9ec3e58a39176af10a90e2d0ca317449d362046bb45125eb5a781432a702454f38d6f698a76096fedf6e6599dd3a629f7524d692c1cb92ac4abb26421ad90bfa262cc0e54718629a01da61f4c7eedf8cc172629e0523f2e62db34f0ce62da9f2dd561c0bbf462a7a919187020247bfa31fd12240864b78bef9a264074146694a594dc78bd0ae14a1549bd3b22bf8b8903ea91e34ab93dac194a377480bac4f63a5ad2edcc438f332a293440c63f69d1fb7de53d644b22489e358c8ec329b05fe596f1f7c67adbe208a8a14eeb638231ebfd7d5b3947f6e6862514b186628a072ea2cdfedce0c994e27c14dbffa61c475a9efcf47b7eb68b3e6d402f47428ad89b80a8d9d327469dbb694f5814b28073fbae34454289d5b65f6ec8bff78d7e5e3d285f8fd829f9835a0caa3dc2e51d653dcfe7b1e60c156e9cadb63d87d2c2b61274e568052495fea9f7415ee553749bba76b3b0195b0ef087c35a7cdb9d14983970b2dd4ba567a77cea0d425fb893924ea0b4575150864537bc7627c038d95235b5d802a1d19c2db3e5e6bca2fcddd1e1c574039fd4116eb194fec46abea30d7a3d2091cc9e5ba09d4c0a5f53a0fe082066656b123a28dd8fb6cb5e08ef1e89c187305cf0d935cae02a79ba0f0a07956b7f124150d44ac7913ba486c92056d7b3e1799f11706656e8e21afaf896e8e56bb9b8f29e25f0e084661adeebe4eba7ed96a83faac4ccd7c3cebf1d19514098e33a7ed3c4b678ed2f5c8b9dae4a3e4f4901ba394365a743f407e7de1ef3ec95c2e1e4c369f824ae879e4c7e2a7aa83e08600df43d022f3491da90cf19d69ee27be200c6fc9ce4ccdf158150373bc6e942d41f596a0636d6d07ea6e38068e6e4c1f4602490ea875fd95a672de121fc08817ebac5662b7b4d0b2b2de285e3826842b058ee0c3120f6a5ca66c6f3fbb4f3b881d286f5a4c08ec9d6cfd2c1764290f9e2daa51ce7e12c5279df565a475a9cc06b41c80498bed3531844fe3eaed13eb1612504fe80e72f76fd5c5d01ad3036c0e897821e207e43c58b83d21e4ed2b858a46ccf1c021949a3c0882a51d20a74fa0730cfc67f7a34ec571774aec04d6f3febf0e09122450c4b9964a7116b837807448f6020eb17013691d9c7f43fbdb240df3041542718c2793876c1eaf18c50b31f5f0c972f86c0c791492ed3fe787a228911e21f6e2bf188fe04a903060d3e44a8eedc06b65305106afb330b53c9576c13b7d3fbce411c215cc4e9cf8acc2398d5f8cfbbe2f5fef6671110974ae4146c1583ad5332b82fd337885e68c3bdc12970fee1fa36432f91e21b4ee52533e62d88fa23900d04c99cdb76047a7281499c60bf7293624559a89a012c9aadd4b3ce61642446cfe5d652e5e1fff130b4b76d0f506039b39c9411a1fc29b9e7da5fdeb96c3d01f982b0df55b15b0fd6ee6e1be08ebabf6d4c929f654f345c925d5ebf8970d3a6e73758633da164ce4eea5c8298bf40f9567f336932c24b4f8349b5d0e3ea7a1a35a973cd60449af7bf47d5464f0451de6e6c16c3c0b7d8c5ff07301de3c90b8416a7896ec00e319f7d96378404c208a302a15828bf25279cd2d58bdf7c29083e69412a16d6cf9103c1f09b0aec51eae5794deef250598d2973f4777f3d5a3324946c5d073b04ff4e6f93207f7bfc296d86b1ca3631c2cc7c5acb13dd8f7d5c8579ea3bb14ae3d550a0444ac99075016e4e2c38401167488874d79fd9543463437d007446e8a6a55228959952588c925963fb4a99d6243e57aacf61dd3f8cec1ee52392ed2ca06d57e9b2829410efb06f52319f9232c7b6247ef3d6b85145413176316a4dd1cf578f2d1a71abf7e6c1ca2e3f8419ceb8df37b70df565d79684fd86200b41822f48fcb14d6b3f0ff78b28335edbaa5a41dd18ec4906d82f00c6ec0ae6228740e5436ad205543c49060a13989df75f21010be374bf69eebc288b22a558bd5dcda1d22aa58865096008a9c8ae8b3995fbb07dfa5d7283e73e00677233250c952dbdbb856bd94a4133d9b1f499955352abba94ea8a5b55de66c303cd9d963657222263640ebcfcdc93c29f7fb175dab3da4b6bc01949bd1026ddb05db455b4b925d4b924bdede50f74f3048325f0534c558945b48d7d0e75cb6d650582b650f284f740a6fb3a2cf42936df0f2eef5824f108ea03bcad23154578f92a4b52e0403b6e337d05800893d17ef4f55e6f556006d570a64dd8da627c71e6cbf35803a478d688ca5639ed57824bd747ec970307b7c08c60ecf86e09f71e1f305fa195038eb93a48f04434a05b0564a3b719bb9d6ae39918f63b70cadab525cc6e42b20616d3f4157cc9f873fade64b7fa112047f3dc50426f6385a4153958c6e995585ebcacb65dce9aedea7ad4bc838864a45a83b04c54d40982c60c32b5b0cdad607c8d056c3dd38f82e23e4ca6e680b83042b582016cd09be7098a02749dbd5fbaf34538cddbf80f9a4b756b142490f808563079b118598591c862ee034dd8bd3c9fd75e521ba169930223b4d7179b08eb638cb517c3fa549d2e4275aaae4a26740a408113afaab4ac003c275d86b3c3f45c2c1bc0d12bcc98aea482d779066e84e48dcfad32876a26b2df879dd16c93e60ac1d9b9e3710661d2676d2397b320d84c40a14eec2f5778fd4a5db9ec7cf68a9e98fc109ee3211f4e0633fd3a1cb6ce670344a3405e203b1239430b69ca45b699b0ac4e61bf88deee79cb6c4800a223b9fe1826673be763e68387b9e5f59dfc4bcbb7f1c1ca5d768eaca23b62409d670c57f6c789a5936e61622a2e6406e1f0651021c06937f4f7c6de9224953beba0a3a097896edee71b5e66036101947423a89d17309e08c3996aa13f6ad95772b911f7dac491642c090739f5634d2ff42c0b95671bbaefa730cc3430ced6be208fe95d3f2b7ec981316ba158b1de462a3d72cbf38c644441c38501519a386c1ada8ded38de934de741f0967a89e08aa4152f88fc732272d74aaa715b93318c0d0d82c5b8e502a789a0cb0054b34910011f659e45ec5eae3ed3d60ba5096db2141a76637541cde4ea82a923cca9d9d152d88a53f608e135cf990a936440a7630617bec3b19ea4d7a9592e72a1f6e5233eb47c21181fb65fa796114910d92cd22783f76aec2001811e62c3b4d0327dded2f4aeadc3037c23f6408ecbdf49be39f878e276f724ea661ef8f462187e363229891549b049cd36c8b5ea2654d0df4ad4f6e5dd2ef5546216154f82c341ec5d0c1c450b18f87ece8d132ff9e84faaedc83c32101d09c5a5234b2c878be919ed140121b599518411bab2c26aaba5996e6d633be4742d16ef05098b53ce485bd59794f60a47b033771536c4fe566cbacbb0a409355f15e2136ac514f1bc42750bae5b0b1e840842f102173e5e5db42417ff5766b6fa6665ca19d87b21b0c1e88d00ac93860b571f99408f46e8178a1f0ac04447c1f5d8e49aa34bc908b72bc60f5860208b1f31fe5a8f05312349f709c97dd304cdf6f182772bd9ad87fc24c225ec7946969b5502b455045f589be06fbb96e40618128baa96c25d2a0f08549659a34057206953474c687eb99e32dd60cfca70f7380905391ab3794b820c1c80141cbf92aa71083ef6ad1b8f0f5874c48fa281bc85f2180e261bac230b3630819d9c22216de891c778c7ebb8efb693f346cf52b5001d8abdb645c607a558f11676c860e58d2e35131e633408129abef981751ed65408150bf108b2f23f3ec0b3299d26fb37c4ef542a7c0de701b3af13a9244b22d3164b3ae995c98d594a47a60c5779f494d42d58063a988aa11a0ad09b97ff9cb2463d433f866242586484069cf6ae0a9ec636d4ffa5880cc4b1f03f64d5bbe2fbb44e9391290a223ca627398500210585c628e52401a371b193dd82514dac21edbf568f8d443b0ff41e7b5b7e68137914095be1c94112191f3caa190ab3e4fd22172ed82e4219ae41fad7db3511bbf512067ceb2c9d3954500c9d06dd80d695ab35257026de3364d7c1922ba9e9c9940d20db913fc283aeee84e74a1ac267ffe215c9d9d3799b11a8747ea5977cbf7b32b530f948e35a3639df6e4b3b656a3a31d31eb94146eff5f9cbce0517def3073ec6713f560dc082ceda4ad168cde4598ff49d9270e1e8a1986d0905735ef27aa82d6618b8c1f2fceb618ece60497acff4034f87c8e622e0ed05800276ebe855df557b63acbe8f5b1ddd9dd6a2a0a43c90ec6d2fc90efee011f089f6a878480c433c36442b7145f962489a4adfd64b3acbb71c87b2510a1b18a5c13cb2de608e638dc6753953109283e7bbf455146003f94ba53be538fbe89070fb5e9a6bb1a515e94882728b5487f6efccf1476e39c26145e78df17ea7075ff2259d310ad23b2bf3e1e5859ca6bb0163388c3e826667b2d9bf0942bb1ced337126b84aca316a4bbfc8820573c3ecd3ebc59ba48d027b2dca569133d5e59bfc78f4852f7835506ee2ebf62f113f81de27791ef397f70347eeba1be5cda6cf53ea77b7071e5120ee5dddcaa0d2c8c7efd2d49c8b40277fce025aa75426a978dc37514aadfe440d12cc727da04d63c8e9f010b4b0de10d7b1ba8fb8cfbb45cfca7d67573794d71647a91b3e9e334c5e8829b103d9db9041f0db89045a20a894faaa72771cb3b70603f84090a0ccdeadb3492c43441bb91b6721cb26d1e589873d72dc60a6c62eb938889632c18285369a33ede1bce2e5abba77a4d15140d563665864ec3f8acea07a9b392ff88d8cb3f2f88860c1d501c2a886bee5e7bcbaf04cc9d05e56c24b676030ee676939962fac5d80b85cca1b3858f9141830f870281c1fbfc449a41af1759160721ab8f6f583e3f71fed412d865bc253ed90d908724953e250a9ed5e4c23bd7cd89ee327e52995783edbe2c40fa05742ed189dff889e23715ab9ab455ae168688501b061e0a3f84d1d7ab618dbabbe0d7bf7bccf3be9eecc42bede4f9381e1512f851f8b835bbd663fcbbc38d817d304c24ce9d7c5799f73bbe8d418fa846ee94ac3f1bfdc4374427d283aa0df5d650e559afac99cda2bb97aaf416eefce8f36b0807fbb65feb429d41599e88f8b67b227b549d890653d2a6ee2b20fa8e0c480117bc0097a4993336650265316e28b8586e172b439985c4071a72858d88e12b0e3c3a504e06a92e257bdd76eb819ccf6873bb28d74ec207874390ff591c477643ae1e4b0b34ccbd2cab499cb16d61d749df71f7d2ec0e7a56a57faf39e0e958fa3ddc1a93f2296f9a4209ee77fffc31069efbeaa78f6b4962f55ea0222f3ffdb346c27db6356092a4888d23344b244887b6b5d073d32bb0bba91cf06482eb52e99d873012ab7fa80f3766a29962474e7aa8c31d44b46170c4f5dfc01749f99f2f89f1cf3051b367dbff71215e2fbad827e96d017a2438532c633236ed02bd755d51f1312b77eda6c43a5c8ede8f3df2af68fe3927f15c16f4eeea7c561d54bae897f9de0d5d6784539925a1a3891ac18463847adf7ffbae85863a53e113ddcd43247a0aad551cf7cd08f4a1c4d4432c51fee3ea4e1b63af12361e4b14a3b221730607583b9b86ca48d225ead2fd586a1baceeb5583f2fd677ba26b7500a2a9bc2a91c12237e1d98d5be12ccae674813ba5862082a91694a6b1c15406b320c6bf8c5da4e219c759d7d27c9fd2b63ecb955e268fcdb14c28adeade85e500b6deeaedaa8cac6e11fab17ea3055ae46276718d944e6246be1779b7188be41e06fab5ef6946419c25d3f6d8d2ac67ec9199308fd2104bff86e8241346057b07239875a646f34570a3420f8ecc0830b2d0d62dd26734bf2215b8756d7ef160a788bb08bd0cbfdca0bcf12906dbc10f14420d4d1fc5e5dd46f567b0d74c5d3eb4668a84fefd447acdf2ac823adfc3a75f6029eb3bf5fe0521f5b6c662d4f0846ba4bdf866dc7910f48e6fd48288a91e423079c24574aa25632e7a73d67b1f6736328f8df64aa9a31885e7a33afc7a13d429b8f74ba40e582fd668d3be914441d82d7cc2102b5aec2cd2b7dec04e6e30ba8360553fd3dd2bbead28d24a52ee77d254b373065de14ec1430dbbfbfba99f40bfa5300739496c2cce046260f92b96f18fb366dc874bcab67bfabb025cdd7571310ded99829d2c87c5979ca24e7274e97f9266a24818af685386d3aed058bfa7ba01c72f98c6b7a80ce0e6f5f788b92240f5702b9bc25a94fc7137e929ac9a5c6bc96f0c6041b5a5b1186f9cb006adb05fe6ab339b8086abb14572f2749658c0c888059c8fd742e62058d98d8b7685bf104eba54930829d8b622c940de1059021fb4888f3862dd98e6450a54d81c696205f74334f2c1b212d1dae6ac1dcc8cc438ea45b970d87c1be4943ab3149aaabc7d435aa42624b86a2bb45ce2a88c0720acb7204475ef55baac0992793ffea06043df2e56bad7c5fc9bed319571eea14b8c7be11a42402ab525131cbe999f685e9617bad5b7c6d2260e4fd9a914e58f290ec29f53668ffa2da24a4232b3f258b5364975a776acb307911fb868bc142f3376a4c101cbd45a2c3b8d48bc03de09b0439a961bf04150c1ec765346f682dee5c5b78eee6adc50c21360db8f6a03b9d01961d14176a9330e439198c0abd429ed989162e9eabc9254a10f85bddfcc7a6f75ceb56372e248fbb0481c3c32eeb13914768103c99d873780269372f6d99b88cfcb50593b8b2a8804ab69f996281b49dc879d05644aed08b074035b71800f6ee2db78f335d07aba58f4aa4ec9160a1211ab781a1081eaa3e48e79a994e074608d71f7cadd84958a4825197a02b4f86b3a8a5c8f9aaf4dca5cc18987480019a7c3cbcdd4f7f461dc37b178673e468cca9a3964dd796f394184c611baf98342c97e479505011d6044632c622502adc66f8c44404671c191be6e3204082f9525947daeeada5da14c5485dd7b3d2cd97e13eee0cbda17fc992274945b89c67a7abbf0f4a2a5495d1f854b6c1574b2741210633fc2394019d1704a7ae6d56bfc9f34089c0f295dc13e3390bb1f3320a05766fd3b95d76ff1d0829ea8f5a782c29f694a5332912c542271f434395196a29a9898b68a69ea990e7b3faad642895af64208a89089632015a7cffe49193737bc92dffa184623fbb9b1890549002eaeea28d46e8cef204fb566c4abcc42aa4dd2d6ad3a2327d5ea12b33bc822960a9d9f37afa77a373855509f2a9aee3fcff26d2cc7c58aa112567dd2670f9915b017cd0d942a03afa2c0567c3a532f7fe45dc0e5fc40016eebb4c4b00a0c84b94c468f852ec2d5330f5d0898403a6e7c1784918a8966a0c52c523385051e4c6ac98c171ca0ba7369f0f6100c5fa8d6ce7c2f80a66edb7e7efcc804bf094612f1531fb60f66795b8ad434510a734cdd2025844cd137f48006722e1c6dea82ad031c9a07ef9971287db2bb7e1c3fcbb80b2dd1adb54361adb3884f35c74867ec3a17be799d4c8fdcb0ba8568bf3e8bfb747dd776acaa0e876ed2e9a751408aa865623d66951242576d59bd27737942a3aa427ce980269789fc681085a1ad72eadcbaadcc40cb0bf96033330669077574a6b2c0bae26bc3339dac866ff0b4e12bd856d9c9fd252a421be70a02040c41a1041b4a168d5e9187a87e88738de1a2a63e0741a1acf4cab07d413ab7f069c6365636739b01b1ec420529d89db0e1855517c403e4f7be3a33a61704900b043212d748c239a0b3354a9b1b8d39b6a3c83938800f68781087d624c740ea37b242ed2b63e7f22b95db999e27fff56d0843c76a526d92f06a9f6e94a3a899e0dd8e073fea2271adf413aa9d6cf5441a127eb68692cff2dcd63dfd6094d846b0a85d2dc19478587c566211dbbe16431d21472ae093444842e567347c1396c0687241b8250f216188d33cefb26c6145f94547351f3b822ebda8f3b48457d2495ecb93b9ad978bf7af15b977546cee0f71bff92d62325c4f4803be156121896b860c4cf13f1516ad702814c68c035ae17fceba0db234a5d6b29705d7b5903a5e0c300ff2b130a7015caee9246340e90a1a19e4e6ada7c724b7f02ada2c718df08e94daa4c55de0d8fe25f5a8f819ff203e7932feeb2b5c41281c95f461374804d0b0436129a97a28437b1f08a06af7be53616d35b535479334a83d64214f0c35c5bc2e03e2c4935b64c32f6cf91b4425f9953b4eac735455bcee447cde25b141035a6fb21096b8072bddec2949e75964893cb730f8d252a927fc004401de83a592b4f636a5c653e3a5f59b1ac02968d469501f3b3a5d448d27ed2b51eba8d195d55c124986891d6efb63da09824c205c5ce29eda793144f2d883b9907471ca03b337a2b99cdec67017a0b721db231939b8a9c1f71545cb864122b5124519305670c61c0fcd6489456f02c07001ceb098200cf93161dd38f144d6d951728d0007869f7f48c464f6ce73232e7544aef8e8d5fe8f4bce4c49f617fda33debb9e24d1fa24f3782c740919ce3bf28e36ad82255ae235b41919d4661b0d26f92683c0d741569523ac1e1f52acc93a203f6eecbee911f3020cd76a4194cba2dd5c0533918c11c263d22294a73606c8034282197a926440e4e2d3e22a014e0c0c933d021f4d8ed3f928093ef4b51bc60e3aae0927ab3acbc3aa31f5b9c5edbd7542c8e476d02875767c9acdd14ab643260d846f8898abe0a37b360b770ccf3b4f99b61ef72f7d6b4cd3b4b3954ccfc62b484391616350ada191c6e750cdd4f0777aae905c22b70e1725ae01807ffd11c60f5a4b1b77a0dbeacd07efd67d299149b199e177e0b9ad0815ab7bcf04e3f273e3dc0a0c265de0cfeeba55d98aea95f644c9bc8637da0f32040fc81994ee658a92b5ab3b780d67935b709aa146f1d553d57ad8f7d59a0b8fdb7b81dd96c9b0b2cfd434ea9875c966fa0ec0fc20200df8426a29b80391e601541d8fc3515d2380de5d98c98053eac43ba94c604d755290e1c7c0aa9c47ddd9370543247397eeeb3d06c00e94deb9918b6be11580895ab200e8a6b7180128129049fd299e3f6566676cd10dc2609227c6a337fe60abccaa6f1afc467fdef262a93110016dcf19edc88b10ce11f4e8820ae0f1b4928e4be425ef8b6fb2e98fcc865bc7aa5e7cfdac9e2f933f31b6cf4d83102e649e7c066fe22f3218a3dc89a568f530f191e016abdb4c4c8f00d80895af03456636fb46ac08f608e4ea91cd599346ef91dac817ddbc855d05b50bee2a95a999e31c7301f7ed4ee84dbbad87e3dc907f27e4f97dcc6b75b251541be7fc2252998bf255b300d8d57744338a84baaa4c20be2a64da6b6ad01baf4efa40cbc137b2ddb06cfb8e95e42405b34263f60cac984eb992e418125f45cd77eab276c3a0fd407e37b1c137c7fd2341337aa3e7ecc3e3beace059d804ea7ee953f92a89f82856074dba28354b3c27e9ce1c47cabcdd4b299e3dfa389f0dd14f129f5e6d245acb6a54f4b5cdb7024e3335c3734dcf37c9d103d89fcedb0193e35c5a00af5d701c5f3c7346402783989f0869764233bd940f2e5f981ccc2435665ca90cab235f122e419eb2ac99909683355d83d78f1d4435fd2e74c3d45a98ae6c5ebcd9b7f7795fcba29f0ec820c2adf559e92f923b3341d22f3991d899075d1fd7894d201e2658a52ba7f3da6d1e6b5ccb8b78eea1657fa656b6becda394034cb2197a4eb9610a74255e5076e2ef6b6b34d87f7fe9f4e8305f8741eb735f72bb5ad72f75d1f13e635b0b1a348f349357fa86bd17849231a6d5f51a87b6ceaae456719426355abd54904d2f5b6039bf1fa75fd017c2cae3778e8e1026ee7d7fe63b301cd9b1a09358096b949768c4d9aca108b8699dbc40ef83a7fd273611e096981f0d6568a0e5b09fdffce0e47aa64912f6dcd2deedab0a0de2f4ddada87e629a711379c6f2163e6935d25143b865b8f0f597bd6189c4ea54a5ed370bd4f16e2411f86ea86e70a01f1fb1cde3085ad0433add6623c10a1e8444e8ac46f63e3a99ae96df863af7b5a5840b4b4394e2918aacc923ca3c7eae0c71f9d59807a20fabb5d04c40294c6beeea793323b6aaa1c172864980b65f2ee64363447d3abffd5b46c01327713f8f4be1b5093b496bae65a5710a1d57f6410672a9b7812c2a5742fe023284657c6f3983e79f7d2534c92240d10b7f5f5445b4cdd72303237898c7533df1d76327de3279345ff3f6fb5805004bae801e579afe735919d92a236263418fe1f6e72c89f56dfea2bf2bdbac795a42a2488313b3c9fe7694f9025d3898498744b48445a6bcdf1ebf81e244e33930e3fe138e6e7360babc3b239d1f361dbea01032a3807e32dce0a9b3d29f12df13c21bb03339ed900f23eecd2326b7bf95007ca0047e01506362abe26c003ba6a3746b4e0a8aa089e24f198a8fb079ea64cbb5fe9d29a552406b83d85923bf47dae788ab468e22f2dfad70a20c1f580121e82d3c28654689b244c34e8aa4d551cca81ce25aae96851f21606496ad4eb0396a3d49d7c1b3e811ef54ae19ccc3e9ee9a791a1207b4d39bbdfdd5c238cd5a4044851980bea19791c108c423b22fc26a88e459ff161955c302fc5107d043050a4c0f8c73180d378ed6f7ea95571c618e080330f841526eddbf432ca7ec2b4b204a354fc3260a12e3f720503d4df31df5e65de64663a1c75defd401155e6c88f3d86eb14429fab62d53e8dd4622b490f0ecccec974db90c4daa4913c99af5f0b1316ea742a1f685d42f5d9ab768dca206d7014d2b0cdf420274df66cd03fcbcb8b8cbb6089fe39ec761dbe6022285edf95848e40dc3de050e8bdd13070f27c792cbcd0e9fffdabc467417d077e42cbe920f325858f779b75a102f4c6802681352174837e04d8ef701de0f223913b545632046255401e94d05bfa89f2c3ea2a5c3bc8a8b7a21df58502ee3d4cfd6cc50f0637da6f09940a7db548ed60be7722bd945b2db941f7350231c6f651b027858e65720ab0b6658da935cd076acb2f4c66489f49b78a71f887dde95e43261a75551c1c710746126fa1912f30a118966d9437082fcc2cce9ab59798a2c8b224363026ffa36efa75791df6c55d7ac6399c8366c5f955a1ae47fcfea8b05d7942c8ad532de04791a95ee0e53b8b0b829040b2640dda82cb5576c77e4e86183e744dccfcc76f4cbabac4cd9391c80f70996a3d031c054fc98d1d0e0dfb5657b2802f6ee9ee2bfb991c60455f98b8da08df7fd72bae4f0f2027f83cfd32412f89906196b5f85875d66a8f3dc008f40a633ca4bbafe650e4329ec1ab7cef15e51117ff44e222692112c557bee64e5cc4e47ab9681bbfa071365bc31210abf272084f91c5f034e65985a8ace87fcc1381e8f451fdcbbca2c19c74f10f9313394ba88c131df17ab282ffd93c085e943696d61b114b8860139c12a0fa904732b564f30bc091addc55dfac69e7780b830d9acb25cd45b3b754f8645018f2b9d330b5e44413408e44a16d72079f2abc0c91c68ac1dc82a88d230261929d96bf75f8515353308541c23e591b7a119e1f3474a8ed795a1130a8c5524b248a06ce11ab2601e89eecb51587cd1f2c5f65259ced020bf97841cbec887829905ded2fc279700a1876cb71bbd2b46667afdcc9a1af71e7517db86856d5ff50bf99571000db51fcd63f0bded9d4abfc6a047403570b041138377a90b0afa3aa315cdfd7a5e7cf8a0a0e681d622e2d3f75625e5270b3f908f380a97033977a72b989f017facc0ac8ab9cd60844de393a3c516fa5a1271b3dc9a6fdd5f8c59bab91eab7c26f471d0ddec10cb26f3740c466d9213d20472472cbc726fc7e2bc574563b917841e7299da6c749a1a495ceec9891ca2370f90e33729c125f81227fc5eb0b1d0033c3352ff88a8cf107c684c4757ed023c8355b48ffa7363bf63f9f077be9e5dc92531f84bab1c25cb41504aa033f71ede2629ddb6be3f0d6a7ff398e5a9320bb6d1589c471aa326da0c588000978a1da11ed24ce6e197152263f905e849e15c4d76ae575bd9b670ba50e1796ba0e8534124194c40b013a6cdb350a5b9474e4f9f0eef8fdf6f04958cef47e3db3943e42df58c1030ab9b5cc8a6b52c43d764e42ef5bfd1ee4ea8d9953cae4792dbe311c8081630fa629e1a0fdd5e15b21b9208e30372d32eb4715feb39a08741021f205946629b41b66761f6df754649f18c1a3705ad18644e14741df4a91e211b91d2fb9ab8c20cf7a86ef7c1ac453e2b8a6637a3040d6eb5be0365e6b318264e474eafd16398f04dd930b41ced8b13fff1fa857b6324daff88bae4ab0df34705254a40c90eea9904732fa130c36cb7bfd7712f128ccf59d6c00afd5e980dbbbe77632d715ace183d4a0ceb47e9a3e83ca980a8acbddf102814ceab0dd0193d66b37cb9f13de3e0467fbe94db69b98f2c86ba3b6f2b1d88503d79e4fa3b09ddba0ee12178975f6aa3a0a95bccd88c65efefba280a8a2a259f99dbef7a2c54a3769a6a20f31dc550a9f338a753e8f5a19c9d657d22d9ccc969f02c603ecb604c3db0c77afb5ca1fae290c49483e7994dbe8b700ba7f8962eba03b3b27ca28277242efb901dddc24e21962a99587b3a452da6b9f647e90d1cd378ac7d862704380ee99dd44c5a49a786773b644a8563f37c2588f0b60ffb9fbfecb7b605e71a4fd8e74286a1f64876972899a8b7ba4d60a4cb45d415a53d718699551811a06f516edb88682f9d4cc58c54e34e8e6d2cf7acf2bf8a01ae91947c2b852180a292303782d3e5f2c0c30e98a6351690fbef3f7a765ca2f7c9f8877fc4239195004d4f1a7a4e6f198ad8f73704b79402579388a606749112375553fb3e8173efa1952ebef4935341dd2cc83d3da67657637bd20f190197b2e7334af176bf3d7ec4edaa52ffec273e2f4e5bbf3202f3801e82818b6fd3bd07bb122281b5a9a9e115283cded76e166b014e69def047a864607e64194243f7950fe45c7198bc38aaa3c0ad1d65e8625725238b9761eb31df10346bdda038c3282392c0133fd49b2f38a18b581adaf21866dcf734396f020f9954f16ba92f84f6adb95e0ddc65943c2acb4d7905fa63971679633a70776ab0b78cb0797a50c70e83ab1d4ed822fe72b453b1803a40ff7aa6721e72c8c2dd701e71db9024b5304aa01cf1389d29732848f6eb9d2fab1e8e770721bf4096090943b771c4fe99e5014e7854c76d3fc91a8969a1034cebab0413987991b2afe866f79f389f187eb28f36333aaa643104bfcd5b6d66c8b96ab4111c71df65adddbfeffe64017255235b87c457afcdb30e7651e3b59065767d9ee712b6854dafb239cef5f7e12939ff5754d2d5faaa7ccf2ed98ec453fc8437f021c74639f0cf55cf987471fe02a38bf5cb08e14b33e3bbd2a6bf1f5a04a7642e23289d1d0cb37890af8242fa2481b4f51de11407d8752c0a772df1f257adb74f8c42e407c4aef07a107b5d89f0debbd46293731f04dfe885bf766b91f6c4f54117eddf77fe0a33d14148b997a0638596f52b50468fa73252561c155ef285915f812fb2542a398fb2ad1c80c3ac7e7596fd6ed1201a0733d77919ce8b8c0e9616fa96be7d15234f8b5b9a13d8e079cc1e169d483ead124751fc631c8f856cdbb512167092410c7059c5a3193da395aab1a87136b7375fd6f116c9b38175678fb20d78e3930dfc16e59642a20c605ff526c88f1a90ca10313f906f9a4fb08c0a7958bed43b291cb7a89da48b986e4e1fca0ef9082681207a680d0ce1762fe94ac85ce6b8974110a1a84c49f267a7f171866e2066c65e14682020ac2c3fa152b1c1260f0605f520a111ee96372a07c1310893a06388a8d135c00877bdade43f4ae6e62c767afaa5055756c61b2768ebb3cfa1b187c954a27e2247877248ad85d9f152a35d20f60cd49d77e0c45b38495433fcfd8de739416ff3db23c73b466dbae8d96b8fb0f52e9b59a5ec991210d86ff5a9e6603efc89ea4c95f387674828fbb52d3eecc04139ecdc3162add07b8aad9ca8e446f16765ce9fbed6baa6754dd336bf613f31e0cce5c41322e3af79a09c1a99222b3bfa9311bec5d5e1548fc56dc7e95a092ec749b2be5b3c5092fdedf3cd0e042a28f38826b12778b78fcc78bfa67535696e14fa5faf1fdffc14cd2b79fe529e33e449edd9aa8fa013858a2de174b17718454c5095c6c1c565fc92924371fc2891ba949d41e51ce8241c5ef12514cbb6540966e936f41a530ae4ddb6a398fc90d26ee87ee6c83df0afe85a149ea10cf8469a57647b2ff7c5720c405fe528e24b6b6a643d700163029df7fddadfd402908a906454d4d1f6628ef45f634ea1c620caa49a309196a5bd0a9442ad42590806f2ae6fa04762cfacd523dce215de125dd0763528237af17cdcc4cb10b1498c989af150a83491d0672d22c5474782d9996e5d70205a27639f7fffa786fd4a83fabffeeed85747adaf14c68db83262b31af3b7c477e5263619b7875bb3428439005c90087680f2453b990a53c53604b814db4e9972bdc1fb0f381d4d7cf688457d79547bf294a1b46107aa38cabfcd0cab7f7f82d6fbd25bd770cc84b3d6b076ea3225aeae9cb85ed8558c805cfc2183834b73cc921374f48cd429f885380861735d9d6a2bb36832379f70bc338e175a8c73557c216514b4c44c761c737943b25a52444f26330d1c53522d115b779ba1a02ceb9230e5977fc947aff2c18c341208eab2aeed9636614014f41dbf008b6f27b4b7c0a217442cce1f6580457ceabe3bc3e27bd66143793146c5f3fb4aa213e6b47822f2760cee3638e5c02f6fedc7415f5e3f87c0b8ee730a274a2f6ec993ba0881bba7a31342553cb0f8c71441c9b03079787708c6bf77c98cff7d271b86f6a71d1779ae7d73a46ae1a5d41606045e7a97363296f4310bb0b99f984bd77916c022c07c49ba4367560f7a566613bf1bfcf8d21b62140e05173afc3736d66db73937117d07e88bfa3f6af98d58a9c181806a3f59b99e9d7e5f148671f536f8b408415862aa68091736623292f90e3b1b7ba2482019625103cedf4daeef1ce907512aa7c25c6524c4c58a47d977f333ad8c8407c1b832b49852a581bf628a24b61a582855bd68e993eedb01eed952b264746f382cc1f21174cba75a72ff42309ec1da6baa4a137ad74398aec4be464b7c08af80a0e753392f703bf04106439195b82df49778fd5cdff2b3234158d5ed6f243660d921b0c614881732e5000899c31fcf6de454d8010279dd349ce2057a8d9e3c8344a7a24590b4258756e5ddd3cf46de6713b28cdc6220a875b51e952cb1dc6b20e82d5f99ed45c4b7b6819fa0cd8caf86929f082272a8618fe0717ae0297410f0fb4511da883a42d10c5112ee1e44850f2ee32f4eb9c84e85588367255bb2a0a1750f520ffd224484b62e6c2c533e7a505cd45c5bce2bd5b320b48d4dbd305eb97bf8330bbc6ca2dbfd3379f37b150ad210cb203c3e77193599e86a38f1aca30d396176230903e4bf7e63874492c1af0cf81d77c92a8418cf2f59da37865cab71cf6596f3f8331755265b3cc75e56f572737659a1a67e35bbbded12655366e62ae4e094288d7d91f7245d20ec22d676b2ceef9204f3c99753ff715051bd709154f12ded34993c9be71eaeb66e1df32dddddf10d019448ace1f3ab4690576f1b3aa7ec9f86403b3c2f328a70cd03950c5dfb2ebe095aba581b8bdab57c5c5c0d2a3fd56373671ccc603249fdf95562d7622a96a9e9fbbb495c305e1a40df69221f131721f35e4fe1405559cbf017bdafa0b04550b6de38b22442065058266192a741bcf4f0fdcb72ada1182162b28e6683f549e1ce2b2a5c21a17c4f4f968adf038c6b17cf0971aeb0d60ef9cd90355282944474e67a7fc9b1b4c99b9d771ae62d61bf05076da37a66ec64460299761ea556fe8f47dfc0a9bfdcc62dfc0a69b7cdaa0b8c4e6fd7d46f073d747944b2d491f75a497d6e0807bfc3842ba9f4ca2a40c75db8b2546d75e6cdb8a88bbab94bd35505478f497c6695b8375de63bc7547ed8a0e91f3b3117a3e3eed2fb56f3561365e80ebf39d07ccb4f7ff027cd5b2f6ce783207cceca4b6e895d362da853cc3ed163ae292be860f51d5056b6ce6d4625f2acf3660f08ca757a0a61091ce4822475300b7771a60dee81ba28c872b4a8a05127bbe86abd3c89e236f6402f654517c390c6296d3ed580b0e96efd1d9607a12c835233309e05dcf7f4df630f026ed0a6007b53833cf55a450dfaf0575aad60aaeb24a2776927d1e1d189d1eb8da290f89ba996ec4e4be56d9d5a2aab6d37a9ece463a21747bfe796673555c4b585ea95565ed55c6254a5ee7d8e5e9337a685978771ca6463e1d9d827d4b18a9aa402d02de0d4c30eedbf9d46a0e5f0003a4846e6257d898f9a751dd483cd209a98c26c72b81f23b14d8fe748e58347adce8c957ba7021dee148b05f8ec3bac61938b2b7539cba947fdfdc981f6f7302a8ee240ede27f96768dae2da12a7b93e69643253d6684f40ec424c38ed74b9f5c3d0a00e3a0a192df0b0ec74e32c034074a5593991aa55cef57a769eed7ce49ae565659f8986887b7de2f539fe7f186c853e609ee89f58196c9bf2604bd266ce849532bbe47de4d803b5ab2aa890946dd81ab727ae5a9f2b0feae58f2811e0f4f5a1b352260acdbbc64b28b096512799990fe98849ec48d0de167b00eb8a26a3c3cb87f62ed5923863b5d97bad0965c14527217f6727954f27f0b0f8783da4591531bd56ef84e2ddbbdb3dabcea531b176af7643ef662b5ae698e2513a90093e3635e0a9032e1e2dc13a49f7694f0cc03c38eb04329978bd22c33e77a3191e2915c63f49e0803977a44659e985224564f8cfd48ae87844c8c053b445bb82dce10fe6b6b3ca779ecb6bb055a2583bd6b71955d8f3fe45fdbbe95e65fe2fa079ad288cb0d7e4bc8789dd2486ab460d44c0cb4452714085a575</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>你有想去的地方吗</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E4%BD%A0%E6%9C%89%E6%83%B3%E5%8E%BB%E7%9A%84%E5%9C%B0%E6%96%B9%E5%90%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="91601bcf0e6d9bff26b2e82a10fddcb14f347e00b984be05ed3f5ec74efaf86d">1c9d8b8c792a241d8f66f0fd62fc81bb81b5d66be52b6d9b6c756d83d0809762ac6ce5cf0da7be55a93fbb397ca351af8ea51b05ec4de584d7b21447d95c4eb0c9184f2a9921ca0aeea61e4739504ac082a69dcdf2e8735d5e4faa2573e5ba9e1d65b4a3a6be6f0abc4c0999834adee81af3569faca6f39d614ea825b2a8f121987d863c05fa9c30226b80e5b1ffb8efeb4b9cc01cbf3615d7195ab818f537324e30de98f03517f3ee600125ee55a240f319d4efffd7dc07a2382eccf332da2dc1fb8ccd82778a8f5ae2e6c5355195cfa89112defaf452768f563e3c8d8099b05a0f8f9152c1a7310001324429f286aaa268bf48d130613e172ad4d0696de5146e1c9a42acafb4a4eb0ad4e30fde5cebf86530ab38a7bca346d2c54ce56a4c03902e51a1a946df804aa4bbcdd005df6022115ee37e652cf5f008ec51b1f04240ddfb554d86acde1fdbbda01cef76b7e3971fe4d0c6f3ad4fdbb320b16b1e841e1c0a7d79a665599c44e992a2227d0f2c105ccc57db5c71b5741a0ccf5ba9245738f173f17daf7d7485cfd8ad67b27c4a2b37b936547dfa366560b15090c818d5daebd0e341bdc02796b89e9e00610839a9d143ae90c2d18ef6eb2928872c26ec5907d11a9f6c1c22c14e7b44e3ea9740f54e8fe02841be1af7eeadd34fe94ea28b6462188353911e6cd42a44c226edb696c5dbe4b69f865bcb2258f624645bb5d0d450d03a9463694deadb684a85e03e6b3928abd1f32104a088f8d89b81afeffc5b6cb2ae0c262477be8b6a8abf323f274839f429af2f109a14551bcfe01e48761d34518934f283b917cbc84695d225f9546322d72c2052eec469f58092fdea14cfcd37c0dc1be6a55a3c24cd182dac6e49027ea99e57436665b146a7ba970b6a489f00a37615fa9c3c7e682669d24b61f55beda9e0e7fbdef04e0874f01942e38dc8515a4dd73f78d8b0ae0d374eb5f2a967dc59a6fc9b28b380a049a90c329dcff540fa3fdf8bd618320ddfe54c3017c0e19f5b86eb0e82da1cf4e198133b92b4bf8a97c3948d27594eee466dd850fd708f5d0a87e3055887a4e000d3f398762626b6fc8516c99d9f8747201050b912e6f6096cee36d9657e0a402883ac637c31e1ddb828b065dfecf89a244d724c81d9697e33622af23eb328d44d38818a2fcca97a36f55b427e95d671f6dfcf51ba7cff36de457de35b33c761e24b76f1a70c1d2984bc007f14b88ff5d253cc57399c252e94478cf158ff79df78a1eea83273c0f89395a7b7426f264ae5a8fa414ee4aeb309b2f42763a825d0d58ce8bf1b2386b48f2438c1fc950bef7667c6f58504951ef591f82bd33a292c4612087d7df4bad6e89876a5e85edec6491ebb8ec3640836492fcdaa3d79fa4b3fc5286ea909b3460822ce945db53b5f7298163514097ba210a89f70fe799523e3fecf3c85e9fea74d537b6d626939ca723e3ef1f31ff7346246aa7ddb38c0740cb6c3ef39d9cdcfbcd872af17ff1f5ca3ac903ba4f16de25ab7578e8d2cac9d96e7f728eda2e791cf04e1287f8029ea1fee77a7a5a1fdfd3736ba800ce81c2e6b6114614402752e426d58b30a9178adccc62c7f6cf2f0db471380284b14991403d89ca22ea4d90fc4e9a851a94f4659ea2d58b6bf23db26f86feed1bd3fed0b13ffd1167addc28d4c01f4d3a0799af38c01276e886b18b9792b4793a45987e141c7dff0b19d0bb871de23cc531aa9bb717d9713793db0a3624ac26f171b5608a1f17df6f0d6afe1e1599cfdb7abf58b556b2366628a83175972e3cb03929c3102cae90a287caa069a3b742953d59ca964440634d2784bcaf83ce9fddb330df6b72fa1340c56aad4db2f0b8965a97cbd6e33080f747ea819f201d59e14be32eaed01b53e8b442fb071453ee47ecc5199abdaf4882049124162e896bec607ef5a5078db5a13b91dbf49f18a2a3a369b11b6fcd3a26ffbc0315683ab711baefc62542da21a46d1876cab7c09e9990d9c85208cd073b0d15f3e601b167d762600131f5abac3c4e58a399740ac1e588ba2f3ff5128367f980e2939cb9cd787419256c9245f7bd43a6190e0be653115150b8ab153413eae53796952c2fddb085b35d18542d8e9af2063d7043a78b4b77c7dfc9a055a104eadcc7e1cc27f2d67bfad7177915c0296f354cd063293d5dbc353d94a699d87afef0ec1c22055f225bb17116a554940f88dc311a0bc294ffd4f562bfbed8b695c66bd1b42e8c6c48db98ec95f2e31d99ca6c960d943787daaeb301b291984b46a61eec082cdad57d5d782f4c1ddde701456550ac1c72905612a41cdb1ad59f54139e6d9a6e963b6df31790d31428739ffff69ba82f74c82353e5195304fed616590f1239a94e9d62e3ef93540223c3e4445ea574899600b34fdc304c072b7b6065e6b207ff913d21c83aae39c00e82c3a374884dd1517722e20529b9994718af2968f4c79c9862553f81a516810850c3f6ac502cebbe99a4e100efaf4a6273465db1e29ef7cde531da9e2ebf1975c7781d31884fe21b9e3cc9f08c99dae4ba95b90fce020c40ae8c9e6c3bfa751e8e551eada5c5447f5ba1d81270d233bdd000fe938b56e47f3fb95af5fb7d37e4be365cab267835d5c376650cbc5e2b4aef59f5f43f2f13d50e724f2b290ddac6868b43532de63f3655ff6b548bd7927e88e72bae4ae1e2a56de19ed756cc321151f841650a528c0d5b01e97f61d8b9d8868de8df84f757614af164b422f5f67f0ac856f8ee3a29be1068ff6a0b6a84f33ae6e9688af0545483bf98c84cdee0177d13cdf026cbb505f9178a9e9accbad809cff17d3e96c904637dc630874368aef6d761e929b812596c966b8770eb36df9c41f7536831ad9f5ed53f167e21f76807b20bf151d8313d6e3a66401d5f14a7a9d6d851907c7a33869df1509ff4d0d5c10f340cc5249a209ce83e3a8d694020ec3ada1fa596c40ae4c044e445e130b17fbfca47429600e00953f7d42eb1c960f4814570e000f1d20f496cfde583250664110fa0c2adf6f4301007d605297451333749e8986cb3acaace35a17ebe3dd4abe858456e3c5fca0101a0ff19f84e853fba0a85fd22372fb7a679ff51f8adb46ee9d29919cb88fa87988b016f1ef37325c27a52ed829175190e14dbf533e204d194dff0b323edd0055538777147b487f574a5de3af16f6b3ae395355216b1658939e2e50a056280a5081735f431a2226eaecb6bdf8e437d2df971a13c44cdde414a4c24c17919d5141c18ab2fa43a9e6833c927accc708218c94a148b4cfe351b126d017a3247fcf04893fa53473c9137bf3804991435abbb777b257231ffcd6217c7d1f6d3b18f43e7b4a774e8173af80265d94682e60a9f72740f995cbb37da836f31a97804d19c249480341dba2e67017e15dc03c0066e24638a39cf7c7da0c66312597b7ff45a4aed03a67606a1493cc47f0d769241887301ff9929b51a9440b576d055d0f06707251f74fbfd2c4335bf26da878694021e14a11d56284b917835574882889e3bee836ec970ccce7e0dff8d7d9f92eddd112ff62da0361eadb8eb28caccc5cfa26070831ce09e6201496c0c36fe80db9ca655ec05a843b6ce8cec471533ab653e49ecf0885ecbfbd2a1c6fc25d4e0872dc90984062eef369336734bcb326ee4bc60554e453d638ddd75d83d0864d5699148c68357d0505ba45fbe04f6a2ba3d14b5efcf9efd8f23634e131380b3ef2083e54c2d463d79a6d285cce304ffa03ad45c8409d92b8196ef3fd365432353e05064602591bce944c54ae4c7de67b2fab4493334fb1a3b265bfcf8b708101db17fc30182ab2d4e5219eab39b8585c4fee1fd8693137fe6c99a255cc30c7e9e75527e927b4963ccb000eeb1e239995c056444b99b091406b5d8c91a20ef8f9a5767659547951c681edfb5bde883dd62ebc19fa75561cbe8f29a254e5ca2714433db9fb45fa388ddb6936cda38e3463417e4647731b09ca10319e5d366ffc8db1844a589273b3c4c2eb861a5e58af82d660bb542da982cbc2eda68b88decd9af587fdc81009bcf0f6e0f64f3e748a73ba544953fc4ba194f0d508f40b575e9ccf0c8e70db8625c9559830af5bd9306ea17de6ac4c77a740f261ccfb07986ffb896515b04dd70f0dcad6fd077b28f0c5547876bda0b7abaf69361b90a4fd904c1d4308e5cc26e4826527d246d5f6228cb1b1eb7632868f67875b4401fc9105e4cf41f21772b3c406f52d873aaf35f16ef5b661bbc387a9fca64f60762429978f0f7cc0279c2bbce8cf9b0947586ab76b6a6d761a8c5c2a9db1bd058aaf4a4ff616fd5163d8f21d7514d3b67da99a5c850fc3598b5a6334ef9f38f3155d32483224e7c29008c4bf969b2bfd0fd5493913c774473366057c865493acb45185415f3eb8efe442c2bc7aa40e92464e4f39aab5b9c0b6895f69821da3a77b90d3b580c6b082bf2d916550f9f2e911b731610c0f2afd915f5cc6078cbd6ac4c685516860b702074a22ee3c99e2abf75bffd8af3d34c55aa66bd27597be91ebe3627ec94a256eb002759b699a9191932fc67219f6b87b5310473f67a7976aa0069893f643fec9b17392e69a9710e31ace03bcc95a17cd971d639fd3b34b6165e03b7f85abf361d0afcd49f29eaf88c76654b4adb5b057646789901111fe2185dfad81de74561fe572c162dfc781dd9c831bb21d3a0072bf5594070c8f649708db377c905281c3ea2abc02b0872d40c9318ed0cc543f589ce5f5f2ae986b3662450c0abf314470cb4fc6ed5aff5f2752897180b3d6e7bd0f7cab1ff21d0f9a06bfde973a1ad19ac1c4f183162f227229adff7b1be10cbc69b1c6907e0486dd1dc41dbe23fa79beabb187f392d4105308d935fd916df07c003cbd6dfa99bf02626901d2d5e31ccd92a7a374cbdbed53b8ec0180191ccb36a8a63cd00b463c996e175c231428aa25211378bd892d92fbc51ac0d9cb511af12959d62bd265def35d54e9fb28ea3c3a2700b50b488c4031bbe9d0b51dd9029b519a3c6b929a56f4202b75d05d41e1f9594d2e2edf7be55db58c264e0ce80f67fa90806ad595231ab12fc44c17781703af4c3cf0a110e5d38a83817805d3b7c1cd822df32106171a81c0e85b7467f798eaccc86fe288aa11676f925a3380dac5b5dea3c78ac6d864bba2695cedade48cad6242c848f5d6a52e2590604cdde47b96f183ac2f7573c78b09a2863f19a4f3baa003875d8e1df7cb2fad5ccf9fea704d645487ec73396542450bef5216a27a04b7c5a6522615d36a2ddb42aafacc3a13813dbeb8ac5bb57348edf3ddcb41d3216327f30c8be9427c8e0357880867a114461fd903d2d7fc6fddf025d454ca732bece5def55a766827d5f72fb77d507ca525f7593c4ecd4d87a467e08fcdfaf273bb51c92082a140f1adf127fcaeed2fe1ca5145fea07ecee559795d8bfaff15d7f56b179cc91091ab0eeb75a660699bf0ec64102c65dbb9204476ac48259b886b90120b1dfcda6f72c82d724532d3b99c6d2d88d1c8d825b2d731d7c71fab957693cc0b85cabe7ede7028e7baa89cea58be20529d68805f3e902eecbd5a17b03b0ae2ab767fe2719588c1a543666a0f9bb084250acc3c984c286f0bd43eb4f07d939d635919fc18266105c16be03781d832d3f1bd04db1d06c7d10eeb7ae471e29de3a6dc0c74b3ea551d0abb582d2dfc72fb6c9ab19dfa5e45f63291228cc42d0c1eb3c84de3101fc20084dcb39751404658ab9f72a9ce294cf60d10425d909e271ef8c2e8d04568e064feb9d35aaa82bfeb315810906062d0f3b669d02dbe093c09a8ffaabc68d565f8c762c551b6616b899848788bd0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>昔巷旧梦</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E6%98%94%E5%B7%B7%E6%97%A7%E6%A2%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9517cbc3b8b1e3a79fc553cf274245a24cc1a3483b55f81fd3386ab5938f503d">e55e8fb0918b8b65d60b5b09d6dc221ca0ff0e3052b28133d3b019c26900c8ac3a7e1625601ddf198c4087986a5392073f5723fab736810d8ecab0bf0e086e6020ef4f389e56da3ae37627dab58fb2a46f44089e88a3f3a8219ada5ebc96d73b3d660130a6308eb8b3435a51779f92b7cfac7c2af06679ddba320a325c7e6f2076d470200aecc2eb3e62abd0196dfbd5ee2d9dba2c43b26d1e0f19ea411b82fa7a015f9eb121863d768ff44b0391bd13b2c8877d76d07fd217c05719f170ac316da5829f7a783846766faa5f7c418003c46b23e7503b6a0d03972c971ecae5dfaba42ff48ef83756dee544a417cf752de0538600acde89f2bfa71afb1d38165de7f905fedc41f633784e81a7a30e908223b9f3bfd638568b351cb24f5eca7228fb12b3edaed38ff8e63553bd5b1bf31018d8f4d47cd11a4ffdce6c4ba6ae509dfdc3faa3274995ea2ba10a67dac40db8ea0f795e7a7332a8a852d20583b4ef21d2ddb07b97ac431c8dc4cf0bf9ed61788481e087a95051696dbf7fb8c09cda9877b76b62b124e506ab40e6f5a187a5793118960af558148c93918388505916c990982046d3737131a17d6c596a1e88c3c47b792d82f476a1f793e8b8eb363493d3f11a72f0b89d8ae601434deed55ae21cd379f4aa8b9770997aa179788948a220aa2d7cae376cb8510fb4e4187ccc926d46f57a6fe947d85d1ce6dcf40977f81882e5881884d7d0189b0fcf4d69710ba8e25b1758cea9f3646d03fb3ebe051221fb2aad139438fdd6d4e35f1926aa9f71c4add5c4663296be538f24f2a1626713796d9be60c0f2f6a28661120cef27bef0ed5c724d061205cb2a6a7803c33b8f523bcf1224db5191637dc87eefa9e755029fb92cd87b0be727b0977749a3ef85a52ce67e64f6d29494bce659c2ed46c1e53411c9f28682657270750ec8c223081993dac6bcafa32cfe4e9647e239d895698ddac01ab6c1a6b1563c058b2f3bfe33d1c2bd8e5e8c955ada7b728ddea0a80c8b852a3c868320628730bd4ce1d36fc1061d05ed6c52b35d4caa7cd15b5b1388e963a16cb44927058812b269bebec054b41fe9d3bbc0ac36adc3d671d5626033afebf53c75c6aae9d3d0db34859dca01ca821f726e7facd076eee5b37468e51657d9bdf59d0d87bb3a3fb7b7c11af070e9ca2242e17a12f5c5f98b015628f1e51ac970d0e5419200b99a3d5d23c72efe012676454552746febc688ad96809b1bce345dde620d1125a36994ebe9e1d6772a238c99e264aaba125efa938a7098a8e5267353ba71fa00442b8708574d2368e2c9e8910a989e1a4d087e40d04cdcd3128a6cb2d7e8a7ec1ee1175c55c6547a8a1ba23fce636cd7adbfa938eb0b6f06974b8435ced6a8ef60d036c88b933a625e4f1c0b0c1e8e0baed78e70d839bcfac8a1fe93408dbe25d6067c8320a10611b82657624f7d64fdd158586fe34d7f8c1cca23c558ad7a42ea8f04f2208298dd5086860db6e228ffc766c2b5916e97f92707c4cd4a9129a8863ff7a7a3cb18823943475ec742cd8eafe6bfd07a25734516a93136049455fb43fd6970838d5fb843670cab8492721fd61467ee5e8c1be1264e5fbbc9d965fc7452f5e89938a0df2614cb91c6ad94bd90151cce9a63b7525124d31f5ec047980a8cadbc136a1e6ac476decc1bc57dc2ef0d092c98dd685cae426fbdb34d95262e3fb7048e2569071eb4c8c320f8655ebd964469e075e81edf00ff6eb9a45876fe0550bc88a617e2356ecb2643dcf1c0e4246599837b3fef0c709b98d924ed8f80b386759d20e4ae88fe72a489b85a98bfb9df13c8fbd13287b55faf960ab6340e93bce433adf640076988df293b76e61ed22e681100b5596bb317b189fc1f489f674cae6baeeb5f38b9a7824fbfebf2f1fd23033b92cbb148ebd284fc15034391204e33d85f2d61bd06c7a9c8e8a4f713e7fcb85130ad44cd8cdbbf2bf838a1e66e05705835d146c41850625f932c7b0bc00f795641ec37890cf56888cbff818d82eefda1c03872235c70a7a3b9b5ea0986f604c5176b6d355e3d29f3d66346649a66c1802b1b7431b709a5fbfd53c4498f8a35b2840056c9bd6fa425a3bf4ef8fb112466d8141d95c216422a92c28df590aa7f2544c792a0e8464e348779024119d9c537c2c718b4bbe881c09912a41ec33b1209bbaba1ae5b458836d85a4434edeafa6b78676d687e9c486b916a1382e426d29a71733b2ef349c3e5f9dd572dfd6b345a1ae74fd81ba29a0aca4586b920ccbdaee3fd46a068e33ad281b7907cf42900d8ba7b1c8960d9c3f7a9a0f938514277f7d3d962c175feb2051e5429ddeeea03c404e188372c77c1ccb86bff8bdea144e3cb679162712552712b20cae9b5172f8ff249f339b5699dab5d9d158df7eb36388d1066e92365b39bfef94e5eedc669a9d6cc876e7a6fceda45d2d15e07ee79eb6b8a71c927040f92074a0d0bdfbeaf48bdc7e5a4bc1597db074d91ad651787ce9d22de645c8f2f97a2c802582de997319c854eed07424b7d5b370aab1bdddfac775fd7bb682028d1832f45c2ab056dee60cb27d06b9ea4bc0f0a7e04ff664ad353bf29d2a34d0234fa66fbf0c3ee7a112c27c3503ed46d274dc2b54341e896f745a16688c66e6ae2ad1452a2df78819ca1d49d5287dec2299df75b1c77b59e45f3cc27859ee2d37a28bcad3c2dce694ad82afbad68bbdb5559e1580f5500993983153c5b388e34828cf3b632fd62e164634f16354efab88d803ba6401409270e61c068c441d82632fdf171505bc08aa2fb491fa275363148bd5742dd153c5042123c3971c41cb6905410d37823d4861a31fb80956bd171202c9fea206ac8078cba7769d0158c331e734f969feaec30b6cea45b81460bcd3e81e794c572c7c81185f84acff56f5dfe03f9745b3b6337561d638dd76b3fe290a543f5fe41d34df96f24ad69acb494e7fdd25304ccdcf8c57e44c38a56c83fea6d94fabe27a952813324552e05432c20aa709f56f1db49b28b415c0ba1e94493b2ea8480072c50f3edc577a4258f6146f041cd2f711d5dd4c6c7e8668f0f4be8103795b21d6ca1dd5e0cbb298615f35aff58b6fcee9e01867c5b697263965d30818de8ce3faef0b32ee9adf14e78698137beb64e0b18e8675941e43bae91f51b77ea1a1816c2644157aaaab0a14ff51e5fb101eab44a760eee8ff15b04a190a2ca4aa6a492e0ff243a5ee9ba8aca7689c8bd0d0c5c9894a901276aa95ad87f75a78ca1abd4f18f0cb79c3c119512ce0fd28d4024bbdfec9063f8a314725d83d0eaa60e08411361ed22b795151eeaa953f407454637547deb251df8a9695815d7eabc747b838377702ed96b97d80192a6ddd691887a3464fe3920088e05e2c5e5e13f9bc7c3b225488a6188d634f2d14a57005b3dda32f5ac5536faa0ced4e386818987c755667e89804fe3e5d124be9ef5f10970c54e8f08e02eb3faaa30fe761bb243c49930a27d6f43350d871d8c1e8d1e71cc54f43dead9137c6b9472e6b1ffcaf537bea81cdda8a62e41aecec3cdb4a44db70a1b935e752a86c693057270f0fdbbe85325703d69284f57e1456825bcae6f297bb572eadb7f85626fada05d5a78ceb1258a512e052abbd6077c7722cdecd86c884beccaf563d37584fdfc35029d47d582dee8ac221c9b3f5c031518653b1b0b296b1d4b9e351d429ce0d8bf5c757ab14f276dbd430cefcb2f2d16e919453852f287a2cd99eb4e2726dd5bdaa0355020447f8dd1eb14ee395cdbd1de0835b568f7f0752cee43c3d75603b45d0b705f86c8e31b0821a4714e6dd70f633306070b1e980cdcfcd961c8d148acfad65e383ab73c0d8224f0033eba21c447c3ae50b07659aa40e23e3b8bc0c30aba291cfe547ded6a8bbc1f0bd2c7f7d84b9a156239c5a9654cb53515905ad41726906ce14689fdfae44ef49678b368a3d9ebed4ea40fcd15f2b40e90ae250e0a7d550f44cc281370216d0a6d37067a6464ca6c905e994732711579043f499e9640a43b3f45a7e1770fcdef5698bb67134fac865dca1013fb3ff4014d38f4c389b936ef7ec07fd5545f80b7bdacf825cb49ea4eed3c38873fbbf89e0e34d5b08be526a1717008b5d853b806a8e9dc270c1e3ca3b75fd8f1a96a7ff10d6ac7e8a2658d0b65d16d12a6475ffdb15442e5ea7d8777e4bce5548ffa009cd5863e685e145145a39e66cbb84acd4f9a5d22ff716a319ad8f310f4395fd73c4906d9ff569939c0443cadd43d10a63acb1082611bde348ae2c280769c141d570958a90367365cc1653ad228bc8b4db5a09669c909e62480bb6e8ab7ab584b1b8d92d4d5e3a28350721d9fc0ac3f36951bcc2066d7f19cd8d9ab4ac6cd479c24c9a74ec046e66cf2b49e4ce3f96d9091c7101d3680af7a00a32d23a8b7db8b66a87204a2ecabbaa55ae884eb02743aae9d142a45c4f1bbe491ffdb9380fb7511df0fb3b7014a0cba429b0b0e3f75d33cf1a742b5050e4534e68fd5b26c70ab073d8161aba90610eb687c98f1ff55cc22c5a54c996947701a0a4c78aa7985eab3e921978b561857cbf6ee832d2f18b94a69a69d1494540bbf50305ba715d4c9cd7a94e80c8a73d83a6d35e87574ae1dc467148e78a27e824a05426c93c612b67e4182f9e9b57fc5af356e5048a92130099314a79c5123a96aca06e9003fe94d251f89b79f2deb8ff63d84abf8691e62e24d10000e8f5957328c8c6960ea2ca17029494706dc976cd2f078bc38fc5ea0ad48503b4e7527da4ce9df36d7ff2c751287066a348a8352a259a122c7cd8767d03ca31269d1876216bb646d895e3679aff1dc4fa6b3e4da9abf816eb4f28ff5537d02f3dbb06af5623c0167ecd03c476361ff1f1b97600e14cb1d277939567e86686be91518c51a6b59659a4cac0c847a2a0223c0899cfd0d442f7bb2dc112d091a9ce167d3fbb6253d0a9dec741e97e88536bd69c47d21230a3e02bbf50668deab00d36fc0ea68a345b27c549bad9276796b03bb981217201a368d818f3666e2f9dcd517a0594e1275aa2e9403af446f66297951e9a2b8ebf589e83a70ef86a8fd877fab1271a41dbf89e213694b8e25733e1733703e67a80976509aa379d5a014d22bfdbd0fe518f68951f3f26ee2c8e93176ea08258004c3a64c747830c6f47380fcc2dc15668bce5890eca134c52254603a68813b3ad25f8837570f8a2e8d679eb4b1bade9412d7b5eba305c0a768bd65cfb5519e31790da347c6583508015fb087201feae65e55bb48fb8cb29afdb6b910d1d6235526ce56e1cbe535366d4fbb9df1027e96bc4aebf52a27b4026740e13e3461553cdf3cda99cbd459649a3c5cbba147d3f1183c678a1d7fc9ddb94b4faf3262162b5232d46f4d3464c24e766c1f832d3df01b4bd0741e6a48590582b2e0e72a32d49c9b79b8df0be9034b167815b739d677fb7d7a34c1ceedb3db0fa010ebd7c3f1bed65c5343506144c06f0a29b37454753dcf44fc394f0c47505b098b405186a18f67976ef5e4b3d6d52e1c783827d0fd28a9439ae519625a4fcbecccd8baadecf105ff4b6ac93c0461ace1c6c2c0619e361c14f096436e1f0a8c611e95c87477b58c9048066198e65b7b8780e9622641bc7fc26cd9f850407278a379b035ae9cd809800c3765beda9b3681e07ccebf7128a8b9ce1b4c1001bb3f088ea2035d42b013857789957bbf1aa08fb8482af401a1b5de903e0308e1e3dc28b551a953abe5523fd4e202f5740c6af0b11edb59d200995d363eec446467ccf07528dcf95f519954908cfb356297fbf49366e0d034980614900cb947667f916d94ac953e50c4ce16fa1e23082a9acf2b2a9207cdcd6093dbf09a3c38a63da191948c7329b4a55d11ef4093e4aa641aa2995ed8d04c52deba7b4880bbf445506d5395abdffac16b4096ce4ca31c5bcc3b8954696b94d02f46e511fd1ca022289a1720a8515541322f656060cfbb48fead2cd7252a685f1aadf6961aacd70457b22207b6ff62075ae077ac10f0a16b1e68247a07be201493d26d7f622156f8a7d7e44f26708e74c194fa9356e0ee65f6b3597b8d28627f7a6a22735ff22bf21a35ddb064a888e6fadb707b3daf0e315f542a8a9d9ec558deca47deb6061740d9cfce30b792a342fa36fcda0f37fc6f92b00ca452fa854d886b52975e0db3061beb6d5e8761797032d63350b58484cf03b82ecf40ac27e6cdf3a874dd18a40a977f25dfbcbebdb4e7112006e6c15a0048283cde6a88929f69a2ce561cc19f4c0ea959986027a497df62e7a56ddbeceac12ea74781d64a1c1d339802bdbc3cf469968644182da60642c440db383b6e07f2ef43c3ff41c28c5ef49e5a913eb1eadd4054cfdb2496205854a50422d9541e609db3bf153e2e26c2d526ec5369a2875a2bead72e5b4aa0ba236eb3af135bd5f6bda2d75d6c3c5a907c8977dc1f7722670b093a7903ab51c87864a11e480790ef1b026a878bd6f15b1dfc9e57f64e5188f66c51c2d1e0296d51dd62428aa7bc43fdd1111ddc798bc7a3b6a9998a20c772ea57fe5462d91b37b408e1c40b702fbde41285dec20118d49a8311f9d5a137ac4af56f1dd82b48f0ba270314a284b1879f6ff6f80dd1f46c9438acb773fabd4febf40f00d73d76314f99256f89881ac036c66f68a699d3ad38abd8d3e52b7428811c4541273f21a832fd61091f5711fbab64c6aa5b72e9b8d6364b54d55fd9a38f565aeedba4547c4df011069f4e12e5e07d5a8a5f3b109b354d193b7dff21ec254a2634b1e241e957b580ef76657b477a8938eedf6dd7b2ef8d99544c77f61000bd02e4a3c7740908d3889b81400984217d9f5229c93ab4df246792e7849f5abe4fbf83eb56123238c43b960886234705b523e15ccc29e2b0ae0d9b8c44cda843587d49561dda5deb47b98c0c661e6ea3265ff03e687c414d6141fbf811e3a4f853644640c1bf748bd1b8b02ba093e8237a6ea48563115053f062ea7b9140aa5fc07d344719ea804078b7a694abbe2c0a5aa6815c4819a22b65cb3960e0570af525c8b689c4215ade3b920eccbe5d7ce69495c37243767e9b443fb0827182a3bdf6bfb5db4273991f05819d9b6d9a7337fa2b5abd1fa78e26887c6a04b8325837affb0ce346c43b05417e396b1817ede989e26c803f6dac5f7ff61222a4b75b094c4cf0add2b2b8ef4e7d271df06e4cb81de423efb25fbdb828b704f42e6da6852b0a12376f7801cf977b90731b22ce3e898091eaa680c54bea0ac54199878b7013d7471c78d7f086839c992142cf5af4e7cd19be81dc851f79cf5d4b5b162c07be0698cff62c6341976ca261f2cb09bef64d0aef0847b4539280b5552796f66f3dd37a55950b70632753259d249d052b24014b66bfdeda1103d0f8c4ffc76f7112a943ecc94d6bd5ccdcdc902b15a864fa2d177e48e1253b1a3a68d7c3e15aa9999bdf6f23487e5adffef5cc91d82415cfe73c11df8dd70453e74cddf78d08c02809d15d26c11b8968bf2896d1a0c64d7b3f406a73e449845f665b535fecdcef7f0ca466a19c7d0747caa3420d10eff0b629c356cab3df9d18044049511a91181a41c0fb0439981590ff8992078894434ec18d7a8bd5d5dae28ec93b41f8acf0e7f2bad6e70fa1202ca2f9406a78fe9529c41c02b22bfe8236207302d00b47fd827c3ae687492b259b6687e4220eee881c7fa0d1039a7e8a578b20f89b760f4d31a387db8cc4bdb8162d273f60a492a2dc6cf8a55517fbe0f83ec489dd61690d733a47624952788f75391bb22fd1bc5ad2920c1ce91e85d48d4151392fa09366b663bb49f2bc2640a4f774e39e69cd19ee754827b1497ece3710933fb03cc10e88657dacdbd90e4b48a5b1d3018d56eccc737e0e25bf5fa85fc011f816f4289a3e247e003748dc863c2b3d364028add5cce1bce4407fea381c0e6f3513b1d7061d16999accc8c38b308f4e9cb22a4d28da45caa66e82a9e1974a9f97e79c9751c76a646c7d0ec559c567f90fd994b23c0651c2f6d14a1e9215b1c1aa42db50244fc56035810e989dd0e47157ae9646992824658fbb89972240b2c39e95c1bab94d7ef1cc940f44db35cf9c47eed820d8a7ba1b8211e73831b0cb25b5f4981e75baa550d7948e8f064829b3d3085f55954a40f07055cc4c5eb6fe9029289b5d0c5d1c3f752753d2a70a4614e8c47b8f0711f4847fef185e696bd40710c672c0538d4e3781bbdc64bbe409fb5d533c681eb08acd76597bb28bc8ad768db5711db5e4ecd0b0e055134bbe7d6150c662254576cefb46d11ea96bde133d9f9057a8cd9c19f24f3cf8565f24f7c8244bea1c7b0a93ddcf654bdb2ee47ad12f67d9bcdecb82f895ee0e2ba92710f19642b01f5ad4cdd4622c0e8d138b189e2791eaa6b0209576e9faa691e39ddef967a4bdbf9dcaecd70c628d1c810a8c45331518138836ac64414d40ed6b45084d9b4c73f49588ddff75fb7bce4b33488648f75f5a7c10b033a2e24ac505d31d4ece268a96a93a25e298deff191a85991c4faad2da84b55212726400c32d6f1367f03be5f6e1e3f75464cfcff5a49ff711e17da1ad4b672fc8be875ae7aeb61bd6612ae1c620f05d7a4171dee6935bec38fcb7acc5545d4ecf2d601d650d355bdba4102d7505f6b3c4e243748e26038db4ac9c2e3fa699057abb90148e271f5ab080d58dbde3e872f36050e70865808c98d1ac47fc58710b41da73edf12ea18eb3ea29588023656cce68c6655b1b1538b9a75153bc761362f95037fd9f210bee398f249687165d710fdf952b71e92d068e0378e83a6b5cd0c0e6b8d029b9accca6ae77b0ee7729b81d92e95e1111cf5b6adb4e2c2dbf4177192ace6dc44d0433acd7984953695ca7a33e98a4be848a9d67ee39a7eaad9fb91cb29e5aca6ba948798e6f8a56ee4abe6bcb901a8a189b737be403b7f6dad55691d251aac40d5bbf5c578b19f9bb4b58c84105b751af03d620dee4835f244168e932c938e47ca482668e5ff2d2e1be012e5b8e654e758a28ef91721cffa42de298c07708eab1f82ae3f8250c46bec7721bffc38b0b0ae7ea8453004ad86222d10a40c51a4dd38e868dcebc2768db00b56f5da26d26329b1a6a6e72455ba474159cadd825bf071985dd9e222741a0c266555bd8551d4f3c81911b60a0aaac5426e1eb805ef38214a72c910e6a06d2f077dbae62e9fe05f54e719fded2f7d2d3e3c9d91c147c744373b6d1214b65a485ee8ffa1829832c0770c6a9f4ecc152edcf7d34c8cae5b73bcc466a9ec0aa8139013d501e402032a70f6df3670a841b49a9e26002182cf02dbb5dc665180918a2682a3d97f4725ad753af09c6d8e70e0f70cc1d18cc5571a6c09259d47f7e01fb5cf1b666d1faef54ab45bab29d7ab7bccbb69d2f843e41b3af43e137a58a2225681d1b6e4cab6cd5ff46e2bde6a2059feaeac4332777d9a3ce80e84a328f0c381aa333f0a9a0cdd9acfbf694401dbb144dc53cdda77c7d3a7362b03717b3227ef875c97c79379db8e3b08c350029c04da2e187e5382ef5b54ddbfa6c10a4ba6d7072afcdd3c5533ddbf66e6ada765a76afbe45348ebffb20efde9bcb0e004e83e715a775292868b0528a054ee7d5c427664d35e6b5c041531863768cf0c03dfdc28c46cedacc8b0047df8337e0e7f3c8dbfd5d9f3d8a6b2740169ae878a8dfc0c821ef4d757cc7ca1edc50ad48de8c666774666765805cb20eb334bfde3ef92a4e8685220cf6d5631c805b8f30b1035b751c9393ae8a51f3a429ee9cdf60f104dd5f0bc1fb63b5e278925fc83b96bfe66c43d4456fb4884bed01a8144e71414be5c9203fc531ca79b57229d7912cbf3bccfcecb16c3ba05a1563272f628834c0a852fb3803d6c0900f55c0fd89d895770fe993bac2104c90cace05938facef2f58c46fdebb4b332fe71b66a234fa2e9beaeb7f2c9e35277788f37bd85de75075e0f067d7f3f4f71553c5f8474b33c788d7dabe52578d13c941db122ac790f12787b59d43551e5166dfdb457f2ff8c0d6b3573832d74bdba5f46dd15adcb68f9473d9863b6d01483891b7a8d4edcb35eb627d4e5f7bcdfd12289ff625cdeecec7038d27503bfd2280021243207af4121f9e13e58e031b9f8ecd28d78cdb1bd9e89521df3d86c4e2c42aaa692211541f3402c9cc69099788009ecb13628fc49e90c2680ec61378e3a2ad8423f00c9ffdf2b266c42de79aa855929db12c9cd3712792cd1bddf486b8dda06851f7c5c815d21cc29b29802c26393a5d720a66614801ca16b371509101c9cb7cb0ce69960a07da8c619e372782ffafaab13c8ee8587dcc00ffc2c1bd2dcde5dcaad5b89ac954e5e15c3e052b947130ebc58e4bd7c8fa9c2a7e0af277e326832f9ce5f0a769f950f9bbe7ecb78962e15af76a4c56505553d3fd25a6e8209a88078fb03a4d39c923d18075919bcf25c95dac8073771345efb1576df1cfe878132197e939bd6412d143a96e1f247007af200096631155f23ebdfea029488af9cd11e74d41eee5e6987803d644b053b35397c0e21369c4758a9dd0e7594281ea1b386bceb376951a3673c74d0037a513ad7e29b88e539d552566d00cec9b817732ef27571e3fad321a7471b3b1567525e4b7e3f4c620c90033a69779df122785443a6f1cc56cfe1cdd5a231a2e27066c77ae997f35f6da718987bbcb085fae5d082b5e13d151caaa1e3767a6442e2e287089f4e9c1f4dc97c58899274455e266ea2794c79faeca5795e57f84eec3675d61d4461272bf8bdfbf21a9acf2e29603701dc2eba26e7f30bef9f491efbb124e718bea449268484c0ed9e13bf43e419d9a1eb4b0c8bbd0717d7b3fcc4887c26d2bab873232459da1f573a426cffc3eceb2d754c7870989899dc96889680af6d16abda83d3604b6ffd566ad56dc7a548544f7128e462be9299f52aaa967c89c03f976d36ef774ead3e21f78e4362019da30f965738a9d2cb85190ef4e015ce75505ea48b310cc6e91b5e6fccfdf1f9b58dc74045a8e28405d78017b89e4c2e356ec59b94ea3e23d779dca47adb178100a8a4133e20bda14fdfd65a6dad7aadd0ef8b100fdc07d5a433b81e2d748a950facc8d6dc68e35f3f23b3abc5f5fd839997a4195f748a0ed179b6832df79fbbc06ee91ffc370b157d9e1b1ee00750fe3853ddfbaa8b0f2c99de4be0967b86c05ca1713364131c90dc1a86b6ce4909211e34fa9bf58ecc43a8ac7d9be4c0e54e8fa99dc1d5377f13950f447024b96df6467f1cf0cf1429f1cca48d6d63b74177802abe3ce389c7044ac3ebab859b6b734c9dcbd13869a5dbff953c3175ecaf8c390c055c6f0a4617b55cbf103b8b5d23b6195e995a50418a351f545f98ce3b826860de53deb4da6df2faa60b673363527ff21533a9f1fa408655e3cd68ff4282579ad71a55df96b1d8685d150d3d545cd8d0feb674197f626bf2743bc394461a3719361af26e97a2dfcc34aee50360898ecf2a005fad50650d7dc5ffd1ff4e8be7d69891ab62b36fd35de63f7b6ada13471851df2ce99b3d10caaedd53568f2cd7d2864165011d30b8616b0753bb2cf736bf216749742c2cd5aebe012960b37d9145b19b02b88ee768713ee2eb549c25e0c45d373cd8b1758834d11728babb4d15054ef14152386635e2df387e9b5f5d376970f695d96a33d0411b2280d7a58a164d525f86290124bd22fb32c00b49d39652a2eae19d2960b92f6af75b36e61bc9f8ab55b5e7446a06d71c1866fcc0b797404543269e534651bd4c687a11c89a9c872e8d03271c97b3285c6e143901e008b59c3efe0df7dc370b54c24f1bcaf03e675f39139c546edd71572798afbb4d89f014b92272a8116a61a6db8cb5d66383165ff41aff29b708524e716f7633eee0b96b34fdee9a7480406bf3edfaf81bb8cf78d54db5c097e411aa973dc6a85a0750a81978f70369450a9ed51ea28f70d011b8f86b6b529de326fff759ad613b38c9e26493ab77c977f21faf096ca4df57dc7d4b7aa648d2855b9ad51c61693dcba83386fb00dfdadf87e2f32399344eb3d8042e5f6cfa0b666ea2c5804dff721d059ff4555b2cef7d3e3e7481a41cfaa1e6500f6d1a64f73dd0beccd8f958957b59dd558099e69412718aba7edc736313ef42a5a4c55b7a79873cf4680e01e4dfc8aeea77dcbf613374ff30bc0b0b224d135d3c1844c942146a1f43a8e62bdc359f6ef1c3f333a8d6cc8f99de9e57b1068e6fc712e102740a9f7d913eeeb995c6cc6b825cf6a674fb55be860d14ee6703532829de4b6f48ecdfbcb76ec25c78740f15146b6f41c304998559067fcef0ad9d0752aac2d16259cd9fadfc817d8606f5f8b50b69c3cab0ad03524f29aca7522007c6fb5a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>杂草</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E6%9D%82%E8%8D%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="32680ddb89cdf0ed6f58a901105ae703ecff2a5238aef29bebe46b7f23c1a24a">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e71fed42b0df9ed23ad4b33b2802bcc4e404509a46e3710100332b3a5ee7d0f057487782eec9c5e4497ebd0300c3ad714336ff2034072c862adc48bfa7250841ab9f0be7aceaa01fe78d79802ea3d4e7aa48cbbe9550dc944d005b14f5fdeda3426e294a5a32ee433794b5f64bfc8eef133178186a8ff20afe67f3302eaba3fa5f618dbcff8a1b49be501385c2d308d375339c46ae091fff1f7fb083eb0fc7fc18d5d98d400110cc17af9f1bc9bd46f4137cdf0f455b78e929fe163ac9baa7d9801ad55604c9539628e6294f0c68c08b1b90cce02d1b9636acf461345555b7bd17d821d440db709e1397c7c889eb44dc4a9793aaa1828faadd6cf72f81fab1b09606114ec8e53b1f9f0c03187727cef03f5b97c71d9b0c1d575de7880dd768ec5c5caee4d14328b365883493142298967e1189dcb06cc9d2fe88ac39b2e6a083640efd4e2b91efdb7265cd0d361864c77f7249430f56178e3259afcb463dae5f1857610a13eb911ad3c111b4f0dba0473e51159322dfdc5d0f95acfcbad3bebd9806a5e829dcf2d66d403ac3640c3431d24186c3185b7df7c039eafe85bc6acf79bfc8cfd5f26d637f1cce9cecaf9f903d4f1b48cfcf65917157fb06368d6084a91bee3cb330beadbaab0431af59b6f5a340d8d3f1b285e22ee8b480d34ef4e545c1f1dc473c329051c5317b289e425542610824934565ac0f5c7f795ace79c7dccfd54f7a12a866ccdee36825bf9125bcb3bb1f668d73daaf28fe117f8a57d5be530f6f2f22a9ace5ff2c401fc922180ec3e48effd8113df9f5d2f910afea9a792fa5a9607efb9f5b98559a132b823a2c21d7294a397aaf9dae228927a48b971fb3d1183983a80d758f5975d9bc7158c19ee73051233e3d682f43986d8a2c514eccadfd310ba4dc6577a31226c4d4f5f0d043c171c74f792255359ed76eefda60163e9a607e0c0d8c8987f1fd78b91bab7743cfed5b2a957f7babead6cf38328b2238c17b988eecaec121f78acf0f0f0ac3b73fa3cb24c44d3f1e536851b318b5d894a3c528e8d253db9f0ff45b4e9aebcba0149e3aba22b66aad05ad11ba5988e2da5b8d21319cfd1255675df4656d20f4cd1c3c9bf287d93dc1714a53a2f326027fedacd1bbfcdde78d8aea8df78a80f95929055c2b0276946dca973cdfeaee688118761154b99a25a4a4b329dd553a79ddac7d814cc3d9fc36d686bfb0940a8ebdeedb06efbceceb28e79ec6e807ac5f88854d9b1f5e9ab7b55b650945c03e25eecd93376ea384c5a6a0815e74bda63cbb5f96f1b787e9bd608b9047a845ac2e9ffd7582222c57fc4b42babc087bed40bf0531b0719dc61edc8ac525a373b7737df477908717ca3e8728016841aa1e58e949dd3e389a9237d81ad3cae34cd4da42d8ca2cdb44e10a871e2607e80d3faad753fdb0c7babb850600ca59b03df68d6d7c48cbe744697c0e6083e062c8774c405461b82b78205e4c8eb25e4399da384bad678130513cb3764fc3c0de03495213a6120c44cc78c5af5e156697d964cd2497d708eb1ddf7edc215c1e6d8f00eb57ceae1637f94992250ece6d8469017111458bebc94d8f500c14452d0056c5a4cc7999352871a0893de672699f458e8fe96a7e896a98a6ec7f8403be9e969deb38164a170efedcb9e59c867e9aab1c72646bf21d4a6e6888c266777e3dc2d5d229f1bd75d3b333179a0250445aaeedf88aad38f258a6749d234a63dc1bc1d2fea595ca77eec30bfa05d65369e65e101648ac09f2290fa2808616f1cb1e246c72a5359c8bdbb417fffc9d69e53f932346df86824f16f7c8d08e0df1bf4efaea2a04558b9c902dc9d8d7537d19f645f0d0dfd5e1160bd404cd5224e8667502ccb5ea397ce5b8a9bb3a5da670f511f45e41da589426c760216591eddc423626df9442902dab28c691e107cd2ec8f21e4d24574054f601502611a28313bf53de3d39cfdfc938bfbfb4a3ba27bf421ce2fee948a7fc697c0dead4b5ddd99461b63e0b08bbe2d43b2613f55aad05b335b2b6a023d0f0f3d9a2898695f1981b3165d9627730e2220936bd606c49a0bea42a5747ad17592436e2d778d6c812450858203604ac5001023adf5bfece737ec23c898300eefdbc42f6a6cb62d466eb45f55c6c52bf702d4a82e68d7e1361864f5011988a5f2c281b1447f31e76faf62b9c0feeea8bf7ae073e9d3093725f62d9a1108c632d502d759382f4205e46e37f872cc4e99f0279823741544163e49ddd49ed8ef171f101e1b40aa13543cb1fc94794336b1b8a83c77baaf411d5e4b292aa45c65038500081a3d35910e0f823c1c3c2c4e5ac8329edb58f6a6063dc602fcca05bbd3b7bf47a24050e7132fe22ae5b6f66959aaac47d18e8fcc3c813b61f3cf088f1a1a9bcec0a1fd90616071eff222406cb450767f0320761268a3518614c013dcc0abfc99e63a50355f796840cb1bf7af7a614fa33064ebcba8ff74caa0ab0713dd01f126a17fbf5f4df3be05087679e93cfe4f125a79156461a3cc101c2e641b12f3dce755fe96ee96a03bcfccff845359c2d02ee0cc6a65c277545f482d83fa41293e47495e80dc873fed5ff0b67fe23afb0ece6924daa6ab783d53b4c970b64e5a13e60a38e903b51dde4a9bbd95ee1703b30004b888b0032568a07fee01ceb41256f669f2e6f3688b565bb4af1dbf25d703fd076488eb7b18c63557c1e0ddfaebbf850ad3f4fd823954edbe1ac4a92dd0d09127049fba1cc121f6c28b4c49e4dafe92d53a4e5b26ae8418421e192b18b9fba96a7d0075e2f075ed1c462dd5922dbf7fe86eba3907af7da5c6874a4abf9f43458896d598f14dd6abfd6636fae0d68b45fbaeecd016b8c6c316ce18da45cdc727699097c6188326c3a453f204616d792b5a51e11b2bd7e204cb64738d7140c687ff7fae5c4b026909f270ca72ad6143abd84130d85ee1246b0ae5a15ae733440025cde8673fb38d06fedf6aa54e02c4d4841d342a2f1a99bb53972b8ccd3e87ddaf3c2be5781f011cf9aa71966394fa1cbeef8d19081bd65ed2c098cc3da7487d86dba46ecb48b1a3a0247dd04fc847356dc265dbbfbff47dac13b870decbf60158b7d7ffb53b6d70737c0013b1bf3d2143d18a21de4a13883efd4f439f1204b290088edc9c3cca8061b351140e7330abc5715e65f4d6d1a0eed5a8027e56391fe79fb9d808cf6277f676befb84f80a98fb0663ef35e83e30bd6a01d193e3c488a7195cf21f2a635592e8fbfb2e7742e8473d6cf040eafdccf38fa04977cfc195f441ab4f26eef3a82245f7afba268614f8817fc20426a5394848a9e214ae34ae7fa6b6bae9f0500d927e5ff41e0f10fa0546d2fa293f4e7c5382da430d0a41129dfaaac29d6fd57c00d5b98311e109a63193d6a369773feeac8db09cbc95b0cdfc2dda6ee24981713085986bef72c6c9a5b6b557624bfc0d87c8598f286d42f37766e8568d1661019f9cfe43df5777064658c553b08676a64de474250682b8bc9d8112e84c8b00e574d813f05260f1b66d01dc08a9bffd80a6b5a8a1149ccdfea1b2e98d071f35dcce4bf8936ad7f9827d43fc7e9d9133ac3b5a8fdcf2020c36253904bf785cf84e6d38175a15def3e6f622dd4d315406a5523fbe6add3ad1eefd3a099d47dea31c196902e1e1979e95a5a82187d1f5ba2addb5e82bb18fe90b60bfdc8340b8416fbcc5f621fdeeddcf65bba60c70abdb8e08f21e16ced7d7961fcd04604ec57f55cadbd80b0af17885772de85d88cba380cfb28bfc443af490a35763a5c7fbfebcb5e1a6e05bf506a6ae8547d6b9d76e0b078b172fc96d889107a0ae4c6e5c644be86a0ef7f987c873ecf477a2a7ff9a576e4b8927d39da357841708dcaf883c1e80e373414d6dea54d2fa840b04cbcde49e42792d24877d7181e6a60a5594596cebcd4e21bc8238937c6cbe8306ae3c735fdc233d6894409109b064efdd4b52cf6a772c607a9af95e25f57eb63f4d198679b0d55b465bdf68782d55aa0f30953e1a6cb2095c1bd86b9399ee68f6b16a4df29718c8a72e9192d0cae4a74583a5e5858d30c8f4119ee9531f397e8b3c174520270d648fa2594282be4f3fc084d98704198834d075912db0172a8f836c3f56eb34e4ea7e6daadfc26de1dbc2036fff9100bd0fbb8198ba7c39e33feb1755efec4f395644a1c1d444733f3ae7518d0e2a34ad39aa04bd1d79ca5956edf0f4cd077b9105933611cdb448d96d91c4775c4a659aaa0798c3e623611196b47e7130800be08d86a6495bd555a385ab9a5d70517fb12e19620a5b0d1a10f9bc4096ca7844169da1f495a911fc5c5bdb7e5e4f40f955ed2379f09bb96f399f61505764869baaeafd72a3a7ab37f5e948be86307f51d257d20a01f02e6bd32f6c7c6ebee489dafa3129c02557bca2ca4120dba4d651c55acc85a71e24db72f99e274c501529717e1584a4037fbb420cda042e7c07b1cc81546580736850ca8d6b97238139a6c1f7c0f2aa5d569d95bbf290d6baf0274d4bbb6197c9b63c9119796e8b8717f6698148b24d17eec163fa54282ae295f631aad9b6570a1fb63983ca7fdfedfd3aa697648059b65326318f8841fdad1fdfb5248a20262587f525c1588b36075ec5461fde3f40f39868b2e65e58fc9d3a8d99611ba3ad844a0b524a26b5fc4fdbe0de80558a473c0688e40947c85831b362070afc921990f9e9182c63a2e058f14ef68b45637bd04d4d142c3a40b26e964b612a919210ee093ff324b7f8d76008545b6688282299e54834cdd7221d7ce1c743e4bb4c26ec9282e6d2ed791776aef7333e1e54e74253eac59a43f4638ba80090044404a164063fd336d8fdbccbc01afd9f848c163eba339c5fcaa5b4ad951978903d5ababd4230645194449fb57e628231920584c1f840750dbcfc3ca8842ac3b58eeac77a39ab164ad13c61a585802fdc2016748c42a9cc1ce155c06193c879c44df008f420f6da5174727f333430796afa06bc5402a19e796de9ff9022d1ea339632398dbf300cf0bd6a2d473f85275fe1203781bbb2f2cad4a8a86721be42f1c3fa8916924518a4c72c8b77aeb9a583fd4ffc207b1058bb2b09e1407a6b4c59660baf137d4740de4bc9da8db5ffc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>晨星</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E6%99%A8%E6%98%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6aa66320912df8f69590b3255743e44aff585b8302b2f851b084c7b30c5e49e0">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7a10fa805641d4262fb1cf09ee0612fdcdd260e2cb7c25c1aff38d3a0df18ec3542cc57bb12e518ead368370b21c48538564d477af3d56b85788a3d292aa3876ca3b4ffb0f8475546e93e659d722f0acd5b117d98a5fa34e7f9de42a511280769d43cecb21fcdf14902feba38baf9383da1c8bd3a697518e9efc2e56f11520d4f44417c45f003b7aff15d6d31f141e777d32f0b3169e48c04c6963277b43e2dcef9b05cf44a0b2d262f55e68088d99b6f1f12eab4799062e5437b51657c28ecc481bb4da9a67a6bfc5ae989d0ff6b5f3bb5d681233d005fb1e120f002b30caab0c8c6c3b3e213836ac8238ce9b48d08aef</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>太阳底下</title>
    <url>/2024/10/20/%E9%9A%8F%E7%AC%94-%E5%A4%AA%E9%98%B3%E5%BA%95%E4%B8%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3ee9726701113cc152050d36ef0aac46aa949e3ba9d2923e4d8a60e6f779f557">5693bd7afa5d3e49f82a8e62c99da97af8196ee93205dfc5a9fb864cd107b062</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E6%A0%91/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1e644dda660132dd21a829a334548ad7286da2e440a437ef11ab966d927f826d">adba944712a73720e1f31df1fce53744781829ffe1ffdcf999dd5594318dfdd1277daf2d87af54cbf9d35bf3633a95e660aa5acd229161a04323f89ffdf6e82157b6cccf07b2a5ad04794b468526e8f7e83f8783c45e7d1f99a86554000cf387f97bebdc8205c70248b5e86cac598cde79d067b16cc83f6580c49a68089527548053dfe201ff5c9d4e2a07190fa1de5b919a82bce4357874f265d51aff726bf5375c03dc70cf4b94532a31c495f665c751236e0604cd11b66771f2c285cefb11d56545c5eda46d4ff067e4935b084b1787537cff2f85349809b48024edd72e2ed8f421b3afc326199eac38b1ef739e0596757afde53ce1a2e7edc780e3dcdd60a422683eac4d9d533767477887618fa32d3d5b152cb3fa562a8ffbc42e06c6ceb333b2de81fe2b832ad1fcf15500d611ac5499ec97be9089225618db6d9e4824020ebcedaebff7c5abede77b35906a1fd302faa19dc4d302bfcc2bcd8526f2e9cdebff0c66af057145e6b99491b036293d7adf932056e00e24a7eb5254df8638d1fb958de50ba78fdc4067c047e344f88d3d2eeb06c0341e073524b9c24e1d573637853e50e2ade0b87dd96b6ccf90ca6591e4941776bcb1e1cc07e56f89e827ad27f522edf09eaf55aa6f8477c01c1c70d4d43cdfa2ac7444ec5fe43000440e8c4d01695c43de56feed7caf9cb5e032505524d2f5e0e4d0af5dddcd111a065fc233d2d085e1ae895e010c97cd5f2650f8e4bb1311e906fcf4d3d21a514259a5e1bfb9480a6dcbf488eff8c57e5e9f3d72abbc831b93a5c46084d9aba1146fe66a00cce06fa7c9c0801e3be24cb6236aab7a94e019770e2f5feef87f42b19139808b3effcb808b347fb878bbb220682e8863dee93fde98b384cc6cf9af9b86fa5b59659f7eb093d8b20e989a69b10ebd81f2b09392cdbc9e94d7078ff36f9ee858756c4f8bf16a1f47540d565a3fa615f9221e531d4a8838456f03150fe6c80951df9a901b74bb8e191f174d2424163a8301855c18f119579093df696135e72cac992879c522400aeca4185bccb9f0ca4bea6183c412be4ff30dd75f688319500dba498cc4c9a74ca863bc74161f8b23f4496e3ef036a3297546d153052c692dec42e6d31ae9acaae595c871ea3198b763f43fb5151a01eaa3483a0792a364fe771897e0ab00b874cca95cd1a7368eaa1e2067b457bb15de048efe92c827b8ffc1f83794b1800d4133e5917d1d35322127f78947f549aae8ea4c7d4922235df2fe7ec0785b686c5f866312a69406e005ff2c8f834d9c346038bb92609e249f86113d5218c76af1a424305ebc463f8e8411ef4693e15df2b079f361281bdb468b763da233ce50346ebfd0c21cf737230cb5137efbb1f2294e2c5d63762b60917d4fe415683875bf147c028f09913df3eb706c77682b9137f3c13c04a46cba2afdc98e288d71b880f4c15f89899cda9435b215a445e70f026e42f608ec836b7ce246c76b5dd050ef64538b45af7f9aa8b0cfcc553676401fa59f0209ea4a48f759889fdc5a3d773abc266f6fad7d5e217a57454710f80c8c8fb41df2eb4996cf9e5ea6794a33fc9f5ea779f9b9dc3edbb67dfb8d509eb2c3dc77562c09431614b1e0732b86d43318960ad5b16c3eb8cf92560d6ffeae6a06549bdf7f4239facd4829879ce0d60f0f97bfcb2f513f3e9fc7bd7533bc237d2aa805c344e8a0aab376291d35838777ae36100c3c80e335049c3b551394c88b3a5833b33f1a59914ff09b28a64d5b3876cc12d50aecc3a08e2440bdb3136c0ba702c490f43ec4fcd2e056bd83a1067693e37738ecc4202f5d8e14f36be0214e88749d5d4c79332f10426d6b3336482834472269182c0fc7e13e9c14188f6b8e051c11cc9255fd192b6413e891f0236e83290d7892b472ab77da0e5bf81cb1bf3ff4edaed27bb1a923956ab9655ee87e305537464ae893288f9be33c1d13ecf76c8213c1b748a2e766e62b33f1e419f0e5ba0bc40530e309affa676e0a6e738c55a9851b040380603e0f6f617ba1ac7926542bf349ec46d75af18faf1ecf0063ad183aca71a465c6bdc5a544fcd74996ded260b6ba3c01aff743e6a9a01af29c74cf0b2837529a81e4cf42f889a6af90a3b25baa99cf079613b3bc1027c24c61de466b955da038ca530b4f7a3d0cc33457674e591390bcb82b1570236d3bdd2735f523489dbe75b91ec374b384da786fc11bb4eea7129e1cd7c6cef51fdbda53fa0b23273fbf1c261538e1a32c5cf590c6b7e725da96523774cce463633e8d46f41f45e278f9f2736150c6047ddaf1c79605dd92a602da4a2b0997168ddd8ad8ea6191d1d836cd1103e8ba5019524d713eb23e484593860254750b7a680c4060b9758a6e7e48ae0c6f50e475c334bd407a9a321097a995c1a8bb504b2f5a17cc9f706227864c72a2e8d65c45894069658feea59652072ee86041885bd4f277f0e73bfe05bd9b16f2722e997b168c22de5ca8db6fc76bdad89900cc3eea8205c9a6e3c5fe30bcd98d13be20fc4295a19ef7f1cc9e80980687a9cc2204d81c2793416401166b9f096cbf1f5eb328da3f78f560dbdf0329bfd9192631345aa8005aeabc900b2b42c039c7bedb1a64e4f93ae3c7fd626b1442f1a8ff8ddeb1150cd9e12aef97e9d454665cc03ec897ef8a5cc8248fc99ecb11aa84f0763cd162e78d21444b31c3fb2c88270eb2ffc876f6d58f26061d3b37b10246ed44f69b7a5d8cbc4c5b95f86c0d3037fbd626ae7138282bf5221ad3c762e25d97918b880667404b82b83f9313c9b2e6bcf7f4cb268f5c9904342c97003274b5c21ca43f99cc0057688d3acfdeeafc39598459df5526655fc28e5e70a9af4d3addb11652b51f2afbe6942992b3a5048bf03db1185d37c8353f2b3593a93768893d12d335c601631316b79876344cab649b864996a1bee05e901112861ee35fc3bb7a68e5a93c4bd97a2b32e4d0637a05c190d489a62bfab545bd6419abc10ef1653704f1234fa74653e39472d4ddd3d7752eacd9fa4c99e267cb0422648ab06e12eb9bf42d52d84235c50aa2007f02f977a6e60f64951138ea0d9a6d9338c096bf3137254cf47056163615564721d44c174c8fc7b535787905e7803b223c417809808ad8160a7cbf380ef235471b306902f878096ef01fdff6a032d4a6984cf705937688dbf83e371e50ad72f5a6ec1cb94a025941e11b877effc033af0413705fed53e20d0c17772606e1b13bbf7bdf307f69a1a29f9bf34c5c08ff1733fa79a78c1d34bf3372f236a0b69827c2d2d07cd9eaa09f4bfd85041297a4af420e3c3db71acdc0b7f019b923d6a307f091333adfd541ed460f07013bdd362c7f78e0e9d16237b6a9a3a78955ceb43c84fbcc10a572e0b5279f0a28bf5d92bdb8d896b86854a6d1ecf8a5153bdc70e06e44f14f7b6291a62cd48a8639c20aca053457d5fe60b98650c3e82dd611828ad13eac195e275aae6d179522af32f29966df448a4e21bee6ae593a145175555ccc9889edb42f2a4c4b39c4dcef29eebb07a46bc78753cc7f2c944afca608eed5ee9c8578970bbc4e104a5211e0ebad7acebef0cd87474fe9e04d27b4cc5c7b9b34b99a78e1197416c0bdbc5e7a07d9594c3abc40baf603c0086f068c42d2d3bf15dfc569d5933e1e5906e14178068bfd2c2bd2a2b8c791d730ac348a100484d97b3159b373b5b4c58be4fe49e3381cc5efaa6104bfae327c102628862be887cb5ed5f3fc33f74087f3e95aa33fcf4f0c7c70d29180fd6a44323ccaddbe26b1cae56ea67b0b369f245337170217988e78569e8688d790137f263c584a8a0a77603da19975be5d468aaf6167eee809c5aa7f5670a91c52b25af4e1c3ff80b8fe60ec1c246185ece29bcafeef59cf6121b908ea7db1047961bdbde118f540dad6ce32e349f3ec98a8153eb8d4c95d3b34828ce4e9dd5a55c3194a1fc2473570ddba5f7521b82622d6f682257f5239f799f9376e638aeb142afea2efeece6f3b8e8c1dec1cc5da2e567de4c1c0012a8d222c53f23ca7193476886d562cd8aa13fdc77c72e4c858c3481f5a11d8bf584126ef78a7f16f08e54cfce638c7947d5a340b9feca79df0c700b5662b3b7c1a2559c3479b813ff02bb8b574179f064bef46798520a87471831df7a3f2755429f38a03fc566462649548d6c6f5c17a3192bb702592e9eb44e179bfd4cd4b8e81ec41a6e0f8a1ac180d5831961d7c52345bda0e4f7fac8b288646fb67860c3fcca2dd8649f23c32d13ed60c9e9f6bbfc8121075962237c8308ebb8872afa3b2a26d763a9f4360693c13ca9e956e46f9b68febad849e7514b452a4347aa7d971937113b0c51800c3f74b0b6cb7b0ed5f963174d0b3b4c27831d7de25e132fac18b0e7e07846aee38e57d6907d4629f7a2062e726c9420c9e40564a40c5d5bae850e1a53eccdfad1224a2de2bf8bb7f2edcb083a8823642827ed2dd556d2f60b81d56eb342fd8ea9e06948519ad3f30f3e04d7dca69386c953a0d0f29374e41b48017db21824af800b8fb77dfe04b1455991f723090d6bcf0983e09336f7f1f2bdddeb6fa3bbe49c88ef36ea7db518bafb241c9f3e44be422f9a44e7e5303d3b224f92a123660c6930c9feedfb4d344579aa81f576a690f1840afe6ce447b4394079f9f9b15ce825d8079011dfb74181a864e326649a257da69b248248edfdfbf4d9860a2524420d5368b05d22c5b3c46327b0d3f69df8b4f148ecf0532a9bce54325e429c38fc5e205eb916f7fe08a9142518107c9197833e7acc3bd7b96bc6b63496f1924784b050b8f9b71507d42c641aefe1f93824e556c4baff277a998850fb07bfb4ee844637bbdb599854a9e251266503370be7aab5eecb2e3ea47b8e0fbb0bdaba3668c252d740e654c35142b4d7e96b89d26e8beea9139b8b788fb933aee524da0dc01d3001e95d0afdd47a7f730bcdfc740a426590c0a9ec5cc5ac57dfceec0c01c192be5f66dec35f7c0f71530028fc7b2881691d7cf51e125ec9be7b77616b78bdb9bacb35deca2d3e4fe814b3e4b6953654ccfdb3ad15cb3f4ee097cb0e1116a0faa2772ce27fca30835b3950931a00dbe722d11b253283af954ae19b8470c304bd2afa9e0cc8b36b5aca1525f193e90b86a07cce5069c8ca06a26d906651f91401c3619a9200268288f563053655c57219144ce8c5d7d44e323e51391ad4e57c3e6da4c0ad687965a914416f187b4ca8d8caed1df6d11558661346887c96ed25521ba2812a1deeaf552eeace9a642277affae33cabf7f0e14a6bcc2150628cdade67cfcd91deccb04e3d0d26424e5cab6f97bf3e211ad7620de4c0452a35ed703dae414baef07adb11293c2c9e4f033fedf4c0eb23efc54f3a627540dcc358db40ffbd477907fe29155fc18e445d6077f0ab23c32d2a88ed4ceeeec1d939173791ad560868daee59c8bcd14fb93e11330008eca349f8d2b3ea393a7fe81e41ae482101ebec8e7f1dc3ee6fccf50bcea678971238b99e7efe0241ca38aba04538f7e8411dcaaea3cce6cc5f1628ea4ad41cece5b681aedf079da9c355a084480040dd3a438a80bfc2069d68043510231c10d4d7e3c75f9499c6059ddbbf056ff98fd0ce93509358f33dc9be6d490752fd714b9068a0aa436a915e4d967da37885b805493c9ea9bd6171b5afcaf93d09a6a24bb5c726c1f115262e0e597572d8324388c3a77b7b057caa907c103055125796709eda9f864ce92a52f80b5a68d3b04a6abce298f44f70c9fd20cb0603c1b98f307e307efe111144332d5238ada7bd395a3742ae831ae770f7675097f570dfddc1206b37eee70b20f84548b56f26ebc3663205853fcef80001abf0e2826d5942cb7f3f32b5ff026f125402effa90b36fb5d3dc22206bc07f4352adb3d8c97c305d435cca69368e7029f0f13065880652de7211fc121c4e43fc0b9c11b4bb596819ebafa0a038c8cd00d1f0558e2d29461aa096e2fafc484ad359077533245e75a870ea06e9f461e6d3001e19cdc9c31978b41a4942b557b21356d3e1c1a43d30cc4667502746df9184b97af8e30e7ac832fc9c0318c2b13d4fd3dd37d52ffaa2d6c59c8f0a775378c04b7db576f1979b8a860d160b5c51590b3ee08da57ccc1bca502ac59f8450194b2ac134bd285db50e6098e58bafd9b2ab11d5409c17e07164f54c12f92ac346c9e9112688d53ed6d1cb58fc547b7cec8de812166cc54d31a360099c887b08156bcec55a882829f9a834d4b3f2c201a3c378ea3cfa7885b94ae7a42888dd728e10e7f952a29d088933e0c35f555ccc8269f79fcf6a49a1ac1aa7c6b0972cd0720561954612fb8846f4a7d9239418030babb797aa49b2ae2a338fd5a44ec847ad9d8d32d98a8af3b50c5d17b54a0535368f6e5f8a8b82694f9824571a4f179f0a91b91dcbf1eb8e5cde9611593e28c86338224ea2c4c5ddc08acc11cc20994bf2e17aa4ec150e7ed1e29d1ebc91efb2dff9077ffe13298c1944c785a1ab7b6865b5aef5d64e9475430760206c45f6de57f56a6277ddb0e30da66e930ea4751c27ec9048f78d1a97b809c7ddddfe32c96a4e478a42d8243c32116ba0e05d978a8a633848316e0f9aed7c0e7cd8ead90969fe27e340425bb1156d75cb61553fd9f8ee88ba9eac67aeddbbe91df60a3dbcb966734fb3a80c030cab7365a2634a545486e8040dac07deb64b07bebb0f2b8b352182ee231c634997f338072ccf46309872898efb608f834d26a62b61c97d6fc0199222ee62157ae80e4f573abad178619795bbf8360619d03131692daa59756eb03951cb60c2e6eb268054a1c55b83b3c88de2bd82c7d24aa310922c50206cedd9a6002a2bffe991f8547bce4eb4564e10a94c9bb115e21ddac444b1095687cc807b3e08d34d3f7ff64e0e93681f8388974bb6f8787ba3771c0549b0beb359662fe165e8a7a2762611dd0b927c924639569b185fb3f1af88f95a5c02f4c522a154ac4210fb49f0499893f8a13040a67b90ceb42e186e859c23aa9ab9ee30aae2a62d2389927eb8e834bea29944e4201d1d78d3e9ef7d483f140e334e172359bcc4a64d1aecb58d3c306fe2aad1087d137ec2beba1ff46991f644238dfc133d3324c4dc4f3d5d46e869e1dfe1c88c8ee4b84b7a1d20b756391893a4f32dd959932010d306fb86d6b8df2b12b96ff3ed61ee2e3fa7b9f497e910b6ff04b41bb3341c0559de03cc29e77daa164cb03a200a6d429594b9144f839feb722e102248bbb9431a1bd0c1415b81d499bb25915af0b0028c4d6bc4a2c84c705ee31d3109d29631bfa19a09e1a22baa6bc4d7b9ba3e02b824cd2c9afe1023adf437009137ce2db3b550855f2bd2f43a1621615a1247aaf0813c6b45dbdc304c4a6265a8e0a20d440258a1ba49825296188fbe390e5d2112f96172914f17bbaabfcff03686b185fd68324c929bb8b5503328496a09e653d205ade05f1dd236f8e76c7f9dfc27c166c6f57175795e2fb508a7ad30c287e2bcd2c8cf1e5fa6f3a585c8aa015e563e1aac3f5a75652b1a6ba4bf5d2659f408078eb58d218f6c6f8a1c50f93daa6a3c5c24383bfd656a5a97be4243038a8ac540518a077bcd852885bffd9dfbaf524b22443abee37726665b4822ab903bd5414467a597fbc7cb8c34c96c32046829b85dbae4b09daf597caea904cd7d237202d52e4163ab14da2a100886bbe672aa135889819123d59e2570bbadbf997d341667fa2310de8fe415bd7659da99bff2da9132258d8c138fbd999d1b64f3fb6452fd5862941fd3c0414479973e1a62199b5c89d31cd9af1e4a4761741df4e27ecf806a0097080e3546291da7b42e5449a6b1d432d71261a74ab5d7c83bb1c6ffe65b3f3c05e56848e7b5aadec6d1eab2a69640af8b197e9a8171f7d30392aea8874743232c1734b6ef430a15003836f630ec177149f10e9497e6c7347c273dff77bab9ec58a60ed671e725f49029988ed722833082a067d31199546fbce9108efcb2dc0cc4f7c194a6859fcad39765340f25b0e4702c2c46312b9ac5d00166381f50fabacd8e4a782e219d9cda85a4980167c43fe921c19b84ede82f4a77895b124b81e39b57faa59049e3ed5c5db91b14025afd18836041ed054f08a623f3a315dbe98948ad1b575b93fcd9b684dd67a6c0509b3c87e2924de33a561cf55cbdbaa485cf6781cec0af66701c926178271d34ef9f4e067f33e3c4900861e2c5c7d16931b2b1ffb816956d7c7fd22d33aaaf40ff10914c41b3d5fabd97ba218488338ebdcd7ad032b19deaa92a5eff22819b34a526c4248cb42bb4ed655176385fdca79ea22654b43080eb98e13e89aa4d28e4a24b70abef45be1e8411abbb53b05f49e8527e7c3dedf30e84d9127eaa43d924578a628cfc4fe318d911c510183583419ddbf4e5df878587f986e98d3d1978454609c18737d7aa0a3bb0fc18f1b9b24508fae64b0a44b951b84b09df820d2b4ac23f37cdfd653ecb4e27c571c124bec75cd5d1364064ca358b1e1a580aba7ffaa96b5df28cfb9a8e3f40a58afd96ecc02e683010e90545b8b6681fd28811c4527b4fbd79bb2d1c405187d49e29a81ebc5fdba96b78179aba18e88dfe168371d2d980e0c74b0ddd9a8c8881182ca498489170264e348a033f199de391c6f753cbedc1c438d26adf16b77b4863bcad63730db5080516470b6c9e52732f20aaf5abfed1b8d305fddf8b38e89984d14d834d56b91f0a2807108f6ff98fd1f7596a7042eb168b6762a4642e9aa8bbd422f7f9b6bc927a8b42ca283a23aa35ad1cb684786dbdb97c95d613c10e762913ae6f5001dd8819f7aeee1a3323309a5eb32c88309025b5072bef95a71553f9739e8b75c1cb6c0f7dff344611644801413a963ffd9fbd5a3c6d9ee46c265c119519ccbbab5dc8f9543fcdd90d1389a346e97c4d6d28bf4ec9ba9b082d98bd241299f4e2896ea202a8d83839680e28baf43919af2892df75977c73381a6fb49edb520cb99f3abd66f8c7a3c90ca79a6362755ef4d4c0cd5d2ee0da09c3bd4686cb129c5d909e224397b77d860c78b867cc04e247f8d6f04a0401dc4552bd17d100b3d1f8e57afa228de5e7581f62bc4d4a415c522841fa07214bcad04cdf78e0c0cb1c34f4c10bd1c54307092624cd2e15d7f9a17506413308070b914e4926d35d47d5d0b11a2682426a260b7040f5283221d3f7ac3e57de9abc52998b75fde75f74b033a5a700cef168d934fc821c621e8401eac32172658b29aab7cee0a6f84d4660093c23bdc01ff38cbff085dfc19657d769bb0a1a2f5a8a9e15944fea493413c7fea5ff27ea1be2e791e044b272abc0fbb44229b659c19f0baebac485b156bcd66737f130b5ab0d8b133206027c718e6c9c9262c007aab2d2a0db1e5c8fe735dc7146c49d2a1ec0bebfe82c2c2c56cbfd5704fdb2010b6b00bbf49f9964bad7b431889adb5ca0e9ab4c4ee420de80a56629ffcf3d328a722f4914c39a998e7c82bef45f23315d2325e6513a7e3d4af674ad2480f7cd72dff3b333e98986e7077b11827d7c20f43fa438157c5daeb3125b070ebae248817ed07e9680d16023bc33b112e5a3ebfa1a2897e43741da43c49f5365cc5b3cfc84bdf4638949329486c4a78073d912ba90c04ccf091ddb8b6eac24866ac4a858cfde40fbc2cb05a1b766d45d19952cf8e5e2897c0d214fea87391496693adae80bababc1d32b1258dc1baf82e74e17367cba20db3309e5cd64ecee4ba025422e2cd94f8e1e077f389506303aed4a105298ce18587461ad2fe2e482468f0ea61768d8f0c22c27ea079bd2d2a764bceb5b859959d0853bcbbc9213a08222db6103ecbb4656c55f79bb149fc81ee0cf0ab37011b31d879ddfdb60c7e6bca72b09e43472778992c324a7c9a3310a16700105934232c7506de54ea90aa8f1ccf7f45e9c38bab3da607080d937a2fa95dec6ff2329a823fd0ef864fb1f182f6959b23532365172a5584add26c8eb21152b97a99224f41c75eee6eec8108a1fa7e3132e951a3ec691c8d5f525468a0359bf95b4a5641e8e39b0b76ed77ab9eb2fcac2a5df992537f6e91ce6eaf39271e8f1eac011f04edc7913c558a353141a03a2405738ddcfd6c9950f49fb09266f5f5292b6769ccd52f9043f73783dca8ed28edec064ed6f00db67ea120b3d97af84f410d52209916d30d79eaebcb9bed6bdd9ee35835ae19d9786d8d1d8aa998ac6cae77dc8cb554ee368f93fc51d930f7d22b90b67dc83fbf64151be612f0266c744c8ef73ca7dd29713f49d925a0c646021870b5f20322e669ab87d4873df2f0badb548307ca29d3829d10ef0059673f2fc14177615ef5568b215c1c880a3e399b171b85f95c295d299c1b1323387813606dfe290227515e842b591dba75e238834adbbac94d977cce75b55d8aa481a736629cdcf58adcae2cbbb1aeed897170b6c8abee6074b1eb6e031720df9503b8342c01ff28083d24a5c1d0fc68ba42d4acf96d5340fa78527c602d923201d9a3dfd9101e36e7b890da140f56a58b3987ab3802f2755b742cd04642e5b19d82ca4bab62df3e4d0ceeedc6f5cef624a9097f332af0b4af6b212bda4513e2353dbdca457c58e15f463554a44bdaaed1216d9da328c6f9fc0ed2ba4b30c2c64594b9f818778cd0f42671afa43ddf9e2e18c1df1e649bd7dae8a7bab432cfd0de667f97eeb4686b0b9ce0d32c4aa56fbb98aa7810b7647c0b9b42a48106940cc2333fa04f7ae6f4fb47646eef141dc456f9ce4270d9178b5132a53f7527ae7a1234c234594314a4819babecf0d2edc05fc7b3df959d8dbd21fc4d3649ed904aa1f9c9f4af905803136dda61a46837d63aabac133a4abc1854ec3d6b84cecefcb86288d5e4ef7dbc5c252e5035cacca12a47aaa14cc681d95863942437c255965dc4749a2e01a4cc884e88db517326b4c10d608fe6881821f907d256506993499c7b2dbf5aa353b236972e499441d8d7c2eb9a196f3ac161648375555d0731425a7c8848ad25e8862f98f921cd7b7c51e86b20603be73d033ff7957182c74dea31f0e156890290a787f9c2e256e3247cf39ab11bfc09c3903062b10f5b247d820dd6d681967c92c708503c3bc02e71dbba9d6b29d18554550831707c19d5e9097de0e527ff8e4815719cea95681532d5fe55cbbc2b631060a8ee2586ac18d1a760e6d2061942251f2cf01093ed9a09030b01a428d9d6886a1932941d628cb4dedc278c228e5173bec8978c064eb929e9643395b05481b6232c27cbddf2c51aa0db1d5cfe72f22fa43165dd9b0bf5c1fad9511e7b26f07f825860a83b69161ffaa97365fd0cc374b6581e77eb066f05a355c84dc7ef5bba47d6d8af68146ca4fbead7b3cb95b2621eff50c870d5370071631d82973a60822e252b9029dc67321a3393a4a1ae7d3637cbcc2083abb93a394dfd6c549928285f1545420e64d088214a1b2ff34b6ea87cc5180f163753da4fbde486710b1420bd73c02db7d730a20acc52f88e429eeaab9f6ba730af1d35948c90b8534e1fc9796c03314bc85489ed8bec4d69a2d2011bb77e0f2d9282d2e5e8c9617bd948903366065530c017b77570c7aa548a9f6d189624e2a1691b2848a2171d7fd2ee681c131c0afedb14b061bac0cdd16a599887f08fe07af9a0affe53838e585c58cc80dcbbc19a77e1e0704724d0acffcded8e79d9da1063816d56b9869fbda23060186dce66420f3d62f7e8697d94934d4203b2f510c2992a324f19ffb21c7f22517dafa37839349d9c94738a31f8502fb5b7b5eb60ea4d575808a9e8fb137715246594ea975cbdf6228c7681422fbda393a4f1ac7f6ab5a2702c4954fed7c251c159cb5166b013de75a0cf1058f4ac1f6d49f642299475105c90d36a7901eb91c584a8d380e9ca4de6a1625ed086032a0360b07bf3ded8a84805e2a6db84ad52b660070a11fc4acb8e6edeac42c782be07da01ea36485ad423f4d39da8e410b6897c7e66c1d24ccc9698ac729d69d013e42f7aa363ae1b5230f05cff002e1a09ae06e070a9035c11a8270977ec0bf251cef7e8f4d7ebe84a93280b53a6807bd76f0f03993b67a9abd7b7ded8aec4bb2439604779503db4119e1c9d3fccf52121c0b6ad4be8379d9f393348e9d7fd505bdf5088d8c649130314e071f1289bcaa926007eba32da90733213af5bc437d1102870e34d0c950a0a413f2fb12f5b5c4d4605fd9b17fb4ce7d2719ca7da6c3829f2e6e8e5b326e94c8f6555358ea5e68af726a811af5ebbc43539e093f94e031806d201d7fa56cd411bcff1ef3b7ee2a04948ef81e760dcaf6de8d3e184b097353301bee5cd1791cde4604dd729982117896fd5d58a5ecfea91ccb7783e45d551c441ffb6a48a045f4ece4a21e81c8f9e3e1095da20f4d218c8d13f012231dda3f44be0377cc89d52048c7fa81daad5d51db85c20fc644f381500c970807b3d63e1b0889683a739986076f96ae70a2391ffb121c6cd1039384f6700f02c3212a54f5104f0c0a3ab20463a97cb21994b72ba87cc14c203b52a6f3e0b89bd8e696fd40b086c50ffd65be8128375e4a81429730a6439cf01c947b6c92f462b7a91f54fc32dc32820df8c74493cd0c1560867856302485ebf60120b0a8bcf898a9fc50a7c90dcd1a12200294d5c75a64225750bf8a6956db1c279e180dfbce8ce8a5a98ad5dc36019a0f72b6c21be31d12e222ae29ed5a7fe0360bf87da21244e8d49da278d35c40b02c3335c7f88ed783d32043987f7de6ad8e0cb64aa5248f65a334c45df1d1a46831408ec0b5dfe1b2eaa1c4c016f7e5693303f8a177ab0b455426848b25dd940b9e5d1f8e9392bb9c110869680176ca1fc095797c592672fa7938ae23d53116db3cb0c5ae5f55b61f63ef9c560e5e36471e9548f84bde806b7f01feb8b32aa37d18aad7c077ebb67bea89daaf61299e3fa89f0be6486e313957dda4f8739331dde11ec8a96848ad8c235b3d4098a1a293fff9013b2f691a847a7ea9c052559920fd291648126da281bb2ca268557bb67efaad7ff66c915474612ad49825ed09fce2b67ee2b9009c79aeb960d145bc37797cf7257b011ebe10791ca71758d58629463196cee720c18f0887237cd013d3c9a01bc821c87b2520d57b8660d7efbd8969cddde4b3bed7f3407da94825f16381cf071f29679761f726c7849760e0ba4a52759a8f25f348116ed192331fc5257b7791457b65827a0c432c042c632e8f10d9bae275b58cc15b53bcb3b823faea58870994e6cb3d3cde2e963e495a9b483d75687b7bdf722c865bf11d639fbbfdaec46433042983289aa7f06f0532d71f6e446e0bffdb4215a2033bea448b3122b21c1a609daf0af5d84724e65fd51b1cb59b873cc534fe62b0f7b77f8682ac49b378de46e5207b97f4c6a02de27835cf743846120614f12397e7fe6eb4724caf00a05cc672fa9027ee26a0e3549ad874e4bceefd7f8c632390d8e72fcf9d48e0cb03165fa0fa8a4b34c4ebbc80b8b009bda1cee31f9adb953700ca00cddf1f898ad6f86c0e8416f78c8f8091dee820e6e027a434ba661259dbe044217805e560da674abe9e97fa8d33577fd91dcd5713466f7fdecafc0357fefa27fdd9b96582a940c474454912179149f6470ad74a5820fd2ccb4efd149c93474844862af88c18a42a2771d1faab150e5693d85ef5b2b46df7a05cef39a39aea4a9a9b1e7676c5181a4213213963e5ecc0bac23f65f99972c5e1aec6b4412cdbf8ea5782382e4c4cd368e9441ca8b9894a743f4484a63014944e7e9b54c95d01b8c3ccde6a097e09d9050f0f76e8460c2cb1e4a60dff1966d7ed2bf7b94d7ab887f2c75705d77d0c5e3e88463bb6d6838763994afe2af9a518c904499728ae1e8aae3ddbdef81a58cee8398082f0f6185ab40ba30e8ea55aa3eae104435a861872d9ccc82f7c7e9044942a443e19f5f920ab37caa23c68644411b2dfbfedb259094491ceb691058872c9722e0842feefae3ef69b4510b0b0614a71e9fc4a4e843142561e15ab99b5737f56a7d4423a13b5fe7c35c234caaa95af8ec569b1342785651bda890218fe62ff62c2674f55dfff992580d35234700e52cebaee1233668e2e6aa8242b8ffa0d470dd5e93b2cbe8a97afe8abbefd41281e185bd0f5843b47d8b35aa62abf12399ee4bd66fd451ffbb92099a9ca071540f8a97f50ca037fd51866c4d0161ddbd12bbf5b388dfa9c9a87da87aa88d63449b6575f4a31c328b78ef66b0ca6ceb50d729c3c661be2e9c4c5b740c3dfebb5d420e8087b42c593c8748113de525c39c0df4aac59f9285c9c23adf7e9dc1acd0b3edd2bd2e715bf34f4664324b7cf80a2880d330289a4a5327c12e00e6a748ba3a5ce04da87a5e8c2ef94c29487012a5f920ad114bb7d403761b04f53e262db66ee792e9b952268942795071ed3647d5418813988f2fd654617d756a44b1311cc9f2f0291d3741b0a55616d6f8046db3625de0c61d1062ddeb6438dc1a069ea53e2d27a2caa0a94542ff31dab6d135e19d96901467ca1e10f6140d90fa42566f6481a8d95e92b03c2b2d430df45d9677a52795a57fdda466f28adf96f6935ae7a0644b536b980ab629af05fc00160510dc46902d542803ed636d2fe4746c48361f101410409cba604346ba817c629c7dbe161295cf369128fe474108476459f989a0e41d8766eef52fdae0b7ffd595b73fd72e8e83cf570ca94220605950788a5172fe9309e1639594afdd0cd2f51d906e09a4368010fd3eb1bb26a77f165d16151224fa7a03005055ac68ea69f8c7bc84e0090ffa0e95d27894d2ff3c7ceed637fe4d51580b1b2e164dc60443743e827a8d528596e48105e8591f7bb54d65029fdf3bdd39d5647186e55ff83c2814bdde0613cfb6fca43d5e0e4230850dd2e606001f5add1da2d5e6746c8afc5f64fc79a4f98766ad69caeb8e04831ca0f811bea89a278ff097a9cba9dcb7b1baa8ccb9c177606b3d7c7dcf10146a2954e602e0eb34937c618b7a029612f92f2eb4e5a5c2d096c79c23c0b209e45d1fbbd53e4c2be99e6102f9582bc4bb15ae128408d133b91670891a92ed96da3ee623a6b3d734caadccd195486ffbf3395ce9812fce4a4cc905d928515bb3c59320c1cb8604d97ff3733923a12588367187c3071111e9461e541c8d8402a96fb6219eb666afbce727d7c647eec9e1769c2e12aef7bf53dee312776f4f0f82c6463bc43a92e4589d86ba1b16671c9c11080f4e2450d1a425499550abea2c0b24daf29817eda440336a4ea98bb5fb2fc9a3ac27c0b73fa54d57dd24ba6edb18493fe88c7307e2c44d56fd11e69226bb76ca15184d4582514392d4d38ee46ba8528d3e941bd73c457f3b4b54daf7816dc87e80b237dbbb2ea4381ecc4f11e2db75082938866c7b0b8722a7aa8e1b1b3275a4b7cd0684e07d3f4647b3f07d7507e837df6893725e08e784c477846a9de6c8049a7ef15d55240376dd8da562e0e6954818e8fe3d66b7a11a972ff0cdd93af2e34b7441ff38c312a0955dd2e713031b536529c6696d69d9a9b531398c03f499fd0d3254eedc65821850c9db160ccb8c0c55282928b57b2ec06736037cc5da837d2172149b917bc23a62bac6fc250ed4c3f97869f87d0645e8d0fca514d873b0f714b882ce6cc30702c35559a5336492233a9079099114396168a303840c838394fa7c8abb010cab96b79bd1f1b2248684a8a98017a1ddd04e079a0190a9132a5775b865e2c64b228acc0f7060a7a2563208bb3752045660fba97ed96f65bf9b3af9414447b976b3cbe470a44bd1cb37ffdbdee3f4b9346114ee70f2747613e8231a51e9122b053e6856a7f705af01caf2196aded477da4d6554fa66f4261577504e5e97137fcd6bbc46a6646f69e472780363221398098eb144aab786583058ea6a392b8a84e738dcdfb60176530f9ecffd599b26f3095c64df13f13de11b8e2f172ec8a751792420c5fbe6a387f1b00b92127feb410ba3b1d1de3fe986f3c6e90e626c9c9e18e0cdb3553cbc4e6358affdb1287b72f403a321a6e9f523b2510c4ea6c728c654a190361df5a0273f01d7c4ff0ab3e276ee864357f97716a1fa2e6c570ff24b8399ed8f306733d3881d18a11a2ee7c4bb82a8f15dc340e4c3577fd9a81f031bda136e7f9fc4ea019657bbe4024793150508ef1f8a99bbf894d1d984e9d771edb4e6e0ea141e2e275cb72a95a4cc8b86d5a8be9851d160fa530e6da1cddae92f4feffab7f5a76feaa9db23bfab09cab5bb1393c957f253cbe82e96b600f5f3c3d3af5c01d165b2deb9198c4bc29697622ea3b7504799e36220b01d0b3a28226b9a1adc2d2249b0a254486fbc43db7f74e0bb91bf3305a9535bb171b24c68eed008b2da899b1713fc046417c3553436db72a60ccf467bb7a73cf28c5162acc70aea65280660f80a3f858c564f93d1f5724a7ffc56c9f2273c553ed641f616e3e1b171f0e3f681b65729c656fcda3a321aaecd88cf563ac2fc3059709240f388a42fcc9b4c530c62d92498271e18cac26ce864769e13afbeb1b08ea0e3592e6377020084fa53925806bc71adf834789e04f76688650d34e7feaa21337295d7962f97b8b87068364c608f3e16771d60f587e02ccc0c45c5d97af63385f3f3226ca3ab257925c815abe070e5830ab31b259bf2bb23db6f66c873182db9adc9eee2392fb54590deb215be947564bc71e9bff97f1a02df04e57092f48f36ac830adde83d56e5148db462316d1f0ce26c6e5c407d2a43bb3b1d9636b4a058f7c5333753ebf762ec6867b8b1ba324bb5f46f712438058b8c26f401e524c4d60de49c344f5b713f2b6ec2fe324287e11227f9b7a9b68e253cfe8671a40988194626893695b3b3dd783a42577eeb6c910fe0ee9da7fe35980f39911ad7754cebf554d6f64144573bddea81ed43a777f3c8a860e350bf5b4c5f57b8f0c4112b1d97c275f5cae2a63502ce7bee69d5bff88c9710d17b7fe95853e830ec02723ddd5801b84498cc065873ed9449b9eb2e624f17f5143f276f37b79d049f0379ea087bdad888160371c1b1238f0273b8ba4f7db0bd9e5bd6b7c14b93d41788c5971b9536828e027e345928e8c5d9bd595a4f2efa6addfb068fa5b9224e954bebad9e2ae10bbd9ba27bf802dcb2738516d61efb7fc2835832f6889a2844425ea45979d9099bd6921bde9a3871f44a866fbdfb165ff7651f52bfce732e6b7bf03ca02403703288febda51b900430b995b6778075b69936db67a9cc0c7938be849c1442d0a13c0b554d2527693d5eb82b67e2361eb784af0960d7be3fdaf32f33bd704c2733bd18501e1ac86308f80ce642da67a4dc2a048606678811e19babcfd9af6bc0f1e8d4a234d12ccdfd0afc5e4e42664637d9be58e67f191a5553aa13adcfa1c3dc1d6f3340e226515e66e00dae3b35b78ee189a416441107bdd683fa9f3be269f9a1437d898f8128a04c873f5da199836ce7529979d87cf9a5be305286ca638b1d6886d0297aa41dcf3113d72b7d61d9a46d135bb3064aefe25e7fa92b9e83e0fb031dba90b74b4b3007e6b19cdc388b8e7b808d18bbc16989ba0ac0394b13fbe5be9b52a1025eff9ea2e6b4b0f9a651185831f5cea32206a593cf73ee352a49daed800e0fc39c09d31585c2ca631b928f935fcc5a98e0a376dcc79572ccb287700797aadd5b32d8ce40966d8536abde424de6dd7743c1cc505a3126bfd656abbefbf214b5673284c1204542b87e353ced7e45874e06b39947e55428bd69c8013fe7a172594e6b50409673de8ca591bbbba239260fdae54312c7a3f3076186360759bd2aebdf0f5f3700d858732fc58a47b9d17c1cf5433f091e138171fa8d0ad62751a31faa20e24edfc416942a8dfe702d0101ba5607ad66e5f7500d999cf25a612ad247044b1b46135e71c82168908bdce24e07326d9bc1a4280ec3e3a2ea191c0a74392bca4680d8e7bca08a8b81b79bee3f28c2c5279545e09ee08b9e54c421ca41c7d54943e057d0f8a174cf22f056b2ca4eaf97ca7704d3d0d59ff2d92132d858bd61d00d0327d28dc733076753f5f481a494e2d179d905642e3dbb75099824bcf635264df2c4a553a8b4ac1cd75acae80bb0a0d122fd2d9f0cf01595bda96a7c2d9e42bc18fe4d01246cf2b96acde0c2acc47f4b1ce58993d33394d832b54d2edffe67d434e5897b2c78313f476017db082ed47b1285e15d8bc5db693264af12560e0e188049995c7bb3194f2d3f8090ad35dfd6107c72fc9e3f635e729cc268c521edb8b34828f5962e28eaec46572b76a9e9fb04271c42b2528e304e7ec66b5af6d689ed4a5fa1a5ebdf92bcb5719f6cee2a3bbbd6b6a1d82971c7301fd3eeb3fbcc3bf4dabffe108e4b01a2978798c0033a8abfd720c0f4168f379989904d7a173678b3696f29e9cef7d3f6b8af5f120a19af45c5a0bb6c1b98696c3dfafe682ac7bbba6bad4d45c4227077155f532e40f386df58ef48c49826f4d351acc232f54508b6dfd5cbd71ec9668cf69f9253e7d83b1039d081a5e69e2a980290db2845c58cf00db500660170d13b24984338d4af328cc3cf9e7025e24f93a53dfb081a48dfee2a8ed11fa35a60f94452d76cc59340e49d888a516d5a208679d9ef06a6561638eceabd15eb59bc0b98782810e9c60188d59d6490d5ac22a4d2790fa4f0fd25c568392dd2b877af80cd4a6f87a43ab7529b42800cc0ba83d27151415b3fd46b07262a93447bdf9c4806b71ffbc938e53ddc95fa4fb98b6d07c7fc05b579eb52f753151679319e6d4c4701d767e97de67f5f059bb6c740d7ea477be2cd7bb36666dfea08e53a224a7ed606d291551ff5b94bef6ed5bd57a488fce1d4af829f1f2f2c27b0d98a394491cbe5a27bca574c1a73ad654fb91f7d870453583327133e27d714eada918dbbd20ed6e47086a05707672d3c9527b279d904c23c2ded557ec6d39d298f39b557bde9e5006859f8ff198f8ee400f70ad10ccbaad3041e2e0f665530d42fca56ec97ecf88fda983b19bbc4792b49dc27ce66492dbeef34bb49f199e7b1cb0c8ab28aa010dc7f586fc9c5c065ed260c8edd13aa3ba4954fb6dc2d6b8e91cb3c65b9c1793eef843323326b72df51dc8837074e84d7d424459fb785bc529a6d9246b62a801262c02a176bdd5fcf86bfbd0f5bfd620dbc08209998630acdfa895ab3e0897b57777b5c9fdf544b7b3cff8ee59cf24e7fdf855effb8c0f9d3be9e398f47330cdcffc3ac45ba0464ccb5846bee88b485ce8ac128694ce474c0dd810a367d3b2479310d0ce4f1b19a2553de67824db4cf742ce8659b1c0a3fb75d50838c14525e749525fc39bf656da869a55713b3e7845e82caafcd697dc4bfa1a99f548776faa8eba6db0b942f3fb53c6baa9c723edfae35681828f8e941f1aa2250e1f5de6247d3b1f391f00c02c40dfe85330d78095d3bfee6a39d9f9d313223845f1264a1590562a9d354b1b2ee9172562e1ba5af6a432fe80852b15601bea60d1b1e574d484cb2a02ab467f76dddab07dfa6f53b778d15f5e91005a981ba0809ca3eb1004133f21c1e9ce595e4b9ad08f73f5502c81f649826b28f249825a70d3ea4013f7bd715e9888ba45a80a127846ca4fb7ae1bbf50a87b007f2bb5356ed1ade0b8202fd6439edf21a8ec6efe8fcbb1f0e9d602b2ff19634597f1ea96a140583d575b97ecc8378dbc09ce0be2e785c0eb228d93186d4fd90b1357b278ab34cb2c1db165843c6652c1684553112267f2dd0dcba05d076dbca05c8b5844273bec5bd5ac16c94f0aae53adc6cdca926c9227f65f4ee354705db503b5428cdb1995711e6f3fb1d104a4beec0dc25880f177b5a0054456933f2a109d51f44032e3aaefb5e2eac1efa3ab11cf24ee97d23e86511bb79b04b8043f3f8aa31109c9ac2bb464df5f15094d5652886192a81e79bb7c28fe70f6396157a6446cb6d59709778aaa396e8a71b7c41bee78dc60b9764006898c037c12a2c3f9e7f07263a82aaced18bac93bfb5170f2957537e2e88ee94f893d4345c02f5a66363fc10d5733e989f0f0d0642167a371081bf36bb6179a5cdd2a3ec3b6ce6687c74158990576621f3b3b4dc9d8699332d9f8a20d36b752483b54b4fcdc88a9c4f7605e34bb5fc863b16c18659822d3d3fc95f2b7e1df514fa2ba5a27295a278310c28b32f632853e5e0295b85f1f389da64704289d5ee0d4fe749a55c268bf4ca8633bbee36ac96f78aabf914c6a12bebd4780aad6b10ec2e7d7cd5af2bbdc4f004211488d17c417533961e121018a7706a4bc45e7f0acbe1303cc9adca601ddb25cc792f8cc3dbce2ff08177a54080b48df057e79de9b00339220e206999abb81021f1772b640b855bdd02f5cdcd396ba5cfd587cdaa107026da134784741350097b4d99892247f68aaea623cf137759909662014712db7bc4d88a1342c05b342260fb7a638355393d296414c46b26e9c0e6328ce8ac417afda1ff35c85924b9f84b4ba8fc54372b401f43f645939246503047e958328ac3c83add80ba8dca9fa8c92a26502d06600cb9d5298119488be1de65e6a43f35adea1f50565eae472c2bcabd1c234c721839c2ce98272cb7bc56b5259784a9607f88866a205de0876a7ae72c125945b5433fce2c99db29c8de81b9645b486c53b89c7d4ef3adc48b8768ab9c3db245971e7c70a03d0c7d15c1f43f1e7d120768a2c9f135da1d72dc74f03816dca6ff18feb5fc1575e22581a9a01f0e85c9dcc4384af42f6bb43fe124f71ae0ba394096734b15ffb5b84a242b28e289bba51e204bc42bb3600679cd0182645582e610ed715a2c2e4468f6fa06d11f7e40e458140bf3eb3774f0f5e648129d610a0542504edf8095e6b77b4bf5f757131553facef07e8a26e390e998c09c8685d9760c019e765f51edaed577fec8d540a2cc7ce7bf66c56b1a87cd68211d2393cfb85f6a34dd1ec42bfcf81c2d26b65c353953dd35e21661e49ff3b730f9da65035b3b361f5c82b5eaa330768e4ee21ba275aec4dddd15f8edc5aa66344a8c2776560095c8e81481191831afd8275db959d4dc7eaebb7c35febe6264138aaac499b05dbd410e2341927e2629b9acfdfdfb64b0fbc02d67b8089065b78f893310d6138ae179db4ff94a67a77bd29b7e965690fd2306b0021cf14fb1f492f68e96d6037dabd5fb332c6f0cc14b25435ea544c82f482f04093b0d1f2ecc448dd59556f426bb4c7e4790f6f74a7de0e41f5c491b3aedcffce72a7eced1d9a5c47a274c2604a3dc082daaa7f2bad323bc32b2ce8bc69d47d457fd847a69f3a7a3f0cf797df9b4199aaec4cb5193e2117f03184980ae4b05a812496d1396708bd4d715a894dd4d1fd17baa6fef1ed7618af7e0ae9e26a4ed554dbd1968b7407fa5e232022d92a15fa32bd9748f8994e99fd399efe650063dbc36871a567ec9a935a9d75e16c4b1e381c6dea76b16790d4a7a932d247b293d2fe0ec00aa540d2a877bcc82a92ac5f6d09bc6d44b8f1a27962db6348904364b748f26aa4f00c2d94d757a0fcada3193cba232ebb2207163efbc844eca9c7c35ac37fa5a9241d74235685502055f9493706ab735d662635cb4aa95cdf9b9ba65ffddfbcc5bbf6e665fb8820c84da72f2786ee9eeeea15e12c6c870cde3a7b6f323d4d5f7576b69578410337963d665ff20209f837fb56101a7032acb897bc9d50e53ae3673440232804bdb1c58a4780bf2eea0ffdec14172a66c0d9964bd998f07ea495b4b6d24145203c455b0417a432bc906a72627d1d2f9cb62ef0aec31cb834400b6d3aa77cc7035eb6e19f036e9554e082a9d4fa9ea875de27ecd74b36ae36935a2a3e69fceec329851fe462325f68c645c66f6c45e2ad971c473e25ed2c5b65a7cdbaeba29a85d6bdbf116e56205f75a87ef55879c293ea8cd299d37ced67a590e7fa6fcf55d7fa09de391cd0d7c9840cc47c6e8a5ee7ac6da5ade7c762f7e950b0231e55d7af600ab50bf2f7655cb83fac31bf30a98a16fd817bc795e5405077a45bb6b8f9a33d932a88b9572013db5d159029c4059c59f8168ff90fe66347b5c18be2a97289cddafe2762070cd7c67ded58d72cd884480e5318a9861c2cf549ddc49e2d24169f9a70117f7b6a6a02d1529d86c1d17cdbb2f0de370bc8ffa50d41efe4c57982a14a1beb160688e590576a38f20f03947b6c8517fc104caeb855579ec7731d86be4894c5e277aa6677e663234ed1a793ec3be426bc4c4b7756baad61c3ffe1c7ba322203e2d7cc587f9c01a0f65b202211ee2e15b491e5571cba4ab8abddd75b22783c8ee970e8f159b42e76543e81c00550b703c71eb73ee905c39e5116733147076985a9039a5e66250a98e0c2780fdf2ae45a27f27ca849a324cf78da9b1310560a76c9cade53b374724f20da09082acdb37b625fe54cd75ce54ba9ba16a113d1fac2444a07032569fe29ce79317217a6785bc4d1e5dcb28b64293aced6a77a26087579e2cc4e2e0050f1670728da110e3fa2bec51230675c8adc31570d2752140f8dd62e38fec9d9bf2b0e3e7b73322786663b5f1006b2168f0463828ee7c66f01adffcd784f95489173e0a25a6403cfad9c9878de7071e7ffe6431785a15a9a1ca01668b6d950c702f193be6eaa288ecf81a33507c625f7d17a0d25de9967033f78553307bedeaac89589d8c653ae026d08794d6e8419c8708280d2e0631eea89d055f420f17a19b9a445fec82714a262f58441d37904efa39ca672a62d29280cb07824d779f261e24405d69bc285322d86fffb60f88b75b67f17a415d37223ab8cbf5dc5bd51f6cfc9b067cbcafbc2c393f2623ae4d1765d6ce079ffe6b1676be7f84fb18e0797951dc2f474458a208df30cba03c72cd5a228c197533e6e0f89dc207a523bc52c767d5962514e13bdeecda1e959a790b760ceb42177da2c41fedcb404d5b7936f490c6a42408d44bf6a6b078b105f6811366ca2d587cf520ddc3b3564d4def44bbca12605328b0bd7a89e1321d5e02976b9eb1ad573224457f75b356f00372d981ea7aeade84ae43049685853f5be3917db42ad64ad9e69dd85c7ebeba9edc7d7e4815e83d58346b1ff4bb4625223d754d6ae533a0afebca2767943de3f70611b52ae4b5bd6b65b39fb163ba231c1f2aa0556f0d7e66443da687c2bc3f5d1b2a460348595bd5ee0b3dfb498f2b4fae3df00606befd32bbe1dadb5916515394371300ba7d2ef6c4c70743663913dc49c0a02f4bf050658d2148aceaa69e8999ba4db143cfa5e3182b4d23ec2f1b40bd002319ba4c07073ddf5b0bb64584cfa5daf107066b04541f71023c8a5ac2fd97aa997c01859ca91ff1197d266ee0f80b9c16dc020b3d6ef3b797d3b66d84f9d87bf63566d812251e3db056dad8429be51e7f30b9eb16c4f653e850a3bd536154a79bbd321fa10004e59c31b2f71d74b6fd2d094423e0fc5563c5975cc707a112cb5f93d0a618375f0ca365e17dbad08bab6c4c0dec10d61fa3003e98c2c09fe3a2fe99a47480754fc4667d24be1b38efbcd7c0b0b449caaedeb5a63a0524bd0253fb5f9799e41df2c92513b89c778eb90747f1ba07051c1929e28b14965ac2ad5bc8c760f25266921445c58f14030435887d48e08430f80165fcbac6ceb51ae725c5b398823684d3eb2ee19b0694999a060387ebcfeda618247951e66abd0c3e192a1371ab90b78235cac9e76865ae48c98baa88e9d69419b70763453d4e52b30636ea584a7c8548bf5d454f2e4623ad113f3acce2a923d6d71636fcd66ff325f6a28ba47b52dd3c20b6146af24b82fa823b7d7bbe11c29515e49685656a1530ac453390c2e72abbb40b75c84b6e8e41bc331c0fef7f17ce2dfc61792e6d1f717689de99420dcc37563552ba3b68233427111edee0ef7a91f8703bf2115cba42e0171bf9f9591dd840e51b972a4762c2c0acb97d6677902f85aa7e2a4173be1ebfcb189b178ad3a63afc724aa39ce83b75ba9ea81b5f680ab7be01f73dbb951e845c9563a788c5ba0b34f8c9830a47407e25d36a6838705b3fa828944704831f915cf608a5f8ef074b47e7972b3cf05e936753c2583c2554d95b3c05e1db85622f534a6b939f021f6125a225cf7a97705d232898ef06a66521a70dd88cb2c8d9943954f328e1c8e67ada9a4354b773ca7c304355c57b3d8908200cc96daf8baad624fcbad1ef4a55513ba8fd93e4844a2217d7cb7df221b38302c462f32e39bceb36e059f8a4c6af4cd23502b48a5e08102bcf306e97ce93255681442364808b968bf5ed818fbf7e759a4ff381471cbc2825d05b4f2db08f6688c2ba5a88e1ffe7e18499133c54444719455f5b51b06650d33651078c75b906230f7fdf552a26ea64db815b0abf745f79d573dd2e0688a3c919222bec96e309196580dab9de383024613ac483d59e50cc84c2536b4c9d6fe30ba0756ff4ea19f6d0e9c950f11d61407ad7b825856b824e17e769f853c8c7d2efd1c3fcca36657dd1ef32f12e4b82f83954235acf4f92534b61719d3772bb5ef67c6e90bb658fc2a8664e66cfadc66c10033552a63c3a56c33e34fa67bb82c4841ac8d3f2c400bf3f10dbc73bb531063db9ce515b5f804c0b494377bac5109c72355bc77ad4a5a85d69ae0cfb146bc501e2df9d0e9e697cfaf830bd3517eca7f1a681393ecf5f8028f391130324ae8c7443ade861ae3da2c6bc5aa7d8918122c4eaef1ad5bd3ee4592098db02aac536a6caf982e45a62f52b067dfd49c34a1b434193c4703e1d61f9edbc8d3479983fdb22965129306c19244e0f620205dbcd011cfc6655ae4e79c925a9bf23199ee1119bac820bfbe234e34b4db538350d9ebfbb2721ac92bd2c880738fbf0fede7267298815817c02c5f2c2eea91b0b1704667109ac4b106e8505800ad8df29c8db4b1b6a1b20e0b0801f2b29fa5ee1a137516227f3a3759aa948f41ec3c694dd36146f68592bf5529c55defe628107fc355b77852295abf7dbfa27db45e217c1bd5f117ac2c554233e74d80971a0acc5acaf118199ac354f61fd7bad2f80f97c7257bff0b21ac5e9fd497c459b28c94364cb847f11298524ddcaceffc5e3ab63784605027b4322fee6730a8ca12e0f8969661c14cef52b0211fc3c08a8e5cc955002c5459798106c9fb62a494a77c1b6555870ee86c403fa78cec0291185eac4154f3dfd92c108228b1b41d4a9f8e82aa7cd03580c14f745d4e431b4993aad52fe0f4b2e230af36e3ffc969848e17f939fe62bde4b7d830bcd89ac7fb98f772f08bf6b667d3ef82d8ab27890f20fb8f006552affa2ee204c7ff25d5dc6dbf6d7a2b6720b5a34896b7a5f4fc8699cc813e270f6643e661dbeeab613b75ce799c5fddfd93eff19624af7d813b4db2eb8faae96955bca0d1ec47ff535e815025ce47ea9ca96ad17baeaf15dc2ea8a892ef8cf3b6fc8f878dfdcb1ad6dfb10bf8ff4c9fbc5f336f330be3ca25d82c18fad6f55f495bf401b2206d975412b06eae20c365f966794f5cf4df457daf81e03ab6b9e562b7c2a05fc99502bf5e6926a03eae6cac85112a6c640a0a2e636dc9a90e165be158b4c0e27943ad0a7a2edbc62396c73286d45c1fb9cdd2c9a830fad26ea4e27489c7ddee2023bc97159761121ac5cc5b9f4b581a0f51bcae5d62ee902a485c6c5ebd99d1ecfcc540528d1c043a83213fcbefc97ffff4e52f877ba9c9fb96762dfb5c297115d195eb2bd6a376727eeb9bae0085a89fae664c924597b8051b4ec23926940637986cf2933043be794d80e10da433967828590f9b4367a81cb5cf285a68fe79c2885d5a2fe1842b021f19fbe2729b2e8e70cc4356f3086f73cbfa0a4baf2fbe995eee1569c3a9fa18e7390c809faa05ece308f2e0bf524700b133d49c2b2356921881f1c92812a9b7636b5d1180b4cfca571766f159c9f4d9bd93edb4a078d53e3bf7eaaf54ffe1352d7f815f1662498d5e82bef9821d7723f15d2437f6a818a0151bec3b7a68f94043f01f9fc6dfe1a32e538bd54bc91fbea69fc6161af9829f9e8b00fbb5487fc4d66e5d88c11c6e33bc19c89e614ba735e9039d7cb3ee49b0e78a86d63af1c47729615d16714c5d835b3d14d23293d80561e91649bd800e7975ccb32924ab5ffb87bf00242a4bc79283de6559ec12e672e0f8b034af0c47881abc9218923b75694c3843e09bdf1d6c6772702aa45bc83e0274ab0f8cdd2139a36ef6401f5ecd63005f8fee3e82815f0b74347be85d70b33628445788eaed48cc6d7dfb5b80fd881aa0af770690d495cd6be7b850e4d449d83b75a29d6bcb64e6a16a585e04929561081823119718b25ae369e84a6e69b4f81908264108e19f014c41a3e7746f64e4c1537b6c8f08869c46fef64bf7ac1da096030017506be6ace8a4ef4346be3daf004abcf1a60ae467ccff3c6fe0713801ab9c8a004ff378233c0611633a5536d723200e84db2fba5de8df9331d7fc861847adce2d9cdceb06d2449a379b72b72d6138e5da098a5fe343ce33f883715b2657bd3c7cb6f75122f036f352503a681ed13246b43d177bb7b91d23ee46cf7d3d2e8a8bcd1730843f8edba79aebef13eaf6abe845257523e0975067f6c79913aa142dfdfe3f7f6845733e24f40d6f6d8ba2bcb91867542837fc1318c7d06f2d856df4c6b90dca00074bcbca77b0c243f1e1085bcb4e121ea1a5013e410b50019b7fffa6afaeb316aa8e3087757a3804bffc944c3384de2057eebf243e09764dda7e72b5bc81d13e6ce9f2f57033e49c15c5060a92e2d6516ae432402b2ee4edae94124183c8c0d551f3be8c2fa48dacf4c09801dd54e1d7def7b8163d88d3e7828a1e2a016aec1103655f723bdfcdb6c846e3ce824317bfd64164f18c92e952c4a4286f1e772fa7a1dc7963eeb175222009e6fb3f18e85943000d3f9f9a1a74f66b6a35379eee5462a300149ade30402bd047d32bb0a43cbc29006705c87908592f608469d267a683e6f4980badb0c860d1449ab3dcd9118f47805d581bd4f9be76a1f9d28c851dd1d00409db43d742125769f31ac9a3a5b4911ea0ced8caf3572f40f5d26e584155e8ae2abfff7f596ed4c3acab769a617777b671a6c6a4e0d59b912690ea52aaf189001aabff64ed9cbd3c3050dd68c121699e186ace60a1c734d2fa14e82dda61de2011d5952b63151d85428840120887b4ed8d3c0c0e44cd8a92c1958925be31490f23447c3974c405f2df61f1c0852cb0a4ba0156c78673ff31fe4dd17dd34f8e6c2f5f8acf05a281260270ac4549d68a1e491bd5c02bc1915b568759dd1039f898b47ec9fdb94554403eb16706e66e3a33224dd8982b5e9763dda7ac198ef828302e685940b62710832fed33dfa8455f0ed7c49ed177ac6da966f33de5c7052caa46d74ffe69ba640136d5f200c1e3922037b290812bbf517adb002f145bcbc90dbe4b38b65d137a51b6c496607d6f5dd10811876397c2711c8f21f653a50ca7eed32226aef7451c6ce0330bc4b064539a22deeb1b1e4cb4c04f502beda9cebadb243a536212d90c80f90e824848ff079db9575ea9efa9c17ec85757f4be874e91a8eef290d92f1f8323ca10f7d61e6b6fce227b012bda2e8203ea1f219a8df442bfe6b7fb6619e51b0b60a821ce801e01488c2e3ab4234ab3535434f0effb025fb8d2c9d143fb1e03581d8dc41b188acf21e2d9f7bf59b9aeb64dfa8f9fe1089957c17ffbe217de6ec4505767580fa7820002c6270d1a4b139313a5f1442c08229b1aee8fda6e587a6a16ac2d25a1d7a5a3d732e8eab4d6a23b100a6b2f412f700206cd95190c4017552f2bba79bfdbc20265a01abfa91a0dd45072c4ebe796383f323ec24b01807623168ae175dc85bf801d19c86bf8a727507b81687f947c60c1fb9a66d24e6163c1ee139de45b425c4b0241f53d92f742aac1e6d188021abca3733384512cb95635082b4ab057df81f3480277cc9b7d6e1cd49813be95ce1ad7e6e7d051122f3a9ab6ca358c4e891a5d75819598bcd9cddd320b807de9b9703a3407f34725571f27d4eea95f89570f17a67e3ecdfd38d26f6390d2b56171df48698957b203b8d20363b050ea48b02b00f2aa3bff764e89c025ff1628382a6360d204d459c4cdf0483069eacede5928301f755b4daa5cc579079e3bc8a81c02152d1741d45c8d159b9b2c649df3f4e51aa1357647d406138580df7d3c3f4fb5282683088e1b1dce18de22bd61392302255b7e88effd2b784cd3cc67c65d16258498ec548f318cf39eafaac6f70082d2328b68df28118d5fa064f0bb9cbbb3a2569bcbbf763868a6c6ce85c61adcbad312faa2160c22bc9dfde1b3035d47c2350416347719e5917dcbe464c2535dfb22a0a2d9f8de00e1665a03df5be783e8100dd5097350f84b86312bdf13c9c9c93d4831ad81b0947350eaf57934ff120d6938c58f1018f421e1050ae438c62adfe8b95da91e8d0b52c97c5a30423088a1d215a970fc81385b1f1c186b79df894afd7a30e6a15882f0643b8acaa7ac42268477f94e4c094028fd64e5c3e44f5e3050d61275cce41ad4de5437dabdcdf384698af1d63fdbf29150e3ec4066ec52f867be98b554ea223ae2e8f41b8e5cba0a317b6a03b3dccb0f285ea381c4c7fa520a69177b74bffecdc77e85d16c1cfb0d76998c7bf35f695fcab8986c9d688fc63ce719229c008e870aa0d726c9eb9bda564b1550e4dd3272b041b486cc125fd5a4f762d63e5e8a3cbca2f0d7c097d33c7d7ca601d4df6179fce09a8507ceb8a12f1fd93127796cc89ed62e8829ee29efe511f679ed89b59e6cab97c789b21c4004601a0be6ba23ebe4a844d599277ba29f17337646fb9b9c60c5b700d61cc004239220ad6e540518bf6daca42aa50e9cd3c434b2318a571af00c9848bc3d9b9bb622fda95fcd68d1444d97ab75015f25124792398d1dcc7c1e0e348f6fffe1c31f589a509b6df46a8cab573746f673b74411c536db03ed5d33390f15e664305c2a6ef32d4fb9c928376e0bdbfc304851772d8d5e49f650ea302b218eb2be1a613b5b56379cfe85b48c8fd59de224bc76baa1d8d3e42c422775aa9a6731123f765b1a8f05f48b82bd6b013689f67591efcfbea6906d1ea10c01af1e4969d9b965b93086cec7d213226bcee940fb3500b9b9dafed139e612edf4073560626cbe725f7632a95a6b8e258d89a60d40bf43297f229b27fcdfec59d64077a7dcb1e13c599ec30e675e5b0d13df733fc04a776b8ae1c720dc5429c7f3d4fb8ca9525d245d908704c5f828b15d4f7d28dc3c8b4c5ff45e86f7433ef1080b1eb7da54548097336b3858b0e5d2e4a7293154194c7fed8ddfca5016c940dfef925ed50f114f3f0171f6646baff4045ceff5c6725e28065cbc94915c9615a6e9c62a67f0e50d580e48ad06e11b89fe6baae10e13deb6ff58a1fda6cc3a176df88b5486b29d2b165537285e82c7d81e3b15b621e12914f694e907308873948acd420308b1cfac4c916ca526f50512f5deeef9179af93bfd68302f8b2db5a9ee62caedad0e0813c2ec09782f33b39b8d26fd8b6a93d956abeb9d68affeaaa7e9555593d9d1fd618f89e00f55ffd21858abbaf910e73430dba1708df739bd467cad7f152fc02e413c3a6727264a369e8ed224ab45082b96bd335b2954229ff48920e91f7032aa22bd82e83741c9b9c47664efdec6dff23ae9fd080ef0b564c14895e2a51f4f0c57ec4b0a26fe070d67c9609ba027f98572802ab72f35b4292f3105ab671e32c565c707808270036c1a570a80c4d054ecf7b318474d04bb08f9b4790bbf0a219076cdf66593db9616bd4271a02194bdb487f73728c092a1463324ef50b6548c9b5f73146ff41542646ca3ccb4e68f105997f82c841beed53bb6a1dc94dcc5b4b434e02eda3d59c6f1a64c54775ae374478c7d1943f9eb55342c1c648dc03b9df4f9a1dbfd007b7a151b7d9f0d6128bf15942ef9225afd82c846a399c885d5c0b017d839489877c4ade8c9382cbfcbb0149487af691ed5968004d953395972142b833bcb26db022dbc5ad28c124d7a6480aee69914b4747d90f6408766d250df2c5c2ec39e18bd3c1865c49f6ddf515fa97a1583c24cc686008d4d8e9311f98b78d093d89f3922cd0a019f656a058be2447930c9622bff763da96f4948db405408585bed0c490989abefe38acf1dd4ab68956cdc61139d3cbea7bb6170449fe8bced77622b0f1197687e3029a49e08acda42f38e4705c191230f3912c45708389ba46a6cb8086b7f33534a76f2b6bf816105876efdc94dd46a19fb38d6749dae521a22e801e5ddc729a1557129476c9699e44c7e7be87987a4b832c84865dc86a49811207a8a5255fa0b28b20055f745c9dcc52625b02bba6ebaca6403217ba2da19d7b61942e62e92a0a2f4c69dab7874f546e8b849940000c5ec04e8ac416f086646c5ffcf21fac84de800937bd1b4faa4ccb368841259c3c665986c4f9899301ba85e63682f67b400d2e2fce80a1eec27318ad71c0b734996cda4c0f92a2db535a3bcbe4bffd6e2796f5b523e7b6e0dc8cc61b2ab5637b4f17a190276a85ad7319afe1316237e086b79e53e1bc6f451d24fbf720079381cd3cc7524da63e0ee6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>月寒日暖</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E6%9C%88%E5%AF%92%E6%97%A5%E6%9A%96/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b1f3501ad987ccc17fcea890e1b476057fd14a0e47c42372074f9240f6350476">1c9d8b8c792a241d8f66f0fd62fc81bb81b5d66be52b6d9b6c756d83d08097620b8c415e439f441098389c364257d7c5354861f47267ab691dbebc40f67e97aa48e8233aa546585ab24aab7a1661a7757264661139b8998ca69e41737479a0ba029d961664c4fceb1e417c850913f2dd0df0734a80b80b9d7c5da2291ea550fb33fbae4f4c3ba9a8006bce7858ae837fb0d359fb998887f81251438cc1c30b18d487844e0d0521b31b376e9a7113cd7afae39393259eacf3d7917cd32a4f92398e61243365173d642b42c8725c4d1e7210a6e93a099641290538389fd406d0fc4c5c1af840ada48072aa2388998ed5344e95d99f6a7ab12b16a36efd931dba57b0c36cda3cdcf2d87435bf816d8f0e01d72a017b6fb53b7552c0bc52d4ad1d99591593951ebb9044bbfad62cc523bdf709971eb4c35185a58bdf33dc74abab33a8cb60fbe795b6a2efe2c34ffb8c18466be4236da9cbe9cd4db00186cb2a4d0177f9eaaa0d5487ac7b4e388f725ff8ec7959fc2efd4531a461ddc45c1d2ae3b575d573830c996570763e7cadec2c08a8c61dd6d9f51b1801ced5dc5d277475063909eb60ffbedb8ad05740d8bf160a814d9e95c479da3c2bcd00bf05f5f597485dab26f90f2ea129cbd7c053ac90a1b48404f11f07406b4e81c73712664eb17f64561b8f5ee24b9bb9f9110f28dbb54cc602955b41ca5a59a4cfe31f6f25214bd5e2268c0d6736784b3e6d543c1dc3ad88846e77aafe54467b005b113e372eb91651c4bd34b5eb2dcc00e4937c783b1503eef8b6ce50c2d1f1449681f9368493e9710c0fd5313f8668dafd4dd518471778d3bce5cf5dc4a6c509f1d31685e95eeef1fe1ae16bbba5524fd69cb0e343f30d219aeabec9722bebf424199e3f17f3646a6f3f29205940909edc948c9c526612b5d8d9606f3022bd1d68e392cbc458b493b3d647444be7206c3034bf96042eee413f15dcb23f466b21dba3beb6bab2aa572aacee24975be50d6e42a0be553b6a0670e5ef281885eb7d17cb5410b3365f92994221f8b41bf6ddac9d973c750eac403432dce96368617ceb302a347b7117d86fd20cc876c05e2a89f9fbaecc616995c0ef2a0d1abff702d0cdcd94558196113fc651253f8f2887cda016b070db11bc45739b8fb49e0cad6967d23fa4cd79f4af3a3123297f53eeed5f5057f7a76bc1c12a918f6b185d2bdc1fe24104a213b86a80591f63a37c1ddc0a6e9fa98221eeb96ef86603c816eea350bca6aa94a1cb0130c9bcfa3db118eaf680348c9347bdf0b1f80079178fde42d2a9dd0779a7c499b4aad05bc5449e6d248c31118316c7cb2177fef10d9fc9cd0d3d7a42906e6a562d3b0e82fc194afc4289c3b8ea6cea2fbc29562a3ba4d28bd7b00b5204758c15720a282dcc0fc389e060d7200281622afa173fac2a68a9bd40217f0cf844e4de2b9c08116b450250eaa714b349952638fec3d160f43d48405b72c39594b782fba441318c7ff3284bc1380f36c9ad61a29d9f1d227771a75388c134992726393c270107736f8557f0aa8184e601bca9ee8bedb69a4b0593b8294536b17e53e5f21bad9c38e5f89d7e4ab1fc16e5cab048bbbbac74fd70eea84ac867a991072fa99f60b60ddf9536d8b904a75fd6201c91cd787271c3f2acea46c44b3c98bb8b39d8f5e172a208d84b0b5339c18505fd69c45c7a86902dcf926063d167e566bb97be01e7173c001e42845e212a99f2b0365d0510fb2364b11df6a22152265d0741d550ada141ff5ef48160669e0b4f801c3fb6b4b388957e127a92a93812633c3a6ee65631ed672899cd9c01daf73dfad895676323ef0f76f928fdd998bf364dc90889739b61a5a8de8e2c3e97f0111e0cbbbcdb114272a92804f8e1ba75e114ebde1913c2b2203bf29d4bd7d210</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>白鸟</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E7%99%BD%E9%B8%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="54f39558986b36e2498dd29f399343fbf1ac4de1f456cd8200ba5a3840a803e0">e55e8fb0918b8b65d60b5b09d6dc221c9895c42adfd9f5723b544e43004f0924b5ef6d7b6aa284c580e875977ecd937d3152d8b6828954cb86df59411b7863ec3927f1aa035a0d4a8df1655588f3fa47c8ca66bf34ebb8be9c1f9501e3a8130d23401ea1f4cf69e1d5effe0c872f614d970cda1cb7e731310e1758548be9d6dd9bd8420988970f0e8029afcc6eac610bd03ff50d97ab108062ec5f189c478c68ef1f25d71203472c1b5543dbb99f4238384ec6d4551cea8846273cf3844840649b8a1e540d44f137de19e70987f2aedc59bea7053d12177d1f55c7bad84e1ec92fe680dbc771d4a81e39f50d63b238c4923b29d898dcd5eb513910b68e6fcc4a8b9217d81b1c8c16a961230c4aa3f286f11e7f1ac210cfe8d575151c6480346f309e937ab297da93c315a6ce993d1f45ef2517be1d85fec3c62893f20008a91c6f8eae86e24f1fa7f9bd30b38f8a369601eec6532c6ecddbace49f4f015a2eced29ed63dfedb534ae0b2cf9e017d59a17f39135af8f3e427ab2fa5a5068a46da7d27dff52cd0dae46266816852c69e0f8b3393e54e2388f63656e27b7b3df500041b8f658b8be0e5be6b6a6781b0dc006fbd0b2a14582d0c2b82137d4963b4e27d6cab1436ef9ad3a890f3b2a5ab3f9b31615f1182d8442bb3f7ebe9eb3d478dce1c220940e7d60de354468bc2a93054dfd26661961c31f468f86f128b096b613259a73c55986102bf8e6a79659da7bfa94a1cfd9f57b06ed19c530c80f64c3f12582e3df075d9d50c17a90bccfdd71819fd202571b1a48f7d41efa96ab7eca0f3b8a75e87c0e25d6ead77f4d0af5f0880b9c533f8abdc475b5f83839647fa79e295e2a7eaf237a9b5e218d893d553faae696cc8a44d66303bbce1287f4cb2538d8f6368b37f6644b0f88d35a829bbb117877012849b6688011d4ba3ca45a7ef2d2d894c393a48845788e5d0dd4c709a6cbdda10c42accf5e93f57aa49c316617027a1164f11657ac81b20bb705605a8c43d91492b8c9d529a4a34acd6c792db94a777e64c9b1cd1fef116296e55c45ac0a4f992ccd68b5e4442958c124bd38f2e3988c10c1bb9f9bbdceac004d6e1e47fa7da688141d7dd5c4bb200d04cbb0490d4a773923eefc38c3f3e598288ffafbe6d7b55abd240472dd872d59781a981424479edd2e719c6966f576c58b296b33dd3fd7404ade108327cb6cbb6081deb66858ebe6fc8777ace29e335408c3bc839ded69f6414564dbe413ba3d2616404f4afca0bd80f4e887a06208ee4bde226c3e54bf52058219da13a16c9ca6f8c448806d8571505f92936c25038cf6a437cf098a6d27b81a752d838c4191f4a456ef4cd89adabc8f57fafd14b3b34c1aff039939b4e674b867951380f644c9fb4958b0d98bc0e7539127d9fd739058f3096a6a3e129bda8cb259cb7dd58e3a93bf5fdf31ef189452e65d8cec57642b29de2847449bd7456cd290864a868bc1c8c4eac04d57ff73e4a5b523f03baba7e910600f2365bf4951c883e58254a781fa33d6c10d55fd77ba237cdff51e57776e1f84d4f154490d92baa1abe95352fe38a3b1034b632ce1f7c7196cd10766d4ee72555579a62efc443b0fb7a0939fa363442395e3354ed9b6a3f36b8d147679bd8c16c423493a66f095a4d0952c92beaf714aafb281a6c937b8603aeb008f8da573ee1bc92bcadec7b9e9453059aa3eea25c1924efb59ba4a7a942a56c4e1265606f20d0bc2d8b75ecb9f202543683100f067a7daa7cbef5ba3c5493c2bdd0ee53744456b86747a4749e75aa8678190dfadccba351f1a58aa1f481ec0a0679516a7cd15bf0d774a115e286d0eea978ee7a27003555b52948402e0660ba2a2c2e3119c70e537de0ce75629273cecd79d75ac56da6c9066a5fcc70999f3093f31dbbdfe59579f1badc39fffbe824bc9e0c8f4e2129ee1a35ced8092d71a89f9c7b9450abfb8197e6e4d0f07f2395267e8de37622a7deaad26f8f011b3b78f0e7dfa643096180e7878239dfa1cc032e896cf0376c1b2086b75f071fd3dff64d88d9a3d66b3d22b01cae32513b53d0e89c0033933068df41b38d415bd4a10f42aa8aa7bf63ebc94b45457f2f717435a3ba352928788d100c80386c55f10db83de74b66a3eac550a34a64cd2cf8c5a3659a6f611fd5c225fc91f1c2eacda7b73aeee6cd211d24afb13f1ec5d14eb9f6d40b54e72f633d7d3c641d13d8e849a51061d18aad1b238c951a7b934caef63482bec3083093bf3c5849ae637ec3578b977b840036a1d4577788e3af24059b4d74457c3099b6245d5113be90ff6c3ce45c07d8416712ba0da19a3735977c488ad65d4d22eb6a1301171e2f55592495553a2e0d20501a0dd52a1792967bac6974f4e111ab64e353d9a7cc45ffa3e0bc9dee09761780c9da2dde21c9f8b5be2ff36644e888b396312b54f458c7bd30f01aa362b7cce6221721fa3ee139fa1389f2b4c184fe45d3db8bfed7c1d5577ed125f64a0c2d828846c3f80de0dc462471a3c35109d7bf47b3bc78e3917d420cef4be65269d93353aa36cda20eec63f5b76e9a887136aedfde4342975855641225f569275b1e7568e71999beb276fdd898e7e0c42d8ef2647c84b5205fb0d9a71232e344b87ee81df169434c40b0d9cd012e0b3c1172da7ff8591a912b0ae6ebb75f8bd76c3ed0e53063630ea394243c0388a90aaa93ae3f5d87d227a99cf4fc2db68a3765b7ec16b46601a2d5bc19154018a7fcc63d32dd755eee203168ea1817f87ec89ea10010daac372740de133d23c3ee15c90a8f66542fa3621818e1fc1c9b4ae3d1b5e4cdda2328ccdc6b3018faa1d349aad6f175feb3ff9a4393e10e30b227c87fb5ad3105d47ada04eb45f40fb643bf9772284ed7e837d553903b2ada67d24dd4f75c52443c2d7e1c61be682c16c78764b8d0071510de41b2bff6c4dc03b5d1f78d136ab4872da186f8bf51773508bc80cd61a530dd67a1602895d58f04a71d419c84afaf745d752696d4bfce0f8ffbdcf9e4743ada89f34168a2a23625f98e6a51c724f9336a1c8dd1b44bc183bcc9e72b905c255fa3119f6be35614ff9224840f9df2598a6967bb8e925626644dd230f122ddd7fa99278fe505a3f1328db38a519174da357cf359e07ecfd01057823178940a8b6700a16b05156bd50083c880b07fb9bac611cdd1a2ce4b8832c1c6194974e29ddab2ccd5c8cdfc02fbf63e5d7e5fc8dffad708cdaacb69c032d2518de3434ce6c5719cbf233ece1e91db7382afeb5032da045dacb0517c6c134790f59029f02e6d1f85d06e219ede1a32d1ae188d112dcbc47ea415d52f39e4f0e33c5a076c54fdce90fc6dd8777563f7c972cc2edb1829ded028ec6d76fd0b5a4988a9d869eeef8518c7215dbeaaaabe52d0e3077b70c434a78af4b5342e39f4853f14ee47265fd2d651f9873f6ce9d6e4ba8e356845095fda956822931c2e5dc2763c170ea7194fcc9704fa255f690462e8186af49913aa235543f0861dc79e7be2c71a134a30ddced9164ad4f5ae226f58b07d6c48730a921309688ab1ccdd6b77fa7ca5b495f40066a81099d1f95afbe094aa368d42a9336841f2a98685fc568dd79b1df0d656eaeba85597db9a5aadd8029838809a14bd017143b31e1b0d8d405b56eb045f36cd714d74e729d4b8e9cd9a48e1ee05c4a87c3e338372786696de538587f51e41282ad952f413da9128e72a36522e113fc7cf13c3b22f40e2dfee09cff05105e74674fe39851dcc145d5c975fa5ac787264541b7a0de77ac195e8d65b7c0794a9c0ced854c8549090e2b0665e19a9b80202acc3e1d1d86930dccbc1ded01d8de4470308da42b4e6e8dbd3a50217e12cfc600d3e41a671f78fd6d6a552fb673629a38f8dda4fa0b6dbfa552c342612105363176cd0e0d214353de4633e5a3c71240b254dfe4f548c5e71c426efd4bc4256b0a9bbaec41600f9b7aaa512800214efa8f61044493494c319e336056892cbe82658c6dfa1785dede73d8c0926631e344e23558d37008151f241991f22bc32cec99f68bfabcbb8c4d320d3ace860cd25cf38cfb690499f5ba1509f7f2e938f36ec96d7c62b9cea74443321030ceb9599654e24fa4fa95747aedd7fd6392b0004087ce6b7fd8f3d05bfc12ee808ba124390724a50916662f1a7ff1ad30a7fcddb5cbacb5ec75cf909afb7db4aeb35b242429b296f1ec672789ae28ffa243493c3e71580da52f55c98e75940a251458a24d47251d207b6be58425fbaa16f00a97d5c70f4646e6c9f7e00ca981b27fcd28baee8a90319cbaebf8b7b6a8946f64dfe61ec4192cc22314cf61dd237480dd8c2bfc001653ea104206e3599579e89c3296c07bef169d2e5a6f22aa34f2586148d3a640ed087bdc962954d6cbcb46d1b1e61f10f183a54a4787913222ef65a8de59d5f6ab433616c869b1ffd62e67ad66a943c69de9025ef9e99b5e574f01ea0a337569519839f7a195d598e2cdc04e21c9510df3a764e324259d73d0fafc7c7a054654e49ddc6d3b5e3af63580753660dcebe0c154578971ba26580b6cdc89ccda5ca77a06c47e8136d0fa5a517647aefbd9dca157c6d1a90a3a534ef8c86078c37960ecf4b8bf4bbafdef34db19e6cb09492746e64f0cb08a5265143cde5cd78fad3435d9588a1f8bf4d3f1fcdd9ed6e5807ffd6f94fafc48e14db0ccb741f48a5493f90ab7ef9be8e5fa822ff8b0776fc83df9fc5d4ce94d534827330f973879a82864cbc6c8cde201e585ade8ac656677c6bea85849ae617aa308b76093fa241fc9d752389ace27f14488d4812960aa5634c43994f1e8e86804f9a241727ac5495ba0a83b898d9378fcb1b0e785591c281fce55b1f823ceacc41ff8165fb54fcf27a030f0f2c0aa207bde3c815581cf63081a31f0ab641f303a2de0d9c76b7fdc24e13590ba372a6807b68b2c34d65ac2500c2e42a7a1ae370b7edb71a4a83a33cd7efae7db9971fca7eda54ad5e84c4004aa7643bbf323b83e5cda3fecf3922a8fc46ab5c95850617d5a7da75f8ada7e86e6b766f0d6b3a2b4c3e2dd8d5a6b9b18aab221d7f1c025fe1ce96af31f33c10e7957d31e416fb225aba0bb9136fd3111d9f00429582d6031f7b916fc2a6fb066695773d1e5fde07c3a3bd7ca2210d13ff427aac01efdf7f5193641dce7dbc3016be4435aea92ca25079db66152d0f32df55dbce998e0497bbee2609b2f545742ec5f7c3249db98cc8fb1cc70eba7239c038ee5126ef0e9fa38ab136a5e5834f920745ed4791606088ec97271cb51e904611660a1981540631e8bcba22a4725969d8fdac1696918c4f98a7166ddb31cf9b126e6030beb84e9fb1cf0a37ac505f675642a488d9eee53716e2c9c3d1abb2b2cc0db21ec8bd48e37ca632d6417426763bbb3a04c32b4383a8c33f34f687442c9e4e63dfa824800e3863334fe8a37d96b1043f10b60d6a612a40d9b8b432a33f6fd2a1b88d7cc4a9f40bf050f1bd0ce22ca415ceee4fa89fe1af388d869c138b6b9cf018178a2cf6dfb9ed9e08632b1c23b007a2363991ded25921e1bae26d726f4b56035b44ce03ba713a47f94b13fbbd86fa064747e36bebd86cd54c40b983ce06d0d113a124e8aa98a4e5e9fffc43e4288ab75bab960dc8e66a5988f2efd411e6edce04c67e5322ce858da7e774666c4522f9ac625d641efd64192215d3cc5a6b01504af94beaa75fe3ff8bac53af00229ff430ce24411edefe7d43d50ab248b42d46f6af4bdc78680a63ed29e09789e3963009ae0635a18ada3fe43538702536082a09a22b7680f1367e75304d89e2e99de31897cf68fe55c85364ef8e0f51bec6ee7ac68bda4cc1b769778f785825002893626334daac759530f5eb98fb1632a102ec107a3e1f1205300309c5a80572bff80af950873a82d51a34be230db4b980bb5ec4c01f270f326075d080c2a352c1cbdb990da8b190f47157f013e4d6d4fa23e515860f63104530fe60cf256ef469b31258372cf5f3c88b1981436f5d55af353eb7cef528becbed9f83b103b928148ecbdbd31cd7a90476364ced35abac491df583dd9ffff42b4e245bb7b441e8a57111024094c70b1d4ad5be7cbd834c696922cdf1028c743d377d6bfff94ceb283fc56ed8b7e80735752df5427bbb97ae3a19d7336f8a94abca030cfd04c3f629b5751f258fd9d13b89bfb9b031c49efa4bd098800f6db7fbffc62ef14312df7912643a706d3247f10367bbc17761bb72e39405c7c4330251b9a2ee9ba6f47e4596c3562f93329fa55c63e5bb4d577e50465f55270473d7cfa72b0d4d3cfc80b6ab8010aa80c92ad99c1efe0af86601ce610e65690268d76e39b7ccd22a3854943228292760a6399689d1c564243e990dbe6a4ab407da83797d0331c484f91445394177da273410e98946253d77598dd4807cc98033b5b5c5d7fd97120bf5181d02edf43ed5e988c568cf246bfec5f1918d6a6a1ebeb89765dbf38fe431304d5c584775d2599026815b5445e25b27ad6d8fff1146aee205ab6aa232217c96f532d4039afc086eacb07c895a48f40c3a0d5f8d15d7990b0ac02306141ade9a7638a6d49eef39ebcb8ad622dee39fb0bf019ce407c3ce517f955fd6d7fdfdf1ba8290ef1d3d22ba5204ad2f329f2df481b3c4b9b879296d95eed8dad4ca8f6ee24b9a02d97fb840968e5e1fe2bf779f37cdcd24317ec53c1d0fd75cb37d0245f0403705b534ea79cb77f6154f73ea31d22c34cf572f93ecfb0ff1f0276c196c5e3ffabff47e14141be205426016a0040a468840fa0380d836928064b1cc2f851b82a4ef39f45807d5fa65e5d32fbe9e9a1564c8096792a489d16f02906bde80ecde3f946eee8a3137e49a0f33d878c964137e8a4f9337e0ee03943e43873d06ab3e0e0068024050074c45e72ebfd417f5a822002f88e6173b9d9904da73c7de385d5a66031837f353dc2aff836f5be2796afdaeda91cce94fcaf0b251c898a37f90c442e9361060277a6af63a9530e16f86280751f13772e990c2e382bda27e327e0829ec6d87e10cc6e2389ee28bf4474c5fdcd2fca7c03d939ee9e7d429211aef50daad6bf30f06678e064f76e4f1ea3b9ef8ada1447b33d98adcd8594e0b5bc8cb05efcd846076a3cd5c56140d4a1873240dc6a802066581bdd7f8597598eb0cc8a937a61bdfc2cca15de731a181c81e896a4ded22b6524526e4bbc3452b8ba67f8082ff81cdd0d97a7f4805017b1635724a30e5c2b00d6d2da0033b03475805464efe0c74adab1a2da2082edb580a745b0365110af289553d68b768cb9e03467e9fb3f08487a4252cb05deff0927d4d7c813ee1865990d91f1d4cf0e1023ebd08b33dc58b7e96b17b8c5aa6aa1a8cd5e5b6170a142fd58191e3168220789a770a93f040403245ee1ee49b31d1bc067d962576d59daaf43504c6b23c6c1585bd5d7ca56a8d36f3f8eb4ce8c0a43be3ec7d44f7b910a44a4c75a317b8146a819bc37d4ba24576ff1ea2363557451784efafbb375d56fc99f94e3b418164003c29e6404ff872cc68d9f5c808612184736e0eccdfea9557a5d6c7bb058141d5754f6c302f0e302377e1f78466a9e35de34c00d59983765babc118a91381dcae06aa65c25ba8d5f89a425773bb2d3f0e2fbf1eb8cd9569854358215ce00d554df4d6626decf416c8acb9f695433e567d5d4f8e29a0255c54faf07c48b75e5220235be0fed77c993489d336a09ae5d965d734f203cce6601a474df9d4a741f7407c81346dd8e4bc2a8f87495f5236565153a67c757b6919e8c5c065463bbc5249bedf710e1da31524b448b0d405e815a87605172547c2a58a8adf8304809a5f697964bd44741adc4135683e5c1785f0eab6daaf5e5240b3410ae2a8a5619ac474b5b3f58ac184104882f1458a62d78c74a2123b12c0eaf28f03cdbe1a5ae5e193b44ddaed7c93d4e987aceffb30f1352b43279f18f94f66cba8d2f1810971195005a4248d7cc500782db977c60ed4d47bbab9ab9e5f1e7cef5eaf2f35c97ba6d84709220b0318060f78a492508cdb549058510c18aec2bf6cfad20f1416fcadc4a2e8499a8e4ba380d380fea6c1689f89193ae68f067624cd419e76d90d3aef34b669e36ed9fb0fcf22fec2f2497f17fb617f880f1ed89671508cc88cf2afb819ceb6b7ce5b0d1efb1424a3592912878c4f5bb9706483ce65c72b101615d8d4e6b64b38ab8ac75cc5667d2713e8a64657fe720438acfe9d8d06deee4912ad39fcfb40a5fcbe0f4c34e999b3adc40e9518aebd8787e1bd03c1d3dab552a6e0ef39554d20f3bd48c26dc423c91d18b6d5285b9a39fdbe674fb1c60cc9beb74832f8878aa4e19a1bc943907fac2be2815dcfdee3f3975966826f9c1e2a3db1dd1fbe220d87ca3e4301584f569bc9710beb6ceba4172c82eaaf4b234da52c574a1cb3e972fc0ec6c66dff7e1851131969fd0438a0cafe44712d9241d69f7aa9af7ddabd21191b86070c7cd2e5ae96346bf9b12d105f184cb00fcd6318a08522de6e477e88bc2213bdd7bbc7dd445e7a48335b567e70dbc03f6afc90e8a9a4f90c9bfd782bf413686eb97b2693ebf0da48bb85da6390cabf578505a5b65a47b95b0a5144c2e34ca20048a527a8c8f48e9c4eb4df30bb1f9127154c137ea84aa0ccdd3b9409d1645d8f75e66cdade5157a86bf4f8523a77316563a57ccf94f772f4f6688a87d38bba6c65943bc77bd87fa1e05beb5e94889c5c929d022b8efb712698c230315e780015d9bea8c4a3baa7a3329170cf7cd870083c717ef00f6e46531015f2fff50336360c3811cd3aba09d370a8a6052bef50780b57da2ecf298f13e63f1610810530ad8bcdb3988047c37fae837f9b9abd8ad6a217e428f6cca4f23f7f96727ee1cd11de9ec6fcb5ea2ccf6ad63a729b9d9fdff9f4c61190edc00f531b2712c96a77d71c98e7ffe71460c7bb270440365ee379734fb1c7cd8b6a1f4c207d016af2b60ffdd285bdaff539223a89d4c6368774127268863312a449db923a99d8a5f9ec987c460e8ec7b78f6f7387e8b0f8d7d2d3021dc8133a83acab3c958a42af9a06a91fc5f5212a3621cf145085c15cf533022e714facd670f14928babbbe617b3cf0105dfdae9d72bf81c2edfca9edfb9da4dbce7973fbdb4f1804bd234d147ca66d29d99e568cdf115372325e3ef8544c7fcbab692cdfac7eb3ebcba1226139cdcc49fc4fcfc8accb8e257202a6544e53b1d950687bdb7046f10f4d7ce5a73b02b74529443257e4aeb8477d018637ac6fc9e37cbf8fd2f3d0024ffacf261740daa39eac82f3d750524fb0ef629ea836d88c34c480e44d0e2836440dcd33cf5af506c3ef4089c5ea06d79138b277e3812d29c58de873e623a7ce7d5b20d39c457f56f8a73d248d02701e51fcbf0a26b5ce446fec580ce198a09731a37d5a8e4c1fbffafb3c7a1ca38bdbf440dd91743ffd0170b4877d9ce924d2209315343d3b974a54b23b766f358502e5d4cea2193ead2fe39777ad27be8c59131b1578f3721fe5f38bd25835a2f165f5b7b9c867a4311c717ad36e670c36907e39b0b090e90abfb94bc291599927fee582188142538191f4057a91a34f353a641d9c895fffe2c28922e0e494a7acb16dac6ecf58096d153a439ed854ca191a63c1bedd8efe254e91758571514be57dca1410b5bf3ef14124dc43e1dccf241cf10d9d0c4d98bcad4987706ef68a5c75a3b477604b0919fa19aed7108b655471c85def9ea364e327f771a9f8aebac2d2c6755b8d203801c945a5e4351f4abb214c928ff4a915bbbe73dd4fb2ee89835a194176650d69840f53895ca5f335ac893662b8020be7dddede68fe2cf94e5f9fa9e830f1458a92defb7df500ff00f6afb8c2174c2052171ebe7b458d49e43d0167054a51e5ee172f6de9a3598f1cd7c3f15291f4cb09e393262a5049cfb7ffa558a65bc5c039f673691acf5b9e75e5eb8ecb37e3b57575c847a0b6a994040922756f99a070126d6bf8d7e934d9cfbf30724c04bc86ce0a50c5819eca0281be2724f05fce8df6c8678aa1f08323711dd405e13efb527377d0bf679972776292d3dc2bd5db89af849b2f7518a183c877a089b1f31a5bd7fc0373795c317ee9b264557e4639c447f454b984f5858627899a577b976f23ca812d1c6617dc95acc58c4f845f283b497872f8829f360b96d0b9a5212386273b7b8caca610e49fd0e8967665b5648cd8e3214523df695bc5ab1b5ea211b099410ce2b142f8e4a10238c211f9e84cc0f56901a7e18df252f030fc1d304fb08da337e3cb992c9fd246976b288503784010af1955e758e326b8d93e45f8aa827280a502fc6f61ff4d63fccf6ae9e26d8389242de3b931992fdbcf042c226161f16ab44601d0cdaeec7bd8ceec86e137664cffb8d64a655443a3d892983a713541de95367360345f46f75601f44b39a0dd5a9bcb157b806a4b38de6f0b6dd396889d41480650d3eb49eeec79a7c0d725170cf159a7f90d8c943b513a892063eee0decf720f64f1e435cc591283d6dc2d6bf72a5f21ffe5c37df8fb71c49567380a0d5efb0209bb3f1ba901d76848a722b6d2e415faaa5890237eca22b45f0fe16f7c267319f51d6c340dcb3820d7a858a051c2293f7a7dcf778ccd7754d75bacc4e9555c70558f7a0c01103b5d694b205248ef9df16ba00c4fc4ca5a313df76da7211825a3c16457fcdfd10e2f8defcfc9d85c21e8a70ba074cda1ff04ce539876d67d0af998034b8cdc5d03475b3b3d4c6381d02e159a10197701498393b69dae978f777e1a262a61f32212d17e88f48fca1dfe8ade1db4e02f43c9e49753c16bf0a2017bf72075b80613f7ae1c95af9020e8d3f3ce01ae9ee8b26fe1ee7bb761d98498b42aae7b106315edf45fec2fb2e3203ef4372567b83d7ccc07afd1e978c57fe283e7dfe302a9691e40a650c9581eee0f95e25f06aed43c6d0871d72748dd3a599943413754c20fed372fdfdecfcdefce9fdff1aae4fa7d6d485f545bf07f043c63be680e93c464776accad4c2740b6da161dbdcd1d166d8314dd6e6c90a3e2b8ef68c794160df7ca756cb2afb23f2060aa3e026543de8a253797cdcf8af73069eeac61c1c5fa231d82002a4eacdc7fb90be98869082e16eaf30c98222c2c5950988b44c8f4efa9f30ca8ff2ea840c5eb715ef9729c4acca3ac5c55eb8b36487494b644be2b161e0763889ed589afe89fca17ac21ba3f4b3e88aa97dd73094ef48215de8b1e590622f03a480ebd79b8997c754a28732f97e0c91c63c50d757ac4845398125b15587e63d4a0f0d16248b24c46e57d93c511cc6a0d81205e0197278acf280efd6f58c9e1a3ea98bf9b413de9ca9b9a8721f174dfc8a9e0ef74951a82b0113a34551972b1c1d9db70215ce4e3936b7e3faf1bae0cca6c956d6cc62c5c18673ec23d499ad13aec06afaece940c135a32465b58c007bc40e7cb0f30c3b7e1d99ce58edbfa257ffd62834e9f18dc293ef1ba6b6e45db0ed2f0c9856796d5acd82f6b65f12a77a9688138b9702f6cc0931671c2c476029db313b8c9af126b967627fe6abb5238802cfc7f1b1304e1ead423cb5a14e68e3868959eba910272eedc54ff98bd3d13f8ab78dab8013c8f1202448562a2313055cf3752ee4a6a01941c5d5705caeb1dcd4c8dd92f5937d57cfc85052b9c60cc03663bbc3697f99c9a27c83edb13966f7d533025c77a1211ae02fe4d791b84028c652c6d1492aeda9fd4d034b47db003889ddfb26d4e3e28fab61f009648a4fa390b63b83f03544d095b87db1b1d40c5c0830f259ac55fd9d267191250b554fde8d7ccdf9235fefba371bdedcd96376d33ace857decded45bddd14b9b4cd819cd9430934452223ec41d6bb253ee615a461f9ebf26fcb107734bf4d1f47b72d5ff3c4491e697e623084a64bbc3a77c3dc997e48d669a440a9fdd27e682e61e89cfb320a57ade4b3ab34735b70ae53ac280d9a76ed229cca7ce17acf5677d2873ac0a90b76009461b2462821a41ee3b7b02d90a7aa17a17b77bdaf89de08e51d48c526a5ef55cb08b2365101a24d7d6a22673d50453f4c3f638263125289cccdd842cc88b3039dd7acd8b20a68f6f1677fa9524686b599f4abbf6265631451334904673b9ead32059597520ba538e09a8ab6291285d2c52919f184dc2961df0ee2ea7dd85e1221bded00ad365f114bebc1ef89f4124761a1201efe18a6a4bc4ed57f3539412cf106769a4b807c9ee98a5b8faf46e80d47ebc0886ed3ace187a6d16f067be3f4ec7b8881d5208e5304d82ddfc971e408908d3f5ff11881def1133cae399675523b009d457b5aa1f9960cce7a2c6790e503690ea3d60436fe54d93a04be6f9fd2c42a6028732cc3ef8cb33e3469c78bb13c118e7f76695bf4b0ffa3c6ae6b21aab11974d2ad66daeb070a9ecd690f519f91fa935dfe7a7697afcf786294cfb0ae7fe6f2c8d65b088d1b0acf000578ad57dac65d1731cadd5e11017c2e3294695a8d102ed57a2bdaf0b490a5a19b2960a3287a385922dc0b49c281aa8a3f7bd13aeccb64553021769fa58c9d6fe56470d29382f84952a1920e9bbb9b44e6fa3488b3f21112e2e5076c139f323cbe6b792885ed86434c263d6cd725c15f2801bd3a6b81505ac7d4f8f0de6a97f965e06487750c75b4416f4d78fbff139f83847feb2b36041a3e518b4d4f03d19642473ce79d38b426fd2f50892fc6278e82c871ed410e92be362cea8909264e48d665e888ac16063af29f5c0affd6f7d06e2f820f5656638c676a72f1bb8eba7c6d912948aa65a1643747b154dac81f8c7daa153bf3ad3f1629bfe5fed975df66cc0beef1ca56b5108a1e9788f07699a12b10536168325351d2851f22d7b9d3ce4b6ced51cf6ca704c5a9975ba169b8739c0698e7bfd0dee2235df58be572aa9bcfa87a220c9cea267cba5ea3a3634b248b484a968f5e8f5e8fd45deaf9bf903dd0df55eb6f0fc926339dfe5d431a2a6c74ba5cdd9bce59b8a3baca224fcb86ce657d56a2a74a4a1accf35fc4235dce1f3d14d63893de05f902e284384955e35f63da9b57b0fd61727863b72d9455e480b439dba7caa2854796b53d36b55ef717608400540a934de7f27cb16d50b03b835f6e195a5ce889a46a0013c22b1f0e7590f37f3b9764638a636d70e971b2240b68ba5eabf56dd0482304d4b108a1c868b8d79636fee6fc90c22b4d356aa305fdd217ba9700510a2f8d12e8a678540ab0f0d0a0098bf2558a050c04e1c0fb2650e585e6949b46ca8fad46c0d027b780690622b8ef3acd49e27a577a7762186a3b395a0f110d0270ad21edebe1801da37dea629dc7621c4869c25f73243e7b34b762ee0acbdaf7998d178e5e8844643b99d7a53b8fbce37cb9902f0ff69507e1544c9b6ec2df3a98268ef96ea929fe6c3088dd3d12a63147ec2070908dc73cdfa20d7881edbb0c5ad92590985954f845d92dcf1ffb0cc2794929d4ca93333cf079d8a74edcecba1c94ccc88565ac8b3760a5b6f9ee0ff2a0c70cff4503fe6026c481c92d833efb5c07dbbb1d3ec2dd6c14de0a160d1f776d9020965a24e598250b550abc2a215b07f7aad41fc6b086afcc8e43cd62467547c93eaff4020cf44ade9c94229051aa15017bbe03bb4b5addd943811c388285f5db8a121c3d3653cf43ba07d497febb71272c08cb34c06ae5cb866e534c15ae71243499dc3e3a027af04f42ce31331ff03f4d3ad246df1654f8f5871ee9c91ce34f967b47af41f3ed2d43539f5ecdbd3658d88e832cb6e212241ccd55a097bd5273df1e51e8387e7c1400b3146b88888c562c3358b1566224caa38db46f44467fdb8d443fe4ade11a4c9dcc5e06917741d1de452dc780f5a47cc6bc5477d3c705de78873935984f31d290720b9bb6f35351133026ac08ff251b87582b5f28c98c921d763676ffec01594b2130bd7563bac402ae917f0149921c4ab6aae41d9509bec2ac280698c7385ba12599bb13f201b4f3103886a89d7f6fa574847e10483e0182c801721e4713e7139ac75622792e483becbcfa7a422c114e518abdecafd5bf7f5ad188dee2153aef2fdb9c98fe019972b1c54e812d5a2f2fb23b529a218bf1ea9460399446ccd2b95f03131b626b1fb37369bbdd1c138fcb0190e62deba12f0b3ba04712508b14a8b2338ece4d112ca479d7b80effe3297e51aa986f7f3e03c1925543d10b968e775aeef97fe9cc86f5c4378369ed8efc2d53dba739a4f59d4b5ec3fccb7eaa196ca47b4246287ea560827448d0c51a2b271576ac9e9a525178a32a47a85d6303c31bf4745d98b405bbc9426d80a50f6b402b0b0a60c7106e984aba298f7143a127d853f8290e37ed21457da338ad5b384f812027de78578b31e1593d5507c3b9c5b366be2ac891d5e9513044a855cfada1322315c775766aa3908de20dd7e8e38f030d826ca216c72a867bb5c9bf4119398272c7cf01793b2e87c4f7220a661f3bbb2f0c85f93339a9135adf117e9649a3cdc27591a85076bf173cd49540ca5e9bb205da2baf0351d01859ab61bc3efe44f7da5fa044a48e2f1debdf3d6bd98107307e1b3e0986865625feb4c2af1dc3c878f8eb228af523232ba61b8ca51ba39b26f6985da8dcf66a59bb454758c346fccde8b9245b604343ed92170f1483b8e73503ea8da54ad5190069150f14fb66768644988b437fa3f36d1547a2275f334e0cd246429edd29b9ad5e881a834900542bc2c80b19091c56bae79cd12fb936c83b49748550ed1285bc4c8b3ce23ba150c6d89f4e0e38e1f4e00c221911654f094d4e71a9e64447571da74bbe2b695a487f08c7ac361a144a0bb7b396c39a9fe7ea97b862535c11d0f2414ef73b4762dde223f13f804ff881abf9a31911d01af46232230d51f543b66128ca553969698593f0274bf78f4fa401875ca65060f4c99d78452b2ea049ecfb5949d8d0a2331105a38deef35b233c2ddda80b53f9f406e252d9d2e9b8e8987c7b9ec7774dfa1f6cb1bfc66f3d27b5aa24ce60f36414c301e17bcf69ca2a4c6a64afc4b8c05ceb2bdbf70f03d291e33d90bb9f8d0b322546e56b87763f8b69d4f6ae222ba5ed0bd3f307f62904381d77d2b9595cbc03b9018f81213a071eb7e275deb69ef9904a836c1eb8cd4ab227dc058a191f317ec585b8033eecb7c2e9958ac70b5e7318e45c91d1bef4e932e35749fbb91d79f1fca1988d955e98d04096a69a696777985080a797f77145e038829d324610bbbfbc66c2f07c7f7ae1ac75545a65ef3b229d17286b99b07aa7e5b7869ae42c758d77991697790c853352457c8b5d590e83e158e07b2573197862ded90dea08a926353186dab83ff60d2626be2c02b932859b792372cae7c7b51e40edacca8509a028517cf1be8a398a4d113aae109dc5935e11c770b221573d1a6f1146335e0c9721a135bfb55c148a2f282a312d9c7f00acd8db846b266312541ef941ecee2413bb2c9257ca37444f6c00eaa213516e9b6f483daf627e2a682b6a2395140acce27087c0fbd2a4ebaa17101e5c4f05f9b6c3b128e9ab3b9d33f4415cfa8cf83ad99285072216b093bb33103ba9682fbc8e2c415dec58d0ec3835dc43645e9b7d1795764a5ec23dabd9d8fc7e3a9e1fd9fde5b0d35df03754ec08b71ff45d1137be1c726b657aed68c7d8dcf408234b0edf3ff055e4aa36437ee796de39e73c99b8c1742167c4d1e623c31a5ec0ad0108452ae8fc5e2478ae4b9bfec24cc4b083d2222eca4f7c1740bfef7682c07a1392f6fd778bb6b0795ebf3c143ccb88d4d4d2c113c72632a2a8dbe6d7f35074d91f6e6a896e484b800d70da9e793e169278860dcd8edfec2912428dcc3a6b9a2c2490fb60bca1f1879200ce57801e85be8eb5a6a595b22aae9460</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>猜火车</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E7%8C%9C%E7%81%AB%E8%BD%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="66d8873676a4a4218a91d5aa0e028d74537499bab936e120376d6093e79b48c9">e55e8fb0918b8b65d60b5b09d6dc221ca0ff0e3052b28133d3b019c26900c8ac3a7e1625601ddf198c4087986a5392073f5723fab736810d8ecab0bf0e086e6020ef4f389e56da3ae37627dab58fb2a46f44089e88a3f3a8219ada5ebc96d73b3d660130a6308eb8b3435a51779f92b7cfac7c2af06679ddba320a325c7e6f2076d470200aecc2eb3e62abd0196dfbd5ee2d9dba2c43b26d1e0f19ea411b82fab415c6cd165d8e48142cadc14a634b1790f60ea4dd650080843baf114c579230ac14a3bb0be7411d553f04520db48b0146a961bee670c54968466cf6f9bc0e93fd5ecd6ae1d480af41b4703c93db719fb89547e03e1931d3068bf33072bb36670c92d22ebcabbd8da67fd982f270a81e7fa4a610078d261d8c3aa01657b7a854e7bde80a9837e71429f38126015e4506221e558343724ed05f0c47177d69852cc0b7e62535a0b9b04eb045e23163786f233bab1c67ef396653e220a04c556b1279ff9c83c04c57bc17b269dc4bacc68769fca1f231bb187bb4f195e8ba17cd051c0788ae887befbf605198192a2e715d7a80026f3f339fc5379f572bf7cd15e03de3f05d44e7a5a5a775077b9dcb17f0d795f0d88c1adeb1b0a56633d41b6eaf6aafd66766c887a0959f8965f0d03fa250c00f17e7651c747d49201abcd317e0927afb3ace9c2d667ed58d9973341c0c48fc5630c41612bddc2d9df1136f5cb687fcf1e6a008c9a41fb0becd9bdcfd8fcb996970380a9d31ed7b47d3d7eb6e23b96d6a1fab2327f4a6451fb8d69cce9a177839d0d63b7ae546cfa398019b6cd6af0eaf5798d29f53b3d5521d22e74b4d96f727845e12540baf674d3e90967120698ade4c849a4531ac313903929caf468f19462f085837bd81e27ce516e351ac1ca59d076f222bc0cb8ed0a4e546f47d06bf112f0d97304c43ba9b403d5dbc2366fb6be3ca913194c92e2b158e169608b1c672ae03f9c7e9dc8761f1677297bcd280ee500f8f4ae7fdd170eea6e19dc68fd73fb98d09d9236b7186ddca28a57ad06b239d7a2427dde5594eff0d13e11cbf475d2644a2dc90234419f4da83bef778275958a1f74358293cf97d7156f2e1e6777498a81ecf879748fea452c45e74035045f0095080f207d187da77db3cec086ce371a2ff8229c54115891a4f77b866e1cdff9ddfb1ea9618a34f307d59a2135c0f2f8fa29d8d8cf0058b3648158739980f1210fc4d908a5fb6140c801645163e1dc390492f80277cf917b07b515ca6c580d9efa673c5af78097ffa4a9d8be04bc41d81acb40db71ef00e620388b3b2c03700e88f9c48f059d7f5ee71df3ba594c0d05ab6cf3518984094fb2d58735c7325767b3acf6c311a70cfb105544620928a574e350671e02028acca21bda503e23fbc730aa6043fb78bee44fab98d06b478c473217e313f8f3e203a12b76de4eb7adc91638125b4d73f817e0d8adf8f07f940eb8f8513961412f7f64c5b8190202a3a83f72217bf87a8d931debb1bbaaacdf8ed216595bc416263e9b54ae23a231a7be66d250c4c17bdcb619cd1c8d9f07a72965cfaa008247ce87998273317dd5680cba21a4c77b29bcc786fed2b6198e0cf73df48f5bd23a121430bf6c7fc707806f521946f23dbc271ee01931672aa7e8562764045975a502b8db708764c16bd329dd0ebeb318b5afda7a398108752620e0f346054568f71a7ca9c60e4971b6274727f94f9a1e181f9fec0bede9ccc3c0686484459f8a49268194d644b46745df90b22355337acef633f187d73cb5ca87b2aedef98b9efdbe8cace93201f7013d2d5134cd71d6a72498340bde8a9c5a8779b3befc15287f83cb46365b9be29a9f20fc1ed9bf9f8e4d68c7ae956eb778b22da3a76256257f4e494103bbc435223cb5a2aab8c492b4a2e224d4206e98aa0593fe030d5e4930de1fc89d6cc95d8f91e0a1d4f1793987f39134dfee85d1beec602d15525a197010a4cba88378b89d0a339632f05632ba02af08b2123ca07d8e2071b9b467f8baa0bcc4dfa8777503ada2ec155f52afa3a39f159c8f8c61ce96576580175068eba5256d98c08e57c31c2c568e728363f9b152c9d1e579af2d7cfed731f13f5ef37b40622c42be6c64fee82770d7d3df2e997009c799ec1361e98932a6535b9267d719515171d3ae26e97ce95a82ab824d2c36a4da9cc32a4bcc3caf065eb10cb080d0b95362ca37492a58c53fab1502be74ec04df787b0fdddbf3141b7ea569b29e13013128f5bc84a717d3c7f70a96d75d2e8445f857c47266d77e8a119dd03116fe0e3033ce38a430c78d15efef257d4c3c367f52f1d217f862cd30cd84661145d5f454b4d9b2f1852c89d014baf8a6cc62cfc2bb97b30b20cf6bf6b4f898e22388c2df69781b21093ca67c79a6ffdaf3b5c7bac5483c74d31ee2c3f7b7331a9d38e64172b5d964016f5556397e2ae4b15c0a09e59e49cc21980be7b48104338a26cb7cc2ba6c4013f8d0ad7ddf4d3d44e03b29470bd3adc0017479d4b906a5bd72fe0afeb608cec4860c90b397701b0b1d7b45f00a8f26efd210f856c83e74fce470e68305b8b75b59d5b7ae22de869ac02ce7317045471df533fe4d2b0efca44c8a85de461812f6d57fcf354f33a6fee0063e12d4856e202d536d23be3365742f745894b9b35e4056375880209f455fc27f07c4baea3d4acf75145b2eedc28d033a0d13b8c2366cbcf29f74ee21889d7d31de073330f1402e06caaf0bbc477a07e471c551189195e86c8edf5d310e8a36f80750a183c2f0b625c3f18b857905e6afdbd6038c32820fac5cf8c52e3aa9f3418f6a57ddfd304013954f16e974f5028f195486781b647df23d4786332e977fd85f38b9e2ba551b306186e50dbfdda00fcb29cc61cd6aff506f938824b08767a5729d74468ad15a3cf0b5bfd2f6eac4a1837aab4fcf712b7240bf2dc4c5a86765dc9f2db08970fb37636992acf2afa61f34bd9537eb0f6abe7362f4573c2ec89cf0bd83d06d73f5c4af13c940e2c967735c72dd307084fe6ba2cb02e561e94dc6c9ecb5e322e327cec8f6725262a8d9475b0d811283d2aebffbf0458bfd356822ef42da510678b1c99989e3bc697c808e78d0059052a287eb232e08afee2b0a53ffe0fa7be1cab163a2829430daa351950091a933c1e053bde4a017cd2dd8fa83382a6bb5747961b126e61feb73776246e9084d1b4b38f1493b6e776fdd1bcb982806fee4447ca2b3b7989d6a716ab787c47f6d76dd632d02958e9266c929f67f209d2baf8d30a7828254b21255ce90505eeb69f669d4fd913c401a49e3513456baf53476a9bbdd5a3c4412cad2680ee7f679ae7fe3e10751cddb4173615dd7f85907130c4b8b281f1f4bd840d2e1a319db0e0e4aa08f8f994b648b97cd397c4d6b68df1cde62724667e8b11e88368be77c292c160ce74a0a75b32254b6f55c1615168e335c832884631aa2346d88aac30f341af5b7edbae545350834ab18a19d6d69c2c19652c1c6e8c52ccaf8177bc099c466abefbab7ec35f8818ec81a215df5ade96b39a83c35a9e65580eef316a1174c914c7cec7ec70a74c9da52af2540af7dca1d5080278c297137bebe8f6502d5079fc89a295615df369510efaf4bb773fd05fbb5d977d41870c6dedbd4e2f6f79f952d3d0c057c5af39e460e6daa94c073fb65284c74e4dbf89ba9159c27c16abf1b8bd71d96e85121391df6f1ce40854000187c5d94952eb3833bfc9bb2f1c56605280c01833ff199106d74df2ee9eb5ef7eb8c2134ee959405adf7dbfdc032b8df1cad09c4a65080c9091705afd33ad17c59dca6e3289c6ef940fbb68eea2a49f188a42bab50a2adc6e01725092ad8c7262685bb097f33a677499992946d65dbe0b8f08e7b50061246b5541003ca3c30fac1fe9e490967b51248d66b66d5f6e873d9866489a12ba813a620deea11b3ff45a4eaa2c242c2c7dc4539c843f9ae7c53891794bf3f125235164e22af572bbc906ae737e5eea765bee1d796469f7886b2ae31592074d6eb6018cb644901123eb7c425abe0ea4d5f437e5aff05492ead4c67ff7e62c07a22567565cc9309b347b03a2613b15a538d59cd603d1f76e19078f6e49015a00be14863f3a6a17f31cce013cb4a792c5848906893f17ae04368290c26e0edbe28aaba611b513add0af0979dd34150f90e37432310f6c6712cefd00ae9f2a2e0eaf63d795655aff4a376be7a492d4ac7d138b2ff289c9f378038827a6d5a4b8d5aaf54c3d6da43c18f1a491eac20e9b2e1c8cd15eeb25c38b5046c40412d055df9288e8a811c00f31f48683b36976574fc6e0125ef6e34f74f033d1484f58a16e72ac891299fe52389d66ae9ddf9e88df095f6aa826d843833835ae939baa3f5d31e23d1f9bd682b665b5b8ebdda268da096e8bc74c86c72c8e16241770e1837bddc64ad105af2bb632cd0d4058becb38894726176f7925b643f25b6df93ba2ac6dcf03b896f5e6194833976b422a26839c55cb93b7f9f40b8af372d2f22c206f9d2e27997fb4e1b2c0e2c8b610bcbb186d718e820c609cfb953226f10227494ddb6329ddcca87b4600ba31d09c2cf70ae7b1aed870ca9004c09ae63daab8442b223984db37bbd2b1ba3b1c291ed18efa04b8cc3b221ec3883a595f16392297bb8c70d9cf5ac7fd945c7faca23f30bd2b9b665e5c7e1f468715faae02f28244537e73fe87b53804663fb29ad274a7f9bfbec8a6a27baa9250dc59d3e65af56e655d9eba3cd003fb25c6c6fb45ded2856066328eca6e67add5d2f461bfecf0afd602670ad5ee94eee76eaaf226326b5c6feb530c505a7b9cb8b75848891511ca96f5a282751e0a4d0327d7ed23747d99111ded4b327021f03c63e2301a1923237fdb0071384790eb1d644c8d5898ae04ef010d2d469ae96449ca7e22133363a53550da1f17d44e02172087b0f5cb017ac96ff237776d966dc6e8af556b4ea4b524896f40e00990c4f12ef93484fab950808a56e0ef0eda3217b7a60999722625e6cee62aa84bf685aab82383523ac3ea3e7737388ff2f22e35f7ecfb0c3746b8ec988f65d7b524d73e7279a3230668de75acbb77c516142c30f1c66ebb4c150843c39d096b36c31f61afa2ac4452b8b2f8fd90decf633d54d5489fe5acfb1ea470769c6b1cf443f922c0ab7bb75bd745bdb8a1909d5151134613f44aa2b744e8d80d961f94990e3941bdf4e2f3a0c7e4e0bff65c96210da04b85cc343f00d77bc6871417ccda265c1e536687fa6e71dcc62b6962b0340a382f30b79b005514147318c350eed89530fec0ffbd59e0547fd3d3950fddf11d025fad307754afcb56f418d14bc90db663c6b6029edbe82d06f5c23c6700284ff6be89197bfee3726435632051d6b0082babbf007ef3342f47dced906605cfa41acaa22baa8abcf35c1955b53caee29d4cca95c82619ed0838e74ed1014c0a58c9a4b0519498a75fad8c88cd1b8dea252a7f7f70405c27d4612f4cdae32ed1a7f6982a44b1443fe706d6a69f9e71c2266ea0be84abebbb5c5dca74b20ca99025e6fe2aaacaa0459a80688ec94cd8462d7051de1db646e914437da353ffba451674ac891c5accbf356711ce0481386079473dd2715fa1311b685352e4dbc78652757cacfabd8e1c3dd8923f177ecd599bcc5adf79d64192f9a6d775af35798e86eeb6e13574c311302f96bf35c5c14766e825f5649aff46030adb8ab642984bb419cbd197d63b91aa3b0defbbc41ab8762c84d81f0f57004fabd6ed02036a95eaa22d36aad8609da0bb6e68c9d93df9a75ade9c5623551e7dd5f21c343b0fc041e706db5ae9565aad140f92e4a79f8162bddce2f0ddd09a375b8b185066f4a3405fb0e4cba4b85f4b378755532218b1b1228cddc42fb830ba964ab912e1d88e2f2c1b5a4c4fce7fd596ff76b84223b58be11c3511b10709a9e992dae2148a3fac2cb5ee4f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我多想说再见啊</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E6%88%91%E5%A4%9A%E6%83%B3%E8%AF%B4%E5%86%8D%E8%A7%81%E5%95%8A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e1cbef1b62ea2903c8fe9625439df4e21371a11a5fbfac0f5bb6ae3b5b419554">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e7a5f9bac6f6c3cad16e5c62d3a5cdfda6d094432ec2372492bf00231fd5e7bce547610cc714a8b5793c85e740cada62a4c3e366539129e120e35b35b6412f3d5333310cf6bbd9eae36c7e6a0af6f1fae6b4c5f94cb74fe25085d7f5ada19cc0c163025dfbcbbbed52a0d5d313c6d2964419ff57799c621e0281fdcccc71606497424d7600cb801986fca1df24fd3f372ce80ebb0c0118df05b110f5c412aca81b2533c6c27861b1c233c44571646d72b14b3ef4cefae87df9487bcbcea9c7aa50ff129a84c3c3b0a6d5aeb3324527be3d2c40c920c6d2af6da4b5f9ab81f8e94d1a9ea2309aea1b823e0935831a55c1d9f5f73476c9fb3c16761a35e280deaede39abd5a7f9bece01e30147b6d202f4683a72f0ff4134232c885cb03fb47c240e3134ef8cc54042e661285522f9da20b3192194c9e9be92d0d65568268d9f866e64dee853348e5d3f0f14f1f67be06f7a23774ce06aa9a24ab6719ce9710f35ab6d575e40dea63139963206297497d900bef6aa855c78418864d1bf03fe17d3bd2ec9f77dcc475f068bd737d630055296258151239c840b597083d86162632350f65b7715ef45d3e71c6b7edec9c41f2e481bee55c4ebc2cddb854c74184440106e686bce095199ea6fd3027dacf719266ae406dab975dccf11b214e74ae3e11c772020bed2b2faa628c44da5b626a844b7cfe815d77e31bb9540e20eeebe5e62dc9c6c32fef9e880cbafee4f00cf45090408f6607f83ab3c0355240a0879efca86697c973a580ec25d054ca4426b1c821e5f56679e1daa2adbb345b5e0a154ccc1e5d67fcff33063fab51d838344c3d633c506aaabd95b906a80ffb418b019ec6bb1207447e8ca77bdbe845b6cc79bc16f383709a7b4729dec7344ee67fb7880d89f320e2b661f8e91dc2be5ce95060ea326f584658ffbfcfd25729aa16f0bc2350adc44ebb60f3240556b776c71bdfce50c26698c3d3e8ff65c627d1c0dfad25c0fdc22051164e39e13830f6601dba3cde13ea07029f3c31d4337f139ee40e720df4a6b9b210fc64a33314cf1b61b5c8f3e626f264af0c74549e4c9b51e2bdee62e9236e6c5d3f8450be666722954b06316878aa616a69600445d5fa58918adfe73b5c53a03dd41b958a469ccff419035ed33eec78da4f53c5a1a1e813764a4a6f2b90d7dfc470af91cdce7975b24670e0f4c3ef26501946fc95e4a4022decc95974230e6c343429e29b2c1e50d59a58f65d2bf7a4d3820073fc4981733dca854d0c384f69b90e2c5fca2676a1c44771f96f9ca2d63aa38e3f2bc1d35f503af87eb34b2cec8bd66b32146625cc0c29ff135b7d39a2989ce10fe920e3e4732a83040f18b19f701d4650bac7a869e773891545718e77d1899123acc884c953e8bd4cd748ebb0121cafa8defa8877bd845dea3b070bbde8561a72b31d41a3a203077580f2b26fd4ff44bc9fbeccbacb3d4f23334ed86983e764518272a7a91267eddf52fe7327ec1b31b1033939b49e7c750da04bb10217484dbef0e968295b476c43b93c2bbb4e1badc98ec2bfbb73870af0bbd0144bc653488081abd0c3b742602ce4e00419500ce4e97f34072c109308f26acdf830f07edcccc50ca445f1caa89ea6b28dc2d32685c41333c51977c1281a986aeca7097f615a16226a7fbbf70663c4fc63b8caf6617ed99e6b8315b056105d9d064026c228b8e2e0b2da00ebe6891dbf3c798ea6b31d21b7e2ccd97e0b83b07622bfa8a94676a7404cde0ab6e9c4509abf6daaf285388f28143ab8da0f36095b2ae47ad70d511ed00450cb0bebe48b776519c968dbefc0d6756e877b4352904306761b1d67c9971667badb8a516d1f37a3f5c7d0437d46a73fb5ea520c9e3a6bcac603f540955635b1e100fe8c743ec9ca07fb1a5bffb0ae9d7837d4b833097748a41ca71f9c3f0f606b5165cab8d5ddf2f7c4707f4a69faab27ba768dd9bd6547a818a2a477c5c5a1e322b23e19f6be5354d3da994114a4a054d960b8438d6a91ab2c8bd3b2aa5d94bb7b704ae212365c4cb662e90a4135e6d3180acd6b1e54a5d0b2ef386e6de0328a55c9d240481f42d02e65a67281360d8e49fff3012a1b12ce44c0dc4f2893cb3cba394d3e1aa7c02b198c61075d58a2341ea7b024da84375759fc5b151846ab8087113160a99213111b043be0839667e17b4aca84fe4dbfb3d6dd61f168a7b65c883ef6e1878432438d717d79c8031ffcb41ec8c244c33a5263ceba9b56272fbb19b73a88fe2c0c3f4e9ac5fed749cf80fca49a40e70be73f33f1dc4490ba7e4e999f4ca8aa444d12e67b7f9b0c2b11e596361124fe7dfd933cc7cf2cbd42ddcafae5de2d4a9f002c6eba8e35213986e77d7ab2c543136d0daffd8d1481bc4de940d578f962d0badb687cf6f5a21ca0ed307059edbec5d6905e4735e9e9af1b31ff95de304b448ac5c3e7dd32f092d81b57cc4a61a0ae9bda21f53bd5c1246009afd2da1a3b04b12c1af29aa1a4d564b95d99010e9391331a52a7f9321cc175eff6286fd9b5e1d30fb1a6abde10eaa24bb77880444bab4d7bab8e84aa38698782f954c71b09c7bbd936e97fea1c050ec85c641dd0fb0632666ce33db4472ab295addc635a8742167da91d3017bc1419d75cfab5cbae23a44730454dfb61bcfb422ed5819e149f2758f4867f7ba141228e0a064f39a1bf9e253b33a8ade662b7af312082795e790ba74bfdeb14e12db368f3a0fe9aedb29f1cd79d38b6eaf2e0164fa86d1707b98846a4bd06acd37a459e4ae39c1a7e54cb620c25ab9e698d8714a8bc7636d61580168b9ea1f4b04c9949c3a6e997f04ec5b85732bd727791f5d5545a31390f967018fc6a87f5980d7c1c19cfd7824f9b9fc43311c634720134d79092cf39c0fb95de987f05130b946709443495ac225fa834f8bddfff1c15ed3c56cf9bed7c56557153ad7044267ab732e0f0c935ceeff0c12def8e2ec8d54a67932de537eb9554ed00d4e2e28d7c5b3b7b55a0c0a17f138f581cbd612aa0f372bbd7b128ffe0b5a3816169e8b06805501ce4bf070f4590adc1eb4acf3a49f37c4b8b86dd13e9f7fb904a2298b62b0ccd5961349c26b841894be2f42319b95ebfed18597c2c5b69b55481c758900a445df26ea9dab2a4cb885d37df751132e96881da67a64fef1ef1e161956ab2151d12bba6e17c6be96ab1e95accc16cd923da733cefa922a53c94538e5653cc7281fccb168cc23e397dd13525ff6057791a851dc1b4457e7700ad9395ac780fefd93823b5f6f7cbf5622d2ec39ced4fc207db8f62e59c5fddd7bc9813d2cd4878bceca5e7b43b12a57087a1b422ccd50feb7a29922f6d0501e3bcae7d7a0c68527df28225798441c9329211709480159db41ae1c88995be6e1781b841dac3822ad620c7e1cefc430b8b07a3a64c86bf74a77706f9fea73bc0877184f9c20cffe7919c79378a459bc97c121e31d1a02dd3b506e8f99b50ab4ae9a7ae1643fd3127e612cf266da495c175e52ab4d9b64af3713239f2c618f0e85a5f6e51469ef69b481347a75d6f2047342128386d10e400e79de2b9f75756bbeffd65ff22f681fff43273b430e3533b88b397a716c159b26aa11e9689258c63040fe3357cc94b49505c05e358cfca51f520604a79603f0bcf853529b1036c559b586ad12b7c4428fcfef36e5ea4178b7e32bdb72aae461a12307b7856231b116492a9343474a1d5a5374bd49a0686ef6ca0170228634123110ba0033bd19d8612b7af43247b8384a00e7f36d00f43f4b69cdfdf3396a93928bfa8b965668a0cc7f7e5c14b27c82d162583bf7fa8c690577d09ae9a84be30ba7b7536cdaf06cf8fcb1dade6f316f1fa175c2ed703c1dafc6a857f6b5afb2e7a97d65909d6365b2890d108cc59a384d7e39ad88a217f079ce9ce14869f6ea7fc244f00e1fe5e53c85e0fc3e8221f8cdb927d7000f4609b76e392f6c2166634d2f5aa0debd3e3d5d34cebc1c9a7f0ebe2850a835af63d9465dcdc6a2d0c1a15b72acba8ba9d6a39f28ceecf1579d5519ed92516509f552f74be05c3d5ee67e94a5314292bbc606323d1f4d0aa32dce7917b435d031840ab28663969b3e6e353c6e062201b5f9f12715645e028bcf0400126d59756384de4b847c501d39118d1f98a3aafb722afa2b46287e68f0af052baea7a911b34879522dd186878a9b6ffd1c4aa3ae906d801e3288a05c637895a94bae83911d1343e4b192b6fdf8d116f789c555f3f564dc4c818533a138e6e8bbbf60d83ba4891fe72ec71423f8a7eaa4568fab39fc9afea1947743a6d5c19a81a8b0e25dc1a78c6984a6d48d51860c44d42a71dba6b6daac8ef814ddd32eace61032c3c77a43eda8b827b031deec9220511c705991382511fee36f09fb094e9e4d826e9448e8c81581d52da133c41605b3b52814ed5fabcfdf48fa176583952564d1bbbf8aaacba559c546c73795ea94b73c912f2a72813c801e70a14dd4066d0833f348b731e8c42339495f8dcf90481c1ad7288b4de5a1c7770e8657a661bada0cb9ae624d21f3771eebe5a8b4a216a9a4724d62750bf510a2bad3967325181f1ca9681149aba296b169f198630e50e2ddcb95f6525b47888c8b150cb958164f645cb367b648203b916211d65235810fe3db282cedac593c46dc4ad021014ba62d7ed27e71de1985cd2e682f09bf30b55d25501b51122a2b180b8defedf090bba8216cea03b0f69e490cfc0d6d813081c92bd73d07393da29322be20c8c5bf390af41bd948dd1a80312dd3fb117c4acb19b2f641ee7cd9620877ce738fed3099abd309cee03c36c23fa585bffc1d53c0c5c6b024185c826349ffbb27200a91e573d8bcfc5ab1202b18e8074b24ceb63d629d0474b8b35f3ae864cd94d9f4e1054706e1239c45b7a0b96e9647d9503cf1846e8a694a4718c2c78601b4bee0b3b8473ad3f1dfbcb9ad25819cd6ea39104c14c6b466aea60f511bec3746ef659995d729060718df40a6909c47c4990681f80bbc4fd464ce06b3feeada5d4a8f8d657d4b08e1cef44884e7f5747e8774d93785a0a8eeccf6b4bea7689a09021d3a34bb2486e437062e531b88b838d1a06cd5613fe0020323f06f39cc41a28f4938e6ed0cb626eeff7b0469ab9f17b9ef865cee11412a065d8dd16c5564288284b59e599b59621151501038fe757cb29b8c520abf56918d7509d29e2fdf9376720b73a58583706c06d0e45f7de34fb77d44ba00be386dd47c53ffcd9cefc7c5f1847ca251896629ed664f98c7da9b2a441f361b66291b4dc83cdbe82f010d0320ad8a6f2f12e71a6317a8fb826a4e7ce36379f69e359a30104792a79cb9284e4a97ffeb47663decfa5d0712d9257af16daf3d37d43fbd2949005a21309b5fffda9d6b1c651b89c8e3dbfbf24350a5fc9288ad6ca5110c46982177f2e0acbc2d81fb04987e88a814210dd8d93a3d9c2c614a24d0ca861752bd1e28cc3aedd03b0c3b8e81b5a7fc36ca2b05ebc4ba90985202280f495eaedfcb13fbec26d544850dc1deb51fa86c6d8fd084fa44ee3c2a9463826a8425949a52c8ca26066fab95ed308d674f7301ff06268754fdc5c522f4b8c0fd8433bce20b7b5c7be2c7697871b1f5196ef526acb5d2564029a5a066935be19aac79b351f24742b27cf48955b631d2ea131c8706ccafbf209882917d357a751be64eda76c03f6d08a8227b5b4108c01d2ca45afef74f450ad13d1644fd26dd75bdce9c986f7fcbae81eda39b3eb664febeb95ef30a4378b3f461a21573d3126712f5b8d88029d9e4a94570075556d134bcdc9dba83805f539c2bc8f67a5d6fa50864d6d5df2903400dbb5eec95e81d237b1c86f4e6591f81659a16fe0e24fb123fef3e979ab571e1cd027fc0f3a014d77d424f08252768d06c7a2b00336182c1ebc214bc9a4374148611352be2cfac7b8276a898f4b7325b4dae0516d4437deab32ea3eb3cc0cf0e5609a24b57e17209bc06ebda8b0eea398875afcdab13f969f69b9df1c6b9092abb2edfa3d1f09653bf072f91649a2af775a6f35e032577539cd538fa34d8ff966e279af086c1800a29e50598d556a8689b02b9cd7fa3edc8cb6b4e04bc288c555c5af26cb2fef5b134d2430d1745050bedf1ac0138a74fce3cbc703943578634864693bb1f6862a8985b5f332c66274b113816f2a2e61a5c19abed6f00a26b283a4ae5b56216ec6c8d6001b8fed2030a2af5f883419548fa761d0958fbcb395fe4790cdef421ca9cf84fd374ff9d55d05cd7b19e13d6bf2629b91284a72761f8c528449b0c2abff20473b3b2efba68bbe5ed4acbddd3d772c7d536bdb65c5c74b269b80838d73e7c298d728ec5b2b1468236ea114100ee7199f7d696ccf4842cc70780207622370ccc993e42eef860d3d170b30a25f8d749f6051d2fe73fcb5c4a659ae329b9cab812ac0fd0d83662331e0455ec7970582bab1f96e7170eb3e0f797ba3d2122376c581655776d1c1a97f2caa8913f69668cec459ea5b19e7d9e84366cf194682c09b332a3ae4963dd51a7ef7071b93828777634eb3851c7a8c53f5856eab57ca74b7cb5705f8e346962cd1e1804860ee872632cc157ea42948612d284c81f50ee2640100854f4db8b87dfc7c12cf8a3e5d8159bb1f257c9aaf403f073450c1303991316ef28f71b7b6b9f98d5d21a82b8b9796a1b24b75545033ab16f88c3c66b86af2a89efcd1392b7fa98ccb203cba66445f4f9595b5fbb4588af53a54bd9df71309ca79fdc01e83a086152f70a2cb14a1e71ad7661c19fcad14baac313c2e2a2f1c75a8504c759ea2d53f514217bae00266b5fba2d32dcb74ac00578c942fb86f7e8e2b9ce7428392b5693b45ffb83b34ccc8ffd801de752f5bdd1db4af416d8d57de80b5b9f6f06ea18b9f0dfb9e3f88f4c300d9d2578ff029657cd2464c67043bcde50bf6625ca5d6d6e1e0518729a924755e129949bd6d1d548905f676c017e3022b1f79165f3689ee0d4a437c20ecb29dfda897943b4d5dacdd53769889ad80e99eafd955155c397b6ffbfc442f190e4331bcc087a64aab1a4231549e810e3bf20dc0986e598a1837915d035790e59bc57872936e49e4f6c0639cb764ffb5bab2e3b76f6ccb2099c1d4fec7f51d39432d27983b7c94e339cce71fbf2b3ebdd657ac67102b0b3114c6d4da2ace01b910548648be139d840c760076de6434fbc662abc7386d00cae53a72a9607dc78834dd38457265920defec84dc180b5fa0ed073c7736f496b0221c2d62b1d5c32105457e399e9bfe6805f1eb3cac53740c1c3836aeb3639a5f6e87bf50ad872287c56279abe98bc6320704e81af23d867d1fd355fe8994ed4ac763450e06457b14fd0a0a302c12d4f3d02dd47a0f258fa8d3e3f5a24d468b32690d87056b9fb1c0d9f6161417243620eaf60773e16b7695d418e7190800a2b7548eae7ba4172d993319a86969fffd4fa0722a1dc83439f82339111fce50aeb4b75ea83f5820f52c93b9a23aa9ebc983ab7beff24f45a81d4ecdc572b612cfff5c4e4923e466987f151bcd60867f7f2df75950f14064e2e7ef3aaab5a9b37909d8f5a43803c06d94f36b4684cfc5d50e753588b679acf01c67bda8729ed93f29fbce7bf6750c8c16865f66112fc2c4b8d133aef8c0a61970d0e0edee8f0de62213e0308b972edc008206fe50e45a47f9b5097b2aef1ebc088d1965d0ae903f997e6c2f4531acdca5775c22e99d8941e5d7722a346e8015194a4353273881c83341ae9d7217fe49e14b0a2990b0724d53ee6f88f9dcd317a8ff7833bd5192af83585f20dfa17f49960a82d571cb98b4c51fcb7fec20a237a1ab38426fc67dd314698f0c202cb63123986fc4dbc5aa81d5f2be54daeadc890f0ad71343be5df8763ce13e41e9638dfdaf07fec9ba73f2c7fdb95f0b03b5a514fdaf324ac0725217be4cc598e3128907f216e78529d24b7ee7ca87d70f6b7bbc551ae3c063e12191e188cf5b58dfe7180c49c2e30e73bc80b00deb78ce6b8610b239acc4ad3000d1b0637901ab581fbacf5907eeb1ac5e2a44e08e8cc8d1eabd4c9fdc043bbc9cc191cf3c7a54c80bd75aee84ff640dc367f6d9e6d6d9a1cf0bc47b707b4a74e56775d405398b86b4138e58f09f192fd1a4423cc3efff0c7a2e26da0fbbd9ae1fba07918ec23f24e908bf7ffa7115af57c816fd73fee5c4e5968c83f1cc3a0bb672f6be15b824d77e059f03a8c020167c1391369131e1d197a98382db9c6708ac22ad5c6cc32f0e306601c994490b76ce0a2ff87abce3122d681a477ae92763dbde3bdfdceb13920cbda8e06f9666fd983efda4f27431771fd7525175b269d93a371bd8933339d5ccf4c6e851463163cd3d6862ae350fdb7d6566a540293d748a11d34e69186d03a5c494326d665b986de3383232c986d023a9187420ca311eb383679cb729ab4e2e1560e7dc7e68ef4bab708e77aaf0e9125e179f90c45e55b5bfca429adde92f0090d9f414396689a6918d80863f9df9743d5558a7c9f42fddcffd94940fc96a193faa00aab55b787793f5b62d3ad6cfbfa1f19eb4b5119360aafc7a888e61cbf9964e4ce2c1f5e46f3cf2333b81d74087b06c10e15894c072a6c67dee656bc080d2cb86f44d0736ecfa39a8fa1d41c7aa436d3ae525f0d76bba0118a1ac234beef6e356470d9faf98c1129d716c8070ec66787636aedc9a2483e5d1664b80bdd70baf49c168b0c270a5fadf993437473563abb3c69928ced5128a68d4c03d44844d6f1740c05962462b0e23a1b6aae53172ae652305a62fa946f8d95ce02399f68928004bef02729036ee9c529bfd3ab364ea691f208eb7d747727c3359179d887c646ea5de815a72732674042c8fdbaff93317ba71c3b28af4cec9e637885a7caf250e41a895ce1ec4717f04abe06ea0df76e748e8151e2b446abe8b2a62a27d7026f96ab84132ebda7fdd2528578f7b2ddd81b9d4a247ed9e4e4ed24615a3c8b6f45509d25e187c4f12eee67e47b6c0c37ff4a7e4f922be2c57cee5c58e7ec95de0f784ac9405a00fe0297c7fc69cc4dec3bc3ed33de4022e43ebaf7dbf17794772585e1802f58a2f5454195d41a74e8fa7e5a9e80fc3de21d8238431531fe51639751c562bd241ff47aeb8529dbbf52a851ec2cad131912fd097bfcf9096aab0b3918c958a18d7f30a60ce10f9aaaec1971b1af10c2f4fd4ac2f9f200486487964941d58a6913a5d9ac651b2bbb1c720e3e70600d80ea04be6b0fcfeff080537aa56f534cc3d11250bb080e940754f8da191f44ecce29f5ea4d3e24c759a4a3b26e874a1af4ca7611d820ac565ace7339d48e846dce256f620e291d4f22ead65814fb24a5c71806ebc040d606756eabd050931a1f8f38a5fe1b6040c48e302a2c0d727d33878c2dac5b7fa0a4662b782567bf030835d9c6ee96e5f9f4eb944f767918fcc5acb3635745066adb50275a6ca2cb972b52be1c37e6a69ffe1fa6f9d6a14bf90386d920bd0ed559f1c9e202c8bbbdcf2950934bd5f4f6c17fb7e75c8887749072a39a3ba6e6489bbefcbb82ce0edf2fe28f9c508900e0529fa87f3e08facd74012ccaefeb973bdae8bfe88d327e9f7a3ceb937b0a971135d5498875c9f0d7a5d26e8a0fa81998b269497ac75e1c4ca0947d1ab986f3f64482145ae2141835c60b41e47471f97785d4fbbf7d9cfe71ee8fbab118e961161c25ae709427165282392c07ebf8a6aad1e909fd1f3813bdea15c7844f854a4ff8fafe35c9024b3d584c833acd7038a188d77d34878a20611045d5ff5cac9ef71eadbd279ee68ec8ae3a6b7fd70bae4d57d44b5af40bcf731415e74130c6fb286c8d4bc22ba95fbdb6afd49b1781d2685cca443d22eb9dc24801b960a84f857c7aa80cc10a2ed6e481351ff431b2397bf65f32f2869e6c647c1342a123be1d9a290e0c9b10775d098a5efd79d38461f1d4cbca08f1cde05e0dd70b5d599847024249b4c24078350a78dc06dad40bb7879692b2c73ab2ab130936a438a258a3f754ced414718e035514add3c7776562481adc80f8b2ae4030645be5ce111a0859388fc595df5636be1e74ff7671b0f87689bddebe1d382be0fc5285c48deb07a43ad5bef19bb5c54bdffb39c1d285174b0fd9abe469828e42045bdd08ef9c9ba445e22b4047e74eb277aef025b4346943b3a34c5df6c1690f344ec3a78a30146790ad60b93096ef5b938b4ba1876258ea8380207e79f6d076dd2cfc4b60e9aed34a88c510018b00b5aa2ef9e415e83796dab07bd95f0431e794b32771dc4259d30f5081026e827706ac6822f2bf27c6fa146e75c6515bc5223dc4c3db9a5c664a87c2a2ff51d5569979f439c5457bc04f3e2bcf6df0d973f0bc7a21a9ac7815e22431ee4d25d0be6a0fdf73965fcc4b65c7c3311367d3cf301a0dacc0eac50431cd5b3f1cdb017dc7ed03ee1f35bc0c0325b9cc570f922774f4acf5fe135636c8ca7e5daa8aa3a7dc13bb539370dbb3becb6aea57d493132fd144a27903efa62b22ca8c4dd8694c47dbdf3985d9aa90d7c755e00d8357213c234833172ea8a4d60c187c3a74c85c4513056d0f29263161dfa5df5f9d06a8e9de2eaa9cba8f509845a71bc78ffdf87e7e4d44c79671fe86c004422f107d22f5a409c682be3dfa297a00577bb3afa501c5243a43850403a1ab918a845e9feb8ff0cd5cdb61975ac6de326c990c573f6adaee4d1ac8c31a8670f8634a814d6771dd1f197be52791cda636b888ee674b14fc018c1c62f8bcd0252f40127ef6967cf26d710dc6dc2e7682bc392fd8cc46a99ba56ba8d1a9b06d36894edefbeaac87214e53f31b972d01c17d78d39b6ecd40002e57dd8ce89312499d6afbe1d4dae7dda5d578e981a54e15739c584324a9b82e6d20df64866aaeca058882c7b3981d0e196c887461edf4e0e37677e087bf40c77327467944964ed31f07a0f4cbf27466e2e34f8f10518756cbeb987a380d6a1ab3660fe7a2cb6c8a1ad7c42d1f3391df0a8489ab0ded2d1875259631c234f14a4413b6ee6b91f554d28482b0202c39574a565324976619ceed4c216c67c6711d1bd466f5ad38b826e1402c8857240d765067e3cb7dc485230e42050d586646f35739661e5039ae63742c0c2f642c2a5c24daa8369e8ccd2eb280d020ac8562cbbefc2c47af959cc5c2b4a0580f02e5e21f4f61f8f67dd0b2d1ab5d5046995f1d9422f4a6cf3a697a4365f5df000337904e23a9ec5a26e8d7eb467f60440a25630cd6c6634db218e49bc41c36a3a24421a900956e456aeb1117146c5a05d3225319b1b180cfd92812110bcf384ad60534dc7c5cb2688e6d6fc5bb47a36fb38bef8d7e063e5b9bd907041784c031d47f5c3545b08e3e7e0fecd6b63be01c293c061b0c2a89f4a5bcff5525747308a796df6d1b6e99ce0079b3eee4e709af7060eaafcfec1557406db25681d05e3736670cb344a7d885e03383216c40054a1abea7ce210d3bc728e85c504a9a5553e9e763247e7e8e7ba8e669ee899c91dc75682f8be655e86c2d45fb8ea8852079373801c1c209f874927f674e65cb695cc2f22015fa24921980b5ef218d1615a9824746f130d5e1c1655e2a9647b4d325f5ba0c8f0038b0aa8c50972e7e915f676277e3833e810a6c7882dab491eea9e86753724b16e681b51a1bb4544bf9880b9a96b48f957ac4abd2a8f6f303589e90cd3c7988185096b4a50b19b8badbc8e0bdeb014cb4581ce18ba760149bb77e308e05f048dc39bdaaa375ab54d928950c7e7bf049e8beba27381e0f04a6bf5431d5135ae1c2b020803eb6d544cfebeec4bb17c3a67006fcf0913f509dd09a8d1c652ca9677ef2a2e1216fda708a93d58ce5ed0abbb7758562ab955bcfba4ed19939da06a339e1c30a754964b8861e321e10dd5b613dbd80f17bdfecb413b4eb1110b1f0b84aeccb5be60d4425cbfcfc3ddfc55d14f4f1c78a1a13b0eb1f15299d0e64131397fc7aede7902c85e38b8afff744d97772c76ffdff375c887d5a1b72dffe14c943e8c9c80bc5439fa80d7ed59bd0790ef797dbd628a07e054e099c7a2f73c75274807846a32a52cd8e5e1518f0bfcaf23bd10806e1c8a0aa810ba595e74841c386b11dbbc52118330150469ce5b9b892266aff81cc95cbe0ced6c4d11f010699ab7b738d40303d2e30765b1bdc7e5a7895940a1a5e233522605454c4994d4c7b64d63a4a91a0a8cebd007a7e6fc1a881e4f519d0f0411aa76862fa9d080e0d653449e6c38f59ce3966bb8ad573782ce8295e9dc4884d338e9b55a62be033069d9875aee02eb958aef996b222e415bd40cc38ada60eae4e0e1ea2ef2af57bedcdcd5900a6e5eb7600eb45bcb643745291e74ee38a83e6368b163b3ccce019d5e07fd9c101136abaa093bffcd87f1f0efdae05535c555a0b4198b51e7d444708073399905b5e74fee4aca25e777b8c4f384c5fc73075a2361f308d15a4b1c126ad4363c7cdf4ebe835559b7063be7174aad30d55fac4dd90dbbc2658a044ae8773f2681f34f4dd5ccc08ecc4a2d514f14749a975399ef2dd734da439317ac72c624f7a0b4155766d4077df5cd8f4a91d2b87b07ebfc0b6251a93d04154ea8346f66495f2da14eb9949fa1dd1251761b044bb5c5dfa24c282e29657bfa27129f6bd37ce18b5c1f68fa6e65231c47d01357490c483f2bade26d9c3136afd7eeefc8137d9f627364cc949101b86cfe45e2db547f64cf0060842cd441ca00ed7a2380f264d3df31b088568a6a9b56fd84bb8d0d2fc211f38d855ff6e14cebd17a2c7a4c615f8e06d0b43c7d19cbdc374388d79e3219bbecb7d99c6e4970bd719b22b89bb7deaf945515e6067dc019103a4f04858ec617266a2dddd2a2cf0d25e0527e42a2b25d2ef7e0505b0c84a1dcfe707cac5691c0b003f99814841df84f9716f02e34e3ade94b909aa34eb9f865633d69dee95265c6159020bbfad9dcc4bd7e3fc895d5d030fb08d69959d27e08f86fc2277783cb7ed72f25ea142fd466c4730a1313a2caa789770da3fb4f1ab96efe066c71edf69916b314bfd52f7f0280a3395f8b2d965d7f360be63c8b5ab87329ee34c2fce959f4d303226d778d5334f096f4ea52bf796d0f83b46355e36b89d1f327311d7ba936fda5aba078f05fb1287321b48e605c5710e422941a5fcd6856b1ea9c14811279b0c1c76745531ae33901e1a83ad8ab8cb13afdc965a6f32bc7c028e7a8505f7fac335954081f50103976754edcc0bcf21509f1b8a440b7b1a34dbe9473e18f16bea6b6b798c2412e410b727f61b9ffd66011b06fd7f4b480461f06973e9aa11c8c970621a51e8beac02e11f82ae5c2c8e3c89435e7a63d120b0dd2218ef55ddd0524d2dc4723ac4609d2e8d04292e2a46a8bb9ff2aba070db5d08914559620184e07e55a1f18a46ca67d165b7a1d4d4a8300d36b71b8de24cb8fac149a8eeabd06549e07ef4e4fc1b7fbef132fbf30d8db40f96905059e24a3e3f351706736eea94ba622901e54b2b1d7db4d4e77862d5c470727df42e2148b609276b2d36f913a998d6648be66efdde194298f96d6f528e7054256492cfcbe02f216bca7087c0f6b1e79b085adec77883c58f3f310e94d47c8d1a55ac947e464b6317dc7ad71c9b8911aa643fd45b1e7c69da7f5f57c9c4d371afeb305bf2f29ae009442d1332a1053051da3af39761b87a3b6266045dfa8507a326cfff7c23ec585bcbc0b0b91042a95b283f22ef570504fc3613f298581ea576678fad835e8caf557285c320ec44f7e712572a26e241cd13a20a48555e5a35443efe207c6df8da5cd1610678032ea232719ba161202fd6478247af58fbe6376e1f6349e2b3955c6689a1b3ab55faa9717fd6e8fb1771b5a05779d59947b32b41f7183177f930647d79c8959f006930e72a6b7251362a39d5ed9df5e011181a3387e885f9a4af31feff8bdec9acda8a98a9bbb9b79ad14aa82717341b6273cd6ac5ae78ee3df227bc2f666bd832c395ff44ff93a75a55fb31500323283837b12656a4063575f0128aefaa645eebaba00c165c617510b25539ff73761ca7a15e3c616133e9ab058d5d3e72b4e06bcf1dddc931c55f758c2dc048a50946752e988dfa99a0be03eac90ab1c8f65d034293ff2f2924f23630d4db3911e9d8c75c148d1e2cde563364a54694a18cfe906e8e0b9fe882ccaf7312150861115294062ffa8bbb81268d839d8b0f10f6ce9ce61647574e74b990f44ad94307d208a77ae7bfce8a14e0b0d00f5cd06b4a0e66326f6c331e776d17c8506f98d906d26d70ce902618713a805d134ae335996579366a118213e3bacd8f27e9b89c99bb3feaa367c74d629c862d4d5aa98a30b8bbfdbc5163486046554b9e33a993d1e87bacfbab0b14d06bdee75a08d590839341bff3c1f2a3cf48a1cbd83228868bb4faa3dbcde8498d3defeb210d75e0e7b5da57566d92b73d77c7904fd48dfad4b58e66631bed8b8d46bcd8c1d1fb12e3400be1f4ba4d059d539f5873bff924dd3429ef968818b8e2f430e327493c31b8744e4049d0e66dbb75e67821b8e67a4c8186f451f4c7b9c5179f853fbe0274d7935bcf79da675be93e5a7e520f9bb1298cd2d583a2b2291d73628ba41cf5d5a597328def185a3dc35772feee5fa18467c8eb8bf73c60b0b2ba184480509fc87c357ff142b99f766d45be1f706079e4f3d28379793724976fa22ebe731c608438c2c0a9ea4398c8a6175950099daa86a49c4c13078a7d1fff279d37301d405baa46266f6776bc9ce9aa95e6f2d05046ff5d7b9e24c16e00bf1422bb691cd167aef0b2a1819232ccb1a89015b20f90f1d1aa2400527529d3fc841c174abc93b3aca91a2760d30d9a7dd61be1df61556799934b6ce2da1ed541221a79982ef316cf40346f7489ba366b5cc2fee98322d17d935f5b0a1f84f7e6a3136086054db49cdc8e486da6f85eed276368b3920a626d02396a55f1dcea5f48637866648d81584588f23501e39205a4c95c65af0a0c290fe13d60836bf6b08f34b3c46269f98f2af6550ef202b7a2c1ea3d84dabfe0a5a2172ee3366cb5b02c83e69f465cf62a8506d00f923968f3965b33fb771351946322f5d6ba2763e267288d154d1657338dd682887e9ba3cf317dcf7714d37285faa7e8fb9d678ba2c2d1f5cd28f3b9da23706fa3c4f4c2f4bc7b6a043b02d89df356cc55dd4a66d0c33ef1c12d53d0341e83f5c29a7a149bafcfa16d6c62526f160d221e454223d22c7077443e6ef4d7232317b7e85e99f3471b56af952b299b88e64167e9b37b13565cd544df84f0d328fe890317ac19c50eebe48c67b8d61fa98cb6aa480ca6805e632bd4f99c7038175dc8451d2950486d8bd35cb7c8eec9395c4df0121714bfcf257a381c5f5b03f0c766e1becc218db1cf7ae386aa096ec6b1c98f989a9d979bb8e3780d6317e6902d49ba27c9162198d88f599493258f36b67b75c25e8d8cdf29e1bcc8da72a2ef530ee3b2a8d50a35b6f25ce21dda054d0374bdf345f9d62e0c1cb9d494efde2039d804812c137b8280c802e3b0bad6f0f94c7f52692a51c6138d5daffa1fb57ba7a6968ccaa8ef9bf15faa7a12e49cab958c8cdb7adca7d4de158aae4397a2199296998985b6a91cdad58f99e3b2e011741f6851ca85999b799a7ec366413ffa4c64538fa5c3eba55a46e89e0f2f8e9879ae6a4745c7b0a18db9a4fb71d4c78e59b8168a7dc08ca99283edadc66acf560384a80e9e31f059482bbbe95523aa8f3944ee91d88f4e8722d7c7df5942b75392c4cc760f61ad5b5c4fe70db8ce9cc8fbc52b994a056a31c894d8a1a1942c486e2243f92d4c26dc01a8a27320de6045cdef37148042ea05148108837373629c8c8182d8337a2791d5fc8830e7379e832c1be72263bf4c8e8f6d0cbda4aab6856cc3cff34df3fd509c57c3524c48ecd99d343edd1a6adfb2a11a1dd687c1641e8247850673e9ebf834f007241be648a80f2b86aae75433e535814ff3d07f866a896980d4ca7ea7a4922dc8d48e7aa1081c7f3c9431a12b28a78fadf0bb420341dfb44ffdad4a722c3715100c121f9501f992303deae7dda816ec566cf10d9579c211f370cd0ee29333facff55eaff6f17b572426de73403526c92b5b2e293ffa06af5b5e08693470adabc03e97c652ebce0e739e47b95a12750d9d5ba8bbef35fb6d3dd5b3188fbe3d8a5fce5a4efc99c3337ca0c0ff34d74a4c871e309bd893f187fbbbbab267dea8a4178fd2d4f59e1fe56e42c0b96e792a7ebe99b17b0da2d90c3793e3c91ca26c67f188e895093b088e2fd6bb4c2ab6f327ce0e4ae53c03f1bc95dde9517de49fcf913c09b12d2b3bdeef8321ef89879c78171dbf0c462cd2e526758874bbb930b6695a194303335c8d505fbf41e3015f98612e47fbda7ecf857ad4ba3100fcb9a4f1a3958f94eb54be45bfd75194e8e96da92364330cfc7e97635da4933021f63cf844a28de6f54412afca60e0bf568905282e8e4fb1acf2c8499728139f49b14e3411bdfe470f9e3fbd51126fdc46bbf82e9ba60062dfb4c2aa5eb241e50f821a4390d827995a39c086c2ed9844949b0e99a3497c350bf8e054b163e03b5676f32ea8f6ac59e21534312b295c43e118e334dd5e1bfb31a5b65a3ef84c4038fe1c94bc50ba0f5f18e56df13cba65afa90e04e90a15f4f3c011d0cd3ae7c08c30b8bd14742573fc8621ba99d8fd8edc44a5a154a98a4465942455ceea3228c76b40363640b8be34b5f78cf62c259dbb41ce22c7a80e2c3f138961cf51354fbc68cd118d435f86dff11c0efafa474aad68aeafa713ab5585e4a6fec0082f50de25e8194674c5901281a22d0abbe30fc31cd822a89e5bd610436caac68f1099eb71e0a3837eb9c425bee7545ce5d31c10939b692ab6257e29c39486ec1006406eacf5a3766fd79eebd04fba33e3437984f73d3e7e0da0b7e1de81f87a8c1bb99b728aab7ede1f7db8b1755eba71bb3f90a84090b728d2ec5598360f7ef0849d4b291db28d07f3baebc0038c175a21855874438d92bf3221178d6bab679975c9dede9c89dc7e12cb5570292214790f24c39e891edf2499a96098ebe67c78f75573fba421137fd897ddd505ca71381c1194ed955074d6b6322bc0d7898fde7e551a6a6272ed25a2b3c13dfd69a2dca0763ba5da3186bb5782fd96807d543289f91c4149e997bbed7830364de0dbcb18672f0342541859631d63e31f1a5a7b417ae5403481cf8c7936a47d5f268eb74f0516be44bd6c08a36cf4e12d17d6424482b88ed455b8700fec3bc904a56cbc64609e4f3d4248a2cef790d9e0ed583c77d22f0b70caaa11adaab5782ff2fca4ea6c9589f7f85d3d30f7a2251f2f9ad8f9193674a2432bb34f72c35ebc96d810a8a6ad740aad82471a3a23f02c3023d82c31a4df40b49954720f9e78f7712eb8ff8cbeb292c2d451947f9994933671ee1405da8d917d635f0cec3e720f33221873ed55add06620c3c1f170e80dd0e736b45b65dda8c1adc2253ac94058101c3d9d9f40535a83470977eb7a4ee3e03ea0d31146259f3ddf435632972f8052f49e72efaca0b49f12525abeef7d4331305a42f3c4b137470da2d1b9d6ae71fe8b26e6373a9539f2ec831b68e750997767bbb3a180e9e47bd2cba55f379b46ca0cf625a33947355db91312ecb7b6a98b925caa192dc421932d8295a92d48fd5a028f0de918cc4d15703bce68728ce24cf674b13c2af9f8a6e3ec056fb25b38f34df7ac29f9f48e6a0e7ef708d38d7ff369d989698af95e11554258ddb420ce4192b42a9e440057f7e92eedad28de06f2fce5a7be80b607e0c2927a525c809149fd8d98cebea145566c93690f8e5d882739a42ab69b6896d58182243a606b548752c356bb982cca0ded1a4d583b48cd57fd97c58a4452e682528dc6cb2befa22b37a569ef654afc687ab623fc8718eadb81063658399f7433a020ad701d7c7f1ae05a5f3cb01540e506252b0289b57fb89588d79a2815eed94ce4344118a0ad1c2e7241c262cd5cd3ec6d3ce7a7d8ea3866a39f428d68a4862d461447ec9b42938aade18d30aa8163a67758fd2562838de9c3a5cbbf86604567e1870e0876ae94cb0adfc7f8b7cce4b02228d606a4d3fa920be115efa0fbccd14313f1664fa8abf470633a8fe9f38530168bdca2534067b7af0c7a55cc7774d209aca68a23683bfc359d6c9dde7316955673b53d0ac1935399f6fa1b59f586a7c900dfb758400b8781a95712c3f4f4c5651b0e79ec99fb6a22f3f05187b931332707a7f5810d63b5309209d6072aec26f70d743be39998a98158c19d23e01cbfbac95e624f0ae6d90a06f5e02e8e3b7edaf3f20d81d36bebca6205cd049d22cc4b4ac9b222d6f683b38dc60458dee7b78d6035e7d0e7a58d770da30e064ef60422ab605e33e17d210bc4c34ca5df60453abc362ead2f38cfecc37328db068777615c72a422ac2fb847ef78832616db95005c79b3ca06c843e5b8b3c1be611f3928849153800dd4774c81d8f0367aaf7a9d339145ed79b35b22fb0757f7e994c9708c9a64ec7071d4cfdfb596ae491fc853281faba35e602ffc8fbaf322312066d83cf8eefd604c7a9d75665737ddce30bf077bc22ef6f234530b618b043cbb1a57893a9db8762ba0ba57c1cf1bd8e2f90141842aa8e180c3750d67f347f306129d7dda82f7be5b2b63399632d940b5b3b51afd0b3f3ae319853e1066d13590b0d9388440dcd01c6abdce1f1bcd1bfebff2f1d2a344efd7951ee584e3e2afc7232878fdbf82e46076f1a85c24ac96bfdef745f0bd0b87a5f5684f3bcebd80abb6160a4f744e1e270fca2eace1859aabab6a249b4b9d73487e7d7a3af9f24293b0d9e9c31a3f2e452c4e5250d11177f11edede099d84b4468f3a9c4f346a8732e2d5aaaefa34b3c0b95c5843a87dd81bdbfcc41012eaf60a2ba6933caca14b07e2bf586fcc5e2dbfc5267316aa1ba9ae4f391050ec354a3400f908e1e09c999c866240943ced068d968867cd71dff93144774e0198d2d47f14f58ac286fcefd85373b0b02cd4d569e2770e564db0620b511a19ff8528edf64cd32707176ae9bec208043117ab9532aeefd1dcd43d444878feaba924f6dd9b26179e017584d57bc1803413e0f7721b3b0ad28e651519f44d76164eb4cda0a0d4264039b07c4843e9dec2948f5704008ce9fd08efa694bfffc911c53cd7f4f7249a0221e8d3f53572a10dba650ca5381c9c7df98f79c572b3830547cd15f34f67ae7387b62c1756da2b2dd0bbc12f7ace2d718cbf42685561357b3cf751292896ea8c356ad0364c2184730fddb798f420b948987e22107b7787ce5cee0809840e58ac3709ba9de5ac9fa36ab9501bf0b432a7c19b68b6487a400aba7f3a89da6fce642a79b4eafbad41b75457f7fdacc55f9accf7cf1709cfc4e1ee0e9f77f13afc06d0f522f77fe2c07c675cbf0dd20c7ce757b32d4d808d1b73f4e4e6a8e59ff8ae5f9f5d89c538f290fd5023cddd861585ab09f0249c554c8309d58910042fa7895c51065e62d1ebdddfea77ffe20db7ad8f7b85f80edc515ce350303927e11d9b691158659111bacbeff0d252a1676a1ca30de2f8a72a1ea46dbdfe921376a0d42407c3878506d4664ed515ec36c6eb724aedc2394e29f0ab6c9b147465409e24f1548591d9e2ad2f28e17b0dcfc1d5d43c164e574849e838f1cf9c781a225a9d01206cb31e64ab5381ed2171457333f159d1094d7c9d2f4fabc1707fc3606006b9dc14b10338787d6aca9e0636c61e515faaf2dc642ba775065c5424714013d1197e74053136e4860cb0c25da7a746a8f79173034b8d00e2b76266c028c0d50509ff3fbb73280f2db2d5c518c8fc36bdac3276c425187e65c873a9ca3e4a917c873dd80a7b929e6880361b608d9af04fe638b07dd48b1fe4003af5184d4c63e5eb9512f10b115405d0d44be3695b31a15eb2567b948bcf2668aa84bac0ad147b6beebaca41183f0967cd64e430ce80d765f8e7cbfd28ba063322ca89be2451f79099e471ddd62b1b1d72d0870e00f190bebaf08bc3e450169173e15ff98e0a18a89499b956d9c9c4696e4fe67244dedc431adf0f593a9d4b28d4716748bef0f84eaa577b91bf25a92d22026809fb908918a288ef1fc4b7483da5cd5d73f4c397fd6a69952a5e5fcf255e5b6576e0539636c1482c45561d37f02e14b6eda3748c78f6430412c4f06e56182fb7d45050b89c7a091badb8445cbbe1d723aa74f252418c1a20ec77f50fe73de7c0950b719aeb54ba21e83314738fe051c6456dc3e1b889eb2c6f9f1d4f0578869a64ea58984519e7210aba0f4ece6db8166137d4b8902518a525d8683370c3502fb39ff966414f7e5b1b7ba65c82462b71602faf49770ff6ef57c923fa8cdc02e1be15ed6c1b11451c0f53048fb52301208e4068470aff00b8d5d3fc402136fc1326c85bc0988ee5e526f1cb06ed86e73fb82e9ab83e5c7c6339ea143d232b5706e6a55b7b1a62e45e744710fb79e57730852d5c2cda7f12d138d45af25f8b3659d92e5437a211a578b1eb5274e04036f5ffa21b63a0cfb5ccdf4286064a48810697041ea6a3c0056c1fabaf018c83f73eb869e13c5ed90836cbb6bcf194bb644712e57f49dfbb422f565f8b9b092ec76dd18115081e7c6af2f88c8d949fbd3127c65cc23606df88155886e47f4b19ca004e79cbe43422364d7b6c266a7d482207353b6878b9bd253219fbbf831b01975f7df7b64d892957586f5448496eca1c6d3b637165b04d6cbcc1476a284292a213896392ea95611c1cf5f73cd41b8d0e10c7013d67743fa716dbeade9d989c1d90ae7790cd1b9ab0a5fa30aa38a86bfcea1280ea45ac3aecc09a3fe8ca50f1960cfc43142130003c405c3da6aff91d452aa7e6f1401de130100a28d3afe3eb1473fa42c414ed0c9ca45ba3fabc5409319d6a0981d3bf9a8a9bc098565014bc4bbcf5562745131e58283f86539edaedef9fff3f310501f6aec6bcca6523c4eb5107fba3c3538a0b677946e8cc41f8477730a22f1aca2bc9586751ebc98da12d3d1963302e36e27c1a1b3b260073df45fae72858857bb68993378aeb6676cb091291b94668c1e702c81311c0d2dca8f7f40f3c071ece4c5151a55f4456961e7e9ab27b95f0934fb4920e496c7d39c90e0087b9be98203b29c907ad407d5685eb5016208d7eb159daa13a6c8c873166d799262892d25d3f09424d27e6d6520962f24b81528925b1871b4e2e666aa90aa94ca5ba39b15737e717fffa03ab32b03a872782d60681ad61ba3bb831e3e0f60e8014e831356a4c9763e44543bd4ffee715a695b32e3698d65e3df2a4027fa422f019860e3be70ea7944633c6c84107e01bf350b1035409d4ebadaf1be0a86df4d3d0df5a14ae08211c63121d489cb56186792d0b30bf48ccee8ef6005f82eb3ec5a4724e51060d49bb0125d66b2f9d033107b9382c2b6d634be74018e5f93f29dd086b6ee276f65899a4b2b4371a2a50bf1202f59d5918fdcd06e938851f637b261c1667931167958736c7b5709aea77929fc6f457c553450d1458198bfa11c926278f098e82e29ddff61b5cf4c8b03b2d746d8503246c7cdda154166a2fd14aa4af1304739603a8c04fc4e36ad43a405946a311c4a293217d1e62b7a338a01ea8158aad5daf151bb3319a1b0df985c4542e3007bf90db0fae0f491f03513ee80a318c04b412fb27b965a1b56585399718703c5c3bc6a32acfbd8057e46a041c5898809c79e93b74c59f5e847e615dee0d3e743680ea04425dbc5a92d7ec79de27d7bc7247d0271e400dac28be75d8a8cb5d0643b9afcfa4d29e1cc8461881fca1b718acc7a1482b475320bd1f160d6a06ceca8ae5371144d5ff16a3ad05721cb5444509a3908fafdbf2214ac86dddf2e54f068051611a9429bc6a3938f02cd090da9f79d0fffd426481eea0494ba719099370d176e340595a1841682b30c46d95f96bb87d109c9d1b09f08d63411d62358a2be2c2c66fef81a829c1c72e133edafc9da9c87b268822caae022cef9c3a72a697a295ba4ffc6dee59aa6e4cfd5317a6ed15dcdecd474931003ace776ffa7c5839af36e019ddfee8d03608b3b14e9464199604ffce64a147b985e88787119ff82f55d3c58c5319f8eb7ead39a6ca24b450bbacbd374c0cf0c6057983dde3e50151c2d411fb8535d210f4aa012a033aa6fd4cee234713e0bc296b73ac5ded08df40b56821f1ac5af534b17fdd38840ba454e55c0cd26e62db35caecfbd290531fc2f0ca7355451dd64f0fbfd9011cefcd827c3fcd71d596c150a2e73215ef9c0ca7a68d8364af0037f2dad477d2adf0d4cc31a85ac19b8eb6b730d34268d29e9dee81e1adff2c1ddddea72e5542498f803ba499b559115d3fc8ddf1a2e51c71bd9f3d9d8639bf27ccbfa795c18dd4973a43e71c666f80550da6e6df84be05ab50a761ac85e220c92a7397032d9b9f9d9d1177f25a39de6a823bd5af7f408c9800b9d88c36a233edfc2769d707f94b3b98be0899b39758aa43efe095fcd988f022c2cb8dace143bcd7c456780bbc47515a0be4f289aa9adfde70efd1e8e9f8fe68210a9a676ee376611c3498c93b1c76be8e0da698d89f64463e8f5f58775693e485df7bc27d96ef1432b7468e1a31630afade31eb5668d0f6b5d18ec5b1b7657365a5f8261aa8eec1d0bda26ca37541cbb3ab3715cb7abb997d615a0dfbed6eb4fe5a377e377de02aa30469cee6a5fbf7356d5412109fd65566faba967df04e1b6045162e2ee270408ed621ec4bedb489ef8d85599148bd7a9bbd78444bc121c1eff0209e484c84eaa2ee1722a136c89c7bbf6767049791b26ea2196ec20f21bcc612400270d0564a40b1efc26301714a727ab5508c31c96c357476f39b7bb8f74e0a5cdb07f2f6514be64cced4330744d0da3f59d94a39ae0bc600c853c3328dfc88e5af1705144c43b9f6c29419ae89339e33b5ef321f8cfcd09a23d969ff08b95bbe9a997335054c5fb471dcaa8ceab0f40573d4c20286c40798d49f47e3ec95300de979032d1791b2c6bd9ed0c49d86324334f8c1fc3812da1788237330c64d7abad2ceffb107e453c483af3383532cf43fa1567811a33afcb37e305daedbf0549f3ed496a03a6b055ff09c35cf3d9e47821d55ffab3fa9ae75da0a6b31f04696e03a118d4208689acad752da0a4aa29da725144264178e5827748dde8cecff90df47869b1c44dc51bcac200c510fb4363df4fd6dca9080e30c73613851e0263c4da2615bb4add6300b7adf485d99cb4f0413a4cb4aeec43899ed01b56314ea22fa56d74aefe52df04777e123502bf22a11425e52e66d7629b74c7487f99fd9bea6994d343417e0f4bad62dd7fe0b2539cec2703d8f69249c5ba7394ee503c8f43dc118d8b79a5cb4451c7ea9530abe7f5b36ca192f8ae0475e9e6523addc466515242c9288ac163389ad3be3352addde925f531e4ea2a5e43ee401c836d76d57df52f9bf4de5017fdb2ae1621549e44f7df7e99ae5c4d2afa7d0b8b7714bc6d993f785c249d8205afb85847965b93b73d603b332f7820c045306a5aa3b6a2427006c40344654cf1bee15238d52893cd23f29806abcb615c783c5d9a037b45ed4a7234bb6485db4d0773d5cb5e6467f0f8fc26b4934e64c5b58ee754837e920a655fb7382d9e9f31b52318ea98b043e71eda0c3eef9494fe26a43a6e701fb5fc1e1fa58fa929f418399b7e2ba1afc70d875fcfacda938b389fdcf818242ca03f5b52129e3d0f671cdea381981df004473b25cfbd65c2e6ef08009dbb75b3b76317e0f3437d82ecb4efcecbc8ceb8cf5fa6f9688d18cad8cbfe935bf452a478b02d4ca97ebd0b902920edf074ba2506ddcea8c73bee012738efc23298550efaf71c437ee92bb32032b2e3d7c9d51cd79bee4f84d512b98dc42b02042869aa5d521f1618494459128e99e304c3c25b51ad8a9c0ac9dd76d862504b81f10e69ef36cde566d78b27d8059cb7894350f70962f85159cb60ce21b44c322322eead14a7c59aeaf52133b650f7bb0917d21a63efa59d414fa2c9ca83c2601b8b63213b9510820cf0a84869a9f4752382304a522a593d09eb9fa439f1cb7c462ab83c7560dcf7a3806f1f75c35f7e2072c0f376bdcc7e4b34b1f4082812234821e59b4cb18898a50cac515a8b460f6923a0ab0e24d8cbb9d677842efdb1867617975ac1357cc2e967577050dc07e9058da208971d4ab2d80917d4fd65216e19a125eae44322caa29d10dda3ac622f898113f5736252685db29588a16e02835318aad5db6b214b2db2ad18751aef558fa5d2d4643f0916339cd1d9ba23387cf0711c13f81856bff933acbda9908cedec7d2e82d2068a117c3569cdd23ab453f4ac6be947c3015895a83421cd26631f35d44bfc7d31be81db33af0e8ab69b4ca00ab4448bf43211885b4127beb5a84e20392749f20a5b941b10d218b76b6893a9a2342c7f67071459e69734224cf3991369bf2378d0841f7c6bc63c0b28bd2cda42da450e7ecc7c5f0ddacf0dabd4be880e906b44450bfb6394b58ccbe8ccfe55517adb791c4d0fb1adc377005809fb1bd85d35c07eb7283076029dbba2f6828e75737447462c181f7e010f434b25b33da16d5afa40c5dcd434ac6e7e120901f9783880f4da3af7b25ef282e98f951c61829160d3c6197082c0e28b38c1c0ed1dc161b655cdee2d1c088693b3f3a83d57aed9d8f723a5fbecac6877dbc9be3c3a4d7e4aabf48e6d0abd7512575716050b813314e3ef101b8f22faa4910e32811287d7478a56dcc0ff67ab7163f371bdce46abb05ba87099fbdad3c2f60cff6ba82ab2b6aed0b5176862bf788ae9cc2144147ed122f8ebe05d5b761b2c10bc8270a41e6f27e5d6325bced70f2dbca6b545725c9fde9d2fe9b5fcb04fb624df4302e8be884cfa878b10c48f772109eb4edcf1f97b898005eca10b2a72c8b7d49e6223616bbdc7c396388d40574da856670fda4abdd2bcd8be362eeca82d6ab25befdc7d79efe908a005b9b04e525f8f35b271679d4212c64473b4329927ff6c2ca14699babbbf420b4aefdb1882e7a13595312a181f80337ad6370287e51bce897e855a5dd23b717dccced87726cd9d3c90e171d844acf4df9b388986decbf85940419db04278fe3b847c2c423bd0f2995fdd39eb43658d2718c38c4d121adfd5b0955a22c0d17140098197e7163b3a011694c01b1fb84b2b8e62d58ad0116ca29761d29f0ab04b5982959755a302d2c6e275f3f69683e9bb52af1d64f0b72081b98e11e18828806857acad77e5dafb8a6ecbdc07efbc0cfb9c993d162025bf22c7c30f621369c00b568c1009fd1ab2424471cc6021b2a7d5dedc035f30fc98f33db378810c9be7eddfc49710123bdbaa0fbf18be0138eb654047757c585a63467394eeb70b5cb92df4585b08c4ed9b26f3ac04fe2b7b772705412182736deba1d2a742b76539bc9505bc8c0cdff4bc54e6f39e266f032d31241337a73d47e0199e4ed540f704babef23c5d94a39e29890c67b78c7f0ba4b426cb3abd9083cf888e1704a0ac390d42dea7669d2f8bb15979ce2a6941a0ead415c856152a306e36260b992c693702df3b95d5ec0f3c3783020a0a4890ff7acd1b701486046ef3157cc23cf7ccbef84e1664f3b454ab33a13d6c0d598f5639f2fcf39c08b7dcf010d89611c14be9438fc229776fa68b135068d6dff42ae1499a44582b3bf9d00a5d50bfd61ffce7cacf0471b84fc4ac610f9f3ffc3452c76176f4d2c40390041b8f54ead90a1539159b3f4e7b00e1d8c2260140eb3d46a5a88ff22d9fee6dd616a2039273277bf7aa48d5e66e64ddab3fa12109e45e03cb8b570ea484f6b3a221c056ec8c55fe246995161d1ec70ac9780f9c5d997810b6e0ffd8d87480ecae23be708f2f327f2de1979e6a444850c62058f1a68c662cfc00e357153298450d67326042aae2a548c22417b09dd44c822ad9c54eee03d5700d0c783e0bd00bb6af5b37b5f3217f4ed2c2ad2dc035b141ecb6ebb60016fd37fb5c586707079757fb1dca6517bce4edb6e8d2f3cbacfe62dcfb189f24bedbe7abd5b89403577bfbc8b07c1a7b397b28470357303c46acf0ddfa08295c03e5f5cf82edab778f8d8c65aaf86a98a884f8b33c2b015f3e7577a84b7a8a344d219d41a62e979f01b90f59d570b4c846f4bf237c967aec27b142b5674ffe4b2d26a3aa60f2a787596121ff7f7b33b536c4ea178a4cccd5e23d2c5693da90db8b21c577b5987486c9c2088648c616d7e5c8c0de6bd84e22ca38cada8716bcedb3903b52c1e2552fb1b5305dec13b69e12a2426d11c66c0bf97d616e62a91ff45d178468fad3000944ada6defc118f295a76d3c3f35a93d025b7924084d9970d7f99fe5cad3b120954286e7b9eae8b2056f676cc6f7716ebda13983dcb34ffe9724aea94c72afff19b4f07f263b2a05eeb1ad9df8343120658ee36b04720b55851910b93c723ea0043d487613e7fe128363c40e6c24d6e62d442c79bea927e177d0bd91987f9e6ac9e23d966417dbe1a063bc034dfd4d8bc7e4791484086b79bcc2bb9a5de49d272027898520f0eca59d3fd556a7769dfca4b02c114ef2fd6ecdda8a3290ec661181a1d8add3813de61f5a984d5ed0630ca7718d7b9cceb8715ec29b5903e75a0d7482ed53b3c0f35674d2f4ae63fb8e4554bd6b039e088071772f20b1d0fd50924c1b4451529684a7412fdb45f955cac818154d9577884e45dcb167abf0fbddbea242810f758b78cf9576931c82a959e13d5ebc0b9a28a6ee8fe273953bfe4a1a0590ddcf86e1fa2bf079db744f7788d9c05693d5adfbd81a0497f3724fc3876f2f144d7bee5f1f5beff24dda0d1645ce09e5c5729e33089a578133e3beb60c6851791d5a673598545c4e282324568f71229b8026828db96a4b2493dbb363d217bebe9a350826d02a1804f8e2c18abafed9975aa0e936d388eb8f1fabe60884791d436bb2024e7415cd64e9d5e908cd7852d4b8946ee57f9a9c5b682ac9c82e14858cb00ad7737ea987527a13f9ea1bc2aa4326269620da3b52a912131f86e70a080a4eed4a6f2ef64b220ab2311571b618964ec0fe76ce57e82a9d92ef63b2fcc2fab4f2141eb1999df4a18bfeb3acb86c233474df54600c87cac520404fbdbb693568a40449054d2207dccd488dcb66a964a924ea6982a07a28b88a08521a175fb99b87db3be3be85d3e161a1855fb20145633e5b0b2daee1102bbaf8a64db35c767f99e5e4c35c9dc414500925538e78c87f98d7f6d51fe6c82ad8be5656b945e82b44e2a8943bc41113063eca8ce9c561e8d564184bf23fbd64f802addd547e2fccd532ba2d2dae11c580b1a7d666581ae578668be39857b5fdff1cd254011760c5fe7cc7243bd8c51d53cfc5613e8e8d5d00c9df8cfb3acfd2399580404f94bfe2dd3eebac70dba4511b70cae4f6029a0a9533a9bc491985087d7ff9e288bd049196d2d3c942c4edd7f2ba31dd0e8e69001d1cfd34560b7180197aed4c2ad22413dedaac9707d4fc4a20d22e72ef4478936e97a937d5884c5c55466e443d7f1b81c548199a5abcafccb081f773b22ebc92aafe912390dacb43edea58da3dbd26d880de6f175ceed8bf0d1c0700e9cdcbab85dec9cb7391c908f5a6122a972796981574f45b79592faed033f85cd41a95aab71bd285e40e4c729e0b719a96a20b73c2784c61b9f41ef893de305565126077eb83b8d47dd13fcf45ba60893305a449297c1aea08870be4e0c98421d43751695b51375078ec1713662926215cbe1c8fa5d58c4a9b50389e5c0ddfd9e7f24dd19e1f70a5fa534a115fd5a5f92dee469ef3a3be88f270e126ac9c8b210abead234ea5459417a290151a1dd65b9e22e798ad1760f309ca33e59585ca4ddd8e27dd87b0eb674be5a1b472411777bf0623c9823a9d0dfd1bf4a762d2d8f445e9b7e95b75242e6e29a7d3cc227b869ff702de7c2c85b4de1ece3d337e52bf29e066cb8d7e24998284844f3df458f689d3fcd1e7ca70ef5181dbfcdf0318591c1952f74cbad8ea6e963afdd5ea702a626841ab12b250a646b563f73effc883bdb4c5cef487757fc538dc96e0a897a5a94c09239352599845eac7191d1269fe97b23793ea9e75b7bdafd51e837ea72dd064f28a0ebffa4e5568dbac9c8963a1f782dc7388676d14093aec77ed2632b51d047056d5de79aaa94fbcdbf8456ba24cf253115474b807267da7748d41c5f706e57adfa03ed6fd227f5896984b883ea31151ff0184d8c1b3249fd8b46b8c52e0488d79c2c991401ce92fec0c18976c8b87565b24bbff598e073f8d4ed2c1c6b23d1605a7c52e27c3b6a37f8ca47744101c0a5cd45628547b8bb0aa6e9788fa97bdecee6184858b8675149ae75bdc296b2009244bee1573139f45848f3e982c244d424248ff62a929447acce2ea0f4a9172003dfaf15e29ccaefa34d0b03e103b26ce83c5dddc5b7da2009583ff7a462c831290c60c831910b5f455c0ccc3b78762fa8724f1e50f5a73ee0e2b182d7cfccffebd2e562b5cbb6e11483677e851f9bf0702dcc42d4d0a79dbcedb5cec058b52943672d60eec87d5c2391529cc4ccacb62a5208b17434f80701137fadc203e18b0aa7504a21461e24802ed43fa23cd1d4705e26af090bd36737e8d00b78bdf02bc91ea6b21ce1080e1143fd33788febde88b305c575086c74d9331054f4c192a735f518c5f5937c387026bedf3bee32c18de51ad30ab9a277b05781b413cf39d71d77e3c6fdedff4cc2285fdd8d79b89ab9c8ac53613b3561bcac21995cdd8f66cecaf9d28c36baa1fe8180b1e0ff58030d2e38abd92b489c7762d48446a31670d9653380fc2aaf1169b0904b63962de09250d7b9a03a40168a358e4d26846814a004b2167ff81391a2ef982d7905ef86aed7e81da7cb591a94cdb2aab4b4df063c501606b4bb6a0d6c2008cdc9a851263364363fe9267f60fa909366188a94ca6ea8a13b45979bdffd8a083e32c7f7c1a73884e8930b52d44fbb05c1842377631af3808cdb5ff7d8b450cb37df270b459d5afb996ee834c22a85c884313165bcb8ace14a26deb6c407b1d4acf9f1ec29732e22f57a74ec1697d59cb8fc1fb2c37ad7660a34afa96541f1fdd9f03d78ad99378a37623d72f0c04360ae34ff092351df0fe7d68226ddf2a500292b9aedbfd02b0b000672233879addb3b971b7d243068d663a2b86fbac056054dc4f0f31f2277e70cbe9320eaf0d7bc608042490a5c7edcc0adfadb19b6a821bcbe8a0dd18b831ba4deb24506e6639e42d427aeee13f4be26d87153096905e5a428e103474265187203211aff952827526906c4fec180c26b9a367fd753b36aa017ff33cedd572a17d714b3b173b22b95901ef36acd317da6477dc44b511ba830c1e8e39abedb9bc2b466b8d48152a476e4e9ef3171d99849e94f8274bb31ab641b77aba1e953121b69506912b70744522b22dc0b96dda6029866ad5b488cf6b47ee459c6dc8ae05e9581df8fc04d579211265a78c31fb85663c13c49b76771c0a211a560dafcb9767eb42224dbc758aea98695bf3874b992fa87d87f590f6a393628513ae61dde2c2bf8643aa04771d654cffe9c810a215d9e4843ebb608adf43a16509b0f9e87a6a9a91fa962940735d358ac5b22dc520e4e6f5aabbec52092a0e1b73548d61dd908f3f2eaafe6688ea825fb123deaf3326e7967f81ed65e45a52df00e62cb3c05b07d838eecb064738ead3372a160952290b71ed53243a88ffce6a869c630f31600e7ea66a46c66c65105be77d490750d116a12221bede9c83cc7aa96d0603b5664bc4b2d636a015757ff29e6177f69021ba9be64d1a90cd8aa7b473cfd67cb8748b98ce0c843aafd1a3ab7b0db5c2e4fcaea2b5dec97f27e8bb0cf401d378b75f8afb4adb356195ffb6e13cd30e74393a3c2975362157867e6d98abf62b27b6a8acf73e2e8215485f848507bc187d880f37ed81c44d2b2ea06ae79a9bc2d1c2adc31a78afa7cd0a5622eda61fc9ffd7fff086e38be1b6ddbe1d00f6c9d1b120bcab26d73bba74cede5f53e1e8fcb351148a3b7015e61ed4e096bfcfa6f3f0603acef3f22ee87fd02b39c3ad531665522df46a01fe692604b2a87d5b885e571f099deb2a7c9a587fe393a2c27752c33be55375ed08f59dde14c708116f87cd726fe9742950bcf6c6286fcb97e48ab901fb1a9ef8703437ad55efd3334eeccc22e181286a824e954166074c7d2de0b68ff963df57f907ceaf85decbb2130b8e5a2a51a65e24ffeba481a74544191f73502407cc230c22014b437a8e46b2af451673f121b6beaf2370230e6d382df0ad1104b5ec90ef3218fa431914586716d935600e3109f981896a2b5235bc6405c77dd04f0a058f4635628b21942f8288996d91161ae99ecab602d2588c62adb6df78864ea42cad19c8dd9ec95db7342de3df4abcac355c927ac5ccf853dfcb0b100ce4b9cf2a004a73044fe57311251179febb90d0ceaa02c4aaf6fa06bbd9e3260b282f92181ae0aee7a16c1ee6faae40d2df13339b5127d4a3b9d8f5ed6c91e60e71bfcc8af317e6a9036625e5df0c9599f11ecc5a4df39a05661dd9d4fd91ed9169ce9146f349a48bbb3db45084c51967f9c6b29300e3107ae3da78d19c7e61542a2760bd0891ae693d0506efd1cd75f5ef3b187685582171af7ea951b2cc4c72286e3d5cb5469ee5e3249fa4bcf26e0af0668c8ccb9d5e7aaf9292545db16ffe02b5228d4d7c739cb1fd878601fad7743d6cce3982b1b08294132afb4da1ae8403676ce10436dd94fb1f4dd54f0c5296b42241ae4c473df027fd1cd68eb780b798dde3c3f0b72350ed82943464a5dadd001fd872503b1999dc52ab7cdc2b71a46b5439745b9062dd052cbfe22460da1bd24ff03526a23e6607e450ec5c56c322fc5171bd6f0ad46d6aa12c799fd5f4bcdcabb1526bbd73887aa183e2b20a6bd2572a8c68c5ae140ab478080cc9a14aea9baebfe2f54abc76a4bb055a39396e892c398733bbe5578701ff4650634fe466f1e569067b04185814cfb9798e852fce1b92cd2a7d762a2d10289e52201561e6e52f5467944a4db21d6be557292d047ad04bedc98adf0ae8b3cec27b3b895af89d02a34d7811de020698374ebed0f0776bcf930b3da62d4820cd02b3c4d0fbdfafd7618fb9c372311ce643198bc137895e1eb113eae66393a3ab2c749cb6a259bc3c94c31876cc3e6226887b13c1ce3af8f40af299a7433dcabadda2344db3af17b5ad2094ee70da4e4da877299a12ce38eb8a3760d8f1c82c5880aafc3c3d4f4748551059f04e26f69c531bfe458fac6cc81e4eeae769639e763750ea9231afc3c73be9c75aa62e7cbca5dc5bd6f15ef12b07a17cd098ff7792db3f531a4bea5d1860e2b93291c12f3422329d26170d5764641bd95db31da1ebcab572a3416ffd51e00806c9040fd4220f915ea6ad6676cbfe80e1974f09c0098bad545e347df932d3941c79135f6ca09a4e11f7e8f8ee61b1175ad82f1d1092c25951661b1c4ca32824c6e8c87da14ce9abc895668d8fdc05d687ba89e0b5635e055ba051d7cd6dc4279c31542c99d15240ac5d7c97d5ee2da9f642913b23967fdc4e45f82b40a955467cd17a64992fa84b3612ff225a4047ed486de973d891986960d782059c43ebdba66f5e957b13e06b512d83a117e3d0bfed6d190d2e58a23791361fd28cde5de442ef8cbb0cdf8da56327cc3b687c2f686bd1435629b5a1ce7403eab1a60843fe71c1a2a31f673f3db4ebacd8562ef455cc709715ac56da52a02517044feeccc9b9f9450abee22ac7655540166bc9265e9e6f5d5c4a9949f768a0d3b4408c0b1948b16a52f28a6f3c5c410b57ca7545644dc4e4051dc4b24f751d80cd2093d7964c18bed9862abe92b5f94fbd34d34f347be0d3424ab46dce29baf0ce7615376b6c8a6756946187c6fda75d7c295cb0b3209ecc85a3e47181b097ec844f550eb8765ddf6c1f750888178164fec232e19cfd0dbe2f4fa40a049a98bcfcc9d9827295ef92731acf318c4dc0ded7a1806d5b70906ce6dfa0679115ee6f111b522b8672efb74af30f4e43369c8989fcc7fab1f40ec390c7962eb515a889c7624dec77f18435eb6a3c43bbabc658afb767397c63c3653c8eec0b4f38a53b28e5a2522f30fafa428ded4f6eb098fb7ad8a4e85718c13e019f373867d77b637a8c93b2350928bc156814b9649c300e13af9cefaa5725a728f8bbbdf738c816c7f0b46fb48f32432c72ed961998f8a1608680c025c7862ad6bb6bb05abedcd45792e7952655ed110b26972b6dd9b2112718251b6d8e42114f9dca513a3c6d0a505b904901e6a6b04b5e56480eb728c663261a9a6c85f5c2f9c8cbcb01060173094142a748ee0523647e9b4b999ea9886c4fd5b5f1366dbfa11258faf8d4faf0f033e128ea6e6cd04c63ff259350b6e43f6e0018f1153dd2086d653c448f029f883f1a54040e9ee4c75b93095c143409b14edb04f874b7ebe3d99c1b6f71ef502539d4dc56f192f8d6aaabdb818d48cd2fc2272b3b9f7aa51ff442dad320256f008b5ee7b4fe60363c7a9fcf92af63085f2ebb5454bbccc6975dc24b9cac9e0f22e17966d0f1412d0329bb558f566115b913aa6dd7fb43ca2b8b6dd48f5dcc0c219e39011f5e557620bf80e92732936caef6dd7ca03ff8bbdbaa0f36ffb18bc00a2bc26e6a759d1631ba7564adff366aca29b0515667b84e152205104d9810c94f327e9df34534acc8aadcef76e169f6d4032276049c6325bb29c8b2f7b467c62969aab2c8333fbd4b75ed7e9d0a4e901a028a7e185aef5540d6e359ee744596f84f9338b6a30439d4fc217a7bf395ac78d0f392b0d230ba9eef918fae1f48c8c7d0be2400489c21534d9d114d23959f7b80f73e0570acc3bcbc5ca5892342f17af015a96eebaa4d1a1de2d14c047a0f34f63153c598d6711eb147b78b80f4fb4fa56d9b4b0b59ddf993430a21abb182f5c975c68ae766171459ccba161f69d9bdb23103db4c4016ac30846261591aa8adff0f7050dc07381b8f3431da53e2231a8138e5358f4df6b76efd37ea29586bc44eda9e8ee362d513a0c1f22c015456fbacaaa31bb7d4e905189f0d7b72d8b745aaee1e049139de6770310d33b99c7572d7978b967e07c3c6992f08098ab87ad9eeb0bf1302923ec91561a2328b02e4cb56ce1f644e16a8b73c2cdb87026d69e73939621c4215b786c2ac8c9f434751196655ce3fde5073e161177c2ba11ce3a2dc20dd133a761c909f4a22778bc962454607dc670204eb98169abc49aac0fec1843b1c8a9f4049a5db6d7cee0b06741d897ad251f1910a66c1e722a1efa00633ea3a35f0403999f50cbdb850499ad9a9d4889a87b658656e132ca168cabd21044062607772b69c146d7f043b20a965787d3fb21b6c83cbb547db9b788fd6d96bf9c277fefb7425d90fb2554c3235c25812e59dc370a0dad32e29f1e7fce3e4d3552642f9299ffb7533e72db6400c86944bfb7c64ac0663f21a77506c191c9067317a5f05ae71c32e30c6bc7db3a7c7b513e601ab6772eef36fe9276917e674674d32fa3cb6b3759810292b0a7c1d4894c674333f671039902144fe97a51fcd6ce73311a3268fa091756cf0cab331bbdaa357c519db9b40cb28371611d54e207f03ef2f3ecb50cafa033bf198c22fc81f88992028aa1045bc51cf16667f89b5b9e07d800ac40cba06d01dd60d4adbee76c1b1626d864bf9e0f37806c48871b1ae7a1fc5d74ccfcf9220d5f96b1cc9d8650927e36052dc5d0886e24823488effb0df3ff66e8ed1348d877d3f6254873397bb7d4e339c24d604a60cfde34a8f6eaec0eaf5c7a5c9e2f0673824359c608f42d6a60f67e86fe4d5259e41bd743fd3a45d5f25cdbb0d380241899254193df6c58c306ab561d4182013a4af5eb73b81cd8d8f2c406fb3547bd2d12f9f25958a10b09a36ec95de3667bb9bdcd3b607f282c368d9e78f0bb36c0ce4794273bc5787f6d31102488caa482fe248f1ee0f5b92c51e410fe4eb895be8ea28e7cf09a94c12d2d904b5e637c22b04b9d3a4154bc37de10870c48b3dd29a2df0398ac9e5d6b03e01b92be85efd43f0ffc3f43e0208ae0af8d4e618719c175fd471ec0968dfbb324b7d4aae8cb10ad711e3d59f9cc23a4e55b627410491c138acb46c464ed4e14cda99b486c1b2f493127121fa95a4166931f7563b040ed64be66a94b500bd45283437ee1eb6bfc010c1817120717744829a93c3c62bfe2f7879506f4334535c053398cc0008a5a6bd68e2720e38354ae826d407a391dbdc113ed7c277bf6049a20b0b1155293079b524bbb9eb6e375814fc78e87843ff1421b250b557ebc0a47dae51822e5cffbe287ced47e1ef270e3fca7cddae692d6fe468eeae10db8302aa8734a8069edcaaab128e381eb3781fdaaac9a56baaffb3bbae2e05ba8997ca1f71b9d551633b5c17198399c7758b7ed1d5eb7974c64c0c58053a62708243e2b4efb5a0cba5283cf71da69ec7f3b0d6a09b9f7d4b02915891beaa50528d1ce12d65282179528eeec9dc0ef74c5d8be571f20d7e397aafba0145527d2b6dc41933c22865e2b372a5734bf031f1c64e9a589e7c5464ad5a3b73dea492df8fe935543cc01622ebf73a4cc1b36dada4a8e3203949f8f35d957667a8fadb2efe9feaa749a232db87d2bde1ba4eacdad6ee97160b35bffa9876a9c3ee5a62fc81fba5b8dc22954489bb0d87168997994e2cccec2e9e429d54b67f62a239f8b5181f813af39bf1bee0043a9383bf78e574a1618b14b4bd9ccd03b3c659a0906cdff27927d43e955987d9a505126c62e2e0e25e634dd5aaf19b5bf53d5aa8c6e1dab8a9df2edae160aa69c4dfd4b8a71e4e8b7d131cdfe997802cd8c7bb81081bec02099fbc36e5a1401b8b4587cf43b27c7fd84b56cf064390c5774fe1b09e509908983ce2a4f1534b8bd1f1d3ae37996fa40386101487d8fce26cfbde984f612929443c5da84f798c2f224899802cf7b3e2207c20021fbc319ff06e5890fa262e39ee98a132020c4b6954805b8d8c0adf4d39c2ca6ff8707b6d9a5ac735c833eda428ee51c94125c18bcbea47ae132aa59f7e3f2a7ba1457dab152374272fae2399190195d247987d0e0ca9656918cb2301125cb11138faf8a2b625e8e4b0835f4ab882d9c6b9fffea46ddce386cf623ee4ca47ce41316700df81456ac82c326b4cfb93fe6a76f6ddb24788bfad38aa756cc027e8aa0de687f61dbc88761b382f565ed20f06424f0cdf6ca0c463fd60aeb6862b659aec21befdf02cf6dba8aaa07f9f5576f13987108592c96a82849aea5e82e11f6b0a734a339ba14102c03af26320adf01854e821149e884f44473437ed0388101032d91b4ba6128a4b18a1af61cd3b6e1a5fa4ff1193805798ab1220cb85285a9ab5633856f641dfe82b516541ab2d9b7dbd784932cf137bc691071d720696d6b1352eed2c6c9bf0f233436585c6a8ece3d621c5ac454cdd6e1adc5773f00abbde96b57388f6d56beff959244c242afaf11eca498c4ffdc017c632c7a9595568a0de42276844fa7ef2e85ff4cd6ec32c1dd8b9a3f7576729c9d3589914b2c37c52d50ae635da9a6d9f1fe8519ae7b2feda99521529a50c87ddcd08c3db22b4ebf36850011a2d02b5e9a850e903a529e1cc2ee9a092b318d3617a7eff57822b6ace81cf75dfc1cbf128d749e8eedd94c1adc7beb015d69bb80c8f67112fc4199504d0b26fc9f6a747afb9363603a3187e05a53017a5365051361a6444242d9c807cf1d477cd3b3f77778d00ea9e566e053e1136314187edfcff4676d1eb59af5051fa81eb8aa514ad2a02e386eedad38e1cbabcf34e80de8b8e860cbe53afc398965af6a7b8c3ba37de59d938f2c663e7ea6a4df1478114272241ed94818f2d9eb7724bf133cb9b971ec8521eb692b1ce436558c1e0a6d22078e8f9173f2eb1af7e4c754cefb49daaf7c2a5cd31a31565b2e7530fa43cddae58a34d169e91daaa9fe9e2584703aa631108663d437c7f43eace184a1c28394d05e3f34220913a07756902ad19650c66b93549929f61d0fc0f2f11f7f2c336948d5bb4037c931e1a24f293a77a00845e643e45c4ee610492b791e17b2b3b434afc94bd304b14d6813139828281e3404f7df9ca6efedb2ef874dfb38207f58e1bd8a1072ab1d29ad5c0f611608228c5ea2992728c0413c13fe867ad0d737b162a37eb259bb0e9fcb893413e7d7e42fb7e851d7a2895558961a6072415b2db34806502f3b30b7484c5d4acf96430b34809aecb524d788cdb2e8c930d01ba8f02ebba91f891671aeb5a6e12d6447989dc1df0087a2b95011a8530cac376e30ceebf55d61c1288af8ee2fc22ddedd9e67e4c150c80a67fdbf54c72cdf8bd0e5e1a83b43c99579c972883f92646d12a4b4e930c7b9624b3098e584f2209e9c39e1da8f09980fddb18584788dd0dfd0bca18071adca436d4b34140b4d2dbdef04bc29c55545027e8e4a2ef532c614f6205747f72dcdd23f7d3b1693ed53b2153cbafd40109dbd9f4f90043c628778b3c841e6af8018eaabaae93bbc5406fd9feefa46804aec1aaf5868ac62931bb88eb0736ca9a88ab0f0f676efb638ce3dc246b1eaa20e0bb49eac7ddf8e45e1ace3cd9f04142c9906694b3d05e047acb3b31d93a3a2b36111db12f31bf20e1ab38e5bce91599646585ab0a2eeac0a7599060891ac668e5880a7a82e468e4ff0a7094b55ba655ae1ac49f6832e4ecc24422c204482861110524321604ed6622f3c00544d2f0720e6c11e56603e3dbf618af9f78f27fb2a83f8998f27624995119f4977a3e458fe36b6c7839cc28faa700d72a0ec4db3d8d470d05e4ac574c080bbda24fd5cfd008a31787ca4d36432cb8e50e8eb6b0f79981c9437177c5220b6d29605bfcd0fb8c16b9a7ab9c36a18e247a2a670b668e4139d8dd504f68418238e769844d256a6bc6c9f0eeba5766c9e639d15aba42cc970b0014a81f78261924f7a4837c7af888d01e4cb54afd79943cdfdcc1916e0421d9c1df8f39b918a4bbb602ec75c2109cbd5cf084b17f5c0ab6e79fe6ca9f5f85405c60754afe99ae999e16e1bebdb3b1155cb66ab9f9e9fcf01a2fd85083efd325008591524486e85d92d80070c8bcbd1e6ecb80937e1ed5ce18ca3529c3852666361145a7bf7956a48bfd49ece3af23affa1e956eb037b1be689d671ec627f521d5aa806eaaa9780fd8e10cc788aa515acd8150a3f64ebcd25fd9e205ddbc42c9d075b465b9b84b9548f5d612ed96ddbb186ff764ebf4d5029f929a35c0459f9bf9f96c90a2e63678712ac0976b1235c46b250d1d4127254a8f80f240b224fd83816a46d31d01feb98a0016bd6691fd63413f840ca6ccbdb372ace6cc1a0b117f724669de2063e139ca977418e6c210d5c0e843f7fc9dd25dddc919bc1cb96e5233c1c92ba536a1ed0fec0be33e562141d908d0b56e36e69ef34ed636890dddee3b8ea6674bea45901fe5a14dea46e33444046e68c4e807642e88d1d63fd3e2a9f1dac3715441fa3b51e1ad51e68ce2490abd33c53bb2e4eb131485d3ef28d5c603cd1c2533cf5227cc4daf134be636017a45731a5f1bd099d2441fd901ef72ea9623f6d34f559e0453dc58b31fbdfc0f5a8d0b2ef4b823be4c5f881d5cb12a6cfcdc8ad2646943666ee5b8f1a1a6c53b43b60a325c724f9ffc694f7af4f82ae2339b9ffb21824ccda24d2d3ccd602d630cdebc9f083858199f28f44f169e84a0609797281dd083535976ca8b9d655f7b159dcae417d5d2d560b43d26b0a685b756e1631d76a099469e25f283232c3ac52a1a3c578b08e3826350eccfe66a01905c851d0b0c69d7c8ef965f19db434cf6248c3c1c7f6c715376f952e215bd8733c08e8e7921c30ade53e3aadad2aa648ee166c750ef7e7e3eb8a7434814690c04b9211f6bb8f0194a637d447debbf38969f1c66d0a02e18039ac624252e7774c00fb903167a84e34f1e62d1c66b2c65ad8c150730ce53b1252fea292bb775e95c1db19800a6e43f4283f83f12a0993b5146be7e441cde222b0925626909b24c8dce96578e160c0d16e4a54c50db10102543abb57f04b4c97cebb7243f45d3742a748db26f77e68d32bb463b07f443850e02e768126e20d843d51148718ad2f0d8721d1e95605b4bfd3a5cb8d5c472a72fb2cdd05df510a75eefc71e05e0e8960840c701e465d682268b4b39d1f5a06b7ccefbf592be3559bf72cc33baa03fb37ea43a53fc07c143d6863f4e3986e6798310ae75df706ce20782d0523b22167bf6bd4459aa5c4ce1c846f575c73478b78f98e86b0f94ebd3e429a9ad3f98a93b7792f9d3939b302d47c5cb5eb251da97a6b9d3faffc4cf61d567abddc9d15795e55577817645ad37e77efe3edf3721014a87b95b180a6b6e89115dc0f80210d5757c01ee077adbe46de3fe9b8d609e3707248f104b7116aba1eaaf8aad9ec8c2d38e8b1f248992262fc5c7fa44663101cba1997cca6ee63967e3d31f89a74775399825dfba275ea85b96b39afbb2ac014b0c60312e9fd58e2ccd1e632ddfe0d47a50f10bc8fbdbf633e5e168857fd3d19365b2556cdc431120b0ac4592f4e1968685a5a83961ef3e3766898aabbf52de5f94223f04d978938e92b8f21abe7edd8d5adb328bb387944b0dd1bdefe5565f54757196ca8ddec0a0ea585c10d043a58e04a868e6a111d91d29c817749ff3d7ecc63bbe63e8e6e308698da5f88f015a84e4809cbdf90b8959a893722a7a1483ef5df04f6d4ea0d2abd71bc99ff5b03e063bbf6a9b5d816282b5b7e4f83115bad2e1ebc985ddb0496ee84f21a52f08613b5faec44067e95841e143ee97e0f874fde948e30efde08375bc74ea3f804289585aca450dba1a7a42fd4009fccacc83e091dc6264963aae75f621d34ad26836be7c4ac20dfcb186f2ec056e503fe512732e8aa01b09c8ec006c86cca31d324a660073f43f6d4b9f3011820b89007316c99147a5a04cc0659c51ef8f6b02a185f76776f8876bd19af2ef5a654f55d3ec4b9d1cffc68ac4d7b9ae5b74df2c4ba2bd2f151c9ddbb5284f37a3f7a56022890c29a24eb4928a9c7bfd0ea520d6e8cfc2488043e83715c2e45c3c912d561b7fe48984e9c05725ee98bcc3678dc2743f7cf255296f8393ce4b0dc4aab5e0ab036e7f28dff04e78c42239328e2a8c724f9675e7f0364273ef71e49e428b8ef429e41da7ef3b4ac4cf0dbdcf098117d35865aec7fe5eac7c7edf30822b34ac7560b935bd798580edef8d89e3d91de8c6a13344ac08a0d6718ecc0e99729a07d7c72ea6af376a9d08ef2dd035a874c54127ab21be240707c03b3cbdc4b1435021bd8f8868eba46455f6b974fb68d85cbe6fb0e0110e6bb3b18779a79c19de31b58a08d89b15294492a70fbc9b522214c8cb7a3585dd250c318dd8d79bb456e9a60a57d208839e139ae0acffd75663216c94aade4378f732ce602f33e8d489edf2fe3f618452ca8dc6609a28b2f2cb56a1549b50c061777819124ca4e900538f53c9a181b19b2bd7c7974c0609a45f9c6ead90b60bb2512a75f1e705c039ce67d0b510ca23d9db04f788e7ebf32aff978e2bebcd7bd058c7079bcee71d315de431c220c1e644c395cd4bfd7b00451c6018224941cb283a68298f518873e9061bce4f79103c3327452857a5372c07284fe534fe7cca8cd5f6af186af6999aa0cd040e538962261d8d7b2c79d72bcdf3e0c3f838d9cbe449f6f46449a4cf27f0b7344ba4e6ab72f4d9d99ebf94d749a6ae588b0d59d463234c29fb9e770d24d51eef23804f5ef7846156bfe308427dd2d72cae6de40b15c57db7e64dfb8b8bce00658cdca18fc77aa1ada3f8a17131ef070c4420398fc15cf01ff461b01ad3490c411d1d1fdd78a0870058845d92fb6c761074258f478bf3f0b64bba15ae53811f852c441b8f996e2120cbf77a18b692719e7b4e5562811f27933753002956d5f5f3958d60268b92c7adeefd74a23f8fd4f445660b343f30581dc25478e6f972c6c9fb984aee1fe2379701a8578f063658a8db73b43152f6f55dcdcb47bdd22fd0a8fb50321cd27e4333c2d90248a6b682d1bbb383e04ce4ead8602d64902094f2ff02fbd8d476a9c76af4ad8d926ecda87eb59a0ecd7de3dc97db980173d9d817ce96b4e92042088c9c31f456996bfc5f73de742de4cab79b3a4bf73916aa42828d8ddc32d1eef1c1fd2b9d362ee854c8eead19e83c4119fd0cfbcf54f6bba675b600a69081414e943139ec33ce4cc8881e2c0e08eaac0cc919d80790f077c763febc23d4237e65dd459ad8b8429a30af0c13488cde299ea08db2559e29e91a72bde999f5bc9232ea261d067751853ca440185f459db11b29866f289ccd8245180b34f8933f97cfb48f706b395d9f08ea11173030977ea9a627e6c0aa756fdc7ba4d6c983d94da3b1a7655411bf1d2526621e74191ef4af3320e0e1459e031d62cb56b79536ce637f60494fa3ba411fca1ea76058712c6b85ec70b572f1be16c31eb4bd8e89a66956bdf3adf4f5e5ebfe5e3b3b08884bfebc40dc89288370b02be27e01da302776d95d190ae9f431da83004876fcba25c203681050a5922e3e26cc2fe94472f16fca7c2451197fbf1443fb84f7c036e5be542f6ad8bb591a18d3f21857e3b3532cbcfbee4490cdb817a427e0cabedd9cb759d7fe8dfc8dd246a9c12966685958829f6292c512ba52383ca09cc787f1304853f9c49f1ee67f09a8f0f0afec4a48ad9cc45698a697e2ae4e442d221da6a417ada3b87733c2f45d72461259011c7a6b375e71f1742386d4fe97a59199381bc7987d2109de52671b00d2fe0da4d736372d013e9d65615807ff76443d9422cf97198336bc925fdfe56cd630fdfa678ddf79774b39ca29643a043a6501dd37e4bbc83339d22f1a6685528c9d7ac7738bbb810b5c83f6532f555415ea1787701a2ecf6f990a7e9b7d4765065c2a799b9c6222daebf05f2b6ddc22b14e384187a08ccf2b856adc92056acf5158b8294a2fee8e111465d46e555bd4dee8c5bf9079991857fabaf56dacf75b7ae5602a1339d2046e46524f1c4e76638593c747673868f9f74b5a1f6c131a931b204954962fbf5c3bd4ccb8fc036e40c66b21d72f5e345468cd910c0d2331ab453f4e38e7b5c0fa8394b0bcff6dcf3a731fe9cbe7f7f202905fbb9f623d6de647e499ad866391657be2b75741fdb7814796319fbd39a10129cc4660b685cde9ee6dd720c73384af4c2ac93d89aa1ded4b91ff4277bef0840e14eb8b25ed9078ab58de33b1e02805dcf1e4da8442081698f3caecb0b0d4ac4d3226115b42d8dba2b5c0771a37350f271c8ca7c8239ee23d9c30d8cd70b02c07babfcdca985a338fec1cbd82339c0e0dc6aa49a99349e2069d9261ad8c16fa37e3d671161c23987f9b3bbcf1c064afdf7649e7faa32e80d0c341e752bd69cf9c154fd0bb04e84071df3c3a901a78116d1e5533ea5c2f3a536b71a3360d21752e40abd74033eb48a94179998afe35fa91ce87c921ed51ca04d2352b7b6ddcb461a3eb9d2faac8956a4e3091773404bd57939c5fc407d10e421820155b9fabfd503544a3854e55ca03af4ad45d7ef6dc439cc6b827d1aad46d30d39e8ea9333ed2775e4553865f87c9ca45b891f6a4c229775132adbfcadfdf50f48fa8b7c004db95b16f3672f3b2545f15bf24c515809736e261beca06e10dadec0ac806512acd8eadfd1cb65e75e572ebbe9cff9ec468593fce69081e5b3c62b289eb4016740303f999f14785edc20c67f70f19ed5d982586464e867a9a538fa0c4cfff577a8be4e9ee0cb4c2cbc0fdb80fe05a8c5c94cbdde386b0a35ac12576a239f1f1e754b05eb727bfaa26dd2e9ff40c5c234bb9ccf6b56770102d60f1fbd94787b22a5e3f450a30cdc76104d31a9792355eba4876863d3fa9a5f4e38f596bcb0ae66e2c4a079acf120301fe71a859faaa90e77a106e98417ec17137c34ae0d696dd77b9fbd9316d4d40f7644edb67224fb141c8997d3ad7c417cb7346e0e200b147dda7e06ea41258fbf5ba8da86f44dc09141a4211c6a5b7ffbc9832402e28495fc4e044aec589a2c98a2163a382f5b72ac8726c984570495023498229085c6cdd3b7f8071afa6aff2f3872a761f1dfb257817d67db535ebc2b3a3d17c53c5aeab1a3ac299782f9763abd2eb352e48a4539013c78dad787eee596c3a8a0daf85d7e4ba41668ff7d52eac1547563a6d0dea424fcbbcfd2941752c6655ac2c31f0825e3404637917f14fb47c2dbad4eac249503e991d6b0a7282037d3f464086c263b56490a7f1cff1458fb454eb60ab6f480e50dd883f09472f20d0b29f80c9dea73385b650b524022460439ba58934168dc836045b45ca95a734ca012bb81293f447a08702cbc7937041f796574ef6835dc97cba20040941e096b423a131084f4e8eea22f7d26ce08e00d84e10846348e37cbe771b2e183ff18df5113e3076e7544a0d18acdfbfb5554097924e582913d97dc425c57b1e08b9ae0ac715d47ddac9e825f69d71a456b030fc5a4003690b77bd027dd0283919637ae102eb29f0d4425bc06a88e0811b0f32313af2fb5f2973a704206eff314fb04686616ac64ba25f6b38072ebb6390b0ec549ead6b705e655ca9be44ca053e79aaab88ee285ec299465d452f6e25a78a538f3948fcacc091adfa1a35b4f4b03dcb750900c273e581d8430c874ba0871b3159ef877280b9b022bf4f15b6d6cd258c3cbc446c554848adf57c067b8e44d5aad3e77300ac0f416d634264c4a3ebc413fb901bee47eba9f1e0872cb6218f418b3a2dbc797ed62b5ff549873fa914a6d3891427ce0c0d9f84757a581af8afc1c07727b227a0921edc3152978957c5817cf6608cada185136a13da640421a396e48eb35f3a0e5eb61c8815b4336276b872ef101350d169c78474e0ad529a7516d83d6ac1eae81de61c6fbe43ae007778dd36ad2ca59bd5efba5e5584343fec1dd4915939a0b43617fd3e3eeb20bf0abd2a0d72eeb31d59a75b7a8ea8ea3501c9764cfbc97dc423b4654edb1d7c451ff418b24c56f73d41a48fb3ce40d1ac2c13b9cf8f750dc7abef70b00d3bf99b67455ffdd75d4624387febfe31177ba1551bd3acae060002d916c26abb7f64567f6976eea4a97a41dbaa775330f9ba4369bc8859023ca65be48fa69da81a7d52b8080b714ff798e27191e984ea61db740acd3415a126b3579db29e4e2af4a20c734a5e5aad430e35781a980478bee0266b5c362923337f01b970d6817c1f6fdce889fa8a1dd416d7523b9391940086c5d5417203e50f59c2bcbea8b33012cefd7645fddf31cef5cae23095cb52e638d1a22cbeef87e44922f2bbcd8774faf23801ad6c0e1cc5f832263833c479703d9edda8badef12b866378baa74eb2f44c809705b18fd2c52790ea4374f242ba4af76988b387af9a71c9f3fdb5794333eb9a6d3f08e2a2a7d7e97d1eabc28ac20f8b05dae5bba09bf446d6e6b302ac92a4310ff7beafb36977084df77f436177997efd9e94a5574479fed47aac4a855c5464bf646df7694c3e740a7c5b1ca439e311ea05c86c37614a0fa901c962121f44882fe6418498b807d0f5b816f6efdbd3b00418727376f08f133e8db75ea7f2f25edc0e4600c9485c45cff7b039cf903eadf4f72d131d9cbc2ae6ad6ad56a925420c0873ff297e8c40eb1c4adeb5fb3ab964971fbbcb927111832cb05a7b0687ba4fa2e316422b4e6d37b9174c757be81cff66decfd187666ef445617576199c2ef730d63acde0679b039bd8dacc52a3c9f40e3aa05a3caaed99532594ca91435cb7815cb12848d849aeb8cac4e8261c1857186f98eb5384279608a268d9d4f9f89592d0500c0113e1ec0e210e33978902bf2a7f885d060cb4800f84b9ffc3730fd36d25dfd2d3cd7b6dbe7ca092de23627000139874794793ca6c5c6f4279d19edcd015308a9e847336bc050162afd742818adadb34cbd82c098cc32735d9169da851cdbcd1c1915898f9c36352073f0fd7959686cef449a769c4498f98b5ab153466f3f5caa95ff08d585f39304c619ffb89b191cee51d977ba0cdea5fd57086dcdd3a5bf893d745f87ff71271984a51f315f0a3546eab3ed73f1e79f24a0e1273057618fa0a5fefea0781f86966a0ae5c86adee9c8896c95cc6c736ea3f1e53291814ae0e2259825ca4f8c29375025da71f197360a0abbbd77456352871324796285d79cb369f154371fb8a4436d7069e7fb1b8d50135181b027b4f8ba9fd143b563facb1551a8972b4b269390d043cc941b49f105d404a576255d2ebb0a14d6ba8a9637a10f73e07f02964481e41bdfe6c9dc1a8a56a18880b74daa05da038f44c8163142d547d86163f8721e89f25d9054bb842ad56af0e785fa0fbedebc4ebe63e3a6fe6c2fab315fbfded3e334f78281a474a9527cd91a7eb6d5c7e60c77fbe563454b56ea3039808b15f19ea6e4e471e6c4cd1b08ce95854b25d5dcaed1212778b355ffe88c198e0d9ee776f3e2574d76d9606ab08934fb5715c2be9d3f1680ad6363765147aba2adc220040b8b861a31c06fae7a208ed57e4005b8dffcdebeb7ab3f1781f6f0932565a021e633b095ce73ab9526b6489ced40425dcfa71c4676ed29e8ff8f48ad9fb4c8680f95d1a043692fc37b8866fde598a46f3f8217fb96f050ebe366dbf5df5250677c7130c6b97358be461c0fd098fa9e6d021e64966550620d640a6b9d8793ccafd3fc834c5dddb912cbf7b052ce169a7397bbb495f2150f681ddb6c883e3df79227e9693208a541a3e203b99693add5c36039521da785e009c1f564ef420cc8c82e543fdb615405eafa84f22d4e54288df54f94322a1e38e6c2b98e5921c0b5d6a549f20f107aea2756b097fc35374f6e50f6068aa31e3bcb2876870ebb7199fe413130e2628b18ca0741fedfd7ef9f416e396aa8d4b5ff0af4a28090b6adf0bd5f5b3eca0a08e083baad694b3f239068fba191b85ed894cba39c681520af4003c3d3cbb5f2eb91cfa606512b009bf5f2f9af8d241384487583a44ed77f7f10a3ee1291da57693e0264b6e259f29cd1cb66e53ab38bf232b1d7383ac468c2e3023242b808366f7896cf0f48d65148a9f18fb99dd65e3f52b482b570a7a5a6f06cd208baf2659f8e02cb301c2a5077c49f40bd3dc78a962925664a03e20b85296bef9f15bf212c552435cc50e7b4850961cc387ccbdb0bda1434d042d2c8c8085042395ed550470b45eba2d5ffaeaafcbb950719c682cb1a3648e3b1f4c8efbe048cf97a2b1cfbc491f9531ed4720d6f6c39f15566fb5d5a272027514451e4a320da31db2e98ed72b0c0d3ce062d0d1d2a952d83801b0f98eb782998c01e9a257a2ea2ac389596fb34444cd0714174fbb2a8fe9ad24770993e12cfa1d504d7d5535e88ebe8b134fe7834ad600270fbcbe9983caa590a065680dc8b764e572e536cc20f1d62467d1b459ba02b04a57e7bbfcbf3082f928a0973c315a73e0e53829883fb75bc7314518dce34bbaa82f79bf9a45f69e19d3eecfc467f71c1ee29a078e745db2a728ee1c0a95729bedfb16518fab3a38d9259d1c83ca5e68acf595060255910dd2d17e5c767ad58c4e552db22c9e91899de8e7b790a9e03c83a70ad35417adad44290700c1c8286c32a881a7658f9289b08e7ff240902dd98261afd193d506a054d02bc5a2e25be24e1dc8b736a200d9eff8630a996c5f6ce91bed1c6aab20d056b847bb9051cfafdfbd123b0c8013b0bd8aef960fcdfb66d0319b83b8a71a7beaba6da94e9cd5c78e18bd7dd60e9ded0232fdb5311d18cb3cb0dee7f9fef66b6823f5e4a044d7a6910b13016d53167064cea98e180402212650052b938ddff336e2ce7a30b52f8992a20ef7a5960177fd6fc6f10b6a41284f6802f9e98e9c0f204c1b83ffe76d2117b617b1dfaf4042cbe54370cafa39b22a149d41c4793d2df6c223ab207289d63dd520bafb3b07e7aec550770f4c23065a50f3589c3b4ea2f346cfb1c808f69d8b350fe30a4973fb1fe7e43de8f495e708dbfa1358d80bf1f8fb91f4e5752450e82d1ec068adf8f3b3ac2afa4b0f5b0ad3b8fcdfd4bdbb8dc05be7a5414130761132df9dd2fc4d008bf990b5cc4580c25871509a1e7f76a01e7980654966ee96a14ad7679221b349daf2f44f31fcda90c46ab7836f3bf76003fd2309e08b08ba974097cd1efb5d20585abb2787c0e1206512a8cfaa86e025f2bca92122495cea42712cab6cbbfa9fc042db937097238ccb6ddf0781bc0d6400925a454b965054db5e56c614c1a2ad1e286051dd9104ab77577714e5ee97802fc6446785b9d0c884c7c801c0c464139a203d9dacb088d0760a6dd0cf59e165bfbe90ba77367e2ea74e45bc8b1282c6dcea1ffd81a5598397f1c84c830252d6f1f2a12d55b03102afb8f0548b5c63ddc1402942555ebfdc7958014358d19d48a5c12a2db5122aa18885f44954cedd2cc96b61cfe0064a6a73422bcbbc2675ae83a937c6aa828002a2a8a69f09da47447d3f79e04d3bbe9158b4725e07e57a5be12af9c6603d9bbfe0f34bb3bf7c4beee3fd19b6a086febe818c4662d69751a6e1e31a54b0b97d9881e2ee5a3bd2f8539d4044b4af3658c7b67e8005e264fdb04207d4de141375de0b40a0871ebfcd6513a4dad40e0675a6c390716c6fd0b1f288e44f562cbd3b764ca58930dd55d4d7f2abeab2e432b615fa407a50f8f324b3a3f17cff4d8791209f0a71e1474077e4986a4c670fa5f3acc6170a6195e1b34bcf95e1475255fcc658f595701f456526d1f92e5e8535ed232a8bdb3546f1f5603e350c5088cb4a9f4d71168793349ea0931d18a6a9999b474fa7472eb4b4e933404c3fc1b6f789f7a48b50c966a13b19af4307e9fbf91ee49a053a53554d1d1480f68c4e0f0e63b159d88c21e9e352ca1f5c2d856e9db503de20b779eea0815fc88cbbfaa00091cd60bd340cac0f13d02147d2c58edc0b7746f272ed2035f03410d6aebb8626b5519254d9f488966ec3b9a174b8eeae6cb8e50d4c12c66a8c5a5a2b0b75fb63740ad9b717e0a0c007715ece03e4c8983a03adc13e827f6d000d2668df7959ab27e171c85b245548126395568d1efebb04de5c04426d3bfa5e195000253cb016c197d4a1714260d738fa8a305ea11463718779b05b18d9f7b410716a65ade536d896c4f98456346d64ceac62e3c26ccb96b451f884459c079ceeb483c5cae1b894719f4f4062c1b2d925e54b94718f17e205e6bcff35c597b9de8235d2fae4468919b9a9699b579c616ad8893ffa039a0e3a4b1aa6a195d8157785e44aea7cc76665ca66202f03fd8d8a2ceabf2e5a2041c3368b780db4c394790d205265c398392b18c1f6ec841bb224e252208ab8aa8eb8fe539343a4a1b802780322f61320b70397524f2b684c18498d890c97858a452961ed21f08c6675eadb9698a694a8c6da19376634b8bbdba077e112f10912c96ce874a8f38fa4eb6b70824536782452fcbad88a2507c41d6ba0e25e850b829d4c67c0bdcb4a0d14069d11efb0e50bdad5117dbf2522200cf3634589ef93d389108610009821e2ff9d14bb0de4bbac4e88be4e7650971e14c8b4689d44df3492e66c15588c4e1df80e651ec7e4f765f37e46a9a9b61d78a94f81466d7541b0e1fcd008c9cc391ea79475d5f4c0fb4ba68ed37e1900c7491477c838d77020f39709061524e9df0bf4e54fb3e5e32f85f440de85c5fbc33e1415f6df497a0eb9b323b6abf686b567fa944242c3ef4277fdfca2af8e4cb54db1cb641d4025fef2e7b4e17a2157f09760847fae15202a0350315eb34f6385b987a70930379bd66a18b7fb1f39dc1a4e4b4e0beaeb514a8c232f95adee17e42bb73b2157b4e5c269292917d7418208387dc6c3b6d3c40ac5c2b8da511b397a4cbbad6e8cd4ffb0d8466b028c6eed498b998efd8f2d275b21dd0c4ac8fc41665040f408023f4ffdefa16cf50020563796587ca7c4c16bcdd1611e4a911cf202ffabe22afa0bffb3689acb680ce8144356a5c4cbf34a48a59a46321e0e450a9daea191139e23861f85fe3d4188716bc4a927008334fb2256bd60814363dd364ce32aa60bedbaf365c624b5dd439457c2108a55408a1c1fcd5f3c060e24063758505b240744c0e0c8a65b5cbee710aa48e5be8ffc4635bf59746fde44346accfcac895ede9c77b7f7299aa45f575c99035ce282131120efe74c3bb90b613779bc6c23c00d81f58538465d0664c5b3320d4e65ea75a5cbba06848738cfc6746ed0ee7cba6a5fa1d7cef4d369c119a5d05f52695e018704f0cb49f7005222b327d5da58b1004de652b0d0621a738c65ac96342812e13dd4106afd99e63cb0df8d35b3dfc9d8d254ed1bcc91833ba653e501d438e952c8e7699a14b5d75c7995461c52643d2bb182ba6edfc41f753c33c98b941f489e137a6e6c659cf914d00a3352d085973cdedcad5c9bd2f21f01dd939582c767729a6011472a917c8004afb6e22f952e8d9c99908098aa6f4fa803b80bf2bb03763b21b199497a5b4a5e6b84b3e2dcf7de707222b811b5c6ccb1b82d19c7ea408f3ea96835ad3b6e90754f6ec1e32aab5c4d6aaece3c60653c1bac43f368c61495a8e4fbe567888365bad329b14353b8de6b225066a27da89f25b322349e9a9ccc3770121fda2d45304e40b039338c2fb80ada80cf46db94a08fc263c816ec574bbda5169be31976e0e02df7593b3a801401e365c9d7d8183f83d1abaed9935011a5ec6995a66ec3e2f1168cc5f3d5bdc3e354fc011aa10639675a8211b856a2aebce887acd5e65574811d7631c2dd4819c7fe46ed126412d3a391749b33ca50e152285c03701df0ecab757bbd9eabcd6f24ac2b3a73a3753f59c890e2ca3b0abb184c0206f968e225f7d943938ec4c9a308e2b6bbf126d1fa55be70cd922c4fe4b2bb15762d41471f796ed7615629e7e1e7583fcedb34b23b84c68155b9a7974d5e6574df18401cba50ab289318bd6b2ae03b47fe2f26d8a89ec205b2952ab98f63a9178301b4bfd0d9919bd70dfe41397a694865e6738d563191b2dcdcb0ebadad4d0ba82e356cebcaed29cffc9e053860956c62ea238a9fc9a38616b937fe18e4a593a72ccb61ea6f7f9219b41135d7e881d54b93d031eedb02382885f68405ea9544a31477744a025af86cde4fb165aa4758491864619ace1df97051f07d75dc5883bb111bc73d61c808c0750c42b3a9374561ad3d8f93b57ccc13d315e229ff1c3e0847b18eaa4c7a2212f31b3e7cca27855c3538dde6f556b26782a0040c094ea36a8054191803cc757de6deb0c6471d352cb4514e42be4614999a57bb4fdce58eec659992f2d34b43e888c5e7bb6537ddf16ba08f86e6b091380f6c563bf940cc53285b3fed23beb02efd72677e4e33dda79fb04203c1a8351310d1b046ae4269f456cfc115590835e26e9a4971b8fd6b075eec9d1cbc5fb574bb520d251f59a8fda7b56d33dac80423ab92cb074cae8fa4f63ca573c4c242719e47aa35d3a4482a870be44e840f57c300c90c69d5ec33de2b3b297f2bb02f25559d4abff765375090e98122114bda2d87ecea9c55d3594f9175ee1ceb3c33ba2c612d110151b9a91e7c98d809d2cfd3de2071b9b391cb1aa8b56d3f769d73e65ef76a1938c736afba886c0c5d00a0e07bba51875c02472fdda93b19ecd0c4e4e05792e620263a89543d00dc7131cd744b4a084d28b913c9fb9624e17eb1982dfc2b2a8bfe5038c93afd7e84d130acc51107df575438ba963c2dbf15a0f1720f870d9360e7813a93916dc3c6e9ad9a68d0600179a79dab898db4684b87ca1141c8e5a0a0ecd00c35231ce3da0cc9ab43cd6885147ec6a4aa49664cc097a1fcf31ba7ebb7af70d020ef6067f8acfdd1bed287f6806305f35907928783f9818da3474afeedd3184f1e1ab7532d43bd2398757da49c85ee5514aacb04b5bb8cd862b4c5cc361a2a5f4266fc2a6023d8d38146ce32d8755228e8d1d183b0be2df7a6fc52408086db0d6adb80fe157c99f80775853881c559a6a3ff9b66014c6689afdebd50d44921944780ca3b27b102c64d4df803dd1c678dc4db8496e65e904b02c338f3cb700b92698fdde7c5e2dcb094938af1773784c9a2b8a02e9f1419891a698c1c189f9e592e4325dac7dfeff9af6eaafb0ad1ea350611741175c6d82fa92fdb9fa245aec067962d87837718252282fd09b5cf4f2ba4ca8be08c9044a81456d415b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>离弦</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E7%A6%BB%E5%BC%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7793c6799414b638200eaff76d597bd971b3147122b3ff44212e8e61ffef7c66">d56b34e7a4f816ab6ddd5cbbd580eed688b1896363658e240377409afa1394c5b88a085fe21e78a68ef1320daac253a9bf34b8d2445455cf625826091f814e32015f7e7f63cde14250e0f46f86dca82622ef41f2b2512e1cbc79dbbbd2a607fdc8b31c07ec0e838255d7ff99990e7c922c3bc85c7193adff239c0507e1152cef139c11d1163528879aaff034763315dcf942918f5898d6cbd1c2289dce183aba912fa8fc63eaf493846ba5c89983081e49cd762b97033ab30ce125379430e13d5a0a0ad894f58f9ac172c5b6eed978caa770564eecba9f0c5a6c1c1c6a215bc5847b4716a3db478327b4e3eddc62de52924c133ba8d8d86cc8b9e074ad6a6e5b3f9083d6c73be5d029c921b2a5a7e587b824a0d2f64b0e45c023c546fcd67a73da5e6182f5ce95bb47012a25c939047515f061c15369cb13bd43e27fb92e195753c86868e5ae044e19e82d32fa27c347476bffcc07fcb2c3592353b9ba73c0c1f4fd40d862aa9e195000a5a471566daa5e79a065da4e12c06b0c610cdf1915ca7675f97c8e988540577225a92a80868b0c4c3e1261a7c120375febd80f65c2a69f259c4d1fbe3f43665416d848156adf9f50e800af7b79fd0602028c0c9ee9968795e5f56edbc018c065ac703b973b1775b757f21594b60ebbeb402d7a8e241329d0345a7b17c86659bdb48bbb89d62c348c1c8e85a006e521fca8e236ce0b1aa834eb8805fc73cb22515ece1d4f3f727689564f39884777438e0c63d58569ad1282d6078d18f6e28ef286f6d9f12e2a7f92f97fb1fd81e337dbcc9714ee8bb70ae5306482d7114205cb20c2b251217aa3360bc51a7ed523e5f0a2c267cd296a8a6ee1e8f228874747adc024ca9770567c7e83dff5496be6f23fbb555ec9afabd508bd28a16bfc793b0fa570565ff7449b7a9307d53cdd33a7c55244db4897eb772e0ba0c44298e29ca6558728b9d41a429bcbb21a6e6a453e07454f21a071cf0b83af82597931d155d49f4ac5ca36f7fb3a1254b4a611a8953561762a249f6f091ae0c2e92d0c37d8a447049fe4626bf6ff09d0f1dd3be836d96f62f78505a9edbc64cfc0170dac028229ca1f3df519ca81818eb62901456199e7d95cd91e7e3affec3bbcaf9ef08568a805ec7a67367a4a5e967aeee3c6f9c78450a0eea5562a6a8638c6b126032bf7eda1bd9b2d38290a005102249ec4117c3fefdf836053e6dfa9495b8a0922767ee18fb1bf1d8b0bd4c248887b0df0b6f4e5ee0732aecd2eb93f8b394b2dce86148fd2b846543c952fdea75ae80b8655d46d6cd7a25505892ef8b05afca4c6d09377bcc7c3dd19a6c363fca765da3b349adf89016a9d05044d1b487367ffa15cfa92d39c539b64a9a62684d37b5f3900a2dba01a422b7c91e43b6741fded757bf21c436bfb00abadeba8ca86b72d24a6c72aed5864025323640cd08d18c6e06d1100d371ec8d11081b4582a02920e30e9edc7f190fd72bc12851f7f46c6181a0dc07fb992b7f8c39acae8c82e80ef57f4521253847d97bb2fb87ac2c76b69741fcbf5914fe84c00e4ac8e6e97eaec13dbaab8348c7ebb4c8c8ba974068e3ec1c9b20d3e7fa1d03c7358156c3b51b7825ea2261420e76b9f2527f5198f17949ff320539355d57fda2fcd73f6f70de8a264a398b58612b4f7801f95bad12b5b2cea5c8448793ddc7132ae4c16b569b836f0df937c5550e8a7fc0150ff9c9dd29a71033f7464d68a65a3107a7bf9049c23e6f4b7319f744f77e44ff04319543838c66ed639289d24245805252d9b101addf3cacbe6a64216d52a7ea5c47a3926ae669b82a24e2d2835750c5adf52318535cc7e35d0a844a0b3baa093eab8bf0fb8ad169d1aee94a638283c53f0bffe6f71cefa79922145319af60e4adfc3b29f897b532dad0720dd0f01bfbe4e471e075705ad7ca1a50834e30c5cf08c7765542c38d14dd27ea6675dc512100c72348ae7784062d98b0c0958fe4846db83938fb12728b7acc002aa27055c22f76fb06e274eca9167f2f93855a612283039560f84fa5d668d4a3e773411faff7e4dee8c1dce82ee609c6cf23bec7aa38828938198c5cdaa05bb97c0fb7be1d474c9b0b2e4bbdcff53274072f5415291df049d5664586eb0d39562b7fdbd4c3026368fa67377a8312e54c9326eca733cc7183813fd418b6ed65c3bf2fd5990ddd64dd0869632b842de428a60ec234d36fc23422c284bd5ce4d9c60d51755acd0aea367264dbf0f12ed4aa0cfea12c6275bb859ac93438ed1755196dd52b7b13efe07dd39114124ba1590fe889092773e138f5f5f262f99395bb58c5f79cb1f7b74599d5e642a6a922328f218d0ba945a6c99deda9d991b987138f03dc6e1bfaed94efab4f3a6ac0cecd2060cfc75a8c3d9a6aadc9b55d159b7bba5db2e9fa1dc1da5d4265df9cebc20e577dae8a6c2bb92acf67476686b6faf4f9bee683115e41e799c8d9c04bd49edf8ea98041d8f4e7e945f6fdcdd5d1bce9282c414bbd73b1d310299cc7c3c6fb31ec923302fbb06f17ab84daec0ca53ad83e6a6aeb7ef2ffb651e3b5a3110afab80178c6ac9d9fe9e3ecd154433a8633635759d6e99263301d6773ff88f7a944f80de78fffd5f61f1b30518dbcaf5bc57eec0286ec31496a1cc04d87c3315678adfd3989bcce62446fa487d1e18d741b798a7e1dd0c91cf96dfd6e847884dd1129eb488cae09972e0dc0a2c751d0aa12203ef8cf6d8078e7f3ddb06d7af818d0f6e2cf54358e10e1288a3ca1120a636006a52392d3108765bc0ff60888a4a207ef0814679c90ef3b20bf25388a335a0b3da29b928a14ac7e1ba3f90fbddcb60c2ea4fb7160684d10e6b67acb7018c67a81aa9a00f82132c3e4f6eeb8aa91e885d57cf688d650c3949e274b4eac1f77d87784cab5cb2ee6c3e2ad4447defee0ee32847a0afa3a4ab8a49b20eb24161a07cc96b83e535d0781e977d1341f475650a8d39124b70d6bfe68ce16a69c3a7c8fb48ae21fccbbd04ea596c7d653c9c61ae45d4b2ca000b4d1f1cdc1123848325ab51d7035104313deb0913749648994b6b4530e61ff566d1abe68a376b4ff97cb47c9e61194bf0db1111bef9420ba5c077ed1ee99730f686618e3e4b83323940caa663606e560296107308eaa58d38f8a34e6759480e71f9d48f534411735bcab6b9c1f290587b5f89e4da308f89d8669270b6aa3c3dab377c78adb7628238847eec8ef21f09c8fde4bd2b642cd20f704df4aa617a922534dbf19d7d1b87d9d466a12305b25c321318133da2e7312d7092b1f4b52158ebeceec771fb3af213e0ad66a12f26798f773e714a1cbb65c37cbc9fe2e9b7ec54eb91b691d89d33164742e1175df01d658fd28dea581d11a16d7bfc0a62e496c45074a337786eac509b92067254e68ed81d51c24d1a86ae412991bdb1274f602abe42fb4d3d9c8e3884116761937ca494ca24087dfc5fd3411ed312e3574d01121ef1a478f09cb49cd828c7d4fd30d2d10f4f65b4f0fbf7156764fcc0cb4107c1c1ad21d1fa6c4c54a4987de64e3e3bad68a40ac9e0748937aade87c0921149777784ef778ee468afc3d272c724b832d13db4da3e5951dd053a578fe3112676d9c305ff5c4e7af39d8718965ea12b31b366733a747bdff83404433f9c226185538193038c1faf5dde71949279beeecbc2f72474b60af930a6155cda60b89057eca5adefa6273f54c35767099b0ee0474040c4cd6a73b94bd37b996c0a789f1fd4c7e205ad6b00a6958a7c18e6d160192b33ddf2612163c9ac3d06c4c91f252dbcc97bcb4f27ca961d76611ad5e17617bb1cbe99ca4e56cbd75a2de32f50fe9e766615d1378d300677437901d777ef817be3c40b1bda182007cd374d3ca212c606ef4af3c0a1a0b9fffea5229667f44072aef146175aa0a741b9ff93ef89d64a549c146fcfa6f51d95d5f569606a0f214b3eb89c27958d718827bc0d862e8196e9947b930def29a78ef00282b1a15d07e6aac42477a22e9c4f742dded3a947e35ee9d9d2b5be1f05d7090467d2a3f2af255febe47e3c1cc503b5aa3854e6dd00879e85db0db2b5c950bee18235bd02c3043c88b4f8130473e13231a9d522a81a4413e19b52ce639e8bc6fe933bdc8b35d191a2fd48641ca7dcfa70c0212d9fdc168e281230972aedb2709395af89f2ebcad34fd103f342598b56c1479aae2195d75253f8ee40e3d2b0e7688b542e3c81e621653cc7b23fe5e5df4a263c7a2e9b31a078dde1167a68fdefbe6a95a35ee9f36e6589fefc2493ee5b33b54254e045ed73e31320d78d4fb79d7a5bfeb2651b03d786385cd57b900fcddb7807cee0a8efff3a131c92e02f4375dfaba5cbfed258b157815407e697cd5929a073b38e0fab68b976a0f92bc34a49f7655d780776c00acbc0b5b3c4be1fb6fbf72edc55c4503d83cd333bd8a85cabd8d0a9ebc03bd575ec3eeabc07a719f6005092b45c2072f12165c4717c83cc18760c654ac4d80c55f7b2c708982aec1785ab087519304a2b229de11ad53320e888815e81d786ac728d8376c427ca38cfa3d14df6422234c9e18bcc9887488765671b798a379120ae640229b1eb46195a4aeb644dd5e33f9f35058a7ae8305478989964dee63a4d3ff22c5d9c210e8f1c53626c4d35718c2c05a1c03ea54750a910f9b3e96a9874b8428e0d2775bfecae4872f7598933929df0aef65a3d89291e56909b8a093be7a93d2659fe9542271e264037c24f9d6ae3ace8ec3a6cf1d507242f8c465946cdd5dc6e72f903080ed10d034cbc9aef547bf553d25eff1aa53584e2c4d07a827d6ee17dd8e6ba47c34899fcde5f08f4c4a4f87f93d06e34a7d4e0ca4abba263b3d8ac510f2ad8519a94a45dade8b62e893737ce74a7d65517a0ca5e1c21ec6644859fd3fa2f98b992f6e786006f5baaee483b7b1114dd0b8f3d06d37c9357828bcaa9094c118ae651821103d215680689f8ff2856fa84a17aea90319c04c56a6fd39b9aa6674e05e65d337b13284a54759230758ae0d82aa7dd89e2f0f0d069ff81a8665d5ff83cb6ed35d4c4956c5509b75678f733aa5127d50670ffe483a1d7f7b25f76a557141b25567fb7e0799a1ffc2b9a8d37fb8402c41309e29f8739d5158b38e1d7e4d3a38a03a768bb73c7c2417883b2d290e5fb5d9d8c5289118bd82936afe3f09c83b5ba6c6bad3fbf463dc91fefb58da2ce961e4052ea88996c6a71a4395dca8b0568ba9f8af96a99c80158c5f8c38977623b375d364d5c32c096aa22d625a792d9499c0d7ec6252e5413cbfeeaefde407e077c790d452cde7cecad487055bb4fd3116f1a39d18b8ed8a85531f88c1b2f84d1ab56c4a28485dc7f0f0803aefc7bcc3a34066f56ed3f60e0ad7e4cca03feb8c0817c70b48e7217e92aefc3fd6dd6da1dc70a09e183a037f61d6ea705259ac2d5e5f3296520ae421660d0b9ccacbf4b5db3bf1f61f771a1234667882b649144b1ddecfb0ddada00a36f5b658dc00d0e3907073c9c620c6bea078cee0799a4a6915f559fbf0ee6c2ce0ded1370a66f2dc54d5dea3976829233ac141020488756a16293c6d26b9de8063d1cd1deaa514924244310f35cb319697164c95679aeb6fd0878638950cccb773250b5b369efe2e96493934798c4d4a98656dddabdc8691849c6a7951b0534282a3ab3219814b27c450cdc46ba4219a9dd7566cf403a8e24a609cbdebb9bc6280c50ece70e675f16f92f077ff98a3ac15488be988a3c91b844daaaaa450a8746a7d6ca71256c010613ec9dd638c74c57f4c0748e489d00729a7e05f6633e9c99476010e426f5d84e13587341a2cef31b32f661221a180c656038925d6a2e8ad41fdde11cf3732a0bc88aa030c02d330c842b3053db7366a402fc8e14469a281de528394c6a6ee55ac99de15aa3558d6d005e174b17f3649fcd49d66e0efdd5a130aa0de1e7d832249bc8ee100af8f3fe02ba754a8c58676fa4005875c08948292146d19d521cace9949d1c213a2952082957b091b3bfe606c8df102f174665b69353b3daff808c31ce9de9bdd3f85f39709adbbe16b630b084ade36fcbda13b8093f00033743d3aa1ed4f377fde01f865d12899c6f23dbb0102c9805ba045b6d157d874bd5146632d62045684bfc3ee154cf28a981fdb3ee583e12da49ac89e89dbac7bcbc71ff045dbbed0713fb803f5cda19ee0733be2871326462ee12d83c236b526d46761ff6f8d64a6162859f56a753314c064fe8921d5acd8d7ddef4a3bb871effa09a7e84c97e0d99d79879be5dd1918c1d4195107f37e099307219a14fac2778defcc7e7123b09bc4146fc7a56e9e93e6ad8186fd92f9518ba190537087b6d41a2d0a94def0691cc5b654c499ad80b4ec09db6e328317819c149385cd397b027bf5177b241444b76eea6de5cf0b2a3b03b7d0e2aaa17ee58f5c02ad33b3f9f14c7aa334941503555d549c63735eceb40708ed720032f8319072d960459da04314d6e65c7f891452f67495ed042328e59152b41c8891d7b395459a94fa8e70fa5b2d0f63ccd9d5c684c270e72110cfb645a554517341342793a6abf10b8c339fd729fce73ceea4e3c9c1307cd4467d89c123480d90cb2ea96beb56bcbd72446a46b0b06204292ad4cdc14cb12af72b1e3619e94d4d1fcf0662cb1553efb20eec4cbc2bc954a462bcce1ebba6c0f5423196ce0dd519fea6d20b57361dc7d0bec292e5d56fecb9f70bf2698120268715857e2b1c07acfcbd21f25aca118568df7763714306ccb0ab7d3dc9f9d125baf765cb0da8fa945dd07be6edd633ca1bbde7491df02edcd6c7dbdf97fc167475fae9c97902902cbec5293665ff81b9f31d1e851f1998e2887673816873106be0624b34a4b3dfba42559005b95b5ddb5441a180d2821b49133885de362e4c4fe5b2e2b13547ff75c7af0f18511e6c244866414b31a64128bccf01dbfdd44fa59b924d083898dc6d966bf7353b390091c26da1b7d6efae86ec73c4a4a75f7deff72dbd5e907177582de7bc3e07cd38289c95cfd9b55317e43158b0d4e330ac3d9de37df63d333181c843f61b0f7365a4fcd8494d3c4f83c54ad8f399de67389ab5133dd17ba54123e368a25fe8697f66ba6176dbf783acfbc15853f128c04d29d4d249215d4bb9490d172c4ad3476b5c6d39c03584fcfd8dd285371acaa386a084707f3346a9f4a50e4f1421b8391881e275d6eb416df105570ffe96fa39a10e6239436d47d4ed71a1bd6fdf3281c8ce7d4a3505a6fa7fae888273edfc2a30b65f882af0fd7644fca678e7d3a0395bfdcb2909a11a0ee0cdf6371aae12efaa7c894c2160ad0790e95a49bacfa4c97aea275e449c540b9b3e222db938c8ce81883058d38715a4aaa17e46a4cc146d1e1b0062dee162c983e74ae5309799ee37301f5c47d98cef8ebf1cab4685ea9ee23172165bb382935238802cbb99f1dc09f1533c893197a38b0697de1ba70805ec953d063637f1dae4faabfea3f1dbac1c503547d1548ec82ba5cc4594a84392ef74b199b7c29dbb69d5fbdc892e89958b178c0a8804d1bc706704428863432adfbbf5ba2504b537a2cd68a5c868d9f9c75e3ae93a0866d66eeb7fc4425b565b4791fb84cd0a1a718fcd7479a3d054d0575f1ca31efb90671f9ff331b6f3dc6b760b6ff1b4fda5ca0d9c3514f9b85675d89703d5ae9f6ffa99c8b444ce08b4406259b35a919c7186b65441b92c9ec6376fa4bc20148baaaee913853efca80df0c8862963ce0d560d914c6681ea176b42af87907b827e7a5fe03dfe16e91f2ae522f44ed7619e923eaa6ebbc9157a43c8c8eea82e496661ba83d999470403a310070295fad4a206395367e08a268dffda1345ddf30f71d90042571775be596c35c233d8bf14eab4c96ee892265261c5316ba20314f4e0938b4df8ad491db6cc9734f09abec3a52dcc0cac7184deb9e0408d9c7beed4dc06032d6bb4cd7081a2fd729c9883eee76628b044adc82fdfea943d88cfad9e315740caeb3cc2cd4684abe58a632937809324c93bf4c86e9a17c3ff8805c6b1d584ad6ddcc8de01ffff51817bb3d80cf26210a3816a8af610c93d9fa2df317516519a684589c3ad685aff73236496496df54adca476659529d64c07ba5d7804b6da2bc940db0d9cf68b616df54a8d71e201529a9f02919ed2af4ec8130541f3e87743afd6e252fd54acc894a9bcf6c11866e5189ae3ed0090d97256c3dff7781a09cb27f1dcd2d0d4f0c838e7961a572413fdef09428da38581407db8746b701484378c36c71cbda24bacc58d440075a9c7010701911baa58a1ddf09163f805c24f7432b822302be66f996f2c35399197b2416ec828e738396680e78f85bbb0d373d3a838178254569f98e0e6e80750075ff08e80440ef6c80c95d9d1a534c30aa000740a8edb9492c3de985e37fb0b297ee206937ce021028d282f2609bcd44fd7e60e61d23679b5d5a6eb7aacae9e1506192517aa5dc1b0271b2e64929a11bb76b6403b148297c99b533c660b8843d565b9c162e9f2555ea5a3b2d0d01ad9a04b6334baa6fbfc8486ae982b31d0678f4e8d9d9294735c18ccdc2ad369c1924f67c4035e4ae1a55a0fdc14e5009297a3322d2c161576227968cb93f7f00b6915ba9577959a569c5988774f964208b54df3ddcc4a0ed9ae21350b9fb4e29d2bf3a085967b75beb0f5c4f70ea4bda5fe96f5fae6e02e2ed81fe7717bb54bf65484b6101c5c1f4b60cd51e047b466e18c37519deac091b5fda4bf95aca04ad67f4fb1273939104ea5b77a8bf9c017cd0573e965b4c88a033cbce606168fb1a82203dda6eb0b8e3ad9b6f04f3e7ffc33c569f699fc096084b1bf52a1d6f7effce69ca51939b13109e6181c432fe46c0aaa18a726ccab796261bfaf1c3bd7f04e4181c27d5d60e3de22e27268cdc625d952b538316c9ee97f969ac335636365b88caa92916ca7e910bc3292d83f041584d3ce8236a77ba0e95b824ae6d133ec2e09469334e8bc8efad3c85b89eb0507ebedd48f0a3d08a071c3e1391ad456a06772da4324b2da859b58fd393dcf96d226546c1ae2f673ecc30e7eb4bf96711bb75dd5c668eb24d162441e571a066cf87fd19c95a29d7fb50dfe2c6ad75d9adf4f22a4c3c861dfdb8fec9ae83fdc7667910f0f15cbfff2a4916461ddafc5139e56edd64704ea5fdc62fe480360b80ba0fdfd3e822e99fb0ea90f95662b02fc264ab90ef3664a975aeedaabed6d27bb5c14a989b78c79898aa26b78b08a464632c446bb309b4153bbe0a3c4c4d868751e39a0e1528c487928a059a2174985befb67529bc410c8eb6d8a881916be9deaf3515c4b9237ce931a88b882a2e0e6c59e673b7473a7c3e845d359a62b80e3c64d62a5e9440df95ac51b4fc52d8c940937a948d5558451e5c71ca9405cdc0788adf8554df99f62804d52aab4c4464f06e4198b4371d74adc3f893d5c024ade9b17cdc3082432f2349ab869608deb395952690beaec8c962d9af4f048a9db120862467b963895eda22efb98a028b1ae06cdc756857258fa09badcc2604a33de98f7bd8662e0848ba37bce98761fc3b04397673c1a07668ca13bab958a3fbbf71d70c49f15c7a4ca8990bfcdb8dfe1cebfb2310d3f3060caca27f560fbdd4c9bc7aeaac61a59896687be7b22888a3210dfc57d108de65d5065e33669d980fdc7f47fa25077f57f8d5091f87dc98f8bde928019e4765c5b37b8224cd628c44b54283f4a0dfc46367bb6e9135ce900210b692b3101f7c41ec8295c080e60ad22a0dde4f92637b1f9f12b6830025bfd407ff4a9e0bad4cc3b49c2de61d538e8159c074bcf29d89e6e44569487d3bc5edbe84a564c78bb39526468b2e40d12595ae9955e7557fbfda62cf87f1fbf9a8d9d1178047457ee1df8390aa8645b7eb6c27a90b4305b8eca127b813d5898e6df523b73a02da079c3efbd0107931609957301d8eb7786be2fdd96cfba3f500b4fa48bf05954e39558d5408556bd9996f3ae884efd98a43cb32d8a3a159bcc2400a064907427edee762d25a00434bfad8e5013190f1781f948fbaa4fba8ef84573631014c6e4e0f10348095bb50e5430e84e88dee64d1573412a8d938408b013bf4bab371fe425a4bfd05bd953a416320b4f06140d7a9dc512a61c76f1c39a7b605d6a62cfbc6e1b612f153a6f54da76a6a994d674c1ec2a888d1fd48c3024225a5ce740e31312b27f740b5841df55251bd18287cf9bfc5bfc069b13a6a3e0a3c644feed5b9335efd49a7785e27ea45cb365c992821706b9ed535247fa1de067cb2497bc0230666ddf15023ab531ba393a98d4c948df9dbc04ce2d0fec37530a6c43c2d23d0f7394e040d8de499026d66763de498954c6a0494b0b4a01f0521171d7ae6936733a3200f165ed66f69c2470113264bf399e9b5a15bc7826e8b7aeacf367b583c5c0ccdc223e968ff5dc3574e388e6032a1ac16702b7849e9a549bc4c97270420737da074b663b05a469b274cabadae4601845a1ece255ebdd3e1c394e9f5f8330d1e95defb53398f1ffc5f367c8ee77ecea38974dac3bbabb5585b32754546201af1f6da31127d32a7cdc23ba449f2d210381fa4e23509447d826bff52e73377b6499ddf8c2809761a02387f6798eec78563452755cb98cf748e44350fa6ad356f422efb1749a23cef87579c77e5c85b3acc41e91a5268eb99c0db9d3d3b3bf7071cc6f02a377e17d21cc24301d2e975df414295962847905864cb6e4994ede7fb6e5c78fc2d438c65cfc976c3e088f998715069628d756f72ef13f53651e6d976e80e62685931d43374c8df4715c0f5566f32b857200a4f709e9368d3bac70592cec9e240831b26a5c107130eda9d9c58b6aa0e95acfc36e73b84dc601e9af15dde6d44f81ca365b89854be588746315295754fc30b0de52b3b370c3bbd00a9d0cf636d1effef24bca6b0a153c137b4d3fcec2fe71da16a99a61e3c283442dd0a17d7549fbaa23fd6731ed409ea082a9c34fdd488dbceaed35e969f924bb7e4a761252c86212c29693ca3f3f06b62b1217dc9b27cb2c60929f2448e86475622dfdf76ac1224b8f368a520ba94fab3429606265983952fcb90f5530e86109507a495ec0fd8d4d649965f9998efaf53dd9be02b92f1571a28fc43d1ae231fb90b02b82636759e96ba57d8c50121c57c4a659444749f86d26b6bf4879c2953aaf02ff2f58a5302387733c4dc03ad663fc55603b4991d8f9c88e95c3b16202f8920b6e58112266dd09075107a576c2b1a07e1b0a7b42c5e477766ce764d0879a397d9e4ef65057d94822aa48a615d612bd2ff1f27805a3fa8430dc65daab11111e047f134402ef7bf4c38c4912145aab8c5942163a850c097f55d7528d5be0c8afa50f129aa1792f72ac4ecef7a017f19640410e6f17bad9497188c09766c66812532e81ed2ec53a0290de4fcf256bea2b56343cd5e3f164418724149bda6f87ac86a749ceae7c4367df6e03f98491891d9c80ebc0de3d432eb09e6eb65e10ff08c8a215c37f7a4962b90eb6ffee38add45efe798561170258aa0bb99ba6134a54ca85e17778f98dcd85b847c7e3832ab35c1ecd5fb511c25e7d01a4d0643728406c14ab36c239cdd264c4091bcd6b56a61f3c5ed3d8c039f77913d1a26062d8c325c0ebe6cd77636b1970c3440d5f97df8b370cdea22ed6d9297a4aa6a07e0eb6aab96f591dc12b7585ab861a7b90d643bf1603dbce16e4934d116a5382e71b285108ddf74c0258cbdaa88532afcd5fb7c4a4d66ec40501592156d807e1975e091132a8643a15e40e9ddaf30247afe914d85594da1057b194e0843b7e216900b1c40dce07f7a655b5995246ca33f35461a0476ac077ad25f9364998e837c89a75c2238344f77b0023242783ec5a5a5b9977d7ac0ee51130ec90bd21ab97f6f34986ad59f730cc10cf3178755b20e58f45fec8c9fd0678cf75f18127d2238c100073f20bee91e50bc2b071ea127119302ebd22a3690522f8814288409d42b907b0fbc92561069e1979e8f617d3270f63e51d8a2c2481adb8bb547e060b381ca831583cde0d6b32b2b3d83e393a018b5677014aeb0b39142639911f581720e88ef4f9dc74e7f7aeeb983aa027788ce4741c6a42fee0196d98bda4a201ac4a266afd4969245d7c5eb259c40962eeb47f29aa5339146bb4c5ffcde8f2e8f3cf72600c8352eaa71b6c4496f67bfe381bcd5910329e92aafb96d4c1aa92b972b0ce2bf44580ed40a66d6ee94cd885f60f167f1d141b19801d3dc1b38b067aec6ea83497bef2d5edc885c7f47425a6886847b39288795f87173f39e3c64a4953b879086d69ede271d449f027918f1530b0ecdcdce5b1447875151fbc299acc8d994d13b1f55d034c7ebfcc21f328a8bcdfb2f7e309e6b60f65fdafb7d76220c517639f3aaa895fe76044ccb6cc75a85491ddd0f187aea5cf04bdb228dac36106d0d7d9a54589f85f34e6fcf888e9bda78ee91650791534fede8c64be06d001ce3092c44d47740035e28d65ca0982783fb0be56c5586075b50e9e0ff13360005eed4f09bbd93ccb542ee69e65934875e662ac5d1cfeede4119b4cf0f6e4f20a6c755b066c24447a3caa4f73752e4d56cc89075d9f81c75da53a05a6e6f51e6f869aa92685d18439181f93a1049f56d9fbbebcc1d8a92c2d085197190eeeae9e68bb82dba7134191c33bdf8888c48f5d1aa5ddb2671778423a0f888581b3cf42642300727363d6493537737c8d56952a59cab155481e2f9ca4bb4196ede3f3ebc445e65083de3d808ab83cca4360786abe2a5c3b285f4d04e8f856fffa805d503537f92f65f5919f5d77fde4abb76b86c1d69365b0eb8803ff6a21bae6e119f44b54bb8e4b1837b2237fb710bfc9282d4345305140135c7e006fae1d7ecfd9bbdd4cab99ea1166c0a513f4b4be47a63afbe2801be6ee9de137b0370e02057a9afcba404a94371b2281c1837c9722a647c324fcffd32947a5047b8e0a565c06e1b270c824c6f5baf914b11fd83b53aa6690df86243ccaa89c88f158d72cd6df75a86a322b30f4b07381552dbd4f16dcfd8140c6c1a8175976e13ef286376b46d642557ec24e85a5a2536c33891a4fe1c85a394bfd8c735630719a022e1f89d6ceb21f7c6ef230ce71349da992f122332ac19a94b47600a63334dfded1e67cf81231dd09a1353d6bf7fdae310f847a9406e946b48656ecbf2372d9998ac27919bc7598552b9537edc1cf73acaddbb2892659d5c2e244510d4c8ae1ff09529be4096ec225a727096ea7303df79aab0ed25aec8d5c4e6d963604e492ecf5ccf33eb4b095c22f0bba57d33a57c38c1ec57492acf1e84426277a02c1d901014cf621170f1e537145786e40487e1bbd00d98a2f99f12e8fb53e02fd9715e6603964fadb47fc5005c2b2281c74aac908f7a0a7e26ad8b47b7d2ca0bb728c29614668a8b7ae62c33723a8963b0f8e0cdf4fce4099d17f7bbfa067f20211c3a9bbf728e08b328a1f5762aba29b0a18e63fd427ff9a633c205650a7940076738f2efaab55b97eeba6f11b5e036fcf4e5ae25ee2fc6790a51962406abaa0daae6b17589888aa8670c0f2916d0b4b34404dbcd69b8ab64fc2427167d3c6547708bc95a99a5c80e708c6e17b7d152d3d05a7bba118607838974fc53c226b749fa0e15ce93d11159b95c501a11574b8c913e0438ee8ef8f928f2b68310ce25a53c91942eb8121ef5ffd7234ef6bfa6ccdb5aa8158035a454487c6e5a298d94ef532fc4bf7886166758f3cd805db8cb6aa9289189de43ffbc6df2e2c36afff6990786425b2081fa0bbbd7e41156682b7e15800bdc23ef03bf26a116f0851dfac8646794a559c2ce5481df8c1967569cb2aa987908252a9fadfe9364b9b381b8a6d278871b9a2bd330edc0d8862a979dab06a84bef60fb3a386d4130cc4cd1bd4ef382dac41c168b83ae1168af5bd3d85b2e0a87621bf946e2ead89f9d68197c2507f86c40596c299c424ebbfa28804c13019debd9123db91a34627c6f5c15412406dbb54742465857c24e00c85918166ca0d4c9f44a5005c5a74ce8736615a01cf4edaad677569bbb3ec4b6224ad58c514a87ea6a241c73772cafed370697f1f96a072ceab2da508a4fa86b6ad6bd35fdf61d37170a30153f7dad4ef0ccfea7d207be86ae44fdec8cbd0dc4ac0ecba419e828fa7461b96c6a9e255833aebf59161840553ea05f1cafad4e57c953d90fd5cbfb1b8e9e79fa106cb1dc535dcd66aff6baa7d94d92548ffaaf60bcda4b2ed3920c2ec4b9eccd48866156c2f0e81624d2b8a5a6f5d1a2d9847534ae090446802e8cf290a9081138055d76546cf964188777d5df869f31047a7eb996eb54884c704c0aa8206cd4e7c0e251b0c623e2ff558d064181cca699fa333d400b7f988c5992a38226f04679e1aae80607de00604a4c084e7adf9cb023fd78308ce4e4357e6c84bf8b27b0c572111ce4841d2ae0b4fb33507c1d8434ad00e7321d0db50fad47c8e5ffe5611a578dd8280f0ee323e74ba6bb34f8660a515e6c9f24b7e4155d9a4909e46b0b82ae5ff58341b311e1c2ad88c864abb60898419d5e89eac55a2a6c2c7dcd63ec1f88147f8140219fcac593323b2bdff741cc6d8e274ac0f073567002b80e2d4382751a682806948ca7c95c380a64ec3eb5818b2609879a7f1307f6a5fdcf5d203eff8d176e7970aa3fe10d12541a54e0890debb59684b196364668e49bd523b51cf18035e83f8062201266994ae41f7527616c2b9b0ae09d0e51d7e5ec77fa8c1d074206721b960e6ce14899c7d4756fabcc8e30daea167964c55038518e3796bd452008a5fabc7ac48e86caed64ef8b93a703f2fd55663d22d464ce559c497ed2d5ef969fb2e5665a50c01f8a0dc13fb3bed2b48cc267882f3d574ad712ac887c048609ab727bd33b6114615a85c4b3d1f47b7041316cb18d16ab5825317e8fd44db8e30eae9b300d60da056715740030c5798ddddfcd6d5acd664739a1e50812fab7d952162e091c71b548b8368894e0f03fa6a58a32a6ebcf8637c2ece156e9df80bcb953a3327055f2b4721abf79472b5aad81ed14bd6fd45ecb04f96dcc7d2dae5b7be88b4d19d33075a09058ce882460ba0b32736929dc10ad5d25a165e505d49bcc5fa16f2b2ac13073d91f593fed9c1fa7b2e7adc7c17366f7fef5fb8396d0787720ff44456929ee98ae099fc135c8fddab068fabad543afe0f0b887af8521caf17a950f6a228731acb529c77b3ca92ec648c70fbc46d297f392d319884a7e36c5b5ddd28861889928fcbee3d944ad5aafafd73db4e4cf02e59aa289f8a610d2b8e31430eb9c6c2d3ec60745bedaa8d5a6d0e1bf491538f94a0c9ac3ba63788cafae128c57765c0718621d0dbcb05237ab4fe4c3c5cadc2f20759ae87f2250ead5a81fe7f3644e32031214a6f5f66d15e2b17a5fc1f1849d84d74021877bd6836de3132767c9cb0b8be1d506e7295d0d40be45675579060c1c46e8ba3e764b74d70d7f44257f10b1f7e4fa49876fd391d5fdbf9fa2ddcd69ab35a86a40f74b92dfc7e958dd4e234d6aef35d30ee74de7352583e8efadb51554f7802a3e2ee00fcf61ff991be755edca3a1431129a0920a9ba699af34da288b5782b1094277c5c74984b0dc88be50c32cb8fc95d886450736a10ec1f5012c8126fdad36714df7f76e9a9ae29c76d79d19dc223c4480086d8f23aadf8464b3988c71bfee4c161712128cf208dee5b302d68feed48181a1608089748498ef1130f6c3abe335b09277760372e12845c6e24b3b1213e49efd6ada5a5d3609933c5d521a8c70958589b096a3eedd32b421c2b2967da44160dd17726190d0631990bfe76f51270076aafcaf99bd1898e2e9870aaf91a4ccf6fd510490fa66d7c1d69c7cdd1dcba0a4b0087c10887af8d73e2979989a3101feb0d4ce6b07ee215376d04e9e4bb76c122129575a960859cea8aa1699cc9e01b8c1a51b5adc4d9cfe0542aaa19e2ce025594fb0b69451bb2c8721426f9bf891b0c39d55574ec3d5fe9a2cd803f038606f7f23e7f19a5eb0d9572b625e636a7540e97e06489dab5af1956e9791295a33a4e0c2172b3937139d910680498df802522512cd184d704d8dfa0f191888bf9e457bf0714ca656f1c92c08c08a5bc3ec4d488231dda03e4cd8a7d3f3253a638c8f3737bbec8cbbc1e02936b17c7c3193fb735cd7f4312125fcfc5d2c3d8f333929859f59c9c8bbd78a447b74fe1d86b14db21ab38f05be70ce588dd551ff666fda06497ffd581db96e04dbc2b863e6c3fc489ac8ff9fad8f67a7bc1ae8d7d48f065d99e189e49e97c6c94c976714253f5ef8b10a9c6274fedae96ee84fd22888d8341ed91b346722df65da6c0d478a854d94ce4624351e44b6443d70f31351afa5b68372b391e5e69e864411719721b1bea49bc812ec8d6d943834e17db27e8b0de4407ad795e52e486277189c5530d70b6cdb819cdacf104de42ec83d727edf89aa072fc4e3cef26410eec2c83cd5be56b8729df099f1331b63ba72794efa7e8bce28852e79d6881ef3a015a90bb25e593f1c23eabf2b11164eeb467b688d2a129ffe1f75c4ee5324f9f0af9dfc36930242585374976e781d6ebfdf1971fd197b0d9715a16765ba8017b68a4d6b040d949a86645a62ee33f56d1b23b893fc1446f7d7e8f27a7f53d9c28d777f5326e6dfc6cb971b06b3580a296bdb59948464230074509f69cb08a4eef3385980300423e9c4acae41d959dccafbc472831ce265208025e09bf30521418471267c6324e2cdf0733f36ed4ff305f3b499e4939d2f31fa506fcde57521c13d8c8ec5b81ad16587b8d19f05aef146b9e41b3e03c74312f0652d26d739e08773dd84c5500bf1645956a54bb6feda434547bcd89e0c0538f1f2cd50536c89788cac5ff616918f390484531627a3924d1838a4798da55f812db02dcaa830e907f66afd3f53c76571735ac6510e00dafc78821d80581eee46dfe17d0d3ba0bb3947c4ce01c029c11bf6c4ffccdf296511614adc8048278aba22c3f8de7a355ba505f69c0e98461075e515bb9086bd8ee28d4e9e3955d512c429430c832bd952354fee86af1e8eec522d87c5437ba9315450752ad72f6f598a743b61b6230008b7d1e23f08ee06bca68907091d685d5696f59fef81edd290e042dc652c21ad248210c437f11ffee1bc29605b0a764dc3f18d61471c1f5defed146bff44f5545b9de347e41c73ceb135f923d3c825e707f8c341bbb9a71e98a8f52bafee5618918a1a475d32e5e8474655f7891cfd0e14a40ee300daf05078b08e0be1c6db4bffbc7e35240a2b8ff629d65f18d0c30c042a2821c99b509f8fec1d958d7b501c14745f444e2b044b7922bef3603f62df537a104e312f9ab1ea0708b556b3dad98d7126f2bee750f7274266d6ed4fc122c387e9fd18c074d8a4e1b332349b06179a21e2165cc35e2b3cd4a58fa7736ebac7799d64d9ef9c5788defbab912b915c235473bb97296f54a479d7480468db1cd77abba710f4aaa217391bb11a1ed4f68db2347a6d1f41f216a4516dfec849dcb4e66306c6dc334a9bfbb6e1194c39085869ce47e9285296d2f081c2ad7920faf70b58e10c4607fa62c9d2c332e8d2a7651d6485ed04bd2d4d97f0138574104769db3f0f061859e70aa3834980dc7b26df6773532c0f84c63965a634450c819e430a068ab68cd2fc607e9973fe3b21dbda40b5787e17927b333df239b6be33f2198280e6cb18b78c39675ae9db35fa317a96bec67f35f8e910f186f377171060ae2ba7688e98d7198cffd2f93402c7eac0af857263e34a02e6a79cb57ae2e46ddd53c1b0e8abe1552032895ba05427e3bd754df91a84465bb364cab4bdf701491e8dcc39c115f90e7b698499f92610a59093cec5f1a5ed6e5de9de86cb76d6cca0c0914370bdd1024132b368b987142db9843c66d96d52a3cdced4642136ff5b801d3cdfb715dce5ed674e53c51229c6545ef12c10feeea8b07fb684047e29483997f900dd44374446a469be01aa64c8594d6fcd248b048e6125c4cace71835557ddb9058e3edfbf6aa00951a3f75945a7d456b0399185c44d03557ce0df716cd132c01b1cbc3e512271690714b75b0b0dcb1b5d17c57bfc01fb7010858e780a80fa0dc9c5b7323bd308af956ab197497e3d16d5b5004f4abbf518bf046d7554e63cda73420108bbdc286ed761c1364328889784713e934fd2f411932aa327225758966329c2e0016568196d010d17d2ba0eeec59b52dd10a926af9d42edb3f9c2d8b7572332f3ea35f4703bdd0886efeb49bf4944b816e417d03de4b94377ac3986657be0c4fba7b6887831f8d1285d1a600a2136b2e0234c55ddaf3931746459d7f406af5ddf08175dc16ab614097b3d1e5a280b35bb1127ee5c0ba3ab82d3392b398d45f0a4ffb4a8d299be7ce18bb004c6cdbe01c7fa41ab75b66168c11fa1c23be07a4e76aa586754ffa8ca810f67a0e69a2342c18b70dd618c8e5286d31d43afccb78fff6069420a8b4134a182c45ec6d077aef1db4f8d9bc555c26af58f483d6cf63623fe9ca507f39838e032c54d5e05d210fca4e2b8e43b35d0b4ad1584f46d917f3b2108e1a513e5358db1b3a4ba8cb2d5a78fa5253b4ce942fd6000229a40c6126943681e6fab8549f4997c9dfd4d052d8c6b1aeaf2eb553713b0df5dc5fedaef4b1b8398763ef119512d11c2c1abc16714ad710180c1b5133f9929a17908d3f8c64271586dc38fef04caed3866da216e835de7a17adee933703dab194cf3a6ee897c4a205498d5986c906ed5c7e0b42816cd65bda719f784e43fa820c179d20d7ec51d715ad62371f74bca512a1cc3c17e8265f77163e7b4c2f210a18b60af51f1f95fe0969c22ea177e537a18fa2508fdaca05cfaeac6799b41412eba83355a24108e3df1c7b717da3cf0b43722a6a797a9d022e974eb9fef9e3131963f89e385cf93f8408117b7ff1e60eedd3ffc910ee8c0dec11dc2850995b617aaf578f72522189d6c88ca49be497a0dda903cb0decdd295ade6b47ad3d6bc4478ff77e0c63c3f235d99284203519da71d36beec3b1239f963b1011aebb0200799e933a56229a027b1c291b478b6b687e2379644572dd822f503c25aaaa6cfb5a64a397d4d17284e19ec43fb96756a8ceef233c2052cf7c3d02cb811909abce9b66c6db59cc6bd15a7c44c7b134aabc8635f9420b952872ad93a2c3f822e03aeaa41b8251e7e79a80b3370d17e68f62f2dfee55a8ad72d000a626d49f7bc8695cbf52cc5c84165dbc489de3f4cbb1be53bf899168d3a8533d8e6f2ad362315426f120ccd183394215b50cec59cad077423d2b04eecfd1390ac9766d80a8ec7ac2db48e8bc2d728b5b1c088fd8d61fa5b216bbc1ebebcefa55d9f6a419d3b46405939c1aca702c85299fa467a1f1477d85baa0c292910ae97e7b5c339726c1b66e8b23b16c14e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>眼</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E7%9C%BC/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0837302962e8acd8632b072350944908662482707bf03c4f4871c680bee803b4">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7ac088f10226f5125607fe60c002264e53b3b3000ecf4dc6f328f938821c76ad1b9ad76edb99494ce9c972b8d3dbfdb4c22a4656d48551d10d778d560aa273de9d3bba7e12736d2973ea2c4e5a8bd2102a39abe60cf30ea4eadf6e2d581c6e0e258f3aff13bf82f0a532c7566c6c6e1a357483a171e20df6faecb6cf1b2fb194de12605057c767aa72be9f1bbce887cced2fa8e89f7d2e90fbf418c64204ab329e11ca72525424754ef062fa02e096a261492d81af31721ad415b2013cfcb149857de905652f8b617a99781836728986a128a9a5675f230976341ffc85612556b9bc362e8cb7434c7d56a901a40d1fb6c27d8fb17e384f2971aff1ec2f10f8ac6d2e35c67f48d987af36277a5b81ad2f334f2e091b5cce89fd93e33403948c078e9029fa5449a0b151b1f77ba3496b3898bcad8dacdbea11452fb8528dfa64ee68c1ab5fd1fb12c794793d76afe8fc7131eb3e9fa92e4294100efc527f00ffb679cfb8354e6779b55cdfa346bc25eaf417bda5e92e46467d033f988d0ba09749e82de4fb53243c814008d951d8d3724bc00571aaa916aa0de7320e577196f77fd25eadacc2bd6f780c25548473328fecae40dbc4a99878b2c7e4030ad6eeb1ff530f05b3f73990ff2580e0474d7bcdf0baf08c7dd89bc7d89cdc139ab8a984f5272f647b0ab8643a41f21db3114c746177093925301310ac174d3245245a24eef19f8eaef46899ffdfe6aab7342fa9ec6bb162a31218a2ef6979fe609a15da68ad063f125b3be2269e153d94f8f5a12167ef2ef73bf19b8dc6598fe9b263d9af44f8c4a9eb6d1638dd058b20e715cc42aa2536e9553c4477ad6d74a66a17f7ebe633af044e502f5f16d18de4ea7fabb4f27c18eb48352b0f8201637b57873c3f3cd79ae6076c52fa9b7ba8f7babca7c02bb7b29d6a7084be8802e3444f917679509c848ef99f92c59af042ec0e78ecd043c5db75afb471c2bc4fb1b21fc939baa8b4cdd66a1abe25b4f8d44e09197e786f8350effba4cc31f032fa1180d475d3beb980552fc4840eb4f0135c4f3735a5171b4b21b91f6a282702e07f5c501731ee8c243064b33f4ab2e784260cabd36e476d3d8142bd173a2821823770fea8850ad8aac49894131a89c83535b75bdc333ad93a7beea438b9a1518699ad24da4256effc45b171f3eca7e93aabc4f87bc74d7676558b645a9b4c8959f2ab32c0b1819a6b974829d6dd239231cd5bdc5368f9ce9302061e7f7c91843e265987cee1db14414ea42dc28ab077dad7d09048cfe8e3822a8f3c0cafdf1fffebc7d55fb4fdc8ac777be9a225f61031b232cff4ef889cbbfebbe1a1446c2f47c0b0168019e9cb4ba4168f19ef3dfb18b721ef6be3183bf612ea8acb9e9ad9786b8b5e5ddec344ffa50f8a007e88be052e728ee0167578b006fc846fb4d5efb2877ca9af0aa77ffc05286e1d01f439d87b5dae44991971c5fd70183629ce727129d7a248113422051088dfdc60c7ed6267df0aeb44e20d5dd9f7a26237dcf4b34dd22b74a9542985f34a6ca64dcf0cae6db5b7cb607e439241710f67fa5f3badcd749620784760867aeea5a3defa1de5b2df0d4a016c1f8352d0b2b766167d5eb9d2a51985fd609e702cea25d71499fc847b11b9720395c4af1ba013ba8edf71d4813b403ad4a224c6032ee1049755ea137c4aec54d10dee29aca9d4a9b6db3cfef2153ffa961ee6bac6783ee378c96227196abc1a4ceb7e5176dae474e0a0938d55cfebdac51cff138ef63dbe1bef426ae3d4adf2735332b8beba3c3b0699084e7c2b81d36a257b2eb4cb6c8a29fbdb6bda7b7f3d4c9c28a9db05c62a151605a8994c0477afe13a4bfd8f971211a17e4890559415f94ed1f50864ecf7ed16b81e9dff792f9a98426eb9de96ea33486b1f7bac48ebbc50ddbca0ea252ebdda6455a89bab952c4f4e3fec1d1bf19edacfa066339d06d7bdf9b6b87b70f45aef9d08dca724ee68751e96c44d0dc1330af84a264f4854bad33344c123194579c142e30e5d9503638ebeab80f5892fa0a189aee3309083fc5d1979c54481a0a4c8de4541ccdaa777058099f6e3b5d4537f62293941469031493dc5ec3e30d093502005bf1182a3d91b3baf896df0b52d0cc4b8569d2ffd94983394ae9ae13ee9e6df11e7339cee82e11a5f19ff2ba286222b917bc5be87db12f32827e394dcd4a74a6c5e0e15de3cc781094040f601da73018e7c7e98193b2e79a3ec76034cbe722df390e29a9e60157cbe20a4673953d9a45026334128fc99d69ff53ecdbd5ab2419030e7522a8d7067691e8c4ee7a662b16734dfeffc50682c97d52f064591a6a0c08e997fac2b2cac04f30cbdcc63eb6cc36458bef11e465cec90b0cc1a07474c1d7a19c77a1f9671d8a612ef6f77aba455b74bb8b6f5fb7d56f7648e0117356f471d6d727f4abd8ba414813536553aa8454ab75d87b5f38bbebe7da2df40f4ce99417dd7235c212da860a7d3359c9859e7297d9b94e82e1bef2631f5c6f8b9de4813657d76ae57a9aacf99fa4d6dd787e7c1ed49289fef242418326680e78e43f665a1ecd850a94183ac56cdbe24d19d91115c9ea8545d2bb598520f10c1e6fc82eaec568c10f3dd65516ef7a990620989ed109eaa4231cf021c0c8d64208122a50d0d39c645cce4d52778992ff9a9b5c786e3cb4628c589f63aaa216f085f404063ea62842b6805e8e28d41d5eb39b0063b3455d704aedad40c5fe5834013f1941a9b843bac70ad4c66469aa77d4a359fb3d9b963d288183f0457f5dbce5f5ac7d7f37416cb5abd88f35e9164a2d5f668d94c6807611c9529f289853e46c56c63d94b58b046f0cebd6f32e60ee9f610c7c3cb5099c05843324630e0a68669bc850f9ce57f891463fa9c8bd4e26fb5abaacdc02c3987f680287d9fe57f2ab194fa3f14a4b73c5c5e2a74c8042d73187ecdca10250c9d8d3054e7da024ae03ddb1b04857b1018c3898b8675ed50c9dd67dbcccfce1e4f6cb397a79a0f10dddaa8e4cd03b7e135c4f30ec44a50571f3e756ebe1af1d9b166f902d6ae65d03e0d13206b382fd8e350407dad371ae03e5ebd04ece58885d369366fa0e91753b01e4e09dda5cb73bfe7758b709475ea851da79e873614b09e212e05170a5d5b42924163742002a1c6093c953d9a753537f17bf837e7adca496bc4bf8f488387565fd56bd50c21f71aae6e2e121ac4a6578b35e98df6884272ae451ce0c3ee8166ac523da12af4415c2bc4f341b1c610cd4563ea75dd266a3be789259270753f4d2ac9f447b9c00ea3da18c9c9859e5d144a0435a07b368cd4fe7bd0c511238988d18f9e982b3cacd7edc3ce1f40292c90ce78e6aad972d6e23ba9576f702dc4c7ea5c3fbbc7ef545bc86b9f57649e72c09b83d34d8b03cbf9c38e7932b8682f19d49b5c7927137fc9981f3223e4d3c46921fa3b2ea3013db82711d741e63d1e8c0a0cefff0deffdc0fb97442af4db48137a89a7dd5153b0f99474d96c07aab0e0eb902b564816c633c2728a46a49f81f2127c9344384e43457d087b690a785fd0b4e6f98bad1dc55678cc42e52240adbdad92e67f20e90ef89147accecde7305fab41a7c4e2b77e48686aea16ca13104aa711f6f52eeec63d9dd717244281f0a43ea4ac4cadd59b5c4c888c8e8c15c62b19109eb28e9da3ee9a00a82aa19e9dccff35d31de6105929199d119111c3b5d38afeaf5252e364b473f57e47ab90012d22de6af88f1d730bc44a02d401321239810a7d79f248a856566265704b25e45c838567ceeef60d69ba8b50f8d37e8868aad8d40882247b8ea2724e8d3e1c2f08f000b2bd7ce62001db4c299dad1dfc0445e6c36ae1f69df266ea93d8aaa63ee19aafce5197bb5d0b1ac1271a9a47c00304c455f78344c822dcd7416fad1450c95e0249b26c548ea0017a9789eb00919ef648cd20caf726ce31c3ef6d0c7179da94f821df05b480bee5d3a17db4ba1c026844583de933d972868f00e437b996c8727cbd9a311e09cac63e4dfcd928a0686c0a4a9072426a1f83fd6aab184fb1b391a6f9d7fc646f6965e94b563c85ea1316fcdcc578d4dcd3092331fa9427825c2642bf054bdf4b1a5211233e02dc337877fd95df2d106cd03fb5d7038c15044fe98335f132d10f5bff3ea90ef759063608a36cbd1f37309634fc7fa7c6a9f46999d58216b0c943ce496151443efb2932ca6fe98f670a19ae1ef914ca981ebcf5c2de95ff3d6c447c6c0d887f0e9f6ec7ab55aeb84bce339d593cedd23862eb313bd74aa3e040a35d99492e1c150e88e3ef36e60c6f3f870663013fd9822b4c389bd41f85e843412f5630948531589241d660221179f50359d67fc8bf988a8950a9e641b23537b690fb5b220d60f685e219edd946053185679bfef5d162a850413cda13ec3f37aaf21c74183b4c67ae195c31be16d171a000a415b9b2b983be960737c3dfad41e944e9dac9bae3666440f96af11e2a657f2ae57bc0ba437964090741e84c5dbc763bea57ae5352d05a5e62cdb4aab95ee8a5f8f1b24269ba45708ea4c2ca85f800bed9e59fdad6add71f860d7fc950936ceb634649d2912af07effaffa4ea9deeb943f079593f87086832086b8785a14c21bfcc33f054e2acaa2c2eacce9fa5ae59d6803c1294b7ac0ff05ba328a7567bfaca9ffc99fb8cd8edd1a3f2afe165e0d4428b35f26647e53e7db8286f2c4c2868daed3672637fe6f5481a335de781159b7af5a948de0720b00cfe134cb2fbf7e648dcb9ca7627898191943159dddc41fb8b000b366d1bd001c9f03b2e133c2a57f9d8e10610923852f64a11207efd45d811457cf7d74fdf2ef8073728c1dbe771e19968da448451881ac994450414f3c5c462088358b7d68f968a0124ecfcce128cb53b2d733596945c68115ab91ea3b8ea1ac7e9494129a96d106acc93527baf8df66da5e3bafe302e3aa161c1901982ff4d9bb50c4618273ee323c9f6c170e9806193b345337dda1bf3cd3aa743241ee631e7d0805bd433903eee5ce85290a4b253ebcfc44149c6b75af96189513ef5b7ff19f482cc1da117c1daf65953c698127296e3088168d5f5ca69c8741de9d967ea21a92d7a948b1efe7537e92e8c25f569610cde88d82dbfa4a1dc508159e4cea9360b7b46d14c0f02ec1d262cc40f355df1e46717c79b45cd263709b682e68200106d77c374d59865e1b0c784759893d2ea8382ea8e7f71a69b0182f2ed29d93da6789ae0002711245feace8e365c8685a02a94413c6b4414885daba6029503b1732f40458c991a73ebd482ec65d3ad9f7243e2de5e58ca645e247b94f7bfdc8cae6509d6013ba16e660bf52f1d5cfb6ce68bfe20f8e49ada119c69c30ea53fdcbdfddc7f0ca8417cb478585a7e2bf6a442e0c0a93265b1e4d6ce60364bf72e7e483431ba3b0b46f2fcefd7b4898e96482b259936c1ba8ea5cd49bd409ca6c7cc1cb7fa4288b296696fd9d07ab496ac100d00294b9343c95f7dbe550a5ab5309b6b8440d0cde108ac68fe0560b415829a13c1674596c17037e0e4b57bc1e9ba59c28d2f3bb55c6bcf7dde1597c1e91598851797110995e73730fa8d9ec46fd5a2a822b66e5089a9bb3cc298a64e13bacbeb8675195ec2a0e4cfa66e8654877bea11e228980186a0b173584afd2f05046e00fa6d3ad2d70dbc0ad383020e7964b63ffd0187fb65a1f820aacd8e6e3f16027aca74cd1563bfa71b0a8b4fbb15b2283209e3e208e55ff09b8db52933060df2e1840af8eaf91d57b9b10f9f4e5542048c5b7028f1f4a5f3108b47ca644e7f9741c7ef644ff1aa276a577c113ce83cb1478f06e2abe719a3b15e6a4101c6f92ada7288402e6e76dd86cbd7e9a2ced38679655f5f280b56970cb98951332bfe01a2830379c4202fac26edd3f9e1ee3e1a26b185135556275818796b80923cb6e94db82e445b403677816a162f3237e69a8b35f696951d1dba7d4b3a4875f250557743f2cfb8c6918d7d6c7e11fa18be4c967e8cda80b87de663adb5b3e72ed7c7c3d6cdc6feba4adaf81c32e6a078db53e37dba50a44a6ce386f15f41424cf314f9358fccd3d5517c3d43ba6462708aa7d4f751aa16c6c85248c6deb8936f7376d91292d9c3f9247aef42d879c214dd4a3580e63e1b8823d8c394923f006169f681cf6f517a7e16234cb0f80f106ba6284840a281b7ff6f4852282cf3557b3292a948656f86cca72aecd8df019fd850a5509a84a58a1ea5b57436c18445b6ad2317341c5a537fbd40b4e1289dc0df5f1a3821f7113cfcea7e1c4936fd0dd1f0011c1ee1f47585c3174f978b1cb97bc17fbd4f9443aadea4772fd27ed9137c7aadb43417ce0e96edcd78028d04030e05867d04d3f643dd54cf76047d29e6b48e2b6b26e7e434e2b303945de1e2539b927fa70e7a749d226ecf0b27b7757e2fa202813438f43b439088e6095d63a514de9051d67576853dddca7322e671296eaee58e2cf9b4aa90028132fac047701a49b7e05e06cfee959b70edee04acf669b84ae5ef55720afb2fbb19f3c801cb4ca8c9b1b209dc6b880b19bdfaf5365a385c9fdcc31571338709499721b70917f5d5bf82c056749792c9ff2f703f633de0c69ac35242244406dfea2e83f233e44d270a4c5ce8efade90d72708e5e435ce604e04bc17e5dda8a66b75677ac90e21d7b56439bb4b943fd9f2970cb9fd50a2446d558abac8c46e38626b29e32d6743ddef766db250bd80a954917efe22222bc4beffc378b6f7d515ef67986f573f7b2a75b4f7d172ad2422caed4a870e6f1040248d7c61f3486143c76d398a5fe4d304b888ac5ecc35d69447ac85a8a15381d05d9decd13293a4e261cf7a2be9e92ae9678f19acf28ea3783fdad8c90784167ac929924b067bad0bafff97f90f8f97c8cfcdd2f9d06566b4a20adbea3f29f3e70bc59087ae69957d5c693a0288c671cf3ad2c6370ba836e9748b9971aa14cf806e0a2dafa31738008dbf8f0ef28ffbaebafcdeed5e122bd5379bd04092b1656c464ebf4d366da3fe2e3b684d33c7e6011dae867c81f7ccda897d2ccefb0e9964f302e404177bb393a6f78e1a14c8096166a401c7448bcc71aed99a916683c0e4616bf71fc5a13fa2ec37e7595d8defc52ea4a9c82fecdbf4dc156b278bedc544a50e852555a732e17c556f58ed9d3813cf5f0280b3e11a701611990061735d73e78f870aee3240407c25a75df6efa3c569607ac5e8073b21cbd8bd6a7c5e4e207b53de97c6f7b41ed38bc2ef059fdf7cb9d6981da54e0b3d66701851ec2693b0968a4549043d7d4748bccd3c30a81c1f67199a244df85cbc78db18bc2c1e845a058d7afb238e432560cb605e3c7df507ef4457c1622edf42becb70743329148bebf2a77086f91b7baae83533f618ce6c64ad4437929f25bee501fd6d57eda2963e75064366032ed370bf68ec50da9375643d788eb3fa8fca826a1f7bceca15ceb19277d8fc67c898fc9ce6ce90d9535ead52ef92a5dd56b157be4d9b5edfe6775f5ee870803b53213246a4e8d9cd5e92374506ba9a01e44aa5037a4d9e97f291dca0d1c798be4f54a0a34953a93942ac513bb8cd1d5d61b615a2b036a0138faea5e9ce5ec3f3dbb7923edcdcabfe711f1cf7864280c2ca7da27c32f36146d868a370a38a42ca34fd17025d23c64badd48764e33ff30767ffce44e0478afac42367ae126a9a5dd1db635dc6ff2b9fdef90d611ca9e1d9a5256eceb4db80d0620da4fb3c174047c9f1afc3551fe7437a74c90b620b44013f484062f52870d02ae6c279f8d0393fed67dc2d3771ca4938d0448bc73ac122d1390f1d0a29f5e763e60e6ac2bb3cb4a464705784154225c94c03f48ef34134f1a8f85a72fa02e2d9d026cfa2edcf4fc86da71b9a4c1769a2b1ea9727b6b44e05b3af8c2c5b7fde74c34ceb4517329a98daa2201a7982bd2ac57dc1455aafd09aedf12ab64c25ef21ddd2d37a1f587d71654098166fe4699d2c854c55bc2e50cb25a922fc8ba40f681c8bde216bbe20bedcda9dc8e7527ef07e4cee505df6204d5310f3ea8e3122f1a454de28779807b876d533c4aa190cdd91e8d40c49a1b387b3f703a44c74572b1fc3ca568ab794f26c50659b215b5b98a9dbe2e63fd78696f7341f4d6a2caa8ac359dd7dab7a3f36d2d19295e45591511ee9829701337475e983fe6f07926f2f3137c9189643b5170513c2b2c3e1c759fa0afa79b66396bd63927854beb37959e97ab1cd6fd5d6d0fce7074bb336b41482320de84316d1645af116a3bb4f011f32f26a1ad55b3424efd984c3581c792fd67557eb6e043535601e65155b34b32261d5f493e8acf9f578b29e9c0a44f2f6f8319ee9b024a535ba92d4013fe0402e908d0c3beb7fe6926e188fd908bcca8136573154dc989c4ab09a40042e7b530603618770905f4591dfb85616eac84ee670acbaf150427f5653373e697f888f96fb1099f3d59744f07d606bea593caac4142ea1ca602d1f4c09483d8431440fa221758c3ee365408404f65ed2cc1fcba9674f533ba1d54b22ac1aa98d9d0c6855707179e78ab11cd75befe17572838afca8333ea5f74d0671f9966c1544bf559b35afce15d716235ae4a68e6b5efcbf9f0a9f3a83879e4c2aed04eed11647d02bff6efb6b36a7737cbd760e0eeb2ce32699f54c8a4b463c6ac3f901b4e679a24f680e6335e2efc4cf0271bc06d6e702cb2857c5dbb6a858c091d7c5a1b34f1ecf613ac5f99a54d8f22153f7ea26b3fbac91266095eae5fe053b5e11f29ca2dbe8ff2e6d8a51bbb14170524691cc7f203ff298d5fa78365bd0967def566e2ab31bfa8e60c710ceec6b2c9c6dda4ab24ee362e4118dfc21b6d651e96720407d4333214761f49110c7dea90efc8f0655e858eb4f79883d40d3d328861b8991da6ec53fd8e690ad483ea1d89680681be3f047015cc8967f4abfd3e5f1cbbe3127074285d29ae294b28daf9b04d30c13f07f43c28954ac0fd468e8a00ce00b87327d0c265522073a5391445289020dff544331919f03fabe21c0b0d9e07fd487a2d7cc6d2c943fbd6761c62e86db6bf2a14d6bd906a4be6cc8d38fead5e8ababbb80b647fda6a401b44603d72e7422c265c1938bbb9be8992f6d28072de300452bb1fd174969b2683fb0e28452f40a4adf5a40c477a1606c7ae11b67b8ddf0173c749869cebcc8ce6998270af0cdbd2d637c69da8b4436796f6b2b4a3cc5c0b8fbbbda2a329141311b00e688856c1c29a00c7247d971e426a48e43f6cf47eb3ee16c24f8a506867adfdba28ee07c583941a27d899c102f3a138756026ebc3a5f7437e8dee8e5e9548115f288f27b41e10a90dd9c524cafc739e1c099b3518f3aa1ec1926c290ac18ca85aefee6d54d118fd0daf634305cfea1177a86fccabcc3649b6ef8691cb0ce61cddfc5ca20d0fd9f76f20223f0edf516114fbc2f86f3e54b4250202b26ba1f2414807a7254a36bd402677016599eab89248194316c8cd302a98bb9d2ab2c40a541b96e84cbd70d45d1bf0397c5203c2b2c97e04d2b21d58342d7983771d529042b02c4bcbf6f0d4f197c7a34f1677654aa3c9b3d10f6865def471d54f248762c85cac0345ee182bd56cd3b68ce5efb8aedcd2fa6d1510f04aa4f02dcdd80a37f39d562b09b94831b9a65e12c9625bb60131869e474c6d409b686814c742d788a021338f2ee107fa7862f358ae9ae0acd48857eb57fd4ae966ab324fecdf3dd323b37b45c045607d77535f7d86df0c8da1759fe221088b004159e87de77172a539dc6bfb7dec3b007ce11d74d80bed5bb1ec8bb637a3b5b10048b9a768d1c0fd1ec831a3ddad0bde4539360b7aeb6d9535ffc51d0ec4607d0d0720a0e35ef08e7f427c1b8de179f7d86548c5218ef00df201e4a7fb1ab365ab14262ce2c76184d959ae9ff4ca5fb1b93fc7b11236c50f0196ebe5c74d882b3915998c50d71071af13d7a6d9870ca274c723be44698dfe6168017b0e47d72202a3ca96fb5d9f7f63a16d649f07a74b18c27d00d16db4449545d5e5a30ab9423465e8a61030aa6c284d4d4af6705925ed560f7fde77c17ae66bc5311ae80f4f1be889238b016e54fa7591792a4c9df763e27b214a0a626f338ea9f8403a90274c3b194bb94a9fdfe1b7cb7b8411cd62a99811481a06a94d86be1503876e2dd8bad6efc0745bd11b89368e4048a2c51b1b386d706346659b0b754b5b4cdf7c8549a6f91d96654a480da3c3966da47059233c1a965a39224a97fbb1cc9ea86f21a861c4b1bc133298892cf3b48edbc5f404a428dc99c3d81b68cb4c945fd5e23a2b9795801f2ea78f9217b37711cbc3f18045073bfa693101f6f4130bd7c8fbe00598d9bda2c15920be12298ad7ac6292fef6a82ae796e686147b8e21fb578c24ab88df6820a7e96e7615904bc4efa4f5f3949220311df47988e93b6720b1fb5bf29a5fc98c5f2f3ad5707c40cabb1ce85da840667408c5400b10a851d218608fc5b4a30a64ad593c31f2d058d89cd11a1d76451de70da86f988fcf0b718ab7b5436a1e751da741b7a9f1274ec53f6020a2e117ba9cbe95d10b6e43800d7d32f93cba422c00aab063761cbbbd567810b5bcdbd116145bd1ef191330f1b5277b12c612ea62a24b742ba856f2871888da64c66f24820b63cee75eae7a5fc86243eb68f493fb3f204d4193b224d2b1ca81f94643c0511895ffe88ee3addee36e96b69d8d91b57624499bf67192d2880c8529f8f2cb46784eb0a605fcbdd575677f6ec43cbcb7e2fcfe96f9d9e8e7a5da48a3be090f89e8b0d5d9ac92280e4b6113a8c150f99f8da1d629c047a10a90a53d68dc8122d851634356f50c0826ed7b022c0861298f45a56b5c1615781295da8ccf1c6fa580dc1559a83b748c70ab6d3ac13be40721232d3ed9f3fd3a06407e5ef419f8ab79ba6c9227480869d3b3273f5668b1e1148a9e41ec0f519ce9f7973c5ed2320fff031f54164e979596fb684c8c224d14fc14206a0c01586754e2edacd3a0f1c932aa647f4d710d9de37d8b294c3fd07c2327cf05c6ae2f948c1e94add4440db1c11767b9d9fce27af1841442619c276c085c601f96ec4a67b2bb6a59f08257e0c4ccdd9560654db4ceb49d27d13a7d78653932b35368ca2b18cc530b2e9491f7f962f827c4e5c541b81b1a16a3f845382a46f6bed76bc1a1ae0fb27a7eed8fd547524ee883ae26c56cc752605f95c4fe8139656c4903d7e556e2c801766af60a22e039e021a8271c8aed10df2cb319a3a968037d9cea98cbfd234f0848a0ac6b3d0583da2b37afcf31e366cc9f449cfb8ccd2385675b5ddeb117552f95e7548be01873829721b78030cc4ab1267e9704e78295580a86a3e29c18e07404e39881dd7373d927295c4fec2afb07b1dc915eae1a16218e7cb00753bc9d2c3b84e343e00910d626c7dbaf576946cbab37806038875d9cc4385b16ce28388bf84a3bf46cd673f0b8d0172a1b24b3df615e25983054bb6571f764e2fbd7068363a4c724dcf1965dcd37fc08779bf97da9c948cd8138e6f254ec05adfdbfd523ae10539cbcb8d7fb1ef1d4679e0d347e1b02c5d8b3cecf2f9693e02cb95ab0873832280799a8c84e6994b3cbc45d6c2e88a11727bb7a0f4df56e9e46b35e7d622f5b100bd14316cfc5dcfe1e7d0e83410bccd3ab87fb53be5ed04267707989718d7f683700326a194777407e9ad96721af34c96b2af6cf14306137c0d380597cb6d3b6fec8cbebe21824614aa7e7ac5c6ec99f4917f25cd7f4885e38b74ad0517a53435070f9e86680672b6c906864fb22a0c8c323277c82f36e48de5ae320a051079f3be06ec60605ca3192274968b6f3b6cc3dc79aac0247d5c2f683b7683d5cf0fc483706412292bb705d2940f05217c1cd90ca23a525a86372e7d6a9e39299c574098024feeaeb84933e8013f4489e6f76827688c79fd836f8f46e3506065c0a48356838dfbed4eb31e6f36bee65bc4ff80150e0c7aa80121f5e852464538919a9ce948d5d653dd202ed0b188842b3335d37bdabcc1f169204a19abeba78f4d66ce59ef8bbbda7e7b775937f2679dbaa7cbd5a4fdc8c167de2b591329c7bb8e46d528364f908d8e0b65a0920d6db6be108cbc14fa5273b31cbf7cf28a11a75cb72cc74a12ed467473934f9f26c61b7c38c0f6a95c68e6d70ff6539836c01930b529024172f16e0e477151af90dce534141e86bb402cb2796269174ed1025465e32854f5ea4e0647ab660bbc363049c7feb2b6aa627882bd7f0426ec260f82d67f8f67c0ab33d95b80fc9e57ec8969e80e0ac42883cae0df5e94601de113fa2736a60955b0f88c1f5638b5622e7513e87bda8ef9a234dfb0145e53456183184913da37bd1faddefe74c75e49d0761d63a49993c68ad44d823690dc74bcdc2520edd355d4038ac85264081320a4a727c5ad45ea8ea9c8cff313fa995406e9c31120e4e87db34466e526f665f8b1a87e5ff6e81227bd7f62713ef86547f3267d5b0a39347938457beea7ee419db218570ef5b2564872a2849b1e032fbb6833be117a960de23457e20c1fffd77b4813e4346b8b1d98732d2fb7c5a5c7368cfb564beb5e49f5fd99f12edf9f33cc89b442f7e21f35c2d7ecae86c9e4fa103a4d9433c71f66789879292ff6d9acb8adfa4ddce6ccd1522cc8175f5d48d054cfd0dd634468b7c24bdacff23e3639b826cd85b925963f15a52e5f17e3f4dff2c79c0b82c84ccd00a04c57f6798021d1460fc532d41f58adbc0cf69fde615761bfa5c3369995a46bc703e8c72da394814875e7706f19eabc34c7bf2fb34cbbbec8112e8dce8e752c0d69673c22c931639264493b4e5b624ebb097aecaf5226afa8b32c58ba8d8f9991a3c893913a15d0c870a0bcd1b12562f8cb7570ee3218172bb4880bfff992cb12ac4d83d2fe75257aa37ca6cac6645292a0a44f9f6d9a8cecbfc343bad5e694a365f71da066712d23e2587c6f585c40574567e1daef1b4d2f239964991a77559eff1aea4c4845eab8771e23eb453c276ef712f7c35765613b96e302976b25644a4e48c184084b0870056c0e12fb04560445762334e694c6fb331e4a89dadbe69e3fcf794e58f23e73ac69035220646cdb8a377efc4806006103dae598b2745822570d5e668409985fe80d3a105c500c821d1881e56a8eff30a6ef5101dc3fb819dfdf8ca04a5bedd85af336911be3ad0751cb821bda7881042aba35060cb2c2a72daf7f7265198e7b3af1ef3d1ab915d10eecd250325cc2947711889eff76e9411eae22c49274df394c4b84c31852fcbc55ba52eadf064848351c9e28526cb1d3dcb2086c5676f801b1ec126cd36d7bd8c808f74c71fb65de9f983a7894139bd47182dbfd5e302c748aa229113c29e774ce69cf7882621f8eb83e74cd907d7441a248ff1fdd496cf6fa9e6f41b8512cf3a32282fb9407a8bbec0c4d972f298b6cb4feab1d90d480739311fcbc0a095b02e155c5c46fd9626b6379267c6dbbb66eaa2e3e7c493eb651751378c560029357ddfda3ab64a54025a1b1c3523fd5afa9ccfe5fbe0452f9c57150639c78b5336e992f7637ede40302335e52618b51021eaaab02608ef5791574774f0ede2d474da1884e71f875b67ac798eaf5c9c0a77470446497e1fa640e1174bc997cac473d1357b974e14e8dee1a68944a6c5c9ac165b831cb56d94634f4d4dac1e778408840a2b5a530e19f21afff847650ce84ad4be77d1d3e4b2c670499e27ace8d1192153f4bbf3d48426fdfc9562b182a4b547fafd642e600f40632901fff0052625cff5047f10da82ebf7283cfa621a08a3bfb2f396d3976021d99be346e9fc307dfa349ea9d917cbf33f5c89604ebe3d7c4411e399f9659de2112811346d0fcda0bc49cd847d18fa3ef3d1817e8c495c44304dc5923458ced6bbbb8d834288055f591cb20db0ae229f4b138964e85665ef96592ef4bec520eab5b59912a80b2d48089513cb933313d9f1474474b9d7e6418ef6ffb685a34d833c1fc5b668a3a851a4532b9b789e788848fcfab441683aa2754fc8fb77f3d6f99e5ae23521ba39753ba15c86176faa1c5f83ed820b75cd5b28f54c8062a563c8ca36ba585f0bfb1308a73b1f7d0c797c873c6891bf3c8f58b5f3ccb087372cd517b0020b335287fae3dbaf89870d59cb3510a5fa01448aa58ab71bdcf0b504460b917086bed921c3a7751329397f8d2e9d18b3f31e65b5d5bfc0fb10c6f5384b948a063f2d488bdb664182c776f53cd732ae4f99ab31b466438c4674ed33cffb2ec1b61f4ee3683e5fd791af1326e0e544207888b95fc32023a5a02f23c482cfb82ddf62f26e90d5ecffafa4e1393682d840e3c4272b0204dfb340ea4e64e4cfe74a406097744a53892b515f45e20c8eb29ca9c6147a29f332e6f8c0deacc5556f98ceacd0134d82d394a826ec678affa1583dd5e7921b67baaa10ebb390ebea9991f0249ec0853c50d6351b868953ae2cf51cd5dedd81d774498fa31e6ab8c2a4c5e62fe33e77216b284c474c78e4f13136d6796b9e2dd9ca5f1d3db0639710016b5d3aecec91c749cdbe1314e13b3cc38bf91b4a87f176d253fe4d85f920da7252d10219faa3937b58a49e2b258d3797b3874b3ce87bbfe20e456f6dc84b7f4fc419344f30ccec8d691e259ccfef3443086b90349acdbc0b0c70fb3c7a71bae80e965edbc6dcf96750bfb7389cb210ef1b483f5e79d3aa27e7c81844ea09da9bfb0a081e6f6cde761f096ef5868cc5f63cf64ee1611e9acfadf25bb9ab6c09c130fa6e6b0dcb48ceb2db740a4767e56dad217d24de18ac847d9ba58489faea026fa30e53100cae1d1aa19b6365bf2cdecde092d000efb98220973c1412589cba9f6a4440e2f118d195ab1f0c84d5d2c2ed556831ae0b100c2764ec2ed3045c9191a512106269619bab21afca30f50fe367de406338998b03487965c27af583f7d918629431c52904b4c2efba1d91b28be50fabcfeb2ca8530faa485b5341da0b3b2244ec21e9c417b149f93991e0848ff3fa12c2e3062e09380b9718635ba2764e091d57ace8fb4464b1c980a293211e80c646d6c85e41336f89078c33c7a3a9fbedb0968978c3d756c0aad1afcbf28c7f6536eb1a17d4307c92a70b65618ff783bf123236751c088b879690e4950d4c8cc81e7ff51352eebd909c64987305d62d48924291f26802500e8b1f0cb359aeb2cdcfc0c038ceedbf58e9426711f9f5f19dfc8a38cf443017609a00c913533e85c98e728c348e0c4a49d7cb8d9d8ede2a3df7c1205c49aa8d39d5c793ff6d2aff0d8c67ab63cbf68d76ab96e0ec8b658eef19fd68d6443ce11610432123391e7015c2461081fdd7a6dcc6ea3e25fb8990f438ba8ac96c65d28bfcfed88a5be573feb27d92a4c67b0393359b401c4fb5ba7bcbbc5059165d64bbaff5607e966589f138adacbfc8c05d39221df8f049cd4f19127f1d2751f85d3e3d0e084c73409e0a4807b18aea63ead03c064786462fafd96c3da407b7dec57acb3988dcb7006ffae1cc0013e835a53caba1e764235aa00a5a10356a558cf6fddc4206c55afb3057b72786f5c5e077d2030695640279c61c826d4f5747ed355445da5a7338b18acd6d6e910794978ed6602bfbd010290d6bbf661ff84e973faec0e5f6df5595d6d956834747ec9fa9542dcd211d4190cc2ad7e6d7cfbe4013ab9ef80bfb16d8b1b61186fff9663530d7fafb567a6c0d0a35bcbeda9fdba64a9f93160d436ef455a14ba623b5e192b960e4d924e827fdc6ace2050c7c2e8fb6f7cae015ba225ecfd0daf67258bbe4b7fc86b57a1708d90d58619ba12658f37f59888baef7b487bc59a37e3f7ace474e2e8a45e2b592e3ab7699c676acb089cc0845562496e29145c21822e7b15ab62bf9ab96710f56569c99a5c0d66b8af2bea095ee2f569517f67a5558f74613ec3766c2a3bc61ef945fe29e38f2441f1fe0651e1a0db342f0a345fc5ed5b0a99237210d45bdeea95116e3892af87b2172603fad30ce15fbcdf61b8394f9af7c5d98843018d561932a336a25f7f484cdca2588f59c9f40ad75bcf54ac4de76365423eddba7fe90e2990b11792a1083c58242e0bf4af95988e20b19c594a5b5c8a2f90749bdc4de2854f38acb68d9f3ce5d7fee847f47d2767883ef72ad4956b4f70b2bc217478991a9a6ec153ca03b071e61df21824a30f83bd389b7200817e676f038e3ed719724a8ecc90610ae2ca03870c27f18be77e1f6ad8a061408e4add8f5f6d69086c5e6238ab74951568e49b458c781d7d14479526392369ff9cd822d70032a189bf1758bc43b2ada3dbfc95f6344a42c7448c9b8bf4b747eba9012139cc2a296ed002b4f3feda2221bf1818588639bfeeb130a32a3ae8c4706bea91ff3bd8fb99c61444cfd2c614f8044fd25b1e965a1ff882de9afd08d47b4ce5bf4aa3e87517cb410f9119d6c642d61b50a06bac190a50f74ab2cd3b851f5b91c89df1744a1a4e15551130b092341d1e7c8d59b81e211718a9c9f58c934bdff4f8c591a83b13882677788698feb33ce816a87dec7736f6a1e096f0e888b8d6e173a1616e592711a3175c57095b418be814a242f8e8354c02d8b8fca8a91443491e740763537451a939df7410823f7ba25cfbc138312012a8e7d0d852b1b5886b3213d1ad250f5a612a327cb990de78c39d301bfe5b61e57c310ef8d7b3a4fee31fc475474b284747ef67d8e0a7919688f8b5b9427ca1e6d578e35fb45d0be6cf8688b136264fb7e4113594b1fb8f71de26266f342adb8d7f1b46cda912c74fda2a28bbc3425eef49234ea7fcdd149d046ecc7ec70beab8f53be83ef85ec7c7a73aceac41583132d999419f67c61518a930fd819cdd17a4efccd886fe981c843133829ddbfb540a66cf936a0427e6f6ee27acb3eb2c47376fdce62ea0277794225a2b273f47dcfcbddd30d019d1bca396ff518ff1603adc69d5d4107a498ebce41033f87370a3ae1483e0504cc39bbb6711618e5e7bf0e826f00dd401f5685de1b1203593a08307df4de89f251fb249ee1099a860cba8b0a12889c2b2dd3cb2b076f23c738553e699ff9208b608812ddecab8853f1167e15cbf5ec314235f2070680636ba6fafc20e8dd67a99636c9c0d697286f48946cc47eec2b9fcc52ec2ef3c5a825bcc35be303b5a465b41bd6c0ec565381dbfb5989ec47154f8cad81054f54a85eae7e7ea4ef33843906870a7bf9cf825484c9cbceefbe6d28d5918492a4540e19c50259469de9839e4f1fd694b02a0da637b4bec269218673b205b20467e6ae9425e30d303bd66090f6b2d1124df03e0c487ffd8ca9b115b92f0b048d7201fc4e7aea4f74ba68b231732da651c02dfd24e1b64ec3eb65f5284b2635549c45de531f3846ee34d20cc9b7e5c332851c61259b3f509d5c527a4d4edd356fbd8c7f638cc73b472bf726ad0e5406296dc3d44849f2b393da73809550026baa5c879afa11c5e8819850df4dd23b13858fe1f613071739bd6be55b775a9e9fc6a79fa5e21fbe647029a114b9b49e470088f5cb594f1031b720a8d3383624aa991f603b96d5991075648c8dd5f58e3b12258847c028b5e450496ed110d7673e70d82cad3b0253a911bfbcc372c89797c111c46541bd89da8bf0b9c7783dfe29832b10c6d57e1160d0ba9ac3da2531ee883ffbd565de5373d026c607728563456e3ebec22a4c1238f38ab67bfa62d9484c295c810b14dea48061d8c63a044d49e825e811f35e31183dd152452764d14b9f64e28c458e31c810e8d1b0d867a5396bf3056a2e0376ceed41e66882112351e7847e35c5fa14afa584a6c36ccc797257d511ded27a9404305fc4bfb4048b56f3ce919b9bf11754ccb0f39f47d6a1989369d1cbda03cf715f5d11e76f8fd50fdab5b50bafe1ad4239dc8bd7f205cf1bfc3501cdf758b9effbbc090eb7a1a9aaa649f0cc4cfc9eb8d892cf4749b216ac574467b5828a3c4ff378029231d71d1f801731320f743f2aa523da74269745c73a86db7ad03e74ab27e18e8e88e1ac8c479e1c2085321ad1e8cec1a1e4b48e730180ebd89d11bc528f7fb592979c547976605842841d1e32df683fadbf5f422e1fbdc3955318ef73f04f522967e3c7c9c23a7f02dc443dcd5f4db9ef5ca79a8692f9481d82fc7c2d783605c98e393e5c7a51d5b298c5c455773567d282e8f699e3ecf532f6501ced60ccf5814f5b085854452e2cb6e43452e01f57d413f8287fdf24143f4453906437b6f970f1fd21bc2501a11069d70bbd1b34903f7cc1e2589bf12e87475e1c8e8c5f5401d9930125d26b0e2e8ef49cb243c2d7b8629040d78cffc5b484060748fd6e9182671cd6b24f059691ca0a701d3dc5b36d3256737ca77ec1fd7f8b5fcad0c1f368af302d657413b8f8a58dc1e12cb6a6ed1443d7b963ded1b85fe04c4d94b5d6b5903e9577d120cbc0808d598b88d441416659028183d916d8dcf6e2038080253b79616de6be1fb16952ef9dc0f7481615c34b1523bdd70f6bc674ee79166c18a5bbb7abc639bd25cd2a9a48c27b78de22638d9cfda1a4f540b7caecaf7a964f269296f03a3c57b499092b520f9c29d510fb54d9fcabdfe2ec6af91772a792f4c4c7b3a80e8571044cce678f5fd65c002f4132b89870f068b974993ece82fc306b2da2cb21ec1795928d47dd6142fb5aeb61168c0a2dc4ebbc5871b0b6abb4f810ead939cf6c15cf161772c11f36a9b7d25d4955e33f431b3c0a80b8960cad664dd3a8bfc82267279d7bdee85f8bdab09192d6d6b53381fcbe6ed5777dddf3ec43e57e69d348e71f445079856f04bc20347aa95ffc160420207217a4bc2c762b43c73e7adc3f30383e7758b3f3ac33d87d511d6c6267717c584bac0303678721ea62808c6b5e11b143d4ab2abbb5cfcb8fa7043acfa59706d0079ac08bfd93eeef43f6b16fa46146357ea6fafde0af91c04ba0dac9273fde4425d2ba160850b88089d1e346c12890d8b9e67de5890d731b1665d042622ee98309a55b70f6ec3f555f9db16f2bce439cb113101f217e61e59b497dbc0dfbaca987d476d9f38a4df2c019ae0ee5b22c3d911e4b56d048bb79c757db0c4a6f38fcbbeb18803875342a338ee781e94b334c6a42cebd5d0601ae73a2e36ce27de0a6fdd76299c18deb25a735cc5125e0eb8f801a2312ad0eec2edd4a139a3ebe972513a00e3c341923deac2421954eeaee7881702d8f98cb32832f1e350611dd43cae29484ab726b001a1b3da6b4cc0cd6cf8fdfc1efeabc9ba70f1079f288094f710781212fd355ea22e0f2f61360424817830c2610c4321eedb3a8f4a2c71f0c010ebe0f313e94fea553bd65a38ff4597011ce84d74875a3ddc9d39c4d7d796bc76ecaa7d6f230594d91cbe044623aa73c483c74542669ed97aba5974ee2cc5b39acd23a75dafd511ff824384e279fea23f32cf947b715c8d4ecd8d728a16350e79b7338d6cf07db9bd9e3fee28d464905e99167d695d3b8bd8f05f904f411ec30c8327d959388bcdf4c00fc32c145289ea9c9141fc9c7bb88ae8e3bc1bec862cc07908e55bf8d6979a58421cf26e71555ec21e15420bd271844f7b5880dd0e4c1f20b59adf9354fedce58f6ec9c8146d7e7d7a822e7e1994387d72161793a104883a506d934036c252b3878a6053ae53952d480db0ee7d7d00cfd1e2f09b54299704cd760922c4627dad4fef25237d8d584a93f3e6e1408b882f199550cb3e23700822fd7483598bc69b20df1678e7ad02b95597fc143b39d3fdcbe656699c59a2e744938432a23c8c43271a2f64368aaf6faae4a37f44bbffe730de27df33c1c8c90ce25d2af7915823c4ee3720ac19acd9bc9f3fcd54186aaa8ef2362058ef92828c1d7433b4e896494760365eef9b36a8e5e2691079faacd209274e94defedc94f3f15893778e3345d7aa77efbba390b4a9467f7b74947ec671d07b3fd52f64dfa3e92fda318b21d827c6cdeec1aea57515af947f016b16b0eecd6953e1462c81f4acfc48c5f3c25e8a14ecbdc5c34be6ba6451edb200373efbbbe90d37ba25336f95cb7f60b99a509ca8b9835d14147f9632cb33f08786a052a9dc4262841d83ca078254156be244e80ed4f24c9316ccb0ebc73e7bb02e7cc322eb995d281afefa3fa9a08472454b5e9bfad172febdc2c3c22a76a124f0b787b343ecf7fdcf2891fd259da104ea688f94045d450e0412d75c85cdec6d8417cc4bdb1003bf4ca601bec7cb895e8e1ecd36b0930799fd646a070cc79a7f1cdeaf63ebad7e44f2dd9c2939eee79d3281e94cc8be3986f899ac83f6211cfb847338676ea629da630c345a199248b1b79a6ed6b840b431302ec1fdb4c3411bc915ebf619c5655489aa74d29987e5a76e48de7628dac14f6451634d83c88e0d09cf59accaadc3cb67a3166f6b614aecf5533474faf752c1835d5eb88902d5df7af798df3076e893db4b6e8782ea7d7fda4a63b26973c513e9f2b143bed7ee35b93ffe613b5599364f3cfce0cabd4530c038e7629450c2997278135a2968fd26e27d63a0d680aa5cfb2a44be4f51dbbad1c471d8e60b0bc2a4311eb46377ea75852d814b82ae524efc2bceb3532119be2f4ba6d203309318201874fdd6513600b10702cda9a2291ac381f5dfc852abade9bedce56576ac92687acc69595620d53f8dfe354be3cbf9da1a481747434a20f1ec44407238b4671c91ad3e2e055673677a9dd5e298284f898a9b9d8690b811acab61720ae90777f652a0628ba4d8e83816dc0f0abff36664c006c4d7bbfa525377c37c94ebe81a97ee5fe12513fcaa07090dda497c4859dd5565a6849595bae886da3a541e6f23e5a5f45d03b57b2e7c09252c43fe6e5701ec00eb6273e3d16dbf76f3c59822866777908676f2e83043bbb3e6d3cefec53315f04523af39609fb547940cc9bb7e790746b8d2005aebc7c42421100432297be6189c0f4e617677de9e8997076b0f0cc1a957554543d7fab52142cc268b774620ea7ad4ef9104c9fba7ad9c036e82171bdf110ffebf96e6f6af7507a82ab9f69ef755b4d3a08ecf86cd57d38c025adb4aa2956f1ed6bc65c962a754dd397d1318d582eb041bf4971e468add21fd6aecda46bb84a0db8485301c76470e1ecac673722a484f3b455ea6cacf14ee1ce8928fee781aec35677c57fd16a5b05bdfbb168442aae84c53b4503458ef22e383d9178141b6a78b491b79245d9289cf09f28f2a2b4760ce881c905b4a89469fc9e2c60a3ffdd7cb944d54bcbca423c96933a1df199cec4bfcc8f6f5822af9666e625cc5ca24bc0bdcee6e1e33f711feadb371695a10ed859d6a99344ad3b2c7f81d66c5cbc9f07f4a0c4a82195bb6404744fc3ae37cec6bffd4ce9f0fd83d49bab85f30da0c3e48ad0aa654b573d0acc819e90d099ead2f9a198ff69ab54ae394ff859614a005a8ad6b8852bc73f4c27eca681ed709a4dacd146c1d05acb08c1ad0946ba23295294806dbdcfbaa794d7cb2ed3aec3bf7caccc65c02e6d8feab4cdab3b8ed8d8896d2a22aab6a006a5841b632e876c3ae67ec59a57385b8bd426c6f97e4f558ae2f4767c4d94b06731a09e5cca99b034005f22817e1dac542320b8a82e637b0b6711b69360d8b6e74b7e44adab695e794648b414af40b8a97380c3cd419ed49ca1420e26f7a85c642615f0084291715c383bf74a5c6a5a47f16a23a6b4e4b1f71ea33afee38e29a6c4402b3cf953b9302efd2a1b7333726f4771ee87a72eb5b6e67fb4c9280d8d8e20849ab9bc945eee0c20ac3239e36319b61f792988c932852aca98301bc02cf8f0afcc189fd71cf29a41af64f4e121efcb4e4d868abca09dbffa5dca6cf70f32d05fe29161d2c40a358002532905ff29bc3358963b04e53324daa6ee6e1e50e63af288ea87b3f8d2ccc609fdbd8ccce2baf342ffe61998b70f54c56d9dbbdc02b7dc70994b2cab303d1bb443e5984377b2b51d1adfbe41332fff68dfc49127dbe9b20bd65fdcee45f0ce22d17908b7a60b6586c1c32b247aeb57bcb24cbe745437cdf3b48689d2a5ed6ca79cd387015d116c5b21456adc524fb51d34e401521bcd2d3da0f39142f43e1e9bf69acaa30edd6050afb1c3fe8e8982c786b410931086f90bd14e9ef723fdb0a41a7aa9cff295aeaa5d07f3a33998bf8c542cc60237b031ed86a559b5182bc312d2fba383b44d195064f68eb37c8cc66f54200787a4e7db593cde8b3ece6867bd2cab90449c41d421712a748ef631c3c9dffa08eb4141b521bad47049b551ad7974d627e4dea3ead203ebbec937b72fb238dfd924b42795793429829d89631a065df9d52592f3bd5262b4fa909e5afdaff3626a244a99ec0b3f43b3c5538b7773e28ae02ac265b8bbd0470c060f9e25ddf2a628148cb67a1970d772dfbb640f77a2e6c37d28848465302b30273209a47eb805c685093d43c296aa86198209f4aec2b554ec9972c64eb339c8e82ff7f76a62019165f36c40dcc893df6731a928fb2d788420e19597da9eea2da0ae7c5bb6dad0626112cf7376b9b1f62c87d20c65f9fe124b3e7d610ad3e1e028a90f830bce20356bbf60fe73cdd2ec69a00af64764f89ce0391ccd0f56d5d5533a3e2a63f731e65985a93c9c46b701dc0cb639dfde476fe03cec66d2e3ce4cdf79df446a62bd54f47d15e9153d70dc18df976de15fcab64e1dccb09e6bc8eaf3e8323fca01f3786938c32b823f0aed9d9bcf6185691bd987da13ff6d8787646e3961e0846962d4320</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>誓</title>
    <url>/2025/03/10/%E9%9A%8F%E7%AC%94-%E8%AA%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5fc59a697bc8e7584558cb17931788bf1a8b649bd07d509cf18fa89a08ddb02b">3bb9165ff5e6bbea951b9b42679dea8a10005ea0aa590a3a442cae26bb5f71e7cefd2dbe40612c7c2a8140ffa690a2bd07c3ac8375b4f96a5b65ce7515f96287621085bb53fb723b8067d99d935c66727149bf42f0a38fa896b9def28ed80055718f799b492aa257d0f6e5bdae703ccd7a8379b069ec2ad2262d444242aa8f3b1f483c8783214a6cb29dd4f972f29a6c9f5a3a9bfad2ee055746120f5472b3487c143d3865be01e85bd3b6ece642587853f088c47add2a23f05f3e6395ee8a040de9011ff3649423af88733f3c60a679d90977075a129b3d0b9aa61f84a5f3f347fe19f11c64cfc8c791402c76978e5ee9bdc1d28a431b14d4d942bf654d648035935086610b312f10956ad47425a76bd954b79083e8df490736d2fa1442735ecf5077327716e3771656b2389966a08ea7e86915282dae621b671bae09b11e56a0f405b2d2fbc8621a971cdc8f11d6c0e9c1985b7c362480fa980103d9dcd11f7db793cefddc9cce86be5420102ff4dd7e06b813f64819d04033c32924d886a152f0914b6de9da0364aedeabf7d363809a28b6cf80ab475a23415d561af889d0f03055ba3bbb716cbc6677eddfd2f75e425bf56d6f8992a074a6d524619df63720f926e23d934937d532d046daefa3b0a887f7742c7ee077a68f294dda43eaa0129368eff3b356f4bd2c21d6b7e2a19b5ce5761e3c2497d6664582ab9b2f9bb4dc61834a4e964fa2f6028deb3bf040efd2dff86dad1231c1dbb58904fb4b19036fbd1230510376944f83fadd4a874c5b55b371aa9383caab6b3baabb83d620bbc0c05e365604e4fdf4d50578f8bd2d725fb390246d63beef0d2ad0bc543d2679cb70b24f9bf63cc6295f6febc314fbbecf195848d0c33951dedf4d638f6940231e67d025ec996801026b8185bebe2b2e2db1b7c10868eeb36f82727b593442688788aa70177823dc5e7b52f56ea2cf4bd07ef5c1e802ba3f6503499dd82b1abf435d85ecb251e50c9f13c81853dfddd6570a25d414c40154b8cfac9cf2208e8182ed2147e66e9d516ee523347328c0990a4d11e399c3f863d4ae3cdaa0b38ad0e13723eda5e718d7d4d6b9e0541f15155c240b1e10139e5fe43b471743d3076ab5370d717422d2a1100d9d3e647c4d5d0f331ab671aef726e1181e8aebbfe6addb453a3ae886f10132fb052b8099a2aa0c2ea55046fbbf419c553708e3391ff9787eee0413d807026eea0b13657bff99ba7e08cafc853cde03124440edc6a79b8268355b8da6cfe41ed455164e8067bce800d7dc7d4bdbd545579d1740b0481ec943aa71c2a03072dd7e581d78869ea171be416eb8e9766693a0d37427be7093af29dd525a9e8b419378be10592895b6442b5b15c9f689257d7a09dcf97ef0b3cd4612d9ca5eb45462c5fb79f36b1418e19fcf42bbffebc9ed1572db45faa6237d5419e81c3e86cab04daa3a2e1b83f4e5cc58b28e7d84ca3771ade48c26e0de572644b1a7c3501867df39a1bb86fac4722e1899b89db618b8b3b8584dc0a876ae1f747d7152a8e294e02d04a5d65bf4df3b8220c933961ce5d7df713175f6fc1563400fbf18fcda9799b1824cba25ee07dc8d41d40ebbc6446a458eb82dc128b14c292d316ab321f0b912c8f23d2ca78a9226eb75d994288a157bcf7b1107b49cb489392e36364c47dede550c015a05b1efe95deaa3444e57fbb7d3990de53de27c09cef112abc2d7764488c5e67a277ee36abfc2416f1f3c87c271eafbee13b4bd2e1478b97eb9f7e7206431fb9fe737717932b6e3e6cd186ce0c4f231471808aac33e73d9788453d4ee3a55e900fef843675305b4aa5a4e3489ad5b7477a55c7c6f77507a00791037e8cafeb7c5c176b5acaefc3f333140547cb31e8c9ecbe4bf90ce70d273733b99d5b4961a38f7e6f406641eb6e9cbdd640fed4e82f8d84449b208d298cc1ad05500be74a214e570443d271fb65b80028d6d8e5e5861f12f80a05c534c9faa57875e9876fd3d32a34ea59153842cda61b60256404a2788a9eb1c6d9fcbee8f6b8321d5b856859bb97fb1f629265d9e8144e8d46664892d17ae2ac740cc9d8a8953c3f4d0dc59fae5210b82cd48c50f009afae6cccfe06a9b61b2172ef33f17b524c16f452f229918539d42a54e1c0ecf1ccd01baf38ef5ad3d63a1d0ea55d9b111de870bccd5c8f8927647bea1ea3cce49949c7f856339dc1a394b547875024d2f9a47dd56119460d9620599787347d25b849a2d32d48c5ebe5e89ebeb6a4bf0b94f04e572e7f72518bd59d3230af133d5ad191d9a33ff49a6cb3b721e25377df7022305b96afba67c67495913155804c6b81fe5312fc72eb1fcdf6edf4b59eb2f05c40f0d6bda2b19782ae912d3653e5a8afe2ce24ffa0059c1ec258b594720dd9cccb78759f919a539733b8934b1bacba2d26b81f9f3b7df39aaad5fa304c8c0253ef43d8815faf2ce70188df0259cc46883c2adb4fbccbf7cc63d2d0a31914eed8c921b2834b659d54b87165f2b844b3ecf8b31897fe5960a95084ad7347a70842e1da1935695c64d892517cd9e3d5d63ab26360b9da690abd6a5298bfa0f6ef266831c76a9407c22d78a97a33d4858268993dd3d4398f8e92bc9e7e99c7b86bdcb5ffbf91460635e7dfdfc10fe63b850be464800ffb6cf88e824793ddd34a224dc181fe4222e36d02e61ea47df6b89d0522dfbf2daca6d1fbff21399f7fd48e3a3e4c424196f06a40f21ab9be00110aab1822813972e267d30d99da12030162ecf289f774febd934fdd1d9f54e75eabc70a7e348e04cc2a149d16faf8341ba188d10f7c0c6e78723ab429eabc0e94dae8468c14f010a49fcbe773e932f87784124ed8af6af485d5d431e3dca7edbfacf00b1221ac50905c685460ca643256a7f36b73b013826d0ce81b66d652ffd87a7b20d33ec093b24b6bd1a21dd0b8106fe32ec5d928550c09d29694f8da4c12e6927e263d8ab4df741671e55a4c3d25940fb79c160c45d50e7a9759a9f7c48eeee39d57c89ca75193d3e71a84c2a0a614a8d79fd365329a375163617bf3b5b211b00da7c4eb1c7ad7dc243d67652b19a74416b35149d993ef8e3eee85992666c8289bf4a7a3cdce45860101f7f4ae8cf05fe28ec237ac20be9e4ae7977742b28435a8c2b711ca639a1ba3cc4a011288d7bd649fcbe47bf8e654903063dc6b21b591f96e899c71458b40325eb5e091cac0a6a0286b290960c31fb6a216f929d19747d3093da93a93bcd39ed8b215ebd5915c4835a4a6dee65234093d75ceed7adcefa59a6dca5a32e5a9622f05f54fd57a543e6977022ebe2c692c4cf4177ab5f0fa76939fbbee53f93927992dbbd719cf8850311d20701b0b5bc54cab46697f21b9fd2acdfdb140b1f83ac52a69a82612b70137ce1fcf4385611f187939a360aeb306f78830e654091876b739327667435a55cc7f73670766dd065be844347a1001cd889b47003f3d0c9823c25ea7e132ee3678709fe22058f6b90314fbc554be12a0097fbf7c156e0da565ec792abc44962051ac2ed60658a861ea29738539d84bf6a0b36dab7aaad0b2bfa0ff7d9f8e3fb6723db2ff4e152a6ecd6c140473665ea35c97dc5d01dbc1c083343527d56287689a1dccc2cf447a1b3678c8c89e1c129417995f464c8efd322a2cd5edbac2dc8f8f4d9f86f759a952c82588a380c68006af582bedc1193db71af5c0d7d1f73ed4c0fa46fc17b7830a5fb9a073620a87ef9f7eb1473cdf0df82af77d93bd2d55e20c6ba910e149510dcfb93f7c67d4799a5e1a6e02e7f5abe6f2f509415d14ed0bccf5c6ad0034e7dbc6d5224cca63c5276c8a389e2a45f4e469ad20011af23aee566b761f46ab7b12e4ca63ca19e37d1221e915334eb9681776e311f55cd2317f0c33b5266462d551cc0eaba6e13f98672c583b6fdc073b4cd9f5007e8365933aa6f7b19f4efb7d275cf6c69523196b94689c6616ab5fe0dbb43b56ca92e711929679347e8f3131c011356ead53d5c67db5a1ac50bd5db58700cf1935cfc7059fccbccc2df991e8a18b02687028bc484d9995be5b6777c71753b13e885b2b3a7787fa9dc0c14a6b6771a2b3c2ca80a5fc8ebec4f3d86e36014faddd58315b12f53f5ae83f84cf78a37535c69be43deb8fd82b15e9f9a868b0732b6dbd18a9ca04d36a57f3009035c7291f6b45504445f83828d34c4ab5267c7d63c391d28834601346d9da7450a8085eb83b0bca6e734397161e5fa7147782fbb42b7d33658d3875d08589c8b36f2626bcac17ee9a0b9cfb80a5d068b49c902a44a05e12bb2f05fb182875fb8128a386567ffceda31b1bb4d22550851a873883afbd12a1ec4510be5098b53fa17ca3cc20339cc777935483720a3f14b642a22de841be7a185f6f0513b0b869b2fe188d86f4596b209be33502157b6c822dcbd74710882244860928bb56c9a26a2c47b9675df44add41abf20b8c02782effa58b6ae6db5c2bfee215eb6f8a087a497232aadee89b66605c9690ad00e36919db7fca9431a98796f4c45fd89f4ba40fc980bac3f970e44085c410222a64566f3529f4eac34d1eeb021acd1aad925e1a4a8485991b94ce00e9f210e1df6b7de679c52d0d564a2be23a9cff5aec8da5d57de24e210eae8d4412b55e73496d8bd783a0a705a51cc7dfb0d99344b255672aa38b9c913d8a40019ffc552bf6d24e5480c5132d4d16239fd52e0a87df5bf827c8bbe384bbb5d6df1ab8e7c15dc8ec2110abc45b7112a82d316179935be929600ae14fc60d70213f4e6fffb1604eb4dcf5382994b0eb117bb9c17d183ba59b5802d4612a0a7daebed5dd74995d5c7189127c27524b2e5720c351eedc8fc8740943c0010523f3d64abdf7265d6d782f8a391477ffd8af4adc1633283d61209515d1fce2f1568f7e0c450bf05bb7c4d5cc3cb991cbf3fb30d84141719c440b62661c6b6da158d116d817615237f5d9271e4edc7645d080f4e7d20a8f42fd13c43421d334d1dc6dcf2a2620b89749e500f0dc8bd76bf236f8509ba38303813df9ebe0d90020b211d8a1b06bedd9fb15d6ce4452c1ccd823effc59eab7deb726053b518d04d60ce201557264c3b2323cc096a76b44233711978d7dfd183d0bf8a6c540d86874c88f23327d97e28470e0b993742c86c155d575a3e503b55473096ac99931cde5828b3e2a5802cc5aa36011c5ffafadecd590fa13d894e5a6e1e83de8ff031f289d73272eb4024c485c12afe1052a1502ffb689c2973224d3283ad279e0a8a24d231cb1f0ec5cd9053a8f79fa08c1207cc929d28152b02a5ea787060857eb9d0a4255f245b985bb39857b4d181bd63165cf8ffea1ad32aae7e2c92b6a5b6ba1313c726cbbd1cd88007be2b7c6d99a77c230064f8d3aaf1aa7ec4f5e534108b17bdd2676806a9738be1f9ca49c6aa62e5cc99cdc0036ed15573de5170abdb1e95266ee9c689c7fcd50da95c20a11e5802f80c7ab13d5c78c7fa7833ab278486a30b5fbdb8d69a064e2406b09220dbfcdb5f15b406dac091913f436cd0415d011122b8bce5f0f74c6d97312c22b8f59f99d713ee43f7df35a487a9c5a3f782fbd687568f0cc7989445bbb89bec74db592f49d859f4fc29bbeb9b3d4c775719090c2f62fe4c6de3e81cda54339c398e541a3a04f4d37b1546fccd752c2a432181386abd453e0768a8aa4d59ef911c8665f893c157ae93ac802e75412d6461e03b05639aacb27d137f409f8bb1cc2aa2b73dfb00c7edb209f7bb98e5b17b7ec1f8e32ad9863e5cd31c3ff93499df52119f64d4b0e8a76a92681383c075003bef00190a2b47e7251b1dc87138356baac6fd2da35505edc75eab355d1ad4db27488f7467b6d89b73c308bd903c83c0e76b7780995a73cfb95e88643d2a2db9c57d3d9cf0b93a5a338d07c8b3268887c8b284c955be6a1098fd2a735fb7a751081f45554a4a822907255d6edb87a4b5df30d0649f7b91e2dfb4d42b75e3275cbcf7f167316f559ee481212c52edd5c1cd342461748cea5791ec78aae10265795ca974307ea5db6875c8fbd228acb7f6310b7de00864753a569d1daeee1e39f2a6e1b4a8b11be5f169de5fcf4a56d4685e9a8210a18422ad39a1e27e83394ddd49f56d1e4a954f7b12200e1945112b3abe9b38e31e09322723a17e799af0eb28f77e75684407cf96876ff62743b43e9657cc97d47f3c37a65108986b2adf654077ca3547e0c736e7d523a6224b5be35b6b4e47991471f0ce338aef43ba041763239782bf2e16388abb0ddc747173b319fc5de81090b836e6e05a1f093b5ad2faee550d119ba7194baed8fa2108d0f0ef958e10e422fdb1591d312df5ea95f7e97f612437e27b477220f39598ff629e15e2371628d43b56e7543a4e644e61812b2da63b3290a60aa02d521062ed93e0be6cde773d690fc232a3b618e97d4e03546cdec704ad5af9a08cb648a25fd3687095f3ad40acafe37025de77fc1e622fec783da64df983462bde42f8a5cc51a26013617a8f0d84fb24f88f9226ffe9cf86a588aba329a9cb6c3c881a9196f095b29f445b5f62e4d65f01d444739981acda146a67412b354af2eaa2ebd064797f7753f05ca2df13ad288301cf4aeef5cd51efe1a5f5eb8a79f8718ab45347205bc247c6a058bd7e54aff8e015c0b944d8f139fd1c8b71985d3439b44f69c6694cee86adacb601ba44ac7137c7b6d988643c711dd270622d8786fe148899e51a0dae0bb17e3b71c3525d8e608d14ecccc6cd1fbd3e755b8cec2bb65dab74a2c80a31439c78e5d7b7b7360214c70d58bb0d93f82640d814069c5dc888d0dbb832a52c2e7b3b4988a61c77b6dc9d4ceec91b6b1a09b150e27903404da8ae146cdba9304890d92bdc89d1f5761e453e87c20cc244e276da982642b61434d0d9f37a55ff8134fb56accd543d9f73103b74276633a74a22da8860bf09102a146a76b87ca3c2644aea79cb8b642acb5f4bab917916d850f2b26c4923156c1c0acd0a4318b7223c4434dcf87b8cabfaccaf196ff7f7e7c6961e32b8fe40d0d3b34745a3cc0166a2320d87c48a5ce51a0f7bc0e725d41bf9b39cec23d6a426d0c5755c67228269aa296fcd569937eebd56291ececbecc6103cc61457cdc42c9b36023d5e3637d532b43414632d87fa1ce41153d125418e6d698b67fdd55a74f206a5b4fa4dd5aaccb495354c485545eebb677222255237de44bdb1a85c5e0342e3920bf5691724f72cddf68b52db0b0549c58a691922bcc92d5d373e455b9dd7914de5b81ae096d41e3562627dee1995b4d9de24b94da16c0d13d6587eccbd0dd183eee492bde6a48b2497742d4933f63cd9c48a84efdf66a0a7b03f0c1a132a541152c50d85bc04f5b193fea0d8f5402bc423d56e7136c7872b48890f0612cfbe2a134194696357dfc56a32f58bb4a167119e30a82ab4ae0a87326f86089dea55d3c4acc1dfaee01178c3809abd29bd4091832162ad352290225f26e537d8545521e887fae3514cc682424d8116993a6de4b476076ec49b87e483df29a22cc06f48f966107c416604aa353b018a49e5dbc75010b45ce96bd7eb1c831df3e68855863ef5481bd30837677904273ea0a956c8e3ef900f2de7f47864e0fdbb63a5ddb65adcd5b4a660c4cfa19819a93d35bf80999dfbb72512b325db279e1aa6fa0a442ff3d99c217983994b3a6387d42c91b117c57e198d9f735bb2c1ff378cf7412507a15a016295b88cdc795ad707468f7b8e817eb39ba4fdad52ab2a6e7e39f03d89c858d634880e93f48211735294aa0ebde51de5598ab1f3461392074c1fb7c2231db3779cae1fd77e465d83445f6a3ac36f1a5fdded685ce4d1f32f5110abec053f26d8c78d391e93de22ac219f0dcd8011d3088a4026e75ec193068e8d52f0334df94bd4002d2ac96ca2cd2c8b93b8d0632560c76f9561651fb404c5ed8f99a745db18255403e8d5cdb0bdb647bec6004f9ec379822250bab7bb58c8569ea5793803bc9668cfc0e9357c461e78dfb1fece2394b95e5644a8df5dd8da490e2304005cd2bf0ea050e610a0a302822ce72ddbb9398620f3983e71f7018a37bf0769077933e95dde14e182e637cc13e38bc9d1b657bcadb21c4df1d77f563d867286acef05fc018f5d7c74d940d66118a46bc6722569149d7fb2dda527733583c9d2dd1271b520a5933c32c7b51355e29d221bf70885d7e7bc545124251539c0241b8e9bd22c4431ebc3d0bea6e358bdfbd9d3e93ff348f1062019f4a1bbaa7a7a2def3c3265bdb1356a4e3fd184b1e125bcf793732a422f916ed3a38d10278a2dbc7c9c8eef50b422c56efc74d5be8745252078b1cef06b7edf83561124e3a9301cbcfe99399a27e89cf0727d6eeba228966a9785754ae525d188fdd35f4ab868e9114a45fd1cee7e577f844d3a258585b65f7a437601faee6531223a3b720ef292f5f2c578765cb5c0f8c46678f2139c2bbb980bc94410c61c0cb7faed268dd3f7e64404ee588243f2731fdd54f2b06214a731f8cb8ef2b7111979d66f03e5699b48daa90b086f727a753019d050ee190012acf75af682329cf0ca1618351f6b825ee5c5a9cf369c934bbb6bf20f63a5f8892abe85d3646b99241fe6f481a86c8beb521f819e22ea36dfa351380c3ce25ca8db636198160bf4029f9584ff0f5fe507a58d1b448849ae09f92f8a0585a85e43f8c410a96795f4ae04329f8de6363836428a416146080e1fcae91fc2adff7a7d8af0da326be3520429ae49a721710b5da29f1c5d8a57bfcb322ca38e9f1de6c53e04996e4c2d5ea6858d999f10ecd8fcf29974d9cc1c2d84565c4ff21f2ccdd77b0615d17cc031a058e190d4d49166da182f177fa4c8d07091e143f112e617e1767b37eb81baee66f383db9b0705916177d1c90edab6292b1549d8c65f692837de4b00da8a9df993beb2f1fb39d580aa17571574ba2db45e261cfbc4844c819e4a90a5aacae29adcd6d4a3d8cb6de3e509f001c9490c51704978aadcf9ee18a9a5597753e656941a9300067f7d9a380e08783ec7e44a9b30c5e8d81194a301d11d9a789191f6e626a0ea49dc0d20c435efbbe9712d409813c02ba446c35d70b1afd1af39d9d5c66eca3960037002dc804e890e49e7f48f23956f84147a935b00c1939fa9e112fd2d325c25457099d949c8431d0c20eb52da6df29cd3c95b0d78b40bfa45acb752eea3559f1a3d701ebb0fd9e7501b6101f8055180246e8d59ea9f11577819c65aaf411542ee8715a46e363792b5720e7379b6270d0e93a1174746987495e09c5c9bc2157b8a59f6488cfe002ecab3954ce65a838220afa8f838ba48437ddc66975a823a5e95942aa597ee36499bec8af43f21186708178b242e5bad70c94636ee3ae4003fbbfc82a905866cae9ea1913a158e4efa588f4fc7bf4a0706177fb3540e5eee45b4761ebdf4accc2d977a3bcd2acae16a1c2f917fdb2f193cc1a1272aec18812988b98e77d1a5afab0415c5c0d8d6c4e08d02d244016f70000612d0e48585eb261d38de6050919a75e35168e6c9daeb4b4298195a01bca7ed2462b83b98d802891c64eef7340e250c5979d07d3289e644414019687b1db98bc07c33f584ff591c69a587a4ab08fe6efb11f62421d1d1763d5313bc2e1474ad30ae5220bf64129cafbb76c088b6a2b2be014b1a7c363704d312385d6cc86eec35e0bdc6a9b2cabcc4f66d803419721e8fe010b4c037ffc54508b409381c9586223cfa3fb9bff96303d88eebb0a0384d22ae7ce6bacc923c95425ddce7b9c82465cebc3550aebcabbd394abb9b38bb387a93022f02d82b238ba1a9f59f6a3da8da2d356e78e5e15e4dd82e6cd8e99ae9c51a36dbc358aaf89a21cce1df3d390352a5c8f56b09eeae9281a79e0a7d0524ce2f68b8142f923465fd54368eeafda8d0db117602fb85550c2aa07afeb1bd8608858148dd74ef6dee283da05e5d07f046d32fe58c3b633369c09e89559f37840c5b8a72d527408f691e4e23fba3374ecea970bd3ac90c7e2df86d3f75e43598c9b86b404eec8aa81a26ba14f85ccfb3327fe34efbf96bbe30028a07186d6247910ba8c27f4b3c2299be1456fb5bb03130d4523891133f778eaa52f49813250e39ee1cc13d5b83c80536bf5c9e9832852f54c009d03b8ad4a0dff1b01a7d5754bf200003985e71a75216602ae9661e0f05ebc6cc04cb18326ed4b1070761ded84a374b06f9f2fd9bcdd2f550cec4c187620858d8511a6ef5deb5779b03edf97bbaad62c72701ba848acf4360136cfbe685ba2006bf2a5130e70c8265d75015f695483907193961abe3a1943b20cf739b39ff5e62860e04ea2b62c393d3cc5c43a4b60742ec2727a88782bc7fa0bab8a6a4647cf5189856f7063b05df88b39ba7af7eb620851d1f2ee1318cf45fc6459941077872d6ca8861950c6d2c63cd321448cfeb904f84d990c1b02476d91abb3a09d4d5b11acadab756bb13e4253c1548f06fcec674b5e1f4c832d5e5fcf05ac6e7e7f5df956a747d9eb1fd737ba569ccc2c7273009e2f0a43691775f82ced893a18c0efb5043a2e3777f3bee807fadf20e856ab419db260bcd7b4dca14754bfabee770570061495c1bbb6df8264f6f86fbf11f333a61d6c88f54a355402f5972f1cef8c981592e63cb73aca5f3598b6f966e758f557608dba4076de5f4f98bae025cd1163eff923570dc46b299b4ee406fc1bc459a5d00f0a404940584fffea333b568013dcb122fc88510506bd1d9aa23e4bead3f0beb9b81bff963df718e569d4f536f423f76c33122cb754913cebaefd6b107b90ffca203209b2773b8d921b98f0dcfb3f7767526f04c05e51f56a46a1855a90514a89b6ebcc8b50667686945d91c6bbd0b3eb9ace06fef38053e93a0a2a39d49a12469b4b6ec7eb60fc48a46a6e0910680f10f3bb8432c8d8032737f2ea19472e2f9029fda1478905a2fd59b8faa1dbc9b2baae9c16f6baf0979b9da480d4d8dc1aa7c35e5eb0ce63ac71f8d0acf0d01bb5b8079e96c297e2757e15a8d31ef8df4ad0360fc7e4cb8191b885679fff907aafbfb51565a4dc3b8c53702f3e27d8804f33352d7dab80a1c09a9c65ca1da7daf91e528b0d783f63a26d8dc1104b6e32e464461e9163fc164db580f2f6103f826824e6eaf9f2cd3d92870a45466e2a8f730765cd64ee44335ef902d0b05bd6da88374307b01c48549865876b7e2f89ec642906a4bce93a8d2ffe3c169df6cdb824ae5fd38b66a79629d87ca5cbcd24209cab86d701668c08ff3691223e2b575582313409c5394e8def867835166f19152fdafaa9057d21495ddd7bb9b8e840c4d6510400d8a2674dc5d08e30bb9e75fe7c85ece3f6fa5ddd9455ff638abd778f8a36a44d581d3a46a0d19995989aeb3539e037172d6062dcbd3686cccf52485378121601254a9deaebee43ad1c4295024882494eab593ae399deaa0182fd586793538f3c6cdde618010eac67baa9aacf47138a7fae4c5ceb03afd1b419ca6c7e964e35220e1e4ee0617f69afbde46b04936ccdf7d67b4186bcc0749a3e0ae217057ef6dcacf9d121898c5a0088baf1e3e9274f21ac638d83169450793060827e0c7a0362f5c375c5d5345b8e75cff52b4d9fa1398e476d5d41c5a269928f2548f03da318431ba2de0c6a9033a18133204163c998ecb28f489baac62f17f39234e6652019882027887922e4075fc3027f80add9020ecd604e22994ebbfa66ac385d14ee1da020b2aa00bbc3145b2142d609c35d1f1a9bfd4fe221a6f33fb902c3dc5fc8cc1ca01573ac15bfc8be39a69d6ed5594a40af6943c2d61305de75c38d44b5fc56f7992e3af124e6aaa2595179ab22a164e62cd193380ab0bbf24c995e42ca2c94ddc8553e42594614093417a944e861911b0031fb094cadb89b7bbdeab8d1abcd5bb5931896bf844ee6e8e8b59e2bf577df7fc5baf58f1c81b3dca15d3f7cb6e3a7584133485ffb9a392b362ebce36a8f18e21782eb33d1485ad5f5b16a1e11c1229e5da18c59bf9a2cf40253b5eb00e1ed1f999d6d558ef45063cf623a0ccce64d18aa3a89e2994a57b494f04577d288047b558ea7f0c629e690d99b75d0571c3ca033e3a6c7d10819843ba6cac542bf7fd8b978e4b26686546e70245ca577dbf798d5edfc0a6bcd28a1fa1de19052fc9ab48aafb2e7f8e2da4dd6a0314a94e9cf6707cf022ecaa738cc727369a27d0e53317ec51811d40805ee42721dcc6bb19d0946fc95a4016fb7a68e6d7782a69ea9cd722cff699cccc2dc9572e3c621d5854ed9c87f7575fab018ae2acfbfb9c0fcde305910e537d9bbe5afc6facb4c01f026f9e75b7769ef29b6bf7062483de1a09dc45a17de99b4a1d191b7091fe8e4ad0cd1d83eb6989faffbf51c0d06a5c282756095eed15b84d28c90cf5ce0fa9e4951e6ea1efb9f59ead484ff7f83c4beee3e521596411cb32daa307443b5d363381fd4f5ba0a94bce80222b8411853d6e6b73ebed19f23c384ed3862735cfef0d832d5a06b2c73a606eced6ed9e7ab65dbd3e4492174a1ca8badaef553049d2ec416f7f441ae8799be99ece0d925233ca9ff55ede15e19a93066e8d4e9b0bac5f306359def4234f4efb3413935e6ae9aff13882470c0614cb279316908fdd3c26f3eb0f9d24ce0a0f82badfb3123dd69f4a228b223266df21429a8c354e23ee5c3db32f36b8eec72efa9621d57a9d1fc5cd6305833fd27199e7f7eaa7a5d5293f5904db32a11fffcc1b397b1dccd412e452dd75525d62d69030a875e3ef559185738a45644d943c1462dc56ceb3c31a9cb1c401df71c4017e13368ed593f6bf66f1fef74a5c3131d3e0ddcd75835dcd6d116657bb1f4dac0f38dd18d0ac19e37b79ec5bfa03ab945ba023dac274dd6cd5b6b6d9026ed8175db0aacc19cc3e8130c433773961af2cd98e7f532d4087f28940fa8e05041ebfe443cf9c9f04cb92ab12395355ea12b07b50ea9b6f24a9b573a3a904ca6db52e10a4e0558715b38eaa4773d0e988257759b5302144b4333dfc1348d376521e754b7edd9243505f86a5e3b3d17bebc864960de8819d06ea394803ee4ca5601bad9e61f394fd80f2d039a9f3a9511b8e2216059b67917e70d1b9e379e7ffc4bbc8c34fd0b8c6778cb74710a7dfc21a94b847bf332004ec1717c3a7937b900ad96eff4ffb4bcefc27758765644231ca9393f16634b16a66839028f4334b6cf372405d64a3718dba11b243a83e3f735a9f747a9408fffabafa1b3e3b705a6603391f175d2bd66cf2d1aea52bfe4352018a444c4e62205352ed906ec09c07b2f478e0ab1d7330d55927a6847a68dd024f0fa2f9189fe58d8dbc60249f631fae261afa575d5b5556a3a6b6570e83a5a5779a78517bcd59cd165873fb2e57181950adce383a0046d7b9384bfb37c9a918613ed40560ffb6db12df6a15480f0b5ea0b7778895b1f88fd89dc6689a311fc078ad982db9263127bebc7819b5299a6ac4eaf3364364b49a93ba30f21a536d9a28349996d74db8d8cd28759dfcccf60b178a1285c3156bf40e3884305d1eaca478c2fc161f238851de0e741f67d48a6359b4aca1949e5f20182163d991d8b660e398efb6be93ad7879ffbc8a9258b3e6b87a2fa0876dc6db152dd978b182931029eef35dc0bbb2832c2af33995ef11b292bec0bb55ec4fb3b0cb6f6b977fa415680f376a662bcc62ae85a778deeb7ab45de09b71f49274d7bece59df408a42ca333ad303a0fe306bc7eaba506059cfae436e06e4e88b275946fcb62bcfc0b320d4fc45808ebb56c6090ad404e7f90be4ef13e70f0698f6514e0749a085379a1abc24ee9bbaf9d915c0e266d132837d65494e6c38cdc33f82890d6dd9fce30603468d8d7dad2804f3af76ebe9f31d57ac27dfbb9fbf9cb3093a976976b202cad6c4fdb6b8acfdc9f4e0a4695286eae6dc02128f92c5786524206289be20924ac08533c8c378da903ed4f119bb518061c096997952ced3bcd540cac9ccad0fb6702254db56688b88f14ddae20fb80f41206b5e5f9236377a03997f63386bec02ff9140008c02136a0a81074788d8c0094ce7c22c85756d7192dff6695d763dfcb4db7a0904dd3f70c52c88559f06bb54bb634d27c7c40aedceff6f0c9da4c842ce4c7c0136ef2be1169a459d3be5378531d553238cdb29a651bab2b9b0cd0ec9c13a5be34af2e4e4bc315cdb7ea92204eba5aadaae9728599c6d82e381c671b60382918a91ba550a2b0d8da198c75f47a1e1f06b613b9355b2d1c42a3eb57dc2ca7845570990f113075fee9b5e88ff32e42f11d352094a7a20e33acb16ca7ea68c9d95411d07bad74c9353aefec9c0622e39a64768eabfae0a4090bb1434f42e6b2ea553a052a763ee02cfbf78e6f30f35a10da438d29850a5ebf1cbc971bbc7820340229d6fc6aabdaa650db44c83bfcf41b8346c43d9eb0549e43d39954eab32e73ba17036328a7cffc8d2b0b87e82725f93f3d083c6acfd12dfc069c71c412aa6e202031519fbf49de3ac8c46fd20888e8356f4ecf3d3e66fae1f1ec45062d60c4024ef3b0f0caa1bff7016c5636d0bc35f3a7aa7f52a32175b23784c407d95ad36bd451feb0099b509ce04d2f77fb6e411886349dd965f6eef0f9d5ca0a4b34c9633aab9b58419e7af525a2de57197c92c9f11d7abf650bcf9085b16dd26ec2c378e0f0bef0ec1dfb140054bd044bfd0a0364f5258605486ee17c90cab3d1e17065ccd8219ef7426961f4b6291e0f8af8d1217746726c5ebee17daba4da828e4908e178d35963b7955a7e2d42e0a246eeda4d341c15276b68fadc355024755049b0dea07930e9375d6ead45657cad1b0b05dfd25ab6128794f6ff1c5d088f2da0571cadb2c8c59a5b62767c42d9d2a841399dbed0c02e02babd845f74da26de01f735c69a81cf993080b288621c76525807315515ebe9adc32c6091b60d33428b308e3802af3fc49c74fa496a50c6cc96c6f5091937b7468e6bd53b7ba5e9a714d8bddbbddeb8d69d13ddde35745a9f6e1df213290d6fa73d8658161eb3e6ad2a62e11565f1cf0aaee751b1a287783034e81c0d9cbb9225bf6665698b79a60a495c0eedda26a78a9faab8a25f958224543d7844a35da5242b76383f89bc7f8307a9300dda20a942ac7a538d75bdba3c29b81bc679c395657403e0f81452282301a05d9d6b9b49574aa6447fb142063e479cae950e588648a66af98dd8e72f816e314871749e9062c859032a42a57f4e98d55d384a199953fad867cf4554c6168f0813308fcb401e3fdb4b5b3b07054dfd01f12911fb6c5c861db843b9e5638981104729873242bba821105b1ad4dcebaa557c273f9b5b2ffa70de45a7104b0122db1e31965592bbf5d3cfe253da7613f91b11baf151b6452e0b0d0495c67f6652954417c89942e8e668faebd026e07851d863c77f24c2f524b1b3278e02da8efc71d7c58a879bffe59c55ecc4dcbc335f66cc4d1366f1803895402248b11f2f55b2f2ac62aa64845ceaf5f4998e9a170c86f3f582350f5fdf739c9cdb89497668762d6e5f9644601303dd91b13966b75bbcb06ffe00facb44fb8c8ff48dff37b6ea827d43b38d9716cbe024d325e3c498d8e9b6ffee5d7b0e3657989f00f3dad0a4fc1119bac43c09894308d3562f57d0525eeb5764aef64bf7b72e109a4c13cecd2ed467c58da95bafc040a54cc066a1f900419ab1c6196af95dd77bac11765f47a7423bdfdb3538fcc8e9f269f5a9878345fb35f2d2263068c07d96ac48415c1340ab4b8ae24825bdae03a05d797be2449d4cea35cf7fdd3f418e4b4df33eb844586fb78dde1dd6d09fe907e84a1522a90f128dae582bd0dd94c6c377039c11d0585d8e77d6060ac9ca8da51dc539ae1406475d1e12b912e37257a7f5b24cdfa0881e59b1162b87d28452d0ccce94e3c5d58af7972c31f0fd55c9a5b53dd2418864a4a1f5ba3f391e2421e6bf32f2f74d034349f229f3d33a09a0b6c7d56840f51b02851a13ecfc2370204ff4152fae6dc59b5c4d00accce7b480e758f548941a1ac776ec0fe1c14aa63f94f6adba302152dd1f425b855027fa9ed6d3c4b04d03104b34886a0415a42935adfb7f9635de58d9d5151b2e441f873a01e3d809ab61fbe3ef31229ab76e392b9a7e1c648e9a5b837a22aad38da9500da7c700af9f62e1ac0b7f74dca623b374e36d330796bf864010b0cbb38e0c0d0cd69844f4673f8c481aac3ec7a920bc72d871ed40a331dfde3076b26c8f9c6e902f5a2edd6a227ae2bd6a78b2206ded70c5e1d388c7c48779c6d73d2a6b012e7d9af26a2bb1232eb2d81fcaac6d21304f49faf22f0e1beeb06d46cc20c12ebd9e146a656b2051b529f72f69f2cbf6317711f97fec1eb300c2653dc2159f947cee0ce748144f6b27039cc1922c2097710de62399c0105c38d2bacdaa09e2d25ad122b23f59df342c550a3cd6907338d211dd2cf2a88d3c0dcfe473ae5232117d2bd17cac7e507066641b7bfa8eb8433d1735a9582b84a039098907daaf846a3d8df88bde1ac85634378e18650ccfac4d2ab361ab79314f6bc8ad339183e1074487ff3aa7b8c470c2e33f64c690b90ac1a8f4128da6094c1a65126dd79e773d172236fb8e4738d99246fc5bd0b102e0a06dff484066adab06add567e54034a6a638c6367dcf878721ae5337718fc1aadb4be2e9ead0ac03395a93b67c12b372c2e7303a9553833a9bce28595ee2ee4efd1f338442d9e2b503024932076ef8dd4642d0f40c4f8e479978010ecc0619976fd1d1b83db99da44092fb32a954b47e325e59e5ad7bd070b9915142ae6ee02b01ed36b6d832021d7884b1a989cbfb99a11af0e70ea9945fee155f55d0b77b95cbb4dc403b1bd5c1b164546f791a4eaecd7610fd8a67b10476039540b98a57e50b826501c2266798b128508aaef7c419f5aa465703dd116a9dc4e1562d5c326447f4ed80d839491ca19f1eca18d0e6cce39687de650c192e3ceab3640fe2dda839dcd98a4207baebfdf26aea5ab62c5e1597d92a750f3531893c8f7f241e484b08391adaf4c88de672c3aadcf2edf3db06e3595d4c528c27ab3040d96018f9a7a1d3dce4ae688a2a1d23d94a1a83b9c235803ad4643167e6c3e022d8067fb4b4713a2a642a54678796b4e9936aab24414ca2971c3bf5ba32077016eebcaeee95050e1ea57fc31f101c647cd7d434ad221bac287f877eb75d057e15442f162e0dd260a426de55eab57862853ee3df68e33fc648eeae4894d46ceddf8a96aa19b400079cf316899d062c8703246dda043f62d5c0fc32396a69a63b70d2f212651e2fa9b9fd551a087e918f226b2c44a4b6c8843506b96a998aa5cfae25f0c19dc17701b4e94ea9f3d518ebb0a22129611b8f270eae8bdc371a68d58a119da0c7d5d8ea2d7921ed408f2b0ef1d6ecfffcb402f8e8014d165941cc98ae4df4d34ad0d7b949855217d73748e04b1c4f2866e29842ca879296854d7723c51ff7822e848482520258d1b04eea439e97d937f38e3452f9c20594dcc728315401a3b16b85209e0e078245dadc20da1c7db1dbe59cde2c83accb4cefce31f3720e1961dee4ac22dd79450dddf10a121af48ab4e48069a23ad3627012d843ab07ce317b58a8ba4dadff1f2fee6cd662e40bccc2ba7369f34cf60d0b7af33ca5f8640bb0abab2ffa8e056d915d5e231f58bf7496a596ba9398f78d8b96aa5d8cc494ece34045420805559abbd909bb20e1a209721a544b949f072857055bb395f8c4aa8f49e4cb9a22c0dded3d9fce39bf9ee7cdc52b682b7e60c66f5c299aa054d66d2e85cbe592e51af155dead800ad6d9d7d5e97828bf69ac469ee2c1c53772f9988c3e5e42957d828dddefb9591903d3d61b1d38cf998d43c7388270e93c2a813bb6e31eb43ed1e6889f4995e9605975fae21edd7f506c55b81389feb14d201291bc0bce17c763a9213eae3de533c025c000f8025f3ccf73c6803975e99c00d6b8c56cfd6349b8d6525f0696f634d4f77bf1f2e4a79e49c4a6d362b37c2bb9c098703d8ce6378d68014913c87de3a0adf357e8e807aaff02249308b9ec7f9ff77cb973029ccfad391e2f928b13a7c44fc5631fa61c535a6d52ba20a5d937f7c7bdcfc8a0d87550fa7e6ae851edf3829659ea615d3cb743d929fa556ac1007ab0690c9439a91b1839d9653e6df59cc8badb6d903de3c89d707de8de0fa4b7722430615d4922c531030ad05533d6eed8630129d38295ef88bb302b272f936560f3586eca429a58e8af9eff2551993f99591a77750c3d25730c19223ffd3da336d903923b5ed0572b03e93538fb973f193c66f3a598d50d9fb642c4f2a992925fd80d11aabdb945cb5a2c286565cc391ade8e72916b36e26d5bcd1661d59bd294c078c7a4fdf495411e709d84bc9b84d8f583b4afc53dbd31fc3dc6a72ca4c8c784356679f8e5ce145e09e9260ff6d27aade3e7c097a9c45fa8f5bec224ac0883919c1a57620d1e4fbaa6aa3d1e0250d19a411faa36b3d012cdc973fb72d082c0b03b1c7b9a2b6a89fbbf78c3b9ee668655cbb5809865311900d638af1a57f85d1fa960c8da07b343cbc34aa2f7b06ec566284afcd7db085b9aee49383fc9e218bcc4a4f9aeddd2ec1b05af10fbbb8d6e2c4a2581bb16e9956268ebeb334b691fad07efba4386ea6ab756447e98d0ef61e962bfcf59fe8520b83da13b394ce4f85facafee92f9935715fc8c69b89d4c3d63da44332a55901d589ec47455e5e30301bfee50aa491b919b0b101f1d3d998f0508c906f0e18dbd3df24013e087eea4b9cc767a3e65e31a8bc455877b9eed3f6e53bde3b92827a0d6e9ebac90e4fda53b8e259ca959166165ab53b04652433db87b7ff8a04e20ac2bd0f3a57a64245175c3279db89cf7ed3de5c40274ab4dba240561bf806c912a1f8cba799a0ff5f006a0835b1ac29bca8e48e0805c7d05c5d5729b0abb5ecd79b32bb1b4adb52e3374191e2d87369fc02abf8f3f39051d42863c642cc2c811ddaf1862e756d7972163832d612e56e82000bc8843374c142ab52bdeae705d566bcd5f06f41873c1ff0f0f55a7bb2bf53f967b7a23f6d7235d07a2ff3f48ab8d948dacdd7790fb74f90c1c832739dfcac375aa02d29c683ec76bb0c9e88bbabfbc9787c1a9bde6248f41ccf5dbb5166d9da7fc7f55f6307e9cd23d484cfa8dacb7effd5fbb0f23ce5daee099361f01556ea3e224017ccab7042ba113289d598457b5851ab93102407047abb0dca8fec588b17cbd70ab2536902e2a10c33b47777ef94cdb18b7217b0b1b58501e916b75577018c75cf547c6971a1a37a94cf6e4e8f426939c8d32f966c03ba3f605ddd735804e3a7e01a9a9e4605ae6ad650935a3cd263e553c76b6a594742e1fea2afcb20159d6f633220818965fa8acf6931001037a7e8685ab9813950aac9b570286274fa1ca2710f193845739e3fbe0d7c943769d062da94ce0ac29af7e50b647d7b8bae17507aeebabe169c878cb1c480ed3a5a20739d7f96414432719dfeb1eedbc26086409502bbc5acaf52d1acd5f580bae0e41e6ca5da9e903ba1f8ce6b9f49481dae26a913d6c81422eb3aecc88a268101ade4455e855e2704026209f2172ea94f27d3701463f03c510d79d28fca23418df4cc67c7d8514398b8946a4d604cac1ea85840ffb091fddb8ec47fcdd988a7299c78de0b45f1cc354b0879799877f7122dfda6097be27705ef32855225ac6b742aa57f21f216e30a9a2443dbd0bb4436d939ef56ed6af36eee8ec5b0e52e19c4ee2c37d1214a30561bd6e6e81584cdf9dbaee289242f67d531f89fa5f1a9e72026825d728c76a32df644c62d8abd8e3c4c32eaa021a5ef7a85a6d647f44cb608dd229d8757e6c9da2772a7c020f6fc2c8ae30ef97933158e5cb7430578ec400bbd352d44ff3c32a16973d9d11e7f307dd883c5b299fb4d4057ae55bfca500e5875f2b62f28aa43cd7d1309507a63c9c78b4d96c4ce0c64fb4f4cc8254f0f943cffb0e84c4e96e8be3996d7d7a64d0c22ebf3268da51920a616f9735f72bd8791bb1055ad835a1f3f22d26dea4dc7589d0066e37ca1a38fd7aae444e3c25506f74d0077d2854c34863ca8920655858a0c7e480c298d36b9899fa0a34a46c48d2f46cdaa56eb6c26ae69bd70fb3148e6dc04100d2522e4c4414f8c7149bc8ebc47f8d994d216c4014715c054159ee899096eeac7a1f28ff41544d18d89733c6e75e8d943c86344d480f279f4b89046e3c44fb1cd95eaa4fa3d042971412cd65795c8dda51ca5085e6f1dd081f07c6723c1a7cad1cc2a6f7420bdeb7933d026756528f82a45b9c1bbfd2d0390a5101ee3641d410392132e3eb565ed37a13b0ccc139e82b9d30d68a4583e67d6c9f1ae36699df4c47edf003ef8df45831bada14176df7007614d431fbbae6c6dda8001bcb11ad2f7f499cffb1927a5f69a1624567bc69b5ccc8b035986c924c6ff2742bd7305884985dbc9fd3ca83753cbe61c504f68ec1222db3f7ca06aafcd335a54e8e0930631a2010df2c36e68595fb023716cc5f0b7a97d6eeaefe9e58245c25be5b2b44603f47ee52226b67cd6fb918568323385e29f2499869e359971270276831ef0b2d2d4b33a417680d8ba955ef9ed946f42ebc168a7562061b1fc2ad24e91107e65239996a792514f1aad7bf809b5cae1961481676c1372b7a8335ca3984471ee92171b6564fb1ac3875db3c63481a295033a36a5d6c3e5de115f43b4c40fed880cfad550b992bffbd047030eed336bee08faeafbb0e9f36be0f8f1c444ae279e96c0b5a5d3afeeff26aabc5aad89616801d1f3de13f0e51031d8e1c04e99e8d72210dd87263d5365fedf87143d728b42aff9c09f5349d815042d2eef4e188f1bef245979d0b602fe4639df771ec6eaca65cd13f3eb5c031098618100f5440fa9f6de80eff7047e05690460a8d1ef6144bc48530a81d916f1bff81c585e7d791739af747c46db04336f7b149fdeddb17a153ce35fcfd58e987671367c51ef11af800864559100da60bd446e481bec7a43aa4efc05e717f197b146ed7e8bf50164236a9e2fe34005da3adf9845cd7421ebbec830d3f6de7c5f9859d6f065e06506765e6479b359d0461a46128ad273b7ee6db57d5bd09446974561e6c4289c7915583967cf4f312700837a44d8707b191876c772a8fb6170419ffdfe6665165ad4c000ef1bdfd59f159a136cb318e90b35cbe810f9546cb380ae0bd88ff0f5a76df17c0be263d65328b2bd234c7fd9dda9dda2c586bee0afd404d5c13391212d552abc2e4a728b7090729c2e1131d918e2bb0429d17d27495812aaa044298724447bd6c18a60802dc7f4e46292046d93abdd339322e76192533bb70665556cb02a2deef57a8bc6c3e86a02c4cd52526a91da0ce544d4893565f66c400cac25db718e98108ba66057650deb2b57438972158124f73f6869fd62e9e8e2cc1ce4879adb6c895992f9b7595f463c1412919a496e822cdee2cafc03bab39d51ab3fcf1713041e0490004577ed3e992f06ef9481c35b9c636f9c5fd0119d7d4b3c74c2b84d23d8c779708ef24d6091e740a000dc462a075de36145dcbafd91faa1078091d68cf6698ddfb3b6e1b94a13342b608eda3572f1cec767e88e56785f52c645b4d39e26f6581faab87b4c26fa7f8035eda30849234dc4b1a0e06efbb52a835fee840ea92804a4c3106fd55d267c1d109b3642fc72f1d1a599065ae903f46223494557e3fd7ca869e4563379a5cda3fc891a1e3b1da0c06ef42fcdea29b0a651eaa5b8294971f475882c08e9595074a62e32f448baa166d39a563d7a3e9ed3ba529dabd68d08147c62184f4173f4d194bffe8e166e4f7409068416c726f2ce1e171aa2ef41e628637c8c4a8ed3fb486dbc7e95142f1335bdea6d3ccff6e6c8ea0e8fc99a3b72206f3127f33730aa10be518ce3827ca1c218df8ec23f53c6f83471cfeaefcd2b1bd5471a4039f41df49ae1030b6cbb52b52cf8a24a6dd76ae90b66e10810f5f99e8af6cd6dc9627cb1c6a67fe814ff4d2895d27a4961b95345c4e15b837622efa017bb4e98c0f1ee07143724770cc4cbcb3491a06d23243775b24b2b58cd7de93284f12074f8a079fed0c3a49d855d63b26d0301b9a4b58729387a6bb8c96cd44c378c97ff00db3d876ad1ba6820975dad3eccc408e2c246ad726577eeca7630b0435e9028bb162c43ba45f83aaa5746fb2380d22815370664f91f59973aa0700c2c59c9ca3d0df347672a9b1021da37b6fcd2ee114c54514260ed6a3ba8fedbddd47a87a4f65997095d86440d778eed58fe9d3c9ade78a965d981a3fbd44c5ca6c5b297e3f7210df17c5ad73ed68fb176de25311df04964da9c262f061f049b074544e7961b5ee5c0f392e5c829607e3adc967103b832127a109fa54b188850ca11be0d4113710a97d5b818a498d35c35058535df74e8d14941ec4788eca0f76fbf235cd2fda1610358e01cc630eb35431c9a4edce089e5f9f12400b17034e7dcecb03f716a011cc653f1ef13ccc6e12d928c0008da601a0f5e9b054a26a659c761e88d6659a2bbf1b923896472d24d3834c925a785eb3312a122e04cb9c84c2646df246d3f63e8df951cb116480d0c49b1f46c89f93030b1d2cd3aeab336a16d9a362f57e7ea37ebef15a0e7e527385e42bb6d8c23123421def94820e6631a1269d5642bd4426a874375462b7f3719cf5c00103c62ca9590aa6884e7d99c689846aecb5dd7150525421e964a3647f415602a7b4539d491aa53126d22dacc968fed80990e8273fce910c071064bfc05c0907092de995999bed85cbd5900fc442859326bf23bb673da3ee667aab9216bd7a231141ae19a4f937d10f879ac491e45b2079cf849a1ae3874eaa5391bdced48a880e97713dc2d738b1287a2f9c4339e630ebc98fe30d35c2311488b67c79877efad91f6ceed807a9ea1d3ad622ab869ce20df688c0d40257840afda255be9aa72d02aef05f5c4d17792a50474bc368ebe737a51237336cc4f04ef4b5449b6bd4388979f71eb97fcd89c56f6060c50c167696ac5fdbf37502e8c3165f395b1432614f4d2f945433583c9167f2bfcd3765fdb72fbf8db01cead476668bbdec25f0cae536b73eb592b557028bb0fc0c2877c6f5dc5c7fa345cdaddbe3e3b258c8e6a82b136c47c3f62ef7f77784b1d7c23cb147bbae3d43cf969a6baa47211efef93c50ecdbd3e61fe98065eec1d97fbf0565ec0f357021b341fc985a0555f9323ec342becc2362ed7a8316fd555c10222afca044121c6a9020cec0ea0f8f311bde609cba7e57399b4fdf747cf0960971adc47bbea99b3965d62bbeda03802c0db929cce91fdfb0b73e0ea2eb19cd9b9945ac111e62a7bba23ab8eb2c531f006c0ad1f97bd053402c6d673d35ebb5f27286f83022881352ceed4be60f77af8c704ed769248ed47ed4df2fa9cfb51b5ffb7a34b2b7fbe6e76ca28318d359dc97a59acf1e12abb974e9f16d91157432d82960cc4ad2b9708f3ed73fe6ed5152dedde9baf6c36efbf0ab201d34d490804cfee3980bfb1bc43061ad17157b98463ddbc21c47498599a5fcb85bd8345eb8964ccd20cdb699268e8feb78de61b52a839a9ca97c9022392fcf8452d406392e8d93ba38a8a70de4d07ebd8ba743e900be298cb34b411c18b69e1c7e5f9fe3fdc04d99bd7043d9ce1d1e2c1e1edd58d8d20463d6a9ffd51dd7237725422f98936da97b7a913673463a76ac67abd7e9f337c3618d9db8d821b9581e3c82b5e4632d25cf1a7c49f696ba5a9ad003e59cb7847c9291d4e950e4f38350f1c421445b95d842c72cf6ffcd30db80a5e34336b9456edf01c6d4413c4ca129cc45b795f1cf90f1ee3d89dbbdaa5bba82d266e419beb64884275dd74592b5663f6a3f01e331f3feae8ee9bf3b9cea9caf49aeb50888929cecfc8f16acb7dc80106654343864ab0a6b8ede0fa1568377ef5e3a7a6870779ccc953eca5dde436b607c0033413cbdd286c2f068c1c1588ae4a6d2c739ad4c8ac741554408ce291c0f8fe352d90dbf5e1fdede1e31addf65c59f5f24c8a4dd28a01f403f48ee00ecb91fe867eb85ca1c6bd4e97d9a39dac58ebb81904867e183a5279f786a7317383dbbaac3e9def4f16ddbee54a060d8f084d9ad0189f41ca611ef84583967148cd202e33ef5d2da66ee088c520ccb6d6bba30ac695cbfe78cc4206474997e3fb787b23bf8f231617e7a4597e6b174d79da23c3e46437bdaabee5c2cf03f1477ea4e0462981e5faf796443223dd3790cc38215d008947895b060a892c1ef9259f400db329881ca9f8d7154be77c70c32ab625117d4468aa2d1e93c6b62854b2ea8a3a32bbf5dc67f0a37ac33767a53938f9de938b96f8485787d435fd8833a4b2b88f46931c908e5d0e4f05011326fdf5e2968fd912b7c68b242adb2c21abd6cac8b3945ad77c8dd6cd2ba311b199434181bfb8a5ddcbb30a6cc49ea96827cbb2b92d7e29a6b2f9e00f1fb3077b53bdf3b8cbdae4446bff50b6c21d1503e629c9d69d887cd3c3ed4169eb619661080d1182bcb9bc1da6dce294d31d19a70acd387be42f809d768a42af9127de336bf573d843b96699bdefee2103c8613b6457e829da8d72072c60f0b8f4737bca3cfd676da4534d2f1c17bfc7843f11064550e8e67a5da9eaa4496bbfeae279e01c7f711a49c9c5a90a3e6cf18d60f73d436e2298595602572221da8a0bb0ef9243ca4ad42e6f5e68b85da0b86f6e9389dd45023deb6ff095d40c1cd4b7a8b3d0eb1b162ca9f70fbea112e56c7ab5f1f8e848b5aef88c627e63a7d40559f1e233c24bbb0b724a470cf8d02099b0b4b57d72029fdb0625b45256393f0e33cc423825d852362411bbe404ba7708c5e26c12257145786ff80336f1413cf071dfc69a0d7d9eccc598d7a97b7c872ab5b8a495ec823fead56dd4ac73bfbac4c6c2e38736b024d4b5111dbecd8feb058176d59979c0879424fce84976a287717e2353a9aa5e30154bcf8de542fef4d4dc8c2ba9da9284f83b02e7bf28e2119b73f54ec4664c52a49f3906d6ed3ab5343f8349ca674fb2edec17526f9e631fa81437014b57331a5d63e5ee339ae6116fbdc03dc197ea205ea2dd1e010079bfd60be0df0b3beace00cf500c0e9c8936b775a3d1face20c541f76b62b497c8eb70633f9dcf588d592b72554faa270c74a84665a4034923f36e44b42ab222ba56611e01ef88125f92007df7bda8429e0b9e8ad93edee62291536ef157f0bc025fef82464a13ab77a7b1666b49087d0ce95b2ca18ccb59a0f1772d7f88410185ce447cc55e8274ecabcc23be734dab19dbc150934e5bf95e3aa288d4d7af6ec35e01055701d1fe2fc2e008c7edd56bd25283e6a4757c8b33da4b35a95e6e5c83a245c58112f7f9a0381535c4db8fbf1706fdad7b40fa63a429e9c38a1c96e0421ae5c21c236e7b5d8cc98086b47f3ff4e7a27dbb8129c528de171c717f136817fa6ed3b772f9246e7b9f6a33aa8592ce811069c4e1f9bb28558109dc8b5046a0ea3835c993922ae6c381a668c06ac79607a34681bbe1fdd2823e47d439a35f645dd44fd7ece5735f93e7e674a8ee59d9f0f1ef1f65643529ecabdb13db34b48583b82c27461e1d1190e65b692a3890f6b5b82ac164e63b25d4f3286e8a3e54cfe91573154becb601e340e0a41dc3c4af01d9ea49cc948e90bc43ce1e466fd5becfa5a5e8fdae8c3186ce485c667edc460f0afbd2c4095340a2645c75d0888d008f6aaf5a19cc13159fcc27ab09f07d385e0d68269af1f3b40f76d6bb7bf8d12bb8b161a458531d394ccba6126186ee11346f9b19e3ab99984ff5f394a7ba234c9930f2eae3d38ccf4722924e34d7090043957c33bcf6ffccf3d52f8332b766a8e181df669ae7e9855a9fc8867b87a6acfc88d74f8fb63883328cfc515ad6558af37eeed2dbf0208eeb8e8984a2774fe6b782d78ad00ae2a6f4684ef4bdd0bb57dfc100f53a66783b846241eb2006ccf2d3b499d35f6f8c0540606f84a54be45f6c16fe9b6ae3cc4f125ad62e3a132e3853b997259a765af895b2885ff53fa0f1dffc3d1c8a6aa7b6ead5cce160358da90e9ea7e898b120e04e3d2ed76a15ae09225d0e463ba7c663385ec406e1036e79bbf1f5acff8ca15bd4d36c8850bf937f2c95e6e5867f8de66e52d3ad07de82c70552d2cfb0baf0cf3febdafb520da78cf4940f2126d93d67fd205953deb2a20871c628f4097addbf579bffd60ece864690ab56219bdc7b6b0821bc64e0ef721bd7185cfd2b537e4244259a6e53051f5f2a5807e1897f7950280e5000838d4660cd70fa5017811b8c854c42753bef57e33567ee8ee5f06e8c5b3f13ea139822fc535110eeeec345992252880192092907de662ad98b48e0bd2c1a2405b2aacc5b14f8ef21e2c69a705a4b83e317b6fe301774cf1e00cf825381d1a00dafd3d85c6b3e6f146240b911d7be56e5433e98be5a54d0b57962273aebbffd38c2664e715333bcc3eff8cbbad3859c4b651395a583f9fe878aa03001be860d5ebaaaef104f34f4d4e71de8faea1fb01d9a9df70bebdd3d421cd98a37f751f141da5ce3ebfb1331f0215e03f58b4f6de7fce0ab8f8d446848aad6e374323e2ee219284f74b71ca8e74b81ad98222a144a5e23f88998eb5397d4d277d2363ca10b8aa46ade40760963dd6c0385a5188faa6c3bffe1ece756e48056a7fbcacbd423bb429e0a6bc1a1598959d3ba2fa687c7a4906d2587f79850c54f1ef907b1949f66acf5495c6dde34e231b97d6979e6071691152f7babe15fd433e6d989ab01c2b2ffcacdf9aee87a36e14e8c20e21e4123857c0b00ebc562b9568a15a3e8669475ef9292a5ace4214dc119bb4d44d59d2576afe29ed7a376d7fe933d4306d7a28309fda620a1065da73c5f9c6b8e9802670a0433b9a7b22cbda6bdb2276d2487e5e521243260113127bf85b1d58411507c3fe5b6db4bab17b2c7b33681513b3e3d7133097d10ae35f8ba2893da83f6291e018fce5ed1c978b61778ff99236ad13ba0d6a81ad739b106d173746f09a5691bc7b99cd8d4f095a3df7be34bd5d37b3405acb355ec512185117f0426394c6d105fb2b8a2598480133d9364e517a71bfb5d1fd05b71e775020c8daa834d618d3ca84ae54e4e5a56e3bf5ef291f1e9bb8434b9ac7d629e36f7a55dd839010a2c67464aeb38443561f9df10d9be705f8b1290153b2b556df3a52315bf54d700e9ff0e0df2bacb2c74c5701c88eb5d5b3a5d46370339733376f4526db522177405f0d0f42d4665ec9b789ad5f4aaf8ec4ce1ede489765acca00bdc4d725a789f01c9d1d4047134fdb8bf7493b790c69ec391869675f4b6dfe23be19e840db6315c186f3dc84de3342f7281d5d0e26fd8e557118d8fd5e2e79654d0b0e93684c9d4e2f68c424d39ab20a617ebfcdc3ae9fc25334ebdcec4d2799b4070556bf50d0e8387905881b66223d97bdc32e7a65b14cbb875a196aa2a0dd9dddfcdd613c58590d903667fe59d2698a0c8e4ecf5dbf8507460353d0800f5f44aa3a751d25e3dede7098e0b6ae0e15467c268bf8bc8781086d5ec43fd40da93aa3cc0cca624d099684d61a66c0a55525319e0544084bfc74f5618efea7ac7d02d07f4c011b1e33d2c6d4a2c8b2cfa6b13b346f6601d64f5e719fde5d2823d8b58c150755376c65aefbbaa440e30174e9f3d9232f482d5b8d8d4df2999fd8836f8725d72be5c1413bfe779b42b03d4b2df6234c9b99910609d8a9b717fc4b1146e21c3c0123af73f18f49e58f0feb7ecdc0f1f2be30796f14bfbe750831135a105f3f9771191b5583a094dafcb3b0388653805067ee5fc8329f012d7cbd2e06c6b03ef8b43beb2f85d3214b1565ad905c72773efb89f35a57439a7d6e5e5eda3cae8edfdfac4cebade229021c547d814567a9f59eda322fb17df1cff928d8476e313f9e723da21ea16cfdd9889a850ac9970dd229a66978367a5a9e23b1647d2f781a0ac696d645823d7b557cf8885785db47d4f63c3c38b063f0eee2ec22ff68e7b274a59df171b911e4ea59b246ef2267a70782d3178ecb7cd3642cc2e334b38078397b727ea9b0788925584268d508b6b930841c63bb5eaec676a619f68aa24f28a5fe05b9922550a363319d8a89c3b557a24272e3d5bc0fddbd27b726e77de2320269c2ff354e8ea11859c33eb5bb950072834e43589191c47813ecd6266031f9e37dbfc593deb0a0d242de9d73853b015072fcf1562c350eeb36ef407b77867395fd0da41acaec6f785975972e2d3de6fee90d41da588cb7610e8832cf1f4f1bfc71e44ef9cb1e127f3801439996bacf6722524787d14f4942aeb05ecf482785d674a9fa2ff42101f3ecca99f87aa48b174b4f200a200bfa7fce7da89f591ead9a5b9e619f18b2f5e424f5b7aa06cd4c91cbd22c34da02f7a2bebcee3516e91bdcfef0c693e29dfc908669f14b3a1773108f66b3601f5c66cf125209096f96f9ee005343e4c1792ced4f15ec0aa4c43ed765a786785d98299b4c941925b19935f486e7205f6ddb0509c2c36b534ee60bc2af04cb0ed03372d93beaec1f50e97b5f2e3ecd1aee53c9e9ec24b1315300aface629045e9e7588934edf01849ec7237e62ed55059668adeaec2b7f7a4f194a191d7518b5b4695fd97bb394ac337048fba2cd016c125b76949d5ca789de790653013572cc6be68ebfbd47f460684d1d94e90e01860504e8e6d25b0f901409f4950804720d388d25db23eff2c5fd8fcbdbf313c15d73ef90742d5fc27edfb2051783ec232247ccf3e1cc1c3b5205df5d021ac9045760648b2eb0ee1c93264167d580c9c1cd5cef8bffde768b221d30fe19d112963cb297dac16f240a377331444a31036e8518092a95119daa47dd8aab939f100a75ff82fbe7e246d9a3be4a94465c8c7735a5a195683fd9ac56ce6343970a116503b752edefeb0252cf9b66c61bf74defd82cfe2d20c75a10cfb0c2e886a4237a95b73c021a0afabfd0f3c2c9358a350ed9cf83aeaed244b1b9b76d313c18b41450dee1c18388f58eb3479e0f7b0dbba4d49fecb32f7ca1f60df93e1fc73c135ba73849ca94a725752e223945fb24eff2b3036b3ef6a8e57e361b4dd98926188924fb248a47d56bef48c2a4d035abbba3deced0c77007671223e04db3e51db1cb6b07afdf2ee1c34431c62483049c41612e21ee34382e112aae75308321e4e8f5ff6b51f5a2e4e578f507557dde8a82040b5169fd83c2c5f27af69e482146b90bc71ffc68cf0608effb1b96a9d8ebadaf14cd522ad34fdefb50d314a739fa2367d02ca5f48ab6ab01b643f2aad63691588cf8bec5d97ce12f4c742a6a919cb0066f5fde64b44aec31a3de9430a787138f79ff8a034addf072bb5675e7247b86bdfacbea5b148efad40ef7d04620e50f7d33d1b898d9a33101b501d3b9b511c7f7edc44e56466e5b405bcbd5160ba19c5e773c9aa708b1b324e6f5fe06bac7c898b6bea51d4fd5cb6b417743a2c7114f694188d0384def886eaca2d2591fd00d031fa23de8ae013d5aa1152dc8fafa94208decaff7a56f2c29caf1155a2951b22d0602cbbd7d16372796676aa20dac756f5658a844847ebe4123a7b2baf81a3162ae3ee50eb88ae241b7801f9cdf1c7fd6d64a1c00026af45fcfec789f70f66450b083e3c91d4b912f2abb82540c8fb86a1fef273050bc37e33b9eaa1092a062779b04efd0356d4521b3bd86bdd8a58a9a4faaed0f20e4128a672f7d2b4ec436f35b61ce7078d56a0baf6da834f5cbb000768581a40359e76b039612829e2bba1a8051190624c7b15c1a9bcf4c1eda9146325b8f7378ef582c8e5c178251cb1ef3a2b7aa203eebeece13e58b860320320788c83f125e0a4b26068521b15f09aeb21c11efe0733c9f41d837bdcf489636acfb056ef33392d8672bc9f48923afce84d28a6993fbe36d1616cf045e17a2e813c0f4d0a4c1011666a764cd52ce24eee8143b27c763df896ed089c55c7a25a7ff3a429f199752a202b56bac87eaccb27e36e4d0a61c350554fb2f9dcf9ac80bc5061f465ad0bcd3e07fcdf969c6dcd64002a409c39ee581f3bc3b7a478ec12145d53cb54e4ef9a81a3395ee0fc7e76894f023313f55f0549ba5d5214a020c3114ebf9d62035863b59ebc33ca481448eb8abe0898a2ee6bc42c4d43197589863f6441c6a27d3ad9b09c7cee6fe2e3ab58921cc09e67a005e4794284fbe418d12f97328744679786e20558497d304110f09d69fb615cd2ef57503c65ecd643824cac740621e993722e02d69018321bec9acb1dcb59d01c73b9aa6df2a79149a924101020150469f5b63e93003b24fcb540d29d905067955d955dd7caab4bec2fd35d98784cc07851047bd64ef3afb45ff320399f4e346b232ea6ebd695df785733ab8cb9c902c315502bfd55eab6f5b19969f2a2076b13baf2ac1c6a07cd55ec84e4c77144a9aff3e1ede7b93376030c038290ad881d628f4c499d9f3b672e837d918d1b2af18f3cd613567c827699437f101ebed3d98230f432589bbd1aeae555ef7698026fbb65ac973bd167f503816bdd06b7dd7c2caa5576b26fa6fc935f4f433110d4f5d78bbfee568b2f786d3a088cf46a06412a395e3213bafcb7df0690c30781ebf97d73be5c13d033f42f7a4ae60c9c13a78c3e2dc388d6070ccd34d0e1f2e509a1d34e6741610a304353</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>解</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E8%A7%A3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3133f19d10072e511fc7434e7a8b0be6b61f9509ab17170541406baba96d2884">adba944712a73720e1f31df1fce53744b710ed1b1a3097797c0b2a294e64dd7a89cb2e7037e28244962c73ae44b5b67472b65e10ed11890669b42aef28bceb23d1f0affd68b66549ec1829c20de2df6b2a515d96174cad219953e14d928aea7a2b1c04625335c632df061d5f0ffeb4b695e56767d28bf1c0d902f27afd0c3a1fc1ace3439c096269cee5a741e3eb5579c7c85db7bab95515bc52c0f40b4b08a4020b1eb58f4111a9344dea91fabd28da257e35bb1bd6628315f660041b796f073c21769e838af127e4f589a6a20c01c67acfc993525cf509d6696a2119f4eb3f618284c4cfdb3613491aead91a8872542f1db0ecd92516c38869851581dd4045f2c7c2c43cd4b6e92fb25a01da3ca5246fdf3147f26c02271e0dfebc0505d1364fdd0ab588313b1062ee9deedf1a12670e6a6995762150a7812282303f1af6f103af6b56f8c2e457a42c5b3c768259a471726aced0c25a9d13304999bf1095f18aae89a3b6f3a82d09f81f7a0935949f3522f77308a0c92abfca722849fc8c8a998902395d45c69d7bd0fc5a5ad878c74662ff25eee047d568ba4eb31f5a90ea9ef090d9b6638305d50faa345f63a090dd026874a44ddfd36425a7f9e975fe09a783ac5782b1b53b19c2ecd1f7081c01e52f1e5dba6aabbb93efc5a072958614926aece4753e7354ae8f403d1462fba9d91b5026e9ba7569c06b156b57a80a4dd309797f8731ab89918782a06fcedeb40b3848a449b0ad4f4c775a0c9e9274d9259609b5bb51e7671d91b9dfca7293baa86fcbf2ca2a1b3bbdcc20b35b724526112c77dafb8cdcf99f6678afa7047b5f06960f3bb5ad8cdc2f0658abd0a2a8a574ff45e7f1a32622ecc179bf8825f75d583de284c847db7da3d8242a14fdf71e791b47b8c5db59e0294d2cbf360ecc8d1526a9807730c36cf5c5b4d86b644360b9c34117c279febb48cc3601ecdbccc0d8adaacb9f074f9f8127aa6a21f44f0fe968ee0ee698339177e5426fa1b7f624e6be3c380da0eec525e8d3e0ec2615db99dd3d4dc77c4e4fcc8a1aa6cff40081ed90a22c1a6a28906c18f5e435769d2b888483c2d0f316150a89865e5fe118d9c5ec37da0c8dcd8b95ffdc9d55f790058b61cada244b16607de27585cd9ece5cfbaa3ecaea3c60d4a2d828c073866aa42c2b2442572f22a008db574a8c7baa8ac5c455f3d73875c37d10f9dcc51f1e5453be57fd331447658d564046926e8abf40ff4000f374daead8c49093790ba750b9b0c34df116ddb3dea8aeda19589cdf36727059fb9a50bfdaf01a498b38d0201536272a9584db43227d0eabf6047d2febb3ca6216e5d0524ebb235609fcd169b4a2a9c016b64e70232a41b202e6d160632a0db18a7c557f6e7c738c53b49857380b8f84974eb5585adba6e02df6ff6f47e6ce4e8e9ee41b2eecfd9c39995252678d99585be5ac60638ac153b79a34c9e78c7d5e3c435cecaf8b1b022be3489f6df2759ebfb94e2774963b390875a4031fe491a04d82c8c7c7e077836f5159354e3e3facf827b1f69f01802fdc2503f96da068d82f35f5d1ea238e682e69a180c8c619a3c8cc702e77680c81491f5884f56ae54caaf6731708d327c915c63b949d1b20cdccb2f6fdefdc8477b5d9bbc99891530a83b9b6f9f50d91fc08d3999093d18fdb63ecf6f833e0661e7925ecc341779d418e9be986b625d17ce62ccb96c24f6b548e7021bb5f8465b2731480c60b77bcb3b916ba136703560e7eb51755aab0f6e3428f6a727dcd9e04cab4c04f852d743f3788e2aa008c46aee75b30cad84814df0a72810760b35f2da4314107c4330a7eba862af708c3584253eb11c19b7241ed73d642d372cd1b4f5ede454a3838d6ac4171a9e26e820ca12ee09b61</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>逃</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E9%80%83/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bfaf23cab4a9d211cb836bb42edd5fd8b1ed16f39556df55d9495ca1fb41ae35">8940f57808c01c58c355fc7b860e98f0f86d39d41d3b9564d7be94d5bb16647bef53a4fcd6b162594ce10fa1890a8a0da339d85a5ae2dc4062d7584c2f5f4a0b8266f5f76ec146df93e4f3f64e732c8ee5e3dd023629a74769f6c39992363322398ec27a8b6cddba22f73d7eeb35e4860998a43a2fdfd448f22cbd76e45d4c7967fa35b3c43f0e77b024fe13d99bb8ad6d9e7df1b9a411f6da1c9919ab00e3ccf5c1c5d13ffafc9b8c4fead00b9468e6add2eaac8b098cf549625f7a186a77d12e828e1c0510585d5a2541c2ce5da4430cdd676e4c2fafb90d3a7b43987e57113ec92ebd372b70d6c929153bb9ec18dfd4b6bfadefcd995d3b3b1eefaa68757b69fc48057fa7ad556b8d4e0ae3b79313c8de3c0c61e4bef0a6dbabed3504736c9cb67aad5383dd53f1b12106cad63468fab3e2d1fd00816597aa586f05ee24f918314b3bc8c9d3883e246bb5111b5cd6e10570d7d9171d877b746f4b5454d26fb18423c693b5a404443e667498d7188b1ab38ff65adf58784a355032b6e93da1f0ec61f27b38b48cf38114e2962e318f3a4dfe0eeb078811764cd6474de43cd290dfab9bafe5d3f178a2b859347dcc531062cae8efce2d6c2ed010ad6e1d79d2327bfe97bf2761c4c4125b80d21e5c06c7348f5488f20d55357c149c54be5939e748175c8e8953dd1d29beeeae1497815127e2789e007787cdd35a516321a5e21afafe60f22fbe89eb0f779653323eb28e1c9490c0a919c7319f4e6812a2457c080ecc3273f3aeae044bb5b23b7db94f88862f5ebbb8d936db8336aab9d6d508fe9082fc9176a020795a6751b7be38df30658b2f9af0b9c91b021f44e493e2686e1414199656a45d8ebed7fac33ca42b40846e4436bdc85109daf7a4aa9afc3256e3296dec76db09bd490d032a3c0c1606122a738337f6ab4c54813965306f1a8f94c18d1e4ff45d25423fb16be9854f3037ebc4364ac92288976c5de0e5983c19fc95466ae48a97f0350ddce94bb71c4fe16ec1b787433c95681a936df3fad59541f3288c805fb358d8d4ac2eeb366b5c70b9f0c0615144b6c4098e579d118f359c663c5c003cfd1d9494fbeaf2e2ae1a0d8f131be98b691d55e0ce70c7a30001c9b04aefbdfa5a5408e99253d362de52d666c76c8a9f0e8123e99bcdea1e7801e6457c3df0bac42afb65443c60ee1e87f90740d622aaf2527c4572f8bd8574c4af05296aa1b10dd8bc4dc8212ed1c8fefb001668559ce77b2f82a836a15a76c2793e7fba013095ff3c5c438e9d087199a9ed3c875bc3bc8e65a12aa69762edcb9038b60f0584642bda6a5b36442ca5181017c487eef1333febe166c0e12dda0d96f852a604551c24fe7af242a7444ea226d4a912e8bc6d862d2cf69279eb039b9c269e986af135977f0128fb5e4da185f24be6c5af30638aa2da9d096c7f273bcb13ce345bfde5dc37c1b45f73538b894e720ad92d71e930fdb5e119f657a5b9b923a17fd2f65697244c3aa63b8b2f4a7d025ce93160fe3155057b3b7fe1d2064d710b72a109f7a52681a9d60134f6b4019c5a37aa6662e920636bfa274eafb07cd027a67a043188e9d34847473c881d989e990fe908b8f3d57f42a2e889ff97249ce3eedb2e4df707bf9a408683185db0425c66c64ae012224349ca35743dd635e613241c41848a4b9814564bf596760b343b72437fe3c4b7e516ce89dbc7cb2c0017db18639e50f877178c8cf155d62919a5aaab2783c5f56a5e536b0207a24ddf44df563cd5eaf01a2b80721eb2cd9aca0e72b2bb119de0bcd63828bb5f1e2773c1ae84144c72813c4e7ff1ea982f7ccabf5e2f3abc69339575a9252b8950c9f2b822fe1cc26fd649995e21fc70b00e9fcacd4791a4ee4c5b4ece602cc72e7f8962b393868a29c198bd46f19c4f71831ee82899b84477a4cf4f1aed961886103a911e3fec1809c1c1b088e654e2b44260f8ebd36bfc2530afc176d0ef62c31e127c4a45ec32afce0f0e2d629bac810b2f582b5c84482945aacc8aa7c0ef51a756d3352184635c93300e2e0d3a64ce31b11d2c21778279b47316889b0549017328079eb14dc52eb722643db99eba586d5b85362b96894952eb35d449bff22b449cd1ab677e692d0d60d9bf0e4cce93ea96bb1a1a20227235f4f2c6bda0a7bdda132f0b8794e549d345a418a459887869fc558223107037fc37309ee22513e227c8f612ba69778168ec7913f7e3cd2c3806ab01cbce2a79cf351b65d60150a787e922d5bc0b70baddf45cc3703f5d693f97f74a923e7d7f9484e68d1f3c904249f0a303e799cd36aa8b2d1b44d24497404e67228018b90005a6d3d1613f0561532c665a14028553e0b6b71ed618ee519ca01fc5aa323c099288849710780338d74808746d801cf907f5b39f878d80f04f0b69e54d728796b4e443c2f599527ae6e9efe08a4c36ad8ad495c536de059471a7f549706c431cdca55685feb995ee177f642461d94dc42c247c6d8516a11248a0dc85b87c60380074582c029497561799cd86771d393cf68bba128ac84aafa879e538f68b7253f15a0733943e41e9a70e762089916f04dd13c8804b99e1153f5b662f889d5795cdbaa0a25df02f13a2e6bf3767e21ac9644587b0d52a29321fe841ad7b0fc4bc230b463efe39fdab5b8088a1ba5d87d1317f46014fefed94f839e665e4c3c6542f07431484a7682c40fb14f0506e0aa6eb399cf24effe2ad02463c4446c6fefe23dcc0b6b4a887faf893c2468f7046fbb64e143d6691ca33cf45c53bce142d8d913f14735e2a6414986692e4b3aa9a6f014d7555affd84c77c998c70c4b8298dfd1f35d091b9208973e06b1d278739f33c7b58b138db61003d2c183721ab20d771c99c7ce22cda6b49182cff10aa4f8add454b86d4b0b7f8b5cd971bb2cfc44dfca8f7f4ef60e1307e21aa4ee24d8f0463de5f41fb86cc71d8dd48d154b18e9d1541bc34b4561b9d15194a51536633830379a84cd27af422f00b32f9f5a7156c70689b755933847328d14d279461a50bbe1bc7e5ad39d199fe943b3f12b012510fdc81f99c1d43d961cbb138f747bc638d346bc5938172298b7a787b99751621ef8f7310e278472931d1d1eaea33b8197a27ffc8eab50698bfe9b2a5c2daca0178e1efe1bd89e1e79897615db6919d567ff23729c68edf0c6c3d86158c2f987553a1f8d9e62da0c8f046a0480cd8aa032abe442ea0569de998222d731b5fbae118d3a23e4407cc5dee1525e4ae61599337d4080ca076ac82329843cd59cbb3be62fb881e15da2775892b2330f708342d40c47918e684de90fd441b333e405ae75efe201895ef4306b013b731b8cb8cead76eab38d9a50e7e18d482da85755cfa3bb5a055134a2e9682ec5cdc045e81cd0b823521d02fd5e73005f4412969d5f81a803b2654daba0d117b2cf25ed514ac33f1b329abef332afa36cb43667197c346d49db667283d602fafab0070ee4e15b008f6530b3d64e036aae15e6f979c2fce9c316db0c5d638d35fb9f02dddf07ca93a333e71ee69567721c35672d4d718ccaa18ffe80ee65f48249ec95a6900f13e501c008a6713bb382f7c506cd64467a3ec748cc22c3f349f455a3b420077d64a49cc206d7862ecc9731a7d788b37e720231cd956f19d26d3b70661d2f593a790739f5d55dfec6170e1f0995f12b2750d1475a6b16f0905ebee7755df548e6f69acc730270befaf957eb36b1e127a69565f452eb45afaabdeba38d76e80ec851ad10fd08116bc7c189bbc924b94bb773f3449cff7f60d53131461b26219af01c4b6cf5eeeee012c9104234acd1e50a7288e1f8eed9958c36f017532bc63f649692ac6ec9e8303da449181ce343f0f99aa8504462170978a6c89711480c9dc407df4b075f878bad58e20f669ffe2f574ab6ebbd1b5e4491438da158477dafb8c6bd44cc828ae13d5b22cb4b181d0707616fc6367c12835a9408f3ce32d745c43b511ac3bbb8f89e11b64e661ef7dfb64ff162863f1ee2440a97d3c1570f7fe9161554587f061631544663a467cea9a90d3ee8ce97f3791d25e5cec3abdc66b3a2fc4a4ab3e1f6d3e0cda43d5f9d93e543f44c20c19b9b4fa27fe3c735392543206bdd589ee0ee4427f125d0688ef5b3bcb2fc14f2b8e9c420c1afed7e7f35d2d48bbe60a31607b50a873a1481e353e1e7febf2f4ab3e027817f74e8c5d0fe77e1d6c25991ece3a0f4d6cbf35faf657277c3355cb244e0e034dd604c5277b8ebca837114eacc86ad9188b6483877630ca7ed31d87f0cb7a15b357bd17a51e081af561c35cef4b48cd7119ac31eb920dde8e73670d3043b9ad72716fb6e70bd07e30b64ab6c9d99bcd3b2e1f7662f9903cf743050b6ab42891d2398b8ebf675608ee7cc1f8b908aed519ffeae1ad3a029d1e335f004d6787ff5da88472558722fb8ef05b4be4457bfbc7abcaa448ed925ea48ed72270b764511c9205b668be387aa7df56b25d708abaaebe6554618b2ff95a31687c98e98bb7aa5887ee8d56869d1c5c930d7ccd96c95620657a8b8a39bcf6bf1ae53f524d45f60cd3c44f66d760877ea04b94a8d11424deb28710b69cd4c487d2c0478723b0c24012aa69dbdb905717ee9a848bfd484d22cb178e8872ff99643ca6a56cc503c2e5af40e433cd276b5224f28f8ff74edb76fc66490c06ed1a31e18092ad912e4e2e8aafe9ee3b3138bc037a3bc3afe2a43a86c5a5f285426faf6c59b06ce27b4ca1efe318edc717da4ab80400ec3159ea092e637dce00e4701b2ab02a7775d9dda33edf871d2f4f97ebb0babcdaf84c0cd8cb56540aed0bd8a4f67763154c0e7198620b4c44a169275d73fd2fd83b4b079385d4734062795e888cd95f494019b7d7b620c0425e34b6e5a970053670aea532f742584f82f6bcdfba36eedf5c9b3a773ae19d2c5e2bc8929b22f8ac64070e83aa0b96d44d16bb401e176ad3f742a11538f382ee3cb147946ce8c9f804d414f547fc441a5c2111f1e81b3b4930cc0460ee24b1961f46c0baf46d09343948b67b61c59abde750db8966de235b0bfca2a17cc6b8e47bdae95f659636fba94ac0128a4ab9b1ab78386a2b78f1cce16909d1dc7cd1e0630e90e2ae4f0ccf0f140b8de58c536fe9c87bd6dbf49fa1e378295717e3e62c66febb8d3ae061a1a67a3829b8e41a88a06fa9658077294befb55afa90cf702a224697f1696eec2d79fb927a80140aa728386ef555188969dd1aec07d5fa5440b35687f80e7bf274a1de57f42624a9cd0b7e9dc78c8e5754606c411dc9aa9e1331e99fe6df2fccacf5d58a8d4df9afcf988a46657beff4da085f88ea534fa2e67f9242264de95cb6766ae07b23bbca75e6211012182eab7189d370e6c560e43d6be5d64e4ffcadfc0d815c1787a31a39575869da96fb2db0df7e411a158b6824c34f1c9e1416a0547cfa5607e8fc30faef4c75ccdb4581bd1fecb6600df93c383699f28e1d7b2f9d8a0645caa382fe9675975eda653cfb81754d98f28b8a6fc0a8faf11ceb1b4ab29ecbd8f0779f367d7bdd2d3732fed76fc1086301af7118c96e0b5a1c0ebe36bbdf9a65e4b47b2b8b6881e5ff8bc6f2f4c77856799b7cee81faa63712abbf3b4280459886c4da7a809f3d42da58ffed5a85ef1e4b69e84b6528f20b99c50567dda429551f9113ad565a1b07408d14ea637d45ac8cf90ca650a25701ae46fdc75d37416cca297432350c9efb1eab399449d29deddc9576c98826603279cc6fd4fbd78eb10c976013ac2ae32a7d43717e0d5fc2438de3be74f2687fbd8b95b96d8c2ac29a5f1eee0d8396ee4961b0e61a6d572ed119f8e9cc82aa4b38fd0efd6bac18a3f0ff323e73a8d093bb6a05ebf633abd9165deffaf9313e6efd43999f1a23b9bd5530cc4a96fdf7138f177d2b597f65d50b0385d7bff38fd7f27c413bdbe74b47229e0f546ef3b40b0e76a77cf5a6883978eea879646dfb0b55fca5d27a0985ef765a2eac8503f40f5ea6e4ebbcd8175ff5086361c449f3830b37f20a4a7596eaf1ad2a5bf8da31a8edf5e65ae0cb0857676a17e868cc14a406eef230b0c8b89bd0c287eb99a647ace3d69c983e626a2d9d270585b7608fd762e1047d59d1d3f85930a8e553b8294faf8f973b2ff452603ac920b1e22a881fa5904f804924396e1497c0ab35d98d4fc71a6931e12016772ddc8607301d04a93336552cc09fac7ff37d4bbc80464dc6edbaa4ec24209c5f55af4289bbbca8745ce151aa84643dbb5a78d4e6ac444ba9992d539da6cdbf9dec7ced4553ca954c9a8bf00eea140e50e5af81208de10ab5c9a0d9cc8ff57e412f31dce8f35c61c9fc07b8d674b78ea6006f17ad8d2ec030c75a95bccdaf050fd16f114fe85e42fbb83b5e0b0d46af4ecf74210d62d47ab1a6406fe39baef8cd80115879528f39aeeca316d0a2634e4befd35518caaa78896d57d7239616468186c0f4838695f02fc7dd2c932302cf9b88550a92e88ce6b834f4b9543e363438b9af20777953332da854eac9b71b23164a6c5abf84e9d35d9b49d4e614936fe1cfed101d0b41a2e30cbd866a7e1a3ef7526c15e43792ac8c959f1cd19c9fcd94da6e85dc1805f5209cb500ddb3c3832e4ea7cedae1cbd55af86a331b743ee7b89ce3cd3fb97e98b68ace63b767f7ceb0baaae6c17db56e01332239e5a5f455467d9ea5e3e9fcf8a2338a8d8130580509c48d54d1e5b4ababbac268188b9ca4026b33ead064efeb459c75c23a2fef3412f622c83101f68e1d854451260c5348e2c59c9e1146fd78d60ced756d4f4339a5854cea9c0258e0cda429e968d713970a77fe41a70175e69affc161d53a30f36eb41124cef29fbbbae3bbb50e4b2079845214ece1356efc01d291a6726f00a1de852f27c44e8146efe2cdb3e7cff2fdd6d3b2bb65b1282bbf147c9911ab3543b4aed7ecd257733143d58bb6e0bcd21ddbac34699fab063aab4666e0a77a0ab216c7430ec4ace61223a365e60cde9929dbb8a74f3f44d3ada292cd8d4c7ae82c72e8d088904c880fef751b33c59818005a6e3bd283d5a200456550af74d338366a77028d5a22d3cfe57ef57b1dc6a1c141d548d082154412495f9fe2de360e83fd0ce477cf6c3d49d39d4c343a62657ed06f75aa3f33c798c646caf38ba0b792cf51876852e40eb1f4afc54d716b2294f9d432d78a49fc4c408a74918e889fe2c50294c8d052c64201c0ae4e9b6dc2e343753a098ddde82fb89ded585d72013456f5eab962c0c5ccbabf61949413ef6f42802b0815b1fef4985ee882aea62db7b1a6c4a34c9ee45f1422d82feb5aae8d2c2c73c23a02018831b67bd192ba1565e486bf2125b904edee221b2ffb336f94cab8280aa5e8e550b79a89e6eb09f0f17f0113c8ba9eef48548b42ec12096e5dd6bacabaef2b4522ec3de17b50d1a26888cce979537636a351905ee91e9f98b4d10276a8b4aea0fa07694b27589624f38241bd29ca3239519e42f71005bfb41532c648b04c36e027323ce18e15b8d0cadbf38f2b0102918abd448e978ea8b10405369701713b5e2eac66bdd09ea092e6f842c78f4eede6b5f8e2eba8c1bc039eb9378790bf0c239cc06c5c1daf918d2d79cd4b5e4217073c3ccdefb8a245412cce8dec4d712eb54191cad1b00f5d77a4edee732d1a823c42b7050e140cc9adbe58c6d0222896e26e1c5453f8dbf7c631a0e77cfaad6d85096d5f77071818e8d7a7cdefd154f13f87d8c23696a7cd90a3fb4f24c41cff810098fa99485671e814fa2a01407a358f8aa4e692c13187b491f8b7808f9d15b9ec0832f250682b4c4d60afdf3a5ad82fe3ba7b1737eeeef1e035a0f07a329d0bb5934244a8a16fe4692d68b36d05eff71f884a235ca42b8df6e37ef7eef1d6c290d2833417cedf2f09103d08c50525f30bbae106182e73d8a9b2dbbcb985c76b4d787f7a045019f141354f98e50025055b68c52b4ea9516c678369e89ff33b90ef10f7bf2aa30cc584ec6d5bd5d7db12ab4bce81558dfac753284b2c1b988cd1b2b196d15f4868a933371ece3bbecffea26a47e5c954eea0c5ea0164e70ad7b8351a81dda17baef17278f1015d436fda75a398febb2ac456b90bde2bab0adbe0de68a1832d0b2b703cb8b793275c803325eeb442ba3cd58e361fe08d9202ab123cbda1da1017f690e16a0ef419a9d40d9d648d6b52dc2c7dc2f5cf0219552b05d5d8ecf345a975c9d6f2510d774deabea738f4b88ad5c877de7efff909011a1f8afb87c859b7605e4fdd96665183258bcb934ee657ce25230839a76b4ce6b278c71efeaa579d0b16a0362a2b9965316b313c111bff2e6b4be999bcab111c9d58427deae4500452a9cf0771523e6f1859bd65f356b468258d6786b3b85accefd41e17b235f93f64d28eb18ef1120057c5e1ca9464e6aec7cf35acc7e72deca18e90b3a4ecf61e152d276b65220a48fc82254c8b4fee156cb37747e4eed13d35ce8a916eb57ea4d486125592edd69d574fee3bb15e077fe0c80b160adf8f9c41e4090187cc7341e78054617a09893a3814be9cf8d4dc14b51ba5cceb16413641cc372801a2b6c68f7353236591485e10bea6a54617404602a488eebc549ba3037a3703ccf08f404c8a329e1c03d0d4f414047f7f5605b3cc6271345b22477225e71e256e6a58a297c15c141c115d0d78ff8285399c535c3e1775ab5a1b0926c29e0ff2ba1fca228bd6eb33c0565359b2302412c1e99c80b3902c121d953cfbb8a61638a0348c96df8f7554c5f668523d404298563d39a7e19e55d22c65c553271f985cec79b23a76215948187452907f6fe1b86c663fe9aae30e477b6e0609d0d1afebb7a4a00e1cc78a18837d97f6c3683118989b94b27db5d8b1604622b5f96700a262f40a983d0594d7afb07706a28b8dc3369d3594d9f219c7acbc241d2147bf4ec570d03268c1122f2aba780c7047b36bc1d714d7f242d11da041bca82897ed83b7d0eba948e31a3514607b3770922fc4bc23bd78d01f79764c5f9d85911bd924e0fb96f4229107560c695abe4de3169969e70aa921098e193cf3f3d292100c402f845a75da132fa13c9da047cade0009c82c5c03301b81b7da91a4b12a11feda35303c51a7d4b7945459f08f325afff85c71b98d996abd6e2ca5586416336445bb9a26a43e574f2582d4c05f1d3f3a42f0eaacc77c253e1db796d66c8c5d67b19a4dc981853ab78b330de239ba57e1d1fa0f14317929f762bd55fb08e3848f0bb87b270c218d6c6123886d782fb680939d8f20a5ed9c72e3027fdc36e41aaa1ebbb9d27e62ef8fed37112e8297508974311462ba8bd5e2bc1ce53e3a22f6388334a3e9151868974831e190d2630e90e8ea2732bb14577bd1518ff46e420c1987301598db9f93676e2c55da98644fc3f6e59bb056929d3f369893b22d30dde67f8717bf8f27acdfa054671b1e5d40f11d622128da4b7099af6895948c24acfa9214878d7d7d03b6cb6e346e803cb399f2464c419f51d5e804ccf0b9f42c06a2e08be8a4d839cc7e0ea6df59f3efc938d696e1a63549c024b1a01d974c02257f25b9b51c50d4586c42c5d4450819019925a00a74c9a93deb72c7378e982ea1dbb7421f45a3a157ac83de1117af165cd5e9c999236adf9a1673d12d707acf0c9604765326e21f5babce091b6b7dac48dace37193d9d128db59a4f84099350d358a2a335fe4d4e421e6ea76e97c47bf5fd3ed32a0d5bda8442202ea0a24103554a0a7d86c7e12a61fe6cac5b21d742882a1c79d214f878d9a32f7bfc49647cff5fcd80ff9b3589d58bd38a9e754c7b4147e8a7f0b98e587bdc24c22036e562666e5000bc4ed0fb77aa0808e9aa98f7dfc624978c8daf15257b9dccdcf17649b1c5868c161d0ea2e422b1d7093a6c0e311b4309e8d65db1cf17357592947eb16fa7dbd51f806561d26bab6c1c9436d765816d0f79fa1855c3243c2a47efc257729b6ee42d996fb336aa51bc58dd621ac93e600f097188029aa8fe2e2710ed03f06a7e54ace5899d1254049ad03ecce693b1b4a6c4317b32cde4eae325d66b0d85d027e22bcc8e2b3e9af424a4a134dc55fa20a193e1323f939123c14368243428ce68faa8d6b10307ae7b26d857f77c8706c084e56417ba6adb3700211273495f5a693708997ce1a13210ac836c887c808cd0d83856872e2775561bc77a4cf6625058c17e6ce0e7ba80c39f7873f6ac0c7bd0f7c7c2a3a508089d999f21f527de7282a03762604c1c5078158d7315e22246d4255be9fe60cc592473c1e2d17fb021262716e71913b0740c6b456b1a7bbac9d79fe882a997eb5c6c07d729981138ac8052b1fb8c3cfd01824209285d3404c09710cb49a78e87a07f17b8a6acb502be9001d1ad087f9394ccc06681b1645b63867252f230557e65e40b2ad97950680734f6aed036a25aa98991ffe3c84e632d88edae48406b9970990db69aaf628edd8aa91bbcd720397197773c05cb0b55c1098d75c0aa71035c1895398eff12bc5b3f33da2fc71167e5f30a5104e0de4fde4763098561437d85613f56e41b7c0dd93010c2970eaff61955393cd41dff2f0f1dd387e68b567f831ea496160dd271746bf793f1eadff5dd32d250584cf2971149ed1d19e95a50e3521efccac18fbb2a16600952ed647fec8bb03d32042dcb71d508d89ef78c1d597eee34745bdfc6a0c8e7a9fa8a8c0f7379a13f72b6a7fd0245a88d6585310a995d7fd19dff529707cecde400586ce2c460b5cb28b21b2cf841a249bc22c9795fc1320f7ee126b0ef068ad7f7a0f20866307661c8d2bea9337da33fe80970e8533dd201e34efab909a89a150959cab45422aaf7eddf388629984904aef5b934272c3b6c5f5f4fb98b76241c5d70bdd162449ed42c5d5df159e6d9e6d1f16067b8fc7ea1955bc30579dab7dc5045e4868cb1b1a1b991b791e16192a0285a85bd8699409139dd06711032f32dfb9128e68123b704b3c3dd559877b9661d94cb6bbfeb57fd4105d793c1a35cf493602e9f7a5634faee35ce0a3fb6a7e42b9cfe8a1049e9f4450f514c0321cd27bc661541c68a2982be83b2859d1a1fd34ddfb6c7cac681d151873398c78e820c2f167ebfe0fb8524b9199a8fb68d96e6e3e289c02bbe127df55bf27b82760e16a76a2c386036016a696fb86b3cf47f97193cbaf13631fb5f90e2a943d8dce025d4a5de11b9f7d71930af12a474f7bd032b3aab5352ac11863c185fc40f3228bdd00da2aa962e00e15e910a8c867f73ad882b4c983a6cbfb29657faf36eef2731fd9538378ea7dd8ae78164841d36cf509065de8c80505ee6845a0d3ee16141b5c5d6b18cfb4b1215385d2df0fb56bfb5446a2d8b341a60be9bec4c0884d70eba4ffad42bb6fbda7ee57c639e08755dab6532fece2e0d74e7f53d81869e25cb5aa9dd7a45c598f04f2fdf2cde0293594cb635abcf0f909255c6ceb96d4df4ead3d73760fd139bbe834c1a08af0291504a3aa477cf43224c301c9a671899801cec948a984620e8893a8a27b272b238a8160db6c270dbe0f70e13006f0c2704b0a641b069d79514e7a167927cf55e1a80f1b472f397e6c971ac7792d7df157c4351ac6dfd0347a55bea6cc959ce2e2b8158d33a353c1faaab628caf6d8287a062863a16013a64577756509b954661cb0f52045cda484a837a781e51c2eef795804556ebd287edd0d68fdc0c10af449196e9651c201ffc9106a0fd54912f59254a40750543f4de11d4ad777c28ef173582836a342bf96cfc5dd104d362fa66cfa082c6a8229989c97bfb96720d6088cb38e5419eb6e95f6a301c26f063e3bb5b93ed775ab9b91ec82404ac901608294cfd85b0af46aab37ceab521f3629ca4768ee9050e08fd236acb1b302b03d2be2acee0a89ab67fd748c4d5d60179533f7a89aa2559ecb83d75b55b8f45026e39024e5c44afee47124f34f240acf5f17899766ed8c21fce27f9ca4b9d7acd9d0635c38886929df2084fb109cce1e8b6ebd319d900a89619bd681f9868e0ac4cf8106ee8780ad51453b4ae9f6a1a31e19fb13fdd4d380c46d40594e97b0860adb58b84243c4dd3c45f3e375a2541c044dd71ce954d4154fe09fa0954e35625eb1eea0548e3f647eb995ee15d5a3b007ea484dd31e8b128184b11c210cd2cd223740f22716c7442f4ef37fff0d826fbe7e28ba7892a3fb160ebe8a3a5c5b531d1cf26fbc6baa3f71151fe4c24720a141b6769e9b47f0029e7bc652bc1ba6decdf787d8c883f018c008fb3318028cb5e9b19c6a439a2908314d95c5ef56928ba38e5117e40c9b2244166d9b128595c67fe6c61410e5c53538111295e19fc264bbad0c0518bd00f1d1b34f1c3fb2110bbaa1eec7e62809b66d50ff3d78cdb512a5d3d5e2596cca85c3c9427a571cc72b86a84349238583a19df398f0bc2bf959cab4c3f933ffff839131e78f3f05bdb9007974c9002dda83ef882f04e4ccc0daa78bd1d76df7a66400a874138646cae36dc8c96a9ab2fad1bf6504cd79fb4242229e8da2fe9e0e3e5cf842e2d4553e3a0624392dff0ff21553987d937d1681df3df8e2d931a40e7cde0fecf833fff79322613d01ad6ee932797f9399d1d61d8dd27534cf9495b1fd040086791f0d4845eb6c42d2c0cad5b50dea397b549cff75ad5a1a23f0238a337bf34abac0f60078fb48e5e303759cc81c666dd54c097f2b04ef86dc75074afbf196fc48fa8e96a7c1175c5291275d18e8c0bd3717f74b289d3c3e175876526c17c713e31a81f95e992875be3ac3accb3a24b31bf5367cdb8a33baac326f27cfcc93bd3e4babbb04e9b84a93d75a90e9809fb2a597f4fe754a2644c34ed2045b795491fb08ec46566717de7e97f029186a9fb0f267153d449d86115b8211226550b756fc9bf96bdc8efcc075e83942fcf9ce23802b9efa09cda4e1b1fc63b385010e73d6d22b974a4873bcd76d1a6be1e8a440e29740a48aef577a748c17441a232e037c61cc7c7e1d9b141108da2617d25512b7c57c57e2889f42ab7cc490e96395e6f6067934c7b32d435d0787ff6b87984b0513b74e108e2d68bb70769bdc85e3732d6419e354de88e3558bc5bba075b4974a205b20660e2ebb2887b64eff991e993785866b4d4678eadd4f7ba81e59e30be5d1329a1011f74453d1bc812dae54a4081f483853a0bcf59ea134605dba6bed395a9ec93a82e572261a7d966633a46e1ca1fa102bb2c3471927213d96f6844ae091c297deceffdcf20817daf3bc95e958e83894323b8f679f5b798dfa30c1d4dbf9c21afc29bb1aecea61d6470c170b7fbdfbe1a48072b2ea8e4edd968854d332e37a36cf9952336bcae411be386b03fdeb5b7b76cb0a4bf7e365b9b4333518120741d51ace6589676ad1d92bb97e1f3faa6dbe222701ed4c2dc8c3a0c91e9c4de54d4af7de78197f4d3ed7b4f06fb188016df14a7a024322ddeeb16b44808b0018e887560d509497b9bad8a359047612a3e010e351e343019618e1b19f1aa277e3cef7b54af729b8f280b2c04484f0c332d74436523c6950f2ee9af6aaccbeeb8c6a7601bf25853b503fc67b8bb472a4bbaf2facba31b1bf2af079cd7288020695b815da9be469d404e7f52d5733aafe5361d822fd3322bb31537923b724759488c77a0762595a3c70efbf3968a7963d5fe37f2b375a089fdcc27adcea61f42306bf43ed5c77aa14457a9f9e0869a4ddad48febf0d9e8472e576266f96d28383e6240d6c26ef5597175371d39d84075e200010467b97c0775c23e147d72f35aa785b19b87966d16c37a7550797cf19084d6d3ca8e9aba53f6c192211ba23eb10925397f2445003a1a8dfddb48aa90091ed9e835ba61da81e0f3a9ef5778032eec5791468fd047f5daa485751342b122a92e1a580139242cfff33e49073b2a0303bde62102dc52a3fdee07c9ba2f861c80d04c916c5d7ce41c2d3a487a1c829503e68b3cf15b42bbb1b6767882f742855ddb01f05e98d31ba513fa303a3c7a0f80fde562f8c4117b5e8e82a002516ebbd074c4f52b44f2571c75f004eab11447ab0b3397f33d434956314220d8bacdd00fda1b07f57d9075873aba0d7973be9aeed16a528b7edff717318b4f254d182ec7ba40763c2e923259a1207efbf4bf859a28d4f2371ad833ae6d04f62b77f260459702e94590f235a067de01c2331ee9c2bf715cf67432351b56d774f3c80d34110b0a0a69c32affe14f757dc7a7c59c2688aeaa3abd9146555156097306df492e7eb299991a1a98ba9b76aee232e815ef2ae395e6e95b6e2e8f03a9452fe7cf246d9a9b9bb57a51efb5de5f8662e1243678e25181d73904a38720732718a0fa7bbf94f1ccc739b294448fd5be9de8e4eb6c5b32dadfc04b4c09dec7513ecb0f138060d7e54c19c09d73ba26c09999ebd9b2fb6634a8d51de10d309a6ab2582e3aaded587d780899c18e23ee963793d9fa971f722bb4149543dff6babd2c5b87239f9611e97593d46785dc51fd4a2af94a656d4c658038179acf94670b45fd1a9473d043b281cacdf15821bc7cb5a45a91ba263db4b986b9ce66e889888dbe5377c27533fcb92a80259a19a8ce230e61d1fc654744ec409362cf6f980ce97b23a5055c2f561c5dc7dc65a49d9a6332884af210e0738207f31b7481d92e26fcc647190356270679a9151e3e62993e71722acf0ffce2b386210b1056706b0d08dc5609662f229d5034e4cfdf6909f06e021ffbc1e3d54ee99ae63d61fb0d0513830e9dfb9442a51c8f909ab220f6bd7fdef39d3fe7b435a01f78e27d2846fbb6489ae6931cddc4220f469465c554e545b123159d3707f91c12ee59b6154ea395204f6458ce201a89478e3e166920f85c056eff53dbc0c41ac606b433cef508a661089e064a16e109360665187bccf50dd2b18b62c1bd308777696cf76d8c2419d16337d4a0f66c11926d8faa948baf07cd807175694bf1cb3dc05b73529cae54bc501644c0db710a076834ad1b061bf42c1cdce89c2223dfa09f3316529db6b3b32001324d188d8084b7ed29411623b900cecf0ed14de040cc9c97e6a8d74f0638a299ecfe4580931b8982b21c0a3a53333396ce49e508ece6fdc0d04ffd83658d1bf7330a1886eecc314b43e3d1bb2215355a43df35cf89e2e4ac0de3134c39449d6fcf2d785e5497aa5621fc21a170f22d941ab238c2752ec6e7c9c3ad675bfbda868a7e09e481496ceb01a92941e65182bd665cd6540e344e4cae856547085808a841db8b7fe998c5ac456f38e1b7e7261f0e2a7e52c35862f184c367d566c4534a2292f968f39439a47008993e8f78a165933f77cb42b731a5681375b812fb85adad5eced2780ad81a894cc17bb0ac2946bfe00e9fa6d43d0982d69cd265686a73a3e2cdca0c7baf9370745d37b5141abde1cfe8c8f3f23fd2b304f54633fa3fe2463fc9df27bc8bce62e5e2fbb95a89d8e5153874633f3e206c9914c0f34c8095b7c52ce1c72e24525cb2c6247671edc7acbbef15a0bf3d673ec60ff8911a998fcd0bf240a0efc7ba6f3167c3afff3fc38ef1899e8842859b0b1b3c07bb1f5e579ccc014083813864fb0bc51ac3f527f9d2169bc5d5d3659e4d50db414256f3eb36c07efcb626fb47fd2c4a98c0133c796ccb76520c7d050dd4c06daae5f604de25f7ae48a86644c5e61097fb326ad1bcbdff9b5fc5f0a1b802dbe214116ccc39456e8902eed8bcb923d24952cb02248d79da42d54ac46fc7ed18ec11e6e2f8581f5fa1cd37690fa1d7f79d6e7c87c84f843149ae364332ebad22cd422234abc48ca8e9d52319348c8bb1c96c7ee97c93de4b2f1638bed5e82173956cc77ee994a74e1c79fc2e24d5901bd3c4c5f1a7590442f449410f1063185f53bb0938ad8b365bebfdb9f71534094fa8d505478c299f6b7c4d6b47c0f89ff2af98c63b3d66b3ebfd4f14d67a93ac124a511168b1f2f4a8b21397e702d219a1b98ce83208b97b4589e12541de9d2c4124fe8b1a0e534c7e2f41a7fac9b9501e46166576cb58ca230fdc7243346433b0bb6b0da888bd50cb307578e2e45e052baa3845f9e2780297747147551bace9366b47a0bc705760b9ea62a6feefc7b1994dd55ff84d79b36d1dcd71d4be6e81f493f9e3c49292e329c6a0940e93535194ffcce3cd5d12ac915621aeb7b21e00fe4b7da935e501d3bde5bbfe5f258eb3e2506bec7df130a716ef2efc80c1050a41c3a5930499d0b82a0c3c931e6b64c3ff72cfe7ea6b7a3eef03ab4df09b07ebc3760386b14f7ad493834f71ede134a62d1483230469c71f38be8372271d37c65f29aa8cee2455d175c20655b85553ce331c7ed489451accb4de3753363c2ef357010d4fd18b6f621f8f5ad2d963b9b0f6c3ce8482002bacc4fdc83661a309c0a6b9350b7f32c05b05b83d8c7b4f9bac7294be03ef43d11d6fdd4a964eeec58638382b078e74c330ae06c33f5e71fdac74f62b81d0a9f933ebf552f5d069d38ad1e842f1804db8941349a9d6a9edde0df1f231f4b9adc95e5eb70eb68c52f0d796f73d18c86825effc7a91dac71c67fa98abb667260e51ec36bdf597abb849096d39c62bd8c00c6fd09c88a7b7cbe2cf3700cbf86b02bdfcf3ee58858951891d267993fc5e937845de7db21c95eb68cbebaf34e0ebdd94bd7e545b1621458dee01302dab934e119c17c8fbd904e64c8116a657a8a40767c6349591d25b1155b8c124c8f6d21fdb534c58487a7a150d18e4da051d542ef8d7b2335db7bf0e110239c6574c60b6e4772162448ee8a9a26e1eee2cf0a9fc00080d47c6c5bdc342f7564ca18b38e1b13c6c2a6dacf2350c1a9e60e6060f105ffd2e1329ace8412408e87a4df439d2808e0bd61004cf384a8685b9b6f51b7deab5fb3808efc3432b1bad9f2118f2e99736833b080ffda06de9a1bbcdb3aa929706a920efb329044cdd7a02b395a42dfada79923581dc7929bcdfedf147b65377da7ab027b9ca04106b8f3698455c9900c8792323fe95295ce44eed4ac378d1813de6e2cf8ae68b0a1aba903ac28a87bd8789c666a30daaf740d677ae5d38d4b846f1b39ee5d413a7847c220f0f6f9d83fc267d52080574bcf930df469bc1ddfc606fab627d0cab333365fe266747ac37a56e33174eeac2a3d66b83c49b541a1abab6d0d8a700a4b25218f838ee5e688e9d8a6d06d7f01c0d00e432c484e134ff639129ddd28be32a8a62e11c40abac0f0d55ca8b6ba9b97e878db43c621924e113af9d3a0df5897bdd2a55af754e1b4443755919dd4c652e99ab40b4a19f347b148423987aaffeb295ae837efaa7a9728dbc658a2b385af27e54df50d9642a1abf5c3bc759b48d0c4c82224f97af582aa5e3def077dbdc0c45d0df7733033bdb266f1e840b45d261185264f1177deda244b3147cb96ca1efb9de61f3e9cf3aa560127f0408d420d624e3dd4c81dc8dedc1e69551eee6b0681b81cecaddbf1a4a2aa6f6a759a11e5254d3f23735bd2e75e27fc3d3c3bc50414e48ef1d39b7703369ba3ac411c3a1f434bfdfeaa8480f4bfc2a30ca76757319403172cb5450a3042db3fd5ebae57f306c100fffe2d55531603ec43d0271da7b989b2a305138e4c8743e62173ca8e5ba2aaab351321de16338559b675e17b7337a1c864b5daf4a85adf726df66dcba34a1e5981e8bb48ad7a9a79dd65c50ab97883b3d4e799341d9c3865ccfea472202b372bcc992a1958d2b7b88e3bb473ec12430bae91b83123f493b805e093704c0319ac89b1e0f949d1aab93a65863bddc003593ddfb40a8032a437a543998667e80ea86e271d6deaefbe4941462519cb2d5252f2e33bed8307766850602b6b2980668d571e77c8d75ae5239384e1cbfa59a20377e39735474baf073054f3f71142fcecf6dc31669a049bba450ca548b4e599c358ca9ec11b08aef3a8b8e6e65d754c04cef8fab42b93450742822d0facb3f3b52dfce8ad01e8d0ecf6de7cc5ca3d75f8ab9b4c07aee44c50e6be0788e64ce9101d1f7c8a60fd8bc9b2696c9fba15e754ae41d5b8b33a5e7f910097116fe9d7db706d99b350448c7246a96fba86094ab19ca93be7b70ba32a0c8becbd99cf088476a45af4b87e1240f2be24bf0431b57fdac51e78499f4f0b4e1ccd89578112ebb4d66501c6ed1e1e57e731bdba43e56ffc0a531d48931a574e00ed634a11a49f3bfa6f0432c3aa190edcf63dd071d4799e1f5bd1de1fa3bd6698521c059950a284f1d6e2cefd297028f1e0d2c10d87dc5ea619a0a549b4a74208dd938f0dff242587462477ef6b75dbf667638665c377713f9fee2f6dc79f857b3b01a4c1f53dc3f8edd830eae8b92c69126caccd11b941b06cb160255791a4cebc6549f132fd56b5a4fc98acb826e440c27bf6612fbcad91dbfa41e2afe2309b3bc8fdccff116e35416a45495da54ee078d6acdd7b084d69ce87cebb4a8664d97bef8c89a960aec61a392a6aafedf308b0530dbff45da953a2ee14e2a9ae3ab5097d4b26f9b47eddfe05d54778ea5ce86b00016219233ac1145e2b83d8d3143a9599f29ce17f580f448c940b8bc555d9d77b620201b0cd3d61cea318e1dc9ed3a588e9a5de5ec81c03a46003f940c470697d450786e33410bc47ae3b608ecff5713fea1141d4f2bd58f84489d31e032fb8ace803a13f737c31570e3816d1d438e168e05745e6cac8fc05ced8e2e9601ed1c50e1c1d911d3658fcee9e703887ddc44d47c9222946aee18e19872c7ef8dd5ebc519c4e6e142fa64f69c545d59f07b040434ace1cdc924992ab53cf9565223a2a8e921c522b8a42fa64f9c245f8461bd27ce206c85b6b697a3a5d1317aad935a93b369b82f205befa0ded9242fa351523fc3335e47b609bc5dfdfe725be297829d4ef5de34cca75903227344916af5732a1642546f8501431bed4e0cdb2010a3408575609973e9294603d065b13f87bc90b5cfad37a03851e2fbe43e4e5a17a88bb0c021bc4e8aa11345cb3fa780eb709276a6d10e0a854601bc90ed1f4daa5e6cb443f6205c6e12e6d2009b7f8c21410e7d075950b80c0c7501f17b51332bc9f7db119347c110296c76bc2d01e9414c4ef18b7a98a1ebeb2777d83abdacc0149b016b5eed7747ef6728fc15360fb509bd86f017ccb0f43fa00ce2b12eaabbffb2272e8301d8ccf612c7cf27f96c560af7807d3c46157bf7c72e1682b7b03acfd7951223f1639c3217332a5fedc79aa0d8fad30d460815a3bf63fafbaeef3db20606026db108754f83891463972555042173f55f824282946e274cbbcf46c8a3b92b5c9a5b13b068770126debb77055f6053a81cdbce1c149d636de18c1762dbf82df259e9a624f62fd2c73797c2c12e0134b348711f82ff76595bcef3b8c93e71812a1e9fa4ce4dff769c1a3d90f0acfbc2c1f871841cdb3d19c8d581b8da044758e44770b7aeffb2bc8dc68c5deefc5886e8373ce79d1a73e5b643117d8aacae53d9bc3242bd6ae91ea5c2e8e3c7d15ac23a36fa915cf457caa7e9768990b3d9e87d158cdb70ec0209785f6f476679be6073e547f3b1e7f83e700ff2c1e492499e4fc9ba79a8a7071a7f4c5252dd7f04eb228460635abdcb5c136eb1251b7137c838feaffc14a2ea0deb649db741a060d3ed503b1e15618c801fc56a9310ab4d436664d075fe3e430bc9b316fa57281f9650f8bb69998091c30736d1faef3d3ae40d397456a04388e3e6dd368e5e9aee527c28ebbfbb75af9e4c818a1266715dc8670be22916fccad57f529c45277506c7971129f82682244f161f2596c93b6b48675fd86939f07f68b6a5db6fe7fce83095925173b7f1639ab49af4307dffad53b02dcf7da66977a769617d841857b6fc5f2a0503f2570af342b77f9ca526ec11a110278ed54bea46ad53c97d375866d1060645ffc62a18202a978fdd188596a6c76441d73ec005d13d5df452d161b48a334b721ce089bb05202da09445917c85016ef100e61a0695e57b3bb5b316afc15ce3c4fe52295ef279736ac3aeb299b7b11e3cad7876df8761251d5a1462b130e7f5e12ce44ce85d67d593a73916f8043eb4d521a762e1efad3950003c06577804a3407171c53c029e216a6ed54e9629ac0fda6ef4db9aa740dffd58ddfae52e99efbd1c9d4f254c3c6d87dab186b00d460e1ad4bd808f0d93aff58ed72360457a8a77f9186e67c79159e13f03d39a41853f8a218887d3ec6e2b0eabd32146e06e17de37193c6991b15478b3990a406832d190cffffc366587158aa10fb58871f5ea1a188e4b8f0393ffec84474ff44a0e19119c8cd6584b0d1367f2e783fb11d48eb286c189276dff35221af1d16ffb169e6bb6471e1d70415747e384978f4f6899318a4d7815abc36303184a94ecd6afa11ba2608e8a918a58b6feada28224569e5f4408e4f3e91b6a74746df28121950fe4db2b580cfa06b9b06d0b1b6b4a38a2cdd37036edf1121d7a892e240fb0aa05e5c4136c916403e30da1e2e7b9582671df6b4106cbbf937afa01efdc1ca0df4318b999ede839c8889600fc10c71fe68c783c3dc1a0bb8b6b854152f36cdd2359107489e70477c8dc7c86e28c5288da9ec36e900f89bccde0747c64b3ddc138d9e6cc1f3dc9980ff6cace3a718efa3949cd204cf488d433820b17fd858f9b7e7e02b3e7084586dfa9b0b275e4880fbbca819205de19ef0e5dd91179ab3766983e396b817db94d7c005e2da89ae2979c08172961936a2c412bd42efc929354adaf1213ef5d0924ff967f2f1218fec3dbd57ed8f86039cd535d1b1d979eb4a145fd14057eab58510b75b00b2edf03d3a0d1829b87376d1b60a257a9c686f5cc5037f90a7509aa3ed92a9f224d2937c168133df31478252eaa84dec9b2f5884d6fb4c7eb3900e663436a958a196ec6704afb382c6d541cc844815302c9852b8f98a3edfac0af60aa14096198caa65e8429dd8f927d3cf41ac264122e5a0f9d751c045def484dad658a3429af847bd10ffd8b90eafb722f55a94cc3aff03110012db7009941a1a58fbd914bc253bbd5b37dbeaea6f816f90cae854f9ae66ac64d94df78bb4525d9b0246a90d07f6369a6f14374b853607f62066fe13fb13f0a8ef86693d719f5abf514606bbc8493b536e862e5329a2a1020fb59ea8842693649ae8980ebd12b8717f87611139424bc4e0a5f5a26cf39d2fe54a5a7568529069bd2e116a9481d6cc3c8ea01854ad7265f598144cea350d1af6e22128403dbe63f462219f02acf186ee0efaa1c9b7e8bffad78998f210441c69e149da991589e1cef27490c2f1d9c8f2a3893875f5bb8db12791a4e3bd1299e01c19f744ff57daa7d0adaee4e8018beda69043cc6bf8c90934b0a68a22e1a25014115ce6f8fa2d9a5d384fdc76909aa4616b4da52534d80a38cadf9e6ea0bd949099b27d0dd0a0dc9ba917fef688b4a79148b310c9e5a4cc984503f033d3c63607b7b8d3a84ef9483005469eaf2f05b44f6e4af6964ec00511b407b828bfb6f1e7dfddc340351657204eccec3949efddc4c1473518e695a8278ae4cddc2396a4eba7280143a626e22b54cad066574b1710a481b2133f7a46dc1312851c10a03d2937516276026db72128b808eecd149ca163010054d3d58594ef1415a75b9d2c506d74e7605782e56e50517d81f3aaa75b8e7ba15abc9596d5e8da314c87d2ae55043b20aaf765c78669df6df4132fe7126a8eea4a85f8cf6be798cac50218618c46b34ba3e015c9e237a1cdb8aec88f09d6324440415f04a50fbef55065f8174889dd4fe9f17d3a3eeb6764bf0d75a2c74fafc4d6a68d5754df54ce634c35a621699a9e2e3f51c6f6dee73eb6fc4062d55a376d356f40de78ac707bcd064dbcdbccdf5b9f3e304d8d5051d95c0a294584b1a990ca05e29bfe368847ed3e4294d59244dfffd8aba8b41004d097537bebf7df0785fda42c2c52107c4aea94571ece40741bdd3c7f145963ac0ef8643e32f08ddd24921fefbc33202a7231aa4259054ed2c2c5ed6f4da2d4e53470c84e9771e14926220d4bf07dab2e616e6d60bf74e08a124a526d212ed4a979f006b4038e3dbf30698212991609e0ce81a3860b3920e25bba9e82aae94d39e0ed00066b3de2431432b0d31db8c86703cebde32af99089d692db0d39de02d428c32c01602148caff7d8e8943141cb5f61523daa5b41c53d8ce50c2a9fcba29d2db7b4caa93d2b31da6b5450030ae0dda46e124b23ebe7a429d3de881b2cfeb93877682d8a0d6a1dd7dd33954cc1252c9cb4ed07fbbccee9df71acc2fb3cd01ca8f46c38a1d87b7d9791d657b284bf4c423557e6af788cc288f61811c1c3fa68c6435ce5bc6fa8173b966c7fff95b596e1932c9d1640ca447cbb1c4748c97657632f307acc653727a2c17872009b9b5ad43ea4ba3b43a8f2176769a5d1472b739f9c88944d49e07dd204f2f7b3099a33b9c44ecb74a15bb19f7e2ffb9f7cd6156cb9452d428bb85b420d6d670d5088d75bc8863f4bfafae03c47653cf39d6443a1976d5e29fdae2205e253decd539731e391b43022aae3a727713ba2cfdbc6f4b84c716b2a18f7663591a0ab5c41306283faf4f59466a108fd52039b67f155eba317381d300f65d9c478123c887012697abec6c6c16df6d4534ef713db6a14308b9802ffaddea9564be3f2d0893a608dc97c8d0f208b418f78035f6ece2d37bb6ad9387aaf8b2d9d9041424b354a8437969935f9a84344c03360ead294721d1d4aa75f5d237f5acec9bed1397da2d06f7f4fa27b07999164c36c11710d0bb681cee8e72aaa7660496aa2b35bc19013034b06d0804a711647f2a41f3ad449c853d71b28ac6bedb746f75ef24e3121195c881961ed972098dfd41bd076d0ec5e36a1ed679e8bbe4ccef5579d191f51c29b2c126e5c52681eacba49a3402f74cff88cd413119886d87f54cde4c75735fd3258d75f8258d9405c0f96e2aab51b2adc212206386fb3c3a3efdd58e37dfad48cef81ea7d9a286cf4d82dfe6751585b68c000c2b0cd843285e480722557c8928e10f13a769ec6179b3731095b98fa202794b11a7c3da17c874902b7207c18a8b0dde54305b7cad53b410a48196516f143c8cebab19ffdd79d623d1664032e30974493606329021662ac2a013aa8f69009e42640974eede9038342641c4dc571472dbe0eee3f92ce9ce3b2e299c6cad6b4474ac9eb33c026a2939886e54b0b962b6e4ab2c4b74a7b3d267fc92868956121499d24d7cd9b797076771b9048b0ce2d0a84ce78af82592e0b7d55fc573e9a70696575e1b9a4adee562832dddda7430c817cac5650c93ba49181ed5893cffd87270479d787c09fd7803a1a172bad363034f28cfaf6ec18efbd430751e113c5806f9ed193ba30d3bea15fb3eea0cfd4caabc5bfd9b24083bf402ee39fb98f22cfe015c33c0e92dc417fbb773218fe423ab527aad69d473c021a6e31120b1b56edb88da9a09e1a9d24e49af4295e62341e1dd299b0bb389402821b6f3e1cae63d3b031bd22349ba4266899161a4e2eb0d5057add506d918ff2b9f8f9a4be502bfbec7e8ceff0086132e9c6a1ce0d7428a8b25188052d8b8a3ab7cb993715e6c46b0c3fbc9ca0cf5659f409db206e0a09cb34beb02ee72e19662a70031760c055d78cfc348e958de147b341262e9f0f4b02fa77cd40ee7d198b40dfc5c69fb3d3caf7ee0e7e600b9416a1070db275924180697b293a4477e7b4fc9fce03b5092f3043262233cdb4a98273d2af6d10adb2a83be8b446d57e8b749666410e8c403fc147c07a0c7a1cfe8879ded184c66147b0f40691cec76722b53ba45d58eacce84bf53b5dab4865f2aff2d0b4a390c75d444a5d7e1c7a27eaa4bdc953803b880f0ed8bf38746b30c44575edbc1ab4a89d617c68b0f6130b26ef694c973c639bd7fd36b542d9edb2d4069dab057528c6c9be8511cf7c2d8d1b25f4cbc998a16a10b5c866d9dc3b771f60b3e1ff4baf02a81a6e36d4a9f214e12ccf56f2d00d670804f454743f94b9f8e374c1c50c73438cfb3644523b750d7a536261274dd086a7d539aa89d35b5cbdc27965bfbd50689685c5245ca1de4dcea65144ebc6a474e5b218c2211a026d34f6056567eb52d2fde7d26a4ef3a1f70562f824f3dd11492caac71bd0e3f74397915247f5eebb8e2153bf93f9a435c1b88ce747e318c3bbacbb8279a793e5a9666b04faf149771777a57cb471edf3ee805f3362c2b5f054af8f57e3c69b933d97b715c9be72aa641b5e00726d8c91b1662218fc185340a1cfb13ff69aa73d3187df56e9b2279832a465ad212d2e75bdf3f10207f5b8909d4f5d37fe8a93304d9c5b2755480642b51ba6d4f95dd61aaedeedf245ccb63424c3d9b48c144cf3f98be5e64cb128704508c187cfd0680942f0ee84dafb420e1e0cfb3717f84b195fb85f337d57d768268061545ba20d5de0ba7ebc3c64fb843790510028bc8baa55073e855a08a318c54d94b463066bac476f58559eaf5adb7d184db4c4621d14159707cf82c8b12cbdc30617c6c6071f7a831dc5c20348d8f9bbdd812d06bf06af89fb50758e34fcdc153e15471fb39229342d17ced3572dd7571ff4df7809899fcc61f7c28b42753d29c20961cc522fe35f35948c1d5f972c4bf6594a011f2524ca448e01e537122f6f10a0da491f89cd874d1981384b6a6fe7af4f513dc0252ee46bd2871d3f8668105017f541f13455b73231182d480aac3d78a83c343e3c1986c18b3cf542a080a14210e3605eae3b217f0614e4072166a085f9b0e2413f64b6e8f7ab3025e9319fc7966a0c7daf6981848c38372088474e93d739ab0f5ad172499bd9fc187bb06d26e6280c84d1731022befb37028cb152d95018daf1bf3adf5d3fc29bfc9481a8417139bf497d7d7a3bfb29e39f7076ee90943d0158453ad939ca083efc586c8c6b09ab3f5a71e8c1356bce2d24bbf30d4b0f7769dd0c89d196d857a137da829b4863e3ca9b26f15776102da2ef923be2da768d79476dd49172be90051a03d5c72e347d9aa2e5a48ec2d35d44b72667b28ff990caf8021230d1ecfa091baf4efd06723772e4191ff84a120ef2fc3dbeda54d29db4446e5f5e9b2a67e3564e0aca89eca550422e7a498e52b190ea10a88e9aa2562b7e2e26d0dcfa5657a6ea3480b1cc267ff8d7918cdd8508a8a6278e65260b06509ddb7a3a3d06f92fc66974e42d2e84b6f41b1ece443fc0313748a7e0d91772e2ab45308cc93c891b3000852011fb8635cd0fb576499ee620c526e2b5c9ee2274a24700ffdd2dd3d5fa1acef3a4765dcb93c5f02aff14f01ab3c446bfd4ae270783a5bc1f8dc98eaec6cb9d8181f14a8883077419a75759f745baf163fd20687f932c0022e1e2f896048a122d4adb039aea308d5f2eab03b262ad849d19d6a38ecfb31e15ec3467a18912e0aaee403e4799ba7b9e2e897e03183d6c3cc0b8d44fa20a80270366763f4681910207ffbdd3d6f5497993b58ad5673656ce06be29b9aa2ed1037527ab10dfc2a0506cd9c4a0e4bfda57a2b95c39cf0a7a43d1eb2cace958fe4e64792228c68b62a546373a92b060114acb09fd46393a283f52e34768472b1634b7bcc998f6f46fe3bbbeb249a579a9eb903fe9ad994f363f8c192d63b740257872512883c216112bf18f883250e74f5fa3b501f5f403e157d766b4d940b2b19768eab0184f7d92e0055632b653c286faea39f4bb4b2b11a5b785ea06bdd66b0ba24bdd317b97e3e3418605588c43900d6a67cc350e063eb9082c28cea2709366b5599c7aa883dc3fcdc226355bdc9ddc731d23beea62dbcedd954e1f718d3160d6975014db1a5bb867e1baec7b24d19ee3b0651f62723a9366eb16425f225d0ece0535586b9cc1936a59788cc6a4d8c3e90952ddfac643cb4ce0ced46d07061934fb8687717c349ab7d585e0111973c6a15b689a994603dd3be5acdc51242e3989050d35c1e9db73f8023e2fca27e028d3352604975127071f22af0e2cc2819a348c76484ef580811c29796bbe7a9b93d2a5ca8b516fdf65e49be2b2c50a8727ea838832a47677d98a88acb8a1322d7ed3ba1dd7cc261dc04fa1889a9926d34fd9facc0b9de323aaa1adf4d342a52f7366202556a4c7a819a4c0aa8c4ed103816c991ad7d24e70a97fa7a14ec32c71241bcdb6c079c6fd0cc79f4dd2304d17e7836f9c29763406788dd4792b0673307aabae7e9ea660ba107dc8d7d4daf40ef561496dd40d2d093d8b2928b31164f72a08b03c4c924e80a74c803f32c1b54c170b6cc9abfc32b174aeb5d565b4bc9aa9ebb34b6151cd283bbd486c1cdb5ec12720197aac1019a615469b54052755e8a8bff3fbb7b594ea6034e1223d26db4f1eeceac7050f75807cab5368c2a46a7fff1df8de8afefdea5821cd69eacaa30848f2fe069d67a10cf8aa6dd6e1532af24bef73737d5f6f0460dc48766c1cbdae445b89a9eb8c3ca17cbdeb3be29c8c9a84847dcd47c882679dd727da62e6e9b4034cb8639e9675ca87b44f13e520c13f50edbb79c08eca23c7efecdf35c78a78ade9e651951d6ff42f42e2bf9d8b3f5c0c1f8b59c9a140db2348e5d3807434a734a9e713b71f1b7d92d1a0cb1d3ee35b6f201ea1092f39e3bb5fb3e5564a7e4528aff76b970f55f8ff43e23ebccc24ec9e1e4cb1b9ab7525b6aa99ec8d31282d93c1a71b86317ef4b3b668e619ec8d5d717f4001809c05182fa6252e823be07f43e95410b24f41bc28a7b12a7ef9b99899b682ad3bfe07ad381c091247edbc55d83e35b333fbc14e92c5a4e275f73db078d61525447d54b8ebe5dbc1276caec8cdce405d694d219626184b8a0ac77e6dd3f93b6e370423ebd4f920331680a13bb07683c86d577859fc4ee2435578c3b1720c8f453c5cf24fb438ddfcb97b38c404d16a7ad07cfdf71a0a9b87e1e7d4a94335fb2f5861793eb4ea9434689d11e5968afde06efec1b0756e1626eb054616234520d63006111155f08c7715dbc23b80ba60a41ad318976abaa11baa171da0ecfc4be07586de52944d3bcafaa4e2b0536d53f4e9a20c1071ce71f57424fc87c6341f91c5cc4159b9838b178549b7ea3d6d1aefb734e29abe42f8907824087629503afe262dd4e0a01c7979ef289d2ccbb3b6b7d1ccf31b4d6ebd57aba6532964a6c2dbe92b2de86efecd93a03690aeba2f7b0c1bbbdf0ad52b011718c1e49c4cd965f210d24668d4d7f4eaa43962b9c9f631a3b8d7b8ef7901e8475c8463817732be3cec10c3ceff5f72517e9b24b28fe11cbff1ac2439253b2eb206d67b507df0a180beb3f9a5cc2fadcabec09858eef3731e2680c38c38aa6f5b39b0e91dc3af45fa10547b6cf43ad1ddd0aa78811b93405b3e50d0f38b05823b73cc2e9385b1e044f8bdbeca36fec7e3d3d94a7ea4fc16c665007b85142c3f2e0040fdf37d7cbca40c5319d5109a57fafaf98dbf6439ccbc781e669c3c9ee3ada94ca5377b2fb45d6b95cc7eb7b751b8084e7925d69b32b0aa56705dd12964a2771ae56cad19c8b03cc15267f6455a68ed7ca122afe9feb199ff97de2336fdb0e9569e52c83d4264ae3d46d496e7cdda595be817ad38fd0d70d9a66d76cc6abab6156eb6dabb17b209984f0a78a4ec6656a59688e80e4bba89b9c924203d0f5e33b1d3993a0802ab00d0cbfaa4dfa324e9301b8c4f193bf8d8dcac180d83c53dc55f57e0d51bbf88134f1a3046407cfbc6b1791dc8e8805d38f125906269bada424844c90b728e126805960c512db93c6c0c766c5897f5ad0d34010d82028cdaaa76a27f4d0f24aeb4b4054489801925ba2df7457830a2e4d049f7f561555f74db5550df12ba22913ec2cf7d42b2cb7a851581f7f1331401eaecbaa92b3bbdc55b3c9e59f8158b5f77c0191c25abc7a7df844036fa1318fbaf9ea6111ea4098e009be5b0ba65af7b19abbe05b45bc88987822c524c79a9b68954409f5bdb2c3a497828ba8d7503cb744d30f150f6536db6b102673a177b742e936d2ca00770e8986e8bbf55059fa96e612a7060d75cfebfb17e974ea156b68afc23b47bc468a1dc65181a9ab908ebbc55a2601caf7c792e8d151e0487bc1f1b831b288750e0bb610ae65a7af6c7b0aed2cec9bc4f5156ff51cc0e7142860516912994cbf48f48a57206d5ca6111121c6c930d1e6f2bcb84ef435163e93f25ccf623946edf766127217b796078562b884db0c569bbc75d1d337870533112aa0b5ee73e0a15c1135b3c21606bf0ad334313a43dece643a2e0c7924a0418ab839ab8a1dd2c921dc1ffad56e47b06345ce7732fd231a19c9c6771c6ea1dd88f0e0abc44e0d5d3a0569faf9af19978ffc2aa9e79e0c13f5eb75745350cc21d13dda0be5e2fb8f2b69126fec6d57514497963fa7967c103e3b6ac1aa234453b64468acb188165bdd1b971a049f6cd3d1dad61df6b602378f51bdc837465ecadb9d6d1f3d11a62c9529e3628e92f0a14448f01885b8537d36d34eb1ed1188c4ff5aa29a9f9d9ea15c0231674831babcb091c778551a862c714d48594f078f6bbd7cf2080b1d8bab57f9c7f0fb301671a0f047ffaf95a6565cfb9670005513d5f8882e4a74a7913b2bf4f899625c7b8822fefa4b1b9e45d294fe851bc071e8046dbda6b8b3d24ecff80ab0bf5269bebfe3317182b1dee1b7bdc7aa1b6ad25c6bf911a2a4107a442a42e74df2666476d080aa67052cdb4abd2456523624d94e083bb600bd858327ad1803e972a3a73dd0758ffffe9cf3d49d2c4cda99b10a45c564bdb02b3f99c64fbe875376487d440504a295a7f29ff8143aa15b8ba874ebde61ba432c2a9b19800188045e8e972837d96903ab6957687a5809c76a2f432e40d0b00721e1fae4418f7c4b3313c22e66bcf10c50a8c99556f797c2471a760d68fc5e1a7bca072f381310c54a64405fe4b66bd3182ee1a1b57b4b13443a45a69d03abd69c3ae9e6167c78598b7ed76c3afa0c21c3f4a07b77c7d41b6b0138a81a18bbddd5e14ab6d21f8ae0b53d664cbc57fd4a288dd04f3651d38c961ca37df24aa1bf52f94193d3fb34409d12cff244436bd75cd30e334ff5afedf027bcb72ff505364bc818e38bdf23b031f50bb33621a9114536906293e1860a4dfe1eecd07d97680b5ead6b23e4120b708897cb2113663b91e9f435294a80625a6088669c23cfdea06339bc13ec84de20ca42a8239daf0e4b0e6da235076522ef3663b2300a54f403ddeedc780aa4c808a19115f8d55f84c89e5161b755a4ea89cd756a01deef9d1fec150b09aa41d83ee3f7618aea31f903337785c81dcc6a7581787976880b66658e92fe271b52063df818379e4b0405586212529578e3495ef19ee8e2157aee69ce786a8d72f56237c4377224da3b25136ee53fa9b63d234fe701e7709b118936c05f6b17250474396e1a26828c565428e36fa87029e330777c64b1a2f961235c4e39e134a17a142a75661bc1fbb476a1ce69f8d7541bed16c395dc077005d54de1b00bb33c6fe05d675c61a0fe171826d7e9a30c5417bce1f5e30efe7d25e7d52b9d696951f84dd23acd76f33fde4cc3ecb033b3404caa82897b090c1d49b9083d7adf185bf1b9c734213a77a55b68fff8dda1ec601604df4ef9896c33b423df5c914d915d2e4bcdeeec5f9f5b1f26bc34cb6f415873a9b8499fdd2f7232d9642b62277dc7174b5fbdbc83cb7f5b5efd63a381a7b0c2f8183f20dbd2215fcaad6f6fe9c5cf5d907b7fd2b9ba770dc10959d8f6f6c88025db71a08db451d75b6845abd6f4630f7dac4f5e1bbd175c0fa9df5ff7f69e3e9d79d095afe882df7f5d6dae1da83099a72def2861891d14b46501fe535df0f3809f2521293ca9a063ea37b3b0d27a9f9c243ff13f07837a6c93a975e0b7b313589a0893fcc8e27decf1ed5ea81d9ec332ef207bb4633d3b5a30088839f4776454b6906b0c31a22baf6d6c61d4a62037f8f815eb39b748089ff8a6d949467b9cb9344f130e6e35f8461002655bd93e861c4e5e2f78e946ca9ed639e9c2b3766fa4d05b553c9adc88b3921541907302a8166062c9404d7aaf297d01c377675fa4e912b07495670dd2b10e7d042514873bc2c5da7096ff611c35e3ef8f4f5cca25b7bc4dc1321561d580d90e9a129b4d4219edeb9cf688a60aac82fa4b1e8e697859d8e4c5b5d59fdaef586797fb9aade5c24e9c98a29ef0704527b0cc509197758963e5345c588a6cf6b05a3b1119878200e9310b8b292f3a9404cfe58e3b8eb5c914d3d329dda22a8af3d4ab1fb69068f6aa68bdf061295ff189ed1f43f6ac48c7e34eff8983898fa55db6de26c29e56d03c22f7dc1e53d332fd74c7e115aaa121978bb29aaafb58c257b218cd5e713ce73fd2fe612652c9ceb5ca399b3d8a2ca3c4fd5962bb7d1711931de9be00b803a7694d5c6ca501995f638f6709a2a67eedddc7d4ef359247bfa9df87fa4be1878a73cb901efa02bc7430dccac4de6be6837dbcb1bdada7736ec5022d4552ab93d3f698b85fa4cf64ceba60c148c77c699fa3ef0937e72cbfaa57455eae39998cc81bbde0a870b96838279f659b37c9018be950fe451235595111e640ddf604dadd19f1272f0ae17f37afab4a896e7d3f414bb5f77180498244120d0f8ad3cc6f80fe0bdde5242d641152a2fad4ad72868641ff0a7a24c7247cff3625489eefe6f8634057c04c9f0fc17e266023b7c716bda0cbe1a665dc460b41f38b8c9d3cf54c238b5200273845da32bbcfb0186d3d086154cb850aed5c77726b861a0c571cbd59f2c611ae66e0432f9dd52479ec643dd2a6894ca1c49f2bf31b139f6495f6e9b4e32711cee20b14253d44f39496aed45d9927fb2916292687c92aca2083252df114740ba7422ff824ffa19155898872d08c8514dd41dbf7b5e9b85c1f40484d155d304b9d189449f00e67db01b2f219277c89cad6140a51bf46ff8a9aebb2e445bc856c448992568497151299dacb9dc560a45520e0d6616da9094f53957fcfeac3bcc591ed7338467ff652d00b8aef1db77abbb39dbc72b9378e224afee8b4742d5848e709b9908654648916149fee9269975c82156b38241ee38ed055208ca8880c667045ce908b9c244fe73e234124de74832dfa25d58829cb920c5f73356d7306fee63c0599349a91a9d17000ad99f9d52b56316b1d9892221294fb18d1e75c23a5f579e381fcd7d01a82087a71a7c4f3018f706171089568055e4ab94cf703e6f0f4ccc025f0383a38845a7631ce047134cd88f52df78dcaaa088b6f2b0397e9302d98e8e378a7a6f8bb1fac2e27a7f54f2a3cd7234ab824c9fe262a3938501d33e9b052d5275726829a1b1b6e56a0140519538667b9c3ac814fcaded21227929ee5c61306588cc3e9655e4709ce32a9cd25c23c13f5fc23a44fa4a6b52a6eff35f9d6e82ec9dba48689511ef5c5d42250b9f63f9951ba8b2c0574cabbab676cea0f94b85a81a8b3f59486e127a000609840e59603368be93f8a14d994ebf4b9e55ee7c087c8307711b32957f409dafa0d55628a9535ca8cf6a853171f5a9e159a4e56aabce2465315e8e3a05758bc6409179c41216034adb56ef8d875df8d29cd0325dd856c80980aff66f03892f0d7e37a7a41972377d065bd3421513efe78de4e4b5dcda93f73db4047d3a4bf23ae04da420dbbcc17456576536416d4397c591360f0b469199cc030de9c92038bd1f28cb6bc66645104cde6fcf35c0548be387dc6120c231175cc359b01d5789ceb32cd0d292f767d42f1c426b9f8cd45b732f6ee3b73e28e9af6e741fbf9a63b70b551b30b168ece1cbb632376d87606635d2de48f1e16b6f0b2a8863ef8fb4c60c11873c0717713926c31dbb078dab14f8d6c2f87f87713f109cec6ca4690480fd38ac05507637d8ad3605e5903e99f3af446b3311bbd7723dac4ddb8a94b13389f425cbd1efb48a875c5fa3b9e82b9924eded2254ba4d30ed1a32e18df248f5c7ee0708683c6a492c2d8f534b01410bf782020df4a5aa69b03d9b50528c5b13589af782f378e92ee7423ce757b042f081e37025b3e2f523d7ecc60bbcbd133a42eefe01ff0e574f8a46e699a9c926233996280200a85f19a032382375d996cc4ba9ef27fbb4f2b00a0e5b678e799b7bc2226481ce1fefbf889209e38b47ae4548b29dd3ef16f39513a443386faf896caea045c87890a5771eae9893eafa3ed488e3687c41b89a0ee2f15ebc4b78f8559791c810749850a0532cc7a7b96707c9410e71b701ab9bd6d3e00e5bd32155848dc0fdc1332b2f8f99d83b795975bccfe1aaba84b1f58e2fa635c34c393568b09a1012a12078f66ad8d36915a1e28fdbeb3824e66068cf26babb9613aabbbee51fac4e713d7d31e4aa1b460ff228c1c47b7c30327d95154ca486472d5fb1634de4eb7f2b46c39467d7cd0c3f4cf7adb29904e044799e7eed4fbf9acbdb14ee063044a1a58ac45f2b75b6c80f8c332c31d7de471b6fbf82853d2f0967b4bac3a23c571ac0eee3452449b68939b045518ab72689e40abc0d98fc3a2e8fdb92d1cc24a21ac48a9973c1f2f113c6ab04f87da165120321e1a997e843d7df3639c3d565cc016cece6afa232ecd39a1170ff8f926bde5cb3e0ff4d00706e71afe957c9bdd0a365bbc8f79ad2287e23cfc27f0ddf36cd234c71ce152850b16020ac5f4f665455b4686bfd0a61798a542b88482bab2124fef2a23aafee59c6790beb54e51a5953d5b977e2b53c4cb98470d1efd08450997e3e92a0420b0075067d67ca5ec8a0ff1a2ab6592a3d85bf63bc1ff2da24de5dc09a8354f70ace262373228b95596332b04a4605aa2ab6815aa1eb5cec55f7bd5224cce690a9edf942c334922537726397b49695e8d13b44ab3b485673977edbd124ba561ca31dc30528c34d5d9e6bb86f15c5de296a7033840d53b84b9eb7ef50acb726d8724dbf6d4f5fbd5be8fd52ad502c62328023d73f4c0d58b12be49e88d27aafc18b053d4fb998ad8e8c4fab816191d08079cc376a0ba1c4c62bb25695295609c0f1dd414858c4ae1eab20c3ab527afdd7a5e761440da5138a717566dac9db7c16d3fed9949625dee76c631e75e9934f342050c598ac38fa746f7806d0312219848baf8641a8af4843be41cee0d75e8576da67a3174031a09d13010134cade78e3a19ae026bb8bd6ba2d8da179a0f3f97e01e68a42c484a3b78b66413651ba67a3be5a9e24889311710e82901f02bfea5f209a953f6a35e17e37875c1d4ca151bd3e4fa334bbbcc80b39cd608d06b69fe0bc93e8ece6628319b5e04b70ba283eb4056242439bd7a129c96827f8618e6e8520779e6d77e02227127619f3d28534127b1b516b231294c9c74bee95f7cc7a1c8ea6a7561978c3cf7fcb7d1f355326bfcd73625cf405bdc1f268306c32ee12fd5b11567968c7e06aeb2bd1c3c797ede5daa972d6621d8bf37a0622c75964aa94247463584fb5dfb7a26d9b2b0b2a10f284557f5d13abff652c5dbc83dea7a2a85fd643743b3b3d12124ce883b294e9106df3e8e21a716c78bfda512ccd3d1b54f23b7eb43be65e13caad89395d2ec850a0ee02d46037d2f0a1f5c168bda72d63e1b8780dc73b6438dd154087a8052b7617de79f48e6eb373478bbfb537e95347bc4fdb5e60fa26e25d2a3af9b5fc3d9501ae938162665560a635974ce80710d72f25e4923486b19f007ed3aaa38051e054623b172eff48a40839cc68f38cd0113139341509c73335ccf8aff9266f02907808eb8f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>谶</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E8%B0%B6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7dbe3d76a94ef9ffd9ed7a53a77715482cbafe8f4c8540dd7a12459f0e0d78b4">adba944712a73720e1f31df1fce537445ad57ceab1752f19987867e0d977d72e6b9306cd99a79ef4fe2bedca4c3b940830aacfa8b5bd6eefdb990f217f57e7e1075ab6aa9b320d9001b998c7d3d96f05ddedf9097643c8ec7a7d149ff96a6d7af0930dc615f6a0b11cb81595ebffc4d0d6d9515f38ea34fed093a8badc343e94ba97251271457dee6b56e58f614bc72b88e637587b099e42765238ca9307064705d00b774e85e6c9958b1e19cb9097e3cab29efd2241eadf665ad31a38a7b166762cd96aab221144778bdac1ccdff3fea9667161495d08bccb321647364f9b7329dab39dd9ed672e6883f2ae1ca57a29a676cc3c2d328db9fb938cba7916d118e78063d66becc9fd67e28c36423dbab85e88827259bb5485d2bc7921407f40d792dad64a84dfdcfc830811a019c1939f00fff84a659039e49730e462ea4c3a8cccc0d4520fa3696498b667e0b8fc66ba65a1f943c0dd9a41e7187849b4bd621b701862b8acd9d47840ea6a84b75a57a3a331253f549b61cf55e374b93690ca5a0927a69b46ae9d6e14d161591d3f11b823313289274db7b38c7cdc6304abb6c9a0b02354a942217179b5861c78a6721e5168ddbb45d56b5f9c45a39ede89f34604aa319597f0d29cfb2e59db0868b9b40b1209ed6eee45e149db998d38e7a9b4b71f7829bf27b6144d09900ee6f3c96ac9ffaf93e4cc060a3bf5b11c955975e5b5fd61562497b6c52efd4f91d3de1ac2e770ae1972126919119e6657237b38e27d6bb33df61e15b1e7e42ff164b5191f7fc64a774dd9ad796354d94c1a15ac4d0f3834b2701359ad51d140046ed691622c3abda5fd2aaa27ff5fed0934f58fffcb65341d312018bdd35bd675307cd97963cb6b517969f527626fe1ca6d4adca11c328ded3f3ca20086ede6764bf1cc0c6a24ac56e020e0d54a2ccd2a5be2f3b3c87bc505b1dd3f5f192783103fb0c5ded07a409bbf9a7b4b58684614e96f704a82a54ad8ad7a7547055d6feec25e608f82a163303e8dd13b966abcb636a49657c93f36bc5f53c6c27c00f1035b9bba0c2a01d0c8b41bad8bbd666b5436471593df48f84f2f27580b31f667724495d382a2001a4ec5773b1e2aef105e45da8f7b28b2fb694428ac84d2edb36cd74e35effe89003ac9071325efa5ba7df7b11b0ba4d0339988903cf485e8acca45ccf125fdf5ba77be1f216590c9699ee4ac5c866439a4b7ad9cd2f299e62b271f2dc48c27b6422aaac2757a4d475d40e256e574743ed526036cabea0d2c90041ca93ad4915ba619e932a14701d5061e0ea31e65534c81309cd8d10a3fe32a95badeec9128c167b4cd3097fb73b10893d97dbe7ffc4b6a0bd48f16dd96bad3702da998c8019a2ecba4d817cf1e40831c5dbea09e35c66ffe983c972c3c7f79c0c20808bfecafe9cee626c0de35206f6c4bb87c089e12933a710fe6ed4f54d587bcf6fdf20e8a84141490b9fcb0064b31b93d6e4be29182b201917a3aa9bf5780d87ef0dae9c7a5320207641a57f158cb36a59e62137430d34e848d7028b2cac57a1afd0cc88b85673e83487661e0bc682aa9ae6a86f88d04d5d2dc5103c668a38f4ec818ffe9e5a2b77889e27a8e363ac9351cfb408767802ffd6777f67574953da2a14e68086c836e5af1d26cd955d0b348118cac4f6c2b0af4300f0fc144a06785a643cd665948509685dc5bdc00ad919865a6c1e8f9d7f157c196d938029f6565130d2e15b2890c3338c99074ae087e5d01d7c9c6a79a4dc3b2f5daa307eccd503fdf4b40079bb38ab869d07a9a99286eff7d0afe1f39c61ac38e1bd819149f3ec309916f248ccbffb01d2dbe1c30252a95a2f0cff49aa8ce673fe3ae676abb7c0b745a009f364d80201ec948cbd30cde855d994623dc1f80ab6280df60ce86b866454bc9ee44582e496c811867addffb87c0b046282327180c1d0139c440e5977473e1d9bbaa01ce4a3da7bac51dd56567e47b0590a2881f8767b91bbaa39db5cbc87ccf0940f23ce62be395770c41ff9d529ec80b0fe1755511442ece1f652b78f4bd7beb2e9050442069339bdf8ff195af4d6101d6a37eb1a747b0b347f506c106dab7fe32b336f47be822747837e51e9a4c0d78b7894485aeb7b5cbf429f8feeedc3d2997bde83427670f00540d83db28bc30b356e4599750c3519959389fc6b5cd112cc6a5ca1080c1b849812a27133b617d1fb6b41f66ee031fb1092d473a717eb85f0c33c453dc3c2d45647114f7062153a1391f62f56c95757f2a21f58ef901fd300b58932cb846eef4fe9e81484a7c8449abf916934f45bf1ced39cee2671a543482cee1368d28b07c679d96b073d262168f49dbe2d953f81548e65c62e3347e80fe1fb47c90541acc8fe4fb4e26f61003cd76bcb375ac7d6c90c5d5222422e51113cfca09398e56deee5a3b71a312c0ca9e972732eebee54df1677d9398cd67e16a41410e099121f7c9f9f70e104b71acb1b76970f1d67ef7b6859c8580474b5ea5350d93506074087f5149aaf26215fce4d82394585c64571316c425da4cb462cac24e1347fbb17e13789fc4148125fdbaace194a50df5e4b9f5a4f08eb7aa9d7f8b8abc43ffe7b84d000fb6b5c7848395b35139628450d729e3270dbf9101e38f44fd525778ffb071a8f003d4492b61e6d7794cbf08d3b7f53a1a4942c1edf109670d884a660254043c9a59d54387361396e1e165818f875431c7b940dd08f5c6f75fc3bcf426a96d8b42b47430ada784537654cd0a92460582ba00b5ff7e1e66b55712ad6247a9ac85672d56213995e2fc84a89750f33f6b1339070b9acac3ab9be0bc55dfcd0166481322c25097dff01d1ea280534690fdc55ef7bb3f5c5f49472306ee49cfdd77c61555ad6af8b4f30c9b6ad900aac4a004cc5653cefa398bf6aed556c5d9b752521fd9398495e4729677c8511435fdc2385aa3e0590602aa61058f8fd2d96868d59e240ac3e1762213b065681694df997468adf3cf023fe24947a374deed2408520acd933e7f4681a0ce4e128b5c0c8c20aef39f4407a5dea686f6963923e505044c6c345caefba1a008fc8b6becd1932f0830a267ae2590a414e3ebc6c120074384f2b60d52dcaea7478107154d01497d93349753cb3504a43c23d11db2fe5a51f013a059fe0818dd7a8129025bc959408f480f2ff57367bb5efe67f94bd285498189a2fdf4cf4bcf43188ab65b9da34a433d5f13c8a285334185592c518108a9e43907b50ba06af725fa5316baec7f073e1fed8afdc224a654f94637e86333d2c29fd208e63d6b847f66e2a9e8b0b4c3309663ed699d23bb2930544dc2064720b70dd641103efc7707c83a7761f5c62c7dcd318fe14ef571c33a6e5f88730d35d0fecdefb29af2c084ed01ae46c1dfb348381313c26c0b9f3d1299d4b9a0dac9a079832dc9cbb2e0c4f9e72af54738d9f9087075fed979cca1bc12ea8bd001463d80cf4532f0084c90358ebba86302664eef5a75267bc880c0a1db0e37dd3ec17b2e0d0425bd04da7380691a53b0496361928d2aa9ad177964f318b6f3b00decd525039c212761fcca2a7d7d91a7e323af33a46f68e91efd3bf73238757c8af0066b9969e39edb189fe6fbfbd96613b71caa587a74acb45ee985513853c01bc936cf39c0674aa9fadb02338f410e9f331be57c43890f2523560b5bae1618f21448e82558840d6d5bd0f9259def9e8d54e57163dc82968f38a02404cf0ba97ed687863a54b2f5ddcc11cc07c9568204e2c1b3ab4044d6dbc5429ee5bcc0312142930271e4cefe500ad606597313e93f301412c73bd38b5a846cfe7f9f76f2b9ee76ccf23821eba2cb5afd447e1f8ba93e4facfc05642feb55e32fb877598343053d5e1e93c019bb84501f999b6b51eb7c0a5fcbee01c10389f7624855af196f9e29c55f47ecedfd132bd61cb63b6a70f09d754c5e4f9d66abecdce7aa7227330f45d91f6de7b05e2f6ed6772088619b2dcecfdcc614c9079a661d3fb5cbb7dc2467e63ff42de94308d28c09ba466c9292a57041ec6f8972c1f9f7d205d910c840f7cc0e700f3f6a0b3b321ea6368f195e047dd165a8a51757b2fcd9560803371e86c9f891f352e215338967c2c2ac019f059b0e2ca99ea932d722a58f078dd5268f7c0f4eb8a466c61a55afa90ec20eb983764a3a7ec4c7c30ac05630b1b84e0f508b09fb2417ea902e6a92ddce5fca5957a74299e50d01b7353f86cf53f911910ae442d3b2a0b5c4deeb8e5559ee23335823a5ef105f227c474a19e0ddee9968333613e6081160a5abba5b8241a991c2f71448f6bd656e3dbf46589bcdce789b7c67953677d195efd8c9f571c81a9eabf3515d7e2322dee291dd012805de8731064b34e26551bed279cb2f6e70666acc31bd3fc5b611c91ac7150dd76c10b21f3bf5817d0a54fa041366c2d8e6e1578538391f50e7dad81ff52a495161ed1e4559523cab8cbfc0c6df29687daa421ba6a2ee2e3f2fd4315934a8a29af5d48e8ac2681a21ab82565099658827544b9494c12b6f0224cf0c696d44111471b3e5ea45e8bf48f05448fd872b973e12fc8d11fe2ccbb118ed949a0ae714b1652c9cf9ae61539cf4260dd519b6660717a86a80ba9eec62e40d77db63a7c6775a8a388bda61274c360214f2b4c922ff193ab902ad7dcc1d3b2b9d828543a47dfd58ecd732582e1467393fe0f797524bb891d4a03758a140880dfb18d82aa6d3a652915b1415d428392a2fa17d566f24188ac04e129d0883484340b7fb72a2ae5c573ce2bdfbe2543bc130d680ef85585960bc8bf3cbe1a08d4b5437e77be5b7d9d03c66c4c70401669e5e069b83207c528e2df0210decc25c331da80630b28a2db46ea8173a4251ad7daba926ca510a5b3e05b48c4f5c6540d333f9b48bd17c1081c37dd6393f062c730b035b7a7bbd4a2047a592d0d5d13b10c68b80d0ca7cfe930dcc7902e60393a77daac988d1f505241df5fa3241d45195ffc95d48878b5b54b66dd4c0b75b470e2793a39566e84ad45e21bd85c619ba8ae4205c2cb170f6ed1c3909463d984b5a60bcc19a428dd6e1cfbf0b86ba3eb06731ebd47d5bf9b3f963708782bbe8b5378f99381a7fc1eca7d16a00b8eed2ac7abd43240c9eea688407f8317a011651e36925027a2d076a1c133701f79136faf0f47c15b00a29d622d18197604305c727e9ac80b38db4658db16d2a8dd61b7f1e21ea902b7d12b5df221f32776e26536bfd4f3cb6829d728643cdf16fdfaa92ecdf8925b003b6a063643cdc4cdaafc18dd0d272d8429b48122775482dae6e678b7c5233599ef276a4548de3219ab2cf029a54d089c65c0620cc838772a5869c280ecc0229bb12e5aee5e2b1314f61d9f9ae7b469db648815f6fc4489fc2132928e21eb524af5aa5b103241d8ae630d5445dd5400f372135dd7b2a29a495ef2c7995dde891dfc750535e833eb3c1992c173e7596b9e10ad2015f553f422c2b94cc52b5ec9d0156dedb4f3666f3269275811937315f4de711ef9d75c463382a11d0efea6028bf16194b91f3a33dae5abd934477f1b358e7676acd47b711bd54484af0022a2d3ab31ca333a8bf4b7de4beea9ed4ba9633106cead3fc8e03789954f74fd7b71e0bec3c7584eca60b2445dcc14da8cfc1e031898835b03bd8569b9f4615f0baf1148dc07190cb059e961f91a1e33deb8f6f71f2f1a2b070747cc7949b85f12a97cfbaf15b0bde8ef4a9282b1944c869e033c89908880f5f01099a36a3645b595252dce61896df1bbc9c3b42335232bf1e5cc76963edca89cf12dcd283e50b668556f43663af361448fa9ef778d4abcdd2acc0596ba067a928317a613260a304cf52943f2f1db60bd8b1f824cb217b3c32995c6e1ecd870a20bbcab69d18f2d2f4dd0891edf4b43cb9618832810543a6aedb7884a8536506bef9a3c7b6423f42d2aa7e7b4a18b71146e18c1213625584014329c3d3608f345c6b17f411f2e5c7b0fcb71a6da733024dba9e0c1bb026f29104c21e3d7f3cccbe19ff09dc8a8ac8ffca1edda29742a01080c0ea93d71b7422a13ca70460fa617277fe91eaa07bf3474027f18fb9b54966b75d49fa277efa606bc126768c1c15398a75b3bd3e54e168d2e8bf700c686a55de6a54b4fe8bce9db360101265341a4766f1b71c45cb35efa3f1c8dcfed4318dbb9469811064b38bd0fa165d3e8321c00ada1b6dbc26136d68a112fe6c8fd03a7897811e4910e3be3a5752405004d4f3b88c8727388da03c55a760fee8915076b4c25b171966e25fa602948c3d296d2f30aac65837f118817da69a5930e3c6147b43d5af2d63d00f1a684903cef14441f9b1aab7007b4cc1a247807681b6f70d503ae6674c0e73825d249103181f37093afa39a67094246d5f7326744fae14b99686281987a2da6f69c2930a9066e05ae21768dceeaffbd3a9e5f193945cd973f7f3a8dcd7875f4d0eab2edc01aa007f42395f177f6f4f019c411091312750145ce6c940a14218773c6ff5a7dfd9d7986425125e91d452caa83142e01c0822611dd86aad5fe2ece90b3709fd66e55546c88ba3a83134a0574833983036eb29a27cca2d27ebdc73a848e1293e917757b60f6def3e92ae036982d99e2395feca39b2ab78f495edc2a7ffccbcce56bdfb2914cd51c0cd9302eeb86c4e37d88ebb47373135007fc9a2573bca64053970e815ef9d4429497191e71fa1b15fc80765a4121b693dec9327bcf41f0ec4a8e7ac72191c993cb734f73cbbf907a56d71b5538e5af1fc240b41bdd800bff80e818daa74041cc14970c45f60e695e94ddb143a310d54849f60128f6a52763d2cf929787c3b66349ff47b4caf838f841ff8ca23dadb502661e71a091d552c673dd669d4b77862000be00167d90272dcc5573a2a4a6f07aaf5428218e961a4cc7007a1a893078fe6682dfdc2a011d5877a8b20c516744a71d94c17c7335759b5849581f188dcd6dddc2db0b041def86ae4b514a2d1b168fed38e05a45dcf6b1a586fa3b9d6ba4caaa9aa7687db5fba5f3d816de5baac1ea1f1bbe4a1328dd6587e9e2cd90c20294a2a6033a5bbecdebfa5a17164a91b19b3a92c0f6e835ac3524852fd7c65ea97f9946d0e149fd4a516e1be1d1b87ff8457c8483a1d691db3886131dc08ba6b44becb468155f62b85e8f351e3d4c0a01c2e8f687104ea95ba007edb3597c6fb564d7c8ea6c4472a1cf638a4d0fcb4cdaa85adffac4b706a24f8e0a98ef68856be919de547f991e0a77c71ed5278cb0e2a58f7c861f0e70b000535aff9314866dd7f54e4ede9f7049cb4d4905d8c2eba206ab035a0c9d17a6672c4262122056786dd27b10bc74dd75558c74d2cec39b9b208014d4cff445f8238eabac91a8f1ef1ac5c3dd0ad5abcd296674258dce12bf86446beeaa66613521c4b6cfd062d018a56e2ba46b6746e673b8c9f7da3f485ad56116733ec9ae3c03193445c7b3f4fe9b7814375b8f7a4924575aeb6e462a02a00cf0395c7d40b1bbb0dd220540db022b696edd7be4233769fed40826d3a58d4bf55ea4f8932de2fa454830d622fa3aaedc3f47e1c29520e1d3d144c34309240821835114047f913b049989ac75b444f554212739ef1b71584a1c11b193dde57ca51348652cd1ed17406e28dd924425f756326737c6b0bdc38d9bad070be604400c2dc2dcb5dccb551c1d7daf53444cc54051c481ae81f2bfa343ad24e23fd0b2a3c806aa68781fd40280ddbb150053a5be83606c042ce9a1e298bd03e93a64cad1148bea11ff46e57e9691b93493a9004fe390b0d110af8bde82ec4f65f8c8b4c2e9a611edd569aa61224a2a2af36f36480d0d5bc4907623aec0ef7ac828b2a326b14033c03d54f50eccc15427ea2ed56f3bb084054ef6f324a410f3e7b3fe672de83e2ed547ffc56fe23c944944d03ee27e2a3c024ec2e14520cdfebf223a9a8d1ba3f67777128544fcb67438c5c1d086a0f5e4168900c17d3e348b9d8479770faabb0d4db5f789a1fc124b150016b0161a4529e0ee38b26cc7c12e989274af9a8f8f5b56edc3923c3998a7faa6288446f636ce0845058cbbc7168950a6cda5729e10ed99ef6b7f48a55552ef49c95d1be030d1773dd1cfd2d75fdf31a5860d4e8c53f950701b73d8c7d4b6bc59373d0c724679eab68983a9690a5778cfb732be052ca90be24e09e64cc6f1019932040b40b77fa7c216dff763870b346ede83c5b47606dcbdadb14e55efc3dd14430b38f98657cf7e8bdbedd18068cb9b9c5bf4c2e0aa7d254dd77618a9955511b97d7cbc8db7dae37f7adc66783b064cb4c402ba0502c7fb478d492776220e7ca9a962104fd8ba89b90d3a21ffaadcd99a1ceaa2182cc250b0ac3b9d8b85eab2facd7ea73e854f5a37ec967d945552dc8d59fa2863f62f2b424c3df96738891e3ffb6702669d67921953fd5e8d1a6ee14620462efd7deffac89942f758e05c2b5be53c0598b9cd2e909c404843ba87d6a083902961c6007bcbae4f9fdd884c926ec1dcf9c9a58a9d7d594d9e9382228593c1cefd43cf22e3a543c6381c51be1af743c88102b1ef9ef25551012e86e1e6cd826d325fa42789528f04d7e86090fe0a71ec41ccd1eb1d70c7548b39a4e6a57f07aa0a572921d52a41c0b8a4bb0857e0e0731539ec6badd6f29fb6a52f5c24d654a1a6ef472443b939c66e7f23257ae7aea3b26549ac7cfcd183bc090b72f0e66cfe039fda32ab76fafd9ee1e2abbbb40db358837338ac8e330c929b1b847ae5beb0139e2651b647fb35d647071ca59324578ae9cf3fb3b6feab51831e82e8176215f0ca2a10b5fc194fe2b2e323471e5307a1dcc6c6ea0f724036254a570e9b1b3343c803ef2bb5fed9427434fd0bf7e26fe06a7643ec1371dbe1ead5e372768b31e3d2840dc0188e84c8d06627faace1b3b33bd2990e88aaee20a383ebd59abea9eed26a259718775fe818d0058f3d1208869b0b9de32ca3e21dec76543fa48636e2ff576c4ce2ef3a756d6443325028538f04f7ce72dcaa81ba415cc62bca26eafbf1b8641842c4472af983552959b64711e26bdc629d7f4b93544e53b107f3c37e034aaec9c4f23fe2eee3e5c4137f7b5af771ce15762d45329cde7fb2a0edf817c74c40a8cc650558f9227de05a853e0711bb8453ccf13e44fe67cb5699f5b2a6a0b5981f07c90d91ce8757045a0f8dd40c03aa2c6415898b5f2f4ecfaa3f71cadefe8e6eec3815ca31d5ee027460b8bf76b4eb5b1764f5fd22f1da6c7d22353194154c5188f895488f16500dee6cbfeea46d512e2ea6df68829296d2d098a3ec60fd7d3a60a9e9cbd5e1896ca6183a6279dbc592700c4db6d2a5352b567e78ea660f17a6261fdd8be689c444cabdea6394b484a859d1fda8246a00337e2775644ae22b7a8336873ee7eff7820729409087513e586052792777276781f32105ff020dd2e865558ce6553f2302c12e7df30379bfaf61d6c0d98656403ee14952edede12a9b333a17b9adf6ba3386c9f4ee8eb6bd7e3717d1e45a5388f864efa2a31cf5036bd9adc03fd07ef4f4365cc5a4c322aeff1bb5a6bf701069524bcfef36d37f4299e7aaf77033c8da012238b8a69c21d4ad6fd41e2149a2d3d4274bafc56e91e980a7b42d7533b9c6cc37c064f6d140ca7ec2b9120c26e8e809a7088a9aee0d168b89bf92a61ce929ab4144c19d8bf7b9443d8983b6773be67487ca500d6677384b4e30740369299e250ee2c29ac9c8b71e18d50161bce9aa3c1bf3dacacc4956175ede0aa31960c451ff50bb22c9c81fcdb535aee9f02037ac50c7b227fc34dc489251dea10d761c6a4b3c64ad3cd280f4bcefcc71f47f7ab1209f1718952be3e3f7632a86ac72cc57f790a96fb7b993634f0ea6c3c5280f481eb3061c387bb18cc4a783a4b5eb8b75d65403c89cef2e6d3895ea641d16d453cafe238b4bce8bbe0eb0cd5d7319dac888de89e7ccbdd716490a13dbdad3efae4c2de066d2a97318d93ae2022eca3bd60f85eba0b61ed016b1571e3d8dff35748166edbe48c5bba0199a9ba527c9cd1825f58a8c30e3f4a499c40c8e583a186b8c8d33cb48c2394ebcb1b593ec4ad927bfaf6f93a8004714343b5e3efc5dad6c49234609c8e4fab0c236e2e779c13ec11fe397fc180c5e251ed3871fe5f0b72dcf2e1126ff34d7d32f11e308d4e0555de03d13f87d0abd232e11228677d15a793ee437db0e811a3dcdf4d4cc04781efd926dd20a0824106206f89d4e984aa42e9c095603ff3b923c25aa375b4aa219d7789ffbb1f7630519f743db8c1eede1660a1c5a6d03ecb620a6b9b5ead9e60a92f418422928b55a73add2b448d6d758b61f2e5160fb5ec6d7381aed0b0d045e979e6089dc75f3739b87c8440cdc8a7c322253898807a769b1b2116dfd2bd75745b7f3bd2c9c724e28bb803198c2c5519030587560d15ec29bdf4806c57315c754c60c6937977f9032fbd674278c06b6dd0db50332f0a89e4e24d6d41295f8c6a37642d752091e9d2e1ad8def836b4448750503f2f984643084180ac6a7a9becdbcc383602961afca96170b403bb2ee830b46ebb0eafb0e97db283cc6bda1c6ed9efda12c561530de6f9d97ee7fd90ec38b2a886ee886a21e8f4d19b52468b87ee9f769579d02d71d213a9614ec834184a441bbdc65ab45e1984a75e53074538b84e7e5f95dba1f9b459ee0f6ac62a214284dd2296dad493385ab04f595bb85a205de4919dafa77015c2a7325ef89e7b564b8a9cb2a9cc35fd34e537a29063c79db5fa6eb4662e1b5cb4b26f862b75cab9136f098dd1446e3a3427fee3f942191f1718e9b5aa7e0b6353d693e9c7cb1f9b5698eb62c975a59d6370196cf5da94af4345b09548267e4a44ddecf5b10e00acbdae74d4258080fa983c86249fddbd76f49232226e576c0c5ac78bd18d35fd28d7729a3b2ffe6da833478c5f1ddb352fc7bbe5ebaf62049a2587bcc8f52aa71c9dceb2160ec5e8841de39c43872d573083a8815111583ae86a2d44a2b6c25a4f7fb02e0ad52213e98f877b071bcdb97fefb86ee7dccc740f806342c1a1ed167170c91911392c5013a873d764b6bfd17ac5f9147075c1b268223f87d7a5abb16896e46359544d603ad1961d4617579023c45375e343876f455e3ec3f52013fac8440c21889abcfce740d9931938de7e6923da078344964fa837c899e98406e4d6ae5935a6f01707ea28afa02319866c9baf47a473ebdd10461bdbc818e47c690a7994b3383d03ad83f87ba2eb6c929bdc6a6965865c4a493a851777d008fcb5c3de3f8676430b9cf9c5fdfbc97b47318d1d913aa067cba6cabf78d8f06fee3150598b1131ba81ab11ae6f0f86f39c900eb233dd6921577917adde72aaac833e0dc2618261fb88d99eb61dc3f4ff9b728854d9116764675d12b64b8389540f2d1c94d14f5d99120debe92dbf2872de0e0c6b90bfa62d0d7e3ac0e62328368ec5969e950e682099ef7a3861f9bd9cd1cf2e492fe50801d1250281fa14b5fd8f30b0b003365e2a2016dfe79b0f8fc9d2f4b3e615e7cc20f4b2ce8524306523651e82342f14101523fc184382b2a5d7d4db43a17659dd6747f9ef1005fd117fcc8f0b764ade0d94d0917d097dd423a920dab2b60f22c336618ae578595094e326b2bc1c5b8f7e5b3f774d02ba2391341d0de421201e8afe5cfa2649c031ed4008232f35c022046f0d3e15f3ada19dc1444e19ec9683a5320a04de34737946dbaf4f59267b67c9128d2d1e223d07b6f8302be5a9af879a2fc81b81c05d18c127efc3af5f9b6ef166cdb9533ce947cfe5e3ec1ebc5019b6c60027af66403cb671833b5af6ce08b49d8550224ba94748c2ad26600c2906b81e18e669905f7f505e265c14ea913a6e8e661b611a6be11547f70f7770f566edc921986fd53ec9dd1eeb826d9b6a38a0cea5d65eeebad31c364e627b7cdec800a059be7de5a2bb7771e4edb57d25ea99e3c27bdfb18b1e4eb11f20226de31a784f42f1be372d574c16ef61f33e59c5748d716fc2b96ebf7d27ab67b77243706dd52feee7d54049fb3b492d0967fcb569a2420cc063e3f540d221aa8b1798db74e133d83cb819d305ecb077546bbdcddea0bbeef696cfdd342a06f647c381a5d9bc6cebb905ad6fa6177580ec11f317944a0d95076779982aae4e530c537357c12f77c5fd3b68383b34afbafd95e203555155aeca73d4f6c9ffc7baaffc1d5c97c4accab71c6ebec352115c2b74299f8acc0cdda19fe0d91d612ab5844aa4ce94bd7fff72efd5f37e5ef7d47d1c43f9ff398014bc756b19a85f26a3363fa8e9d0038ed465a27088c56f5ee38e5ae617aa95bc3993e84331b4e061c5f1565098ab6121b1f940e4b0b61504d03b83d5ee51edd4f19c71c09933f8116016ef6a93b1b970a8f5d308f4a0ca3f2f31088b0d2d755336f08481d32f09e0ddafb3b5fa55a7664f9d51019527a0f44ef52498906382e6cc73915c91ffa1c89151befac58e2f36968b1f38166b891812d6168f2b1849304e5a7111271924a43248b962dd08a6ed01032635bb12686b377c51fd6d2ef19be5784e652493ed8af39d28528fd1f2231d5f35e0aaa6a6f5b9bcd30aa9cfda51564b2f6628046a785874ab78398860cb9a47e37ea7da6bbdd69e28ebf8da0ad2cad0618ce7f1f94f4f224575399649da67cda1ab6b39fecab04a9ea8d6c781db6ad046e2e41661fb1160227306412bafe7782396f75a2de1befacc58bd81cc9bb4520b760a8d89a09b157bdf219fa9b20808d788544604eada2a49b5835aca7e3fc4261cdd5bc9f816872f0b9c314ae4671d753a3b995d35d442371a516aa890d9d4672b6f690844f93b57575f075d3798dcbe655fe550363c8077ac7e6cf367f54e189291bc7d79e01ec9a11d445b7919c2238db8585b8bb01ae3e4d20f21abd324342e04b8e7f662dc509d68d7e40758b65fa8f91c58c373fd7b9f52c2cd9472784520e6f6432139163e7e84ef22531e9a9cf3ad44aa1282a81d1a59337487edf41f532bc73557f12a28725c3a5eeed5e9b9a0594a631b4251a626a5885e560cf6f7106ee455d6ab74886e9611f8aad449d61fba7c1a4baf4b255d7e15cc26ef6b9316cd40b2f8f23593c7d959e590bb4b39adc010789c2a44b8b9ee3219e82509c9b259351e406b68fe26b7cfac5d2549cc30c06bed66ec10ed8405d4c901c676d1eaa83d1f6b06cb8c1f2ff630f4023c7823075f7c6d1759dc6b9f21facf9077db2748edccd0f79d699f894d33a225ad54b00945530979304230c84c2e48ee74bf0f03a028facefffa3654181c8a21c1d26f6d1e8bf380849d800774d10a1f425ef9743038f258a6885fc380f8a65f342a28f3a68fcb7b52a6ece1874ec68d7ad627b709b887552bd78972ee6e000ab993bed4c5370f0dfcd51c3e65b6547f16f14a323461a76b239e7b33ffac67c42c2a02c5aa99d2e880600a523f99a5f73cdaaaf29c5a997568a59b444ab26052c94a68130d10c22e3d0b923c5fd8da4e4150ad17df9b8bbada351786e6352bafa93e6bd38da1e9670394cb47403ec2532ffa71cc243608de454148a2aa6a6370e468c983d6f4072db5160e68bcc6ee2e62a0ab3d2cb1a7f93290d9441419ae5ce167f575cbb73a08bf2baf190ce73e6cc53d9ef35cbe9c8e1a5ce05ffe55fcd1482ba0d11843b4ac394e520f111a98b7141ac14cf69d79215d04c6468f93b53c1e79f425f2104bdf28a07de04b3dc93e4e6772c13e6b7412d35eb087b98d8b434b1499a890189e29eb86c6a6baedce4feb8c2b12e5691bfbeee6b0ef78d1eeccd67e86015fab45e7f419e7c264bf0adabb4d3b08dbad48dde55c9e80534f033a15e6c02add724baa68869dd468ffe034088a9a367eadbc1865d0b220c5c9d1ac4f045f0cced8e63a84438363d55b558c28c94d32cb639bf6704bd8c46d97fc01a894ea337072065dde6bd89fcaf90c9df0c57ff0cbe2c39341574a341a3cb6ef5d73f5faa4a3cd64416a13c924f7ca59b1c3a5c42b5fc7965da0f1476a76127cdbdf22cc16f99a75cd3b89e3e05b6edfd5b152d2a4767dcadb7b8cda378243c504f9cd774655fdb1ac7d11ae8758da48e27dbc0bdad73ba461c522daa6d72c97848839331f42f8b593f48e1e838ac2d5be5d5053f83966a093207d464ec006f7acf9331a7c2e68e4ee906239b1fa2ffc04a659c08423b23d23eee440c726ec3d368ae024abaf6c9a4e3be64d4685add4a455fde3528c9d5dbc3079d70b98b877d2b85cd2539de9109c6279a6899c31b7e8efe796321f12f9b9ddda5970fc63f3ff411702cf7768859bbca09e106ae81f892d9845b29878f1a16f11014a58abfa1f9666a161f2379c0d9d0b4ba3ce76251101fe7a683a684181076204295e3d8ea38291e8cda08aedf39e3c7c477a73236d90e0e38d979de59626d668318f87e344a774de806723a3def342851c7be6f0221a3fa8ef79a949746cd6767b5a9d5888e9e19bb36d570d5299ef5bacddaa71489f8bd41066fc7e75a5408a567b980e4e0db0153c5106e3fd5d7ad721e47ba6440e1c07d17e218fab9836a233efb7968e80f14f000677a2b72df2ac9dc31d2d86f625cbe8874d7b711a534e8229c8e1e724420b2ef86812c6115b49379e033d76f9400885e0f446150eca849babb21cd244a76d5fe8dbd2b933f47e3809bee3fe5a2fe47b3025b24beda2a6d89baf4fad0ff81c75f369adbd0d6ca6539b1054aca27f40fd27bc03dd80bee53b7a2de87db0a2b1c22586ef5e713a285e13b406c6b0f77aa1a966ffa1d705ec6ad25881c552817389e01ade88820b04122fd960a6aa17e70a349f6ecaf1fc38cc491150fb69e1ad318a8b12f4b5f38230a5301928196937355f46a1ee35fd7a414d486792147d5e3367cb760f6838d8b9bdcb1dad3ac66fdca307d6c97d9079cbe7ceac7f61bcf90b846b25d4bd7fe56c1899adfc673161c4ef1870cf8bf2f48ae213097276393a9f34fff82499b3425a6fab20467775ddb8850eb3991517ee864eebd7f434dcbb05c30c2929281fd009c180c2b375abbcb571b244637c44ac8a0420bdbd5ed60f71dfd62866e02d56f08ce8c69aa74751243d0405034d725be1f97fdfa74d014c8188c8c48a0a62aab93c55d0524239d0777f665b9fa49f271f90a9a824058a97f0ed36ee580ba2789f68711b458540a0174bf9a90e585b3e84574e7ee1f3f4acbd2598f1b500bc09ee5f29ac4316d4181327daf91c140ab78d1d0d1d6378223acac62bfd487844704f844d366dcb66b36eb95edbd5d8d839ccbabeb17d94bc11b02dfceb6d04125b2dd9404a60b2d1b9186031fc93dbdbc7ab7a9dc5c4047a19199a06c72490a2fa0ed6db98ebd47ebc355e09b1e7996a59335ca0d3e8e56acb5f4dde3b525b38eff1cca932b7d16db88d174d269d7988889a442ea8f0fcc3f6a881bd3699483d7548dc1db57a5e44085ea946448bd0bde04e6940b1dc804b59e00fd05c83c3d401a8e185df2797521ca774b4b10da23f14331d3655a811af0e1b55c5d6eccaca2e30e1612100d218b32e1daf67970d47a6806f76fcb39ea3f434b6ba8742fcc6c692b716bdeb0108d8682ff8b3f8d7f1f7adbc81e8c42d1c5cb0acc9e310e6aae72fbb59f8fa6b487e4cde232870570a991ae171844142c850668479be245bbf3a85eb0d3d95b989fa13ab10065c51b2241818a28446a02062813a089cddbb1b805912a95680c5c4c6185568117eaf83cc7fa543ec4524af132f89fc71574d672b5c50406a9020805073633288582f270dbbb36f63ef95c27da4a44ae4ed03889f777bf0b6450062bcba48cd0229de187f62f1e453877e4f00bbea50f3f2d321f20b94afbae1312b4899ef5f927ff0d7db538f770307ae83c649b226cb5879cbde236447476d213703765a9c61d1dea4944dff8253f0f860fb2b57cdef3e9c1c48d114f6e3ebbe2df0f85b7591f34479cadfb877df4bfe005153246a1bb1d4f7fa2f3563aeb2bcdf2dcd80fadef4022146015ea1b4940c03fe0e9e0a5a8e9dbe52933065fc3f25f499b954ed65cd22892857e4266c4913f99df14b652939e72a62b99c5bd0bb2ac9da15b28bdac6af82896a16a101802d89e5b9952d635b6ef58c0ffd3729c9521e9373828f4f0d260fd75415dff1776032a0f42d4735f02c724cec0d584236f59214dedc5e46aa39a08dee17fc9f9567c46b618e1dd14f26f355107092476d516125717dfa56f243683990b11986bc1fef9abc8fc05ea9f82beb47524633dcf18a14039c6f16bee3c74ec21dbf5df2ff4862bcd501eab34dff8b63097ad70aa415646e06c8b352ff40551e94dad911b66b3611b4617309583aa16879741244697e2b46f92a49f3833e0658a036c8d49b999c27ae1308bd03fcd5bff383c3d3b86b1dddb09e2b91d0727aad75d2e4ecc946ff0044c23bf3b002598bbc02d422007ef0e94eee1e19430412eba5bf59ef08dcc62f3f4ef6f6576a92275af4358f607b5d11df266fdb1b2bfc4d5e8df5c38d6efcaacaca307a80f26e590e05658500e45f95adbf7e84becfc191b08842d664da676b1ffff7be07027b682e813f82b839a7ded206c2d39c271870bc0427fe18ed2036d1b229faff849cfe5f1f1254eee1829b461c004b810508bf150ddd7d56e7a8dcf3f6b4c34d4ee65ae75dc3208d447db3057be5f8eaab637caa5ce59d99a8bc84a75be742b81acc4412304480ea99eae0e8da14a78762c8e9245ccf0dfe1adc6b08b54929115904ef0af0a7f1bb6a530aae54bdb5e9c0cec048275992e789ad769c868e47d7d71ea7fc0edd9184d9b7e593cfd3a10e57bd35f16164442694ba59ec6592e639b2862b2895077980d789b6044ad9d2274a27f8c7e7fd5353b5c39f8d9fb668eb7ff0e6e25733292212dab2abcc1902140854eca6c50f43f70cf9c4dcbb0eb51553b2acabbb4965a9f78e6cb92c4b3e74e5683907c7e9c4e028c7b292a5162308aba13fbc30c0d0456b12dd23befb0f431f7385b025b1ff0487f7465ce78073ef4a36e1ac51a04070a66e8b173a976d48b81b5b1ad935563da3538b5d166876b5bc36feeb27abab15bc0d77ed96920532affb924993934ccf85b7db23f2320f0b8ab19aeac7276b8c1aa72985536ac100072313c01001d3e27fd1bc5614b402a78272ff80d5b9e7910307b187512c27bb1a6b8cdbcdb12593e1f990981edb7c80cb6de5b2e7f8a6cdf6c3cf1e27991855471c3cac12f9ac38ea3385a445cd3785241b60b2657520580d5e3515ffca470c303b0ca3536f3f8e605f040cc1011f4e5fc98b9768a612c3e79400bcff966c2849a38da19c4d1379348363617dfbaae49c8abb57f61a9ca16d67a59eff76615e6d03bd285f7a1a2314433f5551c4261b54eb1ada8dd08b2bd0a12dfb80f34d3a255d6bdfe6a62deb72867526c7c712abe219b7c698a9c5a1ba396f33174f9a511c881dc21fee19be9cce168b84b9473c6512055b731f122e77206bc3757ffa1f81fe2d2717efc533b7989369a58e5b4f8ea20e82116f6db85e83e52a3c6cae08e61b32b92c79917c8275d729ec25eb428c1bf211afdbc3a6e65543723304027aab879391fe379c18e04016a9e014fc4b90d22b93d8a9c31ce73ea0e8e4b3d31679562ea955f14b70342fdf29ac9a2cfe4b434a4f6246f27036c0f26ebac3e637cd771d99292cd0f6dd1bdbfb716cad87fa7ab7de5bb418d99b5f1425d822486ff67ba87b4de242a855c3e8252e2704b4c79ea57d589649711dec03f2d21f6acf2497bd95f09996fb91c0a038eb3926e288100b804a3218503b8c9228233522d708146f6e5767e7dc437b6254d9db7ac6f7c8d44949e27d48a889ff3e91f60848edaf7c5bffd2dc196a4b5ab93e20e3718fb2ee35a8654f87cd564b0e5101cf63d4b9cf0595906d98e1fe8093ca18518e57c1db69342d7bb735791c43a3dd4f4ea254edeb75c77087e6d91e85a17db4d023807dbf64e68c0271f52962dd22503c0b5ede1d1234741dab0a61c1d897fc97257683ac520f96ca508f125921bd0fd5253dada38aa877cca24bc79e67f6afa5161dbfcf9e80a639f92fc9c4594a4a6ae20cd16e0a9cf8872d1a7d334e95abe49653c6c06ccf531ee498767a5f1d28018deb353d9e7ddc02ad44d97d3501ac2a34d78f176ef872d9efbb7333000cd01417f02b4f9c0ed61b7e1da910d6b7418f947f31c6fd535ccda2188075f1eca6068e830003979d9aba772c18a3bd6ef42ff6c7c2e4776ae5ee2436688fb58757a67cc855a36b121c2dfa220084956d744c62e8cc73a389d659f2a972472fe206fd1452eed71ebc3b16d1651d840250b14fe0c9b269f7d34de09bbd3ef1f4710f1e512f7cdf7a6c47a6228b70c44c4057d076c4b4f588df73c32740d291e3de56c722f8b01204bc98cab709f85522e916ad89e50036a3a4268d8a85c7cb725a0dcc2becdeea25859f46f516efc1820ed2b7e79d9bd2d57ae8b7e4f5fd8239b0f873ef5495a8006e2402bde6ba70342f6728d930067e972d327009f95e64e38fec1df6a5fbffaca6072c0ac9223355bd9bf91a6cba788c99bb5de7479bae95b7d1cb4ba712db826fa2136e43594ae8c44cd1d7b68eb227aa111706f8d110c47aa567608abc08fdb4b9783188cb511d2ee9e473f76411f1a6165902501efa92e5b4838a8d8b9387513ae61734114e7dbce8b1801e4be1e8f95776783db2918f799b7158029724d6f9264d230621304aaaf27a59a91b37a1db5de6b5a21d72abf67ac9dad8b7980343c0325673bb1995c12f71546806f4800de4e2b1b4591f44dda483b6897e04791e27544d8b9156321a5cfd81f1b65be198b4eba7243ee8955bcac00aa41a3cf6c704d846acaf0cb9faaccb27347c7e13cfd5b21aa4d89adeb412f8697813360089369a57a0978cae358476c6acb67f58ab356a3e16c6517a236ab51f4009ec70c6e4ed3d472b4dcce5f098f7d78db5f4b04402c17f9d52946dd5ce885583ff614a5968bb2c96d08641b00dd00f6a8e2980f52ffddfacb24a5013c34f5f426cb45e40d0670ac15e8272f9b1639fb07f309445fb9f61909266700bf10d69762cdf273ebb66a39aa0f620312c1ac8faf801c44559d85a00aea0cfe23771c50a26791674bda447ba33e5c4b152eb5ab7f01a449953b4514e1f97c3da7647e1cf588b7d4dc95b8407cb33fee4c912294c7198e0acb901d3b70982fb491e3f768d3d116f2985bf539e4836307fff806fdbc1927d58dafd5ccb94c2427d0925c2f3692c746fb8137d5681ee65833c55371c563588bef306f07359be327dbe5181cc5b89712b06a2e99cf0484481e809e8e4a62456812a448dcc6c216635661ac242731d8d4a1f433b28ff09b1fd0ca06a9b43e77d57bf19a7d074fb8965f532565ec09c709ba4b9247881a7779953493b8cc8748975dbc4dc4b2a5973278a047b5f0d93f223579056a433e8b09f64a9e8a9a1d9a535b1099c544d7ce9dcbce6f1c596b1f024753f4d5f1fbed7e8d634fa62c741904e5f68be2ecc1d08fc94993a318c30036d2811561311207ff7eb1100853a817ec92cd4205b21a6958be6ac1d1ea0b0a917685e3bd8730679dd7be81b23f732f84cf266f15b97c2f249f0eb1ff281be140fbbfe104610a7da95af0b48e5d6d292fcbd21e09b89f6a346c93918068b3be060b443d12c234c1e2344fa0e097994bf2bd27eeb5d0706dd6419476d35bff62e40ae845e494471505af09f1bd9af42b29dad700d151fe479f1783daad7b3868baf9ef6fccdd2eb4c7b8784a062c4b2f9eb9deb9f54d7c42bce63a85a9dbeac7f0592e576f808555e1c736a5b7fb4b676e6c4853de9c3346efdee7427a16976a9f6ffde45dd74e716819e123503e7ebc71ee0db64a5e6b55f009bbb929d499c14ce63f785ac289fc07d007bf2aa48af3be5b11b88913f89fd9dae53b3a61a71474b10475b3f2c4a74dbc9452546348bec4e43f3120e0eb478286a6fed37aee38080cb2833ae9e3cbac19b90ae49447c6625122c1e3b6972116835ec8de9fed6461594fe0a99a9a1819e69d448fbe3f7f0b0fa1cd3f7afd3e4128874cf44c29d95a5ac0b35718a6330c0da1f4c9904facb0d387b900842325fa51d6772ef60a2fe36f9884caf37d27723c2993318b20b372354ff03110a48a0da5027794b60d20b2326b4c7b113d9393e9e69aaced1887cd93b8cb2ee88b6e9deccb766bd20193ea5400cd74611fde0de720db326cc3f55ad576d2ab78a8b61e891fa2424dfe6ec17cde813fa5ca84e61dd9fe1b1aaa2ea6d4ca86c03ddc41f7b9c8fc3a78b461936533e5ed093509f98457d29766f89cad82d68d56ed15dfc0109d820e059be9dd37a64a4e5968f36476f372ff40495d174c49943e13569611e1124b499b8fb8b16b9c587e86b132e11db7f32d139aba16d0e9e2ade8f2c4bb8c29abb1c3e83a01046662628c3ae7a103f804e5ba5da7e65d4b00362af6d5681eac7d48f45df72b2a2b2fdb83630d847911239d36cc9e44eb52ee7b51616ba85c4bd05e8dea2649f36e847528dcbf6386e52429db9c77c1843044d11198650d94d0d976cdec0bb77dfc4529e845890cbc025e90858dbbd1f6306fb9ce6717afac55f0a39a85a66d0067dfdc6179d549a46041d2929c0bcabd2159caf2943985e3fd2ac56bee4067f05f61aad7016d329515897a2556a52ccbe980d937529d06c62417b88b3d603651ed71e86925c4dde476259b3c6bfca5eecff725e13e140cc0e1a83932ac813a08bc1147f09e6d04a2a9262e9a50ee85651818d3935eeaf8d4c4518442aa0da7ff9f63ab04736072bf32b6d7f7bc89c35500a97aad7c916910c7b43958e36f6a668972004b2c9eb2f09cff9907241c3f8e017b97b55ac5aae6508ace0894c9578844502f1be8234bfd3e39a9b56ecb793eb029d959ff2a4f3bebf6167ebee7d75267d41084cd1b52af86d66fbe93cd45d0d51a202f295f0211204e6d5cb4d5a59c5a923801b2ee63677b154a7f87c4d3ec16146b9c2bcd8c518994b09dde7845f6e9fecb6152b400e315aca9560d74fb8c9f9be414f26afda17467510ae16fcefe780a3fd5f29c9e1732eaada8068f95f3d08773637c82a3a3f0b860d7f7ccc9e8a06e73773ac37ad552dda7616be9f7c42d59edfba787fe866a77bd1262e87128666fe9dcb98bb09f29d59bd3da55f8efb78f4b2f476bb7afac3b8c44a34a1a3bfefca0d250f791807f648a199a39fef2d96e4304af6641a8f441b24c10c9ee720d099168c00a9fd980835299e51e24b7bf1d2dec08bfb0393ee53e97782c131832e4e33dc07e03a8e7353c7baacd03edb29070899df58be33fee734436f40736dc97171a2f2d78a3f0abb43eea72ac32b5d17b1b0c9edb292fca3b0c2fd3acbf3042b35b7a1a605dd0107f86ff08c0c956e762860a0f2c3dd58b7ccc52699fc57d65f7fc7ee83e6588bfdbf1d61bdcc6a071b9a6f0e56d19b2fc93abcf74b77efb9638db062dead658ef0d13b931c1414c4a9e67dc1b9755d63334ea29bee6fcd1c711bf1c03185d194ee73d5d0860c7a472ff4613edbad2c15543f91db8b2dea9abb2d53feb7799059d4e905e818b42f83a239a47b3d0bde548a27600dc1b88fd0cbf2043273b7bdfbb8281df024544336adb4263db196c138b98494f301d39f8368737b5d7b64b3cd78c29c31b247e460971af565dad1778b16157c8178095d3a0fc1c3aaf53c92ad8cc5446a57c236a3501f0fb8a2aa14194eb2e0c8f7c082061395180f520c76f66608fdc8c66fe055e7e106e62e8ac168208550ade23319b4b3881f85b53d56973580ce1bad1e39e76f48597843247d4f6d3066f761dea633a752fdc56225f5a42d8b742e44e43ac26bddef8f89921051f79f4c390e00edfa2ba273255ffb8bb0ee27ed6218146e4a775dc5b55f8eb7fc9acd3c22852304d3bdbacc5da2f31a539b8d496ce9228ef17dbf70b2330f2dc88a7e8761c99b313d88a6c7b44723fdb306457e2c1c425ab281d89e3d1134e8362a4cbed5898222ab010353dea8da53f8ab45b76fde64c6037682fde1c68ce21efb062750d180ad395570eae98064e3351498993b5505047b9181a09eb95d464aaad7e9292a1d7b5cd003e6f6ab2e5ccde754eac05b49caed371c3d4bcd96018f18031e8131cf722e42a1f35722d58996e432b17c3d69aa209e82aa1e9531f000f9d8250367e9a86fdd77d6fab3973051a896c961e617e84b90834f69b2c967224cdd3cbef807478f74745bf1e7c84b6d2d49ec06458f5c0aee85fd7987a7513cdc7545f656b1b8ae3a4eeaa400b6f6cb6b5110e011fb44a1b01fc61d0d65622d13d12894a4fd794f4aff99da4889073ed944cd50ed6c38aa5c0c8faed9844485b7cd13a60087e431116d97e6c144045d24e45b93aca28e39e114757a52e1b713f9eca564efe1e964d25d892fbeacb27a23e0f302f6eafba56983a32e171938b96564284d427c5c142c4632e0bce0303753252012935d9b41de3e96b665fb3543587e49f40476a8cbab58707c6daefdbc4b826be5c4abf83349701878962f442207954a44bf8ca3726d6eb9e490afe0f2ac83bad4950352775546d44d55c9bd5ae5ed271f8f745242862dd8647b8c47fc9424bd384418f6a806474cb14f1e20cc2387962c7d7d2b4542accbd944d9a0666b9dbe0e3bb8aa801a7d5b39940bfdd7605885faec096182b2f2b1c39f9411541e45f7b9cf360c26a4259edadd62c33023d6221380179b1b0f75663067e0b206705cd10065d13bd1481095d95fd5ee54a9f7cf49b560966b9fd3f9e07b77858ed846dd8eaeaaa8697949974e502a4337c0b5b64af25c0352862aa9c49b1ac40f8adf4600342dbb37094e69239d8a11c9cfb59274a0b375626f4294aa30aae0f40bdfe2076ff0fdff13d8bf1da3369e9df4b872a60fee4fb03432ee45ef57150932c21183efc8d77f15591cb645bd768751e6846be99f37dd7a816ed20ebe9dd11cfe095281408d1b910903e95c108025e626e35837ccf7c627e2f938f16eedc93e1dd2114b6dde0414cafde0c4ba40c80b80893e8d1050e9a827aab89a186258c3ab2d68eafbbe39105e22537c3e1b18a99b6901f4ba5b4b58e5bfc7527fd098a879bd50f8de684ad4c9c43ea64ae8b2ee8e75c8abddbb41092b3313bad1a71d8526292b3d45468f0ec327d6b0635f9811d0ef8fad0d660d493e3d30069231448195478fa744fbd6ceffeb8aa1017e88055bbf9846b80d9824f1dff9c3b0cb3275bec7d84d52db55b4258fbdf268899a5adf2be260f18e92449d049f38315f45da66bc0c8ed2fd9da65ba3313a46da1f0005da1d61d6ce1fe6ee883d9ab4484e2f632c8fcca97f61a77ce2a39d6c17024c72c6d146cd18dc43ea2f8a3cffc4e0eed8e6fb631812d942c09ba2d02188f69eabbae9803ebc88a9f4da3f7c58352bf1afe2cfab1d5a8fca0c0100e9ece143429c492856ce22db933d2e6bbfd77c2579aa5affde7a4210fb593b45fc640f3f471b7869c8ae55411793ab713e4b33915f8b7c0d570027f9aaae7069eda2f4500313bf25304394c662f70c160499d4a2cd1f973187379b0342c2512e80e8913765084b612875825f6cded59a1c328e898bda61f5d052895a54d3355a4cd3ab1dba034d2586e08b8173e6e1094d4c856542f93243fb2366d1bf4579df37e5a9fad1684655adf80920161f26c172156c91d4b07d906d2677073cf3ab983d1a53dd149fb718cc8a2d21c55aca81fcf1fdd3e4bd21cc7024e940f78facd4370e1d440ab1d1f761fb41814f714c012c025cbe1ee85474053c3ed70b3bb2db4f6021c9835104984fef216d5155d8659331571b77ee895a9705a666f3cf7917b60bf98a9d9bc3c8a9c70129efeeacd00f2f59e523e54e123c900b0d9c9757e3a0bd42d179e7334a1c1d084026095c406bf9968586473e94dc5c9df535301e724b08e42c4074378fc3d709098759ea7091cd973b544ef34b3bc9b94dce5edd5ce983d0f0c2029f9e8129f30cbbf90252023e3c62a7b2a92d051d40250df96b6efd365b0114e693c29334d53b266da808e660ea7c9be1d3e32902777655f3532b960f62226175d21db4dd9f41532ca1675c233ed25d527e22452c453dda3a3058912ddadafd0ef949c4016f8588898884c9709f5ba4cb61dd2b37122ccce0cb8ae39eac6a01d7ab082374d42a729551cfae6532995affbf64198cbf3bfd13b422c0c9c71245e9517e2ce251c0601bbdc49fe96d91f78574bf2464a049a5b86897416ca0646e19125bdece6d079269cd88e679c7f1d1a3aed115abeb98400e52fd15b4480aed9e18a164a5cb587617c765ee0165489f99e7e7aebde6136428d573abbde42f19ffb907e58496da1725e6c3c7db345d9ee14a19bad1cf4e9e3c452d19d744aa8626023e441ff2dde7be161fcd9c16f27fcd4c3096877443c39c6415e360cb3f3513ca28e5000f35f772b965de0835da216e7248ae9fa44425258fed8a17e2777bb5be1e335f4dc422af8273303bdfc86b2bd4e1f65eea531ff161b3aa0abbe596f49030c9ddbfa30966f4921b2226c5d40fe3e5e9d5030f61bf0f96c98b228e2e1dd1c61fc7e47a0234158dd13ee18ef74245b822e0494b393d480664b9daebb668977d5ab4d9d1e76807484e01c3c53f187d304b3df597bdf1788618fe432ec3f44c8cf830fe301579520c607e81a5089c04630e2cad775e95fa62caaf64079893d86152f935062950556caeceee2b1706b26a01275ff9fb2e6377efb1b5433e6d168cd3750fac0f3210a921ae9771ab682e63ffe95230f582b67658468bf82f694f90ec0e35f28765d355206323f0742f0346aed05919ec6ca8e486be654177334949c2347d1f10ee65c751ac643935d569e7cb1fed42d3d4203c6042fb430f6872188f8aa72ce776ff9f6dd980d489c0a5fe00c7ea6a18467534779b9c700e2d990e16699e2fd79ead93ac7406875d31bd599424bbc498bd76040f5fc9d496219eee819622864dbf368f0b81e3f1a76f8d1ba1e05ae898a13ef0e42574847def22502f6fbcb27ac761f9e4dc955bbfa98b3102a1e2865c567a6e71b27ccaaffa9b56d816fed702a6446f9f2b6ee0598b34a297cf6a37ce71acd76635c11c9bdb8fd46de09d91f840944a3b414b53d0f23f2aeb3d22515bb3059e8a3e5e4342b6eca804a4023d321b6541f3e9d57dc4f7e9b05afa25a732e08e151a2af2484146a3c6743366cfa7f071489936a9d5f4875bc811aad03ad44d0cf785f8a6fae7ccd351fb0f14b2fde8f0f2d8e19cc882a7713e7a38b825b03de7188140e66fc0aeb6b943e840576e8ad0c1f74ad70715cc90b06ee1a3d286293b755143fafe34c036f6d52bea95a80af918d60173c0192d72ee1f1f3108a5103efceec36599a6dc7ddfc37bcc988ce70a9145379be47795af44806984592b8b180d0d307592b62a6426f69a2d35353b40e8f7c61314d7046cc8ce507e5676efeddf29ffd0e05264aec9f1e4438eebad0968a725cc7e02646c70047d3063af9208de28173c3cfebfe03cce2b3efb535c5063a1f71614242e5e74227e8998dfff671c9f85a18e907262d6094e9c6e567c2c3cc3f639f183109d006df7c33c4eb88e67ed9f2f67fd9f3e0993d55b9fc7a5c93b5fd19e23021c69209cb634543dc4850f3ecee4f35a188eb0babee668415503fe8e920f31e8c9d4be03269da8f8ca680309e4ccf559329b1e9afed93d0563db4ad1b93f9e4762b54303b7fe921debb1f3fbdb25ec2f6d351a631f69fa1a22502ae198fb3e2c8b64303ff79483d385aea4fdf551fbc9de48b895348be63e32412de2d737387eb0893b8fcc9c70e906bb719fd5a6d7d44e7e5379e63490a18fc521974fcc5f48705ed852af956ca16164324a44ed30679bb017125523416ddc7c185720c2958c07bec637a9446a9c80c102eed1e1ae5b08aacb396aba63e9de2100d214801a1d4fc74200ffe9ebca44518a96cae0c388c1bd6603698e3061fb8d6485d3b3078d0c6d5af8b694a096c735f07dacd3c9d66cb952a60f197615264cbf6e756f1be67935ca55b41ab88074032e797a771aa9a05776876dd90f8ca9b32700ba9de984698a155dee40bd70d36ceab7bee73490239d50e6d0de13dd40723b944298ce7e811fa0fd5325d72471dbd4c5b0aba08d45592197291c28aec2f7c9a92dc09e663ac1dc4a915571268e0f6da0dde2c4300fd9560664028db165e6641517027f683592552efc2a54c103ae4c2f13ab969496a6520a0665436cd7db94e30c4e4039299cc56ce5b4a007f301ee81c38a2327a53014241dd2bae96ec0f2a1d3af87157b2b29266767b6b698d969790361539a086b0c5801cdb94cbee5c9fa50345a7fb13cdef881781f56f1d3f1746280b5a0432c2106c8e433cc34d87d68772313ed65cbb0cfc247133d6d1275272ce628930a5eab34b6fcdb87e6f67fd3bb93c36d91243442d6a0768f94720f480588fb5d52e5c761f5f4280940d341376f6e333e96a3c7f89e1613fac062d8835759637ba39474f3b368abea4d41793c4fbb9e60ec64c02ff2e32d081b384912e04e7d233e9ce799e2d1a0fcf73f498d5e408506e12e96c6558f2c17e231ae5c5bb19eb107710c3f3be76ff9110408f44af288a8c2a255f89f7a0e9d9e0f69596a02c3cbe907f1623882bc4942557a28f625b3c8c65c89c78553958795e08ab6c63963bee48533d63e20ea981367f2eac74583abb0c47f23a621fb2b139b6e15bac63fd7b5294a045ab6fd04efd0631f2b26333ebaa53f10f9119dff0e351246950364c83c5aa50e3da87eef0341670e7673db0006c8ddf689f73176729271e7c8e6d06c87dcc90f63efea425e832ad1545818be321a9448e9ca0d1c43c19c746b638cafa41685cbebe8b520e62b56e83a421ef1ef215165320fa9e24d77392d3a1572acb1f9c42a9b0b54d6c534d75510c23170942704628c675d203b6f8c49c68a88bfe8a8d9fd954d32fae23586ca3a798f22be856a0d2632f8963c86c25d850751c13449d18861f5c271c073097a6cc944f2e4c5ec409db0910a1c607b26d8f30e4caed43bd0e1a9af442f58d7f244f4230906041465e867bb436c05f100f85135cfc08bfc6a62eabfab060a76182bdd3e6391043e8f7cec90f53ea609fde32735bc5bcf2b5d58a8194be97dff0e483a397aa32652ff8041b50398a9bd0b062c1b83c6f95a9029601c5323fd15ef2255a6c643a680381af0b5d194cdfe4221738df176f86057cd6a493b26858094159aa646809f3cec7b24ef2cebf36b9765c5633f1ad2caccd86e758152a19b730fb71da113eff46d0f099d277fee3047374d5a3737091ffd39062a25fcbc3eee90149216a9d235130d524b32b68675f44598945b2e862ade62c283983789bd3a87d41af2161f7dc9355843f9fdb05b2c82b2053e7cedc2e04bc5c12b461e75479605eed6bce7f61dc289d7a76eec7871d31c03dfa8a83ef0be561de09d98246fc70196e1ab0578385748e6c592670017a89e76f8b718eec866738db29dd827ce18ed06cc037bb2615c2189753c87443d6ca733934669708d313605c2931ce844a248b010038f4dc4b17857060759ce8c89e586988e59362f19b122d9982c358477a6cef3fa21ef248203e5b291e1959f65056b2827feaaa28f713cbd012ca31b36fe08ac367e41dfe7d8a7c13f8e8ac240a5bc77ed7244b286b24e769ec27cd06a985f07cab85c0a305bd30bfb14c0d7281cb881a937f2b6100ddabf885224e264f8b695bc67b82256f3a03519519cafddce50e036d2b6a207c963834e42f303a70fa131f68b3e0ceddf9f6aadde1849cfef0c1e29557b2ac6a2386214634eb59d94346f80a0a7845e178a24cd7e006848f76508b548de1f717fa88d5b93a380c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>高等代数</title>
    <url>/2024/10/05/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<!-- toc -->
<ul>
<li><a href="#抽象代数">抽象代数</a>
<ul>
<li><a href="#群">群</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#基本概念和事实">基本概念和事实</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#子群">子群</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#example8">Example8</a></li>
</ul></li>
<li><a href="#群的实例">群的实例</a>
<ul>
<li><a href="#全变换群对称群与交错群">全变换群,对称群与交错群</a></li>
<li><a href="#一般线性群">一般线性群</a></li>
<li><a href="#克莱因四元群">克莱因四元群</a></li>
<li><a href="#循环群">循环群</a></li>
</ul></li>
<li><a href="#陪集">陪集</a></li>
<li><a href="#正规子群与商群">正规子群与商群</a>
<ul>
<li><a href="#正规子群的判定定理">正规子群的判定定理</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#同态和同构">同态和同构</a>
<ul>
<li><a href="#同态基本定理">同态基本定理</a></li>
<li><a href="#cayley定理">Cayley定理</a></li>
<li><a href="#第一同构定理">第一同构定理</a></li>
<li><a href="#第一同构定理的推论">第一同构定理的推论</a></li>
<li><a href="#第二同构定理">第二同构定理</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#群的直和与直积">群的直和与直积</a>
<ul>
<li><a href="#直和">直和</a></li>
</ul></li>
</ul></li>
<li><a href="#环">环</a>
<ul>
<li><a href="#子环">子环</a></li>
<li><a href="#理想">理想</a></li>
<li><a href="#同态和同构-1">同态和同构</a>
<ul>
<li><a href="#同态基本定理-1">同态基本定理</a></li>
<li><a href="#第一同构定理-1">第一同构定理</a></li>
<li><a href="#第二同构定理-1">第二同构定理</a></li>
</ul></li>
<li><a href="#整环">整环</a>
<ul>
<li><a href="#特征">特征</a></li>
<li><a href="#整除性">整除性</a></li>
<li><a href="#唯一分解整环ufd">唯一分解整环(UFD)</a></li>
<li><a href="#主理想整环pid">主理想整环(PID)</a></li>
</ul></li>
</ul></li>
<li><a href="#多项式环">多项式环</a>
<ul>
<li><a href="#一元多项式环">一元多项式环</a></li>
<li><a href="#多元多项式环">多元多项式环</a></li>
<li><a href="#不可约多项式">不可约多项式</a>
<ul>
<li><a href="#本原多项式">本原多项式</a></li>
<li><a href="#一个判定不可约的算法">一个判定不可约的算法</a></li>
<li><a href="#不可约多项式上的扩域">不可约多项式上的扩域</a></li>
</ul></li>
<li><a href="#对称多项式">对称多项式</a>
<ul>
<li><a href="#牛顿公式">牛顿公式</a></li>
</ul></li>
<li><a href="#结式">结式</a></li>
<li><a href="#判别式">判别式</a></li>
</ul></li>
<li><a href="#域">域</a>
<ul>
<li><a href="#分式域">分式域</a></li>
<li><a href="#子域">子域</a></li>
</ul></li>
</ul></li>
<li><a href="#线性代数">线性代数</a>
<ul>
<li><a href="#矩阵引入">矩阵引入</a>
<ul>
<li><a href="#矩阵运算">矩阵运算</a>
<ul>
<li><a href="#kronecker积">Kronecker积</a></li>
</ul></li>
<li><a href="#分块矩阵">分块矩阵</a></li>
</ul></li>
<li><a href="#线性方程组">线性方程组</a>
<ul>
<li><a href="#系数矩阵和增广矩阵">系数矩阵和增广矩阵</a></li>
<li><a href="#矩阵的初等行变换">矩阵的初等行变换</a></li>
<li><a href="#阶梯形矩阵">阶梯形矩阵</a>
<ul>
<li><a href="#简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</a></li>
</ul></li>
<li><a href="#解线性方程组">解线性方程组</a>
<ul>
<li><a href="#存在与唯一性定理">存在与唯一性定理</a></li>
</ul></li>
<li><a href="#矩阵方程">矩阵方程</a></li>
<li><a href="#齐次线性方程组">齐次线性方程组</a></li>
</ul></li>
<li><a href="#线性空间">线性空间</a>
<ul>
<li><a href="#相关运算">相关运算</a>
<ul>
<li><a href="#直积">直积</a></li>
<li><a href="#直和-1">直和</a></li>
<li><a href="#叉乘">叉乘</a></li>
</ul></li>
<li><a href="#线性无关与线性相关">线性无关与线性相关</a></li>
<li><a href="#子空间">子空间</a>
<ul>
<li><a href="#向量的线性组合">向量的线性组合</a></li>
<li><a href="#线性映射">线性映射</a></li>
<li><a href="#基和维数">基和维数</a></li>
</ul></li>
<li><a href="#可逆矩阵">可逆矩阵</a>
<ul>
<li><a href="#初等矩阵">初等矩阵</a></li>
<li><a href="#求解逆矩阵">求解逆矩阵</a>
<ul>
<li><a href="#example1lu分解">Example1(LU分解)</a></li>
</ul></li>
</ul></li>
<li><a href="#核与像与秩">核与像与秩</a>
<ul>
<li><a href="#sylvester秩不等式">Sylvester秩不等式</a></li>
<li><a href="#frobenius秩不等式">Frobenius秩不等式</a></li>
</ul></li>
<li><a href="#对偶空间">对偶空间</a></li>
<li><a href="#直和分解与分块矩阵">直和分解与分块矩阵</a></li>
<li><a href="#基的变换">基的变换</a>
<ul>
<li><a href="#矩阵的共轭相似">矩阵的共轭(相似)</a></li>
<li><a href="#矩阵的相抵">矩阵的相抵</a></li>
</ul></li>
<li><a href="#商空间">商空间</a>
<ul>
<li><a href="#同态基本定理-2">同态基本定理</a></li>
<li><a href="#第一同构定理-2">第一同构定理</a></li>
<li><a href="#第二同构定理-2">第二同构定理</a></li>
<li><a href="#旗">旗</a></li>
<li><a href="#不变子空间">不变子空间</a></li>
</ul></li>
</ul></li>
<li><a href="#行列式">行列式</a>
<ul>
<li><a href="#置换排列">置换(排列)</a></li>
<li><a href="#交错形式">交错形式</a></li>
<li><a href="#定义-1">定义</a></li>
<li><a href="#余子式与代数余子式">余子式与代数余子式</a></li>
<li><a href="#行列式定向">行列式定向</a></li>
<li><a href="#克拉默cramer法则">克拉默(Cramer)法则</a></li>
<li><a href="#一些特殊行列式">一些特殊行列式</a>
<ul>
<li><a href="#置换矩阵">置换矩阵</a></li>
<li><a href="#上三角矩阵">上三角矩阵</a></li>
<li><a href="#分块上三角矩阵">分块上三角矩阵</a></li>
<li><a href="#范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</a></li>
<li><a href="#一类分块矩阵">一类分块矩阵</a></li>
</ul></li>
<li><a href="#特征多项式">特征多项式</a></li>
<li><a href="#cayley-hamilton定理">Cayley-Hamilton定理</a></li>
<li><a href="#矩阵的迹">矩阵的迹</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#binet-cauchy定理">Binet-Cauchy定理</a></li>
<li><a href="#特征值与特征向量">特征值与特征向量</a></li>
<li><a href="#极小多项式">极小多项式</a></li>
<li><a href="#同步对角化">同步对角化</a></li>
<li><a href="#上三角化">上三角化</a></li>
<li><a href="#广义特征子空间">广义特征子空间</a></li>
<li><a href="#特殊矩阵的特征值">特殊矩阵的特征值</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#双线性形式">双线性形式</a>
<ul>
<li><a href="#线性映射-1">线性映射</a></li>
<li><a href="#非退化形式">非退化形式</a></li>
<li><a href="#伴随映射">伴随映射</a></li>
<li><a href="#分类问题">分类问题</a></li>
<li><a href="#二次型">二次型</a>
<ul>
<li><a href="#实二次型">实二次型</a></li>
<li><a href="#惯性sylvester定理">惯性(Sylvester)定理</a></li>
</ul></li>
<li><a href="#辛空间">辛空间</a>
<ul>
<li><a href="#达布定理">达布定理</a></li>
</ul></li>
<li><a href="#回看对偶空间">回看对偶空间</a>
<ul>
<li><a href="#双重对偶">双重对偶</a></li>
<li><a href="#核余核与对偶映射">核,余核与对偶映射</a></li>
<li><a href="#像自对偶">像自对偶</a></li>
</ul></li>
</ul></li>
<li><a href="#实内积空间">实内积空间</a>
<ul>
<li><a href="#勾股定理">勾股定理</a></li>
<li><a href="#柯西不等式">柯西不等式</a></li>
<li><a href="#三角不等式">三角不等式</a></li>
<li><a href="#距离相关">距离相关</a></li>
<li><a href="#正交向量族">正交向量族</a></li>
<li><a href="#gram-schmidt-正交化">Gram-Schmidt 正交化</a>
<ul>
<li><a href="#example1ru分解">Example1(RU分解)</a></li>
<li><a href="#example2legendre多项式">Example2(Legendre多项式)</a></li>
</ul></li>
<li><a href="#正交算子">正交算子</a></li>
<li><a href="#正交补空间">正交补空间</a></li>
<li><a href="#投影矩阵">投影矩阵</a></li>
<li><a href="#自伴算子">自伴算子</a>
<ul>
<li><a href="#实sylvester-判准">(实)Sylvester 判准</a></li>
<li><a href="#实正定矩阵的二次根">(实)正定矩阵的二次根</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
<li><a href="#极分解">极分解</a></li>
<li><a href="#最小二乘法">最小二乘法</a></li>
</ul></li>
<li><a href="#奇异值分解">奇异值分解</a></li>
<li><a href="#moore-penrose-广义逆">Moore-Penrose 广义逆</a></li>
<li><a href="#极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</a></li>
<li><a href="#perron-frobenius定理">Perron-Frobenius定理</a>
<ul>
<li><a href="#collatz-wielandt公式">Collatz-Wielandt公式</a></li>
<li><a href="#perron定理">Perron定理</a></li>
</ul></li>
<li><a href="#实正交变换的标准型">实正交变换的标准型</a>
<ul>
<li><a href="#欧拉角">欧拉角</a></li>
<li><a href="#四元数">四元数</a></li>
</ul></li>
</ul></li>
<li><a href="#复内积空间">复内积空间</a>
<ul>
<li><a href="#共轭空间">共轭空间</a></li>
<li><a href="#复半双线性形式">(复)半双线性形式</a></li>
<li><a href="#伴随映射-1">伴随映射</a></li>
<li><a href="#hermite形式">Hermite形式</a>
<ul>
<li><a href="#正规线性映射">正规线性映射</a></li>
<li><a href="#二次型-1">二次型</a></li>
</ul></li>
<li><a href="#复内积空间-1">复内积空间</a>
<ul>
<li><a href="#酉变换">酉变换</a></li>
<li><a href="#正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</a></li>
<li><a href="#相关实内积空间定理推广">相关实内积空间定理推广</a></li>
<li><a href="#复矩阵范数实例">复矩阵范数实例</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="抽象代数">抽象代数</span></h2>
<h3><span id="群">群</span></h3>
<h4><span id="定义">定义</span></h4>
<p>如果一个非空集合<span class="math inline">\(G\)</span>上定义了一个二元运算$:GGG <span class="math inline">\((不引起混淆的前提下,通常省略不写,例如\)</span>ab<span class="math inline">\(记作\)</span>ab$),满足:</p>
<ol start="0" type="1">
<li>封闭性:<span class="math inline">\(a\circ b\in G\)</span>.</li>
<li>结合律:<span class="math inline">\((a\circ b)\circ c=a\circ (b\circ
c)\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>半群</strong>.</p>
<p>如果它还满足:</p>
<ol start="2" type="1">
<li>存在幺元:<span class="math inline">\(\exists e\in
G\)</span>,使得<span class="math inline">\(\forall a,e\circ a=a\circ
e=a\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>幺半群(monoid)</strong>.</p>
<p>如果它还满足:</p>
<ol start="3" type="1">
<li>存在逆元:对任意的<span class="math inline">\(a\in
G\)</span>,存在<span class="math inline">\(b\in G\)</span>,使得<span class="math inline">\(a\circ b=e\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>群</strong>.</p>
<p>如果它还满足:</p>
<ol start="4" type="1">
<li>交换律:<span class="math inline">\(\forall a,b,a\circ b=b\circ
a\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>交换群</strong>或<strong>阿贝尔群</strong>.特别地,一般而言在交换群里,我们的运算使用加法符号,这只是一个惯例.</p>
<p>下面主要研究群.</p>
<h4><span id="基本概念和事实">基本概念和事实</span></h4>
<p>定义群的<strong>阶</strong>为群中元素个数,记作<span class="math inline">\(|G|\)</span>,如果<span class="math inline">\(|G|&lt;\infty\)</span>称为<strong>有限群</strong>,否则为<strong>无限群</strong>.</p>
<ol type="1">
<li>群的幺元唯一.</li>
</ol>
<p>设<span class="math inline">\(e,e&#39;\)</span>都是幺元,有<span class="math inline">\(e=ee&#39;=e&#39;\)</span>.</p>
<ol start="2" type="1">
<li>群中任一元素的逆元唯一.</li>
</ol>
<p>设<span class="math inline">\(b,b&#39;\)</span>都是<span class="math inline">\(a\)</span>的逆元,有<span class="math inline">\(b=bab&#39;=b&#39;\)</span>.</p>
<p>这同样说明了虽然群上的二元运算有可能不满足交换律,但是仍然不存在左逆和右逆这种东西(或者说无意义),它俩都等价于逆.</p>
<ol start="3" type="1">
<li>群中有消去律,即<span class="math inline">\(ax=ay\Leftrightarrow
x=y\)</span>(左消去律),<span class="math inline">\(xa=ya\Leftrightarrow
x=y\)</span>(右消去律).</li>
</ol>
<p>显然.</p>
<p>于是可以定义乘方,并定义<span class="math inline">\(a^{0}=e,a^{-1}=inv(a)\)</span>.一切的指数的常规操作在这里都可以照常进行.</p>
<h5><span id="example1">Example1</span></h5>
<p>证明:对于有限集合<span class="math inline">\(G\)</span>和满足结合律的二元运算<span class="math inline">\(\circ\)</span>来说,如果其有左右消去律,那么该二元运算在该集合上构成群.</p>
<p>考虑是有限集合,所以单射<span class="math inline">\(f_a:b\rightarrow
ab\)</span>同时也是满射,这意味着<span class="math inline">\(\forall
a,b\in G,xa=b\)</span>和<span class="math inline">\(ay=b\)</span>一定有解,令<span class="math inline">\(b=a\)</span>可以拿到幺元,令<span class="math inline">\(b=e\)</span>可以拿到逆元,自然可以推出其是群.</p>
<h5><span id="example2">Example2</span></h5>
<p>设<span class="math inline">\(G\)</span>是群,且<span class="math inline">\(\exists a,b,aba^{-1}=b^r\)</span>,求证:<span class="math inline">\(a^iba^{-i}=b^{r^i}\)</span>.</p>
<p>显然<span class="math inline">\(b^{rk}=(b^k)^r=ab^ka^{-1}\)</span>,使用数学归纳,注意到<span class="math inline">\(b^{r^i}=ab^{r^{i-1}}a^{-1}=a^iba^{-i}\)</span>.</p>
<h4><span id="子群">子群</span></h4>
<p>设<span class="math inline">\(H\)</span>为群<span class="math inline">\(G\)</span>的非空子集,如果<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>的运算下构成群,则称<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的<strong>子群</strong>,记作<span class="math inline">\(H\leq G\)</span>.</p>
<p><strong>子群的判定定理</strong>:</p>
<p>设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H\subseteq G,H\ne
\empty\)</span>,下列命题等价:</p>
<ol type="1">
<li><span class="math inline">\(H\leq G\)</span>.</li>
<li><span class="math inline">\(\forall a,b\in H,ab\in H,a^{-1}\in
H\)</span>.</li>
<li><span class="math inline">\(\forall a,b\in H\)</span>,有<span class="math inline">\(ab^{-1}\in H\)</span>.</li>
</ol>
<p>显然(1)<span class="math inline">\(\Rightarrow\)</span>(2),(2)<span class="math inline">\(\Rightarrow\)</span>(3),下面证明(3)$$(1):</p>
<p>满足(3),有<span class="math inline">\(e=aa^{-1}\in
H\)</span>,于是存在幺元.有<span class="math inline">\(ea^{-1}\in
H\)</span>,于是存在逆元.因为<span class="math inline">\(a(b^{-1})^{-1}=ab\in
H\)</span>,于是对运算封闭.同样的运算显然满足结合律.于是证毕.</p>
<p>如果<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H,K\subseteq
G\)</span>,类似闵可夫斯基和,我们定义<span class="math inline">\(HK=\{hk\mid h\in H,k\in K\}\)</span>.如果<span class="math inline">\(H=\{a\}\)</span>,可以写作<span class="math inline">\(aK\)</span>.类似记<span class="math inline">\(H^{-1}=\{h^{-1}\mid h\in H\}\)</span>,注意<span class="math inline">\(HH^{-1}\ne \{e\}\)</span>.</p>
<p>再定义<span class="math inline">\(H^n=\{h_1h_2\cdots h_n\mid
h_1,h_2,\cdots,h_n\in H\}\)</span>.</p>
<p>于是子群的判定定理可以改写成:</p>
<p>下列命题等价:</p>
<ol type="1">
<li><span class="math inline">\(H\leq G\)</span>.</li>
<li><span class="math inline">\(H^2\subseteq H\and H^{-1}\subseteq
H\)</span>.</li>
<li><span class="math inline">\(HH^{-1}\subseteq H\)</span>.</li>
</ol>
<p>显然,任意群<span class="math inline">\(G\)</span>,<span class="math inline">\(G\)</span>和<span class="math inline">\(\{e\}\)</span>都是它的子群,我们称为<strong>平凡子群</strong>,如果<span class="math inline">\(H\ne
G\)</span>,称为<strong>真子群</strong>,记作<span class="math inline">\(H&lt;G\)</span>.</p>
<p>若干个群的交仍然是子群,但是若干个群的并不一定.我们可以证明一下若干个群的交仍然是子群:考虑<span class="math inline">\(h\in A,h\in B,w\in A,w\in B\)</span>,那么<span class="math inline">\(hw^{-1}\in A\cap B\)</span>.</p>
<p>设<span class="math inline">\(M\subseteq G\)</span>,则称<span class="math inline">\(G\)</span>的所有包含<span class="math inline">\(M\)</span>的子群的交为由<span class="math inline">\(M\)</span><strong>生成的子群</strong>,记作<span class="math inline">\(\langle M\rangle\)</span>.</p>
<p>如果<span class="math inline">\(\lang M\rang=G\)</span>,则称<span class="math inline">\(M\)</span>是<span class="math inline">\(G\)</span>的一个<strong>生成系</strong>.可由有限多个元素生成的群叫做<strong>有限生成群</strong>,若<span class="math inline">\(\exists M,|M|=1,\lang M\rang=G\)</span>,则称<span class="math inline">\(G\)</span>是<strong>循环群</strong>.</p>
<p>对于<span class="math inline">\(a\in G\)</span>,我们称<span class="math inline">\(o(a)=|\lang a \rang|\)</span>为<span class="math inline">\(a\)</span>的阶,不难发现<span class="math inline">\(o(a)\)</span>是满足<span class="math inline">\(a^n=e\)</span>的最小的正整数<span class="math inline">\(n\)</span>.如果这样的<span class="math inline">\(n\)</span>不存在,记<span class="math inline">\(o(a)=\infty\)</span>.群中所有元素的阶的<span class="math inline">\(lcm\)</span>称作群的方次数(如果不存在,则记为<span class="math inline">\(\infty\)</span>),记作<span class="math inline">\(\exp(G)\)</span>.</p>
<p>另一个不平凡的例子是群<span class="math inline">\(G\)</span>的<strong>中心</strong>定义为<span class="math inline">\(Z_G=\{z\in G\mid \forall g\in
G,zg=gz\}\)</span>,这显然也是一个子群.</p>
<h5><span id="example1">Example1</span></h5>
<p>证明不存在恰有两个二阶元素的群.</p>
<p>不妨设这两个二阶元素分别为<span class="math inline">\(a\ne b,a,b\ne
e\)</span>,则注意到<span class="math inline">\(aba\)</span>也是一个二阶元素.</p>
<p>如果<span class="math inline">\(aba=a\)</span>,则<span class="math inline">\(ba=e\)</span>,说明<span class="math inline">\(a=b\)</span>.</p>
<p>如果<span class="math inline">\(aba=b\)</span>,则<span class="math inline">\(ba=ab\)</span>,说明<span class="math inline">\(ab\)</span>是第三个二阶元素.</p>
<p>类似可以证明一个群不可能恰有两个指数为<span class="math inline">\(2\)</span>的子群</p>
<p>类似还可以证明如果<span class="math inline">\(\exp(G)=2\)</span>,则<span class="math inline">\(G\)</span>一定是交换群(一定满足<span class="math inline">\(\forall a,b\in G,ab=ba\)</span>).</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个群<span class="math inline">\(G\)</span>,如果<span class="math inline">\(\forall a,b\in G\)</span>,<span class="math inline">\(\exists i\in
\mathbb{N_+},(ab)^i=a^ib^i,(ab)^{i+1}=a^{i+1}b^{i+1},(ab)^{i+2}=a^{i+2}b^{i+2}\)</span>,求证其是交换群.</p>
<p>考虑: <span class="math display">\[
(ab)^{i+1}=a^{i+1}b^{i+1}=a(ab)^ib\\
(ab)^i=a(ab)^ia^{-1}
\]</span> 同理有<span class="math inline">\((ab)^{i+1}=a(ab)^{i+1}a^{-1}\)</span>.两式合并一下有<span class="math inline">\(a(ab)^ia^{-1}ab=a(ab)^{i+1}a^{-1}\Rightarrow
b=aba^{-1}\)</span>.</p>
<h5><span id="example3">Example3</span></h5>
<p>证明若<span class="math inline">\(\exp(G)\in
\text{even}\)</span>,则存在阶为<span class="math inline">\(2\)</span>的元素.</p>
<p>一定存在一个阶为<span class="math inline">\(2k\)</span>的元素<span class="math inline">\(a\)</span>,显然<span class="math inline">\(o(a^k)=2\)</span>.</p>
<h5><span id="example4">Example4</span></h5>
<p>当<span class="math inline">\(n&gt;2\)</span>的时候,证明在有限群<span class="math inline">\(G\)</span>中阶为<span class="math inline">\(n\)</span>的元素个数是偶数.</p>
<p>显然构造双射<span class="math inline">\(a\mapsto
a^{n-1}\)</span>即可.</p>
<h5><span id="example5">Example5</span></h5>
<p>对于群<span class="math inline">\(G\)</span>,证明<span class="math inline">\(o(ab)=o(ba)\)</span>.</p>
<p>考虑反证,不妨设<span class="math inline">\(o(ab)=n&lt;o(ba)=m\)</span>.</p>
<p>则<span class="math inline">\(e=(ba)^m=(ba)^{m-n}b(ab)^{n-1}a=(ba)^{m-n}\)</span>,说明<span class="math inline">\(o(ba)\leq m-n&lt;m\)</span>,不符题意.</p>
<h5><span id="example6">Example6</span></h5>
<p>证明:如果<span class="math inline">\(H,K\leq G\)</span>,那么<span class="math inline">\(HK\leq G\Leftrightarrow HK=KH\)</span>.</p>
<p>如果<span class="math inline">\(HK=KH\)</span>,那么<span class="math inline">\(HK\leq G\Leftrightarrow
HK(HK)^{-1}=HK\)</span>.考虑: <span class="math display">\[
HK(HK)^{-1}=HKK^{-1}H^{-1}=HKH^{-1}=KHH^{-1}=HK
\]</span> 如果<span class="math inline">\(HK\leq G\)</span>,那么<span class="math inline">\(HK=(HK)^{-1}=K^{-1}H^{-1}=KH\)</span>.</p>
<h5><span id="example7">Example7</span></h5>
<p>设<span class="math inline">\(G\)</span>是交换群,证明<span class="math inline">\(G\)</span>中的全体有限阶元素构成<span class="math inline">\(G\)</span>的一个子群.</p>
<p>等价于证明如果<span class="math inline">\(a,b\)</span>的阶有限,那么<span class="math inline">\(ab^{-1}\)</span>的阶有限.这对交换群来说是显然的.</p>
<h5><span id="example8">Example8</span></h5>
<p>如果<span class="math inline">\(G\)</span>只有有限多个子群,证明<span class="math inline">\(G\)</span>是有限群.</p>
<p>考虑若其有无限阶元素<span class="math inline">\(a\)</span>,则$a<span class="math inline">\(已经有无限个子群(取幂次为\)</span>k$的倍数).反之则每个元素都可以生成一个循环群,也有无限个子群.</p>
<h4><span id="群的实例">群的实例</span></h4>
<h5><span id="全变换群对称群与交错群">全变换群,对称群与交错群</span></h5>
<p>设<span class="math inline">\(M\)</span>是一个非空集合,<span class="math inline">\(M\)</span>到自身的双射的全体对于映射的复合构成一个群,称作<span class="math inline">\(M\)</span>的<strong>全变换群</strong>,记作<span class="math inline">\(S(M)\)</span>.</p>
<p>设<span class="math inline">\(M\)</span>是含有<span class="math inline">\(n\)</span>个元素的集合,<span class="math inline">\(M\)</span>的全变换群<span class="math inline">\(S(M)\)</span>称为<strong>n级对称群</strong>,记作<span class="math inline">\(S_n\)</span>.不失一般性,我们可以设<span class="math inline">\(M=\{1,2,\cdots,n\}\)</span>,<span class="math inline">\(S_n\)</span>的元素称为<strong>n元置换</strong>,任一置换可以用列表的方法表示,即如果<span class="math inline">\(\sigma\)</span>是一个映射,我们将其写作: <span class="math display">\[
\sigma=\left( \begin{array}{c}
1&amp;2&amp;\cdots&amp;n\\
\sigma_1&amp;\sigma_2&amp;\cdots&amp;\sigma_n
\end{array} \right)
\]</span> 显然<span class="math inline">\(|S_n|=n!\)</span>.</p>
<p>设<span class="math inline">\(\sigma \in S_n\)</span>,<span class="math inline">\(\{i_1,i_2,\cdots ,i_t\}\subseteq \{1,2,\cdots
,n\}\)</span>,有<span class="math inline">\(\sigma(i_t)=i_1,\forall
1\leq k&lt;t,\sigma(i_k)=i_{k+1}\)</span>,我们称这样的置换是对于<span class="math inline">\(\{i_1,i_2,\cdots
,i_t\}\)</span>的<strong>轮换</strong>,记作<span class="math inline">\(\left(\begin{array}
{c}i_1&amp;i_2&amp;\cdots&amp;i_t\end{array}\right)\)</span>,<span class="math inline">\(t\)</span>为轮换的<strong>长度</strong>,长度为<span class="math inline">\(2\)</span>的轮换称作<strong>对换</strong>.显然,一个置换可以被分解成若干轮换的乘积.又显然,一个轮换可以被分解成若干对换的乘积.</p>
<p>根据逆序对相关,我们知道一个置换的逆序对数量的奇偶性等于其分解成的对换的数量.我们将逆序对数量是奇数的置换称为<strong>奇置换</strong>,是偶数的称之为<strong>偶置换</strong>,<span class="math inline">\(S_n\)</span>中的所有偶置换也构成一个群,称之为<strong>n级交错群</strong>,记为<span class="math inline">\(A_n\)</span>.<span class="math inline">\(A_n\)</span>实际上是<span class="math inline">\(S_n\)</span>的一个子群.</p>
<h5><span id="一般线性群">一般线性群</span></h5>
<p>对于定义在域<span class="math inline">\(F\)</span>上的线性空间<span class="math inline">\(V\)</span>,它上面的所有自同构构成一个<strong>一般线性群</strong><span class="math inline">\(GL(V)=\{T\in \text{End}(V)\mid \det T\ne
0\}\)</span>.特别地,当<span class="math inline">\(\dim
V&lt;\infty\)</span>的时候,其有一个子群<strong>特殊线性群</strong><span class="math inline">\(SL(V)=\{T\in \text{End}(V)\mid \det
T=1\}\)</span>.</p>
<p>在配套的内积空间上还可以把正交变换组成的群一块拿到,称为<strong>正交群</strong>或者<strong>酉群</strong><span class="math inline">\(O(V)\)</span>,还可以定义<span class="math inline">\(SO(V)=O(V)\cap SL(V)\)</span>.</p>
<p>当然上面的版本都可以用矩阵来表示,这里略去不表.然而对于矩阵来代替上面的情形,我们疑似需要引入群同构的概念,这会在下面提出.</p>
<h5><span id="克莱因四元群">克莱因四元群</span></h5>
<p>取<span class="math inline">\(V=\{\text{id},\sigma,\tau,\sigma\tau\}\)</span>,其中:</p>
$$ =(
<span class="math display">\[\begin{matrix}
1&amp;2&amp;3&amp;4\\
2&amp;1&amp;4&amp;3
\end{matrix}\]</span>
<p>)\</p>
=(
<span class="math display">\[\begin{matrix}
1&amp;2&amp;3&amp;4\\
3&amp;4&amp;1&amp;2
\end{matrix}\]</span>
<p>)\</p>
==(
<span class="math display">\[\begin{matrix}
1&amp;2&amp;3&amp;4\\
4&amp;3&amp;2&amp;1
\end{matrix}\]</span>
<p>)\ $$</p>
<p>见到这确实是一个群,而且任何一个元素的逆元都是它本身,而且两个不同的非<span class="math inline">\(1\)</span>元的乘积会得到另一个非<span class="math inline">\(1\)</span>元.</p>
<p>克莱因群的实例非常多,例如<span class="math inline">\(\{1,3,5,7\}\)</span>在<span class="math inline">\(\mod 8\)</span>意义下对乘法构成克莱因群,<span class="math inline">\(\{0,1,2,3\}\)</span>对异或构成克莱因群.以及:</p>
<p><span class="math display">\[
\left\{
\begin{bmatrix}1&amp;0\\ 0&amp;1\end{bmatrix},
\begin{bmatrix}1&amp;0\\ 0&amp;-1\end{bmatrix},
\begin{bmatrix}-1&amp;0\\ 0&amp;1\end{bmatrix},
\begin{bmatrix}-1&amp;0\\ 0&amp;-1\end{bmatrix}
\right\}
\]</span></p>
<p>对矩阵乘法也构成群.</p>
<h5><span id="循环群">循环群</span></h5>
<p>如果对于一个群<span class="math inline">\(G\)</span>,它可以由其中的某个元素<span class="math inline">\(\sigma\)</span>生成,记作<span class="math inline">\(G=\langle \sigma\rangle\)</span>,当<span class="math inline">\(\forall g\in G,\exists k\in
\mathbb{Z},g=\sigma^k\)</span>.</p>
<p>显然<span class="math inline">\(\mathbb{Z}/n\mathbb{Z}\)</span>对加法就是一个循环群,其中<span class="math inline">\(\sigma=1+n\mathbb{Z}\)</span>.</p>
<p>特别地,容易见到对于任意循环群,如果<span class="math inline">\(|G|=\infty\)</span>,则<span class="math inline">\(G\cong \mathbb{Z}\)</span>;反之则<span class="math inline">\(G\cong \mathbb{Z}/|G|\mathbb{Z}\)</span>.</p>
<h4><span id="陪集">陪集</span></h4>
<p>设<span class="math inline">\(G\)</span>是一个群,<span class="math inline">\(H\leq G\)</span>,定义等价关系<span class="math inline">\(a\sim b\Leftrightarrow \exists h\in
H,a=bh\)</span>,容易检查其满足等价类的三条性质.不难发现对于元素<span class="math inline">\(a\)</span>,其所在的等价类就是<span class="math inline">\(aH\)</span>.类似可以定义<span class="math inline">\(Ha\)</span>.我们定义形如<span class="math inline">\(aH\)</span>的子集为<span class="math inline">\(H\)</span>的一个<strong>右陪集</strong>,形如<span class="math inline">\(Ha\)</span>的称作<strong>左陪集</strong>.由于左陪集是一个等价类,因此会将原集合划分为若干个等价类.这种划分用商集刻画,记作<span class="math inline">\(G/H\)</span>.</p>
<p>一个自然的想法是<span class="math inline">\(G/H\)</span>是否构成一个群.先看取逆,容易发现<span class="math inline">\((aH)^{-1}=Ha^{-1}\)</span>,这给出左陪集和右陪集之间一个自然的同构:</p>
<p><span class="math display">\[
Hg\mapsto g^{-1}H=(Hg)^{-1}
\]</span></p>
<p>所以不同的左右陪集个数相等.</p>
<p>我们将<span class="math inline">\(H\)</span>的不同左陪集的个数(不一定有限)称为<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中的<strong>指数</strong>,记为<span class="math inline">\(|G:H|\)</span>,注意到<span class="math inline">\(|H|=|aH|=|Ha|\)</span>,因此其实右陪集个数也是这个指数.既然是等价类,就完成了对原群的一个划分,而且容易见到每个划出的等价类大小都是<span class="math inline">\(|H|\)</span>.</p>
<p>对于有限群,这引出重要的<strong>拉格朗日定理</strong>: <span class="math display">\[
|G|=|G:H| \times |H|
\]</span></p>
<p><span class="math inline">\(\forall a\in G\)</span>,取<span class="math inline">\(H=\lang a\rang\)</span>,有:<span class="math inline">\(\forall a\in G,o(a)\mid (|G|)\)</span>,于是<span class="math inline">\(a^{|G|}=e\)</span>.这当然是数论上的欧拉定理的群论形态.</p>
<h4><span id="正规子群与商群">正规子群与商群</span></h4>
<p>设<span class="math inline">\(G\)</span>是一个群,<span class="math inline">\(H\leq G\)</span>,如果<span class="math inline">\(\forall a\in
G,aH=Ha\)</span>(是运算满足交换律的必要不充分条件),我们称<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的<strong>正规子群</strong>,记作<span class="math inline">\(H\trianglelefteq G\)</span>.</p>
<p>显然,<span class="math inline">\(G\)</span>和<span class="math inline">\(\{e\}\)</span>都是<span class="math inline">\(G\)</span>的正规子群,如果<span class="math inline">\(G\)</span>除此之外没有别的正规子群,称其为<strong>单群</strong>.</p>
<h5><span id="正规子群的判定定理">正规子群的判定定理</span></h5>
<p>当<span class="math inline">\(H\leq G\)</span>时,下列命题等价:</p>
<ol type="1">
<li><span class="math inline">\(H\trianglelefteq G\)</span>.</li>
<li><span class="math inline">\(\forall a,b\in G,\exists c\in
G,(aH)(bH)=cH\)</span>.</li>
<li><span class="math inline">\(\forall a\in G,a^{-1}Ha=H\)</span>.</li>
<li><span class="math inline">\(\forall a\in G,h\in H,a^{-1}ha\in
H\)</span>.</li>
</ol>
<p>先证明(2)$$(1):</p>
<p>由于<span class="math inline">\(a^2H\subseteq (aH)^2\)</span>,<span class="math inline">\(a^2\subseteq (aH)^2\)</span>并且<span class="math inline">\((aH)^2=cH\)</span>是左陪集,那么由于左陪集是等价类,所以<span class="math inline">\(a^2H=(aH)^2\)</span>.两边同时乘以<span class="math inline">\(a^{-1}\)</span>,有<span class="math inline">\(Ha\subseteq HaH=aH\)</span>.再次两边左右乘以<span class="math inline">\(a^{-1}\)</span>,得到$a<sup>{-1}HHa</sup>{-1},aG
$,也就证毕.</p>
<p>再证明(1)$$(2):</p>
<p><span class="math inline">\((aH)(bH)=aHbH=a(bH)H=abH\)</span>.</p>
<p>(1)<span class="math inline">\(\Leftrightarrow\)</span>(3),(3)$<span class="math inline">\((4)都显然,考虑证明(4)\)</span>$(3).</p>
<p>(4)显然等价于<span class="math inline">\(ha\in
aH\)</span>,于是有<span class="math inline">\(Ha\subseteq
aH\)</span>.而又等价于<span class="math inline">\(a^{-1}h\in
Ha^{-1}\)</span>,于是类似证毕.</p>
<p>设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H\trianglelefteq G\)</span>,则<span class="math inline">\(H\)</span>的陪集在乘法下构成群,这个群称为<span class="math inline">\(G\)</span>关于<span class="math inline">\(H\)</span>的<strong>商群</strong>,记作<span class="math inline">\(G/H\)</span>.</p>
<p>考虑封闭律:<span class="math inline">\((aH)(bH)=a(bH)H=abH\)</span>,又显然满足结合律.又有<span class="math inline">\(\forall aH\in
G/H,eH(aH)=(aH)H=aH\)</span>,于是<span class="math inline">\(H\)</span>是幺元.同样知道<span class="math inline">\(a^{-1}H=(aH)^{-1}\)</span>,于是存在逆元.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:群<span class="math inline">\(G\)</span>的任一指数为<span class="math inline">\(2\)</span>的子群必为正规子群.</p>
<p>设指数为<span class="math inline">\(2\)</span>的子群为<span class="math inline">\(N\)</span>,则取<span class="math inline">\(\forall
a\in G\setminus N,aN=G\setminus N=Na\)</span>,因为<span class="math inline">\(\forall n\in N,an\notin N\)</span>.所以<span class="math inline">\(N\)</span>的任一左右陪集相同,<span class="math inline">\(N\)</span>是正规子群.</p>
<h4><span id="同态和同构">同态和同构</span></h4>
<p>考虑在两个群<span class="math inline">\(G\)</span>和<span class="math inline">\(G_1\)</span>之间构造映射<span class="math inline">\(\varphi\)</span>,如果<span class="math inline">\(\varphi\)</span>保持群运算,即对于所有的<span class="math inline">\(a,b\in G\)</span>,都有<span class="math inline">\(\varphi(ab)=\varphi(a)\varphi(b)\)</span>,则称其为由<span class="math inline">\(G\)</span>到<span class="math inline">\(G_1\)</span>的一个<strong>群同态</strong>.如果同时<span class="math inline">\(\varphi\)</span>又是单(满)射,则称其为<strong>单(满)同态</strong>,又单又满的同态称为<strong>同构</strong>.如果存在一个映射<span class="math inline">\(\varphi\)</span>,使得<span class="math inline">\(G,G_1\)</span>同构,则称这两个群<strong>同构</strong>,记作<span class="math inline">\(G\cong G_1\)</span>.</p>
<p>容易见到,同构等价于两方都有<span class="math inline">\(f:G\to
G_1\)</span>和<span class="math inline">\(g:G_1\to
G\)</span>,并且二者的合成<span class="math inline">\(fg=gf=\text{id}\)</span>.而且同构的合成仍是同构.</p>
<p>我们以<span class="math inline">\(End(G)\)</span>表示<span class="math inline">\(G\)</span>的全体<strong>自同态</strong>组成的集合,<span class="math inline">\(Aut(G)\)</span>表示全体<strong>自同构</strong>组成的集合.不难发现,<span class="math inline">\(End(G)\)</span>组成一个幺半群,而<span class="math inline">\(Aut(G)\)</span>组成一个群.</p>
<p>我们可以搞一个伴随映射:<span class="math inline">\(G\to
Aut(G),g\mapsto Ad_g\)</span>,其中<span class="math inline">\(Ad_g(x)=gxg^{-1}\)</span>.容易见到<span class="math inline">\(Ad_g=id\)</span>的充要条件是<span class="math inline">\(g\in Z(G)\)</span>也就是群的中心.</p>
<p>群同态<span class="math inline">\(\varphi:G\rightarrow
G_1\)</span>把<span class="math inline">\(G\)</span>的幺元映为<span class="math inline">\(G_1\)</span>的幺元.原因是:</p>
<p><span class="math display">\[
\varphi(e)^2=\varphi(e^2)=\varphi(e)e_1
\]</span></p>
<p>然而应当说明,这里保持单位元对幺半群未必成立,因此如果要将群同态的定义挪到幺半群上,需要额外添加<span class="math inline">\(\varphi(e)=e_1\)</span>的条件.</p>
<p>我们还有: <span class="math display">\[
e_1=\varphi(e)=\varphi(aa^{-1})=\varphi(a)\varphi(a^{-1})
\]</span> 所以<span class="math inline">\(\varphi(a^{-1})=(\varphi(a))^{-1}\)</span>.</p>
<p>我们将<span class="math inline">\(\varphi(G)\)</span>称为<span class="math inline">\(G\)</span>的<strong>像</strong>,记为<span class="math inline">\(\text{im}\ \varphi\)</span>.又将<span class="math inline">\(e_1\)</span>的原像的集合称为<span class="math inline">\(\varphi\)</span>的<strong>核</strong>,记为<span class="math inline">\(\text{ker} \ \varphi\)</span>.</p>
<p>注意到$<span class="math inline">\(不是单射\)</span><span class="math display">\[\exists a,b\in G,a\ne
b,\varphi(a)=\varphi(b)\]</span><span class="math display">\[\varphi(ab^{-1})=\varphi(a)\varphi(b)^{-1}=e_1\]</span>$<span class="math inline">\(\text{ker}\ \varphi\ne \{e\}\)</span>.</p>
<p>事实上还有以下命题:</p>
<ol type="1">
<li><span class="math inline">\(\text{im}\ \varphi\leq
G_1\)</span>.</li>
<li><span class="math inline">\(\text{ker}\ \varphi\trianglelefteq
G\)</span>.</li>
</ol>
<p>先看(1),考虑首先<span class="math inline">\(e_1\in \text{im}\
\varphi\)</span>,所以其不为空.其次对于任意<span class="math inline">\(a_1,b_1\in \text{im}\ \varphi\)</span>,<span class="math inline">\(\exists a,b\in G\)</span>,使得<span class="math inline">\(\varphi(a)=a_1,\varphi(b)=b_1\)</span>.于是: <span class="math display">\[
a_1b_1^{-1}=\varphi(a)\varphi(b^{-1})=\varphi(ab^{-1})\in \text{im}\
\varphi
\]</span> 再看(2),同上可知<span class="math inline">\(\text {ker}\
\varphi\ne \empty\)</span>,对于任意的<span class="math inline">\(a,b\in
\text {ker}\ \varphi\)</span>,<span class="math inline">\(\varphi(ab^{-1})=\varphi(a)\varphi(b)^{-1}=e_1\)</span>,所以<span class="math inline">\(ab^{-1}\in \text {ker}\ \varphi\)</span>,说明<span class="math inline">\(\text {ker}\ \varphi\leq G\)</span>.而<span class="math inline">\(\forall g\in G\)</span>,<span class="math inline">\(\varphi(gag^{-1})=\varphi(g)e_1\varphi(g)^{-1}=e_1\)</span>,所以<span class="math inline">\(gag^{-1}\in \text {ker}\ \varphi\)</span>.</p>
<p>另外如果<span class="math inline">\(f\)</span>是单同态,那么<span class="math inline">\(f^{-1}\)</span>也是同态,原因是: <span class="math display">\[
f(f^{-1}(x)f^{-1}(y))=f(f^{-1}(x))f(f^{-1}(y))=xy=f(f^{-1}(xy))\\
f^{-1}(x)f^{-1}(y)=f^{-1}(xy)
\]</span> 以及如果<span class="math inline">\(f,g\)</span>都是同态,那么<span class="math inline">\(f\circ g\)</span>也是同态.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>设<span class="math inline">\(\varphi:G\rightarrow
G_1\)</span>是群同态,则<span class="math inline">\(G/\text {ker}\
\varphi\cong \text {im}\ \varphi\)</span>.</p>
<p>不妨先设<span class="math inline">\(H=\text {ker}\
\varphi\)</span>.我们定义映射<span class="math inline">\(\psi:G/H\rightarrow \text {im}\
\varphi\)</span>,满足<span class="math inline">\(\psi(aH)=\varphi(a)\)</span>.</p>
<p>不过首先要判断<span class="math inline">\(\psi\)</span>是不是良定义,也就是当<span class="math inline">\(aH=bH\)</span>的时候,我们要判断<span class="math inline">\(\varphi(a)\)</span>是否等于<span class="math inline">\(\varphi(b)\)</span>.若<span class="math inline">\(aH=bH\)</span>,说明<span class="math inline">\(\exists h\in H,a=bh\)</span>,那么<span class="math inline">\(\psi(bH)=\varphi(b)=\varphi(bh)=\varphi(b)\varphi(h)=\varphi(a)\)</span>.</p>
<p>然后还要证明其是群同态,注意到<span class="math inline">\(\psi((aH)(bH))=\psi(abH)=\varphi(ab)=\varphi(a)\varphi(b)=\psi(aH)\psi(bH)\)</span>.</p>
<p>接下来要证明它是单射,显然只有<span class="math inline">\(\psi(H)=e_1\)</span>,<span class="math inline">\(\text{ker}\ \psi=\{H\}\)</span>.</p>
<p>接下来要证明它是满射,<span class="math inline">\(\forall g\in
\text{im}\ \varphi\)</span>,<span class="math inline">\(\exists
a,\varphi(a)=g\)</span>,则<span class="math inline">\(\psi(aH)=g\)</span>.</p>
<p>这样就证明了同态基本定理.</p>
<p>当<span class="math inline">\(\varphi\)</span>是满射的时候<span class="math inline">\(G_1=\text{im}\ \varphi\)</span>,所以此时有<span class="math inline">\(G/\text {ker}\ \varphi\cong G_1\)</span>.</p>
<h5><span id="cayley定理">Cayley定理</span></h5>
<p>即:任何一个群都同构于某一集合上的变换群.</p>
<p>考虑定义<span class="math inline">\(L(a)\)</span>为由<span class="math inline">\(a\)</span>引起的<span class="math inline">\(G\)</span>的<strong>左平移</strong>,也就是<span class="math inline">\(L(a):G\rightarrow
G,L(a)g=ag\)</span>.类似可以定义右平移.</p>
<p>不难发现,<span class="math inline">\(L(a)^{-1}=L(a^{-1})\)</span>,所以<span class="math inline">\(L(a)\)</span>是<span class="math inline">\(G\)</span>集合上的双射,即<span class="math inline">\(L(a)\in S(G)\)</span>,其中<span class="math inline">\(S(G)\)</span>就是在<span class="math inline">\(G\)</span>集合上的变换群.</p>
<p>我们定义映射<span class="math inline">\(L:G\rightarrow
S(G)\)</span>,显然<span class="math inline">\(L\)</span>是群同态,并且显然<span class="math inline">\(\text{ker}\ L=\{e\}\)</span>,所以<span class="math inline">\(G\cong \text{im}L=L(G)\)</span>.</p>
<p>事实上应当见到的是,这个定理更多依赖于群的消去律.只要有消去律,就可以保证<span class="math inline">\(L(a)\)</span>是单射,对于有限集合的自同态已经可以说明是双射了.</p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>我们定义<span class="math inline">\(H\trianglelefteq
G\)</span>时,定义<span class="math inline">\(\pi:G\rightarrow
G/H,a\mapsto aH\)</span>.显然其是群同态,定义其为由<span class="math inline">\(G\)</span>到<span class="math inline">\(G/H\)</span>的<strong>典范同态</strong>.</p>
<p>那么我们有第一同构定理,即对于一个<span class="math inline">\(G\)</span>的一个正规子群<span class="math inline">\(H\)</span>,在典范同态<span class="math inline">\(\pi:G\rightarrow G/H\)</span>下,我们有:</p>
<ol type="1">
<li><span class="math inline">\(G\)</span>的包含<span class="math inline">\(H\)</span>的子群和<span class="math inline">\(G/H\)</span>的子群在<span class="math inline">\(\pi\)</span>下是群同构.</li>
<li>在此对应下,正规子群对应于正规子群.</li>
<li>若有<span class="math inline">\(H\trianglelefteq K\trianglelefteq
G\)</span>,则<span class="math inline">\(G/K\cong
(G/H)/(K/H)\)</span>.</li>
</ol>
<p><del>这啥玩意啊,这是人话么</del>.</p>
<p>别急,我们先尝试一下怎么证明啊.我们不妨记<span class="math inline">\(\bar{M}\)</span>表示<span class="math inline">\(M\)</span>这个集合在<span class="math inline">\(\pi\)</span>下的像.</p>
<p>对于(1):</p>
<p>先考虑证明单射,对于任何两个包含<span class="math inline">\(H\)</span>的子群<span class="math inline">\(M_1,M_2\)</span>,<span class="math inline">\(M_1\ne M_2\)</span>,那么不妨设<span class="math inline">\(M_1\nsubseteq M_2\)</span>,则<span class="math inline">\(\exists a\in M_1,a\notin
M_2\)</span>.此时考虑<span class="math inline">\(\bar{a}\)</span>,注意到如果<span class="math inline">\(\bar{a}\in \bar{M_2}\)</span>,则<span class="math inline">\(\exists b\in M_2,aH=bH\)</span>,此时必然有<span class="math inline">\(a\in bH\subseteq M_2\)</span>,这就证明了<span class="math inline">\(\bar{M_1}\ne \bar{M_2}\)</span>.</p>
<p>接下来要证明满射,也就是证明<span class="math inline">\(\forall N\leq
G/H,H\leq \pi^{-1}(N)\leq G\)</span>.</p>
<p>首先要证明<span class="math inline">\(\pi^{-1}(N)\)</span>是一个群,注意到<span class="math inline">\(\forall \bar{a},\bar{b}\in N,\overline{ab^{-1}}\in
N\)</span>,则<span class="math inline">\(ab^{-1}\in
\pi^{-1}(N)\)</span>.</p>
<p>再只需证明<span class="math inline">\(H\leq
\pi^{-1}(N)\)</span>,注意到作为幺元,应该有<span class="math inline">\(\bar e=H\in N\)</span>,考虑如果<span class="math inline">\(aH=H\)</span>的话,必然有<span class="math inline">\(a\in H\)</span>.所以<span class="math inline">\(H=\pi^{-1}(\bar e)\leq \pi^{-1}(N)\)</span>.</p>
<p>对于(2):</p>
<p>设<span class="math inline">\(H\leq K\trianglelefteq
G\)</span>,则只需证明<span class="math inline">\(\bar{K}\trianglelefteq
\bar{G}\)</span>.</p>
<p>考虑<span class="math inline">\(g\in G,a\in K,\exists b=g^{-1}ag\in
K\)</span>,<span class="math inline">\(\overline{g^{-1}ag}=\bar{b}\in
\bar K\)</span>.</p>
<p>对于(3):</p>
<p>由同态基本定理,考虑构造满射<span class="math inline">\(\varphi:G/H\rightarrow G/K\)</span>,只需证明<span class="math inline">\(\ker\ \varphi=K/H\)</span>即可.</p>
<p>考虑<span class="math inline">\(\varphi(aH)=aK\)</span>,先要证明它是良定义的,也就是当<span class="math inline">\(aH=bH\)</span>的时候,<span class="math inline">\(a^{-1}b\in H\subseteq K\)</span>,于是<span class="math inline">\(aK=bK\)</span>.</p>
<p>其次要证明它是群同态.我们有<span class="math inline">\(\varphi((aH)(bH))=\varphi(abH)=abK=\varphi(aH)\varphi(bH)\)</span>.</p>
<p>然后要证明它是满射,显然是.</p>
<p>考虑<span class="math inline">\(\forall k\in
K,\varphi(kH)=K\)</span>,而<span class="math inline">\(\forall k&#39;\in
G,k&#39;\notin K,\varphi(k&#39;H)\ne K\)</span>.这样就证明了<span class="math inline">\(\ker \varphi=K/H\)</span>.</p>
<h5><span id="第一同构定理的推论">第一同构定理的推论</span></h5>
<p>考虑满同态的情况,设<span class="math inline">\(\psi:G\rightarrow
G_1\)</span>是群的满同态,此时取<span class="math inline">\(H=\ker
\psi\)</span>,又根据同态基本定理有<span class="math inline">\(G/\ker
\psi\cong G_1,K/\ker \psi\cong K_1\)</span>,立刻有:</p>
<ol type="1">
<li><span class="math inline">\(G\)</span>的包含<span class="math inline">\(\ker \psi\)</span>的子群和<span class="math inline">\(G_1\)</span>的子群在<span class="math inline">\(\psi\)</span>下一一对应.</li>
<li>在此对应下,正规子群对应正规子群.</li>
<li>若有<span class="math inline">\(\ker \psi \leq K\trianglelefteq
G\)</span>,则<span class="math inline">\(G/K\cong (G/\ker \psi)/(K/\ker
\psi)\cong G_1/K_1\)</span>.</li>
</ol>
<p>网上有句话我觉得说的很好,第一同构定理揭示了商群和满射之间的关系.更进一步地,它揭示了为什么只有正规子群是有对应商群的,而且解释了核的重要用处.</p>
<p>换言之,在对正规子群的商群作群同态的时候,正规子群会保持某种不变性.</p>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H\trianglelefteq G,K\leq G\)</span>,则:</p>
<ol type="1">
<li><span class="math inline">\(HK\leq G\)</span>.<span class="math inline">\(H\cap K\trianglelefteq K\)</span>.</li>
<li><span class="math inline">\((HK)/H\cong K/(H\cap K)\)</span>.</li>
</ol>
<p>考虑(1)的证明:</p>
<p>先看前半段,考虑<span class="math inline">\(h_1k_1,h_2k_2\in
HK\)</span>,只需证明<span class="math inline">\(h_1k_1(h_2k_2)^{-1}=h_1k_1k_2^{-1}h_2^{-1}\in
HK\)</span>.</p>
<p>注意到由于<span class="math inline">\(H\)</span>是正规子群,必定有<span class="math inline">\((k_1k_2^{-1})h_2^{-1}(k_1k_2^{-1})^{-1}\in
H\)</span>,不妨设<span class="math inline">\(h_3=(k_1k_2^{-1})h_2^{-1}(k_1k_2^{-1})^{-1}\)</span>,则<span class="math inline">\((k_1k_2^{-1})h_2^{-1}=h_3(k_1k_2^{-1})\)</span>,而显然有<span class="math inline">\((h_1h_3)(k_1k_2^{-1})\in HK\)</span>.</p>
<p>再看后半段,只需证明<span class="math inline">\(\forall k\in K,w\in
H\cap K\)</span>,<span class="math inline">\(kwk^{-1}\in H\cap
K\)</span>.</p>
<p>注意到<span class="math inline">\(k,w\in K\)</span>,所以<span class="math inline">\(kwk^{-1}\in K\)</span>;又注意到<span class="math inline">\(H\trianglelefteq G\)</span>,所以<span class="math inline">\(kwk^{-1}\in H\)</span>,这就证明了该结论.</p>
<p>再看(2)的证明:</p>
<p>考虑构造<span class="math inline">\(\varphi:K\to (HK)/H,k\mapsto
kH\)</span>.这显然是良定义的群同态.</p>
<p>考虑<span class="math inline">\(\varphi(k)=H\Leftrightarrow k\in
H\Leftrightarrow k\in K\cap H\)</span>,于是<span class="math inline">\(\ker \varphi=K\cap H\)</span>.</p>
<p>接下来还需要解释其满性,考虑<span class="math inline">\(\forall
hkH=H(hk)=Hk=kH\)</span>,这就证明了其满性,于是上述命题自然成立.</p>
<p>根据第二同构定理还可以立刻得到:<span class="math inline">\(H,K\leq
G\)</span>,<span class="math inline">\(G\)</span>是有限群,<span class="math inline">\(|HK|=\frac{|H||K|}{|H\cap K|}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:群<span class="math inline">\(G\)</span>是交换群当且仅当<span class="math inline">\(x\mapsto x^{-1}\)</span>是群同构.</p>
<p>显然是单射且是双射,只需证明是群同态即可.此时就需要证明<span class="math inline">\(y^{-1}x^{-1}=(xy)^{-1}=x^{-1}y^{-1}\)</span>,那就搞定了.</p>
<h4><span id="群的直和与直积">群的直和与直积</span></h4>
<h5><span id="直和">直和</span></h5>
<p>在两个群<span class="math inline">\(G_1,G_2\)</span>的笛卡尔积<span class="math inline">\(G_1\times G_2\)</span>集合上定义二元运算,满足<span class="math inline">\((a_1,b_1)(a_2,b_2)=(a_1a_2,b_1b_2)\)</span>,这个集合和这个二元运算显然组成群,称这个群为<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>的<strong>外直和</strong>,记为<span class="math inline">\(G_1\oplus G_2\)</span>,<span class="math inline">\(G_1,G_2\)</span>称作其的<strong>直和因子</strong>.如果要对无限个群做类似操作,则可以区分出<strong>直积</strong>的版本,仍是因为是否有限个分量非零的问题.</p>
<p>显然<span class="math inline">\(G_1\oplus
G_2\)</span>中存在两个正规子群<span class="math inline">\(\bar{G_1}=\{(a,e_2)|a\in
G_1\},\bar{G_2}=\{(e_1,b)|b\in G_2\}\)</span>,并且不难发现<span class="math inline">\(G_1\oplus G_2=\bar{G_1}\bar{G_2}\)</span>.</p>
<p>这给出了一种分解群的策略,事实上,设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H,K\trianglelefteq
G,G=HK\)</span>,我们有以下命题互推:</p>
<ol type="1">
<li>映射<span class="math inline">\(\sigma:H\oplus K\rightarrow
G,(h,k)\mapsto hk\)</span>是同构.</li>
<li><span class="math inline">\(G\)</span>的任一元素表示为<span class="math inline">\(H,K\)</span>的乘积的表示法唯一.</li>
<li><span class="math inline">\(G\)</span>的幺元表示为<span class="math inline">\(H,K\)</span>的元素的乘积的表示法唯一.</li>
<li><span class="math inline">\(H\cap K=\{e\}\)</span>.</li>
</ol>
<p>显然<span class="math inline">\((1)\Rightarrow (2)\Rightarrow
(3)\)</span>.对于<span class="math inline">\((3)\Rightarrow
(4)\)</span>,如果<span class="math inline">\(\exists g\in H\cap K,g\ne
e\)</span>,则<span class="math inline">\(e=gg^{-1}=ee\)</span>,这就给出了两种表示法,不符.</p>
<p>只需证明<span class="math inline">\((4)\Rightarrow
(1)\)</span>.根据我们的经验,先证良定义(显然),再证群同态,再证单射,再证满射(显然).</p>
<p>我们先干个事,我们断言<span class="math inline">\(\forall h\in H,k\in
K,hk=kh\)</span>.</p>
<p>这个怎么断言呢?我们考虑由于<span class="math inline">\(H\trianglelefteq G\)</span>,有<span class="math inline">\(k^{-1}hk\in H\)</span>,所以<span class="math inline">\(h^{-1}k^{-1}hk\in H\)</span>,同理可证明<span class="math inline">\(h^{-1}k^{-1}hk\in K\)</span>,于是<span class="math inline">\(h^{-1}k^{-1}hk=e\)</span>,<span class="math inline">\(kh=hk\)</span>.由此显然证明是群同态.</p>
<p>接下来只需要证明单射,只需要证明<span class="math inline">\(\ker
\sigma=\{e,e\}\)</span>.不妨设<span class="math inline">\((h,k)\in \ker
\sigma\)</span>,则<span class="math inline">\(hk=e\)</span>,<span class="math inline">\(h=k^{-1}\in H\cap K=e\)</span>.所以<span class="math inline">\(\ker \sigma=\{e,e\}\)</span>.</p>
<p>我们也将<span class="math inline">\(G\)</span>称作<span class="math inline">\(H\)</span>和<span class="math inline">\(K\)</span>的<strong>内直和</strong>,将<span class="math inline">\(H,K\)</span>称作其<strong>直和因子</strong>.</p>
<p>上面的概念还可以扩展,设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H_1,\cdots,H_n\trianglelefteq G,G=H_1\cdots
H_n\)</span>,我们有以下命题互推:</p>
<ol type="1">
<li>映射<span class="math inline">\(\sigma:H_1\oplus \cdots \oplus
H_n\rightarrow G,(h_1,\cdots,h_n)\mapsto h_1\cdots
h_n\)</span>是同构.</li>
<li><span class="math inline">\(G\)</span>的任一元素表示为<span class="math inline">\(H_1,\cdots,H_n\)</span>的乘积的表示法唯一.</li>
<li><span class="math inline">\(G\)</span>的幺元表示为<span class="math inline">\(H_1,\cdots,H_n\)</span>的元素的乘积的表示法唯一.</li>
<li><span class="math inline">\(H_i\cap H_1\cdots H_{i-1}H_{i+1}\cdots
H_n=\{e\}\)</span>.</li>
</ol>
<h3><span id="环">环</span></h3>
<p>定义一个<strong>环</strong>是一个集合<span class="math inline">\(R\)</span>和两种二元运算$+,$.它应当满足如下性质:</p>
<ol type="1">
<li>集合对两种运算封闭.</li>
<li><span class="math inline">\((R,+)\)</span>构成阿贝尔群,加法幺元一般记作<span class="math inline">\(0_R\)</span>,<span class="math inline">\(x\)</span>的加法逆元一般记作<span class="math inline">\(-x\)</span>.</li>
<li>乘法有结合律.</li>
<li>乘法对加法有分配律.</li>
<li>(幺环存在乘法幺元,一般记作<span class="math inline">\(1_R\)</span>)</li>
<li>(交换环的乘法具有交换律)</li>
</ol>
<p>最平凡的环只包含一个<span class="math inline">\(0\)</span>元素,被称为<strong>零环</strong>.</p>
<p>下面证明一些环的基础性质:</p>
<ol type="1">
<li><span class="math inline">\(\forall a\in R,a0=0a=0\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\(a0=a(0+0)=a0+a0\)</span>,所以<span class="math inline">\(a0=0\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(\forall a,b\in
R,(-a)b=a(-b)=-(ab)\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\((-a)b+ab=b(a-a)=0\)</span>,所以<span class="math inline">\(-(ab)=(-a)b\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\forall a,b\in
R,(-a)(-b)=ab\)</span>.</li>
</ol>
<p>由(2)是显然的.</p>
<p>注意到环的定义中并没有提及乘法逆元.如果环<span class="math inline">\(R\)</span>是幺环,且对于某一个<span class="math inline">\(a\in R\)</span>,<span class="math inline">\(a\)</span>有逆元(或者既有左逆元又有右逆元,类似群,左右逆元必相等且唯一),那么称其为<strong>可逆元</strong>或<strong>单位元</strong>,有时又称其为unit.</p>
<p>容易验证幺环的可逆元的全体构成乘法群,记作<span class="math inline">\(R^\times\)</span>.</p>
<p>对于一个元素<span class="math inline">\(a\in R\)</span>来说,如果<span class="math inline">\(\exists b\in R\setminus \{0\}\)</span>,<span class="math inline">\(ab=0\)</span>,我们称<span class="math inline">\(a\)</span>是<span class="math inline">\(R\)</span>中的一个<strong>左零因子</strong>,同理可定义<strong>右零因子</strong>,如果一个<span class="math inline">\(a\)</span>既是左零因子又是右零因子,我们称其为一个<strong>零因子</strong>.</p>
<p>我们事实上可以说明这里的加法和乘法与我们平时使用的相当类似,换言之,我们可以说明对于任意环<span class="math inline">\(R\)</span>而言,单同态<span class="math inline">\(\varphi:\Z\rightarrow R\)</span>唯一.</p>
<p>首先我们应该满足<span class="math inline">\(\varphi(1)=1_R,\varphi(0)=0_R\)</span>.</p>
<p>其次我们应当有<span class="math inline">\(\varphi(n)=\varphi(1+1+\cdots+1)=\varphi(1)+\varphi(1)+\cdots+\varphi(1)\)</span>.我们不妨把后者简写为<span class="math inline">\(n\varphi(1)\)</span>,倍数运算是环中相当重要的运算.</p>
<h4><span id="子环">子环</span></h4>
<p>要验证<span class="math inline">\(S\)</span>是<span class="math inline">\(R\)</span>的子环,只需验证<span class="math inline">\(S\)</span>对加法下是子群,然后<span class="math inline">\(S\)</span>对乘法封闭.</p>
<p>而事实上由于<span class="math inline">\(-x=(-1)x\)</span>,所以实际上只需要验证<span class="math inline">\(S\)</span>对加法和乘法都封闭即可.</p>
<h4><span id="理想">理想</span></h4>
<p>由于环上有两种运算,如果我们想在陪集上保持环的两种运算,就需要在上面加一些限制.</p>
<p>进一步地,如果<span class="math inline">\(I\)</span>是<span class="math inline">\(R\)</span>的一个加法子群(由于加法有交换律,所以加法子群一定是加法正规子群),并且<span class="math inline">\(\forall r\in R\)</span>,有<span class="math inline">\(rI\subseteq I\)</span>(那么自然有<span class="math inline">\(rI=I\)</span>),则称<span class="math inline">\(I\)</span>是<span class="math inline">\(R\)</span>的一个<strong>左理想</strong>,同理定义<strong>右理想</strong>,既是左理想又是右理想则称其为一个<strong>理想</strong>.</p>
<p>事实上,如果对于<span class="math inline">\(R\)</span>上的一个理想<span class="math inline">\(I\)</span>,我们容易证明<span class="math inline">\(I=R\Leftrightarrow 1\in I\)</span>.</p>
<p>由于这是一个加法子群,所以加法运算肯定是满足的,容易发现如果<span class="math inline">\(I\)</span>是<span class="math inline">\(R\)</span>的一个理想,那么<span class="math inline">\(\forall r,s\in R,(r+I)(s+I)=rs+I\)</span>.</p>
<p>类似群中的结构,子环的交仍然是子环,理想的交与和仍然是理想.于是类似可以定义由<span class="math inline">\(M\subseteq R,M\ne \empty\)</span>生成的理想<span class="math inline">\((M)\)</span>.可由一个元素生成的理想称为<strong>主理想</strong>,可由有限多个元素生成的理想叫做<strong>有限生成理想</strong>.容易发现如果<span class="math inline">\(R\)</span>是交换环,那么<span class="math inline">\((a)=aR\)</span>.</p>
<p>既然我们在陪集上保持了环的运算,我们自然可以称<span class="math inline">\(R/I\)</span>为<span class="math inline">\(R\)</span>关于<span class="math inline">\(I\)</span>的<strong>商环</strong>,也就是<span class="math inline">\(R/I=\{r+I|r\in
R\}\)</span>.必须要说明的是商环本身也是一个环,其加法幺元是<span class="math inline">\(0+I\)</span>,乘法幺元是<span class="math inline">\(1+I\)</span>.</p>
<p>子环和理想疑似没有对应的符号表示,我们下面不严谨地盗用子群和正规子群的符号(正常情况下好像不让这么干),在不引起混淆的前提下将<span class="math inline">\((R,+,\times)\)</span>简写为<span class="math inline">\(R\)</span>.</p>
<h4><span id="同态和同构">同态和同构</span></h4>
<p>类似群同态和同构,要同时保持两种运算并且需要将乘法幺元映射到对应的乘法幺元.</p>
<p>不过,如果将环同态的定义中的<span class="math inline">\(\varphi(ab)=\varphi(a)\varphi(b)\)</span>改为<span class="math inline">\(\varphi(ab)=\varphi(b)\varphi(a)\)</span>,则称这样的映射为环的<strong>反同态</strong>.</p>
<p>和群略有区别的地方在于如何定义<span class="math inline">\(\ker\varphi\)</span>,事实上我们一般用加法幺元(因为乘法逆元不一定存在)定义<span class="math inline">\(\ker \varphi=\{a\in
R|\varphi(a)=0\}\)</span>.那么<span class="math inline">\(\varphi\)</span>是单射当且仅当<span class="math inline">\(\ker \varphi=\{0\}\)</span>.</p>
<p>类比一下群同态,可以知道对于<span class="math inline">\(\varphi:R\rightarrow R_1\)</span>,<span class="math inline">\(\text {im} \varphi \leq R_1,\ker \varphi
\trianglelefteq R\)</span>.</p>
<p>对于前者:由于加法上的性质已经很好了,只需验证其对乘法封闭,这个是好做的.</p>
<p>对于后者:只需验证其封闭且是理想,同样可行.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>也就是<span class="math inline">\(R/\ker \varphi\cong \text
{im}\varphi\)</span>.</p>
<p>设<span class="math inline">\(f:R_1\to R_2\)</span>是线性映射,<span class="math inline">\(I_1\trianglelefteq R_1,I_2\subseteq
R_2\)</span>并构造两个商映射<span class="math inline">\(\varphi_1,\varphi_2\)</span>,并且<span class="math inline">\(f(I_1)\subseteq
I_2\)</span>,那么存在唯一的线性映射<span class="math inline">\(\bar
f:R_1/I_1\to R_2/I_2\)</span>使得<span class="math inline">\(f\varphi_2=\bar f\varphi_1\)</span>.具体地,<span class="math inline">\(\bar f(r+I_1)=f(r)+I_2\)</span>.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表: <span class="math display">\[
\xymatrix{
R_1 \ar[r]^f\ar[d]_{\varphi_1} &amp;R_2 \ar[r]^g\ar[d]_{\varphi_2}&amp;
R_3 \ar[d]_{\varphi_3}\\
    R_1/I_1 \ar[r]^{\bar f} &amp;R_2/I_2 \ar[r]^{\bar g} &amp;R_3/I_3\\
}
\]</span></p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>设<span class="math inline">\(R\)</span>是环,<span class="math inline">\(I\trianglelefteq R\)</span>,考虑典范同态:<span class="math inline">\(\pi:R\rightarrow R/I,r\mapsto
r+I\)</span>,那么:</p>
<ol type="1">
<li><span class="math inline">\(R\)</span>的包含<span class="math inline">\(I\)</span>的子环与<span class="math inline">\(R/I\)</span>的子环在<span class="math inline">\(\pi\)</span>下一一对应.</li>
<li>在此对应下,理想对应于理想.</li>
<li>若<span class="math inline">\(I\trianglelefteq J\trianglelefteq
R\)</span>,则<span class="math inline">\(R/J\cong
(R/I)/(J/I)\)</span>.</li>
</ol>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>设<span class="math inline">\(R\)</span>是环,<span class="math inline">\(I\trianglelefteq R,S\leq R\)</span>,则:</p>
<ol type="1">
<li><span class="math inline">\(I+S\leq R\)</span>.<span class="math inline">\(I\cap S\trianglelefteq S\)</span>.<span class="math inline">\(I\trianglelefteq I+S\)</span></li>
<li><span class="math inline">\((I+S)/I\cong S/(S\cap I)\)</span>.</li>
</ol>
<h4><span id="整环">整环</span></h4>
<p>如果一个交换幺环至少含有两个元素(或说<span class="math inline">\(0\ne
1\)</span>),且其满足<span class="math inline">\(xy=0\Rightarrow x=0\or
y=0\)</span>(或说其没有非零零因子),那么我们称其是一个整环.</p>
<p>显然,整环上对乘法满足左右消去律.原因是<span class="math inline">\(ax=ay\Leftrightarrow a(x-y)=0\)</span>.</p>
<h5><span id="特征">特征</span></h5>
<p>我们之前证明过<span class="math inline">\(\Z\)</span>可以唯一射到任何一个环上,如果这个环是整环,那么其实有更好的性质:</p>
<p>对于任意一个整环<span class="math inline">\(R\)</span>,存在唯一一个环的<strong>特征</strong><span class="math inline">\(\text {char} R\in\N\)</span>使得<span class="math inline">\(n1_R=0_R\Leftrightarrow
\text{char}R|n\)</span>.我们还可以知道<span class="math inline">\(\text{char}R\)</span>要么是<span class="math inline">\(0\)</span>要么是素数.</p>
<p>怎么证明呢?考虑如果<span class="math inline">\(\text{char
}R=ab\)</span>,自然有<span class="math inline">\(ab1_R=0_R\)</span>,于是<span class="math inline">\((a1_R)(b1_R)=0_R\)</span>,由于这是一个整环,我们当然有<span class="math inline">\(a1_R=0_R\lor b1_R=0_R\Rightarrow \text
{char}R|a\lor \text {char}R|b\)</span>.</p>
<p>如果<span class="math inline">\(R\)</span>中有一个整子环<span class="math inline">\(R_0\)</span>,当然可以发现<span class="math inline">\(\text {char} R=\text {char}
R_0\)</span>,于是当然有<span class="math inline">\(\text {char} R=\text
{char} \ \text{Frac} (R)\)</span>.</p>
<p>另一个性质在于容易发现<span class="math inline">\(\text {char}
R\times x=0_R\)</span>.</p>
<h5><span id="整除性">整除性</span></h5>
<p><span class="math inline">\(\forall a,b\in R\)</span>,如果<span class="math inline">\(\exists c\in R,a=bc\)</span>,就称<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的<strong>因子</strong>,记作<span class="math inline">\(b|a\)</span>.我们可以说明<span class="math inline">\(b|a\Leftrightarrow (a)\subseteq
(b)\)</span>,因为对于必要性:<span class="math inline">\((a)=aR=bcR\subseteq
bR\)</span>,而对于充分性则是因为<span class="math inline">\(a\in
(a)\subseteq (b)\)</span>.</p>
<p>如果两个元素互为因子,则称它们<strong>相伴</strong>,暂且用<span class="math inline">\(\sim\)</span>代表这种关系.容易验证这等价于<span class="math inline">\(\exists u\in R^\times
,a=bu\)</span>.原因是如果<span class="math inline">\(\exists u,v\in
R,a=ub,b=va\)</span>,那么<span class="math inline">\(a=uva\)</span>,由消去律得知<span class="math inline">\(uv=1\)</span>.此时它们生成的主理想必然相等.相伴关系显然是一种等价关系,<span class="math inline">\(R\)</span>对于相伴关系的商集上的因子关系是一种偏序关系(但不是全序的).</p>
<p>事实上还可以定义<strong>真因子</strong>:如果<span class="math inline">\((a)\subsetneq (b)\)</span>,那么显然<span class="math inline">\(b|a\)</span>,我们称此时<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的真因子.容易发现<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的真因子当且仅当<span class="math inline">\(b|a\)</span>并且<span class="math inline">\(b\)</span>不与<span class="math inline">\(a\)</span>相伴.</p>
<p>称一个元素<span class="math inline">\(a\)</span>是<strong>不可约元</strong>,当它不是<span class="math inline">\(0\)</span>也不是单位元而且<span class="math inline">\(\forall b,c\in R,a=bc\Rightarrow b\in R^\times\lor
c\in R^{\times}\)</span>.或者说:<span class="math inline">\(a=bc\Rightarrow c\sim a\lor b\sim a\)</span>.</p>
<p>称一个元素<span class="math inline">\(a\)</span>是<strong>素元</strong>,当它不是<span class="math inline">\(0\)</span>也不是单位元而且<span class="math inline">\(\forall b,c\in R,a|bc\Rightarrow a|b\lor
a|c\)</span>.</p>
<p>我们可以证明:在整环中,素元一定是不可约元,但是不可约元不一定是素元.</p>
<p>如何证明素元一定是不可约元呢?考虑如果<span class="math inline">\(a\in
prime\)</span>,并且<span class="math inline">\(a=bc\)</span>,则<span class="math inline">\(a|bc\Rightarrow a|b\lor a|c\)</span>,不妨假设<span class="math inline">\(a|b\)</span>,那么设<span class="math inline">\(b=ad\)</span>,自然有<span class="math inline">\(a=adc\)</span>,<span class="math inline">\((dc)=1\)</span>,于是<span class="math inline">\(c\in unit\)</span>.</p>
<h5><span id="唯一分解整环ufd">唯一分解整环(UFD)</span></h5>
<p>称<span class="math inline">\(R\)</span>是唯一分解整环,如果<span class="math inline">\(\forall a\in R,a\ne 0\)</span>,都可以将<span class="math inline">\(a\)</span>分解成有限个不可约元的乘积的相伴,也就是可以将<span class="math inline">\(a=u\prod_{k=1}^n p_k\)</span>,其中<span class="math inline">\(u\in unit\)</span>,<span class="math inline">\(p_k\)</span>是不可约元.并且这种分解需要在相伴意义下唯一,也就是如果存在另一种分解<span class="math inline">\(a=v\prod_{k=1}^mq_k\)</span>,那么需要满足<span class="math inline">\(n=m\)</span>并且可以交换乘积顺序使得<span class="math inline">\(p_k\)</span>和<span class="math inline">\(q_k\)</span>相伴.</p>
<p>我们下面可以证明:在唯一分解整环中,不可约元一定也是素元.</p>
<p>不妨设<span class="math inline">\(a\)</span>是不可约元,那么我们要证明<span class="math inline">\(a|bc\Rightarrow a|b\or a|c\)</span>.考虑设<span class="math inline">\(ad=bc\)</span>,对<span class="math inline">\(b,c,d\)</span>均作唯一分解,那么<span class="math inline">\(a\)</span>会剩下来并且和对面的某个分解出来的不可约元相伴,自然会有<span class="math inline">\(a|b\or a|c\)</span>.</p>
<p>在唯一分解整环中可以定义最大公因子.最大公因子当然可能不唯一,但最大公因子之间一定相伴.进一步地,如果最大公因子是可逆元,我们称两个数互素.</p>
<p>当且仅当一个整环有以下两个性质,它是一个唯一分解整环:</p>
<ol type="1">
<li>任意不可约元都是素元.</li>
<li>(存在分解)所有的<span class="math inline">\(r\in
R\setminus\{0\}\)</span>都能写成不可约元的乘积.</li>
</ol>
<p>先数学归纳,然后用反证法,假设不成立,那么<span class="math inline">\(r=\prod p_k=\prod q_j\)</span>.</p>
<p>接下来任取左边的一个<span class="math inline">\(p_1\)</span>,如果右边也有一个<span class="math inline">\(q_1\sim
p_1\)</span>就直接消去.反之考虑不可约元也是素元,因此<span class="math inline">\(p_1|\prod q_j\)</span>,因此<span class="math inline">\(\exists j,p_1|q_j\)</span>,不妨设<span class="math inline">\(tp_1=q_j\)</span>,因为<span class="math inline">\(q_j\)</span>是不可约元,所以<span class="math inline">\(t\in R^\times\)</span>,所以<span class="math inline">\(p_1\sim q_j\)</span>.于是唯一分解性自然得出.</p>
<p>另一种等价条件是:</p>
<ol type="1">
<li>任意不可约元都是素元.</li>
<li>Noether性质:对于一条主理想的链<span class="math inline">\((a_1)\subseteq
(a_2)\subseteq\cdots\)</span>,一定存在一个<span class="math inline">\(k\)</span>,使得从<span class="math inline">\(k\)</span>之后<span class="math inline">\((a_k)=(a_{k+1})=\cdots\)</span>.这条性质也等价于一条因子链一定需要是有限的.</li>
</ol>
<p>用Noether性质直接就可以得出任何一个<span class="math inline">\(r\)</span>都存在分解,于是等价于上面那个等价性质.</p>
<h5><span id="主理想整环pid">主理想整环(PID)</span></h5>
<p>如果一个整环的所有理想都是主理想,则称其为一个主理想整环.交换除环当然是主理想整环的一个典型例子.</p>
<p>需要证明PID一定是UFD,对此,我们考虑:</p>
<p>首先证明PID上的不可约元是素元,这里需要拿出裴蜀定理.然而我们目前不能定义最大公因子的概念,因此退而求其次只定义互素的概念:如果<span class="math inline">\(\forall c,c|a\land c|b\Rightarrow c\in
R^\times\)</span>,则称<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>互素.</p>
<p>我们需要证明在主理想整环上有裴蜀定理,换言之如果两个元素互素,那么<span class="math inline">\(\exists x,y\in R,ax+by=1\)</span>,或者说<span class="math inline">\((\{a,b\})=R\)</span>.原因是<span class="math inline">\(\exists h,(h)=(\{a,b\})\)</span>,那么此时必有<span class="math inline">\(h|a\land h|b\)</span>,于是<span class="math inline">\(h\sim 1\)</span>.</p>
<p>其次需要证明PID上的Noether性质,注意到一条主理想的链<span class="math inline">\(I_1\subseteq
I_2\subseteq\cdots\)</span>,直接取<span class="math inline">\(I=\bigcup_j I_j\)</span>,这个<span class="math inline">\(I\)</span>必然也是理想(乘法封闭性是显然的,加法封闭性的话考虑<span class="math inline">\(\forall x\in I_a,y\in I_b\)</span>,<span class="math inline">\(x+y\in
I_{\max(a,b)}\)</span>),那么它就必然是一个主理想,也就是<span class="math inline">\(\exists h,I=(h)\)</span>.此时注意到<span class="math inline">\(\exists k,h\in I_k\)</span>,那么<span class="math inline">\(I_k=I_{k+1}=\cdots=I\)</span>,这就证毕了.</p>
<p>综上可看出PID一定是UFD.</p>
<p>设<span class="math inline">\(R\)</span>为主理想整环,<span class="math inline">\(t\in (R\setminus \{0\})\setminus
R^\times\)</span>.那么以下命题等价:</p>
<ol type="1">
<li><span class="math inline">\(R/(t)\)</span>是域.</li>
<li><span class="math inline">\(R/(t)\)</span>是整环.</li>
<li><span class="math inline">\(t\)</span>是素元.</li>
</ol>
<p>(1)$<span class="math inline">\((2)当然是平凡的,考虑(2)\)</span>$(3)如何证明:</p>
<p>由于<span class="math inline">\(R/(t)\)</span>是整环,考虑<span class="math inline">\(t=ab\)</span>,那么我们有<span class="math inline">\((a+(t))(b+(t))=ab+(t)=0+(t)\)</span>,由于这是一个整环,这必然意味着:
<span class="math display">\[
a+(t)=0+(t)\lor b+(t)=0+(t)\\\Rightarrow t|a\lor t|b\\\Rightarrow t\sim
a\lor t\sim b
\]</span> 因此<span class="math inline">\(t\)</span>是不可约元,因此<span class="math inline">\(t\)</span>是素元.</p>
<p>接下来考虑(3)$<span class="math inline">\((1),只需证明非零元\)</span>a+(t)<span class="math inline">\(均可逆即可.考虑主理想整环上的裴蜀定理,存在\)</span>x,y<span class="math inline">\(使得\)</span>ax=1-yt<span class="math inline">\(,此时\)</span>x+(t)<span class="math inline">\(就是\)</span>a+(t)$的逆元.</p>
<p>还可进一步扩展裴蜀定理,容易证明在主理想环中<span class="math inline">\((\{r_1,\cdots,r_n\})=\gcd(r_1,\cdots,r_n)R\)</span>.</p>
<p>事实上还可以在这里拿出拓展版的中国剩余定理,具体地,如果<span class="math inline">\(a_1,\cdots,a_n\in
R\setminus\{0\}\)</span>,并且它们两两互素,取<span class="math inline">\(a=\prod a_k\)</span>,那么我们事实上有环同构<span class="math inline">\(\varphi:R/(a)\to
\prod_{k=1}^nR/(a_k),r+(a)\mapsto(r+(a_i))_{k=1}^n\)</span>.</p>
<p>用数学归纳只需证明<span class="math inline">\(n=2\)</span>的情形就可以了.</p>
<p>先证明<span class="math inline">\(\varphi\)</span>是单射,观察<span class="math inline">\(\ker \varphi\)</span>,如果<span class="math inline">\(\varphi(r+(a))=(0+(a_1),0+(a_2))\)</span>自然意味着<span class="math inline">\(a_1|r,a_2|r\Rightarrow a|r\)</span>,于是<span class="math inline">\(r+(a)=0+(a)\)</span>,这立刻得到<span class="math inline">\(\varphi\)</span>是单射.</p>
<p>再证明<span class="math inline">\(\varphi\)</span>是满射,用裴蜀定理容易取<span class="math inline">\(x_1,x_2\in R\)</span>使得<span class="math inline">\(a_1x_1+a_2x_2=1\)</span>,那么<span class="math inline">\(ra_1x_1+ra_2x_2=r\)</span>,此时注意到<span class="math inline">\(\varphi(ra_1x_1+(a))=(0+(a_1),r+(a_2))\)</span>,<span class="math inline">\(\varphi(ra_2x_2+(a))=(r+(a_1),0+(a_2))\)</span>.这样就可以看出其满性.其实这当然也是中国剩余定理在整数上的构造的类似版本.</p>
<h3><span id="多项式环">多项式环</span></h3>
<h4><span id="一元多项式环">一元多项式环</span></h4>
<p>一个系数属于特定非零环<span class="math inline">\(R\)</span>的一元多项式定义为系数在<span class="math inline">\(R\)</span>上的一元多项式环,记作<span class="math inline">\(R[x]\)</span>,注意到如果<span class="math inline">\(R\)</span>是整环,<span class="math inline">\(R[x]\)</span>仍然是整环.多元多项式环可以不断在多元多项式环上定义一元多项式环.不妨将一个多项式记作<span class="math inline">\(f(x)\)</span>.另外如果我们记<span class="math inline">\(R^{\times}\)</span>为<span class="math inline">\(R\)</span>中可逆元素的集合,那么显然<span class="math inline">\(R[x]^{\times}=R^{\times }\)</span>.</p>
<p>一般而言,我们下面默认讨论<span class="math inline">\(R\)</span>是整环的情况.</p>
<p>在多项式环上可以定义最高次数函数<span class="math inline">\(\deg\)</span>,容易验证<span class="math inline">\(\deg (fg)=\deg f+ \deg g,\deg(f+g)\leq \max\{\deg
f,\deg g\}\)</span>,可定义<span class="math inline">\(\deg
0=-\infty\)</span>.</p>
<p>整环上的多项式有长除法和取模运算,也就是对于任意多项式<span class="math inline">\(f\)</span>,以及最高项系数为<span class="math inline">\(1\)</span>的多项式<span class="math inline">\(d\)</span>,存在唯一一组<span class="math inline">\(q,r\)</span>满足<span class="math inline">\(f=dq+r\)</span>并且<span class="math inline">\(\deg
r\)</span>最小.这样还可以定义整除也就是当<span class="math inline">\(r=0\)</span>的时候.</p>
<p>长除法的正确性可以反证,如果存在两组,那么自然有<span class="math inline">\(d(q_1-q_2)=r_2-r_1\)</span>,如果<span class="math inline">\(q_1\ne q_2\)</span>,那么<span class="math inline">\(\deg (q_1-q_2)\geq 0\)</span>,那么<span class="math inline">\(\deg d(q_1-q_2)\geq \deg d\)</span>,但是<span class="math inline">\(\deg (r_2-r_1)&lt;\deg
d\)</span>,这样的话等式就不能成立了.因此必定有<span class="math inline">\(q_1=q_2,r_1=r_2\)</span>.</p>
<p>这就可以保证代入数值操作.因为我们考虑存在唯一的多项式<span class="math inline">\(q\)</span>和唯一一个<span class="math inline">\(s\in R\)</span>满足<span class="math inline">\(f=(x-\alpha)q+s\)</span>,那我们就可以称<span class="math inline">\(f(\alpha)=s\)</span>.</p>
<p>另外,定义在域<span class="math inline">\(F\)</span>上的多项式<span class="math inline">\(F[x]\)</span>是UFD,原因是可以两边对某一个根作长除法.</p>
<h4><span id="多元多项式环">多元多项式环</span></h4>
<p>显然,<span class="math inline">\(R[x_1,\cdots,x_n]\cong
(R[x_1,\cdots,x_{n-1}])[x_n]\)</span>.</p>
<h4><span id="不可约多项式">不可约多项式</span></h4>
<p>不可约多项式,也就是定义在域上的多项式环上的不可约元.换言之如果<span class="math inline">\(f\)</span>是不可约的,那么对于<span class="math inline">\(f\)</span>的任何一个分解<span class="math inline">\(f=g_1g_2\)</span>,都一定有<span class="math inline">\(g_1\in F^\times\)</span>或者<span class="math inline">\(g_1\in F^\times\)</span>.</p>
<h5><span id="本原多项式">本原多项式</span></h5>
<p>为何我们定义不可约多项式的时候需要定义在域上,而不是简单定义在整环上呢?这是因为,例如,<span class="math inline">\(2x\in
\mathbb{Z}[x]\)</span>,它并非是一个不可约元.但只要把<span class="math inline">\(\mathbb{Z}\)</span>扩成<span class="math inline">\(\mathbb{Q}\)</span>,它就成为了一个不可约元.</p>
<p>那么在整数上怎么搞呢?我们考虑设<span class="math inline">\(f=a_0+\cdots +a_n x^n\in
\mathbb{Z}[x]\setminus\{0\}\)</span>,并设<span class="math inline">\(c(f)=|\gcd(a_0,\cdots,a_n)|\)</span>,如若<span class="math inline">\(c(f)=1\)</span>,则称其是一个<strong>本原多项式</strong>.</p>
<p>接下来我们有<strong>高斯引理</strong>:如果<span class="math inline">\(g,h\in
\mathbb{Z}[x]\)</span>都是本原多项式,那么<span class="math inline">\(gh\)</span>也是本原多项式.</p>
<p>如何证明?考虑对于任何一个素数<span class="math inline">\(p\)</span>,我们找到<span class="math inline">\(g\)</span>中的最高次系数不被<span class="math inline">\(p\)</span>整除,设为<span class="math inline">\(r\)</span>.换言之设<span class="math inline">\(g=\sum_{k\geq 0}a_k x^k\)</span>,则<span class="math inline">\(\forall k&gt;r,p|a_k\)</span>,而<span class="math inline">\(p\nmid a_r\)</span>.对<span class="math inline">\(f=\sum_{k\geq 0}b_k
x^k\)</span>同样根据上面找到一个最高次<span class="math inline">\(s\)</span>,满足<span class="math inline">\(p\nmid
b_s\)</span>.</p>
<p>现在观察:</p>
<p><span class="math display">\[
[x^{r+s}]gh\\
=\sum_{i+j=r+s}a_ib_j
\equiv a_rb_s\pmod p\\
\ne 0 \pmod p
\]</span></p>
<p>这就搞定.</p>
<p>另一个证明策略是干脆把<span class="math inline">\(\mathbb{Z}\to
\mathbb{Z}/p\mathbb{Z}\)</span>,后者是一个域,于是可以见到其非零.其实和上面是同一个想法,也许后者在做完映射后更好描述.</p>
<p>高斯引理的推论是<span class="math inline">\(c(gh)=c(g)c(h)\)</span>.</p>
<p>接下来我们来搞一些<span class="math inline">\(\mathbb{Q}\)</span>上的结构,我们下面来证明,对于本原多项式来说,只要其在<span class="math inline">\(\mathbb{Q}[x]\)</span>上可约,那它就在<span class="math inline">\(\mathbb{Z}[x]\)</span>上可约.换言之,假设<span class="math inline">\(f\in \mathbb{Z}\setminus
\{0\}\)</span>是本原多项式,如果<span class="math inline">\(f=gh\)</span>,其中<span class="math inline">\(g,h\in \mathbb{Q}[x],\deg g&gt;0,\deg
h&gt;0\)</span>,那我们断言<span class="math inline">\(\exists \alpha
\in\mathbb{Q}^\times\)</span>使得<span class="math inline">\(g_1=\alpha
g,h_1=\alpha^{-1} h\)</span>使得<span class="math inline">\(g_1,h_1\in
\mathbb{Z}[x]\)</span>且它们都是本原多项式.</p>
<p>考虑总存在一对<span class="math inline">\(u,v\in
\mathbb{N}_+\)</span>使得<span class="math inline">\(ug,vh\in
\mathbb{Z}[x]\)</span>,此时有:</p>
<p><span class="math display">\[
uv=c(uvf)=c(ugvh)=c(ug)c(vh)
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
f=\frac{ugvh}{uv}=\frac{ug}{c(ug)}\frac{vh}{c(vh)}
\]</span></p>
<p>这就搞定.</p>
<p>还有一条性质是说,假设<span class="math inline">\(f\in
\mathbb{Z}\setminus \{0\}\)</span>是本原多项式,当<span class="math inline">\(\deg f&gt;0\)</span>的时候,下面两个命题等价:</p>
<ol type="1">
<li><span class="math inline">\(f\)</span>是<span class="math inline">\(\mathbb{Q}[x]\)</span>上的不可约多项式.</li>
<li><span class="math inline">\(f\)</span>是<span class="math inline">\(\mathbb{Z}[x]\)</span>上的不可约多项式.</li>
</ol>
<p>(1)$<span class="math inline">\((2)的话考虑反证,如若存在\)</span>[x]<span class="math inline">\(上的\)</span>g,h<span class="math inline">\(使得\)</span>f=gh<span class="math inline">\(,那\)</span>f<span class="math inline">\(在\)</span>[x]<span class="math inline">\(上都可约,当然在\)</span>[x]$上可约.</p>
<p>(2)$<span class="math inline">\((1)的话仍然考虑反证,如果存在\)</span>[x]<span class="math inline">\(上的\)</span>g,h<span class="math inline">\(使得\)</span>f=gh<span class="math inline">\(,那之前的推论告诉我们\)</span>f$可以分解为两个本原多项式的乘积,这就矛盾了.</p>
<p>接下来我们证明<span class="math inline">\(\mathbb{Z}[x]\)</span>是一个UFD,在此之前,我们先对<span class="math inline">\(\mathbb{Z}[x]\)</span>上的不可约元做分类,我们断言其分为以下两种:</p>
<ol type="1">
<li><span class="math inline">\(\mathbb{Z}\)</span>的不可约元.</li>
<li><span class="math inline">\(\deg f&gt;0\)</span>并且满足<span class="math inline">\(f\)</span>作为<span class="math inline">\(\mathbb{Q}[x]\)</span>上的不可约元的本原多项式<span class="math inline">\(f\)</span>.</li>
</ol>
<p>首先<span class="math inline">\(\deg
f=0\)</span>的情况自然是(1),下面尝试分类<span class="math inline">\(\deg
f&gt;0\)</span>的情况.</p>
<p>如若<span class="math inline">\(c(f)\ne 1\)</span>,当然有<span class="math inline">\(f=c(f)\frac{f}{c(f)}\)</span>,因此可约.所以不可约当且仅当<span class="math inline">\(c(f)=1\)</span>,也就是<span class="math inline">\(f\)</span>得是一个本原多项式.那就直到其不可约性可以从<span class="math inline">\(\mathbb{Q}[x]\)</span>过渡到<span class="math inline">\(\mathbb{Z}[x]\)</span>上.</p>
<p>最终我们来说明<span class="math inline">\(\mathbb{Z}[x]\)</span>是唯一分解的,首先可以提系数使得只对本原多项式说明唯一分解性.</p>
<p>既然如此,考虑如果<span class="math inline">\(f\)</span>可以被分解为两种<span class="math inline">\(a_1\cdots a_r\)</span>和<span class="math inline">\(b_1\cdots
b_s\)</span>两种,它们都是本原多项式,乘积后亦然,其中<span class="math inline">\(a_i,b_i\)</span>均满足<span class="math inline">\(\deg &gt;0\)</span>,那么直接扩域到<span class="math inline">\(\mathbb{Q}[x]\)</span>上,由于定义在域上的多项式有唯一分解行,因此<span class="math inline">\(s=r\)</span>而且适当重排后<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>差了一个<span class="math inline">\(\mathbb{Q}^\times\)</span>,然而两个本原多项式如果差了一个<span class="math inline">\(\mathbb{Q}^\times\)</span>,当然意味着它俩只差一个正负号,这是显然的,就给出了分解的唯一性.</p>
<p>接下来有<strong>Eisenstein判准</strong>,不妨设<span class="math inline">\(n\geq 1\)</span>,而<span class="math inline">\(f=\sum_{k=0}^n a_k
x^k\in\mathbb{Z}[x]\)</span>,如果存在一个素数<span class="math inline">\(p\)</span>满足<span class="math inline">\(p\nmid
a_n\)</span>,而且<span class="math inline">\(p|a_0,\cdots,a_{n-1}\)</span>,并且<span class="math inline">\(p^2\nmid a_0\)</span>,则<span class="math inline">\(f\)</span>是<span class="math inline">\(\mathbb{Q}[x]\)</span>中的不可约多项式.</p>
<p>为证明此,考虑既然<span class="math inline">\(p\nmid
a_n\)</span>,那当然<span class="math inline">\(p\nmid
c(f)\)</span>,因此,我们可以将<span class="math inline">\(f\)</span>调整为<span class="math inline">\(\frac{f}{c(f)}\)</span>,这并不会对<span class="math inline">\(p\)</span>的性质产生影响,而可以将<span class="math inline">\(f\)</span>化约成本原多项式的情形.</p>
<p>如何证明呢?考虑反证,本原多项式来说<span class="math inline">\(\mathbb{Q}[x]\)</span>上不可约等价于在<span class="math inline">\(\mathbb{Z}[x]\)</span>上不可约,假设此情形下<span class="math inline">\(f=gh\)</span>,其中<span class="math inline">\(g=\sum_{k=0}^m b_k x^k,h=\sum_{k=0}^l c_k
x^k\)</span>,其中<span class="math inline">\(l,m&gt;0\)</span>,而且<span class="math inline">\(g,h\in \mathbb{Z}[x]\)</span>.</p>
<p>既如此,注意到<span class="math inline">\(a_n=b_mc_l\)</span>,因此一定有<span class="math inline">\(p\nmid b_m,p\nmid c_l\)</span>.而又有<span class="math inline">\(p|a_0=b_0c_0\)</span>,不妨假设<span class="math inline">\(p|b_0\)</span>.此时,可以取一个<span class="math inline">\(1\leq k\leq m\)</span>,使得<span class="math inline">\(p|b_0,\cdots,p|b_{k-1}\)</span>但是有<span class="math inline">\(p\nmid b_k\)</span>,注意到:</p>
<p><span class="math display">\[
a_k\equiv 0\pmod p\\
\sum_{j=0}^k b_jc_{k-j}\equiv 0\pmod p\\
b_kc_0\equiv 0\pmod p
\]</span></p>
<p>所以<span class="math inline">\(p|c_0\)</span>,所以<span class="math inline">\(p^2|a_0=b_0c_0\)</span>,矛盾.</p>
<p>我们可以在此基础上证明一些有趣的结论:</p>
<ol type="1">
<li><span class="math inline">\(\forall n\geq 1\)</span>,<span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(p+x^n\)</span>是不可约的.</li>
<li><span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(\Phi_p=1+x+\cdots+x^{p-1}=\frac{x^p-1}{x-1}\)</span>是不可约的.</li>
</ol>
<p>考虑:</p>
<p><span class="math display">\[
\Phi_p=\frac{x^p-1}{x-1}\\
=\frac{(x-1+1)^p-1}{x-1}\\
=\frac{\sum_{k=0}^p\binom{p}{k}(x-1)^k-1}{x-1}\\
=\sum_{k=1}^p\binom{p}{k}(x-1)^{k-1}
\]</span></p>
<p>取<span class="math inline">\(h(x)=\sum_{k=1}^p\binom{p}{k}x^{k-1}\)</span>,则<span class="math inline">\(\Phi_p(x)=h(x-1)\)</span>,显然,二者的不可约性是等价的,下面观察<span class="math inline">\(h(x)\)</span>的不可约性.然而<span class="math inline">\(h(x)\)</span>当然满足Eisenstein判准,这就搞定.</p>
<p>这里可以见到,其实上面的过程可以全部挪到某个UFD以及与其配套的分式域上,均可以起效果.而且也可以看到在某一个UFD上定义的多项式环也一定是UFD.</p>
<h5><span id="一个判定不可约的算法">一个判定不可约的算法</span></h5>
<p>考虑判定一个<span class="math inline">\(f\)</span>是否可以被拆成两个<span class="math inline">\(f=gh\)</span>,并且它们都在<span class="math inline">\(\mathbb{Z}[x]\)</span>上,其中<span class="math inline">\(\deg g\leq k\)</span>.</p>
<p>如何判断呢?首先我们任取不同的<span class="math inline">\(x_0,\cdots,x_k\in \mathbb{Z}\)</span>,并取<span class="math inline">\(f(x_0),\cdots,f(x_k)\)</span>,如果它们中有<span class="math inline">\(0\)</span>就完工了对吧.如果没有,我们一定有<span class="math inline">\(g(x_i)|f(x_i)\)</span>,因此<span class="math inline">\(g(x_i)\)</span>只有有限种可能性.我们枚举所有的可能性并插值判<span class="math inline">\(g\)</span>.这就给出了一个有限次实现的算法.</p>
<h5><span id="不可约多项式上的扩域">不可约多项式上的扩域</span></h5>
<p>如果域<span class="math inline">\(F\)</span>上的多项式<span class="math inline">\(f\in
F[x]\)</span>可以分解为若干个一次多项式的乘积,则称其可<strong>分裂</strong>.</p>
<p>那么如果定义在一个域上的每个<span class="math inline">\(\deg\geq
1\)</span>的多项式都分裂,那么就称这个域是<strong>代数闭</strong>的.</p>
<p>定义在域<span class="math inline">\(F\)</span>上的多项式未必有根,但理应在其上面可以做扩域使其有根.具体而言我们对于域<span class="math inline">\(F\)</span>,想要找到一个单同态<span class="math inline">\(\varphi:F\to L\)</span>使得<span class="math inline">\(L\)</span>是一个更大的域.而应当见到<span class="math inline">\(L\)</span>实际上在某种意义上是定义在<span class="math inline">\(F\)</span>上的向量空间.</p>
<p>在这里需要发现的是,定义在域上的<span class="math inline">\(F[x]\)</span>一定是主理想整环,原因是可以在理想<span class="math inline">\(I\)</span>中取出$<span class="math inline">\(最小的一个非零的\)</span>f<span class="math inline">\(,那么其中的任何一个\)</span>gI<span class="math inline">\(,用带余除法立刻得到\)</span>g=pf+r<span class="math inline">\(,其中\)</span>r&lt;f,rI<span class="math inline">\(,必然得到\)</span>r=0<span class="math inline">\(.这意味着\)</span>I=(f)<span class="math inline">\(.同时容易见到\)</span>f=0<span class="math inline">\(的时候,\)</span>(f)=F[x]$.</p>
<p>我们尝试研究<span class="math inline">\(F[x]/(f)\)</span>的形态,那么见到<span class="math inline">\(\deg f\geq
1\)</span>的时候这个形态应当才是有意义的.构造一个同态<span class="math inline">\(\tau:F\to F[x]/(f),a\mapsto
a+(f)\)</span>,容易见到<span class="math inline">\(\tau\)</span>应当是一个单射,原因是在<span class="math inline">\(\deg f\geq 1\)</span>的前提下,有<span class="math inline">\(\ker \tau=\{0\}\)</span>.此时应当见到<span class="math inline">\(F[x]/(f)\)</span>可以看作一个定义在<span class="math inline">\(F\)</span>上的向量空间.而运用代余除法得知<span class="math inline">\(\{1+(f),x+(f),\cdots,x^{\deg
f-1}+(f)\}\)</span>显然给出了<span class="math inline">\(F[x]/(f)\)</span>的一组基.</p>
<p>在此基础上,若<span class="math inline">\(f=\sum
a_kx^k\)</span>,定义<span class="math inline">\(f^\varphi=\sum
\varphi(a_k)x^k\)</span>.</p>
<p>由于<span class="math inline">\(F[x]\)</span>是主理想环,我们在之前已经证明过了当<span class="math inline">\(f\)</span>不可约的时候,<span class="math inline">\(F[x]/(f)\)</span>是一个域,令<span class="math inline">\(E=F[x]/(f)\)</span>.回到我们一开始的目的.当<span class="math inline">\(\deg f\geq 1\)</span>,并且<span class="math inline">\(f\)</span>在<span class="math inline">\(F[x]\)</span>环上不可约的时候,若令<span class="math inline">\(\alpha=x+(f)\)</span>,此时<span class="math inline">\(\alpha\)</span>应作为一个<span class="math inline">\(E\)</span>上的元素,注意到此时: <span class="math display">\[
f^\tau(x+(f))\\=\sum (a_k+(f))(x+(f))^k\\=\sum a_kx^k+(f)\\=f+(f)=0+(f)
\]</span> 这意味着在<span class="math inline">\(E[X]\)</span>上<span class="math inline">\(f^\tau\)</span>是一个可约的多项式,因为提供了其一个元素<span class="math inline">\(\alpha\in E\)</span>作为其的一个零点.</p>
<p>从上面的过程来看,我们理应可以通过若干次扩张使得一个<span class="math inline">\(f\)</span>在某个<span class="math inline">\(E_r[X]\)</span>上是分裂的,其中<span class="math inline">\(r\leq \deg
f\)</span>,也即每一次扩域次数都至少降低<span class="math inline">\(1\)</span>.</p>
<p>我们应当思考这个域扩大了多少,见到如果<span class="math inline">\(\deg
f=n\)</span>,我们一开始已经声明过此时选取基的大小,自然得到<span class="math inline">\([E_r:F]=[E_r:E_{r-1}]\cdots[E_1:F]\leq
n!\)</span>.</p>
<p>不过我们理应简单说明这样的构造是合理的,具体来讲,我们已经声明过我们需要构造一个交换环<span class="math inline">\(L\)</span>并将<span class="math inline">\(F\)</span>以环同态<span class="math inline">\(\varphi:F\to L\)</span>的形式嵌入其中,并在环<span class="math inline">\(L\)</span>中找到一个<span class="math inline">\(\beta\in L\)</span>使得<span class="math inline">\(f^\varphi(\beta)=0\)</span>,那么此时应当存在一个唯一的环同态<span class="math inline">\(\psi:E\to L\)</span>使得<span class="math inline">\(\psi(\alpha)=\beta\)</span>,并且下面是一个交换图表:
<span class="math display">\[
\xymatrix{
E\ar[r]^\psi&amp;L\\
F\ar[u]^\tau\ar[ru]_\varphi
}
\]</span> 回忆到我们本就拿到了<span class="math inline">\(E,F[x]\)</span>两者之间的关系,也即商同态<span class="math inline">\(\pi:F[x]\to
E=F[x]/(f)\)</span>,将此关系嵌入上述图表应当得到上述图表交换的等价条件是下述图表交换:
<span class="math display">\[
\xymatrix{
F[x]\ar[r]^\pi&amp;E\ar[r]^\psi&amp;L\\
&amp;F\ar[ul]\ar[u]^\tau\ar[ru]_\varphi
}
\]</span> 直接令<span class="math inline">\(\Psi=\psi\pi\)</span>,上图可以简化为: <span class="math display">\[
\xymatrix{
F[x]\ar[rr]^\Psi&amp;&amp;L\\
&amp;F\ar[ul]\ar[ru]_\varphi
}
\]</span>
现在观察此结构,若我们一开始的假设成立,此图表的确交换并且满足<span class="math inline">\(\Psi(x)=\psi(\pi(x))=\psi(\alpha)=\beta\)</span>,那么对于一般的多项式<span class="math inline">\(g=\sum b_kx^k\)</span>,立刻得到<span class="math inline">\(\Psi(g)=\sum
\varphi(b_k)\beta^n=g^\varphi(\beta)\)</span>,这立刻得到了<span class="math inline">\(\Psi\)</span>的唯一性,而直接使用此同态容易证明其存在性.</p>
<p>这个交换图表有什么用呢?来看其在复数上的表现情况.取<span class="math inline">\(F=\mathbb R\)</span>并且<span class="math inline">\(f=x^2+1\)</span>,此时<span class="math inline">\(-1\)</span>自然出现了平方根<span class="math inline">\(\alpha=x+(x^2+1)\)</span>.此时在上述图表中只需简单规定<span class="math inline">\(i\)</span>具体的正负取值立刻得到一个<span class="math inline">\(\mathbb R[x]/(x^2+1)\cong \mathbb
C\)</span>的同构.</p>
<h4><span id="对称多项式">对称多项式</span></h4>
<p>将置换的定义,挪到多元多项式环上,具体而言,<span class="math inline">\(\sigma
f(x_1,\cdots,x_n)=f(x_{\sigma(1)},\cdots,x_{\sigma(n)})\)</span>.</p>
<p>那么,如果带<span class="math inline">\(n\)</span>个变元的多项式<span class="math inline">\(f\)</span>其对任意置换都不变,换言之<span class="math inline">\(\forall \sigma,\sigma
f=f\)</span>,则称其是一个<strong>对称多项式</strong>.</p>
<p>我们记<span class="math inline">\(F[x_1,\cdots,x_n]^S\)</span>为所有在域<span class="math inline">\(F\)</span>上定义的<span class="math inline">\(n\)</span>个变元的对称多项式组成的集合,其当然是<span class="math inline">\(F[x_1,\cdots,x_n]\)</span>上的一个子环,因为如果<span class="math inline">\(f,g\)</span>对称,那么<span class="math inline">\(fg\)</span>和<span class="math inline">\(\alpha
f+\beta g\)</span>亦然.从这里也可以见到其还是一个线性空间.</p>
<p>接下来定义<span class="math inline">\(e_k=\sum_{1\leq
i_1&lt;\cdots&lt;i_k\leq n}x_{i_1}\cdots x_{i_k}\)</span>为第<span class="math inline">\(k\)</span>个<strong>初等对称多项式</strong>,例如<span class="math inline">\(e_n=x_1\cdots
x_n,e_1=x_1+\cdots+x_n\)</span>.并且还见到<strong>Vieta公式</strong>:<span class="math inline">\(\prod_{k=1}^n(y+x_k)=\sum_{k=0}^n e_k
y^{n-k}\)</span>或写作<span class="math inline">\(\prod_{k=1}^n(y-x_k)=\sum_{k=0}^n (-1)^k e_k
y^{n-k}\)</span></p>
<p>接下来我们要证明<strong>对称多项式基本定理</strong>,<span class="math inline">\(\forall f\in F[x_1,\cdots,x_n]^S,\exists g\in
F[x_1,\cdots,x_n],f=g(e_1,\cdots,e_n)\)</span>.</p>
<p>接下来我们定义<span class="math inline">\(f_d=\sum
_{i_1+\cdots+i_n=d}c_{i_1,\cdots,i_n}x_1^{i_1}\cdots
x_n^{i_n}\)</span>为<span class="math inline">\(d\)</span><strong>齐次多项式</strong>,容易见到任何一个多项式都可以写成若干齐次多项式之和.定义<span class="math inline">\(\deg
f\)</span>为它分解出来的最大的可能非零齐次多项式的次数.</p>
<p>接下来我们证明一个引理:对于<span class="math inline">\(f\in
F[x_1,\cdots,x_n]^S\)</span>,则<span class="math inline">\(f(x_1,\cdots,x_{n-1},0)=0\)</span>的充分必要条件是<span class="math inline">\(e_n|f\)</span>.</p>
<p>充分性显然,因为<span class="math inline">\(x_n|e_n\)</span>.</p>
<p>必要性的话,如若<span class="math inline">\(f(x_1,\cdots,x_{n-1},0)=\sum_{i_n=0}c_{i_1,\cdots,i_n}x_1^{i_1}\cdots
x_{n-1}^{i_{n-1}}=0\)</span>,这也就意味着<span class="math inline">\(c_{i_1,\cdots,i_n}\ne 0\Rightarrow i_n\geq
1\)</span>,而由于对称,意味着<span class="math inline">\(c_{i_1,\cdots,i_n}\ne 0\Rightarrow i_k\geq
1\)</span>,这就说明了<span class="math inline">\(e_n|f\)</span>.</p>
<p>对<span class="math inline">\(n\)</span>元对称多项式<span class="math inline">\(h\)</span>,记<span class="math inline">\(h^b=h(x_1,\cdots,x_{n-1},0)\)</span>,观察到<span class="math inline">\(h^b\)</span>当然是<span class="math inline">\(n-1\)</span>次多项式,而且<span class="math inline">\(e_1^b,\cdots,e_{n-1}^b\)</span>正好是第<span class="math inline">\(1,\cdots,n-1\)</span>个初等<span class="math inline">\(n-1\)</span>元对称多项式.</p>
<p>继续考虑证明对称多项式基本定理,首先对于<span class="math inline">\(f=\sum f_d\)</span>来说,<span class="math inline">\(f\)</span>是对称的当然等价于每一个<span class="math inline">\(f_d\)</span>都是对称的,所以我们下面不妨假设<span class="math inline">\(f=f_d\)</span>.</p>
<p>对于一个<span class="math inline">\(g\in
F[x_1,\cdots,x_n]\)</span>,定义其权重为<span class="math inline">\(wt(g)=\begin{cases}\max\{ \sum_{k=1}^nk i_k\mid
c_{i_1,\cdots,i_n}\ne 0 \}&amp;g\ne
0\\-\infty&amp;g=0\end{cases}\)</span>.</p>
<p>容易见到<span class="math inline">\(\deg g(e_1,\cdots,e_n)\leq
wt(g)\)</span>,这恰也是我们如此定义权重的原因.</p>
<p>下面我们证明:如果<span class="math inline">\(f\)</span>是<span class="math inline">\(d\)</span>次齐次的,则断言中的<span class="math inline">\(g\)</span>不仅存在还能取到<span class="math inline">\(wt(g)\leq d\)</span>.下面我们对<span class="math inline">\(n+d\)</span>递归地论证.</p>
<p>当<span class="math inline">\(d=0,f\in
F\)</span>当然是平凡的,下面设<span class="math inline">\(d\geq
1\)</span>.由于数学归纳,我们知道<span class="math inline">\(f^b\)</span>的元数量减少了<span class="math inline">\(1\)</span>.</p>
<p>当<span class="math inline">\(f^b\ne 0\)</span>时,那么如果<span class="math inline">\(f\)</span>是<span class="math inline">\(d\)</span>齐次的,容易见到<span class="math inline">\(f^b\)</span>也该是<span class="math inline">\(d\)</span>齐次的,那此时数学归纳给出存在<span class="math inline">\(g_1\in F[x_1,\cdots,x_{n-1}]\)</span>使得<span class="math inline">\(f^b=g_1(e_1^b,\cdots,e_{n-1}^b)\)</span>,而且<span class="math inline">\(\deg g_1(e_1,\cdots,e_{n-1})\leq wt(g_1)\leq
d\)</span>.</p>
<p>此时设<span class="math inline">\(f_1=f-g_1(e_1,\cdots,e_{n-1})\)</span>,立刻见到<span class="math inline">\(f_1^b=0\)</span>,那么<span class="math inline">\(e_n|f_1\)</span>,取<span class="math inline">\(f_2=\frac{f_1}{e_n}\)</span>,这里就可以看到如若<span class="math inline">\(f^b=0\)</span>,这里直接取<span class="math inline">\(f_1=f,g_1=0\)</span>即可.所以上述讨论在这一步就消掉了.</p>
<p>于是,这里的<span class="math inline">\(f_2\)</span>当然也是对称多项式,并且<span class="math inline">\(\deg f_2\leq
d-n\)</span>,那将其分解为齐次部分的和,运用递归假设知道存在<span class="math inline">\(f_2=g_2(e_1,\cdots,e_n),wt(g_2)\leq
d-n\)</span>.此时:</p>
<p><span class="math display">\[
f=f_1+g_1(e_1,\cdots,e_{n-1})\\
=e_ng_2(e_1,\cdots,e_n)+g_1(e_1,\cdots,e_{n-1})
\]</span></p>
<p>这就搞定了.</p>
<p>另一个问题是,上述算法只搞定了<span class="math inline">\(f=g(e_1,\cdots,e_n)\)</span>的存在性,它是否有唯一性呢?如若有<span class="math inline">\(g(e_1,\cdots,e_n)=h(e_1,\cdots,e_n)\)</span>,则<span class="math inline">\((g-h)(e_1,\cdots,e_n)=0\)</span>.我们应当证明以下定理,称为<span class="math inline">\(e_1,\cdots,e_n\)</span>的<strong>代数无关性</strong>:</p>
<p>若<span class="math inline">\(g\in
F[x_1,\cdots,x_n]\)</span>满足<span class="math inline">\(g(e_1,\cdots,e_n)=0\)</span>,则<span class="math inline">\(g=0\)</span>.</p>
<p>考虑证明其逆否命题,也就是<span class="math inline">\(g\ne
0\)</span>的话就一定有<span class="math inline">\(g(e_1,\cdots,e_n)\ne
0\)</span>.</p>
<p>首要的观察是先扩域,如果这个定义在更大的域上满足,在更小的域上当然也满足.因此可以先一步将<span class="math inline">\(F\)</span>扩到一个无穷域上,例如直接将其扩到有理分数域<span class="math inline">\(F(t)\)</span>上.下面假设<span class="math inline">\(F\)</span>是无穷域.则此时对于任意有限次数非零多项式<span class="math inline">\(g=0\)</span>,一定存在一组<span class="math inline">\((y_1,\cdots,y_n)\)</span>使得<span class="math inline">\(g(y_1,\cdots,y_n)\ne
0\)</span>,这是因为可以数学归纳,当<span class="math inline">\(n=1\)</span>的时候,其最多只有<span class="math inline">\(\deg g\)</span>个根但是<span class="math inline">\(F\)</span>无限,因此肯定存在.当<span class="math inline">\(n&gt;1\)</span>的时候,直接取<span class="math inline">\(g=\sum g_k
x_n^k\)</span>,那么由归纳假设一定存在一组<span class="math inline">\((y_1,\cdots y_{n-1})\)</span>使得至少有一个<span class="math inline">\(g_k\ne 0\)</span>,此时再由<span class="math inline">\(n=1\)</span>的结论就可以知道原命题成立.</p>
<p>接下来考虑<span class="math inline">\(p=\sum_{k=0}^n x^{n-k}(-1)^k
y_k\)</span>,回忆到可以扩域使得该多项式分裂,假设分裂成了<span class="math inline">\(p=\prod_{k=1}^n(x-x_i)\)</span>,此时由于Vieta公式,<span class="math inline">\(p=\sum_{k=0}^n (-1)^k e_k(x_1,\cdots,x_n)
x^{n-k}\)</span>,于是<span class="math inline">\(e_k(x_1,\cdots,x_n)=y_k\)</span>,这就导出了<span class="math inline">\(g(e_1,\cdots,e_n)=g(y_1,\cdots,y_n)\ne
0\)</span>.</p>
<p>容易见到上述论证不涉及域中的除法,所以上述结论对整环也是成立的.</p>
<h5><span id="牛顿公式">牛顿公式</span></h5>
<p>设<span class="math inline">\(p_k=\sum_{j=1}^nx_j^k\)</span>,这里的<span class="math inline">\(p_0\)</span>其实比较特殊,我们一般不去讨论<span class="math inline">\(p_0\)</span>.那么牛顿公式说:</p>
<ol type="1">
<li>当<span class="math inline">\(1\leq k\leq n\)</span>的时候,<span class="math inline">\(\sum_{j=0}^{k-1} (-1)^j e_j p_{k-j}=(-1)^{k-1}k
e_k\)</span>.</li>
<li>当<span class="math inline">\(k&gt;n\)</span>的时候,<span class="math inline">\(\sum_{j=0}^n (-1)^j e_j p_{k-j}=0\)</span>.</li>
</ol>
<p>牛顿公式的一个相当大的作用是可以用递归的方式用<span class="math inline">\(\{e_k\}\)</span>和<span class="math inline">\(\{p_k\}\)</span>相互表示.更进一步地,可以用<span class="math inline">\(\{e_k\}\)</span>的整系数多项式表示<span class="math inline">\(\{p_k\}\)</span>也可以用<span class="math inline">\(\{p_k\}\)</span>的有理系数多项式表示<span class="math inline">\(\{e_k\}\)</span>,当然对应的域要包含<span class="math inline">\(\mathbb{Z}\)</span>和<span class="math inline">\(\mathbb{Q}\)</span>.</p>
<p>如何证明上面那个结论?考虑以<span class="math inline">\(y\)</span>为变元的形式幂级数,定义:</p>
<p><span class="math display">\[
P(y)=\sum_{k\geq 1}p_k y^{k-1}\\
=\sum_{k\geq 1}\sum_{i=1}^n x_i^k y^{k-1}\\
=\sum_{i=1}^n\frac{x_i}{1-x_i y}
\]</span></p>
<p>再定义:</p>
<p><span class="math display">\[
E(y)=\sum_{k=0}^n e_k y^k\\
=\prod_{i=1}^n(1+x_i y)
\]</span></p>
<p>接下来观察到:</p>
<p><span class="math display">\[
P(-y)=\sum_{i=1}^n\frac{x_i}{1+x_i y}\\
=\frac{ {\rm d}}{ {\rm d}y}\ln E(y)\\
=\frac{E&#39;(y)}{E(y)}
\]</span></p>
<p>接下来观察:</p>
<p><span class="math display">\[
E(y)P(-y)=E&#39;(y)\\
=\sum_{k=1}^n k e_k y^{k-1}
\]</span></p>
<p>可是左边直接展开就有:</p>
<p><span class="math display">\[
E(y)P(-y)=(\sum_{l=0}^n e_l (-y)^l)(\sum_{j\geq 1}p_j y^{j-1})\\
\]</span></p>
<p>两边提取<span class="math inline">\([y^{k-1}]\)</span>,就有:</p>
<p><span class="math display">\[
\sum_{l+j=k,0\leq l\leq n,j\geq 1} e_lp_{j}(-1)^{j-1}=k e^k
\]</span></p>
<p>两边倒腾一下正负号就是牛顿公式.</p>
<h4><span id="结式">结式</span></h4>
<p>让<span class="math inline">\(F\)</span>是一个域并且<span class="math inline">\(f,g\in
F[x]\)</span>,我们想要检验它们是否互素.一个好的算法当然是辗转相除法,但我们更想去找一个精确的量来判定.例如矩阵的行列式可以用消元法求,然而我们也可以用代数余子式展开.</p>
<p>具体地,考虑<span class="math inline">\(F[x]\)</span>的元素:</p>
<p><span class="math display">\[
f=v_0 x^n+\cdots+v_n\\
g= w_0 x^m+\cdots + w_m
\]</span></p>
<p>注意这里并不要求<span class="math inline">\(v_0,w_0\ne
0\)</span>,结式并不在乎这个.</p>
<p>我们定义<span class="math inline">\(f,g\)</span>的结式为:</p>
<p><span class="math display">\[
Res(f,g)=
\left|\begin{matrix}
v_0&amp;\cdots&amp;\cdots&amp;v_n&amp;&amp;\\
&amp;\ddots&amp;&amp;&amp;\ddots&amp;\\
&amp;&amp;v_0&amp;\cdots&amp;\cdots&amp;v_n\\
w_0&amp;\cdots&amp;\cdots&amp;w_m&amp;&amp;\\
&amp;\ddots&amp;&amp;&amp;\ddots&amp;\\
&amp;&amp;w_0&amp;\cdots&amp;\cdots&amp;w_m
\end{matrix}\right|
\]</span></p>
<p>其中上面那个平行四边形是<span class="math inline">\(m\)</span>行的,下面那个是<span class="math inline">\(n\)</span>行的.这样总共就是<span class="math inline">\((n+m)\times
(n+m)\)</span>的,该行列式的定义是有意义的.如若将系数<span class="math inline">\(v_0,\cdots,w_m\)</span>视作变量,容易见到上述行列式仍然是关于<span class="math inline">\(v_0,\cdots,w_m\)</span>的整系数<span class="math inline">\(n+m+2\)</span>元多项式,且系数和<span class="math inline">\(F\)</span>无关.</p>
<p>考虑下述性质:</p>
<ol type="1">
<li><span class="math inline">\([v_0^mw_m^n]Res(f,g)=1\)</span>.</li>
<li><span class="math inline">\(Res(g,f)=(-1)^{nm}Res(f,g)\)</span>.</li>
<li><span class="math inline">\(\forall t\in F,Res(tf,g)=t^m
Res(f,g),Res(f,tg)=t^n Res(f,g)\)</span>.</li>
</ol>
<p>考虑(1),应当见到第<span class="math inline">\(m\)</span>行的那个<span class="math inline">\(v_0\)</span>恰好是第<span class="math inline">\(m\)</span>列,所以上述行列式对角线恰好由<span class="math inline">\(m\)</span>个<span class="math inline">\(v_0\)</span>和<span class="math inline">\(n\)</span>个<span class="math inline">\(w_m\)</span>构成,根据行列式最初始的那个排列定义,要凑出<span class="math inline">\(v_0^mw_m^n\)</span>就只能沿着对角线乘.</p>
<p>考虑(2),只需要交换行列即可对吧,每次把<span class="math inline">\(v\)</span>那里的最后一行暴力换到最下面,这样就需要交换<span class="math inline">\(nm\)</span>次.</p>
<p>(3)是显然的.</p>
<p>接下来证明一个引理:如果<span class="math inline">\(Res(f,g)=0\)</span>,当且仅当<span class="math inline">\(\exists f_1,g_1\in F[x]\)</span>满足<span class="math inline">\(\deg f_1&lt;n,\deg g_1&lt;m\)</span>并且<span class="math inline">\(f_1\)</span>和<span class="math inline">\(g_1\)</span>不全为<span class="math inline">\(0\)</span>,使得<span class="math inline">\(fg_1+gf_1=0\)</span>.</p>
<p>不妨展开<span class="math inline">\(f_1\)</span>和<span class="math inline">\(g_1\)</span>如下:</p>
<p><span class="math display">\[
f_1=a_1 x^{n-1}+\cdots+ a_n\\
g_1=b_1 x^{m-1}+\cdots+ b_m
\]</span></p>
<p>如若设<span class="math inline">\(H=fg_1+gf_1=0\)</span>,那么:</p>
<p><span class="math display">\[
[x^{n+m-1}]H=b_1v_0+a_1w_0=0\\
[x^{n+m-2}]H=b_1v_1+b_2v_0+a_1w_1+a_2w_0=0\\
\cdots\\
[x^{0}]H=b_mv_n+a_nw_m=0
\]</span></p>
<p>如果假设<span class="math inline">\(v_0,\cdots,w_m\)</span>均是已知量而尝试求解<span class="math inline">\(f_1,g_1\)</span>,自然拿到了一个大小为<span class="math inline">\(n+m\)</span>的线性方程组,容易见到其系数矩阵为:</p>
<p><span class="math display">\[
\begin{bmatrix}
v_0&amp;&amp;&amp;w_0&amp;&amp;\\
\vdots&amp;\ddots&amp;&amp;\vdots&amp;\ddots&amp;\\
v_n&amp;&amp;v_0&amp;w_m&amp;&amp;w_0\\
&amp;\ddots&amp;\vdots&amp;&amp;\ddots&amp;\vdots\\
&amp;&amp;v_n&amp;&amp;&amp;w_m
\end{bmatrix}
\]</span></p>
<p>(很遗憾这里把第<span class="math inline">\(n+1\)</span>行和第<span class="math inline">\(m+1\)</span>行画到一行了,然而是无奈之举,自行在脑中错开一下位置)</p>
<p>线性方程组理论告诉我们这有一组非<span class="math inline">\(0\)</span>解当且仅当行列式为<span class="math inline">\(0\)</span>,然而这恰好是<span class="math inline">\(Res(f,g)\)</span>的转置,而行列式转置不变,这就证毕.</p>
<p>下面我们证明,<span class="math inline">\(Res(f,g)=0\)</span>当且仅当以下任何一个条件成立:</p>
<ol type="1">
<li><span class="math inline">\(v_0=w_0=0\)</span>.</li>
<li><span class="math inline">\(\deg \gcd(f,g)&gt;0\)</span>.</li>
</ol>
<p>(1)是平凡的,只需观察上述行列式定义即可发现此时第一列全部为<span class="math inline">\(0\)</span>,那行列式当然为<span class="math inline">\(0\)</span>.</p>
<p>对于(2),先证必要性,考虑如果<span class="math inline">\(\exists
h,\deg  h&gt;0\)</span>,<span class="math inline">\(h|f,h|g\)</span>,那么注意到<span class="math inline">\(\deg \frac{f}{h}&lt;n,\deg
\frac{g}{h}&lt;m\)</span>而且由于<span class="math inline">\(v_0\)</span>和<span class="math inline">\(w_0\)</span>不全为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(\frac{f}{h},\frac{g}{h}\)</span>不全为<span class="math inline">\(0\)</span>,而<span class="math inline">\(f\frac{g}{h}-g\frac{f}{h}=0\)</span>,用引理得证<span class="math inline">\(Res(f,g)=0\)</span>.</p>
<p>再证(2)的充分性.如若<span class="math inline">\(f,g\)</span>其一为<span class="math inline">\(0\)</span>,不失一般性设<span class="math inline">\(f=0\)</span>.如若此时<span class="math inline">\(\deg g&gt;0\)</span>,则取<span class="math inline">\(h=g\)</span>自然是公因式;如若<span class="math inline">\(\deg g=0\)</span>,容易见到<span class="math inline">\(w_0=Res(f,g)=0\)</span>,这就是(1)的情况.</p>
<p>如若<span class="math inline">\(f,g\)</span>都不是<span class="math inline">\(0\)</span>,而且<span class="math inline">\(v_0,w_0\)</span>不全为<span class="math inline">\(0\)</span>,不妨设<span class="math inline">\(w_0\ne 0\)</span>,既如此<span class="math inline">\(g\ne 0\)</span>,此时如若<span class="math inline">\(Res(f,g)=0\)</span>,由引理拿到了<span class="math inline">\(f_1,g_1\)</span>不全为<span class="math inline">\(0\)</span>并且使得<span class="math inline">\(fg_1+gf_1=0\)</span>,其中<span class="math inline">\(\deg g_1&lt;m\)</span>.</p>
<p>直接把当前的多项式环<span class="math inline">\(F[x]\)</span>扩到有理分式域<span class="math inline">\(F(x)\)</span>,此时有<span class="math inline">\(\frac{f}{g}g_1=f_1\)</span>,两边通分立刻见到,如果<span class="math inline">\(\deg gcd(f,g)=0\)</span>,那么左边就是<span class="math inline">\(f\frac{g_1}{g}\)</span>,这应该给出<span class="math inline">\(g|g_1\)</span>,然而<span class="math inline">\(\deg g=m,\deg g_1&lt;m\)</span>,不符.这就证毕.</p>
<p>最后,我们来讨论一下当<span class="math inline">\(f,g\)</span>均是分裂的时候如何体现,不妨设<span class="math inline">\(f=a\prod_{k}^n(x-\alpha_k),g=b\prod_{k}^m(x-\beta_k)\)</span>,我们下面证明:</p>
<p><span class="math display">\[
Res(f,g)=a^m\prod_k^n g(\alpha_k)=(-1)^{nm}b^n\prod_j^m f(\beta_j)\\
=a^mb^n\prod_{k,j}(\alpha_k-\beta_j)
\]</span></p>
<p>有一连串等式,其中中间两个是对称的<span class="math inline">\(Res(f,g)\)</span>和<span class="math inline">\(Res(g,f)\)</span>的形式,而最后一个等式只需带入就属显然.因此需要证明的只有第一个等式.</p>
<p>由于<span class="math inline">\(Res(tf,g)=t^mRes(f,g)\)</span>,所以不妨设<span class="math inline">\(a=1\)</span>.</p>
<p>假设<span class="math inline">\(g(\alpha_1),\cdots,g(\alpha_n)\)</span>两两相异,则引入一个新的变元<span class="math inline">\(y\)</span>并在<span class="math inline">\(F[y]\)</span>上考虑<span class="math inline">\(Res(f,g-y)\)</span>,回看一开始的矩阵形状,对于<span class="math inline">\([y^n]Res(f,g-y)\)</span>,见到其意味着下半部分的对角线被全部选择,上半部分选择的话如果非零当然也要选择对角线,所以<span class="math inline">\([y^n]Res(f,g-y)=(-1)^n\)</span>,而显然<span class="math inline">\([y^0]Res(f,g-y)=Res(f,g)\)</span>.既然如此,注意到<span class="math inline">\(\alpha_k\)</span>是<span class="math inline">\(f\)</span>和<span class="math inline">\(g-g(\alpha_k)\)</span>的公共根,则<span class="math inline">\(Res(f,g-g(\alpha_k))=0\)</span>,从而<span class="math inline">\((g(\alpha_k)-y)|Res(f,g-y)\)</span>,又由于<span class="math inline">\(g(\alpha_1),\cdots,g(\alpha_n)\)</span>两两相异,<span class="math inline">\(\prod_k
(g(\alpha_k)-y),Res(f,g-y)\)</span>的最高次系数都是<span class="math inline">\((-1)^n\)</span>,这立刻意味着它们相等,原命题自然成立.</p>
<p>然而既然如此,可以见到直接假设<span class="math inline">\(\alpha_1,\cdots,\alpha_n\)</span>并非常数而是若干个变元,具体而言用<span class="math inline">\(z_1,\cdots,z_n\)</span>代替它们,于是上述立刻有<span class="math inline">\(g(z_1),\cdots,g(z_n)\)</span>两两相异,得到结论后带入<span class="math inline">\(\alpha_1,\cdots,\alpha_n\)</span>即可.</p>
<h4><span id="判别式">判别式</span></h4>
<p>对于一个多项式<span class="math inline">\(f=\sum_k c_k (-1)^{k}
x^{n-k}\)</span>,假设其可分裂而且<span class="math inline">\(f=\prod_j
(x-\alpha_j)\)</span>,我们称其判别式<span class="math inline">\(disc(f)=\prod_{i&lt;j}(\alpha_i-\alpha_j)^2\)</span>如果我们将<span class="math inline">\(\alpha_1,\cdots,\alpha_n\)</span>看作变量,则我们注意到<span class="math inline">\(disc(f)\)</span>是一个对称多项式,原因是<span class="math inline">\(disc(f)=(\prod_{i&lt;j}(\alpha_i-\alpha_j))^2\)</span>,而中间那个东西在重排后会差一个<span class="math inline">\({\rm {sgn}}(\sigma)\)</span>,这就证毕.</p>
<p>既然如此,<span class="math inline">\(disc(f)\)</span>就可以拆成<span class="math inline">\(e_1,\cdots,e_n\)</span>这若干个对称多项式的多项式,然而注意到由于Vieta公式,<span class="math inline">\(e_1=c_1,\cdots,e_n=c_n\)</span>.于是<span class="math inline">\(disc(f)\)</span>当然是关于<span class="math inline">\(c_1,\cdots,c_n\)</span>的多项式.这里由于没有讨论具体的值,而只是把这些涉及到的值用变量来表示,所以你可以先一步把范围控制在整环<span class="math inline">\(\mathbb{Z}\)</span>上,见到<span class="math inline">\(disc(f)\)</span>当然是关于<span class="math inline">\(c_1,\cdots,c_n\)</span>的整系数多项式.</p>
<p>例如当<span class="math inline">\(n=2\)</span>的时候,<span class="math inline">\(f(x)=x^2-bx+c=(x-\alpha_1)(x-\alpha_2)\)</span>,那么<span class="math inline">\(disc(f)=(\alpha_1-\alpha_2)^2=(\alpha_1+\alpha_2)^2-4\alpha_1\alpha_2=b^4-4c\)</span>,这就是二次方程的判别式.</p>
<p>取<span class="math inline">\(n=3\)</span>的时候,特别地取二次项为<span class="math inline">\(0\)</span>的情况,<span class="math inline">\(f=x^3+px+q=(x-\alpha_1)(x-\alpha_2)(x-\alpha_3),\alpha_1+\alpha_2+\alpha_3=0\)</span>,注意到:</p>
<p><span class="math display">\[
disc(f)=\left((\alpha_1-\alpha_2)(\alpha_2-\alpha_3)(\alpha_1-\alpha_3)\right)^2\\
=-4p^3-27q^2
\]</span></p>
<p>而如果将判别式的定义推广到非首一的情形,也就是对于<span class="math inline">\(f=a\prod_j
(x-\alpha_j)\)</span>,我们称其判别式<span class="math inline">\(disc(f)=a^{2n-2}\prod_{i&lt;j}(\alpha_i-\alpha_j)^2\)</span>,对<span class="math inline">\(f\)</span>有形式导数<span class="math inline">\(f&#39;\)</span>,我们下面证明:<span class="math inline">\(a\sdot
disc(f)=(-1)^{\frac{n(n-1)}{2}}Res(f,f&#39;)\)</span>.</p>
<p>证明的话,用Leibniz法则,知道:</p>
<p><span class="math display">\[
f&#39;=a\sum_{k=1}^n\prod_{j\ne k}(x-\alpha_j)\\
f&#39;(\alpha_k)=a\prod_{j\ne k}(\alpha_k-\alpha_j)
\]</span></p>
<p>因此:</p>
<p><span class="math display">\[
Res(f,f&#39;)=a^{n-1}\prod_{k=1}^nf&#39;(\alpha_k)\\
=a^{2n-1}\prod_{k=1}^n\prod_{j\ne k}(\alpha_k-\alpha_j)\\
=a^{2n-1}(-1)^{\frac{n(n-1)}{2}}\prod_{i&lt;j}(\alpha_i-\alpha_j)^2
\]</span></p>
<p>这就证毕.</p>
<p>顺便一提,将<span class="math inline">\(f=a_0 x^n+\cdots
+a_n\)</span>,则<span class="math inline">\(Res(f,f&#39;)\)</span>是<span class="math inline">\(a_0,\cdots,a_n\)</span>的整系数多项式,而其行列式首列能提出<span class="math inline">\(a=a_0\)</span>,因此<span class="math inline">\(a^{-1}Res(f,f&#39;)\)</span>确实表作<span class="math inline">\(a_0,\cdots,a_n\)</span>的整系数多项式,这说明<span class="math inline">\(disc(f)\)</span>在<span class="math inline">\(f\)</span>非首一的时候定义确实合理.</p>
<h3><span id="域">域</span></h3>
<p>设<span class="math inline">\(D\)</span>是含有至少两个元素的幺环,如果<span class="math inline">\(D\)</span>的每个元素都可逆,则称<span class="math inline">\(D\)</span>是一个<strong>体</strong>.有乘法交换律的体称为<strong>域</strong>.</p>
<h4><span id="分式域">分式域</span></h4>
<p>之前尝试使用过商集来用<span class="math inline">\(\Z\)</span>构造<span class="math inline">\(\Q\)</span>,我们同样可以用整环的商集来构造形如<span class="math inline">\(\frac{f}{g}\)</span>的域,将其记作<span class="math inline">\(\text{Frac}(R)\)</span>,也就是<strong>分式域</strong>.</p>
<p>可以说明如果<span class="math inline">\(\varphi:R\rightarrow
R&#39;\)</span>并且<span class="math inline">\(\varphi(R\setminus\{0\})\subseteq R&#39;^{\times
}\)</span>,又取一个<span class="math inline">\(i:R\rightarrow \text
{Frac} R\)</span>,那么存在唯一一个映射<span class="math inline">\(\Phi
:\text{Frac }R\rightarrow R&#39;\)</span>的映射.更具体来说,只需验证<span class="math inline">\(\Phi(\frac{f}{g})\equiv
\varphi(f)\varphi(g)^{-1}\)</span>即可(当然需要检验良定义).</p>
<p>如果我们将一开始的映射改为<span class="math inline">\(\varphi:R\hookrightarrow F\)</span>,其中<span class="math inline">\(F\)</span>是一个域并且<span class="math inline">\(\forall x\in F,\exists f,g\in
R,x=\varphi(f)\varphi(g)^{-1}\)</span>,那我们可以证明<span class="math inline">\(\text{Frac}(R)\cong
F\)</span>,过程太无聊,略过.</p>
<p>这说明分式域具有某种唯一性和泛性质.</p>
<p>一般把<span class="math inline">\(\text{Frac}(R[x])\)</span>写作<span class="math inline">\(R(x)\)</span>.</p>
<h4><span id="子域">子域</span></h4>
<p>由于子域的交还是子域,我们当然可以取所有子域的交得到一个子域<span class="math inline">\(F_{prime}\)</span>,容易验证当<span class="math inline">\(\text{char }F_{prime}=0\)</span>的时候,<span class="math inline">\(F_{prime}\cong \Q\)</span>;当<span class="math inline">\(p=\text{char}F_{prime}\in
prime\)</span>的时候,<span class="math inline">\(F_{prime}\cong
\Z/\Z_p\)</span>.</p>
<h2><span id="线性代数">线性代数</span></h2>
<h3><span id="矩阵引入">矩阵引入</span></h3>
<p>我们称有<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列的<strong>矩阵</strong>为<span class="math inline">\(A_{m\times n}\)</span>,其中第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素称作<span class="math inline">\(a_{i,j}\)</span>,也有的称其为<strong>矩阵元</strong>.</p>
<p>也可以将其中中的列写作<span class="math inline">\(F^m\)</span>中列向量的形式,即写作<span class="math inline">\(A_{m\times
n}=\begin{bmatrix}\vec{a_1}&amp;\vec{a_2}&amp;...&amp;\vec{a_n}\end{bmatrix}\)</span>.</p>
<p>若<span class="math inline">\(n=m\)</span>,则称<span class="math inline">\(A\)</span>为<strong>方阵</strong>.</p>
<h4><span id="矩阵运算">矩阵运算</span></h4>
<p>大小相同的矩阵本身应当是一个线性空间.事实上,我们可以定义:</p>
<ol type="1">
<li><strong>矩阵加法</strong>:若矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是<span class="math inline">\(m\times
n\)</span>矩阵,则它们的和也是<span class="math inline">\(m\times
n\)</span>矩阵,且元素为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>中对应元素的加和.显然有交换律.</li>
<li><strong>标量乘法</strong>:若<span class="math inline">\(c\)</span>是标量而<span class="math inline">\(A\)</span>是一个<span class="math inline">\(m\times n\)</span>矩阵,则<span class="math inline">\(cA\)</span>是一个<span class="math inline">\(m\times n\)</span>矩阵,且元素为A中对应元素的<span class="math inline">\(c\)</span>倍.显然有交换律以及对矩阵加法的分配律.</li>
</ol>
<p>事实上,我们还可以定义:</p>
<ol start="3" type="1">
<li><strong>矩阵乘法</strong>:若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times
n\)</span>矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times p\)</span>矩阵,那么它们的乘积<span class="math inline">\(AB_{i,j}=\sum_{k=1}^nA_{i,k}B_{k,j}\)</span>.</li>
</ol>
<p>矩阵乘法也可以表示为:若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times
p\)</span>矩阵,且<span class="math inline">\(B=\begin{bmatrix}\vec{b_1}&amp;\vec{b_2}&amp;...&amp;\vec{b_p}\end{bmatrix}\)</span>那么它们的乘积<span class="math inline">\(AB=\begin{bmatrix}A\vec{b_1}&amp;A\vec{b_2}&amp;...&amp;A\vec{b_p}\end{bmatrix}\)</span>.</p>
<p>若<span class="math inline">\(AB=BA\)</span>我们称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>彼此<strong>可交换</strong>.</p>
<p>不难发现<span class="math inline">\(\forall A_{m\times
n}\)</span>,对于矩阵<span class="math inline">\(I_{n\times
n}=\begin{bmatrix}1&amp;0&amp;...&amp;0\\0&amp;1&amp;...&amp;0\\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;1\end{bmatrix}\)</span>有<span class="math inline">\(AI=A\)</span>,我们称<span class="math inline">\(I_{n\times
n}\)</span>为<strong>单位矩阵</strong>.单位矩阵的第<span class="math inline">\(i\)</span>列通常记作<span class="math inline">\(\vec e_i\)</span>.</p>
<p>定义<strong>乘幂</strong><span class="math inline">\(A^k\)</span>为<span class="math inline">\(k\)</span>个<span class="math inline">\(A\)</span>连续相乘的乘积.</p>
<p>设<span class="math inline">\(A\)</span>为<span class="math inline">\(m\times n\)</span>矩阵,<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol type="1">
<li>乘法结合律:<span class="math inline">\((AB)C=A(BC)\)</span>.</li>
<li>乘法左分配律:<span class="math inline">\(A(B+C)=AB+AC\)</span>.</li>
<li>乘法右分配律:<span class="math inline">\((B+C)A=BA+CA\)</span>.</li>
<li><span class="math inline">\(c(AB)=(cA)B=A(cB)\)</span>.</li>
<li>乘法恒等式:<span class="math inline">\(I_mA=A=AI_n\)</span>.</li>
</ol>
<p>注意到向量可以看为一个<span class="math inline">\(n\times
1\)</span>的矩阵,事实上,我们有:</p>
<p>若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵,它的各列为<span class="math inline">\(\vec{a_1},\vec{a_2},...\vec{a_n}\)</span>,而<span class="math inline">\(\vec{u},\vec{v}\in\mathbb{R}^n\)</span>,那么:</p>
<ol type="1">
<li><span class="math inline">\(A(\vec{u}+\vec{v})=A\vec{u}+A\vec{v}\)</span>.</li>
<li><span class="math inline">\(A(c\vec{u})=c(A\vec{u})\)</span>.</li>
</ol>
<p>定义<strong>矩阵转置</strong>:对于<span class="math inline">\(m\times
n\)</span>矩阵<span class="math inline">\(A\)</span>,它的<strong>转置</strong>是一个<span class="math inline">\(n\times m\)</span>矩阵,该矩阵的列是由<span class="math inline">\(A\)</span>的对应行构成的,记作<span class="math inline">\(A^T\)</span>,即<span class="math inline">\(A^T_{i,j}=A_{j,i}\)</span>.有的时候也写作<span class="math inline">\(^tA\)</span>.</p>
<p>设<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol type="1">
<li><span class="math inline">\((A^T)^T=A\)</span>.</li>
<li><span class="math inline">\((A+B)^T=A^T+B^T\)</span>.</li>
<li><span class="math inline">\((rA)^T=rA^T\)</span>.</li>
<li><span class="math inline">\((AB)^T=B^TA^T\)</span>.</li>
</ol>
<h5><span id="kronecker积">Kronecker积</span></h5>
<p>对于矩阵<span class="math inline">\(X\in F^{n\times m},Y\in
F^{p\times q}\)</span>,我们定义它们的克罗内多积为: <span class="math display">\[
X\otimes
Y=\begin{bmatrix}x_{1,1}Y&amp;x_{1,2}Y&amp;\cdots&amp;x_{1,m}Y\\x_{2,1}Y&amp;x_{2,2}Y&amp;\cdots&amp;x_{2,m}Y\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_{n,1}Y&amp;x_{n,2}Y&amp;\cdots&amp;x_{n,m}Y\end{bmatrix}\in
F^{(np)\times (mq)}
\]</span> 克罗内多积显然不满足交换律.</p>
<p>事实上,设<span class="math inline">\(X,Y,Z\)</span>在下列运算中有意义,克罗内多积满足以下性质:</p>
<ol type="1">
<li>结合律:<span class="math inline">\(X\otimes Y\otimes Z=X\otimes
(Y\otimes Z)\)</span>.</li>
<li>左分配律:<span class="math inline">\(X\otimes (Y+Z)=X\otimes
Y+X\otimes Z\)</span>.</li>
<li>右分配律:<span class="math inline">\((X+Y)\otimes Z=X\otimes
Z+Y\otimes Z\)</span>.</li>
<li><span class="math inline">\((X\otimes Y)^T=X^T\otimes
Y^T\)</span>.</li>
<li><span class="math inline">\((X\otimes Y)(U\otimes V)=(XU)\otimes
(YV)\)</span>.</li>
<li><span class="math inline">\(X^{-1}\otimes Y^{-1}=(X\otimes
Y)^{-1}\)</span>.</li>
<li><span class="math inline">\(\det(X\otimes Y)=\det(X)^m\det(Y)^n,X\in
F^{n\times n},Y\in F^{m\times m}\)</span>.</li>
<li><span class="math inline">\(rank(X\otimes Y)=rank(X)\times
rank(Y)\)</span>.</li>
</ol>
<p>克罗内多积的性质有一个很有用的特例是: <span class="math display">\[
A\otimes B\otimes C=(A\otimes I_n\otimes I_n)(I_n\otimes B\otimes
I_n)(I_n\otimes I_n\otimes C)\\
A,B,C\in F^{n\times n}
\]</span></p>
<h4><span id="分块矩阵">分块矩阵</span></h4>
<p>我们考虑将一个矩阵看作若干个子矩阵的拼接,类似于我们求逆矩阵时做的那样:将若干个矩阵拼接起来.</p>
<p>换句话说,我们尝试将矩阵看作元素放入矩阵中,并尝试根据基本的矩阵运算去做这种矩阵的运算.</p>
<p>分块矩阵的<strong>矩阵加法</strong>:若矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>维数相同且都以同样的方式分块,则矩阵的和<span class="math inline">\(A+B\)</span>也以同样的方式分块且每一块都是<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>对应块的和.</p>
<p>分块矩阵的<strong>标量乘法</strong>:若<span class="math inline">\(c\)</span>是一个常数,<span class="math inline">\(A\)</span>是一个分块矩阵,则<span class="math inline">\(cA\)</span>是<span class="math inline">\(A\)</span>的子矩阵乘<span class="math inline">\(c\)</span>再以同样的方式组合起来的结果.</p>
<p>分块矩阵的<strong>矩阵乘法</strong>:若矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的维数使得<span class="math inline">\(AB\)</span>有定义,并且<span class="math inline">\(A\)</span>列的分法与<span class="math inline">\(B\)</span>行的分法一致,那我们显然可以直接将矩阵作为元素来直接进行矩阵乘法.</p>
<p>由上面的讨论自然发现:</p>
<p>若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times
p\)</span>矩阵,我们定义<span class="math inline">\(row_i(A)\)</span>为<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>列,<span class="math inline">\(col_i(A)\)</span>为<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行,则:</p>
<p><span class="math inline">\(AB=\begin{bmatrix}col_1(A)&amp;col_2(A)&amp;...&amp;col_n(A)\end{bmatrix}\begin{bmatrix}row_1(B)\\row_2(B)\\..\\row_n(B)\end{bmatrix}\)</span></p>
<p>证明是显然的.</p>
<h3><span id="线性方程组">线性方程组</span></h3>
<p>包含变量<span class="math inline">\(x_1,x_2...,x_n\)</span>的<strong>线性方程</strong>是形如<span class="math inline">\(a_1x_2+a_2x_2+...+a_nx_n=b\)</span>的方程,其中b与系数是实数或复数,通常是已知数.</p>
<p><strong>线性方程组</strong>是由一个或几个包含相同变量<span class="math inline">\(x_1,x_2,...,x_n\)</span>的线性方程组成的.</p>
<p><strong>线性方程组的解</strong>是一组数<span class="math inline">\(\{s_1,s_2,...,s_n\}\)</span>,用这组数分别代替<span class="math inline">\(x_1,x_2,...x_n\)</span>时所有方程的两边相等.</p>
<p>线性方程组所有可能的解的集合称为<strong>线性方程组的解集</strong>.</p>
<p>若两个线性方程组有相同的解集,则称这两个方程组是<strong>等价的</strong>.</p>
<p>我们称一个线性方程组是<strong>相容的</strong>,当且仅当它有一个解或无穷多个解,否则,称其为<strong>不相容的</strong>.</p>
<p>一个线性方程组要么无解,要么有一个解,要么有无穷多个解.</p>
<h4><span id="系数矩阵和增广矩阵">系数矩阵和增广矩阵</span></h4>
<p>考虑以下m个线性方程所组成的线性方程组:</p>
<p><span class="math display">\[\begin{cases}
a_{1,1}x_1+a_{1,2}x_2+...+a_{1,n}x_n=b_1\\
a_{2,1}x_1+a_{2,2}x_2+...+a_{2,n}x_n=b_2\\
...\\
a_{m,1}x_1+a_{m,2}x_2+...+a_{m,n}x_n=b_m
\end{cases}\]</span> 我们称它的<strong>系数矩阵</strong>为:</p>
<p><span class="math display">\[\begin{bmatrix}
a_{1,1}&amp;a_{1,2}&amp;...&amp;a_{1,n}\\
a_{2,1}&amp;a_{2,2}&amp;...&amp;a_{2,n}\\
... &amp;...&amp;...&amp;...\\
a_{m,1}&amp;a_{m,2}&amp;...&amp;a_{m,n}
\end{bmatrix}\]</span></p>
<p>两个系数矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<p>而称它的<strong>增广矩阵</strong>为: <span class="math display">\[\begin{bmatrix}
a_{1,1}&amp;a_{1,2}&amp;...&amp;a_{1,n}&amp;b_1\\
a_{2,1}&amp;a_{2,2}&amp;...&amp;a_{2,n}&amp;b_2\\
... &amp;...&amp;...&amp;...&amp;...\\
a_{m,1}&amp;a_{m,2}&amp;...&amp;a_{m,n}&amp;b_m
\end{bmatrix}\]</span></p>
<p>两个增广矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<h4><span id="矩阵的初等行变换">矩阵的初等行变换</span></h4>
<p>考虑如何解一个线性方程:根据我们已有的知识,等式可以任意两端加减相等的两项,也可以同时乘以一个不为0的数,同时等式的顺序并不重要.</p>
<p>我们用这一点来考虑如何解线性方程组.这里主要是考虑如何对线性方程组的增广矩阵进行变换.</p>
<p>由上面的知识,我们意识到对线性方程组的增广矩阵进行以下变换,是不会改变其解集的:</p>
<ol type="1">
<li>(倍加变换)把某一行换成它本身与另一行的倍数的和,记作<span class="math inline">\(R_i+kR_j\rightarrow R_i\)</span>.</li>
<li>(对换变换)把两行对换,记作<span class="math inline">\(R_i\leftrightarrow R_j\)</span>.</li>
<li>(倍乘变换)把某一行的所有元素乘以同一个非零数<span class="math inline">\(k\)</span>,记作<span class="math inline">\(kR_i\rightarrow R_i,k\ne0\)</span>.</li>
</ol>
<p>以上三种变换称为<strong>矩阵的初等行变换</strong>,同理可以定义初等列变换.</p>
<p>由此可以发现,两个增广矩阵是等价的当且仅当其中一个增广矩阵可以通过若干次初等行变换变为另一个增广矩阵.</p>
<p>我们可以使用这些初等行变换来变换一个矩阵,使得它有一些特殊性质.</p>
<p>如果两个矩阵可以通过若干次初等行变换而转化,我们称二者<strong>行等价</strong>,不难证明行等价满足等价关系的三个性质(反身性,对称性,传递性).</p>
<p>由于简化行阶梯矩阵的唯一性,我们可以用其来判定行等价类.</p>
<h4><span id="阶梯形矩阵">阶梯形矩阵</span></h4>
<p>若矩阵的一行的元素全为0,称这一行为矩阵的一个<strong>零行</strong>,否则称为<strong>非零行</strong>.</p>
<p>非零行的最左边的非零元素称为该行的<strong>先导元素</strong>.</p>
<p>若一个矩阵有以下性质,则称它为<strong>阶梯形矩阵(REF)</strong>:</p>
<ol type="1">
<li>每一个非零行都在零行之上</li>
<li>某一行的先导元素所在的列位于前一行先导元素的右边</li>
<li>某一先导元素所在列下方元素都是0</li>
</ol>
<p>若一个矩阵还满足以下性质,则称它为<strong>简化阶梯形(RREF)</strong>:</p>
<ol start="4" type="1">
<li>每一非零行的先导元素是1</li>
<li>每一先导元素1是该元素所在列唯一的非零元素</li>
</ol>
<p>显然,任意一个矩阵都可以通过若干次初等行变换变为一个阶梯形矩阵或简化阶梯形矩阵.</p>
<p>一个矩阵所对应的阶梯形矩阵中先导元素的位置,被称为这个矩阵的一个<strong>主元位置</strong>,包含一个主元位置的列称为<strong>主元列</strong>.</p>
<p>注意:这里的位置是矩阵中的位置而非元素的位置,这也就是说主元位置上的元素可以不是最终的主元位置上的元素移动而来的.</p>
<h5><span id="简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</span></h5>
<p>每个矩阵通过初等行变换只有可能对应唯一一个简化阶梯形矩阵.</p>
<p>证明:假设两个行等价的简化阶梯形矩阵不相等.那么我们找到它们的第一个不相等的列,设为<span class="math inline">\(j\)</span>.</p>
<p>如果<span class="math inline">\(A,B\)</span>中的<span class="math inline">\(j\)</span>均为主元列,显然它们这一列必然相等,不符.</p>
<p>反之,我们不妨去掉第<span class="math inline">\(j\)</span>列后面的所有列以及第<span class="math inline">\(j\)</span>列前面的所有非主元列,保留第<span class="math inline">\(j\)</span>列考虑剩下的两个矩阵一定也是行等价的,但它们对应的线性方程组的解显然不同,这导出了矛盾.</p>
<h4><span id="解线性方程组">解线性方程组</span></h4>
<p>考虑将线性方程组的增广矩阵通过初等行变换变换为一个简化阶梯形矩阵,我们称对应于主元列的变量为<strong>基本变量</strong>,其它变量称为<strong>自由变量</strong>.</p>
<p>如果线性方程组是相容的,显然我们可以使用自由变量表示基本变量,从而得到一组解.我们得到的基本变量的关于自由变量的表达式称作解集的<strong>参数表示</strong>.</p>
<p>这也意味着,如果没有自由变量,该方程组只有一解;如果有自由变量,由于自由变量取值任意,该方程组有无数组解.</p>
<p>而考虑何时线性方程组不相容,由于自由变脸取值任意,显然唯一的不相容可能性只是出现了<span class="math inline">\(0x_1+0x_2+...+0x_n=b,b\ne 0\)</span>的情况.</p>
<p>以上的分析过程引出下面的定理.</p>
<h5><span id="存在与唯一性定理">存在与唯一性定理</span></h5>
<p>线性方程组相容的充要条件是增广矩阵的最右列不是主元列.</p>
<p>若线性方程组相容,则它的解集可能有两种情形:</p>
<ol type="1">
<li>没有自由变量时,只有一个解.</li>
<li>有自由变量时,有无数个解.</li>
</ol>
<h4><span id="矩阵方程">矩阵方程</span></h4>
<p>设<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>的矩阵,它的各列是<span class="math inline">\(\vec{a_1},\vec{a_2},...,\vec{a_n}\)</span>,若<span class="math inline">\(\vec{x}\)</span>是<span class="math inline">\(F^n\)</span>中向量,则<span class="math inline">\(A\vec x\)</span>即A的各列以<span class="math inline">\(\vec{x}\)</span>中对应元素为权的线性组合,也就是:</p>
<p><span class="math inline">\(A\vec{x}=\begin{bmatrix}\vec{a_1}&amp;\vec{a_2}&amp;...&amp;\vec{a_n}\end{bmatrix}\begin{bmatrix}x_1\\x_2\\...\\x_n\end{bmatrix}=x_1\vec{a_1}+x_2\vec{a_2}+...+x_n\vec{a_n}\)</span></p>
<p>如果令<span class="math inline">\(\vec{b}\in
F^m\)</span>,那么上式可以写成<span class="math inline">\(A\vec{x}=\vec{b}\)</span>,我们把形如这样的方程称作矩阵方程.</p>
<p>不难发现,若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵,它的各列为<span class="math inline">\(\vec{a_1},\vec{a_2},...\vec{a_n}\)</span>,而<span class="math inline">\(\vec{b}\in F^m,\vec{x}\in F^n\)</span>,那么:</p>
<p>矩阵方程<span class="math inline">\(A\vec{x}=\vec{b}\)</span>,向量方程<span class="math inline">\(x_1\vec{a_1}+x_2\vec{a_2}+...+x_n\vec{a_n}=\vec{b}\)</span>,增广矩阵为<span class="math inline">\(\begin{bmatrix}\vec{a_1}&amp;\vec{a_2}&amp;...&amp;\vec{a_n}&amp;\vec{b}\end{bmatrix}\)</span>的线性方程组有相同的解集.</p>
<p>事实上,若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵,它的各列为<span class="math inline">\(\vec{a_1},\vec{a_2},...\vec{a_n}\)</span>,那么以下命题逻辑等价:</p>
<ol type="1">
<li><span class="math inline">\(\forall \vec b\in F^m\)</span>,方程<span class="math inline">\(A\vec{x}=\vec{b}\)</span>有解.</li>
<li><span class="math inline">\(\forall \vec b\in F^m\)</span>,<span class="math inline">\(\vec{b}\)</span>是<span class="math inline">\(A\)</span>的列的一个线性组合.</li>
<li><span class="math inline">\(A\)</span>的各列生成<span class="math inline">\(\mathbb R^m\)</span>.</li>
<li><span class="math inline">\(A\)</span>在每一行都有一个主元位置.</li>
</ol>
<h4><span id="齐次线性方程组">齐次线性方程组</span></h4>
<p>若一个线性方程组可以被写成<span class="math inline">\(A\vec{x}=\vec{0}\)</span>的形式,其中<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times
n\)</span>的矩阵,<span class="math inline">\(\vec{x}\)</span>是<span class="math inline">\(\mathbb{R}^n\)</span>中的向量,称其为<strong>齐次线性方程组</strong>.</p>
<p>显然齐次线性方程组至少有一个解,即<span class="math inline">\(\vec{x}=\vec{0}\)</span>,这个解称作线性齐次方程组的<strong>平凡解</strong>.</p>
<p>而满足<span class="math inline">\(\vec{x}\ne\vec{0}\)</span>的解称作线性齐次方程组的<strong>非平凡解</strong>.</p>
<p>根据存在与唯一性定理,显然其存在非平凡解的充要条件是该方程至少有一个自由变量.</p>
<p>考虑自由变量的取值任意,而且基本变量一定是由若干个自由变量乘以定值之和得到的.</p>
<p>我们把这些定值看作向量,把自由向量看作权重,我们发现:齐次线性方程组的解集总可以表示为<span class="math inline">\(Span\{\vec{v_1},\vec{v_2},...,\vec{v_{p}}\}\)</span>,当然,如果该方程组仅有平凡解,那表示为<span class="math inline">\(Span\{\vec{0}\}\)</span>.</p>
<p>把解表示为<span class="math inline">\(Span\{\vec{v_1},\vec{v_2},...,\vec{v_{p}}\}\)</span>中元素的形式,称之为<strong>解的参数向量形式</strong>.</p>
<p>对于方程<span class="math inline">\(A\vec{x}=\vec{b}\)</span>,它的解一定可以写成<span class="math inline">\(\vec{x}=\vec{p}+\vec{x&#39;}\)</span>的形式,其中<span class="math inline">\(\vec{x&#39;}\)</span>是方程<span class="math inline">\(A\vec{x}=\vec{0}\)</span>的一组解,<span class="math inline">\(\vec{p}\)</span>是方程<span class="math inline">\(A\vec{x}=\vec{b}\)</span>的一组特解.</p>
<p>对于该定理的几何意义,我们考虑<span class="math inline">\(\vec{x}\in
\mathbb{R}^2\)</span>中,即<span class="math inline">\(\vec{x}=\vec{p}+t\vec{u}\)</span>,如果我们把它看为向量加法的形式,它的解集应该是在一条直线上的任意向量,这条直线即<span class="math inline">\(\vec{u}\)</span>所在直线沿向量<span class="math inline">\(\vec{p}\)</span>方向平移后的直线.</p>
<h3><span id="线性空间">线性空间</span></h3>
<p>我们可以在一个域<span class="math inline">\(F\)</span>上定义一个<strong>线性空间</strong>(向量空间)<span class="math inline">\(V\)</span>,除了域本身带有的性质(加法的结合律交换律,加法单位元,加法逆元,乘法对加法有分配律)它应当满足以下公理:</p>
<ol type="1">
<li>定义向量加法<span class="math inline">\(V\times V\rightarrow
V\)</span>.向量加法应当有交换律和结合律.</li>
<li>定义标量乘法<span class="math inline">\(F\times V\rightarrow
V\)</span>.标量乘法应当有交换律,结合律以及对向量加法的分配律.</li>
<li>存在加法幺元以及加法逆元.</li>
</ol>
<p>由于<span class="math inline">\(V\)</span>对加法构成群,相应的性质可以从群的性质搬过来.</p>
<p>值得一提的是,其实标量乘法如果定义成<span class="math inline">\(V\times F\rightarrow
V\)</span>后会有相当多的好处,但是由于历史原因一般还是定义左标量乘法.</p>
<p>当然容易验证我们平常用的线性空间<span class="math inline">\(V=F^n\)</span>满足以上性质.</p>
<p>当然容易验证定义在域上的多项式环满足以上性质.</p>
<h4><span id="相关运算">相关运算</span></h4>
<h5><span id="直积">直积</span></h5>
<p>定义<span class="math inline">\(\prod _{i\in I}V_i=(\vec v_i)_{i\in
I},\vec v_i\in
V_i\)</span>为直积,容易发现线性空间的直积也是线性空间.</p>
<h5><span id="直和">直和</span></h5>
<p>我们如果取直积的一个子空间,使得至多只有有限个<span class="math inline">\(i\in I\)</span>使得<span class="math inline">\(\vec v_i\ne 0\)</span>,则称这是一个直和.</p>
<h5><span id="叉乘">叉乘</span></h5>
<p>对<span class="math inline">\(\mathbb{R}^3\)</span>,定义新的向量运算:向量积(叉乘)<span class="math inline">\(\vec a \times \vec b\)</span>,
其运算结果仍为向量,设为<span class="math inline">\(\vec
c\)</span>,它的模定义为<span class="math inline">\(\vec a\times\vec
b=|\vec a| |\vec b|\sin\theta\)</span>,其中<span class="math inline">\(\theta\)</span>为向量$a ,b <span class="math inline">\(的夹角,\)</span>|c|<span class="math inline">\(为以\)</span>a,b<span class="math inline">\(为两边的平行四边形的面积,\)</span>c <span class="math inline">\(的方向定义为与\)</span>a ,b<span class="math inline">\(所形成的平面垂直,且\)</span>a,b,c <span class="math inline">\(构成右手螺旋定则(即现将四指指向\)</span>a<span class="math inline">\(方向再将四指弯曲指向\)</span>b<span class="math inline">\(的方向,则此时大拇指的方向为\)</span>c$的方向),</p>
<p>向量叉乘满足以下性质:</p>
<ol type="1">
<li>$ab=-ba $.</li>
<li><span class="math inline">\(\vec a\times \vec a =\vec
0\)</span></li>
<li><span class="math inline">\(\vec a\times(\vec b+\vec c)=\vec
a\times\vec b +\vec a \times\vec c\)</span>.</li>
</ol>
<p>在三维坐标系中,设: <span class="math display">\[
\vec a =a_1\vec i+b_1\vec j+c_1\vec k\\
\vec b =a_2\vec i+b_2\vec j+c_2\vec k
\]</span> 由叉乘定义,得到:<span class="math inline">\(\vec
c=(a_yb_z-a_zb_y)\vec i+(a_zb_x-a_xb_z)\vec j+(a_xb_y-a_yb_x)\vec
k\)</span>.也就是: <span class="math display">\[
\vec c=\vec a\times \vec b = \left|\begin{matrix}\vec i&amp;\vec
j&amp;\vec
k\\a_x&amp;a_y&amp;a_z\\b_x&amp;b_y&amp;b_z\end{matrix}\right|
\]</span>
对于任意一个面的法向量，我们总可以选取该面上的两个不共线向量来直接叉乘出来.</p>
<h4><span id="线性无关与线性相关">线性无关与线性相关</span></h4>
<p>称<span class="math inline">\(V\)</span>中一组向量<span class="math inline">\(\{\vec{v_1},\vec{v_2},...,\vec{v_p}\}\)</span>是<strong>线性无关</strong>的,当且仅当向量方程<span class="math inline">\(x_1\vec{v_1}+x_2\vec{v_2}+...+x_p\vec{v_p}=\vec{0}\)</span>仅有平凡解.</p>
<p>反之,称为<strong>线性相关</strong>,即存在一组不全为0的数<span class="math inline">\(c_1,c_2,...,c_p\)</span>使<span class="math inline">\(c_1\vec{v_1}+c_2\vec{v_2}+...+c_p\vec{v_p}=\vec{0}\)</span>,这个式子也被称为<span class="math inline">\(\{\vec{v_1},\vec{v_2},...,\vec{v_p}\}\)</span>之间的<strong>线性相关关系</strong>.</p>
<p>容易发现,两个或更多向量的集合<span class="math inline">\(S=\{\vec{v_1},\vec{v_2},...,\vec{v_p}\}\)</span>线性相关,当且仅当其中至少有一个向量是其它向量的线性组合.</p>
<h4><span id="子空间">子空间</span></h4>
<p>我们定义<span class="math inline">\(V\)</span>的一个<strong>子空间</strong>是它的一个非空子集<span class="math inline">\(V_0\)</span>,具有以下三个性质:</p>
<ol type="1">
<li><span class="math inline">\(\vec{0}\in V_0\)</span>.</li>
<li><span class="math inline">\(\forall \vec u,\vec v\in V_0,\vec u+\vec
v\in V_0\)</span>.</li>
<li><span class="math inline">\(\forall \vec u\in V_0,c\in F,c\vec u\in
V_0\)</span>.</li>
</ol>
<p>线性空间的两个平凡子空间当然是零空间和它本身.</p>
<p>容易验证两个子空间的交仍然是子空间.</p>
<h5><span id="向量的线性组合">向量的线性组合</span></h5>
<p>给定<span class="math inline">\(V\)</span>中向量<span class="math inline">\(\vec v_1,\vec v_2,...,\vec v_p\)</span>和标量<span class="math inline">\(c_1,c_2,...,c_p\in F\)</span>.</p>
<p>我们称向量<span class="math inline">\(\overrightarrow{y}=c_1\overrightarrow{v_1}+c_2\overrightarrow{v_2}+...+c_p\overrightarrow{v_p}\)</span>为向量<span class="math inline">\(\overrightarrow{v_1},\overrightarrow{v_2},...,\overrightarrow{v_p}\)</span>以<span class="math inline">\(c_1,c_2,...,c_p\)</span>为权的<strong>线性组合</strong>.</p>
<p>对于向量<span class="math inline">\(\overrightarrow{v_1},\overrightarrow{v_2},...,\overrightarrow{v_p}\)</span>,我们称它们的所有线性组合所成的集合为<span class="math inline">\(Span\{\overrightarrow{v_1},\overrightarrow{v_2},...,\overrightarrow{v_p}\}\)</span>,也称为由<span class="math inline">\(\overrightarrow{v_1},\overrightarrow{v_2},...,\overrightarrow{v_p}\)</span>所<strong>生成</strong>的<span class="math inline">\(V\)</span>的子集,有时也记作<span class="math inline">\(\langle \vec v_1,\vec v_2,\cdots ,\vec
v_p\rangle\)</span>.</p>
<p>不难发现,<span class="math inline">\(Span\)</span>集合是<span class="math inline">\(V\)</span>的一个子空间,而且容易证明其是包含<span class="math inline">\(\{\vec v_1,\vec v_2,\cdots ,\vec
v_p\}\)</span>的最小的子空间,所以我们又称其为由<span class="math inline">\(\overrightarrow{v_1},\overrightarrow{v_2},...,\overrightarrow{v_p}\)</span>所<strong>生成</strong>的子空间.</p>
<p>可以考虑一些特殊线性空间上<span class="math inline">\(Span\)</span>的几何意义:</p>
<p>对于<span class="math inline">\(\mathbb{R}^2\)</span>,当<span class="math inline">\(\vec{v_1}\)</span>和<span class="math inline">\(\vec{v_2}\)</span>不在一条直线上的时候,<span class="math inline">\(Span\{\vec{v_1},\vec{v_2}\}\)</span>显然对应了整个平面.</p>
<p>对于<span class="math inline">\(\mathbb{R}^3\)</span>,当<span class="math inline">\(\vec{v_1}\)</span>和<span class="math inline">\(\vec{v_2}\)</span>不在一条直线上的时候,<span class="math inline">\(Span\{\vec{v_1},\vec{v_2}\}\)</span>显然对应了三维空间中的一个过<span class="math inline">\(\vec{v_1},\vec{v_2}\)</span>这两条直线的平面.</p>
<p>要判断<span class="math inline">\(\overrightarrow{b}\)</span>是否在<span class="math inline">\(Span\{\overrightarrow{v_1},\overrightarrow{v_2},...,\overrightarrow{v_p}\}\)</span>中，即判断向量方程<span class="math inline">\(x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+...+x_p\overrightarrow{v_p}=\overrightarrow{b}\)</span>是否有解.</p>
<h5><span id="线性映射">线性映射</span></h5>
<p>映射<span class="math inline">\(T:V\rightarrow
W\)</span>是线性的,当且仅当它满足以下两个条件:</p>
<ol type="1">
<li>对<span class="math inline">\(T\)</span>的定义域中一切的向量<span class="math inline">\(\vec{u},\vec{v}\)</span>,满足<span class="math inline">\(T(\vec{u}+\vec v)=T(\vec u)+T(\vec
v)\)</span>.</li>
<li>对<span class="math inline">\(T\)</span>的定义域中一切的向量<span class="math inline">\(\vec u\)</span>和数<span class="math inline">\(c\)</span>,满足<span class="math inline">\(T(c\vec
u)=cT(\vec u)\)</span>.</li>
</ol>
<p>线性映射有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(T(\vec 0)=\vec 0\)</span>.</li>
<li>(叠加原理):<span class="math inline">\(T(c_1\vec v_1+c_2\vec
v_2+...+c_p\vec v_p)=c_1T(\vec v_1)+c_2T(\vec v_2)+...+c_pT(\vec
v_p)\)</span>.</li>
</ol>
<p>称线性映射<span class="math inline">\(T:V\rightarrow
W\)</span>是<strong>可逆的</strong>或者<strong>同构的</strong>,当且仅当存在<span class="math inline">\(T^{-1}:W\rightarrow V\)</span>.</p>
<p>我们可以验证<span class="math inline">\(T^{-1}\)</span>也是线性映射,原因在于此时<span class="math inline">\(T\)</span>是双射: <span class="math display">\[
T^{-1}(\vec w+\vec w&#39;)=T^{-1}(\vec w)+T^{-1}(\vec w&#39;)\\
\Leftrightarrow \\
T(T^{-1}(\vec w+\vec w&#39;))=T(T^{-1}(\vec w)+T^{-1}(\vec w&#39;))
\]</span> 而且: <span class="math display">\[
T^{-1}(t\vec w)=tT^{-1}(\vec w)\\
\Leftrightarrow\\
T(T^{-1}(t\vec w))=T(tT^{-1}(\vec w))
\]</span></p>
<p>我们记<span class="math inline">\(\text{Hom}(V,W)\)</span>为所有的<span class="math inline">\(V\rightarrow W\)</span>,并且其中的<span class="math inline">\(V,W\)</span>都是定义在<span class="math inline">\(F\)</span>上的线性空间的线性映射组成的集合.容易验证<span class="math inline">\(\text{Hom}(V,W)\)</span>构成<span class="math inline">\(F\)</span>上的线性空间.特别地,定义<span class="math inline">\(\text{End}(V)=\text
{Hom}(V,V)\)</span>,容易发现<span class="math inline">\(\text{End}(V)\)</span>是对复合和加法操作一个环.</p>
<p>特别地,定义矩阵映射<span class="math inline">\(T:F^n\rightarrow
F^m\)</span>为<span class="math inline">\(T(\vec x)=A\vec
x\)</span>,其中<span class="math inline">\(A\)</span>是一个<span class="math inline">\(m\times
n\)</span>的矩阵.矩阵映射显然是线性映射.</p>
<h5><span id="基和维数">基和维数</span></h5>
<p><span class="math inline">\(V\)</span>中子空间<span class="math inline">\(H\)</span>的一组<strong>基</strong>是<span class="math inline">\(H\)</span>中一个线性无关集,它生成<span class="math inline">\(H\)</span>.</p>
<p>事实上,以下命题等价:</p>
<ol type="1">
<li><span class="math inline">\(S\)</span>是<span class="math inline">\(V\)</span>的一组基.</li>
<li><span class="math inline">\(S\)</span>是极小的能生成<span class="math inline">\(V\)</span>的集合(不存在其的一个真子集能生成<span class="math inline">\(V\)</span>).</li>
<li><span class="math inline">\(S\)</span>是极大的<span class="math inline">\(V\)</span>中的线性无关集(不存在其的一个真张集线性无关).</li>
</ol>
<p>证明上列命题等价是容易的.</p>
<p>对于<span class="math inline">\(F^n\)</span>来说,其的基有更好的性质,我们称<span class="math inline">\(\{\vec e_1,...,\vec e_n\},\vec
e_i=\{0,0,\cdots,0,1,0,\cdots\}\)</span>为<span class="math inline">\(F^n\)</span>的<strong>标准基</strong>.</p>
<p>对于<span class="math inline">\(n\times
m\)</span>的矩阵组成的线性空间,其当然也有一组标准基<span class="math inline">\(\{\vec e_{i,j}\}\)</span>.</p>
<p>有如下结论:</p>
<ol type="1">
<li>(承认选择公理)对于任何一个线性无关的子集<span class="math inline">\(S\)</span>,存在一个基<span class="math inline">\(\mathcal B\)</span>使得<span class="math inline">\(S\subseteq \mathcal B\)</span>.特别地,取<span class="math inline">\(S=\empty\)</span>可以说明任何一个线性空间总是有基.</li>
<li>(有限生成的情况)如果一个线性空间的子集<span class="math inline">\(S\)</span>满足<span class="math inline">\(|S|&gt;|\mathcal B|\)</span>,其中<span class="math inline">\(\mathcal{B}\)</span>是一组有限大小的基,那么<span class="math inline">\(S\)</span>线性相关.</li>
<li>如果一个线性空间有两组基<span class="math inline">\(\mathcal{B_1},\mathcal{B_2}\)</span>,那么<span class="math inline">\(|\mathcal{B_1}|=|\mathcal{B_2}|\)</span>.</li>
</ol>
<p>现在考虑(1)的证明,拿出所有的线性无关的<span class="math inline">\(T\supseteq
S\)</span>并组成一个集合,用包含关系作为偏序关系,如果能证明其满足Zorn引理的条件,那当然可以取出一个极大的线性无关集合,这当然是一组基.为此我们取出一条链并且将上面的所有集合并起来得到一个集合<span class="math inline">\(T&#39;\)</span>.此时就可以看出我们之前(几乎一笔略过的)要求从基扩张的时候只需要有限个元素的作用,它可以立刻断言<span class="math inline">\(T&#39;\)</span>是一个线性无关集合.</p>
<p>(2)的证明是容易的,不妨设<span class="math inline">\(n=|\mathcal
B|,m=|S|\)</span>,由于<span class="math inline">\(m&gt;n\)</span>,这当然是一个<span class="math inline">\(m\)</span>个变量的大小为<span class="math inline">\(n\)</span>的方程组,当然存在不全为<span class="math inline">\(0\)</span>的解.</p>
<p>(3)的定义较为复杂,略过.</p>
<p>在上述定理的基础上,我们可以定义非零向量空间<span class="math inline">\(V\)</span>的<strong>维数</strong>,记作<span class="math inline">\(\dim V=|\mathcal{B}|\)</span>,零子空间<span class="math inline">\(\{\vec 0\}\)</span>的维数定义为<span class="math inline">\(0\)</span>.</p>
<p>一般而言,我们大部分情况下都只讨论有限生成的情况.</p>
<p>有限生成的情况,我们还有以下若干条定理:</p>
<ol start="4" type="1">
<li>(基定理)设<span class="math inline">\(H\)</span>是<span class="math inline">\(V\)</span>的<span class="math inline">\(p\)</span>维子空间,<span class="math inline">\(H\)</span>中任何恰好由<span class="math inline">\(p\)</span>个元素组成的线性无关集构成<span class="math inline">\(H\)</span>的一个基.</li>
</ol>
<p>这当然是自然的,根据上面的推导,这个线性无关集合就是极大的线性无关集合.</p>
<ol start="5" type="1">
<li>如果线性空间的子空间<span class="math inline">\(V_0\subseteq
V\)</span>,那么<span class="math inline">\(\dim V_0\leq \dim
V\)</span>.特别地,<span class="math inline">\(V_0=V\Leftrightarrow \dim
V_0=\dim V\)</span>.</li>
</ol>
<p>只需要继续在<span class="math inline">\(V_0\)</span>里面取基就可以了.</p>
<ol start="6" type="1">
<li><span class="math inline">\(V\)</span>定义在域<span class="math inline">\(F\)</span>上,如果<span class="math inline">\(\dim
V=n\)</span>,那么<span class="math inline">\(V\cong F^n\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(F^n\)</span>的一组标准基<span class="math inline">\(\vec {e_1},\cdots \vec
e_n\)</span>,然后我们取出<span class="math inline">\(V\)</span>的一组有序基<span class="math inline">\(B=\{\vec v_1,\cdots ,\vec
v_n\}\)</span>,然后把<span class="math inline">\(T:F^n\rightarrow  V,\sum k_i\vec e_i\mapsto \sum
k_i\vec
v_i\)</span>.接下要当然要验证良定义和双射,通过基的定义是显然的.</p>
<p>这可以引出所谓坐标表示,即:设<span class="math inline">\(\mathcal{B}=\{\vec b_1,...,\vec
b_n\}\)</span>是<span class="math inline">\(V\)</span>的一个基,则<span class="math inline">\(\forall \vec x\in V\)</span>,<span class="math inline">\(\exists\)</span>唯一的一组<span class="math inline">\(\{c_1,...,c_n\}\)</span>满足<span class="math inline">\(\vec x=c_1\vec b_1+...+c_n\vec
b_n\)</span>.我们称<span class="math inline">\(\begin{bmatrix}c_1\\\vdots\\c_n\end{bmatrix}\)</span>是<span class="math inline">\(\vec x\)</span>的<span class="math inline">\(\mathcal B-\)</span>坐标向量,记作<span class="math inline">\([x]_{\mathcal B}\)</span>,映射<span class="math inline">\(x\mapsto [x]_{\mathcal B}\)</span>称为由<span class="math inline">\(\mathcal
B\)</span>确定的<strong>坐标映射</strong>.</p>
<p>事实上,如果我们记<span class="math inline">\(P_{\mathcal{B}}=\begin{bmatrix}\vec b_1&amp;\vec
b_2&amp;\cdots &amp;\vec b_n\end{bmatrix}\)</span>,则我们有<span class="math inline">\(\vec
x=P_{\mathcal{B}}[x]_{\mathcal{B}}\)</span>.我们称<span class="math inline">\(P_{\mathcal{B}}\)</span>为<span class="math inline">\(\mathcal{B}\)</span>的坐标变换矩阵.</p>
<ol start="7" type="1">
<li>线性映射由它在基上的作用完全确定.</li>
</ol>
<p>原因是考虑<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(B=\{\vec v_1,\cdots,\vec v_n\}\)</span>,那么<span class="math inline">\(T(\sum k_i\vec v_i)=\sum k_iT(\vec
v_i)\)</span>.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\text{Hom}(V,W)\cong
W^n\)</span>,其中<span class="math inline">\(\dim V=n\)</span>.</li>
</ol>
<p>由(7),我们知道如果选定了<span class="math inline">\(C=\{\vec
w_1,\cdots \vec w_n\}\)</span>,则只需要考虑在基上的具体变换即可.</p>
<ol start="9" type="1">
<li>(线性映射同构于矩阵映射)如果<span class="math inline">\(V,W\)</span>都是定义在<span class="math inline">\(F\)</span>上的线性空间,<span class="math inline">\(\dim V=n,\dim W=m\)</span>,那么<span class="math inline">\(\text {Hom}(V,W)\cong W^n\cong F^{m\times
n}\)</span>.更一般地,如果<span class="math inline">\(V\)</span>的基的指标集是<span class="math inline">\(J\)</span>,<span class="math inline">\(W\)</span>的基的指标集是<span class="math inline">\(I\)</span>.那么<span class="math inline">\(\text{Hom}(V,W)\cong F^{I\times
J}\)</span>.另外地,<span class="math inline">\(\dim
\text{Hom}(V,W)=mn\)</span>.特殊地,<span class="math inline">\(\text{End}(V)\cong F^{n\times n}\)</span>.</li>
</ol>
<p>由(6)(8)显然.</p>
<p>现在我们就可以拿出矩阵了,我们在<span class="math inline">\(F\)</span>上定义<span class="math inline">\(m\times n\)</span>的矩阵<span class="math inline">\(M\)</span>,于是<span class="math inline">\(\mathcal M=\text{Hom}(V,W)\cong M_{m\times
n}\)</span>.</p>
<p>简单来说,如果<span class="math inline">\(B=\{\vec v_1,\cdots \vec
v_n\}\)</span>是<span class="math inline">\(V\)</span>的一组基,<span class="math inline">\(C=\{\vec w_1,\cdots \vec w_m\}\)</span>是<span class="math inline">\(W\)</span>的一组基,我们事实上是把<span class="math inline">\(\vec v_j\mapsto \sum a_{i,j}\vec w_i\)</span>.</p>
<ol start="10" type="1">
<li>线性映射的复合同构于矩阵乘法.</li>
</ol>
<p>只需操演定义即可发现.</p>
<ol start="11" type="1">
<li>如果<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域,那么<span class="math inline">\(E\)</span>是在<span class="math inline">\(F\)</span>上的向量空间.同样,如果<span class="math inline">\(V\)</span>是<span class="math inline">\(E\)</span>的向量空间,那么<span class="math inline">\(V\)</span>是<span class="math inline">\(F\)</span>的向量空间.</li>
</ol>
<p>定义的简单操演.</p>
<ol start="12" type="1">
<li>如果<span class="math inline">\(V\)</span>是<span class="math inline">\(E\)</span>的向量空间,基为<span class="math inline">\(B\)</span>,<span class="math inline">\(E\)</span>是<span class="math inline">\(F\)</span>的向量空间,基为<span class="math inline">\(C\)</span>.那么<span class="math inline">\(V\)</span>是<span class="math inline">\(F\)</span>的向量空间,而且基是<span class="math inline">\(CB\)</span>.作为其的一个推论,如果我们定义<span class="math inline">\([V:E]=\dim_E V\)</span>,即在<span class="math inline">\(E\)</span>上的<span class="math inline">\(V\)</span>的维数.我们应当能见到<span class="math inline">\([V:F]=[V:E][E:F]\)</span>.</li>
</ol>
<p>定义的简单操演.可以将这里理解为<span class="math inline">\([V:F]=\log_F V\)</span>这个样子.</p>
<h4><span id="可逆矩阵">可逆矩阵</span></h4>
<p>称一个<span class="math inline">\(n\times n\)</span>的矩阵<span class="math inline">\(A\)</span>是<strong>可逆的</strong>,当且仅当<span class="math inline">\(\exist C_{n\times n}\)</span>满足<span class="math inline">\(CA=AC=I_{n}\)</span>,我们记<span class="math inline">\(C=A^{-1}\)</span>.其实也就是<span class="math inline">\(F_{n\times
n}\)</span>这个环上的可逆元.这当然意味着其对应的线性映射是可逆的,也就是其代表的线性映射是同构.</p>
<p>不可逆矩阵又被称为<strong>奇异矩阵</strong>.</p>
<p>事实上<span class="math inline">\(m\times n\)</span>的矩阵<span class="math inline">\(A\)</span>在<span class="math inline">\(m\ne
n\)</span>的时候当然是不可逆的,因为其代表的线性映射不可能是同构(不然两边的<span class="math inline">\(\dim\)</span>应当相等,应当有<span class="math inline">\(m=n\)</span>).</p>
<p>可逆矩阵有以下简单性质:</p>
<ol type="1">
<li>若<span class="math inline">\(A\)</span>是可逆方阵,则<span class="math inline">\(A^{-1}\)</span>也可逆且<span class="math inline">\((A^{-1})^{-1}=A\)</span>.</li>
<li>若<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是可逆方阵,则<span class="math inline">\(AB\)</span>也可逆且<span class="math inline">\((AB)^{-1}=B^{-1}A^{-1}\)</span>.</li>
</ol>
<h5><span id="初等矩阵">初等矩阵</span></h5>
<p>将单位矩阵经过一次初等行变换得到的矩阵称作<strong>初等矩阵</strong>.</p>
<p>对任意<span class="math inline">\(m\times
n\)</span>矩阵进行初等行变换一定等价于将其左乘一个初等矩阵,原因在于只需要对单位矩阵验证以下性质即可.</p>
<ol type="1">
<li>倍加变换:<span class="math inline">\(R_i+kR_j\rightarrow R_i,i\ne
j\)</span>:</li>
</ol>
<p><span class="math display">\[
E_{x,y}=
\begin{cases}
k &amp;x=i,y=j\\
1 &amp;x=y\\
0 &amp;Otherwise
\end{cases}\\
\]</span></p>
<ol start="2" type="1">
<li>对换变换:<span class="math inline">\(R_i\leftrightarrow
R_j\)</span>:</li>
</ol>
<p><span class="math display">\[
E_{x,y}=
\begin{cases}
1 &amp;x=i,y=j\\
1 &amp;x=j,y=i\\
1 &amp;x=y,x\ne i,x\ne j\\
0 &amp;Otherwise
\end{cases}\\
\]</span></p>
<ol start="3" type="1">
<li>倍乘变换:<span class="math inline">\(kR_i\rightarrow
R_i,k\ne0\)</span>:</li>
</ol>
<p><span class="math display">\[
E_{x,y}=
\begin{cases}
k &amp;x=y,x=i\\
1 &amp;x=y,x\ne i\\
0 &amp;Otherwise
\end{cases}\\
\]</span></p>
<p>考虑如下事实:行变换是可逆的,那么初等矩阵显然是可逆的.</p>
<p>这引出下面的定理:</p>
<p><span class="math inline">\(n\times
n\)</span>矩阵是可逆的,当且仅当<span class="math inline">\(A\)</span>行等价于<span class="math inline">\(I_n\)</span>,也即<span class="math inline">\(A\)</span>可以通过一系列初等行变换变换为<span class="math inline">\(I_n\)</span>.</p>
<p>如果<span class="math inline">\(A\)</span>可以通过一系列初等行变换变换为<span class="math inline">\(I_n\)</span>,根据初等矩阵的知识,这等价于:</p>
<p><span class="math inline">\(E_1E_2...E_pA=I_n\)</span>,由于初等矩阵显然可逆,我们有<span class="math inline">\(A=(E_1E_{2}...E_p)^{-1}\)</span>,有<span class="math inline">\(A^{-1}=(E_1E_2...E_p)\)</span>.</p>
<p>如果<span class="math inline">\(A\)</span>是可逆矩阵,显然<span class="math inline">\(A\)</span>的简化阶梯形是<span class="math inline">\(I\)</span>,也即二者行等价.</p>
<p>由于初等矩阵转置后仍然是初等矩阵,所以<span class="math inline">\(A\)</span>可逆等价于<span class="math inline">\(A^T\)</span>可逆.此时发现列变换等价于右乘初等矩阵.此外<span class="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span>.</p>
<h5><span id="求解逆矩阵">求解逆矩阵</span></h5>
<p>若<span class="math inline">\(A\)</span>可逆,我们考虑将<span class="math inline">\(A\)</span>和<span class="math inline">\(I\)</span>放在同一个<span class="math inline">\(n\times 2n\)</span>的矩阵中,记作<span class="math inline">\(\begin{bmatrix}A &amp;I
\end{bmatrix}\)</span>,它显然行等价于<span class="math inline">\(\begin{bmatrix}I&amp;A^{-1}\end{bmatrix}\)</span>.</p>
<p>另外,考虑将<span class="math inline">\(I\)</span>写作<span class="math inline">\(\begin{bmatrix}\vec
{e_1}&amp;\vec{e_2}&amp;...&amp;\vec{e_n}\end{bmatrix}\)</span>的形式,则我们发现上述过程等价于求若干个形如<span class="math inline">\(A\vec x_i=\vec e_i\)</span>的方程的解,并且<span class="math inline">\(A^{-1}=\begin{bmatrix}\vec{x_1}&amp;\vec{x_2}&amp;...&amp;\vec{x_n}\end{bmatrix}\)</span>.</p>
<h6><span id="example1lu分解">Example1(LU分解)</span></h6>
<p>考虑上面对一个矩阵做的过程,考虑把一个矩阵消成上三角的.在此过程中如果没有发生行交换操作,那所做的操作就是一列下三角的操作.因此可以把一个矩阵分解为<span class="math inline">\(A=LU\)</span>.当然这里有一些条件才能进行,回头我们再讨论此.</p>
<h4><span id="核与像与秩">核与像与秩</span></h4>
<p>选取<span class="math inline">\(T:V\rightarrow
W\)</span>为线性映射,定义<span class="math inline">\(\ker
T=T^{-1}(0)\)</span>,<span class="math inline">\(\text {im}\
T=T(V)\)</span>.</p>
<p>容易证明<span class="math inline">\(\ker T\)</span>是<span class="math inline">\(V\)</span>的线性子空间,<span class="math inline">\(\text {im}\ T\)</span>是<span class="math inline">\(W\)</span>的线性子空间.</p>
<p>对于任意<span class="math inline">\(w\in \text{im}
T\)</span>,选取任意一个特解<span class="math inline">\(v_0\in
V,T(v_0)=w\)</span>,那么容易看出<span class="math inline">\(T^{-1}(w)=v_0+\ker T\)</span>.于是<span class="math inline">\(T\)</span>是单射当且仅当<span class="math inline">\(\ker T=\{0\}\)</span>.</p>
<p>当<span class="math inline">\(\dim V\)</span>有限的时候,我们有<span class="math inline">\(\dim V=\dim \ker T+\dim \text{im}\ T\)</span>.</p>
<p>原因是可以选取<span class="math inline">\(\text{im}\
T\)</span>的一组基<span class="math inline">\(\{\vec w_1,\cdots \vec
w_r\}\)</span>,找到其原像<span class="math inline">\(B=\{\vec
v_1,\cdots,\vec v_r\}\)</span>,再取<span class="math inline">\(\ker
T\)</span>的一组基<span class="math inline">\(C=\{\vec u_1,\cdots \vec
u_s\}\)</span>.</p>
<p>先来证明<span class="math inline">\(B\cup
C\)</span>是线性无关的.也就是考察<span class="math inline">\(\sum
a_j\vec v_j+\sum b_i\vec u_i=0\)</span>.此时两边取像,当然有<span class="math inline">\(\sum a_j\vec w_j+0=0\)</span>,于是所有的<span class="math inline">\(a_j=0\)</span>.此时考虑<span class="math inline">\(\ker T\)</span>是<span class="math inline">\(V\)</span>的子空间,所以当<span class="math inline">\(0+\sum b_i\vec
u_i=0\)</span>的时候也可以推出所有的<span class="math inline">\(b_i=0\)</span>.</p>
<p>再来证明它确实可以生成<span class="math inline">\(V\)</span>.考虑<span class="math inline">\(\forall
\vec v\in V\)</span>,首先<span class="math inline">\(T(\vec v)=\sum
a_j\vec w_j\)</span>,这当然是可以找到的.那么<span class="math inline">\(T(\vec v-\sum a_j\vec v_j)=0\)</span>,于是<span class="math inline">\(\vec v-\sum a_j\vec v_j\in \ker
T\)</span>,于是<span class="math inline">\(\vec v-\sum a_j\vec v_j=\sum
b_i\vec u_i\)</span>,这就证毕了.利用下面直和分解的原理也可以写作<span class="math inline">\(\ker T\oplus \text{im} T\cong V\)</span>.</p>
<p>而我们知道<span class="math inline">\(T\)</span>的单性等价于<span class="math inline">\(\dim\ker T=0\)</span>,满性等价于<span class="math inline">\(\dim \text{im}\ T=\dim W=\dim V\)</span>,于是<span class="math inline">\(\dim W=\dim V\)</span>时单性等价于满性.</p>
<p>这样的话我们定义一个线性映射的秩<span class="math inline">\(\text{rk}\ T=\dim (\text{im}\ T)\)</span>.</p>
<p>我们来看一个特殊情况<span class="math inline">\(T:F^n\rightarrow
F^m\)</span>.那此时我们就可以定义这个映射所代表的矩阵<span class="math inline">\(M\)</span>的秩.我们注意到<span class="math inline">\(\text{im}\ T=\text{span}\{M\vec e_1,\cdots M\vec
e_{n}\}=\text{span}\{\vec m_1,\cdots,\vec m_n\}\)</span>.也就是<span class="math inline">\(\text{rk}\
M\)</span>其实就是列向量生成的空间的维度.特别地,如果<span class="math inline">\(\text{rk}\
M=\min(n,m)\)</span>,那么我们称矩阵是满秩的.也就等于其消成简化阶梯型矩阵后的主元数量.那此时<span class="math inline">\(\dim\ker T=n-\text{rk}\ M\)</span>.</p>
<p>容易从上面看出<span class="math inline">\(\text{rk}(ST)\leq
\min(\text{rk}S,\text{rk}T)\)</span>.且当<span class="math inline">\(T\)</span>是满的时候<span class="math inline">\(\text{rk}(ST)=\text{rk}(S)\)</span>,当<span class="math inline">\(S\)</span>是单的时候<span class="math inline">\(\text{rk}(ST)=\text{rk}(T)\)</span>.</p>
<h5><span id="sylvester秩不等式">Sylvester秩不等式</span></h5>
<p>考虑<span class="math inline">\(T:U\to V,S:V\to W\)</span>,则<span class="math inline">\(\text{rk}(ST)\geq \text{rk}\ S+\text{rk}\ T-\dim
V=\text{rk}\ T-(\dim V-\text{rk}\ S)\)</span>.可以认为后者<span class="math inline">\(\dim V-\text{rk}\ S\)</span>实际上是<span class="math inline">\(S\)</span>这个映射所带来的维度损失(<span class="math inline">\(\ker S\)</span>),而这个损失有可能叠到<span class="math inline">\(T\)</span>上也可能不叠到<span class="math inline">\(T\)</span>上.</p>
<p>对于其证明,考虑<span class="math inline">\(\text{rk}(ST)\)</span>实际上应当是<span class="math inline">\(S:\text{im}\ T\to W\)</span>的秩,这给出<span class="math inline">\(\text {rk}(ST)=\text{rk}\ T-\dim(\text{im}\ T\cap
\ker S)\)</span>.</p>
<p>而<span class="math inline">\(\dim (\text{im}\ T\cap \ker S)\leq
\dim\ker S=\dim V-\text{rk}\ S\)</span>.于是得证.</p>
<p>其一个特例是<span class="math inline">\(\text{rk}(ST)=0\)</span>时给出<span class="math inline">\(\dim V\geq \text{rk}\ S+\text{rk}\ T\)</span>.</p>
<p>在上述式子左右两边进行简单变形:</p>
<p><span class="math display">\[
\text{rk}(ST)\geq \text{rk}\ T-\dim \ker S\\
\dim U-\text{rk}(T)\geq \dim U-\text{rk}\ (ST)-\dim \ker S\\
\ker T+\ker S\geq \ker (ST)
\]</span></p>
<p>换言之就是线性映射的<span class="math inline">\(\ker\)</span>扩张的过程中可能会出现包含的情况,所以扩不到简单相加的情形.</p>
<h5><span id="frobenius秩不等式">Frobenius秩不等式</span></h5>
<p>有<span class="math inline">\(\text{rk}(ABC)\geq
\text{rk}(AB)+\text{rk}(BC)-\text{rk}B\)</span>.</p>
<p>不妨设<span class="math inline">\(B:U\to V\)</span>,考虑: <span class="math display">\[
\text{rk}(ABC)=\text{rk}(BC)-\dim(\text{im}(BC)\cap\ker A)\\
\geq\text{rk}(BC)-\dim(\text{im}(B)\cap\ker A)\\
\]</span> 而我们事实上有<span class="math inline">\(\text{rk}(AB)=\text{rk}\ B-\dim(\text {im}B\cap
\ker A)\)</span>,于是上述式子得证.</p>
<p>仍然对上式进行变形:</p>
<p><span class="math display">\[
\ker(AB)+\ker(BC)\geq \ker(ABC)+\ker(B)
\]</span></p>
<p>这个式子还不能简单从Sylvester不等式推导,但可以见到这仍然是关于<span class="math inline">\(\ker\)</span>扩张上的意义.</p>
<h4><span id="对偶空间">对偶空间</span></h4>
<p>定义<strong>对偶空间</strong><span class="math inline">\(V^*=\text{Hom}(V,F)\)</span>(也可以记作<span class="math inline">\(\check V\)</span>),其中<span class="math inline">\(V\)</span>是定义在<span class="math inline">\(F\)</span>上的向量空间.对偶空间当然是线性空间.</p>
<p>当线性空间是有限维的时候.我们考虑以下事实:</p>
<p>取<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(\cal B=\{\vec v_1,\cdots ,\vec
v_n\}\)</span>,我们考虑取<span class="math inline">\(\check v_i\in
V^\vee\)</span>使得<span class="math inline">\(\check v_i(\vec
w)=a_i\)</span>,当<span class="math inline">\(\vec w=\sum_j a_j\vec
v_j\)</span>.容易验证它们构成一组<strong>对偶基</strong>,这告诉我们<span class="math inline">\(\dim V=\dim V^\vee\)</span>.</p>
<p>特别地,当<span class="math inline">\(V=F^n\)</span>的时候,容易验证如果取标准基<span class="math inline">\(\cal
B\)</span>,那么得到的对偶基实际上等价于标准基的转置(也就是列向量改为行向量).这可能会给我们带来错觉,认为对偶空间无非是行向量组成的空间,但如此理解有所偏差.既然是向量空间,就应当理解为列向量,否则线性变换理解为矩阵乘法就会收到阻碍,只是其作用效果等价于先转置为行向量再作矩阵乘法.</p>
<p>如果<span class="math inline">\(T:V\to
W\)</span>是线性映射,那我们可以定义其<strong>转置映射</strong><span class="math inline">\(^tT:W^\vee\to V^\vee,\lambda\mapsto \lambda
T\)</span>.容易验证转置映射仍然是线性映射.另外,如果<span class="math inline">\(S,T\)</span>均是线性映射,那么<span class="math inline">\(^t{(ST)}=\
^t{T}^t{S}\)</span>.简单画一下交换图表:</p>
<p>$$ $$</p>
<p>我们接下来说明转置映射对应的矩阵是原映射的矩阵的转置.</p>
<p>不妨设<span class="math inline">\(\dim V=n,\dim
W=m\)</span>,原矩阵为<span class="math inline">\(A_{m\times
n}\)</span>.</p>
<p>接下来看它们分别对对应基的操作:</p>
<p>不妨设<span class="math inline">\(T(\vec v_j)=\sum a_{i,j}\vec
w_i\)</span>,则<span class="math inline">\(^tT(\check
w_i)\)</span>代表一个映射:</p>
<p><span class="math display">\[
\vec v_k\mapsto \check{w_i}T(\vec v_k)\\=\check{w_i}(\sum_h
a_{h,k}w_h)\\=\sum_ha_{h,k}\check
w_i(w_h)\\=a_{i,k}\\=\sum_{j}a_{i,j}\check v_j(\vec v_k)
\]</span></p>
<p>因此<span class="math inline">\(^tT(\check w_i)=\sum_{j}a_{i,j}\check
v_j\)</span>.</p>
<p>如果我们将<span class="math inline">\(\lambda\)</span>看成一个<span class="math inline">\(1\times m\)</span>的矩阵,那<span class="math inline">\(\lambda\to \lambda
T\)</span>不言自明为矩阵乘法.然而正是我们试图总是将空间表示为列向量,因此我们就自然带了一个转置,对于一个<span class="math inline">\(\vec
v\)</span>,我们对它实际上求的是乘法$<sup>t(T)v=(</sup>tT)(^t)v
$的结果,如此一来上述结论便显明了.</p>
<p>我们会在后面谈论矩阵的相抵的部分证明行秩等于列秩这一事实,然而,既然转置实际上表现了对偶空间上的性质,我们理应可以抛开矩阵本身而只从对偶空间的角度理解.换言之,取对偶基是一种非典范的无奈之举,我们会在讨论双线性形式的时候重新讨论于此.</p>
<h4><span id="直和分解与分块矩阵">直和分解与分块矩阵</span></h4>
<p>不妨取映射<span class="math inline">\(\sigma:\bigoplus_{i\in I}V_i\to
V,(v_i)_{i\in I}\mapsto \sum v_i\)</span>,其中<span class="math inline">\(V_i\)</span>都是<span class="math inline">\(V\)</span>的子空间.容易验证其当且仅当在<span class="math inline">\(V_i\cap (\sum_{i\ne j}
V_j)=\{0\}\)</span>时是单射.我们将此称作其<strong>直和分解</strong>.如果不满足上述条件一般称作<strong>外直和</strong>,满足的话则称作<strong>内直和</strong>,并容易发现内直和<span class="math inline">\(\bigoplus V_i\cong \sum V_i\)</span>.</p>
<p>外直和的一个经典应用是构造<span class="math inline">\(\varphi:V_1\oplus V_2\to V,(\vec v_1,\vec
v_2)\mapsto \vec v_1-\vec v_2\)</span>的映射,立刻得到<span class="math inline">\(\ker \varphi=V_1\cap V_2,\text{im}\
\varphi=V_1+V_2\)</span>,于是<span class="math inline">\(\dim V_1+\dim
V_2=\dim(V_1\cap
V_2)+\dim(V_1+V_2)\)</span>.这其实就是第二同构定理的维数表示.</p>
<p>接下来考虑<span class="math inline">\(V=\bigoplus_{i=1}^n
V_i,W=\bigoplus_{j=1}^m W_j\)</span>,我们可以断言<span class="math inline">\(\text{Hom}(V,W)\cong \bigoplus_{1\leq i\leq
n,1\leq j\leq m}\text{Hom}(V_i,W_j)\)</span>.这个的证明只需定义算子<span class="math inline">\(p_i:\bigoplus_{j} V_j\to V,(\vec v_j)_{j\in
J}\mapsto \vec v_i\)</span>即可.</p>
<p>对于对偶空间,事实上取<span class="math inline">\(W=F\)</span>,就会有<span class="math inline">\(V^\vee\cong \bigoplus V_i^\vee\)</span>.</p>
<p>接下来考虑映射的合成<span class="math inline">\(T:U\to V,S:V\to
W\)</span>.不妨设<span class="math inline">\(U\cong \bigoplus U_k,V\cong
\bigoplus_jV_j,W\cong \bigoplus _iW_i\)</span>,容易验证<span class="math inline">\((ST)_{i,k}=\sum_{j}S_{i,j}T_{j,k}\)</span>.</p>
<p>此时我们终于意识到了这个东西应当同构于分块矩阵.更具体地,<span class="math inline">\(\text{Hom}(V,W)\cong A_{n\times m},A_{j,i}\cong
T_{j,i},A_{j,i}\in M_{m_j\times n_i},m_j=\dim W_j,n_i=\dim
V_i\)</span>.</p>
<p>容易类比普通矩阵定义对角线分块矩阵,上(下)三角分块矩阵之类的东西.并且还容易发现上三角矩阵相乘后仍是上三角,对角线矩阵相乘后仍是对角线.</p>
<p>如果考虑<span class="math inline">\(T\in
\text{End}(V)\)</span>,事实上对角线矩阵有相当漂亮的刻画,只需观察矩阵结构就可以发现此时<span class="math inline">\(T(V_i)\subseteq
V_i\)</span>.上三角矩阵有类似的刻画,观察矩阵结构也可以发现<span class="math inline">\(T(V_i)\subseteq \bigoplus_{j\leq
i}V_j\)</span>.</p>
<p>下面我们来证明对于上三角分块矩阵<span class="math inline">\(A_{r\times r}\)</span>,如果对角线上的<span class="math inline">\(A_{i\times i}\)</span>均可逆,那么<span class="math inline">\(A_{r\times
r}\)</span>的分块矩阵可逆,而且其逆的对角线上的矩阵是一列<span class="math inline">\(A_{i\times i}^{-1}\)</span>.</p>
<p>考虑数学归纳,这样的话就只需要证明<span class="math inline">\(\begin{bmatrix}A_{1,1}&amp;A_{1,2}\\0&amp;A_{2,2}\end{bmatrix}\)</span>,其中<span class="math inline">\(A_{1,1}\)</span>和<span class="math inline">\(A_{2,2}\)</span>均可逆即可.容易发现取<span class="math inline">\(\begin{bmatrix}A_{1,1}^{-1}&amp;-A_{1,1}^{-1}A_{1,2}A_{2,2}^{-1}
\\ 0 &amp; A_{2,2}^{-1}\end{bmatrix}\)</span>即可.</p>
<p>那么反之成不成立呢?是不是此时按照合理的分块方式一定能得到对角线上的矩阵都可逆呢?也是可行的.假设<span class="math inline">\(\begin{bmatrix}A_{1,1}&amp;A_{1,2}\\0&amp;A_{2,2}\end{bmatrix}\)</span>可逆,其逆为<span class="math inline">\(\begin{bmatrix}A_{1,1}&#39;&amp;A_{1,2}&#39;\\A_{2,1}&#39;&amp;A_{2,2}&#39;\end{bmatrix}\)</span>.容易发现:
<span class="math display">\[
\begin{aligned}
\begin{bmatrix}A_{1,1}&#39;&amp;A_{1,2}&#39;\\A_{2,1}&#39;&amp;A_{2,2}&#39;\end{bmatrix}\begin{bmatrix}A_{1,1}&amp;A_{1,2}\\0&amp;A_{2,2}\end{bmatrix}=\begin{bmatrix}A_{1,1}A_{1,1}&#39;&amp;\_\\\_
&amp;\_\end{bmatrix}
\\
\begin{bmatrix}A_{1,1}&amp;A_{1,2}\\0&amp;A_{2,2}\end{bmatrix}\begin{bmatrix}A_{1,1}&#39;&amp;A_{1,2}&#39;\\A_{2,1}&#39;&amp;A_{2,2}&#39;\end{bmatrix}=\begin{bmatrix}\_&amp;\_\\\_
&amp;A_{2,2}A&#39;_{2,2}\end{bmatrix}\\
\end{aligned}
\]</span> 于是立刻见到<span class="math inline">\(A_{1,1}\)</span>和<span class="math inline">\(A_{2,2}\)</span>都有逆.</p>
<h4><span id="基的变换">基的变换</span></h4>
<h5><span id="矩阵的共轭相似">矩阵的共轭(相似)</span></h5>
<p>考虑线性映射<span class="math inline">\(T:V\to
W\)</span>,这个线性映射理应和所取的基无关,但如果我们想写出它的矩阵形式,写出来的矩阵当然取决于<span class="math inline">\(V\)</span>和<span class="math inline">\(W\)</span>取的基分别是什么(从而决定不同的坐标).不妨设<span class="math inline">\(V,W\)</span>都是定义在<span class="math inline">\(F\)</span>上的,维度分别为<span class="math inline">\(n,m\)</span>.现在取它们的有序基<span class="math inline">\(\mathcal B=\{\vec v_1,\cdots,\vec
v_n\}\)</span>,<span class="math inline">\(\mathcal C=\{\vec
w_1,\cdots,\vec w_m\}\)</span>,这样就可以确定一个同构<span class="math inline">\(\mathcal M_{\mathcal B\to \mathcal
C}:\text{Hom}(V,W)\to M_{m\times n}\)</span>.再构造一个同构<span class="math inline">\(\varphi_{\mathcal V}:F^n\to
V,(x_1,\cdots,x_n)\mapsto \sum x_i\vec
v_i\)</span>.然后我们可以画出如下交换图表(对其交换性的验证可以直接考虑对每个基验证交换性):
<span class="math display">\[
\xymatrix{
V\ar[r]^T&amp;W\\
F^n\ar[u]^{\varphi_{\mathcal B}}\ar[r]_{\mathcal M_{\mathcal B\to
\mathcal C}(T)}&amp;F^m\ar[u]_{\varphi_{\mathcal C}}
}
\]</span>
如果我们尝试考虑更换它们的基,理论上说当然会得到不同的矩阵.换言之,我们取另一组有序基<span class="math inline">\(\mathcal B&#39;=\{\vec v_1&#39;,\cdots ,\vec
v_n&#39;\},\mathcal C&#39;=\{\vec w_1&#39;,\cdots,\vec
w_m&#39;\}\)</span>,这样可以确定另一个同构<span class="math inline">\(\mathcal M_{B&#39;\to
C&#39;}\)</span>.我们下面试图探索二者之间的关系.</p>
<p>由于选取的有序基的方式不同,我们再构造一个<span class="math inline">\(P_{B&#39;\to B}:(F^n)&#39;\to
F^n,(x&#39;_1,\cdots,x&#39;_n)\mapsto (x_1,\cdots x_n),\sum x&#39;_i\vec
v&#39;_i=\sum x_i\vec v_i\)</span>,容易验证取<span class="math inline">\(P_{V&#39;\to
V}={(\varphi_V)}^{-1}\varphi_{V&#39;}\)</span>即可并且是自同构,并且<span class="math inline">\((P_{V\to V&#39;})^{-1}=P_{V&#39;\to
V}\)</span>.写成交换图表的话应当形如: <span class="math display">\[
\xymatrix{
&amp;V&amp;\\
(F^n)&#39;\ar[ru]^{\varphi_{\mathcal B&#39;}}\ar[rr]_{P_{\mathcal
B&#39;\to \mathcal B}}&amp;&amp;F^n\ar[lu]_{\varphi_{\mathcal B}}
}
\]</span> 这里所有的箭头当然都是可逆的.</p>
<p>事实上,不妨设<span class="math inline">\(\vec
v_i&#39;=\sum_{j}p_{j,i}\vec v_j\)</span>,也就是将<span class="math inline">\(\vec v&#39;\)</span>展开成列向量,对于<span class="math inline">\(\vec x=\sum_{i}x&#39;_i\vec
v&#39;_i\)</span>,考虑<span class="math inline">\(\sum_{i}x&#39;_i\vec
v&#39;_i=\sum_{i}x&#39;_i\sum_{j}p_{j,i}\vec v_j=\sum_{j}\vec
v_j\sum_{i}x&#39;_ip_{j,i}=\sum_j\vec v_jx_j\)</span>,那么<span class="math inline">\(p_{j,i}\)</span>其实就是<span class="math inline">\(P_{\mathcal B&#39;\to \mathcal
B}\)</span>的对应矩阵的第<span class="math inline">\(j\)</span>行<span class="math inline">\(i\)</span>列元素.此时我们称<span class="math inline">\(P_{n\times n}\)</span>为从有序基<span class="math inline">\(\cal B&#39;\to \cal
B\)</span>的<strong>转换矩阵</strong>.事实上容易见到转换矩阵都是可逆的,并且事实上所有的可逆矩阵都可以看作标准基对某个矩阵的转换矩阵.</p>
<p>这样的话,我们就容易见到:<span class="math inline">\(\mathcal
M_{B&#39;\to C&#39;}(T)=P_{C\to C&#39;}\mathcal M_{B\to
C}(T)P_{B&#39;\to B}=(P_{C&#39;\to C})^{-1}\mathcal M_{B\to
C}(T)P_{B&#39;\to B}\)</span>.这里一定要注意<span class="math inline">\(\mathcal M_{B\to C}\)</span>是一个将映射<span class="math inline">\(T\)</span>变为矩阵<span class="math inline">\(M\)</span>的映射.</p>
<p>具体地,我们可以看下面的交换图表: <span class="math display">\[
\xymatrix{
(F^n)&#39;\ar[rrr]^{\mathcal M_{B&#39;\to
C&#39;}(T)}\ar[dd]_{P_{B&#39;\to B}}\ar[rd]^{\varphi_{B&#39;}}
&amp;&amp;&amp; (F^m)&#39;\ar[dd]^{P_{C&#39;\to
C}}\ar[ld]_{\varphi_{C&#39;}}\\
&amp;V\ar[r]^T&amp;W\\
F^n\ar[rrr]_{\mathcal M_{B\to C}(T)}\ar[ru]_{\varphi_B} &amp;&amp;&amp;
F^m\ar[lu]^{\varphi_C}
}
\]</span> 接下来我们考虑<span class="math inline">\(T\in
\text{End}(V)\)</span>,自然可以导出<span class="math inline">\(\mathcal
M_{B&#39;\to B&#39;}(T)=P^{-1}\mathcal M_{B\to B}(T)P\)</span>,其中<span class="math inline">\(P=P_{B&#39;\to B}\)</span>.</p>
<p>于是综上,我们称两个矩阵<span class="math inline">\(A_{n\times
n},B_{n\times n}\)</span>相似,当且仅当存在可逆矩阵<span class="math inline">\(P_{n\times n}\)</span>使得<span class="math inline">\(A=P^{-1}BP\)</span>.由上面可以看出来,相似的两个矩阵实际上是不同基下的同种变换.</p>
<p>另外我们注意到,固定<span class="math inline">\(P_{n\times
n}\)</span>后定义映射<span class="math inline">\(P:M_{n\times n}\to
M_{n\times n},A\mapsto
P^{-1}AP\)</span>不仅仅是线性同构,还是一个环同构.容易验证其满足环同构的性质.</p>
<p>此时注意到另一个事情:我们知道我们做共轭实际上是换基操作,那么如果我们需要换基,难道我们必须总是对着矩阵做矩阵乘法么?</p>
<p>事实上,我们应当观察如下矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}&amp;\vec e_1&amp;\cdots&amp;\vec e_n\\\vec
e_1&amp;a_{1,1}&amp;\cdots&amp;a_{n,1}\\\vdots&amp;\cdots&amp;\ddots&amp;\vdots\\\vec
e_n&amp;a_{1,n}&amp;\cdots&amp;a_{n,n}\end{bmatrix}
\]</span></p>
<p>最简单的改变,我们如果想要让它变成在另一组有序基下的操作,我们应当如何操作呢?如果我们带着这些向量去做,我们实际上可以发现:放在列上的这些向量随着列变换而操作,放在行上的这些向量随着行变换的逆变换而改变.这就是更加方便的做相似矩阵的办法.而这事实上也就是因为,任何一个可逆的矩阵都可以拆成若干初等矩阵,因此只需要将<span class="math inline">\(P\)</span>拆成初等矩阵两边分别做就可以.初等矩阵求逆当然是平凡的.</p>
<h5><span id="矩阵的相抵">矩阵的相抵</span></h5>
<p>我们称两个矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span><strong>相抵</strong>,当且仅当<span class="math inline">\(\exists P,Q\)</span>均可逆,<span class="math inline">\(A=PBQ\)</span>.容易看出相抵是等价关系.由于可逆矩阵等价于若干初等矩阵的乘积,那么<span class="math inline">\(A,B\)</span>相抵当且仅当<span class="math inline">\(B\)</span>可以通过若干初等行变换和列变换变成<span class="math inline">\(A\)</span>.下面我们证明<span class="math inline">\(A,B\)</span>相抵等价于<span class="math inline">\(\text{rk}\ A=\text{rk}\ B\)</span>.</p>
<p><span class="math inline">\(A,B\)</span>相抵的时候当然有<span class="math inline">\(\text{rk}\ A=\text{rk}\ B\)</span>,因为此时<span class="math inline">\(\text {rk}\ A=\dim \text{im
(PBQ)}\)</span>,而<span class="math inline">\(P,Q\)</span>都是同构,所以此时有<span class="math inline">\(\text{rk}\ A=\dim \text{im}\ B=\text{rk}\
B\)</span>.</p>
<p>当<span class="math inline">\(\text {rk}\ A=\text{rk}\
B=k\)</span>时,我们考虑二者都可以经过若干次行变换或者列变换变成形如<span class="math inline">\(m_{i,j}=\begin{cases}1&amp;i=j\leq
k\\0&amp;otherwise\end{cases}\)</span>.于是二者等价.</p>
<p>类似上面就可以发现<span class="math inline">\(\text{rk}\ A=\text{rk}\
A^T\)</span>,原因是二者都可以消成上述那种矩阵,而那种矩阵的主元数量显然是确定且相等的.</p>
<p>用矩阵的相抵可以更快证明Frobenius秩不等式,具体地,考虑分块矩阵<span class="math inline">\(\begin{bmatrix}ABC&amp;0\\0&amp;B\end{bmatrix}\)</span>.考虑<span class="math inline">\(\begin{bmatrix}I&amp;-A\\0&amp;I\end{bmatrix}\begin{bmatrix}ABC&amp;0\\0&amp;B\end{bmatrix}\begin{bmatrix}I&amp;0\\C&amp;I\end{bmatrix}=\begin{bmatrix}0&amp;-AB\\BC&amp;B\end{bmatrix}\)</span>,于是我们知道<span class="math inline">\(\begin{bmatrix}ABC&amp;0\\0&amp;B\end{bmatrix}\)</span>和<span class="math inline">\(\begin{bmatrix}0&amp;-AB\\BC&amp;B\end{bmatrix}\)</span>相抵.</p>
<p>而<span class="math inline">\(\text{rk}\
\begin{bmatrix}ABC&amp;0\\0&amp;B\end{bmatrix}=\text{rk}\ ABC+\text{rk}\
B\)</span>,下面考虑证明<span class="math inline">\(\text{rk}\
\begin{bmatrix}0&amp;-AB\\BC&amp;B\end{bmatrix}\geq \text{rk}\
AB+\text{rk}\ BC\)</span>,而直接考虑<span class="math inline">\(BC\)</span>和<span class="math inline">\(AB\)</span>的行,<span class="math inline">\(BC\)</span>中线性无关行和<span class="math inline">\(AB\)</span>中线性无关行必定也线性无关,而原本线性相关的那些加上右下角的<span class="math inline">\(B\)</span>也有可能变得线性无关,于是上述不等式就得证了.</p>
<h4><span id="商空间">商空间</span></h4>
<p>如果我们考虑在线性空间上定义等价关系<span class="math inline">\(\vec
v_1\sim \vec v_2\Leftrightarrow T\vec v_1=T\vec v_2\)</span>,其中<span class="math inline">\(T\)</span>是一个线性映射,容易发现此时<span class="math inline">\(\vec v_1-\vec v_2\in \ker
T\)</span>.所以其实和<span class="math inline">\(T\)</span>本身关系不大,而只和<span class="math inline">\(\ker T\)</span>这个子空间有关.</p>
<p>那我们不妨设<span class="math inline">\(U\)</span>是<span class="math inline">\(V\)</span>的子空间,立刻发现<span class="math inline">\(\vec v_1\sim \vec v_2\Leftrightarrow (\vec
v_1-\vec v_2)\in U\)</span>是一个等价关系.</p>
<p>在此基础上定义<strong>陪集</strong><span class="math inline">\(\vec
v+U\)</span>,容易发现陪集组成了一个新的线性空间(当然要验证良定义),将其称作<strong>商空间</strong>,并且可验证映射<span class="math inline">\(\varphi:V\to V/U,\vec v\mapsto \vec
v+U\)</span>是线性映射.类比陪群,得知<span class="math inline">\(\ker
\varphi=U\)</span>,综合前面的讨论得知此时<span class="math inline">\(\vec v_1\sim \vec v_2\Leftrightarrow \vec
v_1+U=\vec v_2+U\)</span>.</p>
<p>顺便可以顺手引入<strong>余核</strong><span class="math inline">\(\text{coker}(T)=W/\text{im}\
T\)</span>,容易发现<span class="math inline">\(T\)</span>是满射当且仅当<span class="math inline">\(\text{coker}(T)=\{0\}\)</span>.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>下面来抛出另一个命题.对于线性映射<span class="math inline">\(T:V\to
W,\varphi:V\to V/U\)</span>,如果<span class="math inline">\(U\subseteq
\ker T\)</span>,那么存在唯一的线性映射<span class="math inline">\(\bar
T:V/U\to W\)</span>.使得<span class="math inline">\(T=\bar
T\varphi\)</span>.</p>
<p>这个证明看上去是相当正确的.由于<span class="math inline">\(\varphi\)</span>是满射,那么必定有<span class="math inline">\(\bar T(\vec v+U)=T\vec
v\)</span>,这是显然是唯一的映射,也容易看出其是正确的线性映射.具体来讲,存在唯一的线性映射<span class="math inline">\(\bar T\)</span>使得下图交换: <span class="math display">\[
\xymatrix{
V\ar[r]^T\ar[d]_\varphi &amp;W\\
V/U\ar[ru]_{\bar T}
}
\]</span> 在上述命题中如果<span class="math inline">\(T\)</span>也是满射,也就是<span class="math inline">\(W=\text{im}\ T\)</span>,取<span class="math inline">\(U=\ker T\)</span>,那么此时<span class="math inline">\(\bar T\varphi=T\)</span>,这必定意味着<span class="math inline">\(\text{im}\ \bar T=W\)</span>.接下来考虑一下<span class="math inline">\(\ker \bar T\)</span>的模样,考虑<span class="math inline">\(\bar T(\vec v+U)=0\Leftrightarrow T(\vec
v)=0\Leftrightarrow \vec v\in U\Leftrightarrow \vec
v+U=U\)</span>,从而<span class="math inline">\(\ker \bar
T=\{U\}\)</span>,于是<span class="math inline">\(\bar
T\)</span>是同构.</p>
<p>就可以发现对于一个线性映射<span class="math inline">\(T\)</span>,<span class="math inline">\(V/U=V/\ker
T\cong\text{im}\
T\)</span>,这其实就是同态基本定理在线性空间上的表现.不过线性空间上还多一个标量乘法的运算,需要在群的基础上对此进行简单验证.另外线性空间上还有维数的概念,当然立即断言<span class="math inline">\(\dim V=\dim U+\dim
(V/U)\)</span>.值得一提的是这同样也告知我们<span class="math inline">\(U\)</span>的基和<span class="math inline">\(V/U\)</span>的反像的基合起来就是一组<span class="math inline">\(V\)</span>的基.</p>
<p>上述说了这么多其实都在着重于所谓商空间的结构,现在我们看到陪集的定义可以在相当的意义上刻画商空间.适当推广上面的结论可以有:</p>
<p>设<span class="math inline">\(T:V_1\to V_2\)</span>是线性映射,<span class="math inline">\(U_1\subseteq V_1,U_2\subseteq
V_2\)</span>并构造两个商映射<span class="math inline">\(\varphi_1:V_1\to
V_1/U_1,\varphi_2:V_2\to V_2/U_2\)</span>,并且<span class="math inline">\(T(U_1)\subseteq
U_2\)</span>,那么存在唯一的线性映射<span class="math inline">\(\bar
T:V_1/U_1\to V_2/U_2\)</span>使得<span class="math inline">\(T\varphi_2=\bar T\varphi_1\)</span>.具体地,<span class="math inline">\(\bar T(\vec v+U_1)=T\vec v+U_2\)</span>.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表: <span class="math display">\[
\xymatrix{
V_1 \ar[rr]^T\ar[d]_{\varphi_1} &amp;&amp;V_2
\ar[rr]^S\ar[d]_{\varphi_2}&amp;&amp; V_3 \ar[d]_{\varphi_3}\\
    V_1/U_1 \ar[rr]^{\bar T}_{\ker \bar T=T^{-1}(U_2)/U_1}
&amp;&amp;V_2/U_2 \ar[rr]^{\bar S}_{\ker \bar S=S^{-1}(U_3)/U_2}
&amp;&amp;V_3/U_3\\
}
\]</span></p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>将群论中的第一同构定理(不过线性空间下没有正规的概念)拿过来,即对于线性空间<span class="math inline">\(V\)</span>的一个子空间<span class="math inline">\(U\)</span>,在典范同态<span class="math inline">\(\pi:V\rightarrow V/U\)</span>下,我们有:</p>
<ol type="1">
<li><span class="math inline">\(V\)</span>的包含<span class="math inline">\(U\)</span>的子空间<span class="math inline">\(W\)</span>和<span class="math inline">\(V/U\)</span>的子空间<span class="math inline">\(\bar W\)</span>在<span class="math inline">\(\pi\)</span>下一一对应.不妨设此对应为<span class="math inline">\(\varphi:W\mapsto \bar W\)</span>.</li>
<li>此对应是严格保序的,也就是<span class="math inline">\(W_1\subseteq
W_2\Leftrightarrow \bar W_1\subseteq \bar W_2\)</span>.</li>
<li>若有<span class="math inline">\(U\subseteq W\subseteq
V\)</span>,则<span class="math inline">\(V/W\cong
(V/U)/(W/U)\)</span>.</li>
</ol>
<p>考虑(1)(2)的证明:</p>
<p>先证明单射,对于两个包含<span class="math inline">\(U\)</span>的子空间<span class="math inline">\(W_1\ne W_2\)</span>来说,不妨设<span class="math inline">\(W_1\nsubseteq W_2\)</span>,<span class="math inline">\(\exists \vec a\in W_1,\vec a\notin
W_2\)</span>.此时考虑<span class="math inline">\(\bar
a\)</span>,注意到如果<span class="math inline">\(\bar a\in
\bar{W_2}\)</span>,那么<span class="math inline">\(\vec a+U\in
W_2+U\)</span>.这表明<span class="math inline">\(\exists \vec b\in
W_2\)</span>,<span class="math inline">\(\vec a+U=\vec
b+U\)</span>,此时<span class="math inline">\(\vec a-\vec b\in U\subseteq
W_2\)</span>,那么<span class="math inline">\(\vec a\in
W_2\)</span>,这就不符合了,于是当然<span class="math inline">\(\bar{W_1}\ne
\bar{W_2}\)</span>并且(2)上严格保序.</p>
<p>证明单射还有一种办法是考虑只需证明<span class="math inline">\(\pi^{-1}(\pi(W))=W\)</span>即可,而<span class="math inline">\(W\subseteq
\pi^{-1}(\pi(W))\)</span>是显然的.又考虑<span class="math inline">\(\forall \vec v\in \pi^{-1}(\pi(W)),\pi(\vec
v)\in\pi (W)\)</span>,这意味着<span class="math inline">\(\exists \vec
w\in W,\pi(\vec v)=\pi(\vec w)\)</span>,于是<span class="math inline">\(\vec v\in \vec w+\ker \pi=\vec w+U\subseteq \vec
w+W=W\)</span>.这样就证明了<span class="math inline">\(W\supseteq
\pi^{-1}(\pi(W))\)</span>.</p>
<p>接下来要证明满射,也就是证明<span class="math inline">\(\forall N\leq
V/U,U\leq \pi^{-1}(N)\leq G\)</span>.</p>
<p>首先要证明<span class="math inline">\(\pi^{-1}(N)\)</span>是一个子空间,这个是容易验证的.</p>
<p>而由于保序性已经被证明了,我们就可以注意到由于<span class="math inline">\(\vec 0\in N\)</span>,于是有<span class="math inline">\(\bar 0=U\leq \pi^{-1}(N)\)</span>.</p>
<p>对于(3):</p>
<p>由同态基本定理,考虑构造满射<span class="math inline">\(\varphi:V/U\rightarrow V/W\)</span>,只需证明<span class="math inline">\(\ker\ \varphi=W/U\)</span>即可.</p>
<p>直觉上会认为映射<span class="math inline">\(\varphi:\vec v+U\mapsto
\vec v+W\)</span>即可,下面验证其满足上述性质:</p>
<p>首先验证良定义,<span class="math inline">\(\vec v_1+U=\vec
v_2+U\Leftrightarrow \vec v_1-\vec v_2\in U\subseteq W\Rightarrow \vec
v_1+W=\vec v_2+W\)</span>.</p>
<p>然后验证线性映射,这个验证过程很平凡.</p>
<p>其满性显然.只需验证其<span class="math inline">\(\ker \varphi
=W/U\)</span>即可,而考虑<span class="math inline">\(\varphi(\vec
v+U)=W\Leftrightarrow \vec v+W=W\Leftrightarrow \vec v\in
W\Leftrightarrow \vec v+U\in W/U\)</span>.这样就证明了上述结论.</p>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p><span class="math inline">\(V,W\)</span>是一个更大的线性空间的子空间,那么我们有:</p>
<p><span class="math inline">\(V/(V\cap W)\cong (V+W)/W,\vec v+(V\cap
W)\mapsto \vec v+W\)</span>.</p>
<p>考虑<span class="math inline">\(\varphi:V\to(V+W)/W,\vec v\mapsto
\vec v+W\)</span>,那么显然<span class="math inline">\(\varphi(\vec
v)=W\Leftrightarrow \vec v\in V\cap W\)</span>,于是<span class="math inline">\(\ker \varphi=V\cap W\)</span>.</p>
<p>接下来只需要证明它是满射就可以了.考虑<span class="math inline">\(\forall \vec v+\vec w+W=\vec v+W\in
(V+W)/W\)</span>,这当然是满射.</p>
<p>第二同构定理的一个平凡推论是<span class="math inline">\(\dim(V+W)=(\dim V)+(\dim W)-\dim (V\cap
W)\)</span>.</p>
<p>第二同构定理的另一个推论是说如果<span class="math inline">\(V=U\oplus
W\)</span>,那么<span class="math inline">\(W\cong
V/U\)</span>.原因是<span class="math inline">\(U+W=V\)</span>并且<span class="math inline">\(U\cap W=\{\vec
0\}\)</span>.换言之取商是直和的逆运算.</p>
<p>第二同构定理证明的另一种思路是考虑<span class="math inline">\(\varphi:V\times W\to V+W,(\vec v,\vec
w)\mapsto(\vec v-\vec w)\)</span>,此时注意到<span class="math inline">\(\text{im}\varphi=(V+W),\ker \varphi=V\cap
W\)</span>.</p>
<h5><span id="旗">旗</span></h5>
<p>回看我们一开始拿到的映射<span class="math inline">\(T:V\to
V&#39;\)</span>和映射<span class="math inline">\(\bar T:V/U\to
V&#39;/U&#39;\)</span>.也就是下面这个交换图表: $$ $$
现在我们尝试用矩阵刻画<span class="math inline">\(T\)</span>和<span class="math inline">\(\bar
T\)</span>之间的关系.首先我们需要开始取基,不妨取<span class="math inline">\(\{\vec u_1,\cdots,\vec u_k\}\)</span>是<span class="math inline">\(U\)</span>的一组有序基,<span class="math inline">\(\{\bar v_1,\cdots,\bar v_m\}\)</span>是<span class="math inline">\(V/U\)</span>的一组有序基.<span class="math inline">\(\{\vec u_1&#39;,\cdots,\vec
u_{k&#39;}&#39;\}\)</span>是<span class="math inline">\(U&#39;\)</span>的一组有序基,<span class="math inline">\(\{\bar v_1&#39;,\cdots,\bar
v_{m&#39;}&#39;\}\)</span>是<span class="math inline">\(V&#39;/U&#39;\)</span>的一组有序基.此时由于<span class="math inline">\(\ker \varphi=U\)</span>,我们之前证明<span class="math inline">\(\ker\)</span>的维度关系的时候已经说明过,<span class="math inline">\(\{\vec u_1,\cdots,\vec u_k,\vec v_1,\cdots \vec
v_m\}\)</span>实际上是<span class="math inline">\(V\)</span>的一组有序基.尝试取出一个矩阵<span class="math inline">\(A\in M_{(k&#39;+m&#39;)\times
(k+m)}\)</span>来作为<span class="math inline">\(T\)</span>对应的矩阵.此时将<span class="math inline">\(A\)</span>分块,我们将其写作<span class="math inline">\(A=\begin{bmatrix}A_{U\to U&#39;}&amp;A_{V/U\to
U&#39;}\\A_{U\to V&#39;/U&#39;}&amp;A_{V/U\to
V&#39;/U&#39;}\end{bmatrix}\)</span>.由于<span class="math inline">\(T(U)\subseteq U&#39;\)</span>,我们知道<span class="math inline">\(A_{U\to V&#39;/U&#39;}=0\)</span>,而又有<span class="math inline">\(A_{V/U\to V&#39;/U&#39;}\)</span>当然就是<span class="math inline">\(\bar T\)</span>对应的矩阵<span class="math inline">\(\bar A\)</span>.总结一下就是<span class="math inline">\(A=\begin{bmatrix}A_{U\to
U&#39;}&amp;\_\\0&amp;\bar A\end{bmatrix}\)</span>.</p>
<p>如此观察可以继续推广并得到<strong>旗</strong>的概念.我们称<span class="math inline">\(V\)</span>的<strong>旗</strong>是一列子空间<span class="math inline">\(\{\vec 0\}=U_0\subsetneq \cdots\subsetneq
U_d=V\)</span>.特别地,如果<span class="math inline">\(d=\dim
V\)</span>,则称其为<strong>完备旗</strong>,容易见到完备旗一定满足<span class="math inline">\(\dim V_i=i\)</span>.对于给定的旗,如果线性映射<span class="math inline">\(T\in \text{End}(V)\)</span>对<span class="math inline">\(\forall 0\leq i\leq m\)</span>满足<span class="math inline">\(T(V_i)\subseteq V_i\)</span>,则称<span class="math inline">\(T\)</span>保持此旗.</p>
<p>如果一个映射<span class="math inline">\(T:V\to
V&#39;\)</span>满足<span class="math inline">\(\forall h,T(U_h)\subseteq
U&#39;_h\)</span>,那我们可以对每个<span class="math inline">\(U_h/U_{h-1}\)</span>和<span class="math inline">\(U&#39;_h/U&#39;_{h-1}\)</span>选定有序基,那么得到的矩阵<span class="math inline">\(A\)</span>应当是一个分块上三角矩阵,而且<span class="math inline">\(A_{i,i}\)</span>实际上就是<span class="math inline">\(\bar T_h:U_h/U_{h-1}\to
U&#39;_h/U&#39;_{h-1}\)</span>所对应的矩阵.</p>
<h5><span id="不变子空间">不变子空间</span></h5>
<p>给定线性映射<span class="math inline">\(T\in\text{End}(V)\)</span>,如果子空间<span class="math inline">\(U\subseteq V\)</span>满足<span class="math inline">\(T(U)\subseteq U\)</span>,那我们称<span class="math inline">\(U\)</span>是在<span class="math inline">\(T\)</span>下的一个<strong>不变子空间</strong>.根据前面我们已经讨论过的内容,得到下面这个交换图表:
$$ $$ 其中<span class="math inline">\(\bar T\)</span>是唯一的.</p>
<p>提取<span class="math inline">\(T|_U\)</span>为只考虑<span class="math inline">\(T\)</span>在线性空间<span class="math inline">\(U\)</span>上的作用得到的线性映射,上述交换图表给出以下矩阵:<span class="math inline">\(T\cong \begin{bmatrix}T|_U&amp;\_\\0&amp;\bar
T\end{bmatrix}\)</span>.这个形式更好的用处是结合之后的迹/行列式/特征多项式等概念给出<span class="math inline">\(T,T|_U,\bar T\)</span>三者的关系:事实上<span class="math inline">\(\det(T|_U)\det (\bar T)=\det
(T),\text{tr}(T|_U)+\text{tr} (\bar T)=\text{tr} (T)\)</span>.</p>
<h3><span id="行列式">行列式</span></h3>
<h4><span id="置换排列">置换(排列)</span></h4>
<p>不妨假设<span class="math inline">\(X\)</span>是一个非空集合,那么我们定义其<strong>置换集合</strong><span class="math inline">\(S_X=\{\sigma:X\to X,\sigma\ \text{is a
bijection}\}\)</span>.容易看出<span class="math inline">\(S_X\)</span>对置换复合构成一个群.</p>
<p>我们也可以用<span class="math inline">\(\left(\begin{matrix}1&amp;\cdots&amp;n\\\sigma(1)&amp;\cdots&amp;\sigma(n)\end{matrix}\right)\)</span>.</p>
<p>我们还可以定义<strong>轮换</strong>为<span class="math inline">\(\left(\begin{matrix}1&amp;2&amp;\cdots&amp;n-1&amp;n\\2&amp;3&amp;\cdots&amp;n&amp;1\end{matrix}\right)\)</span>.</p>
<p>还可以定义<strong>对换</strong><span class="math inline">\((i,j)=\left(\begin{matrix}1&amp;\cdots&amp;i&amp;\cdots&amp;j&amp;\cdots&amp;n\\1&amp;\cdots&amp;j&amp;\cdots&amp;i&amp;\cdots&amp;n\end{matrix}\right)\)</span>,其中<span class="math inline">\(i\ne j\)</span>.</p>
<p>在此基础上定义<strong>单对换</strong><span class="math inline">\(s_i=(i,i+1)\)</span>.</p>
<p>在置换的基础上可以定义逆序对:<span class="math inline">\(\text{Inv}_\sigma=\{(i,j)\mid 1\leq i&lt;j\leq
n,\sigma(i)&gt;\sigma(j)\}\)</span>,并定义逆序数<span class="math inline">\(l(\sigma)=|\text{Inv}_\sigma|\)</span>.容易看出<span class="math inline">\(l(\sigma)=0\Leftrightarrow
\sigma=\text{id}\)</span>,<span class="math inline">\(l(\sigma)=\frac{n(n-1)}{2}\Leftrightarrow
\sigma(k)=n-k+1\)</span>.并且注意到<span class="math inline">\(l(\sigma)=l(\sigma^{-1})\)</span>,原因是<span class="math inline">\((i,j)\mapsto
(\sigma(j),\sigma(i))\)</span>是双射.</p>
<p>容易发现一个<span class="math inline">\(\sigma\)</span>可以最少通过<span class="math inline">\(l(\sigma)\)</span>次单对换变为<span class="math inline">\(\text{id}\)</span>,原因是每次交换一对<span class="math inline">\((i,i+1)\)</span>当<span class="math inline">\(\sigma(i)&gt;\sigma(i+1)\)</span>时会让逆序数减少<span class="math inline">\(1\)</span>.或者说更一般地<span class="math inline">\(|l(\sigma)-l(s_i\sigma)|=1\)</span>.由于<span class="math inline">\((s_i)^{-1}=s_i\)</span>,容易发现<span class="math inline">\(|l(\sigma)-l(\sigma s_i)|=1\)</span>.而事实上<span class="math inline">\(|l(\sigma)-l((i,j)\sigma)|\in
\text{odd}\)</span>.这意味着对换会改变逆序数的奇偶性.所以容易看出来一个置换<span class="math inline">\(\sigma\)</span>如果能拆成若干个对换,这些对换的数量的奇偶性一定与<span class="math inline">\(l(\sigma)\)</span>相同.</p>
<p>而由于可以如上分解并合并,我们知道<span class="math inline">\(l(\sigma\tau)\)</span>和<span class="math inline">\(l(\sigma)+l(\tau)\)</span>的奇偶性必然相同.</p>
<p>于是我们可以定义<span class="math inline">\(\text{sgn}(\sigma)=(-1)^{l(\sigma)}\)</span>,并且容易发现<span class="math inline">\(\text{sgn}(\sigma\tau)=\text{sgn}(\sigma)\text{sgn}(\tau)\)</span>.还可以看出<span class="math inline">\(\text{sgn}(\sigma^{-1})=\text{sgn}(\sigma)\)</span>,那么立刻有<span class="math inline">\(\text{sgn}(\sigma^{-1}\tau\sigma)=\text{sgn}(\tau)\)</span>.用此可以定义奇偶置换的概念,也就是<span class="math inline">\(l(\sigma)\in \text{odd}\)</span>的置换<span class="math inline">\(\sigma\)</span>是奇置换.</p>
<h4><span id="交错形式">交错形式</span></h4>
<p>尝试刻画一种交错形式<span class="math inline">\(D:V^m\to
F\)</span>,其中<span class="math inline">\(V\)</span>是定义在<span class="math inline">\(F\)</span>上的线性空间,满足以下性质:</p>
<ol type="1">
<li>其对每一个分量都是线性的.也即固定其他<span class="math inline">\(m-1\)</span>个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之<span class="math inline">\(D(\cdots,t\vec v_i,\cdots)=tD(\cdots,\vec
v_i,\cdots),D(\cdots,\vec v_i+v_i&#39;,\cdots)=D(\cdots,\vec
v_i,\cdots)+D(\cdots,\vec v_i&#39;,\cdots)\)</span>.</li>
<li>如果有两个分量相等,那么得到的是<span class="math inline">\(0\)</span>.</li>
</ol>
<p>在上述基础上容易发现交错形式也是线性空间,不妨将其记作<span class="math inline">\(D_{V,m}\)</span>.</p>
<p>容易发现<span class="math inline">\(D_{V,1}=V^\vee\)</span>.</p>
<p>初看会觉得(2)是一个很奇怪的事情,但实际上其定义了一种很好的性质:首先我们应当需要一种东西使得如果有一个分量是<span class="math inline">\(\vec 0\)</span>则给出<span class="math inline">\(0\)</span>,但如果直接这么定义的话容易看到难以判定一个东西在没有分量为<span class="math inline">\(0\)</span>的时候是否为<span class="math inline">\(0\)</span>,因此这个定义的性质更为优良.事实上,我们有以下性质:</p>
<ol type="1">
<li>对于一个固定的<span class="math inline">\(D\)</span>而言,将其某一个分量乘以若干倍加到另一个分量上不会引起取值的变化.</li>
<li>对于一个固定的<span class="math inline">\(D\)</span>而言,将某一个分量乘以<span class="math inline">\(t\)</span>倍,则取值需要乘以<span class="math inline">\(t\)</span>倍.</li>
<li>对于一个固定的<span class="math inline">\(D\)</span>而言,如果其收到的向量组是线性相关的,那么取值为<span class="math inline">\(0\)</span>.</li>
<li>作为(3)的推论,如果<span class="math inline">\(m&gt;\dim
V\)</span>,那么<span class="math inline">\(D_{V,m}=\{0\}\)</span>.</li>
<li>对于一个固定的<span class="math inline">\(D\)</span>而言,<span class="math inline">\(D(\cdots,\vec v_i,\cdots,\vec
v_j,\cdots)=-D(\cdots,\vec v_j,\cdots,\vec v_i,\cdots)\)</span>.</li>
<li>作为(5)的推论,<span class="math inline">\(D(\vec
v_{\sigma^{-1}(1)},\cdots,\vec
v_{\sigma^{-1}(m)})=\text{sgn}(\sigma)D(\vec v_1,\cdots,\vec
v_m)\)</span>.</li>
</ol>
<p>其它几个都是平凡的,下面考虑(5)的证明,我们有: <span class="math display">\[
0=D(\cdots,\vec v_i+\vec v_j,\cdots,\vec v_j+\vec v_i,\cdots)\\
=D(\cdots,\vec v_i,\cdots,\vec v_j,\cdots)+D(\cdots,\vec v_i,\cdots,\vec
v_i,\cdots)\\+D(\cdots,\vec v_j,\cdots,\vec v_i,\cdots)+D(\cdots,\vec
v_j,\cdots,\vec v_j,\cdots)\\
=D(\cdots,\vec v_i,\cdots,\vec v_j,\cdots)+D(\cdots,\vec v_j,\cdots,\vec
v_i,\cdots)
\]</span></p>
<p>下面我们定义<span class="math inline">\(D_V=D_{V,n}\)</span>,其中<span class="math inline">\(n=\dim V\)</span>,取出其一组有序基<span class="math inline">\(\{\vec e_1,\cdots,\vec
e_n\}\)</span>.对于一组向量<span class="math inline">\(\{\vec
v_{1},\cdots,\vec v_n\}\)</span>,尝试将其分解为<span class="math inline">\(\vec v_i=\sum_{j}a_{i,j}\vec
e_j\)</span>.此时逐个展开<span class="math inline">\(D(\vec
v_1,\cdots,\vec v_n)\)</span>中的向量,理应得知: <span class="math display">\[
D(\vec v_1,\cdots,\vec v_n)=\sum_{\sigma\in S_n}\prod_{k=1}^na_{k,\sigma
(k)}D(\vec e_{\sigma (1)},\cdots,\vec e_{\sigma(n)})\\=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)\prod_{k=1}^na_{k,\sigma(k)}D(\vec e_1,\cdots,\vec
e_n)
\]</span> 这说明任何一个<span class="math inline">\(D\)</span>实际上只由其在基上的作用<span class="math inline">\(D(\vec e_1,\cdots,\vec
e_n)\)</span>唯一确定.因此<span class="math inline">\(\dim D\leq 1=\dim
F\)</span>,原因是线性映射<span class="math inline">\(D_V\to F,D\mapsto
D(\vec e_1,\cdots,\vec e_n)\)</span>是单射.事实上只要<span class="math inline">\(\dim V\geq 1\)</span>,当然可以如上构造<span class="math inline">\(D_e=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)\prod_{k=1}^na_{k,\sigma(k)}\in
D_V\setminus\{0\}\)</span>,于是<span class="math inline">\(\dim D\ne
0\)</span>,于是<span class="math inline">\(\dim D=1\)</span>.</p>
<p>验证<span class="math inline">\(D_e\)</span>映射符合定义的过程较为无聊,验证有相同元素则为<span class="math inline">\(0\)</span>是考虑交换它们后<span class="math inline">\(\text{sgn}\)</span>会变号,而还容易简单验证<span class="math inline">\(D_e(\vec e_1,\cdots \vec e_n)=1\)</span>.</p>
<h4><span id="定义">定义</span></h4>
<p>考虑有限维的<span class="math inline">\(V,W\)</span>,并考虑映射<span class="math inline">\(T^*:D_{W,m}\to D_{V,m},D\mapsto ((T^*D):(\vec
v_1,\cdots,\vec v_m)\mapsto D(T\vec v_1,\cdots T\vec v_m)\)</span>.</p>
<p>现在取<span class="math inline">\(W=V,m=n=\dim V\)</span>,于是<span class="math inline">\(T\in
\text{End}(V),T^*\in\text{End}(D_V)\)</span>,由于<span class="math inline">\(\dim D_V=1\)</span>,于是<span class="math inline">\(T^*\)</span>必然是伸缩映射<span class="math inline">\(D\mapsto tD\)</span>,那么这个<span class="math inline">\(t\)</span>其实就是行列式.更确切地说,我们定义:
<span class="math display">\[
T^*(D)=(\det T)D\\
D(T\vec v_1,\cdots,T\vec v_n)=\det T\times D(\vec v_1,\cdots \vec v_n)
\]</span> 那么既然其是伸缩映射,我们就当然注意到<span class="math inline">\(\det T=\frac{D_e(T\vec e_1,\cdots,T\vec
e_n)}{D_e(\vec e_1,\cdots ,\vec e_n)}=D_e(T\vec e_1,\cdots,T\vec
e_n)\)</span>.</p>
<p>只需简单利用定义就可以注意到行列式的以下性质:</p>
<ol type="1">
<li><span class="math inline">\(\det \text{id}_V=1\)</span>.</li>
<li><span class="math inline">\(\det(ST)=\det S\times \det
T\)</span>.</li>
<li><span class="math inline">\(T\)</span>可逆时,<span class="math inline">\(\det (T^{-1})=(\det T)^{-1}\)</span>.</li>
<li><span class="math inline">\(T\)</span>不可逆时,<span class="math inline">\(\det T=0\)</span>.</li>
</ol>
<p>应当警觉的一个事情是我们上面给出的计算<span class="math inline">\(D\)</span>的方式是观察<span class="math inline">\(D\)</span>在某一组基上的作用,而我们理应判定当选取的基不同的时候<span class="math inline">\(\det
T\)</span>的唯一性,我们还应当确认的是我们可以将一个<span class="math inline">\(\dim V=n\)</span>的线性空间用某一个基打到<span class="math inline">\(F^n\)</span>后也不会有问题,从而引出矩阵的行列式的定义.综上,我们应当验证当以下图表是交换时:
$$ $$ 也即<span class="math inline">\(T&#39;=STS^{-1}\)</span>时<span class="math inline">\(\det T=\det
T&#39;\)</span>.那么这由行列式的乘法性质当然就可以予以说明.</p>
<p>综上就可以定义矩阵的行列式,我们称方阵<span class="math inline">\(A_{n\times
n}\)</span>的行列式是一个将其映射到标量的函数,记作<span class="math inline">\(\det(A)\)</span>或者<span class="math inline">\(|A|\)</span>.由于一般自然地将<span class="math inline">\(\text{End}(V)\cong M_{n\times
n}\)</span>,于是从上面的计算方式容易见到<span class="math inline">\(\det
A=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)\prod_{k=1}^na_{k,\sigma(k)}=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)\prod_{k=1}^na_{\sigma(k),k}\)</span>.</p>
<p>我们应当容易从上述过程中看出以下事实:</p>
<ol type="1">
<li><span class="math inline">\(\det A=\det A^T\)</span>.</li>
<li><span class="math inline">\(\det I_{n\times n}=1\)</span>.</li>
<li><span class="math inline">\(\det
A\)</span>可以看作列向量(或行向量)上的某种交错形式.</li>
<li>如果两个矩阵相似,那么它们的<span class="math inline">\(\det\)</span>相等.</li>
</ol>
<p>而由于行列式是某种交错形式,我们立即可以断言当对其作三种初等行变换的时候:</p>
<ol type="1">
<li>(倍加变换):行列式的值不变.</li>
<li>(对换变换):行列式的值取反.</li>
<li>(倍乘变换):行列式的值取相同倍数.</li>
</ol>
<p>说到这里要声明的某些事情是,我们应当将行列式看作某种交错形式,而并非将所有的交错形式都看作行列式.原因是交错形式一般带有单位,而行列式只是单纯的比例常数.例如我们用行列式求面积的时候,算的其实并不是面积,而是其相对于单位面积的比例常数.</p>
<h4><span id="余子式与代数余子式">余子式与代数余子式</span></h4>
<p>对于矩阵<span class="math inline">\(A\)</span>,<span class="math inline">\(A\)</span>的<strong>余子式</strong><span class="math inline">\(M_{i,j}\)</span>定义为<span class="math inline">\(A\)</span>去掉第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的矩阵的行列式.其中形如<span class="math inline">\(M_{i,i}\)</span>的余子式称为<strong>主余子式</strong>.</p>
<p>对于矩阵<span class="math inline">\(A\)</span>,其<strong>代数余子式</strong>(又称<strong>余因子</strong>)<span class="math inline">\(C_{i,j}=(-1)^{i+j}M_{i,j}\\\)</span>.</p>
<p>那么我们有一种计算行列式的方式是<strong>代数余子式展开</strong>:
<span class="math display">\[
\det A=\sum_{k=1}^na_{i,k}C_{i,k}=\sum_{k=1}^na_{k,j}C_{k,j}
\]</span></p>
<p>原因是<span class="math inline">\(\sigma(i)=j\)</span>的位置对逆序对的贡献的奇偶性等同于<span class="math inline">\(i+j\)</span>的奇偶性.每次我看这个结论都无法第一时间理解这个性质.但你可以考虑以<span class="math inline">\(\sigma(i)=j\)</span>作为分界线,然后发现此时怎么交换其它的部分,这个点的奇偶性贡献都是不变的.因此直接考虑在最普通的排列上挪一下,奇偶性就等价于<span class="math inline">\(i-j\)</span>的奇偶性了.</p>
<p>值得一提的是我们其实还有类似的公式,当<span class="math inline">\(i\ne
j\)</span>的时候: <span class="math display">\[
0=\sum_{k=1}^na_{i,k}C_{j,k}=\sum_{k=1}^na_{k,i}C_{k,j}
\]</span> 原因是直接定义一个矩阵<span class="math inline">\(B\)</span>使得<span class="math inline">\(B\)</span>的第<span class="math inline">\(j\)</span>行与<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行相等,其余行照搬<span class="math inline">\(A\)</span>,那么展开也是上面这个东西,而由于<span class="math inline">\(B\)</span>有两行相等,所以<span class="math inline">\(\det B=0\)</span>.</p>
<p>代数余子式构成的矩阵<span class="math inline">\(C=[C_{i,j}]\)</span>称为<strong>余子矩阵</strong>.其转置称为<strong>伴随矩阵</strong>,我们不妨将伴随矩阵直接记作<span class="math inline">\(\check A\)</span>,也有时记其为<span class="math inline">\(\text{adj}(A)\)</span>.</p>
<p>其满足<span class="math inline">\(A\check A=\check A A=(\det
A)I\)</span>.二者类似,只考虑证明前者:</p>
<p>考虑前者的第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列应该是<span class="math inline">\(\sum_{k}a_{i,k}C_{j,k}\)</span>,我们早在前面就证明过当<span class="math inline">\(i=j\)</span>的时候这个东西应当为<span class="math inline">\(\det A\)</span>,反之为<span class="math inline">\(0\)</span>.</p>
<p>由上面立刻得到推论为<span class="math inline">\(A^{-1}=\frac{\check
A}{\det A}\)</span>.</p>
<p>我们可能还希望去了解<span class="math inline">\(\check
A\)</span>的<span class="math inline">\(\text{rk}\)</span>与<span class="math inline">\(\det\)</span>.事实上我们给出以下若干命题:</p>
<ol type="1">
<li><span class="math inline">\(\det \check A=(\det
A)^{n-1}\)</span>.</li>
<li><span class="math inline">\(\text{rk}(\check
A)=\begin{cases}n&amp;\text{rk}\ A= n\\1&amp;\text{rk}\ A=
n-1\\0&amp;\text{rk}\ A&lt;n-1\end{cases}\)</span>.</li>
</ol>
<p>(1)无非是(2)的推论,下面只看(2).</p>
<p>(2)的话,由于<span class="math inline">\(\det A\ne 0\Rightarrow \det
\check A\ne 0\)</span>,所以当<span class="math inline">\(A\)</span>满秩的时候也很显然.</p>
<p>当<span class="math inline">\(\text {rk}\
A&lt;n-1\)</span>的时候,由于取出的所有余子式都线性相关,于是此时<span class="math inline">\(\check A\)</span>是<span class="math inline">\(0\)</span>矩阵.</p>
<p>当<span class="math inline">\(\text {rk}\
A=n-1\)</span>的时候,首先证明其<span class="math inline">\(\text rk\geq
1\)</span>,也就是只需证明至少存在一个余子式不为<span class="math inline">\(0\)</span>.取出<span class="math inline">\(n-1\)</span>个线性无关的列组成一个<span class="math inline">\(n\times
(n-1)\)</span>大小的矩阵.我们之前已经声明过其行秩等于列秩,这样就可以删去其中一行得到一个<span class="math inline">\((n-1)\times
(n-1)\)</span>的满秩矩阵,这个矩阵的行列式不为零.</p>
<p>于是其<span class="math inline">\(\text{rk}\geq
1\)</span>,我们又根据Frobenius秩不等式,知道考虑<span class="math inline">\(0=\text{rk}\ (AI\check A)\geq \text{rk}\
A+\text{rk}\ \check A-\text{rk}\ I\)</span>,于是<span class="math inline">\(\text{rk}\ \check A\leq 1\)</span>.</p>
<h4><span id="行列式定向">行列式定向</span></h4>
<p>我们知道我们用行列式求平行四边形面积的时候求的是所谓有向面积,问题在于这个方向具体是什么样子呢.</p>
<p>容易见得不同的基对应的矩阵行列式应当是相等的.但基的变换可能拥有不同的行列式.我们曾经研究过<span class="math inline">\(P_{\mathcal B\to\mathcal
B&#39;}\)</span>这个坐标变换矩阵的若干性质,而这个变换当然是同构的,所以这个矩阵行列式理应非零,那它就会天然带有正负的区别.我们定义一种基上的等价关系<span class="math inline">\(\sim\)</span>,或者称为<strong>同定向的</strong>.具体来说<span class="math inline">\(\mathcal B\sim \mathcal B&#39;\Leftrightarrow \det
P_{\mathcal B&#39;\to\mathcal
B}&gt;0\)</span>,由于行列式的乘法性质,立刻见到这将所有的基分为了两类.对于<span class="math inline">\(F^n\)</span>来说,我们一般将其标准基所在的那一类称为<strong>标准定向</strong>.这就是为什么我们求行列式的时候会出现正负的差别.</p>
<h4><span id="克拉默cramer法则">克拉默(Cramer)法则</span></h4>
<p>若<span class="math inline">\(A\)</span>可逆,用<span class="math inline">\(A_i(\vec{b})\)</span>表示将<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>列替换为<span class="math inline">\(\vec
b\)</span>后的矩阵,则<span class="math inline">\(A\vec x=\vec
b\)</span>的唯一解可由下式给出: <span class="math display">\[
x_i=\cfrac{\det A_i(\vec b)}{\det A}
\]</span> 证明:由于<span class="math inline">\(A\)</span>实际上可以看作线性映射不难发现<span class="math inline">\(A\times I_i(\vec x)=A_i(\vec
b)\)</span>,则根据行列式的乘法原理,有<span class="math inline">\((\det
A)(\det I_i(\vec x))=\det A_i(\vec b)\)</span>.而<span class="math inline">\(\det I_i(\vec x)=x_i\)</span>,于是该定理显然.</p>
<p>或者直接考虑<span class="math inline">\(\vec x=A^{-1}\vec
b=\frac{1}{\det A}\check A\vec b\)</span>,于是<span class="math inline">\(x_i=\frac{1}{\det
A}\sum_{k=1}^nC_{k,i}b_k\)</span>,后者刚好是<span class="math inline">\(A_i(\vec b)\)</span>沿第<span class="math inline">\(i\)</span>列作余子式展开后的结果.</p>
<p>值得一提的是,Cramer法则揭示了<span class="math inline">\(\det
=1\)</span>的环上的矩阵必有逆矩阵</p>
<h4><span id="一些特殊行列式">一些特殊行列式</span></h4>
<h5><span id="置换矩阵">置换矩阵</span></h5>
<p>对于一个置换<span class="math inline">\(\sigma\)</span>,我们记它的置换矩阵<span class="math inline">\(P_\sigma\)</span>满足<span class="math inline">\(P_{\sigma,i,j}=\begin{cases}1&amp;i=\sigma(j)\\0&amp;otherwise\end{cases}\)</span>,容易发现它对应了线性映射<span class="math inline">\(\vec e_j\mapsto \vec
e_{\sigma(j)}\)</span>.容易看出<span class="math inline">\(P_\sigma
P_\tau=P_{\sigma\tau}\)</span>并且<span class="math inline">\(P_{\sigma^{-1}}=(P_\sigma)^{-1}=(P_\sigma)^T\)</span>.容易由行列式理论得知<span class="math inline">\(|P_\sigma|=\text{sgn}(\sigma)\)</span>.</p>
<h5><span id="上三角矩阵">上三角矩阵</span></h5>
<p>用代数余子式展开立刻见到上三角矩阵的行列式就是其对角线的乘积.用高斯消元法更快立刻.</p>
<h5><span id="分块上三角矩阵">分块上三角矩阵</span></h5>
<p>也即<span class="math inline">\(\left|\begin{matrix}A_{1,1}&amp;\cdots&amp;\cdots\\0&amp;\ddots&amp;\vdots\\0&amp;0&amp;A_{n,n}\end{matrix}\right|=\prod_{i=1}^n\det
A_{i,i}\)</span>.</p>
<p>证明考虑数学归纳,先把左上角那一坨变成一个分块矩阵,那我们只需要证明<span class="math inline">\(\left|\begin{matrix}A_{1,1}&amp;A_{1,2}\\0&amp;A_{2,2}\end{matrix}\right|=\det
A_{1,1}\det A_{2,2}\)</span>.</p>
<p>这个怎么证明呢?考虑直接套定义,我们知道行列式的定义是:<span class="math inline">\(\det A=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)\prod_{k=1}^na_{k,\sigma(k)}\)</span>,此时意识到如果<span class="math inline">\(k&gt;n_1,\sigma(k)\leq n_1\)</span>那么此时<span class="math inline">\(a_{k,\sigma(k)}=0\)</span>,所以这个<span class="math inline">\(\sigma\)</span>应当分为两部分,一部分是<span class="math inline">\([1,n_1]\)</span>部分内部交换,另一部分是<span class="math inline">\([n_1+1,n_1+n_2]\)</span>内部交换,这样我们把<span class="math inline">\(\sigma=\sigma_1\sigma_2\)</span>,上述表达式变为:
<span class="math display">\[
\det A=\sum_{\sigma\in
S_n}\text{sgn}(\sigma_1)\prod_{k=1}^{n_1}a_{k,\sigma_1(k)}\text{sgn}(\sigma_2)\prod_{k=n_1+1}^{n_1+n_2}a_{k,\sigma_2(k)}\\
=\det A_{1,1}\det A_{2,2}
\]</span></p>
<h5><span id="范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</span></h5>
<p>即<span class="math inline">\(\left|\begin{matrix}1&amp;\cdots&amp;1\\x_1&amp;\cdots&amp;x_n\\\vdots&amp;&amp;\vdots\\x_1^{n-1}&amp;\cdots&amp;x_n^{n-1}\end{matrix}\right|=\prod_{1\leq
i&lt;j\leq n}(x_j-x_i)\)</span>.</p>
<p>这个怎么求呢?我们先逐个消第一列(先用第<span class="math inline">\(n-1\)</span>行消第<span class="math inline">\(n\)</span>行,再用第<span class="math inline">\(n-2\)</span>行消第<span class="math inline">\(n-1\)</span>行,以此类推),我们得到的就是以下行列式:
<span class="math display">\[
\left|\begin{matrix}1&amp;1&amp;\cdots&amp;1\\0&amp;x_2-x_1&amp;\cdots&amp;x_n-x_1\\0&amp;\vdots&amp;&amp;\vdots\\0&amp;x_2^{n-1}-x_1x_2^{n-2}&amp;\cdots&amp;x_n^{n-1}-x_1x_n^{n-2}\end{matrix}\right|
\]</span> 对这个的第一列作代数余子式展开,知道它应当等于: <span class="math display">\[
\left|\begin{matrix}x_2-x_1&amp;\cdots&amp;x_n-x_1\\\vdots&amp;&amp;\vdots\\x_2^{n-1}-x_1x_2^{n-2}&amp;\cdots&amp;x_n^{n-1}-x_1x_n^{n-2}\end{matrix}\right|\\=\left|\begin{matrix}1&amp;\cdots&amp;1\\\vdots&amp;&amp;\vdots\\x_2^{n-2}&amp;\cdots&amp;x_n^{n-2}\end{matrix}\right|\prod_{1&lt;j\leq
n}(x_j-x_1)
\]</span> 然后数学归纳就证完了.</p>
<h5><span id="一类分块矩阵">一类分块矩阵</span></h5>
<p>考虑<span class="math inline">\(\left|\begin{matrix}I&amp;B\\A&amp;I\end{matrix}\right|=\det
(I-AB)\)</span>.此时观测其对基的作用,注意到其和<span class="math inline">\(\begin{bmatrix}I&amp;A\\B&amp;I\end{bmatrix}\)</span>无非是在不同基下的同种线性映射,于是<span class="math inline">\(\det(I-AB)=\det (I-BA)\)</span>.</p>
<h4><span id="特征多项式">特征多项式</span></h4>
<p>自映射<span class="math inline">\(T=\text{End}(V)\)</span>本身作为一个定义了乘法和加法的元素,理应可以嵌入多项式结构中.因此不妨定义多项式<span class="math inline">\(f(T)=\sum_{k=0}^ma_kT^k\)</span>.</p>
<p>此时设<span class="math inline">\(\dim V=n\)</span>有限,那么<span class="math inline">\(\dim T=n^2\)</span>,考虑以下<span class="math inline">\(n^2+1\)</span>个此空间上的向量<span class="math inline">\(T^0,\ldots,T^{n^2}\)</span>,它们必定线性相关,也就是存在一组不全为<span class="math inline">\(0\)</span>的<span class="math inline">\(\{c_k\}\)</span>使得<span class="math inline">\(f(T)=\sum_{k=0}^{n^2}c_kT^k=0\)</span>.</p>
<p>如果<span class="math inline">\(T\)</span>可逆,那我们考虑可以取一个满足上述条件的<span class="math inline">\(f\)</span>使得<span class="math inline">\(c_0\ne
0\)</span>,原因是可以不断两边除去<span class="math inline">\(T\)</span>.那最终就会拿到<span class="math inline">\(c_0\text{id}+\sum_{k=1}^mc_kT^k=0\)</span>,对此式子再简单处理可知以下结论:对于一个可逆的<span class="math inline">\(T\)</span>,存在一个多项式<span class="math inline">\(g(T)\)</span>使得<span class="math inline">\(T^{-1}=g(T)=-\frac{1}{c_0}\sum_{k=1}^{m}c_kT^{k-1}\)</span>.并且注意到<span class="math inline">\(\deg g(T)\leq n^2\)</span>.</p>
<p>将此定义挪到矩阵上,定义其特征多项式<span class="math inline">\(\text{char}_A(x)=\det(xI-A)\)</span>.由定义立刻得知<span class="math inline">\(\text{char}_A(x)=\sum_{\sigma}\text{sgn}(\sigma)\prod_{i=1}^n([i=\sigma(i)]x-a_{i,\sigma(i)})\)</span>.于是容易发现<span class="math inline">\(\text{char}_A(0)=(-1)^n\det
A\)</span>.并且这个多项式应该首项为<span class="math inline">\(1\)</span>.</p>
<p>容易观察到相似的矩阵应当有相同的特征多项式,原因是<span class="math inline">\(\det
(xI-A)=\det(P^{-1}(xI-B)P)=\det(xI-B)\)</span>.这意味着其和基的选取无关,因此特征多项式可以拓展到一般的线性映射上.</p>
<p>另外转置不影响特征多项式的取值,原因是转置也不影响<span class="math inline">\(\det\)</span>的取值.</p>
<p>分块上三角矩阵的特征多项式就是对角线矩阵特征多项式的乘积.</p>
<p>我们还可以有以下性质:当<span class="math inline">\(A\in M_{m\times
n},B\in M_{n\times m}\)</span>,则<span class="math inline">\(\cfrac{\text{char}_{AB}}{x^m}=\cfrac{\text{char}_{BA}}{x^n}\)</span>.</p>
<p>原因是考虑: <span class="math display">\[
x^{-m}\text{char}_{AB}\\=x^{-m}\det(xI-AB)\\=\det(I-x^{-1}AB)\\=\det(I-x^{-1}BA)\\=x^{-n}\text{char}_{BA}
\]</span> 原因是我们已经证明过了<span class="math inline">\(\det
(I-AB)=\det (I-BA)\)</span>.</p>
<p>仅仅如此当然不够好用,然而注意到如果<span class="math inline">\(AB\)</span>以<span class="math inline">\(\lambda_0\ne 0\)</span>为特征值的特征向量是<span class="math inline">\(\vec v\)</span>,那么<span class="math inline">\(BA\)</span>以<span class="math inline">\(\lambda_0\)</span>为特征值的特征向量就是<span class="math inline">\(B\vec v\)</span></p>
<p>应当研究伴随矩阵在特征多项式下的情形,事实上有以下定理:如果<span class="math inline">\(\text{char}_A=\sum_{k=0}^nc_kx^k\)</span>,那么<span class="math inline">\((-1)^{n-1}\check
A=\sum_{k=1}^nc_{k}A^{k-1}\)</span>.</p>
<p>考虑证明以上定理,考虑<span class="math inline">\(\text{adj}(xI-A)\)</span>的每一个元素都是一个次数<span class="math inline">\(\leq n-1\)</span>的多项式,对其进行分解得到<span class="math inline">\(\text{adj}(xI-A)=\sum_{k=0}^{n-1}x^kD_k\)</span>,其中<span class="math inline">\(D_k\)</span>是一个矩阵,代表不同位置<span class="math inline">\(x^k\)</span>前的系数.</p>
<p>而我们知道<span class="math inline">\(\text{char}_A(x)I=(xI-A)\times
\text{adj}(xI-A)=(xI-A)\sum_{k=0}^{n-1}x^kD_k\)</span>.</p>
<p>两边提取系数,于是: <span class="math display">\[
c_nI=D_{n-1}\\
c_{n-1}I=-AD_{n-1}+D_{n-2}\\
c_{n-2}I=-AD_{n-2}+D_{n-3}\\
\cdots
\]</span> 将上面这些若干式子右边乘以<span class="math inline">\(A^{k}\)</span>并相加就可以做到相消,得到<span class="math inline">\(D_0=\sum_{k=1}^nc_{k}A^{k-1}\)</span>,而<span class="math inline">\(D_0\)</span>按照定义就是<span class="math inline">\(\text{adj}(0I-A)=(-1)^{n-1}\check A\)</span>.</p>
<p>根据上述定理有以下结论:</p>
<ol type="1">
<li><span class="math inline">\((A^\vee)^T=(A^T)^\vee\)</span>.</li>
<li><span class="math inline">\(\text{adj}{(P^{-1}AP)}=P^{-1}\check
AP\)</span>.</li>
</ol>
<p>另外,如果<span class="math inline">\(\text{char}_A=\sum_{k=0}^nc_kx^k\)</span>,那么<span class="math inline">\(\text{char}_{A^{-1}}=\sum_{k=0}^n\frac{c_k}{c_0}x^{n-k}\)</span>.</p>
<p>原因是观察到<span class="math inline">\((-1)^nc_0\times
\text{char}_{A^{-1}}=\det A\times
\det(xI-A^{-1})=(-x)^n\det(x^{-1}I-A)\)</span>.</p>
<h4><span id="cayley-hamilton定理">Cayley-Hamilton定理</span></h4>
<p>即:<span class="math inline">\(\text{char}_A(A)=0\)</span>.</p>
<p>原因是根据上述定理,由于<span class="math inline">\(c_0=(-1)^n\det
A\)</span>,我们有: <span class="math display">\[
\sum_{k=0}^nc_kA^k=((-1)^n\det A)\times
I+A\sum_{k=1}^nc_kA^{k-1}\\=((-1)^n\det A)\times
I+(-1)^{n-1}A\check{A}\\=0
\]</span></p>
<h4><span id="矩阵的迹">矩阵的迹</span></h4>
<p>定义<span class="math inline">\(A\in M_{n\times
n}(F)\)</span>的<strong>迹</strong><span class="math inline">\(\text{tr}\ A=\sum
_{i=1}^na_{i,i}\)</span>.显然<span class="math inline">\(tr(A+B)=tr(A)+tr(B)\)</span>.容易验证<span class="math inline">\(tr:M_{n\times n}(F)\to
F\)</span>是线性映射,并且<span class="math inline">\(\forall A\in
M_{n\times m}(F),B\in M_{m\times n}(F)\)</span>有<span class="math inline">\(tr(AB)=tr(BA)\)</span>.</p>
<p>于是共轭的矩阵有相同的迹,原因是<span class="math inline">\(tr(P^{-1}AP)=tr(APP^{-1})=tr(A)\)</span>.这应当意味着迹这个东西有一些更好的性质.事实上,迹的等价定义是<span class="math inline">\(tr(A)=-[x^{n-1}]\text{char}_A\)</span>,原因是<span class="math inline">\(\text{char}_A(x)=\sum_{\sigma}\text{sgn}(\sigma)\prod_{i=1}^n([i=\sigma(i)]x-a_{i,\sigma(i)})\)</span>,从这里立刻看出只有恒等映射<span class="math inline">\(\sigma=\text{id}\)</span>的时候才会对<span class="math inline">\([x^{n-1}]\)</span>产生贡献.</p>
<h6><span id="example">Example</span></h6>
<p>证明:如果<span class="math inline">\(tr(A)=0\)</span>,而且域的特征<span class="math inline">\(\text{char}\ F=0\)</span>,那么存在<span class="math inline">\(A&#39;=PAP^{-1}\)</span>使得<span class="math inline">\(\forall i\in [1,n],a&#39;_{i,i}=0\)</span>.</p>
<p>如果<span class="math inline">\(A=0\)</span>就下班了对吧,如果<span class="math inline">\(A\ne 0\)</span>,我们下面来数学归纳证明.假设<span class="math inline">\(&lt;n\)</span>的时候已经得证.</p>
<p>首先我们说明:如果对于所有的<span class="math inline">\(\vec v\in
F^n\)</span>都存在<span class="math inline">\(c_v\in F\)</span>使得<span class="math inline">\(A\vec v=c_v\vec v\)</span>,那么存在<span class="math inline">\(c\in F\)</span>使得<span class="math inline">\(A=cI\)</span>.</p>
<p>考虑线性无关的两个向量<span class="math inline">\(\vec v,\vec
w\)</span>,如果<span class="math inline">\(c_v\ne c_w\)</span>,考虑<span class="math inline">\(c_v\vec v+c_w\vec w=A(\vec v+\vec w)=c_{v+w}(\vec
v+\vec w)\)</span>,于是自然导出<span class="math inline">\(c_v=c_{v+w}=c_w\)</span>,矛盾.于是上述命题成立.</p>
<p>对于一个<span class="math inline">\(tr(A)=0\)</span>的矩阵当然不是<span class="math inline">\(cI\)</span>的形式,那我们就可以找到一个<span class="math inline">\(\vec v\)</span>使得<span class="math inline">\(A\vec v\ne c\vec v\)</span>,于是<span class="math inline">\(A\vec v\)</span>和<span class="math inline">\(\vec
v\)</span>线性无关.此时考虑将其扩充为一个基<span class="math inline">\(\{\vec v,A\vec v,\vec v_3,\cdots,\vec
v_n\}\)</span>,考虑当然存在一个<span class="math inline">\(C\)</span>使得<span class="math inline">\(C=P_1^{-1}AP_1\)</span>这样<span class="math inline">\(C\)</span>是对上述基的作用.那我们考虑<span class="math inline">\(C(\vec v)=A\vec v\)</span>,于是<span class="math inline">\(C\)</span>应当形如: <span class="math display">\[
\begin{bmatrix}
0&amp;\cdots\\
1&amp;\vdots\\
0&amp;\vdots\\
\vdots&amp;\vdots
\end{bmatrix}
\]</span> 不妨设<span class="math inline">\(C=\begin{bmatrix}0&amp;T\\L&amp;B\end{bmatrix}\)</span>,我们知道根据归纳假设,对于<span class="math inline">\(B\)</span>来说存在一个<span class="math inline">\(P_2\)</span>使得<span class="math inline">\(P_2^{-1}BP_2\)</span>的对角线全零,那我们考虑:
<span class="math display">\[
\begin{bmatrix}1&amp;0\\0&amp;P_2^{-1}\end{bmatrix}\begin{bmatrix}0&amp;T\\L&amp;B\end{bmatrix}\begin{bmatrix}1&amp;0\\0&amp;P_2\end{bmatrix}=\begin{bmatrix}0&amp;\_\\\_&amp;P_2^{-1}BP_2\end{bmatrix}
\]</span> 这样就做完了.</p>
<h4><span id="binet-cauchy定理">Binet-Cauchy定理</span></h4>
<p>定义大小分别为<span class="math inline">\(n\times m\)</span>和<span class="math inline">\(m\times n\)</span>(其中<span class="math inline">\(n\leq m\)</span>)的矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,令<span class="math inline">\(A[S]\)</span>表示矩阵<span class="math inline">\(A\)</span>只取<span class="math inline">\(S\)</span>集合中的列所形成的矩阵,<span class="math inline">\(B[S]\)</span>表示矩阵<span class="math inline">\(B\)</span>只取<span class="math inline">\(S\)</span>集合中的行所形成的矩阵,则有: <span class="math display">\[
\det(AB)=\sum_{S\subseteq\{1,2,...,m\},|S|=n}(\det(A[S]))(\det(B[S]))
\]</span> 下面设<span class="math inline">\(\lambda(P)\)</span>为排列<span class="math inline">\(P\)</span>的逆序对数.</p>
<p><span class="math display">\[
\sum_{S\subseteq\{1,2,...,m\},|S|=n}(\det(A[S]))(\det(B[S]))\\
=\sum_{S\subseteq\{1,2,...,m\},|S|=n}(\sum_{P}(-1)^{\lambda(P)}\prod_{i=1}^nA_{i,S_{P_i}})(\sum_{Q}(-1)^{\lambda(Q)}\prod_{i=1}^nB_{S_i,Q_i})\\
=\sum_{S\subseteq\{1,2,...,m\},|S|=n}\sum_{P}\sum_{Q}(-1)^{\lambda(P)+\lambda(Q)}\prod_{i=1}^nA_{i,S_{P_i}}B_{S_i,Q_i}
\]</span> 若让<span class="math inline">\(R\)</span>为可重集合,换言之让其取遍<span class="math inline">\(m^n\)</span>种情况,又有: <span class="math display">\[
\det(AB)=\sum_{P}(-1)^{\lambda(P)}\prod_{i=1}^n(\sum_{j=1}^mA_{i,j}B_{j,P_i})\\
=\sum_{P}(-1)^{\lambda(P)}\sum_{R,\forall
i,R_i\in[1,m]}(\prod_{i=1}^nA_{i,R_i}B_{R_i,P_i})\\
=\sum_{R,\forall
i,R_i\in[1,m]}\sum_P(-1)^{\lambda(P)}(\prod_{i=1}^nA_{i,R_i})(\prod_{i=1}^nB_{R_i,P_i})
\]</span> 如果<span class="math inline">\(\exists 1\leq i,j\leq n,i\ne
j\)</span>,<span class="math inline">\(R_i=R_j\)</span>,则交换<span class="math inline">\(P_i,P_j\)</span>后,后面的值仍然不变,可逆序对的奇偶性改变了.如果我们对于每一个重复序列都选取最靠前的一对,那么显然只有<span class="math inline">\(R\)</span>不重的情况才有可能产生贡献.既然如此,<span class="math inline">\(R\)</span>的生成方式就应该是先顺序取子集再用一个排列打乱顺序.</p>
<p>所以我们有: <span class="math display">\[
\det(AB)
=\sum_{S\subseteq\{1,2,...,m\},|S|=n}\sum_{Q}\sum_{P}(-1)^{\lambda(P)}(\prod_{i=1}^nA_{i,S_{Q_i}})(\prod_{i=1}^nB_{S_{Q_i},P_i})\\
=\sum_{S\subseteq\{1,2,...,m\},|S|=n}\sum_{Q}\sum_{P_{Q&#39;}}(-1)^{\lambda(P_{Q&#39;})}(\prod_{i=1}^nA_{i,S_{Q_i}})(\prod_{i=1}^nB_{S_i,P_{Q&#39;_i}})\\
=\sum_{S\subseteq\{1,2,...,m\},|S|=n}\sum_{Q}\sum_{P_{Q&#39;}}(-1)^{\lambda(P)+\lambda(Q)}(\prod_{i=1}^nA_{i,S_{Q_i}})(\prod_{i=1}^nB_{S_i,P_{Q&#39;_i}})\\
\]</span> 左右显然相等.</p>
<p>另外,这个定理有更简单的证明方法,即使用LGV引理与组合意义证明.</p>
<p>不妨设现在有个点的集合<span class="math inline">\(A,B,C\)</span>,现在想求出<span class="math inline">\(A\rightarrow B\rightarrow
C\)</span>的不交路径的奇偶数量差,会发现左右的组合意义是相等的.</p>
<p>于此之外,还有一个纯代数的证明策略,不妨定义符号<span class="math inline">\(A\binom{I}{J}=A\binom{i_1,\cdots,i_r}{j_1,\cdots,j_s}\)</span>表示提取下标集<span class="math inline">\(I\)</span>和<span class="math inline">\(J\)</span>分别作为行列得到的矩阵.</p>
<p>先证明一个引理:<span class="math inline">\(C\in M_{n\times
n},[x^{n-k}]\det(xI+C)=\sum_{I\in \{1,\cdots,n\},|I|=k}\det
C\binom{I}{I}\)</span>.</p>
<p>回忆到运算符<span class="math inline">\(\delta_{i,j}=[i=j]\)</span>,应当注意到:<span class="math inline">\(\det(xI+C)=\sum_{\sigma}\text{sgn}(\sigma)\prod_{i=1}^n(x
[i=j]+c_{i,\sigma(i)})\)</span>,此时要想凑出<span class="math inline">\(x^{n-k}\)</span>,就需要有<span class="math inline">\(n-k\)</span>个位置被卡死,而剩下的部分无非是提取剩下<span class="math inline">\(k\)</span>行<span class="math inline">\(k\)</span>列后的结果.就可以见到上述引理无非定义的平凡推论.</p>
<p>然后开始证明该定理,回忆到我们已经证明过<span class="math inline">\(x^{m-n}\det(xI+AB)=\det(xI+BA)\)</span>.此时对左右两边取<span class="math inline">\([x^{m-n}]\)</span>,左边取出了<span class="math inline">\(\det(xI+AB)\)</span>的常数项,亦即<span class="math inline">\(\det(AB)\)</span>.而右边,按上述引理得知得到了<span class="math inline">\(\sum_{I\in \{1,\cdots,n\},|I|=k}\det
\left((BA)\binom{I}{I}\right)\)</span>,而这恰为原本右式的矩阵乘法定义.</p>
<p>由该定理得知,对于<span class="math inline">\(A\in M_{m\times
n}\)</span>,<span class="math inline">\(\det {A^TA}\geq 0\)</span>.</p>
<h4><span id="特征值与特征向量">特征值与特征向量</span></h4>
<p>我们之前应当已经见到,如果一个矩阵是分块对角矩阵,那这个矩阵应当相当容易处理,原因是其加减乘运算无非只是在对角线上的适当操作而已.这引发我们选取适当的直和分解<span class="math inline">\(V=\bigoplus
V_k\)</span>将原本的矩阵化为合适的分块对角矩阵.</p>
<p>然而如果我们想要拿到具体的矩阵就不可避免地需要选基,因此在固定的基意义下,我们对于一个矩阵<span class="math inline">\(A\)</span>,应当思考能否通过换基操作使得<span class="math inline">\(A=P^{-1}BP\)</span>,其中<span class="math inline">\(B\)</span>是一个分块对角矩阵,那此时<span class="math inline">\(A\)</span>也拥有相当好的性质.</p>
<p>考虑最简单的情况,即每个分块都是单个元素的情况,此时该矩阵应当就是一个对角矩阵.这相当于选定一组基<span class="math inline">\(\{\vec v_1,\cdots,\vec v_n\}\)</span>后,取<span class="math inline">\(V_k=\text{span}\{\vec v_k\}\)</span>并将这些<span class="math inline">\(V_k\)</span>取直和得到<span class="math inline">\(V\)</span>,此时该线性映射应当给出<span class="math inline">\(T\vec v_k=\lambda_k\vec
v_k\)</span>,即只能做一个伸缩变换.更一般地,设<span class="math inline">\(P\)</span>就是这种基的变换,它理应给出<span class="math inline">\(\vec v_k=P\vec e_k\)</span>.那么在标准基下的<span class="math inline">\(D\)</span>和在这一组新基下的<span class="math inline">\(A\)</span>就应当给出<span class="math inline">\(A\vec v_k=AP\vec e_k=PD\vec e_k=\lambda_k\vec
v_k\)</span>.上面的种种操作都引诱我们去思考能否进行以上操作,这就引入下面的定义:</p>
<p>设<span class="math inline">\(T\in \text{End}(V)\)</span>并且<span class="math inline">\(\lambda\in F\)</span>,我们引入如下定义:</p>
<ol type="1">
<li>称子空间<span class="math inline">\(V_\lambda=\ker (\lambda
\times\text{id}_V-T)\)</span>为<span class="math inline">\(T\)</span>的<span class="math inline">\(\lambda\)</span><strong>特征子空间</strong>,若<span class="math inline">\(V_\lambda\ne \{0\}\)</span>,则称<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(T\)</span>的<strong>特征值</strong>.</li>
<li>对于<span class="math inline">\(\vec v\in
V_\lambda\)</span>,换言之<span class="math inline">\(T\vec v=\lambda
\vec v\)</span>,而且<span class="math inline">\(\vec v\ne
0\)</span>,则称<span class="math inline">\(\vec v\)</span>是<span class="math inline">\(T\)</span>的一个<strong>特征向量</strong>,以<span class="math inline">\(\lambda\)</span>为特征值.</li>
</ol>
<p>考虑特征值的定义等价于<span class="math inline">\(\det (\lambda\times
I-T)=0\)</span>,于是等价于<span class="math inline">\(\text{char}_T(\lambda)=0\)</span>.立刻见到一个<span class="math inline">\(\lambda\)</span>是特征值等价于其是<span class="math inline">\(\text{char}_T=0\)</span>的一个根.反之,<span class="math inline">\(\text{char}_T=0\)</span>的一个根也一定对应了一个非空的特征子空间,也就对应了一组非零特征向量.如果<span class="math inline">\(T\)</span>分裂,见到行列式其实是特征值的乘积,而迹实际上是特征值的加和.应当见到,一个矩阵可逆等价于其不存在<span class="math inline">\(0\)</span>特征值.</p>
<p>考虑对角化,如果我们能在上面取出若干<span class="math inline">\(\vec
v\)</span>组成一组基,那直接用这组基就可以把<span class="math inline">\(T\)</span>拆成在这组基上的伸缩变换,这样就实现了对角化.因此如果我们能取出一组基使得每一个基对<span class="math inline">\(A\)</span>都是特征向量,我们称<span class="math inline">\(A\)</span>是<strong>可对角化的</strong>.立刻见到可对角化的必要条件是<span class="math inline">\(\text{char}_A\)</span>分裂.</p>
<p>如果<span class="math inline">\(T\)</span>可对角化,我们有<span class="math inline">\(\dim V_\lambda=d\)</span>,其中<span class="math inline">\(d\)</span>是<span class="math inline">\(\lambda\)</span>作为特征多项式的根的重数.如果其可对角化,直接按上述方式取基得到<span class="math inline">\(z\)</span>,并且<span class="math inline">\(PTP^{-1}\)</span>就是在标准基下的变换矩阵.那么直接考虑<span class="math inline">\(\text{rk}(\lambda_n I-T)=n-d\)</span>,其中<span class="math inline">\(d\)</span>是<span class="math inline">\(\lambda_n\)</span>的重数.用同态基本定理立刻得到<span class="math inline">\(V_{\lambda_n}=d\)</span>.(注意这里都是在讨论可对角化的前提下)</p>
<p>我们希望能把<span class="math inline">\(V_{\lambda_k}\)</span>给做直和,那我们就需要做前置工作.具体而言,我们需要证明选取<span class="math inline">\(\vec v_k\in V_{\lambda_k}\)</span>,那么<span class="math inline">\(\sum \vec v_k=\vec 0\Leftrightarrow \forall k,\vec
v_k=\vec 0\)</span>.使用数学归纳,注意到<span class="math inline">\(T(\sum \vec v_k)=\sum \lambda_k\vec
v_k=0\)</span>,又知道<span class="math inline">\(\lambda_1\sum \vec
v_k=0\)</span>,两者一消就可以进行数学归纳.</p>
<p>由上面的过程得知下述命题等价:</p>
<ol type="1">
<li><span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可对角化.</li>
<li><span class="math inline">\(\sum_{\lambda\in F}\dim V_{\lambda}=\dim
V\)</span>.</li>
<li><span class="math inline">\(\bigoplus _{\lambda\in
F}V_\lambda=V\)</span>.</li>
</ol>
<p>其推论是如果所有的<span class="math inline">\(\lambda_k\)</span>互不相同,那么<span class="math inline">\(\dim V_{\lambda_k}\geq 1\)</span>,这必然给出<span class="math inline">\(T\)</span>可对角化.这似乎告诉我们去除重数有某种很好的性质.</p>
<h4><span id="极小多项式">极小多项式</span></h4>
<p>考虑对于一个多项式<span class="math inline">\(h\in
F[x]\)</span>,当我们将<span class="math inline">\(T\in
\text{End}(V)\)</span>带入之后当然会得到一个<span class="math inline">\(h(T)\in \text{End}(V)\)</span>,现在固定<span class="math inline">\(h,T\)</span>,以此构造一个子空间<span class="math inline">\(V[h]=\ker (h(T))=\{\vec v\in V|h(T)\vec
v=0\}\)</span>.</p>
<p>此时注意到<span class="math inline">\(T(V[h])\subseteq
V[h]\)</span>,原因是<span class="math inline">\(T\)</span>与自身交换,于是<span class="math inline">\(\forall \vec v\in V[h]\)</span>,应当有<span class="math inline">\(h(T)(T\vec v)=Th(T)\vec v=T(\vec 0)=\vec
0\)</span>,这意味着<span class="math inline">\(T\vec v\in
V[h]\)</span>.于是可见到<span class="math inline">\(V[h]\)</span>实际上是一个<span class="math inline">\(T\)</span>不变子空间.</p>
<p>取<span class="math inline">\(h=x-\lambda I\)</span>,那么<span class="math inline">\(V[h]\)</span>其实就是我们上述所说的<span class="math inline">\(V_\lambda\)</span>,因此<span class="math inline">\(V_\lambda\)</span>也是<span class="math inline">\(T\)</span>不变的.从这里立刻能看出些什么,比如当<span class="math inline">\(\dim V_\lambda=1\)</span>的时候,<span class="math inline">\(T\)</span>不变当然意味着伸缩变换.</p>
<p>那我们既然需要这个东西用在<span class="math inline">\(V_\lambda\)</span>上,首要要做的当然是分析在其上面的直和分解.换言之,我们下面试图证明如下引理(核引理):<span class="math inline">\(f\bot g\)</span>的时候,<span class="math inline">\(V[fg]=V[gf]=V[f]\oplus V[g]\)</span>.</p>
<p>原因是考虑<span class="math inline">\(F[x]\)</span>的主理想性引出其裴蜀定理,那么就存在多项式<span class="math inline">\(a,b\)</span>使得<span class="math inline">\(af+bg=1\)</span>.此时<span class="math inline">\(\vec v=(af+bg)(T)\vec v=a(T)(f(T)\vec
v)+b(T)(g(T)\vec v)\)</span>.注意到如果<span class="math inline">\(\vec
v\in V[fg]\)</span>,那么<span class="math inline">\(f(T)\vec v\in
V[g],g(T)\vec v\in V[f]\)</span>,而<span class="math inline">\(V[g]\)</span>和<span class="math inline">\(V[f]\)</span>对<span class="math inline">\(a(T)\)</span>和<span class="math inline">\(b(T)\)</span>都是不变子空间,原因是它们对<span class="math inline">\(T\)</span>都是不变子空间,这必然意味着<span class="math inline">\(a(T)(f(T)\vec v)\in
V[g]\)</span>,后者亦然同理.这意味着<span class="math inline">\(V[fg]\subseteq V[f]+V[g]\)</span>,而<span class="math inline">\(V[f]\subseteq
V[fg],V[g]\subseteq  V[fg]\)</span>,这立刻得到<span class="math inline">\(V[fg]=V[f]+V[g]\)</span>.此时检查<span class="math inline">\(\vec v\in V[g]\cap V[f]\)</span>,发现<span class="math inline">\(\vec v=(af+bg)(T)\vec v=\vec
0\)</span>,这就意味着<span class="math inline">\(V[fg]=V[f]\oplus
V[g]\)</span>.</p>
<p>考虑<span class="math inline">\(I=\{f\in
F[x]|f(T)=0_V\}\)</span>,容易见到其应当也有某种<span class="math inline">\(\ker\)</span>的性质,事实上可以证明它是一个理想,原因是当然满足加法和乘法的封闭律.而由于<span class="math inline">\(F[x]\)</span>是一个主理想环,那么上面就应当存在一个<span class="math inline">\(\deg\)</span>极小的<span class="math inline">\(h\)</span>,使得<span class="math inline">\(I=(h)\)</span>,不妨将<span class="math inline">\(h\)</span>规范化为首一的多项式.那么以上操作给出:<span class="math inline">\(f(T)=0\Leftrightarrow h|f\)</span>.</p>
<p>由Cayley-Hamilton定理,当维度有限的时候,这样的多项式必然存在,这就意味着<span class="math inline">\(I\ne \{0\}\)</span>,此时我们就把上面的这个<span class="math inline">\(h\)</span>叫做<span class="math inline">\(T\)</span>的<strong>极小多项式</strong><span class="math inline">\(\text{Min}_T\)</span>.</p>
<p>值得一提的是如果<span class="math inline">\(A\)</span>是在<span class="math inline">\(F\)</span>上的矩阵,其极小多项式为<span class="math inline">\(\text{Min}_{A,F}\)</span>,<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域,<span class="math inline">\(A\)</span>在<span class="math inline">\(E\)</span>上的极小多项式为<span class="math inline">\(\text{Min}_{A,E}\)</span>,则<span class="math inline">\(\text{Min}_{A,F}=\text{Min}_{A,E}\)</span>.原因是首先<span class="math inline">\(\text{Min}_{A,E}|\text{Min}_{A,F}\)</span>,于是<span class="math inline">\(\text{Min}_{A,E}=\text{Min}_{A,F}\)</span>等价于<span class="math inline">\(A^0,\cdots,A^{d-1}\)</span>线性无关,其中<span class="math inline">\(d=\deg
\text{Min}_{A,F}\)</span>.而判定线性无关实际上是用高斯消元判定的,和域的选取无关.</p>
<p>用一次Cayley-Hamilton定理,知道<span class="math inline">\(\text{Min}_T|\text{char}_T\)</span>.既然如此,<span class="math inline">\(\text{Min}_T\)</span>保留了<span class="math inline">\(\text{char}_T\)</span>的哪些具体性质呢?它们之间的关系又如何呢?我们下面尝试证明:如果<span class="math inline">\(\lambda\)</span>是<span class="math inline">\(T\)</span>的特征值,当且仅当<span class="math inline">\(\text{Min}_T(\lambda)=0\)</span>.</p>
<p>充分性显然,因为我们已经声明了只要是<span class="math inline">\(\text{char}_T\)</span>的一个根就自动是特征值.</p>
<p>下面证明必要性:注意到如果<span class="math inline">\(\lambda\)</span>是特征值,此时<span class="math inline">\(\vec 0=\text{Min}_T(T)\vec
v=\text{Min}_T(\lambda)\vec v\)</span>,原因是观察到如果<span class="math inline">\(T\vec v=\lambda\vec v\)</span>,那么立刻得到<span class="math inline">\(f(T)\vec v=f(\lambda)\vec
v\)</span>.于是立刻得到<span class="math inline">\(\text{Min}_T(\lambda)=0\)</span>.</p>
<p>此时见到端倪,我们再证明以下定理:</p>
<p>对于固定的<span class="math inline">\(T\in
\text{End}(V)\)</span>如果有直和分解<span class="math inline">\(V=\bigoplus V_k\)</span>,其中每个<span class="math inline">\(V_k\)</span>都是<span class="math inline">\(T\)</span>不变子空间,那么就可以把<span class="math inline">\(T\)</span>限制到相应的<span class="math inline">\(V_k\)</span>空间内,记作<span class="math inline">\(T|_{V_k}\in
\text{End}(V_k)\)</span>,那在这些空间内部自然有它们自己的极小多项式<span class="math inline">\(\text{Min}_{T_k}\)</span>,我们断言<span class="math inline">\(\text{Min}_T=\text{lcm}_k(\text{Min}_{T_k})\)</span>.原因是由于直和的性质,<span class="math inline">\(f(T)=\vec 0\)</span>当且仅当对于每一个<span class="math inline">\(k\)</span>,<span class="math inline">\(f(T_{k})=0\)</span>,应用极小多项式的定义立刻见到上述结论显然.</p>
<p>对于<span class="math inline">\(T\in
\text{End}(V)\)</span>,我们应当能见到此时<span class="math inline">\(V=V[\text{Min}_{T}]\)</span>.那么反过来,<span class="math inline">\(V[\text{Min}_T]=V\)</span>的极小多项式当然也是<span class="math inline">\(\text{Min}_T\)</span>本身,这只是定义.</p>
<p>不妨设<span class="math inline">\(\text{Min}_T=fg\)</span>并且<span class="math inline">\(f\bot g\)</span>,从上面当然可以知道<span class="math inline">\(V=V[f]\oplus
V[g]\)</span>.此时我们应当思考的是<span class="math inline">\(V[f]\)</span>中的极小多项式是否是<span class="math inline">\(f\)</span>,<span class="math inline">\(V[g]\)</span>中的极小多项式是否是<span class="math inline">\(g\)</span>.而<span class="math inline">\(\text{Min}_T\)</span>是<span class="math inline">\(V[f]\)</span>和<span class="math inline">\(V[g]\)</span>中极小多项式的乘积,它们中的极小多项式又只是<span class="math inline">\(f,g\)</span>的因子,那必然见到极小多项式就是它们.</p>
<p>我们理应从上面的分析中见到极小多项式形态的一种刻画,我们接下来尝试证明,如果<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可对角化,其特征值去重后是<span class="math inline">\(\lambda_1,\cdots,\lambda_m\)</span>,那么最小多项式<span class="math inline">\(\text{Min}_T=\prod_{k=1}^m
(x-\lambda_k)\)</span>.</p>
<p>原因是考虑<span class="math inline">\(T\)</span>可对角化导致<span class="math inline">\(V\)</span>可以被拆成特征子空间的直和<span class="math inline">\(V=\bigoplus_{k=1}^mV_{\lambda_k}\)</span>.而其限制在每一个特征子空间上都是一个伸缩变换,其对应的极小多项式无外乎<span class="math inline">\(x-\lambda_k\)</span>,这样就得到上面的结论.</p>
<p>上述结论反之依然成立,那我们可以拿出一个更好的结论了,即:<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可对角化的充要条件是极小多项式<span class="math inline">\(\text{Min}_T\in F[x]\)</span>分裂并且无重根.</p>
<p>必要性在上面已经证明,接下来说明充分性.</p>
<p>当<span class="math inline">\(\text{Min}_T=\prod_{k=1}^m
(x-\lambda_k)\)</span>的时候,我们下面证明<span class="math inline">\(T\)</span>可对角化,顺便说明此时<span class="math inline">\(\lambda_1,\cdots,\lambda_m\)</span>就是<span class="math inline">\(T\)</span>的特征值去重后的结果.运用上述结论可以知道<span class="math inline">\(V=\bigoplus V[x-\lambda_k]\)</span>.然而<span class="math inline">\(V[x-\lambda_k]=V_{\lambda_k}\)</span>,这立刻就回到了可对角化的等价条件,于是充分性得证.</p>
<p>应当能从上面看出可对角化的某种拆分性,事实上,如果<span class="math inline">\(T\in \text{End}(V)\)</span>可对角化,<span class="math inline">\(V_0\subseteq V\)</span>是<span class="math inline">\(T\)</span>下的不变子空间,则<span class="math inline">\(T|_{V_0}\in \text{End}(V_0)\)</span>和<span class="math inline">\(\bar T\in
\text{End}(V/V_0)\)</span>都可以对角化.原因是它们的极小多项式都应当是<span class="math inline">\(\text{Min}_T\)</span>的因子.</p>
<p>然而也可以看出来上述命题的逆并不成立,因为拆出来的两个的极小多项式并不一定互质.</p>
<h4><span id="同步对角化">同步对角化</span></h4>
<p>设<span class="math inline">\(\mathcal S\subseteq
\text{End}(V)\)</span>,如果存在<span class="math inline">\(V\)</span>的基<span class="math inline">\(\vec
v_1,\cdots,\vec v_n\)</span>使得每个<span class="math inline">\(\vec
v_i\)</span>都是所有<span class="math inline">\(T\in \mathcal
S\)</span>的共同的特征向量,换言之每一个<span class="math inline">\(T\)</span>都可以用同样的一个可逆矩阵<span class="math inline">\(P\)</span>使得<span class="math inline">\(P^{-1}AP\)</span>是对角的,那我们称<span class="math inline">\(\mathcal S\)</span>在<span class="math inline">\(F\)</span>上可以<strong>同步对角化</strong>.</p>
<p>我们首先证明一个引理:如果<span class="math inline">\(ST=TS\)</span>,那么<span class="math inline">\(T\)</span>的任何一个特征子空间<span class="math inline">\(V_\lambda\)</span>都是<span class="math inline">\(S\)</span>的一个不变子空间.原因是对于<span class="math inline">\(\vec v\in V_\lambda\)</span>: <span class="math display">\[
T\vec v=\lambda\vec v\\
ST\vec v=\lambda(S\vec v)\\
T(S\vec v)=\lambda(S\vec v)
\]</span> 所以<span class="math inline">\(S\vec v\in
V_\lambda\)</span>.</p>
<p>我们得知同步对角化的充要条件应该是以下两条同时成立:</p>
<ol type="1">
<li>每个<span class="math inline">\(T\in \mathcal S\)</span>在<span class="math inline">\(F\)</span>上都可对角化.</li>
<li><span class="math inline">\(\forall T,T&#39;\in \mathcal
S\)</span>,<span class="math inline">\(TT&#39;=T&#39;T\)</span>.</li>
</ol>
<p>必要性显然,下面来说明充分性.</p>
<p>取出<span class="math inline">\(T_1\)</span>的所有特征子空间<span class="math inline">\(V_\lambda\)</span>,由于<span class="math inline">\(T&#39;\)</span>可对角化,所以其限制在<span class="math inline">\(T&#39;|_{V_\lambda}\)</span>上肯定也可对角化.如果我们能说明限制在每一个特征子空间<span class="math inline">\(V_\lambda\)</span>上时都可以同步对角化,由于特征子空间是直和分解,所以取直和后当然也可以.此时注意到限制后的<span class="math inline">\(T&#39;\)</span>必然也有交换律,而<span class="math inline">\(T_1|_{V_\lambda}\)</span>本身应当是<span class="math inline">\(\lambda
I\)</span>.这个东西怎么着都是可对角化的,因此就只需要对除了<span class="math inline">\(T_1\)</span>剩下部分继续做,这样就实现了数学归纳.</p>
<h4><span id="上三角化">上三角化</span></h4>
<p>回忆到我们之前曾经提过的旗的概念,我们在下面断言:若<span class="math inline">\(T\in \text{End}(V)\)</span>保持<span class="math inline">\(V\)</span>的一组完备旗,则<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上<strong>可上三角化</strong>,也就是其可以换基得到一个上三角矩阵.</p>
<p>我们已经得知一般的矩阵未必能对角化,那能不能退而求其次讲一个矩阵通过共轭转化为上三角的形式呢?我们下面证明:<span class="math inline">\(\text {char}_T\)</span>在<span class="math inline">\(F\)</span>上分裂是<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可上三角化的充要条件.</p>
<p>先证明必要性:当其可上三角化的时候,可以取<span class="math inline">\(V\)</span>的一组有序基,使得<span class="math inline">\(T\)</span>对应的矩阵形如<span class="math inline">\(\begin{bmatrix}\lambda_1&amp;\cdots&amp;\cdots\\0&amp;\ddots&amp;\cdots\\0&amp;0&amp;\lambda_n\end{bmatrix}\)</span>,此时立刻能得到其<span class="math inline">\(\text{char}_T=\prod (x
-\lambda_k)\)</span>,这立刻给出其可分裂.</p>
<p>再证明充分性:数学归纳,取出<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\vec v_1\in V_{\lambda_1}\setminus
\{0\}\)</span>,再令<span class="math inline">\(V_1=\text{span}\{\vec
v_1\}\)</span>,这里拿到的<span class="math inline">\(V_1\)</span>当然是一个不变子空间.仍取<span class="math inline">\(\pi:V\to V/V_1\)</span>,接下来观察<span class="math inline">\(V/V_1\)</span>的维数降了一维,根据数学归纳那其当然可以上三角化.回忆到我们曾经声明过了此时<span class="math inline">\(\text{char}_T=(x-\lambda_1)\text{char}_{\bar
T}\)</span>,原因是之前曾提过的在此分解下行列式之间的关系.可上三角化应当给出在<span class="math inline">\(V/V_1\)</span>上的一个被<span class="math inline">\(\bar T\)</span>保持的完备旗<span class="math inline">\(\{0\}=\bar {V_1}\subsetneq \cdots\subsetneq
\bar{V_n}=\bar
V\)</span>.第一同构定理已经声明过对他们取原像后仍然是子空间,于是我们取原像应当可以重新得到一列完备旗:<span class="math inline">\(\{0\}=V_0\subsetneq V_1\subsetneq \cdots\subsetneq
V_n=V\)</span>.</p>
<p>我们断言上述的旗也被<span class="math inline">\(T\)</span>保持,原因是<span class="math inline">\(\vec v\in V_i\Rightarrow \pi(T\vec v)=\bar T(\pi
\vec v)\in \bar T(\bar V_i)\subseteq \bar
V_i=\pi(V_i)\)</span>,这当然意味着<span class="math inline">\(T\vec v\in
V_i\)</span>,于是数学归纳就成立了.</p>
<p>值得一提的是上述证明可以原样拿来证明Cayley-Hamilton定理.方法是仍采取数学归纳,取<span class="math inline">\(V_1=\text{span}\{\vec
v_1\}\)</span>后,用数学归纳应当有<span class="math inline">\(\prod_{k=2}^n(\bar T-\lambda_i
I)=\text{char}_{\bar T}(\bar T)=0\)</span>.然而我们早就知道了<span class="math inline">\(\bar T=\pi T\)</span>,于是立刻得知<span class="math inline">\(\forall \vec v\in V,\prod_{k=2}^n(T-\lambda_i
I)(\vec v)\in V_1\)</span>,两边同做<span class="math inline">\(T-\lambda_1 I\)</span>映射立刻得到结论.</p>
<h4><span id="广义特征子空间">广义特征子空间</span></h4>
<p>定义<span class="math inline">\(V_{[\lambda]}=\bigcup_kV[(x-\lambda)^k]\)</span>.</p>
<p>先来分析其与通常讨论的特征子空间之间的关系,我们声明:<span class="math inline">\(V_{[\lambda]}\ne 0\Leftrightarrow V_\lambda\ne
0\)</span>.</p>
<p>由于<span class="math inline">\(V_\lambda\subseteq
V_{[\lambda]}\)</span>,右推左是显然的.</p>
<p>而考虑左推右,<span class="math inline">\(\exists \vec v\in
V_{[\lambda]},(T-\lambda)^N\vec v=\vec 0,(T-\lambda)^{N-1}\vec v\ne \vec
0\)</span>,那么<span class="math inline">\((T-\lambda)^{N-1}\vec v\in
V_{\lambda}\)</span>.</p>
<p>这个无限取并能不能降下去呢?而且上面这个东西应当需要有一种划分原空间的策略,这就意味着其应当和极小多项式有一定关系.事实上,如果特征多项式<span class="math inline">\(\text{char}_T=\prod
(x-\lambda_i)^{a_i}\)</span>,极小多项式<span class="math inline">\(\text{Min}_T=\prod
(x-\lambda_i)^{b_i}\)</span>,那么<span class="math inline">\(V_{[\lambda_i]}=V[(x-\lambda_i)^{b_i}]\)</span>.首先肯定有<span class="math inline">\(V[(x-\lambda_i)^{b_i}]\subseteq
V_{[\lambda_i]}\)</span>,所以只需证明反向包含即可.</p>
<p>此时注意到<span class="math inline">\(\forall \vec v\in
V_{[\lambda_i]}\)</span>,则存在<span class="math inline">\(k\)</span>使得<span class="math inline">\((T-\lambda_i)^k\vec v=\vec 0\)</span>.此时取<span class="math inline">\(h=\gcd((x-\lambda_i)^k,\text{Min}_T)\)</span>,用裴蜀定理立刻得到<span class="math inline">\(h=a(x-\lambda_i)^k+b\text{Min}_T\)</span>,于是立刻见到<span class="math inline">\(h(T)\vec v=\vec 0\)</span>.但容易注意到<span class="math inline">\(h|(x-\lambda_i)^{b_i}\)</span>,这就证完了.</p>
<p>那么从之前我们的分析立刻得知<span class="math inline">\(V=V[\text{Min}_T]=\bigoplus
_{i}V_{[\lambda_i]}\)</span>.并且见到<span class="math inline">\(V_{[\lambda_i]}\)</span>的极小多项式就是<span class="math inline">\((x-\lambda_i)^{b_i}\)</span>,而因为极小多项式和特征多项式的根集相同并且原本的特征多项式等于分空间的特征多项式的乘积,因此特征多项式就是<span class="math inline">\((x-\lambda_i)^{a_i}\)</span>.</p>
<p>接下来我们定义代数重数:作为特征多项式的根的重数.几何重数:<span class="math inline">\(\dim V_{\lambda_i}\)</span>.</p>
<p>注意到代数重数$<span class="math inline">\(几何重数,等式成立当且仅当\)</span>V_{<em>i}=V</em>{[_i]}<span class="math inline">\(.原因是\)</span>a_i=<em>{T_i}=V</em>{[_i]}V_{_i}$.</p>
<p>由于可对角化等价于可以拆分成若干特征子空间的直和,我们之前又已经证明过可对角化的几何重数一定等于代数重数,于是可对角化当且仅当几何重数等于代数重数.</p>
<p>另外代数重数和几何重数的关系还可以从线性方程组的角度理解,因为特征空间的维度就是<span class="math inline">\(\lambda_k I-A\)</span>的自由变量的数量.而<span class="math inline">\(\lambda_k\)</span>的代数重数意味着<span class="math inline">\((x-\lambda_k)\)</span>这一项在对角线的出现次数,现在这些位置都变成了<span class="math inline">\(0\)</span>,也就最多会有这么多个自由变量(还有可能上面某位置也有可以当主元的点顶替了他).那么几何重数就是实际上的自由量.</p>
<h4><span id="特殊矩阵的特征值">特殊矩阵的特征值</span></h4>
<h6><span id="example">Example</span></h6>
<p>回忆道斐波那契数列应当转移矩阵为<span class="math inline">\(T=\begin{bmatrix}0&amp;1\\1&amp;1\end{bmatrix}\)</span>,如果能把这个东西对角化的话就会很舒服.直接解特征值能解出来<span class="math inline">\(\text{char}_T=x^2-x+1\)</span>,两个特征值<span class="math inline">\(\lambda=\frac{1\pm\sqrt 5}{2}\)</span>.</p>
<p>然后需要去解特征向量再用特征向量取基,解出来<span class="math inline">\(\vec v=\left(\begin{matrix}1\\\frac{1\pm \sqrt
5}{2}\end{matrix}\right)\)</span>,这样立刻就拿到了换基矩阵<span class="math inline">\(P=[\vec v_1,\vec v_2]\)</span>和对角矩阵<span class="math inline">\(D=\begin{bmatrix}\lambda_1&amp;0\\0&amp;\lambda_2\end{bmatrix}\)</span>,并且拿到<span class="math inline">\(D=P^{-1}TP\)</span>.</p>
<h3><span id="双线性形式">双线性形式</span></h3>
<h4><span id="线性映射">线性映射</span></h4>
<p>给定<span class="math inline">\(F\)</span>上的线性空间<span class="math inline">\(V_1,\cdots,V_n,W\)</span>,我们定义一个<strong>多重线性映射</strong><span class="math inline">\(C:V_1\times \cdots \times V_n\to
W\)</span>.满足其对每一个分量都是线性的.也即固定其他<span class="math inline">\(m-1\)</span>个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之:
<span class="math display">\[
C(\cdots,t\vec v_i,\cdots)=tC(\cdots,\vec v_i,\cdots)\\C(\cdots,\vec
v_i+v_i&#39;,\cdots)=C(\cdots,\vec v_i,\cdots)+C(\cdots,\vec
v_i&#39;,\cdots)
\]</span> 特别地,当<span class="math inline">\(W=F\)</span>的时候也叫做<strong>多重线性形式</strong>.</p>
<p>容易见到交错形式无非是多重线性形式的某种特例.</p>
<p>还可以看到多重线性映射的集合<span class="math inline">\(\text{Mul}(V_1,\cdots,V_n;W)\)</span>本身也是线性空间.</p>
<p>更常用的是双线性映射,一般记作<span class="math inline">\(\text{Bil}(V_1,V_2;W)\)</span>.矩阵乘法本身是双线性映射的一个典型例子,对偶空间本身也是双线性形式的一个典型例子.特别地,一般定义<span class="math inline">\(V\)</span>和<span class="math inline">\(\check
V\)</span>之间的<strong>典范配对</strong>为<span class="math inline">\(\lang\_,\_\rang:\check V\times V\to
F\)</span>.其也可以看作点乘或者<span class="math inline">\((1\times
n)\times(n\times 1)\)</span>的矩阵乘法.</p>
<p>留意到柯里化过程,设<span class="math inline">\(\dim V=n,\dim
W=m\)</span>,容易见到:</p>
<p><span class="math display">\[
M_{m\times n}\cong\\ \text{Hom}(V,\check W)\cong
\text{Bil}(V,W;F)\cong\text{Hom}(W,\check V)\\\cong M_{n\times m}
\]</span></p>
<p>证明是平凡的.</p>
<p>这就能看出<span class="math inline">\(M_{n\times m}\cong
\text{Bil}(V\cong F^n,W\cong F^m;F)\)</span>,留意到其实可以取<span class="math inline">\(A:V\times W\to F\)</span>以<span class="math inline">\((\vec v,\vec w)\mapsto \check{\vec v}A\vec
w\)</span>.取二者的坐标表示,立刻见到<span class="math inline">\((\vec
v,\vec w)\mapsto\sum _{i}\sum_jv_ia_{i,j}w_j=(\vec v)^TA\vec
w\)</span>.留意到如果设<span class="math inline">\(C(\vec w,\vec
v)=B(\vec v,\vec w)\)</span>,这个<span class="math inline">\(C\)</span>对应的矩阵实际上就是对<span class="math inline">\(B\)</span>对应的矩阵取了转置.</p>
<p>接下来考虑对其取直和,不妨考虑<span class="math inline">\(B_1:V_1\times W_1\to F,B_2:V_2\times W_2\to
F\)</span>,则令<span class="math inline">\(B_1\oplus B_2:(V_1\oplus
V_2)\times (W_1\oplus W_2)\to F\)</span>,其中<span class="math inline">\(((\vec v_1,\vec v_2),(\vec w_1,\vec w_2))\mapsto
B_1(\vec v_1,\vec w_1)+B_2(\vec v_2,\vec
w_2)\)</span>.容易见到这是一个双线性形式.并且其代表的矩阵当然是原本的<span class="math inline">\(B_1,B_2\)</span>对应的矩阵组成的分块对角矩阵.</p>
<p>考虑双线性形式<span class="math inline">\(B:V\times V\to
F\)</span>.称其为<strong>对称的</strong>当且仅当<span class="math inline">\(B(\vec v,\vec w)=B(\vec w,\vec
v)\)</span>,称其为<strong>反对称的</strong>当且仅当<span class="math inline">\(B(\vec v,\vec w)=-B(\vec w,\vec
v)\)</span>.容易看到对称的当且仅当其对应的矩阵为<strong>对称矩阵</strong>,即<span class="math inline">\(A=A^T\)</span>,原因是<span class="math inline">\(B(\vec w,\vec v)=(\vec w)^TA\vec v=(\vec
v)^TA^T\vec
w\)</span>.反对称的对应的矩阵成为<strong>反对称矩阵</strong>或者<strong>斜对称矩阵</strong>,即<span class="math inline">\(-A=A^T\)</span>.</p>
<h4><span id="非退化形式">非退化形式</span></h4>
<p>对于双线性形式<span class="math inline">\(B: V\times W\to
F\)</span>,称<span class="math inline">\(\vec v\)</span>是<span class="math inline">\(B\)</span>的一个<strong>左根</strong>当且仅当<span class="math inline">\(B(\vec v,\_)\equiv
0\)</span>.同理可以定义<strong>右根</strong>.容易见到左根右根集合分别应当是<span class="math inline">\(V,W\)</span>的子空间.将左根空间记作<span class="math inline">\(^{\bot}V\)</span>,右根空间记作<span class="math inline">\(W^{\bot}\)</span>.</p>
<p>当<span class="math inline">\(V=W\)</span>并且<span class="math inline">\(B\)</span>是对称的或者反对称的时候,此时左根和右根是一回事,一般将它们统称为<span class="math inline">\(B\)</span>的根基.</p>
<p>称<span class="math inline">\(B\)</span>是<strong>非退化的</strong>,当且仅当其左右根集合都是<span class="math inline">\(\{\vec 0\}\)</span>.</p>
<p>现在考虑对于典范配对<span class="math inline">\(\langle \lambda,\vec
v\rangle\to \lambda\vec
v\)</span>,考虑其左根和右根,显然都只是各自空间里的<span class="math inline">\(\vec
0\)</span>,原因是对于前者是一个映射,其映射所有都是<span class="math inline">\(0\)</span>,那它当然是<span class="math inline">\(0\)</span>映射本身.对于后者,考虑取<span class="math inline">\(\vec v\ne \vec 0\)</span>,扩充<span class="math inline">\(\vec v\)</span>为一组基<span class="math inline">\(\vec v,\vec v_2\cdots,\vec
v_n\)</span>,并取其对偶基<span class="math inline">\(\check v,\check
v_2,\cdots,\check v_n\)</span>,此时就当然满足<span class="math inline">\(\langle\check v,\vec
v\rangle=1\)</span>,所以它是非退化的.</p>
<p>另一个例子是考虑迹映射<span class="math inline">\(Tr:\text{End}(V)\times \text{End}(V)\to
F,(S,T)\mapsto
\text{tr}(ST)\)</span>,容易见到它是对称的.那么考虑其根基,只考虑左根,如果<span class="math inline">\(\forall
T,\text{tr}(ST)=0\)</span>,应当满足对于基矩阵<span class="math inline">\(E_{i,j}\)</span>满足<span class="math inline">\(\text{tr}(SE_{i,j})=0\)</span>.容易见到<span class="math inline">\(tr(SE_{i,j})=0\)</span>,所以<span class="math inline">\(S\equiv 0_{n\times
n}\)</span>.这意味着迹映射是非退化的.</p>
<p>回忆道双线性形式同构于线性映射<span class="math inline">\(\psi\in
\text{Hom}(V,\check W)\)</span>或<span class="math inline">\(\varphi\in
\text{Hom}(W,\check V)\)</span>,注意到左根实际上就是<span class="math inline">\(\ker \psi\)</span>,右根实际上就是<span class="math inline">\(\ker \varphi\)</span>.</p>
<p>不妨假设<span class="math inline">\(\dim V&gt;\dim W\)</span>,则<span class="math inline">\(\dim\ker \psi=\dim V-\text{rk}\psi\geq \dim V-\dim
W&gt;0\)</span>,所以注意到<span class="math inline">\(B\)</span>是非退化的一定要有<span class="math inline">\(\dim V=\dim W\)</span>.</p>
<p>现在我们对于<span class="math inline">\(B:V\times W\to
F\)</span>并且满足<span class="math inline">\(\dim V=\dim
W\)</span>,我们声称以下三条性质等价:</p>
<ol type="1">
<li><span class="math inline">\(B\)</span>是非退化的.</li>
<li>左根空间为<span class="math inline">\(0\)</span>.</li>
<li>右根空间为<span class="math inline">\(0\)</span>.</li>
</ol>
<p>显然只需说明(2)<span class="math inline">\(\Leftrightarrow\)</span>(3).两个方向类似,下面只证明(2)<span class="math inline">\(\Rightarrow\)</span>(3).而当<span class="math inline">\(\dim\ker
\psi=0\)</span>时,由于两边维数相等,自然得到<span class="math inline">\(\psi\)</span>是一个同构.接下来考虑<span class="math inline">\(\vec
w\)</span>如果是一个右根,那么对此取一个空间<span class="math inline">\(H=\{\lambda\in \check W\mid\lambda \vec
w=0\}\)</span>,见到<span class="math inline">\(\psi(V)\)</span>一定是<span class="math inline">\(H\)</span>的一个子空间.但是<span class="math inline">\(\dim V=\dim \psi(V)\leq \dim H\leq \dim
W\)</span>,这就看出<span class="math inline">\(\dim H=\dim
V=n\)</span>.然而当<span class="math inline">\(\vec w\ne \vec
0\)</span>的时候,<span class="math inline">\(\dim
H\)</span>不可能取到满空间,原因是典范同态是非退化的.这就导出了右根空间也是<span class="math inline">\(0\)</span>空间.</p>
<p>另一种看法是直接观察矩阵,右根实际上就是<span class="math inline">\(\ker(A)\)</span>,左根实际上就是<span class="math inline">\(\ker (A^T)\)</span>,那它们的<span class="math inline">\(\dim\)</span>当然要相等,原因是它们的<span class="math inline">\(\text{rk}\)</span>相等.</p>
<p>此时也容易注意到,非退化的矩阵实际上也就等价于可逆矩阵.</p>
<p>如果对商空间比较敏感,不妨设左根空间为<span class="math inline">\(L\)</span>,右根空间为<span class="math inline">\(R\)</span>,我们应当见到<span class="math inline">\(\bar B:(V/L)\times (W/R)\to F,(\vec v+L,\vec
w+R)\mapsto B(\vec v,\vec
w)\)</span>是非退化双线性形式.此时见到其实<span class="math inline">\(\dim V-\dim L=\dim W-\dim R\)</span>.</p>
<p>适当推广上述结论,我们实际上可以定义任何子空间的<span class="math inline">\(V_0\subseteq V\)</span>的正交空间为<span class="math inline">\(V_0^\bot=\{\vec w\in W\mid \forall \vec v_0\in
V_0,B(\vec v_0,\vec w)=0\}\)</span>.同理定义<span class="math inline">\(^\bot W_0\)</span>.容易见到<span class="math inline">\(V_0\subseteq ^\bot(V_0^\bot)\)</span>.</p>
<p>我们试图寻找一些更好的关系,不妨假设<span class="math inline">\(B\)</span>是非退化的,那么立刻有<span class="math inline">\(\dim V=\dim W\)</span>,我们下面证明<span class="math inline">\(\dim V_0^\bot+\dim V_0=\dim V\)</span>.</p>
<p>令<span class="math inline">\(d=\dim V_0,n=\dim V=\dim
W\)</span>已经知道<span class="math inline">\(B\)</span>会对应一个同构<span class="math inline">\(\psi:V\cong \check W\)</span>,那么取<span class="math inline">\(V_0\)</span>在<span class="math inline">\(\psi\)</span>下的像,并取其基<span class="math inline">\(\check w_1,\cdots,\check w_d\)</span>,此时<span class="math inline">\(V_0^\bot\subseteq W\)</span>是满足<span class="math inline">\(\langle\check w_1,\_\rangle=\cdots=\langle\check
w_d,\_\rangle=0\)</span>的子空间.</p>
<p>不妨先考虑两个特殊情况并从中窥见归纳的办法.当<span class="math inline">\(d=n\)</span>的时候,此时<span class="math inline">\(V_0^\bot=V^\bot\)</span>,也就是右根集合,我们之前已经证明过了这是一个零空间.而当<span class="math inline">\(d=1\)</span>的时候,考虑<span class="math inline">\(\check w_1\)</span>,因为它不是<span class="math inline">\(0\)</span>,所以它必然是<span class="math inline">\(W\to F\)</span>的满射,此时意味着<span class="math inline">\(\dim \text{im}\ \check
w_1=1\)</span>,意味着此时<span class="math inline">\(V_0^\bot=\ker
(\check w_1)\)</span>的维数应当是<span class="math inline">\(n-1\)</span>.</p>
<p>接下来从上面的结构中跳出来,直接观察<span class="math inline">\(\check
W\)</span>上的情形,我们将上述的那一组基扩充为<span class="math inline">\(\check W\)</span>的基<span class="math inline">\(\check w_1,\cdots \check w_n\)</span>并考虑<span class="math inline">\(W\)</span>的子空间列<span class="math inline">\(^\bot\langle\check w_1\rangle\supseteq
\cdots\supseteq ^\bot\langle\check w_1,\cdots,\check
w_n\rangle\)</span>.不妨设<span class="math inline">\(W_k=^\bot\langle\check w_1,\cdots,\check
w_k\rangle\)</span>.</p>
<p>然而此时可以见到<span class="math inline">\(W_{k+1}=W_k\cap
{^\bot\langle\check w_{k+1}\rangle}\)</span>,用第二同构定理得到:</p>
<p><span class="math display">\[
\dim (W_{k+1})=\dim W_k+\dim ^\bot\langle\check
w_{k+1}\rangle-\dim(W_k+^\bot\langle\check w_{k+1}\rangle)\\
\geq \dim W_k+\dim ^\bot\langle\check w_{k+1}\rangle-n\\
=\dim W_k-1
\]</span></p>
<p>因此每加一个最多降一维(其实等价于把那个<span class="math inline">\(\dim=1\)</span>的空间商掉了),然而注意到上述空间列的首项是<span class="math inline">\(n-1\)</span>维,末项是<span class="math inline">\(0\)</span>维,每次降一维的话就可以得到<span class="math inline">\(\dim \langle\check w_1,\cdots ,\check
w_d\rangle=n-d\)</span>,这就证明了上述的结论.</p>
<p>然而上述推断其实并不意味着<span class="math inline">\(V=V_0^\bot+V_0\)</span>,也不意味着<span class="math inline">\(V_0\cap V_0^\bot=\{\vec
0\}\)</span>,这两个结论都是得不到的.</p>
<p>然而好用的结论是我们之前已经提过<span class="math inline">\(V_0\subseteq
^\bot(V_0^\bot)\)</span>,此时我们注意到这个式子两边的维度实际上相等,因此<span class="math inline">\(^\bot(V_0^\bot)=V_0\)</span>.再次声明此式子只在非退化的前提下成立.</p>
<h4><span id="伴随映射">伴随映射</span></h4>
<p>考虑两个双线性形式<span class="math inline">\(B_1,B_2\)</span>,其中<span class="math inline">\(B_1\in\text{Bil}(V_1,V_1&#39;,F)\)</span>,<span class="math inline">\(B_2\)</span>类似.我们声称存在唯一的线性映射<span class="math inline">\(\varphi:\text{Hom}(V_1,V_2)\to
\text{Hom}(V_2&#39;,V_1&#39;),T\mapsto T^*\)</span>满足<span class="math inline">\(B_2(T\vec v_1,\vec v_2&#39;)=B_1(\vec v_1,T^*\vec
v_2&#39;)\)</span>.其中这个<span class="math inline">\(T^*\)</span>称为<span class="math inline">\(T\)</span>相对于<span class="math inline">\(B_1\)</span>和<span class="math inline">\(B_2\)</span>的<strong>右伴随</strong>.同理可以定义<strong>左伴随</strong><span class="math inline">\(^*T\)</span>满足<span class="math inline">\(B_2(\vec v_2,T\vec v_1&#39;)=B_1(^*T\vec v_2,\vec
v_1&#39;)\)</span>,并且假设<span class="math inline">\(B_1\)</span>非退化,那么它对应的矩阵<span class="math inline">\(A_1\)</span>可逆.</p>
<p>如何证明这个结论呢?只考虑右伴随的情况,对于某个固定的<span class="math inline">\(\vec v_2&#39;\)</span>,取出映射<span class="math inline">\(B_2(T(\_),\vec v_2&#39;):V_1\to
F\)</span>.那它当然是<span class="math inline">\(\check{V_1}\)</span>中的元素.而因为<span class="math inline">\(B_1\)</span>非退化,其对应了一个<span class="math inline">\(V_1&#39;\to \check
V_1\)</span>的同构,因此应当存在唯一的<span class="math inline">\(\vec
v_1&#39;\)</span>使得其映射到<span class="math inline">\(\check
{V_1}\)</span>的时候恰好满足<span class="math inline">\(B_2(T(\_),\vec
v_2&#39;)=B_1(\_,\vec v_1&#39;)\)</span>,这就给出了<span class="math inline">\(T^*:\vec v_2&#39;\mapsto \vec
v_1&#39;\)</span>.换言之其唯一性取决于<span class="math inline">\(A_1\)</span>的非退化性.取<span class="math inline">\(\varphi_i:V_i&#39;\to \check{V_i}\)</span>且<span class="math inline">\(\varphi_1\)</span>可逆,回忆到之前过程可以知道这里的<span class="math inline">\(\varphi_1\)</span>实际上就是<span class="math inline">\(A_1\)</span>,下述图表的上半部分交换:</p>
<p><span class="math display">\[
\xymatrix{
V_2&#39;\ar[r]^{T^*}\ar[d]_{A_2}&amp;V_1&#39;\ar[d]^{A_1}\\
\check {V_2}\ar[r]^{^tT} &amp;\check {V_1}\\
V_2\ar[u]&amp;V_1\ar[u]\ar[l]_T
}
\]</span></p>
<p>另外可以见到如果假设<span class="math inline">\(B_2\)</span>也是非退化的,当线性空间本身满足条件的时候应该有<span class="math inline">\(^*(T^*)=T=(^*T)^*\)</span>.还可以见到<span class="math inline">\((ST)^*=T^*S^*,^*(ST)=^*T^*S\)</span>.这还顺便说明了<span class="math inline">\((T^{-1})^*=(T^*)^{-1},^*(T^{-1})=(^*T)^{-1}\)</span>.</p>
<p>上面的结论如何用矩阵刻画?只考虑右伴随的部分,选定一组有序基后,将双线性形式对应到矩阵应当有:</p>
<p><span class="math display">\[
B_2(T\vec v_1,\vec v_2&#39;)=(\vec v_1)^TT^TA_2\vec v_2&#39;=(\vec
v_1)^TA_1(A_1^{-1}T^TA_2)\vec v_2&#39;\\
B_1(\vec v_1,T^*\vec v_2&#39;)=(\vec v_1)^TA_1T^*\vec v_2&#39;
\]</span></p>
<p>比对就可以看到只需取<span class="math inline">\(T^*=A_1^{-1}T^TA_2\)</span>,这与上述交换图表的形式也是符合的.同理可以得到<span class="math inline">\(^*T =(A_2TA_1^{-1})^T\)</span>.并从此看出当<span class="math inline">\(B_1,B_2\)</span>都非退化的时候,伴随不改变矩阵的秩,因为此时伴随矩阵与原矩阵的转置是相抵的.事实上可以直接写出<span class="math inline">\(\ker(T^*)=(\text{im}T)^\bot\)</span>,原因是:</p>
<p><span class="math display">\[
T^*\vec w=0\Leftrightarrow \forall \vec v,(\vec v\mid T^*\vec w)=0\\
\Leftrightarrow \forall \vec v,(T\vec v\mid \vec w)=0\Leftrightarrow
\vec w\in (\text{im}T)^\bot
\]</span></p>
<p>而由同态基本定理,<span class="math inline">\(\dim
(\text{im}T)^\bot=\dim \ker (T^*)\)</span>,由上可以见到当<span class="math inline">\(\dim V=\dim W\)</span>时<span class="math inline">\(\text{rk}\ T=\text{rk}\ T^*\)</span>.</p>
<p>当对应的双线性形式非退化的时候回忆到可以两边取<span class="math inline">\(\bot\)</span>就拿到<span class="math inline">\(\ker(T^*)^\bot=(\text{im}T)\)</span>.</p>
<p>下面考虑<span class="math inline">\(V_1=V_2=V_1&#39;=V_2&#39;=V\)</span>,并假设<span class="math inline">\(B_1=B_2\)</span>且二者要么对称要么反对称.此时注意到<span class="math inline">\(T\)</span>的左伴随和右伴随是没有区别的,我们将它们统一称作伴随,一般采取右伴随的记号记作<span class="math inline">\(T^*\)</span>并尝试通过上下文区分.特别地,如果<span class="math inline">\(T=T^*\)</span>,那我们称其为<strong>自伴的</strong>,如果<span class="math inline">\(T=-T^*\)</span>,则称其为<strong>反自伴的</strong>.</p>
<p>如果选取<span class="math inline">\(A_1=A_2=I\)</span>,那么根据上面的分析见到<span class="math inline">\(T\)</span>是自伴的当且仅当<span class="math inline">\(T\)</span>是对称的,反自伴的当且仅当其是反对称的.</p>
<h4><span id="分类问题">分类问题</span></h4>
<p>定义双线性形式上的同构:称<span class="math inline">\((V_1,B_1)\cong(V_2,B_2)\)</span>,其中<span class="math inline">\(B_1:V_1\times V_1\to F,B_2:V_2\times V_2\to
F\)</span>,当且仅当存在一个同构<span class="math inline">\(\varphi:V_1\cong V_2\)</span>,满足<span class="math inline">\(B_2(\varphi(\vec v),\varphi(\vec v&#39;))=B_1(\vec
v,\vec
v&#39;)\)</span>.容易验证这个同构满足等价条件的三条性质:反身性,对称性,传递性.并且双线性形式的几乎所有性质(左右根,根基,对称性,反对称性,退化性)都在同构关系下得到保持.这就意味着双线性形式应该可以以这种同构关系分类.</p>
<p>不失一般性,不妨直接假设<span class="math inline">\(V=F^n\)</span>以简化描述.</p>
<p>我们定义两个<span class="math inline">\(n\times n\)</span>的矩阵<span class="math inline">\(A,A&#39;\)</span>是<strong>合同的</strong>,当且仅当<span class="math inline">\(\exists C\in (M_{n\times
n})^\times\)</span>使得<span class="math inline">\(A=C^TA&#39;C\)</span>.容易验证这是一个等价关系.必须要强调这里的<span class="math inline">\(C\)</span>是可逆矩阵.</p>
<p>接下来考虑两个双线性形式<span class="math inline">\(B,B&#39;:F^n\times F^n\to
F\)</span>,我们声称当且仅当它们对应的矩阵<span class="math inline">\(A,A&#39;\)</span>是合同的有<span class="math inline">\(A=C^TA&#39;C\)</span>时是同构的.同构办法就是利用<span class="math inline">\(C\)</span>所代表的线性映射.</p>
<p>对于充分性:只需检验是否有<span class="math inline">\(B(\vec v_1,\vec
v_2)=B&#39;(C\vec v_1,C\vec v_2)\)</span>,而<span class="math inline">\(B&#39;(C\vec v_1,C\vec v_2)=(C\vec
v_1)^TA&#39;(C\vec v_2)=(\vec v_1)^TA\vec v_2=B(\vec v_1,\vec
v_2)\)</span>.</p>
<p>对于必要性:考虑所有的同构<span class="math inline">\(\varphi\)</span>当然都可以写作可逆矩阵形式,设这个矩阵为<span class="math inline">\(C\)</span>,立刻见到应当有<span class="math inline">\(A=C^TA&#39;C\)</span>.</p>
<h4><span id="二次型">二次型</span></h4>
<p>考虑<span class="math inline">\(\text{char}\ne 2\)</span>的域<span class="math inline">\(F\)</span>,原因是这种域上面存在<span class="math inline">\(\frac{1}{2}\)</span>.为了方便讨论下面不妨直接假设<span class="math inline">\(V=F^n\)</span>.</p>
<p>定义<span class="math inline">\(n\)</span>元<strong>二次型</strong>为一个<span class="math inline">\(F\)</span>上的齐次多项式<span class="math inline">\(f=\sum_i
a_{i,i}x_i^2+2\sum_{i&lt;j}a_{i,j}x_ix_j\)</span>,并在考虑对称的情况下设<span class="math inline">\(a_{i,j}=a_{j,i}\)</span>成立,上述自然有<span class="math inline">\(f=\sum_{i,j}a_{i,j}x_ix_j\)</span>.容易见到<span class="math inline">\(f\)</span>实际上可以表示为某一个对称的双线性形式,将这些<span class="math inline">\(a\)</span>排列成矩阵就可以见到上述<span class="math inline">\(f(x)=(\vec x)^TA\vec x=B(\vec x,\vec
x)\)</span>.这种对应实际上是双射,原因是该多项式也可以反过去确定一个对称的双线性形式,原因是注意到首先<span class="math inline">\(B(\vec v,\vec
v)\)</span>肯定是可以被确定的,其次由于<span class="math inline">\(B(\vec
v_1+\vec v_2,\vec v_1+\vec v_2)=B(\vec v_1,\vec v_1)+B(\vec v_2,\vec
v_2)+2B(\vec v_1,\vec v_2)\)</span>,于是立刻得到<span class="math inline">\(B(\vec v_1,\vec v_2)=\frac{1}{2}(f(\vec v_1+\vec
v_2)-f(\vec v_1)-f(\vec
v_2))\)</span>,这就给出了一组一一对应的关系.从这里顺便应该能看出对称双线性形式应该由其所有的<span class="math inline">\(B(\vec v,\vec
v)\)</span>的取值唯一确定.我们会在内积空间里再次讨论这个技巧,这被称为<strong>配极化</strong>.</p>
<p>将合同关系挪到二次型上就可以见到,两个二次型同构当且仅当它们可以通过一个可逆的线性变量替换而相互过渡.</p>
<p>既然如此,应该见到二次型某种意义上同构于矩阵,那么能不能把二次型作对角化呢,也即能否将二次型同构于形如<span class="math inline">\(g=\sum
b_ix_i^2\)</span>的二次型.这个当然可以用配方法解决,具体操作是数学归纳,每次将和一个变量有关的全部赛到一个里面去.</p>
<p>具体地,我们执行以下策略:</p>
<ol type="1">
<li>如果当前存在一个<span class="math inline">\(a_{i,i}\ne
0\)</span>,不妨设其为<span class="math inline">\(a_{1,1}\)</span>,那就可以提出一个<span class="math inline">\(a_{1,1}(x_1+\frac{1}{a_{1,1}}\sum_{k\geq
2}a_{1,k}x_k)^2\)</span>.</li>
<li>反之,则存在一个<span class="math inline">\(a_{i,j}\ne
0\)</span>,不妨在此时做变量替换<span class="math inline">\(y_i=x_i-x_j\)</span>换掉<span class="math inline">\(x_i\)</span>,这样<span class="math inline">\(x_j^2\)</span>前的系数就非<span class="math inline">\(0\)</span>,自然回到前一种情况.</li>
</ol>
<p>上述过程不好机械化,能不能用一些更加形式化的方式呢?考虑配方当然等价于寻找一个可逆矩阵<span class="math inline">\(C\)</span>使得对称矩阵<span class="math inline">\(A\)</span>被写作<span class="math inline">\(C^TAC=A&#39;\)</span>,而可逆矩阵可以写作若干初等矩阵的乘积,不妨记作<span class="math inline">\(U_1\cdots U_k\)</span>,于是知道我们想要让<span class="math inline">\((U_1\cdots U_k)^TA(U_1\cdots U_k)\)</span>.</p>
<p>这里有一个算法是将矩阵排列成<span class="math inline">\(\begin{bmatrix}A\\I\end{bmatrix}\)</span>的形式,然后对其做对称行列变换(这样列变换会影响到下面的<span class="math inline">\(I\)</span>,但是行变换不会影响),这样最后会消成<span class="math inline">\(\begin{bmatrix}A&#39;\\C\end{bmatrix}\)</span>的形式,就会有<span class="math inline">\(A&#39;=C^TAC\)</span>.</p>
<p>由此可以设<span class="math inline">\(r=\text
{rk}(f)\)</span>为对角化后剩余的元素个数.见到其根基的维数恰为<span class="math inline">\(n-r\)</span>,原因是<span class="math inline">\(\ker
A\)</span>的维数就是根基的维数.见到其非退化当且仅当<span class="math inline">\(n=r\)</span>.</p>
<p>如果我们做的域是一个代数闭域,那么我们上面的分类问题立刻得到了解决,原因是二次型当然可以进一步化简为<span class="math inline">\(\sum_{k=1}^ry_k^2\)</span>的形式,因此二次型完全由秩来决定.当然其实代数闭这个性质并没有用完全,实际上上述结论只需要求所有的<span class="math inline">\(F\)</span>中元素都有平方根即可.</p>
<h5><span id="实二次型">实二次型</span></h5>
<p>然而我们知道实数域并不满足以上性质,能不能把实数上的二次型进一步分类呢?虽然不能对<span class="math inline">\(-1\)</span>开根,但总之可以将二次型同构成<span class="math inline">\(f=\sum_{k=1}^px_k^2-\sum_{j=p+1}^rx_j^2\)</span>.将此称作该二次型的<strong>规范型</strong>.</p>
<p>先对于实二次型引入一些新的定义:对于一个对称双线性形式,如果<span class="math inline">\(\forall \vec v\)</span>,<span class="math inline">\(B(\vec v,\vec v)\geq
0\)</span>恒成立,则称其为<strong>半正定的</strong>,如果在此基础上当<span class="math inline">\(\vec v\ne 0\)</span>时<span class="math inline">\(B(\vec v,\vec
v)&gt;0\)</span>恒成立,则称其为<strong>正定</strong>的.同样可以定义<strong>半负定的</strong>和<strong>负定的</strong>概念.还可以定义<strong>不定的</strong>概念.容易见到如果一个对称双线性形式是正定的或者负定的时候它必然是非退化的,因为此时除了<span class="math inline">\(\vec
0\)</span>其无根基.一定要注意这里的正定是在对称性的基础上定义的.</p>
<p>容易见到半正定当且仅当上述<span class="math inline">\(f\)</span>中满足<span class="math inline">\(p=r\)</span>,正定当且仅当满足<span class="math inline">\(p=r=n\)</span>.到这里我们忽然疑问到同构的二次型的<span class="math inline">\(p\)</span>是否相等.</p>
<h5><span id="惯性sylvester定理">惯性(Sylvester)定理</span></h5>
<p>即:对于两个同构的二次型,它们的<span class="math inline">\((p,r-p)\)</span>相同,一般将<span class="math inline">\(p\)</span>称作<strong>正惯性系数</strong>而将<span class="math inline">\(r-p\)</span>称作<strong>负惯性系数</strong>,两者的差<span class="math inline">\(2p-r\)</span>一般称作其<strong>符号差</strong>.</p>
<p>之所以会疑惑同构的二次型的<span class="math inline">\(p\)</span>不一定相等,是因为同构只搬运了空间上的性质.因此如果我们能把<span class="math inline">\(p\)</span>以某种基于空间上的形态,当然就可以显然看出两个同构的二次型的<span class="math inline">\((p,r-p)\)</span>相同.我们声明对于一个正惯性系数为<span class="math inline">\(p\)</span>的二次型以下命题成立:</p>
<ol type="1">
<li>存在一个<span class="math inline">\(p\)</span>维的正定子空间.</li>
<li>对于任何维数<span class="math inline">\(&gt;p\)</span>的子空间,其都不可能是正定的.</li>
</ol>
<p>(1)显然,直接拿出其正部分对应的空间即可.</p>
<p>(2)的话无非是考虑将鸽笼原理用子空间之间的交写出来,设<span class="math inline">\(N\)</span>为后<span class="math inline">\(p+1,\cdots,n\)</span>这部分所代表的子空间,对于任何一个<span class="math inline">\(V&#39;\)</span>子空间满足<span class="math inline">\(\dim
V&#39;&gt;p\)</span>,直接拿第二同构定理得到:</p>
<p><span class="math display">\[
\dim(V&#39;\cap N)=\dim(V&#39;)+\dim(N)-\dim(V&#39;+N)\\\geq n-p+\dim
V&#39;-n&gt;0
\]</span></p>
<p>这意味着其不为空.</p>
<p>对负惯性系数当然可以类似做.这样惯性定理自然解决了实二次型的分类问题.</p>
<h4><span id="辛空间">辛空间</span></h4>
<p>回到特征不为<span class="math inline">\(2\)</span>的域<span class="math inline">\(F\)</span>上,考虑反对称形式,注意到<span class="math inline">\(B(\vec v,\vec v)=-B(\vec v,\vec
v)\)</span>,那此时它们就应该同时为<span class="math inline">\(0\)</span>.这当然类似我们之前说的交错形式.</p>
<p>观察这类反对称形式的根基,取<span class="math inline">\(R(V)=\{\vec
v\in V\mid B(\vec v,\_)=0\}\)</span>.此时把补空间拿出来,取<span class="math inline">\(V=R(V)\oplus V&#39;\)</span>,我们断言<span class="math inline">\((V,B)\cong
(R(V),0)\oplus(V&#39;,B\mid_{V&#39;\times V&#39;})\)</span>,其中<span class="math inline">\(B\mid_{V&#39;\times V&#39;}\)</span>是<span class="math inline">\(V&#39;\)</span>上的非退化线性形式.这个断言当然是显然的,只需简单拆分空间即可.问题在于如何证明<span class="math inline">\(B\mid_{V&#39;\times V&#39;}\)</span>是<span class="math inline">\(V&#39;\)</span>上的非退化线性形式,只需证明<span class="math inline">\(R(V&#39;)=V&#39;\cap
R(V&#39;)=\{0\}\)</span>,我们考虑如果<span class="math inline">\(\exists
\vec v&#39;\in V&#39;\)</span>,<span class="math inline">\(\forall \vec
v_1&#39;\in V&#39;,B(\vec v&#39;,\vec
v_1&#39;)=0\)</span>,由于根基当然和任何东西都会变零,因此这等价于<span class="math inline">\(\forall \vec v_1\in V,B(\vec v&#39;,\vec
v_1)=0\)</span>,这必然意味着<span class="math inline">\(\vec v&#39;\in
R(V)\)</span>,也就是<span class="math inline">\(\vec v&#39;\in R(V)\cap
V&#39;=\{0\}\)</span>.</p>
<p>因此其实反对称双线性形式更重要的是考虑其非退化的部分.将这些非退化反对称双线性形式称为<strong>辛形式</strong>,并将<span class="math inline">\((V,B)\)</span>称作辛空间.</p>
<p>考虑取一对基<span class="math inline">\(\vec p,\vec
q\)</span>形成空间<span class="math inline">\(\langle\vec p,\vec
q\rangle\)</span>并满足<span class="math inline">\(B(\vec p,\vec
q)=1=-B(\vec q,\vec p)\)</span>,这当然唯一确定了一个辛形式<span class="math inline">\(B\)</span>,并且其实际上对应了一个反对称矩阵<span class="math inline">\(\begin{bmatrix}0&amp;1\\-1&amp;0\end{bmatrix}\)</span>,这种二维辛空间一般还被称为<strong>双曲辛平面</strong>.</p>
<p>虽然研究范围被限制在了辛空间上,但仍然能看到辛形式中会因为正负相抵爆出大量的<span class="math inline">\(0\)</span>.设<span class="math inline">\(V_0\)</span>是<span class="math inline">\(V\)</span>的子空间,若<span class="math inline">\(B\mid_{V_0\times V_0}\equiv 0\)</span>,我们称<span class="math inline">\(V_0\)</span>是<strong>全迷向子空间</strong>,一个极大(真包含它的子空间全都不是全迷向的)的全迷向子空间称为<strong>拉格朗日子空间</strong>.</p>
<p>设<span class="math inline">\((V,B)\)</span>为辛空间,<span class="math inline">\(L\)</span>是拉格朗日子空间,我们下面证明两个性质:</p>
<ol type="1">
<li><span class="math inline">\(L^\bot=L\)</span>.</li>
<li><span class="math inline">\(\dim V=2\dim L\)</span>.</li>
<li>辛空间必定是偶数维的.</li>
</ol>
<p>如果(1)得证,由于<span class="math inline">\(\dim V=\dim L+\dim
L^\bot\)</span>,(2)(3)也就显然了.所以问题在于如何证明(1).</p>
<p>首先全迷向性质自然等价于<span class="math inline">\(L\subseteq
L^\bot\)</span>.此时考虑若<span class="math inline">\(\exists \vec v\in
L^\bot\setminus L\)</span>,则<span class="math inline">\(L+\langle \vec
v\rangle\)</span>这个空间仍然是全迷向的(原因是<span class="math inline">\(\vec v\)</span>自身的部分会因为交错性质而成<span class="math inline">\(0\)</span>),这就与其极大性矛盾.</p>
<p>我们试图想要找到更好的策略去勾勒<span class="math inline">\(L\)</span>以及<span class="math inline">\(V/L\)</span>这两部分.</p>
<h5><span id="达布定理">达布定理</span></h5>
<p>该定理是说:给定一个拉格朗日子空间<span class="math inline">\(L\)</span>,<span class="math inline">\(L\)</span>的任何有序基<span class="math inline">\(\vec p_1,\cdots,\vec p_n\)</span>都能扩充为<span class="math inline">\(V\)</span>的有序基<span class="math inline">\(\vec
p_1,\cdots \vec p_n,\vec q_n,\cdots,\vec q_1\)</span>,使得<span class="math inline">\(\forall 1\leq i,j\leq n\)</span>:</p>
<ol type="1">
<li><span class="math inline">\(B(p_i,p_j)=B(q_i,q_j)=0\)</span>.</li>
<li><span class="math inline">\(B(p_i,q_j)=-B(q_j,p_i)=\begin{cases}1&amp;i=j\\0&amp;i\ne
j\end{cases}\)</span>.</li>
</ol>
<p>这组有序基又被称为<span class="math inline">\(V\)</span>的<strong>辛基</strong>.</p>
<p>考虑定义<span class="math inline">\(n-1\)</span>维子空间<span class="math inline">\(L_i=\langle\vec p_1,\cdots,\vec p_{i-1},\vec
p_{i+1},\cdots,\vec p_n\rangle\)</span>.留意到此时会有<span class="math inline">\(L=L^\bot\subsetneq L_i^\bot,\dim
L_i^\bot=n+1\)</span>.</p>
<p>接下来数学归纳构造这组<span class="math inline">\(q\)</span>.</p>
<p>对于<span class="math inline">\(k=1\)</span>的情况,由于我们上面的分析,<span class="math inline">\(\exists \vec q_1\in L_1^\bot\setminus
L\)</span>,于是此时必然满足<span class="math inline">\(B(\vec p_1,\vec
q_1)\ne 0\)</span>而<span class="math inline">\(\forall i\geq 2,B(\vec
p_i,\vec q_1)=0\)</span>.适当伸缩即可满足条件.</p>
<p>在此之后,假设<span class="math inline">\(k&lt;n\)</span>并且我们已经有了<span class="math inline">\(\vec q_1,\cdots,\vec
q_k\)</span>使得条件成立,仍然可以取<span class="math inline">\(\vec
q_{k+1}&#39;\in L_{k+1}^\bot\setminus L\)</span>,使得<span class="math inline">\(B(\vec p_i,\vec
q_{k+1}&#39;)\begin{cases}1&amp;i=k+1\\0&amp;i\ne
k+1\end{cases}\)</span>满足.</p>
<p>此时注意到,如果用<span class="math inline">\(\vec q_{k+1}=\vec
q_{k+1}&#39;+\sum_i a_i\vec
p_i\)</span>后,上述条件实际上不受影响.然而,只需取<span class="math inline">\(a_i=B(\vec q_i,\vec
q_{k+1}&#39;)\)</span>就自动满足最后的条件.</p>
<p>接下来无非是要证明这些向量线性无关,对于<span class="math inline">\(\sum a_i\vec p_i+\sum b_i\vec
q_i=0\)</span>,两边取<span class="math inline">\(B(\_,\vec
q_i)\)</span>就可以得到<span class="math inline">\(a_i=0\)</span>,取<span class="math inline">\(B(\vec p_i,\_)\)</span>就可以得到<span class="math inline">\(b_i=0\)</span>,这样就做完了.</p>
<p>此时就可以见到,我们实际上是把原空间拆成了两个拉格朗日子空间的直和,并且这两个子空间之间以某种形式连接起来.此时其对应的矩阵就是:</p>
<p><span class="math display">\[
\begin{bmatrix}
&amp;&amp;&amp;&amp;&amp; 1\\
&amp;&amp;&amp;&amp; \cdots&amp;\\
&amp;&amp;&amp; 1&amp;&amp;\\
&amp;&amp; -1 &amp;&amp;&amp;\\
&amp;\cdots&amp;&amp;&amp;&amp;\\
-1&amp;&amp;&amp;&amp;&amp;
\end{bmatrix}
\]</span></p>
<p>另外,如果<span class="math inline">\(W\)</span>是<span class="math inline">\(V\)</span>的子空间并且满足<span class="math inline">\(W\cap
W^\bot=\{0\}\)</span>,我们称这样的子空间是<strong>辛子空间</strong>.只需套用拉格朗日子空间的过程就可以证明:</p>
<ol type="1">
<li><span class="math inline">\(W\)</span>是辛子空间当且仅当<span class="math inline">\(B\)</span>在<span class="math inline">\(W\)</span>上的限制非退化.</li>
<li><span class="math inline">\(W\)</span>是辛子空间则有直和分解<span class="math inline">\(V=W\oplus W^\bot\)</span>.</li>
</ol>
<h4><span id="回看对偶空间">回看对偶空间</span></h4>
<p>应当回忆我们将一个有限维空间对应到其对偶空间的时候所做的努力:先找到原空间的一组基,再对应地找到一组对偶基.然而,这种对应并非空间自身典范的对应,而是需要选定基的人为构造的定义.</p>
<p>回忆我们上述拿到的所有东西,应当可以见到起码以下资料均是典范的:</p>
<ol type="1">
<li>典范配对<span class="math inline">\(\langle\_,\_\rangle:V^\vee\times
V\to F,\langle\lambda,\vec v\rangle\mapsto \lambda\vec v\)</span>.</li>
<li>转置映射<span class="math inline">\(^tT:W^\vee\to V^\vee,\lambda
\mapsto\lambda T\)</span>.</li>
</ol>
<h5><span id="双重对偶">双重对偶</span></h5>
<p>先分析典范配对的情形,考虑到典范配对会给出一个映射<span class="math inline">\(ev_V:V\to (V^\vee)^\vee,\vec v\mapsto
\langle\_,\vec v
\rangle\)</span>.容易验证这当然是一个同构,而且中途没有用任何取基操作,所以这是一个典范的同构<span class="math inline">\(\text{ev}_V:V\cong
(V^\vee)^\vee\)</span>.更确切地来说,这个<span class="math inline">\(\text{ev}_V\)</span>具有某种函子性.事实上有以下交换图表:</p>
<p><span class="math display">\[
\xymatrix{
V\ar[r]^T\ar[d]_{\text{ev}_V}&amp;W\ar[d]^{\text{ev}_W}\\
(V^\vee)^\vee\ar[r]^{(T^t)^t}&amp;(W^\vee)^\vee
}
\]</span></p>
<p>虽属显然,但也可以小心地展开定义以确实证明<span class="math inline">\((\text{ev}_W)T=(T^t)^t\text{ev}_V\)</span>.策略只需任取<span class="math inline">\(\check w\)</span>,而观察:</p>
<p><span class="math display">\[
\langle ((T^t)^t\text{ev}_V)\vec v,\check w\rangle\\
=\langle (\text{ev}_V)\vec v,T^t\check w\rangle\\
=\langle T^t(\check w),\vec v\rangle\\
=\langle\check w,T\vec v\rangle\\
=\langle\text{ev}_W(T\vec v),\check w\rangle
\]</span></p>
<p>而<span class="math inline">\(\check w\)</span>可以任取,立刻证毕.</p>
<p>回忆到还有一件重要的事情需要解释,那就是柯里化<span class="math inline">\(\text{Hom}(W,V^\vee)\cong \text{Bil}(V,W;F)\cong
\text{Hom}(V,W^\vee)\)</span>.从表面上看,它应当是典范的,可实则描述的时候却发现总需要标准内积结构来体现.为解决这个问题,我们下面证明上述同构映射将<span class="math inline">\(\varphi\in \text{Hom}(W,V^\vee)\)</span>为<span class="math inline">\((\varphi^t)\circ \text{ev}_V\in
\text{Hom}(V,W^\vee)\)</span>.</p>
<p>考虑将两边都映射到典范配对的结构上,由双线性形式的定义,<span class="math inline">\(\varphi\in
\text{Hom}(W,V^\vee)\)</span>必然映一组<span class="math inline">\(\vec
w,\vec v\)</span>为<span class="math inline">\(\langle\varphi(\vec
w),\vec v\rangle\)</span>,这当然是显然的.</p>
<p>回看<span class="math inline">\((\varphi^t)\circ
\text{ev}_V\)</span>,它做到的是将一组<span class="math inline">\(\vec
w,\vec v\)</span>映射到<span class="math inline">\(\langle\text{ev}_V(\vec v),\varphi(\vec
w)\rangle\)</span>,可只需用<span class="math inline">\(\text{ev}_V(\vec
v)\)</span>的定义,上述两者当然是相同的.</p>
<p>再最后,我们终于回看基的选取,我们可以证明以下结论:设<span class="math inline">\(V\)</span>是有限维的向量空间,<span class="math inline">\(\vec v_1,\cdots,\vec v_n\in
V\)</span>是一组有序基,其对偶基记作<span class="math inline">\(\check
v_1,\cdots,\check v_n\)</span>.我们声称:<span class="math inline">\(V^\vee\)</span>中的一组元素<span class="math inline">\(\text{ev}_V(\vec v_1),\cdots,\text{ev}_V(\vec
v_n)\)</span>是<span class="math inline">\(\check v_1,\cdots,\check
v_n\)</span>的对偶基.也就是说中间不管怎么取对偶形态,最终总会回到一种典范的同构<span class="math inline">\(V\cong V^\vee\)</span>上.</p>
<p>至于证明,无非只是:</p>
<p><span class="math display">\[
\langle\text{ev}_V(\vec v_i),\check v_j\rangle=\langle\check v_j,\vec
v_i\rangle
\]</span></p>
<p>立属显然.</p>
<h5><span id="核余核与对偶映射">核,余核与对偶映射</span></h5>
<p>上述证明揭露了对偶空间的一角.之所以<span class="math inline">\(T^t\)</span>会显示出伴随性质,实际上并不是代数形式上的巧合,而恰是<span class="math inline">\(T^t\)</span>的定义本身就是典范配对上的伴随,而自然会以某种形式显示在新的伴随中.既如此,请以下内容再观<span class="math inline">\(T:V\to W\)</span>以及其转置<span class="math inline">\(T^t:W^\vee\to V^\vee\)</span>的性质.</p>
<p>首先,容易观察到的应该是<span class="math inline">\(T\)</span>单则<span class="math inline">\(T^t\)</span>满,<span class="math inline">\(T\)</span>满则<span class="math inline">\(T^t\)</span>单.此结论我们早就得出,策略是使用行秩等于列秩,而由同态基本定理得到<span class="math inline">\(\dim V=\dim \ker T+\text{rk}T\)</span>,如若<span class="math inline">\(T\)</span>单,则<span class="math inline">\(\dim
\ker T=0\)</span>,意味着<span class="math inline">\(\text{rk} T=\dim
V\)</span>,也就意味着<span class="math inline">\(\text{rk}T^t=\dim
V^\vee\)</span>,这就得到<span class="math inline">\(T^t\)</span>是满的.反之亦然同理.</p>
<p>然而回看<span class="math inline">\(\text{rk}T^t=\text{rk}T\)</span>这个结论的得出其实并不典范,我们推出此结论使用的策略是矩阵的相抵.而找到一种典范的证明此的策略便是重要的.而只需稍有对商操作的直觉就可以看到,要抛开矩阵,用一种真正典范的策略证明行秩等于列秩,必然离不开上述的引理.这就是我们下述真正想要做的事.</p>
<p>现在,设<span class="math inline">\(T\)</span>是单射,对于任给的<span class="math inline">\(\mu \in V^\vee\)</span>,尝试找到一个<span class="math inline">\(\tilde{\mu}\in W^\vee\)</span>使得<span class="math inline">\(\tilde{\mu}(T(x))=\mu(x)\)</span>,那根据对偶映射的定义,知道这里有<span class="math inline">\(T^t(\tilde{\mu})=\mu\)</span>.如果这里<span class="math inline">\(\mu\)</span>可以任选的话,换言之,对于任意的<span class="math inline">\(\mu\)</span>我们都能构造出一个<span class="math inline">\(\tilde{\mu}\)</span>来实现上述过程,当然意味着<span class="math inline">\(T^t\)</span>是满射.可既然这里是构造,我们终于可以放下”典范”的包袱,开始取基.</p>
<p>取<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(\mathcal{X}\)</span>,而<span class="math inline">\(T(\mathcal{X})\)</span>当然是<span class="math inline">\(W\)</span>的线性无关子集,可以扩展为一组基<span class="math inline">\(\mathcal{Y}\)</span>,这样<span class="math inline">\(\forall \vec w\in W\)</span>都有唯一的展开<span class="math inline">\(\sum_{\vec y\in \mathcal Y}c_y\vec
y\)</span>,对于给定的<span class="math inline">\(\mu\in
V^\vee\)</span>可以定义<span class="math inline">\(\tilde{\mu}:W\to
F\)</span>为:</p>
<p><span class="math display">\[
\tilde{\mu}(\sum_{y\in \mathcal Y}c_y\vec y)=\mu(\sum_{x\in \mathcal
X}c_{T(\vec x)\vec x})
\]</span></p>
<p>而当<span class="math inline">\(T\)</span>满的时候,设<span class="math inline">\(\tilde{\mu}\in W^\vee\)</span>,此时如果<span class="math inline">\(T^t(\tilde{\mu})=\tilde{\mu}T=0\)</span>,因为<span class="math inline">\(T\)</span>是满的,这必然意味着<span class="math inline">\(\tilde{\mu}=0\)</span>,所以<span class="math inline">\(T^t\)</span>当然是单的.</p>
<p>换句话说,这里通过空间上的结构,用基强行凑出了一个<span class="math inline">\(\ker
T\)</span>的结构.然而取基总是会让我们忽略空间的结构,并给人一种使用文字游戏偷懒的感觉.或者说,构造性证明必然会有一种失掉典范性的感觉.</p>
<p>现在我们重新展现一下上述取出<span class="math inline">\(\tilde{\mu}\)</span>的合理性:设<span class="math inline">\(T:V\to W\)</span>为线性映射,而<span class="math inline">\(\mu\in V^\vee\)</span>,我们声称存在<span class="math inline">\(\tilde{\mu}\in W^\vee\)</span>使得<span class="math inline">\(T^t(\tilde \mu)=\mu\)</span>当且仅当<span class="math inline">\(\mu|_{\ker T}=0\)</span>.</p>
<p>先证明充分性,当<span class="math inline">\(\mu|_{\ker
T}=0\)</span>的时候,不妨设<span class="math inline">\(\twoheadrightarrow\)</span>是满射而<span class="math inline">\(\hookrightarrow\)</span>是单射,如下交换图表当然成立:</p>
<p><span class="math display">\[
\xymatrix{
V \ar@{-&gt;&gt;}[r]^T \ar[d]_\mu \ar@{-&gt;&gt;}[dr]^\pi&amp;
\text{im}\ (T)\\
F&amp;V/\ker(T)\ar[l]^{\bar \mu}\ar@{^{(}-&gt;&gt;}[u]_{\bar T}
}
\]</span></p>
<p>左下三角形的成立性完全依赖于<span class="math inline">\(\mu|_{\ker
T}=0\)</span>的性质,而此时取一个<span class="math inline">\(\tilde{\mu_0}=\bar\mu\circ (\bar T)^{-1}\in
(\text{im}\ T)^{\vee}\)</span>,而由于<span class="math inline">\(\text{im}T\)</span>自然嵌入<span class="math inline">\(W\)</span>中,必有<span class="math inline">\(\text{im}(T)\hookrightarrow
W\)</span>,那也就意味着<span class="math inline">\(W^\vee\twoheadrightarrow
\text{im}(T)^\vee\)</span>,因此<span class="math inline">\(\tilde{\mu_0}\)</span>就可以延拓为<span class="math inline">\(\tilde{\mu}\in W^\vee\)</span>,交换图表给出:</p>
<p><span class="math display">\[
\tilde{\mu}T=\tilde{\mu_0}T=\bar{\mu}(\bar T)^{-1}T=\bar mu\circ \pi=\mu
\]</span></p>
<p>这就证明了充分性.至于必要性,由于<span class="math inline">\(T^t(\tilde \mu)=\tilde \mu T\)</span>,而<span class="math inline">\(\tilde \mu T|_{\ker T}=0\)</span>当然是显然的.</p>
<p>接下来回忆到余核<span class="math inline">\(\text{coker}(T)=W/\text{im}(T)\)</span>这个东西,尝试看看它和<span class="math inline">\(\ker
T\)</span>之间的关系,回忆到我们应该有包含映射<span class="math inline">\(i:\ker (T)\hookrightarrow V\)</span>和商映射<span class="math inline">\(q:W\twoheadrightarrow
\text{coker}(T)\)</span>,取对偶见到:</p>
<p><span class="math display">\[
\xymatrix{
\text{coker}(T)^\vee\ar@{^{(}-&gt;}[r]^{q^t}&amp;W^\vee\ar[r]^{T^t}&amp;V^\vee\ar@{-&gt;&gt;}[r]^{i^t}&amp;\ker(T)^\vee\\
\lambda\ar@{|-&gt;}[r]&amp;\lambda q&amp;&amp;\\
&amp; \tilde{\mu}\ar@{|-&gt;}[r]&amp; \tilde{\mu}T &amp; \\
&amp;&amp;\mu \ar@{|-&gt;}[r]&amp; \mu i
}
\]</span></p>
<p>这个当然没有问题,而我们试图借上面为辅助证明下面这张交换图表:</p>
<p><span class="math display">\[
\xymatrix{
\text{coker}(T)^\vee\ar@{^{(}-&gt;}[r]^{q^t} \ar@{^{(}-&gt;&gt;}[d]
&amp;W^\vee\ar[r]^{T^t}&amp;V^\vee\ar@{-&gt;&gt;}[r]^{i^t}\ar@{-&gt;&gt;}[rd]&amp;\ker(T)^\vee\\
\ker(T^t)\ar@{^{(}-&gt;}[ur]&amp; &amp; &amp;
\text{coker}(T^t)\ar@{^{(}-&gt;&gt;}[u]
}
\]</span></p>
<p>其中竖直方向的同构由左右两部分交换图表各自唯一确定.</p>
<p>先看左部分,我们尝试证明<span class="math inline">\(\text{coker}(T)^\vee\hookrightarrow
W^\vee\)</span>的像正好是<span class="math inline">\(\ker(T^t)\)</span>.</p>
<p>先证明<span class="math inline">\(q^t(\text{coker}(T)^\vee)\subseteq
\ker(T^t)\)</span>,考虑<span class="math inline">\(\lambda\in
\text{coker}(T)^\vee\)</span>,那<span class="math inline">\(q^t\)</span>会将其射到<span class="math inline">\(\lambda q\in W^\vee\)</span>.留意到<span class="math inline">\(T^t(\lambda q)=\lambda q T\)</span>,然而根据<span class="math inline">\(\text{coker}\)</span>的定义知道<span class="math inline">\(qT=0\)</span>,这必然意味着<span class="math inline">\(T^t(\lambda q)=0\)</span>.</p>
<p>再证明<span class="math inline">\(\ker(T^t)\subseteq
q^t(\text{coker}(T)^\vee)\)</span>,设<span class="math inline">\(\tilde{\mu}\in \ker{T^t}\)</span>,也就是说<span class="math inline">\(T^t(\tilde{\mu})=\tilde{\mu}T=0\)</span>,我们要找到一个<span class="math inline">\(\lambda\)</span>使得<span class="math inline">\(q^t(\lambda)=\lambda
q=\tilde{\mu}\)</span>,那么必然见到<span class="math inline">\(\lambda:\vec w+\text{im}(T)\mapsto
\tilde{\mu}(\vec w)\)</span>是满足条件的,只需验证<span class="math inline">\(\tilde{\mu}|_{\text{im}(T)}=0\)</span>,这恰好由<span class="math inline">\(T^t(\tilde{\mu})=\tilde{\mu}T=0\)</span>给出.</p>
<p>至于右半部分,就是我们上面所刻画的<span class="math inline">\(\tilde{\mu}\)</span>和<span class="math inline">\(\mu\)</span>的关系了,换言之<span class="math inline">\(\mu i=0\Leftrightarrow \exists
\tilde{\mu},\mu=\tilde{\mu}T\)</span>.</p>
<p>上述过程当然太过复杂了,尝试感性理解一下我们刚刚在做什么.我们的<span class="math inline">\(\ker T\)</span>的意义是,<span class="math inline">\(T:V\to
W\)</span>这个过程中所损失的信息对吧,那我们反观<span class="math inline">\(T^t:W^\vee\to V^\vee,\lambda\mapsto \lambda
T\)</span>这个过程中所损失的,也就是何时,<span class="math inline">\(\lambda
T=0\)</span>.由于这是两个映射,当然就等价于<span class="math inline">\(\forall \vec v\in V\)</span>,<span class="math inline">\(\lambda T\vec v=0\)</span>.当然就等价于<span class="math inline">\(\forall \vec u\in \text{im}(T)\)</span>,<span class="math inline">\(\lambda\vec u=0\)</span>,这必然等价于<span class="math inline">\(\ker \lambda\supseteq
\text{im}(T)\)</span>.所以这些<span class="math inline">\(\lambda\)</span>都可以表示为一个<span class="math inline">\(\tilde{\lambda}q\)</span>的形式,其中<span class="math inline">\(\ker q=\text{im}(T)\)</span>,取余核是刚刚好的.</p>
<h5><span id="像自对偶">像自对偶</span></h5>
<p>对于映射<span class="math inline">\(T:V\to
W\)</span>,我们下面将给出典范同构:</p>
<p><span class="math display">\[
\text{im}(T)^\vee\cong \text{im}(T^t)
\]</span></p>
<p>如上,商映射<span class="math inline">\(q:W\to
\text{coker}(T)\)</span>满足<span class="math inline">\(\ker
q=\text{im}(T)\)</span>,于是:</p>
<p><span class="math display">\[
\text{im}(T)^\vee\cong \text{coker}(q^t:\text{coker}(T)^\vee\to
W^\vee)\\
\cong \text{coker}(\ker T^t\hookrightarrow W^\vee)\\
=W^\vee/\ker (T^t)\\
\cong \text{im}(T^t)
\]</span></p>
<p>两边取<span class="math inline">\(\dim\)</span>,得知行秩等于列秩.</p>
<h3><span id="实内积空间">实内积空间</span></h3>
<p>考虑正定对称双线性形式<span class="math inline">\((\_\mid\_):V\times
V\to F\)</span>,这样的资料<span class="math inline">\((V,(\_\mid\_))\)</span>称为<strong>内积空间(IPS)</strong>.为了要一些<span class="math inline">\(\R\)</span>上的完备性质,我们下面主要讨论<span class="math inline">\(F=\R\)</span>的特殊情况.回忆道此时它应当满足的条件:</p>
<ol type="1">
<li>双线性:各位有分配律以及标量乘法.</li>
<li>对称性:<span class="math inline">\((\vec v\mid\vec w)=(\vec w\mid
\vec v)\)</span>.</li>
<li>正定性:<span class="math inline">\((\vec v\mid\vec v)\geq
0\)</span>,并且等号成立当且仅当<span class="math inline">\(\vec v=\vec
0\)</span>.</li>
</ol>
<p>回忆道二次型理论的时候我们曾经说过正定性是强于非退化的,因此内积一定是非退化的.</p>
<p>接下来定义<span class="math inline">\(\vec v\in
V\)</span>的<strong>长度</strong>为<span class="math inline">\(\Vert
\vec v\Vert=\sqrt{(\vec v\mid\vec v)}\)</span>,并且如果<span class="math inline">\((\vec v\mid \vec
w)=0\)</span>,则称它们<strong>正交</strong>,也写作<span class="math inline">\(\vec v\bot \vec
w\)</span>.同理可以定义正交空间<span class="math inline">\(V_0^\bot\)</span>.还将满足<span class="math inline">\(\Vert \vec v\Vert =1\)</span>的<span class="math inline">\(\vec v\)</span>称为<strong>单位向量</strong>.</p>
<h4><span id="勾股定理">勾股定理</span></h4>
<p>事实上可以写出所谓的<strong>配极化</strong>:<span class="math inline">\((\vec v_1\mid \vec v_2)=\frac{1}{2}(\Vert \vec
v_1+\vec v_2\Vert^2-\Vert \vec v_1\Vert^2-\Vert\vec
v_2\Vert^2)\)</span>.</p>
<p>这里可以看出内积上的勾股定理:也就是当<span class="math inline">\(\vec
v\bot \vec w\)</span>时<span class="math inline">\(\Vert \vec v+\vec
w\Vert^2=\Vert \vec v\Vert^2+\Vert \vec w\Vert^2\)</span>.</p>
<h4><span id="柯西不等式">柯西不等式</span></h4>
<p>即<span class="math inline">\((\vec v\mid\vec w)^2\leq (\vec
v\mid\vec v)(\vec w\mid \vec w)\)</span>,或言<span class="math inline">\((\vec v\mid\vec w)\leq \Vert\vec v\Vert\sdot
\Vert\vec w\Vert\)</span>.</p>
<p>等式成立当且仅当<span class="math inline">\(\vec v,\vec
w\)</span>线性相关,此时也是容易证明的,只需要讨论<span class="math inline">\(\vec v=t\vec w\)</span>以及反过来的情况即可.</p>
<p>当<span class="math inline">\(\vec v,\vec
w\)</span>线性无关时,那么<span class="math inline">\(\vec v\ne 0,\vec
w\ne 0\)</span>,于是<span class="math inline">\(\forall t,\vec v+t\vec
w\ne 0\)</span>.这会导致:</p>
<p><span class="math display">\[
0&lt;(\vec v+t\vec w\mid \vec v+t\vec w)=t^2(\vec w\mid \vec w)+2t(\vec
v\mid \vec w)+(\vec v\mid \vec v)
\]</span></p>
<p>将此看作关于<span class="math inline">\(t\)</span>的二次多项式,那它就没有实根,于是观察判别式<span class="math inline">\(\Delta=4(\vec v\mid \vec w)^2-4(\vec v\mid\vec
v)(\vec w\mid\vec w)&lt;0\)</span>就见到柯西不等式成立.</p>
<p>用柯西不等式还可以定义两个向量之间的夹角,设其为<span class="math inline">\(\angle(\vec v,\vec w)\)</span>,并定义<span class="math inline">\(\cos \angle(\vec v,\vec w)=\frac{(\vec v\mid \vec
w)}{\Vert \vec v\Vert\sdot \Vert \vec w\Vert}\)</span>.</p>
<p>值得一提的是,柯西准则实际上保证了如果空间本身是连续的,那么内积就一定是连续的,原因是假设一列<span class="math inline">\((\vec x_n,\vec y_n)\to (\vec x,\vec
y)\)</span>,无论以何种方式逼近,一定有:</p>
<p><span class="math display">\[
|(\vec x_n\mid \vec y_n)-(\vec x\mid \vec y)|\\
\leq |(\vec x_n-\vec x\mid \vec y_n)|+|(\vec x\mid \vec y_n-\vec y)|\\
\leq \Vert\vec x-\vec x_n\Vert\sdot \Vert\vec y_n\Vert+\Vert\vec
x\Vert\sdot \Vert\vec y_n-\vec y\Vert
\]</span></p>
<p>这样就可以将其控制住.</p>
<h4><span id="三角不等式">三角不等式</span></h4>
<p>先用配极化,再用柯西不等式得到:</p>
<p><span class="math display">\[
\Vert \vec v_1+\vec v_2\Vert^2=\Vert \vec v_1\Vert^2+\Vert\vec
v_2\Vert^2+2(\vec v_1\mid \vec v_2)\\
\leq \Vert \vec v_1\Vert^2+\Vert\vec v_2\Vert^2+2|(\vec v_1\mid \vec
v_2)|\\
\leq \Vert \vec v_1\Vert^2+\Vert\vec v_2\Vert^2+2\Vert \vec
v_1\Vert\sdot \Vert\vec v_2\Vert\\=(\Vert \vec v_1\Vert+\Vert\vec
v_2\Vert)^2\\
\]</span></p>
<h4><span id="距离相关">距离相关</span></h4>
<p>如上可以定义<strong>距离函数</strong><span class="math inline">\(d:V\times V\to \R_{\geq 0},(\vec v,\vec
w)\mapsto\Vert\vec w-\vec v\Vert\)</span>.容易见到其满足三角不等式<span class="math inline">\(d(\vec u,\vec v)+d(\vec v,\vec w)\geq d(\vec
u,\vec w)\)</span>.</p>
<h4><span id="正交向量族">正交向量族</span></h4>
<p>选取<span class="math inline">\(V\)</span>中的一组两两正交的非零元素,称其为<strong>正交向量族</strong>或者<strong>正交子集</strong>.特别地如果所有向量都是单位向量,则称其为<strong>单位正交向量族</strong>或者<strong>单位正交子集</strong>.容易见到正交向量族应该是线性无关的,原因是反证,如果<span class="math inline">\(\sum a_k\vec v_k=0\)</span>,两边对<span class="math inline">\(\vec v_k\)</span>做内积就可以得到<span class="math inline">\(a_k\Vert\vec
v_k\Vert^2=0\)</span>,根据正定性得到<span class="math inline">\(a_k=0\)</span>.</p>
<p>既然如此,我们就将由一个单位正交子集所给出的基称为<strong>单位正交基(ONB)</strong>.</p>
<p>如果我们能拿出一组<span class="math inline">\(n\)</span>个元素的单位正交基<span class="math inline">\(\langle\vec v_1,\cdots \vec
v_n\rangle\)</span>,那么考虑用这组有序基将<span class="math inline">\(V\to \R^n\)</span>.则注意到<span class="math inline">\(\forall \vec v\in V\)</span>,应当有:<span class="math inline">\(\vec v=\sum_k a_k\vec v_k\)</span>.并且两边对<span class="math inline">\(\vec v_k\)</span>取内积就可以见到<span class="math inline">\(a_k=(\vec v\mid \vec
v_k)\)</span>.我们可以证明在这组基的同构下原本的内积就同构于<span class="math inline">\(\R^n\)</span>上的标准内积(点乘).因此需要验证这个映射是否是保距的,事实上注意到:</p>
<p><span class="math display">\[
(\sum_i a_i\vec v_i \mid \sum_j b_j\vec v_j)\\
=\sum_{i,j}a_ib_j(\vec v_i\mid \vec v_j)\\
=\sum_i a_ib_i
\]</span></p>
<h4><span id="gram-schmidt-正交化">Gram-Schmidt 正交化</span></h4>
<p>问题现在在于单位正交基是否总是存在以及如何找到一个.我们先取一组向量$v_1,v_2,$线性无关(这里甚至允许可数无穷个向量),递归定义:</p>
<p><span class="math display">\[
\vec w_1=\vec v_1\\
\vec w_k=\vec v_k-\sum_{i=1}^{k-1}\frac{(\vec w_i\mid \vec v_k)}{(\vec
w_i\mid \vec w_i)}\vec w_i
\]</span></p>
<p>就可以取出一组正交基,之后只需令<span class="math inline">\(\vec
u_k=\frac{\vec w_k}{\Vert\vec
w_k\Vert}\)</span>就可以转化为一组单位正交基.事实上还可以注意到<span class="math inline">\(\langle\vec w_1,\cdots \vec w_k\rangle=\langle\vec
v_1,\cdots,\vec
v_k\rangle\)</span>.其构造思路是每次添加一个拥有两项的元素,一项要是前面的空间内的部分,另一部分不是,然而它们之和要与前面空间正交.</p>
<p>证明的话,注意到:<span class="math inline">\(\vec w_k\in \vec
v_k+\langle\vec w_1,\cdots,\vec
w_{k-1}\rangle\)</span>,因此数学归纳证明<span class="math inline">\(\langle\vec w_1,\cdots \vec w_k\rangle=\langle\vec
v_1,\cdots,\vec v_k\rangle\)</span>:</p>
<p><span class="math display">\[
\langle\vec w_1,\cdots,\vec w_k\rangle\\
=\langle\vec w_1,\cdots,\vec w_{k-1}\rangle+\langle \vec w_k\rangle\\
=\langle\vec v_1,\cdots,\vec v_{k-1}\rangle+\langle \vec v_k\rangle\\
=\langle\vec v_1,\cdots,\vec v_k\rangle
\]</span></p>
<p>此外上述的算法的优点在于如果<span class="math inline">\(\vec
v_k\)</span>已经和前面的<span class="math inline">\(\vec w_1,\cdots,\vec
w_{k-1}\)</span>正交,自然有<span class="math inline">\(\vec w_k=\vec
v_k\)</span>.</p>
<p>而验证正交无非是两边同时对<span class="math inline">\(\vec
w_j\)</span>做内积并继续归纳即可.</p>
<p>由上给出两个推论:</p>
<ol type="1">
<li>任何有限维内积空间都有单位正交基.</li>
<li>任何单位正交子集都可以扩充为一个单位正交基.</li>
</ol>
<p>(1)找到一组基用上述算法即可,(2)的话可以先扩充成基,再按照上述算法,而前面原本已经正交的部分不会改变.</p>
<h6><span id="example1ru分解">Example1(RU分解)</span></h6>
<p>观察上述Gram-Schmidt正交化过程就可以看到,对于一个矩阵<span class="math inline">\(A=(\vec v_1,\cdots,\vec
v_n)\)</span>,对其作正交化,每次相当于右乘(列变换)一个上三角矩阵(没有交换列的操作),最终变换的形态则会是一个正交矩阵.因此,任何一个可逆矩阵都可以被分解成<span class="math inline">\(RU\)</span>,其中<span class="math inline">\(R\)</span>是一个正交矩阵,<span class="math inline">\(U\)</span>是一个上三角矩阵.</p>
<h6><span id="example2legendre多项式">Example2(Legendre多项式)</span></h6>
<p>考虑<span class="math inline">\(\R\)</span>上的多项式组成的<span class="math inline">\(\R-\)</span>向量空间<span class="math inline">\(\R[x]\)</span>,定义内积<span class="math inline">\((f\mid g)=\int_{-1}^1f(x)g(x)\text d
x\)</span>,容易见到其满足定义.此外,<span class="math inline">\(\R[x]\)</span>的一组自然的基是<span class="math inline">\(\langle 1,x,x^2\cdots\rangle\)</span>.</p>
<p>是否可以对其进行正交化呢?考虑限制得到的单位正交基的最高次系数均为<span class="math inline">\(1\)</span>,容易见到这组单位正交基如此便被唯一刻画,并且必然是上述做Gram-Schmidt正交化的产物.</p>
<p>既然如此,我们接下来尝试检验<span class="math inline">\(P_0=1,P_n=\frac{1}{2^nn!}((x^2-1)^n)^{(n)}\)</span>就是一组正交基.我们声称以下命题成立:</p>
<ol type="1">
<li><span class="math inline">\([x^n]P_n=\frac{(2n)!}{2^n(n!)^2}\)</span>.</li>
<li><span class="math inline">\(P_n(1)=1\)</span>.</li>
<li>当<span class="math inline">\(0\leq k&lt;n\)</span>时,<span class="math inline">\(\int_{-1}^1t^kP_n(t){\rm
d}t=0\)</span>.作为此的一个推论,<span class="math inline">\(n\ne
m\)</span>的时候<span class="math inline">\(\int_{-1}^1P_m(t)P_n(t){\rm
d}t=0\)</span>.</li>
<li><span class="math inline">\(P_n(-t)=(-1)^nP_n(t)\)</span>.</li>
<li><span class="math inline">\(\int_{-1}^1P_n(t)^2{\rm
d}t=\frac{2}{2n+1}\)</span>.</li>
<li>递归式:<span class="math inline">\((n+1)P_{n+1}=(2n+1)x(P_n)-nP_{n-1}\)</span>.</li>
</ol>
<p>对于(1),讨巧的策略是直接看<span class="math inline">\(\lim_{x\to
\infty}\frac{P_n}{x^n}\)</span>,而于此使用洛必达法则上下求导<span class="math inline">\(n\)</span>次,立刻证毕.</p>
<p>对于(2),考虑<span class="math inline">\((x^2-1)=(x-1)(x+1)\)</span>,用Leibniz律求导,得到<span class="math inline">\(P_n(1)=\frac{1}{2^nn!}n!(1+1)^n=1\)</span>.</p>
<p>对于(3),只需分部积分,每次将<span class="math inline">\(P_n(t)\)</span>给扔到<span class="math inline">\(\rm d\)</span>里,这样前面的<span class="math inline">\(t^k\)</span>就会被不断消耗,最终得到结果.</p>
<p>对于(4),考虑在求导前的部分当然都是一样的,因此只是求导的时候,<span class="math inline">\(P_n(t)\)</span>是<span class="math inline">\(\frac{1}{({\rm d}t)^n}\)</span>,而<span class="math inline">\(P_n(-t)=\frac{1}{(({\rm d})(-t))^n}\)</span>.</p>
<p>对于(5),把<span class="math inline">\(P_n(t)^2=P_n(t)\times
P_n(t)\)</span>,然后使用分部积分,得到的结果当然就是:</p>
<p><span class="math display">\[
(-1)^n\frac{(2n)!}{(2^nn!)^2}\int_{-1}^1(t^2-1)^n{\rm d} t\\
=2(-1)^n\frac{(2n)!}{(2^nn!)^2}\int_{0}^1(t^2-1)^n{\rm d} t\\
=2\frac{(2n)!}{(2^nn!)^2}\int_{0}^1(1-t^2)^n{\rm d} t\\
\]</span></p>
<p>做换元<span class="math inline">\(\cos \theta=t\)</span>,则:</p>
<p><span class="math display">\[
2\frac{(2n)!}{(2^nn!)^2}\int_{0}^1(1-t^2)^n{\rm d} t\\
=2\frac{(2n)!}{(2^nn!)^2}\int_{0}^{\frac{\pi}{2}}\sin(t)^{2n+1}{\rm
d}t\\
=2\frac{(2n)!}{(2^nn!)^2}\frac{(2n)!!}{(2n+1)!!}\\
=2\frac{(2n)!}{(2^nn!)^2}\frac{(2^nn!)^2}{(2n+1)!}\\
=\frac{2}{2n+1}
\]</span></p>
<p>于是证毕.</p>
<p>对于(6),考虑既然上述Legendre多项式是一组基,那么<span class="math inline">\(xP_n\)</span>作为一个<span class="math inline">\(n+1\)</span>次多项式,理应可以被表示出来.也就是有:</p>
<p><span class="math display">\[
xP_n=\sum_{k=0}^{n+1} a_k P_{k}
\]</span></p>
<p>两边对<span class="math inline">\(P_{k},k\leq
n-2\)</span>做内积,那么左侧就是<span class="math inline">\(\int_{-1}^1(xP_k(x))P_n(x){\rm
d}x\)</span>,此时考虑<span class="math inline">\(xP_k(x)\)</span>是一个<span class="math inline">\(k+1&lt;n\)</span>次多项式,所以左侧理应为<span class="math inline">\(0\)</span>,于是右侧的<span class="math inline">\(a_k=0\)</span>.上式被我们简化为:</p>
<p><span class="math display">\[
xP_n=a_nP_{n+1}+b_nP_{n}+c_nP_{n-1}
\]</span></p>
<p>考虑两边提取<span class="math inline">\([x^{n+1}]\)</span>,立刻知道<span class="math inline">\(a_n=\frac{n+1}{2n+1}\)</span>.</p>
<p>两边对<span class="math inline">\(P_n\)</span>做内积,注意到<span class="math inline">\(x(P_n)^2\)</span>是一个奇函数,所以左边为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(b_n=0\)</span>.</p>
<p>接下来是<span class="math inline">\(c_n\)</span>.考虑<span class="math inline">\((xP_n\mid P_{n-1})=(P_n\mid
xP_{n-1})\)</span>,而由刚才的<span class="math inline">\(a_n\)</span>,<span class="math inline">\(xP_{n-1}=\frac{n}{2n-1}P_n+P&#39;\)</span>,因此立刻见到<span class="math inline">\(c_n=\frac{n}{2n+1}\)</span>,这就得证了.</p>
<h4><span id="正交算子">正交算子</span></h4>
<p>如果拿出两个内积空间,并能找到一个映射<span class="math inline">\(\varphi:V\to W\)</span>使得保<span class="math inline">\(\Vert\varphi(\vec v)\Vert_W=\Vert\vec
v\Vert_V\)</span>,那么称其为<strong>保距同构</strong>.用配极化容易见到保距同构一定保持了内积.容易见到如果<span class="math inline">\(\varphi\)</span>是同构,那么<span class="math inline">\(\varphi^{-1}\)</span>当然也是同构的.</p>
<p>考虑取两个有限维内积空间<span class="math inline">\(V,W\)</span>.由于内积非退化并且对称,于是应当对于所有线性映射<span class="math inline">\(T:V\to W\)</span>都有伴随<span class="math inline">\(T^*:W\to V\)</span>使得<span class="math inline">\((T\vec v\mid \vec w)_W=(\vec v\mid T^* \vec
w)_V\)</span>并且<span class="math inline">\((T^*\vec w\mid \vec
v)_V=(\vec w\mid T\vec v)_W\)</span>.</p>
<p>接下来我们尝试证明:<span class="math inline">\(T\)</span>是保距同构当且仅当<span class="math inline">\(T^*=T^{-1}\)</span>.</p>
<p>先证必要性:当<span class="math inline">\(T\)</span>是保距同构的时候,见到<span class="math inline">\(T^{-1}\)</span>必然也是同构,这就意味着<span class="math inline">\((T\vec v\mid \vec w)_W=(T^{-1}T\vec v\mid
T^{-1}\vec w)_V=(\vec v\mid T^{-1}\vec w)_V\)</span>对于<span class="math inline">\(\forall \vec v,\vec
w\)</span>都成立,这当然意味着<span class="math inline">\(T^*=T^{-1}\)</span>.</p>
<p>再证充分性,当<span class="math inline">\(T^*=T^{-1}\)</span>时,考虑<span class="math inline">\((T\vec v_1\mid T\vec v_2)_W=(\vec v_1\mid T^*T\vec
v_2)_V=(\vec v_1\mid \vec v_2)_V,\forall \vec v_1,\vec
v_2\)</span>,这就意味着其是保距同构.</p>
<p>另外还可以证明如果<span class="math inline">\(\vec v_1,\cdots,\vec
v_n\)</span>是<span class="math inline">\(V\)</span>的单位正交基时,<span class="math inline">\(T\)</span>是保距同构当且仅当<span class="math inline">\(T\vec v_1,\cdots,T\vec v_n\)</span>是<span class="math inline">\(W\)</span>的单位正交基.</p>
<p>必要性源于保距同构保持了关于内积的一切性质,因此显然.接下来考虑充分性,如果<span class="math inline">\(T\vec v_1,\cdots,T\vec v_n\)</span>是<span class="math inline">\(W\)</span>的单位正交基,那么:</p>
<p><span class="math display">\[
\Vert\sum_k a_k\vec v_k\Vert_V^2=\sum_k a_k^2\\
\Vert T(\sum_k a_k\vec v_k)\Vert_W^2=\Vert\sum_k a_k(T\vec
v_k)\Vert^2_W=\sum_k a_k^2
\]</span></p>
<p>这意味着其保距.并且<span class="math inline">\(\dim V=n=\dim
W\)</span>意味着是同构.</p>
<p>接下来定义有限维内积空间的自同构称为<span class="math inline">\(V\)</span>上的<strong>正交变换</strong>.现在不妨假设<span class="math inline">\(V=\R^n\)</span>并将视角转移到标准内积上(此时应当有<span class="math inline">\(A^*=A^T\)</span>)尝试使用矩阵来描述该问题.容易见到以下命题等价,并将满足下列性质的矩阵称为<strong>实正交矩阵</strong>:</p>
<ol type="1">
<li><span class="math inline">\(A^{-1}=A^T\)</span>.</li>
<li><span class="math inline">\(A\)</span>相对于标准内积是正交变换.</li>
</ol>
<p>由此得到以下推论:</p>
<ol type="1">
<li>单位矩阵是正交矩阵.</li>
<li>如果<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是正交矩阵,那么<span class="math inline">\(AB\)</span>亦然.</li>
<li>如果<span class="math inline">\(A\)</span>是正交矩阵,则<span class="math inline">\(A^T,A^{-1}\)</span>均亦然.</li>
<li>正交矩阵的行列式为<span class="math inline">\(\pm 1\)</span>.</li>
<li>对于矩阵<span class="math inline">\(A=(\vec v_1,\cdots,\vec
v_n)\)</span>,<span class="math inline">\(A\)</span>是正交矩阵当且仅当<span class="math inline">\(\vec v_1,\cdots,\vec
v_n\)</span>是一组单位正交基.</li>
<li>正交矩阵的特征值(无论实复)必然满足<span class="math inline">\(|\lambda|=1\)</span>.</li>
</ol>
<p>(1)(2)(3)显然,(4)则是因为<span class="math inline">\((\det A)^2=\det
(A^T)\det A=1\)</span>.</p>
<p>(5)的话原因是<span class="math inline">\(\R\)</span>下<span class="math inline">\(\vec e_1,\cdots \vec
e_n\)</span>是一组标准正交基,而<span class="math inline">\(\vec
v_k=A\vec
e_k\)</span>,因此根据前面提到的正交矩阵对标准正交基的转译性质即证毕.</p>
<p>(6)的话,考虑标准内积空间<span class="math inline">\((A\vec v\mid
A\vec v)\)</span>,其中<span class="math inline">\(\vec
v\)</span>是以<span class="math inline">\(\lambda\)</span>为特征值的特征向量,那么首先,<span class="math inline">\((A\vec v\mid A\vec v)=|\lambda|^2(\vec v\mid \vec
v)\)</span>,另一方面,其又是<span class="math inline">\(((A\vec
v)^t)(A\vec v)=(\vec v\mid \vec v)\)</span>.这就完事了.</p>
<h4><span id="正交补空间">正交补空间</span></h4>
<p>取<span class="math inline">\(S\)</span>为<span class="math inline">\(V\)</span>的任意子集,则称<span class="math inline">\(S^\bot=\{\vec v\in V\mid \forall \vec s\in S,(\vec
s\mid \vec v)=0\}\)</span>为<span class="math inline">\(S\)</span>的<strong>正交补空间</strong>.</p>
<p>虽然在此定义下<span class="math inline">\(S\)</span>无需是子空间,但仍见到<span class="math inline">\(S^\bot\)</span>自动对加法和纯量乘法封闭,因此<span class="math inline">\(S^\bot\)</span>仍是一个子空间.然而其实这里<span class="math inline">\(S^\bot=(\langle
S\rangle)^\bot\)</span>,这当然是显然的,因此后面只关注<span class="math inline">\(S=V_0\)</span>是<span class="math inline">\(V\)</span>的子空间的情况.</p>
<p>虽然之前我们做双线性形式的时候正交空间并没有太好的性质,但此时对于内积的情况有,我们声称<span class="math inline">\(V=V_0\oplus V_0^\bot\)</span>.原因是任取一组<span class="math inline">\(V_0\)</span>的单位正交基<span class="math inline">\(\vec v_1,\cdots,\vec v_m\)</span>,注意到<span class="math inline">\(\vec v=\sum_{k}(\vec v_k\mid \vec v)\vec v_k+(\vec
v-\sum_{k}(\vec v_k\mid \vec v)\vec v_k)\)</span>,前者显然属于<span class="math inline">\(V_0\)</span>,而后者只需逐个对<span class="math inline">\(\vec v_k\)</span>做内积就可以验证其属于<span class="math inline">\(V_0^\bot\)</span>.不妨将前者称为<span class="math inline">\(\vec v\)</span>在<span class="math inline">\(V_0\)</span>上的正交投影.并将<span class="math inline">\(P:V\to V_0,\vec v\mapsto \vec
v_0\)</span>称作正交投影算子,其中<span class="math inline">\(\vec v=\vec
v_0+\vec v_1\)</span>,<span class="math inline">\(\vec v_0\in V_0,\vec
v_1\in V_0^\bot\)</span>.另外,观察到伴随映射有<span class="math inline">\((\text{im}\ T)^\bot =\ker T^*\)</span>,见到<span class="math inline">\(V=\ker T^*+\text{im}\ T\)</span>.</p>
<p>取<span class="math inline">\(V_0\subseteq V\)</span>,并且取<span class="math inline">\(V=V_0\oplus V_0^\bot\)</span>,考虑<span class="math inline">\(P\)</span>映射是从<span class="math inline">\(V\)</span>到<span class="math inline">\(V_0\)</span>的投影,那么<span class="math inline">\(\forall \vec v\)</span>,<span class="math inline">\(\min_{\vec u\in V_0}\Vert\vec u-\vec
v\Vert\)</span>在<span class="math inline">\(\vec u=P\vec
v\)</span>的时候取最小.原因是不妨设<span class="math inline">\(\vec
v=\vec v_0+\vec v_1\)</span>,使用勾股定理:</p>
<p><span class="math display">\[
\Vert \vec u-\vec v\Vert^2\\
=\Vert \vec u-\vec v_0-\vec v_1\Vert^2\\
=\Vert \vec u-\vec v_0\Vert^2+\Vert\vec v_1\Vert^2\\
\geq \Vert\vec v_1\Vert^2
\]</span></p>
<p>此时仔细观察投影算子<span class="math inline">\(P: V\to
V_0\)</span>,应当可以将<span class="math inline">\(P\)</span>视作<span class="math inline">\(\text{End}(V)\)</span>中的某元素,我们下面证明<span class="math inline">\(P\)</span>是正交投影算子当且仅当<span class="math inline">\(P^*=P\)</span>和<span class="math inline">\(P^2=P\)</span>同时成立.</p>
<p>先证明必要性:仍选择将<span class="math inline">\(\vec v=\vec v_0+\vec
v_1\)</span>,其中<span class="math inline">\(\vec v_0\in
V_0\)</span>而<span class="math inline">\(\vec v_1\in
V_0^\bot\)</span>,此时<span class="math inline">\(P\vec v=\vec
v_0\)</span>,而<span class="math inline">\(P^2\vec v=\vec v_0=P\vec
v\)</span>,因此<span class="math inline">\(P^2=P\)</span>总是成立.另外如果有<span class="math inline">\(\vec v&#39;=\vec v_0&#39;+\vec
v_1&#39;\)</span>,那么应当注意到:</p>
<p><span class="math display">\[
(P\vec v\mid \vec v&#39;)\\
=(\vec v_0\mid \vec v&#39;)
=(\vec v_0\mid \vec v_0&#39;)=(\vec v\mid \vec v_0&#39;)\\
=(\vec v\mid P\vec v&#39;)
\]</span></p>
<p>然后证明充分性,直接取<span class="math inline">\(V_0=\text{im}(P)\)</span>,那么<span class="math inline">\(\forall \vec v\in V\)</span>当然<span class="math inline">\(\exists \vec u\)</span>有<span class="math inline">\(\vec v=P\vec u+\vec v_1\)</span>.此时注意到<span class="math inline">\(P\vec v=P\vec u+P\vec v_1\)</span>.观察发现<span class="math inline">\((P\vec v_1\mid P\vec v_1)=(P^*P\vec v_1\mid \vec
v_1)=(P\vec v_1\mid \vec v_1)\)</span>,然而<span class="math inline">\(\vec v_1\in V_0^\bot\)</span>而<span class="math inline">\(P\vec v_1\in V_0\)</span>,于是<span class="math inline">\((P\vec v_1\mid P\vec v_1)=0\)</span>,于是<span class="math inline">\(P\vec v_1=0\)</span>.因此<span class="math inline">\(P\vec v=P\vec u\)</span>.</p>
<p>接下来定义一个正交投影算子的<strong>镜像</strong>为<span class="math inline">\(2P-\text{id}_V\)</span>,其将<span class="math inline">\(\vec v_0+\vec v_1\)</span>映射到<span class="math inline">\(\vec v_0-\vec v_1\)</span>上.我们想要证明如果<span class="math inline">\(P\)</span>是正交投影算子,那么<span class="math inline">\(2P-\text{id}_V\)</span>是正交变换.容易检验<span class="math inline">\((2P-\text{id}_V)^*=(2P-\text{id}_V)\)</span>,那就只需要验证:</p>
<p><span class="math display">\[
(2P-\text{id}_V)^*(2P-\text{id}_V)\\
=(2P-\text{id}_V)(2P-\text{id}_V)\\
=4P^2-4P+\text{id}_V\\
=\text{id}_V
\]</span></p>
<p>还可以证明:如果<span class="math inline">\(V_0\)</span>是<span class="math inline">\(T\)</span>不变子空间,那么<span class="math inline">\((V_0)^\bot\)</span>是<span class="math inline">\(T^*\)</span>的不变子空间,证明的话只需考虑<span class="math inline">\((T^*\vec w\mid \vec v)=(\vec w\mid T\vec
v)=0\)</span>,其中<span class="math inline">\(\vec v\in
V_0\)</span>而<span class="math inline">\(\vec w\in
(V_0)^\bot\)</span>.这将为我们把空间分解为<span class="math inline">\(V_0\oplus
(V_0)^\bot\)</span>提供帮助.更详细的讨论将在自伴算子处讨论.</p>
<h4><span id="投影矩阵">投影矩阵</span></h4>
<p>考虑向量空间<span class="math inline">\(V\)</span>和<span class="math inline">\(A_1,\cdots,A_s\in \text{End}(V)\)</span>,满足<span class="math inline">\(A_1+\cdots+A_s=\text{id}\)</span>,并且<span class="math inline">\(\forall i\ne j,A_iA_j=0\)</span>,而且<span class="math inline">\(A_i^2=A_i\)</span>.</p>
<p>此时令<span class="math inline">\(V_i=\text{im}(A_i)\)</span>.我们下面证明以下三条事实:</p>
<ol type="1">
<li><span class="math inline">\(A_i(\sum \vec v_k)=\vec
v_i\)</span>,其中<span class="math inline">\(\vec v_k\in
V_k\)</span>.</li>
<li><span class="math inline">\(V=\bigoplus V_k\)</span>.</li>
<li>若<span class="math inline">\(A^2=A\)</span>,则<span class="math inline">\(V=\text{im}(A)\oplus
\text{im}(\text{id}-A)=\text{im}A+\ker A\)</span>.</li>
</ol>
<p>(1)显然.</p>
<p>考虑(2)的证明,由于<span class="math inline">\(V=\text{im}(\text
{id})\subseteq \sum V_k\subseteq V\)</span>,于是<span class="math inline">\(\sum V_k=V\)</span>.只需再证明<span class="math inline">\(\forall k,V_k\cap (\sum _{j\ne k}V_j)=\{\vec
0\}\)</span>即可.而<span class="math inline">\(\forall \vec w\in
V_k\)</span>,考虑<span class="math inline">\(A_k(\vec w)=\vec
w\)</span>但<span class="math inline">\(A_k(\sum _{j\ne
k}V_j)=0\)</span>,这意味着<span class="math inline">\(\vec w\notin (\sum
_{j\ne k}V_j)\)</span>,这就证毕了.</p>
<p>考虑(3)的证明,只需检验<span class="math inline">\(A(\text
{id}-A)=0\)</span>,这是显然的.</p>
<p>而在特征为<span class="math inline">\(0\)</span>的域上,我们尝试证明更强一点的结论:当<span class="math inline">\(\sum
A_k=\text{id}\)</span>的时候,以下三条命题等价:</p>
<ol type="1">
<li>对于每个<span class="math inline">\(i\)</span>都有<span class="math inline">\(A_i^2=A_i\)</span>.</li>
<li><span class="math inline">\(\sum \text{rk}(A_i)=\dim
V\)</span>.</li>
<li><span class="math inline">\(\forall i\ne j\)</span>,<span class="math inline">\(A_iA_j=0=A_jA_i\)</span>.</li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)的话考虑对于单个<span class="math inline">\(A_i\)</span>,我们上面已经证明过当<span class="math inline">\(A_i^2=A_i\)</span>的时候应当有直和分解<span class="math inline">\(V=\text{im}(A_i)\oplus
\text{im}(\text{id}-A_i)\)</span>,此时任取一组基限制在<span class="math inline">\(\text{im}(A_i)\)</span>上都是恒等变换,于是<span class="math inline">\(\text{tr}(A_i)=\text{rk}(A_i)\)</span>.这个证明可能略有口胡,或者你直接观察<span class="math inline">\(A_i\)</span>的极小多项式为<span class="math inline">\(x(x-1)=0\)</span>,立刻得到其可对角化并且对角上只有<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>,并且只划分了两个子空间<span class="math inline">\(V_0\)</span>和<span class="math inline">\(V_1\)</span>,再用迹对于相似不变就可以得到<span class="math inline">\(\text{tr}(A_i)=\text{rk}(A_i)\)</span>.于是<span class="math inline">\(\sum \text{rk}(A_i)=\sum
\text{tr}(A_i)=\text{tr}(\text{id})=\dim V\)</span>.</p>
<p>(2)$<span class="math inline">\((3)的话,考虑同上用\)</span>V=()V_kV<span class="math inline">\(,所以\)</span>V_k=V<span class="math inline">\(.这就可以看到同态\)</span>:V_kV,(v_i)v_i<span class="math inline">\(是满的,比较维数就知道\)</span><span class="math inline">\(,所以这是同构.这意味着\)</span>k,j,(A_k)(A_j)={}<span class="math inline">\(.而我们知道\)</span>(A_k)A_kV<span class="math inline">\(,在这里的直和应该直接表现为\)</span>(A_k)+A_k=
V<span class="math inline">\(,这样就直接把\)</span>A_j<span class="math inline">\(扔进了\)</span>A_k$里面.</p>
<p>(3)$<span class="math inline">\((1)是简单的,原因是\)</span>A_k=A_k(_{jk}A_j)+A_kA_k$.</p>
<p>如果我们将满足<span class="math inline">\(A^2=A\)</span>的矩阵称为投影矩阵的话,可以发现一个矩阵是投影矩阵的必要条件是<span class="math inline">\(\ker A+\text{im}\
A=V\)</span>.然而并不充分,除非再加上<span class="math inline">\(A(I-A)=0\)</span>.</p>
<h4><span id="自伴算子">自伴算子</span></h4>
<p>对于一个内积空间<span class="math inline">\((V,(\_,\_)\
)\)</span>,其中<span class="math inline">\(\dim V=n\)</span>.</p>
<p>称一个映射是<strong>自伴的</strong>,当且仅当<span class="math inline">\(T=T^*\)</span>.我们下面尝试证明如果<span class="math inline">\(T\)</span>是自伴的,那么<span class="math inline">\(T\)</span>可以正交对角化.换言之存在正交映射<span class="math inline">\(P\)</span>使得<span class="math inline">\(P^{-1}TP=P^*TP\)</span>是对角的.另外,如果<span class="math inline">\(T\)</span>可以正交对角化,那么也仅当<span class="math inline">\(T=T^*\)</span>.原因当然显然,因为只需两边取伴随即可见得.</p>
<p>对<span class="math inline">\(n=\dim
V\)</span>进行归纳,下面不妨假设<span class="math inline">\(n\geq
2\)</span>.</p>
<p>回忆到这个内积空间应该可以同构于标准内积空间<span class="math inline">\((\R^n,\sdot)\)</span>,因此将自伴算子同构于<span class="math inline">\(A^T=A^*=A\)</span>的矩阵.假设可以找到<span class="math inline">\(T\)</span>的某一个实特征值<span class="math inline">\(\lambda_1\)</span>,我们就可以取其对应的特征向量<span class="math inline">\(\vec v_1\ne 0\)</span>并且满足<span class="math inline">\(T\vec v_1=\lambda_1\vec v_1\)</span>,而且满足<span class="math inline">\(\Vert\vec v_1\Vert=1\)</span>,并设<span class="math inline">\(V_0=\text{span}(\vec
v_1)\)</span>,回忆到我们有正交直和分解<span class="math inline">\(V=V_0\oplus(V_0^\bot)\)</span>.</p>
<p>此时观察,既然<span class="math inline">\(V_0\)</span>是<span class="math inline">\(T\)</span>不变子空间,我们之前证明了<span class="math inline">\(V_0^\bot\)</span>是<span class="math inline">\(T^*=T\)</span>的不变子空间,既然如此,<span class="math inline">\(T\)</span>限制在<span class="math inline">\(V_0^\bot\)</span>上就仍然自伴,这样就可以进行数学归纳.</p>
<p>那么怎么找到<span class="math inline">\(T\)</span>的一个实特征值呢?为了证明这个定理,我们可能需要先跳出实数域而在复数域上做一些操作.在复数域上的好处在于可以定义共轭,具体地容易发现<span class="math inline">\(\overline{A+B}=\bar A+\bar B\)</span>以及<span class="math inline">\(\overline{A\times B}=\bar A\times \bar
B\)</span>.</p>
<p>对于复数域上的矩阵,我们约定<span class="math inline">\(A^\dagger=\bar{A^T}\)</span>,注意到<span class="math inline">\(\lambda^\dagger=\bar
\lambda\)</span>,并且理应有<span class="math inline">\((AB)^\dagger=B^\dagger
A^\dagger\)</span>.此时取<span class="math inline">\(\vec
v=(z_1,\cdots,z_n)\in \mathbb{C}^n\)</span>,注意到<span class="math inline">\((\vec v)^\dagger(\vec v)=\sum |z_k|^2\in \R_{\geq
0}\)</span>,并且其等于<span class="math inline">\(0\)</span>当且仅当<span class="math inline">\(\vec
v =0\)</span>.</p>
<p>下面我们证明:当<span class="math inline">\(A^\dagger=cA,c\in
\mathbb{C}\)</span>,那么<span class="math inline">\(A\)</span>的所有特征值都满足<span class="math inline">\(\bar \lambda =
c\lambda\)</span>.不过容易见到这里只能取<span class="math inline">\(c=\pm 1\)</span>,原因是<span class="math inline">\(c^2=1\)</span>.这个性质我们会在后面复内积空间中的hermite形式中进一步用到.</p>
<p>证明的话,考虑<span class="math inline">\(\vec v\ne
0\)</span>是以<span class="math inline">\(\lambda \in
\C\)</span>为特征值的特征向量,那么我们考虑<span class="math inline">\((\vec v)^\dagger(A\vec v)=(\vec
v)^\dagger(\lambda)\vec v\)</span>.此时两边取<span class="math inline">\(\dagger\)</span>,左边给出<span class="math inline">\((\vec v)^\dagger A^\dagger\vec v=c(\vec v)^\dagger
A \vec v=c\lambda(\vec v)^\dagger\vec v\)</span>,而右边给出<span class="math inline">\(\bar \lambda (\vec v)^\dagger(\vec
v)\)</span>,这样就证明了上述结论.</p>
<p>那么这样做的意义是什么呢?已经知道实数上的自伴算子满足<span class="math inline">\(A^\dagger =A\)</span>,也就是在上面<span class="math inline">\(c=1\)</span>,那意味着<span class="math inline">\(\lambda=\bar \lambda\)</span>,意味着<span class="math inline">\(\lambda\)</span>是实数.然而,由于在<span class="math inline">\(\C\)</span>是代数闭的,那么就一定可以找到至少一个复特征值,由上知道这些特征值还都是实数,那我们就补上了上述证明的最后一步.</p>
<p>于是,回忆到直和与分块矩阵的关系,将我们拿到的这些特征向量做正交化后,取<span class="math inline">\(P\)</span>为这些单位正交基<span class="math inline">\(\vec v_1,\cdots,\vec
v_n\)</span>为列向量的矩阵,那么<span class="math inline">\(P^{-1}AP=\begin{bmatrix}\lambda_1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;\lambda_n\end{bmatrix}\)</span>.</p>
<p>或者直接来看,我们断言自伴算子对应的特征子空间一定互相正交,原因是设它们分别是<span class="math inline">\(V_{\lambda_1},V_{\lambda_2}\)</span>,那么<span class="math inline">\(\lambda_1(\vec v_1\mid \vec v_2)=(T\vec v_1\mid
\vec v_2)=(\vec v_1\mid T\vec v_2)=\lambda_2(\vec v_1\mid \vec
v_2)\)</span>.这就必然给出<span class="math inline">\((\vec v_1\mid \vec
v_2)=0\)</span>.那只需先求特征向量,然后对此施加Gram-Schmidt正交化就赢了.</p>
<h5><span id="实sylvester-判准">(实)Sylvester 判准</span></h5>
<p>将一个矩阵的左上的<span class="math inline">\(k\times
k\)</span>的矩阵称为<span class="math inline">\(A\)</span>的顺序主子式.</p>
<p>容易发现,实对称矩阵正定当且仅当其所有特征值皆正,原因是正交对角化后的结果.</p>
<p>由此可以得到Sylvester判准,也就是一个实对称矩阵正定当且仅当其所有顺序主子式皆正.</p>
<p>必要性显然,把线性空间限制在左上角的那个<span class="math inline">\(k\times
k\)</span>里,如果有某个顺序主子式是负的,那就存在负的特征值.</p>
<p>下面证明充分性:考虑数学归纳,当<span class="math inline">\(n\geq
2\)</span>的时候,假设<span class="math inline">\(A\)</span>的每个顺序主子式都是正的,我们下面试图证明其所有特征值都是正的.记其特征值为<span class="math inline">\(\lambda_1,\cdots,\lambda_n\)</span>,必定有等式<span class="math inline">\(\lambda_1\cdots\lambda_n=\det
A&gt;0\)</span>.也就是说,如果<span class="math inline">\(A\)</span>有负特征值则必然成对出现,不妨设其为<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\lambda_2\)</span>(当然它们有可能相等,但总之应该取不同的特征向量),此时不妨取它们的特征向量并做单位正交化后得到<span class="math inline">\(\vec v_1,\vec v_2\)</span>.此时<span class="math inline">\(\forall \alpha,\beta\in \R\)</span>,立刻有: <span class="math display">\[
(\alpha\vec v_1+\beta\vec v_2)^tA(\alpha\vec v_1+\beta\vec v_2)\\
=\alpha^2\lambda_1+\beta^2\lambda_2\leq 0
\]</span></p>
<p>其中<span class="math inline">\(\alpha,\beta\)</span>可以任取,当然存在不全为<span class="math inline">\(0\)</span>的一对<span class="math inline">\((\alpha,\beta)\)</span>使得<span class="math inline">\(\alpha\vec v_1+\beta \vec
v_2\)</span>作为列向量的第<span class="math inline">\(n\)</span>个坐标为<span class="math inline">\(0\)</span>,此时对于左上角的<span class="math inline">\((n-1)\times
(n-1)\)</span>的空间来说,由于进行了数学归纳,上面必然是正定的.这当然就矛盾了.</p>
<h5><span id="实正定矩阵的二次根">(实)正定矩阵的二次根</span></h5>
<p>设<span class="math inline">\(T\in
\text{End}(V)\)</span>正定(或者半正定),那么就存在唯一的正定(或半正定)的<span class="math inline">\(S\in \text{End}(V)\)</span>使得<span class="math inline">\(S^2=T\)</span>,这样我们记<span class="math inline">\(S=\sqrt T\)</span>.</p>
<p>(一定要记得正定蕴含着其对称啊,总是忘记这个定义)</p>
<p>存在性的话只需要对<span class="math inline">\(T\)</span>做单位正交分解,然后把对角线上的特征值全部取根号就可以了.唯一性的话,由于<span class="math inline">\(S\)</span>在每一个特征子空间上都应当表现为<span class="math inline">\(\sqrt{\lambda_i}\text{id}\)</span>(原因是每一个特征子空间本身都是不变子空间,因此<span class="math inline">\(S\)</span>的特征子空间也需要是<span class="math inline">\(S^2=T\)</span>的特征子空间,于是反之亦然),那<span class="math inline">\(S\)</span>当然是唯一确定的.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(A,B,A-B\)</span>都是正定矩阵,求证<span class="math inline">\(\sqrt A-\sqrt B\)</span>正定.</p>
<p>反证,假设<span class="math inline">\(\sqrt A-\sqrt
B\)</span>并非正定,那就一定存在一个特征值<span class="math inline">\(\lambda \leq 0\)</span>以及配套的特征向量<span class="math inline">\(\vec v\ne 0\)</span>,使得<span class="math inline">\((\sqrt A-\sqrt B)\vec v=\lambda \vec
v\)</span>,也就是<span class="math inline">\(\sqrt B\vec v=\sqrt A\vec
v-\lambda \vec v\)</span>.此时见到:</p>
<p><span class="math display">\[
(\vec v)^t B \vec v\\
=(\sqrt B\vec v)^t(\sqrt B\vec v)\\
=(\sqrt A\vec v-\lambda \vec v)^t(\sqrt A\vec v-\lambda \vec v)\\
=(\vec v)^t A \vec v+\lambda^2\vec v^t\vec v-2\lambda (\vec v)^t \sqrt A
\vec v\\
\geq (\vec v)^t A \vec v
\]</span></p>
<p>这就与<span class="math inline">\(A-B\)</span>正定是矛盾的了.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(A,B,A-B\)</span>都是正定矩阵,求证<span class="math inline">\(A^{-1}-B^{-1}\)</span>正定.</p>
<p>直接扩到复数域,这样一定存在一个<span class="math inline">\(C\)</span>,使得<span class="math inline">\((C^*)BC=I\)</span>,此时由于合同是内积空间上的同构,所以<span class="math inline">\((C^*)(A-B)C=C^*AC-I\)</span>仍然正定,这就将情况化约到<span class="math inline">\(B=I\)</span>的情况.</p>
<p>此时只需对<span class="math inline">\(A\)</span>做对角化即可见得了.</p>
<h5><span id="极分解">极分解</span></h5>
<p>对于内积空间,设<span class="math inline">\(T\in
\text{End}(V)\)</span>可逆,那么就存在唯一一对<span class="math inline">\(R,U\in \text{End}(V)\)</span>使得<span class="math inline">\(R\)</span>正定并且<span class="math inline">\(U\)</span>是正交变换,<span class="math inline">\(T=RU\)</span>.这其实类似于把一个复数拆成模长和辅角两个部分.</p>
<p>在此之前先证明一个引理:标准内积空间上<span class="math inline">\(T^*T\)</span>是半正定的,并且如果<span class="math inline">\(T\)</span>单,那么其是正定的.</p>
<p>首先其自伴性质是已知的,半正定的原因是<span class="math inline">\(^t(\vec v)(T^*T)(\vec v)=(T\vec v\mid T\vec
v)\)</span>,而后者继承了内积空间上的半正定性.并且从此可以看出<span class="math inline">\(T\)</span>单的话,也就是<span class="math inline">\(\ker
T={0}\)</span>就可以继承内积空间上的正定性.</p>
<p>注意到<span class="math inline">\(TT^*=RUU^*R=R^2\)</span>,因此必定有<span class="math inline">\(R=\sqrt {TT^*}\)</span>,因此<span class="math inline">\(R\)</span>是唯一且存在的且正定的(原因是<span class="math inline">\(T\)</span>是可逆的,因此<span class="math inline">\(TT^*\)</span>是正定的).另外,因为<span class="math inline">\(R\)</span>可逆(正定性推出非退化性),因此<span class="math inline">\(U=R^{-1}T\)</span>就确定.问题在于证明<span class="math inline">\(U\)</span>是否是正交变换,只需要证明<span class="math inline">\(U^*=U^{-1}\)</span>,而:</p>
<p><span class="math display">\[
U^*U=(R^{-1}T)^*(R^{-1}T)\\
=T^*R^{-2}T=\text{id}
\]</span></p>
<p>这就得证.</p>
<h5><span id="最小二乘法">最小二乘法</span></h5>
<p>给定一个特定的<span class="math inline">\(T\in
\text{Hom}(V,W)\)</span>,现在对于一个<span class="math inline">\(\vec
w\in W\)</span>,想要求一个<span class="math inline">\(\vec v\in
V\)</span>使得<span class="math inline">\(\Vert T\vec v-\vec
w\Vert\)</span>最小.这个解被称为<strong>最小二乘解</strong>.</p>
<p>取<span class="math inline">\(W_0=\text{im}
T\)</span>,那么就可以将<span class="math inline">\(\vec w=\vec w_0+\vec
w_1\)</span>,其中<span class="math inline">\(\vec w_0\in W_0,\vec w_1\in
(W_0)^\bot\)</span>.此时就可以见到:</p>
<p><span class="math display">\[
\Vert T\vec v-\vec w\Vert^2=\Vert (T\vec v-\vec w_0)-\vec w_1\Vert^2\\
=\Vert T\vec v-\vec w_0 \Vert^2+\Vert \vec w_1 \Vert^2
\]</span></p>
<p>只需让前面为<span class="math inline">\(0\)</span>就行,从这也可以看出来一般而言<span class="math inline">\(\vec v\)</span>不是唯一的.然而<span class="math inline">\(\vec v+\ker
T\)</span>总是唯一的,我们试图在其中找到<span class="math inline">\(\Vert
\vec v\Vert\)</span>最小的一个作为代表.而<span class="math inline">\(\vec v\)</span>仍可以分解为<span class="math inline">\(\ker T\)</span>和<span class="math inline">\((\ker
T)^\bot\)</span>两部分,这就能见到<span class="math inline">\(\Vert \vec
v\Vert\)</span>最小时<span class="math inline">\(\vec v\in (\ker
T)^\bot\)</span>.不妨将这个<span class="math inline">\(\vec
v\)</span>定义为<span class="math inline">\(S(\vec w)=\vec
v\)</span>,应该见到<span class="math inline">\(S\)</span>是一个线性映射.</p>
<p>我们还可以证明,其最小二乘解正好是<span class="math inline">\(T^*T\vec
v=T^*\vec w\)</span>的解.原因是最小二乘解其实也就是<span class="math inline">\(T\vec v-\vec w\in (\text{im}T)^\bot=\ker
(T^*)\)</span>.</p>
<p>而注意到<span class="math inline">\(T^*T\)</span>是自伴的,然而其还有更多的好性质:</p>
<ol type="1">
<li><span class="math inline">\(\text{im}\ (T^*T)= \text{im}\
(T^*)\)</span>.</li>
<li><span class="math inline">\(\ker (T^*T)=\ker T\)</span>.</li>
<li><span class="math inline">\(\text{rk}\ (T^*T)=\text{rk}\
(T)=\text{rk}(T^*)\)</span>.</li>
</ol>
<p>考虑(1), 首先显然有<span class="math inline">\(\text{im}\
(T^*T)\subseteq \text{im}\ (T^*)\)</span>.而反方向的话,对于<span class="math inline">\(T^*\vec w\in
\text{im}(T^*)\)</span>,只需取其最小二乘解<span class="math inline">\(\vec v\in V\)</span>就给出了<span class="math inline">\(T^*\vec w=T^*T\vec v\in
\text{im}(T^*T)\)</span>.</p>
<p>考虑(2),首先显然有<span class="math inline">\(\ker\ (T^*T)\subseteq
\ker\ (T)\)</span>.而反方向的话,若<span class="math inline">\(T^*T\vec
v=0\)</span>,应该能看到<span class="math inline">\((T\vec v\mid T\vec
v)=(T^*T\vec v\mid \vec v)=0\)</span>,这意味着<span class="math inline">\(T\vec v=0\)</span>.</p>
<p>(3)是(1)(2)的推论.顺便一提,这里推出的<span class="math inline">\(\text{rk}(T)=\text{rk}(T^*)\)</span>是行秩等于列秩的另一个证明.</p>
<h4><span id="奇异值分解">奇异值分解</span></h4>
<p>取<span class="math inline">\(V,W\)</span>为有限维实内积空间并采取标准内积,不妨设<span class="math inline">\(m=\dim V,n=\dim
W\)</span>,注意这里的字母使用与习惯略有差别.并取<span class="math inline">\(T:V\to
W\)</span>为线性映射.接下来我们证明,存在<span class="math inline">\(V,W\)</span>的两组单位正交基,不妨记作<span class="math inline">\(\mathcal{B}_V=\{\vec v_1,\cdots,\vec
v_m\}\)</span>和<span class="math inline">\(\mathcal{B}_W=\{\vec
w_1,\cdots,\vec w_n\}\)</span>.记<span class="math inline">\(p=\text{rk}
T\)</span>,以及存在一列非负实数<span class="math inline">\(\sigma_1\geq
\cdots\geq \sigma_p\)</span>,使得<span class="math inline">\(T\vec
v_i=\begin{cases}\sigma_i\vec w_i&amp;1\leq i\leq
p\\0&amp;i&gt;p\end{cases}\)</span>.我们称这列非负实数为<span class="math inline">\(T\)</span>的<strong>奇异值</strong>,并将在下面证明其由<span class="math inline">\(T\)</span>唯一确定.应当说明的是,下述中虽然有的时候会默认后面有一列<span class="math inline">\(0\)</span>来避开讨论,但<span class="math inline">\(\sigma_p\ne
0\)</span>.一般,我们也用非零奇异值的数量来判断<span class="math inline">\(T\)</span>的秩.可以认为,奇异值是特征值的某种推广.</p>
<p>考虑矩阵,此时的<span class="math inline">\(T\)</span>应当是一个<span class="math inline">\(n\times m\)</span>的矩阵.考虑<span class="math inline">\(V\)</span>的单位正交基组成的矩阵<span class="math inline">\(P\in M_{m\times m}\)</span>,以及<span class="math inline">\(W\)</span>的单位正交基矩阵<span class="math inline">\(Q\in M_{n\times n}\)</span>.</p>
<p>此时不妨考虑<span class="math inline">\(T\)</span>在标准基下表示为<span class="math inline">\(A\)</span>,那考虑<span class="math inline">\(Q^{-1}AP\)</span>实际上就是在两个单位正交基内转化的过程.不妨令<span class="math inline">\(\Sigma=Q^{-1}AP\)</span>,只需证明其在前<span class="math inline">\(p\)</span>个主对角线位置分别为<span class="math inline">\(\sigma_1,\cdots,\sigma_p\)</span>即可.</p>
<p>留意到<span class="math inline">\((\vec v_i\mid T^*\vec w_j)=(T\vec
v_i\mid \vec w_j)=\sigma_i(\vec w_i\mid \vec
w_j)=\sigma_i\delta_{i,j}\)</span>,其中<span class="math inline">\(\delta_{i,j}=[i=j]\)</span>.回忆到<span class="math inline">\(T^*\)</span>是唯一的,并注意到如果干脆定义<span class="math inline">\(T^*\)</span>满足<span class="math inline">\(T^*\vec w_j=\sigma_j\vec
v_j\)</span>上式依旧成立,因此<span class="math inline">\(T^*\)</span>的确有此性质.进一步得到推论<span class="math inline">\(T^*T\vec v_i=\sigma_i^2\vec v_i\)</span>.所以<span class="math inline">\(T^*T\)</span>的特征值恰为<span class="math inline">\(\sigma_1^2\geq
\cdots\)</span>.这样的话其唯一性立刻见到了.不过由于是在<span class="math inline">\(\mathbb{R}\)</span>上,因此我们还要说明其存在性.考虑对<span class="math inline">\(T^*T\)</span>做正交对角化.此时回忆到<span class="math inline">\(\text{rk}(T^*T)=\text{rk}(T)=
p\)</span>,又因为<span class="math inline">\(T^*T\)</span>可对角化,<span class="math inline">\(\text{rk}\)</span>对应了非零特征值的数量.直接取<span class="math inline">\(\sigma_i=\sqrt {\lambda_i}\)</span>,其中<span class="math inline">\(\lambda_i\)</span>是<span class="math inline">\(T^*T\)</span>的特征值,当然都是可行的.</p>
<p>接下来要反推出<span class="math inline">\(V,W\)</span>的两组单位正交基.任取一组<span class="math inline">\(V\)</span>的特征向量组成的基并从其构造<span class="math inline">\(W\)</span>的基,也就是取<span class="math inline">\(\vec w_i=\frac{T\vec
v_i}{\sigma_i}\)</span>(假设<span class="math inline">\(m\geq
n\)</span>的情况下,不然的话反之)并证明这也是一组单位正交基.</p>
<p>此时观察到<span class="math inline">\((\vec w_i\mid \vec
w_j)=\frac{1}{\sigma_i\sigma_j}(T\vec v_i\mid T\vec
v_j)=\frac{1}{\sigma_i\sigma_j}(\vec v_i\mid T^*T\vec
v_j)=\frac{\sigma_j}{\sigma_i}\delta_{i,j}\)</span>,所以这当然也是一组单位正交基.</p>
<h4><span id="moore-penrose-广义逆">Moore-Penrose 广义逆</span></h4>
<p>取域<span class="math inline">\(F\)</span>上的有限维向量空间<span class="math inline">\(V,W\)</span>以及线性映射<span class="math inline">\(T:V\to W\)</span>.其中<span class="math inline">\(T\)</span>未必可逆,但有的时候我们又需要<span class="math inline">\(T\)</span>的逆的性质,我们的目标是去找到一个弱一点的替代品.</p>
<p>我们声明一定存在一个<span class="math inline">\(S:W\to
V\)</span>,满足以下性质:</p>
<ol type="1">
<li><span class="math inline">\(TST=T\)</span>.</li>
<li><span class="math inline">\(STS=S\)</span>.</li>
<li><span class="math inline">\(TS=(TS)^*\)</span>.</li>
<li><span class="math inline">\(ST=(ST)^*\)</span>.</li>
</ol>
<p>容易见到,如果<span class="math inline">\(T\)</span>可逆,它的逆当然是一个MP广义逆.事实上我们可以证明满足上述条件的MP广义逆是唯一的.</p>
<p>先来证明其存在性,<span class="math inline">\(\forall \vec v\in
V\)</span>,做分解<span class="math inline">\(\vec v=\vec v&#39;+\vec
v&#39;&#39;\)</span>,其中<span class="math inline">\(\vec v&#39;\in \ker
T\)</span>且<span class="math inline">\(\vec v&#39;&#39;\in (\ker
T)^\bot\)</span>.同样<span class="math inline">\(\forall \vec w\in
W\)</span>,做分解<span class="math inline">\(\vec w=\vec w&#39;+\vec
w&#39;&#39;\)</span>,其中<span class="math inline">\(\vec w&#39;\in
\text{im} T\)</span>.</p>
<p>接下来应当见到,任取<span class="math inline">\(\vec
v\)</span>使得<span class="math inline">\(T\vec v=\vec
w\)</span>,则<span class="math inline">\(T^{-1}(\vec w&#39;)=\vec v+\ker
T\)</span>,而<span class="math inline">\(\vec v+\ker
T\)</span>中的每个元素做投影后得到的<span class="math inline">\(\vec
v&#39;&#39;\)</span>都是相同的,于是我们定义<span class="math inline">\(S\vec w=\vec v&#39;&#39;\)</span>.容易验证<span class="math inline">\(S\)</span>是线性映射,而且应当见到<span class="math inline">\(ST\)</span>和<span class="math inline">\(TS\)</span>其实都是正交投影,具体而言,<span class="math inline">\(ST:V\to (\ker T)^\bot\)</span>而<span class="math inline">\(TS:W\to
\text{im}T\)</span>,也容易验证上述四条性质.也就是我们想法是,干脆考虑映射<span class="math inline">\(V/\ker T\to \text{im}\
T\)</span>必然是可逆的,直接在这个上面找逆而不顾其它.</p>
<p>接下来证明其唯一性,假设<span class="math inline">\(T\)</span>有两个MP广义逆<span class="math inline">\(S,R\)</span>,我们注意到:</p>
<p><span class="math display">\[
TS=(TS)^*=S^*T^*=S^*(TRT)^*\\
=S^*T^*R^*T^*\\
=(TS)^*(TR)^*\\
=TSTR\\
=TR
\]</span></p>
<p>同理可证明<span class="math inline">\(ST=RT\)</span>,因此<span class="math inline">\(S=STS=STR=RTR=R\)</span>,这就给出了唯一性的证明.</p>
<p>那么如何求出一个MP广义逆呢?考虑对于一个线性映射<span class="math inline">\(T:V\to
W\)</span>,将其视为标准基下的矩阵,做奇异值分解有<span class="math inline">\(T=Q\Sigma P^{-1}\)</span>.</p>
<p>容易见到满足条件的MP逆<span class="math inline">\(S\)</span>应当满足<span class="math inline">\(S\vec w_j=\frac{1}{\sigma_j}\vec
v_j\)</span>,而写作矩阵形式的话就是<span class="math inline">\(P\Pi
Q^{-1}\)</span>,其中<span class="math inline">\(\Pi\)</span>就是<span class="math inline">\(\Sigma\)</span>的非零对角线全部取倒数.验证此事实的策略,要么取检验MP广义逆的定义,要么取一组基并观察投影,但总之都是容易的.</p>
<p>如果想要进一步说明MP广义逆的合理性,不妨考虑设<span class="math inline">\(C(t)=T^*T+t\sdot
{\rm{id}}_V\)</span>,我们证明MP广义逆实际上就是<span class="math inline">\(S=\lim_{t\to 0,\det C(t)\ne
0}C(t)^{-1}T^*\)</span>,证明无非也只是使用奇异值分解,考虑<span class="math inline">\(T=Q\Sigma P^{-1},T^*=P\Sigma
Q^{-1}\)</span>,那么<span class="math inline">\(C(t)=P(\Sigma^2+tI)P^{-1}\)</span>,容易检验其满足性质.</p>
<h4><span id="极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</span></h4>
<p>对于实空间<span class="math inline">\(V\)</span>,考察其标准内积<span class="math inline">\((\_\mid\_)\)</span>和任一对称双线性形式<span class="math inline">\(B:V\times V\to \mathbb
R\)</span>.当然存在唯一的<span class="math inline">\(S\in
\text{End}(V)\)</span>使得<span class="math inline">\(B(\vec v_1,\vec
v_2)=(\vec v_1\mid S\vec v_2)\)</span>恒成立,无非是把<span class="math inline">\(B\)</span>所代表的矩阵拿过来而已.</p>
<p>此时应有<span class="math inline">\(S=S^*\)</span>,对其施加正交对角化拿到单位正交基<span class="math inline">\(\vec v_1,\cdots,\vec
v_n\)</span>和对应的一列特征值<span class="math inline">\(\lambda_1\geq
\cdots\geq \lambda_n\)</span>.对于单位球面上的向量<span class="math inline">\(\vec v\)</span>,其应当满足<span class="math inline">\(|\vec v|=1\)</span>,此时我们注意到<span class="math inline">\(\lambda_1=\max_{|\vec v|=1}B(\vec v,\vec
v),\lambda_n=\min_{|\vec v|=1}B(\vec v,\vec v)\)</span>.原因只是取<span class="math inline">\(\vec v=\sum a_k\vec v_k\)</span>,然后<span class="math inline">\(B(\vec v,\vec v)=\sum_k
a_k^2\lambda_k\)</span>.上述当然成立.确定除此以外的其他特征值需要更精确地刻画,我们引入如下定理:</p>
<p><span class="math display">\[
\lambda_k=\min_{U\subseteq V,\dim U=n-k+1}\left(\max_{\vec v\in U,|\vec
v|=1}B(\vec v,\vec v)\right)\\
\lambda_k=\max_{U\subseteq V,\dim U=k}\left(\min_{\vec v\in U,|\vec
v|=1}B(\vec v,\vec v)\right)\\
\]</span></p>
<p>将<span class="math inline">\(S\)</span>用<span class="math inline">\(-S\)</span>替换,则降序的特征值序列要翻转,立刻见到上述两条等价.下面只证明第一条.</p>
<p>取<span class="math inline">\(W_k=\langle\vec v_1,\cdots,\vec v_k
\rangle\)</span>.应当见到:</p>
<p><span class="math display">\[
\dim U\cap W_k =\dim U+k-\dim (U+W_k)\\
\geq \dim U+k-n=1
\]</span></p>
<p>这意味着这两个空间的交非零空间,取出一个交集元素<span class="math inline">\(\vec v=\sum_{i=1}^k a_i\vec v_i\in
U\)</span>且满足<span class="math inline">\(|\vec
v|=1\)</span>.应当见到<span class="math inline">\(B(\vec v,\vec
v)=\sum_k \lambda_k a_k^2\geq \lambda_k\)</span>.这就意味着<span class="math inline">\(\max_{\vec v\in U,|\vec v|=1}B(\vec v,\vec v)\geq
\lambda_k\)</span>.或言之<span class="math inline">\(\inf \max_{\vec
v\in U,|\vec v|=1}B(\vec v,\vec v)\geq
\lambda_k\)</span>.证明下界可取到只需取<span class="math inline">\(U=\langle\vec v_k,\cdots,\vec
v_n\rangle\)</span>即可取到(证明取到的策略呢,可以直接看基立刻得到,也可以采取更加严谨好说的方式即前后分别表示一下发现其既满足<span class="math inline">\(\geq \lambda_k\)</span>又要<span class="math inline">\(\leq \lambda_k\)</span>).</p>
<p>这个定理也可以用来求奇异值,半正定条件下,奇异值无非是特征值开根后的结果.</p>
<p>这个原理的重要意义是将奇异值,特征值这些东西全部挪到了空间本身的性质上(类似惯性定理).于是从此只要我们能拿到空间的同构当然就能断言奇异值,特征值全都同构,这是无可置疑的.</p>
<h4><span id="perron-frobenius定理">Perron-Frobenius定理</span></h4>
<p>约定<span class="math inline">\(A\geq
B\)</span>表示对于每一个位置<span class="math inline">\(a_{i,j}\geq
b_{i,j}\)</span>.于是约定<span class="math inline">\(A\geq
0\)</span>意味着<span class="math inline">\(A\)</span>中的任意元素都<span class="math inline">\(\geq 0\)</span>.</p>
<p>容易见到以下平凡引理:</p>
<ol type="1">
<li><span class="math inline">\(A&gt;0,x\geq 0,x\ne 0\Rightarrow
Ax&gt;0\)</span>.</li>
<li><span class="math inline">\(A\geq 0,x\geq 0\Rightarrow Ax\geq
0\)</span>.</li>
</ol>
<p>定义实矩阵<span class="math inline">\(A\)</span>的<strong>谱半径</strong>为<span class="math inline">\(\rho(A)=\max{|\lambda|}\)</span>,也就是所有复特征值模长的极大值.</p>
<p>虽然这里用到了复特征值,但意义仅是使得多项式可裂,而矩阵仍然是实数域的.因此仍然认为该定理是实内积空间里的定理.</p>
<h5><span id="collatz-wielandt公式">Collatz-Wielandt公式</span></h5>
<p>对于实矩阵<span class="math inline">\(A&gt;0\)</span>,我们考虑<span class="math inline">\(S=\{\vec x\in \mathbb{R}^n\mid |\vec x|=1,\vec
x\geq 0\}\)</span>,容易见到这是个紧集,考虑定义在其上的映射<span class="math inline">\(L:S\to \mathbb{R_{+}},\vec x\mapsto
\min\left(\cfrac{(A\vec x)_i}{x_i},x_i\ne 0\right)\)</span>.于是命<span class="math inline">\(\rho\in
\mathbb{R_+}\)</span>为上述映射像中的极大值,我们下面证明两个事情:首先是这个<span class="math inline">\(\rho\)</span>是<span class="math inline">\(A\)</span>的一个特征值,其次是这个<span class="math inline">\(\rho\)</span>就是<span class="math inline">\(A\)</span>的谱半径.</p>
<p>首先证明其是一个特征值,而且对应的特征向量大于零,也就是<span class="math inline">\(\exists \vec v&gt;0,A\vec v=\rho \vec
v\)</span>.容易由定义见到<span class="math inline">\(\exists \vec
v,A\vec v\geq \rho \vec v\)</span>.假若<span class="math inline">\(A\vec
v\ne \rho \vec v\)</span>,则上述的平凡引理使得<span class="math inline">\(A(A\vec v-\rho \vec
v)&gt;0\)</span>.这里我们就应当会思考一个事情是,能否进行微调来使得得到更大的<span class="math inline">\(\rho\)</span>从而导出矛盾.因此这里的思路应当是,取一个<span class="math inline">\(\epsilon\)</span>然后找到一个向量<span class="math inline">\(\vec w\)</span>,使得<span class="math inline">\(A\vec w&gt;(\rho+\epsilon)\vec
w\)</span>从而导出矛盾.</p>
<p>回到我们拿到的条件,应该存在<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(A(A\vec v-\rho \vec v)&gt;\epsilon A\vec
v\)</span>,留意到由于平凡引理,应当<span class="math inline">\(A\vec
v&gt;0\)</span>,取适当的<span class="math inline">\(t\)</span>来归一化,定义出<span class="math inline">\(\vec w=tA\vec v\in S\)</span>,从而上式导出:</p>
<p><span class="math display">\[
A(A\vec v)&gt;(\rho+\epsilon)A\vec v\\
A\vec w&gt;(\rho+\epsilon)\vec w
\]</span></p>
<p>立即导出矛盾.因此必有<span class="math inline">\(A\vec v=\rho\vec
v\)</span>.此外,引理告诉我们<span class="math inline">\(A\vec
v&gt;0\)</span>恒成立,则<span class="math inline">\(\vec
v=\rho^{-1}A\vec v&gt;0\)</span>亦然成立.</p>
<p>接下来证明这个<span class="math inline">\(\rho\)</span>就是谱半径<span class="math inline">\(\rho(A)\)</span>.由定义见到<span class="math inline">\(\rho\)</span>作为特征值应当满足<span class="math inline">\(\rho\leq \rho(A)\)</span>,接下来只需证明<span class="math inline">\(\rho\geq \rho(A)\)</span>即可.</p>
<p>对于所有的特征值<span class="math inline">\(\mu\)</span>和相应的特征向量<span class="math inline">\(\vec w\ne 0\)</span>满足<span class="math inline">\(A\vec w=\mu \vec w\)</span>,使用三角不等式,<span class="math inline">\(\forall 1\leq i\leq n\)</span>应当有:</p>
<p><span class="math display">\[
|\mu||w_i|=|(A\vec w)_i|\\=|\sum_j a_{i,j}w_j|\leq \sum_ja_{i,j}|w_j|
\]</span></p>
<p>将<span class="math inline">\(\vec w&#39;=(|w_1|,\cdots,|w_n|)\in
\mathbb{R}^n\)</span>,也就是将复向量强行转到实向量上,上式立刻给出<span class="math inline">\(A\vec w&#39;\geq |\mu|\vec
w&#39;\)</span>.伸缩该向量使得<span class="math inline">\(|\vec
w&#39;|=1\)</span>,于是上式给出<span class="math inline">\(\rho\geq
L(\vec w&#39;)\geq |\mu|\)</span>,这就给出了<span class="math inline">\(\rho(A)\leq \rho\)</span>.于是证毕.</p>
<h5><span id="perron定理">Perron定理</span></h5>
<p>对于实矩阵<span class="math inline">\(A&gt;0\)</span>,我们接下来声明如下定理:</p>
<ol type="1">
<li><span class="math inline">\(\rho(A)&gt;0\)</span>,<span class="math inline">\(\exists \vec v\in \mathbb{R}^n,\vec v&gt;0,A\vec
v=\rho(A)\vec v\)</span>.也即:谱半径的确是一个特征值.</li>
<li>如果<span class="math inline">\(\lambda\ne \rho(A)\)</span>,则<span class="math inline">\(|\lambda|&lt;\rho(A)\)</span>.也就是:谱半径只此实特征值能达到.</li>
<li>谱半径的代数重数和几何重数均为<span class="math inline">\(1\)</span>.</li>
</ol>
<p>(1)也就是Collatz-Wielandt公式.</p>
<p>(2)的话考虑对Collatz-Wielandt公式作一些补充.假使复特征值<span class="math inline">\(\mu\)</span>满足<span class="math inline">\(|\mu|=\rho(A)\)</span>,则不等式链<span class="math inline">\(\rho(A)=\max L(\vec v)\geq L(\vec w&#39;)\geq
|\mu|=\rho(A)\)</span>必然全部三角不等式取等,中间的每一项<span class="math inline">\(w_j\)</span>都必然落在复平面的同一条直线上,那就可以除去一个复数得到实向量<span class="math inline">\(\vec w&#39;&#39;\)</span>亦然满足<span class="math inline">\(A\vec w&#39;&#39;=\mu \vec
w&#39;&#39;\)</span>,由于该式子中除了<span class="math inline">\(\mu\)</span>均为实数,因此<span class="math inline">\(\mu\)</span>也必然是实数.而且<span class="math inline">\(\mu\)</span>当然不可能是负数,这样就完成了(2)的证明.</p>
<p>(3)的话先考虑证明几何重数<span class="math inline">\(\dim
V_{\rho(A)}=1\)</span>,考虑<span class="math inline">\(\vec v,\vec
v&#39;\)</span>都是<span class="math inline">\(\rho(A)\)</span>的特征向量,其中<span class="math inline">\(\vec v\)</span>由于上述讨论而满足<span class="math inline">\(\vec v&gt;0\)</span>,而<span class="math inline">\(\vec
v&#39;\)</span>至少有一个分量为正数.既然如此,应当可以取足够小的<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(\vec v-\epsilon \vec v &#39;\geq
0\)</span>,以至于可以取其中尽可能大的<span class="math inline">\(\epsilon\)</span>使得<span class="math inline">\(\vec v-\epsilon \vec v
&#39;\)</span>的某一个分量恰好为<span class="math inline">\(0\)</span>.我们接下来声明此时<span class="math inline">\(\vec v-\epsilon \vec v &#39;=0\)</span>以说明<span class="math inline">\(\vec v&#39;\)</span>和<span class="math inline">\(\vec v\)</span>线性相关</p>
<p>为说明此进行反证,假设<span class="math inline">\(\vec v-\epsilon \vec
v &#39;\ne 0\)</span>,用平凡引理,考虑<span class="math inline">\(\vec
v-\epsilon \vec v&#39;=\frac{1}{\rho(A)}A(\vec v-\epsilon \vec
v&#39;)&gt;0\)</span>,然而我们已经说明其有一个分量为<span class="math inline">\(0\)</span>,导出矛盾.</p>
<p>接下来考虑(3)的完全版本,利用<span class="math inline">\(\dim
V_{\rho(A)}=1\)</span>,如果我们能将整个空间拆成两部分不变子空间,其中一部分是<span class="math inline">\(\langle \vec
v\rangle\)</span>,那就可以完成上面的部分,原因是此时另一部分不变子空间中不能有<span class="math inline">\(\rho(A)\)</span>作为根,否则与其维数为<span class="math inline">\(1\)</span>矛盾.另一方面,原本的特征多项式就是两个不变子空间的特征多项式的乘积,这就证明了单根的性质.</p>
<p>于此,考虑以下操作:考虑<span class="math inline">\(\text{char}(A)=\text{char}(A^T)\)</span>,于是<span class="math inline">\(\rho(A)=\rho(A^T)\)</span>,这就意味着<span class="math inline">\(\exists \vec u&gt;0\)</span>使得<span class="math inline">\((A^T)\vec u=\rho(A)\vec
u\)</span>.取出它的正交补空间<span class="math inline">\(\langle\vec
u\rangle^\bot\)</span>,它应当是<span class="math inline">\(A\)</span>的不变子空间,原因是:</p>
<p><span class="math display">\[
(\vec u)^T(A\vec x)=(A^T\vec u)^T\vec x\\=\rho(A)(\vec u)^T\vec x=0
\]</span></p>
<p>同时注意到<span class="math inline">\(\vec v&gt;0,\vec
u&gt;0\)</span>,所以<span class="math inline">\(\vec v\notin \langle\vec
u\rangle^\bot\)</span>,这就完成了直和分解,于是上述命题证毕.</p>
<h4><span id="实正交变换的标准型">实正交变换的标准型</span></h4>
<p>(ps:虽然这里放在实内积空间里,然而大部分性质实际上是转移自复内积空间的结构,应当先看下面的章节,回头再来观察此节.)</p>
<p>回忆到取定<span class="math inline">\(V\)</span>是实线性空间,并取上面的某种内积形式,对于<span class="math inline">\(T\in \text{End}(V)\)</span>,若其满足<span class="math inline">\(T^*=T^{-1}\)</span>,则它是实正交变换.特别地,当取标准内积的时候,所对应的就是正交矩阵,则<span class="math inline">\(A^t=A^{-1}\)</span>.</p>
<p>回忆到此时<span class="math inline">\(\det A=\pm 1\)</span>.</p>
<p>将正规算子的概念从复数域里面拿到实数域,即满足<span class="math inline">\((A^t)A=A(A^t)\)</span>.我们在下面做复数酉变换的时候证明过引理:<span class="math inline">\(\exists k\geq 0,T^k=0\Rightarrow
T=0\)</span>.容易见到正交算子一定是正规的.</p>
<p>接下来来观察不同维度的正交变换,假设<span class="math inline">\(\dim_{\mathbb{R}}V=n\)</span>.</p>
<p>当<span class="math inline">\(n=1\)</span>的时候,正交变换显然是长度为<span class="math inline">\(\pm 1\)</span>的伸缩变换,也就是<span class="math inline">\(\pm \text{id}_V\)</span>.</p>
<p>当<span class="math inline">\(n=2\)</span>的时候,不妨设矩阵为<span class="math inline">\(\begin{bmatrix}\alpha&amp;\beta\\
\gamma&amp;\delta\end{bmatrix}\)</span>,用正交性质就知道:</p>
<p><span class="math display">\[
\begin{cases}\alpha^2+\gamma^2=1\\ \beta^2+\delta^2=1\\
\alpha^2+\beta^2=1\\ \gamma^2+\delta^2=1\end{cases}
\]</span></p>
<p>做三角换元后考虑到行列式为<span class="math inline">\(\pm
1\)</span>,在一些简单的确定后,立刻见到原矩阵要么是:<span class="math inline">\(\begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}\)</span>,要么是<span class="math inline">\(\begin{bmatrix}\cos\theta&amp;\sin\theta\\\sin\theta&amp;-\cos\theta\end{bmatrix}\)</span>,它们的行列式分别为<span class="math inline">\(\pm 1\)</span>.</p>
<p>拿出行列式恰好为<span class="math inline">\(+1\)</span>的前者:</p>
<p><span class="math display">\[
R(\theta)=\begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}
\]</span></p>
<p>也就是通常所说的旋转矩阵.容易见到:</p>
<ol type="1">
<li><span class="math inline">\(R(\theta)R(\psi)=R(\theta+\psi)=R(\psi)R(\theta)\)</span>.</li>
<li>如果<span class="math inline">\(P\)</span>是一个正交算子,则<span class="math inline">\(P^{-1}R(\theta)P=R((\det P)\theta)\)</span>.</li>
</ol>
<p>(1)只需对<span class="math inline">\(\vec e\)</span>验证即可.</p>
<p>(2)的话,当<span class="math inline">\(\det
P=1\)</span>的时候,当然有<span class="math inline">\(P=R(\psi),P^{-1}=R(-\psi)\)</span>,那显然成立了;当<span class="math inline">\(\det P=-1\)</span>的时候,只需在外面补一个<span class="math inline">\(\begin{bmatrix}1&amp;0\\0&amp;-1\end{bmatrix}\)</span>即可转化.</p>
<p>于此之前,考虑如果<span class="math inline">\(T\)</span>是正交变换,它当然一定是正规的,那么它在复数上可正交对角化,特征值当然满足<span class="math inline">\(|\lambda|=1\)</span>,那么当然<span class="math inline">\(T+T^{-1}\)</span>自伴.而且它俩可以同步对角化,那<span class="math inline">\(T+T^{-1}\)</span>的特征值当然是<span class="math inline">\(|\mu|=|\lambda+\lambda^{-1}|\leq
|\lambda|+|\lambda^{-1}|=2\)</span>.</p>
<p>接下来考虑一般的情况,我们声明,对于任意正交变换,都可以取基转化为下述形式:</p>
<p><span class="math display">\[
\begin{bmatrix}
I_{a\times a}&amp;&amp;&amp;\\
&amp;-I_{b\times b}&amp;&amp;&amp;\\
&amp;&amp;R(\theta_1)&amp;&amp;\\
&amp;&amp;&amp; \ddots&amp;\\
&amp;&amp;&amp;&amp;R(\theta_k)
\end{bmatrix}
\]</span></p>
<p>其中<span class="math inline">\(\theta_1,\cdots,\theta_k\)</span>都并非<span class="math inline">\(\pi\)</span>的整数倍.</p>
<p>证明考虑令<span class="math inline">\(S=T^{-1}+T\)</span>,容易见到其自伴,那原空间就可以拆成<span class="math inline">\(S\)</span>的若干特征子空间的直和,容易发现<span class="math inline">\(ST=TS\)</span>,这必然意味着<span class="math inline">\(V_\lambda\)</span>是<span class="math inline">\(T\)</span>不变的,于是下面可以只着眼于一个特征子空间,观测<span class="math inline">\(V=V_\lambda\)</span>的情形,且<span class="math inline">\(\lambda\in \mathbb{R},|\lambda|\leq
2\)</span>.</p>
<p>则此时观察此空间,应当有<span class="math inline">\(T+T^{-1}=\lambda
I_V\)</span>.两边乘以<span class="math inline">\(T\)</span>,得到<span class="math inline">\(T^2-\lambda T+I=0\)</span>.</p>
<p>下面我们开始讨论,当<span class="math inline">\(\lambda=\pm
2\)</span>的时候,则上述配方得到<span class="math inline">\((T\mp
I)^2=0\)</span>,由于<span class="math inline">\(T\mp
I\)</span>是正规算子,于是<span class="math inline">\(T\mp
I=0\)</span>,这就对应了上述矩阵中的<span class="math inline">\(\pm
1\)</span>的分块.</p>
<p>那如果<span class="math inline">\(\lambda \ne \pm
2\)</span>呢,那就必然有<span class="math inline">\(|\lambda|&lt;2\)</span>,则<span class="math inline">\(x^2-\lambda x+1\)</span>无实根,不可约,但带入<span class="math inline">\(x=T\)</span>会得到<span class="math inline">\(0\)</span>,因此它必然是<span class="math inline">\(T\)</span>在此空间下的极小多项式.又因为<span class="math inline">\(T\)</span>如果有实特征值,必然是<span class="math inline">\(\pm 1\)</span>,则此时<span class="math inline">\(\lambda = \pm 2\)</span>.因此,<span class="math inline">\(T\)</span>没有实特征值.既然如此,任取一个向量<span class="math inline">\(\vec v\ne 0\)</span>,<span class="math inline">\(\vec v\)</span>与<span class="math inline">\(T\vec
v\)</span>必然线性无关.</p>
<p>既然如此,使他们张成子空间<span class="math inline">\(W=\langle\vec
v,T\vec v\rangle\)</span>并作直和分解<span class="math inline">\(V=W\oplus W^\bot\)</span>.由于<span class="math inline">\(T^2=\lambda T-I\)</span>,因此注意到<span class="math inline">\(W\)</span>应当是<span class="math inline">\(T\)</span>不变的.那么,<span class="math inline">\(W^\bot\)</span>在<span class="math inline">\(T^*=T^{-1}\)</span>作用下当然也是不变的.然而,<span class="math inline">\(T=\lambda I-T^{-1}\)</span>,所以<span class="math inline">\(T\)</span>是关于<span class="math inline">\(T^{-1}\)</span>的多项式,于是<span class="math inline">\(W^\bot\)</span>在<span class="math inline">\(T\)</span>下也是不变的.这样,我们完全把空间归纳下去了,每次都可以扔出去一个<span class="math inline">\(\dim =2\)</span>的空间.于是最后一步是检验<span class="math inline">\(T\)</span>在归纳下去的空间上的性质.对于<span class="math inline">\(\dim =2\)</span>的空间,<span class="math inline">\(x^2-\lambda
x+1\)</span>当然仍然不可约,而它必然就是特征多项式,那<span class="math inline">\(\det =1\)</span>就自然成立.</p>
<p>最后应当简单解释上述形式是否由<span class="math inline">\(T\)</span>唯一确定.然而应属显然了,因为每一次拆出的特征多项式当然都是原本特征多项式的一个不可约因子.</p>
<h5><span id="欧拉角">欧拉角</span></h5>
<p>考虑三维空间中的旋转,我们通过上述对实正交矩阵的分类得知,三维空间中的旋转立刻统合为<span class="math inline">\(\begin{bmatrix}1&amp;\\&amp;R(\theta)\end{bmatrix}\)</span>.</p>
<p>那么就需要两个参数来描述此,旋转轴<span class="math inline">\(\vec
u=\vec v_1\)</span>的坐标用以描述转轴以及一个参数<span class="math inline">\(\theta\)</span>用来描述转角.不妨将这种旋转记作<span class="math inline">\(R_{u}(\theta)\)</span>.然而于此之外,先要论证此旋转和另外两个单位正交基<span class="math inline">\(\vec v_2,\vec
v_3\)</span>无关.然而容易见到不管如何选取这两个基,它们都会同样张成<span class="math inline">\(\langle \vec
u\rangle^\bot\)</span>,因此它们都在同一个空间里,而且只差一个旋转.这个旋转前后当然可以抵消,这也是直觉所告知我们的.</p>
<p>由此就可以看到三维空间的及其好的性质,我们一般称呼二维空间中的旋转,它的转轴实际上是垂直于此平面的一个更高维的轴.而三维空间中的转轴一定落在三维空间中,不需要再到高维空间中找到转轴了.</p>
<p>综上,旋转总是将一个有序单位正交基转化为另一个有序单位正交基,三维空间中表现为<span class="math inline">\((\vec e_1,\vec e_2,\vec e_3)\to (\vec u_1,\vec
u_2,\vec u_3)\)</span>.</p>
<p>对于指定基的旋转,我们应当通过一定的交换基的操作见到:</p>
<p><span class="math display">\[
R_{e_1}(\theta)=\begin{bmatrix}1&amp;&amp;\\&amp;\cos
\theta&amp;-\sin\theta\\&amp;\sin\theta&amp;\cos\theta\end{bmatrix}\\
R_{e_2}(\theta)=\begin{bmatrix}\cos
\theta&amp;&amp;\sin\theta\\&amp;1&amp;\\-\sin\theta&amp;&amp;\cos\theta\end{bmatrix}\\
R_{e_3}(\theta)=\begin{bmatrix}\cos
\theta&amp;-\sin\theta&amp;\\\sin\theta&amp;\cos\theta&amp;\\&amp;&amp;1\end{bmatrix}\\
\]</span></p>
<p>为了表示使得任意基下的旋转,我们考虑先转好一个轴,然后再以此轴作旋转.那我们考虑构造一个<span class="math inline">\(\vec f_2=\begin{cases}\vec e_2&amp;\vec e_3// \vec
u_3\\\vec e_3\times \vec u_3&amp;otherwisse\end{cases}\)</span>.</p>
<p>换言之,此时我们选了一个轴<span class="math inline">\(\vec
f_2\)</span>,它与<span class="math inline">\(\vec u_3,\vec
e_3\)</span>均正交,那我们就可以这么转:</p>
<ol type="1">
<li>将<span class="math inline">\((\vec e_1,\vec e_2,\vec
e_3)\)</span>绕<span class="math inline">\(\vec e_3\)</span>转到<span class="math inline">\((\vec f_1,\vec f_2,\vec e_3)\)</span>.</li>
<li>将<span class="math inline">\((\vec f_1,\vec f_2,\vec
e_3)\)</span>绕<span class="math inline">\(\vec f_2\)</span>转到<span class="math inline">\((\vec g_1,\vec f_2,\vec u_3)\)</span>.</li>
<li>将<span class="math inline">\((\vec g_1,\vec f_2,\vec
u_3)\)</span>绕<span class="math inline">\(\vec u_3\)</span>转到<span class="math inline">\((\vec u_1,\vec u_2,\vec u_3)\)</span>.</li>
</ol>
<p>综上,一个旋转矩阵总可以写成三个矩阵<span class="math inline">\(R_{u_2}(\varphi)R_{f_2}(\theta)R_{e_3}(\psi)\)</span>的乘积,我们称<span class="math inline">\(T\)</span>是由<strong>欧拉角</strong><span class="math display">\[(\varphi,\theta,\psi)\]</span>所确定的.</p>
<p>不过,上述的转轴并非我们选定的有序正交基<span class="math inline">\((\vec e_1,\vec e_2,\vec
e_3)\)</span>,换言之,转轴不是以观察者视角的,而是以被旋转物体本身的视角而言的.可既然要转为矩阵表述,我们应当搞一个观察者版本的矩阵.这就要求转轴被控制为<span class="math inline">\((\vec e_1,\vec e_2,\vec
e_3)\)</span>.我们下面尝试证明<span class="math inline">\(R_{u_2}(\varphi)R_{f_2}(\theta)R_{e_3}(\psi)=R_{e_3}(\psi)R_{e_2}(\theta)R_{e_3}(\varphi)\)</span>.</p>
<p>对于正交变换<span class="math inline">\(P\)</span>,并设<span class="math inline">\(\epsilon=\det P=\pm 1\)</span>,应当有<span class="math inline">\(R_{Pu}(\epsilon\theta)=PR_u(\theta)P^{-1}\)</span>.其实到这里只有这个<span class="math inline">\(\epsilon\)</span>的用法并非显然,但总之,用代数的语言可以看出<span class="math inline">\(P\)</span>将<span class="math inline">\((\vec
u,\vec v,\vec w)\mapsto (P\vec u,P\vec v,P\vec
w)\)</span>,这当然仍是一组有序正交基.但为了使其的方向为正,可以改为<span class="math inline">\((P\vec u,P\vec v,\epsilon P\vec
w)\)</span>以避免讨论,然后去检验<span class="math inline">\(PR_u(\theta)\)</span>和<span class="math inline">\(R_{Pu}(\epsilon \theta)P\)</span>对基<span class="math inline">\((\vec u,\vec v,\vec
w)\)</span>的作用.总之容易验证.</p>
<p>既然如此,考虑<span class="math inline">\(\vec f_2=R_{e_3}(\psi)\vec
e_2\)</span>,既然如此,<span class="math inline">\(R_{f_2}(\theta)=R_{e_3}(\psi)R_{e_2}(\theta)R_{e_3}(\psi)^{-1}\)</span>.</p>
<p>同理,<span class="math inline">\(\vec u_3=R_{f_2}(\theta)\vec
e_3=R_{f_2}(\theta)R_{e_3}(\psi)\vec e_3\)</span>,既然如此,得到<span class="math inline">\(R_{u_3}(\varphi)=R_{e_3}(\psi)R_{e_2}(\theta)R_{e_3}(\varphi)R_{e_2}(\theta)^{-1}R_{e_3}(\psi)^{-1}\)</span>.这就证明了上述结论.</p>
<p>更具体地说,它表为:</p>
<p><span class="math display">\[
\begin{bmatrix}1&amp;&amp;\\&amp;\cos
\psi&amp;-\sin\psi\\&amp;\sin\psi&amp;\cos\psi\end{bmatrix}
\begin{bmatrix}\cos
\theta&amp;&amp;\sin\theta\\&amp;1&amp;\\-\sin\theta&amp;&amp;\cos\theta\end{bmatrix}
\begin{bmatrix}1&amp;&amp;\\&amp;\cos
\varphi&amp;-\sin\varphi\\&amp;\sin\varphi&amp;\cos\varphi\end{bmatrix}
\]</span></p>
<h5><span id="四元数">四元数</span></h5>
<p>试图搞一个以<span class="math inline">\(\mathbb{R}\subsetneq
\mathbb{C}\subsetneq \mathbb{H}\)</span>的东西.其中<span class="math inline">\(\mathbb{H}\)</span>是一个除环,也就是在域的基础上丢掉了交换律.</p>
<p>具体如何构造呢?考虑在实线性空间的基础上引入乘法,那就先要构造它的一组基<span class="math inline">\(\{1,i,j,k\}\)</span>.现在就只需要定义乘法,当然是<span class="math inline">\(\mathbb{H}\times \mathbb{H}\to
\mathbb{H},(x,y)\mapsto x\sdot y\)</span>,并且要求它对于<span class="math inline">\(\mathbb{R}\)</span>是双线性的.同时要求以下规则:</p>
<ol type="1">
<li><span class="math inline">\(1\sdot x=x\)</span>.</li>
<li><span class="math inline">\(i^2=j^2=k^2=-1\)</span>.</li>
<li><span class="math inline">\(ij=k=-ji\)</span>.</li>
<li><span class="math inline">\(jk=i=-kj\)</span>.</li>
<li><span class="math inline">\(ki=j=-ik\)</span>.</li>
</ol>
<p>那么双线性性质和上述约定当然搞定了一个乘法映射.为说明其是环,还应当验证以下性质:</p>
<ol type="1">
<li>分配律.由双线性形式显然.</li>
<li>结合律.只需验证上述四个元素<span class="math inline">\(1,i,j,k\)</span>的结合律即可.</li>
</ol>
<p>这就搞定了环的性质.可以看到<span class="math inline">\(\mathbb
H\)</span>可以看作<span class="math inline">\(\mathbb
R\)</span>或者<span class="math inline">\(\mathbb{C}\)</span>上的向量空间,对于前者是因为<span class="math inline">\(q=a+bi+cj+dk\)</span>,对于后者是因为任何一个<span class="math inline">\(q\)</span>都可以写作<span class="math inline">\(q=z+jw\)</span>,其中<span class="math inline">\(z,w\in
\mathbb{C}\)</span>的形式,这里顺便一提此表述下<span class="math inline">\(jw=\bar w
j\)</span>.这当然顺便也搞定了除环的性质.</p>
<p>回忆到环的中心<span class="math inline">\(Z(\mathbb{H})=\{z\in\mathbb{H}\mid \forall q\in
\mathbb{H},zq=qz\}\)</span>.我们声称<span class="math inline">\(Z(\mathbb{H})=\mathbb{R}\)</span>.由于<span class="math inline">\(\mathbb{H}\)</span>的特殊性,我们知道只需要对<span class="math inline">\(\{1,i,j,k\}\)</span>检查交换性即可,会发现只有<span class="math inline">\(\mathbb{R}\)</span>是合理的.</p>
<p>定义一个四元数<span class="math inline">\(q=a+bi+cj+dk\)</span>的<strong>共轭</strong><span class="math inline">\(\bar
q=a-bi-cj-dk\)</span>,定义其<strong>迹</strong><span class="math inline">\({\rm{Tr}}(q)=q+\bar
q=2a\)</span>,再定义其<strong>范数</strong><span class="math inline">\(N(q)=q\bar q\)</span>.有以下性质:</p>
<ol type="1">
<li>共轭对<span class="math inline">\(\mathbb{R}\)</span>是线性映射.</li>
<li><span class="math inline">\(\overline{(\bar q)}=q\)</span>.</li>
<li><span class="math inline">\(\overline{q_1+q_2}=\bar{q_1}+\bar{q_2}\)</span>.</li>
<li><span class="math inline">\(\overline{q_1q_2}=\bar{q_2}\bar{q_1}\)</span>.</li>
<li>迹对<span class="math inline">\(\mathbb{R}\)</span>是线性映射.</li>
<li><span class="math inline">\(\bar{N(q)}=N(q)=N(\bar q)\)</span>.</li>
<li><span class="math inline">\(N(a+bi+cj+dk)=a^2+b^2+c^2+d^2\in
\mathbb{R}\)</span>.</li>
<li><span class="math inline">\(N(q_1q_2)=N(q_1)N(q_2)\)</span>.</li>
<li>如若<span class="math inline">\(q\ne 0\)</span>,则<span class="math inline">\(q^{-1}=(N(q))^{-1}\bar q\)</span>.</li>
<li><span class="math inline">\(N(q^{-1})=N(q)^{-1}\)</span></li>
</ol>
<p>(1)(2)(3)是显然的.(4)的话由于乘法的双线性,只需验证<span class="math inline">\(q_1,q_2\in \{1,i,j,k\}\)</span>的情形.</p>
<p>(5)(6)是显然的.</p>
<p>(7)除了暴力验证以外,观察到(6),考虑<span class="math inline">\(N(a+bi+cj+dk)=a^2+b^2+c^2+d^2+xi+yj+zk\)</span>,然而<span class="math inline">\(\bar{N(q)}=N(q)\)</span>,这必然意味着后面均为<span class="math inline">\(0\)</span>.</p>
<p>(8)(9)(10)只需展开检验即可.这就详细描述了除环的结构.</p>
<p>我们还可以证明四元数已经到达极限了,有Frobenius定理:如果<span class="math inline">\(D\)</span>是一个除环且是一个<span class="math inline">\(\mathbb{R}\)</span>上的有限维线性空间,其乘法还对<span class="math inline">\(\mathbb{R}\)</span>满足双线性,那么<span class="math inline">\(D\)</span>一定同构于<span class="math inline">\(\mathbb{R},\mathbb{C},\mathbb{H}\)</span>三者其一,再无别的情形.怎么证明?我不会,长大后再学习.</p>
<p>最后我们还可以验证<span class="math inline">\(\mathbb{H}\)</span>可以表为<span class="math inline">\(M_{2\times
2}(\mathbb{C})\)</span>的一个子环,考虑仍取<span class="math inline">\(q=z+jw\)</span>,然后将其改写为<span class="math inline">\(\begin{bmatrix}z&amp;-\bar w\\ w&amp; \bar z
\end{bmatrix}\)</span>.这个矩阵结构可以符合加法,乘法,迹(对应到矩阵的迹),范数(对应到矩阵的行列式).这其实很像复数上把<span class="math inline">\(a+bi\mapsto \begin{bmatrix}a&amp;-b\\ b&amp;a
\end{bmatrix}\)</span>.那么我们可以:</p>
<p><span class="math display">\[
1\mapsto \begin{bmatrix}1&amp;\\&amp;1\end{bmatrix}\\
i\mapsto \begin{bmatrix}i&amp;\\&amp;-i\end{bmatrix}\\
j\mapsto \begin{bmatrix}&amp;-1\\1&amp;\end{bmatrix}\\
k\mapsto \begin{bmatrix}&amp;-i\\-i&amp;\end{bmatrix}\\
\]</span></p>
<p>接下来考虑去掉环的性质,只看线性空间的性质,将目光着眼于<span class="math inline">\(\mathbb{R}^3\)</span>上并只取出<span class="math inline">\(q=ai+bj+ck\)</span>,取这个子空间为<span class="math inline">\(\mathbb{H}_0\)</span>,在上面挪用<span class="math inline">\(N(q)\)</span>以刻画长度,具体而言只需取<span class="math inline">\(\Vert q\Vert^2=N(q)\)</span>.</p>
<p>接下来,让<span class="math inline">\(x\in
\mathbb{H}^\times\)</span>,我们声明:</p>
<ol type="1">
<li><span class="math inline">\(\forall q\in \mathbb{H}\)</span>,<span class="math inline">\(N(xqx^{-1})=N(q)\)</span>.</li>
<li>设<span class="math inline">\(R_x\in
\text{End}(\mathbb{H}_0),q\mapsto
xqx^{-1}\)</span>,则这是个正交变换.</li>
<li><span class="math inline">\(\det R_x=1\)</span>.</li>
<li><span class="math inline">\(R_{tx}=R_x\)</span>,其中<span class="math inline">\(t\in \mathbb{R}^\times\)</span>,且<span class="math inline">\(R_xR_y=R_{xy},R_{x^{-1}}=(R_x)^{-1}\)</span>.而且<span class="math inline">\(R_{-1}=R_1=\text{id}_{\mathbb{H}_0}\)</span>.</li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的话,不妨假设<span class="math inline">\(N(x)=1\)</span>,此时<span class="math inline">\(x^{-1}=\bar x\)</span>.首先要证明这个映射确实是$
(_0)<span class="math inline">\(里面的,观察\)</span>={x<sup>{-1}}qx=x(q)x</sup>{-1}=-xqx<sup>{-1}<span class="math inline">\(,这就说明\)</span>xqx</sup>{-1}_0$.</p>
<p>然后要检验它是线性映射,这里只需使用除环的性质简单验证.</p>
<p>最后由(1)说明其保距,这就说明了它是正交变换.</p>
<p>最后是(3),将<span class="math inline">\(\mathbb{H}\cong
\mathbb{R}^4\)</span>考虑映射<span class="math inline">\(\mathbb{R}^4\setminus\{0\}\to \{\pm 1\},x\mapsto
\det R_x\)</span>.这由于矩阵<span class="math inline">\(R_x\)</span>的每个元当然是关于<span class="math inline">\(x\)</span>的连续函数,因此整个映射都是连续的,而空间<span class="math inline">\(\mathbb{R}^4\setminus\{0\}\)</span>是联通的,因此整个映射必然只射到常数,而<span class="math inline">\(\det R_1=1\)</span>,因此对于任意<span class="math inline">\(x\in \mathbb{H}^\times\)</span>都有<span class="math inline">\(\det R_x=1\)</span>.</p>
<p>(4)只需简单验证即可.</p>
<p>所以我们终于见到了,这个<span class="math inline">\(R_x\)</span>应当就是三维上的正交旋转.现在最后的问题在于是否所有的旋转都可以表示为<span class="math inline">\(R_x\)</span>.我们有下述定理:即对于任意在<span class="math inline">\(\mathbb{H_0}\)</span>上的旋转<span class="math inline">\(T\)</span>,<span class="math inline">\(\exists
x\in \mathbb{H}\)</span>,<span class="math inline">\(N(x)=1\)</span>,使得<span class="math inline">\(T=Rx\)</span>,并且<span class="math inline">\(x\)</span>精确到绝对值是唯一的,换言之,恰有两个<span class="math inline">\(x,-x\)</span>满足上述条件.</p>
<p>先证明存在性,回忆到欧拉角声明了<span class="math inline">\(T\)</span>可以由三个绕轴旋转完成.也就是说,只要我们能证明绕轴旋转<span class="math inline">\(R_{e_l}(\theta)\)</span>可以用四元数表示,那么任意旋转都可以用四元数表示了.</p>
<p>不同轴类似只算一个,当绕着<span class="math inline">\(i\)</span>那条轴转的时候,取<span class="math inline">\(x=\cos \theta+i\sin\theta\)</span>,则<span class="math inline">\(x^{-1}=\bar x=\cos
\theta-i\sin\theta\)</span>,见到:</p>
<p><span class="math display">\[
xix^{-1}=i\\
xjx^{-1}=\cos(2\theta)j+\sin(2\theta)k\\
xkx^{-1}=-\sin(2\theta)j+\cos(2\theta)k
\]</span></p>
<p>综上见到<span class="math inline">\(R_x\)</span>是:<span class="math inline">\(\begin{bmatrix}1&amp;\\&amp;R(2\theta)\end{bmatrix}\)</span>,这样就实现了对第一个坐标轴转<span class="math inline">\(2\theta\)</span>的情形.</p>
<p>类似的,就可以说明四元数可以表示所有的旋转.</p>
<p>最后要检验唯一性,如果<span class="math inline">\(R_x=R_y\)</span>,其中<span class="math inline">\(N(x)=N(y)=1\)</span>,那就有<span class="math inline">\(\text{id}_{\mathbb{H}_0}=R_x(R_y)^{-1}=R_{xy^{-1}}\)</span>.</p>
<p>于是最后转化为说,要证明如果<span class="math inline">\(R_{x}=\text{id}_{\mathbb{H}_0}\)</span>,那么<span class="math inline">\(x=\pm 1\)</span>.那就说明<span class="math inline">\(\forall q, xqx^{-1}=q\)</span>,也就是<span class="math inline">\(x\in Z(\mathbb H)=\mathbb{R}\)</span>.又由于<span class="math inline">\(N(x)=1\)</span>,所以<span class="math inline">\(x=\pm 1\)</span>.</p>
<p>更具体来说,绕着<span class="math inline">\(u\)</span>这条轴,且满足<span class="math inline">\(N(u)=1\)</span>来说,那么<span class="math inline">\(R_u(\theta)=\cos\frac{\theta}{2}+u\sin\frac{\theta}{2}\)</span>.</p>
<p>首先要验证<span class="math inline">\(x=\cos\frac{\theta}{2}+u\sin\frac{\theta}{2}\)</span>满足<span class="math inline">\(N(x)=1\)</span>,而:</p>
<p><span class="math display">\[
N(x)=x\bar x\\
=(\cos\frac{\theta}{2}+u\sin\frac{\theta}{2})(\cos\frac{\theta}{2}-u\sin\frac{\theta}{2})\\
=\cos^2\frac{\theta}{2}-u^2\sin^2\frac{\theta}{2}\\
=\cos^2\frac{\theta}{2}+N(u)\sin^2\frac{\theta}{2}\\
=1
\]</span></p>
<p>而考虑总存在一个旋转<span class="math inline">\(P=R_y\)</span>,使得<span class="math inline">\(P(i)=u\)</span>,此时我们可以知道:</p>
<p><span class="math display">\[
R_u(\theta)=PR_i(\theta)P^{-1}\\
=R_yR_i(\theta)R_{y^{-1}}\\
\]</span></p>
<p>不妨设<span class="math inline">\(R_u(\theta)=R_x\)</span>,则:</p>
<p><span class="math display">\[
x=y(\cos\frac{\theta}{2}+i\sin\frac{\theta}{2})y^{-1}\\
=\cos\frac{\theta}{2}+\sin\frac{\theta}{2}yiy^{-1}\\
=\cos\frac{\theta}{2}+\sin\frac{\theta}{2}u
\]</span></p>
<p>用欧拉公式的话,有<span class="math inline">\(R_u(\theta)=e^{\frac{\theta}{2}u}\)</span>.</p>
<h3><span id="复内积空间">复内积空间</span></h3>
<h4><span id="共轭空间">共轭空间</span></h4>
<p>这应当带给我们思考,既然远在定义复数的时候,我们就声称过<span class="math inline">\(i\)</span>和<span class="math inline">\(-i\)</span>无法区分,于是在此,应当研究一下共轭前后的两个空间分别的性质.</p>
<p>设<span class="math inline">\(V\)</span>是<span class="math inline">\(\mathbb{C}\)</span>下的向量空间,它的复共轭<span class="math inline">\(\bar V\)</span>是按照以下方式确定的<span class="math inline">\(\mathbb{C}\)</span>向量空间:</p>
<ol type="1">
<li>集合<span class="math inline">\(V\)</span>与加法操作与原空间相同.</li>
<li>纯量乘法<span class="math inline">\(\odot: \mathbb{C}\times V\to
V\)</span>定义为<span class="math inline">\(t\odot \vec v=\bar t \vec
v\)</span>.</li>
</ol>
<p>显然<span class="math inline">\(\overline {(\bar
V)}=V\)</span>.半双线性映射无非是线性映射<span class="math inline">\(\bar V\to W\)</span>.当然,也可以等价说是<span class="math inline">\(V\to \bar
W\)</span>.我们接下来验证复共轭的若干性质:</p>
<ol type="1">
<li>映射<span class="math inline">\(z\mapsto \bar
z\)</span>给出向量空间的共轭<span class="math inline">\(\mathbb{C}\cong
\bar{\mathbb{C}}:z\mapsto \bar z\)</span>.</li>
<li><span class="math inline">\(\bar V_1\oplus \bar
V_2=\overline{V_1\oplus V_2}\)</span>.</li>
<li><span class="math inline">\(\overline{\text{Hom}(V_1,V_2)}=\text{Hom}(\bar
V_1,\bar V_2)\)</span>.</li>
<li><span class="math inline">\({\bar W}^\vee\cong
\overline{W^\vee}\)</span>,其实是(3)的另一种表示方式.</li>
</ol>
<p>应当检验上述映射,同构,甚至是完全挪移都是良定义的且半线性的,这里不做赘述.</p>
<p>相信对共轭空间最大的疑问在于,既然其改变了纯量乘法,原本的向量结构为什么不会被打乱呢?事实上,如果你考虑选定一组基的话,纯量乘法上的轻微改变只会使得将其它向量转化为基表示形式的过程中所提取出的纯量发生变化,然而共轭满足<span class="math inline">\(\overline{z_1z_2}=\bar{z_1}\bar
{z_2}\)</span>.虽然取定基的做法并非典范,然而不同基之间的转化仍然可以提取纯量.或者说,我们可以先取<span class="math inline">\(V\cong \mathbb{C}^n\cong (\bar
{\mathbb{C}})^n\cong \bar V\)</span>.</p>
<p>或直接从复数的几何意义来说,共轭无非是将逆时针旋转改为顺时针旋转,这应当仍是合理的.</p>
<h4><span id="复半双线性形式">(复)半双线性形式</span></h4>
<p>应当见到双线性形式在复空间中未必有很好的应用,原因是正定性难以得到满足.</p>
<p>定义<strong>半线性映射</strong>为<span class="math inline">\(T:V\to
W\)</span>满足:</p>
<ol type="1">
<li><span class="math inline">\(T(\vec v_1+\vec v_2)=T(\vec v_1)+T(\vec
v_2)\)</span>.</li>
<li><span class="math inline">\(T(t\vec v)=\bar t T(\vec
v)\)</span>.</li>
</ol>
<p>定义<strong>半双线性映射</strong>为<span class="math inline">\(B:V\times W\to X\)</span>满足:</p>
<ol type="1">
<li><span class="math inline">\(B(\vec v_1+\vec v_2,\vec w)=B(\vec
v_1,\vec w)+B(\vec v_2,\vec w)\)</span>.</li>
<li>对第一个变量半线性:<span class="math inline">\(B(t\vec v,\vec
w)=\bar t B(\vec v,\vec w)\)</span>.</li>
<li><span class="math inline">\(B(\vec v,\vec w_1+\vec w_2)=B(\vec
v,\vec w_1)+B(\vec v,\vec w_2)\)</span>.</li>
<li>对第二个变量线性:<span class="math inline">\(B(\vec v,t\vec w)=t
B(\vec v,\vec w)\)</span>.</li>
</ol>
<p>至于复伴随映射以及其余的东西,无非只是在实数上类似的定义的照抄.将上述记作<span class="math inline">\(\text{Sesq}(V,W;X)\)</span>.特别地,当<span class="math inline">\(X=\mathbb{C}\)</span>的时候,将此称作半双线性形式.应当立刻见到<span class="math inline">\(\text{Sesq}(V,W;X)=\text{Bil}(\bar
V,W;X)\)</span>.</p>
<p>至于非退化等部分仍然是实数情况的照抄,对左右根,不妨设左根空间为<span class="math inline">\(L\)</span>,右根空间为<span class="math inline">\(R\)</span>,用柯里化过程见到该形式等价于<span class="math inline">\(\psi\in \text{Hom}(W,{\bar
V}^\vee)\)</span>或者<span class="math inline">\(\varphi\in
\text{Hom}(\bar V,W^\vee)\)</span>,那么<span class="math inline">\(L=\ker \varphi,R=\ker
\psi\)</span>,我们应当见到<span class="math inline">\(B&#39;:(V/L)\times
(W/R)\to F,(\vec v+L,\vec w+R)\mapsto B(\vec v,\vec
w)\)</span>是非退化双线性形式.此时见到其实<span class="math inline">\(\dim V-\dim L=\dim W-\dim R\)</span>.</p>
<p>接下来要用矩阵形式予以表述,我们声称<span class="math inline">\(M_{m\times n}(\mathbb{C})\cong
\text{Sesq}(\mathbb{C}^m,\mathbb{C}^n),A\mapsto B(\vec v,\vec
w)=(^\dagger\vec v)A\vec w\)</span>,原因是标准基下<span class="math inline">\(\mathbb{C}\)</span>的对偶空间其实就是共轭转置后的结果.</p>
<h4><span id="伴随映射">伴随映射</span></h4>
<p>与实数情况毫无差异,我们在此复述一遍当时的图表即可:</p>
<p><span class="math display">\[
\xymatrix{
V_2&#39;\ar[r]^{T^*}\ar[d]_{A_2}&amp;V_1&#39;\ar[d]^{A_1}\\
\check {V_2}\ar[r]^{^\dagger T} &amp;\check {V_1}\\
V_2\ar[u]&amp;V_1\ar[u]\ar[l]_T
}
\]</span> 同样,我们可以定义<strong>自伴</strong>性质:<span class="math inline">\(T^*=T\)</span>以及<strong>反自伴</strong>性质<span class="math inline">\(T^*=-T\)</span>.此处出现了复数与实数不同的地方:假设<span class="math inline">\(c\)</span>是非零纯虚数,则<span class="math inline">\(T\)</span>自伴当且仅当<span class="math inline">\(cT\)</span>反自伴.这性质是容易验证的,也告知我们复数域上的反自伴并不需要像实数那样使用单独的辛空间来刻画.</p>
<p>类比实数,下面定理当然也是对的:</p>
<p>而注意到<span class="math inline">\(T^*T\)</span>是自伴的,然而其还有更多的好性质:</p>
<ol type="1">
<li><span class="math inline">\((\text{im}T)^\bot=\ker
(T^*)\)</span>.</li>
<li><span class="math inline">\(\text{im}\ (T^*T)= \text{im}\
(T^*)\)</span>.</li>
<li><span class="math inline">\(\ker (T^*T)=\ker T\)</span>.</li>
<li><span class="math inline">\(\text{rk}\ (T^*T)=\text{rk}\
(T)=\text{rk}(T^*)\)</span>.</li>
</ol>
<p>证明与实数情形无差.</p>
<h4><span id="hermite形式">Hermite形式</span></h4>
<p>设<span class="math inline">\(V\)</span>是<span class="math inline">\(\mathbb{C}\)</span>下的向量空间,<span class="math inline">\(\epsilon\in \{-1,1\}\)</span>,若半双线性形式<span class="math inline">\(B:V\times V\to \mathbb{C}\)</span>满足<span class="math inline">\(B(\vec v,\vec w)=\epsilon\overline{B(\vec w,\vec
v)}\)</span>的话,我们就称<span class="math inline">\(B\)</span>是一个<span class="math inline">\(\epsilon-\)</span>Hermite形式.如果<span class="math inline">\(\epsilon=1\)</span>,称这是一个<strong>Hermite形式</strong>;如果<span class="math inline">\(\epsilon=-1\)</span>,则称其为<strong>反Hermite形式</strong>.容易验证,如果<span class="math inline">\(B\)</span>是Hermite的,那么<span class="math inline">\(iB\)</span>是反Hermite的.</p>
<p>此定义直接导致<span class="math inline">\(B\)</span>的左右根是一回事,我们后面会称其为<span class="math inline">\(B\)</span>的根基.并容易见到等价于其对应的矩阵满足<span class="math inline">\(A^\dagger=\epsilon
A\)</span>.也就是说,Hermite形式对应的矩阵自伴,而反Hermite形式对应的矩阵反自伴.</p>
<h5><span id="正规线性映射">正规线性映射</span></h5>
<p>给定某<span class="math inline">\(\epsilon-\)</span>Hermite形式<span class="math inline">\(B:V\times V\to \mathbb{C}\)</span>,我们称满足<span class="math inline">\((T^*)T=T(T^*)\)</span>的<span class="math inline">\(T\)</span>是<strong>正规线性映射</strong>.容易见到自伴和反自伴当然是正规的.事实上,取<span class="math inline">\(T&#39;=\frac{1}{2}(T+T^*),T&#39;&#39;=\frac{1}{2}(T-T^*)\)</span>即可见到能将<span class="math inline">\(T=T&#39;+T&#39;&#39;\)</span>拆成一个自伴形式和一个反自伴形式.这种分解还是唯一的,原因是如果有两组形式满足<span class="math inline">\(T_1&#39;+T_1&#39;&#39;=T_2&#39;+T_2&#39;&#39;\)</span>,移项后得到<span class="math inline">\(T_1&#39;-T_2&#39;=T_2&#39;&#39;-T_1&#39;&#39;\)</span>,左侧是自伴的,右侧是反自伴的,因此它们都是<span class="math inline">\(0\)</span>.</p>
<p>若进一步要求<span class="math inline">\(T\)</span>是正规的,也就是<span class="math inline">\((T^*)T=T(T^*)\)</span>,还可以见到<span class="math inline">\(T&#39;T&#39;&#39;=T&#39;&#39;T&#39;\)</span>,只需简单验证即可.</p>
<h5><span id="二次型">二次型</span></h5>
<p>定义复数上的半双线性版本的<strong>二次型</strong>为<span class="math inline">\(f(x_1,\cdots,x_n)=\sum
a_{i,j}\bar{x_i}x_j\)</span>.要证明其与<span class="math inline">\(\epsilon-\)</span>Hermite形式同构,不妨先直接考虑<span class="math inline">\(f(\vec v+\vec w)=B(\vec v+\vec w,\vec v+\vec
w)\)</span>,那只需考虑配极化技巧,定义<span class="math inline">\(\Re\)</span>为提取实部,<span class="math inline">\(\Im\)</span>为提取虚部,立刻得到:</p>
<p><span class="math display">\[
f(\vec v+\vec w)=\begin{cases}f(\vec v)+f(\vec w)+2\Re B(\vec v,\vec
w)&amp;\epsilon=1\\
f(\vec v)+f(\vec w)+2i\Im B(\vec v,\vec w)&amp;\epsilon=-1
\end{cases}
\]</span></p>
<p>考虑<span class="math inline">\(\Im B(\vec v,\vec w)=\Re B(i\vec
v,\vec w)\)</span>,所以上述立刻确定了<span class="math inline">\(B\)</span>.</p>
<p>搬运实二次型上的性质即可看到<strong>合同</strong>在复数域上体现于<span class="math inline">\(A=(^\dagger
C)A&#39;C\)</span>.对该多项式做对角化与实数情况无异.</p>
<p>至于复数上的<strong>惯性定理</strong>,证明与实数丝毫不差.</p>
<p>既然如此,我们下面会说明Hermite形式对应了标准内积下的自伴算子,其所有特征值均为实数.由此可以定义其<strong>正定性</strong>,当然也就是所有特征值均为正数.其余类似<strong>半正定性</strong>均可照搬原本性质.</p>
<p>于此,我们可以引出以下定理:</p>
<p><span class="math inline">\(T^*T\)</span>是半正定的.当<span class="math inline">\(T\)</span>是单射时,其是正定的.</p>
<p>证明无非仍然是<span class="math inline">\((T^*T\vec v\mid \vec
v)_V=(T\vec v\mid T\vec v)_W\)</span>的直接结论.</p>
<h4><span id="复内积空间">复内积空间</span></h4>
<p>考虑正定Hermite形式<span class="math inline">\((\_\mid\_):V\times
V\to \mathbb{C}\)</span>,这样的资料<span class="math inline">\((V,(\_\mid\_))\)</span>称为<strong>复内积空间</strong>,又称作<strong>酉空间</strong>.特别地,在<span class="math inline">\(\mathbb{C}^n\)</span>上定义标准Hermite内积为<span class="math inline">\((\vec x\mid \vec y)=\sum \bar
{x_i}y_i\)</span>,应当见到其正定且是一个Hermite形式.</p>
<p>容易照搬大部分实内积空间的性质过来,这里简单列举:</p>
<ol type="1">
<li><span class="math inline">\(\Vert\vec v\Vert=0\Leftrightarrow \vec
v=0\)</span>.</li>
<li><span class="math inline">\(\Vert t\vec v\Vert=|t|\Vert\vec
v\Vert^2\)</span>.</li>
<li><span class="math inline">\(\Im (\vec v_1\mid \vec v_2)=\Re(i\vec
v_1\mid \vec v_2)\)</span>.</li>
<li>配极化,即<span class="math inline">\(\Vert\vec v+\vec w\Vert^2=\Vert
\vec v\Vert^2+\Vert \vec w\Vert^2+2\Re(\vec v\mid \vec w)\)</span>.</li>
<li>正交单位向量,正交集合,单位正交基等概念原样照搬.</li>
<li>勾股定理,即<span class="math inline">\(\vec v\bot \vec
w\)</span>时,<span class="math inline">\(\Vert\vec v+\vec
w\Vert^2=\Vert\vec v\Vert^2+\Vert\vec w\Vert^2\)</span>.</li>
<li>柯西不等式,即<span class="math inline">\(|(\vec v\mid \vec w)|\leq
\Vert\vec v\Vert\sdot \Vert\vec w\Vert\)</span>.</li>
<li>三角不等式,即<span class="math inline">\(\Vert\vec v+\vec w\Vert\leq
\Vert\vec v\Vert+\Vert\vec w\Vert\)</span>.</li>
<li>Gram-Schmidt正交化,策略仍是<span class="math inline">\(\vec w_k=\vec
v_k-\sum_{i=1}^{k-1}\frac{(\vec w_i\mid \vec v_k)}{(\vec w_i\mid \vec
w_i)}\vec w_i\)</span>.</li>
</ol>
<p>(1)(2)(3)(4)(5)(6)的证明是平凡的.</p>
<p>(7)的证明与实数情景略有差别,仍设<span class="math inline">\(t\in
\mathbb{C}\)</span>,并观察:</p>
<p><span class="math display">\[
0\leq \Vert\vec v+t\vec w\Vert^2\\
=\Vert\vec v\Vert^2+2\Re(t(\vec v\mid \vec w))+|t|^2\Vert\vec w\Vert^2\\
\leq \Vert\vec v\Vert^2+2|t|\sdot|(\vec v\mid \vec w)|+|t|^2\Vert\vec
w\Vert^2
\]</span></p>
<p>对于(8),只需做一些微小的调整,具体为:</p>
<p><span class="math display">\[
\Vert\vec v+\vec w\Vert^2=\Vert\vec v\Vert^2+2\Re(\vec v\mid \vec
w)+\Vert\vec w\Vert^2\\
\leq \Vert\vec v\Vert^2+2|(\vec v\mid \vec w)|+\Vert\vec w\Vert^2\\
\leq \Vert\vec v\Vert^2+2\Vert\vec v \Vert\sdot \Vert\vec
w\Vert+\Vert\vec w\Vert^2\\
=(\Vert \vec v\Vert+\Vert\vec w\Vert)^2
\]</span></p>
<p>(9)的话,值得注意的是在左右两边对<span class="math inline">\(\vec
w_i\)</span>做内积其实并非完全一致的.做<span class="math inline">\((\vec
w_i\mid\_)\)</span>当然显然是正确的,做<span class="math inline">\((\_\mid \vec
w_i)\)</span>的话,由于是Hermite形式,当然也是对的.</p>
<h5><span id="酉变换">酉变换</span></h5>
<p>复内积空间到自身的同构称为<span class="math inline">\(V\)</span>上的<strong>酉变换</strong>.容易类比实数情况,以下命题等价:</p>
<ol type="1">
<li><span class="math inline">\(T\)</span>是酉变换.</li>
<li><span class="math inline">\(T^*=T^{-1}\)</span>,特别地,取标准内积空间时,该条等价于<span class="math inline">\(T^\dagger=T^{-1}\)</span>,如果<span class="math inline">\(T\)</span>是矩阵,我们称其是<strong>酉矩阵</strong>.</li>
<li><span class="math inline">\(\{\vec v_1,\cdots,\vec
v_n\}\)</span>是一组单位正交基,则<span class="math inline">\(\{T\vec
v_1,\cdots,T\vec v_n\}\)</span>也是一组单位正交基.</li>
</ol>
<h5><span id="正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</span></h5>
<p>我们下面证明,只要<span class="math inline">\(T\)</span>是正规算子,那它就可以酉对角化.换言之<span class="math inline">\(T\)</span>如果对应矩阵<span class="math inline">\(A\)</span>,那么存在酉矩阵<span class="math inline">\(P\)</span>满足<span class="math inline">\(P^\dagger=P^{-1}\)</span>而且<span class="math inline">\(P^{-1}AP=\begin{bmatrix}\lambda_1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;\lambda_n\end{bmatrix}\)</span>.容易见到其逆命题仍然成立,原因是<span class="math inline">\(P^{-1}A(A^\dagger)P=P^{-1}(A^\dagger)AP=\begin{bmatrix}|\lambda_1|^2&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;|\lambda_n|^2\end{bmatrix}\)</span>.</p>
<p>接下来要证明该定理正命题成立,其证明策略有若干种,下面选取两种进行说明.</p>
<p>第一种策略是,照搬实数域上的情形对空间进行数学归纳.已经可以将一个正规算子分解为<span class="math inline">\(T=T&#39;+T&#39;&#39;\)</span>,其中<span class="math inline">\(T&#39;\)</span>自伴而<span class="math inline">\(T&#39;&#39;\)</span>反自伴.那我们可以类比实数域上对其进行归纳,从而说明<span class="math inline">\(T&#39;,T&#39;&#39;\)</span>均可以对角化.又因为当<span class="math inline">\(T\)</span>正规的时候,<span class="math inline">\(T&#39;T&#39;&#39;=T&#39;&#39;T&#39;\)</span>,于是满足同步对角化的条件.</p>
<p>第二种策略较为麻烦,但能揭示更多正规算子的性质.假设<span class="math inline">\(N\in
\text{End}(V)\)</span>是正规算子,我们首先证明以下引理:</p>
<ol type="1">
<li>对于<span class="math inline">\(f\in \mathbb{C}[x]\)</span>,<span class="math inline">\(f(N)\in \text{End}(V)\)</span>也是正规的.</li>
<li>假设特征向量<span class="math inline">\(\vec v\in
V\)</span>使得<span class="math inline">\(\exists \lambda\in
\mathbb{C}\)</span>有<span class="math inline">\(N\vec v=\lambda\vec
v\)</span>,则<span class="math inline">\(N^*\vec v=\bar{\lambda}\vec
v\)</span>.</li>
<li>若存在<span class="math inline">\(k\geq 1\)</span>使得<span class="math inline">\(N^k=0\)</span>,那么<span class="math inline">\(N=0\)</span>.</li>
<li>对于其任意两个不同的特征子空间<span class="math inline">\(V_\lambda,V_\mu\)</span>,当<span class="math inline">\(\lambda\ne \mu\)</span>的时候,<span class="math inline">\(V_\lambda\bot V_\mu\)</span>.</li>
</ol>
<p>(1)的话,考虑<span class="math inline">\((\sum a_iN^i)^*=\sum
\bar{a_i}(N^*)^i\)</span>,其与任意<span class="math inline">\(N\)</span>的多项式都交换.</p>
<p>(2)的话不妨直接取<span class="math inline">\(M=N-\lambda
I\)</span>,根据(1)这当然仍是正规的.取<span class="math inline">\(M^*=N^*-\bar{\lambda}I\)</span>,此时注意到<span class="math inline">\(\ker M\)</span>就是<span class="math inline">\(V_\lambda\)</span>这个特征子空间,然而见到<span class="math inline">\(\ker (M)=\ker(M^*M)=\ker(MM^*)=\ker
(M^*)\)</span>,这就证毕了.当然这也意味着自伴算子的特征值一定都是实数,而反自伴算子的特征值一定都是纯虚数.</p>
<p>(3)考虑到<span class="math inline">\((N^k)^*=(N^*)^k\)</span>,于是<span class="math inline">\(N\)</span>的任意次幂都是正规的.既然如此,考虑<span class="math inline">\(N^*N\)</span>当然是自伴的.要证<span class="math inline">\(N=0\)</span>,只需证明<span class="math inline">\(\text{rk}\ N=0\)</span>,只需证明<span class="math inline">\(\text{rk}\ (N^*N)=0\)</span>,也就只需要证明<span class="math inline">\(N^*N=0\)</span>即可.而如果<span class="math inline">\(N^k=0\)</span>,那么立刻有<span class="math inline">\((N^*N)^k=0\)</span>,因此我们对<span class="math inline">\(N^*N\)</span>,也就是自伴情形证明上述结论即可.</p>
<p>于是接下来不妨假设<span class="math inline">\(N\)</span>自伴,其任意次幂都自伴.考虑<span class="math inline">\(k=1\)</span>显然成立,<span class="math inline">\(k=2\)</span>的时候,回忆到<span class="math inline">\(\forall \vec v,(N\vec v\mid N\vec v)=(N^2\vec
v\mid \vec v)=0\)</span>,因此立刻有<span class="math inline">\(N=0\)</span>.</p>
<p>然后使用数学归纳,对于一般的<span class="math inline">\(k&gt;2\)</span>,如果<span class="math inline">\(k\)</span>是偶数,那<span class="math inline">\((N^{\frac{k}{2}})^2=N^k=0\)</span>意味着<span class="math inline">\(N^{\frac{k}{2}}=0\)</span>,可以数学归纳;当<span class="math inline">\(k\)</span>是奇数的时候,<span class="math inline">\(N^{k+1}=0\)</span>,而<span class="math inline">\(\frac{k+1}{2}&lt;k\)</span>,因此仍然可以数学归纳.</p>
<p>(4)只需要考虑(2),立刻有:</p>
<p><span class="math display">\[
\mu(\vec v\mid \vec w)=(\vec v\mid \mu \vec w)=(\vec v\mid N\vec w)\\
=(N^*\vec v\mid \vec w)=(\bar {\lambda}\vec v\mid \vec w)=\lambda(\vec
v\mid \vec w)
\]</span></p>
<p>于是完事.</p>
<p>有了以上引理,我们就可以来揭示正规算子可对角化的性质.</p>
<p>使用复数域上分裂的性质,将其特征多项式<span class="math inline">\(\text{Char}_T=\prod(x-\mu_i)^{a_i}\)</span>.取<span class="math inline">\(m=\prod (x-\mu_i)\)</span>,只要我们能说明<span class="math inline">\(m\)</span>就是极小多项式,由于其无重根则立即完事.那就只需要验证<span class="math inline">\(m(T)=0\)</span>,然而,<span class="math inline">\(m(T)\)</span>由于(1)是正规的,又因为<span class="math inline">\(m(T)^{\max a_i}=0\)</span>,用(3)立刻见到<span class="math inline">\(m(T)=0\)</span>,再用(4)和Gram-Schmidt法得到正交基,这就证明了该结论.</p>
<p>回忆到实数域上可正交对角化当且仅当自伴,那是因为实数域上的反自伴性质很差.而复数域上二者差别不大,想要它们能够同步对角化就需要有交换性,而正规算子恰好保证了交换性.</p>
<p>但总之,我们由上可以立即见到以下结论成立,当<span class="math inline">\(T\)</span>是正规算子的时候:</p>
<ol type="1">
<li><span class="math inline">\(T\)</span>自伴当且仅当所有特征值都是实数.</li>
<li><span class="math inline">\(T\)</span>反自伴当且仅当所有特征值都是纯虚数.</li>
<li><span class="math inline">\(T\)</span>是酉变换当且仅当所有特征值都满足<span class="math inline">\(|\lambda|=1\)</span>.</li>
</ol>
<p>原因是自伴性质是<span class="math inline">\(A^\dagger=A\)</span>,反自伴性质是<span class="math inline">\(A^\dagger=-A\)</span>,酉变换性质是<span class="math inline">\(A^\dagger=A^{-1}\)</span>.而只需选取单位正交基,立刻就发现<span class="math inline">\(T\)</span>对应的<span class="math inline">\(A=\begin{bmatrix}\lambda_1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;\lambda_n\end{bmatrix}\)</span>,<span class="math inline">\(T^*\)</span>对应的<span class="math inline">\(A^\dagger=\begin{bmatrix}\bar
\lambda_1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;\bar
\lambda_n\end{bmatrix}\)</span>.</p>
<h5><span id="相关实内积空间定理推广">相关实内积空间定理推广</span></h5>
<p>我们声明以下操作在复内积空间上都能做:</p>
<ol type="1">
<li>二次根:设<span class="math inline">\(T\in
\text{End}(V)\)</span>正定(半正定),那么存在唯一的<span class="math inline">\(S\in \text{End}(V)\)</span>使得<span class="math inline">\(S\)</span>也正定(半正定),并且<span class="math inline">\(S^2=T\)</span>,将此<span class="math inline">\(S\)</span>记作<span class="math inline">\(\sqrt
T\)</span>.</li>
<li>极分解:设<span class="math inline">\(T\in
\text{End}(V)\)</span>可逆,则存在唯一一对<span class="math inline">\(R,U\in \text{End}(V)\)</span>使得<span class="math inline">\(R\)</span>正定,<span class="math inline">\(U\)</span>是酉变换,而且<span class="math inline">\(T=RU\)</span>.具体地,<span class="math inline">\(R=\sqrt{TT^*}\)</span>.</li>
<li>奇异值分解:对于线性映射<span class="math inline">\(T:V\to
W\)</span>,存在<span class="math inline">\(V,W\)</span>分别的一组正交基和唯一一组<span class="math inline">\(\sigma_1\geq \cdots\geq \sigma_p\)</span>使得<span class="math inline">\(T\vec v_i=\begin{cases}\sigma_i\vec w_i&amp;1\leq
i\leq p\\0&amp;i&gt;p\end{cases}\)</span>.或者写作<span class="math inline">\(A=Q\Sigma P^{-1}\)</span>,其中<span class="math inline">\(\Sigma=\begin{bmatrix}\sigma_1&amp;\\&amp;\ddots\end{bmatrix}\)</span>.</li>
<li>MP广义逆:对于<span class="math inline">\(T:V\to
W\)</span>,存在唯一的<span class="math inline">\(S:W\to
V\)</span>,使得其满足从前的广义逆结论.特别地,这里的<span class="math inline">\(S\)</span>实际上可以用奇异值分解唯一刻画.</li>
</ol>
<h5><span id="复矩阵范数实例">复矩阵范数实例</span></h5>
<p>考虑<span class="math inline">\((A,B)\to (A\mid
B)_{HS}=\text{Tr}((A^\dagger)B)\)</span>,立刻使得<span class="math inline">\(M_{m\times
n}(\mathbb{C})\)</span>成为一个复内积空间.在此基础上定义<strong>Hilbert-Schmidt范数</strong>:<span class="math inline">\(\Vert T\Vert_{HS}=\sqrt{(T\mid
T)_{HS}}\)</span>.</p>
<p>这里还可以展现<span class="math inline">\(\text{Tr}\)</span>在空间上的体现.回忆到<span class="math inline">\(V\)</span>上的内积结构<span class="math inline">\(\vec v\mapsto (\vec v\mid \_)\)</span></p>
<p>另外,还可以定义所谓<strong>算子范数</strong>为<span class="math inline">\(\Vert T\Vert=\max_{\Vert\vec v\Vert_V=1}\Vert
T\vec v\Vert_W\)</span>.应当容易验证:</p>
<ol type="1">
<li><span class="math inline">\(\Vert tT\Vert=|t|\Vert
T\Vert\)</span>.</li>
<li><span class="math inline">\(\Vert T_1+T_2\Vert\leq \Vert
T_1\Vert+\Vert T_2\Vert\)</span>.</li>
<li><span class="math inline">\(\Vert  T\Vert=0\Leftrightarrow
T=0\)</span>.</li>
<li><span class="math inline">\(\Vert ST\Vert\leq \Vert S\Vert\sdot
\Vert T\Vert\)</span>.</li>
<li><span class="math inline">\(\Vert I\Vert=1\)</span>.</li>
</ol>
<p>只需回忆极小化极大原理就知道<span class="math inline">\(\Vert
T\Vert^2\)</span>取到了<span class="math inline">\(T^*T\)</span>的模长最大的特征值,而<span class="math inline">\(\Vert T\Vert_{HS}^2\)</span>取到了<span class="math inline">\(T^*T\)</span>的特征值之和,考虑<span class="math inline">\(T:V\to W\)</span>,见到:</p>
<p><span class="math display">\[
\frac{1}{\sqrt{\dim V}}\Vert T\Vert_{HS}\leq \Vert T\Vert\leq \Vert
T\Vert_{HS}
\]</span></p>
<p>综上,就可以定义两种距离,容易验证它们的若干性质.</p>
<p>因此容易见到上面两种范数有互相等价的收敛性和极限概念,柯西列的概念也是等价的.</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>壬寅年末</title>
    <url>/2024/10/05/%E9%9A%8F%E7%AC%94-%E5%A3%AC%E5%AF%85%E5%B9%B4%E6%9C%AB/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9ea2d501ac2b63fd7741a017682357148d4c9dba30b1627e345df7e7b7249731">e55e8fb0918b8b65d60b5b09d6dc221c46f3df1266a70b6e74d98c37be16971262c58c70cb8f30f7ee682c578a7ce542f95722d9eb194bc84eefea9665c5f28894876e967f0714ddc183257908ad684ab922c675b00f786a0bd67516ea8906208d54a15f5bea0a244d4b43ac7e419aeaa96c7b9f05aadc551dd9ba958aef3d67a3761c9e187e1f3add725cd059a4304ddc6c430f5d1e29186ee94f6baf816d5ac9a73575e694a48292c14cbe725a2d07c89c84811561cb73dcfe4ea2fbff97f56c6f2152432619a8e95511b67647d5ebc40f892be9b8d0819e40f89ffeebd32da8e27fc99205a64905133257e77bf7c1d69d6574ca9c39199095bf8c7c241ea27ec9e27708962309747cc7c5ea16de1c173cbc67ef4af9afe85636d572f1e317c8f21e62d7db135eb431009bd0ea1487beaf69b3de3eb5e333c45795747702feb5196815666e53cf80539d3cbc5e3fbfd4c540607761063d3a6e91fd9f7ecd5c96b10768712ede7ee4b8065f63481b1d2dbefd3fb1cf7c49674178f3185afe1c4142d54643bacb65b0898b582d6b0e20175152c788113c0a417b675ad64074f7a69b8704ad4d08cbd6f73d954f19a6f3033305571d18deb818ec2ea614861b06deea8a994468d6cd5f56846ba860db480d8a045e4e33c51ce60d4953b4ff275666a4e4ca706fef5498cbbe00e70892ebcf6c2a0b463947b00fe175cc83e7a7935ed47aa3ec91d08b18b4fa6dbb789a294e8bd916c0a0aa3eaca8470c9f5c48add52fd7c7e2242ebc8562203f46b6e317bfc42367216b98ecff930470e9991cb858f3fc6f9f3f288b0d12157e672d2464ee18693097b38f677a5d2efad0e46f92a4aa1693f8e9c71156e57c2a2ca0370c5f458e3f05dcf38f92d285dc6a8469fb0e09b2c2f75e87fa369a5abab007aee6d9db6e01d1a5771c8aaf70cc184b5aca9727e75aaa0f129adf408874ae71fcd4ce1e635b2bb947668e6e59c4cbfc1232e1911a36f0a7b6a90dded1fba93341adb6dca91437261079150d2663581dcd4660942f2be4434329c31ff29eb8d7bb1ad8328a70d94e641a0964b54f3da4fce5e08a3da22e3bb788148b5b2198f7d1fb04b8ef3d8105c1d4ac4915db17196f36703b34707303a5e7c4ad9fb36c4d65b00a01d74aa53634254623251957e7ec76f72f11a95575111173d04e0d1d5c6e4f84749853d9e3796c7b17dd23eb027d6c15f325044f5e6d9507d3f6480489d1459afe8706f68224854257343c7f05cbe593890b11321dcb86cc232c4693aea572bdabce9722bcbcd3f3327275ea67d7b585b4433b8e66c14f0dcf4b84ccc2425d7809ee2268e121b93a3d011b8555a7ada55893bfcb37bccd534fb4e6d68fe68ebcef8a1f59c9c55d8af25c369bf5b729823118b0e933ba37e807ac4482bf85ba1b54431151d6a0ad12735ecc01f3a1fc23e88e4c4be1b7523ea6a6ca88d954d7d2890fefb30551db1c682930266c9b3e0a1abbc7f431cef119e696e57802018b39421671be01726f41afde3b75c588c5fe36d1f6c8f52747e5d34e12ddff7c3c3873c7e6f220dd710c894452b9b20d0be5cd79cc22f9d98d5fe5bc09b29185638faa7e826f6302b2910c9e5d91be5b3180fbb6ca8e454efcdefd04dae07f7f0f15bb2f5053039d9585bec1348738e6132298da92be3c04adb3b5bc849506666d530893ced455a79ff9b3e0bc001b579fdff3b590e85acebb05b7f9e31e24fc762cb1a185ab3e6baf98ef86df72de83f41680276877f52663de38f11d7e41e60eb05d8ab06620f5b04e0161097d070afa933c12b6a5c4751effcaa109257006431ad459ec413e189309cd326e23b0f3cc628388a9cd02b94a76d9f2c0f6a1f93e058d24992f8591e967904c005d647fcc20e4baa9626a5a1fad90ba43e1b12ba16ef91e49c18c6160b0d333f30cdf649e496a056244b98831c12291935fd6bb3695bdffd474ea2bf317950746a7ffc19636db2661bdb3074f40314a9421f8d7cada5df874d0af534b9cba5676b552e547a5f9fc5099c634723d19559cfdbe78323c23c351080be661d35a0f6abf70d10cd83cfe367455a2e9e150518379d87038870d99bbf8b785a0a6d868c9ac9d155608c045ded56d36d04e13a820c74fd203ce2841c8f85de0515b6c92d9517a339efbcfd1011f5afb21bce2504036244681c4fe163b6cd3e0e1493d971fb9ebc939ef242c39a0fa1b5f80dd43be3c3182b6387f5f77a9ba98f4de20eabe55d756badc70fb2658f31b62d3ad035c7b76267eda5beee1c43e2252223f113bd36d7cec3271e9269c6a059d21fe5f43a577642a526e690ba0577295fb02992f3909739262a46bd9b36c6186b4658ed3d52d5f22e60289f9d407e266bade02a3f929754e515a34087570d67b09d972f90e15b0b28e14f5c93801f00a520463934050e8d171c2005c0e57203bfd8827e59642b7682086443545024b7060fa24d553ee394bf1df4206208f2bd0835fe1bb8948b196d6e254b28e87ff857a9b74c53eb833be5194f3f377e9101922278275604f12f0b3835773b4db5af6182ed6df683a44eda7156e2743210f47de6da90db5d4840108ddf0977f7a142189db93e6bef2965ea964473c6a55c6033c8dc1c9b54dd3dc44b2b9c9e57efd6401ce4d78cc406b0f59133fe5fc47906a22c91cda248f358476e3b581186a5f85ee9f91ea7404e004e52d6d1887ac8438baa2ebc1f8b7f829e7b927e31712cd599444a5c9715f3d87ba6d301a253a41bbd40afcad74a2fde9bb8d459bd478537c248b8e2b3516242152c1f5bfe7d51105b1dd98dcb1c50c816adc2beff685256d73f0bcd921ef59a1be0346600a41c6978885796f252b2e3e9a569de762ac898254db5d7035ecaaeb3bc74716b064138fca2e3a6b03f3092a2a1fb2da4f061850157e0752e33d7dac291c5ed09033c10117870e18a27b1022ae6677f0e5177bdb8da4daef6b06a0e5c86e89eb46ffa1eeb6f1e3fd6d66c90c404be7a5ebd1a10ceb8f5ab80d97c5de7f3ac228055c3bf3f684258c6ba35f7d803a8b2d5e6c24da58f57cebee9563d8b503dabc255845ee6fb88a6a9c9b5ce9d4ca840ae83c1109b7918fee617eedafd7b8e96688183a3add111f38a45e04e6653abfa511aec16a54a4deede53931ad45bdd43e3130629905da6a0f8b3b9f85a56172e592ca721d85e7ba68eb918845949fd4a06df9b4e9e1d284686ff3ec997af5f1756826546a0642dbc336c44f7461c2e20de7a1fd5af14e74ded7cafe3ceaded86e929933cc407f1ef80f49d7c045365f6142fd85f5a1dcd96da534707187bf0283267cb4385a0d86c08f7e8e7c0e14ae0990ac0586ec5896c8119a56d02d74d208de2c15b61a66748d9120ae57df6a992805de82a7f5d6935e4d31414a69e33fe4b15fd4b9a4b16b04b792a4c611ef7e8b8c8ee558c764ce0e4e930e5b41976bdbf700c8577bb70f4897d0d1736e74b43081bfb815ad0f74cdce6a7cc64456ea6022b24947461e3d75e9e185280b09fb82991eb8c58c9bea9228ed178ed1418d7c358deb231eb9b7759518f68944023b30b8048bb848a1fe06c0647b04b5aff64ca0f50af3b562beb60b352977bb1dad0fa15868552e8405e10ad2e9cb70aa9972e47d7c7a31798873c27ad801960ed21e4ced5225d0fe6200bf84196ad609511b21d92b427f59878555ddea97953f8a04f84ac22ce0869ebccd1782dcdd5182102e0b9af486a10e4810432421fe633afd88d095c308fbe0e964d31bcbeec5cf976a8008f9af593ede999e6efa48ef77403308ff096cfb4ac41ef0184bccfb7d6b2ea18fe0ad29f2a8ddbfb43ef42dcbaf046e5752233b496bc1e3e4bb1d5c3fc0895ba4e83746e5a156f5a7cbf5e87eaa70c33f5e98f2c2a52824ad71fc2ff7379c7e9d15268901cd5b0692f3c92ffc036fe62b0e8945f524d5df568d90618ea2e609e10337376d15b2c4aaf3ca25d2eff2ab0ad8cada1e110565153ea8c78d848048e6d6a07931f5f733619363e111e535aa1c2cf79abe64f602ce3bc9c76e6392a3c0aa98fe24700f8f2710f5006cf300833c61c343e08bd894fbba557f27d4a5dc9452da0b5109c49035154d20791bd770cc27ef03cccfdf8fd5fc5689f1e6625641b32a4a5e1c9ee8ef34b10df29892cfeb8d0f8947febeacb54f8afff3eeac7adb502a6d65cf612b0ee0501e1e71cb78a62b16354882cb06ec4699202803fb36fce72665249d51b9fd67645036f6ff3c06577f4ad08595be850c79768451a2b5a8e8aa056fd855e14c91266a4d5339baf34b97488782b33935c2d3843aa1d56340199446f3709ec1e6782f5faa2cb91060bf22035a9fa96e6d09740a410f25762b22b69983a5880018d37dc6d469c1980ff5e307a67d51da73876ef3d633ed34563dc6f45ec719de9cdbe68c44208812a07b23031e6931f3ff53f14f4a039ca95332e65a5f829db006002ce9dd84059b9a3244288a290dea38aa7ea09694e581755b74b9aca02d06148d460379560b73d2a5986877c7e24edff374100537af45e989248fbc846f8cb8343e37e831cf475b2af89683d9be1078923b05f66441dba6162666ac5240504178fe68a73caea5dd77f2fb8c09e45e5cb8cabb1030b0cf67e0fe37745ac42736201bc5ad607c720e2e97ab4163df34b7ebffe4b75eff5b085a67fec20886cb759ee37c6d55cb06439575cefd7e5b06767c23fcf25e31972d027b256af7c35d3c9d86f54fa8c4bcc8c3d50866c15582f7cb97d567ba6e85045a1743a1317bbfaa68869dedfd7fb1d269832e45150515f0c1e73aa3fe78a0b69123d96eafb20ff0a9ff4f3f6380ae40486f56e2f7ff2286dbc4ddfdf725dc638f7c40c20206a5dc7f757c4656a34c663142578b168dba00bfac0d515357394ea30fb74f61a237e819424b5b7ebb324e531235b432ec503c6eb5c85b9c31562be07501208d449f0dca861c30dc6e691561daa6ea4b22216f6d95b8151edc7058e4ded68ebf07fa743be3e29cf7cd2c2485da153025c64dea81764cd51e19b11c73101092190cad388956b6ba8b5a87403a8e65b3b1eac9618467bb6562197dde1f399cb4ea6a30216a25d06d09d388f81f42a50f0f766930f671fcb5e47fd3456551368f6dc00846db55ef3571f74eaadcda8e8363a5d779489349138bd76d8366b80edb6436a9b03f2aac84a0f16cc5874706332561813bf58db0cbae7e6b2ce0c0e6424a3a2b6d4c9141dd00edab34fb72d8c6bedd47210ecb13878cde4e6e2ed9e1db8fcfa6fef07625163810719efd97dc67068fdaef7e1845e5537151da087f7b8a17f2cb9e08ac0fccc990d3147fdbc51fcee2a85aaab07790abcd79c847a9437c24669c99c9c2d2ff558c9be8092833e48d28a62e30a4a21fc005296a85233e17204419b0adcde10ef4d097394d6f78d2b0d8c44445f1a1c6d82dd3ceea0b0da9a1b997eed0ae39b70bd98ec4aa603f7e81420c18b6832977272c2c1264311f92a40161f0bb552b7b86f7cbefe70ccaa892c1879a119cd403473f79c96638674269054679fd45c5533769bd0a0668ee3a93c103f55d04ada833303003972f5f06857e22113b68c1b275d44f6496140c71be790629d8697c16c3a2a8ec18cd099f0260a16c0e07f9de50eb2f365473d222da4333a6afc09cf05f261a0c0b21a8e4e81ed6fb2e95b7dd51769b932944ee00f8279962d2815349b8483691a5d0b6c79c6bb908eccf150262b49f493ab12a420620cbb5fa979bde04fb0e96222a52ffbe255f6b25053155bfb69530b8ae494f7c7cb1145d271cc0ceaf85800f97471cc3a3b7cec0333e7d3168a0bd958ba7ffdc51b3c61d3164a679377557d6249f3839975722a9c738d6ce8507c3cb1158dfdf201e0cbad2e6c134124690d0ed8ac5cc8fab0e2d776b7821d1b3df845d476cd98dcfab3c5106ee110ab685b02162e21ec2a98df7127bdc833a6190d98977c38a9ce73aecc78a1b569b5f10bb70c688eb0972f03b7c28399c7f406b495c49ff6d2196b642b22ee633446c0c9b0d3a4e3501e548a482c5acde8551cdba657f93617910b24220806cefd34b5524108f644a54ba4fefc572d7057ce0087659b0b66e8b7b8146b6e306453393e69356d92a287e825881ccd6ab86911681af25254a25decf553058df7e38a9634a7c24e1140ca4128e966fc80a57680d739e8277559c0b4d9dc889e23a078cb10ac5e14bfbdf162602ee7018fb50bba2c58781db6cb6a9a345ac04e8ab17e3fd74e9a38fba7b55e56cb0c289e40db01265e4a17357034a6eaccef19d779c8754cc716b43cf28b2c8238c7c9dd21250d1f621056b53a1256bed2b030d359b97db1fa4348ee55fa44d295f56e3c8e0207c295b0020cce2d516e5539ad5cdac91dab283e4557b0ee7f5e15967ab8d1b821b9b7c34f7e571cc1406b6154e2e1138104510545b4400e2ec4dee893b021f3b57cbdde31a360fe808266d5f80f47ab909e8ff443d3d96ab73bce862ddc2856da85ea6fa2592eb09b9511416e9bac5ebe1b975b49f5b2b08b93ea67a90ab62bf5039c45a89a98a70f1b84b772025a594ac1d36fabdbcd174b9aa33041f0992640af9af68173b625b7ee2407ae3d53a087f91c411f884f0e789be9e60143d2fa1e808315e27acba0a6ec486688886fccc32eba3508e187a92526f9f80d656848e51517963e3125c025bf5ab062cff2cc2b6a3c2f261ade54ad45cdfb7fd98ead6b2964a68c52ce42ad310207da4e68816196dccce896b7ef21ec5e6f54b1e6fd2041e1d05beec0de728ec8773e007f4c9af267e7012af604daa93fb04440a64bc5604be383a7cf7637771589618c0385735e426c5d18176c0e2c57d0a5de0bbeccbec17f905c31369970622327a028aaed2184906c197763f001e269a3790f61e323843c2b75c5eaa08f1a164fa224933a86638c87a14c67e000093190fb836dbc1a1a6f322f4fbc47ea1506ca065cc0ca88fb1d3cb56e28b96ebd8e6e8374e3e8b14cecb715f1053a97a545c8b2ca4fa823d81e92cf7fbcf6fb4cc73aa9aa7269bd0dfcd0e78004853c9512b82bbeef25b020903d5eca5b172b6c7e2706b2cf86ab77167e8be69a8233ba222113fa1dac2ef841bca7ee3da00e73bf9d2b4516e48cd96d5febbe45f3ee91bc748942d1eaad526e53c2e696e6d838db3f84e78b319d9c47a28970151c1dee70c801d5c6f536fd6d42369365ded2e2d6d51e39447308add0238bec600969d297934b0abb2b1a8d5bc3a0a3d69881a38716a6ddd718a71b63de3df1e798103e7e638e1c89fe95ceffbe73ddb1cebaef584f4d7c60d322b0e2b104ad3317525184a1f9b8fd75e2fceb40776f74af6c149e5ec11fda3ddcee02a412988dc5dac5800ee4686458ff81232548a0479d89047002daa29ee3517c192197bbfdf350984fdc5176f2695cd8512cf87cde8ef6fc7388cf402983085394f82d98d4a1f80f9a8fb05ef96a7a135fc626f3a33be0a4ec32c4174dbe74e749e5f4fe6708de7dc062e4cfbc10dff3b6a843035bfdfabb5a12260bf9291defab81dbce5938e7d4ab2358c9d98531d60c22230602e0665720eb28e9e01a6b3a45e7edf7a230a920f3b65a441b935dad503a6445eeb75a11eed192dc4aee0e81304900daf57ef5540316f2288ab7cfd26a331161b7ad1f07fa296b21a68b5419ab999a83e14c1c14d8b63632c651f5f06ba834f02c4fd243e7366bd9b45b3ff29dd0fbe9efbf8b2843f4a71d6f26d12fe2c86871803746da6731c07467324beba964873f7c505726b19426cffde3aaeebb56a88613a678b50efb3d6c1027039af924753662a2f7ca91c4c8a1690c0f68644e9687fb156e310ba04ddee87c60d2215748ec2b42030e2566b1170e07b5f46da9bd1307ebb9ed109de05f2882367bde3209f5f21769a33bd933f59e3116ef41153a735650ecaf680bd94c991d03cbb3031fbb454d20ef32eb6d4346837dbbe42b082bbaf1a4476dbeb8a9cf388400fe036b0a2c45e611a484eb970cc5dab57b2660443aabcb3157195e9c3c837866a540d47ccf1d568f943067737a3d4ff0eef2340d672c765f026c179b37d1843c06cabc983a9d6775fc03d025380203b6f0fa67775266b943e0ba5a09f721f5d415cc21c26992f5d9f6ebec640bc1d97978e18efbe8c58b906b5c3eadf87963444f6b6796c9b1a705a2dcba46396fbc15dabd0199da700385ddda0d86c30f508ca34c903282bdf8885deb0c418e03be466f5d9467e37d1b9f6818424207251ff875eba696f022ffd611859d7315189bc0739196167075aeef740fcbbac2534a7d51f148ee81bb30b5cbdade0a3c7b4bee245d81413c9584a22136f8d8a6e96587c839efaa927ceefc070f2f1f863c412d7fdb3d8d2df6bfd6928fd772f10f8c3f6a85cbb8de42e3dbb29b257f8cbbb7f411342910b040677d40937592fd5bdba786463dfb938e459402c03bd002edba0e2fbcc086740b5bd16c2b9fa3982c32c82508be7b94d40299e7c5ea1719aa76783ca7d73f36c9f2108cdbe4c75bee5abbf59accfac9611c28c1c98f14a4e0e9467256e313d277a55e97b277c3108ba48ee37f80ff295502537334b116cc8a82068f5d69efd17dc75748115f4479364cfeb8083f5e6d18fa87a732280368fd3cb6b468f36508a68ea8189b699b3edfbe40614428988820f96ddf80a55b50572844e32c51a45694cceb14e4c528c2e031027cfff347dee473da2ab4925754d310f48745daaac9102cc8c91bb9a62471ba4304c9fc9f8eea9635919426e7c47ed34bd3598c625b3e747f6ea04a1994421b1a79c46c997b8a3a58fbbfebefdcb72c510a19814f0092d55b5c3c1897fa05c8c67182d17239db3301f74a4921808f25fda57728b39b37f443722e820313b08827087513773dbd3b20743c4182395f39dd43b8de4488d3901d6ad97a6c52550a53c07f3b9b06132763dfba015ddd41608c0af851371b959804fdb081d1798ecb6e7ede071cdbad9bb89a59576d9fbd3e511234b6637e43f093630cb3b6bacd7a706720fea3ad7220f54ddd824375e92d53bbd9c9ba7c1237c59742eafd268ec1500322a67d7b023429610622da2610376a658dd1bacfefa880b174c967b3e1daa802cb1eed1031f893306754374a1fee8ccecac157ee1ee48a409140344b96c045221ce074d2b3470da1fdec675d848dfcc1aabebb7ee5632a92abc2fc875059ba4fad2a4cc7f79a8f9779b55f6660b19af55a6c77c6589e6a7ad4181b3062359f98e0685c98f427b655ebd75db4b98f2bc7fb267c3e1eaa6c3039c15e4ee51d415ad9fc6e6834624dd52b671499d9d9e0cb0f1f1aeeac971a375db781c7b63e1890befdf8a003c3f1dd763a8101e34f42d4d503fbef69a416861e9e94f41081e5e9996c7986441aa7e88cb41e704660a6f50b56998e4bf8e63b86b559f7bb67e42cbf213a06bce5eeb8fb49418cf438e95b794cad56e4dd7bf15e031bcebaaa72503edfa3594450981988760152b43cb700cb4256a9b1e88e1134764557da04e4c3b0387eb9d6c8ecc4479b49c9669c9bea54112938a23db36bfd847e27f472afffe6dd16957aaf2b07e095c6bd80882d8b963a430f81b4443d49d65ef2fd2ec88f3527cd7c03f4a7abeb1d6ae299944b617f050748890f616694d66683be3fcdce76f20d0b6bef162487f43150b03ee0cfe224ce37eeafff551b4a03ad4ba587fc52f0569a3b7dce4b0cad2e1550a2da072821cfdbfba06947aeabaeec1d560005d6ab6df74cf49b454d673ed80ec3d8204db655bbbf349c183502f55c9afbaa4d634f05e7f1508b78c6fd881242481045402b99060da8acf767680fc797549782f3005a27debd6ba16f255042c24006f038579582258f0144634c9cae9a64b0d45c93193843f3b756f2aa45c73c9c727e2bb886181582aa0e9e78122873a781c54dbe3f153333dbfc71de28c2817279e273f6de5b45179539da22edd7def435e54099f24554fe767d1b39c0f4acc953f82f986390f2635db299b020ded12f0df0323479463ca9269c4c5241a57d79dd148ea7dc2dd30c3ec17fe17f79918bbc9cf3f71549f01d37568075368d0b3359195c680162fac501e2b8ab55f198b4aaa516f160280133d906e672c95d5d5a5a39c0e9498d027bc21ef47b07fe12c27aea80b7edc5fadf04de3e75cde9d7066e1cabbf9944141bada77f3bd64f488db39f14c7c68c190c7d27930ae020a491c60c531570d8c9a969b352ba347c1b05a63957e9a85f5a6295d1610efa53cbd713165f261631acc370f31dc60bbf0648545567e47151a2bd1ed66fe4fe1bba0188d1dc123f0be0cfb96ade0864abd86086ef8cbf3043c9278d1303938d53596052c5cc85045e0fa8f6ca840fca5df0a99211fd2dac03b57394b7456296a46532100dd2854b0c0996daaa71e12ddd43ccdb6f923058125e6cb380d64ae4ea29d0a9344323c5cf8a4097f4e945e223bcadbe632c273a2e7a5749da3146c2ace4f738c34ce0e736090a22e959b1797c2ebe030be445633a6de9afbd7f5fd34130d10c26d0713a15e90693f50518cc393505ab633087047137415d18e3f4808da76399a2adb80f2463903068e2efe69255cb0ed54d871d2dd272eb2cc783f3f8e9f85ef4fd0888b3fbf00418ec28bd977298ff5d2710a34d6a62d599c700186581beb653966dcaba86e3a9127cf1d60ff113f4aaaa5b0317d1de41a0477016d6d03162d5b8d7cb937347b957aa5f1673add6cb2ca53083bd0ceb2e2d77884ba9e3af5a083d6fac1048ab839d6f75566c0fa285dc0899dacafb7ad7497c8c92cf341346b741cdfcf4586baeef3d8b22e47b922429ca0fcc46994f0d3933bc273eab17da5e12c298b34546e5a74a4e82907ac5e36e5bb77af08d031c06d5d1f15b1e96896afe65dc9a1b80cf1b8b9a5ce057badb2c8825be81be5b22e84a493c70bafe8021cb5d0e40294a9c886b77f08377487b24277b694e9719972e1ef46bd6cbe91996f62e6b6eacef2a3bc87dc6b807475181186d04fc829c64915560530f24465ab3a58ead6c909f19bb0bf3e96038ecf75c2f62f22f4d762e47d0726e903a5fdc1f21486dd05b4a1bdcc1c2beaf0d7c6d45e7b1c75f27124c40797178c2f45cc68f548acce147414ebbe5353d396e56187eead1a238a0564ed4d9ce5eab2a7088033cae149f25a03c6e165147ce6d604ce3cb3796aef46f9cf881f763203ab364f65543a039ad8fe7f194f2733ae061ff8efa6fbfeb098d39fb5dd1edb060806ddb95ec955958c528ee497f568c70c3ca86b37ff12681cf20e47ddbd5269e2be6be3ee9354c0b12ca5b29a8dff4852e91b5a4c671e457134088f8844ffb5a6507b0d2a8cb6b20c610b003dd63b260ac08bb9e9fa4cff807e48110b81452be76c24e587a9db4d7a56460bd0638143e051cf8a7e625a2d8500323ea5c0209d84db9e5155a2896267c3cb3fd2904e19cd7339939460ea8edc1c9fd95344ee26919f29d0d37374c4e36eafb2846675fa55511a76866f276eb4b2da347cc45eb1f38b98a3569ae3fab7521ad832e4f3028634c24beb26bd94d90e92e1248e14ab13a15569f34d0f5f1d76f65dd79a2911e4c32e0e93a07875fd05c37e3ae2eeec281c71487ad1acae1c09c9d643914e4bbeed4c5f360fc73125866e4a6a1182f98277537b637e6f8d893d6ea6e7ef8bb8b6f73ec3617f83ad9745fc1461b41341839cf4e544b87b9ce776780ea5aa4c5c8cdd299502e1d5ec68b7b8e452bd8d440f1f446c13c8e53101b574a0414888c2537a64a0d2fb27252ce8e27321afc061167345a9495a4deefdf429e1cd40d224c0c46f0e68698d5d3019ecc83457fdba483e5efe217401e3833057ea9efcb43879d9aa65f3fa2794b88060435187108099ae35b13c686ca72bf4745a44e75b6403b3e544100bd622e7cac4928e824c40e3d7bbaca1921f6d7030d4f97644806c3608990ce1c025d02c1438cf6b884cdd9157969a6a593d0eaddf8b7e1064c3e8bf40ae63ebbef0b6b2e68402a0bc5a1764750eab4acc161430911c3e515b9eb6b7bafd5e111bea95e9636ad7c4a1ff493b66d9d7ccbb96814fd3cac440ef3aecc0820bf0a904dcc61dee6573cc866724e3f362c4c0d918d56a872939328ad7d60e84c5006602eaca7e066a00dbe44a5c672ec3d0a93b5efbc0f7ed6fbd0d9dd94a207ee2f34d5e917a296a35718df5d1d6f29b097eb563657075762be6fd70b367bbcdf42d4b4b9f27c10ef4002de2b15360c2e9ae07e34b076eb9bdac92a77e2f8d57acd4a5ed71912490217155e5109167a6812cd7d14b0e4e9cdc5cb58a4005f4e705f0b6f1550b0e3eb9f02c4ccb30e33b79f2c44452ae20f69ea81b6113652b202358df600a89b5e701f91790c01d247128e9749fd29915c211e822b14b0011a0b6cc40c7344449cb26a9ccdc59af5169276523ee2fc5f3cdfd29caa0dac95a8a6af0931bf310d566cd8066738cca7d691466a802f8b3c38abc319714624e17d924aabbd48e9b1406ec0b7f1f7ccae2acc89ed9f82efd99de8f286d3a6aa9c3e10701ec9a6ca6a4c0d221f100e824eb29f9f0df9deeff63c0139d2c92afb3f05b0c1434da5de780bf05a96e676617fdd2e3234485709095cd018a56b18fe54c32027eb3e756ed888725b10aed7e39bacd7819f033a771277d3598d09961d48fa6724655ca132625ca6de8ce1afe885555178bb7f492c960a2cf9c71a9c659e29f893a386acc90a07dd1a5e505dd0c60180e3e254029d6f52a27e3f2d7ebd7ef3a0a5d2d64edf82ea85e0603760a8c51eda02c2739ee09733b02effc90ba01480d04b51e4ac2534737f0947b5348a456313b4b08cc776b7b90a36b9ee940793286af94dfb634d50c36915d24a4f8883b9d678a3822cac2dedb9d69f7dee276488708165b1be4018d621e4d4cfa68c5141c517c6cbf11fbb80d29d8c7287f0e946b8de8089ec8ebe779c53a57c395a9c9fd1c53cc78138909a746ec09a8a7157eb4eeda1cfdde5aa45d46e4aa4c3bfa0606fc05ab69f2e39a5a9b053d91275726a9a04d44e7043343b332a4f3fe97a147e12f4fccda11bf8a3dd38cfd4e78415609c6df462fe6cb7d5bd322d3c3811f7207306a54a2457bf9ce250cedd788a93716fffe7a8b6e1adb3789c7ca3f6bb2612782f166c457914d7795caf7b1ac73a214100c427e25ce3f7820221c78db99fd0fd36800b343ab2280aa89ce47a9ba0273397952c7c674410fa4947715e072a706cd4bc8e47495876e3ec2a893d68df42858a33ecaa0bdf1613382ae83a26ee53ae74c688e918e5099022dff73c7c7d1e8f36872d259c6b236c7099037ba535865298293eb1f008d4c4142f75272b5c88dea9b7c323be84427ca6930c9e9b9c72c6418fe777dd552a0b6cf17fcc85e100b5c83111a1898fe4a885e378ebe2f592b5c512dd56a357d656d94717638e5de10bfd9c61839edd0c4d56590738d87f1974fe424837b157790f62411034239098f4d9fc3891cedf9d6b5766b13f3f0977b990395310013178d91e2b0d300303862ff1fd15a877d9090a2978c3d2108957f1ea126800e038c0d330df3e6cbc78fd3a3694ef0accb39ed231a69b6156561b6c09f4a3697828a8267e42639e785fdeb768ebc298197d3aac3c7aec4d8b0365c66b46a8fc2660cda4f182ba38e9b137045e8320450349a24de5f29b8c7c9d1939c3cc1d931dd594df93cb69328fc8e8e5b1a67bff374e2819bca8122f66958c4960d2863e7bd3cacde6874a691976d43460be061754f8a800c97e222fc964f6a205db0b8bf56e84d066aaa5819768b804190c3ca130dc8cfd697061bb4dff364bc4f1927ae87fde9ee838096aca9d853b7e3e6d2ab7a6804cce04513eefa8b394f64c249784104ad8cfcf13aeb39686af274c56edef8791be241d6ef8854445a79bb8fc93d6895cfeb0aad2c3b77b80e36c2ea8adf93328a4c63f8e961c851830db9ae94f3eca74cd051bdeddaf18a1b0681e0094df1f60d880ba0f90bb851baba60d64ce49036ebe441f656d872375e0a5c0ce7a7f044d19b3f2323f85b384c7eed387db8edc383b0d4d0a68802f420bd25491b74d68ff9addd9f0217bb74ac2e5088b17c6f2323cf4a009e319d7b41c1fbe146cf365cfe3684f69405e5412a05ca29b3db35f33d5e75a645cba2df9db1c297bbb1a2569ba4bbb08f5c4c443ba0ada57a77685ca2a7db5d9ae4557fbae66afe51b1814d3fe21b83b52180ca946ce5c4573fcc3a27ff3cda85c1b801d04f98a570e8e78d9298ac2c0bbcb0cb9be35b1e067b032c1d05a09aa0ca40a8297a4c56cc1b39dd9d57014bbbef3d858aa3d1b129cd524dbfa79c21e894006e05cda04f04c01ba84e525d5bd190f4667e327a768522b1f1f0f86d1739b208e8f8137a4c8d9b0f06d7c63ba766d98e6be9574291cab40207c7ec97fd6000aaa2dc5c93512cf4cd6965fdac79c7ef8775d3fbbe4e008e311325e6a4617f6f7aca1f5929b76b2b8548461f95eda4c9ec3b08dc7e99142b99ca79430cf6332ad063b6e635b8e912ecd75d629e58a6b82aac81b3d727b9b9c0c7cc01e73622e06e8d309fb3617bf807611bf1bf914d1955a7f589fdb407fcfc5c5238aef752cc64b6adfe463dc82316074e586bd4a4a20081e32a848be8a65803874e0a405c411f0067ef6eee569203fcbfb11a82966649a32296a019b82d76a873e85b4502ce1df663b7a04686b92b9522c2f3abd0b2ecf9430284790346430ea9218ee56fa26e710e8e8e05261d68d9ed9ced7f6047b859e62844870e74193c11c0dc58a757005128691da50c203e1dab14efa518e02da7dc1858bd01d9a7917d71e264a645daa47938f610b1b5a48f0bf9d307f55d63502067fb3afe3e90adb4574a3f307c5e27fa3afa61e7f52b940f61f96712c3b4409db425ec068f2e58bab919eadacbbc1cefd0186228501524478de153f20db7d3528baf6ec555ba63ce0db5544d37b48bc234e25cf16a66b9dd422d9f530a64ffe938089aaf03890f733c5c4a3f09aaf4725804db0520e15f048923c50a9fd5e6ca443a634139ec6171b952850f3d8e8bb165489563afd92930596ebd3415db8feb5aaa45f5f08ab1dfcb5cabc5c401d02c829fdba6c24786c891ac2f6ed121c698a8e6c8416a3a87ba2b5bec5f6b0cd8ef09ec0be4952a63adcd9d13484cf71f1440dbf0aa11cb6ebb3a45e1fad2dfdef3923a759a7a38e60205fa6f7355025e40e75e1cae48ea6cdf4a3a9914873f33796b0030814abccfe44d6efda06a20ae145c99442d5392e13884563c908a272ad9c1e2712030757cb1537577f26b30bc08c5d8a38d658017a632526e30c22321b7131ac5f0a1716fa73debd9dbd1c3a82a25bac87f13bdd0797510b9c92eb97bbea9079b5abbf17179e5a91f54ccafece7408cb5a390b6008f787d865708e42506d4b801bc953ee25c8ca79d2346745513cdecf91efb65d8356a31175c24c49442d88d23c8fa8d2c72fec6f6299122f5ccb77e87e05bb011c169b24f45fd27517951e1abdbac8af3d7e0443fad4bd485c36d352c517f8af7a54538f7609e528f7677f8c80fc66c75d240f0af4ed8a5d9ad7be1754076646878a84511015398e1396f3ec564ecb4a25c0ca448e1f5350b63d012c9033cb4339aa009e8c6075168225644ea03fdf4bac10b7375e6cea8b60dfda89de5d26e940a7539c0b29a245e4817981df948954e18b95953a1a546684762e5d981f5bf3fca43046e53302e4a43969305c2eef59993bb87daef19fc42322936abec2646f0ea4f8ed5a62203a6ddc38c759278dbea3f67f76311c567cf2b099639292166c1a51b783ba521223c5ae879ee9ddb83ced4f25288260db8977a36373722a186c4d1583c3ca337be1af1d05c381c6648e63b94ba54c83b46b5cd28fb61fa9745dbd1a5c24858ec4bb2a5e4ab4478d6392252500152653fa5cb7d5f1cd046c8c9c281a4cffb6ace72ea1bb9d8ddac5c448de4f29d0a7533550e1106427ad4f46b8a82e52b2c1087d82b17f27effa956636e345df3581a92e3acb2f90a9e7259c4433e654a3a9b032ac6da719379197fe664d35770f914466347c393aa58824a7573e65b5e5979ed76540bbba1395527d0b2598172ebf6798dd1ba78970cdb623e960bd68d9209f1e657bd04005e29fb07b25578ecbcddf90c2388342420ee0157e9e355c7d58786bd0f38540fa043f63e58b20c5a4e79fd368ed5c8a7670116263e69d436a0b8cbd400158ca4df70c473cf9d0fc71350cc0034de321fb8fceeafc460041603f7b31d1e3ecfdc1cb11eee5ee99c3a2e9f441b47e0b3b5e2fb4bc79285f5b6b0f40a7026b110e02d382f0e79cc813cf24cde91de446f719c67aa62d53ff2729a584675981a39f158c98b9bbb381c93093aa8aa117adbab7fb5b3cde0dc780732db8b20c8a279ae21c122de662bdfc56adbfc7094b8f26c641c9e0fe933fa1368c1215a9c8511dcc67240aa35b0105676b91fdff33f13bbde541d1b772e2dd35264b582706b46a57f93d828d331dc615e12347f6741473d31d63ca558bfc7b592e071c38d08545e96ae81f32e149e91ab37c3dd77b3b4ad908a371c29d0f9465907b764c3fe66198bd9550d95d41a617ef6994d1cb41a67935897231a114355acc9efdd8217ee2d4c632ee4dc0dfc5f3f32e9d7701cb8bf6d87718c80bf78518daf5204c596eade7d50aed9acb01263ee4bd18c6f897a8357fdbd69430437d808c6754be5a8b26f37425689d565c1b58027af098289796eda2292ed7f6dfadeec963862f2635e36a7c242a69df54093596ae3fb56924b4213daff4441d1ea9d6663eaac4b312b0c639735268fe46958dab6e93afc0c41769f7e46a78ee8266bc58cbb14dc53e336d9fcc599f728907f57f54ed0e705bd06fc433c345837dd4bbd90c3f6bd3747649b5b05cfc19075eb7ee3c8bdc0eb2c61a3b2b307391201216936f89af51308b7ebf69445d6702af3cfdc7709c3e74709f902ec22f4ccdb76608912fdc61ac1fae87e3b2bda2be401850036f43ffa306ba4ac4a049891edbdb2b1ff7e2402e21f845039b283e10d8a7bd4405055ecbc756b43cf816a287c677228757cf1d275b193f4f956efc7d3ae4ecc8570381298038bb4271b2baa13a0323c3fba961a15c324ae51a4a03af0bc274b8778a8a01f2f32805da20b5fe7c93fb6497843dcf9b05a59df4c054530a2de250ed0ccf6d343d75c4a7b912e779c87b815e17eb91b5e2fe699a32f09fabfaf9f0fb959fe38d63245eef225bca09e94d8c561ed61a00a5d3899207feb59be9b9861dde9f324e0ce6f347f0ae40ab04fdc4581f7a46254791b341fd7ef565616f7340dc6fe4da1e4e6bcab3016804535bd4b5a24f4bebc59f322b5010f7ee12784928385794249d1bc0fd361de74092108a7538c5308ef6dddaeb9c122c655ed452abdc37532d23c4a19a9ed7b40a00ad6b68b3b4675c2b22b9a63f9c0fe542a79988a29223bf6b6f7983dc470fedf9ffa82a1035c43d3d45a38b266ba21a7cc5356e7599dfa1872bd4623105393eacb375507c7a6cf8190658edc380fb6c3b7f87b0af1d5899a197fef9cd9e8262698a3f263a0f12996792830745f382c83bfcb8cae865d0aeb7d3b99d10b2e6d9ff38b0f5beeec94219ec8d055bf4764571803e631dbe63af2922b8ad41c1dc3db7ad9ff05cd41eccb6a9e635961873148cd19a5055a801b3350196391588b8f05747b0227161eea648c9df941cfda5136b91762769967244345f583f2a6d089ed3613fe4883b09dbaa55f6d52071c1dc7e7556e6c3ff3691c3586c6c7e9bf1555c8a80e58c1579d2383d6118537ce81b43f29159ae833018de065de2f8402c07100926a2fdc4416d37ab3ec2313e5e7f9eb4abb0bd37aa730776f908c8a18a202b27a885bc09eedff3a85e15d72daf226e953add740085f2c6ec44af92519aff97eb4e66ade1f682460531b321f92337380f0204b034adf46dbf12752a72d04fd9c8ca58507ef950b1e68b4c758ef1f979bf55802630d8edc518425cf46d953dade219a78f40cbaa19ba0df5acf4b5961a06107b465a6ca4cf454606ac6cdff51ebc056778132cdf2f0445126e33fa2ee72c2f4336d136d4705d4cb19650e5e1942be94b90ba974b1fa7b500581acbd7d476b79bb96ece1342aa1d8d075108b24b3bc141364f86cb3baf37cd181ec6b2eb54be631a361750f8148a963e45bd43a7dcafae0103c478a3e86d98775c63b176846b942bf0db9abb4d7ea6808f6d5ad923ed591de21c39a19206aa280e357fec4ab64ebe7c055bc577170248b52b0578647c045ce58513df901cd1085a8c3bc851f6ec76fb6fe28089aeecfaea838980aaf00a886353c045cb10dcf579916a3e86646a35908e1b37be30ab1cbf0c5a2e94e871924639fcefad6a2c8929ad71083febe7eba949955c2b2c751c451f956ed435781df535131a0eafe16ec60592dc7810df9684c864a15626f5acd8f5983dd0bbddba421ca5511e1bb984fbc3fc2da9a066b605e1905e07f179537c40710b49ec7ba42f495d96b91089ad6ea70c34d46e963ba3eb6d15ddc36a2b675187b297f91167ebd44d9b35957eef980df5bc3c4ffbdc653bfb7ab82f3e6abeef5c01b8805f171b38624dd146c6c9f9960890d57fc775d5a951f2f9801ac0f8562228c579c84f5ed40f98bcd86f07a7dd9a6e5043fd638d440eb7694980fced8fe5299422118f7981053819ca2ae07945a80dc8cfce20ae32c33a5c1053c90d0e866f412d0c4d5a5de36cee7a31ebd92fdc5fba12a7efa01df93bd1c123c8f4eb0cc6aaeee86126b5c99e3cec6b021faa30f00d18b690f42ecc10c26b8fc330fb0b7b67a7b5592b60a403b00575526c59ef599e9e42b6238a4ba392ed89dddfb208fe6c0b8f10c89d56ad7e31dd361ac229b4405f3e55f77c6211b4069c3370dd1afe3c22e1565a2a9d45333af388d98073e5ab3b0c0e533cce2d4841445366ebfdc6fdefe8da422ceda4540fe87773309c73b6c718c6a98c7bd4c0246c560805489c8000c7a8f9ac548ce73921f4cf7e5fba8bf2969eb8b78f644995b77c5baecb03d527e9a5ca122c275e810be90104b0ebf2c3e2a1907412aced7c828cee0e5bd00a589d42b556ec97b5e0889f67cfb6a197ae64c6f15d25044735f63175647e4eeb693ec395169ce9ed76b01e10248a4ca3b835274f26bc72d84a5e5e54769888323588e7aed80c80cbd0d9f5bcf21b2ad80091f8c369948c4cec771b298bb24e9330b1ce4b61fa2718e528aedd4e95b04bea9141426cf8f225795be1175a6ba6ca94409664fc3aa10ecb37fd9ab7668d671a74f029c3180502f932233c4cf623b9c410774b64472b329cf2760f4d251ac1a8dde740b79231e299b122a5ce601de5c8327cc9389caf7e40837fbdacfb942a78826465c3bb3f951858d5499945a79b01b6a2114f0ab6caaf6d47c912cf07f35e489125f18eafd15398e08c42a6c6cd4d0b416397f4f81bcdd2a2f95600dfcc19138477930ebe63f6b3a6838859d8196c62cab8f3daffa58455b2c1fe9c8ec21d17b1035d54460a69609a639b2ec7921634ae02fac224a3418c99c0198631c0ee1d720692e58f308a3221a670a352b5da8b925f199134b08ad5d9a5f5416ffdad36819607ab1b79c40565f1f200cdb410d4f29ef893fff76058b99a570acc75196061df7767a9ac37c259ed79a3578bf93c96fd0aebde7765a23e25e1a9e2b1f9081294844c624a19ab58c3e833c86235cf81589472d40ec2e55692aee9b93d004d3563649d9c4d459f8fda0380539dde501d9de22a89b85583644659b05c5d2d32b7211dd0e6fa75881d301dffcebb4a2778e4c9dd2b802c7413db3489d7371c98f24b7f9dccd4e2565f0514a520bb333f8b2ac35babd78c3acf21fdcab41752f635b541da7ae8e428a64b3b6c7d4d6fb387dc63d96b2c1384abf9ee51908a15bf5443dd3a9ca35f861a7f080f52c2821aeaa1ba2695f4c71d98fbe223071ea632d826fc38de12dfef779767f1e28a202455b076fd7e2807609afa30cd09616e76f96b0e2970ef2d28190ef5bf0bf0390b98217719a322fd63496f9515fb6bb4a0abd2cc49deb9e97ef3fdd895ce74d5256f4bac8a977d70defbd6bb103d43c585a7a5694eed49e6436d89d4decb6480a8a37b3bc2964ef9b9c40870d371670c0b66d4967b2b1ec7fde4369bab3f058932e28f004500b831d46e3026e967c93090bf17473457231a1dd143c37b633ae024d995ad1ea8868b98e27f5ddc3637f1be2d14cf1481a26010bbe0cdbb0c9fe37a551e89476b791061e8b2290e8129e59064e24e142ed0d31dd5c8f4e5187b60e7093dbde338ed1466cd2165c76ca0118b02949893d9a7372350127cb6c072bc4fd26b02282cfa459aba4b4675441b1b1d224bbd31edddc8a41542af9cc1ff79a91fd7a0a444d0f86782aae4cc9dd06ddbb3d4a987f4465ada89ec740c9c31f39620e4dd49740a0046909f956c4bf2aa378a84b558a44484d8bd7d6d1b7100ad6bf7d11a8d675eb16fc3b4332ca7a48d179621fb8c2c7829b3e8dc4091b789a8c872c2fc9a759fdcf79b4f3599447ee342b76689c132c562714e2f2aa46dea2ddc314a79b1a3e09cce051194257b8baba9081a89bfb621eae66e5cddf604d79fb00e050a56e7e853edd31e00eb92ca587b8f54e4ecd6f1c875f5c4a73f47a14bfc4a0ebfb98c24a30cdce5b5283f4cee4ad8161e9b9703a5293fa9fa94e66c7251a6070fbd8c54648148624dd93ac8a4d41cc7b0960c8b004825baec6bbb84b4c6fde5cc98104ea7ed4a31020c57c2e966fb585b0ed06c163377c2ebf20235571e524ff5fb783b009ab76f065db314473bf23ced47dba5cae8c9bfeff54cb0eaf89ab979adb9b0bed4bd6c29750eb5fcf80b1b5e4f11505622352f7fb500a3016e8da96d8188d86e822db1b990b73bbb350a318d8cae00e8c07e03c3d721c48805dd61a1405f60f9ccab77a668d59c0966938fd068eb8b03ada7976c5d37e5e7392b355b3ed049e652b457970653b284766e71b3e6b941e732f63996210d02b1b1bd1642c9113e038ae984ae79e1fff9c0df6d17a84ef908a7aa7bfa9318589eac54712216a93f4ed9ea8727545ffb2ac7c73acc570185cc67de8b911f3e43c570af33d2e1fed3f7438b7dbf7e4e6b3816386cc459d6b23205a09cc79440af74ff6a255b4b7769c0573a0a17e74d246eff13292d20996d054d57c0fbfabdf20adbb7c4c452752f65635ca308c59c099ad45cba3863856b7b659caa1db4dda414749b6b4c30d9204ae4e5bb1d683d9228315dfa59c96abc67adc95fedfb1f19d60bedd61f6e945ebf04395ec112128659154c17ed79f01a84b6f42057214bea79ebd9414f9fba374f6c86ad48083f76cba183318850e344a27346172dd84f45f5ba9158dd91789590a71eafc32191e3249879284592f003455718eec24172d2888af577f1d462dd2b433c54b636403c66c2482c283f7ba6f251d67de979b99592839e38efa31ade559a726693580539a64b13c6fc0d4d17c72d43477cd88e7699c4172210fa59efc166e72140ebdfb2d5eac8195e09d3a2a8d3e206d1be71e71c8bff295471b1ad6278f2cf820dbc1164ce1ef57e221037e195991cd17efee9d11fa74c0b09b7d00a2940f25d9c734a286d4b8a3fa8f0b3a395477963683cfe91069948b0cebe3a643fb24735403f8058ff08337f33edf7708c0307b610f9120823daef8e9346fd7a8360e34347f9f8f0d3cba923e49a7b6c076b1d00f57125bfd5578d1b179b0b3768f69d779e02881f690f20edf09c45d20443f575fccb3e0587e1eb50b4673098b50affd40413abf2971536a045485538512dfaed50cd796e0d6435a1438f4c7938860a2016aa481415bdd1d35b86c2a22c17ac84d2d8a2972a14c0d857ef6581b70d892f913ae55defa17330d0d513379fe13a87a39b07ce8d30da23425b9bc2eb41d85e81e31e7ae94efdb1ca7912afbe2a793aed5dbbfbc8543aa8f014be0d4632f74f551100839fae0e467a338965a6f7ca2f687c22a61506f24db9f693e0bcb117059b06bc5f79bcfd6bb062cbf7700f6f59cd2d1d369401492051c8bf02cd0eb1037ff00272fc5ca61e44cced304a5f98e87408e50cdbd39c7341025a3ddda68c8ff04ac728a0d8262e953a22cba52b88f9af645cef02a46bc6912599cd32e919a37492e051600fdad80fcbf0a3f9f22f5b37761e9991791a6c9bdc3aa98daa360f33478f83d80e86fbbeb8d40008b191843220f9f5406dee5517b3b195e52f1c7f160042abc54b0e44c8d1160697908ffb829132806dde40d7b207b28bf62708a15b0fac51f78fc8a979f7f4a8894b3a7ff75d726527d6459409697ff3de2c5a5d4784cc7b3077c86ca6c4763f367c33f910a2629a7bddd09d956e2e158506b1ba680b68bf74bee7d30c953d93e96ab6373b45c99eacea239424d4faf3390db1486d99d5e9405c7ea1af050fc3a5683d91f7e9ecdf48cfbe083b46ec6c45e337daa7c06f3888d4369025931cd1829c79e40b3fa6b0c9bb79ed853b9f679a73e138d6fe64620790cdc5f1f68c545f34ad14bc66d75ef85f5e2f03b6a32f25698a6cb1ed74fb2d875372c93c794921b7193c8753b4e4ae31b220090d3cbaf76a6da2099d7b21b50aca4825df9795df3f8c661d40f7152acd6ad22d151a018aea5b84392f4df62e6dec2f96103dc6af28f552d3227f92d100f39b7ad3cb950b10840e19166cfac347b69d49abc34e2cba439f1fbdd768159f28574ab0f33e8751a265a928e7ed9db2c053900222c7704bb7bfa07ff34641f6e62a9f95825b3c1c721853c5d16e4fc5e4e13f7832b4c71a637076e28b2ac9b8ecda464fb1791e337253eb7e63def482d86f8e80fe9001ef15cfb3ea09e0ef6f7d7480aa87f5f47b777471e8dba8a88876ad295abdb24a3bd24220c7df53f8a72231b240c66b5a6c510586b47b93c2223059f38cc6fc7f4debfc316e6275a4f5d7cd8fbe024458eb2ac7bf2adae7aa303c52dc14783b64782b75586ff4165cae47f513053920b16d5629d0c80d2decce8ed8ea5c214ed5fc914f0457f0e69362ff720161fac3e9c494387b74f99a99cfac73be2c5216911f39c37702ef5979fd1d57b101fb08ff9d69c12ce5bceff810c8425f4560b95d304904ee59a3a73ff06d82a900d1eb92f41d01712a3a2d4b69c069729d350857fd8d2591a23760429698fa6ac726cc6c7f2b0faddab15c0cc7a392ba70c241d9c6e620dd3a7c1ad21cf743e2cb3d63ee708655e57b2b42bbf8b38a0aa926148995c8090f83d1ec7c6bf617a93aa306ac12cd06cd10f69d499b570cdd7d226c66d160e80baeba6207cf621b95886e7d38ee3ab3b0608658ea7ca79f2138d584c504d5a6dbea25345d86e0278282e2974e6571e954ac4a189ad302dc0a296b952a6632c78b90dc04be4fbd24de01cc3676aa94d6262a6886441284b924774d3c60bd2a6abc9fea39061081345e1586786e5bc8201fdfd0e9b5027cdaddd4d2c1752d0d01cf8bf545da40b965c4e4b9230068a1e39f7ef526f72315b4618ab5101127a8c8266e406eb68dbaf0f62d73cba6b0b355118cd61cc0a55c94c07c8d0c3c75bd34180f3f37f570d506a37137688cb534d1ec286f0451fed277b47016cd8e706e96ab353b3db0acebe7f948685757d29cedca298eba5a48673b97b534f4e532f173b72fb84d79b2c82649da71b27baa9342c9a6d073e31324a0ca315e2a12e32d67fdbc39b3d38f2fe12ea2ee2cb49fbc558683e20bea0f9624c13a194847b787d4417df9a343ed2e0da33355e972156d67037395bb17623970e1294a3640fec2da63eac20725bd4940c170d99ef799d499d5cf1ee0389e7563d166eb2e97103a3f52c0a2b5cc6be87f500d7434c53783efb0760a6acec89b8dec537af62bf4c3aa81739e289c131be23f6f05f86086d0f24585f193cf244f9b14cff287ba8892101fdf15a6be0092a121598803d4b2606d73a6f0743bb41cd148e97f9da4b9a04959ccfc9efb216e6822a631c27c8632149312d435903e430e33a7d372d6898ceded4a15073e4f4fbd559bb53499d2078fed42273cd9eb04f3ff4591e3a25add2d7245ab723c3d8247ef074076e23263336e1eccbae182fc9f3657b2205dcfd5d58a550a00824b71e0a6294cb699f6b5635f656aec23f49dda930e1ebe43c76d75418b68afe7226cfc3221a5ade4938e7488627117d5b4c86d23ff5e81f5b78a4479d4c302dcf009cd57bb224321f22b8d0215610cc4528f4b9403277f4cd2511faefffd8317a99ab2f58f9dcd20704afaacb1fb2a41c382e46ab8ea65edca5b58b63cea8a0d20681b113bef306e52347aba42dfc7cf3cd844467e34c8755c1f3cdaeeb10472ffa0afc6c2c5d018f5fd8b22878132bf1febf470de0a9ffc42e24553c72153cbb6dbf1b232f51e384d6c70adbea31f727fd00b62da54b3c6a20fafaac28f648987bdd81ded18a47a7e9e86e2b6cbaeede543545a2a7dd7b96c10e77632ffc8c871b9791f3f48a8d22f5a9e057942525f07fe74965b1e4e36b091b9f7828df4c66735823f18e9c72b651b53507d4afc9ea921a5c5760926e6389f546a0f709a64219155fbbf150f7a53d592d755cae1f510f271003455b41d547f247bd2cac0f5e6e4a345180f6c3088e939ce05da85de1636908629211e90d975dd47115022c00e34ab3b20885025f4cb31270665ccb2fd390c25c4bb722e09d77c3d2f4cd3949a5ce3e519741114e12cb7ac6807aea7d71722539f44f5ba9cb826880071d5240c188d3ccbaad0b03ac0cba2cd173ae9a6ff309ff99add4ecd8d438c03f675788d7d6fc565577bce71f767fcd65953b6e35642375ffdc10dccec61e3aafd449817577a3acf6b1313b06bc1e575c220f583ece774b39300d07581926a80e0a6273e7a2f1c2847ef4296100b00c18bdfbbc95a73354c58ba24aa974a3adbe634adf49a9f5bb7380992e2372193353de518ea32ba4ddefd7b88071b6359ffb742948ffaad1a1fa047e21f49824920bbaa8400a53dfc4962dfa5281de6af689063772dad9881ada4459b37e856524cc72ed1102ad345703eabe6744d2eff41a0d5d61c4c8ecd0eabcb8c7766ed6b0f47d27678f31d9e0200404278d3c24d0d59cad17ff575b5b74f7b7a650d490a58592781e5097279123e60d984061c57beb185c8c4a26252240bbb94ae14496737e03f25d34b59ad8d1d603a438fd4bc8d6c73c6b9b74876160ab126575af489cf95f69c45696eb5c159a4fc0ce40ced4b6f5b31c4629b1b17cb6ea537840a7fb1f9cad831d25c2713081ef6d0f58403d3f9a0b887be570e187e343a363ee4c701ae8aeee7870906cab9d272dd7e72714c4a82203483db5c554598bfd9a19a0a8b5b00e394651155a399ecb1472a7976260a403df8668d1bfb7adaf98ee6f8f990d6f6aae468689ee7038409eea3b34d9c1febc6b9cc57fdb7906ceff9ff0324939727bb8dde33606eb8a6f6d06cc433e6211341be72619ac8d401ee20906dbe0f4fb30ab788a93865d79927bf6fc7843730adde2ab38d9850d966eef087e7cb4cf3e990d7ef53bf79093c18e46fb20b92299eca65bd667f08cef83037e6e08d3bc4b54124223a98a68a3ea9858f4a875270d2fcefab8176de2c37dc1284affc6ece0393a9b5519c457c8e0932d68ccc90e15d070bcda569b895a9800d760b8c684784eb185d6f998a4c6d638c20b6e2cf7e373e0c9e597d225d9389bc769aba9f508673738c5e21da19473ee49032969ed9c179c35d7853df0b8630ff772a73dbae5e313c62ea79d4ea4b7272346e30dc52d28cfd826275d315a5f2ccac348fa329dc01b5af4311c17d99be2ed1d58dc9f23cd8ffc82c74e254374be30c6bb34f4450c598333c0c78dbc791916d75723819b06ba4b2123ce4cce6f87de4d1c3608fdf53efa50739a77d9f907c08f270024f23def5f98bbaba64cfcfdd4f5b8f120039749e03feabd880217497f3e215e7fc2ca530e9e848dfbe97c6beb3d8c03ebde0ab11de89a382529d0aad85bbb905b55dd7e737307af6f27a4e6c0da453450ea2f9046bd0ac1e4f9e896a324a5531d299099b862b2a3c3f756e0bcd363787068a1564969ee6e419cbc4ac0bcaf207d257988c274828684e45a2292bbb46c9543f80a1131a3f4019dbe220894069b9233bfacf2c7d475f6c4f17aa0304e49595c513b9193e430535d455e6e64d8bf710485b9f7c182415de5df1baee560ea01dde4025a0aa4f2331c6f6f3bcb1a78687d3d47eb43b0cfb8163545263ae41a300eaaf135641cfad13d5f41e53d8b391c278f1e2ac8735aab32ca6051e0ecb943c214f5c438e02e4b50ff8ee2bd59bc9e99e836658d49743f67b7019df162c9ed85e7fe888256b02b303dbc0e6da0cc1c90f2b9064e83809e9609fe759ba579cd1279573385b5c73dae9459b0ceabcb86dc6ec43f11f03e0098ac060d1dc2418789eb6f4d94a00eb494189a5c6f9a296d317317d1ccbb0fe7d70b2d803b82bb264aaf383abd4ca59aabe44502264004bb107eaf3486ecd214e01ffb75e202603a5b7f0bb1cc3c8c4edf2a1bc2c086e13c7afe62967c95d971d7b0253aae037b7edf34fcd481bd2a58defa6ddf624792f521d98792d57965a0d3af7b4378297274974d0fbd408b5a8d0b0dddb3b3f2513df3ac963968e6d7a65505832ab9fa3da3dffc8c83e83763a0f1b57321f6379eecc1dc2720099e28759de252b478cd755ffeb97fd4ce3bcdda2b7b7f48e65847598dc3b00cf300baf9dcd9c8952b8ac274316e6ac4688f3b06bd1d77f58372ebd6f26d33ffdcdc12704c86e2c9747c93c74c2f1ba3a5cbbb2658ed4c55e4de6986b63a05e5b34f59eb358b57a04c810a50f129f3493ba63d508d5f6f4220a4a255a56cec5b2281616d4636bd3fc3eb0aeb0bc1a21cf72b466c4c6c02f52365b9866bfd4bcdde8f528a5fddb69d2040e7a4021c6cf76d4ae73820986829f08b6bc4611deaea7611a33c6afa898c3836f0b089ea7a88c4f4e24b9c82ab65437a9c116c15200bdb9c8688d664a0c10a95bcf5383365cf6c2d5c3531b8d2c49b16aa943da8e3aa5f945d0d811177b26c889a632b82c681bbe77f6f818a88cb41b3d79906434a6cefcfad72b0652c3f9677f18a7058e9bd7fb0ccc3e1079da1f0c3bce8917171320f033879f63d260578c98e36c85cc9b303fa1f22a4614b6cec2205c21da804a8ad387c966736b350fe0781d9b193fb5804edf61ec9bed38cee01abbf5707cca62af629655f957af01ab201112aa979c068085cdd3dfe92647544b9831370722bb516037372cabecb1a7b257d812a3b43f1930fa23215f616424f83eec9495b811a2e4703dce87c2e3e61fc85db027c95c0df564acc0fe87eda7b119f65f959277e7cc4a523335707279533ef663227625a85f173abf71e4bb4482a2dd2e2a61200784988fc8dfbb1b52fb1e2131419a00a1ae3e43b0aba2e39748374e5de8c7413984e4d9569cdc0f4fd3fca6fc1827c176e54e37edbf93d838bb530ad3ce0a2410362e77ebf9a1c983e071d0c53a1355c55079d863d3e922b2d1d595dafcc557ba9cd6fb9c60ea451ae7ed8b7c85fc01cc06edebdabf8233c2a7bab46a978c40da2a04c6e53c23847f07a25e9024186e324edad6e783493b4e3616e838a207365abcb2653608616d9ee98be302305e6b29ccd254b3adb0238b75828becb0bdc426dce3dd6e9f1fab5dc87c9a333b9413cbe4d5a883ba25cc2bca2efae90335d26e25b4806e697c136ff464ec755e77ada5640776080464e3cb550123026da568343e17f95470d183a9e250f1b9e89ff2e4432a00a22a191a74edcf208de88aadca46f850335cca58e9201c0e7ba9a5910168ea1387386b1aa6130806c1bcc93cb9d212baf30db129903eb7c230061d6c88b781fd715f01714db4ac6324ee45065a4b1383d2d00fc925996c3faa773185aa2a15538d4e3dc8847b4ec41dc1840357e1b5b6bbef12708d8199118c99e1d3ba45fc6cf4d72eac29814aeba9d6dcb6d58d4f7f468433a7aa9c2c3c3b1b734c5c6fdacab146b3ae0ff31bf7437f7ddf1fbf3ef7ce3b88d78045b67317b8c51a1df5c96fb4d2116586fa824d4b0a220aa963329da649331e95836102d377a2366fdef71362354d715abfe182a5da924150da726002d4311c6309c80f860af662ae0b93070ff6d156a77bbbe8da7cad9ea23a2791c5be0c61e492e829a81aadfe98b9ecce4c4057e4817ffaab6b0b0f718bb5ef84bb4eb884a0c1fd9c89d9afc528d6acc7614d3b8d0931081fa2c973233637f8a313adc46bfaf68f18f6e0fb76a52793f8b06aa985950bc6f9cf51c7d6bc5bea58c9e6e527f08d038ccbaf2d6c1305c314cbdd11ec713e49143ec11c835d28efa3bf6bb5a92510271e35d8818177c3bd398c7d686ac6dbcc3269f83278b053ad9bc415ea1b83d9dff25d216155896c073ca5961150cdba875fe347128668733eb3518b87f2d9b03ca3f4857ff4334283b29abb96ebb4461ba8e5ee0d7b8b82e10460dad2f18c247c37bfaa2ff25913633c3268195d28609ab72b775ffec68920e9757b24e9f34a2a77ed9f685215a9b13673807da78187ce98e1e7280e7a50e38b08c128ddc4004a6948d0bce3e1b09e170e123fb8dc908a6266d7af11dda8fc4fc201d6eb608c69466b07f77fb08d1d5fdc6bb59de47259cb108a6e566378c4501eb1dddee75eead9dc271423e2722e60186ce898ee1352d4fb85c780a8c5f6d58e8ba1d3c637f22254b7bb1f23bd05d185907defb817a941e13b04e3554b7e87dbc055d17a8eaa583a96e996df5b9981d7e4f26203c4b14af8aae69e6213ce8d9108f45ec7e2f42cd12b9bdc44bc2727909dc54efb9cfb1f99f3fee3d11412ce6eaf945d748cf5583a14d5440104cf96040a176a919f9e55742075857c4413054edcb2d8235d5b35bec01c76ebae788cbbb5ea2840a420106a005d955df47f6d125a4355b8bb6d88da6e611beaf47ad339732908e8afcfe1300d211331e23f00c61f572557943d167382e97bf622423d3c97143eac450ef2dfec7dd84f9d85b09149c4198d175bd1282bbf1900662da126a54520fe33878deb1f4ab3b88fafebb57c10bd9f23660e40c21a330c620568b2397c51142a22a92f70981dedac819f83ea63963884777e6745498751f9c63c94eb7e6e819e2d0ea4f23f7bf510bed78848754691652972c9818e76aa6bbc7defb01232fb0aebaa4c5e500e7b7f8b50fe0f502f01d896d457b5d67dafc85187267714fb89ab269a7b1641bb42f427eb186c4867f16651c0adfa53d6480667ddffd69b225983ab267f76e6125bf845eaf20d4d4ef445e822aedda1f87a80737f1422f6ccd1c2021580f6c164dc716adcc95f547de9e8f2daa151cfd9067016928e7169bf163b8bd3c127598e40c1c7fccfccd5f274d5581618e70d41a6b4a8e3e64d55afa5449b2bb84f806172a53e693afeabd4b26a6e9e06b2d01827229ecd1e9f701cba47451f9096b51fbeb8a8b463bd555c2351a088ca0236353efe59815a0f565834dc530a67e6a71394498cc4f19099b8dee65acbc9ec67d5c6a366a89d902804efe0a63a64c64774b9f4526a8d36b752a4620b0e98c072a5acea2825a22c194247f47856afd6f75d006aec968b8c9b0174b46c78f8c532b0eb125e445c7fed62ba9f8c4a9ee3c7f048744a94fc0ed31dfc0398228622e1a4096bb12d2d99a14bcaf3fde62c82c7a32ec676a23f6f5553e7f0065b15f275da0f4226ce8140e0037de5eb859309658296081905bdb62f6064fccf0780fdfabc19f48e756090587358bdf822bfbc7e8feda0a8bea267975c9351c1bd7900dbe7b1e94aa8a5058952d3ea6f560b27d16d67b32057033b18d024f5854cc05cd3ee1080afc7139c81a416489a2b528e2e7d7d56474bfe85ad0418c8944cf1f4b8fd07bb842fbb3d52c770b27b932a5d685da8030058a3a3eba2b4528abe942d721aec352f9e19bef29b45732393c8352239f4cccf749b07970d96f377cce76350f0deeb1aceafb4793e0a5cffb15030b674ce4589b0230131a537106cc0467370ddd10e5f2a1460fbb4a67734f0ce9cbdbaa8ea7d55d7d6f663aa83cac11face4c98375a4d7f252afc4b553770377ad151688ddc0b65a20d3383a96835912ff8a88f40ee736eea3461548befcf189b2d8ba7414fe280f7eb02e3f6c16ab92746dc5db9d0920faf08d13d3682e173b6366af04c2f183fadc46df51035714a9db501045506b4288908e85f6abd3c9a5b85b990b66967384d40fd5b1e84010ebeffbc38b8ff908df470ea507713ae6772a7af270190b2d87a1e0042f80c2e2a10d8feaeb89154debf99d517ce3b01a2e95f2176fafa2bf47d2132d48b9aa7705e11a459728c56960a248410efbe68481f48dc4abb398461c9b4eee8453add769c8af46e4048e4688db0655ecc11622f5cb34f59d843a168e5196df9799f0fd92d57e422e78859eff1c35fef9c19641905f12bb5296c9dc653aa5eca6e8a43fde303bcd0f264208381e8127d58c5056c49053daaabf33aebf6791a8777b46b1fc3c9ac56908f508abfbcb2f46c96a129c61bd0d3de627e19a9c64ff69ae59214b94150ad9affb873722e406aa88c3a3c462702564f62efd477d025a33fe020493cf2d242dca7bd735e2679dee84a1a7f3fcc7ada09646d64d01c221b339d313b1e3df22fdeaab44fa47a4a8d74710243855fc15dfae66e581bd15f6d7eba66bb194ff299726e8019ab99a2a9c3bc3ccb28df789d52c0a176a9e5d90d03be1fb5eebfa2383b451c112e2a1a7e07fa88f1260838487055afa46b2e89f3ce583ca82284c32d3e7527b9c332e0e28229c857f57efeba1b5f89b77820bf99d405cd2ae4651c46e7eb984f07f3c2fa381a86f4527cd39f1873425ff220612f37a2ccefedc78c45dcdddbb81fee4ed5c413b9d546b5d1a752cfb4538c49176e593915ea46b3b5907e624914acea5e9211758717f89ea38fb0cce3ca071011f774c49ff51f4a67b2c96ba102d67db289bc4dd594b3020b96350c954ac23996370ba6246ed10d6413fd1d2c4edf3ca293a98a7583493d1e2da323cd1f2df5b1dfc354bf61ddc15ff0d806d8d0031cede75e005c4dfe5b217f711fd57d8d94d4a66fdc0e443f05846b4548df4f17c2cb84959509a20000c0b782340840ab60cb2fb2ffa3d149984d45a986d272061c06d99bca149c0cc05f5a78150f6150703d3cfb1fbd540a5055f939fad2a1849fa09cb511b44818e32db4d1dd45c5a66eb53a13c2dc0533f6ec5fe365e0b549317cb6a6911572849aa3aec070a2aabced3fc1330bfa41f013cdb11cbf9cd4828fa2f302db6e07e874c805162dfe76012cc6e995b3a7e72d8534b0806e4c1de50974a7f43744d0c337b4b4363e254e7783e60df1f9e8934b2a44e75cb027b916fd858be56fc07b1b2f552dbeb179cd424fd7a6039fd4de3bf4675939f76585da93b4832caaf4876c4029f5e3050bfe51c21ee548ca54c7b6a7360c689e7c061203c92e5411393b649ac5ecf52e903f96c390f6af589c2d041bbe94e73052f2a14548760a18c364662b72dc1a0e0d38c581c245c53cc47559513bf52b203e84fd2067c79a2237e38656b70f49f25c3186d07315415bffbaf308844f0c08c6cfe47ff144e4101ed3991b3e7044a326fe551bfbc55f52e7f5a3d8154d22900cba197aea284336b6c295b9f165003931a1f0e6b264ca016bf146f04ca988e6a29db39d82d20e404de480141b8efc2656e8a95da8b4f6d5a194a7dc86286b5f70ea79b755ecc854d1c1ec7ab796f1dbb33d76bc4bf5f24736eb1e7d5a3d9517d333f61c3b2f97d267ce825782793c11c298c4e61af1b33820aec4cc7c21f752fe7445dd749c3dac4aca6a6285401199a074586cda4175249acf69ff69664089749c96de3adf9051d66e0d8e27b89cd5364624f32bca4f5e5c9fe01c113e8a9670375cd28fa8bd7632b988ce0bad2fa789b48cb35156f9e8bec217a8bd82a191d19eeb29ef11dcb17f81a30712d1ad3e6bf3a4af162c64a300274872110d64262d229e0f70858b68fad1b64e43e18c9178cd24d0dd48a0ab32cedec15bb251ad34efefa697de03f26a8bd2bf4c92f77e61905a9bf87d6c88c47586fc1d0ffccb75c8b8f503254360f177af001879cfa45a245880eaa5e07c67ee0a3505e5da9ad1ab77852ad5ad25acf6fdbe5c7215f92772f379ec661fbdda14e3bbcc4e80dfefdd7f37ad07fc9ca059f19737434a332ce037e221eacdfda8ded4283e0556ff95ef125783c5cc5d6eb513877a827979b08a88c93e4817459d07ed62a2a0756c2f8ee45b57f92b0e0eedee9de7791694038d76058deb1dcf7708edc1c2a354da05609ab60e9f77e805f4c0a2cf0ed475db007881e474818cf7242d442820d3ef5f952f0121bbc2b16b9d6711c118a945ad0f8eea6ea2a2eae664e15731dff2eb002131b76ec527b090dedc4aee6296d93fa10d6fc3884df58b069201856af2737d53e78abda65bc139f4373b441f7c1a376f1d63e2c342a24ef1cf15e2bb1d343fd6be6f24b7f5a4fafff683a136e6fd547817ec8e976f4d0700a58e30f8dafea4cdd68aa662f5ebd06eb65b30142ba2d0e80f4edcbec936c9dc4863c6f0cfb6524419aa9a7c3ff84c9a122b30ad94c17924759a424b1d7426e16fd339441f73b96a382bf487e2639dbdb85c76b4c915b62c09b69c400e070f1e0f9bbea0598b9f64d54786efc5b572b04c54880bbcbace1d750db3fe8318755128b3efc510ad294d81eeb9fc809343a7bfce7c9a768144f35be1318b341186798b88586ff591daf5554a5288ae4b2433b5a162e48309f3c1a29b5b1aa6bb99bdccf7520d279e1435327cf8c7faee3b1303ddfe306c8d10f81d98681cc83166a903dafac8fbff4ff6bf42090f6c6b271ee353cabb8b73594eee1f1e0c5d65294689f49b467b35819cc68fc272b0a3b89ebe15ff1940cffc5d5f707d8732f0963478ff9e835d7feefc57bba03d599ac389bfaf008d639d75a5bdb2bbe32759613e427257bded47cd95f072b1922c6aacd5a7fe5fc0bf8a9acd6a501b8b7c4f69ebeb36f66493136b7cacc8a47ff78d510d35d445d60f4363986006a3b9fe7f27aca31295230a637cdb9b2e9e45ca0879f577ec5feb79fd88abc0462e46360e6d2546181eb12e5c21422fed0f9c064d9d2d30c4323e9d5bb782aa422670ffa4799df9123339b7c06f59535dae9493558b4f8222dbcaa1129830d5b0b645c7034499cb6637707e095b2e1841c9d5fc31125aca22a749ccd42886fa28b3ccb4da91d93dce7045a709b48b79b503f12f6cc31286530ad145c24e108b7bc060b217a5cf48721dbb14ff18ba17f91e0eb3ce1b738d40f1e34d3f9a10a5d0cd272b2356d92bd54690e434f2b96eeff09a4acc8b641054808040e79b39d733c4f396cc4d939840f44fc46d5669b6d9cfea82504d1e95c0a004c9915380699c1f25451142d85c40bc541e339300b25aa7cd17908942bf88dbb43918d486819d5a98c195186c6d5ce123ec31639d03561be39046e2715699d071d2e37f1da8ac2d001bbdfd132ea4e24d7e58500529a05e3989ae556dc883d9305530d2e0ffdb493a9f2a7fb48e9fffce1f5e13e9f38a29d84dc015d87161d9dd35a941b8e13b9a7b330c45f93a108556f2d5fbdf408a4a9d2f91ccd8e4ee5fb90914a3125ed6ac79cd587b4c6895896d2df1b57cfa96077443d57a6ff6f7164189dff9b32b9c3494f609f21b426be84015490cb3f44e1cfcb50044d9ab1d9b4a15c3238faeeec0750de56a12a089058c74848d730a8b2b88505f018b2c0eaf87807fa7705764b223be5551faa70c3735c3217896fee444fd11ad71e48edbfdc2edfba02c65362753b9df8bc30db4224799b248ba39083966de3671207baa4a6c1e9b052fddfddcf6242ee6b18a35c030f55ca47179fa26ad2518fa360ae1baf82d07b9df9ce535f5fc6ff67c72100c44797e714866a57fc8aa20a1995e52a008e30aa4ad0603518f3858f592d86f2fb24c495925e154a780c71b9a3526abd0f90bb08e4a0b7d3368295b8458b2a3049a481e8e2951220915869ba3e049a6a6218382022cf76f545826696256c29a2601d238dc1c40448d32832b19a0bb1784b14683c4fe888a4472b5a0ab993c6436e95dfe477ba6253682cc9673ae503a99f7a28d670940136bcd398b3f1625ad65dfd60712e92ce59e6532414573c82072b6f9eafca1b0ef6a16376a9bbf3120d3e8196d60b60d9804a24c0cf2827cb29b8d5baf08392fa7865d112585ba9e02cc727b7e9276d6fa805d4e141b7ba281e1b862e68be6a1f1039ec1514c6a5cc43eb996578fc5adb10db792977a64768909eef6387380b4e86483c0c03258e3feb617ec3fbf880adad56340b22567afe0bbd55d7822b78cea1c65f6388a37f2e284cb15de452b1a26163d091a1f1aad0c146081f9d16c7282937dd6a56d25722c4555c0f0026115a259eff09db43ef401a89087421eddbc81615d3af6cb19a898814a370600bc716122608c1fdf47b637e7f111a605a80e1724a155a3e7e11b9eccc4bee39079a3cbdfab491c752fa9a9b4b36c8508cacb39419811b616025881bfbfafaa601d0bcfd1a2e593e36885b900e802372af825d25bc334eb65d8bac09198c0788e379651febfd825bebba944571f36c6dc996c87fbaa</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>乱想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
