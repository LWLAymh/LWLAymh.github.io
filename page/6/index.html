<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/6/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js" defer></script>





  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">平邑一中集训作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-30 14:59:17" itemprop="dateModified" datetime="2025-07-30T14:59:17+08:00">2025-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-30 14:42:58" itemprop="dateModified" datetime="2025-07-30T14:42:58+08:00">2025-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">多项式与生成函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-27 11:35:27" itemprop="dateModified" datetime="2025-11-27T11:35:27+08:00">2025-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2>
<h3><span id="复数相关">复数相关</span></h3>
<p>棣莫弗定理:<span class="math inline">\(( cos \theta + i \sin \theta
)^n = \cos ( n \theta ) + i \sin ( n \theta )\)</span>.</p>
<p>欧拉公式:<span class="math inline">\(e^{ i \pi } = - 1\)</span>.</p>
<p>也就是<span class="math inline">\(e^{ 2 i \pi } =
1\)</span>,同时又有<span class="math inline">\(e^{ i \theta } = cos
\theta + i · sin \theta\)</span>,证明直接使用泰勒展开.</p>
<p>单位根:对于<span class="math inline">\(x^n = 1\)</span>,我们会有<span class="math inline">\(n\)</span>个根,设第<span class="math inline">\(k\)</span>个根为<span class="math inline">\(\omega_n^k\)</span>.那么我们有:<span class="math inline">\(\omega_n^k = e^{ 2 \pi \frac{ k }{ n } i } = cos (
2 \pi \frac{ k }{ n } ) + i · sin ( 2 \pi \frac{ k }{ n }
)\)</span>.</p>
<p>单位根有以下性质:</p>
<ol type="1">
<li><p>折半引理:<span class="math inline">\(\omega_{ 2 n }^{ 2 k } =
\omega_n^k \\\)</span>,由我们上面推导的通项公式即可证明.</p></li>
<li><p>消去引理:<span class="math inline">\(\omega_n^{ k + \frac{ n }{ 2
} } = - \omega_n^k
\\\)</span>,同样使用通项，运用三角恒等变换可证明.</p></li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4>
<p>上复平面,设<span class="math inline">\(S_k = ( \cos \frac{ 2 k \pi }{
n } , \sin \frac{ 2 k \pi }{ n } )\)</span>,也就是<span class="math inline">\(z_k = \cos \frac{ 2 k \pi }{ n } + i \sin \frac{ 2
k \pi }{ n }\)</span>是方程<span class="math inline">\(z^n - 1 =
0\)</span>的复根.我们把这个方程写开:</p>
<p><span class="math display">\[
z^n - 1 = ( z - 1 ) ( z^{ n - 1 } + z^{ n - 2 } + \cdots + 1 ) = 0
\]</span></p>
<p>不难发现<span class="math inline">\(z = 1\)</span>是平凡解.</p>
<p>我们不妨定义<span class="math inline">\(f ( x ) = \prod_{ k = 1 }^n (
1 + X^k ) = \sum_{ k \geq 0 } a_k X^k\)</span>,事实上我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ n } \sum_{ j = 1 }^n f ( \omega_n^j ) &amp; = \frac{ 1 }{ n
} \sum_{ j = 1 }^n \sum_{ k \geq 0 } a_k \omega^{ kj }_n \\
&amp; = \frac{ 1 }{ n } \sum_{ k \geq 0 } a_k \sum_{ j = 1 }^n \omega_{
n }^{ kj } \\
&amp; = \sum_{ j \geq 0 } a_{ jn } + \frac{ 1 }{ n } \sum_{ k \geq 0 , n
\nmid k } a_k \frac{ 1 - \omega^{ nj }_n }{ 1 - \omega^{ k }_n }
\omega_{ n }^j \\
&amp; = \sum_{ j \geq 0 } a_{ jn }
\end{aligned}
\]</span></p>
<p>事实上,我们令<span class="math inline">\(d = \frac{ n }{ \gcd ( j , n
) }\)</span>,容易发现<span class="math inline">\(f ( \omega_n^j ) = (
\prod_{ k = 1 }^d ( 1 + \omega_n^{ kj } ) )^{ \frac{ n }{ d }
}\)</span>,又容易发现<span class="math inline">\(n | jd\)</span>.</p>
<p>接下来观察<span class="math inline">\(X^d - 1 = \prod_{ k = 1 }^d ( X
- \omega_{ n }^{ kj } )\)</span>,带入<span class="math inline">\(X = -
1\)</span>得到<span class="math inline">\(f ( \omega_n^j ) =
\begin{cases}2^{ \frac{ n }{ d } } &amp; d \in \text{ odd } \\ 0 &amp; d
\in \text{ even }\end{cases}\)</span>.</p>
<p>接下来考虑拿到<span class="math inline">\(\sum_{ j } a_{ jn
}\)</span>,只需求<span class="math inline">\(\frac{ 1 }{ n } \sum_{ j =
1 }^n f ( \omega_n^j ) = \frac{ 1 }{ n } \sum_{ d \in \text{ odd } ,
\gcd ( j , n ) = \frac{ n }{ d } } 2^{ \frac{ n }{ d } } = \frac{ 1 }{ n
} \sum_{ d \in \text{ odd } } \varphi ( d ) 2^{ \frac{ n }{ d }
}\)</span>.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5>
<p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现<span class="math inline">\(+ , - , \times , \div ,
\sqrt[2]{  }\)</span>五种操作.而对于正<span class="math inline">\(n\)</span>边形,显然只要我们能将<span class="math inline">\(\cos \frac{ 2 \pi }{ n
}\)</span>用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6>
<p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_1 &amp; = z_1 + z_4 \\
\sigma_2 &amp; = z_2 + z_3
\end{aligned}
\]</span></p>
<p>不难验证:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_1 + \sigma_2 &amp; = - 1 \\
\sigma_1 \sigma_2 &amp; = - 1
\end{aligned}
\]</span></p>
<p>可以求出复合条件的解,将<span class="math inline">\(z\)</span>带入又有:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_1 &amp; = 2 \cos \frac{ 2 \pi }{ 5 } \\
\sigma_2 &amp; = 2 \cos \frac{ 4 \pi }{ 5 }
\end{aligned}
\]</span></p>
<p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6>
<p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6>
<p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设<span class="math inline">\(n \in \mathrm{ prime
}\)</span>,我们用<span class="math inline">\(p\)</span>代替<span class="math inline">\(n\)</span>.</p>
<p>我们有<span class="math inline">\(z_1 = \cos \frac{ 2 \pi }{ p } + i
\sin \frac{ 2 \pi }{ p }\)</span>,由于其它的<span class="math inline">\(z\)</span>都可以表示成它的幂,因此我们记<span class="math inline">\(\varepsilon = z_1\)</span>.</p>
<p>我们现在想要这么分组:</p>
<p><span class="math display">\[
\sigma_{ k + 1 } = \sum_{ 1 \leq l \leq p - 1 , f ( l , k ) = 1 }
\varepsilon^l
\]</span></p>
<h3><span id="泰勒展开">泰勒展开</span></h3>
<p>即<span class="math inline">\(f ( x ) = g ( x ) = f ( x_0 ) + \sum_{
k \geq 1 } \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } ( x - x_0 )^k
\\\)</span>.<span class="math inline">\(x_0 =
0\)</span>的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="离散傅里叶变换">离散傅里叶变换</span></h2>
<p>考虑如何将一个交换群以一个函数(未必是同态)映射到复数,则这个东西天然对<span class="math inline">\(\mathbb{C}\)</span>形成线性空间且维度为<span class="math inline">\(|G|\)</span>.</p>
<p>结构定理首先给出<span class="math inline">\(G\cong
\mathbb{Z}_{n_1}\times \cdots\times
\mathbb{Z}_{n_k}\)</span>,考虑映射<span class="math inline">\(X_a(x)\)</span>,其固定一个<span class="math inline">\(a:(a_1,\cdots,a_k)\)</span>,而将一个<span class="math inline">\(x:(x_1,\cdots,x_k)\)</span>映射到<span class="math inline">\(\omega_{n_1}^{a_1x_1}\cdots
\omega_{n_k}^{a_kx_k}\)</span>.</p>
<p>现在考虑这个映射本身所组成的交换群<span class="math inline">\(\{X_a\}\)</span>,容易发现以下性质:</p>
<ol type="1">
<li><span class="math inline">\(X_aX_b=X_{a+b}\)</span>.</li>
<li><span class="math inline">\(\bar X_a=X_{-a}\)</span>.</li>
<li><span class="math inline">\(X_{a}(b)=X_{b}(a)\)</span>.</li>
<li><span class="math inline">\(\sum_x
X_a(x)=\begin{cases}|G|&amp;a=0\\0&amp;\text{otherwise}\end{cases}\)</span></li>
</ol>
<p>考虑在上面的复内积<span class="math inline">\(\langle
X_a,X_b\rangle=\sum_x X_a(x)\bar {X_b}(x)=\sum_x
X_{a-b}(x)\)</span>.根据(3),这显然是一组正交基.从而任何一个<span class="math inline">\(f:G\to \mathbb{C}\)</span>都可以写作<span class="math inline">\(\sum \hat f(b)X_b\)</span>的形式,而且<span class="math inline">\(\hat f(b)=\frac{1}{n}\langle
f,X_b\rangle\)</span>,容易见到这里<span class="math inline">\(\hat
f(b)\in \mathbb{C}\)</span>,从而其实<span class="math inline">\(\hat
f\)</span>也是一个<span class="math inline">\(G\to
\mathbb{C}\)</span>的函数.那如果拿它来做内积会怎么样呢?请看: <span class="math display">\[
\begin{aligned}
\sum_b \hat f(b)\bar{X}_a(b)&amp;=\sum_b\sum_x
\frac{1}{n}f(x)X_{-b}(x)X_{-a}(b)\\
&amp;=\sum_b\sum_x \frac{1}{n}f(x)X_{-b}(x)X_{-b}(a)\\
&amp;=\sum_b\sum_x \frac{1}{n}f(x)X_{-b}(a+x)\\
&amp;=\sum_x \frac{1}{n}f(x)\sum_bX_{-(a+x)}(b)\\
&amp;=f(-a)
\end{aligned}
\]</span> 接下来定义卷积<span class="math inline">\((f*g)(x)=\sum_{y}f(y)g(x-y)\)</span>.</p>
<p>还是应该再思考一下两者的地位,见到:</p>
<ol type="1">
<li><span class="math inline">\(n\Vert \hat f\Vert^2=\Vert
f\Vert^2\)</span>.</li>
<li><span class="math inline">\(\widehat{cf}=c\hat f\)</span>.</li>
<li><span class="math inline">\(\widehat{f+g}=\hat f+\hat
g\)</span></li>
<li><span class="math inline">\(\widehat{fg}=\hat f*\hat
g\)</span>.</li>
<li><span class="math inline">\(\widehat{f*g}=n\sdot \hat f\sdot \hat
g\)</span>.</li>
</ol>
<p>考虑(1),显然<span class="math inline">\(\Vert f\Vert^2=n\sum_x (\hat
f(x))^2\)</span>.</p>
<p>(2)(3)显然.</p>
<p>对于(4): <span class="math display">\[
\widehat{fg}(x)=\frac{1}{n}\langle fg,X_x\rangle
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>考虑Bool函数<span class="math inline">\(\{0,1\}^n\to
\{0,1\}\)</span>.为了使用我们上面的技术,我们将其写作<span class="math inline">\(\mathbb{Z}_2^n\to \{1,-1\}\)</span>.</p>
<h2><span id="多项式">多项式</span></h2>
<h3><span id="多项式基础">多项式基础</span></h3>
<h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4>
<p>代数基本定理:一个<span class="math inline">\(n -
1\)</span>次方程在复数域上有且只有<span class="math inline">\(n -
1\)</span>个根.</p>
<p>定理:一个<span class="math inline">\(n - 1\)</span>次多项式在<span class="math inline">\(n\)</span>个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个<span class="math inline">\(n - 1\)</span>次多项式<span class="math inline">\(A ( x )\)</span>和<span class="math inline">\(B (
x )\)</span>且有<span class="math inline">\(\forall i \in [ 0 , n - 1 ]
, A ( x_i ) = B ( x_i ) \\\)</span>.</p>
<p>令<span class="math inline">\(C ( x ) = A ( x ) - B ( x
)\)</span>,那么<span class="math inline">\(C ( x
)\)</span>至多是一个<span class="math inline">\(n -
1\)</span>次多项式且<span class="math inline">\(\forall i \in [ 0 , n -
1 ] , C ( x_i ) = 0 \\\)</span>,也就是<span class="math inline">\(C ( x
)\)</span>有<span class="math inline">\(n\)</span>个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:<span class="math inline">\(A ( x ) = \sum_{ i = 0 }^{ n -
1 } a_i x^i \\\)</span>.</p>
<p>点值表示法:<span class="math inline">\(y_i = \sum_{ j = 0 }^{ n - 1 }
a_j x_i^j \\\)</span>.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } y_i (
\prod_{ j = 0 \land j \ne i }^{ n - 1 } \frac{ x - x_j }{ x_i - x_j } )
\\\)</span>.显然当<span class="math inline">\(x =
x_i\)</span>时,该多项式的答案为<span class="math inline">\(y_i\)</span>.</p>
<p>另外,如果<span class="math inline">\(x_i =
i\)</span>,不难发现这个式子可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ i = 1 }^{ n } y_i ( \prod_{ j = 1 \land j \ne i }^{ n }
\frac{ x - x_j }{ x_i - x_j } ) \\
\\
= &amp; \sum_{ i = 1 }^n y_i ( \prod_{ j = 1 \land j \ne i }^n \cfrac{ x
- j }{ i - j } ) \\
= &amp; \sum_{ i = 1 }^n y_i ( - 1 )^{ n - i } ( \cfrac{ 1 }{ ( i - 1 )
! ( n - i ) ! } \prod_{ j = 1 , j \ne i }^{ n } ( x - j ) )
\end{aligned}
\]</span></p>
<h3><span id="多项式运算">多项式运算</span></h3>
<p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4>
<h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5>
<h6><span id="dft">DFT</span></h6>
<p>将<span class="math inline">\(n\)</span>次单位根(默认<span class="math inline">\(n\)</span>是二的整次幂,如果少了的话补零,设<span class="math inline">\(n = 2^w\)</span>)分别带入<span class="math inline">\(A ( x )\)</span>得到点值向量<span class="math inline">\(A ( \omega_n^k ) \\\)</span>.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
A ( x ) &amp; = \sum_{ i = 0 }^{ n - 1 } a_i x^i \\
&amp; = \sum_{ i = 2 k , k \in \mathbb{ N } }^{ n - 2 } a_i x^i + \sum_{
i = 2 k + 1 , k \in \mathbb{ N } }^{ n - 1 } a_i x^i \\
&amp; = \sum_{ i = 2 k , k \in \mathbb{ N } }^{ n - 2 } a_i x^{ 2 k } +
x \sum_{ i = 2 k + 1 , k \in \mathbb{ N } }^{ n - 1 } a_i x^{ 2 k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>令</p>
<p>A_2(x)=_{i=2k+1,k}<sup>{n-1}a_ix</sup>{k}\<span class="math inline">\(, 那
么\)</span>A(x)=A_1(x<sup>2)+xA_2(x</sup>2)\</p>
<p>接下来分类讨论:</p>
<p><span class="math inline">\(\forall 0 \leq k \leq \frac{ n }{ 2 } - 1
, k \in \mathbb{ N } \\\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^k ) &amp; = A_1 ( \omega_n^{ 2 k } ) + \omega_n^k A_2 (
\omega_n^{ 2 k } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据折半引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^k ) &amp; = A_1 ( \omega_{ \frac{ n }{ 2 } }^k ) +
\omega_n^k A_2 ( \omega^k_{ \frac{ n }{ 2 } } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们处理完了前半部分.</p>
<p><span class="math inline">\(\forall \frac{ n }{ 2 } \leq k + \frac{ n
}{ 2 } \leq n - 1 , k \in \mathbb{ N } \\\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^{ k + \frac{ n }{ 2 } } ) &amp; = A_1 ( \omega_n^{ 2 k + n
} ) + \omega_n^{ k + \frac{ n }{ 2 } } A_2 ( \omega_n^{ 2 k + n } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据消去引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^{ k + \frac{ n }{ 2 } } ) &amp; = A_1 ( \omega_{ \frac{ n
}{ 2 } }^k ) - \omega_n^k A_2 ( \omega_{ \frac{ n }{ 2 } }^k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>综上,我们可以递归处理<span class="math inline">\(A_1\)</span>和<span class="math inline">\(A_2\)</span>,然后合并得到<span class="math inline">\(A\)</span>的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6>
<p>设<span class="math inline">\(A ( \omega_n^k ) = d_k
\\\)</span>,构造多项式<span class="math inline">\(F ( x ) = \sum_{ i = 0
}^{ n - 1 } d_i x^i \\\)</span>.</p>
<p>我们求出<span class="math inline">\(F ( x
)\)</span>的点值表示,设<span class="math inline">\(c_k = F ( \omega_n^{
- k } ) \\\)</span>,也即:</p>
$$
<span class="math display">\[\begin{aligned}
c_k &amp; = \sum_{ i = 0 }^{ n - 1 } d_i ( \omega_n^{ - k } )^i \\
&amp; = \sum_{ i = 0 }^{ n - 1 } ( \sum_{ j = 0 }^{ n - 1 } a_j (
\omega_n^i )^j ) ( \omega_n^{ - k } )^i \\
&amp; = \sum_{ j = 0 }^{ n - 1 } a_j \sum_{ i = 0 }^{ n - 1 } (
\omega_n^i )^{ j - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>当<span class="math inline">\(j = k\)</span>时,显然<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } ( \omega_n^i )^{ j - k }
= n \\\)</span>.</p>
<p>否则根据等比数列求和公式,<span class="math inline">\(\sum_{ i = 0 }^{
n - 1 } ( \omega_n^i )^{ j - k } = \frac{ \omega^0_n [ ( \omega_n^{ j -
k } )^n - 1 ] }{ \omega_n^{ j - k } - 1 } = 0 \\\)</span>.</p>
<p>所以<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } ( \omega_n^i
)^{ j - k } = n [ j = k ] \\\)</span>.</p>
<p>那么我们有</p>
<p>a_k=\</p>
<h6><span id="写法">写法</span></h6>
<p>递归写法显然.</p>
<p>递归过程中,第<span class="math inline">\(k\)</span>层相当于在根据数在第<span class="math inline">\(k\)</span>位的二进制数是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">ll ak=a[i+k];</span><br><span class="line">a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5>
<p>由于FFT中的单位根会产生精度误差,因此在膜<span class="math inline">\(998244353\)</span>意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为<span class="math inline">\(g\)</span>,<span class="math inline">\(g_n = g^{
\frac{ p - 1 }{ n } }
\\\)</span>,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol type="1">
<li><p><span class="math inline">\(g_n^n = g_n^0 = 1\)</span>且<span class="math inline">\(\forall 0 \leq i &lt; j &lt; n , g_n^i \ne
g_n^j\)</span>,证明由原根的性质.</p></li>
<li><p>折半引理:<span class="math inline">\(g_{ 2 n }^{ 2 k } = g_{ n
}^k\)</span>,证明显然.</p></li>
<li><p>消去引理:<span class="math inline">\(g_{ n }^{ k + \frac{ n }{ 2
} } = - g^k_n \\\)</span>.由于<span class="math inline">\(g^{ \frac{ p -
1 }{ 2 } } = - 1\)</span>,该结论显然成立.</p></li>
</ol>
<p>由上我们证明了,我们完全可以使用<span class="math inline">\(g_n\)</span>代替<span class="math inline">\(\omega_n\)</span>进行变换.</p>
<p>另外,注意到<span class="math inline">\(998244352 = 2^{ 23 } \times 7
\times 17 \\\)</span>,而<span class="math inline">\(2^{ 23 } \approx 8
\times 10^6 \\\)</span>.因而,当<span class="math inline">\(n \leq 8
\times 10^6\)</span>的时候,<span class="math inline">\(g_n\)</span>可以直接求出.这也是为什么大部分NTT题目都使用<span class="math inline">\(998244353\)</span>作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5>
<p>范德蒙德矩阵形如:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; \alpha_1 &amp; \cdots &amp; \alpha_1^{ n - 1 } \\
1 &amp; \alpha_2 &amp; \cdots &amp; \alpha_2^{ n - 1 } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \alpha_m &amp; \cdots &amp; \alpha_m^{ n - 1 }
\end{bmatrix} \in \mathbb{ R }^{ m \times n }
\]</span></p>
<p>如果取单位根,我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^1 &amp; \cdots &amp; \omega_2^{ n - 1 } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{ n - 1 } &amp; \cdots &amp; \omega_n^{ ( n - 1 )^2 }
\end{bmatrix} \in \mathbb{ R }^{ n \times n }
\]</span></p>
<p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^1 &amp; \cdots &amp; \omega_2^{ n - 1 } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{ n - 1 } &amp; \cdots &amp; \omega_n^{ ( n - 1 )^2 }
\end{bmatrix}^{ - 1 } = \frac{ 1 }{ n } \begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^{ - 1 } &amp; \cdots &amp; \omega_2^{ - ( n - 1 ) } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{ - ( n - 1 ) } &amp; \cdots &amp; \omega_n^{ - ( n - 1
)^2 }
\end{bmatrix}
\]</span></p>
<h4><span id="分治fft">分治FFT</span></h4>
<p>给定<span class="math inline">\(g ( x )\)</span>和<span class="math inline">\(f ( 0 )\)</span>,求<span class="math inline">\(f (
x ) = \sum_{ y = 1 }^x f ( x - y ) g ( y )\)</span>,答案对<span class="math inline">\(998244353\)</span>取膜.</p>
<p>考虑分治,假如我们已经知道了<span class="math inline">\(f ( x ) , x
\in [ 1 , \frac{ n }{ 2 } ]\)</span>.那我们可以计算出这段部分对<span class="math inline">\(f ( y ) ， y \in [ \frac{ n }{ 2 } + 1 , n
]\)</span>的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4>
<p>对于多项式<span class="math inline">\(P ( x )\)</span>,找到<span class="math inline">\(Q ( x )\)</span>使得<span class="math inline">\(Q
( x ) P ( x ) \equiv 1 \pmod{ x^{ n } } \\\)</span>.显然<span class="math inline">\(Q ( x )\)</span>是唯一的.</p>
<p>首先不妨设<span class="math inline">\(n = 2^k \\\)</span>.</p>
<p>如果我们已知<span class="math inline">\(P ( x ) Q_{ k - 1 } ( x )
\equiv 1 \pmod{ x^{ 2^{ k - 1 } } } \\\)</span>,同时肯定有<span class="math inline">\(P ( x ) Q_{ k } ( x ) \equiv 1 \pmod{ x^{ 2^{ k -
1 } } } \\\)</span>,相减得到<span class="math inline">\(Q_k ( x ) - Q_{
k - 1 } ( x ) \equiv 0 \pmod{ x^{ 2^{ k - 1 } } } \\\)</span>.</p>
<p>两边平方:</p>
$$
<span class="math display">\[\begin{aligned}
Q_k^2 ( x ) + Q^2_{ k - 1 } ( x ) - 2 Q_k ( x ) Q_{ k - 1 } ( x ) &amp;
\equiv 0 \pmod{ x^{ 2^k } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边乘一下<span class="math inline">\(P ( x )\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
Q_k ( x ) - 2 Q_{ k - 1 } ( x ) + P ( x ) Q_{ k - 1 }^2 ( x ) &amp;
\equiv 0 \pmod{ x^n } \\
Q_k ( x ) &amp; \equiv 2 Q_{ k - 1 } ( x ) - P ( x ) Q_{ k - 1 }^2 ( x )
\pmod{ x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据主定理，这么做复杂度是<span class="math inline">\(O ( n \log_2 n
)\)</span>的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; \equiv F ( x ) G ( x ) + f_0 \pmod{ x^{ n + 1 } } \\
F ( x ) &amp; = \frac{ f ( 0 ) }{ 1 - G ( x ) } \pmod{ x^{ n + 1 } }
\end{aligned}
\]</span></p>
<p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4>
<p>对于<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(F ( x )\)</span>和<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(G (
x )\)</span>,找到<span class="math inline">\(Q ( x ) , R ( x
)\)</span>使得<span class="math inline">\(F ( x ) = G ( x ) Q ( x ) + R
( x ) \\\)</span>.</p>
<p>考虑对于<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(F ( x )\)</span>,令<span class="math inline">\(F_R
( x ) = x^n F ( \cfrac{ 1 }{ x } )\)</span>,如果设<span class="math inline">\(f_i\)</span>为其<span class="math inline">\(x^i\)</span>项前的系数,不难发现<span class="math inline">\(f_R ( i ) = f ( n - i )\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; = G ( x ) Q ( x ) + R ( x ) \\
F ( \cfrac{ 1 }{ x } ) &amp; = G ( \cfrac{ 1 }{ x } ) Q ( \cfrac{ 1 }{ x
} ) + R ( \cfrac{ 1 }{ x } ) \\
x^n F ( \cfrac{ 1 }{ x } ) &amp; = x^m G ( \cfrac{ 1 }{ x } ) x^{ n - m
} Q ( \cfrac{ 1 }{ x } ) + x^{ n - m + 1 } x^{ m - 1 } R ( \cfrac{ 1 }{
x } ) \\
F_R ( x ) &amp; = G_R ( x ) Q_R ( x ) + x^{ n - m + 1 } R_R ( x ) \\
F_R ( x ) &amp; \equiv G_R ( x ) Q_R ( x ) \pmod{ x^{ n - m + 1 } } \\
Q_R ( x ) &amp; \equiv F_R ( x ) G_R^{ - 1 } ( x ) \pmod{ x^{ n - m + 1
} }
\end{aligned}
\]</span></p>
<p>于是只要做一遍多项式求逆即可求得<span class="math inline">\(Q ( x
)\)</span>,再做一遍相减既可以得到<span class="math inline">\(R ( x
)\)</span>.</p>
<h4><span id="多项式ln">多项式ln</span></h4>
<p>给出<span class="math inline">\(n - 1\)</span>次多项式<span class="math inline">\(A ( x )\)</span>,求一个多项式<span class="math inline">\(B ( x )\)</span>,满足<span class="math inline">\(B
( x ) \equiv \ln A ( x )\)</span>.</p>
<p>我们有:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \ln A ( x ) \pmod{ x^n } \\
B &#39; ( x ) &amp; \equiv \cfrac{ A &#39; ( x ) }{ A ( x ) } \pmod{
nx^{ n - 1 } } \\
B ( x ) &amp; \equiv \int \cfrac{ A &#39; ( x ) }{ A ( x ) } dx \pmod{
x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当<span class="math inline">\([ x^0 ] f ( x ) =
1\)</span>的时候,<span class="math inline">\(f ( x
)\)</span>有对数多项式.</p>
<p>我们对最后再做一步:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \int_0^x \cfrac{ A &#39; ( t ) }{ A ( t ) } dt + B
( 0 ) \pmod{ x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>首先<span class="math inline">\(B ( 0 ) = \ln A ( 0 ) = \ln
a_0\)</span>,如果<span class="math inline">\(a_0 \in \mathbb{ Q } \land
a_0 \ne 1\)</span>,则<span class="math inline">\(B ( 0 ) \notin \mathbb{
Q }\)</span>,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若<span class="math inline">\([ x^0 ] f ( x ) =
1\)</span>的时候,<span class="math inline">\(B ( 0 ) =
0\)</span>,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>给定多项式<span class="math inline">\(G ( x
)\)</span>,求一个多项式<span class="math inline">\(F ( x
)\)</span>满足<span class="math inline">\(G ( F ( x ) ) \equiv 0 \pmod{
x^n }\)</span>.</p>
<p>首先<span class="math inline">\(n = 1\)</span>的时候,也就是求<span class="math inline">\(G ( F ( x ) ) \equiv 0 \pmod{ x
}\)</span>.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在<span class="math inline">\(\bmod x^{ \lceil
\frac{ n }{ 2 } \rceil }\)</span>意义下的答案<span class="math inline">\(F_0 ( x )\)</span>,我们考虑在<span class="math inline">\(F_0 ( x )\)</span>处做泰勒展开:</p>
$$
<span class="math display">\[\begin{aligned}
G ( F ( x ) ) &amp; = \sum_{ k = 0 }^{ + \infty } \frac{ G^{ ( k ) } (
F_0 ( x ) ) }{ k ! } ( F ( x ) - F_0 ( x ) )^k \equiv 0 \pmod{ x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑<span class="math inline">\(F ( x ) - F_0 ( x
)\)</span>,由于<span class="math inline">\(F_0 ( x ) \equiv F ( x )
\pmod{ x^{ \lceil \frac{ n }{ 2 } \rceil } }\)</span>,因此,因此<span class="math inline">\(( F ( x ) - F_0 ( x ) )^2 \equiv 0 \pmod{ x^n
}\)</span>.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^{ + \infty } \frac{ G^{ ( k ) } ( F_0 ( x ) ) }{ k ! } (
F ( x ) - F_0 ( x ) )^k &amp; \equiv 0 \pmod{ x^n } \\
G ( F_0 ( x ) ) + G &#39; ( F_0 ( x ) ) ( F ( x ) - F_0 ( x ) ) &amp;
\equiv 0 \pmod{ x^n } \\
F ( x ) &amp; \equiv F_0 ( x ) - \frac{ G ( F_0 ( x ) ) }{ G &#39; ( F_0
( x ) ) } \pmod{ x^n }
\end{aligned}
\]</span></p>
<p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4>
<p>给定<span class="math inline">\(h ( x )\)</span>,设<span class="math inline">\(g ( f ( x ) ) = f^2 ( x ) - h ( x
)\)</span>,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
f ( x ) \equiv f_0 ( x ) - \frac{ f^2 ( x ) - h ( x ) }{ 2 f_0 ( x ) }
\equiv \frac{ f^2 ( x ) + h ( x ) }{ 2 f_0 ( x ) } \pmod{ x^n }
\]</span></p>
<p>还没完,用牛顿迭代前一定要求<span class="math inline">\(g ( a ) \equiv
0 \pmod{ x^n }\)</span>的解,也就是<span class="math inline">\([ x^0 ] h
( x )\)</span>的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4>
<p>给定<span class="math inline">\(h ( x )\)</span>,设<span class="math inline">\(g ( f ( x ) ) = \ln f ( x ) - h ( x
)\)</span>,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; \equiv f_0 ( x ) - \frac{ \ln f_0 ( x ) - h ( x ) }{
\frac{ 1 }{ f_0 ( x ) } } \pmod{ x^n } \\
&amp; \equiv f_0 ( x ) ( 1 - \ln f_0 ( x ) + h ( x ) ) \pmod{ x^n }
\end{aligned}
\]</span></p>
<p>还没完,还需要求<span class="math inline">\(g ( a ) \equiv 0 \pmod{
x^n }\)</span>的解,注意到存在<span class="math inline">\(\exp\)</span>当且仅当<span class="math inline">\([
x^0 ] g ( x ) \equiv 0\)</span>,此时<span class="math inline">\(f ( x )
\equiv 1 \pmod{ x }\)</span>.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4>
<p>求<span class="math inline">\(\ln\)</span>后求<span class="math inline">\(\exp\)</span>即可,唯一的问题是为什么指数可以对<span class="math inline">\(p\)</span>取膜.</p>
<p>我们有一个结论:</p>
<p><span class="math display">\[
f ( x^p ) \equiv f ( x )^p \pmod{ p }
\]</span></p>
<p>这个结论很简单,注意到<span class="math inline">\(( a + b )^p \equiv
a^p + b^p \pmod{ p }\)</span>即可.</p>
<p>而又由于<span class="math inline">\(n &lt; p\)</span>,因此<span class="math inline">\(f ( x )^p \equiv f ( 0 ) \pmod{ p
}\)</span>,通常取<span class="math inline">\(f ( 0 ) =
1\)</span>,于是就可以直接对<span class="math inline">\(p\)</span>取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4>
<p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做<span class="math inline">\(\exp\)</span>的时候的直接数组传参,会导致<span class="math inline">\(\exp\)</span>的复杂度退化到<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">ll x[qwq];</span><br><span class="line"><span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">ll ak=(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">x.k=k;</span><br><span class="line">x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">y.x[i]=x*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">y.limit=x.limit;y.k=x.k;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">tmp_inv.x[i]=x.x[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">tmp_inv.k=q_inv.k=k;</span><br><span class="line">q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line"><span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line"><span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">x.limit=lim,x.k=k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">tmp_exp.k=q_exp.k=k;</span><br><span class="line">q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_exp;</span><br><span class="line">&#125;</span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3>
<p>集合幂级数形如<span class="math inline">\(\sum_{ i = 0 }^{ 2^n - 1 }
a_i x^i\)</span>,其中二进制数<span class="math inline">\(i\)</span>表示<span class="math inline">\(\{ 1 , 2
, . . . , n \}\)</span>的一个子集,用<span class="math inline">\(| i
|\)</span>表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4>
<p>高维前缀和:<span class="math inline">\(c_i = \sum_{ j \subseteq i }
a_j \\\)</span>.</p>
<p>高维后缀和:<span class="math inline">\(c_i = \sum_{ j \supseteq i }
a_j \\\)</span>.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:<span class="math inline">\(c_i = \sum_{ j } \sum_{ k } [ j
\lor k = i ] a_j b_k \\\)</span>.</p>
<p>与卷积:<span class="math inline">\(c_i = \sum_{ j } \sum_{ k } [ j
\land k = i ] a_j b_k \\\)</span>.</p>
<p>二者求法类似,考虑如何求<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的或卷积:</p>
<p>引理:</p>
<p>若<span class="math inline">\(j , k \subseteq i\)</span>,则<span class="math inline">\(j \lor k \subseteq i\)</span>,逆命题同样成立.</p>
<p>若<span class="math inline">\(j , k \supseteq i\)</span>,则<span class="math inline">\(j \land k \supseteq i\)</span>,逆命题同样成立.</p>
<p>设<span class="math inline">\(a , b ,
c\)</span>的高维前缀和分别为<span class="math inline">\(A , B ,
C\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A_i B_i &amp; = ( \sum_{ j \subseteq i } a_j ) ( \sum_{ k \subseteq i }
b_k ) \\
&amp; = \sum_{ j , k \subseteq i } a_i b_k \\
&amp; = \sum_{ k \lor j \subseteq i } a_i b_k \\
&amp; = C_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>现在考虑已知<span class="math inline">\(C\)</span>求<span class="math inline">\(c\)</span>,本质上是一个反演.注意到<span class="math inline">\(\sum_{ r \subseteq p } ( - 1 )^{ | r | } = \sum_{
k = 0 }^{ | p | } C_{ | p | }^k ( - 1 )^k = [ p = 0 ]
\\\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
c ( p ) &amp; = \sum_{ q \subseteq p } [ p - q = 0 ] c ( q ) \\
&amp; = \sum_{ q \subseteq p } \sum_{ r \subseteq ( p - q ) } ( - 1 )^{
| r | } c ( q ) \\
&amp; = \sum_{ r \subseteq p } ( - 1 )^{ | r | } \sum_{ q \subseteq ( p
- r ) } c ( q ) \\
&amp; = \sum_{ r \subseteq p } ( - 1 )^{ r } C ( p - r ) \\
&amp; = \sum_{ r \subseteq p } ( - 1 )^{ | p | - | r | } C ( r ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是有<span class="math inline">\(c ( S ) = \sum_{ T \subseteq S } (
- 1 )^{ | S | - | T | } C ( T ) \\\)</span>(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度<span class="math inline">\(O ( 2^n n )\)</span>.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4>
<p>异或卷积:<span class="math inline">\(c_i = \sum_j \sum_k [ j \oplus k
= i ] a_j b_k \\\)</span>.</p>
<p>引理:<span class="math inline">\(( i \oplus j ) \land k = ( i \land k
) \oplus ( j \land k )\)</span>.</p>
<p>证明的话考虑如果<span class="math inline">\(k =
0\)</span>,二者显然相等;当<span class="math inline">\(k =
1\)</span>的时候,左右都等价于<span class="math inline">\(( i \oplus j
)\)</span>.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数<span class="math inline">\(FWT ( a
)\)</span>,满足<span class="math inline">\(FWT ( a )_i = \sum_{ j = 0
}^{ 2^n - 1 } ( - 1 )^{ | i \land j | } a_j \\\)</span>.</p>
<p>那么有:</p>
$$
<span class="math display">\[\begin{aligned}
FWT ( c )_i &amp; = \sum_{ j = 0 }^{ 2^n - 1 } ( - 1 )^{ | i \land j | }
c_j \\
&amp; = \sum_{ j = 0 }^{ 2^n - 1 } ( - 1 )^{ | i \land j | } \sum_{ k =
0 }^{ 2^n - 1 } \sum_{ l = 0 }^{ 2^n - 1 } [ k \oplus l = j ] a_k b_l \\
&amp; = \sum_{ k = 0 }^{ 2^n - 1 } \sum_{ l = 0 }^{ 2^n - 1 } ( - 1 )^{
| ( k \oplus l ) \land i | } a_k b_l \\
&amp; = \sum_{ k = 0 }^{ 2^n - 1 } \sum_{ l = 0 }^{ 2^n - 1 } ( - 1 )^{
| k \land i | } a_k ( - 1 )^{ | l \land i | } b_l \\
&amp; = FWT ( a )_i FWT ( b )_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>时间复杂度<span class="math inline">\(O ( 2^n n )\)</span>.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4>
<h5><span id="线性代数角度">线性代数角度</span></h5>
<p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换<span class="math inline">\(FWT\)</span>,使得</p>
<ol type="1">
<li><p>若<span class="math inline">\(c_i = \sum_{ j \oplus k } a_j
b_k\)</span>,则<span class="math inline">\(FWT ( c ) = FWT ( a ) FWT ( b
)\)</span>.</p></li>
<li><p>这个线性变换是可逆的.</p></li>
<li><p>做这个线性变换和其逆变换的复杂度都可以接受.</p></li>
</ol>
<p>我们设<span class="math inline">\(FWT ( A )_i = \sum_{ j } w ( i , j
) A_j\)</span>,我们想要做的就是构造一组满足上述条件的<span class="math inline">\(w\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( C )_i &amp; = FWT ( A )_i FWT ( B )_i \\
\sum_{ j } w ( i , j ) C_j &amp; = \sum_{ j , k } w ( i , j ) w ( i , k
) A_j B_k
\end{aligned}
\]</span></p>
<p>再考虑:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; = A * B \\
C_i &amp; = \sum_{ k \oplus l = i } A_k B_l \\
\sum_{ j } w ( i , j ) C_j &amp; = \sum_j w ( i , j ) \sum_{ k \oplus l
= j } A_k B_l \\
\sum_{ j , k } w ( i , j ) w ( i , k ) A_j B_k &amp; = \sum_j w ( i , j
) \sum_{ k \oplus l = j } A_k B_l \\
\sum_{ j , k } w ( i , j ) w ( i , k ) A_j B_k &amp; = \sum_{ j , k }
A_j B_k w ( i , j \oplus k )
\end{aligned}
\]</span></p>
<p>比较两边系数,有<span class="math inline">\(w ( i , j ) w ( i , k ) =
w ( i , j \oplus k
)\)</span>.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于<span class="math inline">\(\oplus\)</span>是集合的运算,我们可以对二进制分开考虑.换句话说,如果<span class="math inline">\(a = \sum_{ i = 0 } a_i 2^i , b = \sum_{ i = 0 }
b_i 2^i\)</span>,那么<span class="math inline">\(w ( a , b ) = \prod_{ i
= 0 } w ( a_i , b_i )\)</span>一定是满足条件的.</p>
<p>这样我们就可以只求一个<span class="math inline">\(2 \times
2\)</span>的线性变换矩阵就好.我们接下来将对三种常见的基础位运算(<span class="math inline">\(\lor , \land , xor ( \oplus
)\)</span>)分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出<span class="math inline">\(FWT ( a )\)</span>呢?</p>
<p>考虑和FFT一样折半,令<span class="math inline">\(i_0\)</span>为<span class="math inline">\(i\)</span>的最高位是否是<span class="math inline">\(1\)</span>,<span class="math inline">\(i
&#39;\)</span>为<span class="math inline">\(i\)</span>去掉最高位后的二进制数字,令<span class="math inline">\(n = 2^m\)</span>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A )_i &amp; = \sum_{ j = 0 }^{ 2^m - 1 } w ( i , j ) A_j \\
&amp; = \sum_{ j = 0 }^{ 2^{ m - 1 } - 1 } w ( i , j ) A_j + \sum_{ j =
2^{ m - 1 } }^{ 2^m - 1 } w ( i , j ) A_j \\
&amp; = w ( i_0 , 0 ) \sum_{ j = 0 }^{ 2^{ m - 1 } - 1 } w ( i &#39; , j
&#39; ) A_j + w ( i_0 , 1 ) \sum_{ j = 2^{ m - 1 } }^{ 2^m - 1 } w ( i
&#39; , j &#39; ) A_j
\end{aligned}
\]</span></p>
<p>这样就实现了规模减半,复杂度<span class="math inline">\(O ( mn
)\)</span>.</p>
<p>下面我们设FWT的变换矩阵为<span class="math inline">\(\begin{bmatrix}w
( 0 , 0 ) &amp; w ( 0 , 1 ) \\ w ( 1 , 0 ) &amp; w ( 1 , 1
)\end{bmatrix}\)</span>.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1 &amp; 0 \\ 1 &amp;
1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}1 &amp; 0 \\ - 1 &amp;
1\end{bmatrix}\)</span>.</p>
<h6><span id="与卷积">与卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1 &amp; 1 \\ 0 &amp;
1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}1 &amp; - 1 \\ 0 &amp;
1\end{bmatrix}\)</span>.</p>
<h6><span id="异或卷积">异或卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1 &amp; 1 \\ 1 &amp;
- 1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}\frac{ 1 }{ 2 } &amp; \frac{ 1 }{ 2
} \\ \frac{ 1 }{ 2 } &amp; - \frac{ 1 }{ 2 }\end{bmatrix}\)</span>.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5>
<p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:<span class="math inline">\(x^S x^T = x^{ S \oplus
T }\)</span>,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A )_S &amp; = \sum_{ T = 0 }^{ 2^n - 1 } ( - 1 )^{ | S \land T | }
a_T \\
IFWT ( A )_S &amp; = \frac{ 1 }{ 2^n } FWT ( A )_S
\end{aligned}
\]</span></p>
<p>这等价于:</p>
<p><span class="math display">\[
\begin{aligned}
[ x^S ] FWT ( A ) &amp; = \sum_{ T = 0 }^{ 2^n - 1 } ( - 1 )^{ | S \land
T | } a_T \\
[ x^S ] IFWT ( A ) &amp; = [ x^S ] \frac{ 1 }{ 2^n } FWT ( A )
\end{aligned}
\]</span></p>
<h4><span id="子集卷积">子集卷积</span></h4>
<p>子集卷积:<span class="math inline">\(c_i = \sum_{ j } \sum_{ k } [ j
\land k = \emptyset , j \lor k = i ] a_j b_k \\\)</span>.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些<span class="math inline">\([ j \land k \ne \emptyset ]\)</span>的答案,而<span class="math inline">\([ j \land k = \phi , j \lor k = i ] = [ | j | + |
k | = | i | , j \lor k = i ] \\\)</span>.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再<span class="math inline">\(n^2\)</span>次结合,并做IFMT,最终将结果累计,复杂度<span class="math inline">\(O ( 2^n n^2 )\)</span>.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4>
<p>其实就是设<span class="math inline">\(g_{ i , j } = z^i
f_j\)</span>,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1agc034f-rng-andxor">Example1([AGC034F] RNG and
XOR)</span></h5>
<p>设<span class="math inline">\(f_i ( n )\)</span>表示操作<span class="math inline">\(n\)</span>次后第一次变成<span class="math inline">\(i\)</span>的概率,<span class="math inline">\(g_i (
n )\)</span>表示操作<span class="math inline">\(n\)</span>次后变成<span class="math inline">\(i\)</span>的概率.<span class="math inline">\(F ,
G\)</span>分别是其生成函数.</p>
<p>注意到<span class="math inline">\(G_i = F_i G_0 , F_i = \frac{ G_i }{
G_0 }\)</span>,而<span class="math inline">\(F_i &#39; ( 1
)\)</span>就是期望.接下来的问题在于如何求<span class="math inline">\(G\)</span>.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把<span class="math inline">\(a_i \rightarrow \frac{ a_i }{ \sum a
}\)</span>,然后做<span class="math inline">\(A = FWT ( a
)\)</span>,注意这里<span class="math inline">\(A_0 = \sum a =
1\)</span>,FWT自身有很好的性质:<span class="math inline">\(a = \frac{ 1
}{ 2^N } FWT ( A )\)</span>.我们做<span class="math inline">\(n\)</span>次操作后得到的概率数组也就是<span class="math inline">\(\frac{ 1 }{ 2^N } FWT ( A^n
)\)</span>.展开FWT的式子,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g_i ( n ) &amp; = \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | }
A_j^n x^n \\
G_i &amp; = \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | } \frac{
1 }{ 1 - A_j x } \\
F_i &amp; = \frac{ G_i }{ G_0 } \\
F_i &#39; &amp; = \frac{ G_i &#39; G_0 - G_0 &#39; G_i }{ G_0^2 } \\
&amp; = \frac{ ( \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | }
\frac{ A_j }{ ( 1 - A_j x )^2 } ) ( \sum_{ j = 0 }^{ 2^N - 1 } \frac{ 1
}{ 1 - A_j x } ) - ( \sum_{ j = 0 }^{ 2^N - 1 } \frac{ A_j }{ ( 1 - A_j
x )^2 } ) ( \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | } \frac{
1 }{ 1 - A_j x } ) }{ ( \sum_{ j = 0 }^{ 2^N - 1 } \frac{ 1 }{ 1 - A_j x
} )^2 }
\end{aligned}
\]</span></p>
<p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求<span class="math inline">\(F &#39;_i ( 1 )\)</span>,因此我们直接把<span class="math inline">\(x = 1\)</span>带入算一算就好.不过由于<span class="math inline">\(A_0 = 1\)</span>,我们必须要解决分母为<span class="math inline">\(0\)</span>的情况,解决的方法是分母乘上<span class="math inline">\(( 1 - x )\)</span>,这样就消掉了<span class="math inline">\(j =
0\)</span>的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5>
<p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边<span class="math inline">\(u \leftrightarrow v\)</span>就异或上<span class="math inline">\(( 2^u + 2^v )\)</span>.最后要求这个二进制数是<span class="math inline">\(0\)</span>.我们用一个二元组<span class="math inline">\(( a , F )\)</span>表示在集合幂级数上异或上<span class="math inline">\(a\)</span>,在多项式上乘上<span class="math inline">\(F\)</span>.显然一条边是<span class="math inline">\(( 0 , 1 ) + ( 2^u + 2^v , x
)\)</span>.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上<span class="math inline">\(1 + x\)</span>要么乘上<span class="math inline">\(1 - x\)</span>,做完FWT得到的每一个<span class="math inline">\(FWT_i\)</span>一定形如<span class="math inline">\(( 1 + x )^k ( 1 - x )^{ m - k
}\)</span>,做IFWT的时候直接求<span class="math inline">\(\frac{ 1 }{ 2^N
} \sum ( 1 + x )^k ( 1 - x )^{ m - k }\)</span>即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:<span class="math inline">\(( 0 , 1 )\)</span>和<span class="math inline">\((
2^u + 2^v , x )\)</span>,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个<span class="math inline">\(i\)</span>求<span class="math inline">\(k\)</span>,也就是对于每个<span class="math inline">\(i\)</span>求有多少条边满足<span class="math inline">\(| i \land ( 2^u + 2^v ) | =
1\)</span>,也就是求有多少条边一段链接在了<span class="math inline">\(i\)</span>的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-cloves-3-iii">Example3(CF1034E Little C
Loves 3 III)</span></h5>
<p>仍然是子集卷积,转化为<span class="math inline">\(c_i = \sum_{ j }
\sum_{ k } [ | j | + | k | = | i | , j \lor k = i ] a_j b_k
\\\)</span>.然后我们将<span class="math inline">\(a_j\)</span>乘上<span class="math inline">\(4^j\)</span>,将<span class="math inline">\(b_k\)</span>乘上<span class="math inline">\(4^k\)</span>,最后把<span class="math inline">\(c_i\)</span>除去<span class="math inline">\(4^i\)</span>对<span class="math inline">\(4\)</span>取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2chiori-and-doll-picking">Example4(CF1336E2
Chiori and Doll Picking)</span></h5>
<p>先考虑easy version.首先求出线性基,如果线性基的大小<span class="math inline">\(k\)</span>比较小,我们可以直接<span class="math inline">\(2^k\)</span>枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个<span class="math inline">\(1\)</span>取决于选了多少个元素,其他位置共有<span class="math inline">\(m -
k\)</span>个,可以直接状压进状态.这样复杂度就是<span class="math inline">\(O ( \min \{ 2^k , m^2 2^{ m - k } \}
)\)</span>.</p>
<p>那么我们怎么优化呢?首先<span class="math inline">\(k\)</span>较大的时候有点难做,我们看看能不能优化到<span class="math inline">\(2^{ m - k }\)</span>.</p>
<p>考虑设<span class="math inline">\(f_i^c = [ | i | = c
]\)</span>,将线性基能做出的线性空间设为<span class="math inline">\(A\)</span>,<span class="math inline">\(A_S =
1\)</span>当且仅当线性基能异或出<span class="math inline">\(S\)</span>(最后再把那些废元素贡献到答案里).那么<span class="math inline">\(popcount = c\)</span>的答案就是<span class="math inline">\(IFWT ( FWT ( F ) FWT ( A ) )_0\)</span>.考虑<span class="math inline">\(IFWT_0 = \frac{ 1 }{ 2^m } \sum_{ i = 0 }^{ 2^m -
1 } FWT ( F )_i FWT ( A )_i\)</span>,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:<span class="math inline">\(FWT ( A )\)</span>要么是<span class="math inline">\(2^k\)</span>,要么是<span class="math inline">\(0\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
A * A = A \times 2^k
\]</span></p>
<p>这句是为啥呢?因为对于右边的每一个数字<span class="math inline">\(x\)</span>和左边的一个数字<span class="math inline">\(y\)</span>,如果它们都在线性基中,一定存在一个数字<span class="math inline">\(z\)</span>满足<span class="math inline">\(y \oplus
z = x\)</span>,不然就是<span class="math inline">\(0\)</span>.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A )_i \cdot FWT ( A )_i &amp; = FWT ( A )_i \times 2^k \\
FWT ( A )_i &amp; = 0 \lor 2^k
\end{aligned}
\]</span></p>
<p>引理2:<span class="math inline">\(FWT ( A )_i = 2^k \Leftrightarrow
\forall x , A_x \ne 0 , | i \land x | \equiv 0 \pmod{ 2 }\)</span>.</p>
<p>直接展开上面的式子,用<span class="math inline">\(\sum_{ S \subseteq T
} ( - 1 )^{ | S | } = [ T = \emptyset ]\)</span>.</p>
<p>引理3:<span class="math inline">\(FWT ( A )\)</span>中值为<span class="math inline">\(2^k\)</span>的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果<span class="math inline">\(i\)</span>满足条件,<span class="math inline">\(j\)</span>满足条件,一开始做FWT时我们已经注意到:<span class="math inline">\(( i \oplus j ) \land x = ( i \land x ) \oplus ( j
\land x )\)</span>.于是这个引理也显然成立.</p>
<p>引理4:<span class="math inline">\(FWT ( A )\)</span>中值为<span class="math inline">\(2^k\)</span>的位置构成的线性基的大小是<span class="math inline">\(m - k\)</span>.</p>
<p>设这些位置构成的空间是<span class="math inline">\(B\)</span>,<span class="math inline">\(B_S = 1\)</span>当且仅当<span class="math inline">\(S\)</span>在这个空间中.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) &amp; = B \times 2^k \\
A &amp; = IFWT ( B ) \times 2^k
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(a_0 = 1\)</span>,也就是<span class="math inline">\(\frac{ 2^k }{ 2^m } \sum b = 1 , \sum b = 2^{ m -
k }\)</span>,这就证明了引理.</p>
<p>引理5:将<span class="math inline">\(A\)</span>的线性基对应的矩阵从前往后消成最简,<span class="math inline">\(B\)</span>的线性基对应的矩阵从后往前消成最简,上<span class="math inline">\(A\)</span>下<span class="math inline">\(B\)</span>拼成一个<span class="math inline">\(m
\times m\)</span>的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据<span class="math inline">\(rank ( A ) + rank ( B ) = k + m -
k = m\)</span>可以知道主对角线一定全是<span class="math inline">\(1\)</span>,然后我们任取<span class="math inline">\(A\)</span>中的一个基<span class="math inline">\(x\)</span>和<span class="math inline">\(B\)</span>中的一个基<span class="math inline">\(y\)</span>,应该有<span class="math inline">\(| x
\land y | \equiv 0 \pmod{ 2
}\)</span>.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由<span class="math inline">\(A\)</span>得知<span class="math inline">\(B\)</span>长什么样.</p>
<p>引理6:<span class="math inline">\(FWT ( F^c )_i\)</span>只和<span class="math inline">\(| i |\)</span>有关.</p>
<p>因为<span class="math inline">\(F^c_i\)</span>只和<span class="math inline">\(| i
|\)</span>有关,这里考虑一下对称性就可以.因此设<span class="math inline">\(w_{ d }^c = FWT ( F^c )_i , | i | =
d\)</span>.</p>
<p>然后注意到<span class="math inline">\(w_d^c = \sum_{ i = 0 }^{ 2^m -
1 } ( - 1 )^{ | i \land ( 2^d - 1 ) | } [ | i | = c
]\)</span>.组合意义展开一下:</p>
<p><span class="math display">\[
w_d^c = \sum_{ j = 0 }^{ d } ( - 1 )^{ j } \binom{ d }{ j } \binom{ m -
d }{ c - j }
\]</span></p>
<p>接下来怎么做呢?令<span class="math inline">\(g_d = \sum_{ i = 0 }^{
2^m - 1 } [ A_i = 1 ] [ | i | = d ]\)</span>,这里可以<span class="math inline">\(O ( 2^{ m - k } )\)</span>,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5>
<p>首先发现”如果没有边那么是<span class="math inline">\(0\)</span>“这个限制太强了,如果我们能改为”如果是<span class="math inline">\(0\)</span>,那么可有边可无边”的话,整个序列就会被<span class="math inline">\(1\)</span>的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设<span class="math inline">\(g_{ len , S }\)</span>表示长度为<span class="math inline">\(len\)</span>,一段长度为<span class="math inline">\(len - 1\)</span>的连续的<span class="math inline">\(1\)</span>对应的集合是<span class="math inline">\(S\)</span>的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个<span class="math inline">\(0\)</span>).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5>
<p>首先可以类似数位dp设计一个<span class="math inline">\(dp_{ i , S
}\)</span>表示目前dp到了第<span class="math inline">\(i\)</span>位,然后前面的<span class="math inline">\(limit\)</span>是<span class="math inline">\(S\)</span>.接下来分类讨论当前的最大值限制是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2>
<h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3>
<h4><span id="概念">概念</span></h4>
<p>我们定义一个幂级数形如<span class="math inline">\(A ( z ) = \sum_{ k
\geq 0 } a_k z^k\)</span>,并使<span class="math inline">\([ z^n ] A ( z
) = a_n\)</span>.则称<span class="math inline">\(A ( z )\)</span>是<span class="math inline">\(\langle a_0 , a_1 , . . .
\rangle\)</span>的生成函数.</p>
<h4><span id="运算">运算</span></h4>
<ol type="1">
<li><p><span class="math inline">\(\alpha A ( z ) + \beta B ( z ) =
\sum_{ n \geq 0 } ( \alpha f_n + \beta g_n ) z^n\)</span>.</p></li>
<li><p><span class="math inline">\(z^m A ( z ) = \sum_{ n \geq 0 } g_{ n
} z^{ n + m } = \sum_{ n \geq m } g_{ n - m } z^n\)</span>.</p></li>
<li><p><span class="math inline">\(A ( cz ) = \sum_{ n \geq 0 } c^n f_n
z^n\)</span>.</p></li>
<li><p><span class="math inline">\(A &#39; ( z ) = \sum_{ n \geq 1 }
ig_i z^{ i - 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(\int A ( z ) dz = \sum_{ n \geq 0 }
\cfrac{ 1 }{ n + 1 } g_n z^{ n + 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(A ( z ) B ( z ) = \sum_{ n \geq 0 } (
\sum_{ k = 0 }^n f_k g_{ n - k } ) z^n\)</span>.</p></li>
<li><p><span class="math inline">\(\cfrac{ 1 }{ 1 - z } A ( z ) = \sum_{
n \geq 0 } ( \sum_{ k = 0 }^n g_k ) z^n\)</span>.</p></li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4>
<ol type="1">
<li><span class="math inline">\(\cfrac{ 1 }{ 1 - z } = \sum_{ k \geq 0 }
z^k \\\)</span>,<span class="math inline">\(\cfrac{ 1 }{ 1 - cz } =
\sum_{ k \geq 0 } c^k z^k \\\)</span>.</li>
</ol>
<p>证明显然.</p>
<ol start="2" type="1">
<li><span class="math inline">\(( 1 + z )^r = \sum_{ k \geq 0 } \binom{
r }{ k } z^k \\\)</span>,<span class="math inline">\(( 1 - z )^r =
\sum_{ k \geq 0 } ( - 1 )^k \binom{ r }{ k } z^k \\\)</span>.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\cfrac{ 1 }{ 1 - z^m } = \sum_{ n \geq 0
} [ n | m ] z^n \\\)</span>.</li>
</ol>
<p>证明显然.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\cfrac{ 1 }{ ( 1 - z )^{ n + 1 } } =
\sum_{ k \geq 0 } \binom{ n + k }{ n } z^k , n \in \mathbb{ N }
\\\)</span>,<span class="math inline">\(\cfrac{ z^n }{ ( 1 - z )^{ n + 1
} } = \sum_{ k \geq 0 } \binom{ k }{ n } z^k , n \in \mathbb{ N }
\\\)</span></li>
</ol>
<p>直接使用二项式定理展开<span class="math inline">\(( 1 - z )^{ - n - 1
}\)</span>,可以得到:</p>
<p><span class="math display">\[
( 1 - z )^{ - n - 1 } = \sum_{ k \geq 0 } ( - 1 )^k \binom{ - n - 1 }{ k
} z^k
\]</span></p>
<p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ 1 }{ ( 1 - z )^2 } &amp; = \sum_{ n \geq 0 } ( n + 1 ) z^n \\
\cfrac{ z }{ ( 1 - z )^2 } &amp; = \sum_{ n \geq 0 } nz^n
\end{aligned}
\]</span></p>
<p>根据<span class="math inline">\(( 1 )\)</span>求导即可得到此式.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(e^z = \sum_{ k \geq 0 } \cfrac{ z^k
}{ k ! } \\\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( \cfrac{ 1 }{ 1 - z } ) = \sum_{
n \geq 1 } \cfrac{ 1 }{ n } z^n\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 + z ) = \sum_{ k \geq 0 } ( -
1 )^k \cfrac{ z^{ k + 1 } }{ k + 1 } \\\)</span>.</p></li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\frac{ 1 - \sqrt{ 1 - 4 x } }{ 2 x } =
\sum_{ k \geq 0 } \frac{ \binom{ 2 k }{ k } }{ k + 1 }
x^k\)</span>.</li>
</ol>
<p>也即卡特兰数<span class="math inline">\(C_k\)</span>的生成函数,证明考虑:</p>
<p><span class="math display">\[
xC^2 + 1 = C
\]</span></p>
<p>然后得到两个根,带入<span class="math inline">\(x =
0\)</span>舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3>
<p>https://zhuanlan.zhihu.com/p/53079223</p>
<p>序列<span class="math inline">\(\{ a
\}\)</span>的指数生成函数定义为形式幂级数<span class="math inline">\(\hat F ( x ) = \sum a_n \frac{ x^n }{ n !
}\)</span>.注意<span class="math inline">\([ x^n ] \hat F ( x ) =
a_n\)</span>.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) \hat G ( x ) &amp; = \sum_{ j \geq 0 } a_j \frac{ x^j }{ j
! } \sum_{ k \geq 0 } b_k \frac{ x^k }{ k ! } \\
&amp; = \sum_{ k \geq 0 } x^k \sum_{ j = 0 }^k a_j b_{ k - j } \frac{ k
! }{ j ! ( k - j ) ! } \frac{ 1 }{ k ! } \\
&amp; = \sum_{ k \geq 0 } \frac{ x^k }{ k ! } \sum_{ j = 0 }^k a_j b_{ k
- j } \binom{ k }{ j }
\end{aligned}
\]</span></p>
<p>即<span class="math inline">\(\langle \sum_{ i = 0 }^n \binom{ n }{ i
} a_i b_{ n - i } \rangle\)</span>的EFG.</p>
<p>注意到有一个特例是<span class="math inline">\(x \hat F ( x
)\)</span>就是<span class="math inline">\(\langle \binom{ n }{ n - 1 }
a_i \rangle\)</span>的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li><span class="math inline">\(e^x = \sum_{ k \geq 0 } \frac{ x^k }{ k
! }\)</span></li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol start="2" type="1">
<li><span class="math inline">\(e^{ px } = \sum_{ k \geq 0 } p^k \frac{
x^k }{ k ! }\)</span></li>
</ol>
<p>换元后可以得到.一个经典特例是<span class="math inline">\(e^{ - x } =
\sum_{ k \geq 0 } ( - 1 )^k \frac{ x^k }{ k ! }\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\frac{ e^x + e^{ - x } }{ 2 } = \sum_{ k
\geq 0 } [ 2 | k ] \frac{ x^k }{ k ! }\)</span>.</li>
</ol>
<p>显然.</p>
<ol start="4" type="1">
<li><span class="math inline">\(( 1 + x )^n = \sum_{ k \geq 0 } n^{
\underline{ k } } \frac{ x^k }{ k ! }\)</span>.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(\ln ( 1 + x ) = \sum_{ k \geq 1 } ( -
1 )^{ k - 1 } ( k - 1 ) ! \frac{ x^k }{ k ! }\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 - x ) = \sum_{ k \geq 1 } ( k
- 1 ) ! \frac{ x^k }{ k ! }\)</span>.</p></li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4>
<p>我们设<span class="math inline">\(F_k ( n )\)</span>为<span class="math inline">\(n\)</span>个有标号元素划分成<span class="math inline">\(k\)</span>个非空无序集合的情况,<span class="math inline">\(f_i\)</span>为<span class="math inline">\(i\)</span>个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和<span class="math inline">\(| S |\)</span>有关的定义在集合上的函数),有:</p>
<p><span class="math display">\[
F_k ( n ) = \frac{ n ! }{ k ! } \sum_{ \sum_{ i = 1 }^k a_i = n }
\prod_{ j = 1 }^k \frac{ f_{ a_j } }{ a_j ! }
\]</span></p>
<p>设<span class="math inline">\(\hat{ F } ( x ) = \sum_{ n \geq 0 } f_n
\frac{ x^n }{ n ! }\)</span>,再设:</p>
<p><span class="math display">\[
\begin{aligned}
\hat G_k ( x ) &amp; = \sum_{ n \geq 0 } F_k ( n ) \frac{ x^n }{ n ! }
\\
&amp; = \sum_{ n \geq 0 } x^n \frac{ 1 }{ k ! } \sum_{ \sum_{ i = 1 }^k
a_i = n } \prod_{ j = 1 }^k \frac{ f_{ a_j } }{ a_j ! } \\
&amp; = \sum_{ n \geq 0 } \frac{ 1 }{ k ! } \sum_{ \sum_{ i = 1 }^k a_i
= n } \prod_{ j = 1 }^k \frac{ f_{ a_j } x^{ a_j } }{ a_j ! } \\
&amp; = \frac{ 1 }{ k ! } \hat F^k ( x )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\sum_{ k \geq 0 } \hat G_k ( x ) = \exp \hat F ( x )
\]</span></p>
<p>或者直接递推:</p>
$$
<span class="math display">\[\begin{aligned}
F_k ( x ) &amp; = \sum_{ i = 1 }^{ n - k + 1 } \binom{ n }{ i } F_{ k -
1 } ( n - i ) f_i \frac{ 1 }{ k } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{aligned}
\hat G_k ( x ) &amp; = \sum_{ n \geq 0 } \frac{ x^n }{ n ! } F_k ( n )
\\
&amp; = \sum_{ n \geq 0 } \frac{ x^n }{ n ! } \sum_{ i = 1 }^{ n - k + 1
} \binom{ n }{ i } F_{ k - 1 } ( n - i ) f_i \frac{ 1 }{ k } \\
&amp; = \frac{ 1 }{ k } \sum_{ n \geq 0 } \frac{ x^n }{ n ! } \sum_{ i =
1 }^{ n - k + 1 } \binom{ n }{ i } F_{ k - 1 } ( n - i ) f_i \\
&amp; = \frac{ 1 }{ k } \hat G_{ k - 1 } ( x ) \hat F ( x ) \\
&amp; = \frac{ 1 }{ k ! } \hat F^k ( x )
\end{aligned}
\]</span></p>
<p>简而言之,<span class="math inline">\([ x^n ] \hat F ( x
)\)</span>是将<span class="math inline">\(n\)</span>个有标号的元素放到同一个无序集合的方案数,而<span class="math inline">\([ x^n ] \exp \hat F ( x )\)</span>是将<span class="math inline">\(n\)</span>个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poj3734">Example1(POJ3734)</span></h5>
<p>对于红黄色砖块,其选取方案为<span class="math inline">\(\{ 1 , 0 , 1 ,
0 , \cdots \}\)</span>,对应的EGF是<span class="math inline">\(\frac{ e^x
+ e^{ - x } }{ 2 }\)</span>.</p>
<p>对于蓝绿色砖块,选取方案是<span class="math inline">\(e^x\)</span>.</p>
<p>乘起来有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) &amp; = ( \frac{ e^x + e^{ - x } }{ 2 } )^2 e^{ 2 x } \\
&amp; = \frac{ ( e^{ 2 x } + 2 + e^{ - 2 x } ) e^{ 2 x } }{ 4 } \\
&amp; = \frac{ e^{ 4 x } + 2 e^{ 2 x } + 1 }{ 4 } \\
&amp; = \frac{ 1 }{ 4 } + \sum_{ k \geq 0 } \frac{ 4^i + 2^{ i + 1 } }{
4 } \frac{ x^i }{ i ! }
\end{aligned}
\]</span></p>
<p>于是有<span class="math inline">\([ x^n ] \hat F ( x ) = 4^{ n - 1 }
+ 2^{ n - 1 }\)</span>.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5>
<p>长度为<span class="math inline">\(n\)</span>的排列数的指数生成函数是<span class="math inline">\(\hat P ( x ) = \sum_{ n \geq 0 } \frac{ n ! x^n }{
n ! } = \frac{ 1 }{ 1 - x }\)</span>.</p>
<p>长度为<span class="math inline">\(n\)</span>的圆排列的指数生成函数是<span class="math inline">\(\hat Q ( x ) = \sum_{ n \geq 0 } \frac{ ( n - 1 )
! x^n }{ n ! } = \frac{ x^n }{ n } = - \ln ( 1 - x ) = \ln \frac{ 1 }{ 1
- x }\)</span>.</p>
<p>于是有<span class="math inline">\(\exp \hat Q ( x ) = \hat P ( x
)\)</span>.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5>
<p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为<span class="math inline">\(1\)</span>的置换环,其EGF显然是<span class="math inline">\(\sum_{ n \geq 2 } \frac{ x^n }{ n } = - \ln ( 1 -
x ) - x\)</span>,错排数的EGF对其取<span class="math inline">\(\exp\)</span>即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5>
<p>考虑如果<span class="math inline">\(n\)</span>个点带编号的无向连通图的EGF是<span class="math inline">\(\hat F ( x )\)</span>,那么<span class="math inline">\(n\)</span>个点带标号无向图的EGF就是<span class="math inline">\(\exp \hat F ( x
)\)</span>,后者直接计数,前者对后者做一次<span class="math inline">\(\ln\)</span>就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5>
<p>求有多少个映射<span class="math inline">\(f : \{ 1 , 2 , \cdots , n
\} \mapsto \{ 1 , 2 , \cdots , n \}\)</span>满足<span class="math inline">\(f \circ f \circ \cdots \circ f\)</span>(共<span class="math inline">\(k\)</span>个<span class="math inline">\(f\)</span>)<span class="math inline">\(= f \circ f
\circ \cdots \circ f\)</span>(共<span class="math inline">\(k -
1\)</span>个<span class="math inline">\(f\)</span>).</p>
<p>考虑将<span class="math inline">\(i \rightarrow
f_i\)</span>,这等价于对深度不超过<span class="math inline">\(k\)</span>的基环树(环的长度为<span class="math inline">\(1\)</span>)计数,等价于对深度不超过<span class="math inline">\(k\)</span>的有根树计数.注意到删去根节点后等价于对深度不超过<span class="math inline">\(k - 1\)</span>的有根树计数,因此<span class="math inline">\(\hat F_k ( x ) = x \exp \hat F_{ k - 1 } ( x
)\)</span>.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5>
<p>假设<span class="math inline">\(k\)</span>次操作后<span class="math inline">\(a_i\)</span>减少了<span class="math inline">\(b_i\)</span>,实际上要求的就是<span class="math inline">\(\prod_{ i = 1 }^n a_i - \prod_{ i = 1 }^n ( a_i -
b_i )\)</span>.</p>
<p>考虑对所有情况下的<span class="math inline">\(\prod_{ i = 1 }^n ( a_i
- b_i )\)</span>求和,注意到<span class="math inline">\(k\)</span>次操作,使得<span class="math inline">\(i\)</span>出现<span class="math inline">\(b_i\)</span>次的方案数是<span class="math inline">\(\frac{ k ! }{ \prod_{ i = 1 }^n b_i !
}\)</span>.直接设<span class="math inline">\(a_j\)</span>的EGF是</p>
<p><span class="math display">\[
\begin{aligned}
\hat F_{ j } ( x ) &amp; = \sum_{ i \geq 0 } ( a_j - i ) \frac{ x^i }{ i
! } \\
&amp; = \sum_{ i \geq 0 } a_j \frac{ x^i }{ i ! } - \sum_{ i \geq 1 }
\frac{ x^i }{ ( i - 1 ) ! } \\
&amp; = a_j e^x - xe^x = ( a_j - x ) e^x
\end{aligned}
\]</span></p>
<p>答案就是<span class="math inline">\([ x^k ] \prod_{ j = 1 }^n \hat
F_j ( x )\)</span>.</p>
<h5><span id="example7">Example7</span></h5>
<h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3>
<p>对于序列<span class="math inline">\(f_n\)</span>,定义其DGF为<span class="math inline">\(\tilde{ F } ( x ) = \sum_{ i \geq 1 } \frac{ f_i
}{ i^x }\)</span>.注意到若<span class="math inline">\(f\)</span>是积性函数,那么<span class="math inline">\(\tilde{ F } ( x ) = \prod_{ p \in \mathrm{ prime }
} \sum_{ i \geq 0 } \frac{ f_{ p^i } }{ p^{ ix } } \\\)</span>.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>对于两个序列<span class="math inline">\(f ,
g\)</span>,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{ F } ( x ) \tilde{ G } ( x ) &amp; = \sum_{ i } \sum_{ j } \frac{
f ( i ) g ( j ) }{ ( ij )^x } \\
&amp; = \sum_{ i } \frac{ 1 }{ i^x } \sum_{ d | i } f ( d ) g ( \frac{ i
}{ d } )
\end{aligned}
\]</span></p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li><span class="math inline">\(\epsilon ( x ) = [ x = 1
]\)</span>.</li>
</ol>
<p>显然为<span class="math inline">\(\tilde{ E } ( x ) = 1\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(I ( x ) = 1\)</span>.</li>
</ol>
<p>其封闭式是黎曼函数<span class="math inline">\(\zeta ( x
)\)</span>,事实上,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\zeta ( x ) &amp; = \prod_{ i \geq 1 } \frac{ 1 }{ i^x } \\
&amp; = \prod_{ p \in \mathrm{ prime } } \sum_{ i \geq 0 } \frac{ 1 }{
p^{ ix } } \\
&amp; = \prod_{ p \in \mathrm{ prime } } \frac{ 1 }{ 1 - p^{ - x } }
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li><span class="math inline">\(\mu ( n )\)</span>.</li>
</ol>
<p>其DGF为<span class="math inline">\(\tilde{ M } ( x ) = \prod_{ p \in
\mathrm{ prime } } ( 1 - p^{ - x } )\)</span>.注意到<span class="math inline">\(\zeta ( x ) \tilde{ M } ( x ) = 1 , \tilde{ M } (
x ) = \frac{ 1 }{ \zeta ( x ) }\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(id ( n ) = n\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\tilde{ ID } ( n ) = \prod_{ i \geq 1 }
\frac{ i }{ i^x } = \prod_{ i \geq 1 } \frac{ 1 }{ i^{ x - 1 } } = \zeta
( x - 1 )\)</span>.</p>
<ol start="5" type="1">
<li><span class="math inline">\(I_k ( n ) = n^k\)</span>.</li>
</ol>
<p><span class="math display">\[
\tilde{ I_k } ( x ) = \prod_{ i \geq 1 } \frac{ 1 }{ i^{ x - k } } =
\zeta ( x - k )
\]</span></p>
<ol start="6" type="1">
<li><span class="math inline">\(\varphi ( n )\)</span>.</li>
</ol>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{ \Phi } ( x ) &amp; = \prod_{ p \in \mathrm{ prime } } ( 1 +
\frac{ p - 1 }{ p^x } + \frac{ p ( p - 1 ) }{ p^{ 2 x } } + \cdots ) \\
&amp; = \prod_{ p \in \mathrm{ prime } } \frac{ 1 - p^{ - x } }{ 1 - p^{
1 - x } } \\
&amp; = \tilde{ \Phi } ( x ) = \frac{ \zeta ( x - 1 ) }{ \zeta ( x ) }
\end{aligned}
\]</span></p>
<p>也注意到<span class="math inline">\(\tilde{ \Phi } ( x ) I ( x ) =
\zeta ( x - 1 ) = \tilde{ ID } ( x )\)</span>.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sigma_k ( n ) = \sum_{ d | n }
d^k\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\(\sigma_k ( n ) = I_k ( n ) * I_0 (
n )\)</span>,也就是说<span class="math inline">\(\tilde{ S } ( x ) =
\zeta ( x - k ) \zeta ( x )\)</span>.</p>
<ol start="8" type="1">
<li><span class="math inline">\(u ( n ) = | \mu ( n ) |\)</span>.</li>
</ol>
<p><span class="math inline">\(\tilde{ u } ( n ) = \frac{ \zeta ( n ) }{
\zeta ( 2 n ) }\)</span>.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5>
<p>考虑对于<span class="math inline">\(f ( n ) = n^2 \varphi ( n
)\)</span>构造积性函数<span class="math inline">\(g ( n ) , h ( n
)\)</span>使得<span class="math inline">\(f * g = h\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{ F } ( x ) &amp; = \prod_{ p \in \mathrm{ prime } } ( 1 + \sum_{
k \geq 1 } \frac{ p^{ 3 k - 1 } ( p - 1 ) }{ p^{ kx } } ) \\
&amp; = \prod_{ p \in \mathrm{ prime } } \frac{ 1 - p^{ 2 - x } }{ 1 -
p^{ 3 - x } } = \frac{ \zeta ( x - 3 ) }{ \zeta ( x - 2 ) }
\end{aligned}
\]</span></p>
<p>也就是<span class="math inline">\(f * I_2 = I_3\)</span>.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3>
<p>对于复数的阶乘,我们通常定义:</p>
<p><span class="math display">\[
\cfrac{ 1 }{ z ! } = \lim_{ n \rightarrow + \infin } \binom{ n + z }{ z
} n^{ - z }
\]</span></p>
<p>同时我们定义<span class="math inline">\(\Gamma ( z + 1 ) = z
!\)</span>,有:<span class="math inline">\(( - z ) ! \Gamma ( z ) =
\cfrac{ \pi }{ \sin ( \pi z ) }\)</span>.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<p><span class="math display">\[
\begin{aligned}
z^{ \underline{ w } } &amp; = \cfrac{ z ! }{ ( z - w ) ! } \\
z^{ \overline{ w } } &amp; = \cfrac{ \Gamma ( z + w ) }{ \Gamma ( z ) }
\end{aligned}
\]</span></p>
<p>通过以上我们还可以有二项式系数的定义:</p>
<p><span class="math display">\[
\binom{ z }{ w } = \lim_{ \zeta \rightarrow z , \omega \rightarrow w }
\cfrac{ \zeta ! }{ \omega ! ( \zeta - \omega ) ! }
\]</span></p>
<h3><span id="超几何级数">超几何级数</span></h3>
<h4><span id="超几何函数">超几何函数</span></h4>
<p>我们定义超几何函数<span class="math inline">\(F ( a_1 , . . . , a_m ;
b_1 , . . . b_n ; z ) = F \left ( \begin{array}{ r | } a_1 , . . . , a_m
\\ b_1 , . . . , b_n\end{array} z \right ) = \sum_{ k \geq 0 } \cfrac{
z^k \prod_{ i = 1 }^m a_i^{ \overline{ k } } }{ k ! \prod_{ i = 1 }^n
b_i^{ \overline{ k } } }\)</span>.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似<span class="math inline">\(\cfrac{
0 }{ 0 } = 1\)</span>之类的式子,可以发现当<span class="math inline">\(z
= 0\)</span>时任意超几何函数总是<span class="math inline">\(=
1\)</span>.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为<span class="math inline">\(0\)</span>或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4>
<h5><span id="合流超几何函数">合流超几何函数</span></h5>
<p>我们通常把形如<span class="math inline">\(M ( a ; b ; z ) = F \left (
\begin{array}{ r | } a \\ b\end{array} z \right ) = \sum_{ k \geq 0 }
\cfrac{ z^k a^{ \overline{ k } } }{ b^{ \overline{ k } } k !
}\)</span>的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r | } 1 \\
1
\end{array} z \right ) = e^z
\]</span></p>
<p>也即常见生成函数中的<span class="math inline">\(( 6 )\)</span>.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5>
<p>我们把形如<span class="math inline">\(F \left ( \begin{array}{ r | }
a , b \\ c\end{array} z \right ) = \sum_{ k \geq 0 } \cfrac{ z^k a^{
\overline{ k } } b^{ \overline{ k } } }{ c^{ \overline{ k } } k !
}\)</span>的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } 1 , 1 \\
1\end{array} z \right ) = \cfrac{ 1 }{ 1 - z }\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 1 )\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } - a , 1
\\ 1\end{array} - z \right ) = ( 1 + z )^a\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 2 )\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } a , 1 \\
1\end{array} z \right ) = \cfrac{ 1 }{ ( 1 - z )^a }\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 4 )\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } 1 , 1 \\
2\end{array} - z \right ) = \cfrac{ \ln ( 1 + z ) }{ z }\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 7 )\)</span>.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4>
<p>我们先考虑改写超几何级数的形式:</p>
<p><span class="math inline">\(F \left ( \begin{array}{ r | } a_1 , . .
. , a_m \\ b_1 , . . . , b_n\end{array} z \right ) = \sum_{ k \geq 0 }
t_k , t_k = \cfrac{ z^k \prod_{ i = 1 }^m a_i^{ \overline{ k } } }{ k !
\prod_{ i = 1 }^n b_i^{ \overline{ k } } }\)</span>.</p>
<p>不难发现<span class="math inline">\(t_0 = 1\)</span>,而:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ t_{ k + 1 } }{ t_k } &amp; = \cfrac{ z^{ k + 1 } }{ z^k }
\cfrac{ k ! }{ ( k + 1 ) ! } \cfrac{ \prod_{ i = 1 }^m a_i^{ \overline{
k + 1 } } }{ \prod_{ i = 1 }^m a_i^{ \overline{ k } } } \cfrac{ \prod_{
i = 1 }^n b_i^{ \overline{ k } } }{ \prod_{ i = 1 }^n b_i^{ \overline{ k
+ 1 } } } \\
&amp; = \cfrac{ \prod_{ i = 1 }^m ( k + a_i ) }{ \prod_{ i = 1 }^n ( k +
b_i ) } \cfrac{ z }{ k + 1 }
\end{aligned}
\]</span></p>
<p>换句话说,<span class="math inline">\(\cfrac{ t_{ k + 1 } }{ t_k
}\)</span>是关于<span class="math inline">\(k\)</span>的一个有理函数.而根据代数基本定理,任意<span class="math inline">\(k\)</span>的有理函数在<span class="math inline">\(\mathbb{ C
}\)</span>内都可以分解为以上的形式(如果缺少<span class="math inline">\(k
+ 1\)</span>项则需要上下同时乘以<span class="math inline">\(k +
1\)</span>以补上).</p>
<p>换句话说,对于一个无穷级数<span class="math inline">\(\sum_{ k \geq 0
} t_k\)</span>,我们先将<span class="math inline">\(\cfrac{ t_{ k + 1 }
}{ t_k }\)</span>表示回超几何函数,设为<span class="math inline">\(F\)</span>.</p>
<p>那么有:<span class="math inline">\(\sum_{ k \geq 0 } t_k = t_0
F\)</span>.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和<span class="math inline">\(\Gamma\)</span>函数的定义)来使这些公式全部成立.But
who
cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5>
<p>求证:<span class="math inline">\(\sum_{ k \leq n } \binom{ r + k }{ k
} = \binom{ r + n + 1 }{ n } \Leftrightarrow F \left ( \begin{array}{ r
| } 1 , - n \\ - n - r\end{array} 1 \right ) = \cfrac{ r + n + 1 }{ r +
1 } , n \in \mathbb{ N } \\\)</span>.</p>
<p>首先考虑:</p>
<p><span class="math display">\[
\sum_{ k \leq n } \binom{ r + k }{ k } = \sum_{ k \geq 0 } \binom{ r + n
- k }{ n - k }
\]</span></p>
<p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<p><span class="math display">\[
\binom{ r + n }{ n } F \left ( \begin{array}
{ r | } 1 , - n \\
- n - r
\end{array} 1 \right ) = \binom{ r + n + 1 }{ n }
\]</span></p>
<p>两边同时除以<span class="math inline">\(\binom{ r + n }{ n
}\)</span>得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5>
<p>通过范德蒙德卷积,不难验证:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r | } a , b \\
c
\end{array} 1 \right ) = \cfrac{ \Gamma ( c - a - b ) \Gamma ( c ) }{
\Gamma ( c - a ) \Gamma ( c - b ) } , - b \in \mathbb{ N }
\]</span></p>
<p>这个公式的一个特例是:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r | } a , - n \\
c
\end{array} 1 \right ) &amp; = \cfrac{ ( c - a )^{ \overline{ n } } }{
c^{ \overline{ n } } } = \cfrac{ ( a - c )^{ \underline{ n } } }{ ( - c
)^{ \underline{ n } } } , n \in \mathbb{ N } \\
\sum_{ k \geq 0 } \cfrac{ a^{ \overline{ k } } ( - n )^{ \overline{ k }
} }{ c^{ \overline{ k } } k ! } &amp; = \cfrac{ ( c - a )^{ \overline{ n
} } }{ c^{ \overline{ n } } } = \cfrac{ ( a - c )^{ \underline{ n } } }{
( - c )^{ \underline{ n } } } , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r | } a , b , - n \\
c , a + b - n - c + 1
\end{array} 1 \right ) &amp; = \cfrac{ ( c - a )^{ \overline{ n } } ( c
- b )^{ \overline{ n } } }{ c^{ \overline{ n } } ( c - a - b )^{
\overline{ n } } } = \cfrac{ ( a - c )^{ \underline{ n } } ( b - c )^{
\underline{ n } } }{ ( - c )^{ \underline{ n } } ( a + b - c )^{
\overline{ n } } } , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3>
<h4><span id="example1luogu4931">Example1(luogu4931)</span></h4>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans_k &amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \binom{ i }{ k }
\binom{ n }{ i } \binom{ n }{ i } i ! ( 2 n - 2 i ) ! 2^i \\
&amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \frac{ 1 }{ k ! ( i - k ) ! }
\frac{ n ! }{ ( n - i ) ! } \frac{ n ! }{ ( n - i ) ! } ( 2 n - 2 i ) !
2^i \\
&amp; = ( n ! )^2 \frac{ 2^k }{ k ! } \sum_{ i = k }^n ( - 1 )^{ i - k }
\frac{ 1 }{ ( i - k ) ! } \binom{ 2 n - 2 i }{ n - i } 2^{ i - k } \\
&amp; = ( n ! )^2 \frac{ 2^k }{ k ! } \sum_{ i = 0 }^{ n } \frac{ ( - 2
)^{ i } }{ i ! } \binom{ 2 n - 2 i }{ n - i }
\end{aligned}
\]</span></p>
<p>注意到后者只与<span class="math inline">\(n -
k\)</span>有关,不妨设其为<span class="math inline">\(f_{ n } = \sum_{ i
= 0 }^{ n } \frac{ ( - 2 )^{ i } }{ i ! } \binom{ 2 n - 2 i }{ n - i
}\)</span>,预处理一下就可以做到<span class="math inline">\(O ( n^2 + nT
)\)</span>.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! )^2 \frac{ 2^k }{ k ! } f_{ n - k } \\
f_{ n } &amp; = \sum_{ i = 0 }^{ n } \frac{ ( - 2 )^{ i } }{ i ! }
\binom{ 2 n - 2 i }{ n - i }
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(f\)</span>是一个卷积的形式,设其生成函数为<span class="math inline">\(F_n\)</span>,<span class="math inline">\(g_n =
\frac{ ( - 2 )^n }{ n ! } , h_n = \binom{ 2 n }{ n
}\)</span>,我们自然有<span class="math inline">\(F = GH\)</span>.</p>
<p>考虑<span class="math inline">\(G\)</span>和<span class="math inline">\(H\)</span>的生成函数形式,先看<span class="math inline">\(G\)</span>,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum_{ n \geq 0 } \frac{ ( - 2 x )^n }{ n ! } = e^{ - 2 x }
\]</span></p>
<p>再看<span class="math inline">\(H\)</span>,是卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac{ 1 }{ \sqrt{ 1 - 4 x } }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! )^2 \frac{ 2^k }{ k ! } [ x^{ n - k } ] \frac{ e^{ - 2 x } }{
\sqrt{ 1 - 4 x } }
\]</span></p>
<p>现在看<span class="math inline">\(F\)</span>,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F^2 = e^{ - 4 x }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e^{ - 4 x } \\
- 4 F^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F^2 \\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f_{ i + 1 } - 8 if_i &amp; = 16 f_{ i - 1 } \\
if_i &amp; = 4 ( i - 1 ) f_{ i - 1 } + 8 f_{ i - 2 }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3>
<h4><span id="求解递归关系">求解递归关系</span></h4>
<p>我们假设已经有了<span class="math inline">\(R ( z ) = \sum_{ k \geq 0
} g_k z^k\)</span>,并且<span class="math inline">\(R ( z ) = \cfrac{ P (
z ) }{ Q ( z ) }\)</span>,其中<span class="math inline">\(P ( z
)\)</span>和<span class="math inline">\(Q ( z
)\)</span>都是多项式,我们想要找到一种方式求解<span class="math inline">\([ z^n ] R ( z )\)</span>.</p>
<p>考虑有理函数<span class="math inline">\(S ( z ) = \sum_{ k = 1 }^m
\cfrac{ a_k }{ 1 - \rho_k z } \\\)</span>,不难发现<span class="math inline">\([ z^n ] S ( z ) = \sum_{ k = 1 }^m a_k \rho_k^n
\\\)</span>.</p>
<p>那么可以证明,只要<span class="math inline">\(Q ( z ) =
0\)</span>无重根并且无零根,那么就存在一组系数满足<span class="math inline">\(S ( z ) = R ( z )\)</span>.</p>
<p>我们这么定义”反射”运算,若<span class="math inline">\(Q ( z ) = \sum_{
k = 0 }^m q_k z^k \\\)</span>,则其反射多项式为<span class="math inline">\(Q^R ( z ) = \sum_{ k = 0 }^m q_k z^{ m - k }
\\\)</span>.</p>
<p>若<span class="math inline">\(Q ( z ) = q_0 \prod_{ k = 1 }^m ( 1 -
\rho_k z )\)</span>,则显然有<span class="math inline">\(Q^R ( z ) = q_0
\prod_{ k = 1 }^m ( z - \rho_k ) \\\)</span>.</p>
<p>那么显然这里求出来的这组数<span class="math inline">\(\rho\)</span>就是<span class="math inline">\(S ( z
)\)</span>中的那组<span class="math inline">\(\rho\)</span>.</p>
<p>而我们有<span class="math inline">\(a_k = \cfrac{ - \rho_k P (
\cfrac{ 1 }{ \rho_k } ) }{ Q &#39; ( \rho_k ) }\)</span>.</p>
<h4><span id="example1">Example1</span></h4>
<p>已知<span class="math inline">\(n ! = \sum_{ k } \binom{ n }{ k } g_{
n - k } , n \in \mathbb{ N } \\\)</span>,求<span class="math inline">\(g_n\)</span>.</p>
<p>首先两边同时除以<span class="math inline">\(n
!\)</span>并将组合数用阶乘形式展开,我们有:</p>
<p><span class="math display">\[
1 = \sum_{ k } \cfrac{ g_{ n - k } }{ k ! ( n - k ) ! } .
\]</span></p>
<p>如果我们令<span class="math inline">\(D ( z ) = \sum_{ k \geq 0 }
\cfrac{ g_{ k } }{ k ! } z^k\)</span>,则有:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ 1 }{ 1 - z } &amp; = e^z D ( z ) \\
D ( z ) &amp; = \cfrac{ 1 }{ 1 - z } e^{ - z } \\
D ( z ) &amp; = ( \sum_{ k \geq 0 } z^k ) ( \sum_{ k \geq 0 } ( - 1 )^k
\cfrac{ z^k }{ k ! } ) \\
[ z^n ] D ( z ) &amp; = \sum_{ k = 0 }^n \cfrac{ ( - 1 )^k }{ k ! }
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(g_n = n ! \sum_{ k = 0 }^n \cfrac{ (
- 1 )^k }{ k ! } \\\)</span>.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4>
<p>首先设<span class="math inline">\(F_i ( x )\)</span>为第<span class="math inline">\(i\)</span>家的生成函数,这个是显然可以快速预处理出来的.令<span class="math inline">\(M = 520\)</span>.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有<span class="math inline">\(n\)</span>个多项式,最高次数是<span class="math inline">\(M\)</span>,因此一共要插入<span class="math inline">\(nM\)</span>个值,又要处理每个后缀,复杂度来到<span class="math inline">\(O ( n^2 M^3
)\)</span>.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到<span class="math inline">\(O ( n^2 M^2 )\)</span>.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到<span class="math inline">\(O ( n^2 Mq )\)</span>.但<span class="math inline">\(n\)</span>如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下<span class="math inline">\(2^n\)</span>的答案,复杂度来到<span class="math inline">\(O ( nM 2^n q
)\)</span>.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到<span class="math inline">\(O ( \frac{ n }{ B } B 2^B MnM
)\)</span>,单次询问复杂度来到<span class="math inline">\(O ( \frac{ n }{
B } Mnq
)\)</span>.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以<span class="math inline">\(k\)</span>要大于<span class="math inline">\(m\)</span>,就直接输出<span class="math inline">\(0\)</span>.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要<span class="math inline">\(O ( ( nM )^2 q
)\)</span>的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到<span class="math inline">\(O ( nMq )\)</span>.</p>
<h4><span id="example3十二省联考-2019皮配">Example3([十二省联考 2019]
皮配)</span></h4>
<p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为<span class="math inline">\(xy , y , x ,
1\)</span>,这样最后判断幂在一个区间内的<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是<span class="math inline">\(\prod ( x^{ s_i } y^{ s_i } + x^{ s_i } ) + \prod
( y^{ s_i } + 1 ) = ( \prod ( x^{ s_i } + 1 ) ) ( \prod ( y^{ s_i } + 1
) )\)</span>.也就是<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于<span class="math inline">\(O ( mk^2 s )\)</span>.最后两部分合并一下.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" class="post-title-link" itemprop="url">图论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="约定">约定</span></h3>
<p><span class="math inline">\(K_n\)</span>为<span class="math inline">\(n\)</span>个点的完全图</p>
<h3><span id="树的性质">树的性质</span></h3>
<h5><span id="example1hdu6035colorfultree">Example1([HDU6035]Colorful
Tree)</span></h5>
<p>考虑每种颜色的贡献,一种颜色的贡献显然是删去所有这个颜色的边后,剩下的联通块之间的路径.</p>
<h5><span id="example22022qbxt国庆day1tree">Example2([2022qbxt国庆Day1]tree)</span></h5>
<p>首先考虑分开处理每个点,在做每个点的时候假设它的所有子节点全部已经满足条件了,最终我们再通过计算组合数的方式计算即可.</p>
<p>那么最后,我们需要对于每个点进行处理,假设我们已知这个子树的集合是<span class="math inline">\(S\)</span>,那么我们需要用容斥计算如果当前子树集合是<span class="math inline">\(S\)</span>的子集的情况,不难发现容斥式子:</p>
<p><span class="math display">\[
ans = \sum_{ k = \max \{ f_v | x \rightarrow v \} }^{ f_x } ( - 1 )^{
f_x - k } k \binom{ f_x }{ k } \sum_{ x \rightarrow v } \binom{ k }{ f_v
}
\]</span></p>
<p>其实也就是个二项式反演的形式.</p>
<p>这题还需要一些技巧优化,我们首先发现由于<span class="math inline">\(f_v\)</span>有可能有重复的,我们可以提前把重复的<span class="math inline">\(f_v\)</span>压缩到一起再用快速幂求,于是后面的部分最多不过<span class="math inline">\(\sqrt{ n
}\)</span>级别.而前面是一个类似于树上启发式合并的东西,于是复杂度<span class="math inline">\(O ( n \sqrt{ n } \log n )\)</span>.</p>
<h5><span id="example3cf1628egroceries-in-meteor-town">Example3(CF1628E
Groceries in Meteor Town)</span></h5>
<p>因为要求路径最大值,所以先建Kruskal重构树.然后问题转化为求一个点和一群白点的LCA是谁.</p>
<p>树上多点LCA有个经典性质:也就相当于其中<span class="math inline">\(dfn\)</span>序最大的和最小的两个点的LCA.</p>
<p>至于区间覆盖可以用线段树.</p>
<h5><span id="example4loj3692">Example4(loj3692)</span></h5>
<p>注意到<span class="math inline">\(D\)</span>很小.</p>
<p>我们考虑处理邻域乘,设<span class="math inline">\(f_{ x , i
}\)</span>表示<span class="math inline">\(x\)</span>的<span class="math inline">\(i\)</span>级儿子需要乘上的答案.每次修改时,先将<span class="math inline">\(f_{ x , D }\)</span>和<span class="math inline">\(f_{ x , D - 1 }\)</span>乘上<span class="math inline">\(W\)</span>,然后令<span class="math inline">\(x =
fa_x\)</span>,<span class="math inline">\(D = D -
2\)</span>,继续此操作直到<span class="math inline">\(D\)</span>为<span class="math inline">\(0\)</span>.</p>
<p>然后询问的时候直接暴力跳<span class="math inline">\(D\)</span>层父亲找答案,不难发现这样做是对的.</p>
<p>同样的思路可以脱离点分治处理很多邻域问题.</p>
<h4><span id="树的直径">树的直径</span></h4>
<ol type="1">
<li><p>定义:树中最长的一条简单路径.</p></li>
<li><p>树的直径可能有多个.</p></li>
<li><p>直径的两个端点一定是两个叶子节点.</p></li>
<li><p>如果树有多条直径,树的不同的直径的中点/中边一定是相同的.</p></li>
<li><p>到一个点距离最远的点一定是直径的一个端点.</p></li>
<li><p>对于两棵树,如果第一棵树直径两端点为<span class="math inline">\((
u , v )\)</span>,第二棵树直径两端点为<span class="math inline">\(( x , y
)\)</span>,用一条边将两棵树连接,那么新树的直径一定是<span class="math inline">\(u , v , x , y\)</span>中的两个点.</p></li>
</ol>
<p>上述的证明大都是考虑反证法:如果不成立,则一定存在一条更长的直径.</p>
<h5><span id="example1sdoi2013直径">Example1([SDOI2013]直径)</span></h5>
<p>有一个做法是:考虑找到直径的中点/中边,找到它到两边的最远距离的点,显然两边的点分别的以中点/中边的两个端点为根的LCA中间的部分就是一定会被包含的边.</p>
<h4><span id="树的重心">树的重心</span></h4>
<ol type="1">
<li><p>定义:树的重心是删去后所有剩余子树大小最大值最小的点.</p></li>
<li><p>树的重心是删去后所有剩余子树大小全部小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>的点.</p></li>
<li><p>树的重心只有可能有一个或两个.</p></li>
<li><p>如果树有两个重心,那么这两个重心相邻.</p></li>
<li><p>树的重心是所有点到其距离之和最小的点.</p></li>
<li><p>把一个树添加或删除一个叶子,那么它的重心最多只移动一条边的距离.</p></li>
<li><p>把两个树通过一条边相连得到一个新的树,那么新的树的重心在连接原来两个树的重心的路径上.</p></li>
</ol>
<p>(2)的证明如下:</p>
<p>如果重心是<span class="math inline">\(u\)</span>,且删去<span class="math inline">\(u\)</span>后剩余最大子树大小大于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,设这棵子树中与<span class="math inline">\(u\)</span>相邻的点为<span class="math inline">\(v\)</span>,则我们删去<span class="math inline">\(v\)</span>后,最大子树大小一定会减少,不满足假设,所以(2)得证.</p>
<p>另外,如果一个点删去后所有剩余子树大小全部小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,那它也一定是重心.因为不存在除了重心以外的满足条件的点:考虑调整法,与重心相邻的点一定都不满足条件,因为它们的子树大小全都小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,移动后最大子树一定不小于<span class="math inline">\(n -
\lfloor \cfrac{ n }{ 2 } \rfloor\)</span>.</p>
<p>(3)(4)的证明如下:</p>
<p>首先证明:如果有两个点都是重心,那它们一定相邻.</p>
<p>考虑如果二者不相邻,那删去它们后剩下的最大子树大小一定相等,设这两个点分别为<span class="math inline">\(x , y\)</span>,那删去<span class="math inline">\(x\)</span>后,剩下的最大子树一定包含了<span class="math inline">\(y\)</span>,而这个子树的大小一定小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>.那删去<span class="math inline">\(y\)</span>后,剩下的最大子树大小必定大于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,一定不合法.</p>
<p>而树上不可能有超过两个点两两相邻,于是最多只有两个重心,且它们一定相邻.</p>
<p>(5)的证明如下:</p>
<p>考虑如果<span class="math inline">\(u\)</span>是树的重心,我们看能不能将<span class="math inline">\(u\)</span>调整到另一个点使得所有点到其距离之和更小.</p>
<p>由于调整是一步一步做的,显然只需要判断所有和<span class="math inline">\(u\)</span>相邻的点是否符合条件即可.设这个点为<span class="math inline">\(x\)</span>,那我们把<span class="math inline">\(u\)</span>改为<span class="math inline">\(x\)</span>,会使答案减小<span class="math inline">\(siz_x\)</span>,增加<span class="math inline">\(n -
siz_x\)</span>,由于<span class="math inline">\(siz_x \leq \lfloor
\cfrac{ n }{ 2 } \rfloor\)</span>,所以这么做一定不优.</p>
<p>(6)的证明如下:</p>
<p>首先,如果加入一个叶子节点后,各个子树大小仍然都<span class="math inline">\(&lt; \lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,那显然不必调整.</p>
<p>不然,显然是往叶子节点移动一格或者加入一个相邻的重心.</p>
<p>(7)的证明如下:</p>
<p>不妨设两棵树大小分别为<span class="math inline">\(siz_a \leq
siz_b\)</span>,然后令相连的两个点是这两棵树的根.</p>
<p>对于<span class="math inline">\(b\)</span>中的重心,肯定是会往根跳,并且不可能跳出<span class="math inline">\(b\)</span>原本的树.</p>
<h5><span id="example1csp-s2019树的重心">Example1([CSP-S2019]树的重心)</span></h5>
<p>首先取重心<span class="math inline">\(rt\)</span>为根,如果有两个就随便取一个.</p>
<p>接下来我们考虑对于每个点<span class="math inline">\(x\)</span>,它在什么情况下会成为重心.首先,删掉的边不可能在<span class="math inline">\(x\)</span>的子树内,不然一定不可能取到<span class="math inline">\(x\)</span>的.然后,我们假设删掉的子树大小为<span class="math inline">\(S\)</span>,<span class="math inline">\(x\)</span>的子树内最大的一个子树大小为<span class="math inline">\(g_x\)</span>,那么根据重心的性质有:</p>
$$
<span class="math display">\[\begin{aligned}
2 ( n - S - siz_x ) &amp; \leq n - S \\
2 g_x &amp; \leq n - S \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理得到:</p>
<p><span class="math display">\[
2 g_x \leq n - S \leq 2 siz_x
\]</span></p>
<p>考虑这个怎么计算:如果没有删边必须在<span class="math inline">\(x\)</span>子树外的限制,那显然可以直接遍历一遍存下<span class="math inline">\(n -
S\)</span>,然后统一使用值域树状数组做.而我们接下来考虑删去<span class="math inline">\(x\)</span>子树内的贡献,类似colorful
tree的做法,每次dfs到一个点,记录下来当前树状数组的答案,然后dfs子树,回溯时拿新答案减去旧答案就是子树内的答案.</p>
<p>接下来我们需要考虑<span class="math inline">\(x =
rt\)</span>怎么做.</p>
<p>考虑<span class="math inline">\(x\)</span>的子树中最大的那个和次大的那个,如果我们删去的节点不在最大的子树中,那只需要保证最大的子树大小满足条件;不然,只需保证次大的子树大小满足条件,也是好维护的.</p>
<h4><span id="树的结构的维护">树的结构的维护</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定一棵树,树上点有点权<span class="math inline">\(val\)</span>.现在有一个值<span class="math inline">\(sum\)</span>,初始为<span class="math inline">\(0\)</span>.从<span class="math inline">\(1\)</span>号点出发,每第一次到一个点<span class="math inline">\(u\)</span>,就会使<span class="math inline">\(sum +
= val_u\)</span>.求在时刻保证<span class="math inline">\(sum \geq
0\)</span>的前提下,<span class="math inline">\(sum\)</span>最终的最大值.</p>
<p>首先注意到为了保证<span class="math inline">\(sum \geq
0\)</span>这个性质,一个节点应该有两个值:<span class="math inline">\(lim\)</span>表示能走到这个点所需要的最小的<span class="math inline">\(sum\)</span>,<span class="math inline">\(val\)</span>表示到了这个点后能获得的价值.显然如果<span class="math inline">\(val \leq 0\)</span>则无意义.</p>
<p>如果我们能一开始处理出根的所有儿子的<span class="math inline">\(lim\)</span>和<span class="math inline">\(val\)</span>,我们就可以使用先走<span class="math inline">\(lim\)</span>小的点,并不断累计<span class="math inline">\(sum\)</span>的方式做.</p>
<p>所以考虑不断向上合并信息.不难发现此时一个点要处理出多对<span class="math inline">\(( lim , val
)\)</span>.考虑用一个左偏树维护这个东西.</p>
<p>但是,我们还需要保证不能跳着选点.也就是说我们要保证选中一个点,这个点的父亲必须选,怎么办呢?</p>
<p>一个方式是,我们把排序方法从只看<span class="math inline">\(lim\)</span>变成先判是否存在祖先后代关系,再判断<span class="math inline">\(lim\)</span>.</p>
<p>另一个方式是,我们每次直接把当前子树根节点扔到堆顶.但是需要满足堆的性质.不难发现如果这个点<span class="math inline">\(val &lt; 0\)</span>,我们可以将它与下面的<span class="math inline">\(lim\)</span>最的节点合并直到这个点<span class="math inline">\(val \geq 0\)</span>.而如果这个点的<span class="math inline">\(lim\)</span>太大,我们同样可以合并.注意到这样我们采取了一种很聪明的方式维护了树的形态.</p>
<h4><span id="dfs树的性质">dfs树的性质</span></h4>
<h5><span id="example1cf1361ejames-andthe-chase">Example1([CF1361E]James and
the Chase)</span></h5>
<p>如何判断一个点是否是好的呢?首先,如果要求是任意路径,那一个点是好的当且仅当它是一个叶向有根树的根.</p>
<p>现在要求是简单路径,那也就是说如果走了重复点是可以忽略的,这也就是说这个叶向有根树可以有反走边,而显然不能有横插边.不难发现这是充要条件.</p>
<p>另一个问题是:如何快速判断一个点是否满足上述条件呢?首先我们求出以一个好的点为根的dfs树(随机选取一定数量的点,如果一个都不是好点直接输出<span class="math inline">\(- 1\)</span>),然后我们发现:一个点<span class="math inline">\(u\)</span>是好的必要条件是它的子树内只有一条反走边,证明显然.假设<span class="math inline">\(u\)</span>通过这条反走边走到了点<span class="math inline">\(v\)</span>,那么<span class="math inline">\(u\)</span>是好的点当且仅当<span class="math inline">\(v\)</span>也是好的点.</p>
<p>这是为啥呢?首先,因为我们是以一个好点为根跑的dfs树,所以<span class="math inline">\(u\)</span>走到子树内的点必定只有一种方式.那子树外的点呢?走到<span class="math inline">\(v\)</span>后,显然就要从它走到其它点,而它到<span class="math inline">\(u\)</span>的子树内显然只有一种方案,那如果<span class="math inline">\(v\)</span>到其它点也只有一种方案,那么根据<span class="math inline">\(u \rightarrow v\)</span>这条路径,<span class="math inline">\(u\)</span>显然也是好点.</p>
<h5><span id="example2loj-6276">Example2(Loj 6276)</span></h5>
<p>找到所有颜色相同的点对<span class="math inline">\(( x , y
)\)</span>,经过它们的路径都不合法,显然经过它们的路径可以用dfs序刻画成矩阵,最后要求矩阵面积并.</p>
<h3><span id="圆方树的性质">圆方树的性质</span></h3>
<ol type="1">
<li><p>对于任意的非空无向图<span class="math inline">\(G\)</span>,一定存在一个<span class="math inline">\(G\)</span>的点双连通分量<span class="math inline">\(B\)</span>,使得<span class="math inline">\(B\)</span>中只有不超过<span class="math inline">\(1\)</span>个节点是<span class="math inline">\(G\)</span>的割点.其中,若<span class="math inline">\(B\)</span>中没有<span class="math inline">\(G\)</span>的割点,则有<span class="math inline">\(B
= G\)</span>.</p></li>
<li><p>若一个点双连通分量不为<span class="math inline">\(K_2\)</span>,则该点双连通分量中至少有一个简单环.</p></li>
<li><p>在仙人掌上的每个点双连通分量要么是<span class="math inline">\(K_2\)</span>,要么是一个简单环.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双连通分量中的任意一个点<span class="math inline">\(u\)</span>,一定存在一个简单环<span class="math inline">\(C\)</span>使得<span class="math inline">\(u\)</span>在<span class="math inline">\(C\)</span>上.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双连通分量中的任意两个点<span class="math inline">\(u , v\)</span>,一定存在一个简单环<span class="math inline">\(C\)</span>使得<span class="math inline">\(u ,
v\)</span>在<span class="math inline">\(C\)</span>上.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双,任给一点<span class="math inline">\(x\)</span>和一边<span class="math inline">\(e\)</span>,一定存在经过<span class="math inline">\(x , e\)</span>的简单环.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双,任给两点<span class="math inline">\(s , t\)</span>和一边<span class="math inline">\(e\)</span>,一定存在一条<span class="math inline">\(s - e - t\)</span>的简单路径.</p></li>
</ol>
<p>(6)的证明非常变魔术,你考虑把<span class="math inline">\(e : u
\leftrightarrow v\)</span>这条边给改成<span class="math inline">\(u
\leftrightarrow w \leftrightarrow v\)</span>,然后<span class="math inline">\(w\)</span>和<span class="math inline">\(x\)</span>在一个简单环上,意味着<span class="math inline">\(u , w , v , x\)</span>在一个简单环上.</p>
<p>(7)考虑(6)就行,先找到<span class="math inline">\(s\)</span>和<span class="math inline">\(e\)</span>所在的简单环,然后从这个环上连到<span class="math inline">\(t\)</span>.</p>
<h3><span id="任意图的性质">任意图的性质</span></h3>
<ol type="1">
<li>若一张无向连通图<span class="math inline">\(G\)</span>中存在<span class="math inline">\(3\)</span>个不同的一度点<span class="math inline">\(x , y , z\)</span>,则一定存在一个点<span class="math inline">\(u \notin \{ x , y , z \}\)</span>使得存在<span class="math inline">\(3\)</span>条两两没有公共边的简单路径满足其中一个端点均为<span class="math inline">\(u\)</span> 且另一个端点分别为<span class="math inline">\(x , y ,
z\)</span>.(证明考虑求生成树后讨论LCA)</li>
</ol>
<h3><span id="dsu-on-tree">dsu on tree</span></h3>
<h5><span id="exampleqoj5020">Example(QOJ5020)</span></h5>
<p>我们考虑树链剖分,这样将问题转化为三部分:</p>
<ol type="1">
<li><p>对于某个点而言,到它距离<span class="math inline">\(\leq
d\)</span>的点数量.这个问题可以使用点分治解决.</p></li>
<li><p>对于某条重链的上半部分而言,它连接的所有轻子树中,到它距离<span class="math inline">\(\leq d\)</span>的点数量.这个问题直接dsu on
tree.</p></li>
<li><p>对于某个点而言,在它子树内到它距离<span class="math inline">\(\leq
d\)</span>的点数量.这个问题也可以直接dsu on tree.</p></li>
</ol>
<p>为什么转化为三个部分就能求解呢?我们考虑一条链<span class="math inline">\(u \rightarrow w \rightarrow v\)</span>,其中<span class="math inline">\(w\)</span>是这条链上深度最浅的点.那么首先我们统计在<span class="math inline">\(w\)</span>子树外的,这一个部分可以由(1)和(3)做差求出来.然后我们要求的就是在<span class="math inline">\(w\)</span>子树内,到这条链的距离<span class="math inline">\(\leq
d\)</span>的点的数量.这个怎么求呢?我们考虑差分,求一下<span class="math inline">\(1 \rightarrow u\)</span>和<span class="math inline">\(1 \rightarrow
w\)</span>的答案然后做差.这样我们对这条到根的路径重链剖分,只需要处理重链的上半部分以及两条重链的连接处.不难发现两条重链的连接处会被多算一次,拿(3)减一下就好.以及这条路径所叉出去的重儿子也需要用(3).</p>
<p>现在的问题在于怎么求(2)和(3),先考虑(2),我们对于每一条重链从顶端走到低端不断地加入轻儿子,然后维护BIT就行.(3)是类似的,只不过是需要从底端走到顶端.</p>
<p>注意如果把重儿子和轻儿子分开处理,那么可能会在一些奇怪的地方算重,解决方法是特判<span class="math inline">\(w\)</span>处的答案,然后拆成两条互相之间完全没有影响的链,当然这也有可能会发生跳重链的时候轻儿子算重的情况,同样需要判断一下.</p>
<h3><span id="最小生成树">最小生成树</span></h3>
<h5><span id="example1cf1550f-jumpingaround">Example1(CF1550F Jumping
Around)</span></h5>
<p>首先考虑离线.注意到每次肯定跳到一个自己能跳到的点,而这个点应该是所需灵活度最小的点.</p>
<p>考虑boruvka算法,建立最小生成树并判断.</p>
<h3><span id="kruskal重构树">Kruskal重构树</span></h3>
<p>最小生成树时,每一次加边的时候把那个边变成虚点,两个点连到这条边上.任意两个点的LCA就是它们路径上的最小边权.</p>
<h3><span id="最短路">最短路</span></h3>
<h5><span id="example1cf1753d-the-beach">Example1(CF1753D The Beach)</span></h5>
<p>首先,自然的想法是把格子图黑白染色.</p>
<p>然后,我们注意到一个床是不可能被移动两次及以上的.因为如果是横着动两次,那不动自然就有一对空位置了;如果是转两次,考虑转的目的一定是为了空出某个位置或某两个位置(不可能为了空出三个位置,显然这么做很闲),一次操作足矣;如果是动一次转一次也是一样的,要么转的很闲要么原本就存在这么一对空位置.</p>
<p>我们再进行一步转化,考虑把动床改为动格子.换句话说,每个格子可以通过一定的代价移动到和它相邻的床的与它不相邻的那个位置上.注意到移动格子的过程只会把黑格子移动到黑格子,白格子移动到白格子.</p>
<p>于是建立超级源点跑两边最短路,枚举最后床放在哪里即可.不过这里有一点是一个床有没有可能被黑白最短路同时跑了一遍,是有可能的,但这么跑一定不优秀,不可能是最小答案.</p>
<h5><span id="example2cf843ddynamicshortest-path">Example2([CF843D]Dynamic
Shortest Path)</span></h5>
<p>注意到<span class="math inline">\(O ( nq
)\)</span>能过.而且每次修改只是对于若干条边<span class="math inline">\(+
1\)</span>,自然想到每次修改完后跑01bfs.</p>
<p>但是怎么跑呢?注意到维护每个点最短路的增量,并且在路径的增量上跑01bfs,自然可求.</p>
<h5><span id="example3同余最短路luogup2371墨墨的等式">Example3
同余最短路([luoguP2371]墨墨的等式)</span></h5>
<p>因为<span class="math inline">\(a_i\)</span>无序,假设<span class="math inline">\(a_1\)</span>最小,那么所有的数字都可以按<span class="math inline">\(\mod a_1\)</span>的结果分成<span class="math inline">\(a_1\)</span>类.我们按照余数设置<span class="math inline">\(a_1\)</span>个点,编号为<span class="math inline">\(0\)</span>至<span class="math inline">\(a_1 -
1\)</span>.</p>
<p>设<span class="math inline">\(dis_i\)</span>为所有能组成的数中且<span class="math inline">\(\mod a_1\)</span>余数为<span class="math inline">\(i\)</span>的最小数.那么,所有能表示出来的<span class="math inline">\(\bmod a_1\)</span>余数为<span class="math inline">\(i\)</span>的数都可以写作<span class="math inline">\(dis_i + k \times a_1 , k \in \mathbb{ N
}\)</span>的形式,求得<span class="math inline">\(dis_i\)</span>后可以很轻易算出.</p>
<p>那么怎么求<span class="math inline">\(dis_i\)</span>呢?我们考虑:对于任意一个数<span class="math inline">\(k\)</span>,它可以怎么得到.注意到如果<span class="math inline">\(k - a_j\)</span>(其中<span class="math inline">\(i
\ne j\)</span>)可行,那么<span class="math inline">\(k\)</span>一定可行.自然有:<span class="math inline">\(dis_i = \min \{ dis_j + a_k | 0 \leq j &lt; a_i ,
k \ne i \}\)</span>.</p>
<p>这显然是一个最短路问题.</p>
<h3><span id="差分约束">差分约束</span></h3>
<h5><span id="example1agc056c-01balanced">Example1([AGC056C] 01
Balanced)</span></h5>
<p>将<span class="math inline">\(1\)</span>看成<span class="math inline">\(- 1\)</span>,<span class="math inline">\(0\)</span>看成<span class="math inline">\(+
1\)</span>,不难发现字典序最小也就是让前缀和序列字典序最小,并且有<span class="math inline">\(sum_{ r_i } = sum_{ l_i - 1 }\)</span>以及<span class="math inline">\(- 1 \leq sum_{ i } - sum_{ i - 1 } \leq
1\)</span>,然后做<span class="math inline">\(01\)</span>bfs跑最短路,显然最短路可以保证每个<span class="math inline">\(sum\)</span>都尽可能小.</p>
<p>然后另一个问题在于这玩意为啥不会让<span class="math inline">\(sum_i =
sum_{ i - 1 }\)</span>,这个建图后观察一下就知道不会发生这种情况.</p>
<h3><span id="2-sat">2-SAT</span></h3>
<h5><span id="example1cf1697f">Example1(CF1697F)</span></h5>
<p>对每个点建立<span class="math inline">\(k\)</span>对点表示<span class="math inline">\(a_i \geq x\)</span>和<span class="math inline">\(a_i &lt; x\)</span>,就能做了.</p>
<h5><span id="example22021集训队互测-序列">Example2(2021集训队互测 序列)</span></h5>
<p>注意到如果<span class="math inline">\(a_i &lt; x\)</span>,那么<span class="math inline">\(a_j \geq x \land a_k \geq
x\)</span>,这样就可以刻画所有的条件.</p>
<p>而且一定可以刻画所有的条件.</p>
<h3><span id="对偶图">对偶图</span></h3>
<h5><span id="example1csp-s-2021交通规划">Example1([CSP-S 2021]
交通规划)</span></h5>
<p>先考虑如果附加点的颜色全都相同,那肯定输出<span class="math inline">\(0\)</span>即可.</p>
<p>考虑附加点的数量为<span class="math inline">\(2\)</span>的时候,那显然最优情况需要将整个图分成各自联通的两部分,一部分染成黑色,一部分染成白色.可以发现这就是一个对偶图.</p>
<p>而如果附加点的数量很多怎么做呢?稍微思考一下</p>
<h3><span id="广义串并联图三度化">广义串并联图/三度化</span></h3>
<h4><span id="定义">定义</span></h4>
<p>定义:不存在<span class="math inline">\(4\)</span>个点使得任意两点之间存在一条简单路径,且这六条路径不在<span class="math inline">\(4\)</span>个点之外的地方相交.</p>
<h4><span id="删一度点">删一度点</span></h4>
<p>经典问题引入:树上带权最大独立集.</p>
<p>首先dp是可以实现的,我们考虑是否存在贪心算法.</p>
<p>首先,如果不带权,我们显然可以每次选取一度点或零度点,并删去所有相连的点.这样做显然是最优的.</p>
<p>但怎么做带权的方法呢?我们注意到可以先删掉所有负点权的点,然后可以加入剩下的所有零度点.</p>
<p>那么对于一度点呢?对于一个一度点<span class="math inline">\(u\)</span>和它的相邻点<span class="math inline">\(v\)</span>,我们不能盲目选<span class="math inline">\(u\)</span>的原因是可能选取<span class="math inline">\(v\)</span>会更优秀.考虑做一个带悔贪心,我们先把<span class="math inline">\(u\)</span>选上,然后把<span class="math inline">\(v\)</span>的权值设为<span class="math inline">\(val_v - val_u\)</span>,相当于我们仍然可以选<span class="math inline">\(v\)</span>,但是要花费<span class="math inline">\(val_u\)</span>的代价把<span class="math inline">\(u\)</span>删去.</p>
<p>我们把类似这样的操作称为<strong>删一度点</strong>.</p>
<h4><span id="缩二度点">缩二度点</span></h4>
<p>问题引入:给定一个仙人掌,每个点可以染色为<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>,<span class="math inline">\(u\)</span>节点染成<span class="math inline">\(0\)</span>会有<span class="math inline">\(b_u\)</span>的贡献,不然有<span class="math inline">\(w_u\)</span>的贡献.若一条边<span class="math inline">\(e\)</span>相邻的两点颜色相同则有<span class="math inline">\(s_e\)</span>的贡献,不然有<span class="math inline">\(d_e\)</span>的贡献,求最大答案.</p>
<p>首先如果有一度点和零度点,我们仍然可以使用删一度点的操作.</p>
<p>如果没有,考虑仙人掌上的一个点双一定是一个简单环.而且一定存在一个点双<span class="math inline">\(B\)</span>满足<span class="math inline">\(B\)</span>只包含一个割点.</p>
<p>那么对于这个点双上的一个非割点<span class="math inline">\(x\)</span>以及和它相邻的两个点<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>,我们考虑<span class="math inline">\(x\)</span>的染色有可能改变<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的答案,那么怎么办呢?</p>
<p>冷静思考一下,我们想办法把<span class="math inline">\(x\)</span>给删掉.简单来说,我们把<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>之间连一条边权为<span class="math inline">\([ w_{ 0 , 0 } , w_{ 0 , 1 } , w_{ 1 , 0 } , w_{ 1
, 1 } ]\)</span>的边,分别表示<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的染色为以上四种情况时这条边(也就是原本的<span class="math inline">\(x\)</span>)的最大贡献是什么,这显然可以通过讨论<span class="math inline">\(x\)</span>的取值而求得.这样初始边权实际上就是<span class="math inline">\([ s , d , d , s
]\)</span>,于是我们就可以删掉一个二度点并连起来与它相邻的两个点,我们把类似这样的操作称为<strong>缩二度点</strong>.</p>
<h4><span id="叠合重边">叠合重边</span></h4>
<p>注意到使用缩二度点的时候,会把一个三元环缩成两个点及链接它们的两条重边,但是我们可以直接把重边合起来,我们把类似这样的操作称为<strong>叠合重边</strong>.</p>
<h4><span id="正确性证明">正确性证明</span></h4>
<p>接下来我们证明:任何广义串并联图都可以通过以上三种操作缩为一个点.</p>
<h5><span id="引理1">引理1</span></h5>
<p>对于一个无向图<span class="math inline">\(G\)</span>,若进行若干次删一度点操作,缩<span class="math inline">\(2\)</span>度点操作以及叠合重边操作后得到的图不是广义串并联图,那么<span class="math inline">\(G\)</span>也不是广义串并联图.</p>
<p>考虑用逆操作还原原图.删一度点的逆操作是加入一个点,叠合重边的逆操作是将一条边变成两条边,这两个操作显然不会使一个不是广义串并联图的图变成广义串并联图.接下来考虑缩二度点的逆操作:删掉一条边<span class="math inline">\(( u , v )\)</span>并加入一个点<span class="math inline">\(w\)</span>和两条边<span class="math inline">\(( u
, w )\)</span>和<span class="math inline">\(( w , v )\)</span>.</p>
<p>由于这个图不是广义串并联图,所以一定存在一组反例点<span class="math inline">\(\{ a , b , c , d
\}\)</span>.如果我们删掉的边不在作为反例的六条边上,那显然不影响;如果在,由于新加入的两条边仍然可以作为路径,所以也不影响.</p>
<p>于是引理得证.</p>
<h5><span id="引理2">引理2</span></h5>
<p>任意一张所有点的度数都大于等于<span class="math inline">\(3\)</span>的简单无向连通图,一定不是广义串并联图.</p>
<p>这个引理的严格证明有些麻烦.我们冷静一下,一个四个点的完全图满足以上条件且不是广义串并联图.而其他的图感性理解一下应该可以通过缩路径的方式变成一个四个点的完全图.</p>
<p>结合引理1,我们得知任意一个操作后不能变成单个节点的图的无向连通图不是广义串并联图.</p>
<h5><span id="引理3">引理3</span></h5>
<p>任意一个满足<span class="math inline">\(m \leq n +
k\)</span>的图,通过删一度点,缩二度点,叠合重边操作后,<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都会到达一个<span class="math inline">\(O ( k )\)</span>的量级.</p>
<p>考虑缩完点后,所有点的度数<span class="math inline">\(\geq
3\)</span>,于是有<span class="math inline">\(2 m \geq 3
n\)</span>,而在操作过程中,<span class="math inline">\(m -
n\)</span>的值显然是不增的,于是有<span class="math inline">\(m - n \leq
k\)</span>,解一下方程得到<span class="math inline">\(n \leq 2 k , m \leq
3 k\)</span>.</p>
<h4><span id="example122zr提高十连测day6摆件">Example1(22zr提高十连测day6摆件)</span></h4>
<p>首先考虑颜色之间没啥区别,所以对于一棵树来说,朴素的dp是可以的.</p>
<p>简单来说,设<span class="math inline">\(dp_i\)</span>表示第<span class="math inline">\(i\)</span>棵子树的答案.合并的时候考虑设<span class="math inline">\(f_v = \cfrac{ 1 }{ k } dp_v sam_e + \cfrac{ k - 1
}{ k } dp_v dif_e\)</span>,自然有<span class="math inline">\(dp_u =
\prod_{ u \rightarrow v } f_v \\\)</span>.</p>
<p>接下来考虑先随便找一棵生成树,然后暴力枚举多余的反走边的深度较低的叶子节点的颜色,再进行dp即可.</p>
<p>另外也可以缩点后做,不过对于这题没啥区别.</p>
<h4><span id="example2joi-open-2022放学路">Example2([JOI Open 2022]
放学路)</span></h4>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>在一个点双中,我们找到两个点<span class="math inline">\(u , v\)</span>,使得<span class="math inline">\(u
\rightarrow v\)</span>,并且<span class="math inline">\(u\)</span>的出度至少是<span class="math inline">\(2\)</span>,<span class="math inline">\(v\)</span>的入度至少是<span class="math inline">\(2\)</span>,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为<span class="math inline">\(2\)</span>的点<span class="math inline">\(v\)</span>,找到它的入点<span class="math inline">\(u\)</span>,如果<span class="math inline">\(u\)</span>的出度不是<span class="math inline">\(2\)</span>,那么<span class="math inline">\(u\)</span>也是一个入度至少为<span class="math inline">\(2\)</span>的点.这样往前推一定至少能推到一个点(因为不可能<span class="math inline">\(S\)</span>贡献了俩入度).</p>
<p>如何保证<span class="math inline">\(S ,
T\)</span>在一个点双中呢?其实只需要添加一条边<span class="math inline">\(( S , T , dis_{ S \rightarrow T }
)\)</span>就行了.显然加了后不会对答案产生影响.然后不在<span class="math inline">\(S , T\)</span>这个边双内的点也没有用了.</p>
<h3><span id="点分治">点分治</span></h3>
<h5><span id="example1cfgym101002k">Example1(CFgym101002K)</span></h5>
<p>点分治,假设当前分治重心是<span class="math inline">\(g\)</span>,将每个数缩成一个二元组<span class="math inline">\(( w_i , d_i )\)</span>,所求就是<span class="math inline">\(w_i w_j + d_i +
d_j\)</span>最小,直接排序做斜率优化.</p>
<h4><span id="点分树的性质">点分树的性质</span></h4>
<ol type="1">
<li><p>点分树的高度是<span class="math inline">\(O ( \log n
)\)</span>级别.</p></li>
<li><p>两个点在原树上的路径一定经过其在点分树上的LCA.</p></li>
</ol>
<h5><span id="example1codechef-btree">Example1(codechef [BTREE])</span></h5>
<p>这题用到了一个经典套路:一个树形连通图的点数减去边数为<span class="math inline">\(1\)</span>,把虚树建出来,能到达一个点的守卫必然是一个树形连通图(虚树中原本没有守卫的点可以加个不同覆盖范围的守卫).于是我们只需要求出每个守卫能覆盖多少点以及两个守卫之间的那条路径能覆盖多少个点,前者用点分树轻松维护,后者的话找一下这条边上的某个满足条件的点就行.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树,现在在上面选定<span class="math inline">\(m\)</span>对不同的点,要求每对点的距离之和最大.</p>
<p>考虑如果确定了<span class="math inline">\(2
m\)</span>个点,我们如何匹配他们.对每条边算贡献,假设这条边两侧分别有<span class="math inline">\(a , b\)</span>个点,那么这条边最大的贡献就是<span class="math inline">\(\min \{ a , b
\}\)</span>.不难发现这个上界可以取到,只需要取这<span class="math inline">\(2
m\)</span>个点的带权重心,由于不存在绝对众数,所以直接两两匹配.枚举带权重心是啥,这样复杂度<span class="math inline">\(O ( n^2 )\)</span>.</p>
<p>那么怎么优化呢?我们注意到如果以一个点<span class="math inline">\(x\)</span>作为根,而它有一个儿子<span class="math inline">\(y\)</span>,<span class="math inline">\(y\)</span>的子树中选了少于<span class="math inline">\(m\)</span>个点,那么我们以<span class="math inline">\(y\)</span>为根一定是不优秀的,不然一开始就不可能只选少于<span class="math inline">\(m\)</span>个点,再考虑带权重心这个东西,上点分树.</p>
<p>具体来说,我们建立点分树,然后从点分树的根开始枚举带权重心,如果当前没有一棵子树选了<span class="math inline">\(m\)</span>个点,就停止,不然往选了<span class="math inline">\(m\)</span>个点的那棵子树走(如果有两个的话选第<span class="math inline">\(m\)</span>大更大的那个),这样就只会选取<span class="math inline">\(O ( \log n )\)</span>个带权重心.</p>
<h3><span id="边分治">边分治</span></h3>
<p>需要建立虚点转二叉树.</p>
<h4><span id="边分树的性质">边分树的性质</span></h4>
<ol type="1">
<li><p>非叶子节点代表边,叶子节点代表点.</p></li>
<li><p>边分树的高度是<span class="math inline">\(O ( \log n
)\)</span>级别.</p></li>
<li><p>边分树上每棵子树中的叶子节点一定联通.</p></li>
<li><p>是一棵完全二叉树.</p></li>
<li><p>两个点在原树上的路径一定经过其在边分树上的LCA所代表的边.</p></li>
</ol>
<h3><span id="二分图">二分图</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="最大流-最小割定理">最大流-最小割定理</span></h5>
<h5><span id="hall定理">Hall定理</span></h5>
<p>对于二分图<span class="math inline">\(\langle V_1 , V_2 , E \rangle ,
| V_1 | \leq | V_2 |\)</span>,那么该图存在完备匹配的充要条件是<span class="math inline">\(\forall Q \subseteq V_1 , | Q | \leq | N ( Q )
|\)</span>,其中<span class="math inline">\(N ( Q
)\)</span>指的是所有与<span class="math inline">\(Q\)</span>中点有边相连的点的集合.</p>
<p>必要性很显然,接下来说明充分性.设<span class="math inline">\(T\)</span>为最小点覆盖,也就是最大匹配的数量,再设<span class="math inline">\(M\)</span>为最大匹配,此时自然有:</p>
<p><span class="math display">\[
| M | = | T | = | T_1 | + | T_2 | \geq | T_1 | + | N ( V_1 / T_1 ) |
\geq | T_1 | + | V_1 / T_1 | = | V_1 |
\]</span></p>
<p>显然<span class="math inline">\(| M | \leq | V_1 |\)</span>,于是<span class="math inline">\(| M | = | V_1 |\)</span>.</p>
<p>另外,Hall定理有一个推论:正则二分图一定存在完美匹配.什么叫正则二分图,就是所有的点的度数(不为<span class="math inline">\(0\)</span>)都相等的图.</p>
<p><span class="math inline">\(2^d\)</span>-正则二分图求完美匹配的话,可以不断求欧拉回路并给边定向,每次把一个方向的边全都删掉,这样就转化成了<span class="math inline">\(2^{ d - 1 }\)</span>-正则二分图,不断递归到<span class="math inline">\(d = 0\)</span>.</p>
<h5><span id="vizing定理">Vizing定理</span></h5>
<p>设<span class="math inline">\(f ( G )\)</span>表示将<span class="math inline">\(G\)</span>边染色,使得有公共点的边的颜色不同,最少需要的颜色数量.</p>
<p>设<span class="math inline">\(\delta ( G )\)</span>表示<span class="math inline">\(G\)</span>中的点的最大度数.</p>
<p>对于一般图,我们有:<span class="math inline">\(\delta ( G ) \leq f ( G
) \leq \delta ( G ) + 1\)</span>,对于二分图有<span class="math inline">\(\delta ( G ) = f ( G )\)</span>.</p>
<p>考虑这个的证明:我们每次将一对点<span class="math inline">\(( x , y
)\)</span>染色,考虑设它们当前没染色的最小的颜色是<span class="math inline">\(l_x , l_y ( l_x \leq l_y
)\)</span>,如果相等就直接选,不然类似增广路更新.</p>
<h4><span id="二分图最大权匹配">二分图最大权匹配</span></h4>
<p>假定二分图两边两两有边(不是的话可以补上<span class="math inline">\(-
\infty\)</span>的边),这样就一定存在完美匹配.</p>
<p>我们给每个点一个顶标权值<span class="math inline">\(v\)</span>,对于任意一条边<span class="math inline">\(e : a \leftrightarrow b\)</span>,它的权值是<span class="math inline">\(w_e\)</span>,我们要求<span class="math inline">\(v\)</span>满足<span class="math inline">\(v_a +
v_b \geq w_e\)</span>.</p>
<p>如果我们规定了一组顶标后,取出所有满足<span class="math inline">\(v_a
+ v_b =
w_e\)</span>的边后的图(称作相等子图)存在完美匹配,那这组完美匹配就一定是最大权匹配.</p>
<p>这是为啥呢?考虑此时的最大权其实也就是<span class="math inline">\(\sum
v\)</span>,而由于<span class="math inline">\(v_a + v_b \geq
w_e\)</span>,因此最大权匹配一定不会超过<span class="math inline">\(\sum
v\)</span>.这就是一个可达的上界.</p>
<p>那么我们该怎么得到一个相等子图呢?考虑先构造一组合法的顶标,让左部端点取边的最大值,右部端点取<span class="math inline">\(0\)</span>,然后开始增广.</p>
<p>从左侧任意一个非匹配点出发,在相等子图上走增广路并增广.如果增广失败,我们将访问过的左部端点全部减去<span class="math inline">\(d\)</span>,右部端点全部加上<span class="math inline">\(d\)</span>,注意到此时匹配边一定不会变化,因为匹配边要么两个端点都没被访问过,要么都被访问过.而左端点被访问过,右端点没被访问过的边有可能加入相等子图,我们考虑取所有这种边的需要的差值的最小值并进行更新.但是直接这么做的复杂度有点高.</p>
<p>使用bfs优化,可以发现只会扩大<span class="math inline">\(O ( n^2
)\)</span>次子图,每次复杂度<span class="math inline">\(O ( n
)\)</span>,增广的复杂度类似,于是总复杂度<span class="math inline">\(O (
n^3 )\)</span>.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-ofjapanopenstrain-contest-1489-bpoint-pairs">Example1([
XVII Open Cup named after E.V. Pankratiev. Grand Prix of
Japan(openstrain contest 1489) B]Point Pairs)</span></h5>
<p>看到这种要求横坐标或纵坐标相同的题,有一个自然的想法是建立二分图,对于点<span class="math inline">\(( x , y )\)</span>,将二分图左边的<span class="math inline">\(x\)</span>和右边的<span class="math inline">\(y\)</span>连一条边.那么配对等价于要每次找两条相邻的边删掉.那么如何删掉呢?</p>
<p>首先发现的是,二分图不同的连通块可以分开处理,我们接下来只讨论一个连通块的情况.如果这个连通块有奇数条边,显然一定不行.而又可以发现,如果这个连通块有一个点度数仅为<span class="math inline">\(1\)</span>,那这条边如何删是确定的,我们可以把它和另一条边删掉,不难发现怎么删最后得到的新图仍然联通.而如果不存在度数为<span class="math inline">\(1\)</span>的点呢?由于这是一个二分图,不存在奇环,所以我们可以找一个简单环删掉,之后显然也是一个连通块.我们到这里就可以发现问题了.运用数学归纳不难证明:只要一个连通块的边数是偶数就一定合法.</p>
<p>然后我们可以使用可撤销的分治解决这个问题.</p>
<h3><span id="网络流常见模型">网络流常见模型</span></h3>
<h4><span id="最大流">最大流</span></h4>
<h4><span id="最小费用最大流">最小费用最大流</span></h4>
<h4><span id="最小割">最小割</span></h4>
<p>最大流<span class="math inline">\(=\)</span>最小割,证明显然.</p>
<p>最小割求方案。这个是简单的，我们删去所有流量<span class="math inline">\(0\)</span>的边后从<span class="math inline">\(S\)</span>开始bfs，找到所有<span class="math inline">\(S\)</span>能到达的点，显然这些点（注意如果这个点一开始就不能到达<span class="math inline">\(T\)</span>，那它是废物，不用管它，下面只讨论它能到达<span class="math inline">\(T\)</span>的情况）组成一个SCC（为啥呢？首先<span class="math inline">\(S\)</span>能到达它们，其次由于是最小割，因此这个点一定到达不了<span class="math inline">\(T\)</span>，而原本是可以到达<span class="math inline">\(T\)</span>的，假设这个点是<span class="math inline">\(x\)</span>，那么一定是原本存在一条<span class="math inline">\(S \rightarrow x \rightarrow
T\)</span>的路径被割掉了，也就是现在一定存在一条<span class="math inline">\(x \rightarrow
S\)</span>的路径）。最小割包含的边一定是这个集合和其它集合交界处的边。这是为啥呢？首先这些边一定组成了原图的一个割，其次，我们发现割不可能存在<span class="math inline">\(S\)</span>所在SCC中，而割掉完全不连接<span class="math inline">\(S\)</span>的边可以发现不如割其中一个点在<span class="math inline">\(S\)</span>所在SCC的边。</p>
<h5><span id="example1luogup4313-文理分科">Example1(luoguP4313 文理分科)</span></h5>
<p>先把所有的满意值全部吃下,然后考虑放弃哪些.</p>
<p>对于每个人<span class="math inline">\(u\)</span>,将<span class="math inline">\(S\)</span>向他连一条流量为<span class="math inline">\(art\)</span>的边,它向<span class="math inline">\(T\)</span>连一条为<span class="math inline">\(science\)</span>的边,表示它自己要么放弃文科,要么放弃理科.</p>
<p>然后再对每个点建立一个虚点<span class="math inline">\(u
&#39;\)</span>,<span class="math inline">\(S\)</span>向<span class="math inline">\(u &#39;\)</span>连一条为<span class="math inline">\(sameart\)</span>的边,<span class="math inline">\(u
&#39;\)</span>向相邻的实点连<span class="math inline">\(\infty\)</span>的边,表示要么放弃<span class="math inline">\(sameart\)</span>,要么那些点全都放弃理科.<span class="math inline">\(samescience\)</span>是同理的.</p>
<p>从这也可以看出来,大部分最小割的题目其实就是将冲突的选项放到一条路径中,然后考虑放弃哪些,将这个限制用最小割表示出来.</p>
<h5><span id="example2hnoi2013切糕">Example2([HNOI2013]切糕)</span></h5>
<p>也是显然的最小割,唯一难处理的地方在于相差<span class="math inline">\(\leq D\)</span>.</p>
<p>这个怎么做呢?建图后先每一竖轴都变成了一条链,我们在链之间加一些<span class="math inline">\(\infty\)</span>的边,使得如果断开的两个点之差大于<span class="math inline">\(D\)</span>,那就可以通过这条边破坏最小割结构.</p>
<p>这题同样告诉我们:对于最小割题目中的限制条件,几乎都是需要考虑破坏最小割结构的(也有可能是用费用流限制).</p>
<h5><span id="example3uoj704">Example3(uoj704)</span></h5>
<p>二分图最小割计数.</p>
<p>先求出最小割,然后显然每个匹配的三条边一定会选择一条割掉.</p>
<p>不妨设<span class="math inline">\(a_i = 0 / 1 / 2\)</span>表示第<span class="math inline">\(i\)</span>对匹配割掉了哪一条边.</p>
<p>考虑每个非匹配边<span class="math inline">\(( u , v
)\)</span>对点权的限制:</p>
<ol type="1">
<li><p><span class="math inline">\(u\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(v\)</span>不在.则<span class="math inline">\(a_i =
0\)</span>.</p></li>
<li><p><span class="math inline">\(v\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(u\)</span>不在,则<span class="math inline">\(a_i =
2\)</span>.</p></li>
<li><p><span class="math inline">\(u\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(v\)</span>在最大匹配<span class="math inline">\(j\)</span>中,则<span class="math inline">\(a_i =
0\)</span>或<span class="math inline">\(a_j = 2\)</span>.</p></li>
</ol>
<p>前两种是好处理的,考虑第三种:显然所有都选<span class="math inline">\(2\)</span>或所有都选<span class="math inline">\(0\)</span>是一种方案,更进一步地,我们将<span class="math inline">\(i \rightarrow
j\)</span>,那么在一个强连通分量中的点一定都是<span class="math inline">\(2\)</span>或都是<span class="math inline">\(0\)</span>.这样可以缩点,缩点后发现DAG上的每一条路径的染色都形如<span class="math inline">\(0 , 0 , 0 , \cdots , 0 , ( 1 ) , 2 , \cdots , 2 ,
2 , 2\)</span>.</p>
<p>不妨折半搜索,按照拓扑排序,确定前一半哪些是<span class="math inline">\(0\)</span>,剩下是<span class="math inline">\(1 /
2\)</span>,那他们的后继必然全都是<span class="math inline">\(2\)</span>,这样后面的是<span class="math inline">\(2\)</span>的集合一定是这个后继集合的超集,高维后缀和.</p>
<p>接下来只需要判断哪些位置可以选<span class="math inline">\(1\)</span>.相当于前驱全都是<span class="math inline">\(0\)</span>并且后继全都是<span class="math inline">\(2\)</span>.</p>
<h4><span id="二分图匹配">二分图匹配</span></h4>
<h4><span id="二分图最小点覆盖">二分图最小点覆盖</span></h4>
<p>二分图最小点覆盖<span class="math inline">\(=\)</span>二分图最小割.</p>
<p>问题在于如何求解方案.</p>
<p>我们从左侧的非匹配点开始dfs,走还有残留流量的路径.并将路径上所有的点全都打上标记.那么左侧所有的未标记点和右侧所有的标记点就是一组合法的方案.</p>
<p>这是为啥呢?首先我们注意到,左侧的非匹配点一定会被标记,右侧的非匹配点一定不会被标记.</p>
<p>为啥右侧的非匹配点一定不会被标记呢?因为如果被标记了,从左侧非匹配点到右侧非匹配点这条路径的起始边和终边就都是非匹配边,显然是一条增广路.</p>
<p>然后我们又注意到:对于一组匹配点,要么两者都被标记,要么两者都不被标记,因为一旦走到了右侧点,下一步必然走向左侧点.而如果走到了左侧点,也必然是从右侧点走过来的.</p>
<p>接下来我们讨论一下:</p>
<p>对于非匹配边,由于其必然连了一个左侧非匹配点,所以它的右边必然被选择了.</p>
<p>对于匹配边,不难发现它会被某个匹配点覆盖掉.</p>
<p>于是得证.</p>
<p>当然,上面的证明略显啰嗦.事实上我们这么考虑:</p>
<p>首先,我们按照套路,求出<span class="math inline">\(S\)</span>所有能到达的点.根据二分图的性质,这个点的集合必然不包括<span class="math inline">\(T\)</span>.</p>
<p>然后我们取所有不在这个点集的左侧点和所有在这个点集的右侧点,这样所有的点被分为了四个部分,边也自然被分为了四个部分,讨论一下就知道这四个部分中有一个部分是不存在边的.于是得证.</p>
<h4><span id="二分图最大独立集">二分图最大独立集</span></h4>
<p>二分图最大独立集<span class="math inline">\(= n
-\)</span>二分图最小点覆盖.</p>
<h5><span id="example1cf1404e">Example1(CF1404E)</span></h5>
<p>在两个可选矩形的边界处建立一个点,如果它被选了,那么说明这个矩形和上面那个矩形被一起覆盖了.然后注意到每有一个点被选,自然就多覆盖了一个矩形,显然一个矩形不可能又跟纵向的一起被覆盖又跟横向的一起被覆盖,在他俩之间连边跑最大独立集即可.</p>
<p>感觉还是类似于最小路径覆盖,将这种两个一起被覆盖就减少答案的东西转换成一整条流.</p>
<h4><span id="最大权闭合子图">最大权闭合子图</span></h4>
<p>原图的边流量设为<span class="math inline">\(+
\infty\)</span>,然后对于每个点<span class="math inline">\(x\)</span>,如果<span class="math inline">\(val_x
&gt; 0\)</span>,那么<span class="math inline">\(ans + =
val_x\)</span>,然后将<span class="math inline">\(S \rightarrow
x\)</span>,流量为<span class="math inline">\(val_x\)</span>;不然,<span class="math inline">\(x \rightarrow T\)</span>,流量为<span class="math inline">\(- val_x\)</span>,然后求出最小割<span class="math inline">\(w\)</span>,答案即为<span class="math inline">\(ans
- w\)</span>.</p>
<h5><span id="example1luogup4177">Example1(luoguP4177)</span></h5>
<p>只需要把中间的<span class="math inline">\(\infty\)</span>边改为租用的代价即可.</p>
<h4><span id="最小路径覆盖覆盖点">最小路径覆盖(覆盖点)</span></h4>
<p>将每个点<span class="math inline">\(x\)</span>拆为两个点<span class="math inline">\(A_x\)</span>,<span class="math inline">\(B_x\)</span>,将<span class="math inline">\(S\)</span>向所有<span class="math inline">\(A\)</span>连边,<span class="math inline">\(B\)</span>向<span class="math inline">\(T\)</span>连边,如果图中存在一条路径<span class="math inline">\(x \rightarrow y\)</span>,则连边<span class="math inline">\(A_x \rightarrow B_y\)</span>,流量均为<span class="math inline">\(1\)</span>,然后求出最大流<span class="math inline">\(w\)</span>,答案即为<span class="math inline">\(n -
w\)</span>.</p>
<p>还有一个版本是可以重复走点,做一遍传递闭包就行.因为可重复相当于原图上的可跳点,这个版本又叫最小链覆盖.</p>
<h5><span id="example1网络流24题魔术球问题">Example1([网络流24题]魔术球问题)</span></h5>
<p>枚举球数,不断在残联网络上加边并在新图跑最小路径覆盖即可.</p>
<h4><span id="最长反链">最长反链</span></h4>
<p>反链是一个点的集合,满足这个集合中的点两两不可达.</p>
<p>最长反链<span class="math inline">\(=\)</span>可重复走点的最小点覆盖(最小链覆盖).</p>
<p>为啥呢?因为发现做完传递闭包后等价于新图的最大独立集.当然图是有性质的,观察一下可重复走点的最小点覆盖就可以发现等价于传递闭包后在二分图上求最大独立集.</p>
<h5><span id="example1cf1630fmaking-itbipartite">Example1([CF1630F]Making It
Bipartite)</span></h5>
<p>首先显然的一点是,对于任意一个数字<span class="math inline">\(x\)</span>,这个序列中不能同时出现<span class="math inline">\(px\)</span>和<span class="math inline">\(pqx\)</span>,其中<span class="math inline">\(p ,
q\)</span>都是大于等于二的正整数.这是显然的.如果我们把图改为有向图,由<span class="math inline">\(x \rightarrow
px\)</span>,那么整个图就只会有两种点:只有出边的点和只有入边的点.</p>
<p>那么我们该怎么办呢?如果是只能出现<span class="math inline">\(x\)</span>就不能出现<span class="math inline">\(px\)</span>,那这就是一个经典的最长反链问题.但多了一层,我们可以考虑类似分层图的思想:建立和原图完全一样的图<span class="math inline">\(G &#39;\)</span>,并且将<span class="math inline">\(G\)</span>中的<span class="math inline">\(x\)</span>向<span class="math inline">\(G
&#39;\)</span>中的<span class="math inline">\(x
&#39;\)</span>连有向边,然后跑最长反链.不难发现这样做是正确的.</p>
<h4><span id="平面图最小割">平面图最小割</span></h4>
<p>平面图最小割<span class="math inline">\(=\)</span>对偶图最短路.</p>
<h4><span id="最小费用任意流">最小费用任意流</span></h4>
<p>一般费用流,但是当当前增广路代价为正的就停止增广.</p>
<p>和最小费用最大流不一样,这玩意是可以增量的.</p>
<p>只需要考虑所有新的从源到汇的增广路以及增加过程出现的负环即可.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<p>费用流模型很好建立,问题在于这个东西好像跑费用流有点慢.</p>
<p>那咋办呢?我们考虑到费用流是有凸性的.所以搭配一下wqs二分.</p>
<p>然后分一下三种情况讨论:</p>
<ol type="1">
<li><p>直接<span class="math inline">\(S \rightarrow
T\)</span>的负增广路,相当于选取最小的<span class="math inline">\(b\)</span>和当前的<span class="math inline">\(a\)</span>搭配.</p></li>
<li><p>有一条<span class="math inline">\(S \rightarrow a \rightarrow b
\rightarrow a \rightarrow S\)</span>的负环,相当于以当前的<span class="math inline">\(a\)</span>代替前面的某个较大的<span class="math inline">\(a\)</span>.</p></li>
<li><p>有一条<span class="math inline">\(S \rightarrow a \rightarrow b
\rightarrow T \rightarrow b \rightarrow a \rightarrow
S\)</span>的负环,注意到这个环必然没意义,因为不可能存在一条<span class="math inline">\(T \rightarrow
S\)</span>的负路径(不然反路径就是正的,而最小费用任意流不可能流正路径),所以这种情况不如直接选<span class="math inline">\(S \rightarrow T\)</span>的路径.</p></li>
</ol>
<p>讨论完拿堆模拟一下就行.</p>
<p>这引出了著名的模拟费用流算法.</p>
<h4><span id="负费用最小流">负费用最小流</span></h4>
<p>一般费用流,但是当增广当前增广路时费用变成正的就停止增广.</p>
<p>注意如果两条增广路代价相同选流量大的那条.</p>
<h4><span id="有负环的费用流">有负环的费用流</span></h4>
<p>首先注意到:如果初始图没有负环,那无论后面怎么流都不可能出来负环.因为这意味着要么是一开始流了个正环,要么是一开始有负路径不走走正路径,都不太可能.</p>
<p>对于所有的负边<span class="math inline">\(u \rightarrow
v\)</span>,我们建立两个新点<span class="math inline">\(S
&#39;\)</span>和<span class="math inline">\(T
&#39;\)</span>,我们先将这条负边反向权值取相反数并让答案加上<span class="math inline">\(f \times v\)</span>,之后令<span class="math inline">\(u \rightarrow T &#39; , S &#39; \rightarrow
v\)</span>,跑<span class="math inline">\(S &#39; \rightarrow T
&#39;\)</span>的费用流,这个时候再在残联网络上跑<span class="math inline">\(s \rightarrow t\)</span>的费用流就是答案.</p>
<p>为啥会这样呢?</p>
<p>首先先证明正确性,这个东西相当于一开始跑了一下<span class="math inline">\(T &#39; \rightarrow u \rightarrow v \rightarrow S
&#39;\)</span>的图.然后我们在跑<span class="math inline">\(S &#39;
\rightarrow T &#39;\)</span>的时候一定是可以把上面的那个东西所从<span class="math inline">\(T &#39; \rightarrow S
&#39;\)</span>的所有流量全都退回去,因为这是一个可以构造的上界.也就相当于我们跑了一个环流.而在费用流里跑环流显然是不会影响答案的.</p>
<p>好,那么为啥这么做就不会出现负环了呢?因为你不可能在跑<span class="math inline">\(S &#39; \rightarrow T
&#39;\)</span>的时候跑个正环出来,自然不可能出现负环.</p>
<p>另外有一点是,一个点可能向<span class="math inline">\(S
&#39;\)</span>或<span class="math inline">\(T
&#39;\)</span>连很多边,其实是可以拼掉的,因为这些边全都是零权边,而构造完后的图是非负权边.</p>
<h4><span id="模拟费用流">模拟费用流</span></h4>
<p>对于特殊的图,模拟EK费用流的增广过程并进行操作.</p>
<p>对着例题记吧.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<h4><span id="散题">散题</span></h4>
<h5><span id="example1cqoi2014危桥">Example1([CQOI2014]危桥)</span></h5>
<p>有一个朴素的想法是:我们直接按题意建图,然后<span class="math inline">\(S \rightarrow a_1 , b_1\)</span>,<span class="math inline">\(T \rightarrow a_2 ,
b_2\)</span>,跑最大流然后检查是否满流.</p>
<p>问题在于,这样有可能会出现<span class="math inline">\(a_1 \rightarrow
b_2\)</span>的流量,我们怎么避免这种情况呢?</p>
<p>做法是,我们交换<span class="math inline">\(b_1 ,
b_2\)</span>并重复上面的过程,如果还是满流,我们声明一定合法.</p>
<p>为什么呢?我们注意到此时网络上的流量分为四种:<span class="math inline">\(a_1 \rightarrow a_2\)</span>,<span class="math inline">\(a_1 \rightarrow b_2\)</span>,<span class="math inline">\(b_1 \rightarrow a_2\)</span>,<span class="math inline">\(b_1 \rightarrow b_2\)</span>.不难发现<span class="math inline">\(a_1 \rightarrow b_2\)</span>和<span class="math inline">\(b_1 \rightarrow a_2\)</span>的流量是相等的.</p>
<p>在第二次跑网络流时,我们不妨直接将<span class="math inline">\(a_1
\rightarrow a_2\)</span>和<span class="math inline">\(b_2 \rightarrow
b_1\)</span>的流量加入答案并将这两条路径反向.此时,如果<span class="math inline">\(a_1\)</span>还是要走到<span class="math inline">\(b_1\)</span>,你发现第一轮的时候已经找到了一条<span class="math inline">\(b_1 \rightarrow
a_2\)</span>的路径,我们一定可以走这条来构造出只有<span class="math inline">\(a_1 \rightarrow a_2\)</span>的路径,另一边同理.</p>
<h3><span id="图的计数问题">图的计数问题</span></h3>
<h4><span id="prufer序列">Prufer序列</span></h4>
<p>我们可以将一颗有编号<span class="math inline">\(n\)</span>个点(<span class="math inline">\(n \geq 2\)</span>)的无根树与一个长度为<span class="math inline">\(n -
2\)</span>的Prufer序列建立双射.换句话说,一颗有编号<span class="math inline">\(n\)</span>个节点的无根树总共有<span class="math inline">\(n^{ n - 2 }\)</span>种(Cayley公式).</p>
<p>首先证明一个树可以对应到一个序列:每次选择一个度数为<span class="math inline">\(1\)</span>的编号最小的点,把它连向的点加到序列中并把这个点删去,直到最后只剩下两个节点,这样我们就把一棵树对应到一个序列.不难发现每个点出现的次数是其度数<span class="math inline">\(- 1\)</span>.</p>
<p>然后证明一个序列可以还原成一棵树:</p>
<p>我们可以通过序列得知每个点的度数,每次找到度数中最小的那个点并把它与序列中的第一个元素连边并删去序列中的第一个元素,不断这么做显然可以还原树.</p>
<h5><span id="example">Example</span></h5>
<p>一个<span class="math inline">\(n\)</span>个点的图有<span class="math inline">\(k\)</span>个连通块,现在加入<span class="math inline">\(k - 1\)</span>条边使得图连通,求方案数.</p>
<p>令<span class="math inline">\(s_i\)</span>为第<span class="math inline">\(i\)</span>个连通块的点数,<span class="math inline">\(d_i\)</span>为第<span class="math inline">\(i\)</span>个连通块所新连上的边数,如果我们令<span class="math inline">\(\binom{ n }{ c_1 , c_2 , . . . , c_m } = \cfrac{ n
! }{ c_1 ! c_2 ! . . . c_m ! } , \sum_{ i = 1 }^m c_i = n
\\\)</span>,也即将<span class="math inline">\(n\)</span>个位置拆分成<span class="math inline">\(m\)</span>个集合,第<span class="math inline">\(i\)</span>个集合有<span class="math inline">\(c_i\)</span>个位置的方案数.</p>
<p>那我们所需要做的也就是枚举每个连通块所新连出的边数<span class="math inline">\(d_i\)</span>,于是答案即<span class="math inline">\(\sum_d [ \sum d_i = 2 k - 2 ] \binom{ k - 2 }{ d_1
- 1 , d_2 - 1 , . . . , d_k - 1 } \prod_{ i = 1 }^k s_i^{ d_i }
\\\)</span>.</p>
<p>注意到我们有多项式定理:<span class="math inline">\(( x_1 + x_2 + . .
. + x_m )^n = \sum_{ c } [ \sum c_i = n ] \binom{ n }{ c_1 , c_2 , . . .
, c_m } \prod_{ i = 1 }^m x_i^{ c_i } \\\)</span>.</p>
<p>于是原式<span class="math inline">\(= n^{ k - 2 } \prod_{ i = 1 }^k
s_i\)</span>.</p>
<h4><span id="prufer序列的矩阵树定理理解">Prufer序列的矩阵树定理理解</span></h4>
<p>事实上,Prufer序列其实是可以拿矩阵树定理代替的(但是更麻烦一点).</p>
<p>我们先考虑证明Cayley公式:构造矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>其主余子式为:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>将所有行全部加到第一行:</p>
<p><span class="math display">\[
\begin{bmatrix}
- 1 &amp; - 1 &amp; \cdots &amp; - 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>全部加下来,然后就成了上三角矩阵,将对角线乘起来就是<span class="math inline">\(n^{ n - 2 }\)</span>.</p>
<p>连通块的结论是类似的.</p>
<h4><span id="lgv引理">LGV引理</span></h4>
<p>设<span class="math inline">\(G\)</span>是一个有限的带权有向无环图,有点集<span class="math inline">\(V\)</span>的一个大小为<span class="math inline">\(n\)</span>的子集<span class="math inline">\(A = \{
a_1 , a_2 , . . . , a_n \}\)</span>作为起点集合,一个大小为<span class="math inline">\(n\)</span>的子集<span class="math inline">\(B = \{
b_1 , b_2 , . . . , b_n \}\)</span>作为终点集合.</p>
<p>记边<span class="math inline">\(i\)</span>的权值为<span class="math inline">\(w_i\)</span>.对于有向路径<span class="math inline">\(p\)</span>,记路径上所有边的边权的乘积为<span class="math inline">\(W ( p )\)</span>.记<span class="math inline">\(e (
u , v ) = \sum_{ p : u \rightarrow v } W ( p )\)</span>,即从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的所有路径的边权乘积之和.</p>
<p>记<span class="math inline">\(P : A \rightarrow B = ( p_1 , p_2 , . .
. , p_n )\)</span>,<span class="math inline">\(p_i\)</span>表示从<span class="math inline">\(a_i\)</span>到<span class="math inline">\(b_{
\sigma ( i ) }\)</span>的一条路径,其中<span class="math inline">\(\sigma\)</span>是一个排列,记<span class="math inline">\(sign ( \sigma )\)</span>为<span class="math inline">\(-
1\)</span>以这个排列的逆序对数量为幂的值.又记<span class="math inline">\(\sigma ( P )\)</span>为<span class="math inline">\(P\)</span>所对应终点的排列.若满足<span class="math inline">\(\forall 1 \leq i , j \leq n , i \ne
j\)</span>,<span class="math inline">\(p_i\)</span>与<span class="math inline">\(p_j\)</span>没有公共点,则记作<span class="math inline">\(P^u\)</span>,否则记作<span class="math inline">\(P^c\)</span>,若不作区分记作<span class="math inline">\(P\)</span>.记<span class="math inline">\(W_{ all }
( P ) = \prod_{ i = 1 }^n W ( p_i )
\\\)</span>,也就是所有路径的乘积.</p>
<p>设矩阵<span class="math inline">\(M\)</span>满足<span class="math inline">\(M_{ i , j } = e ( a_i , b_j )\)</span>,那么有:</p>
<p><span class="math display">\[
\det M = \sum_{ P^u : A \rightarrow B } sign ( \sigma ( P^u ) ) W_{ all
} ( P^u )
\]</span></p>
<p>证明:</p>
<p>根据行列式的定义,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\det M &amp; = \sum_{ \sigma } sign ( \sigma ) \prod_{ i = 1 }^n e ( a_i
, b_{ \sigma ( i ) } ) \\
&amp; = \sum_{ \sigma } sign ( \sigma ) \prod_{ i = 1 }^n \sum_{ p_i :
a_i \rightarrow b_{ \sigma ( i ) } } w ( p_i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑后面那部分,<span class="math inline">\(\prod_{ i = 1 }^n \sum_{
p_i : a_i \rightarrow b_{ \sigma ( i ) } } w ( p_i )
\\\)</span>形如一个卷积的形式,所以这个式子等价于所有对应排列为<span class="math inline">\(\sigma\)</span>的<span class="math inline">\(P\)</span>的<span class="math inline">\(w ( P
)\)</span>,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\det M &amp; = \sum_{ \sigma } sign ( \sigma ) ( \sum_{ P : \{ a_1 , . .
. , a_n \} \rightarrow \{ b_{ \sigma ( 1 ) } , . . . , b_{ \sigma ( n )
} \} } w ( P ) ) \\
&amp; = \sum_{ P : A \rightarrow B } sign ( \sigma ( P ) ) w ( P ) \\
&amp; = \sum_{ P^u : A \rightarrow B } sign ( \sigma ( P^u ) ) w ( P^u )
+ \sum_{ P^c : A \rightarrow B } sign ( \sigma ( P^c ) ) w ( P^c )
\end{aligned}
\]</span></p>
<p>接下来只需证明<span class="math inline">\(\sum_{ P^c : A \rightarrow
B } sign ( \sigma ( P^c ) ) w ( P^c ) = 0 \\\)</span>即可.</p>
<p>设所有<span class="math inline">\(P^c\)</span>组成的集合为<span class="math inline">\(E\)</span>,考虑构造一个映射<span class="math inline">\(f : E \rightarrow E\)</span>满足如下条件:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( P^c ) \ne P^c\)</span>.</p></li>
<li><p><span class="math inline">\(f ( f ( P^c ) ) =
P^c\)</span>.</p></li>
<li><p><span class="math inline">\(w ( f ( P^c ) ) = w ( P^c
)\)</span>.</p></li>
<li><p><span class="math inline">\(sign ( f ( P^c ) ) = - sign ( P^c
)\)</span>.</p></li>
</ol>
<p>上面的结论即得证.</p>
<p>我们不妨考虑<span class="math inline">\(P^c\)</span>中的第一对相交的路径<span class="math inline">\(p_i\)</span>和<span class="math inline">\(p_j\)</span>,并交换它们的终点.显然满足上述条件,于是结论得证.</p>
<h5><span id="example">Example</span></h5>
<p>现在有<span class="math inline">\(n\)</span>个点,第<span class="math inline">\(i\)</span>个点位于<span class="math inline">\((
a_i , 1 )\)</span>,需要走到<span class="math inline">\(( b_i , n
)\)</span>.一个在<span class="math inline">\(( x , y
)\)</span>的点可以走向<span class="math inline">\(( x + 1 , y
)\)</span>或<span class="math inline">\(( x , y + 1
)\)</span>.求路径不相交的方案数.</p>
<p>路径不相交,则终点排列只有可能是<span class="math inline">\(\{ 1 , 2 ,
. . . , n \}\)</span>,直接使用LGV引理即可.</p>
<h4><span id="矩阵树定理">矩阵树定理</span></h4>
<h5><span id="无向图情况">无向图情况</span></h5>
<p>定义无向图的度数矩阵<span class="math inline">\(D ( G
)\)</span>为:<span class="math inline">\(D ( G )_{ i , j } =
\begin{cases}0 &amp; i \ne j \\ \deg_{ i } &amp; i =
j\end{cases}\)</span>.</p>
<p>令<span class="math inline">\(w ( i , j )\)</span>为<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>之间直接相连的无向边个数,定义无向图的邻接矩阵<span class="math inline">\(A ( G )_{ i , j } = \begin{cases}0 &amp; i = j \\
w ( i , j ) &amp; i \ne j\end{cases}\)</span></p>
<p>定义无向图的基尔霍夫矩阵(又称拉普拉斯矩阵)<span class="math inline">\(L ( G ) = D ( G ) - A ( G )\)</span>.</p>
<p>记<span class="math inline">\(t ( G )\)</span>为图<span class="math inline">\(G\)</span>的生成树个数,那么有:<span class="math inline">\(t ( G
)\)</span>等于基尔霍夫矩阵任意一个主余子式.</p>
<p>引理:无向图的基尔霍夫矩阵的任意一个代数余子式都相等.</p>
<p>证明:考虑删去第<span class="math inline">\(i\)</span>行,设剩下的矩阵为<span class="math inline">\(A = [ \vec{ r }_1 , \vec{ r }_2 , . . . , \vec{ r
}_n ]\)</span>,根据基尔霍夫矩阵的性质,不难发现<span class="math inline">\(\sum{ \vec{ r }_i } = \vec{ 0 }\)</span>.<span class="math inline">\(\forall 1 \leq j &lt; k \leq
n\)</span>,如果我们删去第<span class="math inline">\(j\)</span>列,考虑将除了第<span class="math inline">\(k\)</span>列的其它列全部加到第<span class="math inline">\(k\)</span>列,于是得到矩阵<span class="math inline">\([ \vec{ r }_1 , . . . , \vec{ r }_{ j - 1 } ,
\vec{ r }_{ j + 1 } , . . . , \vec{ r }_{ k - 1 } , - \vec{ r }_j ,
\vec{ r }_{ k + 1 } , . . . , \vec{ r }_n
]\)</span>.我们接下来一路将第<span class="math inline">\(k\)</span>列交换到第<span class="math inline">\(j
+ 1\)</span>列之前并取反,我们就得到了删去第<span class="math inline">\(k\)</span>列的矩阵,于是有<span class="math inline">\(M_{ i , j } = ( - 1 )^{ 1 + ( k - 1 ) - ( j + 1 )
+ 1 } M_{ i , k }\)</span>,也就是<span class="math inline">\(C_{ i , j }
= C_{ i , k }\)</span>,同理可证明<span class="math inline">\(C_{ j , i }
= C_{ k , i }\)</span>.</p>
<p>接下来,用<span class="math inline">\(T\)</span>表示生成树的边的集合,设<span class="math inline">\(w ( T ) = \prod_{ e \in T } w ( e
)\)</span>,我们只需证明<span class="math inline">\(C_{ 1 , 1 } = \sum w
( T )\)</span>.</p>
<p>定义<span class="math inline">\(\zeta ( e , u ) = v , e = \{ u , v
\}\)</span>,考虑构造一个<span class="math inline">\(n \times
m\)</span>的矩阵<span class="math inline">\(A\)</span>满足<span class="math inline">\(A_{ i , j } = \begin{cases}1 &amp; i \in e_j \land
i &lt; \zeta ( e_j , i ) \\ - 1 &amp; i \in e_j \land i &gt; \zeta ( e_j
, i ) \\ 0 &amp; other\end{cases} \\\)</span>.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
AA^T ( i , j ) &amp; = \sum_{ k = 1 }^m A ( i , k ) A^T ( k , j ) \\
&amp; = \sum_{ k = 1 }^m A ( i , k ) A ( j , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>当<span class="math inline">\(i = j\)</span>时,不难发现<span class="math inline">\(AA^T ( i , j ) = \sum_{ k = 1 }^m [ i \in e_k ] =
\deg_i\)</span>.不然,注意到显然为<span class="math inline">\(- \sum_{ k
= 1 }^m [ i \in e_k ] [ j \in e_k ]\)</span>.也就是说,<span class="math inline">\(AA^T = L\)</span>.</p>
<p>定义<span class="math inline">\(A\)</span>删去第一行后得到的矩阵为<span class="math inline">\(B\)</span>,则<span class="math inline">\(BB^T =
M_{ 1 , 1 }\)</span>.此时我们带入Cauchy-Binet公式,得到:</p>
<p><span class="math display">\[
\begin{aligned}
M_{ 1 , 1 } &amp; = \sum_{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . . .
, m \} } \det ( B [ S ] B^T [ S ] ) \\
&amp; = \sum_{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . . . , m \} }
\det ( B [ S ] )^2
\end{aligned}
\]</span></p>
<p>接下来我们需要证明:如果<span class="math inline">\(S\)</span>集合构成了一棵生成树,那么<span class="math inline">\(\det B [ S ] = \pm 1\)</span>.反之,<span class="math inline">\(\det B [ S ] = 0\)</span>.</p>
<p>如果集合没有构成一个生成树,则至少存在一个简单环.如果有某个点是孤立点那么答案肯定是<span class="math inline">\(0\)</span>,因此只需考虑每个点都与边连通的情况即可.</p>
<p>考虑这种情况下,如果有两条边<span class="math inline">\(( u_1 , u_2
)\)</span>和<span class="math inline">\(( u_2 , u_3
)\)</span>被选上了,那么我们可以通过列变换将它们改为<span class="math inline">\(( u_1 , u_2 )\)</span>和<span class="math inline">\(( u_1 , u_3
)\)</span>.这样不断进行下去,如果存在环,一定会出现重边选择的情况,这个时候行列式的值为<span class="math inline">\(0\)</span>.如果不存在环,那么我们可以通过这个操作得到一个菊花图.所以行列式为<span class="math inline">\(\pm 1\)</span>.</p>
<p>所以定理得证.</p>
<h6><span id="example省选联考-2020-a卷作业题">Example([省选联考 2020 A
卷]作业题)</span></h6>
<p>给定一个图,设第<span class="math inline">\(i\)</span>条边的权值为<span class="math inline">\(w_i\)</span>,求所有生成树的<span class="math inline">\(\gcd ( w_1 , . . . , w_{ n - 1 } ) \sum_{ i = 1
}^{ n - 1 } w_i\)</span>之和.</p>
<p>首先前面的<span class="math inline">\(\gcd\)</span>可以使用<span class="math inline">\(\varphi * I =
id\)</span>来处理.于是剩下的问题在于我们如何将一个生成树的边的和代替乘积作为贡献来求和.</p>
<p>不妨进行扩域,令<span class="math inline">\(j^2 = 0 , j \ne
0\)</span>,这样我们可以类比复数来将每个数写作<span class="math inline">\(a + bj\)</span>的模式.考虑将每条边的边权改为<span class="math inline">\(w_i j +
1\)</span>并定义新域的四则运算,取最后得到的数<span class="math inline">\(a + bj\)</span>的<span class="math inline">\(b\)</span>作为答案即可.</p>
<p>另外,注意到这样做复杂度<span class="math inline">\(wn^3\)</span>,很难通过.考虑每次只当边数大于等于<span class="math inline">\(n - 1\)</span>的时候再跑行列式.不妨设<span class="math inline">\(\sigma ( n )\)</span>为<span class="math inline">\(n\)</span>的因数个数,考虑如果因数很分散,那肯定复杂度很低,不然,我们有复杂度<span class="math inline">\(O ( n^3 \cfrac{ \sum_{ i = 1 }^m \sigma ( w_i ) }{
n - 1 } )\)</span>,可以通过.</p>
<h6><span id="example北京省选集训2019生成树计数">Example([北京省选集训2019]生成树计数)</span></h6>
<p>给定一个图,设第<span class="math inline">\(i\)</span>条边的权值为<span class="math inline">\(w_i\)</span>,求所有生成树的<span class="math inline">\(( \sum_{ i = 1 }^{ n - 1 } w_i
)^k\)</span>之和.</p>
<p>考虑将第<span class="math inline">\(e\)</span>条边边权改为<span class="math inline">\(\sum_{ i = 0 }^k \cfrac{ w_e^i x^i }{ i !
}\)</span>.根据多项式定理,显然最后取<span class="math inline">\([ x^k
]\)</span>并乘以<span class="math inline">\(k !\)</span>即可.</p>
<h5><span id="有向图情况">有向图情况</span></h5>
<p>定义有向图的出度矩阵<span class="math inline">\(D^{ out } ( G ) =
\begin{cases}0 &amp; i \ne j \\ \deg^{ out }_i &amp; i =
j\end{cases}\)</span>,类似地可以定义入度矩阵<span class="math inline">\(D^{ in } ( G )\)</span>.</p>
<p>令<span class="math inline">\(cnte ( i , j )\)</span>为从<span class="math inline">\(i\)</span>直接连向<span class="math inline">\(j\)</span>的有向边个数,定义有向图的邻接矩阵<span class="math inline">\(A ( G )_{ i , j } = \begin{cases}0 &amp; i = j \\
cnte ( i , j ) &amp; i \ne j\end{cases}\)</span></p>
<p>定义有向图的出度基尔霍夫矩阵<span class="math inline">\(L^{ out } ( G
) = D^{ out } ( G ) - A ( G
)\)</span>,同理可以定义其入度基尔霍夫矩阵<span class="math inline">\(L^{
in } ( G )\)</span>.</p>
<p>记<span class="math inline">\(t^{ root } ( r , G )\)</span>为图<span class="math inline">\(G\)</span>以<span class="math inline">\(r\)</span>为根的根向生成树(<span class="math inline">\(r\)</span>为根时,所有边都从儿子指向父亲)个数,同理可以定义叶向生成树个数<span class="math inline">\(t^{ leaf } ( r , G )\)</span>.</p>
<p>设<span class="math inline">\(M^{ out }_{ r , r }\)</span>为<span class="math inline">\(L^{ out }\)</span>的主余子式,有<span class="math inline">\(t^{ root } ( r , G ) = M^{ out }_{ r , r
}\)</span>.叶向同理.</p>
<p>下面只简单提到根向生成树的证明,叶向同理.</p>
<p>类似于无向图,我们考虑构造<span class="math inline">\(n \times
m\)</span>矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(( n - 1 ) \times m\)</span>矩阵<span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
A_{ i , j } &amp; = \begin{cases}
1 &amp; e_j &#39; s \ head \ is \ i \\
- 1 &amp; e_j &#39; s \ tail \ is \ i \\
0 &amp; other
\end{cases} \\
B_{ i , j } &amp; = \begin{cases}
1 &amp; e_j &#39; s \ head \ is \ i \\
0 &amp; other
\end{cases}
\end{aligned}
\]</span></p>
<p>剩下的部分与无向图类似.</p>
<h4><span id="best定理">BEST定理</span></h4>
<p>设<span class="math inline">\(ec ( G )\)</span>为有向图<span class="math inline">\(G\)</span>的欧拉回路个数,若其存在欧拉回路,则:</p>
<p><span class="math display">\[
ec ( G ) = t^{ root } ( G , x ) \prod_{ i = 1 }^n ( \deg_i - 1 ) !
\]</span></p>
<p>其中<span class="math inline">\(\deg_i = \deg^{ in }_i = \deg_i^{ out
}\)</span>.</p>
<p>考虑如果勒令以<span class="math inline">\(x\)</span>为起点,我们保留除了<span class="math inline">\(x\)</span>以外每个点的最后经过的出边,最后一定会形成一棵根向树.而其他点可以随便选(由于我们勒令了每个点存在一个出边,所以不可能走到死胡同),这样的答案是<span class="math inline">\(t^{ root } ( G , x ) \deg_x \prod_{ i = 1 }^n (
\deg_i - 1 ) !\)</span>.</p>
<p>但是如果没有规定起点,考虑循环重构,在我们选择不同的边当作初始边时,只需循环一下总体的顺序,就可以得到以另一条边为初始边的另一个图,所以答案要比规定起点的答案多除一个<span class="math inline">\(\deg_x\)</span>.</p>
<h4><span id="格路计数问题">格路计数问题</span></h4>
<h5><span id="定义">定义</span></h5>
<ol type="1">
<li><p>在平面直角坐标系中,横坐标和纵坐标都是整数的点称为格点,平面格路是指从一个格点到另一格点只走格点的路,格路的长度是指其所走的路的步数.</p></li>
<li><p>对于一条从<span class="math inline">\(( 0 , 0 )\)</span>到<span class="math inline">\(( n , m )\)</span>的格路,若其只使用了上步<span class="math inline">\(U = ( 0 , 1 )\)</span>,右步<span class="math inline">\(L = ( 1 , 0 )\)</span>,则我们称其为<span class="math inline">\(( n , m )\)</span>自由路.</p></li>
<li><p>记<span class="math inline">\(\mathcal{ F } ( n , m
)\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路的集合,<span class="math inline">\(F ( n , m ) = \#
\mathcal{ F } ( n , m )\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路数量,即<span class="math inline">\(\mathcal{ F } ( n , m
)\)</span>的元素个数,显然<span class="math inline">\(F ( n , m ) =
\binom{ n + m }{ n } \\\)</span>.</p></li>
<li><p>对于一条从<span class="math inline">\(( 0 , 0 )\)</span>到<span class="math inline">\(( n , m
)\)</span>的自由路,若其始终不经过对角线<span class="math inline">\(y =
\cfrac{ m }{ n } x\)</span>下方,则我们称之为<span class="math inline">\(( n , m ) - Dyck\)</span>路.</p></li>
<li><p>记<span class="math inline">\(\mathcal{ D } ( n , m
)\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路的集合,<span class="math inline">\(D ( n , m ) = \#
\mathcal{ D } ( n , m )\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路数量,即<span class="math inline">\(\mathcal{ D } ( n , m
)\)</span>的元素个数.</p></li>
<li><p>对于从<span class="math inline">\(( 0 , 0 )\)</span>到<span class="math inline">\(( n , m )\)</span>的<span class="math inline">\(2\)</span>条格路<span class="math inline">\(P ,
Q\)</span>,其中<span class="math inline">\(P = u_1 u_2 . . . u_{ n + m }
, Q = v_1 v_2 . . . v_{ n + m } ( u_i , v_i \in{ L , U } , i = 1 , 2 , .
. . , n + m )\)</span>.若 <span class="math inline">\(\exists i , u_{ i
+ 1 } . . . u_{ n + m } u_1 . . . u_i = v_1 v_2 . . . v_{ n + m
}\)</span>,则我们称格路<span class="math inline">\(P ,
Q\)</span>等价.将<span class="math inline">\(P\)</span>的等价格路全集记为<span class="math inline">\([ P ]\)</span>.</p></li>
<li><p>对于任意格路<span class="math inline">\(P\)</span>,记<span class="math inline">\(P_k = u_{ k + 1 } . . . u_{ n + m } u_1 . . .
u_k\)</span>,则<span class="math inline">\([ P ] = \{ P_k | k = 1 , 2 ,
3 , · · · , n + m \}\)</span>.定义<span class="math inline">\(P\)</span>的周期为使得<span class="math inline">\(P = P_k\)</span>的最小数<span class="math inline">\(k\)</span>，用<span class="math inline">\(period (
P )\)</span>表示,则显然有<span class="math inline">\(\# [ P ] = period (
P )\)</span>.</p></li>
</ol>
<h5><span id="定理">定理</span></h5>
<h4><span id="散模型">散模型</span></h4>
<h5><span id="多叉堆计数">多叉堆计数</span></h5>
<p>有一棵树,要求给每个点一个<span class="math inline">\([ 1 , n
]\)</span>的权值且不同的点权值不同,满足父亲的权值小于儿子的权值,求方案数.</p>
<p>不妨设以<span class="math inline">\(u\)</span>为根节点的子树方案数为<span class="math inline">\(f_u\)</span>,<span class="math inline">\(u\)</span>的儿子是<span class="math inline">\(v_1
, . . . , v_k\)</span>,注意到<span class="math inline">\(f_u = \binom{
siz_u - 1 }{ siz_{ v_1 } , siz_{ v_2 } , . . . , siz_{ v_k } } \prod f_{
v_i } = ( siz_u - 1 ) ! \prod_{ u \rightarrow v } \frac{ f_{ v } }{
siz_v ! } \\\)</span>.</p>
<p>那么考虑根的答案<span class="math inline">\(f_1\)</span>,考虑不断将<span class="math inline">\(f_1\)</span>中含有的其它<span class="math inline">\(f_u\)</span>向下展开,自然的,除了<span class="math inline">\(1\)</span>号点外,每个点对答案都贡献了一个<span class="math inline">\(\frac{ 1 }{ siz }\)</span>,而根的贡献是<span class="math inline">\(( n - 1 ) !\)</span>.</p>
<p>也就是说,<span class="math inline">\(ans = ( n - 1 ) ! \prod_{ u = 2
}^n \frac{ 1 }{ siz_u } = n ! \prod_{ u = 1 }^n \frac{ 1 }{ siz_u }
\\\)</span>.</p>
<h6><span id="example1agc060c-large-heap">Example1([AGC060C] Large Heap)</span></h6>
<p>如果没有限制,就是一个简单的多叉堆计数.</p>
<p>而有了限制怎么做呢?我们考虑把<span class="math inline">\(u\)</span>到<span class="math inline">\(1\)</span>的路径和<span class="math inline">\(v\)</span>到<span class="math inline">\(1\)</span>的路径归并起来,会得到一条长链.我们只要确定了长链上的元素,通过组合数以及二叉堆计数,自然可以算出不在长链上的元素的答案.而对于长链上的元素,我们可以直接设计一个<span class="math inline">\(O ( n^2 )\)</span>的dp即可.</p>
<h6><span id="example2heoi2013sao">Example2([HEOI2013]SAO)</span></h6>
<p>显然给出的是一张树形图,然后每条边有一个限制表示这条边所连接的两个点哪个更大.现在给每个点一个<span class="math inline">\([ 1 , n
]\)</span>的权值且不同的点权值不同求方案数.</p>
<p>我们随便找一个点然后当成有根树做,然后如果只有父亲小于儿子的边就是简单的多叉堆计数.不然,我们可以做一个简单容斥.这样问题就又转化回多叉堆计数,容斥部分写一个树形dp就好.</p>
<p>补一下,这个树形dp没有那么简单.首先你注意到多叉堆计数是跟子树大小有关系的,所以你不能简单地设计<span class="math inline">\(f_{ i , j }\)</span>表示<span class="math inline">\(i\)</span>子树内选中了<span class="math inline">\(j\)</span>条边的代价,你必须加一维来处理子树大小,也就是设<span class="math inline">\(f_{ u , siz , cnt }\)</span>表示<span class="math inline">\(u\)</span>所在连通块大小为<span class="math inline">\(siz\)</span>,子树中总共选择了<span class="math inline">\(cnt\)</span>条边的代价.</p>
<p>但是注意到这题的容斥系数是<span class="math inline">\(( - 1
)^k\)</span>,其中<span class="math inline">\(k\)</span>是选择的儿子小于父亲的数量,然后其它的要求儿子大于父亲的边随便选.你发现你选中了一条边,无非是对答案乘以一个<span class="math inline">\(- 1\)</span>,这是没有必要记录的.因此直接以<span class="math inline">\(f_{ u , siz }\)</span>的状态转移就行.</p>
<p>这个故事告诉我们别什么容斥都最后算,你能在做的过程中把<span class="math inline">\(- 1\)</span>乘上去就别惦记最后统一求和了.</p>
<h5><span id="三元环计数">三元环计数</span></h5>
<p>我们对原图建立一个新的有向图,在新图中,如果<span class="math inline">\(u \rightarrow v\)</span>,则在原图中<span class="math inline">\(\deg u &lt; \deg v\)</span>或<span class="math inline">\(\deg u = \deg v \land u &lt;
v\)</span>.根据自然根号,每个点的出度不会超过<span class="math inline">\(O ( \sqrt{ n } )\)</span>.</p>
<p>接下来枚举原图的一条边<span class="math inline">\(u \leftrightarrow
v\)</span>,只要在新的图中找到<span class="math inline">\(w\)</span>满足<span class="math inline">\(u
\rightarrow v , u \rightarrow w , v \rightarrow
w\)</span>即可.打tag做一做,复杂度<span class="math inline">\(O ( n
\sqrt{ n } )\)</span>.</p>
<h5><span id="四元环计数">四元环计数</span></h5>
<p>仍然类似三元环计数那样建立新图.</p>
<p>考虑原图中的两条边<span class="math inline">\(u \leftrightarrow
v\)</span>和<span class="math inline">\(u \leftrightarrow v
&#39;\)</span>,我们考虑对四元环中度数最大的那个点<span class="math inline">\(w\)</span>计数,对于这个<span class="math inline">\(w\)</span>统计一个tag表示形如<span class="math inline">\(u \leftrightarrow v \rightarrow
w\)</span>的数量,每次改变<span class="math inline">\(u\)</span>的时候清空一下全图tag.</p>
<h5><span id="有标号dag计数">有标号DAG计数</span></h5>
<p>即:</p>
$$
<span class="math display">\[\begin{aligned}
f_n &amp; = \sum_{ k = 1 }^n \binom{ n }{ k } ( - 1 )^{ k - 1 } 2^{ k (
n - k ) } f_{ n - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明见反演与容斥-子集反演-Example2.</p>
<h6><span id="example1qoj5749">Example1(qoj5749)</span></h6>
<p>注意到一个环内部不能有任何边,那么其实也就是有标号DAG计数,只不过要乘上一个斯特林数.不妨设<span class="math inline">\(g_{ n , m }\)</span>为<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的答案,再设<span class="math inline">\(G_n\)</span>为其生成函数.事实上,我们自然有:</p>
$$
<span class="math display">\[\begin{aligned}
G_n &amp; = \sum_{ k = 1 } \binom{ n }{ k } \sum_{ j = 1 }^k{ k \brack j
} ( - 1 )^{ j - 1 } ( 1 + z )^{ k ( n - k ) } G_{ n - k } \\
&amp; = \sum_{ k = 1 } \binom{ n }{ k } ( 1 + z )^{ k ( n - k ) } G_{ n
- k } \sum_{ j = 1 }^k{ k \brack j } ( - 1 )^{ j - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>逆用斯特林公式,如果<span class="math inline">\(n \geq 1\)</span>:</p>
<p><span class="math display">\[
\sum_{ i }{ n \brack i } ( - 1 )^{ i - 1 } = ( - 1 ) \times ( - 1 )^{
\overline{ n } } = [ n = 1 ]
\]</span></p>
<p>注意到<span class="math inline">\(G_1 = 1\)</span>,于是:</p>
<p><span class="math display">\[
\begin{aligned}
G_n &amp; = n ( 1 + z )^{ n - 1 } G_{ n - 1 } \\
&amp; = n ! ( 1 + z )^{ \frac{ n ( n - 1 ) }{ 2 } } \\
[ z^m ] G_n &amp; = n ! \binom{ \frac{ n ( n - 1 ) }{ 2 } }{ m }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" class="post-title-link" itemprop="url">反演与容斥</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-04 00:40:55" itemprop="dateModified" datetime="2025-08-04T00:40:55+08:00">2025-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="反演">反演</span></h2>
<p>假设有两个函数<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>满足:<span class="math inline">\(f ( n )
= \sum_{ k } a_{ n , k } g ( k )\)</span>,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( S ) &amp; = \sum_{ T \subseteq S } g ( T ) \Leftrightarrow g ( S ) =
\sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } f ( T ) \\
f ( S ) &amp; = \sum_{ S \subseteq T \subseteq U } g ( T )
\Leftrightarrow g ( S ) = \sum_{ S \subseteq T \subseteq U } ( - 1 )^{ |
T | - | S | } f ( T )
\end{aligned}
\]</span></p>
<p>证明:</p>
<p><span class="math display">\[
\begin{aligned}
g ( S ) &amp; = \sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } f ( T )
\\
&amp; = ( - 1 )^{ | S | } \sum_{ T \subseteq S } ( - 1 )^{ | T | }
\sum_{ P \subseteq T } g ( P ) \\
&amp; = ( - 1 )^{ | S | } \sum_{ P \subseteq S } g ( P ) \sum_{ T
\subseteq S / P } ( - 1 )^{ | T | + | P | } \\
&amp; = ( - 1 )^{ | S | } \sum_{ P \subseteq S } g ( P ) ( - 1 )^{ | P |
} \sum_{ T \subseteq S / P } ( - 1 )^{ | T | } \\
&amp; = ( - 1 )^{ | S | } \sum_{ P \subseteq S } g ( P ) [ S = P ] ( - 1
)^{ | P | } \\
&amp; = g ( S )
\end{aligned}
\]</span></p>
<p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5>
<p>根据子集反演,设<span class="math inline">\(cnt_S\)</span>为集合为<span class="math inline">\(S\)</span>的数量,然后设<span class="math inline">\(f_S = \sum_{ S &#39; \subseteq S } cnt_{ S &#39;
}\)</span>,有:<span class="math inline">\(ans = \sum_{ S } 2^{ f_S } ( -
1 )^{ n - | S | }\)</span>.</p>
<p>做一遍高维前缀和就好,复杂度<span class="math inline">\(O ( n 2^n
)\)</span>,应该也可以用分治FMT无脑做到<span class="math inline">\(O (
n^2 2^n )\)</span>.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5>
<p>设<span class="math inline">\(f_{ i , j }\)</span>表示<span class="math inline">\(i\)</span>个点,其中有<span class="math inline">\(j\)</span>个点的入度数为<span class="math inline">\(0\)</span>的方案数.(等一下,为撒子想到要记度数为<span class="math inline">\(0\)</span>的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这<span class="math inline">\(j\)</span>个点后,还剩下<span class="math inline">\(k\)</span>个零度点.于是自然有:</p>
<p><span class="math display">\[
f_{ i , j } = \binom{ i }{ j } \sum_{ k = 1 }^{ i - j } ( 2^j - 1 )^k
2^{ j ( i - j - k ) } f_{ i - j , k }
\]</span></p>
<p>等一下咧,这复杂度<span class="math inline">\(O ( n^3
)\)</span>了,这咋办啊?</p>
<p>好像转移优化不太了,因为<span class="math inline">\(k\)</span>很难省去(在指数上).但我们注意到我们定义的时候说:<span class="math inline">\(0\)</span>度点的数量恰好为<span class="math inline">\(k\)</span>,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少<span class="math inline">\(k\)</span>个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设<span class="math inline">\(f ( n , S )\)</span>表示<span class="math inline">\(n\)</span>个点,其中只有<span class="math inline">\(S\)</span>中的点的入度为<span class="math inline">\(0\)</span>;类似定义<span class="math inline">\(g (
n , S )\)</span>表示<span class="math inline">\(n\)</span>个点,至少<span class="math inline">\(S\)</span>中的点的入度为<span class="math inline">\(0\)</span>.显然我们所求也就是<span class="math inline">\(g ( n , \emptyset )\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n , S ) &amp; = 2^{ | S | ( n - | S | ) } g ( n - | S | , \emptyset
) \\
g ( n , S ) &amp; = \sum_{ S \subseteq T } f ( n , T )
\end{aligned}
\]</span></p>
<p>对第二个式子用子集反演,有:</p>
<p><span class="math display">\[
f ( n , S ) = \sum_{ S \subseteq T } ( - 1 )^{ | T | - | S | } g ( n , T
)
\]</span></p>
<p>接下来使用反复带入大法:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , \emptyset ) &amp; = \sum_{ \emptyset \ne T } f ( n , T ) \\
&amp; = \sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } g ( n , S ) \\
&amp; = \sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } 2^{ | S | ( n -
| S | ) } g ( n - | S | , \emptyset ) \\
&amp; = \sum_{ m = 1 }^n \sum_{ | T | = m } \sum_{ T \subseteq S } ( - 1
)^{ | S | - | T | } 2^{ | S | ( n - | S | ) } g ( n - | S | , \emptyset
) \\
&amp; = \sum_{ m = 1 }^n \binom{ n }{ m } \sum_{ k = m }^n \binom{ n - m
}{ k - m } ( - 1 )^{ k - m } 2^{ k ( n - k ) } g ( n - k , \emptyset )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ m = 1 }^n \binom{ n }{ m } \sum_{ k = m }^n \binom{ n - m
}{ k - m } ( - 1 )^{ k - m } 2^{ k ( n - k ) } g ( n - k , \emptyset )
\\
= &amp; \sum_{ k = 1 }^n \sum_{ m = 1 }^k \binom{ n }{ m } \binom{ n - m
}{ k - m } ( - 1 )^{ k - m } 2^{ k ( n - k ) } g ( n - k , \emptyset )
\\
= &amp; \sum_{ k = 1 }^n \binom{ n }{ k } 2^{ k ( n - k ) } g ( n - k ,
\emptyset ) \sum_{ m = 1 }^k \binom{ k }{ m } ( - 1 )^{ k - m } \\
= &amp; \sum_{ k = 1 }^n \binom{ n }{ k } 2^{ k ( n - k ) } g ( n - k ,
\emptyset ) ( ( 1 - 1 )^k - ( - 1 )^k ) \\
= &amp; \sum_{ k = 1 }^n \binom{ n }{ k } 2^{ k ( n - k ) } g ( n - k ,
\emptyset ) ( - 1 )^{ k - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到复杂度已经降到<span class="math inline">\(O ( n^2
)\)</span>了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个<span class="math inline">\(( - 1 )^{ k - 1
}\)</span>,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
$$
<span class="math display">\[\begin{aligned}
f_n &amp; = \sum_{ k = 1 }^n \binom{ n }{ k } ( - 1 )^{ k - 1 } 2^{ k (
n - k ) } f_{ n - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是直接设,然后钦定其有至少<span class="math inline">\(j\)</span>个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = 0 }^n C_n^k g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) \\
f ( n ) &amp; = \sum_{ k = 0 }^n ( - 1 )^k \binom{ n }{ k } g ( k )
\Leftrightarrow g ( n ) = \sum_{ k = 0 }^n ( - 1 )^k \binom{ n }{ k } f
( k ) \\
f ( n ) &amp; = \sum_{ k = n }^N C_k^n g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = n }^N ( - 1 )^{ k - n } C_k^n f ( k ) \\
f ( n ) &amp; = \sum_{ k = n }^N ( - 1 )^k \binom{ k }{ n } g ( k )
\Leftrightarrow g ( n ) = \sum_{ k = n }^N ( - 1 )^k \binom{ k }{ n } f
( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然以<span class="math inline">\(( - 1 )^n g ( n )\)</span>代替<span class="math inline">\(g ( n
)\)</span>即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ k = 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) \\
&amp; = \sum_{ m = 0 }^n \sum_{ k = 0 }^{ n - m } ( - 1 )^k C_{ n - m
}^k C_n^m g ( m ) \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^k C_n^k \sum_{ m = 0 }^{ n - k } C_{ n
- k }^m g ( m ) \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^k C_n^k f ( n - k ) \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example1错排问题">Example1(错排问题)</span></h5>
<p><span class="math inline">\(n\)</span>个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设<span class="math inline">\(f ( n )\)</span>为<span class="math inline">\(n\)</span>个人随便站的方案数,<span class="math inline">\(g ( n )\)</span>为<span class="math inline">\(n\)</span>个人都站错的方案数.</p>
<p>如果知道<span class="math inline">\(g\)</span>的表达式,我们可以通过枚举有多少人站错位置来得到<span class="math inline">\(f\)</span>,即:<span class="math inline">\(f ( n )
= \sum_{ k = 0 }^n C_n^k g ( k )\)</span>.</p>
<p>显然就是一个二项式反演,<span class="math inline">\(g ( n ) = \sum_{ k
= 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) = \sum_{ k = 0 }^n ( - 1 )^{ n -
k } C_n^k k !\)</span>.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:<span class="math inline">\(g ( n ) = n ! \sum_{ 0 \leq k \leq n } \cfrac{ ( -
1 )^k }{ k ! } \\\)</span>.</p>
<p>不难发现<span class="math inline">\(n !\)</span>的后面形如<span class="math inline">\(e^{ - 1
}\)</span>的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n ) &amp; = \cfrac{ n ! }{ e } - n ! \sum_{ k &gt; n } \cfrac{ ( - 1
)^k }{ k ! } \\
&amp; = \cfrac{ n ! }{ e } - \cfrac{ ( - 1 )^{ n + 1 } }{ n + 1 } \sum_{
0 \leq k } ( - 1 )^k \cfrac{ ( n + 1 ) ! }{ ( k + n + 1 ) ! }
\end{aligned}
\]</span></p>
<p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有<span class="math inline">\(g ( n ) = \lfloor \cfrac{ n ! }{ e } + \cfrac{ 1
}{ 2 } \rfloor + [ n = 0 ]\)</span>.</p>
<p>另外,观察<span class="math inline">\(g\)</span>关于<span class="math inline">\(f\)</span>的表达式,不难求出<span class="math inline">\(g\)</span>的递推式:<span class="math inline">\(g (
n ) = ng ( n - 1 ) + ( - 1 )^n\)</span>.</p>
<p>下面证明<span class="math inline">\(g_n = ( n - 1 ) ( g_{ n - 1 } +
g_{ n - 2 } )\)</span>,事实上,右边等于:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; ( n - 1 ) ( g_{ n - 1 } + g_{ n - 2 } ) \\
= &amp; ( - 1 )^{ n - 1 } ( n - 1 ) + ( n - 1 ) \sum_{ k = 0 }^{ n - 2 }
( ( n - 1 ) ! \frac{ ( - 1 )^k }{ k ! } + ( n - 2 ) ! \frac{ ( - 1 )^k
}{ k ! } ) \\
= &amp; n ! \sum_{ k = 0 }^{ n - 2 } \frac{ ( - 1 )^k }{ k ! } - ( n - 1
) ( - 1 )^n \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example2cf1750g">Example2(CF1750G)</span></h5>
<p>如果没有字典序限制就是经典的二项式反演:考虑能被分为<span class="math inline">\(k\)</span>段,说明有<span class="math inline">\(n -
k\)</span>个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了<span class="math inline">\(x\)</span>个数字,<span class="math inline">\(y\)</span>个区间,那么钦定<span class="math inline">\(j\)</span>对的方案是<span class="math inline">\(\binom{ x - y }{ j } ( x - j )
!\)</span>.然后要乘上前面已经有了的,也就是乘上形如<span class="math inline">\(( 1 + z )^k\)</span>.这样复杂度<span class="math inline">\(O ( n^4 )\)</span>.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的<span class="math inline">\(x , y , k\)</span>有<span class="math inline">\(O
( 1 )\)</span>种不同的取值,因此不用枚举.这样就是<span class="math inline">\(O ( n^3
)\)</span>.但是那个多项式乘法也可以规避,考虑最后的答案形如<span class="math inline">\(\sum ( 1 + z )^k P_k ( x
)\)</span>,我们考虑写成<span class="math inline">\(P_{ n - 1 } ( z ) + =
( 1 + z ) P_n ( z )\)</span>,然后不断这么做,就只需要<span class="math inline">\(O ( n^2 )\)</span>.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5>
<p>不妨设至多有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(f_{
i , j }\)</span>,恰好有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(g_{
i , j }\)</span>,注意到:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>令<span class="math inline">\(h_{ n , m } = \sum_{ j = 0 }^m \binom{
m }{ j } g_{ n , j } \\\)</span>,则<span class="math inline">\(f_{ n , m
} = \sum_{ i = 0 }^n \binom{ n }{ i } h_{ i , m } \\\)</span>,而<span class="math inline">\(f_{ n , m } = k^{ nm } ( k - 1 )^{ NM - nm
}\)</span>.做两次二项式反演得到<span class="math inline">\(g\)</span>.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥<span class="math inline">\(f_{ n , m } \ne \binom{ N }{ n } \binom{ M }{ m }
k^{ nm } ( k - 1 )^{ NM - nm }\)</span>呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ S , T } &amp; = \sum_{ s \subseteq S } \sum_{ t \subseteq T } g_{ s
, t } \\
f_{ S , T } &amp; = \sum_{ s \subseteq S } h_{ s , T } \\
h_{ S , T } &amp; = \sum_{ t \subseteq T } g_{ S , t } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ S , T } &amp; = k^{ | S | \times | T | } ( k - 1 )^{ NM - | S | | T
| } \\
h_{ s , T } &amp; = \sum_{ S \subseteq s } ( - 1 )^{ | s | - | S | } f_{
S , T } \\
g_{ s , t } &amp; = \sum_{ T \subseteq t } ( - 1 )^{ | t | - | T | } h_{
s , T }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,<span class="math inline">\(g_{ n , m
}\)</span>本身就包含了所有<span class="math inline">\(| S | = n , | T |
= m\)</span>的情况的和,并且在组合数<span class="math inline">\(\binom{ m
}{ j }\)</span>那里就找到了唯一确定的<span class="math inline">\(f_{ s ,
t }\)</span>,因此<span class="math inline">\(f_{ n , m
}\)</span>是唯一确定的.这意味着这里<span class="math inline">\(f\)</span>的<span class="math inline">\(n ,
m\)</span>并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp; = 2^{ 2^{ n - i } } \binom{ n }{ i } \\
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } g_i \\
g_k &amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \binom{ i }{ k } f_i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>这个问题其实非常显然,我们的<span class="math inline">\(g_{ i , j
}\)</span>定义为所有<span class="math inline">\(| S | = i , | T | =
j\)</span>的答案之和.<span class="math inline">\(f\)</span>也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ N - i }{ n - i } \sum_{ j = 0 }^m
\binom{ M - j }{ m - j } g_{ i , j }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求<span class="math inline">\(g_{ N , M }\)</span>,那此时<span class="math inline">\(g\)</span>怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } g_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,<span class="math inline">\(g\)</span>是已知的集合,<span class="math inline">\(f\)</span>是未知的集合.我们乘上组合数就可以得到对于<span class="math inline">\(f\)</span>来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把<span class="math inline">\(f\)</span>的定义改成<span class="math inline">\(f_{ n , m } = k^{ nm } ( k - 1 )^{ NM - nm
}\)</span>就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的集合的前提下,从中选出<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列并求<span class="math inline">\(g\)</span>.那么你从哪知道的<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列呢?你得组合数啊!</p>
<p>所以,实际上的<span class="math inline">\(f\)</span>是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ n , m } &amp; = \binom{ N }{ n } \binom{ M }{ m } \sum_{ i = 0 }^n
\binom{ n }{ i } \sum_{ j = 0 }^m \binom{ m }{ j } g_{ i , j } \\
f_{ n , m } &amp; = \binom{ N }{ n } \binom{ M }{ m } k^{ nm } ( k - 1
)^{ NM - nm }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = n }^N C_n^k g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = n }^N ( - 1 )^{ k - n } C_n^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设<span class="math inline">\(f &#39;_{ i , j }\)</span>为至少有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列不满足条件的方案数,自然有<span class="math inline">\(f &#39;_{ i , j } = f_{ N - i , M - j
}\)</span>.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39;_{ n , m } = \sum_{ i = n }^N \binom{ i }{ n } \sum_{ j = m }^M
\binom{ j }{ m } g &#39;_{ i , j }
\]</span></p>
<p>最后答案就是<span class="math inline">\(g &#39;_{ 0 , 0
}\)</span>.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) = \sum_{ k = 0 }^n
\left [ \begin{array}
{ c } n \\
k
\end{array} \right ] ( - 1 )^{ n - k } f ( k ) \\
f ( n ) &amp; = \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) = \sum_{ k = 0 }^n
\left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^{ n - k } f ( k ) \\
f ( m ) &amp; = \sum_{ n = m }^M ( - 1 )^{ m - n } \left [ \begin{array}
{ c } n \\
m
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) = \sum_{ k = 0 }^M
\left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} f ( k ) \\
f ( m ) &amp; = \sum_{ n = m }^M ( - 1 )^{ m - n } \left \{
\begin{array}
{ c } n \\
m
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) = \sum_{ k = 0 }^M
\left [ \begin{array}
{ c } k \\
m
\end{array} \right ] f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} ( - 1 )^{ n - k } &amp; = \sum_{ k = 0 }^n \left
\{ \begin{array}
{ c } n \\
k
\end{array} \right \} \left [ \begin{array}
{ c } k \\
m
\end{array} \right ] ( - 1 )^{ n - k } = [ m = n ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ m = 0 }^n [ m = n ] g ( m ) \\
&amp; = \sum_{ m = 0 }^n \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} ( - 1 )^{ n - k } g ( m ) \\
&amp; = \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] ( - 1 )^{ n - k } \sum_{ m = 0 }^k \left \{
\begin{array}
{ c } k \\
m
\end{array} \right \} g ( m ) = \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] ( - 1 )^{ n - k } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( m ) &amp; = \sum_{ n = m }^M [ n = m ] g ( n ) \\
&amp; = \sum_{ n = m }^M \sum_{ k = 0 }^M \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} ( - 1 )^{ n - k } g ( n ) \\
&amp; = \sum_{ k = 0 }^M \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( n ) &amp; = \sum_{ d | n } g ( d ) \Leftrightarrow g ( n ) = \sum_{
d | n } \mu ( \frac{ n }{ d } ) f ( d ) \\
f ( n ) &amp; = \sum_{ n | d } g ( d ) \Leftrightarrow g ( n ) = \sum_{
n | d } \mu ( \frac{ d }{ n } ) f ( d ) \\
f ( x ) &amp; = \sum_{ 1 \leq d } g ( d ) \Leftrightarrow g ( x ) =
\sum_{ 1 \leq d } f ( \cfrac{ x }{ d } ) \mu ( d )
\end{aligned}
\]</span></p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ m | n } [ \frac{ n }{ m } = 1 ] g ( m ) \\
&amp; = \sum_{ m | n } \sum_{ d | \frac{ n }{ m } } \mu ( d ) g ( m ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\([ d | \frac{ n }{ m } ] = [ md | n
] = [ m | \frac{ n }{ d } ] \\\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ d | n } \mu ( d ) \sum_{ m | \frac{ n }{ d } } g
( m ) \\
&amp; = \sum_{ d | n } \mu ( d ) f ( \frac{ n }{ d } ) \\
&amp; = \sum_{ d | n } \mu ( \frac{ n }{ d } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第二个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ n | d } [ \frac{ d }{ n } = 1 ] g ( d ) \\
&amp; = \sum_{ n | d } \sum_{ c | \frac{ d }{ n } } \mu ( c ) g ( d ) \\
&amp; = \sum_{ c | d } \sum_{ nc | d } \mu ( c ) g ( d ) \\
&amp; = \sum_{ c } \mu ( c ) f ( nc ) \\
&amp; = \sum_{ n | d } \mu ( \frac{ d }{ n } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 1 \leq d } g ( \cfrac{ x }{ d } ) \mu ( d ) &amp; = \sum_{ d \geq
1 } \mu ( d ) \sum_{ k \geq 1 } f ( \cfrac{ x }{ kd } ) \\
&amp; = \sum_{ m \geq 1 } f ( \cfrac{ x }{ m } ) \sum_{ d , k \geq 1 } [
m = dk ] \mu ( d ) \\
&amp; = \sum_{ m \geq 1 } f ( \cfrac{ x }{ m } ) \sum_{ d | m } \mu ( d
) \\
&amp; = f ( x )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>求长度为<span class="math inline">\(n\)</span>且仅包含小写英文字母且循环节长度恰为<span class="math inline">\(n\)</span>的字符串个数.</p>
<p>不妨设<span class="math inline">\(f ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>的字符串个数,<span class="math inline">\(g ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>且循环节长度恰为<span class="math inline">\(n\)</span>的字符串个数.</p>
<p>有<span class="math inline">\(f ( n ) = \sum_{ d | n } g ( d
)\)</span>,根据莫比乌斯反演,<span class="math inline">\(g ( n ) = \sum_{
d | n } \mu ( \cfrac{ n }{ d } ) f ( d )\)</span>.</p>
<h4><span id="example2">Example2</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m
gcd ( i , j ) \\\)</span>.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m gcd ( i , j ) &amp; = \sum_{ i = 1
}^n \sum_{ j = 1 }^m id [ gcd ( i , j ) ] \\
&amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^m \sum_{ d | gcd ( i , j ) }
\varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="交换枚举顺序">交换枚举顺序</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n \sum_{ j = 1 }^m \sum_{ d | gcd ( i , j ) } \varphi ( d
) &amp; = \sum_{ d = 1 }^{ \min ( n , m ) } \sum^{ \lfloor \frac{ n }{ d
} \rfloor }_{ i = 1 } \sum^{ \lfloor \frac{ m }{ d } \rfloor }_{ j = 1 }
\varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="分离无关变量">分离无关变量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ d = 1 }^{ \min ( n , m ) } \sum^{ \lfloor \frac{ n }{ d } \rfloor
}_{ i = 1 } \sum^{ \lfloor \frac{ m }{ d } \rfloor }_{ j = 1 } \varphi (
d ) &amp; = \sum^{ \min ( n , m ) }_{ d = 1 } \varphi ( d ) \times
\lfloor \cfrac{ n }{ d } \rfloor \times \lfloor \cfrac{ m }{ d } \rfloor
\\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑使用数论分块,只需处理出<span class="math inline">\(\varphi ( d
)\)</span>的前缀和即可在<span class="math inline">\(O ( \sqrt{ n } +
\sqrt{ m } )\)</span>的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m [
gcd ( i , j ) = 1 ] \\\)</span>.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从<span class="math inline">\(id\)</span>变为了<span class="math inline">\(\epsilon\)</span>.</p>
<h4><span id="example4">Example4</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m [
gcd ( i , j ) \in \mathrm{ prime } ] \\\)</span>.</p>
<p>考虑增加枚举量,则:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m [ gcd ( i , j ) &amp; \in \mathrm{
prime } ] = \sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m \sum_{ p \in \mathrm{
prime } } [ gcd ( i , j ) = p ] \\
&amp; = \sum_{ p \in \mathrm{ prime } } \sum^{ \lfloor \frac{ n }{ d }
\rfloor }_{ i = 1 } \sum^{ \lfloor \frac{ m }{ d } \rfloor }_{ j = 1 } [
gcd ( pi , pj ) = p ] \\
&amp; = \sum_{ p \in \mathrm{ prime } } \sum^{ \lfloor \frac{ n }{ p }
\rfloor }_{ i = 1 } \sum^{ \lfloor \frac{ m }{ p } \rfloor }_{ j = 1 } [
gcd ( i , j ) = 1 ] \\
&amp; = \sum_{ p \in \mathrm{ prime } } \sum_{ d = 1 }^{ \min ( \lfloor
\frac{ m }{ p } \rfloor , \lfloor \frac{ n }{ p } \rfloor ) } \mu ( d )
\lfloor \cfrac{ n }{ pd } \rfloor \lfloor \cfrac{ m }{ pd } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5>
<p>考虑设<span class="math inline">\(x = pd\)</span>,则变为<span class="math inline">\(\sum_{ x = 1 }^{ \min ( n , m ) } \sum_{ p \in
\mathrm{ prime } \land p | x } \mu ( \frac{ x }{ p } ) \lfloor \frac{ n
}{ x } \rfloor \lfloor \frac{ m }{ x } \rfloor \\\)</span>.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4>
<p>首先先考虑去掉<span class="math inline">\(lcm\)</span>使得式子中只有<span class="math inline">\(i , j , \gcd ( i , j )\)</span>.</p>
<p>显然可以构造函数<span class="math inline">\(f ( x ) = x^{ c - d } , g
( x ) = x^d , h ( x ) = x^d \\\)</span>,然后将题目转化为<span class="math inline">\(\sum_{ j = 1 }^n f ( gcd ( i , j ) ) g ( i ) h ( j
) x_j \equiv b_i ( \mod p ) \\\)</span>.</p>
<p><span class="math inline">\(\gcd ( i , j
)\)</span>很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出<span class="math inline">\(f_r ( n )\)</span>使得<span class="math inline">\(f ( n ) = \sum_{ d | n } f_r ( d )
\\\)</span>,也即<span class="math inline">\(f_r ( n ) = \sum_{ d | n }
\mu ( \cfrac{ n }{ d } ) f ( d )\)</span>.</p>
<p>则原式即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ j = 1 }^n \sum_{ d } [ d | i ] [ d | j ] f_r ( d ) g ( i ) h ( j
) x_j &amp; \equiv b_i ( \mod p ) \\
\sum_{ d | i } f_r ( d ) \sum_{ j = 1 }^n [ d | j ] h ( j ) x_j &amp;
\equiv \frac{ b_i }{ g ( i ) } ( \mod p ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(z_d = \sum_{ j = 1 }^n [ d | j ] h ( j
) x_j \\\)</span>,有<span class="math inline">\(\sum_{ d | i } f_r ( d )
z_d \equiv \frac{ b_i }{ g ( i ) } ( \mod p ) \\\)</span>.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出<span class="math inline">\(z_d\)</span>.</p>
<p>而<span class="math inline">\(z_d = \sum_{ j = 1 }^n [ d | j ] h ( j
) x_j = \sum_{ d | j }^n h ( j )
x_j\)</span>,可以再次使用莫比乌斯反演求出<span class="math inline">\(h (
j ) x_j\)</span>,进而求<span class="math inline">\(x_j\)</span>.</p>
<p>无解条件显然是<span class="math inline">\(g_i = 0 \land x_i \ne
0\)</span>.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol type="1">
<li><p>通过增加枚举量消掉<span class="math inline">\(lcm\)</span>以及<span class="math inline">\(\gcd\)</span>这些难以处理的项.</p></li>
<li><p>将<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>尽量分到式子两边.</p></li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p></li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4>
<p>首先注意到一个重要的事实:我们只需要询问所有<span class="math inline">\(\mu ( x ) \ne 0\)</span>的<span class="math inline">\(x\)</span>,就可以得到全部信息,而这些<span class="math inline">\(x\)</span>的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \bigoplus_{ i \in A } i [ \gcd ( i , n ) = 1 ] \\
&amp; = \bigoplus_{ i \in A }^c i \sum_{ d | i , d | n } \mu ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(\sum_{ d | i } \mu ( d ) =
\bigoplus_{ d | i } | \mu ( d ) |\)</span>,于是:</p>
<p><span class="math display">\[
f ( n ) = \bigoplus_{ d | n } | \mu ( d ) | \bigoplus_{ d | i , i \in A
} i
\]</span></p>
<p>接下来只要我们形式上写作<span class="math inline">\(n\)</span>,我们就默认<span class="math inline">\(\mu ( n ) \ne 0\)</span>,又令<span class="math inline">\(g ( n ) = \bigoplus_{ n | i , i \in A }
i\)</span>,此时自然有<span class="math inline">\(f ( n ) = \bigoplus_{ d
| n } g ( d )
\\\)</span>.这是一个经典的莫反形式,我们再反演回去就可以得到<span class="math inline">\(g ( n ) = \bigoplus_{ d | n } \mu ( \frac{ n }{ d
} ) f ( d ) = \bigoplus_{ d | n } f ( d
)\)</span>,也就是说我们可以求得所有的<span class="math inline">\(g ( n
)\)</span>,也就是这个集合中所有是<span class="math inline">\(n\)</span>的倍数的异或值.</p>
<p>注意一个事实:如果我们设<span class="math inline">\(w ( m ) = \prod_{
p \in \mathrm{ prime } , p | m } p\)</span>,那么我们就可以按照<span class="math inline">\(w\)</span>的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进<span class="math inline">\(A\)</span>的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设<span class="math inline">\(S ( n ) = \{ x | w ( x ) = n \}\)</span>,又设<span class="math inline">\(h ( n ) = \bigoplus_{ i \in A , i \in S ( n ) }
i\)</span>.考虑用<span class="math inline">\(g ( n )\)</span>表示<span class="math inline">\(h ( n )\)</span>,我们有:</p>
<p><span class="math display">\[
g ( n ) = \bigoplus_{ n | d } | \mu ( \frac{ d }{ n } ) | h ( d )
\]</span></p>
<p>反演,有<span class="math inline">\(h ( n ) = \bigoplus_{ n | d } g (
d ) \\\)</span>.于是我们可以求得所有的<span class="math inline">\(h ( n
)\)</span>了.</p>
<p>现在的问题在于:对于数<span class="math inline">\(n , \mu ( n ) \ne
0\)</span>,我们要在<span class="math inline">\(S ( n
)\)</span>中选出若干个数,使得它们的异或和为<span class="math inline">\(h
( n )\)</span>,并且选出的数字总共有<span class="math inline">\(| A
|\)</span>个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3>
<p>设<span class="math inline">\(S\)</span>为可重集合.</p>
<p>一般形式:定义<span class="math inline">\(\mu ( S )\)</span>,若<span class="math inline">\(S\)</span>包含重复元素则为<span class="math inline">\(0\)</span>,否则为<span class="math inline">\(( - 1
)^{ | S | }\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
f ( S ) &amp; = \sum_{ T \subseteq S } g ( T ) \Leftrightarrow g ( S ) =
\sum_{ T \subseteq S } \mu ( S - T ) f ( T ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3>
<p>一般形式(<span class="math inline">\(\omega_n = e^{ \frac{ 2 \pi i }{
n } }\)</span>):</p>
<p><span class="math display">\[
f_m = \sum_{ k = 0 }^{ n - 1 } \omega_n^{ mk } g_k \Leftrightarrow g_m =
\frac{ 1 }{ n } \sum_{ k = 0 }^{ n - 1 } \omega_n^{ - mk } f_k
\]</span></p>
<p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3>
<p>考虑莫比乌斯反演的过程,我们实际上使用的是<span class="math inline">\([ m | n ] \sum_{ d | \frac{ n }{ m } } \mu ( d ) =
[ n = m ] \\\)</span>.</p>
<p>令<span class="math inline">\(c = md\)</span>,左边<span class="math inline">\(= \sum_{ c | n } [ m | c ] \mu ( \frac{ c }{ m } )
= \sum ( [ c | n ] ) ( [ m | c ] \mu ( \frac{ c }{ m } ) )
\\\)</span>.</p>
<p>令<span class="math inline">\(A_{ c , n } = [ c | n ]\)</span>,<span class="math inline">\(B_{ m , c } = [ m | c ] \mu ( \frac{ c }{ m } )
\\\)</span>,那我们有<span class="math inline">\(BA = I\)</span>.</p>
<p>刚才的过程相当于:</p>
$$
<span class="math display">\[\begin{aligned}
Ax &amp; = b \\
x &amp; = Ix \\
x &amp; = ( BA ) x \\
x &amp; = B ( Ax ) \\
x &amp; = Bb \\

\end{aligned}\]</span>
<p>$$</p>
<p>无论是二项式反演还是莫比乌斯反演,他们都满足<span class="math inline">\(f ( n )\)</span>所依赖的<span class="math inline">\(g ( k )\)</span>有<span class="math inline">\(k
\leq n \\\)</span>.</p>
<p>根据上面的情况,我们发现<span class="math inline">\(A\)</span>是一个下三角矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(A^{ - 1
}\)</span>.</p>
<p>现在来推导满足<span class="math inline">\(k \leq
n\)</span>的一般情况反演:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = 1 }^n a_{ n , k } g ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设算子<span class="math inline">\(\mu ( n , m
)\)</span>,满足<span class="math inline">\(\sum_{ k = 1 }^n a_{ n , k }
\mu ( k , m ) = \sum_{ k = 1 }^n \mu ( n , k ) a_{ k , m } = [ n = m ]
\\\)</span>.</p>
<p>即<span class="math inline">\(AB = BA = I \\\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ m = 1 }^n [ n = m ] g ( m ) \\
&amp; = \sum_{ m = 1 }^n \sum_{ k = 1 }^n \mu ( n , k ) a_{ k , m } g (
m ) \\
&amp; = \sum_{ k = 1 }^n \mu ( n , k ) f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
$$
<span class="math display">\[\begin{aligned}
c_r &amp; = \sum_{ p , q } [ f ( p , q ) = r ] a_p b_q \\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们需要把<span class="math inline">\(f\)</span>分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2>
<h4><span id="一般形式">一般形式</span></h4>
<p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:<span class="math inline">\(\mid \bigcup_{ i = 1 }^n S_i \mid
= \sum_{ T \subseteq \{ 1 , . . . , n \},T\ne \emptyset } ( - 1 )^{ | T
- 1 | } \mid \bigcap_{ p \in T } S_p \mid\)</span>.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属<span class="math inline">\(m\)</span>个集合<span class="math inline">\(S_1 ,
. . . , S_m\)</span>,而除了这些集合以外的集合,</p>
<p><span class="math display">\[
\begin{aligned}
cnt &amp; = \sum_{ i = 1 }^m ( - 1 )^{ i - 1 } \binom{ m }{ i } \\
&amp; = \binom{ m }{ 0 } - \sum_{ i = 0 }^m ( - 1 )^i \binom{ m }{ i }
\\
&amp; = 1 - [ m = 0 ]
\end{aligned}
\]</span></p>
<p>显然,当这个元素被包含的时候,贡献为<span class="math inline">\(1\)</span>,反之贡献为<span class="math inline">\(0\)</span>.</p>
<p>如果我们定义一类在集合上的函数<span class="math inline">\(F ( S ) =
\sum_{ p \in S } F ( p )\)</span>,那么自然也有:</p>
<p><span class="math display">\[
F ( \bigcup_{ i = 1 }^n S_i ) = \sum_{ T \subseteq \{ 1 , . . . , n \} }
( - 1 )^{ | T | - 1 } F ( \bigcap_{ p \in T } S_p )
\]</span></p>
<p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<p><span class="math display">\[
\mid \bigcap_{ i = 1 }^n S_i \mid = | U | - \mid \bigcup_{ i = 1 }^n
\overline{ S_i } \mid
\]</span></p>
<p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5>
<p>考虑不定方程<span class="math inline">\(\sum_{ i = 1 }^n x_i =
m\)</span>,和<span class="math inline">\(n\)</span>个限制条件<span class="math inline">\(x_i \leq b_i\)</span>,其中<span class="math inline">\(m\)</span>和<span class="math inline">\(b_i\)</span>都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件):</p>
<ol type="1">
<li><p><span class="math inline">\(U\)</span>是满足<span class="math inline">\(\sum_{ i = 1 }^n x_i =
m\)</span>的所有非负整数解;</p></li>
<li><p>对于每个变量<span class="math inline">\(i\)</span>,都对应一个<span class="math inline">\(P_i = [ x_i \leq b_i ]\)</span>.</p></li>
</ol>
<p>设所有满足<span class="math inline">\(P_i\)</span>的解构成集合<span class="math inline">\(S_i\)</span>,那么我们需要求解的值就是<span class="math inline">\(\mid \bigcap_{ i = 1 }^n S_i \mid\)</span>.而<span class="math inline">\(\mid U \mid\)</span>显然是<span class="math inline">\(\binom{ m + n - 1 }{ n - 1 }\)</span>.我们有:<span class="math inline">\(\mid \bigcap_{ i = 1 }^n S_i \mid = | U | - \mid
\bigcup_{ i = 1 }^n \overline{ S_i } \mid\)</span>.考虑对<span class="math inline">\(\mid \bigcup_{ i = 1 }^n \overline{ S_i }
\mid\)</span>使用容斥原理,注意到<span class="math inline">\(\overline{
S_i }\)</span>的意义是满足<span class="math inline">\(x_{ i } \geq b_{ i
} +
1\)</span>的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5>
<p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件):</p>
<ol type="1">
<li><p><span class="math inline">\(U\)</span>是长度为<span class="math inline">\(n\)</span>的所有排列;</p></li>
<li><p>对于每个变量<span class="math inline">\(i\)</span>,都对应一个<span class="math inline">\(P_i = [ p_i \ne i ]\)</span>.</p></li>
</ol>
<p>注意到所求仍然是<span class="math inline">\(\mid \bigcap_{ i = 1 }^n
S_i \mid\)</span>.于是我们仍然试图<span class="math inline">\(|
\bigcap_{ k = 1 }^m \overline{ S_{ a_k } }
|\)</span>.考虑其意义,也即:有<span class="math inline">\(m\)</span>个位置被确定了,而其它位置没有限制,于是<span class="math inline">\(| \bigcap_{ k = 1 }^m \overline{ S_{ a_k } } | =
\binom{ n }{ m } ( n - m ) !\)</span>.根据容斥,自然有:<span class="math inline">\(d_n = n ! - \sum_{ m = 1 }^n ( - 1 )^{ m - 1 }
\binom{ n }{ m } ( n - m ) ! = n ! \sum_{ m = 0 }^n \cfrac{ ( - 1 )^m }{
m ! }\)</span>.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5>
<p>首先可以用dp+双指针得到<span class="math inline">\(f_i\)</span>表示勒令<span class="math inline">\(i\)</span>对满足条件的方案数.把<span class="math inline">\(k\)</span>的定义改为恰好<span class="math inline">\(k\)</span>对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好<span class="math inline">\(a\)</span>对的方案会被钦定<span class="math inline">\(b\)</span>对的方案计算<span class="math inline">\(\binom{ b }{ a
}\)</span>次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为<span class="math inline">\(k\)</span>的方案贡献为<span class="math inline">\(1\)</span>,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为<span class="math inline">\(k + 1\)</span>的方案贡献为<span class="math inline">\(0\)</span>,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令<span class="math inline">\(ans = f_k\)</span>,第二步除去其中被多算的<span class="math inline">\(k + 1\)</span>,这一步令<span class="math inline">\(ans - = \binom{ k + 1 }{ k } f_{ k + 1
}\)</span>.这个时候,我们再考虑<span class="math inline">\(k +
2\)</span>的贡献:它将在<span class="math inline">\(f_k\)</span>时贡献<span class="math inline">\(\binom{ k + 2 }{ k }\)</span>次,在<span class="math inline">\(f_{ k + 1 }\)</span>时贡献<span class="math inline">\(- \binom{ k + 2 }{ k + 1 } \binom{ k + 1 }{ k } =
- \binom{ k + 2 }{ k } \binom{ 2 }{ 1
}\)</span>次,那它现在的贡献还有:<span class="math inline">\(- \binom{ k
+ 2 }{ k }\)</span>次.以此类推,可以得到<span class="math inline">\(ans =
\sum_{ i = k }^n f_i ( - 1 )^{ i - k } \binom{ i }{ k }\)</span>.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个<span class="math inline">\(P_i\)</span>.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画<span class="math inline">\(P_i\)</span>,因为只有这个时候,我们才能通过分析满不满足<span class="math inline">\(P_i\)</span>的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成<span class="math inline">\(1 / 0\)</span>就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5>
<p>如果直接对于每次询问暴力做,复杂度显然是<span class="math inline">\(O
( 4 ns )\)</span>,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画<span class="math inline">\(P_i = [ use_i \leq d_i
]\)</span>,从而可以用容斥做.复杂度<span class="math inline">\(O ( 4 s +
n 2^4 )\)</span>.</p>
<h5><span id="example5">Example5</span></h5>
<p>Alice和Bob在玩游戏,他们有一个<span class="math inline">\(n\)</span>个点的无向完全图,设所有的边组成了集合<span class="math inline">\(E\)</span>,他们想取遍<span class="math inline">\(E\)</span>的所有非空子集,对某个集合<span class="math inline">\(S\)</span>有一个估价<span class="math inline">\(f
( S )\)</span>:考虑<span class="math inline">\(n\)</span>个点与<span class="math inline">\(S\)</span>中的边组成的图,我们用<span class="math inline">\(m\)</span>种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么<span class="math inline">\(f ( S
)\)</span>等于这个图的染色方案数.同时,Alice喜欢奇数,所以当<span class="math inline">\(| S |\)</span>为奇数时,Alice的分值加上<span class="math inline">\(f ( S )\)</span>,否则Alice的分值减去<span class="math inline">\(f ( S )\)</span>,求最后的分值.<span class="math inline">\(( n , m \leq 10^6 )\)</span>.</p>
<p>一开始抄题的时候没有写染色而是直接写”设<span class="math inline">\(k\)</span>为连通块个数,则<span class="math inline">\(f ( S ) = m^k\)</span>.”然后发现做不了,因为<span class="math inline">\(| S |\)</span>相同的<span class="math inline">\(f
( S
)\)</span>不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个<span class="math inline">\(m\)</span>,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那<span class="math inline">\(x
\leftrightarrow y \Rightarrow col_x =
col_y\)</span>.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与<span class="math inline">\(-
1\)</span>有关的单位元素(从一开始就是点)和与<span class="math inline">\(f\)</span>有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令<span class="math inline">\(F ( C
)\)</span>表示在<span class="math inline">\(C\)</span>情况下的染色方案,<span class="math inline">\(T_{ ( i , j ) }\)</span>表示满足边<span class="math inline">\(( i , j )\)</span>限制的解集:</p>
<p><span class="math display">\[
ans = \sum_{ \emptyset \ne S \subseteq E } ( - 1 )^{ | S | - 1 } F (
\bigcap_{ ( i , j ) \in S } T_{ ( i , j ) } )
\]</span></p>
<p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出<span class="math inline">\(ans\)</span>的意义:显然是<span class="math inline">\(F ( \bigcup_{ i = 1 }^{ m } P_i
)\)</span>.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是<span class="math inline">\(m^n - m^{ \underline{ n } }\)</span>.</p>
<h5><span id="example6">Example6</span></h5>
<p>求<span class="math inline">\(\varphi ( n )\)</span>.</p>
<p>考虑这么一个事实:假设<span class="math inline">\(n = \prod p_i^{ q_i
}\)</span>,注意到令<span class="math inline">\(P_i = [ \gcd ( i , n ) =
1 ]\)</span>,我们所求也就是<span class="math inline">\(\mid \bigcap_{ i
= 1 }^n S_i
\mid\)</span>.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5>
<p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如<span class="math inline">\(ABCABCAB . . .\)</span>这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于<span class="math inline">\(3\)</span>并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5>
<p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的<span class="math inline">\(1\)</span>,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是<span class="math inline">\(\sum_{ i = 0 }^{
\min ( n , m ) } ( - 1 )^i \binom{ n }{ i } \binom{ m }{ i } i ! ( m + 1
)^{ n - i } ( n + 1 )^{ m - i }\)</span>.</p>
<h5><span id="example9">Example9</span></h5>
<p>给定若干个限制条件<span class="math inline">\(( x , y
)\)</span>,表示<span class="math inline">\(a_x = y\)</span>和<span class="math inline">\(a_y = x\)</span>必须满足至少一个,求排列方案数.</p>
<p>首先<span class="math inline">\(i \rightarrow
p_i\)</span>把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为<span class="math inline">\(2\)</span>的链,它自己成环的话是不用<span class="math inline">\(\times 2\)</span>的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是<span class="math inline">\(\times 2\)</span>,所以一个有<span class="math inline">\(1\)</span>个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为<span class="math inline">\(2\)</span>的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-squareconstraints">Example10([AGC036F] Square
Constraints)</span></h5>
<p>由题意得:<span class="math inline">\(n^2 - i^2 \leq P_i^2 \leq ( 2 n
)^2 - i^2\)</span>.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为<span class="math inline">\(l_i\)</span>,那么只有上界的答案应该是什么呢?将<span class="math inline">\(l\)</span>从小到大排序,答案就是<span class="math inline">\(\prod_{ i = 0 }^{ 2 n - 1 } ( l_i - i
)\)</span>.(注意到必须满足<span class="math inline">\(l_{ 2 n - 1 } = 2
n - 1\)</span>.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个<span class="math inline">\(\frac{ 1 }{ 4
}\)</span>的圆弧.而通过圆弧的性质不难看出:最终的<span class="math inline">\(l\)</span>分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道<span class="math inline">\(l\)</span>按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照<span class="math inline">\(l\)</span>的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度<span class="math inline">\(O ( n^3 )\)</span>.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5>
<p>(下面将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>反着写)</p>
<p>设<span class="math inline">\(p = \frac{ 2 k }{ n } , q = n -
p\)</span>.</p>
<p>首先注意到期望<span class="math inline">\(= P [ len \geq 1 ] + P [
len \geq 2 ] + \cdots\)</span>.</p>
<p>考虑如何计算<span class="math inline">\(P [ len \geq x
]\)</span>,如果我们设<span class="math inline">\(a_i\)</span>表示以<span class="math inline">\(i\)</span>作为开头的极长的带劲的长度大于等于<span class="math inline">\(x\)</span>的序列的集合,那么最后无非是要求所有<span class="math inline">\(a\)</span>的并.考虑用容斥做到求所有<span class="math inline">\(a\)</span>的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5>
<p>给定<span class="math inline">\(n , k\)</span>和<span class="math inline">\(n\)</span>个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过<span class="math inline">\(k\)</span>.<span class="math inline">\(n \leq
300\)</span>.</p>
<p>著名结论:<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>个连通块任意连边成树的方案数是<span class="math inline">\(n^{ m - 2 } \prod s\)</span>,其中<span class="math inline">\(s\)</span>是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过<span class="math inline">\(k\)</span>,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于<span class="math inline">\(k\)</span>的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过<span class="math inline">\(k\)</span>,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数<span class="math inline">\(( - 1 )^{ 块 数 - 1 }\)</span>.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4>
<p>对于:</p>
<p><span class="math display">\[
\mid \bigcup_{ i = 1 }^n S_i \mid = \sum_{ T \subseteq \{ 1 , . . . , n
\} } ( - 1 )^{ | T - 1 | } \mid \bigcap_{ p \in T } S_p \mid
\]</span></p>
<p>考虑一个特例:<span class="math inline">\(S_i = \{ 1 , 2 , \cdots ,
a_i \}\)</span>,那么上面的式子导出min-max容斥(我们设<span class="math inline">\(S = \{ a_1 , a_2 , \cdots , a_n
\}\)</span>)(第二个式子可以把前缀改成后缀):</p>
<p><span class="math display">\[
\begin{aligned}
\max ( S ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1 )^{ |
T | - 1 } \min ( T ) \\
\min ( S ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1 )^{ |
T | - 1 } \max ( T )
\end{aligned}
\]</span></p>
<p>由于是集合,这个式子在期望意义下同样成立:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \max \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( -
1 )^{ | T | - 1 } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( -
1 )^{ | T | - 1 } E ( \max \{ S \} )
\end{aligned}
\]</span></p>
<p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<p><span class="math display">\[
\begin{aligned}
kth \max \{ S \} &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1
)^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } \min \{ T \} \\
kth \min \{ S \} &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1
)^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } \max \{ T \} \\
E ( kth \max \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset }
( - 1 )^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } E ( \min \{ T \} ) \\
E ( kth \min \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset }
( - 1 )^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } E ( \max \{ T \} )
\end{aligned}
\]</span></p>
<p>原理是消掉前<span class="math inline">\(k -
1\)</span>大的数字,让他们的贡献为<span class="math inline">\(0\)</span>,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5>
<p>不妨设<span class="math inline">\(tim_i\)</span>为<span class="math inline">\([ i , i + 1
]\)</span>第一次被覆盖的时间,答案就是:</p>
<p><span class="math display">\[
E ( \max_{ i = 1 }^{ n - 1 } \{ tim_i \} ) = \sum_{ T \subseteq \{ 1 , 2
, \cdots , n - 1 \} , T \ne \emptyset } ( - 1 )^{ | T | - 1 } E ( \min_{
j \in T } \{ tim_j \} )
\]</span></p>
<p>设<span class="math inline">\(f ( S
)\)</span>为有多少个区间能覆盖至少一个<span class="math inline">\([ i ,
i + 1 ] , i \in S\)</span>,考虑<span class="math inline">\(E = p_{ [ t
\geq 0 ] } + p_{ [ t \geq 1 ] } + p_{ [ t \geq 2 ] } +
\cdots\)</span>,于是<span class="math inline">\(E ( \min_{ j \in S } \{
tim_j \} ) = \frac{ m }{ f ( S ) }\)</span>.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum_{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne
\emptyset } ( - 1 )^{ | T | - 1 } f ( T ) \\
&amp; = \sum_{ k = 0 }^m \frac{ m }{ k } \sum_{ T \subseteq \{ 1 , 2 ,
\cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k } ( - 1 )^{ | T | - 1
}
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(f ( S
)\)</span>可能不那么好求,我们求<span class="math inline">\(g ( S ) = m -
f ( S )\)</span>,也就是不包含任何一个<span class="math inline">\([ i , i
+ 1 ] , i \in S\)</span>的区间个数,我们有:</p>
<p><span class="math display">\[
ans = \sum_{ k = 0 }^m \frac{ m }{ m - k } \sum_{ T \subseteq \{ 1 , 2 ,
\cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k } ( - 1 )^{ | T | - 1
}
\]</span></p>
<p>这里已经不难写出<span class="math inline">\(O ( n^3
)\)</span>的dp了.</p>
<p>那么怎么优化呢?设<span class="math inline">\(dp_{ i , j
}\)</span>表示只考虑<span class="math inline">\([ 1 , i
]\)</span>时(<span class="math inline">\([ i - 1 , i
]\)</span>必选),<span class="math inline">\(\sum_{ g ( T ) = j } ( - 1
)^{ | T | - 1 }\)</span>的答案,不难发现每次加入一个区间<span class="math inline">\([ l , r ]\)</span>就会让<span class="math inline">\(dp_{ i , j } , i &lt; = l\)</span>对<span class="math inline">\(dp_{ r , j + 1 }\)</span>的贡献乘一个<span class="math inline">\(1\)</span>.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度<span class="math inline">\(O ( nm \log n )\)</span>.</p>
<h4><span id="反射容斥">反射容斥</span></h4>
<p>一般形式:给定二维平面上两个点<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>,其中<span class="math inline">\(T\)</span>在<span class="math inline">\(S\)</span>的右方,给定两条线<span class="math inline">\(y = a\)</span>和<span class="math inline">\(y =
b\)</span>,每次可以向右上或者右下走一步,求不碰线的从<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的方案数.</p>
<p>我们不妨设<span class="math inline">\(A\)</span>表示一定碰了一次上界的方案数,<span class="math inline">\(B\)</span>表示一定碰了一次下界的方案数,<span class="math inline">\(AB\)</span>表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走<span class="math inline">\(- A - B + AB + BA -
ABA - BAB . . .\)</span>.</p>
<p>考虑设步数为<span class="math inline">\(n\)</span>,那显然长度最多为<span class="math inline">\(\cfrac{ n }{ a - b }\)</span>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="post-title-link" itemprop="url">博弈论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>颗石子,每次可以取<span class="math inline">\(x\)</span>颗,其中<span class="math inline">\(1
\leq x \leq m \\\)</span>,求<span class="math inline">\(A\)</span>是否能赢.</p>
<p>考虑直接令石子数量为状态,有<span class="math inline">\(SG ( x ) = mex
\{ SG ( y ) | \max \{ 0 , x - m \} \leq y \leq x - 1 \}
\\\)</span>,注意到<span class="math inline">\(SG ( x ) =
0\)</span>当且仅当<span class="math inline">\(x \equiv 0 ( \mod m + 1
)\)</span>.</p>
<p>我们使用数学归纳证明:</p>
<p>当<span class="math inline">\(0 \leq x \leq
m\)</span>时,显然成立.</p>
<p>而对于<span class="math inline">\(x\)</span>,如果<span class="math inline">\(x \equiv 0 ( \mod m + 1 )
\\\)</span>,那么集合<span class="math inline">\(S = \{ y \in \mathbb{ Z
} | \max \{ 0 , x - m \} \leq y \leq x - 1 \}\)</span>中一定<span class="math inline">\(\nexists y\)</span>满足<span class="math inline">\(y \equiv 0 ( \mod m + 1 ) \\\)</span>.</p>
<p>也就是<span class="math inline">\(\nexists y\)</span>满足<span class="math inline">\(SG ( y ) = 0\)</span>,那么<span class="math inline">\(SG ( n ) = 0\)</span>.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>堆石子,第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(x_i\)</span>个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果<span class="math inline">\(x\)</span>均等于<span class="math inline">\(0\)</span>一定先手必败.考虑令<span class="math inline">\(w = x_1 \oplus x_2 \oplus . . . \oplus
x_n\)</span>(<span class="math inline">\(w\)</span>即为全游戏的<span class="math inline">\(SG\)</span>值),那么先手必败当且仅当<span class="math inline">\(w = 0 \\\)</span>.</p>
<p>证明:</p>
<p>只需证明当<span class="math inline">\(w \ne
0\)</span>时一定存在一种方法使得<span class="math inline">\(w = 0
\\\)</span>.</p>
<p>考虑<span class="math inline">\(w\)</span>的最高位为第<span class="math inline">\(k\)</span>位,那么一定存在一个<span class="math inline">\(x_i\)</span>的第<span class="math inline">\(k\)</span>位为<span class="math inline">\(1\)</span>.将它改为<span class="math inline">\(0\)</span>,然后这个<span class="math inline">\(x_i\)</span>的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>堆石子,第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(x_i\)</span>个石子.每次可以任选不超过<span class="math inline">\(k\)</span>堆取走若干个石子,最后不能取的人输.</p>
<p>将<span class="math inline">\(x_i\)</span>写成二进制,如果每一位的<span class="math inline">\(1\)</span>的个数均是<span class="math inline">\(k
+ 1\)</span>的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4>
<p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于<span class="math inline">\(2\)</span>的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p><span class="math inline">\(SG ( x ) = mex \{ \{ SG ( v ) | x
\rightarrow v \} , \{ SG ( x - i ) \oplus SG ( i ) | 1 \leq i &lt; x \}
\} \\\)</span>.</p>
<p>找一下规律可以发现:</p>
$$
<span class="math display">\[\begin{aligned}
SG ( x ) &amp; = \begin{cases}
x - 1 &amp; x \equiv 0 ( \mod 4 ) \\
x &amp; x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 &amp; x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设当<span class="math inline">\(x \leq 4
k\)</span>时结论成立.</p>
<p>当<span class="math inline">\(x = 4 k +
1\)</span>时,前半部分一定是取遍了<span class="math inline">\([ 1 , 4 k
]\)</span>.</p>
<p>但是一定不存在<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>满足<span class="math inline">\(a + b =
4 k + 1\)</span>并且<span class="math inline">\(SG ( a ) \oplus SG ( b )
= 4 k + 1\)</span>.讨论一下<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>在<span class="math inline">\(\mod
4\)</span>意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3>
<p><span class="math inline">\(n\)</span>个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用<span class="math inline">\(SG ( u ) = mex \{ SG ( v ) | u
\rightarrow v \}\)</span>.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是<span class="math inline">\(0\)</span>.</p>
<p>首先如果<span class="math inline">\(SG ( u ) = x\)</span>,那么<span class="math inline">\(\forall 0 \leq y &lt; x\)</span>,<span class="math inline">\(\exists v\)</span>使得<span class="math inline">\(u \rightarrow v\)</span>且<span class="math inline">\(SG ( v ) =
y\)</span>.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能<span class="math inline">\(\exists y &gt;
x\)</span>,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个<span class="math inline">\(u
&#39;\)</span>使得<span class="math inline">\(SG ( u &#39; ) =
x\)</span>,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4>
<p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol type="1">
<li><p>游戏的SG函数不为<span class="math inline">\(0\)</span>且游戏中某个单一游戏的SG函数大于<span class="math inline">\(1\)</span>.</p></li>
<li><p>游戏的SG函数为<span class="math inline">\(0\)</span>且游戏中没有单一游戏的SG函数大于<span class="math inline">\(1\)</span>.</p></li>
</ol>
<p>如果没有单一游戏的SG函数大于<span class="math inline">\(1\)</span>,那么显然游戏的SG函数为<span class="math inline">\(0\)</span>就赢了,否则就输了.</p>
<p>而如果SG函数为<span class="math inline">\(0\)</span>且存在某个单一游戏的SG函数大于<span class="math inline">\(1\)</span>,一定是输的.</p>
<p>因为这个情况下,后手先按照正常<span class="math inline">\(SG\)</span>游戏压着先手,最后一定会剩两堆一样大于<span class="math inline">\(1\)</span>的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4>
<p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在<span class="math inline">\(DAG\)</span>上dp的时候除了<span class="math inline">\(SG\)</span>我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4>
<p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4>
<p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:<span class="math inline">\(SG ( u ) = \bigoplus_{ u \rightarrow
v } ( SG ( v ) + 1 )\)</span>.</p>
<p>考虑归纳假设.如果<span class="math inline">\(u\)</span>只有<span class="math inline">\(v\)</span>一个儿子.那么要么将<span class="math inline">\(v\)</span>子树全删,要么删一部分,有:</p>
<p><span class="math display">\[
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 &lt; SG ( v ) ) = SG ( v )
+ 1
\]</span></p>
<p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的<span class="math inline">\(SG\)</span>为<span class="math inline">\(0\)</span>,而显然<span class="math inline">\(SG\)</span>图中的其它节点的<span class="math inline">\(SG\)</span>均要<span class="math inline">\(+
1\)</span>.</p>
<h4><span id="example4">Example4</span></h4>
<p><span class="math inline">\(n\)</span>个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环<span class="math inline">\(SG = 1\)</span>,偶环<span class="math inline">\(SG = 0\)</span>.</p>
<p>这么考虑:边数为<span class="math inline">\(k\)</span>的链的<span class="math inline">\(SG\)</span>为<span class="math inline">\(k\)</span>.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到<span class="math inline">\(1\)</span>.偶环同理,不可能得到<span class="math inline">\(0\)</span>.</p>
<h4><span id="example5">Example5</span></h4>
<p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,<span class="math inline">\(SG\)</span>值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3>
<p>一个数<span class="math inline">\(N\)</span>,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当<span class="math inline">\(N\)</span>是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当<span class="math inline">\(N\)</span>是斐波那契数时必败,不妨假设<span class="math inline">\(N = N_0 + N_1\)</span>,</p>
<p>考虑将<span class="math inline">\(N\)</span>看成两堆,因为如果第一次取走了大于<span class="math inline">\(N_1\)</span>颗石子,由于<span class="math inline">\(N_0 \leq N_1
\\\)</span>,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在<span class="math inline">\(N_0\)</span>堆取石子,原因是如果取了大于<span class="math inline">\(N_0\)</span>颗石子,由于<span class="math inline">\(N = N_0 + N_1 \leq 3 N_0
\\\)</span>.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取<span class="math inline">\(N_0\)</span>这一堆,如果在这一堆取的过程中,先手一直取得不超过<span class="math inline">\(N_0\)</span>剩下的数,那么根据归纳假设,后手一定可以取走<span class="math inline">\(N_0\)</span>堆的最后一个石子,此时局面变成了只剩<span class="math inline">\(N_1\)</span>颗石子.只要此时先手不能一次取走<span class="math inline">\(N_1\)</span>颗石子,先手就必败.而后手最后一步拿走石子最多会拿走<span class="math inline">\(\frac{ 2 }{ 3 } N_0\)</span>的石子,但是,<span class="math inline">\(\frac{ 4 }{ 3 } N_0 &lt;
N_1\)</span>,因此一定不可能.</p>
<p>否则,仍然是先手取走了<span class="math inline">\(N_0\)</span>全部石子,又当了先手取<span class="math inline">\(N_1\)</span>的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设<span class="math inline">\(N = \sum_{ i = 1 }^k f_{ p_i
}\)</span>,其中<span class="math inline">\(p_1 &lt; p_2 &lt; p_3 &lt; .
. . &lt; p_k \\\)</span>,先手取走<span class="math inline">\(f_{ p_1 }
\\\)</span>.由于<span class="math inline">\(2 f_{ p_1 } &lt; f_{ p_2
}\)</span>,因此后手接下来无论如何不可能取得大于等于<span class="math inline">\(f_{ p_2 } \\\)</span>,问题转化为一堆大小为<span class="math inline">\(f_{ p_2
}\)</span>的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3>
<p>给出一张二分图和起点<span class="math inline">\(S\)</span>,<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点<span class="math inline">\(S\)</span>,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含<span class="math inline">\(S\)</span>,那么<span class="math inline">\(A\)</span>只需要每次走到一个和<span class="math inline">\(S\)</span>匹配的点即可.<span class="math inline">\(B\)</span>无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含<span class="math inline">\(S\)</span>的点,与假设不符.</p>
<p>而如果存在一个匹配不包含<span class="math inline">\(S\)</span>,如果<span class="math inline">\(A\)</span>仍然第一步走到一个和<span class="math inline">\(S\)</span>匹配的点那么<span class="math inline">\(B\)</span>一定能想办法走到一个不在当前<span class="math inline">\(A\)</span>选择的最大匹配中的点而在一个不包含<span class="math inline">\(S\)</span>的最大匹配中的点,于是<span class="math inline">\(B\)</span>必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4>
<p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设<span class="math inline">\(dp_{ S , x } = 0 / 1\)</span>表示目前集合<span class="math inline">\(S\)</span>中的所有人都已经离场了,而目前金条在<span class="math inline">\(x\)</span>手中,金条会不会被抢.显然,如果<span class="math inline">\(\exists y\)</span>满足<span class="math inline">\(dp_{ S \cup \{ x \} , y } =
0\)</span>,也就是金条在<span class="math inline">\(y\)</span>手里不会被抢,那<span class="math inline">\(x\)</span>手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与<span class="math inline">\(S\)</span>匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果<span class="math inline">\(S\)</span>和<span class="math inline">\(x\)</span>并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断<span class="math inline">\(S\)</span>是否一定在其中,只需要先删去<span class="math inline">\(S\)</span>,跑dinic,再在残联网络上加上<span class="math inline">\(S\)</span>,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3>
<h4><span id="example1zr23省选10连-day1clashmas">Example1(zr[23省选10连 day1]
Clashmas)</span></h4>
<p>注意到删点对树形态的影响,考虑重心</p>
<ol type="1">
<li><span class="math inline">\(n\)</span>为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol start="2" type="1">
<li><span class="math inline">\(n\)</span>为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时<span class="math inline">\(n\)</span>为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为<span class="math inline">\(S_A\)</span>,B的点的集合为<span class="math inline">\(S_B\)</span>.以原重心为根建树,设其所有儿子组成的集合为<span class="math inline">\(S_C\)</span>,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当<span class="math inline">\(\sum_{ u \in S_A \cap S_C } siz_u \geq \sum_{ u
\in S_B \cap S_C } siz_u\)</span>.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中<span class="math inline">\(siz\)</span>最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol start="3" type="1">
<li><span class="math inline">\(n\)</span>为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时<span class="math inline">\(n\)</span>为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol start="4" type="1">
<li><span class="math inline">\(n\)</span>为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol start="5" type="1">
<li><span class="math inline">\(n\)</span>为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3>
<h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5>
<p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设<span class="math inline">\(f_i\)</span>为还剩<span class="math inline">\(i\)</span>条蛇的时候能不能吃,那<span class="math inline">\(f_i = 1\)</span>的话,要么<span class="math inline">\(i = 2\)</span>,要么吃完后不是最小的,要么<span class="math inline">\(f_{ i - 1 } = 0\)</span>.</p>
<p>递归做就好了.另外这题需要复杂度<span class="math inline">\(O ( n
)\)</span>,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5>
<p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5>
<p>首先考虑如果有人作为第<span class="math inline">\(n - p +
1\)</span>个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读<span class="math inline">\(n - p\)</span>个人.</p>
<p>继续思考,如果有人作为第<span class="math inline">\(n - 2 p +
1\)</span>个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有<span class="math inline">\(n \mod
p\)</span>个人复读,并且一定是前<span class="math inline">\(n \mod
p\)</span>在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5>
<p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录<span class="math inline">\(f_{ i , j }\)</span>表示当前的<span class="math inline">\(G\)</span>是<span class="math inline">\(i\)</span>,<span class="math inline">\(G\)</span>的倍数还剩下<span class="math inline">\(j\)</span>个,然后做转移,再进一步发现我们只关心<span class="math inline">\(j\)</span>的奇偶性.于是记<span class="math inline">\(f_{ i , 0 / 1 }\)</span>即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5>
<p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在<span class="math inline">\([ l_i , r_i
]\)</span>,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为<span class="math inline">\(0\)</span>.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为<span class="math inline">\(0\)</span>.</p>
<p>换句话说,我们现在有<span class="math inline">\(x_1 , x_2 ,
x_3\)</span>,我们要将其中一个<span class="math inline">\(x_i\)</span>改为<span class="math inline">\(y_i\)</span>,其他不变,使得他们仨异或值为<span class="math inline">\(0\)</span>.和Nim游戏类似,假设他们仨异或值的最高位为<span class="math inline">\(k\)</span>.那么一定有一个<span class="math inline">\(x_i\)</span>的第<span class="math inline">\(k\)</span>位为<span class="math inline">\(1\)</span>,将它改为<span class="math inline">\(0\)</span>,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的<span class="math inline">\([ l_i , r_i
]\)</span>求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5>
<p>Nim游戏,但是每堆石子有一个<span class="math inline">\(K_i\)</span>.如果这堆石子剩<span class="math inline">\(x_i\)</span>个每次最多取<span class="math inline">\(\lfloor \frac{ x_i }{ K_i }
\rfloor\)</span>个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-n k,k)&amp;n(k)\</p>
<p>n k&amp;n=0(k)\</p>
<p>\end{cases}\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于<span class="math inline">\(k\)</span>是否大于<span class="math inline">\(\sqrt{ n }\)</span>讨论一下,如果<span class="math inline">\(k &lt; \sqrt{ n }\)</span>暴力,最多只会做<span class="math inline">\(\sqrt{ n
}\)</span>次.否则,意识到此时可以通过求一个区间<span class="math inline">\([ l , r ]\)</span>,满足<span class="math inline">\(\forall x \in [ l , r ] , \lfloor \frac{ x }{ k }
\rfloor\)</span>均相等,加速一下.这种区间最多只会有<span class="math inline">\(\sqrt{ n }\)</span>个.</p>
<h5><span id="problem7">Problem7</span></h5>
<p>一个数<span class="math inline">\(N\)</span>,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当<span class="math inline">\(N =
2^k\)</span>,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5>
<p>A和B,有<span class="math inline">\(n\)</span>颗石子,每次可以取<span class="math inline">\(x\)</span>颗,其中<span class="math inline">\(1
\leq x \leq \lceil \frac{ n }{ 2 } \rceil \\\)</span>.</p>
<p>仍然令石子数量为状态,注意到<span class="math inline">\(SG ( x ) =
0\)</span>当且仅当<span class="math inline">\(x + 1 = 2^k -
1\)</span>,也即<span class="math inline">\(x = 2^k - 2
\\\)</span>.首先,注意到:</p>
$$
<span class="math display">\[\begin{aligned}
n - \lceil \frac{ n }{ 2 } \rceil &amp; = \lfloor \frac{ n }{ 2 }
\rfloor \\
SG ( n ) &amp; = mex \{ SG ( y ) | \lfloor \frac{ n }{ 2 } \rfloor \leq
y \leq n - 1 \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>设<span class="math inline">\(n = 2^k - w\)</span>,其中:</p>
$$
<span class="math display">\[\begin{aligned}
- 2^{ k - 1 } + 2 &amp; \leq w \leq 2 \\
\lfloor \frac{ 2^k - w }{ 2 } \rfloor &amp; = 2^{ k - 1 } - \lfloor
\frac{ w }{ 2 } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>当<span class="math inline">\(w = 2\)</span>时,原式<span class="math inline">\(= 2^{ k - 1 } - 1 &gt; 2^{ k - 1 } - 2
\\\)</span>.反之.<span class="math inline">\(2^k - 2
\leq\)</span>原式.因此数学归纳即可证明.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">北大相关选拔数学真题汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-15 21:23:40" itemprop="dateModified" datetime="2025-08-15T21:23:40+08:00">2025-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3>
<h4><span id="problem4">Problem4</span></h4>
<p>设<span class="math inline">\(G ( x ) = ( x^2 + x - 1 )^{ 100 } =
\sum_{ k = 0 }^{ 200 } a_k x^k\)</span>,求<span class="math inline">\(2
a_0 - a_1 - a_2 + 2 a_3 - a_4 - a_5 + \cdots + 2 a_{ 198 } - a_{ 199 } -
a_{ 200 }\)</span>.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑求出<span class="math inline">\(\sum_{ 0 \leq k \leq 66 }{ a_{ 3
k } }\)</span>.直接取三次单位根<span class="math inline">\(\omega_3 = -
\frac{ 1 }{ 2 } + \frac{ \sqrt{ 3 } }{ 2 } i\)</span>,自然有<span class="math inline">\(1 + \omega_3 + \omega_3^2 = 0\)</span>,所以<span class="math inline">\(G ( 1 ) + G ( \omega_3 ) + G ( \omega_3^2 ) = 3
\sum_{ 0 \leq k \leq 66 }{ a_{ 3 k } }\)</span>.</p>
<p>所以答案显然是<span class="math inline">\(G ( \omega_3 ) + G (
\omega_3^2 ) = ( - 2 )^{ 100 } + ( - 2 )^{ 100 } = 2^{ 101
}\)</span>.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>等差数列中,<span class="math inline">\(a_1 &gt; 0\)</span>,公差<span class="math inline">\(d &lt; 0 , \frac{ a_{ 31 } }{ a_{ 30 } } &lt; -
1\)</span>,求最大的正整数<span class="math inline">\(n\)</span>,使得<span class="math inline">\(S_n
&gt; 0\)</span>.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>显然<span class="math inline">\(S_{ 60 } = 30 ( a_{ 30 } + a_{ 31 } )
&lt; 0 , S_{ 59 } = 59 a_{ 30 } &gt; 0\)</span>.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>全为整数的等差数列,<span class="math inline">\(d =
4\)</span>,求所有满足<span class="math inline">\(S_n =
2024\)</span>的<span class="math inline">\(n\)</span>的和.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>则<span class="math inline">\(n ( 2 n - 2 + a_1 ) = 2024 = 2^3 \times
11 \times 23\)</span>.显然只要<span class="math inline">\(n |
2024\)</span>即可.</p>
<p>所有<span class="math inline">\(n\)</span>的和自然是<span class="math inline">\(( 1 + 2 + 4 + 8 ) ( 1 + 11 ) ( 1 + 23 ) = 15
\times 12 \times 24 = 4320\)</span>.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>整数数列<span class="math inline">\(U_n\)</span>满足<span class="math inline">\(U_0 = 1\)</span>,且当<span class="math inline">\(n
\geq 1\)</span>的时候<span class="math inline">\(U_{ n + 1 } U_{ n - 1 }
= kU_n\)</span>,其中<span class="math inline">\(k\)</span>是一个正整数.问能让<span class="math inline">\(U_{ N } = N\)</span>的<span class="math inline">\(k\)</span>的个数有多少个,其中<span class="math inline">\(N = 2024\)</span>.</p>
<h5><span id="solution14">Solution14</span></h5>
<p>则<span class="math inline">\(U_{ n + 1 } = \frac{ kU_n }{ U_{ n - 1
} } , \frac{ U_{ n + 1 } }{ U_n } = k \frac{ U_n }{ U_{ n - 1 } } \frac{
1 }{ U_n }\)</span>.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设<span class="math inline">\(T_n = \prod_{ k = 1 }^n U_k , W_n = U_n \prod_{ k
= 1 }^{ n - 2 } U_k\)</span>.</p>
<p>注意到<span class="math inline">\(W_n = kW_{ n - 1 } , W_1 = U_1 ,
W_n = k^{ n - 1 } U_1\)</span>.又注意到<span class="math inline">\(T_n =
kU_{ n - 1 } W_{ n - 1 } = kW_{ n - 1 } \frac{ T_{ n - 1 } }{ T_{ n - 2
} } = k^{ n - 1 } U_1 \frac{ T_{ n - 1 } }{ T_{ n - 2 } } = ( k^{ n - 1
} U_1 ) ( k^{ n - 2 } U_1 ) \frac{ 1 }{ T_{ n - 3 } }\)</span>,<span class="math inline">\(T_{ n - 3 } = ( k^{ n - 4 } U_1 ) ( k^{ n - 5 }
U_1 ) \frac{ 1 }{ T_{ n - 6 } }\)</span>.所以<span class="math inline">\(T_{ n } = k^6 T_{ n - 6 }\)</span>,所以<span class="math inline">\(U\)</span>存在长度为<span class="math inline">\(6\)</span>的循环节.所以<span class="math inline">\(U_{ N } = \frac{ T_N }{ T_{ N - 1 } } = \frac{ T_2
}{ T_1 } = U_2 = kU_1\)</span>.(其实直接暴力找循环节也是可以的)</p>
<p>所以<span class="math inline">\(k\)</span>需要是<span class="math inline">\(N\)</span>的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设<span class="math inline">\(w = U_1\)</span>,则<span class="math inline">\(U\)</span>的前六项是:<span class="math inline">\(1
, w , kw , k^2 , \frac{ k^2 }{ w } , \frac{ k }{ w }\)</span>.要求<span class="math inline">\(kw = N , w | k\)</span>,所以<span class="math inline">\(( 11 \times 23 ) | k\)</span>,<span class="math inline">\(k \equiv 0 \pmod{ 4 }\)</span>.所以<span class="math inline">\(k = 4 \times 11 \times 23\)</span>或<span class="math inline">\(k = 8 \times 11 \times 23\)</span>.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>求使方程<span class="math inline">\(\lfloor \frac{ 10^n }{ x }
\rfloor = N = 2024\)</span>恰有两个整数解的正整数<span class="math inline">\(n\)</span>的个数.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
N &amp; \leq \frac{ 10^n }{ x } &lt; N + 1 \\
xN &amp; \leq 10^n &lt; x ( N + 1 ) \\
\frac{ 10^n }{ N + 1 } &amp; &lt; x \leq \frac{ 10^n }{ N } \\
\lfloor \frac{ 10^n }{ N + 1 } \rfloor &amp; &lt; x \leq \lfloor \frac{
10^n }{ N } \rfloor \\
\lfloor \frac{ 10^n }{ N } \rfloor - \lfloor \frac{ 10^n }{ N + 1 }
\rfloor &amp; = 2 \\
\frac{ 10^n }{ N ( N + 1 ) } - \frac{ 10^n \bmod N }{ N } + \frac{ 10^n
\bmod{ ( N + 1 ) } }{ N + 1 } &amp; = 2
\end{aligned}
\]</span></p>
<p>显然<span class="math inline">\(\lfloor \frac{ 10^n }{ N ( N + 1 ) }
\rfloor = 1 , 2 , 3\)</span>.而<span class="math inline">\(N ( N + 1 ) =
4098600\)</span>,所以只有<span class="math inline">\(n =
7\)</span>可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是<span class="math inline">\(5 \times 3 ! = 30\)</span>.</p>
<h4><span id="problem19">Problem19</span></h4>
<p><span class="math inline">\(f ( x ) = \lfloor 2 x \rfloor + \lfloor 4
x \rfloor + \lfloor 6 x \rfloor + \lfloor 8 x \rfloor , x \in \mathbb{ R
}\)</span>,求其不超过<span class="math inline">\(n =
2024\)</span>的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>显然<span class="math inline">\(f ( x + 1 ) = f ( x ) +
20\)</span>,因此我们先考虑<span class="math inline">\(x \in [ 0 , 1
)\)</span>的情况.</p>
<p>手动枚举一下知道此时<span class="math inline">\(f ( x
)\)</span>有<span class="math inline">\(12\)</span>种不同的取值,前六种是<span class="math inline">\(\{ 0 , 1 , 2 , 4 , 5 , 6
\}\)</span>,后六种对应了前六种<span class="math inline">\(+
10\)</span>.而<span class="math inline">\(2024 = 101 \times 20 +
4\)</span>,所以共有<span class="math inline">\(101 \times 12 - 1 + 4 =
1215\)</span>种取值.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>从<span class="math inline">\([ 1 , n ] , n =
2024\)</span>中分别独立随机两个正整数(可以相同)<span class="math inline">\(a , b\)</span>,则求<span class="math inline">\(3^a
+ 7^b \equiv 8 \pmod{ 10 }\)</span>的概率.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>考虑<span class="math inline">\(\varphi ( 10 ) =
4\)</span>,所以原题答案等价于<span class="math inline">\(n =
4\)</span>的时候的答案.在这<span class="math inline">\(16\)</span>中可能性中满足条件的只有三种,概率为<span class="math inline">\(\frac{ 3 }{ 16 }\)</span>.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3>
<h4><span id="problem3">Problem3</span></h4>
<p>已知<span class="math inline">\(a_1 = \frac{ 5 }{ 2 } , a_{ n + 1 } =
a_n^2 - 2\)</span>,求<span class="math inline">\(\lfloor a_n \rfloor
\bmod 7 , n = 2023\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>这个一看就不是好解的,想都别想直接数学归纳,注意到<span class="math inline">\(a_n = \frac{ 4^{ 2^{ n - 1 } } + 1 }{ 2^{ 2^{ n -
1 } } }\)</span>,那么<span class="math inline">\(\lfloor a_n \rfloor =
2^{ 2^{ n - 1 } }\)</span>.</p>
<p>而<span class="math inline">\(\varphi ( 7 ) = 6 , \varphi ( 6 ) =
2\)</span>.由扩展欧拉定理,立刻有:<span class="math inline">\(2^{ 2^{
2022 } } \equiv 2^{ 2^{ 2022 } \bmod 6 } \equiv 2^{ 2^{ 6 } } \equiv 16
\equiv 2 \pmod{ 7 }\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p><span class="math inline">\(50\)</span>个队伍两两打比赛,胜一场积分<span class="math inline">\(+ 1\)</span>,负一场积分不变,无平局.</p>
<p>且任取<span class="math inline">\(27\)</span>支队伍,其中一定有一支队伍负于其它的<span class="math inline">\(26\)</span>支,也一定有一支队伍胜于其它的<span class="math inline">\(26\)</span>支.</p>
<p>问<span class="math inline">\(50\)</span>支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>答案是<span class="math inline">\(50\)</span>.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都<span class="math inline">\(\leq
27\)</span>的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都<span class="math inline">\(&gt;
27\)</span>,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为<span class="math inline">\(k\)</span>的简单环,由鸽笼原理,剩下的<span class="math inline">\(n - k\)</span>个点中至少有<span class="math inline">\(\frac{ n - k }{ 2 }\)</span>个点对着<span class="math inline">\(k\)</span>个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要<span class="math inline">\(k + \frac{ n - k }{ 2 } \geq
27\)</span>即可,此时<span class="math inline">\(k \geq
4\)</span>即可.由于这是竞赛图,显然存在长度为<span class="math inline">\(4\)</span>的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为<span class="math inline">\(u\)</span>.我们任意取一个击败过它的点(如果有的话),假设为<span class="math inline">\(v\)</span>,再取<span class="math inline">\(25\)</span>个被<span class="math inline">\(u\)</span>击败的点(显然这些点存在),设这些点集为<span class="math inline">\(S\)</span>.则<span class="math inline">\(u , v ,
S\)</span>组成的集合中,有一个点可以击败其它所有点,根据假设,只能是<span class="math inline">\(v\)</span>.由此,可以知道,只要是<span class="math inline">\(u\)</span>能击败的点,<span class="math inline">\(v\)</span>一定能击败,而且<span class="math inline">\(v\)</span>能击败<span class="math inline">\(u\)</span>,因此<span class="math inline">\(\deg_v
&gt; \deg_u\)</span>,与假设不符.因此一定不存在一个<span class="math inline">\(v\)</span>可以击败<span class="math inline">\(u\)</span>.删掉<span class="math inline">\(u\)</span>后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>一只蚂蚁第一天在<span class="math inline">\(( 0 , 0
)\)</span>,第<span class="math inline">\(k +
1\)</span>天向上下左右随机一个方向移动<span class="math inline">\(\frac{
1 }{ 4^k }\)</span>单位,求第<span class="math inline">\(n\)</span>天的可能位置数量,<span class="math inline">\(n = 2023\)</span>.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>不妨设第<span class="math inline">\(n\)</span>天不同位置数量为<span class="math inline">\(S_n\)</span>,显然只要前面岔开了,后面永远无法走到一个点.所以<span class="math inline">\(S_1 = 1 , S_{ n + 1 } = 4 S_n , S_{ 2023 } = 4^{
2022 }\)</span>.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>集合<span class="math inline">\(U = \{ 1 , 2 , \cdots , n \} , n =
10\)</span>,求<span class="math inline">\(U\)</span>中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>集合是无序的,这个很难搞,我们先从<span class="math inline">\(U\)</span>中把<span class="math inline">\(1\)</span>去掉最后再加上.</p>
<p>先考虑可以重复放<span class="math inline">\(1\)</span>的情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n \sum_{ j = 1 }^{ n } \sum_{ k = 1 }^{ n } [ \gcd ( i ,
j ) &amp; = 1 ] [ \gcd ( i , k ) = 1 ] [ \gcd ( j , k ) = 1 ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从<span class="math inline">\(1 , 3 , 5 , 7
, 9\)</span>中选,答案应该是<span class="math inline">\(1 + 2 \binom{ 3
}{ 2 } = 7\)</span>.</p>
<p>接下来考虑选一个偶数,如果选<span class="math inline">\(2 , 4 ,
8\)</span>是等价的,答案此时是<span class="math inline">\(3 ( \binom{ 5
}{ 2 } - 1 ) = 27\)</span>.如果选<span class="math inline">\(6\)</span>的话答案是<span class="math inline">\(\binom{ 3 }{ 2 } = 3\)</span>.如果选<span class="math inline">\(10\)</span>的话方案数是<span class="math inline">\(\binom{ 4 }{ 2 } - 1 =
5\)</span>,加起来方案数是<span class="math inline">\(42\)</span>.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>集合<span class="math inline">\(U = \{ 1 , 2 , \cdots , n \} , n =
366\)</span>,则<span class="math inline">\(U\)</span>的互不相交且各元素之和为<span class="math inline">\(17\)</span>的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5>
<p>考虑<span class="math inline">\(\lfloor \frac{ 366 }{ 17 } \rfloor =
21 , 366 \equiv 9 \pmod{ 17 }\)</span>.答案显然是<span class="math inline">\(21 \times 8 + 10 + 1 = 179\)</span>个.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>三个互不相同的数的<span class="math inline">\(\gcd = 20 , \text{ lcm
} = 20000\)</span>,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然等价于<span class="math inline">\(\gcd = 1 , \text{ lcm } = 1000
= 2^3 \times 5^3\)</span>.先只分析其中一个质因子,方案应该是<span class="math inline">\(( 0 , 0 , 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , (
0 , 3 , 3 )\)</span>,打乱一下顺序的话就共有<span class="math inline">\(3
+ 6 + 6 + 3 = 18\)</span>种方案.如果可以重复,平方一下得到<span class="math inline">\(324\)</span>.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有<span class="math inline">\(2 \times 2 \times 3 =
12\)</span>种,于是答案为<span class="math inline">\(312\)</span>.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>求<span class="math inline">\(\lfloor \frac{ k^2 }{ n } \rfloor , k
\in [ 1 , n ] , n = 2023\)</span>种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5>
<p><span class="math display">\[
\begin{aligned}
\lfloor \frac{ k^2 }{ n } \rfloor &amp; = d \\
d &amp; \leq \frac{ k^2 }{ n } &lt; d + 1 \\
nd &amp; \leq k^2 &lt; n ( d + 1 )
\end{aligned}
\]</span></p>
<p>由于两个完全平方数的差是逐渐增大的,应该存在一个<span class="math inline">\(k_0\)</span>,<span class="math inline">\(\leq
k_0\)</span>的<span class="math inline">\(k\)</span>会扎堆,但是这些<span class="math inline">\(d\)</span>全都能取到,<span class="math inline">\(&gt; k_0\)</span>的则不会有两个<span class="math inline">\(k\)</span>得到相同的元素.所以前者统计不同的<span class="math inline">\(d\)</span>,后者统计不同的<span class="math inline">\(k\)</span>考虑<span class="math inline">\(( k + 1
)^2 - k^2 = 2 k + 1\)</span>.分界线应该是<span class="math inline">\(k_0
= 1011\)</span>.</p>
<p>所以答案应该是<span class="math inline">\(n - k_0 + \lfloor \frac{
k_0^2 }{ 2 k_0 + 1 } \rfloor + 1 = 1012 + 506 = 1518\)</span>.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>对四元组<span class="math inline">\(( a , b , c , d
)\)</span>计数,满足<span class="math inline">\(101 | ( a + b + c + d
)\)</span>且<span class="math inline">\(0 &lt; a &lt; b &lt; c &lt; d
\leq 101\)</span>.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>这题真的厉害啊.</p>
<p>不妨设<span class="math inline">\(S_k\)</span>为满足<span class="math inline">\(( a + b + c + d ) \equiv k \pmod{ 101
}\)</span>的满足<span class="math inline">\(0 &lt; a &lt; b &lt; c &lt;
d \leq 101\)</span>的四元组数量.不难发现<span class="math inline">\(\sum
S_k = \binom{ 101 }{ 4 }\)</span>.</p>
<p>注意到<span class="math inline">\(( a , b , c , d ) \mapsto ( a + 1 ,
b + 1 , c + 1 , d + 1 )\)</span>,注意这里是<span class="math inline">\(\pmod{ 101
}\)</span>意义下的加法,这是一个双射,所以<span class="math inline">\(S_{
k } = S_{ k + 4 }\)</span>,下标同样也是<span class="math inline">\(\pmod{ 101 }\)</span>意义下进行的.又因为<span class="math inline">\(\gcd ( 101 , 4 ) = 1\)</span>,所以所有的<span class="math inline">\(S_k\)</span>均相等.<span class="math inline">\(S_0
= \frac{ \binom{ 101 }{ 4 } }{ 101 } = 40425\)</span>.</p>
<h4><span id="problem16">Problem16</span></h4>
<p>问方程<span class="math inline">\(x \lfloor x \rfloor =
6\)</span>的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5>
<p><span class="math inline">\(6 = x \lfloor x \rfloor \geq \lfloor x
\rfloor^2\)</span>,所以<span class="math inline">\(\lfloor x \rfloor =
\pm 1 , \pm 2\)</span>.显然都不可以.所以个数为<span class="math inline">\(0\)</span>.</p>
<h4><span id="problem17">Problem17</span></h4>
<p>设<span class="math inline">\(R ( n ) = \sum_{ k = 2 }^{ 10 } ( n
\bmod k )\)</span>,求满足<span class="math inline">\(R ( n ) = R ( n + 1
)\)</span>的十进制下的两位数<span class="math inline">\(n\)</span>的个数.</p>
<h5><span id="solution17">Solution17</span></h5>
<p>从<span class="math inline">\(R ( n )\)</span>到<span class="math inline">\(R ( n + 1 )\)</span>,应该是加了若干个<span class="math inline">\(1\)</span>,然后又丢了几个<span class="math inline">\(k -
1\)</span>这样的.那就一定需要丢掉的数字之和为<span class="math inline">\(9\)</span>.枚举一下,丢了的只有可能是以下情况:<span class="math inline">\(( 9 ) , ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 +
3 + 2 )\)</span>,分别对应了<span class="math inline">\(n +
1\)</span>应该是分别以下数的倍数<span class="math inline">\(( 9 ) , ( 14
) , ( 6 ) , ( 20 ) , ( 12
)\)</span>,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:<span class="math inline">\(( 7 + 2
)\)</span>,并且分别不能是以下数字的倍数<span class="math inline">\(( 3 ,
4 , 5 )\)</span>.</p>
<p>取一下的话<span class="math inline">\(n + 1\)</span>可以是:<span class="math inline">\(14 , 98\)</span>,<span class="math inline">\(n =
13 , 97\)</span>,验证一下均合法,所以答案为<span class="math inline">\(2\)</span>.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>已知<span class="math inline">\(a &lt; b &lt; c &lt;
d\)</span>,而<span class="math inline">\(x , y , z , w\)</span>是<span class="math inline">\(a , b , c , d\)</span>的一个排列,求<span class="math inline">\(( x - y )^2 + ( y - z )^2 + ( z - w )^2 + ( w - x
)^2\)</span>得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>圆排列个数是<span class="math inline">\(3 ! =
6\)</span>个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是<span class="math inline">\(( x , y , z , w ) , ( x , z , w , y ) , ( x , w ,
y , z )\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( x - y )^2 + ( y - z )^2 + ( z - w )^2 + ( w - x )^2 \\
= &amp; 2 ( x^2 + z^2 + y^2 + w^2 ) - 2 ( xy + yz + zw + wx )
\end{aligned}
\]</span></p>
<p>显然只要<span class="math inline">\(xy + yz + zw +
wx\)</span>不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>已知<span class="math inline">\(0 &lt; x_1 &lt; x_2 &lt; \cdots &lt;
x_9\)</span>且<span class="math inline">\(\sum_{ k = 1 }^9 x_k =
220\)</span>,在<span class="math inline">\(\sum_{ k = 1 }^5
x_k\)</span>最大的前提下,最小化<span class="math inline">\(x_9 -
x_1\)</span>.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>不妨枚举一下<span class="math inline">\(x_5\)</span>选啥,设<span class="math inline">\(f ( S , m , k )\)</span>表示选出<span class="math inline">\(k\)</span>个互不相同的数,使得它们<span class="math inline">\(\leq m\)</span>且总和为<span class="math inline">\(S\)</span>,是否可行.不难发现<span class="math inline">\(f ( S , m , k ) = [ \frac{ k ( k + 1 ) }{ 2 } \leq
S \leq \frac{ k ( 2 m - k + 1 ) }{ 2 } ]\)</span>.</p>
<p>那我们要求的就是:</p>
<p><span class="math display">\[
\begin{aligned}
\max_{ 5 \leq x_5 } \{ S | f ( 220 - 4 x_5 - S , + \infty , 4 ) &amp; =
1 \land f ( S - x_5 , x_5 - 1 , 4 ) = 1 \} \\
&amp; = \max_{ 5 \leq x_5 } \{ S | 4 x_5 + S \leq 210 \land 10 + x_5
\leq S \leq 5 x_5 - 10 \} \\
&amp; = \max_{ 5 \leq x_5 } ( \min \{ 5 x_5 - 10 , 210 - 4 x_5 \} )
\end{aligned}
\]</span></p>
<p>立刻得到<span class="math inline">\(x_5 = 24 , 25 , S =
110\)</span>,那么后面的选法就一定了,后面四个数一定是<span class="math inline">\(26 , 27 , 28 , 29\)</span>,只需要让<span class="math inline">\(x_1\)</span>最大即可</p>
<p><span class="math inline">\(x_5 = 24\)</span>时,此时最优显然是<span class="math inline">\(20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 ,
29\)</span>,<span class="math inline">\(x_9 - x_1 = 9\)</span>.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>有一个<span class="math inline">\(n\)</span>边形,其中有<span class="math inline">\(\binom{ n }{ 2
}\)</span>条对角线,不存在三线交于一点的情况,问这些对角线将该<span class="math inline">\(n\)</span>边形分成了多少个部分.<span class="math inline">\(n = 10\)</span>.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了<span class="math inline">\(\binom{ n }{ 4
}\)</span>个点(任意四个点有且只有一种交法),每交一个点就会多出<span class="math inline">\(2\)</span>条边,所以多出来了<span class="math inline">\(2 \binom{ n }{ 4 } + \frac{ n ( n - 3 ) }{ 2
}\)</span>条边.</p>
<p>考虑内部的若干个部分一定是<span class="math inline">\(a_3\)</span>个三角形,<span class="math inline">\(a_4\)</span>个四边形,…,<span class="math inline">\(a_k\)</span>个<span class="math inline">\(k\)</span>边形,总之我们发现:</p>
<p><span class="math display">\[
\begin{cases}
\sum_{ j = 3 }^k ( j - 2 ) \pi a_j = ( n - 2 ) \pi + 2 \pi \binom{ n }{
4 } \\
\sum_{ j = 3 }^k ja_j = n + 4 \binom{ n }{ 4 } + n ( n - 3 )
\end{cases}
\]</span></p>
<p>两式得到:<span class="math inline">\(\sum_{ j = 3 }^k a_j = \frac{ (
n - 1 ) ( n - 2 ) }{ 2 } + \binom{ n }{ 4 }\)</span>.</p>
<p><span class="math inline">\(n = 10\)</span>的时候,答案为<span class="math inline">\(246\)</span>.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \lfloor \frac{ 19^i }{
20 } \rfloor \bmod 7 , n = 2024\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ i = 1 }^n \lfloor \frac{ 19^i }{ 20 } \rfloor \\
= &amp; \sum_{ i = 1 }^n \lfloor \frac{ \sum_{ k = 0 }^i 20^k ( - 1 )^{
i - k } \binom{ i }{ k } }{ 20 } \rfloor \\
= &amp; - \lfloor \frac{ n }{ 2 } \rfloor + \sum_{ i = 1 }^{ n } \frac{
19^i - ( - 1 )^i }{ 20 } \\
= &amp; - \lfloor \frac{ n }{ 2 } \rfloor + \frac{ \frac{ 19 }{ 18 } (
19^n - 1 ) - ( \frac{ ( - 1 )^n - 1 }{ 2 } ) }{ 20 }
\end{aligned}
\]</span></p>
<p>带入<span class="math inline">\(n = 2024\)</span>并<span class="math inline">\(\bmod 7\)</span>,原式为:</p>
<p><span class="math display">\[
\equiv - 4 + \frac{ 5 }{ 4 } ( 1 - 5^n ) \equiv - 4 + 3 ( 1 - 5^n )
\]</span></p>
<p>注意到<span class="math inline">\(2024 \bmod 6 = 2\)</span>,原式<span class="math inline">\(\equiv - 4 - 9 \equiv 1\)</span>.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>求长度为<span class="math inline">\(n\)</span>的排列个数,使得排列中<span class="math inline">\(\nexists i \in [ 1 , n - 1 ] , a_i = a_{ i + 1 } -
1\)</span>.<span class="math inline">\(n = 8\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>一眼容斥,也就是每个长度为<span class="math inline">\(k\)</span>的连续段的容斥系数应该是<span class="math inline">\(( - 1 )^{ k - 1 }\)</span>.那么设分成了<span class="math inline">\(w\)</span>个段,总的容斥系数应该是<span class="math inline">\(( - 1 )^{ n - w }\)</span>,答案就是<span class="math inline">\(f_{ n &#39; } = \sum_{ w = 1 }^n ( - 1 )^{ n - w }
w ! \binom{ n - 1 }{ w - 1 } = \sum_{ w = 0 }^{ n &#39; } ( - 1 )^{ n
&#39; - w } \binom{ n &#39; }{ w } ( w + 1 ) ! = n &#39; ! \sum_{ w = 0
}^{ n &#39; } \frac{ ( - 1 )^w }{ w ! } ( n &#39; - w + 1
)\)</span>,此时已经能算出答案是<span class="math inline">\(16687\)</span>.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设<span class="math inline">\(g_n\)</span>为错排数量,显然有<span class="math inline">\(f_{ n } = nf_{ n - 1 } + g_{ n
}\)</span>,立刻算出答案是<span class="math inline">\(16687\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>已知数列<span class="math inline">\(1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4
, 4 , \cdots\)</span>,求其第<span class="math inline">\(n\)</span>项<span class="math inline">\(\bmod
5\)</span>的值,<span class="math inline">\(n = 2024\)</span>.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑第一个值为<span class="math inline">\(k\)</span>的地方应该在哪里.显然<span class="math inline">\(a_{ \frac{ k ( k - 1 ) }{ 2 } + 1 } =
k\)</span>.注意到<span class="math inline">\(a_{ 2081 } =
65\)</span>,所以<span class="math inline">\(a_n = 64\)</span>,其<span class="math inline">\(\bmod 5 = 4\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>求四元组<span class="math inline">\(( a_1 , a_2 , a_3 , a_4
)\)</span>的个数,满足<span class="math inline">\(a_1 , a_2 , a_3 , a_4
\in \{ 1 , 2 , 3 \}\)</span>,且<span class="math inline">\(10 &lt; a_1
a_2 a_3 a_4 &lt; 20\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>排个序按照字典序开搜,只有三种可能:<span class="math inline">\(\{ 3 ,
3 , 2 , 1 \} , \{ 3 , 2 , 2 , 1 \} , \{ 2 , 2 , 2 , 2
\}\)</span>,打乱顺序的话就有<span class="math inline">\(25\)</span>种可能.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>求<span class="math inline">\(\mathbb{ R }\)</span>上方程<span class="math inline">\(x^2 - 13 \lfloor x \rfloor + 11 =
0\)</span>的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>首先注意到<span class="math inline">\(\lfloor x \rfloor = \frac{ x^2
+ 11 }{ 13 }\)</span>,那么自然有方程组:</p>
<p><span class="math display">\[
\begin{cases}
\frac{ x^2 + 11 }{ 13 } \leq x \\
x &lt; \frac{ x^2 + 11 }{ 13 } + 1
\end{cases}
\]</span></p>
<p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑<span class="math inline">\(x^2 \equiv 2 \pmod{ 13
}\)</span>这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设<span class="math inline">\(x = \sqrt{ 2 + 13 k
}\)</span>的形式,带入有不等式:</p>
<p><span class="math display">\[
\begin{aligned}
k - x + 1 &amp; \leq 0 &lt; k - x + 2 \\
1 &amp; \leq \sqrt{ 2 + 13 k } - k &lt; 2 \\
\begin{cases}
0 &lt; k^2 - 9 k + 2 \\
k^2 - 11 k - 1 \leq 0
\end{cases}
\end{aligned}
\]</span></p>
<p>冷静一下!注意到<span class="math inline">\(0 \leq k \leq
13\)</span>,又根据第一个不等式得知大部分<span class="math inline">\(k\)</span>应该会很大,开始暴力枚举一下,合法的情况有:<span class="math inline">\(k = 0 , 9 , 10 , 11\)</span>,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4>
<p>在一个体积为<span class="math inline">\(1\)</span>的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积<span class="math inline">\(\leq \frac{ 1 }{ 8 }\)</span>的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5>
<p>原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积<span class="math inline">\(\leq \frac{ 1 }{ 8 }\)</span>.考虑设这个点是<span class="math inline">\(( x , x , h )\)</span>,那么必然有<span class="math inline">\(\begin{cases}( 1 - h ) x^2 &gt; \frac{ 1 }{ 8 } \\
h ( 1 - x )^2 &gt; \frac{ 1 }{ 8 }\end{cases}\)</span>,化简,只要<span class="math inline">\(8 &gt; \frac{ 1 }{ x^2 } + \frac{ 1 }{ ( 1 - x )^2
}\)</span>即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取<span class="math inline">\(( 0 . 5
, 0 . 5 , 0 . 1 )\)</span>即可.那么是不是可以证明答案一定<span class="math inline">\(&gt; 3\)</span>呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积<span class="math inline">\(\leq \frac{ 1 }{ 8
}\)</span>的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为<span class="math inline">\(( x , y , h ) , x , y , h \leq \frac{ 1 }{ 2
}\)</span>,然后证明<span class="math inline">\(8 &gt; \frac{ 1 }{ xy } +
\frac{ 1 }{ ( 1 - x ) ( 1 - y ) } , x , y \leq \frac{ 1 }{ 2
}\)</span>这个不等式无解即可.</p>
<p>由基本不等式,<span class="math inline">\(\frac{ 1 }{ xy } + \frac{ 1
}{ ( 1 - x ) ( 1 - y ) } \geq 2 \sqrt{ \frac{ 1 }{ x ( 1 - x ) y ( 1 - y
) } } \geq 2 \sqrt{ 4 \times 4 } = 8\)</span>,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>设<span class="math inline">\(S ( n )\)</span>表示正整数<span class="math inline">\(n\)</span>的十进制数码和,求满足<span class="math inline">\(S ( n ) \equiv S ( n + 1 ) \equiv 0 \pmod{ 5
}\)</span>的最小的<span class="math inline">\(n\)</span>.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>显然必须发生进位,不妨设<span class="math inline">\(n = 10^k a + 10^k
- 1\)</span>,<span class="math inline">\(a \ne 9 \pmod{ 10
}\)</span>,<span class="math inline">\(S ( n ) = S ( a ) + 9 k , S ( n +
1 ) = S ( a ) + 1\)</span>,</p>
<p>此时显然有<span class="math inline">\(9 k - 1 \equiv 0 \pmod{ 5
}\)</span>,<span class="math inline">\(k \equiv 4 \pmod{ 5
}\)</span>.<span class="math inline">\(n_{ \min } = 49999\)</span>.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>求满足以下条件的最大的正整数<span class="math inline">\(n\)</span>:十进制下每一位数字互不相同,且<span class="math inline">\(\forall m , 10^m \leq n , \lfloor \frac{ n }{ 10^m
} \rfloor | n\)</span>.</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是<span class="math inline">\(0\)</span>.</p>
<p>不妨设其为<span class="math inline">\(\overline{ ab
}\)</span>,其中<span class="math inline">\(b = 10 c\)</span>,<span class="math inline">\(a\)</span>是<span class="math inline">\(b\)</span>的因子,不妨枚举一下<span class="math inline">\(k = \frac{ b }{ a }\)</span>.注意到因为<span class="math inline">\(a\)</span>中不能有<span class="math inline">\(0\)</span>,所以<span class="math inline">\(k \in
\{ 2 , 4 , 5 , 8 \}\)</span>.取<span class="math inline">\(k =
2\)</span>试出来<span class="math inline">\(3570\)</span>是合法的,而且显然<span class="math inline">\(k \in \{ 4 , 5 , 8
\}\)</span>的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4>
<p><span class="math inline">\(a_1 = \sqrt{ 2 } , a_{ n + 1 } = \lfloor
a_n \rfloor + \frac{ 1 }{ a_n - \lfloor a_n \rfloor }\)</span>,求<span class="math inline">\(\sum_{ k = 1 }^{ n } a_k , n = 2024\)</span>.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>这一看就是个环,设<span class="math inline">\(a_n = b_n + c_n \sqrt{ 2
}\)</span>.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<p><span class="math display">\[
\begin{cases}
a_1 = 0 + \sqrt{ 2 } \\
a_2 = 2 + \sqrt{ 2 } \\
a_3 = 4 + \sqrt{ 2 } \\
\cdots
\end{cases}
\]</span></p>
<p>容易猜测<span class="math inline">\(b_n = 2 ( n - 1 ) , c_n =
1\)</span>.也就是<span class="math inline">\(a_n = 2 ( n - 1 ) + \sqrt{
2 }\)</span>,数学归纳一下即可.</p>
<p>那么<span class="math inline">\(\sum_{ k = 1 }^n a_k = n ( n - 1 ) +
n \sqrt{ 2 }\)</span>,带入<span class="math inline">\(n =
2024\)</span>即可.</p>
<h3><span id="2022图选">2022图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol type="1">
<li><p>任意两个正方形至多有一个顶点重合</p></li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol type="1">
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p></li>
<li><p>边可以相交,放到正十二边形的边上.</p></li>
</ol>
<h4><span id="problem2">Problem2</span></h4>
<p>求<span class="math inline">\(\lfloor ( \frac{ 1 + \sqrt{ 5 } }{ 2 }
)^{ 12 } \rfloor\)</span>.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>考虑<span class="math inline">\(( \frac{ 1 + \sqrt{ 5 } }{ 2 } )^3 =
2 + \sqrt{ 5 }\)</span>,<span class="math inline">\(\lfloor ( \frac{ 1 +
\sqrt{ 5 } }{ 2 } )^{ 12 } \rfloor = 161 + \lfloor 72 \sqrt{ 5 } \rfloor
= 321\)</span>.</p>
<p>也可以考虑类似斐波那契数列,取<span class="math inline">\(f_n = (
\frac{ 1 + \sqrt{ 5 } }{ 2 } )^{ n } + ( \frac{ 1 - \sqrt{ 5 } }{ 2 }
)^{ n }\)</span>,其满足<span class="math inline">\(f_n = f_{ n - 1 } +
f_{ n - 2 } , f_0 = 2 , f_1 = 1\)</span>,取<span class="math inline">\(f_{ 12 } - 1\)</span>就是答案<span class="math inline">\(321\)</span>.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于一个加法乘法环,要求你利用:</p>
<ol type="1">
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p></li>
<li><p>加法结合律、逆元.</p></li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>倒反天罡题.</p>
<p>注意到<span class="math inline">\(( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a
+ 1 )\)</span>,所以<span class="math inline">\(a + b = b +
a\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你<span class="math inline">\(n\)</span>个数集<span class="math inline">\(a_i\)</span>,其中<span class="math inline">\(| a_i
| = i + 1\)</span>,要你选出<span class="math inline">\(n\)</span>个两两不同的数字满足<span class="math inline">\(x_i \in a_i\)</span>,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是<span class="math inline">\(2^n\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice和Bob博弈.Alice先选一个数<span class="math inline">\(m\)</span>,然后Bob选一个数<span class="math inline">\(n ( n &gt; m )\)</span>,并构造一个<span class="math inline">\(n\)</span>个点的竞赛图.Alice如果能从中选出<span class="math inline">\(m\)</span>个不同的点,满足不存在某个点<span class="math inline">\(x\)</span>到这<span class="math inline">\(m\)</span>个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是<span class="math inline">\(( 1 - \frac{ 1 }{ 2^m } )^{ n - 2
}\)</span>,因此期望为<span class="math inline">\(E = \binom{ n }{ m } (
1 - \frac{ 1 }{ 2^m } )^{ n - 2 }\)</span>,只需<span class="math inline">\(n\)</span>足够大的时候期望<span class="math inline">\(&lt; 1\)</span>,则说明一定存在<span class="math inline">\(0\)</span>,也就是Bob总有必胜策略.</p>
<p>注意到只需证明<span class="math inline">\(\exists n\)</span>,<span class="math inline">\(\binom{ n }{ m } &lt; ( \frac{ 2^m }{ 2^m - 1 }
)^{ n - 2 }\)</span>,而<span class="math inline">\(\binom{ n }{ m } =
\frac{ n^{ \underline{ m } } }{ m ! } &lt; n^m\)</span>.下面证明<span class="math inline">\(\exists n , n^m &lt; ( \frac{ 2^m }{ 2^m - 1 } )^{
n - 2 }\)</span>.</p>
<p>两边取<span class="math inline">\(\ln\)</span>,不妨假设<span class="math inline">\(n \geq 3\)</span>,有<span class="math inline">\(m
\ln n &lt; ( n - 2 ) \ln ( \frac{ 2^m }{ 2^m - 1 } ) , \frac{ m }{ \ln (
\frac{ 2^m }{ 2^m - 1 } ) } &lt; \frac{ n - 2 }{ \ln n }\)</span>,<span class="math inline">\(\frac{ n - 2 }{ \ln n }\)</span>显然在<span class="math inline">\(n \geq
3\)</span>的时候单增,所以一定存在这么一个<span class="math inline">\(n\)</span>.</p>
<h3><span id="2023图选">2023图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>求正整数拆分成有序的<span class="math inline">\(1 ,
2\)</span>序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>定义<span class="math inline">\(*\)</span>为集合<span class="math inline">\(G\)</span>上的二元运算,已知:</p>
<ol type="1">
<li><p>满足结合律<span class="math inline">\(a ∗ b ∗ c = a ∗ ( b ∗ c
)\)</span>.</p></li>
<li><p>存在左单位元<span class="math inline">\(e\)</span>,对任意<span class="math inline">\(a\)</span>满足<span class="math inline">\(e ∗ a =
a\)</span>.</p></li>
<li><p>对任意<span class="math inline">\(a\)</span>存在左逆元<span class="math inline">\(b\)</span>,使<span class="math inline">\(b ∗ a =
e\)</span>.</p></li>
</ol>
<p>问:</p>
<ol type="1">
<li><p>左单位元是否也为右单位元.</p></li>
<li><p>左逆元是否也为右逆元.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>看(2),考虑设<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的左逆元,<span class="math inline">\(c\)</span>是<span class="math inline">\(b\)</span>的左逆元,则<span class="math inline">\(cba = ce = a , ab = ceb = e\)</span>.</p>
<p>看(1),设<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的逆元,<span class="math inline">\(ea =
aba = ae\)</span>,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明<span class="math inline">\(ab\)</span>的时候<span class="math inline">\(b\)</span>不能彻底损失信息,而观察<span class="math inline">\(ab = eab\)</span>知道<span class="math inline">\(a\)</span>也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算<span class="math inline">\(( a_1 , b_1 ) ( a_2 , b_2
)\)</span>,想办法让其损失掉<span class="math inline">\(( a_1 , b_1
)\)</span>中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到<span class="math inline">\(( a_1 , b_1 ) ( a_2 , b_2 ) = ( a_1 + a_2 , b_2
)\)</span>即可,存在左幺元为<span class="math inline">\(( 0 , 0
)\)</span>,右逆元为<span class="math inline">\(( - a , 0 )\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p><span class="math inline">\(f\)</span>的定义域和值域都是正整数并且<span class="math inline">\(f ( xy ) = f ( x ) + f ( y ) - 1\)</span>,求:</p>
<ol type="1">
<li><p>是否存在这样的函数.</p></li>
<li><p>是否存在无数个这样的函数.</p></li>
<li><p>是否存在严格递增的函数.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>令<span class="math inline">\(g ( x ) = f ( x ) - 1\)</span>,则<span class="math inline">\(g ( xy ) = g ( x ) + g ( y )\)</span>.</p>
<p>对于(1),取<span class="math inline">\(g ( x ) = 0 , f ( x ) =
1\)</span>即可.</p>
<p>对于(2),考虑<span class="math inline">\(g ( p^k ) = kg ( p
)\)</span>,只需要让<span class="math inline">\(g ( p
)\)</span>取不同的值即可.</p>
<p>对于(3),考虑<span class="math inline">\(g ( 2^a ) = ag ( 2
)\)</span>,<span class="math inline">\(g ( 3^b ) = bg ( 3
)\)</span>.</p>
<p>考虑构造<span class="math inline">\(a , b\)</span>,使得<span class="math inline">\(2^a &lt; 3^b\)</span>但是<span class="math inline">\(ag ( 2 ) \geq bg ( 3 )\)</span>.不妨取<span class="math inline">\(a = \lceil \frac{ bg ( 3 ) }{ g ( 2 ) }
\rceil\)</span>,那么必定有:</p>
$$
<span class="math display">\[\begin{aligned}
2^{ \lceil \frac{ bg ( 3 ) }{ g ( 2 ) } \rceil } &amp; &lt; 3^b \\
\lceil \frac{ bg ( 3 ) }{ g ( 2 ) } \rceil &amp; &lt; b \log_2 3 \\
\frac{ bg ( 3 ) }{ g ( 2 ) } + \Delta &amp; \leq b \log_2 3 \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是如果存在,必定需要<span class="math inline">\(\frac{ g ( p_1 ) }{
g ( p_2 ) } \geq \log_{ p_2 } p_1 \land \frac{ g ( p_2 ) }{ g ( p_1 ) }
\geq \log_{ p_1 } p_2\)</span>,也就是<span class="math inline">\(\frac{
g ( p_2 ) }{ g ( p_1 ) } = \log_{ p_1 }
p_2\)</span>.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于任意<span class="math inline">\(2 n -
1\)</span>个正整数(可重复),问其中是否一定有<span class="math inline">\(n\)</span>个数的和能被<span class="math inline">\(n\)</span>整除,这题<span class="math inline">\(n =
50\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑当<span class="math inline">\(n\)</span>是合数的时候,设<span class="math inline">\(n = pq\)</span>,则可以将其拆成<span class="math inline">\(q - 1\)</span>组每组<span class="math inline">\(2
p\)</span>个数以及一组<span class="math inline">\(2 p -
1\)</span>个数,因此只需要这些都可以找到<span class="math inline">\(p\)</span>个数使得其是<span class="math inline">\(p\)</span>的倍数,组合起来就行了.</p>
<p>只需要解决<span class="math inline">\(n\)</span>是质数的情况.</p>
<p>感觉场上的最优解应该是解决<span class="math inline">\(n =
2\)</span>和<span class="math inline">\(n =
5\)</span>的情况然后拼成<span class="math inline">\(n = 50\)</span>.</p>
<p><span class="math inline">\(n = 2\)</span>的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然<span class="math inline">\(S = \sum_{  }
( x_{ p_1 } + x_{ p_2 } + \cdots + x_{ p_n } )^{ p - 1 } \equiv \binom{
2 n - 1 }{ n } \equiv 1 \pmod{ n }\)</span>.</p>
<p>但是考虑左边那个多项式的每一项,形如<span class="math inline">\(c
\prod_{ i = 1 }^k x_{ p_i }^{ e_i }\)</span>.注意到<span class="math inline">\(c\)</span>一定是<span class="math inline">\(\binom{ 2 n - 1 - k }{ n - k
}\)</span>的倍数,而后者<span class="math inline">\(\bmod
n\)</span>为<span class="math inline">\(0\)</span>.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为<span class="math inline">\(1\)</span>并不是对称的,而左边是个对称式子,某个<span class="math inline">\(x\)</span>增大也无所谓,这意味着左边应该是为<span class="math inline">\(0\)</span>的,我们要做的就是去证明它是<span class="math inline">\(0\)</span>.</p>
<h3><span id="2024图选">2024图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问在双曲线<span class="math inline">\(xy =
1\)</span>上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>不会做,取个特殊值知道答案应该是<span class="math inline">\([ 2 \sqrt{
6 } , + \infty )\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(n , m\)</span>都是好的,那么<span class="math inline">\(nm\)</span>是好的.</p></li>
<li><p><span class="math inline">\(2024\)</span>不是好的.</p></li>
</ol>
<h5><span id="solution2">Solution2</span></h5>
<p>如果<span class="math inline">\(n = a^2 + b^2 , m = c^2 +
d^2\)</span>,那么<span class="math inline">\(nm = a^2 c^2 + a^2 d^2 +
b^2 c^2 + b^2 d^2 = ( ac - bd )^2 + ( ad + bc )^2\)</span>.</p>
<p><span class="math inline">\(2024 = 2^3 \times 11 \times
23\)</span>,使用反证法,不妨设其可以被表示为<span class="math inline">\(a^2 + b^2\)</span>.</p>
<p>讨论一下:如果<span class="math inline">\(a ,
b\)</span>均为奇数,那么<span class="math inline">\(a^2 + b^2 \equiv 2
\pmod{ 8 }\)</span>,不符题意.</p>
<p>于是<span class="math inline">\(a ,
b\)</span>应该均为偶数,那么就有<span class="math inline">\(a &#39;^2 + b
&#39;^2 = 506\)</span>.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于集合<span class="math inline">\(G\)</span>,<span class="math inline">\(e \in G\)</span>,定义域为<span class="math inline">\(G\)</span>的函数<span class="math inline">\(f\)</span>满足以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(e \in G\)</span>,但<span class="math inline">\(e\)</span>不在<span class="math inline">\(f\)</span>的值域中.</p></li>
<li><p><span class="math inline">\(G\)</span>关于<span class="math inline">\(f\)</span>封闭.</p></li>
<li><p>若<span class="math inline">\(\exists A \subseteq
G\)</span>,<span class="math inline">\(e \in A\)</span>且<span class="math inline">\(A\)</span>对<span class="math inline">\(f\)</span>封闭,则<span class="math inline">\(A =
G\)</span>.</p></li>
</ol>
<p>在<span class="math inline">\(G\)</span>上定义二元运算<span class="math inline">\(\circ\)</span>,满足<span class="math inline">\(ae
= a , af ( b ) = f ( ab )\)</span>.</p>
<p>求证:</p>
<ol type="1">
<li><p>存在幺元.</p></li>
<li><p>运算满足交换律.</p></li>
<li><p>运算满足结合律.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往<span class="math inline">\(A\)</span>里面扔个<span class="math inline">\(e\)</span>,此时<span class="math inline">\(A\)</span>一定不满足条件.我们不断从<span class="math inline">\(A\)</span>中选出一个元素<span class="math inline">\(w\)</span>满足<span class="math inline">\(f ( w )
\notin A\)</span>,并把<span class="math inline">\(A : = A \cup \{ f ( w
) \}\)</span>.不断做这个过程显然最后会得到<span class="math inline">\(G\)</span>,这意味着任何一个元素<span class="math inline">\(a\)</span>可以写成<span class="math inline">\(f (
f ( f \cdots f ( e ) ) )\)</span>的形式.</p>
<p>不妨将<span class="math inline">\(f\)</span>函数嵌套<span class="math inline">\(k\)</span>次记作<span class="math inline">\(f^{ (
k ) }\)</span>,那么我们要证明的是<span class="math inline">\(a = f^{ ( A
) } ( e ) , b = f^{ ( B ) } ( e )\)</span>,<span class="math inline">\(ab = ba\)</span>.</p>
<p>考虑<span class="math inline">\(ab = f^{ ( A ) } ( e ) f^{ ( B ) } (
e ) = f^{ ( B ) } ( f^{ ( A ) } ( e ) e ) = f^{ ( A + B ) } ( e
)\)</span>,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给出一个具体函数满足:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( x + y ) = f ( x ) + f ( y ) +
xy\)</span>.</p></li>
<li><p><span class="math inline">\(f ( xy ) = f ( x ) f ( y ) + f ( x -
1 ) f ( y - 1 )\)</span>.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>先注意到<span class="math inline">\(f ( 0 ) = 0 , f ( 1 ) =
1\)</span>.</p>
<p>以<span class="math inline">\(x\)</span>为主元两边求导,立刻得到<span class="math inline">\(f &#39; ( x + y ) = f &#39; ( x ) +
y\)</span>,因此<span class="math inline">\(f &#39; ( x
)\)</span>是斜率为<span class="math inline">\(1\)</span>的一次函数,立刻得到<span class="math inline">\(f ( x ) = \frac{ x^2 }{ 2 } + \frac{ x }{ 2
}\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于<span class="math inline">\(r = \sqrt{ 2
}\)</span>,是否存在正整数<span class="math inline">\(p\)</span>和整数<span class="math inline">\(q\)</span>满足<span class="math inline">\(| pr - q
| &lt; \frac{ 1 }{ 2024 }\)</span>且<span class="math inline">\(p &lt;
2024\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑取<span class="math inline">\(0 , \sqrt{ 2 } , 2 \sqrt{ 2 } , 3
\sqrt{ 2 } , \cdots 2023 \sqrt{ 2 }\)</span>的小数部分,记作<span class="math inline">\(a_0 , a_1 , \cdots a_{ 2023 }\)</span>.</p>
<p>由鸽笼原理,一定存在两个数<span class="math inline">\(0 \leq x &lt; y
\leq 2023\)</span>满足<span class="math inline">\(| a_x - a_y | &lt;
\frac{ 1 }{ 2024 }\)</span>,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>在一个数轴上,你站在<span class="math inline">\(0\)</span>点,并按照如下算法寻找<span class="math inline">\(x ( x &gt; 0 )\)</span>点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. <span class="math inline">\(3 x\)</span> B. <span class="math inline">\(5 x\)</span> C. <span class="math inline">\(7
x\)</span> D. <span class="math inline">\(9 x\)</span> E.
以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>考虑找到牛的时候<span class="math inline">\(step\)</span>为多少,应该为<span class="math inline">\(2^{ 2 k }\)</span>,其中<span class="math inline">\(k\)</span>满足<span class="math inline">\(2^{ 2 k
} \geq x &gt; 2^{ 2 ( k - 1 ) }\)</span>.此时走的步数应该是<span class="math inline">\(ans = 2 \sum_{ i = 0 }^{ 2 k - 1 } 2^i + x = 2^{ 2
k + 1 } - 1 + x\)</span>步.而<span class="math inline">\(x \leq 2^{ 2 k
} &lt; 4 x\)</span>,所以<span class="math inline">\(ans &lt; 9 x -
1\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定<span class="math inline">\(10\)</span>个实数变量<span class="math inline">\(x_1 , \cdots , x_{ 10 }\)</span>,满足它们均<span class="math inline">\(\geq 1\)</span>且两两不同.你要寻找一组<span class="math inline">\(\{ x \}\)</span>和一个实数<span class="math inline">\(a\)</span>,使得存在尽可能多组<span class="math inline">\(\langle b \rangle , b_i = \pm 1\)</span>,满足<span class="math inline">\(\sum_{ i = 1 }^{ 10 } b_i x_i \in ( a , a + 2
)\)</span>.</p>
<p>最多存在多少组<span class="math inline">\(\langle b
\rangle\)</span>?</p>
<p>A. <span class="math inline">\(512\)</span> B. <span class="math inline">\(252\)</span> C. <span class="math inline">\(504\)</span> D. <span class="math inline">\(684\)</span> E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>不妨猜测<span class="math inline">\(x\)</span>全取<span class="math inline">\(1\)</span>最优,此时的答案是<span class="math inline">\(\binom{ 10 }{ 5 } = 252\)</span>.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于<span class="math inline">\(x \geq 1\)</span>,所以如果存在两组<span class="math inline">\(\langle b \rangle\)</span>,使得<span class="math inline">\(A\)</span>组中选择取<span class="math inline">\(+
1\)</span>恰好是<span class="math inline">\(B\)</span>组的子集,那么<span class="math inline">\(S_A \leq S_B - 2\)</span>,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让<span class="math inline">\(x\)</span>尽可能接近<span class="math inline">\(1\)</span>,这样就是满足条件的.所以问题变为对于一个大小为<span class="math inline">\(10\)</span>的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取<span class="math inline">\(\binom{ 10 }{ 5
}\)</span>最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给定无向图<span class="math inline">\(G = ( V , E
)\)</span>,我们称一个图是好的,如果:</p>
<ol type="1">
<li><p>每个点的度数均为<span class="math inline">\(d\)</span>.</p></li>
<li><p>任何一个大小不超过<span class="math inline">\(\frac{ | V | }{ 2
}\)</span>的联通集合<span class="math inline">\(S\)</span>,其邻居(不属于<span class="math inline">\(S\)</span>但和<span class="math inline">\(S\)</span>中的某个点存在直接相连的边)的大小<span class="math inline">\(\geq \frac{ 5 }{ 4 } | S |\)</span>.</p></li>
</ol>
<p>求证:好的图中任意两个点<span class="math inline">\(u ,
v\)</span>之间的最短路径长度<span class="math inline">\(dis ( u , v ) =
O ( \log | V | )\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑以<span class="math inline">\(u\)</span>为起点一点一点往外扩张,这样一直扩张到<span class="math inline">\(\frac{ | V | }{ 2 } +
1\)</span>时,集合中每个点到<span class="math inline">\(u\)</span>的距离不超过<span class="math inline">\(O ( \log | V | )\)</span>.</p>
<p>然后以<span class="math inline">\(v\)</span>做同样的事,由于这两个集合大小之和大于<span class="math inline">\(| V
|\)</span>,说明一定有交,且存在一条路径长度为<span class="math inline">\(O ( \log | V |
)\)</span>的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你两个完全相同的鸡蛋和一个<span class="math inline">\(n =
100\)</span>层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有<span class="math inline">\(101\)</span>个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设<span class="math inline">\(f_{ i , 1 / 2 }\)</span>表示一棵有<span class="math inline">\(i\)</span>个叶子的树,最多向右走<span class="math inline">\(1 / 2\)</span>步,深度最低为多少.显然<span class="math inline">\(f_{ i , 1 } = i - 1\)</span>.</p>
<p>不妨设最后的最大深度为<span class="math inline">\(k\)</span>,需要满足<span class="math inline">\(1 +
\sum_{ i = 1 }^k i = 1 + \frac{ k ( k + 1 ) }{ 2 } \geq 101 , k ( k + 1
) \geq 200\)</span>,<span class="math inline">\(k_{ \min } =
14\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p><span class="math inline">\(n\)</span>个人要进行一场游戏.游戏设计者准备了<span class="math inline">\(n\)</span>张卡片,正面分别写着<span class="math inline">\(n\)</span>个人的名字,背面写了<span class="math inline">\([ 1 , n ]\)</span>共<span class="math inline">\(n\)</span>个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,<span class="math inline">\(n\)</span>个人可以经过充分的讨论,并依次进入房间,一张一张地翻开<span class="math inline">\(\lfloor \frac{ n }{ 2 }
\rfloor\)</span>张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有<span class="math inline">\(n\)</span>个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过<span class="math inline">\(0 . 1\)</span>的胜率.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是<span class="math inline">\(a\)</span>,如果<span class="math inline">\(a\)</span>就是自己的编号就下班;反之接下来翻开<span class="math inline">\(a\)</span>位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于<span class="math inline">\(\frac{ n }{ 2 }\)</span>的环.</p>
<p>考虑总方案数是<span class="math inline">\(n
!\)</span>.不妨枚举这个环的长度为<span class="math inline">\(K\)</span>,则存在一个长度<span class="math inline">\(= K &gt; \frac{ n }{ 2
}\)</span>的环的方案数是<span class="math inline">\(\binom{ n }{ K } ( K
- 1 ) ! ( n - K ) ! = \frac{ n ! }{ K }\)</span>.所以此时的概率为<span class="math inline">\(\frac{ 1 }{ K }\)</span>.</p>
<p>那么失败的概率就是<span class="math inline">\(H_n - H_{ \frac{ n }{ 2
} } \approx \ln 2\)</span>.</p>
<h3><span id="2022茶选">2022茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化<span class="math inline">\(z = 5 x_1 + 8 x_2 + 4
x_3\)</span>,其中:</p>
<ol type="1">
<li><p><span class="math inline">\(x_1 , x_2 , x_3 \geq
0\)</span></p></li>
<li><p><span class="math inline">\(\frac{ 1 }{ 2 } x_1 + 5 x_2 + 9 x_3
\leq 3\)</span></p></li>
<li><p><span class="math inline">\(4 x_1 + 7 x_2 + 3 x_3 \leq
6\)</span></p></li>
</ol>
<p>再提一个问题:最小化<span class="math inline">\(v = 3 y_1 + 6
y_2\)</span>,其中:</p>
<ol type="1">
<li><p><span class="math inline">\(y_1 , y_2 \geq 0\)</span></p></li>
<li><p><span class="math inline">\(\frac{ 1 }{ 2 } y_1 + 4 y_2 \geq
5\)</span></p></li>
<li><p><span class="math inline">\(5 y_1 + 7 y_2 \geq
8\)</span></p></li>
<li><p><span class="math inline">\(9 y_1 + 3 y_2 \geq
4\)</span></p></li>
</ol>
<p>现在请你证明:<span class="math inline">\(z \leq v\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>下面乘一下配一下上面的系数,自然得证.</p>
<p>写成矩阵形式,设<span class="math inline">\(X = \begin{bmatrix}x_1
&amp; x_2 &amp; x_3\end{bmatrix} , A = \begin{bmatrix}0 . 5 &amp; 4 \\ 5
&amp; 7 \\ 9 &amp; 3\end{bmatrix} , Y = \begin{bmatrix}y_1 \\
y_2\end{bmatrix}\)</span>,不难发现<span class="math inline">\(z \leq XAY
\leq v\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>半径为<span class="math inline">\(R\)</span>的球里放点,要求两两之间距离不能小于<span class="math inline">\(1\)</span>,证明至多放<span class="math inline">\((
2 R + 1 )^3\)</span>个.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>要求两两距离不能小于<span class="math inline">\(1\)</span>等价于往其中放半径为<span class="math inline">\(0 . 5\)</span>的球,这种球体积为<span class="math inline">\(\frac{ 4 }{ 3 } \pi \frac{ 1 }{ 8
}\)</span>.然后原球要扩大一圈,所以原球体积变为<span class="math inline">\(\frac{ 4 }{ 3 } \pi ( R + 0 . 5
)^3\)</span>.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数<span class="math inline">\(n\)</span>.</p>
<p>它每秒以<span class="math inline">\(v\)</span>的速度行驶,其中<span class="math inline">\(v\)</span>是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数<span class="math inline">\(x\)</span>,你会得知此时车的坐标是否是<span class="math inline">\(x\)</span>(Yes or No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>第<span class="math inline">\(t\)</span>秒的时候车应该在<span class="math inline">\(n +
vt\)</span>处.由于我们知道现在是第几秒,枚举<span class="math inline">\(n
, v\)</span>然后不断check即可.这个是经典的证明<span class="math inline">\(\mathbb{ Z }^2\)</span>和<span class="math inline">\(\mathbb{ N }\)</span>等势.按照<span class="math inline">\(| n | + | v |\)</span>排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对满足<span class="math inline">\(\forall i , | i - p_i | \leq
1\)</span>的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>简单题,设<span class="math inline">\(f_n\)</span>为答案,考虑<span class="math inline">\(p_n\)</span>取什么.</p>
<p>当<span class="math inline">\(p_n = n\)</span>时,方案数为<span class="math inline">\(f_{ n - 1 }\)</span>.</p>
<p>当<span class="math inline">\(p_n = n - 1\)</span>时,<span class="math inline">\(p_{ n - 1 } = n\)</span>,方案数为<span class="math inline">\(f_{ n - 2 }\)</span>.</p>
<p>于是,<span class="math inline">\(f_1 = 1 , f_2 = 2\)</span>,<span class="math inline">\(f_n = f_{ n - 1 } + f_{ n - 2 }\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>你有一个<span class="math inline">\(n \times
n\)</span>的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择<span class="math inline">\(k\)</span>个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数<span class="math inline">\(k\)</span>最小值是<span class="math inline">\(n\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是<span class="math inline">\(\frac{ 4 n }{ 4 } = n\)</span>个.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>设<span class="math inline">\(F = \{ S_1 , S_2 , S_3 , . . . , S_{ |
F | } \}\)</span>,定义一个集合<span class="math inline">\(T\)</span>能被<span class="math inline">\(F\)</span> shattered为:<span class="math inline">\(T\)</span>的任意一个子集(包括它自己和空集),都可以由<span class="math inline">\(T \cap S_{ i_1 } \cap S_{ i_2 } . .
.\)</span>表示.其中<span class="math inline">\(S_{ i_j }\)</span>是<span class="math inline">\(F\)</span>中的集合(就是说每个子集都等于<span class="math inline">\(T\)</span>和某些<span class="math inline">\(F\)</span>内集合的交.)</p>
<p>定义一个<span class="math inline">\(F\)</span>的”VC-Dimension”是,能被他shattered的集合<span class="math inline">\(T\)</span>的大小的最大值.</p>
<p><span class="math inline">\(F\)</span>中的集合们只会包含某<span class="math inline">\(n\)</span>种不同的元素.证明:</p>
<ol type="1">
<li><p>任意一个<span class="math inline">\(F\)</span>能shattered的<span class="math inline">\(T\)</span>至少有<span class="math inline">\(| F
|\)</span>个.</p></li>
<li><p>对于一个VC-Dimension的大小为<span class="math inline">\(k\)</span>的<span class="math inline">\(F\)</span>,其<span class="math inline">\(| F |
\leq \sum_{ i = 0 }^k \binom{ n }{ i }\)</span>.</p></li>
</ol>
<h5><span id="solution6">Solution6</span></h5>
<p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的<span class="math inline">\(S\)</span>,满足<span class="math inline">\(S , S
\cup \{ x \} \in F\)</span>,然后将这些<span class="math inline">\(S \cap
\{ x \}\)</span>拎出来,假设有<span class="math inline">\(t\)</span>个,左边删去<span class="math inline">\(x\)</span>后再进行数学归纳得到<span class="math inline">\(| F | -
t\)</span>个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有<span class="math inline">\(t\)</span>个集合,在这<span class="math inline">\(t\)</span>个集合添上<span class="math inline">\(x\)</span>这个元素即可.</p>
<p><span class="math inline">\(t =
0\)</span>怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为<span class="math inline">\(S\)</span>(选取最大的那个集合为新加入的),我们在前面的集合中找到一个与<span class="math inline">\(S\)</span>有交的集合<span class="math inline">\(T\)</span>,根据上面的预处理,此集合显然存在.选出一个<span class="math inline">\(x \in S \setminus T\)</span>,不妨设<span class="math inline">\(S = S &#39; \cup \{ x \}\)</span>,令<span class="math inline">\(T &#39; = S &#39; \cap T\)</span>,然后用<span class="math inline">\(T &#39;\)</span>代替原本的<span class="math inline">\(T\)</span>即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>令<span class="math inline">\(p ( x )\)</span>表示<span class="math inline">\(x\)</span>的最大质因子,求所有<span class="math inline">\(( x , y , z )\)</span>使得:</p>
<ol type="1">
<li><p><span class="math inline">\(x &lt; y &lt; z\)</span>且<span class="math inline">\(x + z = 2 y\)</span>.</p></li>
<li><p><span class="math inline">\(p ( xyz ) \leq 3\)</span>.</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>不妨令<span class="math inline">\(g = \gcd ( x , y , z
)\)</span>,令<span class="math inline">\(x &#39; = \frac{ x }{ g
}\)</span>,则只需要解:<span class="math inline">\(x &#39; + z &#39; = 2
y &#39;\)</span>.</p>
<p>我们有<span class="math inline">\(y - x = z - y\)</span>,则<span class="math inline">\(\gcd ( y &#39; , x &#39; ) = \gcd ( y &#39; , y
&#39; - x &#39; ) = \gcd ( y &#39; , z &#39; ) =
1\)</span>,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol type="1">
<li><p><span class="math inline">\(2 \nmid x &#39; , 2 \nmid z
&#39;\)</span>.</p></li>
<li><p><span class="math inline">\(2 \mid x &#39; , 2 \mid z &#39; , 2
\nmid y &#39;\)</span>.</p></li>
</ol>
<p>先看(1),设<span class="math inline">\(x &#39; = 3^a , z &#39; = 3^c ,
y &#39; = 2^b\)</span>.方程变为<span class="math inline">\(3^a ( 1 + 3^{
c - a } ) = 2^{ b + 1 }\)</span>,一定有<span class="math inline">\(a =
0\)</span>,只需解<span class="math inline">\(1 + 3^{ c } = 2^{ b + 1
}\)</span>.</p>
<p>当<span class="math inline">\(b \leq 2\)</span>的时候,经检验有<span class="math inline">\(\begin{cases}c = 0 \\ b =
0\end{cases}\)</span>(舍)和<span class="math inline">\(\begin{cases}c =
1 \\ b = 1\end{cases}\)</span>两组解.</p>
<p>当<span class="math inline">\(b \geq 3\)</span>的时候,注意到<span class="math inline">\(3^{ c } \equiv - 1 \pmod{ 4 }\)</span>,所以<span class="math inline">\(c\)</span>是偶数.又注意到<span class="math inline">\(3^{ c } \equiv - 1 \pmod{ 8
}\)</span>,但是奇数的平方<span class="math inline">\(\bmod
8\)</span>应该是<span class="math inline">\(1\)</span>,不符.</p>
<p>再看(2),设<span class="math inline">\(x &#39; = 2^d , z &#39; = 2^e ,
y &#39; = 3^b\)</span>.</p>
<p>当<span class="math inline">\(e = 1\)</span>时,显然不符.</p>
<p>当<span class="math inline">\(d = 1 , e &gt; 1\)</span>时,要解<span class="math inline">\(2^{ e - 1 } + 1 = 3^{ b }\)</span>.当<span class="math inline">\(e = 2\)</span>的时候有一组解<span class="math inline">\(\begin{cases}e = 2 \\ b =
1\end{cases}\)</span>.当<span class="math inline">\(e \geq
3\)</span>的时候,有<span class="math inline">\(3^b \equiv 1 \pmod{ 4
}\)</span>,说明<span class="math inline">\(b\)</span>是偶数.</p>
<p>那必然有<span class="math inline">\(2^{ e - 1 } = 3^b - 1 = ( 3^{
\frac{ b }{ 2 } } + 1 ) ( 3^{ \frac{ b }{ 2 } } - 1 )\)</span>.令<span class="math inline">\(t = 3^{ \frac{ b }{ 2 } } - 1\)</span>,则<span class="math inline">\(2^{ e - 1 } = t ( t + 2 )\)</span>.则要么<span class="math inline">\(t = 2\)</span>,要么<span class="math inline">\(t +
2 = 2\)</span>.解出<span class="math inline">\(b -
2\)</span>,此时有<span class="math inline">\(\begin{cases}e = 4 \\ b =
2\end{cases}\)</span>.</p>
<p>综上,解出来的解有<span class="math inline">\(\begin{cases}x &#39; = 2
\\ y &#39; = 3 \\ z &#39; = 4\end{cases} , \begin{cases}x &#39; = 1 \\ y
&#39; = 2 \\ z &#39; = 3\end{cases} , \begin{cases}x &#39; = 2 \\ y
&#39; = 9 \\ z &#39; = 16\end{cases}\)</span>.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程<span class="math inline">\(2^x + 1 =
3^y\)</span>,考虑两边<span class="math inline">\(\bmod
3\)</span>知道<span class="math inline">\(x\)</span>是奇数,于是<span class="math inline">\(v_3 ( 2^x + 1 ) = v_3 ( 3 ) + v_3 ( x ) = y , 3^{
y - 1 } | x , x \geq 3^{ y - 1 }\)</span>,用这个放缩一下就行.</p>
<p>再看方程<span class="math inline">\(2^x = 3^y +
1\)</span>.仍然考虑两边<span class="math inline">\(\bmod
4\)</span>,知道<span class="math inline">\(y\)</span>是奇数.<span class="math inline">\(x = v_2 ( 3^y + 1 ) = v_2 ( 3 + 1 ) =
2\)</span>,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定两个随机分布：</p>
<p><span class="math inline">\(x ∼ D_1\)</span>:从<span class="math inline">\({ 0 , 1 , … , p − 1
}\)</span>中等概率随机一个<span class="math inline">\(y\)</span>,令<span class="math inline">\(x = y   \bmod  { 2^k }\)</span>.</p>
<p><span class="math inline">\(x ∼ D_1\)</span>:从<span class="math inline">\({ 0 , 1 , … , 2^k - 1
}\)</span>中等概率随机一个<span class="math inline">\(y\)</span>,令<span class="math inline">\(x = y\)</span>.</p>
<p>定义二者的统计距离为:<span class="math inline">\(SD ( D_1 , D_2 ) =
\frac{ 1 }{ 2 } \sum_{ i = 0 }^{ 2^k - 1 } | P_{ D_1 } ( x = i ) - P_{
D_2 } ( x = i ) |\)</span>.</p>
<p>求证:<span class="math inline">\(SD ( D_1 , D_2 ) ≤ \frac{ 2^k }{ 4 p
}\)</span>.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>令<span class="math inline">\(w = p \bmod{ 2^k }\)</span>.则<span class="math inline">\(SD ( D_1 , D_2 ) = \frac{ w }{ 2 } ( P_{ D_1 } ( x
= 0 ) - P_{ D_2 } ( x = 0 ) ) + \frac{ 2^k - w }{ 2 } ( P_{ D_2 } ( x =
w ) - P_{ D_1 } ( x = w ) )\)</span>.</p>
<p>令<span class="math inline">\(k = \lfloor \frac{ p }{ 2^k } \rfloor =
\frac{ p - w }{ 2^k }\)</span>不难发现<span class="math inline">\(P_{
D_1 } ( x = 0 ) = \frac{ k + 1 }{ p } , P_{ D_1 } ( x = w ) = \frac{ k
}{ p }\)</span>.</p>
<p>则<span class="math inline">\(SD ( D_1 , D_2 ) = \frac{ w }{ 2 } (
\frac{ p - w + 2^k }{ p 2^k } - \frac{ 1 }{ 2^k } ) + \frac{ 2^k - w }{
2 } ( \frac{ 1 }{ 2^k } - \frac{ p - w }{ p 2^k } ) = \frac{ 1 }{ 2^{ k
+ 1 } } ( \frac{ w ( 2^k - w ) }{ p } + \frac{ w ( 2^k - w ) }{ p } ) =
\frac{ w ( 2^k - w ) }{ p 2^k }\)</span>.</p>
<p>要证明<span class="math inline">\(\frac{ w ( 2^k - w ) }{ p 2^k }
\leq \frac{ 2^k }{ 4 p } \Leftrightarrow w ( 2^k - w ) \leq ( 2^{ k - 1
} )^2\)</span>.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给你一个单增函数<span class="math inline">\(f\)</span>,满足定义域和值域都是<span class="math inline">\(\mathbb{ N }\)</span>,并且<span class="math inline">\(f ( f ( n ) ) = 3 n\)</span>,求<span class="math inline">\(f ( 2023 )\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>首先我们不妨先试一下<span class="math inline">\(f ( f ( 1 ) ) =
3\)</span>.由于<span class="math inline">\(f ( 1 ) \geq
2\)</span>,且<span class="math inline">\(f ( 1 ) \ne
3\)</span>,所以<span class="math inline">\(f ( 1 ) = 2 , f ( 2 ) =
3\)</span>.</p>
<p>考虑<span class="math inline">\(f ( 3 n )\)</span>,必然存在一个<span class="math inline">\(n &lt; m &lt; 3 n\)</span>,使得<span class="math inline">\(f ( n ) = m , f ( m ) = 3 n\)</span>.</p>
<p>用这个找前几项,发现规律是把<span class="math inline">\(n\)</span>写成三进制形式,如果首位是<span class="math inline">\(1\)</span>就变成<span class="math inline">\(2\)</span>,首位是<span class="math inline">\(2\)</span>就改为<span class="math inline">\(1\)</span>再在后面加个<span class="math inline">\(0\)</span>.容易验证这是合法的<span class="math inline">\(f\)</span>且<span class="math inline">\(f ( 2023 )
= 3882\)</span>.</p>
<p>但问题没有解决,需要证明它是唯一的<span class="math inline">\(f\)</span>.</p>
<p>考虑数学归纳假设现在<span class="math inline">\(f ( x ) , x \in [ 1 ,
3 k ]\)</span>都确定了.</p>
<p>注意到如果<span class="math inline">\(f ( n ) = m , f ( m ) = 3 n , f
( 3 n ) = 3 m , f ( 3 m ) = 9 n\)</span>.所以如果<span class="math inline">\(f ( n ) = m\)</span>,我们实际上有<span class="math inline">\(f ( 3^k m ) = 3^{ k + 1 } n , f ( 3^k n ) = 3^k
m\)</span>.数学归纳即可以证明<span class="math inline">\(f ( 3 k + 3
)\)</span>一定是确定的.</p>
<p>接下来要证明<span class="math inline">\(f ( 3 k + 1 )\)</span>和<span class="math inline">\(f ( 3 k + 2 )\)</span>一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( 3 k ) + 3 = f ( 3 k + 3
)\)</span>.</p></li>
<li><p><span class="math inline">\(\exists n , f ( n ) = 3 k + w ( w \in
\{ 1 , 2 \} )\)</span>.</p></li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当<span class="math inline">\(k\)</span>在三进制下首位如果是<span class="math inline">\(2\)</span>,则一定满足(2).</p>
<p>当<span class="math inline">\(k\)</span>在三进制下首位是<span class="math inline">\(1\)</span>,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对于一个<span class="math inline">\(n \times n\)</span>的包含<span class="math inline">\([ 1 , n^2
]\)</span>各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol type="1">
<li><p>如果一个排列矩阵满足每行恰有模<span class="math inline">\(n\)</span>余<span class="math inline">\([ 0 , n -
1
]\)</span>的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列为<span class="math inline">\(( i - 1
) n + j\)</span>的矩阵(不妨称为有序矩阵).</p></li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列<span class="math inline">\(\bmod
n\)</span>不相同,可以先将每行按照<span class="math inline">\(\bmod
n\)</span>排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将<span class="math inline">\(\bmod
n\)</span>不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是<span class="math inline">\(n\)</span>正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>有<span class="math inline">\(n ( \geq 2
)\)</span>个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称<span class="math inline">\(n\)</span>是好的.求证:</p>
<ol type="1">
<li><p><span class="math inline">\(4\)</span>是好的.</p></li>
<li><p>如果<span class="math inline">\(n\)</span>是奇数,那么<span class="math inline">\(n\)</span>不是好的.</p></li>
<li><p>求出所有好的<span class="math inline">\(n\)</span>.</p></li>
</ol>
<h5><span id="solution5">Solution5</span></h5>
<p>首先可以证明<span class="math inline">\(2\)</span>是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要<span class="math inline">\(2^n\)</span>步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到<span class="math inline">\(1100\)</span>来一个<span class="math inline">\(1010\)</span>之后啥也不变,但是<span class="math inline">\(1010\)</span>来一个<span class="math inline">\(1010\)</span>一定赢了.所以上来先来一个<span class="math inline">\(1010\)</span>,如果赢了就下班,没赢就来个<span class="math inline">\(1100\)</span>,这样<span class="math inline">\(1100\)</span>要么下班,要么变成了<span class="math inline">\(1010\)</span>,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:<span class="math inline">\(0000 , 1111 ,
1010 , 1111 , 1100 , 1111 , 1010 , 1111 , 1000 , 1111 , 1010 , 1111 ,
1100 , 1111 , 1010 , 1111\)</span>.</p>
<p>上面的构造启发我们手玩一下<span class="math inline">\(n =
3\)</span>,注意到此时的问题在于<span class="math inline">\(100\)</span>和<span class="math inline">\(110\)</span>,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全<span class="math inline">\(0\)</span>;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全<span class="math inline">\(0\)</span>.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全<span class="math inline">\(0\)</span>的成功状态.我们不妨令一个成功状态的度为<span class="math inline">\(d\)</span>表示它可以经过<span class="math inline">\(d\)</span>步到达全<span class="math inline">\(0\)</span>,显然全<span class="math inline">\(1\)</span>的<span class="math inline">\(d =
1\)</span>,<span class="math inline">\(n = 4\)</span>的时候,<span class="math inline">\(1010\)</span>的<span class="math inline">\(d =
2\)</span>,因为其可以通过一次操作转化为全<span class="math inline">\(1\)</span>,<span class="math inline">\(1100\)</span>的<span class="math inline">\(d =
3\)</span>,因为其可以用一次操作转化为<span class="math inline">\(1010\)</span>.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向<span class="math inline">\(d\)</span>比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然<span class="math inline">\(n = 3\)</span>的时候,<span class="math inline">\(\{ 110 , 100 \}\)</span>就是失败状态.</p>
<p>而对于<span class="math inline">\(n\)</span>取任意来说,一定得存在一个<span class="math inline">\(d = 2\)</span>的成功状态.一个显然的<span class="math inline">\(d =
2\)</span>的成功状态要满足的条件是,假设它是<span class="math inline">\(a\)</span>,那么存在一个数<span class="math inline">\(b\)</span>,使得<span class="math inline">\(a
\oplus b\)</span>是全<span class="math inline">\(1\)</span>或者全<span class="math inline">\(0\)</span>.既然<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>旋转后只有两种结果,那么<span class="math inline">\(b\)</span>的循环节必定为<span class="math inline">\(2\)</span>,也就是<span class="math inline">\(b\)</span>一定要是<span class="math inline">\(101
\cdots 010\)</span>这样的,于是<span class="math inline">\(n\)</span>是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找<span class="math inline">\(d =
3\)</span>的成功状态,现在我们已知的四种成功状态是<span class="math inline">\(111 \cdots 111\)</span>,<span class="math inline">\(000 \cdots 000\)</span>,<span class="math inline">\(101 \cdots 010\)</span>,<span class="math inline">\(010 \cdots
101\)</span>,所以考虑构造一个循环节长度为<span class="math inline">\(4\)</span>的串,使得异或完它是这上面四种其一,注意到<span class="math inline">\(1100 \cdots 1100\)</span>就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明<span class="math inline">\(n =
2^k\)</span>一定是好的.考虑数学归纳,不妨这么干:构造一个长度为<span class="math inline">\(2^{ k - 1 }\)</span>的串<span class="math inline">\(b\)</span>,使得其<span class="math inline">\(b_i =
a_i \oplus a_{ i + 2^{ k - 1 } }\)</span>.然后由数学归纳,可以造出<span class="math inline">\(b\)</span>全<span class="math inline">\(0\)</span>的情况.而如果<span class="math inline">\(b\)</span>全<span class="math inline">\(0\)</span>,则原串一定存在长为<span class="math inline">\(2^{ k - 1
}\)</span>的循环节,并且消除循环节的过程不会改变<span class="math inline">\(b\)</span>的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设<span class="math inline">\(n = 2^k m\)</span>,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造<span class="math inline">\(b\)</span>数组,由于<span class="math inline">\(b\)</span>数组都不可能全<span class="math inline">\(0\)</span>,显然也不可能成立.</p>
<p>这个能不能顺便证明<span class="math inline">\(n\)</span>是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了<span class="math inline">\(n - 1\)</span>个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前<span class="math inline">\(n - 1\)</span>个位置的异或值为<span class="math inline">\(1\)</span>.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为<span class="math inline">\(50 \%\)</span>,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>简单题,设<span class="math inline">\(f_0 , f_1 , f_2 ,
f_3\)</span>,然后有<span class="math inline">\(\begin{cases}f_3 = 0 \\
f_2 = \frac{ 1 }{ 2 } f_3 + \frac{ 1 }{ 2 } f_0 + 1 \\ f_1 = \frac{ 1 }{
2 } f_2 + \frac{ 1 }{ 2 } f_0 + 1 \\ f_0 = \frac{ 1 }{ 2 } f_1 + \frac{
1 }{ 2 } f_0 + 1\end{cases}\)</span>,算出<span class="math inline">\(f_0
= 14\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<p><span class="math display">\[
x^3 + □ x^2 + □ x + □ = 0
\]</span></p>
<h5><span id="solution2">Solution2</span></h5>
<p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为<span class="math inline">\(- A , - B , -
C\)</span>,方程应该可以写作<span class="math inline">\(( x + A ) ( x + B
) ( x + C ) = 0\)</span>.</p>
<p>拆开有<span class="math inline">\(x^3 + ( A + B + C ) x^2 + ( AB + AC
+ BC ) x + ABC = 0\)</span>.</p>
<p>这么对称,不妨猜一手Alice先选择<span class="math inline">\(0\)</span>,讨论一下:</p>
<ol type="1">
<li>Bob令<span class="math inline">\(ABC = 0\)</span>.不妨令<span class="math inline">\(C = 0\)</span>.</li>
</ol>
<p>此时方程变为<span class="math inline">\(x^2 + ( A + B ) x + AB =
0\)</span>.直接秒了,随便选一个数就行(比如选<span class="math inline">\(3\)</span>,如果Bob令<span class="math inline">\(AB
= 3\)</span>,就再选<span class="math inline">\(4\)</span>;如果令<span class="math inline">\(A + B = 3\)</span>,就再选<span class="math inline">\(2\)</span>)</p>
<ol start="2" type="1">
<li>Bob令<span class="math inline">\(A + B + C = 0 , C = - A -
B\)</span>.</li>
</ol>
<p>不妨令<span class="math inline">\(C &#39; = - C , D =
AB\)</span>,则<span class="math inline">\(AB + AC + BC = D - C &#39;^2 ,
ABC = DC &#39;\)</span>.</p>
<p>接下来Alice要选择一个数字<span class="math inline">\(k\)</span>,如果Bob又令<span class="math inline">\(D - C &#39;^2 = k\)</span>,发现在此时如果<span class="math inline">\(k\)</span>是一个负的完全平方数,并且Alice接下来选择<span class="math inline">\(0\)</span>,当场就下班了.</p>
<p>所以不妨直接让<span class="math inline">\(k = -
n^2\)</span>,然后看当<span class="math inline">\(DC &#39; = -
n^2\)</span>的时候如何去解.此时有<span class="math inline">\(AB ( A + B
) = n^2\)</span>.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择<span class="math inline">\(- 3^2 \times
4^2 \times 5^2\)</span>,这样就赢了.</p>
<ol start="3" type="1">
<li>Bob令<span class="math inline">\(AB + AC + BC = 0 , C = - \frac{ AB
}{ A + B }\)</span>.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择<span class="math inline">\(6^2 \times 7^3\)</span>,两种情况如下:</p>
<p><span class="math display">\[
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) &amp; = 0 \\
( x - 2 \times 6^2 \times 7^2 ) ( x + 3 \times 6^2 \times 7^2 ) ( x + 6
\times 6^2 \times 7^2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>后来又找人讨论了一下这个是咋得出来的啊.考虑<span class="math inline">\(ABC \ne 0\)</span>,我们有的条件其实是<span class="math inline">\(\frac{ 1 }{ A } + \frac{ 1 }{ B } + \frac{ 1 }{ C
} = 0\)</span>.方程现在是<span class="math inline">\(x^3 + ( A + B -
\frac{ AB }{ A + B } ) x^2 - \frac{ A^2 B^2 }{ A + B } =
0\)</span>.不妨令<span class="math inline">\(a = A + B , b =
AB\)</span>,方程实际上是<span class="math inline">\(x^3 + ( a - \frac{ b
}{ a } ) x^2 - \frac{ b^2 }{ a } = 0\)</span>.最好能让<span class="math inline">\(a\)</span>小一点,因此我们不妨直接取<span class="math inline">\(a = 1\)</span>,此时<span class="math inline">\(A =
- n , B = n + 1 , C = n ( n + 1 )\)</span>,只要能构造这样的两组<span class="math inline">\(A , B , C\)</span>使得它们的<span class="math inline">\(a_1 - \frac{ b_1 }{ a_1 } = - \frac{ b_2^2 }{ a_2
}\)</span>即可.直接造看上去没啥前途,但是不难发现<span class="math inline">\(A = - nk , B = ( n + 1 ) k , C = n ( n + 1 )
k\)</span>依然合法.此时有<span class="math inline">\(k_1 = a_1 , b_1 = -
n ( n + 1 ) a_1^2 , k_2 = a_2 , b_2 = - n ( n + 1 )
a_2^2\)</span>,我们有<span class="math inline">\(a_1 ( n^2 + n + 1 ) = -
n^2 ( n + 1 )^2 a_2^3\)</span>.取<span class="math inline">\(n =
2\)</span>试试看!此时有<span class="math inline">\(7 a_1 = - 36
a_2^3\)</span>.取<span class="math inline">\(a_2 = 7 , a_1 = - 6^2
\times 7^2\)</span>,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外<span class="math inline">\(3\)</span>个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌<span class="math inline">\(1\)</span>个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>有公式:</p>
<p><span class="math display">\[
\sum_{ S \subseteq \{ 1 , 2 , \cdots , n \} } ( P ( f ( R ) \oplus
\bigoplus_{ i \in S } R_i = 0 ) - P ( f ( R ) \oplus \bigoplus_{ i \in S
} R_i = 1 ) )^2 = 1
\]</span></p>
<p>其中<span class="math inline">\(f\)</span>是任意一个将<span class="math inline">\(\{ 0 , 1 \}^n \rightarrow \{ 0 , 1
\}\)</span>的函数,<span class="math inline">\(\oplus\)</span>是二进制意义下的异或运算,<span class="math inline">\(R\)</span>是<span class="math inline">\(\{ 0 , 1
\}^n\)</span>上的均匀分布,<span class="math inline">\(R_i\)</span>表示第<span class="math inline">\(i\)</span>位.再定义<span class="math inline">\(\chi_S ( r ) = \prod_{ i \in S } ( - 1 )^{ r_i
}\)</span>.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol type="1">
<li><p><span class="math inline">\(\chi_S ( r ) \times \chi_S ( r &#39;
) = \chi_S ( r \oplus r &#39; )\)</span>.</p></li>
<li><p>当<span class="math inline">\(r \ne 0\)</span>时,<span class="math inline">\(\sum_{ S \subseteq \{ 1 , \cdots , n \} } \chi_S (
r ) = 0\)</span>.</p></li>
<li><p><span class="math inline">\([ f ( r ) \oplus \bigoplus_{ i \in S
} r_i = 0 ] - [ f ( r ) \oplus \bigoplus_{ i \in S } r_i = 1 ] = ( - 1
)^{ f ( r ) } \chi_S ( r )\)</span>.</p></li>
<li><p>证明原命题.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>(1)显然.</p>
<p>(2)也很经典,挑选一个<span class="math inline">\(j\)</span>,使得<span class="math inline">\(r_j =
1\)</span>,然后所有的集合分为两类:一类是包含<span class="math inline">\(j\)</span>,一类不包含,两类集合一一对应并且<span class="math inline">\(\chi\)</span>互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到<span class="math inline">\(P ( f ( R ) \oplus
\bigoplus_{ i \in S } R_i = 0 ) = \frac{ 1 }{ 2^n } \sum_{ r } [ f ( r )
\oplus \bigoplus_{ i \in S } r_i = 0 ]\)</span>,而<span class="math inline">\(\sum_{ r } [ f ( r ) \oplus \bigoplus_{ i \in S }
r_i = 0 ] - [ f ( r ) \oplus \bigoplus_{ i \in S } r_i = 1 ] = \sum_r (
- 1 )^{ f ( r ) } \chi_S ( r )\)</span>,要证明的只是<span class="math inline">\(\sum_{ S } \frac{ 1 }{ 4^n } ( \sum_r ( - 1 )^{ f
( r ) } \chi_S ( r ) )^2 = 1\)</span>,而:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S } ( \sum_r ( - 1 )^{ f ( r ) } \chi_S ( r ) )^2 \\
= &amp; \sum_S \sum_{ r } \sum_{ r &#39; } ( - 1 )^{ f ( r ) + f ( r
&#39; ) } \chi_S ( r \oplus r &#39; ) \\
= &amp; \sum_{ r } \sum_{ r &#39; } ( - 1 )^{ f ( r ) + f ( r &#39; ) }
\sum_S \chi_S ( r \oplus r &#39; ) \\
= &amp; \sum_{ r } 2^n = 4^n
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于<span class="math inline">\(50 \%\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数<span class="math inline">\(x\)</span>,然后随机一只手,看上面的数字<span class="math inline">\(a\)</span>,如果<span class="math inline">\(a \geq
x\)</span>就认为<span class="math inline">\(a\)</span>大,反之认为<span class="math inline">\(b\)</span>大.只要随机到一个区间内的实数的概率不为<span class="math inline">\(0\)</span>即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5>
<p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令<span class="math inline">\(p\)</span>为素数,把整个图形放大<span class="math inline">\(p\)</span>倍(也就是长度<span class="math inline">\(1\)</span>变成长度<span class="math inline">\(p\)</span>).下面把每个交叉点<span class="math inline">\(( x , y )\)</span>换成其整数部分<span class="math inline">\(( \lfloor x \rfloor , \lfloor y \rfloor
)\)</span>,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被<span class="math inline">\(p\)</span>整除.这样这个新的大矩形的面积也能被<span class="math inline">\(p\)</span>整除,所以它的有一边长能被<span class="math inline">\(p\)</span>整除.这条边只是被换成了它长度的整数部分,所以变化不超过<span class="math inline">\(1\)</span>,所以在放大之前这条边的长度和某个整数相差不超过<span class="math inline">\(1 /
p\)</span>.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有<span class="math inline">\(2\)</span>条边或者<span class="math inline">\(4\)</span>条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点<span class="math inline">\(( x , y )\)</span>染色:如果<span class="math inline">\(x\)</span>是整数,染X颜色.如果<span class="math inline">\(x\)</span>不是整数但<span class="math inline">\(y\)</span>是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为<span class="math inline">\([ 0 , a ] \times [ 0
, b ]\)</span>,并假设<span class="math inline">\(b\)</span>不是整数.把所有小矩形的下边界去掉,然后令<span class="math inline">\(f ( t )\)</span>为所有上边界<span class="math inline">\(y\)</span>坐标不是整数,并且与直线<span class="math inline">\(y = t\)</span>相交的小矩形的<span class="math inline">\(x\)</span>方向边长之和.那么<span class="math inline">\(f ( 0 ) = 0\)</span>,而且当<span class="math inline">\(f ( t
)\)</span>变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以<span class="math inline">\(f ( b )\)</span>是整数.而因为<span class="math inline">\(b\)</span>不是整数,<span class="math inline">\(f (
b )\)</span>就是最靠上的所有小矩形的宽之和,等于<span class="math inline">\(a\)</span>,所以<span class="math inline">\(a\)</span>是整数.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2>
<h3><span id="分析状态">分析状态</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个<span class="math inline">\([ 1 , m ]\)</span>中的数字,然后进行以下判断:</p>
<ol type="1">
<li><p>如果当前序列末尾两个数字相同且小于<span class="math inline">\(t\)</span>,假设都是<span class="math inline">\(x\)</span>,那就将它们都删去,加入一个<span class="math inline">\(x + 1\)</span>.</p></li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为<span class="math inline">\(n\)</span>,终止操作.</p></li>
</ol>
<p>给定<span class="math inline">\(n , m ,
t\)</span>,求最终序列的元素和的期望.</p>
<p><span class="math inline">\(n , m \leq 10^3 , t \leq
10^9\)</span>.</p>
<p>首先<span class="math inline">\(t \leq
10^9\)</span>显然是没用的,因为它最多也就能这么凑:<span class="math inline">\(m + n - 2 , m + n - 3 , \cdots , m ,
m\)</span>,合成一个<span class="math inline">\(m + n -
1\)</span>,因此我们令<span class="math inline">\(t = \min \{ t , m + n -
1 \}\)</span>即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置<span class="math inline">\(i\)</span>,有<span class="math inline">\(a_i &lt;
a_{ i + 1 }\)</span>,那么无论后面怎么做,这里的<span class="math inline">\(a_i\)</span>都必不可能被删除.以此,我们不妨设<span class="math inline">\(f_{ i , j }\)</span>表示序列长度为<span class="math inline">\(i\)</span>,序列开头元素为<span class="math inline">\(j\)</span>的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过<span class="math inline">\(t\)</span>,另一个是序列的长度不能超过<span class="math inline">\(n\)</span>.我们不妨设<span class="math inline">\(ans_{ n , t
}\)</span>表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移<span class="math inline">\(ans\)</span>需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下<span class="math inline">\(ans_{ n , t
}\)</span>,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有<span class="math inline">\(ans_{ n , t } = \sum_{ x = 1 }^t E ( n 个 位 置 ,
第 一 个 位 置 是 x 并 且 没 有 被 删 去 )\)</span>.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:<span class="math inline">\(3 , 3 ,
3\)</span>,最终的答案应该是<span class="math inline">\(4 ,
3\)</span>.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了<span class="math inline">\(3 , [ 3 , 3 ]\)</span>,最终的答案就变成了<span class="math inline">\(3 ,
4\)</span>.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设<span class="math inline">\(g_{ i , j }\)</span>表示当前后面还有<span class="math inline">\(i - 1\)</span>个位置,当前前面已经放好了一个<span class="math inline">\(j\)</span>,这个<span class="math inline">\(j\)</span>不能被删掉的期望,显然有<span class="math inline">\(ans_{ n , t } = \sum_{ x }^t g_{ n , x } P ( 最 终
序 列 中 , 这 里 是 k )\)</span>,问题只在于如何求<span class="math inline">\(g\)</span>.这个<span class="math inline">\(g_{ n ,
k }\)</span>是钦定了这个位置放<span class="math inline">\(k\)</span>的期望,后面我们需要将它乘上这个位置放<span class="math inline">\(k\)</span>的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个<span class="math inline">\(g_{ n , k } = ( k +
\sum_{ j \ne k } g_{ n - 1 , j }
)\)</span>.但是实际上这个是不对的.这里的<span class="math inline">\(k\)</span>不能删掉不意味着后面的<span class="math inline">\(j\)</span>不能删掉,事实上后面的<span class="math inline">\(j\)</span>爱怎么删怎么删,只要不搞出一个<span class="math inline">\(k\)</span>来就可以.因此我们需要设<span class="math inline">\(f_{ i , j }\)</span>表示当前后面还有<span class="math inline">\(i\)</span>个位置,第一个位置不能是<span class="math inline">\(j\)</span>,也不能曾经是<span class="math inline">\(j\)</span>(因为这里只要是<span class="math inline">\(j\)</span>都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设<span class="math inline">\(f_{ i , j }\)</span>表示后面还有<span class="math inline">\(i\)</span>个位置,第一个位置现在或曾经是过<span class="math inline">\(j\)</span>的期望.那么全集是什么呢?全集是<span class="math inline">\(ans_i\)</span>.</p>
<p>还没完啊,我们还需要求一下这里是<span class="math inline">\(k\)</span>的概率,由于还有一个类似的<span class="math inline">\(f\)</span>,我们还要求一下这里曾经是<span class="math inline">\(k\)</span>的概率.设前者为<span class="math inline">\(q_{ i , k }\)</span>,后者为<span class="math inline">\(p_{ i , k
}\)</span>.我们来强调一下这里设计的原则:这里的<span class="math inline">\(p\)</span>其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了<span class="math inline">\(k\)</span>,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过<span class="math inline">\(k\)</span>了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是<span class="math inline">\(k\)</span>等价于这里是<span class="math inline">\(k\)</span>并且后面没有出现过<span class="math inline">\(k\)</span>,也就是<span class="math inline">\(q_{ i
, k } = p_{ i , k } ( 1 - p_{ i - 1 , k } \times [ k &lt; t ]
)\)</span>.这里加一个限制是因为有不能超过<span class="math inline">\(t\)</span>的限制.</p>
<p>对于后者,这里的<span class="math inline">\(k\)</span>有很多种可能出现过,一种是直接加入,一种是合并而来,于是<span class="math inline">\(p_{ i , k } = \frac{ 1 }{ m } [ k \leq m ] + p_{ i
, k - 1 } p_{ i - 1 , k - 1 }\)</span>.</p>
<p>因此我们几经辗转,终于得到了<span class="math inline">\(g\)</span>的转移式子:</p>
<p><span class="math display">\[
q_{ i , k } g_{ n , k } = p_{ i , k } ( k + ans_{ i - 1 } - f_{ i - 1 ,
k } p_{ i - 1 , k } )
\]</span></p>
<p>就差<span class="math inline">\(f\)</span>了.<span class="math inline">\(f\)</span>有两种可能:要么最后仍然是<span class="math inline">\(k\)</span>,要么这个<span class="math inline">\(k\)</span>已经被杀掉了.于是:</p>
<p><span class="math display">\[
p_{ i , k } f_{ i , k } = q_{ i , k } g_{ i , k } + ( p_{ i , k } - q_{
i , k } ) f_{ i , k + 1 }
\]</span></p>
<h5><span id="example2cf1007e">Example2(CF1007E)</span></h5>
<p>首先我们需要发现一个很强的性质:作用到了第<span class="math inline">\(i\)</span>个站台就会清空前面所有站台.清空后就和<span class="math inline">\(a_i\)</span>无关了,而如果还没涉及到一定和<span class="math inline">\(a_i\)</span>有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设<span class="math inline">\(f_{
i , j }\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间需要的最少火车数量.<span class="math inline">\(g_{ i , j }\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间,并且<span class="math inline">\([ 1 , i - 1
]\)</span>全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为<span class="math inline">\(+ \infty\)</span>表示无法满足(对于全局,我们在<span class="math inline">\(n + 1\)</span>处放一个<span class="math inline">\(a = + \infty , b = 0 , c = +
\infty\)</span>来保证一定会满载).为什么需要<span class="math inline">\(g\)</span>作为辅助dp数组呢?我们先对着<span class="math inline">\(f\)</span>分析.</p>
<p>考虑<span class="math inline">\(f_{ i , j
}\)</span>的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前<span class="math inline">\(j\)</span>轮中根本没接走站台<span class="math inline">\(i\)</span>的人.此时需要满足<span class="math inline">\(f_{ i - 1 , j } \ne + \infty \land a_i + j \times
b_i \leq c_i\)</span>.那么这里怎么更新<span class="math inline">\(g\)</span>呢?设<span class="math inline">\(L =
sa_{ i - 1 } + sb_{ i - 1 } \times j\)</span>,显然<span class="math inline">\(g_{ i , j } = \lceil \frac{ L }{ K }
\rceil\)</span>,并且需要保证此时没有用到<span class="math inline">\(i\)</span>以后的站台,因此需要保证<span class="math inline">\(\lceil \frac{ L }{ K } \rceil K \leq sa_{ i } +
sb_i \times j\)</span>.注意到由于这里保证了<span class="math inline">\(f_{ i - 1 , j
}\)</span>是可以取到的,因此我们可以撑到第<span class="math inline">\(j\)</span>秒,剩下的火车在<span class="math inline">\(j + \varepsilon\)</span>秒全选.</p>
<p>第二种,前<span class="math inline">\(j\)</span>轮中有火车接走站台<span class="math inline">\(i\)</span>的人.设最后一次是在<span class="math inline">\(r\)</span>时间接走的站台<span class="math inline">\(i\)</span>,那么此时必然清空了<span class="math inline">\([ 1 , i - 1 ]\)</span>,这里用了<span class="math inline">\(g_{ i , r }\)</span>.然后为了防止这里在<span class="math inline">\([ r + 1 , j
]\)</span>这段时间中爆掉,因此还需要<span class="math inline">\(w =
\lceil \frac{ \max \{ 0 , rem + ( j - r ) b_i - c_i \} }{ K }
\rceil\)</span>,其中<span class="math inline">\(rem\)</span>是<span class="math inline">\(r\)</span>时刻<span class="math inline">\(i\)</span>剩下的人数.这些火车都要在<span class="math inline">\(r\)</span>时刻之前解决(因为我们设了最后一次在<span class="math inline">\(r\)</span>时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在<span class="math inline">\(r\)</span>这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有<span class="math inline">\(wK \leq rem\)</span>.但是,接下来在<span class="math inline">\([ r + 1 , j
]\)</span>时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设<span class="math inline">\(f_{ i , j , 0 }\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间需要的最少火车数量,但是<span class="math inline">\([ 1 , i ]\)</span>都被清空为<span class="math inline">\(0\)</span>过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol type="1">
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p></li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将<span class="math inline">\(g_{ 1 , t , 0 / 1 }\)</span>全部设为<span class="math inline">\(0\)</span>,因为我觉得无论如何<span class="math inline">\(0\)</span>位置都是清空的,但实际上这是错误的!因为在<span class="math inline">\(t\)</span>时刻的<span class="math inline">\(1\)</span>位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前<span class="math inline">\(i\)</span>个的合法性,并且如果我们想要让<span class="math inline">\(i\)</span>位置合法,一定要求让<span class="math inline">\([ 1 , i - 1 ]\)</span>合法.</p></li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从<span class="math inline">\(r \rightarrow
t\)</span>这个过程中会积累的量,这些量必然要在<span class="math inline">\(r\)</span>时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p></li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>定义一个有根树为大菊花,当且仅当这棵树的根的度数<span class="math inline">\(\leq m \land \nexists x \ne root , \deg ( x ) &gt;
2\)</span>.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.<span class="math inline">\(( n \leq 5 \times 10^5 , m \leq 50 )\)</span></p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到<span class="math inline">\(O ( nm^2 )\)</span>.</p>
<p>注意到这个背包是可删除的,所以就能做到<span class="math inline">\(O (
nm )\)</span>.</p>
<h3><span id="dp分界点">dp分界点</span></h3>
<h4><span id="example12022zrtg十连测day7permutation">Example1(2022zrtg十连测day7
Permutation)</span></h4>
<p>首先注意到<span class="math inline">\([ 3 , n
]\)</span>一定会被分成两段递减的序列,分别跟在<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的后面,假设<span class="math inline">\(1\)</span>在<span class="math inline">\(2\)</span>前面,这样算出答案后乘以<span class="math inline">\(n\)</span>即可.</p>
<p>注意到<span class="math inline">\(i + 1\)</span>一定可以放到<span class="math inline">\(i\)</span>的前面,设<span class="math inline">\(f_i\)</span>表示在<span class="math inline">\(i\)</span>和<span class="math inline">\(i +
1\)</span>之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即<span class="math inline">\(i\)</span>的倍数<span class="math inline">\(\pm
1\)</span>之类的,于是可以实现,复杂度<span class="math inline">\(O ( n
\ln n )\)</span>.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3>
<h4><span id="example1cf1666e">Example1(CF1666E)</span></h4>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 } &amp; = \max \{ a_{ i + 1 } , f_i + mn \} \\
g_{ i + 1 } &amp; = \min \{ a_{ i + 2 } , g_i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([ f_i , g_i
]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{ i
}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ ans_{ i + 1 } - mx , ans_{ i + 1 } - mn
]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([ f_i , g_i
]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{ i + 1 } - mn &lt; f_i , f_{ i + 1 } &lt;
ans_{ i + 1 } &lt; f_i +
mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx - mn\)</span>.</p>
<h3><span id="数位dp">数位dp</span></h3>
<h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4>
<p>首先设<span class="math inline">\(f_{ i , j }\)</span>表示长度为<span class="math inline">\(i\)</span>的,以<span class="math inline">\(S [ n -
j + 1 . . . n ]\)</span>为子序列的字符串个数.</p>
<p>考虑按位处理,每次将<span class="math inline">\(T\)</span>的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出<span class="math inline">\(k\)</span>.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为<span class="math inline">\(k\)</span>.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4>
<p>第一反应就是枚举<span class="math inline">\(x &#39;\)</span>和<span class="math inline">\(y &#39;\)</span>,然后用数位dp枚举<span class="math inline">\(d\)</span>使得<span class="math inline">\(x = dx
&#39; , y = dy &#39;\)</span>.</p>
<p>但是有一个问题在于如果<span class="math inline">\(\gcd ( x &#39; , y
&#39; ) \ne 1\)</span>怎么办,这样有可能会算重.我们发现我们只判断<span class="math inline">\(\gcd ( x &#39; , y &#39; ) =
1\)</span>的情况就行,然后写一个<span class="math inline">\(2^8\)</span>判断<span class="math inline">\(x
&#39; , 2 x &#39; , 3 x &#39; , 4 x &#39;\)</span>以及对应的<span class="math inline">\(y &#39;\)</span>出现了没有.复杂度<span class="math inline">\(( 9^4 \times 2^8 \times \log_{ 10 } n
)\)</span>,有点难过.</p>
<p>但是我们发现这个<span class="math inline">\(2^8\)</span>可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有<span class="math inline">\(3^4 \times 2\)</span>的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3>
<h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4>
<p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是<span class="math inline">\(O ( nd^2
)\)</span>的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是<span class="math inline">\(O ( nd )\)</span>的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取<span class="math inline">\(\min\)</span>转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>现在有一个<span class="math inline">\([ 1 , n
]\)</span>的排列,现在要从中选出一个集合<span class="math inline">\(S\)</span>,满足<span class="math inline">\(\forall
x \in S , 2 x \notin S , 3 x \notin S\)</span>,求方案数.</p>
<p>首先考虑将每个数分解为<span class="math inline">\(a \times 2^b \times
3^c\)</span>的形式,显然<span class="math inline">\(a\)</span>不相同的数之间互不干扰.</p>
<p>对于<span class="math inline">\(a\)</span>相同的一群数,我们考虑将<span class="math inline">\(( b , c
)\)</span>作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3>
<h4><span id="example1">Example1</span></h4>
<p><span class="math inline">\(n\)</span>个点的树,一开始位于一号点,每个点有一个颜色(<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>),每次随机选择一个点<span class="math inline">\(v\)</span>,从当前所在点移动到<span class="math inline">\(v\)</span>并将<span class="math inline">\(v\)</span>的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为<span class="math inline">\(1\)</span>,当然不为<span class="math inline">\(1\)</span>也能做).</p>
<p><span class="math inline">\(n \leq 100000\)</span>.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>就可以.不妨设<span class="math inline">\(f_{ i }\)</span>表示当前有<span class="math inline">\(i\)</span>个点是<span class="math inline">\(1\)</span>,最后全<span class="math inline">\(1\)</span>或者全<span class="math inline">\(0\)</span>所需要的期望步数,显然<span class="math inline">\(f_0 = f_n = 0\)</span>,<span class="math inline">\(f_{ i } = \frac{ 1 }{ 2 } ( f_{ i + 1 } + f_{ i -
1 } ) + 1\)</span>.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在<span class="math inline">\(u\)</span>,只要当前没有结束,我们还要选点<span class="math inline">\(v\)</span>,对答案的期望的贡献就是<span class="math inline">\(u\)</span>到这棵树上所有点的距离之和除以<span class="math inline">\(n\)</span>,而这是一个定值.也就是说,只要我们统计一下到了每个点<span class="math inline">\(u\)</span>多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设<span class="math inline">\(f_{ i , j , 0 / 1
}\)</span>表示当前场面上有<span class="math inline">\(i\)</span>个<span class="math inline">\(1\)</span>,<span class="math inline">\(j\)</span>号点这里是<span class="math inline">\(0\)</span>还是<span class="math inline">\(1\)</span>,它在结束前能被期望选多少次,注意<span class="math inline">\(f_{ n / 0 , j , 0 / 1 } =
0\)</span>.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设<span class="math inline">\(f_{ i , 0 / 1 }\)</span>表示当前有<span class="math inline">\(i\)</span>个<span class="math inline">\(1\)</span>,<span class="math inline">\(0 /
1\)</span>染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ 0 / n , 0 / 1 } &amp; = 0 \\
f_{ i , 0 } &amp; = \frac{ i }{ n } f_{ i - 1 , 0 } + \frac{ n - i - 1
}{ n } f_{ i + 1 , 0 } + \frac{ 1 }{ n } ( f_{ i + 1 , 1 } + [ i + 1 \ne
n ] ) \\
f_{ i , 1 } &amp; = \frac{ i - 1 }{ n } f_{ i - 1 , 1 } + \frac{ n - i
}{ n } f_{ i + 1 , 1 } + \frac{ 1 }{ n } ( f_{ i - 1 , 0 } + [ i - 1 \ne
0 ] )
\end{aligned}
\]</span></p>
<p>为啥最后加上了<span class="math inline">\([ i + 1 \ne n
]\)</span>呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了<span class="math inline">\(f_{ i , 0 / 1
}\)</span>和<span class="math inline">\(f_{ i - 1 , 0 / 1
}\)</span>,我们发现我们可以用这两个方程求出<span class="math inline">\(f_{ i + 1 , 0 / 1
}\)</span>,然后就比较典了:我们将所有的函数表示成<span class="math inline">\(af_{ 1 , 0 } + bf_{ 1 , 1 } +
c\)</span>的形式(之所以这么表示,是因为我们架设了<span class="math inline">\(f_{ 1 , 0 / 1
}\)</span>已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出<span class="math inline">\(f_{ n , 0 / 1 }\)</span>,而<span class="math inline">\(f_{ n , 0 / 1
}\)</span>我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3>
<h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4>
<p>首先注意到,<span class="math inline">\(a_i = 1\)</span>的时候和<span class="math inline">\(a_i \ne
1\)</span>的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设<span class="math inline">\(f_i\)</span>为<span class="math inline">\(a_i =
1\)</span>,而其他<span class="math inline">\(a\)</span>全都为<span class="math inline">\(0\)</span>时的答案,不难发现最后的答案也就是<span class="math inline">\(\sum{ a_i f_i }\)</span>.</p>
<p>而上面的转移自然是:<span class="math inline">\(f_i = \min \{ b_i , w
+ \sum_{ j = l }^r f_j \}\)</span>.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次<span class="math inline">\(f_i\)</span>最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查<span class="math inline">\(\log n\)</span>次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5>
<p>考虑组合意义,<span class="math inline">\(\sum
a_i^2\)</span>的意义也即满足操作序列<span class="math inline">\(u\)</span>和操作序列<span class="math inline">\(v\)</span>的最终结果相同的二元组<span class="math inline">\(( u , v )\)</span>的数量.</p>
<p>不妨设<span class="math inline">\(dp_{ i , j , k
}\)</span>为第一个装置上方已经动了<span class="math inline">\(i\)</span>个珠子,下放动了<span class="math inline">\(j\)</span>个珠子,第二个装置上方动了<span class="math inline">\(k\)</span>个珠子,下方动了<span class="math inline">\(i + j -
k\)</span>个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然<span class="math inline">\(dp_{ n , m , n }\)</span>即答案.</p>
<h5><span id="example2">Example2</span></h5>
<p>求长度为<span class="math inline">\(n\)</span>的排列的<span class="math inline">\(( \sum_{ i = 2 }^{ n - 1 } [ a_i &lt; a_{ i - 1 }
\And a_i &lt; a_{ i + 1 } ] )^k\)</span>的期望<span class="math inline">\(( n \leq 10^9 , k \leq 500 )\)</span>.</p>
<p><span class="math inline">\(O ( n^2 k^2
)\)</span>是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是<span class="math inline">\(\sum
ans^k\)</span>,而加入<span class="math inline">\(1\)</span>的时候,对于每个长度为<span class="math inline">\(n - 1\)</span>的排列,有<span class="math inline">\(( n - 2 - 2 ans
)\)</span>个位置加入后会使答案加一,那我们要求的也就是:</p>
<p><span class="math display">\[
\sum ( n - 1 - 2 ans ) ( ans + 1 )^k + \sum ( 2 ans + 2 ) ans^k
\]</span></p>
<p>推一推式子就可以做到<span class="math inline">\(O ( nk^2
)\)</span>,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,<span class="math inline">\(ans^k\)</span>等价于从所有的地方中可重复地选出<span class="math inline">\(k\)</span>个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为<span class="math inline">\(1\)</span>的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设<span class="math inline">\(f_{ i , j }\)</span>表示已经选了<span class="math inline">\(i\)</span>段波动序列,其中有<span class="math inline">\(j\)</span>个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度<span class="math inline">\(O ( k^3 )\)</span>.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \sum_{ j = 1 }^n ( a_i
\oplus a_j )^2\)</span>,<span class="math inline">\(n \leq
10^5\)</span>,<span class="math inline">\(a_i \leq 10^9\)</span>.</p>
<p>考虑设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>低的位置,高位全部默认为<span class="math inline">\(0\)</span>的方案数.如果我们设<span class="math inline">\(cnt_i\)</span>表示<span class="math inline">\(a\)</span>中第<span class="math inline">\(i\)</span>位为<span class="math inline">\(1\)</span>的数个数,那根据<span class="math inline">\(( a + b )^2 = a^2 + 2 ab +
b^2\)</span>,我们只需要求出<span class="math inline">\(g_{ i
}\)</span>表示只考虑前<span class="math inline">\(i\)</span>低的位置,第<span class="math inline">\(i
+ 1\)</span>位是<span class="math inline">\(1\)</span>的数和第<span class="math inline">\(i + 1\)</span>位是<span class="math inline">\(0\)</span>的数两两异或之和,显然有<span class="math inline">\(f_i = f_{ i - 1 } + 2 cnt_i \times 2^i \times g_{
i - 1 } + cnt_i 2^{ i + 1 }\)</span>.</p>
<p><span class="math inline">\(g\)</span>可以用<span class="math inline">\(O ( n \log a
)\)</span>的复杂度求,这样总复杂度<span class="math inline">\(O ( n
\log^2 a )\)</span>.</p>
<h3><span id="线头dp">线头dp</span></h3>
<h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5>
<p>令<span class="math inline">\(dp_{ i , j , k
}\)</span>表示目前倒到第<span class="math inline">\(i\)</span>个水杯,前面还有<span class="math inline">\(j\)</span>个延续过来的未结束的线头,目前已经选定了<span class="math inline">\(k\)</span>个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是<span class="math inline">\(O ( n^5
)\)</span>的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了<span class="math inline">\(O ( n^4 )\)</span>的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5>
<p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设<span class="math inline">\(dp_{ i , 0 / 1 / 2 }\)</span>表示前<span class="math inline">\(i\)</span>个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212svjetlo">Example3([COCI2020-2021#2]
Svjetlo)</span></h5>
<p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设<span class="math inline">\(dp_{ u , 0 / 1 , 1 / 2
}\)</span>为<span class="math inline">\(u\)</span>的状态为<span class="math inline">\(0 / 1\)</span>,以<span class="math inline">\(u\)</span>为根的子树内有<span class="math inline">\(1 / 2\)</span>个线头的方案数.注意如果子树内有<span class="math inline">\(0 / 2\)</span>个线头,那么会在<span class="math inline">\(u\)</span>处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此<span class="math inline">\(dp_{ u , s , 2
}\)</span>的两个接头实际上一个位于<span class="math inline">\(u\)</span>,另一个位于<span class="math inline">\(u\)</span>的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5>
<p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设<span class="math inline">\(dp_{ i , j , k
}\)</span>表示目前走到<span class="math inline">\(i\)</span>,前面分成<span class="math inline">\(j\)</span>组,总贡献不超过<span class="math inline">\(k\)</span>的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489-jtravel-in-sugar-country">Example5([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489) J]Travel in Sugar Country)</span></h5>
<p>一条线段上有<span class="math inline">\(n ( \leq 100
)\)</span>个商店,要从中选出<span class="math inline">\(k ( \leq 10
)\)</span>个不同的商店<span class="math inline">\(s_1 , s_2 , \cdots ,
s_k\)</span>,使得按顺序遍历这<span class="math inline">\(k\)</span>个商店的路径长度是<span class="math inline">\(m ( \leq 30 )\)</span>的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设<span class="math inline">\(dp_{ i , j , w , l
}\)</span>表示目前在判断了<span class="math inline">\(i\)</span>个商店,选了<span class="math inline">\(j\)</span>个,并且目前整个图有<span class="math inline">\(w\)</span>条”路径”(连续走动),走过的路在<span class="math inline">\(\bmod m\)</span>一意义下为<span class="math inline">\(l\)</span>的方案数.最后的答案就是<span class="math inline">\(dp_{ n , k , 1 , 0 }\)</span>.</p>
<p>首先,我们对每个点求出<span class="math inline">\(D ( 1 , x
)\)</span>,然后<span class="math inline">\(D ( x , y ) = | D ( 1 , y ) -
D ( 1 , x ) |\)</span>,不难发现<span class="math inline">\(x\)</span>越大<span class="math inline">\(D ( 1 ,
x
)\)</span>越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的<span class="math inline">\(D\)</span>和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径(<span class="math inline">\(s_1 \rightarrow
s_1\)</span>),接下来,我们每插入一个点<span class="math inline">\(x\)</span>,我们考虑它的贡献:</p>
<ol type="1">
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是<span class="math inline">\(- 2 D ( 1 , x )\)</span>,对方案数的贡献为<span class="math inline">\(1\)</span>.</p></li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为<span class="math inline">\(0\)</span>.</p></li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为<span class="math inline">\(2 D ( 1 , x )\)</span>.</p></li>
</ol>
<p>这样我们就做到了<span class="math inline">\(O ( n^4 km
)\)</span>的复杂度.如果我们加两维<span class="math inline">\(0 /
1\)</span>表示目前起点和终点是否加入,就可以把复杂度优化到<span class="math inline">\(O ( n^2 km )\)</span>.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3>
<p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4>
<p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3>
<p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4>
<p>先考虑数字两两不同的时候怎么做,我们先找到<span class="math inline">\(A\)</span>中的全局最大值所在位置和<span class="math inline">\(B\)</span>中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时<span class="math inline">\(A\)</span>取出的数量和<span class="math inline">\(B\)</span>的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把<span class="math inline">\(B\)</span>序列分成两部分,这两部分将由<span class="math inline">\(A\)</span>中相等的两部分分别生成.不妨假设这个全局最大值的位置是<span class="math inline">\(x\)</span>,那么对于<span class="math inline">\([ 1
, x ]\)</span>这一段的<span class="math inline">\(A\)</span>生成的<span class="math inline">\(B\)</span>数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的<span class="math inline">\(A\)</span>能生成的<span class="math inline">\(B\)</span>的数量.对于<span class="math inline">\([
1 , x + 1 ]\)</span>则任意.</p>
<p>那么我们所需要做的就是求出<span class="math inline">\(A\)</span>的某一段删掉若干次最大值后的序列所能生成的<span class="math inline">\(B\)</span>的数量.不妨设<span class="math inline">\(dp_{ l , r , i }\)</span>表示<span class="math inline">\([ l , r ]\)</span>中所有<span class="math inline">\(\leq i\)</span>的数字组成的序列所能生成的数量.</p>
<p>如果<span class="math inline">\([ l , r
]\)</span>这段区间中没有数字<span class="math inline">\(i\)</span>,那显然<span class="math inline">\(dp_{
l , r , i } = dp_{ l , r , i - 1
}\)</span>,不然,我们可以枚举两端分开的位置,那这个位置一定在数字<span class="math inline">\(i\)</span>的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4>
<p>注意到第<span class="math inline">\(n\)</span>个元素一定是山峰.所以我们考虑用第<span class="math inline">\(n\)</span>个元素分割整个区间为两部分.</p>
<p>设<span class="math inline">\(f_n\)</span>为<span class="math inline">\(n\)</span>个元素且开头为山谷的答案.枚举第<span class="math inline">\(n\)</span>个元素在位置<span class="math inline">\(k\)</span>(<span class="math inline">\(k -
1\)</span>是奇数),则<span class="math inline">\(f_k f_{ n - 1 - k }
\binom{ n - 1 }{ k } \rightarrow f_n\)</span>.</p>
<h4><span id="example3">Example3</span></h4>
<p>给定数组<span class="math inline">\(a\)</span>,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.<span class="math inline">\(n \leq 500\)</span>.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设<span class="math inline">\(f_{ l , r }\)</span>为将<span class="math inline">\([ l , r ]\)</span>删干净后再去删<span class="math inline">\(a_{ l - 1 } , a_{ r + 1
}\)</span>的方案数,然后枚举<span class="math inline">\([ l , r
]\)</span>中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairingpoints">Example4([AGC039E] Pairing
Points)</span></h4>
<p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从<span class="math inline">\(1\)</span>号点这里断开,枚举<span class="math inline">\(1\)</span>号点连接哪个点,然后就可以让<span class="math inline">\(( 2 , 2 n )\)</span>这些点断开了.我们设计<span class="math inline">\(f_{ i , j , k }\)</span>或<span class="math inline">\([ i , j ] ( k )\)</span>表示区间<span class="math inline">\([ i , j ]\)</span>中的<span class="math inline">\(k\)</span>向外连了一条边.答案是枚举<span class="math inline">\(1\)</span>号点连了哪个点,也就是<span class="math inline">\(\sum_{ i = 3 }^{ 2 n - 1 } f_{ 2 , 2 n , i
}\)</span>.</p>
<p>于是我们现在的问题在于如何求<span class="math inline">\(f_{ i , j , k
}\)</span>.由于边要联通,所以与<span class="math inline">\(k\)</span>相连的这条边必然被<span class="math inline">\([ i , j
]\)</span>中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为<span class="math inline">\(x \leftrightarrow
y\)</span>.这样整个区间被分为了两个部分:<span class="math inline">\([ i
, k ] ( x ) , [ k , j ] ( y )\)</span>.但是问题并没有得到解决.因为<span class="math inline">\([ i , x ]\)</span>和<span class="math inline">\([
y , j ]\)</span>之间的确不可能出现连边了,但<span class="math inline">\([
x , k ]\)</span>和<span class="math inline">\([ k , y
]\)</span>之间仍然可能出现连边.但我们发现:在<span class="math inline">\([ i , k
]\)</span>中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为<span class="math inline">\(p
, q\)</span>.现在整个区间被分为了三个部分:<span class="math inline">\([
i , p ] ( x ) , [ p , q ] ( k ) , [ q , j ] ( y
)\)</span>,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-andremove">Example5([AGC035D] Add and
Remove)</span></h4>
<p>首先自然想到区间dp.但是难以处理的是如果一个区间<span class="math inline">\([ l , r ]\)</span>中间删掉一个点<span class="math inline">\(p\)</span>之后,<span class="math inline">\([ l , p
- 1 ]\)</span>和<span class="math inline">\([ p + 1 , r
]\)</span>会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到<span class="math inline">\([ l + 1 , r - 1
]\)</span>中最后删除的点<span class="math inline">\(p\)</span>,这样区间<span class="math inline">\([ l
, r
]\)</span>的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除<span class="math inline">\([ l + 1 , p - 1 ]\)</span>的时候,对<span class="math inline">\(p\)</span>产生的贡献和删除<span class="math inline">\([ p + 1 , r - 1 ]\)</span>的时候对<span class="math inline">\(p\)</span>的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设<span class="math inline">\(a_l\)</span>贡献了<span class="math inline">\(x\)</span>倍,<span class="math inline">\(a_r\)</span>贡献了<span class="math inline">\(y\)</span>倍,那么由于<span class="math inline">\(a_p\)</span>会两边都贡献到,所以<span class="math inline">\(a_p\)</span>会对答案贡献<span class="math inline">\(x + y\)</span>倍.</p>
<p>于是设计一个dp是:<span class="math inline">\(f_{ l , r , x , y
}\)</span>表示删除<span class="math inline">\([ l + 1 , r - 1
]\)</span>后,<span class="math inline">\(xa_l +
ya_r\)</span>最小是多少.自然有<span class="math inline">\(f_{ l , r , x
, y } = \min \{ f_{ l , p , x , x + y } + f_{ p , r , x + y , y } + ( x
+ y ) a_p \}\)</span>.</p>
<p>至于复杂度,前两维肯定是<span class="math inline">\(n^2\)</span>的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移<span class="math inline">\(n\)</span>层,因此是<span class="math inline">\(2^n\)</span>的空间,于是时间复杂度不会超过<span class="math inline">\(O ( n^3 2^n
)\)</span>,其实经过一些奇怪计算应该是不会超过<span class="math inline">\(O ( 2^n )\)</span>的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4>
<p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设<span class="math inline">\(f_{ l , r
}\)</span>表示删除<span class="math inline">\([ l , r
]\)</span>区间的代价.接下来我们无非要枚举<span class="math inline">\(k\)</span>,使得<span class="math inline">\(k\)</span>是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如<span class="math inline">\(l\)</span>,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果<span class="math inline">\(a_l = a_k\)</span>,那么这等价于<span class="math inline">\(f_{ l + 1 , k - 1 } + [ l = k - 1 ] + f_{ k + 1 ,
r }\)</span>.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4>
<p>首先考虑一下<span class="math inline">\(m = 2^k -
1\)</span>的情况,首先我们要判断有几个数最高位是<span class="math inline">\(1\)</span>,然后接下来判断第二位哪些数字是<span class="math inline">\(1\)</span>.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是<span class="math inline">\(1\)</span>的就一定大于最高位是<span class="math inline">\(0\)</span>的了,这两个区间就没有影响了.因此可以设<span class="math inline">\(f_{ l , r , k }\)</span>表示<span class="math inline">\([ l , r ]\)</span>这个区间,前面已经有了<span class="math inline">\(k\)</span>个<span class="math inline">\(1\)</span>的最大贡献.</p>
<p>那么对于<span class="math inline">\(m \ne 2^k -
1\)</span>的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过<span class="math inline">\(m\)</span>就行了.</p>
<h3><span id="相互独立">相互独立</span></h3>
<h5><span id="example12019zrtg十连测day1origami">Example1(2019zrtg十连测day1
origami)</span></h5>
<p>看上去很不好做,先考虑宽为<span class="math inline">\(1\)</span>怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间<span class="math inline">\([ l , r ]\)</span>,然后看<span class="math inline">\([ 1 , l - 1 ]\)</span>和<span class="math inline">\([ r + 1 , m
]\)</span>能不能折进来.也就是判断以<span class="math inline">\(r\)</span>和<span class="math inline">\(r +
1\)</span>为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设<span class="math inline">\(f_i\)</span>表示能不能折成以<span class="math inline">\([ 1 , i ]\)</span>为最下层,<span class="math inline">\(g_i\)</span>表示能不能折成<span class="math inline">\([ i , n ]\)</span>为最下层,那<span class="math inline">\([ l , r ]\)</span>能折出来当且仅当<span class="math inline">\(f_r = g_l =
1\)</span>,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-anedge">Example2(CF1616G Just Add an
Edge)</span></h5>
<p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如<span class="math inline">\(1 \rightarrow x
\cup y \rightarrow n\)</span>,并且<span class="math inline">\(1
\rightarrow x\)</span>和<span class="math inline">\(y \rightarrow
n\)</span>不交,然后添加边<span class="math inline">\(x \rightarrow
y\)</span>.</p>
<p>那么什么时候<span class="math inline">\(1 \rightarrow
x\)</span>和<span class="math inline">\(y \rightarrow
n\)</span>没有交并且他们的并是<span class="math inline">\([ 1 , n
]\)</span>呢?考虑将<span class="math inline">\(1 \rightarrow
x\)</span>这条路径上的点染色为<span class="math inline">\(0\)</span>,<span class="math inline">\(y
\rightarrow n\)</span>上的点染色为<span class="math inline">\(1\)</span>,由于边只有从前往后的,因此<span class="math inline">\([ 1 , y - 1 ]\)</span>必然为<span class="math inline">\(0\)</span>,<span class="math inline">\([ x + 1 , n
]\)</span>必然为<span class="math inline">\(1\)</span>.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了<span class="math inline">\(y\)</span>,现在想要找到<span class="math inline">\(x\)</span>,我们现在假设染色的末尾是<span class="math inline">\(( i , i + 1 )\)</span>,也就是<span class="math inline">\(i\)</span>染色和<span class="math inline">\(i +
1\)</span>的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个<span class="math inline">\(p\)</span>,满足<span class="math inline">\(p
\nrightarrow p + 1\)</span>,那么<span class="math inline">\(p\)</span>和<span class="math inline">\(p +
1\)</span>永远不可能染同种颜色,我们直接以它为断点,自然发现<span class="math inline">\(p\)</span>的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了<span class="math inline">\(p \rightarrow p +
1\)</span>这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立<span class="math inline">\(0\)</span>和<span class="math inline">\(n +
1\)</span>两个虚点,向所有点连边.</p>
<p>总之<span class="math inline">\(O ( nm
)\)</span>的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3>
<p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5>
<p>首先考虑已知一个序列,如何快速求它最后有几个位置不是<span class="math inline">\(0\)</span>.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其<span class="math inline">\(- 1\)</span>并重复判断操作,直到为<span class="math inline">\(0\)</span>或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是<span class="math inline">\(0\)</span>相当于判断后面的已知序列的<span class="math inline">\(mex\)</span>,这个要记入状态中,于是考虑设<span class="math inline">\(dp_{ i , j }\)</span>表示当前到了第<span class="math inline">\(i\)</span>个位置,后面的数的<span class="math inline">\(mex - 1\)</span>是<span class="math inline">\(j\)</span>的方案数.</p>
<p>但是如果直接这么设会发现,当前<span class="math inline">\(i\)</span>的加入有可能会改变<span class="math inline">\(mex\)</span>的值,而这个改变是很难处理的,因为如果<span class="math inline">\(i\)</span>位置选择了<span class="math inline">\(j
+ 1\)</span>这个数字,那么<span class="math inline">\(mex\)</span>要向上伸展到某一个值,而如果不选择<span class="math inline">\(j +
1\)</span>,也有可能选择一个更大的值后不断落到<span class="math inline">\(j + 1\)</span>,这意味着我们转移时需要枚举补上<span class="math inline">\(j + 1\)</span>这个数字后的<span class="math inline">\(mex\)</span>并用刷表法转移.</p>
<p>不妨设这个数字是<span class="math inline">\(k\)</span>.如果我们插入一个数字后直接更新当前的答案,可以发现这个<span class="math inline">\(k\)</span>是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起<span class="math inline">\(mex\)</span>的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全<span class="math inline">\([ j + 2 , k ]\)</span>这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以<span class="math inline">\(2^{ n }\)</span>.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5>
<p><span class="math inline">\(O ( n^3 )\)</span>的暴力是显然的:设<span class="math inline">\(f_{ i , j , k }\)</span>表示目前考虑到第<span class="math inline">\(i\)</span>个位置,前面还有<span class="math inline">\(j\)</span>个A,已经选了<span class="math inline">\(k\)</span>个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到<span class="math inline">\(n^2\)</span>.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设<span class="math inline">\(f_{ i , j }\)</span>表示目前考虑到<span class="math inline">\(i\)</span>,还需要<span class="math inline">\(j\)</span>个B才能凑齐<span class="math inline">\(c_B\)</span>个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3>
<h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5>
<p>设<span class="math inline">\(f_{ i , j }\)</span>表示长度为<span class="math inline">\(i\)</span>,开头为山峰且高度为<span class="math inline">\(j\)</span>的方案数;<span class="math inline">\(g_{
i , j }\)</span>表示长度为<span class="math inline">\(i\)</span>,开头为山谷且高度为<span class="math inline">\(j\)</span>的方案数.注意到这俩显然是一个双射,也就是<span class="math inline">\(f_{ i , j } = g_{ i , i - j + 1 }\)</span>.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于<span class="math inline">\(j\)</span>的数都向上平移一格,于是自然有:<span class="math inline">\(f_{ i , j } = \sum_{ k = 1 }^{ j - 1 } g_{ i - 1 ,
k } = \sum_{ k = 1 }^{ j - 1 } f_{ i - 1 , i - k }\)</span>.</p>
<p>另外,这个式子可以稍微转化为:<span class="math inline">\(f_{ i , j } =
f_{ i - 1 , i - j + 1 } + f_{ i , j - 1 } = g_{ i - 1 , j - 1 } + f_{ i
, j - 1 }\)</span>.</p>
<p>上式可以这么理解:我们讨论一下<span class="math inline">\(j\)</span>和<span class="math inline">\(j -
1\)</span>是否相邻,如果相邻必然是<span class="math inline">\(j\)</span>是山峰,<span class="math inline">\(j -
1\)</span>是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1group">Example2(2019zrtg十连测day1
group)</span></h5>
<p>首先注意到<span class="math inline">\(2 k \leq n \land nk \leq
10^5\)</span>,不难发现<span class="math inline">\(k \leq
500\)</span>.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到<span class="math inline">\(O ( nk^2
)\)</span>.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点<span class="math inline">\(w\)</span>,使得成为组长的经验<span class="math inline">\(\geq w\)</span>,成为组员的经验<span class="math inline">\(\leq w\)</span>,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5>
<p>双序列计数,考虑把<span class="math inline">\(x\)</span>双射到某个东西上.</p>
<p>考虑最后的图一定是个<span class="math inline">\(DAG\)</span>,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设<span class="math inline">\(dp_{ l , r , mx
}\)</span>表示只考虑<span class="math inline">\([ l , r
]\)</span>这一段的线段,然后最大值所在位置需要<span class="math inline">\(\geq
mx\)</span>的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3>
<p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweightedincreasing-subsequences">Example1([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<h2><span id="动态规划的优化">动态规划的优化</span></h2>
<h3><span id="递进转移">递进转移</span></h3>
<p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5>
<p>有<span class="math inline">\(m\)</span>种礼物,每种礼物有无数个(有有限个也能做),<span class="math inline">\(n\)</span>个朋友,第<span class="math inline">\(i\)</span>个朋友喜欢第<span class="math inline">\(j\)</span>个礼物的概率是<span class="math inline">\(p_{ i , j }\)</span>,<span class="math inline">\(\forall i , \sum p_{ i , j } = 1\)</span>.</p>
<p>现在你可以选<span class="math inline">\(n\)</span>件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p><span class="math inline">\(n \leq 3000 , m \leq 300\)</span>.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出<span class="math inline">\(g_{ i , j }\)</span>表示第<span class="math inline">\(i\)</span>种礼物一共选了<span class="math inline">\(j\)</span>个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么<span class="math inline">\(g\)</span>怎么求呢?这个是简单的,我们设<span class="math inline">\(f_{ i , j }\)</span>表示喜欢第<span class="math inline">\(i\)</span>种礼物的人有<span class="math inline">\(j\)</span>个的概率,不难发现<span class="math inline">\(g_{ i , j } = \sum_{ k = 0 }^n \min \{ j , k \}
f_{ i , k }\)</span>.递推式就有<span class="math inline">\(g_{ i , j } =
g_{ i , j - 1 } + \sum_{ k = j }^n f_{ i , k }\)</span>.<span class="math inline">\(f\)</span>同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是<span class="math inline">\(O ( n^2 m
)\)</span>的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现<span class="math inline">\(g_{ i , j
}\)</span>满足四边形不等式,而其转移是经典的<span class="math inline">\(k\)</span>点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于<span class="math inline">\(g_i\)</span>是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为<span class="math inline">\(c_i\)</span>,每次选当前<span class="math inline">\(g_{ i , c_i + 1 } - g_{ i , c_i
}\)</span>最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为<span class="math inline">\(c_i\)</span>越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度<span class="math inline">\(O ( n^2 \log n )\)</span>,不太确定有没有<span class="math inline">\(O ( n^2 )\)</span>的做法.</p>
<p>但是第二个背包,也就是<span class="math inline">\(f\)</span>怎么求呢?我们发现我们没有必要把<span class="math inline">\(g\)</span>全都求出来,只需要求目前需要的一部分就可以了,由于<span class="math inline">\(\sum f =
1\)</span>,因此后缀和可以改为前缀和,考虑到每往后推一位是<span class="math inline">\(O ( n )\)</span>的,但是只会往后推总共<span class="math inline">\(O ( n )\)</span>位,因此这里复杂度<span class="math inline">\(O ( n^2 )\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>给一个字符串,求一个最大长度<span class="math inline">\(L \leq \frac{
n }{ 2 }\)</span>,使得前<span class="math inline">\(L\)</span>个字符与后<span class="math inline">\(L\)</span>个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<p><span class="math display">\[
ABSBA
\]</span></p>
<p>我们枚举<span class="math inline">\(A\)</span>的长度,然后就只需要求<span class="math inline">\(B\)</span>,设<span class="math inline">\(f_{ i
}\)</span>表示字符串去掉开头和结尾的<span class="math inline">\(i\)</span>个字符后的border,有<span class="math inline">\(f_{ i - 1 } \leq f_i +
1\)</span>.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3>
<p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个<span class="math inline">\(k\)</span>暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取<span class="math inline">\(\max\)</span>操作很艰难.但如果!我把这个dp反过来,我设<span class="math inline">\(f_{ i , j
}\)</span>表示<strong>从后往前</strong>dp到<span class="math inline">\(i\)</span>,当前的最大前缀和是<span class="math inline">\(j\)</span>的概率是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f_{ i , j } \rightarrow f_{ i - 1 , \max \{ 0 , j + a_{ i - 1 }
\} }
\]</span></p>
<p>最后在<span class="math inline">\(f_{ 1 , j }\)</span>处乘上<span class="math inline">\(h_j\)</span>.</p>
<p>但是这样是<span class="math inline">\(O ( n^3
)\)</span>的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设<span class="math inline">\(g_{ i , j
}\)</span>表示如果初始只有<span class="math inline">\(f_{ i , j } =
1\)</span>,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{aligned}
P \times g_{ i - 1 , \max \{ 0 , j + a_{ i - 1 } \} } &amp; \rightarrow
g_{ i , j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我认真考虑过这个<span class="math inline">\(P\)</span>应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些<span class="math inline">\(P\)</span>变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3>
<h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4>
<p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于<span class="math inline">\(200\)</span>.也就是说转移矩阵大概是<span class="math inline">\(200 \times 200\)</span>的,设状态数为<span class="math inline">\(S\)</span>.</p>
<p>继续考虑,如果直接做的话复杂度是<span class="math inline">\(O ( TS^3
\log n )\)</span>,过不了.</p>
<p>我们考虑将一个<span class="math inline">\(n\)</span>在<span class="math inline">\(w\)</span>进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了<span class="math inline">\(O ( wS^3 \log_w n + TS^2 \log_w n
)\)</span>,平衡一下复杂度即可,大概取<span class="math inline">\(w =
4\)</span>会比较优秀.</p>
<h4><span id="example2noionline3提高组魔法值">Example2([NOI
Online#3提高组]魔法值)</span></h4>
<p>重新定义矩阵乘法:用<span class="math inline">\(\oplus\)</span>替换原本的<span class="math inline">\(+\)</span>,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4>
<p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令<span class="math inline">\(f_i = \sum_{ j , a_j = a_i
- 1 }
f_j\)</span>,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的<span class="math inline">\(\sum\)</span>的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的<span class="math inline">\(f\)</span>.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设<span class="math inline">\(f_{ i , j }\)</span>表示所有<span class="math inline">\(a_x = i\)</span>的<span class="math inline">\(x\)</span>中第<span class="math inline">\(j\)</span>小的<span class="math inline">\(x\)</span>的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4>
<p>注意到<span class="math inline">\(m\)</span>和<span class="math inline">\(k\)</span>很小,这一定是突破口.</p>
<p>又注意到如果<span class="math inline">\(a_{ i + 1 } &gt;
a_i\)</span>,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字<span class="math inline">\(x + 1\)</span>,我们考虑它只能插入<span class="math inline">\([ x + 1 - m , x
]\)</span>后面,我们直接用一个二进制数<span class="math inline">\(S\)</span>表示<span class="math inline">\([ x + 1
- m , x ]\)</span>中的数字是否存在,然后就可以在转移上直接调用<span class="math inline">\(popcount ( S )\)</span>.设<span class="math inline">\(dp_{ i , j , S }\)</span>表示目前考虑完了数字<span class="math inline">\(i\)</span>,插入了<span class="math inline">\(j\)</span>个数字,存在情况是<span class="math inline">\(S\)</span>.直接对它做矩阵加速就可以做到<span class="math inline">\(O ( ( 2^m k )^3 \log n )\)</span>.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4>
<p>设<span class="math inline">\(dp_{ i , j }\)</span>表示第<span class="math inline">\(i\)</span>天走到城市<span class="math inline">\(j\)</span>的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上<span class="math inline">\(k\)</span>.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3>
<p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4>
<p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设<span class="math inline">\(f_{ l , r }\)</span>表示<span class="math inline">\(a_l\)</span>和<span class="math inline">\(a_r\)</span>必选的前提下,<span class="math inline">\([ l , r ]\)</span>这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设<span class="math inline">\(dp_{ i , j }\)</span>表示前<span class="math inline">\(i\)</span>个点,最大值为<span class="math inline">\(j\)</span>的方案数,不难发现最后一个矩阵的最小值一定是<span class="math inline">\(a_{ i }\)</span>.然后<span class="math inline">\(dp_{ a , b } = \sum_{ i &lt; a , j &lt; b } dp_{ i
, j } f_{ i + 1 , a }\)</span>.</p>
<p>这个转移是<span class="math inline">\(n^4\)</span>的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到<span class="math inline">\(n^2\)</span>,这样我们就得到了一个复杂度<span class="math inline">\(O ( n^3 )\)</span>的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点<span class="math inline">\(i\)</span>,它所在矩阵的最左边的点<span class="math inline">\(k\)</span>,最右边的点<span class="math inline">\(k\)</span>,然后此时的答案为<span class="math inline">\(pre [ j - 1 ] [ a [ k ] - 1 ] \times nxt [ k + 1 ]
[ a [ j ] + 1 ] \times f [ j ] [ i ] \times f [ i ] [ k ]\)</span>.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设<span class="math inline">\(g_{ i , j
}\)</span>为接下来我们要选<span class="math inline">\([ i , j
]\)</span>,<span class="math inline">\(i\)</span>是矩阵左端点,<span class="math inline">\(j\)</span>任意且这两个点必在矩阵中,左右两边的方案数.初始条件<span class="math inline">\(g_{ i , j } = pre [ i - 1 ] [ a [ j ] - 1 ] \times
nxt [ j + 1 ] [ a [ i ] + 1 ]\)</span>.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3>
<h4><span id="example2022zrtg十连测day7zero">Example(2022zrtg十连测day7
Zero)</span></h4>
<p>设<span class="math inline">\(k = \max \{ i , j
\}\)</span>,首先可以求出<span class="math inline">\(x , y ,
z\)</span>分别表示:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>:只包含第一行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(- 1\)</span>.</p></li>
<li><p><span class="math inline">\(y\)</span>:只包含第二行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(- 1\)</span>.</p></li>
<li><p><span class="math inline">\(z\)</span>:同时包含两行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(- 1\)</span>.</p></li>
</ol>
<p>那么自然有转移:</p>
<p><span class="math display">\[
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z
, z ) + 1 \}
\end{gathered}
\]</span></p>
<p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到<span class="math inline">\(f ( i , k )\)</span>关于<span class="math inline">\(i\)</span>不降,于是显然当<span class="math inline">\(f ( i , y ) \ne f ( i , k - 1
)\)</span>的时候才会由<span class="math inline">\(f ( i , y ) +
1\)</span>转移过来.我们不妨设<span class="math inline">\(p_i\)</span>表示最小的位置满足<span class="math inline">\(f ( i , p_i ) = f ( i , k - 1
)\)</span>,那转移也就是<span class="math inline">\(f ( i , k )
\leftarrow f ( i , k - 1 ) + [ p_i \leq y
]\)</span>.并且每进行一次转移,都会满足<span class="math inline">\(p_i
\leq y\)</span>的<span class="math inline">\(p_i\)</span>设为<span class="math inline">\(k\)</span>.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的<span class="math inline">\(i\)</span>在当前<span class="math inline">\(k\)</span>的<span class="math inline">\(f\)</span>值,将这个点放到<span class="math inline">\(p_i\)</span>位置上.然后我们每次找到<span class="math inline">\(y\)</span>并把所有在<span class="math inline">\(y\)</span>位置前的点都合并到<span class="math inline">\(k\)</span>这个点上,并打一个加法<span class="math inline">\(tag\)</span>,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的<span class="math inline">\(p_k\)</span>.</p>
<p>最后还需要处理一下<span class="math inline">\(f_{ k , k
}\)</span>,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照<span class="math inline">\(\max \{ i , j
\}\)</span>为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3>
<p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5>
<p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是<span class="math inline">\(\nexists 1 \leq i &lt; j &lt; k \leq
n\)</span>,<span class="math inline">\(a_i &gt; a_j &gt;
a_k\)</span>.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是<span class="math inline">\(dp_{ i , j }\)</span>表示现在做到<span class="math inline">\(i\)</span>,另一个上升子序列的终点是<span class="math inline">\(j\)</span>,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在<span class="math inline">\(i\)</span>一定的情况下,<span class="math inline">\(j\)</span>的值越小越容易满足.所以设<span class="math inline">\(dp_i\)</span>表示一个上升子序列的终点是<span class="math inline">\(i\)</span>,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5>
<p>首先自然的设计是<span class="math inline">\(dp_{ l , r , u , d
}\)</span>,然后优化一下就是<span class="math inline">\(O ( n^4
)\)</span>.然后咋做?</p>
<p>注意到答案不超过<span class="math inline">\(\log\)</span>级别,所以设<span class="math inline">\(dp_{ l , r , u , c }\)</span>表示答案为<span class="math inline">\(c\)</span>的时候,最大的<span class="math inline">\(d\)</span>是多少.然后就<span class="math inline">\(O ( n^3 \log n )\)</span>.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数<span class="math inline">\(a_i\)</span>减去<span class="math inline">\([ 1 ,
a_i ]\)</span>中的一个数字,减成<span class="math inline">\(0\)</span>就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.<span class="math inline">\(( n \leq 2000 )\)</span></p>
<p>先考虑一个<span class="math inline">\(O ( n^2 a^2
)\)</span>的dp,比较显然,因为一个人取数显然要么取<span class="math inline">\(1\)</span>要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设<span class="math inline">\(dp_{ l , r , x , y
}\)</span>表示目前Alice在取第<span class="math inline">\(l\)</span>堆,Bob在取第<span class="math inline">\(r\)</span>堆,第<span class="math inline">\(l\)</span>堆为<span class="math inline">\(x\)</span>,第<span class="math inline">\(r\)</span>堆为<span class="math inline">\(y\)</span>的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把<span class="math inline">\(a\)</span>存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是<span class="math inline">\(1\)</span>还是更大的数好像无所谓.那:如果<span class="math inline">\(a_1 = x\)</span>的时候,Alice能赢,那<span class="math inline">\(a_1 = x +
1\)</span>的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选<span class="math inline">\(1\)</span>,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于<span class="math inline">\(a_l\)</span>或<span class="math inline">\(a_r\)</span>.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存<span class="math inline">\(0 /
1\)</span>是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设<span class="math inline">\(dp_{ l , r
}\)</span>表示当前Alice在<span class="math inline">\(l\)</span>,Bob在<span class="math inline">\(r\)</span>,Bob还没动<span class="math inline">\(a_r\)</span>的前提下,<span class="math inline">\(a_l\)</span>至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较<span class="math inline">\(dp_{ 1 , 1 }\)</span>和<span class="math inline">\(a_1\)</span>的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选<span class="math inline">\(l\)</span>,Bob开始选<span class="math inline">\(r\)</span>,那Alice的获胜条件显然是<span class="math inline">\(dp_{ l , r } \leq a_r\)</span></p>
<p>如果可以全选(也就是Alice开始选<span class="math inline">\(l +
1\)</span>,Bob开始选<span class="math inline">\(r\)</span>的时候Alice能赢),就直接让<span class="math inline">\(dp_{ l , r } =
1\)</span>.不然,由于清空堆的人要输,所以Alice为了不输,必须要让<span class="math inline">\(dp_{ l , r - 1
}\)</span>也满足条件,一个自然的想法是<span class="math inline">\(dp_{ l
, r - 1 } + a_r +
1\)</span>,但是这个值好像没有必要:因为Bob并不是只有会不断清空<span class="math inline">\(a_r\)</span>的,如果目前的<span class="math inline">\([ l + 1 , r
]\)</span>这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢<span class="math inline">\([ l + 1 , r
]\)</span>的值,Bob就必须全清空,所以如果我们设<span class="math inline">\(g_{ l , r }\)</span>是Bob的<span class="math inline">\(dp\)</span>数组,那其实这里应该是<span class="math inline">\(a_r + 1 + dp_{ l , r - 1 } - g_{ l + 1 , r
}\)</span>,因为Bob的策略一定是一步一步走到<span class="math inline">\(g_{ l + 1 , r
}\)</span>后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5>
<p>自然的想法是<span class="math inline">\(dp_{ i , j
}\)</span>表示<span class="math inline">\(i\)</span>子树内划分成<span class="math inline">\(j\)</span>个连通块是否合法,然后我们发现如果<span class="math inline">\(j\)</span>满足条件,那么<span class="math inline">\(j + 2\)</span>一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3>
<p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于<span class="math inline">\(y\)</span>轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5>
<p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3>
<p>能用WQS二分解决的问题通常形如:需要在<span class="math inline">\(n\)</span>个物品中选择恰好<span class="math inline">\(m\)</span>个,使得最后答案最大.并且如果令<span class="math inline">\(f_i\)</span>表示选了<span class="math inline">\(i\)</span>个的最大答案,<span class="math inline">\(f_i\)</span>必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数<span class="math inline">\(C\)</span>,每选择一个物品就减去<span class="math inline">\(C\)</span>的答案.不难发现这样我们一定能逼近<span class="math inline">\(f_m\)</span>.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3>
<p>对于定义在<span class="math inline">\(\mathbb{ Z
}\)</span>上的二元函数<span class="math inline">\(w\)</span>,若对定义域上任意<span class="math inline">\(a , b , c , d ( a \leq b \leq c \leq d
)\)</span>都有<span class="math inline">\(w ( a , c ) + w ( b , d ) \leq
w ( a , d ) + w ( b , c )\)</span>,也就是交叉小于包含,则称函数<span class="math inline">\(w\)</span>满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:<span class="math inline">\(w\)</span>所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于<span class="math inline">\(0\)</span>.</p>
<p>如果它还满足<span class="math inline">\(\forall 1 \leq l &#39; \leq l
\leq r \leq r &#39; \leq n , w ( l , r ) \leq w ( l &#39; , r &#39;
)\)</span>，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理<span class="math inline">\(\min\)</span>型dp的问题,对于<span class="math inline">\(\max\)</span>型dp需要取相反数改成<span class="math inline">\(\min\)</span>.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p>若二元函数<span class="math inline">\(w ( x , y )\)</span>满足<span class="math inline">\(w ( a , b ) + w ( a + 1 , b + 1 ) \leq w ( a , b +
1 ) + w ( a + 1 , b )\)</span>.其中<span class="math inline">\(a &lt; a
+ 1 \leq b &lt; b + 1\)</span>,则<span class="math inline">\(w\)</span>满足四边形不等式.</p>
<p>证明:</p>
<p>对于<span class="math inline">\(a + 1 &lt; c\)</span> 有</p>
$$
<span class="math display">\[\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1
, c ) \\
w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a
, c ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>同时有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) &amp; \leq w ( a + 1 , c + 1 ) + w
( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
+ 1 , c + 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
<p><span class="math display">\[
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
, c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) &amp; \leq w ( a + 1 , c ) + w ( a + 2
, c + 1 )
\end{aligned}
\]</span></p>
<p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个<span class="math inline">\(2 \times
2\)</span>的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5>
<p>若<span class="math inline">\(w_1 ( l , r ) , w_2 ( l , r
)\)</span>满足四边形不等式(或区间包含单调性),则<span class="math inline">\(\forall c_1 , c_2 \geq 0\)</span>,<span class="math inline">\(( c_1 w_1 + c_2 w_2
)\)</span>满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若<span class="math inline">\(\exists f ( x ) , g ( x
)\)</span>使得<span class="math inline">\(w ( l , r ) = f ( r ) - g ( l
)\)</span>,则<span class="math inline">\(w\)</span>满足四边形恒等式.当<span class="math inline">\(f , g\)</span>单调递增时,<span class="math inline">\(w\)</span>还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>设<span class="math inline">\(h\)</span>是一个单调递增的下凸函数(一阶导数单调递增),若<span class="math inline">\(w ( l , r
)\)</span>满足四边形不等式和区间包含单调性,则复合函数<span class="math inline">\(h ( w ( l , r )
)\)</span>也满足四边形不等式和区间包含单调性.</p>
<p>令<span class="math inline">\(l_1 \leq l_2 \leq r_1 \leq
r_2\)</span>,由于<span class="math inline">\(w\)</span>满足四边形不等式,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l_1 , r_1 ) + w ( l_2 , r_2 ) &amp; \leq w ( l_1 , r_2 ) + w ( l_2 ,
r_1 ) \\
0 &amp; \leq w ( l_1 , r_1 ) - w ( l_2 , r_1 ) \leq w ( l_1 , r_2 ) - w
( l_2 , r_2 )
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(t = w ( l_1 , r_2 ) - w ( l_2 , r_2
)\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l_1 , r_1 ) &amp; \leq w ( l_2 , r_1 ) + t \\
w ( l_1 , r_2 ) &amp; = w ( l_2 , r_2 ) + t \\
h ( w ( l_1 , r_1 ) ) - h ( w ( l_2 , r_1 ) ) &amp; \leq h ( w ( l_2 ,
r_1 ) + t ) - h ( w ( l_2 , r_1 ) ) \\
h ( w ( l_1 , r_2 ) ) - h ( w ( l_2 , r_2 ) ) &amp; = h ( w ( l_2 , r_2
) + t ) - h ( w ( l_2 , r_2 ) )
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(\Delta h ( x ) = h ( x + t ) - h (
x )\)</span>,由于<span class="math inline">\(h\)</span>是下凸函数,所以<span class="math inline">\(\Delta h\)</span>函数单调递增.</p>
<p>那么也就有:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l_1 , r_1 ) ) - h ( w ( l_2 , r_1 ) ) &amp; \leq \Delta h ( w (
l_2 , r_1 ) ) \\
h ( w ( l_1 , r_2 ) ) - h ( w ( l_2 , r_2 ) ) &amp; = \Delta h ( w ( l_2
, r_2 ) )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(w ( l_2 , r_1 ) \leq w ( l_2 , r_2
)\)</span>,所以<span class="math inline">\(\Delta h ( w ( l_2 , r_1 ) )
\leq \Delta h ( w ( l_2 , r_2 ) )\)</span>于是:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l_1 , r_1 ) ) - h ( w ( l_2 , r_1 ) ) &amp; \leq h ( w ( l_1 ,
r_2 ) ) - h ( w ( l_2 , r_2 ) ) \\
h ( w ( l_1 , r_1 ) ) + h ( w ( l_2 , r_2 ) ) &amp; \leq h ( w ( l_1 ,
r_2 ) ) + h ( w ( l_2 , r_1 ) )
\end{aligned}
\]</span></p>
<p>证毕.</p>
<h5><span id="定理5">定理5</span></h5>
<p>设<span class="math inline">\(h\)</span>是一个下凸函数(一阶导数单调递增),若<span class="math inline">\(w ( l , r
)\)</span>满足四边形恒等式和区间包含单调性,则复合函数<span class="math inline">\(h ( w ( l , r ) )\)</span>也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到<span class="math inline">\(h\)</span>单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4>
<p>对于形如<span class="math inline">\(f_i = \min_{ 1 \leq j &lt; i } \{
f_j + w ( j , i ) \}\)</span>的状态转移方程,记<span class="math inline">\(p_i\)</span>为<span class="math inline">\(f_i\)</span>的最优决策.若<span class="math inline">\(p\)</span>在<span class="math inline">\([ 1 , n
]\)</span>上单调不降,则称<span class="math inline">\(f\)</span>具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的<span class="math inline">\(\min\)</span>改为<span class="math inline">\(\max\)</span>,并且把<span class="math inline">\(+
w\)</span>改为<span class="math inline">\(-
w\)</span>,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5>
<p>定理：对于形如<span class="math inline">\(f_i = \min_{ 1 \leq j &lt;
i }{ f_j + w ( j , i ) }\)</span>的状态转移方程,若<span class="math inline">\(w\)</span>满足四边形不等式,则<span class="math inline">\(f\)</span>有决策单调性.</p>
<p>证明:</p>
<p><span class="math inline">\(\forall i \in [ 1 , n ] , \forall j \in [
0 , p_i - 1 ]\)</span>,根据<span class="math inline">\(p\)</span>的定义,有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ p_i } + w ( p_i , i ) &amp; \leq f_j + w ( j , i ) \\
f_{ p_i } - f_j &amp; \leq w ( j , i ) - w ( p_i , i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而对于<span class="math inline">\(k \in [ i + 1 , n
]\)</span>,根据<span class="math inline">\(w\)</span>的四边形不等式,有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( j , i ) + w ( p_i , k ) &amp; \leq w ( j , k ) + w ( p_i , i ) \\
w ( j , i ) - w ( p_i , i ) &amp; \leq w ( j , k ) - w ( p_i , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ p_i } - f_j &amp; \leq w ( j , k ) - w ( p_i , k ) \\
f_{ p_i } + w ( p_i , k ) &amp; \leq w ( j , k ) + f_j \\

\end{aligned}\]</span>
<p>$$</p>
<p>即:<span class="math inline">\(j\)</span>对<span class="math inline">\(k\)</span>的更新一定不如<span class="math inline">\(p_i\)</span>对<span class="math inline">\(k\)</span>的更新更优,因此<span class="math inline">\(p_k \in [ p_i , n ]\)</span>,因此<span class="math inline">\(f\)</span>有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6>
<p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设<span class="math inline">\(f_i\)</span>表示价值为<span class="math inline">\(i\)</span>的答案,自然有:<span class="math inline">\(f_i = \max \{ f_{ i - kc } + sum_{ c , k }
\}\)</span>.</p>
<p>如果我们把<span class="math inline">\(c\)</span>相同的分层,那这显然是一个最短路型dp,其中<span class="math inline">\(w ( i , j ) = sum_{ c , \frac{ i - j }{ c }
}\)</span>.</p>
<p>显然这个转移只会让<span class="math inline">\(\mod
c\)</span>相同的相互转移,于是后面的<span class="math inline">\(w ( i , j
)\)</span>可以理解为一段数字的和,自然满足四边形不等式(<span class="math inline">\(\max\)</span>也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5>
<p>对于形如<span class="math inline">\(f_{ x , j } = \min_{ i = 1 }^{ x
- 1 } \{ f_{ i , j - 1 } + w_{ i , x } \}\)</span>的状态转移方程,若<span class="math inline">\(w\)</span>满足四边形不等式,则<span class="math inline">\(f\)</span>有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如<span class="math inline">\(f_x = \min_{ i = 1
}^{ x - 1 }{ w_{ i , x } }\)</span>,我们也可以看作<span class="math inline">\(k\)</span>点最短路型的<span class="math inline">\(k = 1\)</span>的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6>
<p>令<span class="math inline">\(f ( i , j )\)</span>为在第<span class="math inline">\(j\)</span>个位置建造第<span class="math inline">\(i\)</span>个基站的代价最小值,那么我们有转移:</p>
<p><span class="math display">\[
f ( i , j ) = \min_{ 1 \leq k &lt; j } \{ f ( i - 1 , k ) + \sum_{ l = k
+ 1 }^{ j - 1 } w_l [ d_l - s_l &gt; d_k ] [ d_l + s_l &lt; d_j ] + c_j
\}
\]</span></p>
<p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时<span class="math inline">\(d_k\)</span>单调递增,更新答案时<span class="math inline">\(d_j\)</span>单调递增,于是可以直接使用线段树维护,复杂度<span class="math inline">\(O ( nk \log n
)\)</span>.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度<span class="math inline">\(O ( nk
\log^2 n )\)</span>.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度<span class="math inline">\(O ( n \log k \log n )\)</span>.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6>
<p>自然的设计是<span class="math inline">\(f_{ i , j , k
}\)</span>表示前<span class="math inline">\(i\)</span>个,已经打了<span class="math inline">\(j\)</span>个,末尾有连续<span class="math inline">\(k\)</span>个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为<span class="math inline">\(f_{ i ,
j }\)</span>表示前<span class="math inline">\(i\)</span>个,目前打了<span class="math inline">\(j\)</span>个且第<span class="math inline">\(i\)</span>个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成<span class="math inline">\(f_{ i , j }\)</span>表示前<span class="math inline">\(i\)</span>个,目前有<span class="math inline">\(j\)</span>个没打中而且第<span class="math inline">\(i\)</span>个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:<span class="math inline">\(dp_{ i , j }
= \max \{ dp_{ k , j - 1 } + \sum_{ l = k + 1 }^{ i - 1 } C_{ l - k }
A_l + P \}\)</span>.</p>
<p>令<span class="math inline">\(w ( l , r ) = \sum_{ k = l + 1 }^{ r -
1 } C_{ k - l } A_k + P\)</span>,接下来我们证明:<span class="math inline">\(w ( l + 1 , r ) + w ( l , r - 1 ) \geq w ( l , r )
+ w ( l + 1 , r - 1 )\)</span>即可.讨论一下每个<span class="math inline">\(A\)</span>面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5>
<p>引理:在状态转移方程<span class="math inline">\(f_{ i , j } = \min_{ i
\leq k &lt; j } \{ f_{ i , k } + f_{ k + 1 , j } + w ( i , j )
\}\)</span>中(通常<span class="math inline">\(f_{ i , i } = w ( i , i )
= 0 , f_{ i , i + 1 } = w_{ i , i + 1 }\)</span>),如果<span class="math inline">\(w\)</span>满足四边形不等式和区间包含单调性,那么<span class="math inline">\(f\)</span>也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明<span class="math inline">\(f_{ i , j } + f_{ i + 1 , j + 1 }
\leq f_{ i , j + 1 } + f_{ i + 1 , j }\)</span>即可,考虑<span class="math inline">\(j - i = 1\)</span>的时候,显然成立.</p>
<p>使用数学归纳,假设当<span class="math inline">\(b - a &lt;
k\)</span>时,<span class="math inline">\(f\)</span>满足四边形不等式,考虑<span class="math inline">\(j - i = k\)</span>的情况:</p>
<p>设<span class="math inline">\(f_{ i , j + 1
}\)</span>的最优决策为<span class="math inline">\(x\)</span>,<span class="math inline">\(f_{ i + 1 , j }\)</span>的最优决策为<span class="math inline">\(y\)</span>,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i , j + 1 } + f_{ i + 1 , j } &amp; = f_{ i , x } + f_{ x + 1 , j +
1 } + w ( i , j + 1 ) + f_{ i + 1 , y } + f_{ y + 1 , j } + w ( i + 1 ,
j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于<span class="math inline">\(f_{ i , j }\)</span>和<span class="math inline">\(f_{ i + 1 , j + 1 }\)</span>来说,<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>不一定最优,所以有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i , j } + f_{ i + 1 , j + 1 } &amp; \leq f_{ i , x } + f_{ x + 1 , j
} + w ( i , j ) + f_{ i + 1 , y } + f_{ y + 1 , j + 1 } + w ( i + 1 , j
+ 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math inline">\(w\)</span>和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i , j } + f_{ i + 1 , j + 1 } &amp; \leq f_{ i , j + 1 } + f_{ i + 1
, j } \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="定理">定理</span></h6>
<p>记<span class="math inline">\(p_{ i , j }\)</span>为<span class="math inline">\(f_{ i , j }\)</span>的最优决策,若<span class="math inline">\(f\)</span>满足四边形不等式,那么对于<span class="math inline">\(\forall i &lt; j ， 有 p_{ i , j - 1 } \leq p_{ i
, j } \leq p_{ i + 1 , j } \\\)</span>.</p>
<p>证明:</p>
<p>记<span class="math inline">\(p = p_{ i , j }\)</span>,<span class="math inline">\(\forall k , i &lt; k \leq p\)</span>,因为<span class="math inline">\(f\)</span>满足四边形不等式,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ i , k } + f_{ i + 1 , p } &amp; \leq f_{ i , p } + f_{ i + 1 , k }
\\
f_{ i + 1 , p } - f_{ i + 1 , j } &amp; \leq f_{ i , p } - f_{ i , k }
\end{aligned}
\]</span></p>
<p>根据<span class="math inline">\(p\)</span>定义,有:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ i , p } + f_{ p + 1 , j } &amp; \leq f_{ i , k } + f_{ k + 1 , j }
\\
f_{ i , p } - f_{ i , k } &amp; \leq f_{ k + 1 , j } - f_{ p + 1 , j }
\end{aligned}
\]</span></p>
<p>由上两式移项联立,得到:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 , p } - f_{ i + 1 , k } &amp; \leq f_{ k + 1 , j } - f_{ p + 1
, j } \\
f_{ i + 1 , p } + f_{ p + 1 , j } &amp; \leq f_{ i + 1 , k } + f_{ k + 1
, j } \\
f_{ i + 1 , p } + f_{ p + 1 , j } + w_{ i + 1 , j } &amp; \leq f_{ i + 1
, k } + f_{ k + 1 , j } + w_{ i + 1 , j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>因此对于<span class="math inline">\(f_{ i + 1 , j }\)</span>,<span class="math inline">\(p\)</span>比任意的<span class="math inline">\(k
&lt; p\)</span>更优,因此<span class="math inline">\(p_{ i + 1 , j } \geq
p_{ i , j }\)</span>,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4>
<p>判断一个函数的凸性只需判断<span class="math inline">\(f ( k ) + f ( k
+ 2 ) \geq 2 f ( k + 1 )\)</span>,而这只需证明<span class="math inline">\(k\)</span>的时候的答案和<span class="math inline">\(k + 2\)</span>时的答案可以调整出两个<span class="math inline">\(k +
1\)</span>的答案(不一定是最小答案)并且这两个<span class="math inline">\(k + 1\)</span>的答案的和小于等于<span class="math inline">\(k\)</span>时和<span class="math inline">\(k +
2\)</span>时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5>
<p>首先考虑四个点<span class="math inline">\(( a , b , c , d
)\)</span>,注意到其一定满足四边形不等式,也就是<span class="math inline">\(w_{ ac } + w_{ bd } \geq w_{ ad } + w_{ bc
}\)</span>.</p>
<p>我们现在想证明,设<span class="math inline">\(f_k\)</span>为新增<span class="math inline">\(k\)</span>个传送机后的减少的答案,我们考虑证明<span class="math inline">\(f_k + f_{ k + 2 } \geq 2 f_{ k + 1 }\)</span>.</p>
<p>我们画出<span class="math inline">\(f_k\)</span>时选的点和<span class="math inline">\(f_{ k + 2
}\)</span>时选的点,注意到我们可以用这两次调整出两个<span class="math inline">\(k +
1\)</span>的答案,并且这两个答案的和小于等于<span class="math inline">\(f_k + f_{ k + 2 }\)</span>,于是证明了最小的<span class="math inline">\(f_{ k + 1 }\)</span>是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量<span class="math inline">\(w\)</span>,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于<span class="math inline">\(w\)</span>的最大的传送机数量,然后就可以做了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">人工智能基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="常用激活函数">常用激活函数</span></h3>
<h4><span id="sigmoid函数">Sigmoid函数</span></h4>
<p><span class="math inline">\(f ( x ) = \frac{ 1 }{ 1 + e^{ - x } } : (
- \infty , + \infty ) \to ( 0 , 1 )\)</span>.</p>
<p><span class="math inline">\(f &#39; ( x ) = f ( x ) ( 1 - f ( x )
)\)</span>.</p>
<h4><span id="tanh函数">tanh函数</span></h4>
<p><span class="math inline">\(f ( x ) = \frac{ e^x - e^{ - x } }{ e^x +
e^{ - x } } : ( - \infty , + \infty ) \to ( - 1 , 1 )\)</span>.</p>
<p><span class="math inline">\(f &#39; ( x ) = 1 - f^2 ( x
)\)</span>.</p>
<h4><span id="relu函数">ReLU函数</span></h4>
<p><span class="math inline">\(f ( x ) = \max ( 0 , x ) : ( - \infty , +
\infty ) \to ( 0 , + \infty )\)</span>.</p>
<h4><span id="leaky-relu函数">Leaky ReLU函数</span></h4>
<p><span class="math inline">\(f ( x ) = \max ( \alpha x , x ) , 0 &lt;
\alpha &lt; 1 : ( - \infty , + \infty ) \to ( - \infty , + \infty
)\)</span>.</p>
<h4><span id="softmax函数">Softmax函数</span></h4>
<p><span class="math inline">\(f ( x_i ) = \frac{ e^{ x_i } }{ \sum_j
e^{ x_j } }\)</span>.</p>
<h3><span id="损失函数">损失函数</span></h3>
<h4><span id="least-square">Least Square</span></h4>
<p>即<span class="math inline">\(\arg \min \sum_{ i = 1 }^n ( f ( x_i )
- y_i )^2 = \arg \min ( A \beta - Y \mid A \beta - Y
)\)</span>.用最小二乘法取<span class="math inline">\(\hat \beta = ( A^T
A )^{ - 1 } A^T Y\)</span>.</p>
<h4><span id="cross-entropy">Cross Entropy</span></h4>
<p>用错误的分布<span class="math inline">\(q\)</span>来表示真实分布<span class="math inline">\(p\)</span>的样本,则平均编码长度应该是:</p>
<p><span class="math display">\[
H ( p , q ) = \sum_i p ( i ) \log ( \frac{ 1 }{ q ( i ) } ) = - \sum_i p
( i ) \log{ q ( i ) }
\]</span></p>
<p>此为交叉熵.</p>
<p>特别地,当最终样本只有两个的时候,例如Logistical
Regression问题,可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
H &amp; = - ( y \log a + ( 1 - y ) \log ( 1 - a ) ) \\
\frac{ \partial H }{ \partial a } &amp; = - ( \frac{ y }{ a } - \frac{ 1
- y }{ 1 - a } )
\end{aligned}
\]</span></p>
<p>那如果有多个呢?考虑直接对归一化条件作偏导,先有:</p>
<p><span class="math display">\[
\begin{aligned}
H ( p , q ) &amp; = - \sum_i p_i ( \log{ q_i } - \log ( \sum_j q_j ) )
\\
\frac{ \partial H ( p , q ) }{ \partial q_k } &amp; = - \frac{ p_k }{
q_k } + \frac{ \sum p_k }{ \sum_j q_j } \\
&amp; = - \frac{ p_k }{ q_k } + 1
\end{aligned}
\]</span></p>
<p>再乘以softmax那里的<span class="math inline">\(q_k\)</span>,得到<span class="math inline">\(- p_k + q_k = - y_k + f ( x_k )\)</span>.</p>
<h3><span id="神经网络实现">神经网络实现</span></h3>
<p>通过若干隐藏层,假设最后的输出层为第<span class="math inline">\(L\)</span>层,则:</p>
<ol type="1">
<li><p>对于第<span class="math inline">\(l\)</span>层,取<span class="math inline">\(\vec{ z }_l = ( W_l )^t \vec{ a }_{ l - 1 } +
\vec{ b }_l\)</span>.这里对<span class="math inline">\(W_l\)</span>作转置的目的是写代码的时候需要用行向量.</p></li>
<li><p>对于第<span class="math inline">\(l\)</span>层,取<span class="math inline">\(\vec{ a }_l = f ( \vec{ z }_l
)\)</span>,这里意味着将每一个分量对<span class="math inline">\(f\)</span>操作.</p></li>
<li><p>对于最终答案,取误差<span class="math inline">\(\mathcal{ L } =
\frac{ 1 }{ m } ( \vec{ y } - \vec{ a }_L \mid \vec{ y } - \vec{ a }_L
)\)</span>.</p></li>
</ol>
<h4><span id="梯度下降法">梯度下降法</span></h4>
<p>换言之就是让<span class="math inline">\(w : = w - \alpha \frac{
\partial \mathcal{ L } }{ \partial w }\)</span>,其中<span class="math inline">\(\alpha\)</span>是一个选定的小常数,也可以采用类似模拟退火的方式动态决定.事实上可以把各个位置分开,写作<span class="math inline">\(w_j : = w_j - \alpha \frac{ \partial \mathcal{ L }
}{ \partial w_j }\)</span>.</p>
<p>另外,虽然是这么写,应当见到去掉下标<span class="math inline">\(k\)</span>的记号仍然合理,无非是逐分量做此操作,因此下面如无特殊说明,运算均采用逐分量运算.例如可以定义<span class="math inline">\(\vec{ a } \circ \vec{ b
}\)</span>为两个向量逐分量相乘后得到的新向量,为表区分用<span class="math inline">\(\times\)</span>表示正常的矩阵乘法.甚至采取<span class="math inline">\(( \vec{ a } - \vec{ y }
)^2\)</span>表示其自点积.坦白而言,笔者对此符号相当无奈,可也想不出什么更好的写法了.但总之这种写法总是强于部分参考资料上所将下标放上面的写作<span class="math inline">\(a^L\)</span>的做法.笔者所能维持的精神数院人的唯一做法也只能是在下面加上向量符号,藉此泄愤.</p>
<p>顺便一提,应当见到<span class="math inline">\(\times\)</span>和<span class="math inline">\(\circ\)</span>这两种运算比较随意,用线性映射来理解,你这个<span class="math inline">\(W \times\)</span>任意作用在一个向量上就行.</p>
<h4><span id="误差反向传播">误差反向传播</span></h4>
<p>既然要用梯度下降法,就应该把每一层的偏导都求出来.然而<span class="math inline">\(\mathcal{ L
}\)</span>是最后一层的结果,因此应该用链式法则一路求出前面的偏导.</p>
<p>更具体地,不妨设误差函数选的是<span class="math inline">\(( \vec{ a }
- \vec{ y } )^2\)</span>,激活函数选的是cross entropy有:</p>
<ol type="1">
<li><p><span class="math inline">\(\frac{ \partial{ \mathcal{ L } } }{
\partial \vec{ a }_{ L } } = ( \vec{ a }_{ L } - \vec{ y }
)\)</span>.(如若选择不同的误差函数,这里作适当变化)</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ a }_{ l } }{
\partial \vec{ z }_{ l } } = f &#39; ( \vec{ z }_{ l } ) = \vec{ a }_{ l
} \circ ( 1 - \vec{ a }_{ l }
)\)</span>.(如若选取不同的激活函数,这里作适当变化)</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ z }_{ l + 1 }
}{ \partial \vec{ z }_{ l } } = \frac{ \partial \vec{ z }_{ l + 1 } }{
\partial \vec{ a }_{ l } } \frac{ \partial \vec{ a }_{ l } }{ \partial
\vec{ z }_{ l } } = ( W_{ l + 1 } )^t \times ( \vec{ a }_l \circ ( 1 -
\vec{ a }_l ) )\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ z }_{ l } }{
\partial W_{ l } } = ( \vec{ a }_{ l - 1 }
)\)</span>.结果理应是一个矩阵,其实就是这个列向量不断复制若干遍,或者写成<span class="math inline">\(( \vec{ a }_{ l - 1 } )^t M ( 1
)\)</span>,其中<span class="math inline">\(M ( 1 )\)</span>是全<span class="math inline">\(1\)</span>矩阵.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ z }_{ l } }{
\partial \vec{ b }_{ l } } = 1\)</span>.</p></li>
</ol>
<p>我们应当见到:</p>
<p>不妨设<span class="math inline">\(\delta_l = \frac{ \partial{
\mathcal{ L } } }{ \partial \vec{ z }_l }\)</span>.见到:</p>
<ol type="1">
<li><p><span class="math inline">\(\delta_L = \frac{ \partial \mathcal{
L } }{ \partial \vec{ z }_L } = \frac{ \partial \mathcal{ L } }{
\partial \vec{ a }_L } \frac{ \partial \vec{ a }_L }{ \partial \vec{ z
}_L } = ( \vec{ a }_{ L } - \vec{ y } ) \circ \vec{ a }_{ L } \circ ( 1
- \vec{ a }_{ L }
)\)</span>.前者会因为误差函数的选取而改变,后者会因为激活函数的选取而改变.</p></li>
<li><p><span class="math inline">\(\delta_l = \frac{ \partial{ \mathcal{
L } } }{ \partial \vec{ z }_l } = \delta_{ l + 1 } \frac{ \partial \vec{
z }_{ l + 1 } }{ \partial \vec{ z }_l } = \delta_{ l + 1 } \circ ( W_{ l
+ 1 } )^t \times ( \vec{ a }_{ l } \circ ( 1 - \vec{ a }_{ l } )
)\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \mathcal{ L } }{
\partial W_{ l } } = \frac{ \partial \mathcal{ L } }{ \partial \vec{ z
}_{ l } } \frac{ \partial \vec{ z }_l }{ \partial W_{ l } } = \delta_l
\times a_{ l - 1 }^t\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \mathcal{ L } }{
\partial \vec{ b }_l } = \delta_l\)</span>.</p></li>
</ol>
<p>如此以上更新即可.</p>
<h3><span id="卷积神经网络cnn">卷积神经网络(CNN)</span></h3>
<p>神经网络受矩阵乘法的限制,导致对于真实的尺寸巨大的图像难以快速识别,因此产生了卷积神经网络的概念,大概有以下特征:</p>
<ol type="1">
<li><p>空间上权值共享:不同位置使用同一个卷积核(滤波器)</p></li>
<li><p>稀疏链接:每一层只链接前一层的感受野.</p></li>
<li><p>等变表示:卷积神经网络有某种平移不变性.</p></li>
</ol>
<p>对于2D卷积,其公式如下:</p>
<p><span class="math display">\[
S_{ r , c } = ( X * W )_{ r , c } = \sum_i \sum_j X_{ r + i , c + j }
\times w_{ i , j }
\]</span></p>
<p>其中<span class="math inline">\(W\)</span>是卷积核,<span class="math inline">\(X\)</span>是输入图像,<span class="math inline">\(S\)</span>是输出的结果.如果一个图像有多个通道(比如色彩层之类的),每个通道上都需要应用一个卷积核.</p>
<p>下面引入一些名词:</p>
<ol type="1">
<li><p>input size:输入图像的尺寸.</p></li>
<li><p>padding:填充的像素数.</p></li>
<li><p>filter size:卷积核的尺寸.有时也写作两个变量:filter height和filter
width.3D卷积还会有一个filter depth的变量.</p></li>
<li><p>stride:步长.</p></li>
<li><p>output size:卷积后输出的尺寸.有时也写作feature size.</p></li>
<li><p>input channels:输入图像的通道数.</p></li>
<li><p>n filters:卷积核的数量.</p></li>
<li><p>dilation rate:膨胀率,用于空洞卷积.膨胀率为<span class="math inline">\(d\)</span>的时候,卷积核中间会插入<span class="math inline">\(d - 1\)</span>个<span class="math inline">\(0\)</span>间隔.</p></li>
</ol>
<h4><span id="感受野计算">感受野计算</span></h4>
<p>先看output
size的计算,容易见到,其各个维度方面计算是独立的.只要对于单个维度算出卷积核在上面移动的次数,最后将不同维度相乘即可.</p>
<p>对于单个维度,这个维度的移动次数应该是:</p>
$$
<span class="math display">\[\begin{aligned}
\text{ output \_ size } &amp; = \lceil \frac{ \text{ input \_ size } + 2
\times \text{ padding } - \text{ filter \_ size } + 1 }{ \text{ stride }
} \rceil \\
&amp; = \lfloor \frac{ \text{ input \_ size } + 2 \times \text{ padding
} - \text{ filter \_ size } }{ \text{ stride } } \rfloor + 1 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式相当容易理解,原因是<span class="math inline">\(\text{ stride
} = 1\)</span>的时候,上面恰好是移动的次数,而<span class="math inline">\(\text{ stride
}\)</span>变化的时候,当然要拿到一个上取整.</p>
<p>至于所谓的空洞卷积,只需在上面的基础上改<span class="math inline">\(\text{ filter \_ size }\)</span>就好.</p>
<p>至于乘法操作,每得到一个<span class="math inline">\(\text{ output
}\)</span>当然都会需要<span class="math inline">\(\text{ filter \_ size
}\)</span>次乘法操作.</p>
<p>再看感受野的计算,不妨设<span class="math inline">\(S_i\)</span>为前<span class="math inline">\(i\)</span>次卷积的<span class="math inline">\(\text{ stride }\)</span>的乘积,设<span class="math inline">\(k_{ i + 1 }\)</span>表示第<span class="math inline">\(i + 1\)</span>层的<span class="math inline">\(\text{ kernel \_ size }\)</span>,则:</p>
<p><span class="math display">\[
RF_{ i + 1 } = RF_i + ( k_{ i + 1 } - 1 ) \times S_i
\]</span></p>
<p>这个公式的含义大概是每次先看对应了多大的原数据上的范围,再把原本的边界<span class="math inline">\(RF_i\)</span>给补上.</p>
<h4><span id="池化pooling">池化(Pooling)</span></h4>
<p>池化操作它没有一个可学习的参数,只是对输入数据进行固定的操作.简单来说就是降低输入的规模,以实现更好的鲁棒性以及提高效率.</p>
<p>常见的池化操作包括:</p>
<ol type="1">
<li><p>MaxPooling:取区域内的最大值.</p></li>
<li><p>MeanPooling:取区域内的平均值.</p></li>
<li><p>PyramidPooling:多次进行尺度不同的池化.</p></li>
</ol>
<h4><span id="常见卷积架构">常见卷积架构</span></h4>
<h5><span id="alexnet">AlexNet</span></h5>
<p>首次引入ReLU激活函数,Dropout
技术,以及数据增强,提高了模型的训练效率和泛化能力.</p>
<p>采用了<span class="math inline">\(8\)</span>层深的网络结构,证明了深度网络的潜力.</p>
<h5><span id="vgg">VGG</span></h5>
<p>开始堆叠小尺寸的卷积核,获得与大卷积核相似的感受野的同时可以增加网络深度.</p>
<h5><span id="resnet">ResNet</span></h5>
<p>引入残差的概念,直接将输入数据累加(跳跃连接)到最后的输出中,这样网络学习的实际上是输入和输出之间的残差,从而提高了网络学习能力.</p>
<h5><span id="squeezenet">SqueezeNet</span></h5>
<p>SqueezeNet的基本构建单元是Fire模块.Fire模块由一个squeeze层和一个expand层组成.squeeze层使用<span class="math inline">\(1 \times
1\)</span>卷积核减少通道数,而expand层则使用<span class="math inline">\(1
\times 1\)</span>和<span class="math inline">\(3 \times
3\)</span>卷积核增加通道数.这种设计有效地减少了参数数量和计算量.</p>
<h5><span id="mobilenet">MobileNet</span></h5>
<ol type="1">
<li><p>深度卷积:在这个操作中,每个输入通道独立地进行卷积,这意味着在进行卷积时,不同通道之间没有交互.这样可以减少计算量和参数数量.</p></li>
<li><p>逐点卷积:逐点卷积使用<span class="math inline">\(1 \times
1\)</span>的卷积核,它作用在深度卷积的输出上,将不同通道的信息整合在一起.逐点卷积可以减少参数数量,同时保持较高的性能.</p></li>
</ol>
<h5><span id="shufflenet">ShuffleNet</span></h5>
<ol type="1">
<li><p>组卷积(Group
Convolution):将通道分成几个组,并使用不同的卷积神经网络层执行标准卷积.</p></li>
<li><p>打乱层(Shuffle
layer):通过对通道进行洗牌,将不同组的信息合并.</p></li>
</ol>
<h5><span id="反卷积">反卷积</span></h5>
<p>也就是将较小的数据特征图扩大到较大的尺寸.有的时候也把这个操作说成上采样.</p>
<ol type="1">
<li><p>插值步骤(Interpolation
Step):首先,在输入特征图的元素之间插入零,增加特征图的尺寸.</p></li>
<li><p>卷积步骤(Convolution
Step):接下来,对扩大后的特征图应用一个标准的卷积操作.此步骤相当于在扩大的特征图上滑动卷积核,计算卷积输出.</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">OI中的线性代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<ul>
<li><a href="#oi中的线性代数">OI中的线性代数</a>
<ul>
<li><a href="#线性基">线性基</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan
and Burgers)</a></li>
<li><a href="#example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337
[Ynoi2004] rsxc)</a></li>
<li><a
href="#example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</a></li>
</ul></li>
<li><a href="#杂题">杂题</a>
<ul>
<li><a href="#example1cf1270ixor-on-figures">Example1([CF1270I]Xor on
Figures)</a></li>
<li><a
href="#example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing
Finals)</a></li>
</ul></li>
<li><a href="#逆矩阵求解线性方程组">逆矩阵求解线性方程组</a>
<ul>
<li><a
href="#example1codeforces-cf1266h-red-blue-graph">Example1(codeforces
CF1266H Red-Blue Graph)</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/6/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
