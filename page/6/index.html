<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/6/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2>
<h3><span id="分析状态">分析状态</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个<span class="math inline">\([ 1 , m ]\)</span>中的数字,然后进行以下判断:</p>
<ol type="1">
<li><p>如果当前序列末尾两个数字相同且小于<span class="math inline">\(t\)</span>,假设都是<span class="math inline">\(x\)</span>,那就将它们都删去,加入一个<span class="math inline">\(x + 1\)</span>.</p></li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为<span class="math inline">\(n\)</span>,终止操作.</p></li>
</ol>
<p>给定<span class="math inline">\(n , m ,
t\)</span>,求最终序列的元素和的期望.</p>
<p><span class="math inline">\(n , m \leq 10^3 , t \leq
10^9\)</span>.</p>
<p>首先<span class="math inline">\(t \leq
10^9\)</span>显然是没用的,因为它最多也就能这么凑:<span class="math inline">\(m + n - 2 , m + n - 3 , \cdots , m ,
m\)</span>,合成一个<span class="math inline">\(m + n -
1\)</span>,因此我们令<span class="math inline">\(t = \min \{ t , m + n -
1 \}\)</span>即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置<span class="math inline">\(i\)</span>,有<span class="math inline">\(a_i &lt;
a_{ i + 1 }\)</span>,那么无论后面怎么做,这里的<span class="math inline">\(a_i\)</span>都必不可能被删除.以此,我们不妨设<span class="math inline">\(f_{ i , j }\)</span>表示序列长度为<span class="math inline">\(i\)</span>,序列开头元素为<span class="math inline">\(j\)</span>的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过<span class="math inline">\(t\)</span>,另一个是序列的长度不能超过<span class="math inline">\(n\)</span>.我们不妨设<span class="math inline">\(ans_{ n , t
}\)</span>表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移<span class="math inline">\(ans\)</span>需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下<span class="math inline">\(ans_{ n , t
}\)</span>,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有<span class="math inline">\(ans_{ n , t } = \sum_{ x = 1 }^t E ( n 个 位 置 ,
第 一 个 位 置 是 x 并 且 没 有 被 删 去 )\)</span>.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:<span class="math inline">\(3 , 3 ,
3\)</span>,最终的答案应该是<span class="math inline">\(4 ,
3\)</span>.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了<span class="math inline">\(3 , [ 3 , 3 ]\)</span>,最终的答案就变成了<span class="math inline">\(3 ,
4\)</span>.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设<span class="math inline">\(g_{ i , j }\)</span>表示当前后面还有<span class="math inline">\(i - 1\)</span>个位置,当前前面已经放好了一个<span class="math inline">\(j\)</span>,这个<span class="math inline">\(j\)</span>不能被删掉的期望,显然有<span class="math inline">\(ans_{ n , t } = \sum_{ x }^t g_{ n , x } P ( 最 终
序 列 中 , 这 里 是 k )\)</span>,问题只在于如何求<span class="math inline">\(g\)</span>.这个<span class="math inline">\(g_{ n ,
k }\)</span>是钦定了这个位置放<span class="math inline">\(k\)</span>的期望,后面我们需要将它乘上这个位置放<span class="math inline">\(k\)</span>的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个<span class="math inline">\(g_{ n , k } = ( k +
\sum_{ j \ne k } g_{ n - 1 , j }
)\)</span>.但是实际上这个是不对的.这里的<span class="math inline">\(k\)</span>不能删掉不意味着后面的<span class="math inline">\(j\)</span>不能删掉,事实上后面的<span class="math inline">\(j\)</span>爱怎么删怎么删,只要不搞出一个<span class="math inline">\(k\)</span>来就可以.因此我们需要设<span class="math inline">\(f_{ i , j }\)</span>表示当前后面还有<span class="math inline">\(i\)</span>个位置,第一个位置不能是<span class="math inline">\(j\)</span>,也不能曾经是<span class="math inline">\(j\)</span>(因为这里只要是<span class="math inline">\(j\)</span>都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设<span class="math inline">\(f_{ i , j }\)</span>表示后面还有<span class="math inline">\(i\)</span>个位置,第一个位置现在或曾经是过<span class="math inline">\(j\)</span>的期望.那么全集是什么呢?全集是<span class="math inline">\(ans_i\)</span>.</p>
<p>还没完啊,我们还需要求一下这里是<span class="math inline">\(k\)</span>的概率,由于还有一个类似的<span class="math inline">\(f\)</span>,我们还要求一下这里曾经是<span class="math inline">\(k\)</span>的概率.设前者为<span class="math inline">\(q_{ i , k }\)</span>,后者为<span class="math inline">\(p_{ i , k
}\)</span>.我们来强调一下这里设计的原则:这里的<span class="math inline">\(p\)</span>其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了<span class="math inline">\(k\)</span>,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过<span class="math inline">\(k\)</span>了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是<span class="math inline">\(k\)</span>等价于这里是<span class="math inline">\(k\)</span>并且后面没有出现过<span class="math inline">\(k\)</span>,也就是<span class="math inline">\(q_{ i
, k } = p_{ i , k } ( 1 - p_{ i - 1 , k } \times [ k &lt; t ]
)\)</span>.这里加一个限制是因为有不能超过<span class="math inline">\(t\)</span>的限制.</p>
<p>对于后者,这里的<span class="math inline">\(k\)</span>有很多种可能出现过,一种是直接加入,一种是合并而来,于是<span class="math inline">\(p_{ i , k } = \frac{ 1 }{ m } [ k \leq m ] + p_{ i
, k - 1 } p_{ i - 1 , k - 1 }\)</span>.</p>
<p>因此我们几经辗转,终于得到了<span class="math inline">\(g\)</span>的转移式子:</p>
<p><span class="math display">\[
q_{ i , k } g_{ n , k } = p_{ i , k } ( k + ans_{ i - 1 } - f_{ i - 1 ,
k } p_{ i - 1 , k } )
\]</span></p>
<p>就差<span class="math inline">\(f\)</span>了.<span class="math inline">\(f\)</span>有两种可能:要么最后仍然是<span class="math inline">\(k\)</span>,要么这个<span class="math inline">\(k\)</span>已经被杀掉了.于是:</p>
<p><span class="math display">\[
p_{ i , k } f_{ i , k } = q_{ i , k } g_{ i , k } + ( p_{ i , k } - q_{
i , k } ) f_{ i , k + 1 }
\]</span></p>
<h5><span id="example2cf1007e">Example2(CF1007E)</span></h5>
<p>首先我们需要发现一个很强的性质:作用到了第<span class="math inline">\(i\)</span>个站台就会清空前面所有站台.清空后就和<span class="math inline">\(a_i\)</span>无关了,而如果还没涉及到一定和<span class="math inline">\(a_i\)</span>有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设<span class="math inline">\(f_{
i , j }\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间需要的最少火车数量.<span class="math inline">\(g_{ i , j }\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间,并且<span class="math inline">\([ 1 , i - 1
]\)</span>全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为<span class="math inline">\(+ \infty\)</span>表示无法满足(对于全局,我们在<span class="math inline">\(n + 1\)</span>处放一个<span class="math inline">\(a = + \infty , b = 0 , c = +
\infty\)</span>来保证一定会满载).为什么需要<span class="math inline">\(g\)</span>作为辅助dp数组呢?我们先对着<span class="math inline">\(f\)</span>分析.</p>
<p>考虑<span class="math inline">\(f_{ i , j
}\)</span>的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前<span class="math inline">\(j\)</span>轮中根本没接走站台<span class="math inline">\(i\)</span>的人.此时需要满足<span class="math inline">\(f_{ i - 1 , j } \ne + \infty \land a_i + j \times
b_i \leq c_i\)</span>.那么这里怎么更新<span class="math inline">\(g\)</span>呢?设<span class="math inline">\(L =
sa_{ i - 1 } + sb_{ i - 1 } \times j\)</span>,显然<span class="math inline">\(g_{ i , j } = \lceil \frac{ L }{ K }
\rceil\)</span>,并且需要保证此时没有用到<span class="math inline">\(i\)</span>以后的站台,因此需要保证<span class="math inline">\(\lceil \frac{ L }{ K } \rceil K \leq sa_{ i } +
sb_i \times j\)</span>.注意到由于这里保证了<span class="math inline">\(f_{ i - 1 , j
}\)</span>是可以取到的,因此我们可以撑到第<span class="math inline">\(j\)</span>秒,剩下的火车在<span class="math inline">\(j + \varepsilon\)</span>秒全选.</p>
<p>第二种,前<span class="math inline">\(j\)</span>轮中有火车接走站台<span class="math inline">\(i\)</span>的人.设最后一次是在<span class="math inline">\(r\)</span>时间接走的站台<span class="math inline">\(i\)</span>,那么此时必然清空了<span class="math inline">\([ 1 , i - 1 ]\)</span>,这里用了<span class="math inline">\(g_{ i , r }\)</span>.然后为了防止这里在<span class="math inline">\([ r + 1 , j
]\)</span>这段时间中爆掉,因此还需要<span class="math inline">\(w =
\lceil \frac{ \max \{ 0 , rem + ( j - r ) b_i - c_i \} }{ K }
\rceil\)</span>,其中<span class="math inline">\(rem\)</span>是<span class="math inline">\(r\)</span>时刻<span class="math inline">\(i\)</span>剩下的人数.这些火车都要在<span class="math inline">\(r\)</span>时刻之前解决(因为我们设了最后一次在<span class="math inline">\(r\)</span>时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在<span class="math inline">\(r\)</span>这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有<span class="math inline">\(wK \leq rem\)</span>.但是,接下来在<span class="math inline">\([ r + 1 , j
]\)</span>时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设<span class="math inline">\(f_{ i , j , 0 }\)</span>表示只考虑前<span class="math inline">\(i\)</span>个站台,要撑<span class="math inline">\(j\)</span>个单位时间需要的最少火车数量,但是<span class="math inline">\([ 1 , i ]\)</span>都被清空为<span class="math inline">\(0\)</span>过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol type="1">
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p></li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将<span class="math inline">\(g_{ 1 , t , 0 / 1 }\)</span>全部设为<span class="math inline">\(0\)</span>,因为我觉得无论如何<span class="math inline">\(0\)</span>位置都是清空的,但实际上这是错误的!因为在<span class="math inline">\(t\)</span>时刻的<span class="math inline">\(1\)</span>位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前<span class="math inline">\(i\)</span>个的合法性,并且如果我们想要让<span class="math inline">\(i\)</span>位置合法,一定要求让<span class="math inline">\([ 1 , i - 1 ]\)</span>合法.</p></li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从<span class="math inline">\(r \rightarrow
t\)</span>这个过程中会积累的量,这些量必然要在<span class="math inline">\(r\)</span>时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p></li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>定义一个有根树为大菊花,当且仅当这棵树的根的度数<span class="math inline">\(\leq m \land \nexists x \ne root , \deg ( x ) &gt;
2\)</span>.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.<span class="math inline">\(( n \leq 5 \times 10^5 , m \leq 50 )\)</span></p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到<span class="math inline">\(O ( nm^2 )\)</span>.</p>
<p>注意到这个背包是可删除的,所以就能做到<span class="math inline">\(O (
nm )\)</span>.</p>
<h3><span id="dp分界点">dp分界点</span></h3>
<h4><span id="example12022zrtg十连测day7permutation">Example1(2022zrtg十连测day7
Permutation)</span></h4>
<p>首先注意到<span class="math inline">\([ 3 , n
]\)</span>一定会被分成两段递减的序列,分别跟在<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的后面,假设<span class="math inline">\(1\)</span>在<span class="math inline">\(2\)</span>前面,这样算出答案后乘以<span class="math inline">\(n\)</span>即可.</p>
<p>注意到<span class="math inline">\(i + 1\)</span>一定可以放到<span class="math inline">\(i\)</span>的前面,设<span class="math inline">\(f_i\)</span>表示在<span class="math inline">\(i\)</span>和<span class="math inline">\(i +
1\)</span>之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即<span class="math inline">\(i\)</span>的倍数<span class="math inline">\(\pm
1\)</span>之类的,于是可以实现,复杂度<span class="math inline">\(O ( n
\ln n )\)</span>.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3>
<h4><span id="example1cf1666e">Example1(CF1666E)</span></h4>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 } &amp; = \max \{ a_{ i + 1 } , f_i + mn \} \\
g_{ i + 1 } &amp; = \min \{ a_{ i + 2 } , g_i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([ f_i , g_i
]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{ i
}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ ans_{ i + 1 } - mx , ans_{ i + 1 } - mn
]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([ f_i , g_i
]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{ i + 1 } - mn &lt; f_i , f_{ i + 1 } &lt;
ans_{ i + 1 } &lt; f_i +
mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx - mn\)</span>.</p>
<h3><span id="数位dp">数位dp</span></h3>
<h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4>
<p>首先设<span class="math inline">\(f_{ i , j }\)</span>表示长度为<span class="math inline">\(i\)</span>的,以<span class="math inline">\(S [ n -
j + 1 . . . n ]\)</span>为子序列的字符串个数.</p>
<p>考虑按位处理,每次将<span class="math inline">\(T\)</span>的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出<span class="math inline">\(k\)</span>.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为<span class="math inline">\(k\)</span>.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4>
<p>第一反应就是枚举<span class="math inline">\(x &#39;\)</span>和<span class="math inline">\(y &#39;\)</span>,然后用数位dp枚举<span class="math inline">\(d\)</span>使得<span class="math inline">\(x = dx
&#39; , y = dy &#39;\)</span>.</p>
<p>但是有一个问题在于如果<span class="math inline">\(\gcd ( x &#39; , y
&#39; ) \ne 1\)</span>怎么办,这样有可能会算重.我们发现我们只判断<span class="math inline">\(\gcd ( x &#39; , y &#39; ) =
1\)</span>的情况就行,然后写一个<span class="math inline">\(2^8\)</span>判断<span class="math inline">\(x
&#39; , 2 x &#39; , 3 x &#39; , 4 x &#39;\)</span>以及对应的<span class="math inline">\(y &#39;\)</span>出现了没有.复杂度<span class="math inline">\(( 9^4 \times 2^8 \times \log_{ 10 } n
)\)</span>,有点难过.</p>
<p>但是我们发现这个<span class="math inline">\(2^8\)</span>可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有<span class="math inline">\(3^4 \times 2\)</span>的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3>
<h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4>
<p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是<span class="math inline">\(O ( nd^2
)\)</span>的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是<span class="math inline">\(O ( nd )\)</span>的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取<span class="math inline">\(\min\)</span>转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>现在有一个<span class="math inline">\([ 1 , n
]\)</span>的排列,现在要从中选出一个集合<span class="math inline">\(S\)</span>,满足<span class="math inline">\(\forall
x \in S , 2 x \notin S , 3 x \notin S\)</span>,求方案数.</p>
<p>首先考虑将每个数分解为<span class="math inline">\(a \times 2^b \times
3^c\)</span>的形式,显然<span class="math inline">\(a\)</span>不相同的数之间互不干扰.</p>
<p>对于<span class="math inline">\(a\)</span>相同的一群数,我们考虑将<span class="math inline">\(( b , c
)\)</span>作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3>
<h4><span id="example1">Example1</span></h4>
<p><span class="math inline">\(n\)</span>个点的树,一开始位于一号点,每个点有一个颜色(<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>),每次随机选择一个点<span class="math inline">\(v\)</span>,从当前所在点移动到<span class="math inline">\(v\)</span>并将<span class="math inline">\(v\)</span>的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为<span class="math inline">\(1\)</span>,当然不为<span class="math inline">\(1\)</span>也能做).</p>
<p><span class="math inline">\(n \leq 100000\)</span>.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>就可以.不妨设<span class="math inline">\(f_{ i }\)</span>表示当前有<span class="math inline">\(i\)</span>个点是<span class="math inline">\(1\)</span>,最后全<span class="math inline">\(1\)</span>或者全<span class="math inline">\(0\)</span>所需要的期望步数,显然<span class="math inline">\(f_0 = f_n = 0\)</span>,<span class="math inline">\(f_{ i } = \frac{ 1 }{ 2 } ( f_{ i + 1 } + f_{ i -
1 } ) + 1\)</span>.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在<span class="math inline">\(u\)</span>,只要当前没有结束,我们还要选点<span class="math inline">\(v\)</span>,对答案的期望的贡献就是<span class="math inline">\(u\)</span>到这棵树上所有点的距离之和除以<span class="math inline">\(n\)</span>,而这是一个定值.也就是说,只要我们统计一下到了每个点<span class="math inline">\(u\)</span>多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设<span class="math inline">\(f_{ i , j , 0 / 1
}\)</span>表示当前场面上有<span class="math inline">\(i\)</span>个<span class="math inline">\(1\)</span>,<span class="math inline">\(j\)</span>号点这里是<span class="math inline">\(0\)</span>还是<span class="math inline">\(1\)</span>,它在结束前能被期望选多少次,注意<span class="math inline">\(f_{ n / 0 , j , 0 / 1 } =
0\)</span>.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设<span class="math inline">\(f_{ i , 0 / 1 }\)</span>表示当前有<span class="math inline">\(i\)</span>个<span class="math inline">\(1\)</span>,<span class="math inline">\(0 /
1\)</span>染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ 0 / n , 0 / 1 } &amp; = 0 \\
f_{ i , 0 } &amp; = \frac{ i }{ n } f_{ i - 1 , 0 } + \frac{ n - i - 1
}{ n } f_{ i + 1 , 0 } + \frac{ 1 }{ n } ( f_{ i + 1 , 1 } + [ i + 1 \ne
n ] ) \\
f_{ i , 1 } &amp; = \frac{ i - 1 }{ n } f_{ i - 1 , 1 } + \frac{ n - i
}{ n } f_{ i + 1 , 1 } + \frac{ 1 }{ n } ( f_{ i - 1 , 0 } + [ i - 1 \ne
0 ] )
\end{aligned}
\]</span></p>
<p>为啥最后加上了<span class="math inline">\([ i + 1 \ne n
]\)</span>呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了<span class="math inline">\(f_{ i , 0 / 1
}\)</span>和<span class="math inline">\(f_{ i - 1 , 0 / 1
}\)</span>,我们发现我们可以用这两个方程求出<span class="math inline">\(f_{ i + 1 , 0 / 1
}\)</span>,然后就比较典了:我们将所有的函数表示成<span class="math inline">\(af_{ 1 , 0 } + bf_{ 1 , 1 } +
c\)</span>的形式(之所以这么表示,是因为我们架设了<span class="math inline">\(f_{ 1 , 0 / 1
}\)</span>已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出<span class="math inline">\(f_{ n , 0 / 1 }\)</span>,而<span class="math inline">\(f_{ n , 0 / 1
}\)</span>我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3>
<h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4>
<p>首先注意到,<span class="math inline">\(a_i = 1\)</span>的时候和<span class="math inline">\(a_i \ne
1\)</span>的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设<span class="math inline">\(f_i\)</span>为<span class="math inline">\(a_i =
1\)</span>,而其他<span class="math inline">\(a\)</span>全都为<span class="math inline">\(0\)</span>时的答案,不难发现最后的答案也就是<span class="math inline">\(\sum{ a_i f_i }\)</span>.</p>
<p>而上面的转移自然是:<span class="math inline">\(f_i = \min \{ b_i , w
+ \sum_{ j = l }^r f_j \}\)</span>.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次<span class="math inline">\(f_i\)</span>最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查<span class="math inline">\(\log n\)</span>次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5>
<p>考虑组合意义,<span class="math inline">\(\sum
a_i^2\)</span>的意义也即满足操作序列<span class="math inline">\(u\)</span>和操作序列<span class="math inline">\(v\)</span>的最终结果相同的二元组<span class="math inline">\(( u , v )\)</span>的数量.</p>
<p>不妨设<span class="math inline">\(dp_{ i , j , k
}\)</span>为第一个装置上方已经动了<span class="math inline">\(i\)</span>个珠子,下放动了<span class="math inline">\(j\)</span>个珠子,第二个装置上方动了<span class="math inline">\(k\)</span>个珠子,下方动了<span class="math inline">\(i + j -
k\)</span>个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然<span class="math inline">\(dp_{ n , m , n }\)</span>即答案.</p>
<h5><span id="example2">Example2</span></h5>
<p>求长度为<span class="math inline">\(n\)</span>的排列的<span class="math inline">\(( \sum_{ i = 2 }^{ n - 1 } [ a_i &lt; a_{ i - 1 }
\And a_i &lt; a_{ i + 1 } ] )^k\)</span>的期望<span class="math inline">\(( n \leq 10^9 , k \leq 500 )\)</span>.</p>
<p><span class="math inline">\(O ( n^2 k^2
)\)</span>是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是<span class="math inline">\(\sum
ans^k\)</span>,而加入<span class="math inline">\(1\)</span>的时候,对于每个长度为<span class="math inline">\(n - 1\)</span>的排列,有<span class="math inline">\(( n - 2 - 2 ans
)\)</span>个位置加入后会使答案加一,那我们要求的也就是:</p>
<p><span class="math display">\[
\sum ( n - 1 - 2 ans ) ( ans + 1 )^k + \sum ( 2 ans + 2 ) ans^k
\]</span></p>
<p>推一推式子就可以做到<span class="math inline">\(O ( nk^2
)\)</span>,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,<span class="math inline">\(ans^k\)</span>等价于从所有的地方中可重复地选出<span class="math inline">\(k\)</span>个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为<span class="math inline">\(1\)</span>的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设<span class="math inline">\(f_{ i , j }\)</span>表示已经选了<span class="math inline">\(i\)</span>段波动序列,其中有<span class="math inline">\(j\)</span>个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度<span class="math inline">\(O ( k^3 )\)</span>.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \sum_{ j = 1 }^n ( a_i
\oplus a_j )^2\)</span>,<span class="math inline">\(n \leq
10^5\)</span>,<span class="math inline">\(a_i \leq 10^9\)</span>.</p>
<p>考虑设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>低的位置,高位全部默认为<span class="math inline">\(0\)</span>的方案数.如果我们设<span class="math inline">\(cnt_i\)</span>表示<span class="math inline">\(a\)</span>中第<span class="math inline">\(i\)</span>位为<span class="math inline">\(1\)</span>的数个数,那根据<span class="math inline">\(( a + b )^2 = a^2 + 2 ab +
b^2\)</span>,我们只需要求出<span class="math inline">\(g_{ i
}\)</span>表示只考虑前<span class="math inline">\(i\)</span>低的位置,第<span class="math inline">\(i
+ 1\)</span>位是<span class="math inline">\(1\)</span>的数和第<span class="math inline">\(i + 1\)</span>位是<span class="math inline">\(0\)</span>的数两两异或之和,显然有<span class="math inline">\(f_i = f_{ i - 1 } + 2 cnt_i \times 2^i \times g_{
i - 1 } + cnt_i 2^{ i + 1 }\)</span>.</p>
<p><span class="math inline">\(g\)</span>可以用<span class="math inline">\(O ( n \log a
)\)</span>的复杂度求,这样总复杂度<span class="math inline">\(O ( n
\log^2 a )\)</span>.</p>
<h3><span id="线头dp">线头dp</span></h3>
<h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5>
<p>令<span class="math inline">\(dp_{ i , j , k
}\)</span>表示目前倒到第<span class="math inline">\(i\)</span>个水杯,前面还有<span class="math inline">\(j\)</span>个延续过来的未结束的线头,目前已经选定了<span class="math inline">\(k\)</span>个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是<span class="math inline">\(O ( n^5
)\)</span>的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了<span class="math inline">\(O ( n^4 )\)</span>的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5>
<p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设<span class="math inline">\(dp_{ i , 0 / 1 / 2 }\)</span>表示前<span class="math inline">\(i\)</span>个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212svjetlo">Example3([COCI2020-2021#2]
Svjetlo)</span></h5>
<p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设<span class="math inline">\(dp_{ u , 0 / 1 , 1 / 2
}\)</span>为<span class="math inline">\(u\)</span>的状态为<span class="math inline">\(0 / 1\)</span>,以<span class="math inline">\(u\)</span>为根的子树内有<span class="math inline">\(1 / 2\)</span>个线头的方案数.注意如果子树内有<span class="math inline">\(0 / 2\)</span>个线头,那么会在<span class="math inline">\(u\)</span>处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此<span class="math inline">\(dp_{ u , s , 2
}\)</span>的两个接头实际上一个位于<span class="math inline">\(u\)</span>,另一个位于<span class="math inline">\(u\)</span>的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5>
<p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设<span class="math inline">\(dp_{ i , j , k
}\)</span>表示目前走到<span class="math inline">\(i\)</span>,前面分成<span class="math inline">\(j\)</span>组,总贡献不超过<span class="math inline">\(k\)</span>的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489-jtravel-in-sugar-country">Example5([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489) J]Travel in Sugar Country)</span></h5>
<p>一条线段上有<span class="math inline">\(n ( \leq 100
)\)</span>个商店,要从中选出<span class="math inline">\(k ( \leq 10
)\)</span>个不同的商店<span class="math inline">\(s_1 , s_2 , \cdots ,
s_k\)</span>,使得按顺序遍历这<span class="math inline">\(k\)</span>个商店的路径长度是<span class="math inline">\(m ( \leq 30 )\)</span>的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设<span class="math inline">\(dp_{ i , j , w , l
}\)</span>表示目前在判断了<span class="math inline">\(i\)</span>个商店,选了<span class="math inline">\(j\)</span>个,并且目前整个图有<span class="math inline">\(w\)</span>条”路径”(连续走动),走过的路在<span class="math inline">\(\bmod m\)</span>一意义下为<span class="math inline">\(l\)</span>的方案数.最后的答案就是<span class="math inline">\(dp_{ n , k , 1 , 0 }\)</span>.</p>
<p>首先,我们对每个点求出<span class="math inline">\(D ( 1 , x
)\)</span>,然后<span class="math inline">\(D ( x , y ) = | D ( 1 , y ) -
D ( 1 , x ) |\)</span>,不难发现<span class="math inline">\(x\)</span>越大<span class="math inline">\(D ( 1 ,
x
)\)</span>越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的<span class="math inline">\(D\)</span>和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径(<span class="math inline">\(s_1 \rightarrow
s_1\)</span>),接下来,我们每插入一个点<span class="math inline">\(x\)</span>,我们考虑它的贡献:</p>
<ol type="1">
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是<span class="math inline">\(- 2 D ( 1 , x )\)</span>,对方案数的贡献为<span class="math inline">\(1\)</span>.</p></li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为<span class="math inline">\(0\)</span>.</p></li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为<span class="math inline">\(2 D ( 1 , x )\)</span>.</p></li>
</ol>
<p>这样我们就做到了<span class="math inline">\(O ( n^4 km
)\)</span>的复杂度.如果我们加两维<span class="math inline">\(0 /
1\)</span>表示目前起点和终点是否加入,就可以把复杂度优化到<span class="math inline">\(O ( n^2 km )\)</span>.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3>
<p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4>
<p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3>
<p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4>
<p>先考虑数字两两不同的时候怎么做,我们先找到<span class="math inline">\(A\)</span>中的全局最大值所在位置和<span class="math inline">\(B\)</span>中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时<span class="math inline">\(A\)</span>取出的数量和<span class="math inline">\(B\)</span>的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把<span class="math inline">\(B\)</span>序列分成两部分,这两部分将由<span class="math inline">\(A\)</span>中相等的两部分分别生成.不妨假设这个全局最大值的位置是<span class="math inline">\(x\)</span>,那么对于<span class="math inline">\([ 1
, x ]\)</span>这一段的<span class="math inline">\(A\)</span>生成的<span class="math inline">\(B\)</span>数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的<span class="math inline">\(A\)</span>能生成的<span class="math inline">\(B\)</span>的数量.对于<span class="math inline">\([
1 , x + 1 ]\)</span>则任意.</p>
<p>那么我们所需要做的就是求出<span class="math inline">\(A\)</span>的某一段删掉若干次最大值后的序列所能生成的<span class="math inline">\(B\)</span>的数量.不妨设<span class="math inline">\(dp_{ l , r , i }\)</span>表示<span class="math inline">\([ l , r ]\)</span>中所有<span class="math inline">\(\leq i\)</span>的数字组成的序列所能生成的数量.</p>
<p>如果<span class="math inline">\([ l , r
]\)</span>这段区间中没有数字<span class="math inline">\(i\)</span>,那显然<span class="math inline">\(dp_{
l , r , i } = dp_{ l , r , i - 1
}\)</span>,不然,我们可以枚举两端分开的位置,那这个位置一定在数字<span class="math inline">\(i\)</span>的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4>
<p>注意到第<span class="math inline">\(n\)</span>个元素一定是山峰.所以我们考虑用第<span class="math inline">\(n\)</span>个元素分割整个区间为两部分.</p>
<p>设<span class="math inline">\(f_n\)</span>为<span class="math inline">\(n\)</span>个元素且开头为山谷的答案.枚举第<span class="math inline">\(n\)</span>个元素在位置<span class="math inline">\(k\)</span>(<span class="math inline">\(k -
1\)</span>是奇数),则<span class="math inline">\(f_k f_{ n - 1 - k }
\binom{ n - 1 }{ k } \rightarrow f_n\)</span>.</p>
<h4><span id="example3">Example3</span></h4>
<p>给定数组<span class="math inline">\(a\)</span>,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.<span class="math inline">\(n \leq 500\)</span>.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设<span class="math inline">\(f_{ l , r }\)</span>为将<span class="math inline">\([ l , r ]\)</span>删干净后再去删<span class="math inline">\(a_{ l - 1 } , a_{ r + 1
}\)</span>的方案数,然后枚举<span class="math inline">\([ l , r
]\)</span>中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairingpoints">Example4([AGC039E] Pairing
Points)</span></h4>
<p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从<span class="math inline">\(1\)</span>号点这里断开,枚举<span class="math inline">\(1\)</span>号点连接哪个点,然后就可以让<span class="math inline">\(( 2 , 2 n )\)</span>这些点断开了.我们设计<span class="math inline">\(f_{ i , j , k }\)</span>或<span class="math inline">\([ i , j ] ( k )\)</span>表示区间<span class="math inline">\([ i , j ]\)</span>中的<span class="math inline">\(k\)</span>向外连了一条边.答案是枚举<span class="math inline">\(1\)</span>号点连了哪个点,也就是<span class="math inline">\(\sum_{ i = 3 }^{ 2 n - 1 } f_{ 2 , 2 n , i
}\)</span>.</p>
<p>于是我们现在的问题在于如何求<span class="math inline">\(f_{ i , j , k
}\)</span>.由于边要联通,所以与<span class="math inline">\(k\)</span>相连的这条边必然被<span class="math inline">\([ i , j
]\)</span>中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为<span class="math inline">\(x \leftrightarrow
y\)</span>.这样整个区间被分为了两个部分:<span class="math inline">\([ i
, k ] ( x ) , [ k , j ] ( y )\)</span>.但是问题并没有得到解决.因为<span class="math inline">\([ i , x ]\)</span>和<span class="math inline">\([
y , j ]\)</span>之间的确不可能出现连边了,但<span class="math inline">\([
x , k ]\)</span>和<span class="math inline">\([ k , y
]\)</span>之间仍然可能出现连边.但我们发现:在<span class="math inline">\([ i , k
]\)</span>中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为<span class="math inline">\(p
, q\)</span>.现在整个区间被分为了三个部分:<span class="math inline">\([
i , p ] ( x ) , [ p , q ] ( k ) , [ q , j ] ( y
)\)</span>,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-andremove">Example5([AGC035D] Add and
Remove)</span></h4>
<p>首先自然想到区间dp.但是难以处理的是如果一个区间<span class="math inline">\([ l , r ]\)</span>中间删掉一个点<span class="math inline">\(p\)</span>之后,<span class="math inline">\([ l , p
- 1 ]\)</span>和<span class="math inline">\([ p + 1 , r
]\)</span>会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到<span class="math inline">\([ l + 1 , r - 1
]\)</span>中最后删除的点<span class="math inline">\(p\)</span>,这样区间<span class="math inline">\([ l
, r
]\)</span>的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除<span class="math inline">\([ l + 1 , p - 1 ]\)</span>的时候,对<span class="math inline">\(p\)</span>产生的贡献和删除<span class="math inline">\([ p + 1 , r - 1 ]\)</span>的时候对<span class="math inline">\(p\)</span>的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设<span class="math inline">\(a_l\)</span>贡献了<span class="math inline">\(x\)</span>倍,<span class="math inline">\(a_r\)</span>贡献了<span class="math inline">\(y\)</span>倍,那么由于<span class="math inline">\(a_p\)</span>会两边都贡献到,所以<span class="math inline">\(a_p\)</span>会对答案贡献<span class="math inline">\(x + y\)</span>倍.</p>
<p>于是设计一个dp是:<span class="math inline">\(f_{ l , r , x , y
}\)</span>表示删除<span class="math inline">\([ l + 1 , r - 1
]\)</span>后,<span class="math inline">\(xa_l +
ya_r\)</span>最小是多少.自然有<span class="math inline">\(f_{ l , r , x
, y } = \min \{ f_{ l , p , x , x + y } + f_{ p , r , x + y , y } + ( x
+ y ) a_p \}\)</span>.</p>
<p>至于复杂度,前两维肯定是<span class="math inline">\(n^2\)</span>的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移<span class="math inline">\(n\)</span>层,因此是<span class="math inline">\(2^n\)</span>的空间,于是时间复杂度不会超过<span class="math inline">\(O ( n^3 2^n
)\)</span>,其实经过一些奇怪计算应该是不会超过<span class="math inline">\(O ( 2^n )\)</span>的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4>
<p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设<span class="math inline">\(f_{ l , r
}\)</span>表示删除<span class="math inline">\([ l , r
]\)</span>区间的代价.接下来我们无非要枚举<span class="math inline">\(k\)</span>,使得<span class="math inline">\(k\)</span>是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如<span class="math inline">\(l\)</span>,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果<span class="math inline">\(a_l = a_k\)</span>,那么这等价于<span class="math inline">\(f_{ l + 1 , k - 1 } + [ l = k - 1 ] + f_{ k + 1 ,
r }\)</span>.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4>
<p>首先考虑一下<span class="math inline">\(m = 2^k -
1\)</span>的情况,首先我们要判断有几个数最高位是<span class="math inline">\(1\)</span>,然后接下来判断第二位哪些数字是<span class="math inline">\(1\)</span>.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是<span class="math inline">\(1\)</span>的就一定大于最高位是<span class="math inline">\(0\)</span>的了,这两个区间就没有影响了.因此可以设<span class="math inline">\(f_{ l , r , k }\)</span>表示<span class="math inline">\([ l , r ]\)</span>这个区间,前面已经有了<span class="math inline">\(k\)</span>个<span class="math inline">\(1\)</span>的最大贡献.</p>
<p>那么对于<span class="math inline">\(m \ne 2^k -
1\)</span>的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过<span class="math inline">\(m\)</span>就行了.</p>
<h3><span id="相互独立">相互独立</span></h3>
<h5><span id="example12019zrtg十连测day1origami">Example1(2019zrtg十连测day1
origami)</span></h5>
<p>看上去很不好做,先考虑宽为<span class="math inline">\(1\)</span>怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间<span class="math inline">\([ l , r ]\)</span>,然后看<span class="math inline">\([ 1 , l - 1 ]\)</span>和<span class="math inline">\([ r + 1 , m
]\)</span>能不能折进来.也就是判断以<span class="math inline">\(r\)</span>和<span class="math inline">\(r +
1\)</span>为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设<span class="math inline">\(f_i\)</span>表示能不能折成以<span class="math inline">\([ 1 , i ]\)</span>为最下层,<span class="math inline">\(g_i\)</span>表示能不能折成<span class="math inline">\([ i , n ]\)</span>为最下层,那<span class="math inline">\([ l , r ]\)</span>能折出来当且仅当<span class="math inline">\(f_r = g_l =
1\)</span>,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-anedge">Example2(CF1616G Just Add an
Edge)</span></h5>
<p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如<span class="math inline">\(1 \rightarrow x
\cup y \rightarrow n\)</span>,并且<span class="math inline">\(1
\rightarrow x\)</span>和<span class="math inline">\(y \rightarrow
n\)</span>不交,然后添加边<span class="math inline">\(x \rightarrow
y\)</span>.</p>
<p>那么什么时候<span class="math inline">\(1 \rightarrow
x\)</span>和<span class="math inline">\(y \rightarrow
n\)</span>没有交并且他们的并是<span class="math inline">\([ 1 , n
]\)</span>呢?考虑将<span class="math inline">\(1 \rightarrow
x\)</span>这条路径上的点染色为<span class="math inline">\(0\)</span>,<span class="math inline">\(y
\rightarrow n\)</span>上的点染色为<span class="math inline">\(1\)</span>,由于边只有从前往后的,因此<span class="math inline">\([ 1 , y - 1 ]\)</span>必然为<span class="math inline">\(0\)</span>,<span class="math inline">\([ x + 1 , n
]\)</span>必然为<span class="math inline">\(1\)</span>.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了<span class="math inline">\(y\)</span>,现在想要找到<span class="math inline">\(x\)</span>,我们现在假设染色的末尾是<span class="math inline">\(( i , i + 1 )\)</span>,也就是<span class="math inline">\(i\)</span>染色和<span class="math inline">\(i +
1\)</span>的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个<span class="math inline">\(p\)</span>,满足<span class="math inline">\(p
\nrightarrow p + 1\)</span>,那么<span class="math inline">\(p\)</span>和<span class="math inline">\(p +
1\)</span>永远不可能染同种颜色,我们直接以它为断点,自然发现<span class="math inline">\(p\)</span>的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了<span class="math inline">\(p \rightarrow p +
1\)</span>这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立<span class="math inline">\(0\)</span>和<span class="math inline">\(n +
1\)</span>两个虚点,向所有点连边.</p>
<p>总之<span class="math inline">\(O ( nm
)\)</span>的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3>
<p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5>
<p>首先考虑已知一个序列,如何快速求它最后有几个位置不是<span class="math inline">\(0\)</span>.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其<span class="math inline">\(- 1\)</span>并重复判断操作,直到为<span class="math inline">\(0\)</span>或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是<span class="math inline">\(0\)</span>相当于判断后面的已知序列的<span class="math inline">\(mex\)</span>,这个要记入状态中,于是考虑设<span class="math inline">\(dp_{ i , j }\)</span>表示当前到了第<span class="math inline">\(i\)</span>个位置,后面的数的<span class="math inline">\(mex - 1\)</span>是<span class="math inline">\(j\)</span>的方案数.</p>
<p>但是如果直接这么设会发现,当前<span class="math inline">\(i\)</span>的加入有可能会改变<span class="math inline">\(mex\)</span>的值,而这个改变是很难处理的,因为如果<span class="math inline">\(i\)</span>位置选择了<span class="math inline">\(j
+ 1\)</span>这个数字,那么<span class="math inline">\(mex\)</span>要向上伸展到某一个值,而如果不选择<span class="math inline">\(j +
1\)</span>,也有可能选择一个更大的值后不断落到<span class="math inline">\(j + 1\)</span>,这意味着我们转移时需要枚举补上<span class="math inline">\(j + 1\)</span>这个数字后的<span class="math inline">\(mex\)</span>并用刷表法转移.</p>
<p>不妨设这个数字是<span class="math inline">\(k\)</span>.如果我们插入一个数字后直接更新当前的答案,可以发现这个<span class="math inline">\(k\)</span>是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起<span class="math inline">\(mex\)</span>的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全<span class="math inline">\([ j + 2 , k ]\)</span>这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以<span class="math inline">\(2^{ n }\)</span>.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5>
<p><span class="math inline">\(O ( n^3 )\)</span>的暴力是显然的:设<span class="math inline">\(f_{ i , j , k }\)</span>表示目前考虑到第<span class="math inline">\(i\)</span>个位置,前面还有<span class="math inline">\(j\)</span>个A,已经选了<span class="math inline">\(k\)</span>个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到<span class="math inline">\(n^2\)</span>.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设<span class="math inline">\(f_{ i , j }\)</span>表示目前考虑到<span class="math inline">\(i\)</span>,还需要<span class="math inline">\(j\)</span>个B才能凑齐<span class="math inline">\(c_B\)</span>个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3>
<h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5>
<p>设<span class="math inline">\(f_{ i , j }\)</span>表示长度为<span class="math inline">\(i\)</span>,开头为山峰且高度为<span class="math inline">\(j\)</span>的方案数;<span class="math inline">\(g_{
i , j }\)</span>表示长度为<span class="math inline">\(i\)</span>,开头为山谷且高度为<span class="math inline">\(j\)</span>的方案数.注意到这俩显然是一个双射,也就是<span class="math inline">\(f_{ i , j } = g_{ i , i - j + 1 }\)</span>.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于<span class="math inline">\(j\)</span>的数都向上平移一格,于是自然有:<span class="math inline">\(f_{ i , j } = \sum_{ k = 1 }^{ j - 1 } g_{ i - 1 ,
k } = \sum_{ k = 1 }^{ j - 1 } f_{ i - 1 , i - k }\)</span>.</p>
<p>另外,这个式子可以稍微转化为:<span class="math inline">\(f_{ i , j } =
f_{ i - 1 , i - j + 1 } + f_{ i , j - 1 } = g_{ i - 1 , j - 1 } + f_{ i
, j - 1 }\)</span>.</p>
<p>上式可以这么理解:我们讨论一下<span class="math inline">\(j\)</span>和<span class="math inline">\(j -
1\)</span>是否相邻,如果相邻必然是<span class="math inline">\(j\)</span>是山峰,<span class="math inline">\(j -
1\)</span>是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1group">Example2(2019zrtg十连测day1
group)</span></h5>
<p>首先注意到<span class="math inline">\(2 k \leq n \land nk \leq
10^5\)</span>,不难发现<span class="math inline">\(k \leq
500\)</span>.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到<span class="math inline">\(O ( nk^2
)\)</span>.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点<span class="math inline">\(w\)</span>,使得成为组长的经验<span class="math inline">\(\geq w\)</span>,成为组员的经验<span class="math inline">\(\leq w\)</span>,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5>
<p>双序列计数,考虑把<span class="math inline">\(x\)</span>双射到某个东西上.</p>
<p>考虑最后的图一定是个<span class="math inline">\(DAG\)</span>,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设<span class="math inline">\(dp_{ l , r , mx
}\)</span>表示只考虑<span class="math inline">\([ l , r
]\)</span>这一段的线段,然后最大值所在位置需要<span class="math inline">\(\geq
mx\)</span>的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3>
<p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweightedincreasing-subsequences">Example1([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<h2><span id="动态规划的优化">动态规划的优化</span></h2>
<h3><span id="递进转移">递进转移</span></h3>
<p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5>
<p>有<span class="math inline">\(m\)</span>种礼物,每种礼物有无数个(有有限个也能做),<span class="math inline">\(n\)</span>个朋友,第<span class="math inline">\(i\)</span>个朋友喜欢第<span class="math inline">\(j\)</span>个礼物的概率是<span class="math inline">\(p_{ i , j }\)</span>,<span class="math inline">\(\forall i , \sum p_{ i , j } = 1\)</span>.</p>
<p>现在你可以选<span class="math inline">\(n\)</span>件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p><span class="math inline">\(n \leq 3000 , m \leq 300\)</span>.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出<span class="math inline">\(g_{ i , j }\)</span>表示第<span class="math inline">\(i\)</span>种礼物一共选了<span class="math inline">\(j\)</span>个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么<span class="math inline">\(g\)</span>怎么求呢?这个是简单的,我们设<span class="math inline">\(f_{ i , j }\)</span>表示喜欢第<span class="math inline">\(i\)</span>种礼物的人有<span class="math inline">\(j\)</span>个的概率,不难发现<span class="math inline">\(g_{ i , j } = \sum_{ k = 0 }^n \min \{ j , k \}
f_{ i , k }\)</span>.递推式就有<span class="math inline">\(g_{ i , j } =
g_{ i , j - 1 } + \sum_{ k = j }^n f_{ i , k }\)</span>.<span class="math inline">\(f\)</span>同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是<span class="math inline">\(O ( n^2 m
)\)</span>的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现<span class="math inline">\(g_{ i , j
}\)</span>满足四边形不等式,而其转移是经典的<span class="math inline">\(k\)</span>点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于<span class="math inline">\(g_i\)</span>是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为<span class="math inline">\(c_i\)</span>,每次选当前<span class="math inline">\(g_{ i , c_i + 1 } - g_{ i , c_i
}\)</span>最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为<span class="math inline">\(c_i\)</span>越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度<span class="math inline">\(O ( n^2 \log n )\)</span>,不太确定有没有<span class="math inline">\(O ( n^2 )\)</span>的做法.</p>
<p>但是第二个背包,也就是<span class="math inline">\(f\)</span>怎么求呢?我们发现我们没有必要把<span class="math inline">\(g\)</span>全都求出来,只需要求目前需要的一部分就可以了,由于<span class="math inline">\(\sum f =
1\)</span>,因此后缀和可以改为前缀和,考虑到每往后推一位是<span class="math inline">\(O ( n )\)</span>的,但是只会往后推总共<span class="math inline">\(O ( n )\)</span>位,因此这里复杂度<span class="math inline">\(O ( n^2 )\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>给一个字符串,求一个最大长度<span class="math inline">\(L \leq \frac{
n }{ 2 }\)</span>,使得前<span class="math inline">\(L\)</span>个字符与后<span class="math inline">\(L\)</span>个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<p><span class="math display">\[
ABSBA
\]</span></p>
<p>我们枚举<span class="math inline">\(A\)</span>的长度,然后就只需要求<span class="math inline">\(B\)</span>,设<span class="math inline">\(f_{ i
}\)</span>表示字符串去掉开头和结尾的<span class="math inline">\(i\)</span>个字符后的border,有<span class="math inline">\(f_{ i - 1 } \leq f_i +
1\)</span>.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3>
<p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个<span class="math inline">\(k\)</span>暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取<span class="math inline">\(\max\)</span>操作很艰难.但如果!我把这个dp反过来,我设<span class="math inline">\(f_{ i , j
}\)</span>表示<strong>从后往前</strong>dp到<span class="math inline">\(i\)</span>,当前的最大前缀和是<span class="math inline">\(j\)</span>的概率是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f_{ i , j } \rightarrow f_{ i - 1 , \max \{ 0 , j + a_{ i - 1 }
\} }
\]</span></p>
<p>最后在<span class="math inline">\(f_{ 1 , j }\)</span>处乘上<span class="math inline">\(h_j\)</span>.</p>
<p>但是这样是<span class="math inline">\(O ( n^3
)\)</span>的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设<span class="math inline">\(g_{ i , j
}\)</span>表示如果初始只有<span class="math inline">\(f_{ i , j } =
1\)</span>,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{aligned}
P \times g_{ i - 1 , \max \{ 0 , j + a_{ i - 1 } \} } &amp; \rightarrow
g_{ i , j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我认真考虑过这个<span class="math inline">\(P\)</span>应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些<span class="math inline">\(P\)</span>变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3>
<h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4>
<p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于<span class="math inline">\(200\)</span>.也就是说转移矩阵大概是<span class="math inline">\(200 \times 200\)</span>的,设状态数为<span class="math inline">\(S\)</span>.</p>
<p>继续考虑,如果直接做的话复杂度是<span class="math inline">\(O ( TS^3
\log n )\)</span>,过不了.</p>
<p>我们考虑将一个<span class="math inline">\(n\)</span>在<span class="math inline">\(w\)</span>进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了<span class="math inline">\(O ( wS^3 \log_w n + TS^2 \log_w n
)\)</span>,平衡一下复杂度即可,大概取<span class="math inline">\(w =
4\)</span>会比较优秀.</p>
<h4><span id="example2noionline3提高组魔法值">Example2([NOI
Online#3提高组]魔法值)</span></h4>
<p>重新定义矩阵乘法:用<span class="math inline">\(\oplus\)</span>替换原本的<span class="math inline">\(+\)</span>,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4>
<p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令<span class="math inline">\(f_i = \sum_{ j , a_j = a_i
- 1 }
f_j\)</span>,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的<span class="math inline">\(\sum\)</span>的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的<span class="math inline">\(f\)</span>.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设<span class="math inline">\(f_{ i , j }\)</span>表示所有<span class="math inline">\(a_x = i\)</span>的<span class="math inline">\(x\)</span>中第<span class="math inline">\(j\)</span>小的<span class="math inline">\(x\)</span>的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4>
<p>注意到<span class="math inline">\(m\)</span>和<span class="math inline">\(k\)</span>很小,这一定是突破口.</p>
<p>又注意到如果<span class="math inline">\(a_{ i + 1 } &gt;
a_i\)</span>,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字<span class="math inline">\(x + 1\)</span>,我们考虑它只能插入<span class="math inline">\([ x + 1 - m , x
]\)</span>后面,我们直接用一个二进制数<span class="math inline">\(S\)</span>表示<span class="math inline">\([ x + 1
- m , x ]\)</span>中的数字是否存在,然后就可以在转移上直接调用<span class="math inline">\(popcount ( S )\)</span>.设<span class="math inline">\(dp_{ i , j , S }\)</span>表示目前考虑完了数字<span class="math inline">\(i\)</span>,插入了<span class="math inline">\(j\)</span>个数字,存在情况是<span class="math inline">\(S\)</span>.直接对它做矩阵加速就可以做到<span class="math inline">\(O ( ( 2^m k )^3 \log n )\)</span>.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4>
<p>设<span class="math inline">\(dp_{ i , j }\)</span>表示第<span class="math inline">\(i\)</span>天走到城市<span class="math inline">\(j\)</span>的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上<span class="math inline">\(k\)</span>.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3>
<p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4>
<p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设<span class="math inline">\(f_{ l , r }\)</span>表示<span class="math inline">\(a_l\)</span>和<span class="math inline">\(a_r\)</span>必选的前提下,<span class="math inline">\([ l , r ]\)</span>这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设<span class="math inline">\(dp_{ i , j }\)</span>表示前<span class="math inline">\(i\)</span>个点,最大值为<span class="math inline">\(j\)</span>的方案数,不难发现最后一个矩阵的最小值一定是<span class="math inline">\(a_{ i }\)</span>.然后<span class="math inline">\(dp_{ a , b } = \sum_{ i &lt; a , j &lt; b } dp_{ i
, j } f_{ i + 1 , a }\)</span>.</p>
<p>这个转移是<span class="math inline">\(n^4\)</span>的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到<span class="math inline">\(n^2\)</span>,这样我们就得到了一个复杂度<span class="math inline">\(O ( n^3 )\)</span>的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点<span class="math inline">\(i\)</span>,它所在矩阵的最左边的点<span class="math inline">\(k\)</span>,最右边的点<span class="math inline">\(k\)</span>,然后此时的答案为<span class="math inline">\(pre [ j - 1 ] [ a [ k ] - 1 ] \times nxt [ k + 1 ]
[ a [ j ] + 1 ] \times f [ j ] [ i ] \times f [ i ] [ k ]\)</span>.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设<span class="math inline">\(g_{ i , j
}\)</span>为接下来我们要选<span class="math inline">\([ i , j
]\)</span>,<span class="math inline">\(i\)</span>是矩阵左端点,<span class="math inline">\(j\)</span>任意且这两个点必在矩阵中,左右两边的方案数.初始条件<span class="math inline">\(g_{ i , j } = pre [ i - 1 ] [ a [ j ] - 1 ] \times
nxt [ j + 1 ] [ a [ i ] + 1 ]\)</span>.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3>
<h4><span id="example2022zrtg十连测day7zero">Example(2022zrtg十连测day7
Zero)</span></h4>
<p>设<span class="math inline">\(k = \max \{ i , j
\}\)</span>,首先可以求出<span class="math inline">\(x , y ,
z\)</span>分别表示:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>:只包含第一行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(- 1\)</span>.</p></li>
<li><p><span class="math inline">\(y\)</span>:只包含第二行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(- 1\)</span>.</p></li>
<li><p><span class="math inline">\(z\)</span>:同时包含两行的格子的以<span class="math inline">\(k\)</span>为右端点的和为<span class="math inline">\(0\)</span>的最小矩形的左端点<span class="math inline">\(- 1\)</span>.</p></li>
</ol>
<p>那么自然有转移:</p>
<p><span class="math display">\[
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z
, z ) + 1 \}
\end{gathered}
\]</span></p>
<p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到<span class="math inline">\(f ( i , k )\)</span>关于<span class="math inline">\(i\)</span>不降,于是显然当<span class="math inline">\(f ( i , y ) \ne f ( i , k - 1
)\)</span>的时候才会由<span class="math inline">\(f ( i , y ) +
1\)</span>转移过来.我们不妨设<span class="math inline">\(p_i\)</span>表示最小的位置满足<span class="math inline">\(f ( i , p_i ) = f ( i , k - 1
)\)</span>,那转移也就是<span class="math inline">\(f ( i , k )
\leftarrow f ( i , k - 1 ) + [ p_i \leq y
]\)</span>.并且每进行一次转移,都会满足<span class="math inline">\(p_i
\leq y\)</span>的<span class="math inline">\(p_i\)</span>设为<span class="math inline">\(k\)</span>.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的<span class="math inline">\(i\)</span>在当前<span class="math inline">\(k\)</span>的<span class="math inline">\(f\)</span>值,将这个点放到<span class="math inline">\(p_i\)</span>位置上.然后我们每次找到<span class="math inline">\(y\)</span>并把所有在<span class="math inline">\(y\)</span>位置前的点都合并到<span class="math inline">\(k\)</span>这个点上,并打一个加法<span class="math inline">\(tag\)</span>,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的<span class="math inline">\(p_k\)</span>.</p>
<p>最后还需要处理一下<span class="math inline">\(f_{ k , k
}\)</span>,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照<span class="math inline">\(\max \{ i , j
\}\)</span>为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3>
<p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5>
<p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是<span class="math inline">\(\nexists 1 \leq i &lt; j &lt; k \leq
n\)</span>,<span class="math inline">\(a_i &gt; a_j &gt;
a_k\)</span>.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是<span class="math inline">\(dp_{ i , j }\)</span>表示现在做到<span class="math inline">\(i\)</span>,另一个上升子序列的终点是<span class="math inline">\(j\)</span>,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在<span class="math inline">\(i\)</span>一定的情况下,<span class="math inline">\(j\)</span>的值越小越容易满足.所以设<span class="math inline">\(dp_i\)</span>表示一个上升子序列的终点是<span class="math inline">\(i\)</span>,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5>
<p>首先自然的设计是<span class="math inline">\(dp_{ l , r , u , d
}\)</span>,然后优化一下就是<span class="math inline">\(O ( n^4
)\)</span>.然后咋做?</p>
<p>注意到答案不超过<span class="math inline">\(\log\)</span>级别,所以设<span class="math inline">\(dp_{ l , r , u , c }\)</span>表示答案为<span class="math inline">\(c\)</span>的时候,最大的<span class="math inline">\(d\)</span>是多少.然后就<span class="math inline">\(O ( n^3 \log n )\)</span>.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数<span class="math inline">\(a_i\)</span>减去<span class="math inline">\([ 1 ,
a_i ]\)</span>中的一个数字,减成<span class="math inline">\(0\)</span>就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.<span class="math inline">\(( n \leq 2000 )\)</span></p>
<p>先考虑一个<span class="math inline">\(O ( n^2 a^2
)\)</span>的dp,比较显然,因为一个人取数显然要么取<span class="math inline">\(1\)</span>要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设<span class="math inline">\(dp_{ l , r , x , y
}\)</span>表示目前Alice在取第<span class="math inline">\(l\)</span>堆,Bob在取第<span class="math inline">\(r\)</span>堆,第<span class="math inline">\(l\)</span>堆为<span class="math inline">\(x\)</span>,第<span class="math inline">\(r\)</span>堆为<span class="math inline">\(y\)</span>的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把<span class="math inline">\(a\)</span>存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是<span class="math inline">\(1\)</span>还是更大的数好像无所谓.那:如果<span class="math inline">\(a_1 = x\)</span>的时候,Alice能赢,那<span class="math inline">\(a_1 = x +
1\)</span>的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选<span class="math inline">\(1\)</span>,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于<span class="math inline">\(a_l\)</span>或<span class="math inline">\(a_r\)</span>.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存<span class="math inline">\(0 /
1\)</span>是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设<span class="math inline">\(dp_{ l , r
}\)</span>表示当前Alice在<span class="math inline">\(l\)</span>,Bob在<span class="math inline">\(r\)</span>,Bob还没动<span class="math inline">\(a_r\)</span>的前提下,<span class="math inline">\(a_l\)</span>至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较<span class="math inline">\(dp_{ 1 , 1 }\)</span>和<span class="math inline">\(a_1\)</span>的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选<span class="math inline">\(l\)</span>,Bob开始选<span class="math inline">\(r\)</span>,那Alice的获胜条件显然是<span class="math inline">\(dp_{ l , r } \leq a_r\)</span></p>
<p>如果可以全选(也就是Alice开始选<span class="math inline">\(l +
1\)</span>,Bob开始选<span class="math inline">\(r\)</span>的时候Alice能赢),就直接让<span class="math inline">\(dp_{ l , r } =
1\)</span>.不然,由于清空堆的人要输,所以Alice为了不输,必须要让<span class="math inline">\(dp_{ l , r - 1
}\)</span>也满足条件,一个自然的想法是<span class="math inline">\(dp_{ l
, r - 1 } + a_r +
1\)</span>,但是这个值好像没有必要:因为Bob并不是只有会不断清空<span class="math inline">\(a_r\)</span>的,如果目前的<span class="math inline">\([ l + 1 , r
]\)</span>这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢<span class="math inline">\([ l + 1 , r
]\)</span>的值,Bob就必须全清空,所以如果我们设<span class="math inline">\(g_{ l , r }\)</span>是Bob的<span class="math inline">\(dp\)</span>数组,那其实这里应该是<span class="math inline">\(a_r + 1 + dp_{ l , r - 1 } - g_{ l + 1 , r
}\)</span>,因为Bob的策略一定是一步一步走到<span class="math inline">\(g_{ l + 1 , r
}\)</span>后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5>
<p>自然的想法是<span class="math inline">\(dp_{ i , j
}\)</span>表示<span class="math inline">\(i\)</span>子树内划分成<span class="math inline">\(j\)</span>个连通块是否合法,然后我们发现如果<span class="math inline">\(j\)</span>满足条件,那么<span class="math inline">\(j + 2\)</span>一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3>
<p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于<span class="math inline">\(y\)</span>轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5>
<p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3>
<p>能用WQS二分解决的问题通常形如:需要在<span class="math inline">\(n\)</span>个物品中选择恰好<span class="math inline">\(m\)</span>个,使得最后答案最大.并且如果令<span class="math inline">\(f_i\)</span>表示选了<span class="math inline">\(i\)</span>个的最大答案,<span class="math inline">\(f_i\)</span>必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数<span class="math inline">\(C\)</span>,每选择一个物品就减去<span class="math inline">\(C\)</span>的答案.不难发现这样我们一定能逼近<span class="math inline">\(f_m\)</span>.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3>
<p>对于定义在<span class="math inline">\(\mathbb{ Z
}\)</span>上的二元函数<span class="math inline">\(w\)</span>,若对定义域上任意<span class="math inline">\(a , b , c , d ( a \leq b \leq c \leq d
)\)</span>都有<span class="math inline">\(w ( a , c ) + w ( b , d ) \leq
w ( a , d ) + w ( b , c )\)</span>,也就是交叉小于包含,则称函数<span class="math inline">\(w\)</span>满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:<span class="math inline">\(w\)</span>所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于<span class="math inline">\(0\)</span>.</p>
<p>如果它还满足<span class="math inline">\(\forall 1 \leq l &#39; \leq l
\leq r \leq r &#39; \leq n , w ( l , r ) \leq w ( l &#39; , r &#39;
)\)</span>，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理<span class="math inline">\(\min\)</span>型dp的问题,对于<span class="math inline">\(\max\)</span>型dp需要取相反数改成<span class="math inline">\(\min\)</span>.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p>若二元函数<span class="math inline">\(w ( x , y )\)</span>满足<span class="math inline">\(w ( a , b ) + w ( a + 1 , b + 1 ) \leq w ( a , b +
1 ) + w ( a + 1 , b )\)</span>.其中<span class="math inline">\(a &lt; a
+ 1 \leq b &lt; b + 1\)</span>,则<span class="math inline">\(w\)</span>满足四边形不等式.</p>
<p>证明:</p>
<p>对于<span class="math inline">\(a + 1 &lt; c\)</span> 有</p>
$$
<span class="math display">\[\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1
, c ) \\
w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a
, c ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>同时有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) &amp; \leq w ( a + 1 , c + 1 ) + w
( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
+ 1 , c + 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
<p><span class="math display">\[
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
, c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) &amp; \leq w ( a + 1 , c ) + w ( a + 2
, c + 1 )
\end{aligned}
\]</span></p>
<p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个<span class="math inline">\(2 \times
2\)</span>的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5>
<p>若<span class="math inline">\(w_1 ( l , r ) , w_2 ( l , r
)\)</span>满足四边形不等式(或区间包含单调性),则<span class="math inline">\(\forall c_1 , c_2 \geq 0\)</span>,<span class="math inline">\(( c_1 w_1 + c_2 w_2
)\)</span>满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若<span class="math inline">\(\exists f ( x ) , g ( x
)\)</span>使得<span class="math inline">\(w ( l , r ) = f ( r ) - g ( l
)\)</span>,则<span class="math inline">\(w\)</span>满足四边形恒等式.当<span class="math inline">\(f , g\)</span>单调递增时,<span class="math inline">\(w\)</span>还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>设<span class="math inline">\(h\)</span>是一个单调递增的下凸函数(一阶导数单调递增),若<span class="math inline">\(w ( l , r
)\)</span>满足四边形不等式和区间包含单调性,则复合函数<span class="math inline">\(h ( w ( l , r )
)\)</span>也满足四边形不等式和区间包含单调性.</p>
<p>令<span class="math inline">\(l_1 \leq l_2 \leq r_1 \leq
r_2\)</span>,由于<span class="math inline">\(w\)</span>满足四边形不等式,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l_1 , r_1 ) + w ( l_2 , r_2 ) &amp; \leq w ( l_1 , r_2 ) + w ( l_2 ,
r_1 ) \\
0 &amp; \leq w ( l_1 , r_1 ) - w ( l_2 , r_1 ) &amp; \leq w ( l_1 , r_2
) - w ( l_2 , r_2 )
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(t = w ( l_1 , r_2 ) - w ( l_2 , r_2
)\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l_1 , r_1 ) &amp; \leq w ( l_2 , r_1 ) + t \\
w ( l_1 , r_2 ) &amp; = w ( l_2 , r_2 ) + t \\
h ( w ( l_1 , r_1 ) ) - h ( w ( l_2 , r_1 ) ) &amp; \leq h ( w ( l_2 ,
r_1 ) + t ) - h ( w ( l_2 , r_1 ) ) \\
h ( w ( l_1 , r_2 ) ) - h ( w ( l_2 , r_2 ) ) &amp; = h ( w ( l_2 , r_2
) + t ) - h ( w ( l_2 , r_2 ) )
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(\Delta h ( x ) = h ( x + t ) - h (
x )\)</span>,由于<span class="math inline">\(h\)</span>是下凸函数,所以<span class="math inline">\(\Delta h\)</span>函数单调递增.</p>
<p>那么也就有:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l_1 , r_1 ) ) - h ( w ( l_2 , r_1 ) ) &amp; \leq \Delta h ( w (
l_2 , r_1 ) ) \\
h ( w ( l_1 , r_2 ) ) - h ( w ( l_2 , r_2 ) ) &amp; = \Delta h ( w ( l_2
, r_2 ) )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(w ( l_2 , r_1 ) \leq w ( l_2 , r_2
)\)</span>,所以<span class="math inline">\(\Delta h ( w ( l_2 , r_1 ) )
\leq \Delta h ( w ( l_2 , r_2 ) )\)</span>于是:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l_1 , r_1 ) ) - h ( w ( l_2 , r_1 ) ) &amp; \leq h ( w ( l_1 ,
r_2 ) ) - h ( w ( l_2 , r_2 ) ) \\
h ( w ( l_1 , r_1 ) ) + h ( w ( l_2 , r_2 ) ) &amp; \leq h ( w ( l_1 ,
r_2 ) ) + h ( w ( l_2 , r_1 ) )
\end{aligned}
\]</span></p>
<p>证毕.</p>
<h5><span id="定理5">定理5</span></h5>
<p>设<span class="math inline">\(h\)</span>是一个下凸函数(一阶导数单调递增),若<span class="math inline">\(w ( l , r
)\)</span>满足四边形恒等式和区间包含单调性,则复合函数<span class="math inline">\(h ( w ( l , r ) )\)</span>也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到<span class="math inline">\(h\)</span>单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4>
<p>对于形如<span class="math inline">\(f_i = \min_{ 1 \leq j &lt; i } \{
f_j + w ( j , i ) \}\)</span>的状态转移方程,记<span class="math inline">\(p_i\)</span>为<span class="math inline">\(f_i\)</span>的最优决策.若<span class="math inline">\(p\)</span>在<span class="math inline">\([ 1 , n
]\)</span>上单调不降,则称<span class="math inline">\(f\)</span>具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的<span class="math inline">\(\min\)</span>改为<span class="math inline">\(\max\)</span>,并且把<span class="math inline">\(+
w\)</span>改为<span class="math inline">\(-
w\)</span>,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5>
<p>定理：对于形如<span class="math inline">\(f_i = \min_{ 1 \leq j &lt;
i }{ f_j + w ( j , i ) }\)</span>的状态转移方程,若<span class="math inline">\(w\)</span>满足四边形不等式,则<span class="math inline">\(f\)</span>有决策单调性.</p>
<p>证明:</p>
<p><span class="math inline">\(\forall i \in [ 1 , n ] , \forall j \in [
0 , p_i - 1 ]\)</span>,根据<span class="math inline">\(p\)</span>的定义,有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ p_i } + w ( p_i , i ) &amp; \leq f_j + w ( j , i ) \\
f_{ p_i } - f_j &amp; \leq w ( j , i ) - w ( p_i , i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而对于<span class="math inline">\(k \in [ i + 1 , n
]\)</span>,根据<span class="math inline">\(w\)</span>的四边形不等式,有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( j , i ) + w ( p_i , k ) &amp; \leq w ( j , k ) + w ( p_i , i ) \\
w ( j , i ) - w ( p_i , i ) &amp; \leq w ( j , k ) - w ( p_i , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ p_i } - f_j &amp; \leq w ( j , k ) - w ( p_i , k ) \\
f_{ p_i } + w ( p_i , k ) &amp; \leq w ( j , k ) + f_j \\

\end{aligned}\]</span>
<p>$$</p>
<p>即:<span class="math inline">\(j\)</span>对<span class="math inline">\(k\)</span>的更新一定不如<span class="math inline">\(p_i\)</span>对<span class="math inline">\(k\)</span>的更新更优,因此<span class="math inline">\(p_k \in [ p_i , n ]\)</span>,因此<span class="math inline">\(f\)</span>有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6>
<p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设<span class="math inline">\(f_i\)</span>表示价值为<span class="math inline">\(i\)</span>的答案,自然有:<span class="math inline">\(f_i = \max \{ f_{ i - kc } + sum_{ c , k }
\}\)</span>.</p>
<p>如果我们把<span class="math inline">\(c\)</span>相同的分层,那这显然是一个最短路型dp,其中<span class="math inline">\(w ( i , j ) = sum_{ c , \frac{ i - j }{ c }
}\)</span>.</p>
<p>显然这个转移只会让<span class="math inline">\(\mod
c\)</span>相同的相互转移,于是后面的<span class="math inline">\(w ( i , j
)\)</span>可以理解为一段数字的和,自然满足四边形不等式(<span class="math inline">\(\max\)</span>也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5>
<p>对于形如<span class="math inline">\(f_{ x , j } = \min_{ i = 1 }^{ x
- 1 } \{ f_{ i , j - 1 } + w_{ i , x } \}\)</span>的状态转移方程,若<span class="math inline">\(w\)</span>满足四边形不等式,则<span class="math inline">\(f\)</span>有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如<span class="math inline">\(f_x = \min_{ i = 1
}^{ x - 1 }{ w_{ i , x } }\)</span>,我们也可以看作<span class="math inline">\(k\)</span>点最短路型的<span class="math inline">\(k = 1\)</span>的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6>
<p>令<span class="math inline">\(f ( i , j )\)</span>为在第<span class="math inline">\(j\)</span>个位置建造第<span class="math inline">\(i\)</span>个基站的代价最小值,那么我们有转移:</p>
<p><span class="math display">\[
f ( i , j ) = \min_{ 1 \leq k &lt; j } \{ f ( i - 1 , k ) + \sum_{ l = k
+ 1 }^{ j - 1 } w_l [ d_l - s_l &gt; d_k ] [ d_l + s_l &lt; d_j ] + c_j
\}
\]</span></p>
<p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时<span class="math inline">\(d_k\)</span>单调递增,更新答案时<span class="math inline">\(d_j\)</span>单调递增,于是可以直接使用线段树维护,复杂度<span class="math inline">\(O ( nk \log n
)\)</span>.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度<span class="math inline">\(O ( nk
\log^2 n )\)</span>.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度<span class="math inline">\(O ( n \log k \log n )\)</span>.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6>
<p>自然的设计是<span class="math inline">\(f_{ i , j , k
}\)</span>表示前<span class="math inline">\(i\)</span>个,已经打了<span class="math inline">\(j\)</span>个,末尾有连续<span class="math inline">\(k\)</span>个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为<span class="math inline">\(f_{ i ,
j }\)</span>表示前<span class="math inline">\(i\)</span>个,目前打了<span class="math inline">\(j\)</span>个且第<span class="math inline">\(i\)</span>个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成<span class="math inline">\(f_{ i , j }\)</span>表示前<span class="math inline">\(i\)</span>个,目前有<span class="math inline">\(j\)</span>个没打中而且第<span class="math inline">\(i\)</span>个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:<span class="math inline">\(dp_{ i , j }
= \max \{ dp_{ k , j - 1 } + \sum_{ l = k + 1 }^{ i - 1 } C_{ l - k }
A_l + P \}\)</span>.</p>
<p>令<span class="math inline">\(w ( l , r ) = \sum_{ k = l + 1 }^{ r -
1 } C_{ k - l } A_k + P\)</span>,接下来我们证明:<span class="math inline">\(w ( l + 1 , r ) + w ( l , r - 1 ) \geq w ( l , r )
+ w ( l + 1 , r - 1 )\)</span>即可.讨论一下每个<span class="math inline">\(A\)</span>面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5>
<p>引理:在状态转移方程<span class="math inline">\(f_{ i , j } = \min_{ i
\leq k &lt; j } \{ f_{ i , k } + f_{ k + 1 , j } + w ( i , j )
\}\)</span>中(通常<span class="math inline">\(f_{ i , i } = w ( i , i )
= 0 , f_{ i , i + 1 } = w_{ i , i + 1 }\)</span>),如果<span class="math inline">\(w\)</span>满足四边形不等式和区间包含单调性,那么<span class="math inline">\(f\)</span>也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明<span class="math inline">\(f_{ i , j } + f_{ i + 1 , j + 1 }
\leq f_{ i , j + 1 } + f_{ i + 1 , j }\)</span>即可,考虑<span class="math inline">\(j - i = 1\)</span>的时候,显然成立.</p>
<p>使用数学归纳,假设当<span class="math inline">\(b - a &lt;
k\)</span>时,<span class="math inline">\(f\)</span>满足四边形不等式,考虑<span class="math inline">\(j - i = k\)</span>的情况:</p>
<p>设<span class="math inline">\(f_{ i , j + 1
}\)</span>的最优决策为<span class="math inline">\(x\)</span>,<span class="math inline">\(f_{ i + 1 , j }\)</span>的最优决策为<span class="math inline">\(y\)</span>,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i , j + 1 } + f_{ i + 1 , j } &amp; = f_{ i , x } + f_{ x + 1 , j +
1 } + w ( i , j + 1 ) + f_{ i + 1 , y } + f_{ y + 1 , j } + w ( i + 1 ,
j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于<span class="math inline">\(f_{ i , j }\)</span>和<span class="math inline">\(f_{ i + 1 , j + 1 }\)</span>来说,<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>不一定最优,所以有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i , j } + f_{ i + 1 , j + 1 } &amp; \leq f_{ i , x } + f_{ x + 1 , j
} + w ( i , j ) + f_{ i + 1 , y } + f_{ y + 1 , j + 1 } + w ( i + 1 , j
+ 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math inline">\(w\)</span>和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i , j } + f_{ i + 1 , j + 1 } &amp; \leq f_{ i , j + 1 } + f_{ i + 1
, j } \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="定理">定理</span></h6>
<p>记<span class="math inline">\(p_{ i , j }\)</span>为<span class="math inline">\(f_{ i , j }\)</span>的最优决策,若<span class="math inline">\(f\)</span>满足四边形不等式,那么对于<span class="math inline">\(\forall i &lt; j ， 有 p_{ i , j - 1 } \leq p_{ i
, j } \leq p_{ i + 1 , j } \\\)</span>.</p>
<p>证明:</p>
<p>记<span class="math inline">\(p = p_{ i , j }\)</span>,<span class="math inline">\(\forall k , i &lt; k \leq p\)</span>,因为<span class="math inline">\(f\)</span>满足四边形不等式,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ i , k } + f_{ i + 1 , p } &amp; \leq f_{ i , p } + f_{ i + 1 , k }
\\
f_{ i + 1 , p } - f_{ i + 1 , j } &amp; \leq f_{ i , p } - f_{ i , k }
\end{aligned}
\]</span></p>
<p>根据<span class="math inline">\(p\)</span>定义,有:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ i , p } + f_{ p + 1 , j } &amp; \leq f_{ i , k } + f_{ k + 1 , j }
\\
f_{ i , p } - f_{ i , k } &amp; \leq f_{ k + 1 , j } - f_{ p + 1 , j }
\end{aligned}
\]</span></p>
<p>由上两式移项联立,得到:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 , p } - f_{ i + 1 , k } &amp; \leq f_{ k + 1 , j } - f_{ p + 1
, j } \\
f_{ i + 1 , p } + f_{ p + 1 , j } &amp; \leq f_{ i + 1 , k } + f_{ k + 1
, j } \\
f_{ i + 1 , p } + f_{ p + 1 , j } + w_{ i + 1 , j } &amp; \leq f_{ i + 1
, k } + f_{ k + 1 , j } + w_{ i + 1 , j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>因此对于<span class="math inline">\(f_{ i + 1 , j }\)</span>,<span class="math inline">\(p\)</span>比任意的<span class="math inline">\(k
&lt; p\)</span>更优,因此<span class="math inline">\(p_{ i + 1 , j } \geq
p_{ i , j }\)</span>,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4>
<p>判断一个函数的凸性只需判断<span class="math inline">\(f ( k ) + f ( k
+ 2 ) \geq 2 f ( k + 1 )\)</span>,而这只需证明<span class="math inline">\(k\)</span>的时候的答案和<span class="math inline">\(k + 2\)</span>时的答案可以调整出两个<span class="math inline">\(k +
1\)</span>的答案(不一定是最小答案)并且这两个<span class="math inline">\(k + 1\)</span>的答案的和小于等于<span class="math inline">\(k\)</span>时和<span class="math inline">\(k +
2\)</span>时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5>
<p>首先考虑四个点<span class="math inline">\(( a , b , c , d
)\)</span>,注意到其一定满足四边形不等式,也就是<span class="math inline">\(w_{ ac } + w_{ bd } \geq w_{ ad } + w_{ bc
}\)</span>.</p>
<p>我们现在想证明,设<span class="math inline">\(f_k\)</span>为新增<span class="math inline">\(k\)</span>个传送机后的减少的答案,我们考虑证明<span class="math inline">\(f_k + f_{ k + 2 } \geq 2 f_{ k + 1 }\)</span>.</p>
<p>我们画出<span class="math inline">\(f_k\)</span>时选的点和<span class="math inline">\(f_{ k + 2
}\)</span>时选的点,注意到我们可以用这两次调整出两个<span class="math inline">\(k +
1\)</span>的答案,并且这两个答案的和小于等于<span class="math inline">\(f_k + f_{ k + 2 }\)</span>,于是证明了最小的<span class="math inline">\(f_{ k + 1 }\)</span>是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量<span class="math inline">\(w\)</span>,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于<span class="math inline">\(w\)</span>的最大的传送机数量,然后就可以做了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">人工智能基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="常用激活函数">常用激活函数</span></h3>
<h4><span id="sigmoid函数">Sigmoid函数</span></h4>
<p><span class="math inline">\(f ( x ) = \frac{ 1 }{ 1 + e^{ - x } } : (
- \infty , + \infty ) \to ( 0 , 1 )\)</span>.</p>
<p><span class="math inline">\(f &#39; ( x ) = f ( x ) ( 1 - f ( x )
)\)</span>.</p>
<h4><span id="tanh函数">tanh函数</span></h4>
<p><span class="math inline">\(f ( x ) = \frac{ e^x - e^{ - x } }{ e^x +
e^{ - x } } : ( - \infty , + \infty ) \to ( - 1 , 1 )\)</span>.</p>
<p><span class="math inline">\(f &#39; ( x ) = 1 - f^2 ( x
)\)</span>.</p>
<h4><span id="relu函数">ReLU函数</span></h4>
<p><span class="math inline">\(f ( x ) = \max ( 0 , x ) : ( - \infty , +
\infty ) \to ( 0 , + \infty )\)</span>.</p>
<h4><span id="leaky-relu函数">Leaky ReLU函数</span></h4>
<p><span class="math inline">\(f ( x ) = \max ( \alpha x , x ) , 0 &lt;
\alpha &lt; 1 : ( - \infty , + \infty ) \to ( - \infty , + \infty
)\)</span>.</p>
<h4><span id="softmax函数">Softmax函数</span></h4>
<p><span class="math inline">\(f ( x_i ) = \frac{ e^{ x_i } }{ \sum_j
e^{ x_j } }\)</span>.</p>
<h3><span id="损失函数">损失函数</span></h3>
<h4><span id="least-square">Least Square</span></h4>
<p>即<span class="math inline">\(\arg \min \sum_{ i = 1 }^n ( f ( x_i )
- y_i )^2 = \arg \min ( A \beta - Y \mid A \beta - Y
)\)</span>.用最小二乘法取<span class="math inline">\(\hat \beta = ( A^T
A )^{ - 1 } A^T Y\)</span>.</p>
<h4><span id="cross-entropy">Cross Entropy</span></h4>
<p>用错误的分布<span class="math inline">\(q\)</span>来表示真实分布<span class="math inline">\(p\)</span>的样本,则平均编码长度应该是:</p>
<p><span class="math display">\[
H ( p , q ) = \sum_i p ( i ) \log ( \frac{ 1 }{ q ( i ) } ) = - \sum_i p
( i ) \log{ q ( i ) }
\]</span></p>
<p>此为交叉熵.</p>
<p>特别地,当最终样本只有两个的时候,例如Logistical
Regression问题,可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
H &amp; = - ( y \log a + ( 1 - y ) \log ( 1 - a ) ) \\
\frac{ \partial H }{ \partial a } &amp; = - ( \frac{ y }{ a } - \frac{ 1
- y }{ 1 - a } )
\end{aligned}
\]</span></p>
<p>那如果有多个呢?考虑直接对归一化条件作偏导,先有:</p>
<p><span class="math display">\[
\begin{aligned}
H ( p , q ) &amp; = - \sum_i p_i ( \log{ q_i } - \log ( \sum_j q_j ) )
\\
\frac{ \partial H ( p , q ) }{ \partial q_k } &amp; = - \frac{ p_k }{
q_k } + \frac{ \sum p_k }{ \sum_j q_j } \\
&amp; = - \frac{ p_k }{ q_k } + 1
\end{aligned}
\]</span></p>
<p>再乘以softmax那里的<span class="math inline">\(q_k\)</span>,得到<span class="math inline">\(- p_k + q_k = - y_k + f ( x_k )\)</span>.</p>
<h3><span id="神经网络实现">神经网络实现</span></h3>
<p>通过若干隐藏层,假设最后的输出层为第<span class="math inline">\(L\)</span>层,则:</p>
<ol type="1">
<li><p>对于第<span class="math inline">\(l\)</span>层,取<span class="math inline">\(\vec{ z }_l = ( W_l )^t \vec{ a }_{ l - 1 } +
\vec{ b }_l\)</span>.这里对<span class="math inline">\(W_l\)</span>作转置的目的是写代码的时候需要用行向量.</p></li>
<li><p>对于第<span class="math inline">\(l\)</span>层,取<span class="math inline">\(\vec{ a }_l = f ( \vec{ z }_l
)\)</span>,这里意味着将每一个分量对<span class="math inline">\(f\)</span>操作.</p></li>
<li><p>对于最终答案,取误差<span class="math inline">\(\mathcal{ L } =
\frac{ 1 }{ m } ( \vec{ y } - \vec{ a }_L \mid \vec{ y } - \vec{ a }_L
)\)</span>.</p></li>
</ol>
<h4><span id="梯度下降法">梯度下降法</span></h4>
<p>换言之就是让<span class="math inline">\(w : = w - \alpha \frac{
\partial \mathcal{ L } }{ \partial w }\)</span>,其中<span class="math inline">\(\alpha\)</span>是一个选定的小常数,也可以采用类似模拟退火的方式动态决定.事实上可以把各个位置分开,写作<span class="math inline">\(w_j : = w_j - \alpha \frac{ \partial \mathcal{ L }
}{ \partial w_j }\)</span>.</p>
<p>另外,虽然是这么写,应当见到去掉下标<span class="math inline">\(k\)</span>的记号仍然合理,无非是逐分量做此操作,因此下面如无特殊说明,运算均采用逐分量运算.例如可以定义<span class="math inline">\(\vec{ a } \circ \vec{ b
}\)</span>为两个向量逐分量相乘后得到的新向量,为表区分用<span class="math inline">\(\times\)</span>表示正常的矩阵乘法.甚至采取<span class="math inline">\(( \vec{ a } - \vec{ y }
)^2\)</span>表示其自点积.坦白而言,笔者对此符号相当无奈,可也想不出什么更好的写法了.但总之这种写法总是强于部分参考资料上所将下标放上面的写作<span class="math inline">\(a^L\)</span>的做法.笔者所能维持的精神数院人的唯一做法也只能是在下面加上向量符号,藉此泄愤.</p>
<p>顺便一提,应当见到<span class="math inline">\(\times\)</span>和<span class="math inline">\(\circ\)</span>这两种运算比较随意,用线性映射来理解,你这个<span class="math inline">\(W \times\)</span>任意作用在一个向量上就行.</p>
<h4><span id="误差反向传播">误差反向传播</span></h4>
<p>既然要用梯度下降法,就应该把每一层的偏导都求出来.然而<span class="math inline">\(\mathcal{ L
}\)</span>是最后一层的结果,因此应该用链式法则一路求出前面的偏导.</p>
<p>更具体地,不妨设误差函数选的是<span class="math inline">\(( \vec{ a }
- \vec{ y } )^2\)</span>,激活函数选的是cross entropy有:</p>
<ol type="1">
<li><p><span class="math inline">\(\frac{ \partial{ \mathcal{ L } } }{
\partial \vec{ a }_{ L } } = ( \vec{ a }_{ L } - \vec{ y }
)\)</span>.(如若选择不同的误差函数,这里作适当变化)</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ a }_{ l } }{
\partial \vec{ z }_{ l } } = f &#39; ( \vec{ z }_{ l } ) = \vec{ a }_{ l
} \circ ( 1 - \vec{ a }_{ l }
)\)</span>.(如若选取不同的激活函数,这里作适当变化)</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ z }_{ l + 1 }
}{ \partial \vec{ z }_{ l } } = \frac{ \partial \vec{ z }_{ l + 1 } }{
\partial \vec{ a }_{ l } } \frac{ \partial \vec{ a }_{ l } }{ \partial
\vec{ z }_{ l } } = ( W_{ l + 1 } )^t \times ( \vec{ a }_l \circ ( 1 -
\vec{ a }_l ) )\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ z }_{ l } }{
\partial W_{ l } } = ( \vec{ a }_{ l - 1 }
)\)</span>.结果理应是一个矩阵,其实就是这个列向量不断复制若干遍,或者写成<span class="math inline">\(( \vec{ a }_{ l - 1 } )^t M ( 1
)\)</span>,其中<span class="math inline">\(M ( 1 )\)</span>是全<span class="math inline">\(1\)</span>矩阵.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \vec{ z }_{ l } }{
\partial \vec{ b }_{ l } } = 1\)</span>.</p></li>
</ol>
<p>我们应当见到:</p>
<p>不妨设<span class="math inline">\(\delta_l = \frac{ \partial{
\mathcal{ L } } }{ \partial \vec{ z }_l }\)</span>.见到:</p>
<ol type="1">
<li><p><span class="math inline">\(\delta_L = \frac{ \partial \mathcal{
L } }{ \partial \vec{ z }_L } = \frac{ \partial \mathcal{ L } }{
\partial \vec{ a }_L } \frac{ \partial \vec{ a }_L }{ \partial \vec{ z
}_L } = ( \vec{ a }_{ L } - \vec{ y } ) \circ \vec{ a }_{ L } \circ ( 1
- \vec{ a }_{ L }
)\)</span>.前者会因为误差函数的选取而改变,后者会因为激活函数的选取而改变.</p></li>
<li><p><span class="math inline">\(\delta_l = \frac{ \partial{ \mathcal{
L } } }{ \partial \vec{ z }_l } = \delta_{ l + 1 } \frac{ \partial \vec{
z }_{ l + 1 } }{ \partial \vec{ z }_l } = \delta_{ l + 1 } \circ ( W_{ l
+ 1 } )^t \times ( \vec{ a }_{ l } \circ ( 1 - \vec{ a }_{ l } )
)\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \mathcal{ L } }{
\partial W_{ l } } = \frac{ \partial \mathcal{ L } }{ \partial \vec{ z
}_{ l } } \frac{ \partial \vec{ z }_l }{ \partial W_{ l } } = \delta_l
\times a_{ l - 1 }^t\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \partial \mathcal{ L } }{
\partial \vec{ b }_l } = \delta_l\)</span>.</p></li>
</ol>
<p>如此以上更新即可.</p>
<h3><span id="卷积神经网络cnn">卷积神经网络(CNN)</span></h3>
<p>神经网络受矩阵乘法的限制,导致对于真实的尺寸巨大的图像难以快速识别,因此产生了卷积神经网络的概念,大概有以下特征:</p>
<ol type="1">
<li><p>空间上权值共享:不同位置使用同一个卷积核(滤波器)</p></li>
<li><p>稀疏链接:每一层只链接前一层的感受野.</p></li>
<li><p>等变表示:卷积神经网络有某种平移不变性.</p></li>
</ol>
<p>对于2D卷积,其公式如下:</p>
<p><span class="math display">\[
S_{ r , c } = ( X * W )_{ r , c } = \sum_i \sum_j X_{ r + i , c + j }
\times w_{ i , j }
\]</span></p>
<p>其中<span class="math inline">\(W\)</span>是卷积核,<span class="math inline">\(X\)</span>是输入图像,<span class="math inline">\(S\)</span>是输出的结果.如果一个图像有多个通道(比如色彩层之类的),每个通道上都需要应用一个卷积核.</p>
<p>下面引入一些名词:</p>
<ol type="1">
<li><p>input size:输入图像的尺寸.</p></li>
<li><p>padding:填充的像素数.</p></li>
<li><p>filter size:卷积核的尺寸.有时也写作两个变量:filter height和filter
width.3D卷积还会有一个filter depth的变量.</p></li>
<li><p>stride:步长.</p></li>
<li><p>output size:卷积后输出的尺寸.有时也写作feature size.</p></li>
<li><p>input channels:输入图像的通道数.</p></li>
<li><p>n filters:卷积核的数量.</p></li>
<li><p>dilation rate:膨胀率,用于空洞卷积.膨胀率为<span class="math inline">\(d\)</span>的时候,卷积核中间会插入<span class="math inline">\(d - 1\)</span>个<span class="math inline">\(0\)</span>间隔.</p></li>
</ol>
<h4><span id="感受野计算">感受野计算</span></h4>
<p>先看output
size的计算,容易见到,其各个维度方面计算是独立的.只要对于单个维度算出卷积核在上面移动的次数,最后将不同维度相乘即可.</p>
<p>对于单个维度,这个维度的移动次数应该是:</p>
$$
<span class="math display">\[\begin{aligned}
\text{ output \_ size } &amp; = \lceil \frac{ \text{ input \_ size } + 2
\times \text{ padding } - \text{ filter \_ size } + 1 }{ \text{ stride }
} \rceil \\
&amp; = \lfloor \frac{ \text{ input \_ size } + 2 \times \text{ padding
} - \text{ filter \_ size } }{ \text{ stride } } \rfloor + 1 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式相当容易理解,原因是<span class="math inline">\(\text{ stride
} = 1\)</span>的时候,上面恰好是移动的次数,而<span class="math inline">\(\text{ stride
}\)</span>变化的时候,当然要拿到一个上取整.</p>
<p>至于所谓的空洞卷积,只需在上面的基础上改<span class="math inline">\(\text{ filter \_ size }\)</span>就好.</p>
<p>至于乘法操作,每得到一个<span class="math inline">\(\text{ output
}\)</span>当然都会需要<span class="math inline">\(\text{ filter \_ size
}\)</span>次乘法操作.</p>
<p>再看感受野的计算,不妨设<span class="math inline">\(S_i\)</span>为前<span class="math inline">\(i\)</span>次卷积的<span class="math inline">\(\text{ stride }\)</span>的乘积,设<span class="math inline">\(k_{ i + 1 }\)</span>表示第<span class="math inline">\(i + 1\)</span>层的<span class="math inline">\(\text{ kernel \_ size }\)</span>,则:</p>
<p><span class="math display">\[
RF_{ i + 1 } = RF_i + ( k_{ i + 1 } - 1 ) \times S_i
\]</span></p>
<p>这个公式的含义大概是每次先看对应了多大的原数据上的范围,再把原本的边界<span class="math inline">\(RF_i\)</span>给补上.</p>
<h4><span id="池化pooling">池化(Pooling)</span></h4>
<p>池化操作它没有一个可学习的参数,只是对输入数据进行固定的操作.简单来说就是降低输入的规模,以实现更好的鲁棒性以及提高效率.</p>
<p>常见的池化操作包括:</p>
<ol type="1">
<li><p>MaxPooling:取区域内的最大值.</p></li>
<li><p>MeanPooling:取区域内的平均值.</p></li>
<li><p>PyramidPooling:多次进行尺度不同的池化.</p></li>
</ol>
<h4><span id="常见卷积架构">常见卷积架构</span></h4>
<h5><span id="alexnet">AlexNet</span></h5>
<p>首次引入ReLU激活函数,Dropout
技术,以及数据增强,提高了模型的训练效率和泛化能力.</p>
<p>采用了<span class="math inline">\(8\)</span>层深的网络结构,证明了深度网络的潜力.</p>
<h5><span id="vgg">VGG</span></h5>
<p>开始堆叠小尺寸的卷积核,获得与大卷积核相似的感受野的同时可以增加网络深度.</p>
<h5><span id="resnet">ResNet</span></h5>
<p>引入残差的概念,直接将输入数据累加(跳跃连接)到最后的输出中,这样网络学习的实际上是输入和输出之间的残差,从而提高了网络学习能力.</p>
<h5><span id="squeezenet">SqueezeNet</span></h5>
<p>SqueezeNet的基本构建单元是Fire模块.Fire模块由一个squeeze层和一个expand层组成.squeeze层使用<span class="math inline">\(1 \times
1\)</span>卷积核减少通道数,而expand层则使用<span class="math inline">\(1
\times 1\)</span>和<span class="math inline">\(3 \times
3\)</span>卷积核增加通道数.这种设计有效地减少了参数数量和计算量.</p>
<h5><span id="mobilenet">MobileNet</span></h5>
<ol type="1">
<li><p>深度卷积:在这个操作中,每个输入通道独立地进行卷积,这意味着在进行卷积时,不同通道之间没有交互.这样可以减少计算量和参数数量.</p></li>
<li><p>逐点卷积:逐点卷积使用<span class="math inline">\(1 \times
1\)</span>的卷积核,它作用在深度卷积的输出上,将不同通道的信息整合在一起.逐点卷积可以减少参数数量,同时保持较高的性能.</p></li>
</ol>
<h5><span id="shufflenet">ShuffleNet</span></h5>
<ol type="1">
<li><p>组卷积(Group
Convolution):将通道分成几个组,并使用不同的卷积神经网络层执行标准卷积.</p></li>
<li><p>打乱层(Shuffle
layer):通过对通道进行洗牌,将不同组的信息合并.</p></li>
</ol>
<h5><span id="反卷积">反卷积</span></h5>
<p>也就是将较小的数据特征图扩大到较大的尺寸.有的时候也把这个操作说成上采样.</p>
<ol type="1">
<li><p>插值步骤(Interpolation
Step):首先,在输入特征图的元素之间插入零,增加特征图的尺寸.</p></li>
<li><p>卷积步骤(Convolution
Step):接下来,对扩大后的特征图应用一个标准的卷积操作.此步骤相当于在扩大的特征图上滑动卷积核,计算卷积输出.</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">OI中的线性代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<ul>
<li><a href="#oi中的线性代数">OI中的线性代数</a>
<ul>
<li><a href="#线性基">线性基</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan
and Burgers)</a></li>
<li><a href="#example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337
[Ynoi2004] rsxc)</a></li>
<li><a
href="#example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</a></li>
</ul></li>
<li><a href="#杂题">杂题</a>
<ul>
<li><a href="#example1cf1270ixor-on-figures">Example1([CF1270I]Xor on
Figures)</a></li>
<li><a
href="#example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing
Finals)</a></li>
</ul></li>
<li><a href="#逆矩阵求解线性方程组">逆矩阵求解线性方程组</a>
<ul>
<li><a
href="#example1codeforces-cf1266h-red-blue-graph">Example1(codeforces
CF1266H Red-Blue Graph)</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/" class="post-title-link" itemprop="url">OI中的常见套路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="本质相同">本质相同</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>对于所有满足以下条件的长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(\{ a
\}\)</span>,我们称它是好的:</p>
<p><span class="math display">\[
\begin{aligned}
a_1 &amp; = 1 \\
\forall 2 &amp; \leq i &amp; \leq n , a_i &amp; \leq \max \{ a_1 ,
\cdots , a_{ i - 1 } \} + 1
\end{aligned}
\]</span></p>
<p>对于每一个数<span class="math inline">\(1 \leq x \leq
n\)</span>,求它在每个好的序列中出现的次数的平方和.其中<span class="math inline">\(1 \leq n \leq 3000\)</span>,任意模数.</p>
<p>首先注意到可以枚举每个数<span class="math inline">\(x\)</span>出现的次数,这样就转化为对满足某些位置是<span class="math inline">\(x\)</span>的好的序列计数.</p>
<p>对于一个没有限制的好的序列,设<span class="math inline">\(f_{ i , j
}\)</span>表示<span class="math inline">\([ 1 , i ]\)</span>中填了<span class="math inline">\([ 1 , j ]\)</span>(其中<span class="math inline">\(j\)</span>必填)的方案数,不难发现这就是第二类斯特林数.</p>
<p>这样,对于一个<span class="math inline">\(x\)</span>,我们可以枚举它第一次出现的位置以及出现的次数,以及它第一次出现的位置后面的大于等于它的数的数量,合并即可.复杂度<span class="math inline">\(O ( n^4 )\)</span>.</p>
<p>再思考一下,似乎我们不用枚举它出现的次数,而是可以直接用<span class="math inline">\(g_{ i , j , 0 / 1 / 2 }\)</span>表示在<span class="math inline">\([ 1 , i ]\)</span>中填<span class="math inline">\([ 1 , j ]\)</span>,<span class="math inline">\(1\)</span>出现次数的平方和.同样枚举后面有多少大于等于它的位置,然后就可以把这些位置抽出来作为一个子序列,这个子序列就可以认为<span class="math inline">\(x\)</span>就是<span class="math inline">\(1\)</span>.复杂度<span class="math inline">\(O (
n^3 )\)</span>.</p>
<p>如果写出上面的式子的话,会发现最难处理的是一个形如<span class="math inline">\(x^k\)</span>的项,表示<span class="math inline">\(x\)</span>第一次出现的位置后面仍然选比它小的数字的位置的方案数.这个怎么办呢?自然的想法是想在dp中顺便把它算了.</p>
<p>再进一步想,我们之所以合并麻烦,是因为取了两段上升区间.如果我们能求出一个上升区间和一个下降区间,在交点处合并呢?</p>
<p>但是这样怎么统计平方和呢?我们发现如果在<span class="math inline">\([
1 , k ]\)</span>中选了<span class="math inline">\([ 1 , i
]\)</span>,那么<span class="math inline">\([ 1 , i ]\)</span>在<span class="math inline">\([ k + 1 , n
]\)</span>中是本质完全相同的,因此还是可以用上面的dp求.</p>
<h3><span id="排列转环">排列转环</span></h3>
<h5><span id="example1p8416">Example1(P8416)</span></h5>
<p>这题牛逼.</p>
<p>首先考虑一维的情况,一维情况下最劣应该是<span class="math inline">\(2
, 3 , . . . , n , 1\)</span>这样的.</p>
<p>为啥捏?因为注意到操作数<span class="math inline">\(= n
-\)</span>排列环数,这样的排列环数为<span class="math inline">\(1\)</span>,显然是最小的.加上列也差不多,所以<span class="math inline">\(k_0 = 2 n ( n - 1 ) = 2 n^2 - 2 n\)</span>.</p>
<p>而我们显然可以通过两次操作把一个位置归位,最后剩一行再随便做做,这样的答案就是<span class="math inline">\(2 n^2 - n +
1\)</span>,如果我们想赢,那就需要在上面的<span class="math inline">\(n -
1\)</span>行每行省出一步操作.</p>
<p>这咋做呢?类似上面的做法,也考虑找环然后省一步,对于一行,我们找到所有应该放在这里的值以及它们所在的列,把它们应该在的列和实际在的列连边,一定能找到至少一个环(自环也算),删环就可以省一步操作.</p>
<h5><span id="example2">Example2</span></h5>
<p>给序列<span class="math inline">\(a\)</span>和排列<span class="math inline">\(b\)</span>,有若干次操作:</p>
<ol type="1">
<li><p>修改操作:给定<span class="math inline">\(x , y\)</span>,将<span class="math inline">\(a_x\)</span>改为<span class="math inline">\(y\)</span>.</p></li>
<li><p>查询操作:给定<span class="math inline">\(l , r ,
x\)</span>,查区间<span class="math inline">\([ l , r
]\)</span>内最长的子区间<span class="math inline">\([ l &#39; , r &#39;
]\)</span>,使得对<span class="math inline">\(\forall l &#39; \leq i &lt;
r &#39;\)</span>,有<span class="math inline">\(a_{ i + 1 } = b_{ a_i
}\)</span>,且存在<span class="math inline">\(l &#39; \leq i \leq r
&#39;\)</span>使得<span class="math inline">\(a_i =
x\)</span>.需要输出满足条件的子区间的长度最大值.</p></li>
</ol>
<p>一步一步来,首先处理出所有的极长的满足条件的段,不难发现修改一个点只会断掉一个段或者连接两个段,影响是<span class="math inline">\(O ( 1 )\)</span>的.</p>
<p>难点在于,我们如何处理要求其中存在一个<span class="math inline">\(x\)</span>这种东西.</p>
<p>注意到<span class="math inline">\(b\)</span>是排列,上置换,不难发现<span class="math inline">\(b\)</span>其实就是一个置换,也就是说每一个极长的段一定是一个置换环内部的元素,我们可以快速定位到<span class="math inline">\(x\)</span>所在的置换环.但这样还是不能做.</p>
<p>考虑由于是单点查询<span class="math inline">\(x\)</span>,我们可以直接将数组也做置换,这样一个置换环就在一个区间内部,意味着一个极长的段一定是一个区间或者两个区间(原区间的一段前缀和一段后缀).</p>
<p>现在对于区间查询,我们考虑特殊处理和端点相交的段,这个是平凡的.这样我们只需要处理出完全被区间包含的那些段该怎么做.把右端点缩一缩,就等价于左端点完全被区间包含的那些点.也就是以<span class="math inline">\(a\)</span>为横坐标,<span class="math inline">\(l\)</span>为纵坐标,这样这些就相当于对一条横线取<span class="math inline">\(\max\)</span>,然后查询一段竖着的线段的最大值.注意到一行不可能有两个横线,因此可以线段树分治+线段树维护,复杂度<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<h3><span id="规定转移顺序">规定转移顺序</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一张<span class="math inline">\(n\)</span>个点的图,每个点有一个<span class="math inline">\([ 1 , k
]\)</span>的颜色,求这张图有多少个子图是一棵树并且在这棵树中每种颜色恰好出现了一次.</p>
<p>首先无根树转有根树计数,设<span class="math inline">\(dp_{ i , S
}\)</span>表示以<span class="math inline">\(i\)</span>为根,已经选了<span class="math inline">\(S\)</span>集合中的颜色的方案数.转移的时候枚举出边(注意可能会算重,只要是会算重的都考虑钦定某种颜色在其中一个块里),复杂度<span class="math inline">\(O ( m 3^k )\)</span>.</p>
<p>冷静一下,想到斯坦纳树,于是再设一个<span class="math inline">\(g_{ x ,
S }\)</span>表示以<span class="math inline">\(x\)</span>为根且<span class="math inline">\(x\)</span>只有一个儿子,<span class="math inline">\(S\)</span>的定义类似的方案数.这样我们就可以用斯坦纳树的换根技巧计数.很厉害.</p>
<p>这个故事告诉我们:对于图论计数问题(尤其是和树有关),<span class="math inline">\(m\)</span>大概率可以转化为<span class="math inline">\(n\)</span>,但是需要一些小技巧(例如斯坦纳树)</p>
<h5><span id="example2p7142">Example2(P7142)</span></h5>
<p>类似宝藏那个题,我们考虑设<span class="math inline">\(f_{ d , S_1 ,
S_2 }\)</span>表示<span class="math inline">\(S_1\)</span>中的点到<span class="math inline">\(1\)</span>的距离<span class="math inline">\(&lt;
d\)</span>,<span class="math inline">\(S_2\)</span>中的点到<span class="math inline">\(1\)</span>的距离<span class="math inline">\(=
d\)</span>.然后枚举到<span class="math inline">\(1\)</span>的距离<span class="math inline">\(= d + 1\)</span>的点集,这一部分复杂度是<span class="math inline">\(O ( n 3^n
)\)</span>,预处理一下不同情况的答案即可.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<p>大概是如果多组询问那复杂度是错误的,但是如果我全局求,那我<span class="math inline">\(\sum\)</span>起来的总复杂度大概是对的.经典问题是树上背包.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定一颗二叉树,求对于每一个<span class="math inline">\(x\)</span>,满足<span class="math inline">\(x , y ,
z\)</span>互不相同的三元组<span class="math inline">\(( x , y , z
)\)</span>的价值(定义为两两距离之和对<span class="math inline">\(L\)</span>取膜)的最大值是多少.<span class="math inline">\(n \leq 3000\)</span>.</p>
<p>乍一看,二叉树,想到换根后做dsu on tree+set.但是<span class="math inline">\(O ( n^2 \log^2 n
)\)</span>实在是跑不过去.冷静一下,除去三点共线的情况,考虑三个点在二叉树上的两两LCA一定只有两个点,枚举其中深度较浅的那个点并枚举其子树中的两个点和子树外的一个点.假设其子树内有<span class="math inline">\(x\)</span>个点对,子树外有<span class="math inline">\(y\)</span>个点,注意到<span class="math inline">\(\sum x = n^2 \land \sum y \leq
n^2\)</span>,于是总复杂度<span class="math inline">\(O ( n^2 \log n
)\)</span>.</p>
<h3><span id="字典序相关">字典序相关</span></h3>
<p>题目中询问满足条件的字典序第<span class="math inline">\(k\)</span>小之类的问题,通常采用转化为计数问题.</p>
<h5><span id="example12022noip十连测day88ady">Example1([2022noip十连测day8]8ady)</span></h5>
<p>首先,我们肯定想如果知道<span class="math inline">\(a\)</span>,我们怎么求出<span class="math inline">\(b\)</span>.</p>
<p>首先不难发现,我们可以这么还原:先开一个堆,然后先将前<span class="math inline">\(m - 1\)</span>个位置扔进堆里,从第<span class="math inline">\(m\)</span>个位置开始,假设现在到了第<span class="math inline">\(i\)</span>个位置<span class="math inline">\(( m
\leq i \leq n )\)</span>,每次将<span class="math inline">\(a_i\)</span>扔进堆里,并从堆中取最小元素扔到<span class="math inline">\(i - m +
1\)</span>位置,最后把堆清空到剩下的位置即可.</p>
<p>大量实验证明:这种反向构造思路,你用个堆通常是做不动的.</p>
<p>我们考虑有没有别的做法.</p>
<p>一个一个数地考虑,<span class="math inline">\(b_1\)</span>在<span class="math inline">\(a\)</span>中的位置应该在哪?显然是应该在<span class="math inline">\([ 1 , m
]\)</span>中,而且根据上面的堆的做法,显然它应该是<span class="math inline">\([ 1 , m
]\)</span>中最小的数字,换句话说,我们需要满足:<span class="math inline">\([ 1 , m ]\)</span>中除它以外的数字都比它大.</p>
<p>我们继续考虑<span class="math inline">\(b_2\)</span>,显然它在<span class="math inline">\(a\)</span>中应该在<span class="math inline">\([ 1
, m + 1 ]\)</span>中,并且需要满足<span class="math inline">\([ 1 , m + 1
]\)</span>中的所有数字除了<span class="math inline">\(b_1\)</span>,都比它大.</p>
<p>以此类推.不难注意到对于一个数<span class="math inline">\(b_i\)</span>,其中<span class="math inline">\(1
\leq i \leq n - m + 1\)</span>,它能填回的原序列的位置一定最大最大是<span class="math inline">\([ 1 , m + i - 1
]\)</span>,并且如果它能填到区间<span class="math inline">\([ l , r
]\)</span>中,这个区间中除去在它之前填进来的数字以外,均比它大.</p>
<p>但是,这显然是个上界.这个区间能不能缩小一下呢?</p>
<p>对于一个<span class="math inline">\(i\)</span>,我们找到最大的<span class="math inline">\(j\)</span>满足<span class="math inline">\(1 \leq j
&lt; i\)</span>并且<span class="math inline">\(b_j &gt;
b_i\)</span>(有可能找不到).</p>
<p>冷静一下,显然,<span class="math inline">\(b_i\)</span>不能填到<span class="math inline">\([ 1 , j + m - 1
]\)</span>.(因为如果它扔在这里,那它就:在<span class="math inline">\(j\)</span>出堆前入堆,在<span class="math inline">\(j\)</span>出堆后出堆,显然不合法)</p>
<p>也就是说,我们将每个数能填的区间缩小为了<span class="math inline">\([
j + m , i + m - 1 ]\)</span>.</p>
<p>那是不是说每个数只要填在这个区间中,就一定合法呢?</p>
<p>我们考虑一个数<span class="math inline">\(i\)</span>以及所有比它小且在它后面的数字<span class="math inline">\(j\)</span>,当<span class="math inline">\(j = i +
1\)</span>时,显然<span class="math inline">\(j\)</span>只有一种选择,直接填上;当<span class="math inline">\(j = i + 2\)</span>时,若<span class="math inline">\(i + 1\)</span>已经选择好了,那<span class="math inline">\(j\)</span>显然也只有一种选择,填上.这样,对于所有<span class="math inline">\(i\)</span>,如果它前面有一个大于它的数字,那它一定只有一个位置可以填.</p>
<p>这样我们就可以简化为:给定<span class="math inline">\(b\)</span>数组单调递增的问题.不难发现该条件下<span class="math inline">\(i\)</span>可以选择的区间是<span class="math inline">\([ 1 , i + m - 1 ]\)</span>,且满足条件一定有解.</p>
<p>冷静一下,这个时候假设新序列长度为<span class="math inline">\(len\)</span>,那显然一共有<span class="math inline">\(m^{ len }\)</span>个满足条件的<span class="math inline">\(a\)</span>序列.注意到这个级别是指数级别.</p>
<p>所以前面一定是按顺序填,直到后面才会打乱顺序.而后面的长度大概也就是个<span class="math inline">\(\log_m k\)</span>,枚举枚举就行.</p>
<h3><span id="前缀和与差分">前缀和与差分</span></h3>
<h5><span id="example1loj3266">Example1(loj3266)</span></h5>
<p>把点都扔到坐标系上,显然到一个点曼哈顿距离相等的数一定在一个正方形(对角线平行于坐标轴)上.</p>
<p>我们考虑如果已知两个点,怎么找第三个点的坐标,显然是两个正方形的边界的交点,那也就是说,曼哈顿距离下,一个等边三角形必定有两个点所在直线与坐标轴成<span class="math inline">\(45
\degree\)</span>角,那这两个点必然和另一个点组成了一个等腰直角三角形(欧几里得意义下),我们枚举等腰直角三角形的直角顶点和直角边长就可以确认这两个点的坐标,而另一个点一定在一条与坐标轴成<span class="math inline">\(45 \degree\)</span>的斜线上,可以使用前缀和做.</p>
<p>注意到有的点对可能会被算两遍,要特判.</p>
<h5><span id="example2">Example2</span></h5>
<p>小孔在玩卡牌游戏.众所周知,在卡牌游戏里,过牌是很关键的,所以目前小孔的牌库中,只可能有数字牌<span class="math inline">\(0 , 1 , 2 , 3 , 4\)</span>.</p>
<p>数字牌<span class="math inline">\(x\)</span>的含义是当你打出它的时候,会从牌库的顶端抽<span class="math inline">\(x\)</span>张牌到自己手里,若牌库中不足<span class="math inline">\(x\)</span>张牌,则将牌库抽空为止.打出的数字牌<span class="math inline">\(x\)</span>会放入弃牌堆中.在题目中你可以认为这张牌不会再被用到了.</p>
<p>目前,牌库里有<span class="math inline">\(n\)</span>张牌,从牌堆顶到牌堆底数第<span class="math inline">\(i\)</span>张牌为数字牌<span class="math inline">\(a_i\)</span>.在开始回合时,发牌员会进行一次切牌,切牌的结果是从牌堆顶到牌堆底的牌的顺序变为了<span class="math inline">\(a_s , a_{ s + 1 } , . . . , a_n , a_1 , . . . ,
a_{ s − 1 }\)</span>.</p>
<p>接着,小孔会抽<span class="math inline">\(k\)</span>张牌堆顶的牌到自己手上.每次小孔可以打出一张牌,但这一回合中小孔至多打出<span class="math inline">\(p\)</span>张牌.小孔可以在任意时刻结束回合.</p>
<p>请问,这一回合中若小孔使用最优策略,那么牌库里最少还剩多少牌.进一步地,有<span class="math inline">\(q\)</span>次这样的询问,每次询问给定三个整数<span class="math inline">\(s , k ,
p\)</span>,你需要输出牌库里最少还剩多少牌.<span class="math inline">\((
n , q \leq 3 \times 10^5 )\)</span>.</p>
<p>每次询问是独立的,也就是说每次询问并不会以任何方式影响到之后的询问.</p>
<p>首先我们想一下我们需要知道什么:我们需要知道其在这一回合中打出的各种牌的数量是多少.而只要知道这一点,我们自然得到了答案是多少.注意到每次一定优先打出手头上最大的牌.</p>
<p>我们设<span class="math inline">\(sum_{ t , i
}\)</span>表示从开始到抽完第<span class="math inline">\(i\)</span>张牌<strong>之前</strong>,在只用大于<span class="math inline">\(t\)</span>的牌的前提下,还能往下抽多少张牌.显然<span class="math inline">\(sum_{ t , 0 } = 0\)</span>并且<span class="math inline">\(sum_{ t , i } = sum_{ t , i - 1 } + a_{ i - 1 } [
a_{ i - 1 } &gt; t ] - 1\)</span>.注意到<span class="math inline">\(sum_{ t , i } = 0\)</span>就抽不了第<span class="math inline">\(i\)</span>张牌了.不考虑还能抽负数张牌的情况,注意到<span class="math inline">\(sum\)</span>数组具有可差分性!</p>
<p>那我们一开始抽了<span class="math inline">\(k\)</span>张牌,也就是令<span class="math inline">\(sum_{ s + 1 } \leftarrow sum_{ s + 1 } +
k\)</span>,那第一个不能继续抽牌的地方显然也就是第一个满足<span class="math inline">\(sum_{ i } - sum_{ s } \leq
0\)</span>的地方,用原本的<span class="math inline">\(sum\)</span>数组表示也就是<span class="math inline">\(sum_{ i } + k \leq sum_{ s
}\)</span>.那第二个地方呢?由于后面的<span class="math inline">\(sum\)</span>都加上<span class="math inline">\(k\)</span>了,第二个地方也就是满足<span class="math inline">\(sum_j \leq sum_{ i } -
t\)</span>的地方(不过注意到后面要倍增,所以直接写<span class="math inline">\(sum_j &lt;
sum_i\)</span>也可以,这样方便用单调栈维护这个东西).以此类推,注意到这个东西和询问无关,可以使用倍增预处理,处理的过程中判断一下还有没有大小为<span class="math inline">\(t\)</span>的牌以及用牌总数是否小于等于<span class="math inline">\(p\)</span>即可.都是可以用前缀和之类的东西预处理的.最后从小的牌开始选,选完之后的牌就可以当成<span class="math inline">\(0\)</span>牌了.另外要注意:我们要保证目前一定有大小为<span class="math inline">\(t\)</span>的牌选,所以需要在做之前判断一下最后一次选择大小为<span class="math inline">\(t\)</span>的牌的位置是在哪里.</p>
<p>等一下,注意到我们好像没啥办法判断还有没有大小为<span class="math inline">\(t\)</span>的牌.有一个方法是:我们直接令所有<span class="math inline">\(\leq t - 1\)</span>的牌变成<span class="math inline">\(t\)</span>,并处理出不用<span class="math inline">\(\leq t -
1\)</span>的牌能跑到的最右点,然后取个<span class="math inline">\(\min\)</span>.</p>
<p>想出<span class="math inline">\(sum\)</span>数组并发现可差分性后,这个题突然就变可做了.问题来了:咋想到的<span class="math inline">\(sum\)</span>数组,又是怎么发现的可差分性?</p>
<p>首先,由于切牌这个环节会变化起点.所以有两种可能:要么是像倍增那样起点不定,要么是像差分一样其它起点的答案可以由原本的起点答案得到.那想到差分后呢?又注意到一定会先选较大的牌,所以大概率可以分层考虑:这样就先把问题转化为只有<span class="math inline">\(0 / 1\)</span>或者是只有<span class="math inline">\(0 / 1 /
2\)</span>的情况再继续考虑.由于要多组询问,所以答案一定是可以通过某种方式迅速算出来的,考虑到只要得到每种牌选的次数就可以快速算答案.又有一定是比它大的牌都选完了才选它,于是考虑第一次选不了其它牌只能选它的地方.注意到这个地方可以使用前缀和在变换起点的情况下求.于是由前缀和判断差分性质.</p>
<h3><span id="二分答案">二分答案</span></h3>
<h5><span id="example12022qbxt国庆day6kth">Example1([2022qbxt国庆Day6]kth)</span></h5>
<p>考虑<span class="math inline">\(f\)</span>的取值不会很多,我们可以枚举<span class="math inline">\(f\)</span>的取值,并把相同取值的归类.也就是,对于<span class="math inline">\(f = i\)</span>的类别里也就是后<span class="math inline">\(i\)</span>位为<span class="math inline">\(0\)</span>,第<span class="math inline">\(i\)</span>位为<span class="math inline">\(1\)</span>的那些数.</p>
<p>注意到每个类别内部是很有序的,也就是说我们可以采取类似初赛归并排序的方法二分,找到前<span class="math inline">\(k\)</span>大的和.</p>
<p>调了一年,这个故事告诉我们,如果一个东西暴力调整能过/复杂度均摊,就不要写一些很丑的很难写的即使更快的东西去做.</p>
<h5><span id="example2">Example2</span></h5>
<p>给你一棵<span class="math inline">\(n\)</span>个点的树,每条边是一个字符(字符集是小写字母),一个点的所有相邻边边权不同.</p>
<p>有<span class="math inline">\(m\)</span>次操作:每次询问给出点<span class="math inline">\(x\)</span>和字符串<span class="math inline">\(S\)</span>,<span class="math inline">\(S\)</span>中不包含相同字符,<span class="math inline">\(| S | = 26\)</span>,每次修改会修改一条边边权.</p>
<p>从<span class="math inline">\(x\)</span>点开始,每次对与<span class="math inline">\(x\)</span>点相邻的边,对这些边找出其边权在<span class="math inline">\(S\)</span>中出现的位置,找出边权出现位置最靠前的边,然后走过去.</p>
<p>每次询问走过的边直接从树上删除,一条边正反方向算同一条边,也就是说没法<span class="math inline">\(x \rightarrow y \rightarrow x\)</span>.</p>
<p>这个过程会停机,你需要输出在哪个点停下来,询问之间独立.</p>
<p>这题最重要的思想在于:我们首先需要将这个问题改成一个判定性问题:判定性问题显然弱于找到答案.</p>
<p>怎么判定呢?对于一条路径,如果我们要沿着它走,那么我们就可以确定每个点的最小边(或者次小边),这等价于给出若干个边之间的大小关系,可以使用bitset维护一下,最后判定即可.我们发现判定数组是可以合并的,于是这玩意可以扔到线段树上维护.</p>
<p>会了判定这题就做完了,做树链剖分,然后开始从下往上跳重链,能跳到顶端就跳,不然二分跳到哪里,下去是同理的,只不过下去的二分需要多个<span class="math inline">\(\log n\)</span>.</p>
<h3><span id="整体二分">整体二分</span></h3>
<p>通常解决在二分的情况下,单次check的复杂度比较高的问题.思想是把所有询问共同的check一起做.</p>
<p>整体二分的具体复杂度往往需要现场分析.</p>
<p>最常用的整体二分的写法是分治.但是有的问题(例如不能撤销)可能不太好写分治.</p>
<p>还有一种方式是,我们把所有询问一字排开,然后求出每个询问当前二分的<span class="math inline">\(mid\)</span>,然后顺序处理或者别的什么处理方式做这些<span class="math inline">\(mid\)</span>.</p>
<h5><span id="example1agc002dstamp-rally">Example1([AGC002D]Stamp Rally)</span></h5>
<p>直接整体二分,注意需要做可撤销并查集之类的东西.</p>
<h3><span id="分治">分治</span></h3>
<h5><span id="example1平面最近点对">Example1(平面最近点对)</span></h5>
<p>按照<span class="math inline">\(x\)</span>轴排序,递归做两边的子问题,假设两边问题的最小值为<span class="math inline">\(d\)</span>,对着<span class="math inline">\(d\)</span>做中间的问题.</p>
<h5><span id="example2cf1764g3doremys-perfect-ds-class-hard-version">Example2([CF1764G3]
Doremy’s Perfect DS Class (Hard Version))</span></h5>
<p>有一个<span class="math inline">\([ 1 , n ]\)</span>的排列<span class="math inline">\(p\)</span>,每次可以询问<span class="math inline">\(l , r , k\)</span>,交互库会返回<span class="math inline">\(\lfloor \frac{ p_l }{ k } \rfloor , \lfloor \frac{
p_{ l + 1 } }{ k } \rfloor , \cdots , \lfloor \frac{ p_r }{ k }
\rfloor\)</span>中不同数字的个数,你需要在<span class="math inline">\(20\)</span>次询问内找到<span class="math inline">\(p\)</span>中<span class="math inline">\(1\)</span>的位置.</p>
<p>第一反应就是令<span class="math inline">\(k =
2\)</span>,然后如果<span class="math inline">\(n\)</span>是奇数,不难发现此时只有<span class="math inline">\(1\)</span>自己一个人一组.一个自然的想法是,我们可以对于每个位置<span class="math inline">\(i\)</span>,查询<span class="math inline">\([ 1 , i
- 1 ]\)</span>和<span class="math inline">\([ 1 , i
]\)</span>的答案,如果答案一样,那这个位置肯定不是<span class="math inline">\(1\)</span>.如果不一样,我们再查一下<span class="math inline">\([ i , n ]\)</span>和<span class="math inline">\([
i + 1 , n ]\)</span>.由于<span class="math inline">\(1\)</span>不会和左右任意一个人配对,不难发现如果这两种情况都不一样,那这里一定是<span class="math inline">\(1\)</span>,这样我们就做到了<span class="math inline">\(2 n - 2\)</span>次查询.</p>
<p>那么如何优化呢?我们冷静一下,如果我们查询一个区间<span class="math inline">\([ l , r ]\)</span>,那么得到的答案自然是<span class="math inline">\(len
-\)</span>配对数字都在区间内的对数,因此我们自然也能得到这个区间的未配对数.这个时候发现,对于位置<span class="math inline">\(i\)</span>,如果我们查询<span class="math inline">\([ 1 , i ]\)</span>和<span class="math inline">\([
i + 1 , n ]\)</span>,由于这两个区间内没配对的数字要么是<span class="math inline">\(1\)</span>,要么会和另一个区间中的数字配对,因此这两个区间中,未配对数多的那个一定包含<span class="math inline">\(1\)</span>.这样就可以通过<span class="math inline">\(k\)</span>不断向下二分,最后只需要<span class="math inline">\(20\)</span>步操作就可以解决<span class="math inline">\(n\)</span>是奇数的情况.</p>
<p>那么<span class="math inline">\(n\)</span>是偶数怎么办呢?这个时候<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>都没人配对.我们需要找到<span class="math inline">\(n\)</span>并将它杀掉.注意到<span class="math inline">\(k\)</span>可以取别的数,我们如果只是让<span class="math inline">\(k = 2\)</span>未免有些弱,而且看上去也区分不了<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>,而不难发现,令<span class="math inline">\(k = n\)</span>就可以找到<span class="math inline">\(n\)</span>在哪里,于是可以先找<span class="math inline">\(n\)</span>再找<span class="math inline">\(1\)</span>,需要<span class="math inline">\(40\)</span>步.</p>
<p>那怎么继续优化呢?我们还是令<span class="math inline">\(k =
2\)</span>,查询<span class="math inline">\([ 1 , i ]\)</span>和<span class="math inline">\([ i + 1 , n
]\)</span>,我们发现此时会有两种情况:</p>
<ol type="1">
<li><p>左右两边未配对数量相差<span class="math inline">\(2\)</span>,这个时候<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>一定都在较大的那边,直接递归.</p></li>
<li><p>左右两边未配对数量相等,这个时候一定<span class="math inline">\(1\)</span>在一边,<span class="math inline">\(n\)</span>在另一边,我们可以通过一次查询<span class="math inline">\(k = n\)</span>判断哪边是<span class="math inline">\(n\)</span>.</p></li>
</ol>
<p>于是只需要<span class="math inline">\(21\)</span>次.</p>
<p>但是还是不够,我们从哪里抠出那一次呢?发现最后处理区间<span class="math inline">\([ i , i + 1
]\)</span>还需要两步操作,我们看看能不能省掉一步.</p>
<ol type="1">
<li><p><span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>都在<span class="math inline">\([ i , i
+ 1 ]\)</span>中,我们显然只需要查询一步就可以知道哪边是<span class="math inline">\(n\)</span>.</p></li>
<li><p>只有<span class="math inline">\(1\)</span>在<span class="math inline">\([ i , i + 1
]\)</span>中,我们考虑利用一下前面的信息.注意到我们一定已经知道<span class="math inline">\([ 1 , i - 1 ] , [ i , n ] , [ 1 , i + 1 ] , [ i +
2 , n ]\)</span>的答案(如果区间为空或者区间为<span class="math inline">\([ 1 , n
]\)</span>显然我们也知道答案),假设这个区间中的两个数是<span class="math inline">\(1\)</span>和<span class="math inline">\(x\)</span>,<span class="math inline">\(x \in ( 1 ,
n )\)</span>,那么<span class="math inline">\(x\)</span>一定有一个和它配对的数字,我们考虑通过<span class="math inline">\([ 1 , i - 1 ]\)</span>和<span class="math inline">\([ 1 , i + 1 ]\)</span>就可以知道和<span class="math inline">\(x\)</span>配对的数字在<span class="math inline">\([ 1 , i - 1 ]\)</span>还是在<span class="math inline">\([ i + 2 , n
]\)</span>.接下来只需要一步判断就可以找到<span class="math inline">\(1\)</span>了.</p></li>
</ol>
<h5><span id="example3xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopentraisncontest-1489d-nice-set-of-points">Example3(XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(opentraisn
contest 1489)D Nice Set of Points)</span></h5>
<p>给定一个点集<span class="math inline">\(S = \{ ( x , y )
\}\)</span>,<span class="math inline">\(( x_1 , y_1 )\)</span>和<span class="math inline">\(( x_2 , y_2 )\)</span>可达当且仅当<span class="math inline">\(x_1 = x_2 \lor y_1 =
y_2\)</span>.称一个点集是好的当且仅当这个点集中任意两个点的最短距离是它们的曼哈顿距离.给出一个点集,大小为<span class="math inline">\(N\)</span>,<span class="math inline">\(1 \leq N
\leq 1000\)</span>,加入不多于<span class="math inline">\(10000 -
N\)</span>个点使得这个点集变成好的.</p>
<p>找一条分界线<span class="math inline">\(x =
d\)</span>,我们将这条线左右两边的点全都作出在这条线上的投影点,将这些投影点全都加入,不难发现左右两边之间的路径就合法了,继续递归就行.</p>
<h5><span id="example4cf1442dsum">Example4([CF1442D]Sum)</span></h5>
<p>一个自然的想法是由于越靠后的可能越优秀,所以应该是要不断往后挖的.具体地,我们发现只可能有一个数组被选了一部分,剩下的数组要么不选,要么全选.</p>
<p>为什么呢?假设有两个数组各选了一部分,不妨假设它们最后选的数分别是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,下一个未选的数分别是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>,有<span class="math inline">\(c \geq a
, d \geq b\)</span>,假设<span class="math inline">\(a \geq
b\)</span>,那么自然有<span class="math inline">\(c \geq
b\)</span>,于是我们把<span class="math inline">\(b\)</span>删掉换成<span class="math inline">\(c\)</span>一定更优秀.</p>
<p>有了这个性质后,我们可以枚举是哪个数组只选了一部分,然后求出剩下部分的背包,背包部分可以求前缀和后缀最后合并起来,我们的复杂度就是<span class="math inline">\(O ( nk^2 )\)</span>.</p>
<p>但这个复杂度还是不太够,如何优化呢?</p>
<p>注意到这里的背包是支持撤销操作的,我们考虑一个分治做法:每次做到<span class="math inline">\([ l , r ]\)</span>的时候,假设此时<span class="math inline">\([ 1 , l - 1 ]\)</span>和<span class="math inline">\([ r + 1 , n ]\)</span>都加入答案了,我们把<span class="math inline">\([ mid + 1 , r
]\)</span>也加入背包,然后递归求解<span class="math inline">\([ l , mid
]\)</span>,然后再撤销,同样的方法求解右边的答案.复杂度<span class="math inline">\(O ( nk \log n )\)</span>.</p>
<h5><span id="example5agc044d">Example5(AGC044D)</span></h5>
<p>这题在于分治后归并,考虑我们是可以快速判断一个串是否是原串的子序列的,就是判断它们的编辑距离是否恰好等于长度之差.而我们也可以快速判断每个字母在原串中出现了多少次,只需要询问<span class="math inline">\(L\)</span>个这个字母然后看编辑距离就是替换的次数.这样我们考虑对字母分治,<span class="math inline">\([ l , r ]\)</span>表示只用到<span class="math inline">\([ l , r
]\)</span>中的字母,得到的极长的原串的子序列是什么.边界情况<span class="math inline">\([ l , l ]\)</span>是好处理的,对于<span class="math inline">\([ l , r ]\)</span>,我们考虑归并,合并<span class="math inline">\([ l , mid ]\)</span>和<span class="math inline">\([ mid + 1 , r
]\)</span>的时候不断判断当前串是否是子序列就行.</p>
<h3><span id="倍增">倍增</span></h3>
<p>顺便一提,倍增比二分方便的一点在于:倍增能迅速确定答案的规模,这在复杂度与答案规模有关的时候至关重要.</p>
<h5><span id="example1scoi2015国旗计划">Example1([SCOI2015]国旗计划)</span></h5>
<p>先破环成链,然后设<span class="math inline">\(f_{ i , j
}\)</span>表示从<span class="math inline">\(i\)</span>这个人,途径<span class="math inline">\(2^j\)</span>个人后能到达的最远的人是谁,然后就可以直接通过倍增处理.</p>
<h5><span id="example2pkusc2018星际穿越">Example2([PKUSC2018]星际穿越)</span></h5>
<h5><span id="example3cf1523hhopping-around-the-array">Example3(CF1523H
Hopping Around the Array)</span></h5>
<p>类似国旗计划,只不过需要用背包合并一维.</p>
<p>不过吧,这题有个问题在于最后的询问,我们要每次判断当前越界的点的代价是否小于等于dp数组的代价,如果小就回撤dp数组(因为无论如何都必不可能在这里选择).</p>
<h5><span id="example4loj3665">Example4(loj3665)</span></h5>
<p>思考一下发现,走相同的步数能到的点一定是一段区间,于是考虑使用倍增算法,设<span class="math inline">\(f_{ x , i }\)</span>表示从<span class="math inline">\(x\)</span>走<span class="math inline">\(2^i\)</span>步能到的区间,转移是简单的RMQ问题.</p>
<p>但是初值怎么求呢?先考虑右端点怎么求.对于每个路线<span class="math inline">\(j\)</span>,它会把<span class="math inline">\([ A_j
, A_j + k - 1 ]\)</span>能到达的右端点与<span class="math inline">\(B_j\)</span>取<span class="math inline">\(\max\)</span>,由于查询在修改之后,所以这个东西很好做.</p>
<h5><span id="example5cf1707e">Example5(CF1707E)</span></h5>
<p>引理1:如果<span class="math inline">\([ l , r ] \subseteq [ L , R
]\)</span>,则<span class="math inline">\(f ( ( l , r ) ) \subseteq f ( (
L , R ) )\)</span>.</p>
<p>引理2:如果<span class="math inline">\([ L , R ] = [ l_1 , r_1 ] \cup
[ l_2 , r_2 ]\)</span>,则<span class="math inline">\(f ( ( L , R ) ) = f
( ( l_1 , r_1 ) ) \cup f ( ( l_2 , r_2 ) )\)</span>.</p>
<p>引理1显然,引理2是因为<span class="math inline">\([ L , R
]\)</span>中的最大值和最小值一定都被后面的两个部分取到.</p>
<p>于是,考虑<span class="math inline">\([ l , r ] = \cup_{ i = l }^{ r -
1 } [ i , i + 1 ]\)</span>,就可以倍增了.</p>
<p>考虑求出每个单点的倍增数组,那么总区间的倍增数组也就是这些数组的最小值和最大值.</p>
<p>大概做一下.</p>
<h5><span id="example622zr提高组十连测day6百分号">Example6([22zr提高组十连测day6]百分号)</span></h5>
<p>首先看上去多组询问给定起点终点看上去就很像倍增.</p>
<p>一个很自然的设计是<span class="math inline">\(L_{ x , i
}\)</span>表示从<span class="math inline">\(x\)</span>这个点跳<span class="math inline">\(2^i\)</span>所能到达的最左端的点,<span class="math inline">\(R_{ x , i
}\)</span>同理.但是能跳到最远的点不一定能跳到一个较近的点,那咋办呢?</p>
<p>冷静一下,注意到我们好像还没有用到括号序列的性质:两个跳跃要么包含要么不交,不可能出现第三种情况.</p>
<p>所以,如果目前能跳到的最远的点为<span class="math inline">\(l ,
r\)</span>,那么再跳一步能到达的最远的点一定是从<span class="math inline">\(l\)</span>或<span class="math inline">\(r\)</span>跳过去的.考虑反证这个结论,设能从<span class="math inline">\(( l , r )\)</span>中的一个点<span class="math inline">\(k\)</span>跳到更远的点,那么由于之前没跳到过<span class="math inline">\(k\)</span>就跳到<span class="math inline">\(l\)</span>了,所以一定存在一个<span class="math inline">\(i &gt; k\)</span>,<span class="math inline">\(i
\rightarrow l\)</span>,而如果存在<span class="math inline">\(j &lt;
l\)</span>,<span class="math inline">\(k \rightarrow
j\)</span>,显然不满足性质.</p>
<p>同理,我们最后处理询问答案的时候,考虑从<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>都跳.先从<span class="math inline">\(x\)</span>跳到再跳一步就会跳过<span class="math inline">\(y\)</span>的位置,然后把<span class="math inline">\(y\)</span>跳到再跳一步就会跳过<span class="math inline">\(x\)</span>的位置,那么现在的<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>一定相邻,不然分别跳一步就会出现包含的情况,于是一定是最优解.</p>
<h3><span id="对称建立双射">对称/建立双射</span></h3>
<h5><span id="example1cf1627f">Example1(CF1627F)</span></h5>
<p>冷静一下考虑,分界线一定是一个中心对称图形,分成的两部分一定中心对称.那这条分界线一定过中心点.</p>
<p>我们考虑这么一点:如果所有点对都在矩阵一边,我们就可以直接求中心点到矩阵一边的最短路然后对称一下就好了.</p>
<p>而矩阵上遍布点对怎么办呢?我们在和每个点对对称的位置把这个点对复制一遍,然后从中心点找到一条到边界的最短路,把它对称一下即可.</p>
<h5><span id="example2ah2017hnoi2017抛硬币">Example2([AH2017/HNOI2017]抛硬币)</span></h5>
<p>设<span class="math inline">\(A\)</span>的正面朝上为<span class="math inline">\(S_A\)</span>,<span class="math inline">\(B\)</span>的为<span class="math inline">\(S_B\)</span>.设<span class="math inline">\(p_1 =
\sum [ S_A &gt; S_B ] , p_2 = \sum [ S_A = S_B ] , p_3 = \sum [ S_A &lt;
S_B ]\)</span>.</p>
<p>当<span class="math inline">\(a = b\)</span>,翻转所有硬币,自然有<span class="math inline">\(p_1 = p_3\)</span>,又设<span class="math inline">\(P = p_1 + p_2 + p_3 = 2^{ a + b
}\)</span>,于是求得<span class="math inline">\(p_2\)</span>即可得到答案.而<span class="math inline">\(p_2 = \sum_{ i = 0 }^a \binom{ a }{ i } \binom{ b
}{ i }\)</span>,用范德蒙德卷积的变式,有<span class="math inline">\(p_2 =
\binom{ a + b }{ a }\)</span>.</p>
<p>同样,当<span class="math inline">\(a &gt; b\)</span>时.我们设<span class="math inline">\(p_4 = \sum [ a - S_A &gt; b - S_B ] , p_5 = \sum [
a - S_A = b - S_B ] , p_6 = \sum [ a - S_A &lt; b - S_B
]\)</span>.同样是翻转硬币的套路,自然有<span class="math inline">\(p_4 =
p_1 , p_5 = p_2 , p_6 = p_3\)</span>.注意到:<span class="math inline">\(S_A \leq S_B \Rightarrow a - S_A &gt; b -
S_B\)</span>,但逆命题不成立.不妨设<span class="math inline">\(p_7 = \sum
[ S_A &gt; S_B \land a - S_A &gt; b - S_B ]\)</span>.自然有:</p>
<p><span class="math display">\[
p_1 = p_4 = p_7 + p_2 + p_3 = p_7 + P - p_1
\]</span></p>
<p>于是只要求出<span class="math inline">\(p_7\)</span>就可以求得<span class="math inline">\(p_1\)</span>.</p>
<p>考虑<span class="math inline">\(p_7\)</span>如何求,注意到<span class="math inline">\([ S_A &gt; S_B \land a - S_A &gt; b - S_B ] = [ 0
&lt; S_A - S_B &lt; a - b ]\)</span>,我们可以枚举<span class="math inline">\(S_A -
S_B\)</span>,然后继续用范德蒙德卷积的变式.</p>
<h5><span id="example32022qbxt国庆day4c">Example3([2022qbxt国庆Day4]C)</span></h5>
<p>直接考虑对于每一对位置<span class="math inline">\(( i , j ) , i &lt;
j\)</span>,计算它们可能产生的逆序对贡献.注意到每一对对答案的贡献会大概接近<span class="math inline">\(0 .
5\)</span>,我们考虑构造一个双射,判断双射左右是否都会贡献.</p>
<p>设<span class="math inline">\(d_i\)</span>为<span class="math inline">\(i\)</span>个数的错排数量,根据错排公式有<span class="math inline">\(d_n = ( n - 1 ) ( d_{ n - 1 } + d_{ n - 2 }
)\)</span>.接下来讨论一下这两个位置的取值:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(a_i = j , a_j =
i\)</span>,那么一定贡献了逆序对,这里总共贡献为<span class="math inline">\(d_{ n - 2 } \cfrac{ n ( n - 1 ) }{ 2
}\)</span>,一半的贡献也就是<span class="math inline">\(\cfrac{ d_{ n - 2
} n ( n - 1 ) }{ 4 }\)</span>.</p></li>
<li><p>如果<span class="math inline">\(a_i = j , a_j = k , k \ne i \lor
a_i = k , a_j = i , k \ne j\)</span>,考虑前后两者形成双射.如果<span class="math inline">\(k\)</span>在<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间,那么无论前者还是后者,都一定贡献逆序对;不然,则两种情况一定只有一种会贡献逆序对.前者多出的贡献应该是<span class="math inline">\(\cfrac{ n ( n - 1 ) ( n - 2 ) }{ 6 } ( d_{ n - 2 }
+ d_{ n - 3 } )\)</span>,也就是先选出<span class="math inline">\(i &lt;
k &lt; j\)</span>,如果<span class="math inline">\(a_k =
i\)</span>,那么剩余的可能性就是<span class="math inline">\(d_{ n - 3
}\)</span>;不然,也就是说<span class="math inline">\(a_k \ne
i\)</span>,类似于错排公式,剩余的可能性为<span class="math inline">\(d_{
n - 2 }\)</span>.另外,由于<span class="math inline">\(d_{ n - 2 } + d_{
n - 3 } = \cfrac{ d_{ n - 1 } }{ n - 2
}\)</span>,所以上面的贡献也就是<span class="math inline">\(\cfrac{ n ( n
- 1 ) }{ 6 } d_{ n - 1 }\)</span>.</p></li>
<li><p>如果<span class="math inline">\(i , j , a_i ,
a_j\)</span>互不相同,那我们交换<span class="math inline">\(a_i\)</span>和<span class="math inline">\(a_j\)</span>一定可以构造出另一组答案,并且这两组答案中一定只有一组贡献了逆序对,于是二者形成双射.</p></li>
</ol>
<p>除去上面的部分的贡献是<span class="math inline">\(\cfrac{ d_n n ( n -
1 ) }{ 4 }\)</span>.于是总贡献为:<span class="math inline">\(n ( n - 1 )
( \cfrac{ d_{ n - 1 } }{ 6 } + \cfrac{ d_n + d_{ n - 2 } }{ 4 }
)\)</span>.</p>
<h5><span id="example4arc115d">Example4(ARC115D)</span></h5>
<p>第一反应感觉完全不可做.</p>
<p>思考一下,如果我们随便选边肯定完蛋了:我们又不知道选出了几个奇度点,这不完蛋了?</p>
<p>先考虑要求全是偶度点怎么办?</p>
<p>由于点只有奇度点和偶度点两种,如果我能先随便选个边集,再把它删到全是偶度点好像就赢了.但是一方面我咋删啊,一方面这样删有可能删出重复的.又注意到删一条边就一定可以让两个点的奇偶性改变.</p>
<p>我们考虑求出原图的一棵生成树,然后剩下的边随便选.之后从生成树深度较大的点开始考虑:如果这个点是奇度点,我们就把它的父边删掉.容易发现这样是双射.而如果有奇度点的话可以先组合数选出来然后同样做上面的操作,容易发现是一样的.</p>
<p>不同的连通块可以分别做最后卷起来.</p>
<h5><span id="example5hihocoder1230">Example5(Hihocoder1230)</span></h5>
<p>这题最重要的一点在于观察到一组<span class="math inline">\(a\)</span>如果有解,那么一定是唯一解.为啥呢?我们考虑如何构造一个解:从小位到高位枚举,如果当前位所有数异或起来是<span class="math inline">\(1\)</span>,那么<span class="math inline">\(x\)</span>这一位也必然是<span class="math inline">\(1\)</span>,然后加上后进位.这是由于序列长度是奇数.然后就每次对于<span class="math inline">\(a \in [ x , m + x ]\)</span>计数,做FWT就行.</p>
<h5><span id="example623省选10连测-day5b">Example6(23省选10连测 day5B)</span></h5>
<p>首先我们要知道,一轮冒泡排序的过程等价于:从前往后考虑每一个点,如果它前面存在一个比它大的点,就将它和前面的点交换.</p>
<p>于是我们考虑令<span class="math inline">\(b_i = \sum_{ j = 1 }^{ i -
1 } [ a_j &gt; a_i ]\)</span>.也就是每次冒泡排序,这个<span class="math inline">\(b_i\)</span>都会变成<span class="math inline">\(\max \{ b_i - 1 , 0 \}\)</span>.显然<span class="math inline">\(b_i\)</span>需要满足的条件是<span class="math inline">\(b_i \in [ 0 , n - i
]\)</span>,接下来我们证明:只要满足这个条件,<span class="math inline">\(b\)</span>和<span class="math inline">\(a\)</span>就是双射关系.根据<span class="math inline">\(a\)</span>还原<span class="math inline">\(b\)</span>是简单的,那么如何根据<span class="math inline">\(b\)</span>还原<span class="math inline">\(a\)</span>呢?我们只需要从大向小考虑元素,就可以判断元素插入哪里.</p>
<p>有了这个条件后,我们不妨设原序列是<span class="math inline">\(a
&#39;\)</span>,其对应<span class="math inline">\(b
&#39;\)</span>,那么显然<span class="math inline">\(b_i = \max \{ 0 , b_i
&#39; - m \} \leq \max \{ 0 , n - i - m \}\)</span>.也就是说,如果<span class="math inline">\(b_i = 0\)</span>,那么<span class="math inline">\(b_i &#39; \in [ 0 , m ]\)</span>,反之<span class="math inline">\(b_i &#39; = b_i +
m\)</span>.但问题在于:我们如何保证<span class="math inline">\(b_i &#39;
\in [ 0 , n - i
]\)</span>呢?不难发现,冒泡排序每次会把前面最大的数扔到后面,也就是说整个序列最后的<span class="math inline">\(m\)</span>个数一定有序,那我们分开考虑:对于最后的<span class="math inline">\(m\)</span>个数,它一开始在序列中的相对顺序是无所谓的:无论如何都会扔到最后.而对于其它的数,如果<span class="math inline">\(b_i = 0\)</span>,<span class="math inline">\(b_i
&#39; \in [ 0 , m ]\)</span>,由于最后都已经凑出<span class="math inline">\(m\)</span>个数了,从大向小将数字插入,一定可以使这一部分满足条件.而如果<span class="math inline">\(b_i &gt; 0\)</span>,由于有判定条件<span class="math inline">\(b_i \leq \max \{ 0 , n - i - m
\}\)</span>,显然满足.于是我们设一共有<span class="math inline">\(k\)</span>个<span class="math inline">\(b_i =
0\)</span>的位置(也就是前缀最大值位置),于是自然有<span class="math inline">\(f ( a , m ) = ( m + 1 )^k m
!\)</span>.注意这个式子的前提在于判定每个<span class="math inline">\(b_i
\leq \max \{ 0 , n - i - m \}\)</span>以及<span class="math inline">\(a\)</span>的最后<span class="math inline">\(m\)</span>个位置是<span class="math inline">\(n -
m + 1 , \cdots , n - 1 ,
n\)</span>.到这里不难发现只要满足后者前者必定满足.现在只需要统计前缀最大值的个数就可以解决这个问题了.这个设计个<span class="math inline">\(dp_{ i , j }\)</span>表示前<span class="math inline">\(i\)</span>个数的最大值是<span class="math inline">\(j\)</span>就行.</p>
<h3><span id="拆多项式">拆多项式</span></h3>
<p>通常适用于数据范围中有一项的范围不大的情况,然后拆成多项式后可以带入另一项较大的值.</p>
<h5><span id="example122zr提高组十连测day5可">Example1([22zr提高组十连测day5]可)</span></h5>
<p>首先考虑数位dp,每次枚举当前的<span class="math inline">\(k\)</span>个数中还有<span class="math inline">\(x\)</span>个数被limit,这次又有<span class="math inline">\(y\)</span>个数不用被limit,再枚举一下当前各位之和,然后可以写一个转移,复杂度<span class="math inline">\(O ( k^4 \lg x )\)</span></p>
<p>然后想了好久发现这个东西好像优化不动了.</p>
<p>冷静一下,注意到问题在于枚举,我们不妨把枚举换成容斥试试.设<span class="math inline">\(g ( x )\)</span>为<span class="math inline">\(\sum
a\)</span>为<span class="math inline">\(x\)</span>的方案数,那么可以通过容斥得知:</p>
<p><span class="math display">\[
g ( n ) = \sum_{ i = 0 }^k ( - 1 )^i \binom{ k }{ i } \binom{ n - i ( x
+ 1 ) + k - 1 }{ k - 1 }
\]</span></p>
<p>我们最后要求的答案也就是<span class="math inline">\(\sum f ( n ) g (
n )\)</span>,继续推式子:</p>
<p><span class="math display">\[
ans = \sum_{ n = 0 }^{ kx } f ( n ) g ( n ) = \sum_{ n = 0 }^{ kx } f (
n ) \sum_{ i = 0 }^k ( - 1 )^i \binom{ k }{ i } \binom{ n - i ( x + 1 )
+ k - 1 }{ k - 1 }
\]</span></p>
<p><span class="math display">\[
= \sum_{ i = 0 }^k ( - 1 )^i \binom{ k }{ i } \sum_{ n = 0 }^{ kx } f (
n ) \binom{ n - i ( x + 1 ) + k - 1 }{ k - 1 }
\]</span></p>
<p>看上去好像推不动了.</p>
<p>冷静一下,会发现<span class="math inline">\(n\)</span>的取值远远大于<span class="math inline">\(i ,
k\)</span>的取值.于是我们选择把组合数拆成一个<span class="math inline">\(k -
1\)</span>次多项式,这样只需要处理出这个多项式的每一项的系数,然后就可以预处理后面的东西.</p>
<p>拆二项式系数的时候要注意特判上指标小于下指标的情况.</p>
<p><span class="math display">\[
ans = \sum_{ i = 0 }^k ( - 1 )^i \binom{ k }{ i } \sum_{ j = 0 }^{ k - 1
} c_{ i , j } \sum_{ n = i ( x + 1 ) }^{ kx } f ( n ) n^j
\]</span></p>
<p>其中<span class="math inline">\(c_{ i , j } = [ n^j ] \binom{ n - i (
x + 1 ) + k - 1 }{ k - 1 }\)</span>.</p>
<p>这样我们就成功地分离出了一项<span class="math inline">\(\sum_{ n = i
( x + 1 ) }^{ kx } f ( n ) n^j\)</span>,接下来考虑怎么处理这一项.</p>
<p>考虑枚举<span class="math inline">\(i\)</span>,然后设<span class="math inline">\(dp_{ j , limit } = \sum_{ n = 0 }^{ limit } f ( n
) n^j\)</span>,考虑拿数位dp做这个东西,枚举当前位置<span class="math inline">\(cnt\)</span>的取值<span class="math inline">\(w\)</span>,根据二项式定理,<span class="math inline">\(dp_{ a + b , limit } \leftarrow \binom{ a + b }{ b
} dp_{ b , limit } f ( w ) ( w 10^{ cnt } )^a\)</span>,那么<span class="math inline">\(\sum_{ n = i ( x + 1 ) }^{ kx } f ( n ) n^j = dp_{
j , kx } - dp_{ j , i ( x + 1 ) - 1 }\)</span>.</p>
<p>这样我们需要枚举<span class="math inline">\(i , a , b ,
cnt\)</span>得到一组答案,然后还需要把这些答案合并起来,复杂度<span class="math inline">\(O ( k^3 \lg x )\)</span>.</p>
<h3><span id="抽屉原理">抽屉原理</span></h3>
<h5><span id="example1unr-6小火车">Example1([UNR #6]小火车)</span></h5>
<p>首先考虑证明一定有解:</p>
<p>注意到我们可以先选择出两个不完全相同的集合,如果这两个集合的和相等,那么我们把只在第一个集合的<span class="math inline">\(b\)</span>设为<span class="math inline">\(-
1\)</span>,只在第二个集合的<span class="math inline">\(b\)</span>设为<span class="math inline">\(1\)</span>,都在或都不在的设为<span class="math inline">\(0\)</span>,那么这显然就是一组解.</p>
<p>而由于<span class="math inline">\(p &lt;
2^n\)</span>,根据抽屉原理,显然存在这么两个集合.</p>
<p>考虑对于一个权值区间<span class="math inline">\([ l , r
]\)</span>,如果有超过<span class="math inline">\(r - l +
1\)</span>个集合的和在这个区间内,那一定有两个集合可以组成一个解.</p>
<p>假设现在已知权值区间<span class="math inline">\([ l , r
]\)</span>一定有解,我们判断<span class="math inline">\([ l , mid
]\)</span>中是否有超过<span class="math inline">\(mid - l +
1\)</span>个集合,使用折半搜索再合并可以快速求出权值和为某个定值的集合有多少个.然后可以使用双指针判断,继续递归下去判断即可.复杂度<span class="math inline">\(O ( 2^{ \frac{ n }{ 2 } } n )\)</span>.</p>
<h5><span id="example2noi2021量子通信">Example2([NOI2021]量子通信)</span></h5>
<p>考虑<span class="math inline">\(k \leq
15\)</span>,所以如果我们把两个零一串每<span class="math inline">\(16\)</span>个分一块,那么两个零一串相差少于<span class="math inline">\(k\)</span>处,则一定有一块完全相等.由于数据随机,这个概率为<span class="math inline">\(\cfrac{ 1 }{ 2^{ 16 } }\)</span>.</p>
<p>考虑把在一块中是某个数的零一串全都集合到一起,然后暴力判断,复杂度约为<span class="math inline">\(O ( \cfrac{ n^2 q }{ 2^{ 16 } w } )\)</span>.</p>
<h3><span id="拆贡献">拆贡献</span></h3>
<h5><span id="example12022qbxt国庆day7fenwick">Example1([2022qbxt国庆Day7]fenwick)</span></h5>
<p>注意到要变换多次,考虑每个值的贡献.</p>
<p>一个点要往后更新,不难通过平行求和法则一个值<span class="math inline">\(v\)</span>对它向后跳<span class="math inline">\(w\)</span>步的贡献为<span class="math inline">\(\binom{ w + k }{ w
}\)</span>.但是有修改很难办,怎么办?注意到如果我们暴力跳,查询的时候复杂度是<span class="math inline">\(O ( 1
)\)</span>的,我们没必要让它这么低.我们把所有值对<span class="math inline">\(p\)</span>这个点的更新存到一个数组里,显然只有<span class="math inline">\(\log
n\)</span>种步数.最后每次查询的时候用组合数一起更新即可.</p>
<h5><span id="example2qoj5097-小-p爱学习">Example2([QOJ5097] 小 P
爱学习)</span></h5>
<p>这个题的厉害之处在于完全将贡献拆开.</p>
<p>我们不妨设最后将所有的数分成了<span class="math inline">\(k\)</span>组,那么显然我们只要算出两个东西就可以得到此时的答案的和:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum_{ x_{ 1 , . . . , k } } \prod_{
i = 1 }^k a_{ x_i } \\\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ 1 \leq x_1 , . . . , x_k \leq
n , \sum x = n } \frac{ ( nm - k ) ! }{ \prod_{ i = 1 }^k ( x_i m - 1 )
! } \\\)</span>.</p></li>
</ol>
<p>第一个显然就是个背包,问题在于第二个的分子部分,我们用生成函数,设<span class="math inline">\(F = \sum_{ i = 1 }^{ n } \frac{ 1 }{ ( im - 1 ) !
} x^i\)</span>,我们要求的就是<span class="math inline">\([ x^n ] F^k ,
\forall 1 \leq k \leq n\)</span>.</p>
<p>这个东西可以做BSGS,也就是光速幂.这样就可以用<span class="math inline">\(O ( n^2 \sqrt{ n } )\)</span>预处理,用<span class="math inline">\(O ( n )\)</span>查询单个<span class="math inline">\(k\)</span>.</p>
<h5><span id="example3luogu4211lnoi2014lca">Example3(Luogu4211
[LNOI2014]LCA)</span></h5>
<p>将<span class="math inline">\(dep\)</span>拆成到根节点的路径上的点的数量,差分一下<span class="math inline">\([ l , r ]\)</span>,这样就只需要求<span class="math inline">\(z\)</span>和一个前缀点的LCA的<span class="math inline">\(dep\)</span>.将这个操作离线下来,我们对于每一个点把它到根节点的路径上的点全部<span class="math inline">\(+ 1\)</span>,查询每个点到根节点上的权值和就行.</p>
<p>CF757G是一样的,只不过好像需要卡卡空间?</p>
<h3><span id="二进制拆位">二进制拆位</span></h3>
<h5><span id="example1luogu5354ynoi2017由乃的oj">Example1(Luogu5354
[Ynoi2017]由乃的OJ)</span></h5>
<p>对每一位分开处理,对于线段树上每个区间,设<span class="math inline">\(f_{ 0 }\)</span>表示一开始<span class="math inline">\(v\)</span>的这一位是<span class="math inline">\(0\)</span>,最后的答案是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>,显然可以合并,拿bitset优化一下.</p>
<h3><span id="bitset优化暴力">bitset优化暴力</span></h3>
<h5><span id="example12022qbxt国庆day4d">Example1([2022qbxt国庆Day4]D)</span></h5>
<p>先想一个很明显的优化:我们记录一下每个字符出现的位置,当我们判断当前字符串是否出现过的时候,我们直接从这个字符串开头的字符存在的位置进行判断.</p>
<p>如果我们记录下每个字符在母串中的某个位置是否存在,我们就可以基本脱离母串进行判断.注意到只需要用bitset优化这个过程就可以做到<span class="math inline">\(O ( \sum tlen + \cfrac{ nq }{ w } )\)</span>.</p>
<h5><span id="example2noi2020-制作菜品">Example2([NOI2020] 制作菜品)</span></h5>
<p>这题首先要根据数据范围,注意到<span class="math inline">\(m \geq n -
1\)</span>的时候存在贪心解法.</p>
<p>具体怎么做呢?我们将原料按照质量排序,每次选最小的那个,不够的话就选最大的那个的一部分,重新排序后递归处理.</p>
<p>为啥这个是对的呢?根据鸽笼原理,最大的那个的质量一定大于等于<span class="math inline">\(\frac{ mk }{ n
}\)</span>,而最小的那个数和最大的那个数之和一定大于等于<span class="math inline">\(0 + \frac{ mk }{ n - 1 } \geq
k\)</span>,因此一定有解.</p>
<p>接下来我们就只需要做<span class="math inline">\(m = n -
2\)</span>的情况.</p>
<p>那么这个怎么做呢?我们发现每道菜和两个原材料有关,于是不妨抽象成图论模型:将这两个原材料所代表的点用一条边连起来:我们发现有<span class="math inline">\(n - 2\)</span>条边和<span class="math inline">\(n\)</span>个点,这个图必不联通.也就是说如果有解,必然可以分成两个集合,这两个集合互不相关.如果我们分成了两个集合,一个集合有<span class="math inline">\(a\)</span>个原材料,另一个集合有<span class="math inline">\(n - a\)</span>个原材料,我们就可以第一个集合做<span class="math inline">\(a - 1\)</span>道菜,第二个集合做<span class="math inline">\(n - a - 1\)</span>道菜,自然解决了问题.</p>
<p>接下来的问题在于01背包,用bitset优化一下.</p>
<h3><span id="简化能更新答案的集合">简化能更新答案的集合</span></h3>
<p>简单来说就是当你注意到一个答案只有可能由某些地方贡献,我们就只判断这些地方的贡献.有的时候不仅需要减小集合,还需要使这个集合尽可能好维护,这个时候可能会向集合里放一些不合法但不可能更新答案的选项.</p>
<h5><span id="example1cf1149d-abandoningroads">Example1(CF1149D Abandoning
Roads)</span></h5>
<p>首先一个把只有<span class="math inline">\(a\)</span>边的连通块缩起来,那<span class="math inline">\(1\)</span>到<span class="math inline">\(i\)</span>的最短路显然是通过几个<span class="math inline">\(b\)</span>连接若干个连通块来到<span class="math inline">\(i\)</span>.</p>
<p>由于防止用<span class="math inline">\(b\)</span>边链接连通块的时候连出环,我们需要用一个<span class="math inline">\(dp_{ S , x }\)</span>表示从<span class="math inline">\(1\)</span>经过<span class="math inline">\(S\)</span>集合的连通块到<span class="math inline">\(x\)</span>的最短路.</p>
<p>但是集合数量可能很多,怎么办?</p>
<p>注意到,如果这个集合只有一个点,那显然不可能重复经过;如果这个集合只有两个点,那重复经过意味着想用一条长度为<span class="math inline">\(2 b\)</span>的边代替一条长度为<span class="math inline">\(a\)</span>的边,显然也不优秀;同理集合只有三个点也不优秀.</p>
<p>于是只有点数<span class="math inline">\(\geq
4\)</span>的集合是有用的,复杂度<span class="math inline">\(O ( 2^{
\frac{ n }{ 4 } } m \log n )\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个正整数,要求将<span class="math inline">\(n\)</span>个正整数分到<span class="math inline">\(k\)</span>个集合中,每个集合恰好<span class="math inline">\(\cfrac{ n }{ k }\)</span>个数(保证<span class="math inline">\(k |
n\)</span>)且每个集合中不能有相同的数.设一个方案的代价是每个集合的极差之和,求最小代价,<span class="math inline">\(n \leq 70\)</span>.</p>
<p>首先<span class="math inline">\(O ( 3^n )\)</span>很好设计不说了.</p>
<p>注意到这题看上去就不太能多项式复杂度,我们考虑简化一下状态数.考虑做<span class="math inline">\(O ( 3^n )\)</span>的时候,我们是将<span class="math inline">\(\cfrac{ n }{ k
}\)</span>个数打包成一个集合再塞进去,这样看上去就不太优秀,我们考虑能不能一个数一个数塞进去.</p>
<p>我们现在有<span class="math inline">\(k\)</span>个集合,要塞进去一个数到一个集合中.注意到最后的代价实际上和很多数是没啥关系的.考虑先把数字从小到大排序,然后挨个插入集合.如果插入一个数之前,这个集合是空的,那这个数对答案有负的贡献;如果插入一个数之后,这个集合是满的,那这个数对答案有正的贡献;反之无贡献.</p>
<p>于是我们可以枚举目前集合填成啥样了,这样状态数变成了<span class="math inline">\(( \cfrac{ n }{ k } + 1 )^k\)</span>.</p>
<p>这样还是过不去,我们再冷静一下,显然我们只关心每个集合填了多少个数而不关心具体是哪个集合,于是我们把每个集合的大小排序后再压成状态,这样状态数就是<span class="math inline">\(\sum_{ i = 0 }^{ k }{ \binom{ i + \frac{ n }{ k }
}{ \frac{ n }{ k } } }
\\\)</span>,根据目前填到第几个数分一分类就会发现这部分上限是<span class="math inline">\(O ( n \binom{ 2 \sqrt{ n } }{ \sqrt{ n } }
)\)</span>.</p>
<p>不过我们还需要保证一个集合里不能有相同的元素.这里我们考虑将相同的元素一起放并规定放的顺序.因为放进去的集合在放这种元素前是有大小顺序的,我们每次放进最大的集合中.换句话说,我们设<span class="math inline">\(f_{ i , j , S }\)</span>表示目前放到<span class="math inline">\(i\)</span>,状态是<span class="math inline">\(S\)</span>,并且<span class="math inline">\(a_i\)</span>放进去的那个集合目前大小是<span class="math inline">\(j + 1\)</span>(放前是<span class="math inline">\(j\)</span>).</p>
<p>算一下复杂度是<span class="math inline">\(O ( n^2 \binom{ 2 \sqrt{ n
} }{ \sqrt{ n } }
)\)</span>的,实际上远远跑不满,甚至写了个map来做双射也跑过去了.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张有向图,多组询问,每次询问三个数<span class="math inline">\(p ,
x , y\)</span>,求是否能从<span class="math inline">\(p\)</span>出发只经过<span class="math inline">\([
x , y ]\)</span>中的边且经过的边的编号单调递减到达<span class="math inline">\(1\)</span>号节点.</p>
<p>冷静一下,先加边,注意到如果加<span class="math inline">\(u \rightarrow
v\)</span>这条边的时候,不存在一条从<span class="math inline">\(v\)</span>到<span class="math inline">\(1\)</span>的路径,那这条边显然没有用.</p>
<p>做完这一步后,我们注意到可以在加边的过程中对于每个<span class="math inline">\(u\)</span>维护从<span class="math inline">\(u\)</span>到<span class="math inline">\(1\)</span>的所有合法路径经过的最小编号的边的最大值<span class="math inline">\(maxn_u\)</span>,这样就可以对于每个点维护若干个二元组<span class="math inline">\(( l , r )\)</span>,只要对于<span class="math inline">\(p\)</span>,存在一个二元组<span class="math inline">\([ l , r ] \in [ x , y ]\)</span>就合法.</p>
<h5><span id="example4petrozavodskwinter-2014-moscow-su-tapir-contestopenstrain-contest-1435ccombinations-strike-back">Example4([Petrozavodsk
Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435)
C]Combinations Strike Back)</span></h5>
<p>给定一个大小为<span class="math inline">\(n\)</span>的可重集,多次询问,每次询问查询插入一个数<span class="math inline">\(x\)</span>后,这个集合大小为<span class="math inline">\(k\)</span>的可重子集共有多少个,每次询问互相独立.<span class="math inline">\(n , q \leq 1 . 2 \times 10^5\)</span>,答案对<span class="math inline">\(1051721729 = 1003 \times 2^{ 20 } +
1\)</span>取膜.</p>
<p>自然的想法是上生成函数.</p>
<p>假设数字<span class="math inline">\(i\)</span>在原集合中共有<span class="math inline">\(b_i\)</span>个,那么原集合大小为<span class="math inline">\(k\)</span>的可重子集数量显然为<span class="math inline">\([ z^k ] \prod_{ i = 1 }^n \frac{ z^{ b_i + 1 } - 1
}{ z - 1 }\)</span>.</p>
<p>插入一个数字<span class="math inline">\(x\)</span>,自然就是乘上一个<span class="math inline">\(\frac{ z^{ b_x + 2 } - 1 }{ z^{ b_x + 1 } - 1
}\)</span>.但如果每次都乘的话复杂度显然不行.怎么办?</p>
<p>注意到答案与插入的数字本身无关,只和这个数字在原集合中出现了多少次有关.而原集合最多有<span class="math inline">\(\sqrt{ n
}\)</span>(自然根号)个出现次数不同的数字,预处理一下就行.</p>
<h5><span id="example5cf1621gweightedincreasing-subsequences">Example5([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<p>一个自然的想法是拆出每个点<span class="math inline">\(x\)</span>的贡献,再枚举终点<span class="math inline">\(y\)</span>,这样问题就转化为了以<span class="math inline">\(y\)</span>结尾并且包含<span class="math inline">\(x\)</span>的LIS计数,这样做到<span class="math inline">\(O ( n^2 )\)</span>的复杂度.</p>
<p>那么怎么继续优化呢?我们还是想拆出每个点的贡献,但是如何不枚举终点<span class="math inline">\(y\)</span>呢?我们考虑枚举一下和它做贡献的点<span class="math inline">\(z\)</span>满足<span class="math inline">\(a_z &gt;
a_x\)</span>并且终点<span class="math inline">\(y\)</span>满足<span class="math inline">\(y &lt; z\)</span>,但是这样的<span class="math inline">\(z\)</span>有很多个,不难发现取最后一个就行.如果我们对整个序列取后缀<span class="math inline">\(\max\)</span>,就可以得到所有可能被当作<span class="math inline">\(z\)</span>的点,而且更强的性质是,只要这些点不在LIS中,LIS的终点<span class="math inline">\(y\)</span>必然有<span class="math inline">\(y &lt;
z\)</span>,这是显然的.做一下补集转化,就变成了计数包含<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>的LIS数量.</p>
<p>注意到<span class="math inline">\(z\)</span>的数量不多,且所有数字按照权值排序后被这些<span class="math inline">\(z\)</span>分成了若干个区间.所以颠倒值域和下标重新做LIS就行.</p>
<h5><span id="example6cf919f-a-game-withnumbers">Example6(CF919F A Game With
Numbers)</span></h5>
<p>最小表示法表示每个人的手牌.</p>
<p>不过要注意有可能成环.我们考虑用刷表法更新,最后刷不出来的点就是和.</p>
<h5><span id="example7ioi2014holiday">Example7([IOI2014]holiday)</span></h5>
<p>首先发现走的一定是一个区间,然后发现这个区间<span class="math inline">\([ l , r ]\)</span>的<span class="math inline">\(l\)</span>随<span class="math inline">\(r\)</span>的增大具有决策单调性,然后做完了,上主席树就行.</p>
<h5><span id="example8cf1446d2">Example8(CF1446D2)</span></h5>
<p>我们假设目前得到的答案区间是<span class="math inline">\([ l , r
]\)</span>,也就是说<span class="math inline">\([ l , r
]\)</span>无论如何不可能扩展成更大的区间了.那这需要满足什么条件呢?注意到全局众数一定是答案,如果它不是答案,我们就可以往两边拓展,直到满足区间众数是答案且区间合法.显然可以实现.然后做根号分治.</p>
<p>这个是怎么想到的呢?我们考虑一个区间如何拓展成更大的区间:如果每个数出现次数不降,显然是一个更大的区间.这同样是在说:如果我们能找到一段区间,使得加上这段区间后,原本不是区间众数的数成为了区间众数,并且区间仍然合法,那就一定更为优秀.再注意到如果一个数在全局出现次数多于区间众数,这一定可以实现,进而推出全局众数的结论.</p>
<p>你以为结束了?没有,我们下面给出一个<span class="math inline">\(O ( n
\log n )\)</span>的做法:</p>
<p>首先,我们假设全局众数是<span class="math inline">\(x\)</span>,枚举和它一起成为区间众数的数字<span class="math inline">\(y\)</span>,剩下的数先不管,那么区间大概长这个样:xyxyyxyxxxxxx.</p>
<p>我们发现这一段x一定是没有意义的:xyxyyxyxx[xxxx].</p>
<p>我们对于每一个<span class="math inline">\(y\)</span>出现的位置,找到其左右两边离他最近的没有被标记的<span class="math inline">\(x\)</span>标记一下,没有被标记的<span class="math inline">\(x\)</span>一定没有意义.这样对于一组解<span class="math inline">\(( x , y )\)</span>,合法的端点数量只有<span class="math inline">\(O ( y 出 现 的 次 数
)\)</span>次.每次判断每个端点是否可以做右端点,拿<span class="math inline">\(set\)</span>维护一下后缀和就可以实现<span class="math inline">\(O ( n \log n )\)</span>.</p>
<p>当然,这里得到的区间不一定是合法的(有可能<span class="math inline">\(x
, y\)</span>出现的次数都不是最多的,但没关系,这种一定不优秀).</p>
<p>【luoguP4062 [Code+#1]Yazid
的新生舞会】也是这个标记的思路,标记的话用一下链表之类的大概能做.</p>
<h4><span id="支配对问题">支配对问题</span></h4>
<p>lxl起的名字.</p>
<p>这里的思路其实大概就是:我们将一些很废物的二元组杀了,然后将剩下的二元组进行贡献答案.我们称这种一个二元组严格强于另一个二元组的限制称作支配关系.</p>
<h5><span id="第一类支配对">第一类支配对</span></h5>
<p>虽然总数很多,但是本质不同的很少.</p>
<h6><span id="example1luogup7880ynoi2006-rldcot">Example1(luoguP7880
[Ynoi2006] rldcot)</span></h6>
<p>我们这么考虑:如果现在有三个点<span class="math inline">\(a , b , c ,
a &lt; b &lt; c\)</span>,它们两两LCA都是<span class="math inline">\(d\)</span>,那么显然<span class="math inline">\(( a
, c )\)</span>这一对是没有用的,有用的是<span class="math inline">\(( a ,
b )\)</span>和<span class="math inline">\(( b , c
)\)</span>.进一步你发现这等价于什么呢:我们从下往上合并子树,每次做启发式合并,假设当前要把子树<span class="math inline">\(A\)</span>合并到子树<span class="math inline">\(B\)</span>上,考虑所有的点对<span class="math inline">\(( a , b ) , a \in A , b \in
B\)</span>的贡献,显然,能贡献到<span class="math inline">\(a\)</span>的<span class="math inline">\(b\)</span>只有<span class="math inline">\(a\)</span>的前驱和后继,这样我们就只找到了<span class="math inline">\(O ( n \log n )\)</span>个点对,它们等价于<span class="math inline">\(O ( n \log n )\)</span>个矩形,最后把<span class="math inline">\(dep\)</span>相等的合并一下,随便做做.</p>
<h6><span id="example2luogup8528ynoi2003-铃原露露">Example2(luoguP8528
[Ynoi2003] 铃原露露)</span></h6>
<p>和Example1基本差不多.</p>
<h5><span id="第二类支配对">第二类支配对</span></h5>
<p>虽然总数很多,但是有用的很少.</p>
<h6><span id="example1cf765f">Example1(CF765F)</span></h6>
<p>典.</p>
<h6><span id="example2codechef-minxorseg">Example2(CodeChef MINXORSEG)</span></h6>
<p>这个题比较厉害,仍然考虑<span class="math inline">\(a &lt; b &lt;
c\)</span>,我们看如果<span class="math inline">\(a \oplus c &gt; \max \{
a \oplus b , b \oplus c \}\)</span>的充要条件是什么.</p>
<p>简单分类讨论一下,不难发现这意味着<span class="math inline">\(LCP ( a
, c ) &gt; LCP ( a , b )\)</span>.于是有用的贡献对只有<span class="math inline">\(O ( n \log v )\)</span>个.</p>
<h6><span id="example3luogu9058-ynoi2004rpmtdq">Example3(Luogu9058 [Ynoi2004]
rpmtdq)</span></h6>
<p>这题更为逆天.</p>
<p>首先,这题有两个维度:树和序列,我们要先处理掉其中一维.lxl:树这一维度更加困难,因此我们应该是选择困难的那一维分治掉.</p>
<p>考虑边分治,然后就只需要处理两棵子树间的贡献.但是对于一棵子树内的点,我们要找到在另一棵子树中有可能和它产生贡献的点对,这个咋做呢?</p>
<p>牛逼的一步来了,我们考虑对于每个点,算出它到分治中心的距离<span class="math inline">\(r\)</span>,然后找另一棵子树中到分治中心距离<span class="math inline">\(\leq r\)</span>的点<span class="math inline">\(x\)</span>与它贡献,但是这还是有很多点,其实只需要找这些点中的<span class="math inline">\(x\)</span>的前驱后继就可以了.因为如果<span class="math inline">\(x &lt; b &lt; c\)</span>,<span class="math inline">\(b\)</span>和<span class="math inline">\(c\)</span>在同一边,那么<span class="math inline">\(( b , c )\)</span>一定比<span class="math inline">\(( a , c )\)</span>更加优秀.</p>
<h6><span id="example4cf1635f-closestpair">Example4(CF1635F Closest
Pair)</span></h6>
<p>首先,由于匹配无序,我们考虑对于一对数<span class="math inline">\(( i ,
j )\)</span>,只在<span class="math inline">\(w\)</span>较大的那个位置来更新答案.</p>
<p>不妨假设较大的为<span class="math inline">\(i\)</span>,我们考虑<span class="math inline">\(i\)</span>有可能和谁来更新答案.</p>
<p>如果现在有两个数<span class="math inline">\(k &lt; j , w_k \leq w_i
\land w_j \leq w_i\)</span>,如果<span class="math inline">\(w_k \geq
w_j\)</span>,那肯定选<span class="math inline">\(( j , i
)\)</span>更优秀;不然,如果选<span class="math inline">\(( k , i
)\)</span>比选<span class="math inline">\(( j , i
)\)</span>更优秀,那么我们会发现<span class="math inline">\(( k , j
)\)</span>比<span class="math inline">\(( k , i
)\)</span>更要优秀,因此答案一定会由<span class="math inline">\(( k , j
)\)</span>更新而不是由<span class="math inline">\(( k , i
)\)</span>更新.通过这里的分析我们发现,每个数只有可能和它左右两边的第一个<span class="math inline">\(w\)</span>小于等于它的数更新.</p>
<p>于是我们可以找到<span class="math inline">\(O ( n
)\)</span>个可能更新答案的点对,设点对为<span class="math inline">\(( x ,
y )\)</span>,我们每次查找一个区间<span class="math inline">\([ l , r
]\)</span>,即要找到所有在<span class="math inline">\([ l , r
]\)</span>内的点对并将它们的答案取min.</p>
<p>这一步可以将<span class="math inline">\(( x , y
)\)</span>当作二维平面的点,查询当作一个左下角为<span class="math inline">\(( l , l )\)</span>,右上角为<span class="math inline">\(( r , r
)\)</span>的矩阵,就是一个经典的矩阵取min的操作.</p>
<h6><span id="example5icpc2017wfmoney-for-nothing">Example5([ICPC2017
WF]Money for nothing)</span></h6>
<p>注意到抽象问题后等价于有若干个A点<span class="math inline">\(( x_1 ,
y_1 )\)</span>和若干个B点<span class="math inline">\(( x_2 , y_2
)\)</span>,我们想要找到一个A点和一个B点使得<span class="math inline">\((
x_1 - x_2 ) ( y_1 - y_2
)\)</span>最大.也就是它们作为右上和左下顶点的矩形面积最大.</p>
<p>怎么做这个问题呢?首先我们必须要发现的一点是:对于A点来说,如果有两个点<span class="math inline">\(( a_1 , b_1 )\)</span>和<span class="math inline">\(( a_2 , b_2 )\)</span>满足<span class="math inline">\(a_1 \leq a_2\)</span>,<span class="math inline">\(b_1 \leq
b_2\)</span>,那么前者一定更优秀.把那些废点删掉后,就会得到一个横坐标递增,纵坐标递减的点的序列.对于B点是同理的.</p>
<p>这个序列看上去就很亲切了,接下来简单证明一下是满足决策单调性的就可以判断答案了.</p>
<h3><span id="奇偶染色">奇偶染色</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一个<span class="math inline">\(9 \times
9\)</span>的网格,一开始上面有<span class="math inline">\(65\)</span>个蚂蚁,每个蚂蚁每分钟会四联通移动一格,每个蚂蚁每三分钟所在的格子不能在一条直线上,求证:一定会有一个时间,两只蚂蚁在同一个格子里.</p>
<p>sol1:</p>
<p>注意到如果条件不成立,则一定存在若干条路径,蚂蚁在路径上转圈,也就是找到长度和尽可能大的路径不交地覆盖矩阵,注意到一定是使用<span class="math inline">\(2 \times 2\)</span>的矩阵路径,于是最多有<span class="math inline">\(64\)</span>只蚂蚁.(感性理解)</p>
<p>sol2:</p>
<p>考虑对奇偶染色,设<span class="math inline">\(( i , j ) =
\begin{cases}white &amp; 2 \nmid ( i + j ) \\ blue &amp; 2 \mid i \land
2 \mid j \\ yellow &amp; \text{ otherwise }\end{cases}\)</span>.</p>
<p>我们把黄格子和蓝格子称为彩格子,注意到如果一开始一只蚂蚁在白格子,一分钟后必定在彩格子.一开始一只蚂蚁在蓝格子,两分钟后必定在黄格子.</p>
<p>因为最多有<span class="math inline">\(16\)</span>个蓝格子,所以一开始黄格子和蓝格子上分别最多有<span class="math inline">\(16\)</span>只蚂蚁,从而白格子上最多有<span class="math inline">\(32\)</span>只蚂蚁,总共最多<span class="math inline">\(64\)</span>只,得证.</p>
<h5><span id="example2cf1521e">Example2(CF1521E)</span></h5>
<p>首先考虑我们显然可以一行空一行放,也就是说如果最大的<span class="math inline">\(a_i &gt; n \times \lceil \frac{ n }{ 2 }
\rceil\)</span>的话显然不可以,如果能放的位置少于<span class="math inline">\(\sum a\)</span>显然也不可以.</p>
<p>类似lyz那个题,我们考虑删去行列编号均为偶数的点,这样就满足了一个子矩阵不能全放的限制.</p>
<p>然后呢?我们考虑将所有能放的位置排序.先把所有的位置分成三类:<span class="math inline">\(( \mathrm{ even } , \mathrm{ odd } ) , ( \mathrm{
odd } , \mathrm{ odd } ) , ( \mathrm{ odd } , \mathrm{ even }
)\)</span>,不同类位置按照这个顺序排,不然按照相对位置排.然后直接从头开始放.如果不合法,一定是同种颜色放到了<span class="math inline">\(( \mathrm{ even } , \mathrm{ odd }
)\)</span>和<span class="math inline">\(( \mathrm{ odd } , \mathrm{ even
} )\)</span>,并且相同类别是按照相对位置排序的,于是一定不满足最大的<span class="math inline">\(a_i \leq n \times \lceil \frac{ n }{ 2 }
\rceil\)</span>的限制条件.所以这么做一定是对的.</p>
<p>好!冷静一下,咋想到的啊.</p>
<p>首先这种题肯定要找到一些看上去就很显然的边界,当你发现找不到的时候,大概率就一定有解了(大概率).</p>
<p>然后呢?注意到不合法一定是同种颜色放到了<span class="math inline">\((
\mathrm{ even } , \mathrm{ odd } )\)</span>和<span class="math inline">\(( \mathrm{ odd } , \mathrm{ even }
)\)</span>,又观察到每种位置的数量和一个边界限制条件很像,于是就可以构造出来了.</p>
<p>所以大概是说,这种构造题要先想判断边界的条件,然后对着做.</p>
<h5><span id="example3cf1615f">Example3(CF1615F)</span></h5>
<p>太牛逼了这个题.</p>
<p>首先,找边界条件:啥时候<span class="math inline">\(s\)</span>不能变成<span class="math inline">\(t\)</span>呢?一个自然的想法是数<span class="math inline">\(1\)</span>的个数的奇偶性,但这样显然不对(<span class="math inline">\(01\)</span>和<span class="math inline">\(10\)</span>不能互相转移),我们需要一个更强的条件.</p>
<p>然后:注意到每次操作是相邻的两个数,于是我们有:奇数位置的和-偶数位置的和是定值.但是:注意到这个操作是有限制的!它只能对相邻相同的位置做.</p>
<p>然后我也不知道咋想到的,可能是因为找到限制条件后只要不改变限制条件就可以随便转化?反正我们先把偶数位置全部取反,这样操作就变成了交换相邻数字(如果相邻数字不相同,取反后相同,交换无用).</p>
<p>就可以dp了.</p>
<h5><span id="example4cf1517g">Example4(CF1517G)</span></h5>
<p>按照横纵坐标的奇偶性,分四种情况染色.注意到四边形接下来的路径一定会形如<span class="math inline">\(1 \rightarrow 2 \rightarrow 3 \rightarrow
4\)</span>,建立分层图跑最小割.</p>
<h3><span id="捆绑更新答案">捆绑更新答案</span></h3>
<h5><span id="example12022qbxt国庆day6binary">Example1([2022qbxt国庆Day6]binary)</span></h5>
<p>首先因为有<span class="math inline">\(-
1\)</span>,我们先考虑一个朴素的暴力,从<span class="math inline">\(L\)</span>到<span class="math inline">\(R\)</span>枚举现在被匹配的数<span class="math inline">\(i\)</span>,我们假设之前匹配到<span class="math inline">\(p -
1\)</span>,那我们接下来一定是要找到一个最小的<span class="math inline">\(x \geq p\)</span>能把<span class="math inline">\(i\)</span>给匹配掉,仔细思考这个过程,由于是二进制考虑最高位,不难发现我们只需要找到<span class="math inline">\(( p \land i ) \oplus i\)</span>的最高位<span class="math inline">\(1\)</span>,然后把<span class="math inline">\(p\)</span>的这一位改成<span class="math inline">\(1\)</span>,然后后面的位置全部设成<span class="math inline">\(0\)</span>,如果<span class="math inline">\(i
\subseteq p\)</span>那么就不用改.</p>
<p>冷静一下,二进制大概率是没啥通项公式的,还是要一点一点做.但是我们枚举每一个数实在是太慢了,我们考虑一个地方:<span class="math inline">\(i \subseteq p\)</span>就不用改,下一步<span class="math inline">\(i + = 1 , p + =
1\)</span>,如果没有发生进位还是不用改,这个过程看上去就很可以优化.</p>
<p>所以我们考虑:当遇到<span class="math inline">\(i \subseteq
p\)</span>的时候,我们就捆绑更新.如果不满足就暴力更新.重复这个过程,每次不断暴力更新<span class="math inline">\(\rightarrow\)</span>捆绑更新<span class="math inline">\(\rightarrow\)</span>暴力更新<span class="math inline">\(\rightarrow . .
.\)</span>.每次捆绑更新至少会更新一个<span class="math inline">\(lowbit\)</span>,而暴力更新的情况下,每次<span class="math inline">\(p\)</span>至少会多包含一位<span class="math inline">\(i\)</span>.就算后面进位把这一位消掉了,由于这里进位了,那下一步一定可以直接包含掉,于是复杂度也是<span class="math inline">\(\log
n\)</span>的,反复做一下就做完了,这里能分析复杂度<span class="math inline">\(O ( T \log^2 R
)\)</span>.我们冷静一下,发现二者复杂度算重了,捆绑更新会帮助暴力更新多匹配<span class="math inline">\(1\)</span>,于是复杂度<span class="math inline">\(O
( T \log R )\)</span>.但是肯定跑不满,考场甚至写了个上界<span class="math inline">\(O ( T \log^2 R )\)</span>的仍然跑的飞快.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树和一个值域为<span class="math inline">\(n\)</span>序列<span class="math inline">\(a\)</span>,每次询问给出<span class="math inline">\(l , r , x\)</span>.</p>
<p>设<span class="math inline">\(f ( x , y )\)</span>为点<span class="math inline">\(x\)</span>朝着<span class="math inline">\(y\)</span>的方向走一步后得到的点,求<span class="math inline">\(x\)</span>在经过<span class="math inline">\(a [ l
\cdots r ]\)</span>操作后得到的答案.</p>
<p>这么考虑:这题看上去就需要把任何一个数字<span class="math inline">\(x\)</span>,通过若干个点变成了一个<span class="math inline">\(f ( x )\)</span>,我们要做的就是把<span class="math inline">\(f ( x
)\)</span>求出来,这玩意很难求,考虑分块,单点用长剖做<span class="math inline">\(O ( 1 )\)</span>求<span class="math inline">\(k\)</span>级祖先,然后对于每个整块预处理出它的<span class="math inline">\(f\)</span>就可以了.</p>
<p>接下来的问题在于如何快速处理一个块的答案,考虑把所有的<span class="math inline">\(x\)</span>扔到树上,然后一起维护它们的<span class="math inline">\(f ( x )\)</span>.这玩意看上去好像有点不太能做.</p>
<p>牛逼的一步来了:考虑对于每个块内的<span class="math inline">\(\sqrt{ n
}\)</span>个点,建立这些点的虚树,对于不在虚树上的点,它们一定会往虚树的方向跑(其实也就是向上跑),然后处理出时间扫描线转化成在虚树上的点的问题.对于在虚树上的点,考虑虚树一共有<span class="math inline">\(O ( \sqrt{ n }
)\)</span>条边(也就是原树上的路径),我们用一个双端队列维护每条边上的点,显然每次每条边只会有<span class="math inline">\(O ( 1 )\)</span>的入队和出队,这样就实现了<span class="math inline">\(O ( n )\)</span>的预处理单个块.</p>
<h3><span id="单独更新答案">单独更新答案</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一个数轴上有<span class="math inline">\(n\)</span>个小球,第<span class="math inline">\(i\)</span>个小球在<span class="math inline">\(x_i\)</span>坐标处.数轴上还有<span class="math inline">\(m\)</span>个洞.第<span class="math inline">\(i\)</span>个洞在<span class="math inline">\(y_i\)</span>坐标处.你每秒可以以相同矢量速度移动所有小球.当一个小球和一个洞重合时,小球就会进洞.求一共可能出现多少种最终情况.(我们认为,两种”最终情况”不同,当且仅当存在一个球在两种情况中进入了不同的魔法洞中)</p>
<p>考场的想法:按照洞分类,把被同样两个洞夹起来的球一起处理,显然会有一段区间往左走一段区间往右走,按照这种区间的长度排序,然后硬dp,复杂度<span class="math inline">\(O ( n^3 )\)</span>.</p>
<p>实际的做法:我们抛弃区间,单独考虑每个球.对于每个球而言,有用的信息只有它到左端点的距离和它到右端点的距离.我们把这两个距离缩为<span class="math inline">\(( x_i , y_i )\)</span>.接下来我们要给每个点<span class="math inline">\(0 / 1\)</span>染色,如果是<span class="math inline">\(0\)</span>代表它要到左边的洞里,如果是<span class="math inline">\(1\)</span>代表要到右边的洞里.那什么染色条件是无解的呢?</p>
<p>如果存在两个点<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,<span class="math inline">\(col_a =
0\)</span>,<span class="math inline">\(col_b = 1\)</span>,那显然当<span class="math inline">\(x_a \geq x_b \land y_a \leq
y_b\)</span>时无解.换句话说,如果<span class="math inline">\(col_b = 1
\land x_a \geq x_b \land y_a \leq y_b\)</span>,那么<span class="math inline">\(col_a = 1\)</span>.我们不妨按照<span class="math inline">\(x\)</span>降序排序,<span class="math inline">\(x\)</span>相同的按照<span class="math inline">\(y\)</span>升序排列.那就会先决定<span class="math inline">\(b\)</span>再决定<span class="math inline">\(a\)</span>.注意到:如果<span class="math inline">\(a\)</span>能确定<span class="math inline">\(c\)</span>的状态,那<span class="math inline">\(b\)</span>一定也能确定<span class="math inline">\(c\)</span>的状态.因此我们采取这个策略:如果<span class="math inline">\(x_a \geq x_b \land y_a \leq y_b \land col_b =
1\)</span>,那我们直接不管<span class="math inline">\(a\)</span>;反之,则考虑一下<span class="math inline">\(a\)</span>的两种取值即可.具体一点,我们设<span class="math inline">\(f_{ i , 0 / 1 }\)</span>表示以<span class="math inline">\(i\)</span>结尾,<span class="math inline">\(col_i =
0 / 1\)</span>的方案数,然后顺着做就好.注意到:我们其实不关心<span class="math inline">\(col_x\)</span>具体是啥,我们只关心最后的方案数.所以其实可以直接删去第二维.</p>
<p>zhq对这题的理解:</p>
<p>这可以等价成求一个上升子序列.上升子序列说的是如果<span class="math inline">\(x_i &lt; x_j , y_i &gt; y_j\)</span>,<span class="math inline">\(i\)</span>“选了”,<span class="math inline">\(j\)</span>就必须”不选”.但是钦定必须选和必须不选,这两个限制是一样的.就是说,<span class="math inline">\(j\)</span>没有选择的权力了.</p>
<p>这个说法很有意思,但是要注意:类似说法成立当且仅当我们认为<span class="math inline">\(j\)</span>选了和认为<span class="math inline">\(j\)</span>没选对后面不会产生影响.</p>
<h5><span id="example2petrozavodsksummer-2015-moscow-ipt-contestopenstrain-contest-1464-jtwoairlines">Example2([Petrozavodsk
Summer-2015. Moscow IPT Contest(openstrain contest 1464) J]Two
Airlines)</span></h5>
<p>这是一道交互题.给定一张<span class="math inline">\(n\)</span>个点的完全图,每两个点之间是红色的边或是蓝色的边.可以询问<span class="math inline">\(2
n\)</span>次某两个点之间的边的颜色,求一条哈密顿回路使得这条路上的颜色段最多有两个.</p>
<p>考虑将点逐个加入.假设现在的哈密顿回路的两种颜色分别是<span class="math inline">\(r_s \rightarrow r_t\)</span>和<span class="math inline">\(b_s \rightarrow b_t\)</span>,当前要加入<span class="math inline">\(x\)</span>,我们每次询问<span class="math inline">\(x\)</span>和<span class="math inline">\(r_t\)</span>和<span class="math inline">\(b_t\)</span>之间的颜色,如果可以加入链就加入.如果不能加入,必然意味着<span class="math inline">\(x\)</span>和<span class="math inline">\(r_t\)</span>之间是蓝边,和<span class="math inline">\(b_t\)</span>之间是红边,我们查一下<span class="math inline">\(r_t\)</span>和<span class="math inline">\(b_t\)</span>之间是什么边,然后将其中一个点与<span class="math inline">\(x\)</span>一起扔到对面就行.</p>
<p>不过这样用了<span class="math inline">\(3
n\)</span>次询问,考虑先询问<span class="math inline">\(r_t\)</span>和<span class="math inline">\(b_t\)</span>之间的颜色,这样就能省掉一种.</p>
<h3><span id="寻找不变量">寻找不变量</span></h3>
<h5><span id="example1noip2021-方差">Example1([NOIP2021] 方差)</span></h5>
<p>首先我们注意到:设<span class="math inline">\(b_i = a_i - a_{ i - 1
}\)</span>这个操作相当于交换<span class="math inline">\(b_{ i - 1
}\)</span>和<span class="math inline">\(b_i\)</span>.</p>
<p>接下来推一下式子:</p>
<p><span class="math display">\[
\begin{aligned}
n^2 S^2 &amp; = n \sum_{ i = 1 }^n a_i^2 - ( \sum_{ i = 1 }^n a_i )^2 \\
&amp; = n \sum_{ i = 1 }^n ( \sum_{ j = 1 }^i b_j )^2 - ( \sum_{ i = 1
}^n ( n - i + 1 ) b_i )^2 \\
&amp; = n \sum_{ i = 1 }^n \sum_{ j = 1 }^i b_j \sum_{ k = 1 }^i b_k -
\sum_{ j = 1 }^n ( n - j + 1 ) b_j \sum_{ k = 1 }^n ( n - k + 1 ) b_k \\
&amp; = n \sum_{ j = 1 }^n b_j \sum_{ k = 1 }^n b_k \times ( n - \max \{
j , k \} + 1 ) - \sum_{ j = 1 }^n ( n - j + 1 ) b_j \sum_{ k = 1 }^n ( n
- k + 1 ) b_k \\
&amp; = n \sum_{ j = 1 }^n b_{ n - j + 1 } \sum_{ k = 1 }^n b_{ n - k +
1 } \times \min \{ j , k \} - \sum_{ j = 1 }^n jb_{ n - j + 1 } \sum_{ k
= 1 }^n kb_{ n - k + 1 }
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(c\)</span>为<span class="math inline">\(b\)</span>的倒置数组,则原式</p>
<p><span class="math display">\[
\begin{aligned}
&amp; = n \sum_{ j = 1 }^n c_{ j } \sum_{ k = 1 }^n c_{ k } \times \min
\{ j , k \} - \sum_{ j = 1 }^n jc_{ j } \sum_{ k = 1 }^n kc_{ k } \\
&amp; = 2 \sum_{ j = 1 }^n nc_j \sum_{ k = 1 }^j c_k k - 2 \sum_{ j = 1
}^n jc_{ j } \sum_{ k = 1 }^j kc_{ k } + \sum_{ i = 1 }^n c_i^2 i ( i -
1 ) \\
&amp; = 2 \sum_{ j = 1 }^n ( n - j ) c_j \sum_{ k = 1 }^j c_k k + \sum_{
i = 1 }^n c_i^2 i ( i - 1 ) \\
&amp; = \sum_{ j = 1 }^n ( n - j ) c_j \sum_{ k = 1 }^n c_k k + \sum_{ i
= 1 }^n ( n - 1 ) ic_i^2
\end{aligned}
\]</span></p>
<p><del>推到这一步发现好像没啥用但是推了好久懒得删了</del></p>
<p>冷静一下,由于一开始的数列是单调递增的,所以改变后的数列一定也是单调递增的(差分数组均<span class="math inline">\(\geq
0\)</span>).感性上理解,我们肯定是想让尽可能多的数接近绝对值,于是让重新排列后的差分数组呈现单最小值的峰看上去就很优秀.</p>
<p>这样我们设计<span class="math inline">\(dp_{ i , S
}\)</span>表示现在填到第<span class="math inline">\(i\)</span>小的<span class="math inline">\(b\)</span>,<span class="math inline">\(\sum a =
S\)</span>的情况下最小的<span class="math inline">\(\sum
a^2\)</span>,复杂度<span class="math inline">\(O ( n^2 a )\)</span>.</p>
<p>注意到<span class="math inline">\(a\)</span>很小的时候大部分<span class="math inline">\(b\)</span>都是<span class="math inline">\(0\)</span>,于是可以优化为<span class="math inline">\(O ( na^2 )\)</span>.</p>
<h5><span id="example2agc030e-less-than3">Example2([AGC030E] Less than
3)</span></h5>
<p>注意到:当我们把一个位置取反的时候,这个位置相邻的左右两个位置一定有一个<span class="math inline">\(0\)</span>和一个<span class="math inline">\(1\)</span>,所以我们的操作等价于移动<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>的分界线.</p>
<p>然后枚举一下从边界多产生了多少个分界线就行.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1arc110d">Example1(ARC110D)</span></h5>
<p>注意到这相当于先把一个长度等于<span class="math inline">\(m\)</span>的序列划分成<span class="math inline">\(n + 1\)</span>段,再从第<span class="math inline">\(i\)</span>段选出<span class="math inline">\(a_i\)</span>,其中<span class="math inline">\(a_{ n
+ 1 } = 0\)</span>.</p>
<p>于是自然是<span class="math inline">\(\binom{ n + m }{ \sum a + n
}\)</span>.</p>
<h5><span id="example2abc231g">Example2(ABC231G)</span></h5>
<p>乍一看,感觉完全不可做.因为一开始给定<span class="math inline">\(a\)</span>了,感觉上好像也不太能组合意义.</p>
<p>如果没有<span class="math inline">\(a_i\)</span>怎么做?我们设<span class="math inline">\(f_n\)</span>表示将<span class="math inline">\(k\)</span>个小球分到<span class="math inline">\(n\)</span>个盒子后的答案.那乘法相当于:分完后,在每个盒子中取出一个小球的方案数.于是<span class="math inline">\(f_n = \binom{ k }{ n } n ! n^{ k - n
}\)</span>.</p>
<p>那给定<span class="math inline">\(a\)</span>咋做呢?我们注意到上面的式子好像可以对于任意<span class="math inline">\(n\)</span>快速求.于是将原式子拆为:<span class="math inline">\(\prod ( a_i + b_i )\)</span>,那答案就是选出<span class="math inline">\(n - x\)</span>个<span class="math inline">\(a\)</span>和选出<span class="math inline">\(x\)</span>个<span class="math inline">\(b\)</span>的答案.前者可以背包,后者也就是<span class="math inline">\(f_x = \binom{ k }{ x } x ! n^{ k - x
}\)</span>.</p>
<h5><span id="example3agc060d">Example3(AGC060D)</span></h5>
<p>不妨设<span class="math inline">\(C_p = \{ i | p_i &gt; p_{ i + 1 } ,
1 \leq i &lt; n \}\)</span>.</p>
<p>用一下组合意义,注意到答案等于:</p>
<p><span class="math display">\[
\sum_{ S } ( \sum_{ p } [ S = C_p ] )^2
\]</span></p>
<p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<p><span class="math display">\[
\sum_{ S } ( \sum_{ p } [ S = C_p ] )^2 = \sum_{ S } ( \sum_{ S
\subseteq T } \sum_{ p } ( - 1 )^{ | T | - | S | } [ T \subseteq C_p ]
)^2
\]</span></p>
<p>这个咋做呢?我们考虑用组合意义展开:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S } ( \sum_{ S \subseteq T } \sum_{ p } ( - 1 )^{ | T | - |
S | } [ T \subseteq C_p ] )^2 \\
= &amp; \sum_{ S } \sum_{ S \subseteq T_1 , T_2 } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] )
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(S\)</span>屁用没有,直接交换枚举顺序.</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S } \sum_{ S \subseteq T_1 , T_2 } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] ) \\
= &amp; \sum_{ T_1 , T_2 } 2^{ | T_1 \cap T_2 | } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] )
\end{aligned}
\]</span></p>
<p>考虑<span class="math inline">\(( \sum_{ p } [ T_1 \subseteq C_p ]
)\)</span>怎么求,注意到这等价于所有<span class="math inline">\(T_1\)</span>中的位置全都被钦定为<span class="math inline">\(&gt;\)</span>,而其他位置任意,如果我们设所有以大于号连接的部分的长度为<span class="math inline">\(l_1 , l_2 , . . . ,
l_k\)</span>,那么这里的答案就是<span class="math inline">\(n ! \prod_{ i
= 1 }^k \frac{ 1 }{ l_i ! }\)</span>.</p>
<p>但我们很快发现了难点:<span class="math inline">\(2^{ | T_1 \cap T_2 |
}\)</span>这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中都是<span class="math inline">\(&gt;\)</span>的位置,这个好像不太好求,因为<span class="math inline">\(&gt;\)</span>是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ T_1 , T_2 } 2^{ | T_1 \cap T_2 | } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] ) \\
= &amp; \sum_{ T_1 , T_2 } 2^{ ( ( n - 1 ) - | T_1 \cup T_2 | ) - ( n -
1 ) } ( - 2 )^{ | T_1 | + | T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] )
( \sum_p [ T_2 \subseteq C_p ] ) \\
= &amp; 2^{ 1 - n } ( n ! )^2 \sum_{ T_1 } ( ( - 2 )^{ | T_1 | } \frac{
1 }{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( ( - 2 )^{ | T_2 | } \frac{ 1
}{ \prod l_{ 2 , i } ! } ) 2^{ n - 1 - | T_1 \cup T_2 | }
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(n - 1 - | T_1 \cup T_2
|\)</span>意味着均不在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中的位置的数量.为了给每一段连续的<span class="math inline">\(&gt;\)</span>都分配权值,我们进行一个细小的修改:</p>
<p><span class="math display">\[
2^{ - 1 - n } ( n ! )^2 \sum_{ T_1 } ( ( - 2 )^{ | T_1 | + 1 } \frac{ 1
}{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( ( - 2 )^{ | T_2 | + 1 } \frac{
1 }{ \prod l_{ 2 , i } ! } ) 2^{ n - 1 - | T_1 \cup T_2 | }
\]</span></p>
<p>写到这里应该就能发现,接下来必然要对<span class="math inline">\(n - 1
- | T_1 \cup T_2
|\)</span>做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了<span class="math inline">\(&gt;\)</span>,我们自然有:</p>
$$
<span class="math display">\[\begin{gathered}
2^{ 1 + n } ( n ! )^2 \sum_{ T_1 } ( \frac{ 1 }{ ( - 2 )^{ | T_1 | + 1 }
} \frac{ 1 }{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( \frac{ 1 }{ ( - 2
)^{ | T_2 | + 1 } } \frac{ 1 }{ \prod l_{ 2 , i } ! } ) 2^{ | T_1 \cap
T_2 | } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时<span class="math inline">\(| T_1 \cap T_2
|\)</span>这个限制就显得尤其强,如果只是<span class="math inline">\(S
\subseteq T_1 , T_2\)</span>就会好做很多:我们可以钦定<span class="math inline">\(S\)</span>作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; 2^{ 1 + n } ( n ! )^2 \sum_{ T_1 } ( \frac{ 1 }{ ( - 2 )^{ | T_1 |
+ 1 } } \frac{ 1 }{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( \frac{ 1 }{ (
- 2 )^{ | T_2 | + 1 } } \frac{ 1 }{ \prod l_{ 2 , i } ! } ) 2^{ | T_1
\cap T_2 | } \\
= &amp; 2^{ 1 + n } ( n ! )^2 \sum_{ S } \sum_{ S \subseteq T_1 } (
\frac{ 1 }{ ( - 2 )^{ | T_1 | + 1 } } \frac{ 1 }{ \prod l_{ 1 , i } ! }
) \sum_{ S \subseteq T_2 } ( \frac{ 1 }{ ( - 2 )^{ | T_2 | + 1 } }
\frac{ 1 }{ \prod l_{ 2 , i } ! } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(f ( T ) = \sum_{ S \subseteq T } (
\frac{ 1 }{ ( - 2 )^{ | T | + 1 } } \frac{ 1 }{ \prod l_{ 2 , i } ! } )
\\\)</span>,则原式即:</p>
<p><span class="math display">\[
2^{ 1 + n } ( n ! )^2 \sum_{ S } ( \sum_{ S \subseteq T } f ( T ) )^2
\]</span></p>
<p>考虑下面这个东西怎么求:</p>
<p><span class="math display">\[
\sum_{ S } ( \sum_{ S \subseteq T } f ( T ) )^2
\]</span></p>
<p>注意到,如果我们把每一段(<span class="math inline">\([ T_i , T_{ i + 1
} )\)</span>)的贡献求和,那么<span class="math inline">\(f ( T
)\)</span>相当于这些和乘起来,那么<span class="math inline">\(( \sum_{ S
\subseteq T } f ( T )
)^2\)</span>就是这些和的平方乘起来.换句话说,我们自然有<span class="math inline">\(ans_n = \sum_{ m } ans_{ n - m } g^2_{ m
}\)</span>,其中<span class="math inline">\(g_m\)</span>表示长度为<span class="math inline">\(m\)</span>的一段的贡献之和.而<span class="math inline">\(g_{ n } = \sum_m g_{ n - m } \frac{ 1 }{ - 2 m !
}\)</span>.二者都可以使用分治FFT或多项式求逆解决.更进一步地,<span class="math inline">\(h_i = \frac{ 1 }{ - 2 i ! } , G = \frac{ 1 }{ 1 -
H } , F = \frac{ 1 }{ 1 - G }\)</span>.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将<span class="math inline">\(( &gt; , &gt;
)\)</span>容斥掉,这样我们有若干种对:<span class="math inline">\(2 ( &lt;
, &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e
)\)</span>,然后我们发现两个序列联系得太紧了,我们考虑分配系数:<span class="math inline">\(&lt; \rightarrow \sqrt{ 2 }\)</span>,<span class="math inline">\(e \rightarrow - \frac{ 1 }{ \sqrt{ 2 }
}\)</span>,但是这样发现<span class="math inline">\(( e , e
)\)</span>算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h3><span id="复杂度抵消">复杂度抵消</span></h3>
<h5><span id="example1cf1439b">Example1(CF1439B)</span></h5>
<p>首先注意到度数小于<span class="math inline">\(k -
1\)</span>的点一定没用,于是可以不断删点.删点后的图度数全部<span class="math inline">\(\geq k - 1\)</span>.</p>
<p>首先如果剩下的点度数全都<span class="math inline">\(\geq
k\)</span>那就直接找到答案,不然,我们看一下度数为<span class="math inline">\(k -
1\)</span>的点:它要么在团里,要么没用.不妨直接暴力判断是否在团里,复杂度<span class="math inline">\(O ( k^2 )\)</span>.</p>
<p>欸等一下,这总复杂度<span class="math inline">\(O ( mk^2
)\)</span>了啊,这咋办?</p>
<p>首先,删完点后的度数全都<span class="math inline">\(\geq k -
1\)</span>,注意到此时的点数是<span class="math inline">\(O ( \frac{ m }{
k } )\)</span>的.所以复杂度<span class="math inline">\(O ( mk
)\)</span>.</p>
<p>好像还是过不去,这咋办?</p>
<p>冷静一下,如果<span class="math inline">\(k \geq \sqrt{ m
}\)</span>,显然不可能存在团.于是复杂度<span class="math inline">\(O ( m
\sqrt{ m } )\)</span>.</p>
<h3><span id="寻找关系式">寻找关系式</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>一张有向图,边有两种颜色,从<span class="math inline">\(s\)</span>开始随机游走,维护一个权值.经过第一种颜色的边,权值<span class="math inline">\(+ 1\)</span>.经过第二种颜色的边,权值归<span class="math inline">\(0\)</span>.保证<span class="math inline">\(t\)</span>没有出边,所有点均能到<span class="math inline">\(t\)</span>.询问到<span class="math inline">\(t\)</span>时权值的期望和方差.<span class="math inline">\(n \leq 100\)</span>.</p>
<p>(注意方差为平方的期望减去期望的平方.)</p>
<p>注意到难点在于权值归<span class="math inline">\(0\)</span>.所以一个点到<span class="math inline">\(t\)</span>的期望权值一定和到达它时的权值有关系.</p>
<p>然后就来到了降维打击的时间:我们可以使用数学归纳法证明,如果到一个点<span class="math inline">\(u\)</span>的权值是<span class="math inline">\(x\)</span>,那它到达<span class="math inline">\(t\)</span>的权值一定形如<span class="math inline">\(a_u x + b_u\)</span>.</p>
<p>如果要严谨一点的话,我们发现第一种颜色的边会影响常数项,第二种颜色的边会影响一次项,因此最后的答案一定是一次函数.</p>
<p>最后可以使用高斯消元直接求出每个点权值的<span class="math inline">\(a_u\)</span>和<span class="math inline">\(b_u\)</span>,就可以求出期望.</p>
<p>至于方差是同理的,你注意到平方的期望一定是一个二次函数.</p>
<h3><span id="特判边界">特判边界</span></h3>
<h5><span id="example12022icpc杭州e">Example1(2022ICPC杭州E)</span></h5>
<p>第一反应肯定是一点一点调整成<span class="math inline">\(\{ 1 , 2 , .
. . , n \}\)</span>的形式,写个暴力验证一下发现当<span class="math inline">\(n \geq 4\)</span>的时候的确都可以调整成功.</p>
<p>假设目前形如:<span class="math inline">\([ 1 , k ] , A , k + 1 ,
B\)</span>.我们考虑如何调整:</p>
<ol type="1">
<li><span class="math inline">\(| B | \ne 0\)</span>.</li>
</ol>
<p>我们有:</p>
<p><span class="math display">\[
\{ [ 1 , k ] , A , k + 1 , B \} \rightarrow \{ B , A , k + 1 , [ 1 , k ]
\} \rightarrow \{ [ 1 , k + 1 ] , B , A \}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(| B | = 0 , | A | = 0\)</span>.</li>
</ol>
<p>直接合并就行.</p>
<ol start="3" type="1">
<li><span class="math inline">\(| B | = 0 , | A | \geq 2\)</span>.</li>
</ol>
<p>假设<span class="math inline">\(A = A_1 A_2\)</span>,我们有:</p>
<p><span class="math display">\[
\{ [ 1 , k ] , A_1 , A_2 , k + 1 \} \rightarrow \{ A_2 , k + 1 , A_1 , [
1 , k ] \} \rightarrow \{ [ 1 , k + 1 ] , A_1 , A_2 \}
\]</span></p>
<ol start="4" type="1">
<li><span class="math inline">\(| B | = 0 , | A | = 1\)</span>.</li>
</ol>
<p>此时一定有<span class="math inline">\(k \geq
2\)</span>,发现有点难构造,但是我们猜测是可以构造出来的.不难证明这个问题等价于将<span class="math inline">\(\{ 1 , 2 , 4 , 3 \}\)</span>调整为<span class="math inline">\(\{ 1 , 2 , 3 , 4
\}\)</span>,写个暴力跑一下就行.</p>
<h3><span id="摩尔投票">摩尔投票</span></h3>
<h5><span id="example1cf643gchoosing-ads">Example1([CF643G]Choosing Ads)</span></h5>
<p>将摩尔投票扩展一下.我们现在想求其中出现次数大于等于<span class="math inline">\(\lfloor \frac{ n }{ p }
\rfloor\)</span>的数字,令<span class="math inline">\(k = \lfloor \frac{
100 }{ p } \rfloor\)</span>,我们考虑每次取出<span class="math inline">\(k +
1\)</span>个两两不同的数字并且全部杀掉,那么做完这一步操作后,该满足条件的仍然满足条件(讨论一下),于是拿线段树维护当前的五个数的出现数量,每次对着杀就行.</p>
<h3><span id="寻找周期性">寻找周期性</span></h3>
<h5><span id="example1cf1463fmax-correctset">Example1([CF1463F]Max Correct
Set)</span></h5>
<p>自然的想法是<span class="math inline">\(O ( n 2^{ \max ( x , y ) }
)\)</span>作dp.</p>
<p>接下来比较牛逼的是,注意到如果<span class="math inline">\(S_1\)</span>满足条件,令<span class="math inline">\(m = x + y\)</span>那么<span class="math inline">\(S_1 \cup ( S_1 + m )\)</span>也满足条件.</p>
<p>我们考虑<span class="math inline">\(S_1\)</span>中满足条件意味着什么,意味着<span class="math inline">\(\forall a , b \in S_1 , a &lt; b\)</span>,<span class="math inline">\(b - a \ne x \land b - a \ne
y\)</span>,这意味着<span class="math inline">\(m + b - a \ne x \land m +
b - a \ne y\)</span>,这同样意味着<span class="math inline">\(m + a - b =
x + y + a - b \ne x + y - x \land m + a - b \ne x + y - y\)</span>.</p>
<p>因此,只要我们找到了一个长度为<span class="math inline">\(m\)</span>的可行解,我们一定可以将其不断扩展到全部集合.</p>
<p>进一步地,我们一定能证明:原集合中的最优解是以一个长度为<span class="math inline">\(m\)</span>的可行解作为周期的.</p>
<p>这个是为啥呢?我们设<span class="math inline">\(n = km +
c\)</span>,那么我们直接求出一个长度为<span class="math inline">\(m\)</span>的解,满足前<span class="math inline">\(c\)</span>位对答案的贡献的权值是<span class="math inline">\(k + 1\)</span>,后<span class="math inline">\(m -
c\)</span>位贡献的权值为<span class="math inline">\(k\)</span>,然后直接求答案.注意到如果最大答案另有其人,我们一定可以拿其中的某一段不断循环得到更大的答案,这就不符合我们的假设了.</p>
<h3><span id="补集转化">补集转化</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的无向图,求给每一条边定向使得<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>能到达同一个点(可以是<span class="math inline">\(1\)</span>或<span class="math inline">\(2\)</span>)的方案数.<span class="math inline">\(n
\leq 15 , m \leq \frac{ n ( n - 1 ) }{ 2 }\)</span>.</p>
<p>考虑正难则反,算不存在的概率(事实上也确实很好理解,因为存在性问题通常都要取补集),这时候我们发现:此时<span class="math inline">\(1\)</span>能到达一个集合<span class="math inline">\(S\)</span>,<span class="math inline">\(2\)</span>能到达一个集合<span class="math inline">\(T\)</span>,<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>无交,并且两个集合之间不可能存在边,因此我们只需要算<span class="math inline">\(f ( S )\)</span>表示<span class="math inline">\(1\)</span>能到达<span class="math inline">\(S\)</span>中的点的方案数即可,<span class="math inline">\(2\)</span>同理.</p>
<p>那么这个怎么算呢?我们仍然考虑正难则反,如果<span class="math inline">\(1\)</span>不能到达<span class="math inline">\(S\)</span>中的所有点,那么<span class="math inline">\(1\)</span>一定只能到达<span class="math inline">\(S\)</span>中的一部分点,枚举这一部分,假设是<span class="math inline">\(T\)</span>,就可以用<span class="math inline">\(f (
T )\)</span>算<span class="math inline">\(f ( S )\)</span>的答案.</p>
<h3><span id="二进制分组">二进制分组</span></h3>
<h5><span id="example1loj3273">Example1(loj3273)</span></h5>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点<span class="math inline">\(( x , y )\)</span>,随着<span class="math inline">\(x\)</span>的增大<span class="math inline">\(y\)</span>不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.我们使用二进制分组,将所有点分为大小为<span class="math inline">\(0 , 1 , 2 , 4 , \cdots ,
2^k\)</span>大小的组,当然有些组可能没被分出来.然后如果有两个大小都是<span class="math inline">\(2^k\)</span>的组,我们暴力合并二者,得到一个还没被折线扫过的新的大小为<span class="math inline">\(2^{ k + 1 }\)</span>的组.</p>
<h5><span id="example2luogu7447ynoi2007-rgxsxrs">Example2(Luogu7447
[Ynoi2007] rgxsxrs)</span></h5>
<p>一眼看上去和CF702F很像,但是区间操作感觉很艰难,怎么做呢?</p>
<p>我们对值域分块:分成<span class="math inline">\([ 0 , 1 ) , [ 1 , 2 )
, [ 2 , 4 ) , [ 4 , 8 ) , \cdots\)</span>,这样只会分成<span class="math inline">\(\log
V\)</span>段,每段内部维护平衡树来处理下标.那么对于一个<span class="math inline">\(x\)</span>,它会把后面的段全部打上一个<span class="math inline">\(tag\)</span>,有些位置要掉落到下面的段上,这个维护每个段的最小值就可以处理(最多只会掉落<span class="math inline">\(\log n\)</span>段),问题是和<span class="math inline">\(x\)</span>在同一块内的没有办法打tag,但这一部分一定会掉落到下面的段,一块处理.</p>
<p>好,下面开始思想总结:</p>
<p>首先,我们发现这个区间和值域都很难处理,但是感觉值域更加重要,应该是对值域做均摊(也就是类似CF702F的打tag操作和暴力修改操作分开),于是考虑到对值域分块然后内部平衡树,然后发现可以做了吧.不太清楚,也有可能只是值域分块的套路.</p>
<p>Luogu9069是同款思路,判一下负数.</p>
<h5><span id="example3cf1515i-phoenixand-diamonds">Example3(CF1515I Phoenix
and Diamonds)</span></h5>
<p>俗称带修T-shirt.</p>
<p>做法大概是这样的:我们考虑对于每次给出的<span class="math inline">\(c\)</span>,不妨假设它在<span class="math inline">\([ 2^k , 2^{ k + 1 }
)\)</span>这个块上,那么如果它减去了任何一个还在这个块里的数字,那就一定会掉落到下一个块中.这样就又有均摊了.</p>
<p>但是我们不一定能减去一个还在这个块里的数字,我们怎么做呢?</p>
<p>我们考虑最后的操作一定是减去若干个小于这个块的,最后有可能再减去一个这个块的,然后<span class="math inline">\(c\)</span>就掉到了下一个块,考虑先按照价值排序,然后维护<span class="math inline">\(f_i\)</span>表示排名在<span class="math inline">\(i\)</span>前面且代价在更小的块中的代价和,我们要找到最靠左的小于<span class="math inline">\(c - 2^k\)</span>的<span class="math inline">\(f\)</span>,这个可以做线段树二分维护.</p>
<p>[IOI2021]地牢游戏 类似,但是因为是在图上做,所以把二分要改成倍增.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/" class="post-title-link" itemprop="url">英美戏剧与电影大作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="thebright-morning-stara-sequel-to-a-streetcar-named-desire">The
Bright Morning Star(A Sequel to <em>A Streetcar Named Desire</em>)</span></h3>
<p>MATRON: This is her room. [<em>She knocks on the door.</em>] Miss
DuBois,</p>
<p>here is someone who wants to visit you.</p>
<p>MITCH [<em>overwrought</em>]: Thank you. Has anyone visited her
before? And</p>
<p>has she recovered?</p>
<p>MATRON: No, no. Although she has recovered a lot, sometimes
she’ll</p>
<p>crouch over and tremble in corners as if someone will hurt her,
and</p>
<p>she’ll try to hit anyone who wants to touch her when she’s
insane.</p>
<p>[*She pushes the door open and lets Mitch in. The room where
Blanche</p>
<p>lives now is a pure white space without windows, and a naked bulb</p>
<p>brightens the whole room as if it were daylight. There is a
collapsible</p>
<p>bed in the corner of the room and a Bible on the table. Blanche sits
on</p>
<p>a chair in a blue dress and stares at Mitch, which makes Mitch feel
a</p>
<p>little guilty. Then the Matron goes out and leaves Mitch in the
room.*]</p>
<p>MITCH [<em>keeping his head lower, staring at his hands</em>]: Hello,
Miss</p>
<p>… DuBois.</p>
<p>BLANCHE [<em>happily</em>]: Hello, Mitch. I’m glad that you could
visit me.</p>
<p>You know, I haven’t spoken to anybody for a long time. I … I
didn’t</p>
<p>mean that the Doctor and the Matron treated me badly, and I also
didn’t</p>
<p>mean that you are just a … talkative partner in my heart. [*Her
voice</p>
<p>dies out nervously.*] You know that, you know that … did you
bring</p>
<p>some whiskey or lemon coke for me?</p>
<p>MITCH: No, the Matron said that you can’t have any liquor.</p>
<p>BLANCHE: That’s a pity. Did you bring some unwashed grapes for
me?</p>
<p>MITCH: What?</p>
<p>BLANCHE [<em>smiled</em>]: That’s just a joke.</p>
<p>MITCH [<em>relieved</em>]: It’s a relief to see you more delighted
and</p>
<p>energetic now. [<em>There is a pause.</em>] The room is so … white,
like a</p>
<p>… marble palace.</p>
<p>BLANCHE [<em>delightedly</em>]: Yes. Yes, I know that you mean to say
“Ivory</p>
<p>tower”. The room is neat and … it is better than Elysian Fields,</p>
<p>right? I feel like a new human being with the white walls, the
light,</p>
<p>and the Bible here. And Shep Huntleigh called me a few seconds ago.
Soon</p>
<p>I’ll leave here and go to the real palace, being old and full of
days.</p>
<p>The Lord will bless the latter end of mine more than my
beginning.</p>
<p>[*The music of the polka rises, faint in the distance. She gets</p>
<p>crazy<em>] No, no, I don’t want to hear it again! [</em>Mitch
gets</p>
<p>shocked.*] I’m sorry for that. I … I don’t know why sometimes I</p>
<p>behave like … like … Oh, how is your mother?</p>
<p>MITCH [<em>sadly</em>]: She has passed on.</p>
<p>BLANCHE: I’m sorry to hear that. [<em>There is a pause.</em>] Oh,
don’t let</p>
<p>silence ruin our meeting. We haven’t met for …</p>
<p>MITCH: Seven months.</p>
<p>BLANCHE: Yes, seven months … It’s difficult for me to count the
days</p>
<p>because there’s no calendar, nor sun … How about Stella’s baby? When
I</p>
<p>feel lonely at night, I will miss the lovely baby. I haven’t seen
him</p>
<p>… or her? Oh, it is not important, you know, Stella is my
precious</p>
<p>little sister, and her baby is my precious little nephew …
although</p>
<p>the baby’s father is … Stanley.</p>
<p>MITCH [<em>avoiding Blanche’s eyes</em>]: That’s why I came here,
Blanche, I</p>
<p>have known the brutal thing that Stanley had done. I feel angry and
…</p>
<p>sorry for it. I want to confess my behavior to you and … beseech
your</p>
<p>forgiveness. [<em>His voice dies out.</em>]</p>
<p>BLANCHE: What thing? I must forget something. Pardon me, let me
remember</p>
<p>for a moment … [*She starts shaking all over and panting for</p>
<p>breath.<em>] No, no, no! [</em>She screams*] That’s enough.</p>
<p>MITCH [<em>bravely</em>]: You know, Blanche. I … I’m sorry for what
Stanley</p>
<p>… and I have done.</p>
<p>BLANCHE: I forgive you! You are the man that is without sin.</p>
<p>MITCH [<em>shocked</em>]: No, no, I’m not …</p>
<p>BLANCHE [<em>raising her voice</em>]: You are the one! It is you who
lighten</p>
<p>my life … although just for a while. But that is not your fault.
I</p>
<p>don’t deserve the light for my sinful self. It must be God’s
punishment</p>
<p>…</p>
<p>MITCH [<em>restlessly</em>]: No, Blanche, you are …</p>
<p>BLANCHE: A courtesan, I’ve known it.</p>
<p>MITCH [<em>embarrassedly</em>]: No, Blanche, I didn’t mean that.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: So why do you come here? To
remind me</p>
<p>of the past which I try to forget, to sneer at my fate that I have
been</p>
<p>trapped in this prison, or just because you want to have a sweet
rest</p>
<p>without guilt?</p>
<p>MITCH [<em>embarrassedly</em>]: No, no, Blanche, I come here with
kindness. I</p>
<p>know the memory of Stanley is so harsh for you and I … I have no</p>
<p>hostility to mention it. And … and, you see, the room is not so bad
as</p>
<p>a prison. It is safe. No one will hurt you here.</p>
<p>BLANCHE [<em>coldly</em>]: And no one will love me here.</p>
<p>[<em>They keep silent for a while.</em>]</p>
<p>MITCH [<em>nervously</em>]: Maybe we can turn the light off. The room
is too</p>
<p>bright.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: Don’t touch the button. From
the</p>
<p>first day I came here, the merciful Doctor and the Matron kept the
bulb</p>
<p>on because they thought I’d be cured when there was no night. It
works!</p>
<p>Now I love the light, it makes the room like a … white coffin. Yes,
a</p>
<p>white coffin made of white woods.</p>
<p>MITCH: Don’t talk about death. You said you were afraid of it.</p>
<p>BLANCHE [<em>faintly</em>]: That was the past. In the past, I always
wanted</p>
<p>to get away from death. Before I met you, I escaped to desire; after
I</p>
<p>met you, I was lost in hope. In the past, I clutched at anything
that</p>
<p>would tell me that I’m alive, and when there was no solid thing
in</p>
<p>reality, I tried to clutch at myself … although I’m not solid
enough.</p>
<p>The seven months I have spent here helped me understand death.
Maybe</p>
<p>death isn’t just about crying and darkness but salvation and light.
I</p>
<p>thought I dreamt about Jesus a few days ago and he said, “Today
shalt</p>
<p>thou be with me in paradise.” I wanted to ask him what paradise is
like</p>
<p>but … I could speak no word, and then I woke up ... But, but I
could</p>
<p>imagine it! You see, the room is … is as stainless as heaven. You
see</p>
<p>I’m more delighted and energetic here! It is doubtless that I’ll
keep</p>
<p>delighted and energetic in heaven after I pass on … if I can go
to</p>
<p>heaven by entering in at the strait gate … Do you think I can?</p>
<p>MITCH: Yes, of course.</p>
<p>BLANCHE [<em>laughed</em>]: God love you for a liar! But let me tell
you the</p>
<p>truth: I’ve chosen a wide way that leadeth to destruction … it’s
real</p>
<p>… but why I talk about the truth …</p>
<p>MITCH: I’m serious. I have made up my mind to come here … and I
want</p>
<p>to take you away.</p>
<p>BLANCHE: I am not clean enough.</p>
<p>MITCH: Everyone is not clean enough. Everyone has … a sinful past.
The</p>
<p>world is broken, Blanche …</p>
<p>BLANCHE: No, Mitch. I'm too delicate and painful, but you … are</p>
<p>realistic and natural. How can we live together … just because we
long</p>
<p>for a partner? Sick people have such deep, sincere attachments. But
the</p>
<p>truth is that I’m sick and you’re not. How can you forbear me when
I’m</p>
<p>on the edge of lunacy and want magic?</p>
<p>MITCH: If we … get married, I swear that you won’t be on the edge
of</p>
<p>lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world
is …</p>
<p>always too harsh. [<em>There is a pause.</em>] It’s getting late.
Maybe the</p>
<p>bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend
my</p>
<p>funeral in the future? I have no idea when it will be held. But I
know</p>
<p>it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could
imagine</p>
<p>it. It will be quiet and stainless, with pretty flowers … right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t …
don’t</p>
<p>answer me. Let it be a mystery, a fantastic mystery, just like the
end</p>
<p>of a fairy tale. I had read so many fairy tales when I was young and
I</p>
<p>always imagined that I’m a princess living in a palace, in a
magic</p>
<p>palace, waiting for my prince and then having a happy ending.
Everyone</p>
<p>believes that the protagonists of stories will have a happy ending,
and</p>
<p>I’ll also believe it. Do you know the French story <em>La Porte
étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the
end</p>
<p>of the story, the hero and the heroine get married and have a
happy</p>
<p>ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry.
Tears</p>
<p>are so precious that you should save them for more precious
people.</p>
<p>[*Mitch covers his face with his hands. Blanche wants to wipe away
his</p>
<p>tears at first, but then she hesitates and turns back.*]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the
former</p>
<p>things are passed away.</p>
<p>MITCH [<em>raising his head with eyes full of tears,
hesitantly</em>]: Do you</p>
<p>… do you still remember the inscription?</p>
<p>BLANCHE: What inscription? I have forgotten about it.</p>
<p>MITCH: Alright … alright, I’ll go. Good night, Miss DuBois.</p>
<p>BLANCHE: I shall say “Good night” till it be morrow.</p>
<p>[<em>MITCH leaves.</em>]</p>
<p>BLANCHE: And if God choose, I shall but love thee better after
death.</p>
<p>[<em>The lights fade away.</em>]</p>
<p><strong>END</strong></p>
<h3><span id="summary">SUMMARY</span></h3>
<p>At the end of <em>A Streetcar Named Desire,</em> Blanche says she has
forgotten</p>
<p>something. In this sequel, Mitch visits the asylum where Blanche
is</p>
<p>living to express his wish to take Blanche away. Blanche refuses
him</p>
<p>despite her love for Mitch. While living in the asylum, Blanche
has</p>
<p>understood more about death and love. She knows she is not clean
enough</p>
<p>and wants to go to heaven and love Mitch after death.</p>
<p>Or is this sequel just Blanche’s another dream before death? In
the</p>
<p>Bible, there is no night nor sun in heaven, just like the room.</p>
<h3><span id="theme">THEME</span></h3>
<p>It’s an attempt to explain Blanche’s change after Stanley’s rape.
Before</p>
<p>that, she was afraid of death and tried to avoid harsh light. But
after</p>
<p>that, she claimed that she’d be buried at noon. I tend to link it to
her</p>
<p>chase for a fancy world like heaven.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/" class="post-title-link" itemprop="url">青蛙王子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A0%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">习作</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/" class="post-title-link" itemprop="url">海的女儿</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A0%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">习作</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/" class="post-title-link" itemprop="url">卖火柴的小女孩</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A0%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">习作</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/6/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
