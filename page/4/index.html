<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/4/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">文化课数学导论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A2%AB%E6%96%87%E5%8C%96%E8%AF%BE%E5%88%9B%E9%A3%9E%E4%BA%86/" itemprop="url" rel="index"><span itemprop="name">被文化课创飞了</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2><h3><span id="习惯的更改">习惯的更改</span></h3><p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将$C _{ n  } ^k $写作$\binom { n  } { k  } $,而文化课中不允许此类更改,再者文化课中将$C _{ n  } ^k a ^{ n - k  } b ^k $称作二项式的第$k + 1 $项(从第$1 $项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3><p>首先我们有$E ( aX + b ) = aE ( X ) + b , D ( aX + b ) = a ^2 D ( X ) $.</p>
<p>我们都知道期望满足线性可加,也就是$E ( X _1 + X _2 ) = E ( X _1 ) + E ( X _2 ) $,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若$X _1 $和$X _2 $相互独立,$E ( X _1 X _2 ) = E ( X _1 ) E ( X _2 ) $,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要$X _1 $和$X _2 $相互独立,$D ( X _1 + X _2 ) = D ( X _1 ) + D ( X _2 ) $.从形式上证明是好证明的,我们考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
D ( X _1 + X _2 ) & = E ( ( X _1 + X _2 ) ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + E ( 2 X _1 X _2 ) + E ( X _2 ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + 2 E ( X _1 ) E ( X _2 ) + E ( X _2 ^2 ) - ( E ( X _1 ) + E ( X _2 ) ) ^2 \\
& = E ( X _1 ^2 ) - E ^2 ( X _1 ) + E ( X _2 ^2 ) - E ^2 ( X _2 ) \\
& = D ( X _1 ) + D ( X _2 ) 
\end{aligned}</script><p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为$0 $,不然$D ( X _1 + X _2 ) $要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为$0 $,并且缩放权值,使得方差恰好为$1 $.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为$0 $的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3><h4><span id="两点分布">两点分布</span></h4><p>直接写的话也就是$P ( X ) = \begin{cases}p &amp; X = 1 \ 1 - p &amp; X = 0 \ 0 &amp; other \end{cases} $,事实上这么写可能不太严谨,因为两点分布的$X = 1 $和$X = 0 $两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是$G ( x ) = ( 1 - p ) + px $.由此式子轻松推得$E ( x ) = G ‘ ( 1 ) = p , D ( x ) = E ( x ^2 ) - E ^2 ( x ) = G ‘ ‘ ( 1 ) + G ‘ ( 1 ) - ( G ‘ ( 1 ) ) ^2 = p - p ^2 = p ( 1 - p ) $.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4><p>所谓$n $重伯努利试验,也就是$n $次两点分布的累计,满足$P ( X = k ) = C _{ n  } ^k ( 1 - p ) ^{ n - k  } p ^k $,我们关注两个事情,也就是二项式分布的$E ( X ) = np , D ( X ) = np ( 1 - p ) $,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4><p>所谓不放回取球,考虑目前有$N $个数字,有$M $个是$1 $,剩下$N - M $个是$0 $,取出$n $次,取出了$m $个$1 $的概率.简单组合一下得到此概率为$\frac { C _{ M  } ^m C _{ N - M  } ^{ n - m  }  } { C _{ N  } ^n  } \ $,注意这里必须保证$n \leq N $.</p>
<p>由范德蒙德卷积得知,$\sum _{ m  } C _{ M  } ^m C _{ N - M  } ^{ n - m  } = C _{ N  } ^n $,因此该分布列所有情况之和为$1 $.</p>
<p>考虑其均值,从感性上讲必定是$\frac { nM  } { N  } $.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如$01101 $之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到$1 $的概率,和第二次取得到$1 $的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是$n \frac { N ( N - M ) ( N - n )  } { N ^2 ( N - 1 )  } $,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4><p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写$f ( x ) = \frac { e ^{ - \frac { ( x - \mu ) ^2  } { 2 \sigma ^2  }  }  } { \sigma \sqrt { 2 \pi  }  } \ $,是不是看着非常震撼!其中的方差是$\sigma ^2 $,期望是$\mu $.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足$\sigma = 1 , \mu = 0 $,此时的函数也就是$f ( x ) = \frac { e ^{ - \frac { x ^2  } { 2  }  }  } { \sqrt { 2 \pi  }  } $.一个好奇是,你凭啥说所有情况下的概率之和为$1 $,事实上这其实是因为$g ( x ) = e ^{ - x ^2  } $的积分是$\sqrt { \pi  } $,不会求这个积分.</p>
<p>观察$g ( x ) = e ^{ - x ^2  } $这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数$e ^{ - | x |  } $模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是$\sigma $的由来,将$x \rightarrow \sigma x $,也就是在$x $那里除去一个$\sigma $.而对这个曲线进行横向移动,也就是将$x \rightarrow x - \mu $.</p>
<p>这也就引出所谓的$3 \sigma $原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3><h4><span id="样本相关系数">样本相关系数</span></h4><p>对于若干数据$( x _i , y _i ) $,我们先进行标准化,也就是减去均值后再除以方差,这样做使得$x , y $分别的均值为$0 $,方差为$1 $.下面默认已经标准化过了.</p>
<p>不妨构造$n $维向量$\vec { x  } = ( x _1 , x _2 , \cdots , x _n ) , \vec { y  } = ( y _1 , y _2 , \cdots , y _n ) $,考虑它们的点乘$\vec { x  } \cdot \vec { y  } $,不难发现由于方差为$1 $,因此$| \vec { x  } | = | \vec { y  } | = \sqrt { n  } $,因此它们的点乘为$n \cos \theta $,设$r = \frac { \vec { x  } \cdot \vec { y  }  } { n  } = \cos \theta $.</p>
<p>如果$\exists k $,$\forall i , y _i = kx _i $,此时必有$| r | = 1 $,因此我们断言(为啥呢?其实是不太理解的啊)当$| r | $越靠近$1 $的时候,$x , y $之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4><p>我们在上面的角度审视中提出了一个观点:在满足均值为$0 $的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:$Y = bx + a + e , E ( e ) = 0 , D ( e ) = \sigma ^2 $.</p>
<p>现在我们要做的就是,已知若干组数据$( x _i , y _i ) $,去构造一组$a , b $满足上面的条件.不妨令$e _i = y _i - ( bx _i + a ) $,若$\sum e _i = 0 $,必有$a = \bar { y  } - b \bar { x  } $,带入解得当$\sigma $最小的时候,$b = \frac { \sum _{ i  } ( x _i - \bar { x  } ) ( y _i - \bar { y  } )  } { \sum _{ i  } ( x _i - \bar { x  } ) ^2  } \ $.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个$b $使得$\sigma $最小,标准化说到底只是为了保证$\sigma = 1 $的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4><p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知$P ( AB ) = P ( A ) P ( B ) $,那么我们反推,如果我们在现实中的估计中,发现$P ( AB ) $和$P ( A ) P ( B ) $差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:$P ( 00 ) = \frac { a  } { n  } , P ( 01 ) = \frac { b  } { n  } , P ( 10 ) = \frac { c  } { n  } , P ( 11 ) = \frac { d  } { n  } $.那么$P ( A = 0 ) P ( B = 0 ) = \frac { ( a + b ) ( a + c )  } { n ^2  } $.我们计算它与$P ( 00 ) $的差,平方后除以$P ( A = 0 ) P ( B = 0 ) $然后做四遍求和化简,得到$\chi ^2 = \frac { n ( ad - bc ) ^2  } { ( a + b ) ( a + c ) ( c + d ) ( b + d )  } $.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么$P ( \chi ^2 \geq x _\alpha ) = \alpha $.或者给出我们经验上的准则:</p>
<p>选取一个较小的$\alpha $,并得知其对应的$x _\alpha $,如果$\chi ^2 \geq x _\alpha $,推断独立性不成立,犯错的概率是$\alpha $.反之断言其独立性成立,犯错的概率不可知,肯定$\alpha $越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2><h3><span id="常用对数表">常用对数表</span></h3><ol>
<li><p>$\ln 2 = 0 . 693 $.</p>
</li>
<li><p>$\ln 3 = 1 . 099 $.</p>
</li>
<li><p>$\ln 5 = 1 . 609 $.</p>
</li>
<li><p>$\ln 0 . 1 = - 2 . 303 $.</p>
</li>
<li><p>$\ln 0 . 5 = - 0 . 693 $.</p>
</li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3><ol>
<li><p>$e = 2 . 718 $.</p>
</li>
<li><p>$e ^2 = 7 . 389 $.</p>
</li>
<li><p>$e ^3 = 20 . 086 $.</p>
</li>
<li><p>$e ^5 = 148 . 413 $.</p>
</li>
<li><p>$e ^{ 0 . 1  } = 1 . 105 $.</p>
</li>
<li><p>$e ^{ 0 . 5  } = 1 . 649 $.</p>
</li>
<li><p>$e ^\pi = 23 . 147 $.</p>
</li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3><h4><span id="fxxex">$f(x)=xe^x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = ( x + 1 ) e ^x $,$x = - 1 $的时候,取最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxxln-x">$f(x)=x\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 + \ln x , x = \frac { 1  } { e  } $的时候,有最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow 0 ^{ +  }  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracexx">$f(x)=\frac{e^x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e^xdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { e ^x ( x - 1 )  } { x ^2  } , x = 1 $的时候,有极小值$e $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracln-xx">$f(x)=\frac{\ln x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - \ln x  } { x ^2  } , x = e $的时候,有极大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxx-ln-x">$f(x)=x-\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 - \frac { 1  } { x  } , x = 1 $的时候,有最小值$1 $.</p>
<hr>
<h4><span id="fxfracxex">$f(x)=\frac{x}{e^x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - x  } { e ^x  } , x = 1 $的时候,有最大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<h3><span id="预处理函数">预处理函数</span></h3><h4><span id="分离对数">分离对数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = ( 2 + x + ax ^2 ) \ln ( x + 1 ) - 2 x $,已知$x = 0 $是极大值点,求$a $.</p>
<p>考虑分离对数后操作多项式,我们显然可找到$0 &lt; t &lt; 1 , 2 + t + at ^2 &gt; 0 , 2 - t + at ^2 &gt; 0 $,下面只考虑$x \in [ - t , t ] $.此时$f ( x ) = ( 2 + x + ax ^2 ) ( \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } ) $.</p>
<p>考虑令$g ( x ) = \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } $,由于$f ( 0 ) = 0 $,只需证明$g ( x ) \leq 0 , x \in [ - t , t ] $即可.</p>
<p>而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ' ( x ) & = \frac { 1  } { x + 1  } - \frac { 4 - 2 ax ^2  } { ( 2 + x + ax ^2 ) ^2  } \\
& = \frac { x ^2 ( a ^2 x ^2 + 4 ax + 6 a + 1 )  } { ( x + 1 ) ( 2 + x + ax ^2 )  } \\
\text { sign  } ( g ' ( x ) ) & = \text { sign  } ( a ^2 x ^2 + 4 ax + 6 a + 1 ) 
\end{aligned}</script><p>则$a ^2 0 ^2 + 4 a 0 + 6 a + 1 = 0 $,$a = - \frac { 1  } { 6  } $.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = e ^x - \ln ( x + 1 ) + ax ^3 - x ^2 - 1 $,若$\forall x \in ( - 1 , 1 ) , f ( x ) \geq 0 $,求$a $.</p>
<p>$f ( 0 ) = 0 $,于是上面的条件等价于$0 $是$( - 1 , 1 ) $的最小值点.</p>
<p>考虑$f ‘ ( x ) = e ^x - \frac { 1  } { x + 1  } + 3 ax ^2 - 2 x $,则$f ‘ ( 0 ) = 0 $恒成立.</p>
<p>讨论$g ( x ) = 1 + e ^{ - x  } ( 3 ax ^2 - 2 x - \frac { 1  } { x + 1  } ) $的正负,看$g ‘ ( x ) = \frac { x ( - 3 ax ^3 + 2 x ^2 + ( 9 a + 2 ) x + 6 a - 1 )  } { ( x + 1 ) ^2 e ^x  } $.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3><h4><span id="变化条件">变化条件</span></h4><h5><span id="example">Example</span></h5><p>已知$x + 2 y = 1 $,求$x ^2 + y ^2 $的最小值.</p>
<p>直接令$x = 1 - 2 y $,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^3 = 2 $,求$x + y $的最小值.</p>
<p>这个的话不妨设其最小值为$C $,有$x + y \geq C $,移项得到$y \geq C - x $,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3><h4><span id="普通参数方程">普通参数方程</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^2 - xy = 1 $,求$x + y $的最小值.</p>
<p>这个的话大概是这样,我们找到一个$t $,使得$x = f ( t ) , y = g ( t ) $,然后换元.</p>
<p>比如这个题,你就可以凑成$( x - \frac { y  } { 2  } ) ^2 + ( \frac { \sqrt { 3  }  } { 2  } y ) ^2 = 1 $,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4><h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5><p>求证$\sqrt { ab  } &lt; \frac { a - b  } { \ln a - \ln b  } &lt; \frac { a + b  } { 2  } $.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { a - b  } { \ln a - \ln b  } & < \frac { a + b  } { 2  } \\
\frac { a - b  } { a + b  } & < \frac { \ln \frac { a  } { b  }  } { 2  } \\
\frac { \frac { a  } { b  } - 1  } { \frac { a  } { b  } + 1  } & < \frac { \ln \frac { a  } { b  }  } { 2  } 
\end{aligned}</script><p>换元,令$t = \frac { a  } { b  } $,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5><p>已知函数$f ( x ) = 3 \ln x - ax $,若$x _1 &lt; x _2 $是$f ( x ) $的两个零点,求证$f ‘ ( \frac { x _1 + 3 x _2  } { 4  } ) &lt; 0 $.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
3 \ln x _1 = ax _1 \\
3 \ln x _2 = ax _2 
\end{cases}</script><p>我们想要知道的是:$\frac { 12  } { x _1 + 3 x _2  } &lt; a $.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把$a $给换掉,事实上我们根据前面的方程有$a = \frac { 3 \ln \frac { x _2  } { x _1  }  } { x _2 - x _1  } $.</p>
<p>于是我们只需要证明:$\frac { x _1 + 3 x _2  } { 4  } &gt; \frac { x _2 - x _1  } { \ln \frac { x _2  } { x _1  }  } $,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>同样分析已知,我们得到的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _1 = ax _1 \\
\ln x _2 = ax _2 
\end{cases}</script><p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _2 - \ln x _1 = a ( x _2 - x _1 ) \\
\ln x _2 + \ln x _1 = a ( x _2 + x _1 ) 
\end{cases}</script><p>这里先把所求变形一下,我们把它改成$\ln x _1 + \ln x _2 &gt; 2 $.</p>
<p>发现了什么?这个东西等价于$a ( x _2 + x _1 ) &gt; 2 $,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换$a $即可.</p>
<h5><span id="example4">Example4</span></h5><p>已知$f ( x ) = x ^2 + axe ^x - ae ^{ 2 x  } $有三个不同的零点$x _1 &lt; x _2 &lt; x _3 $,求$a $的范围,并求证$( 1 - \frac { x _1  } { e ^{ x _1  }  } ) ^2 ( 1 - \frac { x _2  } { e ^{ x _2  }  } ) ( 1 - \frac { x _3  } { e ^{ x _3  }  } ) = 1 $.</p>
<p>考虑两边同时除以$e ^{ 2 x  } $,这样得到$g ( x ) = ( \frac { x  } { e ^x  } ) ^2 + a \frac { x  } { e ^x  } - a $,令$t = \frac { x  } { e ^x  } $得到$g ( t ) = t ^2 + at - a = 0 $.</p>
<p>考察$g ( t ) = 0 $的两根$t _1 &lt; t _2 $,根据韦达定理,首先需要满足$\Delta = a ^2 + 4 a &gt; 0 \Rightarrow a &gt; 0 $,然后$t _1 + t _2 = - a , t _1 t _2 = - a $.</p>
<p>接下来考察函数$\frac { x  } { e ^x  } $,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为$t _1 , t _2 $中必有一负,因此$t _2 \in ( 0 , \frac { 1  } { e  } ) $.由此立得$0 &lt; a &lt; \frac { 1  } { e ( e - 1 )  } $.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4><h5><span id="example1">Example1</span></h5><p>若$x &gt; 0 $时,$ax ( e ^{ ax  } + 1 ) \geq 2 ( x ^2 + 1 ) \ln x $恒成立,求$a $取值范围.</p>
<p>一般这种题先判$a $的正负,注意到$x &gt; 1 $的时候右边恒大于$0 $,因此$a &gt; 0 $.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数$2 $放进$\ln $,自然有:$ax ( e ^{ ax  } + 1 ) \geq ( x ^2 + 1 ) \ln x ^2 $.</p>
<p>考虑令$t _1 = ax , t _2 = \ln x ^2 $,则:</p>
<script type="math/tex; mode=display">
t _1 ( e ^{ t _1  } + 1 ) \geq t _2 ( e ^{ t _2  } + 1 )</script><p>接下来分析函数$f ( x ) = x ( e ^x + 1 ) $的单调性,就可以得到$a \geq \frac { 2  } { e  } $.</p>
<h3><span id="不等式相关">不等式相关</span></h3><h4><span id="基本不等式相关">基本不等式相关</span></h4><h5><span id="方程角度的审视">方程角度的审视</span></h5><p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造$\frac { m  } { n  } = k $.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5><p>已知$n , m &gt; 0 , 2 m + n = nm $,求$n + m + \sqrt { n ^2 + m ^2  } $的最小值.</p>
<p>这个题有一个方式是观察到$n , m , \sqrt { n ^2 + m ^2  } $是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n + m + \sqrt { n ^2 + m ^2  } & \geq k \\
\Leftarrow \sqrt { n ^2 + m ^2  } & \geq k - n - m \\

\end{aligned}</script><p>如果$n + m \geq k $,那么不等式显然成立,下面只需要证明$n + m &lt; k $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt { n ^2 + m ^2  } & \geq k - n - m \\
\Leftarrow n ^2 + m ^2 & \geq ( k - ( n + m ) ) ^2 \\
\Leftarrow k ^2 + ( n + m ) ^2 - 2 k ( n + m ) & \leq n ^2 + m ^2 \\
\Leftarrow k ^2 + 2 nm - 2 k ( n + m ) & \leq 0 \\
\Leftarrow k ^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) & \leq 0 \\
\Leftarrow k ^2 & \leq n ( 2 k - 2 ) + m ( 2 k - 4 ) 
\end{aligned}</script><p>变形方程得到$\frac { 2  } { n  } + \frac { 1  } { m  } = 1 $,使用这个式子来降次:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) & = 6 k - 8 + \frac { n  } { m  } ( 2 k - 2 ) + \frac { m  } { n  } ( 4 k - 8 ) \\

\end{aligned}</script><p>要严谨一点的话我们需要证明$4 k - 8 \geq 0 $,$k \geq 2 $.这非常简单,因为$k \geq n + m &gt; 3 $.</p>
<p>这就足够了么?不需要证明存在一个$w = \frac { n  } { m  } $使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>这个等号可以取到,也就是说,只要满足:</p>
<script type="math/tex; mode=display">
k ^2 \leq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下界,特别地,如果满足:</p>
<script type="math/tex; mode=display">
k ^2 = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到$k = 10 $是一个解了),接下来我们必须求出一个$k $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 & = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
k ^2 - 6 k + 8 & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
\sqrt { k - 2  } & = \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } 
\end{aligned}</script><p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个$\sqrt { k - 2  } $带入到上面去!</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 )  } \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } \\
( k - 4 ) ( k - 2 ) & = \frac { 32 ( k - 1 )  } { k - 4  } \\

\end{aligned}</script><p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说$k = 0 $是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出$k = 10 $.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4><h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5><script type="math/tex; mode=display">
\begin{aligned}
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( x _0 )  } { k !  } ( x - x _0 ) ^k \\
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( 0 )  } { k !  } x ^k \\

\end{aligned}</script><h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5><ol>
<li><p>$\frac { 1  } { 1 - x  } = \sum _{ k \geq 0  } x ^k = 1 + x + x ^2 + \cdots \ $.</p>
</li>
<li><p>$e ^x = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } = 1 + x + \frac { 1  } { 2 !  } x ^2 + \cdots \ $.</p>
</li>
<li><p>$\ln ( 1 + x ) = \sum _{ k \geq 1  } ( - 1 ) ^{ k - 1  } \frac { x ^k  } { k  } = x - \frac { 1  } { 2  } x ^2 + \frac { 1  } { 3  } x ^3 + \cdots \ $.</p>
</li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4><h5><span id="example1">Example1</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>极值点偏移的形式,应该是形如$g ( x ) = a $有两个解$x _1 , x _2 $,然后使得$x _1 + x _2 $满足一定条件.因此我们先变形条件:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { \ln x _1  } { x _1  } = a \\
\frac { \ln x _2  } { x _2  } = a 
\end{cases}</script><p>也就是目前我们构造出了函数$g ( x ) = \frac { \ln x  } { x  } $,观察$g ( x ) $图像立得$x _1 + x _2 &gt; 2 e $.</p>
<p>我们发现,$x _1 x _2 \leq \frac { ( x _1 + x _2 ) ^2  } { 4  } $,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为$\ln x _1 + \ln x _2 &lt; 2 $,然后令$t _1 = \ln x _1 , t _2 = \ln x _2 $,带入立有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { t _1  } { e ^{ t _1  }  } = a \\
\frac { t _2  } { e ^{ t _2  }  } = a 
\end{cases}</script><p>而$g ( x ) = \frac { x  } { e ^x  } $恰好也是满足$x _1 + x _2 &gt; 2 $的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5><p>$f ( x ) = x ( 1 - \ln x ) $,$b \ln a - a \ln b = a - b $,求证$2 &lt; \frac { 1  } { a  } + \frac { 1  } { b  } &lt; e $.</p>
<p>首先变形条件得到$b ( 1 + \ln a ) = a ( 1 + \ln b ) $,得到$f ( \frac { 1  } { a  } ) = f ( \frac { 1  } { b  } ) $,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p>$f ‘ ( x ) = - \ln x $,其在$( 0 , 1 ) \uparrow , ( 1 , + \infty ) \downarrow $,考察极值点偏移,我们想要证明$\frac { 1  } { b  } &lt; e - \frac { 1  } { a  } $,我们就想办法把$\frac { 1  } { b  } $和$e - \frac { 1  } { a  } $扔到同一个区间里,而它们确实同在$( 1 , + \infty ) $这个区间内.</p>
<p>比较有启发性的是,你发现$\frac { 1  } { b  } , e - \frac { 1  } { a  } $和$\frac { 1  } { a  } , e - \frac { 1  } { b  } $这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { b  } & < e - \frac { 1  } { a  } \\
f ( \frac { 1  } { a  } ) & = f ( \frac { 1  } { b  } ) & > f ( e - \frac { 1  } { a  } ) 
\end{aligned}</script><p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5><p>$f ( x ) = e ^{ x - 1  } - ax $在$( 0 , 2 ) $有两个零点$x _1 , x _2 $,求证$x _1 x _2 &gt; \frac { 1  } { a  } $.</p>
<p>首先要证明$a $的范围啊,我们不加证明地给出:$a \in ( 1 , \frac { e  } { 2  } ) $,并且$( - \infty , 1 + \ln a ) \downarrow , ( 1 + \ln a , + \infty ) \uparrow $.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
ax _1 = e ^{ x _1 - 1  } \\
ax _2 = e ^{ x _2 - 1  } 
\end{cases}</script><p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取$\ln $,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取$\ln $,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到$x _1 x _2 $和$x _1 + x _2 $之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如$0 &lt; f ( 2 + \ln a - x _2 ) $,也就是$0 &lt; ae ^{ 1 - x _2  } - a ( 2 + \ln a - x _2 ) $.</p>
<p>但是这样有一个问题,我们把$f $带进去,你会发现最后我们的式子同时带有$a , x _2 $,这个就难做了,咋办呢?考虑拿$ax _2 = e ^{ x _2 - 1  } $操作一下把$a $消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4><h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5><ol>
<li><p>$e ^x \geq x + 1 $.</p>
</li>
<li><p>$\frac { x - 1  } { x  } \leq \ln x \leq x - 1 $.</p>
</li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol>
<li>$\ln ( n + 1 ) &lt; \sum _{ k = 1  } ^n \frac { 1  } { k  } $.</li>
</ol>
<p>考虑$\ln ( \frac { n + 1  } { n  } ) &lt; \frac { 1  } { n  } $,左右两边分别求和得到上面的式子.</p>
<ol>
<li>$\ln n &gt; \sum _{ k = 2  } ^n \frac { 1  } { k  } , n &gt; 1 $.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明$\ln \frac { 1  } { n  } &lt; - \sum _{ k = 2  } ^n \frac { 1  } { k  } $.</p>
<p>考虑$\ln ( \frac { n - 1  } { n  } ) \leq - \frac { 1  } { n  } $,两边求和得到上式.</p>
<ol>
<li>$\sum _{ k = 1  } ^n ( \frac { k  } { n  } ) ^n &lt; \frac { e  } { e - 1  } $.</li>
</ol>
<p>考虑$n \ln ( \frac { k  } { n  } ) \leq k - n $,也就有$( \frac { k  } { n  } ) ^n \leq e ^{ k - n  } $,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5><h6><span id="example1">Example1</span></h6><p>设$f ( x ) = x \ln x $,若$f ( x ) = b $有两个实数根$x _1 , x _2 ( x _1 &lt; x _2 ) $,求证:$be + 1 &lt; x _2 - x _1 &lt; \frac { e ^{ - 3  } + 2 + 3 b  } { 2  } $.</p>
<p>注意到$f ( x ) $下凸,考虑求出两条切线,那么这两条切线与$y = b $的交点之差要大于等于$x _2 - x _1 $,两条割线交点之差要小于等于$x _2 - x _1 $.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是$b \rightarrow - \frac { 1  } { e  } $的情况,为了让这种情况有解,我们的割线必过$( \frac { 1  } { e  } , - \frac { 1  } { e  } ) $.</p>
<p>考虑直接选取$( 0 , 0 ) $和$( 1 , 0 ) $作为另外两个点,这两条割线就是$x = - y $和$x = ( e - 1 ) y + 1 $.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得$( x _2 - x _1 ) _{ \max  } $尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是$u $,另一个是$v $,其中$v &lt; \frac { 1  } { e  } &lt; u $,那么两条切线分别是:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = \frac { y - f ( u )  } { f ' ( u )  } + u \\
x = \frac { y - f ( v )  } { f ' ( v )  } + v 
\end{cases}</script><p>那么,现在我们要做的就是找到一组$( u , v ) $,使得:</p>
<script type="math/tex; mode=display">
\frac { b - f ( u )  } { f ' ( u )  } + u - \frac { b - f ( v )  } { f ' ( v )  } - v = \frac { e ^{ - 3  } + 2 + 3 b  } { 2  }</script><p>感觉很难搞啊,我们不妨让$u = 1 $,自然有:</p>
<script type="math/tex; mode=display">
\frac { ( f ' ( v ) - 1 ) b + f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  } + 3 b  } { 2  }</script><p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { f ' ( v ) - 1  } { f ' ( v )  } = \frac { 3  } { 2  } \\
\frac { f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  }  } { 2  } 
\end{cases}</script><p>考虑让$f ‘ ( v ) = - 2 $,则$v = e ^{ - 3  } $,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4><h5><span id="example1">Example1</span></h5><p>求证:$\forall x \in ( 0 , + \infty ) , \ln x + 1 &gt; \frac { 1  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2 x  } $.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以$x $,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为$x \ln x + x &gt; \frac { x  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2  } $,然后证明左边的最小值$\geq $右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4><p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5><p>已知$a = 0 . 1 e ^{ 0 . 1  } , b = \frac { 1  } { 9  } , c = - \ln 0 . 9 $,求比较$a , b , c $的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6><p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算$a $和$c $的大小关系.</p>
<p>构造函数$f ( x ) = xe ^x + \ln ( 1 - x ) $,则$f ( 0 . 1 ) &gt; 0 \Rightarrow a &gt; c $.</p>
<p>考察$f ( 0 ) = 0 $,$f ‘ ( 0 ) = 0 $,$f ‘ ‘ ( 0 ) = 4 &gt; 0 $,则$f ( 0 ) = 0 $是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算$f ( 0 . 1 ) &gt; 0 $.</p>
<h6><span id="估算定积分">估算定积分</span></h6><p>考察$a $和$b $的大小关系,不妨设$f ( x ) = ( 1 - x ) e ^{ 1 - x  } - \frac { 1  } { 10 x  } $,则$f ( 0 . 9 ) &lt; 0 \Rightarrow b &gt; a $.</p>
<p>注意到$f ( 1 ) = - \frac { 1  } { 10  } $,$f ‘ ( 1 ) = - \frac { 9  } { 10  } $,考虑估算一下积分,那么$f ( 0 . 9 ) \approx f ( 1 ) - f ‘ ( 1 ) 0 . 1 = - \frac { 1  } { 100  } &lt; 0 $.</p>
<p>你可能会觉得这个$- \frac { 1  } { 100  } $,是不是不太能那么肯定地估算啊.但是实际上,我们考察$f ‘ ( x ) = ( x - 2 ) e ^{ 1 - x  } + \frac { 1  } { 10 x ^2  } $,这个东西在$[ 0 . 9 , 1 ] $上直觉上平均值是大于$- \frac { 9  } { 10  } $的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6><p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6><p>接下来开抄标答.</p>
<p>令$f _a ( x ) = xe ^x , f _b ( x ) = \frac { x  } { 1 - x  } , f _c ( x ) = - \ln ( 1 - x ) $.</p>
<p>这样当$x = 0 . 1 $的时候所有的数字都被正确表示了.</p>
<p>比较$a , b $:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = \ln ( a ) - \ln ( b ) & = x + \ln ( 1 - x ) \\
y ' & = 1 - \frac { 1  } { 1 - x  } & = \frac { - x  } { 1 - x  } 
\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单减,这样立有$a &lt; b $.</p>
<p>比较$a , c $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = a - c & = xe ^x + \ln ( 1 - x ) \\
y ' & = ( x + 1 ) e ^x - \frac { 1  } { 1 - x  } & = \frac { ( 1 + x ) ( 1 - x ) e ^x - 1  } { 1 - x  } \\

\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单增,这样立有$a &gt; c $.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2><h3><span id="递归式的求解">递归式的求解</span></h3><h4><span id="特征根法">特征根法</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>在上面做$k = 2 $的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6><p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定$a _0 , . . . , a _n $,其中$a _0 \ne 0 $,对于所有的$k \in \mathbb { N  } $,若有下列式子成立:</p>
<script type="math/tex; mode=display">
a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = z _k</script><p>则称为一个$n $阶线性差分方程(或递归关系).为了简化,通常取$a _0 = 1 $.若$\{ z _k \} $是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6><p>我们注意到,对于齐次差分方程而言,如果不给定$y _0 , \cdots y _{ n - 1  } $,只是构造一组满足条件的$y $的话,自然的想法是令$y _k = r ^k $.其中$r $是辅助方程$a _0 r ^{ n  } + a _1 r ^{ n - 1  } + \cdots + a _n = 0 $的一个根.</p>
<p>注意到如果我们将上面的内容看作是$T : \{ y _k \} \mapsto \{ z _k \} $这样一个映射,这显然是一个线性变换.这意味着齐次方程$a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = 0 $的解集就是$T $的核,设为$H $,不难发现只要给定$y _0 , \cdots y _{ n - 1  } $,这个解就唯一确定,将它们看作自由变量,这意味着$\dim H = n $.</p>
<p>还没完,注意到我们解方程可以解出$n $个根,如果这$n $个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了$y _0 , \cdots y _{ n - 1  } $,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这$n $个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的$\mathbb { R  } ^k $的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共$n $个线性无关的根,然后拟合初值.我们如此做:对于一个出现了$m $次的根$r $,我们注意到$r ^k , kr ^k , \cdots , k ^{ m - 1  } r ^k $都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以$kr ^k $作为例子,即证明:</p>
<script type="math/tex; mode=display">
a _0 nr ^n + a _1 ( n - 1 ) r ^{ n - 1  } + \cdots + a _1 r = 0</script><p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个$r $作为根,必然意味着原方程形如$( y - r ) ^2 P $,其中$P $是一个关于$y $的多项式.</p>
<p>我们把它写开:$( y ^2 - 2 ry + r ^2 ) P = 0 $,然后我们用$kr ^k $去代替$r ^k $,不难发现代替后右边还是个多项式,而左边变成了$0 $,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _0 r ^{ n + k  } + a _1 r ^{ n + k - 1  } + \cdots + a _1 r ^k & = 0 \\
a _0 ( n + k ) r ^{ n + k - 1  } + a _1 ( n + k - 1 ) r ^{ n + k - 2  } + \cdots + a _1 kr ^{ k - 1  } & = 0 \\
a _0 ( n + k ) r ^{ n + k  } + a _1 ( n + k - 1 ) r ^{ n + k - 1  } + \cdots + a _1 kr ^{ k  } & = 0 \\

\end{aligned}</script><p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:$( ( y - r ) ^2 P ) ‘ = ( y - r ) ( ( y - r ) P ) ‘ + ( y - r ) ‘ ( y - r ) P = ( y - r ) [ ( y - r ) ‘ P + ( ( y - r ) P ) ‘ ] $,$r $一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6><p>我们注意到齐次差分方程一定能写成$\vec { x  } _k = A \vec { x  } _{ k - 1  } $的形式.如果我们取$A $的特征向量的线性组合作为$\vec { x  } _0 $,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为$1 $的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3><h4><span id="和式的基本运算">和式的基本运算</span></h4><p>分配律:$\ \sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i \ $.</p>
<p>结合律:$\ \sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i $.</p>
<p>交换律:$\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  } $,其中$p $是$S $集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol>
<li><p>$\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] $.</p>
</li>
<li><p>$\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } $.</p>
</li>
</ol>
<p>一般分配律:$\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j ) $.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4><h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6><p>等差数列求和：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\

\end{aligned}</script><p>又有$( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) $,显然有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \leq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \leq b _j \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \geq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \geq b _j \\

\end{aligned}</script><p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6><p>即$\sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \ $.</p>
<p>令$S _n = \sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 \ $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k - a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6><p>$S _n = \sum _{ i = 0  } ^n i ^2 $.</p>
<p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推，我们设$W _n = \sum _{ i = 0  } i ^3 $</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h4><span id="展开和收缩">展开和收缩</span></h4><h6><span id="example1平方和公式">Example1(平方和公式)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="problme3">Problme3</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="problemex2">ProblemEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<p>$g ( x ) = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f ( x ) + C \ $</p>
<p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<p>\Delta(x^{\underline{m}})=mx^{\underline{m-1}}，\sum mx^{\underline{m-1}}\delta x=x^{\underline{m}}+C，m\ne 0\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $，有:</p>
<p>令H(x)=\sum_{i=1}^x\frac{1}{i}\\\Delta(H(x))=x^{\underline{-1}}，\sum x^{\underline{-1}}\delta x =H(x)+C\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<p>$\Delta ( 2 ^x ) = 2 ^x ， \sum 2 ^x \delta x = 2 ^x + C \ $</p>
<p>$\Delta ( c ^x ) = ( c - 1 ) c ^x ， \sum c ^x \delta x = \frac { c ^x  } { c - 1  } + C , c \ne 1 \ $</p>
<p>$\Delta ( c ^{ \underline { x  }  } ) = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x = c ^{ \underline { x  }  } + C , c - x \ne 0 \ $.</p>
<p>根据组合数公式,有:</p>
<p>$\Delta ( \binom { x  } { k  } ) = \binom { x  } { k - 1  } \ $.</p>
<h6><span id="example1">Example1</span></h6><p>仍然考虑平方和公式：</p>
<p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p>$\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \ $.</p>
<h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k 2 ^k \\
& = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x \\
& = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 \\

\end{aligned}</script><h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3">Example3</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } \\
& = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="example4">Example4</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script><h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3><h5><span id="example">Example</span></h5><p>令$A = \{ 2 n - 1 | n \in \mathbb { N  } _{ +  } \} , B = \{ 3 n - 1 | n \in \mathbb { N  } _{ +  } \} $.求$A \cap B $,以及$A \cup B $的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a \in A \Leftrightarrow a & \equiv - 1 \pmod { 2  } \\
b \in B \Leftrightarrow b & \equiv - 1 \pmod { 6  } \\

\end{aligned}</script><p>所以$A \cap B = \{ 6 n - 1 | n \in \mathbb { N  } _{ +  } \} $.</p>
<p>而同理,$x \in A \cup B \Leftrightarrow x \equiv - 1 / - 2 / - 3 / - 5 \pmod { 6  } $.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3><p>设$A = \{ x | x = 2 n - 1 , n \in \mathbb { N  } _+ \} , B = \{ x | x = 2 ^n , n \in \mathbb { N  } _+ \} $,现在将$A \cup B $中的元素排序并提取成一个数列$a $,求使得$S _n &gt; 12 a _n $最小的正整数$n $.</p>
<p>写出数列,它长这样:</p>
<script type="math/tex; mode=display">
\begin{matrix}
1 & 2 \\
3 & 4 \\
5 & 7 & 8 \\
9 & 11 & 13 & 15 & 16 \\
& & \cdots 
\end{matrix}</script><p>不妨设$n $在第$r $行$c $列,显然$( r , c ) $和$n $构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的$n $能快速表达$( r , c ) $,要么反之.显然反之比较简单.</p>
<p>考虑设前$k $行共有$W _k $个数,不难发现$W _{ k + 1  } = W _k + 2 ^{ k - 1  } + 1 , W _k = 2 ^{ k - 1  } + k $.</p>
<p>显然,对于$( r , c ) $来说,它对应的$n $就是$W _{ r - 1  } + c $.</p>
<p>令$SR _{ r  } $为前$r $行数字之和,不难发现$SR _r = 2 ^{ r + 1  } - 2 + ( 2 ^{ r - 1  } ) ^2 $.</p>
<p>接下来考虑找到这个最小的$n $,显然$r \ne 1 $,接下来只考虑$r \geq 2 $的情况.</p>
<p>那么我们可以轻松写出$S _n $和$a _n $的表达式,下面直接给出:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = SR _{ r - 1  } + \sum _{ k = 1  } ^c ( 2 ^{ r - 1  } + 2 k - 1 ) - [ c & = 2 ^{ r - 2  } + 2 ] \\
S _n & = 2 ^r - 2 + 4 ^{ r - 2  } + 2 ^{ r - 1  } c + c ^2 - [ c & = 2 ^{ r - 2  } + 1 ] \\
a _n & = 2 ^{ r - 1  } + 2 c - 1 - [ c & = 2 ^{ r - 2  } + 1 ] 
\end{aligned}</script><p>讨论一下$[ c = 2 ^{ r - 2  } + 1 ] $这个判定式取$0 $还是取$1 $,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3><h2><span id="几何导论">几何导论</span></h2><h3><span id="三角相关">三角相关</span></h3><h4><span id="三角恒等变换">三角恒等变换</span></h4><h5><span id="两角和差公式">两角和差公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( A + B ) & = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) & = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) & = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) & = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) & = \frac { \tan A + \tan B  } { 1 - \tan A \tan B  } \\
\tan ( A - B ) & = \frac { \tan A - \tan B  } { 1 + \tan A \tan B  } 
\end{aligned}</script><h5><span id="倍角公式">倍角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\tan ( 2 A ) & = \frac { 2 \tan A  } { 1 - \tan ^2 A  } \\
\sin ( 2 A ) & = 2 \sin A \cos A \\
\cos ( 2 A ) & = \cos ^2 A - \sin ^2 A & = 2 \cos ^2 A - 1 & = 1 - 2 \sin ^2 A 
\end{aligned}</script><h5><span id="半角公式">半角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 - \cos A  } { 2  }  } \\
\cos ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 + \cos A  } { 2  }  } \\
\tan ( \frac { A  } { 2  } ) & = \frac { \sin A  } { 1 + \cos A  } & = \frac { 1 - \cos A  } { \sin A  } & = \pm \sqrt { \frac { 1 - \cos A  } { 1 + \cos A  }  } 
\end{aligned}</script><h5><span id="和差化积">和差化积</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A + \sin B & = 2 \sin ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\sin A - \sin B & = 2 \cos ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\cos A + \cos B & = 2 \cos ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\cos A - \cos B & = - 2 \sin ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\tan A + \tan B & = \frac { \sin ( A + B )  } { \cos A \cos B  } 
\end{aligned}</script><p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<script type="math/tex; mode=display">
\sin ^2 A - \sin ^2 B = \sin ( A - B ) \sin ( A + B )</script><p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A \sin B & = - \frac { 1  } { 2  } [ \cos ( A + B ) - \cos ( A - B ) ] \\
\cos A \cos B & = \frac { 1  } { 2  } [ \cos ( A + B ) + \cos ( A - B ) ] \\
\sin A \cos B & = \frac { 1  } { 2  } [ \sin ( A + B ) + \sin ( A - B ) ] \\
\cos A \sin B & = \frac { 1  } { 2  } [ \sin ( A + B ) - \sin ( A - B ) ] 
\end{aligned}</script><h5><span id="万能公式">万能公式</span></h5><p>令$w = \tan \frac { A  } { 2  } $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin A & = \frac { 2 w  } { 1 + w ^2  } \\
\cos A & = \frac { 1 - w ^2  } { 1 + w ^2  } \\
\tan A & = \frac { 2 w  } { 1 - w ^2  } 
\end{aligned}</script><p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos ( x ) & = \frac { e ^{ ix  } + e ^{ - ix  }  } { 2  } \\
\sin ( x ) & = \frac { e ^{ ix  } - e ^{ - ix  }  } { 2 i  } 
\end{aligned}</script><h5><span id="补充公式">补充公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
1 + \sin A & = ( \sin \frac { A  } { 2  } + \cos \frac { A  } { 2  } ) ^2 \\
1 - \sin A & = ( \sin \frac { A  } { 2  } - \cos \frac { A  } { 2  } ) ^2 
\end{aligned}</script><h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4><p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的$k $来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6><p>已知函数$f ( x ) = \sin ( \omega x + \varphi ) , w &gt; 0 $,$f ( - \frac { \pi  } { 6  } ) = 0 , f ( \frac { \pi  } { 2  } ) = - 1 $,求$w $和$\varphi $的表达式.</p>
<p>正确做法应该是强设$k _1 , k _2 $,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的$\omega $和$\varphi $都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令$\frac { \pi  } { 2  } $为单位$1 $,我们必有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- \frac { \omega  } { 3  } + \varphi & \equiv 0 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><p>下面推导$\omega $,首先将上面两个式子直接相减,立有:</p>
<script type="math/tex; mode=display">
\frac { 4  } { 3  } \omega \equiv 1 \pmod { 2  }</script><p>对于$\varphi $,考虑类似的做法,将第一个式子乘以$3 $后与第二个式子相加,立有:</p>
<script type="math/tex; mode=display">
4 \varphi \equiv 1 \pmod { 2  }</script><p>这样我们得到的必须满足的条件就有以下几条:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 4  } { 3  } \omega & \equiv 1 \pmod { 2  } \\
4 \varphi & \equiv 1 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><h3><span id="向量相关">向量相关</span></h3><h4><span id="旋转模型">旋转模型</span></h4><p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6><p>已知$AB = 2 , AC = 1 , \angle A = \theta $,$BC $绕$B $点顺时针旋转$\frac { \pi  } { 3  } $得到$BD $,求以$\theta $表示$S _{ \triangle CBD  } $.</p>
<p>先来说文化课做法,我们直接表示$S $,令$\alpha = \angle ABC $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S & = | BD | \sin ( \alpha + \frac { \pi  } { 3  } ) \\

\end{aligned}</script><p>对于这个式子,我们发现如果我们能得到$| BD | \sin ( \alpha ) $和$| BD | \cos ( \alpha ) $就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现$BD $是$\alpha $的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出$| BD | \sin \alpha $,余弦定理可以帮助我们求出$| BD | \cos \alpha $.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出$\overrightarrow { AB  } $和$\overrightarrow { BC  } $的坐标表示,将$\overrightarrow { BC  } $用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4><p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol>
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p>
</li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作$1 $是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p>
</li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6><p>$\triangle ABC $中,$b ^2 = ac $,点$D $在$AC $上且满足$BD = b $,有$\overrightarrow { AD  } = 2 \overrightarrow { DC  } $,求$\cos \angle ABC $.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定$c = 1 $,于是有$b ^2 = a $.</p>
<p>考虑我们要求$\cos \angle ABC $,而我们有一条很奇怪的边$BD $,似乎不满足任何性质,我们立刻想到要把它用$\angle ABC $的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让$c = 1 $,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4><h5><span id="奔驰定理">奔驰定理</span></h5><p>对于$\triangle ABC $内一点$P $,立有$S _{ \triangle PBC  } \overrightarrow { PA  } + S _{ \triangle PAC  } \overrightarrow { PB  } + S _{ \triangle PAB  } \overrightarrow { PC  } = \vec { 0  } $.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令$a = PA , b = PB , c = PC $,我们要证奔驰定理,也就是要证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
bc \sin \alpha \overrightarrow { PA  } + ac \sin \beta \overrightarrow { PB  } + ab \sin \gamma \overrightarrow { PC  } & = \vec { 0  } \\
abc \sin \alpha \frac { \overrightarrow { PA  }  } { a  } + abc \sin \beta \frac { \overrightarrow { PB  }  } { b  } + abc \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\
\sin \alpha \frac { \overrightarrow { PA  }  } { a  } + \sin \beta \frac { \overrightarrow { PB  }  } { b  } + \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\

\end{aligned}</script><p>考虑$| \frac { \overrightarrow { PA  }  } { a  } | = | \frac { \overrightarrow { PB  }  } { b  } | = | \frac { \overrightarrow { PC  }  } { c  } | = 1 $,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5><p>有正弦定理,$| \overrightarrow { OA  } | = | \overrightarrow { OB  } | = | \overrightarrow { OC  } | = \frac { a  } { 2 \sin A  } $.</p>
<p>考虑三个三角形的面积可以表示为$\frac { r ^2  } { 2  } \sin \theta $,又考虑到圆中的$\theta $是圆心角是圆周角的两倍,立有$\sin ( 2 A ) \overrightarrow { OA  } + \sin ( 2 B ) \overrightarrow { OB  } + \sin ( 2 C ) \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6><p>在$\triangle ABC $中,$AB = 2 , BC = \sqrt { 10  } , AC = 3 $,若$O $是其外心,且$\overrightarrow { AO  } = p \overrightarrow { AB  } + q \overrightarrow { AC  } $.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用$| OA | = | OB | = | OC | $,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于$p , q $的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了$| OA | $,用上$| OB | $,这样的话我们两边同时加上$\overrightarrow { BA  } $,就可以得到$p , q $的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据$| OC | $也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { AO  } & = p \overrightarrow { AB  } + q \overrightarrow { AC  } \\
\vec { 0  } & = ( p + q - 1 ) \overrightarrow { OA  } + p \overrightarrow { OB  } + q \overrightarrow { OC  } 
\end{aligned}</script><p>考察奔驰定理,立有$\frac { p + q - 1  } { \sin ( 2 A )  } = \frac { p  } { \sin ( 2 B )  } = \frac { q  } { \sin ( 2 C )  } $,简单题.</p>
<h6><span id="example2">Example2</span></h6><p>已知相异两点$O , H $分别为$\triangle ABC $的外心和垂心,若$\overrightarrow { OH  } = m ( \overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } ) $,求$m $.</p>
<p>这题要用到的性质是,我们一定要知道$( \overrightarrow { OB  } + \overrightarrow { OC  } ) \cdot \overrightarrow { BC  } = 0 $,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出$\overrightarrow { AH  } $,然后两边同时乘以$\overrightarrow { BC  } $就可以解决.注意到最后解方程的时候要么$m = 1 $,要么三角形等边,但是我们声明过$O , H $相异两点.</p>
<h5><span id="重心">重心</span></h5><p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的$1 : 2 $的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若$O $是重心,则必有$\overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5><p>若$O $是重心,立有$\overrightarrow { OA  } \cdot \overrightarrow { BC  } = 0 $,将$\overrightarrow { BC  } = \overrightarrow { BO  } + \overrightarrow { OC  } $,立有$\overrightarrow { OA  } \cdot \overrightarrow { OB  } = \overrightarrow { OA  } \cdot \overrightarrow { OC  } = \overrightarrow { OB  } \cdot \overrightarrow { OC  } $.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有$\overrightarrow { OA  } \tan A + \overrightarrow { OB  } \tan B + \overrightarrow { OC  } \tan C = \vec { 0  } $.</p>
<h5><span id="内心">内心</span></h5><p>根据奔驰定理,立有$a \overrightarrow { OA  } + b \overrightarrow { OB  } + c \overrightarrow { OC  } = \vec { 0  } $.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3><h4><span id="基本概念">基本概念</span></h4><h5><span id="直线">直线</span></h5><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h5><span id="平面">平面</span></h5><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h5><span id="夹角">夹角</span></h5><h6><span id="两直线夹角">两直线夹角.</span></h6><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h5><span id="交点">交点</span></h5><p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3><h4><span id="约定">约定</span></h4><p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可($mx + ny = 1 $需要判断过原点的直线,$y = kx + b $需要判断平行于$y $轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之和为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | F _1 P | + | F _2 P | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5><h6><span id="标准方程">标准方程</span></h6><p>由定义不难得到椭圆的标准方程:$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( b ^2 = a ^2 - c ^2 , a &gt; b &gt; 0 ) $.</p>
<h6><span id="一般方程">一般方程</span></h6><p>$nx ^2 + my ^2 = 1 ( n , m \geq 0 ) $,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下$n $和$m $的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = a - ex _0 $.</p>
<h6><span id="焦点弦">焦点弦</span></h6><p>过$F _1 $的弦$| AB | = 2 a + e ( x _1 + x _2 ) $.</p>
<p>过$F _2 $的弦$| AB | = 2 a - e ( x _1 + x _2 ) $.</p>
<p>注意到焦点弦最短时$x _1 = x _2 $.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li><p>$C = 2 a + 2 c $.</p>
</li>
<li><p>$S = b ^2 \tan \frac { \theta  } { 2  } = c | y _P | $.</p>
</li>
<li><p>$\cos \theta \geq 1 - 2 e ^2 $(当$P $在短轴上取等).</p>
</li>
<li><p>$| PF _1 | | PF _2 | = \frac { 2 b ^2  } { 1 + \cos \theta  } $.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example1">Example1</span></h6><p>已知椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,$P $是椭圆上一点,$\angle F _1 PF _2 $的角平分线交$x $轴于$Q ( \frac { c  } { 4  } , 0 ) $,求离心率取值范围.</p>
<p>注意到$S _{ \bigtriangleup QPF _1  } = \frac { 5  } { 3  } S _{ \bigtriangleup QPF _2  } $,又有$Q $到$PF _1 $和$PF _2 $的距离相等,用等积法,显然$PF _1 = \frac { 5  } { 4  } a , PF _2 = \frac { 3  } { 4  } a $.</p>
<p>然后用三角形不等式做差就行.$2 c &gt; \frac { 1  } { 2  } a , \frac { 1  } { 4  } &lt; e $</p>
<h4><span id="双曲线">双曲线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之差为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | | F _1 P | - | F _2 P | | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) , ( x _0 &gt; 0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = - a + ex _0 $.</p>
<h6><span id="渐近线">渐近线</span></h6><p>$y = \pm \frac { b  } { a  } x $.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成$0 $得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li>$S = \frac { b ^2  } { \tan \frac { \theta  } { 2  }  } $.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5><h6><span id="焦点弦">焦点弦</span></h6><p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线$AB $为过$y ^2 = 2 px ( p &gt; 0 ) $焦点的弦,$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,倾斜角为$\theta $,准线与$x $轴交点为$E ( - \frac { p  } { 2  } , 0 ) $,作$AA _1 $,$BB _1 $垂直于准线于$A _1 , B _1 $,则:</p>
<ol>
<li><p>$| AF | = x _1 + \frac { p  } { 2  } $,$| BF | = x _2 + \frac { p  } { 2  } $,$| AB | = x _1 + x _2 + p , \frac { 1  } { | FA |  } + \frac { 1  } { | FB |  } = \frac { 2  } { p  } $.</p>
</li>
<li><p>$| AF | = \frac { p  } { 1 - \cos \theta  } , | BF | = \frac { p  } { 1 + \cos \theta  } , | AB | = \frac { 2 p  } { \sin ^2 \theta  } $.</p>
</li>
<li><p>$x _1 x _2 = \frac { p ^2  } { 4  } $,$y _1 y _2 = - p ^2 $.</p>
</li>
<li><p>$S _{ \bigtriangleup AOB  } = \frac { p ^2  } { 2 \sin \theta  } $.</p>
</li>
<li><p>$k _{ AE  } + k _{ BE  } = 0 $.</p>
</li>
<li><p>$A , O , B _1 $三点共线,$B , O , A _1 $三点共线.</p>
</li>
<li><p>以$AB $为直径的圆与抛物线的准线相切.</p>
</li>
<li><p>以$A _1 B _1 $为直径的圆与$AB $相切.</p>
</li>
<li><p>以$AF $或$BF $为直径的圆与$y $轴相切.</p>
</li>
</ol>
<h4><span id="通用解法">通用解法</span></h4><h5><span id="联立方程">联立方程</span></h5><h6><span id="点参">点参</span></h6><p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线$l $上有两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,那么$| NM | = \sqrt { 1 + k ^2  } | x _1 - x _2 | = \sqrt { 1 + \frac { 1  } { k ^2  }  } | y _1 - y _2 | $.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,其中点$M ( x _0 , y _0 ) $,有$2 x _0 = x _1 + x _2 , 2 y _0 = y _1 + y _2 $.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线$l $与曲线交于两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,$MN $的中点为$P ( x _0 , y _0 ) $,那么:</p>
<ol>
<li><p>在椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( a &gt; b &gt; 0 ) $中,$k \frac { y _0  } { x _0  } = - \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $中,$k \frac { y _0  } { x _0  } = \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在抛物线$y ^2 = 2 px ( p &gt; 0 ) $中,$k = \frac { p  } { y _0  } = \frac { x _0  } { p  } $.</p>
</li>
</ol>
<h6><span id="小联立">小联立</span></h6><p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6><p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线$PA $,$PB $,我们可以将公共点$P $平移至原点,这样$PA $和$PB $的方程都方便表达.然后设$AB $的方程为$mx + ny = 1 $(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以$mx + ny $,零次项乘以$( mx + ny ) ^2 $,这样就得到了一个齐次式子.将两边同时除以$x ^2 $后就得到了一个和$k = \frac { y  } { x  } $有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的$x _1 x _2 $和$x _1 + x _2 $之间的关系来做.</p>
<p>当然还有一种情况是问形如$\frac { Ax _1 + Bx _2  } { Cx _1 + Dx _2  } $是定值的问题,这个时候一定有$\frac { A  } { C  } = \frac { B  } { D  } $.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令$w = \frac { x _1  } { x _2  } $,自然有$w + \frac { 1  } { w  } + 2 = \frac { ( x _1 + x _2 ) ^2  } { x _1 x _2  } $.</p>
<p>还比如有$y _2 = ny _1 + m $,我们可以用配凑技巧改写作$( y _2 + w ) = k ( y _1 + w ) $,也就有$\frac { y _2 + w  } { y _1 + w  } = k $,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线$y = kx + \varphi $与曲线$\frac { x ^2  } { m  } + \frac { y ^2  } { n  } = 1 $相交于$A ( x _1 , y _1 ) $和$B ( x _2 , y _2 ) $.</p>
<p>那么联立方程是:$( n + mk ^2 ) x ^2 + 2 k \varphi mx + m ( \varphi ^2 - n ) = 0 $.</p>
<p>判别式:$\Delta = 4 mn ( n + mk ^2 - \varphi ^2 ) $.</p>
<p>韦达定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x _1 + x _2 & = \frac { - 2 km \varphi  } { n + mk ^2  } \\
x _1 x _2 & = \frac { m ( \varphi ^2 - n )  } { n + mk ^2  } \\
| x _1 - x _2 | & = \frac { \sqrt { \Delta  }  } { n + mk ^2  } 
\end{aligned}</script><h6><span id="配凑法">配凑法</span></h6><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/521025768">https://zhuanlan.zhihu.com/p/521025768</a>.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6><p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线$y ^2 = 4 x $,若$A , B $位于抛物线上$x $轴上方不同的两点,直线$OA , OB $的斜率分别为$k _1 , k _2 $,且满足$k _1 k _2 - 4 = 4 k _1 + 4 k _2 $,求证:$AB $过定点,并求出$k _{ AB  } $的取值范围.</p>
<p>注意到$k _1 $和$k _2 $之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设$AB : y = kx + b $,则$A ( x _1 , kx _1 + b ) , B ( x _2 , kx _2 + b ) $,显然$k _1 = k + \frac { b  } { x _1  } , k _2 = k + \frac { b  } { x _2  } $.</p>
<p>直接带入方程,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k + \frac { b  } { x _1  } ) ( k + \frac { b  } { x _2  } ) - 4 & = 4 ( 2 k + \frac { b  } { x _1  } + \frac { b  } { x _2  } ) \\
k ^2 + kb ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) + \frac { b ^2  } { x _1 x _2  } - 4 & = 8 k + 4 b ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) \\

\end{aligned}</script><p>而直接大联立得到的式子是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 x ^2 + ( 2 kb - 4 ) x + b ^2 & = 0 \\
\Delta & = 16 - 16 kb & > 0 , kb & < 1 \\
x _1 x _2 & = \frac { b ^2  } { k ^2  } , x _1 + x _2 & = \frac { 4 - 2 kb  } { k ^2  } , \frac { 1  } { x _1  } + \frac { 1  } { x _2  } & = \frac { 4 - 2 kb  } { b ^2  } 
\end{aligned}</script><p>带入,得到$k - b = 4 $,因此过定点$( - 1 , - 4 ) $,与$kb &lt; 1 $联立得到$k &lt; 2 + \sqrt { 5  } $.</p>
<p>还没完,这种题一定要检查一遍条件.注意到$AB $为$x $轴上方两点的性质没用到,这意味着$y _1 y _2 &gt; 0 \land y _1 + y _2 &gt; 0 $,带入方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b ^2 + b ( \frac { 4 - 2 kb  } { k  } ) + b ^2 & > 0 \\
\frac { 4 - 2 kb  } { k  } + 2 b & > 0 
\end{aligned}</script><p>化简得到$\begin{cases}b &gt; 0 \ k &gt; 0 \end{cases} $,解得$k &gt; 4 $,于是$k \in ( 4 , 2 + \sqrt { 5  } ) $.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,$OA $和$OB $的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k _{ OA  } & = \frac { y _1  } { x _1  } , k _{ OB  } & = \frac { y _2  } { x _2  } \\
\frac { y _1 y _2  } { x _1 x _2  } - 4 & = 4 ( \frac { y _1  } { x _1  } + \frac { y _2  } { x _2  } ) \\
16 - 4 y _1 y _2 & = 16 ( y _1 + y _2 ) 
\end{aligned}</script><p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<script type="math/tex; mode=display">
\begin{aligned}
AB : \\
x - x _1 & = ( y - y _1 ) \frac { x 1 - x _2  } { y _1 - y _2  } \\
x - \frac { y _1 ^2  } { 4  } & = ( y - y _1 ) \frac { 1  } { 4  } ( y _1 + y _2 ) \\
x & = \frac { y _1 + y _2  } { 4  } y - \frac { y _1 y _2  } { 4  } \\
x & = \frac { y _1 + y _2  } { 4  } y - 1 + ( y _1 + y _2 ) 
\end{aligned}</script><p>显然过定点$( - 1 , - 4 ) $,并且通过$y _1 $和$y _2 $的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个$\frac { x - x _1  } { x _1 - x _2  } = \frac { y - y _1  } { y _1 - y _2  } $的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + y ^2 = 1 $,$P , Q $在椭圆上,$A ( 2 , 0 ) $,$k _{ AP  } k _{ AQ  } = \frac { 1  } { 20  } $,求证:$PQ $过定点.</p>
<p>注意到$A ( 2 , 0 ) $,设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$PQ : m ( x - 2 ) + yn = 1 $,那么我们要求的也就是$x - 2 $和$y $之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然$\frac { x ^2  } { 4  } + y ^2 = 1 \Rightarrow \frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 $.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令$x ‘ = x - 2 , y ‘ = y $,我们有$x = x ‘ + 2 , y = y ‘ $,带入就可以得到关于$x ‘ , y ‘ $的方程,然后再带回$x $和$y $就行.</p>
<p>我们开始推导:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 \\
( x - 2 ) ^2 + 4 ( x - 2 ) + 4 y ^2 = 0 \\
( x - 2 ) ^2 + 4 n ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
( 4 n + 1 ) ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
4 n + 1 + 4 m \frac { y  } { x - 2  } + 4 ( \frac { y  } { x - 2  } ) ^2 = 0 \\

\end{aligned}</script><p>令$k = \frac { y  } { x - 2  } $,也就得到了$4 n + 1 + 4 mk + 4 k ^2 = 0 $.用一遍韦达定理,有:$k _1 k _2 = \frac { 4 n + 1  } { 4  } = \frac { 1  } { 20  } , n = - \frac { 1  } { 5  } $.</p>
<p>也就有:$PQ : - \frac { 1  } { 5  } ( x - 2 ) + my = 1 $,显然过定点$( - 3 , 0 ) $.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 9  } + y ^2 = 1 $,$P , Q $是该椭圆上两动点,$M , N $分别为$P , Q $在$x $轴上的射影,而且$k _{ OP  } k _{ OQ  } = - 1 $,记$S = S _{ \bigtriangleup OPM  } + S _{ \bigtriangleup OQN  } $,求$S $的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线$PQ $很重要的时候,而这个题除了$P , Q $两点以外,和$PQ $半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$k = \frac { y _1  } { x _1  } , - \frac { 1  } { k  } = \frac { y _2  } { x _2  } $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = | x _1 y _1 | + | x _2 y _2 | \\
& = | x _1 ^2 k - \frac { 1  } { k  } x _2 ^2 | \\

\end{aligned}</script><p>而联立方程,有:</p>
<script type="math/tex; mode=display">
x _1 ^2 = \frac { 1  } { \frac { 1  } { 9  } + k  } , x _2 ^2 = \frac { 1  } { \frac { 1  } { 9  } - \frac { 1  } { k  }  }</script><p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线$PQ $有两个未知量,我们还需要拿$k _{ OP  } k _{ OQ  } = - 1 $限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 2  } + y ^2 = 1 $,$F ( 1 , 0 ) $,直线$l $过$F $且交椭圆于$A , B $两点.求问:$x $轴上是否存在异于$F $的一点$Q $,使得$\frac { k _{ QA  }  } { k _{ QB  }  } $是定值.</p>
<p>直接设$AB : x = ky + 1 $,$Q ( q , 0 ) $.我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = \frac { y _1 ( q - x _2 )  } { y _2 ( q - x _1 )  } \\
& = - \frac { ky _1 y _2 + y _1 - qy _1  } { ky _1 y _2 + y _2 - qy _2  } 
\end{aligned}</script><p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k ^2 + 2 ) y ^2 + 2 ky - 1 & = 0 \\
\Delta & = 8 k ^2 + 8 & > 0 \\
y _1 + y _2 & = - \frac { 2 k  } { k ^2 + 2  } \\
y _1 y _2 & = - \frac { 1  } { k ^2 + 2  } \\

\end{aligned}</script><p>注意到$\frac { ( y _1 + y _2 )  } { 2  } = k ( y _1 y _2 ) $,代入,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = - \frac { y _1 + y _2 + 2 y _1 - 2 qy _1  } { y _1 + y _2 + 2 y _2 - 2 qy _2  } \\
& = - \frac { ( 3 - 2 q ) y _1 + y _2  } { ( 3 - 2 q ) y _2 + y _1  } 
\end{aligned}</script><p>若是定值,那么就有:$\frac { 3 - 2 q  } { 1  } = \frac { 1  } { 3 - 2 q  } $,解得$q _1 = 1 ( F ) $,$q _2 = 2 ( Q ) $.</p>
<p>所以$Q ( 2 , 0 ) $.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,过$F ( - 1 , 0 ) $的直线交椭圆于$M , N $两点,过$M $作直线$x = - 4 $的垂线,垂足为$E $,求证:$EN $过定点.</p>
<p>根据对称原理,显然这个定点一定在$x $轴上.</p>
<p>我们先写大联立的式子:设$MN : x = - 1 + ky $,带入有$( 3 m ^2 + 4 ) y ^2 - 6 my - 9 = 0 $.再设$M ( x _1 , y _1 ) , N ( x _2 , y _2 ) $,自然有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\Delta = 144 k ^2 + 144 \\
y _1 + y _2 = \frac { 6 k  } { 3 k ^2 + 4  } \\
y _1 y _2 = \frac { - 9  } { 3 k ^2 + 4  } 
\end{cases}</script><p>接下来呢,我们想一下我们要求什么:我们要求出$EN $的表达式:形如$y - m = k ( x - n ) $,然后声明$( n , m ) $是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有$k = \frac { y - m  } { x - n  } $.而我们现在有两个点$E ( - 4 , y _1 ) $和$N ( x _2 , y _2 ) $,又猜出$m = 0 $,也就是我们要找到一个$n $满足$\frac { y _1  } { - 4 - n  } = \frac { y _2  } { x _2 - n  } $.</p>
<p>我们倒着推:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { x _2 - n  } \\
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { ky _2 - 1 - n  } 
\end{aligned}</script><p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ky _1 y _2 + \frac { 3  } { 2  } ( y _1 + y _2 ) & = 0 \\
( x _2 + \frac { 5  } { 2  } ) y _1 & = - \frac { 3  } { 2  } y _2 \\
y _1 & = \frac { - 3  } { 2  } \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - \frac { 3  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - 4 + \frac { 5  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\

\end{aligned}</script><p>做到这一步发现要做完了,不难发现$n = \frac { 5  } { 2  } $.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了$m = 0 $了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5><h6><span id="定义">定义</span></h6><p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点$P $作直线$l $交二次曲线于$M , N $两点(离$P $近的是$M $),则在$l $上有且只有一点$Q $,使得$| MQ | | NP | = | MP | | NQ | $(即$P , Q , M , N $构成一调和点列).当$l $绕着$P $旋转时,$Q $的轨迹是一条直线$p $(或一部分),这条直线$p $叫做点$P $关于二次曲线的极线,而$P $叫做$p $关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:$p : \frac { x _0 x  } { a ^2  } + \frac { y _0 y  } { b ^2  } = 1 $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线$C : Ax ^2 + Bxy + Cy ^2 + Dx + Ey + F = 0 $上的一点$P ( x _0 , y _0 ) $,我们称它的极线为$p : Axx _0 + B \frac { x _0 y + y _0 x  } { 2  } + Cyy _0 + D \frac { x + x _0  } { 2  } + E \frac { y + y _0  } { 2  } + F = 0 $.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6><p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线$C $,如果点$P $的极线经过点$Q $,那么点$Q $的极线经过点$P $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol>
<li><p>设四边形$ABCD $(对边不平行)内接于二次曲线$C $,则对角线交点$P $的极线是两组对边交点的连线.反之同理,若$P $在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p>
</li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p>
</li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p>
</li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6><p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知$\frac { \cos \theta  } { a  } + \frac { \sin \theta  } { b  } = 1 $,求证:$\frac { 1  } { a ^2  } + \frac { 1  } { b ^2  } \geq 1 $.</p>
<p>设直线$l : \frac { x  } { a  } + \frac { y  } { b  } = 1 $,$M ( \cos \theta , \sin \theta ) $,则$M $在$l $上.</p>
<p>又注意到$M $显然是在单位圆上,而$l $是单位圆关于$P ( \frac { 1  } { a  } , \frac { 1  } { b  } ) $的极点.又注意到$l $与单位圆至少有一个交点,因此$P $要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,$A _1 ( - 2 , 0 ) , A _2 ( 2 , 0 ) , D ( \frac { 1  } { 2  } , 0 ) $,过$D $的直线交椭圆于$P , Q $两点(不与$A _1 , A _2 $重合).$A _1 P \cap A _2 Q = M $,$A _1 Q \cap A _2 P = N $,设$k _1 = k _{ A _1 P  } , k _2 = k _{ A _1 Q  } $.求证:$k _1 k _2 $是定值,求出这个定值并求出$\bigtriangleup DMN $面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知$MN : x = 8 $.</p>
<p>我们先来看已知$MN : x = 8 $之后怎么做:</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,再设$PQ : x = ky + \frac { 1  } { 2  } $,则:$k _1 k _2 = \frac { y _1  } { x _1 + 2  } \frac { y _2  } { x _2 + 2  } $,不难算出$k _1 k _2 = - \frac { 9  } { 20  } $.</p>
<p>此时$S _{ \bigtriangleup DMN  } = | MN | | 8 - \frac { 1  } { 2  } | \frac { 1  } { 2  } $.不难发现只需求出$| MN | _{ \min  } $即可.而$MN \bot x $轴,所以$| MN | = | y _M - y _N | $.</p>
<p>接下来咋做?第一问求得$k _1 $和$k _2 $的关系不能白求啊!</p>
<p>我们有$A _1 P : x = - 2 + \frac { 1  } { k _1  } y , A _1 Q : x = - 2 + \frac { 1  } { k _2  } y $,带入$x = 8 $,求得$y _M = 10 k _1 , y _N = 10 k _2 $.</p>
<p>于是$| MN | = 10 | k _1 - k _2 | $.注意到$k _1 &gt; 0 \land - k _2 &gt; 0 \land k _1 ( - k _2 ) = \frac { 9  } { 20  } $,显然可以用基本不等式计算,最后得到$S _{ \min  } = \frac { 45 \sqrt { 5  }  } { 2  } $.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出$A _1 Q : x = - 2 + \frac { y _2  } { x _2 + 2  } y , A _2 P : x = 2 + \frac { y _1  } { x _1 - 2  } y $,然后我们声明这两条直线的交点的横坐标一定是$8 $,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5><p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们将$y $看作$x $的函数,对两边求导,自然得到:</p>
<script type="math/tex; mode=display">
\frac { 2 x  } { a ^2  } + \frac { 2 yy '  } { b ^2  } = 0</script><p>这是个方程,你可以解得$y ‘ = - \frac { b ^2 x  } { a ^2 y  } $.而这就是椭圆过$( x , y ) $这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5><p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6><p>向量$\vec { b  } = ( x , y ) $逆时针旋转$\theta $后得到的答案是$A \vec { b  } $,其中</p>
<p>\cos\theta,-\sin\theta\\</p>
<p>\sin\theta,\cos\theta</p>
<p>\end{bmatrix} </p>
<p>你要不喜欢矩阵表示也不是不行,那向量$( x , y ) $旋转$\theta $得到$( x ‘ , y ‘ ) $,其中</p>
<p>y’=xsin\theta+ycos\theta</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6><p>我们注意到圆的方程是$( x ‘ ) ^2 + ( y ‘ ) ^2 = 1 $,而椭圆的方程形如$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们注意到上面的式子等价于:$( \frac { x  } { a  } ) ^2 + ( \frac { y  } { b  } ) ^2 = 1 $.我们将原坐标系中的所有坐标$( x , y ) $全部变成$( \frac { x  } { a  } , \frac { y  } { b  } ) $之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令$\vec { f  } = ( x , y ) $满足椭圆方程,令$\vec { g  } = ( x ‘ , y ‘ ) $满足圆的方程,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}
\frac { 1  } { a  } , 0 \\
0 , \frac { 1  } { b  } 
\end{bmatrix} \vec { f  } & = \vec { g  } \\

\end{aligned}</script><script type="math/tex; mode=display">
\begin{bmatrix}
a , 0 \\
0 , { b  } 
\end{bmatrix} \vec { g  } = \vec { f  }</script><h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6><p>注意到反比例函数的方程是$x ‘ y ‘ = 1 $,而双曲线的方程是$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
<p>首先先转化为$x ^2 - y ^2 = 2 $的形式,需要左乘矩阵$\begin{bmatrix}\frac { \sqrt { 2  }  } { a  } , 0 \ 0 , \frac { \sqrt { 2  }  } { b  } \end{bmatrix} $.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转$\frac { \pi  } { 4  } $了.旋转矩阵为</p>
<p>\frac{1}{\sqrt{2}},-\frac{1}{\sqrt{2}}\\</p>
<p>\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>\frac{1}{a},-\frac{1}{b}\\</p>
<p>\frac{1}{a},\frac{1}{b}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x ‘ = \frac { x  } { a  } - \frac { y  } { b  } , y ‘ = \frac { x  } { a  } + \frac { y  } { b  } $.带入反比例函数的方程:</p>
<script type="math/tex; mode=display">
x ' y ' = \frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1</script><p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>\frac{a}{2},\frac{a}{2}\\</p>
<p>-\frac{b}{2},\frac{b}{2}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x = \frac { a  } { 2  } ( x ‘ + y ‘ ) , y = \frac { b  } { 2  } ( { y ‘ - x ‘  } ) $,带入双曲线方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \frac { x  } { a  } ) ^2 - ( \frac { y  } { b  } ) ^2 & = 1 \\
( x ' + y ' ) ^2 - ( x ' - y ' ) ^2 & = 4 \\
x ' y ' & = 1 
\end{aligned}</script><p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6><p>这个比较简单,交换$x , y $即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5><p>平面内取一点$O $为极点,引一条射线$Ox $叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点$M $,令$\rho = | OM | $,$\theta $为以$Ox $为始边,沿角度正方向(一般是逆时针方向)转到$OM $的夹角.那么我们称$( \rho , \theta ) $为$M $的极坐标,其中$\rho $叫做极径,$\theta $叫做极角.</p>
<p>$\rho $有可能取负,我们通常认为$( - \rho , \theta ) = ( \rho , \theta + \pi ) $.</p>
<p>通常情况下默认$0 \leq \theta &lt; 2 \pi , \rho \geq 0 $.如果遇到和直角坐标系结合的问题,通常默认原点为极点,$x $轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若$M $在直角坐标系中坐标为$( x , y ) $,在极坐标中坐标为$( \rho , \theta ) $,若$M \ne O $自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x & = \rho \cos \theta , y & = \rho \sin \theta \\
\rho ^2 & = x ^2 + y ^2 , \theta & = \begin{cases}
\frac { \pi  } { 2  } & x = 0 \land y > 0 \\
\frac { 3 \pi  } { 2  } & x = 0 \land y < 0 \\
\arctan ( \frac { y  } { x  } ) & x \ne 0 
\end{cases} 
\end{aligned}</script><p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6><p>显然是$\rho ^2 = r ^2 $.</p>
<p>另外,如果中心在$C ( \rho _0 , \theta _0 ) $,半径为$r $的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
r ^2 & = ( \rho \cos \theta - \rho _0 \cos \theta _0 ) ^2 + ( \rho \sin \theta - \rho _0 \sin \theta _0 ) \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos \theta \cos \theta _0 - 2 \rho \rho _0 \sin \theta \sin \theta _0 \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos ( \theta - \theta _0 ) 
\end{aligned}</script><p>另外由于$\cos \theta = \cos ( - \theta ) $,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6><p>过定点$( \rho _1 , \theta _1 ) $,且倾斜角为$\alpha $:$\rho \sin ( \alpha - \theta ) = \rho _1 \sin ( \alpha - \theta _1 ) $.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点$( x _1 , y _1 ) $,倾斜角为$\alpha $,我们自然有$( x - x _1 ) \sin \alpha = ( y - y _1 ) \cos \alpha $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) \sin \alpha & = ( y - y _1 ) \cos \alpha \\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) \sin \alpha & = ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) & = \rho _1 \sin ( \alpha - \theta _1 ) 
\end{aligned}</script><p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点$( \rho _1 , \theta _1 ) $和$( \rho _2 , \theta _2 ) $的直线方程.</p>
<p>同理的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) ( y _2 - y _1 ) & = ( y - y _1 ) ( x _2 - x _1 ) \\
\\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) ( \rho _2 \sin \theta _2 - \rho _1 \sin \theta _1 ) \\
& = ( \rho _2 \cos \theta _2 - \rho _1 \cos \theta _1 ) ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \\
\\
\rho \rho _2 ( \cos \theta \sin \theta _2 - \cos \theta _2 \sin \theta ) \\
+ \rho \rho _1 ( - \cos \theta \sin \theta _1 + \sin \theta \cos \theta _1 ) \\
+ \rho _1 \rho _2 ( - \cos \theta _1 \sin \theta _2 + \cos \theta _2 \sin \theta _1 ) \\
& = 0 \\
\\
\rho \rho _2 \sin ( \theta _2 - \theta ) + \rho \rho _1 \sin ( \theta - \theta _1 ) + \rho _1 \rho _2 \sin ( \theta _1 - \theta _2 ) & = 0 
\end{aligned}</script><p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6><p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离$d $和到定点距离$r $之比为常数的曲线.令$e = \frac { r  } { d  } $.</p>
<p>假定定点为原点,极轴垂直于准线,$h $为定点到准线的距离,又设曲线上一点为$M ( \rho , \theta ) $,自然有:$r = \rho , d = h + \rho \cos \theta $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
e & = \frac { \rho  } { h + \rho \cos \theta  } \\
he + e \rho \cos \theta & = \rho \\
\rho & = \frac { he  } { 1 - e \cos \theta  } 
\end{aligned}</script><p>值得一提的是这玩意不能将圆理解为$e = 0 $的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5><p>在平面直角坐标系中,曲线上任意一点的坐标$x , y $都是某个变量$t $的函数$\begin{cases}x = f ( t ) \ y = g ( t ) \end{cases} $.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6><p>$M ( r \cos \theta , r \sin \theta ) $,其中$\theta $是$\angle OMx $.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6><p>$M ( x _0 + t \cos \theta , y _0 + t \sin \theta ) $,其中$\theta $是倾斜角,$t $是参数,$M _0 ( x _0 , y _0 ) $.</p>
<p>注意到$| M _0 M | = | t | $.事实上,设$\vec { e  } = ( \cos \theta , \sin \theta ) $,也就是直线的单位方向向量,则$\overrightarrow { M _0 M  } = t \vec { e  } $.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6><p>$M ( a \cos \theta , b \sin \theta ) $,其中$\theta $称为$M $的离心角.</p>
<p>值得注意的是,这里的$\theta $并非$\angle MOx $,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆$\frac { x ^2  } { 9  } + \frac { y ^2  } { 4  } = 1 $上求一点$M $,使$M $到直线$x + 2 y - 10 = 0 $的距离最小.</p>
<p>直接令$M = ( 3 \cos \theta , 2 \sin \theta ) $,则$d = \frac { | 3 \cos \theta + 4 \sin \theta - 10 |  } { \sqrt { 5  }  } = | \sqrt { 5  } \sin ( \theta + \varphi ) - 2 \sqrt { 5  } | $,其中$\varphi = \arcsin \frac { 3  } { 5  } $.</p>
<p>于是$d _{ \min  } = \sqrt { 5  } $,此时$\sin ( \theta + \varphi ) = 1 = \sin { \frac { \pi  } { 2  }  } $,那么就有$\theta = \frac { \pi  } { 2  } - \varphi $,$\sin \theta = \cos \varphi = \frac { 4  } { 5  } , \cos \theta = \sin \varphi = \frac { 3  } { 5  } $.</p>
<p>则$M = ( \frac { 9  } { 5  } , \frac { 8  } { 5  } ) $.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 100  } + \frac { y ^2  } { 64  } = 1 $,有一内接矩阵$ABCD $($AB / / x , BC / / y $),求矩阵最大面积.</p>
<p>直接令$A = ( 10 \cos \theta , 8 \sin \theta ) $,则$S = 20 \cos \theta \times 16 \sin \theta = 160 \sin ( 2 \theta ) $,$S _{ \max  } = 160 $.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6><p>$M ( \frac { a  } { \cos \theta  } , b \tan \theta ) = M ( a \sec \theta , b \tan \theta ) $,其中$\theta $称为$M $的离心角,通常规定$\theta \in [ 0 , 2 \pi ] \land \theta \ne \frac { \pi  } { 2  } \land \theta \ne \frac { 3 \pi  } { 2  } $.</p>
<p>其实本质也就是三角恒等式$\sec ^2 \theta = 1 + \tan ^2 \theta $.</p>
<p><strong>Example1</strong></p>
<p>圆$O : x ^2 + ( y - 2 ) ^2 = 1 $上有一点$P $,双曲线$x ^2 - y ^2 = 1 $上有一点$Q $,求$| PQ | _{ \min  } $.</p>
<p>设$Q ( \sec \theta , \tan \theta ) $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
| OQ | ^2 & = \sec ^2 \theta + ( \tan \theta - 2 ) ^2 \\
& = \tan ^2 \theta + 1 ( \tan \theta - 2 ) ^2 \\
& = 2 ( \tan \theta - 1 ) ^2 + 3 
\end{aligned}</script><p>$| OQ | _{ \min  } = \sqrt { 3  } , | PQ | _{ \min  } = \sqrt { 3  } - 1 $.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设$P ( a \sec \theta , a \tan \theta ) , Q ( - a \sec \theta , a \tan \theta ) $,则$k _P = \frac { a \tan \theta  } { a \sec \theta - a  } , k _Q = \frac { a \tan \theta  } { - a \sec \theta - a  } $.注意到$k _P \cdot k _Q = - 1 $.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,$A , B $是双曲线同支上相异两点,线段$AB $的垂直平分线与$x $轴相交于点$P ( x _0 , 0 ) $,求证:$| x _0 | &gt; \frac { c ^2  } { a  } = \frac { a ^2 + b ^2  } { a  } $.</p>
<p>设$A ( a \sec \alpha , b \tan \alpha ) , B ( a \sec \beta , b \tan \beta ) $,则中点$M ( \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) , \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) $.</p>
<p>于是中垂线方程为$y - \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) = - \frac { a ( \sec \alpha - \sec \beta )  } { b ( \tan \alpha - \tan \beta )  } [ x - \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) ] $.</p>
<p>代入$P ( x _0 , 0 ) $,求得$x _0 = \frac { c ^2  } { 2 a  } ( \sec \alpha + \sec \beta ) $.</p>
<p>也就是要比较$| \sec \alpha + \sec \beta | $和$2 $的大小关系,注意到$A , B $同支,所以$| \sec \alpha + \sec \beta | &gt; 2 $.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6><p>$M ( \frac { 2 p  } { \tan ^2 \theta  } , \frac { 2 p  } { \tan \theta  } ) $,其中$\theta $称为$M $的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:$M ( 2 pk ^2 , 2 pk ) $,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
<p>若抛物线$\begin{cases}x = 2 pt ^2 \ y = 2 pt \end{cases} $上有不同两点$M _1 , M _2 $,所对应的参数分别是$t _1 , t _2 $,求直线$M _1 M _2 $所在直线的斜率.</p>
<p>$k _{ M _1 M _2  } = \frac { 2 pt _1 - 2 pt _2  } { 2 pt _1 ^2 - 2 pt _2 ^2  } = \frac { 1  } { t _1 + t _2  } $.</p>
<p><strong>Example2</strong></p>
<p>$A , B $是抛物线$y ^2 = 2 px $上异于顶点的两动点,且$OA \bot OB $,$AB $上有一点$M $满足$OM \bot AB $,求$M $的轨迹方程.</p>
<p>设$M ( x , y ) , A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { OM  } & = ( x , y ) \\
\overrightarrow { OA  } & = ( 2 pt _1 ^2 , 2 pt _1 ) \\
\overrightarrow { OB  } & = ( 2 pt _2 ^2 , 2 pt _2 ) \\
\overrightarrow { AB  } & = ( 2 p ( t _2 ^2 - t _1 ^2 ) , 2 p ( t _2 - t _1 ) ) 
\end{aligned}</script><p>因为$\overrightarrow { OA  } \bot \overrightarrow { OB  } $,所以$( 2 pt _1 t _2 ) ^2 + ( 2 p ) ^2 t _1 t _2 = 0 $,$t _1 t _2 = - 1 $.</p>
<p>因为$\overrightarrow { AB  } \bot \overrightarrow { OM  } $,又有$k _{ AB  } = \frac { 1  } { t _1 + t _2  } $,所以$k _{ OM  } = - ( t _1 + t _2 ) $,$\frac { y  } { x  } = - ( t _1 + t _2 ) $.</p>
<p>接下来咋做捏?注意到我们好像忘记了$ABM $三点共线的性质,拿向量做这个东西.</p>
<p>$\overrightarrow { AM  } = ( x - 2 pt _1 ^2 , y - 2 pt _1 ) , \overrightarrow { MB  } = ( 2 pt _2 ^2 - x , 2 pt _2 - y ) $.</p>
<p>那么有$( x - 2 pt _1 ^2 ) ( 2 pt _2 - y ) = ( 2 pt _2 ^2 - x ) ( y - 2 pt _1 ) $.</p>
<p>化简得到$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点$A , B $,自然要设出它们的参数方程.然后呢?然后我们发现最后$M $一定和$t _1 , t _2 $有关.但是我们要求的是$M $的方程,其中不能带有$t _1 , t _2 $,因此考虑把$M $的坐标设出来,再用这个坐标表示$t _1 , t _2 $,表示不出来表示$t _1 t _2 , t _1 + t _2 $也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到$M $一定在以$| OA | $为直径的圆上,$B $同理,这两个圆的方程分别为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^2 + y ^2 - 2 pt _1 ^2 x - 2 pt _1 y & = 0 \\
x ^2 + y ^2 - 2 pt _2 ^2 x - 2 pt _2 y & = 0 
\end{aligned}</script><p>也就是说,$t _1 , t _2 $是同一个方程的两个根,根据韦达定理自然有$t _1 t _2 = \frac { - ( x ^2 + y ^2 )  } { 2 px  } = - 1 $,于是直接有$x ^2 + y ^2 - 2 px = 0 $.</p>
<p>还没完,注意到$O $一定是一个根,要去掉,所以答案就是$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p><strong>Example3</strong></p>
<p>已知$A , B , C $是抛物线$y ^2 = 2 px ( p &gt; 0 ) $上的三个点,且$BC $与$x $轴垂直,直线$AB $和$AC $分别与抛物线的轴交于$D , E $两点,求证:抛物线的顶点平分$DE $.</p>
<p>设$A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) , C ( 2 pt _2 ^2 , - 2 pt _2 ) $,注意到$AB : y - 2 pt _1 = \frac { 1  } { t _1 + t _2  } ( x - 2 pt _1 ^2 ) $,$AC : t - 2 pt _1 = \frac { 1  } { t _1 - t _2  } ( x - 2 pt _1 ^2 ) $.</p>
<p>可求得$D ( - 2 pt _1 t _2 , 0 ) , E ( 2 pt _1 t _2 , 0 ) $,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/591258689">https://zhuanlan.zhihu.com/p/591258689</a></p>
<h6><span id="定义">定义</span></h6><p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6><p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 + b ^2 $.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 - b ^2 $.</p>
<p>证明:其实注意到椭圆的证明中设$b $是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线$y ^2 = 2 px $,其蒙日圆方程为$x = - \frac { p  } { 2  } $.</p>
<p>有一说一,直线是半径无穷大的圆.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3><p>三个柱子,$n $个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T _n $表示答案,显然$T _0 = 0 , T _1 = 1 $.</p>
<p>而我们一定可以找到一种方案,使得前$n - 1 $个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把$n - 1 $个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:$T _n \leq 2 T _{ n - 1  } + 1 $.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:$2 T _{ n - 1  } + 1 \leq T _n $.于是有$T _n = 2 T _{ n - 1  } + 1 $.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4><p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4><p>考虑设$T _n $为n个圆盘时的最小操作次数.假设已知$T _{ n - 1  } $,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T _{ n  } = 3 T _{ n - 1  } + 2 , T _0 = 0 $.</p>
<p>考虑如何求该式子的封闭形式,令$W _n = T _n + 1 $,显然有$W _n = 3 W _{ n - 1  } , W _0 = 1 $,显然$W _n = 3 ^n $,有$T _n = 3 ^n - 1 $.</p>
<p>注意到$T _n $刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4><p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2 ^n - 1 $.</p>
<h4><span id="solution-2">Solution 2</span></h4><p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4><p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4><p>令$Q _n $为将n个圆盘从A移动到B的最小操作次数,令$R _n $为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q _0 = 0 , R _0 = 0 $.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q _n $的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,$R _n $的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q _n = 2 R _{ n - 1  } + 1 , 1 \leq n $.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R _n = R _{ n - 1  } + 1 + Q _{ n - 1  } + 1 + R _{ n - 1  } = Q _n + Q _{ n - 1  } + 1 , 1 \leq n $.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4><p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4><p>a.仍然令$T _n $为n对圆盘的最小操作次数,显然$T _n = 2 T _{ n - 1  } + 2 , T _0 = 0 $,可解得$T _n = 2 ^{ n + 1  } - 2 $.</p>
<p>b.令$Q _n $为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现$Q _n = T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } = 4 T _{ n - 1  } + 3 = 2 ^{ n + 2  } - 5 $.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q _n $就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4><p>类似Problem11,但第$i $大的圆盘有$k _i $个.</p>
<h4><span id="solution-5">Solution 5</span></h4><p>无区别,只是$T _n = 2 T _{ n - 1  } + k _n , T _0 = 0 $.</p>
<p>如果求封闭形式的话,显然有$T _n = \sum _{ i = 1  } ^n 2 ^{ n - i  } k _i $.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3><p>在上述问题中，我们已经有了以下式子：</p>
<p>$T _n = 2 T _{ n - 1  } + 1 , n &gt; 0 , T _0 = 0 $.</p>
<p>如果$n $很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出$T _n $的方法.</p>
<p>换句话说，我们想要把$T _n $表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4><h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5><p>解递归式:$Q _n = \begin{cases}\alpha &amp; n = 0 \ \beta &amp; n = 1 \ \frac { ( 1 + Q _{ n - 1  } )  } { Q _{ n - 2  }  } &amp; n &gt; 1 \end{cases} $,保证$\forall n , Q _n &gt; 0 $.</p>
<h5><span id="solution">Solution</span></h5><p>注意到$Q _2 = \frac { \beta + 1  } { \alpha  } , Q _3 = \frac { \beta + \alpha + 1  } { \beta \alpha  } , Q _4 = \frac { 1 + \alpha  } { \beta  } , Q _5 = \alpha , Q _6 = \beta $.</p>
<p>显然该递归式存在长度为$5 $的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4><p>观察T序列的前几项，可以发现似乎有$T _n = 2 ^n - 1 $.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n = 0 $成立，显然可验证.</p>
<p>2.若该公式对$n = k $时成立，那该公式必然对$n = k + 1 $成立.</p>
<p>因为有$T _{ k + 1  } = 2 T _k + 1 = 2 \times 2 ^k + 2 - 1 = 2 ^{ k + 1  } - 1 $.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5><p>求证:$\prod _{ i = 1  } ^n x _i \leq ( \frac { \sum _{ i = 1  } ^n x _i  } { n  } ) ^n , \forall i \in N _+ , 1 \leq i \leq n , 0 \leq x _i $.</p>
<h5><span id="solution">Solution</span></h5><p>使用反向归纳法.</p>
<p>1.$n = 2 $时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n = k $时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A _1 = \sqrt [k ] { \prod _{ i = 1  } ^k x _i  } , B _1 = \sqrt [k ] { \prod _{ i = k + 1  } ^{ 2 k  } x _i  } , A _2 = ( \frac { \sum _{ i = 1  } ^k x _i  } { k  } ) , B _2 = ( \frac { \sum _{ i = k + 1  } ^{ 2 k  } x _i  } { k  } ) $,显然有$A _1 \leq A _2 , B _1 \leq B _2 $.</p>
<p>同时有$( \frac { A _2 + B _2  } { 2  } ) \geq \sqrt { A _2 B _2  } \geq \sqrt { A _1 B _1  } $.</p>
<p>3.若该式子对$n = k $时成立,则该式子对$n = k - 1 $的时候也成立.</p>
<p>令$x _k = \frac { \sum _{ i = 1  } ^{ k - 1  } x _i  } { k - 1  } $,有$x _k \prod _{ i = 1  } ^{ k - 1  } x _i \leq ( x _k ) ^k $.</p>
<p>则显然$n = k - 1 $时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4><p>考虑令$U _n = T _n + 1 $,显然有:$T _n + 1 = 2 T _{ n - 1  } + 2 $.即$U _n = 2 U _{ n - 1  } $,显然$U _n = 2 ^n $,则$T _n = 2 ^n - 1 $.</p>
<p>这个做法可以做掉所有形如$a _{ n + 1  } = pa _n + q $的递归式.我们有:</p>
<script type="math/tex; mode=display">
a _{ n + 1  } + \frac { q  } { p - 1  } = p ( a _n + \frac { q  } { p - 1  } )</script><p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4><p>考虑递归式$a _n T _n = b _n T _{ n - 1  } + c _n $.如果我们能找到一个不为0的求和因子$s _n $并满足$s _n b _n = s _{ n - 1  } a _{ n - 1  } $.那么我们两面同时乘以$s _n $,显然有：$s _n a _n T _n = s _{ n - 1  } a _{ n - 1  } T _{ n - 1  } + c _n s _n $.</p>
<p>令$S _n = s _n a _n T _n $.显然有$S _n = s _0 a _0 T _0 + \sum _{ i = 1  } ^n s _i c _i $,则$T _n = \frac { S _n  } { s _n a _n  } $.</p>
<p>而我们也会发现$s _n = \frac { \prod _{ i = 1  } ^{ n - 1  } a _i  } { \prod _{ i = 1  } ^n b _i  } $.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5><p>结论:排序$n $个数时,其期望复杂度满足:</p>
<script type="math/tex; mode=display">
C _n = \begin{cases}
0 & n = 0 , 1 \\
n + 1 + \frac { 2  } { n  } \sum _{ i = 0  } ^{ n - 1  } C _k & n > 1 
\end{cases}</script><p>不妨考虑两边同时乘以$n $,有 $nC _n = n ^2 + n + 2 \sum _{ i = 0  } ^{ n - 1  } C _i , n &gt; 1 $ .</p>
<p>显然也有$( n - 1 ) C _{ n - 1  } = ( n - 1 ) ^2 + n - 1 + 2 \sum _{ i = 0  } ^{ n - 2  } C _i , n &gt; 2 $.</p>
<p>二式相消,有$nC _n - ( n - 1 ) C _{ n - 1  } = 2 n + 2 C _{ n - 1  } , n &gt; 2 $.</p>
<p>而同时有$C _2 = 3 $.即:$nC _n = ( n + 1 ) C _{ n - 1  } + 2 n , n &gt; 2 $,可以使用转化和式的方法,两边乘以$\frac { 1  } { n ( n + 1 )  } $解决.</p>
<h5><span id="example2">Example2</span></h5><p>已知$a _1 = 1 $,$a _n = \sqrt { S _n  } + \sqrt { S _{ n - 1  }  } $,求$a _n $.</p>
<p>注意到$a _n = S _n - S _{ n - 1  } $,则有$\sqrt { S _n  } - \sqrt { S _{ n - 1  }  } = 1 $,于是$\sqrt { S _n  } = n $,$S _n = n ^2 $,$a _n = 2 n - 1 $.</p>
<h4><span id="成套方法">成套方法</span></h4><p>如果我们有</p>
<p>\alpha &amp; n=1\\</p>
<p>2f(\frac n 2)+\beta &amp; n=2k,k\in \mathbb{N_+}\\</p>
<p>2f(\frac {n-1}2)+\gamma &amp;n=2k+1,k\in \mathbb{N_+}</p>
<p>\end{cases}</p>
<p>其中$n = 2 ^m + l $且$2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>该如何求出$f ( n ) $的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有$f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n ) \gamma $,而有$A 、 B 、 C $互不影响且$\alpha \beta \gamma $与$ABC $无关.</p>
<p>那无论$\beta $和$\gamma $的取值如何,$A ( n ) $都不会受到影响,我们考虑$\beta = \gamma = 0 $的特殊情况,此时显然有$A ( n ) = 2 ^m $.</p>
<p>接下来,我们考虑取$\alpha \beta \gamma $的特殊值,去得到ABC之间的关系.</p>
<p>例如，当$f ( n ) = 1 $时，由递推式可知$\alpha = 1 , \beta = \gamma = - 1 $,那么有$A ( n ) - B ( n ) - C ( n ) = f ( n ) = 1 $.</p>
<p>同理，$f ( n ) = n $时，可知$\alpha = 1 , \beta = 0 , \gamma = 1 $,此时有$A ( n ) + C ( n ) = f ( n ) = n $.</p>
<p>显然可以通过解方程求得$B ( n ) $和$C ( n ) $.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC $互不影响且$\alpha \beta \gamma $与$ABC $无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>直接在复数域上定义$f _k ( x ) = \{ n ^k x ^n \} _{ n = 0  } ^\infty $,此时我们规定$0 ^0 = 1 $.特别地,当$x = 0 $的时候,定义$f _k ( x ) $的第$k $项是$1 $,其余项是$0 $.在此基础上定义线性映射$T : ( a _n ) _{ n = 0  } ^\infty \mapsto ( a _{ n + 1  } ) _{ n = 0  } ^\infty $,立刻见到:$( T - x ) ^{ k + 1  } f _k ( x ) = 0 , ( T - x ) ^k f _k ( x ) \ne 0 $.原因只需简单数学归纳.而此还可以引出$f _0 ( x ) , f _1 ( x ) , \cdots $线性无关.</p>
<p>在此基础上观察线性递推$a _{ n + d  } = c _{ d - 1  } a _{ n + d - 1  } + \cdots + c _0 a _n $,不妨取$G ( x ) = x ^d - c _{ d - 1  } x ^{ d - 1  } - \cdots - c _0 $,立刻应当见到如果$a $是$G $的根并且重数为$e ( a ) $,那么$f _{ 0  } ( x ) , \cdots , f _{ e ( a ) - 1  } ( a ) $都在$\ker f ( T ) $中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如$\sum _j w _i f _i ( y ) = \sum _j w _j f _j ( x ) $的情况,此时对右边直接操作若干次$( T - x ) $就可以把右边全部消成$0 $,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于$n $的多项式右边的$( T - x ) $是不会改变左边这边的每一个位置多项式的$\deg $,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3><p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是$2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 , 9 $.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有$J ( 2 n ) = 2 J ( n ) - 1 $;当人数是奇数时,我们杀掉一号,然后有$J ( 2 n + 1 ) = 2 J ( n ) + 1 $.</p>
<p>整理得到:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 1 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>仍然可以使用数学归纳，如果令$n = 2 ^m + l 且 2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>有$J ( n ) = 2 l + 1 $.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从$0 $开始编号:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
0 & n = 1 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>这下相信$J ( n ) $是多少就很显然了,将$n $写成二进制的形式,这个就相当于把首位$1 $抹去然后在末尾加个$0 $.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4><p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4><p>显然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
2 & n = 2 \\
1 & n = 3 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>从$0 $开始编号,自然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 2 \\
0 & n = 3 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>显然$J ( n ) $也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2><h3><span id="和式的基本运算">和式的基本运算</span></h3><p>分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i</script><p>一般分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j )</script><p>结合律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i</script><p>交换律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  }</script><p>交换求和顺序:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] & = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] \\
\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } & = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } 
\end{aligned}</script><h3><span id="和式的封闭形式">和式的封闭形式</span></h3><h4><span id="交换顺序法">交换顺序法</span></h4><h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i < j \leq n  } ( a _j - a _i ) ( b _j - b _i ) 
\end{aligned}</script><p>显然有以下式子:</p>
<p>(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\geq n\sum_{i=1}^na_ib_i，\forall i&lt;j，a_i\leq a_j且b_i\geq b_j\\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5><p>证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 & = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \\

\end{aligned}</script><p>有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 \\
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k + a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5><p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n i ^2 & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推,我们设$W _n = \sum _{ i = 0  } i ^3 $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5><p>令$H _n = \sum _{ k = 1  } ^n \frac { 1  } { k  } $,求$\sum _{ i = 0  } ^n H _i $.</p>
<h5><span id="solution3">Solution3</span></h5><p>不妨考虑$\sum _{ i = 0  } ^n iH _{ i  } $的值.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^n iH _{ i  } & = \sum _{ i = 1  } ^n [ ( i - 1 + 1 ) H _{ i - 1  } + 1 ] \\
& = n + \sum _{ i = 0  } ^{ n - 1  } H _i + \sum _{ i = 0  } ^{ n  } iH _i - nH _n \\
\sum _{ i = 0  } ^{ n - 1  } H _i & = n ( H _n - 1 ) \\
\sum _{ i = 0  } ^n H _i & = ( n + 1 ) ( H _{ n + 1  } - 1 ) \\

\end{aligned}</script><h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5><p>求$S _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } , T _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i , U _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i ^2 $.</p>
<h5><span id="solution-4">Solution 4</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 1  } ^{ n  } ( - 1 ) ^{ n - i  } + ( - 1 ) ^n \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - 1 - i  } \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + S _{ n - 1  } \\
S _{ n - 1  } & = \frac { 1 - ( - 1 ) ^n  } { 2  } \\
S _n & = \frac { 1 + ( - 1 ) ^n  } { 2  } 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
T _{ n  } & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i \\
- T _{ n - 1  } + n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- T _{ n - 1  } + n & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } - ( - 1 ) ^n \\
- T _{ n - 1  } + n & = T _{ n - 1  } + S _n - ( - 1 ) ^n \\
n - \frac { 1 - ( - 1 ) ^n  } { 2  } & = 2 T _{ n - 1  } \\
T _n & = \frac { 1  } { 2  } ( n + 1 + \frac { - 1 - ( - 1 ) ^n  } { 2  } ) & = \frac { 1  } { 2  } ( n + \frac { 1 - ( - 1 ) ^n  } { 2  } ) 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
U _n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 + 1 ) ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) ^2 + 2 \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i ^2 + 2 \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } \\
- U _{ n - 1  } + n ^2 & = U _{ n - 1  } + 2 T _{ n - 1  } + S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - 2 T _{ n - 1  } - S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - ( n - \frac { 1 - ( - 1 ) ^n  } { 2  } ) - \frac { 1 - ( - 1 ) ^n  } { 2  } \\
2 U _{ n - 1  } & = n ^2 - n \\
U _n & = \frac { n ( n + 1 )  } { 2  } 
\end{aligned}</script><h4><span id="转化为递归式">转化为递归式</span></h4><p>考虑和式$S _n = \sum _{ i = 0  } ^n f ( i ) = S _{ n - 1  } + f ( n ) \ $，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5><p>求$\sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 \ $.</p>
<h5><span id="solution1">Solution1</span></h5><p>令$S ( n ) = \sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 = S ( n - 1 ) + ( - 1 ) ^n n ^2 $,考虑使用成套方法.</p>
<p>不妨令$S ( n ) = S ( n - 1 ) + ( - 1 ) ^n ( \alpha + \beta n + \gamma n ^2 ) = \alpha A ( n ) + \beta B ( n ) + \gamma C ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n , 可 以 解 得 \alpha = - 1 , \beta = 2 , \gamma = 0 $,有$( - 1 ) ^n n = - A ( n ) + 2 B ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n ^2 , 可 以 解 得 \alpha = 1 , \beta = - 2 , \gamma = 2 $,有$( - 1 ) ^n n ^2 = A ( n ) - 2 B ( n ) + 2 C ( n ) $.</p>
<p>显然可解得$2 C ( n ) = ( - 1 ) ^n n ^2 + ( - 1 ) ^n n , C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<p>而原式中,$S ( n ) = C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5><p>有$2 T _n = nT _{ n - 1  } + 3 n ! , T _0 = 5 $,求$T _n $.</p>
<h5><span id="solution-2">Solution 2</span></h5><p>令$s _n = \frac { 2 ^{ n - 1  }  } { n !  } $,两边同时乘以$s _n $,有$\frac { 2 ^n  } { n !  } T _n = \frac { 2 ^{ n - 1  }  } { ( n - 1 ) !  } T _{ n - 1  } + 3 \times 2 ^{ n - 1  } \ $.</p>
<p>令$S _n = \frac { 2 ^n  } { n !  } T _n $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = S _{ n - 1  } + 3 \times 2 ^{ n - 1  } \\
& = 5 + 3 \sum _{ i = 0  } ^{ n - 1  } 2 ^i \\
& = 5 + 3 \times 2 ^{ n + 1  } - 3 \\
& = 3 \times 2 ^{ n  } + 2 \\
T _n & = 3 n ! + \frac { n !  } { 2 ^{ n - 1  }  } 
\end{aligned}</script><h4><span id="转化为积分形式">转化为积分形式</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数$f ( x ) = x ^2 $,显然$\int _0 ^n x ^2 dx = \frac { n ^3  } { 3  } \sim S _n \ $.</p>
<p>接下来,我们考虑求得二者之间的误差,设$E _n = S _n - \frac { n ^3  } { 3  } \ $,对其使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \frac { n ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 + 1 ) ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 ) ^3  } { 3  } - ( n - 1 ) ^2 - ( n - 1 ) - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n ^2 - n ^2 + 2 n - 1 - n + 1 - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n - \frac { 1  } { 3  } 
\end{aligned}</script><p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \int _0 ^n x ^2 dx \\
& = \sum _{ k = 1  } ^n ( k ^2 - \int _{ k - 1  } ^k x ^2 dx ) \\
& = \sum _{ k = 1  } ^n ( k ^2 - \frac { k ^3 - ( k - 1 ) ^3  } { 3  } ) \\
& = \sum _{ k = 1  } ^n ( k - \frac { 1  } { 3  } ) 
\end{aligned}</script><p>这是一个简单的和式.而$S _n = E _n + \frac { n ^3  } { 3  } \ $,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5><p>已知$a _1 = 1 , a _{ n + 1  } - a _n = - \frac { 1  } { 3  } a _n ^2 $,估计$a _n $的值.</p>
<p>考虑构造一个函数$f ( n ) $使得$f ( n ) \approx a _n $,那我们就可以将$a _{ n + 1  } - a _n \approx f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$\exists x _0 \in [ n , n + 1 ] , f ‘ ( x _0 ) = f ( n + 1 ) - f ( n ) $,而对于增长率变化不大的函数,直接认为$f ‘ ( x _0 ) = f ‘ ( n ) $是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 $解得$f ( n ) = \frac { 3  } { n + 2  } $.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令$a _n = \frac { 3  } { n + 2  } - b _n $,带入化简,得到$\{ b _n \} $的递推式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } & = ( \frac { 3  } { n + 2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _{ n + 1  } - \frac { 3  } { n + 3  } & = ( b _n - \frac { 3  } { n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 & = 0 , b _{ n + 1  } & = \frac { b _n ^2  } { 3  } + \frac { n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  } 
\end{aligned}</script><p>算到这里,我们可以很轻易使用数学归纳法算出$b _n \leq \frac { 1  } { 4 n  } $,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n $的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设$b _n ^2 &lt; &lt; b _n $:</p>
<p>那么这个$b _n $是$O ( \frac { \ln n  } { n ^2  } ) $级别的.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b _{ n + 1  } & = \frac { n  } { n + 2  } b _n + \frac { 1  } { n ( n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } & = n ( n + 1 ) b _n + \frac { 1  } { n  } \\
g ( n ) & = n ( n + 1 ) b _n , g ' ( n ) & = \frac { 1  } { n  } , g ( n ) & = \ln n \\
b _n & = \frac { \ln n  } { n ^2  } 
\end{aligned}</script><p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ \epsilon  } ) $和$O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n \leq \frac { 3 \ln n  } { n ( n + 1 )  } $.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5><p>求$\sum _{ i = 1  } ^n i 2 ^i \ $.</p>
<h5><span id="solution-2">Solution 2</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n i 2 ^i & = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i 2 ^i \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n 2 ^i \\
& = \sum _{ j = 1  } ^n ( 2 ^{ n + 1  } - 2 ^j ) \\
& = n 2 ^{ n + 1  } - ( 2 ^{ n + 1  } - 2 ) \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 
\end{aligned}</script><h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<h5><span id="solution-3">Solution 3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="exampleex">ExampleEX</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solutionex">SolutionEX</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="exampleex2">ExampleEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( x ) & = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x & = f ( x ) + C \\

\end{aligned}</script><p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( x ^{ \underline { m  }  } ) & = mx ^{ \underline { m - 1  }  } \\
\sum mx ^{ \underline { m - 1  }  } \delta x & = x ^{ \underline { m  }  } + C , m \ne 0 \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( H ( x ) ) & = x ^{ \underline { - 1  }  } & = \frac { 1  } { x + 1  } \\
\sum x ^{ \underline { - 1  }  } \delta x & = H ( x ) + C \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( 2 ^x ) & = 2 ^x , \sum 2 ^x \delta x & = 2 ^x + C \\
\Delta ( c ^x ) & = ( c - 1 ) c ^x , \sum c ^x \delta x & = \frac { c ^x  } { c - 1  } + C , c \ne 1 \\
\Delta ( c ^{ \underline { x  }  } ) & = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x & = c ^{ \underline { x  }  } + C , c - x \ne 0 \\

\end{aligned}</script><p>根据组合数公式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( \binom { x  } { k  } ) & = \binom { x  } { k - 1  } \\
\sum \binom { x  } { k - 1  } \delta x & = \binom { x  } { k  } + C 
\end{aligned}</script><h6><span id="example平方和公式">Example(平方和公式)</span></h6><p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5><p>考虑一阶差分是$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $,那么二阶差分就是$\Delta ^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f ( x ) $.</p>
<p>类似地,我们可以通过归纳法证明$\Delta ^n f ( x ) = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } f ( x + k ) \ $.</p>
<p>事实上有一种更简单的证明方法,由于$\Delta = E - 1 $,于是$\Delta ^n = ( E - 1 ) ^n = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } E ^k \ $,由于$E ^k f ( x ) = f ( x + k ) $,即可证明原式.</p>
<p>另外,不难发现如果$f ( x ) $是一个关于$x $的$d $次多项式,那么$\Delta f ( x ) $是一个$d - 1 $次多项式.同理,$\Delta ^d f ( x ) $会是一个常数而$\Delta ^{ d + 1  } f ( x ) $会是$0 $,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6><p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为$x _1 , x _2 $.</p>
<p>不难写出期望转移式子:$f _i = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 $,并且$f _{ x _1  } = f _{ x _2  } = 0 $.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _i & = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 \\
2 f _i & = f _{ i - 1  } + f _{ i + 1  } + 2 \\
f _i - f _{ i - 1  } & = f _{ i + 1  } - f _i + 2 \\
\Delta f _{ i - 1  } & = \Delta f _{ i  } + 2 \\
\Delta f _i - \Delta f _{ i - 1  } & = - 2 \\
\Delta ^2 f _{ i - 1  } & = - 2 
\end{aligned}</script><p>$f $的二阶差分是常数,也就是说$f $是二次多项式,不难求得其二次项系数为$- 1 $又知道两个零点,显然可以得到$f $的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5><p>令$f ( x ) = \sum _{ 0 \leq i \leq d  } a _i x ^i \ $.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为$f ( x ) = \sum _{ 0 \leq i \leq d  } b _i x ^{ \underline { i  }  } \ $.</p>
<p>我们设$c _i = i ! b _i $,于是有:$f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i  } \ $.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为$f ( x ) $的牛顿级数.</p>
<p>于是不难发现有:$\Delta ^n f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i - n  } \ $.如果我们令$x = 0 $,则有:$\Delta ^n f ( 0 ) = \begin{cases}c _n &amp; n \leq d \ 0 &amp; n &gt; d \end{cases} $.那么牛顿级数的另一种表示即:$f ( x ) = \sum _{ 0 \leq i \leq d  } \Delta ^i f ( 0 ) \binom { x  } { d  } \ $.</p>
<p>另外,如果我们展开一下$c _n = \Delta ^n f ( 0 ) $,我们可以得到公式:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } c _i \binom { k  } { i  } ) = ( - 1 ) ^n c _n , n \in \mathbb { N  } \ $.</p>
<p>如果我们将多项式还原,由于$a _n = b _n $,有:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } a _i k ^i ) = ( - 1 ) ^n n ! a _n , n \in \mathbb { N  } \ $.</p>
<p>另外,如果$x \in \mathbb { N  } $,那么我们有:$f ( x ) = \sum _{ 0 \leq k  } \Delta ^k f ( 0 ) \binom { x  } { 0  } $,根据多项式推理法,这个公式对$\forall x \in \mathbb { Z  } $都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<script type="math/tex; mode=display">
g ( a + x ) = \sum _{ 0 \leq k  } \cfrac { \Delta ^k g ( a )  } { k !  } x ^{ \underline { k  }  }</script><h6><span id="example">Example</span></h6><p>求$\sum _{ k  } \binom { n  } { k  } \binom { r - sk  } { n  } ( - 1 ) ^k , n \in \mathbb { N  } \ $.</p>
<p>如果我们令$f ( k ) = \binom { r - sk  } { n  } = \sum _{ 0 \leq i \leq n  } a _i k ^i \ $,不难发现$a _n = \cfrac { ( - 1 ) ^n s ^n  } { n !  } $,于是显然原式$= s ^n $.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \\
\sum _{ i = l  } ^{ r - 1  } ( \Delta a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( \Delta b _i ) 
\end{aligned}</script><p>对于$l = 0 , r = n , a _0 = b _0 = 0 $的特殊情况,应当有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } a _{ i + 1  } ( \Delta b _i ) \\
\sum _{ i = 1  } ^n a _i ( b _{ i + 1  } - b _i ) & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i 
\end{aligned}</script><p>取两组数列$\alpha , \beta $,并令$\sum _{ i = 1  } ^n \beta _i = B _i $,立刻有:</p>
<script type="math/tex; mode=display">
\sum _{ i = 1  } ^n \alpha _i \beta _i = \alpha _n B _n - \sum _{ i = 1  } ^{ n - 1  } ( \alpha _{ i + 1  } - \alpha _i ) B _i</script><h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<p>$\sum _{ k = 0  } ^n k 2 ^k = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 = ( n - 1 ) 2 ^{ n + 1  } + 2 \ $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<h6><span id="solution-3">Solution 3</span></h6><p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } & = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<h6><span id="solution-4">Solution 4</span></h6><p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">范畴论初步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2><h3><span id="映射">映射</span></h3><p>设$A , B $为两个集合,$\varphi $称为从$A $到$B $的一个<strong>映射</strong>,如果对于任意$a \in A $,$\exists b \in B , b = \varphi ( a ) $.此时$b $称为$a $在$\varphi $下的像,$a $称为$b $在$\varphi $下的原像或反像.一般地,这个定义可以拓展到$S \subseteq A $,$\varphi ( S ) = \{ \varphi ( a ) \mid a \in S \} $,定义$\varphi ^{ - 1  } ( T ) = \{ a | \varphi ( a ) \in T , a \in S \} $.</p>
<p>如果$\forall a _1 , a _2 \in A , a _1 \ne a _2 , \varphi ( a _1 ) \ne \varphi ( a _2 ) $,称$\varphi $是<strong>单射</strong>.</p>
<p>如果$\forall b \in B , \exists a \in A , \varphi ( a ) = b $.称$\varphi $为<strong>满射</strong>.</p>
<p>如果$\varphi $既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果$A = B $,我们又称$\varphi $为一个<strong>变换</strong>.</p>
<p>设$f : A \rightarrow B , g : B \rightarrow A $,那么:</p>
<ol>
<li><p>如果$g \circ f = id _A $,称$g $是$f $的一个<strong>左逆</strong>,不难发现$f $存在左逆当且仅当$f $是单射.</p>
</li>
<li><p>如果$f \circ g = id _B $,称$g $是$f $的一个<strong>右逆</strong>,不难发现$f $存在右逆当且仅当$f $是满射.</p>
</li>
<li><p>如果$g $既是$f $的左逆又是$f $的右逆,则称$g $为$f $的<strong>逆</strong>,不难发现$f $存在逆当且仅当$f $是双射,并且逆唯一.</p>
</li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3><p>集合$A , B $的<strong>笛卡尔积</strong>或<strong>直积</strong>是指$A $的元素与$B $的元素构成的有序对的集合,即$A \times B = \{ ( a , b ) \mid a \in A , b \in B \} $.可以推广到多元对.</p>
<p>集合$A $上的一个<strong>二元运算</strong>是由$A \times A $到$A $的一个映射.对于定义在$U $上的一个二元运算,不妨用$+ $来表示,集合$A , B \subseteq U $的<strong>闵可夫斯基和</strong>定义为$A + B = \{ a + b \mid a \in A , b \in B \} $.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合$A $上的一个<strong>二元关系</strong>$R $定义为$A \times A $的一个子集(可以理解为满足二元关系的解集),如果$( a _1 , a _2 ) \in R $,就称$a _1 , a _2 $有关系$R $,记作$a _1 Ra _2 $,注意这里有序.</p>
<p>如果$R $满足以下三个性质:</p>
<ol>
<li><p>反身性:$\forall a \in A , aRa $.</p>
</li>
<li><p>对称性:$a _1 Ra _2 \Leftrightarrow a _2 Ra _1 $.</p>
</li>
<li><p>传递性:$a _1 Ra _2 , a _2 Ra _3 \Leftrightarrow a _1 Ra _3 $.</p>
</li>
</ol>
<p>则称$R $是一个<strong>等价关系</strong>,不难发现满足等价关系的元素构成了若干个集合,称作<strong>等价类</strong>.等价关系通常记作$\sim $.</p>
<p>如果将等价关系的(2)改作:</p>
<ol>
<li>反对称性:$a _1 Ra _2 , a _2 Ra _1 \Leftrightarrow a _1 = a _2 $.</li>
</ol>
<p>则称$R $是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$\leq $.</p>
<h4><span id="保序映射">保序映射</span></h4><p>对于映射$f : A \rightarrow B $,如果$\forall a , a ‘ \in A , a \leq a ‘ \Rightarrow f ( a ) \leq f ( a ‘ ) $,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4><p>对于偏序集$( A , R ) $来说,定义:</p>
<ol>
<li><p>链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 1 $.</p>
</li>
<li><p>反链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 0 $.</p>
</li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p>
</li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,$| A | \leq 3 $显然成立.</p>
<p>当$| A | &gt; 3 $时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为$d $,下面证明其最小链覆盖也是$d $.</p>
<p>考虑取一条尽可能长的链$A ‘ $,设其中最大的为$M $,最小的为$m $(如果有多个就任取一个).</p>
<p>考虑$T = A \setminus A ‘ $,如果$T $中的最长反链数小于$d $,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链$S $,使得$S \cap A ‘ = \emptyset $.考虑设$A ^{ +  } = \{ x | x \in A \land \exists s \in S , sRx \} $,$A ^{ -  } = \{ x | x \in A \land \exists s \in S , xRs \} $.不难发现$m $一定不在$| A ^{ +  } | $中,不然取出的那条链$A ‘ $可以更长.同理$M $一定不在$| A ^{ -  } | $中,也即$| A ^+ | , | A ^- | &lt; | A | $.</p>
<p>我们又发现$A ^+ \cup A ^- = A $,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,$S \subseteq A ^{ +  } \cap A ^{ -  } $.</p>
<p>由数学归纳,$A ^+ $和$A ^- $中的最小链覆盖均为$d $,并且一个以$S $中元素开头,一个以$S $中元素结尾,我们把它俩拼起来就是一个大小为$d $的新的大小为$d $的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4><p>考虑定义一种等价关系$\sim $,我们可以在此基础上定义商集$A / \sim = \{ [ a ] | a \in A \} $,其中$[ a ] $是$a $所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过$\mathbb { N  } $来定义$\mathbb { Z  } $.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系$\sim $,$( n , m ) \sim ( n ‘ , m ‘ ) $当且仅当$n + m ‘ = m + n ‘ $.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将$\mathbb { N  } / \sim $定义为整数,更确切地,对于任意一组$( n , m ) $其代表的就是$n - m $这个整数.</p>
<p>容易定义加法:$( n , m ) + ( n ‘ , m ‘ ) = ( n + n ‘ , m + m ‘ ) $,乘法$( n , m ) \times ( n ‘ , m ‘ ) = ( mm ‘ + nn ‘ , mn ‘ + m ‘ n ) $.也可以定义大小关系$( n , m ) \leq ( n ‘ , m ‘ ) \Leftrightarrow n + m ‘ \leq m + n ‘ $.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义$- ( n , m ) = ( m , n ) $即可,容易验证二者之和处于$( 0 , 0 ) $这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用$\mathbb { Z  } $构造$\mathbb { Q  } $,构造二元组$\mathbb { Z  } \times \mathbb { N  } _+ $,定义$( r , s ) \sim ( r ‘ , s ‘ ) \Leftrightarrow rs ‘ = r ‘ s $,容易验证其满足等价关系的性质.实际上其对应的就是$\frac { r  } { s  } $这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3><h4><span id="外延公理">外延公理</span></h4><p>$A = B \Leftrightarrow ( A \subset B ) \land ( B \subset A ) $.</p>
<h4><span id="配对公理">配对公理</span></h4><p>对于任意元素$a , b $,存在集合$\{ a , b \} $.特别地,当$a = b $的时候存在集合$\{ a \} $.</p>
<p>值得一提的是可以将数对$( a , b ) $定义为$\{ \{ a \} , \{ a , b \} \} $,下面的幂集公理说明了数对属于$2 ^{ 2 ^{ A \cup B  }  } , a \in A , b \in B $.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4><p>对于一个集合$A $,和一个性质$P $,若$\alpha $满足性质$P $则称$P ( \alpha ) $.那么存在集合:</p>
<script type="math/tex; mode=display">
\{ x | x \in A \land P ( x ) \}</script><p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质$P $都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4><p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4><p>一个集合的所有子集构成一个新的集合(可以记作$2 ^A $).</p>
<h4><span id="无穷公理">无穷公理</span></h4><p>称满足以下性质的集合为归纳集:</p>
<ol>
<li><p>$\emptyset \in A $.</p>
</li>
<li><p>若$\alpha \in A $,则$\{ \alpha \} \cup \alpha \in A $.</p>
</li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4><p>对于集合$A $和一种定义在集合$A $上的映射$F $,存在集合$A ‘ $使得$x \in A ‘ \Leftrightarrow x = F ( a ) , a \in A $.</p>
<p>用替换公理可以证明映射也是一种集合,并且从$A \rightarrow B $的所有映射可以构成集合,可以记作$B ^A $.</p>
<h4><span id="正则公理">正则公理</span></h4><p>对任何非空集合$A $,存在$a \in A $使得$\forall a ‘ \in A $,$a ‘ \notin a $,也就是$a \cap A = \emptyset $.</p>
<h4><span id="选择公理">选择公理</span></h4><p>说对于任何一族非空集$A $,总能从其中的每个集合$a $选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5><p>如果$X $上的一个偏序关系$\leq $,满足其每条链$A $都存在上界($\exists x \in X , \forall a \in A , x \geq a $),那么$X $存在极大元$( \exists x \in X , \forall a \in X , a \geq x \Rightarrow a = x ) $.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系$( A ‘ ‘ , g ‘ ‘ ) \leq ( A ‘ , g ‘ ) $当且仅当$A ‘ ‘ \subseteq A ‘ $并且$\forall x \in A ‘ ‘ , g ‘ ‘ ( x ) = g ‘ ( x ) $.这样拿出来的极大元就是我们需要的$A \rightarrow g ( A ) $.</p>
<h5><span id="良序定理">良序定理</span></h5><p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对$( S , R ) $组成的集合,其中满足$S $对于偏序关系$R $来说是良序的,我们定义两个二元对$a , b $满足$a \leq b $当且仅当它们的$R $相等并且$S _a \subseteq S _b $.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)$( S , R ) $,注意到如果$S $是全集则证毕,如果不是,则取一个全集中不在$S $的元素$x $接到$S $的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3><p>如果存在单射$\varphi : A \rightarrow B $,则称$| A | \leq | B | $.如果存在双射,则称$| A | = | B | $.</p>
<p>如果使用选择公理的话,可以说明如果存在满射$\varphi : A \rightarrow B $,则称$| A | \geq | B | $.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有$A , B $两个集合,接下来我们证明一定存在一个从$A $到$B $的映射,且其要么为单射要么为满射.</p>
<p>我们记$X $为所有$A $的子集到$B $的单射组成的集合,并且我们定义这样一种偏序关系:若$f : A _f \rightarrow B , g : A _g \rightarrow B , A _f \subseteq A _g , \forall a \in A _f , f ( a ) = g ( a ) $.</p>
<p>这样的话,我们不妨取出$X $的一个全序的子集$I $,显然其存在上界.</p>
<p>根据Zorn引理,$X $存在极大元$g : A _g \rightarrow B $,此时我们开始讨论:</p>
<p>如果$A _g = A $,那么找到了一个单射$g : A \rightarrow B $.</p>
<p>反之,如果$A _g \subsetneq A $,考虑如果$g ( A _g ) = B $,也就是找到了一个满射;反之,考虑取$a ‘ \in A \setminus A _g , b ‘ \in B \setminus g ( A _g ) $,在$g $的基础上加上映射$a ‘ \mapsto b ‘ $,这是一个比$g $还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4><p>如果$| A | \leq | B | \land | B | \leq | A | $,则$| A | = | B | $.</p>
<p>不妨设$f : A \rightarrow B , g : B \rightarrow A $我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用$f , f ^{ - 1  } $来构造双射,只有一种除外:那就是以一个$B $中节点开始不断延伸的无限的,我们在这里使用$g , g ^{ - 1  } $来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取$C _0 = B \setminus f ( A ) $,$C _n = f ( g ( C _{ n - 1  } ) ) $,那么对于$C = \cup _{ n \geq 0  } C _n $,使用$g , g ^{ - 1  } $构造双射,剩下的使用$f , f ^{ - 1  } $构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4><p>我们称集合$A $是<strong>可数</strong>的,当且仅当$| A | = | \mathbb { N  } | $.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是$0 $)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为$1 $和$0 $显然都是代数数.</p>
<p>我们接下来看两个代数数$x , y $.考虑如何构造$x + y $作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
X & = \sum _{ k = 0  } ^n a _k x ^k & = 0 \\
Y & = \sum _{ k = 0  } ^m b _k y ^k & = 0 
\end{aligned}</script><p>对于加法,考虑:$( x + y ) ^0 , ( x + y ) ^1 , \cdots $,这些东西,先把它们对$X $取膜再对$Y $取膜,得到的一定是$nm $维的,只需要取$nm + 1 $个就会出现线性相关.乘法同理考虑$( xy ) ^0 , ( xy ) ^1 , \cdots $即可.</p>
<p>值得一提的是,$| \mathbb { R  } | = 2 ^{ | \mathbb { N  } |  } $.这个是怎么构造的呢?只需要证明$[ 0 , 1 ] $上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果$k $在取出的自然数子集中,那么小数点后第$k + 1 $位为$1 $否则为$0 $,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是$0 . 1 = 0 . 0111 \cdots $,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明$| \mathbb { R  } | \leq 2 ^{ | \mathbb { N  } |  } $并且$| \mathbb { R  } | \geq 2 ^{ | \mathbb { N  } |  } $,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2><h3><span id="范畴">范畴</span></h3><p>一个<strong>范畴</strong>$\mathcal { C  } $应当包含以下:</p>
<ol>
<li><p>一个类$\rm { Ob  } ( \mathcal { C  } ) $,其元素称作$\mathcal { C  } $的<strong>对象</strong>.</p>
</li>
<li><p>对于$X , Y \in \rm { Ob  } ( \mathcal { C  } ) $指定一个集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,称作$\mathcal { C  } $中从$X $到$Y $的<strong>态射</strong>.</p>
</li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol>
<li><p>对于$X \in \text { Ob  } ( \mathcal { C  } ) $存在其到自身的<strong>恒等态射</strong>$\text { id  } _X \in \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong>$\circ : \text { Hom  } _{ \mathcal { C  }  } ( Y , Z ) \times \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , ( g , f ) \mapsto g \circ f $.</p>
</li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol>
<li><p><strong>结合律</strong>:对于$\mathcal { C  } $中的态射$h , g , f $,如果合成有意义,那么$h ( gf ) = ( hg ) f $.</p>
</li>
<li><p><strong>单位元</strong>:对于$f \in \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,$f \circ \text { id  } _X = f = \text { id  } _Y \circ f $.</p>
</li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有$\text { id  } _X = \text { id  } _X \text { id ‘  } _X = \text { id ‘  } _X $.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<script type="math/tex; mode=display">
\xymatrix { R \ar [r ] ^u \ar [d ] _x & S \ar [d ] ^v \\
T \ar [r ] _y & U  }</script><p>这意味着$yx = vu $.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol>
<li><p>如果对于$f \in \text { Hom  } ( X , Y ) $,$\exists g \in \text { Hom  } ( Y , X ) $使得$gf = \text { id  } _X $,那么称$g $是$f $的一个<strong>左逆</strong>,称$f $是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p>
</li>
<li><p>如果$f $左右均可逆,易见左右逆相等,记作$f ^{ - 1  } $,易见$f ^{ - 1  } $可逆而且$( f ^{ - 1  } ) ^{ - 1  } = f $.此时称$f $是<strong>同构</strong>的.</p>
</li>
</ol>
<p>同构还有以下性质:</p>
<ol>
<li><p>$( \text { id  } _X ) ^{ - 1  } = \text { id  } _X $.</p>
</li>
<li><p>如果$f $和$g $均为同构并且合成有意义,那么$gf $是同构并且$( gf ) ^{ - 1  } = f ^{ - 1  } g ^{ - 1  } $.</p>
</li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol>
<li><p>自同态幺半群:$\text { End  } _{ \mathcal { C  }  } ( X ) = \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>自同构群:$\text { Aut  } _{ \mathcal { C  }  } ( X ) = ( \text { End  } _{ \mathcal { C  }  } ( X ) ) ^\times $.</p>
</li>
</ol>
<p>如此起名的原因是由抽象代数知识见到$\text { End  } $对二元运算$\circ $构成幺半群,$\text { Aut  } $则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称$\mathcal { C  } ‘ $是$\mathcal { C  } $的子范畴当且仅当:</p>
<ol>
<li><p>$\text { Ob  } ( \mathcal { C  } ‘ ) \subseteq \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $都有$\text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \subseteq \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$\text { id  } _X = \text { id  } _X ‘ $.</p>
</li>
<li><p>态射在$\mathcal { C  } ‘ $中的合成运算应从$\mathcal { C  } $中继承而来.</p>
</li>
</ol>
<p>特别地,如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) , \text { Hom  } ( X , Y ) _{ \mathcal { C  } ‘  } = \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,则称$\mathcal { C  } ‘ $是$\mathcal { C  } $的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3><p>如果$\mathcal { C  } $是一个范畴,其中有一个元素$X \in \mathrm { Ob  } ( \mathcal { C  } ) $,如果$\forall Y \in \mathrm { Ob  } ( { \mathcal { C  }  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称它是始(initial)的.类似地,如果对于$Y \in \mathrm { Ob  } ( \mathcal { C  } ) $,$\forall X \in \mathrm { Ob  } ( \mathcal { C  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称$Y $是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol>
<li><p>如果$X , X ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是initial的,则存在一个唯一的同构$a : X \cong X ‘ $.</p>
</li>
<li><p>如果$Y , Y ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是terminal的,则存在一个唯一的同构$b : Y \cong Y ‘ $.</p>
</li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3><p>我们定义从$\mathcal { C  } ‘ $到$\mathcal { C  } $的<strong>函子</strong>$F $需要有以下性质:</p>
<ol>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,指定一个$\mathcal { C  } $中的对象$FX $.或记作$F : \text { Ob  } ( \mathcal { C  } ‘ ) \to \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,对于态射$f : X \to Y $指定一个$\mathcal { C  } $中的对象$Ff $.或记作$F : \text { Hom  } _\mathcal { C  } ‘ ( X , Y ) \to \text { Hom  } _\mathcal { C  } ( FX , FY ) $.</p>
</li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol>
<li><p>$\forall g , f \in \text { Hom  } _{ \mathcal { C  } ‘  } $,它们的合成有意义,则$F ( gf ) = F ( g ) F ( f ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F ( \text { id  } _X ) = \text { id  } _{ FX  } $.</p>
</li>
</ol>
<p>我们一般也将上述函子记作$F : \mathcal { C  } ‘ \to \mathcal { C  } $.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然$F $可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol>
<li><p>如果$\forall T \in \text { Ob  } ( \mathcal { C  } ) , \exists X \in \text { Ob  } ( \mathcal { C  } ‘ ) $使得$T \cong FX $,则称$F $是<strong>本质满</strong>的.</p>
</li>
<li><p>如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F : \text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( FX , FY ) $均为单射,则称$F $是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p>
</li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓$\text { Hom  } $函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴$\mathcal { C  } $以及其对象$X $,我们定义函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) : \mathcal { C  } \to Set $,它映对象$Y $为集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,映态射$f : Y \to Z $为映射$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) f : \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , h \mapsto f \circ h $.</p>
<p>同理可以定义函子$\text { Hom  } _{ \mathcal { C  }  } ( \cdot , X ) $.</p>
<p>对于函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) $,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3><h4><span id="kleisli范畴">Kleisli范畴</span></h4><p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol>
<li><p>加上修饰.</p>
</li>
<li><p>合并修饰.</p>
</li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" class="post-title-link" itemprop="url">程序设计实习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2><h3><span id="基本分析">基本分析</span></h3><h4><span id="union-bound">Union Bound</span></h4><p>即:$Pr [ \bigcup _i X _i ] \leq \sum Pr [ X _i ] $,取等当且仅当所有$X _i $互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4><p>若$X \geq 0 $,则$Pr [ X \geq t \mathbb { E  } [ X ] ] \leq \frac { 1  } { t  } $.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6><p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有$\frac { 1  } { 2  } $的概率是割边,因此期望自然是$\frac { 1  } { 2  } | E | \geq \frac { 1  } { 2  } | \text { max - cut  } | $.</p>
<p>由此立即见到,$Pr [ | ans | \leq ( \frac { 1  } { 2  } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac { 1  } { 2  } + \epsilon ) | E | ] \leq \frac { 1  } { 1 + 2 \epsilon  } $.</p>
<p>由于每次独立操作,因此如果有$P $的概率失败,那么运行$T $次后至少成功一次的概率应当为$1 - P ^T $.从而$T = O ( \log _P { \delta  } ) = O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \ln ( 1 + { 2 \epsilon  } )  } ) \approx O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \epsilon  } ) $即可拿到$\delta $失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4><p>设$X _1 , \cdots , X _n \in [ 0 , 1 ] $是独立,同期望(期望为$\mu \geq t $)的随机变量,令$X = \frac { \sum _k X _k  } { n  } $,对于任何失败概率$\delta \in ( 0 , 1 ) $,应当有:</p>
<script type="math/tex; mode=display">
Pr \left [ | X - \mu | \geq \sqrt { \cfrac { \log ( 1 / \delta )  } { nt  }  } \mu \right ] \leq \delta</script><h6><span id="examplemedian-trick">Example(Median Trick)</span></h6><p>现在有一个黑盒能够以$p &gt; \frac { 1  } { 2  } $的概率正确回答Yes或者No,问重复$T $选多少次能拿到$1 - \delta $的成功概率.</p>
<p>考虑重复$T $次后应当有期望$pT $个正确答案,因此直接取中位数.称此算法为Median Trick.</p>
<p>Chernoff Bound 告诉我们$T = O ( \log \frac { 1  } { \delta  } ) $足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4><p>设独立随机变量$x _1 , \cdots , x _m \in [ s , t ] $,令$X = \sum _i x _i $,则:</p>
<script type="math/tex; mode=display">
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac { 2 z ^2  } { m ( t - s ) ^2  } \right )</script><h3><span id="编程中的随机性">编程中的随机性</span></h3><p>一般采用伪随机,也即是给定初值$X _0 $,通过某个确定性的函数来生成$X _{ n + 1  } = f ( X _n ) $这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2><h3><span id="基本定义">基本定义</span></h3><p>概率空间$\Omega $:在一个给定问题中可能发生的所有情况.</p>
<p>事件:$\Omega $的一个子集.</p>
<p>基本事件$\omega $:$\Omega $中的单个元素,也可以看作集合大小为$1 $的事件.</p>
<p>概率:若$\omega \in \Omega $,我们称它发生的概率为$\Pr ( \omega ) $,有$\Pr ( \omega ) \geq 0 $且$\sum _{ \omega \in \Omega  } \Pr ( \omega ) = 1 $.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量$X $和$Y $定义在同一个概率空间$\Omega $上,对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,我们称$\Pr ( X = x \land Y = y ) $为它们的联合分布.</p>
<p>独立:如果对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,$\Pr ( X = x \land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y ) $,我们称$X $和$Y $是独立的.</p>
<p>期望(均值)$E X $:我们设概率空间上的随机变量$X $的期望$EX = \sum _{ x \in X ( \Omega )  } x \times \Pr ( X = x ) = \sum _{ w \in \Omega  } X ( \omega ) \Pr ( \omega ) $.</p>
<p>中位数:我们设概率空间上的随机变量$X $的中位数为满足$\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x ) \geq 0 . 5 $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量$X $的众数为满足$\Pr ( X = x ) \geq \Pr ( X = x ‘ ) , \forall x ‘ \in X ( \Omega ) $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>方差$VX $:我们设概率空间上的随机变量$X $的方差$VX = E ( ( X - EX ) ^2 ) $.</p>
<p>标准差$\sigma $:我们设概率空间上的随机变量$X $的标准差$\sigma = \sqrt { VX  } $.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3><p>如果$X , Y $是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol>
<li><p>$E ( X + Y ) = EX + EY $.</p>
</li>
<li><p>$E ( \alpha X ) = \alpha EX $.</p>
</li>
<li><p>如果$X $和$Y $互相独立,那么$E ( XY ) = ( EX ) ( EY ) $.</p>
</li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3><p>我们考虑方差的定义式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X - EX ) ^2 ) & = E ( X ^2 - 2 X ( EX ) + ( EX ) ^2 ) \\
& = E ( X ^2 ) - 2 ( EX ) ( EX ) + ( EX ) ^2 \\
& = E ( X ^2 ) - ( EX ) ^2 
\end{aligned}</script><p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当$X $和$Y $为独立的随机变量时,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( ( X + Y ) ^2 ) - ( EX + EY ) ^2 \\
& = E ( ( X + Y ) ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 
\end{aligned}</script><p>而又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X + Y ) ^2 ) & = E ( X ^2 + 2 XY + Y ^2 ) \\
& = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) 
\end{aligned}</script><p>则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 \\
& = VX + VY 
\end{aligned}</script><p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<script type="math/tex; mode=display">
\Pr ( ( X - EX ) ^2 \geq \alpha ) \leq \cfrac { VX  } { \alpha  } , \alpha > 0</script><p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
VX & = \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) \\
& \geq \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& \geq \sum _{ \omega \in \Omega  } \alpha \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& = \alpha \Pr ( ( X - EX ) ^2 & \geq \alpha ) 
\end{aligned}</script><p>如果我们用$c ^2 VX $代替$\alpha $,我们就有:</p>
<p>$\Pr ( | X - EX | \geq c \sigma ) \leq \cfrac { 1  } { c ^2  } $.</p>
<p>简单来说,这个不等式说明:$X $落在$( EX - c \sigma , EX + c \sigma ) $之外的概率至多为$\cfrac { 1  } { c ^2  } $.</p>
<p>另外,如果我们取$n $个独立的样本$X _1 , X _2 , . . . , X _n $,令$S = \sum _{ i = 1  } ^n X _i $,那么它的均值是$nEX $,标准差是$\sqrt { n  } \sigma $,也就是说,$\cfrac { S  } { n  } $落在$( EX - \cfrac { c \sigma  } { \sqrt { n  }  } , EX + \cfrac { c \sigma  } { \sqrt { n  }  } ) $之外的概率小于等于$\cfrac { 1  } { c ^2  } $.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3><p>如果我们随机取得了$n $个值$X _1 , X _2 , . . . , X _n $,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p>$\hat EX = \cfrac { \sum _{ i = 1  } ^n X _i  } { n  } $.</p>
<p>$\hat VX = \cfrac { \sum _{ i = 1  } ^n X _i ^2  } { n - 1  } - \cfrac { ( \sum _{ i = 1  } ^n X _i ) ^2  } { n ( n - 1 )  } $.</p>
<p>这里的$\hat VX $似乎与定义不是那么相符.但是它拥有更好的性质:$E ( \hat VX ) = VX $.</p>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( \hat VX ) & = \cfrac { 1  } { n - 1  } E ( \sum _{ i = 1  } ^n X _i ^2 - \cfrac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n X _j X _k ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X _i ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n E ( X _i X _j ) ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( ( EX ) ^2 [ j \ne k ] + E ( X ^2 ) [ j & = k ] ) ) \\
& = \cfrac { 1  } { n - 1  } ( nE ( X ^2 ) - \cfrac { 1  } { n  } ( nE ( X ^2 ) + n ( n - 1 ) ( EX ) ^2 ) ) \\
& = E ( X ^2 ) - ( EX ) ^2 \\
& = VX 
\end{aligned}</script><h3><span id="条件概率">条件概率</span></h3><p>已知事件B发生时事件A发生的概率为$P ( A | B ) = \frac { P ( AB )  } { P ( B )  } \ $.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4><p>贝叶斯公式:如果有$\{ B _i \} $是样本空间的一个划分,即$\forall i , j $,有$B _i \cap B _j = \emptyset $,并且有$\bigcup _{ i = 1  } ^n B _i = \Omega $.则有$P ( B _i | A ) = \frac { P ( AB _i )  } { P ( A )  } = \frac { P ( AB _i )  } { P ( A ) \sum P ( B _j )  } = \frac { P ( A B _i )  } { \sum _{ j = 1  } ^n P ( A B _j )  } = \frac { P ( A | B _i ) P ( B _i )  } { \sum _{ j = 1  } ^n P ( A | B _j ) P ( B _j )  } \ $.</p>
<p>简化形式:$P ( B | A ) = \frac { P ( A | B ) P ( B )  } { P ( A )  } \ $.</p>
<p>另外,我们考虑设$O ( B ) = \cfrac { P ( B )  } { P ( \lnot B )  } $,称$\cfrac { P ( B | E )  } { P ( \lnot B | E )  } $为贝叶斯算子,则同理可得:</p>
<script type="math/tex; mode=display">
O ( B | E ) = O ( B ) \cfrac { P ( B | E )  } { P ( \lnot B | E )  }</script><p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3><p>如果$X $是定义在概率空间$\Omega $上的随机变量,那么它的概率生成函数为$G _X ( z ) = \sum _{ k \geq 0  } \Pr ( X = k ) z ^k = E ( z ^X ) $.</p>
<p>不难发现$G _X ( z ) $需要满足的条件:所有系数都非负并且$G _X ( 1 ) = 1 $.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = G _X ' ( 1 ) \\
E ( X ^2 ) & = G ' ' _X ( 1 ) + G _X ' ( 1 ) \\
VX & = G _X ' ' ( 1 ) + G _X ' ( 1 ) - ( G _X ' ( 1 ) ) ^2 
\end{aligned}</script><p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G ) & = G ' ( 1 ) \\
Var ( G ) & = G ' ' ( 1 ) + G ' ( 1 ) - ( G ' ( 1 ) ) ^2 
\end{aligned}</script><p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<script type="math/tex; mode=display">
G ( 1 + t ) = \sum _{ i \geq 0  } \cfrac { G ^{ ( i )  } ( 1 )  } { i !  } t ^i</script><p>另外,我们不难发现:$G _{ X + Y  } ( z ) = G _X ( z ) G _Y ( z ) $.</p>
<p>根据前面的推导,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _{ X + Y  } ) & = Mean ( G _X ) + Mean ( G _Y ) \\
Var ( G _{ X + Y  } ) & = Var ( G _X ) + Var ( G _Y ) 
\end{aligned}</script><p>换句话说,若$G _X ( 1 ) = 1 , G _Y ( 1 ) = 1 $,那么这个式子与直接对$G _{ X + Y  } $使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _X ) & = Mean ( G _{ X + Y  } ) - Mean ( G _Y ) \\
Var ( G _X ) & = Var ( G _{ X + Y  } ) - Var ( G _Y ) 
\end{aligned}</script><h4><span id="example1">Example1</span></h4><p>一枚硬币正面向上的概率为$p $,反面向上的概率为$q $,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设$N $为所有不包含THTTH的硬币序列的生成函数,$S $为所有只有结尾为THTTH的硬币序列的生成函数,令$H = pz , T = qz $,$1 $为空集,我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N \times ( H + T ) & = N + S \\
N \times THTTH & = S + S \times TTH 
\end{aligned}</script><p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设$A $是我们要找到的字符串,$m $是它的长度,令$A ^{ ( k )  } $表示$A $字符串的前$k $个字符所组成的字符串,$A _{ ( k )  } $表示$A $字符串的后$k $个字符所组成的字符串.这样的形式与$k $阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S \\
N \times A & = S ( \sum _{ k = 0  } ^{ m - 1  } A ^{ ( k )  } [ A ^{ ( m - k )  } & = A _{ ( m - k )  } ] ) 
\end{aligned}</script><p>如果我们设$\tilde { A  } $为将字符串$A $中的H替换成$\cfrac { 1  } { p  } z $,T替换成$\cfrac { 1  } { q  } z $之后的值,那么显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N \times A & = A \times S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
N & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
\cfrac { S - 1  } { H + T - 1  } & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) ) & = 1 
\end{aligned}</script><p>这显然是一个卷积的形式.</p>
<p>令$w = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.</p>
<p>令$H ( z ) = 1 $,$F ( z ) = ( 1 + ( 1 - z ) \times w ) $,$G ( z ) = S $.</p>
<p>那么我们显然可以直接求$G ( z ) $的期望和方差,事实上:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] \\
VX & = ( EX ) ^2 - \sum _{ k = 1  } ^m ( 2 k - 1 ) \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] 
\end{aligned}</script><p>如果硬币是均匀的($p = q = \cfrac { 1  } { 2  } $)我们引入另一个符号:我们设$A : A = \sum _{ k = 1  } ^m 2 ^{ k  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.那么显然期望需要的抛硬币次数就是$( A : A ) $.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4><p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设$S _A $为所有以HHT结尾的硬币序列的生成函数,设$S _B $为所有以HTT结尾的硬币序列的生成函数.$N $为其它的硬币序列的生成函数,令$H = T = 0 . 5 z $.</p>
<p>我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S _A + S _B \\
N \times HHT & = S _A \\
N \times HTT & = S _A \times T + S _B 
\end{aligned}</script><p>解方程并带入$z = 1 $,可以有得知以HHT结尾的概率为$\cfrac { 2  } { 3  } $.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为$A $和$B $,那么可以求出:</p>
<script type="math/tex; mode=display">
\cfrac { S _A  } { S _B  } = \cfrac { B : B - B : A  } { A : A - A : B  }</script><h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4><p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设$g _i $表示进行了$i $步还未结束的概率,$f _{ k , i  } $为进行了$i $步恰好第$k $个人胜利的概率,$F , G $是它们的生成函数,我们自然有:</p>
<ol>
<li><p>$1 + xG ( x ) = \sum _k F _k ( x ) + G ( x ) $.</p>
</li>
<li><p>$( \frac { 1  } { 2  } x ) ^L G ( x ) = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^i [ A _k ^{ ( L - i )  } = { A _j  } _{ ( L - i )  } ] $.</p>
</li>
</ol>
<p>第一个式子的用处在于带入$x = 1 $,发现$\sum _{ k  } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  } & = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{ L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } & = { A _j  } _{ ( i )  } ] 
\end{aligned}</script><p>带入$x = 1 $,有:</p>
<script type="math/tex; mode=display">
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [ A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]</script><p>不难发现对于不同的$k $,(2)的右边不同,而左边一定相同,这样就给出了$n $个等式,算上(1)一共有$n + 1 $个等式,可以算出$G ( 1 ) , F _{ 1 \cdots n  } ( 1 ) $这$n + 1 $个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3><p>现在有一个大小为$n + 1 $的概率空间,其中$\Pr ( \omega _k ) = \binom { n  } { k  } p ^k q ^{ n - k  } \ $,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令$H ( z ) = q + pz $,不难发现二项式分布的生成函数为$H ( z ) ^n $.</p>
<p>不难发现,满足二项式分布的随机变量的均值是$np $,方差是$npq $.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:$G ( z ) ^n = ( \cfrac { p  } { 1 - qz  } ) ^n = \sum _{ k  } \binom { n + k - 1  } { k  } p ^n q ^k z ^k $.</p>
<p>我们考虑如何求$G ( z ) $的方差和均值,不妨设$F ( z ) = \cfrac { 1 - qz  } { p  } = \cfrac { 1  } { p  } - \cfrac { q  } { p  } z $,则$G ( z ) ^n = F ( z ) ^{ - n  } $.</p>
<p>不难发现$F ( z ) $满足二项式分布.也就是说,以$( n , p , q ) $为参数的负二项式分布也就是以$( - n , - \cfrac { q  } { p  } , \cfrac { 1  } { p  } ) $为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3><h4><span id="树上随机游走">树上随机游走</span></h4><p>随机游走指每次从相邻的点中随机选一个走过去， 重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5><p>给一棵所有边长都为$1 $的$n $个点的树,问所有点对$( i , j ) ( 1 \leq i , j \leq n ) $中,从$i $走到$j $的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设$f _u $表示$u $随机走到它父亲的期望,$g _v $表示$v $的父亲(假设是$u $)走到$v $的期望.</p>
<p>对于$f _u $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { \sum _{ u \rightarrow v  } ( f _v + f _u )  } { \deg _u  } + 1 \\
f _u & = \deg _u + \sum _{ u \rightarrow v  } f _v 
\end{aligned}</script><p>对于$g _v $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _v & = \cfrac { g _u + g _v + \sum _{ u \rightarrow w , w \ne v  } ( g _v + f _w )  } { \deg _u  } + 1 \\
g _v & = g _u + \sum _{ u \rightarrow w , w \ne v  } f _w + \deg _u 
\end{aligned}</script><h5><span id="example2">Example2</span></h5><p>给出一棵$n $个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从$1 $号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案$+ 1 $.当走到度数为$1 $的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设$f _u $表示以$u $为起点的路径的期望长度,不难注意到$f _{ leaf  } = 1 $且$f _u = 1 + \cfrac { 1  } { \deg _u  } \sum _{ u \rightarrow v \lor v \rightarrow u  } f _v $.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得$f _u = k _u f _{ fa  } + b _u $,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出$g _v $表示从$v $的父亲(假设是$u $)走到$v $的概率,再令$f _u $表示从$u $走到父亲的概率,类似Example1,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { 1  } { \deg _u  } ( 1 + \sum _{ u \rightarrow v  } f _v f _u ) \\
g _v & = \cfrac { 1  } { \deg _u  } ( 1 + g _v g _u + \sum _{ u \rightarrow w , w \ne v  } f _w g _v ) 
\end{aligned}</script><p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4><h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5><p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为$\frac { 1  } { \binom { n  } { 2  }  } $.</p>
<p>把所有人权值从大到小排序,设$f _i $表示只考虑前$i $个人的时候的期望,不难发现:$f _{ i  } = \frac { 1  } { \binom { i  } { 2  }  } v _i + ( 1 - \frac { 1  } { \binom { i  } { 2  }  } ) f _{ i - 1  } $.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4><h5><span id="example1cf865c">Example1(CF865C)</span></h5><p>首先写出转移式子,但是存在后效性.如果我们设$f _{ i , j  } $表示过了$i $关,花费为$j $的期望,不难发现所有的$f $都需要与$f _{ 0 , 0  } $取$\min $,这咋办?</p>
<p>我们考虑二分这个$f _{ 0 , 0  } $,做的时候直接取$\min $,这样最后还会求出一个$f _{ 0 , 0  } $,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的$f _{ 0 , 0  } $越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取$\min $的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5><p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5><p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张$n \times m $的图(假设$n \geq m $),其中格点$( a , b ) $表示现在还剩$a $个Yes,$b $个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从$( n , m ) $走到$( 0 , 0 ) $的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线$y = x $翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从$( n , m ) $走到$( 0 , 0 ) $一定会经过$n $条有向边,所以期望贡献一定要加上一个$n $.而如果我走到了直线$y = x $上,那接下来的贡献是$\frac { 1  } { 2  } $.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2><h3><span id="树">树</span></h3><ol>
<li><p>随机树树高为$\sqrt { n  } $.</p>
</li>
<li><p>点的度数期望为$\log n $.</p>
</li>
</ol>
<h3><span id="数">数</span></h3><ol>
<li>数字的期望因数个数为$\log V $.</li>
</ol>
<h3><span id="序列">序列</span></h3><ol>
<li>随机序列的LIS长度期望为$O ( \sqrt { n  } ) $.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2><h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">多项式与生成函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2><h3><span id="复数相关">复数相关</span></h3><p>棣莫弗定理:$( cos \theta + i \sin \theta ) ^n = \cos ( n \theta ) + i \sin ( n \theta ) $.</p>
<p>欧拉公式:$e ^{ i \pi  } = - 1 $.</p>
<p>也就是$e ^{ 2 i \pi  } = 1 $,同时又有$e ^{ i \theta  } = cos \theta + i · sin \theta $,证明直接使用泰勒展开.</p>
<p>单位根:对于$x ^n = 1 $,我们会有$n $个根,设第$k $个根为$\omega _n ^k $.那么我们有:$\omega _n ^k = e ^{ 2 \pi \frac { k  } { n  } i  } = cos ( 2 \pi \frac { k  } { n  } ) + i · sin ( 2 \pi \frac { k  } { n  } ) $.</p>
<p>单位根有以下性质:</p>
<ol>
<li><p>折半引理:$\omega _{ 2 n  } ^{ 2 k  } = \omega _n ^k \ $,由我们上面推导的通项公式即可证明.</p>
</li>
<li><p>消去引理:$\omega _n ^{ k + \frac { n  } { 2  }  } = - \omega _n ^k \ $,同样使用通项，运用三角恒等变换可证明.</p>
</li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4><p>上复平面,设$S _k = ( \cos \frac { 2 k \pi  } { n  } , \sin \frac { 2 k \pi  } { n  } ) $,也就是$z _k = \cos \frac { 2 k \pi  } { n  } + i \sin \frac { 2 k \pi  } { n  } $是方程$z ^n - 1 = 0 $的复根.我们把这个方程写开:</p>
<script type="math/tex; mode=display">
z ^n - 1 = ( z - 1 ) ( z ^{ n - 1  } + z ^{ n - 2  } + \cdots + 1 ) = 0</script><p>不难发现$z = 1 $是平凡解.</p>
<p>我们不妨定义$f ( x ) = \prod _{ k = 1  } ^n ( 1 + X ^k ) = \sum _{ k \geq 0  } a _k X ^k $,事实上我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { n  } \sum _{ j = 1  } ^n f ( \omega _n ^j ) & = \frac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k \geq 0  } a _k \omega ^{ kj  } _n \\
& = \frac { 1  } { n  } \sum _{ k \geq 0  } a _k \sum _{ j = 1  } ^n \omega _{ n  } ^{ kj  } \\
& = \sum _{ j \geq 0  } a _{ jn  } + \frac { 1  } { n  } \sum _{ k \geq 0 , n \nmid k  } a _k \frac { 1 - \omega ^{ nj  } _n  } { 1 - \omega ^{ k  } _n  } \omega _{ n  } ^j \\
& = \sum _{ j \geq 0  } a _{ jn  } 
\end{aligned}</script><p>事实上,我们令$d = \frac { n  } { \gcd ( j , n )  } $,容易发现$f ( \omega _n ^j ) = ( \prod _{ k = 1  } ^d ( 1 + \omega _n ^{ kj  } ) ) ^{ \frac { n  } { d  }  } $,又容易发现$n | jd $.</p>
<p>接下来观察$X ^d - 1 = \prod _{ k = 1  } ^d ( X - \omega _{ n  } ^{ kj  } ) $,带入$X = - 1 $得到$f ( \omega _n ^j ) = \begin{cases}2 ^{ \frac { n  } { d  }  } &amp; d \in \text { odd  } \ 0 &amp; d \in \text { even  } \end{cases} $.</p>
<p>接下来考虑拿到$\sum _{ j  } a _{ jn  } $,只需求$\frac { 1  } { n  } \sum _{ j = 1  } ^n f ( \omega _n ^j ) = \frac { 1  } { n  } \sum _{ d \in \text { odd  } , \gcd ( j , n ) = \frac { n  } { d  }  } 2 ^{ \frac { n  } { d  }  } = \frac { 1  } { n  } \sum _{ d \in \text { odd  }  } \varphi ( d ) 2 ^{ \frac { n  } { d  }  } $.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5><p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现$+ , - , \times , \div , \sqrt [2 ] {  } $五种操作.而对于正$n $边形,显然只要我们能将$\cos \frac { 2 \pi  } { n  } $用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6><p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma _1 & = z _1 + z _4 \\
\sigma _2 & = z _2 + z _3 
\end{aligned}</script><p>不难验证:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma _1 + \sigma _2 & = - 1 \\
\sigma _1 \sigma _2 & = - 1 
\end{aligned}</script><p>可以求出复合条件的解,将$z $带入又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma _1 & = 2 \cos \frac { 2 \pi  } { 5  } \\
\sigma _2 & = 2 \cos \frac { 4 \pi  } { 5  } 
\end{aligned}</script><p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6><p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6><p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设$n \in prime $,我们用$p $代替$n $.</p>
<p>我们有$z _1 = \cos \frac { 2 \pi  } { p  } + i \sin \frac { 2 \pi  } { p  } $,由于其它的$z $都可以表示成它的幂,因此我们记$\varepsilon = z _1 $.</p>
<p>我们现在想要这么分组:</p>
<script type="math/tex; mode=display">
\sigma _{ k + 1  } = \sum _{ 1 \leq l \leq p - 1 , f ( l , k ) = 1  } \varepsilon ^l</script><h3><span id="泰勒展开">泰勒展开</span></h3><p>即$f ( x ) = g ( x ) = f ( x _0 ) + \sum _{ k \geq 1  } \frac { f ^{ ( k )  } ( x _0 )  } { k !  } ( x - x _0 ) ^k \ $.$x _0 = 0 $的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2><h3><span id="多项式基础">多项式基础</span></h3><h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4><p>代数基本定理:一个$n - 1 $次方程在复数域上有且只有$n - 1 $个根.</p>
<p>定理:一个$n - 1 $次多项式在$n $个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个$n - 1 $次多项式$A ( x ) $和$B ( x ) $且有$\forall i \in [ 0 , n - 1 ] , A ( x _i ) = B ( x _i ) \ $.</p>
<p>令$C ( x ) = A ( x ) - B ( x ) $,那么$C ( x ) $至多是一个$n - 1 $次多项式且$\forall i \in [ 0 , n - 1 ] , C ( x _i ) = 0 \ $,也就是$C ( x ) $有$n $个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:$A ( x ) = \sum _{ i = 0  } ^{ n - 1  } a _i x ^i \ $.</p>
<p>点值表示法:$y _i = \sum _{ j = 0  } ^{ n - 1  } a _j x _i ^j \ $.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4><p>构造多项式$\sum _{ i = 0  } ^{ n - 1  } y _i ( \prod _{ j = 0 \land j \ne i  } ^{ n - 1  } \frac { x - x _j  } { x _i - x _j  } ) \ $.显然当$x = x _i $时,该多项式的答案为$y _i $.</p>
<p>另外,如果$x _i = i $,不难发现这个式子可以写成:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^{ n  } y _i ( \prod _{ j = 1 \land j \ne i  } ^{ n  } \frac { x - x _j  } { x _i - x _j  } ) \\
\\
& = \sum _{ i = 1  } ^n y _i ( \prod _{ j = 1 \land j \ne i  } ^n \cfrac { x - j  } { i - j  } ) \\
& = \sum _{ i = 1  } ^n y _i ( - 1 ) ^{ n - i  } ( \cfrac { 1  } { ( i - 1 ) ! ( n - i ) !  } \prod _{ j = 1 , j \ne i  } ^{ n  } ( x - j ) ) 
\end{aligned}</script><h3><span id="多项式运算">多项式运算</span></h3><p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4><h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5><h6><span id="dft">DFT</span></h6><p>将$n $次单位根(默认$n $是二的整次幂,如果少了的话补零,设$n = 2 ^w $)分别带入$A ( x ) $得到点值向量$A ( \omega _n ^k ) \ $.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( x ) & = \sum _{ i = 0  } ^{ n - 1  } a _i x ^i \\
& = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^i + \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a _i x ^i \\
& = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^{ 2 k  } + x \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a _i x ^{ 2 k  } \\

\end{aligned}</script><p>令</p>
<p>A_2(x)=\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{k}\\$, 那 么 $A(x)=A_1(x^2)+xA_2(x^2)\\</p>
<p>接下来分类讨论:</p>
<p>$\forall 0 \leq k \leq \frac { n  } { 2  } - 1 , k \in \mathbb { N  } \ $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^k ) & = A _1 ( \omega _n ^{ 2 k  } ) + \omega _n ^k A _2 ( \omega _n ^{ 2 k  } ) \\

\end{aligned}</script><p>根据折半引理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^k ) & = A _1 ( \omega _{ \frac { n  } { 2  }  } ^k ) + \omega _n ^k A _2 ( \omega ^k _{ \frac { n  } { 2  }  } ) \\

\end{aligned}</script><p>这样我们处理完了前半部分.</p>
<p>$\forall \frac { n  } { 2  } \leq k + \frac { n  } { 2  } \leq n - 1 , k \in \mathbb { N  } \ $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) & = A _1 ( \omega _n ^{ 2 k + n  } ) + \omega _n ^{ k + \frac { n  } { 2  }  } A _2 ( \omega _n ^{ 2 k + n  } ) \\

\end{aligned}</script><p>根据消去引理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) & = A _1 ( \omega _{ \frac { n  } { 2  }  } ^k ) - \omega _n ^k A _2 ( \omega _{ \frac { n  } { 2  }  } ^k ) \\

\end{aligned}</script><p>综上,我们可以递归处理$A _1 $和$A _2 $,然后合并得到$A $的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6><p>设$A ( \omega _n ^k ) = d _k \ $,构造多项式$F ( x ) = \sum _{ i = 0  } ^{ n - 1  } d _i x ^i \ $.</p>
<p>我们求出$F ( x ) $的点值表示,设$c _k = F ( \omega _n ^{ - k  } ) \ $,也即:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c _k & = \sum _{ i = 0  } ^{ n - 1  } d _i ( \omega _n ^{ - k  } ) ^i \\
& = \sum _{ i = 0  } ^{ n - 1  } ( \sum _{ j = 0  } ^{ n - 1  } a _j ( \omega _n ^i ) ^j ) ( \omega _n ^{ - k  } ) ^i \\
& = \sum _{ j = 0  } ^{ n - 1  } a _j \sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } \\

\end{aligned}</script><p>当$j = k $时,显然$\sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } = n \ $.</p>
<p>否则根据等比数列求和公式,$\sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } = \frac { \omega ^0 _n [ ( \omega _n ^{ j - k  } ) ^n - 1 ]  } { \omega _n ^{ j - k  } - 1  } = 0 \ $.</p>
<p>所以$\sum _{ i = 0  } ^{ n - 1  } ( \omega _n ^i ) ^{ j - k  } = n [ j = k ] \ $.</p>
<p>那么我们有</p>
<p>a_k=\frac{c_k}{n}\\</p>
<h6><span id="写法">写法</span></h6><p>递归写法显然.</p>
<p>递归过程中,第$k $层相当于在根据数在第$k $位的二进制数是$1 $还是$0 $来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">ll ak=a[i+k];</span><br><span class="line">a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5><p>由于FFT中的单位根会产生精度误差,因此在膜$998244353 $意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为$g $,$g _n = g ^{ \frac { p - 1  } { n  }  } \ $,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol>
<li><p>$g _n ^n = g _n ^0 = 1 $且$\forall 0 \leq i &lt; j &lt; n , g _n ^i \ne g _n ^j $,证明由原根的性质.</p>
</li>
<li><p>折半引理:$g _{ 2 n  } ^{ 2 k  } = g _{ n  } ^k $,证明显然.</p>
</li>
<li><p>消去引理:$g _{ n  } ^{ k + \frac { n  } { 2  }  } = - g ^k _n \ $.由于$g ^{ \frac { p - 1  } { 2  }  } = - 1 $,该结论显然成立.</p>
</li>
</ol>
<p>由上我们证明了,我们完全可以使用$g _n $代替$\omega _n $进行变换.</p>
<p>另外,注意到$998244352 = 2 ^{ 23  } \times 7 \times 17 \ $,而$2 ^{ 23  } \approx 8 \times 10 ^6 \ $.因而,当$n \leq 8 \times 10 ^6 $的时候,$g _n $可以直接求出.这也是为什么大部分NTT题目都使用$998244353 $作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5><p>范德蒙德矩阵形如:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & \alpha _1 & \cdots & \alpha _1 ^{ n - 1  } \\
1 & \alpha _2 & \cdots & \alpha _2 ^{ n - 1  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \alpha _m & \cdots & \alpha _m ^{ n - 1  } 
\end{bmatrix} \in \mathbb { R  } ^{ m \times n  }</script><p>如果取单位根,我们有:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega _n ^1 & \cdots & \omega _2 ^{ n - 1  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega _n ^{ n - 1  } & \cdots & \omega _n ^{ ( n - 1 ) ^2  } 
\end{bmatrix} \in \mathbb { R  } ^{ n \times n  }</script><p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega _n ^1 & \cdots & \omega _2 ^{ n - 1  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega _n ^{ n - 1  } & \cdots & \omega _n ^{ ( n - 1 ) ^2  } 
\end{bmatrix} ^{ - 1  } = \frac { 1  } { n  } \begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega _n ^{ - 1  } & \cdots & \omega _2 ^{ - ( n - 1 )  } \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega _n ^{ - ( n - 1 )  } & \cdots & \omega _n ^{ - ( n - 1 ) ^2  } 
\end{bmatrix}</script><h4><span id="分治fft">分治FFT</span></h4><p>给定$g ( x ) $和$f ( 0 ) $,求$f ( x ) = \sum _{ y = 1  } ^x f ( x - y ) g ( y ) $,答案对$998244353 $取膜.</p>
<p>考虑分治,假如我们已经知道了$f ( x ) , x \in [ 1 , \frac { n  } { 2  } ] $.那我们可以计算出这段部分对$f ( y ) ， y \in [ \frac { n  } { 2  } + 1 , n ] $的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算$f $和$g $的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4><p>对于多项式$P ( x ) $,找到$Q ( x ) $使得$Q ( x ) P ( x ) \equiv 1 \pmod { x ^{ n  }  } \ $.显然$Q ( x ) $是唯一的.</p>
<p>首先不妨设$n = 2 ^k \ $.</p>
<p>如果我们已知$P ( x ) Q _{ k - 1  } ( x ) \equiv 1 \pmod { x ^{ 2 ^{ k - 1  }  }  } \ $,同时肯定有$P ( x ) Q _{ k  } ( x ) \equiv 1 \pmod { x ^{ 2 ^{ k - 1  }  }  } \ $,相减得到$Q _k ( x ) - Q _{ k - 1  } ( x ) \equiv 0 \pmod { x ^{ 2 ^{ k - 1  }  }  } \ $.</p>
<p>两边平方:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q _k ^2 ( x ) + Q ^2 _{ k - 1  } ( x ) - 2 Q _k ( x ) Q _{ k - 1  } ( x ) & \equiv 0 \pmod { x ^{ 2 ^k  }  } \\

\end{aligned}</script><p>两边乘一下$P ( x ) $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q _k ( x ) - 2 Q _{ k - 1  } ( x ) + P ( x ) Q _{ k - 1  } ^2 ( x ) & \equiv 0 \pmod { x ^n  } \\
Q _k ( x ) & \equiv 2 Q _{ k - 1  } ( x ) - P ( x ) Q _{ k - 1  } ^2 ( x ) \pmod { x ^n  } \\

\end{aligned}</script><p>根据主定理，这么做复杂度是$O ( n \log _2 n ) $的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F ( x ) & \equiv F ( x ) G ( x ) + f _0 \pmod { x ^{ n + 1  }  } \\
F ( x ) & = \frac { f ( 0 )  } { 1 - G ( x )  } \pmod { x ^{ n + 1  }  } 
\end{aligned}</script><p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4><p>对于$n $次多项式$F ( x ) $和$m $次多项式$G ( x ) $,找到$Q ( x ) , R ( x ) $使得$F ( x ) = G ( x ) Q ( x ) + R ( x ) \ $.</p>
<p>考虑对于$n $次多项式$F ( x ) $,令$F _R ( x ) = x ^n F ( \cfrac { 1  } { x  } ) $,如果设$f _i $为其$x ^i $项前的系数,不难发现$f _R ( i ) = f ( n - i ) $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F ( x ) & = G ( x ) Q ( x ) + R ( x ) \\
F ( \cfrac { 1  } { x  } ) & = G ( \cfrac { 1  } { x  } ) Q ( \cfrac { 1  } { x  } ) + R ( \cfrac { 1  } { x  } ) \\
x ^n F ( \cfrac { 1  } { x  } ) & = x ^m G ( \cfrac { 1  } { x  } ) x ^{ n - m  } Q ( \cfrac { 1  } { x  } ) + x ^{ n - m + 1  } x ^{ m - 1  } R ( \cfrac { 1  } { x  } ) \\
F _R ( x ) & = G _R ( x ) Q _R ( x ) + x ^{ n - m + 1  } R _R ( x ) \\
F _R ( x ) & \equiv G _R ( x ) Q _R ( x ) \pmod { x ^{ n - m + 1  }  } \\
Q _R ( x ) & \equiv F _R ( x ) G _R ^{ - 1  } ( x ) \pmod { x ^{ n - m + 1  }  } 
\end{aligned}</script><p>于是只要做一遍多项式求逆即可求得$Q ( x ) $,再做一遍相减既可以得到$R ( x ) $.</p>
<h4><span id="多项式ln">多项式ln</span></h4><p>给出$n - 1 $次多项式$A ( x ) $,求一个多项式$B ( x ) $,满足$B ( x ) \equiv \ln A ( x ) $.</p>
<p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
B ( x ) & \equiv \ln A ( x ) \pmod { x ^n  } \\
B ' ( x ) & \equiv \cfrac { A ' ( x )  } { A ( x )  } \pmod { nx ^{ n - 1  }  } \\
B ( x ) & \equiv \int \cfrac { A ' ( x )  } { A ( x )  } dx \pmod { x ^n  } \\

\end{aligned}</script><p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当$[ x ^0 ] f ( x ) = 1 $的时候,$f ( x ) $有对数多项式.</p>
<p>我们对最后再做一步:</p>
<script type="math/tex; mode=display">
\begin{aligned}
B ( x ) & \equiv \int _0 ^x \cfrac { A ' ( t )  } { A ( t )  } dt + B ( 0 ) \pmod { x ^n  } \\

\end{aligned}</script><p>首先$B ( 0 ) = \ln A ( 0 ) = \ln a _0 $,如果$a _0 \in \mathbb { Q  } \land a _0 \ne 1 $,则$B ( 0 ) \notin \mathbb { Q  } $,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若$[ x ^0 ] f ( x ) = 1 $的时候,$B ( 0 ) = 0 $,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4><p>给定多项式$G ( x ) $,求一个多项式$F ( x ) $满足$G ( F ( x ) ) \equiv 0 \pmod { x ^n  } $.</p>
<p>首先$n = 1 $的时候,也就是求$G ( F ( x ) ) \equiv 0 \pmod { x  } $.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在$\bmod x ^{ \lceil \frac { n  } { 2  } \rceil  } $意义下的答案$F _0 ( x ) $,我们考虑在$F _0 ( x ) $处做泰勒展开:</p>
<script type="math/tex; mode=display">
\begin{aligned}
G ( F ( x ) ) & = \sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k )  } ( F _0 ( x ) )  } { k !  } ( F ( x ) - F _0 ( x ) ) ^k & \equiv 0 \pmod { x ^n  } \\

\end{aligned}</script><p>考虑$F ( x ) - F _0 ( x ) $,由于$F _0 ( x ) \equiv F ( x ) \pmod { x ^{ \lceil \frac { n  } { 2  } \rceil  }  } $,因此,因此$( F ( x ) - F _0 ( x ) ) ^2 \equiv 0 \pmod { x ^n  } $.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k )  } ( F _0 ( x ) )  } { k !  } ( F ( x ) - F _0 ( x ) ) ^k & \equiv 0 \pmod { x ^n  } \\
G ( F _0 ( x ) ) + G ' ( F _0 ( x ) ) ( F ( x ) - F _0 ( x ) ) & \equiv 0 \pmod { x ^n  } \\
F ( x ) & \equiv F _0 ( x ) - \frac { G ( F _0 ( x ) )  } { G ' ( F _0 ( x ) )  } \pmod { x ^n  } 
\end{aligned}</script><p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4><p>给定$h ( x ) $,设$g ( f ( x ) ) = f ^2 ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<script type="math/tex; mode=display">
f ( x ) \equiv f _0 ( x ) - \frac { f ^2 ( x ) - h ( x )  } { 2 f _0 ( x )  } \equiv \frac { f ^2 ( x ) + h ( x )  } { 2 f _0 ( x )  } \pmod { x ^n  }</script><p>还没完,用牛顿迭代前一定要求$g ( a ) \equiv 0 \pmod { x ^n  } $的解,也就是$[ x ^0 ] h ( x ) $的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4><p>给定$h ( x ) $,设$g ( f ( x ) ) = \ln f ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( x ) & \equiv f _0 ( x ) - \frac { \ln f _0 ( x ) - h ( x )  } { \frac { 1  } { f _0 ( x )  }  } \pmod { x ^n  } \\
& \equiv f _0 ( x ) ( 1 - \ln f _0 ( x ) + h ( x ) ) \pmod { x ^n  } 
\end{aligned}</script><p>还没完,还需要求$g ( a ) \equiv 0 \pmod { x ^n  } $的解,注意到存在$\exp $当且仅当$[ x ^0 ] g ( x ) \equiv 0 $,此时$f ( x ) \equiv 1 \pmod { x  } $.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4><p>求$\ln $后求$\exp $即可,唯一的问题是为什么指数可以对$p $取膜.</p>
<p>我们有一个结论:</p>
<script type="math/tex; mode=display">
f ( x ^p ) \equiv f ( x ) ^p \pmod { p  }</script><p>这个结论很简单,注意到$( a + b ) ^p \equiv a ^p + b ^p \pmod { p  } $即可.</p>
<p>而又由于$n &lt; p $,因此$f ( x ) ^p \equiv f ( 0 ) \pmod { p  } $,通常取$f ( 0 ) = 1 $,于是就可以直接对$p $取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4><p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做$\exp $的时候的直接数组传参,会导致$\exp $的复杂度退化到$O ( n \log ^2 n ) $.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">ll x[qwq];</span><br><span class="line"><span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">ll ak=(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">x.k=k;</span><br><span class="line">x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">y.x[i]=x*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">y.limit=x.limit;y.k=x.k;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">tmp_inv.x[i]=x.x[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">tmp_inv.k=q_inv.k=k;</span><br><span class="line">q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line"><span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line"><span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">x.limit=lim,x.k=k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">tmp_exp.k=q_exp.k=k;</span><br><span class="line">q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_exp;</span><br><span class="line">&#125;</span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3><p>集合幂级数形如$\sum _{ i = 0  } ^{ 2 ^n - 1  } a _i x ^i $,其中二进制数$i $表示$\{ 1 , 2 , . . . , n \} $的一个子集,用$| i | $表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4><p>高维前缀和:$c _i = \sum _{ j \subseteq i  } a _j \ $.</p>
<p>高维后缀和:$c _i = \sum _{ j \supseteq i  } a _j \ $.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:$c _i = \sum _{ j  } \sum _{ k  } [ j \lor k = i ] a _j b _k \ $.</p>
<p>与卷积:$c _i = \sum _{ j  } \sum _{ k  } [ j \land k = i ] a _j b _k \ $.</p>
<p>二者求法类似,考虑如何求$a $和$b $的或卷积:</p>
<p>引理:</p>
<p>若$j , k \subseteq i $,则$j \lor k \subseteq i $,逆命题同样成立.</p>
<p>若$j , k \supseteq i $,则$j \land k \supseteq i $,逆命题同样成立.</p>
<p>设$a , b , c $的高维前缀和分别为$A , B , C $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A _i B _i & = ( \sum _{ j \subseteq i  } a _j ) ( \sum _{ k \subseteq i  } b _k ) \\
& = \sum _{ j , k \subseteq i  } a _i b _k \\
& = \sum _{ k \lor j \subseteq i  } a _i b _k \\
& = C _i \\

\end{aligned}</script><p>现在考虑已知$C $求$c $,本质上是一个反演.注意到$\sum _{ r \subseteq p  } ( - 1 ) ^{ | r |  } = \sum _{ k = 0  } ^{ | p |  } C _{ | p |  } ^k ( - 1 ) ^k = [ p = 0 ] \ $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c ( p ) & = \sum _{ q \subseteq p  } [ p - q & = 0 ] c ( q ) \\
& = \sum _{ q \subseteq p  } \sum _{ r \subseteq ( p - q )  } ( - 1 ) ^{ | r |  } c ( q ) \\
& = \sum _{ r \subseteq p  } ( - 1 ) ^{ | r |  } \sum _{ q \subseteq ( p - r )  } c ( q ) \\
& = \sum _{ r \subseteq p  } ( - 1 ) ^{ r  } C ( p - r ) \\
& = \sum _{ r \subseteq p  } ( - 1 ) ^{ | p | - | r |  } C ( r ) \\

\end{aligned}</script><p>于是有$c ( S ) = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } C ( T ) \ $(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度$O ( 2 ^n n ) $.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4><p>异或卷积:$c _i = \sum _j \sum _k [ j \oplus k = i ] a _j b _k \ $.</p>
<p>引理:$( i \oplus j ) \land k = ( i \land k ) \oplus ( j \land k ) $.</p>
<p>证明的话考虑如果$k = 0 $,二者显然相等;当$k = 1 $的时候,左右都等价于$( i \oplus j ) $.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数$FWT ( a ) $,满足$FWT ( a ) _i = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } a _j \ $.</p>
<p>那么有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( c ) _i & = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } c _j \\
& = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } [ k \oplus l & = j ] a _k b _l \\
& = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | ( k \oplus l ) \land i |  } a _k b _l \\
& = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | k \land i |  } a _k ( - 1 ) ^{ | l \land i |  } b _l \\
& = FWT ( a ) _i FWT ( b ) _i \\

\end{aligned}</script><p>时间复杂度$O ( 2 ^n n ) $.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的$\frac { 1  } { 2  } $都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4><h5><span id="线性代数角度">线性代数角度</span></h5><p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换$FWT $,使得</p>
<ol>
<li><p>若$c _i = \sum _{ j \oplus k  } a _j b _k $,则$FWT ( c ) = FWT ( a ) FWT ( b ) $.</p>
</li>
<li><p>这个线性变换是可逆的.</p>
</li>
<li><p>做这个线性变换和其逆变换的复杂度都可以接受.</p>
</li>
</ol>
<p>我们设$FWT ( A ) _i = \sum _{ j  } w ( i , j ) A _j $,我们想要做的就是构造一组满足上述条件的$w $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( C ) _i & = FWT ( A ) _i FWT ( B ) _i \\
\sum _{ j  } w ( i , j ) C _j & = \sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k 
\end{aligned}</script><p>再考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C & = A * B \\
C _i & = \sum _{ k \oplus l = i  } A _k B _l \\
\sum _{ j  } w ( i , j ) C _j & = \sum _j w ( i , j ) \sum _{ k \oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k & = \sum _j w ( i , j ) \sum _{ k \oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k & = \sum _{ j , k  } A _j B _k w ( i , j \oplus k ) 
\end{aligned}</script><p>比较两边系数,有$w ( i , j ) w ( i , k ) = w ( i , j \oplus k ) $.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于$\oplus $是集合的运算,我们可以对二进制分开考虑.换句话说,如果$a = \sum _{ i = 0  } a _i 2 ^i , b = \sum _{ i = 0  } b _i 2 ^i $,那么$w ( a , b ) = \prod _{ i = 0  } w ( a _i , b _i ) $一定是满足条件的.</p>
<p>这样我们就可以只求一个$2 \times 2 $的线性变换矩阵就好.我们接下来将对三种常见的基础位运算($\lor , \land , xor ( \oplus ) $)分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出$FWT ( a ) $呢?</p>
<p>考虑和FFT一样折半,令$i _0 $为$i $的最高位是否是$1 $,$i ‘ $为$i $去掉最高位后的二进制数字,令$n = 2 ^m $我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) _i & = \sum _{ j = 0  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
& = \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i , j ) A _j + \sum _{ j = 2 ^{ m - 1  }  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
& = w ( i _0 , 0 ) \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i ' , j ' ) A _j + w ( i _0 , 1 ) \sum _{ j = 2 ^{ m - 1  }  } ^{ 2 ^m - 1  } w ( i ' , j ' ) A _j 
\end{aligned}</script><p>这样就实现了规模减半,复杂度$O ( mn ) $.</p>
<p>下面我们设FWT的变换矩阵为$\begin{bmatrix}w ( 0 , 0 ) &amp; w ( 0 , 1 ) \ w ( 1 , 0 ) &amp; w ( 1 , 1 ) \end{bmatrix} $.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6><p>取矩阵$\begin{bmatrix}1 &amp; 0 \ 1 &amp; 1 \end{bmatrix} $.其逆矩阵为$\begin{bmatrix}1 &amp; 0 \ - 1 &amp; 1 \end{bmatrix} $.</p>
<h6><span id="与卷积">与卷积</span></h6><p>取矩阵$\begin{bmatrix}1 &amp; 1 \ 0 &amp; 1 \end{bmatrix} $.其逆矩阵为$\begin{bmatrix}1 &amp; - 1 \ 0 &amp; 1 \end{bmatrix} $.</p>
<h6><span id="异或卷积">异或卷积</span></h6><p>取矩阵$\begin{bmatrix}1 &amp; 1 \ 1 &amp; - 1 \end{bmatrix} $.其逆矩阵为$\begin{bmatrix}\frac { 1  } { 2  } &amp; \frac { 1  } { 2  } \ \frac { 1  } { 2  } &amp; - \frac { 1  } { 2  } \end{bmatrix} $.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5><p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:$x ^S x ^T = x ^{ S \oplus T  } $,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) _S & = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | S \land T |  } a _T \\
IFWT ( A ) _S & = \frac { 1  } { 2 ^n  } FWT ( A ) _S 
\end{aligned}</script><p>这等价于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
[ x ^S ] FWT ( A ) & = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | S \land T |  } a _T \\
[ x ^S ] IFWT ( A ) & = [ x ^S ] \frac { 1  } { 2 ^n  } FWT ( A ) 
\end{aligned}</script><h4><span id="子集卷积">子集卷积</span></h4><p>子集卷积:$c _i = \sum _{ j  } \sum _{ k  } [ j \land k = \emptyset , j \lor k = i ] a _j b _k \ $.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些$[ j \land k \ne \emptyset ] $的答案,而$[ j \land k = \phi , j \lor k = i ] = [ | j | + | k | = | i | , j \lor k = i ] \ $.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再$n ^2 $次结合,并做IFMT,最终将结果累计,复杂度$O ( 2 ^n n ^2 ) $.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4><p>其实就是设$g _{ i , j  } = z ^i f _j $,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4><h5><span id="example1agc034f-rng-and-xor">Example1([AGC034F] RNG and XOR)</span></h5><p>设$f _i ( n ) $表示操作$n $次后第一次变成$i $的概率,$g _i ( n ) $表示操作$n $次后变成$i $的概率.$F , G $分别是其生成函数.</p>
<p>注意到$G _i = F _i G _0 , F _i = \frac { G _i  } { G _0  } $,而$F _i ‘ ( 1 ) $就是期望.接下来的问题在于如何求$G $.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把$a _i \rightarrow \frac { a _i  } { \sum a  } $,然后做$A = FWT ( a ) $,注意这里$A _0 = \sum a = 1 $,FWT自身有很好的性质:$a = \frac { 1  } { 2 ^N  } FWT ( A ) $.我们做$n $次操作后得到的概率数组也就是$\frac { 1  } { 2 ^N  } FWT ( A ^n ) $.展开FWT的式子,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _i ( n ) & = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } A _j ^n x ^n \\
G _i & = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } \frac { 1  } { 1 - A _j x  } \\
F _i & = \frac { G _i  } { G _0  } \\
F _i ' & = \frac { G _i ' G _0 - G _0 ' G _i  } { G _0 ^2  } \\
& = \frac { ( \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { 1  } { 1 - A _j x  } ) - ( \sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  } \frac { 1  } { 1 - A _j x  } )  } { ( \sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { 1  } { 1 - A _j x  } ) ^2  } 
\end{aligned}</script><p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求$F ‘ _i ( 1 ) $,因此我们直接把$x = 1 $带入算一算就好.不过由于$A _0 = 1 $,我们必须要解决分母为$0 $的情况,解决的方法是分母乘上$( 1 - x ) $,这样就消掉了$j = 0 $的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5><p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边$u \leftrightarrow v $就异或上$( 2 ^u + 2 ^v ) $.最后要求这个二进制数是$0 $.我们用一个二元组$( a , F ) $表示在集合幂级数上异或上$a $,在多项式上乘上$F $.显然一条边是$( 0 , 1 ) + ( 2 ^u + 2 ^v , x ) $.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上$1 + x $要么乘上$1 - x $,做完FWT得到的每一个$FWT _i $一定形如$( 1 + x ) ^k ( 1 - x ) ^{ m - k  } $,做IFWT的时候直接求$\frac { 1  } { 2 ^N  } \sum ( 1 + x ) ^k ( 1 - x ) ^{ m - k  } $即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:$( 0 , 1 ) $和$( 2 ^u + 2 ^v , x ) $,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个$i $求$k $,也就是对于每个$i $求有多少条边满足$| i \land ( 2 ^u + 2 ^v ) | = 1 $,也就是求有多少条边一段链接在了$i $的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-c-loves-3-iii">Example3(CF1034E Little C Loves 3 III)</span></h5><p>仍然是子集卷积,转化为$c _i = \sum _{ j  } \sum _{ k  } [ | j | + | k | = | i | , j \lor k = i ] a _j b _k \ $.然后我们将$a _j $乘上$4 ^j $,将$b _k $乘上$4 ^k $,最后把$c _i $除去$4 ^i $对$4 $取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2-chiori-and-doll-picking">Example4(CF1336E2 Chiori and Doll Picking)</span></h5><p>先考虑easy version.首先求出线性基,如果线性基的大小$k $比较小,我们可以直接$2 ^k $枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个$1 $取决于选了多少个元素,其他位置共有$m - k $个,可以直接状压进状态.这样复杂度就是$O ( \min \{ 2 ^k , m ^2 2 ^{ m - k  } \} ) $.</p>
<p>那么我们怎么优化呢?首先$k $较大的时候有点难做,我们看看能不能优化到$2 ^{ m - k  } $.</p>
<p>考虑设$f _i ^c = [ | i | = c ] $,将线性基能做出的线性空间设为$A $,$A _S = 1 $当且仅当线性基能异或出$S $(最后再把那些废元素贡献到答案里).那么$popcount = c $的答案就是$IFWT ( FWT ( F ) FWT ( A ) ) _0 $.考虑$IFWT _0 = \frac { 1  } { 2 ^m  } \sum _{ i = 0  } ^{ 2 ^m - 1  } FWT ( F ) _i FWT ( A ) _i $,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:$FWT ( A ) $要么是$2 ^k $,要么是$0 $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
A * A = A \times 2 ^k</script><p>这句是为啥呢?因为对于右边的每一个数字$x $和左边的一个数字$y $,如果它们都在线性基中,一定存在一个数字$z $满足$y \oplus z = x $,不然就是$0 $.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) _i \cdot FWT ( A ) _i & = FWT ( A ) _i \times 2 ^k \\
FWT ( A ) _i & = 0 \lor 2 ^k 
\end{aligned}</script><p>引理2:$FWT ( A ) _i = 2 ^k \Leftrightarrow \forall x , A _x \ne 0 , | i \land x | \equiv 0 \pmod { 2  } $.</p>
<p>直接展开上面的式子,用$\sum _{ S \subseteq T  } ( - 1 ) ^{ | S |  } = [ T = \emptyset ] $.</p>
<p>引理3:$FWT ( A ) $中值为$2 ^k $的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果$i $满足条件,$j $满足条件,一开始做FWT时我们已经注意到:$( i \oplus j ) \land x = ( i \land x ) \oplus ( j \land x ) $.于是这个引理也显然成立.</p>
<p>引理4:$FWT ( A ) $中值为$2 ^k $的位置构成的线性基的大小是$m - k $.</p>
<p>设这些位置构成的空间是$B $,$B _S = 1 $当且仅当$S $在这个空间中.我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT ( A ) & = B \times 2 ^k \\
A & = IFWT ( B ) \times 2 ^k 
\end{aligned}</script><p>注意到$a _0 = 1 $,也就是$\frac { 2 ^k  } { 2 ^m  } \sum b = 1 , \sum b = 2 ^{ m - k  } $,这就证明了引理.</p>
<p>引理5:将$A $的线性基对应的矩阵从前往后消成最简,$B $的线性基对应的矩阵从后往前消成最简,上$A $下$B $拼成一个$m \times m $的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据$rank ( A ) + rank ( B ) = k + m - k = m $可以知道主对角线一定全是$1 $,然后我们任取$A $中的一个基$x $和$B $中的一个基$y $,应该有$| x \land y | \equiv 0 \pmod { 2  } $.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由$A $得知$B $长什么样.</p>
<p>引理6:$FWT ( F ^c ) _i $只和$| i | $有关.</p>
<p>因为$F ^c _i $只和$| i | $有关,这里考虑一下对称性就可以.因此设$w _{ d  } ^c = FWT ( F ^c ) _i , | i | = d $.</p>
<p>然后注意到$w _d ^c = \sum _{ i = 0  } ^{ 2 ^m - 1  } ( - 1 ) ^{ | i \land ( 2 ^d - 1 ) |  } [ | i | = c ] $.组合意义展开一下:</p>
<script type="math/tex; mode=display">
w _d ^c = \sum _{ j = 0  } ^{ d  } ( - 1 ) ^{ j  } \binom { d  } { j  } \binom { m - d  } { c - j  }</script><p>接下来怎么做呢?令$g _d = \sum _{ i = 0  } ^{ 2 ^m - 1  } [ A _i = 1 ] [ | i | = d ] $,这里可以$O ( 2 ^{ m - k  } ) $,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5><p>首先发现”如果没有边那么是$0 $”这个限制太强了,如果我们能改为”如果是$0 $,那么可有边可无边”的话,整个序列就会被$1 $的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设$g _{ len , S  } $表示长度为$len $,一段长度为$len - 1 $的连续的$1 $对应的集合是$S $的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个$0 $).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5><p>首先可以类似数位dp设计一个$dp _{ i , S  } $表示目前dp到了第$i $位,然后前面的$limit $是$S $.接下来分类讨论当前的最大值限制是$1 $还是$0 $.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2><h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3><h4><span id="概念">概念</span></h4><p>我们定义一个幂级数形如$A ( z ) = \sum _{ k \geq 0  } a _k z ^k $,并使$[ z ^n ] A ( z ) = a _n $.则称$A ( z ) $是$\langle a _0 , a _1 , . . . \rangle $的生成函数.</p>
<h4><span id="运算">运算</span></h4><ol>
<li><p>$\alpha A ( z ) + \beta B ( z ) = \sum _{ n \geq 0  } ( \alpha f _n + \beta g _n ) z ^n $.</p>
</li>
<li><p>$z ^m A ( z ) = \sum _{ n \geq 0  } g _{ n  } z ^{ n + m  } = \sum _{ n \geq m  } g _{ n - m  } z ^n $.</p>
</li>
<li><p>$A ( cz ) = \sum _{ n \geq 0  } c ^n f _n z ^n $.</p>
</li>
<li><p>$A ‘ ( z ) = \sum _{ n \geq 1  } ig _i z ^{ i - 1  } $.</p>
</li>
<li><p>$\int A ( z ) dz = \sum _{ n \geq 0  } \cfrac { 1  } { n + 1  } g _n z ^{ n + 1  } $.</p>
</li>
<li><p>$A ( z ) B ( z ) = \sum _{ n \geq 0  } ( \sum _{ k = 0  } ^n f _k g _{ n - k  } ) z ^n $.</p>
</li>
<li><p>$\cfrac { 1  } { 1 - z  } A ( z ) = \sum _{ n \geq 0  } ( \sum _{ k = 0  } ^n g _k ) z ^n $.</p>
</li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4><ol>
<li>$\cfrac { 1  } { 1 - z  } = \sum _{ k \geq 0  } z ^k \ $,$\cfrac { 1  } { 1 - cz  } = \sum _{ k \geq 0  } c ^k z ^k \ $.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$( 1 + z ) ^r = \sum _{ k \geq 0  } \binom { r  } { k  } z ^k \ $,$( 1 - z ) ^r = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { r  } { k  } z ^k \ $.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol>
<li>$\cfrac { 1  } { 1 - z ^m  } = \sum _{ n \geq 0  } [ n | m ] z ^n \ $.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$\cfrac { 1  } { ( 1 - z ) ^{ n + 1  }  } = \sum _{ k \geq 0  } \binom { n + k  } { n  } z ^k , n \in \mathbb { N  } \ $,$\cfrac { z ^n  } { ( 1 - z ) ^{ n + 1  }  } = \sum _{ k \geq 0  } \binom { k  } { n  } z ^k , n \in \mathbb { N  } \ $</li>
</ol>
<p>直接使用二项式定理展开$( 1 - z ) ^{ - n - 1  } $,可以得到:</p>
<script type="math/tex; mode=display">
( 1 - z ) ^{ - n - 1  } = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { - n - 1  } { k  } z ^k</script><p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cfrac { 1  } { ( 1 - z ) ^2  } & = \sum _{ n \geq 0  } ( n + 1 ) z ^n \\
\cfrac { z  } { ( 1 - z ) ^2  } & = \sum _{ n \geq 0  } nz ^n 
\end{aligned}</script><p>根据$( 1 ) $求导即可得到此式.</p>
<ol>
<li><p>$e ^z = \sum _{ k \geq 0  } \cfrac { z ^k  } { k !  } \ $.</p>
</li>
<li><p>$\ln ( \cfrac { 1  } { 1 - z  } ) = \sum _{ n \geq 1  } \cfrac { 1  } { n  } z ^n $.</p>
</li>
<li><p>$\ln ( 1 + z ) = \sum _{ k \geq 0  } ( - 1 ) ^k \cfrac { z ^{ k + 1  }  } { k + 1  } \ $.</p>
</li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol>
<li>$\frac { 1 - \sqrt { 1 - 4 x  }  } { 2 x  } = \sum _{ k \geq 0  } \frac { \binom { 2 k  } { k  }  } { k + 1  } x ^k $.</li>
</ol>
<p>也即卡特兰数$C _k $的生成函数,证明考虑:</p>
<script type="math/tex; mode=display">
xC ^2 + 1 = C</script><p>然后得到两个根,带入$x = 0 $舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53079223">https://zhuanlan.zhihu.com/p/53079223</a></p>
<p>序列$\{ a \} $的指数生成函数定义为形式幂级数$\hat F ( x ) = \sum a _n \frac { x ^n  } { n !  } $.注意$[ x ^n ] \hat F ( x ) = a _n $.</p>
<h4><span id="基本运算">基本运算</span></h4><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat F ( x ) \hat G ( x ) & = \sum _{ j \geq 0  } a _j \frac { x ^j  } { j !  } \sum _{ k \geq 0  } b _k \frac { x ^k  } { k !  } \\
& = \sum _{ k \geq 0  } x ^k \sum _{ j = 0  } ^k a _j b _{ k - j  } \frac { k !  } { j ! ( k - j ) !  } \frac { 1  } { k !  } \\
& = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } \sum _{ j = 0  } ^k a _j b _{ k - j  } \binom { k  } { j  } 
\end{aligned}</script><p>即$\lang \sum _{ i = 0  } ^n \binom { n  } { i  } a _i b _{ n - i  } \rang $的EFG.</p>
<p>注意到有一个特例是$x \hat F ( x ) $就是$\lang \binom { n  } { n - 1  } a _i \rang $的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4><ol>
<li>$e ^x = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } $</li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol>
<li>$e ^{ px  } = \sum _{ k \geq 0  } p ^k \frac { x ^k  } { k !  } $</li>
</ol>
<p>换元后可以得到.一个经典特例是$e ^{ - x  } = \sum _{ k \geq 0  } ( - 1 ) ^k \frac { x ^k  } { k !  } $.</p>
<ol>
<li>$\frac { e ^x + e ^{ - x  }  } { 2  } = \sum _{ k \geq 0  } [ 2 | k ] \frac { x ^k  } { k !  } $.</li>
</ol>
<p>显然.</p>
<ol>
<li>$( 1 + x ) ^n = \sum _{ k \geq 0  } n ^{ \underline { k  }  } \frac { x ^k  } { k !  } $.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol>
<li><p>$\ln ( 1 + x ) = \sum _{ k \geq 1  } ( - 1 ) ^{ k - 1  } ( k - 1 ) ! \frac { x ^k  } { k !  } $.</p>
</li>
<li><p>$\ln ( 1 - x ) = \sum _{ k \geq 1  } ( k - 1 ) ! \frac { x ^k  } { k !  } $.</p>
</li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4><p>我们设$F _k ( n ) $为$n $个有标号元素划分成$k $个非空无序集合的情况,$f _i $为$i $个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和$| S | $有关的定义在集合上的函数),有:</p>
<script type="math/tex; mode=display">
F _k ( n ) = \frac { n !  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a _j !  }</script><p>设$\hat { F  } ( x ) = \sum _{ n \geq 0  } f _n \frac { x ^n  } { n !  } $,再设:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat G _k ( x ) & = \sum _{ n \geq 0  } F _k ( n ) \frac { x ^n  } { n !  } \\
& = \sum _{ n \geq 0  } x ^n \frac { 1  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a _j !  } \\
& = \sum _{ n \geq 0  } \frac { 1  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  } x ^{ a _j  }  } { a _j !  } \\
& = \frac { 1  } { k !  } \hat F ^k ( x ) 
\end{aligned}</script><script type="math/tex; mode=display">
\sum _{ k \geq 0  } \hat G _k ( x ) = \exp \hat F ( x )</script><p>或者直接递推:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F _k ( x ) & = \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \frac { 1  } { k  } \\

\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\hat G _k ( x ) & = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } F _k ( n ) \\
& = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \frac { 1  } { k  } \\
& = \frac { 1  } { k  } \sum _{ n \geq 0  } \frac { x ^n  } { n !  } \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \\
& = \frac { 1  } { k  } \hat G _{ k - 1  } ( x ) \hat F ( x ) \\
& = \frac { 1  } { k !  } \hat F ^k ( x ) 
\end{aligned}</script><p>简而言之,$[ x ^n ] \hat F ( x ) $是将$n $个有标号的元素放到同一个无序集合的方案数,而$[ x ^n ] \exp \hat F ( x ) $是将$n $个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1poj3734">Example1(POJ3734)</span></h5><p>对于红黄色砖块,其选取方案为$\{ 1 , 0 , 1 , 0 , \cdots \} $,对应的EGF是$\frac { e ^x + e ^{ - x  }  } { 2  } $.</p>
<p>对于蓝绿色砖块,选取方案是$e ^x $.</p>
<p>乘起来有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat F ( x ) & = ( \frac { e ^x + e ^{ - x  }  } { 2  } ) ^2 e ^{ 2 x  } \\
& = \frac { ( e ^{ 2 x  } + 2 + e ^{ - 2 x  } ) e ^{ 2 x  }  } { 4  } \\
& = \frac { e ^{ 4 x  } + 2 e ^{ 2 x  } + 1  } { 4  } \\
& = \frac { 1  } { 4  } + \sum _{ k \geq 0  } \frac { 4 ^i + 2 ^{ i + 1  }  } { 4  } \frac { x ^i  } { i !  } 
\end{aligned}</script><p>于是有$[ x ^n ] \hat F ( x ) = 4 ^{ n - 1  } + 2 ^{ n - 1  } $.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5><p>长度为$n $的排列数的指数生成函数是$\hat P ( x ) = \sum _{ n \geq 0  } \frac { n ! x ^n  } { n !  } = \frac { 1  } { 1 - x  } $.</p>
<p>长度为$n $的圆排列的指数生成函数是$\hat Q ( x ) = \sum _{ n \geq 0  } \frac { ( n - 1 ) ! x ^n  } { n !  } = \frac { x ^n  } { n  } = - \ln ( 1 - x ) = \ln \frac { 1  } { 1 - x  } $.</p>
<p>于是有$\exp \hat Q ( x ) = \hat P ( x ) $.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5><p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为$1 $的置换环,其EGF显然是$\sum _{ n \geq 2  } \frac { x ^n  } { n  } = - \ln ( 1 - x ) - x $,错排数的EGF对其取$\exp $即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5><p>考虑如果$n $个点带编号的无向连通图的EGF是$\hat F ( x ) $,那么$n $个点带标号无向图的EGF就是$\exp \hat F ( x ) $,后者直接计数,前者对后者做一次$\ln $就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5><p>求有多少个映射$f : \{ 1 , 2 , \cdots , n \} \mapsto \{ 1 , 2 , \cdots , n \} $满足$f \circ f \circ \cdots \circ f $(共$k $个$f $)$= f \circ f \circ \cdots \circ f $(共$k - 1 $个$f $).</p>
<p>考虑将$i \rightarrow f _i $,这等价于对深度不超过$k $的基环树(环的长度为$1 $)计数,等价于对深度不超过$k $的有根树计数.注意到删去根节点后等价于对深度不超过$k - 1 $的有根树计数,因此$\hat F _k ( x ) = x \exp \hat F _{ k - 1  } ( x ) $.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5><p>假设$k $次操作后$a _i $减少了$b _i $,实际上要求的就是$\prod _{ i = 1  } ^n a _i - \prod _{ i = 1  } ^n ( a _i - b _i ) $.</p>
<p>考虑对所有情况下的$\prod _{ i = 1  } ^n ( a _i - b _i ) $求和,注意到$k $次操作,使得$i $出现$b _i $次的方案数是$\frac { k !  } { \prod _{ i = 1  } ^n b _i !  } $.直接设$a _j $的EGF是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat F _{ j  } ( x ) & = \sum _{ i \geq 0  } ( a _j - i ) \frac { x ^i  } { i !  } \\
& = \sum _{ i \geq 0  } a _j \frac { x ^i  } { i !  } - \sum _{ i \geq 1  } \frac { x ^i  } { ( i - 1 ) !  } \\
& = a _j e ^x - xe ^x & = ( a _j - x ) e ^x 
\end{aligned}</script><p>答案就是$[ x ^k ] \prod _{ j = 1  } ^n \hat F _j ( x ) $.</p>
<h5><span id="example7">Example7</span></h5><h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3><p>对于序列$f _n $,定义其DGF为$\tilde { F  } ( x ) = \sum _{ i \geq 1  } \frac { f _i  } { i ^x  } $.注意到若$f $是积性函数,那么$\tilde { F  } ( x ) = \prod _{ p \in prime  } \sum _{ i \geq 0  } \frac { f _{ p ^i  }  } { p ^{ ix  }  } \ $.</p>
<h4><span id="基本运算">基本运算</span></h4><p>对于两个序列$f , g $,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde { F  } ( x ) \tilde { G  } ( x ) & = \sum _{ i  } \sum _{ j  } \frac { f ( i ) g ( j )  } { ( ij ) ^x  } \\
& = \sum _{ i  } \frac { 1  } { i ^x  } \sum _{ d | i  } f ( d ) g ( \frac { i  } { d  } ) 
\end{aligned}</script><h4><span id="封闭式">封闭式</span></h4><ol>
<li>$\epsilon ( x ) = [ x = 1 ] $.</li>
</ol>
<p>显然为$\tilde { E  } ( x ) = 1 $.</p>
<ol>
<li>$I ( x ) = 1 $.</li>
</ol>
<p>其封闭式是黎曼函数$\zeta ( x ) $,事实上,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\zeta ( x ) & = \prod _{ i \geq 1  } \frac { 1  } { i ^x  } \\
& = \prod _{ p \in prime  } \sum _{ i \geq 0  } \frac { 1  } { p ^{ ix  }  } \\
& = \prod _{ p \in prime  } \frac { 1  } { 1 - p ^{ - x  }  } 
\end{aligned}</script><ol>
<li>$\mu ( n ) $.</li>
</ol>
<p>其DGF为$\tilde { M  } ( x ) = \prod _{ p \in prime  } ( 1 - p ^{ - x  } ) $.注意到$\zeta ( x ) \tilde { M  } ( x ) = 1 , \tilde { M  } ( x ) = \frac { 1  } { \zeta ( x )  } $.</p>
<ol>
<li>$id ( n ) = n $.</li>
</ol>
<p>有$\tilde { ID  } ( n ) = \prod _{ i \geq 1  } \frac { i  } { i ^x  } = \prod _{ i \geq 1  } \frac { 1  } { i ^{ x - 1  }  } = \zeta ( x - 1 ) $.</p>
<ol>
<li>$I _k ( n ) = n ^k $.</li>
</ol>
<script type="math/tex; mode=display">
\tilde { I _k  } ( x ) = \prod _{ i \geq 1  } \frac { 1  } { i ^{ x - k  }  } = \zeta ( x - k )</script><ol>
<li>$\varphi ( n ) $.</li>
</ol>
<p>注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde { \Phi  } ( x ) & = \prod _{ p \in prime  } ( 1 + \frac { p - 1  } { p ^x  } + \frac { p ( p - 1 )  } { p ^{ 2 x  }  } + \cdots ) \\
& = \prod _{ p \in prime  } \frac { 1 - p ^{ - x  }  } { 1 - p ^{ 1 - x  }  } \\
& = \tilde { \Phi  } ( x ) & = \frac { \zeta ( x - 1 )  } { \zeta ( x )  } 
\end{aligned}</script><p>也注意到$\tilde { \Phi  } ( x ) I ( x ) = \zeta ( x - 1 ) = \tilde { ID  } ( x ) $.</p>
<ol>
<li>$\sigma _k ( n ) = \sum _{ d | n  } d ^k $.</li>
</ol>
<p>注意到$\sigma _k ( n ) = I _k ( n ) * I _0 ( n ) $,也就是说$\tilde { S  } ( x ) = \zeta ( x - k ) \zeta ( x ) $.</p>
<ol>
<li>$u ( n ) = | \mu ( n ) | $.</li>
</ol>
<p>$\tilde { u  } ( n ) = \frac { \zeta ( n )  } { \zeta ( 2 n )  } $.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5><p>考虑对于$f ( n ) = n ^2 \varphi ( n ) $构造积性函数$g ( n ) , h ( n ) $使得$f * g = h $.</p>
<p>注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde { F  } ( x ) & = \prod _{ p \in prime  } ( 1 + \sum _{ k \geq 1  } \frac { p ^{ 3 k - 1  } ( p - 1 )  } { p ^{ kx  }  } ) \\
& = \prod _{ p \in prime  } \frac { 1 - p ^{ 2 - x  }  } { 1 - p ^{ 3 - x  }  } & = \frac { \zeta ( x - 3 )  } { \zeta ( x - 2 )  } 
\end{aligned}</script><p>也就是$f * I _2 = I _3 $.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3><p>对于复数的阶乘,我们通常定义:</p>
<script type="math/tex; mode=display">
\cfrac { 1  } { z !  } = \lim _{ n \rightarrow + \infin  } \binom { n + z  } { z  } n ^{ - z  }</script><p>同时我们定义$\Gamma ( z + 1 ) = z ! $,有:$( - z ) ! \Gamma ( z ) = \cfrac { \pi  } { \sin ( \pi z )  } $.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<script type="math/tex; mode=display">
\begin{aligned}
z ^{ \underline { w  }  } & = \cfrac { z !  } { ( z - w ) !  } \\
z ^{ \overline { w  }  } & = \cfrac { \Gamma ( z + w )  } { \Gamma ( z )  } 
\end{aligned}</script><p>通过以上我们还可以有二项式系数的定义:</p>
<script type="math/tex; mode=display">
\binom { z  } { w  } = \lim _{ \zeta \rightarrow z , \omega \rightarrow w  } \cfrac { \zeta !  } { \omega ! ( \zeta - \omega ) !  }</script><h3><span id="超几何级数">超几何级数</span></h3><h4><span id="超几何函数">超几何函数</span></h4><p>我们定义超几何函数$F ( a _1 , . . . , a _m ; b _1 , . . . b _n ; z ) = F \left ( \begin{array}{ r |  } a _1 , . . . , a _m \ b _1 , . . . , b _n \end{array} z \right ) = \sum _{ k \geq 0  } \cfrac { z ^k \prod _{ i = 1  } ^m a _i ^{ \overline { k  }  }  } { k ! \prod _{ i = 1  } ^n b _i ^{ \overline { k  }  }  } $.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$\cfrac { 0  } { 0  } = 1 $之类的式子,可以发现当$z = 0 $时任意超几何函数总是$= 1 $.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0 $或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4><h5><span id="合流超几何函数">合流超几何函数</span></h5><p>我们通常把形如$M ( a ; b ; z ) = F \left ( \begin{array}{ r |  } a \ b \end{array} z \right ) = \sum _{ k \geq 0  } \cfrac { z ^k a ^{ \overline { k  }  }  } { b ^{ \overline { k  }  } k !  } $的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<script type="math/tex; mode=display">
F \left ( \begin{array}
{ r |  } 1 \\
1 
\end{array} z \right ) = e ^z</script><p>也即常见生成函数中的$( 6 ) $.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5><p>我们把形如$F \left ( \begin{array}{ r |  } a , b \ c \end{array} z \right ) = \sum _{ k \geq 0  } \cfrac { z ^k a ^{ \overline { k  }  } b ^{ \overline { k  }  }  } { c ^{ \overline { k  }  } k !  } $的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } 1 , 1 \ 1 \end{array} z \right ) = \cfrac { 1  } { 1 - z  } $.</li>
</ol>
<p>即常见生成函数$( 1 ) $.</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } - a , 1 \ 1 \end{array} - z \right ) = ( 1 + z ) ^a $.</li>
</ol>
<p>即常见生成函数$( 2 ) $.</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } a , 1 \ 1 \end{array} z \right ) = \cfrac { 1  } { ( 1 - z ) ^a  } $.</li>
</ol>
<p>即常见生成函数$( 4 ) $.</p>
<ol>
<li>$F \left ( \begin{array}{ r |  } 1 , 1 \ 2 \end{array} - z \right ) = \cfrac { \ln ( 1 + z )  } { z  } $.</li>
</ol>
<p>即常见生成函数$( 7 ) $.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4><p>我们先考虑改写超几何级数的形式:</p>
<p>$F \left ( \begin{array}{ r |  } a _1 , . . . , a _m \ b _1 , . . . , b _n \end{array} z \right ) = \sum _{ k \geq 0  } t _k , t _k = \cfrac { z ^k \prod _{ i = 1  } ^m a _i ^{ \overline { k  }  }  } { k ! \prod _{ i = 1  } ^n b _i ^{ \overline { k  }  }  } $.</p>
<p>不难发现$t _0 = 1 $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cfrac { t _{ k + 1  }  } { t _k  } & = \cfrac { z ^{ k + 1  }  } { z ^k  } \cfrac { k !  } { ( k + 1 ) !  } \cfrac { \prod _{ i = 1  } ^m a _i ^{ \overline { k + 1  }  }  } { \prod _{ i = 1  } ^m a _i ^{ \overline { k  }  }  } \cfrac { \prod _{ i = 1  } ^n b _i ^{ \overline { k  }  }  } { \prod _{ i = 1  } ^n b _i ^{ \overline { k + 1  }  }  } \\
& = \cfrac { \prod _{ i = 1  } ^m ( k + a _i )  } { \prod _{ i = 1  } ^n ( k + b _i )  } \cfrac { z  } { k + 1  } 
\end{aligned}</script><p>换句话说,$\cfrac { t _{ k + 1  }  } { t _k  } $是关于$k $的一个有理函数.而根据代数基本定理,任意$k $的有理函数在$\mathbb { C  } $内都可以分解为以上的形式(如果缺少$k + 1 $项则需要上下同时乘以$k + 1 $以补上).</p>
<p>换句话说,对于一个无穷级数$\sum _{ k \geq 0  } t _k $,我们先将$\cfrac { t _{ k + 1  }  } { t _k  } $表示回超几何函数,设为$F $.</p>
<p>那么有:$\sum _{ k \geq 0  } t _k = t _0 F $.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$\Gamma $函数的定义)来使这些公式全部成立.But who cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5><p>求证:$\sum _{ k \leq n  } \binom { r + k  } { k  } = \binom { r + n + 1  } { n  } \Leftrightarrow F \left ( \begin{array}{ r |  } 1 , - n \ - n - r \end{array} 1 \right ) = \cfrac { r + n + 1  } { r + 1  } , n \in \mathbb { N  } \ $.</p>
<p>首先考虑:</p>
<script type="math/tex; mode=display">
\sum _{ k \leq n  } \binom { r + k  } { k  } = \sum _{ k \geq 0  } \binom { r + n - k  } { n - k  }</script><p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<script type="math/tex; mode=display">
\binom { r + n  } { n  } F \left ( \begin{array}
{ r |  } 1 , - n \\
- n - r 
\end{array} 1 \right ) = \binom { r + n + 1  } { n  }</script><p>两边同时除以$\binom { r + n  } { n  } $得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5><p>通过范德蒙德卷积,不难验证:</p>
<script type="math/tex; mode=display">
F \left ( \begin{array}
{ r |  } a , b \\
c 
\end{array} 1 \right ) = \cfrac { \Gamma ( c - a - b ) \Gamma ( c )  } { \Gamma ( c - a ) \Gamma ( c - b )  } , - b \in \mathbb { N  }</script><p>这个公式的一个特例是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F \left ( \begin{array}
{ r |  } a , - n \\
c 
\end{array} 1 \right ) & = \cfrac { ( c - a ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  }  } & = \cfrac { ( a - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline { n  }  }  } , n \in \mathbb { N  } \\
\sum _{ k \geq 0  } \cfrac { a ^{ \overline { k  }  } ( - n ) ^{ \overline { k  }  }  } { c ^{ \overline { k  }  } k !  } & = \cfrac { ( c - a ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  }  } & = \cfrac { ( a - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline { n  }  }  } , n \in \mathbb { N  } \\

\end{aligned}</script><p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F \left ( \begin{array}
{ r |  } a , b , - n \\
c , a + b - n - c + 1 
\end{array} 1 \right ) & = \cfrac { ( c - a ) ^{ \overline { n  }  } ( c - b ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  } ( c - a - b ) ^{ \overline { n  }  }  } & = \cfrac { ( a - c ) ^{ \underline { n  }  } ( b - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline { n  }  } ( a + b - c ) ^{ \overline { n  }  }  } , n \in \mathbb { N  } \\

\end{aligned}</script><p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3><h4><span id="example1luogu4931">Example1(luogu4931)</span></h4><p>二项式反演:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans _k & = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } { k  } \binom { n  } { i  } \binom { n  } { i  } i ! ( 2 n - 2 i ) ! 2 ^i \\
& = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { k ! ( i - k ) !  } \frac { n !  } { ( n - i ) !  } \frac { n !  } { ( n - i ) !  } ( 2 n - 2 i ) ! 2 ^i \\
& = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { ( i - k ) !  } \binom { 2 n - 2 i  } { n - i  } 2 ^{ i - k  } \\
& = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  } 
\end{aligned}</script><p>注意到后者只与$n - k $有关,不妨设其为$f _{ n  } = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  } $,预处理一下就可以做到$O ( n ^2 + nT ) $.</p>
<p>加强版咋做?我们继续看看式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans & = ( n ! ) ^2 \frac { 2 ^k  } { k !  } f _{ n - k  } \\
f _{ n  } & = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  } 
\end{aligned}</script><p>注意到$f $是一个卷积的形式,设其生成函数为$F _n $,$g _n = \frac { ( - 2 ) ^n  } { n !  } , h _n = \binom { 2 n  } { n  } $,我们自然有$F = GH $.</p>
<p>考虑$G $和$H $的生成函数形式,先看$G $,显然用泰勒展开:</p>
<script type="math/tex; mode=display">
G = \sum _{ n \geq 0  } \frac { ( - 2 x ) ^n  } { n !  } = e ^{ - 2 x  }</script><p>再看$H $,是卡特兰数的生成函数,有:</p>
<script type="math/tex; mode=display">
H = \frac { 1  } { \sqrt { 1 - 4 x  }  }</script><p>这下简单了,答案是:</p>
<script type="math/tex; mode=display">
( n ! ) ^2 \frac { 2 ^k  } { k !  } [ x ^{ n - k  } ] \frac { e ^{ - 2 x  }  } { \sqrt { 1 - 4 x  }  }</script><p>现在看$F $,平方一下有:</p>
<script type="math/tex; mode=display">
( 1 - 4 x ) F ^2 = e ^{ - 4 x  }</script><p>两边求导:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F ' & = - 4 e ^{ - 4 x  } \\
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F ' & = - 4 ( 1 - 4 x ) F ^2 \\
( 2 - 8 x ) F ' & = 16 xF \\

\end{aligned}</script><p>得到了一个线性递推形式,更进一步地:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ( i + 1 ) f _{ i + 1  } - 8 if _i & = 16 f _{ i - 1  } \\
if _i & = 4 ( i - 1 ) f _{ i - 1  } + 8 f _{ i - 2  } 
\end{aligned}</script><p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3><h4><span id="求解递归关系">求解递归关系</span></h4><p>我们假设已经有了$R ( z ) = \sum _{ k \geq 0  } g _k z ^k $,并且$R ( z ) = \cfrac { P ( z )  } { Q ( z )  } $,其中$P ( z ) $和$Q ( z ) $都是多项式,我们想要找到一种方式求解$[ z ^n ] R ( z ) $.</p>
<p>考虑有理函数$S ( z ) = \sum _{ k = 1  } ^m \cfrac { a _k  } { 1 - \rho _k z  } \ $,不难发现$[ z ^n ] S ( z ) = \sum _{ k = 1  } ^m a _k \rho _k ^n \ $.</p>
<p>那么可以证明,只要$Q ( z ) = 0 $无重根并且无零根,那么就存在一组系数满足$S ( z ) = R ( z ) $.</p>
<p>我们这么定义”反射”运算,若$Q ( z ) = \sum _{ k = 0  } ^m q _k z ^k \ $,则其反射多项式为$Q ^R ( z ) = \sum _{ k = 0  } ^m q _k z ^{ m - k  } \ $.</p>
<p>若$Q ( z ) = q _0 \prod _{ k = 1  } ^m ( 1 - \rho _k z ) $,则显然有$Q ^R ( z ) = q _0 \prod _{ k = 1  } ^m ( z - \rho _k ) \ $.</p>
<p>那么显然这里求出来的这组数$\rho $就是$S ( z ) $中的那组$\rho $.</p>
<p>而我们有$a _k = \cfrac { - \rho _k P ( \cfrac { 1  } { \rho _k  } )  } { Q ‘ ( \rho _k )  } $.</p>
<h4><span id="example1">Example1</span></h4><p>已知$n ! = \sum _{ k  } \binom { n  } { k  } g _{ n - k  } , n \in \mathbb { N  } \ $,求$g _n $.</p>
<p>首先两边同时除以$n ! $并将组合数用阶乘形式展开,我们有:</p>
<script type="math/tex; mode=display">
1 = \sum _{ k  } \cfrac { g _{ n - k  }  } { k ! ( n - k ) !  } .</script><p>如果我们令$D ( z ) = \sum _{ k \geq 0  } \cfrac { g _{ k  }  } { k !  } z ^k $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cfrac { 1  } { 1 - z  } & = e ^z D ( z ) \\
D ( z ) & = \cfrac { 1  } { 1 - z  } e ^{ - z  } \\
D ( z ) & = ( \sum _{ k \geq 0  } z ^k ) ( \sum _{ k \geq 0  } ( - 1 ) ^k \cfrac { z ^k  } { k !  } ) \\
[ z ^n ] D ( z ) & = \sum _{ k = 0  } ^n \cfrac { ( - 1 ) ^k  } { k !  } 
\end{aligned}</script><p>于是$g _n = n ! \sum _{ k = 0  } ^n \cfrac { ( - 1 ) ^k  } { k !  } \ $.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4><p>首先设$F _i ( x ) $为第$i $家的生成函数,这个是显然可以快速预处理出来的.令$M = 520 $.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有$n $个多项式,最高次数是$M $,因此一共要插入$nM $个值,又要处理每个后缀,复杂度来到$O ( n ^2 M ^3 ) $.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到$O ( n ^2 M ^2 ) $.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到$O ( n ^2 Mq ) $.但$n $如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下$2 ^n $的答案,复杂度来到$O ( nM 2 ^n q ) $.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到$O ( \frac { n  } { B  } B 2 ^B MnM ) $,单次询问复杂度来到$O ( \frac { n  } { B  } Mnq ) $.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以$k $要大于$m $,就直接输出$0 $.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要$O ( ( nM ) ^2 q ) $的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到$O ( nMq ) $.</p>
<h4><span id="example3十二省联考-2019-皮配">Example3([十二省联考 2019] 皮配)</span></h4><p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为$xy , y , x , 1 $,这样最后判断幂在一个区间内的$x $和$y $前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是$\prod ( x ^{ s _i  } y ^{ s _i  } + x ^{ s _i  } ) + \prod ( y ^{ s _i  } + 1 ) = ( \prod ( x ^{ s _i  } + 1 ) ) ( \prod ( y ^{ s _i  } + 1 ) ) $.也就是$x $和$y $是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于$O ( mk ^2 s ) $.最后两部分合并一下.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" class="post-title-link" itemprop="url">反演与容斥</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="反演">反演</span></h2><p>假设有两个函数$f $和$g $满足:$f ( n ) = \sum _{ k  } a _{ n , k  } g ( k ) $,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( S ) & = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S ) & = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
f ( S ) & = \sum _{ S \subseteq T \subseteq U  } g ( T ) \Leftrightarrow g ( S ) & = \sum _{ S \subseteq T \subseteq U  } ( - 1 ) ^{ | T | - | S |  } f ( T ) 
\end{aligned}</script><p>证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( S ) & = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
& = ( - 1 ) ^{ | S |  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | T |  } \sum _{ P \subseteq T  } g ( P ) \\
& = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T | + | P |  } \\
& = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) ( - 1 ) ^{ | P |  } \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T |  } \\
& = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) [ S & = P ] ( - 1 ) ^{ | P |  } \\
& = g ( S ) 
\end{aligned}</script><p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5><p>根据子集反演,设$cnt _S $为集合为$S $的数量,然后设$f _S = \sum _{ S ‘ \subseteq S  } cnt _{ S ‘  } $,有:$ans = \sum _{ S  } 2 ^{ f _S  } ( - 1 ) ^{ n - | S |  } $.</p>
<p>做一遍高维前缀和就好,复杂度$O ( n 2 ^n ) $,应该也可以用分治FMT无脑做到$O ( n ^2 2 ^n ) $.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5><p>设$f _{ i , j  } $表示$i $个点,其中有$j $个点的入度数为$0 $的方案数.(等一下,为撒子想到要记度数为$0 $的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这$j $个点后,还剩下$k $个零度点.于是自然有:</p>
<script type="math/tex; mode=display">
f _{ i , j  } = \binom { i  } { j  } \sum _{ k = 1  } ^{ i - j  } ( 2 ^j - 1 ) ^k 2 ^{ j ( i - j - k )  } f _{ i - j , k  }</script><p>等一下咧,这复杂度$O ( n ^3 ) $了,这咋办啊?</p>
<p>好像转移优化不太了,因为$k $很难省去(在指数上).但我们注意到我们定义的时候说:$0 $度点的数量恰好为$k $,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少$k $个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设$f ( n , S ) $表示$n $个点,其中只有$S $中的点的入度为$0 $;类似定义$g ( n , S ) $表示$n $个点,至少$S $中的点的入度为$0 $.显然我们所求也就是$g ( n , \emptyset ) $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n , S ) & = 2 ^{ | S | ( n - | S | )  } g ( n - | S | , \emptyset ) \\
g ( n , S ) & = \sum _{ S \subseteq T  } f ( n , T ) 
\end{aligned}</script><p>对第二个式子用子集反演,有:</p>
<script type="math/tex; mode=display">
f ( n , S ) = \sum _{ S \subseteq T  } ( - 1 ) ^{ | T | - | S |  } g ( n , T )</script><p>接下来使用反复带入大法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n , \emptyset ) & = \sum _{ \emptyset \ne T  } f ( n , T ) \\
& = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } g ( n , S ) \\
& = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S | , \emptyset ) \\
& = \sum _{ m = 1  } ^n \sum _{ | T | = m  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S | , \emptyset ) \\
& = \sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \\

\end{aligned}</script><p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \\
& = \sum _{ k = 1  } ^n \sum _{ m = 1  } ^k \binom { n  } { m  } \binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \\
& = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) \sum _{ m = 1  } ^k \binom { k  } { m  } ( - 1 ) ^{ k - m  } \\
& = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) ( ( 1 - 1 ) ^k - ( - 1 ) ^k ) \\
& = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g ( n - k , \emptyset ) ( - 1 ) ^{ k - 1  } \\

\end{aligned}</script><p>注意到复杂度已经降到$O ( n ^2 ) $了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个$( - 1 ) ^{ k - 1  } $,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _n & = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k - 1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}</script><p>也就是直接设,然后钦定其有至少$j $个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = 0  } ^n C _n ^k g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
f ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } f ( k ) \\
f ( n ) & = \sum _{ k = n  } ^N C _k ^n g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _k ^n f ( k ) \\
f ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } f ( k ) \\

\end{aligned}</script><p>显然以$( - 1 ) ^n g ( n ) $代替$g ( n ) $即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
& = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^{ n - m  } ( - 1 ) ^k C _{ n - m  } ^k C _n ^m g ( m ) \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k \sum _{ m = 0  } ^{ n - k  } C _{ n - k  } ^m g ( m ) \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k f ( n - k ) \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\

\end{aligned}</script><h5><span id="example1错排问题">Example1(错排问题)</span></h5><p>$n $个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设$f ( n ) $为$n $个人随便站的方案数,$g ( n ) $为$n $个人都站错的方案数.</p>
<p>如果知道$g $的表达式,我们可以通过枚举有多少人站错位置来得到$f $,即:$f ( n ) = \sum _{ k = 0  } ^n C _n ^k g ( k ) $.</p>
<p>显然就是一个二项式反演,$g ( n ) = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k k ! $.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:$g ( n ) = n ! \sum _{ 0 \leq k \leq n  } \cfrac { ( - 1 ) ^k  } { k !  } \ $.</p>
<p>不难发现$n ! $的后面形如$e ^{ - 1  } $的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \cfrac { n !  } { e  } - n ! \sum _{ k > n  } \cfrac { ( - 1 ) ^k  } { k !  } \\
& = \cfrac { n !  } { e  } - \cfrac { ( - 1 ) ^{ n + 1  }  } { n + 1  } \sum _{ 0 \leq k  } ( - 1 ) ^k \cfrac { ( n + 1 ) !  } { ( k + n + 1 ) !  } 
\end{aligned}</script><p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有$g ( n ) = \lfloor \cfrac { n !  } { e  } + \cfrac { 1  } { 2  } \rfloor + [ n = 0 ] $.</p>
<p>另外,观察$g $关于$f $的表达式,不难求出$g $的递推式:$g ( n ) = ng ( n - 1 ) + ( - 1 ) ^n $.</p>
<p>下面证明$g _n = ( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) $,事实上,右边等于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) \\
& = ( - 1 ) ^{ n - 1  } ( n - 1 ) + ( n - 1 ) \sum _{ k = 0  } ^{ n - 2  } ( ( n - 1 ) ! \frac { ( - 1 ) ^k  } { k !  } + ( n - 2 ) ! \frac { ( - 1 ) ^k  } { k !  } ) \\
& = n ! \sum _{ k = 0  } ^{ n - 2  } \frac { ( - 1 ) ^k  } { k !  } - ( n - 1 ) ( - 1 ) ^n \\

\end{aligned}</script><h5><span id="example2cf1750g">Example2(CF1750G)</span></h5><p>如果没有字典序限制就是经典的二项式反演:考虑能被分为$k $段,说明有$n - k $个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了$x $个数字,$y $个区间,那么钦定$j $对的方案是$\binom { x - y  } { j  } ( x - j ) ! $.然后要乘上前面已经有了的,也就是乘上形如$( 1 + z ) ^k $.这样复杂度$O ( n ^4 ) $.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的$x , y , k $有$O ( 1 ) $种不同的取值,因此不用枚举.这样就是$O ( n ^3 ) $.但是那个多项式乘法也可以规避,考虑最后的答案形如$\sum ( 1 + z ) ^k P _k ( x ) $,我们考虑写成$P _{ n - 1  } ( z ) + = ( 1 + z ) P _n ( z ) $,然后不断这么做,就只需要$O ( n ^2 ) $.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5><p>不妨设至多有$i $行$j $列最小值为$1 $的答案是$f _{ i , j  } $,恰好有$i $行$j $列最小值为$1 $的答案是$g _{ i , j  } $,注意到:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  }</script><p>令$h _{ n , m  } = \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ n , j  } \ $,则$f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } h _{ i , m  } \ $,而$f _{ n , m  } = k ^{ nm  } ( k - 1 ) ^{ NM - nm  } $.做两次二项式反演得到$g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f _{ n , m  } \ne \binom { N  } { n  } \binom { M  } { m  } k ^{ nm  } ( k - 1 ) ^{ NM - nm  } $呢?我们写成子集反演形式看看:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ S , T  } & = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  } g _{ s , t  } \\
f _{ S , T  } & = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } & = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}</script><p>做子集反演:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ S , T  } & = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S | | T |  } \\
h _{ s , T  } & = \sum _{ S \subseteq s  } ( - 1 ) ^{ | s | - | S |  } f _{ S , T  } \\
g _{ s , t  } & = \sum _{ T \subseteq t  } ( - 1 ) ^{ | t | - | T |  } h _{ s , T  } 
\end{aligned}</script><p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g _{ n , m  } $本身就包含了所有$| S | = n , | T | = m $的情况的和,并且在组合数$\binom { m  } { j  } $那里就找到了唯一确定的$f _{ s , t  } $,因此$f _{ n , m  } $是唯一确定的.这意味着这里$f $的$n , m $并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _i & = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k & = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k & = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } { k  } f _i 
\end{aligned}</script><p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  }</script><p>这个问题其实非常显然,我们的$g _{ i , j  } $定义为所有$| S | = i , | T | = j $的答案之和.$f $也是这么定义的,那这个式子就是错的,应该写成:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{ j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }</script><p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M  } $,那此时$g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _k & = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}</script><p>这个定义式就非常良性,$g $是已知的集合,$f $是未知的集合.我们乘上组合数就可以得到对于$f $来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f $的定义改成$f _{ n , m  } = k ^{ nm  } ( k - 1 ) ^{ NM - nm  } $就对了呢?</p>
<p>再看看这个式子:</p>
<script type="math/tex; mode=display">
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  }</script><p>这个式子的右边在干这样一件事:那就是在已知$n $行$m $列的集合的前提下,从中选出$i $行$j $列并求$g $.那么你从哪知道的$n $行$m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ n , m  } & = \binom { N  } { n  } \binom { M  } { m  } \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } { j  } g _{ i , j  } \\
f _{ n , m  } & = \binom { N  } { n  } \binom { M  } { m  } k ^{ nm  } ( k - 1 ) ^{ NM - nm  } 
\end{aligned}</script><p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}</script><p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ‘ _{ i , j  } $为至少有$i $行$j $列不满足条件的方案数,自然有$f ‘ _{ i , j  } = f _{ N - i , M - j  } $.你发现此时一定有:</p>
<script type="math/tex; mode=display">
f ' _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j = m  } ^M \binom { j  } { m  } g ' _{ i , j  }</script><p>最后答案就是$g ‘ _{ 0 , 0  } $.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\
f ( n ) & = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} ( - 1 ) ^{ n - k  } f ( k ) \\
f ( m ) & = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left [ \begin{array}
{ c  } n \\
m 
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) & = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} f ( k ) \\
f ( m ) & = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left \{ \begin{array}
{ c  } n \\
m 
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) & = \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } k \\
m 
\end{array} \right ] f ( k ) \\

\end{aligned}</script><p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} ( - 1 ) ^{ n - k  } & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} \left [ \begin{array}
{ c  } k \\
m 
\end{array} \right ] ( - 1 ) ^{ n - k  } & = [ m & = n ] \\

\end{aligned}</script><p>第一个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ m = 0  } ^n [ m & = n ] g ( m ) \\
& = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( m ) \\
& = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] ( - 1 ) ^{ n - k  } \sum _{ m = 0  } ^k \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} g ( m ) & = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\

\end{aligned}</script><p>第三个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( m ) & = \sum _{ n = m  } ^M [ n & = m ] g ( n ) \\
& = \sum _{ n = m  } ^M \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } n \\
k 
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( n ) \\
& = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m 
\end{array} \right \} f ( k ) \\

\end{aligned}</script><h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3><p>一般形式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ d | n  } g ( d ) \Leftrightarrow g ( n ) & = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\
f ( n ) & = \sum _{ n | d  } g ( d ) \Leftrightarrow g ( n ) & = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\
f ( x ) & = \sum _{ 1 \leq d  } g ( d ) \Leftrightarrow g ( x ) & = \sum _{ 1 \leq d  } f ( \cfrac { x  } { d  } ) \mu ( d ) 
\end{aligned}</script><p>第一个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ m | n  } [ \frac { n  } { m  } & = 1 ] g ( m ) \\
& = \sum _{ m | n  } \sum _{ d | \frac { n  } { m  }  } \mu ( d ) g ( m ) \\

\end{aligned}</script><p>注意到$[ d | \frac { n  } { m  } ] = [ md | n ] = [ m | \frac { n  } { d  } ] \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ d | n  } \mu ( d ) \sum _{ m | \frac { n  } { d  }  } g ( m ) \\
& = \sum _{ d | n  } \mu ( d ) f ( \frac { n  } { d  } ) \\
& = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\

\end{aligned}</script><p>第二个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ n | d  } [ \frac { d  } { n  } & = 1 ] g ( d ) \\
& = \sum _{ n | d  } \sum _{ c | \frac { d  } { n  }  } \mu ( c ) g ( d ) \\
& = \sum _{ c | d  } \sum _{ nc | d  } \mu ( c ) g ( d ) \\
& = \sum _{ c  } \mu ( c ) f ( nc ) \\
& = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\

\end{aligned}</script><p>第三个式子的证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 1 \leq d  } g ( \cfrac { x  } { d  } ) \mu ( d ) & = \sum _{ d \geq 1  } \mu ( d ) \sum _{ k \geq 1  } f ( \cfrac { x  } { kd  } ) \\
& = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d , k \geq 1  } [ m & = dk ] \mu ( d ) \\
& = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d | m  } \mu ( d ) \\
& = f ( x ) 
\end{aligned}</script><h4><span id="example1">Example1</span></h4><p>求长度为$n $且仅包含小写英文字母且循环节长度恰为$n $的字符串个数.</p>
<p>不妨设$f ( n ) $表示长度为$n $的字符串个数,$g ( n ) $表示长度为$n $且循环节长度恰为$n $的字符串个数.</p>
<p>有$f ( n ) = \sum _{ d | n  } g ( d ) $,根据莫比乌斯反演,$g ( n ) = \sum _{ d | n  } \mu ( \cfrac { n  } { d  } ) f ( d ) $.</p>
<h4><span id="example2">Example2</span></h4><p>求$\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) \ $.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) & = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m id [ gcd ( i , j ) ] \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  } \varphi ( d ) \\

\end{aligned}</script><h5><span id="交换枚举顺序">交换枚举顺序</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  } \varphi ( d ) & = \sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) \\

\end{aligned}</script><h5><span id="分离无关变量">分离无关变量</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) & = \sum ^{ \min ( n , m )  } _{ d = 1  } \varphi ( d ) \times \lfloor \cfrac { n  } { d  } \rfloor \times \lfloor \cfrac { m  } { d  } \rfloor \\

\end{aligned}</script><p>考虑使用数论分块,只需处理出$\varphi ( d ) $的前缀和即可在$O ( \sqrt { n  } + \sqrt { m  } ) $的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4><p>求$\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) = 1 ] \ $.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从$id $变为了$\epsilon $.</p>
<h4><span id="example4">Example4</span></h4><p>求$\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ] \ $.</p>
<p>考虑增加枚举量,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ] & = \sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m \sum _{ p \in prime  } [ gcd ( i , j ) & = p ] \\
& = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{ j = 1  } [ gcd ( pi , pj ) & = p ] \\
& = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { p  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { p  } \rfloor  } _{ j = 1  } [ gcd ( i , j ) & = 1 ] \\
& = \sum _{ p \in prime  } \sum _{ d = 1  } ^{ \min ( \lfloor \frac { m  } { p  } \rfloor , \lfloor \frac { n  } { p  } \rfloor )  } \mu ( d ) \lfloor \cfrac { n  } { pd  } \rfloor \lfloor \cfrac { m  } { pd  } \rfloor \\

\end{aligned}</script><p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5><p>考虑设$x = pd $,则变为$\sum _{ x = 1  } ^{ \min ( n , m )  } \sum _{ p \in prime \land p | x  } \mu ( \frac { x  } { p  } ) \lfloor \frac { n  } { x  } \rfloor \lfloor \frac { m  } { x  } \rfloor \ $.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4><p>首先先考虑去掉$lcm $使得式子中只有$i , j , \gcd ( i , j ) $.</p>
<p>显然可以构造函数$f ( x ) = x ^{ c - d  } , g ( x ) = x ^d , h ( x ) = x ^d \ $,然后将题目转化为$\sum _{ j = 1  } ^n f ( gcd ( i , j ) ) g ( i ) h ( j ) x _j \equiv b _i ( \mod p ) \ $.</p>
<p>$\gcd ( i , j ) $很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出$f _r ( n ) $使得$f ( n ) = \sum _{ d | n  } f _r ( d ) \ $,也即$f _r ( n ) = \sum _{ d | n  } \mu ( \cfrac { n  } { d  } ) f ( d ) $.</p>
<p>则原式即:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ j = 1  } ^n \sum _{ d  } [ d | i ] [ d | j ] f _r ( d ) g ( i ) h ( j ) x _j & \equiv b _i ( \mod p ) \\
\sum _{ d | i  } f _r ( d ) \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j & \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \\

\end{aligned}</script><p>令$z _d = \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j \ $,有$\sum _{ d | i  } f _r ( d ) z _d \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \ $.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出$z _d $.</p>
<p>而$z _d = \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j = \sum _{ d | j  } ^n h ( j ) x _j $,可以再次使用莫比乌斯反演求出$h ( j ) x _j $,进而求$x _j $.</p>
<p>无解条件显然是$g _i = 0 \land x _i \ne 0 $.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol>
<li><p>通过增加枚举量消掉$lcm $以及$\gcd $这些难以处理的项.</p>
</li>
<li><p>将$i $与$j $尽量分到式子两边.</p>
</li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p>
</li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4><p>首先注意到一个重要的事实:我们只需要询问所有$\mu ( x ) \ne 0 $的$x $,就可以得到全部信息,而这些$x $的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \bigoplus _{ i \in A  } i [ \gcd ( i , n ) & = 1 ] \\
& = \bigoplus _{ i \in A  } ^c i \sum _{ d | i , d | n  } \mu ( d ) \\

\end{aligned}</script><p>注意到$\sum _{ d | i  } \mu ( d ) = \bigoplus _{ d | i  } | \mu ( d ) | $,于是:</p>
<script type="math/tex; mode=display">
f ( n ) = \bigoplus _{ d | n  } | \mu ( d ) | \bigoplus _{ d | i , i \in A  } i</script><p>接下来只要我们形式上写作$n $,我们就默认$\mu ( n ) \ne 0 $,又令$g ( n ) = \bigoplus _{ n | i , i \in A  } i $,此时自然有$f ( n ) = \bigoplus _{ d | n  } g ( d ) \ $.这是一个经典的莫反形式,我们再反演回去就可以得到$g ( n ) = \bigoplus _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) = \bigoplus _{ d | n  } f ( d ) $,也就是说我们可以求得所有的$g ( n ) $,也就是这个集合中所有是$n $的倍数的异或值.</p>
<p>注意一个事实:如果我们设$w ( m ) = \prod _{ p \in prime , p | m  } p $,那么我们就可以按照$w $的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进$A $的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设$S ( n ) = \{ x | w ( x ) = n \} $,又设$h ( n ) = \bigoplus _{ i \in A , i \in S ( n )  } i $.考虑用$g ( n ) $表示$h ( n ) $,我们有:</p>
<script type="math/tex; mode=display">
g ( n ) = \bigoplus _{ n | d  } | \mu ( \frac { d  } { n  } ) | h ( d )</script><p>反演,有$h ( n ) = \bigoplus _{ n | d  } g ( d ) \ $.于是我们可以求得所有的$h ( n ) $了.</p>
<p>现在的问题在于:对于数$n , \mu ( n ) \ne 0 $,我们要在$S ( n ) $中选出若干个数,使得它们的异或和为$h ( n ) $,并且选出的数字总共有$| A | $个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3><p>设$S $为可重集合.</p>
<p>一般形式:定义$\mu ( S ) $,若$S $包含重复元素则为$0 $,否则为$( - 1 ) ^{ | S |  } $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( S ) & = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S ) & = \sum _{ T \subseteq S  } \mu ( S - T ) f ( T ) \\

\end{aligned}</script><p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3><p>一般形式($\omega _n = e ^{ \frac { 2 \pi i  } { n  }  } $):</p>
<script type="math/tex; mode=display">
f _m = \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ mk  } g _k \Leftrightarrow g _m = \frac { 1  } { n  } \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ - mk  } f _k</script><p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3><p>考虑莫比乌斯反演的过程,我们实际上使用的是$[ m | n ] \sum _{ d | \frac { n  } { m  }  } \mu ( d ) = [ n = m ] \ $.</p>
<p>令$c = md $,左边$= \sum _{ c | n  } [ m | c ] \mu ( \frac { c  } { m  } ) = \sum ( [ c | n ] ) ( [ m | c ] \mu ( \frac { c  } { m  } ) ) \ $.</p>
<p>令$A _{ c , n  } = [ c | n ] $,$B _{ m , c  } = [ m | c ] \mu ( \frac { c  } { m  } ) \ $,那我们有$BA = I $.</p>
<p>刚才的过程相当于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Ax & = b \\
x & = Ix \\
x & = ( BA ) x \\
x & = B ( Ax ) \\
x & = Bb \\

\end{aligned}</script><p>无论是二项式反演还是莫比乌斯反演,他们都满足$f ( n ) $所依赖的$g ( k ) $有$k \leq n \ $.</p>
<p>根据上面的情况,我们发现$A $是一个下三角矩阵,$B $是$A ^{ - 1  } $.</p>
<p>现在来推导满足$k \leq n $的一般情况反演:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n ) & = \sum _{ k = 1  } ^n a _{ n , k  } g ( k ) \\

\end{aligned}</script><p>不妨设算子$\mu ( n , m ) $,满足$\sum _{ k = 1  } ^n a _{ n , k  } \mu ( k , m ) = \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k , m  } = [ n = m ] \ $.</p>
<p>即$AB = BA = I \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n ) & = \sum _{ m = 1  } ^n [ n & = m ] g ( m ) \\
& = \sum _{ m = 1  } ^n \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k , m  } g ( m ) \\
& = \sum _{ k = 1  } ^n \mu ( n , k ) f ( k ) \\

\end{aligned}</script><p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c _r & = \sum _{ p , q  } [ f ( p , q ) & = r ] a _p b _q \\

\end{aligned}</script><p>而我们需要把$f $分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2><h4><span id="一般形式">一般形式</span></h4><p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:$\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . . , n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid $.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属$m $个集合$T _1 , . . . , T _m $,而除了这些集合以外的集合,</p>
<script type="math/tex; mode=display">
\begin{aligned}
cnt & = \sum _{ i = 1  } ^m ( - 1 ) ^{ i - 1  } \binom { m  } { i  } \\
& = \binom { m  } { 0  } - \sum _{ i = 0  } ^m ( - 1 ) ^i \binom { m  } { i  } \\
& = 1 - [ m & = 0 ] 
\end{aligned}</script><p>显然,当这个元素被包含的时候,贡献为$1 $,反之贡献为$0 $.</p>
<p>如果我们定义一类在集合上的函数$F ( S ) = \sum _{ p \in S  } F ( p ) $,那么自然也有:</p>
<script type="math/tex; mode=display">
F ( \bigcup _{ i = 1  } ^n S _i ) = \sum _{ T \subseteq \{ 1 , . . . , n \}  } ( - 1 ) ^{ | T | - 1  } F ( \bigcap _{ p \in T  } S _p )</script><p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<script type="math/tex; mode=display">
\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  } ^n \overline { S _i  } \mid</script><p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5><p>考虑不定方程$\sum _{ i = 1  } ^n x _i = m $,和$n $个限制条件$x _i \leq b _i $,其中$m $和$b _i $都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集$U $,以及刻画$U $中元素的$P _i $(条件):</p>
<ol>
<li><p>$U $是满足$\sum _{ i = 1  } ^n x _i = m $的所有非负整数解;</p>
</li>
<li><p>对于每个变量$i $,都对应一个$P _i = [ x _i \leq b _i ] $.</p>
</li>
</ol>
<p>设所有满足$P _i $的解构成集合$S _i $,那么我们需要求解的值就是$\mid \bigcap _{ i = 1  } ^n S _i \mid $.而$\mid U \mid $显然是$\binom { m + n - 1  } { n - 1  } $.我们有:$\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  } ^n \overline { S _i  } \mid $.考虑对$\mid \bigcup _{ i = 1  } ^n \overline { S _i  } \mid $使用容斥原理,注意到$\overline { S _i  } $的意义是满足$x _{ i  } \geq b _{ i  } + 1 $的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5><p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集$U $,以及刻画$U $中元素的$P _i $(条件):</p>
<ol>
<li><p>$U $是长度为$n $的所有排列;</p>
</li>
<li><p>对于每个变量$i $,都对应一个$P _i = [ p _i \ne i ] $.</p>
</li>
</ol>
<p>注意到所求仍然是$\mid \bigcap _{ i = 1  } ^n S _i \mid $.于是我们仍然试图$| \bigcap _{ k = 1  } ^m \overline { S _{ a _k  }  } | $.考虑其意义,也即:有$m $个位置被确定了,而其它位置没有限制,于是$| \bigcap _{ k = 1  } ^m \overline { S _{ a _k  }  } | = \binom { n  } { m  } ( n - m ) ! $.根据容斥,自然有:$d _n = n ! - \sum _{ m = 1  } ^n ( - 1 ) ^{ m - 1  } \binom { n  } { m  } ( n - m ) ! = n ! \sum _{ m = 0  } ^n \cfrac { ( - 1 ) ^m  } { m !  } $.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5><p>首先可以用dp+双指针得到$f _i $表示勒令$i $对满足条件的方案数.把$k $的定义改为恰好$k $对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U $,以及刻画$U $中元素的$P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a $对的方案会被恰好$b $对的方案计算$\binom { b  } { a  } $次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为$k $的方案贡献为$1 $,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为$k + 1 $的方案贡献为$0 $,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令$ans = f _k $,第二步除去其中被多算的$k + 1 $,这一步令$ans - = \binom { k + 1  } { k  } f _{ k + 1  } $.这个时候,我们再考虑$k + 2 $的贡献:它将在$f _k $时贡献$\binom { k + 2  } { k  } $次,在$f _{ k + 1  } $时贡献$- \binom { k + 2  } { k + 1  } \binom { k + 1  } { k  } = - \binom { k + 2  } { k  } \binom { 2  } { 1  } $次,那它现在的贡献还有:$- \binom { k + 2  } { k  } $次.以此类推,可以得到$ans = \sum _{ i = k  } ^n f _i ( - 1 ) ^{ i - k  } \binom { i  } { k  } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P _i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i $,因为只有这个时候,我们才能通过分析满不满足$P _i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1 / 0 $就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5><p>如果直接对于每次询问暴力做,复杂度显然是$O ( 4 ns ) $,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画$P _i = [ use _i \leq d _i ] $,从而可以用容斥做.复杂度$O ( 4 m + n 2 ^4 ) $.</p>
<h5><span id="example5">Example5</span></h5><p>Alice和Bob在玩游戏,他们有一个$n $个点的无向完全图,设所有的边组成了集合$E $,他们想取遍$E $的所有非空子集,对某个集合$S $有一个估价$f ( S ) $:考虑$n $个点与$S $中的边组成的图,我们用$m $种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么$f ( S ) $等于这个图的染色方案数.同时,Alice喜欢奇数,所以当$| S | $为奇数时,Alice的分值加上$f ( S ) $,否则Alice的分值减去$f ( S ) $,求最后的分值.$( n , m \leq 10 ^6 ) $.</p>
<p>一开始抄题的时候没有写染色而是直接写”设$k $为连通块个数,则$f ( S ) = m ^k $.”然后发现做不了,因为$| S | $相同的$f ( S ) $不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个$m $,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那$x \leftrightarrow y \Rightarrow col _x = col _y $.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与$- 1 $有关的单位元素(从一开始就是点)和与$f $有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令$F ( C ) $表示在$C $情况下的染色方案,$T _{ ( i , j )  } $表示满足边$( i , j ) $限制的解集:</p>
<script type="math/tex; mode=display">
ans = \sum _{ \emptyset \ne S \subseteq E  } ( - 1 ) ^{ | S | - 1  } F ( \bigcap _{ ( i , j ) \in S  } T _{ ( i , j )  } )</script><p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出$ans $的意义:显然是$F ( \bigcup _{ i = 1  } ^{ m  } P _i ) $.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是$m ^n - m ^{ \underline { n  }  } $.</p>
<h5><span id="example6">Example6</span></h5><p>求$\varphi ( n ) $.</p>
<p>考虑这么一个事实:假设$n = \prod p _i ^{ q _i  } $,注意到令$P _i = [ \gcd ( i , n ) = 1 ] $,我们所求也就是$\mid \bigcap _{ i = 1  } ^n S _i \mid $.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5><p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如$ABCABCAB . . . $这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于$3 $并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5><p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的$1 $,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是$\sum _{ i = 0  } ^{ \min ( n , m )  } ( - 1 ) ^i \binom { n  } { i  } \binom { m  } { i  } i ! ( m + 1 ) ^{ n - i  } ( n + 1 ) ^{ m - i  } $.</p>
<h5><span id="example9">Example9</span></h5><p>给定若干个限制条件$( x , y ) $,表示$a _x = y $和$a _y = x $必须满足至少一个,求排列方案数.</p>
<p>首先$i \rightarrow p _i $把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为$2 $的链,它自己成环的话是不用$\times 2 $的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是$\times 2 $,所以一个有$1 $个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为$2 $的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-square-constraints">Example10([AGC036F] Square Constraints)</span></h5><p>由题意得:$n ^2 - i ^2 \leq P _i ^2 \leq ( 2 n ) ^2 - i ^2 $.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为$l _i $,那么只有上界的答案应该是什么呢?将$l $从小到大排序,答案就是$\prod _{ i = 0  } ^{ 2 n - 1  } ( l _i - i ) $.(注意到必须满足$l _{ 2 n - 1  } = 2 n - 1 $.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个$\frac { 1  } { 4  } $的圆弧.而通过圆弧的性质不难看出:最终的$l $分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道$l $按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照$l $的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度$O ( n ^3 ) $.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5><p>(下面将$n $和$m $反着写)</p>
<p>设$p = \frac { 2 k  } { n  } , q = n - p $.</p>
<p>首先注意到期望$= P [ len \geq 1 ] + P [ len \geq 2 ] + \cdots $.</p>
<p>考虑如何计算$P [ len \geq x ] $,如果我们设$a _i $表示以$i $作为开头的极长的带劲的长度大于等于$x $的序列的集合,那么最后无非是要求所有$a $的并.考虑用容斥做到求所有$a $的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5><p>给定$n , k $和$n $个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过$k $.$n \leq 300 $.</p>
<p>著名结论:$n $个点$m $个连通块任意连边成树的方案数是$n ^{ m - 2  } \prod s $,其中$s $是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过$k $,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于$k $的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过$k $,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数$( - 1 ) ^{ 块 数 - 1  } $.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4><p>对于:</p>
<script type="math/tex; mode=display">
\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . . , n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid</script><p>考虑一个特例:$S _i = \{ 1 , 2 , \cdots , a _i \} $,那么上面的式子导出min-max容斥(我们设$S = \{ a _1 , a _2 , \cdots , a _n \} $)(第二个式子可以把前缀改成后缀):</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max ( S ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } \min ( T ) \\
\min ( S ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } \max ( T ) 
\end{aligned}</script><p>由于是集合,这个式子在期望意义下同样成立:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( \max \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E ( \max \{ S \} ) 
\end{aligned}</script><p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<script type="math/tex; mode=display">
\begin{aligned}
kth \max \{ S \} & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \min \{ T \} \\
kth \min \{ S \} & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \max \{ T \} \\
E ( kth \max \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E ( \min \{ T \} ) \\
E ( kth \min \{ S \} ) & = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E ( \max \{ T \} ) 
\end{aligned}</script><p>原理是消掉前$k - 1 $大的数字,让他们的贡献为$0 $,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5><p>不妨设$tim _i $为$[ i , i + 1 ] $第一次被覆盖的时间,答案就是:</p>
<script type="math/tex; mode=display">
E ( \max _{ i = 1  } ^{ n - 1  } \{ tim _i \} ) = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E ( \min _{ j \in T  } \{ tim _j \} )</script><p>设$f ( S ) $为有多少个区间能覆盖至少一个$[ i , i + 1 ] , i \in S $,考虑$E = p _{ [ t \geq 0 ]  } + p _{ [ t \geq 1 ]  } + p _{ [ t \geq 2 ]  } + \cdots $,于是$E ( \min _{ j \in S  } \{ tim _j \} ) = \frac { m  } { f ( S )  } $.</p>
<p>于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans & = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } f ( T ) \\
& = \sum _{ k = 0  } ^m \frac { m  } { k  } \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k  } ( - 1 ) ^{ | T | - 1  } 
\end{aligned}</script><p>注意到$f ( S ) $可能不那么好求,我们求$g ( S ) = m - f ( S ) $,也就是不包含任何一个$[ i , i + 1 ] , i \in S $的区间个数,我们有:</p>
<script type="math/tex; mode=display">
ans = \sum _{ k = 0  } ^m \frac { m  } { m - k  } \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k  } ( - 1 ) ^{ | T | - 1  }</script><p>这里已经不难写出$O ( n ^3 ) $的dp了.</p>
<p>那么怎么优化呢?设$dp _{ i , j  } $表示只考虑$[ 1 , i ] $时($[ i - 1 , i ] $必选),$\sum _{ g ( T ) = j  } ( - 1 ) ^{ | T | - 1  } $的答案,不难发现每次加入一个区间$[ l , r ] $就会让$dp _{ i , j  } , i &lt; = l $对$dp _{ r , j + 1  } $的贡献乘一个$1 $.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度$O ( nm \log n ) $.</p>
<h4><span id="反射容斥">反射容斥</span></h4><p>一般形式:给定二维平面上两个点$S $和$T $,其中$T $在$S $的右方,给定两条线$y = a $和$y = b $,每次可以向右上或者右下走一步,求不碰线的从$S $到$T $的方案数.</p>
<p>我们不妨设$A $表示一定碰了一次上界的方案数,$B $表示一定碰了一次下界的方案数,$AB $表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走$- A - B + AB + BA - ABA - BAB . . . $.</p>
<p>考虑设步数为$n $,那显然长度最多为$\cfrac { n  } { a - b  } $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="post-title-link" itemprop="url">博弈论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3><p>$A $和$B $,有$n $颗石子,每次可以取$x $颗,其中$1 \leq x \leq m \ $,求$A $是否能赢.</p>
<p>考虑直接令石子数量为状态,有$SG ( x ) = mex \{ SG ( y ) | \max \{ 0 , x - m \} \leq y \leq x - 1 \} \ $,注意到$SG ( x ) = 0 $当且仅当$x \equiv 0 ( \mod m + 1 ) $.</p>
<p>我们使用数学归纳证明:</p>
<p>当$0 \leq x \leq m $时,显然成立.</p>
<p>而对于$x $,如果$x \equiv 0 ( \mod m + 1 ) \ $,那么集合$S = \{ y \in \mathbb { Z  } | \max \{ 0 , x - m \} \leq y \leq x - 1 \} $中一定$\nexists y $满足$y \equiv 0 ( \mod m + 1 ) \ $.</p>
<p>也就是$\nexists y $满足$SG ( y ) = 0 $,那么$SG ( n ) = 0 $.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3><p>$A $和$B $,有$n $堆石子,第$i $堆石子有$x _i $个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果$x $均等于$0 $一定先手必败.考虑令$w = x _1 \oplus x _2 \oplus . . . \oplus x _n $($w $即为全游戏的$SG $值),那么先手必败当且仅当$w = 0 \ $.</p>
<p>证明:</p>
<p>只需证明当$w \ne 0 $时一定存在一种方法使得$w = 0 \ $.</p>
<p>考虑$w $的最高位为第$k $位,那么一定存在一个$x _i $的第$k $位为$1 $.将它改为$0 $,然后这个$x _i $的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4><p>$A $和$B $,有$n $堆石子,第$i $堆石子有$x _i $个石子.每次可以任选不超过$k $堆取走若干个石子,最后不能取的人输.</p>
<p>将$x _i $写成二进制,如果每一位的$1 $的个数均是$k + 1 $的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4><p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于$2 $的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p>$SG ( x ) = mex \{ \{ SG ( v ) | x \rightarrow v \} , \{ SG ( x - i ) \oplus SG ( i ) | 1 \leq i &lt; x \} \} \ $.</p>
<p>找一下规律可以发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
SG ( x ) & = \begin{cases}
x - 1 & x \equiv 0 ( \mod 4 ) \\
x & x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 & x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}</script><p>不妨设当$x \leq 4 k $时结论成立.</p>
<p>当$x = 4 k + 1 $时,前半部分一定是取遍了$[ 1 , 4 k ] $.</p>
<p>但是一定不存在$a $和$b $满足$a + b = 4 k + 1 $并且$SG ( a ) \oplus SG ( b ) = 4 k + 1 $.讨论一下$a $和$b $在$\mod 4 $意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3><p>$n $个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.$A $和$B $每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用$SG ( u ) = mex \{ SG ( v ) | u \rightarrow v \} $.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是$0 $.</p>
<p>首先如果$SG ( u ) = x $,那么$\forall 0 \leq y &lt; x $,$\exists v $使得$u \rightarrow v $且$SG ( v ) = y $.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能$\exists y &gt; x $,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个$u ‘ $使得$SG ( u ‘ ) = x $,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4><p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol>
<li><p>游戏的SG函数不为$0 $且游戏中某个单一游戏的SG函数大于$1 $.</p>
</li>
<li><p>游戏的SG函数为$0 $且游戏中没有单一游戏的SG函数大于$1 $.</p>
</li>
</ol>
<p>如果没有单一游戏的SG函数大于$1 $,那么显然游戏的SG函数为$0 $就赢了,否则就输了.</p>
<p>而如果SG函数为$0 $且存在某个单一游戏的SG函数大于$1 $,一定是输的.</p>
<p>因为这个情况下,后手先按照正常$SG $游戏压着先手,最后一定会剩两堆一样大于$1 $的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4><p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在$DAG $上dp的时候除了$SG $我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4><p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4><p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:$SG ( u ) = \bigoplus _{ u \rightarrow v  } ( SG ( v ) + 1 ) $.</p>
<p>考虑归纳假设.如果$u $只有$v $一个儿子.那么要么将$v $子树全删,要么删一部分,有:</p>
<script type="math/tex; mode=display">
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 < SG ( v ) ) = SG ( v ) + 1</script><p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的$SG $为$0 $,而显然$SG $图中的其它节点的$SG $均要$+ 1 $.</p>
<h4><span id="example4">Example4</span></h4><p>$n $个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环$SG = 1 $,偶环$SG = 0 $.</p>
<p>这么考虑:边数为$k $的链的$SG $为$k $.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到$1 $.偶环同理,不可能得到$0 $.</p>
<h4><span id="example5">Example5</span></h4><p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,$SG $值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3><p>一个数$N $,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当$N $是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当$N $是斐波那契数时必败,不妨假设$N = N _0 + N _1 $,</p>
<p>考虑将$N $看成两堆,因为如果第一次取走了大于$N _1 $颗石子,由于$N _0 \leq N _1 \ $,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在$N _0 $堆取石子,原因是如果取了大于$N _0 $颗石子,由于$N = N _0 + N _1 \leq 3 N _0 \ $.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取$N _0 $这一堆,如果在这一堆取的过程中,先手一直取得不超过$N _0 $剩下的数,那么根据归纳假设,后手一定可以取走$N _0 $堆的最后一个石子,此时局面变成了只剩$N _1 $颗石子.只要此时先手不能一次取走$N _1 $颗石子,先手就必败.而后手最后一步拿走石子最多会拿走$\frac { 2  } { 3  } N _0 $的石子,但是,$\frac { 4  } { 3  } N _0 &lt; N _1 $,因此一定不可能.</p>
<p>否则,仍然是先手取走了$N _0 $全部石子,又当了先手取$N _1 $的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设$N = \sum _{ i = 1  } ^k f _{ p _i  } $,其中$p _1 &lt; p _2 &lt; p _3 &lt; . . . &lt; p _k \ $,先手取走$f _{ p _1  } \ $.由于$2 f _{ p _1  } &lt; f _{ p _2  } $,因此后手接下来无论如何不可能取得大于等于$f _{ p _2  } \ $,问题转化为一堆大小为$f _{ p _2  } $的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3><p>给出一张二分图和起点$S $,$A $和$B $轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点$S $,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含$S $,那么$A $只需要每次走到一个和$S $匹配的点即可.$B $无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含$S $的点,与假设不符.</p>
<p>而如果存在一个匹配不包含$S $,如果$A $仍然第一步走到一个和$S $匹配的点那么$B $一定能想办法走到一个不在当前$A $选择的最大匹配中的点而在一个不包含$S $的最大匹配中的点,于是$B $必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4><p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设$dp _{ S , x  } = 0 / 1 $表示目前集合$S $中的所有人都已经离场了,而目前金条在$x $手中,金条会不会被抢.显然,如果$\exists y $满足$dp _{ S \cup \{ x \} , y  } = 0 $,也就是金条在$y $手里不会被抢,那$x $手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与$S $匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果$S $和$x $并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断$S $是否一定在其中,只需要先删去$S $,跑dinic,再在残联网络上加上$S $,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3><h4><span id="example1zr23省选10连-day1-clashmas">Example1(zr[23省选10连 day1] Clashmas)</span></h4><p>注意到删点对树形态的影响,考虑重心</p>
<ol>
<li>$n $为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol>
<li>$n $为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时$n $为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为$S _A $,B的点的集合为$S _B $.以原重心为根建树,设其所有儿子组成的集合为$S _C $,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当$\sum _{ u \in S _A \cap S _C  } siz _u \geq \sum _{ u \in S _B \cap S _C  } siz _u $.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中$siz $最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol>
<li>$n $为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时$n $为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol>
<li>$n $为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol>
<li>$n $为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3><h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5><p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设$f _i $为还剩$i $条蛇的时候能不能吃,那$f _i = 1 $的话,要么$i = 2 $,要么吃完后不是最小的,要么$f _{ i - 1  } = 0 $.</p>
<p>递归做就好了.另外这题需要复杂度$O ( n ) $,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5><p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5><p>首先考虑如果有人作为第$n - p + 1 $个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读$n - p $个人.</p>
<p>继续思考,如果有人作为第$n - 2 p + 1 $个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有$n \mod p $个人复读,并且一定是前$n \mod p $在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5><p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录$f _{ i , j  } $表示当前的$G $是$i $,$G $的倍数还剩下$j $个,然后做转移,再进一步发现我们只关心$j $的奇偶性.于是记$f _{ i , 0 / 1  } $即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5><p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在$[ l _i , r _i ] $,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为$0 $.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为$0 $.</p>
<p>换句话说,我们现在有$x _1 , x _2 , x _3 $,我们要将其中一个$x _i $改为$y _i $,其他不变,使得他们仨异或值为$0 $.和Nim游戏类似,假设他们仨异或值的最高位为$k $.那么一定有一个$x _i $的第$k $位为$1 $,将它改为$0 $,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的$[ l _i , r _i ] $求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5><p>Nim游戏,但是每堆石子有一个$K _i $.如果这堆石子剩$x _i $个每次最多取$\lfloor \frac { x _i  } { K _i  } \rfloor $个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-\lfloor\frac n k\rfloor,k)&amp;n\ne 0(\mod k)\\</p>
<p>\frac n k&amp;n=0(\mod k)\\</p>
<p>\end{cases}\\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于$k $是否大于$\sqrt { n  } $讨论一下,如果$k &lt; \sqrt { n  } $暴力,最多只会做$\sqrt { n  } $次.否则,意识到此时可以通过求一个区间$[ l , r ] $,满足$\forall x \in [ l , r ] , \lfloor \frac { x  } { k  } \rfloor $均相等,加速一下.这种区间最多只会有$\sqrt { n  } $个.</p>
<h5><span id="problem7">Problem7</span></h5><p>一个数$N $,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当$N = 2 ^k $,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5><p>A和B,有$n $颗石子,每次可以取$x $颗,其中$1 \leq x \leq \lceil \frac { n  } { 2  } \rceil \ $.</p>
<p>仍然令石子数量为状态,注意到$SG ( x ) = 0 $当且仅当$x + 1 = 2 ^k - 1 $,也即$x = 2 ^k - 2 \ $.首先,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n - \lceil \frac { n  } { 2  } \rceil & = \lfloor \frac { n  } { 2  } \rfloor \\
SG ( n ) & = mex \{ SG ( y ) | \lfloor \frac { n  } { 2  } \rfloor & \leq y & \leq n - 1 \} \\

\end{aligned}</script><p>设$n = 2 ^k - w $,其中:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- 2 ^{ k - 1  } + 2 & \leq w & \leq 2 \\
\lfloor \frac { 2 ^k - w  } { 2  } \rfloor & = 2 ^{ k - 1  } - \lfloor \frac { w  } { 2  } \rfloor \\

\end{aligned}</script><p>当$w = 2 $时,原式$= 2 ^{ k - 1  } - 1 &gt; 2 ^{ k - 1  } - 2 \ $.反之.$2 ^k - 2 \leq $原式.因此数学归纳即可证明.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">北大相关选拔数学真题汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3><h4><span id="problem4">Problem4</span></h4><p>设$G ( x ) = ( x ^2 + x - 1 ) ^{ 100  } = \sum _{ k = 0  } ^{ 200  } a _k x ^k $,求$2 a _0 - a _1 - a _2 + 2 a _3 - a _4 - a _5 + \cdots + 2 a _{ 198  } - a _{ 199  } - a _{ 200  } $.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑求出$\sum _{ 0 \leq k \leq 66  } { a _{ 3 k  }  } $.直接取三次单位根$\omega _3 = - \frac { 1  } { 2  } + \frac { \sqrt { 3  }  } { 2  } i $,自然有$1 + \omega _3 + \omega _3 ^2 = 0 $,所以$G ( 1 ) + G ( \omega _3 ) + G ( \omega _3 ^2 ) = 3 \sum _{ 0 \leq k \leq 66  } { a _{ 3 k  }  } $.</p>
<p>所以答案显然是$G ( \omega _3 ) + G ( \omega _3 ^2 ) = ( - 2 ) ^{ 100  } + ( - 2 ) ^{ 100  } = 2 ^{ 101  } $.</p>
<h4><span id="problem10">Problem10</span></h4><p>等差数列中,$a _1 &gt; 0 $,公差$d &lt; 0 , \frac { a _{ 31  }  } { a _{ 30  }  } &lt; - 1 $,求最大的正整数$n $,使得$S _n &gt; 0 $.</p>
<h5><span id="solution10">Solution10</span></h5><p>显然$S _{ 60  } = 30 ( a _{ 30  } + a _{ 31  } ) &lt; 0 , S _{ 59  } = 59 a _{ 30  } &gt; 0 $.</p>
<h4><span id="problem11">Problem11</span></h4><p>全为整数的等差数列,$d = 4 $,求所有满足$S _n = 2024 $的$n $的和.</p>
<h5><span id="solution11">Solution11</span></h5><p>则$n ( 2 n - 2 + a _1 ) = 2024 = 2 ^3 \times 11 \times 23 $.显然只要$n | 2024 $即可.</p>
<p>所有$n $的和自然是$( 1 + 2 + 4 + 8 ) ( 1 + 11 ) ( 1 + 23 ) = 15 \times 12 \times 24 = 4320 $.</p>
<h4><span id="problem14">Problem14</span></h4><p>整数数列$U _n $满足$U _0 = 1 $,且当$n \geq 1 $的时候$U _{ n + 1  } U _{ n - 1  } = kU _n $,其中$k $是一个正整数.问能让$U _{ N  } = N $的$k $的个数有多少个,其中$N = 2024 $.</p>
<h5><span id="solution14">Solution14</span></h5><p>则$U _{ n + 1  } = \frac { kU _n  } { U _{ n - 1  }  } , \frac { U _{ n + 1  }  } { U _n  } = k \frac { U _n  } { U _{ n - 1  }  } \frac { 1  } { U _n  } $.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设$T _n = \prod _{ k = 1  } ^n U _k , W _n = U _n \prod _{ k = 1  } ^{ n - 2  } U _k $.</p>
<p>注意到$W _n = kW _{ n - 1  } , W _1 = U _1 , W _n = k ^{ n - 1  } U _1 $.又注意到$T _n = kU _{ n - 1  } W _{ n - 1  } = kW _{ n - 1  } \frac { T _{ n - 1  }  } { T _{ n - 2  }  } = k ^{ n - 1  } U _1 \frac { T _{ n - 1  }  } { T _{ n - 2  }  } = ( k ^{ n - 1  } U _1 ) ( k ^{ n - 2  } U _1 ) \frac { 1  } { T _{ n - 3  }  } $,$T _{ n - 3  } = ( k ^{ n - 4  } U _1 ) ( k ^{ n - 5  } U _1 ) \frac { 1  } { T _{ n - 6  }  } $.所以$T _{ n  } = k ^6 T _{ n - 6  } $,所以$U $存在长度为$6 $的循环节.所以$U _{ N  } = \frac { T _N  } { T _{ N - 1  }  } = \frac { T _2  } { T _1  } = U _2 = kU _1 $.(其实直接暴力找循环节也是可以的)</p>
<p>所以$k $需要是$N $的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设$w = U _1 $,则$U $的前六项是:$1 , w , kw , k ^2 , \frac { k ^2  } { w  } , \frac { k  } { w  } $.要求$kw = N , w | k $,所以$( 11 \times 23 ) | k $,$k \equiv 0 \pmod { 4  } $.所以$k = 4 \times 11 \times 23 $或$k = 8 \times 11 \times 23 $.</p>
<h4><span id="problem15">Problem15</span></h4><p>求使方程$\lfloor \frac { 10 ^n  } { x  } \rfloor = N = 2024 $恰有两个整数解的正整数$n $的个数.</p>
<h5><span id="solution15">Solution15</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N & \leq \frac { 10 ^n  } { x  } & < N + 1 \\
xN & \leq 10 ^n & < x ( N + 1 ) \\
\frac { 10 ^n  } { N + 1  } & < x & \leq \frac { 10 ^n  } { N  } \\
\lfloor \frac { 10 ^n  } { N + 1  } \rfloor & < x & \leq \lfloor \frac { 10 ^n  } { N  } \rfloor \\
\lfloor \frac { 10 ^n  } { N  } \rfloor - \lfloor \frac { 10 ^n  } { N + 1  } \rfloor & = 2 \\
\frac { 10 ^n  } { N ( N + 1 )  } - \frac { 10 ^n \bmod N  } { N  } + \frac { 10 ^n \bmod { ( N + 1 )  }  } { N + 1  } & = 2 
\end{aligned}</script><p>显然$\lfloor \frac { 10 ^n  } { N ( N + 1 )  } \rfloor = 1 , 2 , 3 $.而$N ( N + 1 ) = 4098600 $,所以只有$n = 7 $可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4><p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5><p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是$5 \times 3 ! = 30 $.</p>
<h4><span id="problem19">Problem19</span></h4><p>$f ( x ) = \lfloor 2 x \rfloor + \lfloor 4 x \rfloor + \lfloor 6 x \rfloor + \lfloor 8 x \rfloor , x \in \mathbb { R  } $,求其不超过$n = 2024 $的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5><p>显然$f ( x + 1 ) = f ( x ) + 20 $,因此我们先考虑$x \in [ 0 , 1 ) $的情况.</p>
<p>手动枚举一下知道此时$f ( x ) $有$12 $种不同的取值,前六种是$\{ 0 , 1 , 2 , 4 , 5 , 6 \} $,后六种对应了前六种$+ 10 $.而$2024 = 101 \times 20 + 4 $,所以共有$101 \times 12 - 1 + 4 = 1215 $种取值.</p>
<h4><span id="problem20">Problem20</span></h4><p>从$[ 1 , n ] , n = 2024 $中分别独立随机两个正整数(可以相同)$a , b $,则求$3 ^a + 7 ^b \equiv 8 \pmod { 10  } $的概率.</p>
<h5><span id="solution20">Solution20</span></h5><p>考虑$\varphi ( 10 ) = 4 $,所以原题答案等价于$n = 4 $的时候的答案.在这$16 $中可能性中满足条件的只有三种,概率为$\frac { 3  } { 16  } $.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3><h4><span id="problem3">Problem3</span></h4><p>已知$a _1 = \frac { 5  } { 2  } , a _{ n + 1  } = a _n ^2 - 2 $,求$\lfloor a _n \rfloor \bmod 7 , n = 2023 $.</p>
<h5><span id="solution3">Solution3</span></h5><p>这个一看就不是好解的,想都别想直接数学归纳,注意到$a _n = \frac { 4 ^{ 2 ^{ n - 1  }  } + 1  } { 2 ^{ 2 ^{ n - 1  }  }  } $,那么$\lfloor a _n \rfloor = 2 ^{ 2 ^{ n - 1  }  } $.</p>
<p>而$\varphi ( 7 ) = 6 , \varphi ( 6 ) = 2 $.由扩展欧拉定理,立刻有:$2 ^{ 2 ^{ 2022  }  } \equiv 2 ^{ 2 ^{ 2022  } \bmod 6  } \equiv 2 ^{ 2 ^{ 6  }  } \equiv 16 \equiv 2 \pmod { 7  } $.</p>
<h4><span id="problem4">Problem4</span></h4><p>$50 $个队伍两两打比赛,胜一场积分$+ 1 $,负一场积分不变,无平局.</p>
<p>且任取$27 $支队伍,其中一定有一支队伍负于其它的$26 $支,也一定有一支队伍胜于其它的$26 $支.</p>
<p>问$50 $支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5><p>答案是$50 $.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都$\leq 27 $的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都$&gt; 27 $,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为$k $的简单环,由鸽笼原理,剩下的$n - k $个点中至少有$\frac { n - k  } { 2  } $个点对着$k $个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要$k + \frac { n - k  } { 2  } \geq 27 $即可,此时$k \geq 4 $即可.由于这是竞赛图,显然存在长度为$4 $的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为$u $.我们任意取一个击败过它的点(如果有的话),假设为$v $,再取$25 $个被$u $击败的点(显然这些点存在),设这些点集为$S $.则$u , v , S $组成的集合中,有一个点可以击败其它所有点,根据假设,只能是$v $.由此,可以知道,只要是$u $能击败的点,$v $一定能击败,而且$v $能击败$u $,因此$\deg _v &gt; \deg _u $,与假设不符.因此一定不存在一个$v $可以击败$u $.删掉$u $后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4><p>一只蚂蚁第一天在$( 0 , 0 ) $,第$k + 1 $天向上下左右随机一个方向移动$\frac { 1  } { 4 ^k  } $单位,求第$n $天的可能位置数量,$n = 2023 $.</p>
<h5><span id="solution8">Solution8</span></h5><p>不妨设第$n $天不同位置数量为$S _n $,显然只要前面岔开了,后面永远无法走到一个点.所以$S _1 = 1 , S _{ n + 1  } = 4 S _n , S _{ 2023  } = 4 ^{ 2022  } $.</p>
<h4><span id="problem10">Problem10</span></h4><p>集合$U = \{ 1 , 2 , \cdots , n \} , n = 10 $,求$U $中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5><p>集合是无序的,这个很难搞,我们先从$U $中把$1 $去掉最后再加上.</p>
<p>先考虑可以重复放$1 $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^{ n  } \sum _{ k = 1  } ^{ n  } [ \gcd ( i , j ) & = 1 ] [ \gcd ( i , k ) & = 1 ] [ \gcd ( j , k ) & = 1 ] \\

\end{aligned}</script><p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从$1 , 3 , 5 , 7 , 9 $中选,答案应该是$1 + 2 \binom { 3  } { 2  } = 7 $.</p>
<p>接下来考虑选一个偶数,如果选$2 , 4 , 8 $是等价的,答案此时是$3 ( \binom { 5  } { 2  } - 1 ) = 27 $.如果选$6 $的话答案是$\binom { 3  } { 2  } = 3 $.如果选$10 $的话方案数是$\binom { 4  } { 2  } - 1 = 5 $,加起来方案数是$42 $.</p>
<h4><span id="problem11">Problem11</span></h4><p>集合$U = \{ 1 , 2 , \cdots , n \} , n = 366 $,则$U $的互不相交且各元素之和为$17 $的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5><p>考虑$\lfloor \frac { 366  } { 17  } \rfloor = 21 , 366 \equiv 9 \pmod { 17  } $.答案显然是$21 \times 8 + 10 + 1 = 179 $个.</p>
<h4><span id="problem12">Problem12</span></h4><p>三个互不相同的数的$\gcd = 20 , \text { lcm  } = 20000 $,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5><p>显然等价于$\gcd = 1 , \text { lcm  } = 1000 = 2 ^3 \times 5 ^3 $.先只分析其中一个质因子,方案应该是$( 0 , 0 , 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , ( 0 , 3 , 3 ) $,打乱一下顺序的话就共有$3 + 6 + 6 + 3 = 18 $种方案.如果可以重复,平方一下得到$324 $.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有$2 \times 2 \times 3 = 12 $种,于是答案为$312 $.</p>
<h4><span id="problem14">Problem14</span></h4><p>求$\lfloor \frac { k ^2  } { n  } \rfloor , k \in [ 1 , n ] , n = 2023 $种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\lfloor \frac { k ^2  } { n  } \rfloor & = d \\
d & \leq \frac { k ^2  } { n  } & < d + 1 \\
nd & \leq k ^2 & < n ( d + 1 ) 
\end{aligned}</script><p>由于两个完全平方数的差是固定的,不妨猜测存在一个$k _0 $,$\leq k _0 $的$k $会扎堆,但是这些$d $全都能取到,$&gt; k _0 $的则不会有两个$k $得到相同的元素.所以前者统计不同的$d $,后者统计不同的$k $考虑$( k + 1 ) ^2 - k ^2 = 2 k + 1 $.分界线应该是$k _0 = 1011 $.</p>
<p>所以答案应该是$n - k _0 + \lfloor \frac { k _0 ^2  } { 2 k _0 + 1  } \rfloor + 1 = 1012 + 506 = 1518 $.</p>
<h4><span id="problem15">Problem15</span></h4><p>对四元组$( a , b , c , d ) $计数,满足$101 | ( a + b + c + d ) $且$0 &lt; a &lt; b &lt; c &lt; d \leq 101 $.</p>
<h5><span id="solution15">Solution15</span></h5><p>这题真的厉害啊.</p>
<p>不妨设$S _k $为满足$( a + b + c + d ) \equiv k \pmod { 101  } $的满足$0 &lt; a &lt; b &lt; c &lt; d \leq 101 $的四元组数量.不难发现$\sum S _k = \binom { 101  } { 4  } $.</p>
<p>注意到$( a , b , c , d ) \mapsto ( a + 1 , b + 1 , c + 1 , d + 1 ) $,注意这里是$\pmod { 101  } $意义下的加法,这是一个双射,所以$S _{ k  } = S _{ k + 4  } $,下标同样也是$\pmod { 101  } $意义下进行的.又因为$\gcd ( 101 , 4 ) = 1 $,所以所有的$S _k $均相等.$S _0 = \frac { \binom { 101  } { 4  }  } { 101  } = 40425 $.</p>
<h4><span id="problem16">Problem16</span></h4><p>问方程$x \lfloor x \rfloor = 6 $的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5><p>$6 = x \lfloor x \rfloor \geq \lfloor x \rfloor ^2 $,所以$\lfloor x \rfloor = \pm 1 , \pm 2 $.显然都不可以.所以个数为$0 $.</p>
<h4><span id="problem17">Problem17</span></h4><p>设$R ( n ) = \sum _{ k = 2  } ^{ 10  } ( n \bmod k ) $,求满足$R ( n ) = R ( n + 1 ) $的十进制下的两位数$n $的个数.</p>
<h5><span id="solution17">Solution17</span></h5><p>从$R ( n ) $到$R ( n + 1 ) $,应该是加了若干个$1 $,然后又丢了几个$k - 1 $这样的.那就一定需要丢掉的数字之和为$9 $.枚举一下,丢了的只有可能是以下情况:$( 9 ) , ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 + 3 + 2 ) $,分别对应了$n + 1 $应该是分别以下数的倍数$( 9 ) , ( 14 ) , ( 6 ) , ( 20 ) , ( 12 ) $,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:$( 7 + 2 ) $,并且分别不能是以下数字的倍数$( 3 , 4 , 5 ) $.</p>
<p>取一下的话$n + 1 $可以是:$14 , 98 $,$n = 13 , 97 $,验证一下均合法,所以答案为$2 $.</p>
<h4><span id="problem18">Problem18</span></h4><p>已知$a &lt; b &lt; c &lt; d $,而$x , y , z , w $是$a , b , c , d $的一个排列,求$( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 $得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5><p>圆排列个数是$3 ! = 6 $个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是$( x , y , z , w ) , ( x , z , w , y ) , ( x , w , y , z ) $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 \\
& = 2 ( x ^2 + z ^2 + y ^2 + w ^2 ) - 2 ( xy + yz + zw + wx ) 
\end{aligned}</script><p>显然只要$xy + yz + zw + wx $不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4><p>已知$0 &lt; x _1 &lt; x _2 &lt; \cdots &lt; x _9 $且$\sum _{ k = 1  } ^9 x _k = 220 $,在$\sum _{ k = 1  } ^5 x _k $最大的前提下,最小化$x _9 - x _1 $.</p>
<h5><span id="solution19">Solution19</span></h5><p>不妨枚举一下$x _5 $选啥,设$f ( S , m , k ) $表示选出$k $个互不相同的数,使得它们$\leq m $且总和为$S $,是否可行.不难发现$f ( S , m , k ) = [ \frac { k ( k + 1 )  } { 2  } \leq S \leq \frac { k ( 2 m - k + 1 )  } { 2  } ] $.</p>
<p>那我们要求的就是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max _{ 5 \leq x _5  } \{ S | f ( 220 - 4 x _5 - S , + \infty , 4 ) & = 1 \land f ( S - x _5 , x _5 - 1 , 4 ) & = 1 \} \\
& = \max _{ 5 \leq x _5  } \{ S | 4 x _5 + S & \leq 210 \land 10 + x _5 & \leq S & \leq 5 x _5 - 10 \} \\
& = \max _{ 5 \leq x _5  } ( \min \{ 5 x _5 - 10 , 210 - 4 x _5 \} ) 
\end{aligned}</script><p>立刻得到$x _5 = 24 , 25 , S = 110 $,那么后面的选法就一定了,后面四个数一定是$26 , 27 , 28 , 29 $,只需要让$x _1 $最大即可</p>
<p>$x _5 = 24 $时,此时最优显然是$20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 , 29 $,$x _9 - x _1 = 9 $.</p>
<h4><span id="problem20">Problem20</span></h4><p>有一个$n $边形,其中有$\binom { n  } { 2  } $条对角线,不存在三线交于一点的情况,问这些对角线将该$n $边形分成了多少个部分.$n = 10 $.</p>
<h5><span id="solution20">Solution20</span></h5><p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了$\binom { n  } { 4  } $个点(任意四个点有且只有一种交法),每交一个点就会多出$2 $条边,所以多出来了$2 \binom { n  } { 4  } + \frac { n ( n - 3 )  } { 2  } $条边.</p>
<p>考虑内部的若干个部分一定是$a _3 $个三角形,$a _4 $个四边形,…,$a _k $个$k $边形,总之我们发现:</p>
<script type="math/tex; mode=display">
\begin{cases}
\sum _{ j = 3  } ^k ( j - 2 ) \pi a _j = ( n - 2 ) \pi + 2 \pi \binom { n  } { 4  } \\
\sum _{ j = 3  } ^k ja _j = n + 4 \binom { n  } { 4  } + n ( n - 3 ) 
\end{cases}</script><p>两式得到:$\sum _{ j = 3  } ^k a _j = \frac { ( n - 1 ) ( n - 2 )  } { 2  } + \binom { n  } { 4  } $.</p>
<p>$n = 10 $的时候,答案为$246 $.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3><h4><span id="problem1">Problem1</span></h4><p>求$\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \bmod 7 , n = 2024 $.</p>
<h5><span id="solution1">Solution1</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \\
& = \sum _{ i = 1  } ^n \lfloor \frac { \sum _{ k = 0  } ^i 20 ^k ( - 1 ) ^{ i - k  } \binom { i  } { k  }  } { 20  } \rfloor \\
& = - \lfloor \frac { n  } { 2  } \rfloor + \sum _{ i = 1  } ^{ n  } \frac { 19 ^i - ( - 1 ) ^i  } { 20  } \\
& = - \lfloor \frac { n  } { 2  } \rfloor + \frac { \frac { 19  } { 18  } ( 19 ^n - 1 ) - ( \frac { ( - 1 ) ^n - 1  } { 2  } )  } { 20  } 
\end{aligned}</script><p>带入$n = 2024 $并$\bmod 7 $,原式为:</p>
<script type="math/tex; mode=display">
\equiv - 4 + \frac { 5  } { 4  } ( 1 - 5 ^n ) \equiv - 4 + 3 ( 1 - 5 ^n )</script><p>注意到$2024 \bmod 6 = 2 $,原式$\equiv - 4 - 9 \equiv 1 $.</p>
<h4><span id="problem3">Problem3</span></h4><p>求长度为$n $的排列个数,使得排列中$\nexists i \in [ 1 , n - 1 ] , a _i = a _{ i + 1  } - 1 $.$n = 8 $.</p>
<h5><span id="solution3">Solution3</span></h5><p>一眼容斥,也就是每个长度为$k $的连续段的容斥系数应该是$( - 1 ) ^{ k - 1  } $.那么设分成了$w $个段,总的容斥系数应该是$( - 1 ) ^{ n - w  } $,答案就是$f _{ n ‘  } = \sum _{ w = 1  } ^n ( - 1 ) ^{ n - w  } w ! \binom { n - 1  } { w - 1  } = \sum _{ w = 0  } ^{ n ‘  } ( - 1 ) ^{ n ‘ - w  } \binom { n ‘  } { w  } ( w + 1 ) ! = n ‘ ! \sum _{ w = 0  } ^{ n ‘  } \frac { ( - 1 ) ^w  } { w !  } ( n ‘ - w + 1 ) $,此时已经能算出答案是$16687 $.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设$g _n $为错排数量,显然有$f _{ n  } = nf _{ n - 1  } + g _{ n  } $,立刻算出答案是$16687 $.</p>
<h4><span id="problem4">Problem4</span></h4><p>已知数列$1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , \cdots $,求其第$n $项$\bmod 5 $的值,$n = 2024 $.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑第一个值为$k $的地方应该在哪里.显然$a _{ \frac { k ( k - 1 )  } { 2  } + 1  } = k $.注意到$a _{ 2081  } = 65 $,所以$a _n = 64 $,其$\bmod 5 = 4 $.</p>
<h4><span id="problem5">Problem5</span></h4><p>求四元组$( a _1 , a _2 , a _3 , a _4 ) $的个数,满足$a _1 , a _2 , a _3 , a _4 \in \{ 1 , 2 , 3 \} $,且$10 &lt; a _1 a _2 a _3 a _4 &lt; 20 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>排个序按照字典序开搜,只有三种可能:$\{ 3 , 3 , 2 , 1 \} , \{ 3 , 2 , 2 , 1 \} , \{ 2 , 2 , 2 , 2 \} $,打乱顺序的话就有$25 $种可能.</p>
<h4><span id="problem8">Problem8</span></h4><p>求$\mathbb { R  } $上方程$x ^2 - 13 \lfloor x \rfloor + 11 = 0 $的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5><p>首先注意到$\lfloor x \rfloor = \frac { x ^2 + 11  } { 13  } $,那么自然有方程组:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { x ^2 + 11  } { 13  } \leq x \\
x < \frac { x ^2 + 11  } { 13  } + 1 
\end{cases}</script><p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑$x ^2 \equiv 2 \pmod { 13  } $这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设$x = \sqrt { 2 + 13 k  } $的形式,带入有不等式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k - x + 1 & \leq 0 & < k - x + 2 \\
1 & \leq \sqrt { 2 + 13 k  } - k & < 2 \\
\begin{cases}
0 < k ^2 - 9 k + 2 \\
k ^2 - 11 k - 1 \leq 0 
\end{cases} 
\end{aligned}</script><p>冷静一下!注意到$0 \leq k \leq 13 $,又根据第一个不等式得知大部分$k $应该会很大,开始暴力枚举一下,合法的情况有:$k = 0 , 9 , 10 , 11 $,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4><p>在一个体积为$1 $的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积$\leq \frac { 1  } { 8  } $的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5><p>原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积$\leq \frac { 1  } { 8  } $.考虑设这个点是$( x , x , h ) $,那么必然有$\begin{cases}( 1 - h ) x ^2 &gt; \frac { 1  } { 8  } \ h ( 1 - x ) ^2 &gt; \frac { 1  } { 8  } \end{cases} $,化简,只要$8 &gt; \frac { 1  } { x ^2  } + \frac { 1  } { ( 1 - x ) ^2  } $即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取$( 0 . 5 , 0 . 5 , 0 . 1 ) $即可.那么是不是可以证明答案一定$&gt; 3 $呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积$\leq \frac { 1  } { 8  } $的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为$( x , y , h ) , x , y , h \leq \frac { 1  } { 2  } $,然后证明$8 &gt; \frac { 1  } { xy  } + \frac { 1  } { ( 1 - x ) ( 1 - y )  } , x , y \leq \frac { 1  } { 2  } $这个不等式无解即可.</p>
<p>由基本不等式,$\frac { 1  } { xy  } + \frac { 1  } { ( 1 - x ) ( 1 - y )  } \geq 2 \sqrt { \frac { 1  } { x ( 1 - x ) y ( 1 - y )  }  } \geq 2 \sqrt { 4 \times 4  } = 8 $,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4><p>设$S ( n ) $表示正整数$n $的十进制数码和,求满足$S ( n ) \equiv S ( n + 1 ) \equiv 0 \pmod { 5  } $的最小的$n $.</p>
<h5><span id="solution11">Solution11</span></h5><p>显然必须发生进位,不妨设$n = 10 ^k a + 10 ^k - 1 $,$a \ne 9 \pmod { 10  } $,$S ( n ) = S ( a ) + 9 k , S ( n + 1 ) = S ( a ) + 1 $,</p>
<p>此时显然有$9 k - 1 \equiv 0 \pmod { 5  } $,$k \equiv 4 \pmod { 5  } $.$n _{ \min  } = 49999 $.</p>
<h4><span id="problem12">Problem12</span></h4><p>求满足以下条件的最大的正整数$n $:十进制下每一位数字互不相同,且$\forall m , 10 ^m \leq n , \lfloor \frac { n  } { 10 ^m  } \rfloor | n $.</p>
<h5><span id="solution12">Solution12</span></h5><p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是$0 $.</p>
<p>不妨设其为$\overline { ab  } $,其中$b = 10 c $,$a $是$b $的因子,不妨枚举一下$k = \frac { b  } { a  } $.注意到因为$a $中不能有$0 $,所以$k \in \{ 2 , 4 , 5 , 8 \} $.取$k = 2 $试出来$3570 $是合法的,而且显然$k \in \{ 4 , 5 , 8 \} $的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4><p>$a _1 = \sqrt { 2  } , a _{ n + 1  } = \lfloor a _n \rfloor + \frac { 1  } { a _n - \lfloor a _n \rfloor  } $,求$\sum _{ k = 1  } ^{ n  } a _k , n = 2024 $.</p>
<h5><span id="solution20">Solution20</span></h5><p>这一看就是个环,设$a _n = b _n + c _n \sqrt { 2  } $.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<script type="math/tex; mode=display">
\begin{cases}
a _1 = 0 + \sqrt { 2  } \\
a _2 = 2 + \sqrt { 2  } \\
a _3 = 4 + \sqrt { 2  } \\
\cdots 
\end{cases}</script><p>容易猜测$b _n = 2 ( n - 1 ) , c _n = 1 $.也就是$a _n = 2 ( n - 1 ) + \sqrt { 2  } $,数学归纳一下即可.</p>
<p>那么$\sum _{ k = 1  } ^n a _k = n ( n - 1 ) + n \sqrt { 2  } $,带入$n = 2024 $即可.</p>
<h3><span id="2022图选">2022图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol>
<li><p>任意两个正方形至多有一个顶点重合</p>
</li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p>
</li>
</ol>
<h5><span id="solution1">Solution1</span></h5><p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol>
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p>
</li>
<li><p>边可以相交,放到正十二边形的边上.</p>
</li>
</ol>
<h4><span id="problem2">Problem2</span></h4><p>求$\lfloor ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ 12  } \rfloor $.</p>
<h5><span id="solution2">Solution2</span></h5><p>考虑$( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^3 = 2 + \sqrt { 5  } $,$\lfloor ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ 12  } \rfloor = 161 + \lfloor 72 \sqrt { 5  } \rfloor = 321 $.</p>
<p>也可以考虑类似斐波那契数列,取$f _n = ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ n  } + ( \frac { 1 - \sqrt { 5  }  } { 2  } ) ^{ n  } $,其满足$f _n = f _{ n - 1  } + f _{ n - 2  } , f _0 = 2 , f _1 = 1 $,取$f _{ 12  } - 1 $就是答案$321 $.</p>
<h4><span id="problem3">Problem3</span></h4><p>对于一个加法乘法环,要求你利用:</p>
<ol>
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p>
</li>
<li><p>加法结合律、逆元.</p>
</li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5><p>倒反天罡题.</p>
<p>注意到$( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a + 1 ) $,所以$a + b = b + a $.</p>
<h4><span id="problem4">Problem4</span></h4><p>给你$n $个数集$a _i $,其中$| a _i | = i + 1 $,要你选出$n $个两两不同的数字满足$x _i \in a _i $,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是$2 ^n $.</p>
<h4><span id="problem5">Problem5</span></h4><p>Alice和Bob博弈.Alice先选一个数$m $,然后Bob选一个数$n ( n &gt; m ) $,并构造一个$n $个点的竞赛图.Alice如果能从中选出$m $个不同的点,满足不存在某个点$x $到这$m $个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5><p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是$( 1 - \frac { 1  } { 2 ^m  } ) ^{ n - 2  } $,因此期望为$E = \binom { n  } { m  } ( 1 - \frac { 1  } { 2 ^m  } ) ^{ n - 2  } $,只需$n $足够大的时候期望$&lt; 1 $,则说明一定存在$0 $,也就是Bob总有必胜策略.</p>
<p>注意到只需证明$\exists n $,$\binom { n  } { m  } &lt; ( \frac { 2 ^m  } { 2 ^m - 1  } ) ^{ n - 2  } $,而$\binom { n  } { m  } = \frac { n ^{ \underline { m  }  }  } { m !  } &lt; n ^m $.下面证明$\exists n , n ^m &lt; ( \frac { 2 ^m  } { 2 ^m - 1  } ) ^{ n - 2  } $.</p>
<p>两边取$\ln $,不妨假设$n \geq 3 $,有$m \ln n &lt; ( n - 2 ) \ln ( \frac { 2 ^m  } { 2 ^m - 1  } ) , \frac { m  } { \ln ( \frac { 2 ^m  } { 2 ^m - 1  } )  } &lt; \frac { n - 2  } { \ln n  } $,$\frac { n - 2  } { \ln n  } $显然在$n \geq 3 $的时候单增,所以一定存在这么一个$n $.</p>
<h3><span id="2023图选">2023图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5><p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4><p>求正整数拆分成有序的$1 , 2 $序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5><p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4><p>定义$* $为集合$G $上的二元运算,已知:</p>
<ol>
<li><p>满足结合律$a ∗ b ∗ c = a ∗ ( b ∗ c ) $.</p>
</li>
<li><p>存在左单位元$e $,对任意$a $满足$e ∗ a = a $.</p>
</li>
<li><p>对任意$a $存在左逆元$b $,使$b ∗ a = e $.</p>
</li>
</ol>
<p>问:</p>
<ol>
<li><p>左单位元是否也为右单位元.</p>
</li>
<li><p>左逆元是否也为右逆元.</p>
</li>
</ol>
<h5><span id="solution3">Solution3</span></h5><p>看(2),考虑设$b $是$a $的左逆元,$c $是$b $的左逆元,则$cba = ce = a , ab = ceb = e $.</p>
<p>看(1),设$b $是$a $的逆元,$ea = aba = ae $,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明$ab $的时候$b $不能彻底损失信息,而观察$ab = eab $知道$a $也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算$( a _1 , b _1 ) ( a _2 , b _2 ) $,想办法让其损失掉$( a _1 , b _1 ) $中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到$( a _1 , b _1 ) ( a _2 , b _2 ) = ( a _1 + a _2 , b _2 ) $即可,存在左幺元为$( 0 , 0 ) $,右逆元为$( - a , 0 ) $.</p>
<h4><span id="problem4">Problem4</span></h4><p>$f $的定义域和值域都是正整数并且$f ( xy ) = f ( x ) + f ( y ) - 1 $,求:</p>
<ol>
<li><p>是否存在这样的函数.</p>
</li>
<li><p>是否存在无数个这样的函数.</p>
</li>
<li><p>是否存在严格递增的函数.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>令$g ( x ) = f ( x ) - 1 $,则$g ( xy ) = g ( x ) + g ( y ) $.</p>
<p>对于(1),取$g ( x ) = 0 , f ( x ) = 1 $即可.</p>
<p>对于(2),考虑$g ( p ^k ) = kg ( p ) $,只需要让$g ( p ) $取不同的值即可.</p>
<p>对于(3),考虑$g ( 2 ^a ) = ag ( 2 ) $,$g ( 3 ^b ) = bg ( 3 ) $.</p>
<p>考虑构造$a , b $,使得$2 ^a &lt; 3 ^b $但是$ag ( 2 ) \geq bg ( 3 ) $.不妨取$a = \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil $,那么必定有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ^{ \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil  } & < 3 ^b \\
\lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil & < b \log _2 3 \\
\frac { bg ( 3 )  } { g ( 2 )  } + \Delta & \leq b \log _2 3 \\

\end{aligned}</script><p>于是如果存在,必定需要$\frac { g ( p _1 )  } { g ( p _2 )  } \geq \log _{ p _2  } p _1 \land \frac { g ( p _2 )  } { g ( p _1 )  } \geq \log _{ p _1  } p _2 $,也就是$\frac { g ( p _2 )  } { g ( p _1 )  } = \log _{ p _1  } p _2 $.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4><p>对于任意$2 n - 1 $个正整数(可重复),问其中是否一定有$n $个数的和能被$n $整除,这题$n = 50 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>考虑当$n $是合数的时候,设$n = pq $,则可以将其拆成$q - 1 $组每组$2 p $个数以及一组$2 p - 1 $个数,因此只需要这些都可以找到$p $个数使得其是$p $的倍数,组合起来就行了.</p>
<p>只需要解决$n $是质数的情况.</p>
<p>感觉场上的最优解应该是解决$n = 2 $和$n = 5 $的情况然后拼成$n = 50 $.</p>
<p>$n = 2 $的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然$S = \sum _{  } ( x _{ p _1  } + x _{ p _2  } + \cdots + x _{ p _n  } ) ^{ p - 1  } \equiv \binom { 2 n - 1  } { n  } \equiv 1 \pmod { n  } $.</p>
<p>但是考虑左边那个多项式的每一项,形如$c \prod _{ i = 1  } ^k x _{ p _i  } ^{ e _i  } $.注意到$c $一定是$\binom { 2 n - 1 - k  } { n - k  } $的倍数,而后者$\bmod n $为$0 $.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为$1 $并不是对称的,而左边是个对称式子,某个$x $增大也无所谓,这意味着左边应该是为$0 $的,我们要做的就是去证明它是$0 $.</p>
<h3><span id="2024图选">2024图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>问在双曲线$xy = 1 $上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5><p>不会做,取个特殊值知道答案应该是$[ 2 \sqrt { 6  } , + \infty ) $.</p>
<h4><span id="problem2">Problem2</span></h4><p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol>
<li><p>如果$n , m $都是好的,那么$nm $是好的.</p>
</li>
<li><p>$2024 $不是好的.</p>
</li>
</ol>
<h5><span id="solution2">Solution2</span></h5><p>如果$n = a ^2 + b ^2 , m = c ^2 + d ^2 $,那么$nm = a ^2 c ^2 + a ^2 d ^2 + b ^2 c ^2 + b ^2 d ^2 = ( ac - bd ) ^2 + ( ad + bc ) ^2 $.</p>
<p>$2024 = 2 ^3 \times 11 \times 23 $,使用反证法,不妨设其可以被表示为$a ^2 + b ^2 $.</p>
<p>讨论一下:如果$a , b $均为奇数,那么$a ^2 + b ^2 \equiv 2 \pmod { 8  } $,不符题意.</p>
<p>于是$a , b $应该均为偶数,那么就有$a ‘ ^2 + b ‘ ^2 = 506 $.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4><p>对于集合$G $,$e \in G $,定义域为$G $的函数$f $满足以下性质:</p>
<ol>
<li><p>$e \in G $,但$e $不在$f $的值域中.</p>
</li>
<li><p>$G $关于$f $封闭.</p>
</li>
<li><p>若$\exists A \subseteq G $,$e \in A $且$A $对$f $封闭,则$A = G $.</p>
</li>
</ol>
<p>在$G $上定义二元运算$\circ $,满足$ae = a , af ( b ) = f ( ab ) $.</p>
<p>求证:</p>
<ol>
<li><p>存在幺元.</p>
</li>
<li><p>运算满足交换律.</p>
</li>
<li><p>运算满足结合律.</p>
</li>
</ol>
<h5><span id="solution3">Solution3</span></h5><p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往$A $里面扔个$e $,此时$A $一定不满足条件.我们不断从$A $中选出一个元素$w $满足$f ( w ) \notin A $,并把$A : = A \cup \{ f ( w ) \} $.不断做这个过程显然最后会得到$G $,这意味着任何一个元素$a $可以写成$f ( f ( f \cdots f ( e ) ) ) $的形式.</p>
<p>不妨将$f $函数嵌套$k $次记作$f ^{ ( k )  } $,那么我们要证明的是$a = f ^{ ( A )  } ( e ) , b = f ^{ ( B )  } ( e ) $,$ab = ba $.</p>
<p>考虑$ab = f ^{ ( A )  } ( e ) f ^{ ( B )  } ( e ) = f ^{ ( B )  } ( f ^{ ( A )  } ( e ) e ) = f ^{ ( A + B )  } ( e ) $,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4><p>给出一个具体函数满足:</p>
<ol>
<li><p>$f ( x + y ) = f ( x ) + f ( y ) + xy $.</p>
</li>
<li><p>$f ( xy ) = f ( x ) f ( y ) + f ( x - 1 ) f ( y - 1 ) $.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>先注意到$f ( 0 ) = 0 , f ( 1 ) = 1 $.</p>
<p>以$x $为主元两边求导,立刻得到$f ‘ ( x + y ) = f ‘ ( x ) + y $,因此$f ‘ ( x ) $是斜率为$1 $的一次函数,立刻得到$f ( x ) = \frac { x ^2  } { 2  } + \frac { x  } { 2  } $.</p>
<h4><span id="problem5">Problem5</span></h4><p>对于$r = \sqrt { 2  } $,是否存在正整数$p $和整数$q $满足$| pr - q | &lt; \frac { 1  } { 2024  } $且$p &lt; 2024 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>考虑取$0 , \sqrt { 2  } , 2 \sqrt { 2  } , 3 \sqrt { 2  } , \cdots 2023 \sqrt { 2  } $的小数部分,记作$a _0 , a _1 , \cdots a _{ 2023  } $.</p>
<p>由鸽笼原理,一定存在两个数$0 \leq x &lt; y \leq 2023 $满足$| a _x - a _y | &lt; \frac { 1  } { 2024  } $,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>在一个数轴上,你站在$0 $点,并按照如下算法寻找$x ( x &gt; 0 ) $点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. $3 x $  B. $5 x $  C. $7 x $  D. $9 x $  E. 以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5><p>考虑找到牛的时候$step $为多少,应该为$2 ^{ 2 k  } $,其中$k $满足$2 ^{ 2 k  } \geq x &gt; 2 ^{ 2 ( k - 1 )  } $.此时走的步数应该是$ans = 2 \sum _{ i = 0  } ^{ 2 k - 1  } 2 ^i + x = 2 ^{ 2 k + 1  } - 1 + x $步.而$x \leq 2 ^{ 2 k  } &lt; 4 x $,所以$ans &lt; 9 x - 1 $.</p>
<h4><span id="problem2">Problem2</span></h4><p>给定$10 $个实数变量$x _1 , \cdots , x _{ 10  } $,满足它们均$\geq 1 $且两两不同.你要寻找一组$\{ x \} $和一个实数$a $,使得存在尽可能多组$\langle b \rangle , b _i = \pm 1 $,满足$\sum _{ i = 1  } ^{ 10  } b _i x _i \in ( a , a + 2 ) $.</p>
<p>最多存在多少组$\langle b \rangle $?</p>
<p>A. $512 $  B. $252 $  C. $504 $  D. $684 $  E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5><p>不妨猜测$x $全取$1 $最优,此时的答案是$\binom { 10  } { 5  } = 252 $.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于$x \geq 1 $,所以如果存在两组$\langle b \rangle $,使得$A $组中选择取$+ 1 $恰好是$B $组的子集,那么$S _A \leq S _B - 2 $,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让$x $尽可能接近$1 $,这样就是满足条件的.所以问题变为对于一个大小为$10 $的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取$\binom { 10  } { 5  } $最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4><p>给定无向图$G = ( V , E ) $,我们称一个图是好的,如果:</p>
<ol>
<li><p>每个点的度数均为$d $.</p>
</li>
<li><p>任何一个大小不超过$\frac { | V |  } { 2  } $的联通集合$S $,其邻居(不属于$S $但和$S $中的某个点存在直接相连的边)的大小$\geq \frac { 5  } { 4  } | S | $.</p>
</li>
</ol>
<p>求证:好的图中任意两个点$u , v $之间的最短路径长度$dis ( u , v ) = O ( \log | V | ) $.</p>
<h5><span id="solution3">Solution3</span></h5><p>考虑以$u $为起点一点一点往外扩张,这样一直扩张到$\frac { | V |  } { 2  } + 1 $时,集合中每个点到$u $的距离不超过$O ( \log | V | ) $.</p>
<p>然后以$v $做同样的事,由于这两个集合大小之和大于$| V | $,说明一定有交,且存在一条路径长度为$O ( \log | V | ) $的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4><p>给你两个完全相同的鸡蛋和一个$n = 100 $层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5><p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有$101 $个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设$f _{ i , 1 / 2  } $表示一棵有$i $个叶子的树,最多向右走$1 / 2 $步,深度最低为多少.显然$f _{ i , 1  } = i - 1 $.</p>
<p>不妨设最后的最大深度为$k $,需要满足$1 + \sum _{ i = 1  } ^k i = 1 + \frac { k ( k + 1 )  } { 2  } \geq 101 , k ( k + 1 ) \geq 200 $,$k _{ \min  } = 14 $.</p>
<h4><span id="problem5">Problem5</span></h4><p>$n $个人要进行一场游戏.游戏设计者准备了$n $张卡片,正面分别写着$n $个人的名字,背面写了$[ 1 , n ] $共$n $个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,$n $个人可以经过充分的讨论,并依次进入房间,一张一张地翻开$\lfloor \frac { n  } { 2  } \rfloor $张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有$n $个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过$0 . 1 $的胜率.</p>
<h5><span id="solution5">Solution5</span></h5><p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是$a $,如果$a $就是自己的编号就下班;反之接下来翻开$a $位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于$\frac { n  } { 2  } $的环.</p>
<p>考虑总方案数是$n ! $.不妨枚举这个环的长度为$K $,则存在一个长度$= K &gt; \frac { n  } { 2  } $的环的方案数是$\binom { n  } { K  } ( K - 1 ) ! ( n - K ) ! = \frac { n !  } { K  } $.所以此时的概率为$\frac { 1  } { K  } $.</p>
<p>那么失败的概率就是$H _n - H _{ \frac { n  } { 2  }  } \approx \ln 2 $.</p>
<h3><span id="2022茶选">2022茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化$z = 5 x _1 + 8 x _2 + 4 x _3 $,其中:</p>
<ol>
<li><p>$x _1 , x _2 , x _3 \geq 0 $</p>
</li>
<li><p>$\frac { 1  } { 2  } x _1 + 5 x _2 + 9 x _3 \leq 3 $</p>
</li>
<li><p>$4 x _1 + 7 x _2 + 3 x _3 \leq 6 $</p>
</li>
</ol>
<p>再提一个问题:最小化$v = 3 y _1 + 6 y _2 $,其中:</p>
<ol>
<li><p>$y _1 , y _2 \geq 0 $</p>
</li>
<li><p>$\frac { 1  } { 2  } y _1 + 4 y _2 \geq 5 $</p>
</li>
<li><p>$5 y _1 + 7 y _2 \geq 8 $</p>
</li>
<li><p>$9 y _1 + 3 y _2 \geq 4 $</p>
</li>
</ol>
<p>现在请你证明:$z \leq v $.</p>
<h5><span id="solution1">Solution1</span></h5><p>下面乘一下配一下上面的系数,自然得证.</p>
<p>写成矩阵形式,设$X = \begin{bmatrix}x _1 &amp; x _2 &amp; x _3 \end{bmatrix} , A = \begin{bmatrix}0 . 5 &amp; 4 \ 5 &amp; 7 \ 9 &amp; 3 \end{bmatrix} , Y = \begin{bmatrix}y _1 \ y _2 \end{bmatrix} $,不难发现$z \leq XAY \leq v $.</p>
<h4><span id="problem2">Problem2</span></h4><p>半径为$R $的球里放点,要求两两之间距离不能小于$1 $,证明至多放$( 2 R + 1 ) ^3 $个.</p>
<h5><span id="solution2">Solution2</span></h5><p>要求两两距离不能小于$1 $等价于往其中放半径为$0 . 5 $的球,这种球体积为$\frac { 4  } { 3  } \pi \frac { 1  } { 8  } $.然后原球要扩大一圈,所以原球体积变为$\frac { 4  } { 3  } \pi ( R + 0 . 5 ) ^3 $.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4><p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数$n $.</p>
<p>它每秒以$v $的速度行驶,其中$v $是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数$x $,你会得知此时车的坐标是否是$x $(Yes or No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5><p>第$t $秒的时候车应该在$n + vt $处.由于我们知道现在是第几秒,枚举$n , v $然后不断check即可.这个是经典的证明$\mathbb { Z  } ^2 $和$\mathbb { N  } $等势.按照$| n | + | v | $排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4><p>对满足$\forall i , | i - p _i | \leq 1 $的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5><p>简单题,设$f _n $为答案,考虑$p _n $取什么.</p>
<p>当$p _n = n $时,方案数为$f _{ n - 1  } $.</p>
<p>当$p _n = n - 1 $时,$p _{ n - 1  } = n $,方案数为$f _{ n - 2  } $.</p>
<p>于是,$f _1 = 1 , f _2 = 2 $,$f _n = f _{ n - 1  } + f _{ n - 2  } $.</p>
<h4><span id="problem5">Problem5</span></h4><p>你有一个$n \times n $的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择$k $个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数$k $最小值是$n $.</p>
<h5><span id="solution5">Solution5</span></h5><p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是$\frac { 4 n  } { 4  } = n $个.</p>
<h4><span id="problem6">Problem6</span></h4><p>设$F = \{ S _1 , S _2 , S _3 , . . . , S _{ | F |  } \} $,定义一个集合$T $能被$F $ shattered为:$T $的任意一个子集(包括它自己和空集),都可以由$T \cap S _{ i _1  } \cap S _{ i _2  } . . . $表示.其中$S _{ i _j  } $是$F $中的集合(就是说每个子集都等于$T $和某些$F $内集合的交.)</p>
<p>定义一个$F $的”VC-Dimension”是,能被他shattered的集合$T $的大小的最大值.</p>
<p>$F $中的集合们只会包含某$n $种不同的元素.证明:</p>
<ol>
<li><p>任意一个$F $能shattered的$T $至少有$| F | $个.</p>
</li>
<li><p>对于一个VC-Dimension的大小为$k $的$F $,其$| F | \leq \sum _{ i = 0  } ^k \binom { n  } { i  } $.</p>
</li>
</ol>
<h5><span id="solution6">Solution6</span></h5><p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的$S $,满足$S , S \cup \{ x \} \in F $,然后将这些$S \cap \{ x \} $拎出来,假设有$t $个,左边删去$x $后再进行数学归纳得到$| F | - t $个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有$t $个集合,在这$t $个集合添上$x $这个元素即可.</p>
<p>$t = 0 $怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为$S $(选取最大的那个集合为新加入的),我们在前面的集合中找到一个与$S $有交的集合$T $,根据上面的预处理,此集合显然存在.选出一个$x \in S \setminus T $,不妨设$S = S ‘ \cup \{ x \} $,令$T ‘ = S ‘ \cap T $,然后用$T ‘ $代替原本的$T $即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>令$p ( x ) $表示$x $的最大质因子,求所有$( x , y , z ) $使得:</p>
<ol>
<li><p>$x &lt; y &lt; z $且$x + z = 2 y $.</p>
</li>
<li><p>$p ( xyz ) \leq 3 $.</p>
</li>
</ol>
<h5><span id="solution1">Solution1</span></h5><p>不妨令$g = \gcd ( x , y , z ) $,令$x ‘ = \frac { x  } { g  } $,则只需要解:$x ‘ + z ‘ = 2 y ‘ $.</p>
<p>我们有$y - x = z - y $,则$\gcd ( y ‘ , x ‘ ) = \gcd ( y ‘ , y ‘ - x ‘ ) = \gcd ( y ‘ , z ‘ ) = 1 $,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol>
<li><p>$2 \nmid x ‘ , 2 \nmid z ‘ $.</p>
</li>
<li><p>$2 \mid x ‘ , 2 \mid z ‘ , 2 \nmid y ‘ $.</p>
</li>
</ol>
<p>先看(1),设$x ‘ = 3 ^a , z ‘ = 3 ^c , y ‘ = 2 ^b $.方程变为$3 ^a ( 1 + 3 ^{ c - a  } ) = 2 ^{ b + 1  } $,一定有$a = 0 $,只需解$1 + 3 ^{ c  } = 2 ^{ b + 1  } $.</p>
<p>当$b \leq 2 $的时候,经检验有$\begin{cases}c = 0 \ b = 0 \end{cases} $(舍)和$\begin{cases}c = 1 \ b = 1 \end{cases} $两组解.</p>
<p>当$b \geq 3 $的时候,注意到$3 ^{ c  } \equiv - 1 \pmod { 4  } $,所以$c $是偶数.又注意到$3 ^{ c  } \equiv - 1 \pmod { 8  } $,但是奇数的平方$\bmod 8 $应该是$1 $,不符.</p>
<p>再看(2),设$x ‘ = 2 ^d , z ‘ = 2 ^e , y ‘ = 3 ^b $.</p>
<p>当$e = 1 $时,显然不符.</p>
<p>当$d = 1 , e &gt; 1 $时,要解$2 ^{ e - 1  } + 1 = 3 ^{ b  } $.当$e = 2 $的时候有一组解$\begin{cases}e = 2 \ b = 1 \end{cases} $.当$e \geq 3 $的时候,有$3 ^b \equiv 1 \pmod { 4  } $,说明$b $是偶数.</p>
<p>那必然有$2 ^{ e - 1  } = 3 ^b - 1 = ( 3 ^{ \frac { b  } { 2  }  } + 1 ) ( 3 ^{ \frac { b  } { 2  }  } - 1 ) $.令$t = 3 ^{ \frac { b  } { 2  }  } - 1 $,则$2 ^{ e - 1  } = t ( t + 2 ) $.则要么$t = 2 $,要么$t + 2 = 2 $.解出$b - 2 $,此时有$\begin{cases}e = 4 \ b = 2 \end{cases} $.</p>
<p>综上,解出来的解有$\begin{cases}x ‘ = 2 \ y ‘ = 3 \ z ‘ = 4 \end{cases} , \begin{cases}x ‘ = 1 \ y ‘ = 2 \ z ‘ = 3 \end{cases} , \begin{cases}x ‘ = 2 \ y ‘ = 9 \ z ‘ = 16 \end{cases} $.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程$2 ^x + 1 = 3 ^y $,考虑两边$\bmod 3 $知道$x $是奇数,于是$v _3 ( 2 ^x + 1 ) = v _3 ( 3 ) + v _3 ( x ) = y , 3 ^{ y - 1  } | x , x \geq 3 ^{ y - 1  } $,用这个放缩一下就行.</p>
<p>再看方程$2 ^x = 3 ^y + 1 $.仍然考虑两边$\bmod 4 $,知道$y $是奇数.$x = v _2 ( 3 ^y + 1 ) = v _2 ( 3 + 1 ) = 2 $,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4><p>给定两个随机分布：</p>
<p>$x ∼ D _1 $:从${ 0 , 1 , … , p − 1  } $中等概率随机一个$y $,令$x = y   \bmod   { 2 ^k  } $.</p>
<p>$x ∼ D _1 $:从${ 0 , 1 , … , 2 ^k - 1  } $中等概率随机一个$y $,令$x = y   $.</p>
<p>定义二者的统计距离为:$SD ( D _1 , D _2 ) = \frac { 1  } { 2  } \sum _{ i = 0  } ^{ 2 ^k - 1  } | P _{ D _1  } ( x = i ) - P _{ D _2  } ( x = i ) | $.</p>
<p>求证:$SD ( D _1 , D _2 ) ≤ \frac { 2 ^k  } { 4 p  } $.</p>
<h5><span id="solution2">Solution2</span></h5><p>令$w = p \bmod { 2 ^k  } $.则$SD ( D _1 , D _2 ) = \frac { w  } { 2  } ( P _{ D _1  } ( x = 0 ) - P _{ D _2  } ( x = 0 ) ) + \frac { 2 ^k - w  } { 2  } ( P _{ D _2  } ( x = w ) - P _{ D _1  } ( x = w ) ) $.</p>
<p>令$k = \lfloor \frac { p  } { 2 ^k  } \rfloor = \frac { p - w  } { 2 ^k  } $不难发现$P _{ D _1  } ( x = 0 ) = \frac { k + 1  } { p  } , P _{ D _1  } ( x = w ) = \frac { k  } { p  } $.</p>
<p>则$SD ( D _1 , D _2 ) = \frac { w  } { 2  } ( \frac { p - w + 2 ^k  } { p 2 ^k  } - \frac { 1  } { 2 ^k  } ) + \frac { 2 ^k - w  } { 2  } ( \frac { 1  } { 2 ^k  } - \frac { p - w  } { p 2 ^k  } ) = \frac { 1  } { 2 ^{ k + 1  }  } ( \frac { w ( 2 ^k - w )  } { p  } + \frac { w ( 2 ^k - w )  } { p  } ) = \frac { w ( 2 ^k - w )  } { p 2 ^k  } $.</p>
<p>要证明$\frac { w ( 2 ^k - w )  } { p 2 ^k  } \leq \frac { 2 ^k  } { 4 p  } \Leftrightarrow w ( 2 ^k - w ) \leq ( 2 ^{ k - 1  } ) ^2 $.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4><p>给你一个单增函数$f $,满足定义域和值域都是$\mathbb { N  } $,并且$f ( f ( n ) ) = 3 n $,求$f ( 2023 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><p>首先我们不妨先试一下$f ( f ( 1 ) ) = 3 $.由于$f ( 1 ) \geq 2 $,且$f ( 1 ) \ne 3 $,所以$f ( 1 ) = 2 , f ( 2 ) = 3 $.</p>
<p>考虑$f ( 3 n ) $,必然存在一个$n &lt; m &lt; 3 n $,使得$f ( n ) = m , f ( m ) = 3 n $.</p>
<p>用这个找前几项,发现规律是把$n $写成三进制形式,如果首位是$1 $就变成$2 $,首位是$2 $就改为$1 $再在后面加个$0 $.容易验证这是合法的$f $且$f ( 2023 ) = 3882 $.</p>
<p>但问题没有解决,需要证明它是唯一的$f $.</p>
<p>考虑数学归纳假设现在$f ( x ) , x \in [ 1 , 3 k ] $都确定了.</p>
<p>注意到如果$f ( n ) = m , f ( m ) = 3 n , f ( 3 n ) = 3 m , f ( 3 m ) = 9 n $.所以如果$f ( n ) = m $,我们实际上有$f ( 3 ^k m ) = 3 ^{ k + 1  } n , f ( 3 ^k n ) = 3 ^k m $.数学归纳即可以证明$f ( 3 k + 3 ) $一定是确定的.</p>
<p>接下来要证明$f ( 3 k + 1 ) $和$f ( 3 k + 2 ) $一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol>
<li><p>$f ( 3 k ) + 3 = f ( 3 k + 3 ) $.</p>
</li>
<li><p>$\exists n , f ( n ) = 3 k + w ( w \in \{ 1 , 2 \} ) $.</p>
</li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当$k $在三进制下首位如果是$2 $,则一定满足(2).</p>
<p>当$k $在三进制下首位是$1 $,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4><p>对于一个$n \times n $的包含$[ 1 , n ^2 ] $各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol>
<li><p>如果一个排列矩阵满足每行恰有模$n $余$[ 0 , n - 1 ] $的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第$i $行第$j $列为$( i - 1 ) n + j $的矩阵(不妨称为有序矩阵).</p>
</li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列$\bmod n $不相同,可以先将每行按照$\bmod n $排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将$\bmod n $不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是$n $正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4><p>有$n ( \geq 2 ) $个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称$n $是好的.求证:</p>
<ol>
<li><p>$4 $是好的.</p>
</li>
<li><p>如果$n $是奇数,那么$n $不是好的.</p>
</li>
<li><p>求出所有好的$n $.</p>
</li>
</ol>
<h5><span id="solution5">Solution5</span></h5><p>首先可以证明$2 $是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要$2 ^n $步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样$0 $和$1 $就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到$1100 $来一个$1010 $之后啥也不变,但是$1010 $来一个$1010 $一定赢了.所以上来先来一个$1010 $,如果赢了就下班,没赢就来个$1100 $,这样$1100 $要么下班,要么变成了$1010 $,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:$0000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111 , 1000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111 $.</p>
<p>上面的构造启发我们手玩一下$n = 3 $,注意到此时的问题在于$100 $和$110 $,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全$0 $;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全$0 $.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全$0 $的成功状态.我们不妨令一个成功状态的度为$d $表示它可以经过$d $步到达全$0 $,显然全$1 $的$d = 1 $,$n = 4 $的时候,$1010 $的$d = 2 $,因为其可以通过一次操作转化为全$1 $,$1100 $的$d = 3 $,因为其可以用一次操作转化为$1010 $.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向$d $比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然$n = 3 $的时候,$\{ 110 , 100 \} $就是失败状态.</p>
<p>而对于$n $取任意来说,一定得存在一个$d = 2 $的成功状态.一个显然的$d = 2 $的成功状态要满足的条件是,假设它是$a $,那么存在一个数$b $,使得$a \oplus b $是全$1 $或者全$0 $.既然$a $和$b $旋转后只有两种结果,那么$b $的循环节必定为$2 $,也就是$b $一定要是$101 \cdots 010 $这样的,于是$n $是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找$d = 3 $的成功状态,现在我们已知的四种成功状态是$111 \cdots 111 $,$000 \cdots 000 $,$101 \cdots 010 $,$010 \cdots 101 $,所以考虑构造一个循环节长度为$4 $的串,使得异或完它是这上面四种其一,注意到$1100 \cdots 1100 $就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明$n = 2 ^k $一定是好的.考虑数学归纳,不妨这么干:构造一个长度为$2 ^{ k - 1  } $的串$b $,使得其$b _i = a _i \oplus a _{ i + 2 ^{ k - 1  }  } $.然后由数学归纳,可以造出$b $全$0 $的情况.而如果$b $全$0 $,则原串一定存在长为$2 ^{ k - 1  } $的循环节,并且消除循环节的过程不会改变$b $的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设$n = 2 ^k m $,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造$b $数组,由于$b $数组都不可能全$0 $,显然也不可能成立.</p>
<p>这个能不能顺便证明$n $是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了$n - 1 $个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前$n - 1 $个位置的异或值为$1 $.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为$50 \% $,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5><p>简单题,设$f _0 , f _1 , f _2 , f _3 $,然后有$\begin{cases}f _3 = 0 \ f _2 = \frac { 1  } { 2  } f _3 + \frac { 1  } { 2  } f _0 + 1 \ f _1 = \frac { 1  } { 2  } f _2 + \frac { 1  } { 2  } f _0 + 1 \ f _0 = \frac { 1  } { 2  } f _1 + \frac { 1  } { 2  } f _0 + 1 \end{cases} $,算出$f _0 = 14 $.</p>
<h4><span id="problem2">Problem2</span></h4><p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<script type="math/tex; mode=display">
x ^3 + □ x ^2 + □ x + □ = 0</script><h5><span id="solution2">Solution2</span></h5><p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为$- A , - B , - C $,方程应该可以写作$( x + A ) ( x + B ) ( x + C ) = 0 $.</p>
<p>拆开有$x ^3 + ( A + B + C ) x ^2 + ( AB + AC + BC ) x + ABC = 0 $.</p>
<p>这么对称,不妨猜一手Alice先选择$0 $,讨论一下:</p>
<ol>
<li>Bob令$ABC = 0 $.不妨令$C = 0 $.</li>
</ol>
<p>此时方程变为$x ^2 + ( A + B ) x + AB = 0 $.直接秒了,随便选一个数就行(比如选$3 $,如果Bob令$AB = 3 $,就再选$4 $;如果令$A + B = 3 $,就再选$2 $)</p>
<ol>
<li>Bob令$A + B + C = 0 , C = - A - B $.</li>
</ol>
<p>不妨令$C ‘ = - C , D = AB $,则$AB + AC + BC = D - C ‘ ^2 , ABC = DC ‘ $.</p>
<p>接下来Alice要选择一个数字$k $,如果Bob又令$D - C ‘ ^2 = k $,发现在此时如果$k $是一个负的完全平方数,并且Alice接下来选择$0 $,当场就下班了.</p>
<p>所以不妨直接让$k = - n ^2 $,然后看当$DC ‘ = - n ^2 $的时候如何去解.此时有$AB ( A + B ) = n ^2 $.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择$- 3 ^2 \times 4 ^2 \times 5 ^2 $,这样就赢了.</p>
<ol>
<li>Bob令$AB + AC + BC = 0 , C = - \frac { AB  } { A + B  } $.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择$6 ^2 \times 7 ^3 $,两种情况如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) & = 0 \\
( x - 2 \times 6 ^2 \times 7 ^2 ) ( x + 3 \times 6 ^2 \times 7 ^2 ) ( x + 6 \times 6 ^2 \times 7 ^2 ) & = 0 
\end{aligned}</script><p>后来又找人讨论了一下这个是咋得出来的啊.考虑$ABC \ne 0 $,我们有的条件其实是$\frac { 1  } { A  } + \frac { 1  } { B  } + \frac { 1  } { C  } = 0 $.方程现在是$x ^3 + ( A + B - \frac { AB  } { A + B  } ) x ^2 - \frac { A ^2 B ^2  } { A + B  } = 0 $.不妨令$a = A + B , b = AB $,方程实际上是$x ^3 + ( a - \frac { b  } { a  } ) x ^2 - \frac { b ^2  } { a  } = 0 $.最好能让$a $小一点,因此我们不妨直接取$a = 1 $,此时$A = - n , B = n + 1 , C = n ( n + 1 ) $,只要能构造这样的两组$A , B , C $使得它们的$a _1 - \frac { b _1  } { a _1  } = - \frac { b _2 ^2  } { a _2  } $即可.直接造看上去没啥前途,但是不难发现$A = - nk , B = ( n + 1 ) k , C = n ( n + 1 ) k $依然合法.此时有$k _1 = a _1 , b _1 = - n ( n + 1 ) a _1 ^2 , k _2 = a _2 , b _2 = - n ( n + 1 ) a _2 ^2 $,我们有$a _1 ( n ^2 + n + 1 ) = - n ^2 ( n + 1 ) ^2 a _2 ^3 $.取$n = 2 $试试看!此时有$7 a _1 = - 36 a _2 ^3 $.取$a _2 = 7 , a _1 = - 6 ^2 \times 7 ^2 $,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4><p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外$3 $个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌$1 $个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5><p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4><p>有公式:</p>
<script type="math/tex; mode=display">
\sum _{ S \subseteq \{ 1 , 2 , \cdots , n \}  } ( P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 0 ) - P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 1 ) ) ^2 = 1</script><p>其中$f $是任意一个将$\{ 0 , 1 \} ^n \rightarrow \{ 0 , 1 \} $的函数,$\oplus $是二进制意义下的异或运算,$R $是$\{ 0 , 1 \} ^n $上的均匀分布,$R _i $表示第$i $位.再定义$\chi _S ( r ) = \prod _{ i \in S  } ( - 1 ) ^{ r _i  } $.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol>
<li><p>$\chi _S ( r ) \times \chi _S ( r ‘ ) = \chi _S ( r \oplus r ‘ ) $.</p>
</li>
<li><p>当$r \ne 0 $时,$\sum _{ S \subseteq \{ 1 , \cdots , n \}  } \chi _S ( r ) = 0 $.</p>
</li>
<li><p>$[ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] - [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 1 ] = ( - 1 ) ^{ f ( r )  } \chi _S ( r ) $.</p>
</li>
<li><p>证明原命题.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>(1)显然.</p>
<p>(2)也很经典,挑选一个$j $,使得$r _j = 1 $,然后所有的集合分为两类:一类是包含$j $,一类不包含,两类集合一一对应并且$\chi $互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到$P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 0 ) = \frac { 1  } { 2 ^n  } \sum _{ r  } [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] $,而$\sum _{ r  } [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] - [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 1 ] = \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) $,要证明的只是$\sum _{ S  } \frac { 1  } { 4 ^n  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 = 1 $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 \\
& = \sum _S \sum _{ r  } \sum _{ r '  } ( - 1 ) ^{ f ( r ) + f ( r ' )  } \chi _S ( r \oplus r ' ) \\
& = \sum _{ r  } \sum _{ r '  } ( - 1 ) ^{ f ( r ) + f ( r ' )  } \sum _S \chi _S ( r \oplus r ' ) \\
& = \sum _{ r  } 2 ^n & = 4 ^n 
\end{aligned}</script><p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4><p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于$50 \% $.</p>
<h5><span id="solution5">Solution5</span></h5><p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数$x $,然后随机一只手,看上面的数字$a $,如果$a \geq x $就认为$a $大,反之认为$b $大.只要随机到一个区间内的实数的概率不为$0 $即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4><p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5><p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令$p $为素数,把整个图形放大$p $倍(也就是长度$1 $变成长度$p $).下面把每个交叉点$( x , y ) $换成其整数部分$( \lfloor x \rfloor , \lfloor y \rfloor ) $,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被$p $整除.这样这个新的大矩形的面积也能被$p $整除,所以它的有一边长能被$p $整除.这条边只是被换成了它长度的整数部分,所以变化不超过$1 $,所以在放大之前这条边的长度和某个整数相差不超过$1 / p $.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有$2 $条边或者$4 $条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点$( x , y ) $染色:如果$x $是整数,染X颜色.如果$x $不是整数但$y $是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为$[ 0 , a ] \times [ 0 , b ] $,并假设$b $不是整数.把所有小矩形的下边界去掉,然后令$f ( t ) $为所有上边界$y $坐标不是整数,并且与直线$y = t $相交的小矩形的$x $方向边长之和.那么$f ( 0 ) = 0 $,而且当$f ( t ) $变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以$f ( b ) $是整数.而因为$b $不是整数,$f ( b ) $就是最靠上的所有小矩形的宽之和,等于$a $,所以$a $是整数.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2><h3><span id="分析状态">分析状态</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个$[ 1 , m ] $中的数字,然后进行以下判断:</p>
<ol>
<li><p>如果当前序列末尾两个数字相同且小于$t $,假设都是$x $,那就将它们都删去,加入一个$x + 1 $.</p>
</li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为$n $,终止操作.</p>
</li>
</ol>
<p>给定$n , m , t $,求最终序列的元素和的期望.</p>
<p>$n , m \leq 10 ^3 , t \leq 10 ^9 $.</p>
<p>首先$t \leq 10 ^9 $显然是没用的,因为它最多也就能这么凑:$m + n - 2 , m + n - 3 , \cdots , m , m $,合成一个$m + n - 1 $,因此我们令$t = \min \{ t , m + n - 1 \} $即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置$i $,有$a _i &lt; a _{ i + 1  } $,那么无论后面怎么做,这里的$a _i $都必不可能被删除.以此,我们不妨设$f _{ i , j  } $表示序列长度为$i $,序列开头元素为$j $的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过$t $,另一个是序列的长度不能超过$n $.我们不妨设$ans _{ n , t  } $表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移$ans $需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下$ans _{ n , t  } $,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有$ans _{ n , t  } = \sum _{ x = 1  } ^t E ( n 个 位 置 , 第 一 个 位 置 是 x 并 且 没 有 被 删 去 ) $.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:$3 , 3 , 3 $,最终的答案应该是$4 , 3 $.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了$3 , [ 3 , 3 ] $,最终的答案就变成了$3 , 4 $.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设$g _{ i , j  } $表示当前后面还有$i - 1 $个位置,当前前面已经放好了一个$j $,这个$j $不能被删掉的期望,显然有$ans _{ n , t  } = \sum _{ x  } ^t g _{ n , x  } P ( 最 终 序 列 中 , 这 里 是 k ) $,问题只在于如何求$g $.这个$g _{ n , k  } $是钦定了这个位置放$k $的期望,后面我们需要将它乘上这个位置放$k $的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个$g _{ n , k  } = ( k + \sum _{ j \ne k  } g _{ n - 1 , j  } ) $.但是实际上这个是不对的.这里的$k $不能删掉不意味着后面的$j $不能删掉,事实上后面的$j $爱怎么删怎么删,只要不搞出一个$k $来就可以.因此我们需要设$f _{ i , j  } $表示当前后面还有$i $个位置,第一个位置不能是$j $,也不能曾经是$j $(因为这里只要是$j $都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设$f _{ i , j  } $表示后面还有$i $个位置,第一个位置现在或曾经是过$j $的期望.那么全集是什么呢?全集是$ans _i $.</p>
<p>还没完啊,我们还需要求一下这里是$k $的概率,由于还有一个类似的$f $,我们还要求一下这里曾经是$k $的概率.设前者为$q _{ i , k  } $,后者为$p _{ i , k  } $.我们来强调一下这里设计的原则:这里的$p $其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了$k $,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过$k $了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是$k $等价于这里是$k $并且后面没有出现过$k $,也就是$q _{ i , k  } = p _{ i , k  } ( 1 - p _{ i - 1 , k  } \times [ k &lt; t ] ) $.这里加一个限制是因为有不能超过$t $的限制.</p>
<p>对于后者,这里的$k $有很多种可能出现过,一种是直接加入,一种是合并而来,于是$p _{ i , k  } = \frac { 1  } { m  } [ k \leq m ] + p _{ i , k - 1  } p _{ i - 1 , k - 1  } $.</p>
<p>因此我们几经辗转,终于得到了$g $的转移式子:</p>
<script type="math/tex; mode=display">
q _{ i , k  } g _{ n , k  } = p _{ i , k  } ( k + ans _{ i - 1  } - f _{ i - 1 , k  } p _{ i - 1 , k  } )</script><p>就差$f $了.$f $有两种可能:要么最后仍然是$k $,要么这个$k $已经被杀掉了.于是:</p>
<script type="math/tex; mode=display">
p _{ i , k  } f _{ i , k  } = q _{ i , k  } g _{ i , k  } + ( p _{ i , k  } - q _{ i , k  } ) f _{ i , k + 1  }</script><h5><span id="example2cf1007e">Example2(CF1007E)</span></h5><p>首先我们需要发现一个很强的性质:作用到了第$i $个站台就会清空前面所有站台.清空后就和$a _i $无关了,而如果还没涉及到一定和$a _i $有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设$f _{ i , j  } $表示只考虑前$i $个站台,要撑$j $个单位时间需要的最少火车数量.$g _{ i , j  } $表示只考虑前$i $个站台,要撑$j $个单位时间,并且$[ 1 , i - 1 ] $全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为$+ \infty $表示无法满足(对于全局,我们在$n + 1 $处放一个$a = + \infty , b = 0 , c = + \infty $来保证一定会满载).为什么需要$g $作为辅助dp数组呢?我们先对着$f $分析.</p>
<p>考虑$f _{ i , j  } $的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前$j $轮中根本没接走站台$i $的人.此时需要满足$f _{ i - 1 , j  } \ne + \infty \land a _i + j \times b _i \leq c _i $.那么这里怎么更新$g $呢?设$L = sa _{ i - 1  } + sb _{ i - 1  } \times j $,显然$g _{ i , j  } = \lceil \frac { L  } { K  } \rceil $,并且需要保证此时没有用到$i $以后的站台,因此需要保证$\lceil \frac { L  } { K  } \rceil K \leq sa _{ i  } + sb _i \times j $.注意到由于这里保证了$f _{ i - 1 , j  } $是可以取到的,因此我们可以撑到第$j $秒,剩下的火车在$j + \varepsilon $秒全选.</p>
<p>第二种,前$j $轮中有火车接走站台$i $的人.设最后一次是在$r $时间接走的站台$i $,那么此时必然清空了$[ 1 , i - 1 ] $,这里用了$g _{ i , r  } $.然后为了防止这里在$[ r + 1 , j ] $这段时间中爆掉,因此还需要$w = \lceil \frac { \max \{ 0 , rem + ( j - r ) b _i - c _i \}  } { K  } \rceil $,其中$rem $是$r $时刻$i $剩下的人数.这些火车都要在$r $时刻之前解决(因为我们设了最后一次在$r $时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在$r $这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有$wK \leq rem $.但是,接下来在$[ r + 1 , j ] $时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设$f _{ i , j , 0  } $表示只考虑前$i $个站台,要撑$j $个单位时间需要的最少火车数量,但是$[ 1 , i ] $都被清空为$0 $过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol>
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p>
</li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将$g _{ 1 , t , 0 / 1  } $全部设为$0 $,因为我觉得无论如何$0 $位置都是清空的,但实际上这是错误的!因为在$t $时刻的$1 $位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前$i $个的合法性,并且如果我们想要让$i $位置合法,一定要求让$[ 1 , i - 1 ] $合法.</p>
</li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从$r \rightarrow t $这个过程中会积累的量,这些量必然要在$r $时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p>
</li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3><h5><span id="example1">Example1</span></h5><p>定义一个有根树为大菊花,当且仅当这棵树的根的度数$\leq m \land \nexists x \ne root , \deg ( x ) &gt; 2 $.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.$( n \leq 5 \times 10 ^5 , m \leq 50 ) $</p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到$O ( nm ^2 ) $.</p>
<p>注意到这个背包是可删除的,所以就能做到$O ( nm ) $.</p>
<h3><span id="dp分界点">dp分界点</span></h3><h4><span id="example12022zrtg十连测day7-permutation">Example1(2022zrtg十连测day7 Permutation)</span></h4><p>首先注意到$[ 3 , n ] $一定会被分成两段递减的序列,分别跟在$1 $和$2 $的后面,假设$1 $在$2 $前面,这样算出答案后乘以$n $即可.</p>
<p>注意到$i + 1 $一定可以放到$i $的前面,设$f _i $表示在$i $和$i + 1 $之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即$i $的倍数$\pm 1 $之类的,于是可以实现,复杂度$O ( n \ln n ) $.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3><h4><span id="example1cf1666e">Example1(CF1666E)</span></h4><p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i $条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i $表示第$i $个分界点可能的最小值,$g _i $表示第$i $个分界点可能的最大值.假设我们目前二分的最大值要小于等于$mx $,最小值要大于等于$mn $,那么我们有转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1  } & = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } & = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}</script><p>注意到$f $与$g $的转移是无关的,而显然对于第$i $个分界点,它可以取$[ f _i , g _i ] $中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans _{ i  } $表示第$i $条分界线是啥,那么我们$ans _i $是可以取$[ ans _{ i + 1  } - mx , ans _{ i + 1  } - mn ] $中的任何一个数字的,我们将其和上面求出的$[ f _i , g _i ] $求一下交集.如果交集为空,说明要么$ans _{ i + 1  } - mn &lt; f _i , f _{ i + 1  } &lt; ans _{ i + 1  } &lt; f _i + mn $,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差$\leq mx - mn $.</p>
<h3><span id="数位dp">数位dp</span></h3><h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4><p>首先设$f _{ i , j  } $表示长度为$i $的,以$S [ n - j + 1 . . . n ] $为子序列的字符串个数.</p>
<p>考虑按位处理,每次将$T $的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出$k $.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为$k $.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4><p>第一反应就是枚举$x ‘ $和$y ‘ $,然后用数位dp枚举$d $使得$x = dx ‘ , y = dy ‘ $.</p>
<p>但是有一个问题在于如果$\gcd ( x ‘ , y ‘ ) \ne 1 $怎么办,这样有可能会算重.我们发现我们只判断$\gcd ( x ‘ , y ‘ ) = 1 $的情况就行,然后写一个$2 ^8 $判断$x ‘ , 2 x ‘ , 3 x ‘ , 4 x ‘ $以及对应的$y ‘ $出现了没有.复杂度$( 9 ^4 \times 2 ^8 \times \log _{ 10  } n ) $,有点难过.</p>
<p>但是我们发现这个$2 ^8 $可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有$3 ^4 \times 2 $的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3><h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4><p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是$O ( nd ^2 ) $的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是$O ( nd ) $的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取$\min $转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3><h4><span id="example1">Example1</span></h4><p>现在有一个$[ 1 , n ] $的排列,现在要从中选出一个集合$S $,满足$\forall x \in S , 2 x \notin S , 3 x \notin S $,求方案数.</p>
<p>首先考虑将每个数分解为$a \times 2 ^b \times 3 ^c $的形式,显然$a $不相同的数之间互不干扰.</p>
<p>对于$a $相同的一群数,我们考虑将$( b , c ) $作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3><h4><span id="example1">Example1</span></h4><p>$n $个点的树,一开始位于一号点,每个点有一个颜色($0 $或$1 $),每次随机选择一个点$v $,从当前所在点移动到$v $并将$v $的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为$1 $,当然不为$1 $也能做).</p>
<p>$n \leq 100000 $.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是$1 $还是$0 $就可以.不妨设$f _{ i  } $表示当前有$i $个点是$1 $,最后全$1 $或者全$0 $所需要的期望步数,显然$f _0 = f _n = 0 $,$f _{ i  } = \frac { 1  } { 2  } ( f _{ i + 1  } + f _{ i - 1  } ) + 1 $.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在$u $,只要当前没有结束,我们还要选点$v $,对答案的期望的贡献就是$u $到这棵树上所有点的距离之和除以$n $,而这是一个定值.也就是说,只要我们统计一下到了每个点$u $多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设$f _{ i , j , 0 / 1  } $表示当前场面上有$i $个$1 $,$j $号点这里是$0 $还是$1 $,它在结束前能被期望选多少次,注意$f _{ n / 0 , j , 0 / 1  } = 0 $.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设$f _{ i , 0 / 1  } $表示当前有$i $个$1 $,$0 / 1 $染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ 0 / n , 0 / 1  } & = 0 \\
f _{ i , 0  } & = \frac { i  } { n  } f _{ i - 1 , 0  } + \frac { n - i - 1  } { n  } f _{ i + 1 , 0  } + \frac { 1  } { n  } ( f _{ i + 1 , 1  } + [ i + 1 \ne n ] ) \\
f _{ i , 1  } & = \frac { i - 1  } { n  } f _{ i - 1 , 1  } + \frac { n - i  } { n  } f _{ i + 1 , 1  } + \frac { 1  } { n  } ( f _{ i - 1 , 0  } + [ i - 1 \ne 0 ] ) 
\end{aligned}</script><p>为啥最后加上了$[ i + 1 \ne n ] $呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了$f _{ i , 0 / 1  } $和$f _{ i - 1 , 0 / 1  } $,我们发现我们可以用这两个方程求出$f _{ i + 1 , 0 / 1  } $,然后就比较典了:我们将所有的函数表示成$af _{ 1 , 0  } + bf _{ 1 , 1  } + c $的形式(之所以这么表示,是因为我们架设了$f _{ 1 , 0 / 1  } $已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出$f _{ n , 0 / 1  } $,而$f _{ n , 0 / 1  } $我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3><h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4><p>首先注意到,$a _i = 1 $的时候和$a _i \ne 1 $的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设$f _i $为$a _i = 1 $,而其他$a $全都为$0 $时的答案,不难发现最后的答案也就是$\sum { a _i f _i  } $.</p>
<p>而上面的转移自然是:$f _i = \min \{ b _i , w + \sum _{ j = l  } ^r f _j \} $.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次$f _i $最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查$\log n $次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3><h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5><p>考虑组合意义,$\sum a _i ^2 $的意义也即满足操作序列$u $和操作序列$v $的最终结果相同的二元组$( u , v ) $的数量.</p>
<p>不妨设$dp _{ i , j , k  } $为第一个装置上方已经动了$i $个珠子,下放动了$j $个珠子,第二个装置上方动了$k $个珠子,下方动了$i + j - k $个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然$dp _{ n , m , n  } $即答案.</p>
<h5><span id="example2">Example2</span></h5><p>求长度为$n $的排列的$( \sum _{ i = 2  } ^{ n - 1  } [ a _i &lt; a _{ i - 1  } \And a _i &lt; a _{ i + 1  } ] ) ^k $的期望$( n \leq 10 ^9 , k \leq 500 ) $.</p>
<p>$O ( n ^2 k ^2 ) $是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是$\sum ans ^k $,而加入$1 $的时候,对于每个长度为$n - 1 $的排列,有$( n - 2 - 2 ans ) $个位置加入后会使答案加一,那我们要求的也就是:</p>
<script type="math/tex; mode=display">
\sum ( n - 1 - 2 ans ) ( ans + 1 ) ^k + \sum ( 2 ans + 2 ) ans ^k</script><p>推一推式子就可以做到$O ( nk ^2 ) $,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,$ans ^k $等价于从所有的地方中可重复地选出$k $个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为$1 $的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设$f _{ i , j  } $表示已经选了$i $段波动序列,其中有$j $个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度$O ( k ^3 ) $.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3><h4><span id="example1">Example1</span></h4><p>求$\sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( a _i \oplus a _j ) ^2 $,$n \leq 10 ^5 $,$a _i \leq 10 ^9 $.</p>
<p>考虑设$f _i $表示只考虑前$i $低的位置,高位全部默认为$0 $的方案数.如果我们设$cnt _i $表示$a $中第$i $位为$1 $的数个数,那根据$( a + b ) ^2 = a ^2 + 2 ab + b ^2 $,我们只需要求出$g _{ i  } $表示只考虑前$i $低的位置,第$i + 1 $位是$1 $的数和第$i + 1 $位是$0 $的数两两异或之和,显然有$f _i = f _{ i - 1  } + 2 cnt _i \times 2 ^i \times g _{ i - 1  } + cnt _i 2 ^{ i + 1  } $.</p>
<p>$g $可以用$O ( n \log a ) $的复杂度求,这样总复杂度$O ( n \log ^2 a ) $.</p>
<h3><span id="线头dp">线头dp</span></h3><h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5><p>令$dp _{ i , j , k  } $表示目前倒到第$i $个水杯,前面还有$j $个延续过来的未结束的线头,目前已经选定了$k $个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是$O ( n ^5 ) $的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了$O ( n ^4 ) $的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5><p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设$dp _{ i , 0 / 1 / 2  } $表示前$i $个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212-svjetlo">Example3([COCI2020-2021#2] Svjetlo)</span></h5><p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设$dp _{ u , 0 / 1 , 1 / 2  } $为$u $的状态为$0 / 1 $,以$u $为根的子树内有$1 / 2 $个线头的方案数.注意如果子树内有$0 / 2 $个线头,那么会在$u $处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此$dp _{ u , s , 2  } $的两个接头实际上一个位于$u $,另一个位于$u $的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5><p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设$dp _{ i , j , k  } $表示目前走到$i $,前面分成$j $组,总贡献不超过$k $的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489-jtravel-in-sugar-country">Example5([XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain contest 1489) J]Travel in Sugar Country)</span></h5><p>一条线段上有$n ( \leq 100 ) $个商店,要从中选出$k ( \leq 10 ) $个不同的商店$s _1 , s _2 , \cdots , s _k $,使得按顺序遍历这$k $个商店的路径长度是$m ( \leq 30 ) $的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设$dp _{ i , j , w , l  } $表示目前在判断了$i $个商店,选了$j $个,并且目前整个图有$w $条”路径”(连续走动),走过的路在$\bmod m $一意义下为$l $的方案数.最后的答案就是$dp _{ n , k , 1 , 0  } $.</p>
<p>首先,我们对每个点求出$D ( 1 , x ) $,然后$D ( x , y ) = | D ( 1 , y ) - D ( 1 , x ) | $,不难发现$x $越大$D ( 1 , x ) $越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的$D $和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径($s _1 \rightarrow s _1 $),接下来,我们每插入一个点$x $,我们考虑它的贡献:</p>
<ol>
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是$- 2 D ( 1 , x ) $,对方案数的贡献为$1 $.</p>
</li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为$0 $.</p>
</li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为$2 D ( 1 , x ) $.</p>
</li>
</ol>
<p>这样我们就做到了$O ( n ^4 km ) $的复杂度.如果我们加两维$0 / 1 $表示目前起点和终点是否加入,就可以把复杂度优化到$O ( n ^2 km ) $.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3><p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4><p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3><p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4><p>先考虑数字两两不同的时候怎么做,我们先找到$A $中的全局最大值所在位置和$B $中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时$A $取出的数量和$B $的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把$B $序列分成两部分,这两部分将由$A $中相等的两部分分别生成.不妨假设这个全局最大值的位置是$x $,那么对于$[ 1 , x ] $这一段的$A $生成的$B $数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的$A $能生成的$B $的数量.对于$[ 1 , x + 1 ] $则任意.</p>
<p>那么我们所需要做的就是求出$A $的某一段删掉若干次最大值后的序列所能生成的$B $的数量.不妨设$dp _{ l , r , i  } $表示$[ l , r ] $中所有$\leq i $的数字组成的序列所能生成的数量.</p>
<p>如果$[ l , r ] $这段区间中没有数字$i $,那显然$dp _{ l , r , i  } = dp _{ l , r , i - 1  } $,不然,我们可以枚举两端分开的位置,那这个位置一定在数字$i $的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4><p>注意到第$n $个元素一定是山峰.所以我们考虑用第$n $个元素分割整个区间为两部分.</p>
<p>设$f _n $为$n $个元素且开头为山谷的答案.枚举第$n $个元素在位置$k $($k - 1 $是奇数),则$f _k f _{ n - 1 - k  } \binom { n - 1  } { k  } \rightarrow f _n $.</p>
<h4><span id="example3">Example3</span></h4><p>给定数组$a $,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.$n \leq 500 $.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设$f _{ l , r  } $为将$[ l , r ] $删干净后再去删$a _{ l - 1  } , a _{ r + 1  } $的方案数,然后枚举$[ l , r ] $中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairing-points">Example4([AGC039E] Pairing Points)</span></h4><p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从$1 $号点这里断开,枚举$1 $号点连接哪个点,然后就可以让$( 2 , 2 n ) $这些点断开了.我们设计$f _{ i , j , k  } $或$[ i , j ] ( k ) $表示区间$[ i , j ] $中的$k $向外连了一条边.答案是枚举$1 $号点连了哪个点,也就是$\sum _{ i = 3  } ^{ 2 n - 1  } f _{ 2 , 2 n , i  } $.</p>
<p>于是我们现在的问题在于如何求$f _{ i , j , k  } $.由于边要联通,所以与$k $相连的这条边必然被$[ i , j ] $中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为$x \leftrightarrow y $.这样整个区间被分为了两个部分:$[ i , k ] ( x ) , [ k , j ] ( y ) $.但是问题并没有得到解决.因为$[ i , x ] $和$[ y , j ] $之间的确不可能出现连边了,但$[ x , k ] $和$[ k , y ] $之间仍然可能出现连边.但我们发现:在$[ i , k ] $中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为$p , q $.现在整个区间被分为了三个部分:$[ i , p ] ( x ) , [ p , q ] ( k ) , [ q , j ] ( y ) $,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-and-remove">Example5([AGC035D] Add and Remove)</span></h4><p>首先自然想到区间dp.但是难以处理的是如果一个区间$[ l , r ] $中间删掉一个点$p $之后,$[ l , p - 1 ] $和$[ p + 1 , r ] $会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到$[ l + 1 , r - 1 ] $中最后删除的点$p $,这样区间$[ l , r ] $的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除$[ l + 1 , p - 1 ] $的时候,对$p $产生的贡献和删除$[ p + 1 , r - 1 ] $的时候对$p $的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设$a _l $贡献了$x $倍,$a _r $贡献了$y $倍,那么由于$a _p $会两边都贡献到,所以$a _p $会对答案贡献$x + y $倍.</p>
<p>于是设计一个dp是:$f _{ l , r , x , y  } $表示删除$[ l + 1 , r - 1 ] $后,$xa _l + ya _r $最小是多少.自然有$f _{ l , r , x , y  } = \min \{ f _{ l , p , x , x + y  } + f _{ p , r , x + y , y  } + ( x + y ) a _p \} $.</p>
<p>至于复杂度,前两维肯定是$n ^2 $的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移$n $层,因此是$2 ^n $的空间,于是时间复杂度不会超过$O ( n ^3 2 ^n ) $,其实经过一些奇怪计算应该是不会超过$O ( 2 ^n ) $的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4><p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设$f _{ l , r  } $表示删除$[ l , r ] $区间的代价.接下来我们无非要枚举$k $,使得$k $是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如$l $,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果$a _l = a _k $,那么这等价于$f _{ l + 1 , k - 1  } + [ l = k - 1 ] + f _{ k + 1 , r  } $.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4><p>首先考虑一下$m = 2 ^k - 1 $的情况,首先我们要判断有几个数最高位是$1 $,然后接下来判断第二位哪些数字是$1 $.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是$1 $的就一定大于最高位是$0 $的了,这两个区间就没有影响了.因此可以设$f _{ l , r , k  } $表示$[ l , r ] $这个区间,前面已经有了$k $个$1 $的最大贡献.</p>
<p>那么对于$m \ne 2 ^k - 1 $的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过$m $就行了.</p>
<h3><span id="相互独立">相互独立</span></h3><h5><span id="example12019zrtg十连测day1-origami">Example1(2019zrtg十连测day1 origami)</span></h5><p>看上去很不好做,先考虑宽为$1 $怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间$[ l , r ] $,然后看$[ 1 , l - 1 ] $和$[ r + 1 , m ] $能不能折进来.也就是判断以$r $和$r + 1 $为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设$f _i $表示能不能折成以$[ 1 , i ] $为最下层,$g _i $表示能不能折成$[ i , n ] $为最下层,那$[ l , r ] $能折出来当且仅当$f _r = g _l = 1 $,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-an-edge">Example2(CF1616G Just Add an Edge)</span></h5><p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如$1 \rightarrow x \cup y \rightarrow n $,并且$1 \rightarrow x $和$y \rightarrow n $不交,然后添加边$x \rightarrow y $.</p>
<p>那么什么时候$1 \rightarrow x $和$y \rightarrow n $没有交并且他们的并是$[ 1 , n ] $呢?考虑将$1 \rightarrow x $这条路径上的点染色为$0 $,$y \rightarrow n $上的点染色为$1 $,由于边只有从前往后的,因此$[ 1 , y - 1 ] $必然为$0 $,$[ x + 1 , n ] $必然为$1 $.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了$y $,现在想要找到$x $,我们现在假设染色的末尾是$( i , i + 1 ) $,也就是$i $染色和$i + 1 $的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个$p $,满足$p \nrightarrow p + 1 $,那么$p $和$p + 1 $永远不可能染同种颜色,我们直接以它为断点,自然发现$p $的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了$p \rightarrow p + 1 $这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立$0 $和$n + 1 $两个虚点,向所有点连边.</p>
<p>总之$O ( nm ) $的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3><p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5><p>首先考虑已知一个序列,如何快速求它最后有几个位置不是$0 $.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其$- 1 $并重复判断操作,直到为$0 $或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是$0 $相当于判断后面的已知序列的$mex $,这个要记入状态中,于是考虑设$dp _{ i , j  } $表示当前到了第$i $个位置,后面的数的$mex - 1 $是$j $的方案数.</p>
<p>但是如果直接这么设会发现,当前$i $的加入有可能会改变$mex $的值,而这个改变是很难处理的,因为如果$i $位置选择了$j + 1 $这个数字,那么$mex $要向上伸展到某一个值,而如果不选择$j + 1 $,也有可能选择一个更大的值后不断落到$j + 1 $,这意味着我们转移时需要枚举补上$j + 1 $这个数字后的$mex $并用刷表法转移.</p>
<p>不妨设这个数字是$k $.如果我们插入一个数字后直接更新当前的答案,可以发现这个$k $是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起$mex $的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全$[ j + 2 , k ] $这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以$2 ^{ n  } $.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5><p>$O ( n ^3 ) $的暴力是显然的:设$f _{ i , j , k  } $表示目前考虑到第$i $个位置,前面还有$j $个A,已经选了$k $个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到$n ^2 $.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设$f _{ i , j  } $表示目前考虑到$i $,还需要$j $个B才能凑齐$c _B $个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3><h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5><p>设$f _{ i , j  } $表示长度为$i $,开头为山峰且高度为$j $的方案数;$g _{ i , j  } $表示长度为$i $,开头为山谷且高度为$j $的方案数.注意到这俩显然是一个双射,也就是$f _{ i , j  } = g _{ i , i - j + 1  } $.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于$j $的数都向上平移一格,于是自然有:$f _{ i , j  } = \sum _{ k = 1  } ^{ j - 1  } g _{ i - 1 , k  } = \sum _{ k = 1  } ^{ j - 1  } f _{ i - 1 , i - k  } $.</p>
<p>另外,这个式子可以稍微转化为:$f _{ i , j  } = f _{ i - 1 , i - j + 1  } + f _{ i , j - 1  } = g _{ i - 1 , j - 1  } + f _{ i , j - 1  } $.</p>
<p>上式可以这么理解:我们讨论一下$j $和$j - 1 $是否相邻,如果相邻必然是$j $是山峰,$j - 1 $是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1-group">Example2(2019zrtg十连测day1 group)</span></h5><p>首先注意到$2 k \leq n \land nk \leq 10 ^5 $,不难发现$k \leq 500 $.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到$O ( nk ^2 ) $.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点$w $,使得成为组长的经验$\geq w $,成为组员的经验$\leq w $,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5><p>双序列计数,考虑把$x $双射到某个东西上.</p>
<p>考虑最后的图一定是个$DAG $,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设$dp _{ l , r , mx  } $表示只考虑$[ l , r ] $这一段的线段,然后最大值所在位置需要$\geq mx $的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3><p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweighted-increasing-subsequences">Example1([CF1621G]Weighted Increasing Subsequences)</span></h5><h2><span id="动态规划的优化">动态规划的优化</span></h2><h3><span id="递进转移">递进转移</span></h3><p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5><p>有$m $种礼物,每种礼物有无数个(有有限个也能做),$n $个朋友,第$i $个朋友喜欢第$j $个礼物的概率是$p _{ i , j  } $,$\forall i , \sum p _{ i , j  } = 1 $.</p>
<p>现在你可以选$n $件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p>$n \leq 3000 , m \leq 300 $.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出$g _{ i , j  } $表示第$i $种礼物一共选了$j $个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么$g $怎么求呢?这个是简单的,我们设$f _{ i , j  } $表示喜欢第$i $种礼物的人有$j $个的概率,不难发现$g _{ i , j  } = \sum _{ k = 0  } ^n \min \{ j , k \} f _{ i , k  } $.递推式就有$g _{ i , j  } = g _{ i , j - 1  } + \sum _{ k = j  } ^n f _{ i , k  } $.$f $同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是$O ( n ^2 m ) $的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现$g _{ i , j  } $满足四边形不等式,而其转移是经典的$k $点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于$g _i $是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为$c _i $,每次选当前$g _{ i , c _i + 1  } - g _{ i , c _i  } $最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为$c _i $越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度$O ( n ^2 \log n ) $,不太确定有没有$O ( n ^2 ) $的做法.</p>
<p>但是第二个背包,也就是$f $怎么求呢?我们发现我们没有必要把$g $全都求出来,只需要求目前需要的一部分就可以了,由于$\sum f = 1 $,因此后缀和可以改为前缀和,考虑到每往后推一位是$O ( n ) $的,但是只会往后推总共$O ( n ) $位,因此这里复杂度$O ( n ^2 ) $.</p>
<h5><span id="example2">Example2</span></h5><p>给一个字符串,求一个最大长度$L \leq \frac { n  } { 2  } $,使得前$L $个字符与后$L $个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<script type="math/tex; mode=display">
ABSBA</script><p>我们枚举$A $的长度,然后就只需要求$B $,设$f _{ i  } $表示字符串去掉开头和结尾的$i $个字符后的border,有$f _{ i - 1  } \leq f _i + 1 $.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3><p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4><p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k $暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取$\max $操作很艰难.但如果!我把这个dp反过来,我设$f _{ i , j  } $表示<strong>从后往前</strong>dp到$i $,当前的最大前缀和是$j $的概率是多少,这个dp的转移极其简单:</p>
<script type="math/tex; mode=display">
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  }</script><p>最后在$f _{ 1 , j  } $处乘上$h _j $.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g _{ i , j  } $表示如果初始只有$f _{ i , j  } = 1 $,dp到最后的答案是多少.于是只需要:</p>
<script type="math/tex; mode=display">
\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g _{ i , j  } \\

\end{gathered}</script><p>我认真考虑过这个$P $应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些$P $变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3><h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4><p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于$200 $.也就是说转移矩阵大概是$200 \times 200 $的,设状态数为$S $.</p>
<p>继续考虑,如果直接做的话复杂度是$O ( TS ^3 \log n ) $,过不了.</p>
<p>我们考虑将一个$n $在$w $进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了$O ( wS ^3 \log _w n + TS ^2 \log _w n ) $,平衡一下复杂度即可,大概取$w = 4 $会比较优秀.</p>
<h4><span id="example2noi-online3提高组魔法值">Example2([NOI Online#3提高组]魔法值)</span></h4><p>重新定义矩阵乘法:用$\oplus $替换原本的$+ $,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4><p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令$f _i = \sum _{ j , a _j = a _i - 1  } f _j $,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的$\sum $的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的$f $.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设$f _{ i , j  } $表示所有$a _x = i $的$x $中第$j $小的$x $的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4><p>注意到$m $和$k $很小,这一定是突破口.</p>
<p>又注意到如果$a _{ i + 1  } &gt; a _i $,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字$x + 1 $,我们考虑它只能插入$[ x + 1 - m , x ] $后面,我们直接用一个二进制数$S $表示$[ x + 1 - m , x ] $中的数字是否存在,然后就可以在转移上直接调用$popcount ( S ) $.设$dp _{ i , j , S  } $表示目前考虑完了数字$i $,插入了$j $个数字,存在情况是$S $.直接对它做矩阵加速就可以做到$O ( ( 2 ^m k ) ^3 \log n ) $.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4><p>设$dp _{ i , j  } $表示第$i $天走到城市$j $的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上$k $.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3><p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4><p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设$f _{ l , r  } $表示$a _l $和$a _r $必选的前提下,$[ l , r ] $这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设$dp _{ i , j  } $表示前$i $个点,最大值为$j $的方案数,不难发现最后一个矩阵的最小值一定是$a _{ i  } $.然后$dp _{ a , b  } = \sum _{ i &lt; a , j &lt; b  } dp _{ i , j  } f _{ i + 1 , a  } $.</p>
<p>这个转移是$n ^4 $的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到$n ^2 $,这样我们就得到了一个复杂度$O ( n ^3 ) $的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点$i $,它所在矩阵的最左边的点$k $,最右边的点$k $,然后此时的答案为$pre [ j - 1 ] [ a [ k ] - 1 ] \times nxt [ k + 1 ] [ a [ j ] + 1 ] \times f [ j ] [ i ] \times f [ i ] [ k ] $.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设$g _{ i , j  } $为接下来我们要选$[ i , j ] $,$i $是矩阵左端点,$j $任意且这两个点必在矩阵中,左右两边的方案数.初始条件$g _{ i , j  } = pre [ i - 1 ] [ a [ j ] - 1 ] \times nxt [ j + 1 ] [ a [ i ] + 1 ] $.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3><h4><span id="example2022zrtg十连测day7-zero">Example(2022zrtg十连测day7 Zero)</span></h4><p>设$k = \max \{ i , j \} $,首先可以求出$x , y , z $分别表示:</p>
<ol>
<li><p>$x $:只包含第一行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
<li><p>$y $:只包含第二行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
<li><p>$z $:同时包含两行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
</ol>
<p>那么自然有转移:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z , z ) + 1 \} 
\end{gathered}</script><p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到$f ( i , k ) $关于$i $不降,于是显然当$f ( i , y ) \ne f ( i , k - 1 ) $的时候才会由$f ( i , y ) + 1 $转移过来.我们不妨设$p _i $表示最小的位置满足$f ( i , p _i ) = f ( i , k - 1 ) $,那转移也就是$f ( i , k ) \leftarrow f ( i , k - 1 ) + [ p _i \leq y ] $.并且每进行一次转移,都会满足$p _i \leq y $的$p _i $设为$k $.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的$i $在当前$k $的$f $值,将这个点放到$p _i $位置上.然后我们每次找到$y $并把所有在$y $位置前的点都合并到$k $这个点上,并打一个加法$tag $,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的$p _k $.</p>
<p>最后还需要处理一下$f _{ k , k  } $,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照$\max \{ i , j \} $为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3><p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5><p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是$\nexists 1 \leq i &lt; j &lt; k \leq n $,$a _i &gt; a _j &gt; a _k $.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是$dp _{ i , j  } $表示现在做到$i $,另一个上升子序列的终点是$j $,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在$i $一定的情况下,$j $的值越小越容易满足.所以设$dp _i $表示一个上升子序列的终点是$i $,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5><p>首先自然的设计是$dp _{ l , r , u , d  } $,然后优化一下就是$O ( n ^4 ) $.然后咋做?</p>
<p>注意到答案不超过$\log $级别,所以设$dp _{ l , r , u , c  } $表示答案为$c $的时候,最大的$d $是多少.然后就$O ( n ^3 \log n ) $.</p>
<h5><span id="example3">Example3</span></h5><p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数$a _i $减去$[ 1 , a _i ] $中的一个数字,减成$0 $就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.$( n \leq 2000 ) $</p>
<p>先考虑一个$O ( n ^2 a ^2 ) $的dp,比较显然,因为一个人取数显然要么取$1 $要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设$dp _{ l , r , x , y  } $表示目前Alice在取第$l $堆,Bob在取第$r $堆,第$l $堆为$x $,第$r $堆为$y $的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把$a $存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是$1 $还是更大的数好像无所谓.那:如果$a _1 = x $的时候,Alice能赢,那$a _1 = x + 1 $的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选$1 $,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于$a _l $或$a _r $.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存$0 / 1 $是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设$dp _{ l , r  } $表示当前Alice在$l $,Bob在$r $,Bob还没动$a _r $的前提下,$a _l $至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较$dp _{ 1 , 1  } $和$a _1 $的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选$l $,Bob开始选$r $,那Alice的获胜条件显然是$dp _{ l , r  } \leq a _r $</p>
<p>如果可以全选(也就是Alice开始选$l + 1 $,Bob开始选$r $的时候Alice能赢),就直接让$dp _{ l , r  } = 1 $.不然,由于清空堆的人要输,所以Alice为了不输,必须要让$dp _{ l , r - 1  } $也满足条件,一个自然的想法是$dp _{ l , r - 1  } + a _r + 1 $,但是这个值好像没有必要:因为Bob并不是只有会不断清空$a _r $的,如果目前的$[ l + 1 , r ] $这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢$[ l + 1 , r ] $的值,Bob就必须全清空,所以如果我们设$g _{ l , r  } $是Bob的$dp $数组,那其实这里应该是$a _r + 1 + dp _{ l , r - 1  } - g _{ l + 1 , r  } $,因为Bob的策略一定是一步一步走到$g _{ l + 1 , r  } $后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5><p>自然的想法是$dp _{ i , j  } $表示$i $子树内划分成$j $个连通块是否合法,然后我们发现如果$j $满足条件,那么$j + 2 $一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3><p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于$y $轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5><p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3><p>能用WQS二分解决的问题通常形如:需要在$n $个物品中选择恰好$m $个,使得最后答案最大.并且如果令$f _i $表示选了$i $个的最大答案,$f _i $必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数$C $,每选择一个物品就减去$C $的答案.不难发现这样我们一定能逼近$f _m $.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3><p>对于定义在$\mathbb { Z  } $上的二元函数$w $,若对定义域上任意$a , b , c , d ( a \leq b \leq c \leq d ) $都有$w ( a , c ) + w ( b , d ) \leq w ( a , d ) + w ( b , c ) $,也就是交叉小于包含,则称函数$w $满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:$w $所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于$0 $.</p>
<p>如果它还满足$\forall 1 \leq l ‘ \leq l \leq r \leq r ‘ \leq n , w ( l , r ) \leq w ( l ‘ , r ‘ ) $，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理$\min $型dp的问题,对于$\max $型dp需要取相反数改成$\min $.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4><h5><span id="定理1">定理1</span></h5><p>若二元函数$w ( x , y ) $满足$w ( a , b ) + w ( a + 1 , b + 1 ) \leq w ( a , b + 1 ) + w ( a + 1 , b ) $.其中$a &lt; a + 1 \leq b &lt; b + 1 $,则$w $满足四边形不等式.</p>
<p>证明:</p>
<p>对于$a + 1 &lt; c $ 有</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) \\
w ( a + 1 , c + 1 ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\

\end{aligned}</script><p>同时有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) & \leq w ( a + 1 , c + 1 ) + w ( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) & \leq w ( a + 1 , c + 1 ) \\

\end{aligned}</script><p>联立得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) & \leq w ( a + 1 , c ) + w ( a + 2 , c + 1 ) 
\end{aligned}</script><p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个$2 \times 2 $的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5><p>若$w _1 ( l , r ) , w _2 ( l , r ) $满足四边形不等式(或区间包含单调性),则$\forall c _1 , c _2 \geq 0 $,$( c _1 w _1 + c _2 w _2 ) $满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5><p>若$\exists f ( x ) , g ( x ) $使得$w ( l , r ) = f ( r ) - g ( l ) $,则$w $满足四边形恒等式.当$f , g $单调递增时,$w $还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5><p>设$h $是一个单调递增的下凸函数(一阶导数单调递增),若$w ( l , r ) $满足四边形不等式和区间包含单调性,则复合函数$h ( w ( l , r ) ) $也满足四边形不等式和区间包含单调性.</p>
<p>令$l _1 \leq l _2 \leq r _1 \leq r _2 $,由于$w $满足四边形不等式,于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( l _1 , r _1 ) + w ( l _2 , r _2 ) & \leq w ( l _1 , r _2 ) + w ( l _2 , r _1 ) \\
0 & \leq w ( l _1 , r _1 ) - w ( l _2 , r _1 ) & \leq w ( l _1 , r _2 ) - w ( l _2 , r _2 ) 
\end{aligned}</script><p>令$t = w ( l _1 , r _2 ) - w ( l _2 , r _2 ) $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( l _1 , r _1 ) & \leq w ( l _2 , r _1 ) + t \\
w ( l _1 , r _2 ) & = w ( l _2 , r _2 ) + t \\
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq h ( w ( l _2 , r _1 ) + t ) - h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) & = h ( w ( l _2 , r _2 ) + t ) - h ( w ( l _2 , r _2 ) ) 
\end{aligned}</script><p>不妨令$\Delta h ( x ) = h ( x + t ) - h ( x ) $,由于$h $是下凸函数,所以$\Delta h $函数单调递增.</p>
<p>那么也就有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq \Delta h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) & = \Delta h ( w ( l _2 , r _2 ) ) 
\end{aligned}</script><p>由于$w ( l _2 , r _1 ) \leq w ( l _2 , r _2 ) $,所以$\Delta h ( w ( l _2 , r _1 ) ) \leq \Delta h ( w ( l _2 , r _2 ) ) $于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) \\
h ( w ( l _1 , r _1 ) ) + h ( w ( l _2 , r _2 ) ) & \leq h ( w ( l _1 , r _2 ) ) + h ( w ( l _2 , r _1 ) ) 
\end{aligned}</script><p>证毕.</p>
<h5><span id="定理5">定理5</span></h5><p>设$h $是一个下凸函数(一阶导数单调递增),若$w ( l , r ) $满足四边形恒等式和区间包含单调性,则复合函数$h ( w ( l , r ) ) $也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到$h $单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4><p>对于形如$f _i = \min _{ 1 \leq j &lt; i  } \{ f _j + w ( j , i ) \} $的状态转移方程,记$p _i $为$f _i $的最优决策.若$p $在$[ 1 , n ] $上单调不降,则称$f $具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的$\min $改为$\max $,并且把$+ w $改为$- w $,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5><p>定理：对于形如$f _i = \min _{ 1 \leq j &lt; i  } { f _j + w ( j , i )  } $的状态转移方程,若$w $满足四边形不等式,则$f $有决策单调性.</p>
<p>证明:</p>
<p>$\forall i \in [ 1 , n ] , \forall j \in [ 0 , p _i - 1 ] $,根据$p $的定义,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ p _i  } + w ( p _i , i ) & \leq f _j + w ( j , i ) \\
f _{ p _i  } - f _j & \leq w ( j , i ) - w ( p _i , i ) \\

\end{aligned}</script><p>而对于$k \in [ i + 1 , n ] $,根据$w $的四边形不等式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( j , i ) + w ( p _i , k ) & \leq w ( j , k ) + w ( p _i , i ) \\
w ( j , i ) - w ( p _i , i ) & \leq w ( j , k ) - w ( p _i , k ) \\

\end{aligned}</script><p>联立得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ p _i  } - f _j & \leq w ( j , k ) - w ( p _i , k ) \\
f _{ p _i  } + w ( p _i , k ) & \leq w ( j , k ) + f _j \\

\end{aligned}</script><p>即:$j $对$k $的更新一定不如$p _i $对$k $的更新更优,因此$p _k \in [ p _i , n ] $,因此$f $有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6><p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设$f _i $表示价值为$i $的答案,自然有:$f _i = \max \{ f _{ i - kc  } + sum _{ c , k  } \} $.</p>
<p>如果我们把$c $相同的分层,那这显然是一个最短路型dp,其中$w ( i , j ) = sum _{ c , \frac { i - j  } { c  }  } $.</p>
<p>显然这个转移只会让$\mod c $相同的相互转移,于是后面的$w ( i , j ) $可以理解为一段数字的和,自然满足四边形不等式($\max $也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5><p>对于形如$f _{ x , j  } = \min _{ i = 1  } ^{ x - 1  } \{ f _{ i , j - 1  } + w _{ i , x  } \} $的状态转移方程,若$w $满足四边形不等式,则$f $有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如$f _x = \min _{ i = 1  } ^{ x - 1  } { w _{ i , x  }  } $,我们也可以看作$k $点最短路型的$k = 1 $的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6><p>令$f ( i , j ) $为在第$j $个位置建造第$i $个基站的代价最小值,那么我们有转移:</p>
<script type="math/tex; mode=display">
f ( i , j ) = \min _{ 1 \leq k < j  } \{ f ( i - 1 , k ) + \sum _{ l = k + 1  } ^{ j - 1  } w _l [ d _l - s _l > d _k ] [ d _l + s _l < d _j ] + c _j \}</script><p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时$d _k $单调递增,更新答案时$d _j $单调递增,于是可以直接使用线段树维护,复杂度$O ( nk \log n ) $.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度$O ( nk \log ^2 n ) $.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度$O ( n \log k \log n ) $.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6><p>自然的设计是$f _{ i , j , k  } $表示前$i $个,已经打了$j $个,末尾有连续$k $个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为$f _{ i , j  } $表示前$i $个,目前打了$j $个且第$i $个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成$f _{ i , j  } $表示前$i $个,目前有$j $个没打中而且第$i $个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:$dp _{ i , j  } = \max \{ dp _{ k , j - 1  } + \sum _{ l = k + 1  } ^{ i - 1  } C _{ l - k  } A _l + P \} $.</p>
<p>令$w ( l , r ) = \sum _{ k = l + 1  } ^{ r - 1  } C _{ k - l  } A _k + P $,接下来我们证明:$w ( l + 1 , r ) + w ( l , r - 1 ) \geq w ( l , r ) + w ( l + 1 , r - 1 ) $即可.讨论一下每个$A $面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5><p>引理:在状态转移方程$f _{ i , j  } = \min _{ i \leq k &lt; j  } \{ f _{ i , k  } + f _{ k + 1 , j  } + w ( i , j ) \} $中(通常$f _{ i , i  } = w ( i , i ) = 0 , f _{ i , i + 1  } = w _{ i , i + 1  } $),如果$w $满足四边形不等式和区间包含单调性,那么$f $也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明$f _{ i , j  } + f _{ i + 1 , j + 1  } \leq f _{ i , j + 1  } + f _{ i + 1 , j  } $即可,考虑$j - i = 1 $的时候,显然成立.</p>
<p>使用数学归纳,假设当$b - a &lt; k $时,$f $满足四边形不等式,考虑$j - i = k $的情况:</p>
<p>设$f _{ i , j + 1  } $的最优决策为$x $,$f _{ i + 1 , j  } $的最优决策为$y $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j + 1  } + f _{ i + 1 , j  } & = f _{ i , x  } + f _{ x + 1 , j + 1  } + w ( i , j + 1 ) + f _{ i + 1 , y  } + f _{ y + 1 , j  } + w ( i + 1 , j ) \\

\end{aligned}</script><p>对于$f _{ i , j  } $和$f _{ i + 1 , j + 1  } $来说,$x $和$y $不一定最优,所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } & \leq f _{ i , x  } + f _{ x + 1 , j  } + w ( i , j ) + f _{ i + 1 , y  } + f _{ y + 1 , j + 1  } + w ( i + 1 , j + 1 ) \\

\end{aligned}</script><p>$w $和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } & \leq f _{ i , j + 1  } + f _{ i + 1 , j  } \\

\end{aligned}</script><h6><span id="定理">定理</span></h6><p>记$p _{ i , j  } $为$f _{ i , j  } $的最优决策,若$f $满足四边形不等式,那么对于$\forall i &lt; j ， 有 p _{ i , j - 1  } \leq p _{ i , j  } \leq p _{ i + 1 , j  } \ $.</p>
<p>证明:</p>
<p>记$p = p _{ i , j  } $,$\forall k , i &lt; k \leq p $,因为$f $满足四边形不等式,所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , k  } + f _{ i + 1 , p  } & \leq f _{ i , p  } + f _{ i + 1 , k  } \\
f _{ i + 1 , p  } - f _{ i + 1 , j  } & \leq f _{ i , p  } - f _{ i , k  } 
\end{aligned}</script><p>根据$p $定义,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , p  } + f _{ p + 1 , j  } & \leq f _{ i , k  } + f _{ k + 1 , j  } \\
f _{ i , p  } - f _{ i , k  } & \leq f _{ k + 1 , j  } - f _{ p + 1 , j  } 
\end{aligned}</script><p>由上两式移项联立,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1 , p  } - f _{ i + 1 , k  } & \leq f _{ k + 1 , j  } - f _{ p + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } & \leq f _{ i + 1 , k  } + f _{ k + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } + w _{ i + 1 , j  } & \leq f _{ i + 1 , k  } + f _{ k + 1 , j  } + w _{ i + 1 , j  } \\

\end{aligned}</script><p>因此对于$f _{ i + 1 , j  } $,$p $比任意的$k &lt; p $更优,因此$p _{ i + 1 , j  } \geq p _{ i , j  } $,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4><p>判断一个函数的凸性只需判断$f ( k ) + f ( k + 2 ) \geq 2 f ( k + 1 ) $,而这只需证明$k $的时候的答案和$k + 2 $时的答案可以调整出两个$k + 1 $的答案(不一定是最小答案)并且这两个$k + 1 $的答案的和小于等于$k $时和$k + 2 $时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5><p>首先考虑四个点$( a , b , c , d ) $,注意到其一定满足四边形不等式,也就是$w _{ ac  } + w _{ bd  } \geq w _{ ad  } + w _{ bc  } $.</p>
<p>我们现在想证明,设$f _k $为新增$k $个传送机后的减少的答案,我们考虑证明$f _k + f _{ k + 2  } \geq 2 f _{ k + 1  } $.</p>
<p>我们画出$f _k $时选的点和$f _{ k + 2  } $时选的点,注意到我们可以用这两次调整出两个$k + 1 $的答案,并且这两个答案的和小于等于$f _k + f _{ k + 2  } $,于是证明了最小的$f _{ k + 1  } $是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量$w $,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于$w $的最大的传送机数量,然后就可以做了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/4/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
