<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/4/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">文化课数学导论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A2%AB%E6%96%87%E5%8C%96%E8%AF%BE%E5%88%9B%E9%A3%9E%E4%BA%86/" itemprop="url" rel="index"><span itemprop="name">被文化课创飞了</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2>
<h3><span id="习惯的更改">习惯的更改</span></h3>
<p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将$C
<em>{ n } ^k <span class="math inline">\(写作\)</span> { k } <span class="math inline">\(,而文化课中不允许此类更改,再者文化课中将\)</span>C
</em>{ n } ^k a ^{ n - k } b ^k <span class="math inline">\(称作二项式的第\)</span>k + 1 $项(从第$1
$项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3>
<p>首先我们有$E ( aX + b ) = aE ( X ) + b , D ( aX + b ) = a ^2 D ( X )
$.</p>
<p>我们都知道期望满足线性可加,也就是$E ( X _1 + X _2 ) = E ( X _1 ) + E
( X _2 )
$,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若$X _1
<span class="math inline">\(和\)</span>X _2 <span class="math inline">\(相互独立,\)</span>E ( X _1 X _2 ) = E ( X _1 ) E (
X _2 ) $,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要$X _1 <span class="math inline">\(和\)</span>X _2 <span class="math inline">\(相互独立,\)</span>D ( X _1 + X _2 ) = D ( X _1 ) +
D ( X _2 ) $.从形式上证明是好证明的,我们考虑:</p>
<p><span class="math display">\[
\begin{aligned}
D ( X _1 + X _2 ) &amp; = E ( ( X _1 + X _2 ) ^2 ) - E ^2 ( X _1 + X _2
) \\
&amp; = E ( X _1 ^2 ) + E ( 2 X _1 X _2 ) + E ( X _2 ^2 ) - E ^2 ( X _1
+ X _2 ) \\
&amp; = E ( X _1 ^2 ) + 2 E ( X _1 ) E ( X _2 ) + E ( X _2 ^2 ) - ( E (
X _1 ) + E ( X _2 ) ) ^2 \\
&amp; = E ( X _1 ^2 ) - E ^2 ( X _1 ) + E ( X _2 ^2 ) - E ^2 ( X _2 ) \\
&amp; = D ( X _1 ) + D ( X _2 )
\end{aligned}
\]</span></p>
<p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为$0
<span class="math inline">\(,不然\)</span>D ( X _1 + X _2 )
$要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为$0
$,并且缩放权值,使得方差恰好为$1
$.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为$0
$的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3>
<h4><span id="两点分布">两点分布</span></h4>
直接写的话也就是$P ( X ) =
<span class="math display">\[\begin{cases}p &amp; X = 1 \\ 1 - p &amp; X
= 0 \\ 0 &amp; other \end{cases}\]</span>
<p><span class="math inline">\(,事实上这么写可能不太严谨,因为两点分布的\)</span>X
= 1 <span class="math inline">\(和\)</span>X = 0
$两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是$G ( x ) = ( 1 - p ) + px <span class="math inline">\(.由此式子轻松推得\)</span>E ( x ) = G ’ ( 1 ) = p
, D ( x ) = E ( x ^2 ) - E ^2 ( x ) = G ’ ’ ( 1 ) + G ’ ( 1 ) - ( G ’ (
1 ) ) ^2 = p - p ^2 = p ( 1 - p ) $.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4>
<p>所谓$n <span class="math inline">\(重伯努利试验,也就是\)</span>n
<span class="math inline">\(次两点分布的累计,满足\)</span>P ( X = k ) =
C _{ n } ^k ( 1 - p ) ^{ n - k } p ^k <span class="math inline">\(,我们关注两个事情,也就是二项式分布的\)</span>E ( X
) = np , D ( X ) = np ( 1 - p )
$,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4>
<p>所谓不放回取球,考虑目前有$N <span class="math inline">\(个数字,有\)</span>M $个是$1 <span class="math inline">\(,剩下\)</span>N - M $个是$0 <span class="math inline">\(,取出\)</span>n <span class="math inline">\(次,取出了\)</span>m $个$1 <span class="math inline">\(的概率.简单组合一下得到此概率为\)</span> { C _{ N
} ^n } \ <span class="math inline">\(,注意这里必须保证\)</span>n N
$.</p>
<p>由范德蒙德卷积得知,$<em>{ m } C </em>{ M } ^m C <em>{ N - M } ^{ n -
m } = C </em>{ N } ^n $,因此该分布列所有情况之和为$1 $.</p>
<p>考虑其均值,从感性上讲必定是$ { N } $.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如$01101
$之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到$1
$的概率,和第二次取得到$1 $的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是$n { N ^2 ( N - 1 ) } $,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4>
<p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写$f ( x ) = { }
\ <span class="math inline">\(,是不是看着非常震撼!其中的方差是\)</span>^2 <span class="math inline">\(,期望是\)</span>$.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足$= 1 , = 0 <span class="math inline">\(,此时的函数也就是\)</span>f ( x ) = { }
$.一个好奇是,你凭啥说所有情况下的概率之和为$1 <span class="math inline">\(,事实上这其实是因为\)</span>g ( x ) = e ^{ - x ^2
} <span class="math inline">\(的积分是\)</span> $,不会求这个积分.</p>
<p>观察$g ( x ) = e ^{ - x ^2 } <span class="math inline">\(这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数\)</span>e
^{ - | x | } <span class="math inline">\(模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是\)</span><span class="math inline">\(的由来,将\)</span>x x <span class="math inline">\(,也就是在\)</span>x <span class="math inline">\(那里除去一个\)</span><span class="math inline">\(.而对这个曲线进行横向移动,也就是将\)</span>x x -
$.</p>
<p>这也就引出所谓的$3 $原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3>
<h4><span id="样本相关系数">样本相关系数</span></h4>
<p>对于若干数据$( x _i , y _i ) <span class="math inline">\(,我们先进行标准化,也就是减去均值后再除以方差,这样做使得\)</span>x
, y $分别的均值为$0 $,方差为$1 $.下面默认已经标准化过了.</p>
<p>不妨构造$n <span class="math inline">\(维向量\)</span> = ( x _1 , x
_2 , , x _n ) , = ( y _1 , y _2 , , y _n ) <span class="math inline">\(,考虑它们的点乘\)</span> $,不难发现由于方差为$1
<span class="math inline">\(,因此\)</span>| | = | | = <span class="math inline">\(,因此它们的点乘为\)</span>n <span class="math inline">\(,设\)</span>r = { n } = $.</p>
<p>如果$k <span class="math inline">\(,\)</span>i , y _i = kx _i <span class="math inline">\(,此时必有\)</span>| r | = 1 <span class="math inline">\(,因此我们断言(为啥呢?其实是不太理解的啊)当\)</span>|
r | $越靠近$1 <span class="math inline">\(的时候,\)</span>x , y
$之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4>
<p>我们在上面的角度审视中提出了一个观点:在满足均值为$0 <span class="math inline">\(的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:\)</span>Y
= bx + a + e , E ( e ) = 0 , D ( e ) = ^2 $.</p>
<p>现在我们要做的就是,已知若干组数据$( x _i , y _i ) <span class="math inline">\(,去构造一组\)</span>a , b <span class="math inline">\(满足上面的条件.不妨令\)</span>e _i = y _i - ( bx
_i + a ) <span class="math inline">\(,若\)</span>e <em>i = 0 <span class="math inline">\(,必有\)</span>a = { y } - b { x } <span class="math inline">\(,带入解得当\)</span><span class="math inline">\(最小的时候,\)</span>b = { </em>{ i } ( x _i - { x
} ) ^2 } \ $.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个$b <span class="math inline">\(使得\)</span><span class="math inline">\(最小,标准化说到底只是为了保证\)</span>= 1
$的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4>
<p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知$P
( AB ) = P ( A ) P ( B ) <span class="math inline">\(,那么我们反推,如果我们在现实中的估计中,发现\)</span>P
( AB ) <span class="math inline">\(和\)</span>P ( A ) P ( B )
$差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:$P ( 00 ) = { n } , P ( 01 ) = { n } ,
P ( 10 ) = { n } , P ( 11 ) = { n } <span class="math inline">\(.那么\)</span>P ( A = 0 ) P ( B = 0 ) = { n ^2 }
<span class="math inline">\(.我们计算它与\)</span>P ( 00 ) <span class="math inline">\(的差,平方后除以\)</span>P ( A = 0 ) P ( B = 0 )
<span class="math inline">\(然后做四遍求和化简,得到\)</span>^2 = { ( a +
b ) ( a + c ) ( c + d ) ( b + d ) } $.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么$P (
^2 x _) = $.或者给出我们经验上的准则:</p>
<p>选取一个较小的$<span class="math inline">\(,并得知其对应的\)</span>x
<em><span class="math inline">\(,如果\)</span>^2 x </em><span class="math inline">\(,推断独立性不成立,犯错的概率是\)</span><span class="math inline">\(.反之断言其独立性成立,犯错的概率不可知,肯定\)</span>$越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2>
<h3><span id="常用对数表">常用对数表</span></h3>
<ol type="1">
<li><p>$ = 0 . 693 $.</p></li>
<li><p>$ = 1 . 099 $.</p></li>
<li><p>$ = 1 . 609 $.</p></li>
<li><p>$ . 1 = - 2 . 303 $.</p></li>
<li><p>$ . 5 = - 0 . 693 $.</p></li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3>
<ol type="1">
<li><p>$e = 2 . 718 $.</p></li>
<li><p>$e ^2 = 7 . 389 $.</p></li>
<li><p>$e ^3 = 20 . 086 $.</p></li>
<li><p>$e ^5 = 148 . 413 $.</p></li>
<li><p>$e ^{ 0 . 1 } = 1 . 105 $.</p></li>
<li><p>$e ^{ 0 . 5 } = 1 . 649 $.</p></li>
<li><p>$e ^= 23 . 147 $.</p></li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3>
<h4><span id="fxxex"><span class="math inline">\(f(x)=xe^x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = ( x + 1 ) e ^x <span class="math inline">\(,\)</span>x =
- 1 <span class="math inline">\(的时候,取最小值\)</span>- { e } $.</p>
<p>另外$_{ x - } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxxln-x"><span class="math inline">\(f(x)=x\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = 1 + x , x = { e } <span class="math inline">\(的时候,有最小值\)</span>- { e } $.</p>
<p>另外$_{ x ^{ + } } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracexx"><span class="math inline">\(f(x)=\frac{e^x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e%5Exdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = { x ^2 } , x = 1 <span class="math inline">\(的时候,有极小值\)</span>e $.</p>
<p>另外$_{ x - } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfraclnxx"><span class="math inline">\(f(x)=\frac{\ln
x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = { x ^2 } , x = e <span class="math inline">\(的时候,有极大值\)</span> { e } $.</p>
<p>另外$_{ x + } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxx-ln-x"><span class="math inline">\(f(x)=x-\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = 1 - { x } , x = 1 $的时候,有最小值$1 $.</p>
<hr>
<h4><span id="fxfracxex"><span class="math inline">\(f(x)=\frac{x}{e^x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p>$f ’ ( x ) = { e ^x } , x = 1 <span class="math inline">\(的时候,有最大值\)</span> { e } $.</p>
<p>另外$_{ x + } f ( x ) = 0 \ $.</p>
<h3><span id="预处理函数">预处理函数</span></h3>
<h4><span id="分离对数">分离对数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令$f ( x ) = ( 2 + x + ax ^2 ) ( x + 1 ) - 2 x <span class="math inline">\(,已知\)</span>x = 0 <span class="math inline">\(是极大值点,求\)</span>a $.</p>
<p>考虑分离对数后操作多项式,我们显然可找到$0 &lt; t &lt; 1 , 2 + t + at
^2 &gt; 0 , 2 - t + at ^2 &gt; 0 <span class="math inline">\(,下面只考虑\)</span>x <span class="math inline">\(.此时\)</span>f ( x ) = ( 2 + x + ax ^2 ) ( ( x +
1 ) - { 2 + x + ax ^2 } ) $.</p>
<p>考虑令$g ( x ) = ( x + 1 ) - { 2 + x + ax ^2 } <span class="math inline">\(,由于\)</span>f ( 0 ) = 0 <span class="math inline">\(,只需证明\)</span>g ( x ) , x $即可.</p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
g &#39; ( x ) &amp; = \frac { 1  } { x + 1  } - \frac { 4 - 2 ax ^2  } {
( 2 + x + ax ^2 ) ^2  } \\
&amp; = \frac { x ^2 ( a ^2 x ^2 + 4 ax + 6 a + 1 )  } { ( x + 1 ) ( 2 +
x + ax ^2 )  } \\
\text { sign  } ( g &#39; ( x ) ) &amp; = \text { sign  } ( a ^2 x ^2 +
4 ax + 6 a + 1 )
\end{aligned}
\]</span></p>
<p>则$a ^2 0 ^2 + 4 a 0 + 6 a + 1 = 0 <span class="math inline">\(,\)</span>a = - { 6 } $.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令$f ( x ) = e ^x - ( x + 1 ) + ax ^3 - x ^2 - 1 <span class="math inline">\(,若\)</span>x ( - 1 , 1 ) , f ( x ) <span class="math inline">\(,求\)</span>a $.</p>
<p>$f ( 0 ) = 0 $,于是上面的条件等价于$0 <span class="math inline">\(是\)</span>( - 1 , 1 ) $的最小值点.</p>
<p>考虑$f ’ ( x ) = e ^x - { x + 1 } + 3 ax ^2 - 2 x <span class="math inline">\(,则\)</span>f ’ ( 0 ) = 0 $恒成立.</p>
<p>讨论$g ( x ) = 1 + e ^{ - x } ( 3 ax ^2 - 2 x - { x + 1 } ) <span class="math inline">\(的正负,看\)</span>g ’ ( x ) = { ( x + 1 ) ^2 e ^x
} $.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3>
<h4><span id="变化条件">变化条件</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知$x + 2 y = 1 <span class="math inline">\(,求\)</span>x ^2 + y ^2
$的最小值.</p>
<p>直接令$x = 1 - 2 y $,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知$x ^2 + y ^3 = 2 <span class="math inline">\(,求\)</span>x + y
$的最小值.</p>
<p>这个的话不妨设其最小值为$C <span class="math inline">\(,有\)</span>x
+ y C <span class="math inline">\(,移项得到\)</span>y C - x
$,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3>
<h4><span id="普通参数方程">普通参数方程</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知$x ^2 + y ^2 - xy = 1 <span class="math inline">\(,求\)</span>x +
y $的最小值.</p>
<p>这个的话大概是这样,我们找到一个$t <span class="math inline">\(,使得\)</span>x = f ( t ) , y = g ( t )
$,然后换元.</p>
<p>比如这个题,你就可以凑成$( x - { 2 } ) ^2 + ( { 2 } y ) ^2 = 1
$,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4>
<h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5>
<p>求证$ &lt; { a - b } &lt; { 2 } $.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<p><span class="math display">\[
\begin{aligned}
\frac { a - b  } { \ln a - \ln b  } &amp; &lt; \frac { a + b  } { 2  }
\\
\frac { a - b  } { a + b  } &amp; &lt; \frac { \ln \frac { a  } {
b  }  } { 2  } \\
\frac { \frac { a  } { b  } - 1  } { \frac { a  } { b  } + 1  } &amp;
&lt; \frac { \ln \frac { a  } { b  }  } { 2  }
\end{aligned}
\]</span></p>
<p>换元,令$t = { b } $,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知函数$f ( x ) = 3 x - ax <span class="math inline">\(,若\)</span>x
_1 &lt; x _2 <span class="math inline">\(是\)</span>f ( x ) <span class="math inline">\(的两个零点,求证\)</span>f ’ ( { 4 } ) &lt; 0
$.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<p><span class="math display">\[
\begin{cases}
3 \ln x _1 = ax _1 \\
3 \ln x _2 = ax _2
\end{cases}
\]</span></p>
<p>我们想要知道的是:$ { x _1 + 3 x _2 } &lt; a $.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把$a
<span class="math inline">\(给换掉,事实上我们根据前面的方程有\)</span>a
= { x _2 - x _1 } $.</p>
<p>于是我们只需要证明:$ { 4 } &gt; { { x _1 } }
$,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5>
<p>已知函数$f ( x ) = x - ax <span class="math inline">\(,其有两个零点\)</span>x _1 x _2 <span class="math inline">\(,求证\)</span>x _1 x _2 &gt; e ^2 $.</p>
<p>同样分析已知,我们得到的是:</p>
<p><span class="math display">\[
\begin{cases}
\ln x _1 = ax _1 \\
\ln x _2 = ax _2
\end{cases}
\]</span></p>
<p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<p><span class="math display">\[
\begin{cases}
\ln x _2 - \ln x _1 = a ( x _2 - x _1 ) \\
\ln x _2 + \ln x _1 = a ( x _2 + x _1 )
\end{cases}
\]</span></p>
<p>这里先把所求变形一下,我们把它改成$x _1 + x _2 &gt; 2 $.</p>
<p>发现了什么?这个东西等价于$a ( x _2 + x _1 ) &gt; 2
$,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换$a $即可.</p>
<h5><span id="example4">Example4</span></h5>
<p>已知$f ( x ) = x ^2 + axe ^x - ae ^{ 2 x } <span class="math inline">\(有三个不同的零点\)</span>x _1 &lt; x _2 &lt; x _3
<span class="math inline">\(,求\)</span>a <span class="math inline">\(的范围,并求证\)</span>( 1 - { e ^{ x _1 } } ) ^2 (
1 - { e ^{ x _2 } } ) ( 1 - { e ^{ x _3 } } ) = 1 $.</p>
<p>考虑两边同时除以$e ^{ 2 x } <span class="math inline">\(,这样得到\)</span>g ( x ) = ( { e ^x } ) ^2 + a {
e ^x } - a <span class="math inline">\(,令\)</span>t = { e ^x } <span class="math inline">\(得到\)</span>g ( t ) = t ^2 + at - a = 0 $.</p>
<p>考察$g ( t ) = 0 <span class="math inline">\(的两根\)</span>t _1 &lt;
t _2 <span class="math inline">\(,根据韦达定理,首先需要满足\)</span>= a
^2 + 4 a &gt; 0 a &gt; 0 <span class="math inline">\(,然后\)</span>t _1
+ t _2 = - a , t _1 t _2 = - a $.</p>
<p>接下来考察函数$ { e ^x } <span class="math inline">\(,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为\)</span>t
_1 , t _2 <span class="math inline">\(中必有一负,因此\)</span>t _2 ( 0 ,
{ e } ) $.由此立得$0 &lt; a &lt; { e ( e - 1 ) } $.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>若$x &gt; 0 <span class="math inline">\(时,\)</span>ax ( e ^{ ax } +
1 ) ( x ^2 + 1 ) x <span class="math inline">\(恒成立,求\)</span>a
$取值范围.</p>
<p>一般这种题先判$a <span class="math inline">\(的正负,注意到\)</span>x
&gt; 1 $的时候右边恒大于$0 <span class="math inline">\(,因此\)</span>a
&gt; 0 $.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数$2 <span class="math inline">\(放进\)</span><span class="math inline">\(,自然有:\)</span>ax ( e ^{ ax } + 1 ) ( x ^2 + 1 )
x ^2 $.</p>
<p>考虑令$t _1 = ax , t _2 = x ^2 $,则:</p>
<p><span class="math display">\[
t _1 ( e ^{ t _1  } + 1 ) \geq t _2 ( e ^{ t _2  } + 1 )
\]</span></p>
<p>接下来分析函数$f ( x ) = x ( e ^x + 1 ) <span class="math inline">\(的单调性,就可以得到\)</span>a { e } $.</p>
<h3><span id="不等式相关">不等式相关</span></h3>
<h4><span id="基本不等式相关">基本不等式相关</span></h4>
<h5><span id="方程角度的审视">方程角度的审视</span></h5>
<p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造$
{ n } = k $.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5>
<p>已知$n , m &gt; 0 , 2 m + n = nm <span class="math inline">\(,求\)</span>n + m + $的最小值.</p>
<p>这个题有一个方式是观察到$n , m ,
$是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
$$
<span class="math display">\[\begin{aligned}
n + m + \sqrt { n ^2 + m ^2  } &amp; \geq k \\
\Leftarrow \sqrt { n ^2 + m ^2  } &amp; \geq k - n - m \\

\end{aligned}\]</span>
<p>$$</p>
<p>如果$n + m k <span class="math inline">\(,那么不等式显然成立,下面只需要证明\)</span>n + m
&lt; k $的情况:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt { n ^2 + m ^2  } &amp; \geq k - n - m \\
\Leftarrow n ^2 + m ^2 &amp; \geq ( k - ( n + m ) ) ^2 \\
\Leftarrow k ^2 + ( n + m ) ^2 - 2 k ( n + m ) &amp; \leq n ^2 + m ^2 \\
\Leftarrow k ^2 + 2 nm - 2 k ( n + m ) &amp; \leq 0 \\
\Leftarrow k ^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) &amp; \leq 0 \\
\Leftarrow k ^2 &amp; \leq n ( 2 k - 2 ) + m ( 2 k - 4 )
\end{aligned}
\]</span></p>
<p>变形方程得到$ { n } + { m } = 1 $,使用这个式子来降次:</p>
$$
<span class="math display">\[\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) &amp; = 6 k - 8 + \frac { n  } { m  } ( 2
k - 2 ) + \frac { m  } { n  } ( 4 k - 8 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>要严谨一点的话我们需要证明$4 k - 8 <span class="math inline">\(,\)</span>k <span class="math inline">\(.这非常简单,因为\)</span>k n + m &gt; 3 $.</p>
<p>这就足够了么?不需要证明存在一个$w = { m }
$使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<p><span class="math display">\[
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k -
2 )  }
\]</span></p>
<p>这个等号可以取到,也就是说,只要满足:</p>
<p><span class="math display">\[
k ^2 \leq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }
\]</span></p>
<p>那么这个$k $就是一个下界,特别地,如果满足:</p>
<p><span class="math display">\[
k ^2 = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }
\]</span></p>
<p>那么这个$k $就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到$k = 10 <span class="math inline">\(是一个解了),接下来我们必须求出一个\)</span>k
$.</p>
<p><span class="math display">\[
\begin{aligned}
k ^2 &amp; = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
k ^2 - 6 k + 8 &amp; = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
( k - 4 ) ( k - 2 ) &amp; = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
\sqrt { k - 2  } &amp; = \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  }
\end{aligned}
\]</span></p>
<p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个$
$带入到上面去!</p>
$$
<span class="math display">\[\begin{aligned}
( k - 4 ) ( k - 2 ) &amp; = 2 \sqrt { 8 ( k - 1 )  } \frac { 2 \sqrt { 8
( k - 1 )  }  } { k - 4  } \\
( k - 4 ) ( k - 2 ) &amp; = \frac { 32 ( k - 1 )  } { k - 4  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说$k
= 0 $是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出$k = 10 $.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4>
<h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5>
$$
<span class="math display">\[\begin{aligned}
f ( x ) &amp; = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( x _0 )  } {
k !  } ( x - x _0 ) ^k \\
f ( x ) &amp; = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( 0 )  } { k
!  } x ^k \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5>
<ol type="1">
<li><p>$ { 1 - x } = _{ k } x ^k = 1 + x + x ^2 + \ $.</p></li>
<li><p>$e ^x = _{ k } { k ! } = 1 + x + { 2 ! } x ^2 + \ $.</p></li>
<li><p>$( 1 + x ) = _{ k } ( - 1 ) ^{ k - 1 } { k } = x - { 2 } x ^2 + {
3 } x ^3 + \ $.</p></li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>已知函数$f ( x ) = x - ax <span class="math inline">\(,其有两个零点\)</span>x _1 x _2 <span class="math inline">\(,求证\)</span>x _1 x _2 &gt; e ^2 $.</p>
<p>极值点偏移的形式,应该是形如$g ( x ) = a <span class="math inline">\(有两个解\)</span>x _1 , x _2 <span class="math inline">\(,然后使得\)</span>x _1 + x _2
$满足一定条件.因此我们先变形条件:</p>
<p><span class="math display">\[
\begin{cases}
\frac { \ln x _1  } { x _1  } = a \\
\frac { \ln x _2  } { x _2  } = a
\end{cases}
\]</span></p>
<p>也就是目前我们构造出了函数$g ( x ) = { x } <span class="math inline">\(,观察\)</span>g ( x ) <span class="math inline">\(图像立得\)</span>x _1 + x _2 &gt; 2 e $.</p>
<p>我们发现,$x _1 x _2 { 4 }
$,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为$x
_1 + x _2 &lt; 2 <span class="math inline">\(,然后令\)</span>t _1 = x _1
, t _2 = x _2 $,带入立有:</p>
<p><span class="math display">\[
\begin{cases}
\frac { t _1  } { e ^{ t _1  }  } = a \\
\frac { t _2  } { e ^{ t _2  }  } = a
\end{cases}
\]</span></p>
<p>而$g ( x ) = { e ^x } <span class="math inline">\(恰好也是满足\)</span>x _1 + x _2 &gt; 2
$的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5>
<p>$f ( x ) = x ( 1 - x ) <span class="math inline">\(,\)</span>b a - a
b = a - b $,求证$2 &lt; { a } + { b } &lt; e $.</p>
<p>首先变形条件得到$b ( 1 + a ) = a ( 1 + b ) <span class="math inline">\(,得到\)</span>f ( { a } ) = f ( { b } )
$,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p>$f ’ ( x ) = - x <span class="math inline">\(,其在\)</span>( 0 , 1 )
, ( 1 , + ) <span class="math inline">\(,考察极值点偏移,我们想要证明\)</span> { b } &lt; e
- { a } <span class="math inline">\(,我们就想办法把\)</span> { b } <span class="math inline">\(和\)</span>e - { a } <span class="math inline">\(扔到同一个区间里,而它们确实同在\)</span>( 1 , + )
$这个区间内.</p>
<p>比较有启发性的是,你发现$ { b } , e - { a } <span class="math inline">\(和\)</span> { a } , e - { b }
$这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 1  } { b  } &amp; &lt; e - \frac { 1  } { a  } \\
f ( \frac { 1  } { a  } ) &amp; = f ( \frac { 1  } { b  } ) &amp; &gt; f
( e - \frac { 1  } { a  } )
\end{aligned}
\]</span></p>
<p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5>
<p>$f ( x ) = e ^{ x - 1 } - ax <span class="math inline">\(在\)</span>(
0 , 2 ) <span class="math inline">\(有两个零点\)</span>x _1 , x _2 <span class="math inline">\(,求证\)</span>x _1 x _2 &gt; { a } $.</p>
<p>首先要证明$a <span class="math inline">\(的范围啊,我们不加证明地给出:\)</span>a ( 1 , { 2 }
) <span class="math inline">\(,并且\)</span>( - , 1 + a ) , ( 1 + a , +
) $.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<p><span class="math display">\[
\begin{cases}
ax _1 = e ^{ x _1 - 1  } \\
ax _2 = e ^{ x _2 - 1  }
\end{cases}
\]</span></p>
<p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取$$,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取$<span class="math inline">\(,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到\)</span>x
_1 x _2 <span class="math inline">\(和\)</span>x _1 + x _2
$之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如$0
&lt; f ( 2 + a - x _2 ) $,也就是$0 &lt; ae ^{ 1 - x _2 } - a ( 2 + a - x
_2 ) $.</p>
<p>但是这样有一个问题,我们把$f <span class="math inline">\(带进去,你会发现最后我们的式子同时带有\)</span>a ,
x _2 <span class="math inline">\(,这个就难做了,咋办呢?考虑拿\)</span>ax
_2 = e ^{ x _2 - 1 } <span class="math inline">\(操作一下把\)</span>a
$消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4>
<h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5>
<ol type="1">
<li><p>$e ^x x + 1 $.</p></li>
<li><p>$ { x } x x - 1 $.</p></li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol start="3" type="1">
<li>$( n + 1 ) &lt; _{ k = 1 } ^n { k } $.</li>
</ol>
<p>考虑$( { n } ) &lt; { n } $,左右两边分别求和得到上面的式子.</p>
<ol start="4" type="1">
<li>$n &gt; _{ k = 2 } ^n { k } , n &gt; 1 $.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明$ { n } &lt; - _{ k = 2 }
^n { k } $.</p>
<p>考虑$( { n } ) - { n } $,两边求和得到上式.</p>
<ol start="5" type="1">
<li>$_{ k = 1 } ^n ( { n } ) ^n &lt; { e - 1 } $.</li>
</ol>
<p>考虑$n ( { n } ) k - n <span class="math inline">\(,也就有\)</span>(
{ n } ) ^n e ^{ k - n } $,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>设$f ( x ) = x x <span class="math inline">\(,若\)</span>f ( x ) = b
<span class="math inline">\(有两个实数根\)</span>x _1 , x _2 ( x _1 &lt;
x _2 ) <span class="math inline">\(,求证:\)</span>be + 1 &lt; x _2 - x
_1 &lt; { 2 } $.</p>
<p>注意到$f ( x ) <span class="math inline">\(下凸,考虑求出两条切线,那么这两条切线与\)</span>y =
b <span class="math inline">\(的交点之差要大于等于\)</span>x _2 - x _1
<span class="math inline">\(,两条割线交点之差要小于等于\)</span>x _2 - x
_1 $.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是$b - { e } <span class="math inline">\(的情况,为了让这种情况有解,我们的割线必过\)</span>(
{ e } , - { e } ) $.</p>
<p>考虑直接选取$( 0 , 0 ) <span class="math inline">\(和\)</span>( 1 , 0
) <span class="math inline">\(作为另外两个点,这两条割线就是\)</span>x =
- y <span class="math inline">\(和\)</span>x = ( e - 1 ) y + 1
$.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得$(
x _2 - x <em>1 ) </em>{ } $尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是$u <span class="math inline">\(,另一个是\)</span>v <span class="math inline">\(,其中\)</span>v &lt; { e } &lt; u
$,那么两条切线分别是:</p>
<p><span class="math display">\[
\begin{cases}
x = \frac { y - f ( u )  } { f &#39; ( u )  } + u \\
x = \frac { y - f ( v )  } { f &#39; ( v )  } + v
\end{cases}
\]</span></p>
<p>那么,现在我们要做的就是找到一组$( u , v ) $,使得:</p>
<p><span class="math display">\[
\frac { b - f ( u )  } { f &#39; ( u )  } + u - \frac { b - f ( v )  } {
f &#39; ( v )  } - v = \frac { e ^{ - 3  } + 2 + 3 b  } { 2  }
\]</span></p>
<p>感觉很难搞啊,我们不妨让$u = 1 $,自然有:</p>
<p><span class="math display">\[
\frac { ( f &#39; ( v ) - 1 ) b + f ( v ) - vf &#39; ( v )  } { f &#39;
( v )  } = \frac { e ^{ - 3  } + 3 b  } { 2  }
\]</span></p>
<p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<p><span class="math display">\[
\begin{cases}
\frac { f &#39; ( v ) - 1  } { f &#39; ( v )  } = \frac { 3  } { 2  } \\
\frac { f ( v ) - vf &#39; ( v )  } { f &#39; ( v )  } = \frac { e ^{ -
3  }  } { 2  }
\end{cases}
\]</span></p>
<p>考虑让$f ’ ( v ) = - 2 <span class="math inline">\(,则\)</span>v = e
^{ - 3 } $,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求证:$x ( 0 , + ) , x + 1 &gt; { e ^{ x + 1 } } - { e ^2 x } $.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以$x
$,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为$x x + x &gt; { e ^{ x + 1 } } - { e ^2 } <span class="math inline">\(,然后证明左边的最小值\)</span>$右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4>
<p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5>
<p>已知$a = 0 . 1 e ^{ 0 . 1 } , b = { 9 } , c = - . 9 <span class="math inline">\(,求比较\)</span>a , b , c $的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6>
<p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算$a <span class="math inline">\(和\)</span>c $的大小关系.</p>
<p>构造函数$f ( x ) = xe ^x + ( 1 - x ) <span class="math inline">\(,则\)</span>f ( 0 . 1 ) &gt; 0 a &gt; c $.</p>
<p>考察$f ( 0 ) = 0 <span class="math inline">\(,\)</span>f ’ ( 0 ) = 0
<span class="math inline">\(,\)</span>f ’ ’ ( 0 ) = 4 &gt; 0 <span class="math inline">\(,则\)</span>f ( 0 ) = 0 <span class="math inline">\(是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算\)</span>f
( 0 . 1 ) &gt; 0 $.</p>
<h6><span id="估算定积分">估算定积分</span></h6>
<p>考察$a <span class="math inline">\(和\)</span>b <span class="math inline">\(的大小关系,不妨设\)</span>f ( x ) = ( 1 - x ) e ^{
1 - x } - { 10 x } <span class="math inline">\(,则\)</span>f ( 0 . 9 )
&lt; 0 b &gt; a $.</p>
<p>注意到$f ( 1 ) = - { 10 } <span class="math inline">\(,\)</span>f ’ (
1 ) = - { 10 } <span class="math inline">\(,考虑估算一下积分,那么\)</span>f ( 0 . 9 ) f ( 1 )
- f ’ ( 1 ) 0 . 1 = - { 100 } &lt; 0 $.</p>
<p>你可能会觉得这个$- { 100 } <span class="math inline">\(,是不是不太能那么肯定地估算啊.但是实际上,我们考察\)</span>f
’ ( x ) = ( x - 2 ) e ^{ 1 - x } + { 10 x ^2 } <span class="math inline">\(,这个东西在\)</span>[ 0 . 9 , 1 ] <span class="math inline">\(上直觉上平均值是大于\)</span>- { 10 }
$的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6>
<p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6>
<p>接下来开抄标答.</p>
<p>令$f _a ( x ) = xe ^x , f _b ( x ) = { 1 - x } , f _c ( x ) = - ( 1 -
x ) $.</p>
<p>这样当$x = 0 . 1 $的时候所有的数字都被正确表示了.</p>
<p>比较$a , b $:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<p><span class="math display">\[
\begin{aligned}
y &amp; = \ln ( a ) - \ln ( b ) &amp; = x + \ln ( 1 - x ) \\
y &#39; &amp; = 1 - \frac { 1  } { 1 - x  } &amp; = \frac { - x  } { 1 -
x  }
\end{aligned}
\]</span></p>
<p>注意到$x = 0 <span class="math inline">\(的时候\)</span>y = 0 <span class="math inline">\(,又注意到其在\)</span>( 0 , 0 . 1 ) <span class="math inline">\(上单减,这样立有\)</span>a &lt; b $.</p>
<p>比较$a , c $:</p>
$$
<span class="math display">\[\begin{aligned}
y &amp; = a - c &amp; = xe ^x + \ln ( 1 - x ) \\
y &#39; &amp; = ( x + 1 ) e ^x - \frac { 1  } { 1 - x  } &amp; = \frac {
( 1 + x ) ( 1 - x ) e ^x - 1  } { 1 - x  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$x = 0 <span class="math inline">\(的时候\)</span>y = 0 <span class="math inline">\(,又注意到其在\)</span>( 0 , 0 . 1 ) <span class="math inline">\(上单增,这样立有\)</span>a &gt; c $.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2>
<h3><span id="递归式的求解">递归式的求解</span></h3>
<h4><span id="特征根法">特征根法</span></h4>
<p>一个常系数的$k $阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n &amp;
\geq k \\
a _0 &amp; = C _0 , a _1 &amp; = C _1 , . . . , a _{ k - 1  } &amp; = C
_{ k - 1  }
\end{aligned}
\]</span></p>
<p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程$r ^k = _{ i = 1 } ^k c _i r ^{ k - i }
$是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根$r _1 <span class="math inline">\(和\)</span>r _2 <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r _1 ^n + _2 r _2 ^n
$.</p>
<p>若其特征方程有两个相同的根$r <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r ^n + _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 <span class="math inline">\(或者\)</span>n = 1 <span class="math inline">\(的情况,我们考虑求出一组\)</span>_1 <span class="math inline">\(和\)</span>_2 $来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C _0 &amp; = \alpha _1 + \alpha _2 \\
C _1 &amp; = \alpha _1 r _1 + \alpha _2 r _2
\end{aligned}
\]</span></p>
<p>若$r _1 r _2 $,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha _1 &amp; = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 &amp; = C _0 - \alpha _1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } )
+ c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) +
\alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有$= c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C _0 &amp; = \alpha _1 \\
C _1 &amp; = \alpha _1 r + \alpha _2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } -
\alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2
nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
&amp; = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n -
2  }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明$c _1 r + 2 c _2 = 0 <span class="math inline">\(即可.根据方程,不难发现\)</span>r = { 2 } <span class="math inline">\(,根据\)</span>= 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>在上面做$k = 2
$的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6>
<p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定$a _0 , . . . , a _n <span class="math inline">\(,其中\)</span>a
_0 <span class="math inline">\(,对于所有的\)</span>k
$,若有下列式子成立:</p>
<p><span class="math display">\[
a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = z _k
\]</span></p>
<p>则称为一个$n <span class="math inline">\(阶线性差分方程(或递归关系).为了简化,通常取\)</span>a
_0 = 1 <span class="math inline">\(.若\)</span>{ z _k }
$是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6>
<p>我们注意到,对于齐次差分方程而言,如果不给定$y <em>0 , y </em>{ n - 1 }
<span class="math inline">\(,只是构造一组满足条件的\)</span>y <span class="math inline">\(的话,自然的想法是令\)</span>y _k = r ^k <span class="math inline">\(.其中\)</span>r <span class="math inline">\(是辅助方程\)</span>a _0 r ^{ n } + a _1 r ^{ n - 1
} + + a _n = 0 $的一个根.</p>
<p>注意到如果我们将上面的内容看作是$T : { y _k } { z _k } <span class="math inline">\(这样一个映射,这显然是一个线性变换.这意味着齐次方程\)</span>a
<em>0 y </em>{ k + n } + a <em>1 y </em>{ k + n - 1 } + + a _n y _k = 0
<span class="math inline">\(的解集就是\)</span>T <span class="math inline">\(的核,设为\)</span>H <span class="math inline">\(,不难发现只要给定\)</span>y <em>0 , y </em>{ n - 1
} <span class="math inline">\(,这个解就唯一确定,将它们看作自由变量,这意味着\)</span>H
= n $.</p>
<p>还没完,注意到我们解方程可以解出$n <span class="math inline">\(个根,如果这\)</span>n <span class="math inline">\(个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了\)</span>y
<em>0 , y </em>{ n - 1 }
$,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这$n <span class="math inline">\(个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的\)</span>
^k $的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共$n
<span class="math inline">\(个线性无关的根,然后拟合初值.我们如此做:对于一个出现了\)</span>m
<span class="math inline">\(次的根\)</span>r <span class="math inline">\(,我们注意到\)</span>r ^k , kr ^k , , k ^{ m - 1 }
r ^k $都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以$kr
^k $作为例子,即证明:</p>
<p><span class="math display">\[
a _0 nr ^n + a _1 ( n - 1 ) r ^{ n - 1  } + \cdots + a _1 r = 0
\]</span></p>
<p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个$r <span class="math inline">\(作为根,必然意味着原方程形如\)</span>( y - r ) ^2 P
<span class="math inline">\(,其中\)</span>P <span class="math inline">\(是一个关于\)</span>y $的多项式.</p>
<p>我们把它写开:$( y ^2 - 2 ry + r ^2 ) P = 0 <span class="math inline">\(,然后我们用\)</span>kr ^k <span class="math inline">\(去代替\)</span>r ^k
$,不难发现代替后右边还是个多项式,而左边变成了$0
$,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
$$
<span class="math display">\[\begin{aligned}
a _0 r ^{ n + k  } + a _1 r ^{ n + k - 1  } + \cdots + a _1 r ^k &amp; =
0 \\
a _0 ( n + k ) r ^{ n + k - 1  } + a _1 ( n + k - 1 ) r ^{ n + k - 2  }
+ \cdots + a _1 kr ^{ k - 1  } &amp; = 0 \\
a _0 ( n + k ) r ^{ n + k  } + a _1 ( n + k - 1 ) r ^{ n + k - 1  } +
\cdots + a _1 kr ^{ k  } &amp; = 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:$( ( y - r ) ^2 P ) ’ = ( y - r ) ( ( y - r ) P
) ’ + ( y - r ) ’ ( y - r ) P = ( y - r ) [ ( y - r ) ’ P + ( ( y - r )
P ) ’ ] <span class="math inline">\(,\)</span>r
$一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6>
<p>我们注意到齐次差分方程一定能写成$ <em>k = A </em>{ k - 1 } <span class="math inline">\(的形式.如果我们取\)</span>A <span class="math inline">\(的特征向量的线性组合作为\)</span> _0
$,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为$1
$的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是$ <em>{ k + 1 } = A <span class="math inline">\(,\)</span> </em>{ n } = A ^n _0 <span class="math inline">\(.而我们又知道CH定理:\)</span>p ( A ) = 0 <span class="math inline">\(,我们用多项式取膜,有\)</span>A ^n = p ( A ) F ( A
) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3>
<h4><span id="和式的基本运算">和式的基本运算</span></h4>
<p>分配律:$\ _{ i S } ca <em>i = c </em>{ i S } a _i \ $.</p>
<p>结合律:$\ _{ i S } ( a _i + b <em>i ) = </em>{ i S } a <em>i + </em>{
i S } b _i $.</p>
<p>交换律:$<em>{ i S } a <em>i = </em>{ p ( i ) S } a </em>{ p ( i ) }
<span class="math inline">\(,其中\)</span>p <span class="math inline">\(是\)</span>S $集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol type="1">
<li><p>$<em>{ i } </em>{ j } a <em>{ i , j } [ P ( i , j ) ] = </em>{ j
} <em>{ i } a </em>{ i , j } [ P ( i , j ) ] $.</p></li>
<li><p>$<em>{ i = 1 } ^n </em>{ j = i } ^n a <em>{ i , j } = </em>{ j =
1 } ^n <em>{ i = 1 } ^j a </em>{ i , j } $.</p></li>
</ol>
<p>一般分配律:$<em>{ i } </em>{ j } a _{ i } b <em>j = ( </em>{ i } a _i
) ( _j b _j ) $.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6>
<p>等差数列求和：</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ( ai + b ) &amp; = \sum _{ i = 0  } ^n
( a ( n - i ) + b ) \\
2 S _n &amp; = \sum _{ i = 0  } ^n ( an + 2 b ) &amp; = an ( n + 1 ) + 2
b ( n + 1 ) \\
S _n &amp; = ( n + 1 ) ( \frac { an  } { 2  } + b )
\end{aligned}
\]</span></p>
<h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6>
<p>令$S = _{ 1 i &lt; j n } ( a _j - a _i ) ( b _j - b <em>i ) = </em>{
1 j &lt; i n } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 j &lt; i n ] + [ 1 i &lt; j n ] = [ 1 j , i n ] - [ 1
i = j n ] $.</p>
<p>那么我们有:</p>
$$
<span class="math display">\[\begin{aligned}
2 S &amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i
) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
&amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i )
\\
&amp; = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i
) ( \sum _{ j = 1  } ^n b _j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>又有$( _{ i = 1 } ^n a <em>i ) ( </em>{ j = 1 } ^n b <em>j ) = n
</em>{ i = 1 } ^n a _i b <em>i - </em>{ 1 i &lt; j n } ( a _j - a _i ) (
b _j - b _i ) $,显然有以下式子:</p>
$$
<span class="math display">\[\begin{aligned}
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) &amp; \leq n
\sum _{ i = 1  } ^n a _i b _i , \forall i &amp; &lt; j , a _i &amp; \leq
a _j \land b _i &amp; \leq b _j \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) &amp; \geq n
\sum _{ i = 1  } ^n a _i b _i , \forall i &amp; &lt; j , a _i &amp; \leq
a _j \land b _i &amp; \geq b _j \\

\end{aligned}\]</span>
<p>$$</p>
<p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6>
<p>即$_{ 1 j &lt; k n } ( a _j b _k - a _k b <em>j ) ^2 = ( </em>{ i = 1
} ^n a <em>i ^2 ) ( </em>{ i = 1 } ^n b <em>i ^2 ) - ( </em>{ i = 1 } ^n
a _i b _i ) ^2 \ $.</p>
<p>令$S <em>n = </em>{ 1 j &lt; k n } ( a _j b _k - a _k b _j ) ^2 \
$,有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S _n &amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a
_k b _j ) ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a
_j a _k b _j b _k - a _k ^2 b _j ^2 ) \\
&amp; = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2
) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ax ^i \\
&amp; = a + \sum _{ i = 1  } ^n ax ^i \\
&amp; = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
&amp; = a + xS _{ n - 1  }
\end{aligned}
\]</span></p>
<p>而$S _{ n - 1 } + ax ^n = S <em>n = a + xS </em>{ n - 1 } <span class="math inline">\(,有\)</span>S _n + ax ^{ n + 1 } = a + xS _n , S
_n = a { x - 1 } <span class="math inline">\(，其中\)</span>x $.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6>
<p>$S <em>n = </em>{ i = 0 } ^n i ^2 $.</p>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
&amp; = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2
\end{aligned}
\]</span></p>
<p>我们无法得到$S <em>n <span class="math inline">\(的封闭形式,但我们发现我们得到了\)</span></em>{ i =
1 } ^n i $的封闭形式.</p>
<p>那以此类推，我们设$W <em>n = </em>{ i = 0 } i ^3 $</p>
<p><span class="math display">\[
\begin{aligned}
W _n &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum
_{ i = 1  } ^n i - n + n ^3 \\
&amp; = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n &amp; = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
&amp; = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
&amp; = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
&amp; = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  }
\end{aligned}
\]</span></p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h6><span id="example1平方和公式">Example1(平方和公式)</span></h6>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ k = 1  } ^n k ^2 \\
&amp; = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
&amp; = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 )
\\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 -
ni + n ) \\
&amp; = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  }
^n i ^2 + n ^3 + n ^2 ) \\
&amp; = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n +
\frac { n ^3 + n ^2  } { 2  }
\end{aligned}
\]</span></p>
<p>整理得到$S _n $.</p>
<h6><span id="example2">Example2</span></h6>
<p>求$_{ i = 1 } ^n i ^3 \ $.</p>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum _{ i = 1  } ^n i ^3 \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
&amp; = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  }
- \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
&amp; = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } {
3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n (
n + 1 )  } { 12  } \\
S ( n ) &amp; = \frac { n ^2 ( n + 1 ) ^2  } { 4  }
\end{aligned}
\]</span></p>
<h5><span id="problme3">Problme3</span></h5>
<p>求$_{ i = 1 } ^n iq ^i ( q ) $.</p>
<h5><span id="solution3">Solution3</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n iq ^i &amp; = \sum _{ j = 1  } ^n \sum _{ i = j  }
^n q ^i \\
&amp; = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  }
\\
&amp; = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q
^j ) \\
&amp; = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  }
- q  } { q - 1  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="problemex2">ProblemEX2</span></h5>
<p>求$_{ i = 1 } ^n ( ai + b ) q ^{ i - 1 } ( q ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令$A = { q - 1 } , B = { q - 1 } <span class="math inline">\(,答案为\)</span>( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子$E <span class="math inline">\(，使得\)</span>Ef ( x ) =
f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子$f ( x ) = f ( x + 1 ) - f ( x )
$，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$= E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子$$,可以得到有限微积分的基本定理:</p>
<p>$g ( x ) = f ( x ) g ( x ) x = f ( x ) + C \ $</p>
<p>这里的$<span class="math inline">\(又被称为不定和式,是差分等于\)</span>g
$的一个函数类.</p>
<p>值得一提的是,这里的$C <span class="math inline">\(与无限微积分中的\)</span>C <span class="math inline">\(有一定区别,这里的\)</span>C <span class="math inline">\(可以是满足\)</span>p ( x ) = p ( x + 1 )
$的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果$g ( x ) = f ( x ) <span class="math inline">\(,那么有\)</span>_{
a } ^b g ( x ) x = f ( x ) | ^{ b } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a b <span class="math inline">\(,显然有\)</span><em>{ a } ^b g ( x ) x = </em>{ x
= a } ^{ b - 1 } g ( x ) \ $.</p>
<p>但如果$a &gt; b <span class="math inline">\(,那么\)</span>_{ a } ^b g
( x ) x = - _b ^a g ( x ) x \ $.</p>
<p>事实上,我们一定有:$_a ^b g ( x ) x + _b ^c g ( x ) x = _a ^c g ( x )
x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1 } $，有:</p>
<p>(x<sup>{})=mx</sup>{}，mx<sup>{}x=x</sup>{}+C，m\</p>
<p>\</p>
<p>类比无限微积分中的$D ( x ) = { x } $，有:</p>
<p>令H(x)=_{i=1}<sup>x\(H(x))=x</sup>{}，x^{}x =H(x)+C\</p>
<p>\</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<p>$( 2 ^x ) = 2 ^x ， ^x x = 2 ^x + C \ $</p>
<p>$( c ^x ) = ( c - 1 ) c ^x ， c ^x x = { c - 1 } + C , c \ $</p>
<p>$( c ^{ } ) = { c - x } , { c - x } x = c ^{ } + C , c - x \ $.</p>
<p>根据组合数公式,有:</p>
<p>$( { k } ) = { k - 1 } \ $.</p>
<h6><span id="example1">Example1</span></h6>
<p>仍然考虑平方和公式：</p>
<p>我们有:$k ^2 = k ^{ } + k ^{ } \ $.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S _{ n - 1  } &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
&amp; = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{
\underline { 1  }  } ) \\
&amp; = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x +
\sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
&amp; = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline
{ 2  }  }  } { 2  }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v &amp; = Ev \Delta u + u
\Delta v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p>$u v = uv - Ev u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p>$<em>{ i = l } ^{ r - 1 } ( a </em>{ i + 1 } - a _i ) b _i = a _r b
<em>r - a <em>l b <em>l - </em>{ i = l } ^{ r - 1 } a </em>{ i + 1 } ( b
</em>{ i + 1 } - b _i ) \ $.</p>
<h6><span id="example1">Example1</span></h6>
<p>求$_{ k = 0 } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$x 2 ^x x = x 2 ^x - ^{ x + 1 } x = x 2 ^x - 2 ^{ x + 1 } + C \
$.</p>
<p>改为定和式形式，显然有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^n k 2 ^k \\
&amp; = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x \\
&amp; = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 \\
&amp; = ( n - 1 ) 2 ^{ n + 1  } + 2 \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="example2">Example2</span></h6>
<p>求$_{ k = 0 } ^{ n - 1 } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = { 2 } x ^{ } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$xH _x x = { 2 } H _x - { 4 } + C \ $.</p>
<p>带入即可求出原式$= { 2 } ( H _n - { 2 } ) \ $.</p>
<h6><span id="example3">Example3</span></h6>
<p>求$_{ i = 1 } ^n { i ( i + 1 ) } \ $.</p>
<p>令$u = ( 2 n + 1 ) , v = - { i } <span class="math inline">\(,则\)</span>u = 2 , v = { i ( i + 1 ) } $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } &amp; = ( 2 n +
3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( -
\frac { 2  } { i + 1  } ) \\
&amp; = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n
+ 1  } \\
&amp; = 2 H _n - \frac { n  } { n + 1  }
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>求$_{ i = 0 } ^{ n - 1 } { ( k + 1 ) ( k + 2 ) } \ $.</p>
<p>令$u = H _n , v = - { n + 1 } , u = { n + 1 } , v = { ( n + 1 ) ( n +
2 ) } \ $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  }
&amp; = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( -
\frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } (
\frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  }
{ n + 1  } ) \\
&amp; = 1 - \frac { H _n + 1  } { n + 1  }
\end{aligned}
\]</span></p>
<h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3>
<h5><span id="example">Example</span></h5>
<p>令$A = { 2 n - 1 | n <em>{ + } } , B = { 3 n - 1 | n </em>{ + } }
<span class="math inline">\(.求\)</span>A B <span class="math inline">\(,以及\)</span>A B $的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
$$
<span class="math display">\[\begin{aligned}
a \in A \Leftrightarrow a &amp; \equiv - 1 \pmod { 2  } \\
b \in B \Leftrightarrow b &amp; \equiv - 1 \pmod { 6  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以$A B = { 6 n - 1 | n _{ + } } $.</p>
<p>而同理,$x A B x - 1 / - 2 / - 3 / - 5 $.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3>
<p>设$A = { x | x = 2 n - 1 , n <em>+ } , B = { x | x = 2 ^n , n </em>+
} <span class="math inline">\(,现在将\)</span>A B <span class="math inline">\(中的元素排序并提取成一个数列\)</span>a <span class="math inline">\(,求使得\)</span>S _n &gt; 12 a _n <span class="math inline">\(最小的正整数\)</span>n $.</p>
<p>写出数列,它长这样:</p>
<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 \\
3 &amp; 4 \\
5 &amp; 7 &amp; 8 \\
9 &amp; 11 &amp; 13 &amp; 15 &amp; 16 \\
&amp; &amp; \cdots
\end{matrix}
\]</span></p>
<p>不妨设$n <span class="math inline">\(在第\)</span>r <span class="math inline">\(行\)</span>c <span class="math inline">\(列,显然\)</span>( r , c ) <span class="math inline">\(和\)</span>n $构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的$n <span class="math inline">\(能快速表达\)</span>( r , c )
$,要么反之.显然反之比较简单.</p>
<p>考虑设前$k <span class="math inline">\(行共有\)</span>W <em>k <span class="math inline">\(个数,不难发现\)</span>W </em>{ k + 1 } = W _k + 2
^{ k - 1 } + 1 , W _k = 2 ^{ k - 1 } + k $.</p>
<p>显然,对于$( r , c ) <span class="math inline">\(来说,它对应的\)</span>n <span class="math inline">\(就是\)</span>W _{ r - 1 } + c $.</p>
<p>令$SR _{ r } <span class="math inline">\(为前\)</span>r <span class="math inline">\(行数字之和,不难发现\)</span>SR _r = 2 ^{ r + 1 } -
2 + ( 2 ^{ r - 1 } ) ^2 $.</p>
<p>接下来考虑找到这个最小的$n <span class="math inline">\(,显然\)</span>r <span class="math inline">\(,接下来只考虑\)</span>r $的情况.</p>
<p>那么我们可以轻松写出$S _n <span class="math inline">\(和\)</span>a _n
$的表达式,下面直接给出:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = SR _{ r - 1  } + \sum _{ k = 1  } ^c ( 2 ^{ r - 1  } + 2 k
- 1 ) - [ c &amp; = 2 ^{ r - 2  } + 2 ] \\
S _n &amp; = 2 ^r - 2 + 4 ^{ r - 2  } + 2 ^{ r - 1  } c + c ^2 - [ c
&amp; = 2 ^{ r - 2  } + 1 ] \\
a _n &amp; = 2 ^{ r - 1  } + 2 c - 1 - [ c &amp; = 2 ^{ r - 2  } + 1 ]
\end{aligned}
\]</span></p>
<p>讨论一下$[ c = 2 ^{ r - 2 } + 1 ] $这个判定式取$0 $还是取$1
$,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3>
<h2><span id="几何导论">几何导论</span></h2>
<h3><span id="三角相关">三角相关</span></h3>
<h4><span id="三角恒等变换">三角恒等变换</span></h4>
<h5><span id="两角和差公式">两角和差公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin ( A + B ) &amp; = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) &amp; = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) &amp; = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) &amp; = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) &amp; = \frac { \tan A + \tan B  } { 1 - \tan A \tan B  }
\\
\tan ( A - B ) &amp; = \frac { \tan A - \tan B  } { 1 + \tan A \tan B  }
\end{aligned}
\]</span></p>
<h5><span id="倍角公式">倍角公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\tan ( 2 A ) &amp; = \frac { 2 \tan A  } { 1 - \tan ^2 A  } \\
\sin ( 2 A ) &amp; = 2 \sin A \cos A \\
\cos ( 2 A ) &amp; = \cos ^2 A - \sin ^2 A &amp; = 2 \cos ^2 A - 1 &amp;
= 1 - 2 \sin ^2 A
\end{aligned}
\]</span></p>
<h5><span id="半角公式">半角公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin ( \frac { A  } { 2  } ) &amp; = \pm \sqrt { \frac { 1 - \cos A  } {
2  }  } \\
\cos ( \frac { A  } { 2  } ) &amp; = \pm \sqrt { \frac { 1 + \cos A  } {
2  }  } \\
\tan ( \frac { A  } { 2  } ) &amp; = \frac { \sin A  } { 1 + \cos A  }
&amp; = \frac { 1 - \cos A  } { \sin A  } &amp; = \pm \sqrt { \frac { 1
- \cos A  } { 1 + \cos A  }  }
\end{aligned}
\]</span></p>
<h5><span id="和差化积">和差化积</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin A + \sin B &amp; = 2 \sin ( \frac { A + B  } { 2  } ) \cos ( \frac
{ A - B  } { 2  } ) \\
\sin A - \sin B &amp; = 2 \cos ( \frac { A + B  } { 2  } ) \sin ( \frac
{ A - B  } { 2  } ) \\
\cos A + \cos B &amp; = 2 \cos ( \frac { A + B  } { 2  } ) \cos ( \frac
{ A - B  } { 2  } ) \\
\cos A - \cos B &amp; = - 2 \sin ( \frac { A + B  } { 2  } ) \sin (
\frac { A - B  } { 2  } ) \\
\tan A + \tan B &amp; = \frac { \sin ( A + B )  } { \cos A \cos B  }
\end{aligned}
\]</span></p>
<p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<p><span class="math display">\[
\sin ^2 A - \sin ^2 B = \sin ( A - B ) \sin ( A + B )
\]</span></p>
<p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin A \sin B &amp; = - \frac { 1  } { 2  } [ \cos ( A + B ) - \cos ( A
- B ) ] \\
\cos A \cos B &amp; = \frac { 1  } { 2  } [ \cos ( A + B ) + \cos ( A -
B ) ] \\
\sin A \cos B &amp; = \frac { 1  } { 2  } [ \sin ( A + B ) + \sin ( A -
B ) ] \\
\cos A \sin B &amp; = \frac { 1  } { 2  } [ \sin ( A + B ) - \sin ( A -
B ) ]
\end{aligned}
\]</span></p>
<h5><span id="万能公式">万能公式</span></h5>
<p>令$w = { 2 } $,则:</p>
<p><span class="math display">\[
\begin{aligned}
\sin A &amp; = \frac { 2 w  } { 1 + w ^2  } \\
\cos A &amp; = \frac { 1 - w ^2  } { 1 + w ^2  } \\
\tan A &amp; = \frac { 2 w  } { 1 - w ^2  }
\end{aligned}
\]</span></p>
<p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<p><span class="math display">\[
\begin{aligned}
\cos ( x ) &amp; = \frac { e ^{ ix  } + e ^{ - ix  }  } { 2  } \\
\sin ( x ) &amp; = \frac { e ^{ ix  } - e ^{ - ix  }  } { 2 i  }
\end{aligned}
\]</span></p>
<h5><span id="补充公式">补充公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
1 + \sin A &amp; = ( \sin \frac { A  } { 2  } + \cos \frac { A  } { 2  }
) ^2 \\
1 - \sin A &amp; = ( \sin \frac { A  } { 2  } - \cos \frac { A  } { 2  }
) ^2
\end{aligned}
\]</span></p>
<h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4>
<p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的$k
$来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6>
<p>已知函数$f ( x ) = ( x + ) , w &gt; 0 <span class="math inline">\(,\)</span>f ( - { 6 } ) = 0 , f ( { 2 } ) = - 1
<span class="math inline">\(,求\)</span>w <span class="math inline">\(和\)</span>$的表达式.</p>
<p>正确做法应该是强设$k _1 , k _2 $,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的$<span class="math inline">\(和\)</span>$都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令$ { 2 } $为单位$1 $,我们必有以下式子:</p>
<p><span class="math display">\[
\begin{aligned}
- \frac { \omega  } { 3  } + \varphi &amp; \equiv 0 \pmod { 2  } \\
\omega + \varphi &amp; \equiv 3 \pmod { 4  }
\end{aligned}
\]</span></p>
<p>下面推导$$,首先将上面两个式子直接相减,立有:</p>
<p><span class="math display">\[
\frac { 4  } { 3  } \omega \equiv 1 \pmod { 2  }
\]</span></p>
<p>对于$$,考虑类似的做法,将第一个式子乘以$3
$后与第二个式子相加,立有:</p>
<p><span class="math display">\[
4 \varphi \equiv 1 \pmod { 2  }
\]</span></p>
<p>这样我们得到的必须满足的条件就有以下几条:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 4  } { 3  } \omega &amp; \equiv 1 \pmod { 2  } \\
4 \varphi &amp; \equiv 1 \pmod { 2  } \\
\omega + \varphi &amp; \equiv 3 \pmod { 4  }
\end{aligned}
\]</span></p>
<h3><span id="向量相关">向量相关</span></h3>
<h4><span id="旋转模型">旋转模型</span></h4>
<p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6>
<p>已知$AB = 2 , AC = 1 , A = <span class="math inline">\(,\)</span>BC
<span class="math inline">\(绕\)</span>B <span class="math inline">\(点顺时针旋转\)</span> { 3 } <span class="math inline">\(得到\)</span>BD <span class="math inline">\(,求以\)</span><span class="math inline">\(表示\)</span>S _{ CBD } $.</p>
<p>先来说文化课做法,我们直接表示$S <span class="math inline">\(,令\)</span>= ABC $:</p>
$$
<span class="math display">\[\begin{aligned}
S &amp; = | BD | \sin ( \alpha + \frac { \pi  } { 3  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于这个式子,我们发现如果我们能得到$| BD | ( ) <span class="math inline">\(和\)</span>| BD | ( ) $就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现$BD <span class="math inline">\(是\)</span><span class="math inline">\(的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出\)</span>|
BD | <span class="math inline">\(,余弦定理可以帮助我们求出\)</span>| BD
| $.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出$ <span class="math inline">\(和\)</span>
<span class="math inline">\(的坐标表示,将\)</span>
$用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4>
<p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol type="1">
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p></li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作$1
$是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p></li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6>
<p>$ABC <span class="math inline">\(中,\)</span>b ^2 = ac <span class="math inline">\(,点\)</span>D <span class="math inline">\(在\)</span>AC <span class="math inline">\(上且满足\)</span>BD = b <span class="math inline">\(,有\)</span> = 2 <span class="math inline">\(,求\)</span>ABC $.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定$c = 1 <span class="math inline">\(,于是有\)</span>b ^2 = a $.</p>
<p>考虑我们要求$ABC <span class="math inline">\(,而我们有一条很奇怪的边\)</span>BD <span class="math inline">\(,似乎不满足任何性质,我们立刻想到要把它用\)</span>ABC
$的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让$c = 1
$,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4>
<h5><span id="奔驰定理">奔驰定理</span></h5>
<p>对于$ABC <span class="math inline">\(内一点\)</span>P <span class="math inline">\(,立有\)</span>S <em>{ PBC } + S </em>{ PAC } + S
_{ PAB } = $.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令$a
= PA , b = PB , c = PC $,我们要证奔驰定理,也就是要证明:</p>
$$
<span class="math display">\[\begin{aligned}
bc \sin \alpha \overrightarrow { PA  } + ac \sin \beta \overrightarrow {
PB  } + ab \sin \gamma \overrightarrow { PC  } &amp; = \vec { 0  } \\
abc \sin \alpha \frac { \overrightarrow { PA  }  } { a  } + abc \sin
\beta \frac { \overrightarrow { PB  }  } { b  } + abc \sin \gamma \frac
{ \overrightarrow { PC  }  } { c  } &amp; = \vec { 0  } \\
\sin \alpha \frac { \overrightarrow { PA  }  } { a  } + \sin \beta \frac
{ \overrightarrow { PB  }  } { b  } + \sin \gamma \frac {
\overrightarrow { PC  }  } { c  } &amp; = \vec { 0  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑$| { a } | = | { b } | = | { c } | = 1
$,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5>
<p>有正弦定理,$| | = | | = | | = { 2 A } $.</p>
<p>考虑三个三角形的面积可以表示为$ { 2 } <span class="math inline">\(,又考虑到圆中的\)</span><span class="math inline">\(是圆心角是圆周角的两倍,立有\)</span>( 2 A ) + ( 2
B ) + ( 2 C ) = $.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6>
<p>在$ABC <span class="math inline">\(中,\)</span>AB = 2 , BC = , AC = 3
<span class="math inline">\(,若\)</span>O <span class="math inline">\(是其外心,且\)</span> = p + q $.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用$| OA | = | OB
| = | OC | <span class="math inline">\(,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于\)</span>p
, q $的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了$| OA | <span class="math inline">\(,用上\)</span>| OB
| <span class="math inline">\(,这样的话我们两边同时加上\)</span> <span class="math inline">\(,就可以得到\)</span>p , q <span class="math inline">\(的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据\)</span>|
OC | $也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow { AO  } &amp; = p \overrightarrow { AB  } + q
\overrightarrow { AC  } \\
\vec { 0  } &amp; = ( p + q - 1 ) \overrightarrow { OA  } + p
\overrightarrow { OB  } + q \overrightarrow { OC  }
\end{aligned}
\]</span></p>
<p>考察奔驰定理,立有$ { ( 2 A ) } = { ( 2 B ) } = { ( 2 C ) }
$,简单题.</p>
<h6><span id="example2">Example2</span></h6>
<p>已知相异两点$O , H <span class="math inline">\(分别为\)</span>ABC
<span class="math inline">\(的外心和垂心,若\)</span> = m ( + + ) <span class="math inline">\(,求\)</span>m $.</p>
<p>这题要用到的性质是,我们一定要知道$( + ) = 0
$,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出$ <span class="math inline">\(,然后两边同时乘以\)</span> <span class="math inline">\(就可以解决.注意到最后解方程的时候要么\)</span>m =
1 <span class="math inline">\(,要么三角形等边,但是我们声明过\)</span>O ,
H $相异两点.</p>
<h5><span id="重心">重心</span></h5>
<p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的$1
: 2 $的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若$O <span class="math inline">\(是重心,则必有\)</span> + + = $.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5>
<p>若$O <span class="math inline">\(是重心,立有\)</span> = 0 <span class="math inline">\(,将\)</span> = + <span class="math inline">\(,立有\)</span> = =
$.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有$ A + B + C = $.</p>
<h5><span id="内心">内心</span></h5>
<p>根据奔驰定理,立有$a + b + c = $.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3>
<h4><span id="基本概念">基本概念</span></h4>
<h5><span id="直线">直线</span></h5>
<p>使用直线的方向向量$ = ( n , m , p ) <span class="math inline">\(和直线上一点\)</span>M _0 = ( x _0 , y _0 , z _0 )
$.那么方程显然为:</p>
<p><span class="math display">\[
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z
_0  } { p  }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt
\end{cases}
\]</span></p>
<h5><span id="平面">平面</span></h5>
<p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) <span class="math inline">\(和该平面的法向量\)</span> <span class="math inline">\(来表示一个平面,不妨设\)</span> = ( A , B , C )
$,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0
\]</span></p>
<p>如果我们令$D = - ( Ax _0 + By <em>0 + Cz </em>) $,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h5><span id="夹角">夹角</span></h5>
<h6><span id="两直线夹角">两直线夹角.</span></h6>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$ = ( n _1 , m _1 , p _1 ) , = ( n _2 , m _2 , p _2
) <span class="math inline">\(,也就有\)</span>= ( { | _1 | | _2 | } ) \
$.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6>
<p>同样使用向量,不妨设方向向量$ = ( n , m , p ) <span class="math inline">\(,法向量\)</span> = ( a , b , c ) <span class="math inline">\(,那么\)</span>= ( { | | | | } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p></li>
<li><p>若直线与平面垂直,则$ { m } = { n } = { p }
$.注意这里分母可能除以$0 <span class="math inline">\(,我们实际上应该是三个形如\)</span>a = mt
$的参数方程,这里简化了.</p></li>
</ol>
<h5><span id="交点">交点</span></h5>
<p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3>
<h4><span id="约定">约定</span></h4>
<p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可($mx
+ ny = 1 <span class="math inline">\(需要判断过原点的直线,\)</span>y =
kx + b <span class="math inline">\(需要判断平行于\)</span>y
$轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点$F _1 , F _2 <span class="math inline">\(距离之和为常数(\)</span>&gt; | F _1 F _2 | <span class="math inline">\()的点轨迹.即:\)</span>{ P | F _1 P | + | F _2 P |
= 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线($x = { c } <span class="math inline">\()的距离比是常数\)</span>e = { a } <span class="math inline">\(的点轨迹,即\)</span>{ P { d _1 } = { d _2 } = { a
} = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) <span class="math inline">\(的斜率乘积等于定值\)</span>e ^2 - 1
$的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5>
<h6><span id="标准方程">标准方程</span></h6>
<p>由定义不难得到椭圆的标准方程:$ { a ^2 } + { b ^2 } = 1 ( b ^2 = a ^2
- c ^2 , a &gt; b &gt; 0 ) $.</p>
<h6><span id="一般方程">一般方程</span></h6>
<p>$nx ^2 + my ^2 = 1 ( n , m ) <span class="math inline">\(,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下\)</span>n
<span class="math inline">\(和\)</span>m $的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若$P ( x _0 , y _0 ) <span class="math inline">\(,则\)</span>| PF _1
| = a + ex _0 <span class="math inline">\(,\)</span>| PF _2 | = a - ex
_0 $.</p>
<h6><span id="焦点弦">焦点弦</span></h6>
<p>过$F _1 <span class="math inline">\(的弦\)</span>| AB | = 2 a + e ( x
_1 + x _2 ) $.</p>
<p>过$F _2 <span class="math inline">\(的弦\)</span>| AB | = 2 a - e ( x
_1 + x _2 ) $.</p>
<p>注意到焦点弦最短时$x _1 = x _2 $.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即$PF _1 F _2 <span class="math inline">\(,令\)</span>= F _1 PF _2
$,有以下性质:</p>
<ol type="1">
<li><p>$C = 2 a + 2 c $.</p></li>
<li><p>$S = b ^2 { 2 } = c | y _P | $.</p></li>
<li><p>$ - 2 e ^2 <span class="math inline">\((当\)</span>P
$在短轴上取等).</p></li>
<li><p>$| PF _1 | | PF _2 | = { 1 + } $.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>已知椭圆$ { a ^2 } + { b ^2 } = 1 <span class="math inline">\(,\)</span>P <span class="math inline">\(是椭圆上一点,\)</span>F _1 PF _2 <span class="math inline">\(的角平分线交\)</span>x <span class="math inline">\(轴于\)</span>Q ( { 4 } , 0 )
$,求离心率取值范围.</p>
<p>注意到$S _{ QPF <em>1 } = { 3 } S </em>{ QPF _2 } <span class="math inline">\(,又有\)</span>Q <span class="math inline">\(到\)</span>PF _1 <span class="math inline">\(和\)</span>PF _2 <span class="math inline">\(的距离相等,用等积法,显然\)</span>PF _1 = { 4 } a ,
PF _2 = { 4 } a $.</p>
<p>然后用三角形不等式做差就行.$2 c &gt; { 2 } a , { 4 } &lt; e $</p>
<h4><span id="双曲线">双曲线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点$F _1 , F _2 <span class="math inline">\(距离之差为常数(\)</span>&gt; | F _1 F _2 | <span class="math inline">\()的点轨迹.即:\)</span>{ P | | F _1 P | - | F _2 P
| | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线($x = { c } <span class="math inline">\()的距离比是常数\)</span>e = { a } <span class="math inline">\(的点轨迹,即\)</span>{ P { d _1 } = { d _2 } = { a
} = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) } $.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) <span class="math inline">\(的斜率乘积等于定值\)</span>e ^2 - 1
$的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若$P ( x _0 , y _0 ) , ( x _0 &gt; 0 ) <span class="math inline">\(,则\)</span>| PF _1 | = a + ex _0 <span class="math inline">\(,\)</span>| PF _2 | = - a + ex _0 $.</p>
<h6><span id="渐近线">渐近线</span></h6>
<p>$y = { a } x $.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成$0
$得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即$PF _1 F _2 <span class="math inline">\(,令\)</span>= F _1 PF _2
$,有以下性质:</p>
<ol type="1">
<li>$S = { { 2 } } $.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5>
<h6><span id="焦点弦">焦点弦</span></h6>
<p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线$AB <span class="math inline">\(为过\)</span>y ^2 = 2 px ( p &gt;
0 ) <span class="math inline">\(焦点的弦,\)</span>A ( x _1 , y _1 ) , B
( x _2 , y _2 ) <span class="math inline">\(,倾斜角为\)</span><span class="math inline">\(,准线与\)</span>x <span class="math inline">\(轴交点为\)</span>E ( - { 2 } , 0 ) <span class="math inline">\(,作\)</span>AA _1 <span class="math inline">\(,\)</span>BB _1 <span class="math inline">\(垂直于准线于\)</span>A _1 , B _1 $,则:</p>
<ol type="1">
<li><p>$| AF | = x _1 + { 2 } <span class="math inline">\(,\)</span>| BF
| = x _2 + { 2 } <span class="math inline">\(,\)</span>| AB | = x _1 + x
_2 + p , { | FA | } + { | FB | } = { p } $.</p></li>
<li><p>$| AF | = { 1 - } , | BF | = { 1 + } , | AB | = { ^2 }
$.</p></li>
<li><p>$x _1 x _2 = { 4 } <span class="math inline">\(,\)</span>y _1 y
_2 = - p ^2 $.</p></li>
<li><p>$S _{ AOB } = { 2 } $.</p></li>
<li><p>$k <em>{ AE } + k </em>{ BE } = 0 $.</p></li>
<li><p>$A , O , B _1 <span class="math inline">\(三点共线,\)</span>B , O
, A _1 $三点共线.</p></li>
<li><p>以$AB $为直径的圆与抛物线的准线相切.</p></li>
<li><p>以$A _1 B _1 <span class="math inline">\(为直径的圆与\)</span>AB
$相切.</p></li>
<li><p>以$AF <span class="math inline">\(或\)</span>BF <span class="math inline">\(为直径的圆与\)</span>y $轴相切.</p></li>
</ol>
<h4><span id="通用解法">通用解法</span></h4>
<h5><span id="联立方程">联立方程</span></h5>
<h6><span id="点参">点参</span></h6>
<p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线$l <span class="math inline">\(上有两点\)</span>N ( x _1 , y
_1 ) , M ( x _2 , y _2 ) <span class="math inline">\(,这条直线的斜率为\)</span>k <span class="math inline">\(,那么\)</span>| NM | = | x _1 - x _2 | = | y _1 -
y _2 | $.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) <span class="math inline">\(,其中点\)</span>M ( x _0 , y _0 ) $,有$2 x _0 = x
_1 + x _2 , 2 y _0 = y _1 + y _2 $.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线$l <span class="math inline">\(与曲线交于两点\)</span>N ( x
_1 , y _1 ) , M ( x _2 , y _2 ) <span class="math inline">\(,这条直线的斜率为\)</span>k <span class="math inline">\(,\)</span>MN <span class="math inline">\(的中点为\)</span>P ( x _0 , y _0 ) $,那么:</p>
<ol type="1">
<li><p>在椭圆$ { a ^2 } + { b ^2 } = 1 ( a &gt; b &gt; 0 ) <span class="math inline">\(中,\)</span>k { x _0 } = - { a ^2 } = e ^2 - 1
$.</p></li>
<li><p>在双曲线$ { a ^2 } - { b ^2 } = 1 <span class="math inline">\(中,\)</span>k { x _0 } = { a ^2 } = e ^2 - 1
$.</p></li>
<li><p>在抛物线$y ^2 = 2 px ( p &gt; 0 ) <span class="math inline">\(中,\)</span>k = { y _0 } = { p } $.</p></li>
</ol>
<h6><span id="小联立">小联立</span></h6>
<p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6>
<p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线$PA <span class="math inline">\(,\)</span>PB <span class="math inline">\(,我们可以将公共点\)</span>P <span class="math inline">\(平移至原点,这样\)</span>PA <span class="math inline">\(和\)</span>PB <span class="math inline">\(的方程都方便表达.然后设\)</span>AB <span class="math inline">\(的方程为\)</span>mx + ny = 1
$(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以$mx
+ ny <span class="math inline">\(,零次项乘以\)</span>( mx + ny ) ^2
<span class="math inline">\(,这样就得到了一个齐次式子.将两边同时除以\)</span>x
^2 <span class="math inline">\(后就得到了一个和\)</span>k = { x }
$有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的$x _1 x _2 <span class="math inline">\(和\)</span>x _1 + x _2 $之间的关系来做.</p>
<p>当然还有一种情况是问形如$ { Cx _1 + Dx _2 } <span class="math inline">\(是定值的问题,这个时候一定有\)</span> { C } = { D }
$.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令$w = { x _2 } <span class="math inline">\(,自然有\)</span>w + { w } + 2 = { x _1 x _2 }
$.</p>
<p>还比如有$y _2 = ny _1 + m <span class="math inline">\(,我们可以用配凑技巧改写作\)</span>( y _2 + w ) = k
( y _1 + w ) <span class="math inline">\(,也就有\)</span> { y _1 + w } =
k $,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线$y = kx + <span class="math inline">\(与曲线\)</span> { m } + {
n } = 1 <span class="math inline">\(相交于\)</span>A ( x _1 , y _1 )
<span class="math inline">\(和\)</span>B ( x _2 , y _2 ) $.</p>
<p>那么联立方程是:$( n + mk ^2 ) x ^2 + 2 k mx + m ( ^2 - n ) = 0 $.</p>
<p>判别式:$= 4 mn ( n + mk ^2 - ^2 ) $.</p>
<p>韦达定理:</p>
<p><span class="math display">\[
\begin{aligned}
x _1 + x _2 &amp; = \frac { - 2 km \varphi  } { n + mk ^2  } \\
x _1 x _2 &amp; = \frac { m ( \varphi ^2 - n )  } { n + mk ^2  } \\
| x _1 - x _2 | &amp; = \frac { \sqrt { \Delta  }  } { n + mk ^2  }
\end{aligned}
\]</span></p>
<h6><span id="配凑法">配凑法</span></h6>
<p>参考:https://zhuanlan.zhihu.com/p/521025768.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6>
<p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线$y ^2 = 4 x <span class="math inline">\(,若\)</span>A , B
<span class="math inline">\(位于抛物线上\)</span>x <span class="math inline">\(轴上方不同的两点,直线\)</span>OA , OB <span class="math inline">\(的斜率分别为\)</span>k _1 , k _2 <span class="math inline">\(,且满足\)</span>k _1 k _2 - 4 = 4 k _1 + 4 k <em>2
<span class="math inline">\(,求证:\)</span>AB <span class="math inline">\(过定点,并求出\)</span>k </em>{ AB }
$的取值范围.</p>
<p>注意到$k _1 <span class="math inline">\(和\)</span>k _2
$之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设$AB : y = kx + b <span class="math inline">\(,则\)</span>A ( x _1 ,
kx _1 + b ) , B ( x _2 , kx _2 + b ) <span class="math inline">\(,显然\)</span>k _1 = k + { x _1 } , k _2 = k + { x
_2 } $.</p>
<p>直接带入方程,有:</p>
$$
<span class="math display">\[\begin{aligned}
( k + \frac { b  } { x _1  } ) ( k + \frac { b  } { x _2  } ) - 4 &amp;
= 4 ( 2 k + \frac { b  } { x _1  } + \frac { b  } { x _2  } ) \\
k ^2 + kb ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) + \frac {
b ^2  } { x _1 x _2  } - 4 &amp; = 8 k + 4 b ( \frac { 1  } { x _1  } +
\frac { 1  } { x _2  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而直接大联立得到的式子是:</p>
<p><span class="math display">\[
\begin{aligned}
k ^2 x ^2 + ( 2 kb - 4 ) x + b ^2 &amp; = 0 \\
\Delta &amp; = 16 - 16 kb &amp; &gt; 0 , kb &amp; &lt; 1 \\
x _1 x _2 &amp; = \frac { b ^2  } { k ^2  } , x _1 + x _2 &amp; = \frac
{ 4 - 2 kb  } { k ^2  } , \frac { 1  } { x _1  } + \frac { 1  } { x
_2  } &amp; = \frac { 4 - 2 kb  } { b ^2  }
\end{aligned}
\]</span></p>
<p>带入,得到$k - b = 4 <span class="math inline">\(,因此过定点\)</span>(
- 1 , - 4 ) <span class="math inline">\(,与\)</span>kb &lt; 1 <span class="math inline">\(联立得到\)</span>k &lt; 2 + $.</p>
<p>还没完,这种题一定要检查一遍条件.注意到$AB <span class="math inline">\(为\)</span>x <span class="math inline">\(轴上方两点的性质没用到,这意味着\)</span>y _1 y _2
&gt; 0 y _1 + y _2 &gt; 0 $,带入方程得到:</p>
<p><span class="math display">\[
\begin{aligned}
b ^2 + b ( \frac { 4 - 2 kb  } { k  } ) + b ^2 &amp; &gt; 0 \\
\frac { 4 - 2 kb  } { k  } + 2 b &amp; &gt; 0
\end{aligned}
\]</span></p>
化简得到$
<span class="math display">\[\begin{cases}b &gt; 0 \\ k &gt; 0
\end{cases}\]</span>
<p><span class="math inline">\(,解得\)</span>k &gt; 4 <span class="math inline">\(,于是\)</span>k ( 4 , 2 + ) $.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,$OA <span class="math inline">\(和\)</span>OB
$的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<p><span class="math display">\[
\begin{aligned}
k _{ OA  } &amp; = \frac { y _1  } { x _1  } , k _{ OB  } &amp; = \frac
{ y _2  } { x _2  } \\
\frac { y _1 y _2  } { x _1 x _2  } - 4 &amp; = 4 ( \frac { y _1  } { x
_1  } + \frac { y _2  } { x _2  } ) \\
16 - 4 y _1 y _2 &amp; = 16 ( y _1 + y _2 )
\end{aligned}
\]</span></p>
<p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<p><span class="math display">\[
\begin{aligned}
AB : \\
x - x _1 &amp; = ( y - y _1 ) \frac { x 1 - x _2  } { y _1 - y _2  } \\
x - \frac { y _1 ^2  } { 4  } &amp; = ( y - y _1 ) \frac { 1  } { 4  } (
y _1 + y _2 ) \\
x &amp; = \frac { y _1 + y _2  } { 4  } y - \frac { y _1 y _2  } { 4  }
\\
x &amp; = \frac { y _1 + y _2  } { 4  } y - 1 + ( y _1 + y _2 )
\end{aligned}
\]</span></p>
<p>显然过定点$( - 1 , - 4 ) <span class="math inline">\(,并且通过\)</span>y _1 <span class="math inline">\(和\)</span>y _2 $的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个$ { x _1 - x _2 } = { y _1 - y
_2 }
$的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆$ { 4 } + y ^2 = 1 <span class="math inline">\(,\)</span>P ,
Q <span class="math inline">\(在椭圆上,\)</span>A ( 2 , 0 ) <span class="math inline">\(,\)</span>k <em>{ AP } k </em>{ AQ } = { 20 }
<span class="math inline">\(,求证:\)</span>PQ $过定点.</p>
<p>注意到$A ( 2 , 0 ) <span class="math inline">\(,设\)</span>P ( x _1 ,
y _1 ) , Q ( x _2 , y _2 ) <span class="math inline">\(,\)</span>PQ : m
( x - 2 ) + yn = 1 <span class="math inline">\(,那么我们要求的也就是\)</span>x - 2 <span class="math inline">\(和\)</span>y $之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然$ { 4 } + y ^2 = 1 { 4 } + ( x - 2 ) +
y ^2 = 0 $.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令$x ’ = x - 2 , y ’ = y <span class="math inline">\(,我们有\)</span>x = x ’ + 2 , y = y ’ <span class="math inline">\(,带入就可以得到关于\)</span>x ’ , y ’ <span class="math inline">\(的方程,然后再带回\)</span>x <span class="math inline">\(和\)</span>y $就行.</p>
<p>我们开始推导:</p>
$$
<span class="math display">\[\begin{aligned}
\frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 \\
( x - 2 ) ^2 + 4 ( x - 2 ) + 4 y ^2 = 0 \\
( x - 2 ) ^2 + 4 n ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
( 4 n + 1 ) ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
4 n + 1 + 4 m \frac { y  } { x - 2  } + 4 ( \frac { y  } { x - 2  } ) ^2
= 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$k = { x - 2 } $,也就得到了$4 n + 1 + 4 mk + 4 k ^2 = 0 <span class="math inline">\(.用一遍韦达定理,有:\)</span>k _1 k _2 = { 4 } = {
20 } , n = - { 5 } $.</p>
<p>也就有:$PQ : - { 5 } ( x - 2 ) + my = 1 <span class="math inline">\(,显然过定点\)</span>( - 3 , 0 ) $.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆$ { 9 } + y ^2 = 1 <span class="math inline">\(,\)</span>P ,
Q <span class="math inline">\(是该椭圆上两动点,\)</span>M , N <span class="math inline">\(分别为\)</span>P , Q <span class="math inline">\(在\)</span>x <span class="math inline">\(轴上的射影,而且\)</span>k <em>{ OP } k </em>{ OQ }
= - 1 <span class="math inline">\(,记\)</span>S = S <em>{ OPM } + S
</em>{ OQN } <span class="math inline">\(,求\)</span>S $的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线$PQ <span class="math inline">\(很重要的时候,而这个题除了\)</span>P , Q <span class="math inline">\(两点以外,和\)</span>PQ
$半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) <span class="math inline">\(,\)</span>k = { x _1 } , - { k } = { x _2 } $:</p>
$$
<span class="math display">\[\begin{aligned}
2 S &amp; = | x _1 y _1 | + | x _2 y _2 | \\
&amp; = | x _1 ^2 k - \frac { 1  } { k  } x _2 ^2 | \\

\end{aligned}\]</span>
<p>$$</p>
<p>而联立方程,有:</p>
<p><span class="math display">\[
x _1 ^2 = \frac { 1  } { \frac { 1  } { 9  } + k  } , x _2 ^2 = \frac {
1  } { \frac { 1  } { 9  } - \frac { 1  } { k  }  }
\]</span></p>
<p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线$PQ <span class="math inline">\(有两个未知量,我们还需要拿\)</span>k <em>{ OP } k
</em>{ OQ } = - 1 $限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆$ { 2 } + y ^2 = 1 <span class="math inline">\(,\)</span>F (
1 , 0 ) <span class="math inline">\(,直线\)</span>l <span class="math inline">\(过\)</span>F <span class="math inline">\(且交椭圆于\)</span>A , B <span class="math inline">\(两点.求问:\)</span>x <span class="math inline">\(轴上是否存在异于\)</span>F <span class="math inline">\(的一点\)</span>Q <span class="math inline">\(,使得\)</span> { k _{ QB } } $是定值.</p>
<p>直接设$AB : x = ky + 1 <span class="math inline">\(,\)</span>Q ( q ,
0 ) $.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } &amp; = \frac { y _1 ( q - x _2
)  } { y _2 ( q - x _1 )  } \\
&amp; = - \frac { ky _1 y _2 + y _1 - qy _1  } { ky _1 y _2 + y _2 - qy
_2  }
\end{aligned}
\]</span></p>
<p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
$$
<span class="math display">\[\begin{aligned}
( k ^2 + 2 ) y ^2 + 2 ky - 1 &amp; = 0 \\
\Delta &amp; = 8 k ^2 + 8 &amp; &gt; 0 \\
y _1 + y _2 &amp; = - \frac { 2 k  } { k ^2 + 2  } \\
y _1 y _2 &amp; = - \frac { 1  } { k ^2 + 2  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$ { 2 } = k ( y _1 y _2 ) $,代入,有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } &amp; = - \frac { y _1 + y _2 + 2
y _1 - 2 qy _1  } { y _1 + y _2 + 2 y _2 - 2 qy _2  } \\
&amp; = - \frac { ( 3 - 2 q ) y _1 + y _2  } { ( 3 - 2 q ) y _2 + y
_1  }
\end{aligned}
\]</span></p>
<p>若是定值,那么就有:$ { 1 } = { 3 - 2 q } <span class="math inline">\(,解得\)</span>q _1 = 1 ( F ) <span class="math inline">\(,\)</span>q _2 = 2 ( Q ) $.</p>
<p>所以$Q ( 2 , 0 ) $.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆$ { 4 } + { 3 } = 1 <span class="math inline">\(,过\)</span>F
( - 1 , 0 ) <span class="math inline">\(的直线交椭圆于\)</span>M , N
<span class="math inline">\(两点,过\)</span>M <span class="math inline">\(作直线\)</span>x = - 4 <span class="math inline">\(的垂线,垂足为\)</span>E <span class="math inline">\(,求证:\)</span>EN $过定点.</p>
<p>根据对称原理,显然这个定点一定在$x $轴上.</p>
<p>我们先写大联立的式子:设$MN : x = - 1 + ky <span class="math inline">\(,带入有\)</span>( 3 m ^2 + 4 ) y ^2 - 6 my - 9 = 0
<span class="math inline">\(.再设\)</span>M ( x _1 , y _1 ) , N ( x _2 ,
y _2 ) $,自然有:</p>
<p><span class="math display">\[
\begin{cases}
\Delta = 144 k ^2 + 144 \\
y _1 + y _2 = \frac { 6 k  } { 3 k ^2 + 4  } \\
y _1 y _2 = \frac { - 9  } { 3 k ^2 + 4  }
\end{cases}
\]</span></p>
<p>接下来呢,我们想一下我们要求什么:我们要求出$EN <span class="math inline">\(的表达式:形如\)</span>y - m = k ( x - n ) <span class="math inline">\(,然后声明\)</span>( n , m ) $是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有$k = { x -
n } <span class="math inline">\(.而我们现在有两个点\)</span>E ( - 4 , y
_1 ) <span class="math inline">\(和\)</span>N ( x _2 , y _2 ) <span class="math inline">\(,又猜出\)</span>m = 0 <span class="math inline">\(,也就是我们要找到一个\)</span>n <span class="math inline">\(满足\)</span> { - 4 - n } = { x _2 - n } $.</p>
<p>我们倒着推:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { y _1  } { - 4 - n  } &amp; = \frac { y _2  } { x _2 - n  } \\
\frac { y _1  } { - 4 - n  } &amp; = \frac { y _2  } { ky _2 - 1 - n  }
\end{aligned}
\]</span></p>
<p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
ky _1 y _2 + \frac { 3  } { 2  } ( y _1 + y _2 ) &amp; = 0 \\
( x _2 + \frac { 5  } { 2  } ) y _1 &amp; = - \frac { 3  } { 2  } y _2
\\
y _1 &amp; = \frac { - 3  } { 2  } \frac { y _2  } { x _2 + \frac { 5  }
{ 2  }  } \\
\frac { y _1  } { - \frac { 3  } { 2  }  } &amp; = \frac { y _2  } { x
_2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - 4 + \frac { 5  } { 2  }  } &amp; = \frac { y _2  } {
x _2 + \frac { 5  } { 2  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做到这一步发现要做完了,不难发现$n = { 2 } $.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了$m = 0 $了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5>
<h6><span id="定义">定义</span></h6>
<p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点$P <span class="math inline">\(作直线\)</span>l
<span class="math inline">\(交二次曲线于\)</span>M , N <span class="math inline">\(两点(离\)</span>P <span class="math inline">\(近的是\)</span>M <span class="math inline">\(),则在\)</span>l <span class="math inline">\(上有且只有一点\)</span>Q <span class="math inline">\(,使得\)</span>| MQ | | NP | = | MP | | NQ | <span class="math inline">\((即\)</span>P , Q , M , N <span class="math inline">\(构成一调和点列).当\)</span>l <span class="math inline">\(绕着\)</span>P <span class="math inline">\(旋转时,\)</span>Q <span class="math inline">\(的轨迹是一条直线\)</span>p <span class="math inline">\((或一部分),这条直线\)</span>p <span class="math inline">\(叫做点\)</span>P <span class="math inline">\(关于二次曲线的极线,而\)</span>P <span class="math inline">\(叫做\)</span>p $关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:$p : { a ^2 } + { b ^2 } = 1 $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线$C : Ax ^2 + Bxy + Cy ^2 + Dx + Ey + F = 0 <span class="math inline">\(上的一点\)</span>P ( x _0 , y _0 ) <span class="math inline">\(,我们称它的极线为\)</span>p : Axx _0 + B { 2 } +
Cyy _0 + D { 2 } + E { 2 } + F = 0 $.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6>
<p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线$C <span class="math inline">\(,如果点\)</span>P
<span class="math inline">\(的极线经过点\)</span>Q <span class="math inline">\(,那么点\)</span>Q <span class="math inline">\(的极线经过点\)</span>P $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol type="1">
<li><p>设四边形$ABCD <span class="math inline">\((对边不平行)内接于二次曲线\)</span>C <span class="math inline">\(,则对角线交点\)</span>P <span class="math inline">\(的极线是两组对边交点的连线.反之同理,若\)</span>P
$在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p></li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p></li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p></li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6>
<p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知$ { a } + { b } = 1 <span class="math inline">\(,求证:\)</span> {
a ^2 } + { b ^2 } $.</p>
<p>设直线$l : { a } + { b } = 1 <span class="math inline">\(,\)</span>M
( , ) <span class="math inline">\(,则\)</span>M <span class="math inline">\(在\)</span>l $上.</p>
<p>又注意到$M <span class="math inline">\(显然是在单位圆上,而\)</span>l
<span class="math inline">\(是单位圆关于\)</span>P ( { a } , { b } )
<span class="math inline">\(的极点.又注意到\)</span>l <span class="math inline">\(与单位圆至少有一个交点,因此\)</span>P
$要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$ { 4 } + { 3 } = 1 <span class="math inline">\(,\)</span>A
_1 ( - 2 , 0 ) , A _2 ( 2 , 0 ) , D ( { 2 } , 0 ) <span class="math inline">\(,过\)</span>D <span class="math inline">\(的直线交椭圆于\)</span>P , Q <span class="math inline">\(两点(不与\)</span>A _1 , A _2 <span class="math inline">\(重合).\)</span>A _1 P A _2 Q = M <span class="math inline">\(,\)</span>A _1 Q A _2 P = N <span class="math inline">\(,设\)</span>k <em>1 = k </em>{ A _1 P } , k <em>2
= k </em>{ A _1 Q } <span class="math inline">\(.求证:\)</span>k _1 k _2
<span class="math inline">\(是定值,求出这个定值并求出\)</span>DMN
$面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知$MN : x = 8 $.</p>
<p>我们先来看已知$MN : x = 8 $之后怎么做:</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) <span class="math inline">\(,再设\)</span>PQ : x = ky + { 2 } <span class="math inline">\(,则:\)</span>k _1 k _2 = { x _1 + 2 } { x _2 + 2 }
<span class="math inline">\(,不难算出\)</span>k _1 k _2 = - { 20 }
$.</p>
<p>此时$S <em>{ DMN } = | MN | | 8 - { 2 } | { 2 } <span class="math inline">\(.不难发现只需求出\)</span>| MN | </em>{ } <span class="math inline">\(即可.而\)</span>MN x <span class="math inline">\(轴,所以\)</span>| MN | = | y _M - y _N | $.</p>
<p>接下来咋做?第一问求得$k _1 <span class="math inline">\(和\)</span>k
_2 $的关系不能白求啊!</p>
<p>我们有$A _1 P : x = - 2 + { k _1 } y , A _1 Q : x = - 2 + { k _2 } y
<span class="math inline">\(,带入\)</span>x = 8 <span class="math inline">\(,求得\)</span>y _M = 10 k _1 , y _N = 10 k _2
$.</p>
<p>于是$| MN | = 10 | k _1 - k _2 | <span class="math inline">\(.注意到\)</span>k _1 &gt; 0 - k _2 &gt; 0 k _1 ( -
k <em>2 ) = { 20 } <span class="math inline">\(,显然可以用基本不等式计算,最后得到\)</span>S
</em>{ } = { 2 } $.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出$A _1 Q : x = - 2 + { x _2 + 2 } y , A _2 P : x =
2 + { x _1 - 2 } y $,然后我们声明这两条直线的交点的横坐标一定是$8
$,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5>
<p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是$ { a ^2 } + { b ^2 } = 1 $.</p>
<p>我们将$y <span class="math inline">\(看作\)</span>x
$的函数,对两边求导,自然得到:</p>
<p><span class="math display">\[
\frac { 2 x  } { a ^2  } + \frac { 2 yy &#39;  } { b ^2  } = 0
\]</span></p>
<p>这是个方程,你可以解得$y ’ = - { a ^2 y } <span class="math inline">\(.而这就是椭圆过\)</span>( x , y )
$这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5>
<p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6>
<p>向量$ = ( x , y ) <span class="math inline">\(逆时针旋转\)</span><span class="math inline">\(后得到的答案是\)</span>A $,其中</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>你要不喜欢矩阵表示也不是不行,那向量$( x , y ) <span class="math inline">\(旋转\)</span><span class="math inline">\(得到\)</span>( x ’ , y ’ ) $,其中</p>
<p>y’=xsin+ycos</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6>
<p>我们注意到圆的方程是$( x ’ ) ^2 + ( y ’ ) ^2 = 1 <span class="math inline">\(,而椭圆的方程形如\)</span> { a ^2 } + { b ^2 } = 1
$.</p>
<p>我们注意到上面的式子等价于:$( { a } ) ^2 + ( { b } ) ^2 = 1 <span class="math inline">\(.我们将原坐标系中的所有坐标\)</span>( x , y )
<span class="math inline">\(全部变成\)</span>( { a } , { b } )
$之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令$ = ( x , y ) <span class="math inline">\(满足椭圆方程,令\)</span> = ( x ’ , y ’ )
$满足圆的方程,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
\begin{bmatrix}
\frac { 1  } { a  } , 0 \\
0 , \frac { 1  } { b  }
\end{bmatrix} \vec { f  } &amp; = \vec { g  } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{bmatrix}
a , 0 \\
0 , { b  }
\end{bmatrix} \vec { g  } = \vec { f  }
\]</span></p>
<h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6>
<p>注意到反比例函数的方程是$x ’ y ’ = 1 <span class="math inline">\(,而双曲线的方程是\)</span> { a ^2 } - { b ^2 } = 1
$.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
首先先转化为$x ^2 - y ^2 = 2 <span class="math inline">\(的形式,需要左乘矩阵\)</span>
<span class="math display">\[\begin{bmatrix}\frac { \sqrt { 2  }  } {
a  } , 0 \\ 0 , \frac { \sqrt { 2  }  } { b  } \end{bmatrix}\]</span>
<p>$.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转$ { 4 }
$了.旋转矩阵为</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x ’ = { a } - { b } , y ’ = { a } + { b }
$.带入反比例函数的方程:</p>
<p><span class="math display">\[
x &#39; y &#39; = \frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  }
= 1
\]</span></p>
<p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>,\</p>
<p>-,</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x = { 2 } ( x ’ + y ’ ) , y = { 2 } ( { y ’ - x ’ } )
$,带入双曲线方程得到:</p>
<p><span class="math display">\[
\begin{aligned}
( \frac { x  } { a  } ) ^2 - ( \frac { y  } { b  } ) ^2 &amp; = 1 \\
( x &#39; + y &#39; ) ^2 - ( x &#39; - y &#39; ) ^2 &amp; = 4 \\
x &#39; y &#39; &amp; = 1
\end{aligned}
\]</span></p>
<p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6>
<p>这个比较简单,交换$x , y $即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5>
<p>平面内取一点$O <span class="math inline">\(为极点,引一条射线\)</span>Ox
$叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点$M <span class="math inline">\(,令\)</span>= | OM |
<span class="math inline">\(,\)</span><span class="math inline">\(为以\)</span>Ox <span class="math inline">\(为始边,沿角度正方向(一般是逆时针方向)转到\)</span>OM
<span class="math inline">\(的夹角.那么我们称\)</span>( , ) <span class="math inline">\(为\)</span>M <span class="math inline">\(的极坐标,其中\)</span><span class="math inline">\(叫做极径,\)</span>$叫做极角.</p>
<p>$<span class="math inline">\(有可能取负,我们通常认为\)</span>( - , )
= ( , + ) $.</p>
<p>通常情况下默认$0 &lt; 2 , <span class="math inline">\(.如果遇到和直角坐标系结合的问题,通常默认原点为极点,\)</span>x
$轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若$M <span class="math inline">\(在直角坐标系中坐标为\)</span>(
x , y ) <span class="math inline">\(,在极坐标中坐标为\)</span>( , )
<span class="math inline">\(,若\)</span>M O $自然有:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = \rho \cos \theta , y &amp; = \rho \sin \theta \\
\rho ^2 &amp; = x ^2 + y ^2 , \theta &amp; = \begin{cases}
\frac { \pi  } { 2  } &amp; x = 0 \land y &gt; 0 \\
\frac { 3 \pi  } { 2  } &amp; x = 0 \land y &lt; 0 \\
\arctan ( \frac { y  } { x  } ) &amp; x \ne 0
\end{cases}
\end{aligned}
\]</span></p>
<p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6>
<p>显然是$^2 = r ^2 $.</p>
<p>另外,如果中心在$C ( _0 , _0 ) <span class="math inline">\(,半径为\)</span>r $的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
r ^2 &amp; = ( \rho \cos \theta - \rho _0 \cos \theta _0 ) ^2 + ( \rho
\sin \theta - \rho _0 \sin \theta _0 ) \\
r ^2 &amp; = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos \theta \cos
\theta _0 - 2 \rho \rho _0 \sin \theta \sin \theta _0 \\
r ^2 &amp; = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos ( \theta -
\theta _0 )
\end{aligned}
\]</span></p>
<p>另外由于$= ( - ) $,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6>
<p>过定点$( _1 , _1 ) <span class="math inline">\(,且倾斜角为\)</span><span class="math inline">\(:\)</span>( - ) = _1 ( - _1 ) $.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点$( x _1 , y _1 ) <span class="math inline">\(,倾斜角为\)</span><span class="math inline">\(,我们自然有\)</span>( x - x _1 ) = ( y - y _1 )
$.</p>
<p>于是有:</p>
<p><span class="math display">\[
\begin{aligned}
( x - x _1 ) \sin \alpha &amp; = ( y - y _1 ) \cos \alpha \\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) \sin \alpha &amp; = ( \rho
\sin \theta - \rho _1 \sin \theta _1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) &amp; = \rho _1 \sin ( \alpha - \theta _1
)
\end{aligned}
\]</span></p>
<p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点$( _1 , _1 ) <span class="math inline">\(和\)</span>( _2 , _2 ) $的直线方程.</p>
<p>同理的:</p>
<p><span class="math display">\[
\begin{aligned}
( x - x _1 ) ( y _2 - y _1 ) &amp; = ( y - y _1 ) ( x _2 - x _1 ) \\
\\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) ( \rho _2 \sin \theta _2 -
\rho _1 \sin \theta _1 ) \\
&amp; = ( \rho _2 \cos \theta _2 - \rho _1 \cos \theta _1 ) ( \rho \sin
\theta - \rho _1 \sin \theta _1 ) \\
\\
\rho \rho _2 ( \cos \theta \sin \theta _2 - \cos \theta _2 \sin \theta )
\\
+ \rho \rho _1 ( - \cos \theta \sin \theta _1 + \sin \theta \cos \theta
_1 ) \\
+ \rho _1 \rho _2 ( - \cos \theta _1 \sin \theta _2 + \cos \theta _2
\sin \theta _1 ) \\
&amp; = 0 \\
\\
\rho \rho _2 \sin ( \theta _2 - \theta ) + \rho \rho _1 \sin ( \theta -
\theta _1 ) + \rho _1 \rho _2 \sin ( \theta _1 - \theta _2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6>
<p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离$d <span class="math inline">\(和到定点距离\)</span>r <span class="math inline">\(之比为常数的曲线.令\)</span>e = { d } $.</p>
<p>假定定点为原点,极轴垂直于准线,$h <span class="math inline">\(为定点到准线的距离,又设曲线上一点为\)</span>M ( ,
) <span class="math inline">\(,自然有:\)</span>r = , d = h + $.</p>
<p>于是有:</p>
<p><span class="math display">\[
\begin{aligned}
e &amp; = \frac { \rho  } { h + \rho \cos \theta  } \\
he + e \rho \cos \theta &amp; = \rho \\
\rho &amp; = \frac { he  } { 1 - e \cos \theta  }
\end{aligned}
\]</span></p>
<p>值得一提的是这玩意不能将圆理解为$e = 0 $的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5>
在平面直角坐标系中,曲线上任意一点的坐标$x , y <span class="math inline">\(都是某个变量\)</span>t <span class="math inline">\(的函数\)</span>
<span class="math display">\[\begin{cases}x = f ( t ) \\ y = g ( t )
\end{cases}\]</span>
<p>$.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6>
<p>$M ( r , r ) <span class="math inline">\(,其中\)</span><span class="math inline">\(是\)</span>OMx $.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6>
<p>$M ( x _0 + t , y _0 + t ) <span class="math inline">\(,其中\)</span><span class="math inline">\(是倾斜角,\)</span>t <span class="math inline">\(是参数,\)</span>M _0 ( x _0 , y _0 ) $.</p>
<p>注意到$| M _0 M | = | t | <span class="math inline">\(.事实上,设\)</span> = ( , ) <span class="math inline">\(,也就是直线的单位方向向量,则\)</span> = t $.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6>
<p>$M ( a , b ) <span class="math inline">\(,其中\)</span><span class="math inline">\(称为\)</span>M $的离心角.</p>
<p>值得注意的是,这里的$<span class="math inline">\(并非\)</span>MOx
$,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆$ { 9 } + { 4 } = 1 <span class="math inline">\(上求一点\)</span>M <span class="math inline">\(,使\)</span>M <span class="math inline">\(到直线\)</span>x + 2 y - 10 = 0 $的距离最小.</p>
<p>直接令$M = ( 3 , 2 ) <span class="math inline">\(,则\)</span>d = { }
= | ( + ) - 2 | <span class="math inline">\(,其中\)</span>= { 5 } $.</p>
<p>于是$d _{ } = <span class="math inline">\(,此时\)</span>( + ) = 1 =
<span class="math inline">\(,那么就有\)</span>= { 2 } - <span class="math inline">\(,\)</span>= = { 5 } , = = { 5 } $.</p>
<p>则$M = ( { 5 } , { 5 } ) $.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$ { 100 } + { 64 } = 1 <span class="math inline">\(,有一内接矩阵\)</span>ABCD <span class="math inline">\((\)</span>AB / / x , BC / / y
$),求矩阵最大面积.</p>
<p>直接令$A = ( 10 , 8 ) <span class="math inline">\(,则\)</span>S = 20
= 160 ( 2 ) <span class="math inline">\(,\)</span>S _{ } = 160 $.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6>
<p>$M ( { } , b ) = M ( a , b ) <span class="math inline">\(,其中\)</span><span class="math inline">\(称为\)</span>M <span class="math inline">\(的离心角,通常规定\)</span> { 2 } { 2 } $.</p>
<p>其实本质也就是三角恒等式$^2 = 1 + ^2 $.</p>
<p><strong>Example1</strong></p>
<p>圆$O : x ^2 + ( y - 2 ) ^2 = 1 <span class="math inline">\(上有一点\)</span>P <span class="math inline">\(,双曲线\)</span>x ^2 - y ^2 = 1 <span class="math inline">\(上有一点\)</span>Q <span class="math inline">\(,求\)</span>| PQ | _{ } $.</p>
<p>设$Q ( , ) $,则:</p>
<p><span class="math display">\[
\begin{aligned}
| OQ | ^2 &amp; = \sec ^2 \theta + ( \tan \theta - 2 ) ^2 \\
&amp; = \tan ^2 \theta + 1 ( \tan \theta - 2 ) ^2 \\
&amp; = 2 ( \tan \theta - 1 ) ^2 + 3
\end{aligned}
\]</span></p>
<p>$| OQ | <em>{ } = , | PQ | </em>{ } = - 1 $.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设$P ( a , a ) , Q ( - a , a ) <span class="math inline">\(,则\)</span>k _P = { a - a } , k _Q = { - a - a }
<span class="math inline">\(.注意到\)</span>k _P k _Q = - 1 $.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线$ { a ^2 } - { b ^2 } = 1 <span class="math inline">\(,\)</span>A , B <span class="math inline">\(是双曲线同支上相异两点,线段\)</span>AB <span class="math inline">\(的垂直平分线与\)</span>x <span class="math inline">\(轴相交于点\)</span>P ( x _0 , 0 ) <span class="math inline">\(,求证:\)</span>| x _0 | &gt; { a } = { a } $.</p>
<p>设$A ( a , b ) , B ( a , b ) <span class="math inline">\(,则中点\)</span>M ( { 2 } ( + ) , { 2 } ( + ) )
$.</p>
<p>于是中垂线方程为$y - { 2 } ( + ) ) = - { b ( - ) } [ x - { 2 } ( + )
] $.</p>
<p>代入$P ( x _0 , 0 ) <span class="math inline">\(,求得\)</span>x _0 =
{ 2 a } ( + ) $.</p>
<p>也就是要比较$| + | $和$2 <span class="math inline">\(的大小关系,注意到\)</span>A , B <span class="math inline">\(同支,所以\)</span>| + | &gt; 2 $.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6>
<p>$M ( { ^2 } , { } ) <span class="math inline">\(,其中\)</span><span class="math inline">\(称为\)</span>M
$的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:$M ( 2 pk ^2 , 2 pk )
$,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
若抛物线$
<span class="math display">\[\begin{cases}x = 2 pt ^2 \\ y = 2 pt
\end{cases}\]</span>
<p><span class="math inline">\(上有不同两点\)</span>M _1 , M _2 <span class="math inline">\(,所对应的参数分别是\)</span>t _1 , t _2 <span class="math inline">\(,求直线\)</span>M _1 M _2 $所在直线的斜率.</p>
<p>$k _{ M _1 M _2 } = { 2 pt _1 ^2 - 2 pt _2 ^2 } = { t _1 + t _2 }
$.</p>
<p><strong>Example2</strong></p>
<p>$A , B <span class="math inline">\(是抛物线\)</span>y ^2 = 2 px <span class="math inline">\(上异于顶点的两动点,且\)</span>OA OB <span class="math inline">\(,\)</span>AB <span class="math inline">\(上有一点\)</span>M <span class="math inline">\(满足\)</span>OM AB <span class="math inline">\(,求\)</span>M $的轨迹方程.</p>
<p>设$M ( x , y ) , A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt
_2 ) $,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow { OM  } &amp; = ( x , y ) \\
\overrightarrow { OA  } &amp; = ( 2 pt _1 ^2 , 2 pt _1 ) \\
\overrightarrow { OB  } &amp; = ( 2 pt _2 ^2 , 2 pt _2 ) \\
\overrightarrow { AB  } &amp; = ( 2 p ( t _2 ^2 - t _1 ^2 ) , 2 p ( t _2
- t _1 ) )
\end{aligned}
\]</span></p>
<p>因为$ <span class="math inline">\(,所以\)</span>( 2 pt _1 t _2 ) ^2 +
( 2 p ) ^2 t _1 t _2 = 0 <span class="math inline">\(,\)</span>t _1 t _2
= - 1 $.</p>
<p>因为$ <span class="math inline">\(,又有\)</span>k _{ AB } = { t _1 +
t <em>2 } <span class="math inline">\(,所以\)</span>k </em>{ OM } = - (
t _1 + t _2 ) <span class="math inline">\(,\)</span> { x } = - ( t _1 +
t _2 ) $.</p>
<p>接下来咋做捏?注意到我们好像忘记了$ABM
$三点共线的性质,拿向量做这个东西.</p>
<p>$ = ( x - 2 pt _1 ^2 , y - 2 pt _1 ) , = ( 2 pt _2 ^2 - x , 2 pt _2 -
y ) $.</p>
<p>那么有$( x - 2 pt _1 ^2 ) ( 2 pt _2 - y ) = ( 2 pt _2 ^2 - x ) ( y -
2 pt _1 ) $.</p>
<p>化简得到$x ^2 + y ^2 - 2 px = 0 ( x ) $.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点$A , B <span class="math inline">\(,自然要设出它们的参数方程.然后呢?然后我们发现最后\)</span>M
<span class="math inline">\(一定和\)</span>t _1 , t _2 <span class="math inline">\(有关.但是我们要求的是\)</span>M <span class="math inline">\(的方程,其中不能带有\)</span>t _1 , t _2 <span class="math inline">\(,因此考虑把\)</span>M <span class="math inline">\(的坐标设出来,再用这个坐标表示\)</span>t _1 , t _2
<span class="math inline">\(,表示不出来表示\)</span>t _1 t _2 , t _1 + t
_2 $也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到$M <span class="math inline">\(一定在以\)</span>| OA | <span class="math inline">\(为直径的圆上,\)</span>B
$同理,这两个圆的方程分别为:</p>
<p><span class="math display">\[
\begin{aligned}
x ^2 + y ^2 - 2 pt _1 ^2 x - 2 pt _1 y &amp; = 0 \\
x ^2 + y ^2 - 2 pt _2 ^2 x - 2 pt _2 y &amp; = 0
\end{aligned}
\]</span></p>
<p>也就是说,$t _1 , t _2 <span class="math inline">\(是同一个方程的两个根,根据韦达定理自然有\)</span>t
_1 t _2 = { 2 px } = - 1 <span class="math inline">\(,于是直接有\)</span>x ^2 + y ^2 - 2 px = 0 $.</p>
<p>还没完,注意到$O <span class="math inline">\(一定是一个根,要去掉,所以答案就是\)</span>x ^2 + y
^2 - 2 px = 0 ( x ) $.</p>
<p><strong>Example3</strong></p>
<p>已知$A , B , C <span class="math inline">\(是抛物线\)</span>y ^2 = 2
px ( p &gt; 0 ) <span class="math inline">\(上的三个点,且\)</span>BC
<span class="math inline">\(与\)</span>x <span class="math inline">\(轴垂直,直线\)</span>AB <span class="math inline">\(和\)</span>AC <span class="math inline">\(分别与抛物线的轴交于\)</span>D , E <span class="math inline">\(两点,求证:抛物线的顶点平分\)</span>DE $.</p>
<p>设$A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) , C ( 2 pt
_2 ^2 , - 2 pt _2 ) <span class="math inline">\(,注意到\)</span>AB : y -
2 pt _1 = { t _1 + t _2 } ( x - 2 pt _1 ^2 ) <span class="math inline">\(,\)</span>AC : t - 2 pt _1 = { t _1 - t _2 } ( x -
2 pt _1 ^2 ) $.</p>
<p>可求得$D ( - 2 pt _1 t _2 , 0 ) , E ( 2 pt _1 t _2 , 0 )
$,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5>
<p>参考:https://zhuanlan.zhihu.com/p/591258689</p>
<h6><span id="定义">定义</span></h6>
<p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6>
<p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为$ { a ^2 } + { b ^2 } = 1 <span class="math inline">\(,其蒙日圆方程为\)</span>x ^2 + y ^2 = a ^2 + b ^2
$.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为$ { a ^2 } - { b ^2 } = 1 <span class="math inline">\(,其蒙日圆方程为\)</span>x ^2 + y ^2 = a ^2 - b ^2
$.</p>
<p>证明:其实注意到椭圆的证明中设$b $是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线$y ^2 = 2 px <span class="math inline">\(,其蒙日圆方程为\)</span>x = - { 2 } $.</p>
<p>有一说一,直线是半径无穷大的圆.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">高等代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-22 16:57:48 / 修改时间：17:16:06" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="抽象代数">抽象代数</span></h2>
<h3><span id="群">群</span></h3>
<h4><span id="定义">定义</span></h4>
<p>如果一个非空集合$G <span class="math inline">\(上定义了一个二元运算\)</span>: G G G <span class="math inline">\((不引起混淆的前提下,通常省略不写,例如\)</span>a b
<span class="math inline">\(记作\)</span>ab $),满足:</p>
<ol start="0" type="1">
<li><p>封闭性:$a b G $.</p></li>
<li><p>结合律:$( a b ) c = a ( b c ) $.</p></li>
</ol>
<p>那么称作$G $是一个<strong>半群</strong>.</p>
<p>如果它还满足:</p>
<ol start="2" type="1">
<li>存在幺元:$e G <span class="math inline">\(,使得\)</span>a , e a = a
e = a $.</li>
</ol>
<p>那么称作$G $是一个<strong>幺半群(monoid)</strong>.</p>
<p>如果它还满足:</p>
<ol start="3" type="1">
<li>存在逆元:对任意的$a G <span class="math inline">\(,存在\)</span>b G
<span class="math inline">\(,使得\)</span>a b = e $.</li>
</ol>
<p>那么称作$G $是一个<strong>群</strong>.</p>
<p>如果它还满足:</p>
<ol start="4" type="1">
<li>交换律:$a , b , a b = b a $.</li>
</ol>
<p>那么称作$G
$是一个<strong>交换群</strong>或<strong>阿贝尔群</strong>.特别地,一般而言在交换群里,我们的运算使用加法符号(有时也直接叫它加法群),这只是一个惯例.</p>
<p>下面主要研究群.</p>
<h4><span id="基本概念和事实">基本概念和事实</span></h4>
<p>定义群的<strong>阶</strong>为群中元素个数,记作$| G | <span class="math inline">\(,如果\)</span>| G | &lt;
$称为<strong>有限群</strong>,否则为<strong>无限群</strong>.</p>
<ol type="1">
<li>群的幺元唯一.</li>
</ol>
<p>设$e , e ’ <span class="math inline">\(都是幺元,有\)</span>e = ee ’ =
e ’ $.</p>
<ol start="2" type="1">
<li>群中任一元素的逆元唯一.</li>
</ol>
<p>设$b , b ’ <span class="math inline">\(都是\)</span>a <span class="math inline">\(的逆元,有\)</span>b = bab ’ = b ’ $.</p>
<p>这同样说明了虽然群上的二元运算有可能不满足交换律,但是仍然不存在左逆和右逆这种东西(或者说无意义),它俩都等价于逆.</p>
<ol start="3" type="1">
<li>群中有消去律,即$ax = ay x = y <span class="math inline">\((左消去律),\)</span>xa = ya x = y
$(右消去律).</li>
</ol>
<p>显然.</p>
<p>于是可以定义乘方,并定义$a ^{ 0 } = e , a ^{ - 1 } = inv ( a )
$.一切的指数的常规操作在这里都可以照常进行.</p>
<h5><span id="example1">Example1</span></h5>
<p>证明:对于有限集合$G <span class="math inline">\(和满足结合律的二元运算\)</span>$来说,如果其有左右消去律,那么该二元运算在该集合上构成群.</p>
<p>考虑是有限集合,所以单射$f _a : b ab <span class="math inline">\(同时也是满射,这意味着\)</span>a , b G , xa = b
<span class="math inline">\(和\)</span>ay = b <span class="math inline">\(一定有解,令\)</span>b = a <span class="math inline">\(可以拿到幺元,令\)</span>b = e
$可以拿到逆元,自然可以推出其是群.</p>
<h5><span id="example2">Example2</span></h5>
<p>设$G <span class="math inline">\(是群,且\)</span>a , b , aba ^{ - 1 }
= b ^r <span class="math inline">\(,求证:\)</span>a ^i ba ^{ - i } = b
^{ r ^i } $.</p>
<p>显然$b ^{ rk } = ( b ^k ) ^r = ab ^k a ^{ - 1 } <span class="math inline">\(,使用数学归纳,注意到\)</span>b ^{ r ^i } = ab ^{ r
^{ i - 1 } } a ^{ - 1 } = a ^i ba ^{ - i } $.</p>
<h4><span id="子群">子群</span></h4>
<p>设$H <span class="math inline">\(为群\)</span>G <span class="math inline">\(的非空子集,如果\)</span>H <span class="math inline">\(在\)</span>G <span class="math inline">\(的运算下构成群,则称\)</span>H <span class="math inline">\(为\)</span>G <span class="math inline">\(的**子群**,记作\)</span>H G $.</p>
<p><strong>子群的判定定理</strong>:</p>
<p>设$G <span class="math inline">\(是群,\)</span>H G , H
$,下列命题等价:</p>
<ol type="1">
<li><p>$H G $.</p></li>
<li><p>$a , b H , ab H , a ^{ - 1 } H $.</p></li>
<li><p>$a , b H <span class="math inline">\(,有\)</span>ab ^{ - 1 } H
$.</p></li>
</ol>
<p>显然(1)$<span class="math inline">\((2),(2)\)</span><span class="math inline">\((3),下面证明(3)\)</span>$(1):</p>
<p>满足(3),有$e = aa ^{ - 1 } H <span class="math inline">\(,于是存在幺元.有\)</span>ea ^{ - 1 } H <span class="math inline">\(,于是存在逆元.因为\)</span>a ( b ^{ - 1 } ) ^{ - 1
} = ab H $,于是对运算封闭.同样的运算显然满足结合律.于是证毕.</p>
<p>如果$G <span class="math inline">\(是群,\)</span>H , K G <span class="math inline">\(,类似闵可夫斯基和,我们定义\)</span>HK = { hk h H ,
k K } <span class="math inline">\(.如果\)</span>H = { a } <span class="math inline">\(,可以写作\)</span>aK <span class="math inline">\(.类似记\)</span>H ^{ - 1 } = { h ^{ - 1 } h H }
<span class="math inline">\(,注意\)</span>HH ^{ - 1 } { e } $.</p>
<p>再定义$H ^n = { h _1 h _2 h _n h _1 , h _2 , , h _n H } $.</p>
<p>于是子群的判定定理可以改写成:</p>
<p>下列命题等价:</p>
<ol type="1">
<li><p>$H G $.</p></li>
<li><p>$H ^2 H H ^{ - 1 } H $.</p></li>
<li><p>$HH ^{ - 1 } H $.</p></li>
</ol>
<p>显然,任意群$G <span class="math inline">\(,\)</span>G <span class="math inline">\(和\)</span>{ e } <span class="math inline">\(都是它的子群,我们称为**平凡子群**,如果\)</span>H G
<span class="math inline">\(,称为**真子群**,记作\)</span>H &lt; G $.</p>
<p>若干个群的交仍然是子群,但是若干个群的并不一定.我们可以证明一下若干个群的交仍然是子群:考虑$h
A , h B , w A , w B <span class="math inline">\(,那么\)</span>hw ^{ - 1
} A B $.</p>
<p>设集合$M G <span class="math inline">\(,则称\)</span>G <span class="math inline">\(的所有包含\)</span>M <span class="math inline">\(的子群的交为由\)</span>M <span class="math inline">\(**生成的子群**,记作\)</span>M <span class="math inline">\(.这显然是包含\)</span>M $的最小的子群.</p>
<p>如果$M = G <span class="math inline">\(,则称\)</span>M <span class="math inline">\(是\)</span>G <span class="math inline">\(的一个**生成系**.可由有限多个元素生成的群叫做**有限生成群**,若\)</span>M
, | M | = 1 , M = G <span class="math inline">\(,则称\)</span>G
$是<strong>循环群</strong>.</p>
<p>对于$a G <span class="math inline">\(,我们称\)</span>o ( a ) = | a |
<span class="math inline">\(为\)</span>a <span class="math inline">\(的**阶**,不难发现\)</span>o ( a ) <span class="math inline">\(是满足\)</span>a ^n = e <span class="math inline">\(的最小的正整数\)</span>n <span class="math inline">\(.如果这样的\)</span>n <span class="math inline">\(不存在,记\)</span>o ( a ) = <span class="math inline">\(.群中所有元素的阶的\)</span>lcm <span class="math inline">\(称作群的**方次数**(如果不存在,则记为\)</span><span class="math inline">\(),记作\)</span>( G ) $.</p>
<p>另一个不平凡的例子是群$G <span class="math inline">\(的**中心**定义为\)</span>Z _G = { z G g G , zg =
gz } $,这显然也是一个子群.</p>
<h5><span id="example1">Example1</span></h5>
<p>证明不存在恰有两个二阶元素的群.</p>
<p>不妨设这两个二阶元素分别为$a b , a , b e <span class="math inline">\(,则注意到\)</span>aba $也是一个二阶元素.</p>
<p>如果$aba = a <span class="math inline">\(,则\)</span>ba = e <span class="math inline">\(,说明\)</span>a = b $.</p>
<p>如果$aba = b <span class="math inline">\(,则\)</span>ba = ab <span class="math inline">\(,说明\)</span>ab $是第三个二阶元素.</p>
<p>类似还可以证明如果$( G ) = 2 <span class="math inline">\(,则\)</span>G <span class="math inline">\(一定是交换群(一定满足\)</span>a , b G , ab = ba
<span class="math inline">\().原因是假设\)</span>ab = c <span class="math inline">\(,\)</span>ba = d <span class="math inline">\(,则\)</span>cd = e $.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个群$G <span class="math inline">\(,如果\)</span>a , b G <span class="math inline">\(,\)</span>i , ( ab ) ^i = a ^i b ^i , ( ab ) ^{ i
+ 1 } = a ^{ i + 1 } b ^{ i + 1 } , ( ab ) ^{ i + 2 } = a ^{ i + 2 } b
^{ i + 2 } $,求证其是交换群.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( ab ) ^{ i + 1  } &amp; = a ^{ i + 1  } b ^{ i + 1  } &amp; = a ( ab )
^i b \\
( ab ) ^i &amp; = a ( ab ) ^i a ^{ - 1  }
\end{aligned}
\]</span></p>
<p>同理有$( ab ) ^{ i + 1 } = a ( ab ) ^{ i + 1 } a ^{ - 1 } <span class="math inline">\(.两式合并一下有\)</span>a ( ab ) ^i a ^{ - 1 } ab
= a ( ab ) ^{ i + 1 } a ^{ - 1 } b = aba ^{ - 1 } $.</p>
<h5><span id="example3">Example3</span></h5>
<p>证明若$( G ) $,则存在阶为$2 $的元素.</p>
<p>一定存在一个阶为$2 k <span class="math inline">\(的元素\)</span>a
<span class="math inline">\(,显然\)</span>o ( a ^k ) = 2 $.</p>
<h5><span id="example4">Example4</span></h5>
<p>当$n &gt; 2 <span class="math inline">\(的时候,证明在有限群\)</span>G
<span class="math inline">\(中阶为\)</span>n $的元素个数是偶数.</p>
<p>显然构造双射$a a ^{ n - 1 } $即可.</p>
<h5><span id="example5">Example5</span></h5>
<p>对于群$G <span class="math inline">\(,证明\)</span>o ( ab ) = o ( ba
) $.</p>
<p>考虑反证,不妨设$o ( ab ) = n &lt; o ( ba ) = m $.</p>
<p>则$e = ( ba ) ^m = ( ba ) ^{ m - n } b ( ab ) ^{ n - 1 } a = ( ba )
^{ m - n } <span class="math inline">\(,说明\)</span>o ( ba ) m - n &lt;
m $,不符题意.</p>
<h5><span id="example6">Example6</span></h5>
<p>证明:如果$H , K G <span class="math inline">\(,那么\)</span>HK G HK =
KH $.</p>
<p>如果$HK = KH <span class="math inline">\(,那么\)</span>HK G HK ( HK )
^{ - 1 } = HK $.考虑:</p>
<p><span class="math display">\[
HK ( HK ) ^{ - 1  } = HKK ^{ - 1  } H ^{ - 1  } = HKH ^{ - 1  } = KHH ^{
- 1  } = HK
\]</span></p>
<p>如果$HK G <span class="math inline">\(,那么\)</span>HK = ( HK ) ^{ -
1 } = K ^{ - 1 } H ^{ - 1 } = KH $.</p>
<h5><span id="example7">Example7</span></h5>
<p>设$G <span class="math inline">\(是交换群,证明\)</span>G <span class="math inline">\(中的全体有限阶元素构成\)</span>G $的一个子群.</p>
<p>等价于证明如果$a , b <span class="math inline">\(的阶有限,那么\)</span>ab ^{ - 1 }
$的阶有限.这对交换群来说是显然的.</p>
<h5><span id="example8">Example8</span></h5>
<p>如果$G <span class="math inline">\(只有有限多个子群,证明\)</span>G
$是有限群.</p>
<p>考虑若其有无限阶元素$a <span class="math inline">\(,则\)</span>a
<span class="math inline">\(已经有无限个子群(取幂次为\)</span>k
$的倍数).反之则每个元素都可以生成一个循环群,也有无限个子群.</p>
<h4><span id="同态和同构">同态和同构</span></h4>
<p>考虑在两个群$G <span class="math inline">\(和\)</span>G _1 <span class="math inline">\(之间构造映射\)</span><span class="math inline">\(,如果\)</span><span class="math inline">\(保持群运算,即对于所有的\)</span>a , b G <span class="math inline">\(,都有\)</span>( ab ) = ( a ) ( b ) <span class="math inline">\(,则称其为由\)</span>G <span class="math inline">\(到\)</span>G _1 <span class="math inline">\(的一个**群同态**.如果同时\)</span><span class="math inline">\(又是单(满)射,则称其为**单(满)同态**,又单又满的同态称为**同构**.如果存在一个映射\)</span><span class="math inline">\(,使得\)</span>G , G _1 <span class="math inline">\(同构,则称这两个群**同构**,记作\)</span>G G _1
$.</p>
<p>容易见到,同构等价于两方都有$f : G G _1 <span class="math inline">\(和\)</span>g : G _1 G <span class="math inline">\(,并且二者的合成\)</span>fg = gf =
$.而且同构的合成仍是同构.</p>
<p>我们以$End ( G ) <span class="math inline">\(表示\)</span>G <span class="math inline">\(的全体**自同态**组成的集合,\)</span>Aut ( G )
<span class="math inline">\(表示全体**自同构**组成的集合.不难发现,\)</span>End
( G ) <span class="math inline">\(组成一个幺半群,而\)</span>Aut ( G )
$组成一个群.</p>
<p>我们可以搞一个伴随映射:$G Aut ( G ) , g Ad _g <span class="math inline">\(,其中\)</span>Ad _g ( x ) = gxg ^{ - 1 } <span class="math inline">\(.容易见到\)</span>Ad _g = id <span class="math inline">\(的充要条件是\)</span>g Z ( G )
$也就是群的中心.</p>
<p>群同态$: G G _1 <span class="math inline">\(把\)</span>G <span class="math inline">\(的幺元映为\)</span>G _1 $的幺元.原因是:</p>
<p><span class="math display">\[
\varphi ( e ) ^2 = \varphi ( e ^2 ) = \varphi ( e ) e _1
\]</span></p>
<p>然而应当说明,这里保持单位元对幺半群未必成立,因此如果要将群同态的定义挪到幺半群上,需要额外添加$(
e ) = e _1 $的条件.</p>
<p>我们还有:</p>
<p><span class="math display">\[
e _1 = \varphi ( e ) = \varphi ( aa ^{ - 1  } ) = \varphi ( a ) \varphi
( a ^{ - 1  } )
\]</span></p>
<p>所以$( a ^{ - 1 } ) = ( ( a ) ) ^{ - 1 } $.</p>
<p>我们将$( G ) <span class="math inline">\(称为\)</span>G <span class="math inline">\(的**像**,记为\)</span>  <span class="math inline">\(.又将\)</span>e _1 <span class="math inline">\(的原像的集合称为\)</span><span class="math inline">\(的**核**,记为\)</span> $.</p>
<p>注意到$$不是单射等价于:</p>
<p><span class="math display">\[
\begin{aligned}
\Leftrightarrow \exists a , b \in G , a \ne b , \varphi ( a ) &amp; =
\varphi ( b ) \\
\Leftrightarrow \varphi ( ab ^{ - 1  } ) &amp; = \varphi ( a ) \varphi (
b ) ^{ - 1  } &amp; = e _1 \\
\Leftrightarrow \ker \ \varphi \ne \{ e \}
\end{aligned}
\]</span></p>
<h4><span id="群的实例">群的实例</span></h4>
<h5><span id="全变换群对称群与交错群">全变换群,对称群与交错群</span></h5>
<p>设$M <span class="math inline">\(是一个非空集合,\)</span>M <span class="math inline">\(到自身的双射的全体对于映射的复合构成一个群,称作\)</span>M
<span class="math inline">\(的**全变换群**,记作\)</span>S ( M ) $.</p>
<p>设$M <span class="math inline">\(是含有\)</span>n <span class="math inline">\(个元素的集合,\)</span>M <span class="math inline">\(的全变换群\)</span>S ( M ) <span class="math inline">\(称为**n级对称群**,记作\)</span>S _n <span class="math inline">\(.不失一般性,我们可以设\)</span>M = { 1 , 2 , , n }
<span class="math inline">\(,\)</span>S _n <span class="math inline">\(的元素称为**n元置换**,任一置换可以用列表的方法表示,即如果\)</span>$是一个映射,我们将其写作:</p>
<p><span class="math display">\[
\sigma = \left ( \begin{array}
{ c  } 1 &amp; 2 &amp; \cdots &amp; n \\
\sigma _1 &amp; \sigma _2 &amp; \cdots &amp; \sigma _n
\end{array} \right )
\]</span></p>
<p>显然$| S _n | = n ! $.</p>
设$S _n <span class="math inline">\(,\)</span>{ i _1 , i _2 , , i _t } {
1 , 2 , , n } <span class="math inline">\(,有\)</span>( i _t ) = i _1 ,
k &lt; t , ( i <em>k ) = i </em>{ k + 1 } <span class="math inline">\(,我们称这样的置换是对于\)</span>{ i _1 , i _2 , ,
i _t } <span class="math inline">\(的**轮换**,记作\)</span>(
<span class="math display">\[\begin{array}{ c  } i _1 &amp; i _2 &amp;
\cdots &amp; i _t \end{array}\]</span>
<p>) <span class="math inline">\(,\)</span>t
$为轮换的<strong>长度</strong>,长度为$2
$的轮换称作<strong>对换</strong>.显然,一个置换可以被分解成若干两两无交轮换(注意到如果两个轮换无交,则它们可交换)的乘积.又显然,一个轮换可以被分解成若干对换的乘积,原因是总有:</p>
<p><span class="math display">\[
( a _1 , \cdots , a _l ) = ( a _1 , a _l ) ( a _1 , \cdots , a _{ l -
1  } )
\]</span></p>
<p>另外轮换的性质给出任何一个置换$<span class="math inline">\(的\)</span>o ( ) <span class="math inline">\(就是其拆出的所有轮换的\)</span> $.</p>
<p>根据逆序对相关,我们知道一个置换的逆序对数量的奇偶性等于其分解成的对换的数量.我们将逆序对数量是奇数的置换称为<strong>奇置换</strong>,是偶数的称之为<strong>偶置换</strong>,$S
_n <span class="math inline">\(中的所有偶置换也构成一个群,称之为**n级交错群**,记为\)</span>A
_n <span class="math inline">\(.\)</span>A _n <span class="math inline">\(实际上是\)</span>S _n $的一个子群.</p>
<h5><span id="一般线性群">一般线性群</span></h5>
<p>对于定义在域$F <span class="math inline">\(上的线性空间\)</span>V
<span class="math inline">\(,它上面的所有自同构构成一个**一般线性群**\)</span>GL
( V ) = { T ( V ) T } <span class="math inline">\(.特别地,当\)</span>V
&lt; <span class="math inline">\(的时候,其有一个子群**特殊线性群**\)</span>SL ( V )
= { T ( V ) T = 1 } $.</p>
<p>在配套的内积空间上还可以把正交变换组成的群一块拿到,称为<strong>正交群</strong>或者<strong>酉群</strong>$O
( V ) <span class="math inline">\(,还可以定义\)</span>SO ( V ) = O ( V )
SL ( V ) $.</p>
<p>当然上面的版本都可以用矩阵来表示,这里略去不表.然而对于矩阵来代替上面的情形,我们疑似需要引入群同构的概念,这会在下面提出.</p>
<h5><span id="克莱因四元群">克莱因四元群</span></h5>
<p>取$V = { , , , } $,其中:</p>
$$
<span class="math display">\[\begin{aligned}
\sigma &amp; = \left ( \begin{matrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
2 &amp; 1 &amp; 4 &amp; 3
\end{matrix} \right ) \\
\tau &amp; = \left ( \begin{matrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
3 &amp; 4 &amp; 1 &amp; 2
\end{matrix} \right ) \\
\sigma \tau &amp; = \tau \sigma &amp; = \left ( \begin{matrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
4 &amp; 3 &amp; 2 &amp; 1
\end{matrix} \right ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>见到这确实是一个群,而且任何一个元素的逆元都是它本身,而且两个不同的非$1
$元的乘积会得到另一个非$1 $元.</p>
<p>克莱因群的实例非常多,例如${ 1 , 3 , 5 , 7 } <span class="math inline">\(在\)</span> <span class="math inline">\(意义下对乘法构成克莱因群,\)</span>{ 0 , 1 , 2 , 3
} $对异或构成克莱因群.以及:</p>
<p><span class="math display">\[
\left \{ \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} , \begin{bmatrix}
1 &amp; 0 \\
0 &amp; - 1
\end{bmatrix} , \begin{bmatrix}
- 1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} , \begin{bmatrix}
- 1 &amp; 0 \\
0 &amp; - 1
\end{bmatrix} \right \}
\]</span></p>
<p>对矩阵乘法也构成群.</p>
<h5><span id="循环群">循环群</span></h5>
<p>如果对于一个群$G <span class="math inline">\(,它可以由其中的某个元素\)</span><span class="math inline">\(生成,记作\)</span>G = <span class="math inline">\(,当\)</span>g G , k , g = ^k $.</p>
<p>显然$ / n <span class="math inline">\(对加法就是一个循环群,其中\)</span>= 1 + n $.</p>
<p>特别地,容易见到对于任意循环群,如果$| G | = <span class="math inline">\(,则\)</span>G <span class="math inline">\(;反之则\)</span>G / | G | $.</p>
<h4><span id="相反群">相反群</span></h4>
<p>群中的左右区别如此之大,是否说对于任何一个左的版本都存在一个与之对应的右的版本呢?</p>
<p>留神到我们其实可以定义<strong>相反群</strong>$G ^{ op } = ( G , )
<span class="math inline">\(,其中的运算满足\)</span>g g ’ = g ’ g <span class="math inline">\(,也就是在\)</span>G <span class="math inline">\(中使得乘法倒置.容易检验其保留了幺元和逆元等性质,而且\)</span>(
G ^{ op } ) ^{ op } = G <span class="math inline">\(.另外只需观察\)</span>G G ^{ op } , g g ^{ - 1 }
<span class="math inline">\(就可构造双射.有时干脆将相反群记作\)</span>G
^{ - 1 } $.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:群$G <span class="math inline">\(是交换群当且仅当\)</span>x x ^{
- 1 } $是群同构.</p>
<p>显然是单射且是双射,只需证明是群同态即可.此时就需要证明$y ^{ - 1 } x
^{ - 1 } = ( xy ) ^{ - 1 } = ( yx ) ^{ - 1 } $,那就搞定了.</p>
<h4><span id="陪集">陪集</span></h4>
<p>设$G <span class="math inline">\(是一个群,\)</span>H G <span class="math inline">\(,定义等价关系\)</span>a b h H , a = bh <span class="math inline">\(,容易检查其满足等价类的三条性质.不难发现对于元素\)</span>a
<span class="math inline">\(,其所在的等价类就是\)</span>aH <span class="math inline">\(.类似可以定义\)</span>Ha <span class="math inline">\(.我们定义形如\)</span>aH <span class="math inline">\(的子集为\)</span>H <span class="math inline">\(的一个**右陪集**,形如\)</span>Ha <span class="math inline">\(的称作**左陪集**.由于左陪集是一个等价类,因此会将原集合划分为若干个等价类.这种划分用商集刻画,记作\)</span>G
/ H <span class="math inline">\(.需要强调的是这个符号需要区分左右,有的人会盗用反斜杠来表述此关系,但这种符号容易与差集相混淆.因此,我们在下面会直接不加区分(或者说根据上下文判断)来一律统一使用\)</span>G
/ H <span class="math inline">\(.如若的确需要区分,则采用\)</span>( G / H
) _L , ( G / H ) _R $的写法.</p>
<p>一个自然的想法是$G / H <span class="math inline">\(是否构成一个群.先看取逆,容易发现\)</span>( aH ) ^{
- 1 } = Ha ^{ - 1 } $,这给出左陪集和右陪集之间一个自然的同构:</p>
<p><span class="math display">\[
Hg \mapsto g ^{ - 1  } H = ( Hg ) ^{ - 1  }
\]</span></p>
<p>所以不同的左右陪集个数相等.</p>
<p>我们将$H <span class="math inline">\(的不同左陪集的个数(不一定有限)称为\)</span>H <span class="math inline">\(在\)</span>G <span class="math inline">\(中的**指数**,记为\)</span>| G : H | <span class="math inline">\(,用消去律注意到\)</span>| H | = | aH | = | Ha |
<span class="math inline">\(,因此其实右陪集个数也是这个指数.既然是等价类,就完成了对原群的一个划分,而且容易见到每个划出的等价类大小都是\)</span>|
H | $.</p>
<p>对于有限群,这引出重要的<strong>拉格朗日定理</strong>:</p>
<p><span class="math display">\[
| G | = | G : H | \times | H |
\]</span></p>
<p>对于每一个陪集$C G / H <span class="math inline">\(,我们可以选定其一个代表元\)</span>x _c <span class="math inline">\(使得\)</span>x _C H = C <span class="math inline">\(.考虑映射\)</span>H ( G / H ) G , ( h , C ) x _C h
$.下面证明这的确是个同构.</p>
<p>由于这里在映射前就钦定了代表元(需要使用选择公理),所以无需验证良定性.</p>
<p>接下来检查其单射,由于$x <em>C h C <span class="math inline">\(,所以如果\)</span>x </em>{ C ’ } h ’ = x _C h
<span class="math inline">\(,意味着\)</span>C ’ C
$,这是不符合的,因为陪集肯定两两不交.</p>
<p>而满射性只需要找到自己所在的那个等价类即可.</p>
<p>该定理有以下推论(以下默认有限群):</p>
<ol type="1">
<li><p>任何一个子群的大小都一定整除原群大小.</p></li>
<li><p>若$H , K G <span class="math inline">\(,如果\)</span>| H | , | K
| <span class="math inline">\(的大小互素,则\)</span>H K = { 1 }
$</p></li>
<li><p>$G , o ( ) ( | G | ) $.</p></li>
<li><p>$G , ^{ | G | } = e $.</p></li>
<li><p>如果$p = | G | prime <span class="math inline">\(,则\)</span>G
$是一个循环群.</p></li>
<li><p>$K H G <span class="math inline">\(,则\)</span>[ G : K ] = [ G :
H ] $.</p></li>
</ol>
<p>(1)显然.</p>
<p>(2)的原因是$H K <span class="math inline">\(一定是一个子群,则它的大小要整除\)</span>( | H | ,
| K | ) = 1 $.</p>
<p>(3)是因为$G <span class="math inline">\(,而\)</span>o ( ) = | |
$.</p>
<p>(4)根据(3)显然.这其实就是费马小定理和欧拉定理在群上的体现.</p>
<p>(5)是因为任取一个$ $,则$1 o ( ) | p <span class="math inline">\(,所以\)</span>o ( ) = p $,这是循环群.</p>
<p>(6)的话仍是取代表元,不妨设$C G / H <span class="math inline">\(的代表元是\)</span>x _C <span class="math inline">\(,\)</span>D H / K <span class="math inline">\(的代表元是\)</span>y _D <span class="math inline">\(.则\)</span>G = x _C H = x _C y _D K
$,容易检验两边是一一对应的.它的另一个证明策略是取道第一同构定理.</p>
<h4><span id="群作用">群作用</span></h4>
<p>我们早应看出群往往是由一类双射组成的集合,而并非应该将其看作单一运算的环.因此,考虑群在一个集合上的作用是很有意义的.</p>
<p>我们称群$G <span class="math inline">\(的一个**左作用**是\)</span>: G
X X $,使得:</p>
<ol type="1">
<li><p>$( 1 _G , x ) = x $.</p></li>
<li><p>$( g , ( h , x ) ) = ( gh , x ) $.</p></li>
</ol>
<p>这种作用看似隔了一层,只是多引入了符号,而并非将$G <span class="math inline">\(与\)</span>X <span class="math inline">\(直接联系起来.然而回忆到柯里化过程,上述作用也等价于\)</span>G
( X X ) <span class="math inline">\(,设这个映射是\)</span>: G ( X )
$,容易见到上面两条性质等价于:</p>
<ol type="1">
<li><p>$( 1 _G ) = _X $.</p></li>
<li><p>$( g _1 g _2 ) = ( g _1 ) ( g _2 ) $.</p></li>
</ol>
<p>容易见到$$是群同态.</p>
<p>当然同理可以定义<strong>右作用</strong>.</p>
<p>对于左作用,我们定义$x <span class="math inline">\(的\)</span>G <span class="math inline">\(**轨道**是\)</span>Gx = { gx | g G } X <span class="math inline">\(.我们还可以定义其**稳定化子群**是\)</span> _G ( x
) = { g G | gx = x } <span class="math inline">\(,容易检验这的确是一个子群,原因是封闭性和逆存在都满足,而且还满足\)</span>
_G ( gx ) = g _G ( x ) g ^{ - 1 }
$.因此一个轨道中的点的稳定化子群大小相等.</p>
<p>定义$X <span class="math inline">\(的\)</span>G <span class="math inline">\(**不动点**是\)</span>X ^G = { x X | g G , gx = x }
<span class="math inline">\(,容易见到\)</span>X ^G <span class="math inline">\(中的每一个点都自己构成一个轨道,还可以对单个\)</span>g
<span class="math inline">\(定义不动点集合\)</span>X ^g = { x X | gx = x
} <span class="math inline">\(.对于\)</span>g G
$.还可以引入以下定义:</p>
<ol type="1">
<li><p>如果$x X , gx = x <span class="math inline">\(当且仅当\)</span>g
= 1 <em>G <span class="math inline">\(,或说\)</span></em>{ x X } _{ G }
( x ) = { 1 _G } <span class="math inline">\(,则称这个作用是**忠实的**.此时还会满足\)</span>( g
) = id _X g = 1 _G $,也就是上述柯里化是单射.</p></li>
<li><p>若$X <span class="math inline">\(只有一个轨道,换言之\)</span>x ,
y X , g G , y = gx $.则称此群作用<strong>传递</strong>.</p></li>
<li><p>若$x X <span class="math inline">\(,\)</span> _G ( x ) = { 1 _G }
$,则称此群作用<strong>自由</strong>.自由性严格强于忠实性.</p></li>
</ol>
<p>对于$x , y X <span class="math inline">\(,我们定义等价关系\)</span>x
y <span class="math inline">\(当且仅当\)</span>y Gx <span class="math inline">\(.容易见到其满足传递性,自反性,对称性.在此等价关系下的商集也就是分解出的所有轨道,称此为轨道分解,或者盗用陪集符号写作\)</span>X
/ G $.</p>
<h5><span id="cayley定理">Cayley定理</span></h5>
<p>由上面可以见到,任何一个$G <span class="math inline">\(都可以用柯里化表为一个集合上的变换.并且如果群作用是忠实的,那么这种表示事实上总是单射.然而\)</span>G
$作用于自己本身的时候因为消去律一定能导出自由性.这自然是一个置换.</p>
<p>Cayley定理的一个很重要的作用是理解轨道分解.我们早就用图论手段理解过置换可以拆解成轮换的性质.如今我们可以用群论的手段去理解.对于任何一个置换$<span class="math inline">\(,考虑其作用在\)</span>X = { 1 , , n } <span class="math inline">\(上.考虑取一个循环群\)</span>G = <span class="math inline">\(,\)</span>G <span class="math inline">\(作用在\)</span>X <span class="math inline">\(上给出了\)</span>X
$的一个轨道分解.容易见到这里的轨道分解就是给出了若干个轮换.由轨道分解的唯一性,立刻见到轮换分解的唯一性.</p>
<h5><span id="burnside引理">Burnside引理</span></h5>
<p>下面选定$x X <span class="math inline">\(考虑映射\)</span>G Gx , g gx
<span class="math inline">\(.考虑取\)</span>H = _G ( x )
$,现在考虑有:</p>
$$
<span class="math display">\[\begin{aligned}
gx &amp; = g &#39; x \\
\Leftrightarrow g ^{ - 1  } g &#39; x &amp; = x \\
\Leftrightarrow g ^{ - 1  } g &#39; \in H \\
\Leftrightarrow g &#39; \in gH \\
\Leftrightarrow g &#39; H &amp; = gH \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以我们可以搞一个同构映射$G / H Gx <span class="math inline">\(.注意这里未必是群同构,原因是\)</span>H <span class="math inline">\(未必是正规子群,但\)</span>G / H <span class="math inline">\(这个右陪集总可以定义.对于有限集合的情况,回忆到\)</span>X
<span class="math inline">\(可以进行轨道分解,设其不同的轨道分别是\)</span>Gx
_1 , , Gx _m <span class="math inline">\((回忆到\)</span>m = | X / G |
<span class="math inline">\(),并且对应的稳定化子群分别是\)</span>H _1 ,
, H _m $,上述命题给出:</p>
<p><span class="math display">\[
| X | = \sum | Gx _k | = \sum [ G : H _k ]
\]</span></p>
<p>另一个结论是$| X / G | | G | = _{ g G } | X ^g |
$,这个结论是染色计数的基础.</p>
<p>为了证明上面这个结论,我们下面证明把$X <span class="math inline">\(分解为若干轨道后,对于每个轨道\)</span>X <em>i
<span class="math inline">\(都有\)</span></em>{ g G } | X _i ^g | = | G
| <span class="math inline">\(,由于轨道之间互不干扰,下面只需证明\)</span>X <span class="math inline">\(是传递性的单个轨道的情况即可,回忆到单个轨道上的稳定化子群大小均相等,任取\)</span>x
_0 X <span class="math inline">\(,由于此时只着眼于单个轨道,因此根据上述结论\)</span>|
X | = [ G : _G ( x _0 ) ] $.此时:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ g \in G  } | X ^g | &amp; = \sum _{ x \in X  } | \mathrm {
Stab  } _G ( x ) | \\
&amp; = | X | \cdot | \mathrm { Stab  } _G ( x _0 ) | \\
&amp; = [ G : \mathrm { Stab  } _G ( x _0 ) ] \cdot | \mathrm { Stab  }
_G ( x _0 ) | \\
&amp; = | G |
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h5><span id="p-群"><span class="math inline">\(p\)</span>-群</span></h5>
<p>设$p prime <span class="math inline">\(,如果\)</span>| G | = p ^m
<span class="math inline">\((当\)</span>m = 0 <span class="math inline">\(的时候称其平凡),则称\)</span>G <span class="math inline">\(为\)</span>p
$-<strong>群</strong>.对此我们有以下结论:</p>
<ol type="1">
<li><p>$| X | | X ^G | $.</p></li>
<li><p>如果$| G | <span class="math inline">\(非平凡,则\)</span>Z _G { 1
} <span class="math inline">\(.进一步地,\)</span>p ( | Z _G | )
$.</p></li>
</ol>
<p>(1)的原因是轨道分解给出:</p>
<p><span class="math display">\[
| X | = | X ^G | + \sum _{ H _i \ne G  } [ G : H _i ]
\]</span></p>
<p>然而拉格朗日定理给出$| H _i | <span class="math inline">\(总是\)</span>| G | <span class="math inline">\(的因子,也就是说\)</span> { | H _i | } = p ^k
$,于是证毕.</p>
<p>(2)的证明,考虑映射$a : G G G : a ( g , x ) = Ad _g ( x ) = gxg ^{ - 1
} <span class="math inline">\(,这本身是\)</span>G <span class="math inline">\(对自身的一个左作用.而容易见到此作用下的不动点集就是\)</span>Z
_G <span class="math inline">\(.而\)</span>| Z _G | | G |
$,于是证毕.</p>
<p>我们知道轨道分解事实上给出了一种划分集合的策略,而这里的映射其实也给出了一种划分集合的策略:按<strong>共轭类</strong>划分.换言之,我们设$a
b <span class="math inline">\(当且仅当\)</span>g G , a = gbg ^{ - 1 }
$,容易见到其满足等价关系的三条性质.因此我们得到一个共轭类的大小总是整除群的大小,以及:</p>
<p><span class="math display">\[
| G | = | Z _G | + \sum _{ H _i \ne G  } [ G : H _i ]
\]</span></p>
<p>这个被称为<strong>类方程</strong>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:阶为$p ^2 $的有限群都是交换的.</p>
<p>考虑其中心$Z _G <span class="math inline">\(,由于该群非平凡,所以\)</span>| Z _G | &gt; 1 <span class="math inline">\(,所以\)</span>| Z _G | = p <span class="math inline">\(或\)</span>| Z _G | = p ^2 $,后者显然已经证毕.</p>
<p>如果能取出一个元素$c <span class="math inline">\(使得\)</span>c = G
<span class="math inline">\(则显然证毕,下面假设所有的非平凡循环子群的阶都是\)</span>p
$.</p>
<p>取$a Z _G , a <span class="math inline">\(,则\)</span>Z _G = a <span class="math inline">\(.任取\)</span>b G Z _G <span class="math inline">\(,考虑\)</span>b Z _G = { 1 } <span class="math inline">\(,原因是如果\)</span>i , j , a ^i = b ^j <span class="math inline">\(,则取\)</span>j <span class="math inline">\(在\)</span>p <span class="math inline">\(下的逆元\)</span>k <span class="math inline">\(,有\)</span>a ^{ ik } = b $,这就不符.</p>
<p>于是有$G / Z _G b $,立刻证毕.</p>
<h4><span id="正规子群">正规子群</span></h4>
<p>设$G <span class="math inline">\(是一个群,\)</span>H G <span class="math inline">\(,如果\)</span>a G , aH = Ha <span class="math inline">\(或回忆到商群的概念只需检验\)</span>a ^{ - 1 } Ha H
<span class="math inline">\(,我们称\)</span>H <span class="math inline">\(是\)</span>G <span class="math inline">\(的**正规子群**,记作\)</span>H G
$.当一个子群是正规的时候,它的左右陪集不必区分.</p>
<p>显然,$G <span class="math inline">\(和\)</span>{ e } <span class="math inline">\(都是\)</span>G <span class="math inline">\(的正规子群,如果\)</span>G
$除此之外没有别的正规子群,称其为<strong>单群</strong>.</p>
<p>容易发现$Z _G G <span class="math inline">\(.此外,如果\)</span>N G
<span class="math inline">\(,而且\)</span>H G <span class="math inline">\(,则\)</span>N H H $,只需套用定义即可发现.</p>
<p>于此还可以引入两个定义,假设$K G $:</p>
<ol type="1">
<li><p>定义$K <span class="math inline">\(的**中心化子**:\)</span>Z _G (
K ) = { g G | k K , gkg ^{ - 1 } = k } $.</p></li>
<li><p>定义$K <span class="math inline">\(的**正规化子**:\)</span>N _G (
K ) = { g G | gKg ^{ - 1 } = K } $.</p></li>
</ol>
<p>显然$K N _G ( K ) Z _G ( K ) $.</p>
<h5><span id="正规子群的判定定理">正规子群的判定定理</span></h5>
<p>当$H G $时,下列命题等价:</p>
<ol type="1">
<li><p>$H G $.</p></li>
<li><p>$a , b G , c G , ( aH ) ( bH ) = cH $.</p></li>
<li><p>$a G , a ^{ - 1 } Ha = H $.</p></li>
<li><p>$a G , h H , a ^{ - 1 } ha H $.</p></li>
</ol>
<p>先证明(2)$$(1):</p>
<p>由于$a ^2 H ( aH ) ^2 <span class="math inline">\(,\)</span>a ^2 ( aH
) ^2 <span class="math inline">\(并且\)</span>( aH ) ^2 = cH <span class="math inline">\(是左陪集,那么由于左陪集是等价类,所以\)</span>a ^2
H = ( aH ) ^2 <span class="math inline">\(.两边同时乘以\)</span>a ^{ - 1
} <span class="math inline">\(,有\)</span>Ha HaH = aH <span class="math inline">\(.再次两边左右乘以\)</span>a ^{ - 1 } <span class="math inline">\(,得到\)</span>a ^{ - 1 } H Ha ^{ - 1 } , a G
$,也就证毕.</p>
<p>再证明(1)$$(2):</p>
<p><span class="math display">\[
( aH ) ( bH ) = aHbH = a ( bH ) H = abH
\]</span></p>
<p>这里还可以进一步说明如果这里干脆在正规子群的陪集上定义二元运算$( aH ,
bH ) abH <span class="math inline">\(后其陪集构成群.首先我们要检验良定性质.注意到如果\)</span>a
’ = au , b ’ = bv <span class="math inline">\(,其中\)</span>u , v H
$,则:</p>
<p><span class="math display">\[
a &#39; b &#39; H = aubvH = abb ^{ - 1  } ubvH = abH
\]</span></p>
<p>原因是$b ^{ - 1 } ub H , v H $.</p>
<p>逆元只需要对$( aH ) ^{ - 1 } = a ^{ - 1 } H
$即可.至于结合律也可以用上述性质转化,这样就搞定了.</p>
<p>剩下的部分,(1)$<span class="math inline">\((3),(3)\)</span><span class="math inline">\((4)都显然,考虑证明(4)\)</span>$(3).</p>
<p>(4)显然等价于$ha aH <span class="math inline">\(,于是有\)</span>Ha aH
<span class="math inline">\(.而又等价于\)</span>a ^{ - 1 } h Ha ^{ - 1 }
$,于是类似证毕.</p>
<p>设$G <span class="math inline">\(是群,\)</span>H G <span class="math inline">\(,则\)</span>H <span class="math inline">\(的陪集在乘法下构成群,这个群称为\)</span>G <span class="math inline">\(关于\)</span>H <span class="math inline">\(的**商群**,记作\)</span>G / H $.</p>
<p>考虑封闭律:$( aH ) ( bH ) = a ( bH ) H = abH <span class="math inline">\(,又显然满足结合律.又有\)</span>aH G / H , eH ( aH
) = ( aH ) H = aH <span class="math inline">\(,于是\)</span>H <span class="math inline">\(是幺元.同样知道\)</span>a ^{ - 1 } H = ( aH ) ^{ -
1 } $,于是存在逆元.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果$[ G : H ] = 2 <span class="math inline">\(的话则一定有\)</span>H G $.</p>
<p>原因是其可以分解成两个陪集,而其中一个陪集自动是$H
$本身,所以另一个陪集也同样不分左右.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:如果$G / Z _G <span class="math inline">\(是循环群,则\)</span>G
$交换.</p>
<p>不妨假设$G / Z _G = { Z _G , aZ _G , a ^2 Z _G , } $.</p>
<p>对于任意$b , c G <span class="math inline">\(,都存在一组\)</span>i ,
j , g _1 , g _2 <span class="math inline">\(满足\)</span>i , j <span class="math inline">\(,\)</span>g _1 , g _2 Z _G <span class="math inline">\(有\)</span>b = a ^i g _1 , c = a ^j g _2 <span class="math inline">\(,显然\)</span>bc = cb $.</p>
<h5><span id="正规子群与同态">正规子群与同态</span></h5>
<p>事实上有以下命题:</p>
<ol type="1">
<li><p>$  G _1 $.</p></li>
<li><p>$  G $.</p></li>
</ol>
<p>先看(1),考虑首先$e _1  <span class="math inline">\(,所以其不为空.其次对于任意\)</span>a _1 , b _1
 <span class="math inline">\(,\)</span>a , b G <span class="math inline">\(,使得\)</span>( a ) = a _1 , ( b ) = b _1
$.于是:</p>
<p><span class="math display">\[
a _1 b _1 ^{ - 1  } = \varphi ( a ) \varphi ( b ^{ - 1  } ) = \varphi (
ab ^{ - 1  } ) \in \text { im  } \ \varphi
\]</span></p>
<p>再看(2),同上可知$  <span class="math inline">\(,对于任意的\)</span>a
, b  <span class="math inline">\(,\)</span>( ab ^{ - 1 } ) = ( a ) ( b )
^{ - 1 } = e _1 <span class="math inline">\(,所以\)</span>ab ^{ - 1 }
 <span class="math inline">\(,说明\)</span>  G <span class="math inline">\(.而\)</span>g G <span class="math inline">\(,\)</span>( gag ^{ - 1 } ) = ( g ) e _1 ( g ) ^{ -
1 } = e _1 <span class="math inline">\(,所以\)</span>gag ^{ - 1 }
 $.</p>
<p>我们也可以说正规子群均可以成为某个映射的$<span class="math inline">\(,方法是构造映射\)</span>: G G / N , g gN
$.容易检验这的确是一个群同态.</p>
<p>另外如果$f <span class="math inline">\(是同构,那么\)</span>f ^{ - 1 }
$也是同态,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
f ( f ^{ - 1  } ( x ) f ^{ - 1  } ( y ) ) &amp; = f ( f ^{ - 1  } ( x )
) f ( f ^{ - 1  } ( y ) ) &amp; = xy &amp; = f ( f ^{ - 1  } ( xy ) ) \\
f ^{ - 1  } ( x ) f ^{ - 1  } ( y ) &amp; = f ^{ - 1  } ( xy )
\end{aligned}
\]</span></p>
<p>以及如果$f , g <span class="math inline">\(都是同态,那么\)</span>f g
$也是同态.</p>
<p>更进一步地,我们实际上可以在这里画交换图表,对于任何一个群同态$f : G G
’ <span class="math inline">\(,取\)</span>: G G / f <span class="math inline">\(,我们存在唯一的\)</span>{ f } <span class="math inline">\(使得\)</span>f = { f }
$,或言使得下述交换图表成立:</p>
<p><span class="math display">\[
\xymatrix { G \ar [r ] ^f \ar [d ] _\pi &amp; G &#39; \\
G / \ker f \ar [ru ] _{ \bar { f  }  } &amp; \\
}
\]</span></p>
<p>这被称为商群的泛性质.事实上这也很一眼,原因是要满足$x G , { f } ( xN )
= f ( x ) <span class="math inline">\(,这其实也就定义了\)</span>{ f }
$,而存在性只需要堆堆语言就行.</p>
<p>进一步地,如果$f : G G ’ <span class="math inline">\(,而\)</span>N G ,
N ’ G ’ <span class="math inline">\(,并且\)</span>f ( N ) N ’ <span class="math inline">\(,则存在唯一的映射\)</span>{ f } : G / N G ’ / N ’
$使得我们可以搞定下面这个图表的交换性:</p>
<p><span class="math display">\[
\xymatrix { G \ar [r ] ^f \ar [d ] &amp; G &#39; \ar [d ] \\
G / N \ar [r ] _{ \bar { f  }  } &amp; G &#39; / N &#39;  }
\]</span></p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>设$: G G _1 <span class="math inline">\(是群同态,则\)</span>G /  
 $.</p>
<p>不妨先设$H =  <span class="math inline">\(.我们定义映射\)</span>: G /
H  <span class="math inline">\(,满足\)</span>( aH ) = ( a ) $.</p>
<p>不过首先要判断$<span class="math inline">\(是不是良定义,也就是当\)</span>aH = bH <span class="math inline">\(的时候,我们要判断\)</span>( a ) <span class="math inline">\(是否等于\)</span>( b ) <span class="math inline">\(.若\)</span>aH = bH <span class="math inline">\(,说明\)</span>h H , a = bh <span class="math inline">\(,那么\)</span>( aH ) = ( a ) = ( bh ) = ( b ) ( h
) = ( b ) $.</p>
<p>然后还要证明其是群同态,注意到$( ( aH ) ( bH ) ) = ( abH ) = ( ab ) =
( a ) ( b ) = ( aH ) ( bH ) $.</p>
<p>接下来要证明它是单射,显然只有$( H ) = e _1 <span class="math inline">\(,\)</span>  = { H } $.</p>
<p>接下来要证明它是满射,$g  <span class="math inline">\(,\)</span>a , (
a ) = g <span class="math inline">\(,则\)</span>( aH ) = g $.</p>
<p>这样就证明了同态基本定理.</p>
<p>当$<span class="math inline">\(是满射的时候\)</span>G _1 =  <span class="math inline">\(,所以此时有\)</span>G /  G _1 $.</p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>我们定义$H G <span class="math inline">\(时,定义\)</span>: G G / H ,
a aH <span class="math inline">\(.显然其是群同态,定义其为由\)</span>G
<span class="math inline">\(到\)</span>G / H
$的<strong>典范同态</strong>.</p>
<p>那么我们有第一同构定理,即对于一个$G <span class="math inline">\(的一个正规子群\)</span>H <span class="math inline">\(,在典范同态\)</span>: G G / H $下,我们有:</p>
<ol type="1">
<li><p>$G <span class="math inline">\(的包含\)</span>H <span class="math inline">\(的子群和\)</span>G / H <span class="math inline">\(的子群在\)</span>$下是群同构.</p></li>
<li><p>在此对应下,正规子群对应于正规子群.</p></li>
<li><p>若有$H K G <span class="math inline">\(,则\)</span>G / K ( G / H
) / ( K / H ) $.</p></li>
</ol>
<p>如若考虑满同态的情况,我们有另一种形式的表达.设$f : G G ’ <span class="math inline">\(是群的满同态,根据同态基本定理有\)</span>G / f G ’
$,立刻有:</p>
<ol type="1">
<li><p>$G <span class="math inline">\(的包含\)</span>f <span class="math inline">\(的子群和\)</span>G ’ <span class="math inline">\(的子群在\)</span>f $下一一对应.</p></li>
<li><p>在此对应下,正规子群对应正规子群.</p></li>
<li><p>若有$f H G <span class="math inline">\(,则\)</span>G / H ( G / f
) / ( H / f ) G ’ / H ’ $.</p></li>
</ol>
<p>此形式与一开始的形式无太大差别,因为任何一个正规子群总对应某个映射的$$.</p>
<p>然而这个证明要比原本的大量堆砌要更为漂亮.我们断言这种一一对应恰好由$f
<span class="math inline">\(给出.更进一步地,对于\)</span>f H G <span class="math inline">\(,其对应了一个\)</span>H ’ G ’ <span class="math inline">\(,满足:\)</span>f ( H ) = H ’ <span class="math inline">\(,而且\)</span>f ^{ - 1 } ( H ’ ) = H $.</p>
<p>先来证明我们找到是一个双射,那就需要对每个$H <span class="math inline">\(证明其对应的那个\)</span>H ’
$确实是对应自己的,反之亦然:</p>
<p>首先我们要证明$H = f ^{ - 1 } ( f ( H ) ) <span class="math inline">\(.显然有\)</span>H f ^{ - 1 } ( f ( H ) ) <span class="math inline">\(,下面证明\)</span>f ^{ - 1 } ( f ( H ) ) H <span class="math inline">\(.也就是要证明\)</span>f ( x ) f ( H ) <span class="math inline">\(,也就是\)</span>f ( x ) = f ( h ) , x G , h H
<span class="math inline">\(,都一定有\)</span>x H $.</p>
<p>可如若$f ( x ) = f ( h ) <span class="math inline">\(就一定有\)</span>xh ^{ - 1 } f H <span class="math inline">\(,这就搞定了\)</span>x H $.</p>
<p>反过来的$H ’ = f ( f ^{ - 1 } ( H ’ ) ) <span class="math inline">\(,回忆到\)</span>f <span class="math inline">\(是满射,其总有右逆,因此这是显然成立的.这就搞定了一一对应的关系,而且顺便还给出如果\)</span>H
_1 H _2 <span class="math inline">\(,则\)</span>H _1 ’ = f ( H _1 ) H _2
’ = f ( H _2 ) <span class="math inline">\(.至于\)</span>H ’ <span class="math inline">\(的正规性,只需要回忆到\)</span>{ x } G ’ <span class="math inline">\(,\)</span>x G , { x } = f ( x ) <span class="math inline">\(.这就给出\)</span>{ x } f ( H ) ( { x } ) ^{ - 1 }
= f ( xHx ^{ - 1 } ) = f ( H ) $.</p>
<p>最后考虑映射$G G ’ / H ’ , g f ( g ) H ’ <span class="math inline">\(,它的\)</span>= f ^{ - 1 } ( H ’ ) = H <span class="math inline">\(,所以同态基本定理给出\)</span>G / H G ’ / H ’
$,这就搞定.</p>
<p>总之,第一同构定理给出的是”商”这个操作究竟对一个群有了怎样的影响,其实就是切片了对吧,然后把每一片缩起来.有下述交换图表:</p>
<p><span class="math display">\[
\xymatrix { G \ar [r ] ^f \ar [d ] &amp; G &#39; \ar [d ] \\
G / H \ar [r ] &amp; G &#39; / H &#39;  }
\]</span></p>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>设$G <span class="math inline">\(是群,\)</span>H G , K G $,则:</p>
<ol type="1">
<li><p>$H K K <span class="math inline">\(.\)</span>HK = KH G
$.</p></li>
<li><p>$( HK ) / H K / ( H K ) $.</p></li>
</ol>
<p>考虑(1)的证明:</p>
<p>先看前半部分,只需证明$k K , w H K <span class="math inline">\(,\)</span>kwk ^{ - 1 } H K $.</p>
<p>注意到$k , w K <span class="math inline">\(,所以\)</span>kwk ^{ - 1 }
K <span class="math inline">\(;又注意到\)</span>H G <span class="math inline">\(,所以\)</span>kwk ^{ - 1 } H
$,这就证明了该结论.</p>
<p>对于后半部分先证明$HK = KH <span class="math inline">\(,考虑\)</span>hk Hk = kH KH $.</p>
<p>再证$HK $的确是一个子群,我们早在子群判定引理处就证明了此结论.</p>
<p>再看(2)的证明:</p>
<p>考虑构造$: K ( HK ) / H , k kH $.这显然是良定义的群同态.</p>
<p>考虑$( k ) = H k H k K H <span class="math inline">\(,于是\)</span>=
K H $.</p>
<p>接下来还需要解释其满性,考虑$hkH = H ( hk ) = Hk = kH
$,这就证明了其满性,于是上述命题自然成立.</p>
<p>根据第二同构定理还可以立刻得到:$H , K G <span class="math inline">\(,\)</span>G <span class="math inline">\(是有限群,\)</span>| HK | = { | H K | } $.</p>
<p>另外容易见到,其实只要$H N _G ( K ) <span class="math inline">\(,上述结论依然过得去,因为只需要把群限制在\)</span>N
_G ( K ) $上即可.</p>
<h5><span id="交换化">交换化</span></h5>
<p>如果群$G <span class="math inline">\(的子群\)</span>H <span class="math inline">\(对于所有自同构\)</span>: G G <span class="math inline">\(都满足\)</span>( H ) = H <span class="math inline">\(,则称\)</span>H <span class="math inline">\(是一个**特征子群**.取\)</span>=
$可以见到特征子群总是正规子群.</p>
<p>还可以见到群的中心总是特征子群,原因是任取$z Z _G , g G $,都满足:</p>
<p><span class="math display">\[
\begin{aligned}
zg &amp; = gz \\
\varphi ( z ) \varphi ( g ) &amp; = \varphi ( g ) \varphi ( z )
\end{aligned}
\]</span></p>
<p>由于$g <span class="math inline">\(可以取遍\)</span>G <span class="math inline">\(,所以\)</span>( g ) <span class="math inline">\(可以取遍\)</span>G <span class="math inline">\(,所以\)</span>( z ) Z _G $.</p>
<p>我们还可以定义群的<strong>导出子群</strong>$G _{ der } = aba ^{ - 1 }
b ^{ - 1 } | a , b G <span class="math inline">\(也是特征子群.原因是\)</span>( aba ^{ - 1 } b ^{ -
1 } ) = ( a ) ( b ) ( a ) ^{ - 1 } ( b ) ^{ - 1 } $.</p>
<p>既如此,考虑商群$G <em>{ ab } = G / G </em>{ der } <span class="math inline">\(.留意到\)</span>g _1 , g <em>2 G </em>{ ab }
$:</p>
$$
<span class="math display">\[\begin{aligned}
g _1 g _2 G _{ der  } &amp; = g _2 g _1 G _{ der  } \\
\Leftrightarrow g _1 ^{ - 1  } g _2 ^{ - 1  } g _1 g _2 G _{ der  }
&amp; = G _{ der  } \\
\Leftrightarrow g _1 ^{ - 1  } g _2 ^{ - 1  } g _1 g _2 \in G _{ der  }
\\

\end{aligned}\]</span>
<p>$$</p>
<p>所以见到此商群交换,我们将此操作称为<strong>群的交换化</strong>.</p>
<p>我们可能还想说明这样的交换化是最为合理的,我们可以证明如果存在一个同态$f
: G A <span class="math inline">\(,其中\)</span>A <span class="math inline">\(是一个交换群.则存在唯一的\)</span>{ f } : G _{ ab
} A $,使下列图表交换:</p>
<p><span class="math display">\[
\xymatrix { G \ar [d ] \ar [r ] ^f &amp; A \\
G _{ ab  } \ar [ru ] _{ \bar { f  }  } &amp;  }
\]</span></p>
<p>首先注意到必须满足${ f } ( gG _{ der } ) = f ( g ) <span class="math inline">\(,这就给出唯一性,其次要给出存在性,就要证明如果\)</span>g
<em>1 G </em>{ der } = g <em>2 G </em>{ der } <span class="math inline">\(则\)</span>f ( g _1 ) = f ( g <em>2 ) <span class="math inline">\(.只需检验\)</span>G </em>{ der } f <span class="math inline">\(就行,然而由于\)</span>f ( aba ^{ - 1 } b ^{ - 1 }
) = e _A <span class="math inline">\(,原因是\)</span>A
$的交换性,因此这就给定了.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明$GL ( n , F ) _{ der } = SL ( n , F ) <span class="math inline">\(,其中\)</span>F $是含有至少三个元素的域.</p>
<p>显然$GL ( n , F ) _{ der } SL ( n , F ) <span class="math inline">\(,只需要证明上述导出子群的确生成了\)</span>SL ( n ,
F ) $即可.</p>
<p>考虑所有的矩阵都可以通过若干次初等行列变换变到对角线全$1
$的矩阵,只需要把这些初等行列变换全都拿到即可,略去不谈.</p>
<p>此时也可以见到$GL ( n , F ) / SL ( n , F ) = F
$,其实也就是行列式.</p>
<h6><span id="example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</span></h6>
<p>设群$G <span class="math inline">\(作用在集合\)</span>X <span class="math inline">\(上,\)</span>| X | <span class="math inline">\(,若\)</span>( x , y ) , ( x ’ , y ’ ) X ^2 <span class="math inline">\(,其中\)</span>x y , x ’ y ’ <span class="math inline">\(,都存在\)</span>g G <span class="math inline">\(使得\)</span>gx = x ’ , gy = y ’ <span class="math inline">\(,则称该作用是**双传递的**.下面我们设\)</span>G
<span class="math inline">\(双传递于\)</span>X <span class="math inline">\(,并且记\)</span>H _x = _G ( x ) $.</p>
<p>先证明一个引理:$H _x <span class="math inline">\(都是\)</span>G
$的极大真子群.</p>
<p>为证明此,只需要证明任意往里面多添一个$g G H _x <span class="math inline">\(,都会使得这个群扩充到\)</span>G <span class="math inline">\(本身.一个想法是证明\)</span>G = H _x H _x g H _x
$.</p>
<p>既然如此,考虑只要证$g _1 G H _x , h _1 , h _2 H _x <span class="math inline">\(使得\)</span>g _1 = h _1 gh _2 <span class="math inline">\(即可,也就是\)</span>h _1 <span class="math inline">\(使得\)</span>g _1 ^{ - 1 } h _1 g H _x g _1 ^{ - 1
} h _1 g ( x ) = x g ( x ) = h _1 ^{ - 1 } g _1 ( x ) $.</p>
<p>考虑到$g ( x ) x , g _1 ( x ) x <span class="math inline">\(.由双传递性一定存在一个\)</span>h _1 ^{ - 1 }
<span class="math inline">\(把\)</span>( x , g _1 ( x ) ) ( x , g ( x )
) $,这就搞定了.</p>
<p>接下来再证明一个引理:任何正规子群$N G <span class="math inline">\(在\)</span>X
$上的作用要么是平凡的,要么是传递的.</p>
<p>若$N <span class="math inline">\(的作用不是平凡的,也就是存在\)</span>x , n <span class="math inline">\(使得\)</span>nx x <span class="math inline">\(,那我们下面证明对于任意\)</span>y y ’ <span class="math inline">\(,都可以找到一个元素\)</span>m N <span class="math inline">\(使得\)</span>my = y ’ <span class="math inline">\(.原因是可以取\)</span>g : ( x , nx ) ( y , y ’ )
<span class="math inline">\(,于是\)</span>gx = y , gnx = y ’ , gng ^{ -
1 } y = y ’ <span class="math inline">\(,由于\)</span>N <span class="math inline">\(正规知道\)</span>gng ^{ - 1 } N $,这就搞定了.</p>
<p>接下来证明岩泽判准,假设$G <span class="math inline">\(作用忠实,\)</span>G = G _{ der } <span class="math inline">\(,而且存在\)</span>x <span class="math inline">\(使得\)</span>H _x <span class="math inline">\(有正规交换子群\)</span>U <span class="math inline">\(,而\)</span>U <span class="math inline">\(在\)</span>G <span class="math inline">\(中的所有共轭生成\)</span>G <span class="math inline">\(.我们下面证明\)</span>G $是单群.</p>
<p>取定$N G <span class="math inline">\(和\)</span>x X <span class="math inline">\(,由于\)</span>H _x <span class="math inline">\(是极大真子群,所以要么\)</span>NH _x = H _x <span class="math inline">\(,要么\)</span>NH _x = G $.</p>
<p>当$NH _x = H _x , N H _x <span class="math inline">\(的时候,此时\)</span>N <span class="math inline">\(作用并非传递,所以\)</span>N <span class="math inline">\(作用平凡.由于作用是忠实的,作用平凡的元素也就只有\)</span>{
id } $.</p>
<p>当$NH _x = G <span class="math inline">\(的时候,我们先证明\)</span>NU
NH _x = G <span class="math inline">\(.首先第二同构定理的部分已经给出了\)</span>NU NH _x
<span class="math inline">\(,现在考虑\)</span>nu NU , n _1 h _1 NH _x
<span class="math inline">\(,下面证明\)</span>n _1 h _1 nuh _1 ^{ - 1 }
n _1 ^{ - 1 } NU $.</p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
n _1 h _1 nuh _1 ^{ - 1  } n _1 ^{ - 1  } \\
= n _1 ( h _1 nh _1 ^{ - 1  } ) ( h _1 uh _1 ^{ - 1  } ) n _1 ^{ - 1  }
\\
\in NUN = NU
\end{aligned}
\]</span></p>
<p>此时由于$U NU <span class="math inline">\(,而后者正规,前者的所有共轭生成\)</span>G <span class="math inline">\(,这必然意味着\)</span>NU = G <span class="math inline">\(,第二同态定理给出\)</span>G / N U / ( N U ) <span class="math inline">\(而后者交换,这给出了一种\)</span>G <span class="math inline">\(向交换群的同态,我们知道此时必然有\)</span>G <em>{
ab } <span class="math inline">\(上也有一个向交换群的同态,然而\)</span>G
</em>{ ab } <span class="math inline">\(是平凡群,因此\)</span>G / N
<span class="math inline">\(必然也是平凡群,意味着\)</span>N = G $.</p>
<h6><span id="example3">Example3</span></h6>
<p>设$F <span class="math inline">\(为域且\)</span>| F | <span class="math inline">\(,记\)</span>Z <span class="math inline">\(是\)</span>SL ( n , F ) <span class="math inline">\(的中心,下面我们证明当\)</span>n <span class="math inline">\(的时候,\)</span>PSL ( 2 , F ) = SL ( 2 , F ) / Z
$是单群.</p>
<p>我们想要用岩泽健吉判准,首先要检验$SL ( n , F ) = SL ( n , F ) _{ der
} $,这个与之前的做法几乎类似,只需要简单说明.</p>
<p>接下来设$ ^{ n - 1 } ( F ) <span class="math inline">\(为\)</span>F
^n $的$1 <span class="math inline">\(维子空间,让\)</span>PSL ( n , F )
$作用在上面,留意到中心的作用也的确是平凡的.</p>
<p>当$n = 2 <span class="math inline">\(的时候,记录\)</span>( x , y ) F
^2 { 0 } <span class="math inline">\(生成的空间为\)</span>( x : y )
$,我们来证明它是双传递的,事实上这较为显然.</p>
接下来我们来看$( 1 : 0 ) <span class="math inline">\(上的稳定化子群\)</span>H <span class="math inline">\(,其实也就是所有的上三角矩阵,然后还要验证作用是忠实的,总之请检验以上事实.然后取\)</span>U
= {
<span class="math display">\[\begin{bmatrix}1 &amp; \_ \\ 0 &amp; 1
\end{bmatrix}\]</span>
<p>Z } $.</p>
当$n <span class="math inline">\(和上面是同理的,对于\)</span>( 1 : 0 : 0
) <span class="math inline">\(的稳定化子群取分块上三角矩阵\)</span>
<span class="math display">\[\begin{bmatrix}a &amp; \_ \\ &amp; A
\end{bmatrix}\]</span>
Z <span class="math inline">\(,然后取\)</span>U = {
<span class="math display">\[\begin{bmatrix}1 &amp; \_ \\ 0 &amp; I
\end{bmatrix}\]</span>
<p>Z } $.</p>
<h4><span id="群的直和与直积">群的直和与直积</span></h4>
<h5><span id="直和">直和</span></h5>
<p>在两个群$G _1 , G _2 <span class="math inline">\(的笛卡尔积\)</span>G
_1 G _2 <span class="math inline">\(集合上定义二元运算,满足\)</span>( a
_1 , b _1 ) ( a _2 , b _2 ) = ( a _1 a _2 , b _1 b _2 ) <span class="math inline">\(,这个集合和这个二元运算显然组成群,称这个群为\)</span>G
_1 <span class="math inline">\(和\)</span>G _2 <span class="math inline">\(的**外直和**,记为\)</span>G _1 G _2 <span class="math inline">\(,\)</span>G _1 , G _2
$称作其的<strong>直和因子</strong>.如果要对无限个群做类似操作,则可以区分出<strong>直积</strong>的版本,仍是因为是否有限个分量非零的问题.</p>
<p>显然$G _1 G _2 <span class="math inline">\(中存在两个正规子群\)</span>{ G _1 } = { ( a , e _2
) | a G _1 } , { G _2 } = { ( e _1 , b ) | b G _2 } <span class="math inline">\(,并且不难发现\)</span>G _1 G _2 = { G _1 } { G _2
} $.</p>
<p>这给出了一种分解群的策略,事实上,设$G <span class="math inline">\(是群,\)</span>H , K G , G = HK
$,我们有以下命题互推:</p>
<ol type="1">
<li><p>映射$: H K G , ( h , k ) hk $是同构.</p></li>
<li><p>$G <span class="math inline">\(的任一元素表示为\)</span>H , K
$的乘积的表示法唯一.</p></li>
<li><p>$G <span class="math inline">\(的幺元表示为\)</span>H , K
$的元素的乘积的表示法唯一.</p></li>
<li><p>$H K = { e } $.</p></li>
</ol>
<p>显然$( 1 ) ( 2 ) ( 3 ) <span class="math inline">\(.对于\)</span>( 3
) ( 4 ) <span class="math inline">\(,如果\)</span>g H K , g e <span class="math inline">\(,则\)</span>e = gg ^{ - 1 } = ee
$,这就给出了两种表示法,不符.</p>
<p>只需证明$( 4 ) ( 1 )
$.根据我们的经验,先证良定义(显然),再证群同态,再证单射,再证满射(显然).</p>
<p>我们先干个事,我们断言$h H , k K , hk = kh $.</p>
<p>这个怎么断言呢?我们考虑由于$H G <span class="math inline">\(,有\)</span>k ^{ - 1 } hk H <span class="math inline">\(,所以\)</span>h ^{ - 1 } k ^{ - 1 } hk H <span class="math inline">\(,同理可证明\)</span>h ^{ - 1 } k ^{ - 1 } hk K
<span class="math inline">\(,于是\)</span>h ^{ - 1 } k ^{ - 1 } hk = e
<span class="math inline">\(,\)</span>kh = hk
$.由此显然证明是群同态.</p>
<p>接下来只需要证明单射,只需要证明$= { e , e } <span class="math inline">\(.不妨设\)</span>( h , k ) <span class="math inline">\(,则\)</span>hk = e <span class="math inline">\(,\)</span>h = k ^{ - 1 } H K = e <span class="math inline">\(.所以\)</span>= { e , e } $.</p>
<p>我们也将$G <span class="math inline">\(称作\)</span>H <span class="math inline">\(和\)</span>K <span class="math inline">\(的**内直和**,将\)</span>H , K
$称作其<strong>直和因子</strong>.</p>
<p>上面的概念还可以扩展,设$G <span class="math inline">\(是群,\)</span>H
_1 , , H _n G , G = H _1 H _n $,我们有以下命题互推:</p>
<ol type="1">
<li><p>映射$: H _1 H _n G , ( h _1 , , h _n ) h _1 h _n
$是同构.</p></li>
<li><p>$G <span class="math inline">\(的任一元素表示为\)</span>H _1 , ,
H _n $的乘积的表示法唯一.</p></li>
<li><p>$G <span class="math inline">\(的幺元表示为\)</span>H _1 , , H _n
$的元素的乘积的表示法唯一.</p></li>
<li><p>$H <em>i ( H <em>1 H </em>{ i - 1 } H </em>{ i + 1 } H _n ) = { e
} $.</p></li>
</ol>
<h5><span id="半直积">半直积</span></h5>
<p>取$H , N <span class="math inline">\(是给定的两个任意的群,以及给定的群同态\)</span>: H
( N ) , h _h $.</p>
<p>接下来在$N H <span class="math inline">\(上定义一种二元运算,定义为\)</span>( n , h ) ( n ’
, h ’ ) = ( n <em>h ( n ’ ) , hh ’ ) <span class="math inline">\(.我们下面证明这种运算的确使得\)</span>N H <span class="math inline">\(成为群,记作\)</span>N </em>H $.见到:</p>
<ol type="1">
<li><p>幺元存在:$1 _{ N H } = ( 1 _N , 1 _H ) $.</p></li>
<li><p>逆元存在:$( n , h ) ^{ - 1 } = ( _{ h ^{ - 1 } } ( n ^{ - 1 } ) ,
h ^{ - 1 } ) $.</p></li>
</ol>
<p>结合律的验证比较多,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( n _1 , h _1 ) ( n _2 , h _2 ) ( n _3 , h _3 ) \\
&amp; = ( n _1 \varphi _{ h _1  } ( n _2 ) \varphi _{ h _1 h _2  } ( n
_3 ) , h _1 h _2 h _3 )
\end{aligned}
\]</span></p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
( n _1 , h _1 ) ( ( n _2 , h _2 ) ( n _3 , h _3 ) ) \\
&amp; = ( n _1 , h _1 ) ( n _2 \varphi _{ h _2  } ( n _3 ) , h _2 h _3 )
\\
&amp; = ( n _1 \varphi _{ h _1  } ( n _2 \varphi _{ h _2  } ( n _3 ) ) ,
h _1 h _2 h _3 )
\end{aligned}
\]</span></p>
<p>于是我们要证明的就是$_{ h _1 } ( n <em>2 ) </em>{ h _1 h _2 } ( n
<em>3 ) = </em>{ h _1 } ( n <em>2 </em>{ h _2 } ( n <em>3 ) <span class="math inline">\(.由于\)</span><span class="math inline">\(是同态,里面的乘积可以拆出,只需证明\)</span></em>{
h _1 h <em>2 } = </em>{ h <em>1 } </em>{ h _2 } <span class="math inline">\(,然而这恰是同态\)</span>: H ( N )
$本身的性质,这就搞定.</p>
<p>接下来,我们考虑搞两个嵌入映射,考虑$N N H , n ( n , 1 _H ) <span class="math inline">\(.同理定义\)</span>H N H , h ( 1 _N , h ) <span class="math inline">\(.在这种嵌入下见到\)</span>( n , h ) = ( n , 1 _H )
( 1 _N , h ) <span class="math inline">\(,可以发现\)</span>N N H
$.原因是:</p>
<p><span class="math display">\[
\begin{aligned}
( n _1 , h _1 ) ( n , 1 _H ) ( n _1 , h _1 ) ^{ - 1  } \\
&amp; = ( n _1 , 1 _H ) ( 1 _N , h _1 ) ( n , 1 _H ) ( 1 _N , h _1 ) ^{
- 1  } ( n _1 , 1 _H ) ^{ - 1  }
\end{aligned}
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( 1 _N , h ) ( n , 1 _H ) ( 1 _N , h ) ^{ - 1  } \\
&amp; = ( 1 _N , h ) ( n , 1 _H ) ( 1 _N , h ^{ - 1  } ) \\
&amp; = ( \varphi _h ( n ) , h ) ( 1 _N , h ^{ - 1  } ) \\
&amp; = ( \varphi _h ( n ) , 1 _H )
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<p>上述操作看上去一团迷雾,我们想要说明半直积定义的动机:其实就是想让$N ,
H <span class="math inline">\(嵌入同一个群中,并且使得\)</span>N
$是这个群的一个正规子群.</p>
<p>于是我们的目标终于明晰:假设$H G , N G , H N = { 1 } , G = NH = HN
<span class="math inline">\(,考虑由\)</span> <em>h ( n ) = hnh ^{ - 1 }
<span class="math inline">\(给出的映射,下面我们要证明存在同构\)</span>:
N </em> H G , ( n , h ) nh $.</p>
<p>首先验证这的确是个同态,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\Phi ( ( n , h ) ( n &#39; , h &#39; ) ) \\
&amp; = \Phi ( nhn &#39; h ^{ - 1  } , hh &#39; ) \\
&amp; = nhn &#39; h ^{ - 1  } hh &#39; \\
&amp; = nhn &#39; h &#39; &amp; = \Phi ( n , h ) \Phi ( n &#39; , h
&#39; )
\end{aligned}
\]</span></p>
<p>满性显然,单性的话考虑$( n , h ) = 1 nh = 1 n = 1 , h = 1
$,这就搞定.</p>
<p>上述构造舍弃了$<span class="math inline">\(,因此比起之前的版本,这个更像是一种内的版本.事实上上述也有第二同构定理给出\)</span>G
/ N H <span class="math inline">\(,所以你可以将商看作半直积的逆运算,然而反之不可.例如\)</span>(
/ 4 ) / ( 2 / 4 ) ( / 2 ) <span class="math inline">\(,注意到\)</span>(
2 / 4 ) ( / 2 ) <span class="math inline">\(,但\)</span> / 4 <span class="math inline">\(和\)</span>( / 2 ) ^2
$并不同构,前者是循环群后者是克莱因四元群.</p>
<p>半直积的作用要么是通过两个群得到一个新的群,要么反之将一个群拆分为两个不同的群.</p>
<h6><span id="example1">Example1</span></h6>
<p>一个例子是将置换群$S _n <span class="math inline">\(拆成偶置换群\)</span>A _n <span class="math inline">\(和任何一个单置换\)</span>= ( i , j ) <span class="math inline">\(的半直积,有:\)</span>S _n = A _n $.</p>
<p>然而当$n &gt; 2 <span class="math inline">\(的时候,见到永远不可能出现\)</span>S _n = A _n
<span class="math inline">\(的情形,证明可以考虑左侧的中心只有\)</span>id
<span class="math inline">\(而右侧至少有\)</span>( 1 , 1 ) $和$1 ,
$两个.</p>
<h6><span id="example2二面体群">Example2(二面体群)</span></h6>
<p>回忆到$O ( 2 ) <span class="math inline">\(为\)</span> ^2 <span class="math inline">\(上的正交变换,上面有一个正规子群\)</span>SO ( 2 )
<span class="math inline">\(为\)</span>= 1 $的部分.</p>
<p>设$n <span class="math inline">\(,取平面上的一个中心为\)</span>( 0 ,
0 ) <span class="math inline">\(的正\)</span>n <span class="math inline">\(边形,适当缩放后可以使得顶点分别为\)</span><em>n ^k
= e ^{ { n } } <span class="math inline">\(,设\)</span>D </em>{ 2 n }
<span class="math inline">\(为所有使得正\)</span>n <span class="math inline">\(边形不变的正交变换,容易见到\)</span>D _{ 2 n } O (
2 ) $.</p>
<p>接下来看$D _{ 2 n } $中的两种元素:</p>
<ol type="1">
<li><p>旋转:那肯定要将一个角挪到另一个角上,因此等价于复平面上的$_n ^k
<span class="math inline">\(,记\)</span>= _n <span class="math inline">\(则旋转群也就是\)</span> / n $.</p></li>
<li><p>镜射:任取一个$<span class="math inline">\(使得图形沿某条轴翻转.容易见到\)</span> / 2
$.</p></li>
</ol>
<p>下面我们说明$D <em>{ 2 n } / n </em> / 2 <span class="math inline">\(.其中\)</span>_{ 1 + 2 } ( a + n ) = - a + n
$.</p>
<p>首先见到$D <em>{ 2 n } SO ( 2 ) = <span class="math inline">\(,原因显然.这样两边取交就可以说明\)</span>D </em>{
2 n } $.</p>
<p>此外容易见到$= { 1 } <span class="math inline">\(.其余性质也容易说明,唯一可能稍不显然的是为何\)</span>$的确生成了整个群.</p>
<p>策略是转回去!假设这个变换将$0
$号顶点搞到了某个位置,你可以把它转回去,于是此时图形保持了$0
$号顶点不动,此时要么就是恒等,要么就是按照实轴翻转,这样就搞定了.</p>
<h3><span id="环">环</span></h3>
<p>定义一个<strong>环</strong>是一个集合$R <span class="math inline">\(和两种二元运算\)</span>+ ,
$.它应当满足如下性质:</p>
<ol type="1">
<li><p>集合对两种运算封闭.</p></li>
<li><p>$( R , + ) $构成阿贝尔群,加法幺元一般记作$0 _R <span class="math inline">\(,\)</span>x <span class="math inline">\(的加法逆元一般记作\)</span>- x $.</p></li>
<li><p>乘法有结合律.</p></li>
<li><p>乘法对加法有分配律.</p></li>
<li><p>(幺环存在乘法幺元,一般记作$1 _R $)</p></li>
<li><p>(交换环的乘法具有交换律)</p></li>
</ol>
<p>最平凡的环只包含一个$0 $元素,被称为<strong>零环</strong>.</p>
<p>下面证明一些环的基础性质:</p>
<ol type="1">
<li>$a R , a 0 = 0 a = 0 $.</li>
</ol>
<p>注意到$a 0 = a ( 0 + 0 ) = a 0 + a 0 <span class="math inline">\(,所以\)</span>a 0 = 0 $.</p>
<ol start="2" type="1">
<li>$a , b R , ( - a ) b = a ( - b ) = - ( ab ) $.</li>
</ol>
<p>注意到$( - a ) b + ab = b ( a - a ) = 0 <span class="math inline">\(,所以\)</span>- ( ab ) = ( - a ) b $.</p>
<ol start="3" type="1">
<li>$a , b R , ( - a ) ( - b ) = ab $.</li>
</ol>
<p>由(2)是显然的.</p>
<p>注意到环的定义中并没有提及乘法逆元.如果环$R <span class="math inline">\(是幺环,且对于某一个\)</span>a R <span class="math inline">\(,\)</span>a
$有逆元(或者既有左逆元又有右逆元,类似群,左右逆元必相等且唯一),那么称其为<strong>可逆元</strong>或<strong>单位元</strong>,有时又称其为unit.</p>
<p>容易验证幺环的可逆元的全体构成乘法群,记作$R ^$.</p>
<p>对于一个元素$a R <span class="math inline">\(来说,如果\)</span>b R {
0 } <span class="math inline">\(,\)</span>ab = 0 <span class="math inline">\(,我们称\)</span>a <span class="math inline">\(是\)</span>R <span class="math inline">\(中的一个**左零因子**,同理可定义**右零因子**,如果一个\)</span>a
$既是左零因子又是右零因子,我们称其为一个<strong>零因子</strong>.</p>
<p>我们事实上可以说明这里的加法和乘法与我们平时使用的相当类似,换言之,我们可以说明对于任意环$R
<span class="math inline">\(而言,单同态\)</span>: R $唯一.</p>
<p>首先我们应该满足$( 1 ) = 1 _R , ( 0 ) = 0 _R $.</p>
<p>其次我们应当有$( n ) = ( 1 + 1 + + 1 ) = ( 1 ) + ( 1 ) + + ( 1 )
<span class="math inline">\(.我们不妨把后者简写为\)</span>n ( 1 )
$,倍数运算是环中相当重要的运算.</p>
<h4><span id="子环">子环</span></h4>
<p>要验证$S <span class="math inline">\(是\)</span>R <span class="math inline">\(的子环,只需验证\)</span>S <span class="math inline">\(对加法下是子群,然后\)</span>S $对乘法封闭.</p>
<p>而事实上由于$- x = ( - 1 ) x <span class="math inline">\(,所以实际上只需要验证\)</span>S
$对加法和乘法都封闭即可.</p>
<h4><span id="理想">理想</span></h4>
<p>由于环上有两种运算,如果我们想在陪集上保持环的两种运算,就需要在上面加一些限制.</p>
<p>进一步地,如果$I <span class="math inline">\(是\)</span>R <span class="math inline">\(的一个加法子群(由于加法有交换律,所以加法子群一定是加法正规子群),并且\)</span>r
R <span class="math inline">\(,有\)</span>rI I <span class="math inline">\((那么自然有\)</span>rI = I <span class="math inline">\(),则称\)</span>I <span class="math inline">\(是\)</span>R
$的一个<strong>左理想</strong>,同理定义<strong>右理想</strong>,既是左理想又是右理想则称其为一个<strong>理想</strong>.</p>
<p>事实上,如果对于$R <span class="math inline">\(上的一个理想\)</span>I
<span class="math inline">\(,我们容易证明\)</span>I = R I $.</p>
<p>由于这是一个加法子群,所以加法运算肯定是满足的,容易发现如果$I <span class="math inline">\(是\)</span>R <span class="math inline">\(的一个理想,那么\)</span>r , s R , ( r + I ) ( s +
I ) = rs + I $.</p>
<p>类似群中的结构,子环的交仍然是子环,理想的交仍然是理想.于是类似可以定义由$M
R , M <span class="math inline">\(生成的理想\)</span>( M ) <span class="math inline">\(.可由一个元素生成的理想称为**主理想**,可由有限多个元素生成的理想叫做**有限生成理想**.容易发现如果\)</span>R
<span class="math inline">\(是交换环,那么\)</span>( a ) = aR <span class="math inline">\(.不然\)</span>( a ) = RaR $.</p>
<p>既然我们在陪集上保持了环的运算,我们自然可以称$R / I <span class="math inline">\(为\)</span>R <span class="math inline">\(关于\)</span>I <span class="math inline">\(的**商环**,也就是\)</span>R / I = { r + I | r R }
$.必须要说明的是商环本身也是一个环,其加法幺元是$0 + I $,乘法幺元是$1 + I
$.</p>
<p>子环和理想疑似没有对应的符号表示,我们下面不严谨地盗用子群和正规子群的符号(正常情况下好像不让这么干),在不引起混淆的前提下将$(
R , + , ) <span class="math inline">\(简写为\)</span>R $.</p>
<h4><span id="同态和同构">同态和同构</span></h4>
<p>类似群同态和同构,要同时保持两种运算并且需要将乘法幺元映射到对应的乘法幺元.</p>
<p>不过,如果将环同态的定义中的$( ab ) = ( a ) ( b ) <span class="math inline">\(改为\)</span>( ab ) = ( b ) ( a )
$,则称这样的映射为环的<strong>反同态</strong>.</p>
<p>和群略有区别的地方在于如何定义$<span class="math inline">\(,事实上我们一般用加法幺元(因为乘法逆元不一定存在)定义\)</span>=
{ a R | ( a ) = 0 } <span class="math inline">\(.那么\)</span><span class="math inline">\(是单射当且仅当\)</span>= { 0 } $.</p>
<p>类比一下群同态,可以知道对于$: R R _1 <span class="math inline">\(,\)</span> R _1 , R $.</p>
<p>对于前者:由于加法上的性质已经很好了,只需验证其对乘法封闭,这个是好做的.</p>
<p>对于后者:只需验证其封闭且是理想,同样可行.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>也就是$R / $.</p>
<p>设$f : R _1 R _2 <span class="math inline">\(是线性映射,\)</span>I _1
R _1 , I _2 R _2 <span class="math inline">\(并构造两个商映射\)</span>_1
, _2 <span class="math inline">\(,并且\)</span>f ( I _1 ) I _2 <span class="math inline">\(,那么存在唯一的线性映射\)</span>{ f } : R _1 / I
_1 R _2 / I _2 <span class="math inline">\(使得\)</span>f _2 = { f } _1
<span class="math inline">\(.具体地,\)</span>{ f } ( r + I _1 ) = f ( r
) + I _2 $.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表:</p>
<p><span class="math display">\[
\xymatrix { R _1 \ar [r ] ^f \ar [d ] _{ \varphi _1  } &amp; R _2 \ar [r
] ^g \ar [d ] _{ \varphi _2  } &amp; R _3 \ar [d ] _{ \varphi _3  } \\
R _1 / I _1 \ar [r ] ^{ \bar { f  }  } &amp; R _2 / I _2 \ar [r ] ^{
\bar { g  }  } &amp; R _3 / I _3 \\
}
\]</span></p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>设$R <span class="math inline">\(是环,\)</span>I R <span class="math inline">\(,考虑典范同态:\)</span>: R R / I , r r + I
$,那么:</p>
<ol type="1">
<li><p>$R <span class="math inline">\(的包含\)</span>I <span class="math inline">\(的子环与\)</span>R / I <span class="math inline">\(的子环在\)</span>$下一一对应.</p></li>
<li><p>在此对应下,理想对应于理想.</p></li>
<li><p>若$I J R <span class="math inline">\(,则\)</span>R / J ( R / I )
/ ( J / I ) $.</p></li>
</ol>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>设$R <span class="math inline">\(是环,\)</span>I R , S R $,则:</p>
<ol type="1">
<li><p>$I + S R <span class="math inline">\(.\)</span>I S S <span class="math inline">\(.\)</span>I I + S $</p></li>
<li><p>$( I + S ) / I S / ( S I ) $.</p></li>
</ol>
<h4><span id="整环">整环</span></h4>
<p>如果一个交换幺环至少含有两个元素(或说$0 <span class="math inline">\(),且其满足\)</span>xy = 0 x = 0 y = 0
$(或说其没有非零零因子),那么我们称其是一个整环.</p>
<p>显然,整环上对乘法满足左右消去律.原因是$ax = ay a ( x - y ) = 0 $.</p>
<h5><span id="特征">特征</span></h5>
<p>我们之前证明过$
$可以唯一射到任何一个环上,如果这个环是整环,那么其实有更好的性质:</p>
<p>对于任意一个整环$R <span class="math inline">\(,存在唯一一个环的**特征**\)</span> R <span class="math inline">\(使得\)</span>n 1 _R = 0 _R R | n <span class="math inline">\(.我们还可以知道\)</span> R $要么是$0
$要么是素数.</p>
<p>怎么证明呢?考虑如果$ R = ab <span class="math inline">\(,自然有\)</span>ab 1 _R = 0 _R <span class="math inline">\(,于是\)</span>( a 1 _R ) ( b 1 _R ) = 0 _R <span class="math inline">\(,由于这是一个整环,我们当然有\)</span>a 1 _R = 0 _R
b 1 _R = 0 _R R | a R | b $.</p>
<p>如果$R <span class="math inline">\(中有一个整子环\)</span>R _0 <span class="math inline">\(,当然可以发现\)</span> R = R _0 <span class="math inline">\(,于是当然有\)</span> R =   ( R ) $.</p>
<p>另一个性质在于容易发现$ R x = 0 _R $.</p>
<h5><span id="整除性">整除性</span></h5>
<p>$a , b R <span class="math inline">\(,如果\)</span>c R , a = bc <span class="math inline">\(,就称\)</span>b <span class="math inline">\(是\)</span>a <span class="math inline">\(的**因子**,记作\)</span>b | a <span class="math inline">\(.我们可以说明\)</span>b | a ( a ) ( b ) <span class="math inline">\(,因为对于必要性:\)</span>( a ) = aR = bcR bR <span class="math inline">\(,而对于充分性则是因为\)</span>a ( a ) ( b ) $.</p>
<p>如果两个元素互为因子,则称它们<strong>相伴</strong>,暂且用$<span class="math inline">\(代表这种关系.容易验证这等价于\)</span>u R ^, a =
bu <span class="math inline">\(.原因是如果\)</span>u , v R , a = ub , b
= va <span class="math inline">\(,那么\)</span>a = uva <span class="math inline">\(,由消去律得知\)</span>uv = 1 <span class="math inline">\(.此时它们生成的主理想必然相等.相伴关系显然是一种等价关系,\)</span>R
$对于相伴关系的商集上的因子关系是一种偏序关系(但不是全序的).</p>
<p>事实上还可以定义<strong>真因子</strong>:如果$( a ) ( b ) <span class="math inline">\(,那么显然\)</span>b | a <span class="math inline">\(,我们称此时\)</span>b <span class="math inline">\(是\)</span>a <span class="math inline">\(的真因子.容易发现\)</span>b <span class="math inline">\(是\)</span>a <span class="math inline">\(的真因子当且仅当\)</span>b | a <span class="math inline">\(并且\)</span>b <span class="math inline">\(不与\)</span>a $相伴.</p>
<p>称一个元素$a $是<strong>不可约元</strong>,当它不是$0 <span class="math inline">\(也不是单位元而且\)</span>b , c R , a = bc b R ^c R
^{ } <span class="math inline">\(.或者说:\)</span>a = bc c a b a <span class="math inline">\(.或者说\)</span>a $不存在真因子.</p>
<p>称一个元素$a $是<strong>素元</strong>,当它不是$0 <span class="math inline">\(也不是单位元而且\)</span>b , c R , a | bc a | b a
| c $.</p>
<p>我们可以证明:在整环中,素元一定是不可约元,但是不可约元不一定是素元.</p>
<p>如何证明素元一定是不可约元呢?考虑如果$a prime <span class="math inline">\(,并且\)</span>a = bc <span class="math inline">\(,则\)</span>a | bc a | b a | c <span class="math inline">\(,不妨假设\)</span>a | b <span class="math inline">\(,那么设\)</span>b = ad <span class="math inline">\(,自然有\)</span>a = adc <span class="math inline">\(,\)</span>( dc ) = 1 <span class="math inline">\(,于是\)</span>c $.</p>
<h5><span id="唯一分解整环ufd">唯一分解整环(UFD)</span></h5>
<p>称$R <span class="math inline">\(是唯一分解整环,如果\)</span>a R , a
<span class="math inline">\(,都可以将\)</span>a <span class="math inline">\(分解成有限个不可约元的乘积的相伴,也就是可以将\)</span>a
= u _{ k = 1 } ^n p _k <span class="math inline">\(,其中\)</span>u <span class="math inline">\(,\)</span>p <em>k <span class="math inline">\(是不可约元.并且这种分解需要在相伴意义下唯一,也就是如果存在另一种分解\)</span>a
= v </em>{ k = 1 } ^m q _k <span class="math inline">\(,那么需要满足\)</span>n = m <span class="math inline">\(并且可以交换乘积顺序使得\)</span>p _k <span class="math inline">\(和\)</span>q _k $相伴.</p>
<p>我们下面可以证明:在唯一分解整环中,不可约元一定也是素元.</p>
<p>不妨设$a <span class="math inline">\(是不可约元,那么我们要证明\)</span>a | bc a | b a |
c <span class="math inline">\(.考虑设\)</span>ad = bc <span class="math inline">\(,对\)</span>b , c , d <span class="math inline">\(均作唯一分解,那么\)</span>a <span class="math inline">\(会剩下来并且和对面的某个分解出来的不可约元相伴,自然会有\)</span>a
| b a | c $.</p>
<p>在唯一分解整环中可以定义最大公因子.最大公因子当然可能不唯一,但最大公因子之间一定相伴.进一步地,如果最大公因子是可逆元,我们称两个数互素.</p>
<p>当且仅当一个整环有以下两个性质,它是一个唯一分解整环:</p>
<ol type="1">
<li><p>任意不可约元都是素元.</p></li>
<li><p>(存在分解)所有的$r R { 0 } $都能写成有限不可约元的乘积.</p></li>
</ol>
<p>先数学归纳,然后用反证法,假设不成立,那么$r = p _k = q _j $.</p>
<p>接下来任取左边的一个$p _1 <span class="math inline">\(,如果右边也有一个\)</span>q _1 p _1 <span class="math inline">\(就直接消去.反之考虑不可约元也是素元,因此\)</span>p
_1 | q _j <span class="math inline">\(,因此\)</span>j , p _1 | q _j
<span class="math inline">\(,不妨设\)</span>tp _1 = q _j <span class="math inline">\(,因为\)</span>q _j <span class="math inline">\(是不可约元,所以\)</span>t R ^<span class="math inline">\(,所以\)</span>p _1 q _j
$.于是唯一分解性自然得出.</p>
<p>另一种等价条件是:</p>
<ol type="1">
<li><p>任意不可约元都是素元.</p></li>
<li><p>主理想的Noether性质:对于一条主理想的链$( a _1 ) ( a _2 ) <span class="math inline">\(,一定存在一个\)</span>k <span class="math inline">\(,使得从\)</span>k <span class="math inline">\(之后\)</span>( a <em>k ) = ( a </em>{ k + 1 } ) =
$.这条性质也等价于一条因子链一定需要是有限的.</p></li>
</ol>
<p>用主理想的Noether性质直接就可以得出任何一个$r
$都存在有限分解,于是等价于上面那个等价性质.</p>
<p>另外,真实的Noether性质其实是任何一个理想列(不一定是主理想),然而UFD并不一定满足此.最经典的例子是环$
[ x _1 , x _2 , ] <span class="math inline">\(,显然\)</span>( x _1 ) ( x
_1 , x _2 ) $.</p>
<h5><span id="主理想整环pid">主理想整环(PID)</span></h5>
<p>如果一个整环的所有理想都是主理想,则称其为一个主理想整环.交换除环当然是主理想整环的一个典型例子.</p>
<p>需要证明PID一定是UFD,对此,我们考虑:</p>
<p>首先证明PID上的不可约元是素元,这里需要拿出裴蜀定理.然而我们目前不能定义最大公因子的概念,因此退而求其次只定义互素的概念:如果$c
, c | a c | b c R ^<span class="math inline">\(,则称\)</span>a <span class="math inline">\(和\)</span>b $互素.</p>
<p>我们需要证明在主理想整环上有裴蜀定理,换言之如果两个元素互素,那么$x ,
y R , ax + by = 1 <span class="math inline">\(,或者说\)</span>( { a , b
} ) = R <span class="math inline">\(.原因是\)</span>h , ( h ) = ( { a ,
b } ) <span class="math inline">\(,那么此时必有\)</span>h | a h | b
<span class="math inline">\(,于是\)</span>h 1 $.</p>
<p>其次需要证明PID上的Noether性质,注意到一条主理想的链$I _1 I _2 <span class="math inline">\(,直接取\)</span>I = _j I _j <span class="math inline">\(,这个\)</span>I <span class="math inline">\(必然也是理想(乘法封闭性是显然的,加法封闭性的话考虑\)</span>x
I _a , y I <em>b <span class="math inline">\(,\)</span>x + y I </em>{ (
a , b ) } <span class="math inline">\(),那么它就必然是一个主理想,也就是\)</span>h , I =
( h ) <span class="math inline">\(.此时注意到\)</span>k , h I _k <span class="math inline">\(,那么\)</span>I <em>k = I </em>{ k + 1 } = = I
$,这就证毕了.</p>
<p>综上可看出PID一定是UFD.</p>
<p>设$R <span class="math inline">\(为主理想整环,\)</span>t ( R { 0 } )
R ^$.那么以下命题等价:</p>
<ol type="1">
<li><p>$R / ( t ) $是域.</p></li>
<li><p>$R / ( t ) $是整环.</p></li>
<li><p>$t $是素元.</p></li>
</ol>
<p>(1)$<span class="math inline">\((2)当然是平凡的,考虑(2)\)</span>$(3)如何证明:</p>
<p>由于$R / ( t ) <span class="math inline">\(是整环,考虑\)</span>t = ab
<span class="math inline">\(,那么我们有\)</span>( a + ( t ) ) ( b + ( t
) ) = ab + ( t ) = 0 + ( t ) $,由于这是一个整环,这必然意味着:</p>
<p><span class="math display">\[
\begin{aligned}
a + ( t ) &amp; = 0 + ( t ) \lor b + ( t ) &amp; = 0 + ( t ) \\
\Rightarrow t | a \lor t | b \\
\Rightarrow t \sim a \lor t \sim b
\end{aligned}
\]</span></p>
<p>因此$t <span class="math inline">\(是不可约元,因此\)</span>t
$是素元.</p>
<p>接下来考虑(3)$<span class="math inline">\((1),只需证明非零元\)</span>a + ( t ) <span class="math inline">\(均可逆即可.考虑主理想整环上的裴蜀定理,存在\)</span>x
, y <span class="math inline">\(使得\)</span>ax = 1 - yt <span class="math inline">\(,此时\)</span>x + ( t ) <span class="math inline">\(就是\)</span>a + ( t ) $的逆元.</p>
<p>还可进一步扩展裴蜀定理,容易证明在主理想环中$( { r _1 , , r _n } ) = (
r _1 , , r _n ) R $.</p>
<p>事实上还可以在这里拿出拓展版的中国剩余定理,具体地,如果$a _1 , , a _n
R { 0 } <span class="math inline">\(,并且它们两两互素,取\)</span>a = a
<em>k <span class="math inline">\(,那么我们事实上有环同构\)</span>: R /
( a ) </em>{ k = 1 } ^n R / ( a _k ) , r + ( a ) ( r + ( a <em>i ) )
</em>{ k = 1 } ^n $.</p>
<p>用数学归纳只需证明$n = 2 $的情形就可以了.</p>
<p>先证明$<span class="math inline">\(是单射,观察\)</span><span class="math inline">\(,如果\)</span>( r + ( a ) ) = ( 0 + ( a _1 ) , 0 +
( a _2 ) ) <span class="math inline">\(自然意味着\)</span>a _1 | r , a
_2 | r a | r <span class="math inline">\(,于是\)</span>r + ( a ) = 0 + (
a ) <span class="math inline">\(,这立刻得到\)</span>$是单射.</p>
<p>再证明$<span class="math inline">\(是满射,用裴蜀定理容易取\)</span>x
_1 , x _2 R <span class="math inline">\(使得\)</span>a _1 x _1 + a _2 x
_2 = 1 <span class="math inline">\(,那么\)</span>ra _1 x _1 + ra _2 x _2
= r <span class="math inline">\(,此时注意到\)</span>( ra _1 x _1 + ( a )
) = ( 0 + ( a _1 ) , r + ( a _2 ) ) <span class="math inline">\(,\)</span>( ra _2 x _2 + ( a ) ) = ( r + ( a _1 )
, 0 + ( a _2 ) )
$.这样就可以看出其满性.其实这当然也是中国剩余定理在整数上的构造的类似版本.</p>
<h3><span id="多项式环">多项式环</span></h3>
<h4><span id="一元多项式环">一元多项式环</span></h4>
<p>一个系数属于特定非零环$R <span class="math inline">\(的一元多项式定义为系数在\)</span>R <span class="math inline">\(上的一元多项式环,记作\)</span>R [ x ] <span class="math inline">\(,注意到如果\)</span>R <span class="math inline">\(是整环,\)</span>R [ x ] <span class="math inline">\(仍然是整环.多元多项式环可以不断在多元多项式环上定义一元多项式环.不妨将一个多项式记作\)</span>f
( x ) <span class="math inline">\(.另外如果我们记\)</span>R ^{ } <span class="math inline">\(为\)</span>R <span class="math inline">\(中可逆元素的集合,那么显然\)</span>R [ x ] ^{ } = R
^{ } $.</p>
<p>一般而言,我们下面默认讨论$R $是整环的情况.</p>
<p>在多项式环上可以定义最高次数函数$<span class="math inline">\(,容易验证\)</span>( fg ) = f + g , ( f + g ) { f ,
g } <span class="math inline">\(,可定义\)</span> = - $.</p>
<p>整环上的多项式有长除法和取模运算,也就是对于任意多项式$f
$,以及最高项系数为$1 <span class="math inline">\(的多项式\)</span>d
<span class="math inline">\(,存在唯一一组\)</span>q , r <span class="math inline">\(满足\)</span>f = dq + r <span class="math inline">\(并且\)</span>r <span class="math inline">\(最小.这样还可以定义整除也就是当\)</span>r = 0
$的时候.</p>
<p>长除法的正确性可以反证,如果存在两组,那么自然有$d ( q _1 - q _2 ) = r
_2 - r _1 <span class="math inline">\(,如果\)</span>q _1 q _2 <span class="math inline">\(,那么\)</span>( q _1 - q _2 ) <span class="math inline">\(,那么\)</span>d ( q _1 - q _2 ) d <span class="math inline">\(,但是\)</span>( r _2 - r _1 ) &lt; d <span class="math inline">\(,这样的话等式就不能成立了.因此必定有\)</span>q _1
= q _2 , r _1 = r _2 $.</p>
<p>这就可以保证代入数值操作.因为我们考虑存在唯一的多项式$q <span class="math inline">\(和唯一一个\)</span>s R <span class="math inline">\(满足\)</span>f = ( x - ) q + s <span class="math inline">\(,那我们就可以称\)</span>f ( ) = s $.</p>
<p>另外,定义在域$F <span class="math inline">\(上的多项式\)</span>F [ x
] $是UFD,原因是可以两边对某一个根作长除法.</p>
<h4><span id="多元多项式环">多元多项式环</span></h4>
<p>显然,$R [ x _1 , , x _n ] ( R [ x <em>1 , , x </em>{ n - 1 } ] ) [ x
_n ] $.</p>
<h4><span id="不可约多项式">不可约多项式</span></h4>
<p>不可约多项式,也就是定义在域上的多项式环上的不可约元.换言之如果$f
<span class="math inline">\(是不可约的,那么对于\)</span>f <span class="math inline">\(的任何一个分解\)</span>f = g _1 g _2 <span class="math inline">\(,都一定有\)</span>g _1 F ^<span class="math inline">\(或者\)</span>g _1 F ^$.</p>
<h5><span id="本原多项式">本原多项式</span></h5>
<p>为何我们定义不可约多项式的时候需要定义在域上,而不是简单定义在整环上呢?这是因为,例如,$2
x [ x ] <span class="math inline">\(,它并非是一个不可约元.但只要把\)</span> <span class="math inline">\(扩成\)</span> $,它就成为了一个不可约元.</p>
<p>那么在整数上怎么搞呢?我们考虑设$f = a _0 + + a _n x ^n [ x ] { 0 }
<span class="math inline">\(,并设\)</span>c ( f ) = | ( a _0 , , a _n )
| <span class="math inline">\(,如若\)</span>c ( f ) = 1
$,则称其是一个<strong>本原多项式</strong>.</p>
<p>接下来我们有<strong>高斯引理</strong>:如果$g , h [ x ] <span class="math inline">\(都是本原多项式,那么\)</span>gh
$也是本原多项式.</p>
<p>如何证明?考虑对于任何一个素数$p <span class="math inline">\(,我们找到\)</span>g <span class="math inline">\(中的最高次系数不被\)</span>p <span class="math inline">\(整除,设为\)</span>r <span class="math inline">\(.换言之设\)</span>g = _{ k } a _k x ^k <span class="math inline">\(,则\)</span>k &gt; r , p | a _k <span class="math inline">\(,而\)</span>p a <em>r <span class="math inline">\(.对\)</span>f = </em>{ k } b _k x ^k <span class="math inline">\(同样根据上面找到一个最高次\)</span>s <span class="math inline">\(,满足\)</span>p b _s $.</p>
<p>现在观察:</p>
<p><span class="math display">\[
\begin{aligned}
[ x ^{ r + s  } ] gh \\
&amp; = \sum _{ i + j = r + s  } a _i b _j &amp; \equiv a _r b _s \pmod
{ p  } \\
\ne 0 \pmod { p  }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>另一个证明策略是干脆把$ / p
$,后者是一个域,于是可以见到其非零.其实和上面是同一个想法,也许后者在做完映射后更好描述.</p>
<p>高斯引理的推论是$c ( gh ) = c ( g ) c ( h ) $.</p>
<p>接下来我们来搞一些$ <span class="math inline">\(上的结构,我们下面来证明,对于本原多项式来说,只要其在\)</span>
[ x ] <span class="math inline">\(上可约,那它就在\)</span> [ x ] <span class="math inline">\(上可约.换言之,假设\)</span>f { 0 } <span class="math inline">\(是本原多项式,如果\)</span>f = gh <span class="math inline">\(,其中\)</span>g , h [ x ] , g &gt; 0 , h &gt; 0
<span class="math inline">\(,那我们断言\)</span> ^<span class="math inline">\(使得\)</span>g _1 = g , h _1 = ^{ - 1 } h <span class="math inline">\(使得\)</span>g _1 , h _1 [ x ]
$且它们都是本原多项式.</p>
<p>考虑总存在一对$u , v _+ <span class="math inline">\(使得\)</span>ug ,
vh [ x ] $,此时有:</p>
<p><span class="math display">\[
uv = c ( uvf ) = c ( ugvh ) = c ( ug ) c ( vh )
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
f = \frac { ugvh  } { uv  } = \frac { ug  } { c ( ug )  } \frac { vh  }
{ c ( vh )  }
\]</span></p>
<p>这就搞定.</p>
<p>还有一条性质是说,假设$f { 0 } <span class="math inline">\(是本原多项式,当\)</span>f &gt; 0
$的时候,下面两个命题等价:</p>
<ol type="1">
<li><p>$f <span class="math inline">\(是\)</span> [ x ]
$上的不可约多项式.</p></li>
<li><p>$f <span class="math inline">\(是\)</span> [ x ]
$上的不可约多项式.</p></li>
</ol>
<p>(1)$<span class="math inline">\((2)的话考虑反证,如若存在\)</span> [ x
] <span class="math inline">\(上的\)</span>g , h <span class="math inline">\(使得\)</span>f = gh <span class="math inline">\(,那\)</span>f <span class="math inline">\(在\)</span> [ x ] <span class="math inline">\(上都可约,当然在\)</span> [ x ] $上可约.</p>
<p>(2)$<span class="math inline">\((1)的话仍然考虑反证,如果存在\)</span>
[ x ] <span class="math inline">\(上的\)</span>g , h <span class="math inline">\(使得\)</span>f = gh <span class="math inline">\(,那之前的推论告诉我们\)</span>f
$可以分解为两个本原多项式的乘积,这就矛盾了.</p>
<p>接下来我们证明$ [ x ] <span class="math inline">\(是一个UFD,在此之前,我们先对\)</span> [ x ]
$上的不可约元做分类,我们断言其分为以下两种:</p>
<ol type="1">
<li><p>$ $的不可约元.</p></li>
<li><p>$f &gt; 0 <span class="math inline">\(并且满足\)</span>f <span class="math inline">\(作为\)</span> [ x ] <span class="math inline">\(上的不可约元的本原多项式\)</span>f $.</p></li>
</ol>
<p>首先$f = 0 <span class="math inline">\(的情况自然是(1),下面尝试分类\)</span>f &gt; 0
$的情况.</p>
<p>如若$c ( f ) <span class="math inline">\(,当然有\)</span>f = c ( f )
{ c ( f ) } <span class="math inline">\(,因此可约.所以不可约当且仅当\)</span>c ( f ) = 1
<span class="math inline">\(,也就是\)</span>f <span class="math inline">\(得是一个本原多项式.那就知道其不可约性可以从\)</span>
[ x ] <span class="math inline">\(过渡到\)</span> [ x ] $上.</p>
<p>最终我们来说明$ [ x ]
$是唯一分解的,首先可以提系数使得只对本原多项式说明唯一分解性.</p>
<p>既然如此,考虑如果$f <span class="math inline">\(可以被分解为两种\)</span>a _1 a _r <span class="math inline">\(和\)</span>b _1 b _s <span class="math inline">\(两种,它们都是本原多项式,乘积后亦然,其中\)</span>a
_i , b _i <span class="math inline">\(均满足\)</span>&gt; 0 <span class="math inline">\(,那么直接扩域到\)</span> [ x ] <span class="math inline">\(上,由于定义在域上的多项式有唯一分解行,因此\)</span>s
= r <span class="math inline">\(而且适当重排后\)</span>a _i <span class="math inline">\(和\)</span>b _i <span class="math inline">\(差了一个\)</span> ^<span class="math inline">\(,然而两个本原多项式如果差了一个\)</span>
^$,当然意味着它俩只差一个正负号,这是显然的,就给出了分解的唯一性.</p>
<p>接下来有<strong>Eisenstein判准</strong>,不妨设$n <span class="math inline">\(,而\)</span>f = _{ k = 0 } ^n a _k x ^k [ x ]
<span class="math inline">\(,如果存在一个素数\)</span>p <span class="math inline">\(满足\)</span>p a _n <span class="math inline">\(,而且\)</span>p | a <em>0 , , a </em>{ n - 1 }
<span class="math inline">\(,并且\)</span>p ^2 a _0 <span class="math inline">\(,则\)</span>f <span class="math inline">\(是\)</span> [ x ] $中的不可约多项式.</p>
<p>为证明此,考虑既然$p a _n <span class="math inline">\(,那当然\)</span>p c ( f ) <span class="math inline">\(,因此,我们可以将\)</span>f <span class="math inline">\(调整为\)</span> { c ( f ) } <span class="math inline">\(,这并不会对\)</span>p <span class="math inline">\(的性质产生影响,而可以将\)</span>f
$化约成本原多项式的情形.</p>
<p>如何证明呢?考虑反证,对本原多项式来说$ [ x ] <span class="math inline">\(上不可约等价于在\)</span> [ x ] <span class="math inline">\(上不可约,假设此情形下\)</span>f = gh <span class="math inline">\(,其中\)</span>g = _{ k = 0 } ^m b <em>k x ^k , h =
</em>{ k = 0 } ^l c _k x ^k <span class="math inline">\(,其中\)</span>l
, m &gt; 0 <span class="math inline">\(,而且\)</span>g , h [ x ] $.</p>
<p>既如此,注意到$a _n = b _m c _l <span class="math inline">\(,因此一定有\)</span>p b _m , p c _l <span class="math inline">\(.而又有\)</span>p | a _0 = b _0 c _0 <span class="math inline">\(,不妨假设\)</span>p | b _0 $.此时,可以取一个$1 k m
<span class="math inline">\(,使得\)</span>p | b <em>0 , , p | b </em>{ k
- 1 } <span class="math inline">\(但是有\)</span>p b _k $,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
a _k &amp; \equiv 0 \pmod { p  } \\
\sum _{ j = 0  } ^k b _j c _{ k - j  } &amp; \equiv 0 \pmod { p  } \\
b _k c _0 &amp; \equiv 0 \pmod { p  }
\end{aligned}
\]</span></p>
<p>所以$p | c _0 <span class="math inline">\(,所以\)</span>p ^2 | a _0 =
b _0 c _0 $,矛盾.</p>
<p>我们可以在此基础上证明一些有趣的结论:</p>
<ol type="1">
<li><p>$n <span class="math inline">\(,\)</span>p <span class="math inline">\(是质数,则\)</span>p + x ^n $是不可约的.</p></li>
<li><p>$p <span class="math inline">\(是质数,则\)</span>_p = 1 + x + + x
^{ p - 1 } = { x - 1 } $是不可约的.</p></li>
</ol>
<p>对于(2),考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\Phi _p &amp; = \frac { x ^p - 1  } { x - 1  } \\
&amp; = \frac { ( x - 1 + 1 ) ^p - 1  } { x - 1  } \\
&amp; = \frac { \sum _{ k = 0  } ^p \binom { p  } { k  } ( x - 1 ) ^k -
1  } { x - 1  } \\
&amp; = \sum _{ k = 1  } ^p \binom { p  } { k  } ( x - 1 ) ^{ k - 1  }
\end{aligned}
\]</span></p>
<p>取$h ( x ) = _{ k = 1 } ^p { k } x ^{ k - 1 } <span class="math inline">\(,则\)</span>_p ( x ) = h ( x - 1 ) <span class="math inline">\(,显然,二者的不可约性是等价的,下面观察\)</span>h (
x ) <span class="math inline">\(的不可约性.然而\)</span>h ( x )
$当然满足Eisenstein判准,这就搞定.</p>
<p>这里可以见到,其实上面的过程可以全部挪到某个UFD以及与其配套的分式域上,均可以起效果.而且也可以看到在某一个UFD上定义的多项式环也一定是UFD.</p>
<h5><span id="一个判定不可约的算法">一个判定不可约的算法</span></h5>
<p>考虑判定一个$f <span class="math inline">\(是否可以被拆成两个\)</span>f = gh <span class="math inline">\(,并且它们都在\)</span> [ x ] <span class="math inline">\(上,其中\)</span>g k $.</p>
<p>如何判断呢?首先我们任取不同的$x _0 , , x _k <span class="math inline">\(,并取\)</span>f ( x _0 ) , , f ( x _k )
$,如果它们中有$0 <span class="math inline">\(就完工了对吧.如果没有,我们一定有\)</span>g ( x _i
) | f ( x _i ) <span class="math inline">\(,因此\)</span>g ( x _i )
<span class="math inline">\(只有有限种可能性.我们枚举所有的可能性并插值判\)</span>g
$.这就给出了一个有限次实现的算法.</p>
<h5><span id="不可约多项式上的扩域">不可约多项式上的扩域</span></h5>
<p>如果域$F <span class="math inline">\(上的多项式\)</span>f F [ x ]
$可以分解为若干个一次多项式的乘积,则称其可<strong>分裂</strong>.</p>
<p>那么如果定义在一个域上的每个$
$的多项式都分裂,那么就称这个域是<strong>代数闭</strong>的.</p>
<p>定义在域$F <span class="math inline">\(上的多项式未必有根,但理应在其上面可以做扩域使其有根.具体而言我们对于域\)</span>F
<span class="math inline">\(,想要找到一个单同态\)</span>: F L <span class="math inline">\(使得\)</span>L <span class="math inline">\(是一个更大的域.而应当见到\)</span>L <span class="math inline">\(实际上在某种意义上是定义在\)</span>F
$上的向量空间.</p>
<p>在这里需要发现的是,定义在域上的$F [ x ] <span class="math inline">\(一定是主理想整环,原因是可以在理想\)</span>I <span class="math inline">\(中取出\)</span><span class="math inline">\(最小的一个非零的\)</span>f <span class="math inline">\(,那么其中的任何一个\)</span>g I <span class="math inline">\(,用带余除法立刻得到\)</span>g = pf + r <span class="math inline">\(,其中\)</span>r &lt; f , r I <span class="math inline">\(,必然得到\)</span>r = 0 <span class="math inline">\(.这意味着\)</span>I = ( f ) <span class="math inline">\(.同时容易见到\)</span>f = 0 <span class="math inline">\(的时候,\)</span>( f ) = F [ x ] $.</p>
<p>我们尝试研究$F [ x ] / ( f ) <span class="math inline">\(的形态,那么见到\)</span>f <span class="math inline">\(的时候这个形态应当才是有意义的.构造一个同态\)</span>:
F F [ x ] / ( f ) , a a + ( f ) <span class="math inline">\(,容易见到\)</span><span class="math inline">\(应当是一个单射,原因是在\)</span>f <span class="math inline">\(的前提下,有\)</span>= { 0 } <span class="math inline">\(.此时应当见到\)</span>F [ x ] / ( f ) <span class="math inline">\(可以看作一个定义在\)</span>F <span class="math inline">\(上的向量空间.而运用代余除法得知\)</span>{ 1 + ( f
) , x + ( f ) , , x ^{ f - 1 } + ( f ) } <span class="math inline">\(显然给出了\)</span>F [ x ] / ( f ) $的一组基.</p>
<p>在此基础上,若$f = a _k x ^k <span class="math inline">\(,定义\)</span>f ^= ( a _k ) ( x ) ^k $.</p>
<p>由于$F [ x ] <span class="math inline">\(是主理想环,我们在之前已经证明过了当\)</span>f
<span class="math inline">\(不可约的时候,\)</span>F [ x ] / ( f ) <span class="math inline">\(是一个域,令\)</span>E = F [ x ] / ( f ) <span class="math inline">\(.回到我们一开始的目的.当\)</span>f <span class="math inline">\(,并且\)</span>f <span class="math inline">\(在\)</span>F [ x ] <span class="math inline">\(环上不可约的时候,若令\)</span>= x + ( f ) <span class="math inline">\(,此时\)</span><span class="math inline">\(应作为一个\)</span>E $上的元素,注意到此时:</p>
<p><span class="math display">\[
\begin{aligned}
f ^\tau ( x + ( f ) ) \\
&amp; = \sum ( a _k + ( f ) ) ( x + ( f ) ) ^k \\
&amp; = \sum a _k x ^k + ( f ) \\
&amp; = f + ( f ) &amp; = 0 + ( f )
\end{aligned}
\]</span></p>
<p>这意味着在$E [ X ] <span class="math inline">\(上\)</span>f ^<span class="math inline">\(是一个可约的多项式,因为提供了其一个元素\)</span>E
$作为其的一个零点.</p>
<p>从上面的过程来看,我们理应可以通过若干次扩张使得一个$f <span class="math inline">\(在某个\)</span>E _r [ X ] <span class="math inline">\(上是分裂的,其中\)</span>r f
$,也即每一次扩域次数都至少降低$1 $.</p>
<p>我们应当思考这个域扩大了多少,见到如果$f = n <span class="math inline">\(,我们一开始已经声明过此时选取基的大小,自然得到\)</span>[
E _r : F ] = [ E <em>r : E </em>{ r - 1 } ] n ! $.</p>
<p>不过我们理应简单说明这样的构造是泛的,具体来讲,我们已经声明过我们需要构造一个交换环$L
<span class="math inline">\(并将\)</span>F <span class="math inline">\(以环同态\)</span>: F L <span class="math inline">\(的形式嵌入其中,并在环\)</span>L <span class="math inline">\(中找到一个\)</span>L <span class="math inline">\(使得\)</span>f ^( ) = 0 <span class="math inline">\(,那么此时应当存在一个唯一的环同态\)</span>: E L
<span class="math inline">\(使得\)</span>( ) =
$,并且下面是一个交换图表:</p>
<p><span class="math display">\[
\xymatrix { E \ar [r ] ^\psi &amp; L \\
F \ar [u ] ^\tau \ar [ru ] _\varphi  }
\]</span></p>
<p>考察商同态$: F [ x ] E = F [ x ] / ( f )
$,将此关系嵌入上述图表应当得到上述图表交换的等价条件是下述图表交换:</p>
<p><span class="math display">\[
\xymatrix { F [ x ] \ar [r ] ^\pi &amp; E \ar [r ] ^\psi &amp; L \\
&amp; F \ar [ul ] \ar [u ] ^\tau \ar [ru ] _\varphi  }
\]</span></p>
<p>直接令$= $,上图可以简化为:</p>
<p><span class="math display">\[
\xymatrix { F [ x ] \ar [rr ] ^\Psi &amp; &amp; L \\
&amp; F \ar [ul ] \ar [ru ] _\varphi  }
\]</span></p>
<p>现在观察此结构,若我们一开始的假设成立,此图表的确交换并且满足求值同态$(
x ) = ( ( x ) ) = ( ) = <span class="math inline">\(,那么对于一般的多项式\)</span>g = b _k x ^k <span class="math inline">\(,立刻得到\)</span>( g ) = ( b _k ) ^n = g ^( )
<span class="math inline">\(,这立刻得到了\)</span>$的唯一性,而直接使用此同态容易证明其存在性.</p>
<p>这个交换图表有什么用呢?来看其在复数上的表现情况.取$F = <span class="math inline">\(并且\)</span>f = x ^2 + 1 <span class="math inline">\(,此时\)</span>- 1 <span class="math inline">\(自然出现了平方根\)</span>= x + ( x ^2 + 1 ) <span class="math inline">\(.此时在上述图表中只需简单规定\)</span>i <span class="math inline">\(具体的正负取值立刻得到一个\)</span> [ x ] / ( x ^2
+ 1 ) $的同构.</p>
<h4><span id="对称多项式">对称多项式</span></h4>
<p>将置换的定义,挪到多元多项式环上,具体而言,$f ( x <em>1 , , x <em>n ) =
f ( x </em>{ ( 1 ) } , , x </em>{ ( n ) } ) $.</p>
<p>那么,如果带$n <span class="math inline">\(个变元的多项式\)</span>f
<span class="math inline">\(其对任意置换都不变,换言之\)</span>, f = f
$,则称其是一个<strong>对称多项式</strong>.</p>
<p>我们记$F [ x _1 , , x _n ] ^S <span class="math inline">\(为所有在域\)</span>F <span class="math inline">\(上定义的\)</span>n <span class="math inline">\(个变元的对称多项式组成的集合,其当然是\)</span>F [
x _1 , , x _n ] <span class="math inline">\(上的一个子环,因为如果\)</span>f , g <span class="math inline">\(对称,那么\)</span>fg <span class="math inline">\(和\)</span>f + g
$亦然.从这里也可以见到其还是一个线性空间.</p>
<p>接下来定义$e <em>k = </em>{ 1 i _1 &lt; &lt; i <em>k n } x </em>{ i
<em>1 } x </em>{ i _k } <span class="math inline">\(为第\)</span>k <span class="math inline">\(个**初等对称多项式**,例如\)</span>e _n = x _1 x _n
, e _1 = x _1 + + x <em>n <span class="math inline">\(.并且还见到**Vieta公式**:\)</span></em>{ k = 1 }
^n ( y + x <em>k ) = </em>{ k = 0 } ^n e <em>k y ^{ n - k } <span class="math inline">\(或写作\)</span></em>{ k = 1 } ^n ( y - x <em>k ) =
</em>{ k = 0 } ^n ( - 1 ) ^k e _k y ^{ n - k } $</p>
<p>接下来我们要证明<strong>对称多项式基本定理</strong>,$f F [ x _1 , , x
_n ] ^S , g F [ x _1 , , x _n ] , f = g ( e _1 , , e _n ) $.</p>
<p>接下来我们定义$f <em>d = </em>{ i _1 + + i <em>n = d } c </em>{ i _1
, , i _n } x _1 ^{ i _1 } x _n ^{ i _n } <span class="math inline">\(为\)</span>d <span class="math inline">\(**齐次多项式**,容易见到任何一个多项式都可以写成若干齐次多项式之和.定义\)</span>f
$为它分解出来的最大的可能非零齐次多项式的次数.</p>
<p>接下来我们证明一个引理:对于$f F [ x _1 , , x _n ] ^S <span class="math inline">\(,则\)</span>f ( x <em>1 , , x </em>{ n - 1 } , 0 )
= 0 <span class="math inline">\(的充分必要条件是\)</span>e _n | f $.</p>
<p>充分性显然,因为$x _n | e _n $.</p>
<p>必要性的话,如若$f ( x <em>1 , , x </em>{ n - 1 } , 0 ) = _{ i <em>n =
0 } c </em>{ i _1 , , i <em>n } x <em>1 ^{ i <em>1 } x </em>{ n - 1 } ^{
i </em>{ n - 1 } } = 0 <span class="math inline">\(,这也就意味着\)</span>c </em>{ i _1 , , i _n } i
<em>n <span class="math inline">\(,而由于对称,意味着\)</span>c </em>{ i
_1 , , i _n } i _k <span class="math inline">\(,这就说明了\)</span>e _n
| f $.</p>
<p>对$n <span class="math inline">\(元对称多项式\)</span>h <span class="math inline">\(,记\)</span>h ^b = h ( x <em>1 , , x </em>{ n - 1
} , 0 ) <span class="math inline">\(,观察到\)</span>h ^b <span class="math inline">\(当然是\)</span>n - 1 <span class="math inline">\(次多项式,而且\)</span>e <em>1 ^b , , e </em>{ n -
1 } ^b $正好是第$1 , , n - 1 <span class="math inline">\(个初等\)</span>n - 1 $元对称多项式.</p>
<p>继续考虑证明对称多项式基本定理,首先对于$f = f _d <span class="math inline">\(来说,\)</span>f <span class="math inline">\(是对称的当然等价于每一个\)</span>f _d <span class="math inline">\(都是对称的,所以我们下面不妨假设\)</span>f = f _d
$.</p>
对于一个$g F [ x _1 , , x _n ] <span class="math inline">\(,定义其权重为\)</span>wt ( g ) =
<span class="math display">\[\begin{cases}\max \{ \sum _{ k = 1  } ^n k
i _k \mid c _{ i _1 , \cdots , i _n  } \ne 0 \} &amp; g \ne 0 \\ -
\infty &amp; g = 0 \end{cases}\]</span>
<p>$.</p>
<p>容易见到$g ( e _1 , , e _n ) wt ( g )
$,这恰也是我们如此定义权重的原因.</p>
<p>下面我们证明:如果$f <span class="math inline">\(是\)</span>d <span class="math inline">\(次齐次的,则断言中的\)</span>g <span class="math inline">\(不仅存在还能取到\)</span>wt ( g ) d <span class="math inline">\(.下面我们对\)</span>n + d $递归地论证.</p>
<p>当$d = 0 , f F <span class="math inline">\(当然是平凡的,下面设\)</span>d <span class="math inline">\(.由于数学归纳,我们知道\)</span>f ^b
$的元数量减少了$1 $.</p>
<p>当$f ^b <span class="math inline">\(时,那么如果\)</span>f <span class="math inline">\(是\)</span>d <span class="math inline">\(齐次的,容易见到\)</span>f ^b <span class="math inline">\(也该是\)</span>d <span class="math inline">\(齐次的,那此时数学归纳给出存在\)</span>g _1 F [ x
<em>1 , , x </em>{ n - 1 } ] <span class="math inline">\(使得\)</span>f
^b = g _1 ( e <em>1 ^b , , e </em>{ n - 1 } ^b ) <span class="math inline">\(,而且\)</span>g _1 ( e <em>1 , , e </em>{ n - 1 }
) wt ( g _1 ) d $.</p>
<p>此时设$f _1 = f - g _1 ( e <em>1 , , e </em>{ n - 1 } ) <span class="math inline">\(,立刻见到\)</span>f _1 ^b = 0 <span class="math inline">\(,那么\)</span>e _n | f _1 <span class="math inline">\(,取\)</span>f _2 = { e _n } <span class="math inline">\(,这里就可以看到如若\)</span>f ^b = 0 <span class="math inline">\(,这里直接取\)</span>f _1 = f , g _1 = 0
$即可.所以上述讨论在这一步就消掉了.</p>
<p>于是,这里的$f _2 <span class="math inline">\(当然也是对称多项式,并且\)</span>f _2 d - n <span class="math inline">\(,那将其分解为齐次部分的和,运用递归假设知道存在\)</span>f
_2 = g _2 ( e _1 , , e _n ) , wt ( g _2 ) d - n $.此时:</p>
<p><span class="math display">\[
\begin{aligned}
f &amp; = f _1 + g _1 ( e _1 , \cdots , e _{ n - 1  } ) \\
&amp; = e _n g _2 ( e _1 , \cdots , e _n ) + g _1 ( e _1 , \cdots , e _{
n - 1  } )
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<p>另一个问题是,上述算法只搞定了$f = g ( e _1 , , e _n ) <span class="math inline">\(的存在性,它是否有唯一性呢?如若有\)</span>g ( e _1
, , e _n ) = h ( e _1 , , e _n ) <span class="math inline">\(,则\)</span>( g - h ) ( e _1 , , e _n ) = 0 <span class="math inline">\(.我们应当证明以下定理,称为\)</span>e _1 , , e _n
$的<strong>代数无关性</strong>:</p>
<p>若$g F [ x _1 , , x _n ] <span class="math inline">\(满足\)</span>g (
e _1 , , e _n ) = 0 <span class="math inline">\(,则\)</span>g = 0 $.</p>
<p>考虑证明其逆否命题,也就是$g <span class="math inline">\(的话就一定有\)</span>g ( e _1 , , e _n ) $.</p>
<p>首要的观察是先扩域,如果这个定义在更大的域上满足,在更小的域上当然也满足.因此可以先一步将$F
<span class="math inline">\(扩到一个无穷域上,例如直接将其扩到有理分式域\)</span>F
( t ) <span class="math inline">\(上.下面假设\)</span>F <span class="math inline">\(是无穷域.则此时对于任意有限次数非零多项式\)</span>g
= 0 <span class="math inline">\(,一定存在一组\)</span>( y _1 , , y _n )
<span class="math inline">\(使得\)</span>g ( y _1 , , y _n ) <span class="math inline">\(,这是因为可以数学归纳,当\)</span>n = 1 <span class="math inline">\(的时候,其最多只有\)</span>g <span class="math inline">\(个根但是\)</span>F <span class="math inline">\(无限,因此肯定存在.当\)</span>n &gt; 1 <span class="math inline">\(的时候,直接取\)</span>g = g _k x _n ^k <span class="math inline">\(,那么由归纳假设一定存在一组\)</span>( y <em>1 , y
</em>{ n - 1 } ) <span class="math inline">\(使得至少有一个\)</span>g _k
<span class="math inline">\(,此时再由\)</span>n = 1
$的结论就可以知道原命题成立.</p>
<p>接下来考虑$p = _{ k = 0 } ^n x ^{ n - k } ( - 1 ) ^k y <em>k <span class="math inline">\(,回忆到可以扩域使得该多项式分裂,假设分裂成了\)</span>p
= </em>{ k = 1 } ^n ( x - x <em>i ) <span class="math inline">\(,此时由于Vieta公式,\)</span>p = </em>{ k = 0 } ^n
( - 1 ) ^k e _k ( x _1 , , x _n ) x ^{ n - k } <span class="math inline">\(,于是\)</span>e _k ( x _1 , , x _n ) = y _k <span class="math inline">\(,这就导出了\)</span>g ( e _1 , , e _n ) = g ( y _1
, , y _n ) $.</p>
<p>容易见到上述论证不涉及域中的除法,所以上述结论对整环也是成立的.</p>
<h5><span id="牛顿公式">牛顿公式</span></h5>
<p>设$p <em>k = </em>{ j = 1 } ^n x _j ^k <span class="math inline">\(,这里的\)</span>p _0 <span class="math inline">\(其实比较特殊,我们一般不去讨论\)</span>p _0
$.那么牛顿公式说:</p>
<ol type="1">
<li><p>当$1 k n <span class="math inline">\(的时候,\)</span>_{ j = 0 }
^{ k - 1 } ( - 1 ) ^j e <em>j p </em>{ k - j } = ( - 1 ) ^{ k - 1 } k e
_k $.</p></li>
<li><p>当$k &gt; n <span class="math inline">\(的时候,\)</span>_{ j = 0
} ^n ( - 1 ) ^j e <em>j p </em>{ k - j } = 0 $.</p></li>
</ol>
<p>牛顿公式的一个相当大的作用是可以用递归的方式用${ e _k } <span class="math inline">\(和\)</span>{ p _k } <span class="math inline">\(相互表示.更进一步地,可以用\)</span>{ e _k } <span class="math inline">\(的整系数多项式表示\)</span>{ p _k } <span class="math inline">\(也可以用\)</span>{ p _k } <span class="math inline">\(的有理系数多项式表示\)</span>{ e _k } <span class="math inline">\(,当然对应的域要包含\)</span> <span class="math inline">\(和\)</span> $.</p>
<p>如何证明上面那个结论?考虑以$y $为变元的形式幂级数,定义:</p>
<p><span class="math display">\[
\begin{aligned}
P ( y ) &amp; = \sum _{ k \geq 1  } p _k y ^{ k - 1  } \\
&amp; = \sum _{ k \geq 1  } \sum _{ i = 1  } ^n x _i ^k y ^{ k - 1  } \\
&amp; = \sum _{ i = 1  } ^n \frac { x _i  } { 1 - x _i y  }
\end{aligned}
\]</span></p>
<p>再定义:</p>
<p><span class="math display">\[
\begin{aligned}
E ( y ) &amp; = \sum _{ k = 0  } ^n e _k y ^k \\
&amp; = \prod _{ i = 1  } ^n ( 1 + x _i y )
\end{aligned}
\]</span></p>
<p>接下来观察到:</p>
<p><span class="math display">\[
\begin{aligned}
P ( - y ) &amp; = \sum _{ i = 1  } ^n \frac { x _i  } { 1 + x _i y  } \\
&amp; = \frac { \mathrm { d  }  } { \mathrm { d  } y  } \ln E ( y ) \\
&amp; = \frac { E &#39; ( y )  } { E ( y )  }
\end{aligned}
\]</span></p>
<p>接下来观察:</p>
<p><span class="math display">\[
\begin{aligned}
E ( y ) P ( - y ) &amp; = E &#39; ( y ) \\
&amp; = \sum _{ k = 1  } ^n k e _k y ^{ k - 1  }
\end{aligned}
\]</span></p>
<p>可是左边直接展开就有:</p>
$$
<span class="math display">\[\begin{aligned}
E ( y ) P ( - y ) &amp; = ( \sum _{ l = 0  } ^n e _l ( - y ) ^l ) ( \sum
_{ j \geq 1  } p _j y ^{ j - 1  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边提取$[ y ^{ k - 1 } ] $,就有:</p>
<p><span class="math display">\[
\sum _{ l + j = k , 0 \leq l \leq n , j \geq 1  } e _l p _{ j  } ( - 1 )
^{ j - 1  } = k e _k
\]</span></p>
<p>两边倒腾一下正负号就是牛顿公式.</p>
<h4><span id="结式">结式</span></h4>
<p>让$F <span class="math inline">\(是一个域并且\)</span>f , g F [ x ]
$,我们想要检验它们是否互素.一个好的算法当然是辗转相除法,但我们更想去找一个精确的量来判定.例如矩阵的行列式可以用消元法求,然而我们也可以用代数余子式展开.</p>
<p>具体地,考虑$F [ x ] $的元素:</p>
<p><span class="math display">\[
\begin{aligned}
f &amp; = v _0 x ^n + \cdots + v _n \\
g &amp; = w _0 x ^m + \cdots + w _m
\end{aligned}
\]</span></p>
<p>注意这里并不要求$v _0 , w _0 $,结式并不在乎这个.</p>
<p>我们定义$f , g $的<strong>结式</strong>为:</p>
<p><span class="math display">\[
Res ( f , g ) = \left | \begin{matrix}
v _0 &amp; \cdots &amp; \cdots &amp; v _n &amp; &amp; \\
&amp; \ddots &amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; v _0 &amp; \cdots &amp; \cdots &amp; v _n \\
w _0 &amp; \cdots &amp; \cdots &amp; w _m &amp; &amp; \\
&amp; \ddots &amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; w _0 &amp; \cdots &amp; \cdots &amp; w _m
\end{matrix} \right |
\]</span></p>
<p>其中上面那个平行四边形是$m <span class="math inline">\(行的,下面那个是\)</span>n <span class="math inline">\(行的.这样总共就是\)</span>( n + m ) ( n + m )
<span class="math inline">\(的,该行列式的定义是有意义的.如若将系数\)</span>v
_0 , , w _m <span class="math inline">\(视作变量,容易见到上述行列式仍然是关于\)</span>v _0
, , w _m <span class="math inline">\(的整系数\)</span>n + m + 2 <span class="math inline">\(元多项式,且系数和\)</span>F $无关.</p>
<p>考虑下述性质:</p>
<ol type="1">
<li><p>$[ v _0 ^m w _m ^n ] Res ( f , g ) = 1 $.</p></li>
<li><p>$Res ( g , f ) = ( - 1 ) ^{ nm } Res ( f , g ) $.</p></li>
<li><p>$t F , Res ( tf , g ) = t ^m Res ( f , g ) , Res ( f , tg ) = t
^n Res ( f , g ) $.</p></li>
</ol>
<p>考虑(1),应当见到第$m <span class="math inline">\(行的那个\)</span>v
_0 <span class="math inline">\(恰好是第\)</span>m <span class="math inline">\(列,所以上述行列式对角线恰好由\)</span>m <span class="math inline">\(个\)</span>v _0 <span class="math inline">\(和\)</span>n <span class="math inline">\(个\)</span>w _m <span class="math inline">\(构成,根据行列式最初始的那个排列定义,要凑出\)</span>v
_0 ^m w _m ^n $就只能沿着对角线乘.</p>
<p>考虑(2),只需要交换行列即可对吧,每次把$v <span class="math inline">\(那里的最后一行暴力换到最下面,这样就需要交换\)</span>nm
$次.</p>
<p>(3)是显然的.</p>
<p>接下来证明一个引理:如果$Res ( f , g ) = 0 <span class="math inline">\(,当且仅当\)</span>f _1 , g _1 F [ x ] <span class="math inline">\(满足\)</span>f _1 &lt; n , g _1 &lt; m <span class="math inline">\(并且\)</span>f _1 <span class="math inline">\(和\)</span>g _1 $不全为$0 <span class="math inline">\(,使得\)</span>fg _1 + gf _1 = 0 $.</p>
<p>不妨展开$f _1 <span class="math inline">\(和\)</span>g _1 $如下:</p>
<p><span class="math display">\[
\begin{aligned}
f _1 &amp; = a _1 x ^{ n - 1  } + \cdots + a _n \\
g _1 &amp; = b _1 x ^{ m - 1  } + \cdots + b _m
\end{aligned}
\]</span></p>
<p>如若设$H = fg _1 + gf _1 = 0 $,那么:</p>
<p><span class="math display">\[
\begin{aligned}
[ x ^{ n + m - 1  } ] H &amp; = b _1 v _0 + a _1 w _0 &amp; = 0 \\
[ x ^{ n + m - 2  } ] H &amp; = b _1 v _1 + b _2 v _0 + a _1 w _1 + a _2
w _0 &amp; = 0 \\
\cdots \\
[ x ^{ 0  } ] H &amp; = b _m v _n + a _n w _m &amp; = 0
\end{aligned}
\]</span></p>
<p>如果假设$v _0 , , w _m <span class="math inline">\(均是已知量而尝试求解\)</span>f _1 , g _1 <span class="math inline">\(,自然拿到了一个大小为\)</span>n + m
$的线性方程组,容易见到其系数矩阵为:</p>
<p><span class="math display">\[
\begin{bmatrix}
v _0 &amp; &amp; &amp; w _0 &amp; &amp; \\
\vdots &amp; \ddots &amp; &amp; \vdots &amp; \ddots &amp; \\
v _n &amp; &amp; v _0 &amp; w _m &amp; &amp; w _0 \\
&amp; \ddots &amp; \vdots &amp; &amp; \ddots &amp; \vdots \\
&amp; &amp; v _n &amp; &amp; &amp; w _m
\end{bmatrix}
\]</span></p>
<p>(很遗憾这里把第$n + 1 <span class="math inline">\(行和第\)</span>m +
1 $行画到一行了,然而是无奈之举,请读者自行在脑中错开一下位置)</p>
<p>线性方程组理论告诉我们这有一组非$0 $解当且仅当行列式为$0 <span class="math inline">\(,然而这恰好是\)</span>Res ( f , g )
$的转置,而行列式转置不变,这就证毕.</p>
<p>下面我们证明,$Res ( f , g ) = 0 $当且仅当以下任何一个条件成立:</p>
<ol type="1">
<li><p>$v _0 = w _0 = 0 $.</p></li>
<li><p>$( f , g ) &gt; 0 $.</p></li>
</ol>
<p>(1)是平凡的,只需观察上述行列式定义即可发现此时第一列全部为$0
$,那行列式当然为$0 $.</p>
<p>对于(2),先证必要性,考虑如果$h , h &gt; 0 <span class="math inline">\(,\)</span>h | f , h | g <span class="math inline">\(,那么注意到\)</span> { h } &lt; n , { h } &lt; m
<span class="math inline">\(而且由于\)</span>v _0 <span class="math inline">\(和\)</span>w _0 $不全为$0 <span class="math inline">\(,所以\)</span> { h } , { h } $不全为$0 <span class="math inline">\(,而\)</span>f { h } - g { h } = 0 <span class="math inline">\(,用引理得证\)</span>Res ( f , g ) = 0 $.</p>
<p>再证(2)的充分性.如若$f , g $其一为$0 <span class="math inline">\(,不失一般性设\)</span>f = 0 <span class="math inline">\(.如若此时\)</span>g &gt; 0 <span class="math inline">\(,则取\)</span>h = g <span class="math inline">\(自然是公因式;如若\)</span>g = 0 <span class="math inline">\(,容易见到\)</span>w _0 = Res ( f , g ) = 0
$,这就是(1)的情况.</p>
<p>如若$f , g $都不是$0 <span class="math inline">\(,而且\)</span>v _0 ,
w _0 $不全为$0 <span class="math inline">\(,不妨设\)</span>w _0 <span class="math inline">\(,既如此\)</span>g <span class="math inline">\(,此时如若\)</span>Res ( f , g ) = 0 <span class="math inline">\(,由引理拿到了\)</span>f _1 , g _1 $不全为$0 <span class="math inline">\(并且使得\)</span>fg _1 + gf _1 = 0 <span class="math inline">\(,其中\)</span>g _1 &lt; m $.</p>
<p>直接把当前的多项式环$F [ x ] <span class="math inline">\(扩到有理分式域\)</span>F ( x ) <span class="math inline">\(,此时有\)</span> { g } g _1 = f _1 <span class="math inline">\(,两边通分立刻见到,如果\)</span>gcd ( f , g ) = 0
<span class="math inline">\(,那么左边就是\)</span>f { g } <span class="math inline">\(,这应该给出\)</span>g | g _1 <span class="math inline">\(,然而\)</span>g = m , g _1 &lt; m
$,不符.这就证毕.</p>
<p>最后,我们来讨论一下当$f , g <span class="math inline">\(均是分裂的时候如何体现,不妨设\)</span>f = a _{ k }
^n ( x - <em>k ) , g = b </em>{ k } ^m ( x - _k ) $,我们下面证明:</p>
<p><span class="math display">\[
\begin{aligned}
Res ( f , g ) &amp; = a ^m \prod _k ^n g ( \alpha _k ) &amp; = ( - 1 )
^{ nm  } b ^n \prod _j ^m f ( \beta _j ) \\
&amp; = a ^m b ^n \prod _{ k , j  } ( \alpha _k - \beta _j )
\end{aligned}
\]</span></p>
<p>有一连串等式,其中中间两个是对称的$Res ( f , g ) <span class="math inline">\(和\)</span>Res ( g , f )
$的形式,而最后一个等式只需带入就属显然.因此需要证明的只有第一个等式.</p>
<p>由于$Res ( tf , g ) = t ^m Res ( f , g ) <span class="math inline">\(,所以不妨设\)</span>a = 1 $.</p>
<p>假设$g ( _1 ) , , g ( _n ) <span class="math inline">\(两两相异,则引入一个新的变元\)</span>y <span class="math inline">\(并在\)</span>F [ y ] <span class="math inline">\(上考虑\)</span>Res ( f , g - y ) <span class="math inline">\(,回看一开始的矩阵形状,对于\)</span>[ y ^n ] Res (
f , g - y ) <span class="math inline">\(,见到其意味着下半部分的对角线被全部选择,上半部分选择的话如果非零当然也要选择对角线,所以\)</span>[
y ^n ] Res ( f , g - y ) = ( - 1 ) ^n <span class="math inline">\(,而显然\)</span>[ y ^0 ] Res ( f , g - y ) = Res (
f , g ) <span class="math inline">\(.既然如此,注意到\)</span>_k <span class="math inline">\(是\)</span>f <span class="math inline">\(和\)</span>g - g ( _k ) <span class="math inline">\(的公共根,则\)</span>Res ( f , g - g ( _k ) ) = 0
<span class="math inline">\(,从而\)</span>( g ( _k ) - y ) | Res ( f , g
- y ) <span class="math inline">\(,又由于\)</span>g ( _1 ) , , g ( _n )
<span class="math inline">\(两两相异,\)</span>_k ( g ( _k ) - y ) , Res
( f , g - y ) <span class="math inline">\(的最高次系数都是\)</span>( - 1
) ^n $,这立刻意味着它们相等,原命题自然成立.</p>
<p>然而既然如此,可以见到直接假设$_1 , , _n <span class="math inline">\(并非常数而是若干个变元,具体而言用\)</span>z _1 , ,
z _n <span class="math inline">\(代替它们,于是上述立刻有\)</span>g ( z
_1 ) , , g ( z _n ) <span class="math inline">\(两两相异,得到结论后带入\)</span>_1 , , _n
$即可.</p>
<h4><span id="判别式">判别式</span></h4>
<p>对于一个多项式$f = _k c _k ( - 1 ) ^{ k } x ^{ n - k } <span class="math inline">\(,假设其可分裂而且\)</span>f = _j ( x - <em>j )
<span class="math inline">\(,我们称其判别式\)</span>disc ( f ) = </em>{
i &lt; j } ( _i - _j ) ^2 <span class="math inline">\(如果我们将\)</span>_1 , , <em>n <span class="math inline">\(看作变量,则我们注意到\)</span>disc ( f ) <span class="math inline">\(是一个对称多项式,原因是\)</span>disc ( f ) = (
</em>{ i &lt; j } ( _i - _j ) ) ^2 <span class="math inline">\(,而中间那个东西在重排后会差一个\)</span> ( )
$,这就证毕.</p>
<p>既然如此,$disc ( f ) <span class="math inline">\(就可以拆成\)</span>e
_1 , , e _n <span class="math inline">\(这若干个对称多项式的多项式,然而注意到由于Vieta公式,\)</span>e
_1 = c _1 , , e _n = c _n <span class="math inline">\(.于是\)</span>disc
( f ) <span class="math inline">\(当然是关于\)</span>c _1 , , c _n <span class="math inline">\(的多项式.这里由于没有讨论具体的值,而只是把这些涉及到的值用变量来表示,所以你可以先一步把范围控制在整环\)</span>
<span class="math inline">\(上,见到\)</span>disc ( f ) <span class="math inline">\(当然是关于\)</span>c _1 , , c _n
$的整系数多项式.</p>
<p>例如当$n = 2 <span class="math inline">\(的时候,\)</span>f ( x ) = x
^2 - bx + c = ( x - _1 ) ( x - _2 ) <span class="math inline">\(,那么\)</span>disc ( f ) = ( _1 - _2 ) ^2 = ( _1 +
_2 ) ^2 - 4 _1 _2 = b ^2 - 4 c $,这就是二次方程的判别式.</p>
<p>取$n = 3 $的时候,特别地取二次项为$0 <span class="math inline">\(的情况,\)</span>f = x ^3 + px + q = ( x - _1 ) ( x
- _2 ) ( x - _3 ) , _1 + _2 + _3 = 0 $,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
disc ( f ) &amp; = \left ( ( \alpha _1 - \alpha _2 ) ( \alpha _2 -
\alpha _3 ) ( \alpha _1 - \alpha _3 ) \right ) ^2 \\
&amp; = - 4 p ^3 - 27 q ^2
\end{aligned}
\]</span></p>
<p>而如果将判别式的定义推广到非首一的情形,也就是对于$f = a _j ( x -
<em>j ) <span class="math inline">\(,我们称其判别式\)</span>disc ( f ) =
a ^{ 2 n - 2 } </em>{ i &lt; j } ( _i - _j ) ^2 <span class="math inline">\(,对\)</span>f <span class="math inline">\(有形式导数\)</span>f ’ <span class="math inline">\(,我们下面证明:\)</span>a disc ( f ) = ( - 1 ) ^{ {
2 } } Res ( f , f ’ ) $.</p>
<p>证明的话,用Leibniz法则,知道:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; &amp; = a \sum _{ k = 1  } ^n \prod _{ j \ne k  } ( x - \alpha
_j ) \\
f &#39; ( \alpha _k ) &amp; = a \prod _{ j \ne k  } ( \alpha _k - \alpha
_j )
\end{aligned}
\]</span></p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
Res ( f , f &#39; ) &amp; = a ^{ n - 1  } \prod _{ k = 1  } ^n f &#39; (
\alpha _k ) \\
&amp; = a ^{ 2 n - 1  } \prod _{ k = 1  } ^n \prod _{ j \ne k  } (
\alpha _k - \alpha _j ) \\
&amp; = a ^{ 2 n - 1  } ( - 1 ) ^{ \frac { n ( n - 1 )  } { 2  }  }
\prod _{ i &lt; j  } ( \alpha _i - \alpha _j ) ^2
\end{aligned}
\]</span></p>
<p>这就证毕.</p>
<p>顺便一提,将$f = a _0 x ^n + + a _n <span class="math inline">\(,则\)</span>Res ( f , f ’ ) <span class="math inline">\(是\)</span>a _0 , , a _n <span class="math inline">\(的整系数多项式,而其行列式首列能提出\)</span>a = a
_0 <span class="math inline">\(,因此\)</span>a ^{ - 1 } Res ( f , f ’ )
<span class="math inline">\(确实表作\)</span>a _0 , , a _n <span class="math inline">\(的整系数多项式,这说明\)</span>disc ( f ) <span class="math inline">\(在\)</span>f $非首一的时候定义确实合理.</p>
<h3><span id="域">域</span></h3>
<p>设$D <span class="math inline">\(是含有至少两个元素的幺环,如果\)</span>D <span class="math inline">\(的每个元素都可逆,则称\)</span>D
$是一个<strong>体</strong>.有乘法交换律的体称为<strong>域</strong>.</p>
<h4><span id="分式域">分式域</span></h4>
<p>之前尝试使用过商集来用$ <span class="math inline">\(构造\)</span>
<span class="math inline">\(,我们同样可以用整环的商集来构造形如\)</span>
{ g } <span class="math inline">\(的域,将其记作\)</span> ( R )
$,也就是<strong>分式域</strong>.</p>
<p>可以说明如果$: R R ’ <span class="math inline">\(并且\)</span>( R { 0
} ) R ’ ^{ } <span class="math inline">\(,又取一个\)</span>i : R R <span class="math inline">\(,那么存在唯一一个映射\)</span>: R R ’ <span class="math inline">\(的映射.更具体来说,只需验证\)</span>( { g } ) ( f )
( g ) ^{ - 1 } $即可(当然需要检验良定义).</p>
<p>如果我们将一开始的映射改为$: R F <span class="math inline">\(,其中\)</span>F <span class="math inline">\(是一个域并且\)</span>x F , f , g R , x = ( f ) ( g
) ^{ - 1 } <span class="math inline">\(,那我们可以证明\)</span> ( R ) F
$,过程太无聊,略过.</p>
<p>这说明分式域具有某种唯一性和泛性质.</p>
<p>一般把$ ( R [ x ] ) <span class="math inline">\(写作\)</span>R ( x )
$.</p>
<h4><span id="子域">子域</span></h4>
<p>由于子域的交还是子域,我们当然可以取所有子域的交得到一个子域$F <em>{
prime } <span class="math inline">\(,容易验证当\)</span> F </em>{ prime
} = 0 <span class="math inline">\(的时候,\)</span>F <em>{ prime } <span class="math inline">\(;当\)</span>p = F </em>{ prime } prime <span class="math inline">\(的时候,\)</span>F _{ prime } / _p $.</p>
<h2><span id="线性代数">线性代数</span></h2>
<h3><span id="矩阵引入">矩阵引入</span></h3>
<p>我们称有$m <span class="math inline">\(行\)</span>n <span class="math inline">\(列的**矩阵**为\)</span>A <em>{ m n } <span class="math inline">\(,其中第\)</span>i <span class="math inline">\(行第\)</span>j <span class="math inline">\(列的元素称作\)</span>a </em>{ i , j }
$,也有的称其为<strong>矩阵元</strong>.</p>
也可以将其中中的列写作$F ^m <span class="math inline">\(中列向量的形式,即写作\)</span>A _{ m n } =
<span class="math display">\[\begin{bmatrix}\vec { a _1  } &amp; \vec {
a _2  } &amp; . . . &amp; \vec { a _n  } \end{bmatrix}\]</span>
<p>$.</p>
<p>若$n = m <span class="math inline">\(,则称\)</span>A
$为<strong>方阵</strong>.</p>
<h4><span id="矩阵运算">矩阵运算</span></h4>
<p>大小相同的矩阵本身应当是一个线性空间.事实上,我们可以定义:</p>
<ol type="1">
<li><p><strong>矩阵加法</strong>:若矩阵$A <span class="math inline">\(和\)</span>B <span class="math inline">\(都是\)</span>m n <span class="math inline">\(矩阵,则它们的和也是\)</span>m n <span class="math inline">\(矩阵,且元素为\)</span>A <span class="math inline">\(和\)</span>B
$中对应元素的加和.显然有交换律.</p></li>
<li><p><strong>标量乘法</strong>:若$c <span class="math inline">\(是标量而\)</span>A <span class="math inline">\(是一个\)</span>m n <span class="math inline">\(矩阵,则\)</span>cA <span class="math inline">\(是一个\)</span>m n <span class="math inline">\(矩阵,且元素为A中对应元素的\)</span>c
$倍.显然有交换律以及对矩阵加法的分配律.</p></li>
</ol>
<p>事实上,我们还可以定义:</p>
<ol start="3" type="1">
<li><strong>矩阵乘法</strong>:若$A <span class="math inline">\(是\)</span>m n <span class="math inline">\(矩阵,\)</span>B <span class="math inline">\(是\)</span>n p <span class="math inline">\(矩阵,那么它们的乘积\)</span>AB <em>{ i , j } =
</em>{ k = 1 } ^n A <em>{ i , k } B </em>{ k , j } $.</li>
</ol>
矩阵乘法也可以表示为:若$A <span class="math inline">\(是\)</span>m n
<span class="math inline">\(矩阵,\)</span>B <span class="math inline">\(是\)</span>n p <span class="math inline">\(矩阵,且\)</span>B =
<span class="math display">\[\begin{bmatrix}\vec { b _1  } &amp; \vec {
b _2  } &amp; . . . &amp; \vec { b _p  } \end{bmatrix}\]</span>
<span class="math inline">\(那么它们的乘积\)</span>AB =
<span class="math display">\[\begin{bmatrix}A \vec { b _1  } &amp; A
\vec { b _2  } &amp; . . . &amp; A \vec { b _p  } \end{bmatrix}\]</span>
<p>$.</p>
<p>若$AB = BA <span class="math inline">\(我们称\)</span>A <span class="math inline">\(和\)</span>B $彼此<strong>可交换</strong>.</p>
不难发现$A <em>{ m n } <span class="math inline">\(,对于矩阵\)</span>I
</em>{ n n } =
<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; . . . &amp;
0 \\ 0 &amp; 1 &amp; . . . &amp; 0 \\ . . . &amp; . . . &amp; . . .
&amp; . . . \\ 0 &amp; 0 &amp; . . . &amp; 1 \end{bmatrix}\]</span>
<p><span class="math inline">\(有\)</span>AI = A <span class="math inline">\(,我们称\)</span>I _{ n n } <span class="math inline">\(为**单位矩阵**.单位矩阵的第\)</span>i <span class="math inline">\(列通常记作\)</span> _i $.</p>
<p>定义<strong>乘幂</strong>$A ^k <span class="math inline">\(为\)</span>k <span class="math inline">\(个\)</span>A $连续相乘的乘积.</p>
<p>设$A <span class="math inline">\(为\)</span>m n <span class="math inline">\(矩阵,\)</span>B <span class="math inline">\(和\)</span>C
$的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol type="1">
<li><p>乘法结合律:$( AB ) C = A ( BC ) $.</p></li>
<li><p>乘法左分配律:$A ( B + C ) = AB + AC $.</p></li>
<li><p>乘法右分配律:$( B + C ) A = BA + CA $.</p></li>
<li><p>$c ( AB ) = ( cA ) B = A ( cB ) $.</p></li>
<li><p>乘法恒等式:$I _m A = A = AI _n $.</p></li>
</ol>
<p>注意到向量可以看为一个$n $的矩阵,事实上,我们有:</p>
<p>若$A <span class="math inline">\(是\)</span>m n <span class="math inline">\(矩阵,它的各列为\)</span> , , . . . <span class="math inline">\(,而\)</span> , ^n $,那么:</p>
<ol type="1">
<li><p>$A ( + ) = A + A $.</p></li>
<li><p>$A ( c ) = c ( A ) $.</p></li>
</ol>
<p>定义<strong>矩阵转置</strong>:对于$m n <span class="math inline">\(矩阵\)</span>A <span class="math inline">\(,它的**转置**是一个\)</span>n m <span class="math inline">\(矩阵,该矩阵的列是由\)</span>A <span class="math inline">\(的对应行构成的,记作\)</span>A ^T <span class="math inline">\(,即\)</span>A ^T <em>{ i , j } = A </em>{ j , i }
<span class="math inline">\(.有的时候也写作\)</span>^t A $.</p>
<p>设$A <span class="math inline">\(和\)</span>B
$的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol type="1">
<li><p>$( A ^T ) ^T = A $.</p></li>
<li><p>$( A + B ) ^T = A ^T + B ^T $.</p></li>
<li><p>$( rA ) ^T = rA ^T $.</p></li>
<li><p>$( AB ) ^T = B ^T A ^T $.</p></li>
</ol>
<h4><span id="分块矩阵">分块矩阵</span></h4>
<p>我们考虑将一个矩阵看作若干个子矩阵的拼接,类似于我们求逆矩阵时做的那样:将若干个矩阵拼接起来.</p>
<p>换句话说,我们尝试将矩阵看作元素放入矩阵中,并尝试根据基本的矩阵运算去做这种矩阵的运算.</p>
<p>分块矩阵的<strong>矩阵加法</strong>:若矩阵$A <span class="math inline">\(和\)</span>B <span class="math inline">\(维数相同且都以同样的方式分块,则矩阵的和\)</span>A
+ B <span class="math inline">\(也以同样的方式分块且每一块都是\)</span>A
<span class="math inline">\(和\)</span>B $对应块的和.</p>
<p>分块矩阵的<strong>标量乘法</strong>:若$c <span class="math inline">\(是一个常数,\)</span>A <span class="math inline">\(是一个分块矩阵,则\)</span>cA <span class="math inline">\(是\)</span>A <span class="math inline">\(的子矩阵乘\)</span>c
$再以同样的方式组合起来的结果.</p>
<p>分块矩阵的<strong>矩阵乘法</strong>:若矩阵$A <span class="math inline">\(和\)</span>B <span class="math inline">\(的维数使得\)</span>AB <span class="math inline">\(有定义,并且\)</span>A <span class="math inline">\(列的分法与\)</span>B
$行的分法一致,那我们显然可以直接将矩阵作为元素来直接进行矩阵乘法.</p>
<p>由上面的讨论自然发现:</p>
<p>若$A <span class="math inline">\(是\)</span>m n <span class="math inline">\(矩阵,\)</span>B <span class="math inline">\(是\)</span>n p <span class="math inline">\(矩阵,我们定义\)</span>row _i ( A ) <span class="math inline">\(为\)</span>A <span class="math inline">\(的第\)</span>i <span class="math inline">\(列,\)</span>col _i ( A ) <span class="math inline">\(为\)</span>A <span class="math inline">\(的第\)</span>i $行,则:</p>
$AB =
<span class="math display">\[\begin{bmatrix}col _1 ( A ) &amp; col _2 (
A ) &amp; . . . &amp; col _n ( A ) \end{bmatrix} \begin{bmatrix}row _1 (
B ) \\ row _2 ( B ) \\ . . \\ row _n ( B ) \end{bmatrix}\]</span>
<p>$</p>
<p>证明是显然的.</p>
<h3><span id="线性方程组">线性方程组</span></h3>
<p>包含变量$x _1 , x _2 . . . , x _n <span class="math inline">\(的**线性方程**是形如\)</span>a _1 x _2 + a _2 x _2
+ . . . + a _n x _n = b
$的方程,其中b与系数是实数或复数,通常是已知数.</p>
<p><strong>线性方程组</strong>是由一个或几个包含相同变量$x _1 , x _2 , .
. . , x _n $的线性方程组成的.</p>
<p><strong>线性方程组的解</strong>是一组数${ s _1 , s _2 , . . . , s _n
} <span class="math inline">\(,用这组数分别代替\)</span>x _1 , x _2 , .
. . x _n $时所有方程的两边相等.</p>
<p>线性方程组所有可能的解的集合称为<strong>线性方程组的解集</strong>.</p>
<p>若两个线性方程组有相同的解集,则称这两个方程组是<strong>等价的</strong>.</p>
<p>我们称一个线性方程组是<strong>相容的</strong>,当且仅当它有一个解或无穷多个解,否则,称其为<strong>不相容的</strong>.</p>
<p>一个线性方程组要么无解,要么有一个解,要么有无穷多个解.</p>
<h4><span id="系数矩阵和增广矩阵">系数矩阵和增广矩阵</span></h4>
<p>考虑以下m个线性方程所组成的线性方程组:</p>
<p><span class="math display">\[
\begin{cases}
a _{ 1 , 1  } x _1 + a _{ 1 , 2  } x _2 + . . . + a _{ 1 , n  } x _n = b
_1 \\
a _{ 2 , 1  } x _1 + a _{ 2 , 2  } x _2 + . . . + a _{ 2 , n  } x _n = b
_2 \\
. . . \\
a _{ m , 1  } x _1 + a _{ m , 2  } x _2 + . . . + a _{ m , n  } x _n = b
_m
\end{cases}
\]</span></p>
<p>我们称它的<strong>系数矩阵</strong>为:</p>
<p><span class="math display">\[
\begin{bmatrix}
a _{ 1 , 1  } &amp; a _{ 1 , 2  } &amp; . . . &amp; a _{ 1 , n  } \\
a _{ 2 , 1  } &amp; a _{ 2 , 2  } &amp; . . . &amp; a _{ 2 , n  } \\
. . . &amp; . . . &amp; . . . &amp; . . . \\
a _{ m , 1  } &amp; a _{ m , 2  } &amp; . . . &amp; a _{ m , n  }
\end{bmatrix}
\]</span></p>
<p>两个系数矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<p>而称它的<strong>增广矩阵</strong>为:</p>
<p><span class="math display">\[
\begin{bmatrix}
a _{ 1 , 1  } &amp; a _{ 1 , 2  } &amp; . . . &amp; a _{ 1 , n  } &amp;
b _1 \\
a _{ 2 , 1  } &amp; a _{ 2 , 2  } &amp; . . . &amp; a _{ 2 , n  } &amp;
b _2 \\
. . . &amp; . . . &amp; . . . &amp; . . . &amp; . . . \\
a _{ m , 1  } &amp; a _{ m , 2  } &amp; . . . &amp; a _{ m , n  } &amp;
b _m
\end{bmatrix}
\]</span></p>
<p>两个增广矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<h4><span id="矩阵的初等行变换">矩阵的初等行变换</span></h4>
<p>考虑如何解一个线性方程:根据我们已有的知识,等式可以任意两端加减相等的两项,也可以同时乘以一个不为0的数,同时等式的顺序并不重要.</p>
<p>我们用这一点来考虑如何解线性方程组.这里主要是考虑如何对线性方程组的增广矩阵进行变换.</p>
<p>由上面的知识,我们意识到对线性方程组的增广矩阵进行以下变换,是不会改变其解集的:</p>
<ol type="1">
<li><p>(倍加变换)把某一行换成它本身与另一行的倍数的和,记作$R _i + kR _j
R _i $.</p></li>
<li><p>(对换变换)把两行对换,记作$R _i R _j $.</p></li>
<li><p>(倍乘变换)把某一行的所有元素乘以同一个非零数$k <span class="math inline">\(,记作\)</span>kR _i R _i , k $.</p></li>
</ol>
<p>以上三种变换称为<strong>矩阵的初等行变换</strong>,同理可以定义初等列变换.</p>
<p>由此可以发现,两个增广矩阵是等价的当且仅当其中一个增广矩阵可以通过若干次初等行变换变为另一个增广矩阵.</p>
<p>我们可以使用这些初等行变换来变换一个矩阵,使得它有一些特殊性质.</p>
<p>如果两个矩阵可以通过若干次初等行变换而转化,我们称二者<strong>行等价</strong>,不难证明行等价满足等价关系的三个性质(反身性,对称性,传递性).</p>
<p>由于简化行阶梯矩阵的唯一性,我们可以用其来判定行等价类.</p>
<h4><span id="阶梯形矩阵">阶梯形矩阵</span></h4>
<p>若矩阵的一行的元素全为0,称这一行为矩阵的一个<strong>零行</strong>,否则称为<strong>非零行</strong>.</p>
<p>非零行的最左边的非零元素称为该行的<strong>先导元素</strong>.</p>
<p>若一个矩阵有以下性质,则称它为<strong>阶梯形矩阵(REF)</strong>:</p>
<ol type="1">
<li><p>每一个非零行都在零行之上</p></li>
<li><p>某一行的先导元素所在的列位于前一行先导元素的右边</p></li>
<li><p>某一先导元素所在列下方元素都是0</p></li>
</ol>
<p>若一个矩阵还满足以下性质,则称它为<strong>简化阶梯形(RREF)</strong>:</p>
<ol start="4" type="1">
<li><p>每一非零行的先导元素是1</p></li>
<li><p>每一先导元素1是该元素所在列唯一的非零元素</p></li>
</ol>
<p>显然,任意一个矩阵都可以通过若干次初等行变换变为一个阶梯形矩阵或简化阶梯形矩阵.</p>
<p>一个矩阵所对应的阶梯形矩阵中先导元素的位置,被称为这个矩阵的一个<strong>主元位置</strong>,包含一个主元位置的列称为<strong>主元列</strong>.</p>
<p>注意:这里的位置是矩阵中的位置而非元素的位置,这也就是说主元位置上的元素可以不是最终的主元位置上的元素移动而来的.</p>
<h5><span id="简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</span></h5>
<p>每个矩阵通过初等行变换只有可能对应唯一一个简化阶梯形矩阵.</p>
<p>证明:假设两个行等价的简化阶梯形矩阵不相等.那么我们找到它们的第一个不相等的列,设为$j
$.</p>
<p>如果$A , B <span class="math inline">\(中的\)</span>j
$均为主元列,显然它们这一列必然相等,不符.</p>
<p>反之,我们不妨去掉第$j <span class="math inline">\(列后面的所有列以及第\)</span>j <span class="math inline">\(列前面的所有非主元列,保留第\)</span>j
$列考虑剩下的两个矩阵一定也是行等价的,但它们对应的线性方程组的解显然不同,这导出了矛盾.</p>
<h4><span id="解线性方程组">解线性方程组</span></h4>
<p>考虑将线性方程组的增广矩阵通过初等行变换变换为一个简化阶梯形矩阵,我们称对应于主元列的变量为<strong>基本变量</strong>,其它变量称为<strong>自由变量</strong>.</p>
<p>如果线性方程组是相容的,显然我们可以使用自由变量表示基本变量,从而得到一组解.我们得到的基本变量的关于自由变量的表达式称作解集的<strong>参数表示</strong>.</p>
<p>这也意味着,如果没有自由变量,该方程组只有一解;如果有自由变量,由于自由变量取值任意,该方程组有无数组解.</p>
<p>而考虑何时线性方程组不相容,由于自由变脸取值任意,显然唯一的不相容可能性只是出现了$0
x _1 + 0 x _2 + . . . + 0 x _n = b , b $的情况.</p>
<p>以上的分析过程引出下面的定理.</p>
<h5><span id="存在与唯一性定理">存在与唯一性定理</span></h5>
<p>线性方程组相容的充要条件是增广矩阵的最右列不是主元列.</p>
<p>若线性方程组相容,则它的解集可能有两种情形:</p>
<ol type="1">
<li><p>没有自由变量时,只有一个解.</p></li>
<li><p>有自由变量时,有无数个解.</p></li>
</ol>
<h4><span id="矩阵方程">矩阵方程</span></h4>
<p>设$A <span class="math inline">\(是\)</span>m n <span class="math inline">\(的矩阵,它的各列是\)</span> , , . . . , <span class="math inline">\(,若\)</span> <span class="math inline">\(是\)</span>F ^n <span class="math inline">\(中向量,则\)</span>A <span class="math inline">\(即A的各列以\)</span>
$中对应元素为权的线性组合,也就是:</p>
$A =
<span class="math display">\[\begin{bmatrix}\vec { a _1  } &amp; \vec {
a _2  } &amp; . . . &amp; \vec { a _n  } \end{bmatrix} \begin{bmatrix}x
_1 \\ x _2 \\ . . . \\ x _n \end{bmatrix}\]</span>
<p>= x _1 + x _2 + . . . + x _n $</p>
<p>如果令$ F ^m <span class="math inline">\(,那么上式可以写成\)</span>A
= $,我们把形如这样的方程称作矩阵方程.</p>
<p>不难发现,若$A <span class="math inline">\(是\)</span>m n <span class="math inline">\(矩阵,它的各列为\)</span> , , . . . <span class="math inline">\(,而\)</span> F ^m , F ^n $,那么:</p>
矩阵方程$A = <span class="math inline">\(,向量方程\)</span>x _1 + x _2 +
. . . + x _n = <span class="math inline">\(,增广矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}\vec { a _1  } &amp; \vec {
a _2  } &amp; . . . &amp; \vec { a _n  } &amp; \vec { b  }
\end{bmatrix}\]</span>
<p>$的线性方程组有相同的解集.</p>
<p>事实上,若$A <span class="math inline">\(是\)</span>m n <span class="math inline">\(矩阵,它的各列为\)</span> , , . . .
$,那么以下命题逻辑等价:</p>
<ol type="1">
<li><p>$ F ^m <span class="math inline">\(,方程\)</span>A =
$有解.</p></li>
<li><p>$ F ^m <span class="math inline">\(,\)</span> <span class="math inline">\(是\)</span>A $的列的一个线性组合.</p></li>
<li><p>$A <span class="math inline">\(的各列生成\)</span> ^m $.</p></li>
<li><p>$A $在每一行都有一个主元位置.</p></li>
</ol>
<h4><span id="齐次线性方程组">齐次线性方程组</span></h4>
<p>若一个线性方程组可以被写成$A = <span class="math inline">\(的形式,其中\)</span>A <span class="math inline">\(是\)</span>m n <span class="math inline">\(的矩阵,\)</span> <span class="math inline">\(是\)</span> ^n
$中的向量,称其为<strong>齐次线性方程组</strong>.</p>
<p>显然齐次线性方程组至少有一个解,即$ =
$,这个解称作线性齐次方程组的<strong>平凡解</strong>.</p>
<p>而满足$ $的解称作线性齐次方程组的<strong>非平凡解</strong>.</p>
<p>根据存在与唯一性定理,显然其存在非平凡解的充要条件是该方程至少有一个自由变量.</p>
<p>考虑自由变量的取值任意,而且基本变量一定是由若干个自由变量乘以定值之和得到的.</p>
<p>我们把这些定值看作向量,把自由向量看作权重,我们发现:齐次线性方程组的解集总可以表示为$
{ , , . . . , } <span class="math inline">\(,当然,如果该方程组仅有平凡解,那表示为\)</span> { }
$.</p>
<p>把解表示为$ { , , . . . , }
$中元素的形式,称之为<strong>解的参数向量形式</strong>.</p>
<p>对于方程$A = <span class="math inline">\(,它的解一定可以写成\)</span>
= + <span class="math inline">\(的形式,其中\)</span> <span class="math inline">\(是方程\)</span>A = <span class="math inline">\(的一组解,\)</span> <span class="math inline">\(是方程\)</span>A = $的一组特解.</p>
<p>对于该定理的几何意义,我们考虑$ ^2 <span class="math inline">\(中,即\)</span> = + t <span class="math inline">\(,如果我们把它看为向量加法的形式,它的解集应该是在一条直线上的任意向量,这条直线即\)</span>
<span class="math inline">\(所在直线沿向量\)</span>
$方向平移后的直线.</p>
<h3><span id="线性空间">线性空间</span></h3>
<p>我们可以在一个域$F <span class="math inline">\(上定义一个**线性空间**(向量空间)\)</span>V
$,除了域本身带有的性质(加法的结合律交换律,加法单位元,加法逆元,乘法对加法有分配律)它应当满足以下公理:</p>
<ol type="1">
<li><p>定义向量加法$V V V $.向量加法应当有交换律和结合律.</p></li>
<li><p>定义标量乘法$F V V
$.标量乘法应当有交换律,结合律以及对向量加法的分配律.</p></li>
<li><p>存在加法幺元以及加法逆元.</p></li>
</ol>
<p>由于$V $对加法构成群,相应的性质可以从群的性质搬过来.</p>
<p>值得一提的是,其实标量乘法如果定义成$V F V
$后会有相当多的好处,但是由于历史原因一般还是定义左标量乘法.</p>
<p>当然容易验证我们平常用的线性空间$V = F ^n $满足以上性质.</p>
<p>当然容易验证定义在域上的多项式环满足以上性质.</p>
<h4><span id="相关运算">相关运算</span></h4>
<h5><span id="直积">直积</span></h5>
<p>定义$_{ i I } V _i = ( <em>i ) </em>{ i I } , _i V _i
$为直积,容易发现线性空间的直积也是线性空间.</p>
<h5><span id="直和">直和</span></h5>
<p>我们如果取直积的一个子空间,使得至多只有有限个$i I <span class="math inline">\(使得\)</span> _i $,则称这是一个直和.</p>
<h5><span id="叉乘">叉乘</span></h5>
<p>对$ ^3 <span class="math inline">\(,定义新的向量运算:向量积(叉乘)\)</span> <span class="math inline">\(, 其运算结果仍为向量,设为\)</span> <span class="math inline">\(,它的模定义为\)</span> = | | | | <span class="math inline">\(,其中\)</span><span class="math inline">\(为向量\)</span> , <span class="math inline">\(的夹角,\)</span>| | <span class="math inline">\(为以\)</span>a , b <span class="math inline">\(为两边的平行四边形的面积,\)</span> <span class="math inline">\(的方向定义为与\)</span> , <span class="math inline">\(所形成的平面垂直,且\)</span> , , <span class="math inline">\(构成右手螺旋定则(即现将四指指向\)</span> <span class="math inline">\(方向再将四指弯曲指向\)</span> <span class="math inline">\(的方向,则此时大拇指的方向为\)</span> $的方向),</p>
<p>向量叉乘满足以下性质:</p>
<ol type="1">
<li><p>$ = - $.</p></li>
<li><p>$ = $</p></li>
<li><p>$ ( + ) = + $.</p></li>
</ol>
<p>在三维坐标系中,设:</p>
<p><span class="math display">\[
\begin{aligned}
\vec { a  } &amp; = a _1 \vec { i  } + b _1 \vec { j  } + c _1 \vec {
k  } \\
\vec { b  } &amp; = a _2 \vec { i  } + b _2 \vec { j  } + c _2 \vec {
k  }
\end{aligned}
\]</span></p>
<p>由叉乘定义,得到:$ = ( a _y b _z - a _z b _y ) + ( a _z b _x - a _x b
_z ) + ( a _x b _y - a _y b _x ) $.也就是:</p>
<p><span class="math display">\[
\vec { c  } = \vec { a  } \times \vec { b  } = \left | \begin{matrix}
\vec { i  } &amp; \vec { j  } &amp; \vec { k  } \\
a _x &amp; a _y &amp; a _z \\
b _x &amp; b _y &amp; b _z
\end{matrix} \right |
\]</span></p>
<p>对于任意一个面的法向量，我们总可以选取该面上的两个不共线向量来直接叉乘出来.</p>
<h4><span id="线性无关与线性相关">线性无关与线性相关</span></h4>
<p>称$V <span class="math inline">\(中一组向量\)</span>{ , , . . . , }
<span class="math inline">\(是**线性无关**的,当且仅当向量方程\)</span>x
_1 + x _2 + . . . + x _p = $仅有平凡解.</p>
<p>反之,称为<strong>线性相关</strong>,即存在一组不全为0的数$c _1 , c _2
, . . . , c _p <span class="math inline">\(使\)</span>c _1 + c _2 + . .
. + c _p = <span class="math inline">\(,这个式子也被称为\)</span>{ , , .
. . , } $之间的<strong>线性相关关系</strong>.</p>
<p>容易发现,两个或更多向量的集合$S = { , , . . . , }
$线性相关,当且仅当其中至少有一个向量是其它向量的线性组合.</p>
<h4><span id="子空间">子空间</span></h4>
<p>我们定义$V <span class="math inline">\(的一个**子空间**是它的一个非空子集\)</span>V _0
$,具有以下三个性质:</p>
<ol type="1">
<li><p>$ V _0 $.</p></li>
<li><p>$ , V _0 , + V _0 $.</p></li>
<li><p>$ V _0 , c F , c V _0 $.</p></li>
</ol>
<p>线性空间的两个平凡子空间当然是零空间和它本身.</p>
<p>容易验证两个子空间的交仍然是子空间.</p>
<h5><span id="向量的线性组合">向量的线性组合</span></h5>
<p>给定$V <span class="math inline">\(中向量\)</span> _1 , _2 , . . . ,
_p <span class="math inline">\(和标量\)</span>c _1 , c _2 , . . . , c _p
F $.</p>
<p>我们称向量$ = c _1 + c _2 + . . . + c _p <span class="math inline">\(为向量\)</span> , , . . . , <span class="math inline">\(以\)</span>c _1 , c _2 , . . . , c _p
$为权的<strong>线性组合</strong>.</p>
<p>对于向量$ , , . . . , <span class="math inline">\(,我们称它们的所有线性组合所成的集合为\)</span> { ,
, . . . , } <span class="math inline">\(,也称为由\)</span> , , . . . ,
<span class="math inline">\(所**生成**的\)</span>V <span class="math inline">\(的子集,有时也记作\)</span> _1 , _2 , , _p $.</p>
<p>不难发现,$ <span class="math inline">\(集合是\)</span>V <span class="math inline">\(的一个子空间,而且容易证明其是包含\)</span>{ _1 ,
_2 , , _p } <span class="math inline">\(的最小的子空间,所以我们又称其为由\)</span> , , . .
. , $所<strong>生成</strong>的子空间.</p>
<p>可以考虑一些特殊线性空间上$ $的几何意义:</p>
<p>对于$ ^2 <span class="math inline">\(,当\)</span> <span class="math inline">\(和\)</span> <span class="math inline">\(不在一条直线上的时候,\)</span> { , }
$显然对应了整个平面.</p>
<p>对于$ ^3 <span class="math inline">\(,当\)</span> <span class="math inline">\(和\)</span> <span class="math inline">\(不在一条直线上的时候,\)</span> { , } <span class="math inline">\(显然对应了三维空间中的一个过\)</span> ,
$这两条直线的平面.</p>
<p>要判断$ <span class="math inline">\(是否在\)</span> { , , . . . , }
<span class="math inline">\(中，即判断向量方程\)</span>x _1 + x _2 + . .
. + x _p = $是否有解.</p>
<h5><span id="线性映射">线性映射</span></h5>
<p>映射$T : V W $是线性的,当且仅当它满足以下两个条件:</p>
<ol type="1">
<li><p>对$T <span class="math inline">\(的定义域中一切的向量\)</span> ,
<span class="math inline">\(,满足\)</span>T ( + ) = T ( ) + T ( )
$.</p></li>
<li><p>对$T <span class="math inline">\(的定义域中一切的向量\)</span>
<span class="math inline">\(和数\)</span>c <span class="math inline">\(,满足\)</span>T ( c ) = cT ( ) $.</p></li>
</ol>
<p>线性映射有以下性质:</p>
<ol type="1">
<li><p>$T ( ) = $.</p></li>
<li><p>(叠加原理):$T ( c _1 _1 + c _2 _2 + . . . + c _p _p ) = c _1 T (
_1 ) + c _2 T ( _2 ) + . . . + c _p T ( _p ) $.</p></li>
</ol>
<p>称线性映射$T : V W <span class="math inline">\(是**可逆的**或者**同构的**,当且仅当存在\)</span>T
^{ - 1 } : W V $.</p>
<p>我们可以验证$T ^{ - 1 } <span class="math inline">\(也是线性映射,原因在于此时\)</span>T $是双射:</p>
<p><span class="math display">\[
\begin{aligned}
T ^{ - 1  } ( \vec { w  } + \vec { w  } &#39; ) &amp; = T ^{ - 1  } (
\vec { w  } ) + T ^{ - 1  } ( \vec { w  } &#39; ) \\
\Leftrightarrow \\
T ( T ^{ - 1  } ( \vec { w  } + \vec { w  } &#39; ) ) &amp; = T ( T ^{ -
1  } ( \vec { w  } ) + T ^{ - 1  } ( \vec { w  } &#39; ) )
\end{aligned}
\]</span></p>
<p>而且:</p>
<p><span class="math display">\[
\begin{aligned}
T ^{ - 1  } ( t \vec { w  } ) &amp; = tT ^{ - 1  } ( \vec { w  } ) \\
\Leftrightarrow \\
T ( T ^{ - 1  } ( t \vec { w  } ) ) &amp; = T ( tT ^{ - 1  } ( \vec {
w  } ) )
\end{aligned}
\]</span></p>
<p>我们记$ ( V , W ) <span class="math inline">\(为所有的\)</span>V W
<span class="math inline">\(,并且其中的\)</span>V , W <span class="math inline">\(都是定义在\)</span>F <span class="math inline">\(上的线性空间的线性映射组成的集合.容易验证\)</span>
( V , W ) <span class="math inline">\(构成\)</span>F <span class="math inline">\(上的线性空间.特别地,定义\)</span> ( V ) = ( V , V
) <span class="math inline">\(,容易发现\)</span> ( V )
$是对复合和加法操作一个环.</p>
<p>特别地,定义矩阵映射$T : F ^n F ^m <span class="math inline">\(为\)</span>T ( ) = A <span class="math inline">\(,其中\)</span>A <span class="math inline">\(是一个\)</span>m n
$的矩阵.矩阵映射显然是线性映射.</p>
<h5><span id="基和维数">基和维数</span></h5>
<p>$V <span class="math inline">\(中子空间\)</span>H <span class="math inline">\(的一组**基**是\)</span>H <span class="math inline">\(中一个线性无关集,它生成\)</span>H $.</p>
<p>事实上,以下命题等价:</p>
<ol type="1">
<li><p>$S <span class="math inline">\(是\)</span>V $的一组基.</p></li>
<li><p>$S <span class="math inline">\(是极小的能生成\)</span>V <span class="math inline">\(的集合(不存在其的一个真子集能生成\)</span>V
$).</p></li>
<li><p>$S <span class="math inline">\(是极大的\)</span>V
$中的线性无关集(不存在其的一个真张集线性无关).</p></li>
</ol>
<p>证明上列命题等价是容易的.</p>
<p>对于$F ^n <span class="math inline">\(来说,其的基有更好的性质,我们称\)</span>{ _1 , . .
. , _n } , _i = { 0 , 0 , , 0 , 1 , 0 , } <span class="math inline">\(为\)</span>F ^n $的<strong>标准基</strong>.</p>
<p>对于$n m <span class="math inline">\(的矩阵组成的线性空间,其当然也有一组标准基\)</span>{
_{ i , j } } $.</p>
<p>有如下结论:</p>
<ol type="1">
<li><p>(承认选择公理)对于任何一个线性无关的子集$S <span class="math inline">\(,存在一个基\)</span> <span class="math inline">\(使得\)</span>S <span class="math inline">\(.特别地,取\)</span>S =
$可以说明任何一个线性空间总是有基.</p></li>
<li><p>(有限生成的情况)如果一个线性空间的子集$S <span class="math inline">\(满足\)</span>| S | &gt; | | <span class="math inline">\(,其中\)</span> <span class="math inline">\(是一组有限大小的基,那么\)</span>S
$线性相关.</p></li>
<li><p>如果一个线性空间有两组基$ , <span class="math inline">\(,那么\)</span>| | = | | $.</p></li>
</ol>
<p>现在考虑(1)的证明,拿出所有的线性无关的$T S <span class="math inline">\(并组成一个集合,用包含关系作为偏序关系,如果能证明其满足Zorn引理的条件,那当然可以取出一个极大的线性无关集合,这当然是一组基.为此我们取出一条链并且将上面的所有集合并起来得到一个集合\)</span>T
’ <span class="math inline">\(.此时就可以看出我们之前(几乎一笔略过的)要求从基扩张的时候只需要有限个元素的作用,它可以立刻断言\)</span>T
’ $是一个线性无关集合.</p>
<p>(2)的证明是容易的,不妨设$n = | | , m = | S | <span class="math inline">\(,由于\)</span>m &gt; n <span class="math inline">\(,这当然是一个\)</span>m <span class="math inline">\(个变量的大小为\)</span>n
$的方程组,当然存在不全为$0 $的解.</p>
<p>(3)的定义较为复杂,略过.</p>
<p>在上述定理的基础上,我们可以定义非零向量空间$V <span class="math inline">\(的**维数**,记作\)</span>V = | | <span class="math inline">\(,零子空间\)</span>{ } $的维数定义为$0 $.</p>
<p>一般而言,我们大部分情况下都只讨论有限生成的情况.</p>
<p>有限生成的情况,我们还有以下若干条定理:</p>
<ol start="4" type="1">
<li>(基定理)设$H <span class="math inline">\(是\)</span>V <span class="math inline">\(的\)</span>p <span class="math inline">\(维子空间,\)</span>H <span class="math inline">\(中任何恰好由\)</span>p <span class="math inline">\(个元素组成的线性无关集构成\)</span>H
$的一个基.</li>
</ol>
<p>这当然是自然的,根据上面的推导,这个线性无关集合就是极大的线性无关集合.</p>
<ol start="5" type="1">
<li>如果线性空间的子空间$V _0 V <span class="math inline">\(,那么\)</span>V _0 V <span class="math inline">\(.特别地,\)</span>V _0 = V V _0 = V $.</li>
</ol>
<p>只需要继续在$V _0 $里面取基就可以了.</p>
<ol start="6" type="1">
<li>$V <span class="math inline">\(定义在域\)</span>F <span class="math inline">\(上,如果\)</span>V = n <span class="math inline">\(,那么\)</span>V F ^n $.</li>
</ol>
<p>考虑$F ^n <span class="math inline">\(的一组标准基\)</span> , _n
<span class="math inline">\(,然后我们取出\)</span>V <span class="math inline">\(的一组有序基\)</span>B = { _1 , , _n } <span class="math inline">\(,然后把\)</span>T : F ^n V , k _i _i k _i _i
$.接下要当然要验证良定义和双射,通过基的定义是显然的.</p>
这可以引出所谓坐标表示,即:设$ = { _1 , . . . , _n } <span class="math inline">\(是\)</span>V <span class="math inline">\(的一个基,则\)</span> V <span class="math inline">\(,\)</span><span class="math inline">\(唯一的一组\)</span>{ c _1 , . . . , c _n } <span class="math inline">\(满足\)</span> = c _1 _1 + . . . + c _n _n <span class="math inline">\(.我们称\)</span>
<span class="math display">\[\begin{bmatrix}c _1 \\ \vdots \\ c _n
\end{bmatrix}\]</span>
<p><span class="math inline">\(是\)</span> <span class="math inline">\(的\)</span> - <span class="math inline">\(坐标向量,记作\)</span>[ x ] <em>{ } <span class="math inline">\(,映射\)</span>x </em>{ } <span class="math inline">\(称为由\)</span>
$确定的<strong>坐标映射</strong>.</p>
事实上,如果我们记$P _{ } =
<span class="math display">\[\begin{bmatrix}\vec { b  } _1 &amp; \vec {
b  } _2 &amp; \cdots &amp; \vec { b  } _n \end{bmatrix}\]</span>
<p><span class="math inline">\(,则我们有\)</span> = P <em>{ } [ x ]
</em>{ } <span class="math inline">\(.我们称\)</span>P _{ } <span class="math inline">\(为\)</span> $的坐标变换矩阵.</p>
<ol start="7" type="1">
<li>线性映射由它在基上的作用完全确定.</li>
</ol>
<p>原因是考虑$V <span class="math inline">\(的一组基\)</span>B = { _1 ,
, _n } <span class="math inline">\(,那么\)</span>T ( k _i _i ) = k _i T
( _i ) $.</p>
<ol start="8" type="1">
<li>$ ( V , W ) W ^n <span class="math inline">\(,其中\)</span>V = n
$.</li>
</ol>
<p>由(7),我们知道如果选定了$C = { _1 , _n }
$,则只需要考虑在基上的具体变换即可.</p>
<ol start="9" type="1">
<li>(线性映射同构于矩阵映射)如果$V , W <span class="math inline">\(都是定义在\)</span>F <span class="math inline">\(上的线性空间,\)</span>V = n , W = m <span class="math inline">\(,那么\)</span> ( V , W ) W ^n F ^{ m n } <span class="math inline">\(.更一般地,如果\)</span>V <span class="math inline">\(的基的指标集是\)</span>J <span class="math inline">\(,\)</span>W <span class="math inline">\(的基的指标集是\)</span>I <span class="math inline">\(.那么\)</span> ( V , W ) F ^{ I J } <span class="math inline">\(.另外地,\)</span> ( V , W ) = mn <span class="math inline">\(.特殊地,\)</span> ( V ) F ^{ n n } $.</li>
</ol>
<p>由(6)(8)显然.</p>
<p>现在我们就可以拿出矩阵了,我们在$F <span class="math inline">\(上定义\)</span>m n <span class="math inline">\(的矩阵\)</span>M <span class="math inline">\(,于是\)</span> = ( V , W ) M _{ m n } $.</p>
<p>简单来说,如果$B = { _1 , _n } <span class="math inline">\(是\)</span>V <span class="math inline">\(的一组基,\)</span>C = { _1 , _m } <span class="math inline">\(是\)</span>W <span class="math inline">\(的一组基,我们事实上是把\)</span> <em>j a </em>{ i
, j } _i $.</p>
<ol start="10" type="1">
<li>线性映射的复合同构于矩阵乘法.</li>
</ol>
<p>只需操演定义即可发现.</p>
<ol start="11" type="1">
<li>如果$F <span class="math inline">\(是\)</span>E <span class="math inline">\(的子域,那么\)</span>E <span class="math inline">\(是在\)</span>F <span class="math inline">\(上的向量空间.同样,如果\)</span>V <span class="math inline">\(是\)</span>E <span class="math inline">\(的向量空间,那么\)</span>V <span class="math inline">\(是\)</span>F $的向量空间.</li>
</ol>
<p>定义的简单操演.</p>
<ol start="12" type="1">
<li>如果$V <span class="math inline">\(是\)</span>E <span class="math inline">\(的向量空间,基为\)</span>B <span class="math inline">\(,\)</span>E <span class="math inline">\(是\)</span>F <span class="math inline">\(的向量空间,基为\)</span>C <span class="math inline">\(.那么\)</span>V <span class="math inline">\(是\)</span>F <span class="math inline">\(的向量空间,而且基是\)</span>CB <span class="math inline">\(.作为其的一个推论,如果我们定义\)</span>[ V : E ] =
_E V <span class="math inline">\(,即在\)</span>E <span class="math inline">\(上的\)</span>V <span class="math inline">\(的维数.我们应当能见到\)</span>[ V : F ] = [ V : E
] [ E : F ] $.</li>
</ol>
<p>定义的简单操演.可以将这里理解为$[ V : F ] = _F V $这个样子.</p>
<h4><span id="可逆矩阵">可逆矩阵</span></h4>
<p>称一个$n n <span class="math inline">\(的矩阵\)</span>A <span class="math inline">\(是**可逆的**,当且仅当\)</span>C <em>{ n n } <span class="math inline">\(满足\)</span>CA = AC = I </em>{ n } <span class="math inline">\(,我们记\)</span>C = A ^{ - 1 } <span class="math inline">\(.其实也就是\)</span>F _{ n n }
$这个环上的可逆元.这当然意味着其对应的线性映射是可逆的,也就是其代表的线性映射是同构.</p>
<p>不可逆矩阵又被称为<strong>奇异矩阵</strong>.</p>
<p>事实上$m n <span class="math inline">\(的矩阵\)</span>A <span class="math inline">\(在\)</span>m n <span class="math inline">\(的时候当然是不可逆的,因为其代表的线性映射不可能是同构(不然两边的\)</span><span class="math inline">\(应当相等,应当有\)</span>m = n $).</p>
<p>可逆矩阵有以下简单性质:</p>
<ol type="1">
<li><p>若$A <span class="math inline">\(是可逆方阵,则\)</span>A ^{ - 1 }
<span class="math inline">\(也可逆且\)</span>( A ^{ - 1 } ) ^{ - 1 } = A
$.</p></li>
<li><p>若$A <span class="math inline">\(和\)</span>B <span class="math inline">\(都是可逆方阵,则\)</span>AB <span class="math inline">\(也可逆且\)</span>( AB ) ^{ - 1 } = B ^{ - 1 } A ^{
- 1 } $.</p></li>
</ol>
<h5><span id="初等矩阵">初等矩阵</span></h5>
<p>将单位矩阵经过一次初等行变换得到的矩阵称作<strong>初等矩阵</strong>.</p>
<p>对任意$m n
$矩阵进行初等行变换一定等价于将其左乘一个初等矩阵,原因在于只需要对单位矩阵验证以下性质即可.</p>
<ol type="1">
<li>倍加变换:$R _i + kR _j R _i , i j $:</li>
</ol>
$$
<span class="math display">\[\begin{aligned}
E _{ x , y  } &amp; = \begin{cases}
k &amp; x = i , y = j \\
1 &amp; x = y \\
0 &amp; \text { Otherwise  }
\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<ol start="2" type="1">
<li>对换变换:$R _i R _j $:</li>
</ol>
$$
<span class="math display">\[\begin{aligned}
E _{ x , y  } &amp; = \begin{cases}
1 &amp; x = i , y = j \\
1 &amp; x = j , y = i \\
1 &amp; x = y , x \ne i , x \ne j \\
0 &amp; \text { Otherwise  }
\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<ol start="3" type="1">
<li>倍乘变换:$kR _i R _i , k $:</li>
</ol>
$$
<span class="math display">\[\begin{aligned}
E _{ x , y  } &amp; = \begin{cases}
k &amp; x = y , x = i \\
1 &amp; x = y , x \ne i \\
0 &amp; \text { Otherwise  }
\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑如下事实:行变换是可逆的,那么初等矩阵显然是可逆的.</p>
<p>这引出下面的定理:</p>
<p>$n n <span class="math inline">\(矩阵是可逆的,当且仅当\)</span>A
<span class="math inline">\(行等价于\)</span>I _n <span class="math inline">\(,也即\)</span>A <span class="math inline">\(可以通过一系列初等行变换变换为\)</span>I _n $.</p>
<p>如果$A <span class="math inline">\(可以通过一系列初等行变换变换为\)</span>I _n
$,根据初等矩阵的知识,这等价于:</p>
<p>$E _1 E _2 . . . E _p A = I _n <span class="math inline">\(,由于初等矩阵显然可逆,我们有\)</span>A = ( E <em>1
E </em>{ 2 } . . . E _p ) ^{ - 1 } <span class="math inline">\(,有\)</span>A ^{ - 1 } = ( E _1 E _2 . . . E _p )
$.</p>
<p>如果$A <span class="math inline">\(是可逆矩阵,显然\)</span>A <span class="math inline">\(的简化阶梯形是\)</span>I $,也即二者行等价.</p>
<p>由于初等矩阵转置后仍然是初等矩阵,所以$A <span class="math inline">\(可逆等价于\)</span>A ^T <span class="math inline">\(可逆.此时发现列变换等价于右乘初等矩阵.此外\)</span>(
A ^T ) ^{ - 1 } = ( A ^{ - 1 } ) ^T $.</p>
<h5><span id="求解逆矩阵">求解逆矩阵</span></h5>
若$A <span class="math inline">\(可逆,我们考虑将\)</span>A <span class="math inline">\(和\)</span>I <span class="math inline">\(放在同一个\)</span>n n <span class="math inline">\(的矩阵中,记作\)</span>
<span class="math display">\[\begin{bmatrix}A &amp; I
\end{bmatrix}\]</span>
<span class="math inline">\(,它显然行等价于\)</span>
<span class="math display">\[\begin{bmatrix}I &amp; A ^{ - 1  }
\end{bmatrix}\]</span>
<p>$.</p>
另外,考虑将$I <span class="math inline">\(写作\)</span>
<span class="math display">\[\begin{bmatrix}\vec { e _1  } &amp; \vec {
e _2  } &amp; . . . &amp; \vec { e _n  } \end{bmatrix}\]</span>
<span class="math inline">\(的形式,则我们发现上述过程等价于求若干个形如\)</span>A
_i = _i <span class="math inline">\(的方程的解,并且\)</span>A ^{ - 1 } =
<span class="math display">\[\begin{bmatrix}\vec { x _1  } &amp; \vec {
x _2  } &amp; . . . &amp; \vec { x _n  } \end{bmatrix}\]</span>
<p>$.</p>
<h6><span id="example1lu分解">Example1(LU分解)</span></h6>
<p>考虑上面对一个矩阵做的过程,考虑把一个矩阵消成上三角的.在此过程中如果没有发生行交换操作,那所做的操作就是一列下三角的操作.因此可以把一个矩阵分解为$A
= LU $.当然这里有一些条件才能进行,回头我们再讨论此.</p>
<h4><span id="核与像与秩">核与像与秩</span></h4>
<p>选取$T : V W <span class="math inline">\(为线性映射,定义\)</span>T =
T ^{ - 1 } ( 0 ) <span class="math inline">\(,\)</span>  T = T ( V )
$.</p>
<p>容易证明$T <span class="math inline">\(是\)</span>V <span class="math inline">\(的线性子空间,\)</span>  T <span class="math inline">\(是\)</span>W $的线性子空间.</p>
<p>对于任意$w T <span class="math inline">\(,选取任意一个特解\)</span>v
_0 V , T ( v _0 ) = w <span class="math inline">\(,那么容易看出\)</span>T ^{ - 1 } ( w ) = v _0 + T
<span class="math inline">\(.于是\)</span>T <span class="math inline">\(是单射当且仅当\)</span>T = { 0 } $.</p>
<p>当$V <span class="math inline">\(有限的时候,我们有\)</span>V = T +  T
$.</p>
<p>原因是可以选取$  T <span class="math inline">\(的一组基\)</span>{ _1
, _r } <span class="math inline">\(,找到其原像\)</span>B = { _1 , , _r }
<span class="math inline">\(,再取\)</span>T <span class="math inline">\(的一组基\)</span>C = { _1 , _s } $.</p>
<p>先来证明$B C <span class="math inline">\(是线性无关的.也就是考察\)</span>a _j _j + b _i _i
= 0 <span class="math inline">\(.此时两边取像,当然有\)</span>a _j _j + 0
= 0 <span class="math inline">\(,于是所有的\)</span>a _j = 0 <span class="math inline">\(.此时考虑\)</span>T <span class="math inline">\(是\)</span>V $的子空间,所以当$0 + b _i _i = 0
<span class="math inline">\(的时候也可以推出所有的\)</span>b _i = 0
$.</p>
<p>再来证明它确实可以生成$V <span class="math inline">\(.考虑\)</span> V
<span class="math inline">\(,首先\)</span>T ( ) = a _j _j <span class="math inline">\(,这当然是可以找到的.那么\)</span>T ( - a _j _j ) =
0 <span class="math inline">\(,于是\)</span> - a _j _j T <span class="math inline">\(,于是\)</span> - a _j _j = b _i _i <span class="math inline">\(,这就证毕了.利用下面直和分解的原理也可以写作\)</span>T
T V $.</p>
<p>而我们知道$T <span class="math inline">\(的单性等价于\)</span>T = 0
<span class="math inline">\(,满性等价于\)</span>  T = W = V <span class="math inline">\(,于是\)</span>W = V $时单性等价于满性.</p>
<p>这样的话我们定义一个线性映射的秩$  T = (  T ) $.</p>
<p>我们来看一个特殊情况$T : F ^n F ^m <span class="math inline">\(.那此时我们就可以定义这个映射所代表的矩阵\)</span>M
<span class="math inline">\(的秩.我们注意到\)</span>  T = { M <em>1 , M
</em>{ n } } = { _1 , , _n } <span class="math inline">\(.也就是\)</span>  M <span class="math inline">\(其实就是列向量生成的空间的维度.特别地,如果\)</span>
 M = ( n , m ) <span class="math inline">\(,那么我们称矩阵是满秩的.也就等于其消成简化阶梯型矩阵后的主元数量.那此时\)</span>T
= n -  M $.</p>
<p>容易从上面看出$ ( ST ) ( S , T ) <span class="math inline">\(.且当\)</span>T <span class="math inline">\(是满的时候\)</span> ( ST ) = ( S ) <span class="math inline">\(,当\)</span>S <span class="math inline">\(是单的时候\)</span> ( ST ) = ( T ) $.</p>
<h5><span id="sylvester秩不等式">Sylvester秩不等式</span></h5>
<p>考虑$T : U V , S : V W <span class="math inline">\(,则\)</span> ( ST
)  S +  T - V =  T - ( V -  S ) <span class="math inline">\(.可以认为后者\)</span>V -  S <span class="math inline">\(实际上是\)</span>S <span class="math inline">\(这个映射所带来的维度损失(\)</span>S <span class="math inline">\(),而这个损失有可能叠到\)</span>T <span class="math inline">\(上也可能不叠到\)</span>T $上.</p>
<p>对于其证明,考虑$ ( ST ) <span class="math inline">\(实际上应当是\)</span>S :  T W <span class="math inline">\(的秩,这给出\)</span> ( ST ) =  T - (  T S ) $.</p>
<p>而$(  T S ) S = V -  S $.于是得证.</p>
<p>其一个特例是$ ( ST ) = 0 <span class="math inline">\(时给出\)</span>V
 S +  T $.</p>
<p>在上述式子左右两边进行简单变形:</p>
<p><span class="math display">\[
\begin{aligned}
\text { rk  } ( ST ) &amp; \geq \text { rk  } \ T - \dim \ker S \\
\dim U - \text { rk  } ( T ) &amp; \geq \dim U - \text { rk  } \ ( ST )
- \dim \ker S \\
\ker T + \ker S &amp; \geq \ker ( ST )
\end{aligned}
\]</span></p>
<p>换言之就是线性映射的$$扩张的过程中可能会出现包含的情况,所以扩不到简单相加的情形.</p>
<h5><span id="frobenius秩不等式">Frobenius秩不等式</span></h5>
<p>有$ ( ABC ) ( AB ) + ( BC ) - B $.</p>
<p>不妨设$B : U V $,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\text { rk  } ( ABC ) &amp; = \text { rk  } ( BC ) - \dim ( \text {
im  } ( BC ) \cap \ker A ) \\
&amp; \geq \text { rk  } ( BC ) - \dim ( \text { im  } ( B ) \cap \ker A
) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们事实上有$ ( AB ) =  B - ( B A ) $,于是上述式子得证.</p>
<p>仍然对上式进行变形:</p>
<p><span class="math display">\[
\ker ( AB ) + \ker ( BC ) \geq \ker ( ABC ) + \ker ( B )
\]</span></p>
<p>这个式子还不能简单从Sylvester不等式推导,但可以见到这仍然是关于$$扩张上的意义.</p>
<h4><span id="对偶空间">对偶空间</span></h4>
<p>定义<strong>对偶空间</strong>$V ^* = ( V , F ) <span class="math inline">\((也可以记作\)</span> <span class="math inline">\(),其中\)</span>V <span class="math inline">\(是定义在\)</span>F
$上的向量空间.对偶空间当然是线性空间.</p>
<p>当线性空间是有限维的时候.我们考虑以下事实:</p>
<p>取$V <span class="math inline">\(的一组基\)</span>B = { _1 , , _n }
<span class="math inline">\(,我们考虑取\)</span> _i V ^<span class="math inline">\(使得\)</span> _i ( ) = a _i <span class="math inline">\(,当\)</span> = _j a _j _j <span class="math inline">\(.容易验证它们构成一组**对偶基**,这告诉我们\)</span>V
= V ^$.</p>
<p>特别地,当$V = F ^n <span class="math inline">\(的时候,容易验证如果取标准基\)</span>B
$,那么得到的对偶基实际上等价于标准基的转置(也就是列向量改为行向量).这可能会给我们带来错觉,认为对偶空间无非是行向量组成的空间,但如此理解有所偏差.既然是向量空间,就应当理解为列向量,否则线性变换理解为矩阵乘法就会收到阻碍,只是其作用效果等价于先转置为行向量再作矩阵乘法.</p>
<p>如果$T : V W <span class="math inline">\(是线性映射,那我们可以定义其**转置映射**\)</span>^t
T : W ^V ^, T <span class="math inline">\(.容易验证转置映射仍然是线性映射.另外,如果\)</span>S
, T <span class="math inline">\(均是线性映射,那么\)</span>^t { ( ST ) }
=  ^t { T } ^t { S } $.简单画一下交换图表:</p>
<p><span class="math display">\[
\xymatrix { V \ar [d ] \ar [r ] ^T &amp; W \ar [d ] \\
\check { V  } &amp; \check { W  } \ar [l ] _{ T ^t  }  }
\]</span></p>
<p>我们接下来说明转置映射对应的矩阵是原映射的矩阵的转置.</p>
<p>不妨设$V = n , W = m <span class="math inline">\(,原矩阵为\)</span>A
_{ m n } $.</p>
<p>接下来看它们分别对对应基的操作:</p>
<p>不妨设$T ( <em>j ) = a </em>{ i , j } _i <span class="math inline">\(,则\)</span>^t T ( _i ) $代表一个映射:</p>
<p><span class="math display">\[
\begin{aligned}
\vec { v  } _k \mapsto \check { w _i  } T ( \vec { v  } _k ) \\
&amp; = \check { w _i  } ( \sum _h a _{ h , k  } w _h ) \\
&amp; = \sum _h a _{ h , k  } \check { w  } _i ( w _h ) \\
&amp; = a _{ i , k  } \\
&amp; = \sum _{ j  } a _{ i , j  } \check { v  } _j ( \vec { v  } _k )
\end{aligned}
\]</span></p>
<p>因此$^t T ( <em>i ) = </em>{ j } a _{ i , j } _j $.</p>
<p>如果我们将$$看成一个$1 m <span class="math inline">\(的矩阵,那\)</span>T <span class="math inline">\(不言自明为矩阵乘法.然而正是我们试图总是将空间表示为列向量,因此我们就自然带了一个转置,对于一个\)</span>
<span class="math inline">\(,我们对它实际上求的是乘法\)</span>^t ( T ) =
( ^t T ) ( ^t ) $的结果,如此一来上述结论便显明了.</p>
<p>我们会在后面谈论矩阵的相抵的部分证明行秩等于列秩这一事实,然而,既然转置实际上表现了对偶空间上的性质,我们理应可以抛开矩阵本身而只从对偶空间的角度理解.换言之,取对偶基是一种非典范的无奈之举,我们会在讨论双线性形式的时候重新讨论于此.</p>
<h4><span id="直和分解与分块矩阵">直和分解与分块矩阵</span></h4>
<p>不妨取映射$: _{ i I } V _i V , ( v <em>i ) </em>{ i I } v _i <span class="math inline">\(,其中\)</span>V _i <span class="math inline">\(都是\)</span>V <span class="math inline">\(的子空间.容易验证其当且仅当在\)</span>V <em>i (
</em>{ i j } V _j ) = { 0 } <span class="math inline">\(时是单射.我们将此称作其**直和分解**.如果不满足上述条件一般称作**外直和**,满足的话则称作**内直和**,并容易发现内直和\)</span>V
_i V _i $.</p>
<p>外直和的一个经典应用是构造$: V _1 V _2 V , ( _1 , _2 ) _1 - _2 <span class="math inline">\(的映射,立刻得到\)</span>= V _1 V _2 ,  = V _1 + V
_2 <span class="math inline">\(,于是\)</span>V _1 + V _2 = ( V _1 V _2 )
+ ( V _1 + V _2 ) $.这其实就是第二同构定理的维数表示.</p>
<p>接下来考虑$V = _{ i = 1 } ^n V <em>i , W = </em>{ j = 1 } ^m W <em>j
<span class="math inline">\(,我们可以断言\)</span> ( V , W ) </em>{ 1 i
n , 1 j m } ( V _i , W _j ) <span class="math inline">\(.这个的证明只需定义算子\)</span>p <em>i : </em>{ j
} V _j V , ( <em>j ) </em>{ j J } _i $即可.</p>
<p>对于对偶空间,事实上取$W = F <span class="math inline">\(,就会有\)</span>V ^V _i ^$.</p>
<p>接下来考虑映射的合成$T : U V , S : V W <span class="math inline">\(.不妨设\)</span>U U _k , V <em>j V <em>j , W <em>i
W <em>i <span class="math inline">\(,容易验证\)</span>( ST ) </em>{ i ,
k } = </em>{ j } S </em>{ i , j } T </em>{ j , k } $.</p>
<p>此时我们终于意识到了这个东西应当同构于分块矩阵.更具体地,$ ( V , W ) A
<em>{ n m } , A </em>{ j , i } T <em>{ j , i } , A </em>{ j , i } M _{ m
_j n _i } , m _j = W _j , n _i = V _i $.</p>
<p>容易类比普通矩阵定义对角线分块矩阵,上(下)三角分块矩阵之类的东西.并且还容易发现上三角矩阵相乘后仍是上三角,对角线矩阵相乘后仍是对角线.</p>
<p>如果考虑$T ( V ) <span class="math inline">\(,事实上对角线矩阵有相当漂亮的刻画,只需观察矩阵结构就可以发现此时\)</span>T
( V _i ) V _i <span class="math inline">\(.上三角矩阵有类似的刻画,观察矩阵结构也可以发现\)</span>T
( V <em>i ) </em>{ j i } V _j $.</p>
<p>下面我们来证明对于上三角分块矩阵$A <em>{ r r } <span class="math inline">\(,如果对角线上的\)</span>A </em>{ i i } <span class="math inline">\(均可逆,那么\)</span>A <em>{ r r } <span class="math inline">\(的分块矩阵可逆,而且其逆的对角线上的矩阵是一列\)</span>A
</em>{ i i } ^{ - 1 } $.</p>
考虑数学归纳,这样的话就只需要证明$
<span class="math display">\[\begin{bmatrix}A _{ 1 , 1  } &amp; A _{ 1 ,
2  } \\ 0 &amp; A _{ 2 , 2  } \end{bmatrix}\]</span>
<span class="math inline">\(,其中\)</span>A <em>{ 1 , 1 } <span class="math inline">\(和\)</span>A </em>{ 2 , 2 } <span class="math inline">\(均可逆即可.容易发现取\)</span>
<span class="math display">\[\begin{bmatrix}A _{ 1 , 1  } ^{ - 1  }
&amp; - A _{ 1 , 1  } ^{ - 1  } A _{ 1 , 2  } A _{ 2 , 2  } ^{ - 1  } \\
0 &amp; A _{ 2 , 2  } ^{ - 1  } \end{bmatrix}\]</span>
<p>$即可.</p>
那么反之成不成立呢?是不是此时按照合理的分块方式一定能得到对角线上的矩阵都可逆呢?也是可行的.假设$
<span class="math display">\[\begin{bmatrix}A _{ 1 , 1  } &amp; A _{ 1 ,
2  } \\ 0 &amp; A _{ 2 , 2  } \end{bmatrix}\]</span>
<span class="math inline">\(可逆,其逆为\)</span>
<span class="math display">\[\begin{bmatrix}A _{ 1 , 1  } &#39; &amp; A
_{ 1 , 2  } &#39; \\ A _{ 2 , 1  } &#39; &amp; A _{ 2 , 2  } &#39;
\end{bmatrix}\]</span>
<p>$.容易发现:</p>
$$
<span class="math display">\[\begin{aligned}
\begin{bmatrix}
A _{ 1 , 1  } &#39; &amp; A _{ 1 , 2  } &#39; \\
A _{ 2 , 1  } &#39; &amp; A _{ 2 , 2  } &#39;
\end{bmatrix} \begin{bmatrix}
A _{ 1 , 1  } &amp; A _{ 1 , 2  } \\
0 &amp; A _{ 2 , 2  }
\end{bmatrix} = \begin{bmatrix}
A _{ 1 , 1  } A _{ 1 , 1  } &#39; &amp; \_ \\
\_ &amp; \_
\end{bmatrix} \\
\begin{bmatrix}
A _{ 1 , 1  } &amp; A _{ 1 , 2  } \\
0 &amp; A _{ 2 , 2  }
\end{bmatrix} \begin{bmatrix}
A _{ 1 , 1  } &#39; &amp; A _{ 1 , 2  } &#39; \\
A _{ 2 , 1  } &#39; &amp; A _{ 2 , 2  } &#39;
\end{bmatrix} = \begin{bmatrix}
\_ &amp; \_ \\
\_ &amp; A _{ 2 , 2  } A &#39; _{ 2 , 2  }
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是立刻见到$A <em>{ 1 , 1 } <span class="math inline">\(和\)</span>A
</em>{ 2 , 2 } $都有逆.</p>
<h4><span id="基的变换">基的变换</span></h4>
<h5><span id="矩阵的共轭相似">矩阵的共轭(相似)</span></h5>
<p>考虑线性映射$T : V W <span class="math inline">\(,这个线性映射理应和所取的基无关,但如果我们想写出它的矩阵形式,写出来的矩阵当然取决于\)</span>V
<span class="math inline">\(和\)</span>W <span class="math inline">\(取的基分别是什么(从而决定不同的坐标).不妨设\)</span>V
, W <span class="math inline">\(都是定义在\)</span>F <span class="math inline">\(上的,维度分别为\)</span>n , m <span class="math inline">\(.现在取它们的有序基\)</span> = { _1 , , <em>n }
<span class="math inline">\(,\)</span> = { <em>1 , , <em>m } <span class="math inline">\(,这样就可以确定一个同构\)</span> </em>{ } : ( V ,
W ) M </em>{ m n } <span class="math inline">\(.再构造一个同构\)</span></em>{ } : F ^n V , ( x _1
, , x _n ) x _i _i
$.然后我们可以画出如下交换图表(对其交换性的验证可以直接考虑对每个基验证交换性):</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^T &amp; W \\
F ^n \ar [u ] ^{ \varphi _{ \mathcal { B  }  }  } \ar [r ] _{ \mathcal {
M  } _{ \mathcal { B  } \to \mathcal { C  }  } ( T )  } &amp; F ^m \ar
[u ] _{ \varphi _{ \mathcal { C  }  }  }  }
\]</span></p>
<p>如果我们尝试考虑更换它们的基,理论上说当然会得到不同的矩阵.换言之,我们取另一组有序基$
’ = { _1 ’ , , _n ’ } , ’ = { _1 ’ , , <em>m ’ } <span class="math inline">\(,这样可以确定另一个同构\)</span> </em>{ B ’ C ’ }
$.我们下面试图探索二者之间的关系.</p>
<p>由于选取的有序基的方式不同,我们再构造一个$P _{ B ’ B } : ( F ^n ) ’ F
^n , ( x ’ _1 , , x ’ _n ) ( x _1 , x _n ) , x ’ _i ’ <em>i = x <em>i
<em>i <span class="math inline">\(,容易验证取\)</span>P </em>{ V ’ V } =
{ ( <em>V ) } ^{ - 1 } </em>{ V ’ } <span class="math inline">\(即可并且是自同构,并且\)</span>( P </em>{ V V ’ } )
^{ - 1 } = P </em>{ V ’ V } $.写成交换图表的话应当形如:</p>
<p><span class="math display">\[
\xymatrix { &amp; V &amp; \\
( F ^n ) &#39; \ar [ru ] ^{ \varphi _{ \mathcal { B  } &#39;  }  } \ar
[rr ] _{ P _{ \mathcal { B  } &#39; \to \mathcal { B  }  }  } &amp;
&amp; F ^n \ar [lu ] _{ \varphi _{ \mathcal { B  }  }  }  }
\]</span></p>
<p>这里所有的箭头当然都是可逆的.</p>
<p>事实上,不妨设$ <em>i ’ = </em>{ j } p _{ j , i } <em>j <span class="math inline">\(,也就是将\)</span> ’ <span class="math inline">\(展开成列向量,对于\)</span> = </em>{ i } x ’ _i ’
<em>i <span class="math inline">\(,考虑\)</span></em>{ i } x ’ <em>i ’
<em>i = </em>{ i } x ’ <em>i </em>{ j } p </em>{ j , i } <em>j = </em>{
j } <em>j </em>{ i } x ’ <em>i p </em>{ j , i } = <em>j <em>j x <em>j
<span class="math inline">\(,那么\)</span>p </em>{ j , i } <span class="math inline">\(其实就是\)</span>P </em>{ ’ } <span class="math inline">\(的对应矩阵的第\)</span>j <span class="math inline">\(行\)</span>i <span class="math inline">\(列元素.此时我们称\)</span>P </em>{ n n } <span class="math inline">\(为从有序基\)</span>B ’ B
$的<strong>转换矩阵</strong>.事实上容易见到转换矩阵都是可逆的,并且事实上所有的可逆矩阵都可以看作标准基对某个矩阵的转换矩阵.</p>
<p>这样的话,我们就容易见到:$ <em>{ B ’ C ’ } ( T ) = P </em>{ C C ’ }
<em>{ B C } ( T ) P </em>{ B ’ B } = ( P <em>{ C ’ C } ) ^{ - 1 } </em>{
B C } ( T ) P <em>{ B ’ B } <span class="math inline">\(.这里一定要注意\)</span> </em>{ B C } <span class="math inline">\(是一个将映射\)</span>T <span class="math inline">\(变为矩阵\)</span>M $的映射.</p>
<p>具体地,我们可以看下面的交换图表:</p>
<p><span class="math display">\[
\xymatrix { ( F ^n ) &#39; \ar [rrr ] ^{ \mathcal { M  } _{ B &#39; \to
C &#39;  } ( T )  } \ar [dd ] _{ P _{ B &#39; \to B  }  } \ar [rd ] ^{
\varphi _{ B &#39;  }  } &amp; &amp; &amp; ( F ^m ) &#39; \ar [dd ] ^{ P
_{ C &#39; \to C  }  } \ar [ld ] _{ \varphi _{ C &#39;  }  } \\
&amp; V \ar [r ] ^T &amp; W \\
F ^n \ar [rrr ] _{ \mathcal { M  } _{ B \to C  } ( T )  } \ar [ru ] _{
\varphi _B  } &amp; &amp; &amp; F ^m \ar [lu ] ^{ \varphi _C  }  }
\]</span></p>
<p>接下来我们考虑$T ( V ) <span class="math inline">\(,自然可以导出\)</span> <em>{ B ’ B ’ } ( T ) = P
^{ - 1 } </em>{ B B } ( T ) P <span class="math inline">\(,其中\)</span>P = P _{ B ’ B } $.</p>
<p>于是综上,我们称两个矩阵$A <em>{ n n } , B </em>{ n n } <span class="math inline">\(相似,当且仅当存在可逆矩阵\)</span>P _{ n n } <span class="math inline">\(使得\)</span>A = P ^{ - 1 } BP
$.由上面可以看出来,相似的两个矩阵实际上是不同基下的同种变换.</p>
<p>另外我们注意到,固定$P <em>{ n n } <span class="math inline">\(后定义映射\)</span>P : M </em>{ n n } M _{ n n } ,
A P ^{ - 1 } AP
$不仅仅是线性同构,还是一个环同构.容易验证其满足环同构的性质.</p>
<p>此时注意到另一个事情:我们知道我们做共轭实际上是换基操作,那么如果我们需要换基,难道我们必须总是对着矩阵做矩阵乘法么?</p>
<p>事实上,我们应当观察如下矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}
&amp; \vec { e  } _1 &amp; \cdots &amp; \vec { e  } _n \\
\vec { e  } _1 &amp; a _{ 1 , 1  } &amp; \cdots &amp; a _{ n , 1  } \\
\vdots &amp; \cdots &amp; \ddots &amp; \vdots \\
\vec { e  } _n &amp; a _{ 1 , n  } &amp; \cdots &amp; a _{ n , n  }
\end{bmatrix}
\]</span></p>
<p>最简单的改变,我们如果想要让它变成在另一组有序基下的操作,我们应当如何操作呢?如果我们带着这些向量去做,我们实际上可以发现:放在列上的这些向量随着列变换而操作,放在行上的这些向量随着行变换的逆变换而改变.这就是更加方便的做相似矩阵的办法.而这事实上也就是因为,任何一个可逆的矩阵都可以拆成若干初等矩阵,因此只需要将$P
$拆成初等矩阵两边分别做就可以.初等矩阵求逆当然是平凡的.</p>
<h5><span id="矩阵的相抵">矩阵的相抵</span></h5>
<p>我们称两个矩阵$A <span class="math inline">\(和\)</span>B <span class="math inline">\(**相抵**,当且仅当\)</span>P , Q <span class="math inline">\(均可逆,\)</span>A = PBQ <span class="math inline">\(.容易看出相抵是等价关系.由于可逆矩阵等价于若干初等矩阵的乘积,那么\)</span>A
, B <span class="math inline">\(相抵当且仅当\)</span>B <span class="math inline">\(可以通过若干初等行变换和列变换变成\)</span>A <span class="math inline">\(.下面我们证明\)</span>A , B <span class="math inline">\(相抵等价于\)</span>  A =  B $.</p>
<p>$A , B <span class="math inline">\(相抵的时候当然有\)</span>  A =  B
<span class="math inline">\(,因为此时\)</span>  A = <span class="math inline">\(,而\)</span>P , Q <span class="math inline">\(都是同构,所以此时有\)</span>  A =  B =  B $.</p>
当$  A =  B = k <span class="math inline">\(时,我们考虑二者都可以经过若干次行变换或者列变换变成形如\)</span>m
_{ i , j } =
<span class="math display">\[\begin{cases}1 &amp; i = j \leq k \\ 0
&amp; \text { otherwise  } \end{cases}\]</span>
<p>$.于是二者等价.</p>
<p>类似上面就可以发现$  A =  A ^T
$,原因是二者都可以消成上述那种矩阵,而那种矩阵的主元数量显然是确定且相等的.</p>
用矩阵的相抵可以更快证明Frobenius秩不等式,具体地,考虑分块矩阵$
<span class="math display">\[\begin{bmatrix}ABC &amp; 0 \\ 0 &amp; B
\end{bmatrix}\]</span>
<span class="math inline">\(.考虑\)</span>
<span class="math display">\[\begin{bmatrix}I &amp; - A \\ 0 &amp; I
\end{bmatrix} \begin{bmatrix}ABC &amp; 0 \\ 0 &amp; B \end{bmatrix}
\begin{bmatrix}I &amp; 0 \\ C &amp; I \end{bmatrix}\]</span>
=
<span class="math display">\[\begin{bmatrix}0 &amp; - AB \\ BC &amp; B
\end{bmatrix}\]</span>
<span class="math inline">\(,于是我们知道\)</span>
<span class="math display">\[\begin{bmatrix}ABC &amp; 0 \\ 0 &amp; B
\end{bmatrix}\]</span>
<span class="math inline">\(和\)</span>
<span class="math display">\[\begin{bmatrix}0 &amp; - AB \\ BC &amp; B
\end{bmatrix}\]</span>
<p>$相抵.</p>
而$  
<span class="math display">\[\begin{bmatrix}ABC &amp; 0 \\ 0 &amp; B
\end{bmatrix}\]</span>
=  ABC +  B <span class="math inline">\(,下面考虑证明\)</span>  
<span class="math display">\[\begin{bmatrix}0 &amp; - AB \\ BC &amp; B
\end{bmatrix}\]</span>
<p>  AB +  BC <span class="math inline">\(,而直接考虑\)</span>BC <span class="math inline">\(和\)</span>AB <span class="math inline">\(的行,\)</span>BC <span class="math inline">\(中线性无关行和\)</span>AB <span class="math inline">\(中线性无关行必定也线性无关,而原本线性相关的那些加上右下角的\)</span>B
$也有可能变得线性无关,于是上述不等式就得证了.</p>
<h4><span id="商空间">商空间</span></h4>
<p>如果我们考虑在线性空间上定义等价关系$ _1 _2 T _1 = T _2 <span class="math inline">\(,其中\)</span>T <span class="math inline">\(是一个线性映射,容易发现此时\)</span> _1 - _2 T
<span class="math inline">\(.所以其实和\)</span>T <span class="math inline">\(本身关系不大,而只和\)</span>T $这个子空间有关.</p>
<p>那我们不妨设$U <span class="math inline">\(是\)</span>V <span class="math inline">\(的子空间,立刻发现\)</span> _1 _2 ( _1 - _2 ) U
$是一个等价关系.</p>
<p>在此基础上定义<strong>陪集</strong>$ + U <span class="math inline">\(,容易发现陪集组成了一个新的线性空间(当然要验证良定义),将其称作**商空间**,并且可验证映射\)</span>:
V V / U , + U <span class="math inline">\(是线性映射.类比陪群,得知\)</span>= U <span class="math inline">\(,综合前面的讨论得知此时\)</span> _1 _2 _1 + U = _2
+ U $.</p>
<p>顺便可以顺手引入<strong>余核</strong>$ ( T ) = W /  T <span class="math inline">\(,容易发现\)</span>T <span class="math inline">\(是满射当且仅当\)</span> ( T ) = { 0 } $.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>下面来抛出另一个命题.对于线性映射$T : V W , : V V / U <span class="math inline">\(,如果\)</span>U T <span class="math inline">\(,那么存在唯一的线性映射\)</span>{ T } : V / U W
<span class="math inline">\(.使得\)</span>T = { T } $.</p>
<p>这个证明看上去是相当正确的.由于$<span class="math inline">\(是满射,那么必定有\)</span>{ T } ( + U ) = T <span class="math inline">\(,这是显然是唯一的映射,也容易看出其是正确的线性映射.具体来讲,存在唯一的线性映射\)</span>{
T } $使得下图交换:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^T \ar [d ] _\varphi &amp; W \\
V / U \ar [ru ] _{ \bar { T  }  }  }
\]</span></p>
<p>在上述命题中如果$T <span class="math inline">\(也是满射,也就是\)</span>W =  T <span class="math inline">\(,取\)</span>U = T <span class="math inline">\(,那么此时\)</span>{ T } = T <span class="math inline">\(,这必定意味着\)</span>  { T } = W <span class="math inline">\(.接下来考虑一下\)</span>{ T } <span class="math inline">\(的模样,考虑\)</span>{ T } ( + U ) = 0 T ( ) = 0 U
+ U = U <span class="math inline">\(,从而\)</span>{ T } = { U } <span class="math inline">\(,于是\)</span>{ T } $是同构.</p>
<p>就可以发现对于一个线性映射$T <span class="math inline">\(,\)</span>V
/ U = V / T  T <span class="math inline">\(,这其实就是同态基本定理在线性空间上的表现.不过线性空间上还多一个标量乘法的运算,需要在群的基础上对此进行简单验证.另外线性空间上还有维数的概念,当然立即断言\)</span>V
= U + ( V / U ) <span class="math inline">\(.值得一提的是这同样也告知我们\)</span>U <span class="math inline">\(的基和\)</span>V / U <span class="math inline">\(的反像的基合起来就是一组\)</span>V $的基.</p>
<p>上述说了这么多其实都在着重于所谓商空间的结构,现在我们看到陪集的定义可以在相当的意义上刻画商空间.适当推广上面的结论可以有:</p>
<p>设$T : V _1 V _2 <span class="math inline">\(是线性映射,\)</span>U _1
V _1 , U _2 V _2 <span class="math inline">\(并构造两个商映射\)</span>_1
: V _1 V _1 / U _1 , _2 : V _2 V _2 / U _2 <span class="math inline">\(,并且\)</span>T ( U _1 ) U _2 <span class="math inline">\(,那么存在唯一的线性映射\)</span>{ T } : V _1 / U
_1 V _2 / U _2 <span class="math inline">\(使得\)</span>T _2 = { T } _1
<span class="math inline">\(.具体地,\)</span>{ T } ( + U _1 ) = T + U _2
$.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表:</p>
<p><span class="math display">\[
\xymatrix { V _1 \ar [rr ] ^T \ar [d ] _{ \varphi _1  } &amp; &amp; V _2
\ar [rr ] ^S \ar [d ] _{ \varphi _2  } &amp; &amp; V _3 \ar [d ] _{
\varphi _3  } \\
V _1 / U _1 \ar [rr ] ^{ \bar { T  }  } _{ \ker \bar { T  } = T ^{ -
1  } ( U _2 ) / U _1  } &amp; &amp; V _2 / U _2 \ar [rr ] ^{ \bar {
S  }  } _{ \ker \bar { S  } = S ^{ - 1  } ( U _3 ) / U _2  } &amp; &amp;
V _3 / U _3 \\
}
\]</span></p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>将群论中的第一同构定理(不过线性空间下没有正规的概念)拿过来,即对于线性空间$V
<span class="math inline">\(的一个子空间\)</span>U <span class="math inline">\(,在典范同态\)</span>: V V / U $下,我们有:</p>
<ol type="1">
<li><p>$V <span class="math inline">\(的包含\)</span>U <span class="math inline">\(的子空间\)</span>W <span class="math inline">\(和\)</span>V / U <span class="math inline">\(的子空间\)</span>{ W } <span class="math inline">\(在\)</span><span class="math inline">\(下一一对应.不妨设此对应为\)</span>: W { W }
$.</p></li>
<li><p>此对应是严格保序的,也就是$W _1 W _2 { W } _1 { W } _2 $.</p></li>
<li><p>若有$U W V <span class="math inline">\(,则\)</span>V / W ( V / U
) / ( W / U ) $.</p></li>
</ol>
<p>考虑(1)(2)的证明:</p>
<p>先证明单射,对于两个包含$U <span class="math inline">\(的子空间\)</span>W _1 W _2 <span class="math inline">\(来说,不妨设\)</span>W _1 W _2 <span class="math inline">\(,\)</span> W _1 , W _2 <span class="math inline">\(.此时考虑\)</span>{ a } <span class="math inline">\(,注意到如果\)</span>{ a } { W _2 } <span class="math inline">\(,那么\)</span> + U W _2 + U <span class="math inline">\(.这表明\)</span> W _2 <span class="math inline">\(,\)</span> + U = + U <span class="math inline">\(,此时\)</span> - U W _2 <span class="math inline">\(,那么\)</span> W _2 <span class="math inline">\(,这就不符合了,于是当然\)</span>{ W _1 } { W _2 }
$并且(2)上严格保序.</p>
<p>证明单射还有一种办法是考虑只需证明$^{ - 1 } ( ( W ) ) = W <span class="math inline">\(即可,而\)</span>W ^{ - 1 } ( ( W ) ) <span class="math inline">\(是显然的.又考虑\)</span> ^{ - 1 } ( ( W ) ) , ( )
( W ) <span class="math inline">\(,这意味着\)</span> W , ( ) = ( ) <span class="math inline">\(,于是\)</span> + = + U + W = W <span class="math inline">\(.这样就证明了\)</span>W ^{ - 1 } ( ( W ) ) $.</p>
<p>接下来要证明满射,也就是证明$N V / U , U ^{ - 1 } ( N ) G $.</p>
<p>首先要证明$^{ - 1 } ( N ) $是一个子空间,这个是容易验证的.</p>
<p>而由于保序性已经被证明了,我们就可以注意到由于$ N <span class="math inline">\(,于是有\)</span>{ 0 } = U ^{ - 1 } ( N ) $.</p>
<p>对于(3):</p>
<p>由同态基本定理,考虑构造满射$: V / U V / W <span class="math inline">\(,只需证明\)</span> = W / U $即可.</p>
<p>直觉上会认为映射$: + U + W $即可,下面验证其满足上述性质:</p>
<p>首先验证良定义,$ _1 + U = _2 + U _1 - _2 U W _1 + W = _2 + W $.</p>
<p>然后验证线性映射,这个验证过程很平凡.</p>
<p>其满性显然.只需验证其$= W / U <span class="math inline">\(即可,而考虑\)</span>( + U ) = W + W = W W + U W /
U $.这样就证明了上述结论.</p>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>$V , W $是一个更大的线性空间的子空间,那么我们有:</p>
<p>$V / ( V W ) ( V + W ) / W , + ( V W ) + W $.</p>
<p>考虑$: V ( V + W ) / W , + W <span class="math inline">\(,那么显然\)</span>( ) = W V W <span class="math inline">\(,于是\)</span>= V W $.</p>
<p>接下来只需要证明它是满射就可以了.考虑$ + + W = + W ( V + W ) / W
$,这当然是满射.</p>
<p>第二同构定理的一个平凡推论是$( V + W ) = ( V ) + ( W ) - ( V W )
$.</p>
<p>第二同构定理的另一个推论是说如果$V = U W <span class="math inline">\(,那么\)</span>W V / U <span class="math inline">\(.原因是\)</span>U + W = V <span class="math inline">\(并且\)</span>U W = { }
$.换言之取商是直和的逆运算.</p>
<p>第二同构定理证明的另一种思路是考虑$: V W V + W , ( , ) ( - ) <span class="math inline">\(,此时注意到\)</span> = ( V + W ) , = V W $.</p>
<h5><span id="旗">旗</span></h5>
<p>回看我们一开始拿到的映射$T : V V ’ <span class="math inline">\(和映射\)</span>{ T } : V / U V ’ / U ’
$.也就是下面这个交换图表:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^T \ar [d ] _{ \varphi  } &amp; V &#39; \ar [d ]
^{ \varphi &#39;  } \\
V / U \ar [r ] _{ \bar { T  }  } &amp; V &#39; / U &#39; \\
}
\]</span></p>
现在我们尝试用矩阵刻画$T <span class="math inline">\(和\)</span>{ T }
<span class="math inline">\(之间的关系.首先我们需要开始取基,不妨取\)</span>{
_1 , , _k } <span class="math inline">\(是\)</span>U <span class="math inline">\(的一组有序基,\)</span>{ { v } _1 , , { v } _m }
<span class="math inline">\(是\)</span>V / U <span class="math inline">\(的一组有序基.\)</span>{ <em>1 ’ , , </em>{ k ’ } ’
} <span class="math inline">\(是\)</span>U ’ <span class="math inline">\(的一组有序基,\)</span>{ { v } <em>1 ’ , , { v }
</em>{ m ’ } ’ } <span class="math inline">\(是\)</span>V ’ / U ’ <span class="math inline">\(的一组有序基.此时由于\)</span>= U <span class="math inline">\(,我们之前证明\)</span><span class="math inline">\(的维度关系的时候已经说明过,\)</span>{ _1 , , _k ,
_1 , <em>m } <span class="math inline">\(实际上是\)</span>V <span class="math inline">\(的一组有序基.尝试取出一个矩阵\)</span>A M </em>{ (
k ’ + m ’ ) ( k + m ) } <span class="math inline">\(来作为\)</span>T
<span class="math inline">\(对应的矩阵.此时将\)</span>A <span class="math inline">\(分块,我们将其写作\)</span>A =
<span class="math display">\[\begin{bmatrix}A _{ U \to U &#39;  } &amp;
A _{ V / U \to U &#39;  } \\ A _{ U \to V &#39; / U &#39;  } &amp; A _{
V / U \to V &#39; / U &#39;  } \end{bmatrix}\]</span>
<span class="math inline">\(.由于\)</span>T ( U ) U ’ <span class="math inline">\(,我们知道\)</span>A <em>{ U V ’ / U ’ } = 0 <span class="math inline">\(,而又有\)</span>A </em>{ V / U V ’ / U ’ } <span class="math inline">\(当然就是\)</span>{ T } <span class="math inline">\(对应的矩阵\)</span>{ A } <span class="math inline">\(.总结一下就是\)</span>A =
<span class="math display">\[\begin{bmatrix}A _{ U \to U &#39;  } &amp;
\_ \\ 0 &amp; \bar { A  } \end{bmatrix}\]</span>
<p>$.</p>
<p>如此观察可以继续推广并得到<strong>旗</strong>的概念.我们称$V <span class="math inline">\(的**旗**是一列子空间\)</span>{ } = U _0 U _d = V
<span class="math inline">\(.特别地,如果\)</span>d = V <span class="math inline">\(,则称其为**完备旗**,容易见到完备旗一定满足\)</span>V
_i = i <span class="math inline">\(.对于给定的旗,如果线性映射\)</span>T
( V ) <span class="math inline">\(对\)</span> i m <span class="math inline">\(满足\)</span>T ( V _i ) V _i <span class="math inline">\(,则称\)</span>T $保持此旗.</p>
<p>如果一个映射$T : V V ’ <span class="math inline">\(满足\)</span>h , T
( U _h ) U ’ <em>h <span class="math inline">\(,那我们可以对每个\)</span>U <em>h / U </em>{ h - 1
} <span class="math inline">\(和\)</span>U ’ <em>h / U ’ </em>{ h - 1 }
<span class="math inline">\(选定有序基,那么得到的矩阵\)</span>A <span class="math inline">\(应当是一个分块上三角矩阵,而且\)</span>A </em>{ i ,
i } <span class="math inline">\(实际上就是\)</span>{ T } _h : U <em>h /
U </em>{ h - 1 } U ’ <em>h / U ’ </em>{ h - 1 } $所对应的矩阵.</p>
<h5><span id="不变子空间">不变子空间</span></h5>
<p>给定线性映射$T ( V ) <span class="math inline">\(,如果子空间\)</span>U V <span class="math inline">\(满足\)</span>T ( U ) U <span class="math inline">\(,那我们称\)</span>U <span class="math inline">\(是在\)</span>T
$下的一个<strong>不变子空间</strong>.根据前面我们已经讨论过的内容,得到下面这个交换图表:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^T \ar [d ] _{ \varphi  } &amp; V \ar [d ] ^{
\varphi &#39;  } \\
V / U \ar [r ] _{ \bar { T  }  } &amp; V / U \\
}
\]</span></p>
<p>其中${ T } $是唯一的.</p>
提取$T | _U <span class="math inline">\(为只考虑\)</span>T <span class="math inline">\(在线性空间\)</span>U <span class="math inline">\(上的作用得到的线性映射,上述交换图表给出以下矩阵:\)</span>T
<span class="math display">\[\begin{bmatrix}T | _U &amp; \_ \\ 0 &amp;
\bar { T  } \end{bmatrix}\]</span>
<p><span class="math inline">\(.这个形式更好的用处是结合之后的迹/行列式/特征多项式等概念给出\)</span>T
, T | _U , { T } <span class="math inline">\(三者的关系:事实上\)</span>(
T | _U ) ( { T } ) = ( T ) , ( T | _U ) + ( { T } ) = ( T ) $.</p>
<h3><span id="行列式">行列式</span></h3>
<h4><span id="置换排列">置换(排列)</span></h4>
<p>不妨假设$X <span class="math inline">\(是一个非空集合,那么我们定义其**置换集合**\)</span>S
_X = { : X X ,   } <span class="math inline">\(.容易看出\)</span>S _X
$对置换复合构成一个群.</p>
我们也可以用$(
<span class="math display">\[\begin{matrix}1 &amp; \cdots &amp; n \\
\sigma ( 1 ) &amp; \cdots &amp; \sigma ( n ) \end{matrix}\]</span>
<p>) $.</p>
我们还可以定义<strong>轮换</strong>为$(
<span class="math display">\[\begin{matrix}1 &amp; 2 &amp; \cdots &amp;
n - 1 &amp; n \\ 2 &amp; 3 &amp; \cdots &amp; n &amp; 1
\end{matrix}\]</span>
<p>) $.</p>
还可以定义<strong>对换</strong>$( i , j ) = (
<span class="math display">\[\begin{matrix}1 &amp; \cdots &amp; i &amp;
\cdots &amp; j &amp; \cdots &amp; n \\ 1 &amp; \cdots &amp; j &amp;
\cdots &amp; i &amp; \cdots &amp; n \end{matrix}\]</span>
<p>) <span class="math inline">\(,其中\)</span>i j $.</p>
<p>在此基础上定义<strong>单对换</strong>$s _i = ( i , i + 1 ) $.</p>
<p>在置换的基础上可以定义逆序对:$ <em>= { ( i , j ) i &lt; j n , ( i )
&gt; ( j ) } <span class="math inline">\(,并定义逆序数\)</span>l ( ) = |
</em>| <span class="math inline">\(.容易看出\)</span>l ( ) = 0 = <span class="math inline">\(,\)</span>l ( ) = { 2 } ( k ) = n - k + 1 <span class="math inline">\(.并且注意到\)</span>l ( ) = l ( ^{ - 1 } ) <span class="math inline">\(,原因是\)</span>( i , j ) ( ( j ) , ( i ) )
$是双射.</p>
<p>容易发现一个$<span class="math inline">\(可以最少通过\)</span>l ( )
<span class="math inline">\(次单对换变为\)</span> <span class="math inline">\(,原因是每次交换一对\)</span>( i , i + 1 ) <span class="math inline">\(当\)</span>( i ) &gt; ( i + 1 )
$时会让逆序数减少$1 <span class="math inline">\(.或者说更一般地\)</span>| l ( ) - l ( s _i ) | = 1
<span class="math inline">\(.由于\)</span>( s _i ) ^{ - 1 } = s _i <span class="math inline">\(,容易发现\)</span>| l ( ) - l ( s _i ) | = 1 <span class="math inline">\(.而事实上\)</span>| l ( ) - l ( ( i , j ) ) |
<span class="math inline">\(.这意味着对换会改变逆序数的奇偶性.所以容易看出来一个置换\)</span><span class="math inline">\(如果能拆成若干个对换,这些对换的数量的奇偶性一定与\)</span>l
( ) $相同.</p>
<p>而由于可以如上分解并合并,我们知道$l ( ) <span class="math inline">\(和\)</span>l ( ) + l ( ) $的奇偶性必然相同.</p>
<p>于是我们可以定义$ ( ) = ( - 1 ) ^{ l ( ) } <span class="math inline">\(,并且容易发现\)</span> ( ) = ( ) ( ) <span class="math inline">\(.还可以看出\)</span> ( ^{ - 1 } ) = ( ) <span class="math inline">\(,那么立刻有\)</span> ( ^{ - 1 } ) = ( ) <span class="math inline">\(.用此可以定义奇偶置换的概念,也就是\)</span>l ( )
<span class="math inline">\(的置换\)</span>$是奇置换.</p>
<h4><span id="交错形式">交错形式</span></h4>
<p>尝试刻画一种交错形式$D : V ^m F <span class="math inline">\(,其中\)</span>V <span class="math inline">\(是定义在\)</span>F $上的线性空间,满足以下性质:</p>
<ol type="1">
<li><p>其对每一个分量都是线性的.也即固定其他$m - 1 <span class="math inline">\(个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之\)</span>D
( , t _i , ) = tD ( , _i , ) , D ( , _i + v _i ’ , ) = D ( , _i , ) + D
( , _i ’ , ) $.</p></li>
<li><p>如果有两个分量相等,那么得到的是$0 $.</p></li>
</ol>
<p>在上述基础上容易发现交错形式也是线性空间,不妨将其记作$D _{ V , m }
$.</p>
<p>容易发现$D _{ V , 1 } = V ^$.</p>
<p>初看会觉得(2)是一个很奇怪的事情,但实际上其定义了一种很好的性质:首先我们应当需要一种东西使得如果有一个分量是$
$则给出$0 $,但如果直接这么定义的话容易看到难以判定一个东西在没有分量为$0
$的时候是否为$0 $,因此这个定义的性质更为优良.事实上,我们有以下性质:</p>
<ol type="1">
<li><p>对于一个固定的$D
$而言,将其某一个分量乘以若干倍加到另一个分量上不会引起取值的变化.</p></li>
<li><p>对于一个固定的$D <span class="math inline">\(而言,将某一个分量乘以\)</span>t <span class="math inline">\(倍,则取值需要乘以\)</span>t $倍.</p></li>
<li><p>对于一个固定的$D
$而言,如果其收到的向量组是线性相关的,那么取值为$0 $.</p></li>
<li><p>作为(3)的推论,如果$m &gt; V <span class="math inline">\(,那么\)</span>D _{ V , m } = { 0 } $.</p></li>
<li><p>对于一个固定的$D <span class="math inline">\(而言,\)</span>D ( ,
_i , , _j , ) = - D ( , _j , , _i , ) $.</p></li>
<li><p>作为(5)的推论,$D ( <em>{ ^{ - 1 } ( 1 ) } , , </em>{ ^{ - 1 } ( m
) } ) = ( ) D ( _1 , , _m ) $.</p></li>
</ol>
<p>其它几个都是平凡的,下面考虑(5)的证明,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp; = D ( \cdots , \vec { v  } _i + \vec { v  } _j , \cdots , \vec {
v  } _j + \vec { v  } _i , \cdots ) \\
&amp; = D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _j , \cdots )
+ D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _i , \cdots ) \\
+ D ( \cdots , \vec { v  } _j , \cdots , \vec { v  } _i , \cdots ) + D (
\cdots , \vec { v  } _j , \cdots , \vec { v  } _j , \cdots ) \\
&amp; = D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _j , \cdots )
+ D ( \cdots , \vec { v  } _j , \cdots , \vec { v  } _i , \cdots )
\end{aligned}
\]</span></p>
<p>下面我们定义$D <em>V = D </em>{ V , n } <span class="math inline">\(,其中\)</span>n = V <span class="math inline">\(,取出其一组有序基\)</span>{ _1 , , <em>n } <span class="math inline">\(.对于一组向量\)</span>{ </em>{ 1 } , , <em>n }
<span class="math inline">\(,尝试将其分解为\)</span> <em>i = </em>{ j }
a </em>{ i , j } _j <span class="math inline">\(.此时逐个展开\)</span>D
( _1 , , _n ) $中的向量,理应得知:</p>
<p><span class="math display">\[
\begin{aligned}
D ( \vec { v  } _1 , \cdots , \vec { v  } _n ) &amp; = \sum _{ \sigma
\in S _n  } \prod _{ k = 1  } ^n a _{ k , \sigma ( k )  } D ( \vec {
e  } _{ \sigma ( 1 )  } , \cdots , \vec { e  } _{ \sigma ( n )  } ) \\
&amp; = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma ) \prod _{ k
= 1  } ^n a _{ k , \sigma ( k )  } D ( \vec { e  } _1 , \cdots , \vec {
e  } _n )
\end{aligned}
\]</span></p>
<p>这说明任何一个$D <span class="math inline">\(实际上只由其在基上的作用\)</span>D ( _1 , , _n )
<span class="math inline">\(唯一确定.因此\)</span>D = F <span class="math inline">\(,原因是线性映射\)</span>D _V F , D D / D ( _1 , ,
<em>n ) <span class="math inline">\(是单射.事实上只要\)</span>V <span class="math inline">\(,当然可以如上构造\)</span>D <em>e = </em>{ S <em>n
} ( ) </em>{ k = 1 } ^n a </em>{ k , ( k ) } D _V { 0 } <span class="math inline">\(,于是\)</span>D <span class="math inline">\(,于是\)</span>D = 1 $.</p>
<p>验证$D _e $映射符合定义的过程较为无聊,验证有相同元素则为$0 <span class="math inline">\(是考虑交换它们后\)</span> <span class="math inline">\(会变号,而还容易简单验证\)</span>D _e ( _1 , _n ) =
1 $.</p>
<h4><span id="定义">定义</span></h4>
<p>考虑有限维的$V , W <span class="math inline">\(,并考虑映射\)</span>T
^* : D <em>{ W , m } D </em>{ V , m } , D ( ( T ^* D ) : ( _1 , , _m ) D
( T _1 , T _m ) $.</p>
<p>现在取$W = V , m = n = V <span class="math inline">\(,于是\)</span>T
( V ) , T ^* ( D _V ) <span class="math inline">\(,由于\)</span>D _V = 1
<span class="math inline">\(,于是\)</span>T ^* <span class="math inline">\(必然是伸缩映射\)</span>D tD <span class="math inline">\(,那么这个\)</span>t
$其实就是行列式.更确切地说,我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
T ^* ( D ) &amp; = ( \det T ) D \\
D ( T \vec { v  } _1 , \cdots , T \vec { v  } _n ) &amp; = \det T \times
D ( \vec { v  } _1 , \cdots \vec { v  } _n )
\end{aligned}
\]</span></p>
<p>那么既然其是伸缩映射,我们就当然注意到$T = { D _e ( _1 , , _n ) } = D
_e ( T _1 , , T _n ) $.</p>
<p>只需简单利用定义就可以注意到行列式的以下性质:</p>
<ol type="1">
<li><p>$ _V = 1 $.</p></li>
<li><p>$( ST ) = S T $.</p></li>
<li><p>$T <span class="math inline">\(可逆时,\)</span>( T ^{ - 1 } ) = (
T ) ^{ - 1 } $.</p></li>
<li><p>$T <span class="math inline">\(不可逆时,\)</span>T = 0
$.</p></li>
</ol>
<p>应当警觉的一个事情是我们上面给出的计算$D <span class="math inline">\(的方式是观察\)</span>D <span class="math inline">\(在某一组基上的作用,而我们理应判定当选取的基不同的时候\)</span>T
<span class="math inline">\(的唯一性,我们还应当确认的是我们可以将一个\)</span>V
= n <span class="math inline">\(的线性空间用某一个基打到\)</span>F ^n
$后也不会有问题,从而引出矩阵的行列式的定义.综上,我们应当验证当以下图表是交换时:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^T \ar [d ] _S &amp; V \ar [d ] ^S \\
W \ar [r ] _{ T &#39;  } &amp; W  }
\]</span></p>
<p>也即$T ’ = STS ^{ - 1 } <span class="math inline">\(时\)</span>T = T
’ $.那么这由行列式的乘法性质当然就可以予以说明.</p>
<p>综上就可以定义矩阵的行列式,我们称方阵$A <em>{ n n } <span class="math inline">\(的行列式是一个将其映射到标量的函数,记作\)</span>(
A ) <span class="math inline">\(或者\)</span>| A | <span class="math inline">\(.由于一般自然地将\)</span> ( V ) M </em>{ n n }
<span class="math inline">\(,于是从上面的计算方式容易见到\)</span>A =
<em>{ S <em>n } ( ) </em>{ k = 1 } ^n a </em>{ k , ( k ) } = <em>{ S
<em>n } ( ) </em>{ k = 1 } ^n a </em>{ ( k ) , k } $.</p>
<p>我们应当容易从上述过程中看出以下事实:</p>
<ol type="1">
<li><p>$A = A ^T $.</p></li>
<li><p>$I _{ n n } = 1 $.</p></li>
<li><p>$A $可以看作列向量(或行向量)上的某种交错形式.</p></li>
<li><p>如果两个矩阵相似,那么它们的$$相等.</p></li>
</ol>
<p>而由于行列式是某种交错形式,我们立即可以断言当对其作三种初等行变换的时候:</p>
<ol type="1">
<li><p>(倍加变换):行列式的值不变.</p></li>
<li><p>(对换变换):行列式的值取反.</p></li>
<li><p>(倍乘变换):行列式的值取相同倍数.</p></li>
</ol>
<p>说到这里要声明的某些事情是,我们应当将行列式看作某种交错形式,而并非将所有的交错形式都看作行列式.原因是交错形式一般带有单位,而行列式只是单纯的比例常数.例如我们用行列式求面积的时候,算的其实并不是面积,而是其相对于单位面积的比例常数.</p>
<h4><span id="余子式与代数余子式">余子式与代数余子式</span></h4>
<p>对于矩阵$A <span class="math inline">\(,\)</span>A <span class="math inline">\(的**余子式**\)</span>M <em>{ i , j } <span class="math inline">\(定义为\)</span>A <span class="math inline">\(去掉第\)</span>i <span class="math inline">\(行第\)</span>j <span class="math inline">\(列的矩阵的行列式.其中形如\)</span>M </em>{ i , i }
$的余子式称为<strong>主余子式</strong>.</p>
<p>对于矩阵$A <span class="math inline">\(,其**代数余子式**(又称**余因子**)\)</span>C <em>{
i , j } = ( - 1 ) ^{ i + j } M </em>{ i , j } \ $.</p>
<p>那么我们有一种计算行列式的方式是<strong>代数余子式展开</strong>:</p>
<p><span class="math display">\[
\det A = \sum _{ k = 1  } ^n a _{ i , k  } C _{ i , k  } = \sum _{ k =
1  } ^n a _{ k , j  } C _{ k , j  }
\]</span></p>
<p>原因是$( i ) = j <span class="math inline">\(的位置对逆序对的贡献的奇偶性等同于\)</span>i + j
<span class="math inline">\(的奇偶性.每次我看这个结论都无法第一时间理解这个性质.但你可以考虑以\)</span>(
i ) = j <span class="math inline">\(作为分界线,然后发现此时怎么交换其它的部分,这个点的奇偶性贡献都是不变的.因此直接考虑在最普通的排列上挪一下,奇偶性就等价于\)</span>i
- j $的奇偶性了.</p>
<p>值得一提的是我们其实还有类似的公式,当$i j $的时候:</p>
<p><span class="math display">\[
0 = \sum _{ k = 1  } ^n a _{ i , k  } C _{ j , k  } = \sum _{ k = 1  }
^n a _{ k , i  } C _{ k , j  }
\]</span></p>
<p>原因是直接定义一个矩阵$B <span class="math inline">\(使得\)</span>B
<span class="math inline">\(的第\)</span>j <span class="math inline">\(行与\)</span>A <span class="math inline">\(的第\)</span>i <span class="math inline">\(行相等,其余行照搬\)</span>A <span class="math inline">\(,那么展开也是上面这个东西,而由于\)</span>B <span class="math inline">\(有两行相等,所以\)</span>B = 0 $.</p>
<p>代数余子式构成的矩阵$C = [ C _{ i , j } ] <span class="math inline">\(称为**余子矩阵**.其转置称为**伴随矩阵**,我们不妨将伴随矩阵直接记作\)</span>
<span class="math inline">\(,也有时记其为\)</span> ( A ) $.</p>
<p>其满足$A = A = ( A ) I $.二者类似,只考虑证明前者:</p>
<p>考虑前者的第$i <span class="math inline">\(行第\)</span>j <span class="math inline">\(列应该是\)</span><em>{ k } a </em>{ i , k } C _{ j
, k } <span class="math inline">\(,我们早在前面就证明过当\)</span>i = j
<span class="math inline">\(的时候这个东西应当为\)</span>A $,反之为$0
$.</p>
<p>由上面立刻得到推论为$A ^{ - 1 } = { A } $.</p>
<p>我们可能还希望去了解$ <span class="math inline">\(的\)</span> <span class="math inline">\(与\)</span>$.事实上我们给出以下若干命题:</p>
<ol type="1">
<li><p>$ = ( A ) ^{ n - 1 } $.</p></li>
<li><p>$ ( ) =</p>
<span class="math display">\[\begin{cases}n &amp; \text { rk  } \ A = n
\\ 1 &amp; \text { rk  } \ A = n - 1 \\ 0 &amp; \text { rk  } \ A &lt; n
- 1 \end{cases}\]</span>
<p>$.</p></li>
</ol>
<p>(1)无非是(2)的推论,下面只看(2).</p>
<p>(2)的话,由于$A <span class="math inline">\(,所以当\)</span>A
$满秩的时候也很显然.</p>
<p>当$  A &lt; n - 1 <span class="math inline">\(的时候,由于取出的所有余子式都线性相关,于是此时\)</span>
$是$0 $矩阵.</p>
<p>当$  A = n - 1 <span class="math inline">\(的时候,首先证明其\)</span>
k $,也就是只需证明至少存在一个余子式不为$0 <span class="math inline">\(.取出\)</span>n - 1 <span class="math inline">\(个线性无关的列组成一个\)</span>n ( n - 1 ) <span class="math inline">\(大小的矩阵.我们之前已经声明过其行秩等于列秩,这样就可以删去其中一行得到一个\)</span>(
n - 1 ) ( n - 1 ) $的满秩矩阵,这个矩阵的行列式不为零.</p>
<p>于是其$ $,我们又根据Frobenius秩不等式,知道考虑$0 =  ( AI )  A +   -
 I <span class="math inline">\(,于是\)</span>   $.</p>
<h4><span id="行列式定向">行列式定向</span></h4>
<p>我们知道我们用行列式求平行四边形面积的时候求的是所谓有向面积,问题在于这个方向具体是什么样子呢.</p>
<p>容易见得不同的基对应的矩阵行列式应当是相等的.但基的变换可能拥有不同的行列式.我们曾经研究过$P
<em>{ ’ } <span class="math inline">\(这个坐标变换矩阵的若干性质,而这个变换当然是同构的,所以这个矩阵行列式理应非零,那它就会天然带有正负的区别.我们定义一种基上的等价关系\)</span><span class="math inline">\(,或者称为**同定向的**.具体来说\)</span> ’ P </em>{
’ } &gt; 0 <span class="math inline">\(,由于行列式的乘法性质,立刻见到这将所有的基分为了两类.对于\)</span>F
^n
$来说,我们一般将其标准基所在的那一类称为<strong>标准定向</strong>.这就是为什么我们求行列式的时候会出现正负的差别.</p>
<h4><span id="克拉默cramer法则">克拉默(Cramer)法则</span></h4>
<p>若$A <span class="math inline">\(可逆,用\)</span>A _i ( ) <span class="math inline">\(表示将\)</span>A <span class="math inline">\(的第\)</span>i <span class="math inline">\(列替换为\)</span> <span class="math inline">\(后的矩阵,则\)</span>A = $的唯一解可由下式给出:</p>
<p><span class="math display">\[
x _i = \cfrac { \det A _i ( \vec { b  } )  } { \det A  }
\]</span></p>
<p>证明:由于$A <span class="math inline">\(实际上可以看作线性映射不难发现\)</span>A I _i ( )
= A _i ( ) <span class="math inline">\(,则根据行列式的乘法原理,有\)</span>( A ) ( I _i (
) ) = A _i ( ) <span class="math inline">\(.而\)</span>I _i ( ) = x _i
$,于是该定理显然.</p>
<p>或者直接考虑$ = A ^{ - 1 } = { A } <span class="math inline">\(,于是\)</span>x <em>i = { A } </em>{ k = 1 } ^n C
_{ k , i } b _k <span class="math inline">\(,后者刚好是\)</span>A _i ( )
<span class="math inline">\(沿第\)</span>i $列作余子式展开后的结果.</p>
<p>值得一提的是,Cramer法则揭示了$R ^$的环上的矩阵必有逆矩阵</p>
<h4><span id="一些特殊行列式">一些特殊行列式</span></h4>
<h5><span id="置换矩阵">置换矩阵</span></h5>
对于一个置换$<span class="math inline">\(,我们记它的置换矩阵\)</span>P
<em><span class="math inline">\(满足\)</span>P </em>{ , i , j } =
<span class="math display">\[\begin{cases}1 &amp; i = \sigma ( j ) \\ 0
&amp; \text { otherwise  } \end{cases}\]</span>
<p><span class="math inline">\(,容易发现它对应了线性映射\)</span> <em>j
</em>{ ( j ) } <span class="math inline">\(.容易看出\)</span>P <em>P
</em>= P <em>{ } <span class="math inline">\(并且\)</span>P </em>{ ^{ -
1 } } = ( P <em>) ^{ - 1 } = ( P </em>) ^T <span class="math inline">\(.容易由行列式理论得知\)</span>| P _| = ( ) $.</p>
<h5><span id="上三角矩阵">上三角矩阵</span></h5>
<p>用代数余子式展开立刻见到上三角矩阵的行列式就是其对角线的乘积.这比用高斯消元更好,因为对角线未必可逆.</p>
<h5><span id="分块上三角矩阵">分块上三角矩阵</span></h5>
也即$|
<span class="math display">\[\begin{matrix}A _{ 1 , 1  } &amp; \cdots
&amp; \cdots \\ 0 &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; A _{ n ,
n  } \end{matrix}\]</span>
<p>| = <em>{ i = 1 } ^n A </em>{ i , i } $.</p>
证明考虑数学归纳,先把左上角那一坨变成一个分块矩阵,那我们只需要证明$|
<span class="math display">\[\begin{matrix}A _{ 1 , 1  } &amp; A _{ 1 ,
2  } \\ 0 &amp; A _{ 2 , 2  } \end{matrix}\]</span>
<p>| = A <em>{ 1 , 1 } A </em>{ 2 , 2 } $.</p>
<p>这个怎么证明呢?考虑直接套定义,我们知道行列式的定义是:$A = <em>{ S
<em>n } ( ) </em>{ k = 1 } ^n a </em>{ k , ( k ) } <span class="math inline">\(,此时意识到如果\)</span>k &gt; n _1 , ( k ) n
<em>1 <span class="math inline">\(那么此时\)</span>a </em>{ k , ( k ) }
= 0 <span class="math inline">\(,所以这个\)</span><span class="math inline">\(应当分为两部分,一部分是\)</span>[ 1 , n _1 ] <span class="math inline">\(部分内部交换,另一部分是\)</span>[ n _1 + 1 , n _1
+ n _2 ] <span class="math inline">\(内部交换,这样我们把\)</span>= _1 _2
$,上述表达式变为:</p>
<p><span class="math display">\[
\begin{aligned}
\det A &amp; = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma _1 )
\prod _{ k = 1  } ^{ n _1  } a _{ k , \sigma _1 ( k )  } \text { sgn  }
( \sigma _2 ) \prod _{ k = n _1 + 1  } ^{ n _1 + n _2  } a _{ k , \sigma
_2 ( k )  } \\
&amp; = \det A _{ 1 , 1  } \det A _{ 2 , 2  }
\end{aligned}
\]</span></p>
<h5><span id="范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</span></h5>
即$|
<span class="math display">\[\begin{matrix}1 &amp; \cdots &amp; 1 \\ x
_1 &amp; \cdots &amp; x _n \\ \vdots &amp; &amp; \vdots \\ x _1 ^{ n -
1  } &amp; \cdots &amp; x _n ^{ n - 1  } \end{matrix}\]</span>
<p>| = _{ 1 i &lt; j n } ( x _j - x _i ) $.</p>
<p>这个怎么求呢?我们先逐个消第一列(先用第$n - 1 <span class="math inline">\(行消第\)</span>n <span class="math inline">\(行,再用第\)</span>n - 2 <span class="math inline">\(行消第\)</span>n - 1
$行,以此类推),我们得到的就是以下行列式:</p>
<p><span class="math display">\[
\left | \begin{matrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
0 &amp; x _2 - x _1 &amp; \cdots &amp; x _n - x _1 \\
0 &amp; \vdots &amp; &amp; \vdots \\
0 &amp; x _2 ^{ n - 1  } - x _1 x _2 ^{ n - 2  } &amp; \cdots &amp; x _n
^{ n - 1  } - x _1 x _n ^{ n - 2  }
\end{matrix} \right |
\]</span></p>
<p>对这个的第一列作代数余子式展开,知道它应当等于:</p>
<p><span class="math display">\[
\begin{aligned}
\left | \begin{matrix}
x _2 - x _1 &amp; \cdots &amp; x _n - x _1 \\
\vdots &amp; &amp; \vdots \\
x _2 ^{ n - 1  } - x _1 x _2 ^{ n - 2  } &amp; \cdots &amp; x _n ^{ n -
1  } - x _1 x _n ^{ n - 2  }
\end{matrix} \right | \\
&amp; = \left | \begin{matrix}
1 &amp; \cdots &amp; 1 \\
\vdots &amp; &amp; \vdots \\
x _2 ^{ n - 2  } &amp; \cdots &amp; x _n ^{ n - 2  }
\end{matrix} \right | \prod _{ 1 &lt; j \leq n  } ( x _j - x _1 )
\end{aligned}
\]</span></p>
<p>然后数学归纳就证完了.</p>
<h5><span id="一类分块矩阵">一类分块矩阵</span></h5>
考虑$|
<span class="math display">\[\begin{matrix}I &amp; B \\ A &amp; I
\end{matrix}\]</span>
| = ( I - AB ) <span class="math inline">\(.此时观测其对基的作用,注意到其和\)</span>
<span class="math display">\[\begin{bmatrix}I &amp; A \\ B &amp; I
\end{bmatrix}\]</span>
<p><span class="math inline">\(无非是在不同基下的同种线性映射,于是\)</span>( I -
AB ) = ( I - BA ) $.</p>
<h4><span id="特征多项式">特征多项式</span></h4>
<p>自映射$T = ( V ) <span class="math inline">\(本身作为一个定义了乘法和加法的元素,理应可以嵌入多项式结构中.因此不妨定义多项式\)</span>f
( T ) = _{ k = 0 } ^m a _k T ^k $.</p>
<p>此时设$V = n <span class="math inline">\(有限,那么\)</span>T = n ^2
<span class="math inline">\(,考虑以下\)</span>n ^2 + 1 <span class="math inline">\(个此空间上的向量\)</span>T ^0 , , T ^{ n ^2 }
$,它们必定线性相关,也就是存在一组不全为$0 <span class="math inline">\(的\)</span>{ c <em>k } <span class="math inline">\(使得\)</span>f ( T ) = </em>{ k = 0 } ^{ n ^2 } c
_k T ^k = 0 $.</p>
<p>如果$T <span class="math inline">\(可逆,那我们考虑可以取一个满足上述条件的\)</span>f
<span class="math inline">\(使得\)</span>c _0 <span class="math inline">\(,原因是可以不断两边除去\)</span>T <span class="math inline">\(.那最终就会拿到\)</span>c <em>0 + </em>{ k = 1 }
^m c _k T ^k = 0 <span class="math inline">\(,对此式子再简单处理可知以下结论:对于一个可逆的\)</span>T
<span class="math inline">\(,存在一个多项式\)</span>g ( T ) <span class="math inline">\(使得\)</span>T ^{ - 1 } = g ( T ) = - { c <em>0 }
</em>{ k = 1 } ^{ m } c _k T ^{ k - 1 } <span class="math inline">\(.并且注意到\)</span>g ( T ) n ^2 $.</p>
<p>将此定义挪到矩阵上,定义其特征多项式$ <em>A ( x ) = ( xI - A ) <span class="math inline">\(.由定义立刻得知\)</span> <em>A ( x ) = </em>{ } (
) </em>{ i = 1 } ^n ( [ i = ( i ) ] x - a _{ i , ( i ) } ) <span class="math inline">\(.于是容易发现\)</span> _A ( 0 ) = ( - 1 ) ^n A
$.并且这个多项式应该首项为$1 $.</p>
<p>容易观察到相似的矩阵应当有相同的特征多项式,原因是$( xI - A ) = ( P ^{
- 1 } ( xI - B ) P ) = ( xI - B )
$.这意味着其和基的选取无关,因此特征多项式可以拓展到一般的线性映射上.</p>
<p>另外转置不影响特征多项式的取值,原因是转置也不影响$$的取值.</p>
<p>分块上三角矩阵的特征多项式就是对角线矩阵特征多项式的乘积.</p>
<p>我们还可以有以下性质:当$A M <em>{ m n } , B M </em>{ n m } <span class="math inline">\(,则\)</span> { x ^m } = { x ^n } $.</p>
<p>原因是考虑:</p>
<p><span class="math display">\[
\begin{aligned}
x ^{ - m  } \text { char  } _{ AB  } \\
&amp; = x ^{ - m  } \det ( xI - AB ) \\
&amp; = \det ( I - x ^{ - 1  } AB ) \\
&amp; = \det ( I - x ^{ - 1  } BA ) \\
&amp; = x ^{ - n  } \text { char  } _{ BA  }
\end{aligned}
\]</span></p>
<p>原因是我们已经证明过了$( I - AB ) = ( I - BA ) $.</p>
<p>仅仅如此当然不够好用,然而注意到如果$AB <span class="math inline">\(以\)</span>_0 <span class="math inline">\(为特征值的特征向量是\)</span> <span class="math inline">\(,那么\)</span>BA <span class="math inline">\(以\)</span>_0 <span class="math inline">\(为特征值的特征向量就是\)</span>B $.</p>
<p>应当研究伴随矩阵在特征多项式下的情形,事实上有以下定理:如果$ <em>A =
</em>{ k = 0 } ^n c <em>k x ^k <span class="math inline">\(,那么\)</span>( - 1 ) ^{ n - 1 } = </em>{ k = 1 }
^n c _{ k } A ^{ k - 1 } $.</p>
<p>考虑证明以上定理,考虑$ ( xI - A ) <span class="math inline">\(的每一个元素都是一个次数\)</span>n - 1 <span class="math inline">\(的多项式,对其进行分解得到\)</span> ( xI - A ) = _{
k = 0 } ^{ n - 1 } x ^k D _k <span class="math inline">\(,其中\)</span>D
_k <span class="math inline">\(是一个矩阵,代表不同位置\)</span>x ^k
$前的系数.</p>
<p>而我们知道$ <em>A ( x ) I = ( xI - A ) ( xI - A ) = ( xI - A ) </em>{
k = 0 } ^{ n - 1 } x ^k D _k $.</p>
<p>两边提取系数,于是:</p>
<p><span class="math display">\[
\begin{aligned}
c _n I &amp; = D _{ n - 1  } \\
c _{ n - 1  } I &amp; = - AD _{ n - 1  } + D _{ n - 2  } \\
c _{ n - 2  } I &amp; = - AD _{ n - 2  } + D _{ n - 3  } \\
\cdots
\end{aligned}
\]</span></p>
<p>将上面这些若干式子右边乘以$A ^{ k } <span class="math inline">\(并相加就可以做到相消,得到\)</span>D <em>0 = </em>{
k = 1 } ^n c _{ k } A ^{ k - 1 } <span class="math inline">\(,而\)</span>D _0 <span class="math inline">\(按照定义就是\)</span> ( 0 I - A ) = ( - 1 ) ^{ n -
1 } $.</p>
<p>根据上述定理有以下结论:</p>
<ol type="1">
<li><p>$( A ^) ^T = ( A ^T ) ^$.</p></li>
<li><p>$ { ( P ^{ - 1 } AP ) } = P ^{ - 1 } P $.</p></li>
</ol>
<p>另外,如果$ <em>A = </em>{ k = 0 } ^n c <em>k x ^k <span class="math inline">\(,那么\)</span> </em>{ A ^{ - 1 } } = _{ k = 0 } ^n
{ c _0 } x ^{ n - k } $.</p>
<p>原因是观察到$( - 1 ) ^n c <em>0 </em>{ A ^{ - 1 } } = A ( xI - A ^{ -
1 } ) = ( - x ) ^n ( x ^{ - 1 } I - A ) $.</p>
<h4><span id="cayley-hamilton定理">Cayley-Hamilton定理</span></h4>
<p>即:$ _A ( A ) = 0 $.</p>
<p>原因是根据上述定理,由于$c _0 = ( - 1 ) ^n A $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^n c _k A ^k &amp; = ( ( - 1 ) ^n \det A ) \times I + A
\sum _{ k = 1  } ^n c _k A ^{ k - 1  } \\
&amp; = ( ( - 1 ) ^n \det A ) \times I + ( - 1 ) ^{ n - 1  } A \check {
A  } \\
&amp; = 0
\end{aligned}
\]</span></p>
<h4><span id="矩阵的迹">矩阵的迹</span></h4>
<p>定义$A M <em>{ n n } ( F ) <span class="math inline">\(的**迹**\)</span>  A = </em>{ i = 1 } ^n a <em>{ i
, i } <span class="math inline">\(.显然\)</span>tr ( A + B ) = tr ( A )
+ tr ( B ) <span class="math inline">\(.容易验证\)</span>tr : M </em>{ n
n } ( F ) F <span class="math inline">\(是线性映射,并且\)</span>A M
<em>{ n m } ( F ) , B M </em>{ m n } ( F ) <span class="math inline">\(有\)</span>tr ( AB ) = tr ( BA ) $.</p>
<p>于是共轭的矩阵有相同的迹,原因是$tr ( P ^{ - 1 } AP ) = tr ( APP ^{ -
1 } ) = tr ( A ) <span class="math inline">\(.这应当意味着迹这个东西有一些更好的性质.事实上,迹的等价定义是\)</span>tr
( A ) = - [ x ^{ n - 1 } ] <em>A <span class="math inline">\(,原因是\)</span> <em>A ( x ) = </em>{ } ( ) </em>{
i = 1 } ^n ( [ i = ( i ) ] x - a _{ i , ( i ) } ) <span class="math inline">\(,从这里立刻看出只有恒等映射\)</span>= <span class="math inline">\(的时候才会对\)</span>[ x ^{ n - 1 } ]
$产生贡献.</p>
<h6><span id="example">Example</span></h6>
<p>证明:如果$tr ( A ) = 0 <span class="math inline">\(,而且域的特征\)</span>  F = 0 <span class="math inline">\(,那么存在\)</span>A ’ = PAP ^{ - 1 } <span class="math inline">\(使得\)</span>i , a ’ _{ i , i } = 0 $.</p>
<p>如果$A = 0 <span class="math inline">\(就下班了对吧,如果\)</span>A
<span class="math inline">\(,我们下面来数学归纳证明.假设\)</span>&lt; n
$的时候已经得证.</p>
<p>首先我们说明:如果对于所有的$ F ^n <span class="math inline">\(都存在\)</span>c _v F <span class="math inline">\(使得\)</span>A = c _v <span class="math inline">\(,那么存在\)</span>c F <span class="math inline">\(使得\)</span>A = cI $.</p>
<p>考虑线性无关的两个向量$ , <span class="math inline">\(,如果\)</span>c
_v c _w <span class="math inline">\(,考虑\)</span>c _v + c <em>w = A ( +
) = c </em>{ v + w } ( + ) <span class="math inline">\(,于是自然导出\)</span>c <em>v = c </em>{ v + w } =
c _w $,矛盾.于是上述命题成立.</p>
<p>对于一个$tr ( A ) = 0 <span class="math inline">\(的矩阵当然不是\)</span>cI <span class="math inline">\(的形式,那我们就可以找到一个\)</span> <span class="math inline">\(使得\)</span>A c <span class="math inline">\(,于是\)</span>A <span class="math inline">\(和\)</span> <span class="math inline">\(线性无关.此时考虑将其扩充为一个基\)</span>{ , A ,
_3 , , _n } <span class="math inline">\(,考虑当然存在一个\)</span>C
<span class="math inline">\(使得\)</span>C = P _1 ^{ - 1 } AP _1 <span class="math inline">\(这样\)</span>C <span class="math inline">\(是对上述基的作用.那我们考虑\)</span>C ( ) = A
<span class="math inline">\(,于是\)</span>C $应当形如:</p>
<p><span class="math display">\[
\begin{bmatrix}
0 &amp; \cdots \\
1 &amp; \vdots \\
0 &amp; \vdots \\
\vdots &amp; \vdots
\end{bmatrix}
\]</span></p>
不妨设$C =
<span class="math display">\[\begin{bmatrix}0 &amp; T \\ L &amp; B
\end{bmatrix}\]</span>
<p><span class="math inline">\(,我们知道根据归纳假设,对于\)</span>B
<span class="math inline">\(来说存在一个\)</span>P _2 <span class="math inline">\(使得\)</span>P _2 ^{ - 1 } BP _2
$的对角线全零,那我们考虑:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 \\
0 &amp; P _2 ^{ - 1  }
\end{bmatrix} \begin{bmatrix}
0 &amp; T \\
L &amp; B
\end{bmatrix} \begin{bmatrix}
1 &amp; 0 \\
0 &amp; P _2
\end{bmatrix} = \begin{bmatrix}
0 &amp; \_ \\
\_ &amp; P _2 ^{ - 1  } BP _2
\end{bmatrix}
\]</span></p>
<p>这样就做完了.</p>
<h4><span id="binet-cauchy定理">Binet-Cauchy定理</span></h4>
<p>定义大小分别为$n m <span class="math inline">\(和\)</span>m n <span class="math inline">\((其中\)</span>n m <span class="math inline">\()的矩阵\)</span>A <span class="math inline">\(和\)</span>B <span class="math inline">\(,令\)</span>A [ S ] <span class="math inline">\(表示矩阵\)</span>A <span class="math inline">\(只取\)</span>S <span class="math inline">\(集合中的列所形成的矩阵,\)</span>B [ S ] <span class="math inline">\(表示矩阵\)</span>B <span class="math inline">\(只取\)</span>S $集合中的行所形成的矩阵,则有:</p>
<p><span class="math display">\[
\det ( AB ) = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  }
( \det ( A [ S ] ) ) ( \det ( B [ S ] ) )
\]</span></p>
<p>下面设$( P ) <span class="math inline">\(为排列\)</span>P
$的逆序对数.</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } ( \det ( A [
S ] ) ) ( \det ( B [ S ] ) ) \\
&amp; = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } (
\sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } \prod _{ i = 1  } ^n A _{ i , S
_{ P _i  }  } ) ( \sum _{ Q  } ( - 1 ) ^{ \lambda ( Q )  } \prod _{ i =
1  } ^n B _{ S _i , Q _i  } ) \\
&amp; = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum
_{ P  } \sum _{ Q  } ( - 1 ) ^{ \lambda ( P ) + \lambda ( Q )  } \prod
_{ i = 1  } ^n A _{ i , S _{ P _i  }  } B _{ S _i , Q _i  }
\end{aligned}
\]</span></p>
<p>若让$R <span class="math inline">\(为可重集合,换言之让其取遍\)</span>m ^n
$种情况,又有:</p>
<p><span class="math display">\[
\begin{aligned}
\det ( AB ) &amp; = \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } \prod _{ i
= 1  } ^n ( \sum _{ j = 1  } ^m A _{ i , j  } B _{ j , P _i  } ) \\
&amp; = \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } \sum _{ R , \forall i ,
R _i \in [ 1 , m ]  } ( \prod _{ i = 1  } ^n A _{ i , R _i  } B _{ R _i
, P _i  } ) \\
&amp; = \sum _{ R , \forall i , R _i \in [ 1 , m ]  } \sum _P ( - 1 ) ^{
\lambda ( P )  } ( \prod _{ i = 1  } ^n A _{ i , R _i  } ) ( \prod _{ i
= 1  } ^n B _{ R _i , P _i  } )
\end{aligned}
\]</span></p>
<p>如果$ i , j n , i j <span class="math inline">\(,\)</span>R _i = R _j
<span class="math inline">\(,则交换\)</span>P _i , P _j <span class="math inline">\(后,后面的值仍然不变,可逆序对的奇偶性改变了.如果我们对于每一个重复序列都选取最靠前的一对,那么显然只有\)</span>R
<span class="math inline">\(不重的情况才有可能产生贡献.既然如此,\)</span>R
$的生成方式就应该是先顺序取子集再用一个排列打乱顺序.</p>
<p>所以我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\det ( AB ) &amp; = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S |
= n  } \sum _{ Q  } \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } ( \prod _{
i = 1  } ^n A _{ i , S _{ Q _i  }  } ) ( \prod _{ i = 1  } ^n B _{ S _{
Q _i  } , P _i  } ) \\
&amp; = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum
_{ Q  } \sum _{ P _{ Q &#39;  }  } ( - 1 ) ^{ \lambda ( P _{ Q &#39;  }
)  } ( \prod _{ i = 1  } ^n A _{ i , S _{ Q _i  }  } ) ( \prod _{ i =
1  } ^n B _{ S _i , P _{ Q &#39; _i  }  } ) \\
&amp; = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum
_{ Q  } \sum _{ P _{ Q &#39;  }  } ( - 1 ) ^{ \lambda ( P ) + \lambda (
Q )  } ( \prod _{ i = 1  } ^n A _{ i , S _{ Q _i  }  } ) ( \prod _{ i =
1  } ^n B _{ S _i , P _{ Q &#39; _i  }  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>左右显然相等.</p>
<p>另外,这个定理有更简单的证明方法,即使用LGV引理与组合意义证明.</p>
<p>不妨设现在有个点的集合$A , B , C <span class="math inline">\(,现在想求出\)</span>A B C
$的不交路径的奇偶数量差,会发现左右的组合意义是相等的.</p>
<p>于此之外,还有一个纯代数的证明策略,不妨定义符号$A { J } = A { j _1 , ,
j _s } <span class="math inline">\(表示提取下标集\)</span>I <span class="math inline">\(和\)</span>J $分别作为行列得到的矩阵.</p>
<p>先证明一个引理:$C M <em>{ n n } , [ x ^{ n - k } ] ( xI + C ) =
</em>{ I { 1 , , n } , | I | = k } C { I } $.</p>
<p>回忆到运算符$<em>{ i , j } = [ i = j ] <span class="math inline">\(,应当注意到:\)</span>( xI + C ) = </em>{ } ( )
<em>{ i = 1 } ^n ( x [ i = j ] + c </em>{ i , ( i ) } ) <span class="math inline">\(,此时要想凑出\)</span>x ^{ n - k } <span class="math inline">\(,就需要有\)</span>n - k <span class="math inline">\(个位置被卡死,而剩下的部分无非是提取剩下\)</span>k
<span class="math inline">\(行\)</span>k
$列后的结果.就可以见到上述引理无非定义的平凡推论.</p>
<p>然后开始证明该定理,回忆到我们已经证明过$x ^{ m - n } ( xI + AB ) = (
xI + BA ) <span class="math inline">\(.此时对左右两边取\)</span>[ x ^{ m
- n } ] <span class="math inline">\(,左边取出了\)</span>( xI + AB )
<span class="math inline">\(的常数项,亦即\)</span>( AB ) <span class="math inline">\(.而右边,按上述引理得知得到了\)</span>_{ I { 1 , ,
n } , | I | = k } ( ( BA ) { I } ) $,而这恰为原本右式的矩阵乘法定义.</p>
<p>由该定理得知,对于$A M _{ m n } <span class="math inline">\(,\)</span>
$.</p>
<h4><span id="特征值与特征向量">特征值与特征向量</span></h4>
<p>我们之前应当已经见到,如果一个矩阵是分块对角矩阵,那这个矩阵应当相当容易处理,原因是其加减乘运算无非只是在对角线上的适当操作而已.这引发我们选取适当的直和分解$V
= V _k $将原本的矩阵化为合适的分块对角矩阵.</p>
<p>然而如果我们想要拿到具体的矩阵就不可避免地需要选基,因此在固定的基意义下,我们对于一个矩阵$A
<span class="math inline">\(,应当思考能否通过换基操作使得\)</span>A = P
^{ - 1 } BP <span class="math inline">\(,其中\)</span>B <span class="math inline">\(是一个分块对角矩阵,那此时\)</span>A
$也拥有相当好的性质.</p>
<p>考虑最简单的情况,即每个分块都是单个元素的情况,此时该矩阵应当就是一个对角矩阵.这相当于选定一组基${
_1 , , _n } <span class="math inline">\(后,取\)</span>V _k = { _k }
<span class="math inline">\(并将这些\)</span>V _k <span class="math inline">\(取直和得到\)</span>V <span class="math inline">\(,此时该线性映射应当给出\)</span>T _k = _k _k
$,即只能做一个伸缩变换.上面的种种操作都引诱我们去思考能否进行以上操作,这就引入下面的定义:</p>
<p>设$T ( V ) <span class="math inline">\(并且\)</span>F
$,我们引入如下定义:</p>
<ol type="1">
<li><p>称子空间$V _= ( <em>V - T ) <span class="math inline">\(为\)</span>T <span class="math inline">\(的\)</span><span class="math inline">\(**特征子空间**,若\)</span>V </em>{ 0 } <span class="math inline">\(,则称\)</span><span class="math inline">\(为\)</span>T $的<strong>特征值</strong>.</p></li>
<li><p>对于$ V _<span class="math inline">\(,换言之\)</span>T = <span class="math inline">\(,而且\)</span> <span class="math inline">\(,则称\)</span> <span class="math inline">\(是\)</span>T <span class="math inline">\(的一个**特征向量**,以\)</span>$为特征值.</p></li>
</ol>
<p>考虑特征值的定义等价于$( I - T ) = 0 <span class="math inline">\(,于是等价于\)</span> _T ( ) = 0 <span class="math inline">\(.立刻见到一个\)</span><span class="math inline">\(是特征值等价于其是\)</span> _T = 0 <span class="math inline">\(的一个根.反之,\)</span> _T = 0 <span class="math inline">\(的一个根也一定对应了一个非空的特征子空间,也就对应了一组非零特征向量.如果\)</span>T
$分裂,见到行列式其实是特征值的乘积,而迹实际上是特征值的加和.应当见到,一个矩阵可逆等价于其不存在$0
$特征值.</p>
<p>考虑对角化,如果我们能在上面取出若干$ <span class="math inline">\(组成一组基,那直接用这组基就可以把\)</span>T <span class="math inline">\(拆成在这组基上的伸缩变换,这样就实现了对角化.因此如果我们能取出一组基使得每一个基对\)</span>A
<span class="math inline">\(都是特征向量,我们称\)</span>A <span class="math inline">\(是**可对角化的**.立刻见到可对角化的必要条件是\)</span>
_A $分裂.</p>
<p>如果$T <span class="math inline">\(可对角化,我们有\)</span>V _= d
<span class="math inline">\(,其中\)</span>d <span class="math inline">\(是\)</span><span class="math inline">\(作为特征多项式的根的重数.如果其可对角化,直接按上述方式取基得到\)</span>z
<span class="math inline">\(,并且\)</span>PTP ^{ - 1 } <span class="math inline">\(就是在标准基下的变换矩阵.那么直接考虑\)</span> (
_n I - T ) = n - d <span class="math inline">\(,其中\)</span>d <span class="math inline">\(是\)</span><em>n <span class="math inline">\(的重数.用同态基本定理立刻得到\)</span>V </em>{ _n
} = d $.(注意这里都是在讨论可对角化的前提下)</p>
<p>我们希望能把$V _{ _k } <span class="math inline">\(给做直和,那我们就需要做前置工作.具体而言,我们需要证明选取\)</span>
<em>k V </em>{ _k } <span class="math inline">\(,那么\)</span> _k = k ,
_k = <span class="math inline">\(.使用数学归纳,注意到\)</span>T ( _k ) =
_k _k = 0 <span class="math inline">\(,又知道\)</span>_1 _k = 0
$,两者一消就可以进行数学归纳.</p>
<p>由上面的过程得知下述命题等价:</p>
<ol type="1">
<li><p>$T <span class="math inline">\(在\)</span>F $上可对角化.</p></li>
<li><p>$<em>{ F } V </em>{ } = V $.</p></li>
<li><p>$<em>{ F } V </em>= V $.</p></li>
</ol>
<p>其推论是如果所有的$<em>k <span class="math inline">\(互不相同,那么\)</span>V </em>{ _k } <span class="math inline">\(,这必然给出\)</span>T
$可对角化.这似乎告诉我们去除重数有某种很好的性质.</p>
<h4><span id="极小多项式">极小多项式</span></h4>
<p>考虑对于一个多项式$h F [ x ] <span class="math inline">\(,当我们将\)</span>T ( V ) <span class="math inline">\(带入之后当然会得到一个\)</span>h ( T ) ( V ) <span class="math inline">\(,现在固定\)</span>h , T <span class="math inline">\(,以此构造一个子空间\)</span>V [ h ] = ( h ( T ) )
= { V | h ( T ) = 0 } $.</p>
<p>此时注意到$T ( V [ h ] ) V [ h ] <span class="math inline">\(,原因是\)</span>T <span class="math inline">\(与自身交换,于是\)</span> V [ h ] <span class="math inline">\(,应当有\)</span>h ( T ) ( T ) = Th ( T ) = T ( ) =
<span class="math inline">\(,这意味着\)</span>T V [ h ] <span class="math inline">\(.于是可见到\)</span>V [ h ] <span class="math inline">\(实际上是一个\)</span>T $不变子空间.</p>
<p>取$h = x - I <span class="math inline">\(,那么\)</span>V [ h ] <span class="math inline">\(其实就是我们上述所说的\)</span>V <em><span class="math inline">\(,因此\)</span>V </em><span class="math inline">\(也是\)</span>T <span class="math inline">\(不变的.从这里立刻能看出些什么,比如当\)</span>V _=
1 <span class="math inline">\(的时候,\)</span>T
$不变当然意味着伸缩变换.</p>
<p>那我们既然需要这个东西用在$V _<span class="math inline">\(上,首要要做的当然是分析在其上面的直和分解.换言之,我们下面试图证明如下引理(核引理):\)</span>f
g <span class="math inline">\(的时候,\)</span>V [ fg ] = V [ gf ] = V [
f ] V [ g ] $.</p>
<p>原因是考虑$F [ x ] <span class="math inline">\(的主理想性引出其裴蜀定理,那么就存在多项式\)</span>a
, b <span class="math inline">\(使得\)</span>af + bg = 1 <span class="math inline">\(.此时\)</span> = ( af + bg ) ( T ) = a ( T ) ( f (
T ) ) + b ( T ) ( g ( T ) ) <span class="math inline">\(.注意到如果\)</span> V [ fg ] <span class="math inline">\(,那么\)</span>f ( T ) V [ g ] , g ( T ) V [ f ]
<span class="math inline">\(,而\)</span>V [ g ] <span class="math inline">\(和\)</span>V [ f ] <span class="math inline">\(对\)</span>a ( T ) <span class="math inline">\(和\)</span>b ( T ) <span class="math inline">\(都是不变子空间,原因是它们对\)</span>T <span class="math inline">\(都是不变子空间,这必然意味着\)</span>a ( T ) ( f (
T ) ) V [ g ] <span class="math inline">\(,后者亦然同理.这意味着\)</span>V [ fg ] V [ f ] +
V [ g ] <span class="math inline">\(,而\)</span>V [ f ] V [ fg ] , V [ g
] V [ fg ] <span class="math inline">\(,这立刻得到\)</span>V [ fg ] = V
[ f ] + V [ g ] <span class="math inline">\(.此时检查\)</span> V [ g ] V
[ f ] <span class="math inline">\(,发现\)</span> = ( af + bg ) ( T ) =
<span class="math inline">\(,这就意味着\)</span>V [ fg ] = V [ f ] V [ g
] $.</p>
<p>考虑$I = { f F [ x ] | f ( T ) = 0 _V } <span class="math inline">\(,容易见到其应当也有某种\)</span><span class="math inline">\(的性质,事实上可以证明它是一个理想,原因是当然满足加法和乘法的封闭律.而由于\)</span>F
[ x ] <span class="math inline">\(是一个主理想环,那么上面就应当存在一个\)</span><span class="math inline">\(极小的\)</span>h <span class="math inline">\(,使得\)</span>I = ( h ) <span class="math inline">\(,不妨将\)</span>h <span class="math inline">\(规范化为首一的多项式.那么以上操作给出:\)</span>f (
T ) = 0 h | f $.</p>
<p>由Cayley-Hamilton定理,当维度有限的时候,这样的多项式必然存在,这就意味着$I
{ 0 } <span class="math inline">\(,此时我们就把上面的这个\)</span>h
<span class="math inline">\(叫做\)</span>T <span class="math inline">\(的**极小多项式**\)</span> _T $.</p>
<p>值得一提的是如果$A <span class="math inline">\(是在\)</span>F <span class="math inline">\(上的矩阵,其极小多项式为\)</span> <em>{ A , F }
<span class="math inline">\(,\)</span>F <span class="math inline">\(是\)</span>E <span class="math inline">\(的子域,\)</span>A <span class="math inline">\(在\)</span>E <span class="math inline">\(上的极小多项式为\)</span> </em>{ A , E } <span class="math inline">\(,则\)</span> <em>{ A , F } = </em>{ A , E } <span class="math inline">\(.原因是首先\)</span> <em>{ A , E } | </em>{ A , F
} <span class="math inline">\(,于是\)</span> <em>{ A , E } = </em>{ A ,
F } <span class="math inline">\(等价于\)</span>A ^0 , , A ^{ d - 1 }
<span class="math inline">\(线性无关,其中\)</span>d = _{ A , F }
$.而判定线性无关实际上是用高斯消元判定的,和域的选取无关.</p>
<p>用一次Cayley-Hamilton定理,知道$ _T | _T <span class="math inline">\(.既然如此,\)</span> _T <span class="math inline">\(保留了\)</span> _T <span class="math inline">\(的哪些具体性质呢?它们之间的关系又如何呢?我们下面尝试证明:如果\)</span><span class="math inline">\(是\)</span>T <span class="math inline">\(的特征值,当且仅当\)</span> _T ( ) = 0 $.</p>
<p>充分性显然,因为我们已经声明了只要是$ _T $的一个根就自动是特征值.</p>
<p>下面证明必要性:注意到如果$<span class="math inline">\(是特征值,此时\)</span> = _T ( T ) = _T ( ) <span class="math inline">\(,原因是观察到如果\)</span>T = <span class="math inline">\(,那么立刻得到\)</span>f ( T ) = f ( ) <span class="math inline">\(.于是立刻得到\)</span> _T ( ) = 0 $.</p>
<p>此时见到端倪,我们再证明以下定理:</p>
<p>对于固定的$T ( V ) <span class="math inline">\(如果有直和分解\)</span>V = V _k <span class="math inline">\(,其中每个\)</span>V _k <span class="math inline">\(都是\)</span>T <span class="math inline">\(不变子空间,那么就可以把\)</span>T <span class="math inline">\(限制到相应的\)</span>V <em>k <span class="math inline">\(空间内,记作\)</span>T | </em>{ V _k } ( V <em>k )
<span class="math inline">\(,那在这些空间内部自然有它们自己的极小多项式\)</span>
</em>{ T _k } <span class="math inline">\(,我们断言\)</span> _T = <em>k
( </em>{ T <em>k } ) <span class="math inline">\(.原因是由于直和的性质,\)</span>f ( T ) = <span class="math inline">\(当且仅当对于每一个\)</span>k <span class="math inline">\(,\)</span>f ( T </em>{ k } ) = 0
$,应用极小多项式的定义立刻见到上述结论显然.</p>
<p>对于$T ( V ) <span class="math inline">\(,我们应当能见到此时\)</span>V = V [ _{ T } ] <span class="math inline">\(.那么反过来,\)</span>V [ _T ] = V <span class="math inline">\(的极小多项式当然也是\)</span> _T
$本身,这只是定义.</p>
<p>不妨设$ _T = fg <span class="math inline">\(并且\)</span>f g <span class="math inline">\(,从上面当然可以知道\)</span>V = V [ f ] V [ g ]
<span class="math inline">\(.此时我们应当思考的是\)</span>V [ f ] <span class="math inline">\(中的极小多项式是否是\)</span>f <span class="math inline">\(,\)</span>V [ g ] <span class="math inline">\(中的极小多项式是否是\)</span>g <span class="math inline">\(.而\)</span> _T <span class="math inline">\(是\)</span>V [ f ] <span class="math inline">\(和\)</span>V [ g ] <span class="math inline">\(中极小多项式的乘积,它们中的极小多项式又只是\)</span>f
, g $的因子,那必然见到极小多项式就是它们.</p>
<p>我们理应从上面的分析中见到极小多项式形态的一种刻画,我们接下来尝试证明,如果$T
<span class="math inline">\(在\)</span>F <span class="math inline">\(上可对角化,其特征值去重后是\)</span>_1 , , _m
<span class="math inline">\(,那么最小多项式\)</span> <em>T = </em>{ k =
1 } ^m ( x - _k ) $.</p>
<p>原因是考虑$T <span class="math inline">\(可对角化导致\)</span>V <span class="math inline">\(可以被拆成特征子空间的直和\)</span>V = <em>{ k = 1
} ^m V </em>{ _k } <span class="math inline">\(.而其限制在每一个特征子空间上都是一个伸缩变换,其对应的极小多项式无外乎\)</span>x
- _k $,这样就得到上面的结论.</p>
<p>上述结论反之依然成立,那我们可以拿出一个更好的结论了,即:$T <span class="math inline">\(在\)</span>F <span class="math inline">\(上可对角化的充要条件是极小多项式\)</span> _T F [ x
] $分裂并且无重根.</p>
<p>必要性在上面已经证明,接下来说明充分性.</p>
<p>当$ <em>T = </em>{ k = 1 } ^m ( x - _k ) <span class="math inline">\(的时候,我们下面证明\)</span>T <span class="math inline">\(可对角化,顺便说明此时\)</span>_1 , , <em>m <span class="math inline">\(就是\)</span>T <span class="math inline">\(的特征值去重后的结果.运用上述结论可以知道\)</span>V
= V [ x - _k ] <span class="math inline">\(.然而\)</span>V [ x - _k ] =
V </em>{ _k } $,这立刻就回到了可对角化的等价条件,于是充分性得证.</p>
<p>应当能从上面看出可对角化的某种拆分性,事实上,如果$T ( V ) <span class="math inline">\(可对角化,\)</span>V <em>0 V <span class="math inline">\(是\)</span>T <span class="math inline">\(下的不变子空间,则\)</span>T | </em>{ V _0 } ( V _0
) <span class="math inline">\(和\)</span>{ T } ( V / V _0 ) <span class="math inline">\(都可以对角化.原因是它们的极小多项式都应当是\)</span>
_T $的因子.</p>
<p>然而也可以看出来上述命题的逆并不成立,因为拆出来的两个的极小多项式并不一定互质.</p>
<h4><span id="同步对角化">同步对角化</span></h4>
<p>设$ ( V ) <span class="math inline">\(,如果存在\)</span>V <span class="math inline">\(的基\)</span> _1 , , _n <span class="math inline">\(使得每个\)</span> _i <span class="math inline">\(都是所有\)</span>T <span class="math inline">\(的共同的特征向量,换言之每一个\)</span>T <span class="math inline">\(都可以用同样的一个可逆矩阵\)</span>P <span class="math inline">\(使得\)</span>P ^{ - 1 } AP <span class="math inline">\(是对角的,那我们称\)</span> <span class="math inline">\(在\)</span>F
$上可以<strong>同步对角化</strong>.</p>
<p>我们首先证明一个引理:如果$ST = TS <span class="math inline">\(,那么\)</span>T <span class="math inline">\(的任何一个特征子空间\)</span>V <em><span class="math inline">\(都是\)</span>S <span class="math inline">\(的一个不变子空间.原因是对于\)</span> V </em>$:</p>
<p><span class="math display">\[
\begin{aligned}
T \vec { v  } &amp; = \lambda \vec { v  } \\
ST \vec { v  } &amp; = \lambda ( S \vec { v  } ) \\
T ( S \vec { v  } ) &amp; = \lambda ( S \vec { v  } )
\end{aligned}
\]</span></p>
<p>所以$S V _$.</p>
<p>我们得知同步对角化的充要条件应该是以下两条同时成立:</p>
<ol type="1">
<li><p>每个$T <span class="math inline">\(在\)</span>F
$上都可对角化.</p></li>
<li><p>$T , T ’ <span class="math inline">\(,\)</span>TT ’ = T ’ T
$.</p></li>
</ol>
<p>必要性显然,下面来说明充分性.</p>
<p>取出$T <em>1 <span class="math inline">\(的所有特征子空间\)</span>V
</em><span class="math inline">\(,由于\)</span>T ’ <span class="math inline">\(可对角化,所以其限制在\)</span>T ’ | <em>{ V </em>}
<span class="math inline">\(上肯定也可对角化.如果我们能说明限制在每一个特征子空间\)</span>V
<em><span class="math inline">\(上时都可以同步对角化,由于特征子空间是直和分解,所以取直和后当然也可以.此时注意到限制后的\)</span>T
’ <span class="math inline">\(必然也有交换律,而\)</span>T <em>1 | </em>{
V </em>} <span class="math inline">\(本身应当是\)</span>I <span class="math inline">\(.这个东西怎么着都是可对角化的,因此就只需要对除了\)</span>T
_1 $剩下部分继续做,这样就实现了数学归纳.</p>
<h4><span id="上三角化">上三角化</span></h4>
<p>回忆到我们之前曾经提过的旗的概念,我们在下面断言:若$T ( V ) <span class="math inline">\(保持\)</span>V <span class="math inline">\(的一组完备旗,则\)</span>T <span class="math inline">\(在\)</span>F
$上<strong>可上三角化</strong>,也就是其可以换基得到一个上三角矩阵.</p>
<p>我们已经得知一般的矩阵未必能对角化,那能不能退而求其次讲一个矩阵通过共轭转化为上三角的形式呢?我们下面证明:$
_T <span class="math inline">\(在\)</span>F <span class="math inline">\(上分裂是\)</span>T <span class="math inline">\(在\)</span>F $上可上三角化的充要条件.</p>
先证明必要性:当其可上三角化的时候,可以取$V <span class="math inline">\(的一组有序基,使得\)</span>T <span class="math inline">\(对应的矩阵形如\)</span>
<span class="math display">\[\begin{bmatrix}\lambda _1 &amp; \cdots
&amp; \cdots \\ 0 &amp; \ddots &amp; \cdots \\ 0 &amp; 0 &amp; \lambda
_n \end{bmatrix}\]</span>
<p><span class="math inline">\(,此时立刻能得到其\)</span> _T = ( x - _k
) $,这立刻给出其可分裂.</p>
<p>再证明充分性:数学归纳,取出$_1 <span class="math inline">\(和\)</span>
<em>1 V </em>{ _1 } { 0 } <span class="math inline">\(,再令\)</span>V _1
= { _1 } <span class="math inline">\(,这里拿到的\)</span>V _1 <span class="math inline">\(当然是一个不变子空间.仍取\)</span>: V V / V _1
<span class="math inline">\(,接下来观察\)</span>V / V _1 <span class="math inline">\(的维数降了一维,根据数学归纳那其当然可以上三角化.回忆到我们曾经声明过了此时\)</span>
_T = ( x - <em>1 ) </em>{ { T } } <span class="math inline">\(,原因是之前曾提过的在此分解下行列式之间的关系.可上三角化应当给出在\)</span>V
/ V _1 <span class="math inline">\(上的一个被\)</span>{ T } <span class="math inline">\(保持的完备旗\)</span>{ 0 } = { V _1 } { V _n } = {
V } <span class="math inline">\(.第一同构定理已经声明过对他们取原像后仍然是子空间,于是我们取原像应当可以重新得到一列完备旗:\)</span>{
0 } = V _0 V _1 V _n = V $.</p>
<p>我们断言上述的旗也被$T <span class="math inline">\(保持,原因是\)</span> V _i ( T ) = { T } ( ) { T }
( { V } _i ) { V } _i = ( V _i ) <span class="math inline">\(,这当然意味着\)</span>T V _i
$,于是数学归纳就成立了.</p>
<p>值得一提的是上述证明可以原样拿来证明Cayley-Hamilton定理.方法是仍采取数学归纳,取$V
<em>1 = { <em>1 } <span class="math inline">\(后,用数学归纳应当有\)</span></em>{ k = 2 } ^n ( {
T } - <em>i I ) = </em>{ { T } } ( { T } ) = 0 <span class="math inline">\(.然而我们早就知道了\)</span>{ T } = T <span class="math inline">\(,于是立刻得知\)</span> V , </em>{ k = 2 } ^n ( T -
_i I ) ( ) V _1 <span class="math inline">\(,两边同做\)</span>T - _1 I
$映射立刻得到结论.</p>
<h4><span id="广义特征子空间">广义特征子空间</span></h4>
<p>定义$V _{ [ ] } = _k V [ ( x - ) ^k ] $.</p>
<p>先来分析其与通常讨论的特征子空间之间的关系,我们声明:$V <em>{ [ ] } V
</em> $.</p>
<p>由于$V <em>V </em>{ [ ] } $,右推左是显然的.</p>
<p>而考虑左推右,$ V <em>{ [ ] } , ( T - ) ^N = , ( T - ) ^{ N - 1 }
<span class="math inline">\(,那么\)</span>( T - ) ^{ N - 1 } V </em>{ }
$.</p>
<p>这个无限取并能不能降下去呢?而且上面这个东西应当需要有一种划分原空间的策略,这就意味着其应当和极小多项式有一定关系.事实上,如果特征多项式$
_T = ( x - _i ) ^{ a _i } <span class="math inline">\(,极小多项式\)</span> _T = ( x - <em>i ) ^{ b <em>i
} <span class="math inline">\(,那么\)</span>V </em>{ [ _i ] } = V [ ( x
- _i ) ^{ b _i } ] <span class="math inline">\(.首先肯定有\)</span>V [ (
x - _i ) ^{ b _i } ] V </em>{ [ _i ] } $,所以只需证明反向包含即可.</p>
<p>此时注意到$ V _{ [ _i ] } <span class="math inline">\(,则存在\)</span>k <span class="math inline">\(使得\)</span>( T - _i ) ^k = <span class="math inline">\(.此时取\)</span>h = ( ( x - _i ) ^k , _T ) <span class="math inline">\(,用裴蜀定理立刻得到\)</span>h = a ( x - _i ) ^k +
b _T <span class="math inline">\(,于是立刻见到\)</span>h ( T ) = <span class="math inline">\(.但容易注意到\)</span>h | ( x - _i ) ^{ b _i }
$,这就证完了.</p>
<p>那么从之前我们的分析立刻得知$V = V [ _T ] = <em>{ i } V </em>{ [ _i ]
} <span class="math inline">\(.并且见到\)</span>V _{ [ _i ] } <span class="math inline">\(的极小多项式就是\)</span>( x - _i ) ^{ b _i }
<span class="math inline">\(,而因为极小多项式和特征多项式的根集相同并且原本的特征多项式等于分空间的特征多项式的乘积,因此特征多项式就是\)</span>(
x - _i ) ^{ a _i } $.</p>
<p>接下来我们定义代数重数:作为特征多项式的根的重数.几何重数:$V _{ _i }
$.</p>
<p>注意到代数重数$<span class="math inline">\(几何重数,等式成立当且仅当\)</span>V <em>{ <em>i }
= V </em>{ [ _i ] } <span class="math inline">\(.原因是\)</span>a <em>i
= </em>{ T <em>i } = V </em>{ [ _i ] } V </em>{ _i } $.</p>
<p>由于可对角化等价于可以拆分成若干特征子空间的直和,我们之前又已经证明过可对角化的几何重数一定等于代数重数,于是可对角化当且仅当几何重数等于代数重数.</p>
<p>另外代数重数和几何重数的关系还可以从线性方程组的角度理解,因为特征空间的维度就是$_k
I - A <span class="math inline">\(的自由变量的数量.而\)</span>_k <span class="math inline">\(的代数重数意味着\)</span>( x - _k )
$这一项在对角线的出现次数,现在这些位置都变成了$0
$,也就最多会有这么多个自由变量(还有可能上面某位置也有可以当主元的点顶替了他).那么几何重数就是实际上的自由量.</p>
<h4><span id="特殊矩阵的特征值">特殊矩阵的特征值</span></h4>
<h6><span id="example">Example</span></h6>
回忆道斐波那契数列应当转移矩阵为$T =
<span class="math display">\[\begin{bmatrix}0 &amp; 1 \\ 1 &amp; 1
\end{bmatrix}\]</span>
<p><span class="math inline">\(,如果能把这个东西对角化的话就会很舒服.直接解特征值能解出来\)</span>
_T = x ^2 - x + 1 <span class="math inline">\(,两个特征值\)</span>= { 2
} $.</p>
然后需要去解特征向量再用特征向量取基,解出来$ = (
<span class="math display">\[\begin{matrix}1 \\ \frac { 1 \pm \sqrt {
5  }  } { 2  } \end{matrix}\]</span>
) <span class="math inline">\(,这样立刻就拿到了换基矩阵\)</span>P = [ _1
, _2 ] <span class="math inline">\(和对角矩阵\)</span>D =
<span class="math display">\[\begin{bmatrix}\lambda _1 &amp; 0 \\ 0
&amp; \lambda _2 \end{bmatrix}\]</span>
<p><span class="math inline">\(,并且拿到\)</span>D = P ^{ - 1 } TP
$.</p>
<h3><span id="双线性形式">双线性形式</span></h3>
<h4><span id="线性映射">线性映射</span></h4>
<p>给定$F <span class="math inline">\(上的线性空间\)</span>V _1 , , V _n
, W <span class="math inline">\(,我们定义一个**多重线性映射**\)</span>C
: V _1 V _n W <span class="math inline">\(.满足其对每一个分量都是线性的.也即固定其他\)</span>m
- 1 $个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之:</p>
<p><span class="math display">\[
\begin{aligned}
C ( \cdots , t \vec { v  } _i , \cdots ) &amp; = tC ( \cdots , \vec {
v  } _i , \cdots ) \\
C ( \cdots , \vec { v  } _i + v _i &#39; , \cdots ) &amp; = C ( \cdots ,
\vec { v  } _i , \cdots ) + C ( \cdots , \vec { v  } _i &#39; , \cdots )
\end{aligned}
\]</span></p>
<p>特别地,当$W = F $的时候也叫做<strong>多重线性形式</strong>.</p>
<p>容易见到交错形式无非是多重线性形式的某种特例.</p>
<p>还可以看到多重线性映射的集合$ ( V _1 , , V _n ; W )
$本身也是线性空间.</p>
<p>更常用的是双线性映射,一般记作$ ( V _1 , V _2 ; W ) <span class="math inline">\(.矩阵乘法本身是双线性映射的一个典型例子,对偶空间本身也是双线性形式的一个典型例子.特别地,一般定义\)</span>V
<span class="math inline">\(和\)</span> <span class="math inline">\(之间的**典范配对**为\)</span>_ , _ : V F <span class="math inline">\(.其也可以看作点乘或者\)</span>( 1 n ) ( n )
$的矩阵乘法.</p>
<p>留意到柯里化过程,设$V = n , W = m $,容易见到:</p>
<p><span class="math display">\[
\begin{gathered}
M _{ m \times n  } \cong \\
\text { Hom  } ( V , \check { W  } ) \cong \text { Bil  } ( V , W ; F )
\cong \text { Hom  } ( W , \check { V  } ) \\
\cong M _{ n \times m  }
\end{gathered}
\]</span></p>
<p>证明是平凡的.</p>
<p>这就能看出$M <em>{ n m } ( V F ^n , W F ^m ; F ) <span class="math inline">\(,留意到其实可以取\)</span>A : W V <span class="math inline">\(以\)</span>( , ) A <span class="math inline">\(.取二者的坐标表示,立刻见到\)</span>( , ) </em>{ i
} _j v <em>i a </em>{ i , j } w _j = ( ) ^T A <span class="math inline">\(.留意到如果设\)</span>C ( , ) = B ( , ) <span class="math inline">\(,这个\)</span>C <span class="math inline">\(对应的矩阵实际上就是对\)</span>B
$对应的矩阵取了转置.</p>
<p>接下来考虑对其取直和,不妨考虑$B _1 : V _1 W _1 F , B _2 : V _2 W _2 F
<span class="math inline">\(,则令\)</span>B _1 B _2 : ( V _1 V _2 ) ( W
_1 W _2 ) F <span class="math inline">\(,其中\)</span>( ( _1 , _2 ) , (
_1 , _2 ) ) B _1 ( _1 , _1 ) + B _2 ( _2 , _2 ) <span class="math inline">\(.容易见到这是一个双线性形式.并且其代表的矩阵当然是原本的\)</span>B
_1 , B _2 $对应的矩阵组成的分块对角矩阵.</p>
<p>考虑双线性形式$B : V V F <span class="math inline">\(.称其为**对称的**当且仅当\)</span>B ( , ) = B ( ,
) <span class="math inline">\(,称其为**反对称的**当且仅当\)</span>B ( ,
) = - B ( , ) <span class="math inline">\(.容易看到对称的当且仅当其对应的矩阵为**对称矩阵**,即\)</span>A
= A ^T <span class="math inline">\(,原因是\)</span>B ( , ) = ( ) ^T A =
( ) ^T A ^T <span class="math inline">\(.反对称的对应的矩阵成为**反对称矩阵**或者**斜对称矩阵**,即\)</span>-
A = A ^T $.</p>
<h4><span id="非退化形式">非退化形式</span></h4>
<p>对于双线性形式$B : V W F <span class="math inline">\(,称\)</span>
<span class="math inline">\(是\)</span>B <span class="math inline">\(的一个**左根**当且仅当\)</span>B ( , _ ) <span class="math inline">\(.同理可以定义**右根**.容易见到左根右根集合分别应当是\)</span>V
, W <span class="math inline">\(的子空间.将左根空间记作\)</span>^{ } V
<span class="math inline">\(,右根空间记作\)</span>W ^{ } $.</p>
<p>当$V = W <span class="math inline">\(并且\)</span>B <span class="math inline">\(是对称的或者反对称的时候,此时左根和右根是一回事,一般将它们统称为\)</span>B
$的根基.</p>
<p>称$B <span class="math inline">\(是**非退化的**,当且仅当其左右根集合都是\)</span>{
} $.</p>
<p>现在考虑对于典范配对$, <span class="math inline">\(,考虑其左根和右根,显然都只是各自空间里的\)</span>
$,原因是对于前者是一个映射,其映射所有都是$0 $,那它当然是$0 <span class="math inline">\(映射本身.对于后者,考虑取\)</span> <span class="math inline">\(,扩充\)</span> <span class="math inline">\(为一组基\)</span> , _2 , _n <span class="math inline">\(,并取其对偶基\)</span> , _2 , , _n <span class="math inline">\(,此时就当然满足\)</span> , = 1
$,所以它是非退化的.</p>
<p>另一个例子是考虑迹映射$Tr : ( V ) ( V ) F , ( S , T ) ( ST ) <span class="math inline">\(,容易见到它是对称的.那么考虑其根基,只考虑左根,如果\)</span>T
, ( ST ) = 0 <span class="math inline">\(,应当满足对于基矩阵\)</span>E
<em>{ i , j } <span class="math inline">\(满足\)</span> ( SE </em>{ i ,
j } ) = 0 <span class="math inline">\(.容易见到\)</span>tr ( SE <em>{ i
, j } ) = 0 <span class="math inline">\(,所以\)</span>S </em>{ n n }
$.这意味着迹映射是非退化的.</p>
<p>回忆道双线性形式同构于线性映射$ ( V , ) <span class="math inline">\(或\)</span> ( W , ) <span class="math inline">\(,注意到左根实际上就是\)</span><span class="math inline">\(,右根实际上就是\)</span>$.</p>
<p>不妨假设$V &gt; W <span class="math inline">\(,则\)</span>= V - V - W
&gt; 0 <span class="math inline">\(,所以注意到\)</span>B <span class="math inline">\(是非退化的一定要有\)</span>V = W $.</p>
<p>现在我们对于$B : V W F <span class="math inline">\(并且满足\)</span>V
= W $,我们声称以下三条性质等价:</p>
<ol type="1">
<li><p>$B $是非退化的.</p></li>
<li><p>左根空间为$0 $.</p></li>
<li><p>右根空间为$0 $.</p></li>
</ol>
<p>显然只需说明(2)$<span class="math inline">\((3).两个方向类似,下面只证明(2)\)</span><span class="math inline">\((3).而当\)</span>= 0 <span class="math inline">\(时,由于两边维数相等,自然得到\)</span><span class="math inline">\(是一个同构.接下来考虑\)</span> <span class="math inline">\(如果是一个右根,那么对此取一个空间\)</span>H = { =
0 } <span class="math inline">\(,见到\)</span>( V ) <span class="math inline">\(一定是\)</span>H <span class="math inline">\(的一个子空间.但是\)</span>V = ( V ) H W <span class="math inline">\(,这就看出\)</span>H = V = n <span class="math inline">\(.然而当\)</span> <span class="math inline">\(的时候,\)</span>H
$不可能取到满空间,原因是典范同态是非退化的.这就导出了右根空间也是$0
$空间.</p>
<p>另一种看法是直接观察矩阵,右根实际上就是$( A ) <span class="math inline">\(,左根实际上就是\)</span>( A ^T ) <span class="math inline">\(,那它们的\)</span><span class="math inline">\(当然要相等,原因是它们的\)</span> $相等.</p>
<p>此时也容易注意到,非退化的矩阵实际上也就等价于可逆矩阵.</p>
<p>如果对商空间比较敏感,不妨设左根空间为$L <span class="math inline">\(,右根空间为\)</span>R <span class="math inline">\(,我们应当见到\)</span>{ B } : ( V / L ) ( W / R )
F , ( + L , + R ) B ( , ) <span class="math inline">\(是非退化双线性形式.此时见到其实\)</span>V - L = W
- R $.</p>
<p>适当推广上述结论,我们实际上可以定义任何子空间的$V _0 V <span class="math inline">\(的正交空间为\)</span>V _0 ^= { W _0 V _0 , B ( _0
, ) = 0 } <span class="math inline">\(.同理定义\)</span>^W _0 <span class="math inline">\(.容易见到\)</span>V _0 ^( V _0 ^) $.</p>
<p>我们试图寻找一些更好的关系,不妨假设$B <span class="math inline">\(是非退化的,那么立刻有\)</span>V = W <span class="math inline">\(,我们下面证明\)</span>V _0 ^+ V _0 = V $.</p>
<p>令$d = V _0 , n = V = W <span class="math inline">\(已经知道\)</span>B <span class="math inline">\(会对应一个同构\)</span>: V <span class="math inline">\(,那么取\)</span>V _0 <span class="math inline">\(在\)</span><span class="math inline">\(下的像,并取其基\)</span> _1 , , _d <span class="math inline">\(,此时\)</span>V _0 ^W <span class="math inline">\(是满足\)</span> _1 , _ = = _d , _ = 0
$的子空间.</p>
<p>不妨先考虑两个特殊情况并从中窥见归纳的办法.当$d = n <span class="math inline">\(的时候,此时\)</span>V _0 ^= V ^<span class="math inline">\(,也就是右根集合,我们之前已经证明过了这是一个零空间.而当\)</span>d
= 1 <span class="math inline">\(的时候,考虑\)</span> _1 $,因为它不是$0
<span class="math inline">\(,所以它必然是\)</span>W F <span class="math inline">\(的满射,此时意味着\)</span>   _1 = 1 <span class="math inline">\(,意味着此时\)</span>V _0 ^= ( _1 ) <span class="math inline">\(的维数应当是\)</span>n - 1 $.</p>
<p>接下来从上面的结构中跳出来,直接观察$ <span class="math inline">\(上的情形,我们将上述的那一组基扩充为\)</span> <span class="math inline">\(的基\)</span> _1 , _n <span class="math inline">\(并考虑\)</span>W <span class="math inline">\(的子空间列\)</span>^ _1 ^ _1 , , _n <span class="math inline">\(.不妨设\)</span>W _k = ^ _1 , , _k $.</p>
<p>然而此时可以见到$W _{ k + 1 } = W _k $,用第二同构定理得到:</p>
<p><span class="math display">\[
\begin{aligned}
\dim ( W _{ k + 1  } ) &amp; = \dim W _k + \dim ^\bot \langle \check {
w  } _{ k + 1  } \rangle - \dim ( W _k + ^\bot \langle \check { w  } _{
k + 1  } \rangle ) \\
&amp; \geq \dim W _k + \dim ^\bot \langle \check { w  } _{ k + 1  }
\rangle - n \\
&amp; = \dim W _k - 1
\end{aligned}
\]</span></p>
<p>因此每加一个最多降一维(其实等价于把那个$= 1 <span class="math inline">\(的空间商掉了),然而注意到上述空间列的首项是\)</span>n
- 1 $维,末项是$0 <span class="math inline">\(维,每次降一维的话就可以得到\)</span>^ _1 , , _d =
n - d $,这就证明了上述的结论.</p>
<p>然而上述推断其实并不意味着$V = V _0 ^+ V _0 <span class="math inline">\(,也不意味着\)</span>V _0 V _0 ^= { }
$,这两个结论都是得不到的.</p>
<p>然而好用的结论是我们之前已经提过$V _0 ^( V _0 ^) <span class="math inline">\(,此时我们注意到这个式子两边的维度实际上相等,因此\)</span>^(
V _0 ^) = V _0 $.再次声明此式子只在非退化的前提下成立.</p>
<h4><span id="伴随映射">伴随映射</span></h4>
<p>考虑两个双线性形式$B _1 , B _2 <span class="math inline">\(,其中\)</span>B _1 ( V _1 , V _1 ’ , F ) <span class="math inline">\(,\)</span>B _2 <span class="math inline">\(类似.我们声称存在唯一的线性映射\)</span>: ( V _1 ,
V _2 ) ( V _2 ’ , V _1 ’ ) , T T ^* <span class="math inline">\(满足\)</span>B _2 ( T _1 , _2 ’ ) = B _1 ( _1 , T
^* _2 ’ ) <span class="math inline">\(.其中这个\)</span>T ^* <span class="math inline">\(称为\)</span>T <span class="math inline">\(相对于\)</span>B _1 <span class="math inline">\(和\)</span>B _2 <span class="math inline">\(的**右伴随**.同理可以定义**左伴随**\)</span>^* T
<span class="math inline">\(满足\)</span>B _2 ( _2 , T _1 ’ ) = B _1 (
^* T _2 , _1 ’ ) <span class="math inline">\(,并且假设\)</span>B _1
<span class="math inline">\(非退化,它对应的矩阵\)</span>A _1 $可逆.</p>
<p>如何证明这个结论呢?只考虑右伴随的情况,对于某个固定的$ _2 ’ <span class="math inline">\(,取出映射\)</span>B _2 ( T ( _ ) , _2 ’ ) : V _1 F
<span class="math inline">\(.那它当然是\)</span> <span class="math inline">\(中的元素.而因为\)</span>B _1 <span class="math inline">\(非退化,其对应了一个\)</span>V _1 ’ _1 <span class="math inline">\(的同构,因此应当存在唯一的\)</span> _1 ’ <span class="math inline">\(使得其映射到\)</span> <span class="math inline">\(的时候恰好满足\)</span>B _2 ( T ( _ ) , _2 ’ ) = B
_1 ( _ , _1 ’ ) <span class="math inline">\(,这就给出了\)</span>T ^* :
_2 ’ _1 ’ <span class="math inline">\(.换言之其唯一性取决于\)</span>A _1
<span class="math inline">\(的非退化性.取\)</span>_i : V _i ’ <span class="math inline">\(且\)</span>_1 <span class="math inline">\(可逆,回忆到之前过程可以知道这里的\)</span>_1 <span class="math inline">\(实际上就是\)</span>A _1
$,下述图表的上半部分交换:</p>
<p><span class="math display">\[
\xymatrix { V _2 &#39; \ar [r ] ^{ T ^*  } \ar [d ] _{ A _2  } &amp; V
_1 &#39; \ar [d ] ^{ A _1  } \\
\check { V _2  } \ar [r ] ^{ ^t T  } &amp; \check { V _1  } \\
V _2 \ar [u ] &amp; V _1 \ar [u ] \ar [l ] _T  }
\]</span></p>
<p>另外可以见到如果假设$B _2 <span class="math inline">\(也是非退化的,当线性空间本身满足条件的时候应该有\)</span>^*
( T ^* ) = T = ( ^* T ) ^* <span class="math inline">\(.还可以见到\)</span>( ST ) ^* = T ^* S ^* , ^* (
ST ) = ^* T ^* S <span class="math inline">\(.这还顺便说明了\)</span>( T
^{ - 1 } ) ^* = ( T ^* ) ^{ - 1 } , ^* ( T ^{ - 1 } ) = ( ^* T ) ^{ - 1
} $.</p>
<p>上面的结论如何用矩阵刻画?只考虑右伴随的部分,选定一组有序基后,将双线性形式对应到矩阵应当有:</p>
<p><span class="math display">\[
\begin{aligned}
B _2 ( T \vec { v  } _1 , \vec { v  } _2 &#39; ) &amp; = ( \vec { v  }
_1 ) ^T T ^T A _2 \vec { v  } _2 &#39; &amp; = ( \vec { v  } _1 ) ^T A
_1 ( A _1 ^{ - 1  } T ^T A _2 ) \vec { v  } _2 &#39; \\
B _1 ( \vec { v  } _1 , T ^* \vec { v  } _2 &#39; ) &amp; = ( \vec {
v  } _1 ) ^T A _1 T ^* \vec { v  } _2 &#39;
\end{aligned}
\]</span></p>
<p>比对就可以看到只需取$T ^* = A _1 ^{ - 1 } T ^T A _2 <span class="math inline">\(,这与上述交换图表的形式也是符合的.同理可以得到\)</span>^*
T = ( A _2 TA _1 ^{ - 1 } ) ^T <span class="math inline">\(.并从此看出当\)</span>B _1 , B _2 <span class="math inline">\(都非退化的时候,伴随不改变矩阵的秩,因为此时伴随矩阵与原矩阵的转置是相抵的.事实上可以直接写出\)</span>(
T ^* ) = ( T ) ^$,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
T ^* \vec { w  } &amp; = 0 \Leftrightarrow \forall \vec { v  } , ( \vec
{ v  } \mid T ^* \vec { w  } ) &amp; = 0 \\
\Leftrightarrow \forall \vec { v  } , ( T \vec { v  } \mid \vec { w  } )
&amp; = 0 \Leftrightarrow \vec { w  } \in ( \text { im  } T ) ^\bot
\end{aligned}
\]</span></p>
<p>而由同态基本定理,$( T ) ^= ( T ^* ) <span class="math inline">\(,由上可以见到当\)</span>V = W <span class="math inline">\(时\)</span>  T =  T ^* $.</p>
<p>当对应的双线性形式非退化的时候回忆到可以两边取$<span class="math inline">\(就拿到\)</span>( T ^* ) ^= ( T ) $.</p>
<p>下面考虑$V _1 = V _2 = V _1 ’ = V _2 ’ = V <span class="math inline">\(,并假设\)</span>B _1 = B _2 <span class="math inline">\(且二者要么对称要么反对称.此时注意到\)</span>T
<span class="math inline">\(的左伴随和右伴随是没有区别的,我们将它们统一称作伴随,一般采取右伴随的记号记作\)</span>T
^* <span class="math inline">\(并尝试通过上下文区分.特别地,如果\)</span>T = T ^*
<span class="math inline">\(,那我们称其为**自伴的**,如果\)</span>T = - T
^* $,则称其为<strong>反自伴的</strong>.</p>
<p>如果选取$A _1 = A _2 = I <span class="math inline">\(,那么根据上面的分析见到\)</span>T <span class="math inline">\(是自伴的当且仅当\)</span>T
$是对称的,反自伴的当且仅当其是反对称的.</p>
<h4><span id="分类问题">分类问题</span></h4>
<p>定义双线性形式上的同构:称$( V _1 , B _1 ) ( V _2 , B _2 ) <span class="math inline">\(,其中\)</span>B _1 : V _1 V _1 F , B _2 : V _2 V
_2 F <span class="math inline">\(,当且仅当存在一个同构\)</span>: V _1 V
_2 <span class="math inline">\(,满足\)</span>B _2 ( ( ) , ( ’ ) ) = B _1
( , ’ )
$.容易验证这个同构满足等价条件的三条性质:反身性,对称性,传递性.并且双线性形式的几乎所有性质(左右根,根基,对称性,反对称性,退化性)都在同构关系下得到保持.这就意味着双线性形式应该可以以这种同构关系分类.</p>
<p>不失一般性,不妨直接假设$V = F ^n $以简化描述.</p>
<p>我们定义两个$n n <span class="math inline">\(的矩阵\)</span>A , A ’
<span class="math inline">\(是**合同的**,当且仅当\)</span>C ( M _{ n n }
) ^<span class="math inline">\(使得\)</span>A = C ^T A ’ C <span class="math inline">\(.容易验证这是一个等价关系.必须要强调这里的\)</span>C
$是可逆矩阵.</p>
<p>接下来考虑两个双线性形式$B , B ’ : F ^n F ^n F <span class="math inline">\(,我们声称当且仅当它们对应的矩阵\)</span>A , A ’
<span class="math inline">\(是合同的有\)</span>A = C ^T A ’ C <span class="math inline">\(时是同构的.同构办法就是利用\)</span>C
$所代表的线性映射.</p>
<p>对于充分性:只需检验是否有$B ( _1 , _2 ) = B ’ ( C _1 , C _2 ) <span class="math inline">\(,而\)</span>B ’ ( C _1 , C _2 ) = ( C _1 ) ^T A ’
( C _2 ) = ( _1 ) ^T A _2 = B ( _1 , _2 ) $.</p>
<p>对于必要性:考虑所有的同构$<span class="math inline">\(当然都可以写作可逆矩阵形式,设这个矩阵为\)</span>C
<span class="math inline">\(,立刻见到应当有\)</span>A = C ^T A ’ C
$.</p>
<h4><span id="二次型">二次型</span></h4>
<p>考虑$ <span class="math inline">\(的域\)</span>F <span class="math inline">\(,原因是这种域上面存在\)</span> { 2 } <span class="math inline">\(.为了方便讨论下面不妨直接假设\)</span>V = F ^n
$.</p>
<p>定义$n <span class="math inline">\(元**二次型**为一个\)</span>F <span class="math inline">\(上的齐次多项式\)</span>f = <em>i a </em>{ i , i }
x <em>i ^2 + 2 </em>{ i &lt; j } a <em>{ i , j } x <em>i x <em>j <span class="math inline">\(,并在考虑对称的情况下设\)</span>a </em>{ i , j } =
a </em>{ j , i } <span class="math inline">\(成立,上述自然有\)</span>f =
</em>{ i , j } a _{ i , j } x _i x _j <span class="math inline">\(.容易见到\)</span>f <span class="math inline">\(实际上可以表示为某一个对称的双线性形式,将这些\)</span>a
<span class="math inline">\(排列成矩阵就可以见到上述\)</span>f ( x ) = (
) ^T A = B ( , ) <span class="math inline">\(.这种对应实际上是双射,原因是该多项式也可以反过去确定一个对称的双线性形式,原因是注意到首先\)</span>B
( , ) <span class="math inline">\(肯定是可以被确定的,其次由于\)</span>B
( _1 + _2 , _1 + _2 ) = B ( _1 , _1 ) + B ( _2 , _2 ) + 2 B ( _1 , _2 )
<span class="math inline">\(,于是立刻得到\)</span>B ( _1 , _2 ) = { 2 }
( f ( _1 + _2 ) - f ( _1 ) - f ( _2 ) ) <span class="math inline">\(,这就给出了一组一一对应的关系.从这里顺便应该能看出对称双线性形式应该由其所有的\)</span>B
( , )
$的取值唯一确定.我们会在内积空间里再次讨论这个技巧,这被称为<strong>配极化</strong>.</p>
<p>将合同关系挪到二次型上就可以见到,两个二次型同构当且仅当它们可以通过一个可逆的线性变量替换而相互过渡.</p>
<p>既然如此,应该见到二次型某种意义上同构于矩阵,那么能不能把二次型作对角化呢,也即能否将二次型同构于形如$g
= b _i x _i ^2
$的二次型.这个当然可以用配方法解决,具体操作是数学归纳,每次将和一个变量有关的全部赛到一个里面去.</p>
<p>具体地,我们执行以下策略:</p>
<ol type="1">
<li><p>如果当前存在一个$a <em>{ i , i } <span class="math inline">\(,不妨设其为\)</span>a </em>{ 1 , 1 } <span class="math inline">\(,那就可以提出一个\)</span>a <em>{ 1 , 1 } ( x
<em>1 + { a </em>{ 1 , 1 } } </em>{ k } a _{ 1 , k } x _k ) ^2
$.</p></li>
<li><p>反之,则存在一个$a _{ i , j } <span class="math inline">\(,不妨在此时做变量替换\)</span>y _i = x _i - x _j
<span class="math inline">\(换掉\)</span>x _i <span class="math inline">\(,这样\)</span>x _j ^2 $前的系数就非$0
$,自然回到前一种情况.</p></li>
</ol>
<p>上述过程不好机械化,能不能用一些更加形式化的方式呢?考虑配方当然等价于寻找一个可逆矩阵$C
<span class="math inline">\(使得对称矩阵\)</span>A <span class="math inline">\(被写作\)</span>C ^T AC = A ’ <span class="math inline">\(,而可逆矩阵可以写作若干初等矩阵的乘积,不妨记作\)</span>U
_1 U _k <span class="math inline">\(,于是知道我们想要让\)</span>( U _1 U
_k ) ^T A ( U _1 U _k ) $.</p>
这里有一个算法是将矩阵排列成$
<span class="math display">\[\begin{bmatrix}A \\ I
\end{bmatrix}\]</span>
<span class="math inline">\(的形式,然后对其做对称行列变换(这样列变换会影响到下面的\)</span>I
<span class="math inline">\(,但是行变换不会影响),这样最后会消成\)</span>
<span class="math display">\[\begin{bmatrix}A &#39; \\ C
\end{bmatrix}\]</span>
<p><span class="math inline">\(的形式,就会有\)</span>A ’ = C ^T AC
$.</p>
<p>由此可以设$r = ( f ) <span class="math inline">\(为对角化后剩余的元素个数.见到其根基的维数恰为\)</span>n
- r <span class="math inline">\(,原因是\)</span>A <span class="math inline">\(的维数就是根基的维数.见到其非退化当且仅当\)</span>n
= r $.</p>
<p>如果我们做的域是一个代数闭域,那么我们上面的分类问题立刻得到了解决,原因是二次型当然可以进一步化简为$_{
k = 1 } ^r y _k ^2 <span class="math inline">\(的形式,因此二次型完全由秩来决定.当然其实代数闭这个性质并没有用完全,实际上上述结论只需要求所有的\)</span>F
$中元素都有平方根即可.</p>
<h5><span id="实二次型">实二次型</span></h5>
<p>然而我们知道实数域并不满足以上性质,能不能把实数上的二次型进一步分类呢?虽然不能对$-
1 <span class="math inline">\(开根,但总之可以将二次型同构成\)</span>f =
_{ k = 1 } ^p x <em>k ^2 - </em>{ j = p + 1 } ^r x _j ^2
$.将此称作该二次型的<strong>规范型</strong>.</p>
<p>先对于实二次型引入一些新的定义:对于一个对称双线性形式,如果$ <span class="math inline">\(,\)</span>B ( , ) <span class="math inline">\(恒成立,则称其为**半正定的**,如果在此基础上当\)</span>
<span class="math inline">\(时\)</span>B ( , ) &gt; 0 <span class="math inline">\(恒成立,则称其为**正定**的.同样可以定义**半负定的**和**负定的**概念.还可以定义**不定的**概念.容易见到如果一个对称双线性形式是正定的或者负定的时候它必然是非退化的,因为此时除了\)</span>
$其无根基.一定要注意这里的正定是在对称性的基础上定义的.</p>
<p>容易见到半正定当且仅当上述$f <span class="math inline">\(中满足\)</span>p = r <span class="math inline">\(,正定当且仅当满足\)</span>p = r = n <span class="math inline">\(.到这里我们忽然疑问到同构的二次型的\)</span>p
$是否相等.</p>
<h5><span id="惯性sylvester定理">惯性(Sylvester)定理</span></h5>
<p>即:对于两个同构的二次型,它们的$( p , r - p ) <span class="math inline">\(相同,一般将\)</span>p <span class="math inline">\(称作**正惯性系数**而将\)</span>r - p
$称作<strong>负惯性系数</strong>,两者的差$2 p - r
$一般称作其<strong>符号差</strong>.</p>
<p>之所以会疑惑同构的二次型的$p <span class="math inline">\(不一定相等,是因为同构只搬运了空间上的性质.因此如果我们能把\)</span>p
<span class="math inline">\(以某种基于空间上的形态,当然就可以显然看出两个同构的二次型的\)</span>(
p , r - p ) <span class="math inline">\(相同.我们声明对于一个正惯性系数为\)</span>p
$的二次型以下命题成立:</p>
<ol type="1">
<li><p>存在一个$p $维的正定子空间.</p></li>
<li><p>对于任何维数$&gt; p $的子空间,其都不可能是正定的.</p></li>
</ol>
<p>(1)显然,直接拿出其正部分对应的空间即可.</p>
<p>(2)的话无非是考虑将鸽笼原理用子空间之间的交写出来,设$N <span class="math inline">\(为后\)</span>p + 1 , , n <span class="math inline">\(这部分所代表的子空间,对于任何一个\)</span>V ’
<span class="math inline">\(子空间满足\)</span>V ’ &gt; p
$,直接拿第二同构定理得到:</p>
<p><span class="math display">\[
\begin{aligned}
\dim ( V &#39; \cap N ) &amp; = \dim ( V &#39; ) + \dim ( N ) - \dim ( V
&#39; + N ) \\
&amp; \geq n - p + \dim V &#39; - n &amp; &gt; 0
\end{aligned}
\]</span></p>
<p>这意味着其不为空.</p>
<p>对负惯性系数当然可以类似做.这样惯性定理自然解决了实二次型的分类问题.</p>
<h4><span id="辛空间">辛空间</span></h4>
<p>回到特征不为$2 <span class="math inline">\(的域\)</span>F <span class="math inline">\(上,考虑反对称形式,注意到\)</span>B ( , ) = - B ( ,
) $,那此时它们就应该同时为$0 $.这当然类似我们之前说的交错形式.</p>
<p>观察这类反对称形式的根基,取$R ( V ) = { V B ( , _ ) = 0 } <span class="math inline">\(.此时把补空间拿出来,取\)</span>V = R ( V ) V ’
<span class="math inline">\(,我们断言\)</span>( V , B ) ( R ( V ) , 0 )
( V ’ , B <em>{ V ’ V ’ } ) <span class="math inline">\(,其中\)</span>B
</em>{ V ’ V ’ } <span class="math inline">\(是\)</span>V ’ <span class="math inline">\(上的非退化线性形式.这个断言当然是显然的,只需简单拆分空间即可.问题在于如何证明\)</span>B
_{ V ’ V ’ } <span class="math inline">\(是\)</span>V ’ <span class="math inline">\(上的非退化线性形式,只需证明\)</span>R ( V ’ ) = {
0 } <span class="math inline">\(,我们考虑如果\)</span> ’ V ’ <span class="math inline">\(,\)</span> _1 ’ V ’ , B ( ’ , _1 ’ ) = 0 <span class="math inline">\(,由于根基当然和任何东西都会变零,因此这等价于\)</span>
_1 V , B ( ’ , _1 ) = 0 <span class="math inline">\(,这必然意味着\)</span> ’ R ( V ) <span class="math inline">\(,也就是\)</span> ’ R ( V ) V ’ = { 0 } $.</p>
<p>因此其实反对称双线性形式更重要的是考虑其非退化的部分.将这些非退化反对称双线性形式称为<strong>辛形式</strong>,并将$(
V , B ) $称作辛空间.</p>
考虑取一对基$ , <span class="math inline">\(形成空间\)</span> , <span class="math inline">\(并满足\)</span>B ( , ) = 1 = - B ( , ) <span class="math inline">\(,这当然唯一确定了一个辛形式\)</span>B <span class="math inline">\(,并且其实际上对应了一个反对称矩阵\)</span>
<span class="math display">\[\begin{bmatrix}0 &amp; 1 \\ - 1 &amp; 0
\end{bmatrix}\]</span>
<p>$,这种二维辛空间一般还被称为<strong>双曲辛平面</strong>.</p>
<p>虽然研究范围被限制在了辛空间上,但仍然能看到辛形式中会因为正负相抵爆出大量的$0
<span class="math inline">\(.设\)</span>V <em>0 <span class="math inline">\(是\)</span>V <span class="math inline">\(的子空间,若\)</span>B </em>{ V _0 V _0 } <span class="math inline">\(,我们称\)</span>V _0
$是<strong>全迷向子空间</strong>,一个极大(真包含它的子空间全都不是全迷向的)的全迷向子空间称为<strong>拉格朗日子空间</strong>.</p>
<p>设$( V , B ) <span class="math inline">\(为辛空间,\)</span>L
$是拉格朗日子空间,我们下面证明两个性质:</p>
<ol type="1">
<li><p>$L ^= L $.</p></li>
<li><p>$V = 2 L $.</p></li>
<li><p>辛空间必定是偶数维的.</p></li>
</ol>
<p>如果(1)得证,由于$V = L + L
^$,(2)(3)也就显然了.所以问题在于如何证明(1).</p>
<p>首先全迷向性质自然等价于$L L ^<span class="math inline">\(.此时考虑若\)</span> L ^L <span class="math inline">\(,则\)</span>L + <span class="math inline">\(这个空间仍然是全迷向的(原因是\)</span>
$自身的部分会因为交错性质而成$0 $),这就与其极大性矛盾.</p>
<p>我们试图想要找到更好的策略去勾勒$L <span class="math inline">\(以及\)</span>V / L $这两部分.</p>
<h5><span id="达布定理">达布定理</span></h5>
<p>该定理是说:给定一个拉格朗日子空间$L <span class="math inline">\(,\)</span>L <span class="math inline">\(的任何有序基\)</span> _1 , , _n <span class="math inline">\(都能扩充为\)</span>V <span class="math inline">\(的有序基\)</span> _1 , _n , _n , , _1 <span class="math inline">\(,使得\)</span> i , j n $:</p>
<ol type="1">
<li><p>$B ( p _i , p _j ) = B ( q _i , q _j ) = 0 $.</p></li>
<li><p>$B ( p _i , q _j ) = - B ( q _j , p _i ) =</p>
<span class="math display">\[\begin{cases}1 &amp; i = j \\ 0 &amp; i \ne
j \end{cases}\]</span>
<p>$.</p></li>
</ol>
<p>这组有序基又被称为$V $的<strong>辛基</strong>.</p>
<p>考虑定义$n - 1 <span class="math inline">\(维子空间\)</span>L <em>i =
<em>1 , , </em>{ i - 1 } , </em>{ i + 1 } , , _n <span class="math inline">\(.留意到此时会有\)</span>L = L ^L _i ^, L _i ^= n +
1 $.</p>
<p>接下来数学归纳构造这组$q $.</p>
<p>对于$k = 1 <span class="math inline">\(的情况,由于我们上面的分析,\)</span> _1 L _1 ^L
<span class="math inline">\(,于是此时必然满足\)</span>B ( _1 , _1 )
<span class="math inline">\(而\)</span>i , B ( _i , _1 ) = 0
$.适当伸缩即可满足条件.</p>
在此之后,假设$k &lt; n <span class="math inline">\(并且我们已经有了\)</span> <em>1 , , <em>k <span class="math inline">\(使得条件成立,仍然可以取\)</span> </em>{ k + 1 } ’
L </em>{ k + 1 } ^L <span class="math inline">\(,使得\)</span>B ( <em>i
, </em>{ k + 1 } ’ )
<span class="math display">\[\begin{cases}1 &amp; i = k + 1 \\ 0 &amp; i
\ne k + 1 \end{cases}\]</span>
<p>$满足.</p>
<p>此时注意到,如果用$ <em>{ k + 1 } = </em>{ k + 1 } ’ + _i a _i _i
<span class="math inline">\(后,上述条件实际上不受影响.然而,只需取\)</span>a _i
= B ( <em>i , </em>{ k + 1 } ’ ) $就自动满足最后的条件.</p>
<p>接下来无非是要证明这些向量线性无关,对于$a _i _i + b _i _i = 0 <span class="math inline">\(,两边取\)</span>B ( _ , _i ) <span class="math inline">\(就可以得到\)</span>a _i = 0 <span class="math inline">\(,取\)</span>B ( _i , _ ) <span class="math inline">\(就可以得到\)</span>b _i = 0 $,这样就做完了.</p>
<p>此时就可以见到,我们实际上是把原空间拆成了两个拉格朗日子空间的直和,并且这两个子空间之间以某种形式连接起来.此时其对应的矩阵就是:</p>
<p><span class="math display">\[
\begin{bmatrix}
&amp; &amp; &amp; &amp; &amp; 1 \\
&amp; &amp; &amp; &amp; \cdots &amp; \\
&amp; &amp; &amp; 1 &amp; &amp; \\
&amp; &amp; - 1 &amp; &amp; &amp; \\
&amp; \cdots &amp; &amp; &amp; &amp; \\
- 1 &amp; &amp; &amp; &amp; &amp;
\end{bmatrix}
\]</span></p>
<p>另外,如果$W <span class="math inline">\(是\)</span>V <span class="math inline">\(的子空间并且满足\)</span>W W ^= { 0 }
$,我们称这样的子空间是<strong>辛子空间</strong>.只需套用拉格朗日子空间的过程就可以证明:</p>
<ol type="1">
<li><p>$W <span class="math inline">\(是辛子空间当且仅当\)</span>B <span class="math inline">\(在\)</span>W $上的限制非退化.</p></li>
<li><p>$W <span class="math inline">\(是辛子空间则有直和分解\)</span>V =
W W ^$.</p></li>
</ol>
<h4><span id="回看对偶空间">回看对偶空间</span></h4>
<p>应当回忆我们将一个有限维空间对应到其对偶空间的时候所做的努力:先找到原空间的一组基,再对应地找到一组对偶基.然而,这种对应并非空间自身典范的对应,而是需要选定基的人为构造的定义.</p>
<p>回忆我们上述拿到的所有东西,应当可以见到起码以下资料均是典范的:</p>
<ol type="1">
<li><p>典范配对$_ , _ : V ^V F , , $.</p></li>
<li><p>转置映射$^t T : W ^V ^, T $.</p></li>
</ol>
<h5><span id="双重对偶">双重对偶</span></h5>
<p>先分析典范配对的情形,考虑到典范配对会给出一个映射$ev _V : V ( V ^) ^,
_ , <span class="math inline">\(.容易验证这当然是一个同构,而且中途没有用任何取基操作,所以这是一个典范的同构\)</span>
_V : V ( V ^) ^<span class="math inline">\(.更确切地来说,这个\)</span>
_V $具有某种函子性.事实上有以下交换图表:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^T \ar [d ] _{ \text { ev  } _V  } &amp; W \ar [d
] ^{ \text { ev  } _W  } \\
( V ^\vee ) ^\vee \ar [r ] ^{ ( T ^t ) ^t  } &amp; ( W ^\vee ) ^\vee  }
\]</span></p>
<p>虽属显然,但也可以小心地展开定义以确实证明$( _W ) T = ( T ^t ) ^t _V
<span class="math inline">\(.策略只需任取\)</span> $,而观察:</p>
<p><span class="math display">\[
\begin{aligned}
\langle ( ( T ^t ) ^t \text { ev  } _V ) \vec { v  } , \check { w  }
\rangle \\
&amp; = \langle ( \text { ev  } _V ) \vec { v  } , T ^t \check { w  }
\rangle \\
&amp; = \langle T ^t ( \check { w  } ) , \vec { v  } \rangle \\
&amp; = \langle \check { w  } , T \vec { v  } \rangle \\
&amp; = \langle \text { ev  } _W ( T \vec { v  } ) , \check { w  }
\rangle
\end{aligned}
\]</span></p>
<p>而$ $可以任取,立刻证毕.</p>
<p>回忆到还有一件重要的事情需要解释,那就是柯里化$ ( W , V ^) ( V , W ; F
) ( V , W ^) <span class="math inline">\(.从表面上看,它应当是典范的,可实则描述的时候却发现总需要标准内积结构来体现.为解决这个问题,我们下面证明上述同构映射将\)</span>
( W , V ^) <span class="math inline">\(为\)</span>( ^t ) _V ( V , W ^)
$.</p>
<p>考虑将两边都映射到典范配对的结构上,由双线性形式的定义,$ ( W , V ^)
<span class="math inline">\(必然映一组\)</span> , <span class="math inline">\(为\)</span>( ) , $,这当然是显然的.</p>
<p>回看$( ^t ) _V <span class="math inline">\(,它做到的是将一组\)</span>
, <span class="math inline">\(映射到\)</span> _V ( ) , ( ) <span class="math inline">\(,可只需用\)</span> _V ( )
$的定义,上述两者当然是相同的.</p>
<p>再最后,我们终于回看基的选取,我们可以证明以下结论:设$V <span class="math inline">\(是有限维的向量空间,\)</span> _1 , , _n V <span class="math inline">\(是一组有序基,其对偶基记作\)</span> _1 , , _n <span class="math inline">\(.我们声称:\)</span>V ^<span class="math inline">\(中的一组元素\)</span> _V ( _1 ) , , _V ( _n )
<span class="math inline">\(是\)</span> _1 , , _n <span class="math inline">\(的对偶基.也就是说中间不管怎么取对偶形态,最终总会回到一种典范的同构\)</span>V
V ^$上.</p>
<p>至于证明,无非只是:</p>
<p><span class="math display">\[
\langle \text { ev  } _V ( \vec { v  } _i ) , \check { v  } _j \rangle =
\langle \check { v  } _j , \vec { v  } _i \rangle
\]</span></p>
<p>立属显然.</p>
<h5><span id="核余核与对偶映射">核,余核与对偶映射</span></h5>
<p>上述证明揭露了对偶空间的一角.之所以$T ^t <span class="math inline">\(会显示出伴随性质,实际上并不是代数形式上的巧合,而恰是\)</span>T
^t <span class="math inline">\(的定义本身就是典范配对上的伴随,而自然会以某种形式显示在新的伴随中.既如此,请以下内容再观\)</span>T
: V W <span class="math inline">\(以及其转置\)</span>T ^t : W ^V
^$的性质.</p>
<p>首先,容易观察到的应该是$T <span class="math inline">\(单则\)</span>T
^t <span class="math inline">\(满,\)</span>T <span class="math inline">\(满则\)</span>T ^t <span class="math inline">\(单.此结论我们早就得出,策略是使用行秩等于列秩,而由同态基本定理得到\)</span>V
= T + T <span class="math inline">\(,如若\)</span>T <span class="math inline">\(单,则\)</span>T = 0 <span class="math inline">\(,意味着\)</span> T = V <span class="math inline">\(,也就意味着\)</span> T ^t = V ^<span class="math inline">\(,这就得到\)</span>T ^t $是满的.反之亦然同理.</p>
<p>然而回看$ T ^t = T
$这个结论的得出其实并不典范,我们推出此结论使用的策略是矩阵的相抵.而找到一种典范的证明此的策略便是重要的.而只需稍有对商操作的直觉就可以看到,要抛开矩阵,用一种真正典范的策略证明行秩等于列秩,必然离不开上述的引理.这就是我们下述真正想要做的事.</p>
<p>现在,设$T <span class="math inline">\(是单射,对于任给的\)</span>V
^<span class="math inline">\(,尝试找到一个\)</span> W ^<span class="math inline">\(使得\)</span> ( T ( x ) ) = ( x ) <span class="math inline">\(,那根据对偶映射的定义,知道这里有\)</span>T ^t ( )
= <span class="math inline">\(.如果这里\)</span><span class="math inline">\(可以任选的话,换言之,对于任意的\)</span><span class="math inline">\(我们都能构造出一个\)</span> <span class="math inline">\(来实现上述过程,当然意味着\)</span>T ^t
$是满射.可既然这里是构造,我们终于可以放下”典范”的包袱,开始取基.</p>
<p>取$V <span class="math inline">\(的一组基\)</span> <span class="math inline">\(,而\)</span>T ( ) <span class="math inline">\(当然是\)</span>W <span class="math inline">\(的线性无关子集,可以扩展为一组基\)</span> <span class="math inline">\(,这样\)</span> W <span class="math inline">\(都有唯一的展开\)</span>_{ } c _y <span class="math inline">\(,对于给定的\)</span>V ^<span class="math inline">\(可以定义\)</span> : W F $为:</p>
<p><span class="math display">\[
\tilde { \mu  } ( \sum _{ y \in \mathcal { Y  }  } c _y \vec { y  } ) =
\mu ( \sum _{ x \in \mathcal { X  }  } c _{ T ( \vec { x  } ) \vec {
x  }  } )
\]</span></p>
<p>而当$T <span class="math inline">\(满的时候,设\)</span> W ^<span class="math inline">\(,此时如果\)</span>T ^t ( ) = T = 0 <span class="math inline">\(,因为\)</span>T <span class="math inline">\(是满的,这必然意味着\)</span> = 0 <span class="math inline">\(,所以\)</span>T ^t $当然是单的.</p>
<p>换句话说,这里通过空间上的结构,用基强行凑出了一个$T
$的结构.然而取基总是会让我们忽略空间的结构,并给人一种使用文字游戏偷懒的感觉.或者说,构造性证明必然会有一种失掉典范性的感觉.</p>
<p>现在我们重新展现一下上述取出$ <span class="math inline">\(的合理性:设\)</span>T : V W <span class="math inline">\(为线性映射,而\)</span>V ^<span class="math inline">\(,我们声称存在\)</span> W ^<span class="math inline">\(使得\)</span>T ^t ( ) = <span class="math inline">\(当且仅当\)</span>| _{ T } = 0 $.</p>
<p>先证明充分性,当$| _{ T } = 0 <span class="math inline">\(的时候,不妨设\)</span><span class="math inline">\(是满射而\)</span>$是单射,如下交换图表当然成立:</p>
<p><span class="math display">\[
\xymatrix { V \ar @{-&gt;&gt;} [r ] ^T \ar [d ] _\mu \ar @{-&gt;&gt;}
[dr ] ^\pi &amp; \text { im  } \ ( T ) \\
F &amp; V / \ker ( T ) \ar [l ] ^{ \bar { \mu  }  } \ar @{^{(}-&gt;&gt;}
[u ] _{ \bar { T  }  }  }
\]</span></p>
<p>左下三角形的成立性完全依赖于$| _{ T } = 0 <span class="math inline">\(的性质,而此时取一个\)</span> = { } ( { T } ) ^{ -
1 } (  T ) ^{ } <span class="math inline">\(,而由于\)</span> T <span class="math inline">\(自然嵌入\)</span>W <span class="math inline">\(中,必有\)</span> ( T ) W <span class="math inline">\(,那也就意味着\)</span>W ^ ( T ) ^<span class="math inline">\(,因此\)</span> <span class="math inline">\(就可以延拓为\)</span> W ^$,交换图表给出:</p>
<p><span class="math display">\[
\tilde { \mu  } T = \tilde { \mu _0  } T = \bar { \mu  } ( \bar { T  } )
^{ - 1  } T = \bar { m  } u \circ \pi = \mu
\]</span></p>
<p>这就证明了充分性.至于必要性,由于$T ^t ( ) = T <span class="math inline">\(,而\)</span> T | _{ T } = 0 $当然是显然的.</p>
<p>接下来回忆到余核$ ( T ) = W / ( T ) <span class="math inline">\(这个东西,尝试看看它和\)</span>T <span class="math inline">\(之间的关系,回忆到我们应该有包含映射\)</span>i : (
T ) V <span class="math inline">\(和商映射\)</span>q : W ( T )
$,取对偶见到:</p>
<p><span class="math display">\[
\xymatrix { \text { coker  } ( T ) ^\vee \ar @{^{(}-&gt;} [r ] ^{ q
^t  } &amp; W ^\vee \ar [r ] ^{ T ^t  } &amp; V ^\vee \ar @{-&gt;&gt;}
[r ] ^{ i ^t  } &amp; \ker ( T ) ^\vee \\
\lambda \ar @{|-&gt;} [r ] &amp; \lambda q &amp; &amp; \\
&amp; \tilde { \mu  } \ar @{|-&gt;} [r ] &amp; \tilde { \mu  } T &amp;
\\
&amp; &amp; \mu \ar @{|-&gt;} [r ] &amp; \mu i  }
\]</span></p>
<p>这个当然没有问题,而我们试图借上面为辅助证明下面这张交换图表:</p>
<p><span class="math display">\[
\xymatrix { \text { coker  } ( T ) ^\vee \ar @{^{(}-&gt;} [r ] ^{ q
^t  } \ar @{^{(}-&gt;&gt;} [d ] &amp; W ^\vee \ar [r ] ^{ T ^t  } &amp;
V ^\vee \ar @{-&gt;&gt;} [r ] ^{ i ^t  } \ar @{-&gt;&gt;} [rd ] &amp;
\ker ( T ) ^\vee \\
\ker ( T ^t ) \ar @{^{(}-&gt;} [ur ] &amp; &amp; &amp; \text { coker  }
( T ^t ) \ar @{^{(}-&gt;&gt;} [u ]  }
\]</span></p>
<p>其中竖直方向的同构由左右两部分交换图表各自唯一确定.</p>
<p>先看左部分,我们尝试证明$ ( T ) ^W ^<span class="math inline">\(的像正好是\)</span>( T ^t ) $.</p>
<p>先证明$q ^t ( ( T ) ^) ( T ^t ) <span class="math inline">\(,考虑\)</span> ( T ) ^<span class="math inline">\(,那\)</span>q ^t <span class="math inline">\(会将其射到\)</span>q W ^<span class="math inline">\(.留意到\)</span>T ^t ( q ) = q T <span class="math inline">\(,然而根据\)</span> <span class="math inline">\(的定义知道\)</span>qT = 0 <span class="math inline">\(,这必然意味着\)</span>T ^t ( q ) = 0 $.</p>
<p>再证明$( T ^t ) q ^t ( ( T ) ^) <span class="math inline">\(,设\)</span> <span class="math inline">\(,也就是说\)</span>T ^t ( ) = T = 0 <span class="math inline">\(,我们要找到一个\)</span><span class="math inline">\(使得\)</span>q ^t ( ) = q = <span class="math inline">\(,那么必然见到\)</span>: + ( T ) ( ) <span class="math inline">\(是满足条件的,只需验证\)</span> | _{ ( T ) } = 0
<span class="math inline">\(,这恰好由\)</span>T ^t ( ) = T = 0
$给出.</p>
<p>至于右半部分,就是我们上面所刻画的$ <span class="math inline">\(和\)</span><span class="math inline">\(的关系了,换言之\)</span>i = 0 , = T $.</p>
<p>上述过程当然太过复杂了,尝试感性理解一下我们刚刚在做什么.我们的$T
<span class="math inline">\(的意义是,\)</span>T : V W <span class="math inline">\(这个过程中所损失的信息对吧,那我们反观\)</span>T ^t
: W ^V ^, T <span class="math inline">\(这个过程中所损失的,也就是何时,\)</span>T = 0 <span class="math inline">\(.由于这是两个映射,当然就等价于\)</span> V <span class="math inline">\(,\)</span>T = 0 <span class="math inline">\(.当然就等价于\)</span> ( T ) <span class="math inline">\(,\)</span> = 0 <span class="math inline">\(,这必然等价于\)</span> ( T ) <span class="math inline">\(.所以这些\)</span><span class="math inline">\(都可以表示为一个\)</span> q <span class="math inline">\(的形式,其中\)</span>q = ( T )
$,取余核是刚刚好的.</p>
<h5><span id="像自对偶">像自对偶</span></h5>
<p>对于映射$T : V W $,我们下面将给出典范同构:</p>
<p><span class="math display">\[
\text { im  } ( T ) ^\vee \cong \text { im  } ( T ^t )
\]</span></p>
<p>如上,商映射$q : W ( T ) <span class="math inline">\(满足\)</span>q =
( T ) $,于是:</p>
<p><span class="math display">\[
\begin{aligned}
\text { im  } ( T ) ^\vee \cong \text { coker  } ( q ^t : \text {
coker  } ( T ) ^\vee \to W ^\vee ) \\
\cong \text { coker  } ( \ker T ^t \hookrightarrow W ^\vee ) \\
&amp; = W ^\vee / \ker ( T ^t ) \\
\cong \text { im  } ( T ^t )
\end{aligned}
\]</span></p>
<p>两边取$$,得知行秩等于列秩.</p>
<h3><span id="实内积空间">实内积空间</span></h3>
<p>考虑正定对称双线性形式$( _ _ ) : V V F <span class="math inline">\(,这样的资料\)</span>( V , ( _ _ ) ) <span class="math inline">\(称为**内积空间(IPS)**.为了要一些\)</span> <span class="math inline">\(上的完备性质,我们下面主要讨论\)</span>F =
$的特殊情况.回忆道此时它应当满足的条件:</p>
<ol type="1">
<li><p>双线性:各位有分配律以及标量乘法.</p></li>
<li><p>对称性:$( ) = ( ) $.</p></li>
<li><p>正定性:$( ) <span class="math inline">\(,并且等号成立当且仅当\)</span> = $.</p></li>
</ol>
<p>回忆道二次型理论的时候我们曾经说过正定性是强于非退化的,因此内积一定是非退化的.</p>
<p>接下来定义$ V <span class="math inline">\(的**长度**为\)</span> =
<span class="math inline">\(,并且如果\)</span>( ) = 0 <span class="math inline">\(,则称它们**正交**,也写作\)</span> <span class="math inline">\(.同理可以定义正交空间\)</span>V _0 ^<span class="math inline">\(.还将满足\)</span> = 1 <span class="math inline">\(的\)</span> $称为<strong>单位向量</strong>.</p>
<h4><span id="勾股定理">勾股定理</span></h4>
<p>事实上可以写出所谓的<strong>配极化</strong>:$( _1 _2 ) = { 2 } ( _1 +
_2 ^2 - _1 ^2 - _2 ^2 ) $.</p>
<p>这里可以看出内积上的勾股定理:也就是当$ <span class="math inline">\(时\)</span> + ^2 = ^2 + ^2 $.</p>
<h4><span id="柯西不等式">柯西不等式</span></h4>
<p>即$( ) ^2 ( ) ( ) <span class="math inline">\(,或言\)</span>( )
$.</p>
<p>等式成立当且仅当$ , <span class="math inline">\(线性相关,此时也是容易证明的,只需要讨论\)</span> =
t $以及反过来的情况即可.</p>
<p>当$ , <span class="math inline">\(线性无关时,那么\)</span> , <span class="math inline">\(,于是\)</span>t , + t $.这会导致:</p>
<p><span class="math display">\[
0 &lt; ( \vec { v  } + t \vec { w  } \mid \vec { v  } + t \vec { w  } )
= t ^2 ( \vec { w  } \mid \vec { w  } ) + 2 t ( \vec { v  } \mid \vec {
w  } ) + ( \vec { v  } \mid \vec { v  } )
\]</span></p>
<p>将此看作关于$t <span class="math inline">\(的二次多项式,那它就没有实根,于是观察判别式\)</span>=
4 ( ) ^2 - 4 ( ) ( ) &lt; 0 $就见到柯西不等式成立.</p>
<p>用柯西不等式还可以定义两个向量之间的夹角,设其为$( , ) <span class="math inline">\(,并定义\)</span>( , ) = { } $.</p>
<p>值得一提的是,柯西准则实际上保证了如果空间本身是连续的,那么内积就一定是连续的,原因是假设一列$(
_n , _n ) ( , ) $,无论以何种方式逼近,一定有:</p>
<p><span class="math display">\[
\begin{aligned}
| ( \vec { x  } _n \mid \vec { y  } _n ) - ( \vec { x  } \mid \vec {
y  } ) | \\
&amp; \leq | ( \vec { x  } _n - \vec { x  } \mid \vec { y  } _n ) | + |
( \vec { x  } \mid \vec { y  } _n - \vec { y  } ) | \\
&amp; \leq \Vert \vec { x  } - \vec { x  } _n \Vert \cdot \Vert \vec {
y  } _n \Vert + \Vert \vec { x  } \Vert \cdot \Vert \vec { y  } _n -
\vec { y  } \Vert
\end{aligned}
\]</span></p>
<p>这样就可以将其控制住.</p>
<h4><span id="三角不等式">三角不等式</span></h4>
<p>先用配极化,再用柯西不等式得到:</p>
$$
<span class="math display">\[\begin{aligned}
\Vert \vec { v  } _1 + \vec { v  } _2 \Vert ^2 &amp; = \Vert \vec { v  }
_1 \Vert ^2 + \Vert \vec { v  } _2 \Vert ^2 + 2 ( \vec { v  } _1 \mid
\vec { v  } _2 ) \\
&amp; \leq \Vert \vec { v  } _1 \Vert ^2 + \Vert \vec { v  } _2 \Vert ^2
+ 2 | ( \vec { v  } _1 \mid \vec { v  } _2 ) | \\
&amp; \leq \Vert \vec { v  } _1 \Vert ^2 + \Vert \vec { v  } _2 \Vert ^2
+ 2 \Vert \vec { v  } _1 \Vert \cdot \Vert \vec { v  } _2 \Vert \\
&amp; = ( \Vert \vec { v  } _1 \Vert + \Vert \vec { v  } _2 \Vert ) ^2
\\

\end{aligned}\]</span>
<p>$$</p>
<h4><span id="距离相关">距离相关</span></h4>
<p>如上可以定义<strong>距离函数</strong>$d : V V _{ } , ( , ) - <span class="math inline">\(.容易见到其满足三角不等式\)</span>d ( , ) + d ( ,
) d ( , ) $.</p>
<h4><span id="正交向量族">正交向量族</span></h4>
<p>选取$V <span class="math inline">\(中的一组两两正交的非零元素,称其为**正交向量族**或者**正交子集**.特别地如果所有向量都是单位向量,则称其为**单位正交向量族**或者**单位正交子集**.容易见到正交向量族应该是线性无关的,原因是反证,如果\)</span>a
_k _k = 0 <span class="math inline">\(,两边对\)</span> _k <span class="math inline">\(做内积就可以得到\)</span>a _k _k ^2 = 0 <span class="math inline">\(,根据正定性得到\)</span>a _k = 0 $.</p>
<p>既然如此,我们就将由一个单位正交子集所给出的基称为<strong>单位正交基(ONB)</strong>.</p>
<p>如果我们能拿出一组$n <span class="math inline">\(个元素的单位正交基\)</span> _1 , _n <span class="math inline">\(,那么考虑用这组有序基将\)</span>V ^n <span class="math inline">\(.则注意到\)</span> V <span class="math inline">\(,应当有:\)</span> = _k a _k _k <span class="math inline">\(.并且两边对\)</span> _k <span class="math inline">\(取内积就可以见到\)</span>a _k = ( _k ) <span class="math inline">\(.我们可以证明在这组基的同构下原本的内积就同构于\)</span>
^n
$上的标准内积(点乘).因此需要验证这个映射是否是保距的,事实上注意到:</p>
<p><span class="math display">\[
\begin{aligned}
( \sum _i a _i \vec { v  } _i \mid \sum _j b _j \vec { v  } _j ) \\
&amp; = \sum _{ i , j  } a _i b _j ( \vec { v  } _i \mid \vec { v  } _j
) \\
&amp; = \sum _i a _i b _i
\end{aligned}
\]</span></p>
<h4><span id="gram-schmidt-正交化">Gram-Schmidt 正交化</span></h4>
<p>问题现在在于单位正交基是否总是存在以及如何找到一个.我们先取一组向量$
_1 , _2 , $线性无关(这里甚至允许可数无穷个向量),递归定义:</p>
<p><span class="math display">\[
\begin{aligned}
\vec { w  } _1 &amp; = \vec { v  } _1 \\
\vec { w  } _k &amp; = \vec { v  } _k - \sum _{ i = 1  } ^{ k - 1  }
\frac { ( \vec { w  } _i \mid \vec { v  } _k )  } { ( \vec { w  } _i
\mid \vec { w  } _i )  } \vec { w  } _i
\end{aligned}
\]</span></p>
<p>就可以取出一组正交基,之后只需令$ _k = { _k } <span class="math inline">\(就可以转化为一组单位正交基.事实上还可以注意到\)</span>
_1 , _k = _1 , , _k
$.其构造思路是每次添加一个拥有两项的元素,一项要是前面的空间内的部分,另一部分不是,然而它们之和要与前面空间正交.</p>
<p>证明的话,注意到:$ _k _k + <em>1 , , </em>{ k - 1 } <span class="math inline">\(,因此数学归纳证明\)</span> _1 , _k = _1 , , _k
$:</p>
<p><span class="math display">\[
\begin{aligned}
\langle \vec { w  } _1 , \cdots , \vec { w  } _k \rangle \\
&amp; = \langle \vec { w  } _1 , \cdots , \vec { w  } _{ k - 1  }
\rangle + \langle \vec { w  } _k \rangle \\
&amp; = \langle \vec { v  } _1 , \cdots , \vec { v  } _{ k - 1  }
\rangle + \langle \vec { v  } _k \rangle \\
&amp; = \langle \vec { v  } _1 , \cdots , \vec { v  } _k \rangle
\end{aligned}
\]</span></p>
<p>此外上述的算法的优点在于如果$ _k <span class="math inline">\(已经和前面的\)</span> <em>1 , , </em>{ k - 1 }
<span class="math inline">\(正交,自然有\)</span> _k = _k $.</p>
<p>而验证正交无非是两边同时对$ _j $做内积并继续归纳即可.</p>
<p>由上给出两个推论:</p>
<ol type="1">
<li><p>任何有限维内积空间都有单位正交基.</p></li>
<li><p>任何单位正交子集都可以扩充为一个单位正交基.</p></li>
</ol>
<p>(1)找到一组基用上述算法即可,(2)的话可以先扩充成基,再按照上述算法,而前面原本已经正交的部分不会改变.</p>
<h6><span id="example1ru分解">Example1(RU分解)</span></h6>
<p>观察上述Gram-Schmidt正交化过程就可以看到,对于一个矩阵$A = ( _1 , , _n
) <span class="math inline">\(,对其作正交化,每次相当于右乘(列变换)一个上三角矩阵(没有交换列的操作),最终变换的形态则会是一个正交矩阵.因此,任何一个可逆矩阵都可以被分解成\)</span>RU
<span class="math inline">\(,其中\)</span>R <span class="math inline">\(是一个正交矩阵,\)</span>U $是一个上三角矩阵.</p>
<h6><span id="example2legendre多项式">Example2(Legendre多项式)</span></h6>
<p>考虑$ <span class="math inline">\(上的多项式组成的\)</span> - <span class="math inline">\(向量空间\)</span> [ x ] <span class="math inline">\(,定义内积\)</span>( f g ) = _{ - 1 } ^1 f ( x ) g
( x ) x <span class="math inline">\(,容易见到其满足定义.此外,\)</span> [
x ] <span class="math inline">\(的一组自然的基是\)</span> , x , x ^2
$.</p>
<p>是否可以对其进行正交化呢?考虑限制得到的单位正交基的最高次系数均为$1
$,容易见到这组单位正交基如此便被唯一刻画,并且必然是上述做Gram-Schmidt正交化的产物.</p>
<p>既然如此,我们接下来尝试检验$P _0 = 1 , P _n = { 2 ^n n ! } ( ( x ^2 -
1 ) ^n ) ^{ ( n ) } $就是一组正交基.我们声称以下命题成立:</p>
<ol type="1">
<li><p>$[ x ^n ] P _n = { 2 ^n ( n ! ) ^2 } $.</p></li>
<li><p>$P _n ( 1 ) = 1 $.</p></li>
<li><p>当$0 k &lt; n <span class="math inline">\(时,\)</span>_{ - 1 } ^1
t ^k P <em>n ( t ) t = 0 <span class="math inline">\(.作为此的一个推论,\)</span>n m <span class="math inline">\(的时候\)</span></em>{ - 1 } ^1 P _m ( t ) P _n ( t
) t = 0 $.</p></li>
<li><p>$P _n ( - t ) = ( - 1 ) ^n P _n ( t ) $.</p></li>
<li><p>$_{ - 1 } ^1 P _n ( t ) ^2 t = { 2 n + 1 } $.</p></li>
<li><p>递归式:$( n + 1 ) P _{ n + 1 } = ( 2 n + 1 ) x ( P <em>n ) - nP
</em>{ n - 1 } $.</p></li>
</ol>
<p>对于(1),讨巧的策略是直接看$_{ x } { x ^n } <span class="math inline">\(,而于此使用洛必达法则上下求导\)</span>n
$次,立刻证毕.</p>
<p>对于(2),考虑$( x ^2 - 1 ) = ( x - 1 ) ( x + 1 ) <span class="math inline">\(,用Leibniz律求导,得到\)</span>P _n ( 1 ) = { 2 ^n
n ! } n ! ( 1 + 1 ) ^n = 1 $.</p>
对于(3),只需分部积分,每次将$P _n ( t ) <span class="math inline">\(给扔到\)</span>
<span class="math display">\[\begin{bmatrix}\lambda _1 &amp; &amp; \\
&amp; \ddots &amp; \\ &amp; &amp; \lambda _n \end{bmatrix}\]</span>
<p>$.</p>
<p>或者直接来看,我们断言自伴算子对应的特征子空间一定互相正交,原因是设它们分别是$V
_{ <em>1 } , V </em>{ _2 } <span class="math inline">\(,那么\)</span>_1
( _1 _2 ) = ( T _1 _2 ) = ( _1 T _2 ) = _2 ( _1 _2 ) <span class="math inline">\(.这就必然给出\)</span>( _1 _2 ) = 0
$.那只需先求特征向量,然后对此施加Gram-Schmidt正交化就赢了.</p>
<h5><span id="实sylvester-判准">(实)Sylvester 判准</span></h5>
<p>将一个矩阵的左上的$k k <span class="math inline">\(的矩阵称为\)</span>A $的顺序主子式.</p>
<p>容易发现,实对称矩阵正定当且仅当其所有特征值皆正,原因是正交对角化后的结果.</p>
<p>由此可以得到Sylvester判准,也就是一个实对称矩阵正定当且仅当其所有顺序主子式皆正.</p>
<p>必要性显然,把线性空间限制在左上角的那个$k k
$里,如果有某个顺序主子式是负的,那就存在负的特征值.</p>
<p>下面证明充分性:考虑数学归纳,当$n <span class="math inline">\(的时候,假设\)</span>A <span class="math inline">\(的每个顺序主子式都是正的,我们下面试图证明其所有特征值都是正的.记其特征值为\)</span>_1
, , _n <span class="math inline">\(,必定有等式\)</span>_1 _n = A &gt; 0
<span class="math inline">\(.也就是说,如果\)</span>A <span class="math inline">\(有负特征值则必然成对出现,不妨设其为\)</span>_1
<span class="math inline">\(和\)</span>_2 <span class="math inline">\((当然它们有可能相等,但总之应该取不同的特征向量),此时不妨取它们的特征向量并做单位正交化后得到\)</span>
_1 , _2 <span class="math inline">\(.此时\)</span>, $,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
( \alpha \vec { v  } _1 + \beta \vec { v  } _2 ) ^t A ( \alpha \vec {
v  } _1 + \beta \vec { v  } _2 ) \\
&amp; = \alpha ^2 \lambda _1 + \beta ^2 \lambda _2 &amp; \leq 0
\end{aligned}
\]</span></p>
<p>其中$, $可以任取,当然存在不全为$0 <span class="math inline">\(的一对\)</span>( , ) <span class="math inline">\(使得\)</span> _1 + _2 <span class="math inline">\(作为列向量的第\)</span>n $个坐标为$0 <span class="math inline">\(,此时对于左上角的\)</span>( n - 1 ) ( n - 1 )
$的空间来说,由于进行了数学归纳,上面必然是正定的.这当然就矛盾了.</p>
<h5><span id="实正定矩阵的二次根">(实)正定矩阵的二次根</span></h5>
<p>设$T ( V ) <span class="math inline">\(正定(或者半正定),那么就存在唯一的正定(或半正定)的\)</span>S
( V ) <span class="math inline">\(使得\)</span>S ^2 = T <span class="math inline">\(,这样我们记\)</span>S = $.</p>
<p>(一定要记得正定蕴含着其对称啊,总是忘记这个定义)</p>
<p>存在性的话只需要对$T <span class="math inline">\(做单位正交分解,然后把对角线上的特征值全部取根号就可以了.唯一性的话,由于\)</span>S
<span class="math inline">\(在每一个特征子空间上都应当表现为\)</span>
<span class="math inline">\((原因是每一个特征子空间本身都是不变子空间,因此\)</span>S
<span class="math inline">\(的特征子空间也需要是\)</span>S ^2 = T <span class="math inline">\(的特征子空间,于是反之亦然),那\)</span>S
$当然是唯一确定的.</p>
<h6><span id="example1">Example1</span></h6>
<p>设$A , B , A - B <span class="math inline">\(都是正定矩阵,求证\)</span> - $正定.</p>
<p>反证,假设$ - <span class="math inline">\(并非正定,那就一定存在一个特征值\)</span> <span class="math inline">\(以及配套的特征向量\)</span> <span class="math inline">\(,使得\)</span>( - ) = <span class="math inline">\(,也就是\)</span> = - $.此时见到:</p>
<p><span class="math display">\[
\begin{aligned}
( \vec { v  } ) ^t B \vec { v  } \\
&amp; = ( \sqrt { B  } \vec { v  } ) ^t ( \sqrt { B  } \vec { v  } ) \\
&amp; = ( \sqrt { A  } \vec { v  } - \lambda \vec { v  } ) ^t ( \sqrt {
A  } \vec { v  } - \lambda \vec { v  } ) \\
&amp; = ( \vec { v  } ) ^t A \vec { v  } + \lambda ^2 \vec { v  } ^t
\vec { v  } - 2 \lambda ( \vec { v  } ) ^t \sqrt { A  } \vec { v  } \\
&amp; \geq ( \vec { v  } ) ^t A \vec { v  }
\end{aligned}
\]</span></p>
<p>这就与$A - B $正定是矛盾的了.</p>
<h6><span id="example2">Example2</span></h6>
<p>设$A , B , A - B <span class="math inline">\(都是正定矩阵,求证\)</span>A ^{ - 1 } - B ^{ - 1 }
$正定.</p>
<p>直接扩到复数域,这样一定存在一个$C <span class="math inline">\(,使得\)</span>( C ^* ) BC = I <span class="math inline">\(,此时由于合同是内积空间上的同构,所以\)</span>( C
^* ) ( A - B ) C = C ^* AC - I <span class="math inline">\(仍然正定,这就将情况化约到\)</span>B = I
$的情况.</p>
<p>此时只需对$A $做对角化即可见得了.</p>
<h5><span id="极分解">极分解</span></h5>
<p>对于内积空间,设$T ( V ) <span class="math inline">\(可逆,那么就存在唯一一对\)</span>R , U ( V ) <span class="math inline">\(使得\)</span>R <span class="math inline">\(正定并且\)</span>U <span class="math inline">\(是正交变换,\)</span>T = RU
$.这其实类似于把一个复数拆成模长和辅角两个部分.</p>
<p>在此之前先证明一个引理:标准内积空间上$T ^* T <span class="math inline">\(是半正定的,并且如果\)</span>T
$单,那么其是正定的.</p>
<p>首先其自伴性质是已知的,半正定的原因是$^t ( ) ( T ^* T ) ( ) = ( T T )
<span class="math inline">\(,而后者继承了内积空间上的半正定性.并且从此可以看出\)</span>T
<span class="math inline">\(单的话,也就是\)</span>T = { 0 }
$就可以继承内积空间上的正定性.</p>
<p>注意到$TT ^* = RUU ^* R = R ^2 <span class="math inline">\(,因此必定有\)</span>R = <span class="math inline">\(,因此\)</span>R <span class="math inline">\(是唯一且存在的且正定的(原因是\)</span>T <span class="math inline">\(是可逆的,因此\)</span>TT ^* <span class="math inline">\(是正定的)而且\)</span>R <span class="math inline">\(还自伴.另外,因为\)</span>R <span class="math inline">\(可逆(正定性推出非退化性),因此\)</span>U = R ^{ - 1
} T <span class="math inline">\(就确定.问题在于证明\)</span>U <span class="math inline">\(是否是正交变换,只需要证明\)</span>U ^* = U ^{ - 1
} $,而:</p>
<p><span class="math display">\[
\begin{aligned}
U ^* U &amp; = ( R ^{ - 1  } T ) ^* ( R ^{ - 1  } T ) \\
&amp; = T ^* R ^{ - 2  } T &amp; = \text { id  }
\end{aligned}
\]</span></p>
<p>这就得证.</p>
<h5><span id="最小二乘法">最小二乘法</span></h5>
<p>给定一个特定的$T ( V , W ) <span class="math inline">\(,现在对于一个\)</span> W <span class="math inline">\(,想要求一个\)</span> V <span class="math inline">\(使得\)</span>T -
$最小.这个解被称为<strong>最小二乘解</strong>.</p>
<p>取$W _0 = T <span class="math inline">\(,那么就可以将\)</span> = _0 +
_1 <span class="math inline">\(,其中\)</span> _0 W _0 , _1 ( W _0 )
^$.此时就可以见到:</p>
<p><span class="math display">\[
\begin{aligned}
\Vert T \vec { v  } - \vec { w  } \Vert ^2 &amp; = \Vert ( T \vec { v  }
- \vec { w  } _0 ) - \vec { w  } _1 \Vert ^2 \\
&amp; = \Vert T \vec { v  } - \vec { w  } _0 \Vert ^2 + \Vert \vec {
w  } _1 \Vert ^2
\end{aligned}
\]</span></p>
<p>只需让前面为$0 <span class="math inline">\(就行,从这也可以看出来一般而言\)</span> <span class="math inline">\(不是唯一的.然而\)</span> + T <span class="math inline">\(总是唯一的,我们试图在其中找到\)</span> <span class="math inline">\(最小的一个作为代表.而\)</span> <span class="math inline">\(仍可以分解为\)</span>T <span class="math inline">\(和\)</span>( T ) ^<span class="math inline">\(两部分,这就能见到\)</span> <span class="math inline">\(最小时\)</span> ( T ) ^<span class="math inline">\(.不妨将这个\)</span> <span class="math inline">\(定义为\)</span>S ( ) = <span class="math inline">\(,应该见到\)</span>S $是一个线性映射.</p>
<p>我们还可以证明,其最小二乘解正好是$T ^* T = T ^* <span class="math inline">\(的解.原因是最小二乘解其实也就是\)</span>T - ( T )
^= ( T ^* ) $.</p>
<p>而注意到$T ^* T $是自伴的,然而其还有更多的好性质:</p>
<ol type="1">
<li><p>$  ( T ^* T ) =  ( T ^* ) $.</p></li>
<li><p>$( T ^* T ) = T $.</p></li>
<li><p>$  ( T ^* T ) =  ( T ) = ( T ^* ) $.</p></li>
</ol>
<p>考虑(1), 首先显然有$  ( T ^* T )  ( T ^* ) <span class="math inline">\(.而反方向的话,对于\)</span>T ^* ( T ^* ) <span class="math inline">\(,只需取其最小二乘解\)</span> V <span class="math inline">\(就给出了\)</span>T ^* = T ^* T ( T ^* T ) $.</p>
<p>考虑(2),首先显然有$ ( T ^* T )  ( T ) <span class="math inline">\(.而反方向的话,若\)</span>T ^* T = 0 <span class="math inline">\(,应该能看到\)</span>( T T ) = ( T ^* T ) = 0 <span class="math inline">\(,这意味着\)</span>T = 0 $.</p>
<p>(3)是(1)(2)的推论.顺便一提,这里推出的$ ( T ) = ( T ^* )
$是行秩等于列秩的另一个证明.</p>
<h4><span id="奇异值分解">奇异值分解</span></h4>
取$V , W <span class="math inline">\(为有限维实内积空间并采取标准内积,不妨设\)</span>m
= V , n = W <span class="math inline">\(,注意这里的字母使用与习惯略有差别.并取\)</span>T :
V W <span class="math inline">\(为线性映射.接下来我们证明,存在\)</span>V
, W <span class="math inline">\(的两组单位正交基,不妨记作\)</span> _V =
{ _1 , , _m } <span class="math inline">\(和\)</span> _W = { _1 , , _n }
<span class="math inline">\(.记\)</span>p = T <span class="math inline">\(,以及存在一列非负实数\)</span>_1 _p <span class="math inline">\(,使得\)</span>T _i =
<span class="math display">\[\begin{cases}\sigma _i \vec { w  } _i &amp;
1 \leq i \leq p \\ 0 &amp; i &gt; p \end{cases}\]</span>
<p><span class="math inline">\(.我们称这列非负实数为\)</span>T <span class="math inline">\(的**奇异值**,并将在下面证明其由\)</span>T
$唯一确定.应当说明的是,下述中虽然有的时候会默认后面有一列$0 <span class="math inline">\(来避开讨论,但\)</span>_p <span class="math inline">\(.一般,我们也用非零奇异值的数量来判断\)</span>T
$的秩.可以认为,奇异值是特征值的某种推广.</p>
<p>考虑矩阵,此时的$T <span class="math inline">\(应当是一个\)</span>n m
<span class="math inline">\(的矩阵.考虑\)</span>V <span class="math inline">\(的单位正交基组成的矩阵\)</span>P M <em>{ m m }
<span class="math inline">\(,以及\)</span>W <span class="math inline">\(的单位正交基矩阵\)</span>Q M </em>{ n n } $.</p>
<p>此时不妨考虑$T <span class="math inline">\(在标准基下表示为\)</span>A
<span class="math inline">\(,那考虑\)</span>Q ^{ - 1 } AP <span class="math inline">\(实际上就是在两个单位正交基内转化的过程.不妨令\)</span>=
Q ^{ - 1 } AP <span class="math inline">\(,只需证明其在前\)</span>p
<span class="math inline">\(个主对角线位置分别为\)</span>_1 , , _p
$即可.</p>
<p>留意到$( _i T ^* _j ) = ( T _i _j ) = _i ( _i <em>j ) = <em>i </em>{
i , j } <span class="math inline">\(,其中\)</span></em>{ i , j } = [ i =
j ] <span class="math inline">\(.回忆到\)</span>T ^* <span class="math inline">\(是唯一的,并注意到如果干脆定义\)</span>T ^* <span class="math inline">\(满足\)</span>T ^* _j = _j _j <span class="math inline">\(上式依旧成立,因此\)</span>T ^* <span class="math inline">\(的确有此性质.进一步得到推论\)</span>T ^* T _i = _i
^2 _i <span class="math inline">\(.所以\)</span>T ^* T <span class="math inline">\(的特征值恰为\)</span>_1 ^2 <span class="math inline">\(.这样的话其唯一性立刻见到了.不过由于是在\)</span>
<span class="math inline">\(上,因此我们还要说明其存在性.考虑对\)</span>T
^* T <span class="math inline">\(做正交对角化.此时回忆到\)</span> ( T ^*
T ) = ( T ) = p <span class="math inline">\(,又因为\)</span>T ^* T <span class="math inline">\(可对角化,\)</span> <span class="math inline">\(对应了非零特征值的数量.直接取\)</span>_i = <span class="math inline">\(,其中\)</span>_i <span class="math inline">\(是\)</span>T ^* T $的特征值,当然都是可行的.</p>
<p>接下来要反推出$V , W <span class="math inline">\(的两组单位正交基.任取一组\)</span>V <span class="math inline">\(的特征向量组成的基并从其构造\)</span>W <span class="math inline">\(的基,也就是取\)</span> _i = { _i } <span class="math inline">\((假设\)</span>m n
$的情况下,不然的话反之)并证明这也是一组单位正交基.</p>
<p>此时观察到$( _i _j ) = { _i _j } ( T _i T _j ) = { _i _j } ( _i T ^*
T _j ) = { <em>i } </em>{ i , j } $,所以这当然也是一组单位正交基.</p>
<h4><span id="moore-penrose-广义逆">Moore-Penrose 广义逆</span></h4>
<p>取域$F <span class="math inline">\(上的有限维向量空间\)</span>V , W
<span class="math inline">\(以及线性映射\)</span>T : V W <span class="math inline">\(.其中\)</span>T <span class="math inline">\(未必可逆,但有的时候我们又需要\)</span>T
$的逆的性质,我们的目标是去找到一个弱一点的替代品.</p>
<p>我们声明一定存在一个$S : W V $,满足以下性质:</p>
<ol type="1">
<li><p>$TST = T $.</p></li>
<li><p>$STS = S $.</p></li>
<li><p>$TS = ( TS ) ^* $.</p></li>
<li><p>$ST = ( ST ) ^* $.</p></li>
</ol>
<p>容易见到,如果$T
$可逆,它的逆当然是一个MP广义逆.事实上我们可以证明满足上述条件的MP广义逆是唯一的.</p>
<p>先来证明其存在性,$ V <span class="math inline">\(,做分解\)</span> = ’
+ ’ ’ <span class="math inline">\(,其中\)</span> ’ T <span class="math inline">\(且\)</span> ’ ’ ( T ) ^<span class="math inline">\(.同样\)</span> W <span class="math inline">\(,做分解\)</span> = ’ + ’ ’ <span class="math inline">\(,其中\)</span> ’ T $.</p>
<p>接下来应当见到,任取$ <span class="math inline">\(使得\)</span>T =
<span class="math inline">\(,则\)</span>T ^{ - 1 } ( ’ ) = + T <span class="math inline">\(,而\)</span> + T <span class="math inline">\(中的每个元素做投影后得到的\)</span> ’ ’ <span class="math inline">\(都是相同的,于是我们定义\)</span>S = ’ ’ <span class="math inline">\(.容易验证\)</span>S <span class="math inline">\(是线性映射,而且应当见到\)</span>ST <span class="math inline">\(和\)</span>TS <span class="math inline">\(其实都是正交投影,具体而言,\)</span>ST : V ( T )
^<span class="math inline">\(而\)</span>TS : W T <span class="math inline">\(,也容易验证上述四条性质.也就是我们想法是,干脆考虑映射\)</span>V
/ T  T $必然是可逆的,直接在这个上面找逆而不顾其它.</p>
<p>接下来证明其唯一性,假设$T <span class="math inline">\(有两个MP广义逆\)</span>S , R $,我们注意到:</p>
<p><span class="math display">\[
\begin{aligned}
TS &amp; = ( TS ) ^* &amp; = S ^* T ^* &amp; = S ^* ( TRT ) ^* \\
&amp; = S ^* T ^* R ^* T ^* \\
&amp; = ( TS ) ^* ( TR ) ^* \\
&amp; = TSTR \\
&amp; = TR
\end{aligned}
\]</span></p>
<p>同理可证明$ST = RT <span class="math inline">\(,因此\)</span>S = STS
= STR = RTR = R $,这就给出了唯一性的证明.</p>
<p>那么如何求出一个MP广义逆呢?考虑对于一个线性映射$T : V W <span class="math inline">\(,将其视为标准基下的矩阵,做奇异值分解有\)</span>T =
Q P ^{ - 1 } $.</p>
<p>容易见到满足条件的MP逆$S <span class="math inline">\(应当满足\)</span>S _j = { _j } _j <span class="math inline">\(,而写作矩阵形式的话就是\)</span>P Q ^{ - 1 } <span class="math inline">\(,其中\)</span><span class="math inline">\(就是\)</span>$的非零对角线全部取倒数.验证此事实的策略,要么取检验MP广义逆的定义,要么取一组基并观察投影,但总之都是容易的.</p>
<p>如果想要进一步说明MP广义逆的合理性,不妨考虑设$C ( t ) = T ^* T + t
<em>V <span class="math inline">\(,我们证明MP广义逆实际上就是\)</span>S
= </em>{ t , C ( t ) } C ( t ) ^{ - 1 } T ^* <span class="math inline">\(,证明无非也只是使用奇异值分解,考虑\)</span>T = Q P
^{ - 1 } , T ^* = P Q ^{ - 1 } <span class="math inline">\(,那么\)</span>C ( t ) = P ( ^2 + tI ) P ^{ - 1 }
$,容易检验其满足性质.</p>
<h4><span id="极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</span></h4>
<p>对于实空间$V <span class="math inline">\(,考察其标准内积\)</span>( _
_ ) <span class="math inline">\(和任一对称双线性形式\)</span>B : V V
<span class="math inline">\(.当然存在唯一的\)</span>S ( V ) <span class="math inline">\(使得\)</span>B ( _1 , _2 ) = ( _1 S _2 ) <span class="math inline">\(恒成立,无非是把\)</span>B
$所代表的矩阵拿过来而已.</p>
<p>此时应有$S = S ^* <span class="math inline">\(,对其施加正交对角化拿到单位正交基\)</span> _1 , ,
_n <span class="math inline">\(和对应的一列特征值\)</span>_1 _n <span class="math inline">\(.对于单位球面上的向量\)</span> <span class="math inline">\(,其应当满足\)</span>| | = 1 <span class="math inline">\(,此时我们注意到\)</span><em>1 = </em>{ | | = 1 } B
( , ) , <em>n = </em>{ | | = 1 } B ( , ) <span class="math inline">\(.原因只是取\)</span> = a _k _k <span class="math inline">\(,然后\)</span>B ( , ) = _k a _k ^2 _k
$.上述当然成立.确定除此以外的其他特征值需要更精确地刻画,我们引入如下定理:</p>
$$
<span class="math display">\[\begin{aligned}
\lambda _k &amp; = \min _{ U \subseteq V , \dim U = n - k + 1  } \left (
\max _{ \vec { v  } \in U , | \vec { v  } | = 1  } B ( \vec { v  } ,
\vec { v  } ) \right ) \\
\lambda _k &amp; = \max _{ U \subseteq V , \dim U = k  } \left ( \min _{
\vec { v  } \in U , | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  }
) \right ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>将$S <span class="math inline">\(用\)</span>- S
$替换,则降序的特征值序列要翻转,立刻见到上述两条等价.下面只证明第一条.</p>
<p>取$W _k = _1 , , _k $.应当见到:</p>
<p><span class="math display">\[
\begin{aligned}
\dim U \cap W _k &amp; = \dim U + k - \dim ( U + W _k ) \\
&amp; \geq \dim U + k - n &amp; = 1
\end{aligned}
\]</span></p>
<p>这意味着这两个空间的交非零空间,取出一个交集元素$ = _{ i = 1 } ^k a _i
_i U <span class="math inline">\(且满足\)</span>| | = 1 <span class="math inline">\(.应当见到\)</span>B ( , ) = _k _k a _k ^2 <em>k
<span class="math inline">\(.这就意味着\)</span></em>{ U , | | = 1 } B (
, ) <em>k <span class="math inline">\(.或言之\)</span></em>{ U , | | = 1
} B ( , ) _k <span class="math inline">\(.证明下界可取到只需取\)</span>U
= _k , , _n <span class="math inline">\(即可取到(证明取到的策略呢,可以直接看基立刻得到,也可以采取更加严谨好说的方式即前后分别表示一下发现其既满足\)</span>_k
<span class="math inline">\(又要\)</span>_k $).</p>
<p>这个定理也可以用来求奇异值,半正定条件下,奇异值无非是特征值开根后的结果.</p>
<p>这个原理的重要意义是将奇异值,特征值这些东西全部挪到了空间本身的性质上(类似惯性定理).于是从此只要我们能拿到空间的同构当然就能断言奇异值,特征值全都同构,这是无可置疑的.</p>
<p>应当能看出这个定理更多有一种拓扑性质,事实上的确如此,如果能取最大值的话,这实际上对应了某种李氏连续性质.</p>
<h4><span id="perron-frobenius定理">Perron-Frobenius定理</span></h4>
<p>约定$A B <span class="math inline">\(表示对于每一个位置\)</span>a
<em>{ i , j } b </em>{ i , j } <span class="math inline">\(.于是约定\)</span>A <span class="math inline">\(意味着\)</span>A <span class="math inline">\(中的任意元素都\)</span> $.</p>
<p>容易见到以下平凡引理:</p>
<ol type="1">
<li><p>$A &gt; 0 , x , x Ax &gt; 0 $.</p></li>
<li><p>$A , x Ax $.</p></li>
</ol>
<p>定义实矩阵$A <span class="math inline">\(的**谱半径**为\)</span>( A )
= $,也就是所有复特征值模长的极大值.</p>
<p>虽然这里用到了复特征值,但意义仅是使得多项式可裂,而矩阵仍然是实数域的.因此仍然认为该定理是实内积空间里的定理.</p>
<h5><span id="collatz-wielandt公式">Collatz-Wielandt公式</span></h5>
<p>对于实矩阵$A &gt; 0 <span class="math inline">\(,我们考虑\)</span>S =
{ ^n | | = 1 , } <span class="math inline">\(,容易见到这是个紧集,考虑定义在其上的映射\)</span>L
: S , ( { x _i } , x _i ) <span class="math inline">\(.于是命\)</span>
<span class="math inline">\(为上述映射像中的极大值,我们下面证明两个事情:首先是这个\)</span><span class="math inline">\(是\)</span>A <span class="math inline">\(的一个特征值,其次是这个\)</span><span class="math inline">\(就是\)</span>A $的谱半径.</p>
<p>首先证明其是一个特征值,而且对应的特征向量大于零,也就是$ &gt; 0 , A =
<span class="math inline">\(.容易由定义见到\)</span> , A <span class="math inline">\(.假若\)</span>A <span class="math inline">\(,则上述的平凡引理使得\)</span>A ( A - ) &gt; 0
<span class="math inline">\(.这里我们就应当会思考一个事情是,能否进行微调来使得得到更大的\)</span><span class="math inline">\(从而导出矛盾.因此这里的思路应当是,取一个\)</span><span class="math inline">\(然后找到一个向量\)</span> <span class="math inline">\(,使得\)</span>A &gt; ( + ) $从而导出矛盾.</p>
<p>回到我们拿到的条件,应该存在$&gt; 0 <span class="math inline">\(使得\)</span>A ( A - ) &gt; A <span class="math inline">\(,留意到由于平凡引理,应当\)</span>A &gt; 0 <span class="math inline">\(,取适当的\)</span>t <span class="math inline">\(来归一化,定义出\)</span> = tA S
$,从而上式导出:</p>
<p><span class="math display">\[
\begin{aligned}
A ( A \vec { v  } ) &amp; &gt; ( \rho + \epsilon ) A \vec { v  } \\
A \vec { w  } &amp; &gt; ( \rho + \epsilon ) \vec { w  }
\end{aligned}
\]</span></p>
<p>立即导出矛盾.因此必有$A = <span class="math inline">\(.此外,引理告诉我们\)</span>A &gt; 0 <span class="math inline">\(恒成立,则\)</span> = ^{ - 1 } A &gt; 0
$亦然成立.</p>
<p>接下来证明这个$<span class="math inline">\(就是谱半径\)</span>( A )
<span class="math inline">\(.由定义见到\)</span><span class="math inline">\(作为特征值应当满足\)</span>( A ) <span class="math inline">\(,接下来只需证明\)</span>( A ) $即可.</p>
<p>对于所有的特征值$<span class="math inline">\(和相应的特征向量\)</span> <span class="math inline">\(满足\)</span>A = <span class="math inline">\(,使用三角不等式,\)</span> i n $应当有:</p>
<p><span class="math display">\[
\begin{aligned}
| \mu | | w _i | &amp; = | ( A \vec { w  } ) _i | \\
&amp; = | \sum _j a _{ i , j  } w _j | &amp; \leq \sum _j a _{ i , j  }
| w _j |
\end{aligned}
\]</span></p>
<p>将$ ’ = ( | w _1 | , , | w _n | ) ^n <span class="math inline">\(,也就是将复向量强行转到实向量上,上式立刻给出\)</span>A
’ | | ’ <span class="math inline">\(.伸缩该向量使得\)</span>| ’ | = 1
<span class="math inline">\(,于是上式给出\)</span>L ( ’ ) | | <span class="math inline">\(,这就给出了\)</span>( A ) $.于是证毕.</p>
<h5><span id="perron定理">Perron定理</span></h5>
<p>对于实矩阵$A &gt; 0 $,我们接下来声明如下定理:</p>
<ol type="1">
<li><p>$( A ) &gt; 0 <span class="math inline">\(,\)</span> ^n , &gt; 0
, A = ( A ) $.也即:谱半径的确是一个特征值.</p></li>
<li><p>如果$( A ) <span class="math inline">\(,则\)</span>| | &lt; ( A )
$.也就是:谱半径只此实特征值能达到.</p></li>
<li><p>谱半径的代数重数和几何重数均为$1 $.</p></li>
</ol>
<p>(1)也就是Collatz-Wielandt公式.</p>
<p>(2)的话考虑对Collatz-Wielandt公式作一些补充.假使复特征值$<span class="math inline">\(满足\)</span>| | = ( A ) <span class="math inline">\(,则不等式链\)</span>( A ) = L ( ) L ( ’ ) | | = (
A ) <span class="math inline">\(必然全部三角不等式取等,中间的每一项\)</span>w _j
<span class="math inline">\(都必然落在复平面的同一条直线上,那就可以除去一个复数得到实向量\)</span>
’ ’ <span class="math inline">\(亦然满足\)</span>A ’ ’ = ’ ’ <span class="math inline">\(,由于该式子中除了\)</span><span class="math inline">\(均为实数,因此\)</span><span class="math inline">\(也必然是实数.而且\)</span>$当然不可能是负数,这样就完成了(2)的证明.</p>
<p>(3)的话先考虑证明几何重数$V _{ ( A ) } = 1 <span class="math inline">\(,考虑\)</span> , ’ <span class="math inline">\(都是\)</span>( A ) <span class="math inline">\(的特征向量,其中\)</span> <span class="math inline">\(由于上述讨论而满足\)</span> &gt; 0 <span class="math inline">\(,而\)</span> ’ <span class="math inline">\(至少有一个分量为正数.既然如此,应当可以取足够小的\)</span>&gt;
0 <span class="math inline">\(使得\)</span> - ’ <span class="math inline">\(,以至于可以取其中尽可能大的\)</span><span class="math inline">\(使得\)</span> - ’ $的某一个分量恰好为$0 <span class="math inline">\(.我们接下来声明此时\)</span> - ’ = 0 <span class="math inline">\(以说明\)</span> ’ <span class="math inline">\(和\)</span> $线性相关</p>
<p>为说明此进行反证,假设$ - ’ <span class="math inline">\(,用平凡引理,考虑\)</span> - ’ = { ( A ) } A ( - ’
) &gt; 0 $,然而我们已经说明其有一个分量为$0 $,导出矛盾.</p>
<p>接下来考虑(3)的完全版本,利用$V _{ ( A ) } = 1 <span class="math inline">\(,如果我们能将整个空间拆成两部分不变子空间,其中一部分是\)</span>
<span class="math inline">\(,那就可以完成上面的部分,原因是此时另一部分不变子空间中不能有\)</span>(
A ) $作为根,否则与其维数为$1
$矛盾.另一方面,原本的特征多项式就是两个不变子空间的特征多项式的乘积,这就证明了单根的性质.</p>
<p>于此,考虑以下操作:考虑$ ( A ) = ( A ^T ) <span class="math inline">\(,于是\)</span>( A ) = ( A ^T ) <span class="math inline">\(,这就意味着\)</span> &gt; 0 <span class="math inline">\(使得\)</span>( A ^T ) = ( A ) <span class="math inline">\(.取出它的正交补空间\)</span> ^<span class="math inline">\(,它应当是\)</span>A $的不变子空间,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
( \vec { u  } ) ^T ( A \vec { x  } ) &amp; = ( A ^T \vec { u  } ) ^T
\vec { x  } \\
&amp; = \rho ( A ) ( \vec { u  } ) ^T \vec { x  } &amp; = 0
\end{aligned}
\]</span></p>
<p>同时注意到$ &gt; 0 , &gt; 0 <span class="math inline">\(,所以\)</span>
^$,这就完成了直和分解,于是上述命题证毕.</p>
<h4><span id="实正交变换的标准型">实正交变换的标准型</span></h4>
<p>(ps:虽然这里放在实内积空间里,然而大部分性质实际上是转移自复内积空间的结构,应当先看下面的章节,回头再来观察此节.)</p>
<p>回忆到取定$V <span class="math inline">\(是实线性空间,并取上面的某种内积形式,对于\)</span>T
( V ) <span class="math inline">\(,若其满足\)</span>T ^* = T ^{ - 1 }
<span class="math inline">\(,则它是实正交变换.特别地,当取标准内积的时候,所对应的就是正交矩阵,则\)</span>A
^t = A ^{ - 1 } $.</p>
<p>回忆到此时$A = $.</p>
<p>将正规算子的概念从复数域里面拿到实数域,即满足$( A ^t ) A = A ( A ^t )
<span class="math inline">\(.我们在下面做复数酉变换的时候证明过引理:\)</span>k
, T ^k = 0 T = 0 $.容易见到正交算子一定是正规的.</p>
<p>接下来来观察不同维度的正交变换,假设$_{ } V = n $.</p>
<p>当$n = 1 <span class="math inline">\(的时候,正交变换显然是长度为\)</span> <span class="math inline">\(的伸缩变换,也就是\)</span> _V $.</p>
当$n = 2 <span class="math inline">\(的时候,不妨设矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}\alpha &amp; \beta \\ \gamma
&amp; \delta \end{bmatrix}\]</span>
<p>$,用正交性质就知道:</p>
<p><span class="math display">\[
\begin{cases}
\alpha ^2 + \gamma ^2 = 1 \\
\beta ^2 + \delta ^2 = 1 \\
\alpha ^2 + \beta ^2 = 1 \\
\gamma ^2 + \delta ^2 = 1
\end{cases}
\]</span></p>
做三角换元后考虑到行列式为$ <span class="math inline">\(,在一些简单的确定后,立刻见到原矩阵要么是:\)</span>
<span class="math display">\[\begin{bmatrix}\cos \theta &amp; - \sin
\theta \\ \sin \theta &amp; \cos \theta \end{bmatrix}\]</span>
<span class="math inline">\(,要么是\)</span>
<span class="math display">\[\begin{bmatrix}\cos \theta &amp; \sin
\theta \\ \sin \theta &amp; - \cos \theta \end{bmatrix}\]</span>
<p><span class="math inline">\(,它们的行列式分别为\)</span> $.</p>
<p>拿出行列式恰好为$+ 1 $的前者:</p>
<p><span class="math display">\[
R ( \theta ) = \begin{bmatrix}
\cos \theta &amp; - \sin \theta \\
\sin \theta &amp; \cos \theta
\end{bmatrix}
\]</span></p>
<p>也就是通常所说的旋转矩阵.容易见到:</p>
<ol type="1">
<li><p>$R ( ) R ( ) = R ( + ) = R ( ) R ( ) $.</p></li>
<li><p>如果$P <span class="math inline">\(是一个正交算子,则\)</span>P ^{
- 1 } R ( ) P = R ( ( P ) ) $.</p></li>
</ol>
<p>(1)只需对$ $验证即可.</p>
(2)的话,当$P = 1 <span class="math inline">\(的时候,当然有\)</span>P = R
( ) , P ^{ - 1 } = R ( - ) <span class="math inline">\(,那显然成立了;当\)</span>P = - 1 <span class="math inline">\(的时候,只需在外面补一个\)</span>
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ 0 &amp; - 1
\end{bmatrix}\]</span>
<p>$即可转化.</p>
<p>于此之前,考虑如果$T <span class="math inline">\(是正交变换,它当然一定是正规的,那么它在复数上可正交对角化,特征值当然满足\)</span>|
| = 1 <span class="math inline">\(,那么当然\)</span>T + T ^{ - 1 } <span class="math inline">\(自伴.而且它俩可以同步对角化,那\)</span>T + T ^{ -
1 } <span class="math inline">\(的特征值当然是\)</span>| | = | + ^{ - 1
} | | | + | ^{ - 1 } | = 2 $.</p>
<p>接下来考虑一般的情况,我们声明,对于任意正交变换,都可以取基转化为下述形式:</p>
<p><span class="math display">\[
\begin{bmatrix}
I _{ a \times a  } &amp; &amp; &amp; \\
&amp; - I _{ b \times b  } &amp; &amp; &amp; \\
&amp; &amp; R ( \theta _1 ) &amp; &amp; \\
&amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; &amp; &amp; R ( \theta _k )
\end{bmatrix}
\]</span></p>
<p>其中$_1 , , _k <span class="math inline">\(都并非\)</span>$的整数倍.</p>
<p>证明考虑令$S = T ^{ - 1 } + T <span class="math inline">\(,容易见到其自伴,那原空间就可以拆成\)</span>S <span class="math inline">\(的若干特征子空间的直和,容易发现\)</span>ST = TS
<span class="math inline">\(,这必然意味着\)</span>V <em><span class="math inline">\(是\)</span>T <span class="math inline">\(不变的,于是下面可以只着眼于一个特征子空间,观测\)</span>V
= V </em><span class="math inline">\(的情形,且\)</span> , | | $.</p>
<p>则此时观察此空间,应当有$T + T ^{ - 1 } = I _V <span class="math inline">\(.两边乘以\)</span>T <span class="math inline">\(,得到\)</span>T ^2 - T + I = 0 $.</p>
<p>下面我们开始讨论,当$= <span class="math inline">\(的时候,则上述配方得到\)</span>( T I ) ^2 = 0 <span class="math inline">\(,由于\)</span>T I <span class="math inline">\(是正规算子,于是\)</span>T I = 0 <span class="math inline">\(,这就对应了上述矩阵中的\)</span> $的分块.</p>
<p>那如果$ <span class="math inline">\(呢,那就必然有\)</span>| | &lt; 2
<span class="math inline">\(,则\)</span>x ^2 - x + 1 <span class="math inline">\(无实根,不可约,但带入\)</span>x = T $会得到$0 <span class="math inline">\(,因此它必然是\)</span>T <span class="math inline">\(在此空间下的极小多项式.又因为\)</span>T <span class="math inline">\(如果有实特征值,必然是\)</span> <span class="math inline">\(,则此时\)</span>= <span class="math inline">\(.因此,\)</span>T <span class="math inline">\(没有实特征值.既然如此,任取一个向量\)</span> <span class="math inline">\(,\)</span> <span class="math inline">\(与\)</span>T $必然线性无关.</p>
<p>既然如此,使他们张成子空间$W = , T <span class="math inline">\(并作直和分解\)</span>V = W W ^<span class="math inline">\(.由于\)</span>T ^2 = T - I <span class="math inline">\(,因此注意到\)</span>W <span class="math inline">\(应当是\)</span>T <span class="math inline">\(不变的.那么,\)</span>W ^<span class="math inline">\(在\)</span>T ^* = T ^{ - 1 } <span class="math inline">\(作用下当然也是不变的.然而,\)</span>T = I - T ^{ -
1 } <span class="math inline">\(,所以\)</span>T <span class="math inline">\(是关于\)</span>T ^{ - 1 } <span class="math inline">\(的多项式,于是\)</span>W ^<span class="math inline">\(在\)</span>T <span class="math inline">\(下也是不变的.这样,我们完全把空间归纳下去了,每次都可以扔出去一个\)</span>=
2 <span class="math inline">\(的空间.于是最后一步是检验\)</span>T <span class="math inline">\(在归纳下去的空间上的性质.对于\)</span>= 2 <span class="math inline">\(的空间,\)</span>x ^2 - x + 1 <span class="math inline">\(当然仍然不可约,而它必然就是特征多项式,那\)</span>=
1 $就自然成立.</p>
<p>最后应当简单解释上述形式是否由$T
$唯一确定.然而应属显然了,因为每一次拆出的特征多项式当然都是原本特征多项式的一个不可约因子.</p>
<h5><span id="欧拉角">欧拉角</span></h5>
考虑三维空间中的旋转,我们通过上述对实正交矩阵的分类得知,三维空间中的旋转立刻统合为$
<span class="math display">\[\begin{bmatrix}1 &amp; \\ &amp; R ( \theta
) \end{bmatrix}\]</span>
<p>$.</p>
<p>那么就需要两个参数来描述此,旋转轴$ = <em>1 <span class="math inline">\(的坐标用以描述转轴以及一个参数\)</span><span class="math inline">\(用来描述转角.不妨将这种旋转记作\)</span>R </em>{ u
} ( ) <span class="math inline">\(.然而于此之外,先要论证此旋转和另外两个单位正交基\)</span>
_2 , _3 <span class="math inline">\(无关.然而容易见到不管如何选取这两个基,它们都会同样张成\)</span>
^$,因此它们都在同一个空间里,而且只差一个旋转.这个旋转前后当然可以抵消,这也是直觉所告知我们的.</p>
<p>由此就可以看到三维空间的及其好的性质,我们一般称呼二维空间中的旋转,它的转轴实际上是垂直于此平面的一个更高维的轴.而三维空间中的转轴一定落在三维空间中,不需要再到高维空间中找到转轴了.</p>
<p>综上,旋转总是将一个有序单位正交基转化为另一个有序单位正交基,三维空间中表现为$(
_1 , _2 , _3 ) ( _1 , _2 , _3 ) $.</p>
<p>对于指定基的旋转,我们应当通过一定的交换基的操作见到:</p>
$$
<span class="math display">\[\begin{aligned}
R _{ e _1  } ( \theta ) &amp; = \begin{bmatrix}
1 &amp; &amp; \\
&amp; \cos \theta &amp; - \sin \theta \\
&amp; \sin \theta &amp; \cos \theta
\end{bmatrix} \\
R _{ e _2  } ( \theta ) &amp; = \begin{bmatrix}
\cos \theta &amp; &amp; \sin \theta \\
&amp; 1 &amp; \\
- \sin \theta &amp; &amp; \cos \theta
\end{bmatrix} \\
R _{ e _3  } ( \theta ) &amp; = \begin{bmatrix}
\cos \theta &amp; - \sin \theta &amp; \\
\sin \theta &amp; \cos \theta &amp; \\
&amp; &amp; 1
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
为了表示使得任意基下的旋转,我们考虑先转好一个轴,然后再以此轴作旋转.那我们考虑构造一个$
_2 =
<span class="math display">\[\begin{cases}\vec { e  } _2 &amp; \vec {
e  } _3 / / \vec { u  } _3 \\ \vec { e  } _3 \times \vec { u  } _3 &amp;
otherwisse \end{cases}\]</span>
<p>$.</p>
<p>换言之,此时我们选了一个轴$ _2 <span class="math inline">\(,它与\)</span> _3 , _3
$均正交,那我们就可以这么转:</p>
<ol type="1">
<li><p>将$( _1 , _2 , _3 ) <span class="math inline">\(绕\)</span> _3
<span class="math inline">\(转到\)</span>( _1 , _2 , _3 ) $.</p></li>
<li><p>将$( _1 , _2 , _3 ) <span class="math inline">\(绕\)</span> _2
<span class="math inline">\(转到\)</span>( _1 , _2 , _3 ) $.</p></li>
<li><p>将$( _1 , _2 , _3 ) <span class="math inline">\(绕\)</span> _3
<span class="math inline">\(转到\)</span>( _1 , _2 , _3 ) $.</p></li>
</ol>
<p>综上,一个旋转矩阵总可以写成三个矩阵$R _{ u <em>2 } ( ) R </em>{ f
<em>2 } ( ) R </em>{ e _3 } ( ) <span class="math inline">\(的乘积,我们称\)</span>T <span class="math inline">\(是由**欧拉角**\)</span>( , , ) $所确定的.</p>
<p>不过,上述的转轴并非我们选定的有序正交基$( _1 , _2 , _3 ) <span class="math inline">\(,换言之,转轴不是以观察者视角的,而是以被旋转物体本身的视角而言的.可既然要转为矩阵表述,我们应当搞一个观察者版本的矩阵.这就要求转轴被控制为\)</span>(
_1 , _2 , <em>3 ) <span class="math inline">\(.我们下面尝试证明\)</span>R </em>{ u <em>2 } ( ) R
</em>{ f <em>2 } ( ) R </em>{ e <em>3 } ( ) = R </em>{ e <em>3 } ( ) R
</em>{ e <em>2 } ( ) R </em>{ e _3 } ( ) $.</p>
<p>对于正交变换$P <span class="math inline">\(,并设\)</span>= P = <span class="math inline">\(,应当有\)</span>R _{ Pu } ( ) = PR _u ( ) P ^{ - 1
} <span class="math inline">\(.其实到这里只有这个\)</span><span class="math inline">\(的用法并非显然,但总之,用代数的语言可以看出\)</span>P
<span class="math inline">\(将\)</span>( , , ) ( P , P , P ) <span class="math inline">\(,这当然仍是一组有序正交基.但为了使其的方向为正,可以改为\)</span>(
P , P , P ) <span class="math inline">\(以避免讨论,然后去检验\)</span>PR
<em>u ( ) <span class="math inline">\(和\)</span>R </em>{ Pu } ( ) P
<span class="math inline">\(对基\)</span>( , , )
$的作用.总之容易验证.</p>
<p>既然如此,考虑$ <em>2 = R </em>{ e _3 } ( ) <em>2 <span class="math inline">\(,既然如此,\)</span>R </em>{ f <em>2 } ( ) = R
</em>{ e <em>3 } ( ) R </em>{ e <em>2 } ( ) R </em>{ e _3 } ( ) ^{ - 1 }
$.</p>
<p>同理,$ <em>3 = R </em>{ f _2 } ( ) <em>3 = R </em>{ f <em>2 } ( ) R
</em>{ e _3 } ( ) <em>3 <span class="math inline">\(,既然如此,得到\)</span>R </em>{ u <em>3 } ( ) = R
</em>{ e <em>3 } ( ) R </em>{ e <em>2 } ( ) R </em>{ e <em>3 } ( ) R
</em>{ e <em>2 } ( ) ^{ - 1 } R </em>{ e _3 } ( ) ^{ - 1 }
$.这就证明了上述结论.</p>
<p>更具体地说,它表为:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; &amp; \\
&amp; \cos \psi &amp; - \sin \psi \\
&amp; \sin \psi &amp; \cos \psi
\end{bmatrix} \begin{bmatrix}
\cos \theta &amp; &amp; \sin \theta \\
&amp; 1 &amp; \\
- \sin \theta &amp; &amp; \cos \theta
\end{bmatrix} \begin{bmatrix}
1 &amp; &amp; \\
&amp; \cos \varphi &amp; - \sin \varphi \\
&amp; \sin \varphi &amp; \cos \varphi
\end{bmatrix}
\]</span></p>
<h5><span id="四元数">四元数</span></h5>
<p>试图搞一个以$ <span class="math inline">\(的东西.其中\)</span>
$是一个除环,也就是在域的基础上丢掉了交换律.</p>
<p>具体如何构造呢?考虑在实线性空间的基础上引入乘法,那就先要构造它的一组基${
1 , i , j , k } <span class="math inline">\(.现在就只需要定义乘法,当然是\)</span> , ( x , y )
x y <span class="math inline">\(,并且要求它对于\)</span>
$是双线性的.同时要求以下规则:</p>
<ol type="1">
<li><p>$1 x = x $.</p></li>
<li><p>$i ^2 = j ^2 = k ^2 = - 1 $.</p></li>
<li><p>$ij = k = - ji $.</p></li>
<li><p>$jk = i = - kj $.</p></li>
<li><p>$ki = j = - ik $.</p></li>
</ol>
<p>那么双线性性质和上述约定当然搞定了一个乘法映射.为说明其是环,还应当验证以下性质:</p>
<ol type="1">
<li><p>分配律.由双线性形式显然.</p></li>
<li><p>结合律.只需验证上述四个元素$1 , i , j , k $的结合律即可.</p></li>
</ol>
<p>这就搞定了环的性质.可以看到$ <span class="math inline">\(可以看作\)</span> <span class="math inline">\(或者\)</span> <span class="math inline">\(上的向量空间,对于前者是因为\)</span>q = a + bi +
cj + dk <span class="math inline">\(,对于后者是因为任何一个\)</span>q
<span class="math inline">\(都可以写作\)</span>q = z + jw <span class="math inline">\(,其中\)</span>z , w <span class="math inline">\(的形式,这里顺便一提此表述下\)</span>jw = { w } j
$.这当然顺便也搞定了除环的性质.</p>
<p>回忆到环的中心$Z ( ) = { z q , zq = qz } <span class="math inline">\(.我们声称\)</span>Z ( ) = <span class="math inline">\(.由于\)</span> <span class="math inline">\(的特殊性,我们知道只需要对\)</span>{ 1 , i , j , k
} <span class="math inline">\(检查交换性即可,会发现只有\)</span>
$是合理的.</p>
<p>定义一个四元数$q = a + bi + cj + dk <span class="math inline">\(的**共轭**\)</span>{ q } = a - bi - cj - dk <span class="math inline">\(,定义其**迹**\)</span> ( q ) = q + { q } = 2 a
<span class="math inline">\(,再定义其**范数**\)</span>N ( q ) = q { q }
$.有以下性质:</p>
<ol type="1">
<li><p>共轭对$ $是线性映射.</p></li>
<li><p>$ = q $.</p></li>
<li><p>$ = { q _1 } + { q _2 } $.</p></li>
<li><p>$ = { q _2 } { q _1 } $.</p></li>
<li><p>迹对$ $是线性映射.</p></li>
<li><p>${ N ( q ) } = N ( q ) = N ( { q } ) $.</p></li>
<li><p>$N ( a + bi + cj + dk ) = a ^2 + b ^2 + c ^2 + d ^2 $.</p></li>
<li><p>$N ( q _1 q _2 ) = N ( q _1 ) N ( q _2 ) $.</p></li>
<li><p>如若$q <span class="math inline">\(,则\)</span>q ^{ - 1 } = ( N (
q ) ) ^{ - 1 } { q } $.</p></li>
<li><p>$N ( q ^{ - 1 } ) = N ( q ) ^{ - 1 } $</p></li>
</ol>
<p>(1)(2)(3)是显然的.(4)的话由于乘法的双线性,只需验证$q _1 , q _2 { 1 ,
i , j , k } $的情形.</p>
<p>(5)(6)是显然的.</p>
<p>(7)除了暴力验证以外,观察到(6),考虑$N ( a + bi + cj + dk ) = a ^2 + b
^2 + c ^2 + d ^2 + xi + yj + zk <span class="math inline">\(,然而\)</span>{ N ( q ) } = N ( q )
$,这必然意味着后面均为$0 $.</p>
<p>(8)(9)(10)只需展开检验即可.这就详细描述了除环的结构.</p>
<p>我们还可以证明四元数已经到达极限了,有Frobenius定理:如果$D <span class="math inline">\(是一个除环且是一个\)</span> <span class="math inline">\(上的有限维线性空间,其乘法还对\)</span> <span class="math inline">\(满足双线性,那么\)</span>D <span class="math inline">\(一定同构于\)</span> , ,
$三者其一,再无别的情形.怎么证明?我不会,长大后再学习.</p>
最后我们还可以验证$ <span class="math inline">\(可以表为\)</span>M _{ 2
} ( ) <span class="math inline">\(的一个子环,考虑仍取\)</span>q = z + jw
<span class="math inline">\(,然后将其改写为\)</span>
<span class="math display">\[\begin{bmatrix}z &amp; - \bar { w  } \\ w
&amp; \bar { z  } \end{bmatrix}\]</span>
<span class="math inline">\(.这个矩阵结构可以符合加法,乘法,迹(对应到矩阵的迹),范数(对应到矩阵的行列式).这其实很像复数上把\)</span>a
+ bi
<span class="math display">\[\begin{bmatrix}a &amp; - b \\ b &amp; a
\end{bmatrix}\]</span>
<p>$.那么我们可以:</p>
$$
<span class="math display">\[\begin{gathered}
1 \mapsto \begin{bmatrix}
1 &amp; \\
&amp; 1
\end{bmatrix} \\
i \mapsto \begin{bmatrix}
i &amp; \\
&amp; - i
\end{bmatrix} \\
j \mapsto \begin{bmatrix}
&amp; - 1 \\
1 &amp;
\end{bmatrix} \\
k \mapsto \begin{bmatrix}
&amp; - i \\
- i &amp;
\end{bmatrix} \\

\end{gathered}\]</span>
<p>$$</p>
<p>接下来考虑去掉环的性质,只看线性空间的性质,将目光着眼于$ ^3 <span class="math inline">\(上并只取出\)</span>q = ai + bj + ck <span class="math inline">\(,取这个子空间为\)</span> _0 <span class="math inline">\(,在上面挪用\)</span>N ( q ) <span class="math inline">\(以刻画长度,具体而言只需取\)</span>q ^2 = N ( q )
$.</p>
<p>接下来,让$x ^$,我们声明:</p>
<ol type="1">
<li><p>$q <span class="math inline">\(,\)</span>N ( xqx ^{ - 1 } ) = N (
q ) $.</p></li>
<li><p>设$R _x ( _0 ) , q xqx ^{ - 1 } $,则这是个正交变换.</p></li>
<li><p>$R _x = 1 $.</p></li>
<li><p>$R _{ tx } = R _x <span class="math inline">\(,其中\)</span>t
^<span class="math inline">\(,且\)</span>R <em>x R <em>y = R </em>{ xy }
, R </em>{ x ^{ - 1 } } = ( R <em>x ) ^{ - 1 } <span class="math inline">\(.而且\)</span>R </em>{ - 1 } = R <em>1 = </em>{ _0
} $.</p></li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的话,不妨假设$N ( x ) = 1 <span class="math inline">\(,此时\)</span>x ^{ - 1 } = { x } <span class="math inline">\(.首先要证明这个映射确实是\)</span> ( _0 ) <span class="math inline">\(里面的,观察\)</span> = { x ^{ - 1 } } { q } { x }
= x ( { q } ) x ^{ - 1 } = - xqx ^{ - 1 } <span class="math inline">\(,这就说明\)</span>xqx ^{ - 1 } _0 $.</p>
<p>然后要检验它是线性映射,这里只需使用除环的性质简单验证.</p>
<p>最后由(1)说明其保距,这就说明了它是正交变换.</p>
<p>最后是(3),将$ ^4 <span class="math inline">\(考虑映射\)</span> ^4 { 0
} { } , x R _x <span class="math inline">\(.这由于矩阵\)</span>R _x
<span class="math inline">\(的每个元当然是关于\)</span>x <span class="math inline">\(的连续函数,因此整个映射都是连续的,而空间\)</span>
^4 { 0 } <span class="math inline">\(是联通的,因此整个映射必然只射到常数,而\)</span>R
_1 = 1 <span class="math inline">\(,因此对于任意\)</span>x ^<span class="math inline">\(都有\)</span>R _x = 1 $.</p>
<p>(4)只需简单验证即可.</p>
<p>所以我们终于见到了,这个$R _x <span class="math inline">\(应当就是三维上的正交旋转.现在最后的问题在于是否所有的旋转都可以表示为\)</span>R
_x <span class="math inline">\(.我们有下述定理:即对于任意在\)</span>
<span class="math inline">\(上的旋转\)</span>T <span class="math inline">\(,\)</span>x <span class="math inline">\(,\)</span>N ( x ) = 1 <span class="math inline">\(,使得\)</span>T = Rx <span class="math inline">\(,并且\)</span>x <span class="math inline">\(精确到绝对值是唯一的,换言之,恰有两个\)</span>x , -
x $满足上述条件.</p>
<p>先证明存在性,回忆到欧拉角声明了$T <span class="math inline">\(可以由三个绕轴旋转完成.也就是说,只要我们能证明绕轴旋转\)</span>R
_{ e _l } ( ) $可以用四元数表示,那么任意旋转都可以用四元数表示了.</p>
<p>不同轴类似只算一个,当绕着$i <span class="math inline">\(那条轴转的时候,取\)</span>x = + i <span class="math inline">\(,则\)</span>x ^{ - 1 } = { x } = - i $,见到:</p>
<p><span class="math display">\[
\begin{aligned}
xix ^{ - 1  } &amp; = i \\
xjx ^{ - 1  } &amp; = \cos ( 2 \theta ) j + \sin ( 2 \theta ) k \\
xkx ^{ - 1  } &amp; = - \sin ( 2 \theta ) j + \cos ( 2 \theta ) k
\end{aligned}
\]</span></p>
综上见到$R _x <span class="math inline">\(是:\)</span>
<span class="math display">\[\begin{bmatrix}1 &amp; \\ &amp; R ( 2
\theta ) \end{bmatrix}\]</span>
<p>$,这样就实现了对第一个坐标轴转$2 $的情形.</p>
<p>类似的,就可以说明四元数可以表示所有的旋转.</p>
<p>最后要检验唯一性,如果$R _x = R <em>y <span class="math inline">\(,其中\)</span>N ( x ) = N ( y ) = 1 <span class="math inline">\(,那就有\)</span> </em>{ _0 } = R _x ( R <em>y ) ^{
- 1 } = R </em>{ xy ^{ - 1 } } $.</p>
<p>于是最后转化为说,要证明如果$R <em>{ x } = </em>{ _0 } <span class="math inline">\(,那么\)</span>x = <span class="math inline">\(.那就说明\)</span>q , xqx ^{ - 1 } = q <span class="math inline">\(,也就是\)</span>x Z ( ) = <span class="math inline">\(.又由于\)</span>N ( x ) = 1 <span class="math inline">\(,所以\)</span>x = $.</p>
<p>更具体来说,绕着$u <span class="math inline">\(这条轴,且满足\)</span>N
( u ) = 1 <span class="math inline">\(来说,那么\)</span>R _u ( ) = { 2 }
+ u { 2 } $.</p>
<p>首先要验证$x = { 2 } + u { 2 } <span class="math inline">\(满足\)</span>N ( x ) = 1 $,而:</p>
<p><span class="math display">\[
\begin{aligned}
N ( x ) &amp; = x \bar { x  } \\
&amp; = ( \cos \frac { \theta  } { 2  } + u \sin \frac { \theta  } {
2  } ) ( \cos \frac { \theta  } { 2  } - u \sin \frac { \theta  } { 2  }
) \\
&amp; = \cos ^2 \frac { \theta  } { 2  } - u ^2 \sin ^2 \frac {
\theta  } { 2  } \\
&amp; = \cos ^2 \frac { \theta  } { 2  } + N ( u ) \sin ^2 \frac {
\theta  } { 2  } \\
&amp; = 1
\end{aligned}
\]</span></p>
<p>而考虑总存在一个旋转$P = R _y <span class="math inline">\(,使得\)</span>P ( i ) = u $,此时我们可以知道:</p>
$$
<span class="math display">\[\begin{aligned}
R _u ( \theta ) &amp; = PR _i ( \theta ) P ^{ - 1  } \\
&amp; = R _y R _i ( \theta ) R _{ y ^{ - 1  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设$R _u ( ) = R _x $,则:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = y ( \cos \frac { \theta  } { 2  } + i \sin \frac { \theta  } {
2  } ) y ^{ - 1  } \\
&amp; = \cos \frac { \theta  } { 2  } + \sin \frac { \theta  } { 2  }
yiy ^{ - 1  } \\
&amp; = \cos \frac { \theta  } { 2  } + \sin \frac { \theta  } { 2  } u
\end{aligned}
\]</span></p>
<p>用欧拉公式的话,有$R _u ( ) = e ^{ { 2 } u } $.</p>
<h3><span id="复内积空间">复内积空间</span></h3>
<h4><span id="共轭空间">共轭空间</span></h4>
<p>这应当带给我们思考,既然远在定义复数的时候,我们就声称过$i <span class="math inline">\(和\)</span>- i
$无法区分,于是在此,应当研究一下共轭前后的两个空间分别的性质.</p>
<p>设$V <span class="math inline">\(是\)</span> <span class="math inline">\(下的向量空间,它的复共轭\)</span>{ V } <span class="math inline">\(是按照以下方式确定的\)</span> $向量空间:</p>
<ol type="1">
<li><p>集合$V $与加法操作与原空间相同.</p></li>
<li><p>纯量乘法$: V V <span class="math inline">\(定义为\)</span>t = { t
} $.</p></li>
</ol>
<p>显然$ = V <span class="math inline">\(.半双线性映射无非是线性映射\)</span>{ V } W <span class="math inline">\(.当然,也可以等价说是\)</span>V { W }
$.我们接下来验证复共轭的若干性质:</p>
<ol type="1">
<li><p>映射$z { z } <span class="math inline">\(给出向量空间的共轭\)</span> { } : z { z }
$.</p></li>
<li><p>${ V } _1 { V } _2 = $.</p></li>
<li><p>$ = ( { V } _1 , { V } _2 ) $.</p></li>
<li><p>${ { W } } ^ $,其实是(3)的另一种表示方式.</p></li>
</ol>
<p>应当检验上述映射,同构,甚至是完全挪移都是良定义的且半线性的,这里不做赘述.</p>
<p>相信对共轭空间最大的疑问在于,既然其改变了纯量乘法,原本的向量结构为什么不会被打乱呢?事实上,如果你考虑选定一组基的话,纯量乘法上的轻微改变只会使得将其它向量转化为基表示形式的过程中所提取出的纯量发生变化,然而共轭满足$
= { z _1 } { z _2 } <span class="math inline">\(.虽然取定基的做法并非典范,然而不同基之间的转化仍然可以提取纯量.或者说,我们可以先取\)</span>V
^n ( { } ) ^n { V } $.</p>
<p>或直接从复数的几何意义来说,共轭无非是将逆时针旋转改为顺时针旋转,这应当仍是合理的.</p>
<h4><span id="复半双线性形式">(复)半双线性形式</span></h4>
<p>应当见到双线性形式在复空间中未必有很好的应用,原因是正定性难以得到满足.</p>
<p>定义<strong>半线性映射</strong>为$T : V W $满足:</p>
<ol type="1">
<li><p>$T ( _1 + _2 ) = T ( _1 ) + T ( _2 ) $.</p></li>
<li><p>$T ( t ) = { t } T ( ) $.</p></li>
</ol>
<p>定义<strong>半双线性映射</strong>为$B : V W X $满足:</p>
<ol type="1">
<li><p>$B ( _1 + _2 , ) = B ( _1 , ) + B ( _2 , ) $.</p></li>
<li><p>对第一个变量半线性:$B ( t , ) = { t } B ( , ) $.</p></li>
<li><p>$B ( , _1 + _2 ) = B ( , _1 ) + B ( , _2 ) $.</p></li>
<li><p>对第二个变量线性:$B ( , t ) = t B ( , ) $.</p></li>
</ol>
<p>至于复伴随映射以及其余的东西,无非只是在实数上类似的定义的照抄.将上述记作$
( V , W ; X ) <span class="math inline">\(.特别地,当\)</span>X = <span class="math inline">\(的时候,将此称作半双线性形式.应当立刻见到\)</span>
( V , W ; X ) = ( { V } , W ; X ) $.</p>
<p>至于非退化等部分仍然是实数情况的照抄,对左右根,不妨设左根空间为$L
<span class="math inline">\(,右根空间为\)</span>R <span class="math inline">\(,用柯里化过程见到该形式等价于\)</span> ( W , { { V
} } ^) <span class="math inline">\(或者\)</span> ( { V } , W ^) <span class="math inline">\(,那么\)</span>L = , R = <span class="math inline">\(,我们应当见到\)</span>B ’ : ( V / L ) ( W / R ) F
, ( + L , + R ) B ( , ) <span class="math inline">\(是非退化双线性形式.此时见到其实\)</span>V - L = W
- R $.</p>
<p>接下来要用矩阵形式予以表述,我们声称$M _{ m n } ( ) ( ^m , ^n ) , A B
( , ) = ( ^ ) A <span class="math inline">\(,原因是标准基下\)</span>
$的对偶空间其实就是共轭转置后的结果.</p>
<h4><span id="伴随映射">伴随映射</span></h4>
<p>与实数情况毫无差异,我们在此复述一遍当时的图表即可:</p>
<p><span class="math display">\[
\xymatrix { V _2 &#39; \ar [r ] ^{ T ^*  } \ar [d ] _{ A _2  } &amp; V
_1 &#39; \ar [d ] ^{ A _1  } \\
\check { V _2  } \ar [r ] ^{ ^\dagger T  } &amp; \check { V _1  } \\
V _2 \ar [u ] &amp; V _1 \ar [u ] \ar [l ] _T  }
\]</span></p>
<p>同样,我们可以定义<strong>自伴</strong>性质:$T ^* = T <span class="math inline">\(以及**反自伴**性质\)</span>T ^* = - T <span class="math inline">\(.此处出现了复数与实数不同的地方:假设\)</span>c
<span class="math inline">\(是非零纯虚数,则\)</span>T <span class="math inline">\(自伴当且仅当\)</span>cT
$反自伴.这性质是容易验证的,也告知我们复数域上的反自伴并不需要像实数那样使用单独的辛空间来刻画.</p>
<p>类比实数,下面定理当然也是对的:</p>
<p>而注意到$T ^* T $是自伴的,然而其还有更多的好性质:</p>
<ol type="1">
<li><p>$( T ) ^= ( T ^* ) $.</p></li>
<li><p>$  ( T ^* T ) =  ( T ^* ) $.</p></li>
<li><p>$( T ^* T ) = T $.</p></li>
<li><p>$  ( T ^* T ) =  ( T ) = ( T ^* ) $.</p></li>
</ol>
<p>证明与实数情形无差.</p>
<h4><span id="hermite形式">Hermite形式</span></h4>
<p>设$V <span class="math inline">\(是\)</span> <span class="math inline">\(下的向量空间,\)</span>{ - 1 , 1 } <span class="math inline">\(,若半双线性形式\)</span>B : V V <span class="math inline">\(满足\)</span>B ( , ) = <span class="math inline">\(的话,我们就称\)</span>B <span class="math inline">\(是一个\)</span>- <span class="math inline">\(Hermite形式.如果\)</span>= 1 <span class="math inline">\(,称这是一个**Hermite形式**;如果\)</span>= - 1
<span class="math inline">\(,则称其为**反Hermite形式**.容易验证,如果\)</span>B
<span class="math inline">\(是Hermite的,那么\)</span>iB
$是反Hermite的.</p>
<p>此定义直接导致$B <span class="math inline">\(的左右根是一回事,我们后面会称其为\)</span>B <span class="math inline">\(的根基.并容易见到等价于其对应的矩阵满足\)</span>A
^= A
$.也就是说,Hermite形式对应的矩阵自伴,而反Hermite形式对应的矩阵反自伴.</p>
<h5><span id="正规线性映射">正规线性映射</span></h5>
<p>给定某$- <span class="math inline">\(Hermite形式\)</span>B : V V
<span class="math inline">\(,我们称满足\)</span>( T ^* ) T = T ( T ^* )
<span class="math inline">\(的\)</span>T <span class="math inline">\(是**正规线性映射**.容易见到自伴和反自伴当然是正规的.事实上,取\)</span>T
’ = { 2 } ( T + T ^* ) , T ’ ’ = { 2 } ( T - T ^* ) <span class="math inline">\(即可见到能将\)</span>T = T ’ + T ’ ’ <span class="math inline">\(拆成一个自伴形式和一个反自伴形式.这种分解还是唯一的,原因是如果有两组形式满足\)</span>T
_1 ’ + T _1 ’ ’ = T _2 ’ + T _2 ’ ’ <span class="math inline">\(,移项后得到\)</span>T _1 ’ - T _2 ’ = T _2 ’ ’ - T
_1 ’ ’ $,左侧是自伴的,右侧是反自伴的,因此它们都是$0 $.</p>
<p>若进一步要求$T <span class="math inline">\(是正规的,也就是\)</span>(
T ^* ) T = T ( T ^* ) <span class="math inline">\(,还可以见到\)</span>T
’ T ’ ’ = T ’ ’ T ’ $,只需简单验证即可.</p>
<h5><span id="二次型">二次型</span></h5>
<p>定义复数上的半双线性版本的<strong>二次型</strong>为$f ( x _1 , , x
<em>n ) = a </em>{ i , j } { x _i } x _j <span class="math inline">\(.要证明其与\)</span>- <span class="math inline">\(Hermite形式同构,不妨先直接考虑\)</span>f ( + ) = B
( + , + ) <span class="math inline">\(,那只需考虑配极化技巧,定义\)</span><span class="math inline">\(为提取实部,\)</span>$为提取虚部,立刻得到:</p>
<p><span class="math display">\[
f ( \vec { v  } + \vec { w  } ) = \begin{cases}
f ( \vec { v  } ) + f ( \vec { w  } ) + 2 \Re B ( \vec { v  } , \vec {
w  } ) &amp; \epsilon = 1 \\
f ( \vec { v  } ) + f ( \vec { w  } ) + 2 i \Im B ( \vec { v  } , \vec {
w  } ) &amp; \epsilon = - 1
\end{cases}
\]</span></p>
<p>考虑$B ( , ) = B ( i , ) <span class="math inline">\(,所以上述立刻确定了\)</span>B $.</p>
<p>搬运实二次型上的性质即可看到<strong>合同</strong>在复数域上体现于$A =
( ^C ) A ’ C $.对该多项式做对角化与实数情况无异.</p>
<p>至于复数上的<strong>惯性定理</strong>,证明与实数丝毫不差.</p>
<p>既然如此,我们下面会说明Hermite形式对应了标准内积下的自伴算子,其所有特征值均为实数.由此可以定义其<strong>正定性</strong>,当然也就是所有特征值均为正数.其余类似<strong>半正定性</strong>均可照搬原本性质.</p>
<p>于此,我们可以引出以下定理:</p>
<p>$T ^* T <span class="math inline">\(是半正定的.当\)</span>T
$是单射时,其是正定的.</p>
<p>证明无非仍然是$( T ^* T ) _V = ( T T ) _W $的直接结论.</p>
<h4><span id="复内积空间">复内积空间</span></h4>
<p>考虑正定Hermite形式$( _ _ ) : V V <span class="math inline">\(,这样的资料\)</span>( V , ( _ _ ) ) <span class="math inline">\(称为**复内积空间**,又称作**酉空间**.特别地,在\)</span>
^n <span class="math inline">\(上定义标准Hermite内积为\)</span>( ) = { x
_i } y _i $,应当见到其正定且是一个Hermite形式.</p>
<p>容易照搬大部分实内积空间的性质过来,这里简单列举:</p>
<ol type="1">
<li><p>$ = 0 = 0 $.</p></li>
<li><p>$t = | t | ^2 $.</p></li>
<li><p>$( _1 _2 ) = ( i _1 _2 ) $.</p></li>
<li><p>配极化,即$ + ^2 = ^2 + ^2 + 2 ( ) $.</p></li>
<li><p>正交单位向量,正交集合,单位正交基等概念原样照搬.</p></li>
<li><p>勾股定理,即$ <span class="math inline">\(时,\)</span> + ^2 = ^2 +
^2 $.</p></li>
<li><p>柯西不等式,即$| ( ) | $.</p></li>
<li><p>三角不等式,即$ + + $.</p></li>
<li><p>Gram-Schmidt正交化,策略仍是$ _k = <em>k - </em>{ i = 1 } ^{ k - 1
} { ( _i _i ) } _i $.</p></li>
</ol>
<p>(1)(2)(3)(4)(5)(6)的证明是平凡的.</p>
<p>(7)的证明与实数情景略有差别,仍设$t $,并观察:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp; \leq \Vert \vec { v  } + t \vec { w  } \Vert ^2 \\
&amp; = \Vert \vec { v  } \Vert ^2 + 2 \Re ( t ( \vec { v  } \mid \vec {
w  } ) ) + | t | ^2 \Vert \vec { w  } \Vert ^2 \\
&amp; \leq \Vert \vec { v  } \Vert ^2 + 2 | t | \cdot | ( \vec { v  }
\mid \vec { w  } ) | + | t | ^2 \Vert \vec { w  } \Vert ^2
\end{aligned}
\]</span></p>
<p>对于(8),只需做一些微小的调整,具体为:</p>
<p><span class="math display">\[
\begin{aligned}
\Vert \vec { v  } + \vec { w  } \Vert ^2 &amp; = \Vert \vec { v  } \Vert
^2 + 2 \Re ( \vec { v  } \mid \vec { w  } ) + \Vert \vec { w  } \Vert ^2
\\
&amp; \leq \Vert \vec { v  } \Vert ^2 + 2 | ( \vec { v  } \mid \vec {
w  } ) | + \Vert \vec { w  } \Vert ^2 \\
&amp; \leq \Vert \vec { v  } \Vert ^2 + 2 \Vert \vec { v  } \Vert \cdot
\Vert \vec { w  } \Vert + \Vert \vec { w  } \Vert ^2 \\
&amp; = ( \Vert \vec { v  } \Vert + \Vert \vec { w  } \Vert ) ^2
\end{aligned}
\]</span></p>
<p>(9)的话,值得注意的是在左右两边对$ _i <span class="math inline">\(做内积其实并非完全一致的.做\)</span>( _i _ ) <span class="math inline">\(当然显然是正确的,做\)</span>( _ _i )
$的话,由于是Hermite形式,当然也是对的.</p>
<h5><span id="酉变换">酉变换</span></h5>
<p>复内积空间到自身的同构称为$V
$上的<strong>酉变换</strong>.容易类比实数情况,以下命题等价:</p>
<ol type="1">
<li><p>$T $是酉变换.</p></li>
<li><p>$T ^* = T ^{ - 1 } <span class="math inline">\(,特别地,取标准内积空间时,该条等价于\)</span>T ^= T
^{ - 1 } <span class="math inline">\(,如果\)</span>T
$是矩阵,我们称其是<strong>酉矩阵</strong>.</p></li>
<li><p>${ _1 , , _n } <span class="math inline">\(是一组单位正交基,则\)</span>{ T _1 , , T _n }
$也是一组单位正交基.</p></li>
</ol>
<h5><span id="正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</span></h5>
我们下面证明,只要$T <span class="math inline">\(是正规算子,那它就可以酉对角化.换言之\)</span>T
<span class="math inline">\(如果对应矩阵\)</span>A <span class="math inline">\(,那么存在酉矩阵\)</span>P <span class="math inline">\(满足\)</span>P ^= P ^{ - 1 } <span class="math inline">\(而且\)</span>P ^{ - 1 } AP =
<span class="math display">\[\begin{bmatrix}\lambda _1 &amp; &amp; \\
&amp; \ddots &amp; \\ &amp; &amp; \lambda _n \end{bmatrix}\]</span>
<span class="math inline">\(.容易见到其逆命题仍然成立,原因是\)</span>P
^{ - 1 } A ( A ^) P = P ^{ - 1 } ( A ^) AP =
<span class="math display">\[\begin{bmatrix}| \lambda _1 | ^2 &amp;
&amp; \\ &amp; \ddots &amp; \\ &amp; &amp; | \lambda _n | ^2
\end{bmatrix}\]</span>
<p>$.</p>
<p>接下来要证明该定理正命题成立,其证明策略有若干种,下面选取两种进行说明.</p>
<p>第一种策略是,照搬实数域上的情形对空间进行数学归纳.已经可以将一个正规算子分解为$T
= T ’ + T ’ ’ <span class="math inline">\(,其中\)</span>T ’ <span class="math inline">\(自伴而\)</span>T ’ ’ <span class="math inline">\(反自伴.那我们可以类比实数域上对其进行归纳,从而说明\)</span>T
’ , T ’ ’ <span class="math inline">\(均可以对角化.又因为当\)</span>T
<span class="math inline">\(正规的时候,\)</span>T ’ T ’ ’ = T ’ ’ T ’
$,于是满足同步对角化的条件.</p>
<p>第二种策略较为麻烦,但能揭示更多正规算子的性质.假设$N ( V )
$是正规算子,我们首先证明以下引理:</p>
<ol type="1">
<li><p>对于$f [ x ] <span class="math inline">\(,\)</span>f ( N ) ( V )
$也是正规的.</p></li>
<li><p>假设特征向量$ V <span class="math inline">\(使得\)</span> <span class="math inline">\(有\)</span>N = <span class="math inline">\(,则\)</span>N ^* = { } $.</p></li>
<li><p>若存在$k <span class="math inline">\(使得\)</span>N ^k = 0 <span class="math inline">\(,那么\)</span>N = 0 $.</p></li>
<li><p>对于其任意两个不同的特征子空间$V <em>, V </em><span class="math inline">\(,当\)</span><span class="math inline">\(的时候,\)</span>V <em>V </em>$.</p></li>
</ol>
<p>(1)的话,考虑$( a _i N ^i ) ^* = { a _i } ( N ^* ) ^i <span class="math inline">\(,其与任意\)</span>N $的多项式都交换.</p>
<p>(2)的话不妨直接取$M = N - I <span class="math inline">\(,根据(1)这当然仍是正规的.取\)</span>M ^* = N ^* -
{ } I <span class="math inline">\(,此时注意到\)</span>M <span class="math inline">\(就是\)</span>V _<span class="math inline">\(这个特征子空间,然而见到\)</span>( M ) = ( M ^* M )
= ( MM ^* ) = ( M ^* )
$,这就证毕了.当然这也意味着自伴算子的特征值一定都是实数,而反自伴算子的特征值一定都是纯虚数.</p>
<p>(3)考虑到$( N ^k ) ^* = ( N ^* ) ^k <span class="math inline">\(,于是\)</span>N <span class="math inline">\(的任意次幂都是正规的.既然如此,考虑\)</span>N ^* N
<span class="math inline">\(当然是自伴的.要证\)</span>N = 0 <span class="math inline">\(,只需证明\)</span>  N = 0 <span class="math inline">\(,只需证明\)</span>  ( N ^* N ) = 0 <span class="math inline">\(,也就只需要证明\)</span>N ^* N = 0 <span class="math inline">\(即可.而如果\)</span>N ^k = 0 <span class="math inline">\(,那么立刻有\)</span>( N ^* N ) ^k = 0 <span class="math inline">\(,因此我们对\)</span>N ^* N
$,也就是自伴情形证明上述结论即可.</p>
<p>于是接下来不妨假设$N <span class="math inline">\(自伴,其任意次幂都自伴.考虑\)</span>k = 1 <span class="math inline">\(显然成立,\)</span>k = 2 <span class="math inline">\(的时候,回忆到\)</span> , ( N N ) = ( N ^2 ) = 0
<span class="math inline">\(,因此立刻有\)</span>N = 0 $.</p>
<p>然后使用数学归纳,对于一般的$k &gt; 2 <span class="math inline">\(,如果\)</span>k <span class="math inline">\(是偶数,那\)</span>( N ^{ { 2 } } ) ^2 = N ^k = 0
<span class="math inline">\(意味着\)</span>N ^{ { 2 } } = 0 <span class="math inline">\(,可以数学归纳;当\)</span>k <span class="math inline">\(是奇数的时候,\)</span>N ^{ k + 1 } = 0 <span class="math inline">\(,而\)</span> { 2 } &lt; k
$,因此仍然可以数学归纳.</p>
<p>(4)只需要考虑(2),立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
\mu ( \vec { v  } \mid \vec { w  } ) &amp; = ( \vec { v  } \mid \mu \vec
{ w  } ) &amp; = ( \vec { v  } \mid N \vec { w  } ) \\
&amp; = ( N ^* \vec { v  } \mid \vec { w  } ) &amp; = ( \bar {
\lambda  } \vec { v  } \mid \vec { w  } ) &amp; = \lambda ( \vec { v  }
\mid \vec { w  } )
\end{aligned}
\]</span></p>
<p>于是完事.</p>
<p>有了以上引理,我们就可以来揭示正规算子可对角化的性质.</p>
<p>使用复数域上分裂的性质,将其特征多项式$ _T = ( x - _i ) ^{ a _i }
<span class="math inline">\(.取\)</span>m = ( x - _i ) <span class="math inline">\(,只要我们能说明\)</span>m <span class="math inline">\(就是极小多项式,由于其无重根则立即完事.那就只需要验证\)</span>m
( T ) = 0 <span class="math inline">\(,然而,\)</span>m ( T ) <span class="math inline">\(由于(1)是正规的,又因为\)</span>m ( T ) ^{ a _i } =
0 <span class="math inline">\(,用(3)立刻见到\)</span>m ( T ) = 0
$,再用(4)和Gram-Schmidt法得到正交基,这就证明了该结论.</p>
<p>回忆到实数域上可正交对角化当且仅当自伴,那是因为实数域上的反自伴性质很差.而复数域上二者差别不大,想要它们能够同步对角化就需要有交换性,而正规算子恰好保证了交换性.</p>
<p>但总之,我们由上可以立即见到以下结论成立,当$T $是正规算子的时候:</p>
<ol type="1">
<li><p>$T $自伴当且仅当所有特征值都是实数.</p></li>
<li><p>$T $反自伴当且仅当所有特征值都是纯虚数.</p></li>
<li><p>$T <span class="math inline">\(是酉变换当且仅当所有特征值都满足\)</span>| | = 1
$.</p></li>
</ol>
原因是自伴性质是$A ^= A <span class="math inline">\(,反自伴性质是\)</span>A ^= - A <span class="math inline">\(,酉变换性质是\)</span>A ^= A ^{ - 1 } <span class="math inline">\(.而只需选取单位正交基,立刻就发现\)</span>T <span class="math inline">\(对应的\)</span>A =
<span class="math display">\[\begin{bmatrix}\lambda _1 &amp; &amp; \\
&amp; \ddots &amp; \\ &amp; &amp; \lambda _n \end{bmatrix}\]</span>
<span class="math inline">\(,\)</span>T ^* <span class="math inline">\(对应的\)</span>A ^=
<span class="math display">\[\begin{bmatrix}\bar { \lambda  } _1 &amp;
&amp; \\ &amp; \ddots &amp; \\ &amp; &amp; \bar { \lambda  } _n
\end{bmatrix}\]</span>
<p>$.</p>
<h5><span id="相关实内积空间定理推广">相关实内积空间定理推广</span></h5>
<p>我们声明以下操作在复内积空间上都能做:</p>
<ol type="1">
<li><p>二次根:设$T ( V ) <span class="math inline">\(正定(半正定),那么存在唯一的\)</span>S ( V ) <span class="math inline">\(使得\)</span>S <span class="math inline">\(也正定(半正定),并且\)</span>S ^2 = T <span class="math inline">\(,将此\)</span>S <span class="math inline">\(记作\)</span> $.</p></li>
<li><p>极分解:设$T ( V ) <span class="math inline">\(可逆,则存在唯一一对\)</span>R , U ( V ) <span class="math inline">\(使得\)</span>R <span class="math inline">\(正定,\)</span>U <span class="math inline">\(是酉变换,而且\)</span>T = RU <span class="math inline">\(.具体地,\)</span>R = $.</p></li>
<li><p>奇异值分解:对于线性映射$T : V W <span class="math inline">\(,存在\)</span>V , W <span class="math inline">\(分别的一组正交基和唯一一组\)</span>_1 _p <span class="math inline">\(使得\)</span>T _i =</p>
<span class="math display">\[\begin{cases}\sigma _i \vec { w  } _i &amp;
1 \leq i \leq p \\ 0 &amp; i &gt; p \end{cases}\]</span>
<p><span class="math inline">\(.或者写作\)</span>A = Q P ^{ - 1 } <span class="math inline">\(,其中\)</span>=</p>
<span class="math display">\[\begin{bmatrix}\sigma _1 &amp; \\ &amp;
\ddots \end{bmatrix}\]</span>
<p>$.</p></li>
<li><p>MP广义逆:对于$T : V W <span class="math inline">\(,存在唯一的\)</span>S : W V <span class="math inline">\(,使得其满足从前的广义逆结论.特别地,这里的\)</span>S
$实际上可以用奇异值分解唯一刻画.</p></li>
</ol>
<h5><span id="复矩阵范数实例">复矩阵范数实例</span></h5>
<p>考虑$( A , B ) ( A B ) <em>{ HS } = ( ( A ^) B ) <span class="math inline">\(,立刻使得\)</span>M </em>{ m n } ( ) <span class="math inline">\(成为一个复内积空间.在此基础上定义**Hilbert-Schmidt范数**:\)</span>T
_{ HS } = $.</p>
<p>这里还可以展现$ <span class="math inline">\(在空间上的体现.回忆到\)</span>V <span class="math inline">\(上的内积结构\)</span> ( _ ) $</p>
<p>另外,还可以定义所谓<strong>算子范数</strong>为$T = _{ _V = 1 } T _W
$.应当容易验证:</p>
<ol type="1">
<li><p>$tT = | t | T $.</p></li>
<li><p>$T _1 + T _2 T _1 + T _2 $.</p></li>
<li><p>$T = 0 T = 0 $.</p></li>
<li><p>$ST S T $.</p></li>
<li><p>$I = 1 $.</p></li>
</ol>
<p>只需回忆极小化极大原理就知道$T ^2 <span class="math inline">\(取到了\)</span>T ^* T <span class="math inline">\(的模长最大的特征值,而\)</span>T _{ HS } ^2 <span class="math inline">\(取到了\)</span>T ^* T <span class="math inline">\(的特征值之和,考虑\)</span>T : V W $,见到:</p>
<p><span class="math display">\[
\frac { 1  } { \sqrt { \dim V  }  } \Vert T \Vert _{ HS  } \leq \Vert T
\Vert \leq \Vert T \Vert _{ HS  }
\]</span></p>
<p>综上,就可以定义两种距离,容易验证它们的若干性质.</p>
<p>因此容易见到上面两种范数有互相等价的收敛性和极限概念,柯西列的概念也是等价的.</p>
<h3><span id="模">模</span></h3>
<p>考虑将线性空间的定义从域挪到环上,对于一个环$R <span class="math inline">\(,定义**左模**为一个资料\)</span>M <span class="math inline">\(,其中\)</span>M <span class="math inline">\(自带一个加法群(需要可交换)而其还有一个对环的左乘\)</span>R
M M <span class="math inline">\(使得\)</span>x M , r _1 , r _2 R
$,以下性质成立:</p>
<ol type="1">
<li><p>$r ( x + y ) = rx + ry $.</p></li>
<li><p>$( r _1 + r _2 ) x = r _1 x + r _2 x $.</p></li>
<li><p>$( r _1 r _2 ) x = r _1 ( r _2 x ) $.</p></li>
<li><p>$1 _R x = x $.</p></li>
</ol>
<p>同理可以定义<strong>右模</strong>.这里可能又需要定义相反环$R ^{ op }
<span class="math inline">\(,相当于把乘法顺序调转.当\)</span>R <span class="math inline">\(是交换环的时候,\)</span>R = R ^{ op }
$,此时左模和右模无差别.下面无特殊说明默认为左模.</p>
<p>容易见到线性空间是模的特例.</p>
<p>还可以定义两个都定义在$R <span class="math inline">\(上的模\)</span>M
_1 , M _2 <span class="math inline">\(之间的同态\)</span>f : M _1 M _2
$满足:</p>
<ol type="1">
<li><p>$f ( rx ) = rf ( x ) $.</p></li>
<li><p>$f ( x _1 + x _2 ) = f ( x _1 ) + f ( x _2 ) $.</p></li>
</ol>
<p>容易见到$( f _1 + f _2 ) ( x ) = f _1 ( x ) + f _2 ( x ) <span class="math inline">\(成立并且\)</span>( f _1 + f _2 ) <span class="math inline">\(当然也是同态,然而\)</span>( rf ) ( x ) = rf ( x )
$并不一定是同态,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
rf ( r &#39; x ) &amp; = rf ( r &#39; x ) &amp; = rr &#39; f ( x ) \\
\ne r &#39; rf ( x ) &amp; = r &#39; ( rf ) ( x )
\end{aligned}
\]</span></p>
<p>因此并不一定能把里面的$r ’
$提到外面来,这就出问题了.模的同态集合并非是模.然而同态对复合操作总是构成幺半群,容易见到:</p>
<ol type="1">
<li><p>$( f _1 + f _2 ) g = ( f _1 g ) + ( f _2 g ) $.</p></li>
<li><p>$f ( g _1 + g _2 ) = ( f g _1 ) + ( f g _2 ) $.</p></li>
</ol>
<p>那也可以定义同构,就是存在逆映射.还可以定义子模.容易见到任何一组子模的交仍然是子模.</p>
<p>还可以定义商模.假设$N <span class="math inline">\(是\)</span>M <span class="math inline">\(的子模,在加法群意义下存在一个商群\)</span>M / N
<span class="math inline">\((原因是此加法群可交换),现在我们想将其升级为\)</span>R
<span class="math inline">\(的模.我们定义:\)</span>R ( M / N ) ( M / N )
: ( r , x + N ) rx + N $作为模上的标量乘法,我们试图证明:</p>
<ol type="1">
<li><p>此运算使得$M / N $成为模.</p></li>
<li><p>$q : M M / N <span class="math inline">\(构成模同态,而且\)</span>q = N $.</p></li>
</ol>
<p>(1)只需要简单检验即可(由于$N $对于标量乘法封闭显然).</p>
<p>(2)则是由于$q <span class="math inline">\(本身已经是加法群的同态,又有\)</span>q ( rx ) = rx
+ N = rq ( x ) $,这就搞定.</p>
<p>然后定义直积,考虑一组定义在$R <span class="math inline">\(上的模\)</span>( M <em>i ) </em>{ i I } <span class="math inline">\(,考虑它们本身都是一个加法群,因此先用加法群的定义拿到\)</span>_i
M _i <span class="math inline">\(,然后将它升级为一个\)</span>R <span class="math inline">\(模,方法是\)</span>( r , ( x <em>i ) </em>{ i I } )
( rx <em>i ) </em>{ i I } <span class="math inline">\(.同理把其至多有限多个分量非零的子集定义为直和.内直和亦然同理.设\)</span>(
M <em>i ) </em>{ i I } <span class="math inline">\(是\)</span>M
$的一组子模,以下命题等价:</p>
<ol type="1">
<li><p>$_{ i I } M _i = M <span class="math inline">\(,而且\)</span>i I
, M <em>i </em>{ j i } M _j = { 0 } $.</p></li>
<li><p>$x M <span class="math inline">\(都能唯一写作\)</span>x = _{ i I
} x _i $的形式.</p></li>
<li><p>$: _{ i I } M _i M $.</p></li>
</ol>
<p>验证上述命题是简单的.</p>
<p>最后,如果存在一个$M <span class="math inline">\(的子集\)</span>S
<span class="math inline">\(使得\)</span>M = S <span class="math inline">\(,我们称\)</span>M
$是<strong>有限生成</strong>的.</p>
<h4><span id="自由模">自由模</span></h4>
设$X <span class="math inline">\(为集合,其上的**自由模**定义为直和\)</span>R ^{ X }
<span class="math inline">\(,可以自然地将\)</span>X <span class="math inline">\(嵌入\)</span>R ^{ X } <span class="math inline">\(,只需将\)</span>x ( r _y ) <span class="math inline">\(,其中\)</span>r _y =
<span class="math display">\[\begin{cases}1 &amp; x = y \\ 0 &amp; x \ne
y \end{cases}\]</span>
<p>$.</p>
<p>对于任何一个$R <span class="math inline">\(上的模\)</span>N <span class="math inline">\(,我们可以将\)</span> _R ( R ^{ X } , N ) <span class="math inline">\(与\)</span>X N <span class="math inline">\(的映射一一对应.从前者对应到后者只需将映射限制在\)</span>X
<span class="math inline">\(上即可(上述已经给出将\)</span>X
$嵌入其中的策略),从后者到前者的对应只需逐分量映射亦可.</p>
<p>既然$X <span class="math inline">\(可以如上嵌入\)</span>R ^{ X }
<span class="math inline">\(,能否找到一个\)</span>R <span class="math inline">\(上的模\)</span>M <span class="math inline">\(,使得干脆使得\)</span>X M <span class="math inline">\(并且\)</span>M R ^{ X } <span class="math inline">\(呢.其实这里可以生添一个定义,假设\)</span>X M <span class="math inline">\(并且\)</span>M <span class="math inline">\(已经是\)</span>R $模,以下命题等价:</p>
<ol type="1">
<li><p>$X <span class="math inline">\(生成\)</span>M
$而且线性无关.</p></li>
<li><p>每个$m M <span class="math inline">\(都能唯一表示成有限和\)</span>m = _{ x X } r _x x
$.</p></li>
<li><p>$: R ^{ X } M $是同构.</p></li>
</ol>
<p>的确容易见到上面命题等价.此时称模$M <span class="math inline">\(是以\)</span>X
$为<strong>基</strong>的自由模.从而见到所有的向量空间其实都是自由模.并且只要我能找到一个模的一组基,那这个模自然成为了自由模.当然也存在非自由模,Example1给出了一个很平凡的非自由模实例.</p>
<p>回忆到线性空间上的基的定义,事实上当$R <span class="math inline">\(是交换环的时候,它的任意两组基\)</span>X , Y <span class="math inline">\(都满足\)</span>| X | = | Y | <span class="math inline">\(,从而自然地引出其**秩**为\)</span> ( M ) = | X |
$的定义.然而这个证明有点艰难,因此我们尝试去证明一个弱些的版本:整环上的有限生成自由模.</p>
<p>此时对于一组基$X <span class="math inline">\(,则\)</span>M R ^{ X }
<span class="math inline">\(.注意到如果\)</span>| X | = <span class="math inline">\(,则\)</span>R ^{ X } <span class="math inline">\(必然不是有限生成的.因此有限生成自由模的基一定满足\)</span>|
X | &lt; $.</p>
<p>而之后的做法只需将$R <span class="math inline">\(通过分式域\)</span>
( R ) $嵌入进向量空间就可以了.</p>
<p>我们还想要像线性空间一样,将$ <em>R ( R ^n , R ^m ) M </em>{ m n } ( R
) $,这里取右模是方便的(因为需要标量乘法),也就是:</p>
<p><span class="math display">\[
\begin{bmatrix}
x _1 \\
\vdots \\
x _n
\end{bmatrix} \mapsto A \begin{bmatrix}
x _1 \\
\vdots \\
x _n
\end{bmatrix}
\]</span></p>
<p>用右模的好处是标量乘法可以看作$1 $的矩阵乘法:</p>
<p><span class="math display">\[
\begin{bmatrix}
x _1 t \\
\vdots \\
x _n t
\end{bmatrix} \mapsto A \begin{bmatrix}
x _1 t \\
\vdots \\
x _n t
\end{bmatrix} = A \begin{bmatrix}
x _1 \\
\vdots \\
x _n
\end{bmatrix} t
\]</span></p>
<p>至于证明只需要化到基上即可.</p>
<h6><span id="example1非自由模">Example1(非自由模)</span></h6>
<p>取$R = , M = / n <span class="math inline">\(,其中\)</span>n , <span class="math inline">\(.此时立刻见到\)</span>M <span class="math inline">\(必定不是自由的,因为不存在一个\)</span>X <span class="math inline">\(使得\)</span>M ^{ X } <span class="math inline">\(,原因是左侧是有限的\)</span>n
$个元素,而右侧要么是单个元素,要么是无穷多元素.</p>
<h4><span id="线性映射和模结构">线性映射和模结构</span></h4>
<p>回忆到$F [ x ] <span class="math inline">\(是一个自然的\)</span>F
<span class="math inline">\(向量空间.我们的问题是如若\)</span>V <span class="math inline">\(是\)</span>F <span class="math inline">\(上的向量空间,能否将其升级为一个\)</span>F [ x ]
$上的模.</p>
<p>我们先指定一个$V <span class="math inline">\(上的线性变换\)</span>T (
V ) <span class="math inline">\(,考虑\)</span>f F [ x ] <span class="math inline">\(,\)</span>f ( T ) ( V ) <span class="math inline">\(,直接将其作用在\)</span>V <span class="math inline">\(上就得到了一个\)</span>F [ x ] <span class="math inline">\(上的模.换言之就是将\)</span>x v T ( v ) <span class="math inline">\(.我们现在想要证明所有可以使得\)</span>V <span class="math inline">\(升级为\)</span>F [ x ] <span class="math inline">\(模的办法,均可以转化为指定一个映射\)</span>T ( V )
$.</p>
<p>对此进行说明,将$F <span class="math inline">\(上的向量空间\)</span>V
<span class="math inline">\(升级为\)</span>F [ x ] <span class="math inline">\(上的模等价于说对所有\)</span>f F [ x ] <span class="math inline">\(指定对应于纯量乘法的映射\)</span>_f : V V
$,使得:</p>
<ol type="1">
<li><p>$_f ( v _1 + v _2 ) = _f ( v _1 ) + _f ( v _2 ) $.</p></li>
<li><p>$_{ f + g } ( v ) = _f ( v ) + _g ( v ) $.</p></li>
<li><p>$_{ fg } ( v ) = _f ( _g ( v ) ) $.</p></li>
<li><p>当$c F <span class="math inline">\(的时候,应该有\)</span>_c ( v )
= cv $,以保证原本的向量空间结构.</p></li>
</ol>
<p>容易检验当我们指定映射$T <span class="math inline">\(后的确能使其升级为\)</span>F [ x ] <span class="math inline">\(上的模.下面我们说明将\)</span>V <span class="math inline">\(升级为\)</span>F [ x ] <span class="math inline">\(上的模的过程一定对应了一个映射\)</span>T $.</p>
<p>假设$V <span class="math inline">\(已经升级为\)</span>F [ x ] <span class="math inline">\(模,那么考虑证明\)</span>_x <span class="math inline">\(必须是个线性变换即可.而由上面我们说的,\)</span>_x
( v _1 + v _2 ) = _x ( v _1 ) + _x ( v _2 ) <span class="math inline">\(,并且有\)</span><em>x ( cv ) = </em>{ xc } ( v ) =
c _x ( v ) $,这就搞定了.</p>
<p>而如果考虑模之间的映射$: V V ’ <span class="math inline">\(,则\)</span>$是模同态等价于:</p>
<ol type="1">
<li><p>$( c _1 v _1 + c _2 v _2 ) = c _1 ( v _1 ) + c _2 ( v _2 )
$.</p></li>
<li><p>$f ( T ) = f ( T ’ ) $.</p></li>
</ol>
<p>(1)使得$<span class="math inline">\(必须为一个线性映射,既然如此(2)中就可以拆开\)</span>f
( T ) <span class="math inline">\(,也就变成了要求\)</span>n <span class="math inline">\(,都有\)</span>( T ’ ) ^n = T ^n <span class="math inline">\(.容易见到只需满足\)</span>T ’ = T
$即可数学归纳满足上面的性质.乍一看可能觉得这个等式比较奇怪,但我们可以将其写作交换图表:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^\varphi \ar [d ] _T &amp; V &#39; \ar [d ] ^{ T
&#39;  } \\
V \ar [r ] _\varphi &amp; V &#39; \\
}
\]</span></p>
<p>如果$<span class="math inline">\(是同构,那这当然等价于\)</span>T ’ =
T ^{ - 1 } $.</p>
<p>我们现在想要做一些更深的操作,能不能干脆对所有$F [ x ] <span class="math inline">\(上的模结构\)</span>( V , T ) <span class="math inline">\(进行分类呢?不妨设\)</span>_F V = n &lt; <span class="math inline">\(,既然如此就有\)</span>V F ^n <span class="math inline">\(.既然如此指定\)</span>T <span class="math inline">\(无非是指定矩阵\)</span>F ^{ n n } <span class="math inline">\(,因此在同构意义下分类\)</span>F [ x ] <span class="math inline">\(上的模结构等价于分类共轭的\)</span>n n <span class="math inline">\(的矩阵.换言之分类共轭的\)</span>n n <span class="math inline">\(的矩阵也就相当于同构意义下分类\)</span>F [ x ]
<span class="math inline">\(上的模结构.回忆到\)</span>F [ x ] <span class="math inline">\(是PID(主理想环),而\)</span>V &lt; <span class="math inline">\(导出\)</span>V $是有限生成的.</p>
<h4><span id="主理想环上的有限生成模">主理想环上的有限生成模</span></h4>
<p>考虑$R <span class="math inline">\(是一个交换环,\)</span>I R <span class="math inline">\(是一个理想,考虑一个\)</span>R <span class="math inline">\(上的模\)</span>M <span class="math inline">\(,现在考虑定义\)</span>M [ I ] = { x M | a I , ax =
0 } <span class="math inline">\(为\)</span>I <span class="math inline">\(所零化的子模(容易检验封闭性).当\)</span>I = ( h )
= { hr | r R } <span class="math inline">\(的时候,我们记作\)</span>M [ I
] = M [ h ] <span class="math inline">\(,原因是显然此时只需要\)</span>h
<span class="math inline">\(零化即可.进一步地,留意到\)</span>M [ I ] =
_{ h I } M [ h ] $.</p>
<p>考虑当$R <span class="math inline">\(是整环的时候,如果\)</span>x M ,
h R { 0 } , x M [ h ] <span class="math inline">\(,我们称\)</span>x
$是一个<strong>挠元</strong>.容易见到自由模无挠.</p>
<p>接下来考虑所有挠元组成的集合称为<strong>挠子模</strong>$M _{ tors }
$,我们下面来证明它是一个子模.</p>
<p>如若$x , y M _{ tors } <span class="math inline">\(,则存在\)</span>r
, s R { 0 } <span class="math inline">\(,\)</span>rx = sy = 0 <span class="math inline">\(,由于此时我们在看整环,所以\)</span>rs <span class="math inline">\(.留神到:\)</span>rs ( ax + by ) = 0 , a , b R
$.于是就拿到了封闭性.</p>
<p>定义<strong>无挠商</strong>为$M <em>{ tf } = M / M </em>{ tors }
$.下面我们来证明其中的确没有挠元.</p>
<p>考虑${ x } M <em>{ tf } , { x } = x + M </em>{ tors } <span class="math inline">\(.如若\)</span>r R { 0 } <span class="math inline">\(使得\)</span>r { x } = 0 <span class="math inline">\(,意味着\)</span>rx + M <em>{ tors } = M </em>{
tors } <span class="math inline">\(,这意味着\)</span>rx M <em>{ tors }
<span class="math inline">\(,既如此则\)</span>s R { 0 } <span class="math inline">\(使得\)</span>s ( rx ) = ( sr ) x = 0 x M </em>{
tors } $,所以我们这个的确是无挠的.</p>
<p>接下来看$R <span class="math inline">\(是PID的情形,此时考虑任何一个\)</span>t <span class="math inline">\(都可以被分解为\)</span>t p _1 ^{ a _1 } p _m ^{ a
_m } , a <em>i <span class="math inline">\(.我们下面来证明此时\)</span>M
[ t ] = </em>{ i = 1 } ^m M [ p _i ^{ a _i } ] $.</p>
<p>其实只需要证明$t = ab <span class="math inline">\(,其中\)</span>a , b
<span class="math inline">\(互素就可以推出\)</span>M [ t ] = M [ a ] M [
b ] $就行了对吧.和我们之前证明极小多项式的结论时的策略完全一致:</p>
<p>先证明$M [ t ] = M [ a ] + M [ b ] <span class="math inline">\(,考虑\)</span>x M [ t ] <span class="math inline">\(,留意到存在\)</span>u , v <span class="math inline">\(使得\)</span>au + bv = 1 <span class="math inline">\(,所以\)</span>x t <span class="math inline">\(,\)</span>x = aux + bvx M [ b ] + M [ a ] $.</p>
<p>在证明$M [ a ] M [ b ] = { 0 } <span class="math inline">\(,设\)</span>x M [ a ] M [ b ] <span class="math inline">\(,则\)</span>x = aux + bvx = 0 $.</p>
<p>接下来我们证明$M [ a ] M [ b ] = M [ ( a , b ) ] <span class="math inline">\(.裴蜀定理告诉我们存在一对\)</span>u , v <span class="math inline">\(使得\)</span>( a , b ) = au + bv <span class="math inline">\(,因此\)</span>M [ ( a , b ) ] M [ a ] M [ b ]
<span class="math inline">\(,反之如若\)</span>x M [ ( a , b ) ] <span class="math inline">\(,则\)</span>x M [ a ] , x M [ b ]
$,这就搞定了.</p>
<p>接下来考虑$p <span class="math inline">\(是PID里的一个素元,容易见到\)</span>M [ p ] M [ p
^2 ] <span class="math inline">\(,定义\)</span>M [ p ^] = <em>{ i } M [
p ^i ] <span class="math inline">\(.如果\)</span>t R , t , M = M [ t ]
<span class="math inline">\(.此时考虑对\)</span>t <span class="math inline">\(作分解,应该得到\)</span>M = M [ p _i ^{ a _i } ]
<span class="math inline">\(.事实上此时我们可以直接说\)</span>M = </em>{
p } M [ p ^] <span class="math inline">\(,原因是考虑当\)</span>n p ^{ a
_p } <span class="math inline">\(时候,有\)</span>M [ p ^n ] = M [ p ^n ]
M [ t ] = M [ p ^{ a _p } ] $.</p>
<p>下面干脆假设$M = R / ( t ) <span class="math inline">\(,\)</span>p
<span class="math inline">\(是\)</span>R $中的素元,我们有以下结论:</p>
<ol type="1">
<li><p>如果$p ^a | t <span class="math inline">\(,则\)</span>( R / ( t )
) [ p ^a ] R / ( p ^a ) $.</p></li>
<li><p>如果$p ^a | t , p ^{ a + 1 } t <span class="math inline">\(,则\)</span>( R / ( t ) ) [ p ^] R / ( p ^a )
$.</p></li>
</ol>
<p>对于(1),如若$p ^a | t <span class="math inline">\(,考虑\)</span>{ x }
= x + ( t ) R / ( t ) <span class="math inline">\(,如若满足\)</span>p ^a
{ x } = 0 y , p ^a x = ty <span class="math inline">\(,此时取\)</span>s
= { p ^a } <span class="math inline">\(,于是上述条件立刻等价于\)</span>x
( s ) <span class="math inline">\(.所以\)</span>( R / ( t ) ) [ p ^a ] =
( s ) / ( t ) <span class="math inline">\(.然而我们有一个满射\)</span>R
( s ) / ( t ) : y sy + ( t ) <span class="math inline">\(,观察其\)</span>= { y R : t | sy } = ( p ^a )
<span class="math inline">\(,由同态定理知道\)</span>( R / ( t ) ) [ p ^a
] R / ( p ^a ) $.</p>
<p>对于(2),我们已经说过了$M [ p ^] = M [ p ^a ] $,于是由(1)就做完了.</p>
<h5><span id="自由模与其子模">自由模与其子模</span></h5>
<p>回忆到Noether性质:任何一个理想链最终都会稳定.那同理可以定义一个$R
<span class="math inline">\(上的模\)</span>M <span class="math inline">\(是有Noether性质的,当它的任何一个子模链都会趋于稳定.回忆到如果\)</span>R
$是一个PID,则它当然有Noether性质,同时它作为自己的模也具有Noether性质(它的子模其实就是子理想).</p>
<p>下面我们来证明,如果一个模$M $具有Noether性质,那它是有限生成的.</p>
<p>证明非常简单,考虑反证,如果其不是有限生成的,那我们考虑任意$x _1 <span class="math inline">\(,\)</span>Rx _1 <span class="math inline">\(不能生成\)</span>M <span class="math inline">\(,取\)</span>x _2 M ( Rx _1 ) <span class="math inline">\(,则\)</span>Rx _1 + Rx _2 <span class="math inline">\(也不能生成\)</span>M
$,以此类推,这就得到了一个无穷增大的子模链,不符合Noether性质.</p>
<p>接下来引入一个引理:设$R <span class="math inline">\(是一个交换环,\)</span>M <span class="math inline">\(是\)</span>R <span class="math inline">\(上的一个模,而且\)</span>M ’ <span class="math inline">\(是\)</span>M <span class="math inline">\(的一个子模,如果\)</span>M ’ ’ = M / M ’ <span class="math inline">\(,那么\)</span>M <span class="math inline">\(有Noether性质等价于\)</span>M ’ <span class="math inline">\(和\)</span>M ’ ’ $都有Noether性质.</p>
<p>先来看必要性,假设$M <span class="math inline">\(有Noether性质,则其子模\)</span>M ’ <span class="math inline">\(的子模列当然也是\)</span>M <span class="math inline">\(中的子模列,所以\)</span>M ’ <span class="math inline">\(必定有Noether性质.而反之\)</span>M ’ ’ <span class="math inline">\(中的子模列当然可以取原像回到\)</span>M
$中,必定也是Noetherian的.</p>
<p>再来看充分性,考虑$M <span class="math inline">\(中的一列子模\)</span>M _1 M _2 <span class="math inline">\(.取\)</span>M _i ’ = M _i M ’ <span class="math inline">\(,\)</span>M _i ’ ’ = ( M _i + M ’ ) / M ’ <span class="math inline">\(.它们当然分别是\)</span>M ’ <span class="math inline">\(和\)</span>M ’ ’ <span class="math inline">\(中的子模列,所以存在一个\)</span>i _0 , i i _0
<span class="math inline">\(,\)</span>M <em>i ’ = M </em>{ i + 1 } ’ , M
<em>i ’ ’ = M </em>{ i + 1 } ’ ’ <span class="math inline">\(.下面我们试图证明当\)</span>i i _0 <span class="math inline">\(的时候此时也有\)</span>M <em>i = M </em>{ i + 1 }
<span class="math inline">\(,这只需证明\)</span>M <em>i M </em>{ i + 1 }
$.</p>
<p>考虑$x M <em>{ i + 1 } , x + M ’ M </em>{ i + 1 } ’ ’ = M <em>i ’ ’
<span class="math inline">\(,从而我们知道一定存在一个\)</span>y M <em>i
<span class="math inline">\(使得\)</span>x + M ’ = y + M ’ <span class="math inline">\(,意味着\)</span>x - y M ’ <span class="math inline">\(,而\)</span>x M </em>{ i } M </em>{ i + 1 } <span class="math inline">\(,所以\)</span>x - y M ’ M <em>{ i + 1 } = M </em>{
i + 1 } ’ = M _i ’ M _i <span class="math inline">\(,由于\)</span>y M _i
<span class="math inline">\(,自然导出\)</span>x M _i $.从而证毕.</p>
<p>其实用第二同构定理见到$M _i ’ ’ M _i / M _i ’ $也就搞定了.</p>
<p>现在我们有了如上引理,我们可以得知以下推论:</p>
<ol type="1">
<li><p>如果$M _1 , M _2 <span class="math inline">\(都是Noether模,则\)</span>M _1 M _2
$也是Noether模.</p></li>
<li><p>作为(1)的推论,如果$R <span class="math inline">\(是一个PID,\)</span>E <span class="math inline">\(是一个\)</span>R <span class="math inline">\(上的自由模,如果\)</span>E <span class="math inline">\(是有限生成的,则\)</span>E $是Noether模.</p></li>
<li><p>作为(2)的推论,有限生成自由模的子模总是有限生成的.</p></li>
</ol>
<h5><span id="smith标准型">Smith标准型</span></h5>
<p>最后要做的是在模上引入矩阵符号,对于交换环$R <span class="math inline">\(上的模\)</span>M <span class="math inline">\(,假设\)</span>e _1 , , e _n M <span class="math inline">\(且\)</span>x _1 , , x <em>m M <span class="math inline">\(,取矩阵\)</span>A M </em>{ n m } ( R ) <span class="math inline">\(,此时记\)</span>( x _1 , , x _m ) = ( e _1 , , e
_n ) A <span class="math inline">\(,当且仅当\)</span>x <em>j = </em>{ i
= 1 } ^n e <em>i a </em>{ i , j } $.容易检查以下结论:</p>
<ol type="1">
<li><p>$( e _1 , , e _n ) AB = ( e _1 , , e _n ) ( AB ) $.</p></li>
<li><p>$( e _1 , , e _n ) I = ( e _1 , , e _n ) $.</p></li>
<li><p>如果$e _1 , , e _n <span class="math inline">\(线性无关,则\)</span>A $若存在则唯一确定.</p></li>
</ol>
<p>同时Cramer法则告诉我们,当$A R ^<span class="math inline">\(的时候,\)</span>A <span class="math inline">\(一定存在逆矩阵\)</span>B <span class="math inline">\(使得\)</span>AB = BA = I <span class="math inline">\(,这也很显然是\)</span>A <span class="math inline">\(存在逆矩阵的充要条件,因为\)</span>B = { A }
$.还可以检查如下结论:</p>
<ol type="1">
<li><p>如果$( y _1 ’ , , y _n ’ ) = ( y _1 , , y _n ) P <span class="math inline">\(,其中\)</span>P <span class="math inline">\(可逆,则\)</span>Ry _i = R y _i ’ $.</p></li>
<li><p>设$( e _1 , , e _n ) <span class="math inline">\(为基,则\)</span>( e _1 ’ , , e _n ’ ) = ( e _1 , ,
e _n ) A <span class="math inline">\(是另一组基,当且仅当\)</span>A
$可逆.</p></li>
</ol>
<p>现在考虑自由模$E <span class="math inline">\(,其基为\)</span>e _1 , ,
e _n <span class="math inline">\(,其有一个子模\)</span>N <span class="math inline">\(,可以被\)</span>x _1 , , x _m <span class="math inline">\(生成.考虑取一个唯一的矩阵\)</span>A <span class="math inline">\(满足\)</span>( x _1 , , x _m ) = ( e _1 , , e _m )
A <span class="math inline">\(,此时发现如果将\)</span>A <span class="math inline">\(换成\)</span>AP <span class="math inline">\(,其中\)</span>P <span class="math inline">\(是一个可逆矩阵,则\)</span>( x _1 , , x _m ) <span class="math inline">\(会被改变.如果将\)</span>A <span class="math inline">\(换成\)</span>QA <span class="math inline">\(,则\)</span>( e _1 , , e _n ) $会被改变.</p>
由此我们有<strong>Smith标准型</strong>:当$R <span class="math inline">\(是PID的时候,对于矩阵\)</span>A M _{ n m } <span class="math inline">\(,总存在两个可逆矩阵\)</span>P , Q <span class="math inline">\(,使得\)</span>d _1 | d _2 | R <span class="math inline">\(使得\)</span>A = Q
<span class="math display">\[\begin{bmatrix}d _1 &amp; &amp; \\ &amp; d
_2 &amp; \\ &amp; &amp; \ddots \end{bmatrix}\]</span>
<p>P $.</p>
<p>上述结论对欧几里得整环是平凡结论,而且还可以计算.</p>
<p>那么对于PID怎么办呢?难点当然在于现在我们没有办法任意做欧几里得算法了,也许唯一的工具只有裴蜀定理.</p>
<p>考虑数学归纳,如果$A = 0 <span class="math inline">\(那当然已经搞定了对吧,否则我们总可以做点初等变换使得\)</span>A
$的左上角元素不为$0 $.</p>
<p>现在假设第一列第一行元素为$a <span class="math inline">\(,第一列第二行元素为\)</span>b <span class="math inline">\(,取\)</span>d = ( a , b ) , u = - { d } , v = { d
} <span class="math inline">\(,用裴蜀定理拿到\)</span>sa + tb = d
$,然后用下述矩阵左乘:</p>
<p><span class="math display">\[
\begin{bmatrix}
s &amp; t &amp; &amp; &amp; \\
u &amp; v &amp; &amp; &amp; \\
&amp; &amp; 1 &amp; &amp; \\
&amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; &amp; &amp; 1
\end{bmatrix}
\]</span></p>
<p>就可以让第一列第二行的元素变成$0 $.不断做此过程,矩阵变为:</p>
<p><span class="math display">\[
\begin{bmatrix}
d _1 &#39; &amp; \\
&amp; A _1
\end{bmatrix}
\]</span></p>
<p>其中$d _1 ’ <span class="math inline">\(是\)</span>A <span class="math inline">\(的第一行第一列所有元素的\)</span>$,继续做此操作得到:</p>
<p><span class="math display">\[
\begin{bmatrix}
d _1 &#39; &amp; &amp; \\
&amp; d _2 &#39; &amp; \\
&amp; &amp; A _1
\end{bmatrix}
\]</span></p>
<p>如果$d _1 ’ d _2 ’ <span class="math inline">\(,那我们就把第二列加到第一列上,然后重复以上操作,从而使得左上角变成\)</span>(
d _1 ’ , d _2 ’ ) $.这样我们就搞定了.</p>
<h5><span id="结构定理">结构定理</span></h5>
<p>扔出一个<strong>结构定理</strong>:$R <span class="math inline">\(是一个PID,\)</span>M <span class="math inline">\(是一个\)</span>R <span class="math inline">\(模,我们都可以将\)</span>M $拆成:</p>
<p><span class="math display">\[
M \cong ( R / I _1 ) \oplus \cdots \oplus ( R / I _k ) \oplus E
\]</span></p>
<p>其中$I _1 I _k { 0 } <span class="math inline">\(是\)</span>R <span class="math inline">\(上的一列真理想,而\)</span>E <span class="math inline">\(是一个\)</span>R $上的自由模.</p>
<p>并且上述拆法是有唯一性的,也就是如果还存在另一组拆法:</p>
<p><span class="math display">\[
M \cong ( R / J _1 ) \oplus \cdots \oplus ( R / J _{ k &#39;  } ) \oplus
E &#39;
\]</span></p>
<p>则$k = k ’ , I _1 = J _1 , , I <em>k = J </em>{ k ’ } , E E ’ $.</p>
<p>回忆到$E <span class="math inline">\(既然是整环上的有限生成自由模,那它可以同构于\)</span>R
^{ rk ( E ) } <span class="math inline">\(.因此我们可以在上述一列理想后面补\)</span> ( E )
<span class="math inline">\(个\)</span>{ 0 } $.这样就可以简写作:</p>
<p><span class="math display">\[
M \cong ( R / I _1 ) \oplus \cdots \oplus ( R / I _k )
\]</span></p>
<p>这组$I _1 I _k { 0 } <span class="math inline">\(被称为\)</span>M
$的一组<strong>不变因子</strong>.</p>
<p>此时我们回忆到PID中的自由模不能有挠元,而前面商掉的部分全是挠元,因此结构定理会给出$(
R / I _1 ) ( R / I <em>k ) M </em>{ tors } = M [ I _k ] = M [ f _k ]
$.</p>
<p>其实这也可以写成结构定理的第二种形式:</p>
<p><span class="math display">\[
M _{ tors  } \cong \bigoplus _p M _{ tors  } [ p ^\infty ] \cong
\bigoplus _{ p | f _k , p \in \mathrm { prime  }  } \bigoplus _i R / ( p
^{ b _i ( p )  } )
\]</span></p>
<p>其中$p , 0 b _1 ( p ) b _k ( p )
$.我们将这一列称为<strong>初等因子</strong>.</p>
<p>现在我们着手证明结构定理,首先给出如下引理:</p>
<p>设$E <span class="math inline">\(为主理想环\)</span>R <span class="math inline">\(上的自由模,秩为\)</span>n <span class="math inline">\(,而\)</span>N <span class="math inline">\(是其子模,我们下面证明存在\)</span>E <span class="math inline">\(的一组基\)</span>f _1 , , f _n <span class="math inline">\(以及\)</span>R <span class="math inline">\(的一列元素\)</span>d _1 | | d _n <span class="math inline">\(,令\)</span>r = { i | d _i } <span class="math inline">\(,则\)</span>d _1 f _1 , , d _r f _r <span class="math inline">\(构成\)</span>N $的基.</p>
<p>回忆到自由模的子模一定是有限生成的而且秩不超过$n <span class="math inline">\(,此时取\)</span>x _1 , , x _m <span class="math inline">\(是\)</span>N <span class="math inline">\(的一组生成元,则存在一个唯一的\)</span>A <span class="math inline">\(使得\)</span>( x _1 , , x _m ) = ( e _1 , , e _n )
A $,由Smith标准型,式子变成:</p>
<p><span class="math display">\[
( x _1 , \cdots , x _m ) P ^{ - 1  } = ( e _1 , \cdots , e _n ) Q
\begin{bmatrix}
d _1 &amp; &amp; \\
&amp; d _2 &amp; \\
&amp; &amp; \ddots
\end{bmatrix}
\]</span></p>
<p>此时观察左侧的确给出了一组$N <span class="math inline">\(的一组生成元,而右侧的\)</span>( e _1 , , e _n ) Q
<span class="math inline">\(给出了另一组基\)</span>( f _1 , , f _n )
$.这就完事了.</p>
<p>此时我们有了如上引理,来证明结构定理的存在性.对于有限生成模$M <span class="math inline">\(,由定义知道存在一组元素\)</span>x _1 , , x <em>n =
M <span class="math inline">\(.既然如此考虑取\)</span>E = R ^{ n } <span class="math inline">\(,考虑模同态\)</span>E M , ( r <em>i ) </em>{ i = 1
} ^n </em>{ i = 1 } ^n r _i x _i <span class="math inline">\(,容易见到这显然是个满同态,因此取其\)</span>= N
<span class="math inline">\(,自然有\)</span>M E / N <span class="math inline">\(.根据引理,可以拿到\)</span>N <span class="math inline">\(的一组基\)</span>d _1 f _1 , , d _r f _r
$,此时见到:</p>
<p><span class="math display">\[
M \cong \cfrac { Rf _1 \oplus \cdots \oplus R f _n  } { Rd _1 f _1
\oplus \cdots Rd _r f _r  }
\]</span></p>
<p>然而对于单个的$f _n <span class="math inline">\(来说,自然有\)</span>Rf _n R <span class="math inline">\(,而且如果\)</span>N _1 <span class="math inline">\(是\)</span>M _1 <span class="math inline">\(的子模,\)</span>N _2 <span class="math inline">\(是\)</span>M _2 <span class="math inline">\(的子模,并且\)</span>M _1 M _2 = { 0 } <span class="math inline">\(,容易检验\)</span>( M _1 M _2 ) / ( N _1 N _2 ) (
M _1 / N _1 ) ( M _2 / N _2 ) <span class="math inline">\(,而\)</span>(
Rf _i ) / ( Rd _i f _i ) R / ( d _i ) $,这就搞定了存在性的部分.</p>
<p>接下来来证明唯一性,假设:</p>
<p><span class="math display">\[
M \cong ( R / I _1 ) \oplus \cdots \oplus ( R / I _k ) \oplus E \cong (
R / J _1 ) \oplus \cdots \oplus ( R / J _{ k &#39;  } ) \oplus E &#39;
\]</span></p>
<p>然而我们已经知道$E M <em>{ tf } <span class="math inline">\(而且\)</span>E ’ M </em>{ tf } <span class="math inline">\(,因此有\)</span>E E ’ <span class="math inline">\(.因此我们将问题化约到没有自由部分的特例.于此使用初等因子形式的证明,考虑\)</span>M
[ p ^] <span class="math inline">\(自然是其中所有的\)</span>R / ( p ^j )
$结构,因此必然只涉及它们的部分会同构,此时化约到已知为:</p>
<p><span class="math display">\[
R / ( p ^{ b _1  } ) \oplus \cdots \oplus R / ( p ^{ b _k  } ) \cong R /
( p ^{ b _1 &#39;  } ) \oplus \cdots \oplus R / ( p ^{ b _{ k &#39;  }
&#39;  } )
\]</span></p>
<p>为证明这些项对应相同,需要将这些东西等同于某种空间上的结构,我们先来着手证明$k
= k ’ <span class="math inline">\(.回忆到\)</span>M [ p ] = <em>{ i } (
R / ( p ^{ b <em>i } ) ) [ p ] = </em>{ i } R / ( p ) <span class="math inline">\(,此时见到\)</span>M [ p ] <span class="math inline">\(实际上也可以表示为\)</span>R / ( p ) <span class="math inline">\(上的向量空间(回忆到主理想环商掉素理想后得到了一个域),而且\)</span></em>{
R / ( p ) } M [ p ] = k <span class="math inline">\(,因此必然有\)</span>k = k ’ $.</p>
<p>类似上面,考虑对于一个固定的$a <span class="math inline">\(,考察\)</span>p ^c M = _{ i , b _i &gt; c } p ^c R
/ p ^{ b <em>i } R = </em>{ i , b _i &gt; c } R / p ^{ b _i - c } R
<span class="math inline">\(,此时观察\)</span>( p ^c M ) [ p ] <span class="math inline">\(,它的维度就是满足\)</span>b _i &gt; c <span class="math inline">\(的\)</span>i $的个数,即可继续见到两遍逐个相同.</p>
<h5><span id="有限生成交换群的分类">有限生成交换群的分类</span></h5>
<p>我们先将交换群$A <span class="math inline">\(等同于\)</span> <span class="math inline">\(上的模.下述用加法群,则上面有自然的倍数运算\)</span>
A A : na a + a + + a <span class="math inline">\(.因此交换群立刻等价于\)</span> $模.</p>
<p>然而模上的结构定理立刻给出:</p>
<p><span class="math display">\[
A \cong \mathbb { Z  } / d _1 \mathbb { Z  } \oplus \cdots \oplus
\mathbb { Z  } / d _k \mathbb { Z  } \oplus \mathbb { Z  } ^{ \oplus
m  }
\]</span></p>
<p>其中$d _1 | | d _k $,这就搞定.</p>
<h4><span id="有理标准型">有理标准型</span></h4>
<p>取定$R = F [ x ] <span class="math inline">\(,我们可以将一个真理想写作\)</span>I _i = ( f _i )
<span class="math inline">\(,其中\)</span>f _i F [ x ] F <span class="math inline">\(,并且如果进一步要求其首项为一则\)</span>f _i
$唯一.</p>
<p>现在来看对于一个固定的多项式$f <span class="math inline">\(,此时\)</span>F [ x ] / ( f ) <span class="math inline">\(必然也是一个\)</span>F [ x ] <span class="math inline">\(模,那在上面的\)</span>x <span class="math inline">\(必然也对应了一个矩阵,设\)</span>f = n , f = x ^n +
c _{ n - 1 } x ^{ n - 1 } + + c _0 <span class="math inline">\(,取其有序基为\)</span>{ 1 + ( f ) , x + ( f ) , ,
x ^{ n - 1 } + ( f ) } <span class="math inline">\(.容易见到\)</span>x
$对应的矩阵应该形如:</p>
$$ C _f =
<span class="math display">\[\begin{bmatrix}
0 &amp; 0 &amp; \cdots &amp; 0 &amp; - c _0 \\
1 &amp; 0 &amp; \cdots &amp; 0 &amp; - c _1 \\
0 &amp; 1 &amp; \cdots &amp; 0 &amp; - c _2 \\
\vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1 &amp; - c _{ n - 1  } \\

\end{bmatrix}\]</span>
<p>$$</p>
<p>这个被称为<strong>友矩阵</strong>.按照最后一列展开见到其特征多项式就是$f
$.</p>
<p>结构定理告诉我们,对于上述的一个模(我们之前说过可以唯一对应一个矩阵$A
<span class="math inline">\(),可以找到唯一的一组首项为一的多项式\)</span>f _1
| | f _k , k <span class="math inline">\(,其中\)</span>f _i = n <span class="math inline">\(,则\)</span>A
$可以对应于它们所对应的友矩阵所构成的分块对角矩阵,称为<strong>有理标准型</strong>.</p>
<p>上述的具体细节是次数相关的讨论.对于$A <span class="math inline">\(对应的\)</span>F [ x ] <span class="math inline">\(上的模\)</span>M
$,我们之前已经用结构定理搞定说:</p>
<p><span class="math display">\[
M \cong F [ x ] / ( f _1 ) \oplus \cdots \oplus F [ x ] / ( f _k )
\oplus E
\]</span></p>
<p>然而回忆到$_F M = n , _F F [ x ] = + <span class="math inline">\(,所以必然有\)</span>E = { 0 } <span class="math inline">\(.既然如此\)</span>_F ( F [ x ] / ( f _i ) ) = f _i
= n $.</p>
<p>有理标准型的强大之处在于蕴含了我们之前讲过的很多事情,并且给出了更加简单的描述:我们下面证明:</p>
<ol type="1">
<li><p>极小多项式有$ _A = f _k $.</p></li>
<li><p>特征多项式有$ <em>A = </em>{ i = 1 } ^k f _i $.</p></li>
</ol>
<p>先证明(1):如果多项式$h <span class="math inline">\(满足\)</span>h ( A
) = 0 <span class="math inline">\(,由于我们此时已经将\)</span>A <span class="math inline">\(的作用等价于\)</span>x <span class="math inline">\(的作用,因此\)</span>h ( x )
$必然作用于每个商模上都是$0 <span class="math inline">\(,那就必然意味着\)</span>i , f _i | h f _k | h
$.</p>
<p>再证明(2):首先我们知道友矩阵的特征多项式满足$ _{ C _f } = f
$,此时发现证完了,因为直和直接就是每一分模的特征多项式乘积.</p>
<p>回忆到结构定理存在第二种表示方法,我们考虑将$ _A = f _k = p _1 ^{ a _1
} p _k ^{ a _k } <span class="math inline">\(,那我们就可以将\)</span>A
<span class="math inline">\(同构于若干分块对角矩阵\)</span>A _1 , , A _m
<span class="math inline">\(组成的分块对角矩阵,其中每一个\)</span>A
<em>i <span class="math inline">\(亦然可以分解为若干友矩阵\)</span>C
</em>{ p _j ^{ b } } $之类的东西.</p>
<p>接下来看如何计算一个有理标准型,考虑$V <span class="math inline">\(是一个\)</span>F <span class="math inline">\(向量空间,而\)</span>T ( V ) <span class="math inline">\(,从而使得\)</span>V <span class="math inline">\(从一个\)</span>F <span class="math inline">\(向量空间升级为一个\)</span>F [ x ] $模.</p>
<p>如果我们能拿到一个满射$: F [ x ] ^{ n } V <span class="math inline">\(,那考虑\)</span><span class="math inline">\(当然是\)</span>F [ x ] ^{ n } <span class="math inline">\(的一个子模,既然如此,存在\)</span>F [ x ] ^{ n }
<span class="math inline">\(的一组基\)</span>f _1 , , f _n <span class="math inline">\(,以及一组非零多项式\)</span>d _1 | | d _n <span class="math inline">\(,使得\)</span>= _i F [ x ] d _i f _i <span class="math inline">\(,从而使得\)</span>V _i F [ x ] / ( d _i ) $.</p>
<p>策略当然是简单的,考虑$F [ x ] ^{ n } <span class="math inline">\(的一组基\)</span>e _1 , , e _n <span class="math inline">\(,以及\)</span>V <span class="math inline">\(作为向量空间的一组基\)</span>v _1 , , v _n <span class="math inline">\(,我们要求\)</span>( e _i ) = v _i , ( x ) = T
<span class="math inline">\(,从而\)</span>( _i r _i e _i ) = _i r _i ( T
) v _i <span class="math inline">\(,立刻见到这的确是满射,疑问只在于如何求其\)</span>$.</p>
<p>定义$y <em>j = xe <em>j - </em>{ i = 1 } ^n a </em>{ i , j } e <em>i
<span class="math inline">\(.取\)</span>N = </em>{ j = 1 } ^n F [ x ] y
<em>j <span class="math inline">\(,其中\)</span>a </em>{ i , j } <span class="math inline">\(是\)</span>T <span class="math inline">\(再这组基下对应的矩阵元素.此时立刻见到\)</span>( y
<em>j ) = Tv <em>j - </em>{ i } a </em>{ i , j } v _i = 0 <span class="math inline">\(,因此\)</span>N $.</p>
<p>反之,观察到$xe _j = <em>i a </em>{ i , j } e _i + y _j <em>i a </em>{
i , j } e <em>i + N <span class="math inline">\(,反复做此操作,得知\)</span>w F [ x ] ^{ n } , w
</em>{ i } c _i e _i + N <span class="math inline">\(,于此做\)</span><span class="math inline">\(得到\)</span>( w ) = 0 _i c _i v _i = 0 <span class="math inline">\(,从而得知所有的\)</span>c _i = 0 <span class="math inline">\(.这就证明了\)</span>= N $.</p>
观察到$( x _1 , , x _n ) = ( e _1 , , e _n ) ( xI - A ) <span class="math inline">\(,而\)</span>( xI - A ) <span class="math inline">\(的确是一个定义在\)</span>F [ x ] <span class="math inline">\(上的矩阵,对此用Smith标准型得到\)</span>( e _1 , ,
e _n ) Q
<span class="math display">\[\begin{bmatrix}d _1 &amp; &amp; \\ &amp;
\ddots &amp; \\ &amp; &amp; d _n \end{bmatrix}\]</span>
<p>P $,这就搞定了.</p>
<h6><span id="example1">Example1</span></h6>
考虑$V = F ^3 <span class="math inline">\(,\)</span>T = A =
<span class="math display">\[\begin{bmatrix}- 1 &amp; - 2 &amp; 6 \\ - 1
&amp; 0 &amp; 3 \\ - 1 &amp; - 1 &amp; 4 \end{bmatrix}\]</span>
<p>$.</p>
<p>首先要做的是计算$xI - A $,对此:</p>
$$
<span class="math display">\[\begin{aligned}
xI - A &amp; = \begin{bmatrix}
x + 1 &amp; 2 &amp; - 6 \\
1 &amp; x &amp; - 3 \\
1 &amp; 1 &amp; x - 4
\end{bmatrix} \\
\to \begin{bmatrix}
0 &amp; - x + 1 &amp; - x ^2 + 3 x - 2 \\
0 &amp; x - 1 &amp; - x + 1 \\
1 &amp; 1 &amp; x - 4
\end{bmatrix} \\
\to \begin{bmatrix}
1 &amp; 1 &amp; x - 4 \\
0 &amp; x - 1 &amp; - x + 1 \\
0 &amp; - x + 1 &amp; - ( x - 1 ) ( x - 2 )
\end{bmatrix} \\
\to \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; x - 1 &amp; - x + 1 \\
0 &amp; - x + 1 &amp; - ( x - 1 ) ( x - 2 )
\end{bmatrix} \\
\to \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; x - 1 &amp; - x + 1 \\
0 &amp; 0 &amp; - ( x - 1 ) ^2
\end{bmatrix} \\
\to \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; x - 1 &amp; 0 \\
0 &amp; 0 &amp; - ( x - 1 ) ^2
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
这样我们就得到了不变因子,得到$T
<span class="math display">\[\begin{bmatrix}1 &amp; &amp; \\ &amp; 0
&amp; - 1 \\ &amp; 1 &amp; 2 \end{bmatrix}\]</span>
<p>$.</p>
<h4><span id="jordan标准型">Jordan标准型</span></h4>
<p>对环上元素$r R <span class="math inline">\(,如果\)</span>d , r ^d = 0
<span class="math inline">\(,我们称它是**幂零的**.而最小的\)</span>d
<span class="math inline">\(满足\)</span>r ^d <span class="math inline">\(称为\)</span>r <span class="math inline">\(的**幂零指数**.回忆到我们定义过广义特征子空间\)</span>V
_{ [ ] } = ( T - ) ^<span class="math inline">\(.回忆到\)</span> ( V )
<span class="math inline">\(是一个环,\)</span>T ( V )
$是其中的一个元素,我们说以下命题等价:</p>
<ol type="1">
<li><p>$T ( V ) $是幂零的.</p></li>
<li><p>$k , _T = x ^k $.</p></li>
<li><p>$ _T = x ^n $.</p></li>
<li><p>$V = V _{ [ 0 ] } $.</p></li>
</ol>
<p>(1)$<span class="math inline">\((2)只需考虑如果\)</span>T ^k = 0
<span class="math inline">\(,则\)</span> _T | x ^k $.</p>
<p>(2)$$(3)是显然的,因为极小多项式和特征多项式共根.</p>
<p>(3)$$(4)直接是定义.</p>
<p>(4)$<span class="math inline">\((1),考虑\)</span>V _{ [ 0 ] }
$作为子空间,扩张一定是有限次的,所以也就搞定.</p>
接下来我们定义上三角块$J _d ( ) =
<span class="math display">\[\begin{bmatrix}\lambda &amp; 1 &amp; &amp;
\\ &amp; \ddots &amp; \ddots &amp; \\ &amp; &amp; \lambda &amp; 1 \\
&amp; &amp; &amp; \lambda \end{bmatrix}\]</span>
<p><span class="math inline">\(以及下三角块\)</span>( J _d ) ^t ( )
<span class="math inline">\(.容易见到\)</span>J _d ( ) = I + J _d ( 0 )
<span class="math inline">\(,我们还可以发现下三角块\)</span>( J _d ) ^t
( 0 ) <span class="math inline">\(恰好是多项式\)</span>x ^d <span class="math inline">\(的友矩阵.并且容易见到对于\)</span>( J _d ) ^t ( )
<span class="math inline">\(而言,其\)</span> = = ( x - ) ^d <span class="math inline">\(.同理取其转置可以知道\)</span>J _d ( ) <span class="math inline">\(亦然有\)</span> = = ( x - ) ^d $.</p>
接下来我们证明,如果$A $幂零,则存在唯一的正整数列$1 b _1 b <em>r <span class="math inline">\(使得\)</span></em>{ i = 1 } ^r b _i = n <span class="math inline">\(而\)</span>A <span class="math inline">\(共轭于分块对角矩阵\)</span>
<span class="math display">\[\begin{bmatrix}J _{ b _1  } ( 0 ) &amp;
&amp; \\ &amp; \ddots &amp; \\ &amp; &amp; J _{ b _r  } ( 0 )
\end{bmatrix}\]</span>
<p><span class="math inline">\(,并且如果上述陈述中的\)</span>J _{ b
<em>i } <span class="math inline">\(全换成下三角\)</span>( J </em>{ b _i
} ) ^t $,结论亦然成立.</p>
<p>这个其实是显然的,因为此时直接取其有理标准型满足$f _1 | | f _r <span class="math inline">\(,并且\)</span>f _r = x ^d <span class="math inline">\(,设\)</span>f _i = x ^{ b _i }
$,自然得到下三角的结论,转置后得到上三角的结论.</p>
接下来假设特征多项式在$F <span class="math inline">\(上分裂(这当然是必要的,因为Jordan标准型是上三角矩阵,而一个矩阵可上三角化的充要条件是特征多项式在\)</span>F
<span class="math inline">\(上分裂),我们设其相异根为\)</span>_1 , , _m F
<span class="math inline">\(,存在\)</span>V <span class="math inline">\(的有序基,使得\)</span>T <span class="math inline">\(表为分块对角矩阵\)</span>diag ( A _1 , , A _m )
<span class="math inline">\(,其中\)</span>A _j =
<span class="math display">\[\begin{bmatrix}J _{ b _1 , j  } ( \lambda
_j ) &amp; &amp; \\ &amp; \ddots &amp; \\ &amp; &amp; J _{ b _{ r _j  }
, j  } ( \lambda _j ) \end{bmatrix}\]</span>
<p><span class="math inline">\(.而且每个\)</span>j <span class="math inline">\(对应地正整数数列由\)</span>T <span class="math inline">\(唯一确定,上述矩阵被称为\)</span>T
$的Jordan标准型.</p>
<p>证法呼之欲出,取对$T <span class="math inline">\(的广义特征子空间分解\)</span>V = V <em>{ [ _1 ] }
V </em>{ [ _m ] } <span class="math inline">\(,限制在\)</span>V _{ _j }
<span class="math inline">\(上,\)</span>T _j - _j
$幂零,根据上面的结论就做完了.</p>
<p>现在的问题可能在于如何计算Jordan标准型,一种方法是途径有理标准型,另一种方法是依赖于秩的计算.让我们依旧从幂零情形入手,假设$T
$幂零,我们断言:</p>
<ol type="1">
<li><p>在$T <span class="math inline">\(的Jordan标准型中,Jordan块的总数为\)</span>n - ( T
) $个.</p></li>
<li><p>对于每个$d <span class="math inline">\(,标准型中的\)</span>d d
<span class="math inline">\(Jordan块的个数\)</span>N ( d ) <span class="math inline">\(满足:\)</span>N ( d ) = ( T ^{ d + 1 } ) + ( T ^{
d - 1 } ) - 2 ( T ^d ) $.</p></li>
</ol>
<p>(1)是显然的,因为一个$d d <span class="math inline">\(的Jordan块的秩为\)</span>d - 1 $.</p>
<p>而容易见到$ ( J _b ( 0 ) ^k ) = ( 0 , b - k ) $,从而:</p>
$$
<span class="math display">\[\begin{aligned}
\mathrm { rk  } ( T ^{ d + 1  } ) - \mathrm { rk  } ( T ^d ) &amp; =
\sum _{ j : b _j \geq d + 1  } ( - 1 ) \\
\mathrm { rk  } ( T ^{ d  } ) - \mathrm { rk  } ( T ^{ d - 1  } ) &amp;
= \sum _{ j : b _j \geq d  } ( - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>两式相减即可得到答案.</p>
<p>至于对其余情形,只需观察到当$_i _j <span class="math inline">\(的时候,\)</span>A _i - _j I $肯定可逆,因此:</p>
<p><span class="math display">\[
N _j ( d ) = \mathrm { rk  } ( T - \lambda _j I ) ^{ d + 1  } + \mathrm
{ rk  } ( T - \lambda _j I ) ^{ d - 1  } - 2 \mathrm { rk  } ( T -
\lambda _j I ) ^d
\]</span></p>
<p>便数平凡.</p>
<p>可以见到Jordan标准型的每一个块,如果特征值为$0
$,实际上是把基向前挪动.</p>
<h5><span id="加性jordan-chevalley分解">加性Jordan-Chevalley分解</span></h5>
<p>由上述可以见到,对于一个特征多项式可分裂的矩阵$T <span class="math inline">\(,存在唯一一个可对角化矩阵\)</span>S <span class="math inline">\(和一个幂零矩阵\)</span>N <span class="math inline">\(使得\)</span>T = S + N <span class="math inline">\(而且\)</span>SN = NS $.</p>
<p>由Jordan标准型知道的确存在解(因为每一个分块对角上的对角矩阵都是$I
$的形式),现在问题在于唯一性.</p>
<p>既然$S <span class="math inline">\(可对角化,我们取其相异的特征值\)</span>_1 , , <em>l
<span class="math inline">\(.对其做特征子空间分解\)</span>V = V </em>{
<em>1 } V </em>{ _l } <span class="math inline">\(,回忆到\)</span>NS =
SN <span class="math inline">\(导出\)</span>ST = TS <span class="math inline">\(,这意味着每一个特征子空间都是\)</span>T
$不变的.</p>
<p>此时观察$T | _{ V _j } <span class="math inline">\(,观察到此时\)</span>( T - <em>j I ) | </em>{ V
<em>j } = N | </em>{ V _j } <span class="math inline">\(是幂零的,所以\)</span>V _j <span class="math inline">\(被包含于\)</span>T <span class="math inline">\(的广义特征子空间\)</span>V ’ [ _j ] <span class="math inline">\(,然而广义特征子空间必然也给出了一个空间的分解,因此它们也不可能再往外扩张了,这必然意味着\)</span>S
<span class="math inline">\(的特征空间\)</span>V _j <span class="math inline">\(恰好就是\)</span>T <span class="math inline">\(的广义特征子空间\)</span>V ’ [ _j ] <span class="math inline">\(.所以\)</span>S <span class="math inline">\(限定在\)</span>V ’ [ _j ] <span class="math inline">\(上就是\)</span>_j I <span class="math inline">\(,这就保证了\)</span>S <span class="math inline">\(是唯一的,从而\)</span>N $也就唯一.</p>
<p>此外,我们还可以证明存在多项式$f , g <span class="math inline">\(使得\)</span>S = f ( T ) , N = g ( T ) <span class="math inline">\(.首先可以取\)</span>g = x - f <span class="math inline">\(,下面来搞定\)</span>f $是如何取定的.</p>
<p>考虑用中国剩余定理拿到一个$f <span class="math inline">\(满足\)</span>f <em>i <span class="math inline">\(,留神到\)</span>f ( T ) | </em>{ V _j } = _j <span class="math inline">\(,原因是\)</span>( T - <em>j ) ^n | </em>{ V _j } =
0 <span class="math inline">\(,那按照我们刚才对唯一性的论证,这必然说明了\)</span>f
( T ) = S $.</p>
<h5><span id="乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</span></h5>
<p>对于一个特征多项式可分裂的可逆(等价于特征多项式无零根)的$T ( V )
<span class="math inline">\(,则存在唯一一对可逆的\)</span>S , U
$使得:</p>
<ol type="1">
<li><p>$S $可对角化.</p></li>
<li><p>$U - I $幂零.</p></li>
<li><p>$SU = T = US $.</p></li>
<li><p>存在多项式$f , g <span class="math inline">\(,\)</span>S = f ( T
) , U = g ( T ) $.</p></li>
</ol>
<p>对于存在性,取道加性分解,设$T = S + N = S ( I + S ^{ - 1 } N ) <span class="math inline">\(,直接取\)</span>U = I + S ^{ - 1 } N <span class="math inline">\(,由于\)</span>SN = NS <span class="math inline">\(,则\)</span>U - I = S ^{ - 1 } N <span class="math inline">\(因为\)</span>N <span class="math inline">\(幂零而幂零,同时\)</span>SU = T = US $也满足了.</p>
<p>对于唯一性,假设存在$T = SU = S + S ( U - I ) <span class="math inline">\(,由于\)</span>SU = US <span class="math inline">\(,所以\)</span>S ( U - I )
$幂零,这就给出了一个加性分解,从而导出了唯一性.</p>
<p>最后来看如何取多项式.加性版本给出了$S = f ( T ) <span class="math inline">\(.要求出\)</span>g <span class="math inline">\(的话需要满足\)</span>g ( T ) f ( T ) = T $.</p>
<p>于此考虑证明$f <span class="math inline">\(和\)</span> _T <span class="math inline">\(是互素的,原因是反证法:如果不互素,则存在\)</span>T
<span class="math inline">\(的特征值\)</span><span class="math inline">\(使得\)</span>( x - ) | f <span class="math inline">\(,则对于对应的特征向量\)</span> <span class="math inline">\(总有\)</span>S = f ( T ) = 0 <span class="math inline">\(,可是\)</span>S $可对角化而且特征值无$0
$,这就矛盾了.</p>
<p>既然如此,用裴蜀定理立刻拿到一对$g , h F [ x ] <span class="math inline">\(使得\)</span>gf + h _T = x <span class="math inline">\(,带入\)</span>T <span class="math inline">\(得到\)</span>g ( T ) f ( T ) = T <span class="math inline">\(,这个\)</span>g ( T ) = TS ^{ - 1 } = U $.</p>
<h3><span id="张量积">张量积</span></h3>
<p>给定两个$F <span class="math inline">\(上的向量空间\)</span>V , W
<span class="math inline">\(,我们想要通过它们构造新的向量空间\)</span>V
W $(这里并非直积,只是用这个符号).我们希望这个配对满足:</p>
<ol type="1">
<li><p>$V W V W $是双线性的.</p></li>
<li><p>构造应该是自然的:不依赖基的选取.</p></li>
</ol>
<p>此外,我们希望其满足一些更好的泛性质,考虑资料$( L , B ) <span class="math inline">\(,其中\)</span>L <span class="math inline">\(是一个向量空间,\)</span>B <span class="math inline">\(是一个\)</span>V W L <span class="math inline">\(的一个双线性映射,我们希望有一个尽可能泛的资料\)</span>(
L <em>{ } , B </em>{ } ) <span class="math inline">\(,使得对于任何满足条件的\)</span>( L , B ) <span class="math inline">\(,存在唯一的\)</span>$以下图表交换:</p>
<p><span class="math display">\[
\xymatrix { V \times W \ar [r ] ^{ B _{ \mathrm { univ  }  }  } \ar [dr
] _B &amp; L _{ \mathrm { univ  }  } \ar [d ] ^\varphi \\
&amp; L  }
\]</span></p>
<p>此外我们还希望上述资料$( L <em>{ } , B </em>{ } ) <span class="math inline">\(是唯一的,我们希望将其记作\)</span>V W $.</p>
<p>我们可以先尝试构造一下,用最粗暴的方法,干脆定义$E = F ^{ ( V W ) }
<span class="math inline">\(,其元素表为有限线性组合\)</span>_i c _i ( v
_i , w _i ) <span class="math inline">\(,考虑以下元素生成的子空间\)</span>N $:</p>
<ol type="1">
<li><p>$( v + v ’ , w ) - ( v , w ) - ( v ’ , w ) $.</p></li>
<li><p>$( v , w + w ’ ) - ( v , w ) - ( v , w ’ ) $.</p></li>
<li><p>$( tv , w ) - t ( v , w ) $.</p></li>
<li><p>$( v , tw ) - t ( v , w ) $.</p></li>
</ol>
<p>接下来取$L <em>{ } = E / N <span class="math inline">\(,连同映射\)</span>B </em>{ } : ( v , w ) ( v , w )
+ N $,容易见到我们的确强行定义了双线性形式的性质.</p>
<p>接下来考虑其泛性质,对双线性映射$B : V W L <span class="math inline">\(,其可以确定唯一的线性映射\)</span>: E L , _i c _i
( v _i , w _i ) _i c _i B ( v _i , w _i ) $.</p>
<p>然而由于$B <span class="math inline">\(的双线性性,立刻得到\)</span>B
( N ) = { 0 } <span class="math inline">\(,从而可以导出唯一的\)</span>:
L _{ } L , x + N ( x ) <span class="math inline">\(.这立刻得到了\)</span><span class="math inline">\(的唯一性,原因是\)</span>( ( v , w ) + N ) = B ( v
, w ) $是总有的.</p>
<p>唯一性应当是显然的,只需见到如果有两个$L <em>{ } <span class="math inline">\(和\)</span>L </em>{ } ’ $,则应当有:</p>
<p><span class="math display">\[
\xymatrix { &amp; L _{ \mathrm { univ  }  } \ar [d ] ^\varphi \\
V \times W \ar [ru ] ^{ B _{ \mathrm { univ  }  }  } \ar [r ] ^{ B _{
\mathrm { univ  }  } &#39;  } \ar [dr ] _{ B _{ \mathrm { univ  }  }  }
&amp; L _{ \mathrm { univ  }  } &#39; \ar [d ] ^\psi \\
&amp; L _{ \mathrm { univ  }  }  }
\]</span></p>
<p>外圈当然也是交换的,然而取$id <span class="math inline">\(也必然导出外圈交换,由图表唯一性立刻得到\)</span>=
id <span class="math inline">\(,对称性得出\)</span>= id <span class="math inline">\(,这就搞定了\)</span>L <em>{ } L </em>{ } ’ $.</p>
<p>容易见到上述性质保证了同构:$ ( V W , L ) ( V , W ; L ) , B _{ }
$.</p>
<p>容易将上述结论推广到多重线性映射的情形.还可以将张量积的符号推广到线性映射上,我们断言总存在唯一的$$使得下图交换:</p>
<p><span class="math display">\[
\xymatrix { V _1 \times \cdots \times V _n \ar [r ] ^{ ( f _1 , \cdots ,
f _n )  } \ar [d ] &amp; W _1 \times \cdots \times W _n \ar [d ] \\
V _1 \otimes \cdots \otimes V _n \ar [r ] _{ \varphi  } &amp; W _1
\otimes \cdots \otimes W _n \\
}
\]</span></p>
<p>从而可以自然地将$<span class="math inline">\(记作\)</span>f _1 f _n
$.</p>
<p>于此只需考虑上半部分,我们知道$( v _1 , , v _n ) f _1 ( v _1 ) f _n (
v _n ) $是一个多重线性映射,所以当然存在唯一一个映射打过来.从而得到:</p>
<p><span class="math display">\[
( f _1 \otimes \cdots \otimes f _n ) ( v _1 \otimes \cdots \otimes v _n
) = f _1 ( v _1 ) \otimes \cdots \otimes f _n ( v _n )
\]</span></p>
<p>其实我们上面证明的就是下面这个同构$_{ i = 1 } ^n ( V _i , W _i ) ( _i
V _i , _i W _i )
$,好吧起码这个有限维情况下是同构,无穷维的话lww好像也有点不确定.</p>
<p>有以下性质自然成立(另一种看法是,线性映射也在一个线性空间里,所以上面也会自带一种张量积,恰为这个):</p>
<ol type="1">
<li><p>$id _{ V <em>1 } id </em>{ V <em>n } = id </em>{ V _1 V _n }
$.</p></li>
<li><p>$( f _1 f _n ) ( g _1 g _n ) = f _1 g _1 f _n g _n $.</p></li>
<li><p>$( ( f _1 + ’ f _1 ’ ) f _n ) = ( f _1 f _n ) + ’ ( f _1 ’ f _n )
$.</p></li>
</ol>
<p>而考虑多重线性映射的$ ( V _1 , , V _n ; M ) <span class="math inline">\(,如果\)</span>V _1 , , V _n <span class="math inline">\(中任意一个是零空间,那由于多重线性性质,立刻导出这个映射只有零映射(原因是此时\)</span>a
= a + a <span class="math inline">\(),从而使得\)</span> ( V _1 V _n ; M
) <span class="math inline">\(中只有零映射(对所有\)</span>M <span class="math inline">\(),那其\)</span>id <span class="math inline">\(映射也是零映射,自然意味着\)</span>V _1 V _n
$是零空间.</p>
<p>于此之外,如果想要跳过张量积的构造而直接探究张量积的性质,可能需要先判断${
v _1 v _n } <span class="math inline">\(集合是否的确生成了\)</span>V _1
V _n <span class="math inline">\(.于此只需要取\)</span>K = v _1 v _n | v
_i V _i <span class="math inline">\(,然后判断\)</span>M = ( V _1 V _n )
/ K <span class="math inline">\(是否为零空间即可.此时\)</span><span class="math inline">\(作为商映射,当然都有\)</span>( v _1 v _n ) = 0
<span class="math inline">\(,我们想说明\)</span><span class="math inline">\(的确是零映射,这首先需要保证即使只有\)</span>v _1 v
_n $上的限制也可以有类似外延公理的结论.</p>
<p>换言之,如果两个在$V _1 V _n <span class="math inline">\(映射\)</span>f , g <span class="math inline">\(满足\)</span>v _i , f ( v _1 v _n ) = g ( v _1 v
_n ) <span class="math inline">\(则\)</span>f g
$,只需回忆到这上面的映射与多重线性映射一一对应,而多重线性映射上用外延公理就搞定了.</p>
<p>这就看到,用与多重线性映射一一对应的性质同样是张量积的某种泛性质.</p>
<p>我们还可以看到,如果$f _1 , , f _n <span class="math inline">\(都是满的,则\)</span>f _1 f _n
$亦然,这是显然的.</p>
<p>可能稍不显然的是如果$f _1 , , f _n <span class="math inline">\(都是单的,则\)</span>f _1 f _n <span class="math inline">\(也是单的.此时\)</span>W _i <span class="math inline">\(可以分解出一个与\)</span>V _i <span class="math inline">\(同构的\)</span> f _i <span class="math inline">\(部分,干脆记作\)</span>W _i V _i V _i ’ <span class="math inline">\(,并假设\)</span>f _i : V _i W _i <span class="math inline">\(是自然的嵌入映射.回忆到张量积在同构下有交换律和对直和的分配律(下面会证),见到\)</span>W
_1 W _n ( V _1 V _n ) V ’ <span class="math inline">\(,此时\)</span>f _1
f _n <span class="math inline">\(就是自然的嵌入映射.你可能会想欸,不对啊,\)</span>V
’ <span class="math inline">\(里也会有一些\)</span>V _i
$项啊.可是,回忆到如果某一分量为零,则其在张量积中拿到的结果就是$0 <span class="math inline">\(,所以\)</span>f _1 f _n $只会对前面有意义.</p>
<h4><span id="张量积与直和">张量积与直和</span></h4>
<p>接下来考虑证明以下结论:</p>
<ol type="1">
<li><p>结合律:$V _1 ( V _2 V _3 ) V _1 V _2 V _3 ( V _1 V _2 ) V _3
$.</p></li>
<li><p>幺元:$F V V V F $.</p></li>
<li><p>交换律:$V W W V $.</p></li>
<li><p>零元:${ 0 } V { 0 } V { 0 } $.</p></li>
<li><p>分配律:设$V <span class="math inline">\(带有直和分解\)</span>V =
_{ i I } V <em>i <span class="math inline">\(,则\)</span>V W </em>{ i I
} ( V _i W ) $.</p></li>
</ol>
<p>考虑(1),下面证明$V _1 ( V _2 V _3 ) V _1 V _2 V _3
$,其关键是构造以下线性映射:</p>
<p><span class="math display">\[
\xymatrix { V _1 \otimes ( V _2 \otimes V _3 ) \ar [r ] ^{ \alpha  }
&amp; V _1 \otimes V _2 \otimes V _3 \ar [r ] ^{ \beta  } &amp; V _1
\otimes ( V _2 \otimes V _3 ) \\
v _1 \otimes ( v _2 \otimes v _3 ) \ar @{|-&gt;} [r ] &amp; v _1 \otimes
v _2 \otimes v _3 \ar @{|-&gt;} [r ] &amp; v _1 \otimes ( v _2 \otimes v
_3 )  }
\]</span></p>
<p>如果我们的确造出了这个映射,由于我们有外延公理,这必然意味着$= id <span class="math inline">\(,从而导出\)</span>V _1 ( V _2 V _3 ) V _1 V _2 V
_3 $.</p>
<p>对于$<span class="math inline">\(,立刻就能看出\)</span>V _1 V _2 V _3
V _1 ( V _2 V _3 ) <span class="math inline">\(是三重线性的.因此泛性质诱导出\)</span>$映射.</p>
<p>至于$<span class="math inline">\(映射,只需先做\)</span>V _1 ( V _2 V
_3 ) V _1 V _2 V _3 $就行.</p>
<p>考虑(2),和(1)一样,我们想要搞一个映射链$V F V V <span class="math inline">\(,对于前者只需要取映射\)</span>_V : F V V , t v tv
<span class="math inline">\(,对于后者只需要取\)</span>_V : V F V , v v
$.回忆到$1 tv = t v <span class="math inline">\(,因此上述映射均是合理的,而且复合之后是\)</span>id
$.</p>
<p>考虑(3),我想答案呼之欲出:$V W <span class="math inline">\(和\)</span>W V <span class="math inline">\(都是\)</span>V W <span class="math inline">\(诱导出来的,而\)</span>V W W V $.</p>
<p>(4)我们之前已经证明了.</p>
<p>考虑(5),回忆到如果$V = _{ i I } V <em>i <span class="math inline">\(,则\)</span>V ^= </em>{ i I } ( V <em>i ) ^<span class="math inline">\(.同理应该能拿到\)</span> ( V , L ) = </em>{ i I }
( V _i , L ) $,进一步地有:</p>
<p><span class="math display">\[
\mathrm { Bil  } ( V , W ; L ) \cong \prod _{ i \in I  } \mathrm {
Bil  } ( V _i , W ; L ) \cong \prod _{ i \in I  } \mathrm { Hom  } ( V
_i \otimes W , L ) \cong \mathrm { Hom  } \left ( \bigoplus _{ i \in
I  } ( V _i \otimes W ) , L \right )
\]</span></p>
<p>从而可以使我们诱导出原本的同构.</p>
<p>基于(5),我们可以知道如果$V <span class="math inline">\(有基\)</span>(
v <em>i ) </em>{ i I } <span class="math inline">\(而\)</span>W <span class="math inline">\(有基\)</span>( w <em>j ) </em>{ j J } <span class="math inline">\(,则\)</span>( v _i w <em>j ) </em>{ ( i , j ) I J
} <span class="math inline">\(也是\)</span>V W <span class="math inline">\(的基,从而得到\)</span>( V W ) = ( V ) ( W )
$.这给出了张量积的Kronecker基形式.</p>
<p>最后我们还可以引入张量幂$V ^{ n } <span class="math inline">\(,从上面的讨论我们可以知道\)</span>( V ^{ a } ) ^{
b } V ^{ ab } <span class="math inline">\(以及\)</span>V ^{ a } V ^{ b }
V ^{ ( a + b ) } $.</p>
<h4><span id="kronecker积">Kronecker积</span></h4>
<p>对于矩阵$X F ^{ n m } , Y F ^{ p q }
$,我们定义它们的克罗内多积为:</p>
<p><span class="math display">\[
X \otimes Y = \begin{bmatrix}
x _{ 1 , 1  } Y &amp; x _{ 1 , 2  } Y &amp; \cdots &amp; x _{ 1 , m  } Y
\\
x _{ 2 , 1  } Y &amp; x _{ 2 , 2  } Y &amp; \cdots &amp; x _{ 2 , m  } Y
\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x _{ n , 1  } Y &amp; x _{ n , 2  } Y &amp; \cdots &amp; x _{ n , m  } Y
\end{bmatrix} \in F ^{ ( np ) \times ( mq )  }
\]</span></p>
<p>克罗内多积显然不满足交换律.</p>
<p>事实上,设$X , Y , Z $在下列运算中有意义,克罗内多积满足以下性质:</p>
<ol type="1">
<li><p>结合律:$X Y Z = X ( Y Z ) $.</p></li>
<li><p>左分配律:$X ( Y + Z ) = X Y + X Z $.</p></li>
<li><p>右分配律:$( X + Y ) Z = X Z + Y Z $.</p></li>
<li><p>$( X Y ) ^T = X ^T Y ^T $.</p></li>
<li><p>$( X Y ) ( U V ) = ( XU ) ( YV ) $.</p></li>
<li><p>$X ^{ - 1 } Y ^{ - 1 } = ( X Y ) ^{ - 1 } $.</p></li>
<li><p>$( X Y ) = ( X ) ^m ( Y ) ^n , X F ^{ n n } , Y F ^{ m m }
$.</p></li>
<li><p>$rank ( X Y ) = rank ( X ) rank ( Y ) $.</p></li>
</ol>
<p>上述命题稍不显然的是(4),我们将在下面讨论对偶空间的时候得出它.</p>
<p>克罗内多积的性质有一个很有用的特例是:</p>
<p><span class="math display">\[
\begin{aligned}
A \otimes B \otimes C &amp; = ( A \otimes I _n \otimes I _n ) ( I _n
\otimes B \otimes I _n ) ( I _n \otimes I _n \otimes C ) \\
A , B , C \in F ^{ n \times n  }
\end{aligned}
\]</span></p>
<h4><span id="张量积与对偶空间">张量积与对偶空间</span></h4>
<p>回忆到典范配对,如今我们可以用张量积将其表示为线性映射$V ^V F , v , v
= ( v ) $,这被称为<strong>缩并</strong>映射.</p>
<p>考虑映射$: V ^W ( V , W ) , _i _i w _i _i _i , _ w _i
$.这个映射总是单射,当维数是有限维的时候则是满的.</p>
<p>也许还该简单验证此结论,首先检查$V ^W ( V , W ) <span class="math inline">\(,这的确是一个双线性映射,于是由泛性质立刻诱导出映射\)</span>V
^W ( V , W ) $.</p>
<p>接下来证明其是单射,只需要证明其$= { 0 } <span class="math inline">\(即可.而其\)</span><span class="math inline">\(中的元素总形如\)</span>_{ i = 1 } ^k _i w _i <span class="math inline">\(,不妨假设\)</span>w _1 , , w _k <span class="math inline">\(是线性无关的(可以把相关的项整理到\)</span>_i
$里面).</p>
<p>此时由于其在$<span class="math inline">\(里,所以\)</span>v V <span class="math inline">\(,总有\)</span>_{ i = 1 } ^k _i , v w _i = 0 <span class="math inline">\(,然而\)</span>w _i <span class="math inline">\(线性无关,所以\)</span>_i , v <span class="math inline">\(,可是\)</span>v <span class="math inline">\(是任取的,这必然意味着\)</span>_i $.</p>
<p>接下来考虑证明当$V , W <span class="math inline">\(其一是有限维的时候上述映射是满的,容易发现\)</span><span class="math inline">\(的像总是有限维的(因为左边是有限求和).当\)</span>V
, W <span class="math inline">\(其一是有限维的,\)</span>T ( V , W )
<span class="math inline">\(就是有限秩的,此时就可以取其像的基\)</span>w
_1 , , w _n <span class="math inline">\(,对所有\)</span>v V <span class="math inline">\(,\)</span>T ( v ) <span class="math inline">\(都可以唯一表述为\)</span>c _1 w _1 + + c _n w _n
<span class="math inline">\(,然而这里面每一个\)</span>c _i <span class="math inline">\(对\)</span>v <span class="math inline">\(都是线性的,从而它们都可以表示为\)</span>V ^<span class="math inline">\(中的元素而与\)</span>v $的选取无关,这就搞定了.</p>
<p>万事俱备,再看$ ( V ) <span class="math inline">\(上,既然\)</span>V ^V
<span class="math inline">\(带有一个典范的缩并映射,在有限维的情况下,那与之同构的\)</span>
( V ) <span class="math inline">\(也该带有一个到\)</span>F <span class="math inline">\(的映射.我们断言这个映射就是\)</span>
$映射.有下述图表:</p>
<p><span class="math display">\[
\xymatrix { V ^\vee \otimes V \ar [rd ] _{ \text { contraction  }  } \ar
[rr ] ^{ \sim  } &amp; &amp; \mathrm { End ( V )  } \ar [ld ] ^\mathrm {
Trace  } \\
&amp; F &amp;  }
\]</span></p>
<p>如何检验这个结论,我们之前刻画Trace的办法只有取对偶基$ _1 , , _n <span class="math inline">\(,然后将\)</span>v = c _i v _i <span class="math inline">\(和\)</span>= d _i <em>i <span class="math inline">\(,那典范配对\)</span>( v ) = </em>{ i , j } _i , _
v _j <span class="math inline">\(,也就是说其将基向量\)</span>v _i <span class="math inline">\(映射到了\)</span>_j c _j d _i <span class="math inline">\(,从而见到其\)</span> = _i c _i d _i = , v $.</p>
<p>如果写成矩阵形式的话,$V ^$可以写成一个$1 n <span class="math inline">\(的矩阵,\)</span>w W <span class="math inline">\(可以写成一个\)</span>m <span class="math inline">\(的矩阵,那其实\)</span>( w ) <span class="math inline">\(就是\)</span>w <span class="math inline">\(这个\)</span>m n $的矩阵.</p>
<p>最后来看曾经想要拿到的那个结论,下面我们引入一个典范的同构$: V _1 ^V
_n ^( V _1 V _n ) ^<span class="math inline">\(,策略是观察\)</span>V _1
^V _n ^( V _1 V _n ) ^$自然是一个线性映射,其映射自然是:</p>
<p><span class="math display">\[
( \check { v  } _1 , \cdots , \check { v  } _n ) \mapsto \left [ v _1
\otimes \cdots \otimes v _n \mapsto \prod _{ i = 1  } ^n \langle \check
{ v  } _i , v _i \rangle \right ]
\]</span></p>
<p>我们希望当每个$V _i <span class="math inline">\(都是有限维的时候,上述映射是同构.由于两遍维数相同,所以单性蕴含着满性.而其单性只要取左侧\)</span>V
_1 ^V <em>n ^<span class="math inline">\(的基\)</span> <span class="math inline">\(,将每个\)</span><span class="math inline">\(按照这组基展开,\)</span>( ) <span class="math inline">\(在\)</span>v </em>{ 1 , i <em>1 } v </em>{ n , i
_n } <span class="math inline">\(处的值就是该基在\)</span><span class="math inline">\(中的系数.因此\)</span>= { 0 } $导出单性.</p>
<h4><span id="张量代数">张量代数</span></h4>
<p>设$F <span class="math inline">\(是一个域,一个\)</span>F
$上的<strong>代数</strong>需要以下资料:</p>
<ol type="1">
<li><p>一个环$A <span class="math inline">\(,其需要带有\)</span>F
$向量空间的结构,使得环的加法等价于向量空间的加法.</p></li>
<li><p>环的乘法$A A A $需要是双线性的.</p></li>
</ol>
<p>请沿之前引入代数结构的常规讨论把代数的结构一块搞定,其实大部分在环那里已经做完了,代数结构更强,因此只需要限定同态必须也态射到代数就行.也许还需要检验理想对标量乘法封闭,只需要观察到$tI
= ( t 1 _A ) I I $就行.</p>
<p>对于$F <span class="math inline">\(向量空间\)</span>V <span class="math inline">\(,下面定义\)</span>T ( V ) = _{ n } V ^{ n }
$,其自然带有向量空间的结构,只需加上双线性乘法就能构成一个代数,策略是:</p>
<p><span class="math display">\[
\begin{gathered}
V ^{ \otimes a  } \otimes V ^{ \otimes b  } \to V ^{ \otimes ( a + b
)  } \\
( v _1 \otimes \cdots \otimes v _a ) \otimes ( v _1 &#39; \otimes \cdots
\otimes v _b &#39; ) \mapsto v _1 \otimes \cdots \otimes v _a \otimes v
_1 &#39; \otimes \cdots \otimes v _b &#39;
\end{gathered}
\]</span></p>
<p>它的幺元自然选作$1 F = V ^{ } <span class="math inline">\(.我们还可以自然地在上面定义\)</span>^{ a }
$之类的结构,不再赘述.</p>
<p>来进入对称代数与外代数,考虑$C ( V , , V ; M ) <span class="math inline">\(,任意置换\)</span>$,定义:</p>
<ol type="1">
<li><p>如果$C ( , x , y , ) = C ( , y , x , ) <span class="math inline">\(,则称其为**对称的**.对称性等价于说\)</span>C ( v
<em>1 , , v <em>n ) = C ( v </em>{ ( 1 ) } , , v </em>{ ( n ) } )
$.</p></li>
<li><p>如果说$C ( v <em>1 , , v <em>n ) = ( ) C ( v </em>{ ( 1 ) } , , v
</em>{ ( n ) } ) $,则称其为<strong>反对称的</strong>.</p></li>
<li><p>如果$C ( , x , x , ) = 0
$,则称其为<strong>交错的</strong>.</p></li>
</ol>
<p>当$ F
$的时候,交错和反对称是等价的.不然,起码交错的一定是反对称的.下面定义:</p>
<ol type="1">
<li><p>$I _{ Sym } <span class="math inline">\(为形如\)</span>x y - y x
$的元素生成的理想.</p></li>
<li><p>$I _{ } <span class="math inline">\(为形如\)</span>x x
$生成的理想.</p></li>
</ol>
<p>这样就可以定义相应的<strong>对称代数</strong>$Sym ( V ) = T ( V ) / I
<em>{ Sym } <span class="math inline">\(,**外代数**\)</span>( V ) = T (
V ) / I </em><span class="math inline">\(.还可以定义\)</span>Sym ^m ( V
) = V ^{ m } / I _{ } ^m <span class="math inline">\(,同理定义\)</span>^m ( V ) <span class="math inline">\(,容易发现\)</span>Sym ^0 ( V ) = F = ^0 ( V ) ,
Sym ^1 ( V ) = V = ^1 ( V ) $.</p>
<p>在其中的$<span class="math inline">\(运算被自然变成了新的运算,设前者仍是通常的乘法符号,而后者符号采取\)</span>$.</p>
<p>外代数里一个重要的性质是如果$^p ( V ) , ^q ( V ) <span class="math inline">\(,则\)</span>= ( - 1 ) ^{ pq } <span class="math inline">\(,原因是只需要假设\)</span>= x _1 x _p , = y _1 y
_q <span class="math inline">\(,其中\)</span>x _i , y _i V <span class="math inline">\(,而外代数的定义已经给出\)</span>x y = - y x
$,这就完事了.</p>
<p>既然我们可以将一个对称代数或者外代数分成若干层,那考虑对于任意线性映射$:
V W <span class="math inline">\(,我们都可以通过在各个分量上诱导从而拿到:\)</span>Sym
( ) : Sym ( V ) Sym ( W ) , x _1 x _m ( x _1 ) ( x _m ) <span class="math inline">\(,其中\)</span>( x _m ) <span class="math inline">\(是限制在\)</span>V ^{ m }
$上的.这应该是平凡的.</p>
<p>最后我们想要说明对称代数与外代数确实对应着我们的多重线性映射.也就是$
( Sym ^m , M ) <span class="math inline">\(同构于所有的对称\)</span>m
$重线性映射.外代数类似.而这些依照理想的定义的确如此.</p>
<p>接下来来展现二者的结构,不妨设$V = n <span class="math inline">\(,取其一组基\)</span>v _1 , v _n $,我们说:</p>
<ol type="1">
<li><p>当$m &gt; n <span class="math inline">\(的时候,\)</span>^m ( V )
= { 0 } $.</p></li>
<li><p>当$0 m n <span class="math inline">\(的时候,\)</span>^m ( V ) = {
m } $.更确切地说,任意一组下标$1 i _1 &lt; &lt; i <em>m n <span class="math inline">\(,\)</span>v </em>{ i <em>1 } v </em>{ i _m } <span class="math inline">\(构成\)</span>^m ( V ) $的基.</p></li>
<li><p>作为(2)的推论,$( V ) = 2 ^n $.</p></li>
</ol>
<p>(1)比较显然,因为当$m &gt; n <span class="math inline">\(的时候,任何一个元素被生成的方式\)</span>v ’ <em>{
1 } v ’ </em>{ m } $一定线性相关,所以自然为$0 $.</p>
<p>接下来看(2),我们早在行列式的讨论处就证明过了当$m = n <span class="math inline">\(的时候,交错形式是一维的,那当然导出\)</span>( ^n (
V ) ) = 1 <span class="math inline">\(.而且若\)</span> ( V ) <span class="math inline">\(,则当然有\)</span>^n ( ) = det ( ) _{ ^n ( V ) }
$.</p>
<p>而由之前张量积的结论,$v _{ i <em>1 } v </em>{ i _m }
$这些元素肯定构成了一组生成元,只需要证明它们的确线性无关即可.只需证明:</p>
<p><span class="math display">\[
\sum _{ 1 \leq j _1 &lt; \cdots &lt; j _m \leq n  } c _{ j _1 , \cdots ,
j _m  } ( v _{ j _1  } \wedge \cdots \wedge v _{ j _m  } ) = 0
\Rightarrow c _{ j _1 , \cdots , j _m  } \equiv 0
\]</span></p>
做法呼之欲出,取$V ’ = v _{ i <em>1 , } , , v </em>{ i _m } <span class="math inline">\(,定义\)</span>: V V ’ <span class="math inline">\(,方法是\)</span>( v _j ) =
<span class="math display">\[\begin{cases}v _j &amp; j \in \{ i _1 ,
\cdots , i _m \} \\ 0 &amp; \text { otherwise  } \end{cases}\]</span>
<p><span class="math inline">\(.此时其诱导出了\)</span>^m ( ) : ^m ( V )
^m ( V ’ ) <span class="math inline">\(.然后两边做映射.如果\)</span>{ j
_1 , , j _m } { i _1 , , i <em>m } <span class="math inline">\(那就会变成零,最后就会导出\)</span>c </em>{ i _1 ,
, i <em>m } ( v </em>{ i <em>1 } v </em>{ i <em>m } ) = 0 <span class="math inline">\(,然而左边是在\)</span>^m ( V ’ ) <span class="math inline">\(这个\)</span>= 1 <span class="math inline">\(的空间中,所以一定能导出\)</span>c </em>{ i _1 , ,
i _m } = 0 $.</p>
<p>上述是外代数的结构,我们还可以刻画对称代数的结构,可以证明如果$V = n
<span class="math inline">\(,取定\)</span>V <span class="math inline">\(的基\)</span>v _1 , , v _n <span class="math inline">\(,可以将\)</span>Sym ( V ) F [ X _1 , , X _n ]
$.其实就是二次型理论对吧,应该比较简单.</p>
<p>最后我们可以来定义交错矩阵:$A M <em>{ n n } ( R ) <span class="math inline">\(,若\)</span>a </em>{ i , j } = - a <em>{ j , i }
<span class="math inline">\(而且\)</span>a </em>{ i , i } = 0 $.在$2 R
^<span class="math inline">\(的交换环上,这等价于\)</span>A ^t = - A
$.</p>
<p>可以证明当$A M <em>{ n n } ( F ) <span class="math inline">\(,对应了双线性形式\)</span>B ( F ^n , F ^n ; F )
<span class="math inline">\(为\)</span>B ( , ) = ( ) ^t A <span class="math inline">\(.则\)</span>B <span class="math inline">\(是交错形式当且仅当\)</span>A <span class="math inline">\(是交错矩阵.必要性很显然,只需带入\)</span>a </em>{
i , j } = ( _i ) ^t A _j = B ( _i , _j ) <span class="math inline">\(;充分性也很显然,考察\)</span>B ( , ) = ( ) ^t A =
0 $即可.</p>
<p>最后来看特征多项式如何表为外代数形式.考虑$V <span class="math inline">\(是域\)</span>F <span class="math inline">\(上的\)</span>n <span class="math inline">\(维向量空间,\)</span>T ( V ) $,则我们断言:</p>
<p><span class="math display">\[
\det ( \lambda I - T ) = \sum _{ k = 0  } ^n ( - 1 ) ^k \mathrm { Tr  }
( \bigwedge _k T ) \lambda ^{ n - k  }
\]</span></p>
<p>我们之前已经解释过了:</p>
<p><span class="math display">\[
\begin{aligned}
\det ( \lambda I - T ) e _1 \wedge \cdots \wedge e _n \\
&amp; = ( \lambda I - T ) e _1 \wedge \cdots \wedge ( \lambda I - T ) e
_n \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \lambda ^{ n - k  } \sum _{ | I |
= k  } e _1 \wedge \cdots Te _{ i _1  } \cdots \wedge e _n
\end{aligned}
\]</span></p>
<p>也就是设只有$i <em>k I <span class="math inline">\(这个指标集选到了\)</span>Te <span class="math inline">\(而其它的还是\)</span>e <span class="math inline">\(,不妨设\)</span>J = { 1 , , n } I <span class="math inline">\(.现在考虑\)</span>{ e </em>{ i <em>1 } e </em>{ i
<em>k } } </em>{ I } <span class="math inline">\(会构成\)</span>^k ( V )
<span class="math inline">\(的一组基,\)</span>T $施加到上面得到:</p>
$$
<span class="math display">\[\begin{aligned}
( \bigwedge ^k T ) ( e _{ i _1  } \wedge \cdots \wedge e _{ i _k  } )
&amp; = Te _{ i _1  } \wedge \cdots \wedge T e _{ i _k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>对上面这个式子两边做$( e <em>{ j <em>1 } e </em>{ j </em>{ n - k } }
) <span class="math inline">\(,现在看右侧,如果\)</span>Te <em>{ i <em>1
} <span class="math inline">\(变出了一些带有\)</span>e </em>{ j }
$的项,就会变成$0 <span class="math inline">\(.因此右边最后剩下来的只会是形如\)</span>a <em>I (
e </em>{ i <em>1 } e </em>{ i <em>k } ) ( e </em>{ j <em>1 } e </em>{ j
</em>{ n - k } } ) $的东西.两边再换回去,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\det ( \lambda I - T ) e _1 \wedge \cdots \wedge e _n \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \lambda ^{ n - k  } \sum _{ | I |
= k  } a _I
\end{aligned}
\]</span></p>
<p>而最后那个东西恰好是$ ( ^k T ) $.</p>
<h5><span id="另一种构造">另一种构造</span></h5>
<p>当$ ( F ) = 0 <span class="math inline">\(的时候,我们可以脱离商空间的结构,而直接将对称代数与外代数定义在\)</span>T
( V ) $的子空间上.</p>
<p>对称代数与外代数(此时已经等价于反对称代数)都依赖于交换导出的结果,因此首要要做的就是让置换群$S
_n <span class="math inline">\(作用域\)</span>V ^{ n } <span class="math inline">\(,为了保证左作用,下面的设计可能略有一些不合理,但好在我们后面也不会涉及具体的运算.假设\)</span>S
_n $,保持:</p>
<ol type="1">
<li><p>$( ax + by ) = a ( x ) + b ( y ) $.</p></li>
<li><p>$( v <em>1 v <em>n ) = v </em>{ ^{ - 1 } ( 1 ) } v </em>{ ^{ - 1
} ( n ) } $.</p></li>
<li><p>$( ) ( x ) = ( x ) $.</p></li>
</ol>
<p>(2)的奇异设计是为了让(3)合理.这个时候你肯定要问:wcnmd,这个为啥不对啊.你别急,我们设$w
<em>i = v </em>{ <em>{ - 1 } ( i ) } <span class="math inline">\(,则最后得到的结果是\)</span>w </em>{ ^{ - 1 } ( i
) } = w <em>{ ^{ - 1 } ^{ - 1 } ( i ) } = w </em>{ ( ) ^{ - 1 } ( i ) }
$.</p>
<p>原因很简单,因为对于$v <em>i <span class="math inline">\(这个东西,我们想要把它送到\)</span>v </em>{ ( i ) }
$那里去,这样看就合理了.</p>
<p>现在我们着手取子空间,拿出$V _{ Sym } ^{ n } = { x V ^{ n } | S <em>n
, x = x } <span class="math inline">\(以及\)</span>V </em>{ } ^{ n } = {
x V ^{ n } | S <em>n , x = ( ) x } <span class="math inline">\(.同理可以施加\)</span><em>n <span class="math inline">\(从而拿到\)</span>T ( V ) <span class="math inline">\(的子空间\)</span>V </em>{ Sym } <span class="math inline">\(和\)</span>V </em>$.</p>
<p>回忆到我们之前定义过商映射$q <em>{ } : T ( V ) Sym ( V ) <span class="math inline">\(和\)</span>q </em>: T ( V ) ( V ) <span class="math inline">\(.我们下面断言,如果\)</span>n ! F ^<span class="math inline">\((当\)</span> F = 0 <span class="math inline">\(的时候自动满足),则上述映射限制在子空间上变为同构\)</span>(
V ^{ n } ) <em>{ Sym } Sym ^n ( V ) <span class="math inline">\(和\)</span>( V ^{ n } ) </em>{ } ^n ( V ) $.</p>
<p>上述两条类似,我们下面只证明$Sym <span class="math inline">\(的情形.定义映射\)</span>Avg ( V ^{ n } ) , x { n !
} <em>{ S <em>n } x <span class="math inline">\(.留神到\)</span>Avg |
</em>{ V </em>{ } ^{ n } } = id <span class="math inline">\(,而\)</span>
( Avg ) = V <em>{ } ^{ n } <span class="math inline">\(.从而我们知道\)</span>Avg <span class="math inline">\(事实上给出了一个\)</span>V ^{ n } V </em>{ } ^{ n
} <span class="math inline">\(的映射,有同构\)</span>V ^{ n } / ( Avg ) V
_{ } ^{ n } $.</p>
<p>来考虑$q <em>{ } ^n <span class="math inline">\(限制在\)</span>V
</em>{ } ^{ n } <span class="math inline">\(上的结果,记作\)</span><span class="math inline">\(.如果我们想证明\)</span><span class="math inline">\(是满射,其实就是要证明\)</span>Avg q <em>{ } ^n
<span class="math inline">\(.可是\)</span>q </em>{ } ^n <span class="math inline">\(的定义保证了\)</span>q <em>{ } ^n ( x ) = q </em>{
} ^n ( x ) <span class="math inline">\(,因此\)</span>q <em>{ } ^n Avg =
q </em>{ } ^n <span class="math inline">\(,导出\)</span>Avg q _{ } ^n
$.</p>
<p>要证明单射则只需要证明$V <em>{ Sym } ^{ n } q </em>{ } ^n = { 0 }
$.我想这应该是显然的,假设它们的交不为$0 <span class="math inline">\(,取出其中之一,由于其在\)</span>q _{ } ^n <span class="math inline">\(中,所以它必然可以写成若干个\)</span>( x y ) - ( y
x ) <span class="math inline">\(的组合,而这些都会在\)</span>Avg
$作用下变成$0 $.从而我们证明了上述结论.</p>
<p>不过还没有完,我们想要刻画它的代数结构,还差一个乘法.</p>
<p>考虑取上述映射的逆映射,定义$p <em> ^n : Sym ^n ( V ) V <span class="math inline">\(,我们想要研究一下乘法,断言当\)</span>( a + b ) ! F
^<span class="math inline">\(的时候,对所有\)</span>x ( V ^{ a } ) </em>
, y ( V ^{ b } ) _ $:</p>
<p><span class="math display">\[
p _\mathrm { sym  } ^{ a + b  } ( q _\mathrm { sym  } ^{ a  } ( x ) q
_\mathrm { sym  } ^{ b  } ( y ) ) = \frac { a ! b !  } { ( a + b ) !  }
\sum _{ \sigma \in S _{ a + b  } / ( S _a \times S _b )  } \sigma ( x
\otimes y )
\]</span></p>
<p>对于$$有类似的版本,有:</p>
<p><span class="math display">\[
p _{ \wedge  } ^{ a + b  } ( q _{ \wedge  } ^{ a  } ( x ) q _{ \wedge  }
^{ b  } ( y ) ) = \frac { a ! b !  } { ( a + b ) !  } \sum _{ \sigma \in
S _{ a + b  } / ( S _a \times S _b )  } \mathrm { sgn  } ( \sigma )
\sigma ( x \wedge y )
\]</span></p>
<p>考虑上述断言的证明,选取$$版本进行证明,首先应该有:</p>
<p><span class="math display">\[
\begin{aligned}
q _{ \wedge  } ^{ a  } ( x ) q _{ \wedge  } ^{ b  } ( y ) &amp; = q _{
\wedge  } ^{ ab  } ( x \wedge y ) \\
&amp; = q _{ \wedge  } ^{ ab  } \left ( \frac { 1  } { ( a + b ) !  }
\sum _{ \sigma \in S _{ a + b  }  } \mathrm { sgn  } ( \sigma ) \sigma (
x \wedge y ) \right )
\end{aligned}
\]</span></p>
<p>考虑$( x y ) <span class="math inline">\(,其对于\)</span>( , ) S _a S
_b $的时候,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( \tau , \eta ) ( x \wedge y ) &amp; = \tau ( x ) \wedge \eta ( y ) \\
&amp; = \mathrm { sgn  } ( \tau ) \mathrm { sgn  } ( \eta ) x \wedge y
\\
&amp; = \mathrm { sgn  } ( ( \tau , \eta ) ) ( x \wedge y )
\end{aligned}
\]</span></p>
<p>这就会和前面抵消.所以$S _a S _b <span class="math inline">\(可以被商掉,这些元素的数量是\)</span>a ! b !
$个,从而我们确实知道了它的乘法结构.</p>
<p>至于$S _{ a + b } / ( S _a S _b ) <span class="math inline">\(,其实就是选出\)</span>a + b <span class="math inline">\(中的\)</span>a <span class="math inline">\(个元素扔到前面,把剩下的\)</span>b <span class="math inline">\(个元素扔到后面,而且不在意它们的顺序.这就是为什么它的大小为\)</span>
{ a } $.</p>
<h5><span id="又看对偶空间">又看对偶空间</span></h5>
<p>假设$V = n &lt; <span class="math inline">\(,\)</span>n ! F
^$.我们断言有以下典范(从左到右)同构成立:</p>
<ol type="1">
<li><p>$ ^n ( V ^) ^n ( V ) ^$.</p></li>
<li><p>${ } ^n ( V ^) ^n ( V ) ^$.</p></li>
</ol>
<p>原因是以下同构:</p>
<p><span class="math display">\[
\xymatrix { ( V ^\vee ) ^{ \otimes n  } \ar [r ] ^{ \cong  } _{ \Psi  }
&amp; ( V ^{ \otimes n  } ) ^\vee \ar [r ] ^{ \cong  } _{ \Phi  } &amp;
\mathrm { Mul  } ( V , \cdots , V ; F ) \\
\lambda _1 \otimes \cdots \otimes \lambda _n \ar @{|-&gt;} [rr ] &amp;
&amp; [ C ( x _1 , \cdots , x _n ) = \prod _{ i = 1  } ^n \langle
\lambda _i , x _i \rangle ]  }
\]</span></p>
<p>如果我们在左侧施加$<span class="math inline">\(后,右侧会如何改变呢?当然是会变成\)</span>C ( x
<em>{ ( 1 ) } , , x </em>{ ( n ) } ) <span class="math inline">\(.如果左侧是\)</span>( V ^) ^{ n } <em> <span class="math inline">\(,那右侧就会对应到\)</span> </em> ( V , , V ; F ) =
( V ^{ n } ) ^_ $.</p>
<h6><span id="example1">Example1</span></h6>
<p>设$U , W <span class="math inline">\(分别是\)</span>V <span class="math inline">\(的\)</span>p <span class="math inline">\(维子空间,\)</span>U <span class="math inline">\(有基\)</span>x _1 , , x _p <span class="math inline">\(,\)</span>V <span class="math inline">\(有基\)</span>y _1 , , y _p <span class="math inline">\(,求证:\)</span>U = V <span class="math inline">\(当且仅当\)</span>x _1 x _p <span class="math inline">\(和\)</span>y _1 y _p $成比例.</p>
<p>必要性显然,只需要把其中一组基用令一组基表示即可.</p>
<p>对于充分性,考虑反证,如果$U W <span class="math inline">\(,取\)</span>w U V <span class="math inline">\(,两边对\)</span>w <span class="math inline">\(操作.则\)</span>x _1 x _p $会变成$0 <span class="math inline">\(可\)</span>y _1 y _p $不会,这就矛盾了.</p>
<h6><span id="example2">Example2</span></h6>
<p>对于$^p ( V ) { 0 } <span class="math inline">\(,我们定义如果存在\)</span>v _1 , , v _p V <span class="math inline">\(,使得\)</span>= v _1 , v _p <span class="math inline">\(,则称\)</span>$可<strong>分解</strong>.这当然是我们关注的一个重点,下面我们尝试去推导出关于可分解的部分结论.</p>
<p>设$^p ( V ) { 0 } <span class="math inline">\(,其中\)</span>p n = V
$.</p>
<p>考虑如果$v = 0 <span class="math inline">\(,我们断言\)</span><span class="math inline">\(一定可以写作\)</span>v <span class="math inline">\(的形式.策略是将\)</span>{ v } <span class="math inline">\(扩展成一组基\)</span>e _1 = v , e _2 , e <em>n
<span class="math inline">\(.此时\)</span>= </em>{ | I | = p } a <em>I e
</em>{ i <em>1 } e </em>{ i _k } <span class="math inline">\(.如果\)</span>v = 0 $,必然意味着如果$1 I a _I = 0
$.从而导出上述结论.</p>
<p>定义$ ( ) = { v V | v = 0 } <span class="math inline">\(,容易发现这的确是\)</span>V <span class="math inline">\(的一个子空间.以数学归纳的策略可以证明其\)</span>r
= p <span class="math inline">\(,策略是取其一组基\)</span>e _1 , , e _r
<span class="math inline">\(.必然有\)</span>e _1 = 0 <span class="math inline">\(,从而导出\)</span>^{ p - 1 } ( V ) { 0 } <span class="math inline">\(,\)</span>= e _1 <span class="math inline">\(.从而导出\)</span>e _1 e _2 = 0 <span class="math inline">\(.因为\)</span>e _1 <span class="math inline">\(并且\)</span>e _1 e _2 <span class="math inline">\(,这意味着\)</span>e _2 = 0 , e _n = 0
$,从而可以数学归纳.</p>
<p>现在我们尝试断言:$<span class="math inline">\(可分解的充要条件是\)</span> ( ) = p $.</p>
<p>先来看必要性,如果$= x _1 x _p <span class="math inline">\(,因为\)</span> <span class="math inline">\(,所以\)</span>x _1 , , x _p <span class="math inline">\(线性无关.显然\)</span>x _1 , , x _p ( ) <span class="math inline">\(,然而左侧维数是\)</span>p <span class="math inline">\(,右侧维数\)</span>p $.比较维数知道两边相等.</p>
<p>再看充分性,假设$ ( ) <span class="math inline">\(的基是\)</span>e _1
, , e _r <span class="math inline">\(,我们已经断言过存在\)</span>^{ p -
r } ( V ) <span class="math inline">\(使得\)</span>= t ( e _1 e _r )
<span class="math inline">\(,当\)</span>p = r <span class="math inline">\(的时候得到\)</span>$可分解.</p>
<p>还可以证明以下两个结论:</p>
<ol type="1">
<li><p>所有的$^{ n - 1 } ( V ) $都是可分解的.</p></li>
<li><p>设$ ( F ) , n <span class="math inline">\(,则\)</span>^2 ( V )
<span class="math inline">\(可分解当且仅当\)</span>= 0 $.</p></li>
</ol>
<p>对于(1),考虑选取一组基$v _1 , , v _n <span class="math inline">\(,则\)</span>v = c ( v ) v _1 v _n <span class="math inline">\(,其中\)</span>c : V F <span class="math inline">\(显然是线性映射.既然如此,\)</span>c = n - 1 <span class="math inline">\(,从而导出\)</span> ( ) = c <span class="math inline">\(的维数也是\)</span>n - 1 $,这就搞定了.</p>
<p>对于(2),首先必要性显然.对于充分性,一个朴素的证明是基于归纳法的:</p>
<p>对$V <span class="math inline">\(的大小进行归纳,取一组基\)</span>e _1
, e _n <span class="math inline">\(,令\)</span>V _1 = e _2 , , e _n
<span class="math inline">\(则\)</span>= e _1 v + <span class="math inline">\(的形式,其中\)</span>v V _1 , ^2 ( V _1 ) <span class="math inline">\(,根据归纳假设其可分解,设\)</span>= x y $.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
0 &amp; = \omega \wedge \omega \\
0 &amp; = ( e _1 \wedge v + x \wedge y ) \wedge ( e _1 \wedge v + x
\wedge y ) \\
0 &amp; = e _1 \wedge v \wedge x \wedge y \\
0 &amp; = v \wedge x \wedge y \\

\end{aligned}\]</span>
<p>$$</p>
<p>既然如此,说明$v , x , y <span class="math inline">\(线性相关.如果\)</span>x = 0 <span class="math inline">\(或者\)</span>y = 0 <span class="math inline">\(当然就做完了,反之必有\)</span>v = ax + by
$.那么:</p>
<p><span class="math display">\[
\begin{aligned}
\omega &amp; = e _1 \wedge ( ax + by ) + x \wedge y \\
&amp; = ( x + be _1 ) \wedge ( y - ae _1 )
\end{aligned}
\]</span></p>
<p>另一个策略是考虑$^2 ( V ) ( V ^, V ^; F ) <span class="math inline">\(,而且右侧是反对称的.然而我们对辛形式早有研究,回忆到取基使得\)</span>B
( p _i , q _i ) = 1 <span class="math inline">\(而当\)</span>i j <span class="math inline">\(的时候\)</span>B ( p _i , q _j ) = 0 <span class="math inline">\(.用辛形式的分类得知存在一组基\)</span>u _1 , , u
_r , v _1 , v <em>r $,其中$2 r n <span class="math inline">\(使得\)</span>= </em>{ i = 1 } ^r u _i v _i <span class="math inline">\(.立刻见到\)</span>= 0 r { 0 , 1 } $.</p>
<h5><span id="简单应用">简单应用</span></h5>
<p>对于外代数来说,其最显然的应用是考虑$V = ^3 <span class="math inline">\(的情形,此时\)</span>^2 ( V ) <span class="math inline">\(有\)</span> _1 _2 , _1 _3 , _2 _3
$三个基,并且:</p>
<p><span class="math display">\[
\begin{aligned}
( x \vec { e  } _1 + y \vec { e  } _2 + z \vec { e  } _3 ) \wedge ( x
&#39; \vec { e  } _1 + y &#39; \vec { e  } _2 + z &#39; \vec { e  } _3 )
\\
&amp; = ( xy &#39; - x &#39; y ) ( \vec { e  } _1 \wedge \vec { e  } _2
) + ( yz &#39; - y &#39; z ) ( \vec { e  } _2 \wedge \vec { e  } _3 ) +
( zx &#39; - z &#39; x ) ( \vec { e  } _3 \wedge \vec { e  } _1 )
\end{aligned}
\]</span></p>
<p>这其实就是叉积对吧.</p>
<h4><span id="域的变换">域的变换</span></h4>
<p>对于域$F E <span class="math inline">\(,如果我们有一个定义在\)</span>F <span class="math inline">\(上的向量空间\)</span>V <span class="math inline">\(,我们想要一种策略将其典范地推广到\)</span>E <span class="math inline">\(上的向量空间\)</span>V _E $.</p>
<p>将$E <span class="math inline">\(视作一个\)</span>F <span class="math inline">\(向量空间.乘法映射\)</span>E E E <span class="math inline">\(当然是双线性映射,从而诱导出\)</span>E E E , x y xy
$的映射.</p>
<p>考虑一个$F <span class="math inline">\(向量空间\)</span>V
$,考虑下述线性映射:</p>
<p><span class="math display">\[
\begin{gathered}
E \times ( E \otimes _F V ) \to E \otimes _F ( E \otimes _F V ) \cong (
E \otimes _F E ) \otimes _F V \to E \otimes _F V \\
( x , y \otimes _F v ) \mapsto x \otimes _F ( y \otimes v ) \mapsto ( x
\otimes _F y ) \otimes _F v \mapsto ( xy ) \otimes _F v
\end{gathered}
\]</span></p>
<p>于是$E _F V <span class="math inline">\(成为了一个\)</span>E
$线性空间.</p>
<p>另一个重要的是检验如果$V , W <span class="math inline">\(都是\)</span>F <span class="math inline">\(向量空间,则上述拓展后\)</span> ( V _E , W _E )
<span class="math inline">\(亦然构成\)</span>E <span class="math inline">\(向量空间.而且我们还要检验如果原本的\)</span>f : V
W <span class="math inline">\(,则\)</span>f _E : V _E W _E $.</p>
<p>取$V <span class="math inline">\(的一组基\)</span>{ v <em>i } </em>{
i I } $,则:</p>
<p><span class="math display">\[
V _E = E \otimes _F ( \bigoplus _{ i \in I  } F v _i ) \cong \bigoplus
_{ i \in I  } ( E \otimes _F F ) \cong E ^{ \oplus I  }
\]</span></p>
<p>从而我们知道$V _E <span class="math inline">\(有一组基:\)</span>{ _i
= 1 _E v <em>i } </em>{ i I } <span class="math inline">\(,推论是\)</span>_F V = _E V _E $.</p>
<p>接下来将$ <em>F ( F ^n , F ^m ) <span class="math inline">\(等同于矩阵\)</span>A M </em>{ m n } ( F ) <span class="math inline">\(,我们下面验证\)</span>A _E = 1 _E A
$.只需发现:</p>
<p><span class="math display">\[
\begin{aligned}
A _E ( \tilde { e  } _i ) &amp; = ( 1 _E \otimes A ) ( 1 _E \otimes e _i
) \\
&amp; = 1 _E \otimes ( Ae _i ) \\
&amp; = 1 _e \otimes ( \sum _{ k = 1  } ^n a _{ k , i  } e _k ) \\
&amp; = \sum _{ k = 1  } ^n a _{ k , i  } ( 1 _E \otimes e _k ) \\
&amp; = \sum _{ k = 1  } ^n a _{ k , i  } \tilde { e _k  }
\end{aligned}
\]</span></p>
<p>考虑$i : V V _E , v _E v <span class="math inline">\(可以作为一个\)</span>F <span class="math inline">\(线性映射,方法是将\)</span>V _E <span class="math inline">\(限制成一个\)</span>F
$向量空间.这显然是一个单射.</p>
<p>下面假设$V <span class="math inline">\(是一个\)</span>F <span class="math inline">\(向量空间,\)</span> <span class="math inline">\(是一个\)</span>E
$向量空间,则我们下面来证明最后的结论:</p>
<p><span class="math display">\[
\begin{gathered}
\mathrm { Hom  } _E ( V _E , \tilde { V  } ) \cong \mathrm { Hom  } _F (
V , \tilde { V  } ) \\
\tilde { f  } \mapsto \tilde { f  } \circ i
\end{gathered}
\]</span></p>
<p>先证明这的确是一个单射,考虑:</p>
<p><span class="math display">\[
\tilde { f  } ( t \otimes v ) = \tilde { f  } ( t \cdot i ( v ) ) = t
\cdot ( \tilde { f  } \circ i ) ( v )
\]</span></p>
<p>由于$i <span class="math inline">\(是一个单射,所以这里如果非单,则存在两个\)</span> _1
, <span class="math inline">\(满足\)</span>v <span class="math inline">\(,\)</span>( _1 i ) ( v ) = ( _2 i ) ( v ) <span class="math inline">\(,必然导出\)</span>t v , _1 ( t v ) = _2 ( t v )
$.</p>
<p>接下来考虑其满射,对于$f _F ( V , ) <span class="math inline">\(,考虑\)</span>E V , ( t , v ) t f ( v ) <span class="math inline">\(当然是一个\)</span>F <span class="math inline">\(上的双线性映射,其对应了一个\)</span> : E _F V , t
v tf ( v ) $.这就论证了满性.</p>
<p>好吧,我们上面论证的一切都太过无趣,但请来总结,我们实际上是想要这么做:假设我有$F
<span class="math inline">\(上的向量空间\)</span>V <span class="math inline">\(,\)</span>E <span class="math inline">\(上的向量空间\)</span> <span class="math inline">\(以及它们之间的\)</span>F <span class="math inline">\(线性映射\)</span>f <span class="math inline">\(.关于这个\)</span>f <span class="math inline">\(的看法,如果我们将\)</span> <span class="math inline">\(拉到\)</span>F <span class="math inline">\(上当然是可以的对吧,那能不能将\)</span>V <span class="math inline">\(升上\)</span>E <span class="math inline">\(呢?我们想要一个资料\)</span>( <em>{ } , f </em>{ }
) $使得下述图表交换:</p>
<p><span class="math display">\[
\xymatrix { V \ar [r ] ^{ f _{ \mathrm { univ  }  }  } \ar [rd ] _{ f  }
&amp; \tilde { V  } _{ \mathrm { univ  }  } \ar [d ] ^{ \tilde { f  }  }
\\
&amp; \tilde { V  }  }
\]</span></p>
<p>我们上面所证明的就是这个资料$( <em>{ } , f </em>{ } ) <span class="math inline">\(可以取作\)</span>( E _F V , i ) $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3>
<p>三个柱子,$n
$个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T _n <span class="math inline">\(表示答案,显然\)</span>T _0 =
0 , T _1 = 1 $.</p>
<p>而我们一定可以找到一种方案,使得前$n - 1 <span class="math inline">\(个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把\)</span>n
- 1 <span class="math inline">\(个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:\)</span>T
<em>n T </em>{ n - 1 } + 1 $.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:$2
T _{ n - 1 } + 1 T _n <span class="math inline">\(.于是有\)</span>T
<em>n = 2 T </em>{ n - 1 } + 1 $.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4>
<p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4>
<p>考虑设$T <em>n <span class="math inline">\(为n个圆盘时的最小操作次数.假设已知\)</span>T
</em>{ n - 1 } $,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T
<em>{ n } = 3 T </em>{ n - 1 } + 2 , T _0 = 0 $.</p>
<p>考虑如何求该式子的封闭形式,令$W _n = T _n + 1 <span class="math inline">\(,显然有\)</span>W <em>n = 3 W </em>{ n - 1 } , W
_0 = 1 <span class="math inline">\(,显然\)</span>W _n = 3 ^n <span class="math inline">\(,有\)</span>T _n = 3 ^n - 1 $.</p>
<p>注意到$T _n
$刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4>
<p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2
^n - 1 $.</p>
<h4><span id="solution-2">Solution 2</span></h4>
<p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4>
<p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4>
<p>令$Q _n <span class="math inline">\(为将n个圆盘从A移动到B的最小操作次数,令\)</span>R
_n $为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q _0 = 0 , R _0 = 0 $.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q _n <span class="math inline">\(的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,\)</span>R
_n $的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q <em>n = 2 R </em>{ n - 1 } + 1 , 1 n $.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R <em>n = R </em>{ n - 1 } + 1 + Q <em>{ n - 1 } + 1 + R </em>{ n
- 1 } = Q <em>n + Q </em>{ n - 1 } + 1 , 1 n $.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4>
<p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4>
<p>a.仍然令$T _n <span class="math inline">\(为n对圆盘的最小操作次数,显然\)</span>T <em>n = 2 T
</em>{ n - 1 } + 2 , T _0 = 0 <span class="math inline">\(,可解得\)</span>T _n = 2 ^{ n + 1 } - 2 $.</p>
<p>b.令$Q <em>n <span class="math inline">\(为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现\)</span>Q
<em>n = T </em>{ n - 1 } + 1 + T </em>{ n - 1 } + 1 + T <em>{ n - 1 } +
1 + T </em>{ n - 1 } = 4 T _{ n - 1 } + 3 = 2 ^{ n + 2 } - 5 $.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q
_n $就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4>
<p>类似Problem11,但第$i <span class="math inline">\(大的圆盘有\)</span>k
_i $个.</p>
<h4><span id="solution-5">Solution 5</span></h4>
<p>无区别,只是$T <em>n = 2 T </em>{ n - 1 } + k _n , T _0 = 0 $.</p>
<p>如果求封闭形式的话,显然有$T <em>n = </em>{ i = 1 } ^n 2 ^{ n - i } k
_i $.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3>
<p>在上述问题中，我们已经有了以下式子：</p>
<p>$T <em>n = 2 T </em>{ n - 1 } + 1 , n &gt; 0 , T _0 = 0 $.</p>
<p>如果$n <span class="math inline">\(很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出\)</span>T
_n $的方法.</p>
<p>换句话说，我们想要把$T _n
$表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4>
<h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5>
解递归式:$Q _n =
<span class="math display">\[\begin{cases}\alpha &amp; n = 0 \\ \beta
&amp; n = 1 \\ \frac { ( 1 + Q _{ n - 1  } )  } { Q _{ n - 2  }  } &amp;
n &gt; 1 \end{cases}\]</span>
<p><span class="math inline">\(,保证\)</span>n , Q _n &gt; 0 $.</p>
<h5><span id="solution">Solution</span></h5>
<p>注意到$Q _2 = { } , Q _3 = { } , Q _4 = { } , Q _5 = , Q _6 = $.</p>
<p>显然该递归式存在长度为$5 $的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4>
<p>观察T序列的前几项，可以发现似乎有$T _n = 2 ^n - 1 $.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n = 0 $成立，显然可验证.</p>
<p>2.若该公式对$n = k <span class="math inline">\(时成立，那该公式必然对\)</span>n = k + 1
$成立.</p>
<p>因为有$T _{ k + 1 } = 2 T _k + 1 = 2 ^k + 2 - 1 = 2 ^{ k + 1 } - 1
$.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5>
<p>求证:$_{ i = 1 } ^n x <em>i ( { n } ) ^n , i N </em>+ , 1 i n , 0 x
_i $.</p>
<h5><span id="solution">Solution</span></h5>
<p>使用反向归纳法.</p>
<p>1.$n = 2 $时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n = k $时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A _1 = , B _1 = , A _2 = ( { k } ) , B _2 = ( { k } ) <span class="math inline">\(,显然有\)</span>A _1 A _2 , B _1 B _2 $.</p>
<p>同时有$( { 2 } ) $.</p>
<p>3.若该式子对$n = k <span class="math inline">\(时成立,则该式子对\)</span>n = k - 1
$的时候也成立.</p>
<p>令$x _k = { k - 1 } <span class="math inline">\(,有\)</span>x <em>k
</em>{ i = 1 } ^{ k - 1 } x _i ( x _k ) ^k $.</p>
<p>则显然$n = k - 1 $时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4>
<p>考虑令$U _n = T _n + 1 <span class="math inline">\(,显然有:\)</span>T
<em>n + 1 = 2 T </em>{ n - 1 } + 2 <span class="math inline">\(.即\)</span>U <em>n = 2 U </em>{ n - 1 } <span class="math inline">\(,显然\)</span>U _n = 2 ^n <span class="math inline">\(,则\)</span>T _n = 2 ^n - 1 $.</p>
<p>这个做法可以做掉所有形如$a _{ n + 1 } = pa _n + q
$的递归式.我们有:</p>
<p><span class="math display">\[
a _{ n + 1  } + \frac { q  } { p - 1  } = p ( a _n + \frac { q  } { p -
1  } )
\]</span></p>
<p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4>
<p>考虑递归式$a _n T _n = b <em>n T </em>{ n - 1 } + c _n <span class="math inline">\(.如果我们能找到一个不为0的求和因子\)</span>s _n
<span class="math inline">\(并满足\)</span>s <em>n b <em>n = s </em>{ n
- 1 } a </em>{ n - 1 } <span class="math inline">\(.那么我们两面同时乘以\)</span>s _n <span class="math inline">\(,显然有：\)</span>s <em>n a <em>n T <em>n = s
</em>{ n - 1 } a </em>{ n - 1 } T </em>{ n - 1 } + c _n s _n $.</p>
<p>令$S _n = s _n a _n T _n <span class="math inline">\(.显然有\)</span>S _n = s _0 a _0 T <em>0 + </em>{
i = 1 } ^n s _i c _i <span class="math inline">\(,则\)</span>T _n = { s
_n a _n } $.</p>
<p>而我们也会发现$s <em>n = { </em>{ i = 1 } ^n b _i } $.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5>
<p>结论:排序$n $个数时,其期望复杂度满足:</p>
<p><span class="math display">\[
C _n = \begin{cases}
0 &amp; n = 0 , 1 \\
n + 1 + \frac { 2  } { n  } \sum _{ i = 0  } ^{ n - 1  } C _k &amp; n
&gt; 1
\end{cases}
\]</span></p>
<p>不妨考虑两边同时乘以$n $,有 $nC <em>n = n ^2 + n + 2 </em>{ i = 0 }
^{ n - 1 } C _i , n &gt; 1 $ .</p>
<p>显然也有$( n - 1 ) C <em>{ n - 1 } = ( n - 1 ) ^2 + n - 1 + 2 </em>{
i = 0 } ^{ n - 2 } C _i , n &gt; 2 $.</p>
<p>二式相消,有$nC <em>n - ( n - 1 ) C </em>{ n - 1 } = 2 n + 2 C _{ n -
1 } , n &gt; 2 $.</p>
<p>而同时有$C _2 = 3 <span class="math inline">\(.即:\)</span>nC <em>n =
( n + 1 ) C </em>{ n - 1 } + 2 n , n &gt; 2 <span class="math inline">\(,可以使用转化和式的方法,两边乘以\)</span> { n ( n
+ 1 ) } $解决.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知$a _1 = 1 <span class="math inline">\(,\)</span>a _n = + <span class="math inline">\(,求\)</span>a _n $.</p>
<p>注意到$a _n = S <em>n - S </em>{ n - 1 } <span class="math inline">\(,则有\)</span> - = 1 <span class="math inline">\(,于是\)</span> = n <span class="math inline">\(,\)</span>S _n = n ^2 <span class="math inline">\(,\)</span>a _n = 2 n - 1 $.</p>
<h4><span id="成套方法">成套方法</span></h4>
<p>如果我们有</p>
<p>&amp; n=1\</p>
<p>2f(n 2)+&amp; n=2k,k\</p>
<p>2f(2)+&amp;n=2k+1,k</p>
<p>\end{cases}</p>
<p>其中$n = 2 ^m + l $且$2 ^m n &lt; 2 ^{ m + 1 } $.</p>
<p>该如何求出$f ( n ) $的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有$f ( n ) = A ( n ) + B ( n )
+ C ( n ) <span class="math inline">\(,而有\)</span>A 、 B 、 C <span class="math inline">\(互不影响且\)</span><span class="math inline">\(与\)</span>ABC $无关.</p>
<p>那无论$<span class="math inline">\(和\)</span><span class="math inline">\(的取值如何,\)</span>A ( n ) <span class="math inline">\(都不会受到影响,我们考虑\)</span>= = 0 <span class="math inline">\(的特殊情况,此时显然有\)</span>A ( n ) = 2 ^m
$.</p>
<p>接下来,我们考虑取$$的特殊值,去得到ABC之间的关系.</p>
<p>例如，当$f ( n ) = 1 <span class="math inline">\(时，由递推式可知\)</span>= 1 , = = - 1 <span class="math inline">\(,那么有\)</span>A ( n ) - B ( n ) - C ( n ) = f (
n ) = 1 $.</p>
<p>同理，$f ( n ) = n <span class="math inline">\(时，可知\)</span>= 1 ,
= 0 , = 1 <span class="math inline">\(,此时有\)</span>A ( n ) + C ( n )
= f ( n ) = n $.</p>
<p>显然可以通过解方程求得$B ( n ) <span class="math inline">\(和\)</span>C ( n ) $.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC <span class="math inline">\(互不影响且\)</span><span class="math inline">\(与\)</span>ABC $无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4>
<p>一个常系数的$k $阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n &amp;
\geq k \\
a _0 &amp; = C _0 , a _1 &amp; = C _1 , . . . , a _{ k - 1  } &amp; = C
_{ k - 1  }
\end{aligned}
\]</span></p>
<p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程$r ^k = _{ i = 1 } ^k c _i r ^{ k - i }
$是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根$r _1 <span class="math inline">\(和\)</span>r _2 <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r _1 ^n + _2 r _2 ^n
$.</p>
<p>若其特征方程有两个相同的根$r <span class="math inline">\(,那么存在两个常数\)</span>_1 <span class="math inline">\(和\)</span>_2 <span class="math inline">\(,满足\)</span>a _n = _1 r ^n + _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 <span class="math inline">\(或者\)</span>n = 1 <span class="math inline">\(的情况,我们考虑求出一组\)</span>_1 <span class="math inline">\(和\)</span>_2 $来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C _0 &amp; = \alpha _1 + \alpha _2 \\
C _1 &amp; = \alpha _1 r _1 + \alpha _2 r _2
\end{aligned}
\]</span></p>
<p>若$r _1 r _2 $,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha _1 &amp; = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 &amp; = C _0 - \alpha _1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } )
+ c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) +
\alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
&amp; = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有$= c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C _0 &amp; = \alpha _1 \\
C _1 &amp; = \alpha _1 r + \alpha _2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a _n &amp; = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
&amp; = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } -
\alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2
nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
&amp; = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n -
2  }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明$c _1 r + 2 c _2 = 0 <span class="math inline">\(即可.根据方程,不难发现\)</span>r = { 2 } <span class="math inline">\(,根据\)</span>= 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>直接在复数域上定义$f <em>k ( x ) = { n ^k x ^n } </em>{ n = 0 }
^$,此时我们规定$0 ^0 = 1 <span class="math inline">\(.特别地,当\)</span>x = 0 <span class="math inline">\(的时候,定义\)</span>f <em>k ( x ) <span class="math inline">\(的第\)</span>k $项是$1 $,其余项是$0 <span class="math inline">\(.在此基础上定义线性映射\)</span>T : ( a <em>n )
</em>{ n = 0 } ^( a </em>{ n + 1 } ) _{ n = 0 } ^<span class="math inline">\(,立刻见到:\)</span>( T - x ) ^{ k + 1 } f _k ( x )
= 0 , ( T - x ) ^k f _k ( x ) <span class="math inline">\(.原因只需简单数学归纳.而此还可以引出\)</span>f _0
( x ) , f _1 ( x ) , $线性无关.</p>
<p>在此基础上观察线性递推$a <em>{ n + d } = c </em>{ d - 1 } a _{ n + d
- 1 } + + c <em>0 a <em>n <span class="math inline">\(,不妨取\)</span>G
( x ) = x ^d - c </em>{ d - 1 } x ^{ d - 1 } - - c <em>0 <span class="math inline">\(,立刻应当见到如果\)</span>a <span class="math inline">\(是\)</span>G <span class="math inline">\(的根并且重数为\)</span>e ( a ) <span class="math inline">\(,那么\)</span>f </em>{ 0 } ( x ) , , f </em>{ e (
a ) - 1 } ( a ) <span class="math inline">\(都在\)</span>f ( T ) <span class="math inline">\(中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如\)</span>_j
w _i f _i ( y ) = _j w _j f _j ( x ) <span class="math inline">\(的情况,此时对右边直接操作若干次\)</span>( T - x )
$就可以把右边全部消成$0 <span class="math inline">\(,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于\)</span>n
<span class="math inline">\(的多项式右边的\)</span>( T - x ) <span class="math inline">\(是不会改变左边这边的每一个位置多项式的\)</span>$,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是$ <em>{ k + 1 } = A <span class="math inline">\(,\)</span> </em>{ n } = A ^n _0 <span class="math inline">\(.而我们又知道CH定理:\)</span>p ( A ) = 0 <span class="math inline">\(,我们用多项式取膜,有\)</span>A ^n = p ( A ) F ( A
) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3>
<p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是$2
, 4 , 6 , 8 , 10 , 3 , 7 , 1 , 9 $.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有$J ( 2 n ) = 2 J ( n ) - 1 <span class="math inline">\(;当人数是奇数时,我们杀掉一号,然后有\)</span>J ( 2
n + 1 ) = 2 J ( n ) + 1 $.</p>
<p>整理得到:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 1 \\
2 J ( \frac { n  } { 2  } ) - 1 &amp; n = 2 k , k \in \mathbb { N _+  }
\\
2 J ( \frac { n - 1  } { 2  } ) + 1 &amp; n = 2 k + 1 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>仍然可以使用数学归纳，如果令$n = 2 ^m + l 且 2 ^m n &lt; 2 ^{ m + 1 }
$.</p>
<p>有$J ( n ) = 2 l + 1 $.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从$0
$开始编号:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
0 &amp; n = 1 \\
2 J ( \frac { n  } { 2  } ) &amp; n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 &amp; n = 2 k + 1 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>这下相信$J ( n ) <span class="math inline">\(是多少就很显然了,将\)</span>n
$写成二进制的形式,这个就相当于把首位$1 $抹去然后在末尾加个$0 $.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4>
<p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4>
<p>显然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
2 &amp; n = 2 \\
1 &amp; n = 3 \\
2 J ( \frac { n  } { 2  } ) - 1 &amp; n = 2 k + 2 , k \in \mathbb { N
_+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 &amp; n = 2 k + 3 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>从$0 $开始编号,自然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 2 \\
0 &amp; n = 3 \\
2 J ( \frac { n  } { 2  } ) &amp; n = 2 k + 2 , k \in \mathbb { N _+  }
\\
2 J ( \frac { n - 1  } { 2  } ) + 2 &amp; n = 2 k + 3 , k \in \mathbb {
N _+  }
\end{cases}
\]</span></p>
<p>显然$J ( n ) $也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2>
<h3><span id="和式的基本运算">和式的基本运算</span></h3>
<p>分配律:</p>
<p><span class="math display">\[
\sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i
\]</span></p>
<p>一般分配律:</p>
<p><span class="math display">\[
\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum
_j b _j )
\]</span></p>
<p>结合律:</p>
<p><span class="math display">\[
\sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i
\in S  } b _i
\]</span></p>
<p>交换律:</p>
<p><span class="math display">\[
\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  }
\]</span></p>
<p>交换求和顺序:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] &amp; = \sum _{
j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] \\
\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } &amp; = \sum _{ j
= 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  }
\end{aligned}
\]</span></p>
<h3><span id="和式的封闭形式">和式的封闭形式</span></h3>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ( ai + b ) &amp; = \sum _{ i = 0  } ^n
( a ( n - i ) + b ) \\
2 S _n &amp; = \sum _{ i = 0  } ^n ( an + 2 b ) &amp; = an ( n + 1 ) + 2
b ( n + 1 ) \\
S _n &amp; = ( n + 1 ) ( \frac { an  } { 2  } + b )
\end{aligned}
\]</span></p>
<h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5>
<p>令$S = _{ 1 i &lt; j n } ( a _j - a _i ) ( b _j - b <em>i ) = </em>{
1 j &lt; i n } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 j &lt; i n ] + [ 1 i &lt; j n ] = [ 1 j , i n ] - [ 1
i = j n ] $.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S &amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i
) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
&amp; = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i )
\\
&amp; = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i
) ( \sum _{ j = 1  } ^n b _j ) \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) &amp; = n \sum
_{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a
_i ) ( b _j - b _i )
\end{aligned}
\]</span></p>
<p>显然有以下式子:</p>
<p>(_{i=1}<sup>na_i)(<em>{j=1}^nb_j)n</em>{i=1}</sup>na_ib_i，i&lt;j，a_ia_j且b_ib_j\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5>
<p>证明:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 &amp; = (
\sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum
_{ i = 1  } ^n a _i b _i ) ^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j )
^2 \\
2 S _n &amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a
_k b _j ) ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a
_j a _k b _j b _k + a _k ^2 b _j ^2 ) \\
&amp; = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2
) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n ax ^i \\
&amp; = a + \sum _{ i = 1  } ^n ax ^i \\
&amp; = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
&amp; = a + xS _{ n - 1  }
\end{aligned}
\]</span></p>
<p>而$S _{ n - 1 } + ax ^n = S <em>n = a + xS </em>{ n - 1 } <span class="math inline">\(,有\)</span>S _n + ax ^{ n + 1 } = a + xS _n , S
_n = a { x - 1 } <span class="math inline">\(，其中\)</span>x $.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 0  } ^n i ^2 &amp; = \sum _{ i = 0  } ^{ n -
1  } i ^2 + n ^2 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
&amp; = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2
\end{aligned}
\]</span></p>
<p>我们无法得到$S <em>n <span class="math inline">\(的封闭形式,但我们发现我们得到了\)</span></em>{ i =
1 } ^n i $的封闭形式.</p>
<p>那以此类推,我们设$W <em>n = </em>{ i = 0 } i ^3 $.</p>
<p><span class="math display">\[
\begin{aligned}
W _n &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
&amp; = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum
_{ i = 1  } ^n i - n + n ^3 \\
&amp; = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n &amp; = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
&amp; = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
&amp; = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
&amp; = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  }
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5>
<p>令$H <em>n = </em>{ k = 1 } ^n { k } <span class="math inline">\(,求\)</span>_{ i = 0 } ^n H _i $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>不妨考虑$<em>{ i = 0 } ^n iH </em>{ i } $的值.</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 0  } ^n iH _{ i  } &amp; = \sum _{ i = 1  } ^n [ ( i - 1 + 1
) H _{ i - 1  } + 1 ] \\
&amp; = n + \sum _{ i = 0  } ^{ n - 1  } H _i + \sum _{ i = 0  } ^{ n  }
iH _i - nH _n \\
\sum _{ i = 0  } ^{ n - 1  } H _i &amp; = n ( H _n - 1 ) \\
\sum _{ i = 0  } ^n H _i &amp; = ( n + 1 ) ( H _{ n + 1  } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5>
<p>求$S <em>n = </em>{ i = 0 } ^n ( - 1 ) ^{ n - i } , T <em>n = </em>{
i = 0 } ^n ( - 1 ) ^{ n - i } i , U <em>n = </em>{ i = 0 } ^n ( - 1 ) ^{
n - i } i ^2 $.</p>
<h5><span id="solution-4">Solution 4</span></h5>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ i = 1  } ^{ n  } ( - 1 ) ^{ n - i  } + ( - 1 ) ^n
\\
- S _{ n - 1  } + 1 &amp; = ( - 1 ) ^n + \sum _{ i = 0  } ^{ n - 1  } (
- 1 ) ^{ n - 1 - i  } \\
- S _{ n - 1  } + 1 &amp; = ( - 1 ) ^n + S _{ n - 1  } \\
S _{ n - 1  } &amp; = \frac { 1 - ( - 1 ) ^n  } { 2  } \\
S _n &amp; = \frac { 1 + ( - 1 ) ^n  } { 2  }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
T _{ n  } &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i \\
- T _{ n - 1  } + n &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i
- 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- T _{ n - 1  } + n &amp; = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n -
i - 1  } i + \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } - ( - 1 ) ^n \\
- T _{ n - 1  } + n &amp; = T _{ n - 1  } + S _n - ( - 1 ) ^n \\
n - \frac { 1 - ( - 1 ) ^n  } { 2  } &amp; = 2 T _{ n - 1  } \\
T _n &amp; = \frac { 1  } { 2  } ( n + 1 + \frac { - 1 - ( - 1 ) ^n  } {
2  } ) &amp; = \frac { 1  } { 2  } ( n + \frac { 1 - ( - 1 ) ^n  } {
2  } )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
U _n &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i ^2 \\
- U _{ n - 1  } + n ^2 &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } (
i - 1 + 1 ) ^2 \\
- U _{ n - 1  } + n ^2 &amp; = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } (
i - 1 ) ^2 + 2 \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum
_{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- U _{ n - 1  } + n ^2 &amp; = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n
- i - 1  } i ^2 + 2 \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  }
i + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } \\
- U _{ n - 1  } + n ^2 &amp; = U _{ n - 1  } + 2 T _{ n - 1  } + S _{ n
- 1  } \\
2 U _{ n - 1  } &amp; = n ^2 - 2 T _{ n - 1  } - S _{ n - 1  } \\
2 U _{ n - 1  } &amp; = n ^2 - ( n - \frac { 1 - ( - 1 ) ^n  } { 2  } )
- \frac { 1 - ( - 1 ) ^n  } { 2  } \\
2 U _{ n - 1  } &amp; = n ^2 - n \\
U _n &amp; = \frac { n ( n + 1 )  } { 2  }
\end{aligned}
\]</span></p>
<h4><span id="转化为递归式">转化为递归式</span></h4>
<p>考虑和式$S <em>n = </em>{ i = 0 } ^n f ( i ) = S _{ n - 1 } + f ( n )
\ $，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5>
<p>求$_{ i = 0 } ^n ( - 1 ) ^i i ^2 \ $.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>令$S ( n ) = _{ i = 0 } ^n ( - 1 ) ^i i ^2 = S ( n - 1 ) + ( - 1 ) ^n
n ^2 $,考虑使用成套方法.</p>
<p>不妨令$S ( n ) = S ( n - 1 ) + ( - 1 ) ^n ( + n + n ^2 ) = A ( n ) +
B ( n ) + C ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n , 可 以 解 得 = - 1 , = 2 , = 0 <span class="math inline">\(,有\)</span>( - 1 ) ^n n = - A ( n ) + 2 B ( n )
$.</p>
<p>令$S ( n ) = ( - 1 ) ^n n ^2 , 可 以 解 得 = 1 , = - 2 , = 2 <span class="math inline">\(,有\)</span>( - 1 ) ^n n ^2 = A ( n ) - 2 B ( n )
+ 2 C ( n ) $.</p>
<p>显然可解得$2 C ( n ) = ( - 1 ) ^n n ^2 + ( - 1 ) ^n n , C ( n ) = ( -
1 ) ^n { 2 } $.</p>
<p>而原式中,$S ( n ) = C ( n ) = ( - 1 ) ^n { 2 } $.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5>
<p>有$2 T <em>n = nT </em>{ n - 1 } + 3 n ! , T _0 = 5 <span class="math inline">\(,求\)</span>T _n $.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p>令$s _n = { n ! } <span class="math inline">\(,两边同时乘以\)</span>s
_n <span class="math inline">\(,有\)</span> { n ! } T <em>n = { ( n - 1
) ! } T </em>{ n - 1 } + 3 ^{ n - 1 } \ $.</p>
<p>令$S _n = { n ! } T _n $,有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = S _{ n - 1  } + 3 \times 2 ^{ n - 1  } \\
&amp; = 5 + 3 \sum _{ i = 0  } ^{ n - 1  } 2 ^i \\
&amp; = 5 + 3 \times 2 ^{ n + 1  } - 3 \\
&amp; = 3 \times 2 ^{ n  } + 2 \\
T _n &amp; = 3 n ! + \frac { n !  } { 2 ^{ n - 1  }  }
\end{aligned}
\]</span></p>
<h4><span id="转化为积分形式">转化为积分形式</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数$f ( x ) = x ^2 <span class="math inline">\(,显然\)</span>_0
^n x ^2 dx = { 3 } S _n \ $.</p>
<p>接下来,我们考虑求得二者之间的误差,设$E _n = S _n - { 3 } \
$,对其使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
E _n &amp; = S _n - \frac { n ^3  } { 3  } \\
&amp; = S _{ n - 1  } + n ^2 - \frac { ( n - 1 + 1 ) ^3  } { 3  } \\
&amp; = S _{ n - 1  } + n ^2 - \frac { ( n - 1 ) ^3  } { 3  } - ( n - 1
) ^2 - ( n - 1 ) - \frac { 1  } { 3  } \\
&amp; = E _{ n - 1  } + n ^2 - n ^2 + 2 n - 1 - n + 1 - \frac { 1  } {
3  } \\
&amp; = E _{ n - 1  } + n - \frac { 1  } { 3  }
\end{aligned}
\]</span></p>
<p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<p><span class="math display">\[
\begin{aligned}
E _n &amp; = S _n - \int _0 ^n x ^2 dx \\
&amp; = \sum _{ k = 1  } ^n ( k ^2 - \int _{ k - 1  } ^k x ^2 dx ) \\
&amp; = \sum _{ k = 1  } ^n ( k ^2 - \frac { k ^3 - ( k - 1 ) ^3  } {
3  } ) \\
&amp; = \sum _{ k = 1  } ^n ( k - \frac { 1  } { 3  } )
\end{aligned}
\]</span></p>
<p>这是一个简单的和式.而$S _n = E _n + { 3 } \ $,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5>
<p>已知$a <em>1 = 1 , a </em>{ n + 1 } - a _n = - { 3 } a _n ^2 <span class="math inline">\(,估计\)</span>a _n $的值.</p>
<p>考虑构造一个函数$f ( n ) <span class="math inline">\(使得\)</span>f (
n ) a <em>n <span class="math inline">\(,那我们就可以将\)</span>a </em>{
n + 1 } - a _n f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$x
_0 , f ’ ( x _0 ) = f ( n + 1 ) - f ( n ) <span class="math inline">\(,而对于增长率变化不大的函数,直接认为\)</span>f ’ (
x _0 ) = f ’ ( n ) $是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 <span class="math inline">\(解得\)</span>f ( n ) = { n + 2 }
$.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令$a _n = { n + 2 } - b _n <span class="math inline">\(,带入化简,得到\)</span>{ b _n } $的递推式:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } &amp; = ( \frac { 3  } { n +
2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } )
\\
b _{ n + 1  } - \frac { 3  } { n + 3  } &amp; = ( b _n - \frac { 3  } {
n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 &amp; = 0 , b _{ n + 1  } &amp; = \frac { b _n ^2  } { 3  } + \frac
{ n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  }
\end{aligned}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出$b _n { 4 n }
$,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n <span class="math inline">\(的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设\)</span>b
_n ^2 &lt; &lt; b _n $:</p>
<p>那么这个$b _n <span class="math inline">\(是\)</span>O ( { n ^2 } )
$级别的.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
b _{ n + 1  } &amp; = \frac { n  } { n + 2  } b _n + \frac { 1  } { n (
n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } &amp; = n ( n + 1 ) b _n + \frac {
1  } { n  } \\
g ( n ) &amp; = n ( n + 1 ) b _n , g &#39; ( n ) &amp; = \frac { 1  } {
n  } , g ( n ) &amp; = \ln n \\
b _n &amp; = \frac { \ln n  } { n ^2  }
\end{aligned}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ } ) <span class="math inline">\(和\)</span>O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n { n ( n + 1 ) } $.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S _n &amp; = \sum _{ k = 1  } ^n k ^2 \\
&amp; = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
&amp; = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 )
\\
&amp; = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 -
ni + n ) \\
&amp; = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  }
^n i ^2 + n ^3 + n ^2 ) \\
&amp; = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n +
\frac { n ^3 + n ^2  } { 2  }
\end{aligned}
\]</span></p>
<p>整理得到$S _n $.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5>
<p>求$_{ i = 1 } ^n i 2 ^i \ $.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n i 2 ^i &amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  }
^i 2 ^i \\
&amp; = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n 2 ^i \\
&amp; = \sum _{ j = 1  } ^n ( 2 ^{ n + 1  } - 2 ^j ) \\
&amp; = n 2 ^{ n + 1  } - ( 2 ^{ n + 1  } - 2 ) \\
&amp; = ( n - 1 ) 2 ^{ n + 1  } + 2
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5>
<p>求$_{ i = 1 } ^n i ^3 \ $.</p>
<h5><span id="solution-3">Solution 3</span></h5>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum _{ i = 1  } ^n i ^3 \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
&amp; = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
&amp; = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  }
- \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
&amp; = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } {
3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n (
n + 1 )  } { 12  } \\
S ( n ) &amp; = \frac { n ^2 ( n + 1 ) ^2  } { 4  }
\end{aligned}
\]</span></p>
<h5><span id="exampleex">ExampleEX</span></h5>
<p>求$_{ i = 1 } ^n iq ^i ( q ) $.</p>
<h5><span id="solutionex">SolutionEX</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n iq ^i &amp; = \sum _{ j = 1  } ^n \sum _{ i = j  }
^n q ^i \\
&amp; = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  }
\\
&amp; = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q
^j ) \\
&amp; = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  }
- q  } { q - 1  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="exampleex2">ExampleEX2</span></h5>
<p>求$_{ i = 1 } ^n ( ai + b ) q ^{ i - 1 } ( q ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令$A = { q - 1 } , B = { q - 1 } <span class="math inline">\(,答案为\)</span>( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子$E <span class="math inline">\(，使得\)</span>Ef ( x ) =
f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子$f ( x ) = f ( x + 1 ) - f ( x )
$，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$= E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子$$,可以得到有限微积分的基本定理:</p>
$$
<span class="math display">\[\begin{aligned}
g ( x ) &amp; = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x
&amp; = f ( x ) + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里的$<span class="math inline">\(又被称为不定和式,是差分等于\)</span>g
$的一个函数类.</p>
<p>值得一提的是,这里的$C <span class="math inline">\(与无限微积分中的\)</span>C <span class="math inline">\(有一定区别,这里的\)</span>C <span class="math inline">\(可以是满足\)</span>p ( x ) = p ( x + 1 )
$的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果$g ( x ) = f ( x ) <span class="math inline">\(,那么有\)</span>_{
a } ^b g ( x ) x = f ( x ) | ^{ b } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a b <span class="math inline">\(,显然有\)</span><em>{ a } ^b g ( x ) x = </em>{ x
= a } ^{ b - 1 } g ( x ) \ $.</p>
<p>但如果$a &gt; b <span class="math inline">\(,那么\)</span>_{ a } ^b g
( x ) x = - _b ^a g ( x ) x \ $.</p>
<p>事实上,我们一定有:$_a ^b g ( x ) x + _b ^c g ( x ) x = _a ^c g ( x )
x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1 } $，有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( x ^{ \underline { m  }  } ) &amp; = mx ^{ \underline { m -
1  }  } \\
\sum mx ^{ \underline { m - 1  }  } \delta x &amp; = x ^{ \underline {
m  }  } + C , m \ne 0 \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的$D ( x ) = { x } $,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( H ( x ) ) &amp; = x ^{ \underline { - 1  }  } &amp; = \frac {
1  } { x + 1  } \\
\sum x ^{ \underline { - 1  }  } \delta x &amp; = H ( x ) + C \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( 2 ^x ) &amp; = 2 ^x , \sum 2 ^x \delta x &amp; = 2 ^x + C \\
\Delta ( c ^x ) &amp; = ( c - 1 ) c ^x , \sum c ^x \delta x &amp; =
\frac { c ^x  } { c - 1  } + C , c \ne 1 \\
\Delta ( c ^{ \underline { x  }  } ) &amp; = \frac { c ^{ \underline { x
+ 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  }
{ c - x  } \delta x &amp; = c ^{ \underline { x  }  } + C , c - x \ne 0
\\

\end{aligned}\]</span>
<p>$$</p>
<p>根据组合数公式,有:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta ( \binom { x  } { k  } ) &amp; = \binom { x  } { k - 1  } \\
\sum \binom { x  } { k - 1  } \delta x &amp; = \binom { x  } { k  } + C
\end{aligned}
\]</span></p>
<h6><span id="example平方和公式">Example(平方和公式)</span></h6>
<p>我们有:$k ^2 = k ^{ } + k ^{ } \ $.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S _{ n - 1  } &amp; = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
&amp; = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{
\underline { 1  }  } ) \\
&amp; = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x +
\sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
&amp; = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline
{ 2  }  }  } { 2  }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5>
<p>考虑一阶差分是$f ( x ) = f ( x + 1 ) - f ( x ) <span class="math inline">\(,那么二阶差分就是\)</span>^2 f ( x ) = f ( x + 2 )
- 2 f ( x + 1 ) + f ( x ) $.</p>
<p>类似地,我们可以通过归纳法证明$^n f ( x ) = _{ k } { k } ( - 1 ) ^{ n
- k } f ( x + k ) \ $.</p>
<p>事实上有一种更简单的证明方法,由于$= E - 1 <span class="math inline">\(,于是\)</span>^n = ( E - 1 ) ^n = _{ k } { k } ( -
1 ) ^{ n - k } E ^k \ <span class="math inline">\(,由于\)</span>E ^k f (
x ) = f ( x + k ) $,即可证明原式.</p>
<p>另外,不难发现如果$f ( x ) <span class="math inline">\(是一个关于\)</span>x <span class="math inline">\(的\)</span>d <span class="math inline">\(次多项式,那么\)</span>f ( x ) <span class="math inline">\(是一个\)</span>d - 1 <span class="math inline">\(次多项式.同理,\)</span>^d f ( x ) <span class="math inline">\(会是一个常数而\)</span>^{ d + 1 } f ( x ) $会是$0
$,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6>
<p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为$x
_1 , x _2 $.</p>
<p>不难写出期望转移式子:$f <em>i = { 2 } ( f </em>{ i - 1 } + f <em>{ i
+ 1 } ) + 1 <span class="math inline">\(,并且\)</span>f </em>{ x <em>1 }
= f </em>{ x _2 } = 0 $.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1
\\
2 f _i &amp; = f _{ i - 1  } + f _{ i + 1  } + 2 \\
f _i - f _{ i - 1  } &amp; = f _{ i + 1  } - f _i + 2 \\
\Delta f _{ i - 1  } &amp; = \Delta f _{ i  } + 2 \\
\Delta f _i - \Delta f _{ i - 1  } &amp; = - 2 \\
\Delta ^2 f _{ i - 1  } &amp; = - 2
\end{aligned}
\]</span></p>
<p>$f <span class="math inline">\(的二阶差分是常数,也就是说\)</span>f
<span class="math inline">\(是二次多项式,不难求得其二次项系数为\)</span>- 1
<span class="math inline">\(又知道两个零点,显然可以得到\)</span>f
$的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5>
<p>令$f ( x ) = _{ 0 i d } a <em>i x ^i \ <span class="math inline">\(.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为\)</span>f
( x ) = </em>{ 0 i d } b _i x ^{ } \ $.</p>
<p>我们设$c _i = i ! b <em>i <span class="math inline">\(,于是有:\)</span>f ( x ) = </em>{ 0 i d } c _i { i
} \ $.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为$f
( x ) $的牛顿级数.</p>
于是不难发现有:$^n f ( x ) = _{ 0 i d } c _i { i - n } \ <span class="math inline">\(.如果我们令\)</span>x = 0 <span class="math inline">\(,则有:\)</span>^n f ( 0 ) =
<span class="math display">\[\begin{cases}c _n &amp; n \leq d \\ 0 &amp;
n &gt; d \end{cases}\]</span>
<p><span class="math inline">\(.那么牛顿级数的另一种表示即:\)</span>f (
x ) = _{ 0 i d } ^i f ( 0 ) { d } \ $.</p>
<p>另外,如果我们展开一下$c _n = ^n f ( 0 ) $,我们可以得到公式:</p>
<p>$<em>{ k } { k } ( - 1 ) ^k ( </em>{ 0 i n } c _i { i } ) = ( - 1 )
^n c _n , n \ $.</p>
<p>如果我们将多项式还原,由于$a _n = b _n $,有:</p>
<p>$<em>{ k } { k } ( - 1 ) ^k ( </em>{ 0 i n } a _i k ^i ) = ( - 1 ) ^n
n ! a _n , n \ $.</p>
<p>另外,如果$x <span class="math inline">\(,那么我们有:\)</span>f ( x )
= _{ 0 k } ^k f ( 0 ) { 0 } <span class="math inline">\(,根据多项式推理法,这个公式对\)</span>x
$都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<p><span class="math display">\[
g ( a + x ) = \sum _{ 0 \leq k  } \cfrac { \Delta ^k g ( a )  } { k !  }
x ^{ \underline { k  }  }
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>求$_{ k } { k } { n } ( - 1 ) ^k , n \ $.</p>
<p>如果我们令$f ( k ) = { n } = _{ 0 i n } a _i k ^i \ <span class="math inline">\(,不难发现\)</span>a _n = { n ! } <span class="math inline">\(,于是显然原式\)</span>= s ^n $.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v &amp; = Ev \Delta u + u
\Delta v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p>$u v = uv - Ev u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i &amp; = a _r
b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i +
1  } - b _i ) \\
\sum _{ i = l  } ^{ r - 1  } ( \Delta a _i ) b _i &amp; = a _r b _r - a
_l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( \Delta b _i )
\end{aligned}
\]</span></p>
<p>对于$l = 0 , r = n , a _0 = b _0 = 0 $的特殊情况,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i &amp; = a _n b _n -
\sum _{ i = 0  } ^{ n - 1  } a _{ i + 1  } ( \Delta b _i ) \\
\sum _{ i = 1  } ^n a _i ( b _{ i + 1  } - b _i ) &amp; = a _n b _n -
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i
\end{aligned}
\]</span></p>
<p>取两组数列$, <span class="math inline">\(,并令\)</span>_{ i = 1 } ^n
_i = B _i $,立刻有:</p>
<p><span class="math display">\[
\sum _{ i = 1  } ^n \alpha _i \beta _i = \alpha _n B _n - \sum _{ i =
1  } ^{ n - 1  } ( \alpha _{ i + 1  } - \alpha _i ) B _i
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求$_{ k = 0 } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$x 2 ^x x = x 2 ^x - ^{ x + 1 } x = x 2 ^x - 2 ^{ x + 1 } + C \
$.</p>
<p>改为定和式形式，显然有:</p>
<p>$_{ k = 0 } ^n k 2 ^k = _0 ^{ n + 1 } x 2 ^x x = ( n + 1 ) 2 ^{ n + 1
} - 2 ^{ n + 2 } + 2 = ( n - 1 ) 2 ^{ n + 1 } + 2 \ $.</p>
<h6><span id="example2">Example2</span></h6>
<p>求$_{ k = 0 } ^{ n - 1 } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = { 2 } x ^{ } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$xH _x x = { 2 } H _x - { 4 } + C \ $.</p>
<p>带入即可求出原式$= { 2 } ( H _n - { 2 } ) \ $.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6>
<p>求$_{ i = 1 } ^n { i ( i + 1 ) } \ $.</p>
<h6><span id="solution-3">Solution 3</span></h6>
<p>令$u = ( 2 n + 1 ) , v = - { i } <span class="math inline">\(,则\)</span>u = 2 , v = { i ( i + 1 ) } $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } &amp; = ( 2 n +
3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( -
\frac { 2  } { i + 1  } ) \\
&amp; = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n
+ 1  } &amp; = 2 H _n - \frac { n  } { n + 1  }
\end{aligned}
\]</span></p>
<h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6>
<p>求$_{ i = 0 } ^{ n - 1 } { ( k + 1 ) ( k + 2 ) } \ $.</p>
<h6><span id="solution-4">Solution 4</span></h6>
<p>令$u = H _n , v = - { n + 1 } , u = { n + 1 } , v = { ( n + 1 ) ( n +
2 ) } \ $.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  }
&amp; = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( -
\frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } (
\frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
&amp; = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  }
{ n + 1  } ) \\
&amp; = 1 - \frac { H _n + 1  } { n + 1  }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">贪心与构造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="贪心">贪心</span></h2>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了$t <span class="math inline">\(个消息\)</span>a _1 , a _2 , . . . , a _t <span class="math inline">\(,那么答案就是\)</span> { t } <span class="math inline">\(.显然如果\)</span>t <span class="math inline">\(固定,那么每个\)</span>a _j <span class="math inline">\(的贡献是独立的.于是只需要枚举\)</span>t
$然后取贡献最大的.</p>
<p>但是,如果$t &gt; { k _i } <span class="math inline">\(,这个时候\)</span>t - 1 <span class="math inline">\(的答案是\)</span>t - 1 <span class="math inline">\(个数之和除以\)</span>t - 1 <span class="math inline">\(,\)</span>t <span class="math inline">\(的答案是这\)</span>t - 1 <span class="math inline">\(个数之和加上另一个更小的数除以\)</span>t
$,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度$O ( n { k _i } ) $.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分($b <em>{ i , j } = a </em>{ i , j } a <em>{ i +
1 , j } a </em>{ i , j + 1 } a _{ i + 1 , j + 1 }
$)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是$0
$了,那么矩阵外不可能是$1 $,也就是原矩阵也全都是$0 $了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成$0
$才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对$( x , y ) <span class="math inline">\(使用操作四,那我们不可能再对一个\)</span>( x , i )
$使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有$b <em>{ x , y } , b </em>{ n , y } , b
<em>{ x , m } $都是$1
$的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个$1
$,所以一定不如直接用一操作来的划算.不然,如果三个都是$1 <span class="math inline">\(,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后\)</span>b
</em>{ n , m } $变成$1 $了,再不行也可以使用一次$1 $操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果$b
<em>{ x , y } , b </em>{ n , y } , b _{ x , m } $都是$1 <span class="math inline">\(,我们就把\)</span>x <span class="math inline">\(到\)</span>y
$连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i
$条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最小值,\)</span>g _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最大值.假设我们目前二分的最大值要小于等于\)</span>mx
<span class="math inline">\(,最小值要大于等于\)</span>mn
$,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i + 1  } &amp; = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } &amp; = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$f <span class="math inline">\(与\)</span>g <span class="math inline">\(的转移是无关的,而显然对于第\)</span>i <span class="math inline">\(个分界点,它可以取\)</span>[ f _i , g _i ]
$中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans <em>{ i } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(条分界线是啥,那么我们\)</span>ans <em>i <span class="math inline">\(是可以取\)</span>[ ans <em>{ i + 1 } - mx , ans
</em>{ i + 1 } - mn ] <span class="math inline">\(中的任何一个数字的,我们将其和上面求出的\)</span>[
f _i , g _i ] <span class="math inline">\(求一下交集.如果交集为空,说明要么\)</span>ans
</em>{ i + 1 } - mn &lt; f <em>i , f </em>{ i + 1 } &lt; ans </em>{ i +
1 } &lt; f _i + mn <span class="math inline">\(,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差\)</span>mx
- mn $.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对$( l , r ) <span class="math inline">\(,我们想给每一个点对赋值:\)</span>a _l = i , a
<em>r = n - i + 1 <span class="math inline">\((注意如果\)</span>n <span class="math inline">\(是奇数,那么中心点应该是\)</span>a </em>{ mid } = {
2 } $),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对$( l _1 , r _1 ) <span class="math inline">\(,\)</span>( l _2 , r _2 ) <span class="math inline">\(之间的三种可能的关系:不交,包含,相交且不包含.会发现若\)</span>l
<span class="math inline">\(小则让\)</span>a _l $尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个$ <span class="math inline">\(操作很奇怪.我们不妨这么考虑:设最后的答案序列为\)</span>b
<span class="math inline">\(,那么答案其实就是\)</span>| b _i - a _i |
<span class="math inline">\(.这实际上是什么呢?实际上是数轴上\)</span>a
_i <span class="math inline">\(和\)</span>b _i <span class="math inline">\(之间的距离.既然这样,那么我们同时反转\)</span>a
<span class="math inline">\(和\)</span>b <span class="math inline">\(,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个\)</span>a
<span class="math inline">\(,将它和\)</span>x <span class="math inline">\(同时反转,那么答案不变.这么做后我们可以直接清空所有\)</span>a
<span class="math inline">\(的最高位,只剩下\)</span>x $可能有最高位.</p>
<p>那$x <span class="math inline">\(的最高位一定会让若干\)</span>a <span class="math inline">\(往上变成它.注意到最多只会有一个\)</span>a <span class="math inline">\(会向上满足\)</span>x <span class="math inline">\(的最高位.证明的话同样考虑取反,如果有两个\)</span>a
<span class="math inline">\(满足\)</span>a _i b _i <span class="math inline">\(和\)</span>a _j b _j $这一位是$1 <span class="math inline">\(,我们仍然考虑数轴,有\)</span>| not ( b _i ) - a _i
| | a _i - b _i | <span class="math inline">\(,这由\)</span>a _i b _i
$最高位是$1 $导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个$a <span class="math inline">\(上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的\)</span>a
$可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作$[ l , r , k ] <span class="math inline">\(表示可以将\)</span>a [ l r ] <span class="math inline">\(减一进行至多\)</span>k
$次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个$- 1 <span class="math inline">\(,另一个\)</span>- 2 $,求使得整个序列都小于等于$0
$的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p></li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p></li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p></li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做$( - 2 , -
1 ) <span class="math inline">\(,最后不够了再加个\)</span>( - 1 , - 2 )
$补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候$( - 1 , - 2 ) + ( - 1
, - 2 ) <span class="math inline">\(比\)</span>( - 2 , - 1 )
$更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做$( - 2 , - 1 )
<span class="math inline">\(,最后不够了再加个\)</span>( - 1 , - 2 )
<span class="math inline">\(补一下.我们通过样例以及其它栗子发现:有的时候\)</span>(
- 1 , - 2 ) + ( - 1 , - 2 ) <span class="math inline">\(比\)</span>( - 2
, - 1 ) <span class="math inline">\(更优秀,这启发我们:能不能在做后面位置的时候将前面的\)</span>(
- 2 , - 1 ) <span class="math inline">\(变成\)</span>( - 1 , - 2 ) + ( -
1 , - 2 ) <span class="math inline">\(呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个\)</span>(
- 2 , - 1 ) <span class="math inline">\(操作,那么我可以在这个位置进行一个\)</span>( 0 , -
3 ) <span class="math inline">\(操作.显然\)</span>( 0 , - 3 ) + ( - 2 ,
- 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2 ) $.我们完成了反悔的操作!</p>
<p>但是,我们直接认为$( - 1 , - 2 ) <span class="math inline">\(不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个\)</span>(
- 1 , - 2 ) + ( - 1 , - 2 ) <span class="math inline">\(,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑\)</span>(
- 3 , 0 ) <span class="math inline">\(怎么反悔.这个看上去很疑惑:我们为了使\)</span>( - 2
, - 1 ) <span class="math inline">\(变成\)</span>( - 1 , - 2 ) + ( - 1 ,
- 2 ) <span class="math inline">\(而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在\)</span>(
- 2 , - 1 ) $的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:$( - 3 , 0 ) <span class="math inline">\(这个技能的发动是有前提条件的:前面必须有\)</span>(
- 2 , - 1 ) <span class="math inline">\(才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个\)</span>(
- 2 , - 1 ) <span class="math inline">\(,也很清楚每个地方用了几个\)</span>( - 3 , 0 )
$.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:$( - 3 , 0 ) ( - 1 , - 2
) + ( - 2 , - 1 ) = ( - 3 , 0 ) + ( 0 , - 3 ) <span class="math inline">\(,或者\)</span>( - 3 , 0 ) ( - 1 , - 2 ) + ( - 1 ,
- 2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3 ) $.</p>
<p>最后遇到一个点,能用$( 0 , - 3 ) <span class="math inline">\(就用\)</span>( 0 , - 3 ) <span class="math inline">\(,不够用的再补齐.这个原因也很简单:如果我们在这里不用\)</span>(
- 3 , 0 ) <span class="math inline">\(而用其它的代替的话,你会发现无论如何都等价于\)</span>(
- 3 , 0 ) $然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的$(
- 2 , - 1 ) <span class="math inline">\(和\)</span>( - 1 , - 2 ) <span class="math inline">\(的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的\)</span>(
- 3 , 0 )
$操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为$n <span class="math inline">\(的序列\)</span>a <span class="math inline">\(,保证\)</span>a _1 = a _n = 1 <span class="math inline">\(.每次你可以选择一个\)</span>i ( 1 &lt; i &lt; n )
<span class="math inline">\(将\)</span>a <em>i <span class="math inline">\(删去并付出\)</span>a </em>{ i - 1 } a <em>i a
</em>{ i + 1 } <span class="math inline">\(的代价.删去\)</span>a _i
$后序列两端会接起来,求删成两个$1 $的最小代价.</p>
<p>首先注意到,如果有一个$1 &lt; i &lt; n <span class="math inline">\(满足\)</span>a _i = 1
$,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要$1
$的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个$1
<span class="math inline">\(所划分.接下来我们只考虑中间所有数\)</span>
$的情况.</p>
<p>再思考一个事实:当$a , b <span class="math inline">\(时,一定有\)</span>ab a + b <span class="math inline">\(.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是\)</span><em>{
i = 2 } ^{ n - 2 } a <em>i a </em>{ i + 1 } + </em>{ i = 2 } ^{ n - 1 }
{ a _i }
$.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造$a
$数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值$a _i
$,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑$a _i <span class="math inline">\(互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数\)</span>$还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在$a <em>i <span class="math inline">\(相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的\)</span>(
a <em>i , a </em>{ i + 1 } ) <span class="math inline">\(,然后这么选:\)</span>a <em>i , a </em>{ i + 1 } ,
a <em>n , a </em>{ i - 1 } , a </em>{ n - 1 } , a _{ i - 2 } . . .
$,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在$a _i
$上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是$a <span class="math inline">\(和\)</span>b $,其中$2 a &lt; b <span class="math inline">\(.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果\)</span>b
<span class="math inline">\(之前吃过别的鱼,假设是\)</span>c <span class="math inline">\(和\)</span>d <span class="math inline">\((不妨假设\)</span>d c <span class="math inline">\(),有\)</span>b = c + d <span class="math inline">\(,由鸽笼原理,发现\)</span>d &gt; a <span class="math inline">\(.这意味着:如果\)</span>a <span class="math inline">\(都没被操作掉,那么\)</span>d <span class="math inline">\(必不可能被操作掉,这也就是说\)</span>b <span class="math inline">\(不可能出现.因此\)</span>b <span class="math inline">\(在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于\)</span>b
<span class="math inline">\(,且\)</span>a <span class="math inline">\(就是所有一开始小于\)</span>b $的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是$w
<em>i &gt; 2 </em>{ j = 1 } ^{ i - 1 } w _j
$,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多$w <span class="math inline">\(个,我们考虑一下这个两倍的用处,我们按照值域\)</span>[
1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , . . . , [ 2 ^{ k - 1 } + 1
, 2 ^k ]
$将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定$n
$个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><p>$S $表示标准球.</p></li>
<li><p>$&lt; A , B &gt; <span class="math inline">\(表示称量集合\)</span>A <span class="math inline">\(和集合\)</span>B <span class="math inline">\(,\)</span>&lt; A , B &gt; = 0 <span class="math inline">\(表示平衡,\)</span>&lt; A , B &gt; = A <span class="math inline">\(表示\)</span>A <span class="math inline">\(较重,\)</span>&lt; A , B &gt; = B <span class="math inline">\(表示\)</span>B $较重.</p></li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量$x <span class="math inline">\(有\)</span>n <span class="math inline">\(种取值,出现概率分别为\)</span>p _1 , p _2 , , p _n
<span class="math inline">\(,则其熵为\)</span>H ( x ) = f ( p _1 , p _2
, , p _n ) = <span class="math inline">\(,\)</span>C $为正整数,通常取$1
$.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量$x <span class="math inline">\(的一个熵为\)</span>h <span class="math inline">\(的信息后,\)</span>x <span class="math inline">\(的熵会减少\)</span>h $.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有$n
<span class="math inline">\(个球,每个球等概率成为次品,因此总熵是\)</span>n
<span class="math inline">\(,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是\)</span>
<span class="math inline">\(,也就是说我们至少要猜\)</span> { } = _3 n
<span class="math inline">\(次.如果我们不知道次品的轻重,那么至少要猜\)</span>
{ } = _3 2 n $次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p>$n <span class="math inline">\(个叶子的树的最小深度是\)</span>_3 n
$,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设$f ( n ) <span class="math inline">\(表示有\)</span>n <span class="math inline">\(个球的最少次数,注意到\)</span>f ( 3 ) = 1 $.</p>
<p>根据信息论,$f ( n ) _3 n $,下面证明等号成立:</p>
<p>首先考虑证明$f ( 3 ^m ) = m <span class="math inline">\(,\)</span>m =
1 <span class="math inline">\(时已经得证.\)</span>m &gt; 1 <span class="math inline">\(时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此\)</span>f
( 3 ^m ) f ( 3 ^{ m - 1 } ) + 1 <span class="math inline">\(.综合信息论下界\)</span>f ( 3 ^m ) m <span class="math inline">\(,我们不难得出以上结论.至于\)</span>n ^m <span class="math inline">\(的情况,我们类似这个过程按照\)</span>n <span class="math inline">\(的值讨论一下即可,于是有\)</span>f ( n ) f ( { 3 }
) + 1 $.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,$f ( n ) _3 2 n $.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有$n <span class="math inline">\(个球,第二堆有\)</span>m <span class="math inline">\(个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是\)</span>g
( n , m ) <span class="math inline">\(,则\)</span>g ( n , m ) = _3 ( n +
m ) $.</p>
<p>先证明信息论下界,不难发现仍然是$g ( n , m ) = _3 ( n + m ) $.</p>
<p>首先不难发现,$g ( 1 , 0 ) = g ( 0 , 1 ) = 0 , g ( 1 , 1 ) = g ( 2 , 0
) = g ( 0 , 2 ) = 1 $.</p>
<p>仍然使用数学归纳,假设$n + m &lt; k ( k ) <span class="math inline">\(的时候成立,我们接下来证明\)</span>n + m = k
$的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若$n = 3 p , m = 3 q <span class="math inline">\(,我们将\)</span>n
<span class="math inline">\(分成等数量的三堆:\)</span>A _1 , B _1 , C _1
<span class="math inline">\(,将\)</span>m <span class="math inline">\(分成等质量的三堆\)</span>A _2 , B _2 , C _2 $.</p>
<p>接下来称量$A _1 + A _2 , B _1 + B _2 $.</p>
<ol type="1">
<li><p>如果$A _1 + A _2 , B _1 + B _2 = 0 <span class="math inline">\(,那么答案在\)</span>C _1 C _2 <span class="math inline">\(中,此时有\)</span>g ( n , m ) = g ( { 3 } , { 3 }
) + 1 $.</p></li>
<li><p>如果$A _1 + A _2 , B _1 + B _2 = A _1 + A _2 <span class="math inline">\(,由于若次品在\)</span>A _2 <span class="math inline">\(中,那么它不可能是重球,因此次品不可能在\)</span>A
_2 <span class="math inline">\(中,同理不可能在\)</span>B _1 <span class="math inline">\(中,只可能在\)</span>A _1 B _2 <span class="math inline">\(中,此时有\)</span>g ( n , m ) = g ( { 3 } , { 3 }
) + 1 $.</p></li>
<li><p>$A _1 + A _2 , B _1 + B _2 = B _1 + B _2 $,同理.</p></li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p>$n = 3 p + 1 , m = 3 q + 2 <span class="math inline">\(.此时我们将第一堆分成\)</span>A _1 ( p ) , B _1 (
p ) , C _1 ( p + 1 ) <span class="math inline">\(,将第二堆分成\)</span>A
_2 ( q + 1 ) , B _2 ( q + 1 ) , C _2 ( q ) <span class="math inline">\(,然后\)</span>A _1 + A _2 , B _1 + B _2 <span class="math inline">\(,接下来和情况1一样,于是有\)</span>g ( n , m ) = {
g ( p , q + 1 ) , g ( p + 1 , q ) } = _3 { 3 } + 1 $.</p>
<p>同理,当$n , m $的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论$n $的值.</p>
<p><strong>情况1</strong></p>
<p>当$n = 3 p <span class="math inline">\(时,直接分成\)</span>A ( p ) ,
B ( p ) , C ( p ) <span class="math inline">\(,然后\)</span>A , B <span class="math inline">\(.如果平衡则接下来需要\)</span>f ( p ) = _3 2 p
<span class="math inline">\(次,不然根据引理,需要\)</span>_3 ( p + p )
<span class="math inline">\(次,因此\)</span>f ( n ) = _3 2 p + 1 = _3 6
p = _3 2 n $.</p>
<p><strong>情况2</strong></p>
<p>当$n = 3 p + 1 <span class="math inline">\(时,一种自然的想法是分成\)</span>A ( p + 1 ) , B (
p ) , C ( p )
$,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了$2 p
+ 2 , 2 p , 2 p <span class="math inline">\(,这显然是不优秀的.正确的做法是分成\)</span>A = { S
, 1 , p } , B = { p + 1 , p + 1 } , C = { 2 p + 2 , p + 1 } <span class="math inline">\(.由于存在标准球,此时如果\)</span>A , B = A  or  B
<span class="math inline">\(,那么转化成\)</span>g ( p , p + 1 ) = _3 ( 2
p + 1 ) <span class="math inline">\(,不然转化成\)</span>f ( p ) = _3 2 p
$.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有$n
= 1 <span class="math inline">\(的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题\)</span>f
( n ) = _3 ( 2 n + 2 ) $.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将$a <span class="math inline">\(个球放左边,\)</span>b <span class="math inline">\(个球放右边,\)</span>a b <span class="math inline">\(,在左边补上\)</span>b - a $个标准球.</p>
<ol type="1">
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要$_3
( a + b ) + 1 $步.</p></li>
<li><p>如果天平平衡,需要$f ( n - a - b ) + 1 $步.</p></li>
</ol>
<p>我们有$f ( n ) = _{ a , b } { { f ( n - a - b ) , _3 ( a + b ) } } +
1 $.</p>
<p>注意到接下来的步数只与$a + b <span class="math inline">\(有关,取\)</span>b - a
$,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到$f ( n ) = _3 ( 2 n - 1 ) $.</p>
<p>接下来归纳法就简单了,只需要对于$n <span class="math inline">\(的余数讨论一下,然后再讨论一下\)</span>a
$的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求$n
<span class="math inline">\(所在位置.要求询问次数\)</span> . 5 _2 n
<span class="math inline">\(,询问区间总长度\)</span> n $.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设$T ( n ) <span class="math inline">\(表示长度为\)</span>n
$的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程$T ( n ) = _{ m &lt; n } { { T ( m ) + 1 , T ( n -
m ) + 2 } } $.</p>
<p>当然有$m <em>n m </em>{ n + 1 } $,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3>
<h4><span id="模型1">模型1</span></h4>
<p>给定$n <span class="math inline">\(个元素\)</span>x _1 , . . . , x
<em>n <span class="math inline">\(,以及一个定义域为这些元素的序列,定义域为有序集合的函数\)</span>F
<span class="math inline">\(.求出对于所有的\)</span>n <span class="math inline">\(阶排列\)</span>p <span class="math inline">\(,表达式\)</span>F ( { x </em>{ p <em>1 } , x
</em>{ p <em>2 } , . . . , x </em>{ p _n } } ) $最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定$n <span class="math inline">\(个二元正整数对\)</span>( a _i , b
_i ) <span class="math inline">\(,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的\)</span>a
<span class="math inline">\(乘上序列中这个二元组之后的所有二元组的\)</span>b
<span class="math inline">\(之和的总和,求最小代价.\)</span>n , a _i , b
_i ^6 $.</p>
<p>转化为上面的形式,也即:$F ( { ( a _1 , b _1 ) , . . . , ( a _n , b
<em>n ) } ) = </em>{ 1 i &lt; j k } a _i b _j $.</p>
<p>考虑调整法,令排列$( q _1 , . . . , q <em>n ) = ( p <em>1 , . . . , p
</em>{ i - 1 } , p </em>{ i + 1 } , p <em>i , p </em>{ i + 2 } , . . . ,
p _n ) $.则:</p>
<p><span class="math display">\[
F ( \{ ( a _{ p _1  } , b _{ p _1  } ) , . . . , ( a _{ p _n  } , b _{ p
_n  } ) \} ) - F ( \{ ( a _{ q _1  } , b _{ q _1  } ) , . . . , ( a _{ q
_n  } , b _{ q _n  } ) \} ) = a _{ p _i  } b _{ p _{ i + 1  }  } - a _{
p _{ i + 1  }  } b _{ p _i  }
\]</span></p>
<p>因而如果$a <em>{ p <em>i } b </em>{ p </em>{ i + 1 } } - a <em>{ p
</em>{ i + 1 } } b _{ p <em>i } &gt; 0 <span class="math inline">\(,则\)</span>F ( { ( a </em>{ p <em>1 } , b </em>{
p <em>1 } ) , . . . , ( a </em>{ p <em>n } , b </em>{ p <em>n } ) } )
&gt; F ( { ( a </em>{ q <em>1 } , b </em>{ q <em>1 } ) , . . . , ( a
</em>{ q <em>n } , b </em>{ q _n } ) } ) <span class="math inline">\(,也就是说\)</span>( p <em>1 , . . . , p <em>n )
<span class="math inline">\(不是最优解.因此只有满足\)</span> i &lt; n
<span class="math inline">\(,\)</span> { b </em>{ p <em>i } } { b </em>{
p </em>{ i + 1 } } } $可能是最优解.</p>
<p>如果一个$p <span class="math inline">\(满足这样的性质,则所有\)</span>
{ b } <span class="math inline">\(相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换\)</span>
{ b } <span class="math inline">\(相等的两个位置,是不会使答案改变的.因此直接按照\)</span>
{ b } $排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为$S <span class="math inline">\(,定义\)</span>S
<span class="math inline">\(上的一种二元比较关系\)</span>$,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li><p>强完全性:$a , b S <span class="math inline">\(,\)</span>a b b a =
1 $.</p></li>
<li><p>传递性:$a , b , c S <span class="math inline">\(,\)</span>a b , b
c a c $.</p></li>
<li><p>$a , b S <span class="math inline">\(,如果\)</span>a b <span class="math inline">\(,则对于任意一个包含\)</span>{ a , b } <span class="math inline">\(作为子段的元素序列\)</span>{ s <em>1 , . . . , s
</em>{ k - 1 } , a , b , s _{ k + 2 } , . . . , s <em>n } <span class="math inline">\(和\)</span>{ s <em>1 , . . . , s </em>{ k - 1 } ,
b , a , s </em>{ k + 2 } , . . . , s <em>n } <span class="math inline">\(都有:\)</span>F ( { s <em>1 , . . . , s </em>{ k -
1 } , a , b , s </em>{ k + 2 } , . . . , s <em>n } ) F ( { s <em>1 , . .
. , s </em>{ k - 1 } , b , a , s </em>{ k + 2 } , . . . , s _n } )
$.</p></li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义$<span class="math inline">\(后自然也就定义了\)</span>=
$,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到$$的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定$n <span class="math inline">\(个包含小写字符的字符串\)</span>s
_1 , . . . , s <em>n <span class="math inline">\(,找到一个\)</span>n
<span class="math inline">\(阶排列\)</span>p <span class="math inline">\(,将\)</span>s </em>{ p <em>1 } , s </em>{ p <em>2
} , . . . , s </em>{ p _n } <span class="math inline">\(顺序拼接得到\)</span>S <span class="math inline">\(,使\)</span>S $的字典序最小.</p>
<p>令$s t <span class="math inline">\(当且仅当\)</span>s + t <span class="math inline">\(的字典序\)</span>$t+s</p>
<p>此时我们注意到:$s + t <span class="math inline">\(的字典序小于等于\)</span>t + s <span class="math inline">\(的字典序当且仅当\)</span>s ^{ } t ^{ } <span class="math inline">\(.原因是:不妨设\)</span>s <span class="math inline">\(的长度\)</span>t <span class="math inline">\(的长度.若\)</span>s <span class="math inline">\(不是\)</span>t <span class="math inline">\(的前缀,那显然只需比较\)</span>t <span class="math inline">\(的前缀和\)</span>s <span class="math inline">\(的字典序即可,此时上面两个条件等价;若\)</span>s
<span class="math inline">\(是\)</span>t <span class="math inline">\(的前缀,则我们需要比较\)</span>t <span class="math inline">\(的前缀和\)</span>t <span class="math inline">\(的后缀,注意到\)</span>t <span class="math inline">\(的前缀还是\)</span>s <span class="math inline">\(,于是需要比较\)</span>s <span class="math inline">\(和\)</span>t $的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有$n <span class="math inline">\(个箱子,第\)</span>i <span class="math inline">\(个箱子有重量\)</span>w _i <span class="math inline">\(和承载量\)</span>v _i <span class="math inline">\(,\)</span>( w _i , v _i &gt; 0 )
$,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化$_{ i = 1 } ^n { v <em>i - </em>{ j = 1 } ^{ i - 1 } w _j }
<span class="math inline">\(,并判断是否\)</span> $.</p>
<p>我们令$b _i = - ( v _i + w _i ) , a _i = - v <em>i <span class="math inline">\(,则我们要最大化\)</span>{ </em>{ j = 1 } ^{ i - 1
} b <em>i - </em>{ j = 1 } ^i a _i } $.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义$x y <span class="math inline">\(当且仅当\)</span>F ( { x ,
y } ) F ( { y , x } ) <span class="math inline">\(,那么对于两个元素\)</span>( a _1 , b _1 ) , ( a _2
, b _2 ) <span class="math inline">\(,显然\)</span>( a _1 , b _1 ) ( a
_2 , b _2 ) <span class="math inline">\(当且仅当\)</span>{ - a _1 , b _1
- a _1 - a _2 } { - a _2 , b _2 - a _1 - a _2 }
$.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li><p>都大于等于第一个元素,则相当于$a _1 a _2 b _1 - a _1 $.</p></li>
<li><p>都大于等于第二个元素,则相当于$b _1 b _2 b _2 - a _2 $.</p></li>
</ol>
<p>可能这里后面和$0
$比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对$b - a $的符号进行讨论:</p>
<ol type="1">
<li><p>若$sgn ( b _1 - a _1 ) &gt; sgn ( b _2 - a _2 )
$,则不等式成立.</p></li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 1 <span class="math inline">\(,则不等式成立当且仅当\)</span>a _1 a _2
$.</p></li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 0
$,则不等式成立.</p></li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = - 1 <span class="math inline">\(,则不等式成立当且仅当\)</span>b _1 b _2
$.</p></li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时$b _1 = a _1 <span class="math inline">\(,\)</span>b _2 = a _2 <span class="math inline">\(,两条件必有一真.(1)则是因为此时满足\)</span>b _1 -
a _1 &gt; b _2 - a _2 sgn ( b _1 - a _1 ) sgn ( b _2 - a _2 ) <span class="math inline">\(.也就有\)</span>a _2 - a _1 &gt; b _2 - b _1 b _1
a _1 b _2 a _2 $.怎么着都能成立.</p>
<p>由此发现,对于$sgn ( b - a ) $相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<p><span class="math display">\[
\begin{aligned}
( a _1 , b _1 ) &amp; \leq ( a _2 , b _2 ) \\
\Updownarrow \\
( sgn ( b _1 - a _1 ) &amp; &gt; sgn ( b _2 - a _2 ) ) \\
\lor ( sgn ( b _1 - a _1 ) &amp; = sgn ( b _2 - a _2 ) \land F ( \{ 1 ,
2 \} ) &amp; \leq F ( \{ 2 , 1 \} )
\end{aligned}
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定$n <span class="math inline">\(个元素\)</span>x _1 , . . . , x
<em>n <span class="math inline">\(,以及一个定义域为这些元素的序列,值域为有序集合的函数\)</span>F
<span class="math inline">\(.求出对于给定整数\)</span>k <span class="math inline">\(,所有的\)</span>n <span class="math inline">\(阶排列\)</span>p <span class="math inline">\(的长度为\)</span>k <span class="math inline">\(的子序列,表达式\)</span>F ( { x </em>{ p <em>1 } ,
x </em>{ p <em>2 } , . . . , x </em>{ p _k } } ) $最小值.</p>
<p>如果$k = n <span class="math inline">\(,则就是模型1.不然,我们考虑先选出一个大小为\)</span>k
<span class="math inline">\(的子集,然后使用模型1.不难发现,我们最后取出的\)</span>{
x _{ p <em>1 } , x </em>{ p <em>2 } , . . . , x </em>{ p _k } } <span class="math inline">\(一定是\)</span>n = k
$时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有$n <span class="math inline">\(个物品,第\)</span>i <span class="math inline">\(个物品有非负费用\)</span>c _i <span class="math inline">\(和价值\)</span>v _i $,两个人进行如下博弈:</p>
<ol type="1">
<li><p>第一个人要么选择一个物品,付出$c _i
$的代价;要么选择结束游戏.</p></li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行$k
<span class="math inline">\(次);也可以选择不操作,此时第一个人获得\)</span>v _i
$的收益,博弈结束.</p></li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.$(
n . 5 ^5 , k ) $</p></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择$k + 1 <span class="math inline">\(个,然后收益为\)</span><em>{ i = 1 } ^{ k - 1 } { v
</em>{ x <em>i } - </em>{ j = 1 } ^i c _{ x _j } } <span class="math inline">\((如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度\)</span>O
( n n + nk ) $.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有$n
$条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有$n <span class="math inline">\(条直线的答案,求\)</span>n + 1
$条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度$a _1 , , a _n { 90 , 270 } <span class="math inline">\(,要求构造一个\)</span>n <span class="math inline">\(边形(边必须平行于坐标轴),使得其内角依次是\)</span>a
_1 , , a _n $.</p>
<p>首先有解条件显然是判定它们的和是否是$180 ( n - 2 ) $.</p>
<p>注意到相邻的$90 $和$270
$无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让$S T <span class="math inline">\(.这个时候可以找一个中间状态\)</span>A <span class="math inline">\(,让\)</span>S A , T A $.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有$( X , 0 ) <span class="math inline">\(亮着,每次把\)</span>( x , y ) <span class="math inline">\(,\)</span>( x , y + 1 ) <span class="math inline">\(,\)</span>( x + 1 , y )
$状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p>$n ^5 <span class="math inline">\(,坐标的绝对值均\)</span> ^{ 17 }
$.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线$y = - inf <span class="math inline">\(,然后比对.我们注意到\)</span>( X , 0 ) <span class="math inline">\(向下推的过程类似一个组合数递推的过程,由经典公式\)</span>
{ T } <span class="math inline">\(可知,我们取\)</span>inf = 2 ^{ 63 } -
1 $即可.然后最后在这条线上一定是有一个区间是$1
$,我们需要找到区间左端点,我们选择在直线上随便找到一个$1 <span class="math inline">\(,由于\)</span>inf $很大,大于$10 ^{ 17 }
$,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,$n ^4 <span class="math inline">\(,但是初始点可能是\)</span>( X , Y ) $.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点$( j , - inf ) <span class="math inline">\(和\)</span>( k , - inf ) <span class="math inline">\(是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出\)</span>X
<span class="math inline">\(和\)</span>Y <span class="math inline">\(.而上述条件满足当且仅当\)</span>[ j - X Y + inf ]
$.</p>
<p>如果我们随便找一个点$( p , - inf ) <span class="math inline">\(满足条件,那我们接下来只需要枚举\)</span>w <span class="math inline">\(,判断\)</span>( p - 2 ^w , - inf )
$是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间$[ l , r ]
$中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">计算几何</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2>
<p>参考:https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3>
<h4><span id="eps">eps</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$ = | | | | = x _a x _b + y _a y _b <span class="math inline">\(.也就等于\)</span> <span class="math inline">\(在\)</span>b <span class="math inline">\(上的投影与\)</span> $的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol type="1">
<li><p>如果$ = 0 <span class="math inline">\(,则说明\)</span>
$.</p></li>
<li><p>如果$ &gt; 0 <span class="math inline">\(,则说明\)</span> <span class="math inline">\(和\)</span> $正方向的夹角小于$90 $.</p></li>
<li><p>如果$ &lt; 0 <span class="math inline">\(,则说明\)</span> <span class="math inline">\(和\)</span> $正方向的夹角大于$90 $.</p></li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$ = x _a y _b - y _a x _b <span class="math inline">\(.也就等于\)</span> ,
$两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol type="1">
<li><p>如果$ = 0 $,说明二者共线.</p></li>
<li><p>如果$ &lt; 0 <span class="math inline">\(,说明从\)</span> <span class="math inline">\(到\)</span> $的方向是顺时针.</p></li>
<li><p>如果$ &gt; 0 <span class="math inline">\(,说明从\)</span> <span class="math inline">\(到\)</span> $的方向是逆时针.</p></li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
也就是将这个竖向量乘左乘旋转矩阵$
<span class="math display">\[\begin{bmatrix}\cos \theta &amp; - \sin
\theta \\ \sin \theta &amp; \cos \theta \end{bmatrix}\]</span>
<p>$.</p>
<h4><span id="line">Line</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下$x _{ L <em>1 } , x </em>{ L <em>2 } , y </em>{ L
<em>1 } , y </em>{ L _2 } <span class="math inline">\(围成的四边形,计算面积后用等高不等底计算.注意\)</span>ls
<span class="math inline">\(和\)</span>rs
$所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4>
<p>利用叉乘,任取平面上一点$O <span class="math inline">\(,则\)</span>S =
{ 2 } _{ i = 1 } ^n <span class="math inline">\(.证明的话考虑分\)</span>O <span class="math inline">\(在内部和\)</span>O <span class="math inline">\(在外部两种情况分类讨论.注意此时的\)</span>P
$必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为$a
<span class="math inline">\(,它的边上(包括顶点)的整点数为\)</span>b
<span class="math inline">\(,则它的面积\)</span>S = a + { 2 } - 1 $.</p>
<h3><span id="基本算法">基本算法</span></h3>
<h4><span id="排序算法">排序算法</span></h4>
<h5><span id="极角排序">极角排序</span></h5>
<p>定义原点$O <span class="math inline">\(并建立坐标系,所有点按照和\)</span>O <span class="math inline">\(所连直线与\)</span>x $轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$x <span class="math inline">\(相同比\)</span>y <span class="math inline">\(,否则比\)</span>x $.</p>
<h4><span id="二维凸包">二维凸包</span></h4>
<h5><span id="定义">定义</span></h5>
<p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5>
<p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否$ABC <span class="math inline">\(三点是一个上凸的(注意\)</span>ABC
$三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5>
<p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4>
<p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5>
<p>两个区域$A , B <span class="math inline">\(的闵可夫斯基和定义为\)</span>{ a + b a A , b B }
$.</p>
<h5><span id="实现">实现</span></h5>
<p>事实上,新的区域所形成的凸包,一定是原本$A , B
$的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下$A , B <span class="math inline">\(,使得\)</span>B
<span class="math inline">\(有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是\)</span>B
<span class="math inline">\(这个边加上\)</span>A <span class="math inline">\(的最右边的点.这样这条边必定还在最终的凸包上.就算\)</span>A
<span class="math inline">\(最右边的是一条边,你也会发现最终的凸包最右边也一定是由\)</span>A
<span class="math inline">\(的这条边和\)</span>B $的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义半平面为满足$ax + by + c &gt; 0 <span class="math inline">\(或\)</span>ax + by + c <span class="math inline">\(的点对\)</span>( x , y )
$组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5>
<p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2>
<p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3>
<h4><span id="直线">直线</span></h4>
<p>使用直线的方向向量$ = ( n , m , p ) <span class="math inline">\(和直线上一点\)</span>M _0 = ( x _0 , y _0 , z _0 )
$.那么方程显然为:</p>
<p><span class="math display">\[
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z
_0  } { p  }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt
\end{cases}
\]</span></p>
<h4><span id="平面">平面</span></h4>
<p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) <span class="math inline">\(和该平面的法向量\)</span> <span class="math inline">\(来表示一个平面,不妨设\)</span> = ( A , B , C )
$,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0
\]</span></p>
<p>如果我们令$D = - ( Ax _0 + By <em>0 + Cz </em>) $,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h4><span id="夹角">夹角</span></h4>
<h5><span id="两直线夹角">两直线夹角.</span></h5>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$ = ( n _1 , m _1 , p _1 ) , = ( n _2 , m _2 , p _2
) <span class="math inline">\(,也就有\)</span>= ( { | _1 | | _2 | } ) \
$.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5>
<p>同样使用向量,不妨设方向向量$ = ( n , m , p ) <span class="math inline">\(,法向量\)</span> = ( a , b , c ) <span class="math inline">\(,那么\)</span>= ( { | | | | } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p></li>
<li><p>若直线与平面垂直,则$ { m } = { n } = { p }
$.注意这里分母可能除以$0 <span class="math inline">\(,我们实际上应该是三个形如\)</span>a = mt
$的参数方程,这里简化了.</p></li>
</ol>
<h4><span id="交点">交点</span></h4>
<p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">范畴论初步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2>
<h3><span id="映射">映射</span></h3>
<p>设$A , B <span class="math inline">\(为两个集合,\)</span><span class="math inline">\(称为从\)</span>A <span class="math inline">\(到\)</span>B <span class="math inline">\(的一个**映射**,如果对于任意\)</span>a A <span class="math inline">\(,\)</span>b B , b = ( a ) <span class="math inline">\(.此时\)</span>b <span class="math inline">\(称为\)</span>a <span class="math inline">\(在\)</span><span class="math inline">\(下的像,\)</span>a <span class="math inline">\(称为\)</span>b <span class="math inline">\(在\)</span><span class="math inline">\(下的原像或反像.一般地,这个定义可以拓展到\)</span>S
A <span class="math inline">\(,\)</span>( S ) = { ( a ) a S } <span class="math inline">\(,定义\)</span>^{ - 1 } ( T ) = { a | ( a ) T , a S
} $.</p>
<p>如果$a _1 , a _2 A , a _1 a _2 , ( a _1 ) ( a _2 ) <span class="math inline">\(,称\)</span>$是<strong>单射</strong>.</p>
<p>如果$b B , a A , ( a ) = b <span class="math inline">\(.称\)</span>$为<strong>满射</strong>.</p>
<p>如果$$既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果$A = B <span class="math inline">\(,我们又称\)</span>$为一个<strong>变换</strong>.</p>
<p>设$f : A B , g : B A $,那么:</p>
<ol type="1">
<li><p>如果$g f = id _A <span class="math inline">\(,称\)</span>g <span class="math inline">\(是\)</span>f <span class="math inline">\(的一个**左逆**,不难发现\)</span>f <span class="math inline">\(存在左逆当且仅当\)</span>f $是单射.</p></li>
<li><p>如果$f g = id _B <span class="math inline">\(,称\)</span>g <span class="math inline">\(是\)</span>f <span class="math inline">\(的一个**右逆**,不难发现\)</span>f <span class="math inline">\(存在右逆当且仅当\)</span>f $是满射.</p></li>
<li><p>如果$g <span class="math inline">\(既是\)</span>f <span class="math inline">\(的左逆又是\)</span>f <span class="math inline">\(的右逆,则称\)</span>g <span class="math inline">\(为\)</span>f <span class="math inline">\(的**逆**,不难发现\)</span>f <span class="math inline">\(存在逆当且仅当\)</span>f
$是双射,并且逆唯一.</p></li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3>
<p>集合$A , B <span class="math inline">\(的**笛卡尔积**或**直积**是指\)</span>A <span class="math inline">\(的元素与\)</span>B <span class="math inline">\(的元素构成的有序对的集合,即\)</span>A B = { ( a ,
b ) a A , b B } $.可以推广到多元对.</p>
<p>集合$A <span class="math inline">\(上的一个**二元运算**是由\)</span>A
A <span class="math inline">\(到\)</span>A <span class="math inline">\(的一个映射.对于定义在\)</span>U <span class="math inline">\(上的一个二元运算,不妨用\)</span>+ <span class="math inline">\(来表示,集合\)</span>A , B U <span class="math inline">\(的**闵可夫斯基和**定义为\)</span>A + B = { a + b a
A , b B }
$.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合$A <span class="math inline">\(上的一个**二元关系**\)</span>R
<span class="math inline">\(定义为\)</span>A A <span class="math inline">\(的一个子集(可以理解为满足二元关系的解集),如果\)</span>(
a _1 , a _2 ) R <span class="math inline">\(,就称\)</span>a _1 , a _2
<span class="math inline">\(有关系\)</span>R <span class="math inline">\(,记作\)</span>a _1 Ra _2 $,注意这里有序.</p>
<p>如果$R $满足以下三个性质:</p>
<ol type="1">
<li><p>反身性:$a A , aRa $.</p></li>
<li><p>对称性:$a _1 Ra _2 a _2 Ra _1 $.</p></li>
<li><p>传递性:$a _1 Ra _2 , a _2 Ra _3 a _1 Ra _3 $.</p></li>
</ol>
<p>则称$R <span class="math inline">\(是一个**等价关系**,不难发现满足等价关系的元素构成了若干个集合,称作**等价类**.等价关系通常记作\)</span>$.</p>
<p>如果将等价关系的(2)改作:</p>
<ol start="2" type="1">
<li>反对称性:$a _1 Ra _2 , a _2 Ra _1 a _1 = a _2 $.</li>
</ol>
<p>则称$R
$是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$$.</p>
<h4><span id="保序映射">保序映射</span></h4>
<p>对于映射$f : A B <span class="math inline">\(,如果\)</span>a , a ’ A
, a a ’ f ( a ) f ( a ’ ) $,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4>
<p>对于偏序集$( A , R ) $来说,定义:</p>
<ol type="1">
<li><p>链:$A ’ A , x , y A ’ , [ xRy yRx ] = 1 $.</p></li>
<li><p>反链:$A ’ A , x , y A ’ , [ xRy yRx ] = 0 $.</p></li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p></li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,$| A | $显然成立.</p>
<p>当$| A | &gt; 3
$时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为$d <span class="math inline">\(,下面证明其最小链覆盖也是\)</span>d $.</p>
<p>考虑取一条尽可能长的链$A ’ <span class="math inline">\(,设其中最大的为\)</span>M <span class="math inline">\(,最小的为\)</span>m $(如果有多个就任取一个).</p>
<p>考虑$T = A A ’ <span class="math inline">\(,如果\)</span>T <span class="math inline">\(中的最长反链数小于\)</span>d $,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链$S <span class="math inline">\(,使得\)</span>S A ’ = <span class="math inline">\(.考虑设\)</span>A ^{ + } = { x | x A s S , sRx }
<span class="math inline">\(,\)</span>A ^{ - } = { x | x A s S , xRs }
<span class="math inline">\(.不难发现\)</span>m <span class="math inline">\(一定不在\)</span>| A ^{ + } | <span class="math inline">\(中,不然取出的那条链\)</span>A ’ <span class="math inline">\(可以更长.同理\)</span>M <span class="math inline">\(一定不在\)</span>| A ^{ - } | <span class="math inline">\(中,也即\)</span>| A ^+ | , | A ^- | &lt; | A |
$.</p>
<p>我们又发现$A ^+ A ^- = A
$,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,$S A ^{ + } A ^{ - } $.</p>
<p>由数学归纳,$A ^+ <span class="math inline">\(和\)</span>A ^- <span class="math inline">\(中的最小链覆盖均为\)</span>d <span class="math inline">\(,并且一个以\)</span>S <span class="math inline">\(中元素开头,一个以\)</span>S <span class="math inline">\(中元素结尾,我们把它俩拼起来就是一个大小为\)</span>d
<span class="math inline">\(的新的大小为\)</span>d
$的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4>
<p>考虑定义一种等价关系$<span class="math inline">\(,我们可以在此基础上定义商集\)</span>A / = { [ a ]
| a A } <span class="math inline">\(,其中\)</span>[ a ] <span class="math inline">\(是\)</span>a $所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过$ <span class="math inline">\(来定义\)</span>
$.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系$<span class="math inline">\(,\)</span>( n , m ) ( n ’ , m ’ ) <span class="math inline">\(当且仅当\)</span>n + m ’ = m + n ’
$.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将$ / <span class="math inline">\(定义为整数,更确切地,对于任意一组\)</span>( n , m )
<span class="math inline">\(其代表的就是\)</span>n - m $这个整数.</p>
<p>容易定义加法:$( n , m ) + ( n ’ , m ’ ) = ( n + n ’ , m + m ’ ) <span class="math inline">\(,乘法\)</span>( n , m ) ( n ’ , m ’ ) = ( mm ’ +
nn ’ , mn ’ + m ’ n ) <span class="math inline">\(.也可以定义大小关系\)</span>( n , m ) ( n ’ , m ’
) n + m ’ m + n ’ $.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义$- ( n , m ) = ( m , n ) <span class="math inline">\(即可,容易验证二者之和处于\)</span>( 0 , 0 )
$这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用$ <span class="math inline">\(构造\)</span> <span class="math inline">\(,构造二元组\)</span> _+ <span class="math inline">\(,定义\)</span>( r , s ) ( r ’ , s ’ ) rs ’ = r ’ s
<span class="math inline">\(,容易验证其满足等价关系的性质.实际上其对应的就是\)</span>
{ s } $这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3>
<h4><span id="外延公理">外延公理</span></h4>
<p>$A = B ( A B ) ( B A ) $.</p>
<h4><span id="配对公理">配对公理</span></h4>
<p>对于任意元素$a , b <span class="math inline">\(,存在集合\)</span>{ a
, b } <span class="math inline">\(.特别地,当\)</span>a = b <span class="math inline">\(的时候存在集合\)</span>{ a } $.</p>
<p>值得一提的是可以将数对$( a , b ) <span class="math inline">\(定义为\)</span>{ { a } , { a , b } }
$,下面的幂集公理说明了数对属于$2 ^{ 2 ^{ A B } } , a A , b B $.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4>
<p>对于一个集合$A <span class="math inline">\(,和一个性质\)</span>P
<span class="math inline">\(,若\)</span><span class="math inline">\(满足性质\)</span>P <span class="math inline">\(则称\)</span>P ( ) $.那么存在集合:</p>
<p><span class="math display">\[
\{ x | x \in A \land P ( x ) \}
\]</span></p>
<p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质$P $都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4>
<p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4>
<p>一个集合的所有子集构成一个新的集合(可以记作$2 ^A $).</p>
<h4><span id="无穷公理">无穷公理</span></h4>
<p>称满足以下性质的集合为归纳集:</p>
<ol type="1">
<li><p>$A $.</p></li>
<li><p>若$A <span class="math inline">\(,则\)</span>{ } A $.</p></li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4>
<p>对于集合$A <span class="math inline">\(和一种定义在集合\)</span>A
<span class="math inline">\(上的映射\)</span>F <span class="math inline">\(,存在集合\)</span>A ’ <span class="math inline">\(使得\)</span>x A ’ x = F ( a ) , a A $.</p>
<p>用替换公理可以证明映射也是一种集合,并且从$A B <span class="math inline">\(的所有映射可以构成集合,可以记作\)</span>B ^A
$.</p>
<h4><span id="正则公理">正则公理</span></h4>
<p>对任何非空集合$A <span class="math inline">\(,存在\)</span>a A <span class="math inline">\(使得\)</span>a ’ A <span class="math inline">\(,\)</span>a ’ a <span class="math inline">\(,也就是\)</span>a A = $.</p>
<h4><span id="选择公理">选择公理</span></h4>
<p>说对于任何一族非空集$A <span class="math inline">\(,总能从其中的每个集合\)</span>a $选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5>
<p>如果$X <span class="math inline">\(上的一个偏序关系\)</span><span class="math inline">\(,满足其每条链\)</span>A <span class="math inline">\(都存在上界(\)</span>x X , a A , x a <span class="math inline">\(),那么\)</span>X <span class="math inline">\(存在极大元\)</span>( x X , a X , a x a = x )
$.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系$( A ’ ’ , g ’ ’ ) (
A ’ , g ’ ) <span class="math inline">\(当且仅当\)</span>A ’ ’ A ’ <span class="math inline">\(并且\)</span>x A ’ ’ , g ’ ’ ( x ) = g ’ ( x )
<span class="math inline">\(.这样拿出来的极大元就是我们需要的\)</span>A
g ( A ) $.</p>
<h5><span id="良序定理">良序定理</span></h5>
<p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对$( S , R ) <span class="math inline">\(组成的集合,其中满足\)</span>S <span class="math inline">\(对于偏序关系\)</span>R <span class="math inline">\(来说是良序的,我们定义两个二元对\)</span>a , b
<span class="math inline">\(满足\)</span>a b <span class="math inline">\(当且仅当它们的\)</span>R <span class="math inline">\(相等并且\)</span>S _a S _b <span class="math inline">\(.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)\)</span>(
S , R ) <span class="math inline">\(,注意到如果\)</span>S <span class="math inline">\(是全集则证毕,如果不是,则取一个全集中不在\)</span>S
<span class="math inline">\(的元素\)</span>x <span class="math inline">\(接到\)</span>S
$的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3>
<p>如果存在单射$: A B <span class="math inline">\(,则称\)</span>| A | |
B | <span class="math inline">\(.如果存在双射,则称\)</span>| A | = | B |
$.</p>
<p>如果使用选择公理的话,可以说明如果存在满射$: A B <span class="math inline">\(,则称\)</span>| A | | B | $.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有$A , B <span class="math inline">\(两个集合,接下来我们证明一定存在一个从\)</span>A
<span class="math inline">\(到\)</span>B
$的映射,且其要么为单射要么为满射.</p>
<p>我们记$X <span class="math inline">\(为所有\)</span>A <span class="math inline">\(的子集到\)</span>B <span class="math inline">\(的单射组成的集合,并且我们定义这样一种偏序关系:若\)</span>f
: A _f B , g : A _g B , A _f A _g , a A _f , f ( a ) = g ( a ) $.</p>
<p>这样的话,我们不妨取出$X <span class="math inline">\(的一个全序的子集\)</span>I $,显然其存在上界.</p>
<p>根据Zorn引理,$X <span class="math inline">\(存在极大元\)</span>g : A
_g B $,此时我们开始讨论:</p>
<p>如果$A _g = A <span class="math inline">\(,那么找到了一个单射\)</span>g : A B $.</p>
<p>反之,如果$A _g A <span class="math inline">\(,考虑如果\)</span>g ( A
_g ) = B <span class="math inline">\(,也就是找到了一个满射;反之,考虑取\)</span>a ’ A A
_g , b ’ B g ( A _g ) <span class="math inline">\(,在\)</span>g <span class="math inline">\(的基础上加上映射\)</span>a ’ b ’ <span class="math inline">\(,这是一个比\)</span>g
$还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4>
<p>如果$| A | | B | | B | | A | <span class="math inline">\(,则\)</span>| A | = | B | $.</p>
<p>不妨设$f : A B , g : B A <span class="math inline">\(我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用\)</span>f
, f ^{ - 1 } <span class="math inline">\(来构造双射,只有一种除外:那就是以一个\)</span>B
<span class="math inline">\(中节点开始不断延伸的无限的,我们在这里使用\)</span>g
, g ^{ - 1 } $来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取$C <em>0 = B f (
A ) <span class="math inline">\(,\)</span>C <em>n = f ( g ( C </em>{ n -
1 } ) ) <span class="math inline">\(,那么对于\)</span>C = </em>{ n } C
_n <span class="math inline">\(,使用\)</span>g , g ^{ - 1 } <span class="math inline">\(构造双射,剩下的使用\)</span>f , f ^{ - 1 }
$构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4>
<p>我们称集合$A <span class="math inline">\(是**可数**的,当且仅当\)</span>| A | = | | $.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是$0
$)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为$1 $和$0 $显然都是代数数.</p>
<p>我们接下来看两个代数数$x , y <span class="math inline">\(.考虑如何构造\)</span>x + y $作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<p><span class="math display">\[
\begin{aligned}
X &amp; = \sum _{ k = 0  } ^n a _k x ^k &amp; = 0 \\
Y &amp; = \sum _{ k = 0  } ^m b _k y ^k &amp; = 0
\end{aligned}
\]</span></p>
<p>对于加法,考虑:$( x + y ) ^0 , ( x + y ) ^1 , <span class="math inline">\(,这些东西,先把它们对\)</span>X <span class="math inline">\(取膜再对\)</span>Y <span class="math inline">\(取膜,得到的一定是\)</span>nm <span class="math inline">\(维的,只需要取\)</span>nm + 1 <span class="math inline">\(个就会出现线性相关.乘法同理考虑\)</span>( xy ) ^0
, ( xy ) ^1 , $即可.</p>
<p>值得一提的是,$| | = 2 ^{ | | } <span class="math inline">\(.这个是怎么构造的呢?只需要证明\)</span>[ 0 , 1 ]
<span class="math inline">\(上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果\)</span>k
<span class="math inline">\(在取出的自然数子集中,那么小数点后第\)</span>k + 1
$位为$1 $否则为$0 $,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是$0 . 1 = 0 . 0111 <span class="math inline">\(,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明\)</span>|
| ^{ | | } <span class="math inline">\(并且\)</span>| | ^{ | | }
$,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2>
<h3><span id="范畴">范畴</span></h3>
<p>一个<strong>范畴</strong>$ $应当包含以下:</p>
<ol type="1">
<li><p>一个类$\rm { Ob } ( ) <span class="math inline">\(,其元素称作\)</span>
$的<strong>对象</strong>.</p></li>
<li><p>对于$X , Y \rm { Ob } ( ) <span class="math inline">\(指定一个集合\)</span> _{ } ( X , Y ) <span class="math inline">\(,称作\)</span> <span class="math inline">\(中从\)</span>X <span class="math inline">\(到\)</span>Y $的<strong>态射</strong>.</p></li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol type="1">
<li><p>对于$X ( ) <span class="math inline">\(存在其到自身的**恒等态射**\)</span> <em>X </em>{ }
( X , X ) $.</p></li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong>$: <em>{ }
( Y , Z ) </em>{ } ( X , Y ) _{ } ( X , Z ) , ( g , f ) g f $.</p></li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol type="1">
<li><p><strong>结合律</strong>:对于$ <span class="math inline">\(中的态射\)</span>h , g , f <span class="math inline">\(,如果合成有意义,那么\)</span>h ( gf ) = ( hg ) f
$.</p></li>
<li><p><strong>单位元</strong>:对于$f _{ } ( X , Y ) <span class="math inline">\(,\)</span>f _X = f = _Y f $.</p></li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有$ _X = _X _X
= _X $.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<p><span class="math display">\[
\xymatrix { R \ar [r ] ^u \ar [d ] _x &amp; S \ar [d ] ^v \\
T \ar [r ] _y &amp; U  }
\]</span></p>
<p>这意味着$yx = vu $.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol type="1">
<li><p>如果对于$f ( X , Y ) <span class="math inline">\(,\)</span>g ( Y
, X ) <span class="math inline">\(使得\)</span>gf = _X <span class="math inline">\(,那么称\)</span>g <span class="math inline">\(是\)</span>f <span class="math inline">\(的一个**左逆**,称\)</span>f
$是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p></li>
<li><p>如果$f <span class="math inline">\(左右均可逆,易见左右逆相等,记作\)</span>f ^{ - 1 }
<span class="math inline">\(,易见\)</span>f ^{ - 1 } <span class="math inline">\(可逆而且\)</span>( f ^{ - 1 } ) ^{ - 1 } = f <span class="math inline">\(.此时称\)</span>f
$是<strong>同构</strong>的.</p></li>
</ol>
<p>同构还有以下性质:</p>
<ol type="1">
<li><p>$( _X ) ^{ - 1 } = _X $.</p></li>
<li><p>如果$f <span class="math inline">\(和\)</span>g <span class="math inline">\(均为同构并且合成有意义,那么\)</span>gf <span class="math inline">\(是同构并且\)</span>( gf ) ^{ - 1 } = f ^{ - 1 } g
^{ - 1 } $.</p></li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol type="1">
<li><p>自同态幺半群:$ <em>{ } ( X ) = </em>{ } ( X , X ) $.</p></li>
<li><p>自同构群:$ <em>{ } ( X ) = ( </em>{ } ( X ) ) ^$.</p></li>
</ol>
<p>如此起名的原因是由抽象代数知识见到$ <span class="math inline">\(对二元运算\)</span><span class="math inline">\(构成幺半群,\)</span> $则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称$ ’ <span class="math inline">\(是\)</span> $的子范畴当且仅当:</p>
<ol type="1">
<li><p>$ ( ’ ) ( ) $.</p></li>
<li><p>$X , Y ( ’ ) <span class="math inline">\(都有\)</span> <em>{ ’ }
( X , Y ) </em>{ } ( X , Y ) $.</p></li>
<li><p>$X ( ’ ) <span class="math inline">\(,\)</span> _X = _X ’
$.</p></li>
<li><p>态射在$ ’ <span class="math inline">\(中的合成运算应从\)</span>
$中继承而来.</p></li>
</ol>
<p>特别地,如果$X , Y ( ’ ) , ( X , Y ) <em>{ ’ } = </em>{ } ( X , Y )
<span class="math inline">\(,则称\)</span> ’ <span class="math inline">\(是\)</span> $的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3>
<p>如果$ <span class="math inline">\(是一个范畴,其中有一个元素\)</span>X
( ) <span class="math inline">\(,如果\)</span>Y ( { } ) <span class="math inline">\(,\)</span>| <em>{ } ( X , Y ) | = 1 <span class="math inline">\(,则称它是始(initial)的.类似地,如果对于\)</span>Y (
) <span class="math inline">\(,\)</span>X ( ) <span class="math inline">\(,\)</span>| </em>{ } ( X , Y ) | = 1 <span class="math inline">\(,则称\)</span>Y $是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol type="1">
<li><p>如果$X , X ’ ( ) <span class="math inline">\(都是initial的,则存在一个唯一的同构\)</span>a : X X
’ $.</p></li>
<li><p>如果$Y , Y ’ ( ) <span class="math inline">\(都是terminal的,则存在一个唯一的同构\)</span>b : Y
Y ’ $.</p></li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3>
<p>我们定义从$ ’ <span class="math inline">\(到\)</span> <span class="math inline">\(的**函子**\)</span>F $需要有以下性质:</p>
<ol type="1">
<li><p>$X ( ’ ) <span class="math inline">\(,指定一个\)</span> <span class="math inline">\(中的对象\)</span>FX <span class="math inline">\(.或记作\)</span>F : ( ’ ) ( ) $.</p></li>
<li><p>$X , Y ( ’ ) <span class="math inline">\(,对于态射\)</span>f : X
Y <span class="math inline">\(指定一个\)</span> <span class="math inline">\(中的对象\)</span>Ff <span class="math inline">\(.或记作\)</span>F : <em> ’ ( X , Y ) </em> ( FX ,
FY ) $.</p></li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol type="1">
<li><p>$g , f _{ ’ } <span class="math inline">\(,它们的合成有意义,则\)</span>F ( gf ) = F ( g ) F
( f ) $.</p></li>
<li><p>$X ( ’ ) <span class="math inline">\(,\)</span>F ( <em>X ) =
</em>{ FX } $.</p></li>
</ol>
<p>我们一般也将上述函子记作$F : ’
$.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然$F $可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol type="1">
<li><p>如果$T ( ) , X ( ’ ) <span class="math inline">\(使得\)</span>T
FX <span class="math inline">\(,则称\)</span>F
$是<strong>本质满</strong>的.</p></li>
<li><p>如果$X , Y ( ’ ) <span class="math inline">\(,\)</span>F : <em>{
’ } ( X , Y ) </em>{ } ( FX , FY ) <span class="math inline">\(均为单射,则称\)</span>F
$是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p></li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓$
$函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴$ <span class="math inline">\(以及其对象\)</span>X <span class="math inline">\(,我们定义函子\)</span> <em>{ } ( X , ) : Set <span class="math inline">\(,它映对象\)</span>Y <span class="math inline">\(为集合\)</span> </em>{ } ( X , Y ) <span class="math inline">\(,映态射\)</span>f : Y Z <span class="math inline">\(为映射\)</span> <em>{ } ( X , ) f : </em>{ } ( X ,
Y ) _{ } ( X , Z ) , h f h $.</p>
<p>同理可以定义函子$ _{ } ( , X ) $.</p>
<p>对于函子$ _{ } ( X , ) $,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3>
<h4><span id="kleisli范畴">Kleisli范畴</span></h4>
<p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol type="1">
<li><p>加上修饰.</p></li>
<li><p>合并修饰.</p></li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">组合数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2>
<h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3>
<p>定义下降幂$x ^{ } = _{ i = 0 } ^{ k - 1 } ( x - i ) = { ( x - k ) ! }
$.</p>
<p>定义上升幂$x ^{ } _{ i = 0 } ^{ k - 1 } ( x + i ) = { ( x - 1 ) ! }
$.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:$r ^{ } ( r - 0 . 5 ) ^{ } = { 2 ^{ 2 k } } , k
$.</p>
<p>他们之间存在转换:$x ^{ } = ( - 1 ) ^n ( - x ) ^{ } $.</p>
<p>同时存在大小关系:$x ^{ } x ^n x ^{ } $,其中$0 n &lt; x $.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3>
<p>考虑令$ { m } <span class="math inline">\(表示从一个大小为\)</span>n
<span class="math inline">\(的子集中选出大小为\)</span>m <span class="math inline">\(的子集的方案数.第一次有\)</span>n <span class="math inline">\(个选择,第二次有\)</span>n - 1 <span class="math inline">\(个选择......第m次有\)</span>n - m + 1 <span class="math inline">\(个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是\)</span>m
! <span class="math inline">\(,因此显然有\)</span> { m } = { m ! }
$.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
$ { k } =
<span class="math display">\[\begin{cases}\cfrac { r ^{ \underline {
k  }  }  } { k !  } &amp; k \geq 0 \\ 0 &amp; k &lt; 0
\end{cases}\]</span>
<p>, r , k $.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把$ { k } <span class="math inline">\(看作了一个关于\)</span>r <span class="math inline">\(的\)</span>k $次多项式.</p>
<p>另外根据定义,$r r &lt; k $时,该公式给出$0 $.</p>
<p>值得一提的是,为了使二项式系数在面对$0 $的时候更加简洁,通常直接定义$0
! = 1 , 0 ^0 = 1 $.</p>
<p>另外不难发现$ { n } <span class="math inline">\(是所有\)</span> { k }
<span class="math inline">\(中最大的.事实上我们有Wallis公式:\)</span>_{
n } { 2 n + 1 } = { 2 } $.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3>
<ol type="1">
<li>阶乘展开式:$ { k } = { k ! ( n - k ) ! } , n , k , n k \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="2" type="1">
<li>对称恒等式:$ { k } = { n - k } , n , k \ $.</li>
</ol>
<p>根据$( 1 ) $,$0 k n $时是显然的.而其他情况两边都会给出$0
$,因此也是成立的.</p>
<ol start="3" type="1">
<li>吸收恒等式:$ { k } = { k } { k - 1 } , k k \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="4" type="1">
<li>吸收恒等式的变式:$k { k } = r { k - 1 } , k \ $.</li>
</ol>
<p>根据$( 3 ) <span class="math inline">\(,只需要验证\)</span>k = 0
$的情况即可,也是显然的.</p>
<ol start="5" type="1">
<li>相伴恒等式:$( r - k ) { k } = r { k } , k \ $.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
( r - k ) \binom { r  } { k  } &amp; = ( r - k ) \binom { r  } { r -
k  } \\
&amp; = r \binom { r - 1  } { r - k - 1  } \\
&amp; = r \binom { r - 1  } { k  }
\end{aligned}
\]</span></p>
<p>问题在于:我们在上述描述中并未提到$r <span class="math inline">\(的范围,但是推导过程要求\)</span>r <span class="math inline">\(.不过,我们已经说明了二项式系数是关于\)</span>r
<span class="math inline">\(的\)</span>k <span class="math inline">\(次多项式,因此只需要有\)</span>k + 1 <span class="math inline">\(个\)</span>r <span class="math inline">\(满足这个公式即可.而根据推导过程显然有无限个\)</span>r
<span class="math inline">\(满足,因此这个公式对\)</span>r
$也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<p><span class="math display">\[
\begin{aligned}
k \binom { r  } { k  } &amp; = r \binom { r - 1  } { k - 1  } \\
( r - k ) \binom { r  } { r - k  } &amp; = r \binom { r - 1  } { r - k -
1  } \\
( r - k ) \binom { r  } { k  } &amp; = r \binom { r - 1  } { k  }
\end{aligned}
\]</span></p>
<ol start="6" type="1">
<li>加法公式:$ { k } = { k } + { k - 1 } , k \ $.</li>
</ol>
<p>证明可以使用定义,也可以先用$r
$的情况给出组合意义,再使用多项式推理法证明.</p>
<ol start="7" type="1">
<li>$ { m } { k } = { k } { m - k } , n , k \ $.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol start="8" type="1">
<li>平行求和法:$_{ k n } { k } = { n } , n \ $.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p>$ { n } = { n } + { n - 1 } = { n } + { n - 1 } + { n - 2 } = . . . \
$,最终下标会减成负数,这样后面的项就全都是$0 $了.</p>
<p>也可以考虑组合意义:如果$r <span class="math inline">\(,那么我们考虑从右到左第一个没有被选上的数,假设它是\)</span>r
+ k + 1 <span class="math inline">\(,那么在它右边的数全部选择了,一共是\)</span>n - k
<span class="math inline">\(个数,而还需要在左边的\)</span>r + k <span class="math inline">\(中选择\)</span>k $个数.</p>
<ol start="9" type="1">
<li>上指标求和法:$_{ 0 k n } { m } = { m + 1 } , n , m \ $.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是$k + 1 <span class="math inline">\(,接下来就还需要在\)</span>[ 1 , k ] <span class="math inline">\(中选择\)</span>m $个.</p>
<p>如果我们将这个公式两边同时乘以$m ! <span class="math inline">\(,我们可以得到公式:\)</span>_{ 0 k n } k ^{ } = { m
+ 1 } , n , m \ $,这也就是有限微积分的公式中的一个.</p>
<ol start="10" type="1">
<li>二项式定理:$( x + y ) ^r = _{ k } { k } x ^k y ^{ r - k } , r \
$.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 0 \leq k \leq n  } \binom { n  } { k  } &amp; = 2 ^n , n \in
\mathbb { N  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令$x = y = 1 $即可证明.</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ 0 \leq k \leq n  } ( - 1 ) ^k \binom { n  } { k  } &amp; = 0 ^n
&amp; = [ n &amp; = 0 ] , n \in \mathbb { N  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令$x = - 1 , y = 1 <span class="math inline">\(即可证明,值得一提的是,当\)</span>n = 0
$的时候这个式子给出$1 $,并在其他情况下给出$0
$,这个式子是二项式反演的基础.</p>
<ol start="11" type="1">
<li>三项式定理:$( x + y + z ) ^n = _{ 0 a , b , c n } [ a + b + c = n ]
{ a ! b ! c ! } x ^a y ^b z ^c , n \ $.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,$ { a ! b ! c ! } = { b + c } { c }
$.</p>
<ol start="12" type="1">
<li>多项式定理:$( _{ i = 1 } ^m x <em>i ) ^n = </em>{ i , 0 a <em>i n }
[ _{ i = 1 } ^m a _i = n ] { </em>{ i = 1 } ^m a <em>i ! } </em>{ i = 1
} ^m x _i ^{ a _i } , n \ $.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol start="13" type="1">
<li>范德蒙德卷积:$_{ k } { m + k } { n - k } = { n + m } , n , m \
$.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol start="14" type="1">
<li>范德蒙德卷积的变式:$_{ k } { m + k } { n + k } = { l - m + n } , l ,
n , m \ $.</li>
</ol>
<p>有$ { m + k } = { l - m - k } $,然后运用范德蒙德卷积即可得到答案.</p>
<ol start="15" type="1">
<li>上指标反转公式:$ { k } = ( - 1 ) ^k { k } \ $.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3>
<ol type="1">
<li>$_{ k m } { k } ( - 1 ) ^k = ( - 1 ) ^m { m } , m \ $.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k \leq m  } \binom { r  } { k  } ( - 1 ) ^k &amp; = \sum _{ k
\leq m  } \binom { k - r - 1  } { k  } \\
&amp; = \binom { - r + m  } { m  } &amp; = ( - 1 ) ^m \binom { r - 1  }
{ m  }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li>$_{ - q k l } { m } { n } = { m + n + 1 } , n , m , l + q \ $.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol start="3" type="1">
<li>$_{ k } { a + k } { b + k } ( - 1 ) ^k = { a } , a , b \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="4" type="1">
<li>$_{ k = 0 } ^m { { k } } = { n + 1 - m } , n , m , n m \ $.</li>
</ol>
<p>我们有$ { m } { k } = { k } { m - k } \ <span class="math inline">\(,两边同时除以\)</span> { m } { m - k } \ <span class="math inline">\(,于是我们得到了\)</span> { { k } } = { { m } } \
$.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^m \cfrac { \binom { m  } { k  }  } { \binom { n  } {
k  }  } &amp; = \sum _{ k = 0  } ^m \cfrac { \binom { n - k  } { m -
k  }  } { \binom { n  } { m  }  } \\
&amp; = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m
\binom { n - k  } { m - k  } \\
&amp; = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m
\binom { n - m + k  } { k  } \\
&amp; = \cfrac { \binom { n + 1  } { m  }  } { \binom { n  } { m  }  }
\\
&amp; = \cfrac { n + 1  } { n + 1 - m  }
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li>$( - 1 ) ^m { m } = ( - 1 ) ^n { n } , n , m \ $.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于$ { m } \ $.</p>
<ol start="6" type="1">
<li>$_{ k m } { k } ( { 2 } - k ) = { 2 } { m + 1 } , m \ $.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol start="7" type="1">
<li>$<em>{ k m } { k } x ^k y ^{ m - k } = </em>{ k m } { k } ( - x ) ^k
( x + y ) ^{ m - k } , m \ $.</li>
</ol>
<p>不妨令左边的值为$S _m $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S _m &amp; = \sum _{ k \leq m  } \binom { m + r  } { k  } x ^k y ^{ m -
k  } &amp; = \sum _{ k \leq m  } \binom { m + r - 1  } { k  } x ^k y ^{
m - k  } + \sum _{ k \leq m  } \binom { m + r - 1  } { k - 1  } x ^k y
^{ m - k  } \\
&amp; = y \sum _{ k &lt; m  } \binom { m - 1 + r  } { k  } x ^k y ^{ m -
1 - k  } + \binom { m + r - 1  } { m  } x ^m + x \sum _{ k \leq m  }
\binom { m + r - 1  } { k - 1  } x ^{ k - 1  } y ^{ m - k  } \\
&amp; = ( x + y ) S _{ m - 1  } + \binom { m + r - 1  } { m  } x ^m \\
&amp; = ( x + y ) S _{ m - 1  } + \binom { r  } { m  } ( - x ) ^m
\end{aligned}
\]</span></p>
<p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol start="8" type="1">
<li>$_{ k m } { k } 2 ^{ - k } = 2 ^m , m \ $.</li>
</ol>
<p>考虑$( 7 ) <span class="math inline">\(,将\)</span>x = y = 1 , r = m
+ 1 $带入,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k \leq m  } \binom { 2 m + 1  } { k  } &amp; = \sum _{ k \leq
m  } \binom { m + k  } { k  } 2 ^{ m - k  } \\
2 ^{ 2 m  } &amp; = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ m
- k  } \\
2 ^m &amp; = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ - k  }
\end{aligned}
\]</span></p>
<ol start="9" type="1">
<li>$_{ k } { m + k } { n } ( - 1 ) ^k = ( - 1 ) ^{ l + m } { n - l } ,
l , n , m \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="10" type="1">
<li>$_{ k l } { m } { k - n } ( - 1 ) ^k = ( - 1 ) ^{ l + m } { l - n -
m } , l , n , m \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3>
<ol type="1">
<li>$ { k } { k } = { 2 ^{ 2 k } } , k \ $.</li>
</ol>
<p>将加倍公式两边同时除以$k ! ^2 $即可得到这个公式.</p>
<ol start="2" type="1">
<li>$ { n } = { 2 ^{ 2 n } } , n \ $.</li>
</ol>
<p>将$( 1 ) <span class="math inline">\(中令\)</span>r = k = n
$即可得到这个公式.</p>
<ol start="3" type="1">
<li>$ { n } = ( { 4 } ) ^n { n } , n \ $.</li>
</ol>
<p>即$( 2 ) $的变形.</p>
<ol start="4" type="1">
<li>$_{ k } { 2 k } { k } 2 ^{ - 2 k } = { { 2 } } , n \ $</li>
</ol>
<p>首先根据$( 1 ) <span class="math inline">\(,左边\)</span>= _{ k } { k
} { k } \ <span class="math inline">\(,而考虑到\)</span> { 2 } <span class="math inline">\(和\)</span> { 2 }
$必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol start="5" type="1">
<li>$_{ k } { k } { n - k } = ( - 1 ) ^n , n \ $.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol start="6" type="1">
<li>$_{ k } { k } { n - k } = 4 ^n , n \ $.</li>
</ol>
<p>由$( 5 ) <span class="math inline">\(和\)</span>( 3 ) $不难推出.</p>
<ol start="7" type="1">
<li>$_{ k } { k } { x + k } = x ^{ - 1 } { n } ^{ - 1 } , x { 0 , - 1 ,
. . . , - n } \ $.</li>
</ol>
<p>令$f ( x ) = ( x - 1 ) ^{ } $,直接做高阶差分即可得到这个式子.</p>
<ol start="8" type="1">
<li>$_{ k = 0 } ^n { k } { n - k } ( - 1 ) ^k = [ n  is   ] ( - 1 ) ^{ {
2 } } { { 2 } } \ $.</li>
</ol>
<p>首先不难发现,$( 1 - z ) ^r = _{ k } ( - 1 ) ^k { k } \ $.</p>
<p>考虑$( 1 - z ) ^r ( 1 + z ) ^r = ( 1 - z ^2 ) ^r $.</p>
<p>我们有$[ z ^n ] ( 1 - z ) ^r ( 1 + z ) ^r = [ z ^n ] ( 1 - z ^2 ) ^r
$,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3>
<p>卡特兰数$f _n $表示:长度为$2 n $的合法括号序列个数.</p>
<p>卡特兰数的前几项为$1 , 1 , 2 , 5 , 14 , 42 , 132 $.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:$f <em>n = </em>{ i = 0 } ^{ n - 1 } f <em>i f </em>{ n - 1
- i } $.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如$( A ) B
$.</p>
<p>考虑将其删成$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,则\)</span>A <span class="math inline">\(一定合法,因为若\)</span>A
$不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:$f <em>n = { n + 1 } C </em>{ 2 n } ^n = C <em>{ 2 n } ^n -
C </em>{ 2 n } ^{ n - 1 } $.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从$( 0 , 0 ) <span class="math inline">\(走到\)</span>( 2 n , 0 )
$不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到$( 2 n , 0 ) <span class="math inline">\(的方案数是\)</span>C _{ 2 n } ^n $.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点$( x , - 1 ) $.</p>
<p>考虑将$x <span class="math inline">\(以后的折线以直线\)</span>y = - 1
<span class="math inline">\(为对称轴反转,那么终点到了\)</span>( 2 n , -
2 ) $.</p>
<p>不难发现,任意从$( 0 , 0 ) <span class="math inline">\(走到\)</span>(
2 n , - 2 ) <span class="math inline">\(的方案一定唯一对应了一种从\)</span>( 0 , 0 ) <span class="math inline">\(走到\)</span>( 2 n , 0 ) <span class="math inline">\(的不合法方案.因为从\)</span>( 0 , 0 ) <span class="math inline">\(走到\)</span>( 2 n , - 2 ) <span class="math inline">\(一定会经过直线\)</span>y = - 1 <span class="math inline">\(,将后半部分对称后就是其对应方案.而从\)</span>( 0 ,
0 ) <span class="math inline">\(走到\)</span>( 2 n , - 2 ) <span class="math inline">\(的方案数为\)</span>C _{ 2 n } ^{ n - 1 } $.</p>
<p>因而$f <em>n = C </em>{ 2 n } ^n - C _{ 2 n } ^{ n - 1 } \ $.</p>
<p>而$C <em>{ 2 n } ^n - C </em>{ 2 n } ^{ n - 1 } = { n ! n ! } - { ( n
- 1 ) ! ( n + 1 ) ! } = { n ! ( n + 1 ) ! } = { n + 1 } \ $.</p>
<p>递推定义:$f <em>n = { n + 1 } f </em>{ n - 1 } \ $.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\</p>
<p>f_{n-1}=</p>
<p>\end{cases}\</p>
<p>不难发现$f <em>n = { n ( n + 1 ) } f </em>{ n - 1 } \ <span class="math inline">\(.整理,得到\)</span>f <em>n = { n + 1 } f </em>{ n
- 1 } \ $.</p>
<p>换个记号,设$C _n <span class="math inline">\(为卡特兰数的第\)</span>n
<span class="math inline">\(项,卡特兰数有一个著名的结论是\)</span>k
$次卷积:</p>
<p><span class="math display">\[
C ^{ ( k )  } _n = \sum _{ \sum _{ j = 1  } ^k a _j = n  } \prod C _{ a
_i  } = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  }
\]</span></p>
<p>我们可以这么理解它:它指的是一个长度为$n + k - 1 <span class="math inline">\(的括号序列,前\)</span>k - 1 <span class="math inline">\(个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成\)</span>(
( ( A ) B ) C ) D $之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<p><span class="math display">\[
\begin{aligned}
C ^{ ( k )  } _n &amp; = \binom { 2 n + k - 1  } { n  } - \binom { 2 n +
k - 1  } { n - 1  } \\
&amp; = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  }
\end{aligned}
\]</span></p>
<h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5>
<p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是$
{ n } $.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5>
<p>给定$x , n <span class="math inline">\(,对\)</span>y <span class="math inline">\(,固定\)</span>p _x = y <span class="math inline">\(做笛卡尔树的**形态**计数.\)</span>n ^5 $.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现$a
_x = y $只要满足:</p>
<ol type="1">
<li><p>$x <span class="math inline">\(节点的祖先数量不超过\)</span>y - 1
<span class="math inline">\(个(深度小于等于\)</span>y $).</p></li>
<li><p>$x <span class="math inline">\(节点的子树大小不超过\)</span>n - y
+ 1 $.</p></li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出$f _p <span class="math inline">\(表示\)</span>x
<span class="math inline">\(的深度为\)</span>p <span class="math inline">\(的答案,\)</span>g _p <span class="math inline">\(表示\)</span>x <span class="math inline">\(的子树大小为\)</span>p
$的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:$x <span class="math inline">\(的祖先有两种:一种在序列中在\)</span>x <span class="math inline">\(的左边,一种在\)</span>x $的右边.我们设前者为$0 = l
<em>0 &lt; l <em>1 &lt; l <em>2 &lt; l <em>p &lt; l </em>{ p + 1 } = x
<span class="math inline">\(,设后者为\)</span>n + 1 = r <em>0 &gt; r
<em>1 &gt; r <em>2 &gt; &gt; r </em>{ q } &gt; r </em>{ q + 1 } = x
<span class="math inline">\(.这么分类有什么用呢?我们考虑\)</span>( l
</em>{ i - 1 } , l </em>{ i } ) <span class="math inline">\(这一段数能放在哪里,它只能是\)</span>l </em>{ i }
<span class="math inline">\(的左儿子,独立于整棵树,因此这一段的答案就是\)</span>C
</em>{ l <em>i - l </em>{ i - 1 } - 1 } $.</p>
<p>记:</p>
$$
<span class="math display">\[\begin{aligned}
L _p &amp; = \sum _{ l  } \prod _{ i = 1  } ^{ p + 1  } C _{ l _i - l _{
i - 1  } - 1  } \\
R _q &amp; = \sum _{ r  } \prod _{ i = 1  } ^{ q + 1  } C _{ r _{ i -
1  } - r _i - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到这等价于卡特兰数的$k $次卷积,有:</p>
$$
<span class="math display">\[\begin{aligned}
L _p &amp; = C _{ x - p - 1  } ^{ ( p + 1 )  } \\
R _q &amp; = C ^{ ( q + 1 )  } _{ n - x - q  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时的答案自然是$f _{ p + q + 1 } = L _p R _q { q } $,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把$x
<span class="math inline">\(的子树从原树中删去,然后插入\)</span>x <span class="math inline">\(一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为\)</span>p
<span class="math inline">\(,右子树大小为\)</span>q <span class="math inline">\(,我们有\)</span>g _{ p + q + 1 } = C <em>p C <em>q
C </em>{ n - ( p + q + 1 ) } = C </em>{ n - 1 } ^{ ( 3 ) }
$,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3>
<h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求$_{ k = 0 } ^n k { m - n - 1 } , n , m m &gt; n \ $.</p>
<p>这个式子乘了个系数$k <span class="math inline">\(导致很难处理,一个自然的想法是使用吸收恒等式将\)</span>k
$消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } &amp; = \sum
_{ k = 0  } ^n m \binom { m - k - 1  } { m - n - 1  } - \sum _{ k = 0  }
^n ( m - k ) \binom { m - k - 1  } { m - n - 1  } \\
&amp; = m \sum _{ k = 0  } ^{ m - 1  } \binom { m - k - 1  } { m - n -
1  } - ( m - n ) \sum _{ k = 0  } ^m \binom { m - k  } { m - n  }
\end{aligned}
\]</span></p>
<p>不妨令$S <em>m = </em>{ k = 0 } ^m { m - n } \ $,不难发现我们有:</p>
<p><span class="math display">\[
S _m = \sum _{ k = 0  } ^m \binom { k  } { m - n  } = \binom { m + 1  }
{ m - n + 1  }
\]</span></p>
<p>于是原式$= mS _{ m - 1 } - ( m - n ) S _m = { m - n + 1 } { m - n } \
$.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将$k = { 1 }
$带入:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } &amp; = \sum
_{ k = 0  } ^n \binom { k  } { 1  } \binom { m - k - 1  } { m - n - 1  }
\\
&amp; = \binom { m  } { m - n + 1  } \\
&amp; = \cfrac { n  } { m - n + 1  } \binom { m  } { m - n  }
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>求$_{ k } k { k } { k } , n \ $.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到$n <span class="math inline">\(和\)</span>s
$的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k  } k \binom { n  } { k  } \binom { s  } { k  } &amp; = s \sum
_{ k  } \binom { n  } { k  } \binom { s - 1  } { k - 1  } \\
&amp; = s \binom { n + s - 1  } { n - 1  }
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求$_{ 0 k } { 2 k } { k } { k + 1 } , n \ $.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 0 \leq k  } \binom { n + k  } { 2 k  } \binom { 2 k  } { k  }
\cfrac { ( - 1 ) ^k  } { k + 1  } &amp; = \sum _{ 0 \leq k  } \binom { n
+ k  } { k  } \binom { n  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n
\in \mathbb { N  } \\
&amp; = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { n + k  } {
k  } \binom { n + 1  } { k + 1  } { ( - 1 ) ^k  } \\
&amp; = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { - n - 1  }
{ k  } \binom { n + 1  } { k + 1  } \\
&amp; = \cfrac { 1  } { n + 1  } \binom { 0  } { n  } \\
&amp; = [ n &amp; = 0 ]
\end{aligned}
\]</span></p>
<h5><span id="example4">Example4</span></h5>
<p>求$_{ k } { m + 2 k } { k } { k + 1 } , n , m \ $.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的$( 1 ) $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k \geq 0  } \binom { n + k  } { m + 2 k  } \binom { 2 k  } {
k  } \cfrac { ( - 1 ) ^k  } { k + 1  } &amp; = \sum _{ k \geq 0  } \sum
_{ 0 \leq j \leq n + k - 1  } \binom { n + k - 1 - j  } { 2 k  } \binom
{ j  } { m - 1  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k +
1  } \\
&amp; = \sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{
j + 1 - n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom
{ 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  }
\end{aligned}
\]</span></p>
<p>注意到如果$j + 1 - n <span class="math inline">\(,则\)</span> { 2 k }
\ $应为$0 $.所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{ j + 1 -
n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom { 2
k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } \\
&amp; = \sum _{ 0 \leq j &lt; n  } \binom { j  } { m - 1  } [ n - 1 - j
&amp; = 0 ] &amp; = \binom { n - 1  } { m - 1  }
\end{aligned}
\]</span></p>
<h5><span id="example5">Example5</span></h5>
<p>求$_{ k = 0 } ^n ( C _n ^k ) ^2 $.</p>
<p><span class="math display">\[
\sum _{ k = 0  } ^n ( C _n ^k ) ^2 = \sum _{ k = 0  } ^n C _{ n  } ^k
\times C _{ n  } ^{ n - k  } = C _n ^{ 2 n  }
\]</span></p>
<h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求$Q <em>n = </em>{ k ^n } { k } ( - 1 ) ^k , n \ $.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于$Q
_n $的式子中实际上只与$2 ^n <span class="math inline">\(有关,我们不妨令\)</span>R <em>n = </em>{ k n } { k
} ( - 1 ) ^k \ <span class="math inline">\(,显然有\)</span>Q <em>n = R
</em>{ 2 ^n } $.</p>
<p>而我们有:</p>
<p><span class="math display">\[
\begin{aligned}
R _n &amp; = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k
+ \sum _{ k \leq n  } \binom { n - 1 - k  } { k - 1  } ( - 1 ) ^k \\
&amp; = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k +
\sum _{ k \leq n - 1  } \binom { n - k - 2  } { k  } ( - 1 ) ^{ k + 1  }
\\
&amp; = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k
+ \binom { - 1  } { n  } ( - 1 ) ^n - ( \sum _{ k \leq n - 2  } \binom {
n - 2 - k  } { k  } ( - 1 ) ^k + \binom { - 1  } { n - 1  } ( - 1 ) ^{ n
- 1  } ) \\
&amp; = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k
- \sum _{ k \leq n - 1  } \binom { n - 2 - k  } { k  } ( - 1 ) ^k \\
&amp; = R _{ n - 1  } - R _{ n - 2  } \\
&amp; = R _{ n - 2  } - R _{ n - 3  } - R _{ n - 2  } \\
&amp; = - R _{ n - 3  } \\
&amp; = R _{ n - 6  }
\end{aligned}
\]</span></p>
也即$R _n <span class="math inline">\(具有周期性,不难计算前几项答案,最后有\)</span>Q _n
<span class="math display">\[\begin{cases}1 &amp; n = 0 \\ 0 &amp; n \
is \ \mathrm { odd  } \\ - 1 &amp; n &gt; 0 \land n \ is \ \mathrm {
even  } \end{cases}\]</span>
<p>$.</p>
<h5><span id="example2">Example2</span></h5>
<p>求$( ^{ + } <em>{ i = 0 } C ^{ ik + r } </em>{ nk } ) p $.</p>
<p>考虑设$f ( n , r ) = ^{ + } <em>{ i = 0 } C ^{ ik + r } </em>{ nk } \
$,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n , r ) &amp; = \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{
nk  } \\
&amp; = \sum _{ i = 0  } ^{ + \infty  } \sum _{ j = 0  } ^k C _{ nk -
k  } ^{ ik + r - j  } \times C _k ^j \\
&amp; = \sum ^k _{ j = 0  } C _k ^j \sum _{ i = 0  } ^{ + \infty  } C _{
nk - k  } ^{ ik + r - j  } \\
&amp; = \sum _{ j = 0  } ^k C _k ^j f ( n - 1 , r - j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理上式,得到:$f ( n , r ) = _{ j = 0 } ^k C _k ^j f ( n - 1 , r - j
) \ $.</p>
<p>于是我们得到了关于$f $的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4>
<h5><span id="example">Example</span></h5>
<p>求$_{ k = 1 } ^n k ^2 C _n ^k $.</p>
$$
<span class="math display">\[\begin{aligned}
( ( 1 + x ) ^n ) &amp; = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } ) \\
( ( 1 + x ) ^n ) &#39; &amp; = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } )
&#39; \\
n ( 1 + x ) ^{ n - 1  } &amp; = \sum _{ k = 0  } ^n kC _n ^k x ^{ k -
1  } \\
nx ( 1 + x ) ^{ n - 1  } &amp; = \sum _{ k = 0  } ^n kC _n ^k x ^{ k  }
\\
( nx ( 1 + x ) ^{ n - 1  } ) &#39; &amp; = ( \sum _{ k = 0  } ^n kC _n
^k x ^{ k  } ) &#39; \\
n ( ( 1 + x ) ^{ n - 1  } + ( n - 1 ) x ( 1 + x ) ^{ n - 2  } ) &amp; =
\sum _{ k = 0  } ^n k ^2 C _n ^k x ^{ k - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>取$x = 1 <span class="math inline">\(,则原式\)</span>= n ( n + 1 ) 2
^{ n - 2 } $.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>多次询问给定$k , r <span class="math inline">\(,\)</span>k n , r &lt;
2 n - k <span class="math inline">\(,求\)</span>_{ i = 0 } ^{ r } { 2 ^i
} { n - k } $,.</p>
<p>我们把模型抽象成:在二维平面上,从$( 0 , 0 ) <span class="math inline">\(随机游走到\)</span>( n - k + 1 , r - n + k ) <span class="math inline">\(正下方(包含这个点)的概率,容易发现此时向右走了\)</span>n
- k <span class="math inline">\(步,总共走了\)</span>r <span class="math inline">\(步,然后再向右走一步保证第一次走到了\)</span>( n -
k + 1 , r - n + k ) $下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到$x
+ y = r + 1 <span class="math inline">\(这条直线时横坐标\)</span>n - k +
1 <span class="math inline">\(的概率.枚举一下总共向上走了几步,就得到\)</span> {
2 ^{ r } } _{ j = 0 } ^{ r - n + k } { j } <span class="math inline">\(,注意这里是\)</span> { 2 ^r } <span class="math inline">\(,因为从一开始钦定了一步,因此映射过来需要多乘个\)</span>
{ 2 } $,反映射就要乘个$2 <span class="math inline">\(.但是这个式子还是做不了,因为\)</span>r <span class="math inline">\(并不满足\)</span>r n $.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于$1 - { 2 ^{ r } }
_{ i = 0 } ^{ n - k } { i } <span class="math inline">\(.我们考虑暴力预处理出\)</span>f <em>r = </em>{ i =
0 } ^{ n } { i } <span class="math inline">\(,每次删掉一个后缀的组合数就行.现在的问题在于\)</span>f
$怎么做.</p>
<p>直接拆组合数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f _r &amp; = \sum _{ i = 0  } ^n \binom { r  } { i  } \\
&amp; = \sum _{ i = 0  } ^n \binom { r - 1  } { i - 1  } + \sum _{ i =
0  } ^n \binom { r - 1  } { i  } \\
&amp; = 2 \sum _{ i = 0  } ^n \binom { r - 1  } { i  } - \binom { r -
1  } { n  } \\
&amp; = 2 f _{ r - 1  } - \binom { r - 1  } { n  }
\end{aligned}
\]</span></p>
<h3><span id="lucas定理">Lucas定理</span></h3>
<p>若$p <span class="math inline">\(是质数,则\)</span>C <em>n ^m p = C
</em>{ n p } ^{ m p } C _{ { p } } ^{ { p } } p \ $.</p>
<p>或者说,将$n <span class="math inline">\(和\)</span>m <span class="math inline">\(在\)</span>p $进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若$i <span class="math inline">\(且\)</span>i p <span class="math inline">\(,\)</span>C <em>{ p } ^i { i } C </em>{ p - 1 } ^{
i - 1 } ( p ) \ $.</p>
<p>而根据二项式定理,$( 1 + x ) ^p <em>{ i = 0 } ^p C </em>{ p } ^i x ^i
= 1 + x ^p ( p ) \ $.</p>
<p>令$n = k _1 p + b _1 <span class="math inline">\(,\)</span>m = k _2 p
+ b _2 <span class="math inline">\(,则\)</span>( 1 + x ) ^n = ( 1 + x )
^{ k _1 p } ( 1 + x ) ^{ b _1 } \ $.</p>
<p>而$( 1 + x ) ^{ k _1 p } ( 1 + x ^p ) ^{ k _1 } ( p ) \ <span class="math inline">\(,有\)</span>( 1 + x ) ^n ( 1 + x ^p ) ^{ k _1 } (
1 + x ) ^{ b _1 } \ $.</p>
<p>根据二项式定理,$C _n ^m p <span class="math inline">\(即\)</span>x ^m
$项的系数.</p>
<p>我们可以得出,$C <em>n ^m x ^m C </em>{ k _1 } ^{ k _2 } x ^{ k <em>2
p } C </em>{ b 1 } ^{ b _2 } x ^{ b _2 } \ <span class="math inline">\(,那么有\)</span>C <em>a ^b C </em>{ k _1 } ^{ k
<em>2 } C </em>{ b _1 } ^{ b _2 } \ $.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<p><span class="math display">\[
\binom { n  } { m  } \equiv [ m \subseteq n ] \pmod { 2  }
\]</span></p>
<h5><span id="example1cf1770fkoxia-andsequence">Example1([CF1770F]Koxia and
Sequence)</span></h5>
<p>首先观察样例并思考,可以发现当$n
$为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是$0
$),所以异或值为$0 <span class="math inline">\(.不然,我们可以翻转\)</span>a [ 2 . . . n ] <span class="math inline">\(,得出答案应该是所有\)</span>a _1 $的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有$y
’ y <span class="math inline">\(,求出满足\)</span>a _i y ’ , a _i = x
<span class="math inline">\(时,\)</span>a _1
$异或和.接下来怎么做呢?我们考虑拆位,若$2 ^k y ’ <span class="math inline">\(,假设\)</span>a _1 <span class="math inline">\(的第\)</span>k $位是$1
$,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第$k $位贡献是:</p>
<p><span class="math display">\[
[ 2 ^k \subseteq y &#39; ] \bigoplus _{ \sum a = x  } [ 2 ^k \subseteq a
_1 ] \prod _{ i = 1  } ^n [ a _i \subseteq y &#39; ]
\]</span></p>
<p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:$[ x y ] {
x } $.</p>
<p>所以原式化简为:</p>
$$
<span class="math display">\[\begin{aligned}
\binom { y &#39;  } { 2 ^k  } \sum _{ \sum a = x  } \binom { a _1  } { 2
^k  } \prod _{ i = 1  } ^n \binom { y &#39;  } { a _i  } \pmod { 2  } \\
&amp; = \binom { y &#39;  } { 2 ^k  } \sum _{ a _1  } \binom { y &#39; -
2 ^k  } { a _1 - 2 ^k  } \sum _{ \sum a = x - a _1  } \prod _{ i = 2  }
^n \binom { y &#39;  } { a _i  } \pmod { 2  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
\binom { y &#39;  } { 2 ^k  } \sum _{ a _1  } \binom { y &#39; - 2 ^k  }
{ a _1 - 2 ^k  } \binom { ( n - 1 ) y &#39;  } { x - a _1  } \pmod {
2  } \\
&amp; = \binom { y &#39;  } { 2 ^k  } \binom { ny &#39; - 2 ^k  } { x -
2 ^k  } \pmod { 2  } \\
&amp; = [ 2 ^k \subseteq y &#39; ] [ ( x - 2 ^k ) \subseteq ( ny &#39; -
2 ^k ) ]
\end{aligned}
\]</span></p>
<h3><span id="扩展lucas定理">扩展Lucas定理</span></h3>
<p>令$p = p _i ^{ e _i } <span class="math inline">\(,那我们只要对于每个\)</span>i <span class="math inline">\(求出\)</span>C _n ^m p _i ^{ e _i }
$,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求$C _n ^m p ^k <span class="math inline">\(,其中\)</span>p prime $.</p>
<p>原式$= { m ! ( n - m ) ! } p ^k = { { p ^y } { p ^z } } p ^{ x - y -
z } p ^k \ $.</p>
<p>现在问题转化为求$ { p ^x } p ^k 以 及 p ^x \ $.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n ! &amp; = \prod _{ i = 1  } i \\
&amp; = ( \prod _{ i = wp , w \in \mathbb { Z  }  } i ) ( \prod _{ i \ne
wp , w \in \mathbb { Z  }  } i ) \\
&amp; = p ^{ \lfloor n p \rfloor  } ( \lfloor n p \rfloor ! ) ( \prod _{
i \ne wp , w \in \mathbb { Z  }  } i ) \\
&amp; \equiv p ^{ \lfloor \frac { n  } { p  } \rfloor  } ( \lfloor \frac
{ n  } { p  } \rfloor ! ) ( \prod _{ i = 1 , i \ne wp , w \in \mathbb {
Z  }  } ^{ p ^k  } i ) ^{ \lfloor \frac { n  } { p ^k  } \rfloor  } (
\prod ^{ n \ \bmod { p ^k  }  } _{ i = p ^k \lfloor \frac { n  } { p
^k  } \rfloor , i \ne wp , w \in \mathbb { Z  }  } i ) ( \mod p ^k )
\end{aligned}
\]</span></p>
<p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将$[ 1 , n ] <span class="math inline">\(的所有数全部排成一个宽为\)</span>p ^k $的矩阵.</p>
<p>那右边第一项就是把那些$p
$的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2>
<h3><span id="第一类斯特林数">第一类斯特林数</span></h3>
<p>$n k \ <span class="math inline">\(:长度为\)</span>n <span class="math inline">\(的排列划分成\)</span>k $个轮换的方案数.</p>
<p>考虑现在已经将$n - 1 <span class="math inline">\(个数分成了若干轮换,现在新加入第\)</span>n
$个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然$= ( n - 1 ) + \ $.</p>
<p>特别地,我们定义$= [ k = 0 ] \ $.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:$_{ k = 0 } ^n = n ! $.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3>
${
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>} <span class="math inline">\(:将\)</span>n
$个本质不同的物品划分成k个非空集合的方案数.</p>
考虑现在已经放好$n - 1 <span class="math inline">\(个物品,正要放入第\)</span>n <span class="math inline">\(个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然\)</span>{
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} = k {
<span class="math display">\[\begin{array}{ c  } n - 1 \\ k
\end{array}\]</span>
} + {
<span class="math display">\[\begin{array}{ c  } n - 1 \\ k - 1
\end{array}\]</span>
<p>} \ $.</p>
特别地,我们定义${
<span class="math display">\[\begin{array}{ c  } 0 \\ k
\end{array}\]</span>
<p>} = [ k = 0 ] \ $.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3>
<p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:${ n m }
= { - m - n } \ $.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3>
<ol type="1">
<li>$x ^n = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} x ^{ } = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} ( - 1 ) ^{ n - k } x ^{ } \ $.</li>
</ol>
证明:先考虑前半段,不妨使用数学归纳.若$x ^{ n - 1 } = _{ k = 0 } ^{ n - 1
} {
<span class="math display">\[\begin{array}{ c  } n - 1 \\ k
\end{array}\]</span>
<p>} x ^{ } \ $,我们要证</p>
<p>\</p>
$$
<span class="math display">\[\begin{aligned}
x \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} x ^{ \underline { k  }  } &amp; = \sum _{ k = 0  }
^{ n  } \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} x ^{ \underline { k  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑$( x - k ) x ^{ } = x ^{ } <span class="math inline">\(,所以\)</span>x x ^{ } = x ^{ } + kx ^{ } \
$.那么左边即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} x ^{ \underline { k + 1  }  } + \sum _{ k = 0  }
^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} kx ^{ \underline { k  }  } \\
&amp; = \sum _{ k = 1  } ^{ n  } \left \{ \begin{array}
{ c  } n - 1 \\
k - 1
\end{array} \right \} x ^{ \underline { k  }  } + \sum _{ k = 1  } ^{
n  } \left \{ \begin{array}
{ c  } n - 1 \\
k
\end{array} \right \} kx ^{ \underline { k  }  } \\
&amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} x ^{ \underline { k  }  } \\
\\

\end{aligned}\]</span>
<p>$$</p>
至于后半段,由于$x ^{ } = ( - 1 ) ^n ( - x ) ^{ } \ <span class="math inline">\(,所以\)</span>x ^n = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>} ( - 1 ) ^k ( - x ) ^{ } \ $.</p>
<p>不妨用$x <span class="math inline">\(来代替\)</span>- x $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( - x ) ^n &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^k ( x ) ^{ \overline { k  }  } \\
x ^n &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^{ n - k  } x ^{ \overline { k  }  }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><p>$x ^{ } = _{ k = 0 } ^n x ^k \ $.</p></li>
<li><p>$x ^{ } = _{ k = 0 } ^n ( - 1 ) ^{ n - k } x ^k \ $.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于$( x + n - 1 ) x ^k = x ^{ k + 1 } + ( n - 1 ) x ^k \
$,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol start="4" type="1">
<li>反转公式:$_{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
} ( - 1 ) ^{ n - k } = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} ( - 1 ) ^{ n - k } = [ m = n ] \ $.</li>
</ol>
<p>证明:</p>
考虑先证明后半部分,将(3)带入(1),得到$x ^n = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
} x ^{ } = <em>{ k = 0 } ^n </em>{ m = 0 } ^k {
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>} ( - 1 ) ^{ n - k } x ^m \ $.</p>
<p>由于这对任意$x <span class="math inline">\(都成立,因此右边除了\)</span>x ^n
$以外的项系数均为$0 <span class="math inline">\(,而\)</span>x ^n
$的系数为$1 $.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol start="5" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n + 1 \\ m + 1
\end{array}\]</span>
<p>} = _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) {</p>
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
<p>} \ $.</p></li>
<li><p>$= _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) \ $.</p></li>
</ol>
<p>证明:对于前者,考虑组合意义,将$n + 1 <span class="math inline">\(个分为\)</span>m + 1 <span class="math inline">\(组,也就是先找一部分分成\)</span>m
$组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3>
<ol start="7" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n \\ m
\end{array}\]</span>
<p>} = _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) {</p>
<span class="math display">\[\begin{array}{ c  } k + 1 \\ m + 1
\end{array}\]</span>
<p>} ( - 1 ) ^{ n - k } \ $.</p></li>
<li><p>$= _{ k = m } ^n (</p>
<span class="math display">\[\begin{array}{ c  } n \\ k
\end{array}\]</span>
<p>) ( - 1 ) ^{ n - k } \ $.</p></li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol start="9" type="1">
<li>$m ! {
<span class="math display">\[\begin{array}{ c  } n \\ m
\end{array}\]</span>
} = _{ k = 0 } ^m C _m ^k k ^n ( - 1 ) ^{ m - k } \ $.</li>
</ol>
证明:首先有$m ^n = _{ k = 0 } ^m m ^{ } {
<span class="math display">\[\begin{array}{ c  } m \\ k
\end{array}\]</span>
} = _{ k = 0 } ^m k ! C _m ^k {
<span class="math display">\[\begin{array}{ c  } m \\ k
\end{array}\]</span>
<p>} \ $,对这个式子进行二项式反演即可.</p>
<ol start="10" type="1">
<li>${
<span class="math display">\[\begin{array}{ c  } n + 1 \\ m + 1
\end{array}\]</span>
} = _{ k = 0 } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
} ( m + 1 ) ^{ n - k } \ $.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前$k <span class="math inline">\(个分为\)</span>m <span class="math inline">\(组,把第\)</span>k + 1 <span class="math inline">\(个数放到第\)</span>m + 1 <span class="math inline">\(组.然后剩下\)</span>( n + 1 ) - ( k + 1 ) = n - k
<span class="math inline">\(个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第\)</span>m
+ 1 <span class="math inline">\(组(最小值最大的那组)在\)</span>k
$不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol start="11" type="1">
<li>$= <em>{ k = 0 } ^n C </em>{ n } ^k ( n - k ) ! = n ! _{ k = 0 } ^n
{ k ! } \ $.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果$n &gt; 0 <span class="math inline">\(,我们有\)</span>= ( n - 1 ) ! \ <span class="math inline">\(.这个式子很显然,我们现在有一个长度为\)</span>n - 1
<span class="math inline">\(的环,想要往里插入第\)</span>n <span class="math inline">\(个数有\)</span>n - 1 <span class="math inline">\(种选择,所以我们有:\)</span>= ( n - 1 ) \
$,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将$n + 1 <span class="math inline">\(个数划分成\)</span>m + 1 <span class="math inline">\(个环,我们先将其中\)</span>k <span class="math inline">\(个数划分成\)</span>m <span class="math inline">\(个环,剩下\)</span>n + 1 - k <span class="math inline">\(个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第\)</span>n
+ 1 $个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于$C _n ^k ( n - k ) ! = C _n ^{ n - k } ( n - k ) ! = n ^{ } = {
k ! } \ $.因此后半部分也得证.</p>
<ol start="12" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n + m + 1 \\ m
\end{array}\]</span>
<p>} = _{ k = 0 } ^m k {</p>
<span class="math display">\[\begin{array}{ c  } n + k \\ k
\end{array}\]</span>
<p>} \ $.</p></li>
<li><p>$_{ k = 0 } ^m ( n + k ) \ $.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将$n + k <span class="math inline">\(个位置分到\)</span>k <span class="math inline">\(个集合之后.还剩下\)</span>( n + m + 1 ) - ( n + k
) = ( m - k + 1 ) <span class="math inline">\(个数,剩下\)</span>( m - k
) $个集合.</p>
<p>拿出来$( n + k + 1 ) <span class="math inline">\(这个数,剩下的数刚好够每个集合放一个.最后枚举一下把\)</span>(
n + k + 1 ) $放在哪里即可.由于每个划分一定存在一段(可能是$0
$)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol start="14" type="1">
<li>$C <em>n ^m ( n - 1 ) ^{ } = </em>{ k = m } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
} \ $.</li>
</ol>
<p>证明:</p>
考虑$( n - 1 ) ^{ } = { ( m - 1 ) ! } \ <span class="math inline">\(,不妨设\)</span>f ( n , m ) = _{ k = m } ^n {
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
<p>} \ <span class="math inline">\(,相当于将\)</span>n <span class="math inline">\(个数分成非空\)</span>m <span class="math inline">\(组,然后组内的数要形成若干轮换的方案数.那么知道\)</span>f
( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m ) f ( n - 1 , m ) \ $.</p>
<p>设$g ( n , m ) = C _n ^m { ( m - 1 ) ! } = { m ! ( n - m ) ! ( m - 1
) ! } \ $,那么知道:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n - 1 , m - 1 ) &amp; = \frac { ( n - 1 ) ! ( n - 2 ) !  } { ( m - 1
) ! ( n - m ) ! ( m - 2 ) !  } \\
g ( n - 1 , m ) &amp; = \frac { ( n - 1 ) ! ( n - 2 ) !  } { m ! ( n - 1
- m ) ! ( m - 2 ) !  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然$g ( n , m ) = g ( n - 1 , m - 1 ) + ( n - 1 + m ) g ( n - 1 , m
) \ $,数学归纳即可.</p>
<ol start="15" type="1">
<li><p>$C <em>n ^m = { m ! ( n - m ) ! } = </em>{ k = m } ^n {</p>
<span class="math display">\[\begin{array}{ c  } n + 1 \\ k + 1
\end{array}\]</span>
<p>} ( - 1 ) ^{ m - k } \ $.</p></li>
<li><p>$n ^{ } = { m ! } = _{ k = m } ^n {</p>
<span class="math display">\[\begin{array}{ c  } k \\ m
\end{array}\]</span>
<p>} ( - 1 ) ^{ m - k } ， 其 中 m n \ $.</p></li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol start="17" type="1">
<li><p>${</p>
<span class="math display">\[\begin{array}{ c  } n \\ l + m
\end{array}\]</span>
<p>} C <em>{ l + m } ^l = </em>{ k = l } ^n {</p>
<span class="math display">\[\begin{array}{ c  } k \\ l
\end{array}\]</span>
<p>} {</p>
<span class="math display">\[\begin{array}{ c  } n - k \\ m
\end{array}\]</span>
<p>} C _n ^k \ $.</p></li>
<li><p>$C <em>{ l + m } ^l = </em>{ k = l } ^n C _n ^k \ $.</p></li>
</ol>
<p>证明:先考虑前者,左边即先将$n <span class="math inline">\(个数分为\)</span>l + m <span class="math inline">\(个集合,然后再挑出\)</span>l <span class="math inline">\(个集合.那不妨枚举这\)</span>l
$个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2>
记$
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
<span class="math inline">\(表示\)</span>{ 1 , 2 , . . . , n } <span class="math inline">\(的排列\)</span>a <span class="math inline">\(中满足这条性质的排列个数:存在且只存在\)</span>k
<span class="math inline">\(个升高,换句话说,存在且只存在\)</span>k <span class="math inline">\(个\)</span>i $,满足$1 i &lt; n <span class="math inline">\(,\)</span>a <em>i &lt; a </em>{ i + 1 } <span class="math inline">\(.不难发现\)</span>
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
=
<span class="math display">\[\begin{array}\\ n \\ n - k - 1
\end{array}\]</span>
<p>$.</p>
考虑在一个${ 1 , 2 , . . . , n - 1 } <span class="math inline">\(的排列中插入\)</span>n <span class="math inline">\(,设插入的位置是原本\)</span>a _i <span class="math inline">\(的后面,那么要么原本\)</span>a <em>i &lt; a </em>{
i + 1 } $,要么反之.前者不会改变排列的升高的数量,后者则会增加$1 <span class="math inline">\(.另外还有一种情况是插入到了序列最前面.于是我们自然得到:\)</span>
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
= ( k + 1 )
<span class="math display">\[\begin{array}\\ n - 1 \\ k
\end{array}\]</span>
+ ( n - k )
<span class="math display">\[\begin{array}\\ n - 1 \\ k - 1
\end{array}\]</span>
<p>$.</p>
特别地,我们令$
<span class="math display">\[\begin{array}\\ 0 \\ k \end{array}\]</span>
= [ k = 0 ] <span class="math inline">\(,若\)</span>k &lt; 0 <span class="math inline">\(,则\)</span>
<span class="math display">\[\begin{array}\\ n \\ k \end{array}\]</span>
<p>= 0 $.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3>
<p>我们有Worpitzky恒等式:</p>
<p><span class="math display">\[
x ^n = \sum _{ k \geq 0  } \binom { x + k  } { n  } \left \langle
\begin{array}
\\
n \\
k
\end{array} \right \rangle , n \in \mathbb { N  }
\]</span></p>
<p>还有另一个恒等式:</p>
<p><span class="math display">\[
\left \langle \begin{array}
\\
n \\
m
\end{array} \right \rangle = \sum _{ k = 0  } ^m \binom { n + 1  } {
k  } ( m + 1 - k ) ^n ( - 1 ) ^k
\]</span></p>
<p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2>
<p>定义$B <em>j <span class="math inline">\(为第\)</span>j <span class="math inline">\(个伯努利数,且满足\)</span></em>{ j = 0 } ^m { j }
B _j = [ m = 0 ] , m \ $.</p>
<p>定义$S <em>m ( n ) = </em>{ i = 0 } ^{ n - 1 } i ^m $.</p>
<p>伯努利数满足公式:$S <em>m ( n ) = { m + 1 } </em>{ k = 0 } ^m { k } B
_k n ^{ m + 1 - k } \ $.</p>
<p>证明如下:</p>
<p>对$S _{ m + 1 } ( n ) $使用扰动法,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
S _{ m + 1  } ( n ) + n ^{ m + 1  } &amp; = \sum _{ k = 0  } ^{ n - 1  }
( k + 1 ) ^{ m + 1  } \\
&amp; = \sum _{ k = 0  } ^{ n - 1  } \sum _{ j = 0  } ^{ m + 1  } \binom
{ m + 1  } { j  } k ^j \\
&amp; = \sum _{ j = 0  } ^{ m + 1  } \binom { m + 1  } { j  } S _j ( n )
\\
&amp; = \sum _{ j = 0  } ^{ m  } \binom { m + 1  } { j  } S _j ( n ) + S
_{ m + 1  } ( n ) \\
n ^{ m + 1  } &amp; = \sum _{ j = 0  } ^m \binom { m + 1  } { j  } S _j
( n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来使用数学归纳,假设$0 j &lt; m <span class="math inline">\(时该公式成立,并假设有\)</span>S <em>m ( n ) = { m
+ 1 } </em>{ k = 0 } ^m { k } B _k n ^{ m + 1 - k } + \ <span class="math inline">\(,我们只需要证明\)</span>= 0 $.</p>
<p><span class="math display">\[
\begin{aligned}
n ^{ m + 1  } &amp; = \sum _{ j = 0  } ^m \binom { m + 1  } { j  }
\cfrac { 1  } { j + 1  } \sum _{ k = 0  } ^j \binom { j + 1  } { k  } B
_k n ^{ j + 1 - k  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k  }
\binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _k n ^{ j + 1 - k  }
+ ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { j - k  }
\binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k +
1  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k + 1  }
\binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k +
1  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  }
\sum _{ j = k  } ^m B _{ j - k  } \binom { m + 1  } { j  } \binom { j  }
{ k  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  }
\binom { m + 1  } { k  } \sum _{ j = k  } ^m B _{ j - k  } \binom { m +
1 - k  } { j - k  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom
{ m + 1  } { k  } \sum _{ j = 0  } ^{ m - k  } B _{ j  } \binom { m + 1
- k  } { j  } + ( m + 1 ) \Delta \\
&amp; = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom
{ m + 1  } { k  } [ m - k &amp; = 0 ] + ( m + 1 ) \Delta \\
&amp; = n ^{ m + 1  } + ( m + 1 ) \Delta
\end{aligned}
\]</span></p>
<p>显然$= 0 $,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2>
定义斐波那契数$F _n =
<span class="math display">\[\begin{cases}0 &amp; n = 0 \\ 1 &amp; n = 1
\\ F _{ n - 1  } + F _{ n - 2  } &amp; n &gt; 1 \end{cases}\]</span>
<p>$.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3>
<p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<p><span class="math display">\[
F _{ n + 1  } F _{ n - 1  } - F _n ^2 = ( - 1 ) ^n , n &gt; 0
\]</span></p>
<p>事实上,如果我们将斐波那契数的递推式改写作:$F <em>n = F </em>{ n + 2 }
- F _{ n + 1 } <span class="math inline">\(,我们可以在\)</span>n
$的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<p><span class="math display">\[
F _{ - n  } = ( - 1 ) ^{ n - 1  } F _n , n \in \mathbb { Z  }
\]</span></p>
<h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3>
<p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
F _{ n + k  } &amp; = F _k F _{ n + 1  } + F _{ k - 1  } F _n \\
F _{ n + m + 1  } &amp; = F _{ n + 1  } F _{ m + 1  } + F _n F _m
\end{aligned}
\]</span></p>
<p>另外,如果我们在上面这个式子中取$k = wn , w <span class="math inline">\(并使用归纳法,我们又可以得到一个性质:\)</span>F _{
kn } <span class="math inline">\(是\)</span>F _n <span class="math inline">\(的倍数,\)</span>k $.</p>
<p>再观察这个式子,使用归纳法可以证明$( F <em>{ n } , F </em>{ n - 1 } )
= 1 <span class="math inline">\(,进一步有:\)</span>( F _{ n + m } , F _m
) = ( F _n , F _m ) $.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<p><span class="math display">\[
\gcd ( F _m , F _n ) = F _{ \gcd ( n , m )  }
\]</span></p>
<p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<p><span class="math display">\[
F _n ^2 | F _m \Leftrightarrow nF _n | m , n &gt; 2
\]</span></p>
<p>这个引理的证明如下:</p>
<p>由于$F <em>{ n + 1 } F </em>{ n - 1 } <span class="math inline">\(.于是我们有:\)</span>F <em>{ 2 n } = F <em>n F
</em>{ n + 1 } + F </em>{ n - 1 } F <em>n <span class="math inline">\(,也就是\)</span>F </em>{ 2 n } F <em>n F </em>{ n
+ 1 } $.</p>
<p>另外我们有:$F <em>{ 2 n + 1 } F </em>{ n + 1 } ^2 $.</p>
<p>同理,使用归纳法可以证明:$F <em>{ kn } kF <em>n F </em>{ n + 1 } ^{ k
- 1 } , F </em>{ kn + 1 } F _{ n + 1 } ^k $.</p>
<p>而$F _{ n + 1 } F <em>n <span class="math inline">\(,于是\)</span>F
</em>{ kn } k , n &gt; 2 $.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3>
<p>我们如果定义$j k j k + 2 $,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:$n = <em>{ i = 1 } ^r F </em>{ k _i
} , i &lt; r , k <em>i k </em>{ i + 1 } $.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果$k <span class="math inline">\(满足\)</span>F _k = n <span class="math inline">\(,则显然成立,不然,应\)</span>k <span class="math inline">\(满足\)</span>F <em>k &lt; n &lt; F </em>{ k + 1 }
<span class="math inline">\(,而\)</span>n - F _k <span class="math inline">\(的表示已经存在了.另外,由于\)</span>n - F <em>k
&lt; F </em>{ k + 1 } - F <em>k = F </em>{ k - 1 } <span class="math inline">\(,因此必定不可能出现选了\)</span>F <em>k <span class="math inline">\(又选了\)</span>F </em>{ k - 1 }
$的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择$F <em>k <span class="math inline">\(而是选择\)</span>F </em>{ k - 1 } <span class="math inline">\(,那么显然接下来无论怎么选,它们的加和都不可能大于等于\)</span>F
_k $,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数$n $以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3>
<p>使用生成函数,令$F ( z ) = _{ k } F _k z ^k <span class="math inline">\(.那么不难发现\)</span>F ( z ) - zF ( z ) - z ^2 F
( z ) = z <span class="math inline">\(,也就是\)</span>F ( z ) = { 1 - z
- z ^2 } $.</p>
<p>考虑这个形式一定可以分解为$F ( z ) = { 1 - z } + { 1 - z }
$的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令$= { 2 } , = { 2 } <span class="math inline">\(,那么可以得到\)</span>F _n = { } ( ^n - ^n )
$.</p>
<p>另外,由于$^n <span class="math inline">\(的影响很小,于是又有\)</span>F _n = { } + 0 . 5
$.</p>
<h3><span id="连项式">连项式</span></h3>
连项式多项式$K _n ( x _1 , x _2 , . . . , x _n ) <span class="math inline">\(定义为:\)</span>K _n ( x _1 , x _2 , . . . , x _n
) =
<span class="math display">\[\begin{cases}1 &amp; n = 0 \\ x _1 &amp; n
= 1 \\ x _n K _{ n - 1  } ( x _1 , x _2 , . . . x _{ n - 1  } ) + K _{ n
- 2  } ( x _1 , x _2 , . . . , x _{ n - 2  } ) &amp; n \geq 2
\end{cases}\]</span>
<p>$.</p>
<p>通过定义不难发现:$K <em>n ( 1 , 1 , . . . , 1 ) = F </em>{ n + 1 }
$.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数$( x _{
n - 1 } , x _n )
$.我们考虑用这样一种形式的字符串来表示最后某一项的情况:‘.’为还没有消除掉的项,长度为$1
$;’-’为已经消除了的两项,长度为$2 <span class="math inline">\(.那么\)</span>K _n ( x _1 , x _2 , . . . , x _n )
<span class="math inline">\(就可以表示为一个长度为\)</span>n <span class="math inline">\(的字符串,其中若有\)</span>k <span class="math inline">\(个&#39;-&#39;,有\)</span>n - 2 k <span class="math inline">\(个&#39;.&#39;,则有\)</span> { k }
$种不同的排列方式.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
K _n ( z , z , . . . , z ) &amp; = \sum _{ k = 0  } ^n \binom { n - k  }
{ k  } z ^{ n - 2 k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,这也导出:$F <em>{ n + 1 } = </em>{ k = 0 } ^n { k } \ $.</p>
<p>考虑上面的构造过程,不难发现$K _n ( x _1 , x _2 , . . . , x _n ) = K
_n ( x <em>n , x </em>{ n - 1 } , . . . , x _1 ) $.</p>
<p>于是递归式可以写成:$K _n ( x _1 , x _2 , . . . , x _n ) = x <em>1 K
</em>{ n - 1 } ( x <em>2 , x <em>3 , . . . x </em>{ n } ) + K </em>{ n -
2 } ( x _3 , x <em>4 , . . . , x </em>{ n } ) $.</p>
<p>进一步地,不断展开后得到:</p>
<p><span class="math display">\[
\begin{aligned}
K _{ m + n  } ( x _1 , . . . , x _m , x _{ m + 1  } , . . . , x _{ n +
m  } ) &amp; = \\
K _m ( x _1 , . . . , x _m ) K _n ( x _{ m + 1  } , . . . , x _{ n +
m  } ) + K _{ m - 1  } ( x _1 , . . . , x _{ m - 1  } ) K _{ n - 1  } (
x _{ m + 2  } , . . . , x _{ n + m  } )
\end{aligned}
\]</span></p>
<p>另外,根据连项式的定义,不难导出$K _n ( x _1 , . . . , x _n + y ) = K
_n ( x _1 , . . . , x <em>n ) + K </em>{ n - 1 } ( x <em>1 , . . . , x
</em>{ n - 1 } ) y $.</p>
<p>由这个公式可以推出:$ { K _n ( a _1 , . . . , a <em>n ) } = { K </em>{
n - 1 } ( a <em>1 , . . . , a </em>{ n - 1 } + { a _n } ) } $.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<p><span class="math display">\[
\cfrac { K _{ n + 1  } ( a _0 , . . . , a _n )  } { K _n ( a _1 , . . .
, a _n )  } = a _0 + \cfrac { 1  } { a _1 + \cfrac { 1  } { a _2 +
\cfrac { 1  } { a _3 + . . .  }  }  }
\]</span></p>
<p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" class="post-title-link" itemprop="url">简单乐理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="前言">前言</span></h3>
<p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3>
<h4><span id="拍音理论">拍音理论</span></h4>
<p>假设两个正弦单音的频率分别是$, + $,那么它们叠加后是:</p>
<p><span class="math display">\[
\begin{aligned}
\sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
&amp; = 2 \sin \left ( 2 \pi ( \omega + \frac { \delta  } { 2  } ) t
\right ) \cos ( \pi \delta t )
\end{aligned}
\]</span></p>
<p>注意到这个声音受到$( t ) <span class="math inline">\(的控制.因此会以\)</span> { 2 } <span class="math inline">\(的频率振动,由于\)</span><span class="math inline">\(应该远小于\)</span><span class="math inline">\(,这里就会产生\)</span>= | _1 - _2 | $个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4>
<p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol type="1">
<li><p>弦长$L $.</p></li>
<li><p>张力$T $.</p></li>
<li><p>线密度$$.</p></li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点$u
( x , t ) $,首先是一维振动方程:</p>
<p><span class="math display">\[
\frac { \partial ^2 u  } { \partial x ^2  } = \frac { \rho  } { T  }
\frac { \partial ^2 u  } { \partial t ^2  }
\]</span></p>
<p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<p><span class="math display">\[
u _n ( x , t ) = c _n \sin ( \omega _n t + \theta _n ) \sin ( \frac { n
\pi  } { L  } x )
\]</span></p>
<p>其中第$n $项的频率满足:</p>
<p><span class="math display">\[
f _n = \frac { n  } { 2 L  } \sqrt { \frac { T  } { \rho  }  }
\]</span></p>
<p>其中我们将$f _1 <span class="math inline">\(称为**基频**,相应的声音称为**基音**,而将剩下的频率对应的声音统称为泛音,其中\)</span>f
_n , n <span class="math inline">\(对应的是第\)</span>n - 1 $泛音.</p>
<p>特别地,如果我们干脆记$f = f _1
$,上述结果告诉我们弦的振动产生的一列频率是:</p>
<p><span class="math display">\[
f , 2 f , 3 f , \cdots
\]</span></p>
<p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的$n
$,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0"></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的$f
_{ 2 k + 1 } $,泛音列中只剩下$2 f , 4 f , <span class="math inline">\(.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按\)</span>
{ 3 } $处呢?那泛音列中就会只剩下$3 f , 6 f , 9 f ,
$,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是$f
, 3 f , 5 f , $.</p>
<h4><span id="管乐器">管乐器</span></h4>
<p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<p><span class="math display">\[
f , 2 f , 3 f , 4 f , \cdots
\]</span></p>
<p>闭管的泛音列:</p>
<p><span class="math display">\[
f , 3 f , 5 f , 7 f
\]</span></p>
<p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4>
<p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots
\end{gathered}
\]</span></p>
<p>或是:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac { 3  } { 2  } f , 3 f , \frac { 9  } { 2  } f , 6 f , \cdots
\end{gathered}
\]</span></p>
<p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3>
<p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是$L
<em>p = 20 </em>{ 10 } ( { p _0 } ) <span class="math inline">\(,其中\)</span>p _0 = 20 Pa $.</p>
<h4><span id="音程">音程</span></h4>
<p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<div class="line-block">度数 | 半音数 | 名称 |</div>
<div class="line-block">—- | —— | —— |</div>
<div class="line-block">一 | 0 | 纯一度 |</div>
<div class="line-block">二 | 1 | 小二度 |</div>
<div class="line-block">二 | 2 | 大二度 |</div>
<div class="line-block">三 | 3 | 小三度 |</div>
<div class="line-block">三 | 4 | 大三度 |</div>
<div class="line-block">四 | 5 | 纯四度 |</div>
<div class="line-block">四 | 6 | 增四度 |</div>
<div class="line-block">五 | 6 | 减五度 |</div>
<div class="line-block">五 | 7 | 纯五度 |</div>
<div class="line-block">六 | 8 | 小六度 |</div>
<div class="line-block">六 | 9 | 大六度 |</div>
<div class="line-block">七 | 10 | 小七度 |</div>
<div class="line-block">七 | 11 | 大七度 |</div>
<div class="line-block">八 | 12 | 纯八度 |</div>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<div class="line-block">音程 | 频率比 |</div>
<div class="line-block">—— | —— |</div>
<div class="line-block">纯八度 | $2 : 1 $ |</div>
<div class="line-block">纯五度 | $3 : 2 $ |</div>
<div class="line-block">纯四度 | $4 : 3 $ |</div>
<div class="line-block">大三度 | $5 : 4 $ |</div>
<div class="line-block">小三度 | $6 : 5 $ |</div>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4>
<p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定$C
$的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为$1 <span class="math inline">\(,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求\)</span>{
7 k } $这个数列对吧,简单数论知识告诉我们它必然能遍历$12
$种情况,具体而言:</p>
$$
<span class="math display">\[\begin{aligned}
C \to &amp; &amp; G \to &amp; &amp; D \to &amp; &amp; A \to &amp; &amp;
E \to &amp; &amp; B \to \\
1 \to &amp; &amp; \frac { 3  } { 2  } \to &amp; &amp; \frac { 3 ^2  } {
2 ^3  } \to &amp; &amp; \frac { 3 ^3  } { 2 ^4  } \to &amp; &amp; \frac
{ 3 ^4  } { 2 ^6  } \to &amp; &amp; \frac { 3 ^5  } { 2 ^7  } \to \\
\\
\\
\# F \to &amp; &amp; \# C \to &amp; &amp; \# G \to &amp; &amp; \# D \to
&amp; &amp; \# A \to &amp; &amp; \# E \\
\frac { 3 ^6  } { 2 ^9  } \to &amp; &amp; \frac { 3 ^7  } { 2 ^{
11  }  } \to &amp; &amp; \frac { 3 ^8  } { 2 ^{ 12  }  } \to &amp; &amp;
\frac { 3 ^9  } { 2 ^{ 14  }  } \to &amp; &amp; \frac { 3 ^{ 10  }  } {
2 ^{ 15  }  } \to &amp; &amp; \frac { 3 ^{ 11  }  } { 2 ^{ 17  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度$CE
<span class="math inline">\(的比是\)</span> { 64 } &gt; { 64 } = { 4 }
$.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的$#
E F <span class="math inline">\(,你对着这个\)</span># E <span class="math inline">\(往上再升一个音得到的理应是\)</span>C ’ = { 2 ^{ 18
} } &gt; 2 <span class="math inline">\(,具体来说\)</span> { 2 ^{ 19 } }
. 013643
$,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于$1
$的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升$12
$个纯五度,再下降$7 $个纯八度理应回到原点,可是:</p>
<p><span class="math display">\[
( \frac { 3  } { 2  } ) ^{ 12  } \times ( \frac { 1  } { 2  } ) ^7 &gt;
1
\]</span></p>
<p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4>
<p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定$C $的频率为$1 <span class="math inline">\(.接下来用正三和弦(一个大三度和一个小三度)\)</span>I
: C - E - G <span class="math inline">\(,\)</span>IV : F - A - C ’ <span class="math inline">\(,\)</span>V : G - B - D ’ $的比例是$4 : 5 : 6
$确定剩下的:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; &amp; D &amp; &amp; E &amp; &amp; F &amp; &amp; G &amp; &amp; A
&amp; &amp; B &amp; &amp; C &#39; &amp; &amp; D &#39; \\
1 &amp; &amp; \frac { 9  } { 8  } &amp; &amp; \frac { 5  } { 4  } &amp;
&amp; \frac { 4  } { 3  } &amp; &amp; \frac { 3  } { 2  } &amp; &amp;
\frac { 5  } { 3  } &amp; &amp; \frac { 15  } { 8  } &amp; &amp; 2 &amp;
&amp; \frac { 9  } { 4  }
\end{aligned}
\]</span></p>
<p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol type="1">
<li><p>五度音程$D - A <span class="math inline">\(不协和,比例为\)</span>
{ 54 } &lt; { 54 } = { 2 } $.这直接导致了转调会出错.</p></li>
<li><p>有两种不同的大二度:音程$C - D , F - G , A - B <span class="math inline">\(的比例是\)</span> { 8 } <span class="math inline">\(而音程\)</span>D - E , G - A <span class="math inline">\(的比例为\)</span> { 9 } $.</p></li>
<li><p><strong>谐调音差</strong>:从$C <span class="math inline">\(出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:\)</span>(
{ 2 } ) ^4 ( { 2 } ) ^2 { 5 } = { 80 } = 1 . 0125 &gt; 1 $.</p></li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4>
<p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用$
$来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是$f _1 ,
f _2 $,则它们的音分数定义为$1200 _2 ( { f _1 } )
$,容易见到十二平均律拿到的一个半音恰好是$100 $音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3>
<h4><span id="大小调">大小调</span></h4>
<h5><span id="自然大调">自然大调</span></h5>
<p>就是我们最常用的$CDEFGABC ’
$,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol type="1">
<li><p>主音</p></li>
<li><p>上主音</p></li>
<li><p>中音</p></li>
<li><p>下属音</p></li>
<li><p>属音</p></li>
<li><p>下中音</p></li>
<li><p>导音</p></li>
</ol>
<p>用五度相生,下属音$<span class="math inline">\(主音\)</span>$属音.</p>
<h5><span id="自然小调">自然小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以$ABCDEFG <span class="math inline">\(用的调子,然而这里的问题是\)</span>G <span class="math inline">\(作为导音却和\)</span>A ’ $差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用$A , B , C , D , E , F , ( ^# G )
$.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用$A , B , C , D , E , ( ^# F ) , ( ^#
G ) $.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4>
<p>以五度相生:</p>
<p><span class="math display">\[
C \to G \to D \to A \to E \to B \to ( ^\# F ) \to ( ^\# C )
\]</span></p>
<p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从$C
<span class="math inline">\(开始每次往后跳一次都要在一个音阶上增一个升号.从\)</span>C
<span class="math inline">\(大调提升到\)</span>G <span class="math inline">\(大调的时候就是将\)</span>C <span class="math inline">\(的下属音(也就是\)</span>F $)升音.</p>
<p>对称地,反方向的五度相生:</p>
<p><span class="math display">\[
C \to F \to ( ^b B ) \to ( ^b E ) \to ( ^b A ) \to ( ^b D ) \to ( ^b G )
\to ( ^b C )
\]</span></p>
<p>那这个应该降什么呢?比如从$C <span class="math inline">\(大调提升到\)</span>F <span class="math inline">\(大调的时候就是将\)</span>F <span class="math inline">\(的下属音\)</span>B $降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png"></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3>
<h4><span id="三和弦">三和弦</span></h4>
<p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol type="1">
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成$4 : 5 : 6
$的频率关系.</p></li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p></li>
<li><p>减三和弦:两个小三度.</p></li>
<li><p>增三和弦:两个大三度.</p></li>
</ol>
<h4><span id="七和弦">七和弦</span></h4>
<p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol type="1">
<li><p>减减七和弦(减七和弦):小小小.</p></li>
<li><p>减小七和弦(半减七和弦):小小大.</p></li>
<li><p>小小七和弦(小七和弦):小大小.</p></li>
<li><p>小大七和弦:小大大.</p></li>
<li><p>大小七和弦(属七和弦):大小小.</p></li>
<li><p>大大七和弦(大七和弦):大小大.</p></li>
<li><p>增大七和弦:大大小.</p></li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4>
<p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p></li>
</ol>
<p>对于七和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p></li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p></li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4>
<p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为$C
- E - G <span class="math inline">\(,\)</span>F - A - C ’ <span class="math inline">\(,\)</span>G - B - D ’
$.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol type="1">
<li><p>正格进行:$I V I $.</p></li>
<li><p>变格进行:$I IV I $.</p></li>
<li><p>复式进行:$I IV V I $.</p></li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<p><span class="math display">\[
\xymatrix { &amp; &amp; &amp; &amp; I \\
&amp; &amp; IV \ar [r ] \ar [d ] \ar [dr ] \ar [rru ] &amp; vii \degree
\ar [ru ] &amp; \\
iii \ar [r ] &amp; vi \ar [r ] \ar [ru ] &amp; ii \ar [r ] \ar [ru ]
&amp; V \ar [ruu ] &amp;  }
\]</span></p>
<p>其中$I $较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4>
<p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol type="1">
<li><p>平行变换$P $:保持纯五度音阶不变,将三音切换.</p></li>
<li><p>关系变换$R
$:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p></li>
<li><p>导音变换$L $:保持小三度音阶不变,补上剩下的一个.</p></li>
</ol>
<p>容易见到$R ( L R ) ^3 = P $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" class="post-title-link" itemprop="url">程序设计实习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2>
<h3><span id="基本分析">基本分析</span></h3>
<h4><span id="union-bound">Union Bound</span></h4>
<p>即:$Pr [ _i X _i ] Pr [ X _i ] <span class="math inline">\(,取等当且仅当所有\)</span>X _i $互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4>
<p>若$X <span class="math inline">\(,则\)</span>Pr [ X t [ X ] ] { t }
$.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6>
<p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有$ { 2 } <span class="math inline">\(的概率是割边,因此期望自然是\)</span> { 2 } | E | {
2 } | | $.</p>
<p>由此立即见到,$Pr [ | ans | ( { 2 } - ) | E | ] = Pr [ | E | - | ans |
( { 2 } + ) | E | ] { 1 + 2 } $.</p>
<p>由于每次独立操作,因此如果有$P <span class="math inline">\(的概率失败,那么运行\)</span>T
$次后至少成功一次的概率应当为$1 - P ^T <span class="math inline">\(.从而\)</span>T = O ( _P { } ) = O ( { ( 1 + { 2 }
) } ) O ( { } ) <span class="math inline">\(即可拿到\)</span>$失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>设$X _1 , , X _n <span class="math inline">\(是独立,同期望(期望为\)</span>t <span class="math inline">\()的随机变量,令\)</span>X = { n } <span class="math inline">\(,对于任何失败概率\)</span>( 0 , 1 ) $,应当有:</p>
<p><span class="math display">\[
Pr \left [ | X - \mu | \geq \sqrt { \cfrac { \log ( 1 / \delta )  } {
nt  }  } \mu \right ] \leq \delta
\]</span></p>
<h6><span id="examplemedian-trick">Example(Median Trick)</span></h6>
<p>现在有一个黑盒能够以$p &gt; { 2 } <span class="math inline">\(的概率正确回答Yes或者No,问重复\)</span>T
$选多少次能拿到$1 - $的成功概率.</p>
<p>考虑重复$T <span class="math inline">\(次后应当有期望\)</span>pT
$个正确答案,因此直接取中位数.称此算法为Median Trick.</p>
<p>Chernoff Bound 告诉我们$T = O ( { } ) $足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4>
<p>设独立随机变量$x _1 , , x _m <span class="math inline">\(,令\)</span>X = _i x _i $,则:</p>
<p><span class="math display">\[
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac { 2 z ^2  } { m (
t - s ) ^2  } \right )
\]</span></p>
<h3><span id="编程中的随机性">编程中的随机性</span></h3>
<p>一般采用伪随机,也即是给定初值$X <em>0 <span class="math inline">\(,通过某个确定性的函数来生成\)</span>X </em>{ n + 1
} = f ( X _n ) $这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) ) <span class="math inline">\(的算法,我们运行其\)</span>k $次,则正确率为$1 - ( 1
- p ) ^k <span class="math inline">\(,时间复杂度为\)</span>O ( kf ( n )
) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) <span class="math inline">\(,其中\)</span>f ( n ) <span class="math inline">\(为枚举部分的复杂度,\)</span>g ( n ) <span class="math inline">\(为单词枚举中计算所需的复杂度.大部分情况下应保证\)</span>g
( n ) $不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有$n $个互不重合的点,已知存在不超过$7 <span class="math inline">\(条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.\)</span>n
$.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O
( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$
{ 7 } <span class="math inline">\(个点.换句话说,我们随机一个点,这个点在这条直线上的概率是\)</span>
{ 7 } <span class="math inline">\(,因此随机两个点确定这条直线的概率为\)</span> { 49
} $.随机$1000 $次,错误概率为$1 - ( { 49 } ) ^{ 1000 } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为$n <span class="math inline">\(的序列,要求找出一个长度大于等于\)</span> { 2 }
<span class="math inline">\(的子序列,使这个子序列中所有数的\)</span><span class="math inline">\(最大,求最大的\)</span><span class="math inline">\(.\)</span>n ^6 <span class="math inline">\(,\)</span>a _i ^{ 12 } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$ { 2 } <span class="math inline">\(.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度\)</span>O
( n ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$ <span class="math inline">\(个质因子全都存下来,然后将\)</span>n <span class="math inline">\(个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个\)</span>$,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为$n <span class="math inline">\(的序列\)</span>a <span class="math inline">\(,有\)</span>m <span class="math inline">\(次询问,每次给定一个区间\)</span>[ l , r ] <span class="math inline">\(,问\)</span>a [ l , r ] <span class="math inline">\(中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.\)</span>(
n , m , 1 a _i n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A <span class="math inline">\(并判断它与其它向量的内积,这样复杂度为\)</span>O (
n ^2 d ) $.</p>
冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A =
<span class="math display">\[\begin{bmatrix}\vec { a _1  } , \vec { a
_2  } , . . . , \vec { a _n  } \end{bmatrix}\]</span>
<p><span class="math inline">\(,那我们要验证的无非是\)</span>B = AA ^T
<span class="math inline">\(中是否存在一个不在主对角线上的元素\)</span>B
_{ i , j } <span class="math inline">\(在\)</span> $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C <span class="math inline">\(,其中\)</span>C <span class="math inline">\(的主对角线元素与\)</span>B $相同,而其他元素全是$1
<span class="math inline">\(.接下来我们要做的无非是找到\)</span>B <span class="math inline">\(和\)</span>C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C <span class="math inline">\(,那么对于任意一个\)</span>X _{ m n } <span class="math inline">\(都应该满足\)</span>XB = XC <span class="math inline">\(,取\)</span>m = 1 <span class="math inline">\(,我们的问题就转化为:是否能找到一个\)</span>X <span class="math inline">\(,使得\)</span>XB XC <span class="math inline">\(?这显然可以随机化.计算前者的复杂度为\)</span>O (
nd ) <span class="math inline">\(,后者由于\)</span>C <span class="math inline">\(很特殊,可以在\)</span>O ( n )
$的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令$D = B - C <span class="math inline">\(,若返回相等但实际上不相等,则\)</span>D
$中至少存在一个不为$0 <span class="math inline">\(的数字,假设\)</span>D
<em>{ i , j } <span class="math inline">\(.我们令\)</span>E = X D <span class="math inline">\(,那么只有当\)</span>E <span class="math inline">\(是零向量时才会错误.而\)</span>E <em>j = </em>{ k }
X <em>k D </em>{ k , j } <span class="math inline">\(,不难解得:\)</span>E <em>i = - { D </em>{ i , j }
} </em>{ k i } X <em>k D </em>{ k , j } <span class="math inline">\(,也就是说如果\)</span>X <span class="math inline">\(的其它位置都确定了,那么\)</span>E <span class="math inline">\(只有一种取值会返回错误.由于\)</span>k <span class="math inline">\(一共就俩取值,所以正确率至少\)</span> { 2 } $.</p>
<p>至于找到答案:我们找到一个不为$0 <span class="math inline">\(的\)</span>E _i <span class="math inline">\(,那么一定存在一组解包含了第\)</span>i <span class="math inline">\(个向量,只需枚举另一个向量检验就行,复杂度\)</span>O
( nd ) $.</p>
<p>$k = 3 <span class="math inline">\(的话,我们注意到\)</span>
$意义下,$1 $和$2 $的平方都是$1 <span class="math inline">\(.考虑\)</span><em>{ j } B </em>{ i , j } ^2 X
<em>j = </em>{ j } B _{ i , j } X <em>j B </em>{ h , i } ^T
$,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) <span class="math inline">\(表示对长度为\)</span>n
$的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要$+ 1 <span class="math inline">\(或者\)</span>- 1
$或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n
- 1  } ( T _i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{
\frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } {
n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i
- 1 ) )
\end{aligned}
\]</span></p>
<p>由于$T ( n ) n <span class="math inline">\(,所以对于\)</span> { 2 } i
j <span class="math inline">\(,我们显然有:\)</span>T ( i ) + T ( n - i )
T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } {
2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  }
{ 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
&amp; \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明$c <span class="math inline">\(,\)</span>T ( n ) cn n
$,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log
( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } {
4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  }
\log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } {
4  } + \frac { n  } { 2  } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } {
3  } ) - \frac { c  } { 4  } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) )
$的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk &amp; = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } &amp; =
p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k &amp; = \frac { 1  } { p  }
\end{aligned}
\]</span></p>
<p>则期望复杂度为$O ( { p } ) $.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 <span class="math inline">\(和第二个位置\)</span>x _2 <span class="math inline">\(,显然只要问到\)</span>[ x _1 , x _2 )
$是正确的.</p>
<p>考虑因为是随机,所以$x _1 x _2 <span class="math inline">\(的概率应当是不低的(事实上约为\)</span> { 2 } <span class="math inline">\(),而此时的\)</span>[ x _1 , x _2 )
$中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . .
$.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E _{ t + 1  } &gt; E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } &amp; E _{ t + 1  } \leq
E _t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度$T _0 <span class="math inline">\(,降温速度\)</span>k ( 0 , 1 ) <span class="math inline">\(,以及终止温度\)</span>T _k <span class="math inline">\(,每次操作后让\)</span>T = kT
$,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间$$:在一个给定问题中可能发生的所有情况.</p>
<p>事件:$$的一个子集.</p>
<p>基本事件$<span class="math inline">\(:\)</span>$中的单个元素,也可以看作集合大小为$1
$的事件.</p>
<p>概率:若$<span class="math inline">\(,我们称它发生的概率为\)</span>( )
<span class="math inline">\(,有\)</span>( ) <span class="math inline">\(且\)</span>_{ } ( ) = 1 $.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量$X <span class="math inline">\(和\)</span>Y
<span class="math inline">\(定义在同一个概率空间\)</span><span class="math inline">\(上,对于每一个在\)</span>X <span class="math inline">\(取值范围内的\)</span>x <span class="math inline">\(以及在\)</span>Y <span class="math inline">\(取值范围内的\)</span>y <span class="math inline">\(,我们称\)</span>( X = x Y = y )
$为它们的联合分布.</p>
<p>独立:如果对于每一个在$X <span class="math inline">\(取值范围内的\)</span>x <span class="math inline">\(以及在\)</span>Y <span class="math inline">\(取值范围内的\)</span>y <span class="math inline">\(,\)</span>( X = x Y = y ) = ( X = x ) ( Y = y )
<span class="math inline">\(,我们称\)</span>X <span class="math inline">\(和\)</span>Y $是独立的.</p>
<p>期望(均值)$E X <span class="math inline">\(:我们设概率空间上的随机变量\)</span>X <span class="math inline">\(的期望\)</span>EX = <em>{ x X ( ) } x ( X = x ) =
</em>{ w } X ( ) ( ) $.</p>
<p>中位数:我们设概率空间上的随机变量$X <span class="math inline">\(的中位数为满足\)</span>( X x ) . 5 ( X x ) . 5
<span class="math inline">\(的\)</span>x X ( ) $所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量$X <span class="math inline">\(的众数为满足\)</span>( X = x ) ( X = x ’ ) , x ’ X
( ) <span class="math inline">\(的\)</span>x X ( ) $所组成的集合.</p>
<p>方差$VX <span class="math inline">\(:我们设概率空间上的随机变量\)</span>X <span class="math inline">\(的方差\)</span>VX = E ( ( X - EX ) ^2 ) $.</p>
<p>标准差$<span class="math inline">\(:我们设概率空间上的随机变量\)</span>X <span class="math inline">\(的标准差\)</span>= $.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果$X , Y $是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><p>$E ( X + Y ) = EX + EY $.</p></li>
<li><p>$E ( X ) = EX $.</p></li>
<li><p>如果$X <span class="math inline">\(和\)</span>Y <span class="math inline">\(互相独立,那么\)</span>E ( XY ) = ( EX ) ( EY )
$.</p></li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X - EX ) ^2 ) &amp; = E ( X ^2 - 2 X ( EX ) + ( EX ) ^2 ) \\
&amp; = E ( X ^2 ) - 2 ( EX ) ( EX ) + ( EX ) ^2 \\
&amp; = E ( X ^2 ) - ( EX ) ^2
\end{aligned}
\]</span></p>
<p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当$X <span class="math inline">\(和\)</span>Y
$为独立的随机变量时,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( ( X + Y ) ^2 ) - ( EX + EY ) ^2 \\
&amp; = E ( ( X + Y ) ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2
\end{aligned}
\]</span></p>
<p>而又有:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X + Y ) ^2 ) &amp; = E ( X ^2 + 2 XY + Y ^2 ) \\
&amp; = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 )
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) - ( EX )
^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 \\
&amp; = VX + VY
\end{aligned}
\]</span></p>
<p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<p><span class="math display">\[
\Pr ( ( X - EX ) ^2 \geq \alpha ) \leq \cfrac { VX  } { \alpha  } ,
\alpha &gt; 0
\]</span></p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
VX &amp; = \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr (
\omega ) \\
&amp; \geq \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr (
\omega ) [ ( X ( \omega ) - EX ) ^2 &amp; \geq \alpha ] \\
&amp; \geq \sum _{ \omega \in \Omega  } \alpha \Pr ( \omega ) [ ( X (
\omega ) - EX ) ^2 &amp; \geq \alpha ] \\
&amp; = \alpha \Pr ( ( X - EX ) ^2 &amp; \geq \alpha )
\end{aligned}
\]</span></p>
<p>如果我们用$c ^2 VX <span class="math inline">\(代替\)</span>$,我们就有:</p>
<p>$( | X - EX | c ) { c ^2 } $.</p>
<p>简单来说,这个不等式说明:$X <span class="math inline">\(落在\)</span>(
EX - c , EX + c ) <span class="math inline">\(之外的概率至多为\)</span>
{ c ^2 } $.</p>
<p>另外,如果我们取$n <span class="math inline">\(个独立的样本\)</span>X
_1 , X _2 , . . . , X <em>n <span class="math inline">\(,令\)</span>S =
</em>{ i = 1 } ^n X _i <span class="math inline">\(,那么它的均值是\)</span>nEX <span class="math inline">\(,标准差是\)</span> <span class="math inline">\(,也就是说,\)</span> { n } <span class="math inline">\(落在\)</span>( EX - { } , EX + { } ) <span class="math inline">\(之外的概率小于等于\)</span> { c ^2 } $.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了$n <span class="math inline">\(个值\)</span>X _1 ,
X _2 , . . . , X _n
$,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p>$EX = { n } $.</p>
<p>$VX = { n - 1 } - { n ( n - 1 ) } $.</p>
<p>这里的$VX <span class="math inline">\(似乎与定义不是那么相符.但是它拥有更好的性质:\)</span>E
( VX ) = VX $.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \hat VX ) &amp; = \cfrac { 1  } { n - 1  } E ( \sum _{ i = 1  } ^n X
_i ^2 - \cfrac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n X
_j X _k ) \\
&amp; = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X _i ^2 ) -
\cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n E ( X _i X
_j ) ) \\
&amp; = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X ^2 ) -
\cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( ( EX ) ^2
[ j \ne k ] + E ( X ^2 ) [ j &amp; = k ] ) ) \\
&amp; = \cfrac { 1  } { n - 1  } ( nE ( X ^2 ) - \cfrac { 1  } { n  } (
nE ( X ^2 ) + n ( n - 1 ) ( EX ) ^2 ) ) \\
&amp; = E ( X ^2 ) - ( EX ) ^2 \\
&amp; = VX
\end{aligned}
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为$P ( A | B ) = { P ( B ) } \ $.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有${ B _i } <span class="math inline">\(是样本空间的一个划分,即\)</span>i , j <span class="math inline">\(,有\)</span>B _i B <em>j = <span class="math inline">\(,并且有\)</span></em>{ i = 1 } ^n B _i = <span class="math inline">\(.则有\)</span>P ( B _i | A ) = { P ( A ) } = { P (
A ) P ( B <em>j ) } = { </em>{ j = 1 } ^n P ( A B <em>j ) } = { </em>{ j
= 1 } ^n P ( A | B _j ) P ( B _j ) } \ $.</p>
<p>简化形式:$P ( B | A ) = { P ( A ) } \ $.</p>
<p>另外,我们考虑设$O ( B ) = { P ( B ) } <span class="math inline">\(,称\)</span> { P ( B | E ) }
$为贝叶斯算子,则同理可得:</p>
<p><span class="math display">\[
O ( B | E ) = O ( B ) \cfrac { P ( B | E )  } { P ( \lnot B | E )  }
\]</span></p>
<p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果$X <span class="math inline">\(是定义在概率空间\)</span><span class="math inline">\(上的随机变量,那么它的概率生成函数为\)</span>G
<em>X ( z ) = </em>{ k } ( X = k ) z ^k = E ( z ^X ) $.</p>
<p>不难发现$G _X ( z ) <span class="math inline">\(需要满足的条件:所有系数都非负并且\)</span>G _X ( 1
) = 1 $.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = G _X &#39; ( 1 ) \\
E ( X ^2 ) &amp; = G &#39; &#39; _X ( 1 ) + G _X &#39; ( 1 ) \\
VX &amp; = G _X &#39; &#39; ( 1 ) + G _X &#39; ( 1 ) - ( G _X &#39; ( 1
) ) ^2
\end{aligned}
\]</span></p>
<p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G ) &amp; = G &#39; ( 1 ) \\
Var ( G ) &amp; = G &#39; &#39; ( 1 ) + G &#39; ( 1 ) - ( G &#39; ( 1 )
) ^2
\end{aligned}
\]</span></p>
<p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<p><span class="math display">\[
G ( 1 + t ) = \sum _{ i \geq 0  } \cfrac { G ^{ ( i )  } ( 1 )  } { i
!  } t ^i
\]</span></p>
<p>另外,我们不难发现:$G _{ X + Y } ( z ) = G _X ( z ) G _Y ( z ) $.</p>
<p>根据前面的推导,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G _{ X + Y  } ) &amp; = Mean ( G _X ) + Mean ( G _Y ) \\
Var ( G _{ X + Y  } ) &amp; = Var ( G _X ) + Var ( G _Y )
\end{aligned}
\]</span></p>
<p>换句话说,若$G _X ( 1 ) = 1 , G <em>Y ( 1 ) = 1 <span class="math inline">\(,那么这个式子与直接对\)</span>G </em>{ X + Y }
$使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G _X ) &amp; = Mean ( G _{ X + Y  } ) - Mean ( G _Y ) \\
Var ( G _X ) &amp; = Var ( G _{ X + Y  } ) - Var ( G _Y )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为$p <span class="math inline">\(,反面向上的概率为\)</span>q
$,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设$N <span class="math inline">\(为所有不包含THTTH的硬币序列的生成函数,\)</span>S
<span class="math inline">\(为所有只有结尾为THTTH的硬币序列的生成函数,令\)</span>H
= pz , T = qz $,$1 $为空集,我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N \times ( H + T ) &amp; = N + S \\
N \times THTTH &amp; = S + S \times TTH
\end{aligned}
\]</span></p>
<p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设$A <span class="math inline">\(是我们要找到的字符串,\)</span>m <span class="math inline">\(是它的长度,令\)</span>A ^{ ( k ) } <span class="math inline">\(表示\)</span>A <span class="math inline">\(字符串的前\)</span>k <span class="math inline">\(个字符所组成的字符串,\)</span>A _{ ( k ) } <span class="math inline">\(表示\)</span>A <span class="math inline">\(字符串的后\)</span>k <span class="math inline">\(个字符所组成的字符串.这样的形式与\)</span>k
$阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S \\
N \times A &amp; = S ( \sum _{ k = 0  } ^{ m - 1  } A ^{ ( k )  } [ A ^{
( m - k )  } &amp; = A _{ ( m - k )  } ] )
\end{aligned}
\]</span></p>
<p>如果我们设$ <span class="math inline">\(为将字符串\)</span>A <span class="math inline">\(中的H替换成\)</span> { p } z <span class="math inline">\(,T替换成\)</span> { q } z
$之后的值,那么显然有:</p>
<p><span class="math display">\[
\begin{aligned}
N \times A &amp; = A \times S \times ( \sum _{ k = 1  } ^{ m  } \tilde {
A  } _{ ( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ] ) \\
N &amp; = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  }
[ A ^{ ( k )  } &amp; = A _{ ( k )  } ] ) \\
\cfrac { S - 1  } { H + T - 1  } &amp; = S \times ( \sum _{ k = 1  } ^{
m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ] )
\\
S \times ( 1 + ( 1 - H - T ) \times ( \sum _{ k = 1  } ^{ m  } \tilde {
A  } _{ ( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ] ) ) &amp; = 1
\end{aligned}
\]</span></p>
<p>这显然是一个卷积的形式.</p>
<p>令$w = <em>{ k = 1 } ^{ m } </em>{ ( k ) } [ A ^{ ( k ) } = A _{ ( k
) } ] $.</p>
<p>令$H ( z ) = 1 <span class="math inline">\(,\)</span>F ( z ) = ( 1 +
( 1 - z ) w ) <span class="math inline">\(,\)</span>G ( z ) = S $.</p>
<p>那么我们显然可以直接求$G ( z ) $的期望和方差,事实上:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k
)  } &amp; = A _{ ( k )  } ] \\
VX &amp; = ( EX ) ^2 - \sum _{ k = 1  } ^m ( 2 k - 1 ) \tilde { A  } _{
( k )  } [ A ^{ ( k )  } &amp; = A _{ ( k )  } ]
\end{aligned}
\]</span></p>
<p>如果硬币是均匀的($p = q = { 2 } <span class="math inline">\()我们引入另一个符号:我们设\)</span>A : A = _{ k =
1 } ^m 2 ^{ k } [ A ^{ ( k ) } = A _{ ( k ) } ] <span class="math inline">\(.那么显然期望需要的抛硬币次数就是\)</span>( A : A
) $.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设$S _A <span class="math inline">\(为所有以HHT结尾的硬币序列的生成函数,设\)</span>S
_B <span class="math inline">\(为所有以HTT结尾的硬币序列的生成函数.\)</span>N
<span class="math inline">\(为其它的硬币序列的生成函数,令\)</span>H = T
= 0 . 5 z $.</p>
<p>我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S _A + S _B \\
N \times HHT &amp; = S _A \\
N \times HTT &amp; = S _A \times T + S _B
\end{aligned}
\]</span></p>
<p>解方程并带入$z = 1 <span class="math inline">\(,可以有得知以HHT结尾的概率为\)</span> { 3 } $.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为$A <span class="math inline">\(和\)</span>B $,那么可以求出:</p>
<p><span class="math display">\[
\cfrac { S _A  } { S _B  } = \cfrac { B : B - B : A  } { A : A - A :
B  }
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设$g <em>i <span class="math inline">\(表示进行了\)</span>i <span class="math inline">\(步还未结束的概率,\)</span>f </em>{ k , i } <span class="math inline">\(为进行了\)</span>i <span class="math inline">\(步恰好第\)</span>k <span class="math inline">\(个人胜利的概率,\)</span>F , G
$是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p>$1 + xG ( x ) = _k F _k ( x ) + G ( x ) $.</p></li>
<li><p>$( { 2 } x ) ^L G ( x ) = _{ j = 1 } ^n F <em>j ( x ) </em>{ i =
0 } ^{ L - 1 } ( { 2 } x ) ^i [ A _k ^{ ( L - i ) } = { A <em>j } </em>{
( L - i ) } ] $.</p></li>
</ol>
<p>第一个式子的用处在于带入$x = 1 <span class="math inline">\(,发现\)</span>_{ k } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{
L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  }
&amp; = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{
L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } &amp; = { A
_j  } _{ ( i )  } ]
\end{aligned}
\]</span></p>
<p>带入$x = 1 $,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [
A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]
\]</span></p>
<p>不难发现对于不同的$k <span class="math inline">\(,(2)的右边不同,而左边一定相同,这样就给出了\)</span>n
<span class="math inline">\(个等式,算上(1)一共有\)</span>n + 1 <span class="math inline">\(个等式,可以算出\)</span>G ( 1 ) , F _{ 1 n } ( 1 )
<span class="math inline">\(这\)</span>n + 1 $个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为$n + 1 <span class="math inline">\(的概率空间,其中\)</span>( _k ) = { k } p ^k q ^{ n
- k } \ $,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令$H ( z ) = q + pz <span class="math inline">\(,不难发现二项式分布的生成函数为\)</span>H ( z ) ^n
$.</p>
<p>不难发现,满足二项式分布的随机变量的均值是$np <span class="math inline">\(,方差是\)</span>npq $.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:$G ( z ) ^n = (
{ 1 - qz } ) ^n = _{ k } { k } p ^n q ^k z ^k $.</p>
<p>我们考虑如何求$G ( z ) <span class="math inline">\(的方差和均值,不妨设\)</span>F ( z ) = { p } = { p
} - { p } z <span class="math inline">\(,则\)</span>G ( z ) ^n = F ( z )
^{ - n } $.</p>
<p>不难发现$F ( z ) <span class="math inline">\(满足二项式分布.也就是说,以\)</span>( n , p , q )
<span class="math inline">\(为参数的负二项式分布也就是以\)</span>( - n ,
- { p } , { p } ) $为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为$1 <span class="math inline">\(的\)</span>n <span class="math inline">\(个点的树,问所有点对\)</span>( i , j ) ( 1 i , j n
) <span class="math inline">\(中,从\)</span>i <span class="math inline">\(走到\)</span>j $的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设$f _u <span class="math inline">\(表示\)</span>u <span class="math inline">\(随机走到它父亲的期望,\)</span>g _v <span class="math inline">\(表示\)</span>v <span class="math inline">\(的父亲(假设是\)</span>u <span class="math inline">\()走到\)</span>v $的期望.</p>
<p>对于$f _u $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f _u &amp; = \cfrac { \sum _{ u \rightarrow v  } ( f _v + f _u )  } {
\deg _u  } + 1 \\
f _u &amp; = \deg _u + \sum _{ u \rightarrow v  } f _v
\end{aligned}
\]</span></p>
<p>对于$g _v $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
g _v &amp; = \cfrac { g _u + g _v + \sum _{ u \rightarrow w , w \ne v  }
( g _v + f _w )  } { \deg _u  } + 1 \\
g _v &amp; = g _u + \sum _{ u \rightarrow w , w \ne v  } f _w + \deg _u
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵$n $个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从$1 <span class="math inline">\(号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案\)</span>+
1 $.当走到度数为$1 $的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设$f <em>u <span class="math inline">\(表示以\)</span>u <span class="math inline">\(为起点的路径的期望长度,不难注意到\)</span>f </em>{
leaf } = 1 <span class="math inline">\(且\)</span>f _u = 1 + { <em>u }
</em>{ u v v u } f _v <span class="math inline">\(.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得\)</span>f
_u = k <em>u f </em>{ fa } + b _u
$,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出$g
_v <span class="math inline">\(表示从\)</span>v <span class="math inline">\(的父亲(假设是\)</span>u <span class="math inline">\()走到\)</span>v <span class="math inline">\(的概率,再令\)</span>f _u <span class="math inline">\(表示从\)</span>u
$走到父亲的概率,类似Example1,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f _u &amp; = \cfrac { 1  } { \deg _u  } ( 1 + \sum _{ u \rightarrow v  }
f _v f _u ) \\
g _v &amp; = \cfrac { 1  } { \deg _u  } ( 1 + g _v g _u + \sum _{ u
\rightarrow w , w \ne v  } f _w g _v )
\end{aligned}
\]</span></p>
<p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为$
{ { 2 } } $.</p>
<p>把所有人权值从大到小排序,设$f <em>i <span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(个人的时候的期望,不难发现:\)</span>f </em>{ i } =
{ { 2 } } v <em>i + ( 1 - { { 2 } } ) f </em>{ i - 1 } $.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设$f <em>{ i , j } <span class="math inline">\(表示过了\)</span>i <span class="math inline">\(关,花费为\)</span>j <span class="math inline">\(的期望,不难发现所有的\)</span>f <span class="math inline">\(都需要与\)</span>f </em>{ 0 , 0 } <span class="math inline">\(取\)</span>$,这咋办?</p>
<p>我们考虑二分这个$f <em>{ 0 , 0 } <span class="math inline">\(,做的时候直接取\)</span><span class="math inline">\(,这样最后还会求出一个\)</span>f </em>{ 0 , 0 }
$,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的$f _{ 0 , 0 } <span class="math inline">\(越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取\)</span>$的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张$n m <span class="math inline">\(的图(假设\)</span>n m
<span class="math inline">\(),其中格点\)</span>( a , b ) <span class="math inline">\(表示现在还剩\)</span>a <span class="math inline">\(个Yes,\)</span>b <span class="math inline">\(个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从\)</span>(
n , m ) <span class="math inline">\(走到\)</span>( 0 , 0 )
$的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线$y
= x $翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从$( n , m ) <span class="math inline">\(走到\)</span>( 0
, 0 ) <span class="math inline">\(一定会经过\)</span>n <span class="math inline">\(条有向边,所以期望贡献一定要加上一个\)</span>n
<span class="math inline">\(.而如果我走到了直线\)</span>y = x <span class="math inline">\(上,那接下来的贡献是\)</span> { 2 }
$.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2>
<h3><span id="树">树</span></h3>
<ol type="1">
<li><p>随机树树高为$ $.</p></li>
<li><p>点的度数期望为$n $.</p></li>
</ol>
<h3><span id="数">数</span></h3>
<ol type="1">
<li>数字的期望因数个数为$V $.</li>
</ol>
<h3><span id="序列">序列</span></h3>
<ol type="1">
<li>随机序列的LIS长度期望为$O ( ) $.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) ) <span class="math inline">\(的算法,我们运行其\)</span>k $次,则正确率为$1 - ( 1
- p ) ^k <span class="math inline">\(,时间复杂度为\)</span>O ( kf ( n )
) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) <span class="math inline">\(,其中\)</span>f ( n ) <span class="math inline">\(为枚举部分的复杂度,\)</span>g ( n ) <span class="math inline">\(为单词枚举中计算所需的复杂度.大部分情况下应保证\)</span>g
( n ) $不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有$n $个互不重合的点,已知存在不超过$7 <span class="math inline">\(条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.\)</span>n
$.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O
( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$
{ 7 } <span class="math inline">\(个点.换句话说,我们随机一个点,这个点在这条直线上的概率是\)</span>
{ 7 } <span class="math inline">\(,因此随机两个点确定这条直线的概率为\)</span> { 49
} $.随机$1000 $次,错误概率为$1 - ( { 49 } ) ^{ 1000 } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为$n <span class="math inline">\(的序列,要求找出一个长度大于等于\)</span> { 2 }
<span class="math inline">\(的子序列,使这个子序列中所有数的\)</span><span class="math inline">\(最大,求最大的\)</span><span class="math inline">\(.\)</span>n ^6 <span class="math inline">\(,\)</span>a _i ^{ 12 } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$ { 2 } <span class="math inline">\(.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度\)</span>O
( n ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$ <span class="math inline">\(个质因子全都存下来,然后将\)</span>n <span class="math inline">\(个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个\)</span>$,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为$n <span class="math inline">\(的序列\)</span>a <span class="math inline">\(,有\)</span>m <span class="math inline">\(次询问,每次给定一个区间\)</span>[ l , r ] <span class="math inline">\(,问\)</span>a [ l , r ] <span class="math inline">\(中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.\)</span>(
n , m , 1 a _i n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A <span class="math inline">\(并判断它与其它向量的内积,这样复杂度为\)</span>O (
n ^2 d ) $.</p>
冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A =
<span class="math display">\[\begin{bmatrix}\vec { a _1  } , \vec { a
_2  } , . . . , \vec { a _n  } \end{bmatrix}\]</span>
<p><span class="math inline">\(,那我们要验证的无非是\)</span>B = AA ^T
<span class="math inline">\(中是否存在一个不在主对角线上的元素\)</span>B
_{ i , j } <span class="math inline">\(在\)</span> $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C <span class="math inline">\(,其中\)</span>C <span class="math inline">\(的主对角线元素与\)</span>B $相同,而其他元素全是$1
<span class="math inline">\(.接下来我们要做的无非是找到\)</span>B <span class="math inline">\(和\)</span>C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C <span class="math inline">\(,那么对于任意一个\)</span>X _{ m n } <span class="math inline">\(都应该满足\)</span>XB = XC <span class="math inline">\(,取\)</span>m = 1 <span class="math inline">\(,我们的问题就转化为:是否能找到一个\)</span>X <span class="math inline">\(,使得\)</span>XB XC <span class="math inline">\(?这显然可以随机化.计算前者的复杂度为\)</span>O (
nd ) <span class="math inline">\(,后者由于\)</span>C <span class="math inline">\(很特殊,可以在\)</span>O ( n )
$的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令$D = B - C <span class="math inline">\(,若返回相等但实际上不相等,则\)</span>D
$中至少存在一个不为$0 <span class="math inline">\(的数字,假设\)</span>D
<em>{ i , j } <span class="math inline">\(.我们令\)</span>E = X D <span class="math inline">\(,那么只有当\)</span>E <span class="math inline">\(是零向量时才会错误.而\)</span>E <em>j = </em>{ k }
X <em>k D </em>{ k , j } <span class="math inline">\(,不难解得:\)</span>E <em>i = - { D </em>{ i , j }
} </em>{ k i } X <em>k D </em>{ k , j } <span class="math inline">\(,也就是说如果\)</span>X <span class="math inline">\(的其它位置都确定了,那么\)</span>E <span class="math inline">\(只有一种取值会返回错误.由于\)</span>k <span class="math inline">\(一共就俩取值,所以正确率至少\)</span> { 2 } $.</p>
<p>至于找到答案:我们找到一个不为$0 <span class="math inline">\(的\)</span>E _i <span class="math inline">\(,那么一定存在一组解包含了第\)</span>i <span class="math inline">\(个向量,只需枚举另一个向量检验就行,复杂度\)</span>O
( nd ) $.</p>
<p>$k = 3 <span class="math inline">\(的话,我们注意到\)</span>
$意义下,$1 $和$2 $的平方都是$1 <span class="math inline">\(.考虑\)</span><em>{ j } B </em>{ i , j } ^2 X
<em>j = </em>{ j } B _{ i , j } X <em>j B </em>{ h , i } ^T
$,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) <span class="math inline">\(表示对长度为\)</span>n
$的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要$+ 1 <span class="math inline">\(或者\)</span>- 1
$或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T
_i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n
- 1  } ( T _i + T _{ n - i - 1  } ) \\
&amp; = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{
\frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } {
n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i
- 1 ) )
\end{aligned}
\]</span></p>
<p>由于$T ( n ) n <span class="math inline">\(,所以对于\)</span> { 2 } i
j <span class="math inline">\(,我们显然有:\)</span>T ( i ) + T ( n - i )
T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } {
2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  }
{ 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
&amp; \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T (
\frac { n  } { 4  } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明$c <span class="math inline">\(,\)</span>T ( n ) cn n
$,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log
( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } {
4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  }
\log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } {
4  } + \frac { n  } { 2  } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } {
3  } ) - \frac { c  } { 4  } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p <span class="math inline">\(,时间复杂度为\)</span>O ( f ( n ) )
$的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k &amp; = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk &amp; = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } &amp; =
p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k &amp; = \frac { 1  } { p  }
\end{aligned}
\]</span></p>
<p>则期望复杂度为$O ( { p } ) $.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 <span class="math inline">\(和第二个位置\)</span>x _2 <span class="math inline">\(,显然只要问到\)</span>[ x _1 , x _2 )
$是正确的.</p>
<p>考虑因为是随机,所以$x _1 x _2 <span class="math inline">\(的概率应当是不低的(事实上约为\)</span> { 2 } <span class="math inline">\(),而此时的\)</span>[ x _1 , x _2 )
$中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . .
$.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E _{ t + 1  } &gt; E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } &amp; E _{ t + 1  } \leq
E _t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度$T _0 <span class="math inline">\(,降温速度\)</span>k ( 0 , 1 ) <span class="math inline">\(,以及终止温度\)</span>T _k <span class="math inline">\(,每次操作后让\)</span>T = kT
$,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/4/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
