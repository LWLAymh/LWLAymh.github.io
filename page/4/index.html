<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/4/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">文化课数学导论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A2%AB%E6%96%87%E5%8C%96%E8%AF%BE%E5%88%9B%E9%A3%9E%E4%BA%86/" itemprop="url" rel="index"><span itemprop="name">被文化课创飞了</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2><h3><span id="习惯的更改">习惯的更改</span></h3><p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将$C _{ n  } ^k $写作$\binom { n  } { k  } $,而文化课中不允许此类更改,再者文化课中将$C _{ n  } ^k a ^{ n - k  } b ^k $称作二项式的第$k + 1 $项(从第$1 $项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3><p>首先我们有$E ( aX + b ) = aE ( X ) + b , D ( aX + b ) = a ^2 D ( X ) $.</p>
<p>我们都知道期望满足线性可加,也就是$E ( X _1 + X _2 ) = E ( X _1 ) + E ( X _2 ) $,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若$X _1 $和$X _2 $相互独立,$E ( X _1 X _2 ) = E ( X _1 ) E ( X _2 ) $,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要$X _1 $和$X _2 $相互独立,$D ( X _1 + X _2 ) = D ( X _1 ) + D ( X _2 ) $.从形式上证明是好证明的,我们考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
D ( X _1 + X _2 ) & = E ( ( X _1 + X _2 ) ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + E ( 2 X _1 X _2 ) + E ( X _2 ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + 2 E ( X _1 ) E ( X _2 ) + E ( X _2 ^2 ) - ( E ( X _1 ) + E ( X _2 ) ) ^2 \\
& = E ( X _1 ^2 ) - E ^2 ( X _1 ) + E ( X _2 ^2 ) - E ^2 ( X _2 ) \\
& = D ( X _1 ) + D ( X _2 ) 
\end{aligned}</script><p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为$0 $,不然$D ( X _1 + X _2 ) $要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为$0 $,并且缩放权值,使得方差恰好为$1 $.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为$0 $的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3><h4><span id="两点分布">两点分布</span></h4><p>直接写的话也就是$P ( X ) = \begin{cases}p &amp; X = 1 \ 1 - p &amp; X = 0 \ 0 &amp; other \end{cases} $,事实上这么写可能不太严谨,因为两点分布的$X = 1 $和$X = 0 $两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是$G ( x ) = ( 1 - p ) + px $.由此式子轻松推得$E ( x ) = G ‘ ( 1 ) = p , D ( x ) = E ( x ^2 ) - E ^2 ( x ) = G ‘ ‘ ( 1 ) + G ‘ ( 1 ) - ( G ‘ ( 1 ) ) ^2 = p - p ^2 = p ( 1 - p ) $.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4><p>所谓$n $重伯努利试验,也就是$n $次两点分布的累计,满足$P ( X = k ) = C _{ n  } ^k ( 1 - p ) ^{ n - k  } p ^k $,我们关注两个事情,也就是二项式分布的$E ( X ) = np , D ( X ) = np ( 1 - p ) $,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4><p>所谓不放回取球,考虑目前有$N $个数字,有$M $个是$1 $,剩下$N - M $个是$0 $,取出$n $次,取出了$m $个$1 $的概率.简单组合一下得到此概率为$\frac { C _{ M  } ^m C _{ N - M  } ^{ n - m  }  } { C _{ N  } ^n  } \ $,注意这里必须保证$n \leq N $.</p>
<p>由范德蒙德卷积得知,$\sum _{ m  } C _{ M  } ^m C _{ N - M  } ^{ n - m  } = C _{ N  } ^n $,因此该分布列所有情况之和为$1 $.</p>
<p>考虑其均值,从感性上讲必定是$\frac { nM  } { N  } $.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如$01101 $之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到$1 $的概率,和第二次取得到$1 $的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是$n \frac { N ( N - M ) ( N - n )  } { N ^2 ( N - 1 )  } $,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4><p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写$f ( x ) = \frac { e ^{ - \frac { ( x - \mu ) ^2  } { 2 \sigma ^2  }  }  } { \sigma \sqrt { 2 \pi  }  } \ $,是不是看着非常震撼!其中的方差是$\sigma ^2 $,期望是$\mu $.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足$\sigma = 1 , \mu = 0 $,此时的函数也就是$f ( x ) = \frac { e ^{ - \frac { x ^2  } { 2  }  }  } { \sqrt { 2 \pi  }  } $.一个好奇是,你凭啥说所有情况下的概率之和为$1 $,事实上这其实是因为$g ( x ) = e ^{ - x ^2  } $的积分是$\sqrt { \pi  } $,不会求这个积分.</p>
<p>观察$g ( x ) = e ^{ - x ^2  } $这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数$e ^{ - | x |  } $模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是$\sigma $的由来,将$x \rightarrow \sigma x $,也就是在$x $那里除去一个$\sigma $.而对这个曲线进行横向移动,也就是将$x \rightarrow x - \mu $.</p>
<p>这也就引出所谓的$3 \sigma $原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3><h4><span id="样本相关系数">样本相关系数</span></h4><p>对于若干数据$( x _i , y _i ) $,我们先进行标准化,也就是减去均值后再除以方差,这样做使得$x , y $分别的均值为$0 $,方差为$1 $.下面默认已经标准化过了.</p>
<p>不妨构造$n $维向量$\vec { x  } = ( x _1 , x _2 , \cdots , x _n ) , \vec { y  } = ( y _1 , y _2 , \cdots , y _n ) $,考虑它们的点乘$\vec { x  } \cdot \vec { y  } $,不难发现由于方差为$1 $,因此$| \vec { x  } | = | \vec { y  } | = \sqrt { n  } $,因此它们的点乘为$n \cos \theta $,设$r = \frac { \vec { x  } \cdot \vec { y  }  } { n  } = \cos \theta $.</p>
<p>如果$\exists k $,$\forall i , y _i = kx _i $,此时必有$| r | = 1 $,因此我们断言(为啥呢?其实是不太理解的啊)当$| r | $越靠近$1 $的时候,$x , y $之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4><p>我们在上面的角度审视中提出了一个观点:在满足均值为$0 $的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:$Y = bx + a + e , E ( e ) = 0 , D ( e ) = \sigma ^2 $.</p>
<p>现在我们要做的就是,已知若干组数据$( x _i , y _i ) $,去构造一组$a , b $满足上面的条件.不妨令$e _i = y _i - ( bx _i + a ) $,若$\sum e _i = 0 $,必有$a = \bar { y  } - b \bar { x  } $,带入解得当$\sigma $最小的时候,$b = \frac { \sum _{ i  } ( x _i - \bar { x  } ) ( y _i - \bar { y  } )  } { \sum _{ i  } ( x _i - \bar { x  } ) ^2  } \ $.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个$b $使得$\sigma $最小,标准化说到底只是为了保证$\sigma = 1 $的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4><p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知$P ( AB ) = P ( A ) P ( B ) $,那么我们反推,如果我们在现实中的估计中,发现$P ( AB ) $和$P ( A ) P ( B ) $差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:$P ( 00 ) = \frac { a  } { n  } , P ( 01 ) = \frac { b  } { n  } , P ( 10 ) = \frac { c  } { n  } , P ( 11 ) = \frac { d  } { n  } $.那么$P ( A = 0 ) P ( B = 0 ) = \frac { ( a + b ) ( a + c )  } { n ^2  } $.我们计算它与$P ( 00 ) $的差,平方后除以$P ( A = 0 ) P ( B = 0 ) $然后做四遍求和化简,得到$\chi ^2 = \frac { n ( ad - bc ) ^2  } { ( a + b ) ( a + c ) ( c + d ) ( b + d )  } $.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么$P ( \chi ^2 \geq x _\alpha ) = \alpha $.或者给出我们经验上的准则:</p>
<p>选取一个较小的$\alpha $,并得知其对应的$x _\alpha $,如果$\chi ^2 \geq x _\alpha $,推断独立性不成立,犯错的概率是$\alpha $.反之断言其独立性成立,犯错的概率不可知,肯定$\alpha $越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2><h3><span id="常用对数表">常用对数表</span></h3><ol>
<li><p>$\ln 2 = 0 . 693 $.</p>
</li>
<li><p>$\ln 3 = 1 . 099 $.</p>
</li>
<li><p>$\ln 5 = 1 . 609 $.</p>
</li>
<li><p>$\ln 0 . 1 = - 2 . 303 $.</p>
</li>
<li><p>$\ln 0 . 5 = - 0 . 693 $.</p>
</li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3><ol>
<li><p>$e = 2 . 718 $.</p>
</li>
<li><p>$e ^2 = 7 . 389 $.</p>
</li>
<li><p>$e ^3 = 20 . 086 $.</p>
</li>
<li><p>$e ^5 = 148 . 413 $.</p>
</li>
<li><p>$e ^{ 0 . 1  } = 1 . 105 $.</p>
</li>
<li><p>$e ^{ 0 . 5  } = 1 . 649 $.</p>
</li>
<li><p>$e ^\pi = 23 . 147 $.</p>
</li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3><h4><span id="fxxex">$f(x)=xe^x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = ( x + 1 ) e ^x $,$x = - 1 $的时候,取最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxxln-x">$f(x)=x\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 + \ln x , x = \frac { 1  } { e  } $的时候,有最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow 0 ^{ +  }  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracexx">$f(x)=\frac{e^x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e^xdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { e ^x ( x - 1 )  } { x ^2  } , x = 1 $的时候,有极小值$e $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracln-xx">$f(x)=\frac{\ln x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - \ln x  } { x ^2  } , x = e $的时候,有极大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxx-ln-x">$f(x)=x-\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 - \frac { 1  } { x  } , x = 1 $的时候,有最小值$1 $.</p>
<hr>
<h4><span id="fxfracxex">$f(x)=\frac{x}{e^x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - x  } { e ^x  } , x = 1 $的时候,有最大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<h3><span id="预处理函数">预处理函数</span></h3><h4><span id="分离对数">分离对数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = ( 2 + x + ax ^2 ) \ln ( x + 1 ) - 2 x $,已知$x = 0 $是极大值点,求$a $.</p>
<p>考虑分离对数后操作多项式,我们显然可找到$0 &lt; t &lt; 1 , 2 + t + at ^2 &gt; 0 , 2 - t + at ^2 &gt; 0 $,下面只考虑$x \in [ - t , t ] $.此时$f ( x ) = ( 2 + x + ax ^2 ) ( \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } ) $.</p>
<p>考虑令$g ( x ) = \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } $,由于$f ( 0 ) = 0 $,只需证明$g ( x ) \leq 0 , x \in [ - t , t ] $即可.</p>
<p>而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ' ( x ) & = \frac { 1  } { x + 1  } - \frac { 4 - 2 ax ^2  } { ( 2 + x + ax ^2 ) ^2  } \\
& = \frac { x ^2 ( a ^2 x ^2 + 4 ax + 6 a + 1 )  } { ( x + 1 ) ( 2 + x + ax ^2 )  } \\
\text { sign  } ( g ' ( x ) ) & = \text { sign  } ( a ^2 x ^2 + 4 ax + 6 a + 1 ) 
\end{aligned}</script><p>则$a ^2 0 ^2 + 4 a 0 + 6 a + 1 = 0 $,$a = - \frac { 1  } { 6  } $.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = e ^x - \ln ( x + 1 ) + ax ^3 - x ^2 - 1 $,若$\forall x \in ( - 1 , 1 ) , f ( x ) \geq 0 $,求$a $.</p>
<p>$f ( 0 ) = 0 $,于是上面的条件等价于$0 $是$( - 1 , 1 ) $的最小值点.</p>
<p>考虑$f ‘ ( x ) = e ^x - \frac { 1  } { x + 1  } + 3 ax ^2 - 2 x $,则$f ‘ ( 0 ) = 0 $恒成立.</p>
<p>讨论$g ( x ) = 1 + e ^{ - x  } ( 3 ax ^2 - 2 x - \frac { 1  } { x + 1  } ) $的正负,看$g ‘ ( x ) = \frac { x ( - 3 ax ^3 + 2 x ^2 + ( 9 a + 2 ) x + 6 a - 1 )  } { ( x + 1 ) ^2 e ^x  } $.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3><h4><span id="变化条件">变化条件</span></h4><h5><span id="example">Example</span></h5><p>已知$x + 2 y = 1 $,求$x ^2 + y ^2 $的最小值.</p>
<p>直接令$x = 1 - 2 y $,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^3 = 2 $,求$x + y $的最小值.</p>
<p>这个的话不妨设其最小值为$C $,有$x + y \geq C $,移项得到$y \geq C - x $,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3><h4><span id="普通参数方程">普通参数方程</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^2 - xy = 1 $,求$x + y $的最小值.</p>
<p>这个的话大概是这样,我们找到一个$t $,使得$x = f ( t ) , y = g ( t ) $,然后换元.</p>
<p>比如这个题,你就可以凑成$( x - \frac { y  } { 2  } ) ^2 + ( \frac { \sqrt { 3  }  } { 2  } y ) ^2 = 1 $,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4><h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5><p>求证$\sqrt { ab  } &lt; \frac { a - b  } { \ln a - \ln b  } &lt; \frac { a + b  } { 2  } $.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { a - b  } { \ln a - \ln b  } & < \frac { a + b  } { 2  } \\
\frac { a - b  } { a + b  } & < \frac { \ln \frac { a  } { b  }  } { 2  } \\
\frac { \frac { a  } { b  } - 1  } { \frac { a  } { b  } + 1  } & < \frac { \ln \frac { a  } { b  }  } { 2  } 
\end{aligned}</script><p>换元,令$t = \frac { a  } { b  } $,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5><p>已知函数$f ( x ) = 3 \ln x - ax $,若$x _1 &lt; x _2 $是$f ( x ) $的两个零点,求证$f ‘ ( \frac { x _1 + 3 x _2  } { 4  } ) &lt; 0 $.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
3 \ln x _1 = ax _1 \\
3 \ln x _2 = ax _2 
\end{cases}</script><p>我们想要知道的是:$\frac { 12  } { x _1 + 3 x _2  } &lt; a $.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把$a $给换掉,事实上我们根据前面的方程有$a = \frac { 3 \ln \frac { x _2  } { x _1  }  } { x _2 - x _1  } $.</p>
<p>于是我们只需要证明:$\frac { x _1 + 3 x _2  } { 4  } &gt; \frac { x _2 - x _1  } { \ln \frac { x _2  } { x _1  }  } $,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>同样分析已知,我们得到的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _1 = ax _1 \\
\ln x _2 = ax _2 
\end{cases}</script><p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _2 - \ln x _1 = a ( x _2 - x _1 ) \\
\ln x _2 + \ln x _1 = a ( x _2 + x _1 ) 
\end{cases}</script><p>这里先把所求变形一下,我们把它改成$\ln x _1 + \ln x _2 &gt; 2 $.</p>
<p>发现了什么?这个东西等价于$a ( x _2 + x _1 ) &gt; 2 $,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换$a $即可.</p>
<h5><span id="example4">Example4</span></h5><p>已知$f ( x ) = x ^2 + axe ^x - ae ^{ 2 x  } $有三个不同的零点$x _1 &lt; x _2 &lt; x _3 $,求$a $的范围,并求证$( 1 - \frac { x _1  } { e ^{ x _1  }  } ) ^2 ( 1 - \frac { x _2  } { e ^{ x _2  }  } ) ( 1 - \frac { x _3  } { e ^{ x _3  }  } ) = 1 $.</p>
<p>考虑两边同时除以$e ^{ 2 x  } $,这样得到$g ( x ) = ( \frac { x  } { e ^x  } ) ^2 + a \frac { x  } { e ^x  } - a $,令$t = \frac { x  } { e ^x  } $得到$g ( t ) = t ^2 + at - a = 0 $.</p>
<p>考察$g ( t ) = 0 $的两根$t _1 &lt; t _2 $,根据韦达定理,首先需要满足$\Delta = a ^2 + 4 a &gt; 0 \Rightarrow a &gt; 0 $,然后$t _1 + t _2 = - a , t _1 t _2 = - a $.</p>
<p>接下来考察函数$\frac { x  } { e ^x  } $,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为$t _1 , t _2 $中必有一负,因此$t _2 \in ( 0 , \frac { 1  } { e  } ) $.由此立得$0 &lt; a &lt; \frac { 1  } { e ( e - 1 )  } $.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4><h5><span id="example1">Example1</span></h5><p>若$x &gt; 0 $时,$ax ( e ^{ ax  } + 1 ) \geq 2 ( x ^2 + 1 ) \ln x $恒成立,求$a $取值范围.</p>
<p>一般这种题先判$a $的正负,注意到$x &gt; 1 $的时候右边恒大于$0 $,因此$a &gt; 0 $.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数$2 $放进$\ln $,自然有:$ax ( e ^{ ax  } + 1 ) \geq ( x ^2 + 1 ) \ln x ^2 $.</p>
<p>考虑令$t _1 = ax , t _2 = \ln x ^2 $,则:</p>
<script type="math/tex; mode=display">
t _1 ( e ^{ t _1  } + 1 ) \geq t _2 ( e ^{ t _2  } + 1 )</script><p>接下来分析函数$f ( x ) = x ( e ^x + 1 ) $的单调性,就可以得到$a \geq \frac { 2  } { e  } $.</p>
<h3><span id="不等式相关">不等式相关</span></h3><h4><span id="基本不等式相关">基本不等式相关</span></h4><h5><span id="方程角度的审视">方程角度的审视</span></h5><p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造$\frac { m  } { n  } = k $.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5><p>已知$n , m &gt; 0 , 2 m + n = nm $,求$n + m + \sqrt { n ^2 + m ^2  } $的最小值.</p>
<p>这个题有一个方式是观察到$n , m , \sqrt { n ^2 + m ^2  } $是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n + m + \sqrt { n ^2 + m ^2  } & \geq k \\
\Leftarrow \sqrt { n ^2 + m ^2  } & \geq k - n - m \\

\end{aligned}</script><p>如果$n + m \geq k $,那么不等式显然成立,下面只需要证明$n + m &lt; k $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt { n ^2 + m ^2  } & \geq k - n - m \\
\Leftarrow n ^2 + m ^2 & \geq ( k - ( n + m ) ) ^2 \\
\Leftarrow k ^2 + ( n + m ) ^2 - 2 k ( n + m ) & \leq n ^2 + m ^2 \\
\Leftarrow k ^2 + 2 nm - 2 k ( n + m ) & \leq 0 \\
\Leftarrow k ^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) & \leq 0 \\
\Leftarrow k ^2 & \leq n ( 2 k - 2 ) + m ( 2 k - 4 ) 
\end{aligned}</script><p>变形方程得到$\frac { 2  } { n  } + \frac { 1  } { m  } = 1 $,使用这个式子来降次:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) & = 6 k - 8 + \frac { n  } { m  } ( 2 k - 2 ) + \frac { m  } { n  } ( 4 k - 8 ) \\

\end{aligned}</script><p>要严谨一点的话我们需要证明$4 k - 8 \geq 0 $,$k \geq 2 $.这非常简单,因为$k \geq n + m &gt; 3 $.</p>
<p>这就足够了么?不需要证明存在一个$w = \frac { n  } { m  } $使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>这个等号可以取到,也就是说,只要满足:</p>
<script type="math/tex; mode=display">
k ^2 \leq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下界,特别地,如果满足:</p>
<script type="math/tex; mode=display">
k ^2 = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到$k = 10 $是一个解了),接下来我们必须求出一个$k $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 & = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
k ^2 - 6 k + 8 & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
\sqrt { k - 2  } & = \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } 
\end{aligned}</script><p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个$\sqrt { k - 2  } $带入到上面去!</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 )  } \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } \\
( k - 4 ) ( k - 2 ) & = \frac { 32 ( k - 1 )  } { k - 4  } \\

\end{aligned}</script><p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说$k = 0 $是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出$k = 10 $.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4><h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5><script type="math/tex; mode=display">
\begin{aligned}
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( x _0 )  } { k !  } ( x - x _0 ) ^k \\
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( 0 )  } { k !  } x ^k \\

\end{aligned}</script><h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5><ol>
<li><p>$\frac { 1  } { 1 - x  } = \sum _{ k \geq 0  } x ^k = 1 + x + x ^2 + \cdots \ $.</p>
</li>
<li><p>$e ^x = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } = 1 + x + \frac { 1  } { 2 !  } x ^2 + \cdots \ $.</p>
</li>
<li><p>$\ln ( 1 + x ) = \sum _{ k \geq 1  } ( - 1 ) ^{ k - 1  } \frac { x ^k  } { k  } = x - \frac { 1  } { 2  } x ^2 + \frac { 1  } { 3  } x ^3 + \cdots \ $.</p>
</li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4><h5><span id="example1">Example1</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>极值点偏移的形式,应该是形如$g ( x ) = a $有两个解$x _1 , x _2 $,然后使得$x _1 + x _2 $满足一定条件.因此我们先变形条件:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { \ln x _1  } { x _1  } = a \\
\frac { \ln x _2  } { x _2  } = a 
\end{cases}</script><p>也就是目前我们构造出了函数$g ( x ) = \frac { \ln x  } { x  } $,观察$g ( x ) $图像立得$x _1 + x _2 &gt; 2 e $.</p>
<p>我们发现,$x _1 x _2 \leq \frac { ( x _1 + x _2 ) ^2  } { 4  } $,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为$\ln x _1 + \ln x _2 &lt; 2 $,然后令$t _1 = \ln x _1 , t _2 = \ln x _2 $,带入立有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { t _1  } { e ^{ t _1  }  } = a \\
\frac { t _2  } { e ^{ t _2  }  } = a 
\end{cases}</script><p>而$g ( x ) = \frac { x  } { e ^x  } $恰好也是满足$x _1 + x _2 &gt; 2 $的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5><p>$f ( x ) = x ( 1 - \ln x ) $,$b \ln a - a \ln b = a - b $,求证$2 &lt; \frac { 1  } { a  } + \frac { 1  } { b  } &lt; e $.</p>
<p>首先变形条件得到$b ( 1 + \ln a ) = a ( 1 + \ln b ) $,得到$f ( \frac { 1  } { a  } ) = f ( \frac { 1  } { b  } ) $,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p>$f ‘ ( x ) = - \ln x $,其在$( 0 , 1 ) \uparrow , ( 1 , + \infty ) \downarrow $,考察极值点偏移,我们想要证明$\frac { 1  } { b  } &lt; e - \frac { 1  } { a  } $,我们就想办法把$\frac { 1  } { b  } $和$e - \frac { 1  } { a  } $扔到同一个区间里,而它们确实同在$( 1 , + \infty ) $这个区间内.</p>
<p>比较有启发性的是,你发现$\frac { 1  } { b  } , e - \frac { 1  } { a  } $和$\frac { 1  } { a  } , e - \frac { 1  } { b  } $这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { b  } & < e - \frac { 1  } { a  } \\
f ( \frac { 1  } { a  } ) & = f ( \frac { 1  } { b  } ) & > f ( e - \frac { 1  } { a  } ) 
\end{aligned}</script><p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5><p>$f ( x ) = e ^{ x - 1  } - ax $在$( 0 , 2 ) $有两个零点$x _1 , x _2 $,求证$x _1 x _2 &gt; \frac { 1  } { a  } $.</p>
<p>首先要证明$a $的范围啊,我们不加证明地给出:$a \in ( 1 , \frac { e  } { 2  } ) $,并且$( - \infty , 1 + \ln a ) \downarrow , ( 1 + \ln a , + \infty ) \uparrow $.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
ax _1 = e ^{ x _1 - 1  } \\
ax _2 = e ^{ x _2 - 1  } 
\end{cases}</script><p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取$\ln $,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取$\ln $,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到$x _1 x _2 $和$x _1 + x _2 $之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如$0 &lt; f ( 2 + \ln a - x _2 ) $,也就是$0 &lt; ae ^{ 1 - x _2  } - a ( 2 + \ln a - x _2 ) $.</p>
<p>但是这样有一个问题,我们把$f $带进去,你会发现最后我们的式子同时带有$a , x _2 $,这个就难做了,咋办呢?考虑拿$ax _2 = e ^{ x _2 - 1  } $操作一下把$a $消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4><h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5><ol>
<li><p>$e ^x \geq x + 1 $.</p>
</li>
<li><p>$\frac { x - 1  } { x  } \leq \ln x \leq x - 1 $.</p>
</li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol>
<li>$\ln ( n + 1 ) &lt; \sum _{ k = 1  } ^n \frac { 1  } { k  } $.</li>
</ol>
<p>考虑$\ln ( \frac { n + 1  } { n  } ) &lt; \frac { 1  } { n  } $,左右两边分别求和得到上面的式子.</p>
<ol>
<li>$\ln n &gt; \sum _{ k = 2  } ^n \frac { 1  } { k  } , n &gt; 1 $.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明$\ln \frac { 1  } { n  } &lt; - \sum _{ k = 2  } ^n \frac { 1  } { k  } $.</p>
<p>考虑$\ln ( \frac { n - 1  } { n  } ) \leq - \frac { 1  } { n  } $,两边求和得到上式.</p>
<ol>
<li>$\sum _{ k = 1  } ^n ( \frac { k  } { n  } ) ^n &lt; \frac { e  } { e - 1  } $.</li>
</ol>
<p>考虑$n \ln ( \frac { k  } { n  } ) \leq k - n $,也就有$( \frac { k  } { n  } ) ^n \leq e ^{ k - n  } $,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5><h6><span id="example1">Example1</span></h6><p>设$f ( x ) = x \ln x $,若$f ( x ) = b $有两个实数根$x _1 , x _2 ( x _1 &lt; x _2 ) $,求证:$be + 1 &lt; x _2 - x _1 &lt; \frac { e ^{ - 3  } + 2 + 3 b  } { 2  } $.</p>
<p>注意到$f ( x ) $下凸,考虑求出两条切线,那么这两条切线与$y = b $的交点之差要大于等于$x _2 - x _1 $,两条割线交点之差要小于等于$x _2 - x _1 $.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是$b \rightarrow - \frac { 1  } { e  } $的情况,为了让这种情况有解,我们的割线必过$( \frac { 1  } { e  } , - \frac { 1  } { e  } ) $.</p>
<p>考虑直接选取$( 0 , 0 ) $和$( 1 , 0 ) $作为另外两个点,这两条割线就是$x = - y $和$x = ( e - 1 ) y + 1 $.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得$( x _2 - x _1 ) _{ \max  } $尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是$u $,另一个是$v $,其中$v &lt; \frac { 1  } { e  } &lt; u $,那么两条切线分别是:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = \frac { y - f ( u )  } { f ' ( u )  } + u \\
x = \frac { y - f ( v )  } { f ' ( v )  } + v 
\end{cases}</script><p>那么,现在我们要做的就是找到一组$( u , v ) $,使得:</p>
<script type="math/tex; mode=display">
\frac { b - f ( u )  } { f ' ( u )  } + u - \frac { b - f ( v )  } { f ' ( v )  } - v = \frac { e ^{ - 3  } + 2 + 3 b  } { 2  }</script><p>感觉很难搞啊,我们不妨让$u = 1 $,自然有:</p>
<script type="math/tex; mode=display">
\frac { ( f ' ( v ) - 1 ) b + f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  } + 3 b  } { 2  }</script><p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { f ' ( v ) - 1  } { f ' ( v )  } = \frac { 3  } { 2  } \\
\frac { f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  }  } { 2  } 
\end{cases}</script><p>考虑让$f ‘ ( v ) = - 2 $,则$v = e ^{ - 3  } $,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4><h5><span id="example1">Example1</span></h5><p>求证:$\forall x \in ( 0 , + \infty ) , \ln x + 1 &gt; \frac { 1  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2 x  } $.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以$x $,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为$x \ln x + x &gt; \frac { x  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2  } $,然后证明左边的最小值$\geq $右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4><p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5><p>已知$a = 0 . 1 e ^{ 0 . 1  } , b = \frac { 1  } { 9  } , c = - \ln 0 . 9 $,求比较$a , b , c $的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6><p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算$a $和$c $的大小关系.</p>
<p>构造函数$f ( x ) = xe ^x + \ln ( 1 - x ) $,则$f ( 0 . 1 ) &gt; 0 \Rightarrow a &gt; c $.</p>
<p>考察$f ( 0 ) = 0 $,$f ‘ ( 0 ) = 0 $,$f ‘ ‘ ( 0 ) = 4 &gt; 0 $,则$f ( 0 ) = 0 $是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算$f ( 0 . 1 ) &gt; 0 $.</p>
<h6><span id="估算定积分">估算定积分</span></h6><p>考察$a $和$b $的大小关系,不妨设$f ( x ) = ( 1 - x ) e ^{ 1 - x  } - \frac { 1  } { 10 x  } $,则$f ( 0 . 9 ) &lt; 0 \Rightarrow b &gt; a $.</p>
<p>注意到$f ( 1 ) = - \frac { 1  } { 10  } $,$f ‘ ( 1 ) = - \frac { 9  } { 10  } $,考虑估算一下积分,那么$f ( 0 . 9 ) \approx f ( 1 ) - f ‘ ( 1 ) 0 . 1 = - \frac { 1  } { 100  } &lt; 0 $.</p>
<p>你可能会觉得这个$- \frac { 1  } { 100  } $,是不是不太能那么肯定地估算啊.但是实际上,我们考察$f ‘ ( x ) = ( x - 2 ) e ^{ 1 - x  } + \frac { 1  } { 10 x ^2  } $,这个东西在$[ 0 . 9 , 1 ] $上直觉上平均值是大于$- \frac { 9  } { 10  } $的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6><p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6><p>接下来开抄标答.</p>
<p>令$f _a ( x ) = xe ^x , f _b ( x ) = \frac { x  } { 1 - x  } , f _c ( x ) = - \ln ( 1 - x ) $.</p>
<p>这样当$x = 0 . 1 $的时候所有的数字都被正确表示了.</p>
<p>比较$a , b $:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = \ln ( a ) - \ln ( b ) & = x + \ln ( 1 - x ) \\
y ' & = 1 - \frac { 1  } { 1 - x  } & = \frac { - x  } { 1 - x  } 
\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单减,这样立有$a &lt; b $.</p>
<p>比较$a , c $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = a - c & = xe ^x + \ln ( 1 - x ) \\
y ' & = ( x + 1 ) e ^x - \frac { 1  } { 1 - x  } & = \frac { ( 1 + x ) ( 1 - x ) e ^x - 1  } { 1 - x  } \\

\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单增,这样立有$a &gt; c $.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2><h3><span id="递归式的求解">递归式的求解</span></h3><h4><span id="特征根法">特征根法</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>在上面做$k = 2 $的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6><p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定$a _0 , . . . , a _n $,其中$a _0 \ne 0 $,对于所有的$k \in \mathbb { N  } $,若有下列式子成立:</p>
<script type="math/tex; mode=display">
a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = z _k</script><p>则称为一个$n $阶线性差分方程(或递归关系).为了简化,通常取$a _0 = 1 $.若$\{ z _k \} $是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6><p>我们注意到,对于齐次差分方程而言,如果不给定$y _0 , \cdots y _{ n - 1  } $,只是构造一组满足条件的$y $的话,自然的想法是令$y _k = r ^k $.其中$r $是辅助方程$a _0 r ^{ n  } + a _1 r ^{ n - 1  } + \cdots + a _n = 0 $的一个根.</p>
<p>注意到如果我们将上面的内容看作是$T : \{ y _k \} \mapsto \{ z _k \} $这样一个映射,这显然是一个线性变换.这意味着齐次方程$a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = 0 $的解集就是$T $的核,设为$H $,不难发现只要给定$y _0 , \cdots y _{ n - 1  } $,这个解就唯一确定,将它们看作自由变量,这意味着$\dim H = n $.</p>
<p>还没完,注意到我们解方程可以解出$n $个根,如果这$n $个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了$y _0 , \cdots y _{ n - 1  } $,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这$n $个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的$\mathbb { R  } ^k $的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共$n $个线性无关的根,然后拟合初值.我们如此做:对于一个出现了$m $次的根$r $,我们注意到$r ^k , kr ^k , \cdots , k ^{ m - 1  } r ^k $都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以$kr ^k $作为例子,即证明:</p>
<script type="math/tex; mode=display">
a _0 nr ^n + a _1 ( n - 1 ) r ^{ n - 1  } + \cdots + a _1 r = 0</script><p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个$r $作为根,必然意味着原方程形如$( y - r ) ^2 P $,其中$P $是一个关于$y $的多项式.</p>
<p>我们把它写开:$( y ^2 - 2 ry + r ^2 ) P = 0 $,然后我们用$kr ^k $去代替$r ^k $,不难发现代替后右边还是个多项式,而左边变成了$0 $,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _0 r ^{ n + k  } + a _1 r ^{ n + k - 1  } + \cdots + a _1 r ^k & = 0 \\
a _0 ( n + k ) r ^{ n + k - 1  } + a _1 ( n + k - 1 ) r ^{ n + k - 2  } + \cdots + a _1 kr ^{ k - 1  } & = 0 \\
a _0 ( n + k ) r ^{ n + k  } + a _1 ( n + k - 1 ) r ^{ n + k - 1  } + \cdots + a _1 kr ^{ k  } & = 0 \\

\end{aligned}</script><p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:$( ( y - r ) ^2 P ) ‘ = ( y - r ) ( ( y - r ) P ) ‘ + ( y - r ) ‘ ( y - r ) P = ( y - r ) [ ( y - r ) ‘ P + ( ( y - r ) P ) ‘ ] $,$r $一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6><p>我们注意到齐次差分方程一定能写成$\vec { x  } _k = A \vec { x  } _{ k - 1  } $的形式.如果我们取$A $的特征向量的线性组合作为$\vec { x  } _0 $,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为$1 $的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3><h4><span id="和式的基本运算">和式的基本运算</span></h4><p>分配律:$\ \sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i \ $.</p>
<p>结合律:$\ \sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i $.</p>
<p>交换律:$\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  } $,其中$p $是$S $集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol>
<li><p>$\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] $.</p>
</li>
<li><p>$\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } $.</p>
</li>
</ol>
<p>一般分配律:$\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j ) $.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4><h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6><p>等差数列求和：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\

\end{aligned}</script><p>又有$( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) $,显然有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \leq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \leq b _j \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \geq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \geq b _j \\

\end{aligned}</script><p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6><p>即$\sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \ $.</p>
<p>令$S _n = \sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 \ $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k - a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6><p>$S _n = \sum _{ i = 0  } ^n i ^2 $.</p>
<p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推，我们设$W _n = \sum _{ i = 0  } i ^3 $</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h4><span id="展开和收缩">展开和收缩</span></h4><h6><span id="example1平方和公式">Example1(平方和公式)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="problme3">Problme3</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="problemex2">ProblemEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<p>$g ( x ) = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f ( x ) + C \ $</p>
<p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<p>\Delta(x^{\underline{m}})=mx^{\underline{m-1}}，\sum mx^{\underline{m-1}}\delta x=x^{\underline{m}}+C，m\ne 0\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $，有:</p>
<p>令H(x)=\sum_{i=1}^x\frac{1}{i}\\\Delta(H(x))=x^{\underline{-1}}，\sum x^{\underline{-1}}\delta x =H(x)+C\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<p>$\Delta ( 2 ^x ) = 2 ^x ， \sum 2 ^x \delta x = 2 ^x + C \ $</p>
<p>$\Delta ( c ^x ) = ( c - 1 ) c ^x ， \sum c ^x \delta x = \frac { c ^x  } { c - 1  } + C , c \ne 1 \ $</p>
<p>$\Delta ( c ^{ \underline { x  }  } ) = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x = c ^{ \underline { x  }  } + C , c - x \ne 0 \ $.</p>
<p>根据组合数公式,有:</p>
<p>$\Delta ( \binom { x  } { k  } ) = \binom { x  } { k - 1  } \ $.</p>
<h6><span id="example1">Example1</span></h6><p>仍然考虑平方和公式：</p>
<p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p>$\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \ $.</p>
<h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k 2 ^k \\
& = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x \\
& = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 \\

\end{aligned}</script><h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3">Example3</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } \\
& = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="example4">Example4</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script><h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3><h5><span id="example">Example</span></h5><p>令$A = \{ 2 n - 1 | n \in \mathbb { N  } _{ +  } \} , B = \{ 3 n - 1 | n \in \mathbb { N  } _{ +  } \} $.求$A \cap B $,以及$A \cup B $的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a \in A \Leftrightarrow a & \equiv - 1 \pmod { 2  } \\
b \in B \Leftrightarrow b & \equiv - 1 \pmod { 6  } \\

\end{aligned}</script><p>所以$A \cap B = \{ 6 n - 1 | n \in \mathbb { N  } _{ +  } \} $.</p>
<p>而同理,$x \in A \cup B \Leftrightarrow x \equiv - 1 / - 2 / - 3 / - 5 \pmod { 6  } $.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3><p>设$A = \{ x | x = 2 n - 1 , n \in \mathbb { N  } _+ \} , B = \{ x | x = 2 ^n , n \in \mathbb { N  } _+ \} $,现在将$A \cup B $中的元素排序并提取成一个数列$a $,求使得$S _n &gt; 12 a _n $最小的正整数$n $.</p>
<p>写出数列,它长这样:</p>
<script type="math/tex; mode=display">
\begin{matrix}
1 & 2 \\
3 & 4 \\
5 & 7 & 8 \\
9 & 11 & 13 & 15 & 16 \\
& & \cdots 
\end{matrix}</script><p>不妨设$n $在第$r $行$c $列,显然$( r , c ) $和$n $构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的$n $能快速表达$( r , c ) $,要么反之.显然反之比较简单.</p>
<p>考虑设前$k $行共有$W _k $个数,不难发现$W _{ k + 1  } = W _k + 2 ^{ k - 1  } + 1 , W _k = 2 ^{ k - 1  } + k $.</p>
<p>显然,对于$( r , c ) $来说,它对应的$n $就是$W _{ r - 1  } + c $.</p>
<p>令$SR _{ r  } $为前$r $行数字之和,不难发现$SR _r = 2 ^{ r + 1  } - 2 + ( 2 ^{ r - 1  } ) ^2 $.</p>
<p>接下来考虑找到这个最小的$n $,显然$r \ne 1 $,接下来只考虑$r \geq 2 $的情况.</p>
<p>那么我们可以轻松写出$S _n $和$a _n $的表达式,下面直接给出:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = SR _{ r - 1  } + \sum _{ k = 1  } ^c ( 2 ^{ r - 1  } + 2 k - 1 ) - [ c & = 2 ^{ r - 2  } + 2 ] \\
S _n & = 2 ^r - 2 + 4 ^{ r - 2  } + 2 ^{ r - 1  } c + c ^2 - [ c & = 2 ^{ r - 2  } + 1 ] \\
a _n & = 2 ^{ r - 1  } + 2 c - 1 - [ c & = 2 ^{ r - 2  } + 1 ] 
\end{aligned}</script><p>讨论一下$[ c = 2 ^{ r - 2  } + 1 ] $这个判定式取$0 $还是取$1 $,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3><h2><span id="几何导论">几何导论</span></h2><h3><span id="三角相关">三角相关</span></h3><h4><span id="三角恒等变换">三角恒等变换</span></h4><h5><span id="两角和差公式">两角和差公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( A + B ) & = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) & = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) & = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) & = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) & = \frac { \tan A + \tan B  } { 1 - \tan A \tan B  } \\
\tan ( A - B ) & = \frac { \tan A - \tan B  } { 1 + \tan A \tan B  } 
\end{aligned}</script><h5><span id="倍角公式">倍角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\tan ( 2 A ) & = \frac { 2 \tan A  } { 1 - \tan ^2 A  } \\
\sin ( 2 A ) & = 2 \sin A \cos A \\
\cos ( 2 A ) & = \cos ^2 A - \sin ^2 A & = 2 \cos ^2 A - 1 & = 1 - 2 \sin ^2 A 
\end{aligned}</script><h5><span id="半角公式">半角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 - \cos A  } { 2  }  } \\
\cos ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 + \cos A  } { 2  }  } \\
\tan ( \frac { A  } { 2  } ) & = \frac { \sin A  } { 1 + \cos A  } & = \frac { 1 - \cos A  } { \sin A  } & = \pm \sqrt { \frac { 1 - \cos A  } { 1 + \cos A  }  } 
\end{aligned}</script><h5><span id="和差化积">和差化积</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A + \sin B & = 2 \sin ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\sin A - \sin B & = 2 \cos ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\cos A + \cos B & = 2 \cos ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\cos A - \cos B & = - 2 \sin ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\tan A + \tan B & = \frac { \sin ( A + B )  } { \cos A \cos B  } 
\end{aligned}</script><p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<script type="math/tex; mode=display">
\sin ^2 A - \sin ^2 B = \sin ( A - B ) \sin ( A + B )</script><p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A \sin B & = - \frac { 1  } { 2  } [ \cos ( A + B ) - \cos ( A - B ) ] \\
\cos A \cos B & = \frac { 1  } { 2  } [ \cos ( A + B ) + \cos ( A - B ) ] \\
\sin A \cos B & = \frac { 1  } { 2  } [ \sin ( A + B ) + \sin ( A - B ) ] \\
\cos A \sin B & = \frac { 1  } { 2  } [ \sin ( A + B ) - \sin ( A - B ) ] 
\end{aligned}</script><h5><span id="万能公式">万能公式</span></h5><p>令$w = \tan \frac { A  } { 2  } $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin A & = \frac { 2 w  } { 1 + w ^2  } \\
\cos A & = \frac { 1 - w ^2  } { 1 + w ^2  } \\
\tan A & = \frac { 2 w  } { 1 - w ^2  } 
\end{aligned}</script><p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos ( x ) & = \frac { e ^{ ix  } + e ^{ - ix  }  } { 2  } \\
\sin ( x ) & = \frac { e ^{ ix  } - e ^{ - ix  }  } { 2 i  } 
\end{aligned}</script><h5><span id="补充公式">补充公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
1 + \sin A & = ( \sin \frac { A  } { 2  } + \cos \frac { A  } { 2  } ) ^2 \\
1 - \sin A & = ( \sin \frac { A  } { 2  } - \cos \frac { A  } { 2  } ) ^2 
\end{aligned}</script><h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4><p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的$k $来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6><p>已知函数$f ( x ) = \sin ( \omega x + \varphi ) , w &gt; 0 $,$f ( - \frac { \pi  } { 6  } ) = 0 , f ( \frac { \pi  } { 2  } ) = - 1 $,求$w $和$\varphi $的表达式.</p>
<p>正确做法应该是强设$k _1 , k _2 $,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的$\omega $和$\varphi $都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令$\frac { \pi  } { 2  } $为单位$1 $,我们必有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- \frac { \omega  } { 3  } + \varphi & \equiv 0 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><p>下面推导$\omega $,首先将上面两个式子直接相减,立有:</p>
<script type="math/tex; mode=display">
\frac { 4  } { 3  } \omega \equiv 1 \pmod { 2  }</script><p>对于$\varphi $,考虑类似的做法,将第一个式子乘以$3 $后与第二个式子相加,立有:</p>
<script type="math/tex; mode=display">
4 \varphi \equiv 1 \pmod { 2  }</script><p>这样我们得到的必须满足的条件就有以下几条:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 4  } { 3  } \omega & \equiv 1 \pmod { 2  } \\
4 \varphi & \equiv 1 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><h3><span id="向量相关">向量相关</span></h3><h4><span id="旋转模型">旋转模型</span></h4><p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6><p>已知$AB = 2 , AC = 1 , \angle A = \theta $,$BC $绕$B $点顺时针旋转$\frac { \pi  } { 3  } $得到$BD $,求以$\theta $表示$S _{ \triangle CBD  } $.</p>
<p>先来说文化课做法,我们直接表示$S $,令$\alpha = \angle ABC $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S & = | BD | \sin ( \alpha + \frac { \pi  } { 3  } ) \\

\end{aligned}</script><p>对于这个式子,我们发现如果我们能得到$| BD | \sin ( \alpha ) $和$| BD | \cos ( \alpha ) $就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现$BD $是$\alpha $的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出$| BD | \sin \alpha $,余弦定理可以帮助我们求出$| BD | \cos \alpha $.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出$\overrightarrow { AB  } $和$\overrightarrow { BC  } $的坐标表示,将$\overrightarrow { BC  } $用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4><p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol>
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p>
</li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作$1 $是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p>
</li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6><p>$\triangle ABC $中,$b ^2 = ac $,点$D $在$AC $上且满足$BD = b $,有$\overrightarrow { AD  } = 2 \overrightarrow { DC  } $,求$\cos \angle ABC $.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定$c = 1 $,于是有$b ^2 = a $.</p>
<p>考虑我们要求$\cos \angle ABC $,而我们有一条很奇怪的边$BD $,似乎不满足任何性质,我们立刻想到要把它用$\angle ABC $的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让$c = 1 $,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4><h5><span id="奔驰定理">奔驰定理</span></h5><p>对于$\triangle ABC $内一点$P $,立有$S _{ \triangle PBC  } \overrightarrow { PA  } + S _{ \triangle PAC  } \overrightarrow { PB  } + S _{ \triangle PAB  } \overrightarrow { PC  } = \vec { 0  } $.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令$a = PA , b = PB , c = PC $,我们要证奔驰定理,也就是要证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
bc \sin \alpha \overrightarrow { PA  } + ac \sin \beta \overrightarrow { PB  } + ab \sin \gamma \overrightarrow { PC  } & = \vec { 0  } \\
abc \sin \alpha \frac { \overrightarrow { PA  }  } { a  } + abc \sin \beta \frac { \overrightarrow { PB  }  } { b  } + abc \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\
\sin \alpha \frac { \overrightarrow { PA  }  } { a  } + \sin \beta \frac { \overrightarrow { PB  }  } { b  } + \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\

\end{aligned}</script><p>考虑$| \frac { \overrightarrow { PA  }  } { a  } | = | \frac { \overrightarrow { PB  }  } { b  } | = | \frac { \overrightarrow { PC  }  } { c  } | = 1 $,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5><p>有正弦定理,$| \overrightarrow { OA  } | = | \overrightarrow { OB  } | = | \overrightarrow { OC  } | = \frac { a  } { 2 \sin A  } $.</p>
<p>考虑三个三角形的面积可以表示为$\frac { r ^2  } { 2  } \sin \theta $,又考虑到圆中的$\theta $是圆心角是圆周角的两倍,立有$\sin ( 2 A ) \overrightarrow { OA  } + \sin ( 2 B ) \overrightarrow { OB  } + \sin ( 2 C ) \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6><p>在$\triangle ABC $中,$AB = 2 , BC = \sqrt { 10  } , AC = 3 $,若$O $是其外心,且$\overrightarrow { AO  } = p \overrightarrow { AB  } + q \overrightarrow { AC  } $.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用$| OA | = | OB | = | OC | $,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于$p , q $的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了$| OA | $,用上$| OB | $,这样的话我们两边同时加上$\overrightarrow { BA  } $,就可以得到$p , q $的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据$| OC | $也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { AO  } & = p \overrightarrow { AB  } + q \overrightarrow { AC  } \\
\vec { 0  } & = ( p + q - 1 ) \overrightarrow { OA  } + p \overrightarrow { OB  } + q \overrightarrow { OC  } 
\end{aligned}</script><p>考察奔驰定理,立有$\frac { p + q - 1  } { \sin ( 2 A )  } = \frac { p  } { \sin ( 2 B )  } = \frac { q  } { \sin ( 2 C )  } $,简单题.</p>
<h6><span id="example2">Example2</span></h6><p>已知相异两点$O , H $分别为$\triangle ABC $的外心和垂心,若$\overrightarrow { OH  } = m ( \overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } ) $,求$m $.</p>
<p>这题要用到的性质是,我们一定要知道$( \overrightarrow { OB  } + \overrightarrow { OC  } ) \cdot \overrightarrow { BC  } = 0 $,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出$\overrightarrow { AH  } $,然后两边同时乘以$\overrightarrow { BC  } $就可以解决.注意到最后解方程的时候要么$m = 1 $,要么三角形等边,但是我们声明过$O , H $相异两点.</p>
<h5><span id="重心">重心</span></h5><p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的$1 : 2 $的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若$O $是重心,则必有$\overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5><p>若$O $是重心,立有$\overrightarrow { OA  } \cdot \overrightarrow { BC  } = 0 $,将$\overrightarrow { BC  } = \overrightarrow { BO  } + \overrightarrow { OC  } $,立有$\overrightarrow { OA  } \cdot \overrightarrow { OB  } = \overrightarrow { OA  } \cdot \overrightarrow { OC  } = \overrightarrow { OB  } \cdot \overrightarrow { OC  } $.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有$\overrightarrow { OA  } \tan A + \overrightarrow { OB  } \tan B + \overrightarrow { OC  } \tan C = \vec { 0  } $.</p>
<h5><span id="内心">内心</span></h5><p>根据奔驰定理,立有$a \overrightarrow { OA  } + b \overrightarrow { OB  } + c \overrightarrow { OC  } = \vec { 0  } $.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3><h4><span id="基本概念">基本概念</span></h4><h5><span id="直线">直线</span></h5><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h5><span id="平面">平面</span></h5><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h5><span id="夹角">夹角</span></h5><h6><span id="两直线夹角">两直线夹角.</span></h6><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h5><span id="交点">交点</span></h5><p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3><h4><span id="约定">约定</span></h4><p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可($mx + ny = 1 $需要判断过原点的直线,$y = kx + b $需要判断平行于$y $轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之和为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | F _1 P | + | F _2 P | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5><h6><span id="标准方程">标准方程</span></h6><p>由定义不难得到椭圆的标准方程:$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( b ^2 = a ^2 - c ^2 , a &gt; b &gt; 0 ) $.</p>
<h6><span id="一般方程">一般方程</span></h6><p>$nx ^2 + my ^2 = 1 ( n , m \geq 0 ) $,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下$n $和$m $的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = a - ex _0 $.</p>
<h6><span id="焦点弦">焦点弦</span></h6><p>过$F _1 $的弦$| AB | = 2 a + e ( x _1 + x _2 ) $.</p>
<p>过$F _2 $的弦$| AB | = 2 a - e ( x _1 + x _2 ) $.</p>
<p>注意到焦点弦最短时$x _1 = x _2 $.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li><p>$C = 2 a + 2 c $.</p>
</li>
<li><p>$S = b ^2 \tan \frac { \theta  } { 2  } = c | y _P | $.</p>
</li>
<li><p>$\cos \theta \geq 1 - 2 e ^2 $(当$P $在短轴上取等).</p>
</li>
<li><p>$| PF _1 | | PF _2 | = \frac { 2 b ^2  } { 1 + \cos \theta  } $.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example1">Example1</span></h6><p>已知椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,$P $是椭圆上一点,$\angle F _1 PF _2 $的角平分线交$x $轴于$Q ( \frac { c  } { 4  } , 0 ) $,求离心率取值范围.</p>
<p>注意到$S _{ \bigtriangleup QPF _1  } = \frac { 5  } { 3  } S _{ \bigtriangleup QPF _2  } $,又有$Q $到$PF _1 $和$PF _2 $的距离相等,用等积法,显然$PF _1 = \frac { 5  } { 4  } a , PF _2 = \frac { 3  } { 4  } a $.</p>
<p>然后用三角形不等式做差就行.$2 c &gt; \frac { 1  } { 2  } a , \frac { 1  } { 4  } &lt; e $</p>
<h4><span id="双曲线">双曲线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之差为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | | F _1 P | - | F _2 P | | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) , ( x _0 &gt; 0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = - a + ex _0 $.</p>
<h6><span id="渐近线">渐近线</span></h6><p>$y = \pm \frac { b  } { a  } x $.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成$0 $得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li>$S = \frac { b ^2  } { \tan \frac { \theta  } { 2  }  } $.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5><h6><span id="焦点弦">焦点弦</span></h6><p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线$AB $为过$y ^2 = 2 px ( p &gt; 0 ) $焦点的弦,$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,倾斜角为$\theta $,准线与$x $轴交点为$E ( - \frac { p  } { 2  } , 0 ) $,作$AA _1 $,$BB _1 $垂直于准线于$A _1 , B _1 $,则:</p>
<ol>
<li><p>$| AF | = x _1 + \frac { p  } { 2  } $,$| BF | = x _2 + \frac { p  } { 2  } $,$| AB | = x _1 + x _2 + p , \frac { 1  } { | FA |  } + \frac { 1  } { | FB |  } = \frac { 2  } { p  } $.</p>
</li>
<li><p>$| AF | = \frac { p  } { 1 - \cos \theta  } , | BF | = \frac { p  } { 1 + \cos \theta  } , | AB | = \frac { 2 p  } { \sin ^2 \theta  } $.</p>
</li>
<li><p>$x _1 x _2 = \frac { p ^2  } { 4  } $,$y _1 y _2 = - p ^2 $.</p>
</li>
<li><p>$S _{ \bigtriangleup AOB  } = \frac { p ^2  } { 2 \sin \theta  } $.</p>
</li>
<li><p>$k _{ AE  } + k _{ BE  } = 0 $.</p>
</li>
<li><p>$A , O , B _1 $三点共线,$B , O , A _1 $三点共线.</p>
</li>
<li><p>以$AB $为直径的圆与抛物线的准线相切.</p>
</li>
<li><p>以$A _1 B _1 $为直径的圆与$AB $相切.</p>
</li>
<li><p>以$AF $或$BF $为直径的圆与$y $轴相切.</p>
</li>
</ol>
<h4><span id="通用解法">通用解法</span></h4><h5><span id="联立方程">联立方程</span></h5><h6><span id="点参">点参</span></h6><p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线$l $上有两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,那么$| NM | = \sqrt { 1 + k ^2  } | x _1 - x _2 | = \sqrt { 1 + \frac { 1  } { k ^2  }  } | y _1 - y _2 | $.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,其中点$M ( x _0 , y _0 ) $,有$2 x _0 = x _1 + x _2 , 2 y _0 = y _1 + y _2 $.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线$l $与曲线交于两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,$MN $的中点为$P ( x _0 , y _0 ) $,那么:</p>
<ol>
<li><p>在椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( a &gt; b &gt; 0 ) $中,$k \frac { y _0  } { x _0  } = - \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $中,$k \frac { y _0  } { x _0  } = \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在抛物线$y ^2 = 2 px ( p &gt; 0 ) $中,$k = \frac { p  } { y _0  } = \frac { x _0  } { p  } $.</p>
</li>
</ol>
<h6><span id="小联立">小联立</span></h6><p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6><p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线$PA $,$PB $,我们可以将公共点$P $平移至原点,这样$PA $和$PB $的方程都方便表达.然后设$AB $的方程为$mx + ny = 1 $(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以$mx + ny $,零次项乘以$( mx + ny ) ^2 $,这样就得到了一个齐次式子.将两边同时除以$x ^2 $后就得到了一个和$k = \frac { y  } { x  } $有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的$x _1 x _2 $和$x _1 + x _2 $之间的关系来做.</p>
<p>当然还有一种情况是问形如$\frac { Ax _1 + Bx _2  } { Cx _1 + Dx _2  } $是定值的问题,这个时候一定有$\frac { A  } { C  } = \frac { B  } { D  } $.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令$w = \frac { x _1  } { x _2  } $,自然有$w + \frac { 1  } { w  } + 2 = \frac { ( x _1 + x _2 ) ^2  } { x _1 x _2  } $.</p>
<p>还比如有$y _2 = ny _1 + m $,我们可以用配凑技巧改写作$( y _2 + w ) = k ( y _1 + w ) $,也就有$\frac { y _2 + w  } { y _1 + w  } = k $,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线$y = kx + \varphi $与曲线$\frac { x ^2  } { m  } + \frac { y ^2  } { n  } = 1 $相交于$A ( x _1 , y _1 ) $和$B ( x _2 , y _2 ) $.</p>
<p>那么联立方程是:$( n + mk ^2 ) x ^2 + 2 k \varphi mx + m ( \varphi ^2 - n ) = 0 $.</p>
<p>判别式:$\Delta = 4 mn ( n + mk ^2 - \varphi ^2 ) $.</p>
<p>韦达定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x _1 + x _2 & = \frac { - 2 km \varphi  } { n + mk ^2  } \\
x _1 x _2 & = \frac { m ( \varphi ^2 - n )  } { n + mk ^2  } \\
| x _1 - x _2 | & = \frac { \sqrt { \Delta  }  } { n + mk ^2  } 
\end{aligned}</script><h6><span id="配凑法">配凑法</span></h6><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/521025768">https://zhuanlan.zhihu.com/p/521025768</a>.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6><p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线$y ^2 = 4 x $,若$A , B $位于抛物线上$x $轴上方不同的两点,直线$OA , OB $的斜率分别为$k _1 , k _2 $,且满足$k _1 k _2 - 4 = 4 k _1 + 4 k _2 $,求证:$AB $过定点,并求出$k _{ AB  } $的取值范围.</p>
<p>注意到$k _1 $和$k _2 $之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设$AB : y = kx + b $,则$A ( x _1 , kx _1 + b ) , B ( x _2 , kx _2 + b ) $,显然$k _1 = k + \frac { b  } { x _1  } , k _2 = k + \frac { b  } { x _2  } $.</p>
<p>直接带入方程,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k + \frac { b  } { x _1  } ) ( k + \frac { b  } { x _2  } ) - 4 & = 4 ( 2 k + \frac { b  } { x _1  } + \frac { b  } { x _2  } ) \\
k ^2 + kb ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) + \frac { b ^2  } { x _1 x _2  } - 4 & = 8 k + 4 b ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) \\

\end{aligned}</script><p>而直接大联立得到的式子是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 x ^2 + ( 2 kb - 4 ) x + b ^2 & = 0 \\
\Delta & = 16 - 16 kb & > 0 , kb & < 1 \\
x _1 x _2 & = \frac { b ^2  } { k ^2  } , x _1 + x _2 & = \frac { 4 - 2 kb  } { k ^2  } , \frac { 1  } { x _1  } + \frac { 1  } { x _2  } & = \frac { 4 - 2 kb  } { b ^2  } 
\end{aligned}</script><p>带入,得到$k - b = 4 $,因此过定点$( - 1 , - 4 ) $,与$kb &lt; 1 $联立得到$k &lt; 2 + \sqrt { 5  } $.</p>
<p>还没完,这种题一定要检查一遍条件.注意到$AB $为$x $轴上方两点的性质没用到,这意味着$y _1 y _2 &gt; 0 \land y _1 + y _2 &gt; 0 $,带入方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b ^2 + b ( \frac { 4 - 2 kb  } { k  } ) + b ^2 & > 0 \\
\frac { 4 - 2 kb  } { k  } + 2 b & > 0 
\end{aligned}</script><p>化简得到$\begin{cases}b &gt; 0 \ k &gt; 0 \end{cases} $,解得$k &gt; 4 $,于是$k \in ( 4 , 2 + \sqrt { 5  } ) $.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,$OA $和$OB $的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k _{ OA  } & = \frac { y _1  } { x _1  } , k _{ OB  } & = \frac { y _2  } { x _2  } \\
\frac { y _1 y _2  } { x _1 x _2  } - 4 & = 4 ( \frac { y _1  } { x _1  } + \frac { y _2  } { x _2  } ) \\
16 - 4 y _1 y _2 & = 16 ( y _1 + y _2 ) 
\end{aligned}</script><p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<script type="math/tex; mode=display">
\begin{aligned}
AB : \\
x - x _1 & = ( y - y _1 ) \frac { x 1 - x _2  } { y _1 - y _2  } \\
x - \frac { y _1 ^2  } { 4  } & = ( y - y _1 ) \frac { 1  } { 4  } ( y _1 + y _2 ) \\
x & = \frac { y _1 + y _2  } { 4  } y - \frac { y _1 y _2  } { 4  } \\
x & = \frac { y _1 + y _2  } { 4  } y - 1 + ( y _1 + y _2 ) 
\end{aligned}</script><p>显然过定点$( - 1 , - 4 ) $,并且通过$y _1 $和$y _2 $的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个$\frac { x - x _1  } { x _1 - x _2  } = \frac { y - y _1  } { y _1 - y _2  } $的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + y ^2 = 1 $,$P , Q $在椭圆上,$A ( 2 , 0 ) $,$k _{ AP  } k _{ AQ  } = \frac { 1  } { 20  } $,求证:$PQ $过定点.</p>
<p>注意到$A ( 2 , 0 ) $,设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$PQ : m ( x - 2 ) + yn = 1 $,那么我们要求的也就是$x - 2 $和$y $之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然$\frac { x ^2  } { 4  } + y ^2 = 1 \Rightarrow \frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 $.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令$x ‘ = x - 2 , y ‘ = y $,我们有$x = x ‘ + 2 , y = y ‘ $,带入就可以得到关于$x ‘ , y ‘ $的方程,然后再带回$x $和$y $就行.</p>
<p>我们开始推导:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 \\
( x - 2 ) ^2 + 4 ( x - 2 ) + 4 y ^2 = 0 \\
( x - 2 ) ^2 + 4 n ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
( 4 n + 1 ) ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
4 n + 1 + 4 m \frac { y  } { x - 2  } + 4 ( \frac { y  } { x - 2  } ) ^2 = 0 \\

\end{aligned}</script><p>令$k = \frac { y  } { x - 2  } $,也就得到了$4 n + 1 + 4 mk + 4 k ^2 = 0 $.用一遍韦达定理,有:$k _1 k _2 = \frac { 4 n + 1  } { 4  } = \frac { 1  } { 20  } , n = - \frac { 1  } { 5  } $.</p>
<p>也就有:$PQ : - \frac { 1  } { 5  } ( x - 2 ) + my = 1 $,显然过定点$( - 3 , 0 ) $.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 9  } + y ^2 = 1 $,$P , Q $是该椭圆上两动点,$M , N $分别为$P , Q $在$x $轴上的射影,而且$k _{ OP  } k _{ OQ  } = - 1 $,记$S = S _{ \bigtriangleup OPM  } + S _{ \bigtriangleup OQN  } $,求$S $的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线$PQ $很重要的时候,而这个题除了$P , Q $两点以外,和$PQ $半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$k = \frac { y _1  } { x _1  } , - \frac { 1  } { k  } = \frac { y _2  } { x _2  } $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = | x _1 y _1 | + | x _2 y _2 | \\
& = | x _1 ^2 k - \frac { 1  } { k  } x _2 ^2 | \\

\end{aligned}</script><p>而联立方程,有:</p>
<script type="math/tex; mode=display">
x _1 ^2 = \frac { 1  } { \frac { 1  } { 9  } + k  } , x _2 ^2 = \frac { 1  } { \frac { 1  } { 9  } - \frac { 1  } { k  }  }</script><p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线$PQ $有两个未知量,我们还需要拿$k _{ OP  } k _{ OQ  } = - 1 $限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 2  } + y ^2 = 1 $,$F ( 1 , 0 ) $,直线$l $过$F $且交椭圆于$A , B $两点.求问:$x $轴上是否存在异于$F $的一点$Q $,使得$\frac { k _{ QA  }  } { k _{ QB  }  } $是定值.</p>
<p>直接设$AB : x = ky + 1 $,$Q ( q , 0 ) $.我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = \frac { y _1 ( q - x _2 )  } { y _2 ( q - x _1 )  } \\
& = - \frac { ky _1 y _2 + y _1 - qy _1  } { ky _1 y _2 + y _2 - qy _2  } 
\end{aligned}</script><p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k ^2 + 2 ) y ^2 + 2 ky - 1 & = 0 \\
\Delta & = 8 k ^2 + 8 & > 0 \\
y _1 + y _2 & = - \frac { 2 k  } { k ^2 + 2  } \\
y _1 y _2 & = - \frac { 1  } { k ^2 + 2  } \\

\end{aligned}</script><p>注意到$\frac { ( y _1 + y _2 )  } { 2  } = k ( y _1 y _2 ) $,代入,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = - \frac { y _1 + y _2 + 2 y _1 - 2 qy _1  } { y _1 + y _2 + 2 y _2 - 2 qy _2  } \\
& = - \frac { ( 3 - 2 q ) y _1 + y _2  } { ( 3 - 2 q ) y _2 + y _1  } 
\end{aligned}</script><p>若是定值,那么就有:$\frac { 3 - 2 q  } { 1  } = \frac { 1  } { 3 - 2 q  } $,解得$q _1 = 1 ( F ) $,$q _2 = 2 ( Q ) $.</p>
<p>所以$Q ( 2 , 0 ) $.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,过$F ( - 1 , 0 ) $的直线交椭圆于$M , N $两点,过$M $作直线$x = - 4 $的垂线,垂足为$E $,求证:$EN $过定点.</p>
<p>根据对称原理,显然这个定点一定在$x $轴上.</p>
<p>我们先写大联立的式子:设$MN : x = - 1 + ky $,带入有$( 3 m ^2 + 4 ) y ^2 - 6 my - 9 = 0 $.再设$M ( x _1 , y _1 ) , N ( x _2 , y _2 ) $,自然有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\Delta = 144 k ^2 + 144 \\
y _1 + y _2 = \frac { 6 k  } { 3 k ^2 + 4  } \\
y _1 y _2 = \frac { - 9  } { 3 k ^2 + 4  } 
\end{cases}</script><p>接下来呢,我们想一下我们要求什么:我们要求出$EN $的表达式:形如$y - m = k ( x - n ) $,然后声明$( n , m ) $是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有$k = \frac { y - m  } { x - n  } $.而我们现在有两个点$E ( - 4 , y _1 ) $和$N ( x _2 , y _2 ) $,又猜出$m = 0 $,也就是我们要找到一个$n $满足$\frac { y _1  } { - 4 - n  } = \frac { y _2  } { x _2 - n  } $.</p>
<p>我们倒着推:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { x _2 - n  } \\
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { ky _2 - 1 - n  } 
\end{aligned}</script><p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ky _1 y _2 + \frac { 3  } { 2  } ( y _1 + y _2 ) & = 0 \\
( x _2 + \frac { 5  } { 2  } ) y _1 & = - \frac { 3  } { 2  } y _2 \\
y _1 & = \frac { - 3  } { 2  } \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - \frac { 3  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - 4 + \frac { 5  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\

\end{aligned}</script><p>做到这一步发现要做完了,不难发现$n = \frac { 5  } { 2  } $.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了$m = 0 $了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5><h6><span id="定义">定义</span></h6><p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点$P $作直线$l $交二次曲线于$M , N $两点(离$P $近的是$M $),则在$l $上有且只有一点$Q $,使得$| MQ | | NP | = | MP | | NQ | $(即$P , Q , M , N $构成一调和点列).当$l $绕着$P $旋转时,$Q $的轨迹是一条直线$p $(或一部分),这条直线$p $叫做点$P $关于二次曲线的极线,而$P $叫做$p $关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:$p : \frac { x _0 x  } { a ^2  } + \frac { y _0 y  } { b ^2  } = 1 $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线$C : Ax ^2 + Bxy + Cy ^2 + Dx + Ey + F = 0 $上的一点$P ( x _0 , y _0 ) $,我们称它的极线为$p : Axx _0 + B \frac { x _0 y + y _0 x  } { 2  } + Cyy _0 + D \frac { x + x _0  } { 2  } + E \frac { y + y _0  } { 2  } + F = 0 $.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6><p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线$C $,如果点$P $的极线经过点$Q $,那么点$Q $的极线经过点$P $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol>
<li><p>设四边形$ABCD $(对边不平行)内接于二次曲线$C $,则对角线交点$P $的极线是两组对边交点的连线.反之同理,若$P $在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p>
</li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p>
</li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p>
</li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6><p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知$\frac { \cos \theta  } { a  } + \frac { \sin \theta  } { b  } = 1 $,求证:$\frac { 1  } { a ^2  } + \frac { 1  } { b ^2  } \geq 1 $.</p>
<p>设直线$l : \frac { x  } { a  } + \frac { y  } { b  } = 1 $,$M ( \cos \theta , \sin \theta ) $,则$M $在$l $上.</p>
<p>又注意到$M $显然是在单位圆上,而$l $是单位圆关于$P ( \frac { 1  } { a  } , \frac { 1  } { b  } ) $的极点.又注意到$l $与单位圆至少有一个交点,因此$P $要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,$A _1 ( - 2 , 0 ) , A _2 ( 2 , 0 ) , D ( \frac { 1  } { 2  } , 0 ) $,过$D $的直线交椭圆于$P , Q $两点(不与$A _1 , A _2 $重合).$A _1 P \cap A _2 Q = M $,$A _1 Q \cap A _2 P = N $,设$k _1 = k _{ A _1 P  } , k _2 = k _{ A _1 Q  } $.求证:$k _1 k _2 $是定值,求出这个定值并求出$\bigtriangleup DMN $面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知$MN : x = 8 $.</p>
<p>我们先来看已知$MN : x = 8 $之后怎么做:</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,再设$PQ : x = ky + \frac { 1  } { 2  } $,则:$k _1 k _2 = \frac { y _1  } { x _1 + 2  } \frac { y _2  } { x _2 + 2  } $,不难算出$k _1 k _2 = - \frac { 9  } { 20  } $.</p>
<p>此时$S _{ \bigtriangleup DMN  } = | MN | | 8 - \frac { 1  } { 2  } | \frac { 1  } { 2  } $.不难发现只需求出$| MN | _{ \min  } $即可.而$MN \bot x $轴,所以$| MN | = | y _M - y _N | $.</p>
<p>接下来咋做?第一问求得$k _1 $和$k _2 $的关系不能白求啊!</p>
<p>我们有$A _1 P : x = - 2 + \frac { 1  } { k _1  } y , A _1 Q : x = - 2 + \frac { 1  } { k _2  } y $,带入$x = 8 $,求得$y _M = 10 k _1 , y _N = 10 k _2 $.</p>
<p>于是$| MN | = 10 | k _1 - k _2 | $.注意到$k _1 &gt; 0 \land - k _2 &gt; 0 \land k _1 ( - k _2 ) = \frac { 9  } { 20  } $,显然可以用基本不等式计算,最后得到$S _{ \min  } = \frac { 45 \sqrt { 5  }  } { 2  } $.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出$A _1 Q : x = - 2 + \frac { y _2  } { x _2 + 2  } y , A _2 P : x = 2 + \frac { y _1  } { x _1 - 2  } y $,然后我们声明这两条直线的交点的横坐标一定是$8 $,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5><p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们将$y $看作$x $的函数,对两边求导,自然得到:</p>
<script type="math/tex; mode=display">
\frac { 2 x  } { a ^2  } + \frac { 2 yy '  } { b ^2  } = 0</script><p>这是个方程,你可以解得$y ‘ = - \frac { b ^2 x  } { a ^2 y  } $.而这就是椭圆过$( x , y ) $这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5><p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6><p>向量$\vec { b  } = ( x , y ) $逆时针旋转$\theta $后得到的答案是$A \vec { b  } $,其中</p>
<p>\cos\theta,-\sin\theta\\</p>
<p>\sin\theta,\cos\theta</p>
<p>\end{bmatrix} </p>
<p>你要不喜欢矩阵表示也不是不行,那向量$( x , y ) $旋转$\theta $得到$( x ‘ , y ‘ ) $,其中</p>
<p>y’=xsin\theta+ycos\theta</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6><p>我们注意到圆的方程是$( x ‘ ) ^2 + ( y ‘ ) ^2 = 1 $,而椭圆的方程形如$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们注意到上面的式子等价于:$( \frac { x  } { a  } ) ^2 + ( \frac { y  } { b  } ) ^2 = 1 $.我们将原坐标系中的所有坐标$( x , y ) $全部变成$( \frac { x  } { a  } , \frac { y  } { b  } ) $之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令$\vec { f  } = ( x , y ) $满足椭圆方程,令$\vec { g  } = ( x ‘ , y ‘ ) $满足圆的方程,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}
\frac { 1  } { a  } , 0 \\
0 , \frac { 1  } { b  } 
\end{bmatrix} \vec { f  } & = \vec { g  } \\

\end{aligned}</script><script type="math/tex; mode=display">
\begin{bmatrix}
a , 0 \\
0 , { b  } 
\end{bmatrix} \vec { g  } = \vec { f  }</script><h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6><p>注意到反比例函数的方程是$x ‘ y ‘ = 1 $,而双曲线的方程是$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
<p>首先先转化为$x ^2 - y ^2 = 2 $的形式,需要左乘矩阵$\begin{bmatrix}\frac { \sqrt { 2  }  } { a  } , 0 \ 0 , \frac { \sqrt { 2  }  } { b  } \end{bmatrix} $.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转$\frac { \pi  } { 4  } $了.旋转矩阵为</p>
<p>\frac{1}{\sqrt{2}},-\frac{1}{\sqrt{2}}\\</p>
<p>\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>\frac{1}{a},-\frac{1}{b}\\</p>
<p>\frac{1}{a},\frac{1}{b}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x ‘ = \frac { x  } { a  } - \frac { y  } { b  } , y ‘ = \frac { x  } { a  } + \frac { y  } { b  } $.带入反比例函数的方程:</p>
<script type="math/tex; mode=display">
x ' y ' = \frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1</script><p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>\frac{a}{2},\frac{a}{2}\\</p>
<p>-\frac{b}{2},\frac{b}{2}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x = \frac { a  } { 2  } ( x ‘ + y ‘ ) , y = \frac { b  } { 2  } ( { y ‘ - x ‘  } ) $,带入双曲线方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \frac { x  } { a  } ) ^2 - ( \frac { y  } { b  } ) ^2 & = 1 \\
( x ' + y ' ) ^2 - ( x ' - y ' ) ^2 & = 4 \\
x ' y ' & = 1 
\end{aligned}</script><p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6><p>这个比较简单,交换$x , y $即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5><p>平面内取一点$O $为极点,引一条射线$Ox $叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点$M $,令$\rho = | OM | $,$\theta $为以$Ox $为始边,沿角度正方向(一般是逆时针方向)转到$OM $的夹角.那么我们称$( \rho , \theta ) $为$M $的极坐标,其中$\rho $叫做极径,$\theta $叫做极角.</p>
<p>$\rho $有可能取负,我们通常认为$( - \rho , \theta ) = ( \rho , \theta + \pi ) $.</p>
<p>通常情况下默认$0 \leq \theta &lt; 2 \pi , \rho \geq 0 $.如果遇到和直角坐标系结合的问题,通常默认原点为极点,$x $轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若$M $在直角坐标系中坐标为$( x , y ) $,在极坐标中坐标为$( \rho , \theta ) $,若$M \ne O $自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x & = \rho \cos \theta , y & = \rho \sin \theta \\
\rho ^2 & = x ^2 + y ^2 , \theta & = \begin{cases}
\frac { \pi  } { 2  } & x = 0 \land y > 0 \\
\frac { 3 \pi  } { 2  } & x = 0 \land y < 0 \\
\arctan ( \frac { y  } { x  } ) & x \ne 0 
\end{cases} 
\end{aligned}</script><p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6><p>显然是$\rho ^2 = r ^2 $.</p>
<p>另外,如果中心在$C ( \rho _0 , \theta _0 ) $,半径为$r $的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
r ^2 & = ( \rho \cos \theta - \rho _0 \cos \theta _0 ) ^2 + ( \rho \sin \theta - \rho _0 \sin \theta _0 ) \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos \theta \cos \theta _0 - 2 \rho \rho _0 \sin \theta \sin \theta _0 \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos ( \theta - \theta _0 ) 
\end{aligned}</script><p>另外由于$\cos \theta = \cos ( - \theta ) $,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6><p>过定点$( \rho _1 , \theta _1 ) $,且倾斜角为$\alpha $:$\rho \sin ( \alpha - \theta ) = \rho _1 \sin ( \alpha - \theta _1 ) $.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点$( x _1 , y _1 ) $,倾斜角为$\alpha $,我们自然有$( x - x _1 ) \sin \alpha = ( y - y _1 ) \cos \alpha $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) \sin \alpha & = ( y - y _1 ) \cos \alpha \\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) \sin \alpha & = ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) & = \rho _1 \sin ( \alpha - \theta _1 ) 
\end{aligned}</script><p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点$( \rho _1 , \theta _1 ) $和$( \rho _2 , \theta _2 ) $的直线方程.</p>
<p>同理的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) ( y _2 - y _1 ) & = ( y - y _1 ) ( x _2 - x _1 ) \\
\\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) ( \rho _2 \sin \theta _2 - \rho _1 \sin \theta _1 ) \\
& = ( \rho _2 \cos \theta _2 - \rho _1 \cos \theta _1 ) ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \\
\\
\rho \rho _2 ( \cos \theta \sin \theta _2 - \cos \theta _2 \sin \theta ) \\
+ \rho \rho _1 ( - \cos \theta \sin \theta _1 + \sin \theta \cos \theta _1 ) \\
+ \rho _1 \rho _2 ( - \cos \theta _1 \sin \theta _2 + \cos \theta _2 \sin \theta _1 ) \\
& = 0 \\
\\
\rho \rho _2 \sin ( \theta _2 - \theta ) + \rho \rho _1 \sin ( \theta - \theta _1 ) + \rho _1 \rho _2 \sin ( \theta _1 - \theta _2 ) & = 0 
\end{aligned}</script><p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6><p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离$d $和到定点距离$r $之比为常数的曲线.令$e = \frac { r  } { d  } $.</p>
<p>假定定点为原点,极轴垂直于准线,$h $为定点到准线的距离,又设曲线上一点为$M ( \rho , \theta ) $,自然有:$r = \rho , d = h + \rho \cos \theta $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
e & = \frac { \rho  } { h + \rho \cos \theta  } \\
he + e \rho \cos \theta & = \rho \\
\rho & = \frac { he  } { 1 - e \cos \theta  } 
\end{aligned}</script><p>值得一提的是这玩意不能将圆理解为$e = 0 $的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5><p>在平面直角坐标系中,曲线上任意一点的坐标$x , y $都是某个变量$t $的函数$\begin{cases}x = f ( t ) \ y = g ( t ) \end{cases} $.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6><p>$M ( r \cos \theta , r \sin \theta ) $,其中$\theta $是$\angle OMx $.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6><p>$M ( x _0 + t \cos \theta , y _0 + t \sin \theta ) $,其中$\theta $是倾斜角,$t $是参数,$M _0 ( x _0 , y _0 ) $.</p>
<p>注意到$| M _0 M | = | t | $.事实上,设$\vec { e  } = ( \cos \theta , \sin \theta ) $,也就是直线的单位方向向量,则$\overrightarrow { M _0 M  } = t \vec { e  } $.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6><p>$M ( a \cos \theta , b \sin \theta ) $,其中$\theta $称为$M $的离心角.</p>
<p>值得注意的是,这里的$\theta $并非$\angle MOx $,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆$\frac { x ^2  } { 9  } + \frac { y ^2  } { 4  } = 1 $上求一点$M $,使$M $到直线$x + 2 y - 10 = 0 $的距离最小.</p>
<p>直接令$M = ( 3 \cos \theta , 2 \sin \theta ) $,则$d = \frac { | 3 \cos \theta + 4 \sin \theta - 10 |  } { \sqrt { 5  }  } = | \sqrt { 5  } \sin ( \theta + \varphi ) - 2 \sqrt { 5  } | $,其中$\varphi = \arcsin \frac { 3  } { 5  } $.</p>
<p>于是$d _{ \min  } = \sqrt { 5  } $,此时$\sin ( \theta + \varphi ) = 1 = \sin { \frac { \pi  } { 2  }  } $,那么就有$\theta = \frac { \pi  } { 2  } - \varphi $,$\sin \theta = \cos \varphi = \frac { 4  } { 5  } , \cos \theta = \sin \varphi = \frac { 3  } { 5  } $.</p>
<p>则$M = ( \frac { 9  } { 5  } , \frac { 8  } { 5  } ) $.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 100  } + \frac { y ^2  } { 64  } = 1 $,有一内接矩阵$ABCD $($AB / / x , BC / / y $),求矩阵最大面积.</p>
<p>直接令$A = ( 10 \cos \theta , 8 \sin \theta ) $,则$S = 20 \cos \theta \times 16 \sin \theta = 160 \sin ( 2 \theta ) $,$S _{ \max  } = 160 $.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6><p>$M ( \frac { a  } { \cos \theta  } , b \tan \theta ) = M ( a \sec \theta , b \tan \theta ) $,其中$\theta $称为$M $的离心角,通常规定$\theta \in [ 0 , 2 \pi ] \land \theta \ne \frac { \pi  } { 2  } \land \theta \ne \frac { 3 \pi  } { 2  } $.</p>
<p>其实本质也就是三角恒等式$\sec ^2 \theta = 1 + \tan ^2 \theta $.</p>
<p><strong>Example1</strong></p>
<p>圆$O : x ^2 + ( y - 2 ) ^2 = 1 $上有一点$P $,双曲线$x ^2 - y ^2 = 1 $上有一点$Q $,求$| PQ | _{ \min  } $.</p>
<p>设$Q ( \sec \theta , \tan \theta ) $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
| OQ | ^2 & = \sec ^2 \theta + ( \tan \theta - 2 ) ^2 \\
& = \tan ^2 \theta + 1 ( \tan \theta - 2 ) ^2 \\
& = 2 ( \tan \theta - 1 ) ^2 + 3 
\end{aligned}</script><p>$| OQ | _{ \min  } = \sqrt { 3  } , | PQ | _{ \min  } = \sqrt { 3  } - 1 $.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设$P ( a \sec \theta , a \tan \theta ) , Q ( - a \sec \theta , a \tan \theta ) $,则$k _P = \frac { a \tan \theta  } { a \sec \theta - a  } , k _Q = \frac { a \tan \theta  } { - a \sec \theta - a  } $.注意到$k _P \cdot k _Q = - 1 $.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,$A , B $是双曲线同支上相异两点,线段$AB $的垂直平分线与$x $轴相交于点$P ( x _0 , 0 ) $,求证:$| x _0 | &gt; \frac { c ^2  } { a  } = \frac { a ^2 + b ^2  } { a  } $.</p>
<p>设$A ( a \sec \alpha , b \tan \alpha ) , B ( a \sec \beta , b \tan \beta ) $,则中点$M ( \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) , \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) $.</p>
<p>于是中垂线方程为$y - \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) = - \frac { a ( \sec \alpha - \sec \beta )  } { b ( \tan \alpha - \tan \beta )  } [ x - \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) ] $.</p>
<p>代入$P ( x _0 , 0 ) $,求得$x _0 = \frac { c ^2  } { 2 a  } ( \sec \alpha + \sec \beta ) $.</p>
<p>也就是要比较$| \sec \alpha + \sec \beta | $和$2 $的大小关系,注意到$A , B $同支,所以$| \sec \alpha + \sec \beta | &gt; 2 $.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6><p>$M ( \frac { 2 p  } { \tan ^2 \theta  } , \frac { 2 p  } { \tan \theta  } ) $,其中$\theta $称为$M $的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:$M ( 2 pk ^2 , 2 pk ) $,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
<p>若抛物线$\begin{cases}x = 2 pt ^2 \ y = 2 pt \end{cases} $上有不同两点$M _1 , M _2 $,所对应的参数分别是$t _1 , t _2 $,求直线$M _1 M _2 $所在直线的斜率.</p>
<p>$k _{ M _1 M _2  } = \frac { 2 pt _1 - 2 pt _2  } { 2 pt _1 ^2 - 2 pt _2 ^2  } = \frac { 1  } { t _1 + t _2  } $.</p>
<p><strong>Example2</strong></p>
<p>$A , B $是抛物线$y ^2 = 2 px $上异于顶点的两动点,且$OA \bot OB $,$AB $上有一点$M $满足$OM \bot AB $,求$M $的轨迹方程.</p>
<p>设$M ( x , y ) , A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { OM  } & = ( x , y ) \\
\overrightarrow { OA  } & = ( 2 pt _1 ^2 , 2 pt _1 ) \\
\overrightarrow { OB  } & = ( 2 pt _2 ^2 , 2 pt _2 ) \\
\overrightarrow { AB  } & = ( 2 p ( t _2 ^2 - t _1 ^2 ) , 2 p ( t _2 - t _1 ) ) 
\end{aligned}</script><p>因为$\overrightarrow { OA  } \bot \overrightarrow { OB  } $,所以$( 2 pt _1 t _2 ) ^2 + ( 2 p ) ^2 t _1 t _2 = 0 $,$t _1 t _2 = - 1 $.</p>
<p>因为$\overrightarrow { AB  } \bot \overrightarrow { OM  } $,又有$k _{ AB  } = \frac { 1  } { t _1 + t _2  } $,所以$k _{ OM  } = - ( t _1 + t _2 ) $,$\frac { y  } { x  } = - ( t _1 + t _2 ) $.</p>
<p>接下来咋做捏?注意到我们好像忘记了$ABM $三点共线的性质,拿向量做这个东西.</p>
<p>$\overrightarrow { AM  } = ( x - 2 pt _1 ^2 , y - 2 pt _1 ) , \overrightarrow { MB  } = ( 2 pt _2 ^2 - x , 2 pt _2 - y ) $.</p>
<p>那么有$( x - 2 pt _1 ^2 ) ( 2 pt _2 - y ) = ( 2 pt _2 ^2 - x ) ( y - 2 pt _1 ) $.</p>
<p>化简得到$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点$A , B $,自然要设出它们的参数方程.然后呢?然后我们发现最后$M $一定和$t _1 , t _2 $有关.但是我们要求的是$M $的方程,其中不能带有$t _1 , t _2 $,因此考虑把$M $的坐标设出来,再用这个坐标表示$t _1 , t _2 $,表示不出来表示$t _1 t _2 , t _1 + t _2 $也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到$M $一定在以$| OA | $为直径的圆上,$B $同理,这两个圆的方程分别为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^2 + y ^2 - 2 pt _1 ^2 x - 2 pt _1 y & = 0 \\
x ^2 + y ^2 - 2 pt _2 ^2 x - 2 pt _2 y & = 0 
\end{aligned}</script><p>也就是说,$t _1 , t _2 $是同一个方程的两个根,根据韦达定理自然有$t _1 t _2 = \frac { - ( x ^2 + y ^2 )  } { 2 px  } = - 1 $,于是直接有$x ^2 + y ^2 - 2 px = 0 $.</p>
<p>还没完,注意到$O $一定是一个根,要去掉,所以答案就是$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p><strong>Example3</strong></p>
<p>已知$A , B , C $是抛物线$y ^2 = 2 px ( p &gt; 0 ) $上的三个点,且$BC $与$x $轴垂直,直线$AB $和$AC $分别与抛物线的轴交于$D , E $两点,求证:抛物线的顶点平分$DE $.</p>
<p>设$A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) , C ( 2 pt _2 ^2 , - 2 pt _2 ) $,注意到$AB : y - 2 pt _1 = \frac { 1  } { t _1 + t _2  } ( x - 2 pt _1 ^2 ) $,$AC : t - 2 pt _1 = \frac { 1  } { t _1 - t _2  } ( x - 2 pt _1 ^2 ) $.</p>
<p>可求得$D ( - 2 pt _1 t _2 , 0 ) , E ( 2 pt _1 t _2 , 0 ) $,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/591258689">https://zhuanlan.zhihu.com/p/591258689</a></p>
<h6><span id="定义">定义</span></h6><p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6><p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 + b ^2 $.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 - b ^2 $.</p>
<p>证明:其实注意到椭圆的证明中设$b $是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线$y ^2 = 2 px $,其蒙日圆方程为$x = - \frac { p  } { 2  } $.</p>
<p>有一说一,直线是半径无穷大的圆.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">高等代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-22 16:57:48 / 修改时间：17:16:06" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="抽象代数">抽象代数</span></h2><h3><span id="群">群</span></h3><h4><span id="定义">定义</span></h4><p>如果一个非空集合$G $上定义了一个二元运算$\circ : G \times G \to G $(不引起混淆的前提下,通常省略不写,例如$a \circ b $记作$ab $),满足:</p>
<ol>
<li><p>封闭性:$a \circ b \in G $.</p>
</li>
<li><p>结合律:$( a \circ b ) \circ c = a \circ ( b \circ c ) $.</p>
</li>
</ol>
<p>那么称作$G $是一个<strong>半群</strong>.</p>
<p>如果它还满足:</p>
<ol>
<li>存在幺元:$\exists e \in G $,使得$\forall a , e \circ a = a \circ e = a $.</li>
</ol>
<p>那么称作$G $是一个<strong>幺半群(monoid)</strong>.</p>
<p>如果它还满足:</p>
<ol>
<li>存在逆元:对任意的$a \in G $,存在$b \in G $,使得$a \circ b = e $.</li>
</ol>
<p>那么称作$G $是一个<strong>群</strong>.</p>
<p>如果它还满足:</p>
<ol>
<li>交换律:$\forall a , b , a \circ b = b \circ a $.</li>
</ol>
<p>那么称作$G $是一个<strong>交换群</strong>或<strong>阿贝尔群</strong>.特别地,一般而言在交换群里,我们的运算使用加法符号(有时也直接叫它加法群),这只是一个惯例.</p>
<p>下面主要研究群.</p>
<h4><span id="基本概念和事实">基本概念和事实</span></h4><p>定义群的<strong>阶</strong>为群中元素个数,记作$| G | $,如果$| G | &lt; \infty $称为<strong>有限群</strong>,否则为<strong>无限群</strong>.</p>
<ol>
<li>群的幺元唯一.</li>
</ol>
<p>设$e , e ‘ $都是幺元,有$e = ee ‘ = e ‘ $.</p>
<ol>
<li>群中任一元素的逆元唯一.</li>
</ol>
<p>设$b , b ‘ $都是$a $的逆元,有$b = bab ‘ = b ‘ $.</p>
<p>这同样说明了虽然群上的二元运算有可能不满足交换律,但是仍然不存在左逆和右逆这种东西(或者说无意义),它俩都等价于逆.</p>
<ol>
<li>群中有消去律,即$ax = ay \Leftrightarrow x = y $(左消去律),$xa = ya \Leftrightarrow x = y $(右消去律).</li>
</ol>
<p>显然.</p>
<p>于是可以定义乘方,并定义$a ^{ 0  } = e , a ^{ - 1  } = inv ( a ) $.一切的指数的常规操作在这里都可以照常进行.</p>
<h5><span id="example1">Example1</span></h5><p>证明:对于有限集合$G $和满足结合律的二元运算$\circ $来说,如果其有左右消去律,那么该二元运算在该集合上构成群.</p>
<p>考虑是有限集合,所以单射$f _a : b \rightarrow ab $同时也是满射,这意味着$\forall a , b \in G , xa = b $和$ay = b $一定有解,令$b = a $可以拿到幺元,令$b = e $可以拿到逆元,自然可以推出其是群.</p>
<h5><span id="example2">Example2</span></h5><p>设$G $是群,且$\exists a , b , aba ^{ - 1  } = b ^r $,求证:$a ^i ba ^{ - i  } = b ^{ r ^i  } $.</p>
<p>显然$b ^{ rk  } = ( b ^k ) ^r = ab ^k a ^{ - 1  } $,使用数学归纳,注意到$b ^{ r ^i  } = ab ^{ r ^{ i - 1  }  } a ^{ - 1  } = a ^i ba ^{ - i  } $.</p>
<h4><span id="子群">子群</span></h4><p>设$H $为群$G $的非空子集,如果$H $在$G $的运算下构成群,则称$H $为$G $的<strong>子群</strong>,记作$H \leq G $.</p>
<p><strong>子群的判定定理</strong>:</p>
<p>设$G $是群,$H \subseteq G , H \ne \emptyset $,下列命题等价:</p>
<ol>
<li><p>$H \leq G $.</p>
</li>
<li><p>$\forall a , b \in H , ab \in H , a ^{ - 1  } \in H $.</p>
</li>
<li><p>$\forall a , b \in H $,有$ab ^{ - 1  } \in H $.</p>
</li>
</ol>
<p>显然(1)$\Rightarrow $(2),(2)$\Rightarrow $(3),下面证明(3)$\Rightarrow $(1):</p>
<p>满足(3),有$e = aa ^{ - 1  } \in H $,于是存在幺元.有$ea ^{ - 1  } \in H $,于是存在逆元.因为$a ( b ^{ - 1  } ) ^{ - 1  } = ab \in H $,于是对运算封闭.同样的运算显然满足结合律.于是证毕.</p>
<p>如果$G $是群,$H , K \subseteq G $,类似闵可夫斯基和,我们定义$HK = \{ hk \mid h \in H , k \in K \} $.如果$H = \{ a \} $,可以写作$aK $.类似记$H ^{ - 1  } = \{ h ^{ - 1  } \mid h \in H \} $,注意$HH ^{ - 1  } \ne \{ e \} $.</p>
<p>再定义$H ^n = \{ h _1 h _2 \cdots h _n \mid h _1 , h _2 , \cdots , h _n \in H \} $.</p>
<p>于是子群的判定定理可以改写成:</p>
<p>下列命题等价:</p>
<ol>
<li><p>$H \leq G $.</p>
</li>
<li><p>$H ^2 \subseteq H \land H ^{ - 1  } \subseteq H $.</p>
</li>
<li><p>$HH ^{ - 1  } \subseteq H $.</p>
</li>
</ol>
<p>显然,任意群$G $,$G $和$\{ e \} $都是它的子群,我们称为<strong>平凡子群</strong>,如果$H \ne G $,称为<strong>真子群</strong>,记作$H &lt; G $.</p>
<p>若干个群的交仍然是子群,但是若干个群的并不一定.我们可以证明一下若干个群的交仍然是子群:考虑$h \in A , h \in B , w \in A , w \in B $,那么$hw ^{ - 1  } \in A \cap B $.</p>
<p>设集合$M \subseteq G $,则称$G $的所有包含$M $的子群的交为由$M $<strong>生成的子群</strong>,记作$\langle M \rangle $.这显然是包含$M $的最小的子群.</p>
<p>如果$\langle M \rangle = G $,则称$M $是$G $的一个<strong>生成系</strong>.可由有限多个元素生成的群叫做<strong>有限生成群</strong>,若$\exists M , | M | = 1 , \langle M \rangle = G $,则称$G $是<strong>循环群</strong>.</p>
<p>对于$a \in G $,我们称$o ( a ) = | \langle a \rangle | $为$a $的<strong>阶</strong>,不难发现$o ( a ) $是满足$a ^n = e $的最小的正整数$n $.如果这样的$n $不存在,记$o ( a ) = \infty $.群中所有元素的阶的$lcm $称作群的<strong>方次数</strong>(如果不存在,则记为$\infty $),记作$\exp ( G ) $.</p>
<p>另一个不平凡的例子是群$G $的<strong>中心</strong>定义为$Z _G = \{ z \in G \mid \forall g \in G , zg = gz \} $,这显然也是一个子群.</p>
<h5><span id="example1">Example1</span></h5><p>证明不存在恰有两个二阶元素的群.</p>
<p>不妨设这两个二阶元素分别为$a \ne b , a , b \ne e $,则注意到$aba $也是一个二阶元素.</p>
<p>如果$aba = a $,则$ba = e $,说明$a = b $.</p>
<p>如果$aba = b $,则$ba = ab $,说明$ab $是第三个二阶元素.</p>
<p>类似还可以证明如果$\exp ( G ) = 2 $,则$G $一定是交换群(一定满足$\forall a , b \in G , ab = ba $).原因是假设$ab = c $,$ba = d $,则$cd = e $.</p>
<h5><span id="example2">Example2</span></h5><p>对于一个群$G $,如果$\forall a , b \in G $,$\exists i \in \mathbb { N _+  } , ( ab ) ^i = a ^i b ^i , ( ab ) ^{ i + 1  } = a ^{ i + 1  } b ^{ i + 1  } , ( ab ) ^{ i + 2  } = a ^{ i + 2  } b ^{ i + 2  } $,求证其是交换群.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( ab ) ^{ i + 1  } & = a ^{ i + 1  } b ^{ i + 1  } & = a ( ab ) ^i b \\
( ab ) ^i & = a ( ab ) ^i a ^{ - 1  } 
\end{aligned}</script><p>同理有$( ab ) ^{ i + 1  } = a ( ab ) ^{ i + 1  } a ^{ - 1  } $.两式合并一下有$a ( ab ) ^i a ^{ - 1  } ab = a ( ab ) ^{ i + 1  } a ^{ - 1  } \Rightarrow b = aba ^{ - 1  } $.</p>
<h5><span id="example3">Example3</span></h5><p>证明若$\exp ( G ) \in \text { even  } $,则存在阶为$2 $的元素.</p>
<p>一定存在一个阶为$2 k $的元素$a $,显然$o ( a ^k ) = 2 $.</p>
<h5><span id="example4">Example4</span></h5><p>当$n &gt; 2 $的时候,证明在有限群$G $中阶为$n $的元素个数是偶数.</p>
<p>显然构造双射$a \mapsto a ^{ n - 1  } $即可.</p>
<h5><span id="example5">Example5</span></h5><p>对于群$G $,证明$o ( ab ) = o ( ba ) $.</p>
<p>考虑反证,不妨设$o ( ab ) = n &lt; o ( ba ) = m $.</p>
<p>则$e = ( ba ) ^m = ( ba ) ^{ m - n  } b ( ab ) ^{ n - 1  } a = ( ba ) ^{ m - n  } $,说明$o ( ba ) \leq m - n &lt; m $,不符题意.</p>
<h5><span id="example6">Example6</span></h5><p>证明:如果$H , K \leq G $,那么$HK \leq G \Leftrightarrow HK = KH $.</p>
<p>如果$HK = KH $,那么$HK \leq G \Leftrightarrow HK ( HK ) ^{ - 1  } = HK $.考虑:</p>
<script type="math/tex; mode=display">
HK ( HK ) ^{ - 1  } = HKK ^{ - 1  } H ^{ - 1  } = HKH ^{ - 1  } = KHH ^{ - 1  } = HK</script><p>如果$HK \leq G $,那么$HK = ( HK ) ^{ - 1  } = K ^{ - 1  } H ^{ - 1  } = KH $.</p>
<h5><span id="example7">Example7</span></h5><p>设$G $是交换群,证明$G $中的全体有限阶元素构成$G $的一个子群.</p>
<p>等价于证明如果$a , b $的阶有限,那么$ab ^{ - 1  } $的阶有限.这对交换群来说是显然的.</p>
<h5><span id="example8">Example8</span></h5><p>如果$G $只有有限多个子群,证明$G $是有限群.</p>
<p>考虑若其有无限阶元素$a $,则$\langle a \rangle $已经有无限个子群(取幂次为$k $的倍数).反之则每个元素都可以生成一个循环群,也有无限个子群.</p>
<h4><span id="同态和同构">同态和同构</span></h4><p>考虑在两个群$G $和$G _1 $之间构造映射$\varphi $,如果$\varphi $保持群运算,即对于所有的$a , b \in G $,都有$\varphi ( ab ) = \varphi ( a ) \varphi ( b ) $,则称其为由$G $到$G _1 $的一个<strong>群同态</strong>.如果同时$\varphi $又是单(满)射,则称其为<strong>单(满)同态</strong>,又单又满的同态称为<strong>同构</strong>.如果存在一个映射$\varphi $,使得$G , G _1 $同构,则称这两个群<strong>同构</strong>,记作$G \cong G _1 $.</p>
<p>容易见到,同构等价于两方都有$f : G \to G _1 $和$g : G _1 \to G $,并且二者的合成$fg = gf = \text { id  } $.而且同构的合成仍是同构.</p>
<p>我们以$End ( G ) $表示$G $的全体<strong>自同态</strong>组成的集合,$Aut ( G ) $表示全体<strong>自同构</strong>组成的集合.不难发现,$End ( G ) $组成一个幺半群,而$Aut ( G ) $组成一个群.</p>
<p>我们可以搞一个伴随映射:$G \to Aut ( G ) , g \mapsto Ad _g $,其中$Ad _g ( x ) = gxg ^{ - 1  } $.容易见到$Ad _g = id $的充要条件是$g \in Z ( G ) $也就是群的中心.</p>
<p>群同态$\varphi : G \rightarrow G _1 $把$G $的幺元映为$G _1 $的幺元.原因是:</p>
<script type="math/tex; mode=display">
\varphi ( e ) ^2 = \varphi ( e ^2 ) = \varphi ( e ) e _1</script><p>然而应当说明,这里保持单位元对幺半群未必成立,因此如果要将群同态的定义挪到幺半群上,需要额外添加$\varphi ( e ) = e _1 $的条件.</p>
<p>我们还有:</p>
<script type="math/tex; mode=display">
e _1 = \varphi ( e ) = \varphi ( aa ^{ - 1  } ) = \varphi ( a ) \varphi ( a ^{ - 1  } )</script><p>所以$\varphi ( a ^{ - 1  } ) = ( \varphi ( a ) ) ^{ - 1  } $.</p>
<p>我们将$\varphi ( G ) $称为$G $的<strong>像</strong>,记为$\text { im  }  \varphi $.又将$e _1 $的原像的集合称为$\varphi $的<strong>核</strong>,记为$\ker  \varphi $.</p>
<p>注意到$\varphi $不是单射等价于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Leftrightarrow \exists a , b \in G , a \ne b , \varphi ( a ) & = \varphi ( b ) \\
\Leftrightarrow \varphi ( ab ^{ - 1  } ) & = \varphi ( a ) \varphi ( b ) ^{ - 1  } & = e _1 \\
\Leftrightarrow \ker \ \varphi \ne \{ e \} 
\end{aligned}</script><h4><span id="群的实例">群的实例</span></h4><h5><span id="全变换群对称群与交错群">全变换群,对称群与交错群</span></h5><p>设$M $是一个非空集合,$M $到自身的双射的全体对于映射的复合构成一个群,称作$M $的<strong>全变换群</strong>,记作$S ( M ) $.</p>
<p>设$M $是含有$n $个元素的集合,$M $的全变换群$S ( M ) $称为<strong>n级对称群</strong>,记作$S _n $.不失一般性,我们可以设$M = \{ 1 , 2 , \cdots , n \} $,$S _n $的元素称为<strong>n元置换</strong>,任一置换可以用列表的方法表示,即如果$\sigma $是一个映射,我们将其写作:</p>
<script type="math/tex; mode=display">
\sigma = \left ( \begin{array}
{ c  } 1 & 2 & \cdots & n \\
\sigma _1 & \sigma _2 & \cdots & \sigma _n 
\end{array} \right )</script><p>显然$| S _n | = n ! $.</p>
<p>设$\sigma \in S _n $,$\{ i _1 , i _2 , \cdots , i _t \} \subseteq \{ 1 , 2 , \cdots , n \} $,有$\sigma ( i _t ) = i _1 , \forall 1 \leq k &lt; t , \sigma ( i _k ) = i _{ k + 1  } $,我们称这样的置换是对于$\{ i _1 , i _2 , \cdots , i _t \} $的<strong>轮换</strong>,记作$\left ( \begin{array}{ c  } i _1 &amp; i _2 &amp; \cdots &amp; i _t \end{array} \right ) $,$t $为轮换的<strong>长度</strong>,长度为$2 $的轮换称作<strong>对换</strong>.显然,一个置换可以被分解成若干两两无交轮换(注意到如果两个轮换无交,则它们可交换)的乘积.又显然,一个轮换可以被分解成若干对换的乘积,原因是总有:</p>
<script type="math/tex; mode=display">
( a _1 , \cdots , a _l ) = ( a _1 , a _l ) ( a _1 , \cdots , a _{ l - 1  } )</script><p>另外轮换的性质给出任何一个置换$\sigma $的$o ( \sigma ) $就是其拆出的所有轮换的$\text { lcm  } $.</p>
<p>根据逆序对相关,我们知道一个置换的逆序对数量的奇偶性等于其分解成的对换的数量.我们将逆序对数量是奇数的置换称为<strong>奇置换</strong>,是偶数的称之为<strong>偶置换</strong>,$S _n $中的所有偶置换也构成一个群,称之为<strong>n级交错群</strong>,记为$A _n $.$A _n $实际上是$S _n $的一个子群.</p>
<h5><span id="一般线性群">一般线性群</span></h5><p>对于定义在域$F $上的线性空间$V $,它上面的所有自同构构成一个<strong>一般线性群</strong>$GL ( V ) = \{ T \in \text { End  } ( V ) \mid \det T \ne 0 \} $.特别地,当$\dim V &lt; \infty $的时候,其有一个子群<strong>特殊线性群</strong>$SL ( V ) = \{ T \in \text { End  } ( V ) \mid \det T = 1 \} $.</p>
<p>在配套的内积空间上还可以把正交变换组成的群一块拿到,称为<strong>正交群</strong>或者<strong>酉群</strong>$O ( V ) $,还可以定义$SO ( V ) = O ( V ) \cap SL ( V ) $.</p>
<p>当然上面的版本都可以用矩阵来表示,这里略去不表.然而对于矩阵来代替上面的情形,我们疑似需要引入群同构的概念,这会在下面提出.</p>
<h5><span id="克莱因四元群">克莱因四元群</span></h5><p>取$V = \{ \text { id  } , \sigma , \tau , \sigma \tau \} $,其中:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma & = \left ( \begin{matrix}
1 & 2 & 3 & 4 \\
2 & 1 & 4 & 3 
\end{matrix} \right ) \\
\tau & = \left ( \begin{matrix}
1 & 2 & 3 & 4 \\
3 & 4 & 1 & 2 
\end{matrix} \right ) \\
\sigma \tau & = \tau \sigma & = \left ( \begin{matrix}
1 & 2 & 3 & 4 \\
4 & 3 & 2 & 1 
\end{matrix} \right ) \\

\end{aligned}</script><p>见到这确实是一个群,而且任何一个元素的逆元都是它本身,而且两个不同的非$1 $元的乘积会得到另一个非$1 $元.</p>
<p>克莱因群的实例非常多,例如$\{ 1 , 3 , 5 , 7 \} $在$\mod 8 $意义下对乘法构成克莱因群,$\{ 0 , 1 , 2 , 3 \} $对异或构成克莱因群.以及:</p>
<script type="math/tex; mode=display">
\left \{ \begin{bmatrix}
1 & 0 \\
0 & 1 
\end{bmatrix} , \begin{bmatrix}
1 & 0 \\
0 & - 1 
\end{bmatrix} , \begin{bmatrix}
- 1 & 0 \\
0 & 1 
\end{bmatrix} , \begin{bmatrix}
- 1 & 0 \\
0 & - 1 
\end{bmatrix} \right \}</script><p>对矩阵乘法也构成群.</p>
<h5><span id="循环群">循环群</span></h5><p>如果对于一个群$G $,它可以由其中的某个元素$\sigma $生成,记作$G = \langle \sigma \rangle $,当$\forall g \in G , \exists k \in \mathbb { Z  } , g = \sigma ^k $.</p>
<p>显然$\mathbb { Z  } / n \mathbb { Z  } $对加法就是一个循环群,其中$\sigma = 1 + n \mathbb { Z  } $.</p>
<p>特别地,容易见到对于任意循环群,如果$| G | = \infty $,则$G \cong \mathbb { Z  } $;反之则$G \cong \mathbb { Z  } / | G | \mathbb { Z  } $.</p>
<h4><span id="相反群">相反群</span></h4><p>群中的左右区别如此之大,是否说对于任何一个左的版本都存在一个与之对应的右的版本呢?</p>
<p>留神到我们其实可以定义<strong>相反群</strong>$G ^{ op  } = ( G , \odot ) $,其中的运算满足$g \odot g ‘ = g ‘ g $,也就是在$G $中使得乘法倒置.容易检验其保留了幺元和逆元等性质,而且$( G ^{ op  } ) ^{ op  } = G $.另外只需观察$G \to G ^{ op  } , g \mapsto g ^{ - 1  } $就可构造双射.有时干脆将相反群记作$G ^{ - 1  } $.</p>
<h6><span id="example1">Example1</span></h6><p>证明:群$G $是交换群当且仅当$x \mapsto x ^{ - 1  } $是群同构.</p>
<p>显然是单射且是双射,只需证明是群同态即可.此时就需要证明$y ^{ - 1  } x ^{ - 1  } = ( xy ) ^{ - 1  } = ( yx ) ^{ - 1  } $,那就搞定了.</p>
<h4><span id="陪集">陪集</span></h4><p>设$G $是一个群,$H \leq G $,定义等价关系$a \sim b \Leftrightarrow \exists h \in H , a = bh $,容易检查其满足等价类的三条性质.不难发现对于元素$a $,其所在的等价类就是$aH $.类似可以定义$Ha $.我们定义形如$aH $的子集为$H $的一个<strong>右陪集</strong>,形如$Ha $的称作<strong>左陪集</strong>.由于左陪集是一个等价类,因此会将原集合划分为若干个等价类.这种划分用商集刻画,记作$G / H $.需要强调的是这个符号需要区分左右,有的人会盗用反斜杠来表述此关系,但这种符号容易与差集相混淆.因此,我们在下面会直接不加区分(或者说根据上下文判断)来一律统一使用$G / H $.如若的确需要区分,则采用$( G / H ) _L , ( G / H ) _R $的写法.</p>
<p>一个自然的想法是$G / H $是否构成一个群.先看取逆,容易发现$( aH ) ^{ - 1  } = Ha ^{ - 1  } $,这给出左陪集和右陪集之间一个自然的同构:</p>
<script type="math/tex; mode=display">
Hg \mapsto g ^{ - 1  } H = ( Hg ) ^{ - 1  }</script><p>所以不同的左右陪集个数相等.</p>
<p>我们将$H $的不同左陪集的个数(不一定有限)称为$H $在$G $中的<strong>指数</strong>,记为$| G : H | $,用消去律注意到$| H | = | aH | = | Ha | $,因此其实右陪集个数也是这个指数.既然是等价类,就完成了对原群的一个划分,而且容易见到每个划出的等价类大小都是$| H | $.</p>
<p>对于有限群,这引出重要的<strong>拉格朗日定理</strong>:</p>
<script type="math/tex; mode=display">
| G | = | G : H | \times | H |</script><p>对于每一个陪集$C \in G / H $,我们可以选定其一个代表元$x _c $使得$x _C H = C $.考虑映射$H \times ( G / H ) \to G , ( h , C ) \mapsto x _C h $.下面证明这的确是个同构.</p>
<p>由于这里在映射前就钦定了代表元(需要使用选择公理),所以无需验证良定性.</p>
<p>接下来检查其单射,由于$x _C h \in C $,所以如果$x _{ C ‘  } h ‘ = x _C h $,意味着$C ‘ \cap C \ne \emptyset $,这是不符合的,因为陪集肯定两两不交.</p>
<p>而满射性只需要找到自己所在的那个等价类即可.</p>
<p>该定理有以下推论(以下默认有限群):</p>
<ol>
<li><p>任何一个子群的大小都一定整除原群大小.</p>
</li>
<li><p>若$H , K \subseteq G $,如果$| H | , | K | $的大小互素,则$H \cap K = \{ 1 \} $</p>
</li>
<li><p>$\forall \sigma \in G , o ( \sigma ) \mid ( | G | ) $.</p>
</li>
<li><p>$\forall \sigma \in G , \sigma ^{ | G |  } = e $.</p>
</li>
<li><p>如果$p = | G | \in prime $,则$G $是一个循环群.</p>
</li>
<li><p>$K \leq H \leq G $,则$[ G : K ] = [ G : H ] \times [ H : K ] $.</p>
</li>
</ol>
<p>(1)显然.</p>
<p>(2)的原因是$H \cap K $一定是一个子群,则它的大小要整除$\gcd ( | H | , | K | ) = 1 $.</p>
<p>(3)是因为$\langle \sigma \rangle \leq G $,而$o ( \sigma ) = | \langle \sigma \rangle | $.</p>
<p>(4)根据(3)显然.这其实就是费马小定理和欧拉定理在群上的体现.</p>
<p>(5)是因为任取一个$\sigma \ne 1 $,则$1 \ne o ( \sigma ) | p $,所以$o ( \sigma ) = p $,这是循环群.</p>
<p>(6)的话仍是取代表元,不妨设$C \in G / H $的代表元是$x _C $,$D \in H / K $的代表元是$y _D $.则$G = \bigsqcup x _C H = \bigsqcup x _C y _D K $,容易检验两边是一一对应的.它的另一个证明策略是取道第一同构定理.</p>
<h4><span id="群作用">群作用</span></h4><p>我们早应看出群往往是由一类双射组成的集合,而并非应该将其看作单一运算的环.因此,考虑群在一个集合上的作用是很有意义的.</p>
<p>我们称群$G $的一个<strong>左作用</strong>是$\varphi : G \times X \to X $,使得:</p>
<ol>
<li><p>$\varphi ( 1 _G , x ) = x $.</p>
</li>
<li><p>$\varphi ( g , \varphi ( h , x ) ) = \varphi ( gh , x ) $.</p>
</li>
</ol>
<p>这种作用看似隔了一层,只是多引入了符号,而并非将$G $与$X $直接联系起来.然而回忆到柯里化过程,上述作用也等价于$G \to ( X \to X ) $,设这个映射是$\Phi : G \to \mathrm { End  } ( X ) $,容易见到上面两条性质等价于:</p>
<ol>
<li><p>$\Phi ( 1 _G ) = \text { id  } _X $.</p>
</li>
<li><p>$\Phi ( g _1 g _2 ) = \Phi ( g _1 ) \Phi ( g _2 ) $.</p>
</li>
</ol>
<p>容易见到$\Phi $是群同态.</p>
<p>当然同理可以定义<strong>右作用</strong>.</p>
<p>对于左作用,我们定义$x $的$G $<strong>轨道</strong>是$Gx = \{ gx | g \in G \} \subseteq X $.我们还可以定义其<strong>稳定化子群</strong>是$\mathrm { Stab  } _G ( x ) = \{ g \in G | gx = x \} $,容易检验这的确是一个子群,原因是封闭性和逆存在都满足,而且还满足$\mathrm { Stab  } _G ( gx ) = g \mathrm { Stab  } _G ( x ) g ^{ - 1  } $.因此一个轨道中的点的稳定化子群大小相等.</p>
<p>定义$X $的$G $<strong>不动点</strong>是$X ^G = \{ x \in X | \forall g \in G , gx = x \} $,容易见到$X ^G $中的每一个点都自己构成一个轨道,还可以对单个$g $定义不动点集合$X ^g = \{ x \in X | gx = x \} $.对于$\forall g \in G $.还可以引入以下定义:</p>
<ol>
<li><p>如果$\forall x \in X , gx = x $当且仅当$g = 1 _G $,或说$\bigcap _{ x \in X  } \mathrm { Stab  } _{ G  } ( x ) = \{ 1 _G \} $,则称这个作用是<strong>忠实的</strong>.此时还会满足$\Phi ( g ) = id _X \Leftrightarrow g = 1 _G $,也就是上述柯里化是单射.</p>
</li>
<li><p>若$X $只有一个轨道,换言之$\forall x , y \in X , \exists g \in G , y = gx $.则称此群作用<strong>传递</strong>.</p>
</li>
<li><p>若$\forall x \in X $,$\mathrm { Stab  } _G ( x ) = { 1 _G  } $,则称此群作用<strong>自由</strong>.自由性严格强于忠实性.</p>
</li>
</ol>
<p>对于$x , y \in X $,我们定义等价关系$x \sim y $当且仅当$y \in Gx $.容易见到其满足传递性,自反性,对称性.在此等价关系下的商集也就是分解出的所有轨道,称此为轨道分解,或者盗用陪集符号写作$X / G $.</p>
<h5><span id="cayley定理">Cayley定理</span></h5><p>由上面可以见到,任何一个$G $都可以用柯里化表为一个集合上的变换.并且如果群作用是忠实的,那么这种表示事实上总是单射.然而$G $作用于自己本身的时候因为消去律一定能导出自由性.这自然是一个置换.</p>
<p>Cayley定理的一个很重要的作用是理解轨道分解.我们早就用图论手段理解过置换可以拆解成轮换的性质.如今我们可以用群论的手段去理解.对于任何一个置换$\sigma $,考虑其作用在$X = \{ 1 , \cdots , n \} $上.考虑取一个循环群$G = \langle \sigma \rangle $,$G $作用在$X $上给出了$X $的一个轨道分解.容易见到这里的轨道分解就是给出了若干个轮换.由轨道分解的唯一性,立刻见到轮换分解的唯一性.</p>
<h5><span id="burnside引理">Burnside引理</span></h5><p>下面选定$x \in X $考虑映射$G \to Gx , g \mapsto gx $.考虑取$H = \text { Stab  } _G ( x ) $,现在考虑有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
gx & = g ' x \\
\Leftrightarrow g ^{ - 1  } g ' x & = x \\
\Leftrightarrow g ^{ - 1  } g ' \in H \\
\Leftrightarrow g ' \in gH \\
\Leftrightarrow g ' H & = gH \\

\end{aligned}</script><p>所以我们可以搞一个同构映射$G / H \to Gx $.注意这里未必是群同构,原因是$H $未必是正规子群,但$G / H $这个右陪集总可以定义.对于有限集合的情况,回忆到$X $可以进行轨道分解,设其不同的轨道分别是$Gx _1 , \cdots , Gx _m $(回忆到$m = | X / G | $),并且对应的稳定化子群分别是$H _1 , \cdots , H _m $,上述命题给出:</p>
<script type="math/tex; mode=display">
| X | = \sum | Gx _k | = \sum [ G : H _k ]</script><p>另一个结论是$| X / G | \cdot | G | = \sum _{ g \in G  } | X ^g | $,这个结论是染色计数的基础.</p>
<p>为了证明上面这个结论,我们下面证明把$X $分解为若干轨道后,对于每个轨道$X _i $都有$\sum _{ g \in G  } | X _i ^g | = | G | $,由于轨道之间互不干扰,下面只需证明$X $是传递性的单个轨道的情况即可,回忆到单个轨道上的稳定化子群大小均相等,任取$x _0 \in X $,由于此时只着眼于单个轨道,因此根据上述结论$| X | = [ G : \mathrm { Stab  } _G ( x _0 ) ] $.此时:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ g \in G  } | X ^g | & = \sum _{ x \in X  } | \mathrm { Stab  } _G ( x ) | \\
& = | X | \cdot | \mathrm { Stab  } _G ( x _0 ) | \\
& = [ G : \mathrm { Stab  } _G ( x _0 ) ] \cdot | \mathrm { Stab  } _G ( x _0 ) | \\
& = | G | 
\end{aligned}</script><p>这就搞定.</p>
<h5><span id="p-群">$p$-群</span></h5><p>设$p \in prime $,如果$| G | = p ^m $(当$m = 0 $的时候称其平凡),则称$G $为$p $-<strong>群</strong>.对此我们有以下结论:</p>
<ol>
<li><p>$| X | \equiv | X ^G | \pmod { p  } $.</p>
</li>
<li><p>如果$| G | $非平凡,则$Z _G \ne \{ 1 \} $.进一步地,$p \mid ( | Z _G | ) $.</p>
</li>
</ol>
<p>(1)的原因是轨道分解给出:</p>
<script type="math/tex; mode=display">
| X | = | X ^G | + \sum _{ H _i \ne G  } [ G : H _i ]</script><p>然而拉格朗日定理给出$| H _i | $总是$| G | $的因子,也就是说$\frac { | G |  } { | H _i |  } = p ^k $,于是证毕.</p>
<p>(2)的证明,考虑映射$a : G \times G \to G : a ( g , x ) = Ad _g ( x ) = gxg ^{ - 1  } $,这本身是$G $对自身的一个左作用.而容易见到此作用下的不动点集就是$Z _G $.而$| Z _G | \equiv | G | \equiv 0 \pmod { p  } $,于是证毕.</p>
<p>我们知道轨道分解事实上给出了一种划分集合的策略,而这里的映射其实也给出了一种划分集合的策略:按<strong>共轭类</strong>划分.换言之,我们设$a \sim b $当且仅当$\exists g \in G , a = gbg ^{ - 1  } $,容易见到其满足等价关系的三条性质.因此我们得到一个共轭类的大小总是整除群的大小,以及:</p>
<script type="math/tex; mode=display">
| G | = | Z _G | + \sum _{ H _i \ne G  } [ G : H _i ]</script><p>这个被称为<strong>类方程</strong>.</p>
<h6><span id="example1">Example1</span></h6><p>求证:阶为$p ^2 $的有限群都是交换的.</p>
<p>考虑其中心$Z _G $,由于该群非平凡,所以$| Z _G | &gt; 1 $,所以$| Z _G | = p $或$| Z _G | = p ^2 $,后者显然已经证毕.</p>
<p>如果能取出一个元素$c $使得$\langle c \rangle = G $则显然证毕,下面假设所有的非平凡循环子群的阶都是$p $.</p>
<p>取$a \in Z _G , a \ne 1 $,则$Z _G = \langle a \rangle $.任取$b \in G \setminus Z _G $,考虑$\langle b \rangle \cap Z _G = \{ 1 \} $,原因是如果$\exists i , j , a ^i = b ^j $,则取$j $在$\bmod p $下的逆元$k $,有$a ^{ ik  } = b $,这就不符.</p>
<p>于是有$G / Z _G \cong \langle b \rangle $,立刻证毕.</p>
<h4><span id="正规子群">正规子群</span></h4><p>设$G $是一个群,$H \leq G $,如果$\forall a \in G , aH = Ha $或回忆到商群的概念只需检验$a ^{ - 1  } Ha \subseteq H $,我们称$H $是$G $的<strong>正规子群</strong>,记作$H \trianglelefteq G $.当一个子群是正规的时候,它的左右陪集不必区分.</p>
<p>显然,$G $和$\{ e \} $都是$G $的正规子群,如果$G $除此之外没有别的正规子群,称其为<strong>单群</strong>.</p>
<p>容易发现$Z _G \trianglelefteq G $.此外,如果$N \trianglelefteq G $,而且$H \leq G $,则$N \cap H \trianglelefteq H $,只需套用定义即可发现.</p>
<p>于此还可以引入两个定义,假设$K \leq G $:</p>
<ol>
<li><p>定义$K $的<strong>中心化子</strong>:$Z _G ( K ) = \{ g \in G | \forall k \in K , gkg ^{ - 1  } = k \} $.</p>
</li>
<li><p>定义$K $的<strong>正规化子</strong>:$N _G ( K ) = \{ g \in G | gKg ^{ - 1  } = K \} $.</p>
</li>
</ol>
<p>显然$K \trianglelefteq N _G ( K ) \geq Z _G ( K ) $.</p>
<h5><span id="正规子群的判定定理">正规子群的判定定理</span></h5><p>当$H \leq G $时,下列命题等价:</p>
<ol>
<li><p>$H \trianglelefteq G $.</p>
</li>
<li><p>$\forall a , b \in G , \exists c \in G , ( aH ) ( bH ) = cH $.</p>
</li>
<li><p>$\forall a \in G , a ^{ - 1  } Ha = H $.</p>
</li>
<li><p>$\forall a \in G , h \in H , a ^{ - 1  } ha \in H $.</p>
</li>
</ol>
<p>先证明(2)$\Rightarrow $(1):</p>
<p>由于$a ^2 H \subseteq ( aH ) ^2 $,$a ^2 \subseteq ( aH ) ^2 $并且$( aH ) ^2 = cH $是左陪集,那么由于左陪集是等价类,所以$a ^2 H = ( aH ) ^2 $.两边同时乘以$a ^{ - 1  } $,有$Ha \subseteq HaH = aH $.再次两边左右乘以$a ^{ - 1  } $,得到$a ^{ - 1  } H \subseteq Ha ^{ - 1  } , \forall a \in G $,也就证毕.</p>
<p>再证明(1)$\Rightarrow $(2):</p>
<script type="math/tex; mode=display">
( aH ) ( bH ) = aHbH = a ( bH ) H = abH</script><p>这里还可以进一步说明如果这里干脆在正规子群的陪集上定义二元运算$( aH , bH ) \to abH $后其陪集构成群.首先我们要检验良定性质.注意到如果$a ‘ = au , b ‘ = bv $,其中$u , v \in H $,则:</p>
<script type="math/tex; mode=display">
a ' b ' H = aubvH = abb ^{ - 1  } ubvH = abH</script><p>原因是$b ^{ - 1  } ub \in H , v \in H $.</p>
<p>逆元只需要对$( aH ) ^{ - 1  } = a ^{ - 1  } H $即可.至于结合律也可以用上述性质转化,这样就搞定了.</p>
<p>剩下的部分,(1)$\Leftrightarrow $(3),(3)$\Rightarrow $(4)都显然,考虑证明(4)$\Rightarrow $(3).</p>
<p>(4)显然等价于$ha \in aH $,于是有$Ha \subseteq aH $.而又等价于$a ^{ - 1  } h \in Ha ^{ - 1  } $,于是类似证毕.</p>
<p>设$G $是群,$H \trianglelefteq G $,则$H $的陪集在乘法下构成群,这个群称为$G $关于$H $的<strong>商群</strong>,记作$G / H $.</p>
<p>考虑封闭律:$( aH ) ( bH ) = a ( bH ) H = abH $,又显然满足结合律.又有$\forall aH \in G / H , eH ( aH ) = ( aH ) H = aH $,于是$H $是幺元.同样知道$a ^{ - 1  } H = ( aH ) ^{ - 1  } $,于是存在逆元.</p>
<h6><span id="example1">Example1</span></h6><p>证明:如果$[ G : H ] = 2 $的话则一定有$H \trianglelefteq G $.</p>
<p>原因是其可以分解成两个陪集,而其中一个陪集自动是$H $本身,所以另一个陪集也同样不分左右.</p>
<h6><span id="example2">Example2</span></h6><p>求证:如果$G / Z _G $是循环群,则$G $交换.</p>
<p>不妨假设$G / Z _G = \{ Z _G , aZ _G , a ^2 Z _G , \cdots \} $.</p>
<p>对于任意$b , c \in G $,都存在一组$i , j , g _1 , g _2 $满足$i , j \in \mathbb { Z  } $,$g _1 , g _2 \in Z _G $有$b = a ^i g _1 , c = a ^j g _2 $,显然$bc = cb $.</p>
<h5><span id="正规子群与同态">正规子群与同态</span></h5><p>事实上有以下命题:</p>
<ol>
<li><p>$\text { im  }  \varphi \leq G _1 $.</p>
</li>
<li><p>$\text { ker  }  \varphi \trianglelefteq G $.</p>
</li>
</ol>
<p>先看(1),考虑首先$e _1 \in \text { im  }  \varphi $,所以其不为空.其次对于任意$a _1 , b _1 \in \text { im  }  \varphi $,$\exists a , b \in G $,使得$\varphi ( a ) = a _1 , \varphi ( b ) = b _1 $.于是:</p>
<script type="math/tex; mode=display">
a _1 b _1 ^{ - 1  } = \varphi ( a ) \varphi ( b ^{ - 1  } ) = \varphi ( ab ^{ - 1  } ) \in \text { im  } \ \varphi</script><p>再看(2),同上可知$\text { ker  }  \varphi \ne \emptyset $,对于任意的$a , b \in \text { ker  }  \varphi $,$\varphi ( ab ^{ - 1  } ) = \varphi ( a ) \varphi ( b ) ^{ - 1  } = e _1 $,所以$ab ^{ - 1  } \in \text { ker  }  \varphi $,说明$\text { ker  }  \varphi \leq G $.而$\forall g \in G $,$\varphi ( gag ^{ - 1  } ) = \varphi ( g ) e _1 \varphi ( g ) ^{ - 1  } = e _1 $,所以$gag ^{ - 1  } \in \text { ker  }  \varphi $.</p>
<p>我们也可以说正规子群均可以成为某个映射的$\ker $,方法是构造映射$\pi : G \to G / N , g \mapsto gN $.容易检验这的确是一个群同态.</p>
<p>另外如果$f $是同构,那么$f ^{ - 1  } $也是同态,原因是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( f ^{ - 1  } ( x ) f ^{ - 1  } ( y ) ) & = f ( f ^{ - 1  } ( x ) ) f ( f ^{ - 1  } ( y ) ) & = xy & = f ( f ^{ - 1  } ( xy ) ) \\
f ^{ - 1  } ( x ) f ^{ - 1  } ( y ) & = f ^{ - 1  } ( xy ) 
\end{aligned}</script><p>以及如果$f , g $都是同态,那么$f \circ g $也是同态.</p>
<p>更进一步地,我们实际上可以在这里画交换图表,对于任何一个群同态$f : G \to G ‘ $,取$\pi : G \to G / \ker f $,我们存在唯一的$\bar { f  } $使得$f = \bar { f  } \circ \pi $,或言使得下述交换图表成立:</p>
<script type="math/tex; mode=display">
\xymatrix { G \ar [r ] ^f \ar [d ] _\pi & G ' \\
G / \ker f \ar [ru ] _{ \bar { f  }  } & \\
 }</script><p>这被称为商群的泛性质.事实上这也很一眼,原因是要满足$\forall x \in G , \bar { f  } ( xN ) = f ( x ) $,这其实也就定义了$\bar { f  } $,而存在性只需要堆堆语言就行.</p>
<p>进一步地,如果$f : G \to G ‘ $,而$N \trianglelefteq G , N ‘ \trianglelefteq G ‘ $,并且$f ( N ) \subseteq N ‘ $,则存在唯一的映射$\bar { f  } : G / N \to G ‘ / N ‘ $使得我们可以搞定下面这个图表的交换性:</p>
<script type="math/tex; mode=display">
\xymatrix { G \ar [r ] ^f \ar [d ] & G ' \ar [d ] \\
G / N \ar [r ] _{ \bar { f  }  } & G ' / N '  }</script><h5><span id="同态基本定理">同态基本定理</span></h5><p>设$\varphi : G \rightarrow G _1 $是群同态,则$G / \text { ker  }  \varphi \cong \text { im  }  \varphi $.</p>
<p>不妨先设$H = \text { ker  }  \varphi $.我们定义映射$\psi : G / H \rightarrow \text { im  }  \varphi $,满足$\psi ( aH ) = \varphi ( a ) $.</p>
<p>不过首先要判断$\psi $是不是良定义,也就是当$aH = bH $的时候,我们要判断$\varphi ( a ) $是否等于$\varphi ( b ) $.若$aH = bH $,说明$\exists h \in H , a = bh $,那么$\psi ( aH ) = \varphi ( a ) = \varphi ( bh ) = \varphi ( b ) \varphi ( h ) = \varphi ( b ) $.</p>
<p>然后还要证明其是群同态,注意到$\psi ( ( aH ) ( bH ) ) = \psi ( abH ) = \varphi ( ab ) = \varphi ( a ) \varphi ( b ) = \psi ( aH ) \psi ( bH ) $.</p>
<p>接下来要证明它是单射,显然只有$\psi ( H ) = e _1 $,$\text { ker  }  \psi = \{ H \} $.</p>
<p>接下来要证明它是满射,$\forall g \in \text { im  }  \varphi $,$\exists a , \varphi ( a ) = g $,则$\psi ( aH ) = g $.</p>
<p>这样就证明了同态基本定理.</p>
<p>当$\varphi $是满射的时候$G _1 = \text { im  }  \varphi $,所以此时有$G / \text { ker  }  \varphi \cong G _1 $.</p>
<h5><span id="第一同构定理">第一同构定理</span></h5><p>我们定义$H \trianglelefteq G $时,定义$\pi : G \rightarrow G / H , a \mapsto aH $.显然其是群同态,定义其为由$G $到$G / H $的<strong>典范同态</strong>.</p>
<p>那么我们有第一同构定理,即对于一个$G $的一个正规子群$H $,在典范同态$\pi : G \rightarrow G / H $下,我们有:</p>
<ol>
<li><p>$G $的包含$H $的子群和$G / H $的子群在$\pi $下是群同构.</p>
</li>
<li><p>在此对应下,正规子群对应于正规子群.</p>
</li>
<li><p>若有$H \trianglelefteq K \trianglelefteq G $,则$G / K \cong ( G / H ) / ( K / H ) $.</p>
</li>
</ol>
<p>如若考虑满同态的情况,我们有另一种形式的表达.设$f : G \rightarrow G ‘ $是群的满同态,根据同态基本定理有$G / \ker f \cong G ‘ $,立刻有:</p>
<ol>
<li><p>$G $的包含$\ker f $的子群和$G ‘ $的子群在$f $下一一对应.</p>
</li>
<li><p>在此对应下,正规子群对应正规子群.</p>
</li>
<li><p>若有$\ker f \leq H \trianglelefteq G $,则$G / H \cong ( G / \ker f ) / ( H / \ker f ) \cong G ‘ / H ‘ $.</p>
</li>
</ol>
<p>此形式与一开始的形式无太大差别,因为任何一个正规子群总对应某个映射的$\ker $.</p>
<p>然而这个证明要比原本的大量堆砌要更为漂亮.我们断言这种一一对应恰好由$f $给出.更进一步地,对于$\ker f \leq H \leq G $,其对应了一个$H ‘ \leq G ‘ $,满足:$f ( H ) = H ‘ $,而且$f ^{ - 1  } ( H ‘ ) = H $.</p>
<p>先来证明我们找到是一个双射,那就需要对每个$H $证明其对应的那个$H ‘ $确实是对应自己的,反之亦然:</p>
<p>首先我们要证明$H = f ^{ - 1  } ( f ( H ) ) $.显然有$H \subseteq f ^{ - 1  } ( f ( H ) ) $,下面证明$f ^{ - 1  } ( f ( H ) ) \subseteq H $.也就是要证明$\forall f ( x ) \in f ( H ) $,也就是$f ( x ) = f ( h ) , x \in G , h \in H $,都一定有$x \in H $.</p>
<p>可如若$f ( x ) = f ( h ) $就一定有$xh ^{ - 1  } \in \ker f \subseteq H $,这就搞定了$x \in H $.</p>
<p>反过来的$H ‘ = f ( f ^{ - 1  } ( H ‘ ) ) $,回忆到$f $是满射,其总有右逆,因此这是显然成立的.这就搞定了一一对应的关系,而且顺便还给出如果$H _1 \subseteq H _2 $,则$H _1 ‘ = f ( H _1 ) \subseteq H _2 ‘ = f ( H _2 ) $.至于$H ‘ $的正规性,只需要回忆到$\forall \bar { x  } \in G ‘ $,$\exists x \in G , \bar { x  } = f ( x ) $.这就给出$\bar { x  } f ( H ) ( \bar { x  } ) ^{ - 1  } = f ( xHx ^{ - 1  } ) = f ( H ) $.</p>
<p>最后考虑映射$G \to G ‘ / H ‘ , g \mapsto f ( g ) H ‘ $,它的$\ker = f ^{ - 1  } ( H ‘ ) = H $,所以同态基本定理给出$G / H \cong G ‘ / H ‘ $,这就搞定.</p>
<p>总之,第一同构定理给出的是”商”这个操作究竟对一个群有了怎样的影响,其实就是切片了对吧,然后把每一片缩起来.有下述交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { G \ar [r ] ^f \ar [d ] & G ' \ar [d ] \\
G / H \ar [r ] & G ' / H '  }</script><h5><span id="第二同构定理">第二同构定理</span></h5><p>设$G $是群,$H \trianglelefteq G , K \leq G $,则:</p>
<ol>
<li><p>$H \cap K \trianglelefteq K $.$HK = KH \leq G $.</p>
</li>
<li><p>$( HK ) / H \cong K / ( H \cap K ) $.</p>
</li>
</ol>
<p>考虑(1)的证明:</p>
<p>先看前半部分,只需证明$\forall k \in K , w \in H \cap K $,$kwk ^{ - 1  } \in H \cap K $.</p>
<p>注意到$k , w \in K $,所以$kwk ^{ - 1  } \in K $;又注意到$H \trianglelefteq G $,所以$kwk ^{ - 1  } \in H $,这就证明了该结论.</p>
<p>对于后半部分先证明$HK = KH $,考虑$hk \in Hk = kH \subseteq KH $.</p>
<p>再证$HK $的确是一个子群,我们早在子群判定引理处就证明了此结论.</p>
<p>再看(2)的证明:</p>
<p>考虑构造$\varphi : K \to ( HK ) / H , k \mapsto kH $.这显然是良定义的群同态.</p>
<p>考虑$\varphi ( k ) = H \Leftrightarrow k \in H \Leftrightarrow k \in K \cap H $,于是$\ker \varphi = K \cap H $.</p>
<p>接下来还需要解释其满性,考虑$\forall hkH = H ( hk ) = Hk = kH $,这就证明了其满性,于是上述命题自然成立.</p>
<p>根据第二同构定理还可以立刻得到:$H , K \leq G $,$G $是有限群,$| HK | = \frac { | H | | K |  } { | H \cap K |  } $.</p>
<p>另外容易见到,其实只要$H \leq N _G ( K ) $,上述结论依然过得去,因为只需要把群限制在$N _G ( K ) $上即可.</p>
<h5><span id="交换化">交换化</span></h5><p>如果群$G $的子群$H $对于所有自同构$\varphi : G \cong G $都满足$\varphi ( H ) = H $,则称$H $是一个<strong>特征子群</strong>.取$\varphi = \mathrm { Ad  } $可以见到特征子群总是正规子群.</p>
<p>还可以见到群的中心总是特征子群,原因是任取$z \in Z _G , \forall g \in G $,都满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
zg & = gz \\
\varphi ( z ) \varphi ( g ) & = \varphi ( g ) \varphi ( z ) 
\end{aligned}</script><p>由于$g $可以取遍$G $,所以$\varphi ( g ) $可以取遍$G $,所以$\varphi ( z ) \in Z _G $.</p>
<p>我们还可以定义群的<strong>导出子群</strong>$G _{ der  } = \langle aba ^{ - 1  } b ^{ - 1  } | a , b \in G \rangle $也是特征子群.原因是$\varphi ( aba ^{ - 1  } b ^{ - 1  } ) = \varphi ( a ) \varphi ( b ) \varphi ( a ) ^{ - 1  } \varphi ( b ) ^{ - 1  } $.</p>
<p>既如此,考虑商群$G _{ ab  } = G / G _{ der  } $.留意到$\forall g _1 , g _2 \in G _{ ab  } $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _1 g _2 G _{ der  } & = g _2 g _1 G _{ der  } \\
\Leftrightarrow g _1 ^{ - 1  } g _2 ^{ - 1  } g _1 g _2 G _{ der  } & = G _{ der  } \\
\Leftrightarrow g _1 ^{ - 1  } g _2 ^{ - 1  } g _1 g _2 \in G _{ der  } \\

\end{aligned}</script><p>所以见到此商群交换,我们将此操作称为<strong>群的交换化</strong>.</p>
<p>我们可能还想说明这样的交换化是最为合理的,我们可以证明如果存在一个同态$f : G \to A $,其中$A $是一个交换群.则存在唯一的$\bar { f  } : G _{ ab  } \to A $,使下列图表交换:</p>
<script type="math/tex; mode=display">
\xymatrix { G \ar [d ] \ar [r ] ^f & A \\
G _{ ab  } \ar [ru ] _{ \bar { f  }  } &  }</script><p>首先注意到必须满足$\bar { f  } ( gG _{ der  } ) = f ( g ) $,这就给出唯一性,其次要给出存在性,就要证明如果$g _1 G _{ der  } = g _2 G _{ der  } $则$f ( g _1 ) = f ( g _2 ) $.只需检验$G _{ der  } \subseteq \ker f $就行,然而由于$f ( aba ^{ - 1  } b ^{ - 1  } ) = e _A $,原因是$A $的交换性,因此这就给定了.</p>
<h6><span id="example1">Example1</span></h6><p>证明$GL ( n , F ) _{ der  } = SL ( n , F ) $,其中$F $是含有至少三个元素的域.</p>
<p>显然$GL ( n , F ) _{ der  } \subseteq SL ( n , F ) $,只需要证明上述导出子群的确生成了$SL ( n , F ) $即可.</p>
<p>考虑所有的矩阵都可以通过若干次初等行列变换变到对角线全$1 $的矩阵,只需要把这些初等行列变换全都拿到即可,略去不谈.</p>
<p>此时也可以见到$GL ( n , F ) / SL ( n , F ) = F $,其实也就是行列式.</p>
<h6><span id="example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</span></h6><p>设群$G $作用在集合$X $上,$| X | \geq 2 $,若$\forall ( x , y ) , ( x ‘ , y ‘ ) \in X ^2 $,其中$x \ne y , x ‘ \ne y ‘ $,都存在$g \in G $使得$gx = x ‘ , gy = y ‘ $,则称该作用是<strong>双传递的</strong>.下面我们设$G $双传递于$X $,并且记$H _x = \mathrm { Stab  } _G ( x ) $.</p>
<p>先证明一个引理:$\forall H _x $都是$G $的极大真子群.</p>
<p>为证明此,只需要证明任意往里面多添一个$g \in G \setminus H _x $,都会使得这个群扩充到$G $本身.一个想法是证明$G = H _x \cup H _x g H _x $.</p>
<p>既然如此,考虑只要证$\forall g _1 \in G \setminus H _x , \exists h _1 , h _2 \in H _x $使得$g _1 = h _1 gh _2 $即可,也就是$\exists h _1 $使得$g _1 ^{ - 1  } h _1 g \in H _x \Leftrightarrow g _1 ^{ - 1  } h _1 g ( x ) = x \Leftrightarrow g ( x ) = h _1 ^{ - 1  } g _1 ( x ) $.</p>
<p>考虑到$g ( x ) \ne x , g _1 ( x ) \ne x $.由双传递性一定存在一个$h _1 ^{ - 1  } $把$( x , g _1 ( x ) ) \to ( x , g ( x ) ) $,这就搞定了.</p>
<p>接下来再证明一个引理:任何正规子群$N \trianglelefteq G $在$X $上的作用要么是平凡的,要么是传递的.</p>
<p>若$N $的作用不是平凡的,也就是存在$x , n $使得$nx \ne x $,那我们下面证明对于任意$y \ne y ‘ $,都可以找到一个元素$m \in N $使得$my = y ‘ $.原因是可以取$g : ( x , nx ) \mapsto ( y , y ‘ ) $,于是$gx = y , gnx = y ‘ , gng ^{ - 1  } y = y ‘ $,由于$N $正规知道$gng ^{ - 1  } \in N $,这就搞定了.</p>
<p>接下来证明岩泽判准,假设$G $作用忠实,$G = G _{ der  } $,而且存在$x $使得$H _x $有正规交换子群$U $,而$U $在$G $中的所有共轭生成$G $.我们下面证明$G $是单群.</p>
<p>取定$N \trianglelefteq G $和$x \in X $,由于$H _x $是极大真子群,所以要么$NH _x = H _x $,要么$NH _x = G $.</p>
<p>当$NH _x = H _x , N \subseteq H _x $的时候,此时$N $作用并非传递,所以$N $作用平凡.由于作用是忠实的,作用平凡的元素也就只有$\{ id \} $.</p>
<p>当$NH _x = G $的时候,我们先证明$NU \trianglelefteq NH _x = G $.首先第二同构定理的部分已经给出了$NU \leq NH _x $,现在考虑$\forall nu \in NU , n _1 h _1 \in NH _x $,下面证明$n _1 h _1 nuh _1 ^{ - 1  } n _1 ^{ - 1  } \in NU $.</p>
<p>而考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n _1 h _1 nuh _1 ^{ - 1  } n _1 ^{ - 1  } \\
= n _1 ( h _1 nh _1 ^{ - 1  } ) ( h _1 uh _1 ^{ - 1  } ) n _1 ^{ - 1  } \\
\in NUN = NU 
\end{aligned}</script><p>此时由于$U \leq NU $,而后者正规,前者的所有共轭生成$G $,这必然意味着$NU = G $,第二同态定理给出$G / N \cong U / ( N \cap U ) $而后者交换,这给出了一种$G $向交换群的同态,我们知道此时必然有$G _{ ab  } $上也有一个向交换群的同态,然而$G _{ ab  } $是平凡群,因此$G / N $必然也是平凡群,意味着$N = G $.</p>
<h6><span id="example3">Example3</span></h6><p>设$F $为域且$| F | \geq 4 $,记$Z $是$SL ( n , F ) $的中心,下面我们证明当$n \geq 2 $的时候,$PSL ( 2 , F ) = SL ( 2 , F ) / Z $是单群.</p>
<p>我们想要用岩泽健吉判准,首先要检验$SL ( n , F ) = SL ( n , F ) _{ der  } $,这个与之前的做法几乎类似,只需要简单说明.</p>
<p>接下来设$\mathbb { P  } ^{ n - 1  } ( F ) $为$F ^n $的$1 $维子空间,让$PSL ( n , F ) $作用在上面,留意到中心的作用也的确是平凡的.</p>
<p>当$n = 2 $的时候,记录$( x , y ) \in F ^2 \setminus \{ 0 \} $生成的空间为$( x : y ) $,我们来证明它是双传递的,事实上这较为显然.</p>
<p>接下来我们来看$( 1 : 0 ) $上的稳定化子群$H $,其实也就是所有的上三角矩阵,然后还要验证作用是忠实的,总之请检验以上事实.然后取$U = \{ \begin{bmatrix}1 &amp; _ \ 0 &amp; 1 \end{bmatrix} Z \} $.</p>
<p>当$n \geq 3 $和上面是同理的,对于$( 1 : 0 \cdots : 0 ) $的稳定化子群取分块上三角矩阵$\begin{bmatrix}a &amp; _ \ &amp; A \end{bmatrix} Z $,然后取$U = \{ \begin{bmatrix}1 &amp; _ \ 0 &amp; I \end{bmatrix} Z \} $.</p>
<h4><span id="群的直和与直积">群的直和与直积</span></h4><h5><span id="直和">直和</span></h5><p>在两个群$G _1 , G _2 $的笛卡尔积$G _1 \times G _2 $集合上定义二元运算,满足$( a _1 , b _1 ) ( a _2 , b _2 ) = ( a _1 a _2 , b _1 b _2 ) $,这个集合和这个二元运算显然组成群,称这个群为$G _1 $和$G _2 $的<strong>外直和</strong>,记为$G _1 \oplus G _2 $,$G _1 , G _2 $称作其的<strong>直和因子</strong>.如果要对无限个群做类似操作,则可以区分出<strong>直积</strong>的版本,仍是因为是否有限个分量非零的问题.</p>
<p>显然$G _1 \oplus G _2 $中存在两个正规子群$\bar { G _1  } = \{ ( a , e _2 ) | a \in G _1 \} , \bar { G _2  } = \{ ( e _1 , b ) | b \in G _2 \} $,并且不难发现$G _1 \oplus G _2 = \bar { G _1  } \bar { G _2  } $.</p>
<p>这给出了一种分解群的策略,事实上,设$G $是群,$H , K \trianglelefteq G , G = HK $,我们有以下命题互推:</p>
<ol>
<li><p>映射$\sigma : H \oplus K \rightarrow G , ( h , k ) \mapsto hk $是同构.</p>
</li>
<li><p>$G $的任一元素表示为$H , K $的乘积的表示法唯一.</p>
</li>
<li><p>$G $的幺元表示为$H , K $的元素的乘积的表示法唯一.</p>
</li>
<li><p>$H \cap K = \{ e \} $.</p>
</li>
</ol>
<p>显然$( 1 ) \Rightarrow ( 2 ) \Rightarrow ( 3 ) $.对于$( 3 ) \Rightarrow ( 4 ) $,如果$\exists g \in H \cap K , g \ne e $,则$e = gg ^{ - 1  } = ee $,这就给出了两种表示法,不符.</p>
<p>只需证明$( 4 ) \Rightarrow ( 1 ) $.根据我们的经验,先证良定义(显然),再证群同态,再证单射,再证满射(显然).</p>
<p>我们先干个事,我们断言$\forall h \in H , k \in K , hk = kh $.</p>
<p>这个怎么断言呢?我们考虑由于$H \trianglelefteq G $,有$k ^{ - 1  } hk \in H $,所以$h ^{ - 1  } k ^{ - 1  } hk \in H $,同理可证明$h ^{ - 1  } k ^{ - 1  } hk \in K $,于是$h ^{ - 1  } k ^{ - 1  } hk = e $,$kh = hk $.由此显然证明是群同态.</p>
<p>接下来只需要证明单射,只需要证明$\ker \sigma = \{ e , e \} $.不妨设$( h , k ) \in \ker \sigma $,则$hk = e $,$h = k ^{ - 1  } \in H \cap K = e $.所以$\ker \sigma = \{ e , e \} $.</p>
<p>我们也将$G $称作$H $和$K $的<strong>内直和</strong>,将$H , K $称作其<strong>直和因子</strong>.</p>
<p>上面的概念还可以扩展,设$G $是群,$H _1 , \cdots , H _n \trianglelefteq G , G = H _1 \cdots H _n $,我们有以下命题互推:</p>
<ol>
<li><p>映射$\sigma : H _1 \oplus \cdots \oplus H _n \rightarrow G , ( h _1 , \cdots , h _n ) \mapsto h _1 \cdots h _n $是同构.</p>
</li>
<li><p>$G $的任一元素表示为$H _1 , \cdots , H _n $的乘积的表示法唯一.</p>
</li>
<li><p>$G $的幺元表示为$H _1 , \cdots , H _n $的元素的乘积的表示法唯一.</p>
</li>
<li><p>$H _i \cap ( H _1 \cdots H _{ i - 1  } H _{ i + 1  } \cdots H _n ) = \{ e \} $.</p>
</li>
</ol>
<h5><span id="半直积">半直积</span></h5><p>取$H , N $是给定的两个任意的群,以及给定的群同态$\varphi : H \to \mathrm { Aut  } ( N ) , h \mapsto \varphi _h $.</p>
<p>接下来在$N \times H $上定义一种二元运算,定义为$( n , h ) ( n ‘ , h ‘ ) = ( n \varphi _h ( n ‘ ) , hh ‘ ) $.我们下面证明这种运算的确使得$N \times H $成为群,记作$N \rtimes _\varphi H $.见到:</p>
<ol>
<li><p>幺元存在:$1 _{ N \times H  } = ( 1 _N , 1 _H ) $.</p>
</li>
<li><p>逆元存在:$( n , h ) ^{ - 1  } = ( \varphi _{ h ^{ - 1  }  } ( n ^{ - 1  } ) , h ^{ - 1  } ) $.</p>
</li>
</ol>
<p>结合律的验证比较多,考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( n _1 , h _1 ) ( n _2 , h _2 ) ( n _3 , h _3 ) \\
& = ( n _1 \varphi _{ h _1  } ( n _2 ) \varphi _{ h _1 h _2  } ( n _3 ) , h _1 h _2 h _3 ) 
\end{aligned}</script><p>而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( n _1 , h _1 ) ( ( n _2 , h _2 ) ( n _3 , h _3 ) ) \\
& = ( n _1 , h _1 ) ( n _2 \varphi _{ h _2  } ( n _3 ) , h _2 h _3 ) \\
& = ( n _1 \varphi _{ h _1  } ( n _2 \varphi _{ h _2  } ( n _3 ) ) , h _1 h _2 h _3 ) 
\end{aligned}</script><p>于是我们要证明的就是$\varphi _{ h _1  } ( n _2 ) \varphi _{ h _1 h _2  } ( n _3 ) = \varphi _{ h _1  } ( n _2 \varphi _{ h _2  } ( n _3 ) $.由于$\varphi $是同态,里面的乘积可以拆出,只需证明$\varphi _{ h _1 h _2  } = \varphi _{ h _1  } \circ \varphi _{ h _2  } $,然而这恰是同态$\varphi : H \to \mathrm { Aut  } ( N ) $本身的性质,这就搞定.</p>
<p>接下来,我们考虑搞两个嵌入映射,考虑$N \to N \times H , n \mapsto ( n , 1 _H ) $.同理定义$H \to N \times H , h \mapsto ( 1 _N , h ) $.在这种嵌入下见到$( n , h ) = ( n , 1 _H ) ( 1 _N , h ) $,可以发现$N \trianglelefteq N \times H $.原因是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( n _1 , h _1 ) ( n , 1 _H ) ( n _1 , h _1 ) ^{ - 1  } \\
& = ( n _1 , 1 _H ) ( 1 _N , h _1 ) ( n , 1 _H ) ( 1 _N , h _1 ) ^{ - 1  } ( n _1 , 1 _H ) ^{ - 1  } 
\end{aligned}</script><p>而考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( 1 _N , h ) ( n , 1 _H ) ( 1 _N , h ) ^{ - 1  } \\
& = ( 1 _N , h ) ( n , 1 _H ) ( 1 _N , h ^{ - 1  } ) \\
& = ( \varphi _h ( n ) , h ) ( 1 _N , h ^{ - 1  } ) \\
& = ( \varphi _h ( n ) , 1 _H ) 
\end{aligned}</script><p>这就搞定了.</p>
<p>上述操作看上去一团迷雾,我们想要说明半直积定义的动机:其实就是想让$N , H $嵌入同一个群中,并且使得$N $是这个群的一个正规子群.</p>
<p>于是我们的目标终于明晰:假设$H \leq G , N \trianglelefteq G , H \cap N = \{ 1 \} , G = NH = HN $,考虑由$\mathrm { Ad  } _h ( n ) = hnh ^{ - 1  } $给出的映射,下面我们要证明存在同构$\Phi : N \rtimes _\mathrm { Ad  } H \cong G , ( n , h ) \mapsto nh $.</p>
<p>首先验证这的确是个同态,考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Phi ( ( n , h ) ( n ' , h ' ) ) \\
& = \Phi ( nhn ' h ^{ - 1  } , hh ' ) \\
& = nhn ' h ^{ - 1  } hh ' \\
& = nhn ' h ' & = \Phi ( n , h ) \Phi ( n ' , h ' ) 
\end{aligned}</script><p>满性显然,单性的话考虑$\Phi ( n , h ) = 1 \Leftrightarrow nh = 1 \Leftrightarrow n = 1 , h = 1 $,这就搞定.</p>
<p>上述构造舍弃了$\varphi $,因此比起之前的版本,这个更像是一种内的版本.事实上上述也有第二同构定理给出$G / N \cong H $,所以你可以将商看作半直积的逆运算,然而反之不可.例如$( \mathbb { Z  } / 4 \mathbb { Z  } ) / ( 2 \mathbb { Z  } / 4 \mathbb { Z  } ) \cong ( \mathbb { Z  } / 2 \mathbb { Z  } ) $,注意到$( 2 \mathbb { Z  } / 4 \mathbb { Z  } ) \cong ( \mathbb { Z  } / 2 \mathbb { Z  } ) $,但$\mathbb { Z  } / 4 \mathbb { Z  } $和$( \mathbb { Z  } / 2 \mathbb { Z  } ) ^2 $并不同构,前者是循环群后者是克莱因四元群.</p>
<p>半直积的作用要么是通过两个群得到一个新的群,要么反之将一个群拆分为两个不同的群.</p>
<h6><span id="example1">Example1</span></h6><p>一个例子是将置换群$S _n $拆成偶置换群$A _n $和任何一个单置换$\tau = ( i , j ) $的半直积,有:$S _n = A _n \rtimes \langle \tau \rangle $.</p>
<p>然而当$n &gt; 2 $的时候,见到永远不可能出现$S _n = A _n \times \langle \tau \rangle $的情形,证明可以考虑左侧的中心只有$id $而右侧至少有$( 1 , 1 ) $和$1 , \tau $两个.</p>
<h6><span id="example2二面体群">Example2(二面体群)</span></h6><p>回忆到$O ( 2 ) $为$\mathbb { R  } ^2 $上的正交变换,上面有一个正规子群$SO ( 2 ) $为$\det = 1 $的部分.</p>
<p>设$n \geq 3 $,取平面上的一个中心为$( 0 , 0 ) $的正$n $边形,适当缩放后可以使得顶点分别为$\omega _n ^k = e ^{ \frac { 2 k \pi i  } { n  }  } $,设$D _{ 2 n  } $为所有使得正$n $边形不变的正交变换,容易见到$D _{ 2 n  } \leq O ( 2 ) $.</p>
<p>接下来看$D _{ 2 n  } $中的两种元素:</p>
<ol>
<li><p>旋转:那肯定要将一个角挪到另一个角上,因此等价于复平面上的$\omega _n ^k $,记$\sigma = \omega _n $则旋转群也就是$\langle \sigma \rangle \cong \mathbb { Z  } / n \mathbb { Z  } $.</p>
</li>
<li><p>镜射:任取一个$\tau $使得图形沿某条轴翻转.容易见到$\langle \tau \rangle \cong \mathbb { Z  } / 2 \mathbb { Z  } $.</p>
</li>
</ol>
<p>下面我们说明$D _{ 2 n  } \cong \langle \sigma \rangle \rtimes \langle \tau \rangle \cong \mathbb { Z  } / n \mathbb { Z  } \rtimes _\varphi \mathbb { Z  } / 2 \mathbb { Z  } $.其中$\varphi _{ 1 + 2 \mathbb { Z  }  } ( a + n \mathbb { Z  } ) = - a + n \mathbb { Z  } $.</p>
<p>首先见到$D _{ 2 n  } \cap SO ( 2 ) = \langle \sigma \rangle $,原因显然.这样两边取交就可以说明$\langle \sigma \rangle \trianglelefteq D _{ 2 n  } $.</p>
<p>此外容易见到$\langle \sigma \rangle \cap \langle \tau \rangle = \{ 1 \} $.其余性质也容易说明,唯一可能稍不显然的是为何$\langle \sigma \rangle \rtimes \langle \tau \rangle $的确生成了整个群.</p>
<p>策略是转回去!假设这个变换将$0 $号顶点搞到了某个位置,你可以把它转回去,于是此时图形保持了$0 $号顶点不动,此时要么就是恒等,要么就是按照实轴翻转,这样就搞定了.</p>
<h3><span id="环">环</span></h3><p>定义一个<strong>环</strong>是一个集合$R $和两种二元运算$+ , \times $.它应当满足如下性质:</p>
<ol>
<li><p>集合对两种运算封闭.</p>
</li>
<li><p>$( R , + ) $构成阿贝尔群,加法幺元一般记作$0 _R $,$x $的加法逆元一般记作$- x $.</p>
</li>
<li><p>乘法有结合律.</p>
</li>
<li><p>乘法对加法有分配律.</p>
</li>
<li><p>(幺环存在乘法幺元,一般记作$1 _R $)</p>
</li>
<li><p>(交换环的乘法具有交换律)</p>
</li>
</ol>
<p>最平凡的环只包含一个$0 $元素,被称为<strong>零环</strong>.</p>
<p>下面证明一些环的基础性质:</p>
<ol>
<li>$\forall a \in R , a 0 = 0 a = 0 $.</li>
</ol>
<p>注意到$a 0 = a ( 0 + 0 ) = a 0 + a 0 $,所以$a 0 = 0 $.</p>
<ol>
<li>$\forall a , b \in R , ( - a ) b = a ( - b ) = - ( ab ) $.</li>
</ol>
<p>注意到$( - a ) b + ab = b ( a - a ) = 0 $,所以$- ( ab ) = ( - a ) b $.</p>
<ol>
<li>$\forall a , b \in R , ( - a ) ( - b ) = ab $.</li>
</ol>
<p>由(2)是显然的.</p>
<p>注意到环的定义中并没有提及乘法逆元.如果环$R $是幺环,且对于某一个$a \in R $,$a $有逆元(或者既有左逆元又有右逆元,类似群,左右逆元必相等且唯一),那么称其为<strong>可逆元</strong>或<strong>单位元</strong>,有时又称其为unit.</p>
<p>容易验证幺环的可逆元的全体构成乘法群,记作$R ^\times $.</p>
<p>对于一个元素$a \in R $来说,如果$\exists b \in R \setminus \{ 0 \} $,$ab = 0 $,我们称$a $是$R $中的一个<strong>左零因子</strong>,同理可定义<strong>右零因子</strong>,如果一个$a $既是左零因子又是右零因子,我们称其为一个<strong>零因子</strong>.</p>
<p>我们事实上可以说明这里的加法和乘法与我们平时使用的相当类似,换言之,我们可以说明对于任意环$R $而言,单同态$\varphi : \mathbb { Z  } \rightarrow R $唯一.</p>
<p>首先我们应该满足$\varphi ( 1 ) = 1 _R , \varphi ( 0 ) = 0 _R $.</p>
<p>其次我们应当有$\varphi ( n ) = \varphi ( 1 + 1 + \cdots + 1 ) = \varphi ( 1 ) + \varphi ( 1 ) + \cdots + \varphi ( 1 ) $.我们不妨把后者简写为$n \varphi ( 1 ) $,倍数运算是环中相当重要的运算.</p>
<h4><span id="子环">子环</span></h4><p>要验证$S $是$R $的子环,只需验证$S $对加法下是子群,然后$S $对乘法封闭.</p>
<p>而事实上由于$- x = ( - 1 ) x $,所以实际上只需要验证$S $对加法和乘法都封闭即可.</p>
<h4><span id="理想">理想</span></h4><p>由于环上有两种运算,如果我们想在陪集上保持环的两种运算,就需要在上面加一些限制.</p>
<p>进一步地,如果$I $是$R $的一个加法子群(由于加法有交换律,所以加法子群一定是加法正规子群),并且$\forall r \in R $,有$rI \subseteq I $(那么自然有$rI = I $),则称$I $是$R $的一个<strong>左理想</strong>,同理定义<strong>右理想</strong>,既是左理想又是右理想则称其为一个<strong>理想</strong>.</p>
<p>事实上,如果对于$R $上的一个理想$I $,我们容易证明$I = R \Leftrightarrow 1 \in I $.</p>
<p>由于这是一个加法子群,所以加法运算肯定是满足的,容易发现如果$I $是$R $的一个理想,那么$\forall r , s \in R , ( r + I ) ( s + I ) = rs + I $.</p>
<p>类似群中的结构,子环的交仍然是子环,理想的交仍然是理想.于是类似可以定义由$M \subseteq R , M \ne \emptyset $生成的理想$( M ) $.可由一个元素生成的理想称为<strong>主理想</strong>,可由有限多个元素生成的理想叫做<strong>有限生成理想</strong>.容易发现如果$R $是交换环,那么$( a ) = aR $.不然$( a ) = RaR $.</p>
<p>既然我们在陪集上保持了环的运算,我们自然可以称$R / I $为$R $关于$I $的<strong>商环</strong>,也就是$R / I = \{ r + I | r \in R \} $.必须要说明的是商环本身也是一个环,其加法幺元是$0 + I $,乘法幺元是$1 + I $.</p>
<p>子环和理想疑似没有对应的符号表示,我们下面不严谨地盗用子群和正规子群的符号(正常情况下好像不让这么干),在不引起混淆的前提下将$( R , + , \times ) $简写为$R $.</p>
<h4><span id="同态和同构">同态和同构</span></h4><p>类似群同态和同构,要同时保持两种运算并且需要将乘法幺元映射到对应的乘法幺元.</p>
<p>不过,如果将环同态的定义中的$\varphi ( ab ) = \varphi ( a ) \varphi ( b ) $改为$\varphi ( ab ) = \varphi ( b ) \varphi ( a ) $,则称这样的映射为环的<strong>反同态</strong>.</p>
<p>和群略有区别的地方在于如何定义$\ker \varphi $,事实上我们一般用加法幺元(因为乘法逆元不一定存在)定义$\ker \varphi = \{ a \in R | \varphi ( a ) = 0 \} $.那么$\varphi $是单射当且仅当$\ker \varphi = \{ 0 \} $.</p>
<p>类比一下群同态,可以知道对于$\varphi : R \rightarrow R _1 $,$\text { im  } \varphi \leq R _1 , \ker \varphi \trianglelefteq R $.</p>
<p>对于前者:由于加法上的性质已经很好了,只需验证其对乘法封闭,这个是好做的.</p>
<p>对于后者:只需验证其封闭且是理想,同样可行.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5><p>也就是$R / \ker \varphi \cong \text { im  } \varphi $.</p>
<p>设$f : R _1 \to R _2 $是线性映射,$I _1 \trianglelefteq R _1 , I _2 \subseteq R _2 $并构造两个商映射$\varphi _1 , \varphi _2 $,并且$f ( I _1 ) \subseteq I _2 $,那么存在唯一的线性映射$\bar { f  } : R _1 / I _1 \to R _2 / I _2 $使得$f \varphi _2 = \bar { f  } \varphi _1 $.具体地,$\bar { f  } ( r + I _1 ) = f ( r ) + I _2 $.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { R _1 \ar [r ] ^f \ar [d ] _{ \varphi _1  } & R _2 \ar [r ] ^g \ar [d ] _{ \varphi _2  } & R _3 \ar [d ] _{ \varphi _3  } \\
R _1 / I _1 \ar [r ] ^{ \bar { f  }  } & R _2 / I _2 \ar [r ] ^{ \bar { g  }  } & R _3 / I _3 \\
 }</script><h5><span id="第一同构定理">第一同构定理</span></h5><p>设$R $是环,$I \trianglelefteq R $,考虑典范同态:$\pi : R \rightarrow R / I , r \mapsto r + I $,那么:</p>
<ol>
<li><p>$R $的包含$I $的子环与$R / I $的子环在$\pi $下一一对应.</p>
</li>
<li><p>在此对应下,理想对应于理想.</p>
</li>
<li><p>若$I \trianglelefteq J \trianglelefteq R $,则$R / J \cong ( R / I ) / ( J / I ) $.</p>
</li>
</ol>
<h5><span id="第二同构定理">第二同构定理</span></h5><p>设$R $是环,$I \trianglelefteq R , S \leq R $,则:</p>
<ol>
<li><p>$I + S \leq R $.$I \cap S \trianglelefteq S $.$I \trianglelefteq I + S $</p>
</li>
<li><p>$( I + S ) / I \cong S / ( S \cap I ) $.</p>
</li>
</ol>
<h4><span id="整环">整环</span></h4><p>如果一个交换幺环至少含有两个元素(或说$0 \ne 1 $),且其满足$xy = 0 \Rightarrow x = 0 \lor y = 0 $(或说其没有非零零因子),那么我们称其是一个整环.</p>
<p>显然,整环上对乘法满足左右消去律.原因是$ax = ay \Leftrightarrow a ( x - y ) = 0 $.</p>
<h5><span id="特征">特征</span></h5><p>我们之前证明过$\mathbb { Z  } $可以唯一射到任何一个环上,如果这个环是整环,那么其实有更好的性质:</p>
<p>对于任意一个整环$R $,存在唯一一个环的<strong>特征</strong>$\text { char  } R \in \mathbb { N  } $使得$n 1 _R = 0 _R \Leftrightarrow \text { char  } R | n $.我们还可以知道$\text { char  } R $要么是$0 $要么是素数.</p>
<p>怎么证明呢?考虑如果$\text { char  } R = ab $,自然有$ab 1 _R = 0 _R $,于是$( a 1 _R ) ( b 1 _R ) = 0 _R $,由于这是一个整环,我们当然有$a 1 _R = 0 _R \lor b 1 _R = 0 _R \Rightarrow \text { char  } R | a \lor \text { char  } R | b $.</p>
<p>如果$R $中有一个整子环$R _0 $,当然可以发现$\text { char  } R = \text { char  } R _0 $,于是当然有$\text { char  } R = \text { char  }  \text { Frac  } ( R ) $.</p>
<p>另一个性质在于容易发现$\text { char  } R \times x = 0 _R $.</p>
<h5><span id="整除性">整除性</span></h5><p>$\forall a , b \in R $,如果$\exists c \in R , a = bc $,就称$b $是$a $的<strong>因子</strong>,记作$b | a $.我们可以说明$b | a \Leftrightarrow ( a ) \subseteq ( b ) $,因为对于必要性:$( a ) = aR = bcR \subseteq bR $,而对于充分性则是因为$a \in ( a ) \subseteq ( b ) $.</p>
<p>如果两个元素互为因子,则称它们<strong>相伴</strong>,暂且用$\sim $代表这种关系.容易验证这等价于$\exists u \in R ^\times , a = bu $.原因是如果$\exists u , v \in R , a = ub , b = va $,那么$a = uva $,由消去律得知$uv = 1 $.此时它们生成的主理想必然相等.相伴关系显然是一种等价关系,$R $对于相伴关系的商集上的因子关系是一种偏序关系(但不是全序的).</p>
<p>事实上还可以定义<strong>真因子</strong>:如果$( a ) \subsetneq ( b ) $,那么显然$b | a $,我们称此时$b $是$a $的真因子.容易发现$b $是$a $的真因子当且仅当$b | a $并且$b $不与$a $相伴.</p>
<p>称一个元素$a $是<strong>不可约元</strong>,当它不是$0 $也不是单位元而且$\forall b , c \in R , a = bc \Rightarrow b \in R ^\times \lor c \in R ^{ \times  } $.或者说:$a = bc \Rightarrow c \sim a \lor b \sim a $.或者说$a $不存在真因子.</p>
<p>称一个元素$a $是<strong>素元</strong>,当它不是$0 $也不是单位元而且$\forall b , c \in R , a | bc \Rightarrow a | b \lor a | c $.</p>
<p>我们可以证明:在整环中,素元一定是不可约元,但是不可约元不一定是素元.</p>
<p>如何证明素元一定是不可约元呢?考虑如果$a \in prime $,并且$a = bc $,则$a | bc \Rightarrow a | b \lor a | c $,不妨假设$a | b $,那么设$b = ad $,自然有$a = adc $,$( dc ) = 1 $,于是$c \in \mathrm { unit  } $.</p>
<h5><span id="唯一分解整环ufd">唯一分解整环(UFD)</span></h5><p>称$R $是唯一分解整环,如果$\forall a \in R , a \ne 0 $,都可以将$a $分解成有限个不可约元的乘积的相伴,也就是可以将$a = u \prod _{ k = 1  } ^n p _k $,其中$u \in \mathrm { unit  } $,$p _k $是不可约元.并且这种分解需要在相伴意义下唯一,也就是如果存在另一种分解$a = v \prod _{ k = 1  } ^m q _k $,那么需要满足$n = m $并且可以交换乘积顺序使得$p _k $和$q _k $相伴.</p>
<p>我们下面可以证明:在唯一分解整环中,不可约元一定也是素元.</p>
<p>不妨设$a $是不可约元,那么我们要证明$a | bc \Rightarrow a | b \lor a | c $.考虑设$ad = bc $,对$b , c , d $均作唯一分解,那么$a $会剩下来并且和对面的某个分解出来的不可约元相伴,自然会有$a | b \lor a | c $.</p>
<p>在唯一分解整环中可以定义最大公因子.最大公因子当然可能不唯一,但最大公因子之间一定相伴.进一步地,如果最大公因子是可逆元,我们称两个数互素.</p>
<p>当且仅当一个整环有以下两个性质,它是一个唯一分解整环:</p>
<ol>
<li><p>任意不可约元都是素元.</p>
</li>
<li><p>(存在分解)所有的$r \in R \setminus \{ 0 \} $都能写成有限不可约元的乘积.</p>
</li>
</ol>
<p>先数学归纳,然后用反证法,假设不成立,那么$r = \prod p _k = \prod q _j $.</p>
<p>接下来任取左边的一个$p _1 $,如果右边也有一个$q _1 \sim p _1 $就直接消去.反之考虑不可约元也是素元,因此$p _1 | \prod q _j $,因此$\exists j , p _1 | q _j $,不妨设$tp _1 = q _j $,因为$q _j $是不可约元,所以$t \in R ^\times $,所以$p _1 \sim q _j $.于是唯一分解性自然得出.</p>
<p>另一种等价条件是:</p>
<ol>
<li><p>任意不可约元都是素元.</p>
</li>
<li><p>主理想的Noether性质:对于一条主理想的链$( a _1 ) \subseteq ( a _2 ) \subseteq \cdots $,一定存在一个$k $,使得从$k $之后$( a _k ) = ( a _{ k + 1  } ) = \cdots $.这条性质也等价于一条因子链一定需要是有限的.</p>
</li>
</ol>
<p>用主理想的Noether性质直接就可以得出任何一个$r $都存在有限分解,于是等价于上面那个等价性质.</p>
<p>另外,真实的Noether性质其实是任何一个理想列(不一定是主理想),然而UFD并不一定满足此.最经典的例子是环$\mathbb { Q  } [ x _1 , x _2 , \cdots ] $,显然$( x _1 ) \subseteq ( x _1 , x _2 ) \subseteq \cdots $.</p>
<h5><span id="主理想整环pid">主理想整环(PID)</span></h5><p>如果一个整环的所有理想都是主理想,则称其为一个主理想整环.交换除环当然是主理想整环的一个典型例子.</p>
<p>需要证明PID一定是UFD,对此,我们考虑:</p>
<p>首先证明PID上的不可约元是素元,这里需要拿出裴蜀定理.然而我们目前不能定义最大公因子的概念,因此退而求其次只定义互素的概念:如果$\forall c , c | a \land c | b \Rightarrow c \in R ^\times $,则称$a $和$b $互素.</p>
<p>我们需要证明在主理想整环上有裴蜀定理,换言之如果两个元素互素,那么$\exists x , y \in R , ax + by = 1 $,或者说$( \{ a , b \} ) = R $.原因是$\exists h , ( h ) = ( \{ a , b \} ) $,那么此时必有$h | a \land h | b $,于是$h \sim 1 $.</p>
<p>其次需要证明PID上的Noether性质,注意到一条主理想的链$I _1 \subseteq I _2 \subseteq \cdots $,直接取$I = \bigcup _j I _j $,这个$I $必然也是理想(乘法封闭性是显然的,加法封闭性的话考虑$\forall x \in I _a , y \in I _b $,$x + y \in I _{ \max ( a , b )  } $),那么它就必然是一个主理想,也就是$\exists h , I = ( h ) $.此时注意到$\exists k , h \in I _k $,那么$I _k = I _{ k + 1  } = \cdots = I $,这就证毕了.</p>
<p>综上可看出PID一定是UFD.</p>
<p>设$R $为主理想整环,$t \in ( R \setminus \{ 0 \} ) \setminus R ^\times $.那么以下命题等价:</p>
<ol>
<li><p>$R / ( t ) $是域.</p>
</li>
<li><p>$R / ( t ) $是整环.</p>
</li>
<li><p>$t $是素元.</p>
</li>
</ol>
<p>(1)$\Rightarrow $(2)当然是平凡的,考虑(2)$\Rightarrow $(3)如何证明:</p>
<p>由于$R / ( t ) $是整环,考虑$t = ab $,那么我们有$( a + ( t ) ) ( b + ( t ) ) = ab + ( t ) = 0 + ( t ) $,由于这是一个整环,这必然意味着:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a + ( t ) & = 0 + ( t ) \lor b + ( t ) & = 0 + ( t ) \\
\Rightarrow t | a \lor t | b \\
\Rightarrow t \sim a \lor t \sim b 
\end{aligned}</script><p>因此$t $是不可约元,因此$t $是素元.</p>
<p>接下来考虑(3)$\Rightarrow $(1),只需证明非零元$a + ( t ) $均可逆即可.考虑主理想整环上的裴蜀定理,存在$x , y $使得$ax = 1 - yt $,此时$x + ( t ) $就是$a + ( t ) $的逆元.</p>
<p>还可进一步扩展裴蜀定理,容易证明在主理想环中$( \{ r _1 , \cdots , r _n \} ) = \gcd ( r _1 , \cdots , r _n ) R $.</p>
<p>事实上还可以在这里拿出拓展版的中国剩余定理,具体地,如果$a _1 , \cdots , a _n \in R \setminus \{ 0 \} $,并且它们两两互素,取$a = \prod a _k $,那么我们事实上有环同构$\varphi : R / ( a ) \to \prod _{ k = 1  } ^n R / ( a _k ) , r + ( a ) \mapsto ( r + ( a _i ) ) _{ k = 1  } ^n $.</p>
<p>用数学归纳只需证明$n = 2 $的情形就可以了.</p>
<p>先证明$\varphi $是单射,观察$\ker \varphi $,如果$\varphi ( r + ( a ) ) = ( 0 + ( a _1 ) , 0 + ( a _2 ) ) $自然意味着$a _1 | r , a _2 | r \Rightarrow a | r $,于是$r + ( a ) = 0 + ( a ) $,这立刻得到$\varphi $是单射.</p>
<p>再证明$\varphi $是满射,用裴蜀定理容易取$x _1 , x _2 \in R $使得$a _1 x _1 + a _2 x _2 = 1 $,那么$ra _1 x _1 + ra _2 x _2 = r $,此时注意到$\varphi ( ra _1 x _1 + ( a ) ) = ( 0 + ( a _1 ) , r + ( a _2 ) ) $,$\varphi ( ra _2 x _2 + ( a ) ) = ( r + ( a _1 ) , 0 + ( a _2 ) ) $.这样就可以看出其满性.其实这当然也是中国剩余定理在整数上的构造的类似版本.</p>
<h3><span id="多项式环">多项式环</span></h3><h4><span id="一元多项式环">一元多项式环</span></h4><p>一个系数属于特定非零环$R $的一元多项式定义为系数在$R $上的一元多项式环,记作$R [ x ] $,注意到如果$R $是整环,$R [ x ] $仍然是整环.多元多项式环可以不断在多元多项式环上定义一元多项式环.不妨将一个多项式记作$f ( x ) $.另外如果我们记$R ^{ \times  } $为$R $中可逆元素的集合,那么显然$R [ x ] ^{ \times  } = R ^{ \times  } $.</p>
<p>一般而言,我们下面默认讨论$R $是整环的情况.</p>
<p>在多项式环上可以定义最高次数函数$\deg $,容易验证$\deg ( fg ) = \deg f + \deg g , \deg ( f + g ) \leq \max \{ \deg f , \deg g \} $,可定义$\deg 0 = - \infty $.</p>
<p>整环上的多项式有长除法和取模运算,也就是对于任意多项式$f $,以及最高项系数为$1 $的多项式$d $,存在唯一一组$q , r $满足$f = dq + r $并且$\deg r $最小.这样还可以定义整除也就是当$r = 0 $的时候.</p>
<p>长除法的正确性可以反证,如果存在两组,那么自然有$d ( q _1 - q _2 ) = r _2 - r _1 $,如果$q _1 \ne q _2 $,那么$\deg ( q _1 - q _2 ) \geq 0 $,那么$\deg d ( q _1 - q _2 ) \geq \deg d $,但是$\deg ( r _2 - r _1 ) &lt; \deg d $,这样的话等式就不能成立了.因此必定有$q _1 = q _2 , r _1 = r _2 $.</p>
<p>这就可以保证代入数值操作.因为我们考虑存在唯一的多项式$q $和唯一一个$s \in R $满足$f = ( x - \alpha ) q + s $,那我们就可以称$f ( \alpha ) = s $.</p>
<p>另外,定义在域$F $上的多项式$F [ x ] $是UFD,原因是可以两边对某一个根作长除法.</p>
<h4><span id="多元多项式环">多元多项式环</span></h4><p>显然,$R [ x _1 , \cdots , x _n ] \cong ( R [ x _1 , \cdots , x _{ n - 1  } ] ) [ x _n ] $.</p>
<h4><span id="不可约多项式">不可约多项式</span></h4><p>不可约多项式,也就是定义在域上的多项式环上的不可约元.换言之如果$f $是不可约的,那么对于$f $的任何一个分解$f = g _1 g _2 $,都一定有$g _1 \in F ^\times $或者$g _1 \in F ^\times $.</p>
<h5><span id="本原多项式">本原多项式</span></h5><p>为何我们定义不可约多项式的时候需要定义在域上,而不是简单定义在整环上呢?这是因为,例如,$2 x \in \mathbb { Z  } [ x ] $,它并非是一个不可约元.但只要把$\mathbb { Z  } $扩成$\mathbb { Q  } $,它就成为了一个不可约元.</p>
<p>那么在整数上怎么搞呢?我们考虑设$f = a _0 + \cdots + a _n x ^n \in \mathbb { Z  } [ x ] \setminus \{ 0 \} $,并设$c ( f ) = | \gcd ( a _0 , \cdots , a _n ) | $,如若$c ( f ) = 1 $,则称其是一个<strong>本原多项式</strong>.</p>
<p>接下来我们有<strong>高斯引理</strong>:如果$g , h \in \mathbb { Z  } [ x ] $都是本原多项式,那么$gh $也是本原多项式.</p>
<p>如何证明?考虑对于任何一个素数$p $,我们找到$g $中的最高次系数不被$p $整除,设为$r $.换言之设$g = \sum _{ k \geq 0  } a _k x ^k $,则$\forall k &gt; r , p | a _k $,而$p \nmid a _r $.对$f = \sum _{ k \geq 0  } b _k x ^k $同样根据上面找到一个最高次$s $,满足$p \nmid b _s $.</p>
<p>现在观察:</p>
<script type="math/tex; mode=display">
\begin{aligned}
[ x ^{ r + s  } ] gh \\
& = \sum _{ i + j = r + s  } a _i b _j & \equiv a _r b _s \pmod { p  } \\
\ne 0 \pmod { p  } 
\end{aligned}</script><p>这就搞定.</p>
<p>另一个证明策略是干脆把$\mathbb { Z  } \to \mathbb { Z  } / p \mathbb { Z  } $,后者是一个域,于是可以见到其非零.其实和上面是同一个想法,也许后者在做完映射后更好描述.</p>
<p>高斯引理的推论是$c ( gh ) = c ( g ) c ( h ) $.</p>
<p>接下来我们来搞一些$\mathbb { Q  } $上的结构,我们下面来证明,对于本原多项式来说,只要其在$\mathbb { Q  } [ x ] $上可约,那它就在$\mathbb { Z  } [ x ] $上可约.换言之,假设$f \in \mathbb { Z  } \setminus \{ 0 \} $是本原多项式,如果$f = gh $,其中$g , h \in \mathbb { Q  } [ x ] , \deg g &gt; 0 , \deg h &gt; 0 $,那我们断言$\exists \alpha \in \mathbb { Q  } ^\times $使得$g _1 = \alpha g , h _1 = \alpha ^{ - 1  } h $使得$g _1 , h _1 \in \mathbb { Z  } [ x ] $且它们都是本原多项式.</p>
<p>考虑总存在一对$u , v \in \mathbb { N  } _+ $使得$ug , vh \in \mathbb { Z  } [ x ] $,此时有:</p>
<script type="math/tex; mode=display">
uv = c ( uvf ) = c ( ugvh ) = c ( ug ) c ( vh )</script><p>所以:</p>
<script type="math/tex; mode=display">
f = \frac { ugvh  } { uv  } = \frac { ug  } { c ( ug )  } \frac { vh  } { c ( vh )  }</script><p>这就搞定.</p>
<p>还有一条性质是说,假设$f \in \mathbb { Z  } \setminus \{ 0 \} $是本原多项式,当$\deg f &gt; 0 $的时候,下面两个命题等价:</p>
<ol>
<li><p>$f $是$\mathbb { Q  } [ x ] $上的不可约多项式.</p>
</li>
<li><p>$f $是$\mathbb { Z  } [ x ] $上的不可约多项式.</p>
</li>
</ol>
<p>(1)$\Rightarrow $(2)的话考虑反证,如若存在$\mathbb { Z  } [ x ] $上的$g , h $使得$f = gh $,那$f $在$\mathbb { Z  } [ x ] $上都可约,当然在$\mathbb { Q  } [ x ] $上可约.</p>
<p>(2)$\Rightarrow $(1)的话仍然考虑反证,如果存在$\mathbb { Q  } [ x ] $上的$g , h $使得$f = gh $,那之前的推论告诉我们$f $可以分解为两个本原多项式的乘积,这就矛盾了.</p>
<p>接下来我们证明$\mathbb { Z  } [ x ] $是一个UFD,在此之前,我们先对$\mathbb { Z  } [ x ] $上的不可约元做分类,我们断言其分为以下两种:</p>
<ol>
<li><p>$\mathbb { Z  } $的不可约元.</p>
</li>
<li><p>$\deg f &gt; 0 $并且满足$f $作为$\mathbb { Q  } [ x ] $上的不可约元的本原多项式$f $.</p>
</li>
</ol>
<p>首先$\deg f = 0 $的情况自然是(1),下面尝试分类$\deg f &gt; 0 $的情况.</p>
<p>如若$c ( f ) \ne 1 $,当然有$f = c ( f ) \frac { f  } { c ( f )  } $,因此可约.所以不可约当且仅当$c ( f ) = 1 $,也就是$f $得是一个本原多项式.那就知道其不可约性可以从$\mathbb { Q  } [ x ] $过渡到$\mathbb { Z  } [ x ] $上.</p>
<p>最终我们来说明$\mathbb { Z  } [ x ] $是唯一分解的,首先可以提系数使得只对本原多项式说明唯一分解性.</p>
<p>既然如此,考虑如果$f $可以被分解为两种$a _1 \cdots a _r $和$b _1 \cdots b _s $两种,它们都是本原多项式,乘积后亦然,其中$a _i , b _i $均满足$\deg &gt; 0 $,那么直接扩域到$\mathbb { Q  } [ x ] $上,由于定义在域上的多项式有唯一分解行,因此$s = r $而且适当重排后$a _i $和$b _i $差了一个$\mathbb { Q  } ^\times $,然而两个本原多项式如果差了一个$\mathbb { Q  } ^\times $,当然意味着它俩只差一个正负号,这是显然的,就给出了分解的唯一性.</p>
<p>接下来有<strong>Eisenstein判准</strong>,不妨设$n \geq 1 $,而$f = \sum _{ k = 0  } ^n a _k x ^k \in \mathbb { Z  } [ x ] $,如果存在一个素数$p $满足$p \nmid a _n $,而且$p | a _0 , \cdots , a _{ n - 1  } $,并且$p ^2 \nmid a _0 $,则$f $是$\mathbb { Q  } [ x ] $中的不可约多项式.</p>
<p>为证明此,考虑既然$p \nmid a _n $,那当然$p \nmid c ( f ) $,因此,我们可以将$f $调整为$\frac { f  } { c ( f )  } $,这并不会对$p $的性质产生影响,而可以将$f $化约成本原多项式的情形.</p>
<p>如何证明呢?考虑反证,对本原多项式来说$\mathbb { Q  } [ x ] $上不可约等价于在$\mathbb { Z  } [ x ] $上不可约,假设此情形下$f = gh $,其中$g = \sum _{ k = 0  } ^m b _k x ^k , h = \sum _{ k = 0  } ^l c _k x ^k $,其中$l , m &gt; 0 $,而且$g , h \in \mathbb { Z  } [ x ] $.</p>
<p>既如此,注意到$a _n = b _m c _l $,因此一定有$p \nmid b _m , p \nmid c _l $.而又有$p | a _0 = b _0 c _0 $,不妨假设$p | b _0 $.此时,可以取一个$1 \leq k \leq m $,使得$p | b _0 , \cdots , p | b _{ k - 1  } $但是有$p \nmid b _k $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _k & \equiv 0 \pmod { p  } \\
\sum _{ j = 0  } ^k b _j c _{ k - j  } & \equiv 0 \pmod { p  } \\
b _k c _0 & \equiv 0 \pmod { p  } 
\end{aligned}</script><p>所以$p | c _0 $,所以$p ^2 | a _0 = b _0 c _0 $,矛盾.</p>
<p>我们可以在此基础上证明一些有趣的结论:</p>
<ol>
<li><p>$\forall n \geq 1 $,$p $是质数,则$p + x ^n $是不可约的.</p>
</li>
<li><p>$p $是质数,则$\Phi _p = 1 + x + \cdots + x ^{ p - 1  } = \frac { x ^p - 1  } { x - 1  } $是不可约的.</p>
</li>
</ol>
<p>对于(2),考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Phi _p & = \frac { x ^p - 1  } { x - 1  } \\
& = \frac { ( x - 1 + 1 ) ^p - 1  } { x - 1  } \\
& = \frac { \sum _{ k = 0  } ^p \binom { p  } { k  } ( x - 1 ) ^k - 1  } { x - 1  } \\
& = \sum _{ k = 1  } ^p \binom { p  } { k  } ( x - 1 ) ^{ k - 1  } 
\end{aligned}</script><p>取$h ( x ) = \sum _{ k = 1  } ^p \binom { p  } { k  } x ^{ k - 1  } $,则$\Phi _p ( x ) = h ( x - 1 ) $,显然,二者的不可约性是等价的,下面观察$h ( x ) $的不可约性.然而$h ( x ) $当然满足Eisenstein判准,这就搞定.</p>
<p>这里可以见到,其实上面的过程可以全部挪到某个UFD以及与其配套的分式域上,均可以起效果.而且也可以看到在某一个UFD上定义的多项式环也一定是UFD.</p>
<h5><span id="一个判定不可约的算法">一个判定不可约的算法</span></h5><p>考虑判定一个$f $是否可以被拆成两个$f = gh $,并且它们都在$\mathbb { Z  } [ x ] $上,其中$\deg g \leq k $.</p>
<p>如何判断呢?首先我们任取不同的$x _0 , \cdots , x _k \in \mathbb { Z  } $,并取$f ( x _0 ) , \cdots , f ( x _k ) $,如果它们中有$0 $就完工了对吧.如果没有,我们一定有$g ( x _i ) | f ( x _i ) $,因此$g ( x _i ) $只有有限种可能性.我们枚举所有的可能性并插值判$g $.这就给出了一个有限次实现的算法.</p>
<h5><span id="不可约多项式上的扩域">不可约多项式上的扩域</span></h5><p>如果域$F $上的多项式$f \in F [ x ] $可以分解为若干个一次多项式的乘积,则称其可<strong>分裂</strong>.</p>
<p>那么如果定义在一个域上的每个$\deg \geq 1 $的多项式都分裂,那么就称这个域是<strong>代数闭</strong>的.</p>
<p>定义在域$F $上的多项式未必有根,但理应在其上面可以做扩域使其有根.具体而言我们对于域$F $,想要找到一个单同态$\varphi : F \to L $使得$L $是一个更大的域.而应当见到$L $实际上在某种意义上是定义在$F $上的向量空间.</p>
<p>在这里需要发现的是,定义在域上的$F [ x ] $一定是主理想整环,原因是可以在理想$I $中取出$\deg $最小的一个非零的$f $,那么其中的任何一个$g \in I $,用带余除法立刻得到$g = pf + r $,其中$\deg r &lt; \deg f , r \in I $,必然得到$r = 0 $.这意味着$I = ( f ) $.同时容易见到$\deg f = 0 $的时候,$( f ) = F [ x ] $.</p>
<p>我们尝试研究$F [ x ] / ( f ) $的形态,那么见到$\deg f \geq 1 $的时候这个形态应当才是有意义的.构造一个同态$\tau : F \to F [ x ] / ( f ) , a \mapsto a + ( f ) $,容易见到$\tau $应当是一个单射,原因是在$\deg f \geq 1 $的前提下,有$\ker \tau = \{ 0 \} $.此时应当见到$F [ x ] / ( f ) $可以看作一个定义在$F $上的向量空间.而运用代余除法得知$\{ 1 + ( f ) , x + ( f ) , \cdots , x ^{ \deg f - 1  } + ( f ) \} $显然给出了$F [ x ] / ( f ) $的一组基.</p>
<p>在此基础上,若$f = \sum a _k x ^k $,定义$f ^\varphi = \sum \varphi ( a _k ) \varphi ( x ) ^k $.</p>
<p>由于$F [ x ] $是主理想环,我们在之前已经证明过了当$f $不可约的时候,$F [ x ] / ( f ) $是一个域,令$E = F [ x ] / ( f ) $.回到我们一开始的目的.当$\deg f \geq 1 $,并且$f $在$F [ x ] $环上不可约的时候,若令$\alpha = x + ( f ) $,此时$\alpha $应作为一个$E $上的元素,注意到此时:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ^\tau ( x + ( f ) ) \\
& = \sum ( a _k + ( f ) ) ( x + ( f ) ) ^k \\
& = \sum a _k x ^k + ( f ) \\
& = f + ( f ) & = 0 + ( f ) 
\end{aligned}</script><p>这意味着在$E [ X ] $上$f ^\tau $是一个可约的多项式,因为提供了其一个元素$\alpha \in E $作为其的一个零点.</p>
<p>从上面的过程来看,我们理应可以通过若干次扩张使得一个$f $在某个$E _r [ X ] $上是分裂的,其中$r \leq \deg f $,也即每一次扩域次数都至少降低$1 $.</p>
<p>我们应当思考这个域扩大了多少,见到如果$\deg f = n $,我们一开始已经声明过此时选取基的大小,自然得到$[ E _r : F ] = [ E _r : E _{ r - 1  } ] \cdots [ E _1 : F ] \leq n ! $.</p>
<p>不过我们理应简单说明这样的构造是泛的,具体来讲,我们已经声明过我们需要构造一个交换环$L $并将$F $以环同态$\varphi : F \to L $的形式嵌入其中,并在环$L $中找到一个$\beta \in L $使得$f ^\varphi ( \beta ) = 0 $,那么此时应当存在一个唯一的环同态$\psi : E \to L $使得$\psi ( \alpha ) = \beta $,并且下面是一个交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { E \ar [r ] ^\psi & L \\
F \ar [u ] ^\tau \ar [ru ] _\varphi  }</script><p>考察商同态$\pi : F [ x ] \to E = F [ x ] / ( f ) $,将此关系嵌入上述图表应当得到上述图表交换的等价条件是下述图表交换:</p>
<script type="math/tex; mode=display">
\xymatrix { F [ x ] \ar [r ] ^\pi & E \ar [r ] ^\psi & L \\
& F \ar [ul ] \ar [u ] ^\tau \ar [ru ] _\varphi  }</script><p>直接令$\Psi = \psi \pi $,上图可以简化为:</p>
<script type="math/tex; mode=display">
\xymatrix { F [ x ] \ar [rr ] ^\Psi & & L \\
& F \ar [ul ] \ar [ru ] _\varphi  }</script><p>现在观察此结构,若我们一开始的假设成立,此图表的确交换并且满足求值同态$\Psi ( x ) = \psi ( \pi ( x ) ) = \psi ( \alpha ) = \beta $,那么对于一般的多项式$g = \sum b _k x ^k $,立刻得到$\Psi ( g ) = \sum \varphi ( b _k ) \beta ^n = g ^\varphi ( \beta ) $,这立刻得到了$\Psi $的唯一性,而直接使用此同态容易证明其存在性.</p>
<p>这个交换图表有什么用呢?来看其在复数上的表现情况.取$F = \mathbb { R  } $并且$f = x ^2 + 1 $,此时$- 1 $自然出现了平方根$\alpha = x + ( x ^2 + 1 ) $.此时在上述图表中只需简单规定$i $具体的正负取值立刻得到一个$\mathbb { R  } [ x ] / ( x ^2 + 1 ) \cong \mathbb { C  } $的同构.</p>
<h4><span id="对称多项式">对称多项式</span></h4><p>将置换的定义,挪到多元多项式环上,具体而言,$\sigma f ( x _1 , \cdots , x _n ) = f ( x _{ \sigma ( 1 )  } , \cdots , x _{ \sigma ( n )  } ) $.</p>
<p>那么,如果带$n $个变元的多项式$f $其对任意置换都不变,换言之$\forall \sigma , \sigma f = f $,则称其是一个<strong>对称多项式</strong>.</p>
<p>我们记$F [ x _1 , \cdots , x _n ] ^S $为所有在域$F $上定义的$n $个变元的对称多项式组成的集合,其当然是$F [ x _1 , \cdots , x _n ] $上的一个子环,因为如果$f , g $对称,那么$fg $和$\alpha f + \beta g $亦然.从这里也可以见到其还是一个线性空间.</p>
<p>接下来定义$e _k = \sum _{ 1 \leq i _1 &lt; \cdots &lt; i _k \leq n  } x _{ i _1  } \cdots x _{ i _k  } $为第$k $个<strong>初等对称多项式</strong>,例如$e _n = x _1 \cdots x _n , e _1 = x _1 + \cdots + x _n $.并且还见到<strong>Vieta公式</strong>:$\prod _{ k = 1  } ^n ( y + x _k ) = \sum _{ k = 0  } ^n e _k y ^{ n - k  } $或写作$\prod _{ k = 1  } ^n ( y - x _k ) = \sum _{ k = 0  } ^n ( - 1 ) ^k e _k y ^{ n - k  } $</p>
<p>接下来我们要证明<strong>对称多项式基本定理</strong>,$\forall f \in F [ x _1 , \cdots , x _n ] ^S , \exists g \in F [ x _1 , \cdots , x _n ] , f = g ( e _1 , \cdots , e _n ) $.</p>
<p>接下来我们定义$f _d = \sum _{ i _1 + \cdots + i _n = d  } c _{ i _1 , \cdots , i _n  } x _1 ^{ i _1  } \cdots x _n ^{ i _n  } $为$d $<strong>齐次多项式</strong>,容易见到任何一个多项式都可以写成若干齐次多项式之和.定义$\deg f $为它分解出来的最大的可能非零齐次多项式的次数.</p>
<p>接下来我们证明一个引理:对于$f \in F [ x _1 , \cdots , x _n ] ^S $,则$f ( x _1 , \cdots , x _{ n - 1  } , 0 ) = 0 $的充分必要条件是$e _n | f $.</p>
<p>充分性显然,因为$x _n | e _n $.</p>
<p>必要性的话,如若$f ( x _1 , \cdots , x _{ n - 1  } , 0 ) = \sum _{ i _n = 0  } c _{ i _1 , \cdots , i _n  } x _1 ^{ i _1  } \cdots x _{ n - 1  } ^{ i _{ n - 1  }  } = 0 $,这也就意味着$c _{ i _1 , \cdots , i _n  } \ne 0 \Rightarrow i _n \geq 1 $,而由于对称,意味着$c _{ i _1 , \cdots , i _n  } \ne 0 \Rightarrow i _k \geq 1 $,这就说明了$e _n | f $.</p>
<p>对$n $元对称多项式$h $,记$h ^b = h ( x _1 , \cdots , x _{ n - 1  } , 0 ) $,观察到$h ^b $当然是$n - 1 $次多项式,而且$e _1 ^b , \cdots , e _{ n - 1  } ^b $正好是第$1 , \cdots , n - 1 $个初等$n - 1 $元对称多项式.</p>
<p>继续考虑证明对称多项式基本定理,首先对于$f = \sum f _d $来说,$f $是对称的当然等价于每一个$f _d $都是对称的,所以我们下面不妨假设$f = f _d $.</p>
<p>对于一个$g \in F [ x _1 , \cdots , x _n ] $,定义其权重为$wt ( g ) = \begin{cases}\max \{ \sum _{ k = 1  } ^n k i _k \mid c _{ i _1 , \cdots , i _n  } \ne 0 \} &amp; g \ne 0 \ - \infty &amp; g = 0 \end{cases} $.</p>
<p>容易见到$\deg g ( e _1 , \cdots , e _n ) \leq wt ( g ) $,这恰也是我们如此定义权重的原因.</p>
<p>下面我们证明:如果$f $是$d $次齐次的,则断言中的$g $不仅存在还能取到$wt ( g ) \leq d $.下面我们对$n + d $递归地论证.</p>
<p>当$d = 0 , f \in F $当然是平凡的,下面设$d \geq 1 $.由于数学归纳,我们知道$f ^b $的元数量减少了$1 $.</p>
<p>当$f ^b \ne 0 $时,那么如果$f $是$d $齐次的,容易见到$f ^b $也该是$d $齐次的,那此时数学归纳给出存在$g _1 \in F [ x _1 , \cdots , x _{ n - 1  } ] $使得$f ^b = g _1 ( e _1 ^b , \cdots , e _{ n - 1  } ^b ) $,而且$\deg g _1 ( e _1 , \cdots , e _{ n - 1  } ) \leq wt ( g _1 ) \leq d $.</p>
<p>此时设$f _1 = f - g _1 ( e _1 , \cdots , e _{ n - 1  } ) $,立刻见到$f _1 ^b = 0 $,那么$e _n | f _1 $,取$f _2 = \frac { f _1  } { e _n  } $,这里就可以看到如若$f ^b = 0 $,这里直接取$f _1 = f , g _1 = 0 $即可.所以上述讨论在这一步就消掉了.</p>
<p>于是,这里的$f _2 $当然也是对称多项式,并且$\deg f _2 \leq d - n $,那将其分解为齐次部分的和,运用递归假设知道存在$f _2 = g _2 ( e _1 , \cdots , e _n ) , wt ( g _2 ) \leq d - n $.此时:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f & = f _1 + g _1 ( e _1 , \cdots , e _{ n - 1  } ) \\
& = e _n g _2 ( e _1 , \cdots , e _n ) + g _1 ( e _1 , \cdots , e _{ n - 1  } ) 
\end{aligned}</script><p>这就搞定了.</p>
<p>另一个问题是,上述算法只搞定了$f = g ( e _1 , \cdots , e _n ) $的存在性,它是否有唯一性呢?如若有$g ( e _1 , \cdots , e _n ) = h ( e _1 , \cdots , e _n ) $,则$( g - h ) ( e _1 , \cdots , e _n ) = 0 $.我们应当证明以下定理,称为$e _1 , \cdots , e _n $的<strong>代数无关性</strong>:</p>
<p>若$g \in F [ x _1 , \cdots , x _n ] $满足$g ( e _1 , \cdots , e _n ) = 0 $,则$g = 0 $.</p>
<p>考虑证明其逆否命题,也就是$g \ne 0 $的话就一定有$g ( e _1 , \cdots , e _n ) \ne 0 $.</p>
<p>首要的观察是先扩域,如果这个定义在更大的域上满足,在更小的域上当然也满足.因此可以先一步将$F $扩到一个无穷域上,例如直接将其扩到有理分式域$F ( t ) $上.下面假设$F $是无穷域.则此时对于任意有限次数非零多项式$g = 0 $,一定存在一组$( y _1 , \cdots , y _n ) $使得$g ( y _1 , \cdots , y _n ) \ne 0 $,这是因为可以数学归纳,当$n = 1 $的时候,其最多只有$\deg g $个根但是$F $无限,因此肯定存在.当$n &gt; 1 $的时候,直接取$g = \sum g _k x _n ^k $,那么由归纳假设一定存在一组$( y _1 , \cdots y _{ n - 1  } ) $使得至少有一个$g _k \ne 0 $,此时再由$n = 1 $的结论就可以知道原命题成立.</p>
<p>接下来考虑$p = \sum _{ k = 0  } ^n x ^{ n - k  } ( - 1 ) ^k y _k $,回忆到可以扩域使得该多项式分裂,假设分裂成了$p = \prod _{ k = 1  } ^n ( x - x _i ) $,此时由于Vieta公式,$p = \sum _{ k = 0  } ^n ( - 1 ) ^k e _k ( x _1 , \cdots , x _n ) x ^{ n - k  } $,于是$e _k ( x _1 , \cdots , x _n ) = y _k $,这就导出了$g ( e _1 , \cdots , e _n ) = g ( y _1 , \cdots , y _n ) \ne 0 $.</p>
<p>容易见到上述论证不涉及域中的除法,所以上述结论对整环也是成立的.</p>
<h5><span id="牛顿公式">牛顿公式</span></h5><p>设$p _k = \sum _{ j = 1  } ^n x _j ^k $,这里的$p _0 $其实比较特殊,我们一般不去讨论$p _0 $.那么牛顿公式说:</p>
<ol>
<li><p>当$1 \leq k \leq n $的时候,$\sum _{ j = 0  } ^{ k - 1  } ( - 1 ) ^j e _j p _{ k - j  } = ( - 1 ) ^{ k - 1  } k e _k $.</p>
</li>
<li><p>当$k &gt; n $的时候,$\sum _{ j = 0  } ^n ( - 1 ) ^j e _j p _{ k - j  } = 0 $.</p>
</li>
</ol>
<p>牛顿公式的一个相当大的作用是可以用递归的方式用$\{ e _k \} $和$\{ p _k \} $相互表示.更进一步地,可以用$\{ e _k \} $的整系数多项式表示$\{ p _k \} $也可以用$\{ p _k \} $的有理系数多项式表示$\{ e _k \} $,当然对应的域要包含$\mathbb { Z  } $和$\mathbb { Q  } $.</p>
<p>如何证明上面那个结论?考虑以$y $为变元的形式幂级数,定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
P ( y ) & = \sum _{ k \geq 1  } p _k y ^{ k - 1  } \\
& = \sum _{ k \geq 1  } \sum _{ i = 1  } ^n x _i ^k y ^{ k - 1  } \\
& = \sum _{ i = 1  } ^n \frac { x _i  } { 1 - x _i y  } 
\end{aligned}</script><p>再定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( y ) & = \sum _{ k = 0  } ^n e _k y ^k \\
& = \prod _{ i = 1  } ^n ( 1 + x _i y ) 
\end{aligned}</script><p>接下来观察到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
P ( - y ) & = \sum _{ i = 1  } ^n \frac { x _i  } { 1 + x _i y  } \\
& = \frac { \mathrm { d  }  } { \mathrm { d  } y  } \ln E ( y ) \\
& = \frac { E ' ( y )  } { E ( y )  } 
\end{aligned}</script><p>接下来观察:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( y ) P ( - y ) & = E ' ( y ) \\
& = \sum _{ k = 1  } ^n k e _k y ^{ k - 1  } 
\end{aligned}</script><p>可是左边直接展开就有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( y ) P ( - y ) & = ( \sum _{ l = 0  } ^n e _l ( - y ) ^l ) ( \sum _{ j \geq 1  } p _j y ^{ j - 1  } ) \\

\end{aligned}</script><p>两边提取$[ y ^{ k - 1  } ] $,就有:</p>
<script type="math/tex; mode=display">
\sum _{ l + j = k , 0 \leq l \leq n , j \geq 1  } e _l p _{ j  } ( - 1 ) ^{ j - 1  } = k e _k</script><p>两边倒腾一下正负号就是牛顿公式.</p>
<h4><span id="结式">结式</span></h4><p>让$F $是一个域并且$f , g \in F [ x ] $,我们想要检验它们是否互素.一个好的算法当然是辗转相除法,但我们更想去找一个精确的量来判定.例如矩阵的行列式可以用消元法求,然而我们也可以用代数余子式展开.</p>
<p>具体地,考虑$F [ x ] $的元素:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f & = v _0 x ^n + \cdots + v _n \\
g & = w _0 x ^m + \cdots + w _m 
\end{aligned}</script><p>注意这里并不要求$v _0 , w _0 \ne 0 $,结式并不在乎这个.</p>
<p>我们定义$f , g $的<strong>结式</strong>为:</p>
<script type="math/tex; mode=display">
Res ( f , g ) = \left | \begin{matrix}
v _0 & \cdots & \cdots & v _n & & \\
& \ddots & & & \ddots & \\
& & v _0 & \cdots & \cdots & v _n \\
w _0 & \cdots & \cdots & w _m & & \\
& \ddots & & & \ddots & \\
& & w _0 & \cdots & \cdots & w _m 
\end{matrix} \right |</script><p>其中上面那个平行四边形是$m $行的,下面那个是$n $行的.这样总共就是$( n + m ) \times ( n + m ) $的,该行列式的定义是有意义的.如若将系数$v _0 , \cdots , w _m $视作变量,容易见到上述行列式仍然是关于$v _0 , \cdots , w _m $的整系数$n + m + 2 $元多项式,且系数和$F $无关.</p>
<p>考虑下述性质:</p>
<ol>
<li><p>$[ v _0 ^m w _m ^n ] Res ( f , g ) = 1 $.</p>
</li>
<li><p>$Res ( g , f ) = ( - 1 ) ^{ nm  } Res ( f , g ) $.</p>
</li>
<li><p>$\forall t \in F , Res ( tf , g ) = t ^m Res ( f , g ) , Res ( f , tg ) = t ^n Res ( f , g ) $.</p>
</li>
</ol>
<p>考虑(1),应当见到第$m $行的那个$v _0 $恰好是第$m $列,所以上述行列式对角线恰好由$m $个$v _0 $和$n $个$w _m $构成,根据行列式最初始的那个排列定义,要凑出$v _0 ^m w _m ^n $就只能沿着对角线乘.</p>
<p>考虑(2),只需要交换行列即可对吧,每次把$v $那里的最后一行暴力换到最下面,这样就需要交换$nm $次.</p>
<p>(3)是显然的.</p>
<p>接下来证明一个引理:如果$Res ( f , g ) = 0 $,当且仅当$\exists f _1 , g _1 \in F [ x ] $满足$\deg f _1 &lt; n , \deg g _1 &lt; m $并且$f _1 $和$g _1 $不全为$0 $,使得$fg _1 + gf _1 = 0 $.</p>
<p>不妨展开$f _1 $和$g _1 $如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _1 & = a _1 x ^{ n - 1  } + \cdots + a _n \\
g _1 & = b _1 x ^{ m - 1  } + \cdots + b _m 
\end{aligned}</script><p>如若设$H = fg _1 + gf _1 = 0 $,那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
[ x ^{ n + m - 1  } ] H & = b _1 v _0 + a _1 w _0 & = 0 \\
[ x ^{ n + m - 2  } ] H & = b _1 v _1 + b _2 v _0 + a _1 w _1 + a _2 w _0 & = 0 \\
\cdots \\
[ x ^{ 0  } ] H & = b _m v _n + a _n w _m & = 0 
\end{aligned}</script><p>如果假设$v _0 , \cdots , w _m $均是已知量而尝试求解$f _1 , g _1 $,自然拿到了一个大小为$n + m $的线性方程组,容易见到其系数矩阵为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
v _0 & & & w _0 & & \\
\vdots & \ddots & & \vdots & \ddots & \\
v _n & & v _0 & w _m & & w _0 \\
& \ddots & \vdots & & \ddots & \vdots \\
& & v _n & & & w _m 
\end{bmatrix}</script><p>(很遗憾这里把第$n + 1 $行和第$m + 1 $行画到一行了,然而是无奈之举,请读者自行在脑中错开一下位置)</p>
<p>线性方程组理论告诉我们这有一组非$0 $解当且仅当行列式为$0 $,然而这恰好是$Res ( f , g ) $的转置,而行列式转置不变,这就证毕.</p>
<p>下面我们证明,$Res ( f , g ) = 0 $当且仅当以下任何一个条件成立:</p>
<ol>
<li><p>$v _0 = w _0 = 0 $.</p>
</li>
<li><p>$\deg \gcd ( f , g ) &gt; 0 $.</p>
</li>
</ol>
<p>(1)是平凡的,只需观察上述行列式定义即可发现此时第一列全部为$0 $,那行列式当然为$0 $.</p>
<p>对于(2),先证必要性,考虑如果$\exists h , \deg h &gt; 0 $,$h | f , h | g $,那么注意到$\deg \frac { f  } { h  } &lt; n , \deg \frac { g  } { h  } &lt; m $而且由于$v _0 $和$w _0 $不全为$0 $,所以$\frac { f  } { h  } , \frac { g  } { h  } $不全为$0 $,而$f \frac { g  } { h  } - g \frac { f  } { h  } = 0 $,用引理得证$Res ( f , g ) = 0 $.</p>
<p>再证(2)的充分性.如若$f , g $其一为$0 $,不失一般性设$f = 0 $.如若此时$\deg g &gt; 0 $,则取$h = g $自然是公因式;如若$\deg g = 0 $,容易见到$w _0 = Res ( f , g ) = 0 $,这就是(1)的情况.</p>
<p>如若$f , g $都不是$0 $,而且$v _0 , w _0 $不全为$0 $,不妨设$w _0 \ne 0 $,既如此$g \ne 0 $,此时如若$Res ( f , g ) = 0 $,由引理拿到了$f _1 , g _1 $不全为$0 $并且使得$fg _1 + gf _1 = 0 $,其中$\deg g _1 &lt; m $.</p>
<p>直接把当前的多项式环$F [ x ] $扩到有理分式域$F ( x ) $,此时有$\frac { f  } { g  } g _1 = f _1 $,两边通分立刻见到,如果$\deg gcd ( f , g ) = 0 $,那么左边就是$f \frac { g _1  } { g  } $,这应该给出$g | g _1 $,然而$\deg g = m , \deg g _1 &lt; m $,不符.这就证毕.</p>
<p>最后,我们来讨论一下当$f , g $均是分裂的时候如何体现,不妨设$f = a \prod _{ k  } ^n ( x - \alpha _k ) , g = b \prod _{ k  } ^m ( x - \beta _k ) $,我们下面证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Res ( f , g ) & = a ^m \prod _k ^n g ( \alpha _k ) & = ( - 1 ) ^{ nm  } b ^n \prod _j ^m f ( \beta _j ) \\
& = a ^m b ^n \prod _{ k , j  } ( \alpha _k - \beta _j ) 
\end{aligned}</script><p>有一连串等式,其中中间两个是对称的$Res ( f , g ) $和$Res ( g , f ) $的形式,而最后一个等式只需带入就属显然.因此需要证明的只有第一个等式.</p>
<p>由于$Res ( tf , g ) = t ^m Res ( f , g ) $,所以不妨设$a = 1 $.</p>
<p>假设$g ( \alpha _1 ) , \cdots , g ( \alpha _n ) $两两相异,则引入一个新的变元$y $并在$F [ y ] $上考虑$Res ( f , g - y ) $,回看一开始的矩阵形状,对于$[ y ^n ] Res ( f , g - y ) $,见到其意味着下半部分的对角线被全部选择,上半部分选择的话如果非零当然也要选择对角线,所以$[ y ^n ] Res ( f , g - y ) = ( - 1 ) ^n $,而显然$[ y ^0 ] Res ( f , g - y ) = Res ( f , g ) $.既然如此,注意到$\alpha _k $是$f $和$g - g ( \alpha _k ) $的公共根,则$Res ( f , g - g ( \alpha _k ) ) = 0 $,从而$( g ( \alpha _k ) - y ) | Res ( f , g - y ) $,又由于$g ( \alpha _1 ) , \cdots , g ( \alpha _n ) $两两相异,$\prod _k ( g ( \alpha _k ) - y ) , Res ( f , g - y ) $的最高次系数都是$( - 1 ) ^n $,这立刻意味着它们相等,原命题自然成立.</p>
<p>然而既然如此,可以见到直接假设$\alpha _1 , \cdots , \alpha _n $并非常数而是若干个变元,具体而言用$z _1 , \cdots , z _n $代替它们,于是上述立刻有$g ( z _1 ) , \cdots , g ( z _n ) $两两相异,得到结论后带入$\alpha _1 , \cdots , \alpha _n $即可.</p>
<h4><span id="判别式">判别式</span></h4><p>对于一个多项式$f = \sum _k c _k ( - 1 ) ^{ k  } x ^{ n - k  } $,假设其可分裂而且$f = \prod _j ( x - \alpha _j ) $,我们称其判别式$disc ( f ) = \prod _{ i &lt; j  } ( \alpha _i - \alpha _j ) ^2 $如果我们将$\alpha _1 , \cdots , \alpha _n $看作变量,则我们注意到$disc ( f ) $是一个对称多项式,原因是$disc ( f ) = ( \prod _{ i &lt; j  } ( \alpha _i - \alpha _j ) ) ^2 $,而中间那个东西在重排后会差一个$\mathrm { { sgn  }  } ( \sigma ) $,这就证毕.</p>
<p>既然如此,$disc ( f ) $就可以拆成$e _1 , \cdots , e _n $这若干个对称多项式的多项式,然而注意到由于Vieta公式,$e _1 = c _1 , \cdots , e _n = c _n $.于是$disc ( f ) $当然是关于$c _1 , \cdots , c _n $的多项式.这里由于没有讨论具体的值,而只是把这些涉及到的值用变量来表示,所以你可以先一步把范围控制在整环$\mathbb { Z  } $上,见到$disc ( f ) $当然是关于$c _1 , \cdots , c _n $的整系数多项式.</p>
<p>例如当$n = 2 $的时候,$f ( x ) = x ^2 - bx + c = ( x - \alpha _1 ) ( x - \alpha _2 ) $,那么$disc ( f ) = ( \alpha _1 - \alpha _2 ) ^2 = ( \alpha _1 + \alpha _2 ) ^2 - 4 \alpha _1 \alpha _2 = b ^2 - 4 c $,这就是二次方程的判别式.</p>
<p>取$n = 3 $的时候,特别地取二次项为$0 $的情况,$f = x ^3 + px + q = ( x - \alpha _1 ) ( x - \alpha _2 ) ( x - \alpha _3 ) , \alpha _1 + \alpha _2 + \alpha _3 = 0 $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
disc ( f ) & = \left ( ( \alpha _1 - \alpha _2 ) ( \alpha _2 - \alpha _3 ) ( \alpha _1 - \alpha _3 ) \right ) ^2 \\
& = - 4 p ^3 - 27 q ^2 
\end{aligned}</script><p>而如果将判别式的定义推广到非首一的情形,也就是对于$f = a \prod _j ( x - \alpha _j ) $,我们称其判别式$disc ( f ) = a ^{ 2 n - 2  } \prod _{ i &lt; j  } ( \alpha _i - \alpha _j ) ^2 $,对$f $有形式导数$f ‘ $,我们下面证明:$a \cdot disc ( f ) = ( - 1 ) ^{ \frac { n ( n - 1 )  } { 2  }  } Res ( f , f ‘ ) $.</p>
<p>证明的话,用Leibniz法则,知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ' & = a \sum _{ k = 1  } ^n \prod _{ j \ne k  } ( x - \alpha _j ) \\
f ' ( \alpha _k ) & = a \prod _{ j \ne k  } ( \alpha _k - \alpha _j ) 
\end{aligned}</script><p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Res ( f , f ' ) & = a ^{ n - 1  } \prod _{ k = 1  } ^n f ' ( \alpha _k ) \\
& = a ^{ 2 n - 1  } \prod _{ k = 1  } ^n \prod _{ j \ne k  } ( \alpha _k - \alpha _j ) \\
& = a ^{ 2 n - 1  } ( - 1 ) ^{ \frac { n ( n - 1 )  } { 2  }  } \prod _{ i < j  } ( \alpha _i - \alpha _j ) ^2 
\end{aligned}</script><p>这就证毕.</p>
<p>顺便一提,将$f = a _0 x ^n + \cdots + a _n $,则$Res ( f , f ‘ ) $是$a _0 , \cdots , a _n $的整系数多项式,而其行列式首列能提出$a = a _0 $,因此$a ^{ - 1  } Res ( f , f ‘ ) $确实表作$a _0 , \cdots , a _n $的整系数多项式,这说明$disc ( f ) $在$f $非首一的时候定义确实合理.</p>
<h3><span id="域">域</span></h3><p>设$D $是含有至少两个元素的幺环,如果$D $的每个元素都可逆,则称$D $是一个<strong>体</strong>.有乘法交换律的体称为<strong>域</strong>.</p>
<h4><span id="分式域">分式域</span></h4><p>之前尝试使用过商集来用$\mathbb { Z  } $构造$\mathbb { Q  } $,我们同样可以用整环的商集来构造形如$\frac { f  } { g  } $的域,将其记作$\text { Frac  } ( R ) $,也就是<strong>分式域</strong>.</p>
<p>可以说明如果$\varphi : R \rightarrow R ‘ $并且$\varphi ( R \setminus \{ 0 \} ) \subseteq R ‘ ^{ \times  } $,又取一个$i : R \rightarrow \text { Frac  } R $,那么存在唯一一个映射$\Phi : \text { Frac  } R \rightarrow R ‘ $的映射.更具体来说,只需验证$\Phi ( \frac { f  } { g  } ) \equiv \varphi ( f ) \varphi ( g ) ^{ - 1  } $即可(当然需要检验良定义).</p>
<p>如果我们将一开始的映射改为$\varphi : R \hookrightarrow F $,其中$F $是一个域并且$\forall x \in F , \exists f , g \in R , x = \varphi ( f ) \varphi ( g ) ^{ - 1  } $,那我们可以证明$\text { Frac  } ( R ) \cong F $,过程太无聊,略过.</p>
<p>这说明分式域具有某种唯一性和泛性质.</p>
<p>一般把$\text { Frac  } ( R [ x ] ) $写作$R ( x ) $.</p>
<h4><span id="子域">子域</span></h4><p>由于子域的交还是子域,我们当然可以取所有子域的交得到一个子域$F _{ prime  } $,容易验证当$\text { char  } F _{ prime  } = 0 $的时候,$F _{ prime  } \cong \mathbb { Q  } $;当$p = \text { char  } F _{ prime  } \in prime $的时候,$F _{ prime  } \cong \mathbb { Z  } / \mathbb { Z  } _p $.</p>
<h2><span id="线性代数">线性代数</span></h2><h3><span id="矩阵引入">矩阵引入</span></h3><p>我们称有$m $行$n $列的<strong>矩阵</strong>为$A _{ m \times n  } $,其中第$i $行第$j $列的元素称作$a _{ i , j  } $,也有的称其为<strong>矩阵元</strong>.</p>
<p>也可以将其中中的列写作$F ^m $中列向量的形式,即写作$A _{ m \times n  } = \begin{bmatrix}\vec { a _1  } &amp; \vec { a _2  } &amp; . . . &amp; \vec { a _n  } \end{bmatrix} $.</p>
<p>若$n = m $,则称$A $为<strong>方阵</strong>.</p>
<h4><span id="矩阵运算">矩阵运算</span></h4><p>大小相同的矩阵本身应当是一个线性空间.事实上,我们可以定义:</p>
<ol>
<li><p><strong>矩阵加法</strong>:若矩阵$A $和$B $都是$m \times n $矩阵,则它们的和也是$m \times n $矩阵,且元素为$A $和$B $中对应元素的加和.显然有交换律.</p>
</li>
<li><p><strong>标量乘法</strong>:若$c $是标量而$A $是一个$m \times n $矩阵,则$cA $是一个$m \times n $矩阵,且元素为A中对应元素的$c $倍.显然有交换律以及对矩阵加法的分配律.</p>
</li>
</ol>
<p>事实上,我们还可以定义:</p>
<ol>
<li><strong>矩阵乘法</strong>:若$A $是$m \times n $矩阵,$B $是$n \times p $矩阵,那么它们的乘积$AB _{ i , j  } = \sum _{ k = 1  } ^n A _{ i , k  } B _{ k , j  } $.</li>
</ol>
<p>矩阵乘法也可以表示为:若$A $是$m \times n $矩阵,$B $是$n \times p $矩阵,且$B = \begin{bmatrix}\vec { b _1  } &amp; \vec { b _2  } &amp; . . . &amp; \vec { b _p  } \end{bmatrix} $那么它们的乘积$AB = \begin{bmatrix}A \vec { b _1  } &amp; A \vec { b _2  } &amp; . . . &amp; A \vec { b _p  } \end{bmatrix} $.</p>
<p>若$AB = BA $我们称$A $和$B $彼此<strong>可交换</strong>.</p>
<p>不难发现$\forall A _{ m \times n  } $,对于矩阵$I _{ n \times n  } = \begin{bmatrix}1 &amp; 0 &amp; . . . &amp; 0 \ 0 &amp; 1 &amp; . . . &amp; 0 \ . . . &amp; . . . &amp; . . . &amp; . . . \ 0 &amp; 0 &amp; . . . &amp; 1 \end{bmatrix} $有$AI = A $,我们称$I _{ n \times n  } $为<strong>单位矩阵</strong>.单位矩阵的第$i $列通常记作$\vec { e  } _i $.</p>
<p>定义<strong>乘幂</strong>$A ^k $为$k $个$A $连续相乘的乘积.</p>
<p>设$A $为$m \times n $矩阵,$B $和$C $的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol>
<li><p>乘法结合律:$( AB ) C = A ( BC ) $.</p>
</li>
<li><p>乘法左分配律:$A ( B + C ) = AB + AC $.</p>
</li>
<li><p>乘法右分配律:$( B + C ) A = BA + CA $.</p>
</li>
<li><p>$c ( AB ) = ( cA ) B = A ( cB ) $.</p>
</li>
<li><p>乘法恒等式:$I _m A = A = AI _n $.</p>
</li>
</ol>
<p>注意到向量可以看为一个$n \times 1 $的矩阵,事实上,我们有:</p>
<p>若$A $是$m \times n $矩阵,它的各列为$\vec { a _1  } , \vec { a _2  } , . . . \vec { a _n  } $,而$\vec { u  } , \vec { v  } \in \mathbb { R  } ^n $,那么:</p>
<ol>
<li><p>$A ( \vec { u  } + \vec { v  } ) = A \vec { u  } + A \vec { v  } $.</p>
</li>
<li><p>$A ( c \vec { u  } ) = c ( A \vec { u  } ) $.</p>
</li>
</ol>
<p>定义<strong>矩阵转置</strong>:对于$m \times n $矩阵$A $,它的<strong>转置</strong>是一个$n \times m $矩阵,该矩阵的列是由$A $的对应行构成的,记作$A ^T $,即$A ^T _{ i , j  } = A _{ j , i  } $.有的时候也写作$^t A $.</p>
<p>设$A $和$B $的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol>
<li><p>$( A ^T ) ^T = A $.</p>
</li>
<li><p>$( A + B ) ^T = A ^T + B ^T $.</p>
</li>
<li><p>$( rA ) ^T = rA ^T $.</p>
</li>
<li><p>$( AB ) ^T = B ^T A ^T $.</p>
</li>
</ol>
<h4><span id="分块矩阵">分块矩阵</span></h4><p>我们考虑将一个矩阵看作若干个子矩阵的拼接,类似于我们求逆矩阵时做的那样:将若干个矩阵拼接起来.</p>
<p>换句话说,我们尝试将矩阵看作元素放入矩阵中,并尝试根据基本的矩阵运算去做这种矩阵的运算.</p>
<p>分块矩阵的<strong>矩阵加法</strong>:若矩阵$A $和$B $维数相同且都以同样的方式分块,则矩阵的和$A + B $也以同样的方式分块且每一块都是$A $和$B $对应块的和.</p>
<p>分块矩阵的<strong>标量乘法</strong>:若$c $是一个常数,$A $是一个分块矩阵,则$cA $是$A $的子矩阵乘$c $再以同样的方式组合起来的结果.</p>
<p>分块矩阵的<strong>矩阵乘法</strong>:若矩阵$A $和$B $的维数使得$AB $有定义,并且$A $列的分法与$B $行的分法一致,那我们显然可以直接将矩阵作为元素来直接进行矩阵乘法.</p>
<p>由上面的讨论自然发现:</p>
<p>若$A $是$m \times n $矩阵,$B $是$n \times p $矩阵,我们定义$row _i ( A ) $为$A $的第$i $列,$col _i ( A ) $为$A $的第$i $行,则:</p>
<p>$AB = \begin{bmatrix}col _1 ( A ) &amp; col _2 ( A ) &amp; . . . &amp; col _n ( A ) \end{bmatrix} \begin{bmatrix}row _1 ( B ) \ row _2 ( B ) \ . . \ row _n ( B ) \end{bmatrix} $</p>
<p>证明是显然的.</p>
<h3><span id="线性方程组">线性方程组</span></h3><p>包含变量$x _1 , x _2 . . . , x _n $的<strong>线性方程</strong>是形如$a _1 x _2 + a _2 x _2 + . . . + a _n x _n = b $的方程,其中b与系数是实数或复数,通常是已知数.</p>
<p><strong>线性方程组</strong>是由一个或几个包含相同变量$x _1 , x _2 , . . . , x _n $的线性方程组成的.</p>
<p><strong>线性方程组的解</strong>是一组数$\{ s _1 , s _2 , . . . , s _n \} $,用这组数分别代替$x _1 , x _2 , . . . x _n $时所有方程的两边相等.</p>
<p>线性方程组所有可能的解的集合称为<strong>线性方程组的解集</strong>.</p>
<p>若两个线性方程组有相同的解集,则称这两个方程组是<strong>等价的</strong>.</p>
<p>我们称一个线性方程组是<strong>相容的</strong>,当且仅当它有一个解或无穷多个解,否则,称其为<strong>不相容的</strong>.</p>
<p>一个线性方程组要么无解,要么有一个解,要么有无穷多个解.</p>
<h4><span id="系数矩阵和增广矩阵">系数矩阵和增广矩阵</span></h4><p>考虑以下m个线性方程所组成的线性方程组:</p>
<script type="math/tex; mode=display">
\begin{cases}
a _{ 1 , 1  } x _1 + a _{ 1 , 2  } x _2 + . . . + a _{ 1 , n  } x _n = b _1 \\
a _{ 2 , 1  } x _1 + a _{ 2 , 2  } x _2 + . . . + a _{ 2 , n  } x _n = b _2 \\
. . . \\
a _{ m , 1  } x _1 + a _{ m , 2  } x _2 + . . . + a _{ m , n  } x _n = b _m 
\end{cases}</script><p>我们称它的<strong>系数矩阵</strong>为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a _{ 1 , 1  } & a _{ 1 , 2  } & . . . & a _{ 1 , n  } \\
a _{ 2 , 1  } & a _{ 2 , 2  } & . . . & a _{ 2 , n  } \\
. . . & . . . & . . . & . . . \\
a _{ m , 1  } & a _{ m , 2  } & . . . & a _{ m , n  } 
\end{bmatrix}</script><p>两个系数矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<p>而称它的<strong>增广矩阵</strong>为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a _{ 1 , 1  } & a _{ 1 , 2  } & . . . & a _{ 1 , n  } & b _1 \\
a _{ 2 , 1  } & a _{ 2 , 2  } & . . . & a _{ 2 , n  } & b _2 \\
. . . & . . . & . . . & . . . & . . . \\
a _{ m , 1  } & a _{ m , 2  } & . . . & a _{ m , n  } & b _m 
\end{bmatrix}</script><p>两个增广矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<h4><span id="矩阵的初等行变换">矩阵的初等行变换</span></h4><p>考虑如何解一个线性方程:根据我们已有的知识,等式可以任意两端加减相等的两项,也可以同时乘以一个不为0的数,同时等式的顺序并不重要.</p>
<p>我们用这一点来考虑如何解线性方程组.这里主要是考虑如何对线性方程组的增广矩阵进行变换.</p>
<p>由上面的知识,我们意识到对线性方程组的增广矩阵进行以下变换,是不会改变其解集的:</p>
<ol>
<li><p>(倍加变换)把某一行换成它本身与另一行的倍数的和,记作$R _i + kR _j \rightarrow R _i $.</p>
</li>
<li><p>(对换变换)把两行对换,记作$R _i \leftrightarrow R _j $.</p>
</li>
<li><p>(倍乘变换)把某一行的所有元素乘以同一个非零数$k $,记作$kR _i \rightarrow R _i , k \ne 0 $.</p>
</li>
</ol>
<p>以上三种变换称为<strong>矩阵的初等行变换</strong>,同理可以定义初等列变换.</p>
<p>由此可以发现,两个增广矩阵是等价的当且仅当其中一个增广矩阵可以通过若干次初等行变换变为另一个增广矩阵.</p>
<p>我们可以使用这些初等行变换来变换一个矩阵,使得它有一些特殊性质.</p>
<p>如果两个矩阵可以通过若干次初等行变换而转化,我们称二者<strong>行等价</strong>,不难证明行等价满足等价关系的三个性质(反身性,对称性,传递性).</p>
<p>由于简化行阶梯矩阵的唯一性,我们可以用其来判定行等价类.</p>
<h4><span id="阶梯形矩阵">阶梯形矩阵</span></h4><p>若矩阵的一行的元素全为0,称这一行为矩阵的一个<strong>零行</strong>,否则称为<strong>非零行</strong>.</p>
<p>非零行的最左边的非零元素称为该行的<strong>先导元素</strong>.</p>
<p>若一个矩阵有以下性质,则称它为<strong>阶梯形矩阵(REF)</strong>:</p>
<ol>
<li><p>每一个非零行都在零行之上</p>
</li>
<li><p>某一行的先导元素所在的列位于前一行先导元素的右边</p>
</li>
<li><p>某一先导元素所在列下方元素都是0</p>
</li>
</ol>
<p>若一个矩阵还满足以下性质,则称它为<strong>简化阶梯形(RREF)</strong>:</p>
<ol>
<li><p>每一非零行的先导元素是1</p>
</li>
<li><p>每一先导元素1是该元素所在列唯一的非零元素</p>
</li>
</ol>
<p>显然,任意一个矩阵都可以通过若干次初等行变换变为一个阶梯形矩阵或简化阶梯形矩阵.</p>
<p>一个矩阵所对应的阶梯形矩阵中先导元素的位置,被称为这个矩阵的一个<strong>主元位置</strong>,包含一个主元位置的列称为<strong>主元列</strong>.</p>
<p>注意:这里的位置是矩阵中的位置而非元素的位置,这也就是说主元位置上的元素可以不是最终的主元位置上的元素移动而来的.</p>
<h5><span id="简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</span></h5><p>每个矩阵通过初等行变换只有可能对应唯一一个简化阶梯形矩阵.</p>
<p>证明:假设两个行等价的简化阶梯形矩阵不相等.那么我们找到它们的第一个不相等的列,设为$j $.</p>
<p>如果$A , B $中的$j $均为主元列,显然它们这一列必然相等,不符.</p>
<p>反之,我们不妨去掉第$j $列后面的所有列以及第$j $列前面的所有非主元列,保留第$j $列考虑剩下的两个矩阵一定也是行等价的,但它们对应的线性方程组的解显然不同,这导出了矛盾.</p>
<h4><span id="解线性方程组">解线性方程组</span></h4><p>考虑将线性方程组的增广矩阵通过初等行变换变换为一个简化阶梯形矩阵,我们称对应于主元列的变量为<strong>基本变量</strong>,其它变量称为<strong>自由变量</strong>.</p>
<p>如果线性方程组是相容的,显然我们可以使用自由变量表示基本变量,从而得到一组解.我们得到的基本变量的关于自由变量的表达式称作解集的<strong>参数表示</strong>.</p>
<p>这也意味着,如果没有自由变量,该方程组只有一解;如果有自由变量,由于自由变量取值任意,该方程组有无数组解.</p>
<p>而考虑何时线性方程组不相容,由于自由变脸取值任意,显然唯一的不相容可能性只是出现了$0 x _1 + 0 x _2 + . . . + 0 x _n = b , b \ne 0 $的情况.</p>
<p>以上的分析过程引出下面的定理.</p>
<h5><span id="存在与唯一性定理">存在与唯一性定理</span></h5><p>线性方程组相容的充要条件是增广矩阵的最右列不是主元列.</p>
<p>若线性方程组相容,则它的解集可能有两种情形:</p>
<ol>
<li><p>没有自由变量时,只有一个解.</p>
</li>
<li><p>有自由变量时,有无数个解.</p>
</li>
</ol>
<h4><span id="矩阵方程">矩阵方程</span></h4><p>设$A $是$m \times n $的矩阵,它的各列是$\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } $,若$\vec { x  } $是$F ^n $中向量,则$A \vec { x  } $即A的各列以$\vec { x  } $中对应元素为权的线性组合,也就是:</p>
<p>$A \vec { x  } = \begin{bmatrix}\vec { a _1  } &amp; \vec { a _2  } &amp; . . . &amp; \vec { a _n  } \end{bmatrix} \begin{bmatrix}x _1 \ x _2 \ . . . \ x _n \end{bmatrix} = x _1 \vec { a _1  } + x _2 \vec { a _2  } + . . . + x _n \vec { a _n  } $</p>
<p>如果令$\vec { b  } \in F ^m $,那么上式可以写成$A \vec { x  } = \vec { b  } $,我们把形如这样的方程称作矩阵方程.</p>
<p>不难发现,若$A $是$m \times n $矩阵,它的各列为$\vec { a _1  } , \vec { a _2  } , . . . \vec { a _n  } $,而$\vec { b  } \in F ^m , \vec { x  } \in F ^n $,那么:</p>
<p>矩阵方程$A \vec { x  } = \vec { b  } $,向量方程$x _1 \vec { a _1  } + x _2 \vec { a _2  } + . . . + x _n \vec { a _n  } = \vec { b  } $,增广矩阵为$\begin{bmatrix}\vec { a _1  } &amp; \vec { a _2  } &amp; . . . &amp; \vec { a _n  } &amp; \vec { b  } \end{bmatrix} $的线性方程组有相同的解集.</p>
<p>事实上,若$A $是$m \times n $矩阵,它的各列为$\vec { a _1  } , \vec { a _2  } , . . . \vec { a _n  } $,那么以下命题逻辑等价:</p>
<ol>
<li><p>$\forall \vec { b  } \in F ^m $,方程$A \vec { x  } = \vec { b  } $有解.</p>
</li>
<li><p>$\forall \vec { b  } \in F ^m $,$\vec { b  } $是$A $的列的一个线性组合.</p>
</li>
<li><p>$A $的各列生成$\mathbb { R  } ^m $.</p>
</li>
<li><p>$A $在每一行都有一个主元位置.</p>
</li>
</ol>
<h4><span id="齐次线性方程组">齐次线性方程组</span></h4><p>若一个线性方程组可以被写成$A \vec { x  } = \vec { 0  } $的形式,其中$A $是$m \times n $的矩阵,$\vec { x  } $是$\mathbb { R  } ^n $中的向量,称其为<strong>齐次线性方程组</strong>.</p>
<p>显然齐次线性方程组至少有一个解,即$\vec { x  } = \vec { 0  } $,这个解称作线性齐次方程组的<strong>平凡解</strong>.</p>
<p>而满足$\vec { x  } \ne \vec { 0  } $的解称作线性齐次方程组的<strong>非平凡解</strong>.</p>
<p>根据存在与唯一性定理,显然其存在非平凡解的充要条件是该方程至少有一个自由变量.</p>
<p>考虑自由变量的取值任意,而且基本变量一定是由若干个自由变量乘以定值之和得到的.</p>
<p>我们把这些定值看作向量,把自由向量看作权重,我们发现:齐次线性方程组的解集总可以表示为$\mathrm { Span  } \{ \vec { v _1  } , \vec { v _2  } , . . . , \vec { v _{ p  }  } \} $,当然,如果该方程组仅有平凡解,那表示为$\mathrm { Span  } \{ \vec { 0  } \} $.</p>
<p>把解表示为$\mathrm { Span  } \{ \vec { v _1  } , \vec { v _2  } , . . . , \vec { v _{ p  }  } \} $中元素的形式,称之为<strong>解的参数向量形式</strong>.</p>
<p>对于方程$A \vec { x  } = \vec { b  } $,它的解一定可以写成$\vec { x  } = \vec { p  } + \vec { x ‘  } $的形式,其中$\vec { x ‘  } $是方程$A \vec { x  } = \vec { 0  } $的一组解,$\vec { p  } $是方程$A \vec { x  } = \vec { b  } $的一组特解.</p>
<p>对于该定理的几何意义,我们考虑$\vec { x  } \in \mathbb { R  } ^2 $中,即$\vec { x  } = \vec { p  } + t \vec { u  } $,如果我们把它看为向量加法的形式,它的解集应该是在一条直线上的任意向量,这条直线即$\vec { u  } $所在直线沿向量$\vec { p  } $方向平移后的直线.</p>
<h3><span id="线性空间">线性空间</span></h3><p>我们可以在一个域$F $上定义一个<strong>线性空间</strong>(向量空间)$V $,除了域本身带有的性质(加法的结合律交换律,加法单位元,加法逆元,乘法对加法有分配律)它应当满足以下公理:</p>
<ol>
<li><p>定义向量加法$V \times V \rightarrow V $.向量加法应当有交换律和结合律.</p>
</li>
<li><p>定义标量乘法$F \times V \rightarrow V $.标量乘法应当有交换律,结合律以及对向量加法的分配律.</p>
</li>
<li><p>存在加法幺元以及加法逆元.</p>
</li>
</ol>
<p>由于$V $对加法构成群,相应的性质可以从群的性质搬过来.</p>
<p>值得一提的是,其实标量乘法如果定义成$V \times F \rightarrow V $后会有相当多的好处,但是由于历史原因一般还是定义左标量乘法.</p>
<p>当然容易验证我们平常用的线性空间$V = F ^n $满足以上性质.</p>
<p>当然容易验证定义在域上的多项式环满足以上性质.</p>
<h4><span id="相关运算">相关运算</span></h4><h5><span id="直积">直积</span></h5><p>定义$\prod _{ i \in I  } V _i = ( \vec { v  } _i ) _{ i \in I  } , \vec { v  } _i \in V _i $为直积,容易发现线性空间的直积也是线性空间.</p>
<h5><span id="直和">直和</span></h5><p>我们如果取直积的一个子空间,使得至多只有有限个$i \in I $使得$\vec { v  } _i \ne 0 $,则称这是一个直和.</p>
<h5><span id="叉乘">叉乘</span></h5><p>对$\mathbb { R  } ^3 $,定义新的向量运算:向量积(叉乘)$\vec { a  } \times \vec { b  } $, 其运算结果仍为向量,设为$\vec { c  } $,它的模定义为$\vec { a  } \times \vec { b  } = | \vec { a  } | | \vec { b  } | \sin \theta $,其中$\theta $为向量$\vec { a  } , \vec { b  } $的夹角,$| \vec { c  } | $为以$a , b $为两边的平行四边形的面积,$\vec { c  } $的方向定义为与$\vec { a  } , \vec { b  } $所形成的平面垂直,且$\vec { a  } , \vec { b  } , \vec { c  } $构成右手螺旋定则(即现将四指指向$\vec { a  } $方向再将四指弯曲指向$\vec { b  } $的方向,则此时大拇指的方向为$\vec { c  } $的方向),</p>
<p>向量叉乘满足以下性质:</p>
<ol>
<li><p>$\vec { a  } \times \vec { b  } = - \vec { b  } \times \vec { a  } $.</p>
</li>
<li><p>$\vec { a  } \times \vec { a  } = \vec { 0  } $</p>
</li>
<li><p>$\vec { a  } \times ( \vec { b  } + \vec { c  } ) = \vec { a  } \times \vec { b  } + \vec { a  } \times \vec { c  } $.</p>
</li>
</ol>
<p>在三维坐标系中,设:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\vec { a  } & = a _1 \vec { i  } + b _1 \vec { j  } + c _1 \vec { k  } \\
\vec { b  } & = a _2 \vec { i  } + b _2 \vec { j  } + c _2 \vec { k  } 
\end{aligned}</script><p>由叉乘定义,得到:$\vec { c  } = ( a _y b _z - a _z b _y ) \vec { i  } + ( a _z b _x - a _x b _z ) \vec { j  } + ( a _x b _y - a _y b _x ) \vec { k  } $.也就是:</p>
<script type="math/tex; mode=display">
\vec { c  } = \vec { a  } \times \vec { b  } = \left | \begin{matrix}
\vec { i  } & \vec { j  } & \vec { k  } \\
a _x & a _y & a _z \\
b _x & b _y & b _z 
\end{matrix} \right |</script><p>对于任意一个面的法向量，我们总可以选取该面上的两个不共线向量来直接叉乘出来.</p>
<h4><span id="线性无关与线性相关">线性无关与线性相关</span></h4><p>称$V $中一组向量$\{ \vec { v _1  } , \vec { v _2  } , . . . , \vec { v _p  } \} $是<strong>线性无关</strong>的,当且仅当向量方程$x _1 \vec { v _1  } + x _2 \vec { v _2  } + . . . + x _p \vec { v _p  } = \vec { 0  } $仅有平凡解.</p>
<p>反之,称为<strong>线性相关</strong>,即存在一组不全为0的数$c _1 , c _2 , . . . , c _p $使$c _1 \vec { v _1  } + c _2 \vec { v _2  } + . . . + c _p \vec { v _p  } = \vec { 0  } $,这个式子也被称为$\{ \vec { v _1  } , \vec { v _2  } , . . . , \vec { v _p  } \} $之间的<strong>线性相关关系</strong>.</p>
<p>容易发现,两个或更多向量的集合$S = \{ \vec { v _1  } , \vec { v _2  } , . . . , \vec { v _p  } \} $线性相关,当且仅当其中至少有一个向量是其它向量的线性组合.</p>
<h4><span id="子空间">子空间</span></h4><p>我们定义$V $的一个<strong>子空间</strong>是它的一个非空子集$V _0 $,具有以下三个性质:</p>
<ol>
<li><p>$\vec { 0  } \in V _0 $.</p>
</li>
<li><p>$\forall \vec { u  } , \vec { v  } \in V _0 , \vec { u  } + \vec { v  } \in V _0 $.</p>
</li>
<li><p>$\forall \vec { u  } \in V _0 , c \in F , c \vec { u  } \in V _0 $.</p>
</li>
</ol>
<p>线性空间的两个平凡子空间当然是零空间和它本身.</p>
<p>容易验证两个子空间的交仍然是子空间.</p>
<h5><span id="向量的线性组合">向量的线性组合</span></h5><p>给定$V $中向量$\vec { v  } _1 , \vec { v  } _2 , . . . , \vec { v  } _p $和标量$c _1 , c _2 , . . . , c _p \in F $.</p>
<p>我们称向量$\overrightarrow { y  } = c _1 \overrightarrow { v _1  } + c _2 \overrightarrow { v _2  } + . . . + c _p \overrightarrow { v _p  } $为向量$\overrightarrow { v _1  } , \overrightarrow { v _2  } , . . . , \overrightarrow { v _p  } $以$c _1 , c _2 , . . . , c _p $为权的<strong>线性组合</strong>.</p>
<p>对于向量$\overrightarrow { v _1  } , \overrightarrow { v _2  } , . . . , \overrightarrow { v _p  } $,我们称它们的所有线性组合所成的集合为$\mathrm { Span  } \{ \overrightarrow { v _1  } , \overrightarrow { v _2  } , . . . , \overrightarrow { v _p  } \} $,也称为由$\overrightarrow { v _1  } , \overrightarrow { v _2  } , . . . , \overrightarrow { v _p  } $所<strong>生成</strong>的$V $的子集,有时也记作$\langle \vec { v  } _1 , \vec { v  } _2 , \cdots , \vec { v  } _p \rangle $.</p>
<p>不难发现,$\mathrm { Span  } $集合是$V $的一个子空间,而且容易证明其是包含$\{ \vec { v  } _1 , \vec { v  } _2 , \cdots , \vec { v  } _p \} $的最小的子空间,所以我们又称其为由$\overrightarrow { v _1  } , \overrightarrow { v _2  } , . . . , \overrightarrow { v _p  } $所<strong>生成</strong>的子空间.</p>
<p>可以考虑一些特殊线性空间上$\mathrm { Span  } $的几何意义:</p>
<p>对于$\mathbb { R  } ^2 $,当$\vec { v _1  } $和$\vec { v _2  } $不在一条直线上的时候,$\mathrm { Span  } \{ \vec { v _1  } , \vec { v _2  } \} $显然对应了整个平面.</p>
<p>对于$\mathbb { R  } ^3 $,当$\vec { v _1  } $和$\vec { v _2  } $不在一条直线上的时候,$\mathrm { Span  } \{ \vec { v _1  } , \vec { v _2  } \} $显然对应了三维空间中的一个过$\vec { v _1  } , \vec { v _2  } $这两条直线的平面.</p>
<p>要判断$\overrightarrow { b  } $是否在$\mathrm { Span  } \{ \overrightarrow { v _1  } , \overrightarrow { v _2  } , . . . , \overrightarrow { v _p  } \} $中，即判断向量方程$x _1 \overrightarrow { v _1  } + x _2 \overrightarrow { v _2  } + . . . + x _p \overrightarrow { v _p  } = \overrightarrow { b  } $是否有解.</p>
<h5><span id="线性映射">线性映射</span></h5><p>映射$T : V \rightarrow W $是线性的,当且仅当它满足以下两个条件:</p>
<ol>
<li><p>对$T $的定义域中一切的向量$\vec { u  } , \vec { v  } $,满足$T ( \vec { u  } + \vec { v  } ) = T ( \vec { u  } ) + T ( \vec { v  } ) $.</p>
</li>
<li><p>对$T $的定义域中一切的向量$\vec { u  } $和数$c $,满足$T ( c \vec { u  } ) = cT ( \vec { u  } ) $.</p>
</li>
</ol>
<p>线性映射有以下性质:</p>
<ol>
<li><p>$T ( \vec { 0  } ) = \vec { 0  } $.</p>
</li>
<li><p>(叠加原理):$T ( c _1 \vec { v  } _1 + c _2 \vec { v  } _2 + . . . + c _p \vec { v  } _p ) = c _1 T ( \vec { v  } _1 ) + c _2 T ( \vec { v  } _2 ) + . . . + c _p T ( \vec { v  } _p ) $.</p>
</li>
</ol>
<p>称线性映射$T : V \rightarrow W $是<strong>可逆的</strong>或者<strong>同构的</strong>,当且仅当存在$T ^{ - 1  } : W \rightarrow V $.</p>
<p>我们可以验证$T ^{ - 1  } $也是线性映射,原因在于此时$T $是双射:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ^{ - 1  } ( \vec { w  } + \vec { w  } ' ) & = T ^{ - 1  } ( \vec { w  } ) + T ^{ - 1  } ( \vec { w  } ' ) \\
\Leftrightarrow \\
T ( T ^{ - 1  } ( \vec { w  } + \vec { w  } ' ) ) & = T ( T ^{ - 1  } ( \vec { w  } ) + T ^{ - 1  } ( \vec { w  } ' ) ) 
\end{aligned}</script><p>而且:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ^{ - 1  } ( t \vec { w  } ) & = tT ^{ - 1  } ( \vec { w  } ) \\
\Leftrightarrow \\
T ( T ^{ - 1  } ( t \vec { w  } ) ) & = T ( tT ^{ - 1  } ( \vec { w  } ) ) 
\end{aligned}</script><p>我们记$\text { Hom  } ( V , W ) $为所有的$V \rightarrow W $,并且其中的$V , W $都是定义在$F $上的线性空间的线性映射组成的集合.容易验证$\text { Hom  } ( V , W ) $构成$F $上的线性空间.特别地,定义$\text { End  } ( V ) = \text { Hom  } ( V , V ) $,容易发现$\text { End  } ( V ) $是对复合和加法操作一个环.</p>
<p>特别地,定义矩阵映射$T : F ^n \rightarrow F ^m $为$T ( \vec { x  } ) = A \vec { x  } $,其中$A $是一个$m \times n $的矩阵.矩阵映射显然是线性映射.</p>
<h5><span id="基和维数">基和维数</span></h5><p>$V $中子空间$H $的一组<strong>基</strong>是$H $中一个线性无关集,它生成$H $.</p>
<p>事实上,以下命题等价:</p>
<ol>
<li><p>$S $是$V $的一组基.</p>
</li>
<li><p>$S $是极小的能生成$V $的集合(不存在其的一个真子集能生成$V $).</p>
</li>
<li><p>$S $是极大的$V $中的线性无关集(不存在其的一个真张集线性无关).</p>
</li>
</ol>
<p>证明上列命题等价是容易的.</p>
<p>对于$F ^n $来说,其的基有更好的性质,我们称$\{ \vec { e  } _1 , . . . , \vec { e  } _n \} , \vec { e  } _i = \{ 0 , 0 , \cdots , 0 , 1 , 0 , \cdots \} $为$F ^n $的<strong>标准基</strong>.</p>
<p>对于$n \times m $的矩阵组成的线性空间,其当然也有一组标准基$\{ \vec { e  } _{ i , j  } \} $.</p>
<p>有如下结论:</p>
<ol>
<li><p>(承认选择公理)对于任何一个线性无关的子集$S $,存在一个基$\mathcal { B  } $使得$S \subseteq \mathcal { B  } $.特别地,取$S = \emptyset $可以说明任何一个线性空间总是有基.</p>
</li>
<li><p>(有限生成的情况)如果一个线性空间的子集$S $满足$| S | &gt; | \mathcal { B  } | $,其中$\mathcal { B  } $是一组有限大小的基,那么$S $线性相关.</p>
</li>
<li><p>如果一个线性空间有两组基$\mathcal { B _1  } , \mathcal { B _2  } $,那么$| \mathcal { B _1  } | = | \mathcal { B _2  } | $.</p>
</li>
</ol>
<p>现在考虑(1)的证明,拿出所有的线性无关的$T \supseteq S $并组成一个集合,用包含关系作为偏序关系,如果能证明其满足Zorn引理的条件,那当然可以取出一个极大的线性无关集合,这当然是一组基.为此我们取出一条链并且将上面的所有集合并起来得到一个集合$T ‘ $.此时就可以看出我们之前(几乎一笔略过的)要求从基扩张的时候只需要有限个元素的作用,它可以立刻断言$T ‘ $是一个线性无关集合.</p>
<p>(2)的证明是容易的,不妨设$n = | \mathcal { B  } | , m = | S | $,由于$m &gt; n $,这当然是一个$m $个变量的大小为$n $的方程组,当然存在不全为$0 $的解.</p>
<p>(3)的定义较为复杂,略过.</p>
<p>在上述定理的基础上,我们可以定义非零向量空间$V $的<strong>维数</strong>,记作$\dim V = | \mathcal { B  } | $,零子空间$\{ \vec { 0  } \} $的维数定义为$0 $.</p>
<p>一般而言,我们大部分情况下都只讨论有限生成的情况.</p>
<p>有限生成的情况,我们还有以下若干条定理:</p>
<ol>
<li>(基定理)设$H $是$V $的$p $维子空间,$H $中任何恰好由$p $个元素组成的线性无关集构成$H $的一个基.</li>
</ol>
<p>这当然是自然的,根据上面的推导,这个线性无关集合就是极大的线性无关集合.</p>
<ol>
<li>如果线性空间的子空间$V _0 \subseteq V $,那么$\dim V _0 \leq \dim V $.特别地,$V _0 = V \Leftrightarrow \dim V _0 = \dim V $.</li>
</ol>
<p>只需要继续在$V _0 $里面取基就可以了.</p>
<ol>
<li>$V $定义在域$F $上,如果$\dim V = n $,那么$V \cong F ^n $.</li>
</ol>
<p>考虑$F ^n $的一组标准基$\vec { e _1  } , \cdots \vec { e  } _n $,然后我们取出$V $的一组有序基$B = \{ \vec { v  } _1 , \cdots , \vec { v  } _n \} $,然后把$T : F ^n \rightarrow V , \sum k _i \vec { e  } _i \mapsto \sum k _i \vec { v  } _i $.接下要当然要验证良定义和双射,通过基的定义是显然的.</p>
<p>这可以引出所谓坐标表示,即:设$\mathcal { B  } = \{ \vec { b  } _1 , . . . , \vec { b  } _n \} $是$V $的一个基,则$\forall \vec { x  } \in V $,$\exists $唯一的一组$\{ c _1 , . . . , c _n \} $满足$\vec { x  } = c _1 \vec { b  } _1 + . . . + c _n \vec { b  } _n $.我们称$\begin{bmatrix}c _1 \ \vdots \ c _n \end{bmatrix} $是$\vec { x  } $的$\mathcal { B  } - $坐标向量,记作$[ x ] _{ \mathcal { B  }  } $,映射$x \mapsto [ x ] _{ \mathcal { B  }  } $称为由$\mathcal { B  } $确定的<strong>坐标映射</strong>.</p>
<p>事实上,如果我们记$P _{ \mathcal { B  }  } = \begin{bmatrix}\vec { b  } _1 &amp; \vec { b  } _2 &amp; \cdots &amp; \vec { b  } _n \end{bmatrix} $,则我们有$\vec { x  } = P _{ \mathcal { B  }  } [ x ] _{ \mathcal { B  }  } $.我们称$P _{ \mathcal { B  }  } $为$\mathcal { B  } $的坐标变换矩阵.</p>
<ol>
<li>线性映射由它在基上的作用完全确定.</li>
</ol>
<p>原因是考虑$V $的一组基$B = \{ \vec { v  } _1 , \cdots , \vec { v  } _n \} $,那么$T ( \sum k _i \vec { v  } _i ) = \sum k _i T ( \vec { v  } _i ) $.</p>
<ol>
<li>$\text { Hom  } ( V , W ) \cong W ^n $,其中$\dim V = n $.</li>
</ol>
<p>由(7),我们知道如果选定了$C = \{ \vec { w  } _1 , \cdots \vec { w  } _n \} $,则只需要考虑在基上的具体变换即可.</p>
<ol>
<li>(线性映射同构于矩阵映射)如果$V , W $都是定义在$F $上的线性空间,$\dim V = n , \dim W = m $,那么$\text { Hom  } ( V , W ) \cong W ^n \cong F ^{ m \times n  } $.更一般地,如果$V $的基的指标集是$J $,$W $的基的指标集是$I $.那么$\text { Hom  } ( V , W ) \cong F ^{ I \times J  } $.另外地,$\dim \text { Hom  } ( V , W ) = mn $.特殊地,$\text { End  } ( V ) \cong F ^{ n \times n  } $.</li>
</ol>
<p>由(6)(8)显然.</p>
<p>现在我们就可以拿出矩阵了,我们在$F $上定义$m \times n $的矩阵$M $,于是$\mathcal { M  } = \text { Hom  } ( V , W ) \cong M _{ m \times n  } $.</p>
<p>简单来说,如果$B = \{ \vec { v  } _1 , \cdots \vec { v  } _n \} $是$V $的一组基,$C = \{ \vec { w  } _1 , \cdots \vec { w  } _m \} $是$W $的一组基,我们事实上是把$\vec { v  } _j \mapsto \sum a _{ i , j  } \vec { w  } _i $.</p>
<ol>
<li>线性映射的复合同构于矩阵乘法.</li>
</ol>
<p>只需操演定义即可发现.</p>
<ol>
<li>如果$F $是$E $的子域,那么$E $是在$F $上的向量空间.同样,如果$V $是$E $的向量空间,那么$V $是$F $的向量空间.</li>
</ol>
<p>定义的简单操演.</p>
<ol>
<li>如果$V $是$E $的向量空间,基为$B $,$E $是$F $的向量空间,基为$C $.那么$V $是$F $的向量空间,而且基是$CB $.作为其的一个推论,如果我们定义$[ V : E ] = \dim _E V $,即在$E $上的$V $的维数.我们应当能见到$[ V : F ] = [ V : E ] [ E : F ] $.</li>
</ol>
<p>定义的简单操演.可以将这里理解为$[ V : F ] = \log _F V $这个样子.</p>
<h4><span id="可逆矩阵">可逆矩阵</span></h4><p>称一个$n \times n $的矩阵$A $是<strong>可逆的</strong>,当且仅当$\exists C _{ n \times n  } $满足$CA = AC = I _{ n  } $,我们记$C = A ^{ - 1  } $.其实也就是$F _{ n \times n  } $这个环上的可逆元.这当然意味着其对应的线性映射是可逆的,也就是其代表的线性映射是同构.</p>
<p>不可逆矩阵又被称为<strong>奇异矩阵</strong>.</p>
<p>事实上$m \times n $的矩阵$A $在$m \ne n $的时候当然是不可逆的,因为其代表的线性映射不可能是同构(不然两边的$\dim $应当相等,应当有$m = n $).</p>
<p>可逆矩阵有以下简单性质:</p>
<ol>
<li><p>若$A $是可逆方阵,则$A ^{ - 1  } $也可逆且$( A ^{ - 1  } ) ^{ - 1  } = A $.</p>
</li>
<li><p>若$A $和$B $都是可逆方阵,则$AB $也可逆且$( AB ) ^{ - 1  } = B ^{ - 1  } A ^{ - 1  } $.</p>
</li>
</ol>
<h5><span id="初等矩阵">初等矩阵</span></h5><p>将单位矩阵经过一次初等行变换得到的矩阵称作<strong>初等矩阵</strong>.</p>
<p>对任意$m \times n $矩阵进行初等行变换一定等价于将其左乘一个初等矩阵,原因在于只需要对单位矩阵验证以下性质即可.</p>
<ol>
<li>倍加变换:$R _i + kR _j \rightarrow R _i , i \ne j $:</li>
</ol>
<script type="math/tex; mode=display">
\begin{aligned}
E _{ x , y  } & = \begin{cases}
k & x = i , y = j \\
1 & x = y \\
0 & \text { Otherwise  } 
\end{cases} \\

\end{aligned}</script><ol>
<li>对换变换:$R _i \leftrightarrow R _j $:</li>
</ol>
<script type="math/tex; mode=display">
\begin{aligned}
E _{ x , y  } & = \begin{cases}
1 & x = i , y = j \\
1 & x = j , y = i \\
1 & x = y , x \ne i , x \ne j \\
0 & \text { Otherwise  } 
\end{cases} \\

\end{aligned}</script><ol>
<li>倍乘变换:$kR _i \rightarrow R _i , k \ne 0 $:</li>
</ol>
<script type="math/tex; mode=display">
\begin{aligned}
E _{ x , y  } & = \begin{cases}
k & x = y , x = i \\
1 & x = y , x \ne i \\
0 & \text { Otherwise  } 
\end{cases} \\

\end{aligned}</script><p>考虑如下事实:行变换是可逆的,那么初等矩阵显然是可逆的.</p>
<p>这引出下面的定理:</p>
<p>$n \times n $矩阵是可逆的,当且仅当$A $行等价于$I _n $,也即$A $可以通过一系列初等行变换变换为$I _n $.</p>
<p>如果$A $可以通过一系列初等行变换变换为$I _n $,根据初等矩阵的知识,这等价于:</p>
<p>$E _1 E _2 . . . E _p A = I _n $,由于初等矩阵显然可逆,我们有$A = ( E _1 E _{ 2  } . . . E _p ) ^{ - 1  } $,有$A ^{ - 1  } = ( E _1 E _2 . . . E _p ) $.</p>
<p>如果$A $是可逆矩阵,显然$A $的简化阶梯形是$I $,也即二者行等价.</p>
<p>由于初等矩阵转置后仍然是初等矩阵,所以$A $可逆等价于$A ^T $可逆.此时发现列变换等价于右乘初等矩阵.此外$( A ^T ) ^{ - 1  } = ( A ^{ - 1  } ) ^T $.</p>
<h5><span id="求解逆矩阵">求解逆矩阵</span></h5><p>若$A $可逆,我们考虑将$A $和$I $放在同一个$n \times 2 n $的矩阵中,记作$\begin{bmatrix}A &amp; I \end{bmatrix} $,它显然行等价于$\begin{bmatrix}I &amp; A ^{ - 1  } \end{bmatrix} $.</p>
<p>另外,考虑将$I $写作$\begin{bmatrix}\vec { e _1  } &amp; \vec { e _2  } &amp; . . . &amp; \vec { e _n  } \end{bmatrix} $的形式,则我们发现上述过程等价于求若干个形如$A \vec { x  } _i = \vec { e  } _i $的方程的解,并且$A ^{ - 1  } = \begin{bmatrix}\vec { x _1  } &amp; \vec { x _2  } &amp; . . . &amp; \vec { x _n  } \end{bmatrix} $.</p>
<h6><span id="example1lu分解">Example1(LU分解)</span></h6><p>考虑上面对一个矩阵做的过程,考虑把一个矩阵消成上三角的.在此过程中如果没有发生行交换操作,那所做的操作就是一列下三角的操作.因此可以把一个矩阵分解为$A = LU $.当然这里有一些条件才能进行,回头我们再讨论此.</p>
<h4><span id="核与像与秩">核与像与秩</span></h4><p>选取$T : V \rightarrow W $为线性映射,定义$\ker T = T ^{ - 1  } ( 0 ) $,$\text { im  }  T = T ( V ) $.</p>
<p>容易证明$\ker T $是$V $的线性子空间,$\text { im  }  T $是$W $的线性子空间.</p>
<p>对于任意$w \in \text { im  } T $,选取任意一个特解$v _0 \in V , T ( v _0 ) = w $,那么容易看出$T ^{ - 1  } ( w ) = v _0 + \ker T $.于是$T $是单射当且仅当$\ker T = \{ 0 \} $.</p>
<p>当$\dim V $有限的时候,我们有$\dim V = \dim \ker T + \dim \text { im  }  T $.</p>
<p>原因是可以选取$\text { im  }  T $的一组基$\{ \vec { w  } _1 , \cdots \vec { w  } _r \} $,找到其原像$B = \{ \vec { v  } _1 , \cdots , \vec { v  } _r \} $,再取$\ker T $的一组基$C = \{ \vec { u  } _1 , \cdots \vec { u  } _s \} $.</p>
<p>先来证明$B \cup C $是线性无关的.也就是考察$\sum a _j \vec { v  } _j + \sum b _i \vec { u  } _i = 0 $.此时两边取像,当然有$\sum a _j \vec { w  } _j + 0 = 0 $,于是所有的$a _j = 0 $.此时考虑$\ker T $是$V $的子空间,所以当$0 + \sum b _i \vec { u  } _i = 0 $的时候也可以推出所有的$b _i = 0 $.</p>
<p>再来证明它确实可以生成$V $.考虑$\forall \vec { v  } \in V $,首先$T ( \vec { v  } ) = \sum a _j \vec { w  } _j $,这当然是可以找到的.那么$T ( \vec { v  } - \sum a _j \vec { v  } _j ) = 0 $,于是$\vec { v  } - \sum a _j \vec { v  } _j \in \ker T $,于是$\vec { v  } - \sum a _j \vec { v  } _j = \sum b _i \vec { u  } _i $,这就证毕了.利用下面直和分解的原理也可以写作$\ker T \oplus \text { im  } T \cong V $.</p>
<p>而我们知道$T $的单性等价于$\dim \ker T = 0 $,满性等价于$\dim \text { im  }  T = \dim W = \dim V $,于是$\dim W = \dim V $时单性等价于满性.</p>
<p>这样的话我们定义一个线性映射的秩$\text { rk  }  T = \dim ( \text { im  }  T ) $.</p>
<p>我们来看一个特殊情况$T : F ^n \rightarrow F ^m $.那此时我们就可以定义这个映射所代表的矩阵$M $的秩.我们注意到$\text { im  }  T = \text { span  } \{ M \vec { e  } _1 , \cdots M \vec { e  } _{ n  } \} = \text { span  } \{ \vec { m  } _1 , \cdots , \vec { m  } _n \} $.也就是$\text { rk  }  M $其实就是列向量生成的空间的维度.特别地,如果$\text { rk  }  M = \min ( n , m ) $,那么我们称矩阵是满秩的.也就等于其消成简化阶梯型矩阵后的主元数量.那此时$\dim \ker T = n - \text { rk  }  M $.</p>
<p>容易从上面看出$\text { rk  } ( ST ) \leq \min ( \text { rk  } S , \text { rk  } T ) $.且当$T $是满的时候$\text { rk  } ( ST ) = \text { rk  } ( S ) $,当$S $是单的时候$\text { rk  } ( ST ) = \text { rk  } ( T ) $.</p>
<h5><span id="sylvester秩不等式">Sylvester秩不等式</span></h5><p>考虑$T : U \to V , S : V \to W $,则$\text { rk  } ( ST ) \geq \text { rk  }  S + \text { rk  }  T - \dim V = \text { rk  }  T - ( \dim V - \text { rk  }  S ) $.可以认为后者$\dim V - \text { rk  }  S $实际上是$S $这个映射所带来的维度损失($\ker S $),而这个损失有可能叠到$T $上也可能不叠到$T $上.</p>
<p>对于其证明,考虑$\text { rk  } ( ST ) $实际上应当是$S : \text { im  }  T \to W $的秩,这给出$\text { rk  } ( ST ) = \text { rk  }  T - \dim ( \text { im  }  T \cap \ker S ) $.</p>
<p>而$\dim ( \text { im  }  T \cap \ker S ) \leq \dim \ker S = \dim V - \text { rk  }  S $.于是得证.</p>
<p>其一个特例是$\text { rk  } ( ST ) = 0 $时给出$\dim V \geq \text { rk  }  S + \text { rk  }  T $.</p>
<p>在上述式子左右两边进行简单变形:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text { rk  } ( ST ) & \geq \text { rk  } \ T - \dim \ker S \\
\dim U - \text { rk  } ( T ) & \geq \dim U - \text { rk  } \ ( ST ) - \dim \ker S \\
\ker T + \ker S & \geq \ker ( ST ) 
\end{aligned}</script><p>换言之就是线性映射的$\ker $扩张的过程中可能会出现包含的情况,所以扩不到简单相加的情形.</p>
<h5><span id="frobenius秩不等式">Frobenius秩不等式</span></h5><p>有$\text { rk  } ( ABC ) \geq \text { rk  } ( AB ) + \text { rk  } ( BC ) - \text { rk  } B $.</p>
<p>不妨设$B : U \to V $,考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text { rk  } ( ABC ) & = \text { rk  } ( BC ) - \dim ( \text { im  } ( BC ) \cap \ker A ) \\
& \geq \text { rk  } ( BC ) - \dim ( \text { im  } ( B ) \cap \ker A ) \\

\end{aligned}</script><p>而我们事实上有$\text { rk  } ( AB ) = \text { rk  }  B - \dim ( \text { im  } B \cap \ker A ) $,于是上述式子得证.</p>
<p>仍然对上式进行变形:</p>
<script type="math/tex; mode=display">
\ker ( AB ) + \ker ( BC ) \geq \ker ( ABC ) + \ker ( B )</script><p>这个式子还不能简单从Sylvester不等式推导,但可以见到这仍然是关于$\ker $扩张上的意义.</p>
<h4><span id="对偶空间">对偶空间</span></h4><p>定义<strong>对偶空间</strong>$V ^* = \text { Hom  } ( V , F ) $(也可以记作$\check { V  } $),其中$V $是定义在$F $上的向量空间.对偶空间当然是线性空间.</p>
<p>当线性空间是有限维的时候.我们考虑以下事实:</p>
<p>取$V $的一组基$\cal B = \{ \vec { v  } _1 , \cdots , \vec { v  } _n \} $,我们考虑取$\check { v  } _i \in V ^\vee $使得$\check { v  } _i ( \vec { w  } ) = a _i $,当$\vec { w  } = \sum _j a _j \vec { v  } _j $.容易验证它们构成一组<strong>对偶基</strong>,这告诉我们$\dim V = \dim V ^\vee $.</p>
<p>特别地,当$V = F ^n $的时候,容易验证如果取标准基$\cal B $,那么得到的对偶基实际上等价于标准基的转置(也就是列向量改为行向量).这可能会给我们带来错觉,认为对偶空间无非是行向量组成的空间,但如此理解有所偏差.既然是向量空间,就应当理解为列向量,否则线性变换理解为矩阵乘法就会收到阻碍,只是其作用效果等价于先转置为行向量再作矩阵乘法.</p>
<p>如果$T : V \to W $是线性映射,那我们可以定义其<strong>转置映射</strong>$^t T : W ^\vee \to V ^\vee , \lambda \mapsto \lambda T $.容易验证转置映射仍然是线性映射.另外,如果$S , T $均是线性映射,那么$^t { ( ST )  } =  ^t { T  } ^t { S  } $.简单画一下交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [d ] \ar [r ] ^T & W \ar [d ] \\
\check { V  } & \check { W  } \ar [l ] _{ T ^t  }  }</script><p>我们接下来说明转置映射对应的矩阵是原映射的矩阵的转置.</p>
<p>不妨设$\dim V = n , \dim W = m $,原矩阵为$A _{ m \times n  } $.</p>
<p>接下来看它们分别对对应基的操作:</p>
<p>不妨设$T ( \vec { v  } _j ) = \sum a _{ i , j  } \vec { w  } _i $,则$^t T ( \check { w  } _i ) $代表一个映射:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\vec { v  } _k \mapsto \check { w _i  } T ( \vec { v  } _k ) \\
& = \check { w _i  } ( \sum _h a _{ h , k  } w _h ) \\
& = \sum _h a _{ h , k  } \check { w  } _i ( w _h ) \\
& = a _{ i , k  } \\
& = \sum _{ j  } a _{ i , j  } \check { v  } _j ( \vec { v  } _k ) 
\end{aligned}</script><p>因此$^t T ( \check { w  } _i ) = \sum _{ j  } a _{ i , j  } \check { v  } _j $.</p>
<p>如果我们将$\lambda $看成一个$1 \times m $的矩阵,那$\lambda \to \lambda T $不言自明为矩阵乘法.然而正是我们试图总是将空间表示为列向量,因此我们就自然带了一个转置,对于一个$\vec { v  } $,我们对它实际上求的是乘法$^t ( \lambda T ) \vec { v  } = ( ^t T ) ( ^t \lambda ) \vec { v  } $的结果,如此一来上述结论便显明了.</p>
<p>我们会在后面谈论矩阵的相抵的部分证明行秩等于列秩这一事实,然而,既然转置实际上表现了对偶空间上的性质,我们理应可以抛开矩阵本身而只从对偶空间的角度理解.换言之,取对偶基是一种非典范的无奈之举,我们会在讨论双线性形式的时候重新讨论于此.</p>
<h4><span id="直和分解与分块矩阵">直和分解与分块矩阵</span></h4><p>不妨取映射$\sigma : \bigoplus _{ i \in I  } V _i \to V , ( v _i ) _{ i \in I  } \mapsto \sum v _i $,其中$V _i $都是$V $的子空间.容易验证其当且仅当在$V _i \cap ( \sum _{ i \ne j  } V _j ) = \{ 0 \} $时是单射.我们将此称作其<strong>直和分解</strong>.如果不满足上述条件一般称作<strong>外直和</strong>,满足的话则称作<strong>内直和</strong>,并容易发现内直和$\bigoplus V _i \cong \sum V _i $.</p>
<p>外直和的一个经典应用是构造$\varphi : V _1 \oplus V _2 \to V , ( \vec { v  } _1 , \vec { v  } _2 ) \mapsto \vec { v  } _1 - \vec { v  } _2 $的映射,立刻得到$\ker \varphi = V _1 \cap V _2 , \text { im  }  \varphi = V _1 + V _2 $,于是$\dim V _1 + \dim V _2 = \dim ( V _1 \cap V _2 ) + \dim ( V _1 + V _2 ) $.这其实就是第二同构定理的维数表示.</p>
<p>接下来考虑$V = \bigoplus _{ i = 1  } ^n V _i , W = \bigoplus _{ j = 1  } ^m W _j $,我们可以断言$\text { Hom  } ( V , W ) \cong \bigoplus _{ 1 \leq i \leq n , 1 \leq j \leq m  } \text { Hom  } ( V _i , W _j ) $.这个的证明只需定义算子$p _i : \bigoplus _{ j  } V _j \to V , ( \vec { v  } _j ) _{ j \in J  } \mapsto \vec { v  } _i $即可.</p>
<p>对于对偶空间,事实上取$W = F $,就会有$V ^\vee \cong \bigoplus V _i ^\vee $.</p>
<p>接下来考虑映射的合成$T : U \to V , S : V \to W $.不妨设$U \cong \bigoplus U _k , V \cong \bigoplus _j V _j , W \cong \bigoplus _i W _i $,容易验证$( ST ) _{ i , k  } = \sum _{ j  } S _{ i , j  } T _{ j , k  } $.</p>
<p>此时我们终于意识到了这个东西应当同构于分块矩阵.更具体地,$\text { Hom  } ( V , W ) \cong A _{ n \times m  } , A _{ j , i  } \cong T _{ j , i  } , A _{ j , i  } \in M _{ m _j \times n _i  } , m _j = \dim W _j , n _i = \dim V _i $.</p>
<p>容易类比普通矩阵定义对角线分块矩阵,上(下)三角分块矩阵之类的东西.并且还容易发现上三角矩阵相乘后仍是上三角,对角线矩阵相乘后仍是对角线.</p>
<p>如果考虑$T \in \text { End  } ( V ) $,事实上对角线矩阵有相当漂亮的刻画,只需观察矩阵结构就可以发现此时$T ( V _i ) \subseteq V _i $.上三角矩阵有类似的刻画,观察矩阵结构也可以发现$T ( V _i ) \subseteq \bigoplus _{ j \leq i  } V _j $.</p>
<p>下面我们来证明对于上三角分块矩阵$A _{ r \times r  } $,如果对角线上的$A _{ i \times i  } $均可逆,那么$A _{ r \times r  } $的分块矩阵可逆,而且其逆的对角线上的矩阵是一列$A _{ i \times i  } ^{ - 1  } $.</p>
<p>考虑数学归纳,这样的话就只需要证明$\begin{bmatrix}A _{ 1 , 1  } &amp; A _{ 1 , 2  } \ 0 &amp; A _{ 2 , 2  } \end{bmatrix} $,其中$A _{ 1 , 1  } $和$A _{ 2 , 2  } $均可逆即可.容易发现取$\begin{bmatrix}A _{ 1 , 1  } ^{ - 1  } &amp; - A _{ 1 , 1  } ^{ - 1  } A _{ 1 , 2  } A _{ 2 , 2  } ^{ - 1  } \ 0 &amp; A _{ 2 , 2  } ^{ - 1  } \end{bmatrix} $即可.</p>
<p>那么反之成不成立呢?是不是此时按照合理的分块方式一定能得到对角线上的矩阵都可逆呢?也是可行的.假设$\begin{bmatrix}A _{ 1 , 1  } &amp; A _{ 1 , 2  } \ 0 &amp; A _{ 2 , 2  } \end{bmatrix} $可逆,其逆为$\begin{bmatrix}A _{ 1 , 1  } ‘ &amp; A _{ 1 , 2  } ‘ \ A _{ 2 , 1  } ‘ &amp; A _{ 2 , 2  } ‘ \end{bmatrix} $.容易发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}
A _{ 1 , 1  } ' & A _{ 1 , 2  } ' \\
A _{ 2 , 1  } ' & A _{ 2 , 2  } ' 
\end{bmatrix} \begin{bmatrix}
A _{ 1 , 1  } & A _{ 1 , 2  } \\
0 & A _{ 2 , 2  } 
\end{bmatrix} = \begin{bmatrix}
A _{ 1 , 1  } A _{ 1 , 1  } ' & \_ \\
\_ & \_ 
\end{bmatrix} \\
\begin{bmatrix}
A _{ 1 , 1  } & A _{ 1 , 2  } \\
0 & A _{ 2 , 2  } 
\end{bmatrix} \begin{bmatrix}
A _{ 1 , 1  } ' & A _{ 1 , 2  } ' \\
A _{ 2 , 1  } ' & A _{ 2 , 2  } ' 
\end{bmatrix} = \begin{bmatrix}
\_ & \_ \\
\_ & A _{ 2 , 2  } A ' _{ 2 , 2  } 
\end{bmatrix} \\

\end{aligned}</script><p>于是立刻见到$A _{ 1 , 1  } $和$A _{ 2 , 2  } $都有逆.</p>
<h4><span id="基的变换">基的变换</span></h4><h5><span id="矩阵的共轭相似">矩阵的共轭(相似)</span></h5><p>考虑线性映射$T : V \to W $,这个线性映射理应和所取的基无关,但如果我们想写出它的矩阵形式,写出来的矩阵当然取决于$V $和$W $取的基分别是什么(从而决定不同的坐标).不妨设$V , W $都是定义在$F $上的,维度分别为$n , m $.现在取它们的有序基$\mathcal { B  } = \{ \vec { v  } _1 , \cdots , \vec { v  } _n \} $,$\mathcal { C  } = \{ \vec { w  } _1 , \cdots , \vec { w  } _m \} $,这样就可以确定一个同构$\mathcal { M  } _{ \mathcal { B  } \to \mathcal { C  }  } : \text { Hom  } ( V , W ) \to M _{ m \times n  } $.再构造一个同构$\varphi _{ \mathcal { V  }  } : F ^n \to V , ( x _1 , \cdots , x _n ) \mapsto \sum x _i \vec { v  } _i $.然后我们可以画出如下交换图表(对其交换性的验证可以直接考虑对每个基验证交换性):</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^T & W \\
F ^n \ar [u ] ^{ \varphi _{ \mathcal { B  }  }  } \ar [r ] _{ \mathcal { M  } _{ \mathcal { B  } \to \mathcal { C  }  } ( T )  } & F ^m \ar [u ] _{ \varphi _{ \mathcal { C  }  }  }  }</script><p>如果我们尝试考虑更换它们的基,理论上说当然会得到不同的矩阵.换言之,我们取另一组有序基$\mathcal { B  } ‘ = \{ \vec { v  } _1 ‘ , \cdots , \vec { v  } _n ‘ \} , \mathcal { C  } ‘ = \{ \vec { w  } _1 ‘ , \cdots , \vec { w  } _m ‘ \} $,这样可以确定另一个同构$\mathcal { M  } _{ B ‘ \to C ‘  } $.我们下面试图探索二者之间的关系.</p>
<p>由于选取的有序基的方式不同,我们再构造一个$P _{ B ‘ \to B  } : ( F ^n ) ‘ \to F ^n , ( x ‘ _1 , \cdots , x ‘ _n ) \mapsto ( x _1 , \cdots x _n ) , \sum x ‘ _i \vec { v  } ‘ _i = \sum x _i \vec { v  } _i $,容易验证取$P _{ V ‘ \to V  } = { ( \varphi _V )  } ^{ - 1  } \varphi _{ V ‘  } $即可并且是自同构,并且$( P _{ V \to V ‘  } ) ^{ - 1  } = P _{ V ‘ \to V  } $.写成交换图表的话应当形如:</p>
<script type="math/tex; mode=display">
\xymatrix { & V & \\
( F ^n ) ' \ar [ru ] ^{ \varphi _{ \mathcal { B  } '  }  } \ar [rr ] _{ P _{ \mathcal { B  } ' \to \mathcal { B  }  }  } & & F ^n \ar [lu ] _{ \varphi _{ \mathcal { B  }  }  }  }</script><p>这里所有的箭头当然都是可逆的.</p>
<p>事实上,不妨设$\vec { v  } _i ‘ = \sum _{ j  } p _{ j , i  } \vec { v  } _j $,也就是将$\vec { v  } ‘ $展开成列向量,对于$\vec { x  } = \sum _{ i  } x ‘ _i \vec { v  } ‘ _i $,考虑$\sum _{ i  } x ‘ _i \vec { v  } ‘ _i = \sum _{ i  } x ‘ _i \sum _{ j  } p _{ j , i  } \vec { v  } _j = \sum _{ j  } \vec { v  } _j \sum _{ i  } x ‘ _i p _{ j , i  } = \sum _j \vec { v  } _j x _j $,那么$p _{ j , i  } $其实就是$P _{ \mathcal { B  } ‘ \to \mathcal { B  }  } $的对应矩阵的第$j $行$i $列元素.此时我们称$P _{ n \times n  } $为从有序基$\cal B ‘ \to \cal B $的<strong>转换矩阵</strong>.事实上容易见到转换矩阵都是可逆的,并且事实上所有的可逆矩阵都可以看作标准基对某个矩阵的转换矩阵.</p>
<p>这样的话,我们就容易见到:$\mathcal { M  } _{ B ‘ \to C ‘  } ( T ) = P _{ C \to C ‘  } \mathcal { M  } _{ B \to C  } ( T ) P _{ B ‘ \to B  } = ( P _{ C ‘ \to C  } ) ^{ - 1  } \mathcal { M  } _{ B \to C  } ( T ) P _{ B ‘ \to B  } $.这里一定要注意$\mathcal { M  } _{ B \to C  } $是一个将映射$T $变为矩阵$M $的映射.</p>
<p>具体地,我们可以看下面的交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { ( F ^n ) ' \ar [rrr ] ^{ \mathcal { M  } _{ B ' \to C '  } ( T )  } \ar [dd ] _{ P _{ B ' \to B  }  } \ar [rd ] ^{ \varphi _{ B '  }  } & & & ( F ^m ) ' \ar [dd ] ^{ P _{ C ' \to C  }  } \ar [ld ] _{ \varphi _{ C '  }  } \\
& V \ar [r ] ^T & W \\
F ^n \ar [rrr ] _{ \mathcal { M  } _{ B \to C  } ( T )  } \ar [ru ] _{ \varphi _B  } & & & F ^m \ar [lu ] ^{ \varphi _C  }  }</script><p>接下来我们考虑$T \in \text { End  } ( V ) $,自然可以导出$\mathcal { M  } _{ B ‘ \to B ‘  } ( T ) = P ^{ - 1  } \mathcal { M  } _{ B \to B  } ( T ) P $,其中$P = P _{ B ‘ \to B  } $.</p>
<p>于是综上,我们称两个矩阵$A _{ n \times n  } , B _{ n \times n  } $相似,当且仅当存在可逆矩阵$P _{ n \times n  } $使得$A = P ^{ - 1  } BP $.由上面可以看出来,相似的两个矩阵实际上是不同基下的同种变换.</p>
<p>另外我们注意到,固定$P _{ n \times n  } $后定义映射$P : M _{ n \times n  } \to M _{ n \times n  } , A \mapsto P ^{ - 1  } AP $不仅仅是线性同构,还是一个环同构.容易验证其满足环同构的性质.</p>
<p>此时注意到另一个事情:我们知道我们做共轭实际上是换基操作,那么如果我们需要换基,难道我们必须总是对着矩阵做矩阵乘法么?</p>
<p>事实上,我们应当观察如下矩阵:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
& \vec { e  } _1 & \cdots & \vec { e  } _n \\
\vec { e  } _1 & a _{ 1 , 1  } & \cdots & a _{ n , 1  } \\
\vdots & \cdots & \ddots & \vdots \\
\vec { e  } _n & a _{ 1 , n  } & \cdots & a _{ n , n  } 
\end{bmatrix}</script><p>最简单的改变,我们如果想要让它变成在另一组有序基下的操作,我们应当如何操作呢?如果我们带着这些向量去做,我们实际上可以发现:放在列上的这些向量随着列变换而操作,放在行上的这些向量随着行变换的逆变换而改变.这就是更加方便的做相似矩阵的办法.而这事实上也就是因为,任何一个可逆的矩阵都可以拆成若干初等矩阵,因此只需要将$P $拆成初等矩阵两边分别做就可以.初等矩阵求逆当然是平凡的.</p>
<h5><span id="矩阵的相抵">矩阵的相抵</span></h5><p>我们称两个矩阵$A $和$B $<strong>相抵</strong>,当且仅当$\exists P , Q $均可逆,$A = PBQ $.容易看出相抵是等价关系.由于可逆矩阵等价于若干初等矩阵的乘积,那么$A , B $相抵当且仅当$B $可以通过若干初等行变换和列变换变成$A $.下面我们证明$A , B $相抵等价于$\text { rk  }  A = \text { rk  }  B $.</p>
<p>$A , B $相抵的时候当然有$\text { rk  }  A = \text { rk  }  B $,因为此时$\text { rk  }  A = \dim \text { im ( PBQ )  } $,而$P , Q $都是同构,所以此时有$\text { rk  }  A = \dim \text { im  }  B = \text { rk  }  B $.</p>
<p>当$\text { rk  }  A = \text { rk  }  B = k $时,我们考虑二者都可以经过若干次行变换或者列变换变成形如$m _{ i , j  } = \begin{cases}1 &amp; i = j \leq k \ 0 &amp; \text { otherwise  } \end{cases} $.于是二者等价.</p>
<p>类似上面就可以发现$\text { rk  }  A = \text { rk  }  A ^T $,原因是二者都可以消成上述那种矩阵,而那种矩阵的主元数量显然是确定且相等的.</p>
<p>用矩阵的相抵可以更快证明Frobenius秩不等式,具体地,考虑分块矩阵$\begin{bmatrix}ABC &amp; 0 \ 0 &amp; B \end{bmatrix} $.考虑$\begin{bmatrix}I &amp; - A \ 0 &amp; I \end{bmatrix} \begin{bmatrix}ABC &amp; 0 \ 0 &amp; B \end{bmatrix} \begin{bmatrix}I &amp; 0 \ C &amp; I \end{bmatrix} = \begin{bmatrix}0 &amp; - AB \ BC &amp; B \end{bmatrix} $,于是我们知道$\begin{bmatrix}ABC &amp; 0 \ 0 &amp; B \end{bmatrix} $和$\begin{bmatrix}0 &amp; - AB \ BC &amp; B \end{bmatrix} $相抵.</p>
<p>而$\text { rk  }  \begin{bmatrix}ABC &amp; 0 \ 0 &amp; B \end{bmatrix} = \text { rk  }  ABC + \text { rk  }  B $,下面考虑证明$\text { rk  }  \begin{bmatrix}0 &amp; - AB \ BC &amp; B \end{bmatrix} \geq \text { rk  }  AB + \text { rk  }  BC $,而直接考虑$BC $和$AB $的行,$BC $中线性无关行和$AB $中线性无关行必定也线性无关,而原本线性相关的那些加上右下角的$B $也有可能变得线性无关,于是上述不等式就得证了.</p>
<h4><span id="商空间">商空间</span></h4><p>如果我们考虑在线性空间上定义等价关系$\vec { v  } _1 \sim \vec { v  } _2 \Leftrightarrow T \vec { v  } _1 = T \vec { v  } _2 $,其中$T $是一个线性映射,容易发现此时$\vec { v  } _1 - \vec { v  } _2 \in \ker T $.所以其实和$T $本身关系不大,而只和$\ker T $这个子空间有关.</p>
<p>那我们不妨设$U $是$V $的子空间,立刻发现$\vec { v  } _1 \sim \vec { v  } _2 \Leftrightarrow ( \vec { v  } _1 - \vec { v  } _2 ) \in U $是一个等价关系.</p>
<p>在此基础上定义<strong>陪集</strong>$\vec { v  } + U $,容易发现陪集组成了一个新的线性空间(当然要验证良定义),将其称作<strong>商空间</strong>,并且可验证映射$\varphi : V \to V / U , \vec { v  } \mapsto \vec { v  } + U $是线性映射.类比陪群,得知$\ker \varphi = U $,综合前面的讨论得知此时$\vec { v  } _1 \sim \vec { v  } _2 \Leftrightarrow \vec { v  } _1 + U = \vec { v  } _2 + U $.</p>
<p>顺便可以顺手引入<strong>余核</strong>$\text { coker  } ( T ) = W / \text { im  }  T $,容易发现$T $是满射当且仅当$\text { coker  } ( T ) = \{ 0 \} $.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5><p>下面来抛出另一个命题.对于线性映射$T : V \to W , \varphi : V \to V / U $,如果$U \subseteq \ker T $,那么存在唯一的线性映射$\bar { T  } : V / U \to W $.使得$T = \bar { T  } \varphi $.</p>
<p>这个证明看上去是相当正确的.由于$\varphi $是满射,那么必定有$\bar { T  } ( \vec { v  } + U ) = T \vec { v  } $,这是显然是唯一的映射,也容易看出其是正确的线性映射.具体来讲,存在唯一的线性映射$\bar { T  } $使得下图交换:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^T \ar [d ] _\varphi & W \\
V / U \ar [ru ] _{ \bar { T  }  }  }</script><p>在上述命题中如果$T $也是满射,也就是$W = \text { im  }  T $,取$U = \ker T $,那么此时$\bar { T  } \varphi = T $,这必定意味着$\text { im  }  \bar { T  } = W $.接下来考虑一下$\ker \bar { T  } $的模样,考虑$\bar { T  } ( \vec { v  } + U ) = 0 \Leftrightarrow T ( \vec { v  } ) = 0 \Leftrightarrow \vec { v  } \in U \Leftrightarrow \vec { v  } + U = U $,从而$\ker \bar { T  } = \{ U \} $,于是$\bar { T  } $是同构.</p>
<p>就可以发现对于一个线性映射$T $,$V / U = V / \ker T \cong \text { im  }  T $,这其实就是同态基本定理在线性空间上的表现.不过线性空间上还多一个标量乘法的运算,需要在群的基础上对此进行简单验证.另外线性空间上还有维数的概念,当然立即断言$\dim V = \dim U + \dim ( V / U ) $.值得一提的是这同样也告知我们$U $的基和$V / U $的反像的基合起来就是一组$V $的基.</p>
<p>上述说了这么多其实都在着重于所谓商空间的结构,现在我们看到陪集的定义可以在相当的意义上刻画商空间.适当推广上面的结论可以有:</p>
<p>设$T : V _1 \to V _2 $是线性映射,$U _1 \subseteq V _1 , U _2 \subseteq V _2 $并构造两个商映射$\varphi _1 : V _1 \to V _1 / U _1 , \varphi _2 : V _2 \to V _2 / U _2 $,并且$T ( U _1 ) \subseteq U _2 $,那么存在唯一的线性映射$\bar { T  } : V _1 / U _1 \to V _2 / U _2 $使得$T \varphi _2 = \bar { T  } \varphi _1 $.具体地,$\bar { T  } ( \vec { v  } + U _1 ) = T \vec { v  } + U _2 $.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V _1 \ar [rr ] ^T \ar [d ] _{ \varphi _1  } & & V _2 \ar [rr ] ^S \ar [d ] _{ \varphi _2  } & & V _3 \ar [d ] _{ \varphi _3  } \\
V _1 / U _1 \ar [rr ] ^{ \bar { T  }  } _{ \ker \bar { T  } = T ^{ - 1  } ( U _2 ) / U _1  } & & V _2 / U _2 \ar [rr ] ^{ \bar { S  }  } _{ \ker \bar { S  } = S ^{ - 1  } ( U _3 ) / U _2  } & & V _3 / U _3 \\
 }</script><h5><span id="第一同构定理">第一同构定理</span></h5><p>将群论中的第一同构定理(不过线性空间下没有正规的概念)拿过来,即对于线性空间$V $的一个子空间$U $,在典范同态$\pi : V \rightarrow V / U $下,我们有:</p>
<ol>
<li><p>$V $的包含$U $的子空间$W $和$V / U $的子空间$\bar { W  } $在$\pi $下一一对应.不妨设此对应为$\varphi : W \mapsto \bar { W  } $.</p>
</li>
<li><p>此对应是严格保序的,也就是$W _1 \subseteq W _2 \Leftrightarrow \bar { W  } _1 \subseteq \bar { W  } _2 $.</p>
</li>
<li><p>若有$U \subseteq W \subseteq V $,则$V / W \cong ( V / U ) / ( W / U ) $.</p>
</li>
</ol>
<p>考虑(1)(2)的证明:</p>
<p>先证明单射,对于两个包含$U $的子空间$W _1 \ne W _2 $来说,不妨设$W _1 \nsubseteq W _2 $,$\exists \vec { a  } \in W _1 , \vec { a  } \notin W _2 $.此时考虑$\bar { a  } $,注意到如果$\bar { a  } \in \bar { W _2  } $,那么$\vec { a  } + U \in W _2 + U $.这表明$\exists \vec { b  } \in W _2 $,$\vec { a  } + U = \vec { b  } + U $,此时$\vec { a  } - \vec { b  } \in U \subseteq W _2 $,那么$\vec { a  } \in W _2 $,这就不符合了,于是当然$\bar { W _1  } \ne \bar { W _2  } $并且(2)上严格保序.</p>
<p>证明单射还有一种办法是考虑只需证明$\pi ^{ - 1  } ( \pi ( W ) ) = W $即可,而$W \subseteq \pi ^{ - 1  } ( \pi ( W ) ) $是显然的.又考虑$\forall \vec { v  } \in \pi ^{ - 1  } ( \pi ( W ) ) , \pi ( \vec { v  } ) \in \pi ( W ) $,这意味着$\exists \vec { w  } \in W , \pi ( \vec { v  } ) = \pi ( \vec { w  } ) $,于是$\vec { v  } \in \vec { w  } + \ker \pi = \vec { w  } + U \subseteq \vec { w  } + W = W $.这样就证明了$W \supseteq \pi ^{ - 1  } ( \pi ( W ) ) $.</p>
<p>接下来要证明满射,也就是证明$\forall N \leq V / U , U \leq \pi ^{ - 1  } ( N ) \leq G $.</p>
<p>首先要证明$\pi ^{ - 1  } ( N ) $是一个子空间,这个是容易验证的.</p>
<p>而由于保序性已经被证明了,我们就可以注意到由于$\vec { 0  } \in N $,于是有$\bar { 0  } = U \leq \pi ^{ - 1  } ( N ) $.</p>
<p>对于(3):</p>
<p>由同态基本定理,考虑构造满射$\varphi : V / U \rightarrow V / W $,只需证明$\ker  \varphi = W / U $即可.</p>
<p>直觉上会认为映射$\varphi : \vec { v  } + U \mapsto \vec { v  } + W $即可,下面验证其满足上述性质:</p>
<p>首先验证良定义,$\vec { v  } _1 + U = \vec { v  } _2 + U \Leftrightarrow \vec { v  } _1 - \vec { v  } _2 \in U \subseteq W \Rightarrow \vec { v  } _1 + W = \vec { v  } _2 + W $.</p>
<p>然后验证线性映射,这个验证过程很平凡.</p>
<p>其满性显然.只需验证其$\ker \varphi = W / U $即可,而考虑$\varphi ( \vec { v  } + U ) = W \Leftrightarrow \vec { v  } + W = W \Leftrightarrow \vec { v  } \in W \Leftrightarrow \vec { v  } + U \in W / U $.这样就证明了上述结论.</p>
<h5><span id="第二同构定理">第二同构定理</span></h5><p>$V , W $是一个更大的线性空间的子空间,那么我们有:</p>
<p>$V / ( V \cap W ) \cong ( V + W ) / W , \vec { v  } + ( V \cap W ) \mapsto \vec { v  } + W $.</p>
<p>考虑$\varphi : V \to ( V + W ) / W , \vec { v  } \mapsto \vec { v  } + W $,那么显然$\varphi ( \vec { v  } ) = W \Leftrightarrow \vec { v  } \in V \cap W $,于是$\ker \varphi = V \cap W $.</p>
<p>接下来只需要证明它是满射就可以了.考虑$\forall \vec { v  } + \vec { w  } + W = \vec { v  } + W \in ( V + W ) / W $,这当然是满射.</p>
<p>第二同构定理的一个平凡推论是$\dim ( V + W ) = ( \dim V ) + ( \dim W ) - \dim ( V \cap W ) $.</p>
<p>第二同构定理的另一个推论是说如果$V = U \oplus W $,那么$W \cong V / U $.原因是$U + W = V $并且$U \cap W = \{ \vec { 0  } \} $.换言之取商是直和的逆运算.</p>
<p>第二同构定理证明的另一种思路是考虑$\varphi : V \times W \to V + W , ( \vec { v  } , \vec { w  } ) \mapsto ( \vec { v  } - \vec { w  } ) $,此时注意到$\text { im  } \varphi = ( V + W ) , \ker \varphi = V \cap W $.</p>
<h5><span id="旗">旗</span></h5><p>回看我们一开始拿到的映射$T : V \to V ‘ $和映射$\bar { T  } : V / U \to V ‘ / U ‘ $.也就是下面这个交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^T \ar [d ] _{ \varphi  } & V ' \ar [d ] ^{ \varphi '  } \\
V / U \ar [r ] _{ \bar { T  }  } & V ' / U ' \\
 }</script><p>现在我们尝试用矩阵刻画$T $和$\bar { T  } $之间的关系.首先我们需要开始取基,不妨取$\{ \vec { u  } _1 , \cdots , \vec { u  } _k \} $是$U $的一组有序基,$\{ \bar { v  } _1 , \cdots , \bar { v  } _m \} $是$V / U $的一组有序基.$\{ \vec { u  } _1 ‘ , \cdots , \vec { u  } _{ k ‘  } ‘ \} $是$U ‘ $的一组有序基,$\{ \bar { v  } _1 ‘ , \cdots , \bar { v  } _{ m ‘  } ‘ \} $是$V ‘ / U ‘ $的一组有序基.此时由于$\ker \varphi = U $,我们之前证明$\ker $的维度关系的时候已经说明过,$\{ \vec { u  } _1 , \cdots , \vec { u  } _k , \vec { v  } _1 , \cdots \vec { v  } _m \} $实际上是$V $的一组有序基.尝试取出一个矩阵$A \in M _{ ( k ‘ + m ‘ ) \times ( k + m )  } $来作为$T $对应的矩阵.此时将$A $分块,我们将其写作$A = \begin{bmatrix}A _{ U \to U ‘  } &amp; A _{ V / U \to U ‘  } \ A _{ U \to V ‘ / U ‘  } &amp; A _{ V / U \to V ‘ / U ‘  } \end{bmatrix} $.由于$T ( U ) \subseteq U ‘ $,我们知道$A _{ U \to V ‘ / U ‘  } = 0 $,而又有$A _{ V / U \to V ‘ / U ‘  } $当然就是$\bar { T  } $对应的矩阵$\bar { A  } $.总结一下就是$A = \begin{bmatrix}A _{ U \to U ‘  } &amp; _ \ 0 &amp; \bar { A  } \end{bmatrix} $.</p>
<p>如此观察可以继续推广并得到<strong>旗</strong>的概念.我们称$V $的<strong>旗</strong>是一列子空间$\{ \vec { 0  } \} = U _0 \subsetneq \cdots \subsetneq U _d = V $.特别地,如果$d = \dim V $,则称其为<strong>完备旗</strong>,容易见到完备旗一定满足$\dim V _i = i $.对于给定的旗,如果线性映射$T \in \text { End  } ( V ) $对$\forall 0 \leq i \leq m $满足$T ( V _i ) \subseteq V _i $,则称$T $保持此旗.</p>
<p>如果一个映射$T : V \to V ‘ $满足$\forall h , T ( U _h ) \subseteq U ‘ _h $,那我们可以对每个$U _h / U _{ h - 1  } $和$U ‘ _h / U ‘ _{ h - 1  } $选定有序基,那么得到的矩阵$A $应当是一个分块上三角矩阵,而且$A _{ i , i  } $实际上就是$\bar { T  } _h : U _h / U _{ h - 1  } \to U ‘ _h / U ‘ _{ h - 1  } $所对应的矩阵.</p>
<h5><span id="不变子空间">不变子空间</span></h5><p>给定线性映射$T \in \text { End  } ( V ) $,如果子空间$U \subseteq V $满足$T ( U ) \subseteq U $,那我们称$U $是在$T $下的一个<strong>不变子空间</strong>.根据前面我们已经讨论过的内容,得到下面这个交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^T \ar [d ] _{ \varphi  } & V \ar [d ] ^{ \varphi '  } \\
V / U \ar [r ] _{ \bar { T  }  } & V / U \\
 }</script><p>其中$\bar { T  } $是唯一的.</p>
<p>提取$T | _U $为只考虑$T $在线性空间$U $上的作用得到的线性映射,上述交换图表给出以下矩阵:$T \cong \begin{bmatrix}T | _U &amp; _ \ 0 &amp; \bar { T  } \end{bmatrix} $.这个形式更好的用处是结合之后的迹/行列式/特征多项式等概念给出$T , T | _U , \bar { T  } $三者的关系:事实上$\det ( T | _U ) \det ( \bar { T  } ) = \det ( T ) , \text { tr  } ( T | _U ) + \text { tr  } ( \bar { T  } ) = \text { tr  } ( T ) $.</p>
<h3><span id="行列式">行列式</span></h3><h4><span id="置换排列">置换(排列)</span></h4><p>不妨假设$X $是一个非空集合,那么我们定义其<strong>置换集合</strong>$S _X = \{ \sigma : X \to X , \sigma  \text { is a bijection  } \} $.容易看出$S _X $对置换复合构成一个群.</p>
<p>我们也可以用$\left ( \begin{matrix}1 &amp; \cdots &amp; n \ \sigma ( 1 ) &amp; \cdots &amp; \sigma ( n ) \end{matrix} \right ) $.</p>
<p>我们还可以定义<strong>轮换</strong>为$\left ( \begin{matrix}1 &amp; 2 &amp; \cdots &amp; n - 1 &amp; n \ 2 &amp; 3 &amp; \cdots &amp; n &amp; 1 \end{matrix} \right ) $.</p>
<p>还可以定义<strong>对换</strong>$( i , j ) = \left ( \begin{matrix}1 &amp; \cdots &amp; i &amp; \cdots &amp; j &amp; \cdots &amp; n \ 1 &amp; \cdots &amp; j &amp; \cdots &amp; i &amp; \cdots &amp; n \end{matrix} \right ) $,其中$i \ne j $.</p>
<p>在此基础上定义<strong>单对换</strong>$s _i = ( i , i + 1 ) $.</p>
<p>在置换的基础上可以定义逆序对:$\text { Inv  } _\sigma = \{ ( i , j ) \mid 1 \leq i &lt; j \leq n , \sigma ( i ) &gt; \sigma ( j ) \} $,并定义逆序数$l ( \sigma ) = | \text { Inv  } _\sigma | $.容易看出$l ( \sigma ) = 0 \Leftrightarrow \sigma = \text { id  } $,$l ( \sigma ) = \frac { n ( n - 1 )  } { 2  } \Leftrightarrow \sigma ( k ) = n - k + 1 $.并且注意到$l ( \sigma ) = l ( \sigma ^{ - 1  } ) $,原因是$( i , j ) \mapsto ( \sigma ( j ) , \sigma ( i ) ) $是双射.</p>
<p>容易发现一个$\sigma $可以最少通过$l ( \sigma ) $次单对换变为$\text { id  } $,原因是每次交换一对$( i , i + 1 ) $当$\sigma ( i ) &gt; \sigma ( i + 1 ) $时会让逆序数减少$1 $.或者说更一般地$| l ( \sigma ) - l ( s _i \sigma ) | = 1 $.由于$( s _i ) ^{ - 1  } = s _i $,容易发现$| l ( \sigma ) - l ( \sigma s _i ) | = 1 $.而事实上$| l ( \sigma ) - l ( ( i , j ) \sigma ) | \in \text { odd  } $.这意味着对换会改变逆序数的奇偶性.所以容易看出来一个置换$\sigma $如果能拆成若干个对换,这些对换的数量的奇偶性一定与$l ( \sigma ) $相同.</p>
<p>而由于可以如上分解并合并,我们知道$l ( \sigma \tau ) $和$l ( \sigma ) + l ( \tau ) $的奇偶性必然相同.</p>
<p>于是我们可以定义$\text { sgn  } ( \sigma ) = ( - 1 ) ^{ l ( \sigma )  } $,并且容易发现$\text { sgn  } ( \sigma \tau ) = \text { sgn  } ( \sigma ) \text { sgn  } ( \tau ) $.还可以看出$\text { sgn  } ( \sigma ^{ - 1  } ) = \text { sgn  } ( \sigma ) $,那么立刻有$\text { sgn  } ( \sigma ^{ - 1  } \tau \sigma ) = \text { sgn  } ( \tau ) $.用此可以定义奇偶置换的概念,也就是$l ( \sigma ) \in \text { odd  } $的置换$\sigma $是奇置换.</p>
<h4><span id="交错形式">交错形式</span></h4><p>尝试刻画一种交错形式$D : V ^m \to F $,其中$V $是定义在$F $上的线性空间,满足以下性质:</p>
<ol>
<li><p>其对每一个分量都是线性的.也即固定其他$m - 1 $个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之$D ( \cdots , t \vec { v  } _i , \cdots ) = tD ( \cdots , \vec { v  } _i , \cdots ) , D ( \cdots , \vec { v  } _i + v _i ‘ , \cdots ) = D ( \cdots , \vec { v  } _i , \cdots ) + D ( \cdots , \vec { v  } _i ‘ , \cdots ) $.</p>
</li>
<li><p>如果有两个分量相等,那么得到的是$0 $.</p>
</li>
</ol>
<p>在上述基础上容易发现交错形式也是线性空间,不妨将其记作$D _{ V , m  } $.</p>
<p>容易发现$D _{ V , 1  } = V ^\vee $.</p>
<p>初看会觉得(2)是一个很奇怪的事情,但实际上其定义了一种很好的性质:首先我们应当需要一种东西使得如果有一个分量是$\vec { 0  } $则给出$0 $,但如果直接这么定义的话容易看到难以判定一个东西在没有分量为$0 $的时候是否为$0 $,因此这个定义的性质更为优良.事实上,我们有以下性质:</p>
<ol>
<li><p>对于一个固定的$D $而言,将其某一个分量乘以若干倍加到另一个分量上不会引起取值的变化.</p>
</li>
<li><p>对于一个固定的$D $而言,将某一个分量乘以$t $倍,则取值需要乘以$t $倍.</p>
</li>
<li><p>对于一个固定的$D $而言,如果其收到的向量组是线性相关的,那么取值为$0 $.</p>
</li>
<li><p>作为(3)的推论,如果$m &gt; \dim V $,那么$D _{ V , m  } = \{ 0 \} $.</p>
</li>
<li><p>对于一个固定的$D $而言,$D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _j , \cdots ) = - D ( \cdots , \vec { v  } _j , \cdots , \vec { v  } _i , \cdots ) $.</p>
</li>
<li><p>作为(5)的推论,$D ( \vec { v  } _{ \sigma ^{ - 1  } ( 1 )  } , \cdots , \vec { v  } _{ \sigma ^{ - 1  } ( m )  } ) = \text { sgn  } ( \sigma ) D ( \vec { v  } _1 , \cdots , \vec { v  } _m ) $.</p>
</li>
</ol>
<p>其它几个都是平凡的,下面考虑(5)的证明,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
0 & = D ( \cdots , \vec { v  } _i + \vec { v  } _j , \cdots , \vec { v  } _j + \vec { v  } _i , \cdots ) \\
& = D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _j , \cdots ) + D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _i , \cdots ) \\
+ D ( \cdots , \vec { v  } _j , \cdots , \vec { v  } _i , \cdots ) + D ( \cdots , \vec { v  } _j , \cdots , \vec { v  } _j , \cdots ) \\
& = D ( \cdots , \vec { v  } _i , \cdots , \vec { v  } _j , \cdots ) + D ( \cdots , \vec { v  } _j , \cdots , \vec { v  } _i , \cdots ) 
\end{aligned}</script><p>下面我们定义$D _V = D _{ V , n  } $,其中$n = \dim V $,取出其一组有序基$\{ \vec { e  } _1 , \cdots , \vec { e  } _n \} $.对于一组向量$\{ \vec { v  } _{ 1  } , \cdots , \vec { v  } _n \} $,尝试将其分解为$\vec { v  } _i = \sum _{ j  } a _{ i , j  } \vec { e  } _j $.此时逐个展开$D ( \vec { v  } _1 , \cdots , \vec { v  } _n ) $中的向量,理应得知:</p>
<script type="math/tex; mode=display">
\begin{aligned}
D ( \vec { v  } _1 , \cdots , \vec { v  } _n ) & = \sum _{ \sigma \in S _n  } \prod _{ k = 1  } ^n a _{ k , \sigma ( k )  } D ( \vec { e  } _{ \sigma ( 1 )  } , \cdots , \vec { e  } _{ \sigma ( n )  } ) \\
& = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma ) \prod _{ k = 1  } ^n a _{ k , \sigma ( k )  } D ( \vec { e  } _1 , \cdots , \vec { e  } _n ) 
\end{aligned}</script><p>这说明任何一个$D $实际上只由其在基上的作用$D ( \vec { e  } _1 , \cdots , \vec { e  } _n ) $唯一确定.因此$\dim D \leq 1 = \dim F $,原因是线性映射$D _V \to F , D \mapsto D / D ( \vec { e  } _1 , \cdots , \vec { e  } _n ) $是单射.事实上只要$\dim V \geq 1 $,当然可以如上构造$D _e = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma ) \prod _{ k = 1  } ^n a _{ k , \sigma ( k )  } \in D _V \setminus \{ 0 \} $,于是$\dim D \ne 0 $,于是$\dim D = 1 $.</p>
<p>验证$D _e $映射符合定义的过程较为无聊,验证有相同元素则为$0 $是考虑交换它们后$\text { sgn  } $会变号,而还容易简单验证$D _e ( \vec { e  } _1 , \cdots \vec { e  } _n ) = 1 $.</p>
<h4><span id="定义">定义</span></h4><p>考虑有限维的$V , W $,并考虑映射$T ^<em> : D _{ W , m  } \to D _{ V , m  } , D \mapsto ( ( T ^</em> D ) : ( \vec { v  } _1 , \cdots , \vec { v  } _m ) \mapsto D ( T \vec { v  } _1 , \cdots T \vec { v  } _m ) $.</p>
<p>现在取$W = V , m = n = \dim V $,于是$T \in \text { End  } ( V ) , T ^<em> \in \text { End  } ( D _V ) $,由于$\dim D _V = 1 $,于是$T ^</em> $必然是伸缩映射$D \mapsto tD $,那么这个$t $其实就是行列式.更确切地说,我们定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ^* ( D ) & = ( \det T ) D \\
D ( T \vec { v  } _1 , \cdots , T \vec { v  } _n ) & = \det T \times D ( \vec { v  } _1 , \cdots \vec { v  } _n ) 
\end{aligned}</script><p>那么既然其是伸缩映射,我们就当然注意到$\det T = \frac { D _e ( T \vec { e  } _1 , \cdots , T \vec { e  } _n )  } { D _e ( \vec { e  } _1 , \cdots , \vec { e  } _n )  } = D _e ( T \vec { e  } _1 , \cdots , T \vec { e  } _n ) $.</p>
<p>只需简单利用定义就可以注意到行列式的以下性质:</p>
<ol>
<li><p>$\det \text { id  } _V = 1 $.</p>
</li>
<li><p>$\det ( ST ) = \det S \times \det T $.</p>
</li>
<li><p>$T $可逆时,$\det ( T ^{ - 1  } ) = ( \det T ) ^{ - 1  } $.</p>
</li>
<li><p>$T $不可逆时,$\det T = 0 $.</p>
</li>
</ol>
<p>应当警觉的一个事情是我们上面给出的计算$D $的方式是观察$D $在某一组基上的作用,而我们理应判定当选取的基不同的时候$\det T $的唯一性,我们还应当确认的是我们可以将一个$\dim V = n $的线性空间用某一个基打到$F ^n $后也不会有问题,从而引出矩阵的行列式的定义.综上,我们应当验证当以下图表是交换时:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^T \ar [d ] _S & V \ar [d ] ^S \\
W \ar [r ] _{ T '  } & W  }</script><p>也即$T ‘ = STS ^{ - 1  } $时$\det T = \det T ‘ $.那么这由行列式的乘法性质当然就可以予以说明.</p>
<p>综上就可以定义矩阵的行列式,我们称方阵$A _{ n \times n  } $的行列式是一个将其映射到标量的函数,记作$\det ( A ) $或者$| A | $.由于一般自然地将$\text { End  } ( V ) \cong M _{ n \times n  } $,于是从上面的计算方式容易见到$\det A = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma ) \prod _{ k = 1  } ^n a _{ k , \sigma ( k )  } = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma ) \prod _{ k = 1  } ^n a _{ \sigma ( k ) , k  } $.</p>
<p>我们应当容易从上述过程中看出以下事实:</p>
<ol>
<li><p>$\det A = \det A ^T $.</p>
</li>
<li><p>$\det I _{ n \times n  } = 1 $.</p>
</li>
<li><p>$\det A $可以看作列向量(或行向量)上的某种交错形式.</p>
</li>
<li><p>如果两个矩阵相似,那么它们的$\det $相等.</p>
</li>
</ol>
<p>而由于行列式是某种交错形式,我们立即可以断言当对其作三种初等行变换的时候:</p>
<ol>
<li><p>(倍加变换):行列式的值不变.</p>
</li>
<li><p>(对换变换):行列式的值取反.</p>
</li>
<li><p>(倍乘变换):行列式的值取相同倍数.</p>
</li>
</ol>
<p>说到这里要声明的某些事情是,我们应当将行列式看作某种交错形式,而并非将所有的交错形式都看作行列式.原因是交错形式一般带有单位,而行列式只是单纯的比例常数.例如我们用行列式求面积的时候,算的其实并不是面积,而是其相对于单位面积的比例常数.</p>
<h4><span id="余子式与代数余子式">余子式与代数余子式</span></h4><p>对于矩阵$A $,$A $的<strong>余子式</strong>$M _{ i , j  } $定义为$A $去掉第$i $行第$j $列的矩阵的行列式.其中形如$M _{ i , i  } $的余子式称为<strong>主余子式</strong>.</p>
<p>对于矩阵$A $,其<strong>代数余子式</strong>(又称<strong>余因子</strong>)$C _{ i , j  } = ( - 1 ) ^{ i + j  } M _{ i , j  } \ $.</p>
<p>那么我们有一种计算行列式的方式是<strong>代数余子式展开</strong>:</p>
<script type="math/tex; mode=display">
\det A = \sum _{ k = 1  } ^n a _{ i , k  } C _{ i , k  } = \sum _{ k = 1  } ^n a _{ k , j  } C _{ k , j  }</script><p>原因是$\sigma ( i ) = j $的位置对逆序对的贡献的奇偶性等同于$i + j $的奇偶性.每次我看这个结论都无法第一时间理解这个性质.但你可以考虑以$\sigma ( i ) = j $作为分界线,然后发现此时怎么交换其它的部分,这个点的奇偶性贡献都是不变的.因此直接考虑在最普通的排列上挪一下,奇偶性就等价于$i - j $的奇偶性了.</p>
<p>值得一提的是我们其实还有类似的公式,当$i \ne j $的时候:</p>
<script type="math/tex; mode=display">
0 = \sum _{ k = 1  } ^n a _{ i , k  } C _{ j , k  } = \sum _{ k = 1  } ^n a _{ k , i  } C _{ k , j  }</script><p>原因是直接定义一个矩阵$B $使得$B $的第$j $行与$A $的第$i $行相等,其余行照搬$A $,那么展开也是上面这个东西,而由于$B $有两行相等,所以$\det B = 0 $.</p>
<p>代数余子式构成的矩阵$C = [ C _{ i , j  } ] $称为<strong>余子矩阵</strong>.其转置称为<strong>伴随矩阵</strong>,我们不妨将伴随矩阵直接记作$\check { A  } $,也有时记其为$\text { adj  } ( A ) $.</p>
<p>其满足$A \check { A  } = \check { A  } A = ( \det A ) I $.二者类似,只考虑证明前者:</p>
<p>考虑前者的第$i $行第$j $列应该是$\sum _{ k  } a _{ i , k  } C _{ j , k  } $,我们早在前面就证明过当$i = j $的时候这个东西应当为$\det A $,反之为$0 $.</p>
<p>由上面立刻得到推论为$A ^{ - 1  } = \frac { \check { A  }  } { \det A  } $.</p>
<p>我们可能还希望去了解$\check { A  } $的$\text { rk  } $与$\det $.事实上我们给出以下若干命题:</p>
<ol>
<li><p>$\det \check { A  } = ( \det A ) ^{ n - 1  } $.</p>
</li>
<li><p>$\text { rk  } ( \check { A  } ) = \begin{cases}n &amp; \text { rk  }  A = n \ 1 &amp; \text { rk  }  A = n - 1 \ 0 &amp; \text { rk  }  A &lt; n - 1 \end{cases} $.</p>
</li>
</ol>
<p>(1)无非是(2)的推论,下面只看(2).</p>
<p>(2)的话,由于$\det A \ne 0 \Rightarrow \det \check { A  } \ne 0 $,所以当$A $满秩的时候也很显然.</p>
<p>当$\text { rk  }  A &lt; n - 1 $的时候,由于取出的所有余子式都线性相关,于是此时$\check { A  } $是$0 $矩阵.</p>
<p>当$\text { rk  }  A = n - 1 $的时候,首先证明其$\text { r  } k \geq 1 $,也就是只需证明至少存在一个余子式不为$0 $.取出$n - 1 $个线性无关的列组成一个$n \times ( n - 1 ) $大小的矩阵.我们之前已经声明过其行秩等于列秩,这样就可以删去其中一行得到一个$( n - 1 ) \times ( n - 1 ) $的满秩矩阵,这个矩阵的行列式不为零.</p>
<p>于是其$\text { rk  } \geq 1 $,我们又根据Frobenius秩不等式,知道考虑$0 = \text { rk  }  ( AI \check { A  } ) \geq \text { rk  }  A + \text { rk  }  \check { A  } - \text { rk  }  I $,于是$\text { rk  }  \check { A  } \leq 1 $.</p>
<h4><span id="行列式定向">行列式定向</span></h4><p>我们知道我们用行列式求平行四边形面积的时候求的是所谓有向面积,问题在于这个方向具体是什么样子呢.</p>
<p>容易见得不同的基对应的矩阵行列式应当是相等的.但基的变换可能拥有不同的行列式.我们曾经研究过$P _{ \mathcal { B  } \to \mathcal { B  } ‘  } $这个坐标变换矩阵的若干性质,而这个变换当然是同构的,所以这个矩阵行列式理应非零,那它就会天然带有正负的区别.我们定义一种基上的等价关系$\sim $,或者称为<strong>同定向的</strong>.具体来说$\mathcal { B  } \sim \mathcal { B  } ‘ \Leftrightarrow \det P _{ \mathcal { B  } ‘ \to \mathcal { B  }  } &gt; 0 $,由于行列式的乘法性质,立刻见到这将所有的基分为了两类.对于$F ^n $来说,我们一般将其标准基所在的那一类称为<strong>标准定向</strong>.这就是为什么我们求行列式的时候会出现正负的差别.</p>
<h4><span id="克拉默cramer法则">克拉默(Cramer)法则</span></h4><p>若$A $可逆,用$A _i ( \vec { b  } ) $表示将$A $的第$i $列替换为$\vec { b  } $后的矩阵,则$A \vec { x  } = \vec { b  } $的唯一解可由下式给出:</p>
<script type="math/tex; mode=display">
x _i = \cfrac { \det A _i ( \vec { b  } )  } { \det A  }</script><p>证明:由于$A $实际上可以看作线性映射不难发现$A \times I _i ( \vec { x  } ) = A _i ( \vec { b  } ) $,则根据行列式的乘法原理,有$( \det A ) ( \det I _i ( \vec { x  } ) ) = \det A _i ( \vec { b  } ) $.而$\det I _i ( \vec { x  } ) = x _i $,于是该定理显然.</p>
<p>或者直接考虑$\vec { x  } = A ^{ - 1  } \vec { b  } = \frac { 1  } { \det A  } \check { A  } \vec { b  } $,于是$x _i = \frac { 1  } { \det A  } \sum _{ k = 1  } ^n C _{ k , i  } b _k $,后者刚好是$A _i ( \vec { b  } ) $沿第$i $列作余子式展开后的结果.</p>
<p>值得一提的是,Cramer法则揭示了$\det \in R ^\times $的环上的矩阵必有逆矩阵</p>
<h4><span id="一些特殊行列式">一些特殊行列式</span></h4><h5><span id="置换矩阵">置换矩阵</span></h5><p>对于一个置换$\sigma $,我们记它的置换矩阵$P _\sigma $满足$P _{ \sigma , i , j  } = \begin{cases}1 &amp; i = \sigma ( j ) \ 0 &amp; \text { otherwise  } \end{cases} $,容易发现它对应了线性映射$\vec { e  } _j \mapsto \vec { e  } _{ \sigma ( j )  } $.容易看出$P _\sigma P _\tau = P _{ \sigma \tau  } $并且$P _{ \sigma ^{ - 1  }  } = ( P _\sigma ) ^{ - 1  } = ( P _\sigma ) ^T $.容易由行列式理论得知$| P _\sigma | = \text { sgn  } ( \sigma ) $.</p>
<h5><span id="上三角矩阵">上三角矩阵</span></h5><p>用代数余子式展开立刻见到上三角矩阵的行列式就是其对角线的乘积.这比用高斯消元更好,因为对角线未必可逆.</p>
<h5><span id="分块上三角矩阵">分块上三角矩阵</span></h5><p>也即$\left | \begin{matrix}A _{ 1 , 1  } &amp; \cdots &amp; \cdots \ 0 &amp; \ddots &amp; \vdots \ 0 &amp; 0 &amp; A _{ n , n  } \end{matrix} \right | = \prod _{ i = 1  } ^n \det A _{ i , i  } $.</p>
<p>证明考虑数学归纳,先把左上角那一坨变成一个分块矩阵,那我们只需要证明$\left | \begin{matrix}A _{ 1 , 1  } &amp; A _{ 1 , 2  } \ 0 &amp; A _{ 2 , 2  } \end{matrix} \right | = \det A _{ 1 , 1  } \det A _{ 2 , 2  } $.</p>
<p>这个怎么证明呢?考虑直接套定义,我们知道行列式的定义是:$\det A = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma ) \prod _{ k = 1  } ^n a _{ k , \sigma ( k )  } $,此时意识到如果$k &gt; n _1 , \sigma ( k ) \leq n _1 $那么此时$a _{ k , \sigma ( k )  } = 0 $,所以这个$\sigma $应当分为两部分,一部分是$[ 1 , n _1 ] $部分内部交换,另一部分是$[ n _1 + 1 , n _1 + n _2 ] $内部交换,这样我们把$\sigma = \sigma _1 \sigma _2 $,上述表达式变为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\det A & = \sum _{ \sigma \in S _n  } \text { sgn  } ( \sigma _1 ) \prod _{ k = 1  } ^{ n _1  } a _{ k , \sigma _1 ( k )  } \text { sgn  } ( \sigma _2 ) \prod _{ k = n _1 + 1  } ^{ n _1 + n _2  } a _{ k , \sigma _2 ( k )  } \\
& = \det A _{ 1 , 1  } \det A _{ 2 , 2  } 
\end{aligned}</script><h5><span id="范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</span></h5><p>即$\left | \begin{matrix}1 &amp; \cdots &amp; 1 \ x _1 &amp; \cdots &amp; x _n \ \vdots &amp; &amp; \vdots \ x _1 ^{ n - 1  } &amp; \cdots &amp; x _n ^{ n - 1  } \end{matrix} \right | = \prod _{ 1 \leq i &lt; j \leq n  } ( x _j - x _i ) $.</p>
<p>这个怎么求呢?我们先逐个消第一列(先用第$n - 1 $行消第$n $行,再用第$n - 2 $行消第$n - 1 $行,以此类推),我们得到的就是以下行列式:</p>
<script type="math/tex; mode=display">
\left | \begin{matrix}
1 & 1 & \cdots & 1 \\
0 & x _2 - x _1 & \cdots & x _n - x _1 \\
0 & \vdots & & \vdots \\
0 & x _2 ^{ n - 1  } - x _1 x _2 ^{ n - 2  } & \cdots & x _n ^{ n - 1  } - x _1 x _n ^{ n - 2  } 
\end{matrix} \right |</script><p>对这个的第一列作代数余子式展开,知道它应当等于:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left | \begin{matrix}
x _2 - x _1 & \cdots & x _n - x _1 \\
\vdots & & \vdots \\
x _2 ^{ n - 1  } - x _1 x _2 ^{ n - 2  } & \cdots & x _n ^{ n - 1  } - x _1 x _n ^{ n - 2  } 
\end{matrix} \right | \\
& = \left | \begin{matrix}
1 & \cdots & 1 \\
\vdots & & \vdots \\
x _2 ^{ n - 2  } & \cdots & x _n ^{ n - 2  } 
\end{matrix} \right | \prod _{ 1 < j \leq n  } ( x _j - x _1 ) 
\end{aligned}</script><p>然后数学归纳就证完了.</p>
<h5><span id="一类分块矩阵">一类分块矩阵</span></h5><p>考虑$\left | \begin{matrix}I &amp; B \ A &amp; I \end{matrix} \right | = \det ( I - AB ) $.此时观测其对基的作用,注意到其和$\begin{bmatrix}I &amp; A \ B &amp; I \end{bmatrix} $无非是在不同基下的同种线性映射,于是$\det ( I - AB ) = \det ( I - BA ) $.</p>
<h4><span id="特征多项式">特征多项式</span></h4><p>自映射$T = \text { End  } ( V ) $本身作为一个定义了乘法和加法的元素,理应可以嵌入多项式结构中.因此不妨定义多项式$f ( T ) = \sum _{ k = 0  } ^m a _k T ^k $.</p>
<p>此时设$\dim V = n $有限,那么$\dim T = n ^2 $,考虑以下$n ^2 + 1 $个此空间上的向量$T ^0 , \ldots , T ^{ n ^2  } $,它们必定线性相关,也就是存在一组不全为$0 $的$\{ c _k \} $使得$f ( T ) = \sum _{ k = 0  } ^{ n ^2  } c _k T ^k = 0 $.</p>
<p>如果$T $可逆,那我们考虑可以取一个满足上述条件的$f $使得$c _0 \ne 0 $,原因是可以不断两边除去$T $.那最终就会拿到$c _0 \text { id  } + \sum _{ k = 1  } ^m c _k T ^k = 0 $,对此式子再简单处理可知以下结论:对于一个可逆的$T $,存在一个多项式$g ( T ) $使得$T ^{ - 1  } = g ( T ) = - \frac { 1  } { c _0  } \sum _{ k = 1  } ^{ m  } c _k T ^{ k - 1  } $.并且注意到$\deg g ( T ) \leq n ^2 $.</p>
<p>将此定义挪到矩阵上,定义其特征多项式$\text { char  } _A ( x ) = \det ( xI - A ) $.由定义立刻得知$\text { char  } _A ( x ) = \sum _{ \sigma  } \text { sgn  } ( \sigma ) \prod _{ i = 1  } ^n ( [ i = \sigma ( i ) ] x - a _{ i , \sigma ( i )  } ) $.于是容易发现$\text { char  } _A ( 0 ) = ( - 1 ) ^n \det A $.并且这个多项式应该首项为$1 $.</p>
<p>容易观察到相似的矩阵应当有相同的特征多项式,原因是$\det ( xI - A ) = \det ( P ^{ - 1  } ( xI - B ) P ) = \det ( xI - B ) $.这意味着其和基的选取无关,因此特征多项式可以拓展到一般的线性映射上.</p>
<p>另外转置不影响特征多项式的取值,原因是转置也不影响$\det $的取值.</p>
<p>分块上三角矩阵的特征多项式就是对角线矩阵特征多项式的乘积.</p>
<p>我们还可以有以下性质:当$A \in M _{ m \times n  } , B \in M _{ n \times m  } $,则$\cfrac { \text { char  } _{ AB  }  } { x ^m  } = \cfrac { \text { char  } _{ BA  }  } { x ^n  } $.</p>
<p>原因是考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^{ - m  } \text { char  } _{ AB  } \\
& = x ^{ - m  } \det ( xI - AB ) \\
& = \det ( I - x ^{ - 1  } AB ) \\
& = \det ( I - x ^{ - 1  } BA ) \\
& = x ^{ - n  } \text { char  } _{ BA  } 
\end{aligned}</script><p>原因是我们已经证明过了$\det ( I - AB ) = \det ( I - BA ) $.</p>
<p>仅仅如此当然不够好用,然而注意到如果$AB $以$\lambda _0 \ne 0 $为特征值的特征向量是$\vec { v  } $,那么$BA $以$\lambda _0 $为特征值的特征向量就是$B \vec { v  } $.</p>
<p>应当研究伴随矩阵在特征多项式下的情形,事实上有以下定理:如果$\text { char  } _A = \sum _{ k = 0  } ^n c _k x ^k $,那么$( - 1 ) ^{ n - 1  } \check { A  } = \sum _{ k = 1  } ^n c _{ k  } A ^{ k - 1  } $.</p>
<p>考虑证明以上定理,考虑$\text { adj  } ( xI - A ) $的每一个元素都是一个次数$\leq n - 1 $的多项式,对其进行分解得到$\text { adj  } ( xI - A ) = \sum _{ k = 0  } ^{ n - 1  } x ^k D _k $,其中$D _k $是一个矩阵,代表不同位置$x ^k $前的系数.</p>
<p>而我们知道$\text { char  } _A ( x ) I = ( xI - A ) \times \text { adj  } ( xI - A ) = ( xI - A ) \sum _{ k = 0  } ^{ n - 1  } x ^k D _k $.</p>
<p>两边提取系数,于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
c _n I & = D _{ n - 1  } \\
c _{ n - 1  } I & = - AD _{ n - 1  } + D _{ n - 2  } \\
c _{ n - 2  } I & = - AD _{ n - 2  } + D _{ n - 3  } \\
\cdots 
\end{aligned}</script><p>将上面这些若干式子右边乘以$A ^{ k  } $并相加就可以做到相消,得到$D _0 = \sum _{ k = 1  } ^n c _{ k  } A ^{ k - 1  } $,而$D _0 $按照定义就是$\text { adj  } ( 0 I - A ) = ( - 1 ) ^{ n - 1  } \check { A  } $.</p>
<p>根据上述定理有以下结论:</p>
<ol>
<li><p>$( A ^\vee ) ^T = ( A ^T ) ^\vee $.</p>
</li>
<li><p>$\text { adj  } { ( P ^{ - 1  } AP )  } = P ^{ - 1  } \check { A  } P $.</p>
</li>
</ol>
<p>另外,如果$\text { char  } _A = \sum _{ k = 0  } ^n c _k x ^k $,那么$\text { char  } _{ A ^{ - 1  }  } = \sum _{ k = 0  } ^n \frac { c _k  } { c _0  } x ^{ n - k  } $.</p>
<p>原因是观察到$( - 1 ) ^n c _0 \times \text { char  } _{ A ^{ - 1  }  } = \det A \times \det ( xI - A ^{ - 1  } ) = ( - x ) ^n \det ( x ^{ - 1  } I - A ) $.</p>
<h4><span id="cayley-hamilton定理">Cayley-Hamilton定理</span></h4><p>即:$\text { char  } _A ( A ) = 0 $.</p>
<p>原因是根据上述定理,由于$c _0 = ( - 1 ) ^n \det A $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n c _k A ^k & = ( ( - 1 ) ^n \det A ) \times I + A \sum _{ k = 1  } ^n c _k A ^{ k - 1  } \\
& = ( ( - 1 ) ^n \det A ) \times I + ( - 1 ) ^{ n - 1  } A \check { A  } \\
& = 0 
\end{aligned}</script><h4><span id="矩阵的迹">矩阵的迹</span></h4><p>定义$A \in M _{ n \times n  } ( F ) $的<strong>迹</strong>$\text { tr  }  A = \sum _{ i = 1  } ^n a _{ i , i  } $.显然$tr ( A + B ) = tr ( A ) + tr ( B ) $.容易验证$tr : M _{ n \times n  } ( F ) \to F $是线性映射,并且$\forall A \in M _{ n \times m  } ( F ) , B \in M _{ m \times n  } ( F ) $有$tr ( AB ) = tr ( BA ) $.</p>
<p>于是共轭的矩阵有相同的迹,原因是$tr ( P ^{ - 1  } AP ) = tr ( APP ^{ - 1  } ) = tr ( A ) $.这应当意味着迹这个东西有一些更好的性质.事实上,迹的等价定义是$tr ( A ) = - [ x ^{ n - 1  } ] \text { char  } _A $,原因是$\text { char  } _A ( x ) = \sum _{ \sigma  } \text { sgn  } ( \sigma ) \prod _{ i = 1  } ^n ( [ i = \sigma ( i ) ] x - a _{ i , \sigma ( i )  } ) $,从这里立刻看出只有恒等映射$\sigma = \text { id  } $的时候才会对$[ x ^{ n - 1  } ] $产生贡献.</p>
<h6><span id="example">Example</span></h6><p>证明:如果$tr ( A ) = 0 $,而且域的特征$\text { char  }  F = 0 $,那么存在$A ‘ = PAP ^{ - 1  } $使得$\forall i \in [ 1 , n ] , a ‘ _{ i , i  } = 0 $.</p>
<p>如果$A = 0 $就下班了对吧,如果$A \ne 0 $,我们下面来数学归纳证明.假设$&lt; n $的时候已经得证.</p>
<p>首先我们说明:如果对于所有的$\vec { v  } \in F ^n $都存在$c _v \in F $使得$A \vec { v  } = c _v \vec { v  } $,那么存在$c \in F $使得$A = cI $.</p>
<p>考虑线性无关的两个向量$\vec { v  } , \vec { w  } $,如果$c _v \ne c _w $,考虑$c _v \vec { v  } + c _w \vec { w  } = A ( \vec { v  } + \vec { w  } ) = c _{ v + w  } ( \vec { v  } + \vec { w  } ) $,于是自然导出$c _v = c _{ v + w  } = c _w $,矛盾.于是上述命题成立.</p>
<p>对于一个$tr ( A ) = 0 $的矩阵当然不是$cI $的形式,那我们就可以找到一个$\vec { v  } $使得$A \vec { v  } \ne c \vec { v  } $,于是$A \vec { v  } $和$\vec { v  } $线性无关.此时考虑将其扩充为一个基$\{ \vec { v  } , A \vec { v  } , \vec { v  } _3 , \cdots , \vec { v  } _n \} $,考虑当然存在一个$C $使得$C = P _1 ^{ - 1  } AP _1 $这样$C $是对上述基的作用.那我们考虑$C ( \vec { v  } ) = A \vec { v  } $,于是$C $应当形如:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
0 & \cdots \\
1 & \vdots \\
0 & \vdots \\
\vdots & \vdots 
\end{bmatrix}</script><p>不妨设$C = \begin{bmatrix}0 &amp; T \ L &amp; B \end{bmatrix} $,我们知道根据归纳假设,对于$B $来说存在一个$P _2 $使得$P _2 ^{ - 1  } BP _2 $的对角线全零,那我们考虑:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 \\
0 & P _2 ^{ - 1  } 
\end{bmatrix} \begin{bmatrix}
0 & T \\
L & B 
\end{bmatrix} \begin{bmatrix}
1 & 0 \\
0 & P _2 
\end{bmatrix} = \begin{bmatrix}
0 & \_ \\
\_ & P _2 ^{ - 1  } BP _2 
\end{bmatrix}</script><p>这样就做完了.</p>
<h4><span id="binet-cauchy定理">Binet-Cauchy定理</span></h4><p>定义大小分别为$n \times m $和$m \times n $(其中$n \leq m $)的矩阵$A $和$B $,令$A [ S ] $表示矩阵$A $只取$S $集合中的列所形成的矩阵,$B [ S ] $表示矩阵$B $只取$S $集合中的行所形成的矩阵,则有:</p>
<script type="math/tex; mode=display">
\det ( AB ) = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } ( \det ( A [ S ] ) ) ( \det ( B [ S ] ) )</script><p>下面设$\lambda ( P ) $为排列$P $的逆序对数.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } ( \det ( A [ S ] ) ) ( \det ( B [ S ] ) ) \\
& = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } ( \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } \prod _{ i = 1  } ^n A _{ i , S _{ P _i  }  } ) ( \sum _{ Q  } ( - 1 ) ^{ \lambda ( Q )  } \prod _{ i = 1  } ^n B _{ S _i , Q _i  } ) \\
& = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum _{ P  } \sum _{ Q  } ( - 1 ) ^{ \lambda ( P ) + \lambda ( Q )  } \prod _{ i = 1  } ^n A _{ i , S _{ P _i  }  } B _{ S _i , Q _i  } 
\end{aligned}</script><p>若让$R $为可重集合,换言之让其取遍$m ^n $种情况,又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\det ( AB ) & = \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } \prod _{ i = 1  } ^n ( \sum _{ j = 1  } ^m A _{ i , j  } B _{ j , P _i  } ) \\
& = \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } \sum _{ R , \forall i , R _i \in [ 1 , m ]  } ( \prod _{ i = 1  } ^n A _{ i , R _i  } B _{ R _i , P _i  } ) \\
& = \sum _{ R , \forall i , R _i \in [ 1 , m ]  } \sum _P ( - 1 ) ^{ \lambda ( P )  } ( \prod _{ i = 1  } ^n A _{ i , R _i  } ) ( \prod _{ i = 1  } ^n B _{ R _i , P _i  } ) 
\end{aligned}</script><p>如果$\exists 1 \leq i , j \leq n , i \ne j $,$R _i = R _j $,则交换$P _i , P _j $后,后面的值仍然不变,可逆序对的奇偶性改变了.如果我们对于每一个重复序列都选取最靠前的一对,那么显然只有$R $不重的情况才有可能产生贡献.既然如此,$R $的生成方式就应该是先顺序取子集再用一个排列打乱顺序.</p>
<p>所以我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\det ( AB ) & = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum _{ Q  } \sum _{ P  } ( - 1 ) ^{ \lambda ( P )  } ( \prod _{ i = 1  } ^n A _{ i , S _{ Q _i  }  } ) ( \prod _{ i = 1  } ^n B _{ S _{ Q _i  } , P _i  } ) \\
& = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum _{ Q  } \sum _{ P _{ Q '  }  } ( - 1 ) ^{ \lambda ( P _{ Q '  } )  } ( \prod _{ i = 1  } ^n A _{ i , S _{ Q _i  }  } ) ( \prod _{ i = 1  } ^n B _{ S _i , P _{ Q ' _i  }  } ) \\
& = \sum _{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n  } \sum _{ Q  } \sum _{ P _{ Q '  }  } ( - 1 ) ^{ \lambda ( P ) + \lambda ( Q )  } ( \prod _{ i = 1  } ^n A _{ i , S _{ Q _i  }  } ) ( \prod _{ i = 1  } ^n B _{ S _i , P _{ Q ' _i  }  } ) \\

\end{aligned}</script><p>左右显然相等.</p>
<p>另外,这个定理有更简单的证明方法,即使用LGV引理与组合意义证明.</p>
<p>不妨设现在有个点的集合$A , B , C $,现在想求出$A \rightarrow B \rightarrow C $的不交路径的奇偶数量差,会发现左右的组合意义是相等的.</p>
<p>于此之外,还有一个纯代数的证明策略,不妨定义符号$A \binom { I  } { J  } = A \binom { i _1 , \cdots , i _r  } { j _1 , \cdots , j _s  } $表示提取下标集$I $和$J $分别作为行列得到的矩阵.</p>
<p>先证明一个引理:$C \in M _{ n \times n  } , [ x ^{ n - k  } ] \det ( xI + C ) = \sum _{ I \in \{ 1 , \cdots , n \} , | I | = k  } \det C \binom { I  } { I  } $.</p>
<p>回忆到运算符$\delta _{ i , j  } = [ i = j ] $,应当注意到:$\det ( xI + C ) = \sum _{ \sigma  } \text { sgn  } ( \sigma ) \prod _{ i = 1  } ^n ( x [ i = j ] + c _{ i , \sigma ( i )  } ) $,此时要想凑出$x ^{ n - k  } $,就需要有$n - k $个位置被卡死,而剩下的部分无非是提取剩下$k $行$k $列后的结果.就可以见到上述引理无非定义的平凡推论.</p>
<p>然后开始证明该定理,回忆到我们已经证明过$x ^{ m - n  } \det ( xI + AB ) = \det ( xI + BA ) $.此时对左右两边取$[ x ^{ m - n  } ] $,左边取出了$\det ( xI + AB ) $的常数项,亦即$\det ( AB ) $.而右边,按上述引理得知得到了$\sum _{ I \in \{ 1 , \cdots , n \} , | I | = k  } \det \left ( ( BA ) \binom { I  } { I  } \right ) $,而这恰为原本右式的矩阵乘法定义.</p>
<p>由该定理得知,对于$A \in M _{ m \times n  } $,$\det { A ^T A  } \geq 0 $.</p>
<h4><span id="特征值与特征向量">特征值与特征向量</span></h4><p>我们之前应当已经见到,如果一个矩阵是分块对角矩阵,那这个矩阵应当相当容易处理,原因是其加减乘运算无非只是在对角线上的适当操作而已.这引发我们选取适当的直和分解$V = \bigoplus V _k $将原本的矩阵化为合适的分块对角矩阵.</p>
<p>然而如果我们想要拿到具体的矩阵就不可避免地需要选基,因此在固定的基意义下,我们对于一个矩阵$A $,应当思考能否通过换基操作使得$A = P ^{ - 1  } BP $,其中$B $是一个分块对角矩阵,那此时$A $也拥有相当好的性质.</p>
<p>考虑最简单的情况,即每个分块都是单个元素的情况,此时该矩阵应当就是一个对角矩阵.这相当于选定一组基$\{ \vec { v  } _1 , \cdots , \vec { v  } _n \} $后,取$V _k = \text { span  } \{ \vec { v  } _k \} $并将这些$V _k $取直和得到$V $,此时该线性映射应当给出$T \vec { v  } _k = \lambda _k \vec { v  } _k $,即只能做一个伸缩变换.上面的种种操作都引诱我们去思考能否进行以上操作,这就引入下面的定义:</p>
<p>设$T \in \text { End  } ( V ) $并且$\lambda \in F $,我们引入如下定义:</p>
<ol>
<li><p>称子空间$V _\lambda = \ker ( \lambda \times \text { id  } _V - T ) $为$T $的$\lambda $<strong>特征子空间</strong>,若$V _\lambda \ne \{ 0 \} $,则称$\lambda $为$T $的<strong>特征值</strong>.</p>
</li>
<li><p>对于$\vec { v  } \in V _\lambda $,换言之$T \vec { v  } = \lambda \vec { v  } $,而且$\vec { v  } \ne 0 $,则称$\vec { v  } $是$T $的一个<strong>特征向量</strong>,以$\lambda $为特征值.</p>
</li>
</ol>
<p>考虑特征值的定义等价于$\det ( \lambda \times I - T ) = 0 $,于是等价于$\text { char  } _T ( \lambda ) = 0 $.立刻见到一个$\lambda $是特征值等价于其是$\text { char  } _T = 0 $的一个根.反之,$\text { char  } _T = 0 $的一个根也一定对应了一个非空的特征子空间,也就对应了一组非零特征向量.如果$T $分裂,见到行列式其实是特征值的乘积,而迹实际上是特征值的加和.应当见到,一个矩阵可逆等价于其不存在$0 $特征值.</p>
<p>考虑对角化,如果我们能在上面取出若干$\vec { v  } $组成一组基,那直接用这组基就可以把$T $拆成在这组基上的伸缩变换,这样就实现了对角化.因此如果我们能取出一组基使得每一个基对$A $都是特征向量,我们称$A $是<strong>可对角化的</strong>.立刻见到可对角化的必要条件是$\text { char  } _A $分裂.</p>
<p>如果$T $可对角化,我们有$\dim V _\lambda = d $,其中$d $是$\lambda $作为特征多项式的根的重数.如果其可对角化,直接按上述方式取基得到$z $,并且$PTP ^{ - 1  } $就是在标准基下的变换矩阵.那么直接考虑$\text { rk  } ( \lambda _n I - T ) = n - d $,其中$d $是$\lambda _n $的重数.用同态基本定理立刻得到$V _{ \lambda _n  } = d $.(注意这里都是在讨论可对角化的前提下)</p>
<p>我们希望能把$V _{ \lambda _k  } $给做直和,那我们就需要做前置工作.具体而言,我们需要证明选取$\vec { v  } _k \in V _{ \lambda _k  } $,那么$\sum \vec { v  } _k = \vec { 0  } \Leftrightarrow \forall k , \vec { v  } _k = \vec { 0  } $.使用数学归纳,注意到$T ( \sum \vec { v  } _k ) = \sum \lambda _k \vec { v  } _k = 0 $,又知道$\lambda _1 \sum \vec { v  } _k = 0 $,两者一消就可以进行数学归纳.</p>
<p>由上面的过程得知下述命题等价:</p>
<ol>
<li><p>$T $在$F $上可对角化.</p>
</li>
<li><p>$\sum _{ \lambda \in F  } \dim V _{ \lambda  } = \dim V $.</p>
</li>
<li><p>$\bigoplus _{ \lambda \in F  } V _\lambda = V $.</p>
</li>
</ol>
<p>其推论是如果所有的$\lambda _k $互不相同,那么$\dim V _{ \lambda _k  } \geq 1 $,这必然给出$T $可对角化.这似乎告诉我们去除重数有某种很好的性质.</p>
<h4><span id="极小多项式">极小多项式</span></h4><p>考虑对于一个多项式$h \in F [ x ] $,当我们将$T \in \text { End  } ( V ) $带入之后当然会得到一个$h ( T ) \in \text { End  } ( V ) $,现在固定$h , T $,以此构造一个子空间$V [ h ] = \ker ( h ( T ) ) = \{ \vec { v  } \in V | h ( T ) \vec { v  } = 0 \} $.</p>
<p>此时注意到$T ( V [ h ] ) \subseteq V [ h ] $,原因是$T $与自身交换,于是$\forall \vec { v  } \in V [ h ] $,应当有$h ( T ) ( T \vec { v  } ) = Th ( T ) \vec { v  } = T ( \vec { 0  } ) = \vec { 0  } $,这意味着$T \vec { v  } \in V [ h ] $.于是可见到$V [ h ] $实际上是一个$T $不变子空间.</p>
<p>取$h = x - \lambda I $,那么$V [ h ] $其实就是我们上述所说的$V _\lambda $,因此$V _\lambda $也是$T $不变的.从这里立刻能看出些什么,比如当$\dim V _\lambda = 1 $的时候,$T $不变当然意味着伸缩变换.</p>
<p>那我们既然需要这个东西用在$V _\lambda $上,首要要做的当然是分析在其上面的直和分解.换言之,我们下面试图证明如下引理(核引理):$f \bot g $的时候,$V [ fg ] = V [ gf ] = V [ f ] \oplus V [ g ] $.</p>
<p>原因是考虑$F [ x ] $的主理想性引出其裴蜀定理,那么就存在多项式$a , b $使得$af + bg = 1 $.此时$\vec { v  } = ( af + bg ) ( T ) \vec { v  } = a ( T ) ( f ( T ) \vec { v  } ) + b ( T ) ( g ( T ) \vec { v  } ) $.注意到如果$\vec { v  } \in V [ fg ] $,那么$f ( T ) \vec { v  } \in V [ g ] , g ( T ) \vec { v  } \in V [ f ] $,而$V [ g ] $和$V [ f ] $对$a ( T ) $和$b ( T ) $都是不变子空间,原因是它们对$T $都是不变子空间,这必然意味着$a ( T ) ( f ( T ) \vec { v  } ) \in V [ g ] $,后者亦然同理.这意味着$V [ fg ] \subseteq V [ f ] + V [ g ] $,而$V [ f ] \subseteq V [ fg ] , V [ g ] \subseteq V [ fg ] $,这立刻得到$V [ fg ] = V [ f ] + V [ g ] $.此时检查$\vec { v  } \in V [ g ] \cap V [ f ] $,发现$\vec { v  } = ( af + bg ) ( T ) \vec { v  } = \vec { 0  } $,这就意味着$V [ fg ] = V [ f ] \oplus V [ g ] $.</p>
<p>考虑$I = \{ f \in F [ x ] | f ( T ) = 0 _V \} $,容易见到其应当也有某种$\ker $的性质,事实上可以证明它是一个理想,原因是当然满足加法和乘法的封闭律.而由于$F [ x ] $是一个主理想环,那么上面就应当存在一个$\deg $极小的$h $,使得$I = ( h ) $,不妨将$h $规范化为首一的多项式.那么以上操作给出:$f ( T ) = 0 \Leftrightarrow h | f $.</p>
<p>由Cayley-Hamilton定理,当维度有限的时候,这样的多项式必然存在,这就意味着$I \ne \{ 0 \} $,此时我们就把上面的这个$h $叫做$T $的<strong>极小多项式</strong>$\text { Min  } _T $.</p>
<p>值得一提的是如果$A $是在$F $上的矩阵,其极小多项式为$\text { Min  } _{ A , F  } $,$F $是$E $的子域,$A $在$E $上的极小多项式为$\text { Min  } _{ A , E  } $,则$\text { Min  } _{ A , F  } = \text { Min  } _{ A , E  } $.原因是首先$\text { Min  } _{ A , E  } | \text { Min  } _{ A , F  } $,于是$\text { Min  } _{ A , E  } = \text { Min  } _{ A , F  } $等价于$A ^0 , \cdots , A ^{ d - 1  } $线性无关,其中$d = \deg \text { Min  } _{ A , F  } $.而判定线性无关实际上是用高斯消元判定的,和域的选取无关.</p>
<p>用一次Cayley-Hamilton定理,知道$\text { Min  } _T | \text { char  } _T $.既然如此,$\text { Min  } _T $保留了$\text { char  } _T $的哪些具体性质呢?它们之间的关系又如何呢?我们下面尝试证明:如果$\lambda $是$T $的特征值,当且仅当$\text { Min  } _T ( \lambda ) = 0 $.</p>
<p>充分性显然,因为我们已经声明了只要是$\text { char  } _T $的一个根就自动是特征值.</p>
<p>下面证明必要性:注意到如果$\lambda $是特征值,此时$\vec { 0  } = \text { Min  } _T ( T ) \vec { v  } = \text { Min  } _T ( \lambda ) \vec { v  } $,原因是观察到如果$T \vec { v  } = \lambda \vec { v  } $,那么立刻得到$f ( T ) \vec { v  } = f ( \lambda ) \vec { v  } $.于是立刻得到$\text { Min  } _T ( \lambda ) = 0 $.</p>
<p>此时见到端倪,我们再证明以下定理:</p>
<p>对于固定的$T \in \text { End  } ( V ) $如果有直和分解$V = \bigoplus V _k $,其中每个$V _k $都是$T $不变子空间,那么就可以把$T $限制到相应的$V _k $空间内,记作$T | _{ V _k  } \in \text { End  } ( V _k ) $,那在这些空间内部自然有它们自己的极小多项式$\text { Min  } _{ T _k  } $,我们断言$\text { Min  } _T = \text { lcm  } _k ( \text { Min  } _{ T _k  } ) $.原因是由于直和的性质,$f ( T ) = \vec { 0  } $当且仅当对于每一个$k $,$f ( T _{ k  } ) = 0 $,应用极小多项式的定义立刻见到上述结论显然.</p>
<p>对于$T \in \text { End  } ( V ) $,我们应当能见到此时$V = V [ \text { Min  } _{ T  } ] $.那么反过来,$V [ \text { Min  } _T ] = V $的极小多项式当然也是$\text { Min  } _T $本身,这只是定义.</p>
<p>不妨设$\text { Min  } _T = fg $并且$f \bot g $,从上面当然可以知道$V = V [ f ] \oplus V [ g ] $.此时我们应当思考的是$V [ f ] $中的极小多项式是否是$f $,$V [ g ] $中的极小多项式是否是$g $.而$\text { Min  } _T $是$V [ f ] $和$V [ g ] $中极小多项式的乘积,它们中的极小多项式又只是$f , g $的因子,那必然见到极小多项式就是它们.</p>
<p>我们理应从上面的分析中见到极小多项式形态的一种刻画,我们接下来尝试证明,如果$T $在$F $上可对角化,其特征值去重后是$\lambda _1 , \cdots , \lambda _m $,那么最小多项式$\text { Min  } _T = \prod _{ k = 1  } ^m ( x - \lambda _k ) $.</p>
<p>原因是考虑$T $可对角化导致$V $可以被拆成特征子空间的直和$V = \bigoplus _{ k = 1  } ^m V _{ \lambda _k  } $.而其限制在每一个特征子空间上都是一个伸缩变换,其对应的极小多项式无外乎$x - \lambda _k $,这样就得到上面的结论.</p>
<p>上述结论反之依然成立,那我们可以拿出一个更好的结论了,即:$T $在$F $上可对角化的充要条件是极小多项式$\text { Min  } _T \in F [ x ] $分裂并且无重根.</p>
<p>必要性在上面已经证明,接下来说明充分性.</p>
<p>当$\text { Min  } _T = \prod _{ k = 1  } ^m ( x - \lambda _k ) $的时候,我们下面证明$T $可对角化,顺便说明此时$\lambda _1 , \cdots , \lambda _m $就是$T $的特征值去重后的结果.运用上述结论可以知道$V = \bigoplus V [ x - \lambda _k ] $.然而$V [ x - \lambda _k ] = V _{ \lambda _k  } $,这立刻就回到了可对角化的等价条件,于是充分性得证.</p>
<p>应当能从上面看出可对角化的某种拆分性,事实上,如果$T \in \text { End  } ( V ) $可对角化,$V _0 \subseteq V $是$T $下的不变子空间,则$T | _{ V _0  } \in \text { End  } ( V _0 ) $和$\bar { T  } \in \text { End  } ( V / V _0 ) $都可以对角化.原因是它们的极小多项式都应当是$\text { Min  } _T $的因子.</p>
<p>然而也可以看出来上述命题的逆并不成立,因为拆出来的两个的极小多项式并不一定互质.</p>
<h4><span id="同步对角化">同步对角化</span></h4><p>设$\mathcal { S  } \subseteq \text { End  } ( V ) $,如果存在$V $的基$\vec { v  } _1 , \cdots , \vec { v  } _n $使得每个$\vec { v  } _i $都是所有$T \in \mathcal { S  } $的共同的特征向量,换言之每一个$T $都可以用同样的一个可逆矩阵$P $使得$P ^{ - 1  } AP $是对角的,那我们称$\mathcal { S  } $在$F $上可以<strong>同步对角化</strong>.</p>
<p>我们首先证明一个引理:如果$ST = TS $,那么$T $的任何一个特征子空间$V _\lambda $都是$S $的一个不变子空间.原因是对于$\vec { v  } \in V _\lambda $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T \vec { v  } & = \lambda \vec { v  } \\
ST \vec { v  } & = \lambda ( S \vec { v  } ) \\
T ( S \vec { v  } ) & = \lambda ( S \vec { v  } ) 
\end{aligned}</script><p>所以$S \vec { v  } \in V _\lambda $.</p>
<p>我们得知同步对角化的充要条件应该是以下两条同时成立:</p>
<ol>
<li><p>每个$T \in \mathcal { S  } $在$F $上都可对角化.</p>
</li>
<li><p>$\forall T , T ‘ \in \mathcal { S  } $,$TT ‘ = T ‘ T $.</p>
</li>
</ol>
<p>必要性显然,下面来说明充分性.</p>
<p>取出$T _1 $的所有特征子空间$V _\lambda $,由于$T ‘ $可对角化,所以其限制在$T ‘ | _{ V _\lambda  } $上肯定也可对角化.如果我们能说明限制在每一个特征子空间$V _\lambda $上时都可以同步对角化,由于特征子空间是直和分解,所以取直和后当然也可以.此时注意到限制后的$T ‘ $必然也有交换律,而$T _1 | _{ V _\lambda  } $本身应当是$\lambda I $.这个东西怎么着都是可对角化的,因此就只需要对除了$T _1 $剩下部分继续做,这样就实现了数学归纳.</p>
<h4><span id="上三角化">上三角化</span></h4><p>回忆到我们之前曾经提过的旗的概念,我们在下面断言:若$T \in \text { End  } ( V ) $保持$V $的一组完备旗,则$T $在$F $上<strong>可上三角化</strong>,也就是其可以换基得到一个上三角矩阵.</p>
<p>我们已经得知一般的矩阵未必能对角化,那能不能退而求其次讲一个矩阵通过共轭转化为上三角的形式呢?我们下面证明:$\text { char  } _T $在$F $上分裂是$T $在$F $上可上三角化的充要条件.</p>
<p>先证明必要性:当其可上三角化的时候,可以取$V $的一组有序基,使得$T $对应的矩阵形如$\begin{bmatrix}\lambda _1 &amp; \cdots &amp; \cdots \ 0 &amp; \ddots &amp; \cdots \ 0 &amp; 0 &amp; \lambda _n \end{bmatrix} $,此时立刻能得到其$\text { char  } _T = \prod ( x - \lambda _k ) $,这立刻给出其可分裂.</p>
<p>再证明充分性:数学归纳,取出$\lambda _1 $和$\vec { v  } _1 \in V _{ \lambda _1  } \setminus \{ 0 \} $,再令$V _1 = \text { span  } \{ \vec { v  } _1 \} $,这里拿到的$V _1 $当然是一个不变子空间.仍取$\pi : V \to V / V _1 $,接下来观察$V / V _1 $的维数降了一维,根据数学归纳那其当然可以上三角化.回忆到我们曾经声明过了此时$\text { char  } _T = ( x - \lambda _1 ) \text { char  } _{ \bar { T  }  } $,原因是之前曾提过的在此分解下行列式之间的关系.可上三角化应当给出在$V / V _1 $上的一个被$\bar { T  } $保持的完备旗$\{ 0 \} = \bar { V _1  } \subsetneq \cdots \subsetneq \bar { V _n  } = \bar { V  } $.第一同构定理已经声明过对他们取原像后仍然是子空间,于是我们取原像应当可以重新得到一列完备旗:$\{ 0 \} = V _0 \subsetneq V _1 \subsetneq \cdots \subsetneq V _n = V $.</p>
<p>我们断言上述的旗也被$T $保持,原因是$\vec { v  } \in V _i \Rightarrow \pi ( T \vec { v  } ) = \bar { T  } ( \pi \vec { v  } ) \in \bar { T  } ( \bar { V  } _i ) \subseteq \bar { V  } _i = \pi ( V _i ) $,这当然意味着$T \vec { v  } \in V _i $,于是数学归纳就成立了.</p>
<p>值得一提的是上述证明可以原样拿来证明Cayley-Hamilton定理.方法是仍采取数学归纳,取$V _1 = \text { span  } \{ \vec { v  } _1 \} $后,用数学归纳应当有$\prod _{ k = 2  } ^n ( \bar { T  } - \lambda _i I ) = \text { char  } _{ \bar { T  }  } ( \bar { T  } ) = 0 $.然而我们早就知道了$\bar { T  } = \pi T $,于是立刻得知$\forall \vec { v  } \in V , \prod _{ k = 2  } ^n ( T - \lambda _i I ) ( \vec { v  } ) \in V _1 $,两边同做$T - \lambda _1 I $映射立刻得到结论.</p>
<h4><span id="广义特征子空间">广义特征子空间</span></h4><p>定义$V _{ [ \lambda ]  } = \bigcup _k V [ ( x - \lambda ) ^k ] $.</p>
<p>先来分析其与通常讨论的特征子空间之间的关系,我们声明:$V _{ [ \lambda ]  } \ne 0 \Leftrightarrow V _\lambda \ne 0 $.</p>
<p>由于$V _\lambda \subseteq V _{ [ \lambda ]  } $,右推左是显然的.</p>
<p>而考虑左推右,$\exists \vec { v  } \in V _{ [ \lambda ]  } , ( T - \lambda ) ^N \vec { v  } = \vec { 0  } , ( T - \lambda ) ^{ N - 1  } \vec { v  } \ne \vec { 0  } $,那么$( T - \lambda ) ^{ N - 1  } \vec { v  } \in V _{ \lambda  } $.</p>
<p>这个无限取并能不能降下去呢?而且上面这个东西应当需要有一种划分原空间的策略,这就意味着其应当和极小多项式有一定关系.事实上,如果特征多项式$\text { char  } _T = \prod ( x - \lambda _i ) ^{ a _i  } $,极小多项式$\text { Min  } _T = \prod ( x - \lambda _i ) ^{ b _i  } $,那么$V _{ [ \lambda _i ]  } = V [ ( x - \lambda _i ) ^{ b _i  } ] $.首先肯定有$V [ ( x - \lambda _i ) ^{ b _i  } ] \subseteq V _{ [ \lambda _i ]  } $,所以只需证明反向包含即可.</p>
<p>此时注意到$\forall \vec { v  } \in V _{ [ \lambda _i ]  } $,则存在$k $使得$( T - \lambda _i ) ^k \vec { v  } = \vec { 0  } $.此时取$h = \gcd ( ( x - \lambda _i ) ^k , \text { Min  } _T ) $,用裴蜀定理立刻得到$h = a ( x - \lambda _i ) ^k + b \text { Min  } _T $,于是立刻见到$h ( T ) \vec { v  } = \vec { 0  } $.但容易注意到$h | ( x - \lambda _i ) ^{ b _i  } $,这就证完了.</p>
<p>那么从之前我们的分析立刻得知$V = V [ \text { Min  } _T ] = \bigoplus _{ i  } V _{ [ \lambda _i ]  } $.并且见到$V _{ [ \lambda _i ]  } $的极小多项式就是$( x - \lambda _i ) ^{ b _i  } $,而因为极小多项式和特征多项式的根集相同并且原本的特征多项式等于分空间的特征多项式的乘积,因此特征多项式就是$( x - \lambda _i ) ^{ a _i  } $.</p>
<p>接下来我们定义代数重数:作为特征多项式的根的重数.几何重数:$\dim V _{ \lambda _i  } $.</p>
<p>注意到代数重数$\geq $几何重数,等式成立当且仅当$V _{ \lambda _i  } = V _{ [ \lambda _i ]  } $.原因是$a _i = \deg \text { char  } _{ T _i  } = \dim V _{ [ \lambda _i ]  } \geq \dim V _{ \lambda _i  } $.</p>
<p>由于可对角化等价于可以拆分成若干特征子空间的直和,我们之前又已经证明过可对角化的几何重数一定等于代数重数,于是可对角化当且仅当几何重数等于代数重数.</p>
<p>另外代数重数和几何重数的关系还可以从线性方程组的角度理解,因为特征空间的维度就是$\lambda _k I - A $的自由变量的数量.而$\lambda _k $的代数重数意味着$( x - \lambda _k ) $这一项在对角线的出现次数,现在这些位置都变成了$0 $,也就最多会有这么多个自由变量(还有可能上面某位置也有可以当主元的点顶替了他).那么几何重数就是实际上的自由量.</p>
<h4><span id="特殊矩阵的特征值">特殊矩阵的特征值</span></h4><h6><span id="example">Example</span></h6><p>回忆道斐波那契数列应当转移矩阵为$T = \begin{bmatrix}0 &amp; 1 \ 1 &amp; 1 \end{bmatrix} $,如果能把这个东西对角化的话就会很舒服.直接解特征值能解出来$\text { char  } _T = x ^2 - x + 1 $,两个特征值$\lambda = \frac { 1 \pm \sqrt { 5  }  } { 2  } $.</p>
<p>然后需要去解特征向量再用特征向量取基,解出来$\vec { v  } = \left ( \begin{matrix}1 \ \frac { 1 \pm \sqrt { 5  }  } { 2  } \end{matrix} \right ) $,这样立刻就拿到了换基矩阵$P = [ \vec { v  } _1 , \vec { v  } _2 ] $和对角矩阵$D = \begin{bmatrix}\lambda _1 &amp; 0 \ 0 &amp; \lambda _2 \end{bmatrix} $,并且拿到$D = P ^{ - 1  } TP $.</p>
<h3><span id="双线性形式">双线性形式</span></h3><h4><span id="线性映射">线性映射</span></h4><p>给定$F $上的线性空间$V _1 , \cdots , V _n , W $,我们定义一个<strong>多重线性映射</strong>$C : V _1 \times \cdots \times V _n \to W $.满足其对每一个分量都是线性的.也即固定其他$m - 1 $个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C ( \cdots , t \vec { v  } _i , \cdots ) & = tC ( \cdots , \vec { v  } _i , \cdots ) \\
C ( \cdots , \vec { v  } _i + v _i ' , \cdots ) & = C ( \cdots , \vec { v  } _i , \cdots ) + C ( \cdots , \vec { v  } _i ' , \cdots ) 
\end{aligned}</script><p>特别地,当$W = F $的时候也叫做<strong>多重线性形式</strong>.</p>
<p>容易见到交错形式无非是多重线性形式的某种特例.</p>
<p>还可以看到多重线性映射的集合$\text { Mul  } ( V _1 , \cdots , V _n ; W ) $本身也是线性空间.</p>
<p>更常用的是双线性映射,一般记作$\text { Bil  } ( V _1 , V _2 ; W ) $.矩阵乘法本身是双线性映射的一个典型例子,对偶空间本身也是双线性形式的一个典型例子.特别地,一般定义$V $和$\check { V  } $之间的<strong>典范配对</strong>为$\langle _ , _ \rangle : \check { V  } \times V \to F $.其也可以看作点乘或者$( 1 \times n ) \times ( n \times 1 ) $的矩阵乘法.</p>
<p>留意到柯里化过程,设$\dim V = n , \dim W = m $,容易见到:</p>
<script type="math/tex; mode=display">
\begin{gathered}
M _{ m \times n  } \cong \\
\text { Hom  } ( V , \check { W  } ) \cong \text { Bil  } ( V , W ; F ) \cong \text { Hom  } ( W , \check { V  } ) \\
\cong M _{ n \times m  } 
\end{gathered}</script><p>证明是平凡的.</p>
<p>这就能看出$M _{ n \times m  } \cong \text { Bil  } ( V \cong F ^n , W \cong F ^m ; F ) $,留意到其实可以取$A : W \to V $以$( \vec { v  } , \vec { w  } ) \mapsto \check { \vec { v  }  } A \vec { w  } $.取二者的坐标表示,立刻见到$( \vec { v  } , \vec { w  } ) \mapsto \sum _{ i  } \sum _j v _i a _{ i , j  } w _j = ( \vec { v  } ) ^T A \vec { w  } $.留意到如果设$C ( \vec { w  } , \vec { v  } ) = B ( \vec { v  } , \vec { w  } ) $,这个$C $对应的矩阵实际上就是对$B $对应的矩阵取了转置.</p>
<p>接下来考虑对其取直和,不妨考虑$B _1 : V _1 \times W _1 \to F , B _2 : V _2 \times W _2 \to F $,则令$B _1 \oplus B _2 : ( V _1 \oplus V _2 ) \times ( W _1 \oplus W _2 ) \to F $,其中$( ( \vec { v  } _1 , \vec { v  } _2 ) , ( \vec { w  } _1 , \vec { w  } _2 ) ) \mapsto B _1 ( \vec { v  } _1 , \vec { w  } _1 ) + B _2 ( \vec { v  } _2 , \vec { w  } _2 ) $.容易见到这是一个双线性形式.并且其代表的矩阵当然是原本的$B _1 , B _2 $对应的矩阵组成的分块对角矩阵.</p>
<p>考虑双线性形式$B : V \times V \to F $.称其为<strong>对称的</strong>当且仅当$B ( \vec { v  } , \vec { w  } ) = B ( \vec { w  } , \vec { v  } ) $,称其为<strong>反对称的</strong>当且仅当$B ( \vec { v  } , \vec { w  } ) = - B ( \vec { w  } , \vec { v  } ) $.容易看到对称的当且仅当其对应的矩阵为<strong>对称矩阵</strong>,即$A = A ^T $,原因是$B ( \vec { w  } , \vec { v  } ) = ( \vec { w  } ) ^T A \vec { v  } = ( \vec { v  } ) ^T A ^T \vec { w  } $.反对称的对应的矩阵成为<strong>反对称矩阵</strong>或者<strong>斜对称矩阵</strong>,即$- A = A ^T $.</p>
<h4><span id="非退化形式">非退化形式</span></h4><p>对于双线性形式$B : V \times W \to F $,称$\vec { v  } $是$B $的一个<strong>左根</strong>当且仅当$B ( \vec { v  } , _ ) \equiv 0 $.同理可以定义<strong>右根</strong>.容易见到左根右根集合分别应当是$V , W $的子空间.将左根空间记作$^{ \bot  } V $,右根空间记作$W ^{ \bot  } $.</p>
<p>当$V = W $并且$B $是对称的或者反对称的时候,此时左根和右根是一回事,一般将它们统称为$B $的根基.</p>
<p>称$B $是<strong>非退化的</strong>,当且仅当其左右根集合都是$\{ \vec { 0  } \} $.</p>
<p>现在考虑对于典范配对$\langle \lambda , \vec { v  } \rangle \to \lambda \vec { v  } $,考虑其左根和右根,显然都只是各自空间里的$\vec { 0  } $,原因是对于前者是一个映射,其映射所有都是$0 $,那它当然是$0 $映射本身.对于后者,考虑取$\vec { v  } \ne \vec { 0  } $,扩充$\vec { v  } $为一组基$\vec { v  } , \vec { v  } _2 \cdots , \vec { v  } _n $,并取其对偶基$\check { v  } , \check { v  } _2 , \cdots , \check { v  } _n $,此时就当然满足$\langle \check { v  } , \vec { v  } \rangle = 1 $,所以它是非退化的.</p>
<p>另一个例子是考虑迹映射$Tr : \text { End  } ( V ) \times \text { End  } ( V ) \to F , ( S , T ) \mapsto \text { tr  } ( ST ) $,容易见到它是对称的.那么考虑其根基,只考虑左根,如果$\forall T , \text { tr  } ( ST ) = 0 $,应当满足对于基矩阵$E _{ i , j  } $满足$\text { tr  } ( SE _{ i , j  } ) = 0 $.容易见到$tr ( SE _{ i , j  } ) = 0 $,所以$S \equiv 0 _{ n \times n  } $.这意味着迹映射是非退化的.</p>
<p>回忆道双线性形式同构于线性映射$\psi \in \text { Hom  } ( V , \check { W  } ) $或$\varphi \in \text { Hom  } ( W , \check { V  } ) $,注意到左根实际上就是$\ker \psi $,右根实际上就是$\ker \varphi $.</p>
<p>不妨假设$\dim V &gt; \dim W $,则$\dim \ker \psi = \dim V - \text { rk  } \psi \geq \dim V - \dim W &gt; 0 $,所以注意到$B $是非退化的一定要有$\dim V = \dim W $.</p>
<p>现在我们对于$B : V \times W \to F $并且满足$\dim V = \dim W $,我们声称以下三条性质等价:</p>
<ol>
<li><p>$B $是非退化的.</p>
</li>
<li><p>左根空间为$0 $.</p>
</li>
<li><p>右根空间为$0 $.</p>
</li>
</ol>
<p>显然只需说明(2)$\Leftrightarrow $(3).两个方向类似,下面只证明(2)$\Rightarrow $(3).而当$\dim \ker \psi = 0 $时,由于两边维数相等,自然得到$\psi $是一个同构.接下来考虑$\vec { w  } $如果是一个右根,那么对此取一个空间$H = \{ \lambda \in \check { W  } \mid \lambda \vec { w  } = 0 \} $,见到$\psi ( V ) $一定是$H $的一个子空间.但是$\dim V = \dim \psi ( V ) \leq \dim H \leq \dim W $,这就看出$\dim H = \dim V = n $.然而当$\vec { w  } \ne \vec { 0  } $的时候,$\dim H $不可能取到满空间,原因是典范同态是非退化的.这就导出了右根空间也是$0 $空间.</p>
<p>另一种看法是直接观察矩阵,右根实际上就是$\ker ( A ) $,左根实际上就是$\ker ( A ^T ) $,那它们的$\dim $当然要相等,原因是它们的$\text { rk  } $相等.</p>
<p>此时也容易注意到,非退化的矩阵实际上也就等价于可逆矩阵.</p>
<p>如果对商空间比较敏感,不妨设左根空间为$L $,右根空间为$R $,我们应当见到$\bar { B  } : ( V / L ) \times ( W / R ) \to F , ( \vec { v  } + L , \vec { w  } + R ) \mapsto B ( \vec { v  } , \vec { w  } ) $是非退化双线性形式.此时见到其实$\dim V - \dim L = \dim W - \dim R $.</p>
<p>适当推广上述结论,我们实际上可以定义任何子空间的$V _0 \subseteq V $的正交空间为$V _0 ^\bot = \{ \vec { w  } \in W \mid \forall \vec { v  } _0 \in V _0 , B ( \vec { v  } _0 , \vec { w  } ) = 0 \} $.同理定义$^\bot W _0 $.容易见到$V _0 \subseteq ^\bot ( V _0 ^\bot ) $.</p>
<p>我们试图寻找一些更好的关系,不妨假设$B $是非退化的,那么立刻有$\dim V = \dim W $,我们下面证明$\dim V _0 ^\bot + \dim V _0 = \dim V $.</p>
<p>令$d = \dim V _0 , n = \dim V = \dim W $已经知道$B $会对应一个同构$\psi : V \cong \check { W  } $,那么取$V _0 $在$\psi $下的像,并取其基$\check { w  } _1 , \cdots , \check { w  } _d $,此时$V _0 ^\bot \subseteq W $是满足$\langle \check { w  } _1 , _ \rangle = \cdots = \langle \check { w  } _d , _ \rangle = 0 $的子空间.</p>
<p>不妨先考虑两个特殊情况并从中窥见归纳的办法.当$d = n $的时候,此时$V _0 ^\bot = V ^\bot $,也就是右根集合,我们之前已经证明过了这是一个零空间.而当$d = 1 $的时候,考虑$\check { w  } _1 $,因为它不是$0 $,所以它必然是$W \to F $的满射,此时意味着$\dim \text { im  }  \check { w  } _1 = 1 $,意味着此时$V _0 ^\bot = \ker ( \check { w  } _1 ) $的维数应当是$n - 1 $.</p>
<p>接下来从上面的结构中跳出来,直接观察$\check { W  } $上的情形,我们将上述的那一组基扩充为$\check { W  } $的基$\check { w  } _1 , \cdots \check { w  } _n $并考虑$W $的子空间列$^\bot \langle \check { w  } _1 \rangle \supseteq \cdots \supseteq ^\bot \langle \check { w  } _1 , \cdots , \check { w  } _n \rangle $.不妨设$W _k = ^\bot \langle \check { w  } _1 , \cdots , \check { w  } _k \rangle $.</p>
<p>然而此时可以见到$W _{ k + 1  } = W _k \cap { ^\bot \langle \check { w  } _{ k + 1  } \rangle  } $,用第二同构定理得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dim ( W _{ k + 1  } ) & = \dim W _k + \dim ^\bot \langle \check { w  } _{ k + 1  } \rangle - \dim ( W _k + ^\bot \langle \check { w  } _{ k + 1  } \rangle ) \\
& \geq \dim W _k + \dim ^\bot \langle \check { w  } _{ k + 1  } \rangle - n \\
& = \dim W _k - 1 
\end{aligned}</script><p>因此每加一个最多降一维(其实等价于把那个$\dim = 1 $的空间商掉了),然而注意到上述空间列的首项是$n - 1 $维,末项是$0 $维,每次降一维的话就可以得到$\dim ^\bot \langle \check { w  } _1 , \cdots , \check { w  } _d \rangle = n - d $,这就证明了上述的结论.</p>
<p>然而上述推断其实并不意味着$V = V _0 ^\bot + V _0 $,也不意味着$V _0 \cap V _0 ^\bot = \{ \vec { 0  } \} $,这两个结论都是得不到的.</p>
<p>然而好用的结论是我们之前已经提过$V _0 \subseteq ^\bot ( V _0 ^\bot ) $,此时我们注意到这个式子两边的维度实际上相等,因此$^\bot ( V _0 ^\bot ) = V _0 $.再次声明此式子只在非退化的前提下成立.</p>
<h4><span id="伴随映射">伴随映射</span></h4><p>考虑两个双线性形式$B _1 , B _2 $,其中$B _1 \in \text { Bil  } ( V _1 , V _1 ‘ , F ) $,$B _2 $类似.我们声称存在唯一的线性映射$\varphi : \text { Hom  } ( V _1 , V _2 ) \to \text { Hom  } ( V _2 ‘ , V _1 ‘ ) , T \mapsto T ^<em> $满足$B _2 ( T \vec { v  } _1 , \vec { v  } _2 ‘ ) = B _1 ( \vec { v  } _1 , T ^</em> \vec { v  } _2 ‘ ) $.其中这个$T ^<em> $称为$T $相对于$B _1 $和$B _2 $的<strong>右伴随</strong>.同理可以定义<strong>左伴随</strong>$^</em> T $满足$B _2 ( \vec { v  } _2 , T \vec { v  } _1 ‘ ) = B _1 ( ^* T \vec { v  } _2 , \vec { v  } _1 ‘ ) $,并且假设$B _1 $非退化,它对应的矩阵$A _1 $可逆.</p>
<p>如何证明这个结论呢?只考虑右伴随的情况,对于某个固定的$\vec { v  } _2 ‘ $,取出映射$B _2 ( T ( _ ) , \vec { v  } _2 ‘ ) : V _1 \to F $.那它当然是$\check { V _1  } $中的元素.而因为$B _1 $非退化,其对应了一个$V _1 ‘ \to \check { V  } _1 $的同构,因此应当存在唯一的$\vec { v  } _1 ‘ $使得其映射到$\check { V _1  } $的时候恰好满足$B _2 ( T ( _ ) , \vec { v  } _2 ‘ ) = B _1 ( _ , \vec { v  } _1 ‘ ) $,这就给出了$T ^* : \vec { v  } _2 ‘ \mapsto \vec { v  } _1 ‘ $.换言之其唯一性取决于$A _1 $的非退化性.取$\varphi _i : V _i ‘ \to \check { V _i  } $且$\varphi _1 $可逆,回忆到之前过程可以知道这里的$\varphi _1 $实际上就是$A _1 $,下述图表的上半部分交换:</p>
<script type="math/tex; mode=display">
\xymatrix { V _2 ' \ar [r ] ^{ T ^*  } \ar [d ] _{ A _2  } & V _1 ' \ar [d ] ^{ A _1  } \\
\check { V _2  } \ar [r ] ^{ ^t T  } & \check { V _1  } \\
V _2 \ar [u ] & V _1 \ar [u ] \ar [l ] _T  }</script><p>另外可以见到如果假设$B _2 $也是非退化的,当线性空间本身满足条件的时候应该有$^<em> ( T ^</em> ) = T = ( ^<em> T ) ^</em> $.还可以见到$( ST ) ^<em> = T ^</em> S ^<em> , ^</em> ( ST ) = ^<em> T ^</em> S $.这还顺便说明了$( T ^{ - 1  } ) ^<em> = ( T ^</em> ) ^{ - 1  } , ^<em> ( T ^{ - 1  } ) = ( ^</em> T ) ^{ - 1  } $.</p>
<p>上面的结论如何用矩阵刻画?只考虑右伴随的部分,选定一组有序基后,将双线性形式对应到矩阵应当有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
B _2 ( T \vec { v  } _1 , \vec { v  } _2 ' ) & = ( \vec { v  } _1 ) ^T T ^T A _2 \vec { v  } _2 ' & = ( \vec { v  } _1 ) ^T A _1 ( A _1 ^{ - 1  } T ^T A _2 ) \vec { v  } _2 ' \\
B _1 ( \vec { v  } _1 , T ^* \vec { v  } _2 ' ) & = ( \vec { v  } _1 ) ^T A _1 T ^* \vec { v  } _2 ' 
\end{aligned}</script><p>比对就可以看到只需取$T ^<em> = A _1 ^{ - 1  } T ^T A _2 $,这与上述交换图表的形式也是符合的.同理可以得到$^</em> T = ( A _2 TA _1 ^{ - 1  } ) ^T $.并从此看出当$B _1 , B _2 $都非退化的时候,伴随不改变矩阵的秩,因为此时伴随矩阵与原矩阵的转置是相抵的.事实上可以直接写出$\ker ( T ^* ) = ( \text { im  } T ) ^\bot $,原因是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ^* \vec { w  } & = 0 \Leftrightarrow \forall \vec { v  } , ( \vec { v  } \mid T ^* \vec { w  } ) & = 0 \\
\Leftrightarrow \forall \vec { v  } , ( T \vec { v  } \mid \vec { w  } ) & = 0 \Leftrightarrow \vec { w  } \in ( \text { im  } T ) ^\bot 
\end{aligned}</script><p>而由同态基本定理,$\dim ( \text { im  } T ) ^\bot = \dim \ker ( T ^<em> ) $,由上可以见到当$\dim V = \dim W $时$\text { rk  }  T = \text { rk  }  T ^</em> $.</p>
<p>当对应的双线性形式非退化的时候回忆到可以两边取$\bot $就拿到$\ker ( T ^* ) ^\bot = ( \text { im  } T ) $.</p>
<p>下面考虑$V _1 = V _2 = V _1 ‘ = V _2 ‘ = V $,并假设$B _1 = B _2 $且二者要么对称要么反对称.此时注意到$T $的左伴随和右伴随是没有区别的,我们将它们统一称作伴随,一般采取右伴随的记号记作$T ^<em> $并尝试通过上下文区分.特别地,如果$T = T ^</em> $,那我们称其为<strong>自伴的</strong>,如果$T = - T ^<em> $,则称其为<em>*反自伴的</em></em>.</p>
<p>如果选取$A _1 = A _2 = I $,那么根据上面的分析见到$T $是自伴的当且仅当$T $是对称的,反自伴的当且仅当其是反对称的.</p>
<h4><span id="分类问题">分类问题</span></h4><p>定义双线性形式上的同构:称$( V _1 , B _1 ) \cong ( V _2 , B _2 ) $,其中$B _1 : V _1 \times V _1 \to F , B _2 : V _2 \times V _2 \to F $,当且仅当存在一个同构$\varphi : V _1 \cong V _2 $,满足$B _2 ( \varphi ( \vec { v  } ) , \varphi ( \vec { v  } ‘ ) ) = B _1 ( \vec { v  } , \vec { v  } ‘ ) $.容易验证这个同构满足等价条件的三条性质:反身性,对称性,传递性.并且双线性形式的几乎所有性质(左右根,根基,对称性,反对称性,退化性)都在同构关系下得到保持.这就意味着双线性形式应该可以以这种同构关系分类.</p>
<p>不失一般性,不妨直接假设$V = F ^n $以简化描述.</p>
<p>我们定义两个$n \times n $的矩阵$A , A ‘ $是<strong>合同的</strong>,当且仅当$\exists C \in ( M _{ n \times n  } ) ^\times $使得$A = C ^T A ‘ C $.容易验证这是一个等价关系.必须要强调这里的$C $是可逆矩阵.</p>
<p>接下来考虑两个双线性形式$B , B ‘ : F ^n \times F ^n \to F $,我们声称当且仅当它们对应的矩阵$A , A ‘ $是合同的有$A = C ^T A ‘ C $时是同构的.同构办法就是利用$C $所代表的线性映射.</p>
<p>对于充分性:只需检验是否有$B ( \vec { v  } _1 , \vec { v  } _2 ) = B ‘ ( C \vec { v  } _1 , C \vec { v  } _2 ) $,而$B ‘ ( C \vec { v  } _1 , C \vec { v  } _2 ) = ( C \vec { v  } _1 ) ^T A ‘ ( C \vec { v  } _2 ) = ( \vec { v  } _1 ) ^T A \vec { v  } _2 = B ( \vec { v  } _1 , \vec { v  } _2 ) $.</p>
<p>对于必要性:考虑所有的同构$\varphi $当然都可以写作可逆矩阵形式,设这个矩阵为$C $,立刻见到应当有$A = C ^T A ‘ C $.</p>
<h4><span id="二次型">二次型</span></h4><p>考虑$\text { char  } \ne 2 $的域$F $,原因是这种域上面存在$\frac { 1  } { 2  } $.为了方便讨论下面不妨直接假设$V = F ^n $.</p>
<p>定义$n $元<strong>二次型</strong>为一个$F $上的齐次多项式$f = \sum _i a _{ i , i  } x _i ^2 + 2 \sum _{ i &lt; j  } a _{ i , j  } x _i x _j $,并在考虑对称的情况下设$a _{ i , j  } = a _{ j , i  } $成立,上述自然有$f = \sum _{ i , j  } a _{ i , j  } x _i x _j $.容易见到$f $实际上可以表示为某一个对称的双线性形式,将这些$a $排列成矩阵就可以见到上述$f ( x ) = ( \vec { x  } ) ^T A \vec { x  } = B ( \vec { x  } , \vec { x  } ) $.这种对应实际上是双射,原因是该多项式也可以反过去确定一个对称的双线性形式,原因是注意到首先$B ( \vec { v  } , \vec { v  } ) $肯定是可以被确定的,其次由于$B ( \vec { v  } _1 + \vec { v  } _2 , \vec { v  } _1 + \vec { v  } _2 ) = B ( \vec { v  } _1 , \vec { v  } _1 ) + B ( \vec { v  } _2 , \vec { v  } _2 ) + 2 B ( \vec { v  } _1 , \vec { v  } _2 ) $,于是立刻得到$B ( \vec { v  } _1 , \vec { v  } _2 ) = \frac { 1  } { 2  } ( f ( \vec { v  } _1 + \vec { v  } _2 ) - f ( \vec { v  } _1 ) - f ( \vec { v  } _2 ) ) $,这就给出了一组一一对应的关系.从这里顺便应该能看出对称双线性形式应该由其所有的$B ( \vec { v  } , \vec { v  } ) $的取值唯一确定.我们会在内积空间里再次讨论这个技巧,这被称为<strong>配极化</strong>.</p>
<p>将合同关系挪到二次型上就可以见到,两个二次型同构当且仅当它们可以通过一个可逆的线性变量替换而相互过渡.</p>
<p>既然如此,应该见到二次型某种意义上同构于矩阵,那么能不能把二次型作对角化呢,也即能否将二次型同构于形如$g = \sum b _i x _i ^2 $的二次型.这个当然可以用配方法解决,具体操作是数学归纳,每次将和一个变量有关的全部赛到一个里面去.</p>
<p>具体地,我们执行以下策略:</p>
<ol>
<li><p>如果当前存在一个$a _{ i , i  } \ne 0 $,不妨设其为$a _{ 1 , 1  } $,那就可以提出一个$a _{ 1 , 1  } ( x _1 + \frac { 1  } { a _{ 1 , 1  }  } \sum _{ k \geq 2  } a _{ 1 , k  } x _k ) ^2 $.</p>
</li>
<li><p>反之,则存在一个$a _{ i , j  } \ne 0 $,不妨在此时做变量替换$y _i = x _i - x _j $换掉$x _i $,这样$x _j ^2 $前的系数就非$0 $,自然回到前一种情况.</p>
</li>
</ol>
<p>上述过程不好机械化,能不能用一些更加形式化的方式呢?考虑配方当然等价于寻找一个可逆矩阵$C $使得对称矩阵$A $被写作$C ^T AC = A ‘ $,而可逆矩阵可以写作若干初等矩阵的乘积,不妨记作$U _1 \cdots U _k $,于是知道我们想要让$( U _1 \cdots U _k ) ^T A ( U _1 \cdots U _k ) $.</p>
<p>这里有一个算法是将矩阵排列成$\begin{bmatrix}A \ I \end{bmatrix} $的形式,然后对其做对称行列变换(这样列变换会影响到下面的$I $,但是行变换不会影响),这样最后会消成$\begin{bmatrix}A ‘ \ C \end{bmatrix} $的形式,就会有$A ‘ = C ^T AC $.</p>
<p>由此可以设$r = \text { rk  } ( f ) $为对角化后剩余的元素个数.见到其根基的维数恰为$n - r $,原因是$\ker A $的维数就是根基的维数.见到其非退化当且仅当$n = r $.</p>
<p>如果我们做的域是一个代数闭域,那么我们上面的分类问题立刻得到了解决,原因是二次型当然可以进一步化简为$\sum _{ k = 1  } ^r y _k ^2 $的形式,因此二次型完全由秩来决定.当然其实代数闭这个性质并没有用完全,实际上上述结论只需要求所有的$F $中元素都有平方根即可.</p>
<h5><span id="实二次型">实二次型</span></h5><p>然而我们知道实数域并不满足以上性质,能不能把实数上的二次型进一步分类呢?虽然不能对$- 1 $开根,但总之可以将二次型同构成$f = \sum _{ k = 1  } ^p x _k ^2 - \sum _{ j = p + 1  } ^r x _j ^2 $.将此称作该二次型的<strong>规范型</strong>.</p>
<p>先对于实二次型引入一些新的定义:对于一个对称双线性形式,如果$\forall \vec { v  } $,$B ( \vec { v  } , \vec { v  } ) \geq 0 $恒成立,则称其为<strong>半正定的</strong>,如果在此基础上当$\vec { v  } \ne 0 $时$B ( \vec { v  } , \vec { v  } ) &gt; 0 $恒成立,则称其为<strong>正定</strong>的.同样可以定义<strong>半负定的</strong>和<strong>负定的</strong>概念.还可以定义<strong>不定的</strong>概念.容易见到如果一个对称双线性形式是正定的或者负定的时候它必然是非退化的,因为此时除了$\vec { 0  } $其无根基.一定要注意这里的正定是在对称性的基础上定义的.</p>
<p>容易见到半正定当且仅当上述$f $中满足$p = r $,正定当且仅当满足$p = r = n $.到这里我们忽然疑问到同构的二次型的$p $是否相等.</p>
<h5><span id="惯性sylvester定理">惯性(Sylvester)定理</span></h5><p>即:对于两个同构的二次型,它们的$( p , r - p ) $相同,一般将$p $称作<strong>正惯性系数</strong>而将$r - p $称作<strong>负惯性系数</strong>,两者的差$2 p - r $一般称作其<strong>符号差</strong>.</p>
<p>之所以会疑惑同构的二次型的$p $不一定相等,是因为同构只搬运了空间上的性质.因此如果我们能把$p $以某种基于空间上的形态,当然就可以显然看出两个同构的二次型的$( p , r - p ) $相同.我们声明对于一个正惯性系数为$p $的二次型以下命题成立:</p>
<ol>
<li><p>存在一个$p $维的正定子空间.</p>
</li>
<li><p>对于任何维数$&gt; p $的子空间,其都不可能是正定的.</p>
</li>
</ol>
<p>(1)显然,直接拿出其正部分对应的空间即可.</p>
<p>(2)的话无非是考虑将鸽笼原理用子空间之间的交写出来,设$N $为后$p + 1 , \cdots , n $这部分所代表的子空间,对于任何一个$V ‘ $子空间满足$\dim V ‘ &gt; p $,直接拿第二同构定理得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dim ( V ' \cap N ) & = \dim ( V ' ) + \dim ( N ) - \dim ( V ' + N ) \\
& \geq n - p + \dim V ' - n & > 0 
\end{aligned}</script><p>这意味着其不为空.</p>
<p>对负惯性系数当然可以类似做.这样惯性定理自然解决了实二次型的分类问题.</p>
<h4><span id="辛空间">辛空间</span></h4><p>回到特征不为$2 $的域$F $上,考虑反对称形式,注意到$B ( \vec { v  } , \vec { v  } ) = - B ( \vec { v  } , \vec { v  } ) $,那此时它们就应该同时为$0 $.这当然类似我们之前说的交错形式.</p>
<p>观察这类反对称形式的根基,取$R ( V ) = \{ \vec { v  } \in V \mid B ( \vec { v  } , _ ) = 0 \} $.此时把补空间拿出来,取$V = R ( V ) \oplus V ‘ $,我们断言$( V , B ) \cong ( R ( V ) , 0 ) \oplus ( V ‘ , B \mid _{ V ‘ \times V ‘  } ) $,其中$B \mid _{ V ‘ \times V ‘  } $是$V ‘ $上的非退化线性形式.这个断言当然是显然的,只需简单拆分空间即可.问题在于如何证明$B \mid _{ V ‘ \times V ‘  } $是$V ‘ $上的非退化线性形式,只需证明$R ( V ‘ ) = \{ 0 \} $,我们考虑如果$\exists \vec { v  } ‘ \in V ‘ $,$\forall \vec { v  } _1 ‘ \in V ‘ , B ( \vec { v  } ‘ , \vec { v  } _1 ‘ ) = 0 $,由于根基当然和任何东西都会变零,因此这等价于$\forall \vec { v  } _1 \in V , B ( \vec { v  } ‘ , \vec { v  } _1 ) = 0 $,这必然意味着$\vec { v  } ‘ \in R ( V ) $,也就是$\vec { v  } ‘ \in R ( V ) \cap V ‘ = \{ 0 \} $.</p>
<p>因此其实反对称双线性形式更重要的是考虑其非退化的部分.将这些非退化反对称双线性形式称为<strong>辛形式</strong>,并将$( V , B ) $称作辛空间.</p>
<p>考虑取一对基$\vec { p  } , \vec { q  } $形成空间$\langle \vec { p  } , \vec { q  } \rangle $并满足$B ( \vec { p  } , \vec { q  } ) = 1 = - B ( \vec { q  } , \vec { p  } ) $,这当然唯一确定了一个辛形式$B $,并且其实际上对应了一个反对称矩阵$\begin{bmatrix}0 &amp; 1 \ - 1 &amp; 0 \end{bmatrix} $,这种二维辛空间一般还被称为<strong>双曲辛平面</strong>.</p>
<p>虽然研究范围被限制在了辛空间上,但仍然能看到辛形式中会因为正负相抵爆出大量的$0 $.设$V _0 $是$V $的子空间,若$B \mid _{ V _0 \times V _0  } \equiv 0 $,我们称$V _0 $是<strong>全迷向子空间</strong>,一个极大(真包含它的子空间全都不是全迷向的)的全迷向子空间称为<strong>拉格朗日子空间</strong>.</p>
<p>设$( V , B ) $为辛空间,$L $是拉格朗日子空间,我们下面证明两个性质:</p>
<ol>
<li><p>$L ^\bot = L $.</p>
</li>
<li><p>$\dim V = 2 \dim L $.</p>
</li>
<li><p>辛空间必定是偶数维的.</p>
</li>
</ol>
<p>如果(1)得证,由于$\dim V = \dim L + \dim L ^\bot $,(2)(3)也就显然了.所以问题在于如何证明(1).</p>
<p>首先全迷向性质自然等价于$L \subseteq L ^\bot $.此时考虑若$\exists \vec { v  } \in L ^\bot \setminus L $,则$L + \langle \vec { v  } \rangle $这个空间仍然是全迷向的(原因是$\vec { v  } $自身的部分会因为交错性质而成$0 $),这就与其极大性矛盾.</p>
<p>我们试图想要找到更好的策略去勾勒$L $以及$V / L $这两部分.</p>
<h5><span id="达布定理">达布定理</span></h5><p>该定理是说:给定一个拉格朗日子空间$L $,$L $的任何有序基$\vec { p  } _1 , \cdots , \vec { p  } _n $都能扩充为$V $的有序基$\vec { p  } _1 , \cdots \vec { p  } _n , \vec { q  } _n , \cdots , \vec { q  } _1 $,使得$\forall 1 \leq i , j \leq n $:</p>
<ol>
<li><p>$B ( p _i , p _j ) = B ( q _i , q _j ) = 0 $.</p>
</li>
<li><p>$B ( p _i , q _j ) = - B ( q _j , p _i ) = \begin{cases}1 &amp; i = j \ 0 &amp; i \ne j \end{cases} $.</p>
</li>
</ol>
<p>这组有序基又被称为$V $的<strong>辛基</strong>.</p>
<p>考虑定义$n - 1 $维子空间$L _i = \langle \vec { p  } _1 , \cdots , \vec { p  } _{ i - 1  } , \vec { p  } _{ i + 1  } , \cdots , \vec { p  } _n \rangle $.留意到此时会有$L = L ^\bot \subsetneq L _i ^\bot , \dim L _i ^\bot = n + 1 $.</p>
<p>接下来数学归纳构造这组$q $.</p>
<p>对于$k = 1 $的情况,由于我们上面的分析,$\exists \vec { q  } _1 \in L _1 ^\bot \setminus L $,于是此时必然满足$B ( \vec { p  } _1 , \vec { q  } _1 ) \ne 0 $而$\forall i \geq 2 , B ( \vec { p  } _i , \vec { q  } _1 ) = 0 $.适当伸缩即可满足条件.</p>
<p>在此之后,假设$k &lt; n $并且我们已经有了$\vec { q  } _1 , \cdots , \vec { q  } _k $使得条件成立,仍然可以取$\vec { q  } _{ k + 1  } ‘ \in L _{ k + 1  } ^\bot \setminus L $,使得$B ( \vec { p  } _i , \vec { q  } _{ k + 1  } ‘ ) \begin{cases}1 &amp; i = k + 1 \ 0 &amp; i \ne k + 1 \end{cases} $满足.</p>
<p>此时注意到,如果用$\vec { q  } _{ k + 1  } = \vec { q  } _{ k + 1  } ‘ + \sum _i a _i \vec { p  } _i $后,上述条件实际上不受影响.然而,只需取$a _i = B ( \vec { q  } _i , \vec { q  } _{ k + 1  } ‘ ) $就自动满足最后的条件.</p>
<p>接下来无非是要证明这些向量线性无关,对于$\sum a _i \vec { p  } _i + \sum b _i \vec { q  } _i = 0 $,两边取$B ( _ , \vec { q  } _i ) $就可以得到$a _i = 0 $,取$B ( \vec { p  } _i , _ ) $就可以得到$b _i = 0 $,这样就做完了.</p>
<p>此时就可以见到,我们实际上是把原空间拆成了两个拉格朗日子空间的直和,并且这两个子空间之间以某种形式连接起来.此时其对应的矩阵就是:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
& & & & & 1 \\
& & & & \cdots & \\
& & & 1 & & \\
& & - 1 & & & \\
& \cdots & & & & \\
- 1 & & & & & 
\end{bmatrix}</script><p>另外,如果$W $是$V $的子空间并且满足$W \cap W ^\bot = \{ 0 \} $,我们称这样的子空间是<strong>辛子空间</strong>.只需套用拉格朗日子空间的过程就可以证明:</p>
<ol>
<li><p>$W $是辛子空间当且仅当$B $在$W $上的限制非退化.</p>
</li>
<li><p>$W $是辛子空间则有直和分解$V = W \oplus W ^\bot $.</p>
</li>
</ol>
<h4><span id="回看对偶空间">回看对偶空间</span></h4><p>应当回忆我们将一个有限维空间对应到其对偶空间的时候所做的努力:先找到原空间的一组基,再对应地找到一组对偶基.然而,这种对应并非空间自身典范的对应,而是需要选定基的人为构造的定义.</p>
<p>回忆我们上述拿到的所有东西,应当可以见到起码以下资料均是典范的:</p>
<ol>
<li><p>典范配对$\langle _ , _ \rangle : V ^\vee \times V \to F , \langle \lambda , \vec { v  } \rangle \mapsto \lambda \vec { v  } $.</p>
</li>
<li><p>转置映射$^t T : W ^\vee \to V ^\vee , \lambda \mapsto \lambda T $.</p>
</li>
</ol>
<h5><span id="双重对偶">双重对偶</span></h5><p>先分析典范配对的情形,考虑到典范配对会给出一个映射$ev _V : V \to ( V ^\vee ) ^\vee , \vec { v  } \mapsto \langle _ , \vec { v  } \rangle $.容易验证这当然是一个同构,而且中途没有用任何取基操作,所以这是一个典范的同构$\text { ev  } _V : V \cong ( V ^\vee ) ^\vee $.更确切地来说,这个$\text { ev  } _V $具有某种函子性.事实上有以下交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^T \ar [d ] _{ \text { ev  } _V  } & W \ar [d ] ^{ \text { ev  } _W  } \\
( V ^\vee ) ^\vee \ar [r ] ^{ ( T ^t ) ^t  } & ( W ^\vee ) ^\vee  }</script><p>虽属显然,但也可以小心地展开定义以确实证明$( \text { ev  } _W ) T = ( T ^t ) ^t \text { ev  } _V $.策略只需任取$\check { w  } $,而观察:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\langle ( ( T ^t ) ^t \text { ev  } _V ) \vec { v  } , \check { w  } \rangle \\
& = \langle ( \text { ev  } _V ) \vec { v  } , T ^t \check { w  } \rangle \\
& = \langle T ^t ( \check { w  } ) , \vec { v  } \rangle \\
& = \langle \check { w  } , T \vec { v  } \rangle \\
& = \langle \text { ev  } _W ( T \vec { v  } ) , \check { w  } \rangle 
\end{aligned}</script><p>而$\check { w  } $可以任取,立刻证毕.</p>
<p>回忆到还有一件重要的事情需要解释,那就是柯里化$\text { Hom  } ( W , V ^\vee ) \cong \text { Bil  } ( V , W ; F ) \cong \text { Hom  } ( V , W ^\vee ) $.从表面上看,它应当是典范的,可实则描述的时候却发现总需要标准内积结构来体现.为解决这个问题,我们下面证明上述同构映射将$\varphi \in \text { Hom  } ( W , V ^\vee ) $为$( \varphi ^t ) \circ \text { ev  } _V \in \text { Hom  } ( V , W ^\vee ) $.</p>
<p>考虑将两边都映射到典范配对的结构上,由双线性形式的定义,$\varphi \in \text { Hom  } ( W , V ^\vee ) $必然映一组$\vec { w  } , \vec { v  } $为$\langle \varphi ( \vec { w  } ) , \vec { v  } \rangle $,这当然是显然的.</p>
<p>回看$( \varphi ^t ) \circ \text { ev  } _V $,它做到的是将一组$\vec { w  } , \vec { v  } $映射到$\langle \text { ev  } _V ( \vec { v  } ) , \varphi ( \vec { w  } ) \rangle $,可只需用$\text { ev  } _V ( \vec { v  } ) $的定义,上述两者当然是相同的.</p>
<p>再最后,我们终于回看基的选取,我们可以证明以下结论:设$V $是有限维的向量空间,$\vec { v  } _1 , \cdots , \vec { v  } _n \in V $是一组有序基,其对偶基记作$\check { v  } _1 , \cdots , \check { v  } _n $.我们声称:$V ^\vee $中的一组元素$\text { ev  } _V ( \vec { v  } _1 ) , \cdots , \text { ev  } _V ( \vec { v  } _n ) $是$\check { v  } _1 , \cdots , \check { v  } _n $的对偶基.也就是说中间不管怎么取对偶形态,最终总会回到一种典范的同构$V \cong V ^\vee $上.</p>
<p>至于证明,无非只是:</p>
<script type="math/tex; mode=display">
\langle \text { ev  } _V ( \vec { v  } _i ) , \check { v  } _j \rangle = \langle \check { v  } _j , \vec { v  } _i \rangle</script><p>立属显然.</p>
<h5><span id="核余核与对偶映射">核,余核与对偶映射</span></h5><p>上述证明揭露了对偶空间的一角.之所以$T ^t $会显示出伴随性质,实际上并不是代数形式上的巧合,而恰是$T ^t $的定义本身就是典范配对上的伴随,而自然会以某种形式显示在新的伴随中.既如此,请以下内容再观$T : V \to W $以及其转置$T ^t : W ^\vee \to V ^\vee $的性质.</p>
<p>首先,容易观察到的应该是$T $单则$T ^t $满,$T $满则$T ^t $单.此结论我们早就得出,策略是使用行秩等于列秩,而由同态基本定理得到$\dim V = \dim \ker T + \text { rk  } T $,如若$T $单,则$\dim \ker T = 0 $,意味着$\text { rk  } T = \dim V $,也就意味着$\text { rk  } T ^t = \dim V ^\vee $,这就得到$T ^t $是满的.反之亦然同理.</p>
<p>然而回看$\text { rk  } T ^t = \text { rk  } T $这个结论的得出其实并不典范,我们推出此结论使用的策略是矩阵的相抵.而找到一种典范的证明此的策略便是重要的.而只需稍有对商操作的直觉就可以看到,要抛开矩阵,用一种真正典范的策略证明行秩等于列秩,必然离不开上述的引理.这就是我们下述真正想要做的事.</p>
<p>现在,设$T $是单射,对于任给的$\mu \in V ^\vee $,尝试找到一个$\tilde { \mu  } \in W ^\vee $使得$\tilde { \mu  } ( T ( x ) ) = \mu ( x ) $,那根据对偶映射的定义,知道这里有$T ^t ( \tilde { \mu  } ) = \mu $.如果这里$\mu $可以任选的话,换言之,对于任意的$\mu $我们都能构造出一个$\tilde { \mu  } $来实现上述过程,当然意味着$T ^t $是满射.可既然这里是构造,我们终于可以放下”典范”的包袱,开始取基.</p>
<p>取$V $的一组基$\mathcal { X  } $,而$T ( \mathcal { X  } ) $当然是$W $的线性无关子集,可以扩展为一组基$\mathcal { Y  } $,这样$\forall \vec { w  } \in W $都有唯一的展开$\sum _{ \vec { y  } \in \mathcal { Y  }  } c _y \vec { y  } $,对于给定的$\mu \in V ^\vee $可以定义$\tilde { \mu  } : W \to F $为:</p>
<script type="math/tex; mode=display">
\tilde { \mu  } ( \sum _{ y \in \mathcal { Y  }  } c _y \vec { y  } ) = \mu ( \sum _{ x \in \mathcal { X  }  } c _{ T ( \vec { x  } ) \vec { x  }  } )</script><p>而当$T $满的时候,设$\tilde { \mu  } \in W ^\vee $,此时如果$T ^t ( \tilde { \mu  } ) = \tilde { \mu  } T = 0 $,因为$T $是满的,这必然意味着$\tilde { \mu  } = 0 $,所以$T ^t $当然是单的.</p>
<p>换句话说,这里通过空间上的结构,用基强行凑出了一个$\ker T $的结构.然而取基总是会让我们忽略空间的结构,并给人一种使用文字游戏偷懒的感觉.或者说,构造性证明必然会有一种失掉典范性的感觉.</p>
<p>现在我们重新展现一下上述取出$\tilde { \mu  } $的合理性:设$T : V \to W $为线性映射,而$\mu \in V ^\vee $,我们声称存在$\tilde { \mu  } \in W ^\vee $使得$T ^t ( \tilde { \mu  } ) = \mu $当且仅当$\mu | _{ \ker T  } = 0 $.</p>
<p>先证明充分性,当$\mu | _{ \ker T  } = 0 $的时候,不妨设$\twoheadrightarrow $是满射而$\hookrightarrow $是单射,如下交换图表当然成立:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar @{->>} [r ] ^T \ar [d ] _\mu \ar @{->>} [dr ] ^\pi & \text { im  } \ ( T ) \\
F & V / \ker ( T ) \ar [l ] ^{ \bar { \mu  }  } \ar @{^{(}->>} [u ] _{ \bar { T  }  }  }</script><p>左下三角形的成立性完全依赖于$\mu | _{ \ker T  } = 0 $的性质,而此时取一个$\tilde { \mu _0  } = \bar { \mu  } \circ ( \bar { T  } ) ^{ - 1  } \in ( \text { im  }  T ) ^{ \vee  } $,而由于$\text { im  } T $自然嵌入$W $中,必有$\text { im  } ( T ) \hookrightarrow W $,那也就意味着$W ^\vee \twoheadrightarrow \text { im  } ( T ) ^\vee $,因此$\tilde { \mu _0  } $就可以延拓为$\tilde { \mu  } \in W ^\vee $,交换图表给出:</p>
<script type="math/tex; mode=display">
\tilde { \mu  } T = \tilde { \mu _0  } T = \bar { \mu  } ( \bar { T  } ) ^{ - 1  } T = \bar { m  } u \circ \pi = \mu</script><p>这就证明了充分性.至于必要性,由于$T ^t ( \tilde { \mu  } ) = \tilde { \mu  } T $,而$\tilde { \mu  } T | _{ \ker T  } = 0 $当然是显然的.</p>
<p>接下来回忆到余核$\text { coker  } ( T ) = W / \text { im  } ( T ) $这个东西,尝试看看它和$\ker T $之间的关系,回忆到我们应该有包含映射$i : \ker ( T ) \hookrightarrow V $和商映射$q : W \twoheadrightarrow \text { coker  } ( T ) $,取对偶见到:</p>
<script type="math/tex; mode=display">
\xymatrix { \text { coker  } ( T ) ^\vee \ar @{^{(}->} [r ] ^{ q ^t  } & W ^\vee \ar [r ] ^{ T ^t  } & V ^\vee \ar @{->>} [r ] ^{ i ^t  } & \ker ( T ) ^\vee \\
\lambda \ar @{|->} [r ] & \lambda q & & \\
& \tilde { \mu  } \ar @{|->} [r ] & \tilde { \mu  } T & \\
& & \mu \ar @{|->} [r ] & \mu i  }</script><p>这个当然没有问题,而我们试图借上面为辅助证明下面这张交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { \text { coker  } ( T ) ^\vee \ar @{^{(}->} [r ] ^{ q ^t  } \ar @{^{(}->>} [d ] & W ^\vee \ar [r ] ^{ T ^t  } & V ^\vee \ar @{->>} [r ] ^{ i ^t  } \ar @{->>} [rd ] & \ker ( T ) ^\vee \\
\ker ( T ^t ) \ar @{^{(}->} [ur ] & & & \text { coker  } ( T ^t ) \ar @{^{(}->>} [u ]  }</script><p>其中竖直方向的同构由左右两部分交换图表各自唯一确定.</p>
<p>先看左部分,我们尝试证明$\text { coker  } ( T ) ^\vee \hookrightarrow W ^\vee $的像正好是$\ker ( T ^t ) $.</p>
<p>先证明$q ^t ( \text { coker  } ( T ) ^\vee ) \subseteq \ker ( T ^t ) $,考虑$\lambda \in \text { coker  } ( T ) ^\vee $,那$q ^t $会将其射到$\lambda q \in W ^\vee $.留意到$T ^t ( \lambda q ) = \lambda q T $,然而根据$\text { coker  } $的定义知道$qT = 0 $,这必然意味着$T ^t ( \lambda q ) = 0 $.</p>
<p>再证明$\ker ( T ^t ) \subseteq q ^t ( \text { coker  } ( T ) ^\vee ) $,设$\tilde { \mu  } \in \ker { T ^t  } $,也就是说$T ^t ( \tilde { \mu  } ) = \tilde { \mu  } T = 0 $,我们要找到一个$\lambda $使得$q ^t ( \lambda ) = \lambda q = \tilde { \mu  } $,那么必然见到$\lambda : \vec { w  } + \text { im  } ( T ) \mapsto \tilde { \mu  } ( \vec { w  } ) $是满足条件的,只需验证$\tilde { \mu  } | _{ \text { im  } ( T )  } = 0 $,这恰好由$T ^t ( \tilde { \mu  } ) = \tilde { \mu  } T = 0 $给出.</p>
<p>至于右半部分,就是我们上面所刻画的$\tilde { \mu  } $和$\mu $的关系了,换言之$\mu i = 0 \Leftrightarrow \exists \tilde { \mu  } , \mu = \tilde { \mu  } T $.</p>
<p>上述过程当然太过复杂了,尝试感性理解一下我们刚刚在做什么.我们的$\ker T $的意义是,$T : V \to W $这个过程中所损失的信息对吧,那我们反观$T ^t : W ^\vee \to V ^\vee , \lambda \mapsto \lambda T $这个过程中所损失的,也就是何时,$\lambda T = 0 $.由于这是两个映射,当然就等价于$\forall \vec { v  } \in V $,$\lambda T \vec { v  } = 0 $.当然就等价于$\forall \vec { u  } \in \text { im  } ( T ) $,$\lambda \vec { u  } = 0 $,这必然等价于$\ker \lambda \supseteq \text { im  } ( T ) $.所以这些$\lambda $都可以表示为一个$\tilde { \lambda  } q $的形式,其中$\ker q = \text { im  } ( T ) $,取余核是刚刚好的.</p>
<h5><span id="像自对偶">像自对偶</span></h5><p>对于映射$T : V \to W $,我们下面将给出典范同构:</p>
<script type="math/tex; mode=display">
\text { im  } ( T ) ^\vee \cong \text { im  } ( T ^t )</script><p>如上,商映射$q : W \to \text { coker  } ( T ) $满足$\ker q = \text { im  } ( T ) $,于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text { im  } ( T ) ^\vee \cong \text { coker  } ( q ^t : \text { coker  } ( T ) ^\vee \to W ^\vee ) \\
\cong \text { coker  } ( \ker T ^t \hookrightarrow W ^\vee ) \\
& = W ^\vee / \ker ( T ^t ) \\
\cong \text { im  } ( T ^t ) 
\end{aligned}</script><p>两边取$\dim $,得知行秩等于列秩.</p>
<h3><span id="实内积空间">实内积空间</span></h3><p>考虑正定对称双线性形式$( _ \mid _ ) : V \times V \to F $,这样的资料$( V , ( _ \mid _ ) ) $称为<strong>内积空间(IPS)</strong>.为了要一些$\mathbb { R  } $上的完备性质,我们下面主要讨论$F = \mathbb { R  } $的特殊情况.回忆道此时它应当满足的条件:</p>
<ol>
<li><p>双线性:各位有分配律以及标量乘法.</p>
</li>
<li><p>对称性:$( \vec { v  } \mid \vec { w  } ) = ( \vec { w  } \mid \vec { v  } ) $.</p>
</li>
<li><p>正定性:$( \vec { v  } \mid \vec { v  } ) \geq 0 $,并且等号成立当且仅当$\vec { v  } = \vec { 0  } $.</p>
</li>
</ol>
<p>回忆道二次型理论的时候我们曾经说过正定性是强于非退化的,因此内积一定是非退化的.</p>
<p>接下来定义$\vec { v  } \in V $的<strong>长度</strong>为$\Vert \vec { v  } \Vert = \sqrt { ( \vec { v  } \mid \vec { v  } )  } $,并且如果$( \vec { v  } \mid \vec { w  } ) = 0 $,则称它们<strong>正交</strong>,也写作$\vec { v  } \bot \vec { w  } $.同理可以定义正交空间$V _0 ^\bot $.还将满足$\Vert \vec { v  } \Vert = 1 $的$\vec { v  } $称为<strong>单位向量</strong>.</p>
<h4><span id="勾股定理">勾股定理</span></h4><p>事实上可以写出所谓的<strong>配极化</strong>:$( \vec { v  } _1 \mid \vec { v  } _2 ) = \frac { 1  } { 2  } ( \Vert \vec { v  } _1 + \vec { v  } _2 \Vert ^2 - \Vert \vec { v  } _1 \Vert ^2 - \Vert \vec { v  } _2 \Vert ^2 ) $.</p>
<p>这里可以看出内积上的勾股定理:也就是当$\vec { v  } \bot \vec { w  } $时$\Vert \vec { v  } + \vec { w  } \Vert ^2 = \Vert \vec { v  } \Vert ^2 + \Vert \vec { w  } \Vert ^2 $.</p>
<h4><span id="柯西不等式">柯西不等式</span></h4><p>即$( \vec { v  } \mid \vec { w  } ) ^2 \leq ( \vec { v  } \mid \vec { v  } ) ( \vec { w  } \mid \vec { w  } ) $,或言$( \vec { v  } \mid \vec { w  } ) \leq \Vert \vec { v  } \Vert \cdot \Vert \vec { w  } \Vert $.</p>
<p>等式成立当且仅当$\vec { v  } , \vec { w  } $线性相关,此时也是容易证明的,只需要讨论$\vec { v  } = t \vec { w  } $以及反过来的情况即可.</p>
<p>当$\vec { v  } , \vec { w  } $线性无关时,那么$\vec { v  } \ne 0 , \vec { w  } \ne 0 $,于是$\forall t , \vec { v  } + t \vec { w  } \ne 0 $.这会导致:</p>
<script type="math/tex; mode=display">
0 < ( \vec { v  } + t \vec { w  } \mid \vec { v  } + t \vec { w  } ) = t ^2 ( \vec { w  } \mid \vec { w  } ) + 2 t ( \vec { v  } \mid \vec { w  } ) + ( \vec { v  } \mid \vec { v  } )</script><p>将此看作关于$t $的二次多项式,那它就没有实根,于是观察判别式$\Delta = 4 ( \vec { v  } \mid \vec { w  } ) ^2 - 4 ( \vec { v  } \mid \vec { v  } ) ( \vec { w  } \mid \vec { w  } ) &lt; 0 $就见到柯西不等式成立.</p>
<p>用柯西不等式还可以定义两个向量之间的夹角,设其为$\angle ( \vec { v  } , \vec { w  } ) $,并定义$\cos \angle ( \vec { v  } , \vec { w  } ) = \frac { ( \vec { v  } \mid \vec { w  } )  } { \Vert \vec { v  } \Vert \cdot \Vert \vec { w  } \Vert  } $.</p>
<p>值得一提的是,柯西准则实际上保证了如果空间本身是连续的,那么内积就一定是连续的,原因是假设一列$( \vec { x  } _n , \vec { y  } _n ) \to ( \vec { x  } , \vec { y  } ) $,无论以何种方式逼近,一定有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
| ( \vec { x  } _n \mid \vec { y  } _n ) - ( \vec { x  } \mid \vec { y  } ) | \\
& \leq | ( \vec { x  } _n - \vec { x  } \mid \vec { y  } _n ) | + | ( \vec { x  } \mid \vec { y  } _n - \vec { y  } ) | \\
& \leq \Vert \vec { x  } - \vec { x  } _n \Vert \cdot \Vert \vec { y  } _n \Vert + \Vert \vec { x  } \Vert \cdot \Vert \vec { y  } _n - \vec { y  } \Vert 
\end{aligned}</script><p>这样就可以将其控制住.</p>
<h4><span id="三角不等式">三角不等式</span></h4><p>先用配极化,再用柯西不等式得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Vert \vec { v  } _1 + \vec { v  } _2 \Vert ^2 & = \Vert \vec { v  } _1 \Vert ^2 + \Vert \vec { v  } _2 \Vert ^2 + 2 ( \vec { v  } _1 \mid \vec { v  } _2 ) \\
& \leq \Vert \vec { v  } _1 \Vert ^2 + \Vert \vec { v  } _2 \Vert ^2 + 2 | ( \vec { v  } _1 \mid \vec { v  } _2 ) | \\
& \leq \Vert \vec { v  } _1 \Vert ^2 + \Vert \vec { v  } _2 \Vert ^2 + 2 \Vert \vec { v  } _1 \Vert \cdot \Vert \vec { v  } _2 \Vert \\
& = ( \Vert \vec { v  } _1 \Vert + \Vert \vec { v  } _2 \Vert ) ^2 \\

\end{aligned}</script><h4><span id="距离相关">距离相关</span></h4><p>如上可以定义<strong>距离函数</strong>$d : V \times V \to \mathbb { R  } _{ \geq 0  } , ( \vec { v  } , \vec { w  } ) \mapsto \Vert \vec { w  } - \vec { v  } \Vert $.容易见到其满足三角不等式$d ( \vec { u  } , \vec { v  } ) + d ( \vec { v  } , \vec { w  } ) \geq d ( \vec { u  } , \vec { w  } ) $.</p>
<h4><span id="正交向量族">正交向量族</span></h4><p>选取$V $中的一组两两正交的非零元素,称其为<strong>正交向量族</strong>或者<strong>正交子集</strong>.特别地如果所有向量都是单位向量,则称其为<strong>单位正交向量族</strong>或者<strong>单位正交子集</strong>.容易见到正交向量族应该是线性无关的,原因是反证,如果$\sum a _k \vec { v  } _k = 0 $,两边对$\vec { v  } _k $做内积就可以得到$a _k \Vert \vec { v  } _k \Vert ^2 = 0 $,根据正定性得到$a _k = 0 $.</p>
<p>既然如此,我们就将由一个单位正交子集所给出的基称为<strong>单位正交基(ONB)</strong>.</p>
<p>如果我们能拿出一组$n $个元素的单位正交基$\langle \vec { v  } _1 , \cdots \vec { v  } _n \rangle $,那么考虑用这组有序基将$V \to \mathbb { R  } ^n $.则注意到$\forall \vec { v  } \in V $,应当有:$\vec { v  } = \sum _k a _k \vec { v  } _k $.并且两边对$\vec { v  } _k $取内积就可以见到$a _k = ( \vec { v  } \mid \vec { v  } _k ) $.我们可以证明在这组基的同构下原本的内积就同构于$\mathbb { R  } ^n $上的标准内积(点乘).因此需要验证这个映射是否是保距的,事实上注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \sum _i a _i \vec { v  } _i \mid \sum _j b _j \vec { v  } _j ) \\
& = \sum _{ i , j  } a _i b _j ( \vec { v  } _i \mid \vec { v  } _j ) \\
& = \sum _i a _i b _i 
\end{aligned}</script><h4><span id="gram-schmidt-正交化">Gram-Schmidt 正交化</span></h4><p>问题现在在于单位正交基是否总是存在以及如何找到一个.我们先取一组向量$\vec { v  } _1 , \vec { v  } _2 , \cdots $线性无关(这里甚至允许可数无穷个向量),递归定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\vec { w  } _1 & = \vec { v  } _1 \\
\vec { w  } _k & = \vec { v  } _k - \sum _{ i = 1  } ^{ k - 1  } \frac { ( \vec { w  } _i \mid \vec { v  } _k )  } { ( \vec { w  } _i \mid \vec { w  } _i )  } \vec { w  } _i 
\end{aligned}</script><p>就可以取出一组正交基,之后只需令$\vec { u  } _k = \frac { \vec { w  } _k  } { \Vert \vec { w  } _k \Vert  } $就可以转化为一组单位正交基.事实上还可以注意到$\langle \vec { w  } _1 , \cdots \vec { w  } _k \rangle = \langle \vec { v  } _1 , \cdots , \vec { v  } _k \rangle $.其构造思路是每次添加一个拥有两项的元素,一项要是前面的空间内的部分,另一部分不是,然而它们之和要与前面空间正交.</p>
<p>证明的话,注意到:$\vec { w  } _k \in \vec { v  } _k + \langle \vec { w  } _1 , \cdots , \vec { w  } _{ k - 1  } \rangle $,因此数学归纳证明$\langle \vec { w  } _1 , \cdots \vec { w  } _k \rangle = \langle \vec { v  } _1 , \cdots , \vec { v  } _k \rangle $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\langle \vec { w  } _1 , \cdots , \vec { w  } _k \rangle \\
& = \langle \vec { w  } _1 , \cdots , \vec { w  } _{ k - 1  } \rangle + \langle \vec { w  } _k \rangle \\
& = \langle \vec { v  } _1 , \cdots , \vec { v  } _{ k - 1  } \rangle + \langle \vec { v  } _k \rangle \\
& = \langle \vec { v  } _1 , \cdots , \vec { v  } _k \rangle 
\end{aligned}</script><p>此外上述的算法的优点在于如果$\vec { v  } _k $已经和前面的$\vec { w  } _1 , \cdots , \vec { w  } _{ k - 1  } $正交,自然有$\vec { w  } _k = \vec { v  } _k $.</p>
<p>而验证正交无非是两边同时对$\vec { w  } _j $做内积并继续归纳即可.</p>
<p>由上给出两个推论:</p>
<ol>
<li><p>任何有限维内积空间都有单位正交基.</p>
</li>
<li><p>任何单位正交子集都可以扩充为一个单位正交基.</p>
</li>
</ol>
<p>(1)找到一组基用上述算法即可,(2)的话可以先扩充成基,再按照上述算法,而前面原本已经正交的部分不会改变.</p>
<h6><span id="example1ru分解">Example1(RU分解)</span></h6><p>观察上述Gram-Schmidt正交化过程就可以看到,对于一个矩阵$A = ( \vec { v  } _1 , \cdots , \vec { v  } _n ) $,对其作正交化,每次相当于右乘(列变换)一个上三角矩阵(没有交换列的操作),最终变换的形态则会是一个正交矩阵.因此,任何一个可逆矩阵都可以被分解成$RU $,其中$R $是一个正交矩阵,$U $是一个上三角矩阵.</p>
<h6><span id="example2legendre多项式">Example2(Legendre多项式)</span></h6><p>考虑$\mathbb { R  } $上的多项式组成的$\mathbb { R  } - $向量空间$\mathbb { R  } [ x ] $,定义内积$( f \mid g ) = \int _{ - 1  } ^1 f ( x ) g ( x ) \text { d  } x $,容易见到其满足定义.此外,$\mathbb { R  } [ x ] $的一组自然的基是$\langle 1 , x , x ^2 \cdots \rangle $.</p>
<p>是否可以对其进行正交化呢?考虑限制得到的单位正交基的最高次系数均为$1 $,容易见到这组单位正交基如此便被唯一刻画,并且必然是上述做Gram-Schmidt正交化的产物.</p>
<p>既然如此,我们接下来尝试检验$P _0 = 1 , P _n = \frac { 1  } { 2 ^n n !  } ( ( x ^2 - 1 ) ^n ) ^{ ( n )  } $就是一组正交基.我们声称以下命题成立:</p>
<ol>
<li><p>$[ x ^n ] P _n = \frac { ( 2 n ) !  } { 2 ^n ( n ! ) ^2  } $.</p>
</li>
<li><p>$P _n ( 1 ) = 1 $.</p>
</li>
<li><p>当$0 \leq k &lt; n $时,$\int _{ - 1  } ^1 t ^k P _n ( t ) \mathrm { d  } t = 0 $.作为此的一个推论,$n \ne m $的时候$\int _{ - 1  } ^1 P _m ( t ) P _n ( t ) \mathrm { d  } t = 0 $.</p>
</li>
<li><p>$P _n ( - t ) = ( - 1 ) ^n P _n ( t ) $.</p>
</li>
<li><p>$\int _{ - 1  } ^1 P _n ( t ) ^2 \mathrm { d  } t = \frac { 2  } { 2 n + 1  } $.</p>
</li>
<li><p>递归式:$( n + 1 ) P _{ n + 1  } = ( 2 n + 1 ) x ( P _n ) - nP _{ n - 1  } $.</p>
</li>
</ol>
<p>对于(1),讨巧的策略是直接看$\lim _{ x \to \infty  } \frac { P _n  } { x ^n  } $,而于此使用洛必达法则上下求导$n $次,立刻证毕.</p>
<p>对于(2),考虑$( x ^2 - 1 ) = ( x - 1 ) ( x + 1 ) $,用Leibniz律求导,得到$P _n ( 1 ) = \frac { 1  } { 2 ^n n !  } n ! ( 1 + 1 ) ^n = 1 $.</p>
<p>对于(3),只需分部积分,每次将$P _n ( t ) $给扔到$\rm d $里,这样前面的$t ^k $就会被不断消耗,最终得到结果.</p>
<p>对于(4),考虑在求导前的部分当然都是一样的,因此只是求导的时候,$P _n ( t ) $是$\frac { 1  } { ( \mathrm { d  } t ) ^n  } $,而$P _n ( - t ) = \frac { 1  } { ( ( \mathrm { d  } ) ( - t ) ) ^n  } $.</p>
<p>对于(5),把$P _n ( t ) ^2 = P _n ( t ) \times P _n ( t ) $,然后使用分部积分,得到的结果当然就是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( - 1 ) ^n \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \int _{ - 1  } ^1 ( t ^2 - 1 ) ^n \mathrm { d  } t \\
& = 2 ( - 1 ) ^n \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \int _{ 0  } ^1 ( t ^2 - 1 ) ^n \mathrm { d  } t \\
& = 2 \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \int _{ 0  } ^1 ( 1 - t ^2 ) ^n \mathrm { d  } t \\

\end{aligned}</script><p>做换元$\cos \theta = t $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \int _{ 0  } ^1 ( 1 - t ^2 ) ^n \mathrm { d  } t \\
& = 2 \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \int _{ 0  } ^{ \frac { \pi  } { 2  }  } \sin ( t ) ^{ 2 n + 1  } \mathrm { d  } t \\
& = 2 \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \frac { ( 2 n ) ! !  } { ( 2 n + 1 ) ! !  } \\
& = 2 \frac { ( 2 n ) !  } { ( 2 ^n n ! ) ^2  } \frac { ( 2 ^n n ! ) ^2  } { ( 2 n + 1 ) !  } \\
& = \frac { 2  } { 2 n + 1  } 
\end{aligned}</script><p>于是证毕.</p>
<p>对于(6),考虑既然上述Legendre多项式是一组基,那么$xP _n $作为一个$n + 1 $次多项式,理应可以被表示出来.也就是有:</p>
<script type="math/tex; mode=display">
xP _n = \sum _{ k = 0  } ^{ n + 1  } a _k P _{ k  }</script><p>两边对$P _{ k  } , k \leq n - 2 $做内积,那么左侧就是$\int _{ - 1  } ^1 ( xP _k ( x ) ) P _n ( x ) \mathrm { d  } x $,此时考虑$xP _k ( x ) $是一个$k + 1 &lt; n $次多项式,所以左侧理应为$0 $,于是右侧的$a _k = 0 $.上式被我们简化为:</p>
<script type="math/tex; mode=display">
xP _n = a _n P _{ n + 1  } + b _n P _{ n  } + c _n P _{ n - 1  }</script><p>考虑两边提取$[ x ^{ n + 1  } ] $,立刻知道$a _n = \frac { n + 1  } { 2 n + 1  } $.</p>
<p>两边对$P _n $做内积,注意到$x ( P _n ) ^2 $是一个奇函数,所以左边为$0 $,所以$b _n = 0 $.</p>
<p>接下来是$c _n $.考虑$( xP _n \mid P _{ n - 1  } ) = ( P _n \mid xP _{ n - 1  } ) $,而由刚才的$a _n $,$xP _{ n - 1  } = \frac { n  } { 2 n - 1  } P _n + P ‘ $,因此立刻见到$c _n = \frac { n  } { 2 n + 1  } $,这就得证了.</p>
<h4><span id="正交算子">正交算子</span></h4><p>如果拿出两个内积空间,并能找到一个映射$\varphi : V \to W $使得保$\Vert \varphi ( \vec { v  } ) \Vert _W = \Vert \vec { v  } \Vert _V $,那么称其为<strong>保距同构</strong>.用配极化容易见到保距同构一定保持了内积.容易见到如果$\varphi $是同构,那么$\varphi ^{ - 1  } $当然也是同构的.</p>
<p>考虑取两个有限维内积空间$V , W $.由于内积非退化并且对称,于是应当对于所有线性映射$T : V \to W $都有伴随$T ^<em> : W \to V $使得$( T \vec { v  } \mid \vec { w  } ) _W = ( \vec { v  } \mid T ^</em> \vec { w  } ) _V $并且$( T ^* \vec { w  } \mid \vec { v  } ) _V = ( \vec { w  } \mid T \vec { v  } ) _W $.</p>
<p>接下来我们尝试证明:$T $是保距同构当且仅当$T ^* = T ^{ - 1  } $.</p>
<p>先证必要性:当$T $是保距同构的时候,见到$T ^{ - 1  } $必然也是同构,这就意味着$( T \vec { v  } \mid \vec { w  } ) _W = ( T ^{ - 1  } T \vec { v  } \mid T ^{ - 1  } \vec { w  } ) _V = ( \vec { v  } \mid T ^{ - 1  } \vec { w  } ) _V $对于$\forall \vec { v  } , \vec { w  } $都成立,这当然意味着$T ^* = T ^{ - 1  } $.</p>
<p>再证充分性,当$T ^<em> = T ^{ - 1  } $时,考虑$( T \vec { v  } _1 \mid T \vec { v  } _2 ) _W = ( \vec { v  } _1 \mid T ^</em> T \vec { v  } _2 ) _V = ( \vec { v  } _1 \mid \vec { v  } _2 ) _V , \forall \vec { v  } _1 , \vec { v  } _2 $,这就意味着其是保距同构.</p>
<p>另外还可以证明如果$\vec { v  } _1 , \cdots , \vec { v  } _n $是$V $的单位正交基时,$T $是保距同构当且仅当$T \vec { v  } _1 , \cdots , T \vec { v  } _n $是$W $的单位正交基.</p>
<p>必要性源于保距同构保持了关于内积的一切性质,因此显然.接下来考虑充分性,如果$T \vec { v  } _1 , \cdots , T \vec { v  } _n $是$W $的单位正交基,那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Vert \sum _k a _k \vec { v  } _k \Vert _V ^2 & = \sum _k a _k ^2 \\
\Vert T ( \sum _k a _k \vec { v  } _k ) \Vert _W ^2 & = \Vert \sum _k a _k ( T \vec { v  } _k ) \Vert ^2 _W & = \sum _k a _k ^2 
\end{aligned}</script><p>这意味着其保距.并且$\dim V = n = \dim W $意味着是同构.</p>
<p>接下来定义有限维内积空间的自同构称为$V $上的<strong>正交变换</strong>.现在不妨假设$V = \mathbb { R  } ^n $并将视角转移到标准内积上(此时应当有$A ^<em> = A ^T $)尝试使用矩阵来描述该问题.容易见到以下命题等价,并将满足下列性质的矩阵称为<em>*实正交矩阵</em></em>:</p>
<ol>
<li><p>$A ^{ - 1  } = A ^T $.</p>
</li>
<li><p>$A $相对于标准内积是正交变换.</p>
</li>
</ol>
<p>由此得到以下推论:</p>
<ol>
<li><p>单位矩阵是正交矩阵.</p>
</li>
<li><p>如果$A $和$B $都是正交矩阵,那么$AB $亦然.</p>
</li>
<li><p>如果$A $是正交矩阵,则$A ^T , A ^{ - 1  } $均亦然.</p>
</li>
<li><p>正交矩阵的行列式为$\pm 1 $.</p>
</li>
<li><p>对于矩阵$A = ( \vec { v  } _1 , \cdots , \vec { v  } _n ) $,$A $是正交矩阵当且仅当$\vec { v  } _1 , \cdots , \vec { v  } _n $是一组单位正交基.</p>
</li>
<li><p>正交矩阵的特征值(无论实复)必然满足$| \lambda | = 1 $.</p>
</li>
</ol>
<p>(1)(2)(3)显然,(4)则是因为$( \det A ) ^2 = \det ( A ^T ) \det A = 1 $.</p>
<p>(5)的话原因是$\mathbb { R  } $下$\vec { e  } _1 , \cdots \vec { e  } _n $是一组标准正交基,而$\vec { v  } _k = A \vec { e  } _k $,因此根据前面提到的正交矩阵对标准正交基的转译性质即证毕.</p>
<p>(6)的话,考虑标准内积空间$( A \vec { v  } \mid A \vec { v  } ) $,其中$\vec { v  } $是以$\lambda $为特征值的特征向量,那么首先,$( A \vec { v  } \mid A \vec { v  } ) = | \lambda | ^2 ( \vec { v  } \mid \vec { v  } ) $,另一方面,其又是$( ( A \vec { v  } ) ^t ) ( A \vec { v  } ) = ( \vec { v  } \mid \vec { v  } ) $.这就完事了.</p>
<h4><span id="正交补空间">正交补空间</span></h4><p>取$S $为$V $的任意子集,则称$S ^\bot = \{ \vec { v  } \in V \mid \forall \vec { s  } \in S , ( \vec { s  } \mid \vec { v  } ) = 0 \} $为$S $的<strong>正交补空间</strong>.</p>
<p>虽然在此定义下$S $无需是子空间,但仍见到$S ^\bot $自动对加法和纯量乘法封闭,因此$S ^\bot $仍是一个子空间.然而其实这里$S ^\bot = ( \langle S \rangle ) ^\bot $,这当然是显然的,因此后面只关注$S = V _0 $是$V $的子空间的情况.</p>
<p>虽然之前我们做双线性形式的时候正交空间并没有太好的性质,但此时对于内积的情况有,我们声称$V = V _0 \oplus V _0 ^\bot $.原因是任取一组$V _0 $的单位正交基$\vec { v  } _1 , \cdots , \vec { v  } _m $,注意到$\vec { v  } = \sum _{ k  } ( \vec { v  } _k \mid \vec { v  } ) \vec { v  } _k + ( \vec { v  } - \sum _{ k  } ( \vec { v  } _k \mid \vec { v  } ) \vec { v  } _k ) $,前者显然属于$V _0 $,而后者只需逐个对$\vec { v  } _k $做内积就可以验证其属于$V _0 ^\bot $.不妨将前者称为$\vec { v  } $在$V _0 $上的正交投影.并将$P : V \to V _0 , \vec { v  } \mapsto \vec { v  } _0 $称作正交投影算子,其中$\vec { v  } = \vec { v  } _0 + \vec { v  } _1 $,$\vec { v  } _0 \in V _0 , \vec { v  } _1 \in V _0 ^\bot $.另外,观察到伴随映射有$( \text { im  }  T ) ^\bot = \ker T ^<em> $,见到$V = \ker T ^</em> + \text { im  }  T $.</p>
<p>取$V _0 \subseteq V $,并且取$V = V _0 \oplus V _0 ^\bot $,考虑$P $映射是从$V $到$V _0 $的投影,那么$\forall \vec { v  } $,$\min _{ \vec { u  } \in V _0  } \Vert \vec { u  } - \vec { v  } \Vert $在$\vec { u  } = P \vec { v  } $的时候取最小.原因是不妨设$\vec { v  } = \vec { v  } _0 + \vec { v  } _1 $,使用勾股定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Vert \vec { u  } - \vec { v  } \Vert ^2 \\
& = \Vert \vec { u  } - \vec { v  } _0 - \vec { v  } _1 \Vert ^2 \\
& = \Vert \vec { u  } - \vec { v  } _0 \Vert ^2 + \Vert \vec { v  } _1 \Vert ^2 \\
& \geq \Vert \vec { v  } _1 \Vert ^2 
\end{aligned}</script><p>此时仔细观察投影算子$P : V \to V _0 $,应当可以将$P $视作$\text { End  } ( V ) $中的某元素,我们下面证明$P $是正交投影算子当且仅当$P ^* = P $和$P ^2 = P $同时成立.</p>
<p>先证明必要性:仍选择将$\vec { v  } = \vec { v  } _0 + \vec { v  } _1 $,其中$\vec { v  } _0 \in V _0 $而$\vec { v  } _1 \in V _0 ^\bot $,此时$P \vec { v  } = \vec { v  } _0 $,而$P ^2 \vec { v  } = \vec { v  } _0 = P \vec { v  } $,因此$P ^2 = P $总是成立.另外如果有$\vec { v  } ‘ = \vec { v  } _0 ‘ + \vec { v  } _1 ‘ $,那么应当注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( P \vec { v  } \mid \vec { v  } ' ) \\
& = ( \vec { v  } _0 \mid \vec { v  } ' ) & = ( \vec { v  } _0 \mid \vec { v  } _0 ' ) & = ( \vec { v  } \mid \vec { v  } _0 ' ) \\
& = ( \vec { v  } \mid P \vec { v  } ' ) 
\end{aligned}</script><p>然后证明充分性,直接取$V _0 = \text { im  } ( P ) $,那么$\forall \vec { v  } \in V $当然$\exists \vec { u  } $有$\vec { v  } = P \vec { u  } + \vec { v  } _1 $.此时注意到$P \vec { v  } = P \vec { u  } + P \vec { v  } _1 $.观察发现$( P \vec { v  } _1 \mid P \vec { v  } _1 ) = ( P ^* P \vec { v  } _1 \mid \vec { v  } _1 ) = ( P \vec { v  } _1 \mid \vec { v  } _1 ) $,然而$\vec { v  } _1 \in V _0 ^\bot $而$P \vec { v  } _1 \in V _0 $,于是$( P \vec { v  } _1 \mid P \vec { v  } _1 ) = 0 $,于是$P \vec { v  } _1 = 0 $.因此$P \vec { v  } = P \vec { u  } $.</p>
<p>接下来定义一个正交投影算子的<strong>镜像</strong>为$2 P - \text { id  } _V $,其将$\vec { v  } _0 + \vec { v  } _1 $映射到$\vec { v  } _0 - \vec { v  } _1 $上.我们想要证明如果$P $是正交投影算子,那么$2 P - \text { id  } _V $是正交变换.容易检验$( 2 P - \text { id  } _V ) ^* = ( 2 P - \text { id  } _V ) $,那就只需要验证:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( 2 P - \text { id  } _V ) ^* ( 2 P - \text { id  } _V ) \\
& = ( 2 P - \text { id  } _V ) ( 2 P - \text { id  } _V ) \\
& = 4 P ^2 - 4 P + \text { id  } _V \\
& = \text { id  } _V 
\end{aligned}</script><p>还可以证明:如果$V _0 $是$T $不变子空间,那么$( V _0 ) ^\bot $是$T ^<em> $的不变子空间,证明的话只需考虑$( T ^</em> \vec { w  } \mid \vec { v  } ) = ( \vec { w  } \mid T \vec { v  } ) = 0 $,其中$\vec { v  } \in V _0 $而$\vec { w  } \in ( V _0 ) ^\bot $.这将为我们把空间分解为$V _0 \oplus ( V _0 ) ^\bot $提供帮助.更详细的讨论将在自伴算子处讨论.</p>
<h4><span id="投影矩阵">投影矩阵</span></h4><p>考虑向量空间$V $和$A _1 , \cdots , A _s \in \text { End  } ( V ) $,满足$A _1 + \cdots + A _s = \text { id  } $,并且$\forall i \ne j , A _i A _j = 0 $,而且$A _i ^2 = A _i $.</p>
<p>此时令$V _i = \text { im  } ( A _i ) $.我们下面证明以下三条事实:</p>
<ol>
<li><p>$A _i ( \sum \vec { v  } _k ) = \vec { v  } _i $,其中$\vec { v  } _k \in V _k $.</p>
</li>
<li><p>$V = \bigoplus V _k $.</p>
</li>
<li><p>若$A ^2 = A $,则$V = \text { im  } ( A ) \oplus \text { im  } ( \text { id  } - A ) = \text { im  } A \oplus \ker A $.</p>
</li>
</ol>
<p>(1)显然.</p>
<p>考虑(2)的证明,由于$V = \text { im  } ( \text { id  } ) \subseteq \sum V _k \subseteq V $,于是$\sum V _k = V $.只需再证明$\forall k , V _k \cap ( \sum _{ j \ne k  } V _j ) = \{ \vec { 0  } \} $即可.而$\forall \vec { w  } \in V _k $,考虑$A _k ( \vec { w  } ) = \vec { w  } $但$A _k ( \sum _{ j \ne k  } V _j ) = 0 $,这意味着$\vec { w  } \notin ( \sum _{ j \ne k  } V _j ) $,这就证毕了.</p>
<p>考虑(3)的证明,只需检验$A ( \text { id  } - A ) = 0 $,这是显然的.</p>
<p>而在特征为$0 $的域上,我们尝试证明更强一点的结论:当$\sum A _k = \text { id  } $的时候,以下三条命题等价:</p>
<ol>
<li><p>对于每个$i $都有$A _i ^2 = A _i $.</p>
</li>
<li><p>$\sum \text { rk  } ( A _i ) = \dim V $.</p>
</li>
<li><p>$\forall i \ne j $,$A _i A _j = 0 = A _j A _i $.</p>
</li>
</ol>
<p>(1)$\Rightarrow $(2)的话考虑对于单个$A _i $,我们上面已经证明过当$A _i ^2 = A _i $的时候应当有直和分解$V = \text { im  } ( A _i ) \oplus \text { im  } ( \text { id  } - A _i ) $,此时任取一组基限制在$\text { im  } ( A _i ) $上都是恒等变换,于是$\text { tr  } ( A _i ) = \text { rk  } ( A _i ) $.这个证明可能略有口胡,或者你直接观察$A _i $的极小多项式为$x ( x - 1 ) = 0 $,立刻得到其可对角化并且对角上只有$1 $和$0 $,并且只划分了两个子空间$V _0 $和$V _1 $,再用迹对于相似不变就可以得到$\text { tr  } ( A _i ) = \text { rk  } ( A _i ) $.于是$\sum \text { rk  } ( A _i ) = \sum \text { tr  } ( A _i ) = \text { tr  } ( \text { id  } ) = \dim V $.</p>
<p>(2)$\Rightarrow $(3)的话,考虑同上用$V = \text { im  } ( \text { id  } ) \subseteq \sum V _k \subseteq V $,所以$\sum V _k = V $.这就可以看到同态$\sigma : \bigoplus V _k \to V , ( \vec { v  } _i ) \mapsto \sum \vec { v  } _i $是满的,比较维数就知道$\dim \ker = 0 $,所以这是同构.这意味着$\forall k , j , \text { im  } ( A _k ) \cap \text { im  } ( A _j ) = \{ \vec { 0  } \} $.而我们知道$\text { im  } ( A _k ) \oplus \ker A _k \cong V $,在这里的直和应该直接表现为$\text { im  } ( A _k ) + \ker A _k = V $,这样就直接把$A _j $扔进了$\ker A _k $里面.</p>
<p>(3)$\Rightarrow $(1)是简单的,原因是$A _k = A _k ( \sum _{ j \ne k  } A _j ) + A _k \times A _k $.</p>
<p>如果我们将满足$A ^2 = A $的矩阵称为投影矩阵的话,可以发现一个矩阵是投影矩阵的必要条件是$\ker A + \text { im  }  A = V $.然而并不充分,除非再加上$A ( I - A ) = 0 $.</p>
<h4><span id="自伴算子">自伴算子</span></h4><p>对于一个内积空间$( V , ( _ , _ )  ) $,其中$\dim V = n $.</p>
<p>称一个映射是<strong>自伴的</strong>,当且仅当$T = T ^<em> $.我们下面尝试证明如果$T $是自伴的,那么$T $可以正交对角化.换言之存在正交映射$P $使得$P ^{ - 1  } TP = P ^</em> TP $是对角的.另外,如果$T $可以正交对角化,那么也仅当$T = T ^* $.原因当然显然,因为只需两边取伴随即可见得.</p>
<p>对$n = \dim V $进行归纳,下面不妨假设$n \geq 2 $.</p>
<p>回忆到这个内积空间应该可以同构于标准内积空间$( \mathbb { R  } ^n , \cdot ) $,因此将自伴算子同构于$A ^T = A ^* = A $的矩阵.假设可以找到$T $的某一个实特征值$\lambda _1 $,我们就可以取其对应的特征向量$\vec { v  } _1 \ne 0 $并且满足$T \vec { v  } _1 = \lambda _1 \vec { v  } _1 $,而且满足$\Vert \vec { v  } _1 \Vert = 1 $,并设$V _0 = \text { span  } ( \vec { v  } _1 ) $,回忆到我们有正交直和分解$V = V _0 \oplus ( V _0 ^\bot ) $.</p>
<p>此时观察,既然$V _0 $是$T $不变子空间,我们之前证明了$V _0 ^\bot $是$T ^* = T $的不变子空间,既然如此,$T $限制在$V _0 ^\bot $上就仍然自伴,这样就可以进行数学归纳.</p>
<p>那么怎么找到$T $的一个实特征值呢?为了证明这个定理,我们可能需要先跳出实数域而在复数域上做一些操作.在复数域上的好处在于可以定义共轭,具体地容易发现$\overline { A + B  } = \bar { A  } + \bar { B  } $以及$\overline { A \times B  } = \bar { A  } \times \bar { B  } $.</p>
<p>对于复数域上的矩阵,我们约定$A ^\dagger = \bar { A ^T  } $,注意到$\lambda ^\dagger = \bar { \lambda  } $,并且理应有$( AB ) ^\dagger = B ^\dagger A ^\dagger $.此时取$\vec { v  } = ( z _1 , \cdots , z _n ) \in \mathbb { C  } ^n $,注意到$( \vec { v  } ) ^\dagger ( \vec { v  } ) = \sum | z _k | ^2 \in \mathbb { R  } _{ \geq 0  } $,并且其等于$0 $当且仅当$\vec { v  } = 0 $.</p>
<p>下面我们证明:当$A ^\dagger = cA , c \in \mathbb { C  } $,那么$A $的所有特征值都满足$\bar { \lambda  } = c \lambda $.不过容易见到这里只能取$c = \pm 1 $,原因是$c ^2 = 1 $.这个性质我们会在后面复内积空间中的hermite形式中进一步用到.</p>
<p>证明的话,考虑$\vec { v  } \ne 0 $是以$\lambda \in \mathbb { C  } $为特征值的特征向量,那么我们考虑$( \vec { v  } ) ^\dagger ( A \vec { v  } ) = ( \vec { v  } ) ^\dagger ( \lambda ) \vec { v  } $.此时两边取$\dagger $,左边给出$( \vec { v  } ) ^\dagger A ^\dagger \vec { v  } = c ( \vec { v  } ) ^\dagger A \vec { v  } = c \lambda ( \vec { v  } ) ^\dagger \vec { v  } $,而右边给出$\bar { \lambda  } ( \vec { v  } ) ^\dagger ( \vec { v  } ) $,这样就证明了上述结论.</p>
<p>那么这样做的意义是什么呢?已经知道实数上的自伴算子满足$A ^\dagger = A $,也就是在上面$c = 1 $,那意味着$\lambda = \bar { \lambda  } $,意味着$\lambda $是实数.然而,由于在$\mathbb { C  } $是代数闭的,那么就一定可以找到至少一个复特征值,由上知道这些特征值还都是实数,那我们就补上了上述证明的最后一步.</p>
<p>于是,回忆到直和与分块矩阵的关系,将我们拿到的这些特征向量做正交化后,取$P $为这些单位正交基$\vec { v  } _1 , \cdots , \vec { v  } _n $为列向量的矩阵,那么$P ^{ - 1  } AP = \begin{bmatrix}\lambda _1 &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; \lambda _n \end{bmatrix} $.</p>
<p>或者直接来看,我们断言自伴算子对应的特征子空间一定互相正交,原因是设它们分别是$V _{ \lambda _1  } , V _{ \lambda _2  } $,那么$\lambda _1 ( \vec { v  } _1 \mid \vec { v  } _2 ) = ( T \vec { v  } _1 \mid \vec { v  } _2 ) = ( \vec { v  } _1 \mid T \vec { v  } _2 ) = \lambda _2 ( \vec { v  } _1 \mid \vec { v  } _2 ) $.这就必然给出$( \vec { v  } _1 \mid \vec { v  } _2 ) = 0 $.那只需先求特征向量,然后对此施加Gram-Schmidt正交化就赢了.</p>
<h5><span id="实sylvester-判准">(实)Sylvester 判准</span></h5><p>将一个矩阵的左上的$k \times k $的矩阵称为$A $的顺序主子式.</p>
<p>容易发现,实对称矩阵正定当且仅当其所有特征值皆正,原因是正交对角化后的结果.</p>
<p>由此可以得到Sylvester判准,也就是一个实对称矩阵正定当且仅当其所有顺序主子式皆正.</p>
<p>必要性显然,把线性空间限制在左上角的那个$k \times k $里,如果有某个顺序主子式是负的,那就存在负的特征值.</p>
<p>下面证明充分性:考虑数学归纳,当$n \geq 2 $的时候,假设$A $的每个顺序主子式都是正的,我们下面试图证明其所有特征值都是正的.记其特征值为$\lambda _1 , \cdots , \lambda _n $,必定有等式$\lambda _1 \cdots \lambda _n = \det A &gt; 0 $.也就是说,如果$A $有负特征值则必然成对出现,不妨设其为$\lambda _1 $和$\lambda _2 $(当然它们有可能相等,但总之应该取不同的特征向量),此时不妨取它们的特征向量并做单位正交化后得到$\vec { v  } _1 , \vec { v  } _2 $.此时$\forall \alpha , \beta \in \mathbb { R  } $,立刻有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \alpha \vec { v  } _1 + \beta \vec { v  } _2 ) ^t A ( \alpha \vec { v  } _1 + \beta \vec { v  } _2 ) \\
& = \alpha ^2 \lambda _1 + \beta ^2 \lambda _2 & \leq 0 
\end{aligned}</script><p>其中$\alpha , \beta $可以任取,当然存在不全为$0 $的一对$( \alpha , \beta ) $使得$\alpha \vec { v  } _1 + \beta \vec { v  } _2 $作为列向量的第$n $个坐标为$0 $,此时对于左上角的$( n - 1 ) \times ( n - 1 ) $的空间来说,由于进行了数学归纳,上面必然是正定的.这当然就矛盾了.</p>
<h5><span id="实正定矩阵的二次根">(实)正定矩阵的二次根</span></h5><p>设$T \in \text { End  } ( V ) $正定(或者半正定),那么就存在唯一的正定(或半正定)的$S \in \text { End  } ( V ) $使得$S ^2 = T $,这样我们记$S = \sqrt { T  } $.</p>
<p>(一定要记得正定蕴含着其对称啊,总是忘记这个定义)</p>
<p>存在性的话只需要对$T $做单位正交分解,然后把对角线上的特征值全部取根号就可以了.唯一性的话,由于$S $在每一个特征子空间上都应当表现为$\sqrt { \lambda _i  } \text { id  } $(原因是每一个特征子空间本身都是不变子空间,因此$S $的特征子空间也需要是$S ^2 = T $的特征子空间,于是反之亦然),那$S $当然是唯一确定的.</p>
<h6><span id="example1">Example1</span></h6><p>设$A , B , A - B $都是正定矩阵,求证$\sqrt { A  } - \sqrt { B  } $正定.</p>
<p>反证,假设$\sqrt { A  } - \sqrt { B  } $并非正定,那就一定存在一个特征值$\lambda \leq 0 $以及配套的特征向量$\vec { v  } \ne 0 $,使得$( \sqrt { A  } - \sqrt { B  } ) \vec { v  } = \lambda \vec { v  } $,也就是$\sqrt { B  } \vec { v  } = \sqrt { A  } \vec { v  } - \lambda \vec { v  } $.此时见到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \vec { v  } ) ^t B \vec { v  } \\
& = ( \sqrt { B  } \vec { v  } ) ^t ( \sqrt { B  } \vec { v  } ) \\
& = ( \sqrt { A  } \vec { v  } - \lambda \vec { v  } ) ^t ( \sqrt { A  } \vec { v  } - \lambda \vec { v  } ) \\
& = ( \vec { v  } ) ^t A \vec { v  } + \lambda ^2 \vec { v  } ^t \vec { v  } - 2 \lambda ( \vec { v  } ) ^t \sqrt { A  } \vec { v  } \\
& \geq ( \vec { v  } ) ^t A \vec { v  } 
\end{aligned}</script><p>这就与$A - B $正定是矛盾的了.</p>
<h6><span id="example2">Example2</span></h6><p>设$A , B , A - B $都是正定矩阵,求证$A ^{ - 1  } - B ^{ - 1  } $正定.</p>
<p>直接扩到复数域,这样一定存在一个$C $,使得$( C ^<em> ) BC = I $,此时由于合同是内积空间上的同构,所以$( C ^</em> ) ( A - B ) C = C ^* AC - I $仍然正定,这就将情况化约到$B = I $的情况.</p>
<p>此时只需对$A $做对角化即可见得了.</p>
<h5><span id="极分解">极分解</span></h5><p>对于内积空间,设$T \in \text { End  } ( V ) $可逆,那么就存在唯一一对$R , U \in \text { End  } ( V ) $使得$R $正定并且$U $是正交变换,$T = RU $.这其实类似于把一个复数拆成模长和辅角两个部分.</p>
<p>在此之前先证明一个引理:标准内积空间上$T ^* T $是半正定的,并且如果$T $单,那么其是正定的.</p>
<p>首先其自伴性质是已知的,半正定的原因是$^t ( \vec { v  } ) ( T ^* T ) ( \vec { v  } ) = ( T \vec { v  } \mid T \vec { v  } ) $,而后者继承了内积空间上的半正定性.并且从此可以看出$T $单的话,也就是$\ker T = { 0  } $就可以继承内积空间上的正定性.</p>
<p>注意到$TT ^<em> = RUU ^</em> R = R ^2 $,因此必定有$R = \sqrt { TT ^<em>  } $,因此$R $是唯一且存在的且正定的(原因是$T $是可逆的,因此$TT ^</em> $是正定的)而且$R $还自伴.另外,因为$R $可逆(正定性推出非退化性),因此$U = R ^{ - 1  } T $就确定.问题在于证明$U $是否是正交变换,只需要证明$U ^* = U ^{ - 1  } $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
U ^* U & = ( R ^{ - 1  } T ) ^* ( R ^{ - 1  } T ) \\
& = T ^* R ^{ - 2  } T & = \text { id  } 
\end{aligned}</script><p>这就得证.</p>
<h5><span id="最小二乘法">最小二乘法</span></h5><p>给定一个特定的$T \in \text { Hom  } ( V , W ) $,现在对于一个$\vec { w  } \in W $,想要求一个$\vec { v  } \in V $使得$\Vert T \vec { v  } - \vec { w  } \Vert $最小.这个解被称为<strong>最小二乘解</strong>.</p>
<p>取$W _0 = \text { im  } T $,那么就可以将$\vec { w  } = \vec { w  } _0 + \vec { w  } _1 $,其中$\vec { w  } _0 \in W _0 , \vec { w  } _1 \in ( W _0 ) ^\bot $.此时就可以见到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Vert T \vec { v  } - \vec { w  } \Vert ^2 & = \Vert ( T \vec { v  } - \vec { w  } _0 ) - \vec { w  } _1 \Vert ^2 \\
& = \Vert T \vec { v  } - \vec { w  } _0 \Vert ^2 + \Vert \vec { w  } _1 \Vert ^2 
\end{aligned}</script><p>只需让前面为$0 $就行,从这也可以看出来一般而言$\vec { v  } $不是唯一的.然而$\vec { v  } + \ker T $总是唯一的,我们试图在其中找到$\Vert \vec { v  } \Vert $最小的一个作为代表.而$\vec { v  } $仍可以分解为$\ker T $和$( \ker T ) ^\bot $两部分,这就能见到$\Vert \vec { v  } \Vert $最小时$\vec { v  } \in ( \ker T ) ^\bot $.不妨将这个$\vec { v  } $定义为$S ( \vec { w  } ) = \vec { v  } $,应该见到$S $是一个线性映射.</p>
<p>我们还可以证明,其最小二乘解正好是$T ^<em> T \vec { v  } = T ^</em> \vec { w  } $的解.原因是最小二乘解其实也就是$T \vec { v  } - \vec { w  } \in ( \text { im  } T ) ^\bot = \ker ( T ^* ) $.</p>
<p>而注意到$T ^* T $是自伴的,然而其还有更多的好性质:</p>
<ol>
<li><p>$\text { im  }  ( T ^<em> T ) = \text { im  }  ( T ^</em> ) $.</p>
</li>
<li><p>$\ker ( T ^* T ) = \ker T $.</p>
</li>
<li><p>$\text { rk  }  ( T ^<em> T ) = \text { rk  }  ( T ) = \text { rk  } ( T ^</em> ) $.</p>
</li>
</ol>
<p>考虑(1), 首先显然有$\text { im  }  ( T ^<em> T ) \subseteq \text { im  }  ( T ^</em> ) $.而反方向的话,对于$T ^<em> \vec { w  } \in \text { im  } ( T ^</em> ) $,只需取其最小二乘解$\vec { v  } \in V $就给出了$T ^<em> \vec { w  } = T ^</em> T \vec { v  } \in \text { im  } ( T ^* T ) $.</p>
<p>考虑(2),首先显然有$\ker  ( T ^<em> T ) \subseteq \ker  ( T ) $.而反方向的话,若$T ^</em> T \vec { v  } = 0 $,应该能看到$( T \vec { v  } \mid T \vec { v  } ) = ( T ^* T \vec { v  } \mid \vec { v  } ) = 0 $,这意味着$T \vec { v  } = 0 $.</p>
<p>(3)是(1)(2)的推论.顺便一提,这里推出的$\text { rk  } ( T ) = \text { rk  } ( T ^* ) $是行秩等于列秩的另一个证明.</p>
<h4><span id="奇异值分解">奇异值分解</span></h4><p>取$V , W $为有限维实内积空间并采取标准内积,不妨设$m = \dim V , n = \dim W $,注意这里的字母使用与习惯略有差别.并取$T : V \to W $为线性映射.接下来我们证明,存在$V , W $的两组单位正交基,不妨记作$\mathcal { B  } _V = \{ \vec { v  } _1 , \cdots , \vec { v  } _m \} $和$\mathcal { B  } _W = \{ \vec { w  } _1 , \cdots , \vec { w  } _n \} $.记$p = \text { rk  } T $,以及存在一列非负实数$\sigma _1 \geq \cdots \geq \sigma _p $,使得$T \vec { v  } _i = \begin{cases}\sigma _i \vec { w  } _i &amp; 1 \leq i \leq p \ 0 &amp; i &gt; p \end{cases} $.我们称这列非负实数为$T $的<strong>奇异值</strong>,并将在下面证明其由$T $唯一确定.应当说明的是,下述中虽然有的时候会默认后面有一列$0 $来避开讨论,但$\sigma _p \ne 0 $.一般,我们也用非零奇异值的数量来判断$T $的秩.可以认为,奇异值是特征值的某种推广.</p>
<p>考虑矩阵,此时的$T $应当是一个$n \times m $的矩阵.考虑$V $的单位正交基组成的矩阵$P \in M _{ m \times m  } $,以及$W $的单位正交基矩阵$Q \in M _{ n \times n  } $.</p>
<p>此时不妨考虑$T $在标准基下表示为$A $,那考虑$Q ^{ - 1  } AP $实际上就是在两个单位正交基内转化的过程.不妨令$\Sigma = Q ^{ - 1  } AP $,只需证明其在前$p $个主对角线位置分别为$\sigma _1 , \cdots , \sigma _p $即可.</p>
<p>留意到$( \vec { v  } _i \mid T ^<em> \vec { w  } _j ) = ( T \vec { v  } _i \mid \vec { w  } _j ) = \sigma _i ( \vec { w  } _i \mid \vec { w  } _j ) = \sigma _i \delta _{ i , j  } $,其中$\delta _{ i , j  } = [ i = j ] $.回忆到$T ^</em> $是唯一的,并注意到如果干脆定义$T ^<em> $满足$T ^</em> \vec { w  } _j = \sigma _j \vec { v  } _j $上式依旧成立,因此$T ^<em> $的确有此性质.进一步得到推论$T ^</em> T \vec { v  } _i = \sigma _i ^2 \vec { v  } _i $.所以$T ^<em> T $的特征值恰为$\sigma _1 ^2 \geq \cdots $.这样的话其唯一性立刻见到了.不过由于是在$\mathbb { R  } $上,因此我们还要说明其存在性.考虑对$T ^</em> T $做正交对角化.此时回忆到$\text { rk  } ( T ^<em> T ) = \text { rk  } ( T ) = p $,又因为$T ^</em> T $可对角化,$\text { rk  } $对应了非零特征值的数量.直接取$\sigma _i = \sqrt { \lambda _i  } $,其中$\lambda _i $是$T ^* T $的特征值,当然都是可行的.</p>
<p>接下来要反推出$V , W $的两组单位正交基.任取一组$V $的特征向量组成的基并从其构造$W $的基,也就是取$\vec { w  } _i = \frac { T \vec { v  } _i  } { \sigma _i  } $(假设$m \geq n $的情况下,不然的话反之)并证明这也是一组单位正交基.</p>
<p>此时观察到$( \vec { w  } _i \mid \vec { w  } _j ) = \frac { 1  } { \sigma _i \sigma _j  } ( T \vec { v  } _i \mid T \vec { v  } _j ) = \frac { 1  } { \sigma _i \sigma _j  } ( \vec { v  } _i \mid T ^* T \vec { v  } _j ) = \frac { \sigma _j  } { \sigma _i  } \delta _{ i , j  } $,所以这当然也是一组单位正交基.</p>
<h4><span id="moore-penrose-广义逆">Moore-Penrose 广义逆</span></h4><p>取域$F $上的有限维向量空间$V , W $以及线性映射$T : V \to W $.其中$T $未必可逆,但有的时候我们又需要$T $的逆的性质,我们的目标是去找到一个弱一点的替代品.</p>
<p>我们声明一定存在一个$S : W \to V $,满足以下性质:</p>
<ol>
<li><p>$TST = T $.</p>
</li>
<li><p>$STS = S $.</p>
</li>
<li><p>$TS = ( TS ) ^* $.</p>
</li>
<li><p>$ST = ( ST ) ^* $.</p>
</li>
</ol>
<p>容易见到,如果$T $可逆,它的逆当然是一个MP广义逆.事实上我们可以证明满足上述条件的MP广义逆是唯一的.</p>
<p>先来证明其存在性,$\forall \vec { v  } \in V $,做分解$\vec { v  } = \vec { v  } ‘ + \vec { v  } ‘ ‘ $,其中$\vec { v  } ‘ \in \ker T $且$\vec { v  } ‘ ‘ \in ( \ker T ) ^\bot $.同样$\forall \vec { w  } \in W $,做分解$\vec { w  } = \vec { w  } ‘ + \vec { w  } ‘ ‘ $,其中$\vec { w  } ‘ \in \text { im  } T $.</p>
<p>接下来应当见到,任取$\vec { v  } $使得$T \vec { v  } = \vec { w  } $,则$T ^{ - 1  } ( \vec { w  } ‘ ) = \vec { v  } + \ker T $,而$\vec { v  } + \ker T $中的每个元素做投影后得到的$\vec { v  } ‘ ‘ $都是相同的,于是我们定义$S \vec { w  } = \vec { v  } ‘ ‘ $.容易验证$S $是线性映射,而且应当见到$ST $和$TS $其实都是正交投影,具体而言,$ST : V \to ( \ker T ) ^\bot $而$TS : W \to \text { im  } T $,也容易验证上述四条性质.也就是我们想法是,干脆考虑映射$V / \ker T \to \text { im  }  T $必然是可逆的,直接在这个上面找逆而不顾其它.</p>
<p>接下来证明其唯一性,假设$T $有两个MP广义逆$S , R $,我们注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
TS & = ( TS ) ^* & = S ^* T ^* & = S ^* ( TRT ) ^* \\
& = S ^* T ^* R ^* T ^* \\
& = ( TS ) ^* ( TR ) ^* \\
& = TSTR \\
& = TR 
\end{aligned}</script><p>同理可证明$ST = RT $,因此$S = STS = STR = RTR = R $,这就给出了唯一性的证明.</p>
<p>那么如何求出一个MP广义逆呢?考虑对于一个线性映射$T : V \to W $,将其视为标准基下的矩阵,做奇异值分解有$T = Q \Sigma P ^{ - 1  } $.</p>
<p>容易见到满足条件的MP逆$S $应当满足$S \vec { w  } _j = \frac { 1  } { \sigma _j  } \vec { v  } _j $,而写作矩阵形式的话就是$P \Pi Q ^{ - 1  } $,其中$\Pi $就是$\Sigma $的非零对角线全部取倒数.验证此事实的策略,要么取检验MP广义逆的定义,要么取一组基并观察投影,但总之都是容易的.</p>
<p>如果想要进一步说明MP广义逆的合理性,不妨考虑设$C ( t ) = T ^<em> T + t \cdot \mathrm { { id  }  } _V $,我们证明MP广义逆实际上就是$S = \lim _{ t \to 0 , \det C ( t ) \ne 0  } C ( t ) ^{ - 1  } T ^</em> $,证明无非也只是使用奇异值分解,考虑$T = Q \Sigma P ^{ - 1  } , T ^* = P \Sigma Q ^{ - 1  } $,那么$C ( t ) = P ( \Sigma ^2 + tI ) P ^{ - 1  } $,容易检验其满足性质.</p>
<h4><span id="极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</span></h4><p>对于实空间$V $,考察其标准内积$( _ \mid _ ) $和任一对称双线性形式$B : V \times V \to \mathbb { R  } $.当然存在唯一的$S \in \text { End  } ( V ) $使得$B ( \vec { v  } _1 , \vec { v  } _2 ) = ( \vec { v  } _1 \mid S \vec { v  } _2 ) $恒成立,无非是把$B $所代表的矩阵拿过来而已.</p>
<p>此时应有$S = S ^* $,对其施加正交对角化拿到单位正交基$\vec { v  } _1 , \cdots , \vec { v  } _n $和对应的一列特征值$\lambda _1 \geq \cdots \geq \lambda _n $.对于单位球面上的向量$\vec { v  } $,其应当满足$| \vec { v  } | = 1 $,此时我们注意到$\lambda _1 = \max _{ | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  } ) , \lambda _n = \min _{ | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  } ) $.原因只是取$\vec { v  } = \sum a _k \vec { v  } _k $,然后$B ( \vec { v  } , \vec { v  } ) = \sum _k a _k ^2 \lambda _k $.上述当然成立.确定除此以外的其他特征值需要更精确地刻画,我们引入如下定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lambda _k & = \min _{ U \subseteq V , \dim U = n - k + 1  } \left ( \max _{ \vec { v  } \in U , | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  } ) \right ) \\
\lambda _k & = \max _{ U \subseteq V , \dim U = k  } \left ( \min _{ \vec { v  } \in U , | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  } ) \right ) \\

\end{aligned}</script><p>将$S $用$- S $替换,则降序的特征值序列要翻转,立刻见到上述两条等价.下面只证明第一条.</p>
<p>取$W _k = \langle \vec { v  } _1 , \cdots , \vec { v  } _k \rangle $.应当见到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dim U \cap W _k & = \dim U + k - \dim ( U + W _k ) \\
& \geq \dim U + k - n & = 1 
\end{aligned}</script><p>这意味着这两个空间的交非零空间,取出一个交集元素$\vec { v  } = \sum _{ i = 1  } ^k a _i \vec { v  } _i \in U $且满足$| \vec { v  } | = 1 $.应当见到$B ( \vec { v  } , \vec { v  } ) = \sum _k \lambda _k a _k ^2 \geq \lambda _k $.这就意味着$\max _{ \vec { v  } \in U , | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  } ) \geq \lambda _k $.或言之$\inf \max _{ \vec { v  } \in U , | \vec { v  } | = 1  } B ( \vec { v  } , \vec { v  } ) \geq \lambda _k $.证明下界可取到只需取$U = \langle \vec { v  } _k , \cdots , \vec { v  } _n \rangle $即可取到(证明取到的策略呢,可以直接看基立刻得到,也可以采取更加严谨好说的方式即前后分别表示一下发现其既满足$\geq \lambda _k $又要$\leq \lambda _k $).</p>
<p>这个定理也可以用来求奇异值,半正定条件下,奇异值无非是特征值开根后的结果.</p>
<p>这个原理的重要意义是将奇异值,特征值这些东西全部挪到了空间本身的性质上(类似惯性定理).于是从此只要我们能拿到空间的同构当然就能断言奇异值,特征值全都同构,这是无可置疑的.</p>
<p>应当能看出这个定理更多有一种拓扑性质,事实上的确如此,如果能取最大值的话,这实际上对应了某种李氏连续性质.</p>
<h4><span id="perron-frobenius定理">Perron-Frobenius定理</span></h4><p>约定$A \geq B $表示对于每一个位置$a _{ i , j  } \geq b _{ i , j  } $.于是约定$A \geq 0 $意味着$A $中的任意元素都$\geq 0 $.</p>
<p>容易见到以下平凡引理:</p>
<ol>
<li><p>$A &gt; 0 , x \geq 0 , x \ne 0 \Rightarrow Ax &gt; 0 $.</p>
</li>
<li><p>$A \geq 0 , x \geq 0 \Rightarrow Ax \geq 0 $.</p>
</li>
</ol>
<p>定义实矩阵$A $的<strong>谱半径</strong>为$\rho ( A ) = \max { | \lambda |  } $,也就是所有复特征值模长的极大值.</p>
<p>虽然这里用到了复特征值,但意义仅是使得多项式可裂,而矩阵仍然是实数域的.因此仍然认为该定理是实内积空间里的定理.</p>
<h5><span id="collatz-wielandt公式">Collatz-Wielandt公式</span></h5><p>对于实矩阵$A &gt; 0 $,我们考虑$S = \{ \vec { x  } \in \mathbb { R  } ^n \mid | \vec { x  } | = 1 , \vec { x  } \geq 0 \} $,容易见到这是个紧集,考虑定义在其上的映射$L : S \to \mathbb { R _{ +  }  } , \vec { x  } \mapsto \min \left ( \cfrac { ( A \vec { x  } ) _i  } { x _i  } , x _i \ne 0 \right ) $.于是命$\rho \in \mathbb { R _+  } $为上述映射像中的极大值,我们下面证明两个事情:首先是这个$\rho $是$A $的一个特征值,其次是这个$\rho $就是$A $的谱半径.</p>
<p>首先证明其是一个特征值,而且对应的特征向量大于零,也就是$\exists \vec { v  } &gt; 0 , A \vec { v  } = \rho \vec { v  } $.容易由定义见到$\exists \vec { v  } , A \vec { v  } \geq \rho \vec { v  } $.假若$A \vec { v  } \ne \rho \vec { v  } $,则上述的平凡引理使得$A ( A \vec { v  } - \rho \vec { v  } ) &gt; 0 $.这里我们就应当会思考一个事情是,能否进行微调来使得得到更大的$\rho $从而导出矛盾.因此这里的思路应当是,取一个$\epsilon $然后找到一个向量$\vec { w  } $,使得$A \vec { w  } &gt; ( \rho + \epsilon ) \vec { w  } $从而导出矛盾.</p>
<p>回到我们拿到的条件,应该存在$\epsilon &gt; 0 $使得$A ( A \vec { v  } - \rho \vec { v  } ) &gt; \epsilon A \vec { v  } $,留意到由于平凡引理,应当$A \vec { v  } &gt; 0 $,取适当的$t $来归一化,定义出$\vec { w  } = tA \vec { v  } \in S $,从而上式导出:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A ( A \vec { v  } ) & > ( \rho + \epsilon ) A \vec { v  } \\
A \vec { w  } & > ( \rho + \epsilon ) \vec { w  } 
\end{aligned}</script><p>立即导出矛盾.因此必有$A \vec { v  } = \rho \vec { v  } $.此外,引理告诉我们$A \vec { v  } &gt; 0 $恒成立,则$\vec { v  } = \rho ^{ - 1  } A \vec { v  } &gt; 0 $亦然成立.</p>
<p>接下来证明这个$\rho $就是谱半径$\rho ( A ) $.由定义见到$\rho $作为特征值应当满足$\rho \leq \rho ( A ) $,接下来只需证明$\rho \geq \rho ( A ) $即可.</p>
<p>对于所有的特征值$\mu $和相应的特征向量$\vec { w  } \ne 0 $满足$A \vec { w  } = \mu \vec { w  } $,使用三角不等式,$\forall 1 \leq i \leq n $应当有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
| \mu | | w _i | & = | ( A \vec { w  } ) _i | \\
& = | \sum _j a _{ i , j  } w _j | & \leq \sum _j a _{ i , j  } | w _j | 
\end{aligned}</script><p>将$\vec { w  } ‘ = ( | w _1 | , \cdots , | w _n | ) \in \mathbb { R  } ^n $,也就是将复向量强行转到实向量上,上式立刻给出$A \vec { w  } ‘ \geq | \mu | \vec { w  } ‘ $.伸缩该向量使得$| \vec { w  } ‘ | = 1 $,于是上式给出$\rho \geq L ( \vec { w  } ‘ ) \geq | \mu | $,这就给出了$\rho ( A ) \leq \rho $.于是证毕.</p>
<h5><span id="perron定理">Perron定理</span></h5><p>对于实矩阵$A &gt; 0 $,我们接下来声明如下定理:</p>
<ol>
<li><p>$\rho ( A ) &gt; 0 $,$\exists \vec { v  } \in \mathbb { R  } ^n , \vec { v  } &gt; 0 , A \vec { v  } = \rho ( A ) \vec { v  } $.也即:谱半径的确是一个特征值.</p>
</li>
<li><p>如果$\lambda \ne \rho ( A ) $,则$| \lambda | &lt; \rho ( A ) $.也就是:谱半径只此实特征值能达到.</p>
</li>
<li><p>谱半径的代数重数和几何重数均为$1 $.</p>
</li>
</ol>
<p>(1)也就是Collatz-Wielandt公式.</p>
<p>(2)的话考虑对Collatz-Wielandt公式作一些补充.假使复特征值$\mu $满足$| \mu | = \rho ( A ) $,则不等式链$\rho ( A ) = \max L ( \vec { v  } ) \geq L ( \vec { w  } ‘ ) \geq | \mu | = \rho ( A ) $必然全部三角不等式取等,中间的每一项$w _j $都必然落在复平面的同一条直线上,那就可以除去一个复数得到实向量$\vec { w  } ‘ ‘ $亦然满足$A \vec { w  } ‘ ‘ = \mu \vec { w  } ‘ ‘ $,由于该式子中除了$\mu $均为实数,因此$\mu $也必然是实数.而且$\mu $当然不可能是负数,这样就完成了(2)的证明.</p>
<p>(3)的话先考虑证明几何重数$\dim V _{ \rho ( A )  } = 1 $,考虑$\vec { v  } , \vec { v  } ‘ $都是$\rho ( A ) $的特征向量,其中$\vec { v  } $由于上述讨论而满足$\vec { v  } &gt; 0 $,而$\vec { v  } ‘ $至少有一个分量为正数.既然如此,应当可以取足够小的$\epsilon &gt; 0 $使得$\vec { v  } - \epsilon \vec { v  } ‘ \geq 0 $,以至于可以取其中尽可能大的$\epsilon $使得$\vec { v  } - \epsilon \vec { v  } ‘ $的某一个分量恰好为$0 $.我们接下来声明此时$\vec { v  } - \epsilon \vec { v  } ‘ = 0 $以说明$\vec { v  } ‘ $和$\vec { v  } $线性相关</p>
<p>为说明此进行反证,假设$\vec { v  } - \epsilon \vec { v  } ‘ \ne 0 $,用平凡引理,考虑$\vec { v  } - \epsilon \vec { v  } ‘ = \frac { 1  } { \rho ( A )  } A ( \vec { v  } - \epsilon \vec { v  } ‘ ) &gt; 0 $,然而我们已经说明其有一个分量为$0 $,导出矛盾.</p>
<p>接下来考虑(3)的完全版本,利用$\dim V _{ \rho ( A )  } = 1 $,如果我们能将整个空间拆成两部分不变子空间,其中一部分是$\langle \vec { v  } \rangle $,那就可以完成上面的部分,原因是此时另一部分不变子空间中不能有$\rho ( A ) $作为根,否则与其维数为$1 $矛盾.另一方面,原本的特征多项式就是两个不变子空间的特征多项式的乘积,这就证明了单根的性质.</p>
<p>于此,考虑以下操作:考虑$\text { char  } ( A ) = \text { char  } ( A ^T ) $,于是$\rho ( A ) = \rho ( A ^T ) $,这就意味着$\exists \vec { u  } &gt; 0 $使得$( A ^T ) \vec { u  } = \rho ( A ) \vec { u  } $.取出它的正交补空间$\langle \vec { u  } \rangle ^\bot $,它应当是$A $的不变子空间,原因是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \vec { u  } ) ^T ( A \vec { x  } ) & = ( A ^T \vec { u  } ) ^T \vec { x  } \\
& = \rho ( A ) ( \vec { u  } ) ^T \vec { x  } & = 0 
\end{aligned}</script><p>同时注意到$\vec { v  } &gt; 0 , \vec { u  } &gt; 0 $,所以$\vec { v  } \notin \langle \vec { u  } \rangle ^\bot $,这就完成了直和分解,于是上述命题证毕.</p>
<h4><span id="实正交变换的标准型">实正交变换的标准型</span></h4><p>(ps:虽然这里放在实内积空间里,然而大部分性质实际上是转移自复内积空间的结构,应当先看下面的章节,回头再来观察此节.)</p>
<p>回忆到取定$V $是实线性空间,并取上面的某种内积形式,对于$T \in \text { End  } ( V ) $,若其满足$T ^* = T ^{ - 1  } $,则它是实正交变换.特别地,当取标准内积的时候,所对应的就是正交矩阵,则$A ^t = A ^{ - 1  } $.</p>
<p>回忆到此时$\det A = \pm 1 $.</p>
<p>将正规算子的概念从复数域里面拿到实数域,即满足$( A ^t ) A = A ( A ^t ) $.我们在下面做复数酉变换的时候证明过引理:$\exists k \geq 0 , T ^k = 0 \Rightarrow T = 0 $.容易见到正交算子一定是正规的.</p>
<p>接下来来观察不同维度的正交变换,假设$\dim _{ \mathbb { R  }  } V = n $.</p>
<p>当$n = 1 $的时候,正交变换显然是长度为$\pm 1 $的伸缩变换,也就是$\pm \text { id  } _V $.</p>
<p>当$n = 2 $的时候,不妨设矩阵为$\begin{bmatrix}\alpha &amp; \beta \ \gamma &amp; \delta \end{bmatrix} $,用正交性质就知道:</p>
<script type="math/tex; mode=display">
\begin{cases}
\alpha ^2 + \gamma ^2 = 1 \\
\beta ^2 + \delta ^2 = 1 \\
\alpha ^2 + \beta ^2 = 1 \\
\gamma ^2 + \delta ^2 = 1 
\end{cases}</script><p>做三角换元后考虑到行列式为$\pm 1 $,在一些简单的确定后,立刻见到原矩阵要么是:$\begin{bmatrix}\cos \theta &amp; - \sin \theta \ \sin \theta &amp; \cos \theta \end{bmatrix} $,要么是$\begin{bmatrix}\cos \theta &amp; \sin \theta \ \sin \theta &amp; - \cos \theta \end{bmatrix} $,它们的行列式分别为$\pm 1 $.</p>
<p>拿出行列式恰好为$+ 1 $的前者:</p>
<script type="math/tex; mode=display">
R ( \theta ) = \begin{bmatrix}
\cos \theta & - \sin \theta \\
\sin \theta & \cos \theta 
\end{bmatrix}</script><p>也就是通常所说的旋转矩阵.容易见到:</p>
<ol>
<li><p>$R ( \theta ) R ( \psi ) = R ( \theta + \psi ) = R ( \psi ) R ( \theta ) $.</p>
</li>
<li><p>如果$P $是一个正交算子,则$P ^{ - 1  } R ( \theta ) P = R ( ( \det P ) \theta ) $.</p>
</li>
</ol>
<p>(1)只需对$\vec { e  } $验证即可.</p>
<p>(2)的话,当$\det P = 1 $的时候,当然有$P = R ( \psi ) , P ^{ - 1  } = R ( - \psi ) $,那显然成立了;当$\det P = - 1 $的时候,只需在外面补一个$\begin{bmatrix}1 &amp; 0 \ 0 &amp; - 1 \end{bmatrix} $即可转化.</p>
<p>于此之前,考虑如果$T $是正交变换,它当然一定是正规的,那么它在复数上可正交对角化,特征值当然满足$| \lambda | = 1 $,那么当然$T + T ^{ - 1  } $自伴.而且它俩可以同步对角化,那$T + T ^{ - 1  } $的特征值当然是$| \mu | = | \lambda + \lambda ^{ - 1  } | \leq | \lambda | + | \lambda ^{ - 1  } | = 2 $.</p>
<p>接下来考虑一般的情况,我们声明,对于任意正交变换,都可以取基转化为下述形式:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I _{ a \times a  } & & & \\
& - I _{ b \times b  } & & & \\
& & R ( \theta _1 ) & & \\
& & & \ddots & \\
& & & & R ( \theta _k ) 
\end{bmatrix}</script><p>其中$\theta _1 , \cdots , \theta _k $都并非$\pi $的整数倍.</p>
<p>证明考虑令$S = T ^{ - 1  } + T $,容易见到其自伴,那原空间就可以拆成$S $的若干特征子空间的直和,容易发现$ST = TS $,这必然意味着$V _\lambda $是$T $不变的,于是下面可以只着眼于一个特征子空间,观测$V = V _\lambda $的情形,且$\lambda \in \mathbb { R  } , | \lambda | \leq 2 $.</p>
<p>则此时观察此空间,应当有$T + T ^{ - 1  } = \lambda I _V $.两边乘以$T $,得到$T ^2 - \lambda T + I = 0 $.</p>
<p>下面我们开始讨论,当$\lambda = \pm 2 $的时候,则上述配方得到$( T \mp I ) ^2 = 0 $,由于$T \mp I $是正规算子,于是$T \mp I = 0 $,这就对应了上述矩阵中的$\pm 1 $的分块.</p>
<p>那如果$\lambda \ne \pm 2 $呢,那就必然有$| \lambda | &lt; 2 $,则$x ^2 - \lambda x + 1 $无实根,不可约,但带入$x = T $会得到$0 $,因此它必然是$T $在此空间下的极小多项式.又因为$T $如果有实特征值,必然是$\pm 1 $,则此时$\lambda = \pm 2 $.因此,$T $没有实特征值.既然如此,任取一个向量$\vec { v  } \ne 0 $,$\vec { v  } $与$T \vec { v  } $必然线性无关.</p>
<p>既然如此,使他们张成子空间$W = \langle \vec { v  } , T \vec { v  } \rangle $并作直和分解$V = W \oplus W ^\bot $.由于$T ^2 = \lambda T - I $,因此注意到$W $应当是$T $不变的.那么,$W ^\bot $在$T ^* = T ^{ - 1  } $作用下当然也是不变的.然而,$T = \lambda I - T ^{ - 1  } $,所以$T $是关于$T ^{ - 1  } $的多项式,于是$W ^\bot $在$T $下也是不变的.这样,我们完全把空间归纳下去了,每次都可以扔出去一个$\dim = 2 $的空间.于是最后一步是检验$T $在归纳下去的空间上的性质.对于$\dim = 2 $的空间,$x ^2 - \lambda x + 1 $当然仍然不可约,而它必然就是特征多项式,那$\det = 1 $就自然成立.</p>
<p>最后应当简单解释上述形式是否由$T $唯一确定.然而应属显然了,因为每一次拆出的特征多项式当然都是原本特征多项式的一个不可约因子.</p>
<h5><span id="欧拉角">欧拉角</span></h5><p>考虑三维空间中的旋转,我们通过上述对实正交矩阵的分类得知,三维空间中的旋转立刻统合为$\begin{bmatrix}1 &amp; \ &amp; R ( \theta ) \end{bmatrix} $.</p>
<p>那么就需要两个参数来描述此,旋转轴$\vec { u  } = \vec { v  } _1 $的坐标用以描述转轴以及一个参数$\theta $用来描述转角.不妨将这种旋转记作$R _{ u  } ( \theta ) $.然而于此之外,先要论证此旋转和另外两个单位正交基$\vec { v  } _2 , \vec { v  } _3 $无关.然而容易见到不管如何选取这两个基,它们都会同样张成$\langle \vec { u  } \rangle ^\bot $,因此它们都在同一个空间里,而且只差一个旋转.这个旋转前后当然可以抵消,这也是直觉所告知我们的.</p>
<p>由此就可以看到三维空间的及其好的性质,我们一般称呼二维空间中的旋转,它的转轴实际上是垂直于此平面的一个更高维的轴.而三维空间中的转轴一定落在三维空间中,不需要再到高维空间中找到转轴了.</p>
<p>综上,旋转总是将一个有序单位正交基转化为另一个有序单位正交基,三维空间中表现为$( \vec { e  } _1 , \vec { e  } _2 , \vec { e  } _3 ) \to ( \vec { u  } _1 , \vec { u  } _2 , \vec { u  } _3 ) $.</p>
<p>对于指定基的旋转,我们应当通过一定的交换基的操作见到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
R _{ e _1  } ( \theta ) & = \begin{bmatrix}
1 & & \\
& \cos \theta & - \sin \theta \\
& \sin \theta & \cos \theta 
\end{bmatrix} \\
R _{ e _2  } ( \theta ) & = \begin{bmatrix}
\cos \theta & & \sin \theta \\
& 1 & \\
- \sin \theta & & \cos \theta 
\end{bmatrix} \\
R _{ e _3  } ( \theta ) & = \begin{bmatrix}
\cos \theta & - \sin \theta & \\
\sin \theta & \cos \theta & \\
& & 1 
\end{bmatrix} \\

\end{aligned}</script><p>为了表示使得任意基下的旋转,我们考虑先转好一个轴,然后再以此轴作旋转.那我们考虑构造一个$\vec { f  } _2 = \begin{cases}\vec { e  } _2 &amp; \vec { e  } _3 / / \vec { u  } _3 \ \vec { e  } _3 \times \vec { u  } _3 &amp; otherwisse \end{cases} $.</p>
<p>换言之,此时我们选了一个轴$\vec { f  } _2 $,它与$\vec { u  } _3 , \vec { e  } _3 $均正交,那我们就可以这么转:</p>
<ol>
<li><p>将$( \vec { e  } _1 , \vec { e  } _2 , \vec { e  } _3 ) $绕$\vec { e  } _3 $转到$( \vec { f  } _1 , \vec { f  } _2 , \vec { e  } _3 ) $.</p>
</li>
<li><p>将$( \vec { f  } _1 , \vec { f  } _2 , \vec { e  } _3 ) $绕$\vec { f  } _2 $转到$( \vec { g  } _1 , \vec { f  } _2 , \vec { u  } _3 ) $.</p>
</li>
<li><p>将$( \vec { g  } _1 , \vec { f  } _2 , \vec { u  } _3 ) $绕$\vec { u  } _3 $转到$( \vec { u  } _1 , \vec { u  } _2 , \vec { u  } _3 ) $.</p>
</li>
</ol>
<p>综上,一个旋转矩阵总可以写成三个矩阵$R _{ u _2  } ( \varphi ) R _{ f _2  } ( \theta ) R _{ e _3  } ( \psi ) $的乘积,我们称$T $是由<strong>欧拉角</strong>$( \varphi , \theta , \psi ) $所确定的.</p>
<p>不过,上述的转轴并非我们选定的有序正交基$( \vec { e  } _1 , \vec { e  } _2 , \vec { e  } _3 ) $,换言之,转轴不是以观察者视角的,而是以被旋转物体本身的视角而言的.可既然要转为矩阵表述,我们应当搞一个观察者版本的矩阵.这就要求转轴被控制为$( \vec { e  } _1 , \vec { e  } _2 , \vec { e  } _3 ) $.我们下面尝试证明$R _{ u _2  } ( \varphi ) R _{ f _2  } ( \theta ) R _{ e _3  } ( \psi ) = R _{ e _3  } ( \psi ) R _{ e _2  } ( \theta ) R _{ e _3  } ( \varphi ) $.</p>
<p>对于正交变换$P $,并设$\epsilon = \det P = \pm 1 $,应当有$R _{ Pu  } ( \epsilon \theta ) = PR _u ( \theta ) P ^{ - 1  } $.其实到这里只有这个$\epsilon $的用法并非显然,但总之,用代数的语言可以看出$P $将$( \vec { u  } , \vec { v  } , \vec { w  } ) \mapsto ( P \vec { u  } , P \vec { v  } , P \vec { w  } ) $,这当然仍是一组有序正交基.但为了使其的方向为正,可以改为$( P \vec { u  } , P \vec { v  } , \epsilon P \vec { w  } ) $以避免讨论,然后去检验$PR _u ( \theta ) $和$R _{ Pu  } ( \epsilon \theta ) P $对基$( \vec { u  } , \vec { v  } , \vec { w  } ) $的作用.总之容易验证.</p>
<p>既然如此,考虑$\vec { f  } _2 = R _{ e _3  } ( \psi ) \vec { e  } _2 $,既然如此,$R _{ f _2  } ( \theta ) = R _{ e _3  } ( \psi ) R _{ e _2  } ( \theta ) R _{ e _3  } ( \psi ) ^{ - 1  } $.</p>
<p>同理,$\vec { u  } _3 = R _{ f _2  } ( \theta ) \vec { e  } _3 = R _{ f _2  } ( \theta ) R _{ e _3  } ( \psi ) \vec { e  } _3 $,既然如此,得到$R _{ u _3  } ( \varphi ) = R _{ e _3  } ( \psi ) R _{ e _2  } ( \theta ) R _{ e _3  } ( \varphi ) R _{ e _2  } ( \theta ) ^{ - 1  } R _{ e _3  } ( \psi ) ^{ - 1  } $.这就证明了上述结论.</p>
<p>更具体地说,它表为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & & \\
& \cos \psi & - \sin \psi \\
& \sin \psi & \cos \psi 
\end{bmatrix} \begin{bmatrix}
\cos \theta & & \sin \theta \\
& 1 & \\
- \sin \theta & & \cos \theta 
\end{bmatrix} \begin{bmatrix}
1 & & \\
& \cos \varphi & - \sin \varphi \\
& \sin \varphi & \cos \varphi 
\end{bmatrix}</script><h5><span id="四元数">四元数</span></h5><p>试图搞一个以$\mathbb { R  } \subsetneq \mathbb { C  } \subsetneq \mathbb { H  } $的东西.其中$\mathbb { H  } $是一个除环,也就是在域的基础上丢掉了交换律.</p>
<p>具体如何构造呢?考虑在实线性空间的基础上引入乘法,那就先要构造它的一组基$\{ 1 , i , j , k \} $.现在就只需要定义乘法,当然是$\mathbb { H  } \times \mathbb { H  } \to \mathbb { H  } , ( x , y ) \mapsto x \cdot y $,并且要求它对于$\mathbb { R  } $是双线性的.同时要求以下规则:</p>
<ol>
<li><p>$1 \cdot x = x $.</p>
</li>
<li><p>$i ^2 = j ^2 = k ^2 = - 1 $.</p>
</li>
<li><p>$ij = k = - ji $.</p>
</li>
<li><p>$jk = i = - kj $.</p>
</li>
<li><p>$ki = j = - ik $.</p>
</li>
</ol>
<p>那么双线性性质和上述约定当然搞定了一个乘法映射.为说明其是环,还应当验证以下性质:</p>
<ol>
<li><p>分配律.由双线性形式显然.</p>
</li>
<li><p>结合律.只需验证上述四个元素$1 , i , j , k $的结合律即可.</p>
</li>
</ol>
<p>这就搞定了环的性质.可以看到$\mathbb { H  } $可以看作$\mathbb { R  } $或者$\mathbb { C  } $上的向量空间,对于前者是因为$q = a + bi + cj + dk $,对于后者是因为任何一个$q $都可以写作$q = z + jw $,其中$z , w \in \mathbb { C  } $的形式,这里顺便一提此表述下$jw = \bar { w  } j $.这当然顺便也搞定了除环的性质.</p>
<p>回忆到环的中心$Z ( \mathbb { H  } ) = \{ z \in \mathbb { H  } \mid \forall q \in \mathbb { H  } , zq = qz \} $.我们声称$Z ( \mathbb { H  } ) = \mathbb { R  } $.由于$\mathbb { H  } $的特殊性,我们知道只需要对$\{ 1 , i , j , k \} $检查交换性即可,会发现只有$\mathbb { R  } $是合理的.</p>
<p>定义一个四元数$q = a + bi + cj + dk $的<strong>共轭</strong>$\bar { q  } = a - bi - cj - dk $,定义其<strong>迹</strong>$\mathrm { { Tr  }  } ( q ) = q + \bar { q  } = 2 a $,再定义其<strong>范数</strong>$N ( q ) = q \bar { q  } $.有以下性质:</p>
<ol>
<li><p>共轭对$\mathbb { R  } $是线性映射.</p>
</li>
<li><p>$\overline { ( \bar { q  } )  } = q $.</p>
</li>
<li><p>$\overline { q _1 + q _2  } = \bar { q _1  } + \bar { q _2  } $.</p>
</li>
<li><p>$\overline { q _1 q _2  } = \bar { q _2  } \bar { q _1  } $.</p>
</li>
<li><p>迹对$\mathbb { R  } $是线性映射.</p>
</li>
<li><p>$\bar { N ( q )  } = N ( q ) = N ( \bar { q  } ) $.</p>
</li>
<li><p>$N ( a + bi + cj + dk ) = a ^2 + b ^2 + c ^2 + d ^2 \in \mathbb { R  } $.</p>
</li>
<li><p>$N ( q _1 q _2 ) = N ( q _1 ) N ( q _2 ) $.</p>
</li>
<li><p>如若$q \ne 0 $,则$q ^{ - 1  } = ( N ( q ) ) ^{ - 1  } \bar { q  } $.</p>
</li>
<li><p>$N ( q ^{ - 1  } ) = N ( q ) ^{ - 1  } $</p>
</li>
</ol>
<p>(1)(2)(3)是显然的.(4)的话由于乘法的双线性,只需验证$q _1 , q _2 \in \{ 1 , i , j , k \} $的情形.</p>
<p>(5)(6)是显然的.</p>
<p>(7)除了暴力验证以外,观察到(6),考虑$N ( a + bi + cj + dk ) = a ^2 + b ^2 + c ^2 + d ^2 + xi + yj + zk $,然而$\bar { N ( q )  } = N ( q ) $,这必然意味着后面均为$0 $.</p>
<p>(8)(9)(10)只需展开检验即可.这就详细描述了除环的结构.</p>
<p>我们还可以证明四元数已经到达极限了,有Frobenius定理:如果$D $是一个除环且是一个$\mathbb { R  } $上的有限维线性空间,其乘法还对$\mathbb { R  } $满足双线性,那么$D $一定同构于$\mathbb { R  } , \mathbb { C  } , \mathbb { H  } $三者其一,再无别的情形.怎么证明?我不会,长大后再学习.</p>
<p>最后我们还可以验证$\mathbb { H  } $可以表为$M _{ 2 \times 2  } ( \mathbb { C  } ) $的一个子环,考虑仍取$q = z + jw $,然后将其改写为$\begin{bmatrix}z &amp; - \bar { w  } \ w &amp; \bar { z  } \end{bmatrix} $.这个矩阵结构可以符合加法,乘法,迹(对应到矩阵的迹),范数(对应到矩阵的行列式).这其实很像复数上把$a + bi \mapsto \begin{bmatrix}a &amp; - b \ b &amp; a \end{bmatrix} $.那么我们可以:</p>
<script type="math/tex; mode=display">
\begin{gathered}
1 \mapsto \begin{bmatrix}
1 & \\
& 1 
\end{bmatrix} \\
i \mapsto \begin{bmatrix}
i & \\
& - i 
\end{bmatrix} \\
j \mapsto \begin{bmatrix}
& - 1 \\
1 & 
\end{bmatrix} \\
k \mapsto \begin{bmatrix}
& - i \\
- i & 
\end{bmatrix} \\

\end{gathered}</script><p>接下来考虑去掉环的性质,只看线性空间的性质,将目光着眼于$\mathbb { R  } ^3 $上并只取出$q = ai + bj + ck $,取这个子空间为$\mathbb { H  } _0 $,在上面挪用$N ( q ) $以刻画长度,具体而言只需取$\Vert q \Vert ^2 = N ( q ) $.</p>
<p>接下来,让$x \in \mathbb { H  } ^\times $,我们声明:</p>
<ol>
<li><p>$\forall q \in \mathbb { H  } $,$N ( xqx ^{ - 1  } ) = N ( q ) $.</p>
</li>
<li><p>设$R _x \in \text { End  } ( \mathbb { H  } _0 ) , q \mapsto xqx ^{ - 1  } $,则这是个正交变换.</p>
</li>
<li><p>$\det R _x = 1 $.</p>
</li>
<li><p>$R _{ tx  } = R _x $,其中$t \in \mathbb { R  } ^\times $,且$R _x R _y = R _{ xy  } , R _{ x ^{ - 1  }  } = ( R _x ) ^{ - 1  } $.而且$R _{ - 1  } = R _1 = \text { id  } _{ \mathbb { H  } _0  } $.</p>
</li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的话,不妨假设$N ( x ) = 1 $,此时$x ^{ - 1  } = \bar { x  } $.首先要证明这个映射确实是$\text { End  } ( \mathbb { H  } _0 ) $里面的,观察$\overline { xqx ^{ - 1  }  } = \bar { x ^{ - 1  }  } \bar { q  } \bar { x  } = x ( \bar { q  } ) x ^{ - 1  } = - xqx ^{ - 1  } $,这就说明$xqx ^{ - 1  } \in \mathbb { H  } _0 $.</p>
<p>然后要检验它是线性映射,这里只需使用除环的性质简单验证.</p>
<p>最后由(1)说明其保距,这就说明了它是正交变换.</p>
<p>最后是(3),将$\mathbb { H  } \cong \mathbb { R  } ^4 $考虑映射$\mathbb { R  } ^4 \setminus \{ 0 \} \to \{ \pm 1 \} , x \mapsto \det R _x $.这由于矩阵$R _x $的每个元当然是关于$x $的连续函数,因此整个映射都是连续的,而空间$\mathbb { R  } ^4 \setminus \{ 0 \} $是联通的,因此整个映射必然只射到常数,而$\det R _1 = 1 $,因此对于任意$x \in \mathbb { H  } ^\times $都有$\det R _x = 1 $.</p>
<p>(4)只需简单验证即可.</p>
<p>所以我们终于见到了,这个$R _x $应当就是三维上的正交旋转.现在最后的问题在于是否所有的旋转都可以表示为$R _x $.我们有下述定理:即对于任意在$\mathbb { H _0  } $上的旋转$T $,$\exists x \in \mathbb { H  } $,$N ( x ) = 1 $,使得$T = Rx $,并且$x $精确到绝对值是唯一的,换言之,恰有两个$x , - x $满足上述条件.</p>
<p>先证明存在性,回忆到欧拉角声明了$T $可以由三个绕轴旋转完成.也就是说,只要我们能证明绕轴旋转$R _{ e _l  } ( \theta ) $可以用四元数表示,那么任意旋转都可以用四元数表示了.</p>
<p>不同轴类似只算一个,当绕着$i $那条轴转的时候,取$x = \cos \theta + i \sin \theta $,则$x ^{ - 1  } = \bar { x  } = \cos \theta - i \sin \theta $,见到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
xix ^{ - 1  } & = i \\
xjx ^{ - 1  } & = \cos ( 2 \theta ) j + \sin ( 2 \theta ) k \\
xkx ^{ - 1  } & = - \sin ( 2 \theta ) j + \cos ( 2 \theta ) k 
\end{aligned}</script><p>综上见到$R _x $是:$\begin{bmatrix}1 &amp; \ &amp; R ( 2 \theta ) \end{bmatrix} $,这样就实现了对第一个坐标轴转$2 \theta $的情形.</p>
<p>类似的,就可以说明四元数可以表示所有的旋转.</p>
<p>最后要检验唯一性,如果$R _x = R _y $,其中$N ( x ) = N ( y ) = 1 $,那就有$\text { id  } _{ \mathbb { H  } _0  } = R _x ( R _y ) ^{ - 1  } = R _{ xy ^{ - 1  }  } $.</p>
<p>于是最后转化为说,要证明如果$R _{ x  } = \text { id  } _{ \mathbb { H  } _0  } $,那么$x = \pm 1 $.那就说明$\forall q , xqx ^{ - 1  } = q $,也就是$x \in Z ( \mathbb { H  } ) = \mathbb { R  } $.又由于$N ( x ) = 1 $,所以$x = \pm 1 $.</p>
<p>更具体来说,绕着$u $这条轴,且满足$N ( u ) = 1 $来说,那么$R _u ( \theta ) = \cos \frac { \theta  } { 2  } + u \sin \frac { \theta  } { 2  } $.</p>
<p>首先要验证$x = \cos \frac { \theta  } { 2  } + u \sin \frac { \theta  } { 2  } $满足$N ( x ) = 1 $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N ( x ) & = x \bar { x  } \\
& = ( \cos \frac { \theta  } { 2  } + u \sin \frac { \theta  } { 2  } ) ( \cos \frac { \theta  } { 2  } - u \sin \frac { \theta  } { 2  } ) \\
& = \cos ^2 \frac { \theta  } { 2  } - u ^2 \sin ^2 \frac { \theta  } { 2  } \\
& = \cos ^2 \frac { \theta  } { 2  } + N ( u ) \sin ^2 \frac { \theta  } { 2  } \\
& = 1 
\end{aligned}</script><p>而考虑总存在一个旋转$P = R _y $,使得$P ( i ) = u $,此时我们可以知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
R _u ( \theta ) & = PR _i ( \theta ) P ^{ - 1  } \\
& = R _y R _i ( \theta ) R _{ y ^{ - 1  }  } \\

\end{aligned}</script><p>不妨设$R _u ( \theta ) = R _x $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x & = y ( \cos \frac { \theta  } { 2  } + i \sin \frac { \theta  } { 2  } ) y ^{ - 1  } \\
& = \cos \frac { \theta  } { 2  } + \sin \frac { \theta  } { 2  } yiy ^{ - 1  } \\
& = \cos \frac { \theta  } { 2  } + \sin \frac { \theta  } { 2  } u 
\end{aligned}</script><p>用欧拉公式的话,有$R _u ( \theta ) = e ^{ \frac { \theta  } { 2  } u  } $.</p>
<h3><span id="复内积空间">复内积空间</span></h3><h4><span id="共轭空间">共轭空间</span></h4><p>这应当带给我们思考,既然远在定义复数的时候,我们就声称过$i $和$- i $无法区分,于是在此,应当研究一下共轭前后的两个空间分别的性质.</p>
<p>设$V $是$\mathbb { C  } $下的向量空间,它的复共轭$\bar { V  } $是按照以下方式确定的$\mathbb { C  } $向量空间:</p>
<ol>
<li><p>集合$V $与加法操作与原空间相同.</p>
</li>
<li><p>纯量乘法$\odot : \mathbb { C  } \times V \to V $定义为$t \odot \vec { v  } = \bar { t  } \vec { v  } $.</p>
</li>
</ol>
<p>显然$\overline { ( \bar { V  } )  } = V $.半双线性映射无非是线性映射$\bar { V  } \to W $.当然,也可以等价说是$V \to \bar { W  } $.我们接下来验证复共轭的若干性质:</p>
<ol>
<li><p>映射$z \mapsto \bar { z  } $给出向量空间的共轭$\mathbb { C  } \cong \bar { \mathbb { C  }  } : z \mapsto \bar { z  } $.</p>
</li>
<li><p>$\bar { V  } _1 \oplus \bar { V  } _2 = \overline { V _1 \oplus V _2  } $.</p>
</li>
<li><p>$\overline { \text { Hom  } ( V _1 , V _2 )  } = \text { Hom  } ( \bar { V  } _1 , \bar { V  } _2 ) $.</p>
</li>
<li><p>${ \bar { W  }  } ^\vee \cong \overline { W ^\vee  } $,其实是(3)的另一种表示方式.</p>
</li>
</ol>
<p>应当检验上述映射,同构,甚至是完全挪移都是良定义的且半线性的,这里不做赘述.</p>
<p>相信对共轭空间最大的疑问在于,既然其改变了纯量乘法,原本的向量结构为什么不会被打乱呢?事实上,如果你考虑选定一组基的话,纯量乘法上的轻微改变只会使得将其它向量转化为基表示形式的过程中所提取出的纯量发生变化,然而共轭满足$\overline { z _1 z _2  } = \bar { z _1  } \bar { z _2  } $.虽然取定基的做法并非典范,然而不同基之间的转化仍然可以提取纯量.或者说,我们可以先取$V \cong \mathbb { C  } ^n \cong ( \bar { \mathbb { C  }  } ) ^n \cong \bar { V  } $.</p>
<p>或直接从复数的几何意义来说,共轭无非是将逆时针旋转改为顺时针旋转,这应当仍是合理的.</p>
<h4><span id="复半双线性形式">(复)半双线性形式</span></h4><p>应当见到双线性形式在复空间中未必有很好的应用,原因是正定性难以得到满足.</p>
<p>定义<strong>半线性映射</strong>为$T : V \to W $满足:</p>
<ol>
<li><p>$T ( \vec { v  } _1 + \vec { v  } _2 ) = T ( \vec { v  } _1 ) + T ( \vec { v  } _2 ) $.</p>
</li>
<li><p>$T ( t \vec { v  } ) = \bar { t  } T ( \vec { v  } ) $.</p>
</li>
</ol>
<p>定义<strong>半双线性映射</strong>为$B : V \times W \to X $满足:</p>
<ol>
<li><p>$B ( \vec { v  } _1 + \vec { v  } _2 , \vec { w  } ) = B ( \vec { v  } _1 , \vec { w  } ) + B ( \vec { v  } _2 , \vec { w  } ) $.</p>
</li>
<li><p>对第一个变量半线性:$B ( t \vec { v  } , \vec { w  } ) = \bar { t  } B ( \vec { v  } , \vec { w  } ) $.</p>
</li>
<li><p>$B ( \vec { v  } , \vec { w  } _1 + \vec { w  } _2 ) = B ( \vec { v  } , \vec { w  } _1 ) + B ( \vec { v  } , \vec { w  } _2 ) $.</p>
</li>
<li><p>对第二个变量线性:$B ( \vec { v  } , t \vec { w  } ) = t B ( \vec { v  } , \vec { w  } ) $.</p>
</li>
</ol>
<p>至于复伴随映射以及其余的东西,无非只是在实数上类似的定义的照抄.将上述记作$\text { Sesq  } ( V , W ; X ) $.特别地,当$X = \mathbb { C  } $的时候,将此称作半双线性形式.应当立刻见到$\text { Sesq  } ( V , W ; X ) = \text { Bil  } ( \bar { V  } , W ; X ) $.</p>
<p>至于非退化等部分仍然是实数情况的照抄,对左右根,不妨设左根空间为$L $,右根空间为$R $,用柯里化过程见到该形式等价于$\psi \in \text { Hom  } ( W , { \bar { V  }  } ^\vee ) $或者$\varphi \in \text { Hom  } ( \bar { V  } , W ^\vee ) $,那么$L = \ker \varphi , R = \ker \psi $,我们应当见到$B ‘ : ( V / L ) \times ( W / R ) \to F , ( \vec { v  } + L , \vec { w  } + R ) \mapsto B ( \vec { v  } , \vec { w  } ) $是非退化双线性形式.此时见到其实$\dim V - \dim L = \dim W - \dim R $.</p>
<p>接下来要用矩阵形式予以表述,我们声称$M _{ m \times n  } ( \mathbb { C  } ) \cong \text { Sesq  } ( \mathbb { C  } ^m , \mathbb { C  } ^n ) , A \mapsto B ( \vec { v  } , \vec { w  } ) = ( ^\dagger \vec { v  } ) A \vec { w  } $,原因是标准基下$\mathbb { C  } $的对偶空间其实就是共轭转置后的结果.</p>
<h4><span id="伴随映射">伴随映射</span></h4><p>与实数情况毫无差异,我们在此复述一遍当时的图表即可:</p>
<script type="math/tex; mode=display">
\xymatrix { V _2 ' \ar [r ] ^{ T ^*  } \ar [d ] _{ A _2  } & V _1 ' \ar [d ] ^{ A _1  } \\
\check { V _2  } \ar [r ] ^{ ^\dagger T  } & \check { V _1  } \\
V _2 \ar [u ] & V _1 \ar [u ] \ar [l ] _T  }</script><p>同样,我们可以定义<strong>自伴</strong>性质:$T ^<em> = T $以及<strong>反自伴</strong>性质$T ^</em> = - T $.此处出现了复数与实数不同的地方:假设$c $是非零纯虚数,则$T $自伴当且仅当$cT $反自伴.这性质是容易验证的,也告知我们复数域上的反自伴并不需要像实数那样使用单独的辛空间来刻画.</p>
<p>类比实数,下面定理当然也是对的:</p>
<p>而注意到$T ^* T $是自伴的,然而其还有更多的好性质:</p>
<ol>
<li><p>$( \text { im  } T ) ^\bot = \ker ( T ^* ) $.</p>
</li>
<li><p>$\text { im  }  ( T ^<em> T ) = \text { im  }  ( T ^</em> ) $.</p>
</li>
<li><p>$\ker ( T ^* T ) = \ker T $.</p>
</li>
<li><p>$\text { rk  }  ( T ^<em> T ) = \text { rk  }  ( T ) = \text { rk  } ( T ^</em> ) $.</p>
</li>
</ol>
<p>证明与实数情形无差.</p>
<h4><span id="hermite形式">Hermite形式</span></h4><p>设$V $是$\mathbb { C  } $下的向量空间,$\epsilon \in \{ - 1 , 1 \} $,若半双线性形式$B : V \times V \to \mathbb { C  } $满足$B ( \vec { v  } , \vec { w  } ) = \epsilon \overline { B ( \vec { w  } , \vec { v  } )  } $的话,我们就称$B $是一个$\epsilon - $Hermite形式.如果$\epsilon = 1 $,称这是一个<strong>Hermite形式</strong>;如果$\epsilon = - 1 $,则称其为<strong>反Hermite形式</strong>.容易验证,如果$B $是Hermite的,那么$iB $是反Hermite的.</p>
<p>此定义直接导致$B $的左右根是一回事,我们后面会称其为$B $的根基.并容易见到等价于其对应的矩阵满足$A ^\dagger = \epsilon A $.也就是说,Hermite形式对应的矩阵自伴,而反Hermite形式对应的矩阵反自伴.</p>
<h5><span id="正规线性映射">正规线性映射</span></h5><p>给定某$\epsilon - $Hermite形式$B : V \times V \to \mathbb { C  } $,我们称满足$( T ^<em> ) T = T ( T ^</em> ) $的$T $是<strong>正规线性映射</strong>.容易见到自伴和反自伴当然是正规的.事实上,取$T ‘ = \frac { 1  } { 2  } ( T + T ^<em> ) , T ‘ ‘ = \frac { 1  } { 2  } ( T - T ^</em> ) $即可见到能将$T = T ‘ + T ‘ ‘ $拆成一个自伴形式和一个反自伴形式.这种分解还是唯一的,原因是如果有两组形式满足$T _1 ‘ + T _1 ‘ ‘ = T _2 ‘ + T _2 ‘ ‘ $,移项后得到$T _1 ‘ - T _2 ‘ = T _2 ‘ ‘ - T _1 ‘ ‘ $,左侧是自伴的,右侧是反自伴的,因此它们都是$0 $.</p>
<p>若进一步要求$T $是正规的,也就是$( T ^<em> ) T = T ( T ^</em> ) $,还可以见到$T ‘ T ‘ ‘ = T ‘ ‘ T ‘ $,只需简单验证即可.</p>
<h5><span id="二次型">二次型</span></h5><p>定义复数上的半双线性版本的<strong>二次型</strong>为$f ( x _1 , \cdots , x _n ) = \sum a _{ i , j  } \bar { x _i  } x _j $.要证明其与$\epsilon - $Hermite形式同构,不妨先直接考虑$f ( \vec { v  } + \vec { w  } ) = B ( \vec { v  } + \vec { w  } , \vec { v  } + \vec { w  } ) $,那只需考虑配极化技巧,定义$\Re $为提取实部,$\Im $为提取虚部,立刻得到:</p>
<script type="math/tex; mode=display">
f ( \vec { v  } + \vec { w  } ) = \begin{cases}
f ( \vec { v  } ) + f ( \vec { w  } ) + 2 \Re B ( \vec { v  } , \vec { w  } ) & \epsilon = 1 \\
f ( \vec { v  } ) + f ( \vec { w  } ) + 2 i \Im B ( \vec { v  } , \vec { w  } ) & \epsilon = - 1 
\end{cases}</script><p>考虑$\Im B ( \vec { v  } , \vec { w  } ) = \Re B ( i \vec { v  } , \vec { w  } ) $,所以上述立刻确定了$B $.</p>
<p>搬运实二次型上的性质即可看到<strong>合同</strong>在复数域上体现于$A = ( ^\dagger C ) A ‘ C $.对该多项式做对角化与实数情况无异.</p>
<p>至于复数上的<strong>惯性定理</strong>,证明与实数丝毫不差.</p>
<p>既然如此,我们下面会说明Hermite形式对应了标准内积下的自伴算子,其所有特征值均为实数.由此可以定义其<strong>正定性</strong>,当然也就是所有特征值均为正数.其余类似<strong>半正定性</strong>均可照搬原本性质.</p>
<p>于此,我们可以引出以下定理:</p>
<p>$T ^* T $是半正定的.当$T $是单射时,其是正定的.</p>
<p>证明无非仍然是$( T ^* T \vec { v  } \mid \vec { v  } ) _V = ( T \vec { v  } \mid T \vec { v  } ) _W $的直接结论.</p>
<h4><span id="复内积空间">复内积空间</span></h4><p>考虑正定Hermite形式$( _ \mid _ ) : V \times V \to \mathbb { C  } $,这样的资料$( V , ( _ \mid _ ) ) $称为<strong>复内积空间</strong>,又称作<strong>酉空间</strong>.特别地,在$\mathbb { C  } ^n $上定义标准Hermite内积为$( \vec { x  } \mid \vec { y  } ) = \sum \bar { x _i  } y _i $,应当见到其正定且是一个Hermite形式.</p>
<p>容易照搬大部分实内积空间的性质过来,这里简单列举:</p>
<ol>
<li><p>$\Vert \vec { v  } \Vert = 0 \Leftrightarrow \vec { v  } = 0 $.</p>
</li>
<li><p>$\Vert t \vec { v  } \Vert = | t | \Vert \vec { v  } \Vert ^2 $.</p>
</li>
<li><p>$\Im ( \vec { v  } _1 \mid \vec { v  } _2 ) = \Re ( i \vec { v  } _1 \mid \vec { v  } _2 ) $.</p>
</li>
<li><p>配极化,即$\Vert \vec { v  } + \vec { w  } \Vert ^2 = \Vert \vec { v  } \Vert ^2 + \Vert \vec { w  } \Vert ^2 + 2 \Re ( \vec { v  } \mid \vec { w  } ) $.</p>
</li>
<li><p>正交单位向量,正交集合,单位正交基等概念原样照搬.</p>
</li>
<li><p>勾股定理,即$\vec { v  } \bot \vec { w  } $时,$\Vert \vec { v  } + \vec { w  } \Vert ^2 = \Vert \vec { v  } \Vert ^2 + \Vert \vec { w  } \Vert ^2 $.</p>
</li>
<li><p>柯西不等式,即$| ( \vec { v  } \mid \vec { w  } ) | \leq \Vert \vec { v  } \Vert \cdot \Vert \vec { w  } \Vert $.</p>
</li>
<li><p>三角不等式,即$\Vert \vec { v  } + \vec { w  } \Vert \leq \Vert \vec { v  } \Vert + \Vert \vec { w  } \Vert $.</p>
</li>
<li><p>Gram-Schmidt正交化,策略仍是$\vec { w  } _k = \vec { v  } _k - \sum _{ i = 1  } ^{ k - 1  } \frac { ( \vec { w  } _i \mid \vec { v  } _k )  } { ( \vec { w  } _i \mid \vec { w  } _i )  } \vec { w  } _i $.</p>
</li>
</ol>
<p>(1)(2)(3)(4)(5)(6)的证明是平凡的.</p>
<p>(7)的证明与实数情景略有差别,仍设$t \in \mathbb { C  } $,并观察:</p>
<script type="math/tex; mode=display">
\begin{aligned}
0 & \leq \Vert \vec { v  } + t \vec { w  } \Vert ^2 \\
& = \Vert \vec { v  } \Vert ^2 + 2 \Re ( t ( \vec { v  } \mid \vec { w  } ) ) + | t | ^2 \Vert \vec { w  } \Vert ^2 \\
& \leq \Vert \vec { v  } \Vert ^2 + 2 | t | \cdot | ( \vec { v  } \mid \vec { w  } ) | + | t | ^2 \Vert \vec { w  } \Vert ^2 
\end{aligned}</script><p>对于(8),只需做一些微小的调整,具体为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Vert \vec { v  } + \vec { w  } \Vert ^2 & = \Vert \vec { v  } \Vert ^2 + 2 \Re ( \vec { v  } \mid \vec { w  } ) + \Vert \vec { w  } \Vert ^2 \\
& \leq \Vert \vec { v  } \Vert ^2 + 2 | ( \vec { v  } \mid \vec { w  } ) | + \Vert \vec { w  } \Vert ^2 \\
& \leq \Vert \vec { v  } \Vert ^2 + 2 \Vert \vec { v  } \Vert \cdot \Vert \vec { w  } \Vert + \Vert \vec { w  } \Vert ^2 \\
& = ( \Vert \vec { v  } \Vert + \Vert \vec { w  } \Vert ) ^2 
\end{aligned}</script><p>(9)的话,值得注意的是在左右两边对$\vec { w  } _i $做内积其实并非完全一致的.做$( \vec { w  } _i \mid _ ) $当然显然是正确的,做$( _ \mid \vec { w  } _i ) $的话,由于是Hermite形式,当然也是对的.</p>
<h5><span id="酉变换">酉变换</span></h5><p>复内积空间到自身的同构称为$V $上的<strong>酉变换</strong>.容易类比实数情况,以下命题等价:</p>
<ol>
<li><p>$T $是酉变换.</p>
</li>
<li><p>$T ^<em> = T ^{ - 1  } $,特别地,取标准内积空间时,该条等价于$T ^\dagger = T ^{ - 1  } $,如果$T $是矩阵,我们称其是<em>*酉矩阵</em></em>.</p>
</li>
<li><p>$\{ \vec { v  } _1 , \cdots , \vec { v  } _n \} $是一组单位正交基,则$\{ T \vec { v  } _1 , \cdots , T \vec { v  } _n \} $也是一组单位正交基.</p>
</li>
</ol>
<h5><span id="正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</span></h5><p>我们下面证明,只要$T $是正规算子,那它就可以酉对角化.换言之$T $如果对应矩阵$A $,那么存在酉矩阵$P $满足$P ^\dagger = P ^{ - 1  } $而且$P ^{ - 1  } AP = \begin{bmatrix}\lambda _1 &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; \lambda _n \end{bmatrix} $.容易见到其逆命题仍然成立,原因是$P ^{ - 1  } A ( A ^\dagger ) P = P ^{ - 1  } ( A ^\dagger ) AP = \begin{bmatrix}| \lambda _1 | ^2 &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; | \lambda _n | ^2 \end{bmatrix} $.</p>
<p>接下来要证明该定理正命题成立,其证明策略有若干种,下面选取两种进行说明.</p>
<p>第一种策略是,照搬实数域上的情形对空间进行数学归纳.已经可以将一个正规算子分解为$T = T ‘ + T ‘ ‘ $,其中$T ‘ $自伴而$T ‘ ‘ $反自伴.那我们可以类比实数域上对其进行归纳,从而说明$T ‘ , T ‘ ‘ $均可以对角化.又因为当$T $正规的时候,$T ‘ T ‘ ‘ = T ‘ ‘ T ‘ $,于是满足同步对角化的条件.</p>
<p>第二种策略较为麻烦,但能揭示更多正规算子的性质.假设$N \in \text { End  } ( V ) $是正规算子,我们首先证明以下引理:</p>
<ol>
<li><p>对于$f \in \mathbb { C  } [ x ] $,$f ( N ) \in \text { End  } ( V ) $也是正规的.</p>
</li>
<li><p>假设特征向量$\vec { v  } \in V $使得$\exists \lambda \in \mathbb { C  } $有$N \vec { v  } = \lambda \vec { v  } $,则$N ^* \vec { v  } = \bar { \lambda  } \vec { v  } $.</p>
</li>
<li><p>若存在$k \geq 1 $使得$N ^k = 0 $,那么$N = 0 $.</p>
</li>
<li><p>对于其任意两个不同的特征子空间$V _\lambda , V _\mu $,当$\lambda \ne \mu $的时候,$V _\lambda \bot V _\mu $.</p>
</li>
</ol>
<p>(1)的话,考虑$( \sum a _i N ^i ) ^<em> = \sum \bar { a _i  } ( N ^</em> ) ^i $,其与任意$N $的多项式都交换.</p>
<p>(2)的话不妨直接取$M = N - \lambda I $,根据(1)这当然仍是正规的.取$M ^<em> = N ^</em> - \bar { \lambda  } I $,此时注意到$\ker M $就是$V _\lambda $这个特征子空间,然而见到$\ker ( M ) = \ker ( M ^<em> M ) = \ker ( MM ^</em> ) = \ker ( M ^* ) $,这就证毕了.当然这也意味着自伴算子的特征值一定都是实数,而反自伴算子的特征值一定都是纯虚数.</p>
<p>(3)考虑到$( N ^k ) ^<em> = ( N ^</em> ) ^k $,于是$N $的任意次幂都是正规的.既然如此,考虑$N ^<em> N $当然是自伴的.要证$N = 0 $,只需证明$\text { rk  }  N = 0 $,只需证明$\text { rk  }  ( N ^</em> N ) = 0 $,也就只需要证明$N ^<em> N = 0 $即可.而如果$N ^k = 0 $,那么立刻有$( N ^</em> N ) ^k = 0 $,因此我们对$N ^* N $,也就是自伴情形证明上述结论即可.</p>
<p>于是接下来不妨假设$N $自伴,其任意次幂都自伴.考虑$k = 1 $显然成立,$k = 2 $的时候,回忆到$\forall \vec { v  } , ( N \vec { v  } \mid N \vec { v  } ) = ( N ^2 \vec { v  } \mid \vec { v  } ) = 0 $,因此立刻有$N = 0 $.</p>
<p>然后使用数学归纳,对于一般的$k &gt; 2 $,如果$k $是偶数,那$( N ^{ \frac { k  } { 2  }  } ) ^2 = N ^k = 0 $意味着$N ^{ \frac { k  } { 2  }  } = 0 $,可以数学归纳;当$k $是奇数的时候,$N ^{ k + 1  } = 0 $,而$\frac { k + 1  } { 2  } &lt; k $,因此仍然可以数学归纳.</p>
<p>(4)只需要考虑(2),立刻有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mu ( \vec { v  } \mid \vec { w  } ) & = ( \vec { v  } \mid \mu \vec { w  } ) & = ( \vec { v  } \mid N \vec { w  } ) \\
& = ( N ^* \vec { v  } \mid \vec { w  } ) & = ( \bar { \lambda  } \vec { v  } \mid \vec { w  } ) & = \lambda ( \vec { v  } \mid \vec { w  } ) 
\end{aligned}</script><p>于是完事.</p>
<p>有了以上引理,我们就可以来揭示正规算子可对角化的性质.</p>
<p>使用复数域上分裂的性质,将其特征多项式$\text { Char  } _T = \prod ( x - \mu _i ) ^{ a _i  } $.取$m = \prod ( x - \mu _i ) $,只要我们能说明$m $就是极小多项式,由于其无重根则立即完事.那就只需要验证$m ( T ) = 0 $,然而,$m ( T ) $由于(1)是正规的,又因为$m ( T ) ^{ \max a _i  } = 0 $,用(3)立刻见到$m ( T ) = 0 $,再用(4)和Gram-Schmidt法得到正交基,这就证明了该结论.</p>
<p>回忆到实数域上可正交对角化当且仅当自伴,那是因为实数域上的反自伴性质很差.而复数域上二者差别不大,想要它们能够同步对角化就需要有交换性,而正规算子恰好保证了交换性.</p>
<p>但总之,我们由上可以立即见到以下结论成立,当$T $是正规算子的时候:</p>
<ol>
<li><p>$T $自伴当且仅当所有特征值都是实数.</p>
</li>
<li><p>$T $反自伴当且仅当所有特征值都是纯虚数.</p>
</li>
<li><p>$T $是酉变换当且仅当所有特征值都满足$| \lambda | = 1 $.</p>
</li>
</ol>
<p>原因是自伴性质是$A ^\dagger = A $,反自伴性质是$A ^\dagger = - A $,酉变换性质是$A ^\dagger = A ^{ - 1  } $.而只需选取单位正交基,立刻就发现$T $对应的$A = \begin{bmatrix}\lambda _1 &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; \lambda _n \end{bmatrix} $,$T ^* $对应的$A ^\dagger = \begin{bmatrix}\bar { \lambda  } _1 &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; \bar { \lambda  } _n \end{bmatrix} $.</p>
<h5><span id="相关实内积空间定理推广">相关实内积空间定理推广</span></h5><p>我们声明以下操作在复内积空间上都能做:</p>
<ol>
<li><p>二次根:设$T \in \text { End  } ( V ) $正定(半正定),那么存在唯一的$S \in \text { End  } ( V ) $使得$S $也正定(半正定),并且$S ^2 = T $,将此$S $记作$\sqrt { T  } $.</p>
</li>
<li><p>极分解:设$T \in \text { End  } ( V ) $可逆,则存在唯一一对$R , U \in \text { End  } ( V ) $使得$R $正定,$U $是酉变换,而且$T = RU $.具体地,$R = \sqrt { TT ^*  } $.</p>
</li>
<li><p>奇异值分解:对于线性映射$T : V \to W $,存在$V , W $分别的一组正交基和唯一一组$\sigma _1 \geq \cdots \geq \sigma _p $使得$T \vec { v  } _i = \begin{cases}\sigma _i \vec { w  } _i &amp; 1 \leq i \leq p \ 0 &amp; i &gt; p \end{cases} $.或者写作$A = Q \Sigma P ^{ - 1  } $,其中$\Sigma = \begin{bmatrix}\sigma _1 &amp; \ &amp; \ddots \end{bmatrix} $.</p>
</li>
<li><p>MP广义逆:对于$T : V \to W $,存在唯一的$S : W \to V $,使得其满足从前的广义逆结论.特别地,这里的$S $实际上可以用奇异值分解唯一刻画.</p>
</li>
</ol>
<h5><span id="复矩阵范数实例">复矩阵范数实例</span></h5><p>考虑$( A , B ) \to ( A \mid B ) _{ HS  } = \text { Tr  } ( ( A ^\dagger ) B ) $,立刻使得$M _{ m \times n  } ( \mathbb { C  } ) $成为一个复内积空间.在此基础上定义<strong>Hilbert-Schmidt范数</strong>:$\Vert T \Vert _{ HS  } = \sqrt { ( T \mid T ) _{ HS  }  } $.</p>
<p>这里还可以展现$\text { Tr  } $在空间上的体现.回忆到$V $上的内积结构$\vec { v  } \mapsto ( \vec { v  } \mid _ ) $</p>
<p>另外,还可以定义所谓<strong>算子范数</strong>为$\Vert T \Vert = \max _{ \Vert \vec { v  } \Vert _V = 1  } \Vert T \vec { v  } \Vert _W $.应当容易验证:</p>
<ol>
<li><p>$\Vert tT \Vert = | t | \Vert T \Vert $.</p>
</li>
<li><p>$\Vert T _1 + T _2 \Vert \leq \Vert T _1 \Vert + \Vert T _2 \Vert $.</p>
</li>
<li><p>$\Vert T \Vert = 0 \Leftrightarrow T = 0 $.</p>
</li>
<li><p>$\Vert ST \Vert \leq \Vert S \Vert \cdot \Vert T \Vert $.</p>
</li>
<li><p>$\Vert I \Vert = 1 $.</p>
</li>
</ol>
<p>只需回忆极小化极大原理就知道$\Vert T \Vert ^2 $取到了$T ^<em> T $的模长最大的特征值,而$\Vert T \Vert _{ HS  } ^2 $取到了$T ^</em> T $的特征值之和,考虑$T : V \to W $,见到:</p>
<script type="math/tex; mode=display">
\frac { 1  } { \sqrt { \dim V  }  } \Vert T \Vert _{ HS  } \leq \Vert T \Vert \leq \Vert T \Vert _{ HS  }</script><p>综上,就可以定义两种距离,容易验证它们的若干性质.</p>
<p>因此容易见到上面两种范数有互相等价的收敛性和极限概念,柯西列的概念也是等价的.</p>
<h3><span id="模">模</span></h3><p>考虑将线性空间的定义从域挪到环上,对于一个环$R $,定义<strong>左模</strong>为一个资料$M $,其中$M $自带一个加法群(需要可交换)而其还有一个对环的左乘$R \times M \to M $使得$\forall x \in M , r _1 , r _2 \in R $,以下性质成立:</p>
<ol>
<li><p>$r ( x + y ) = rx + ry $.</p>
</li>
<li><p>$( r _1 + r _2 ) x = r _1 x + r _2 x $.</p>
</li>
<li><p>$( r _1 r _2 ) x = r _1 ( r _2 x ) $.</p>
</li>
<li><p>$1 _R x = x $.</p>
</li>
</ol>
<p>同理可以定义<strong>右模</strong>.这里可能又需要定义相反环$R ^{ op  } $,相当于把乘法顺序调转.当$R $是交换环的时候,$R = R ^{ op  } $,此时左模和右模无差别.下面无特殊说明默认为左模.</p>
<p>容易见到线性空间是模的特例.</p>
<p>还可以定义两个都定义在$R $上的模$M _1 , M _2 $之间的同态$f : M _1 \to M _2 $满足:</p>
<ol>
<li><p>$f ( rx ) = rf ( x ) $.</p>
</li>
<li><p>$f ( x _1 + x _2 ) = f ( x _1 ) + f ( x _2 ) $.</p>
</li>
</ol>
<p>容易见到$( f _1 + f _2 ) ( x ) = f _1 ( x ) + f _2 ( x ) $成立并且$( f _1 + f _2 ) $当然也是同态,然而$( rf ) ( x ) = rf ( x ) $并不一定是同态,原因是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
rf ( r ' x ) & = rf ( r ' x ) & = rr ' f ( x ) \\
\ne r ' rf ( x ) & = r ' ( rf ) ( x ) 
\end{aligned}</script><p>因此并不一定能把里面的$r ‘ $提到外面来,这就出问题了.模的同态集合并非是模.然而同态对复合操作总是构成幺半群,容易见到:</p>
<ol>
<li><p>$( f _1 + f _2 ) \circ g = ( f _1 \circ g ) + ( f _2 \circ g ) $.</p>
</li>
<li><p>$f \circ ( g _1 + g _2 ) = ( f \circ g _1 ) + ( f \circ g _2 ) $.</p>
</li>
</ol>
<p>那也可以定义同构,就是存在逆映射.还可以定义子模.容易见到任何一组子模的交仍然是子模.</p>
<p>还可以定义商模.假设$N $是$M $的子模,在加法群意义下存在一个商群$M / N $(原因是此加法群可交换),现在我们想将其升级为$R $的模.我们定义:$R \times ( M / N ) \to ( M / N ) : ( r , x + N ) \mapsto rx + N $作为模上的标量乘法,我们试图证明:</p>
<ol>
<li><p>此运算使得$M / N $成为模.</p>
</li>
<li><p>$q : M \to M / N $构成模同态,而且$\ker q = N $.</p>
</li>
</ol>
<p>(1)只需要简单检验即可(由于$N $对于标量乘法封闭显然).</p>
<p>(2)则是由于$q $本身已经是加法群的同态,又有$q ( rx ) = rx + N = rq ( x ) $,这就搞定.</p>
<p>然后定义直积,考虑一组定义在$R $上的模$( M _i ) _{ i \in I  } $,考虑它们本身都是一个加法群,因此先用加法群的定义拿到$\prod _i M _i $,然后将它升级为一个$R $模,方法是$( r , ( x _i ) _{ i \in I  } ) \mapsto ( rx _i ) _{ i \in I  } $.同理把其至多有限多个分量非零的子集定义为直和.内直和亦然同理.设$( M _i ) _{ i \in I  } $是$M $的一组子模,以下命题等价:</p>
<ol>
<li><p>$\sum _{ i \in I  } M _i = M $,而且$\forall i \in I , M _i \cap \sum _{ j \ne i  } M _j = \{ 0 \} $.</p>
</li>
<li><p>$\forall x \in M $都能唯一写作$x = \sum _{ i \in I  } x _i $的形式.</p>
</li>
<li><p>$\sigma : \bigoplus _{ i \in I  } M _i \cong M $.</p>
</li>
</ol>
<p>验证上述命题是简单的.</p>
<p>最后,如果存在一个$M $的子集$S $使得$M = \langle S \rangle $,我们称$M $是<strong>有限生成</strong>的.</p>
<h4><span id="自由模">自由模</span></h4><p>设$X $为集合,其上的<strong>自由模</strong>定义为直和$R ^{ \oplus X  } $,可以自然地将$X $嵌入$R ^{ \oplus X  } $,只需将$x \mapsto ( r _y ) $,其中$r _y = \begin{cases}1 &amp; x = y \ 0 &amp; x \ne y \end{cases} $.</p>
<p>对于任何一个$R $上的模$N $,我们可以将$\mathrm { Hom  } _R ( R ^{ \oplus X  } , N ) $与$X \to N $的映射一一对应.从前者对应到后者只需将映射限制在$X $上即可(上述已经给出将$X $嵌入其中的策略),从后者到前者的对应只需逐分量映射亦可.</p>
<p>既然$X $可以如上嵌入$R ^{ \oplus X  } $,能否找到一个$R $上的模$M $,使得干脆使得$X \subseteq M $并且$M \cong R ^{ \oplus X  } $呢.其实这里可以生添一个定义,假设$X \subseteq M $并且$M $已经是$R $模,以下命题等价:</p>
<ol>
<li><p>$X $生成$M $而且线性无关.</p>
</li>
<li><p>每个$m \in M $都能唯一表示成有限和$m = \sum _{ x \in X  } r _x x $.</p>
</li>
<li><p>$\varphi : R ^{ \oplus X  } \cong M $是同构.</p>
</li>
</ol>
<p>的确容易见到上面命题等价.此时称模$M $是以$X $为<strong>基</strong>的自由模.从而见到所有的向量空间其实都是自由模.并且只要我能找到一个模的一组基,那这个模自然成为了自由模.当然也存在非自由模,Example1给出了一个很平凡的非自由模实例.</p>
<p>回忆到线性空间上的基的定义,事实上当$R $是交换环的时候,它的任意两组基$X , Y $都满足$| X | = | Y | $,从而自然地引出其<strong>秩</strong>为$\mathrm { rk  } ( M ) = | X | $的定义.然而这个证明有点艰难,因此我们尝试去证明一个弱些的版本:整环上的有限生成自由模.</p>
<p>此时对于一组基$X $,则$M \cong R ^{ \oplus X  } $.注意到如果$| X | = \infty $,则$R ^{ \oplus X  } $必然不是有限生成的.因此有限生成自由模的基一定满足$| X | &lt; \infty $.</p>
<p>而之后的做法只需将$R $通过分式域$\mathrm { Frac  } ( R ) $嵌入进向量空间就可以了.</p>
<p>我们还想要像线性空间一样,将$\mathrm { Hom  } _R ( R ^n , R ^m ) \cong M _{ m \times n  } ( R ) $,这里取右模是方便的(因为需要标量乘法),也就是:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x _1 \\
\vdots \\
x _n 
\end{bmatrix} \mapsto A \begin{bmatrix}
x _1 \\
\vdots \\
x _n 
\end{bmatrix}</script><p>用右模的好处是标量乘法可以看作$1 \times 1 $的矩阵乘法:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x _1 t \\
\vdots \\
x _n t 
\end{bmatrix} \mapsto A \begin{bmatrix}
x _1 t \\
\vdots \\
x _n t 
\end{bmatrix} = A \begin{bmatrix}
x _1 \\
\vdots \\
x _n 
\end{bmatrix} t</script><p>至于证明只需要化到基上即可.</p>
<h6><span id="example1非自由模">Example1(非自由模)</span></h6><p>取$R = \mathbb { Z  } , M = \mathbb { Z  } / n \mathbb { Z  } $,其中$n \ne 0 , \pm 1 $.此时立刻见到$M $必定不是自由的,因为不存在一个$X $使得$M \cong \mathbb { Z  } ^{ \oplus X  } $,原因是左侧是有限的$n $个元素,而右侧要么是单个元素,要么是无穷多元素.</p>
<h4><span id="线性映射和模结构">线性映射和模结构</span></h4><p>回忆到$F [ x ] $是一个自然的$F $向量空间.我们的问题是如若$V $是$F $上的向量空间,能否将其升级为一个$F [ x ] $上的模.</p>
<p>我们先指定一个$V $上的线性变换$T \in \mathrm { End  } ( V ) $,考虑$\forall f \in F [ x ] $,$f ( T ) \in \mathrm { End  } ( V ) $,直接将其作用在$V $上就得到了一个$F [ x ] $上的模.换言之就是将$x \cdot v \mapsto T ( v ) $.我们现在想要证明所有可以使得$V $升级为$F [ x ] $模的办法,均可以转化为指定一个映射$T \in \mathrm { End  } ( V ) $.</p>
<p>对此进行说明,将$F $上的向量空间$V $升级为$F [ x ] $上的模等价于说对所有$f \in F [ x ] $指定对应于纯量乘法的映射$\rho _f : V \to V $,使得:</p>
<ol>
<li><p>$\rho _f ( v _1 + v _2 ) = \rho _f ( v _1 ) + \rho _f ( v _2 ) $.</p>
</li>
<li><p>$\rho _{ f + g  } ( v ) = \rho _f ( v ) + \rho _g ( v ) $.</p>
</li>
<li><p>$\rho _{ fg  } ( v ) = \rho _f ( \rho _g ( v ) ) $.</p>
</li>
<li><p>当$c \in F $的时候,应该有$\rho _c ( v ) = cv $,以保证原本的向量空间结构.</p>
</li>
</ol>
<p>容易检验当我们指定映射$T $后的确能使其升级为$F [ x ] $上的模.下面我们说明将$V $升级为$F [ x ] $上的模的过程一定对应了一个映射$T \in \mathrm { End  } $.</p>
<p>假设$V $已经升级为$F [ x ] $模,那么考虑证明$\rho _x $必须是个线性变换即可.而由上面我们说的,$\rho _x ( v _1 + v _2 ) = \rho _x ( v _1 ) + \rho _x ( v _2 ) $,并且有$\rho _x ( cv ) = \rho _{ xc  } ( v ) = c \rho _x ( v ) $,这就搞定了.</p>
<p>而如果考虑模之间的映射$\varphi : V \to V ‘ $,则$\varphi $是模同态等价于:</p>
<ol>
<li><p>$\varphi ( c _1 v _1 + c _2 v _2 ) = c _1 \varphi ( v _1 ) + c _2 \varphi ( v _2 ) $.</p>
</li>
<li><p>$\varphi f ( T ) = f ( T ‘ ) \varphi $.</p>
</li>
</ol>
<p>(1)使得$\varphi $必须为一个线性映射,既然如此(2)中就可以拆开$f ( T ) $,也就变成了要求$\forall n \geq 0 $,都有$( T ‘ ) ^n \circ \varphi = \varphi \circ T ^n $.容易见到只需满足$T ‘ \varphi = \varphi T $即可数学归纳满足上面的性质.乍一看可能觉得这个等式比较奇怪,但我们可以将其写作交换图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^\varphi \ar [d ] _T & V ' \ar [d ] ^{ T '  } \\
V \ar [r ] _\varphi & V ' \\
 }</script><p>如果$\varphi $是同构,那这当然等价于$T ‘ = \varphi T \varphi ^{ - 1  } $.</p>
<p>我们现在想要做一些更深的操作,能不能干脆对所有$F [ x ] $上的模结构$( V , T ) $进行分类呢?不妨设$\dim _F V = n &lt; \infty $,既然如此就有$V \cong F ^n $.既然如此指定$T $无非是指定矩阵$F ^{ n \times n  } $,因此在同构意义下分类$F [ x ] $上的模结构等价于分类共轭的$n \times n $的矩阵.换言之分类共轭的$n \times n $的矩阵也就相当于同构意义下分类$F [ x ] $上的模结构.回忆到$F [ x ] $是PID(主理想环),而$\dim V &lt; \infty $导出$V $是有限生成的.</p>
<h4><span id="主理想环上的有限生成模">主理想环上的有限生成模</span></h4><p>考虑$R $是一个交换环,$I \subseteq R $是一个理想,考虑一个$R $上的模$M $,现在考虑定义$M [ I ] = \{ x \in M | \forall a \in I , ax = 0 \} $为$I $所零化的子模(容易检验封闭性).当$I = ( h ) = \{ hr | r \in R \} $的时候,我们记作$M [ I ] = M [ h ] $,原因是显然此时只需要$h $零化即可.进一步地,留意到$M [ I ] = \bigcap _{ h \in I  } M [ h ] $.</p>
<p>考虑当$R $是整环的时候,如果$x \in M , \exists h \in R \setminus \{ 0 \} , x \in M [ h ] $,我们称$x $是一个<strong>挠元</strong>.容易见到自由模无挠.</p>
<p>接下来考虑所有挠元组成的集合称为<strong>挠子模</strong>$M _{ tors  } $,我们下面来证明它是一个子模.</p>
<p>如若$x , y \in M _{ tors  } $,则存在$r , s \in R \setminus \{ 0 \} $,$rx = sy = 0 $,由于此时我们在看整环,所以$rs \ne 0 $.留神到:$rs ( ax + by ) = 0 , \forall a , b \in R $.于是就拿到了封闭性.</p>
<p>定义<strong>无挠商</strong>为$M _{ tf  } = M / M _{ tors  } $.下面我们来证明其中的确没有挠元.</p>
<p>考虑$\bar { x  } \in M _{ tf  } , \bar { x  } = x + M _{ tors  } $.如若$\exists r \in R \setminus \{ 0 \} $使得$r \bar { x  } = 0 $,意味着$rx + M _{ tors  } = M _{ tors  } $,这意味着$rx \in M _{ tors  } $,既如此则$\exists s \in R \setminus \{ 0 \} $使得$s ( rx ) = ( sr ) x = 0 \Rightarrow x \in M _{ tors  } $,所以我们这个的确是无挠的.</p>
<p>接下来看$R $是PID的情形,此时考虑任何一个$t $都可以被分解为$t \sim p _1 ^{ a _1  } \cdots p _m ^{ a _m  } , a _i \geq 0 $.我们下面来证明此时$M [ t ] = \bigoplus _{ i = 1  } ^m M [ p _i ^{ a _i  } ] $.</p>
<p>其实只需要证明$t = ab $,其中$a , b $互素就可以推出$M [ t ] = M [ a ] \oplus M [ b ] $就行了对吧.和我们之前证明极小多项式的结论时的策略完全一致:</p>
<p>先证明$M [ t ] = M [ a ] + M [ b ] $,考虑$x \in M [ t ] $,留意到存在$u , v $使得$au + bv = 1 $,所以$\forall x \in t $,$x = aux + bvx \in M [ b ] + M [ a ] $.</p>
<p>在证明$M [ a ] \cap M [ b ] = \{ 0 \} $,设$x \in M [ a ] \cap M [ b ] $,则$x = aux + bvx = 0 $.</p>
<p>接下来我们证明$M [ a ] \cap M [ b ] = M [ \gcd ( a , b ) ] $.裴蜀定理告诉我们存在一对$u , v $使得$\gcd ( a , b ) = au + bv $,因此$M [ \gcd ( a , b ) ] \supseteq M [ a ] \cap M [ b ] $,反之如若$x \in M [ \gcd ( a , b ) ] $,则$x \in M [ a ] , x \in M [ b ] $,这就搞定了.</p>
<p>接下来考虑$p $是PID里的一个素元,容易见到$M [ p ] \subseteq M [ p ^2 ] \cdots $,定义$M [ p ^\infty ] = \bigcup _{ i \geq 1  } M [ p ^i ] $.如果$\exists t \in R , t \ne 0 , M = M [ t ] $.此时考虑对$t $作分解,应该得到$M = \oplus M [ p _i ^{ a _i  } ] $.事实上此时我们可以直接说$M = \oplus _{ p  } M [ p ^\infty ] $,原因是考虑当$n \geq p ^{ a _p  } $时候,有$M [ p ^n ] = M [ p ^n ] \cap M [ t ] = M [ p ^{ a _p  } ] $.</p>
<p>下面干脆假设$M = R / ( t ) $,$p $是$R $中的素元,我们有以下结论:</p>
<ol>
<li><p>如果$p ^a | t $,则$( R / ( t ) ) [ p ^a ] \cong R / ( p ^a ) $.</p>
</li>
<li><p>如果$p ^a | t , p ^{ a + 1  } \nmid t $,则$( R / ( t ) ) [ p ^\infty ] \cong R / ( p ^a ) $.</p>
</li>
</ol>
<p>对于(1),如若$p ^a | t $,考虑$\bar { x  } = x + ( t ) \in R / ( t ) $,如若满足$p ^a \bar { x  } = 0 \Leftrightarrow \exists y , p ^a x = ty $,此时取$s = \frac { t  } { p ^a  } $,于是上述条件立刻等价于$x \in ( s ) $.所以$( R / ( t ) ) [ p ^a ] = ( s ) / ( t ) $.然而我们有一个满射$R \to ( s ) / ( t ) : y \mapsto sy + ( t ) $,观察其$\ker = \{ y \in R : t | sy \} = ( p ^a ) $,由同态定理知道$( R / ( t ) ) [ p ^a ] \cong R / ( p ^a ) $.</p>
<p>对于(2),我们已经说过了$M [ p ^\infty ] = M [ p ^a ] $,于是由(1)就做完了.</p>
<h5><span id="自由模与其子模">自由模与其子模</span></h5><p>回忆到Noether性质:任何一个理想链最终都会稳定.那同理可以定义一个$R $上的模$M $是有Noether性质的,当它的任何一个子模链都会趋于稳定.回忆到如果$R $是一个PID,则它当然有Noether性质,同时它作为自己的模也具有Noether性质(它的子模其实就是子理想).</p>
<p>下面我们来证明,如果一个模$M $具有Noether性质,那它是有限生成的.</p>
<p>证明非常简单,考虑反证,如果其不是有限生成的,那我们考虑任意$x _1 $,$Rx _1 $不能生成$M $,取$x _2 \in M \setminus ( Rx _1 ) $,则$Rx _1 + Rx _2 $也不能生成$M $,以此类推,这就得到了一个无穷增大的子模链,不符合Noether性质.</p>
<p>接下来引入一个引理:设$R $是一个交换环,$M $是$R $上的一个模,而且$M ‘ $是$M $的一个子模,如果$M ‘ ‘ = M / M ‘ $,那么$M $有Noether性质等价于$M ‘ $和$M ‘ ‘ $都有Noether性质.</p>
<p>先来看必要性,假设$M $有Noether性质,则其子模$M ‘ $的子模列当然也是$M $中的子模列,所以$M ‘ $必定有Noether性质.而反之$M ‘ ‘ $中的子模列当然可以取原像回到$M $中,必定也是Noetherian的.</p>
<p>再来看充分性,考虑$M $中的一列子模$M _1 \subseteq M _2 \subseteq \cdots $.取$M _i ‘ = M _i \cap M ‘ $,$M _i ‘ ‘ = ( M _i + M ‘ ) / M ‘ $.它们当然分别是$M ‘ $和$M ‘ ‘ $中的子模列,所以存在一个$i _0 , \forall i \geq i _0 $,$M _i ‘ = M _{ i + 1  } ‘ , M _i ‘ ‘ = M _{ i + 1  } ‘ ‘ $.下面我们试图证明当$i \geq i _0 $的时候此时也有$M _i = M _{ i + 1  } $,这只需证明$M _i \supseteq M _{ i + 1  } $.</p>
<p>考虑$\forall x \in M _{ i + 1  } , x + M ‘ \in M _{ i + 1  } ‘ ‘ = M _i ‘ ‘ $,从而我们知道一定存在一个$y \in M _i $使得$x + M ‘ = y + M ‘ $,意味着$x - y \in M ‘ $,而$x \in M _{ i  } \subseteq M _{ i + 1  } $,所以$x - y \in M ‘ \cap M _{ i + 1  } = M _{ i + 1  } ‘ = M _i ‘ \subseteq M _i $,由于$y \in M _i $,自然导出$x \in M _i $.从而证毕.</p>
<p>其实用第二同构定理见到$M _i ‘ ‘ \cong M _i / M _i ‘ $也就搞定了.</p>
<p>现在我们有了如上引理,我们可以得知以下推论:</p>
<ol>
<li><p>如果$M _1 , M _2 $都是Noether模,则$M _1 \oplus M _2 $也是Noether模.</p>
</li>
<li><p>作为(1)的推论,如果$R $是一个PID,$E $是一个$R $上的自由模,如果$E $是有限生成的,则$E $是Noether模.</p>
</li>
<li><p>作为(2)的推论,有限生成自由模的子模总是有限生成的.</p>
</li>
</ol>
<h5><span id="smith标准型">Smith标准型</span></h5><p>最后要做的是在模上引入矩阵符号,对于交换环$R $上的模$M $,假设$e _1 , \cdots , e _n \in M $且$x _1 , \cdots , x _m \in M $,取矩阵$A \in M _{ n \times m  } ( R ) $,此时记$( x _1 , \cdots , x _m ) = ( e _1 , \cdots , e _n ) A $,当且仅当$x _j = \sum _{ i = 1  } ^n e _i a _{ i , j  } $.容易检查以下结论:</p>
<ol>
<li><p>$( e _1 , \cdots , e _n ) AB = ( e _1 , \cdots , e _n ) ( AB ) $.</p>
</li>
<li><p>$( e _1 , \cdots , e _n ) I = ( e _1 , \cdots , e _n ) $.</p>
</li>
<li><p>如果$e _1 , \cdots , e _n $线性无关,则$A $若存在则唯一确定.</p>
</li>
</ol>
<p>同时Cramer法则告诉我们,当$\det A \in R ^\times $的时候,$A $一定存在逆矩阵$B $使得$AB = BA = I $,这也很显然是$A $存在逆矩阵的充要条件,因为$\det B = \frac { 1  } { \det A  } $.还可以检查如下结论:</p>
<ol>
<li><p>如果$( y _1 ‘ , \cdots , y _n ‘ ) = ( y _1 , \cdots , y _n ) P $,其中$P $可逆,则$\sum Ry _i = \sum R y _i ‘ $.</p>
</li>
<li><p>设$( e _1 , \cdots , e _n ) $为基,则$( e _1 ‘ , \cdots , e _n ‘ ) = ( e _1 , \cdots , e _n ) A $是另一组基,当且仅当$A $可逆.</p>
</li>
</ol>
<p>现在考虑自由模$E $,其基为$e _1 , \cdots , e _n $,其有一个子模$N $,可以被$x _1 , \cdots , x _m $生成.考虑取一个唯一的矩阵$A $满足$( x _1 , \cdots , x _m ) = ( e _1 , \cdots , e _m ) A $,此时发现如果将$A $换成$AP $,其中$P $是一个可逆矩阵,则$( x _1 , \cdots , x _m ) $会被改变.如果将$A $换成$QA $,则$( e _1 , \cdots , e _n ) $会被改变.</p>
<p>由此我们有<strong>Smith标准型</strong>:当$R $是PID的时候,对于矩阵$A \in M _{ n \times m  } $,总存在两个可逆矩阵$P , Q $,使得$d _1 | d _2 | \cdots \in R $使得$A = Q \begin{bmatrix}d _1 &amp; &amp; \ &amp; d _2 &amp; \ &amp; &amp; \ddots \end{bmatrix} P $.</p>
<p>上述结论对欧几里得整环是平凡结论,而且还可以计算.</p>
<p>那么对于PID怎么办呢?难点当然在于现在我们没有办法任意做欧几里得算法了,也许唯一的工具只有裴蜀定理.</p>
<p>考虑数学归纳,如果$A = 0 $那当然已经搞定了对吧,否则我们总可以做点初等变换使得$A $的左上角元素不为$0 $.</p>
<p>现在假设第一列第一行元素为$a \ne 0 $,第一列第二行元素为$b \ne 0 $,取$d = \gcd ( a , b ) , u = - \frac { b  } { d  } , v = \frac { a  } { d  } $,用裴蜀定理拿到$sa + tb = d $,然后用下述矩阵左乘:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
s & t & & & \\
u & v & & & \\
& & 1 & & \\
& & & \ddots & \\
& & & & 1 
\end{bmatrix}</script><p>就可以让第一列第二行的元素变成$0 $.不断做此过程,矩阵变为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
d _1 ' & \\
& A _1 
\end{bmatrix}</script><p>其中$d _1 ‘ $是$A $的第一行第一列所有元素的$\gcd $,继续做此操作得到:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
d _1 ' & & \\
& d _2 ' & \\
& & A _1 
\end{bmatrix}</script><p>如果$d _1 ‘ \nmid d _2 ‘ $,那我们就把第二列加到第一列上,然后重复以上操作,从而使得左上角变成$\gcd ( d _1 ‘ , d _2 ‘ ) $.这样我们就搞定了.</p>
<h5><span id="结构定理">结构定理</span></h5><p>扔出一个<strong>结构定理</strong>:$R $是一个PID,$M $是一个$R $模,我们都可以将$M $拆成:</p>
<script type="math/tex; mode=display">
M \cong ( R / I _1 ) \oplus \cdots \oplus ( R / I _k ) \oplus E</script><p>其中$I _1 \supseteq \cdots \supseteq I _k \ne \{ 0 \} $是$R $上的一列真理想,而$E $是一个$R $上的自由模.</p>
<p>并且上述拆法是有唯一性的,也就是如果还存在另一组拆法:</p>
<script type="math/tex; mode=display">
M \cong ( R / J _1 ) \oplus \cdots \oplus ( R / J _{ k '  } ) \oplus E '</script><p>则$k = k ‘ , I _1 = J _1 , \cdots , I _k = J _{ k ‘  } , E \cong E ‘ $.</p>
<p>回忆到$E $既然是整环上的有限生成自由模,那它可以同构于$R ^{ rk ( E )  } $.因此我们可以在上述一列理想后面补$\mathrm { rk  } ( E ) $个$\{ 0 \} $.这样就可以简写作:</p>
<script type="math/tex; mode=display">
M \cong ( R / I _1 ) \oplus \cdots \oplus ( R / I _k )</script><p>这组$I _1 \supseteq \cdots \supseteq I _k \supseteq \{ 0 \} \cdots $被称为$M $的一组<strong>不变因子</strong>.</p>
<p>此时我们回忆到PID中的自由模不能有挠元,而前面商掉的部分全是挠元,因此结构定理会给出$( R / I _1 ) \oplus \cdots \oplus ( R / I _k ) \cong M _{ tors  } = M [ I _k ] = M [ f _k ] $.</p>
<p>其实这也可以写成结构定理的第二种形式:</p>
<script type="math/tex; mode=display">
M _{ tors  } \cong \bigoplus _p M _{ tors  } [ p ^\infty ] \cong \bigoplus _{ p | f _k , p \in \mathrm { prime  }  } \bigoplus _i R / ( p ^{ b _i ( p )  } )</script><p>其中$\forall p , 0 \leq b _1 ( p ) \leq \cdots \leq b _k ( p ) $.我们将这一列称为<strong>初等因子</strong>.</p>
<p>现在我们着手证明结构定理,首先给出如下引理:</p>
<p>设$E $为主理想环$R $上的自由模,秩为$n $,而$N $是其子模,我们下面证明存在$E $的一组基$f _1 , \cdots , f _n $以及$R $的一列元素$d _1 | \cdots | d _n $,令$r = \max \{ i | d _i \ne 0 \} $,则$d _1 f _1 , \cdots , d _r f _r $构成$N $的基.</p>
<p>回忆到自由模的子模一定是有限生成的而且秩不超过$n $,此时取$x _1 , \cdots , x _m $是$N $的一组生成元,则存在一个唯一的$A $使得$( x _1 , \cdots , x _m ) = ( e _1 , \cdots , e _n ) A $,由Smith标准型,式子变成:</p>
<script type="math/tex; mode=display">
( x _1 , \cdots , x _m ) P ^{ - 1  } = ( e _1 , \cdots , e _n ) Q \begin{bmatrix}
d _1 & & \\
& d _2 & \\
& & \ddots 
\end{bmatrix}</script><p>此时观察左侧的确给出了一组$N $的一组生成元,而右侧的$( e _1 , \cdots , e _n ) Q $给出了另一组基$( f _1 , \cdots , f _n ) $.这就完事了.</p>
<p>此时我们有了如上引理,来证明结构定理的存在性.对于有限生成模$M $,由定义知道存在一组元素$\langle x _1 , \cdots , x _n \rangle = M $.既然如此考虑取$E = R ^{ \otimes n  } $,考虑模同态$E \to M , ( r _i ) _{ i = 1  } ^n \mapsto \sum _{ i = 1  } ^n r _i x _i $,容易见到这显然是个满同态,因此取其$\ker = N $,自然有$M \cong E / N $.根据引理,可以拿到$N $的一组基$d _1 f _1 , \cdots , d _r f _r $,此时见到:</p>
<script type="math/tex; mode=display">
M \cong \cfrac { Rf _1 \oplus \cdots \oplus R f _n  } { Rd _1 f _1 \oplus \cdots Rd _r f _r  }</script><p>然而对于单个的$f _n $来说,自然有$Rf _n \cong R $,而且如果$N _1 $是$M _1 $的子模,$N _2 $是$M _2 $的子模,并且$M _1 \cap M _2 = \{ 0 \} $,容易检验$( M _1 \oplus M _2 ) / ( N _1 \oplus N _2 ) \cong ( M _1 / N _1 ) \oplus ( M _2 / N _2 ) $,而$( Rf _i ) / ( Rd _i f _i ) \cong R / ( d _i ) $,这就搞定了存在性的部分.</p>
<p>接下来来证明唯一性,假设:</p>
<script type="math/tex; mode=display">
M \cong ( R / I _1 ) \oplus \cdots \oplus ( R / I _k ) \oplus E \cong ( R / J _1 ) \oplus \cdots \oplus ( R / J _{ k '  } ) \oplus E '</script><p>然而我们已经知道$E \cong M _{ tf  } $而且$E ‘ \cong M _{ tf  } $,因此有$E \cong E ‘ $.因此我们将问题化约到没有自由部分的特例.于此使用初等因子形式的证明,考虑$M [ p ^\infty ] $自然是其中所有的$R / ( p ^j ) $结构,因此必然只涉及它们的部分会同构,此时化约到已知为:</p>
<script type="math/tex; mode=display">
R / ( p ^{ b _1  } ) \oplus \cdots \oplus R / ( p ^{ b _k  } ) \cong R / ( p ^{ b _1 '  } ) \oplus \cdots \oplus R / ( p ^{ b _{ k '  } '  } )</script><p>为证明这些项对应相同,需要将这些东西等同于某种空间上的结构,我们先来着手证明$k = k ‘ $.回忆到$M [ p ] = \bigoplus _{ i  } ( R / ( p ^{ b _i  } ) ) [ p ] = \bigoplus _{ i  } R / ( p ) $,此时见到$M [ p ] $实际上也可以表示为$R / ( p ) $上的向量空间(回忆到主理想环商掉素理想后得到了一个域),而且$\dim _{ R / ( p )  } M [ p ] = k $,因此必然有$k = k ‘ $.</p>
<p>类似上面,考虑对于一个固定的$a \geq 1 $,考察$p ^c M = \bigoplus _{ i , b _i &gt; c  } p ^c R / p ^{ b _i  } R = \bigoplus _{ i , b _i &gt; c  } R / p ^{ b _i - c  } R $,此时观察$( p ^c M ) [ p ] $,它的维度就是满足$b _i &gt; c $的$i $的个数,即可继续见到两遍逐个相同.</p>
<h5><span id="有限生成交换群的分类">有限生成交换群的分类</span></h5><p>我们先将交换群$A $等同于$\mathbb { Z  } $上的模.下述用加法群,则上面有自然的倍数运算$\mathbb { Z  } \times A \to A : na \mapsto a + a + \cdots + a $.因此交换群立刻等价于$\mathbb { Z  } $模.</p>
<p>然而模上的结构定理立刻给出:</p>
<script type="math/tex; mode=display">
A \cong \mathbb { Z  } / d _1 \mathbb { Z  } \oplus \cdots \oplus \mathbb { Z  } / d _k \mathbb { Z  } \oplus \mathbb { Z  } ^{ \oplus m  }</script><p>其中$d _1 | \cdots | d _k $,这就搞定.</p>
<h4><span id="有理标准型">有理标准型</span></h4><p>取定$R = F [ x ] $,我们可以将一个真理想写作$I _i = ( f _i ) $,其中$f _i \in F [ x ] \setminus F $,并且如果进一步要求其首项为一则$f _i $唯一.</p>
<p>现在来看对于一个固定的多项式$f $,此时$F [ x ] / ( f ) $必然也是一个$F [ x ] $模,那在上面的$x $必然也对应了一个矩阵,设$\deg f = n , f = x ^n + c _{ n - 1  } x ^{ n - 1  } + \cdots + c _0 $,取其有序基为$\{ 1 + ( f ) , x + ( f ) , \cdots , x ^{ n - 1  } + ( f ) \} $.容易见到$x $对应的矩阵应该形如:</p>
<script type="math/tex; mode=display">
C _f = \begin{bmatrix}
0 & 0 & \cdots & 0 & - c _0 \\
1 & 0 & \cdots & 0 & - c _1 \\
0 & 1 & \cdots & 0 & - c _2 \\
\vdots & & \ddots & & \vdots \\
0 & 0 & \cdots & 1 & - c _{ n - 1  } \\

\end{bmatrix}</script><p>这个被称为<strong>友矩阵</strong>.按照最后一列展开见到其特征多项式就是$f $.</p>
<p>结构定理告诉我们,对于上述的一个模(我们之前说过可以唯一对应一个矩阵$A $),可以找到唯一的一组首项为一的多项式$f _1 | \cdots | f _k , k \geq 1 $,其中$\sum \deg f _i = n $,则$A $可以对应于它们所对应的友矩阵所构成的分块对角矩阵,称为<strong>有理标准型</strong>.</p>
<p>上述的具体细节是次数相关的讨论.对于$A $对应的$F [ x ] $上的模$M $,我们之前已经用结构定理搞定说:</p>
<script type="math/tex; mode=display">
M \cong F [ x ] / ( f _1 ) \oplus \cdots \oplus F [ x ] / ( f _k ) \oplus E</script><p>然而回忆到$\dim _F M = n , \dim _F F [ x ] = + \infty $,所以必然有$E = \{ 0 \} $.既然如此$\sum \dim _F ( F [ x ] / ( f _i ) ) = \sum \deg f _i = n $.</p>
<p>有理标准型的强大之处在于蕴含了我们之前讲过的很多事情,并且给出了更加简单的描述:我们下面证明:</p>
<ol>
<li><p>极小多项式有$\mathrm { Min  } _A = f _k $.</p>
</li>
<li><p>特征多项式有$\mathrm { Char  } _A = \prod _{ i = 1  } ^k f _i $.</p>
</li>
</ol>
<p>先证明(1):如果多项式$h $满足$h ( A ) = 0 $,由于我们此时已经将$A $的作用等价于$x $的作用,因此$h ( x ) $必然作用于每个商模上都是$0 $,那就必然意味着$\forall i , f _i | h \Leftrightarrow f _k | h $.</p>
<p>再证明(2):首先我们知道友矩阵的特征多项式满足$\mathrm { Char  } _{ C _f  } = f $,此时发现证完了,因为直和直接就是每一分模的特征多项式乘积.</p>
<p>回忆到结构定理存在第二种表示方法,我们考虑将$\mathrm { Min  } _A = f _k = p _1 ^{ a _1  } \cdots p _k ^{ a _k  } $,那我们就可以将$A $同构于若干分块对角矩阵$A _1 , \cdots , A _m $组成的分块对角矩阵,其中每一个$A _i $亦然可以分解为若干友矩阵$C _{ p _j ^{ b  }  } $之类的东西.</p>
<p>接下来看如何计算一个有理标准型,考虑$V $是一个$F $向量空间,而$T \in \mathrm { End  } ( V ) $,从而使得$V $从一个$F $向量空间升级为一个$F [ x ] $模.</p>
<p>如果我们能拿到一个满射$\varphi : F [ x ] ^{ \oplus n  } \to V $,那考虑$\ker \varphi $当然是$F [ x ] ^{ \oplus n  } $的一个子模,既然如此,存在$F [ x ] ^{ \oplus n  } $的一组基$f _1 , \cdots , f _n $,以及一组非零多项式$d _1 | \cdots | d _n $,使得$\ker \varphi = \bigoplus _i F [ x ] d _i f _i $,从而使得$V \cong \bigoplus _i F [ x ] / ( d _i ) $.</p>
<p>策略当然是简单的,考虑$F [ x ] ^{ \oplus n  } $的一组基$e _1 , \cdots , e _n $,以及$V $作为向量空间的一组基$v _1 , \cdots , v _n $,我们要求$\varphi ( e _i ) = v _i , \varphi ( x ) = T $,从而$\varphi ( \sum _i r _i e _i ) = \sum _i r _i ( T ) v _i $,立刻见到这的确是满射,疑问只在于如何求其$\ker $.</p>
<p>定义$y _j = xe _j - \sum _{ i = 1  } ^n a _{ i , j  } e _i $.取$N = \sum _{ j = 1  } ^n F [ x ] y _j $,其中$a _{ i , j  } $是$T $再这组基下对应的矩阵元素.此时立刻见到$\varphi ( y _j ) = Tv _j - \sum _{ i  } a _{ i , j  } v _i = 0 $,因此$\ker \varphi \supseteq N $.</p>
<p>反之,观察到$xe _j = \sum _i a _{ i , j  } e _i + y _j \in \sum _i a _{ i , j  } e _i + N $,反复做此操作,得知$\forall w \in F [ x ] ^{ \bigoplus n  } , w \in \sum _{ i  } c _i e _i + N $,于此做$\varphi $得到$\varphi ( w ) = 0 \Leftrightarrow \sum _i c _i v _i = 0 $,从而得知所有的$c _i = 0 $.这就证明了$\ker \varphi = N $.</p>
<p>观察到$( x _1 , \cdots , x _n ) = ( e _1 , \cdots , e _n ) ( xI - A ) $,而$( xI - A ) $的确是一个定义在$F [ x ] $上的矩阵,对此用Smith标准型得到$( e _1 , \cdots , e _n ) Q \begin{bmatrix}d _1 &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; d _n \end{bmatrix} P $,这就搞定了.</p>
<h6><span id="example1">Example1</span></h6><p>考虑$V = F ^3 $,$T = A = \begin{bmatrix}- 1 &amp; - 2 &amp; 6 \ - 1 &amp; 0 &amp; 3 \ - 1 &amp; - 1 &amp; 4 \end{bmatrix} $.</p>
<p>首先要做的是计算$xI - A $,对此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
xI - A & = \begin{bmatrix}
x + 1 & 2 & - 6 \\
1 & x & - 3 \\
1 & 1 & x - 4 
\end{bmatrix} \\
\to \begin{bmatrix}
0 & - x + 1 & - x ^2 + 3 x - 2 \\
0 & x - 1 & - x + 1 \\
1 & 1 & x - 4 
\end{bmatrix} \\
\to \begin{bmatrix}
1 & 1 & x - 4 \\
0 & x - 1 & - x + 1 \\
0 & - x + 1 & - ( x - 1 ) ( x - 2 ) 
\end{bmatrix} \\
\to \begin{bmatrix}
1 & 0 & 0 \\
0 & x - 1 & - x + 1 \\
0 & - x + 1 & - ( x - 1 ) ( x - 2 ) 
\end{bmatrix} \\
\to \begin{bmatrix}
1 & 0 & 0 \\
0 & x - 1 & - x + 1 \\
0 & 0 & - ( x - 1 ) ^2 
\end{bmatrix} \\
\to \begin{bmatrix}
1 & 0 & 0 \\
0 & x - 1 & 0 \\
0 & 0 & - ( x - 1 ) ^2 
\end{bmatrix} \\

\end{aligned}</script><p>这样我们就得到了不变因子,得到$T \sim \begin{bmatrix}1 &amp; &amp; \ &amp; 0 &amp; - 1 \ &amp; 1 &amp; 2 \end{bmatrix} $.</p>
<h4><span id="jordan标准型">Jordan标准型</span></h4><p>对环上元素$r \in R $,如果$\exists d \geq 1 , r ^d = 0 $,我们称它是<strong>幂零的</strong>.而最小的$d \geq 1 $满足$r ^d $称为$r $的<strong>幂零指数</strong>.回忆到我们定义过广义特征子空间$V _{ [ \lambda ]  } = \ker ( T - \lambda ) ^\infty $.回忆到$\mathrm { End  } ( V ) $是一个环,$T \in \mathrm { End  } ( V ) $是其中的一个元素,我们说以下命题等价:</p>
<ol>
<li><p>$T \in \mathrm { End  } ( V ) $是幂零的.</p>
</li>
<li><p>$\exists k , \mathrm { Min  } _T = x ^k $.</p>
</li>
<li><p>$\mathrm { Char  } _T = x ^n $.</p>
</li>
<li><p>$V = V _{ [ 0 ]  } $.</p>
</li>
</ol>
<p>(1)$\Rightarrow $(2)只需考虑如果$T ^k = 0 $,则$\mathrm { Min  } _T | x ^k $.</p>
<p>(2)$\Rightarrow $(3)是显然的,因为极小多项式和特征多项式共根.</p>
<p>(3)$\Rightarrow $(4)直接是定义.</p>
<p>(4)$\Rightarrow $(1),考虑$V _{ [ 0 ]  } $作为子空间,扩张一定是有限次的,所以也就搞定.</p>
<p>接下来我们定义上三角块$J _d ( \lambda ) = \begin{bmatrix}\lambda &amp; 1 &amp; &amp; \ &amp; \ddots &amp; \ddots &amp; \ &amp; &amp; \lambda &amp; 1 \ &amp; &amp; &amp; \lambda \end{bmatrix} $以及下三角块$( J _d ) ^t ( \lambda ) $.容易见到$J _d ( \lambda ) = \lambda I + J _d ( 0 ) $,我们还可以发现下三角块$( J _d ) ^t ( 0 ) $恰好是多项式$x ^d $的友矩阵.并且容易见到对于$( J _d ) ^t ( \lambda ) $而言,其$\mathrm { Min  } = \mathrm { Char  } = ( x - \lambda ) ^d $.同理取其转置可以知道$J _d ( \lambda ) $亦然有$\mathrm { Min  } = \mathrm { Char  } = ( x - \lambda ) ^d $.</p>
<p>接下来我们证明,如果$A $幂零,则存在唯一的正整数列$1 \leq b _1 \leq \cdots \leq b _r $使得$\sum _{ i = 1  } ^r b _i = n $而$A $共轭于分块对角矩阵$\begin{bmatrix}J _{ b _1  } ( 0 ) &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; J _{ b _r  } ( 0 ) \end{bmatrix} $,并且如果上述陈述中的$J _{ b _i  } $全换成下三角$( J _{ b _i  } ) ^t $,结论亦然成立.</p>
<p>这个其实是显然的,因为此时直接取其有理标准型满足$f _1 | \cdots | f _r $,并且$f _r = x ^d $,设$f _i = x ^{ b _i  } $,自然得到下三角的结论,转置后得到上三角的结论.</p>
<p>接下来假设特征多项式在$F $上分裂(这当然是必要的,因为Jordan标准型是上三角矩阵,而一个矩阵可上三角化的充要条件是特征多项式在$F $上分裂),我们设其相异根为$\lambda _1 , \cdots , \lambda _m \in F $,存在$V $的有序基,使得$T $表为分块对角矩阵$diag ( A _1 , \cdots , A _m ) $,其中$A _j = \begin{bmatrix}J _{ b _1 , j  } ( \lambda _j ) &amp; &amp; \ &amp; \ddots &amp; \ &amp; &amp; J _{ b _{ r _j  } , j  } ( \lambda _j ) \end{bmatrix} $.而且每个$j $对应地正整数数列由$T $唯一确定,上述矩阵被称为$T $的Jordan标准型.</p>
<p>证法呼之欲出,取对$T $的广义特征子空间分解$V = V _{ [ \lambda _1 ]  } \oplus \cdots \oplus V _{ [ \lambda _m ]  } $,限制在$V _{ \lambda _j  } $上,$T _j - \lambda _j $幂零,根据上面的结论就做完了.</p>
<p>现在的问题可能在于如何计算Jordan标准型,一种方法是途径有理标准型,另一种方法是依赖于秩的计算.让我们依旧从幂零情形入手,假设$T $幂零,我们断言:</p>
<ol>
<li><p>在$T $的Jordan标准型中,Jordan块的总数为$n - \mathrm { rk  } ( T ) $个.</p>
</li>
<li><p>对于每个$d \geq 1 $,标准型中的$d \times d $Jordan块的个数$N ( d ) $满足:$N ( d ) = \mathrm { rk  } ( T ^{ d + 1  } ) + \mathrm { rk  } ( T ^{ d - 1  } ) - 2 \mathrm { rk  } ( T ^d ) $.</p>
</li>
</ol>
<p>(1)是显然的,因为一个$d \times d $的Jordan块的秩为$d - 1 $.</p>
<p>而容易见到$\mathrm { rk  } ( J _b ( 0 ) ^k ) = \max ( 0 , b - k ) $,从而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathrm { rk  } ( T ^{ d + 1  } ) - \mathrm { rk  } ( T ^d ) & = \sum _{ j : b _j \geq d + 1  } ( - 1 ) \\
\mathrm { rk  } ( T ^{ d  } ) - \mathrm { rk  } ( T ^{ d - 1  } ) & = \sum _{ j : b _j \geq d  } ( - 1 ) \\

\end{aligned}</script><p>两式相减即可得到答案.</p>
<p>至于对其余情形,只需观察到当$\lambda _i \ne \lambda _j $的时候,$A _i - \lambda _j I $肯定可逆,因此:</p>
<script type="math/tex; mode=display">
N _j ( d ) = \mathrm { rk  } ( T - \lambda _j I ) ^{ d + 1  } + \mathrm { rk  } ( T - \lambda _j I ) ^{ d - 1  } - 2 \mathrm { rk  } ( T - \lambda _j I ) ^d</script><p>便数平凡.</p>
<p>可以见到Jordan标准型的每一个块,如果特征值为$0 $,实际上是把基向前挪动.</p>
<h5><span id="加性jordan-chevalley分解">加性Jordan-Chevalley分解</span></h5><p>由上述可以见到,对于一个特征多项式可分裂的矩阵$T $,存在唯一一个可对角化矩阵$S $和一个幂零矩阵$N $使得$T = S + N $而且$SN = NS $.</p>
<p>由Jordan标准型知道的确存在解(因为每一个分块对角上的对角矩阵都是$\lambda I $的形式),现在问题在于唯一性.</p>
<p>既然$S $可对角化,我们取其相异的特征值$\mu _1 , \cdots , \mu _l $.对其做特征子空间分解$V = V _{ \mu _1  } \oplus \cdots \oplus V _{ \mu _l  } $,回忆到$NS = SN $导出$ST = TS $,这意味着每一个特征子空间都是$T $不变的.</p>
<p>此时观察$T | _{ V _j  } $,观察到此时$( T - \mu _j I ) | _{ V _j  } = N | _{ V _j  } $是幂零的,所以$V _j $被包含于$T $的广义特征子空间$V ‘ [ \mu _j ] $,然而广义特征子空间必然也给出了一个空间的分解,因此它们也不可能再往外扩张了,这必然意味着$S $的特征空间$V _j $恰好就是$T $的广义特征子空间$V ‘ [ \mu _j ] $.所以$S $限定在$V ‘ [ \mu _j ] $上就是$\mu _j I $,这就保证了$S $是唯一的,从而$N $也就唯一.</p>
<p>此外,我们还可以证明存在多项式$f , g $使得$S = f ( T ) , N = g ( T ) $.首先可以取$g = x - f $,下面来搞定$f $是如何取定的.</p>
<p>考虑用中国剩余定理拿到一个$f $满足$f \equiv \mu _i \pmod { ( x - \mu _i ) ^n  } $,留神到$f ( T ) | _{ V _j  } = \mu _j $,原因是$( T - \mu _j ) ^n | _{ V _j  } = 0 $,那按照我们刚才对唯一性的论证,这必然说明了$f ( T ) = S $.</p>
<h5><span id="乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</span></h5><p>对于一个特征多项式可分裂的可逆(等价于特征多项式无零根)的$T \in \mathrm { End  } ( V ) $,则存在唯一一对可逆的$S , U $使得:</p>
<ol>
<li><p>$S $可对角化.</p>
</li>
<li><p>$U - I $幂零.</p>
</li>
<li><p>$SU = T = US $.</p>
</li>
<li><p>存在多项式$f , g $,$S = f ( T ) , U = g ( T ) $.</p>
</li>
</ol>
<p>对于存在性,取道加性分解,设$T = S + N = S ( I + S ^{ - 1  } N ) $,直接取$U = I + S ^{ - 1  } N $,由于$SN = NS $,则$U - I = S ^{ - 1  } N $因为$N $幂零而幂零,同时$SU = T = US $也满足了.</p>
<p>对于唯一性,假设存在$T = SU = S + S ( U - I ) $,由于$SU = US $,所以$S ( U - I ) $幂零,这就给出了一个加性分解,从而导出了唯一性.</p>
<p>最后来看如何取多项式.加性版本给出了$S = f ( T ) $.要求出$g $的话需要满足$g ( T ) f ( T ) = T $.</p>
<p>于此考虑证明$f $和$\mathrm { char  } _T $是互素的,原因是反证法:如果不互素,则存在$T $的特征值$\lambda $使得$( x - \lambda ) | f $,则对于对应的特征向量$\vec { v  } $总有$S \vec { v  } = f ( T ) \vec { v  } = 0 $,可是$S $可对角化而且特征值无$0 $,这就矛盾了.</p>
<p>既然如此,用裴蜀定理立刻拿到一对$g , h \in F [ x ] $使得$gf + h \mathrm { char  } _T = x $,带入$T $得到$g ( T ) f ( T ) = T $,这个$g ( T ) = TS ^{ - 1  } = U $.</p>
<h3><span id="张量积">张量积</span></h3><p>给定两个$F $上的向量空间$V , W $,我们想要通过它们构造新的向量空间$V \otimes W $(这里并非直积,只是用这个符号).我们希望这个配对满足:</p>
<ol>
<li><p>$V \times W \to V \otimes W $是双线性的.</p>
</li>
<li><p>构造应该是自然的:不依赖基的选取.</p>
</li>
</ol>
<p>此外,我们希望其满足一些更好的泛性质,考虑资料$( L , B ) $,其中$L $是一个向量空间,$B $是一个$V \times W \to L $的一个双线性映射,我们希望有一个尽可能泛的资料$( L _{ \mathrm { univ  }  } , B _{ \mathrm { univ  }  } ) $,使得对于任何满足条件的$( L , B ) $,存在唯一的$\varphi $以下图表交换:</p>
<script type="math/tex; mode=display">
\xymatrix { V \times W \ar [r ] ^{ B _{ \mathrm { univ  }  }  } \ar [dr ] _B & L _{ \mathrm { univ  }  } \ar [d ] ^\varphi \\
& L  }</script><p>此外我们还希望上述资料$( L _{ \mathrm { univ  }  } , B _{ \mathrm { univ  }  } ) $是唯一的,我们希望将其记作$V \otimes W $.</p>
<p>我们可以先尝试构造一下,用最粗暴的方法,干脆定义$E = F ^{ \oplus ( V \times W )  } $,其元素表为有限线性组合$\sum _i c _i ( v _i , w _i ) $,考虑以下元素生成的子空间$N $:</p>
<ol>
<li><p>$( v + v ‘ , w ) - ( v , w ) - ( v ‘ , w ) $.</p>
</li>
<li><p>$( v , w + w ‘ ) - ( v , w ) - ( v , w ‘ ) $.</p>
</li>
<li><p>$( tv , w ) - t ( v , w ) $.</p>
</li>
<li><p>$( v , tw ) - t ( v , w ) $.</p>
</li>
</ol>
<p>接下来取$L _{ \mathrm { univ  }  } = E / N $,连同映射$B _{ \mathrm { univ  }  } : ( v , w ) \mapsto ( v , w ) + N $,容易见到我们的确强行定义了双线性形式的性质.</p>
<p>接下来考虑其泛性质,对双线性映射$B : V \times W \to L $,其可以确定唯一的线性映射$\Phi : E \to L , \sum _i c _i ( v _i , w _i ) \mapsto \sum _i c _i B ( v _i , w _i ) $.</p>
<p>然而由于$B $的双线性性,立刻得到$B ( N ) = \{ 0 \} $,从而可以导出唯一的$\varphi : L _{ \mathrm { univ  }  } \to L , x + N \mapsto \Phi ( x ) $.这立刻得到了$\varphi $的唯一性,原因是$\varphi ( ( v , w ) + N ) = B ( v , w ) $是总有的.</p>
<p>唯一性应当是显然的,只需见到如果有两个$L _{ \mathrm { univ  }  } $和$L _{ \mathrm { univ  }  } ‘ $,则应当有:</p>
<script type="math/tex; mode=display">
\xymatrix { & L _{ \mathrm { univ  }  } \ar [d ] ^\varphi \\
V \times W \ar [ru ] ^{ B _{ \mathrm { univ  }  }  } \ar [r ] ^{ B _{ \mathrm { univ  }  } '  } \ar [dr ] _{ B _{ \mathrm { univ  }  }  } & L _{ \mathrm { univ  }  } ' \ar [d ] ^\psi \\
& L _{ \mathrm { univ  }  }  }</script><p>外圈当然也是交换的,然而取$id $也必然导出外圈交换,由图表唯一性立刻得到$\varphi \psi = id $,对称性得出$\psi \varphi = id $,这就搞定了$L _{ \mathrm { univ  }  } \cong L _{ \mathrm { univ  }  } ‘ $.</p>
<p>容易见到上述性质保证了同构:$\mathrm { Hom  } ( V \otimes W , L ) \cong \mathrm { Bil  } ( V , W ; L ) , \varphi \mapsto \varphi B _{ \mathrm { univ  }  } $.</p>
<p>容易将上述结论推广到多重线性映射的情形.还可以将张量积的符号推广到线性映射上,我们断言总存在唯一的$\varphi $使得下图交换:</p>
<script type="math/tex; mode=display">
\xymatrix { V _1 \times \cdots \times V _n \ar [r ] ^{ ( f _1 , \cdots , f _n )  } \ar [d ] & W _1 \times \cdots \times W _n \ar [d ] \\
V _1 \otimes \cdots \otimes V _n \ar [r ] _{ \varphi  } & W _1 \otimes \cdots \otimes W _n \\
 }</script><p>从而可以自然地将$\varphi $记作$f _1 \otimes \cdots \otimes f _n $.</p>
<p>于此只需考虑上半部分,我们知道$( v _1 , \cdots , v _n ) \mapsto f _1 ( v _1 ) \otimes \cdots \otimes f _n ( v _n ) $是一个多重线性映射,所以当然存在唯一一个映射打过来.从而得到:</p>
<script type="math/tex; mode=display">
( f _1 \otimes \cdots \otimes f _n ) ( v _1 \otimes \cdots \otimes v _n ) = f _1 ( v _1 ) \otimes \cdots \otimes f _n ( v _n )</script><p>其实我们上面证明的就是下面这个同构$\bigotimes _{ i = 1  } ^n \mathrm { Hom  } ( V _i , W _i ) \cong \mathrm { Hom  } ( \bigotimes _i V _i , \bigotimes _i W _i ) $,好吧起码这个有限维情况下是同构,无穷维的话lww好像也有点不确定.</p>
<p>有以下性质自然成立(另一种看法是,线性映射也在一个线性空间里,所以上面也会自带一种张量积,恰为这个):</p>
<ol>
<li><p>$id _{ V _1  } \otimes \cdots \otimes id _{ V _n  } = id _{ V _1 \otimes \cdots \otimes V _n  } $.</p>
</li>
<li><p>$( f _1 \otimes \cdots \otimes f _n ) ( g _1 \otimes \cdots \otimes g _n ) = f _1 g _1 \otimes \cdots \otimes f _n g _n $.</p>
</li>
<li><p>$( ( \alpha f _1 + \alpha ‘ f _1 ‘ ) \otimes \cdots \otimes f _n ) = \alpha ( f _1 \otimes \cdots \otimes f _n ) + \alpha ‘ ( f _1 ‘ \otimes \cdots \otimes f _n ) $.</p>
</li>
</ol>
<p>而考虑多重线性映射的$\mathrm { Mul  } ( V _1 , \cdots , V _n ; M ) $,如果$V _1 , \cdots , V _n $中任意一个是零空间,那由于多重线性性质,立刻导出这个映射只有零映射(原因是此时$a = a + a $),从而使得$\mathrm { Hom  } ( V _1 \otimes \cdots \otimes V _n ; M ) $中只有零映射(对所有$M $),那其$id $映射也是零映射,自然意味着$V _1 \otimes \cdots \otimes V _n $是零空间.</p>
<p>于此之外,如果想要跳过张量积的构造而直接探究张量积的性质,可能需要先判断$\{ v _1 \otimes \cdots \otimes v _n \} $集合是否的确生成了$V _1 \otimes \cdots \otimes V _n $.于此只需要取$K = \langle v _1 \otimes \cdots \otimes v _n | \forall v _i \in V _i \rangle $,然后判断$M = ( V _1 \otimes \cdots \otimes V _n ) / K $是否为零空间即可.此时$\forall \varphi $作为商映射,当然都有$\varphi ( v _1 \otimes \cdots \otimes v _n ) = 0 $,我们想说明$\varphi $的确是零映射,这首先需要保证即使只有$v _1 \otimes \cdots \otimes v _n $上的限制也可以有类似外延公理的结论.</p>
<p>换言之,如果两个在$V _1 \otimes \cdots \otimes V _n $映射$f , g $满足$\forall v _i , f ( v _1 \otimes \cdots \otimes v _n ) = g ( v _1 \otimes \cdots \otimes v _n ) $则$f \equiv g $,只需回忆到这上面的映射与多重线性映射一一对应,而多重线性映射上用外延公理就搞定了.</p>
<p>这就看到,用与多重线性映射一一对应的性质同样是张量积的某种泛性质.</p>
<p>我们还可以看到,如果$f _1 , \cdots , f _n $都是满的,则$f _1 \otimes \cdots \otimes f _n $亦然,这是显然的.</p>
<p>可能稍不显然的是如果$f _1 , \cdots , f _n $都是单的,则$f _1 \otimes \cdots \otimes f _n $也是单的.此时$W _i $可以分解出一个与$V _i $同构的$\mathrm { im  } f _i $部分,干脆记作$W _i \cong V _i \oplus V _i ‘ $,并假设$f _i : V _i \to W _i $是自然的嵌入映射.回忆到张量积在同构下有交换律和对直和的分配律(下面会证),见到$W _1 \otimes \cdots \otimes W _n \cong ( V _1 \otimes \cdots \otimes V _n ) \oplus V ‘ $,此时$f _1 \otimes \cdots \otimes f _n $就是自然的嵌入映射.你可能会想欸,不对啊,$V ‘ $里也会有一些$V _i $项啊.可是,回忆到如果某一分量为零,则其在张量积中拿到的结果就是$0 $,所以$f _1 \otimes \cdots \otimes f _n $只会对前面有意义.</p>
<h4><span id="张量积与直和">张量积与直和</span></h4><p>接下来考虑证明以下结论:</p>
<ol>
<li><p>结合律:$V _1 \otimes ( V _2 \otimes V _3 ) \cong V _1 \otimes V _2 \otimes V _3 \cong ( V _1 \otimes V _2 ) \otimes V _3 $.</p>
</li>
<li><p>幺元:$F \otimes V \cong V \cong V \otimes F $.</p>
</li>
<li><p>交换律:$V \otimes W \cong W \otimes V $.</p>
</li>
<li><p>零元:$\{ 0 \} \otimes V \cong \{ 0 \} \cong V \otimes \{ 0 \} $.</p>
</li>
<li><p>分配律:设$V $带有直和分解$V = \bigoplus _{ i \in I  } V _i $,则$V \otimes W \cong \bigoplus _{ i \in I  } ( V _i \otimes W ) $.</p>
</li>
</ol>
<p>考虑(1),下面证明$V _1 \otimes ( V _2 \otimes V _3 ) \cong V _1 \otimes V _2 \otimes V _3 $,其关键是构造以下线性映射:</p>
<script type="math/tex; mode=display">
\xymatrix { V _1 \otimes ( V _2 \otimes V _3 ) \ar [r ] ^{ \alpha  } & V _1 \otimes V _2 \otimes V _3 \ar [r ] ^{ \beta  } & V _1 \otimes ( V _2 \otimes V _3 ) \\
v _1 \otimes ( v _2 \otimes v _3 ) \ar @{|->} [r ] & v _1 \otimes v _2 \otimes v _3 \ar @{|->} [r ] & v _1 \otimes ( v _2 \otimes v _3 )  }</script><p>如果我们的确造出了这个映射,由于我们有外延公理,这必然意味着$\alpha \circ \beta = id $,从而导出$V _1 \otimes ( V _2 \otimes V _3 ) \cong V _1 \otimes V _2 \otimes V _3 $.</p>
<p>对于$\beta $,立刻就能看出$V _1 \times V _2 \times V _3 \to V _1 \otimes ( V _2 \otimes V _3 ) $是三重线性的.因此泛性质诱导出$\beta $映射.</p>
<p>至于$\alpha $映射,只需先做$V _1 \times ( V _2 \times V _3 ) \cong V _1 \times V _2 \times V _3 $就行.</p>
<p>考虑(2),和(1)一样,我们想要搞一个映射链$V \to F \otimes V \to V $,对于前者只需要取映射$\lambda _V : F \otimes V \to V , t \otimes v \mapsto tv $,对于后者只需要取$\tau _V : V \to F \otimes V , v \mapsto 1 \otimes v $.回忆到$1 \otimes tv = t \otimes v $,因此上述映射均是合理的,而且复合之后是$id $.</p>
<p>考虑(3),我想答案呼之欲出:$V \otimes W $和$W \otimes V $都是$V \times W $诱导出来的,而$V \times W \cong W \times V $.</p>
<p>(4)我们之前已经证明了.</p>
<p>考虑(5),回忆到如果$V = \bigoplus _{ i \in I  } V _i $,则$V ^\vee = \prod _{ i \in I  } ( V _i ) ^\vee $.同理应该能拿到$\mathrm { Hom  } ( V , L ) = \prod _{ i \in I  } \mathrm { Hom  } ( V _i , L ) $,进一步地有:</p>
<script type="math/tex; mode=display">
\mathrm { Bil  } ( V , W ; L ) \cong \prod _{ i \in I  } \mathrm { Bil  } ( V _i , W ; L ) \cong \prod _{ i \in I  } \mathrm { Hom  } ( V _i \otimes W , L ) \cong \mathrm { Hom  } \left ( \bigoplus _{ i \in I  } ( V _i \otimes W ) , L \right )</script><p>从而可以使我们诱导出原本的同构.</p>
<p>基于(5),我们可以知道如果$V $有基$( v _i ) _{ i \in I  } $而$W $有基$( w _j ) _{ j \in J  } $,则$( v _i \otimes w _j ) _{ ( i , j ) \in I \times J  } $也是$V \otimes W $的基,从而得到$\dim ( V \otimes W ) = ( \dim V ) \times ( \dim W ) $.这给出了张量积的Kronecker基形式.</p>
<p>最后我们还可以引入张量幂$V ^{ \otimes n  } $,从上面的讨论我们可以知道$( V ^{ \otimes a  } ) ^{ \otimes b  } \cong V ^{ \otimes ab  } $以及$V ^{ \otimes a  } \otimes V ^{ \otimes b  } \cong V ^{ \otimes ( a + b )  } $.</p>
<h4><span id="kronecker积">Kronecker积</span></h4><p>对于矩阵$X \in F ^{ n \times m  } , Y \in F ^{ p \times q  } $,我们定义它们的克罗内多积为:</p>
<script type="math/tex; mode=display">
X \otimes Y = \begin{bmatrix}
x _{ 1 , 1  } Y & x _{ 1 , 2  } Y & \cdots & x _{ 1 , m  } Y \\
x _{ 2 , 1  } Y & x _{ 2 , 2  } Y & \cdots & x _{ 2 , m  } Y \\
\vdots & \vdots & \ddots & \vdots \\
x _{ n , 1  } Y & x _{ n , 2  } Y & \cdots & x _{ n , m  } Y 
\end{bmatrix} \in F ^{ ( np ) \times ( mq )  }</script><p>克罗内多积显然不满足交换律.</p>
<p>事实上,设$X , Y , Z $在下列运算中有意义,克罗内多积满足以下性质:</p>
<ol>
<li><p>结合律:$X \otimes Y \otimes Z = X \otimes ( Y \otimes Z ) $.</p>
</li>
<li><p>左分配律:$X \otimes ( Y + Z ) = X \otimes Y + X \otimes Z $.</p>
</li>
<li><p>右分配律:$( X + Y ) \otimes Z = X \otimes Z + Y \otimes Z $.</p>
</li>
<li><p>$( X \otimes Y ) ^T = X ^T \otimes Y ^T $.</p>
</li>
<li><p>$( X \otimes Y ) ( U \otimes V ) = ( XU ) \otimes ( YV ) $.</p>
</li>
<li><p>$X ^{ - 1  } \otimes Y ^{ - 1  } = ( X \otimes Y ) ^{ - 1  } $.</p>
</li>
<li><p>$\det ( X \otimes Y ) = \det ( X ) ^m \det ( Y ) ^n , X \in F ^{ n \times n  } , Y \in F ^{ m \times m  } $.</p>
</li>
<li><p>$rank ( X \otimes Y ) = rank ( X ) \times rank ( Y ) $.</p>
</li>
</ol>
<p>上述命题稍不显然的是(4),我们将在下面讨论对偶空间的时候得出它.</p>
<p>克罗内多积的性质有一个很有用的特例是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A \otimes B \otimes C & = ( A \otimes I _n \otimes I _n ) ( I _n \otimes B \otimes I _n ) ( I _n \otimes I _n \otimes C ) \\
A , B , C \in F ^{ n \times n  } 
\end{aligned}</script><h4><span id="张量积与对偶空间">张量积与对偶空间</span></h4><p>回忆到典范配对,如今我们可以用张量积将其表示为线性映射$V ^\vee \otimes V \to F , \lambda \otimes v \mapsto \langle \lambda , v \rangle = \lambda ( v ) $,这被称为<strong>缩并</strong>映射.</p>
<p>考虑映射$\Theta : V ^\vee \otimes W \to \mathrm { Hom  } ( V , W ) , \sum _i \lambda _i \otimes w _i \mapsto \sum _i \langle \lambda _i , _ \rangle w _i $.这个映射总是单射,当维数是有限维的时候则是满的.</p>
<p>也许还该简单验证此结论,首先检查$V ^\vee \times W \to \mathrm { Hom  } ( V , W ) $,这的确是一个双线性映射,于是由泛性质立刻诱导出映射$V ^\vee \otimes W \to \mathrm { Hom  } ( V , W ) $.</p>
<p>接下来证明其是单射,只需要证明其$\ker = \{ 0 \} $即可.而其$\ker $中的元素总形如$\sum _{ i = 1  } ^k \lambda _i \otimes w _i $,不妨假设$w _1 , \cdots , w _k $是线性无关的(可以把相关的项整理到$\lambda _i $里面).</p>
<p>此时由于其在$\ker $里,所以$\forall v \in V $,总有$\sum _{ i = 1  } ^k \langle \lambda _i , v \rangle w _i = 0 $,然而$w _i $线性无关,所以$\langle \lambda _i , v \rangle \equiv 0 $,可是$v $是任取的,这必然意味着$\lambda _i \equiv 0 $.</p>
<p>接下来考虑证明当$V , W $其一是有限维的时候上述映射是满的,容易发现$\Theta $的像总是有限维的(因为左边是有限求和).当$V , W $其一是有限维的,$T \in \mathrm { Hom  } ( V , W ) $就是有限秩的,此时就可以取其像的基$w _1 , \cdots , w _n $,对所有$v \in V $,$T ( v ) $都可以唯一表述为$c _1 w _1 + \cdots + c _n w _n $,然而这里面每一个$c _i $对$v $都是线性的,从而它们都可以表示为$V ^\vee $中的元素而与$v $的选取无关,这就搞定了.</p>
<p>万事俱备,再看$\mathrm { End  } ( V ) $上,既然$V ^\vee \otimes V $带有一个典范的缩并映射,在有限维的情况下,那与之同构的$\mathrm { End  } ( V ) $也该带有一个到$F $的映射.我们断言这个映射就是$\mathrm { Tr  } $映射.有下述图表:</p>
<script type="math/tex; mode=display">
\xymatrix { V ^\vee \otimes V \ar [rd ] _{ \text { contraction  }  } \ar [rr ] ^{ \sim  } & & \mathrm { End ( V )  } \ar [ld ] ^\mathrm { Trace  } \\
& F &  }</script><p>如何检验这个结论,我们之前刻画Trace的办法只有取对偶基$\check { v  } _1 , \cdots , \check { v  } _n $,然后将$v = \sum c _i v _i $和$\lambda = d _i \check { v  } _i $,那典范配对$\Theta ( \lambda \otimes v ) = \sum _{ i , j  } \langle \check { v  } _i , _ \rangle v _j $,也就是说其将基向量$v _i $映射到了$\sum _j c _j d _i $,从而见到其$\mathrm { Tr  } = \sum _i c _i d _i = \langle \lambda , v \rangle $.</p>
<p>如果写成矩阵形式的话,$\lambda \in V ^\vee $可以写成一个$1 \times n $的矩阵,$w \in W $可以写成一个$m \times 1 $的矩阵,那其实$\Theta ( \lambda \otimes w ) $就是$w \lambda $这个$m \times n $的矩阵.</p>
<p>最后来看曾经想要拿到的那个结论,下面我们引入一个典范的同构$\Psi : V _1 ^\vee \otimes \cdots \otimes V _n ^\vee \to ( V _1 \otimes \cdots \otimes V _n ) ^\vee $,策略是观察$V _1 ^\vee \times \cdots \times V _n ^\vee \to ( V _1 \otimes \cdots \otimes V _n ) ^\vee $自然是一个线性映射,其映射自然是:</p>
<script type="math/tex; mode=display">
( \check { v  } _1 , \cdots , \check { v  } _n ) \mapsto \left [ v _1 \otimes \cdots \otimes v _n \mapsto \prod _{ i = 1  } ^n \langle \check { v  } _i , v _i \rangle \right ]</script><p>我们希望当每个$V _i $都是有限维的时候,上述映射是同构.由于两遍维数相同,所以单性蕴含着满性.而其单性只要取左侧$V _1 ^\vee \otimes \cdots \otimes V _n ^\vee $的基$\check { v _{ 1 , i _1  }  } \otimes \cdots \otimes \check { v _{ n , i _n  }  } $,将每个$\lambda $按照这组基展开,$\psi ( \lambda ) $在$v _{ 1 , i _1  } \otimes \cdots \otimes v _{ n , i _n  } $处的值就是该基在$\lambda $中的系数.因此$\ker = \{ 0 \} $导出单性.</p>
<h4><span id="张量代数">张量代数</span></h4><p>设$F $是一个域,一个$F $上的<strong>代数</strong>需要以下资料:</p>
<ol>
<li><p>一个环$A $,其需要带有$F $向量空间的结构,使得环的加法等价于向量空间的加法.</p>
</li>
<li><p>环的乘法$A \times A \to A $需要是双线性的.</p>
</li>
</ol>
<p>请沿之前引入代数结构的常规讨论把代数的结构一块搞定,其实大部分在环那里已经做完了,代数结构更强,因此只需要限定同态必须也态射到代数就行.也许还需要检验理想对标量乘法封闭,只需要观察到$tI = ( t 1 _A ) I \subseteq I $就行.</p>
<p>对于$F $向量空间$V $,下面定义$T ( V ) = \bigoplus _{ n \geq 0  } V ^{ \otimes n  } $,其自然带有向量空间的结构,只需加上双线性乘法就能构成一个代数,策略是:</p>
<script type="math/tex; mode=display">
\begin{gathered}
V ^{ \otimes a  } \otimes V ^{ \otimes b  } \to V ^{ \otimes ( a + b )  } \\
( v _1 \otimes \cdots \otimes v _a ) \otimes ( v _1 ' \otimes \cdots \otimes v _b ' ) \mapsto v _1 \otimes \cdots \otimes v _a \otimes v _1 ' \otimes \cdots \otimes v _b ' 
\end{gathered}</script><p>它的幺元自然选作$1 \in F = V ^{ \otimes 0  } $.我们还可以自然地在上面定义$\psi ^{ \otimes a  } $之类的结构,不再赘述.</p>
<p>来进入对称代数与外代数,考虑$C \in \mathrm { Mul  } ( V , \cdots , V ; M ) $,任意置换$\sigma $,定义:</p>
<ol>
<li><p>如果$C ( \cdots , x , y , \cdots ) = C ( \cdots , y , x , \cdots ) $,则称其为<strong>对称的</strong>.对称性等价于说$C ( v _1 , \cdots , v _n ) = C ( v _{ \sigma ( 1 )  } , \cdots , v _{ \sigma ( n )  } ) $.</p>
</li>
<li><p>如果说$C ( v _1 , \cdots , v _n ) = \mathrm { sgn  } ( \sigma ) C ( v _{ \sigma ( 1 )  } , \cdots , v _{ \sigma ( n )  } ) $,则称其为<strong>反对称的</strong>.</p>
</li>
<li><p>如果$C ( \cdots , x , x , \cdots ) = 0 $,则称其为<strong>交错的</strong>.</p>
</li>
</ol>
<p>当$\mathrm { char  } F \ne 2 $的时候,交错和反对称是等价的.不然,起码交错的一定是反对称的.下面定义:</p>
<ol>
<li><p>$I _{ Sym  } $为形如$x \otimes y - y \otimes x $的元素生成的理想.</p>
</li>
<li><p>$I _{ \wedge  } $为形如$x \otimes x $生成的理想.</p>
</li>
</ol>
<p>这样就可以定义相应的<strong>对称代数</strong>$Sym ( V ) = T ( V ) / I _{ Sym  } $,<strong>外代数</strong>$\bigwedge ( V ) = T ( V ) / I _\wedge $.还可以定义$Sym ^m ( V ) = V ^{ \otimes m  } / I _{ \mathrm { sym  }  } ^m $,同理定义$\bigwedge ^m ( V ) $,容易发现$Sym ^0 ( V ) = F = \bigwedge ^0 ( V ) , Sym ^1 ( V ) = V = \bigwedge ^1 ( V ) $.</p>
<p>在其中的$\otimes $运算被自然变成了新的运算,设前者仍是通常的乘法符号,而后者符号采取$\wedge $.</p>
<p>外代数里一个重要的性质是如果$\omega \in \bigwedge ^p ( V ) , \eta \in \bigwedge ^q ( V ) $,则$\omega \eta = ( - 1 ) ^{ pq  } \eta \omega $,原因是只需要假设$\omega = x _1 \wedge \cdots \wedge x _p , \eta = y _1 \wedge \cdots \wedge y _q $,其中$x _i , y _i \in V $,而外代数的定义已经给出$x \wedge y = - y \wedge x $,这就完事了.</p>
<p>既然我们可以将一个对称代数或者外代数分成若干层,那考虑对于任意线性映射$\psi : V \to W $,我们都可以通过在各个分量上诱导从而拿到:$Sym ( \psi ) : Sym ( V ) \to Sym ( W ) , x _1 \cdots x _m \mapsto \psi ( x _1 ) \cdots \psi ( x _m ) $,其中$\psi ( x _m ) $是限制在$V ^{ \otimes m  } $上的.这应该是平凡的.</p>
<p>最后我们想要说明对称代数与外代数确实对应着我们的多重线性映射.也就是$\mathrm { Hom  } ( Sym ^m , M ) $同构于所有的对称$m $重线性映射.外代数类似.而这些依照理想的定义的确如此.</p>
<p>接下来来展现二者的结构,不妨设$\dim V = n $,取其一组基$v _1 , \cdots v _n $,我们说:</p>
<ol>
<li><p>当$m &gt; n $的时候,$\bigwedge ^m ( V ) = \{ 0 \} $.</p>
</li>
<li><p>当$0 \leq m \leq n $的时候,$\dim \bigwedge ^m ( V ) = \binom { n  } { m  } $.更确切地说,任意一组下标$1 \leq i _1 &lt; \cdots &lt; i _m \leq n $,$v _{ i _1  } \wedge \cdots \wedge v _{ i _m  } $构成$\bigwedge ^m ( V ) $的基.</p>
</li>
<li><p>作为(2)的推论,$\dim \bigwedge ( V ) = 2 ^n $.</p>
</li>
</ol>
<p>(1)比较显然,因为当$m &gt; n $的时候,任何一个元素被生成的方式$v ‘ _{ 1  } \wedge \cdots \wedge v ‘ _{ m  } $一定线性相关,所以自然为$0 $.</p>
<p>接下来看(2),我们早在行列式的讨论处就证明过了当$m = n $的时候,交错形式是一维的,那当然导出$\dim ( \bigwedge ^n ( V ) ) = 1 $.而且若$\psi \in \mathrm { End  } ( V ) $,则当然有$\bigwedge ^n ( \psi ) = det ( \psi ) \mathrm { id  } _{ \wedge ^n ( V )  } $.</p>
<p>而由之前张量积的结论,$v _{ i _1  } \wedge \cdots \wedge v _{ i _m  } $这些元素肯定构成了一组生成元,只需要证明它们的确线性无关即可.只需证明:</p>
<script type="math/tex; mode=display">
\sum _{ 1 \leq j _1 < \cdots < j _m \leq n  } c _{ j _1 , \cdots , j _m  } ( v _{ j _1  } \wedge \cdots \wedge v _{ j _m  } ) = 0 \Rightarrow c _{ j _1 , \cdots , j _m  } \equiv 0</script><p>做法呼之欲出,取$V ‘ = \langle v _{ i _1 ,  } , \cdots , v _{ i _m  } \rangle $,定义$\psi : V \to V ‘ $,方法是$\psi ( v _j ) = \begin{cases}v _j &amp; j \in \{ i _1 , \cdots , i _m \} \ 0 &amp; \text { otherwise  } \end{cases} $.此时其诱导出了$\bigwedge ^m ( \psi ) : \bigwedge ^m ( V ) \to \bigwedge ^m ( V ‘ ) $.然后两边做映射.如果$\{ j _1 , \cdots , j _m \} \ne \{ i _1 , \cdots , i _m \} $那就会变成零,最后就会导出$c _{ i _1 , \cdots , i _m  } ( v _{ i _1  } \wedge \cdots \wedge v _{ i _m  } ) = 0 $,然而左边是在$\bigwedge ^m ( V ‘ ) $这个$\dim = 1 $的空间中,所以一定能导出$c _{ i _1 , \cdots , i _m  } = 0 $.</p>
<p>上述是外代数的结构,我们还可以刻画对称代数的结构,可以证明如果$\dim V = n $,取定$V $的基$v _1 , \cdots , v _n $,可以将$Sym ( V ) \cong F [ X _1 , \cdots , X _n ] $.其实就是二次型理论对吧,应该比较简单.</p>
<p>最后我们可以来定义交错矩阵:$A \in M _{ n \times n  } ( R ) $,若$a _{ i , j  } = - a _{ j , i  } $而且$a _{ i , i  } = 0 $.在$2 \in R ^\times $的交换环上,这等价于$A ^t = - A $.</p>
<p>可以证明当$A \in M _{ n \times n  } ( F ) $,对应了双线性形式$B \in \mathrm { Bil  } ( F ^n , F ^n ; F ) $为$B ( \vec { x  } , \vec { y  } ) = ( \vec { x  } ) ^t A \vec { y  } $.则$B $是交错形式当且仅当$A $是交错矩阵.必要性很显然,只需带入$a _{ i , j  } = ( \vec { e  } _i ) ^t A \vec { e  } _j = B ( \vec { e  } _i , \vec { e  } _j ) $;充分性也很显然,考察$B ( \vec { x  } , \vec { x  } ) = ( \vec { x  } ) ^t A \vec { x  } = 0 $即可.</p>
<p>最后来看特征多项式如何表为外代数形式.考虑$V $是域$F $上的$n $维向量空间,$T \in \mathrm { End  } ( V ) $,则我们断言:</p>
<script type="math/tex; mode=display">
\det ( \lambda I - T ) = \sum _{ k = 0  } ^n ( - 1 ) ^k \mathrm { Tr  } ( \bigwedge _k T ) \lambda ^{ n - k  }</script><p>我们之前已经解释过了:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\det ( \lambda I - T ) e _1 \wedge \cdots \wedge e _n \\
& = ( \lambda I - T ) e _1 \wedge \cdots \wedge ( \lambda I - T ) e _n \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^k \lambda ^{ n - k  } \sum _{ | I | = k  } e _1 \wedge \cdots Te _{ i _1  } \cdots \wedge e _n 
\end{aligned}</script><p>也就是设只有$i _k \in I $这个指标集选到了$Te $而其它的还是$e $,不妨设$J = \{ 1 , \cdots , n \} \setminus I $.现在考虑$\{ e _{ i _1  } \wedge \cdots \wedge e _{ i _k  } \} _{ I  } $会构成$\bigwedge ^k ( V ) $的一组基,$T $施加到上面得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \bigwedge ^k T ) ( e _{ i _1  } \wedge \cdots \wedge e _{ i _k  } ) & = Te _{ i _1  } \wedge \cdots \wedge T e _{ i _k  } \\

\end{aligned}</script><p>对上面这个式子两边做$\wedge ( e _{ j _1  } \wedge \cdots \wedge e _{ j _{ n - k  }  } ) $,现在看右侧,如果$Te _{ i _1  } $变出了一些带有$e _{ j  } $的项,就会变成$0 $.因此右边最后剩下来的只会是形如$a _I ( e _{ i _1  } \wedge \cdots \wedge e _{ i _k  } ) \wedge ( e _{ j _1  } \wedge \cdots \wedge e _{ j _{ n - k  }  } ) $的东西.两边再换回去,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\det ( \lambda I - T ) e _1 \wedge \cdots \wedge e _n \\
& = \sum _{ k = 0  } ^n ( - 1 ) ^k \lambda ^{ n - k  } \sum _{ | I | = k  } a _I 
\end{aligned}</script><p>而最后那个东西恰好是$\mathrm { Tr  } ( \bigwedge ^k T ) $.</p>
<h5><span id="另一种构造">另一种构造</span></h5><p>当$\mathrm { char  } ( F ) = 0 $的时候,我们可以脱离商空间的结构,而直接将对称代数与外代数定义在$T ( V ) $的子空间上.</p>
<p>对称代数与外代数(此时已经等价于反对称代数)都依赖于交换导出的结果,因此首要要做的就是让置换群$S _n $作用域$V ^{ \otimes n  } $,为了保证左作用,下面的设计可能略有一些不合理,但好在我们后面也不会涉及具体的运算.假设$\sigma \in S _n $,保持:</p>
<ol>
<li><p>$\sigma ( ax + by ) = a ( \sigma x ) + b ( \sigma y ) $.</p>
</li>
<li><p>$\sigma ( v _1 \otimes \cdots \otimes v _n ) = v _{ \sigma ^{ - 1  } ( 1 )  } \otimes \cdots \otimes v _{ \sigma ^{ - 1  } ( n )  } $.</p>
</li>
<li><p>$( \sigma \tau ) ( x ) = \sigma ( \tau x ) $.</p>
</li>
</ol>
<p>(2)的奇异设计是为了让(3)合理.这个时候你肯定要问:wcnmd,这个为啥不对啊.你别急,我们设$w _i = v _{ \tau _{ - 1  } ( i )  } $,则最后得到的结果是$w _{ \sigma ^{ - 1  } ( i )  } = w _{ \tau ^{ - 1  } \sigma ^{ - 1  } ( i )  } = w _{ ( \sigma \tau ) ^{ - 1  } ( i )  } $.</p>
<p>原因很简单,因为对于$v _i $这个东西,我们想要把它送到$v _{ \sigma ( i )  } $那里去,这样看就合理了.</p>
<p>现在我们着手取子空间,拿出$V _{ Sym  } ^{ \otimes n  } = \{ x \in V ^{ \otimes n  } | \forall \sigma \in S _n , \sigma x = x \} $以及$V _{ \wedge  } ^{ \otimes n  } = \{ x \in V ^{ \otimes n  } | \forall \sigma \in S _n , \sigma x = \mathrm { sgn  } ( \sigma ) x \} $.同理可以施加$\bigoplus _n $从而拿到$T ( V ) $的子空间$V _{ Sym  } $和$V _\wedge $.</p>
<p>回忆到我们之前定义过商映射$q _{ \mathrm { sym  }  } : T ( V ) \to Sym ( V ) $和$q _\wedge : T ( V ) \to \bigwedge ( V ) $.我们下面断言,如果$n ! \in F ^\times $(当$\mathrm { char  } F = 0 $的时候自动满足),则上述映射限制在子空间上变为同构$( V ^{ \otimes n  } ) _{ Sym  } \cong Sym ^n ( V ) $和$( V ^{ \otimes n  } ) _{ \wedge  } \cong \bigwedge ^n ( V ) $.</p>
<p>上述两条类似,我们下面只证明$Sym $的情形.定义映射$Avg \in \mathrm { End  } ( V ^{ \otimes n  } ) , x \mapsto \frac { 1  } { n !  } \sum _{ \sigma \in S _n  } \sigma x $.留神到$Avg | _{ V _{ \mathrm { sym  }  } ^{ \otimes n  }  } = id $,而$\mathrm { im  } ( Avg ) = V _{ \mathrm { sym  }  } ^{ \otimes n  } $.从而我们知道$Avg $事实上给出了一个$V ^{ \otimes n  } \to V _{ \mathrm { sym  }  } ^{ \otimes n  } $的映射,有同构$V ^{ \otimes n  } / \ker ( Avg ) \cong V _{ \mathrm { sym  }  } ^{ \otimes n  } $.</p>
<p>来考虑$q _{ \mathrm { sym  }  } ^n $限制在$V _{ \mathrm { sym  }  } ^{ \otimes n  } $上的结果,记作$\pi $.如果我们想证明$\pi $是满射,其实就是要证明$\ker Avg \subseteq \ker q _{ \mathrm { sym  }  } ^n $.可是$q _{ \mathrm { sym  }  } ^n $的定义保证了$q _{ \mathrm { sym  }  } ^n ( \sigma x ) = q _{ \mathrm { sym  }  } ^n ( x ) $,因此$q _{ \mathrm { sym  }  } ^n \circ Avg = q _{ \mathrm { sym  }  } ^n $,导出$\ker Avg \subseteq \ker q _{ \mathrm { sym  }  } ^n $.</p>
<p>要证明单射则只需要证明$V _{ Sym  } ^{ \otimes n  } \cap \ker q _{ \mathrm { sym  }  } ^n = \{ 0 \} $.我想这应该是显然的,假设它们的交不为$0 $,取出其中之一,由于其在$\ker q _{ \mathrm { sym  }  } ^n $中,所以它必然可以写成若干个$\cdots ( x \otimes y ) - ( y \otimes x ) \cdots $的组合,而这些都会在$Avg $作用下变成$0 $.从而我们证明了上述结论.</p>
<p>不过还没有完,我们想要刻画它的代数结构,还差一个乘法.</p>
<p>考虑取上述映射的逆映射,定义$p _\mathrm { sym  } ^n : Sym ^n ( V ) \cong V $,我们想要研究一下乘法,断言当$( a + b ) ! \in F ^\times $的时候,对所有$x \in ( V ^{ \otimes a  } ) _\mathrm { sym  } , y \in ( V ^{ \otimes b  } ) _\mathrm { sym  } $:</p>
<script type="math/tex; mode=display">
p _\mathrm { sym  } ^{ a + b  } ( q _\mathrm { sym  } ^{ a  } ( x ) q _\mathrm { sym  } ^{ b  } ( y ) ) = \frac { a ! b !  } { ( a + b ) !  } \sum _{ \sigma \in S _{ a + b  } / ( S _a \times S _b )  } \sigma ( x \otimes y )</script><p>对于$\bigwedge $有类似的版本,有:</p>
<script type="math/tex; mode=display">
p _{ \wedge  } ^{ a + b  } ( q _{ \wedge  } ^{ a  } ( x ) q _{ \wedge  } ^{ b  } ( y ) ) = \frac { a ! b !  } { ( a + b ) !  } \sum _{ \sigma \in S _{ a + b  } / ( S _a \times S _b )  } \mathrm { sgn  } ( \sigma ) \sigma ( x \wedge y )</script><p>考虑上述断言的证明,选取$\bigwedge $版本进行证明,首先应该有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
q _{ \wedge  } ^{ a  } ( x ) q _{ \wedge  } ^{ b  } ( y ) & = q _{ \wedge  } ^{ ab  } ( x \wedge y ) \\
& = q _{ \wedge  } ^{ ab  } \left ( \frac { 1  } { ( a + b ) !  } \sum _{ \sigma \in S _{ a + b  }  } \mathrm { sgn  } ( \sigma ) \sigma ( x \wedge y ) \right ) 
\end{aligned}</script><p>考虑$\sigma ( x \wedge y ) $,其对于$( \tau , \eta ) \in S _a \times S _b $的时候,考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \tau , \eta ) ( x \wedge y ) & = \tau ( x ) \wedge \eta ( y ) \\
& = \mathrm { sgn  } ( \tau ) \mathrm { sgn  } ( \eta ) x \wedge y \\
& = \mathrm { sgn  } ( ( \tau , \eta ) ) ( x \wedge y ) 
\end{aligned}</script><p>这就会和前面抵消.所以$S _a \times S _b $可以被商掉,这些元素的数量是$a ! b ! $个,从而我们确实知道了它的乘法结构.</p>
<p>至于$S _{ a + b  } / ( S _a \times S _b ) $,其实就是选出$a + b $中的$a $个元素扔到前面,把剩下的$b $个元素扔到后面,而且不在意它们的顺序.这就是为什么它的大小为$\binom { a + b  } { a  } $.</p>
<h5><span id="又看对偶空间">又看对偶空间</span></h5><p>假设$\dim V = n &lt; \infty $,$n ! \in F ^\times $.我们断言有以下典范(从左到右)同构成立:</p>
<ol>
<li><p>$\mathrm { Sym  } ^n ( V ^\vee ) \cong \mathrm { Sym  } ^n ( V ) ^\vee $.</p>
</li>
<li><p>${ \bigwedge  } ^n ( V ^\vee ) \cong { \bigwedge  } ^n ( V ) ^\vee $.</p>
</li>
</ol>
<p>原因是以下同构:</p>
<script type="math/tex; mode=display">
\xymatrix { ( V ^\vee ) ^{ \otimes n  } \ar [r ] ^{ \cong  } _{ \Psi  } & ( V ^{ \otimes n  } ) ^\vee \ar [r ] ^{ \cong  } _{ \Phi  } & \mathrm { Mul  } ( V , \cdots , V ; F ) \\
\lambda _1 \otimes \cdots \otimes \lambda _n \ar @{|->} [rr ] & & [ C ( x _1 , \cdots , x _n ) = \prod _{ i = 1  } ^n \langle \lambda _i , x _i \rangle ]  }</script><p>如果我们在左侧施加$\sigma $后,右侧会如何改变呢?当然是会变成$C ( x _{ \sigma ( 1 )  } , \cdots , x _{ \sigma ( n )  } ) $.如果左侧是$( V ^\vee ) ^{ \otimes n  } _\mathrm { sym  } $,那右侧就会对应到$\mathrm { Mul  } _\mathrm { sym  } ( V , \cdots , V ; F ) = ( V ^{ \otimes n  } ) ^\vee _\mathrm { sym  } $.</p>
<h6><span id="example1">Example1</span></h6><p>设$U , W $分别是$V $的$p $维子空间,$U $有基$x _1 , \cdots , x _p $,$V $有基$y _1 , \cdots , y _p $,求证:$U = V $当且仅当$x _1 \wedge \cdots \wedge x _p $和$y _1 \wedge \cdots \wedge y _p $成比例.</p>
<p>必要性显然,只需要把其中一组基用令一组基表示即可.</p>
<p>对于充分性,考虑反证,如果$U \ne W $,取$w \in U \setminus V $,两边对$\wedge w $操作.则$x _1 \wedge \cdots \wedge x _p $会变成$0 $可$y _1 \wedge \cdots \wedge y _p $不会,这就矛盾了.</p>
<h6><span id="example2">Example2</span></h6><p>对于$\omega \in \bigwedge ^p ( V ) \setminus \{ 0 \} $,我们定义如果存在$v _1 , \cdots , v _p \in V $,使得$\omega = v _1 \wedge \cdots , \wedge v _p $,则称$\omega $可<strong>分解</strong>.这当然是我们关注的一个重点,下面我们尝试去推导出关于可分解的部分结论.</p>
<p>设$\omega \in \bigwedge ^p ( V ) \setminus \{ 0 \} $,其中$p \leq n = \dim V $.</p>
<p>考虑如果$\omega \wedge v = 0 $,我们断言$\omega $一定可以写作$v \wedge \eta $的形式.策略是将$\{ v \} $扩展成一组基$e _1 = v , e _2 \cdots , e _n $.此时$\omega = \sum _{ | I | = p  } a _I e _{ i _1  } \wedge \cdots \wedge e _{ i _k  } $.如果$\omega \wedge v = 0 $,必然意味着如果$1 \notin I \Rightarrow a _I = 0 $.从而导出上述结论.</p>
<p>定义$\mathrm { ann  } ( \omega ) = \{ v \in V | \omega \wedge v = 0 \} $,容易发现这的确是$V $的一个子空间.以数学归纳的策略可以证明其$r = \dim \leq p $,策略是取其一组基$e _1 , \cdots , e _r $.必然有$\omega \wedge e _1 = 0 $,从而导出$\exists \eta \in \bigwedge ^{ p - 1  } ( V ) \setminus \{ 0 \} $,$\omega = e _1 \wedge \eta $.从而导出$e _1 \wedge e _2 \wedge \eta = 0 $.因为$e _1 \wedge \eta \ne 0 $并且$e _1 \wedge e _2 \ne 0 $,这意味着$e _2 \wedge \eta = 0 , \cdots e _n \wedge \eta = 0 $,从而可以数学归纳.</p>
<p>现在我们尝试断言:$\omega $可分解的充要条件是$\dim \mathrm { ann  } ( \omega ) = p $.</p>
<p>先来看必要性,如果$\omega = x _1 \wedge \cdots \wedge x _p $,因为$\omega \ne 0 $,所以$x _1 , \cdots , x _p $线性无关.显然$\langle x _1 , \cdots , x _p \rangle \subseteq \mathrm { ann  } ( \omega ) $,然而左侧维数是$p $,右侧维数$\leq p $.比较维数知道两边相等.</p>
<p>再看充分性,假设$\mathrm { ann  } ( \omega ) $的基是$e _1 , \cdots , e _r $,我们已经断言过存在$\eta \in \bigwedge ^{ p - r  } ( V ) $使得$\omega = t ( e _1 \wedge \cdots \wedge e _r \wedge \eta ) $,当$p = r $的时候得到$\omega $可分解.</p>
<p>还可以证明以下两个结论:</p>
<ol>
<li><p>所有的$\omega \in \bigwedge ^{ n - 1  } ( V ) $都是可分解的.</p>
</li>
<li><p>设$\mathrm { char  } ( F ) \ne 2 , n \geq 2 $,则$\omega \in \bigwedge ^2 ( V ) $可分解当且仅当$\omega \wedge \omega = 0 $.</p>
</li>
</ol>
<p>对于(1),考虑选取一组基$v _1 , \cdots , v _n $,则$\omega \wedge v = c ( v ) v _1 \wedge \cdots \wedge v _n $,其中$c : V \to F $显然是线性映射.既然如此,$\dim \ker c = n - 1 $,从而导出$\mathrm { ann  } ( \omega ) = \ker c $的维数也是$n - 1 $,这就搞定了.</p>
<p>对于(2),首先必要性显然.对于充分性,一个朴素的证明是基于归纳法的:</p>
<p>对$\dim V $的大小进行归纳,取一组基$e _1 , \cdots e _n $,令$V _1 = \langle e _2 , \cdots , e _n \rangle $则$\omega = e _1 \wedge v + \eta $的形式,其中$v \in V _1 , \eta \in \bigwedge ^2 ( V _1 ) $,根据归纳假设其可分解,设$\eta = x \wedge y $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
0 & = \omega \wedge \omega \\
0 & = ( e _1 \wedge v + x \wedge y ) \wedge ( e _1 \wedge v + x \wedge y ) \\
0 & = e _1 \wedge v \wedge x \wedge y \\
0 & = v \wedge x \wedge y \\

\end{aligned}</script><p>既然如此,说明$v , x , y $线性相关.如果$x = 0 $或者$y = 0 $当然就做完了,反之必有$v = ax + by $.那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\omega & = e _1 \wedge ( ax + by ) + x \wedge y \\
& = ( x + be _1 ) \wedge ( y - ae _1 ) 
\end{aligned}</script><p>另一个策略是考虑$\bigwedge ^2 ( V ) \cong \mathrm { Bil  } ( V ^\vee , V ^\vee ; F ) $,而且右侧是反对称的.然而我们对辛形式早有研究,回忆到取基使得$B ( p _i , q _i ) = 1 $而当$i \ne j $的时候$B ( p _i , q _j ) = 0 $.用辛形式的分类得知存在一组基$u _1 , \cdots , u _r , v _1 , \cdots v _r $,其中$2 r \leq n $使得$\omega = \sum _{ i = 1  } ^r u _i \wedge v _i $.立刻见到$\omega \wedge \omega = 0 \Rightarrow r \in \{ 0 , 1 \} $.</p>
<h5><span id="简单应用">简单应用</span></h5><p>对于外代数来说,其最显然的应用是考虑$V = \mathbb { R  } ^3 $的情形,此时$\bigwedge ^2 ( V ) $有$\vec { e  } _1 \wedge \vec { e  } _2 , \vec { e  } _1 \wedge \vec { e  } _3 , \vec { e  } _2 \wedge \vec { e  } _3 $三个基,并且:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x \vec { e  } _1 + y \vec { e  } _2 + z \vec { e  } _3 ) \wedge ( x ' \vec { e  } _1 + y ' \vec { e  } _2 + z ' \vec { e  } _3 ) \\
& = ( xy ' - x ' y ) ( \vec { e  } _1 \wedge \vec { e  } _2 ) + ( yz ' - y ' z ) ( \vec { e  } _2 \wedge \vec { e  } _3 ) + ( zx ' - z ' x ) ( \vec { e  } _3 \wedge \vec { e  } _1 ) 
\end{aligned}</script><p>这其实就是叉积对吧.</p>
<h4><span id="域的变换">域的变换</span></h4><p>对于域$F \subseteq E $,如果我们有一个定义在$F $上的向量空间$V $,我们想要一种策略将其典范地推广到$E $上的向量空间$V _E $.</p>
<p>将$E $视作一个$F $向量空间.乘法映射$E \times E \to E $当然是双线性映射,从而诱导出$E \otimes E \to E , x \otimes y \mapsto xy $的映射.</p>
<p>考虑一个$F $向量空间$V $,考虑下述线性映射:</p>
<script type="math/tex; mode=display">
\begin{gathered}
E \times ( E \otimes _F V ) \to E \otimes _F ( E \otimes _F V ) \cong ( E \otimes _F E ) \otimes _F V \to E \otimes _F V \\
( x , y \otimes _F v ) \mapsto x \otimes _F ( y \otimes v ) \mapsto ( x \otimes _F y ) \otimes _F v \mapsto ( xy ) \otimes _F v 
\end{gathered}</script><p>于是$E \otimes _F V $成为了一个$E $线性空间.</p>
<p>另一个重要的是检验如果$V , W $都是$F $向量空间,则上述拓展后$\mathrm { Hom  } ( V _E , W _E ) $亦然构成$E $向量空间.而且我们还要检验如果原本的$f : V \cong W $,则$f _E : V _E \cong W _E $.</p>
<p>取$V $的一组基$\{ v _i \} _{ i \in I  } $,则:</p>
<script type="math/tex; mode=display">
V _E = E \otimes _F ( \bigoplus _{ i \in I  } F v _i ) \cong \bigoplus _{ i \in I  } ( E \otimes _F F ) \cong E ^{ \oplus I  }</script><p>从而我们知道$V _E $有一组基:$\{ \tilde { v  } _i = 1 _E \otimes v _i \} _{ i \in I  } $,推论是$\dim _F V = \dim _E V _E $.</p>
<p>接下来将$\mathrm { Hom  } _F ( F ^n , F ^m ) $等同于矩阵$A \in M _{ m \times n  } ( F ) $,我们下面验证$A _E = 1 _E \otimes A $.只需发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
A _E ( \tilde { e  } _i ) & = ( 1 _E \otimes A ) ( 1 _E \otimes e _i ) \\
& = 1 _E \otimes ( Ae _i ) \\
& = 1 _e \otimes ( \sum _{ k = 1  } ^n a _{ k , i  } e _k ) \\
& = \sum _{ k = 1  } ^n a _{ k , i  } ( 1 _E \otimes e _k ) \\
& = \sum _{ k = 1  } ^n a _{ k , i  } \tilde { e _k  } 
\end{aligned}</script><p>考虑$i : V \to V _E , v \mapsto 1 _E \otimes v $可以作为一个$F $线性映射,方法是将$V _E $限制成一个$F $向量空间.这显然是一个单射.</p>
<p>下面假设$V $是一个$F $向量空间,$\tilde { V  } $是一个$E $向量空间,则我们下面来证明最后的结论:</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm { Hom  } _E ( V _E , \tilde { V  } ) \cong \mathrm { Hom  } _F ( V , \tilde { V  } ) \\
\tilde { f  } \mapsto \tilde { f  } \circ i 
\end{gathered}</script><p>先证明这的确是一个单射,考虑:</p>
<script type="math/tex; mode=display">
\tilde { f  } ( t \otimes v ) = \tilde { f  } ( t \cdot i ( v ) ) = t \cdot ( \tilde { f  } \circ i ) ( v )</script><p>由于$i $是一个单射,所以这里如果非单,则存在两个$\tilde { f  } _1 , \tilde { f _2  } $满足$\forall v $,$( \tilde { f  } _1 \circ i ) ( v ) = ( \tilde { f  } _2 \circ i ) ( v ) $,必然导出$\forall t \otimes v , \tilde { f  } _1 ( t \otimes v ) = \tilde { f  } _2 ( t \otimes v ) $.</p>
<p>接下来考虑其满射,对于$f \in \mathrm { Hom  } _F ( V , \tilde { V  } ) $,考虑$E \times V \to \tilde { V  } , ( t , v ) \mapsto t f ( v ) $当然是一个$F $上的双线性映射,其对应了一个$\tilde { f  } : E \otimes _F V \to \tilde { V  } , t \otimes v \mapsto tf ( v ) $.这就论证了满性.</p>
<p>好吧,我们上面论证的一切都太过无趣,但请来总结,我们实际上是想要这么做:假设我有$F $上的向量空间$V $,$E $上的向量空间$\tilde { V  } $以及它们之间的$F $线性映射$f $.关于这个$f $的看法,如果我们将$\tilde { V  } $拉到$F $上当然是可以的对吧,那能不能将$V $升上$E $呢?我们想要一个资料$( \tilde { V  } _{ \mathrm { univ  }  } , f _{ \mathrm { univ  }  } ) $使得下述图表交换:</p>
<script type="math/tex; mode=display">
\xymatrix { V \ar [r ] ^{ f _{ \mathrm { univ  }  }  } \ar [rd ] _{ f  } & \tilde { V  } _{ \mathrm { univ  }  } \ar [d ] ^{ \tilde { f  }  } \\
& \tilde { V  }  }</script><p>我们上面所证明的就是这个资料$( \tilde { V  } _{ \mathrm { univ  }  } , f _{ \mathrm { univ  }  } ) $可以取作$( E \otimes _F V , i ) $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3><p>三个柱子,$n $个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T _n $表示答案,显然$T _0 = 0 , T _1 = 1 $.</p>
<p>而我们一定可以找到一种方案,使得前$n - 1 $个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把$n - 1 $个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:$T _n \leq 2 T _{ n - 1  } + 1 $.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:$2 T _{ n - 1  } + 1 \leq T _n $.于是有$T _n = 2 T _{ n - 1  } + 1 $.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4><p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4><p>考虑设$T _n $为n个圆盘时的最小操作次数.假设已知$T _{ n - 1  } $,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T _{ n  } = 3 T _{ n - 1  } + 2 , T _0 = 0 $.</p>
<p>考虑如何求该式子的封闭形式,令$W _n = T _n + 1 $,显然有$W _n = 3 W _{ n - 1  } , W _0 = 1 $,显然$W _n = 3 ^n $,有$T _n = 3 ^n - 1 $.</p>
<p>注意到$T _n $刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4><p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2 ^n - 1 $.</p>
<h4><span id="solution-2">Solution 2</span></h4><p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4><p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4><p>令$Q _n $为将n个圆盘从A移动到B的最小操作次数,令$R _n $为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q _0 = 0 , R _0 = 0 $.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q _n $的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,$R _n $的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q _n = 2 R _{ n - 1  } + 1 , 1 \leq n $.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R _n = R _{ n - 1  } + 1 + Q _{ n - 1  } + 1 + R _{ n - 1  } = Q _n + Q _{ n - 1  } + 1 , 1 \leq n $.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4><p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4><p>a.仍然令$T _n $为n对圆盘的最小操作次数,显然$T _n = 2 T _{ n - 1  } + 2 , T _0 = 0 $,可解得$T _n = 2 ^{ n + 1  } - 2 $.</p>
<p>b.令$Q _n $为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现$Q _n = T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } = 4 T _{ n - 1  } + 3 = 2 ^{ n + 2  } - 5 $.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q _n $就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4><p>类似Problem11,但第$i $大的圆盘有$k _i $个.</p>
<h4><span id="solution-5">Solution 5</span></h4><p>无区别,只是$T _n = 2 T _{ n - 1  } + k _n , T _0 = 0 $.</p>
<p>如果求封闭形式的话,显然有$T _n = \sum _{ i = 1  } ^n 2 ^{ n - i  } k _i $.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3><p>在上述问题中，我们已经有了以下式子：</p>
<p>$T _n = 2 T _{ n - 1  } + 1 , n &gt; 0 , T _0 = 0 $.</p>
<p>如果$n $很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出$T _n $的方法.</p>
<p>换句话说，我们想要把$T _n $表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4><h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5><p>解递归式:$Q _n = \begin{cases}\alpha &amp; n = 0 \ \beta &amp; n = 1 \ \frac { ( 1 + Q _{ n - 1  } )  } { Q _{ n - 2  }  } &amp; n &gt; 1 \end{cases} $,保证$\forall n , Q _n &gt; 0 $.</p>
<h5><span id="solution">Solution</span></h5><p>注意到$Q _2 = \frac { \beta + 1  } { \alpha  } , Q _3 = \frac { \beta + \alpha + 1  } { \beta \alpha  } , Q _4 = \frac { 1 + \alpha  } { \beta  } , Q _5 = \alpha , Q _6 = \beta $.</p>
<p>显然该递归式存在长度为$5 $的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4><p>观察T序列的前几项，可以发现似乎有$T _n = 2 ^n - 1 $.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n = 0 $成立，显然可验证.</p>
<p>2.若该公式对$n = k $时成立，那该公式必然对$n = k + 1 $成立.</p>
<p>因为有$T _{ k + 1  } = 2 T _k + 1 = 2 \times 2 ^k + 2 - 1 = 2 ^{ k + 1  } - 1 $.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5><p>求证:$\prod _{ i = 1  } ^n x _i \leq ( \frac { \sum _{ i = 1  } ^n x _i  } { n  } ) ^n , \forall i \in N _+ , 1 \leq i \leq n , 0 \leq x _i $.</p>
<h5><span id="solution">Solution</span></h5><p>使用反向归纳法.</p>
<p>1.$n = 2 $时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n = k $时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A _1 = \sqrt [k ] { \prod _{ i = 1  } ^k x _i  } , B _1 = \sqrt [k ] { \prod _{ i = k + 1  } ^{ 2 k  } x _i  } , A _2 = ( \frac { \sum _{ i = 1  } ^k x _i  } { k  } ) , B _2 = ( \frac { \sum _{ i = k + 1  } ^{ 2 k  } x _i  } { k  } ) $,显然有$A _1 \leq A _2 , B _1 \leq B _2 $.</p>
<p>同时有$( \frac { A _2 + B _2  } { 2  } ) \geq \sqrt { A _2 B _2  } \geq \sqrt { A _1 B _1  } $.</p>
<p>3.若该式子对$n = k $时成立,则该式子对$n = k - 1 $的时候也成立.</p>
<p>令$x _k = \frac { \sum _{ i = 1  } ^{ k - 1  } x _i  } { k - 1  } $,有$x _k \prod _{ i = 1  } ^{ k - 1  } x _i \leq ( x _k ) ^k $.</p>
<p>则显然$n = k - 1 $时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4><p>考虑令$U _n = T _n + 1 $,显然有:$T _n + 1 = 2 T _{ n - 1  } + 2 $.即$U _n = 2 U _{ n - 1  } $,显然$U _n = 2 ^n $,则$T _n = 2 ^n - 1 $.</p>
<p>这个做法可以做掉所有形如$a _{ n + 1  } = pa _n + q $的递归式.我们有:</p>
<script type="math/tex; mode=display">
a _{ n + 1  } + \frac { q  } { p - 1  } = p ( a _n + \frac { q  } { p - 1  } )</script><p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4><p>考虑递归式$a _n T _n = b _n T _{ n - 1  } + c _n $.如果我们能找到一个不为0的求和因子$s _n $并满足$s _n b _n = s _{ n - 1  } a _{ n - 1  } $.那么我们两面同时乘以$s _n $,显然有：$s _n a _n T _n = s _{ n - 1  } a _{ n - 1  } T _{ n - 1  } + c _n s _n $.</p>
<p>令$S _n = s _n a _n T _n $.显然有$S _n = s _0 a _0 T _0 + \sum _{ i = 1  } ^n s _i c _i $,则$T _n = \frac { S _n  } { s _n a _n  } $.</p>
<p>而我们也会发现$s _n = \frac { \prod _{ i = 1  } ^{ n - 1  } a _i  } { \prod _{ i = 1  } ^n b _i  } $.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5><p>结论:排序$n $个数时,其期望复杂度满足:</p>
<script type="math/tex; mode=display">
C _n = \begin{cases}
0 & n = 0 , 1 \\
n + 1 + \frac { 2  } { n  } \sum _{ i = 0  } ^{ n - 1  } C _k & n > 1 
\end{cases}</script><p>不妨考虑两边同时乘以$n $,有 $nC _n = n ^2 + n + 2 \sum _{ i = 0  } ^{ n - 1  } C _i , n &gt; 1 $ .</p>
<p>显然也有$( n - 1 ) C _{ n - 1  } = ( n - 1 ) ^2 + n - 1 + 2 \sum _{ i = 0  } ^{ n - 2  } C _i , n &gt; 2 $.</p>
<p>二式相消,有$nC _n - ( n - 1 ) C _{ n - 1  } = 2 n + 2 C _{ n - 1  } , n &gt; 2 $.</p>
<p>而同时有$C _2 = 3 $.即:$nC _n = ( n + 1 ) C _{ n - 1  } + 2 n , n &gt; 2 $,可以使用转化和式的方法,两边乘以$\frac { 1  } { n ( n + 1 )  } $解决.</p>
<h5><span id="example2">Example2</span></h5><p>已知$a _1 = 1 $,$a _n = \sqrt { S _n  } + \sqrt { S _{ n - 1  }  } $,求$a _n $.</p>
<p>注意到$a _n = S _n - S _{ n - 1  } $,则有$\sqrt { S _n  } - \sqrt { S _{ n - 1  }  } = 1 $,于是$\sqrt { S _n  } = n $,$S _n = n ^2 $,$a _n = 2 n - 1 $.</p>
<h4><span id="成套方法">成套方法</span></h4><p>如果我们有</p>
<p>\alpha &amp; n=1\\</p>
<p>2f(\frac n 2)+\beta &amp; n=2k,k\in \mathbb{N_+}\\</p>
<p>2f(\frac {n-1}2)+\gamma &amp;n=2k+1,k\in \mathbb{N_+}</p>
<p>\end{cases}</p>
<p>其中$n = 2 ^m + l $且$2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>该如何求出$f ( n ) $的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有$f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n ) \gamma $,而有$A 、 B 、 C $互不影响且$\alpha \beta \gamma $与$ABC $无关.</p>
<p>那无论$\beta $和$\gamma $的取值如何,$A ( n ) $都不会受到影响,我们考虑$\beta = \gamma = 0 $的特殊情况,此时显然有$A ( n ) = 2 ^m $.</p>
<p>接下来,我们考虑取$\alpha \beta \gamma $的特殊值,去得到ABC之间的关系.</p>
<p>例如，当$f ( n ) = 1 $时，由递推式可知$\alpha = 1 , \beta = \gamma = - 1 $,那么有$A ( n ) - B ( n ) - C ( n ) = f ( n ) = 1 $.</p>
<p>同理，$f ( n ) = n $时，可知$\alpha = 1 , \beta = 0 , \gamma = 1 $,此时有$A ( n ) + C ( n ) = f ( n ) = n $.</p>
<p>显然可以通过解方程求得$B ( n ) $和$C ( n ) $.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC $互不影响且$\alpha \beta \gamma $与$ABC $无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>直接在复数域上定义$f _k ( x ) = \{ n ^k x ^n \} _{ n = 0  } ^\infty $,此时我们规定$0 ^0 = 1 $.特别地,当$x = 0 $的时候,定义$f _k ( x ) $的第$k $项是$1 $,其余项是$0 $.在此基础上定义线性映射$T : ( a _n ) _{ n = 0  } ^\infty \mapsto ( a _{ n + 1  } ) _{ n = 0  } ^\infty $,立刻见到:$( T - x ) ^{ k + 1  } f _k ( x ) = 0 , ( T - x ) ^k f _k ( x ) \ne 0 $.原因只需简单数学归纳.而此还可以引出$f _0 ( x ) , f _1 ( x ) , \cdots $线性无关.</p>
<p>在此基础上观察线性递推$a _{ n + d  } = c _{ d - 1  } a _{ n + d - 1  } + \cdots + c _0 a _n $,不妨取$G ( x ) = x ^d - c _{ d - 1  } x ^{ d - 1  } - \cdots - c _0 $,立刻应当见到如果$a $是$G $的根并且重数为$e ( a ) $,那么$f _{ 0  } ( x ) , \cdots , f _{ e ( a ) - 1  } ( a ) $都在$\ker f ( T ) $中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如$\sum _j w _i f _i ( y ) = \sum _j w _j f _j ( x ) $的情况,此时对右边直接操作若干次$( T - x ) $就可以把右边全部消成$0 $,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于$n $的多项式右边的$( T - x ) $是不会改变左边这边的每一个位置多项式的$\deg $,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3><p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是$2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 , 9 $.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有$J ( 2 n ) = 2 J ( n ) - 1 $;当人数是奇数时,我们杀掉一号,然后有$J ( 2 n + 1 ) = 2 J ( n ) + 1 $.</p>
<p>整理得到:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 1 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>仍然可以使用数学归纳，如果令$n = 2 ^m + l 且 2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>有$J ( n ) = 2 l + 1 $.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从$0 $开始编号:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
0 & n = 1 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>这下相信$J ( n ) $是多少就很显然了,将$n $写成二进制的形式,这个就相当于把首位$1 $抹去然后在末尾加个$0 $.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4><p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4><p>显然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
2 & n = 2 \\
1 & n = 3 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>从$0 $开始编号,自然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 2 \\
0 & n = 3 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>显然$J ( n ) $也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2><h3><span id="和式的基本运算">和式的基本运算</span></h3><p>分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i</script><p>一般分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j )</script><p>结合律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i</script><p>交换律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  }</script><p>交换求和顺序:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] & = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] \\
\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } & = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } 
\end{aligned}</script><h3><span id="和式的封闭形式">和式的封闭形式</span></h3><h4><span id="交换顺序法">交换顺序法</span></h4><h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i < j \leq n  } ( a _j - a _i ) ( b _j - b _i ) 
\end{aligned}</script><p>显然有以下式子:</p>
<p>(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\geq n\sum_{i=1}^na_ib_i，\forall i&lt;j，a_i\leq a_j且b_i\geq b_j\\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5><p>证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 & = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \\

\end{aligned}</script><p>有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 \\
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k + a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5><p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n i ^2 & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推,我们设$W _n = \sum _{ i = 0  } i ^3 $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5><p>令$H _n = \sum _{ k = 1  } ^n \frac { 1  } { k  } $,求$\sum _{ i = 0  } ^n H _i $.</p>
<h5><span id="solution3">Solution3</span></h5><p>不妨考虑$\sum _{ i = 0  } ^n iH _{ i  } $的值.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^n iH _{ i  } & = \sum _{ i = 1  } ^n [ ( i - 1 + 1 ) H _{ i - 1  } + 1 ] \\
& = n + \sum _{ i = 0  } ^{ n - 1  } H _i + \sum _{ i = 0  } ^{ n  } iH _i - nH _n \\
\sum _{ i = 0  } ^{ n - 1  } H _i & = n ( H _n - 1 ) \\
\sum _{ i = 0  } ^n H _i & = ( n + 1 ) ( H _{ n + 1  } - 1 ) \\

\end{aligned}</script><h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5><p>求$S _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } , T _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i , U _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i ^2 $.</p>
<h5><span id="solution-4">Solution 4</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 1  } ^{ n  } ( - 1 ) ^{ n - i  } + ( - 1 ) ^n \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - 1 - i  } \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + S _{ n - 1  } \\
S _{ n - 1  } & = \frac { 1 - ( - 1 ) ^n  } { 2  } \\
S _n & = \frac { 1 + ( - 1 ) ^n  } { 2  } 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
T _{ n  } & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i \\
- T _{ n - 1  } + n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- T _{ n - 1  } + n & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } - ( - 1 ) ^n \\
- T _{ n - 1  } + n & = T _{ n - 1  } + S _n - ( - 1 ) ^n \\
n - \frac { 1 - ( - 1 ) ^n  } { 2  } & = 2 T _{ n - 1  } \\
T _n & = \frac { 1  } { 2  } ( n + 1 + \frac { - 1 - ( - 1 ) ^n  } { 2  } ) & = \frac { 1  } { 2  } ( n + \frac { 1 - ( - 1 ) ^n  } { 2  } ) 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
U _n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 + 1 ) ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) ^2 + 2 \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i ^2 + 2 \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } \\
- U _{ n - 1  } + n ^2 & = U _{ n - 1  } + 2 T _{ n - 1  } + S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - 2 T _{ n - 1  } - S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - ( n - \frac { 1 - ( - 1 ) ^n  } { 2  } ) - \frac { 1 - ( - 1 ) ^n  } { 2  } \\
2 U _{ n - 1  } & = n ^2 - n \\
U _n & = \frac { n ( n + 1 )  } { 2  } 
\end{aligned}</script><h4><span id="转化为递归式">转化为递归式</span></h4><p>考虑和式$S _n = \sum _{ i = 0  } ^n f ( i ) = S _{ n - 1  } + f ( n ) \ $，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5><p>求$\sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 \ $.</p>
<h5><span id="solution1">Solution1</span></h5><p>令$S ( n ) = \sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 = S ( n - 1 ) + ( - 1 ) ^n n ^2 $,考虑使用成套方法.</p>
<p>不妨令$S ( n ) = S ( n - 1 ) + ( - 1 ) ^n ( \alpha + \beta n + \gamma n ^2 ) = \alpha A ( n ) + \beta B ( n ) + \gamma C ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n , 可 以 解 得 \alpha = - 1 , \beta = 2 , \gamma = 0 $,有$( - 1 ) ^n n = - A ( n ) + 2 B ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n ^2 , 可 以 解 得 \alpha = 1 , \beta = - 2 , \gamma = 2 $,有$( - 1 ) ^n n ^2 = A ( n ) - 2 B ( n ) + 2 C ( n ) $.</p>
<p>显然可解得$2 C ( n ) = ( - 1 ) ^n n ^2 + ( - 1 ) ^n n , C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<p>而原式中,$S ( n ) = C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5><p>有$2 T _n = nT _{ n - 1  } + 3 n ! , T _0 = 5 $,求$T _n $.</p>
<h5><span id="solution-2">Solution 2</span></h5><p>令$s _n = \frac { 2 ^{ n - 1  }  } { n !  } $,两边同时乘以$s _n $,有$\frac { 2 ^n  } { n !  } T _n = \frac { 2 ^{ n - 1  }  } { ( n - 1 ) !  } T _{ n - 1  } + 3 \times 2 ^{ n - 1  } \ $.</p>
<p>令$S _n = \frac { 2 ^n  } { n !  } T _n $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = S _{ n - 1  } + 3 \times 2 ^{ n - 1  } \\
& = 5 + 3 \sum _{ i = 0  } ^{ n - 1  } 2 ^i \\
& = 5 + 3 \times 2 ^{ n + 1  } - 3 \\
& = 3 \times 2 ^{ n  } + 2 \\
T _n & = 3 n ! + \frac { n !  } { 2 ^{ n - 1  }  } 
\end{aligned}</script><h4><span id="转化为积分形式">转化为积分形式</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数$f ( x ) = x ^2 $,显然$\int _0 ^n x ^2 dx = \frac { n ^3  } { 3  } \sim S _n \ $.</p>
<p>接下来,我们考虑求得二者之间的误差,设$E _n = S _n - \frac { n ^3  } { 3  } \ $,对其使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \frac { n ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 + 1 ) ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 ) ^3  } { 3  } - ( n - 1 ) ^2 - ( n - 1 ) - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n ^2 - n ^2 + 2 n - 1 - n + 1 - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n - \frac { 1  } { 3  } 
\end{aligned}</script><p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \int _0 ^n x ^2 dx \\
& = \sum _{ k = 1  } ^n ( k ^2 - \int _{ k - 1  } ^k x ^2 dx ) \\
& = \sum _{ k = 1  } ^n ( k ^2 - \frac { k ^3 - ( k - 1 ) ^3  } { 3  } ) \\
& = \sum _{ k = 1  } ^n ( k - \frac { 1  } { 3  } ) 
\end{aligned}</script><p>这是一个简单的和式.而$S _n = E _n + \frac { n ^3  } { 3  } \ $,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5><p>已知$a _1 = 1 , a _{ n + 1  } - a _n = - \frac { 1  } { 3  } a _n ^2 $,估计$a _n $的值.</p>
<p>考虑构造一个函数$f ( n ) $使得$f ( n ) \approx a _n $,那我们就可以将$a _{ n + 1  } - a _n \approx f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$\exists x _0 \in [ n , n + 1 ] , f ‘ ( x _0 ) = f ( n + 1 ) - f ( n ) $,而对于增长率变化不大的函数,直接认为$f ‘ ( x _0 ) = f ‘ ( n ) $是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 $解得$f ( n ) = \frac { 3  } { n + 2  } $.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令$a _n = \frac { 3  } { n + 2  } - b _n $,带入化简,得到$\{ b _n \} $的递推式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } & = ( \frac { 3  } { n + 2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _{ n + 1  } - \frac { 3  } { n + 3  } & = ( b _n - \frac { 3  } { n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 & = 0 , b _{ n + 1  } & = \frac { b _n ^2  } { 3  } + \frac { n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  } 
\end{aligned}</script><p>算到这里,我们可以很轻易使用数学归纳法算出$b _n \leq \frac { 1  } { 4 n  } $,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n $的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设$b _n ^2 &lt; &lt; b _n $:</p>
<p>那么这个$b _n $是$O ( \frac { \ln n  } { n ^2  } ) $级别的.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b _{ n + 1  } & = \frac { n  } { n + 2  } b _n + \frac { 1  } { n ( n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } & = n ( n + 1 ) b _n + \frac { 1  } { n  } \\
g ( n ) & = n ( n + 1 ) b _n , g ' ( n ) & = \frac { 1  } { n  } , g ( n ) & = \ln n \\
b _n & = \frac { \ln n  } { n ^2  } 
\end{aligned}</script><p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ \epsilon  } ) $和$O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n \leq \frac { 3 \ln n  } { n ( n + 1 )  } $.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5><p>求$\sum _{ i = 1  } ^n i 2 ^i \ $.</p>
<h5><span id="solution-2">Solution 2</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n i 2 ^i & = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i 2 ^i \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n 2 ^i \\
& = \sum _{ j = 1  } ^n ( 2 ^{ n + 1  } - 2 ^j ) \\
& = n 2 ^{ n + 1  } - ( 2 ^{ n + 1  } - 2 ) \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 
\end{aligned}</script><h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<h5><span id="solution-3">Solution 3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="exampleex">ExampleEX</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solutionex">SolutionEX</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="exampleex2">ExampleEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( x ) & = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x & = f ( x ) + C \\

\end{aligned}</script><p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( x ^{ \underline { m  }  } ) & = mx ^{ \underline { m - 1  }  } \\
\sum mx ^{ \underline { m - 1  }  } \delta x & = x ^{ \underline { m  }  } + C , m \ne 0 \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( H ( x ) ) & = x ^{ \underline { - 1  }  } & = \frac { 1  } { x + 1  } \\
\sum x ^{ \underline { - 1  }  } \delta x & = H ( x ) + C \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( 2 ^x ) & = 2 ^x , \sum 2 ^x \delta x & = 2 ^x + C \\
\Delta ( c ^x ) & = ( c - 1 ) c ^x , \sum c ^x \delta x & = \frac { c ^x  } { c - 1  } + C , c \ne 1 \\
\Delta ( c ^{ \underline { x  }  } ) & = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x & = c ^{ \underline { x  }  } + C , c - x \ne 0 \\

\end{aligned}</script><p>根据组合数公式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( \binom { x  } { k  } ) & = \binom { x  } { k - 1  } \\
\sum \binom { x  } { k - 1  } \delta x & = \binom { x  } { k  } + C 
\end{aligned}</script><h6><span id="example平方和公式">Example(平方和公式)</span></h6><p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5><p>考虑一阶差分是$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $,那么二阶差分就是$\Delta ^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f ( x ) $.</p>
<p>类似地,我们可以通过归纳法证明$\Delta ^n f ( x ) = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } f ( x + k ) \ $.</p>
<p>事实上有一种更简单的证明方法,由于$\Delta = E - 1 $,于是$\Delta ^n = ( E - 1 ) ^n = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } E ^k \ $,由于$E ^k f ( x ) = f ( x + k ) $,即可证明原式.</p>
<p>另外,不难发现如果$f ( x ) $是一个关于$x $的$d $次多项式,那么$\Delta f ( x ) $是一个$d - 1 $次多项式.同理,$\Delta ^d f ( x ) $会是一个常数而$\Delta ^{ d + 1  } f ( x ) $会是$0 $,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6><p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为$x _1 , x _2 $.</p>
<p>不难写出期望转移式子:$f _i = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 $,并且$f _{ x _1  } = f _{ x _2  } = 0 $.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _i & = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 \\
2 f _i & = f _{ i - 1  } + f _{ i + 1  } + 2 \\
f _i - f _{ i - 1  } & = f _{ i + 1  } - f _i + 2 \\
\Delta f _{ i - 1  } & = \Delta f _{ i  } + 2 \\
\Delta f _i - \Delta f _{ i - 1  } & = - 2 \\
\Delta ^2 f _{ i - 1  } & = - 2 
\end{aligned}</script><p>$f $的二阶差分是常数,也就是说$f $是二次多项式,不难求得其二次项系数为$- 1 $又知道两个零点,显然可以得到$f $的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5><p>令$f ( x ) = \sum _{ 0 \leq i \leq d  } a _i x ^i \ $.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为$f ( x ) = \sum _{ 0 \leq i \leq d  } b _i x ^{ \underline { i  }  } \ $.</p>
<p>我们设$c _i = i ! b _i $,于是有:$f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i  } \ $.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为$f ( x ) $的牛顿级数.</p>
<p>于是不难发现有:$\Delta ^n f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i - n  } \ $.如果我们令$x = 0 $,则有:$\Delta ^n f ( 0 ) = \begin{cases}c _n &amp; n \leq d \ 0 &amp; n &gt; d \end{cases} $.那么牛顿级数的另一种表示即:$f ( x ) = \sum _{ 0 \leq i \leq d  } \Delta ^i f ( 0 ) \binom { x  } { d  } \ $.</p>
<p>另外,如果我们展开一下$c _n = \Delta ^n f ( 0 ) $,我们可以得到公式:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } c _i \binom { k  } { i  } ) = ( - 1 ) ^n c _n , n \in \mathbb { N  } \ $.</p>
<p>如果我们将多项式还原,由于$a _n = b _n $,有:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } a _i k ^i ) = ( - 1 ) ^n n ! a _n , n \in \mathbb { N  } \ $.</p>
<p>另外,如果$x \in \mathbb { N  } $,那么我们有:$f ( x ) = \sum _{ 0 \leq k  } \Delta ^k f ( 0 ) \binom { x  } { 0  } $,根据多项式推理法,这个公式对$\forall x \in \mathbb { Z  } $都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<script type="math/tex; mode=display">
g ( a + x ) = \sum _{ 0 \leq k  } \cfrac { \Delta ^k g ( a )  } { k !  } x ^{ \underline { k  }  }</script><h6><span id="example">Example</span></h6><p>求$\sum _{ k  } \binom { n  } { k  } \binom { r - sk  } { n  } ( - 1 ) ^k , n \in \mathbb { N  } \ $.</p>
<p>如果我们令$f ( k ) = \binom { r - sk  } { n  } = \sum _{ 0 \leq i \leq n  } a _i k ^i \ $,不难发现$a _n = \cfrac { ( - 1 ) ^n s ^n  } { n !  } $,于是显然原式$= s ^n $.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \\
\sum _{ i = l  } ^{ r - 1  } ( \Delta a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( \Delta b _i ) 
\end{aligned}</script><p>对于$l = 0 , r = n , a _0 = b _0 = 0 $的特殊情况,应当有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } a _{ i + 1  } ( \Delta b _i ) \\
\sum _{ i = 1  } ^n a _i ( b _{ i + 1  } - b _i ) & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i 
\end{aligned}</script><p>取两组数列$\alpha , \beta $,并令$\sum _{ i = 1  } ^n \beta _i = B _i $,立刻有:</p>
<script type="math/tex; mode=display">
\sum _{ i = 1  } ^n \alpha _i \beta _i = \alpha _n B _n - \sum _{ i = 1  } ^{ n - 1  } ( \alpha _{ i + 1  } - \alpha _i ) B _i</script><h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<p>$\sum _{ k = 0  } ^n k 2 ^k = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 = ( n - 1 ) 2 ^{ n + 1  } + 2 \ $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<h6><span id="solution-3">Solution 3</span></h6><p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } & = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<h6><span id="solution-4">Solution 4</span></h6><p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">贪心与构造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="贪心">贪心</span></h2><h3><span id="排除不优策略">排除不优策略</span></h3><h5><span id="example1cf1612e">Example1(CF1612E)</span></h5><p>先把期望写开,我们发现如果选择了$t $个消息$a _1 , a _2 , . . . , a _t $,那么答案就是$\sum [ \exists j , m _i = a _j ] \cfrac { \min ( t , k _i )  } { t  } $.显然如果$t $固定,那么每个$a _j $的贡献是独立的.于是只需要枚举$t $然后取贡献最大的.</p>
<p>但是,如果$t &gt; \max \{ k _i \} $,这个时候$t - 1 $的答案是$t - 1 $个数之和除以$t - 1 $,$t $的答案是这$t - 1 $个数之和加上另一个更小的数除以$t $,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度$O ( n \max \{ k _i \} ) $.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5><p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分($b _{ i , j  } = a _{ i , j  } \oplus a _{ i + 1 , j  } \oplus a _{ i , j + 1  } \oplus a _{ i + 1 , j + 1  } $)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是$0 $了,那么矩阵外不可能是$1 $,也就是原矩阵也全都是$0 $了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成$0 $才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5><p>首先注意到,如果我们对$( x , y ) $使用操作四,那我们不可能再对一个$( x , i ) $使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有$b _{ x , y  } , b _{ n , y  } , b _{ x , m  } $都是$1 $的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个$1 $,所以一定不如直接用一操作来的划算.不然,如果三个都是$1 $,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后$b _{ n , m  } $变成$1 $了,再不行也可以使用一次$1 $操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果$b _{ x , y  } , b _{ n , y  } , b _{ x , m  } $都是$1 $,我们就把$x $到$y $连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5><p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i $条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i $表示第$i $个分界点可能的最小值,$g _i $表示第$i $个分界点可能的最大值.假设我们目前二分的最大值要小于等于$mx $,最小值要大于等于$mn $,那么我们有转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1  } & = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } & = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}</script><p>注意到$f $与$g $的转移是无关的,而显然对于第$i $个分界点,它可以取$[ f _i , g _i ] $中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans _{ i  } $表示第$i $条分界线是啥,那么我们$ans _i $是可以取$[ ans _{ i + 1  } - mx , ans _{ i + 1  } - mn ] $中的任何一个数字的,我们将其和上面求出的$[ f _i , g _i ] $求一下交集.如果交集为空,说明要么$ans _{ i + 1  } - mn &lt; f _i , f _{ i + 1  } &lt; ans _{ i + 1  } &lt; f _i + mn $,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差$\leq mx - mn $.</p>
<h5><span id="example52022zrtg十连测day7-palindrome">Example5(2022zrtg十连测day7 Palindrome)</span></h5><p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对$( l , r ) $,我们想给每一个点对赋值:$a _l = i , a _r = n - i + 1 $(注意如果$n $是奇数,那么中心点应该是$a _{ mid  } = \frac { n + 1  } { 2  } $),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对$( l _1 , r _1 ) $,$( l _2 , r _2 ) $之间的三种可能的关系:不交,包含,相交且不包含.会发现若$l $小则让$a _l $尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5><p>强强题.</p>
<p>首先发现这个$\pm 1 $操作很奇怪.我们不妨这么考虑:设最后的答案序列为$b $,那么答案其实就是$\sum | b _i - a _i | $.这实际上是什么呢?实际上是数轴上$a _i $和$b _i $之间的距离.既然这样,那么我们同时反转$a $和$b $,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个$a $,将它和$x $同时反转,那么答案不变.这么做后我们可以直接清空所有$a $的最高位,只剩下$x $可能有最高位.</p>
<p>那$x $的最高位一定会让若干$a $往上变成它.注意到最多只会有一个$a $会向上满足$x $的最高位.证明的话同样考虑取反,如果有两个$a $满足$a _i \oplus b _i $和$a _j \oplus b _j $这一位是$1 $,我们仍然考虑数轴,有$| not ( b _i ) - a _i | \leq | a _i - b _i | $,这由$a _i \oplus b _i $最高位是$1 $导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个$a $上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的$a $可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5><h5><span id="example8">Example8()</span></h5><h3><span id="带悔贪心">带悔贪心</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个数组,给出若干次操作$[ l , r , k ] $表示可以将$a [ l \cdots r ] $减一进行至多$k $次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5><p>给定一个序列,每次可以选择相邻的两个数,使其中一个$- 1 $,另一个$- 2 $,求使得整个序列都小于等于$0 $的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol>
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p>
</li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p>
</li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p>
</li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做$( - 2 , - 1 ) $,最后不够了再加个$( - 1 , - 2 ) $补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候$( - 1 , - 2 ) + ( - 1 , - 2 ) $比$( - 2 , - 1 ) $更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做$( - 2 , - 1 ) $,最后不够了再加个$( - 1 , - 2 ) $补一下.我们通过样例以及其它栗子发现:有的时候$( - 1 , - 2 ) + ( - 1 , - 2 ) $比$( - 2 , - 1 ) $更优秀,这启发我们:能不能在做后面位置的时候将前面的$( - 2 , - 1 ) $变成$( - 1 , - 2 ) + ( - 1 , - 2 ) $呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个$( - 2 , - 1 ) $操作,那么我可以在这个位置进行一个$( 0 , - 3 ) $操作.显然$( 0 , - 3 ) + ( - 2 , - 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2 ) $.我们完成了反悔的操作!</p>
<p>但是,我们直接认为$( - 1 , - 2 ) $不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个$( - 1 , - 2 ) + ( - 1 , - 2 ) $,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑$( - 3 , 0 ) $怎么反悔.这个看上去很疑惑:我们为了使$( - 2 , - 1 ) $变成$( - 1 , - 2 ) + ( - 1 , - 2 ) $而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在$( - 2 , - 1 ) $的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:$( - 3 , 0 ) $这个技能的发动是有前提条件的:前面必须有$( - 2 , - 1 ) $才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个$( - 2 , - 1 ) $,也很清楚每个地方用了几个$( - 3 , 0 ) $.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:$( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 2 , - 1 ) = ( - 3 , 0 ) + ( 0 , - 3 ) $,或者$( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 1 , - 2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3 ) $.</p>
<p>最后遇到一个点,能用$( 0 , - 3 ) $就用$( 0 , - 3 ) $,不够用的再补齐.这个原因也很简单:如果我们在这里不用$( - 3 , 0 ) $而用其它的代替的话,你会发现无论如何都等价于$( - 3 , 0 ) $然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的$( - 2 , - 1 ) $和$( - 1 , - 2 ) $的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的$( - 3 , 0 ) $操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3><h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5><p>给你一个长度为$n $的序列$a $,保证$a _1 = a _n = 1 $.每次你可以选择一个$i ( 1 &lt; i &lt; n ) $将$a _i $删去并付出$a _{ i - 1  } a _i a _{ i + 1  } $的代价.删去$a _i $后序列两端会接起来,求删成两个$1 $的最小代价.</p>
<p>首先注意到,如果有一个$1 &lt; i &lt; n $满足$a _i = 1 $,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要$1 $的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个$1 $所划分.接下来我们只考虑中间所有数$\geq 2 $的情况.</p>
<p>再思考一个事实:当$a , b \geq 2 $时,一定有$ab \geq a + b $.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是$\sum _{ i = 2  } ^{ n - 2  } a _i a _{ i + 1  } + \min _{ i = 2  } ^{ n - 1  } { a _i  } $.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5><p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造$a $数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5><p>给定一张图,每个点上有一个权值$a _i $,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5><p>先考虑$a _i $互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数$\leq $还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在$a _i $相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的$( a _i , a _{ i + 1  } ) $,然后这么选:$a _i , a _{ i + 1  } , a _n , a _{ i - 1  } , a _{ n - 1  } , a _{ i - 2  } . . . $,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在$a _i $上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5><p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是$a $和$b $,其中$2 a &lt; b $.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果$b $之前吃过别的鱼,假设是$c $和$d $(不妨假设$d \geq c $),有$b = c + d $,由鸽笼原理,发现$d &gt; a $.这意味着:如果$a $都没被操作掉,那么$d $必不可能被操作掉,这也就是说$b $不可能出现.因此$b $在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于$b $,且$a $就是所有一开始小于$b $的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是$w _i &gt; 2 \sum _{ j = 1  } ^{ i - 1  } w _j $,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多$\log w $个,我们考虑一下这个两倍的用处,我们按照值域$[ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , . . . , [ 2 ^{ k - 1  } + 1 , 2 ^k ] $将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5><p>给定$n $个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol>
<li><p>$S $表示标准球.</p>
</li>
<li><p>$&lt; A , B &gt; $表示称量集合$A $和集合$B $,$&lt; A , B &gt; = 0 $表示平衡,$&lt; A , B &gt; = A $表示$A $较重,$&lt; A , B &gt; = B $表示$B $较重.</p>
</li>
</ol>
<h6><span id="信息论">信息论</span></h6><p>如果一个随机变量$x $有$n $种取值,出现概率分别为$p _1 , p _2 , \cdots , p _n $,则其熵为$H ( x ) = f ( p _1 , p _2 , \cdots , p _n ) = \sum { C p _i \ln \frac { 1  } { p _i  }  } $,$C $为正整数,通常取$1 $.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量$x $的一个熵为$h $的信息后,$x $的熵会减少$h $.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有$n $个球,每个球等概率成为次品,因此总熵是$\ln n $,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是$\ln 3 $,也就是说我们至少要猜$\frac { \ln n  } { \ln 3  } = \log _3 n $次.如果我们不知道次品的轻重,那么至少要猜$\frac { \ln 2 n  } { \ln 3  } = \log _3 2 n $次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6><p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p>$n $个叶子的树的最小深度是$\lceil \log _3 n \rceil $,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6><p>不妨假设$f ( n ) $表示有$n $个球的最少次数,注意到$f ( 3 ) = 1 $.</p>
<p>根据信息论,$f ( n ) \geq \lceil \log _3 n \rceil $,下面证明等号成立:</p>
<p>首先考虑证明$f ( 3 ^m ) = m $,$m = 1 $时已经得证.$m &gt; 1 $时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此$f ( 3 ^m ) \leq f ( 3 ^{ m - 1  } ) + 1 $.综合信息论下界$f ( 3 ^m ) \geq m $,我们不难得出以上结论.至于$n \ne 3 ^m $的情况,我们类似这个过程按照$n \bmod 3 $的值讨论一下即可,于是有$f ( n ) \leq f ( \lceil \frac { n  } { 3  } \rceil ) + 1 $.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6><p>根据信息论下界,$f ( n ) \geq \lceil \log _3 2 n \rceil $.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有$n $个球,第二堆有$m $个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是$g ( n , m ) $,则$g ( n , m ) = \lceil \log _3 ( n + m ) \rceil $.</p>
<p>先证明信息论下界,不难发现仍然是$g ( n , m ) = \lceil \log _3 ( n + m ) \rceil $.</p>
<p>首先不难发现,$g ( 1 , 0 ) = g ( 0 , 1 ) = 0 , g ( 1 , 1 ) = g ( 2 , 0 ) = g ( 0 , 2 ) = 1 $.</p>
<p>仍然使用数学归纳,假设$n + m &lt; k ( k \geq 3 ) $的时候成立,我们接下来证明$n + m = k $的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若$n = 3 p , m = 3 q $,我们将$n $分成等数量的三堆:$A _1 , B _1 , C _1 $,将$m $分成等质量的三堆$A _2 , B _2 , C _2 $.</p>
<p>接下来称量$\lang A _1 + A _2 , B _1 + B _2 \rang $.</p>
<ol>
<li><p>如果$\langle A _1 + A _2 , B _1 + B _2 \rang = 0 $,那么答案在$C _1 \cup C _2 $中,此时有$g ( n , m ) = g ( \frac { n  } { 3  } , \frac { m  } { 3  } ) + 1 $.</p>
</li>
<li><p>如果$\lang A _1 + A _2 , B _1 + B _2 \rang = A _1 + A _2 $,由于若次品在$A _2 $中,那么它不可能是重球,因此次品不可能在$A _2 $中,同理不可能在$B _1 $中,只可能在$A _1 \cup B _2 $中,此时有$g ( n , m ) = g ( \frac { n  } { 3  } , \frac { m  } { 3  } ) + 1 $.</p>
</li>
<li><p>$\lang A _1 + A _2 , B _1 + B _2 \rang = B _1 + B _2 $,同理.</p>
</li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p>$n = 3 p + 1 , m = 3 q + 2 $.此时我们将第一堆分成$A _1 ( p ) , B _1 ( p ) , C _1 ( p + 1 ) $,将第二堆分成$A _2 ( q + 1 ) , B _2 ( q + 1 ) , C _2 ( q ) $,然后$\lang A _1 + A _2 , B _1 + B _2 \rang $,接下来和情况1一样,于是有$g ( n , m ) = \max \{ g ( p , q + 1 ) , g ( p + 1 , q ) \} = \lceil \log _3 \frac { n + m  } { 3  } \rceil + 1 $.</p>
<p>同理,当$n , m \bmod 3 $的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论$n \bmod 3 $的值.</p>
<p><strong>情况1</strong></p>
<p>当$n = 3 p $时,直接分成$A ( p ) , B ( p ) , C ( p ) $,然后$\lang A , B \rang $.如果平衡则接下来需要$f ( p ) = \lceil \log _3 2 p \rceil $次,不然根据引理,需要$\lceil \log _3 ( p + p ) \rceil $次,因此$f ( n ) = \lceil \log _3 2 p \rceil + 1 = \lceil \log _3 6 p \rceil = \lceil \log _3 2 n \rceil $.</p>
<p><strong>情况2</strong></p>
<p>当$n = 3 p + 1 $时,一种自然的想法是分成$A ( p + 1 ) , B ( p ) , C ( p ) $,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了$2 p + 2 , 2 p , 2 p $,这显然是不优秀的.正确的做法是分成$A = \{ S , 1 , \cdots p \} , B = \{ p + 1 , \cdots 2 p + 1 \} , C = \{ 2 p + 2 , \cdots 3 p + 1 \} $.由于存在标准球,此时如果$\lang A , B \rang = A  or  B $,那么转化成$g ( p , p + 1 ) = \lceil \log _3 ( 2 p + 1 ) \rceil $,不然转化成$f ( p ) = \lceil \log _3 2 p \rceil $.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6><p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有$n \bmod 3 = 1 $的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题$f ( n ) = \lceil \log _3 ( 2 n + 2 ) \rceil $.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6><p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将$a $个球放左边,$b $个球放右边,$a \leq b $,在左边补上$b - a $个标准球.</p>
<ol>
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要$\lceil \log _3 ( a + b ) \rceil + 1 $步.</p>
</li>
<li><p>如果天平平衡,需要$f ( n - a - b ) + 1 $步.</p>
</li>
</ol>
<p>我们有$f ( n ) = \min _{ a , b  } \{ \max \{ f ( n - a - b ) , \lceil \log _3 ( a + b ) \rceil \} \} + 1 $.</p>
<p>注意到接下来的步数只与$a + b $有关,取$b - a \leq 1 $,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到$f ( n ) = \lceil \log _3 ( 2 n - 1 ) \rceil $.</p>
<p>接下来归纳法就简单了,只需要对于$n \bmod 3 $的余数讨论一下,然后再讨论一下$a $的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5><p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求$n $所在位置.要求询问次数$\leq \lceil 1 . 5 \log _2 n \rceil $,询问区间总长度$\leq 3 n $.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设$T ( n ) $表示长度为$n $的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程$T ( n ) = \min _{ m &lt; n  } \{ \max \{ T ( m ) + 1 , T ( n - m ) + 2 \} \} $.</p>
<p>当然有$m _n \leq m _{ n + 1  } $,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3><h4><span id="模型1">模型1</span></h4><p>给定$n $个元素$x _1 , . . . , x _n $,以及一个定义域为这些元素的序列,定义域为有序集合的函数$F $.求出对于所有的$n $阶排列$p $,表达式$F ( \{ x _{ p _1  } , x _{ p _2  } , . . . , x _{ p _n  } \} ) $最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5><p>给定$n $个二元正整数对$( a _i , b _i ) $,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的$a $乘上序列中这个二元组之后的所有二元组的$b $之和的总和,求最小代价.$n , a _i , b _i \leq 10 ^6 $.</p>
<p>转化为上面的形式,也即:$F ( \{ ( a _1 , b _1 ) , . . . , ( a _n , b _n ) \} ) = \sum _{ 1 \leq i &lt; j \leq k  } a _i b _j $.</p>
<p>考虑调整法,令排列$( q _1 , . . . , q _n ) = ( p _1 , . . . , p _{ i - 1  } , p _{ i + 1  } , p _i , p _{ i + 2  } , . . . , p _n ) $.则:</p>
<script type="math/tex; mode=display">
F ( \{ ( a _{ p _1  } , b _{ p _1  } ) , . . . , ( a _{ p _n  } , b _{ p _n  } ) \} ) - F ( \{ ( a _{ q _1  } , b _{ q _1  } ) , . . . , ( a _{ q _n  } , b _{ q _n  } ) \} ) = a _{ p _i  } b _{ p _{ i + 1  }  } - a _{ p _{ i + 1  }  } b _{ p _i  }</script><p>因而如果$a _{ p _i  } b _{ p _{ i + 1  }  } - a _{ p _{ i + 1  }  } b _{ p _i  } &gt; 0 $,则$F ( \{ ( a _{ p _1  } , b _{ p _1  } ) , . . . , ( a _{ p _n  } , b _{ p _n  } ) \} ) &gt; F ( \{ ( a _{ q _1  } , b _{ q _1  } ) , . . . , ( a _{ q _n  } , b _{ q _n  } ) \} ) $,也就是说$( p _1 , . . . , p _n ) $不是最优解.因此只有满足$\forall 1 \leq i &lt; n $,$\cfrac { a _{ p _i  }  } { b _{ p _i  }  } \leq \cfrac { a _{ p _{ i + 1  }  }  } { b _{ p _{ i + 1  }  }  } $可能是最优解.</p>
<p>如果一个$p $满足这样的性质,则所有$\cfrac { a  } { b  } $相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换$\cfrac { a  } { b  } $相等的两个位置,是不会使答案改变的.因此直接按照$\cfrac { a  } { b  } $排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5><p>设给出的元素的集合为$S $,定义$S $上的一种二元比较关系$\leq $,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol>
<li><p>强完全性:$\forall a , b \in S $,$a \leq b \lor b \leq a = 1 $.</p>
</li>
<li><p>传递性:$\forall a , b , c \in S $,$a \leq b , b \leq c \Rightarrow a \leq c $.</p>
</li>
<li><p>$\forall a , b \in S $,如果$a \leq b $,则对于任意一个包含$\{ a , b \} $作为子段的元素序列$\{ s _1 , . . . , s _{ k - 1  } , a , b , s _{ k + 2  } , . . . , s _n \} $和$\{ s _1 , . . . , s _{ k - 1  } , b , a , s _{ k + 2  } , . . . , s _n \} $都有:$F ( \{ s _1 , . . . , s _{ k - 1  } , a , b , s _{ k + 2  } , . . . , s _n \} ) \leq F ( \{ s _1 , . . . , s _{ k - 1  } , b , a , s _{ k + 2  } , . . . , s _n \} ) $.</p>
</li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义$\leq $后自然也就定义了$= $,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到$\leq $的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5><p>给定$n $个包含小写字符的字符串$s _1 , . . . , s _n $,找到一个$n $阶排列$p $,将$s _{ p _1  } , s _{ p _2  } , . . . , s _{ p _n  } $顺序拼接得到$S $,使$S $的字典序最小.</p>
<p>令$s \leq t $当且仅当$s + t $的字典序$\leq $t+s</p>
<p>此时我们注意到:$s + t $的字典序小于等于$t + s $的字典序当且仅当$s ^{ \infty  } \leq t ^{ \infty  } $.原因是:不妨设$s $的长度$\leq t $的长度.若$s $不是$t $的前缀,那显然只需比较$t $的前缀和$s $的字典序即可,此时上面两个条件等价;若$s $是$t $的前缀,则我们需要比较$t $的前缀和$t $的后缀,注意到$t $的前缀还是$s $,于是需要比较$s $和$t $的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5><p>有$n $个箱子,第$i $个箱子有重量$w _i $和承载量$v _i $,$( w _i , v _i &gt; 0 ) $,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化$\min _{ i = 1  } ^n \{ v _i - \sum _{ j = 1  } ^{ i - 1  } w _j \} $,并判断是否$\geq 0 $.</p>
<p>我们令$b _i = - ( v _i + w _i ) , a _i = - v _i $,则我们要最大化$\min \{ \sum _{ j = 1  } ^{ i - 1  } b _i - \sum _{ j = 1  } ^i a _i \} $.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义$x \leq y $当且仅当$F ( \{ x , y \} ) \leq F ( \{ y , x \} ) $,那么对于两个元素$( a _1 , b _1 ) , ( a _2 , b _2 ) $,显然$( a _1 , b _1 ) \leq ( a _2 , b _2 ) $当且仅当$\min \{ - a _1 , b _1 - a _1 - a _2 \} \geq \min \{ - a _2 , b _2 - a _1 - a _2 \} $.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol>
<li><p>都大于等于第一个元素,则相当于$a _1 \leq a _2 \land b _1 - a _1 \geq 0 $.</p>
</li>
<li><p>都大于等于第二个元素,则相当于$b _1 \geq b _2 \land b _2 - a _2 \leq 0 $.</p>
</li>
</ol>
<p>可能这里后面和$0 $比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对$b - a $的符号进行讨论:</p>
<ol>
<li><p>若$sgn ( b _1 - a _1 ) &gt; sgn ( b _2 - a _2 ) $,则不等式成立.</p>
</li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 1 $,则不等式成立当且仅当$a _1 \leq a _2 $.</p>
</li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 0 $,则不等式成立.</p>
</li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = - 1 $,则不等式成立当且仅当$b _1 \geq b _2 $.</p>
</li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时$b _1 = a _1 $,$b _2 = a _2 $,两条件必有一真.(1)则是因为此时满足$b _1 - a _1 &gt; b _2 - a _2 \land sgn ( b _1 - a _1 ) \geq 0 \land sgn ( b _2 - a _2 ) \leq 0 $.也就有$a _2 - a _1 &gt; b _2 - b _1 \land b _1 \geq a _1 \land b _2 \leq a _2 $.怎么着都能成立.</p>
<p>由此发现,对于$sgn ( b - a ) $相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( a _1 , b _1 ) & \leq ( a _2 , b _2 ) \\
\Updownarrow \\
( sgn ( b _1 - a _1 ) & > sgn ( b _2 - a _2 ) ) \\
\lor ( sgn ( b _1 - a _1 ) & = sgn ( b _2 - a _2 ) \land F ( \{ 1 , 2 \} ) & \leq F ( \{ 2 , 1 \} ) 
\end{aligned}</script><h4><span id="模型2">模型2</span></h4><p>给定$n $个元素$x _1 , . . . , x _n $,以及一个定义域为这些元素的序列,值域为有序集合的函数$F $.求出对于给定整数$k $,所有的$n $阶排列$p $的长度为$k $的子序列,表达式$F ( \{ x _{ p _1  } , x _{ p _2  } , . . . , x _{ p _k  } \} ) $最小值.</p>
<p>如果$k = n $,则就是模型1.不然,我们考虑先选出一个大小为$k $的子集,然后使用模型1.不难发现,我们最后取出的$\{ x _{ p _1  } , x _{ p _2  } , . . . , x _{ p _k  } \} $一定是$n = k $时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5><p>有$n $个物品,第$i $个物品有非负费用$c _i $和价值$v _i $,两个人进行如下博弈:</p>
<ol>
<li><p>第一个人要么选择一个物品,付出$c _i $的代价;要么选择结束游戏.</p>
</li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行$k $次);也可以选择不操作,此时第一个人获得$v _i $的收益,博弈结束.</p>
</li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.$( n \leq 1 . 5 \times 10 ^5 , k \leq 9 ) $</p>
</li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择$k + 1 $个,然后收益为$\min _{ i = 1  } ^{ k - 1  } \{ v _{ x _i  } - \sum _{ j = 1  } ^i c _{ x _j  } \} $(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度$O ( n \log n + nk ) $.</p>
<h2><span id="构造">构造</span></h2><h3><span id="增量构造">增量构造</span></h3><h5><span id="example1">Example1</span></h5><p>平面上有$n $条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有$n $条直线的答案,求$n + 1 $条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5><p>给定若干个角度$a _1 , \cdots , a _n \in \{ 90 \degree , 270 \degree \} $,要求构造一个$n $边形(边必须平行于坐标轴),使得其内角依次是$a _1 , \cdots , a _n $.</p>
<p>首先有解条件显然是判定它们的和是否是$180 \degree ( n - 2 ) $.</p>
<p>注意到相邻的$90 \degree $和$270 \degree $无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5><p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5><p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3><p>常见于操作可逆,想要让$S \rightarrow T $.这个时候可以找一个中间状态$A $,让$S \rightarrow A , T \rightarrow A $.</p>
<h5><span id="example1">Example1</span></h5><p>坐标系上每个整点有个灯,初始只有$( X , 0 ) $亮着,每次把$( x , y ) $,$( x , y + 1 ) $,$( x + 1 , y ) $状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p>$n \leq 10 ^5 $,坐标的绝对值均$\leq 10 ^{ 17  } $.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线$y = - inf $,然后比对.我们注意到$( X , 0 ) $向下推的过程类似一个组合数递推的过程,由经典公式$\binom { S  } { T  } \equiv [ T \subseteq S ] \bmod 2 $可知,我们取$inf = 2 ^{ 63  } - 1 $即可.然后最后在这条线上一定是有一个区间是$1 $,我们需要找到区间左端点,我们选择在直线上随便找到一个$1 $,由于$inf $很大,大于$10 ^{ 17  } $,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,$n \leq 10 ^4 $,但是初始点可能是$( X , Y ) $.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点$( j , - inf ) $和$( k , - inf ) $是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出$X $和$Y $.而上述条件满足当且仅当$[ j - X \subseteq Y + inf ] $.</p>
<p>如果我们随便找一个点$( p , - inf ) $满足条件,那我们接下来只需要枚举$w $,判断$( p - 2 ^w , - inf ) $是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间$[ l , r ] $中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">计算几何</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2><p>参考:<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong">https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong</a>.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3><h4><span id="eps">eps</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$\vec { a  } \cdot \vec { b  } = | \vec { a  } | | \vec { b  } | \cos \theta = x _a x _b + y _a y _b $.也就等于$\vec { a  } $在$b $上的投影与$\vec { b  } $的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol>
<li><p>如果$\vec { a  } \cdot \vec { b  } = 0 $,则说明$\vec { a  } \bot \vec { b  } $.</p>
</li>
<li><p>如果$\vec { a  } \cdot \vec { b  } &gt; 0 $,则说明$\vec { a  } $和$\vec { b  } $正方向的夹角小于$90 \degree $.</p>
</li>
<li><p>如果$\vec { a  } \cdot \vec { b  } &lt; 0 $,则说明$\vec { a  } $和$\vec { b  } $正方向的夹角大于$90 \degree $.</p>
</li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$\vec { a  } \times \vec { b  } = x _a y _b - y _a x _b $.也就等于$\vec { a  } , \vec { b  } $两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol>
<li><p>如果$\vec { a  } \times \vec { b  } = 0 $,说明二者共线.</p>
</li>
<li><p>如果$\vec { a  } \times \vec { b  } &lt; 0 $,说明从$\vec { a  } $到$\vec { b  } $的方向是顺时针.</p>
</li>
<li><p>如果$\vec { a  } \times \vec { b  } &gt; 0 $,说明从$\vec { a  } $到$\vec { b  } $的方向是逆时针.</p>
</li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵$\begin{bmatrix}\cos \theta &amp; - \sin \theta \ \sin \theta &amp; \cos \theta \end{bmatrix} $.</p>
<h4><span id="line">Line</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下$x _{ L _1  } , x _{ L _2  } , y _{ L _1  } , y _{ L _2  } $围成的四边形,计算面积后用等高不等底计算.注意$ls $和$rs $所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4><p>利用叉乘,任取平面上一点$O $,则$S = \frac { 1  } { 2  } \sum _{ i = 1  } ^n \overrightarrow { OP _i  } \times \overrightarrow { OP _{ i + 1  }  } $.证明的话考虑分$O $在内部和$O $在外部两种情况分类讨论.注意此时的$P $必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为$a $,它的边上(包括顶点)的整点数为$b $,则它的面积$S = a + \frac { b  } { 2  } - 1 $.</p>
<h3><span id="基本算法">基本算法</span></h3><h4><span id="排序算法">排序算法</span></h4><h5><span id="极角排序">极角排序</span></h5><p>定义原点$O $并建立坐标系,所有点按照和$O $所连直线与$x $轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$x $相同比$y $,否则比$x $.</p>
<h4><span id="二维凸包">二维凸包</span></h4><h5><span id="定义">定义</span></h5><p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5><p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否$ABC $三点是一个上凸的(注意$ABC $三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4><h5><span id="定义">定义</span></h5><p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5><p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4><p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5><p>两个区域$A , B $的闵可夫斯基和定义为$\{ a + b \mid a \in A , b \in B \} $.</p>
<h5><span id="实现">实现</span></h5><p>事实上,新的区域所形成的凸包,一定是原本$A , B $的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下$A , B $,使得$B $有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是$B $这个边加上$A $的最右边的点.这样这条边必定还在最终的凸包上.就算$A $最右边的是一条边,你也会发现最终的凸包最右边也一定是由$A $的这条边和$B $的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4><h5><span id="定义">定义</span></h5><p>定义半平面为满足$ax + by + c &gt; 0 $或$ax + by + c \geq 0 $的点对$( x , y ) $组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5><p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2><p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3><h4><span id="直线">直线</span></h4><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h4><span id="平面">平面</span></h4><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h4><span id="夹角">夹角</span></h4><h5><span id="两直线夹角">两直线夹角.</span></h5><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h4><span id="交点">交点</span></h4><p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">范畴论初步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2><h3><span id="映射">映射</span></h3><p>设$A , B $为两个集合,$\varphi $称为从$A $到$B $的一个<strong>映射</strong>,如果对于任意$a \in A $,$\exists b \in B , b = \varphi ( a ) $.此时$b $称为$a $在$\varphi $下的像,$a $称为$b $在$\varphi $下的原像或反像.一般地,这个定义可以拓展到$S \subseteq A $,$\varphi ( S ) = \{ \varphi ( a ) \mid a \in S \} $,定义$\varphi ^{ - 1  } ( T ) = \{ a | \varphi ( a ) \in T , a \in S \} $.</p>
<p>如果$\forall a _1 , a _2 \in A , a _1 \ne a _2 , \varphi ( a _1 ) \ne \varphi ( a _2 ) $,称$\varphi $是<strong>单射</strong>.</p>
<p>如果$\forall b \in B , \exists a \in A , \varphi ( a ) = b $.称$\varphi $为<strong>满射</strong>.</p>
<p>如果$\varphi $既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果$A = B $,我们又称$\varphi $为一个<strong>变换</strong>.</p>
<p>设$f : A \rightarrow B , g : B \rightarrow A $,那么:</p>
<ol>
<li><p>如果$g \circ f = id _A $,称$g $是$f $的一个<strong>左逆</strong>,不难发现$f $存在左逆当且仅当$f $是单射.</p>
</li>
<li><p>如果$f \circ g = id _B $,称$g $是$f $的一个<strong>右逆</strong>,不难发现$f $存在右逆当且仅当$f $是满射.</p>
</li>
<li><p>如果$g $既是$f $的左逆又是$f $的右逆,则称$g $为$f $的<strong>逆</strong>,不难发现$f $存在逆当且仅当$f $是双射,并且逆唯一.</p>
</li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3><p>集合$A , B $的<strong>笛卡尔积</strong>或<strong>直积</strong>是指$A $的元素与$B $的元素构成的有序对的集合,即$A \times B = \{ ( a , b ) \mid a \in A , b \in B \} $.可以推广到多元对.</p>
<p>集合$A $上的一个<strong>二元运算</strong>是由$A \times A $到$A $的一个映射.对于定义在$U $上的一个二元运算,不妨用$+ $来表示,集合$A , B \subseteq U $的<strong>闵可夫斯基和</strong>定义为$A + B = \{ a + b \mid a \in A , b \in B \} $.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合$A $上的一个<strong>二元关系</strong>$R $定义为$A \times A $的一个子集(可以理解为满足二元关系的解集),如果$( a _1 , a _2 ) \in R $,就称$a _1 , a _2 $有关系$R $,记作$a _1 Ra _2 $,注意这里有序.</p>
<p>如果$R $满足以下三个性质:</p>
<ol>
<li><p>反身性:$\forall a \in A , aRa $.</p>
</li>
<li><p>对称性:$a _1 Ra _2 \Leftrightarrow a _2 Ra _1 $.</p>
</li>
<li><p>传递性:$a _1 Ra _2 , a _2 Ra _3 \Leftrightarrow a _1 Ra _3 $.</p>
</li>
</ol>
<p>则称$R $是一个<strong>等价关系</strong>,不难发现满足等价关系的元素构成了若干个集合,称作<strong>等价类</strong>.等价关系通常记作$\sim $.</p>
<p>如果将等价关系的(2)改作:</p>
<ol>
<li>反对称性:$a _1 Ra _2 , a _2 Ra _1 \Leftrightarrow a _1 = a _2 $.</li>
</ol>
<p>则称$R $是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$\leq $.</p>
<h4><span id="保序映射">保序映射</span></h4><p>对于映射$f : A \rightarrow B $,如果$\forall a , a ‘ \in A , a \leq a ‘ \Rightarrow f ( a ) \leq f ( a ‘ ) $,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4><p>对于偏序集$( A , R ) $来说,定义:</p>
<ol>
<li><p>链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 1 $.</p>
</li>
<li><p>反链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 0 $.</p>
</li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p>
</li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,$| A | \leq 3 $显然成立.</p>
<p>当$| A | &gt; 3 $时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为$d $,下面证明其最小链覆盖也是$d $.</p>
<p>考虑取一条尽可能长的链$A ‘ $,设其中最大的为$M $,最小的为$m $(如果有多个就任取一个).</p>
<p>考虑$T = A \setminus A ‘ $,如果$T $中的最长反链数小于$d $,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链$S $,使得$S \cap A ‘ = \emptyset $.考虑设$A ^{ +  } = \{ x | x \in A \land \exists s \in S , sRx \} $,$A ^{ -  } = \{ x | x \in A \land \exists s \in S , xRs \} $.不难发现$m $一定不在$| A ^{ +  } | $中,不然取出的那条链$A ‘ $可以更长.同理$M $一定不在$| A ^{ -  } | $中,也即$| A ^+ | , | A ^- | &lt; | A | $.</p>
<p>我们又发现$A ^+ \cup A ^- = A $,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,$S \subseteq A ^{ +  } \cap A ^{ -  } $.</p>
<p>由数学归纳,$A ^+ $和$A ^- $中的最小链覆盖均为$d $,并且一个以$S $中元素开头,一个以$S $中元素结尾,我们把它俩拼起来就是一个大小为$d $的新的大小为$d $的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4><p>考虑定义一种等价关系$\sim $,我们可以在此基础上定义商集$A / \sim = \{ [ a ] | a \in A \} $,其中$[ a ] $是$a $所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过$\mathbb { N  } $来定义$\mathbb { Z  } $.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系$\sim $,$( n , m ) \sim ( n ‘ , m ‘ ) $当且仅当$n + m ‘ = m + n ‘ $.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将$\mathbb { N  } / \sim $定义为整数,更确切地,对于任意一组$( n , m ) $其代表的就是$n - m $这个整数.</p>
<p>容易定义加法:$( n , m ) + ( n ‘ , m ‘ ) = ( n + n ‘ , m + m ‘ ) $,乘法$( n , m ) \times ( n ‘ , m ‘ ) = ( mm ‘ + nn ‘ , mn ‘ + m ‘ n ) $.也可以定义大小关系$( n , m ) \leq ( n ‘ , m ‘ ) \Leftrightarrow n + m ‘ \leq m + n ‘ $.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义$- ( n , m ) = ( m , n ) $即可,容易验证二者之和处于$( 0 , 0 ) $这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用$\mathbb { Z  } $构造$\mathbb { Q  } $,构造二元组$\mathbb { Z  } \times \mathbb { N  } _+ $,定义$( r , s ) \sim ( r ‘ , s ‘ ) \Leftrightarrow rs ‘ = r ‘ s $,容易验证其满足等价关系的性质.实际上其对应的就是$\frac { r  } { s  } $这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3><h4><span id="外延公理">外延公理</span></h4><p>$A = B \Leftrightarrow ( A \subset B ) \land ( B \subset A ) $.</p>
<h4><span id="配对公理">配对公理</span></h4><p>对于任意元素$a , b $,存在集合$\{ a , b \} $.特别地,当$a = b $的时候存在集合$\{ a \} $.</p>
<p>值得一提的是可以将数对$( a , b ) $定义为$\{ \{ a \} , \{ a , b \} \} $,下面的幂集公理说明了数对属于$2 ^{ 2 ^{ A \cup B  }  } , a \in A , b \in B $.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4><p>对于一个集合$A $,和一个性质$P $,若$\alpha $满足性质$P $则称$P ( \alpha ) $.那么存在集合:</p>
<script type="math/tex; mode=display">
\{ x | x \in A \land P ( x ) \}</script><p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质$P $都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4><p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4><p>一个集合的所有子集构成一个新的集合(可以记作$2 ^A $).</p>
<h4><span id="无穷公理">无穷公理</span></h4><p>称满足以下性质的集合为归纳集:</p>
<ol>
<li><p>$\emptyset \in A $.</p>
</li>
<li><p>若$\alpha \in A $,则$\{ \alpha \} \cup \alpha \in A $.</p>
</li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4><p>对于集合$A $和一种定义在集合$A $上的映射$F $,存在集合$A ‘ $使得$x \in A ‘ \Leftrightarrow x = F ( a ) , a \in A $.</p>
<p>用替换公理可以证明映射也是一种集合,并且从$A \rightarrow B $的所有映射可以构成集合,可以记作$B ^A $.</p>
<h4><span id="正则公理">正则公理</span></h4><p>对任何非空集合$A $,存在$a \in A $使得$\forall a ‘ \in A $,$a ‘ \notin a $,也就是$a \cap A = \emptyset $.</p>
<h4><span id="选择公理">选择公理</span></h4><p>说对于任何一族非空集$A $,总能从其中的每个集合$a $选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5><p>如果$X $上的一个偏序关系$\leq $,满足其每条链$A $都存在上界($\exists x \in X , \forall a \in A , x \geq a $),那么$X $存在极大元$( \exists x \in X , \forall a \in X , a \geq x \Rightarrow a = x ) $.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系$( A ‘ ‘ , g ‘ ‘ ) \leq ( A ‘ , g ‘ ) $当且仅当$A ‘ ‘ \subseteq A ‘ $并且$\forall x \in A ‘ ‘ , g ‘ ‘ ( x ) = g ‘ ( x ) $.这样拿出来的极大元就是我们需要的$A \rightarrow g ( A ) $.</p>
<h5><span id="良序定理">良序定理</span></h5><p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对$( S , R ) $组成的集合,其中满足$S $对于偏序关系$R $来说是良序的,我们定义两个二元对$a , b $满足$a \leq b $当且仅当它们的$R $相等并且$S _a \subseteq S _b $.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)$( S , R ) $,注意到如果$S $是全集则证毕,如果不是,则取一个全集中不在$S $的元素$x $接到$S $的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3><p>如果存在单射$\varphi : A \rightarrow B $,则称$| A | \leq | B | $.如果存在双射,则称$| A | = | B | $.</p>
<p>如果使用选择公理的话,可以说明如果存在满射$\varphi : A \rightarrow B $,则称$| A | \geq | B | $.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有$A , B $两个集合,接下来我们证明一定存在一个从$A $到$B $的映射,且其要么为单射要么为满射.</p>
<p>我们记$X $为所有$A $的子集到$B $的单射组成的集合,并且我们定义这样一种偏序关系:若$f : A _f \rightarrow B , g : A _g \rightarrow B , A _f \subseteq A _g , \forall a \in A _f , f ( a ) = g ( a ) $.</p>
<p>这样的话,我们不妨取出$X $的一个全序的子集$I $,显然其存在上界.</p>
<p>根据Zorn引理,$X $存在极大元$g : A _g \rightarrow B $,此时我们开始讨论:</p>
<p>如果$A _g = A $,那么找到了一个单射$g : A \rightarrow B $.</p>
<p>反之,如果$A _g \subsetneq A $,考虑如果$g ( A _g ) = B $,也就是找到了一个满射;反之,考虑取$a ‘ \in A \setminus A _g , b ‘ \in B \setminus g ( A _g ) $,在$g $的基础上加上映射$a ‘ \mapsto b ‘ $,这是一个比$g $还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4><p>如果$| A | \leq | B | \land | B | \leq | A | $,则$| A | = | B | $.</p>
<p>不妨设$f : A \rightarrow B , g : B \rightarrow A $我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用$f , f ^{ - 1  } $来构造双射,只有一种除外:那就是以一个$B $中节点开始不断延伸的无限的,我们在这里使用$g , g ^{ - 1  } $来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取$C _0 = B \setminus f ( A ) $,$C _n = f ( g ( C _{ n - 1  } ) ) $,那么对于$C = \cup _{ n \geq 0  } C _n $,使用$g , g ^{ - 1  } $构造双射,剩下的使用$f , f ^{ - 1  } $构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4><p>我们称集合$A $是<strong>可数</strong>的,当且仅当$| A | = | \mathbb { N  } | $.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是$0 $)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为$1 $和$0 $显然都是代数数.</p>
<p>我们接下来看两个代数数$x , y $.考虑如何构造$x + y $作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
X & = \sum _{ k = 0  } ^n a _k x ^k & = 0 \\
Y & = \sum _{ k = 0  } ^m b _k y ^k & = 0 
\end{aligned}</script><p>对于加法,考虑:$( x + y ) ^0 , ( x + y ) ^1 , \cdots $,这些东西,先把它们对$X $取膜再对$Y $取膜,得到的一定是$nm $维的,只需要取$nm + 1 $个就会出现线性相关.乘法同理考虑$( xy ) ^0 , ( xy ) ^1 , \cdots $即可.</p>
<p>值得一提的是,$| \mathbb { R  } | = 2 ^{ | \mathbb { N  } |  } $.这个是怎么构造的呢?只需要证明$[ 0 , 1 ] $上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果$k $在取出的自然数子集中,那么小数点后第$k + 1 $位为$1 $否则为$0 $,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是$0 . 1 = 0 . 0111 \cdots $,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明$| \mathbb { R  } | \leq 2 ^{ | \mathbb { N  } |  } $并且$| \mathbb { R  } | \geq 2 ^{ | \mathbb { N  } |  } $,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2><h3><span id="范畴">范畴</span></h3><p>一个<strong>范畴</strong>$\mathcal { C  } $应当包含以下:</p>
<ol>
<li><p>一个类$\rm { Ob  } ( \mathcal { C  } ) $,其元素称作$\mathcal { C  } $的<strong>对象</strong>.</p>
</li>
<li><p>对于$X , Y \in \rm { Ob  } ( \mathcal { C  } ) $指定一个集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,称作$\mathcal { C  } $中从$X $到$Y $的<strong>态射</strong>.</p>
</li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol>
<li><p>对于$X \in \text { Ob  } ( \mathcal { C  } ) $存在其到自身的<strong>恒等态射</strong>$\text { id  } _X \in \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong>$\circ : \text { Hom  } _{ \mathcal { C  }  } ( Y , Z ) \times \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , ( g , f ) \mapsto g \circ f $.</p>
</li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol>
<li><p><strong>结合律</strong>:对于$\mathcal { C  } $中的态射$h , g , f $,如果合成有意义,那么$h ( gf ) = ( hg ) f $.</p>
</li>
<li><p><strong>单位元</strong>:对于$f \in \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,$f \circ \text { id  } _X = f = \text { id  } _Y \circ f $.</p>
</li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有$\text { id  } _X = \text { id  } _X \text { id ‘  } _X = \text { id ‘  } _X $.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<script type="math/tex; mode=display">
\xymatrix { R \ar [r ] ^u \ar [d ] _x & S \ar [d ] ^v \\
T \ar [r ] _y & U  }</script><p>这意味着$yx = vu $.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol>
<li><p>如果对于$f \in \text { Hom  } ( X , Y ) $,$\exists g \in \text { Hom  } ( Y , X ) $使得$gf = \text { id  } _X $,那么称$g $是$f $的一个<strong>左逆</strong>,称$f $是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p>
</li>
<li><p>如果$f $左右均可逆,易见左右逆相等,记作$f ^{ - 1  } $,易见$f ^{ - 1  } $可逆而且$( f ^{ - 1  } ) ^{ - 1  } = f $.此时称$f $是<strong>同构</strong>的.</p>
</li>
</ol>
<p>同构还有以下性质:</p>
<ol>
<li><p>$( \text { id  } _X ) ^{ - 1  } = \text { id  } _X $.</p>
</li>
<li><p>如果$f $和$g $均为同构并且合成有意义,那么$gf $是同构并且$( gf ) ^{ - 1  } = f ^{ - 1  } g ^{ - 1  } $.</p>
</li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol>
<li><p>自同态幺半群:$\text { End  } _{ \mathcal { C  }  } ( X ) = \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>自同构群:$\text { Aut  } _{ \mathcal { C  }  } ( X ) = ( \text { End  } _{ \mathcal { C  }  } ( X ) ) ^\times $.</p>
</li>
</ol>
<p>如此起名的原因是由抽象代数知识见到$\text { End  } $对二元运算$\circ $构成幺半群,$\text { Aut  } $则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称$\mathcal { C  } ‘ $是$\mathcal { C  } $的子范畴当且仅当:</p>
<ol>
<li><p>$\text { Ob  } ( \mathcal { C  } ‘ ) \subseteq \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $都有$\text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \subseteq \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$\text { id  } _X = \text { id  } _X ‘ $.</p>
</li>
<li><p>态射在$\mathcal { C  } ‘ $中的合成运算应从$\mathcal { C  } $中继承而来.</p>
</li>
</ol>
<p>特别地,如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) , \text { Hom  } ( X , Y ) _{ \mathcal { C  } ‘  } = \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,则称$\mathcal { C  } ‘ $是$\mathcal { C  } $的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3><p>如果$\mathcal { C  } $是一个范畴,其中有一个元素$X \in \mathrm { Ob  } ( \mathcal { C  } ) $,如果$\forall Y \in \mathrm { Ob  } ( { \mathcal { C  }  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称它是始(initial)的.类似地,如果对于$Y \in \mathrm { Ob  } ( \mathcal { C  } ) $,$\forall X \in \mathrm { Ob  } ( \mathcal { C  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称$Y $是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol>
<li><p>如果$X , X ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是initial的,则存在一个唯一的同构$a : X \cong X ‘ $.</p>
</li>
<li><p>如果$Y , Y ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是terminal的,则存在一个唯一的同构$b : Y \cong Y ‘ $.</p>
</li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3><p>我们定义从$\mathcal { C  } ‘ $到$\mathcal { C  } $的<strong>函子</strong>$F $需要有以下性质:</p>
<ol>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,指定一个$\mathcal { C  } $中的对象$FX $.或记作$F : \text { Ob  } ( \mathcal { C  } ‘ ) \to \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,对于态射$f : X \to Y $指定一个$\mathcal { C  } $中的对象$Ff $.或记作$F : \text { Hom  } _\mathcal { C  } ‘ ( X , Y ) \to \text { Hom  } _\mathcal { C  } ( FX , FY ) $.</p>
</li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol>
<li><p>$\forall g , f \in \text { Hom  } _{ \mathcal { C  } ‘  } $,它们的合成有意义,则$F ( gf ) = F ( g ) F ( f ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F ( \text { id  } _X ) = \text { id  } _{ FX  } $.</p>
</li>
</ol>
<p>我们一般也将上述函子记作$F : \mathcal { C  } ‘ \to \mathcal { C  } $.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然$F $可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol>
<li><p>如果$\forall T \in \text { Ob  } ( \mathcal { C  } ) , \exists X \in \text { Ob  } ( \mathcal { C  } ‘ ) $使得$T \cong FX $,则称$F $是<strong>本质满</strong>的.</p>
</li>
<li><p>如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F : \text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( FX , FY ) $均为单射,则称$F $是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p>
</li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓$\text { Hom  } $函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴$\mathcal { C  } $以及其对象$X $,我们定义函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) : \mathcal { C  } \to Set $,它映对象$Y $为集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,映态射$f : Y \to Z $为映射$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) f : \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , h \mapsto f \circ h $.</p>
<p>同理可以定义函子$\text { Hom  } _{ \mathcal { C  }  } ( \cdot , X ) $.</p>
<p>对于函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) $,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3><h4><span id="kleisli范畴">Kleisli范畴</span></h4><p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol>
<li><p>加上修饰.</p>
</li>
<li><p>合并修饰.</p>
</li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">组合数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2><h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3><p>定义下降幂$x ^{ \underline { k  }  } = \prod _{ i = 0  } ^{ k - 1  } ( x - i ) = \frac { x !  } { ( x - k ) !  } $.</p>
<p>定义上升幂$x ^{ \overline { k  }  } \prod _{ i = 0  } ^{ k - 1  } ( x + i ) = \frac { ( x + k - 1 ) !  } { ( x - 1 ) !  } $.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:$r ^{ \underline { k  }  } ( r - 0 . 5 ) ^{ \underline { k  }  } = \cfrac { ( 2 r ) ^{ \underline { 2 k  }  }  } { 2 ^{ 2 k  }  } , k \in \mathbb { N  } $.</p>
<p>他们之间存在转换:$x ^{ \underline { n  }  } = ( - 1 ) ^n ( - x ) ^{ \overline { n  }  } $.</p>
<p>同时存在大小关系:$x ^{ \underline { n  }  } \leq x ^n \leq x ^{ \overline { n  }  } $,其中$0 \leq n &lt; x $.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3><p>考虑令$\binom { n  } { m  } $表示从一个大小为$n $的子集中选出大小为$m $的子集的方案数.第一次有$n $个选择,第二次有$n - 1 $个选择……第m次有$n - m + 1 $个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是$m ! $,因此显然有$\binom { n  } { m  } = \cfrac { n ^{ \underline { m  }  }  } { m !  } $.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
<p>$\binom { r  } { k  } = \begin{cases}\cfrac { r ^{ \underline { k  }  }  } { k !  } &amp; k \geq 0 \ 0 &amp; k &lt; 0 \end{cases} , r \in \mathbb { C  } , k \in \mathbb { Z  } $.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把$\binom { r  } { k  } $看作了一个关于$r $的$k $次多项式.</p>
<p>另外根据定义,$r \in \mathbb { Z  } \land r &lt; k $时,该公式给出$0 $.</p>
<p>值得一提的是,为了使二项式系数在面对$0 $的时候更加简洁,通常直接定义$0 ! = 1 , 0 ^0 = 1 $.</p>
<p>另外不难发现$\binom { 2 n  } { n  } $是所有$\binom { 2 n  } { k  } $中最大的.事实上我们有Wallis公式:$\lim _{ n \rightarrow \infty  } \frac { ( \frac { 2 ^{ 2 n  }  } { \binom { 2 n  } { n  }  } ) ^2  } { 2 n + 1  } = \frac { \pi  } { 2  } $.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3><ol>
<li>阶乘展开式:$\binom { n  } { k  } = \cfrac { n !  } { k ! ( n - k ) !  } , n , k \in \mathbb { N  } , n \geq k \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol>
<li>对称恒等式:$\binom { n  } { k  } = \binom { n  } { n - k  } , n \in \mathbb { N  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>根据$( 1 ) $,$0 \leq k \leq n $时是显然的.而其他情况两边都会给出$0 $,因此也是成立的.</p>
<ol>
<li>吸收恒等式:$\binom { r  } { k  } = \cfrac { r  } { k  } \binom { r - 1  } { k - 1  } , k \in \mathbb { Z  } \land k \ne 0 \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol>
<li>吸收恒等式的变式:$k \binom { r  } { k  } = r \binom { r - 1  } { k - 1  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>根据$( 3 ) $,只需要验证$k = 0 $的情况即可,也是显然的.</p>
<ol>
<li>相伴恒等式:$( r - k ) \binom { r  } { k  } = r \binom { r - 1  } { k  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( r - k ) \binom { r  } { k  } & = ( r - k ) \binom { r  } { r - k  } \\
& = r \binom { r - 1  } { r - k - 1  } \\
& = r \binom { r - 1  } { k  } 
\end{aligned}</script><p>问题在于:我们在上述描述中并未提到$r $的范围,但是推导过程要求$r \in \mathbb { N  } $.不过,我们已经说明了二项式系数是关于$r $的$k $次多项式,因此只需要有$k + 1 $个$r $满足这个公式即可.而根据推导过程显然有无限个$r $满足,因此这个公式对$r \in \mathbb { C  } $也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k \binom { r  } { k  } & = r \binom { r - 1  } { k - 1  } \\
( r - k ) \binom { r  } { r - k  } & = r \binom { r - 1  } { r - k - 1  } \\
( r - k ) \binom { r  } { k  } & = r \binom { r - 1  } { k  } 
\end{aligned}</script><ol>
<li>加法公式:$\binom { r  } { k  } = \binom { r - 1  } { k  } + \binom { r - 1  } { k - 1  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明可以使用定义,也可以先用$r \in \mathbb { N  } $的情况给出组合意义,再使用多项式推理法证明.</p>
<ol>
<li>$\binom { r  } { m  } \binom { m  } { k  } = \binom { r  } { k  } \binom { r - k  } { m - k  } , n , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol>
<li>平行求和法:$\sum _{ k \leq n  } \binom { r + k  } { k  } = \binom { r + n + 1  } { n  } , n \in \mathbb { N  } \ $.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p>$\binom { r + n + 1  } { n  } = \binom { r + n  } { n  } + \binom { r + n  } { n - 1  } = \binom { r + n  } { n  } + \binom { r + n - 1  } { n - 1  } + \binom { r + n - 1  } { n - 2  } = . . . \ $,最终下标会减成负数,这样后面的项就全都是$0 $了.</p>
<p>也可以考虑组合意义:如果$r \in \mathbb { N  } $,那么我们考虑从右到左第一个没有被选上的数,假设它是$r + k + 1 $,那么在它右边的数全部选择了,一共是$n - k $个数,而还需要在左边的$r + k $中选择$k $个数.</p>
<ol>
<li>上指标求和法:$\sum _{ 0 \leq k \leq n  } \binom { k  } { m  } = \binom { n + 1  } { m + 1  } , n , m \in \mathbb { N  } \ $.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是$k + 1 $,接下来就还需要在$[ 1 , k ] $中选择$m $个.</p>
<p>如果我们将这个公式两边同时乘以$m ! $,我们可以得到公式:$\sum _{ 0 \leq k \leq n  } k ^{ \underline { m  }  } = \cfrac { ( n + 1 ) ^{ \underline { m + 1  }  }  } { m + 1  } , n , m \in \mathbb { N  } \ $,这也就是有限微积分的公式中的一个.</p>
<ol>
<li>二项式定理:$( x + y ) ^r = \sum _{ k  } \binom { r  } { k  } x ^k y ^{ r - k  } , r \in \mathbb { N  } \ $.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq k \leq n  } \binom { n  } { k  } & = 2 ^n , n \in \mathbb { N  } \\

\end{aligned}</script><p>在二项式定理中令$x = y = 1 $即可证明.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq k \leq n  } ( - 1 ) ^k \binom { n  } { k  } & = 0 ^n & = [ n & = 0 ] , n \in \mathbb { N  } \\

\end{aligned}</script><p>在二项式定理中令$x = - 1 , y = 1 $即可证明,值得一提的是,当$n = 0 $的时候这个式子给出$1 $,并在其他情况下给出$0 $,这个式子是二项式反演的基础.</p>
<ol>
<li>三项式定理:$( x + y + z ) ^n = \sum _{ 0 \leq a , b , c \leq n  } [ a + b + c = n ] \cfrac { n !  } { a ! b ! c !  } x ^a y ^b z ^c , n \in \mathbb { N  } \ $.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,$\cfrac { n !  } { a ! b ! c !  } = \binom { n  } { b + c  } \binom { b + c  } { c  } $.</p>
<ol>
<li>多项式定理:$( \sum _{ i = 1  } ^m x _i ) ^n = \sum _{ \forall i \in [ 1 , m ] , 0 \leq a _i \leq n  } [ \sum _{ i = 1  } ^m a _i = n ] \cfrac { n !  } { \prod _{ i = 1  } ^m a _i !  } \prod _{ i = 1  } ^m x _i ^{ a _i  } , n \in \mathbb { N  } \ $.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol>
<li>范德蒙德卷积:$\sum _{ k  } \binom { r  } { m + k  } \binom { s  } { n - k  } = \binom { r + s  } { n + m  } , n , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol>
<li>范德蒙德卷积的变式:$\sum _{ k  } \binom { l  } { m + k  } \binom { s  } { n + k  } = \binom { l + s  } { l - m + n  } , l \in \mathbb { N  } , n , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>有$\binom { l  } { m + k  } = \binom { l  } { l - m - k  } $,然后运用范德蒙德卷积即可得到答案.</p>
<ol>
<li>上指标反转公式:$\binom { r  } { k  } = ( - 1 ) ^k \binom { k - r - 1  } { k  } \ $.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3><ol>
<li>$\sum _{ k \leq m  } \binom { r  } { k  } ( - 1 ) ^k = ( - 1 ) ^m \binom { r - 1  } { m  } , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k \leq m  } \binom { r  } { k  } ( - 1 ) ^k & = \sum _{ k \leq m  } \binom { k - r - 1  } { k  } \\
& = \binom { - r + m  } { m  } & = ( - 1 ) ^m \binom { r - 1  } { m  } 
\end{aligned}</script><ol>
<li>$\sum _{ - q \leq k \leq l  } \binom { l - k  } { m  } \binom { q + k  } { n  } = \binom { l + q + 1  } { m + n + 1  } , n , m \in \mathbb { N  } , l + q \geq 0 \ $.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol>
<li>$\sum _{ k  } \binom { a + b  } { a + k  } \binom { a + b  } { b + k  } ( - 1 ) ^k = \binom { a + b  } { a  } , a , b \in \mathbb { N  } \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol>
<li>$\sum _{ k = 0  } ^m \cfrac { \binom { m  } { k  }  } { \binom { n  } { k  }  } = \cfrac { n + 1  } { n + 1 - m  } , n , m \in \mathbb { N  } , n \geq m \ $.</li>
</ol>
<p>我们有$\binom { n  } { m  } \binom { m  } { k  } = \binom { n  } { k  } \binom { n - k  } { m - k  } \ $,两边同时除以$\binom { n  } { m  } \binom { n - k  } { m - k  } \ $,于是我们得到了$\cfrac { \binom { m  } { k  }  } { \binom { n  } { k  }  } = \cfrac { \binom { n - k  } { m - k  }  } { \binom { n  } { m  }  } \ $.</p>
<p>有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^m \cfrac { \binom { m  } { k  }  } { \binom { n  } { k  }  } & = \sum _{ k = 0  } ^m \cfrac { \binom { n - k  } { m - k  }  } { \binom { n  } { m  }  } \\
& = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m \binom { n - k  } { m - k  } \\
& = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m \binom { n - m + k  } { k  } \\
& = \cfrac { \binom { n + 1  } { m  }  } { \binom { n  } { m  }  } \\
& = \cfrac { n + 1  } { n + 1 - m  } 
\end{aligned}</script><ol>
<li>$( - 1 ) ^m \binom { - n - 1  } { m  } = ( - 1 ) ^n \binom { - m - 1  } { n  } , n , m \in \mathbb { N  } \ $.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于$\binom { n + m  } { m  } \ $.</p>
<ol>
<li>$\sum _{ k \leq m  } \binom { r  } { k  } ( \cfrac { r  } { 2  } - k ) = \cfrac { m + 1  } { 2  } \binom { r  } { m + 1  } , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol>
<li>$\sum _{ k \leq m  } \binom { m + r  } { k  } x ^k y ^{ m - k  } = \sum _{ k \leq m  } \binom { - r  } { k  } ( - x ) ^k ( x + y ) ^{ m - k  } , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>不妨令左边的值为$S _m $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _m & = \sum _{ k \leq m  } \binom { m + r  } { k  } x ^k y ^{ m - k  } & = \sum _{ k \leq m  } \binom { m + r - 1  } { k  } x ^k y ^{ m - k  } + \sum _{ k \leq m  } \binom { m + r - 1  } { k - 1  } x ^k y ^{ m - k  } \\
& = y \sum _{ k < m  } \binom { m - 1 + r  } { k  } x ^k y ^{ m - 1 - k  } + \binom { m + r - 1  } { m  } x ^m + x \sum _{ k \leq m  } \binom { m + r - 1  } { k - 1  } x ^{ k - 1  } y ^{ m - k  } \\
& = ( x + y ) S _{ m - 1  } + \binom { m + r - 1  } { m  } x ^m \\
& = ( x + y ) S _{ m - 1  } + \binom { r  } { m  } ( - x ) ^m 
\end{aligned}</script><p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol>
<li>$\sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ - k  } = 2 ^m , m \in \mathbb { N  } \ $.</li>
</ol>
<p>考虑$( 7 ) $,将$x = y = 1 , r = m + 1 $带入,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k \leq m  } \binom { 2 m + 1  } { k  } & = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ m - k  } \\
2 ^{ 2 m  } & = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ m - k  } \\
2 ^m & = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ - k  } 
\end{aligned}</script><ol>
<li>$\sum _{ k  } \binom { l  } { m + k  } \binom { s + k  } { n  } ( - 1 ) ^k = ( - 1 ) ^{ l + m  } \binom { s - m  } { n - l  } , l \in \mathbb { N  } , n , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol>
<li>$\sum _{ k \leq l  } \binom { l - k  } { m  } \binom { s  } { k - n  } ( - 1 ) ^k = ( - 1 ) ^{ l + m  } \binom { s - m - 1  } { l - n - m  } , l , n , m \in \mathbb { N  } \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3><ol>
<li>$\binom { r  } { k  } \binom { r - \cfrac { 1  } { 2  }  } { k  } = \cfrac { \binom { 2 r  } { 2 k  } \binom { 2 k  } { k  }  } { 2 ^{ 2 k  }  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>将加倍公式两边同时除以$k ! ^2 $即可得到这个公式.</p>
<ol>
<li>$\binom { n - \cfrac { 1  } { 2  }  } { n  } = \cfrac { \binom { 2 n  } { n  }  } { 2 ^{ 2 n  }  } , n \in \mathbb { Z  } \ $.</li>
</ol>
<p>将$( 1 ) $中令$r = k = n $即可得到这个公式.</p>
<ol>
<li>$\binom { - \cfrac { 1  } { 2  }  } { n  } = ( \cfrac { - 1  } { 4  } ) ^n \binom { 2 n  } { n  } , n \in \mathbb { Z  } \ $.</li>
</ol>
<p>即$( 2 ) $的变形.</p>
<ol>
<li>$\sum _{ k  } \binom { n  } { 2 k  } \binom { 2 k  } { k  } 2 ^{ - 2 k  } = \binom { n - \cfrac { 1  } { 2  }  } { \lfloor \cfrac { n  } { 2  } \rfloor  } , n \in \mathbb { N  } \ $</li>
</ol>
<p>首先根据$( 1 ) $,左边$= \sum _{ k  } \binom { \cfrac { n  } { 2  }  } { k  } \binom { \cfrac { n - 1  } { 2  }  } { k  } \ $,而考虑到$\cfrac { n  } { 2  } $和$\cfrac { n - 1  } { 2  } $必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol>
<li>$\sum _{ k  } \binom { - \cfrac { 1  } { 2  }  } { k  } \binom { - \cfrac { 1  } { 2  }  } { n - k  } = ( - 1 ) ^n , n \in \mathbb { N  } \ $.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol>
<li>$\sum _{ k  } \binom { 2 k  } { k  } \binom { 2 n - 2 k  } { n - k  } = 4 ^n , n \in \mathbb { N  } \ $.</li>
</ol>
<p>由$( 5 ) $和$( 3 ) $不难推出.</p>
<ol>
<li>$\sum _{ k  } \binom { n  } { k  } \cfrac { ( - 1 ) ^k  } { x + k  } = x ^{ - 1  } \binom { x + n  } { n  } ^{ - 1  } , x \notin \{ 0 , - 1 , . . . , - n \} \ $.</li>
</ol>
<p>令$f ( x ) = ( x - 1 ) ^{ \underline { - 1  }  } $,直接做高阶差分即可得到这个式子.</p>
<ol>
<li>$\sum _{ k = 0  } ^n \binom { r  } { k  } \binom { r  } { n - k  } ( - 1 ) ^k = [ n  is  \mathrm { even  } ] ( - 1 ) ^{ \cfrac { n  } { 2  }  } \binom { r  } { \cfrac { n  } { 2  }  } \ $.</li>
</ol>
<p>首先不难发现,$( 1 - z ) ^r = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { r  } { k  } \ $.</p>
<p>考虑$( 1 - z ) ^r ( 1 + z ) ^r = ( 1 - z ^2 ) ^r $.</p>
<p>我们有$[ z ^n ] ( 1 - z ) ^r ( 1 + z ) ^r = [ z ^n ] ( 1 - z ^2 ) ^r $,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3><p>卡特兰数$f _n $表示:长度为$2 n $的合法括号序列个数.</p>
<p>卡特兰数的前几项为$1 , 1 , 2 , 5 , 14 , 42 , 132 \cdots $.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:$f _n = \sum _{ i = 0  } ^{ n - 1  } f _i f _{ n - 1 - i  } $.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如$( A ) B $.</p>
<p>考虑将其删成$A $和$B $,则$A $一定合法,因为若$A $不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:$f _n = \frac { 1  } { n + 1  } C _{ 2 n  } ^n = C _{ 2 n  } ^n - C _{ 2 n  } ^{ n - 1  } $.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从$( 0 , 0 ) $走到$( 2 n , 0 ) $不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到$( 2 n , 0 ) $的方案数是$C _{ 2 n  } ^n $.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点$( x , - 1 ) $.</p>
<p>考虑将$x $以后的折线以直线$y = - 1 $为对称轴反转,那么终点到了$( 2 n , - 2 ) $.</p>
<p>不难发现,任意从$( 0 , 0 ) $走到$( 2 n , - 2 ) $的方案一定唯一对应了一种从$( 0 , 0 ) $走到$( 2 n , 0 ) $的不合法方案.因为从$( 0 , 0 ) $走到$( 2 n , - 2 ) $一定会经过直线$y = - 1 $,将后半部分对称后就是其对应方案.而从$( 0 , 0 ) $走到$( 2 n , - 2 ) $的方案数为$C _{ 2 n  } ^{ n - 1  } $.</p>
<p>因而$f _n = C _{ 2 n  } ^n - C _{ 2 n  } ^{ n - 1  } \ $.</p>
<p>而$C _{ 2 n  } ^n - C _{ 2 n  } ^{ n - 1  } = \frac { ( 2 n ) !  } { n ! n !  } - \frac { ( 2 n ) !  } { ( n - 1 ) ! ( n + 1 ) !  } = \frac { ( 2 n ) !  } { n ! ( n + 1 ) !  } = \frac { C _{ 2 n  } ^n  } { n + 1  } \ $.</p>
<p>递推定义:$f _n = \frac { 4 n - 2  } { n + 1  } f _{ n - 1  } \ $.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\frac{(2n)!}{n!(n+1)!}\\</p>
<p>f_{n-1}=\frac{(2n-2)!}{(n-1)!(n)!}</p>
<p>\end{cases}\\</p>
<p>不难发现$f _n = \frac { ( 2 n - 1 ) ( 2 n )  } { n ( n + 1 )  } f _{ n - 1  } \ $.整理,得到$f _n = \frac { 4 n - 2  } { n + 1  } f _{ n - 1  } \ $.</p>
<p>换个记号,设$C _n $为卡特兰数的第$n $项,卡特兰数有一个著名的结论是$k $次卷积:</p>
<script type="math/tex; mode=display">
C ^{ ( k )  } _n = \sum _{ \sum _{ j = 1  } ^k a _j = n  } \prod C _{ a _i  } = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  }</script><p>我们可以这么理解它:它指的是一个长度为$n + k - 1 $的括号序列,前$k - 1 $个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成$( ( ( A ) B ) C ) D $之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C ^{ ( k )  } _n & = \binom { 2 n + k - 1  } { n  } - \binom { 2 n + k - 1  } { n - 1  } \\
& = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  } 
\end{aligned}</script><h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5><p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是$\binom { 2 n  } { n  } $.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5><p>给定$x , n $,对$y \in [ 1 , n ] $,固定$p _x = y $做笛卡尔树的<strong>形态</strong>计数.$n \leq 5 \times 10 ^5 $.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现$a _x = y $只要满足:</p>
<ol>
<li><p>$x $节点的祖先数量不超过$y - 1 $个(深度小于等于$y $).</p>
</li>
<li><p>$x $节点的子树大小不超过$n - y + 1 $.</p>
</li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出$f _p $表示$x $的深度为$p $的答案,$g _p $表示$x $的子树大小为$p $的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:$x $的祖先有两种:一种在序列中在$x $的左边,一种在$x $的右边.我们设前者为$0 = l _0 &lt; l _1 &lt; l _2 &lt; \cdots l _p &lt; l _{ p + 1  } = x $,设后者为$n + 1 = r _0 &gt; r _1 &gt; r _2 &gt; \cdots &gt; r _{ q  } &gt; r _{ q + 1  } = x $.这么分类有什么用呢?我们考虑$( l _{ i - 1  } , l _{ i  } ) $这一段数能放在哪里,它只能是$l _{ i  } $的左儿子,独立于整棵树,因此这一段的答案就是$C _{ l _i - l _{ i - 1  } - 1  } $.</p>
<p>记:</p>
<script type="math/tex; mode=display">
\begin{aligned}
L _p & = \sum _{ l  } \prod _{ i = 1  } ^{ p + 1  } C _{ l _i - l _{ i - 1  } - 1  } \\
R _q & = \sum _{ r  } \prod _{ i = 1  } ^{ q + 1  } C _{ r _{ i - 1  } - r _i - 1  } \\

\end{aligned}</script><p>注意到这等价于卡特兰数的$k $次卷积,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
L _p & = C _{ x - p - 1  } ^{ ( p + 1 )  } \\
R _q & = C ^{ ( q + 1 )  } _{ n - x - q  } \\

\end{aligned}</script><p>此时的答案自然是$f _{ p + q + 1  } = L _p R _q \binom { p + q  } { q  } $,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把$x $的子树从原树中删去,然后插入$x $一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为$p $,右子树大小为$q $,我们有$g _{ p + q + 1  } = C _p C _q C _{ n - ( p + q + 1 )  } = C _{ n - 1  } ^{ ( 3 )  } $,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3><h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4><h5><span id="example1">Example1</span></h5><p>求$\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } , n , m \in \mathbb { N  } \land m &gt; n \ $.</p>
<p>这个式子乘了个系数$k $导致很难处理,一个自然的想法是使用吸收恒等式将$k $消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } & = \sum _{ k = 0  } ^n m \binom { m - k - 1  } { m - n - 1  } - \sum _{ k = 0  } ^n ( m - k ) \binom { m - k - 1  } { m - n - 1  } \\
& = m \sum _{ k = 0  } ^{ m - 1  } \binom { m - k - 1  } { m - n - 1  } - ( m - n ) \sum _{ k = 0  } ^m \binom { m - k  } { m - n  } 
\end{aligned}</script><p>不妨令$S _m = \sum _{ k = 0  } ^m \binom { m - k  } { m - n  } \ $,不难发现我们有:</p>
<script type="math/tex; mode=display">
S _m = \sum _{ k = 0  } ^m \binom { k  } { m - n  } = \binom { m + 1  } { m - n + 1  }</script><p>于是原式$= mS _{ m - 1  } - ( m - n ) S _m = \cfrac { n  } { m - n + 1  } \binom { m  } { m - n  } \ $.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将$k = \binom { k  } { 1  } $带入:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } & = \sum _{ k = 0  } ^n \binom { k  } { 1  } \binom { m - k - 1  } { m - n - 1  } \\
& = \binom { m  } { m - n + 1  } \\
& = \cfrac { n  } { m - n + 1  } \binom { m  } { m - n  } 
\end{aligned}</script><h5><span id="example2">Example2</span></h5><p>求$\sum _{ k  } k \binom { n  } { k  } \binom { s  } { k  } , n \in \mathbb { N  } \ $.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到$n $和$s $的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k  } k \binom { n  } { k  } \binom { s  } { k  } & = s \sum _{ k  } \binom { n  } { k  } \binom { s - 1  } { k - 1  } \\
& = s \binom { n + s - 1  } { n - 1  } 
\end{aligned}</script><h5><span id="example3">Example3</span></h5><p>求$\sum _{ 0 \leq k  } \binom { n + k  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n \in \mathbb { N  } \ $.</p>
<p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq k  } \binom { n + k  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } & = \sum _{ 0 \leq k  } \binom { n + k  } { k  } \binom { n  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n \in \mathbb { N  } \\
& = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { n + k  } { k  } \binom { n + 1  } { k + 1  } { ( - 1 ) ^k  } \\
& = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { - n - 1  } { k  } \binom { n + 1  } { k + 1  } \\
& = \cfrac { 1  } { n + 1  } \binom { 0  } { n  } \\
& = [ n & = 0 ] 
\end{aligned}</script><h5><span id="example4">Example4</span></h5><p>求$\sum _{ k \geq 0  } \binom { n + k  } { m + 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n , m \in \mathbb { N _+  } \ $.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的$( 1 ) $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k \geq 0  } \binom { n + k  } { m + 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } & = \sum _{ k \geq 0  } \sum _{ 0 \leq j \leq n + k - 1  } \binom { n + k - 1 - j  } { 2 k  } \binom { j  } { m - 1  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } \\
& = \sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{ j + 1 - n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } 
\end{aligned}</script><p>注意到如果$j + 1 - n \geq 0 $,则$\binom { n + k - 1 - j  } { 2 k  } \ $应为$0 $.所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{ j + 1 - n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } \\
& = \sum _{ 0 \leq j < n  } \binom { j  } { m - 1  } [ n - 1 - j & = 0 ] & = \binom { n - 1  } { m - 1  } 
\end{aligned}</script><h5><span id="example5">Example5</span></h5><p>求$\sum _{ k = 0  } ^n ( C _n ^k ) ^2 $.</p>
<script type="math/tex; mode=display">
\sum _{ k = 0  } ^n ( C _n ^k ) ^2 = \sum _{ k = 0  } ^n C _{ n  } ^k \times C _{ n  } ^{ n - k  } = C _n ^{ 2 n  }</script><h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4><h5><span id="example1">Example1</span></h5><p>求$Q _n = \sum _{ k \leq 2 ^n  } \binom { 2 ^n - k  } { k  } ( - 1 ) ^k , n \in \mathbb { N  } \ $.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于$Q _n $的式子中实际上只与$2 ^n $有关,我们不妨令$R _n = \sum _{ k \leq n  } \binom { n - k  } { k  } ( - 1 ) ^k \ $,显然有$Q _n = R _{ 2 ^n  } $.</p>
<p>而我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
R _n & = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k + \sum _{ k \leq n  } \binom { n - 1 - k  } { k - 1  } ( - 1 ) ^k \\
& = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k + \sum _{ k \leq n - 1  } \binom { n - k - 2  } { k  } ( - 1 ) ^{ k + 1  } \\
& = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k + \binom { - 1  } { n  } ( - 1 ) ^n - ( \sum _{ k \leq n - 2  } \binom { n - 2 - k  } { k  } ( - 1 ) ^k + \binom { - 1  } { n - 1  } ( - 1 ) ^{ n - 1  } ) \\
& = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k - \sum _{ k \leq n - 1  } \binom { n - 2 - k  } { k  } ( - 1 ) ^k \\
& = R _{ n - 1  } - R _{ n - 2  } \\
& = R _{ n - 2  } - R _{ n - 3  } - R _{ n - 2  } \\
& = - R _{ n - 3  } \\
& = R _{ n - 6  } 
\end{aligned}</script><p>也即$R _n $具有周期性,不难计算前几项答案,最后有$Q _n \begin{cases}1 &amp; n = 0 \ 0 &amp; n  is  \mathrm { odd  } \ - 1 &amp; n &gt; 0 \land n  is  \mathrm { even  } \end{cases} $.</p>
<h5><span id="example2">Example2</span></h5><p>求$( \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{ nk  } ) \mod p $.</p>
<p>考虑设$f ( n , r ) = \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{ nk  } \ $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n , r ) & = \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{ nk  } \\
& = \sum _{ i = 0  } ^{ + \infty  } \sum _{ j = 0  } ^k C _{ nk - k  } ^{ ik + r - j  } \times C _k ^j \\
& = \sum ^k _{ j = 0  } C _k ^j \sum _{ i = 0  } ^{ + \infty  } C _{ nk - k  } ^{ ik + r - j  } \\
& = \sum _{ j = 0  } ^k C _k ^j f ( n - 1 , r - j ) \\

\end{aligned}</script><p>整理上式,得到:$f ( n , r ) = \sum _{ j = 0  } ^k C _k ^j f ( n - 1 , r - j ) \ $.</p>
<p>于是我们得到了关于$f $的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4><h5><span id="example">Example</span></h5><p>求$\sum _{ k = 1  } ^n k ^2 C _n ^k $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
( ( 1 + x ) ^n ) & = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } ) \\
( ( 1 + x ) ^n ) ' & = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } ) ' \\
n ( 1 + x ) ^{ n - 1  } & = \sum _{ k = 0  } ^n kC _n ^k x ^{ k - 1  } \\
nx ( 1 + x ) ^{ n - 1  } & = \sum _{ k = 0  } ^n kC _n ^k x ^{ k  } \\
( nx ( 1 + x ) ^{ n - 1  } ) ' & = ( \sum _{ k = 0  } ^n kC _n ^k x ^{ k  } ) ' \\
n ( ( 1 + x ) ^{ n - 1  } + ( n - 1 ) x ( 1 + x ) ^{ n - 2  } ) & = \sum _{ k = 0  } ^n k ^2 C _n ^k x ^{ k - 1  } \\

\end{aligned}</script><p>取$x = 1 $,则原式$= n ( n + 1 ) 2 ^{ n - 2  } $.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4><h5><span id="example1">Example1</span></h5><p>多次询问给定$k , r $,$\sum k \leq 2 n , r &lt; 2 n - k $,求$\sum _{ i = 0  } ^{ r  } \frac { 1  } { 2 ^i  } \binom { i  } { n - k  } $,.</p>
<p>我们把模型抽象成:在二维平面上,从$( 0 , 0 ) $随机游走到$( n - k + 1 , r - n + k ) $正下方(包含这个点)的概率,容易发现此时向右走了$n - k $步,总共走了$\leq r $步,然后再向右走一步保证第一次走到了$( n - k + 1 , r - n + k ) $下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到$x + y = r + 1 $这条直线时横坐标$\geq n - k + 1 $的概率.枚举一下总共向上走了几步,就得到$\frac { 1  } { 2 ^{ r  }  } \sum _{ j = 0  } ^{ r - n + k  } \binom { r + 1  } { j  } $,注意这里是$\frac { 1  } { 2 ^r  } $,因为从一开始钦定了一步,因此映射过来需要多乘个$\frac { 1  } { 2  } $,反映射就要乘个$2 $.但是这个式子还是做不了,因为$r $并不满足$\sum r \leq 2 n $.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于$1 - \frac { 1  } { 2 ^{ r  }  } \sum _{ i = 0  } ^{ n - k  } \binom { r + 1  } { i  } $.我们考虑暴力预处理出$f _r = \sum _{ i = 0  } ^{ n  } \binom { r  } { i  } $,每次删掉一个后缀的组合数就行.现在的问题在于$f $怎么做.</p>
<p>直接拆组合数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _r & = \sum _{ i = 0  } ^n \binom { r  } { i  } \\
& = \sum _{ i = 0  } ^n \binom { r - 1  } { i - 1  } + \sum _{ i = 0  } ^n \binom { r - 1  } { i  } \\
& = 2 \sum _{ i = 0  } ^n \binom { r - 1  } { i  } - \binom { r - 1  } { n  } \\
& = 2 f _{ r - 1  } - \binom { r - 1  } { n  } 
\end{aligned}</script><h3><span id="lucas定理">Lucas定理</span></h3><p>若$p $是质数,则$C _n ^m \mod p = C _{ n \mod p  } ^{ m \mod p  } \times C _{ \lfloor \frac { n  } { p  } \rfloor  } ^{ \lfloor \frac { m  } { p  } \rfloor  } \mod p \ $.</p>
<p>或者说,将$n $和$m $在$p $进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若$i \ne 0 $且$i \ne p $,$C _{ p  } ^i \equiv \frac { p  } { i  } C _{ p - 1  } ^{ i - 1  } \equiv 0 ( \mod p ) \ $.</p>
<p>而根据二项式定理,$( 1 + x ) ^p \equiv \sum _{ i = 0  } ^p C _{ p  } ^i x ^i = 1 + x ^p ( \mod p ) \ $.</p>
<p>令$n = k _1 p + b _1 $,$m = k _2 p + b _2 $,则$( 1 + x ) ^n = ( 1 + x ) ^{ k _1 p  } ( 1 + x ) ^{ b _1  } \ $.</p>
<p>而$( 1 + x ) ^{ k _1 p  } \equiv ( 1 + x ^p ) ^{ k _1  } ( \mod p ) \ $,有$( 1 + x ) ^n \equiv ( 1 + x ^p ) ^{ k _1  } ( 1 + x ) ^{ b _1  } \ $.</p>
<p>根据二项式定理,$C _n ^m \bmod p $即$x ^m $项的系数.</p>
<p>我们可以得出,$C _n ^m x ^m \equiv C _{ k _1  } ^{ k _2  } x ^{ k _2 p  } C _{ b 1  } ^{ b _2  } x ^{ b _2  } \pmod { p  } \ $,那么有$C _a ^b \equiv C _{ k _1  } ^{ k _2  } C _{ b _1  } ^{ b _2  } \pmod { p  } \ $.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<script type="math/tex; mode=display">
\binom { n  } { m  } \equiv [ m \subseteq n ] \pmod { 2  }</script><h5><span id="example1cf1770fkoxia-and-sequence">Example1([CF1770F]Koxia and Sequence)</span></h5><p>首先观察样例并思考,可以发现当$n $为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是$0 $),所以异或值为$0 $.不然,我们可以翻转$a [ 2 . . . n ] $,得出答案应该是所有$a _1 $的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有$y ‘ \subseteq y $,求出满足$a _i \subseteq y ‘ , \sum a _i = x $时,$a _1 $异或和.接下来怎么做呢?我们考虑拆位,若$2 ^k \subseteq y ‘ $,假设$a _1 $的第$k $位是$1 $,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第$k $位贡献是:</p>
<script type="math/tex; mode=display">
[ 2 ^k \subseteq y ' ] \bigoplus _{ \sum a = x  } [ 2 ^k \subseteq a _1 ] \prod _{ i = 1  } ^n [ a _i \subseteq y ' ]</script><p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:$[ x \subseteq y ] \equiv \binom { y  } { x  } \pmod { 2  } $.</p>
<p>所以原式化简为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\binom { y '  } { 2 ^k  } \sum _{ \sum a = x  } \binom { a _1  } { 2 ^k  } \prod _{ i = 1  } ^n \binom { y '  } { a _i  } \pmod { 2  } \\
& = \binom { y '  } { 2 ^k  } \sum _{ a _1  } \binom { y ' - 2 ^k  } { a _1 - 2 ^k  } \sum _{ \sum a = x - a _1  } \prod _{ i = 2  } ^n \binom { y '  } { a _i  } \pmod { 2  } \\

\end{aligned}</script><p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\binom { y '  } { 2 ^k  } \sum _{ a _1  } \binom { y ' - 2 ^k  } { a _1 - 2 ^k  } \binom { ( n - 1 ) y '  } { x - a _1  } \pmod { 2  } \\
& = \binom { y '  } { 2 ^k  } \binom { ny ' - 2 ^k  } { x - 2 ^k  } \pmod { 2  } \\
& = [ 2 ^k \subseteq y ' ] [ ( x - 2 ^k ) \subseteq ( ny ' - 2 ^k ) ] 
\end{aligned}</script><h3><span id="扩展lucas定理">扩展Lucas定理</span></h3><p>令$p = \prod p _i ^{ e _i  } $,那我们只要对于每个$i $求出$C _n ^m \mod p _i ^{ e _i  } $,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求$C _n ^m \mod p ^k $,其中$p \in prime $.</p>
<p>原式$= \frac { n !  } { m ! ( n - m ) !  } \mod p ^k = \frac { \frac { n !  } { p ^x  }  } { \frac { m !  } { p ^y  } \frac { ( n - m ) !  } { p ^z  }  } p ^{ x - y - z  } \mod p ^k \ $.</p>
<p>现在问题转化为求$\frac { n !  } { p ^x  } \mod p ^k 以 及 p ^x \ $.</p>
<p>注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ! & = \prod _{ i = 1  } i \\
& = ( \prod _{ i = wp , w \in \mathbb { Z  }  } i ) ( \prod _{ i \ne wp , w \in \mathbb { Z  }  } i ) \\
& = p ^{ \lfloor n p \rfloor  } ( \lfloor n p \rfloor ! ) ( \prod _{ i \ne wp , w \in \mathbb { Z  }  } i ) \\
& \equiv p ^{ \lfloor \frac { n  } { p  } \rfloor  } ( \lfloor \frac { n  } { p  } \rfloor ! ) ( \prod _{ i = 1 , i \ne wp , w \in \mathbb { Z  }  } ^{ p ^k  } i ) ^{ \lfloor \frac { n  } { p ^k  } \rfloor  } ( \prod ^{ n \ \bmod { p ^k  }  } _{ i = p ^k \lfloor \frac { n  } { p ^k  } \rfloor , i \ne wp , w \in \mathbb { Z  }  } i ) ( \mod p ^k ) 
\end{aligned}</script><p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将$[ 1 , n ] $的所有数全部排成一个宽为$p ^k $的矩阵.</p>
<p>那右边第一项就是把那些$p $的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2><h3><span id="第一类斯特林数">第一类斯特林数</span></h3><p>$n \brack k \ $:长度为$n $的排列划分成$k $个轮换的方案数.</p>
<p>考虑现在已经将$n - 1 $个数分成了若干轮换,现在新加入第$n $个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然$\left [ \begin{array}{ c  } n \ k \end{array} \right ] = ( n - 1 ) \left [ \begin{array}{ c  } n - 1 \ k \end{array} \right ] + \left [ \begin{array}{ c  } n - 1 \ k - 1 \end{array} \right ] \ $.</p>
<p>特别地,我们定义$\left [ \begin{array}{ c  } 0 \ k \end{array} \right ] = [ k = 0 ] \ $.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:$\sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] = n ! $.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3><p>$\left \{ \begin{array}{ c  } n \ k \end{array} \right \} $:将$n $个本质不同的物品划分成k个非空集合的方案数.</p>
<p>考虑现在已经放好$n - 1 $个物品,正要放入第$n $个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然$\left \{ \begin{array}{ c  } n \ k \end{array} \right \} = k \left \{ \begin{array}{ c  } n - 1 \ k \end{array} \right \} + \left \{ \begin{array}{ c  } n - 1 \ k - 1 \end{array} \right \} \ $.</p>
<p>特别地,我们定义$\left \{ \begin{array}{ c  } 0 \ k \end{array} \right \} = [ k = 0 ] \ $.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3><p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:${ n \brack m  } = { - m \brace - n  } \ $.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3><ol>
<li>$x ^n = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} x ^{ \underline { k  }  } = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} ( - 1 ) ^{ n - k  } x ^{ \overline { k  }  } \ $.</li>
</ol>
<p>证明:先考虑前半段,不妨使用数学归纳.若$x ^{ n - 1  } = \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}{ c  } n - 1 \ k \end{array} \right \} x ^{ \underline { k  }  } \ $,我们要证</p>
<p>\\</p>
<script type="math/tex; mode=display">
\begin{aligned}
x \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} x ^{ \underline { k  }  } & = \sum _{ k = 0  } ^{ n  } \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} x ^{ \underline { k  }  } \\

\end{aligned}</script><p>考虑$( x - k ) x ^{ \underline { k  }  } = x ^{ \underline { k + 1  }  } $,所以$x \cdot x ^{ \underline { k  }  } = x ^{ \underline { k + 1  }  } + kx ^{ \underline { k  }  } \ $.那么左边即:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} x ^{ \underline { k + 1  }  } + \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} kx ^{ \underline { k  }  } \\
& = \sum _{ k = 1  } ^{ n  } \left \{ \begin{array}
{ c  } n - 1 \\
k - 1 
\end{array} \right \} x ^{ \underline { k  }  } + \sum _{ k = 1  } ^{ n  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} kx ^{ \underline { k  }  } \\
& = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} x ^{ \underline { k  }  } \\
\\

\end{aligned}</script><p>至于后半段,由于$x ^{ \underline { n  }  } = ( - 1 ) ^n ( - x ) ^{ \overline { n  }  } \ $,所以$x ^n = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} ( - 1 ) ^k ( - x ) ^{ \overline { k  }  } \ $.</p>
<p>不妨用$x $来代替$- x $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( - x ) ^n & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} ( - 1 ) ^k ( x ) ^{ \overline { k  }  } \\
x ^n & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} ( - 1 ) ^{ n - k  } x ^{ \overline { k  }  } 
\end{aligned}</script><ol>
<li><p>$x ^{ \overline { n  }  } = \sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] x ^k \ $.</p>
</li>
<li><p>$x ^{ \underline { n  }  } = \sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] ( - 1 ) ^{ n - k  } x ^k \ $.</p>
</li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于$( x + n - 1 ) x ^k = x ^{ k + 1  } + ( n - 1 ) x ^k \ $,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol>
<li>反转公式:$\sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} ( - 1 ) ^{ n - k  } = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} \left [ \begin{array}{ c  } k \ m \end{array} \right ] ( - 1 ) ^{ n - k  } = [ m = n ] \ $.</li>
</ol>
<p>证明:</p>
<p>考虑先证明后半部分,将(3)带入(1),得到$x ^n = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} x ^{ \underline { k  }  } = \sum _{ k = 0  } ^n \sum _{ m = 0  } ^k \left \{ \begin{array}{ c  } n \ k \end{array} \right \} \left [ \begin{array}{ c  } k \ m \end{array} \right ] ( - 1 ) ^{ n - k  } x ^m \ $.</p>
<p>由于这对任意$x $都成立,因此右边除了$x ^n $以外的项系数均为$0 $,而$x ^n $的系数为$1 $.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol>
<li><p>$\left \{ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right \} = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left \{ \begin{array}{ c  } k \ m \end{array} \right \} \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right ] = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left [ \begin{array}{ c  } k \ m \end{array} \right ] \ $.</p>
</li>
</ol>
<p>证明:对于前者,考虑组合意义,将$n + 1 $个分为$m + 1 $组,也就是先找一部分分成$m $组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3><ol>
<li><p>$\left \{ \begin{array}{ c  } n \ m \end{array} \right \} = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left \{ \begin{array}{ c  } k + 1 \ m + 1 \end{array} \right \} ( - 1 ) ^{ n - k  } \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n \ m \end{array} \right ] = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left [ \begin{array}{ c  } k + 1 \ m + 1 \end{array} \right ] ( - 1 ) ^{ n - k  } \ $.</p>
</li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol>
<li>$m ! \left \{ \begin{array}{ c  } n \ m \end{array} \right \} = \sum _{ k = 0  } ^m C _m ^k k ^n ( - 1 ) ^{ m - k  } \ $.</li>
</ol>
<p>证明:首先有$m ^n = \sum _{ k = 0  } ^m m ^{ \underline { k  }  } \left \{ \begin{array}{ c  } m \ k \end{array} \right \} = \sum _{ k = 0  } ^m k ! C _m ^k \left \{ \begin{array}{ c  } m \ k \end{array} \right \} \ $,对这个式子进行二项式反演即可.</p>
<ol>
<li>$\left \{ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right \} = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } k \ m \end{array} \right \} ( m + 1 ) ^{ n - k  } \ $.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前$k $个分为$m $组,把第$k + 1 $个数放到第$m + 1 $组.然后剩下$( n + 1 ) - ( k + 1 ) = n - k $个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第$m + 1 $组(最小值最大的那组)在$k $不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol>
<li>$\left [ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right ] = \sum _{ k = 0  } ^n \left [ \begin{array}{ c  } k \ m \end{array} \right ] C _{ n  } ^k ( n - k ) ! = n ! \sum _{ k = 0  } ^n \frac { \left [ \begin{array}{ c  } k \ m \end{array} \right ]  } { k !  } \ $.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果$n &gt; 0 $,我们有$\left [ \begin{array}{ c  } n \ 1 \end{array} \right ] = ( n - 1 ) ! \ $.这个式子很显然,我们现在有一个长度为$n - 1 $的环,想要往里插入第$n $个数有$n - 1 $种选择,所以我们有:$\left [ \begin{array}{ c  } n \ 1 \end{array} \right ] = \left [ \begin{array}{ c  } n - 1 \ 1 \end{array} \right ] ( n - 1 ) \ $,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将$n + 1 $个数划分成$m + 1 $个环,我们先将其中$k $个数划分成$m $个环,剩下$n + 1 - k $个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第$n + 1 $个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于$C _n ^k ( n - k ) ! = C _n ^{ n - k  } ( n - k ) ! = n ^{ \underline { n - k  }  } = \frac { n !  } { k !  } \ $.因此后半部分也得证.</p>
<ol>
<li><p>$\left \{ \begin{array}{ c  } n + m + 1 \ m \end{array} \right \} = \sum _{ k = 0  } ^m k \left \{ \begin{array}{ c  } n + k \ k \end{array} \right \} \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n + m + 1 \ m \end{array} \right ] \sum _{ k = 0  } ^m ( n + k ) \left [ \begin{array}{ c  } n + k \ k \end{array} \right ] \ $.</p>
</li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将$n + k $个位置分到$k $个集合之后.还剩下$( n + m + 1 ) - ( n + k ) = ( m - k + 1 ) $个数,剩下$( m - k ) $个集合.</p>
<p>拿出来$( n + k + 1 ) $这个数,剩下的数刚好够每个集合放一个.最后枚举一下把$( n + k + 1 ) $放在哪里即可.由于每个划分一定存在一段(可能是$0 $)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol>
<li>$C _n ^m ( n - 1 ) ^{ \underline { n - m  }  } = \sum _{ k = m  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} \ $.</li>
</ol>
<p>证明:</p>
<p>考虑$( n - 1 ) ^{ \underline { n - m  }  } = \frac { ( n - 1 ) !  } { ( m - 1 ) !  } \ $,不妨设$f ( n , m ) = \sum _{ k = m  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} \ $,相当于将$n $个数分成非空$m $组,然后组内的数要形成若干轮换的方案数.那么知道$f ( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m ) f ( n - 1 , m ) \ $.</p>
<p>设$g ( n , m ) = C _n ^m \frac { ( n - 1 ) !  } { ( m - 1 ) !  } = \frac { n ! ( n - 1 ) !  } { m ! ( n - m ) ! ( m - 1 ) !  } \ $,那么知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n - 1 , m - 1 ) & = \frac { ( n - 1 ) ! ( n - 2 ) !  } { ( m - 1 ) ! ( n - m ) ! ( m - 2 ) !  } \\
g ( n - 1 , m ) & = \frac { ( n - 1 ) ! ( n - 2 ) !  } { m ! ( n - 1 - m ) ! ( m - 2 ) !  } \\

\end{aligned}</script><p>显然$g ( n , m ) = g ( n - 1 , m - 1 ) + ( n - 1 + m ) g ( n - 1 , m ) \ $,数学归纳即可.</p>
<ol>
<li><p>$C _n ^m = \frac { n !  } { m ! ( n - m ) !  } = \sum _{ k = m  } ^n \left \{ \begin{array}{ c  } n + 1 \ k + 1 \end{array} \right \} \left [ \begin{array}{ c  } k \ m \end{array} \right ] ( - 1 ) ^{ m - k  } \ $.</p>
</li>
<li><p>$n ^{ \underline { n - m  }  } = \frac { n !  } { m !  } = \sum _{ k = m  } ^n \left [ \begin{array}{ c  } n + 1 \ k + 1 \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} ( - 1 ) ^{ m - k  } ， 其 中 m \leq n \ $.</p>
</li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol>
<li><p>$\left \{ \begin{array}{ c  } n \ l + m \end{array} \right \} C _{ l + m  } ^l = \sum _{ k = l  } ^n \left \{ \begin{array}{ c  } k \ l \end{array} \right \} \left \{ \begin{array}{ c  } n - k \ m \end{array} \right \} C _n ^k \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n \ l + m \end{array} \right ] C _{ l + m  } ^l = \sum _{ k = l  } ^n \left [ \begin{array}{ c  } k \ l \end{array} \right ] \left [ \begin{array}{ c  } n - k \ m \end{array} \right ] C _n ^k \ $.</p>
</li>
</ol>
<p>证明:先考虑前者,左边即先将$n $个数分为$l + m $个集合,然后再挑出$l $个集合.那不妨枚举这$l $个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2><p>记$\left \langle \begin{array}\ n \ k \end{array} \right \rangle $表示$\{ 1 , 2 , . . . , n \} $的排列$a $中满足这条性质的排列个数:存在且只存在$k $个升高,换句话说,存在且只存在$k $个$i $,满足$1 \leq i &lt; n $,$a _i &lt; a _{ i + 1  } $.不难发现$\left \langle \begin{array}\ n \ k \end{array} \right \rangle = \left \langle \begin{array}\ n \ n - k - 1 \end{array} \right \rangle $.</p>
<p>考虑在一个$\{ 1 , 2 , . . . , n - 1 \} $的排列中插入$n $,设插入的位置是原本$a _i $的后面,那么要么原本$a _i &lt; a _{ i + 1  } $,要么反之.前者不会改变排列的升高的数量,后者则会增加$1 $.另外还有一种情况是插入到了序列最前面.于是我们自然得到:$\left \langle \begin{array}\ n \ k \end{array} \right \rangle = ( k + 1 ) \left \langle \begin{array}\ n - 1 \ k \end{array} \right \rangle + ( n - k ) \left \langle \begin{array}\ n - 1 \ k - 1 \end{array} \right \rangle $.</p>
<p>特别地,我们令$\left \langle \begin{array}\ 0 \ k \end{array} \right \rangle = [ k = 0 ] $,若$k &lt; 0 $,则$\left \langle \begin{array}\ n \ k \end{array} \right \rangle = 0 $.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3><p>我们有Worpitzky恒等式:</p>
<script type="math/tex; mode=display">
x ^n = \sum _{ k \geq 0  } \binom { x + k  } { n  } \left \langle \begin{array}
\\
n \\
k 
\end{array} \right \rangle , n \in \mathbb { N  }</script><p>还有另一个恒等式:</p>
<script type="math/tex; mode=display">
\left \langle \begin{array}
\\
n \\
m 
\end{array} \right \rangle = \sum _{ k = 0  } ^m \binom { n + 1  } { k  } ( m + 1 - k ) ^n ( - 1 ) ^k</script><p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2><p>定义$B _j $为第$j $个伯努利数,且满足$\sum _{ j = 0  } ^m \binom { m + 1  } { j  } B _j = [ m = 0 ] , m \geq 0 \ $.</p>
<p>定义$S _m ( n ) = \sum _{ i = 0  } ^{ n - 1  } i ^m $.</p>
<p>伯努利数满足公式:$S _m ( n ) = \cfrac { 1  } { m + 1  } \sum _{ k = 0  } ^m \binom { m + 1  } { k  } B _k n ^{ m + 1 - k  } \ $.</p>
<p>证明如下:</p>
<p>对$S _{ m + 1  } ( n ) $使用扰动法,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ m + 1  } ( n ) + n ^{ m + 1  } & = \sum _{ k = 0  } ^{ n - 1  } ( k + 1 ) ^{ m + 1  } \\
& = \sum _{ k = 0  } ^{ n - 1  } \sum _{ j = 0  } ^{ m + 1  } \binom { m + 1  } { j  } k ^j \\
& = \sum _{ j = 0  } ^{ m + 1  } \binom { m + 1  } { j  } S _j ( n ) \\
& = \sum _{ j = 0  } ^{ m  } \binom { m + 1  } { j  } S _j ( n ) + S _{ m + 1  } ( n ) \\
n ^{ m + 1  } & = \sum _{ j = 0  } ^m \binom { m + 1  } { j  } S _j ( n ) \\

\end{aligned}</script><p>接下来使用数学归纳,假设$0 \leq j &lt; m $时该公式成立,并假设有$S _m ( n ) = \cfrac { 1  } { m + 1  } \sum _{ k = 0  } ^m \binom { m + 1  } { k  } B _k n ^{ m + 1 - k  } + \Delta \ $,我们只需要证明$\Delta = 0 $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ^{ m + 1  } & = \sum _{ j = 0  } ^m \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } \sum _{ k = 0  } ^j \binom { j + 1  } { k  } B _k n ^{ j + 1 - k  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k  } \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _k n ^{ j + 1 - k  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { j - k  } \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k + 1  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k + 1  } \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k + 1  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  } \sum _{ j = k  } ^m B _{ j - k  } \binom { m + 1  } { j  } \binom { j  } { k  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  } \binom { m + 1  } { k  } \sum _{ j = k  } ^m B _{ j - k  } \binom { m + 1 - k  } { j - k  } + ( m + 1 ) \Delta \\
& = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom { m + 1  } { k  } \sum _{ j = 0  } ^{ m - k  } B _{ j  } \binom { m + 1 - k  } { j  } + ( m + 1 ) \Delta \\
& = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom { m + 1  } { k  } [ m - k & = 0 ] + ( m + 1 ) \Delta \\
& = n ^{ m + 1  } + ( m + 1 ) \Delta 
\end{aligned}</script><p>显然$\Delta = 0 $,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2><p>定义斐波那契数$F _n = \begin{cases}0 &amp; n = 0 \ 1 &amp; n = 1 \ F _{ n - 1  } + F _{ n - 2  } &amp; n &gt; 1 \end{cases} $.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3><p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<script type="math/tex; mode=display">
F _{ n + 1  } F _{ n - 1  } - F _n ^2 = ( - 1 ) ^n , n > 0</script><p>事实上,如果我们将斐波那契数的递推式改写作:$F _n = F _{ n + 2  } - F _{ n + 1  } $,我们可以在$n \in \mathbb { Z  } $的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<script type="math/tex; mode=display">
F _{ - n  } = ( - 1 ) ^{ n - 1  } F _n , n \in \mathbb { Z  }</script><h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3><p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F _{ n + k  } & = F _k F _{ n + 1  } + F _{ k - 1  } F _n \\
F _{ n + m + 1  } & = F _{ n + 1  } F _{ m + 1  } + F _n F _m 
\end{aligned}</script><p>另外,如果我们在上面这个式子中取$k = wn , w \in \mathbb { N  } $并使用归纳法,我们又可以得到一个性质:$F _{ kn  } $是$F _n $的倍数,$k \in \mathbb { Z  } $.</p>
<p>再观察这个式子,使用归纳法可以证明$\gcd ( F _{ n  } , F _{ n - 1  } ) = 1 $,进一步有:$\gcd ( F _{ n + m  } , F _m ) = \gcd ( F _n , F _m ) $.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<script type="math/tex; mode=display">
\gcd ( F _m , F _n ) = F _{ \gcd ( n , m )  }</script><p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<script type="math/tex; mode=display">
F _n ^2 | F _m \Leftrightarrow nF _n | m , n > 2</script><p>这个引理的证明如下:</p>
<p>由于$F _{ n + 1  } \equiv F _{ n - 1  } \pmod { F _n  } $.于是我们有:$F _{ 2 n  } = F _n F _{ n + 1  } + F _{ n - 1  } F _n $,也就是$F _{ 2 n  } \equiv 2 F _n F _{ n + 1  } \pmod { F _n ^2  } $.</p>
<p>另外我们有:$F _{ 2 n + 1  } \equiv F _{ n + 1  } ^2 \pmod { F _n ^2  } $.</p>
<p>同理,使用归纳法可以证明:$F _{ kn  } \equiv kF _n F _{ n + 1  } ^{ k - 1  } \pmod { F _n ^2  } , F _{ kn + 1  } \equiv F _{ n + 1  } ^k \pmod { F _n ^2  } $.</p>
<p>而$F _{ n + 1  } \bot F _n $,于是$F _{ kn  } \equiv 0 \pmod { F _n ^2  } \Leftrightarrow k \equiv 0 \pmod { F _n  } , n &gt; 2 $.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3><p>我们如果定义$j \gg k \Leftrightarrow j \geq k + 2 $,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:$n = \sum _{ i = 1  } ^r F _{ k _i  } , \forall 1 \leq i &lt; r , k _i \gg k _{ i + 1  } \gg 0 $.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果$\exists k $满足$F _k = n $,则显然成立,不然,应$\exists k $满足$F _k &lt; n &lt; F _{ k + 1  } $,而$n - F _k $的表示已经存在了.另外,由于$n - F _k &lt; F _{ k + 1  } - F _k = F _{ k - 1  } $,因此必定不可能出现选了$F _k $又选了$F _{ k - 1  } $的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择$F _k $而是选择$F _{ k - 1  } $,那么显然接下来无论怎么选,它们的加和都不可能大于等于$F _k $,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数$n $以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3><p>使用生成函数,令$F ( z ) = \sum _{ k \geq 0  } F _k z ^k $.那么不难发现$F ( z ) - zF ( z ) - z ^2 F ( z ) = z $,也就是$F ( z ) = \cfrac { z  } { 1 - z - z ^2  } $.</p>
<p>考虑这个形式一定可以分解为$F ( z ) = \cfrac { a  } { 1 - \alpha z  } + \cfrac { b  } { 1 - \beta z  } $的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令$\phi = \cfrac { 1 + \sqrt { 5  }  } { 2  } , \hat \phi = \cfrac { 1 - \sqrt { 5  }  } { 2  } $,那么可以得到$F _n = \cfrac { 1  } { \sqrt { 5  }  } ( \phi ^n - \hat \phi ^n ) $.</p>
<p>另外,由于$\hat \phi ^n $的影响很小,于是又有$F _n = \lfloor \cfrac { \phi ^n  } { \sqrt { 5  }  } + 0 . 5 \rfloor $.</p>
<h3><span id="连项式">连项式</span></h3><p>连项式多项式$K _n ( x _1 , x _2 , . . . , x _n ) $定义为:$K _n ( x _1 , x _2 , . . . , x _n ) = \begin{cases}1 &amp; n = 0 \ x _1 &amp; n = 1 \ x _n K _{ n - 1  } ( x _1 , x _2 , . . . x _{ n - 1  } ) + K _{ n - 2  } ( x _1 , x _2 , . . . , x _{ n - 2  } ) &amp; n \geq 2 \end{cases} $.</p>
<p>通过定义不难发现:$K _n ( 1 , 1 , . . . , 1 ) = F _{ n + 1  } $.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数$( x _{ n - 1  } , x _n ) $.我们考虑用这样一种形式的字符串来表示最后某一项的情况:’.’为还没有消除掉的项,长度为$1 $;’-‘为已经消除了的两项,长度为$2 $.那么$K _n ( x _1 , x _2 , . . . , x _n ) $就可以表示为一个长度为$n $的字符串,其中若有$k $个’-‘,有$n - 2 k $个’.’,则有$\binom { n - k  } { k  } $种不同的排列方式.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
K _n ( z , z , . . . , z ) & = \sum _{ k = 0  } ^n \binom { n - k  } { k  } z ^{ n - 2 k  } \\

\end{aligned}</script><p>另外,这也导出:$F _{ n + 1  } = \sum _{ k = 0  } ^n \binom { n - k  } { k  } \ $.</p>
<p>考虑上面的构造过程,不难发现$K _n ( x _1 , x _2 , . . . , x _n ) = K _n ( x _n , x _{ n - 1  } , . . . , x _1 ) $.</p>
<p>于是递归式可以写成:$K _n ( x _1 , x _2 , . . . , x _n ) = x _1 K _{ n - 1  } ( x _2 , x _3 , . . . x _{ n  } ) + K _{ n - 2  } ( x _3 , x _4 , . . . , x _{ n  } ) $.</p>
<p>进一步地,不断展开后得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
K _{ m + n  } ( x _1 , . . . , x _m , x _{ m + 1  } , . . . , x _{ n + m  } ) & = \\
K _m ( x _1 , . . . , x _m ) K _n ( x _{ m + 1  } , . . . , x _{ n + m  } ) + K _{ m - 1  } ( x _1 , . . . , x _{ m - 1  } ) K _{ n - 1  } ( x _{ m + 2  } , . . . , x _{ n + m  } ) 
\end{aligned}</script><p>另外,根据连项式的定义,不难导出$K _n ( x _1 , . . . , x _n + y ) = K _n ( x _1 , . . . , x _n ) + K _{ n - 1  } ( x _1 , . . . , x _{ n - 1  } ) y $.</p>
<p>由这个公式可以推出:$\cfrac { K _{ n + 1  } ( a _0 , . . . , a _n )  } { K _n ( a _1 , . . . , a _n )  } = \cfrac { K _n ( a _0 , . . . , a _{ n - 1  } + \cfrac { 1  } { a _n  } )  } { K _{ n - 1  } ( a _1 , . . . , a _{ n - 1  } + \cfrac { 1  } { a _n  } )  } $.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<script type="math/tex; mode=display">
\cfrac { K _{ n + 1  } ( a _0 , . . . , a _n )  } { K _n ( a _1 , . . . , a _n )  } = a _0 + \cfrac { 1  } { a _1 + \cfrac { 1  } { a _2 + \cfrac { 1  } { a _3 + . . .  }  }  }</script><p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" class="post-title-link" itemprop="url">简单乐理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="前言">前言</span></h3><p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3><h4><span id="拍音理论">拍音理论</span></h4><p>假设两个正弦单音的频率分别是$\omega , \omega + \delta $,那么它们叠加后是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
& = 2 \sin \left ( 2 \pi ( \omega + \frac { \delta  } { 2  } ) t \right ) \cos ( \pi \delta t ) 
\end{aligned}</script><p>注意到这个声音受到$\cos ( \pi \delta t ) $的控制.因此会以$\frac { \delta  } { 2  } $的频率振动,由于$\delta $应该远小于$\omega $,这里就会产生$\delta = | \omega _1 - \omega _2 | $个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4><p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol>
<li><p>弦长$L $.</p>
</li>
<li><p>张力$T $.</p>
</li>
<li><p>线密度$\rho $.</p>
</li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点$u ( x , t ) $,首先是一维振动方程:</p>
<script type="math/tex; mode=display">
\frac { \partial ^2 u  } { \partial x ^2  } = \frac { \rho  } { T  } \frac { \partial ^2 u  } { \partial t ^2  }</script><p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<script type="math/tex; mode=display">
u _n ( x , t ) = c _n \sin ( \omega _n t + \theta _n ) \sin ( \frac { n \pi  } { L  } x )</script><p>其中第$n $项的频率满足:</p>
<script type="math/tex; mode=display">
f _n = \frac { n  } { 2 L  } \sqrt { \frac { T  } { \rho  }  }</script><p>其中我们将$f _1 $称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中$f _n , n \geq 2 $对应的是第$n - 1 $泛音.</p>
<p>特别地,如果我们干脆记$f = f _1 $,上述结果告诉我们弦的振动产生的一列频率是:</p>
<script type="math/tex; mode=display">
f , 2 f , 3 f , \cdots</script><p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的$n $,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0" alt></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的$f _{ 2 k + 1  } $,泛音列中只剩下$2 f , 4 f , \cdots $.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按$\frac { 1  } { 3  } $处呢?那泛音列中就会只剩下$3 f , 6 f , 9 f , \cdots $,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是$f , 3 f , 5 f , \cdots $.</p>
<h4><span id="管乐器">管乐器</span></h4><p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<script type="math/tex; mode=display">
f , 2 f , 3 f , 4 f , \cdots</script><p>闭管的泛音列:</p>
<script type="math/tex; mode=display">
f , 3 f , 5 f , 7 f</script><p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4><p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots 
\end{gathered}</script><p>或是:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac { 3  } { 2  } f , 3 f , \frac { 9  } { 2  } f , 6 f , \cdots 
\end{gathered}</script><p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3><p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是$L _p = 20 \log _{ 10  } ( \frac { p  } { p _0  } ) $,其中$p _0 = 20 \mu Pa $.</p>
<h4><span id="音程">音程</span></h4><p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<p>| 度数 | 半音数 | 名称   |</p>
<p>| —— | ——— | ——— |</p>
<p>| 一   | 0      | 纯一度 |</p>
<p>| 二   | 1      | 小二度 |</p>
<p>| 二   | 2      | 大二度 |</p>
<p>| 三   | 3      | 小三度 |</p>
<p>| 三   | 4      | 大三度 |</p>
<p>| 四   | 5      | 纯四度 |</p>
<p>| 四   | 6      | 增四度 |</p>
<p>| 五   | 6      | 减五度 |</p>
<p>| 五   | 7      | 纯五度 |</p>
<p>| 六   | 8      | 小六度 |</p>
<p>| 六   | 9      | 大六度 |</p>
<p>| 七   | 10     | 小七度 |</p>
<p>| 七   | 11     | 大七度 |</p>
<p>| 八   | 12     | 纯八度 |</p>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<p>| 音程   | 频率比 |</p>
<p>| ——— | ——— |</p>
<p>| 纯八度 | $2 : 1 $  |</p>
<p>| 纯五度 | $3 : 2 $  |</p>
<p>| 纯四度 | $4 : 3 $  |</p>
<p>| 大三度 | $5 : 4 $  |</p>
<p>| 小三度 | $6 : 5 $  |</p>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4><p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定$C $的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为$1 $,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求$\{ 7 k \} \pmod { 12  } $这个数列对吧,简单数论知识告诉我们它必然能遍历$12 $种情况,具体而言:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C \to & & G \to & & D \to & & A \to & & E \to & & B \to \\
1 \to & & \frac { 3  } { 2  } \to & & \frac { 3 ^2  } { 2 ^3  } \to & & \frac { 3 ^3  } { 2 ^4  } \to & & \frac { 3 ^4  } { 2 ^6  } \to & & \frac { 3 ^5  } { 2 ^7  } \to \\
\\
\\
\# F \to & & \# C \to & & \# G \to & & \# D \to & & \# A \to & & \# E \\
\frac { 3 ^6  } { 2 ^9  } \to & & \frac { 3 ^7  } { 2 ^{ 11  }  } \to & & \frac { 3 ^8  } { 2 ^{ 12  }  } \to & & \frac { 3 ^9  } { 2 ^{ 14  }  } \to & & \frac { 3 ^{ 10  }  } { 2 ^{ 15  }  } \to & & \frac { 3 ^{ 11  }  } { 2 ^{ 17  }  } \\

\end{aligned}</script><p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度$CE $的比是$\frac { 81  } { 64  } &gt; \frac { 80  } { 64  } = \frac { 5  } { 4  } $.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的$# E \ne F $,你对着这个$# E $往上再升一个音得到的理应是$C ‘ = \frac { 3 ^{ 12  }  } { 2 ^{ 18  }  } &gt; 2 $,具体来说$\frac { 3 ^{ 12  }  } { 2 ^{ 19  }  } \approx 1 . 013643 $,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于$1 $的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升$12 $个纯五度,再下降$7 $个纯八度理应回到原点,可是:</p>
<script type="math/tex; mode=display">
( \frac { 3  } { 2  } ) ^{ 12  } \times ( \frac { 1  } { 2  } ) ^7 > 1</script><p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4><p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定$C $的频率为$1 $.接下来用正三和弦(一个大三度和一个小三度)$I : C - E - G $,$IV : F - A - C ‘ $,$V : G - B - D ‘ $的比例是$4 : 5 : 6 $确定剩下的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C & & D & & E & & F & & G & & A & & B & & C ' & & D ' \\
1 & & \frac { 9  } { 8  } & & \frac { 5  } { 4  } & & \frac { 4  } { 3  } & & \frac { 3  } { 2  } & & \frac { 5  } { 3  } & & \frac { 15  } { 8  } & & 2 & & \frac { 9  } { 4  } 
\end{aligned}</script><p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol>
<li><p>五度音程$D - A $不协和,比例为$\frac { 80  } { 54  } &lt; \frac { 81  } { 54  } = \frac { 3  } { 2  } $.这直接导致了转调会出错.</p>
</li>
<li><p>有两种不同的大二度:音程$C - D , F - G , A - B $的比例是$\frac { 9  } { 8  } $而音程$D - E , G - A $的比例为$\frac { 10  } { 9  } $.</p>
</li>
<li><p><strong>谐调音差</strong>:从$C $出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:$( \frac { 3  } { 2  } ) ^4 \times ( \frac { 1  } { 2  } ) ^2 \times \frac { 4  } { 5  } = \frac { 81  } { 80  } = 1 . 0125 &gt; 1 $.</p>
</li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4><p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用$\sqrt [12 ] { 2  } $来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是$f _1 , f _2 $,则它们的音分数定义为$1200 \log _2 ( \frac { f _2  } { f _1  } ) $,容易见到十二平均律拿到的一个半音恰好是$100 $音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3><h4><span id="大小调">大小调</span></h4><h5><span id="自然大调">自然大调</span></h5><p>就是我们最常用的$CDEFGABC ‘ $,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol>
<li><p>主音</p>
</li>
<li><p>上主音</p>
</li>
<li><p>中音</p>
</li>
<li><p>下属音</p>
</li>
<li><p>属音</p>
</li>
<li><p>下中音</p>
</li>
<li><p>导音</p>
</li>
</ol>
<p>用五度相生,下属音$\rightarrow $主音$\rightarrow $属音.</p>
<h5><span id="自然小调">自然小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以$ABCDEFG $用的调子,然而这里的问题是$G $作为导音却和$A ‘ $差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用$A , B , C , D , E , F , ( ^# G ) $.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用$A , B , C , D , E , ( ^# F ) , ( ^# G ) $.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4><p>以五度相生:</p>
<script type="math/tex; mode=display">
C \to G \to D \to A \to E \to B \to ( ^\# F ) \to ( ^\# C )</script><p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从$C $开始每次往后跳一次都要在一个音阶上增一个升号.从$C $大调提升到$G $大调的时候就是将$C $的下属音(也就是$F $)升音.</p>
<p>对称地,反方向的五度相生:</p>
<script type="math/tex; mode=display">
C \to F \to ( ^b B ) \to ( ^b E ) \to ( ^b A ) \to ( ^b D ) \to ( ^b G ) \to ( ^b C )</script><p>那这个应该降什么呢?比如从$C $大调提升到$F $大调的时候就是将$F $的下属音$B $降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png" alt></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3><h4><span id="三和弦">三和弦</span></h4><p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol>
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成$4 : 5 : 6 $的频率关系.</p>
</li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p>
</li>
<li><p>减三和弦:两个小三度.</p>
</li>
<li><p>增三和弦:两个大三度.</p>
</li>
</ol>
<h4><span id="七和弦">七和弦</span></h4><p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol>
<li><p>减减七和弦(减七和弦):小小小.</p>
</li>
<li><p>减小七和弦(半减七和弦):小小大.</p>
</li>
<li><p>小小七和弦(小七和弦):小大小.</p>
</li>
<li><p>小大七和弦:小大大.</p>
</li>
<li><p>大小七和弦(属七和弦):大小小.</p>
</li>
<li><p>大大七和弦(大七和弦):大小大.</p>
</li>
<li><p>增大七和弦:大大小.</p>
</li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4><p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol>
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p>
</li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p>
</li>
</ol>
<p>对于七和弦来说:</p>
<ol>
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p>
</li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p>
</li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p>
</li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4><p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为$C - E - G $,$F - A - C ‘ $,$G - B - D ‘ $.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol>
<li><p>正格进行:$I \to V \to I $.</p>
</li>
<li><p>变格进行:$I \to IV \to I $.</p>
</li>
<li><p>复式进行:$I \to IV \to V \to I $.</p>
</li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<script type="math/tex; mode=display">
\xymatrix { & & & & I \\
& & IV \ar [r ] \ar [d ] \ar [dr ] \ar [rru ] & vii \degree \ar [ru ] & \\
iii \ar [r ] & vi \ar [r ] \ar [ru ] & ii \ar [r ] \ar [ru ] & V \ar [ruu ] &  }</script><p>其中$I $较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4><p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol>
<li><p>平行变换$P $:保持纯五度音阶不变,将三音切换.</p>
</li>
<li><p>关系变换$R $:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p>
</li>
<li><p>导音变换$L $:保持小三度音阶不变,补上剩下的一个.</p>
</li>
</ol>
<p>容易见到$R \circ ( L \circ R ) ^3 = P $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" class="post-title-link" itemprop="url">程序设计实习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2><h3><span id="基本分析">基本分析</span></h3><h4><span id="union-bound">Union Bound</span></h4><p>即:$Pr [ \bigcup _i X _i ] \leq \sum Pr [ X _i ] $,取等当且仅当所有$X _i $互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4><p>若$X \geq 0 $,则$Pr [ X \geq t \mathbb { E  } [ X ] ] \leq \frac { 1  } { t  } $.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6><p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有$\frac { 1  } { 2  } $的概率是割边,因此期望自然是$\frac { 1  } { 2  } | E | \geq \frac { 1  } { 2  } | \text { max - cut  } | $.</p>
<p>由此立即见到,$Pr [ | ans | \leq ( \frac { 1  } { 2  } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac { 1  } { 2  } + \epsilon ) | E | ] \leq \frac { 1  } { 1 + 2 \epsilon  } $.</p>
<p>由于每次独立操作,因此如果有$P $的概率失败,那么运行$T $次后至少成功一次的概率应当为$1 - P ^T $.从而$T = O ( \log _P { \delta  } ) = O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \ln ( 1 + { 2 \epsilon  } )  } ) \approx O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \epsilon  } ) $即可拿到$\delta $失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4><p>设$X _1 , \cdots , X _n \in [ 0 , 1 ] $是独立,同期望(期望为$\mu \geq t $)的随机变量,令$X = \frac { \sum _k X _k  } { n  } $,对于任何失败概率$\delta \in ( 0 , 1 ) $,应当有:</p>
<script type="math/tex; mode=display">
Pr \left [ | X - \mu | \geq \sqrt { \cfrac { \log ( 1 / \delta )  } { nt  }  } \mu \right ] \leq \delta</script><h6><span id="examplemedian-trick">Example(Median Trick)</span></h6><p>现在有一个黑盒能够以$p &gt; \frac { 1  } { 2  } $的概率正确回答Yes或者No,问重复$T $选多少次能拿到$1 - \delta $的成功概率.</p>
<p>考虑重复$T $次后应当有期望$pT $个正确答案,因此直接取中位数.称此算法为Median Trick.</p>
<p>Chernoff Bound 告诉我们$T = O ( \log \frac { 1  } { \delta  } ) $足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4><p>设独立随机变量$x _1 , \cdots , x _m \in [ s , t ] $,令$X = \sum _i x _i $,则:</p>
<script type="math/tex; mode=display">
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac { 2 z ^2  } { m ( t - s ) ^2  } \right )</script><h3><span id="编程中的随机性">编程中的随机性</span></h3><p>一般采用伪随机,也即是给定初值$X _0 $,通过某个确定性的函数来生成$X _{ n + 1  } = f ( X _n ) $这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2><h3><span id="基本定义">基本定义</span></h3><p>概率空间$\Omega $:在一个给定问题中可能发生的所有情况.</p>
<p>事件:$\Omega $的一个子集.</p>
<p>基本事件$\omega $:$\Omega $中的单个元素,也可以看作集合大小为$1 $的事件.</p>
<p>概率:若$\omega \in \Omega $,我们称它发生的概率为$\Pr ( \omega ) $,有$\Pr ( \omega ) \geq 0 $且$\sum _{ \omega \in \Omega  } \Pr ( \omega ) = 1 $.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量$X $和$Y $定义在同一个概率空间$\Omega $上,对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,我们称$\Pr ( X = x \land Y = y ) $为它们的联合分布.</p>
<p>独立:如果对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,$\Pr ( X = x \land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y ) $,我们称$X $和$Y $是独立的.</p>
<p>期望(均值)$E X $:我们设概率空间上的随机变量$X $的期望$EX = \sum _{ x \in X ( \Omega )  } x \times \Pr ( X = x ) = \sum _{ w \in \Omega  } X ( \omega ) \Pr ( \omega ) $.</p>
<p>中位数:我们设概率空间上的随机变量$X $的中位数为满足$\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x ) \geq 0 . 5 $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量$X $的众数为满足$\Pr ( X = x ) \geq \Pr ( X = x ‘ ) , \forall x ‘ \in X ( \Omega ) $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>方差$VX $:我们设概率空间上的随机变量$X $的方差$VX = E ( ( X - EX ) ^2 ) $.</p>
<p>标准差$\sigma $:我们设概率空间上的随机变量$X $的标准差$\sigma = \sqrt { VX  } $.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3><p>如果$X , Y $是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol>
<li><p>$E ( X + Y ) = EX + EY $.</p>
</li>
<li><p>$E ( \alpha X ) = \alpha EX $.</p>
</li>
<li><p>如果$X $和$Y $互相独立,那么$E ( XY ) = ( EX ) ( EY ) $.</p>
</li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3><p>我们考虑方差的定义式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X - EX ) ^2 ) & = E ( X ^2 - 2 X ( EX ) + ( EX ) ^2 ) \\
& = E ( X ^2 ) - 2 ( EX ) ( EX ) + ( EX ) ^2 \\
& = E ( X ^2 ) - ( EX ) ^2 
\end{aligned}</script><p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当$X $和$Y $为独立的随机变量时,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( ( X + Y ) ^2 ) - ( EX + EY ) ^2 \\
& = E ( ( X + Y ) ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 
\end{aligned}</script><p>而又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X + Y ) ^2 ) & = E ( X ^2 + 2 XY + Y ^2 ) \\
& = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) 
\end{aligned}</script><p>则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 \\
& = VX + VY 
\end{aligned}</script><p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<script type="math/tex; mode=display">
\Pr ( ( X - EX ) ^2 \geq \alpha ) \leq \cfrac { VX  } { \alpha  } , \alpha > 0</script><p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
VX & = \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) \\
& \geq \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& \geq \sum _{ \omega \in \Omega  } \alpha \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& = \alpha \Pr ( ( X - EX ) ^2 & \geq \alpha ) 
\end{aligned}</script><p>如果我们用$c ^2 VX $代替$\alpha $,我们就有:</p>
<p>$\Pr ( | X - EX | \geq c \sigma ) \leq \cfrac { 1  } { c ^2  } $.</p>
<p>简单来说,这个不等式说明:$X $落在$( EX - c \sigma , EX + c \sigma ) $之外的概率至多为$\cfrac { 1  } { c ^2  } $.</p>
<p>另外,如果我们取$n $个独立的样本$X _1 , X _2 , . . . , X _n $,令$S = \sum _{ i = 1  } ^n X _i $,那么它的均值是$nEX $,标准差是$\sqrt { n  } \sigma $,也就是说,$\cfrac { S  } { n  } $落在$( EX - \cfrac { c \sigma  } { \sqrt { n  }  } , EX + \cfrac { c \sigma  } { \sqrt { n  }  } ) $之外的概率小于等于$\cfrac { 1  } { c ^2  } $.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3><p>如果我们随机取得了$n $个值$X _1 , X _2 , . . . , X _n $,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p>$\hat EX = \cfrac { \sum _{ i = 1  } ^n X _i  } { n  } $.</p>
<p>$\hat VX = \cfrac { \sum _{ i = 1  } ^n X _i ^2  } { n - 1  } - \cfrac { ( \sum _{ i = 1  } ^n X _i ) ^2  } { n ( n - 1 )  } $.</p>
<p>这里的$\hat VX $似乎与定义不是那么相符.但是它拥有更好的性质:$E ( \hat VX ) = VX $.</p>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( \hat VX ) & = \cfrac { 1  } { n - 1  } E ( \sum _{ i = 1  } ^n X _i ^2 - \cfrac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n X _j X _k ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X _i ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n E ( X _i X _j ) ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( ( EX ) ^2 [ j \ne k ] + E ( X ^2 ) [ j & = k ] ) ) \\
& = \cfrac { 1  } { n - 1  } ( nE ( X ^2 ) - \cfrac { 1  } { n  } ( nE ( X ^2 ) + n ( n - 1 ) ( EX ) ^2 ) ) \\
& = E ( X ^2 ) - ( EX ) ^2 \\
& = VX 
\end{aligned}</script><h3><span id="条件概率">条件概率</span></h3><p>已知事件B发生时事件A发生的概率为$P ( A | B ) = \frac { P ( AB )  } { P ( B )  } \ $.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4><p>贝叶斯公式:如果有$\{ B _i \} $是样本空间的一个划分,即$\forall i , j $,有$B _i \cap B _j = \emptyset $,并且有$\bigcup _{ i = 1  } ^n B _i = \Omega $.则有$P ( B _i | A ) = \frac { P ( AB _i )  } { P ( A )  } = \frac { P ( AB _i )  } { P ( A ) \sum P ( B _j )  } = \frac { P ( A B _i )  } { \sum _{ j = 1  } ^n P ( A B _j )  } = \frac { P ( A | B _i ) P ( B _i )  } { \sum _{ j = 1  } ^n P ( A | B _j ) P ( B _j )  } \ $.</p>
<p>简化形式:$P ( B | A ) = \frac { P ( A | B ) P ( B )  } { P ( A )  } \ $.</p>
<p>另外,我们考虑设$O ( B ) = \cfrac { P ( B )  } { P ( \lnot B )  } $,称$\cfrac { P ( B | E )  } { P ( \lnot B | E )  } $为贝叶斯算子,则同理可得:</p>
<script type="math/tex; mode=display">
O ( B | E ) = O ( B ) \cfrac { P ( B | E )  } { P ( \lnot B | E )  }</script><p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3><p>如果$X $是定义在概率空间$\Omega $上的随机变量,那么它的概率生成函数为$G _X ( z ) = \sum _{ k \geq 0  } \Pr ( X = k ) z ^k = E ( z ^X ) $.</p>
<p>不难发现$G _X ( z ) $需要满足的条件:所有系数都非负并且$G _X ( 1 ) = 1 $.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = G _X ' ( 1 ) \\
E ( X ^2 ) & = G ' ' _X ( 1 ) + G _X ' ( 1 ) \\
VX & = G _X ' ' ( 1 ) + G _X ' ( 1 ) - ( G _X ' ( 1 ) ) ^2 
\end{aligned}</script><p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G ) & = G ' ( 1 ) \\
Var ( G ) & = G ' ' ( 1 ) + G ' ( 1 ) - ( G ' ( 1 ) ) ^2 
\end{aligned}</script><p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<script type="math/tex; mode=display">
G ( 1 + t ) = \sum _{ i \geq 0  } \cfrac { G ^{ ( i )  } ( 1 )  } { i !  } t ^i</script><p>另外,我们不难发现:$G _{ X + Y  } ( z ) = G _X ( z ) G _Y ( z ) $.</p>
<p>根据前面的推导,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _{ X + Y  } ) & = Mean ( G _X ) + Mean ( G _Y ) \\
Var ( G _{ X + Y  } ) & = Var ( G _X ) + Var ( G _Y ) 
\end{aligned}</script><p>换句话说,若$G _X ( 1 ) = 1 , G _Y ( 1 ) = 1 $,那么这个式子与直接对$G _{ X + Y  } $使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _X ) & = Mean ( G _{ X + Y  } ) - Mean ( G _Y ) \\
Var ( G _X ) & = Var ( G _{ X + Y  } ) - Var ( G _Y ) 
\end{aligned}</script><h4><span id="example1">Example1</span></h4><p>一枚硬币正面向上的概率为$p $,反面向上的概率为$q $,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设$N $为所有不包含THTTH的硬币序列的生成函数,$S $为所有只有结尾为THTTH的硬币序列的生成函数,令$H = pz , T = qz $,$1 $为空集,我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N \times ( H + T ) & = N + S \\
N \times THTTH & = S + S \times TTH 
\end{aligned}</script><p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设$A $是我们要找到的字符串,$m $是它的长度,令$A ^{ ( k )  } $表示$A $字符串的前$k $个字符所组成的字符串,$A _{ ( k )  } $表示$A $字符串的后$k $个字符所组成的字符串.这样的形式与$k $阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S \\
N \times A & = S ( \sum _{ k = 0  } ^{ m - 1  } A ^{ ( k )  } [ A ^{ ( m - k )  } & = A _{ ( m - k )  } ] ) 
\end{aligned}</script><p>如果我们设$\tilde { A  } $为将字符串$A $中的H替换成$\cfrac { 1  } { p  } z $,T替换成$\cfrac { 1  } { q  } z $之后的值,那么显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N \times A & = A \times S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
N & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
\cfrac { S - 1  } { H + T - 1  } & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) ) & = 1 
\end{aligned}</script><p>这显然是一个卷积的形式.</p>
<p>令$w = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.</p>
<p>令$H ( z ) = 1 $,$F ( z ) = ( 1 + ( 1 - z ) \times w ) $,$G ( z ) = S $.</p>
<p>那么我们显然可以直接求$G ( z ) $的期望和方差,事实上:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] \\
VX & = ( EX ) ^2 - \sum _{ k = 1  } ^m ( 2 k - 1 ) \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] 
\end{aligned}</script><p>如果硬币是均匀的($p = q = \cfrac { 1  } { 2  } $)我们引入另一个符号:我们设$A : A = \sum _{ k = 1  } ^m 2 ^{ k  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.那么显然期望需要的抛硬币次数就是$( A : A ) $.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4><p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设$S _A $为所有以HHT结尾的硬币序列的生成函数,设$S _B $为所有以HTT结尾的硬币序列的生成函数.$N $为其它的硬币序列的生成函数,令$H = T = 0 . 5 z $.</p>
<p>我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S _A + S _B \\
N \times HHT & = S _A \\
N \times HTT & = S _A \times T + S _B 
\end{aligned}</script><p>解方程并带入$z = 1 $,可以有得知以HHT结尾的概率为$\cfrac { 2  } { 3  } $.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为$A $和$B $,那么可以求出:</p>
<script type="math/tex; mode=display">
\cfrac { S _A  } { S _B  } = \cfrac { B : B - B : A  } { A : A - A : B  }</script><h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4><p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设$g _i $表示进行了$i $步还未结束的概率,$f _{ k , i  } $为进行了$i $步恰好第$k $个人胜利的概率,$F , G $是它们的生成函数,我们自然有:</p>
<ol>
<li><p>$1 + xG ( x ) = \sum _k F _k ( x ) + G ( x ) $.</p>
</li>
<li><p>$( \frac { 1  } { 2  } x ) ^L G ( x ) = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^i [ A _k ^{ ( L - i )  } = { A _j  } _{ ( L - i )  } ] $.</p>
</li>
</ol>
<p>第一个式子的用处在于带入$x = 1 $,发现$\sum _{ k  } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  } & = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{ L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } & = { A _j  } _{ ( i )  } ] 
\end{aligned}</script><p>带入$x = 1 $,有:</p>
<script type="math/tex; mode=display">
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [ A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]</script><p>不难发现对于不同的$k $,(2)的右边不同,而左边一定相同,这样就给出了$n $个等式,算上(1)一共有$n + 1 $个等式,可以算出$G ( 1 ) , F _{ 1 \cdots n  } ( 1 ) $这$n + 1 $个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3><p>现在有一个大小为$n + 1 $的概率空间,其中$\Pr ( \omega _k ) = \binom { n  } { k  } p ^k q ^{ n - k  } \ $,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令$H ( z ) = q + pz $,不难发现二项式分布的生成函数为$H ( z ) ^n $.</p>
<p>不难发现,满足二项式分布的随机变量的均值是$np $,方差是$npq $.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:$G ( z ) ^n = ( \cfrac { p  } { 1 - qz  } ) ^n = \sum _{ k  } \binom { n + k - 1  } { k  } p ^n q ^k z ^k $.</p>
<p>我们考虑如何求$G ( z ) $的方差和均值,不妨设$F ( z ) = \cfrac { 1 - qz  } { p  } = \cfrac { 1  } { p  } - \cfrac { q  } { p  } z $,则$G ( z ) ^n = F ( z ) ^{ - n  } $.</p>
<p>不难发现$F ( z ) $满足二项式分布.也就是说,以$( n , p , q ) $为参数的负二项式分布也就是以$( - n , - \cfrac { q  } { p  } , \cfrac { 1  } { p  } ) $为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3><h4><span id="树上随机游走">树上随机游走</span></h4><p>随机游走指每次从相邻的点中随机选一个走过去， 重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5><p>给一棵所有边长都为$1 $的$n $个点的树,问所有点对$( i , j ) ( 1 \leq i , j \leq n ) $中,从$i $走到$j $的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设$f _u $表示$u $随机走到它父亲的期望,$g _v $表示$v $的父亲(假设是$u $)走到$v $的期望.</p>
<p>对于$f _u $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { \sum _{ u \rightarrow v  } ( f _v + f _u )  } { \deg _u  } + 1 \\
f _u & = \deg _u + \sum _{ u \rightarrow v  } f _v 
\end{aligned}</script><p>对于$g _v $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _v & = \cfrac { g _u + g _v + \sum _{ u \rightarrow w , w \ne v  } ( g _v + f _w )  } { \deg _u  } + 1 \\
g _v & = g _u + \sum _{ u \rightarrow w , w \ne v  } f _w + \deg _u 
\end{aligned}</script><h5><span id="example2">Example2</span></h5><p>给出一棵$n $个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从$1 $号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案$+ 1 $.当走到度数为$1 $的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设$f _u $表示以$u $为起点的路径的期望长度,不难注意到$f _{ leaf  } = 1 $且$f _u = 1 + \cfrac { 1  } { \deg _u  } \sum _{ u \rightarrow v \lor v \rightarrow u  } f _v $.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得$f _u = k _u f _{ fa  } + b _u $,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出$g _v $表示从$v $的父亲(假设是$u $)走到$v $的概率,再令$f _u $表示从$u $走到父亲的概率,类似Example1,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { 1  } { \deg _u  } ( 1 + \sum _{ u \rightarrow v  } f _v f _u ) \\
g _v & = \cfrac { 1  } { \deg _u  } ( 1 + g _v g _u + \sum _{ u \rightarrow w , w \ne v  } f _w g _v ) 
\end{aligned}</script><p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4><h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5><p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为$\frac { 1  } { \binom { n  } { 2  }  } $.</p>
<p>把所有人权值从大到小排序,设$f _i $表示只考虑前$i $个人的时候的期望,不难发现:$f _{ i  } = \frac { 1  } { \binom { i  } { 2  }  } v _i + ( 1 - \frac { 1  } { \binom { i  } { 2  }  } ) f _{ i - 1  } $.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4><h5><span id="example1cf865c">Example1(CF865C)</span></h5><p>首先写出转移式子,但是存在后效性.如果我们设$f _{ i , j  } $表示过了$i $关,花费为$j $的期望,不难发现所有的$f $都需要与$f _{ 0 , 0  } $取$\min $,这咋办?</p>
<p>我们考虑二分这个$f _{ 0 , 0  } $,做的时候直接取$\min $,这样最后还会求出一个$f _{ 0 , 0  } $,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的$f _{ 0 , 0  } $越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取$\min $的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5><p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5><p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张$n \times m $的图(假设$n \geq m $),其中格点$( a , b ) $表示现在还剩$a $个Yes,$b $个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从$( n , m ) $走到$( 0 , 0 ) $的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线$y = x $翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从$( n , m ) $走到$( 0 , 0 ) $一定会经过$n $条有向边,所以期望贡献一定要加上一个$n $.而如果我走到了直线$y = x $上,那接下来的贡献是$\frac { 1  } { 2  } $.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2><h3><span id="树">树</span></h3><ol>
<li><p>随机树树高为$\sqrt { n  } $.</p>
</li>
<li><p>点的度数期望为$\log n $.</p>
</li>
</ol>
<h3><span id="数">数</span></h3><ol>
<li>数字的期望因数个数为$\log V $.</li>
</ol>
<h3><span id="序列">序列</span></h3><ol>
<li>随机序列的LIS长度期望为$O ( \sqrt { n  } ) $.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2><h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/4/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
