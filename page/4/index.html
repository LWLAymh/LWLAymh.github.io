<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/4/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">文化课数学导论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A2%AB%E6%96%87%E5%8C%96%E8%AF%BE%E5%88%9B%E9%A3%9E%E4%BA%86/" itemprop="url" rel="index"><span itemprop="name">被文化课创飞了</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2>
<h3><span id="习惯的更改">习惯的更改</span></h3>
<p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将<span class="math inline">\(C_{ n }^k\)</span>写作<span class="math inline">\(\binom{ n }{ k
}\)</span>,而文化课中不允许此类更改,再者文化课中将<span class="math inline">\(C_{ n }^k a^{ n - k }
b^k\)</span>称作二项式的第<span class="math inline">\(k +
1\)</span>项(从第<span class="math inline">\(1\)</span>项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3>
<p>首先我们有<span class="math inline">\(E ( aX + b ) = aE ( X ) + b , D
( aX + b ) = a^2 D ( X )\)</span>.</p>
<p>我们都知道期望满足线性可加,也就是<span class="math inline">\(E ( X_1
+ X_2 ) = E ( X_1 ) + E ( X_2
)\)</span>,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若<span class="math inline">\(X_1\)</span>和<span class="math inline">\(X_2\)</span>相互独立,<span class="math inline">\(E
( X_1 X_2 ) = E ( X_1 ) E ( X_2
)\)</span>,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要<span class="math inline">\(X_1\)</span>和<span class="math inline">\(X_2\)</span>相互独立,<span class="math inline">\(D
( X_1 + X_2 ) = D ( X_1 ) + D ( X_2
)\)</span>.从形式上证明是好证明的,我们考虑:</p>
<p><span class="math display">\[
\begin{aligned}
D ( X_1 + X_2 ) &amp; = E ( ( X_1 + X_2 )^2 ) - E^2 ( X_1 + X_2 ) \\
&amp; = E ( X_1^2 ) + E ( 2 X_1 X_2 ) + E ( X_2^2 ) - E^2 ( X_1 + X_2 )
\\
&amp; = E ( X_1^2 ) + 2 E ( X_1 ) E ( X_2 ) + E ( X_2^2 ) - ( E ( X_1 )
+ E ( X_2 ) )^2 \\
&amp; = E ( X_1^2 ) - E^2 ( X_1 ) + E ( X_2^2 ) - E^2 ( X_2 ) \\
&amp; = D ( X_1 ) + D ( X_2 )
\end{aligned}
\]</span></p>
<p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为<span class="math inline">\(0\)</span>,不然<span class="math inline">\(D ( X_1
+ X_2 )\)</span>要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为<span class="math inline">\(0\)</span>,并且缩放权值,使得方差恰好为<span class="math inline">\(1\)</span>.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为<span class="math inline">\(0\)</span>的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3>
<h4><span id="两点分布">两点分布</span></h4>
<p>直接写的话也就是<span class="math inline">\(P ( X ) = \begin{cases}p
&amp; X = 1 \\ 1 - p &amp; X = 0 \\ 0 &amp;
other\end{cases}\)</span>,事实上这么写可能不太严谨,因为两点分布的<span class="math inline">\(X = 1\)</span>和<span class="math inline">\(X =
0\)</span>两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是<span class="math inline">\(G ( x ) = ( 1 - p
) + px\)</span>.由此式子轻松推得<span class="math inline">\(E ( x ) = G
&#39; ( 1 ) = p , D ( x ) = E ( x^2 ) - E^2 ( x ) = G &#39; &#39; ( 1 )
+ G &#39; ( 1 ) - ( G &#39; ( 1 ) )^2 = p - p^2 = p ( 1 - p
)\)</span>.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4>
<p>所谓<span class="math inline">\(n\)</span>重伯努利试验,也就是<span class="math inline">\(n\)</span>次两点分布的累计,满足<span class="math inline">\(P ( X = k ) = C_{ n }^k ( 1 - p )^{ n - k }
p^k\)</span>,我们关注两个事情,也就是二项式分布的<span class="math inline">\(E ( X ) = np , D ( X ) = np ( 1 - p
)\)</span>,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4>
<p>所谓不放回取球,考虑目前有<span class="math inline">\(N\)</span>个数字,有<span class="math inline">\(M\)</span>个是<span class="math inline">\(1\)</span>,剩下<span class="math inline">\(N -
M\)</span>个是<span class="math inline">\(0\)</span>,取出<span class="math inline">\(n\)</span>次,取出了<span class="math inline">\(m\)</span>个<span class="math inline">\(1\)</span>的概率.简单组合一下得到此概率为<span class="math inline">\(\frac{ C_{ M }^m C_{ N - M }^{ n - m } }{ C_{ N
}^n } \\\)</span>,注意这里必须保证<span class="math inline">\(n \leq
N\)</span>.</p>
<p>由范德蒙德卷积得知,<span class="math inline">\(\sum_{ m } C_{ M }^m
C_{ N - M }^{ n - m } = C_{ N
}^n\)</span>,因此该分布列所有情况之和为<span class="math inline">\(1\)</span>.</p>
<p>考虑其均值,从感性上讲必定是<span class="math inline">\(\frac{ nM }{ N
}\)</span>.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如<span class="math inline">\(01101\)</span>之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到<span class="math inline">\(1\)</span>的概率,和第二次取得到<span class="math inline">\(1\)</span>的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是<span class="math inline">\(n \frac{ N ( N - M ) ( N - n ) }{
N^2 ( N - 1 ) }\)</span>,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4>
<p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写<span class="math inline">\(f ( x ) = \frac{ e^{ - \frac{ ( x - \mu )^2 }{ 2
\sigma^2 } } }{ \sigma \sqrt{ 2 \pi } }
\\\)</span>,是不是看着非常震撼!其中的方差是<span class="math inline">\(\sigma^2\)</span>,期望是<span class="math inline">\(\mu\)</span>.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足<span class="math inline">\(\sigma = 1 , \mu
= 0\)</span>,此时的函数也就是<span class="math inline">\(f ( x ) =
\frac{ e^{ - \frac{ x^2 }{ 2 } } }{ \sqrt{ 2 \pi }
}\)</span>.一个好奇是,你凭啥说所有情况下的概率之和为<span class="math inline">\(1\)</span>,事实上这其实是因为<span class="math inline">\(g ( x ) = e^{ - x^2 }\)</span>的积分是<span class="math inline">\(\sqrt{ \pi }\)</span>,不会求这个积分.</p>
<p>观察<span class="math inline">\(g ( x ) = e^{ - x^2
}\)</span>这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数<span class="math inline">\(e^{ - | x |
}\)</span>模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是<span class="math inline">\(\sigma\)</span>的由来,将<span class="math inline">\(x \rightarrow \sigma x\)</span>,也就是在<span class="math inline">\(x\)</span>那里除去一个<span class="math inline">\(\sigma\)</span>.而对这个曲线进行横向移动,也就是将<span class="math inline">\(x \rightarrow x - \mu\)</span>.</p>
<p>这也就引出所谓的<span class="math inline">\(3
\sigma\)</span>原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3>
<h4><span id="样本相关系数">样本相关系数</span></h4>
<p>对于若干数据<span class="math inline">\(( x_i , y_i
)\)</span>,我们先进行标准化,也就是减去均值后再除以方差,这样做使得<span class="math inline">\(x , y\)</span>分别的均值为<span class="math inline">\(0\)</span>,方差为<span class="math inline">\(1\)</span>.下面默认已经标准化过了.</p>
<p>不妨构造<span class="math inline">\(n\)</span>维向量<span class="math inline">\(\vec{ x } = ( x_1 , x_2 , \cdots , x_n ) , \vec{ y
} = ( y_1 , y_2 , \cdots , y_n )\)</span>,考虑它们的点乘<span class="math inline">\(\vec{ x } \cdot \vec{ y
}\)</span>,不难发现由于方差为<span class="math inline">\(1\)</span>,因此<span class="math inline">\(| \vec{
x } | = | \vec{ y } | = \sqrt{ n }\)</span>,因此它们的点乘为<span class="math inline">\(n \cos \theta\)</span>,设<span class="math inline">\(r = \frac{ \vec{ x } \cdot \vec{ y } }{ n } = \cos
\theta\)</span>.</p>
<p>如果<span class="math inline">\(\exists k\)</span>,<span class="math inline">\(\forall i , y_i = kx_i\)</span>,此时必有<span class="math inline">\(| r | =
1\)</span>,因此我们断言(为啥呢?其实是不太理解的啊)当<span class="math inline">\(| r |\)</span>越靠近<span class="math inline">\(1\)</span>的时候,<span class="math inline">\(x ,
y\)</span>之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4>
<p>我们在上面的角度审视中提出了一个观点:在满足均值为<span class="math inline">\(0\)</span>的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:<span class="math inline">\(Y = bx + a + e , E ( e ) = 0 , D ( e ) =
\sigma^2\)</span>.</p>
<p>现在我们要做的就是,已知若干组数据<span class="math inline">\(( x_i ,
y_i )\)</span>,去构造一组<span class="math inline">\(a ,
b\)</span>满足上面的条件.不妨令<span class="math inline">\(e_i = y_i - (
bx_i + a )\)</span>,若<span class="math inline">\(\sum e_i =
0\)</span>,必有<span class="math inline">\(a = \bar{ y } - b \bar{ x
}\)</span>,带入解得当<span class="math inline">\(\sigma\)</span>最小的时候,<span class="math inline">\(b = \frac{ \sum_{ i } ( x_i - \bar{ x } ) ( y_i -
\bar{ y } ) }{ \sum_{ i } ( x_i - \bar{ x } )^2 } \\\)</span>.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个<span class="math inline">\(b\)</span>使得<span class="math inline">\(\sigma\)</span>最小,标准化说到底只是为了保证<span class="math inline">\(\sigma =
1\)</span>的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4>
<p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知<span class="math inline">\(P ( AB ) = P ( A ) P ( B
)\)</span>,那么我们反推,如果我们在现实中的估计中,发现<span class="math inline">\(P ( AB )\)</span>和<span class="math inline">\(P (
A ) P ( B )\)</span>差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:<span class="math inline">\(P ( 00 ) =
\frac{ a }{ n } , P ( 01 ) = \frac{ b }{ n } , P ( 10 ) = \frac{ c }{ n
} , P ( 11 ) = \frac{ d }{ n }\)</span>.那么<span class="math inline">\(P ( A = 0 ) P ( B = 0 ) = \frac{ ( a + b ) ( a + c
) }{ n^2 }\)</span>.我们计算它与<span class="math inline">\(P ( 00
)\)</span>的差,平方后除以<span class="math inline">\(P ( A = 0 ) P ( B =
0 )\)</span>然后做四遍求和化简,得到<span class="math inline">\(\chi^2 =
\frac{ n ( ad - bc )^2 }{ ( a + b ) ( a + c ) ( c + d ) ( b + d )
}\)</span>.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么<span class="math inline">\(P ( \chi^2 \geq x_\alpha ) =
\alpha\)</span>.或者给出我们经验上的准则:</p>
<p>选取一个较小的<span class="math inline">\(\alpha\)</span>,并得知其对应的<span class="math inline">\(x_\alpha\)</span>,如果<span class="math inline">\(\chi^2 \geq
x_\alpha\)</span>,推断独立性不成立,犯错的概率是<span class="math inline">\(\alpha\)</span>.反之断言其独立性成立,犯错的概率不可知,肯定<span class="math inline">\(\alpha\)</span>越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2>
<h3><span id="常用对数表">常用对数表</span></h3>
<ol type="1">
<li><p><span class="math inline">\(\ln 2 = 0 . 693\)</span>.</p></li>
<li><p><span class="math inline">\(\ln 3 = 1 . 099\)</span>.</p></li>
<li><p><span class="math inline">\(\ln 5 = 1 . 609\)</span>.</p></li>
<li><p><span class="math inline">\(\ln 0 . 1 = - 2 .
303\)</span>.</p></li>
<li><p><span class="math inline">\(\ln 0 . 5 = - 0 .
693\)</span>.</p></li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3>
<ol type="1">
<li><p><span class="math inline">\(e = 2 . 718\)</span>.</p></li>
<li><p><span class="math inline">\(e^2 = 7 . 389\)</span>.</p></li>
<li><p><span class="math inline">\(e^3 = 20 . 086\)</span>.</p></li>
<li><p><span class="math inline">\(e^5 = 148 . 413\)</span>.</p></li>
<li><p><span class="math inline">\(e^{ 0 . 1 } = 1 .
105\)</span>.</p></li>
<li><p><span class="math inline">\(e^{ 0 . 5 } = 1 .
649\)</span>.</p></li>
<li><p><span class="math inline">\(e^\pi = 23 . 147\)</span>.</p></li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3>
<h4><span id="fxxex"><span class="math inline">\(f(x)=xe^x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f &#39; ( x ) = ( x + 1 )
e^x\)</span>,<span class="math inline">\(x = -
1\)</span>的时候,取最小值<span class="math inline">\(- \frac{ 1 }{ e
}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{ x \rightarrow - \infty } f ( x
) = 0 \\\)</span>.</p>
<hr>
<h4><span id="fxxln-x"><span class="math inline">\(f(x)=x\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f &#39; ( x ) = 1 + \ln x , x = \frac{ 1
}{ e }\)</span>的时候,有最小值<span class="math inline">\(- \frac{ 1 }{
e }\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{ x \rightarrow 0^{ + } } f ( x
) = 0 \\\)</span>.</p>
<hr>
<h4><span id="fxfracexx"><span class="math inline">\(f(x)=\frac{e^x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e%5Exdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f &#39; ( x ) = \frac{ e^x ( x - 1 ) }{
x^2 } , x = 1\)</span>的时候,有极小值<span class="math inline">\(e\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{ x \rightarrow - \infty } f ( x
) = 0 \\\)</span>.</p>
<hr>
<h4><span id="fxfraclnxx"><span class="math inline">\(f(x)=\frac{\ln
x}{x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f &#39; ( x ) = \frac{ 1 - \ln x }{ x^2 }
, x = e\)</span>的时候,有极大值<span class="math inline">\(\frac{ 1 }{ e
}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{ x \rightarrow + \infty } f ( x
) = 0 \\\)</span>.</p>
<hr>
<h4><span id="fxx-ln-x"><span class="math inline">\(f(x)=x-\ln x\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f &#39; ( x ) = 1 - \frac{ 1 }{ x } , x =
1\)</span>的时候,有最小值<span class="math inline">\(1\)</span>.</p>
<hr>
<h4><span id="fxfracxex"><span class="math inline">\(f(x)=\frac{x}{e^x}\)</span></span></h4>
<h5><span id="图像">图像</span></h5>
<p><img src="F:\Studying%20Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive%5Ex.png"></p>
<h5><span id="极值与极限">极值与极限</span></h5>
<p><span class="math inline">\(f &#39; ( x ) = \frac{ 1 - x }{ e^x } , x
= 1\)</span>的时候,有最大值<span class="math inline">\(\frac{ 1 }{ e
}\)</span>.</p>
<p>另外<span class="math inline">\(\lim_{ x \rightarrow + \infty } f ( x
) = 0 \\\)</span>.</p>
<h3><span id="预处理函数">预处理函数</span></h3>
<h4><span id="分离对数">分离对数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令<span class="math inline">\(f ( x ) = ( 2 + x + ax^2 ) \ln ( x + 1
) - 2 x\)</span>,已知<span class="math inline">\(x =
0\)</span>是极大值点,求<span class="math inline">\(a\)</span>.</p>
<p>考虑分离对数后操作多项式,我们显然可找到<span class="math inline">\(0
&lt; t &lt; 1 , 2 + t + at^2 &gt; 0 , 2 - t + at^2 &gt;
0\)</span>,下面只考虑<span class="math inline">\(x \in [ - t , t
]\)</span>.此时<span class="math inline">\(f ( x ) = ( 2 + x + ax^2 ) (
\ln ( x + 1 ) - \frac{ 2 x }{ 2 + x + ax^2 } )\)</span>.</p>
<p>考虑令<span class="math inline">\(g ( x ) = \ln ( x + 1 ) - \frac{ 2
x }{ 2 + x + ax^2 }\)</span>,由于<span class="math inline">\(f ( 0 ) =
0\)</span>,只需证明<span class="math inline">\(g ( x ) \leq 0 , x \in [
- t , t ]\)</span>即可.</p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
g &#39; ( x ) &amp; = \frac{ 1 }{ x + 1 } - \frac{ 4 - 2 ax^2 }{ ( 2 + x
+ ax^2 )^2 } \\
&amp; = \frac{ x^2 ( a^2 x^2 + 4 ax + 6 a + 1 ) }{ ( x + 1 ) ( 2 + x +
ax^2 ) } \\
\text{ sign } ( g &#39; ( x ) ) &amp; = \text{ sign } ( a^2 x^2 + 4 ax +
6 a + 1 )
\end{aligned}
\]</span></p>
<p>则<span class="math inline">\(a^2 0^2 + 4 a 0 + 6 a + 1 =
0\)</span>,<span class="math inline">\(a = - \frac{ 1 }{ 6
}\)</span>.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4>
<h5><span id="example">Example</span></h5>
<p>令<span class="math inline">\(f ( x ) = e^x - \ln ( x + 1 ) + ax^3 -
x^2 - 1\)</span>,若<span class="math inline">\(\forall x \in ( - 1 , 1 )
, f ( x ) \geq 0\)</span>,求<span class="math inline">\(a\)</span>.</p>
<p><span class="math inline">\(f ( 0 ) =
0\)</span>,于是上面的条件等价于<span class="math inline">\(0\)</span>是<span class="math inline">\(( - 1 , 1
)\)</span>的最小值点.</p>
<p>考虑<span class="math inline">\(f &#39; ( x ) = e^x - \frac{ 1 }{ x +
1 } + 3 ax^2 - 2 x\)</span>,则<span class="math inline">\(f &#39; ( 0 )
= 0\)</span>恒成立.</p>
<p>讨论<span class="math inline">\(g ( x ) = 1 + e^{ - x } ( 3 ax^2 - 2
x - \frac{ 1 }{ x + 1 } )\)</span>的正负,看<span class="math inline">\(g
&#39; ( x ) = \frac{ x ( - 3 ax^3 + 2 x^2 + ( 9 a + 2 ) x + 6 a - 1 ) }{
( x + 1 )^2 e^x }\)</span>.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3>
<h4><span id="变化条件">变化条件</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(x + 2 y = 1\)</span>,求<span class="math inline">\(x^2 + y^2\)</span>的最小值.</p>
<p>直接令<span class="math inline">\(x = 1 - 2 y\)</span>,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(x^2 + y^3 = 2\)</span>,求<span class="math inline">\(x + y\)</span>的最小值.</p>
<p>这个的话不妨设其最小值为<span class="math inline">\(C\)</span>,有<span class="math inline">\(x + y
\geq C\)</span>,移项得到<span class="math inline">\(y \geq C -
x\)</span>,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3>
<h4><span id="普通参数方程">普通参数方程</span></h4>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(x^2 + y^2 - xy = 1\)</span>,求<span class="math inline">\(x + y\)</span>的最小值.</p>
<p>这个的话大概是这样,我们找到一个<span class="math inline">\(t\)</span>,使得<span class="math inline">\(x = f (
t ) , y = g ( t )\)</span>,然后换元.</p>
<p>比如这个题,你就可以凑成<span class="math inline">\(( x - \frac{ y }{
2 } )^2 + ( \frac{ \sqrt{ 3 } }{ 2 } y )^2 =
1\)</span>,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4>
<h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5>
<p>求证<span class="math inline">\(\sqrt{ ab } &lt; \frac{ a - b }{ \ln
a - \ln b } &lt; \frac{ a + b }{ 2 }\)</span>.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ a - b }{ \ln a - \ln b } &amp; &lt; \frac{ a + b }{ 2 } \\
\frac{ a - b }{ a + b } &amp; &lt; \frac{ \ln \frac{ a }{ b } }{ 2 } \\
\frac{ \frac{ a }{ b } - 1 }{ \frac{ a }{ b } + 1 } &amp; &lt; \frac{
\ln \frac{ a }{ b } }{ 2 }
\end{aligned}
\]</span></p>
<p>换元,令<span class="math inline">\(t = \frac{ a }{ b
}\)</span>,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知函数<span class="math inline">\(f ( x ) = 3 \ln x -
ax\)</span>,若<span class="math inline">\(x_1 &lt; x_2\)</span>是<span class="math inline">\(f ( x )\)</span>的两个零点,求证<span class="math inline">\(f &#39; ( \frac{ x_1 + 3 x_2 }{ 4 } ) &lt;
0\)</span>.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<p><span class="math display">\[
\begin{cases}
3 \ln x_1 = ax_1 \\
3 \ln x_2 = ax_2
\end{cases}
\]</span></p>
<p>我们想要知道的是:<span class="math inline">\(\frac{ 12 }{ x_1 + 3 x_2
} &lt; a\)</span>.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把<span class="math inline">\(a\)</span>给换掉,事实上我们根据前面的方程有<span class="math inline">\(a = \frac{ 3 \ln \frac{ x_2 }{ x_1 } }{ x_2 - x_1
}\)</span>.</p>
<p>于是我们只需要证明:<span class="math inline">\(\frac{ x_1 + 3 x_2 }{
4 } &gt; \frac{ x_2 - x_1 }{ \ln \frac{ x_2 }{ x_1 }
}\)</span>,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5>
<p>已知函数<span class="math inline">\(f ( x ) = \ln x -
ax\)</span>,其有两个零点<span class="math inline">\(x_1 \ne
x_2\)</span>,求证<span class="math inline">\(x_1 x_2 &gt;
e^2\)</span>.</p>
<p>同样分析已知,我们得到的是:</p>
<p><span class="math display">\[
\begin{cases}
\ln x_1 = ax_1 \\
\ln x_2 = ax_2
\end{cases}
\]</span></p>
<p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<p><span class="math display">\[
\begin{cases}
\ln x_2 - \ln x_1 = a ( x_2 - x_1 ) \\
\ln x_2 + \ln x_1 = a ( x_2 + x_1 )
\end{cases}
\]</span></p>
<p>这里先把所求变形一下,我们把它改成<span class="math inline">\(\ln x_1
+ \ln x_2 &gt; 2\)</span>.</p>
<p>发现了什么?这个东西等价于<span class="math inline">\(a ( x_2 + x_1 )
&gt; 2\)</span>,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换<span class="math inline">\(a\)</span>即可.</p>
<h5><span id="example4">Example4</span></h5>
<p>已知<span class="math inline">\(f ( x ) = x^2 + axe^x - ae^{ 2 x
}\)</span>有三个不同的零点<span class="math inline">\(x_1 &lt; x_2 &lt;
x_3\)</span>,求<span class="math inline">\(a\)</span>的范围,并求证<span class="math inline">\(( 1 - \frac{ x_1 }{ e^{ x_1 } } )^2 ( 1 - \frac{
x_2 }{ e^{ x_2 } } ) ( 1 - \frac{ x_3 }{ e^{ x_3 } } ) = 1\)</span>.</p>
<p>考虑两边同时除以<span class="math inline">\(e^{ 2 x
}\)</span>,这样得到<span class="math inline">\(g ( x ) = ( \frac{ x }{
e^x } )^2 + a \frac{ x }{ e^x } - a\)</span>,令<span class="math inline">\(t = \frac{ x }{ e^x }\)</span>得到<span class="math inline">\(g ( t ) = t^2 + at - a = 0\)</span>.</p>
<p>考察<span class="math inline">\(g ( t ) = 0\)</span>的两根<span class="math inline">\(t_1 &lt;
t_2\)</span>,根据韦达定理,首先需要满足<span class="math inline">\(\Delta
= a^2 + 4 a &gt; 0 \Rightarrow a &gt; 0\)</span>,然后<span class="math inline">\(t_1 + t_2 = - a , t_1 t_2 = - a\)</span>.</p>
<p>接下来考察函数<span class="math inline">\(\frac{ x }{ e^x
}\)</span>,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为<span class="math inline">\(t_1 , t_2\)</span>中必有一负,因此<span class="math inline">\(t_2 \in ( 0 , \frac{ 1 }{ e }
)\)</span>.由此立得<span class="math inline">\(0 &lt; a &lt; \frac{ 1 }{
e ( e - 1 ) }\)</span>.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>若<span class="math inline">\(x &gt; 0\)</span>时,<span class="math inline">\(ax ( e^{ ax } + 1 ) \geq 2 ( x^2 + 1 ) \ln
x\)</span>恒成立,求<span class="math inline">\(a\)</span>取值范围.</p>
<p>一般这种题先判<span class="math inline">\(a\)</span>的正负,注意到<span class="math inline">\(x &gt; 1\)</span>的时候右边恒大于<span class="math inline">\(0\)</span>,因此<span class="math inline">\(a &gt;
0\)</span>.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数<span class="math inline">\(2\)</span>放进<span class="math inline">\(\ln\)</span>,自然有:<span class="math inline">\(ax
( e^{ ax } + 1 ) \geq ( x^2 + 1 ) \ln x^2\)</span>.</p>
<p>考虑令<span class="math inline">\(t_1 = ax , t_2 = \ln
x^2\)</span>,则:</p>
<p><span class="math display">\[
t_1 ( e^{ t_1 } + 1 ) \geq t_2 ( e^{ t_2 } + 1 )
\]</span></p>
<p>接下来分析函数<span class="math inline">\(f ( x ) = x ( e^x + 1
)\)</span>的单调性,就可以得到<span class="math inline">\(a \geq \frac{ 2
}{ e }\)</span>.</p>
<h3><span id="不等式相关">不等式相关</span></h3>
<h4><span id="基本不等式相关">基本不等式相关</span></h4>
<h5><span id="方程角度的审视">方程角度的审视</span></h5>
<p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造<span class="math inline">\(\frac{ m }{ n } = k\)</span>.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5>
<p>已知<span class="math inline">\(n , m &gt; 0 , 2 m + n =
nm\)</span>,求<span class="math inline">\(n + m + \sqrt{ n^2 + m^2
}\)</span>的最小值.</p>
<p>这个题有一个方式是观察到<span class="math inline">\(n , m , \sqrt{
n^2 + m^2
}\)</span>是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
$$
<span class="math display">\[\begin{aligned}
n + m + \sqrt{ n^2 + m^2 } &amp; \geq k \\
\Leftarrow \sqrt{ n^2 + m^2 } &amp; \geq k - n - m \\

\end{aligned}\]</span>
<p>$$</p>
<p>如果<span class="math inline">\(n + m \geq
k\)</span>,那么不等式显然成立,下面只需要证明<span class="math inline">\(n + m &lt; k\)</span>的情况:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt{ n^2 + m^2 } &amp; \geq k - n - m \\
\Leftarrow n^2 + m^2 &amp; \geq ( k - ( n + m ) )^2 \\
\Leftarrow k^2 + ( n + m )^2 - 2 k ( n + m ) &amp; \leq n^2 + m^2 \\
\Leftarrow k^2 + 2 nm - 2 k ( n + m ) &amp; \leq 0 \\
\Leftarrow k^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) &amp; \leq 0 \\
\Leftarrow k^2 &amp; \leq n ( 2 k - 2 ) + m ( 2 k - 4 )
\end{aligned}
\]</span></p>
<p>变形方程得到<span class="math inline">\(\frac{ 2 }{ n } + \frac{ 1 }{
m } = 1\)</span>,使用这个式子来降次:</p>
$$
<span class="math display">\[\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) &amp; = 6 k - 8 + \frac{ n }{ m } ( 2 k -
2 ) + \frac{ m }{ n } ( 4 k - 8 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>要严谨一点的话我们需要证明<span class="math inline">\(4 k - 8 \geq
0\)</span>,<span class="math inline">\(k \geq
2\)</span>.这非常简单,因为<span class="math inline">\(k \geq n + m &gt;
3\)</span>.</p>
<p>这就足够了么?不需要证明存在一个<span class="math inline">\(w = \frac{
n }{ m }\)</span>使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<p><span class="math display">\[
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt{ 8 ( k - 1 ) ( k -
2 ) }
\]</span></p>
<p>这个等号可以取到,也就是说,只要满足:</p>
<p><span class="math display">\[
k^2 \leq 6 k - 8 + 2 \sqrt{ 8 ( k - 1 ) ( k - 2 ) }
\]</span></p>
<p>那么这个<span class="math inline">\(k\)</span>就是一个下界,特别地,如果满足:</p>
<p><span class="math display">\[
k^2 = 6 k - 8 + 2 \sqrt{ 8 ( k - 1 ) ( k - 2 ) }
\]</span></p>
<p>那么这个<span class="math inline">\(k\)</span>就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到<span class="math inline">\(k
= 10\)</span>是一个解了),接下来我们必须求出一个<span class="math inline">\(k\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
k^2 &amp; = 6 k - 8 + 2 \sqrt{ 8 ( k - 1 ) ( k - 2 ) } \\
k^2 - 6 k + 8 &amp; = 2 \sqrt{ 8 ( k - 1 ) ( k - 2 ) } \\
( k - 4 ) ( k - 2 ) &amp; = 2 \sqrt{ 8 ( k - 1 ) ( k - 2 ) } \\
\sqrt{ k - 2 } &amp; = \frac{ 2 \sqrt{ 8 ( k - 1 ) } }{ k - 4 }
\end{aligned}
\]</span></p>
<p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个<span class="math inline">\(\sqrt{ k - 2 }\)</span>带入到上面去!</p>
$$
<span class="math display">\[\begin{aligned}
( k - 4 ) ( k - 2 ) &amp; = 2 \sqrt{ 8 ( k - 1 ) } \frac{ 2 \sqrt{ 8 ( k
- 1 ) } }{ k - 4 } \\
( k - 4 ) ( k - 2 ) &amp; = \frac{ 32 ( k - 1 ) }{ k - 4 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说<span class="math inline">\(k = 0\)</span>是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出<span class="math inline">\(k
= 10\)</span>.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4>
<h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5>
$$
<span class="math display">\[\begin{aligned}
f ( x ) &amp; = \sum_{ k \geq 0 } \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } (
x - x_0 )^k \\
f ( x ) &amp; = \sum_{ k \geq 0 } \frac{ f^{ ( k ) } ( 0 ) }{ k ! } x^k
\\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5>
<ol type="1">
<li><p><span class="math inline">\(\frac{ 1 }{ 1 - x } = \sum_{ k \geq 0
} x^k = 1 + x + x^2 + \cdots \\\)</span>.</p></li>
<li><p><span class="math inline">\(e^x = \sum_{ k \geq 0 } \frac{ x^k }{
k ! } = 1 + x + \frac{ 1 }{ 2 ! } x^2 + \cdots \\\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 + x ) = \sum_{ k \geq 1 } ( -
1 )^{ k - 1 } \frac{ x^k }{ k } = x - \frac{ 1 }{ 2 } x^2 + \frac{ 1 }{
3 } x^3 + \cdots \\\)</span>.</p></li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>已知函数<span class="math inline">\(f ( x ) = \ln x -
ax\)</span>,其有两个零点<span class="math inline">\(x_1 \ne
x_2\)</span>,求证<span class="math inline">\(x_1 x_2 &gt;
e^2\)</span>.</p>
<p>极值点偏移的形式,应该是形如<span class="math inline">\(g ( x ) =
a\)</span>有两个解<span class="math inline">\(x_1 ,
x_2\)</span>,然后使得<span class="math inline">\(x_1 +
x_2\)</span>满足一定条件.因此我们先变形条件:</p>
<p><span class="math display">\[
\begin{cases}
\frac{ \ln x_1 }{ x_1 } = a \\
\frac{ \ln x_2 }{ x_2 } = a
\end{cases}
\]</span></p>
<p>也就是目前我们构造出了函数<span class="math inline">\(g ( x ) =
\frac{ \ln x }{ x }\)</span>,观察<span class="math inline">\(g ( x
)\)</span>图像立得<span class="math inline">\(x_1 + x_2 &gt; 2
e\)</span>.</p>
<p>我们发现,<span class="math inline">\(x_1 x_2 \leq \frac{ ( x_1 + x_2
)^2 }{ 4
}\)</span>,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为<span class="math inline">\(\ln x_1 + \ln x_2 &lt; 2\)</span>,然后令<span class="math inline">\(t_1 = \ln x_1 , t_2 = \ln
x_2\)</span>,带入立有:</p>
<p><span class="math display">\[
\begin{cases}
\frac{ t_1 }{ e^{ t_1 } } = a \\
\frac{ t_2 }{ e^{ t_2 } } = a
\end{cases}
\]</span></p>
<p>而<span class="math inline">\(g ( x ) = \frac{ x }{ e^x
}\)</span>恰好也是满足<span class="math inline">\(x_1 + x_2 &gt;
2\)</span>的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5>
<p><span class="math inline">\(f ( x ) = x ( 1 - \ln x )\)</span>,<span class="math inline">\(b \ln a - a \ln b = a - b\)</span>,求证<span class="math inline">\(2 &lt; \frac{ 1 }{ a } + \frac{ 1 }{ b } &lt;
e\)</span>.</p>
<p>首先变形条件得到<span class="math inline">\(b ( 1 + \ln a ) = a ( 1 +
\ln b )\)</span>,得到<span class="math inline">\(f ( \frac{ 1 }{ a } ) =
f ( \frac{ 1 }{ b } )\)</span>,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p><span class="math inline">\(f &#39; ( x ) = - \ln
x\)</span>,其在<span class="math inline">\(( 0 , 1 ) \uparrow , ( 1 , +
\infty ) \downarrow\)</span>,考察极值点偏移,我们想要证明<span class="math inline">\(\frac{ 1 }{ b } &lt; e - \frac{ 1 }{ a
}\)</span>,我们就想办法把<span class="math inline">\(\frac{ 1 }{ b
}\)</span>和<span class="math inline">\(e - \frac{ 1 }{ a
}\)</span>扔到同一个区间里,而它们确实同在<span class="math inline">\(( 1
, + \infty )\)</span>这个区间内.</p>
<p>比较有启发性的是,你发现<span class="math inline">\(\frac{ 1 }{ b } ,
e - \frac{ 1 }{ a }\)</span>和<span class="math inline">\(\frac{ 1 }{ a
} , e - \frac{ 1 }{ b }\)</span>这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ b } &amp; &lt; e - \frac{ 1 }{ a } \\
f ( \frac{ 1 }{ a } ) &amp; = f ( \frac{ 1 }{ b } ) &gt; f ( e - \frac{
1 }{ a } )
\end{aligned}
\]</span></p>
<p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5>
<p><span class="math inline">\(f ( x ) = e^{ x - 1 } -
ax\)</span>在<span class="math inline">\(( 0 , 2
)\)</span>有两个零点<span class="math inline">\(x_1 ,
x_2\)</span>,求证<span class="math inline">\(x_1 x_2 &gt; \frac{ 1 }{ a
}\)</span>.</p>
<p>首先要证明<span class="math inline">\(a\)</span>的范围啊,我们不加证明地给出:<span class="math inline">\(a \in ( 1 , \frac{ e }{ 2 } )\)</span>,并且<span class="math inline">\(( - \infty , 1 + \ln a ) \downarrow , ( 1 + \ln a
, + \infty ) \uparrow\)</span>.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<p><span class="math display">\[
\begin{cases}
ax_1 = e^{ x_1 - 1 } \\
ax_2 = e^{ x_2 - 1 }
\end{cases}
\]</span></p>
<p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取<span class="math inline">\(\ln\)</span>,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取<span class="math inline">\(\ln\)</span>,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到<span class="math inline">\(x_1 x_2\)</span>和<span class="math inline">\(x_1
+
x_2\)</span>之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如<span class="math inline">\(0 &lt; f ( 2 + \ln a - x_2 )\)</span>,也就是<span class="math inline">\(0 &lt; ae^{ 1 - x_2 } - a ( 2 + \ln a - x_2
)\)</span>.</p>
<p>但是这样有一个问题,我们把<span class="math inline">\(f\)</span>带进去,你会发现最后我们的式子同时带有<span class="math inline">\(a , x_2\)</span>,这个就难做了,咋办呢?考虑拿<span class="math inline">\(ax_2 = e^{ x_2 - 1 }\)</span>操作一下把<span class="math inline">\(a\)</span>消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4>
<h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5>
<ol type="1">
<li><p><span class="math inline">\(e^x \geq x + 1\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ x - 1 }{ x } \leq \ln x \leq x
- 1\)</span>.</p></li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol start="3" type="1">
<li><span class="math inline">\(\ln ( n + 1 ) &lt; \sum_{ k = 1 }^n
\frac{ 1 }{ k }\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(\ln ( \frac{ n + 1 }{ n } ) &lt;
\frac{ 1 }{ n }\)</span>,左右两边分别求和得到上面的式子.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\ln n &gt; \sum_{ k = 2 }^n \frac{ 1 }{
k } , n &gt; 1\)</span>.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明<span class="math inline">\(\ln \frac{ 1 }{ n } &lt; - \sum_{ k = 2 }^n \frac{
1 }{ k }\)</span>.</p>
<p>考虑<span class="math inline">\(\ln ( \frac{ n - 1 }{ n } ) \leq -
\frac{ 1 }{ n }\)</span>,两边求和得到上式.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\sum_{ k = 1 }^n ( \frac{ k }{ n } )^n
&lt; \frac{ e }{ e - 1 }\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(n \ln ( \frac{ k }{ n } ) \leq k -
n\)</span>,也就有<span class="math inline">\(( \frac{ k }{ n } )^n \leq
e^{ k - n }\)</span>,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f ( x ) = x \ln x\)</span>,若<span class="math inline">\(f ( x ) = b\)</span>有两个实数根<span class="math inline">\(x_1 , x_2 ( x_1 &lt; x_2 )\)</span>,求证:<span class="math inline">\(be + 1 &lt; x_2 - x_1 &lt; \frac{ e^{ - 3 } + 2 +
3 b }{ 2 }\)</span>.</p>
<p>注意到<span class="math inline">\(f ( x
)\)</span>下凸,考虑求出两条切线,那么这两条切线与<span class="math inline">\(y = b\)</span>的交点之差要大于等于<span class="math inline">\(x_2 - x_1\)</span>,两条割线交点之差要小于等于<span class="math inline">\(x_2 - x_1\)</span>.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是<span class="math inline">\(b \rightarrow - \frac{ 1 }{ e
}\)</span>的情况,为了让这种情况有解,我们的割线必过<span class="math inline">\(( \frac{ 1 }{ e } , - \frac{ 1 }{ e }
)\)</span>.</p>
<p>考虑直接选取<span class="math inline">\(( 0 , 0 )\)</span>和<span class="math inline">\(( 1 , 0
)\)</span>作为另外两个点,这两条割线就是<span class="math inline">\(x = -
y\)</span>和<span class="math inline">\(x = ( e - 1 ) y +
1\)</span>.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得<span class="math inline">\(( x_2 - x_1 )_{ \max }\)</span>尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是<span class="math inline">\(u\)</span>,另一个是<span class="math inline">\(v\)</span>,其中<span class="math inline">\(v &lt;
\frac{ 1 }{ e } &lt; u\)</span>,那么两条切线分别是:</p>
<p><span class="math display">\[
\begin{cases}
x = \frac{ y - f ( u ) }{ f &#39; ( u ) } + u \\
x = \frac{ y - f ( v ) }{ f &#39; ( v ) } + v
\end{cases}
\]</span></p>
<p>那么,现在我们要做的就是找到一组<span class="math inline">\(( u , v
)\)</span>,使得:</p>
<p><span class="math display">\[
\frac{ b - f ( u ) }{ f &#39; ( u ) } + u - \frac{ b - f ( v ) }{ f
&#39; ( v ) } - v = \frac{ e^{ - 3 } + 2 + 3 b }{ 2 }
\]</span></p>
<p>感觉很难搞啊,我们不妨让<span class="math inline">\(u =
1\)</span>,自然有:</p>
<p><span class="math display">\[
\frac{ ( f &#39; ( v ) - 1 ) b + f ( v ) - vf &#39; ( v ) }{ f &#39; ( v
) } = \frac{ e^{ - 3 } + 3 b }{ 2 }
\]</span></p>
<p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<p><span class="math display">\[
\begin{cases}
\frac{ f &#39; ( v ) - 1 }{ f &#39; ( v ) } = \frac{ 3 }{ 2 } \\
\frac{ f ( v ) - vf &#39; ( v ) }{ f &#39; ( v ) } = \frac{ e^{ - 3 } }{
2 }
\end{cases}
\]</span></p>
<p>考虑让<span class="math inline">\(f &#39; ( v ) = -
2\)</span>,则<span class="math inline">\(v = e^{ - 3
}\)</span>,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求证:<span class="math inline">\(\forall x \in ( 0 , + \infty ) , \ln
x + 1 &gt; \frac{ 1 }{ e^{ x + 1 } } - \frac{ 2 }{ e^2 x }\)</span>.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以<span class="math inline">\(x\)</span>,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为<span class="math inline">\(x \ln x + x &gt; \frac{ x
}{ e^{ x + 1 } } - \frac{ 2 }{ e^2 }\)</span>,然后证明左边的最小值<span class="math inline">\(\geq\)</span>右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4>
<p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5>
<p>已知<span class="math inline">\(a = 0 . 1 e^{ 0 . 1 } , b = \frac{ 1
}{ 9 } , c = - \ln 0 . 9\)</span>,求比较<span class="math inline">\(a ,
b , c\)</span>的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6>
<p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算<span class="math inline">\(a\)</span>和<span class="math inline">\(c\)</span>的大小关系.</p>
<p>构造函数<span class="math inline">\(f ( x ) = xe^x + \ln ( 1 - x
)\)</span>,则<span class="math inline">\(f ( 0 . 1 ) &gt; 0 \Rightarrow
a &gt; c\)</span>.</p>
<p>考察<span class="math inline">\(f ( 0 ) = 0\)</span>,<span class="math inline">\(f &#39; ( 0 ) = 0\)</span>,<span class="math inline">\(f &#39; &#39; ( 0 ) = 4 &gt; 0\)</span>,则<span class="math inline">\(f ( 0 ) =
0\)</span>是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算<span class="math inline">\(f ( 0 . 1 ) &gt; 0\)</span>.</p>
<h6><span id="估算定积分">估算定积分</span></h6>
<p>考察<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的大小关系,不妨设<span class="math inline">\(f ( x ) = ( 1 - x ) e^{ 1 - x } - \frac{ 1 }{ 10 x
}\)</span>,则<span class="math inline">\(f ( 0 . 9 ) &lt; 0 \Rightarrow
b &gt; a\)</span>.</p>
<p>注意到<span class="math inline">\(f ( 1 ) = - \frac{ 1 }{ 10
}\)</span>,<span class="math inline">\(f &#39; ( 1 ) = - \frac{ 9 }{ 10
}\)</span>,考虑估算一下积分,那么<span class="math inline">\(f ( 0 . 9 )
\approx f ( 1 ) - f &#39; ( 1 ) 0 . 1 = - \frac{ 1 }{ 100 } &lt;
0\)</span>.</p>
<p>你可能会觉得这个<span class="math inline">\(- \frac{ 1 }{ 100
}\)</span>,是不是不太能那么肯定地估算啊.但是实际上,我们考察<span class="math inline">\(f &#39; ( x ) = ( x - 2 ) e^{ 1 - x } + \frac{ 1
}{ 10 x^2 }\)</span>,这个东西在<span class="math inline">\([ 0 . 9 , 1
]\)</span>上直觉上平均值是大于<span class="math inline">\(- \frac{ 9 }{
10 }\)</span>的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6>
<p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6>
<p>接下来开抄标答.</p>
<p>令<span class="math inline">\(f_a ( x ) = xe^x , f_b ( x ) = \frac{ x
}{ 1 - x } , f_c ( x ) = - \ln ( 1 - x )\)</span>.</p>
<p>这样当<span class="math inline">\(x = 0 .
1\)</span>的时候所有的数字都被正确表示了.</p>
<p>比较<span class="math inline">\(a , b\)</span>:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<p><span class="math display">\[
\begin{aligned}
y &amp; = \ln ( a ) - \ln ( b ) = x + \ln ( 1 - x ) \\
y &#39; &amp; = 1 - \frac{ 1 }{ 1 - x } = \frac{ - x }{ 1 - x }
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(x = 0\)</span>的时候<span class="math inline">\(y = 0\)</span>,又注意到其在<span class="math inline">\(( 0 , 0 . 1 )\)</span>上单减,这样立有<span class="math inline">\(a &lt; b\)</span>.</p>
<p>比较<span class="math inline">\(a , c\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
y &amp; = a - c = xe^x + \ln ( 1 - x ) \\
y &#39; &amp; = ( x + 1 ) e^x - \frac{ 1 }{ 1 - x } = \frac{ ( 1 + x ) (
1 - x ) e^x - 1 }{ 1 - x } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(x = 0\)</span>的时候<span class="math inline">\(y = 0\)</span>,又注意到其在<span class="math inline">\(( 0 , 0 . 1 )\)</span>上单增,这样立有<span class="math inline">\(a &gt; c\)</span>.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2>
<h3><span id="递归式的求解">递归式的求解</span></h3>
<h4><span id="特征根法">特征根法</span></h4>
<p>一个常系数的<span class="math inline">\(k\)</span>阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = P_n + \sum_{ i = 1 }^k c_i a_{ n - i } , n \geq k \\
a_0 &amp; = C_0 , a_1 = C_1 , . . . , a_{ k - 1 } = C_{ k - 1 }
\end{aligned}
\]</span></p>
<p>当<span class="math inline">\(P = 0\)</span>时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程<span class="math inline">\(r^k = \sum_{ i = 1 }^k c_i r^{
k - i
}\)</span>是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根<span class="math inline">\(r_1\)</span>和<span class="math inline">\(r_2\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r_1^n + \alpha_2
r_2^n\)</span>.</p>
<p>若其特征方程有两个相同的根<span class="math inline">\(r\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r^n + \alpha_2 nr^n\)</span>.</p>
<p>先考虑前者的证明,首先考虑对于<span class="math inline">\(n =
0\)</span>或者<span class="math inline">\(n =
1\)</span>的情况,我们考虑求出一组<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C_0 &amp; = \alpha_1 + \alpha_2 \\
C_1 &amp; = \alpha_1 r_1 + \alpha_2 r_2
\end{aligned}
\]</span></p>
<p>若<span class="math inline">\(r_1 \ne r_2\)</span>,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha_1 &amp; = \cfrac{ C_1 - C_0 r_2 }{ r_1 - r_2 } \\
\alpha_2 &amp; = C_0 - \alpha_1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r_1^{ n - 1 } + \alpha_2 r_2^{ n - 1 } ) + c_2 (
\alpha_1 r_1^{ n - 2 } + \alpha_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 ( c_1 r_1^{ n - 1 } + c_2 r_1^{ n - 2 } ) + \alpha_2 (
c_1 r_2^{ n - 1 } + c_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 r_1^n + \alpha_2 r_2^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有<span class="math inline">\(\Delta = c_1^2 +
4 c_2 = 0\)</span>,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C_0 &amp; = \alpha_1 \\
C_1 &amp; = \alpha_1 r + \alpha_2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r^{ n - 1 } + \alpha_2 nr^{ n - 1 } - \alpha_2
r^{ n - 1 } ) + c_2 ( \alpha_1 r^{ n - 2 } + \alpha_2 nr^{ n - 2 } - 2
\alpha_2 r^{ n - 2 } ) \\
&amp; = a_n - c_1 \alpha_2 r^{ n - 1 } - 2 c_2 \alpha_2 r^{ n - 2 }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明<span class="math inline">\(c_1 r + 2 c_2 =
0\)</span>即可.根据方程,不难发现<span class="math inline">\(r = \cfrac{
c_1 }{ 2 }\)</span>,根据<span class="math inline">\(\Delta =
0\)</span>,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>在上面做<span class="math inline">\(k =
2\)</span>的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6>
<p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定<span class="math inline">\(a_0 , . . . , a_n\)</span>,其中<span class="math inline">\(a_0 \ne 0\)</span>,对于所有的<span class="math inline">\(k \in \mathbb{ N }\)</span>,若有下列式子成立:</p>
<p><span class="math display">\[
a_0 y_{ k + n } + a_1 y_{ k + n - 1 } + \cdots + a_n y_k = z_k
\]</span></p>
<p>则称为一个<span class="math inline">\(n\)</span>阶线性差分方程(或递归关系).为了简化,通常取<span class="math inline">\(a_0 = 1\)</span>.若<span class="math inline">\(\{
z_k \}\)</span>是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6>
<p>我们注意到,对于齐次差分方程而言,如果不给定<span class="math inline">\(y_0 , \cdots y_{ n - 1
}\)</span>,只是构造一组满足条件的<span class="math inline">\(y\)</span>的话,自然的想法是令<span class="math inline">\(y_k = r^k\)</span>.其中<span class="math inline">\(r\)</span>是辅助方程<span class="math inline">\(a_0 r^{ n } + a_1 r^{ n - 1 } + \cdots + a_n =
0\)</span>的一个根.</p>
<p>注意到如果我们将上面的内容看作是<span class="math inline">\(T : \{
y_k \} \mapsto \{ z_k
\}\)</span>这样一个映射,这显然是一个线性变换.这意味着齐次方程<span class="math inline">\(a_0 y_{ k + n } + a_1 y_{ k + n - 1 } + \cdots +
a_n y_k = 0\)</span>的解集就是<span class="math inline">\(T\)</span>的核,设为<span class="math inline">\(H\)</span>,不难发现只要给定<span class="math inline">\(y_0 , \cdots y_{ n - 1
}\)</span>,这个解就唯一确定,将它们看作自由变量,这意味着<span class="math inline">\(\dim H = n\)</span>.</p>
<p>还没完,注意到我们解方程可以解出<span class="math inline">\(n\)</span>个根,如果这<span class="math inline">\(n\)</span>个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了<span class="math inline">\(y_0 , \cdots y_{ n - 1
}\)</span>,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这<span class="math inline">\(n\)</span>个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的<span class="math inline">\(\mathbb{ R }^k\)</span>的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共<span class="math inline">\(n\)</span>个线性无关的根,然后拟合初值.我们如此做:对于一个出现了<span class="math inline">\(m\)</span>次的根<span class="math inline">\(r\)</span>,我们注意到<span class="math inline">\(r^k , kr^k , \cdots , k^{ m - 1 }
r^k\)</span>都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以<span class="math inline">\(kr^k\)</span>作为例子,即证明:</p>
<p><span class="math display">\[
a_0 nr^n + a_1 ( n - 1 ) r^{ n - 1 } + \cdots + a_1 r = 0
\]</span></p>
<p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个<span class="math inline">\(r\)</span>作为根,必然意味着原方程形如<span class="math inline">\(( y - r )^2 P\)</span>,其中<span class="math inline">\(P\)</span>是一个关于<span class="math inline">\(y\)</span>的多项式.</p>
<p>我们把它写开:<span class="math inline">\(( y^2 - 2 ry + r^2 ) P =
0\)</span>,然后我们用<span class="math inline">\(kr^k\)</span>去代替<span class="math inline">\(r^k\)</span>,不难发现代替后右边还是个多项式,而左边变成了<span class="math inline">\(0\)</span>,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
$$
<span class="math display">\[\begin{aligned}
a_0 r^{ n + k } + a_1 r^{ n + k - 1 } + \cdots + a_1 r^k &amp; = 0 \\
a_0 ( n + k ) r^{ n + k - 1 } + a_1 ( n + k - 1 ) r^{ n + k - 2 } +
\cdots + a_1 kr^{ k - 1 } &amp; = 0 \\
a_0 ( n + k ) r^{ n + k } + a_1 ( n + k - 1 ) r^{ n + k - 1 } + \cdots +
a_1 kr^{ k } &amp; = 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:<span class="math inline">\(( ( y - r )^2 P )
&#39; = ( y - r ) ( ( y - r ) P ) &#39; + ( y - r ) &#39; ( y - r ) P =
( y - r ) [ ( y - r ) &#39; P + ( ( y - r ) P ) &#39; ]\)</span>,<span class="math inline">\(r\)</span>一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6>
<p>我们注意到齐次差分方程一定能写成<span class="math inline">\(\vec{ x
}_k = A \vec{ x }_{ k - 1 }\)</span>的形式.如果我们取<span class="math inline">\(A\)</span>的特征向量的线性组合作为<span class="math inline">\(\vec{ x }_0\)</span>,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为<span class="math inline">\(1\)</span>的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是<span class="math inline">\(\vec{ x }_{ k +
1 } = A \vec{ x }\)</span>,<span class="math inline">\(\vec{ x }_{ n } =
A^n \vec{ x }_0\)</span>.而我们又知道CH定理:<span class="math inline">\(p ( A ) = 0\)</span>,我们用多项式取膜,有<span class="math inline">\(A^n = p ( A ) F ( A ) + G ( A ) = G ( A
)\)</span>,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3>
<h4><span id="和式的基本运算">和式的基本运算</span></h4>
<p>分配律:<span class="math inline">\(\\ \sum_{ i \in S } ca_i = c
\sum_{ i \in S } a_i \\\)</span>.</p>
<p>结合律:<span class="math inline">\(\\ \sum_{ i \in S } ( a_i + b_i )
= \sum_{ i \in S } a_i + \sum_{ i \in S } b_i\)</span>.</p>
<p>交换律:<span class="math inline">\(\sum_{ i \in S } a_i = \sum_{ p (
i ) \in S } a_{ p ( i ) }\)</span>,其中<span class="math inline">\(p\)</span>是<span class="math inline">\(S\)</span>集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum_{ i } \sum_{ j } a_{ i , j } [ P
( i , j ) ] = \sum_{ j } \sum_{ i } a_{ i , j } [ P ( i , j )
]\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ i = 1 }^n \sum_{ j = i }^n a_{
i , j } = \sum_{ j = 1 }^n \sum_{ i = 1 }^j a_{ i , j
}\)</span>.</p></li>
</ol>
<p>一般分配律:<span class="math inline">\(\sum_{ i } \sum_{ j } a_{ i }
b_j = ( \sum_{ i } a_i ) ( \sum_j b_j )\)</span>.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6>
<p>等差数列求和：</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ( ai + b ) = \sum_{ i = 0 }^n ( a ( n - i )
+ b ) \\
2 S_n &amp; = \sum_{ i = 0 }^n ( an + 2 b ) = an ( n + 1 ) + 2 b ( n + 1
) \\
S_n &amp; = ( n + 1 ) ( \frac{ an }{ 2 } + b )
\end{aligned}
\]</span></p>
<h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6>
<p>令<span class="math inline">\(S = \sum_{ 1 \leq i &lt; j \leq n } (
a_j - a_i ) ( b_j - b_i ) = \sum_{ 1 \leq j &lt; i \leq n } ( a_j - a_i
) ( b_j - b_i )\)</span>.</p>
<p>考虑恒等式<span class="math inline">\([ 1 \leq j &lt; i \leq n ] + [
1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq
n ]\)</span>.</p>
<p>那么我们有:</p>
$$
<span class="math display">\[\begin{aligned}
2 S &amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) -
\sum_{ 1 \leq i = j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = 2 n \sum_{ i = 1 }^n a_i b_i - 2 ( \sum_{ i = 1 }^n a_i ) (
\sum_{ j = 1 }^n b_j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>又有<span class="math inline">\(( \sum_{ i = 1 }^n a_i ) ( \sum_{ j =
1 }^n b_j ) = n \sum_{ i = 1 }^n a_i b_i - \sum_{ 1 \leq i &lt; j \leq n
} ( a_j - a_i ) ( b_j - b_i )\)</span>,显然有以下式子:</p>
$$
<span class="math display">\[\begin{aligned}
( \sum_{ i = 1 }^n a_i ) ( \sum_{ j = 1 }^n b_j ) &amp; \leq n \sum_{ i
= 1 }^n a_i b_i , \forall i &lt; j , a_i \leq a_j \land b_i \leq b_j \\
( \sum_{ i = 1 }^n a_i ) ( \sum_{ j = 1 }^n b_j ) &amp; \geq n \sum_{ i
= 1 }^n a_i b_i , \forall i &lt; j , a_i \leq a_j \land b_i \geq b_j \\

\end{aligned}\]</span>
<p>$$</p>
<p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6>
<p>即<span class="math inline">\(\sum_{ 1 \leq j &lt; k \leq n } ( a_j
b_k - a_k b_j )^2 = ( \sum_{ i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2
) - ( \sum_{ i = 1 }^n a_i b_i )^2 \\\)</span>.</p>
<p>令<span class="math inline">\(S_n = \sum_{ 1 \leq j &lt; k \leq n } (
a_j b_k - a_k b_j )^2 \\\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S_n &amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j b_k - a_k b_j )^2
\\
&amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j^2 b_k^2 - 2 a_j a_k b_j
b_k - a_k^2 b_j^2 ) \\
&amp; = 2 ( \sum_{ i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - 2 (
\sum_{ i = 1 }^n a_i b_i )^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ax^i \\
&amp; = a + \sum_{ i = 1 }^n ax^i \\
&amp; = a + x \sum_{ i = 0 }^{ n - 1 } ax^i \\
&amp; = a + xS_{ n - 1 }
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(S_{ n - 1 } + ax^n = S_n = a + xS_{ n -
1 }\)</span>,有<span class="math inline">\(S_n + ax^{ n + 1 } = a + xS_n
, S_n = a \frac{ x^{ n + 1 } - 1 }{ x - 1 }\)</span>，其中<span class="math inline">\(x \ne 1\)</span>.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6>
<p><span class="math inline">\(S_n = \sum_{ i = 0 }^n i^2\)</span>.</p>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^{ n - 1 } i^2 + n^2 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^2 + n^2 \\
&amp; = S_n - 2 \sum_{ i = 1 }^n i + n + n^2
\end{aligned}
\]</span></p>
<p>我们无法得到<span class="math inline">\(S_n\)</span>的封闭形式,但我们发现我们得到了<span class="math inline">\(\sum_{ i = 1 }^n i\)</span>的封闭形式.</p>
<p>那以此类推，我们设<span class="math inline">\(W_n = \sum_{ i = 0 }
i^3\)</span></p>
<p><span class="math display">\[
\begin{aligned}
W_n &amp; = \sum_{ i = 0 }^{ n - 1 } i^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n i^3 - 3 \sum_{ i = 1 }^n i^2 + 3 \sum_{ i = 1
}^n i - n + n^3 \\
&amp; = W_n - 3 S_n + 3 \frac{ n + n^2 }{ 2 } - n + n^3 \\
S_n &amp; = \frac{ n + n^2 }{ 2 } - \frac{ n - n^3 }{ 3 } \\
&amp; = \frac{ n + 3 n^2 + 2 n^3 }{ 6 } \\
&amp; = \frac{ n ( 1 + 3 n + 2 n^2 ) }{ 6 } \\
&amp; = \frac{ n ( 2 n + 1 ) ( n + 1 ) }{ 6 }
\end{aligned}
\]</span></p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h6><span id="example1平方和公式">Example1(平方和公式)</span></h6>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ k = 1 }^n k^2 \\
&amp; = \sum_{ k = 1 }^n \sum_{ i = 1 }^k k \\
&amp; = \sum_{ i = 1 }^n \sum_{ k = i }^n k \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( i + n ) ( n - i + 1 ) \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( in - i^2 + i + n^2 - ni + n )
\\
&amp; = \frac{ 1 }{ 2 } ( \sum_{ i = 1 }^n i - \sum_{ i = 1 }^n i^2 +
n^3 + n^2 ) \\
&amp; = \frac{ 1 }{ 4 } n ( n + 1 ) - \frac{ 1 }{ 2 } S_n + \frac{ n^3 +
n^2 }{ 2 }
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(S_n\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i^3 \\\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum_{ i = 1 }^n i^3 \\
&amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i i^2 \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n i^2 \\
&amp; = \sum_{ j = 1 }^n ( \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 6 } -
\frac{ ( j - 1 ) j ( 2 j - 1 ) }{ 6 } ) \\
&amp; = \frac{ n^2 ( n + 1 ) ( 2 n + 1 ) }{ 6 } - \frac{ 1 }{ 3 } S ( n
) + \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 12 } - \frac{ n ( n + 1 ) }{ 12 }
\\
S ( n ) &amp; = \frac{ n^2 ( n + 1 )^2 }{ 4 }
\end{aligned}
\]</span></p>
<h5><span id="problme3">Problme3</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n iq^i ( q \ne 1
)\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n iq^i &amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n q^i \\
&amp; = \sum_{ j = 1 }^n \frac{ q^j - q^{ n + 1 } }{ 1 - q } \\
&amp; = \frac{ 1 }{ q - 1 } \sum_{ j = 1 }^n ( q^{ n + 1 } - q^j ) \\
&amp; = \frac{ 1 }{ q - 1 } ( nq^{ n + 1 } - \frac{ q^{ n + 1 } - q }{ q
- 1 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="problemex2">ProblemEX2</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n ( ai + b ) q^{ i - 1 }
( q \ne 1 )\)</span>.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令<span class="math inline">\(A = \frac{ a }{ q - 1 } , B = \frac{ b
- A }{ q - 1 }\)</span>,答案为<span class="math inline">\(( An + B ) q^n
- B\)</span>.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子<span class="math inline">\(E\)</span>，使得<span class="math inline">\(Ef ( x ) = f ( x + 1 )\)</span>.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子<span class="math inline">\(\Delta f ( x ) = f ( x + 1 )
- f ( x )\)</span>，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有<span class="math inline">\(\Delta = E -
1\)</span>.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子<span class="math inline">\(\Sigma\)</span>,可以得到有限微积分的基本定理:</p>
<p><span class="math inline">\(g ( x ) = \Delta f ( x ) \Leftrightarrow
\sum g ( x ) \delta x = f ( x ) + C \\\)</span></p>
<p>这里的<span class="math inline">\(\Sigma\)</span>又被称为不定和式,是差分等于<span class="math inline">\(g\)</span>的一个函数类.</p>
<p>值得一提的是,这里的<span class="math inline">\(C\)</span>与无限微积分中的<span class="math inline">\(C\)</span>有一定区别,这里的<span class="math inline">\(C\)</span>可以是满足<span class="math inline">\(p
( x ) = p ( x + 1 )\)</span>的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果<span class="math inline">\(g ( x ) = \Delta f ( x
)\)</span>,那么有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = f ( x ) |^{ b }_a = f ( b ) - f ( a ) \\\)</span>.</p>
<p>值得一提的是,如果<span class="math inline">\(a \leq
b\)</span>,显然有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = \sum_{ x = a }^{ b - 1 } g ( x ) \\\)</span>.</p>
<p>但如果<span class="math inline">\(a &gt; b\)</span>,那么<span class="math inline">\(\sum \nolimits_{ a }^b g ( x ) \delta x = - \sum
\nolimits_b^a g ( x ) \delta x \\\)</span>.</p>
<p>事实上,我们一定有:<span class="math inline">\(\sum \nolimits_a^b g (
x ) \delta x + \sum \nolimits_b^c g ( x ) \delta x = \sum \nolimits_a^c
g ( x ) \delta x \\\)</span>.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的<span class="math inline">\(D ( x^m ) = mx^{ m - 1
}\)</span>，有:</p>
<p>(x<sup>{})=mx</sup>{}，mx<sup>{}x=x</sup>{}+C，m\</p>
<p>\</p>
<p>类比无限微积分中的<span class="math inline">\(D ( \ln x ) = \frac{ 1
}{ x }\)</span>，有:</p>
<p>令H(x)=_{i=1}<sup>x\(H(x))=x</sup>{}，x^{}x =H(x)+C\</p>
<p>\</p>
<p>类比无限微积分中的<span class="math inline">\(D ( e^x ) =
e^x\)</span>,有:</p>
<p><span class="math inline">\(\Delta ( 2^x ) = 2^x ， \sum 2^x \delta x
= 2^x + C \\\)</span></p>
<p><span class="math inline">\(\Delta ( c^x ) = ( c - 1 ) c^x ， \sum
c^x \delta x = \frac{ c^x }{ c - 1 } + C , c \ne 1 \\\)</span></p>
<p><span class="math inline">\(\Delta ( c^{ \underline{ x } } ) = \frac{
c^{ \underline{ x + 2 } } }{ c - x } , \sum \frac{ c^{ \underline{ x + 2
} } }{ c - x } \delta x = c^{ \underline{ x } } + C , c - x \ne 0
\\\)</span>.</p>
<p>根据组合数公式,有:</p>
<p><span class="math inline">\(\Delta ( \binom{ x }{ k } ) = \binom{ x
}{ k - 1 } \\\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>仍然考虑平方和公式：</p>
<p>我们有:<span class="math inline">\(k^2 = k^{ \underline{ 2 } } + k^{
\underline{ 1 } } \\\)</span>.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S_{ n - 1 } &amp; = \sum_{ i = 0 }^{ n - 1 } i^2 \\
&amp; = \sum_{ i = 0 }^{ n - 1 } ( i^{ \underline{ 2 } } + i^{
\underline{ 1 } } ) \\
&amp; = \sum \nolimits_{ 0 }^n x^{ \underline{ 2 } } \delta x + \sum
\nolimits_{ 0 }^n x^{ \underline{ 1 } } \delta x \\
&amp; = \frac{ n^\underline{ 3 } }{ 3 } + \frac{ n^{ \underline{ 2 } }
}{ 2 }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v = Ev \Delta u + u \Delta
v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p><span class="math inline">\(\sum u \Delta v = uv - \sum Ev \Delta u
\\\)</span>.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math inline">\(\sum_{ i = l }^{ r - 1 } ( a_{ i + 1 } -
a_i ) b_i = a_r b_r - a_l b_l - \sum_{ i = l }^{ r - 1 } a_{ i + 1 } (
b_{ i + 1 } - b_i ) \\\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k 2^k \\\)</span>.</p>
<p>根据分部求和法则，我们有:</p>
<p><span class="math inline">\(\sum x 2^x \delta x = x 2^x - \sum 2^{ x
+ 1 } \delta x = x 2^x - 2^{ x + 1 } + C \\\)</span>.</p>
<p>改为定和式形式，显然有:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ k = 0 }^n k 2^k \\
= &amp; \sum \nolimits_0^{ n + 1 } x 2^x \delta x \\
= &amp; ( n + 1 ) 2^{ n + 1 } - 2^{ n + 2 } + 2 \\
= &amp; ( n - 1 ) 2^{ n + 1 } + 2 \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^{ n - 1 } kH_k
\\\)</span>.</p>
<p>令<span class="math inline">\(u ( x ) = H_x , v ( x ) = \frac{ 1 }{ 2
} x^{ \underline{ 2 } } \\\)</span>.</p>
<p>带入分部求和法则，显然有:</p>
<p><span class="math inline">\(\sum xH_x \delta x = \frac{ x^\underline{
2 } }{ 2 } H_x - \frac{ x^\underline{ 2 } }{ 4 } + C \\\)</span>.</p>
<p>带入即可求出原式<span class="math inline">\(= \frac{ n^\underline{ 2
} }{ 2 } ( H_n - \frac{ 1 }{ 2 } ) \\\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i (
i + 1 ) } \\\)</span>.</p>
<p>令<span class="math inline">\(u = ( 2 n + 1 ) , v = - \frac{ 1 }{ i
}\)</span>,则<span class="math inline">\(\Delta u = 2 , \Delta v =
\frac{ 1 }{ i ( i + 1 ) }\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i ( i + 1 ) } &amp; = ( 2 n + 3 )
\times ( - \frac{ 1 }{ n + 1 } ) + 3 - \sum_{ i = 1 }^n ( - \frac{ 2 }{
i + 1 } ) \\
&amp; = - \frac{ 2 n + 3 }{ n + 1 } + 2 H_n + \frac{ n + 3 }{ n + 1 } \\
&amp; = 2 H_n - \frac{ n }{ n + 1 }
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{
( k + 1 ) ( k + 2 ) } \\\)</span>.</p>
<p>令<span class="math inline">\(u = H_n , v = - \frac{ 1 }{ n + 1 } ,
\Delta u = \frac{ 1 }{ n + 1 } , \Delta v = \frac{ 1 }{ ( n + 1 ) ( n +
2 ) } \\\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{ ( k + 1 ) ( k + 2 ) } &amp; = -
\frac{ H_n }{ n + 1 } - \sum_{ i = 0 }^{ n - 1 } ( - \frac{ 1 }{ ( i + 2
) ( i + 1 ) } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + \sum_{ i = 0 }^{ n - 1 } ( \frac{ 1 }{
i + 1 } - \frac{ 1 }{ i + 2 } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + H_n - ( H_n - 1 + \frac{ 1 }{ n + 1 }
) \\
&amp; = 1 - \frac{ H_n + 1 }{ n + 1 }
\end{aligned}
\]</span></p>
<h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3>
<h5><span id="example">Example</span></h5>
<p>令<span class="math inline">\(A = \{ 2 n - 1 | n \in \mathbb{ N }_{ +
} \} , B = \{ 3 n - 1 | n \in \mathbb{ N }_{ + } \}\)</span>.求<span class="math inline">\(A \cap B\)</span>,以及<span class="math inline">\(A \cup B\)</span>的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
$$
<span class="math display">\[\begin{aligned}
a &amp; \in A \Leftrightarrow a \equiv - 1 \pmod{ 2 } \\
b &amp; \in B \Leftrightarrow b \equiv - 1 \pmod{ 6 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以<span class="math inline">\(A \cap B = \{ 6 n - 1 | n \in
\mathbb{ N }_{ + } \}\)</span>.</p>
<p>而同理,<span class="math inline">\(x \in A \cup B \Leftrightarrow x
\equiv - 1 / - 2 / - 3 / - 5 \pmod{ 6 }\)</span>.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3>
<p>设<span class="math inline">\(A = \{ x | x = 2 n - 1 , n \in \mathbb{
N }_+ \} , B = \{ x | x = 2^n , n \in \mathbb{ N }_+
\}\)</span>,现在将<span class="math inline">\(A \cup
B\)</span>中的元素排序并提取成一个数列<span class="math inline">\(a\)</span>,求使得<span class="math inline">\(S_n
&gt; 12 a_n\)</span>最小的正整数<span class="math inline">\(n\)</span>.</p>
<p>写出数列,它长这样:</p>
<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 \\
3 &amp; 4 \\
5 &amp; 7 &amp; 8 \\
9 &amp; 11 &amp; 13 &amp; 15 &amp; 16 \\
&amp; &amp; \cdots
\end{matrix}
\]</span></p>
<p>不妨设<span class="math inline">\(n\)</span>在第<span class="math inline">\(r\)</span>行<span class="math inline">\(c\)</span>列,显然<span class="math inline">\(( r ,
c )\)</span>和<span class="math inline">\(n\)</span>构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的<span class="math inline">\(n\)</span>能快速表达<span class="math inline">\((
r , c )\)</span>,要么反之.显然反之比较简单.</p>
<p>考虑设前<span class="math inline">\(k\)</span>行共有<span class="math inline">\(W_k\)</span>个数,不难发现<span class="math inline">\(W_{ k + 1 } = W_k + 2^{ k - 1 } + 1 , W_k = 2^{ k
- 1 } + k\)</span>.</p>
<p>显然,对于<span class="math inline">\(( r , c
)\)</span>来说,它对应的<span class="math inline">\(n\)</span>就是<span class="math inline">\(W_{ r - 1 } + c\)</span>.</p>
<p>令<span class="math inline">\(SR_{ r }\)</span>为前<span class="math inline">\(r\)</span>行数字之和,不难发现<span class="math inline">\(SR_r = 2^{ r + 1 } - 2 + ( 2^{ r - 1 }
)^2\)</span>.</p>
<p>接下来考虑找到这个最小的<span class="math inline">\(n\)</span>,显然<span class="math inline">\(r \ne
1\)</span>,接下来只考虑<span class="math inline">\(r \geq
2\)</span>的情况.</p>
<p>那么我们可以轻松写出<span class="math inline">\(S_n\)</span>和<span class="math inline">\(a_n\)</span>的表达式,下面直接给出:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = SR_{ r - 1 } + \sum_{ k = 1 }^c ( 2^{ r - 1 } + 2 k - 1 ) -
[ c = 2^{ r - 2 } + 2 ] \\
S_n &amp; = 2^r - 2 + 4^{ r - 2 } + 2^{ r - 1 } c + c^2 - [ c = 2^{ r -
2 } + 1 ] \\
a_n &amp; = 2^{ r - 1 } + 2 c - 1 - [ c = 2^{ r - 2 } + 1 ]
\end{aligned}
\]</span></p>
<p>讨论一下<span class="math inline">\([ c = 2^{ r - 2 } + 1
]\)</span>这个判定式取<span class="math inline">\(0\)</span>还是取<span class="math inline">\(1\)</span>,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3>
<h2><span id="几何导论">几何导论</span></h2>
<h3><span id="三角相关">三角相关</span></h3>
<h4><span id="三角恒等变换">三角恒等变换</span></h4>
<h5><span id="两角和差公式">两角和差公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin ( A + B ) &amp; = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) &amp; = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) &amp; = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) &amp; = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) &amp; = \frac{ \tan A + \tan B }{ 1 - \tan A \tan B } \\
\tan ( A - B ) &amp; = \frac{ \tan A - \tan B }{ 1 + \tan A \tan B }
\end{aligned}
\]</span></p>
<h5><span id="倍角公式">倍角公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\tan ( 2 A ) &amp; = \frac{ 2 \tan A }{ 1 - \tan^2 A } \\
\sin ( 2 A ) &amp; = 2 \sin A \cos A \\
\cos ( 2 A ) &amp; = \cos^2 A - \sin^2 A = 2 \cos^2 A - 1 = 1 - 2 \sin^2
A
\end{aligned}
\]</span></p>
<h5><span id="半角公式">半角公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin ( \frac{ A }{ 2 } ) &amp; = \pm \sqrt{ \frac{ 1 - \cos A }{ 2 } }
\\
\cos ( \frac{ A }{ 2 } ) &amp; = \pm \sqrt{ \frac{ 1 + \cos A }{ 2 } }
\\
\tan ( \frac{ A }{ 2 } ) &amp; = \frac{ \sin A }{ 1 + \cos A } = \frac{
1 - \cos A }{ \sin A } = \pm \sqrt{ \frac{ 1 - \cos A }{ 1 + \cos A } }
\end{aligned}
\]</span></p>
<h5><span id="和差化积">和差化积</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin A + \sin B &amp; = 2 \sin ( \frac{ A + B }{ 2 } ) \cos ( \frac{ A -
B }{ 2 } ) \\
\sin A - \sin B &amp; = 2 \cos ( \frac{ A + B }{ 2 } ) \sin ( \frac{ A -
B }{ 2 } ) \\
\cos A + \cos B &amp; = 2 \cos ( \frac{ A + B }{ 2 } ) \cos ( \frac{ A -
B }{ 2 } ) \\
\cos A - \cos B &amp; = - 2 \sin ( \frac{ A + B }{ 2 } ) \sin ( \frac{ A
- B }{ 2 } ) \\
\tan A + \tan B &amp; = \frac{ \sin ( A + B ) }{ \cos A \cos B }
\end{aligned}
\]</span></p>
<p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<p><span class="math display">\[
\sin^2 A - \sin^2 B = \sin ( A - B ) \sin ( A + B )
\]</span></p>
<p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sin A \sin B &amp; = - \frac{ 1 }{ 2 } [ \cos ( A + B ) - \cos ( A - B
) ] \\
\cos A \cos B &amp; = \frac{ 1 }{ 2 } [ \cos ( A + B ) + \cos ( A - B )
] \\
\sin A \cos B &amp; = \frac{ 1 }{ 2 } [ \sin ( A + B ) + \sin ( A - B )
] \\
\cos A \sin B &amp; = \frac{ 1 }{ 2 } [ \sin ( A + B ) - \sin ( A - B )
]
\end{aligned}
\]</span></p>
<h5><span id="万能公式">万能公式</span></h5>
<p>令<span class="math inline">\(w = \tan \frac{ A }{ 2
}\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
\sin A &amp; = \frac{ 2 w }{ 1 + w^2 } \\
\cos A &amp; = \frac{ 1 - w^2 }{ 1 + w^2 } \\
\tan A &amp; = \frac{ 2 w }{ 1 - w^2 }
\end{aligned}
\]</span></p>
<p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<p><span class="math display">\[
\begin{aligned}
\cos ( x ) &amp; = \frac{ e^{ ix } + e^{ - ix } }{ 2 } \\
\sin ( x ) &amp; = \frac{ e^{ ix } - e^{ - ix } }{ 2 i }
\end{aligned}
\]</span></p>
<h5><span id="补充公式">补充公式</span></h5>
<p><span class="math display">\[
\begin{aligned}
1 + \sin A &amp; = ( \sin \frac{ A }{ 2 } + \cos \frac{ A }{ 2 } )^2 \\
1 - \sin A &amp; = ( \sin \frac{ A }{ 2 } - \cos \frac{ A }{ 2 } )^2
\end{aligned}
\]</span></p>
<h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4>
<p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的<span class="math inline">\(k\)</span>来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6>
<p>已知函数<span class="math inline">\(f ( x ) = \sin ( \omega x +
\varphi ) , w &gt; 0\)</span>,<span class="math inline">\(f ( - \frac{
\pi }{ 6 } ) = 0 , f ( \frac{ \pi }{ 2 } ) = - 1\)</span>,求<span class="math inline">\(w\)</span>和<span class="math inline">\(\varphi\)</span>的表达式.</p>
<p>正确做法应该是强设<span class="math inline">\(k_1 ,
k_2\)</span>,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的<span class="math inline">\(\omega\)</span>和<span class="math inline">\(\varphi\)</span>都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令<span class="math inline">\(\frac{ \pi }{ 2
}\)</span>为单位<span class="math inline">\(1\)</span>,我们必有以下式子:</p>
<p><span class="math display">\[
\begin{aligned}
- \frac{ \omega }{ 3 } + \varphi &amp; \equiv 0 \pmod{ 2 } \\
\omega + \varphi &amp; \equiv 3 \pmod{ 4 }
\end{aligned}
\]</span></p>
<p>下面推导<span class="math inline">\(\omega\)</span>,首先将上面两个式子直接相减,立有:</p>
<p><span class="math display">\[
\frac{ 4 }{ 3 } \omega \equiv 1 \pmod{ 2 }
\]</span></p>
<p>对于<span class="math inline">\(\varphi\)</span>,考虑类似的做法,将第一个式子乘以<span class="math inline">\(3\)</span>后与第二个式子相加,立有:</p>
<p><span class="math display">\[
4 \varphi \equiv 1 \pmod{ 2 }
\]</span></p>
<p>这样我们得到的必须满足的条件就有以下几条:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 4 }{ 3 } \omega &amp; \equiv 1 \pmod{ 2 } \\
4 \varphi &amp; \equiv 1 \pmod{ 2 } \\
\omega + \varphi &amp; \equiv 3 \pmod{ 4 }
\end{aligned}
\]</span></p>
<h3><span id="向量相关">向量相关</span></h3>
<h4><span id="旋转模型">旋转模型</span></h4>
<p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6>
<p>已知<span class="math inline">\(AB = 2 , AC = 1 , \angle A =
\theta\)</span>,<span class="math inline">\(BC\)</span>绕<span class="math inline">\(B\)</span>点顺时针旋转<span class="math inline">\(\frac{ \pi }{ 3 }\)</span>得到<span class="math inline">\(BD\)</span>,求以<span class="math inline">\(\theta\)</span>表示<span class="math inline">\(S_{
\triangle CBD }\)</span>.</p>
<p>先来说文化课做法,我们直接表示<span class="math inline">\(S\)</span>,令<span class="math inline">\(\alpha =
\angle ABC\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
S &amp; = | BD | \sin ( \alpha + \frac{ \pi }{ 3 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于这个式子,我们发现如果我们能得到<span class="math inline">\(| BD |
\sin ( \alpha )\)</span>和<span class="math inline">\(| BD | \cos (
\alpha )\)</span>就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现<span class="math inline">\(BD\)</span>是<span class="math inline">\(\alpha\)</span>的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出<span class="math inline">\(| BD | \sin
\alpha\)</span>,余弦定理可以帮助我们求出<span class="math inline">\(| BD
| \cos \alpha\)</span>.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出<span class="math inline">\(\overrightarrow{
AB }\)</span>和<span class="math inline">\(\overrightarrow{ BC
}\)</span>的坐标表示,将<span class="math inline">\(\overrightarrow{ BC
}\)</span>用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4>
<p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol type="1">
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p></li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作<span class="math inline">\(1\)</span>是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p></li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(\triangle ABC\)</span>中,<span class="math inline">\(b^2 = ac\)</span>,点<span class="math inline">\(D\)</span>在<span class="math inline">\(AC\)</span>上且满足<span class="math inline">\(BD
= b\)</span>,有<span class="math inline">\(\overrightarrow{ AD } = 2
\overrightarrow{ DC }\)</span>,求<span class="math inline">\(\cos \angle
ABC\)</span>.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定<span class="math inline">\(c = 1\)</span>,于是有<span class="math inline">\(b^2 = a\)</span>.</p>
<p>考虑我们要求<span class="math inline">\(\cos \angle
ABC\)</span>,而我们有一条很奇怪的边<span class="math inline">\(BD\)</span>,似乎不满足任何性质,我们立刻想到要把它用<span class="math inline">\(\angle
ABC\)</span>的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让<span class="math inline">\(c = 1\)</span>,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4>
<h5><span id="奔驰定理">奔驰定理</span></h5>
<p>对于<span class="math inline">\(\triangle ABC\)</span>内一点<span class="math inline">\(P\)</span>,立有<span class="math inline">\(S_{
\triangle PBC } \overrightarrow{ PA } + S_{ \triangle PAC }
\overrightarrow{ PB } + S_{ \triangle PAB } \overrightarrow{ PC } =
\vec{ 0 }\)</span>.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令<span class="math inline">\(a = PA , b = PB , c =
PC\)</span>,我们要证奔驰定理,也就是要证明:</p>
$$
<span class="math display">\[\begin{aligned}
bc \sin \alpha \overrightarrow{ PA } + ac \sin \beta \overrightarrow{ PB
} + ab \sin \gamma \overrightarrow{ PC } &amp; = \vec{ 0 } \\
abc \sin \alpha \frac{ \overrightarrow{ PA } }{ a } + abc \sin \beta
\frac{ \overrightarrow{ PB } }{ b } + abc \sin \gamma \frac{
\overrightarrow{ PC } }{ c } &amp; = \vec{ 0 } \\
\sin \alpha \frac{ \overrightarrow{ PA } }{ a } + \sin \beta \frac{
\overrightarrow{ PB } }{ b } + \sin \gamma \frac{ \overrightarrow{ PC }
}{ c } &amp; = \vec{ 0 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑<span class="math inline">\(| \frac{ \overrightarrow{ PA } }{ a }
| = | \frac{ \overrightarrow{ PB } }{ b } | = | \frac{ \overrightarrow{
PC } }{ c } | = 1\)</span>,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5>
<p>有正弦定理,<span class="math inline">\(| \overrightarrow{ OA } | = |
\overrightarrow{ OB } | = | \overrightarrow{ OC } | = \frac{ a }{ 2 \sin
A }\)</span>.</p>
<p>考虑三个三角形的面积可以表示为<span class="math inline">\(\frac{ r^2
}{ 2 } \sin \theta\)</span>,又考虑到圆中的<span class="math inline">\(\theta\)</span>是圆心角是圆周角的两倍,立有<span class="math inline">\(\sin ( 2 A ) \overrightarrow{ OA } + \sin ( 2 B )
\overrightarrow{ OB } + \sin ( 2 C ) \overrightarrow{ OC } = \vec{ 0
}\)</span>.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6>
<p>在<span class="math inline">\(\triangle ABC\)</span>中,<span class="math inline">\(AB = 2 , BC = \sqrt{ 10 } , AC =
3\)</span>,若<span class="math inline">\(O\)</span>是其外心,且<span class="math inline">\(\overrightarrow{ AO } = p \overrightarrow{ AB } +
q \overrightarrow{ AC }\)</span>.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用<span class="math inline">\(| OA | = | OB | = | OC
|\)</span>,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于<span class="math inline">\(p , q\)</span>的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了<span class="math inline">\(| OA |\)</span>,用上<span class="math inline">\(| OB |\)</span>,这样的话我们两边同时加上<span class="math inline">\(\overrightarrow{ BA }\)</span>,就可以得到<span class="math inline">\(p ,
q\)</span>的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据<span class="math inline">\(| OC |\)</span>也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow{ AO } &amp; = p \overrightarrow{ AB } + q
\overrightarrow{ AC } \\
\vec{ 0 } &amp; = ( p + q - 1 ) \overrightarrow{ OA } + p
\overrightarrow{ OB } + q \overrightarrow{ OC }
\end{aligned}
\]</span></p>
<p>考察奔驰定理,立有<span class="math inline">\(\frac{ p + q - 1 }{ \sin
( 2 A ) } = \frac{ p }{ \sin ( 2 B ) } = \frac{ q }{ \sin ( 2 C )
}\)</span>,简单题.</p>
<h6><span id="example2">Example2</span></h6>
<p>已知相异两点<span class="math inline">\(O , H\)</span>分别为<span class="math inline">\(\triangle ABC\)</span>的外心和垂心,若<span class="math inline">\(\overrightarrow{ OH } = m ( \overrightarrow{ OA }
+ \overrightarrow{ OB } + \overrightarrow{ OC } )\)</span>,求<span class="math inline">\(m\)</span>.</p>
<p>这题要用到的性质是,我们一定要知道<span class="math inline">\((
\overrightarrow{ OB } + \overrightarrow{ OC } ) \cdot \overrightarrow{
BC } = 0\)</span>,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出<span class="math inline">\(\overrightarrow{ AH
}\)</span>,然后两边同时乘以<span class="math inline">\(\overrightarrow{
BC }\)</span>就可以解决.注意到最后解方程的时候要么<span class="math inline">\(m = 1\)</span>,要么三角形等边,但是我们声明过<span class="math inline">\(O , H\)</span>相异两点.</p>
<h5><span id="重心">重心</span></h5>
<p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的<span class="math inline">\(1 : 2\)</span>的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若<span class="math inline">\(O\)</span>是重心,则必有<span class="math inline">\(\overrightarrow{ OA } + \overrightarrow{ OB } +
\overrightarrow{ OC } = \vec{ 0 }\)</span>.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5>
<p>若<span class="math inline">\(O\)</span>是重心,立有<span class="math inline">\(\overrightarrow{ OA } \cdot \overrightarrow{ BC }
= 0\)</span>,将<span class="math inline">\(\overrightarrow{ BC } =
\overrightarrow{ BO } + \overrightarrow{ OC }\)</span>,立有<span class="math inline">\(\overrightarrow{ OA } \cdot \overrightarrow{ OB }
= \overrightarrow{ OA } \cdot \overrightarrow{ OC } = \overrightarrow{
OB } \cdot \overrightarrow{ OC
}\)</span>.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有<span class="math inline">\(\overrightarrow{ OA }
\tan A + \overrightarrow{ OB } \tan B + \overrightarrow{ OC } \tan C =
\vec{ 0 }\)</span>.</p>
<h5><span id="内心">内心</span></h5>
<p>根据奔驰定理,立有<span class="math inline">\(a \overrightarrow{ OA }
+ b \overrightarrow{ OB } + c \overrightarrow{ OC } = \vec{ 0
}\)</span>.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3>
<h4><span id="基本概念">基本概念</span></h4>
<h5><span id="直线">直线</span></h5>
<p>使用直线的方向向量<span class="math inline">\(\vec{ s } = ( n , m , p
)\)</span>和直线上一点<span class="math inline">\(M_0 = ( x_0 , y_0 ,
z_0 )\)</span>.那么方程显然为:</p>
<p><span class="math display">\[
\frac{ x - x_0 }{ n } = \frac{ y - y_0 }{ m } = \frac{ z - z_0 }{ p }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x_0 + nt \\
y = y_0 + mt \\
z = z_0 + pt
\end{cases}
\]</span></p>
<h5><span id="平面">平面</span></h5>
<p>使用平面上的一点<span class="math inline">\(P_0 ( x_0 , y_0 , z_0
)\)</span>和该平面的法向量<span class="math inline">\(\vec{ n
}\)</span>来表示一个平面,不妨设<span class="math inline">\(\vec{ n } = (
A , B , C )\)</span>,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x_0 ) + B ( y - y_0 ) + C ( z - z_0 ) = 0
\]</span></p>
<p>如果我们令<span class="math inline">\(D = - ( Ax_0 + By_0 +
Cz_)\)</span>,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h5><span id="夹角">夹角</span></h5>
<h6><span id="两直线夹角">两直线夹角.</span></h6>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是<span class="math inline">\(\vec{ s_1 } = ( n_1 ,
m_1 , p_1 ) , \vec{ s_2 } = ( n_2 , m_2 , p_2 )\)</span>,也就有<span class="math inline">\(\varphi = \arccos ( \frac{ | \vec{ s }_1 \cdot
\vec{ s }_2 | }{ | \vec{ s }_1 | | \vec{ s }_2 | } ) \\\)</span>.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6>
<p>同样使用向量,不妨设方向向量<span class="math inline">\(\vec{ s } = (
n , m , p )\)</span>,法向量<span class="math inline">\(\vec{ f } = ( a ,
b , c )\)</span>,那么<span class="math inline">\(\varphi = \arcsin (
\frac{ | \vec{ s } \cdot \vec{ f } | }{ | \vec{ s } | | \vec{ f } | }
)\)</span>.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则<span class="math inline">\(am + bn + cp =
0\)</span>.</p></li>
<li><p>若直线与平面垂直,则<span class="math inline">\(\frac{ a }{ m } =
\frac{ b }{ n } = \frac{ c }{ p }\)</span>.注意这里分母可能除以<span class="math inline">\(0\)</span>,我们实际上应该是三个形如<span class="math inline">\(a = mt\)</span>的参数方程,这里简化了.</p></li>
</ol>
<h5><span id="交点">交点</span></h5>
<p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3>
<h4><span id="约定">约定</span></h4>
<p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可(<span class="math inline">\(mx + ny = 1\)</span>需要判断过原点的直线,<span class="math inline">\(y = kx + b\)</span>需要判断平行于<span class="math inline">\(y\)</span>轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点<span class="math inline">\(F_1 ,
F_2\)</span>距离之和为常数(<span class="math inline">\(&gt; | F_1 F_2
|\)</span>)的点轨迹.即:<span class="math inline">\(\{ P \mid | F_1 P | +
| F_2 P | = 2 a , F_1 ( - c , 0 ) , F_2 ( c , 0 ) \}\)</span>.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线(<span class="math inline">\(x = \pm \frac{
a^2 }{ c }\)</span>)的距离比是常数<span class="math inline">\(e = \frac{
c }{ a }\)</span>的点轨迹,即<span class="math inline">\(\{ P \mid \frac{
| PF_1 | }{ d_1 } = \frac{ | PF_2 | }{ d_2 } = \frac{ c }{ a } = e , F_1
( - c , 0 ) , F_2 ( c , 0 ) \}\)</span>.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点<span class="math inline">\(A_1 ( - a , 0 ) , A_2
( a , 0 )\)</span>的斜率乘积等于定值<span class="math inline">\(e^2 -
1\)</span>的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5>
<h6><span id="标准方程">标准方程</span></h6>
<p>由定义不难得到椭圆的标准方程:<span class="math inline">\(\frac{ x^2
}{ a^2 } + \frac{ y^2 }{ b^2 } = 1 ( b^2 = a^2 - c^2 , a &gt; b &gt; 0
)\)</span>.</p>
<h6><span id="一般方程">一般方程</span></h6>
<p><span class="math inline">\(nx^2 + my^2 = 1 ( n , m \geq 0
)\)</span>,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若<span class="math inline">\(P ( x_0 , y_0 )\)</span>,则<span class="math inline">\(| PF_1 | = a + ex_0\)</span>,<span class="math inline">\(| PF_2 | = a - ex_0\)</span>.</p>
<h6><span id="焦点弦">焦点弦</span></h6>
<p>过<span class="math inline">\(F_1\)</span>的弦<span class="math inline">\(| AB | = 2 a + e ( x_1 + x_2 )\)</span>.</p>
<p>过<span class="math inline">\(F_2\)</span>的弦<span class="math inline">\(| AB | = 2 a - e ( x_1 + x_2 )\)</span>.</p>
<p>注意到焦点弦最短时<span class="math inline">\(x_1 = x_2\)</span>.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即<span class="math inline">\(\bigtriangleup PF_1
F_2\)</span>,令<span class="math inline">\(\theta = \angle F_1
PF_2\)</span>,有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(C = 2 a + 2 c\)</span>.</p></li>
<li><p><span class="math inline">\(S = b^2 \tan \frac{ \theta }{ 2 } = c
| y_P |\)</span>.</p></li>
<li><p><span class="math inline">\(\cos \theta \geq 1 - 2
e^2\)</span>(当<span class="math inline">\(P\)</span>在短轴上取等).</p></li>
<li><p><span class="math inline">\(| PF_1 | | PF_2 | = \frac{ 2 b^2 }{ 1
+ \cos \theta }\)</span>.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example1">Example1</span></h6>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ a^2 } + \frac{ y^2
}{ b^2 } = 1\)</span>,<span class="math inline">\(P\)</span>是椭圆上一点,<span class="math inline">\(\angle F_1 PF_2\)</span>的角平分线交<span class="math inline">\(x\)</span>轴于<span class="math inline">\(Q (
\frac{ c }{ 4 } , 0 )\)</span>,求离心率取值范围.</p>
<p>注意到<span class="math inline">\(S_{ \bigtriangleup QPF_1 } = \frac{
5 }{ 3 } S_{ \bigtriangleup QPF_2 }\)</span>,又有<span class="math inline">\(Q\)</span>到<span class="math inline">\(PF_1\)</span>和<span class="math inline">\(PF_2\)</span>的距离相等,用等积法,显然<span class="math inline">\(PF_1 = \frac{ 5 }{ 4 } a , PF_2 = \frac{ 3 }{ 4 }
a\)</span>.</p>
<p>然后用三角形不等式做差就行.<span class="math inline">\(2 c &gt;
\frac{ 1 }{ 2 } a , \frac{ 1 }{ 4 } &lt; e\)</span></p>
<h4><span id="双曲线">双曲线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内与两定点<span class="math inline">\(F_1 ,
F_2\)</span>距离之差为常数(<span class="math inline">\(&gt; | F_1 F_2
|\)</span>)的点轨迹.即:<span class="math inline">\(\{ P \mid | | F_1 P |
- | F_2 P | | = 2 a , F_1 ( - c , 0 ) , F_2 ( c , 0 ) \}\)</span>.</p>
<h6><span id="第二定义">第二定义</span></h6>
<p>平面内一动点到定点与准线(<span class="math inline">\(x = \pm \frac{
a^2 }{ c }\)</span>)的距离比是常数<span class="math inline">\(e = \frac{
c }{ a }\)</span>的点轨迹,即<span class="math inline">\(\{ P \mid \frac{
| PF_1 | }{ d_1 } = \frac{ | PF_2 | }{ d_2 } = \frac{ c }{ a } = e , F_1
( - c , 0 ) , F_2 ( c , 0 ) \}\)</span>.</p>
<h6><span id="第三定义">第三定义</span></h6>
<p>平面内一动点到两定点<span class="math inline">\(A_1 ( - a , 0 ) , A_2
( a , 0 )\)</span>的斜率乘积等于定值<span class="math inline">\(e^2 -
1\)</span>的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5>
<h6><span id="焦半径">焦半径</span></h6>
<p>若<span class="math inline">\(P ( x_0 , y_0 ) , ( x_0 &gt; 0
)\)</span>,则<span class="math inline">\(| PF_1 | = a +
ex_0\)</span>,<span class="math inline">\(| PF_2 | = - a +
ex_0\)</span>.</p>
<h6><span id="渐近线">渐近线</span></h6>
<p><span class="math inline">\(y = \pm \frac{ b }{ a } x\)</span>.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成<span class="math inline">\(0\)</span>得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6>
<p>即<span class="math inline">\(\bigtriangleup PF_1
F_2\)</span>,令<span class="math inline">\(\theta = \angle F_1
PF_2\)</span>,有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(S = \frac{ b^2 }{ \tan \frac{ \theta }{
2 } }\)</span>.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4>
<h5><span id="定义">定义</span></h5>
<h6><span id="第一定义">第一定义</span></h6>
<p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5>
<h6><span id="焦点弦">焦点弦</span></h6>
<p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线<span class="math inline">\(AB\)</span>为过<span class="math inline">\(y^2 = 2 px ( p &gt; 0 )\)</span>焦点的弦,<span class="math inline">\(A ( x_1 , y_1 ) , B ( x_2 , y_2
)\)</span>,倾斜角为<span class="math inline">\(\theta\)</span>,准线与<span class="math inline">\(x\)</span>轴交点为<span class="math inline">\(E (
- \frac{ p }{ 2 } , 0 )\)</span>,作<span class="math inline">\(AA_1\)</span>,<span class="math inline">\(BB_1\)</span>垂直于准线于<span class="math inline">\(A_1 , B_1\)</span>,则:</p>
<ol type="1">
<li><p><span class="math inline">\(| AF | = x_1 + \frac{ p }{ 2
}\)</span>,<span class="math inline">\(| BF | = x_2 + \frac{ p }{ 2
}\)</span>,<span class="math inline">\(| AB | = x_1 + x_2 + p , \frac{ 1
}{ | FA | } + \frac{ 1 }{ | FB | } = \frac{ 2 }{ p }\)</span>.</p></li>
<li><p><span class="math inline">\(| AF | = \frac{ p }{ 1 - \cos \theta
} , | BF | = \frac{ p }{ 1 + \cos \theta } , | AB | = \frac{ 2 p }{
\sin^2 \theta }\)</span>.</p></li>
<li><p><span class="math inline">\(x_1 x_2 = \frac{ p^2 }{ 4
}\)</span>,<span class="math inline">\(y_1 y_2 = -
p^2\)</span>.</p></li>
<li><p><span class="math inline">\(S_{ \bigtriangleup AOB } = \frac{ p^2
}{ 2 \sin \theta }\)</span>.</p></li>
<li><p><span class="math inline">\(k_{ AE } + k_{ BE } =
0\)</span>.</p></li>
<li><p><span class="math inline">\(A , O , B_1\)</span>三点共线,<span class="math inline">\(B , O , A_1\)</span>三点共线.</p></li>
<li><p>以<span class="math inline">\(AB\)</span>为直径的圆与抛物线的准线相切.</p></li>
<li><p>以<span class="math inline">\(A_1 B_1\)</span>为直径的圆与<span class="math inline">\(AB\)</span>相切.</p></li>
<li><p>以<span class="math inline">\(AF\)</span>或<span class="math inline">\(BF\)</span>为直径的圆与<span class="math inline">\(y\)</span>轴相切.</p></li>
</ol>
<h4><span id="通用解法">通用解法</span></h4>
<h5><span id="联立方程">联立方程</span></h5>
<h6><span id="点参">点参</span></h6>
<p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线<span class="math inline">\(l\)</span>上有两点<span class="math inline">\(N ( x_1 , y_1 ) , M ( x_2 , y_2
)\)</span>,这条直线的斜率为<span class="math inline">\(k\)</span>,那么<span class="math inline">\(| NM |
= \sqrt{ 1 + k^2 } | x_1 - x_2 | = \sqrt{ 1 + \frac{ 1 }{ k^2 } } | y_1
- y_2 |\)</span>.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点<span class="math inline">\(A ( x_1 , y_1 ) , B ( x_2
, y_2 )\)</span>,其中点<span class="math inline">\(M ( x_0 , y_0
)\)</span>,有<span class="math inline">\(2 x_0 = x_1 + x_2 , 2 y_0 = y_1
+ y_2\)</span>.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线<span class="math inline">\(l\)</span>与曲线交于两点<span class="math inline">\(N ( x_1 , y_1 ) , M ( x_2 , y_2
)\)</span>,这条直线的斜率为<span class="math inline">\(k\)</span>,<span class="math inline">\(MN\)</span>的中点为<span class="math inline">\(P (
x_0 , y_0 )\)</span>,那么:</p>
<ol type="1">
<li><p>在椭圆<span class="math inline">\(\frac{ x^2 }{ a^2 } + \frac{
y^2 }{ b^2 } = 1 ( a &gt; b &gt; 0 )\)</span>中,<span class="math inline">\(k \frac{ y_0 }{ x_0 } = - \frac{ b^2 }{ a^2 } =
e^2 - 1\)</span>.</p></li>
<li><p>在双曲线<span class="math inline">\(\frac{ x^2 }{ a^2 } - \frac{
y^2 }{ b^2 } = 1\)</span>中,<span class="math inline">\(k \frac{ y_0 }{
x_0 } = \frac{ b^2 }{ a^2 } = e^2 - 1\)</span>.</p></li>
<li><p>在抛物线<span class="math inline">\(y^2 = 2 px ( p &gt; 0
)\)</span>中,<span class="math inline">\(k = \frac{ p }{ y_0 } = \frac{
x_0 }{ p }\)</span>.</p></li>
</ol>
<h6><span id="小联立">小联立</span></h6>
<p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6>
<p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线<span class="math inline">\(PA\)</span>,<span class="math inline">\(PB\)</span>,我们可以将公共点<span class="math inline">\(P\)</span>平移至原点,这样<span class="math inline">\(PA\)</span>和<span class="math inline">\(PB\)</span>的方程都方便表达.然后设<span class="math inline">\(AB\)</span>的方程为<span class="math inline">\(mx
+ ny = 1\)</span>(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以<span class="math inline">\(mx + ny\)</span>,零次项乘以<span class="math inline">\(( mx + ny
)^2\)</span>,这样就得到了一个齐次式子.将两边同时除以<span class="math inline">\(x^2\)</span>后就得到了一个和<span class="math inline">\(k = \frac{ y }{ x }\)</span>有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的<span class="math inline">\(x_1
x_2\)</span>和<span class="math inline">\(x_1 +
x_2\)</span>之间的关系来做.</p>
<p>当然还有一种情况是问形如<span class="math inline">\(\frac{ Ax_1 +
Bx_2 }{ Cx_1 + Dx_2 }\)</span>是定值的问题,这个时候一定有<span class="math inline">\(\frac{ A }{ C } = \frac{ B }{ D }\)</span>.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令<span class="math inline">\(w
= \frac{ x_1 }{ x_2 }\)</span>,自然有<span class="math inline">\(w +
\frac{ 1 }{ w } + 2 = \frac{ ( x_1 + x_2 )^2 }{ x_1 x_2 }\)</span>.</p>
<p>还比如有<span class="math inline">\(y_2 = ny_1 +
m\)</span>,我们可以用配凑技巧改写作<span class="math inline">\(( y_2 + w
) = k ( y_1 + w )\)</span>,也就有<span class="math inline">\(\frac{ y_2
+ w }{ y_1 + w } = k\)</span>,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线<span class="math inline">\(y = kx +
\varphi\)</span>与曲线<span class="math inline">\(\frac{ x^2 }{ m } +
\frac{ y^2 }{ n } = 1\)</span>相交于<span class="math inline">\(A ( x_1
, y_1 )\)</span>和<span class="math inline">\(B ( x_2 , y_2
)\)</span>.</p>
<p>那么联立方程是:<span class="math inline">\(( n + mk^2 ) x^2 + 2 k
\varphi mx + m ( \varphi^2 - n ) = 0\)</span>.</p>
<p>判别式:<span class="math inline">\(\Delta = 4 mn ( n + mk^2 -
\varphi^2 )\)</span>.</p>
<p>韦达定理:</p>
<p><span class="math display">\[
\begin{aligned}
x_1 + x_2 &amp; = \frac{ - 2 km \varphi }{ n + mk^2 } \\
x_1 x_2 &amp; = \frac{ m ( \varphi^2 - n ) }{ n + mk^2 } \\
| x_1 - x_2 | &amp; = \frac{ \sqrt{ \Delta } }{ n + mk^2 }
\end{aligned}
\]</span></p>
<h6><span id="配凑法">配凑法</span></h6>
<p>参考:https://zhuanlan.zhihu.com/p/521025768.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6>
<p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线<span class="math inline">\(y^2 = 4 x\)</span>,若<span class="math inline">\(A , B\)</span>位于抛物线上<span class="math inline">\(x\)</span>轴上方不同的两点,直线<span class="math inline">\(OA , OB\)</span>的斜率分别为<span class="math inline">\(k_1 , k_2\)</span>,且满足<span class="math inline">\(k_1 k_2 - 4 = 4 k_1 + 4 k_2\)</span>,求证:<span class="math inline">\(AB\)</span>过定点,并求出<span class="math inline">\(k_{ AB }\)</span>的取值范围.</p>
<p>注意到<span class="math inline">\(k_1\)</span>和<span class="math inline">\(k_2\)</span>之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设<span class="math inline">\(AB : y = kx + b\)</span>,则<span class="math inline">\(A ( x_1 , kx_1 + b ) , B ( x_2 , kx_2 + b
)\)</span>,显然<span class="math inline">\(k_1 = k + \frac{ b }{ x_1 } ,
k_2 = k + \frac{ b }{ x_2 }\)</span>.</p>
<p>直接带入方程,有:</p>
$$
<span class="math display">\[\begin{aligned}
( k + \frac{ b }{ x_1 } ) ( k + \frac{ b }{ x_2 } ) - 4 &amp; = 4 ( 2 k
+ \frac{ b }{ x_1 } + \frac{ b }{ x_2 } ) \\
k^2 + kb ( \frac{ 1 }{ x_1 } + \frac{ 1 }{ x_2 } ) + \frac{ b^2 }{ x_1
x_2 } - 4 &amp; = 8 k + 4 b ( \frac{ 1 }{ x_1 } + \frac{ 1 }{ x_2 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而直接大联立得到的式子是:</p>
<p><span class="math display">\[
\begin{aligned}
k^2 x^2 + ( 2 kb - 4 ) x + b^2 &amp; = 0 \\
\Delta &amp; = 16 - 16 kb &gt; 0 , kb &lt; 1 \\
x_1 x_2 &amp; = \frac{ b^2 }{ k^2 } , x_1 + x_2 = \frac{ 4 - 2 kb }{ k^2
} , \frac{ 1 }{ x_1 } + \frac{ 1 }{ x_2 } = \frac{ 4 - 2 kb }{ b^2 }
\end{aligned}
\]</span></p>
<p>带入,得到<span class="math inline">\(k - b =
4\)</span>,因此过定点<span class="math inline">\(( - 1 , - 4
)\)</span>,与<span class="math inline">\(kb &lt; 1\)</span>联立得到<span class="math inline">\(k &lt; 2 + \sqrt{ 5 }\)</span>.</p>
<p>还没完,这种题一定要检查一遍条件.注意到<span class="math inline">\(AB\)</span>为<span class="math inline">\(x\)</span>轴上方两点的性质没用到,这意味着<span class="math inline">\(y_1 y_2 &gt; 0 \land y_1 + y_2 &gt;
0\)</span>,带入方程得到:</p>
<p><span class="math display">\[
\begin{aligned}
b^2 + b ( \frac{ 4 - 2 kb }{ k } ) + b^2 &amp; &gt; 0 \\
\frac{ 4 - 2 kb }{ k } + 2 b &amp; &gt; 0
\end{aligned}
\]</span></p>
<p>化简得到<span class="math inline">\(\begin{cases}b &gt; 0 \\ k &gt;
0\end{cases}\)</span>,解得<span class="math inline">\(k &gt;
4\)</span>,于是<span class="math inline">\(k \in ( 4 , 2 + \sqrt{ 5 }
)\)</span>.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,<span class="math inline">\(OA\)</span>和<span class="math inline">\(OB\)</span>的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<p><span class="math display">\[
\begin{aligned}
k_{ OA } &amp; = \frac{ y_1 }{ x_1 } , k_{ OB } = \frac{ y_2 }{ x_2 } \\
\frac{ y_1 y_2 }{ x_1 x_2 } - 4 &amp; = 4 ( \frac{ y_1 }{ x_1 } + \frac{
y_2 }{ x_2 } ) \\
16 - 4 y_1 y_2 &amp; = 16 ( y_1 + y_2 )
\end{aligned}
\]</span></p>
<p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; AB : \\
x - x_1 = &amp; ( y - y_1 ) \frac{ x 1 - x_2 }{ y_1 - y_2 } \\
x - \frac{ y_1^2 }{ 4 } = &amp; ( y - y_1 ) \frac{ 1 }{ 4 } ( y_1 + y_2
) \\
x = &amp; \frac{ y_1 + y_2 }{ 4 } y - \frac{ y_1 y_2 }{ 4 } \\
x = &amp; \frac{ y_1 + y_2 }{ 4 } y - 1 + ( y_1 + y_2 )
\end{aligned}
\]</span></p>
<p>显然过定点<span class="math inline">\(( - 1 , - 4
)\)</span>,并且通过<span class="math inline">\(y_1\)</span>和<span class="math inline">\(y_2\)</span>的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个<span class="math inline">\(\frac{ x - x_1 }{ x_1 - x_2 } = \frac{ y - y_1 }{
y_1 - y_2
}\)</span>的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ 4 } + y^2 =
1\)</span>,<span class="math inline">\(P , Q\)</span>在椭圆上,<span class="math inline">\(A ( 2 , 0 )\)</span>,<span class="math inline">\(k_{ AP } k_{ AQ } = \frac{ 1 }{ 20
}\)</span>,求证:<span class="math inline">\(PQ\)</span>过定点.</p>
<p>注意到<span class="math inline">\(A ( 2 , 0 )\)</span>,设<span class="math inline">\(P ( x_1 , y_1 ) , Q ( x_2 , y_2 )\)</span>,<span class="math inline">\(PQ : m ( x - 2 ) + yn =
1\)</span>,那么我们要求的也就是<span class="math inline">\(x -
2\)</span>和<span class="math inline">\(y\)</span>之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然<span class="math inline">\(\frac{ x^2
}{ 4 } + y^2 = 1 \Rightarrow \frac{ ( x - 2 )^2 }{ 4 } + ( x - 2 ) + y^2
= 0\)</span>.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令<span class="math inline">\(x &#39; = x - 2 , y
&#39; = y\)</span>,我们有<span class="math inline">\(x = x &#39; + 2 , y
= y &#39;\)</span>,带入就可以得到关于<span class="math inline">\(x &#39;
, y &#39;\)</span>的方程,然后再带回<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>就行.</p>
<p>我们开始推导:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ ( x - 2 )^2 }{ 4 } + ( x - 2 ) + y^2 = 0 \\
( x - 2 )^2 + 4 ( x - 2 ) + 4 y^2 = 0 \\
( x - 2 )^2 + 4 n ( x - 2 )^2 + 4 my ( x - 2 ) + 4 y^2 = 0 \\
( 4 n + 1 ) ( x - 2 )^2 + 4 my ( x - 2 ) + 4 y^2 = 0 \\
4 n + 1 + 4 m \frac{ y }{ x - 2 } + 4 ( \frac{ y }{ x - 2 } )^2 = 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(k = \frac{ y }{ x - 2
}\)</span>,也就得到了<span class="math inline">\(4 n + 1 + 4 mk + 4 k^2
= 0\)</span>.用一遍韦达定理,有:<span class="math inline">\(k_1 k_2 =
\frac{ 4 n + 1 }{ 4 } = \frac{ 1 }{ 20 } , n = - \frac{ 1 }{ 5
}\)</span>.</p>
<p>也就有:<span class="math inline">\(PQ : - \frac{ 1 }{ 5 } ( x - 2 ) +
my = 1\)</span>,显然过定点<span class="math inline">\(( - 3 , 0
)\)</span>.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ 9 } + y^2 =
1\)</span>,<span class="math inline">\(P ,
Q\)</span>是该椭圆上两动点,<span class="math inline">\(M ,
N\)</span>分别为<span class="math inline">\(P , Q\)</span>在<span class="math inline">\(x\)</span>轴上的射影,而且<span class="math inline">\(k_{ OP } k_{ OQ } = - 1\)</span>,记<span class="math inline">\(S = S_{ \bigtriangleup OPM } + S_{ \bigtriangleup
OQN }\)</span>,求<span class="math inline">\(S\)</span>的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线<span class="math inline">\(PQ\)</span>很重要的时候,而这个题除了<span class="math inline">\(P , Q\)</span>两点以外,和<span class="math inline">\(PQ\)</span>半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设<span class="math inline">\(P ( x_1 , y_1 ) , Q ( x_2 , y_2
)\)</span>,<span class="math inline">\(k = \frac{ y_1 }{ x_1 } , -
\frac{ 1 }{ k } = \frac{ y_2 }{ x_2 }\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
2 S &amp; = | x_1 y_1 | + | x_2 y_2 | \\
&amp; = | x_1^2 k - \frac{ 1 }{ k } x_2^2 | \\

\end{aligned}\]</span>
<p>$$</p>
<p>而联立方程,有:</p>
<p><span class="math display">\[
x_1^2 = \frac{ 1 }{ \frac{ 1 }{ 9 } + k } , x_2^2 = \frac{ 1 }{ \frac{ 1
}{ 9 } - \frac{ 1 }{ k } }
\]</span></p>
<p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线<span class="math inline">\(PQ\)</span>有两个未知量,我们还需要拿<span class="math inline">\(k_{ OP } k_{ OQ } = -
1\)</span>限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ 2 } + y^2 =
1\)</span>,<span class="math inline">\(F ( 1 , 0 )\)</span>,直线<span class="math inline">\(l\)</span>过<span class="math inline">\(F\)</span>且交椭圆于<span class="math inline">\(A
, B\)</span>两点.求问:<span class="math inline">\(x\)</span>轴上是否存在异于<span class="math inline">\(F\)</span>的一点<span class="math inline">\(Q\)</span>,使得<span class="math inline">\(\frac{
k_{ QA } }{ k_{ QB } }\)</span>是定值.</p>
<p>直接设<span class="math inline">\(AB : x = ky + 1\)</span>,<span class="math inline">\(Q ( q , 0 )\)</span>.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ k_{ QA } }{ k_{ QB } } &amp; = \frac{ y_1 ( q - x_2 ) }{ y_2 ( q
- x_1 ) } \\
&amp; = - \frac{ ky_1 y_2 + y_1 - qy_1 }{ ky_1 y_2 + y_2 - qy_2 }
\end{aligned}
\]</span></p>
<p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
$$
<span class="math display">\[\begin{aligned}
( k^2 + 2 ) y^2 + 2 ky - 1 &amp; = 0 \\
\Delta &amp; = 8 k^2 + 8 &gt; 0 \\
y_1 + y_2 &amp; = - \frac{ 2 k }{ k^2 + 2 } \\
y_1 y_2 &amp; = - \frac{ 1 }{ k^2 + 2 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(\frac{ ( y_1 + y_2 ) }{ 2 } = k (
y_1 y_2 )\)</span>,代入,有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ k_{ QA } }{ k_{ QB } } &amp; = - \frac{ y_1 + y_2 + 2 y_1 - 2
qy_1 }{ y_1 + y_2 + 2 y_2 - 2 qy_2 } \\
&amp; = - \frac{ ( 3 - 2 q ) y_1 + y_2 }{ ( 3 - 2 q ) y_2 + y_1 }
\end{aligned}
\]</span></p>
<p>若是定值,那么就有:<span class="math inline">\(\frac{ 3 - 2 q }{ 1 } =
\frac{ 1 }{ 3 - 2 q }\)</span>,解得<span class="math inline">\(q_1 = 1 (
F )\)</span>,<span class="math inline">\(q_2 = 2 ( Q )\)</span>.</p>
<p>所以<span class="math inline">\(Q ( 2 , 0 )\)</span>.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ 4 } + \frac{ y^2 }{
3 } = 1\)</span>,过<span class="math inline">\(F ( - 1 , 0
)\)</span>的直线交椭圆于<span class="math inline">\(M ,
N\)</span>两点,过<span class="math inline">\(M\)</span>作直线<span class="math inline">\(x = - 4\)</span>的垂线,垂足为<span class="math inline">\(E\)</span>,求证:<span class="math inline">\(EN\)</span>过定点.</p>
<p>根据对称原理,显然这个定点一定在<span class="math inline">\(x\)</span>轴上.</p>
<p>我们先写大联立的式子:设<span class="math inline">\(MN : x = - 1 +
ky\)</span>,带入有<span class="math inline">\(( 3 m^2 + 4 ) y^2 - 6 my -
9 = 0\)</span>.再设<span class="math inline">\(M ( x_1 , y_1 ) , N ( x_2
, y_2 )\)</span>,自然有:</p>
<p><span class="math display">\[
\begin{cases}
\Delta = 144 k^2 + 144 \\
y_1 + y_2 = \frac{ 6 k }{ 3 k^2 + 4 } \\
y_1 y_2 = \frac{ - 9 }{ 3 k^2 + 4 }
\end{cases}
\]</span></p>
<p>接下来呢,我们想一下我们要求什么:我们要求出<span class="math inline">\(EN\)</span>的表达式:形如<span class="math inline">\(y - m = k ( x - n )\)</span>,然后声明<span class="math inline">\(( n , m )\)</span>是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有<span class="math inline">\(k = \frac{ y - m }{ x - n
}\)</span>.而我们现在有两个点<span class="math inline">\(E ( - 4 , y_1
)\)</span>和<span class="math inline">\(N ( x_2 , y_2
)\)</span>,又猜出<span class="math inline">\(m =
0\)</span>,也就是我们要找到一个<span class="math inline">\(n\)</span>满足<span class="math inline">\(\frac{
y_1 }{ - 4 - n } = \frac{ y_2 }{ x_2 - n }\)</span>.</p>
<p>我们倒着推:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ y_1 }{ - 4 - n } &amp; = \frac{ y_2 }{ x_2 - n } \\
\frac{ y_1 }{ - 4 - n } &amp; = \frac{ y_2 }{ ky_2 - 1 - n }
\end{aligned}
\]</span></p>
<p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
ky_1 y_2 + \frac{ 3 }{ 2 } ( y_1 + y_2 ) &amp; = 0 \\
( x_2 + \frac{ 5 }{ 2 } ) y_1 &amp; = - \frac{ 3 }{ 2 } y_2 \\
y_1 &amp; = \frac{ - 3 }{ 2 } \frac{ y_2 }{ x_2 + \frac{ 5 }{ 2 } } \\
\frac{ y_1 }{ - \frac{ 3 }{ 2 } } &amp; = \frac{ y_2 }{ x_2 + \frac{ 5
}{ 2 } } \\
\frac{ y_1 }{ - 4 + \frac{ 5 }{ 2 } } &amp; = \frac{ y_2 }{ x_2 + \frac{
5 }{ 2 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做到这一步发现要做完了,不难发现<span class="math inline">\(n = \frac{
5 }{ 2 }\)</span>.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了<span class="math inline">\(m =
0\)</span>了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5>
<h6><span id="定义">定义</span></h6>
<p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点<span class="math inline">\(P\)</span>作直线<span class="math inline">\(l\)</span>交二次曲线于<span class="math inline">\(M , N\)</span>两点(离<span class="math inline">\(P\)</span>近的是<span class="math inline">\(M\)</span>),则在<span class="math inline">\(l\)</span>上有且只有一点<span class="math inline">\(Q\)</span>,使得<span class="math inline">\(| MQ |
| NP | = | MP | | NQ |\)</span>(即<span class="math inline">\(P , Q , M
, N\)</span>构成一调和点列).当<span class="math inline">\(l\)</span>绕着<span class="math inline">\(P\)</span>旋转时,<span class="math inline">\(Q\)</span>的轨迹是一条直线<span class="math inline">\(p\)</span>(或一部分),这条直线<span class="math inline">\(p\)</span>叫做点<span class="math inline">\(P\)</span>关于二次曲线的极线,而<span class="math inline">\(P\)</span>叫做<span class="math inline">\(p\)</span>关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:<span class="math inline">\(p : \frac{
x_0 x }{ a^2 } + \frac{ y_0 y }{ b^2 } = 1\)</span>.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线<span class="math inline">\(C : Ax^2 + Bxy + Cy^2 +
Dx + Ey + F = 0\)</span>上的一点<span class="math inline">\(P ( x_0 ,
y_0 )\)</span>,我们称它的极线为<span class="math inline">\(p : Axx_0 + B
\frac{ x_0 y + y_0 x }{ 2 } + Cyy_0 + D \frac{ x + x_0 }{ 2 } + E \frac{
y + y_0 }{ 2 } + F = 0\)</span>.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6>
<p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线<span class="math inline">\(C\)</span>,如果点<span class="math inline">\(P\)</span>的极线经过点<span class="math inline">\(Q\)</span>,那么点<span class="math inline">\(Q\)</span>的极线经过点<span class="math inline">\(P\)</span>.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol type="1">
<li><p>设四边形<span class="math inline">\(ABCD\)</span>(对边不平行)内接于二次曲线<span class="math inline">\(C\)</span>,则对角线交点<span class="math inline">\(P\)</span>的极线是两组对边交点的连线.反之同理,若<span class="math inline">\(P\)</span>在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p></li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p></li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p></li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6>
<p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知<span class="math inline">\(\frac{ \cos \theta }{ a } + \frac{
\sin \theta }{ b } = 1\)</span>,求证:<span class="math inline">\(\frac{
1 }{ a^2 } + \frac{ 1 }{ b^2 } \geq 1\)</span>.</p>
<p>设直线<span class="math inline">\(l : \frac{ x }{ a } + \frac{ y }{ b
} = 1\)</span>,<span class="math inline">\(M ( \cos \theta , \sin \theta
)\)</span>,则<span class="math inline">\(M\)</span>在<span class="math inline">\(l\)</span>上.</p>
<p>又注意到<span class="math inline">\(M\)</span>显然是在单位圆上,而<span class="math inline">\(l\)</span>是单位圆关于<span class="math inline">\(P ( \frac{ 1 }{ a } , \frac{ 1 }{ b }
)\)</span>的极点.又注意到<span class="math inline">\(l\)</span>与单位圆至少有一个交点,因此<span class="math inline">\(P\)</span>要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ 4 } + \frac{ y^2 }{
3 } = 1\)</span>,<span class="math inline">\(A_1 ( - 2 , 0 ) , A_2 ( 2 ,
0 ) , D ( \frac{ 1 }{ 2 } , 0 )\)</span>,过<span class="math inline">\(D\)</span>的直线交椭圆于<span class="math inline">\(P , Q\)</span>两点(不与<span class="math inline">\(A_1 , A_2\)</span>重合).<span class="math inline">\(A_1 P \cap A_2 Q = M\)</span>,<span class="math inline">\(A_1 Q \cap A_2 P = N\)</span>,设<span class="math inline">\(k_1 = k_{ A_1 P } , k_2 = k_{ A_1 Q
}\)</span>.求证:<span class="math inline">\(k_1
k_2\)</span>是定值,求出这个定值并求出<span class="math inline">\(\bigtriangleup DMN\)</span>面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知<span class="math inline">\(MN :
x = 8\)</span>.</p>
<p>我们先来看已知<span class="math inline">\(MN : x =
8\)</span>之后怎么做:</p>
<p>设<span class="math inline">\(P ( x_1 , y_1 ) , Q ( x_2 , y_2
)\)</span>,再设<span class="math inline">\(PQ : x = ky + \frac{ 1 }{ 2
}\)</span>,则:<span class="math inline">\(k_1 k_2 = \frac{ y_1 }{ x_1 +
2 } \frac{ y_2 }{ x_2 + 2 }\)</span>,不难算出<span class="math inline">\(k_1 k_2 = - \frac{ 9 }{ 20 }\)</span>.</p>
<p>此时<span class="math inline">\(S_{ \bigtriangleup DMN } = | MN | | 8
- \frac{ 1 }{ 2 } | \frac{ 1 }{ 2 }\)</span>.不难发现只需求出<span class="math inline">\(| MN |_{ \min }\)</span>即可.而<span class="math inline">\(MN \bot x\)</span>轴,所以<span class="math inline">\(| MN | = | y_M - y_N |\)</span>.</p>
<p>接下来咋做?第一问求得<span class="math inline">\(k_1\)</span>和<span class="math inline">\(k_2\)</span>的关系不能白求啊!</p>
<p>我们有<span class="math inline">\(A_1 P : x = - 2 + \frac{ 1 }{ k_1 }
y , A_1 Q : x = - 2 + \frac{ 1 }{ k_2 } y\)</span>,带入<span class="math inline">\(x = 8\)</span>,求得<span class="math inline">\(y_M
= 10 k_1 , y_N = 10 k_2\)</span>.</p>
<p>于是<span class="math inline">\(| MN | = 10 | k_1 - k_2
|\)</span>.注意到<span class="math inline">\(k_1 &gt; 0 \land - k_2 &gt;
0 \land k_1 ( - k_2 ) = \frac{ 9 }{ 20
}\)</span>,显然可以用基本不等式计算,最后得到<span class="math inline">\(S_{ \min } = \frac{ 45 \sqrt{ 5 } }{ 2
}\)</span>.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出<span class="math inline">\(A_1 Q : x = - 2 +
\frac{ y_2 }{ x_2 + 2 } y , A_2 P : x = 2 + \frac{ y_1 }{ x_1 - 2 }
y\)</span>,然后我们声明这两条直线的交点的横坐标一定是<span class="math inline">\(8\)</span>,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5>
<p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是<span class="math inline">\(\frac{ x^2
}{ a^2 } + \frac{ y^2 }{ b^2 } = 1\)</span>.</p>
<p>我们将<span class="math inline">\(y\)</span>看作<span class="math inline">\(x\)</span>的函数,对两边求导,自然得到:</p>
<p><span class="math display">\[
\frac{ 2 x }{ a^2 } + \frac{ 2 yy &#39; }{ b^2 } = 0
\]</span></p>
<p>这是个方程,你可以解得<span class="math inline">\(y &#39; = - \frac{
b^2 x }{ a^2 y }\)</span>.而这就是椭圆过<span class="math inline">\(( x
, y )\)</span>这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5>
<p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6>
<p>向量<span class="math inline">\(\vec{ b } = ( x , y
)\)</span>逆时针旋转<span class="math inline">\(\theta\)</span>后得到的答案是<span class="math inline">\(A \vec{ b }\)</span>,其中</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>你要不喜欢矩阵表示也不是不行,那向量<span class="math inline">\(( x ,
y )\)</span>旋转<span class="math inline">\(\theta\)</span>得到<span class="math inline">\(( x &#39; , y &#39; )\)</span>,其中</p>
<p>y’=xsin+ycos</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6>
<p>我们注意到圆的方程是<span class="math inline">\(( x &#39; )^2 + ( y
&#39; )^2 = 1\)</span>,而椭圆的方程形如<span class="math inline">\(\frac{ x^2 }{ a^2 } + \frac{ y^2 }{ b^2 } =
1\)</span>.</p>
<p>我们注意到上面的式子等价于:<span class="math inline">\(( \frac{ x }{
a } )^2 + ( \frac{ y }{ b } )^2 =
1\)</span>.我们将原坐标系中的所有坐标<span class="math inline">\(( x , y
)\)</span>全部变成<span class="math inline">\(( \frac{ x }{ a } , \frac{
y }{ b }
)\)</span>之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令<span class="math inline">\(\vec{ f } = ( x , y
)\)</span>满足椭圆方程,令<span class="math inline">\(\vec{ g } = ( x
&#39; , y &#39; )\)</span>满足圆的方程,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
\begin{bmatrix}
\frac{ 1 }{ a } , 0 \\
0 , \frac{ 1 }{ b }
\end{bmatrix} \vec{ f } &amp; = \vec{ g } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{bmatrix}
a , 0 \\
0 ,{ b }
\end{bmatrix} \vec{ g } = \vec{ f }
\]</span></p>
<h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6>
<p>注意到反比例函数的方程是<span class="math inline">\(x &#39; y &#39; =
1\)</span>,而双曲线的方程是<span class="math inline">\(\frac{ x^2 }{ a^2
} - \frac{ y^2 }{ b^2 } = 1\)</span>.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
<p>首先先转化为<span class="math inline">\(x^2 - y^2 =
2\)</span>的形式,需要左乘矩阵<span class="math inline">\(\begin{bmatrix}\frac{ \sqrt{ 2 } }{ a } , 0 \\ 0 ,
\frac{ \sqrt{ 2 } }{ b }\end{bmatrix}\)</span>.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转<span class="math inline">\(\frac{ \pi }{ 4 }\)</span>了.旋转矩阵为</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>,-\</p>
<p>,</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有<span class="math inline">\(x &#39; = \frac{ x }{ a }
- \frac{ y }{ b } , y &#39; = \frac{ x }{ a } + \frac{ y }{ b
}\)</span>.带入反比例函数的方程:</p>
<p><span class="math display">\[
x &#39; y &#39; = \frac{ x^2 }{ a^2 } - \frac{ y^2 }{ b^2 } = 1
\]</span></p>
<p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>,\</p>
<p>-,</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有<span class="math inline">\(x = \frac{ a }{ 2 } ( x
&#39; + y &#39; ) , y = \frac{ b }{ 2 } ({ y &#39; - x &#39; }
)\)</span>,带入双曲线方程得到:</p>
<p><span class="math display">\[
\begin{aligned}
( \frac{ x }{ a } )^2 - ( \frac{ y }{ b } )^2 &amp; = 1 \\
( x &#39; + y &#39; )^2 - ( x &#39; - y &#39; )^2 &amp; = 4 \\
x &#39; y &#39; &amp; = 1
\end{aligned}
\]</span></p>
<p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6>
<p>这个比较简单,交换<span class="math inline">\(x ,
y\)</span>即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5>
<p>平面内取一点<span class="math inline">\(O\)</span>为极点,引一条射线<span class="math inline">\(Ox\)</span>叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点<span class="math inline">\(M\)</span>,令<span class="math inline">\(\rho = | OM |\)</span>,<span class="math inline">\(\theta\)</span>为以<span class="math inline">\(Ox\)</span>为始边,沿角度正方向(一般是逆时针方向)转到<span class="math inline">\(OM\)</span>的夹角.那么我们称<span class="math inline">\(( \rho , \theta )\)</span>为<span class="math inline">\(M\)</span>的极坐标,其中<span class="math inline">\(\rho\)</span>叫做极径,<span class="math inline">\(\theta\)</span>叫做极角.</p>
<p><span class="math inline">\(\rho\)</span>有可能取负,我们通常认为<span class="math inline">\(( - \rho , \theta ) = ( \rho , \theta + \pi
)\)</span>.</p>
<p>通常情况下默认<span class="math inline">\(0 \leq \theta &lt; 2 \pi ,
\rho \geq
0\)</span>.如果遇到和直角坐标系结合的问题,通常默认原点为极点,<span class="math inline">\(x\)</span>轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若<span class="math inline">\(M\)</span>在直角坐标系中坐标为<span class="math inline">\(( x , y )\)</span>,在极坐标中坐标为<span class="math inline">\(( \rho , \theta )\)</span>,若<span class="math inline">\(M \ne O\)</span>自然有:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = \rho \cos \theta , y = \rho \sin \theta \\
\rho^2 &amp; = x^2 + y^2 , \theta = \begin{cases}
\frac{ \pi }{ 2 } &amp; x = 0 \land y &gt; 0 \\
\frac{ 3 \pi }{ 2 } &amp; x = 0 \land y &lt; 0 \\
\arctan ( \frac{ y }{ x } ) &amp; x \ne 0
\end{cases}
\end{aligned}
\]</span></p>
<p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6>
<p>显然是<span class="math inline">\(\rho^2 = r^2\)</span>.</p>
<p>另外,如果中心在<span class="math inline">\(C ( \rho_0 , \theta_0
)\)</span>,半径为<span class="math inline">\(r\)</span>的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
r^2 &amp; = ( \rho \cos \theta - \rho_0 \cos \theta_0 )^2 + ( \rho \sin
\theta - \rho_0 \sin \theta_0 ) \\
r^2 &amp; = \rho^2 + \rho_0^2 - 2 \rho \rho_0 \cos \theta \cos \theta_0
- 2 \rho \rho_0 \sin \theta \sin \theta_0 \\
r^2 &amp; = \rho^2 + \rho_0^2 - 2 \rho \rho_0 \cos ( \theta - \theta_0 )
\end{aligned}
\]</span></p>
<p>另外由于<span class="math inline">\(\cos \theta = \cos ( - \theta
)\)</span>,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6>
<p>过定点<span class="math inline">\(( \rho_1 , \theta_1
)\)</span>,且倾斜角为<span class="math inline">\(\alpha\)</span>:<span class="math inline">\(\rho \sin ( \alpha - \theta ) = \rho_1 \sin (
\alpha - \theta_1 )\)</span>.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点<span class="math inline">\(( x_1 , y_1 )\)</span>,倾斜角为<span class="math inline">\(\alpha\)</span>,我们自然有<span class="math inline">\(( x - x_1 ) \sin \alpha = ( y - y_1 ) \cos
\alpha\)</span>.</p>
<p>于是有:</p>
<p><span class="math display">\[
\begin{aligned}
( x - x_1 ) \sin \alpha &amp; = ( y - y_1 ) \cos \alpha \\
( \rho \cos \theta - \rho_1 \cos \theta_1 ) \sin \alpha &amp; = ( \rho
\sin \theta - \rho_1 \sin \theta_1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) &amp; = \rho_1 \sin ( \alpha - \theta_1 )
\end{aligned}
\]</span></p>
<p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点<span class="math inline">\(( \rho_1 ,
\theta_1 )\)</span>和<span class="math inline">\(( \rho_2 , \theta_2
)\)</span>的直线方程.</p>
<p>同理的:</p>
<p><span class="math display">\[
\begin{aligned}
( x - x_1 ) ( y_2 - y_1 ) &amp; = ( y - y_1 ) ( x_2 - x_1 ) \\
\\
( \rho \cos \theta - \rho_1 \cos \theta_1 ) ( \rho_2 \sin \theta_2 -
\rho_1 \sin \theta_1 ) \\
&amp; = ( \rho_2 \cos \theta_2 - \rho_1 \cos \theta_1 ) ( \rho \sin
\theta - \rho_1 \sin \theta_1 ) \\
\\
\rho \rho_2 ( \cos \theta \sin \theta_2 - \cos \theta_2 \sin \theta ) \\
+ \rho \rho_1 ( - \cos \theta \sin \theta_1 + \sin \theta \cos \theta_1
) \\
+ \rho_1 \rho_2 ( - \cos \theta_1 \sin \theta_2 + \cos \theta_2 \sin
\theta_1 ) \\
&amp; = 0 \\
\\
\rho \rho_2 \sin ( \theta_2 - \theta ) + \rho \rho_1 \sin ( \theta -
\theta_1 ) + \rho_1 \rho_2 \sin ( \theta_1 - \theta_2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6>
<p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离<span class="math inline">\(d\)</span>和到定点距离<span class="math inline">\(r\)</span>之比为常数的曲线.令<span class="math inline">\(e = \frac{ r }{ d }\)</span>.</p>
<p>假定定点为原点,极轴垂直于准线,<span class="math inline">\(h\)</span>为定点到准线的距离,又设曲线上一点为<span class="math inline">\(M ( \rho , \theta )\)</span>,自然有:<span class="math inline">\(r = \rho , d = h + \rho \cos \theta\)</span>.</p>
<p>于是有:</p>
<p><span class="math display">\[
\begin{aligned}
e &amp; = \frac{ \rho }{ h + \rho \cos \theta } \\
he + e \rho \cos \theta &amp; = \rho \\
\rho &amp; = \frac{ he }{ 1 - e \cos \theta }
\end{aligned}
\]</span></p>
<p>值得一提的是这玩意不能将圆理解为<span class="math inline">\(e =
0\)</span>的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5>
<p>在平面直角坐标系中,曲线上任意一点的坐标<span class="math inline">\(x
, y\)</span>都是某个变量<span class="math inline">\(t\)</span>的函数<span class="math inline">\(\begin{cases}x = f ( t ) \\ y = g ( t
)\end{cases}\)</span>.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6>
<p><span class="math inline">\(M ( r \cos \theta , r \sin \theta
)\)</span>,其中<span class="math inline">\(\theta\)</span>是<span class="math inline">\(\angle OMx\)</span>.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6>
<p><span class="math inline">\(M ( x_0 + t \cos \theta , y_0 + t \sin
\theta )\)</span>,其中<span class="math inline">\(\theta\)</span>是倾斜角,<span class="math inline">\(t\)</span>是参数,<span class="math inline">\(M_0 (
x_0 , y_0 )\)</span>.</p>
<p>注意到<span class="math inline">\(| M_0 M | = | t
|\)</span>.事实上,设<span class="math inline">\(\vec{ e } = ( \cos
\theta , \sin \theta )\)</span>,也就是直线的单位方向向量,则<span class="math inline">\(\overrightarrow{ M_0 M } = t \vec{ e
}\)</span>.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6>
<p><span class="math inline">\(M ( a \cos \theta , b \sin \theta
)\)</span>,其中<span class="math inline">\(\theta\)</span>称为<span class="math inline">\(M\)</span>的离心角.</p>
<p>值得注意的是,这里的<span class="math inline">\(\theta\)</span>并非<span class="math inline">\(\angle
MOx\)</span>,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆<span class="math inline">\(\frac{ x^2 }{ 9 } + \frac{ y^2 }{ 4
} = 1\)</span>上求一点<span class="math inline">\(M\)</span>,使<span class="math inline">\(M\)</span>到直线<span class="math inline">\(x + 2
y - 10 = 0\)</span>的距离最小.</p>
<p>直接令<span class="math inline">\(M = ( 3 \cos \theta , 2 \sin \theta
)\)</span>,则<span class="math inline">\(d = \frac{ | 3 \cos \theta + 4
\sin \theta - 10 | }{ \sqrt{ 5 } } = | \sqrt{ 5 } \sin ( \theta +
\varphi ) - 2 \sqrt{ 5 } |\)</span>,其中<span class="math inline">\(\varphi = \arcsin \frac{ 3 }{ 5 }\)</span>.</p>
<p>于是<span class="math inline">\(d_{ \min } = \sqrt{ 5
}\)</span>,此时<span class="math inline">\(\sin ( \theta + \varphi ) = 1
= \sin{ \frac{ \pi }{ 2 } }\)</span>,那么就有<span class="math inline">\(\theta = \frac{ \pi }{ 2 } -
\varphi\)</span>,<span class="math inline">\(\sin \theta = \cos \varphi
= \frac{ 4 }{ 5 } , \cos \theta = \sin \varphi = \frac{ 3 }{ 5
}\)</span>.</p>
<p>则<span class="math inline">\(M = ( \frac{ 9 }{ 5 } , \frac{ 8 }{ 5 }
)\)</span>.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆<span class="math inline">\(\frac{ x^2 }{ 100 } + \frac{ y^2
}{ 64 } = 1\)</span>,有一内接矩阵<span class="math inline">\(ABCD\)</span>(<span class="math inline">\(AB / / x
, BC / / y\)</span>),求矩阵最大面积.</p>
<p>直接令<span class="math inline">\(A = ( 10 \cos \theta , 8 \sin
\theta )\)</span>,则<span class="math inline">\(S = 20 \cos \theta
\times 16 \sin \theta = 160 \sin ( 2 \theta )\)</span>,<span class="math inline">\(S_{ \max } = 160\)</span>.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6>
<p><span class="math inline">\(M ( \frac{ a }{ \cos \theta } , b \tan
\theta ) = M ( a \sec \theta , b \tan \theta )\)</span>,其中<span class="math inline">\(\theta\)</span>称为<span class="math inline">\(M\)</span>的离心角,通常规定<span class="math inline">\(\theta \in [ 0 , 2 \pi ] \land \theta \ne \frac{
\pi }{ 2 } \land \theta \ne \frac{ 3 \pi }{ 2 }\)</span>.</p>
<p>其实本质也就是三角恒等式<span class="math inline">\(\sec^2 \theta = 1
+ \tan^2 \theta\)</span>.</p>
<p><strong>Example1</strong></p>
<p>圆<span class="math inline">\(O : x^2 + ( y - 2 )^2 =
1\)</span>上有一点<span class="math inline">\(P\)</span>,双曲线<span class="math inline">\(x^2 - y^2 = 1\)</span>上有一点<span class="math inline">\(Q\)</span>,求<span class="math inline">\(| PQ |_{
\min }\)</span>.</p>
<p>设<span class="math inline">\(Q ( \sec \theta , \tan \theta
)\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
| OQ |^2 &amp; = \sec^2 \theta + ( \tan \theta - 2 )^2 \\
&amp; = \tan^2 \theta + 1 ( \tan \theta - 2 )^2 \\
&amp; = 2 ( \tan \theta - 1 )^2 + 3
\end{aligned}
\]</span></p>
<p><span class="math inline">\(| OQ |_{ \min } = \sqrt{ 3 } , | PQ |_{
\min } = \sqrt{ 3 } - 1\)</span>.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设<span class="math inline">\(P ( a \sec \theta , a \tan \theta ) , Q
( - a \sec \theta , a \tan \theta )\)</span>,则<span class="math inline">\(k_P = \frac{ a \tan \theta }{ a \sec \theta - a }
, k_Q = \frac{ a \tan \theta }{ - a \sec \theta - a
}\)</span>.注意到<span class="math inline">\(k_P \cdot k_Q = -
1\)</span>.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线<span class="math inline">\(\frac{ x^2 }{ a^2 } - \frac{
y^2 }{ b^2 } = 1\)</span>,<span class="math inline">\(A ,
B\)</span>是双曲线同支上相异两点,线段<span class="math inline">\(AB\)</span>的垂直平分线与<span class="math inline">\(x\)</span>轴相交于点<span class="math inline">\(P
( x_0 , 0 )\)</span>,求证:<span class="math inline">\(| x_0 | &gt;
\frac{ c^2 }{ a } = \frac{ a^2 + b^2 }{ a }\)</span>.</p>
<p>设<span class="math inline">\(A ( a \sec \alpha , b \tan \alpha ) , B
( a \sec \beta , b \tan \beta )\)</span>,则中点<span class="math inline">\(M ( \frac{ a }{ 2 } ( \sec \alpha + \sec \beta ) ,
\frac{ b }{ 2 } ( \tan \alpha + \tan \beta ) )\)</span>.</p>
<p>于是中垂线方程为<span class="math inline">\(y - \frac{ b }{ 2 } (
\tan \alpha + \tan \beta ) ) = - \frac{ a ( \sec \alpha - \sec \beta )
}{ b ( \tan \alpha - \tan \beta ) } [ x - \frac{ a }{ 2 } ( \sec \alpha
+ \sec \beta ) ]\)</span>.</p>
<p>代入<span class="math inline">\(P ( x_0 , 0 )\)</span>,求得<span class="math inline">\(x_0 = \frac{ c^2 }{ 2 a } ( \sec \alpha + \sec
\beta )\)</span>.</p>
<p>也就是要比较<span class="math inline">\(| \sec \alpha + \sec \beta
|\)</span>和<span class="math inline">\(2\)</span>的大小关系,注意到<span class="math inline">\(A , B\)</span>同支,所以<span class="math inline">\(| \sec \alpha + \sec \beta | &gt; 2\)</span>.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6>
<p><span class="math inline">\(M ( \frac{ 2 p }{ \tan^2 \theta } ,
\frac{ 2 p }{ \tan \theta } )\)</span>,其中<span class="math inline">\(\theta\)</span>称为<span class="math inline">\(M\)</span>的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:<span class="math inline">\(M (
2 pk^2 , 2 pk )\)</span>,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
<p>若抛物线<span class="math inline">\(\begin{cases}x = 2 pt^2 \\ y = 2
pt\end{cases}\)</span>上有不同两点<span class="math inline">\(M_1 ,
M_2\)</span>,所对应的参数分别是<span class="math inline">\(t_1 ,
t_2\)</span>,求直线<span class="math inline">\(M_1
M_2\)</span>所在直线的斜率.</p>
<p><span class="math inline">\(k_{ M_1 M_2 } = \frac{ 2 pt_1 - 2 pt_2 }{
2 pt_1^2 - 2 pt_2^2 } = \frac{ 1 }{ t_1 + t_2 }\)</span>.</p>
<p><strong>Example2</strong></p>
<p><span class="math inline">\(A , B\)</span>是抛物线<span class="math inline">\(y^2 = 2 px\)</span>上异于顶点的两动点,且<span class="math inline">\(OA \bot OB\)</span>,<span class="math inline">\(AB\)</span>上有一点<span class="math inline">\(M\)</span>满足<span class="math inline">\(OM \bot
AB\)</span>,求<span class="math inline">\(M\)</span>的轨迹方程.</p>
<p>设<span class="math inline">\(M ( x , y ) , A ( 2 pt_1^2 , 2 pt_1 ) ,
B ( 2 pt_2^2 , 2 pt_2 )\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow{ OM } &amp; = ( x , y ) \\
\overrightarrow{ OA } &amp; = ( 2 pt_1^2 , 2 pt_1 ) \\
\overrightarrow{ OB } &amp; = ( 2 pt_2^2 , 2 pt_2 ) \\
\overrightarrow{ AB } &amp; = ( 2 p ( t_2^2 - t_1^2 ) , 2 p ( t_2 - t_1
) )
\end{aligned}
\]</span></p>
<p>因为<span class="math inline">\(\overrightarrow{ OA } \bot
\overrightarrow{ OB }\)</span>,所以<span class="math inline">\(( 2 pt_1
t_2 )^2 + ( 2 p )^2 t_1 t_2 = 0\)</span>,<span class="math inline">\(t_1
t_2 = - 1\)</span>.</p>
<p>因为<span class="math inline">\(\overrightarrow{ AB } \bot
\overrightarrow{ OM }\)</span>,又有<span class="math inline">\(k_{ AB }
= \frac{ 1 }{ t_1 + t_2 }\)</span>,所以<span class="math inline">\(k_{
OM } = - ( t_1 + t_2 )\)</span>,<span class="math inline">\(\frac{ y }{
x } = - ( t_1 + t_2 )\)</span>.</p>
<p>接下来咋做捏?注意到我们好像忘记了<span class="math inline">\(ABM\)</span>三点共线的性质,拿向量做这个东西.</p>
<p><span class="math inline">\(\overrightarrow{ AM } = ( x - 2 pt_1^2 ,
y - 2 pt_1 ) , \overrightarrow{ MB } = ( 2 pt_2^2 - x , 2 pt_2 - y
)\)</span>.</p>
<p>那么有<span class="math inline">\(( x - 2 pt_1^2 ) ( 2 pt_2 - y ) = (
2 pt_2^2 - x ) ( y - 2 pt_1 )\)</span>.</p>
<p>化简得到<span class="math inline">\(x^2 + y^2 - 2 px = 0 ( x \ne 0
)\)</span>.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点<span class="math inline">\(A ,
B\)</span>,自然要设出它们的参数方程.然后呢?然后我们发现最后<span class="math inline">\(M\)</span>一定和<span class="math inline">\(t_1 ,
t_2\)</span>有关.但是我们要求的是<span class="math inline">\(M\)</span>的方程,其中不能带有<span class="math inline">\(t_1 , t_2\)</span>,因此考虑把<span class="math inline">\(M\)</span>的坐标设出来,再用这个坐标表示<span class="math inline">\(t_1 , t_2\)</span>,表示不出来表示<span class="math inline">\(t_1 t_2 , t_1 +
t_2\)</span>也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到<span class="math inline">\(M\)</span>一定在以<span class="math inline">\(| OA
|\)</span>为直径的圆上,<span class="math inline">\(B\)</span>同理,这两个圆的方程分别为:</p>
<p><span class="math display">\[
\begin{aligned}
x^2 + y^2 - 2 pt_1^2 x - 2 pt_1 y &amp; = 0 \\
x^2 + y^2 - 2 pt_2^2 x - 2 pt_2 y &amp; = 0
\end{aligned}
\]</span></p>
<p>也就是说,<span class="math inline">\(t_1 ,
t_2\)</span>是同一个方程的两个根,根据韦达定理自然有<span class="math inline">\(t_1 t_2 = \frac{ - ( x^2 + y^2 ) }{ 2 px } = -
1\)</span>,于是直接有<span class="math inline">\(x^2 + y^2 - 2 px =
0\)</span>.</p>
<p>还没完,注意到<span class="math inline">\(O\)</span>一定是一个根,要去掉,所以答案就是<span class="math inline">\(x^2 + y^2 - 2 px = 0 ( x \ne 0 )\)</span>.</p>
<p><strong>Example3</strong></p>
<p>已知<span class="math inline">\(A , B , C\)</span>是抛物线<span class="math inline">\(y^2 = 2 px ( p &gt; 0 )\)</span>上的三个点,且<span class="math inline">\(BC\)</span>与<span class="math inline">\(x\)</span>轴垂直,直线<span class="math inline">\(AB\)</span>和<span class="math inline">\(AC\)</span>分别与抛物线的轴交于<span class="math inline">\(D , E\)</span>两点,求证:抛物线的顶点平分<span class="math inline">\(DE\)</span>.</p>
<p>设<span class="math inline">\(A ( 2 pt_1^2 , 2 pt_1 ) , B ( 2 pt_2^2
, 2 pt_2 ) , C ( 2 pt_2^2 , - 2 pt_2 )\)</span>,注意到<span class="math inline">\(AB : y - 2 pt_1 = \frac{ 1 }{ t_1 + t_2 } ( x - 2
pt_1^2 )\)</span>,<span class="math inline">\(AC : t - 2 pt_1 = \frac{ 1
}{ t_1 - t_2 } ( x - 2 pt_1^2 )\)</span>.</p>
<p>可求得<span class="math inline">\(D ( - 2 pt_1 t_2 , 0 ) , E ( 2 pt_1
t_2 , 0 )\)</span>,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5>
<p>参考:https://zhuanlan.zhihu.com/p/591258689</p>
<h6><span id="定义">定义</span></h6>
<p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6>
<p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为<span class="math inline">\(\frac{ x^2 }{ a^2 } + \frac{ y^2
}{ b^2 } = 1\)</span>,其蒙日圆方程为<span class="math inline">\(x^2 +
y^2 = a^2 + b^2\)</span>.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为<span class="math inline">\(\frac{ x^2 }{ a^2 } - \frac{
y^2 }{ b^2 } = 1\)</span>,其蒙日圆方程为<span class="math inline">\(x^2
+ y^2 = a^2 - b^2\)</span>.</p>
<p>证明:其实注意到椭圆的证明中设<span class="math inline">\(b\)</span>是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线<span class="math inline">\(y^2 = 2
px\)</span>,其蒙日圆方程为<span class="math inline">\(x = - \frac{ p }{
2 }\)</span>.</p>
<p>有一说一,直线是半径无穷大的圆.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">高等代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<ul>
<li><a href="#抽象代数">抽象代数</a>
<ul>
<li><a href="#群">群</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#基本概念和事实">基本概念和事实</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#子群">子群</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#example8">Example8</a></li>
</ul></li>
<li><a href="#同态和同构">同态和同构</a></li>
<li><a href="#群的实例">群的实例</a>
<ul>
<li><a href="#全变换群对称群与交错群">全变换群,对称群与交错群</a></li>
<li><a href="#一般线性群">一般线性群</a></li>
<li><a href="#克莱因四元群">克莱因四元群</a></li>
<li><a href="#循环群">循环群</a></li>
</ul></li>
<li><a href="#相反群">相反群</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
<li><a href="#陪集">陪集</a></li>
<li><a href="#群作用">群作用</a>
<ul>
<li><a href="#cayley定理">Cayley定理</a></li>
<li><a href="#burnside引理">Burnside引理</a></li>
<li><a href="#p-群"><span class="math inline">\(p\)</span>-群</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#正规子群">正规子群</a>
<ul>
<li><a href="#正规子群的判定定理">正规子群的判定定理</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
<li><a href="#正规子群与同态">正规子群与同态</a></li>
<li><a href="#同态基本定理">同态基本定理</a></li>
<li><a href="#第一同构定理">第一同构定理</a></li>
<li><a href="#第二同构定理">第二同构定理</a></li>
<li><a href="#交换化">交换化</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
<li><a
href="#example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul></li>
</ul></li>
<li><a href="#群的直和与直积">群的直和与直积</a>
<ul>
<li><a href="#直和">直和</a></li>
<li><a href="#半直积">半直积</a>
<ul>
<li><a href="#example1-6">Example1</a></li>
<li><a href="#example2二面体群">Example2(二面体群)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#环">环</a>
<ul>
<li><a href="#子环">子环</a></li>
<li><a href="#理想">理想</a></li>
<li><a href="#同态和同构-1">同态和同构</a>
<ul>
<li><a href="#同态基本定理-1">同态基本定理</a></li>
<li><a href="#第一同构定理-1">第一同构定理</a></li>
<li><a href="#第二同构定理-1">第二同构定理</a></li>
</ul></li>
<li><a href="#整环">整环</a>
<ul>
<li><a href="#特征">特征</a></li>
<li><a href="#整除性">整除性</a></li>
<li><a href="#唯一分解整环ufd">唯一分解整环(UFD)</a></li>
<li><a href="#主理想整环pid">主理想整环(PID)</a></li>
</ul></li>
</ul></li>
<li><a href="#多项式环">多项式环</a>
<ul>
<li><a href="#一元多项式环">一元多项式环</a></li>
<li><a href="#多元多项式环">多元多项式环</a></li>
<li><a href="#不可约多项式">不可约多项式</a>
<ul>
<li><a href="#本原多项式">本原多项式</a></li>
<li><a href="#一个判定不可约的算法">一个判定不可约的算法</a></li>
<li><a href="#不可约多项式上的扩域">不可约多项式上的扩域</a></li>
</ul></li>
<li><a href="#对称多项式">对称多项式</a>
<ul>
<li><a href="#牛顿公式">牛顿公式</a></li>
</ul></li>
<li><a href="#结式">结式</a></li>
<li><a href="#判别式">判别式</a></li>
</ul></li>
<li><a href="#域">域</a>
<ul>
<li><a href="#分式域">分式域</a></li>
<li><a href="#子域">子域</a></li>
</ul></li>
</ul></li>
<li><a href="#线性代数">线性代数</a>
<ul>
<li><a href="#矩阵引入">矩阵引入</a>
<ul>
<li><a href="#矩阵运算">矩阵运算</a></li>
<li><a href="#分块矩阵">分块矩阵</a></li>
</ul></li>
<li><a href="#线性方程组">线性方程组</a>
<ul>
<li><a href="#系数矩阵和增广矩阵">系数矩阵和增广矩阵</a></li>
<li><a href="#矩阵的初等行变换">矩阵的初等行变换</a></li>
<li><a href="#阶梯形矩阵">阶梯形矩阵</a>
<ul>
<li><a href="#简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</a></li>
</ul></li>
<li><a href="#解线性方程组">解线性方程组</a>
<ul>
<li><a href="#存在与唯一性定理">存在与唯一性定理</a></li>
</ul></li>
<li><a href="#矩阵方程">矩阵方程</a></li>
<li><a href="#齐次线性方程组">齐次线性方程组</a></li>
</ul></li>
<li><a href="#线性空间">线性空间</a>
<ul>
<li><a href="#相关运算">相关运算</a>
<ul>
<li><a href="#直积">直积</a></li>
<li><a href="#直和-1">直和</a></li>
<li><a href="#叉乘">叉乘</a></li>
</ul></li>
<li><a href="#线性无关与线性相关">线性无关与线性相关</a></li>
<li><a href="#子空间">子空间</a>
<ul>
<li><a href="#向量的线性组合">向量的线性组合</a></li>
<li><a href="#线性映射">线性映射</a></li>
<li><a href="#基和维数">基和维数</a></li>
</ul></li>
<li><a href="#可逆矩阵">可逆矩阵</a>
<ul>
<li><a href="#初等矩阵">初等矩阵</a></li>
<li><a href="#求解逆矩阵">求解逆矩阵</a>
<ul>
<li><a href="#example1lu分解">Example1(LU分解)</a></li>
</ul></li>
</ul></li>
<li><a href="#核与像与秩">核与像与秩</a>
<ul>
<li><a href="#sylvester秩不等式">Sylvester秩不等式</a></li>
<li><a href="#frobenius秩不等式">Frobenius秩不等式</a></li>
</ul></li>
<li><a href="#对偶空间">对偶空间</a></li>
<li><a href="#直和分解与分块矩阵">直和分解与分块矩阵</a></li>
<li><a href="#基的变换">基的变换</a>
<ul>
<li><a href="#矩阵的共轭相似">矩阵的共轭(相似)</a></li>
<li><a href="#矩阵的相抵">矩阵的相抵</a></li>
</ul></li>
<li><a href="#商空间">商空间</a>
<ul>
<li><a href="#同态基本定理-2">同态基本定理</a></li>
<li><a href="#第一同构定理-2">第一同构定理</a></li>
<li><a href="#第二同构定理-2">第二同构定理</a></li>
<li><a href="#旗">旗</a></li>
<li><a href="#不变子空间">不变子空间</a></li>
</ul></li>
</ul></li>
<li><a href="#行列式">行列式</a>
<ul>
<li><a href="#置换排列">置换(排列)</a></li>
<li><a href="#交错形式">交错形式</a></li>
<li><a href="#定义-1">定义</a></li>
<li><a href="#余子式与代数余子式">余子式与代数余子式</a></li>
<li><a href="#行列式定向">行列式定向</a></li>
<li><a href="#克拉默cramer法则">克拉默(Cramer)法则</a></li>
<li><a href="#一些特殊行列式">一些特殊行列式</a>
<ul>
<li><a href="#置换矩阵">置换矩阵</a></li>
<li><a href="#上三角矩阵">上三角矩阵</a></li>
<li><a href="#分块上三角矩阵">分块上三角矩阵</a></li>
<li><a
href="#范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</a></li>
<li><a href="#一类分块矩阵">一类分块矩阵</a></li>
</ul></li>
<li><a href="#特征多项式">特征多项式</a></li>
<li><a href="#cayley-hamilton定理">Cayley-Hamilton定理</a></li>
<li><a href="#矩阵的迹">矩阵的迹</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#binet-cauchy定理">Binet-Cauchy定理</a></li>
<li><a href="#特征值与特征向量">特征值与特征向量</a></li>
<li><a href="#极小多项式">极小多项式</a></li>
<li><a href="#同步对角化">同步对角化</a></li>
<li><a href="#上三角化">上三角化</a></li>
<li><a href="#广义特征子空间">广义特征子空间</a></li>
<li><a href="#特殊矩阵的特征值">特殊矩阵的特征值</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#双线性形式">双线性形式</a>
<ul>
<li><a href="#线性映射-1">线性映射</a></li>
<li><a href="#非退化形式">非退化形式</a></li>
<li><a href="#伴随映射">伴随映射</a></li>
<li><a href="#分类问题">分类问题</a></li>
<li><a href="#二次型">二次型</a>
<ul>
<li><a href="#实二次型">实二次型</a></li>
<li><a href="#惯性sylvester定理">惯性(Sylvester)定理</a></li>
</ul></li>
<li><a href="#辛空间">辛空间</a>
<ul>
<li><a href="#达布定理">达布定理</a></li>
</ul></li>
<li><a href="#回看对偶空间">回看对偶空间</a>
<ul>
<li><a href="#双重对偶">双重对偶</a></li>
<li><a href="#核余核与对偶映射">核,余核与对偶映射</a></li>
<li><a href="#像自对偶">像自对偶</a></li>
</ul></li>
</ul></li>
<li><a href="#实内积空间">实内积空间</a>
<ul>
<li><a href="#勾股定理">勾股定理</a></li>
<li><a href="#柯西不等式">柯西不等式</a></li>
<li><a href="#三角不等式">三角不等式</a></li>
<li><a href="#距离相关">距离相关</a></li>
<li><a href="#正交向量族">正交向量族</a></li>
<li><a href="#gram-schmidt-正交化">Gram-Schmidt 正交化</a>
<ul>
<li><a href="#example1ru分解">Example1(RU分解)</a></li>
<li><a href="#example2legendre多项式">Example2(Legendre多项式)</a></li>
</ul></li>
<li><a href="#正交算子">正交算子</a></li>
<li><a href="#正交补空间">正交补空间</a></li>
<li><a href="#投影矩阵">投影矩阵</a></li>
<li><a href="#自伴算子">自伴算子</a>
<ul>
<li><a href="#实sylvester-判准">(实)Sylvester 判准</a></li>
<li><a href="#实正定矩阵的二次根">(实)正定矩阵的二次根</a>
<ul>
<li><a href="#example1-7">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
</ul></li>
<li><a href="#极分解">极分解</a></li>
<li><a href="#最小二乘法">最小二乘法</a></li>
</ul></li>
<li><a href="#奇异值分解">奇异值分解</a></li>
<li><a href="#moore-penrose-广义逆">Moore-Penrose 广义逆</a></li>
<li><a
href="#极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</a></li>
<li><a href="#perron-frobenius定理">Perron-Frobenius定理</a>
<ul>
<li><a href="#collatz-wielandt公式">Collatz-Wielandt公式</a></li>
<li><a href="#perron定理">Perron定理</a></li>
</ul></li>
<li><a href="#实正交变换的标准型">实正交变换的标准型</a>
<ul>
<li><a href="#欧拉角">欧拉角</a></li>
<li><a href="#四元数">四元数</a></li>
</ul></li>
</ul></li>
<li><a href="#复内积空间">复内积空间</a>
<ul>
<li><a href="#共轭空间">共轭空间</a></li>
<li><a href="#复半双线性形式">(复)半双线性形式</a></li>
<li><a href="#伴随映射-1">伴随映射</a></li>
<li><a href="#hermite形式">Hermite形式</a>
<ul>
<li><a href="#正规线性映射">正规线性映射</a></li>
<li><a href="#二次型-1">二次型</a></li>
</ul></li>
<li><a href="#复内积空间-1">复内积空间</a>
<ul>
<li><a href="#酉变换">酉变换</a></li>
<li><a
href="#正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</a></li>
<li><a href="#相关实内积空间定理推广">相关实内积空间定理推广</a></li>
<li><a href="#复矩阵范数实例">复矩阵范数实例</a></li>
</ul></li>
</ul></li>
<li><a href="#模">模</a>
<ul>
<li><a href="#自由模">自由模</a>
<ul>
<li><a href="#example1非自由模">Example1(非自由模)</a></li>
</ul></li>
<li><a href="#线性映射和模结构">线性映射和模结构</a></li>
<li><a href="#主理想环上的有限生成模">主理想环上的有限生成模</a>
<ul>
<li><a href="#自由模与其子模">自由模与其子模</a></li>
<li><a href="#smith标准型">Smith标准型</a></li>
<li><a href="#结构定理">结构定理</a></li>
<li><a href="#有限生成交换群的分类">有限生成交换群的分类</a></li>
</ul></li>
<li><a href="#有理标准型">有理标准型</a>
<ul>
<li><a href="#example1-8">Example1</a></li>
</ul></li>
<li><a href="#jordan标准型">Jordan标准型</a>
<ul>
<li><a
href="#加性jordan-chevalley分解">加性Jordan-Chevalley分解</a></li>
<li><a
href="#乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</a></li>
</ul></li>
</ul></li>
<li><a href="#张量积">张量积</a>
<ul>
<li><a href="#张量积与直和">张量积与直和</a></li>
<li><a href="#kronecker积">Kronecker积</a></li>
<li><a href="#张量积与对偶空间">张量积与对偶空间</a></li>
<li><a href="#张量代数">张量代数</a>
<ul>
<li><a href="#另一种构造">另一种构造</a></li>
<li><a href="#又看对偶空间">又看对偶空间</a>
<ul>
<li><a href="#example1-9">Example1</a></li>
<li><a href="#example2-4">Example2</a></li>
</ul></li>
<li><a href="#简单应用">简单应用</a></li>
</ul></li>
<li><a href="#域的变换">域的变换</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3>
<p>三个柱子,<span class="math inline">\(n\)</span>个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令<span class="math inline">\(T_n\)</span>表示答案,显然<span class="math inline">\(T_0 = 0 , T_1 = 1\)</span>.</p>
<p>而我们一定可以找到一种方案,使得前<span class="math inline">\(n -
1\)</span>个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把<span class="math inline">\(n -
1\)</span>个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:<span class="math inline">\(T_n \leq 2 T_{ n - 1 } + 1\)</span>.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:<span class="math inline">\(2 T_{ n - 1 } + 1 \leq T_n\)</span>.于是有<span class="math inline">\(T_n = 2 T_{ n - 1 } + 1\)</span>.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4>
<p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4>
<p>考虑设<span class="math inline">\(T_n\)</span>为n个圆盘时的最小操作次数.假设已知<span class="math inline">\(T_{ n - 1 }\)</span>,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:<span class="math inline">\(T_{ n } = 3 T_{ n - 1 } + 2 , T_0 =
0\)</span>.</p>
<p>考虑如何求该式子的封闭形式,令<span class="math inline">\(W_n = T_n +
1\)</span>,显然有<span class="math inline">\(W_n = 3 W_{ n - 1 } , W_0 =
1\)</span>,显然<span class="math inline">\(W_n = 3^n\)</span>,有<span class="math inline">\(T_n = 3^n - 1\)</span>.</p>
<p>注意到<span class="math inline">\(T_n\)</span>刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4>
<p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于<span class="math inline">\(2^n - 1\)</span>.</p>
<h4><span id="solution-2">Solution 2</span></h4>
<p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4>
<p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4>
<p>令<span class="math inline">\(Q_n\)</span>为将n个圆盘从A移动到B的最小操作次数,令<span class="math inline">\(R_n\)</span>为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,<span class="math inline">\(Q_0 = 0 , R_0 =
0\)</span>.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此<span class="math inline">\(Q_n\)</span>的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,<span class="math inline">\(R_n\)</span>的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有<span class="math inline">\(Q_n = 2 R_{ n - 1 } + 1 , 1 \leq
n\)</span>.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有<span class="math inline">\(R_n = R_{ n - 1 } + 1 + Q_{ n - 1 } + 1
+ R_{ n - 1 } = Q_n + Q_{ n - 1 } + 1 , 1 \leq n\)</span>.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4>
<p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4>
<p>a.仍然令<span class="math inline">\(T_n\)</span>为n对圆盘的最小操作次数,显然<span class="math inline">\(T_n = 2 T_{ n - 1 } + 2 , T_0 =
0\)</span>,可解得<span class="math inline">\(T_n = 2^{ n + 1 } -
2\)</span>.</p>
<p>b.令<span class="math inline">\(Q_n\)</span>为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现<span class="math inline">\(Q_n = T_{ n - 1 } + 1 + T_{ n - 1 } + 1 + T_{ n -
1 } + 1 + T_{ n - 1 } = 4 T_{ n - 1 } + 3 = 2^{ n + 2 } -
5\)</span>.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的<span class="math inline">\(Q_n\)</span>就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4>
<p>类似Problem11,但第<span class="math inline">\(i\)</span>大的圆盘有<span class="math inline">\(k_i\)</span>个.</p>
<h4><span id="solution-5">Solution 5</span></h4>
<p>无区别,只是<span class="math inline">\(T_n = 2 T_{ n - 1 } + k_n ,
T_0 = 0\)</span>.</p>
<p>如果求封闭形式的话,显然有<span class="math inline">\(T_n = \sum_{ i =
1 }^n 2^{ n - i } k_i\)</span>.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3>
<p>在上述问题中，我们已经有了以下式子：</p>
<p><span class="math inline">\(T_n = 2 T_{ n - 1 } + 1 , n &gt; 0 , T_0
= 0\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出<span class="math inline">\(T_n\)</span>的方法.</p>
<p>换句话说，我们想要把<span class="math inline">\(T_n\)</span>表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4>
<h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5>
<p>解递归式:<span class="math inline">\(Q_n = \begin{cases}\alpha &amp;
n = 0 \\ \beta &amp; n = 1 \\ \frac{ ( 1 + Q_{ n - 1 } ) }{ Q_{ n - 2 }
} &amp; n &gt; 1\end{cases}\)</span>,保证<span class="math inline">\(\forall n , Q_n &gt; 0\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>注意到<span class="math inline">\(Q_2 = \frac{ \beta + 1 }{ \alpha }
, Q_3 = \frac{ \beta + \alpha + 1 }{ \beta \alpha } , Q_4 = \frac{ 1 +
\alpha }{ \beta } , Q_5 = \alpha , Q_6 = \beta\)</span>.</p>
<p>显然该递归式存在长度为<span class="math inline">\(5\)</span>的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4>
<p>观察T序列的前几项，可以发现似乎有<span class="math inline">\(T_n =
2^n - 1\)</span>.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于<span class="math inline">\(n =
0\)</span>成立，显然可验证.</p>
<p>2.若该公式对<span class="math inline">\(n =
k\)</span>时成立，那该公式必然对<span class="math inline">\(n = k +
1\)</span>成立.</p>
<p>因为有<span class="math inline">\(T_{ k + 1 } = 2 T_k + 1 = 2 \times
2^k + 2 - 1 = 2^{ k + 1 } - 1\)</span>.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5>
<p>求证:<span class="math inline">\(\prod_{ i = 1 }^n x_i \leq ( \frac{
\sum_{ i = 1 }^n x_i }{ n } )^n , \forall i \in N_+ , 1 \leq i \leq n ,
0 \leq x_i\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>使用反向归纳法.</p>
<p>1.<span class="math inline">\(n =
2\)</span>时,即基本不等式,显然成立.</p>
<p>2.若该式子对<span class="math inline">\(n =
k\)</span>时成立,则该式子对n=2k时也成立.</p>
<p>不妨令<span class="math inline">\(A_1 = \sqrt[k]{ \prod_{ i = 1 }^k
x_i } , B_1 = \sqrt[k]{ \prod_{ i = k + 1 }^{ 2 k } x_i } , A_2 = (
\frac{ \sum_{ i = 1 }^k x_i }{ k } ) , B_2 = ( \frac{ \sum_{ i = k + 1
}^{ 2 k } x_i }{ k } )\)</span>,显然有<span class="math inline">\(A_1
\leq A_2 , B_1 \leq B_2\)</span>.</p>
<p>同时有<span class="math inline">\(( \frac{ A_2 + B_2 }{ 2 } ) \geq
\sqrt{ A_2 B_2 } \geq \sqrt{ A_1 B_1 }\)</span>.</p>
<p>3.若该式子对<span class="math inline">\(n =
k\)</span>时成立,则该式子对<span class="math inline">\(n = k -
1\)</span>的时候也成立.</p>
<p>令<span class="math inline">\(x_k = \frac{ \sum_{ i = 1 }^{ k - 1 }
x_i }{ k - 1 }\)</span>,有<span class="math inline">\(x_k \prod_{ i = 1
}^{ k - 1 } x_i \leq ( x_k )^k\)</span>.</p>
<p>则显然<span class="math inline">\(n = k - 1\)</span>时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4>
<p>考虑令<span class="math inline">\(U_n = T_n + 1\)</span>,显然有:<span class="math inline">\(T_n + 1 = 2 T_{ n - 1 } + 2\)</span>.即<span class="math inline">\(U_n = 2 U_{ n - 1 }\)</span>,显然<span class="math inline">\(U_n = 2^n\)</span>,则<span class="math inline">\(T_n = 2^n - 1\)</span>.</p>
<p>这个做法可以做掉所有形如<span class="math inline">\(a_{ n + 1 } =
pa_n + q\)</span>的递归式.我们有:</p>
<p><span class="math display">\[
a_{ n + 1 } + \frac{ q }{ p - 1 } = p ( a_n + \frac{ q }{ p - 1 } )
\]</span></p>
<p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4>
<p>考虑递归式<span class="math inline">\(a_n T_n = b_n T_{ n - 1 } +
c_n\)</span>.如果我们能找到一个不为0的求和因子<span class="math inline">\(s_n\)</span>并满足<span class="math inline">\(s_n
b_n = s_{ n - 1 } a_{ n - 1 }\)</span>.那么我们两面同时乘以<span class="math inline">\(s_n\)</span>,显然有：<span class="math inline">\(s_n a_n T_n = s_{ n - 1 } a_{ n - 1 } T_{ n - 1 }
+ c_n s_n\)</span>.</p>
<p>令<span class="math inline">\(S_n = s_n a_n T_n\)</span>.显然有<span class="math inline">\(S_n = s_0 a_0 T_0 + \sum_{ i = 1 }^n s_i
c_i\)</span>,则<span class="math inline">\(T_n = \frac{ S_n }{ s_n a_n
}\)</span>.</p>
<p>而我们也会发现<span class="math inline">\(s_n = \frac{ \prod_{ i = 1
}^{ n - 1 } a_i }{ \prod_{ i = 1 }^n b_i }\)</span>.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5>
<p>结论:排序<span class="math inline">\(n\)</span>个数时,其期望复杂度满足:</p>
<p><span class="math display">\[
C_n = \begin{cases}
0 &amp; n = 0 , 1 \\
n + 1 + \frac{ 2 }{ n } \sum_{ i = 0 }^{ n - 1 } C_k &amp; n &gt; 1
\end{cases}
\]</span></p>
<p>不妨考虑两边同时乘以<span class="math inline">\(n\)</span>,有 <span class="math inline">\(nC_n = n^2 + n + 2 \sum_{ i = 0 }^{ n - 1 } C_i ,
n &gt; 1\)</span> .</p>
<p>显然也有<span class="math inline">\(( n - 1 ) C_{ n - 1 } = ( n - 1
)^2 + n - 1 + 2 \sum_{ i = 0 }^{ n - 2 } C_i , n &gt; 2\)</span>.</p>
<p>二式相消,有<span class="math inline">\(nC_n - ( n - 1 ) C_{ n - 1 } =
2 n + 2 C_{ n - 1 } , n &gt; 2\)</span>.</p>
<p>而同时有<span class="math inline">\(C_2 = 3\)</span>.即:<span class="math inline">\(nC_n = ( n + 1 ) C_{ n - 1 } + 2 n , n &gt;
2\)</span>,可以使用转化和式的方法,两边乘以<span class="math inline">\(\frac{ 1 }{ n ( n + 1 ) }\)</span>解决.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知<span class="math inline">\(a_1 = 1\)</span>,<span class="math inline">\(a_n = \sqrt{ S_n } + \sqrt{ S_{ n - 1 }
}\)</span>,求<span class="math inline">\(a_n\)</span>.</p>
<p>注意到<span class="math inline">\(a_n = S_n - S_{ n - 1
}\)</span>,则有<span class="math inline">\(\sqrt{ S_n } - \sqrt{ S_{ n -
1 } } = 1\)</span>,于是<span class="math inline">\(\sqrt{ S_n } =
n\)</span>,<span class="math inline">\(S_n = n^2\)</span>,<span class="math inline">\(a_n = 2 n - 1\)</span>.</p>
<h4><span id="成套方法">成套方法</span></h4>
<p>如果我们有</p>
<p>&amp; n=1\</p>
<p>2f(n 2)+&amp; n=2k,k\</p>
<p>2f(2)+&amp;n=2k+1,k</p>
<p>\end{cases}</p>
<p>其中<span class="math inline">\(n = 2^m + l\)</span>且<span class="math inline">\(2^m \leq n &lt; 2^{ m + 1 }\)</span>.</p>
<p>该如何求出<span class="math inline">\(f ( n
)\)</span>的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有<span class="math inline">\(f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n )
\gamma\)</span>,而有<span class="math inline">\(A 、 B 、
C\)</span>互不影响且<span class="math inline">\(\alpha \beta
\gamma\)</span>与<span class="math inline">\(ABC\)</span>无关.</p>
<p>那无论<span class="math inline">\(\beta\)</span>和<span class="math inline">\(\gamma\)</span>的取值如何,<span class="math inline">\(A ( n )\)</span>都不会受到影响,我们考虑<span class="math inline">\(\beta = \gamma =
0\)</span>的特殊情况,此时显然有<span class="math inline">\(A ( n ) =
2^m\)</span>.</p>
<p>接下来,我们考虑取<span class="math inline">\(\alpha \beta
\gamma\)</span>的特殊值,去得到ABC之间的关系.</p>
<p>例如，当<span class="math inline">\(f ( n ) =
1\)</span>时，由递推式可知<span class="math inline">\(\alpha = 1 , \beta
= \gamma = - 1\)</span>,那么有<span class="math inline">\(A ( n ) - B (
n ) - C ( n ) = f ( n ) = 1\)</span>.</p>
<p>同理，<span class="math inline">\(f ( n ) = n\)</span>时，可知<span class="math inline">\(\alpha = 1 , \beta = 0 , \gamma =
1\)</span>,此时有<span class="math inline">\(A ( n ) + C ( n ) = f ( n )
= n\)</span>.</p>
<p>显然可以通过解方程求得<span class="math inline">\(B ( n
)\)</span>和<span class="math inline">\(C ( n )\)</span>.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明<span class="math inline">\(ABC\)</span>互不影响且<span class="math inline">\(\alpha \beta \gamma\)</span>与<span class="math inline">\(ABC\)</span>无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4>
<p>一个常系数的<span class="math inline">\(k\)</span>阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = P_n + \sum_{ i = 1 }^k c_i a_{ n - i } , n \geq k \\
a_0 &amp; = C_0 , a_1 = C_1 , . . . , a_{ k - 1 } = C_{ k - 1 }
\end{aligned}
\]</span></p>
<p>当<span class="math inline">\(P = 0\)</span>时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程<span class="math inline">\(r^k = \sum_{ i = 1 }^k c_i r^{
k - i
}\)</span>是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根<span class="math inline">\(r_1\)</span>和<span class="math inline">\(r_2\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r_1^n + \alpha_2
r_2^n\)</span>.</p>
<p>若其特征方程有两个相同的根<span class="math inline">\(r\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r^n + \alpha_2 nr^n\)</span>.</p>
<p>先考虑前者的证明,首先考虑对于<span class="math inline">\(n =
0\)</span>或者<span class="math inline">\(n =
1\)</span>的情况,我们考虑求出一组<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C_0 &amp; = \alpha_1 + \alpha_2 \\
C_1 &amp; = \alpha_1 r_1 + \alpha_2 r_2
\end{aligned}
\]</span></p>
<p>若<span class="math inline">\(r_1 \ne r_2\)</span>,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha_1 &amp; = \cfrac{ C_1 - C_0 r_2 }{ r_1 - r_2 } \\
\alpha_2 &amp; = C_0 - \alpha_1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r_1^{ n - 1 } + \alpha_2 r_2^{ n - 1 } ) + c_2 (
\alpha_1 r_1^{ n - 2 } + \alpha_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 ( c_1 r_1^{ n - 1 } + c_2 r_1^{ n - 2 } ) + \alpha_2 (
c_1 r_2^{ n - 1 } + c_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 r_1^n + \alpha_2 r_2^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有<span class="math inline">\(\Delta = c_1^2 +
4 c_2 = 0\)</span>,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C_0 &amp; = \alpha_1 \\
C_1 &amp; = \alpha_1 r + \alpha_2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r^{ n - 1 } + \alpha_2 nr^{ n - 1 } - \alpha_2
r^{ n - 1 } ) + c_2 ( \alpha_1 r^{ n - 2 } + \alpha_2 nr^{ n - 2 } - 2
\alpha_2 r^{ n - 2 } ) \\
&amp; = a_n - c_1 \alpha_2 r^{ n - 1 } - 2 c_2 \alpha_2 r^{ n - 2 }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明<span class="math inline">\(c_1 r + 2 c_2 =
0\)</span>即可.根据方程,不难发现<span class="math inline">\(r = \cfrac{
c_1 }{ 2 }\)</span>,根据<span class="math inline">\(\Delta =
0\)</span>,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>直接在复数域上定义<span class="math inline">\(f_k ( x ) = \{ n^k x^n
\}_{ n = 0 }^\infty\)</span>,此时我们规定<span class="math inline">\(0^0
= 1\)</span>.特别地,当<span class="math inline">\(x =
0\)</span>的时候,定义<span class="math inline">\(f_k ( x
)\)</span>的第<span class="math inline">\(k\)</span>项是<span class="math inline">\(1\)</span>,其余项是<span class="math inline">\(0\)</span>.在此基础上定义线性映射<span class="math inline">\(T : ( a_n )_{ n = 0 }^\infty \mapsto ( a_{ n + 1 }
)_{ n = 0 }^\infty\)</span>,立刻见到:<span class="math inline">\(( T - x
)^{ k + 1 } f_k ( x ) = 0 , ( T - x )^k f_k ( x ) \ne
0\)</span>.原因只需简单数学归纳.而此还可以引出<span class="math inline">\(f_0 ( x ) , f_1 ( x ) ,
\cdots\)</span>线性无关.</p>
<p>在此基础上观察线性递推<span class="math inline">\(a_{ n + d } = c_{ d
- 1 } a_{ n + d - 1 } + \cdots + c_0 a_n\)</span>,不妨取<span class="math inline">\(G ( x ) = x^d - c_{ d - 1 } x^{ d - 1 } - \cdots -
c_0\)</span>,立刻应当见到如果<span class="math inline">\(a\)</span>是<span class="math inline">\(G\)</span>的根并且重数为<span class="math inline">\(e ( a )\)</span>,那么<span class="math inline">\(f_{ 0 } ( x ) , \cdots , f_{ e ( a ) - 1 } ( a
)\)</span>都在<span class="math inline">\(\ker f ( T
)\)</span>中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如<span class="math inline">\(\sum_j w_i f_i ( y ) = \sum_j w_j f_j ( x
)\)</span>的情况,此时对右边直接操作若干次<span class="math inline">\(( T
- x )\)</span>就可以把右边全部消成<span class="math inline">\(0\)</span>,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于<span class="math inline">\(n\)</span>的多项式右边的<span class="math inline">\(( T - x
)\)</span>是不会改变左边这边的每一个位置多项式的<span class="math inline">\(\deg\)</span>,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是<span class="math inline">\(\vec{ x }_{ k +
1 } = A \vec{ x }\)</span>,<span class="math inline">\(\vec{ x }_{ n } =
A^n \vec{ x }_0\)</span>.而我们又知道CH定理:<span class="math inline">\(p ( A ) = 0\)</span>,我们用多项式取膜,有<span class="math inline">\(A^n = p ( A ) F ( A ) + G ( A ) = G ( A
)\)</span>,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3>
<p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是<span class="math inline">\(2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 ,
9\)</span>.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有<span class="math inline">\(J ( 2 n ) = 2 J
( n ) - 1\)</span>;当人数是奇数时,我们杀掉一号,然后有<span class="math inline">\(J ( 2 n + 1 ) = 2 J ( n ) + 1\)</span>.</p>
<p>整理得到:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 1 \\
2 J ( \frac{ n }{ 2 } ) - 1 &amp; n = 2 k , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 1 &amp; n = 2 k + 1 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>仍然可以使用数学归纳，如果令<span class="math inline">\(n = 2^m + l
且 2^m \leq n &lt; 2^{ m + 1 }\)</span>.</p>
<p>有<span class="math inline">\(J ( n ) = 2 l + 1\)</span>.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从<span class="math inline">\(0\)</span>开始编号:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
0 &amp; n = 1 \\
2 J ( \frac{ n }{ 2 } ) &amp; n = 2 k , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 2 &amp; n = 2 k + 1 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>这下相信<span class="math inline">\(J ( n
)\)</span>是多少就很显然了,将<span class="math inline">\(n\)</span>写成二进制的形式,这个就相当于把首位<span class="math inline">\(1\)</span>抹去然后在末尾加个<span class="math inline">\(0\)</span>.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4>
<p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4>
<p>显然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
2 &amp; n = 2 \\
1 &amp; n = 3 \\
2 J ( \frac{ n }{ 2 } ) - 1 &amp; n = 2 k + 2 , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 1 &amp; n = 2 k + 3 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>从<span class="math inline">\(0\)</span>开始编号,自然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 2 \\
0 &amp; n = 3 \\
2 J ( \frac{ n }{ 2 } ) &amp; n = 2 k + 2 , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 2 &amp; n = 2 k + 3 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>显然<span class="math inline">\(J ( n
)\)</span>也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2>
<h3><span id="和式的基本运算">和式的基本运算</span></h3>
<p>分配律:</p>
<p><span class="math display">\[
\sum_{ i \in S } ca_i = c \sum_{ i \in S } a_i
\]</span></p>
<p>一般分配律:</p>
<p><span class="math display">\[
\sum_{ i } \sum_{ j } a_{ i } b_j = ( \sum_{ i } a_i ) ( \sum_j b_j )
\]</span></p>
<p>结合律:</p>
<p><span class="math display">\[
\sum_{ i \in S } ( a_i + b_i ) = \sum_{ i \in S } a_i + \sum_{ i \in S }
b_i
\]</span></p>
<p>交换律:</p>
<p><span class="math display">\[
\sum_{ i \in S } a_i = \sum_{ p ( i ) \in S } a_{ p ( i ) }
\]</span></p>
<p>交换求和顺序:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i } \sum_{ j } a_{ i , j } [ P ( i , j ) ] &amp; = \sum_{ j }
\sum_{ i } a_{ i , j } [ P ( i , j ) ] \\
\sum_{ i = 1 }^n \sum_{ j = i }^n a_{ i , j } &amp; = \sum_{ j = 1 }^n
\sum_{ i = 1 }^j a_{ i , j }
\end{aligned}
\]</span></p>
<h3><span id="和式的封闭形式">和式的封闭形式</span></h3>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ( ai + b ) = \sum_{ i = 0 }^n ( a ( n - i )
+ b ) \\
2 S_n &amp; = \sum_{ i = 0 }^n ( an + 2 b ) = an ( n + 1 ) + 2 b ( n + 1
) \\
S_n &amp; = ( n + 1 ) ( \frac{ an }{ 2 } + b )
\end{aligned}
\]</span></p>
<h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5>
<p>令<span class="math inline">\(S = \sum_{ 1 \leq i &lt; j \leq n } (
a_j - a_i ) ( b_j - b_i ) = \sum_{ 1 \leq j &lt; i \leq n } ( a_j - a_i
) ( b_j - b_i )\)</span>.</p>
<p>考虑恒等式<span class="math inline">\([ 1 \leq j &lt; i \leq n ] + [
1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq
n ]\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S &amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) -
\sum_{ 1 \leq i = j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = 2 n \sum_{ i = 1 }^n a_i b_i - 2 ( \sum_{ i = 1 }^n a_i ) (
\sum_{ j = 1 }^n b_j ) \\
( \sum_{ i = 1 }^n a_i ) ( \sum_{ j = 1 }^n b_j ) &amp; = n \sum_{ i = 1
}^n a_i b_i - \sum_{ 1 \leq i &lt; j \leq n } ( a_j - a_i ) ( b_j - b_i
)
\end{aligned}
\]</span></p>
<p>显然有以下式子:</p>
<p>(_{i=1}<sup>na_i)(<em>{j=1}^nb_j)n</em>{i=1}</sup>na_ib_i，i&lt;j，a_ia_j且b_ib_j\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5>
<p>证明:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 1 \leq j &lt; k \leq n } ( a_j b_k - a_k b_j )^2 &amp; = ( \sum_{
i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - ( \sum_{ i = 1 }^n a_i
b_i )^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ 1 \leq j &lt; k \leq n } ( a_j b_k - a_k b_j )^2 \\
2 S_n &amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j b_k - a_k b_j )^2
\\
&amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j^2 b_k^2 - 2 a_j a_k b_j
b_k + a_k^2 b_j^2 ) \\
&amp; = 2 ( \sum_{ i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - 2 (
\sum_{ i = 1 }^n a_i b_i )^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ax^i \\
&amp; = a + \sum_{ i = 1 }^n ax^i \\
&amp; = a + x \sum_{ i = 0 }^{ n - 1 } ax^i \\
&amp; = a + xS_{ n - 1 }
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(S_{ n - 1 } + ax^n = S_n = a + xS_{ n -
1 }\)</span>,有<span class="math inline">\(S_n + ax^{ n + 1 } = a + xS_n
, S_n = a \frac{ x^{ n + 1 } - 1 }{ x - 1 }\)</span>，其中<span class="math inline">\(x \ne 1\)</span>.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n i^2 = \sum_{ i = 0 }^{ n - 1 } i^2 + n^2 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^2 + n^2 \\
&amp; = S_n - 2 \sum_{ i = 1 }^n i + n + n^2
\end{aligned}
\]</span></p>
<p>我们无法得到<span class="math inline">\(S_n\)</span>的封闭形式,但我们发现我们得到了<span class="math inline">\(\sum_{ i = 1 }^n i\)</span>的封闭形式.</p>
<p>那以此类推,我们设<span class="math inline">\(W_n = \sum_{ i = 0 }
i^3\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
W_n &amp; = \sum_{ i = 0 }^{ n - 1 } i^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n i^3 - 3 \sum_{ i = 1 }^n i^2 + 3 \sum_{ i = 1
}^n i - n + n^3 \\
&amp; = W_n - 3 S_n + 3 \frac{ n + n^2 }{ 2 } - n + n^3 \\
S_n &amp; = \frac{ n + n^2 }{ 2 } - \frac{ n - n^3 }{ 3 } \\
&amp; = \frac{ n + 3 n^2 + 2 n^3 }{ 6 } \\
&amp; = \frac{ n ( 1 + 3 n + 2 n^2 ) }{ 6 } \\
&amp; = \frac{ n ( 2 n + 1 ) ( n + 1 ) }{ 6 }
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5>
<p>令<span class="math inline">\(H_n = \sum_{ k = 1 }^n \frac{ 1 }{ k
}\)</span>,求<span class="math inline">\(\sum_{ i = 0 }^n
H_i\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>不妨考虑<span class="math inline">\(\sum_{ i = 0 }^n iH_{ i
}\)</span>的值.</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 0 }^n iH_{ i } &amp; = \sum_{ i = 1 }^n [ ( i - 1 + 1 ) H_{ i
- 1 } + 1 ] \\
&amp; = n + \sum_{ i = 0 }^{ n - 1 } H_i + \sum_{ i = 0 }^{ n } iH_i -
nH_n \\
\sum_{ i = 0 }^{ n - 1 } H_i &amp; = n ( H_n - 1 ) \\
\sum_{ i = 0 }^n H_i &amp; = ( n + 1 ) ( H_{ n + 1 } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5>
<p>求<span class="math inline">\(S_n = \sum_{ i = 0 }^n ( - 1 )^{ n - i
} , T_n = \sum_{ i = 0 }^n ( - 1 )^{ n - i } i , U_n = \sum_{ i = 0 }^n
( - 1 )^{ n - i } i^2\)</span>.</p>
<h5><span id="solution-4">Solution 4</span></h5>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 1 }^{ n } ( - 1 )^{ n - i } + ( - 1 )^n \\
- S_{ n - 1 } + 1 &amp; = ( - 1 )^n + \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{
n - 1 - i } \\
- S_{ n - 1 } + 1 &amp; = ( - 1 )^n + S_{ n - 1 } \\
S_{ n - 1 } &amp; = \frac{ 1 - ( - 1 )^n }{ 2 } \\
S_n &amp; = \frac{ 1 + ( - 1 )^n }{ 2 }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
T_{ n } &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } i \\
- T_{ n - 1 } + n &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 ) +
\sum_{ i = 1 }^n ( - 1 )^{ n - i } \\
- T_{ n - 1 } + n &amp; = \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1 }
i + \sum_{ i = 0 }^n ( - 1 )^{ n - i } - ( - 1 )^n \\
- T_{ n - 1 } + n &amp; = T_{ n - 1 } + S_n - ( - 1 )^n \\
n - \frac{ 1 - ( - 1 )^n }{ 2 } &amp; = 2 T_{ n - 1 } \\
T_n &amp; = \frac{ 1 }{ 2 } ( n + 1 + \frac{ - 1 - ( - 1 )^n }{ 2 } ) =
\frac{ 1 }{ 2 } ( n + \frac{ 1 - ( - 1 )^n }{ 2 } )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
U_n &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } i^2 \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 +
1 )^2 \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1
)^2 + 2 \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 ) + \sum_{ i = 1 }^n
( - 1 )^{ n - i } \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1
} i^2 + 2 \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1 } i + \sum_{ i =
0 }^{ n - 1 } ( - 1 )^{ n - i - 1 } \\
- U_{ n - 1 } + n^2 &amp; = U_{ n - 1 } + 2 T_{ n - 1 } + S_{ n - 1 } \\
2 U_{ n - 1 } &amp; = n^2 - 2 T_{ n - 1 } - S_{ n - 1 } \\
2 U_{ n - 1 } &amp; = n^2 - ( n - \frac{ 1 - ( - 1 )^n }{ 2 } ) - \frac{
1 - ( - 1 )^n }{ 2 } \\
2 U_{ n - 1 } &amp; = n^2 - n \\
U_n &amp; = \frac{ n ( n + 1 ) }{ 2 }
\end{aligned}
\]</span></p>
<h4><span id="转化为递归式">转化为递归式</span></h4>
<p>考虑和式<span class="math inline">\(S_n = \sum_{ i = 0 }^n f ( i ) =
S_{ n - 1 } + f ( n ) \\\)</span>，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 0 }^n ( - 1 )^i i^2
\\\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>令<span class="math inline">\(S ( n ) = \sum_{ i = 0 }^n ( - 1 )^i
i^2 = S ( n - 1 ) + ( - 1 )^n n^2\)</span>,考虑使用成套方法.</p>
<p>不妨令<span class="math inline">\(S ( n ) = S ( n - 1 ) + ( - 1 )^n (
\alpha + \beta n + \gamma n^2 ) = \alpha A ( n ) + \beta B ( n ) +
\gamma C ( n )\)</span>.</p>
<p>令<span class="math inline">\(S ( n ) = ( - 1 )^n n , 可 以 解 得
\alpha = - 1 , \beta = 2 , \gamma = 0\)</span>,有<span class="math inline">\(( - 1 )^n n = - A ( n ) + 2 B ( n )\)</span>.</p>
<p>令<span class="math inline">\(S ( n ) = ( - 1 )^n n^2 , 可 以 解 得
\alpha = 1 , \beta = - 2 , \gamma = 2\)</span>,有<span class="math inline">\(( - 1 )^n n^2 = A ( n ) - 2 B ( n ) + 2 C ( n
)\)</span>.</p>
<p>显然可解得<span class="math inline">\(2 C ( n ) = ( - 1 )^n n^2 + ( -
1 )^n n , C ( n ) = ( - 1 )^n \frac{ n ( n + 1 ) }{ 2 }\)</span>.</p>
<p>而原式中,<span class="math inline">\(S ( n ) = C ( n ) = ( - 1 )^n
\frac{ n ( n + 1 ) }{ 2 }\)</span>.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5>
<p>有<span class="math inline">\(2 T_n = nT_{ n - 1 } + 3 n ! , T_0 =
5\)</span>,求<span class="math inline">\(T_n\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p>令<span class="math inline">\(s_n = \frac{ 2^{ n - 1 } }{ n !
}\)</span>,两边同时乘以<span class="math inline">\(s_n\)</span>,有<span class="math inline">\(\frac{ 2^n }{ n ! } T_n = \frac{ 2^{ n - 1 } }{ (
n - 1 ) ! } T_{ n - 1 } + 3 \times 2^{ n - 1 } \\\)</span>.</p>
<p>令<span class="math inline">\(S_n = \frac{ 2^n }{ n ! }
T_n\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = S_{ n - 1 } + 3 \times 2^{ n - 1 } \\
&amp; = 5 + 3 \sum_{ i = 0 }^{ n - 1 } 2^i \\
&amp; = 5 + 3 \times 2^{ n + 1 } - 3 \\
&amp; = 3 \times 2^{ n } + 2 \\
T_n &amp; = 3 n ! + \frac{ n ! }{ 2^{ n - 1 } }
\end{aligned}
\]</span></p>
<h4><span id="转化为积分形式">转化为积分形式</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数<span class="math inline">\(f ( x ) = x^2\)</span>,显然<span class="math inline">\(\int_0^n x^2 dx = \frac{ n^3 }{ 3 } \sim S_n
\\\)</span>.</p>
<p>接下来,我们考虑求得二者之间的误差,设<span class="math inline">\(E_n =
S_n - \frac{ n^3 }{ 3 } \\\)</span>,对其使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
E_n &amp; = S_n - \frac{ n^3 }{ 3 } \\
&amp; = S_{ n - 1 } + n^2 - \frac{ ( n - 1 + 1 )^3 }{ 3 } \\
&amp; = S_{ n - 1 } + n^2 - \frac{ ( n - 1 )^3 }{ 3 } - ( n - 1 )^2 - (
n - 1 ) - \frac{ 1 }{ 3 } \\
&amp; = E_{ n - 1 } + n^2 - n^2 + 2 n - 1 - n + 1 - \frac{ 1 }{ 3 } \\
&amp; = E_{ n - 1 } + n - \frac{ 1 }{ 3 }
\end{aligned}
\]</span></p>
<p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<p><span class="math display">\[
\begin{aligned}
E_n &amp; = S_n - \int_0^n x^2 dx \\
&amp; = \sum_{ k = 1 }^n ( k^2 - \int_{ k - 1 }^k x^2 dx ) \\
&amp; = \sum_{ k = 1 }^n ( k^2 - \frac{ k^3 - ( k - 1 )^3 }{ 3 } ) \\
&amp; = \sum_{ k = 1 }^n ( k - \frac{ 1 }{ 3 } )
\end{aligned}
\]</span></p>
<p>这是一个简单的和式.而<span class="math inline">\(S_n = E_n + \frac{
n^3 }{ 3 } \\\)</span>,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5>
<p>已知<span class="math inline">\(a_1 = 1 , a_{ n + 1 } - a_n = -
\frac{ 1 }{ 3 } a_n^2\)</span>,估计<span class="math inline">\(a_n\)</span>的值.</p>
<p>考虑构造一个函数<span class="math inline">\(f ( n )\)</span>使得<span class="math inline">\(f ( n ) \approx a_n\)</span>,那我们就可以将<span class="math inline">\(a_{ n + 1 } - a_n \approx f_n\)</span>.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,<span class="math inline">\(\exists x_0 \in [ n , n + 1 ] , f &#39; ( x_0 ) =
f ( n + 1 ) - f ( n )\)</span>,而对于增长率变化不大的函数,直接认为<span class="math inline">\(f &#39; ( x_0 ) = f &#39; ( n
)\)</span>是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入<span class="math inline">\(f (
1 ) = 1\)</span>解得<span class="math inline">\(f ( n ) = \frac{ 3 }{ n
+ 2 }\)</span>.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令<span class="math inline">\(a_n = \frac{ 3 }{ n + 2 } -
b_n\)</span>,带入化简,得到<span class="math inline">\(\{ b_n
\}\)</span>的递推式:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 3 }{ n + 3 } - b_{ n + 1 } &amp; = ( \frac{ 3 }{ n + 2 } - b_n )
( 1 - \frac{ 1 }{ n + 2 } + \frac{ b_n }{ 3 } ) \\
b_{ n + 1 } - \frac{ 3 }{ n + 3 } &amp; = ( b_n - \frac{ 3 }{ n + 2 } )
( \frac{ n + 1 }{ n + 2 } + \frac{ b_n }{ 3 } ) \\
b_1 &amp; = 0 , b_{ n + 1 } = \frac{ b_n^2 }{ 3 } + \frac{ n }{ n + 2 }
b_n + \frac{ 3 }{ ( n + 2 )^2 ( n + 3 ) }
\end{aligned}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出<span class="math inline">\(b_n \leq \frac{ 1 }{ 4 n
}\)</span>,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个<span class="math inline">\(b_n\)</span>的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设<span class="math inline">\(b_n^2 &lt; &lt; b_n\)</span>:</p>
<p>那么这个<span class="math inline">\(b_n\)</span>是<span class="math inline">\(O ( \frac{ \ln n }{ n^2 } )\)</span>级别的.</p>
<p>如何理解这个级别?考虑别乱动<span class="math inline">\(b_n\)</span>的系数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
b_{ n + 1 } &amp; = \frac{ n }{ n + 2 } b_n + \frac{ 1 }{ n ( n + 1 ) (
n + 2 ) } \\
( n + 1 ) ( n + 2 ) b_{ n + 1 } &amp; = n ( n + 1 ) b_n + \frac{ 1 }{ n
} \\
g ( n ) &amp; = n ( n + 1 ) b_n , g &#39; ( n ) = \frac{ 1 }{ n } , g (
n ) = \ln n \\
b_n &amp; = \frac{ \ln n }{ n^2 }
\end{aligned}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把<span class="math inline">\(O ( n^{
\epsilon } )\)</span>和<span class="math inline">\(O ( 1
)\)</span>搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现<span class="math inline">\(b_n \leq \frac{
3 \ln n }{ n ( n + 1 ) }\)</span>.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ k = 1 }^n k^2 \\
&amp; = \sum_{ k = 1 }^n \sum_{ i = 1 }^k k \\
&amp; = \sum_{ i = 1 }^n \sum_{ k = i }^n k \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( i + n ) ( n - i + 1 ) \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( in - i^2 + i + n^2 - ni + n )
\\
&amp; = \frac{ 1 }{ 2 } ( \sum_{ i = 1 }^n i - \sum_{ i = 1 }^n i^2 +
n^3 + n^2 ) \\
&amp; = \frac{ 1 }{ 4 } n ( n + 1 ) - \frac{ 1 }{ 2 } S_n + \frac{ n^3 +
n^2 }{ 2 }
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(S_n\)</span>.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i 2^i \\\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n i 2^i &amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i 2^i \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n 2^i \\
&amp; = \sum_{ j = 1 }^n ( 2^{ n + 1 } - 2^j ) \\
&amp; = n 2^{ n + 1 } - ( 2^{ n + 1 } - 2 ) \\
&amp; = ( n - 1 ) 2^{ n + 1 } + 2
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i^3 \\\)</span>.</p>
<h5><span id="solution-3">Solution 3</span></h5>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum_{ i = 1 }^n i^3 \\
&amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i i^2 \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n i^2 \\
&amp; = \sum_{ j = 1 }^n ( \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 6 } -
\frac{ ( j - 1 ) j ( 2 j - 1 ) }{ 6 } ) \\
&amp; = \frac{ n^2 ( n + 1 ) ( 2 n + 1 ) }{ 6 } - \frac{ 1 }{ 3 } S ( n
) + \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 12 } - \frac{ n ( n + 1 ) }{ 12 }
\\
S ( n ) &amp; = \frac{ n^2 ( n + 1 )^2 }{ 4 }
\end{aligned}
\]</span></p>
<h5><span id="exampleex">ExampleEX</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n iq^i ( q \ne 1
)\)</span>.</p>
<h5><span id="solutionex">SolutionEX</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n iq^i &amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n q^i \\
&amp; = \sum_{ j = 1 }^n \frac{ q^j - q^{ n + 1 } }{ 1 - q } \\
&amp; = \frac{ 1 }{ q - 1 } \sum_{ j = 1 }^n ( q^{ n + 1 } - q^j ) \\
&amp; = \frac{ 1 }{ q - 1 } ( nq^{ n + 1 } - \frac{ q^{ n + 1 } - q }{ q
- 1 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="exampleex2">ExampleEX2</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n ( ai + b ) q^{ i - 1 }
( q \ne 1 )\)</span>.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令<span class="math inline">\(A = \frac{ a }{ q - 1 } , B = \frac{ b
- A }{ q - 1 }\)</span>,答案为<span class="math inline">\(( An + B ) q^n
- B\)</span>.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子<span class="math inline">\(E\)</span>，使得<span class="math inline">\(Ef ( x ) = f ( x + 1 )\)</span>.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子<span class="math inline">\(\Delta f ( x ) = f ( x + 1 )
- f ( x )\)</span>，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有<span class="math inline">\(\Delta = E -
1\)</span>.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子<span class="math inline">\(\Sigma\)</span>,可以得到有限微积分的基本定理:</p>
$$
<span class="math display">\[\begin{aligned}
g ( x ) &amp; = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f
( x ) + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里的<span class="math inline">\(\Sigma\)</span>又被称为不定和式,是差分等于<span class="math inline">\(g\)</span>的一个函数类.</p>
<p>值得一提的是,这里的<span class="math inline">\(C\)</span>与无限微积分中的<span class="math inline">\(C\)</span>有一定区别,这里的<span class="math inline">\(C\)</span>可以是满足<span class="math inline">\(p
( x ) = p ( x + 1 )\)</span>的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果<span class="math inline">\(g ( x ) = \Delta f ( x
)\)</span>,那么有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = f ( x ) |^{ b }_a = f ( b ) - f ( a ) \\\)</span>.</p>
<p>值得一提的是,如果<span class="math inline">\(a \leq
b\)</span>,显然有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = \sum_{ x = a }^{ b - 1 } g ( x ) \\\)</span>.</p>
<p>但如果<span class="math inline">\(a &gt; b\)</span>,那么<span class="math inline">\(\sum \nolimits_{ a }^b g ( x ) \delta x = - \sum
\nolimits_b^a g ( x ) \delta x \\\)</span>.</p>
<p>事实上,我们一定有:<span class="math inline">\(\sum \nolimits_a^b g (
x ) \delta x + \sum \nolimits_b^c g ( x ) \delta x = \sum \nolimits_a^c
g ( x ) \delta x \\\)</span>.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的<span class="math inline">\(D ( x^m ) = mx^{ m - 1
}\)</span>，有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( x^{ \underline{ m } } ) &amp; = mx^{ \underline{ m - 1 } } \\
\sum mx^{ \underline{ m - 1 } } \delta x &amp; = x^{ \underline{ m } } +
C , m \ne 0 \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的<span class="math inline">\(D ( \ln x ) = \frac{ 1
}{ x }\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( H ( x ) ) &amp; = x^{ \underline{ - 1 } } = \frac{ 1 }{ x + 1 }
\\
\sum x^{ \underline{ - 1 } } \delta x &amp; = H ( x ) + C \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的<span class="math inline">\(D ( e^x ) =
e^x\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( 2^x ) &amp; = 2^x , \sum 2^x \delta x = 2^x + C \\
\Delta ( c^x ) &amp; = ( c - 1 ) c^x , \sum c^x \delta x = \frac{ c^x }{
c - 1 } + C , c \ne 1 \\
\Delta ( c^{ \underline{ x } } ) &amp; = \frac{ c^{ \underline{ x + 2 }
} }{ c - x } , \sum \frac{ c^{ \underline{ x + 2 } } }{ c - x } \delta x
= c^{ \underline{ x } } + C , c - x \ne 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据组合数公式,有:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta ( \binom{ x }{ k } ) &amp; = \binom{ x }{ k - 1 } \\
\sum \binom{ x }{ k - 1 } \delta x &amp; = \binom{ x }{ k } + C
\end{aligned}
\]</span></p>
<h6><span id="example平方和公式">Example(平方和公式)</span></h6>
<p>我们有:<span class="math inline">\(k^2 = k^{ \underline{ 2 } } + k^{
\underline{ 1 } } \\\)</span>.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S_{ n - 1 } &amp; = \sum_{ i = 0 }^{ n - 1 } i^2 \\
&amp; = \sum_{ i = 0 }^{ n - 1 } ( i^{ \underline{ 2 } } + i^{
\underline{ 1 } } ) \\
&amp; = \sum \nolimits_{ 0 }^n x^{ \underline{ 2 } } \delta x + \sum
\nolimits_{ 0 }^n x^{ \underline{ 1 } } \delta x \\
&amp; = \frac{ n^\underline{ 3 } }{ 3 } + \frac{ n^{ \underline{ 2 } }
}{ 2 }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5>
<p>考虑一阶差分是<span class="math inline">\(\Delta f ( x ) = f ( x + 1
) - f ( x )\)</span>,那么二阶差分就是<span class="math inline">\(\Delta^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f
( x )\)</span>.</p>
<p>类似地,我们可以通过归纳法证明<span class="math inline">\(\Delta^n f (
x ) = \sum_{ k } \binom{ n }{ k } ( - 1 )^{ n - k } f ( x + k )
\\\)</span>.</p>
<p>事实上有一种更简单的证明方法,由于<span class="math inline">\(\Delta =
E - 1\)</span>,于是<span class="math inline">\(\Delta^n = ( E - 1 )^n =
\sum_{ k } \binom{ n }{ k } ( - 1 )^{ n - k } E^k \\\)</span>,由于<span class="math inline">\(E^k f ( x ) = f ( x + k
)\)</span>,即可证明原式.</p>
<p>另外,不难发现如果<span class="math inline">\(f ( x
)\)</span>是一个关于<span class="math inline">\(x\)</span>的<span class="math inline">\(d\)</span>次多项式,那么<span class="math inline">\(\Delta f ( x )\)</span>是一个<span class="math inline">\(d - 1\)</span>次多项式.同理,<span class="math inline">\(\Delta^d f ( x )\)</span>会是一个常数而<span class="math inline">\(\Delta^{ d + 1 } f ( x )\)</span>会是<span class="math inline">\(0\)</span>,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6>
<p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为<span class="math inline">\(x_1 , x_2\)</span>.</p>
<p>不难写出期望转移式子:<span class="math inline">\(f_i = \cfrac{ 1 }{ 2
} ( f_{ i - 1 } + f_{ i + 1 } ) + 1\)</span>,并且<span class="math inline">\(f_{ x_1 } = f_{ x_2 } = 0\)</span>.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp; = \cfrac{ 1 }{ 2 } ( f_{ i - 1 } + f_{ i + 1 } ) + 1 \\
2 f_i &amp; = f_{ i - 1 } + f_{ i + 1 } + 2 \\
f_i - f_{ i - 1 } &amp; = f_{ i + 1 } - f_i + 2 \\
\Delta f_{ i - 1 } &amp; = \Delta f_{ i } + 2 \\
\Delta f_i - \Delta f_{ i - 1 } &amp; = - 2 \\
\Delta^2 f_{ i - 1 } &amp; = - 2
\end{aligned}
\]</span></p>
<p><span class="math inline">\(f\)</span>的二阶差分是常数,也就是说<span class="math inline">\(f\)</span>是二次多项式,不难求得其二次项系数为<span class="math inline">\(- 1\)</span>又知道两个零点,显然可以得到<span class="math inline">\(f\)</span>的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5>
<p>令<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } a_i
x^i
\\\)</span>.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } b_i x^{
\underline{ i } } \\\)</span>.</p>
<p>我们设<span class="math inline">\(c_i = i ! b_i\)</span>,于是有:<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } c_i \binom{ x
}{ i } \\\)</span>.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为<span class="math inline">\(f ( x )\)</span>的牛顿级数.</p>
<p>于是不难发现有:<span class="math inline">\(\Delta^n f ( x ) = \sum_{
0 \leq i \leq d } c_i \binom{ x }{ i - n } \\\)</span>.如果我们令<span class="math inline">\(x = 0\)</span>,则有:<span class="math inline">\(\Delta^n f ( 0 ) = \begin{cases}c_n &amp; n \leq d
\\ 0 &amp; n &gt; d\end{cases}\)</span>.那么牛顿级数的另一种表示即:<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } \Delta^i f ( 0
) \binom{ x }{ d } \\\)</span>.</p>
<p>另外,如果我们展开一下<span class="math inline">\(c_n = \Delta^n f ( 0
)\)</span>,我们可以得到公式:</p>
<p><span class="math inline">\(\sum_{ k } \binom{ n }{ k } ( - 1 )^k (
\sum_{ 0 \leq i \leq n } c_i \binom{ k }{ i } ) = ( - 1 )^n c_n , n \in
\mathbb{ N } \\\)</span>.</p>
<p>如果我们将多项式还原,由于<span class="math inline">\(a_n =
b_n\)</span>,有:</p>
<p><span class="math inline">\(\sum_{ k } \binom{ n }{ k } ( - 1 )^k (
\sum_{ 0 \leq i \leq n } a_i k^i ) = ( - 1 )^n n ! a_n , n \in \mathbb{
N } \\\)</span>.</p>
<p>另外,如果<span class="math inline">\(x \in \mathbb{ N
}\)</span>,那么我们有:<span class="math inline">\(f ( x ) = \sum_{ 0
\leq k } \Delta^k f ( 0 ) \binom{ x }{ 0
}\)</span>,根据多项式推理法,这个公式对<span class="math inline">\(\forall x \in \mathbb{ Z }\)</span>都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<p><span class="math display">\[
g ( a + x ) = \sum_{ 0 \leq k } \cfrac{ \Delta^k g ( a ) }{ k ! } x^{
\underline{ k } }
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>求<span class="math inline">\(\sum_{ k } \binom{ n }{ k } \binom{ r -
sk }{ n } ( - 1 )^k , n \in \mathbb{ N } \\\)</span>.</p>
<p>如果我们令<span class="math inline">\(f ( k ) = \binom{ r - sk }{ n }
= \sum_{ 0 \leq i \leq n } a_i k^i \\\)</span>,不难发现<span class="math inline">\(a_n = \cfrac{ ( - 1 )^n s^n }{ n !
}\)</span>,于是显然原式<span class="math inline">\(= s^n\)</span>.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v = Ev \Delta u + u \Delta
v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p><span class="math inline">\(\sum u \Delta v = uv - \sum Ev \Delta u
\\\)</span>.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = l }^{ r - 1 } ( a_{ i + 1 } - a_i ) b_i &amp; = a_r b_r - a_l
b_l - \sum_{ i = l }^{ r - 1 } a_{ i + 1 } ( b_{ i + 1 } - b_i ) \\
\sum_{ i = l }^{ r - 1 } ( \Delta a_i ) b_i &amp; = a_r b_r - a_l b_l -
\sum_{ i = l }^{ r - 1 } a_{ i + 1 } ( \Delta b_i )
\end{aligned}
\]</span></p>
<p>对于<span class="math inline">\(l = 0 , r = n , a_0 = b_0 =
0\)</span>的特殊情况,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } ( \Delta a_i ) b_i &amp; = a_n b_n - \sum_{ i =
0 }^{ n - 1 } a_{ i + 1 } ( \Delta b_i ) \\
\sum_{ i = 1 }^n a_i ( b_{ i + 1 } - b_i ) &amp; = a_n b_n - \sum_{ i =
0 }^{ n - 1 } ( \Delta a_i ) b_i
\end{aligned}
\]</span></p>
<p>取两组数列<span class="math inline">\(\alpha ,
\beta\)</span>,并令<span class="math inline">\(\sum_{ i = 1 }^n \beta_i
= B_i\)</span>,立刻有:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n \alpha_i \beta_i = \alpha_n B_n - \sum_{ i = 1 }^{ n -
1 } ( \alpha_{ i + 1 } - \alpha_i ) B_i
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k 2^k \\\)</span>.</p>
<p>根据分部求和法则，我们有:</p>
<p><span class="math inline">\(\sum x 2^x \delta x = x 2^x - \sum 2^{ x
+ 1 } \delta x = x 2^x - 2^{ x + 1 } + C \\\)</span>.</p>
<p>改为定和式形式，显然有:</p>
<p><span class="math inline">\(\sum_{ k = 0 }^n k 2^k = \sum
\nolimits_0^{ n + 1 } x 2^x \delta x = ( n + 1 ) 2^{ n + 1 } - 2^{ n + 2
} + 2 = ( n - 1 ) 2^{ n + 1 } + 2 \\\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^{ n - 1 } kH_k
\\\)</span>.</p>
<p>令<span class="math inline">\(u ( x ) = H_x , v ( x ) = \frac{ 1 }{ 2
} x^{ \underline{ 2 } } \\\)</span>.</p>
<p>带入分部求和法则，显然有:</p>
<p><span class="math inline">\(\sum xH_x \delta x = \frac{ x^\underline{
2 } }{ 2 } H_x - \frac{ x^\underline{ 2 } }{ 4 } + C \\\)</span>.</p>
<p>带入即可求出原式<span class="math inline">\(= \frac{ n^\underline{ 2
} }{ 2 } ( H_n - \frac{ 1 }{ 2 } ) \\\)</span>.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i (
i + 1 ) } \\\)</span>.</p>
<h6><span id="solution-3">Solution 3</span></h6>
<p>令<span class="math inline">\(u = ( 2 n + 1 ) , v = - \frac{ 1 }{ i
}\)</span>,则<span class="math inline">\(\Delta u = 2 , \Delta v =
\frac{ 1 }{ i ( i + 1 ) }\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i ( i + 1 ) } &amp; = ( 2 n + 3 )
\times ( - \frac{ 1 }{ n + 1 } ) + 3 - \sum_{ i = 1 }^n ( - \frac{ 2 }{
i + 1 } ) \\
&amp; = - \frac{ 2 n + 3 }{ n + 1 } + 2 H_n + \frac{ n + 3 }{ n + 1 } =
2 H_n - \frac{ n }{ n + 1 }
\end{aligned}
\]</span></p>
<h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{
( k + 1 ) ( k + 2 ) } \\\)</span>.</p>
<h6><span id="solution-4">Solution 4</span></h6>
<p>令<span class="math inline">\(u = H_n , v = - \frac{ 1 }{ n + 1 } ,
\Delta u = \frac{ 1 }{ n + 1 } , \Delta v = \frac{ 1 }{ ( n + 1 ) ( n +
2 ) } \\\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{ ( k + 1 ) ( k + 2 ) } &amp; = -
\frac{ H_n }{ n + 1 } - \sum_{ i = 0 }^{ n - 1 } ( - \frac{ 1 }{ ( i + 2
) ( i + 1 ) } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + \sum_{ i = 0 }^{ n - 1 } ( \frac{ 1 }{
i + 1 } - \frac{ 1 }{ i + 2 } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + H_n - ( H_n - 1 + \frac{ 1 }{ n + 1 }
) \\
&amp; = 1 - \frac{ H_n + 1 }{ n + 1 }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">贪心与构造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="贪心">贪心</span></h2>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了<span class="math inline">\(t\)</span>个消息<span class="math inline">\(a_1 ,
a_2 , . . . , a_t\)</span>,那么答案就是<span class="math inline">\(\sum
[ \exists j , m_i = a_j ] \cfrac{ \min ( t , k_i ) }{ t
}\)</span>.显然如果<span class="math inline">\(t\)</span>固定,那么每个<span class="math inline">\(a_j\)</span>的贡献是独立的.于是只需要枚举<span class="math inline">\(t\)</span>然后取贡献最大的.</p>
<p>但是,如果<span class="math inline">\(t &gt; \max \{ k_i
\}\)</span>,这个时候<span class="math inline">\(t -
1\)</span>的答案是<span class="math inline">\(t -
1\)</span>个数之和除以<span class="math inline">\(t - 1\)</span>,<span class="math inline">\(t\)</span>的答案是这<span class="math inline">\(t
- 1\)</span>个数之和加上另一个更小的数除以<span class="math inline">\(t\)</span>,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度<span class="math inline">\(O ( n \max \{ k_i \}
)\)</span>.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分(<span class="math inline">\(b_{ i , j } = a_{ i
, j } \oplus a_{ i + 1 , j } \oplus a_{ i , j + 1 } \oplus a_{ i + 1 , j
+ 1
}\)</span>)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是<span class="math inline">\(0\)</span>了,那么矩阵外不可能是<span class="math inline">\(1\)</span>,也就是原矩阵也全都是<span class="math inline">\(0\)</span>了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成<span class="math inline">\(0\)</span>才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对<span class="math inline">\(( x , y
)\)</span>使用操作四,那我们不可能再对一个<span class="math inline">\(( x
, i )\)</span>使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有<span class="math inline">\(b_{ x , y } ,
b_{ n , y } , b_{ x , m }\)</span>都是<span class="math inline">\(1\)</span>的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个<span class="math inline">\(1\)</span>,所以一定不如直接用一操作来的划算.不然,如果三个都是<span class="math inline">\(1\)</span>,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后<span class="math inline">\(b_{ n , m }\)</span>变成<span class="math inline">\(1\)</span>了,再不行也可以使用一次<span class="math inline">\(1\)</span>操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果<span class="math inline">\(b_{ x , y } , b_{ n , y } , b_{ x , m
}\)</span>都是<span class="math inline">\(1\)</span>,我们就把<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 } &amp; = \max \{ a_{ i + 1 } , f_i + mn \} \\
g_{ i + 1 } &amp; = \min \{ a_{ i + 2 } , g_i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([ f_i , g_i
]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{ i
}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ ans_{ i + 1 } - mx , ans_{ i + 1 } - mn
]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([ f_i , g_i
]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{ i + 1 } - mn &lt; f_i , f_{ i + 1 } &lt;
ans_{ i + 1 } &lt; f_i +
mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx - mn\)</span>.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对<span class="math inline">\(( l ,
r )\)</span>,我们想给每一个点对赋值:<span class="math inline">\(a_l = i
, a_r = n - i + 1\)</span>(注意如果<span class="math inline">\(n\)</span>是奇数,那么中心点应该是<span class="math inline">\(a_{ mid } = \frac{ n + 1 }{ 2
}\)</span>),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对<span class="math inline">\(( l_1 , r_1
)\)</span>,<span class="math inline">\(( l_2 , r_2
)\)</span>之间的三种可能的关系:不交,包含,相交且不包含.会发现若<span class="math inline">\(l\)</span>小则让<span class="math inline">\(a_l\)</span>尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个<span class="math inline">\(\pm
1\)</span>操作很奇怪.我们不妨这么考虑:设最后的答案序列为<span class="math inline">\(b\)</span>,那么答案其实就是<span class="math inline">\(\sum | b_i - a_i
|\)</span>.这实际上是什么呢?实际上是数轴上<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>之间的距离.既然这样,那么我们同时反转<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个<span class="math inline">\(a\)</span>,将它和<span class="math inline">\(x\)</span>同时反转,那么答案不变.这么做后我们可以直接清空所有<span class="math inline">\(a\)</span>的最高位,只剩下<span class="math inline">\(x\)</span>可能有最高位.</p>
<p>那<span class="math inline">\(x\)</span>的最高位一定会让若干<span class="math inline">\(a\)</span>往上变成它.注意到最多只会有一个<span class="math inline">\(a\)</span>会向上满足<span class="math inline">\(x\)</span>的最高位.证明的话同样考虑取反,如果有两个<span class="math inline">\(a\)</span>满足<span class="math inline">\(a_i
\oplus b_i\)</span>和<span class="math inline">\(a_j \oplus
b_j\)</span>这一位是<span class="math inline">\(1\)</span>,我们仍然考虑数轴,有<span class="math inline">\(| not ( b_i ) - a_i | \leq | a_i - b_i
|\)</span>,这由<span class="math inline">\(a_i \oplus
b_i\)</span>最高位是<span class="math inline">\(1\)</span>导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个<span class="math inline">\(a\)</span>上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的<span class="math inline">\(a\)</span>可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作<span class="math inline">\([ l , r , k
]\)</span>表示可以将<span class="math inline">\(a [ l \cdots r
]\)</span>减一进行至多<span class="math inline">\(k\)</span>次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个<span class="math inline">\(- 1\)</span>,另一个<span class="math inline">\(-
2\)</span>,求使得整个序列都小于等于<span class="math inline">\(0\)</span>的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p></li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p></li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p></li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.我们通过样例以及其它栗子发现:有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀,这启发我们:能不能在做后面位置的时候将前面的<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个<span class="math inline">\(( - 2 , - 1
)\)</span>操作,那么我可以在这个位置进行一个<span class="math inline">\((
0 , - 3 )\)</span>操作.显然<span class="math inline">\(( 0 , - 3 ) + ( -
2 , - 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>.我们完成了反悔的操作!</p>
<p>但是,我们直接认为<span class="math inline">\(( - 1 , - 2
)\)</span>不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑<span class="math inline">\(( - 3 , 0
)\)</span>怎么反悔.这个看上去很疑惑:我们为了使<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在<span class="math inline">\(( - 2 , - 1
)\)</span>的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:<span class="math inline">\(( - 3 , 0
)\)</span>这个技能的发动是有前提条件的:前面必须有<span class="math inline">\(( - 2 , - 1
)\)</span>才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个<span class="math inline">\(( - 2 , - 1
)\)</span>,也很清楚每个地方用了几个<span class="math inline">\(( - 3 , 0
)\)</span>.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 2 , -
1 ) = ( - 3 , 0 ) + ( 0 , - 3 )\)</span>,或者<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 1 , -
2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3
)\)</span>.</p>
<p>最后遇到一个点,能用<span class="math inline">\(( 0 , - 3
)\)</span>就用<span class="math inline">\(( 0 , - 3
)\)</span>,不够用的再补齐.这个原因也很简单:如果我们在这里不用<span class="math inline">\(( - 3 , 0
)\)</span>而用其它的代替的话,你会发现无论如何都等价于<span class="math inline">\(( - 3 , 0 )\)</span>然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的<span class="math inline">\(( - 2 , - 1 )\)</span>和<span class="math inline">\(( - 1 , - 2
)\)</span>的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的<span class="math inline">\(( - 3 , 0
)\)</span>操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,保证<span class="math inline">\(a_1 =
a_n = 1\)</span>.每次你可以选择一个<span class="math inline">\(i ( 1
&lt; i &lt; n )\)</span>将<span class="math inline">\(a_i\)</span>删去并付出<span class="math inline">\(a_{ i - 1 } a_i a_{ i + 1
}\)</span>的代价.删去<span class="math inline">\(a_i\)</span>后序列两端会接起来,求删成两个<span class="math inline">\(1\)</span>的最小代价.</p>
<p>首先注意到,如果有一个<span class="math inline">\(1 &lt; i &lt;
n\)</span>满足<span class="math inline">\(a_i =
1\)</span>,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要<span class="math inline">\(1\)</span>的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个<span class="math inline">\(1\)</span>所划分.接下来我们只考虑中间所有数<span class="math inline">\(\geq 2\)</span>的情况.</p>
<p>再思考一个事实:当<span class="math inline">\(a , b \geq
2\)</span>时,一定有<span class="math inline">\(ab \geq a +
b\)</span>.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是<span class="math inline">\(\sum_{ i = 2 }^{ n - 2 } a_i a_{ i + 1 } + \min_{
i = 2 }^{ n - 1 }{ a_i
}\)</span>.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造<span class="math inline">\(a\)</span>数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值<span class="math inline">\(a_i\)</span>,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑<span class="math inline">\(a_i\)</span>互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数<span class="math inline">\(\leq\)</span>还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在<span class="math inline">\(a_i\)</span>相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的<span class="math inline">\(( a_i , a_{ i + 1 } )\)</span>,然后这么选:<span class="math inline">\(a_i , a_{ i + 1 } , a_n , a_{ i - 1 } , a_{ n - 1
} , a_{ i - 2 } . .
.\)</span>,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在<span class="math inline">\(a_i\)</span>上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,其中<span class="math inline">\(2 a
&lt;
b\)</span>.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果<span class="math inline">\(b\)</span>之前吃过别的鱼,假设是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>(不妨假设<span class="math inline">\(d
\geq c\)</span>),有<span class="math inline">\(b = c +
d\)</span>,由鸽笼原理,发现<span class="math inline">\(d &gt;
a\)</span>.这意味着:如果<span class="math inline">\(a\)</span>都没被操作掉,那么<span class="math inline">\(d\)</span>必不可能被操作掉,这也就是说<span class="math inline">\(b\)</span>不可能出现.因此<span class="math inline">\(b\)</span>在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于<span class="math inline">\(b\)</span>,且<span class="math inline">\(a\)</span>就是所有一开始小于<span class="math inline">\(b\)</span>的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是<span class="math inline">\(w_i &gt; 2 \sum_{ j = 1 }^{ i - 1 }
w_j\)</span>,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多<span class="math inline">\(\log
w\)</span>个,我们考虑一下这个两倍的用处,我们按照值域<span class="math inline">\([ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , .
. . , [ 2^{ k - 1 } + 1 , 2^k
]\)</span>将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span>表示标准球.</p></li>
<li><p><span class="math inline">\(&lt; A , B
&gt;\)</span>表示称量集合<span class="math inline">\(A\)</span>和集合<span class="math inline">\(B\)</span>,<span class="math inline">\(&lt; A , B
&gt; = 0\)</span>表示平衡,<span class="math inline">\(&lt; A , B &gt; =
A\)</span>表示<span class="math inline">\(A\)</span>较重,<span class="math inline">\(&lt; A , B &gt; = B\)</span>表示<span class="math inline">\(B\)</span>较重.</p></li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量<span class="math inline">\(x\)</span>有<span class="math inline">\(n\)</span>种取值,出现概率分别为<span class="math inline">\(p_1 , p_2 , \cdots , p_n\)</span>,则其熵为<span class="math inline">\(H ( x ) = f ( p_1 , p_2 , \cdots , p_n ) = \sum{ C
p_i \ln \frac{ 1 }{ p_i } }\)</span>,<span class="math inline">\(C\)</span>为正整数,通常取<span class="math inline">\(1\)</span>.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量<span class="math inline">\(x\)</span>的一个熵为<span class="math inline">\(h\)</span>的信息后,<span class="math inline">\(x\)</span>的熵会减少<span class="math inline">\(h\)</span>.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有<span class="math inline">\(n\)</span>个球,每个球等概率成为次品,因此总熵是<span class="math inline">\(\ln
n\)</span>,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是<span class="math inline">\(\ln 3\)</span>,也就是说我们至少要猜<span class="math inline">\(\frac{ \ln n }{ \ln 3 } = \log_3
n\)</span>次.如果我们不知道次品的轻重,那么至少要猜<span class="math inline">\(\frac{ \ln 2 n }{ \ln 3 } = \log_3 2
n\)</span>次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p><span class="math inline">\(n\)</span>个叶子的树的最小深度是<span class="math inline">\(\lceil \log_3 n
\rceil\)</span>,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设<span class="math inline">\(f ( n )\)</span>表示有<span class="math inline">\(n\)</span>个球的最少次数,注意到<span class="math inline">\(f ( 3 ) = 1\)</span>.</p>
<p>根据信息论,<span class="math inline">\(f ( n ) \geq \lceil \log_3 n
\rceil\)</span>,下面证明等号成立:</p>
<p>首先考虑证明<span class="math inline">\(f ( 3^m ) = m\)</span>,<span class="math inline">\(m = 1\)</span>时已经得证.<span class="math inline">\(m &gt;
1\)</span>时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此<span class="math inline">\(f ( 3^m ) \leq f ( 3^{ m - 1 } ) +
1\)</span>.综合信息论下界<span class="math inline">\(f ( 3^m ) \geq
m\)</span>,我们不难得出以上结论.至于<span class="math inline">\(n \ne
3^m\)</span>的情况,我们类似这个过程按照<span class="math inline">\(n
\bmod 3\)</span>的值讨论一下即可,于是有<span class="math inline">\(f ( n
) \leq f ( \lceil \frac{ n }{ 3 } \rceil ) + 1\)</span>.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,<span class="math inline">\(f ( n ) \geq \lceil \log_3
2 n \rceil\)</span>.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有<span class="math inline">\(n\)</span>个球,第二堆有<span class="math inline">\(m\)</span>个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是<span class="math inline">\(g ( n , m )\)</span>,则<span class="math inline">\(g ( n , m ) = \lceil \log_3 ( n + m )
\rceil\)</span>.</p>
<p>先证明信息论下界,不难发现仍然是<span class="math inline">\(g ( n , m
) = \lceil \log_3 ( n + m ) \rceil\)</span>.</p>
<p>首先不难发现,<span class="math inline">\(g ( 1 , 0 ) = g ( 0 , 1 ) =
0 , g ( 1 , 1 ) = g ( 2 , 0 ) = g ( 0 , 2 ) = 1\)</span>.</p>
<p>仍然使用数学归纳,假设<span class="math inline">\(n + m &lt; k ( k
\geq 3 )\)</span>的时候成立,我们接下来证明<span class="math inline">\(n
+ m = k\)</span>的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若<span class="math inline">\(n = 3 p , m = 3 q\)</span>,我们将<span class="math inline">\(n\)</span>分成等数量的三堆:<span class="math inline">\(A_1 , B_1 , C_1\)</span>,将<span class="math inline">\(m\)</span>分成等质量的三堆<span class="math inline">\(A_2 , B_2 , C_2\)</span>.</p>
<p>接下来称量<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>.</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = 0\)</span>,那么答案在<span class="math inline">\(C_1 \cup
C_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g (
\frac{ n }{ 3 } , \frac{ m }{ 3 } ) + 1\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = A_1 + A_2\)</span>,由于若次品在<span class="math inline">\(A_2\)</span>中,那么它不可能是重球,因此次品不可能在<span class="math inline">\(A_2\)</span>中,同理不可能在<span class="math inline">\(B_1\)</span>中,只可能在<span class="math inline">\(A_1 \cup B_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g ( \frac{ n }{ 3 } , \frac{ m }{ 3
} ) + 1\)</span>.</p></li>
<li><p><span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2 \rangle
= B_1 + B_2\)</span>,同理.</p></li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p><span class="math inline">\(n = 3 p + 1 , m = 3 q +
2\)</span>.此时我们将第一堆分成<span class="math inline">\(A_1 ( p ) ,
B_1 ( p ) , C_1 ( p + 1 )\)</span>,将第二堆分成<span class="math inline">\(A_2 ( q + 1 ) , B_2 ( q + 1 ) , C_2 ( q
)\)</span>,然后<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>,接下来和情况1一样,于是有<span class="math inline">\(g (
n , m ) = \max \{ g ( p , q + 1 ) , g ( p + 1 , q ) \} = \lceil \log_3
\frac{ n + m }{ 3 } \rceil + 1\)</span>.</p>
<p>同理,当<span class="math inline">\(n , m \bmod
3\)</span>的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论<span class="math inline">\(n
\bmod 3\)</span>的值.</p>
<p><strong>情况1</strong></p>
<p>当<span class="math inline">\(n = 3 p\)</span>时,直接分成<span class="math inline">\(A ( p ) , B ( p ) , C ( p )\)</span>,然后<span class="math inline">\(\langle A , B
\rangle\)</span>.如果平衡则接下来需要<span class="math inline">\(f ( p )
= \lceil \log_3 2 p \rceil\)</span>次,不然根据引理,需要<span class="math inline">\(\lceil \log_3 ( p + p )
\rceil\)</span>次,因此<span class="math inline">\(f ( n ) = \lceil
\log_3 2 p \rceil + 1 = \lceil \log_3 6 p \rceil = \lceil \log_3 2 n
\rceil\)</span>.</p>
<p><strong>情况2</strong></p>
<p>当<span class="math inline">\(n = 3 p +
1\)</span>时,一种自然的想法是分成<span class="math inline">\(A ( p + 1 )
, B ( p ) , C ( p
)\)</span>,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了<span class="math inline">\(2 p + 2 , 2 p , 2
p\)</span>,这显然是不优秀的.正确的做法是分成<span class="math inline">\(A = \{ S , 1 , \cdots p \} , B = \{ p + 1 , \cdots
2 p + 1 \} , C = \{ 2 p + 2 , \cdots 3 p + 1
\}\)</span>.由于存在标准球,此时如果<span class="math inline">\(\langle A
, B \rangle = A \ or \ B\)</span>,那么转化成<span class="math inline">\(g ( p , p + 1 ) = \lceil \log_3 ( 2 p + 1 )
\rceil\)</span>,不然转化成<span class="math inline">\(f ( p ) = \lceil
\log_3 2 p \rceil\)</span>.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有<span class="math inline">\(n \bmod 3 =
1\)</span>的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题<span class="math inline">\(f ( n ) = \lceil \log_3 ( 2 n + 2 )
\rceil\)</span>.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将<span class="math inline">\(a\)</span>个球放左边,<span class="math inline">\(b\)</span>个球放右边,<span class="math inline">\(a
\leq b\)</span>,在左边补上<span class="math inline">\(b -
a\)</span>个标准球.</p>
<ol type="1">
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要<span class="math inline">\(\lceil \log_3 ( a + b ) \rceil +
1\)</span>步.</p></li>
<li><p>如果天平平衡,需要<span class="math inline">\(f ( n - a - b ) +
1\)</span>步.</p></li>
</ol>
<p>我们有<span class="math inline">\(f ( n ) = \min_{ a , b } \{ \max \{
f ( n - a - b ) , \lceil \log_3 ( a + b ) \rceil \} \} + 1\)</span>.</p>
<p>注意到接下来的步数只与<span class="math inline">\(a +
b\)</span>有关,取<span class="math inline">\(b - a \leq
1\)</span>,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到<span class="math inline">\(f ( n ) = \lceil
\log_3 ( 2 n - 1 ) \rceil\)</span>.</p>
<p>接下来归纳法就简单了,只需要对于<span class="math inline">\(n \bmod
3\)</span>的余数讨论一下,然后再讨论一下<span class="math inline">\(a\)</span>的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求<span class="math inline">\(n\)</span>所在位置.要求询问次数<span class="math inline">\(\leq \lceil 1 . 5 \log_2 n
\rceil\)</span>,询问区间总长度<span class="math inline">\(\leq 3
n\)</span>.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设<span class="math inline">\(T ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程<span class="math inline">\(T ( n ) = \min_{ m &lt;
n } \{ \max \{ T ( m ) + 1 , T ( n - m ) + 2 \} \}\)</span>.</p>
<p>当然有<span class="math inline">\(m_n \leq m_{ n + 1
}\)</span>,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3>
<h4><span id="模型1">模型1</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,定义域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,表达式<span class="math inline">\(F (
\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_n } \} )\)</span>最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个二元正整数对<span class="math inline">\(( a_i , b_i
)\)</span>,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的<span class="math inline">\(a\)</span>乘上序列中这个二元组之后的所有二元组的<span class="math inline">\(b\)</span>之和的总和,求最小代价.<span class="math inline">\(n , a_i , b_i \leq 10^6\)</span>.</p>
<p>转化为上面的形式,也即:<span class="math inline">\(F ( \{ ( a_1 , b_1
) , . . . , ( a_n , b_n ) \} ) = \sum_{ 1 \leq i &lt; j \leq k } a_i
b_j\)</span>.</p>
<p>考虑调整法,令排列<span class="math inline">\(( q_1 , . . . , q_n ) =
( p_1 , . . . , p_{ i - 1 } , p_{ i + 1 } , p_i , p_{ i + 2 } , . . . ,
p_n )\)</span>.则:</p>
<p><span class="math display">\[
F ( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \}
) - F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n } )
\} ) = a_{ p_i } b_{ p_{ i + 1 } } - a_{ p_{ i + 1 } } b_{ p_i }
\]</span></p>
<p>因而如果<span class="math inline">\(a_{ p_i } b_{ p_{ i + 1 } } - a_{
p_{ i + 1 } } b_{ p_i } &gt; 0\)</span>,则<span class="math inline">\(F
( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \} )
&gt; F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n }
) \} )\)</span>,也就是说<span class="math inline">\(( p_1 , . . . , p_n
)\)</span>不是最优解.因此只有满足<span class="math inline">\(\forall 1
\leq i &lt; n\)</span>,<span class="math inline">\(\cfrac{ a_{ p_i } }{
b_{ p_i } } \leq \cfrac{ a_{ p_{ i + 1 } } }{ b_{ p_{ i + 1 } }
}\)</span>可能是最优解.</p>
<p>如果一个<span class="math inline">\(p\)</span>满足这样的性质,则所有<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的两个位置,是不会使答案改变的.因此直接按照<span class="math inline">\(\cfrac{ a }{ b }\)</span>排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为<span class="math inline">\(S\)</span>,定义<span class="math inline">\(S\)</span>上的一种二元比较关系<span class="math inline">\(\leq\)</span>,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li><p>强完全性:<span class="math inline">\(\forall a , b \in
S\)</span>,<span class="math inline">\(a \leq b \lor b \leq a =
1\)</span>.</p></li>
<li><p>传递性:<span class="math inline">\(\forall a , b , c \in
S\)</span>,<span class="math inline">\(a \leq b , b \leq c \Rightarrow a
\leq c\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in
S\)</span>,如果<span class="math inline">\(a \leq
b\)</span>,则对于任意一个包含<span class="math inline">\(\{ a , b
\}\)</span>作为子段的元素序列<span class="math inline">\(\{ s_1 , . . .
, s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \}\)</span>和<span class="math inline">\(\{ s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 }
, . . . , s_n \}\)</span>都有:<span class="math inline">\(F ( \{ s_1 , .
. . , s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \} ) \leq F ( \{
s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 } , . . . , s_n \}
)\)</span>.</p></li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义<span class="math inline">\(\leq\)</span>后自然也就定义了<span class="math inline">\(=\)</span>,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到<span class="math inline">\(\leq\)</span>的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个包含小写字符的字符串<span class="math inline">\(s_1 , . . . , s_n\)</span>,找到一个<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,将<span class="math inline">\(s_{ p_1 }
, s_{ p_2 } , . . . , s_{ p_n }\)</span>顺序拼接得到<span class="math inline">\(S\)</span>,使<span class="math inline">\(S\)</span>的字典序最小.</p>
<p>令<span class="math inline">\(s \leq t\)</span>当且仅当<span class="math inline">\(s + t\)</span>的字典序<span class="math inline">\(\leq\)</span>t+s</p>
<p>此时我们注意到:<span class="math inline">\(s +
t\)</span>的字典序小于等于<span class="math inline">\(t +
s\)</span>的字典序当且仅当<span class="math inline">\(s^{ \infty } \leq
t^{ \infty }\)</span>.原因是:不妨设<span class="math inline">\(s\)</span>的长度<span class="math inline">\(\leq
t\)</span>的长度.若<span class="math inline">\(s\)</span>不是<span class="math inline">\(t\)</span>的前缀,那显然只需比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(s\)</span>的字典序即可,此时上面两个条件等价;若<span class="math inline">\(s\)</span>是<span class="math inline">\(t\)</span>的前缀,则我们需要比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(t\)</span>的后缀,注意到<span class="math inline">\(t\)</span>的前缀还是<span class="math inline">\(s\)</span>,于是需要比较<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有<span class="math inline">\(n\)</span>个箱子,第<span class="math inline">\(i\)</span>个箱子有重量<span class="math inline">\(w_i\)</span>和承载量<span class="math inline">\(v_i\)</span>,<span class="math inline">\(( w_i ,
v_i &gt; 0
)\)</span>,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化<span class="math inline">\(\min_{ i = 1 }^n \{ v_i -
\sum_{ j = 1 }^{ i - 1 } w_j \}\)</span>,并判断是否<span class="math inline">\(\geq 0\)</span>.</p>
<p>我们令<span class="math inline">\(b_i = - ( v_i + w_i ) , a_i = -
v_i\)</span>,则我们要最大化<span class="math inline">\(\min \{ \sum_{ j
= 1 }^{ i - 1 } b_i - \sum_{ j = 1 }^i a_i \}\)</span>.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义<span class="math inline">\(x \leq y\)</span>当且仅当<span class="math inline">\(F ( \{ x , y \} ) \leq F ( \{ y , x \}
)\)</span>,那么对于两个元素<span class="math inline">\(( a_1 , b_1 ) , (
a_2 , b_2 )\)</span>,显然<span class="math inline">\(( a_1 , b_1 ) \leq
( a_2 , b_2 )\)</span>当且仅当<span class="math inline">\(\min \{ - a_1
, b_1 - a_1 - a_2 \} \geq \min \{ - a_2 , b_2 - a_1 - a_2
\}\)</span>.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li><p>都大于等于第一个元素,则相当于<span class="math inline">\(a_1 \leq
a_2 \land b_1 - a_1 \geq 0\)</span>.</p></li>
<li><p>都大于等于第二个元素,则相当于<span class="math inline">\(b_1 \geq
b_2 \land b_2 - a_2 \leq 0\)</span>.</p></li>
</ol>
<p>可能这里后面和<span class="math inline">\(0\)</span>比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对<span class="math inline">\(b -
a\)</span>的符号进行讨论:</p>
<ol type="1">
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) &gt; sgn ( b_2 -
a_2 )\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 1\)</span>,则不等式成立当且仅当<span class="math inline">\(a_1 \leq
a_2\)</span>.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 0\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = - 1\)</span>,则不等式成立当且仅当<span class="math inline">\(b_1
\geq b_2\)</span>.</p></li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时<span class="math inline">\(b_1 = a_1\)</span>,<span class="math inline">\(b_2
= a_2\)</span>,两条件必有一真.(1)则是因为此时满足<span class="math inline">\(b_1 - a_1 &gt; b_2 - a_2 \land sgn ( b_1 - a_1 )
\geq 0 \land sgn ( b_2 - a_2 ) \leq 0\)</span>.也就有<span class="math inline">\(a_2 - a_1 &gt; b_2 - b_1 \land b_1 \geq a_1 \land
b_2 \leq a_2\)</span>.怎么着都能成立.</p>
<p>由此发现,对于<span class="math inline">\(sgn ( b - a
)\)</span>相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<p><span class="math display">\[
\begin{aligned}
( a_1 , b_1 ) &amp; \leq ( a_2 , b_2 ) \\
\Updownarrow \\
( sgn ( b_1 - a_1 ) &amp; &gt; sgn ( b_2 - a_2 ) ) \\
\lor ( sgn ( b_1 - a_1 ) &amp; = sgn ( b_2 - a_2 ) \land F ( \{ 1 , 2 \}
) \leq F ( \{ 2 , 1 \} )
\end{aligned}
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,值域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于给定整数<span class="math inline">\(k\)</span>,所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>的长度为<span class="math inline">\(k\)</span>的子序列,表达式<span class="math inline">\(F ( \{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\} )\)</span>最小值.</p>
<p>如果<span class="math inline">\(k =
n\)</span>,则就是模型1.不然,我们考虑先选出一个大小为<span class="math inline">\(k\)</span>的子集,然后使用模型1.不难发现,我们最后取出的<span class="math inline">\(\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\}\)</span>一定是<span class="math inline">\(n =
k\)</span>时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有<span class="math inline">\(n\)</span>个物品,第<span class="math inline">\(i\)</span>个物品有非负费用<span class="math inline">\(c_i\)</span>和价值<span class="math inline">\(v_i\)</span>,两个人进行如下博弈:</p>
<ol type="1">
<li><p>第一个人要么选择一个物品,付出<span class="math inline">\(c_i\)</span>的代价;要么选择结束游戏.</p></li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行<span class="math inline">\(k\)</span>次);也可以选择不操作,此时第一个人获得<span class="math inline">\(v_i\)</span>的收益,博弈结束.</p></li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.<span class="math inline">\(( n \leq 1 . 5 \times 10^5 , k \leq 9
)\)</span></p></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择<span class="math inline">\(k + 1\)</span>个,然后收益为<span class="math inline">\(\min_{ i = 1 }^{ k - 1 } \{ v_{ x_i } - \sum_{ j =
1 }^i c_{ x_j }
\}\)</span>(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度<span class="math inline">\(O ( n \log n + nk )\)</span>.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有<span class="math inline">\(n\)</span>条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有<span class="math inline">\(n\)</span>条直线的答案,求<span class="math inline">\(n +
1\)</span>条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度<span class="math inline">\(a_1 , \cdots , a_n \in \{
90 \degree , 270 \degree \}\)</span>,要求构造一个<span class="math inline">\(n\)</span>边形(边必须平行于坐标轴),使得其内角依次是<span class="math inline">\(a_1 , \cdots , a_n\)</span>.</p>
<p>首先有解条件显然是判定它们的和是否是<span class="math inline">\(180
\degree ( n - 2 )\)</span>.</p>
<p>注意到相邻的<span class="math inline">\(90 \degree\)</span>和<span class="math inline">\(270
\degree\)</span>无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让<span class="math inline">\(S \rightarrow
T\)</span>.这个时候可以找一个中间状态<span class="math inline">\(A\)</span>,让<span class="math inline">\(S
\rightarrow A , T \rightarrow A\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有<span class="math inline">\(( X , 0
)\)</span>亮着,每次把<span class="math inline">\(( x , y
)\)</span>,<span class="math inline">\(( x , y + 1 )\)</span>,<span class="math inline">\(( x + 1 , y
)\)</span>状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p><span class="math inline">\(n \leq 10^5\)</span>,坐标的绝对值均<span class="math inline">\(\leq 10^{ 17 }\)</span>.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线<span class="math inline">\(y = - inf\)</span>,然后比对.我们注意到<span class="math inline">\(( X , 0
)\)</span>向下推的过程类似一个组合数递推的过程,由经典公式<span class="math inline">\(\binom{ S }{ T } \equiv [ T \subseteq S ] \bmod
2\)</span>可知,我们取<span class="math inline">\(inf = 2^{ 63 } -
1\)</span>即可.然后最后在这条线上一定是有一个区间是<span class="math inline">\(1\)</span>,我们需要找到区间左端点,我们选择在直线上随便找到一个<span class="math inline">\(1\)</span>,由于<span class="math inline">\(inf\)</span>很大,大于<span class="math inline">\(10^{ 17
}\)</span>,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,<span class="math inline">\(n \leq
10^4\)</span>,但是初始点可能是<span class="math inline">\(( X , Y
)\)</span>.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点<span class="math inline">\(( j , - inf )\)</span>和<span class="math inline">\(( k , - inf
)\)</span>是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>.而上述条件满足当且仅当<span class="math inline">\([ j - X \subseteq Y + inf ]\)</span>.</p>
<p>如果我们随便找一个点<span class="math inline">\(( p , - inf
)\)</span>满足条件,那我们接下来只需要枚举<span class="math inline">\(w\)</span>,判断<span class="math inline">\(( p -
2^w , - inf
)\)</span>是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间<span class="math inline">\([ l , r
]\)</span>中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">计算几何</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2>
<p>参考:https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3>
<h4><span id="eps">eps</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec{ a } \cdot \vec{ b } = | \vec{
a } | | \vec{ b } | \cos \theta = x_a x_b + y_a
y_b\)</span>.也就等于<span class="math inline">\(\vec{ a
}\)</span>在<span class="math inline">\(b\)</span>上的投影与<span class="math inline">\(\vec{ b }\)</span>的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } =
0\)</span>,则说明<span class="math inline">\(\vec{ a } \bot \vec{ b
}\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } &gt;
0\)</span>,则说明<span class="math inline">\(\vec{ a }\)</span>和<span class="math inline">\(\vec{ b }\)</span>正方向的夹角小于<span class="math inline">\(90 \degree\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } &lt;
0\)</span>,则说明<span class="math inline">\(\vec{ a }\)</span>和<span class="math inline">\(\vec{ b }\)</span>正方向的夹角大于<span class="math inline">\(90 \degree\)</span>.</p></li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec{ a } \times \vec{ b } = x_a
y_b - y_a x_b\)</span>.也就等于<span class="math inline">\(\vec{ a } ,
\vec{ b }\)</span>两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } =
0\)</span>,说明二者共线.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } &lt;
0\)</span>,说明从<span class="math inline">\(\vec{ a }\)</span>到<span class="math inline">\(\vec{ b }\)</span>的方向是顺时针.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } &gt;
0\)</span>,说明从<span class="math inline">\(\vec{ a }\)</span>到<span class="math inline">\(\vec{ b }\)</span>的方向是逆时针.</p></li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵<span class="math inline">\(\begin{bmatrix}\cos \theta &amp; - \sin \theta \\
\sin \theta &amp; \cos \theta\end{bmatrix}\)</span>.</p>
<h4><span id="line">Line</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下<span class="math inline">\(x_{ L_1 } , x_{ L_2 } ,
y_{ L_1 } , y_{ L_2
}\)</span>围成的四边形,计算面积后用等高不等底计算.注意<span class="math inline">\(ls\)</span>和<span class="math inline">\(rs\)</span>所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4>
<p>利用叉乘,任取平面上一点<span class="math inline">\(O\)</span>,则<span class="math inline">\(S = \frac{ 1 }{ 2 } \sum_{ i = 1 }^n
\overrightarrow{ OP_i } \times \overrightarrow{ OP_{ i + 1 }
}\)</span>.证明的话考虑分<span class="math inline">\(O\)</span>在内部和<span class="math inline">\(O\)</span>在外部两种情况分类讨论.注意此时的<span class="math inline">\(P\)</span>必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为<span class="math inline">\(a\)</span>,它的边上(包括顶点)的整点数为<span class="math inline">\(b\)</span>,则它的面积<span class="math inline">\(S
= a + \frac{ b }{ 2 } - 1\)</span>.</p>
<h3><span id="基本算法">基本算法</span></h3>
<h4><span id="排序算法">排序算法</span></h4>
<h5><span id="极角排序">极角排序</span></h5>
<p>定义原点<span class="math inline">\(O\)</span>并建立坐标系,所有点按照和<span class="math inline">\(O\)</span>所连直线与<span class="math inline">\(x\)</span>轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(x\)</span>相同比<span class="math inline">\(y\)</span>,否则比<span class="math inline">\(x\)</span>.</p>
<h4><span id="二维凸包">二维凸包</span></h4>
<h5><span id="定义">定义</span></h5>
<p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5>
<p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否<span class="math inline">\(ABC\)</span>三点是一个上凸的(注意<span class="math inline">\(ABC\)</span>三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5>
<p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4>
<p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5>
<p>两个区域<span class="math inline">\(A ,
B\)</span>的闵可夫斯基和定义为<span class="math inline">\(\{ a + b \mid
a \in A , b \in B \}\)</span>.</p>
<h5><span id="实现">实现</span></h5>
<p>事实上,新的区域所形成的凸包,一定是原本<span class="math inline">\(A ,
B\)</span>的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下<span class="math inline">\(A , B\)</span>,使得<span class="math inline">\(B\)</span>有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是<span class="math inline">\(B\)</span>这个边加上<span class="math inline">\(A\)</span>的最右边的点.这样这条边必定还在最终的凸包上.就算<span class="math inline">\(A\)</span>最右边的是一条边,你也会发现最终的凸包最右边也一定是由<span class="math inline">\(A\)</span>的这条边和<span class="math inline">\(B\)</span>的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义半平面为满足<span class="math inline">\(ax + by + c &gt;
0\)</span>或<span class="math inline">\(ax + by + c \geq
0\)</span>的点对<span class="math inline">\(( x , y
)\)</span>组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5>
<p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2>
<p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3>
<h4><span id="直线">直线</span></h4>
<p>使用直线的方向向量<span class="math inline">\(\vec{ s } = ( n , m , p
)\)</span>和直线上一点<span class="math inline">\(M_0 = ( x_0 , y_0 ,
z_0 )\)</span>.那么方程显然为:</p>
<p><span class="math display">\[
\frac{ x - x_0 }{ n } = \frac{ y - y_0 }{ m } = \frac{ z - z_0 }{ p }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x_0 + nt \\
y = y_0 + mt \\
z = z_0 + pt
\end{cases}
\]</span></p>
<h4><span id="平面">平面</span></h4>
<p>使用平面上的一点<span class="math inline">\(P_0 ( x_0 , y_0 , z_0
)\)</span>和该平面的法向量<span class="math inline">\(\vec{ n
}\)</span>来表示一个平面,不妨设<span class="math inline">\(\vec{ n } = (
A , B , C )\)</span>,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x_0 ) + B ( y - y_0 ) + C ( z - z_0 ) = 0
\]</span></p>
<p>如果我们令<span class="math inline">\(D = - ( Ax_0 + By_0 +
Cz_)\)</span>,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h4><span id="夹角">夹角</span></h4>
<h5><span id="两直线夹角">两直线夹角.</span></h5>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是<span class="math inline">\(\vec{ s_1 } = ( n_1 ,
m_1 , p_1 ) , \vec{ s_2 } = ( n_2 , m_2 , p_2 )\)</span>,也就有<span class="math inline">\(\varphi = \arccos ( \frac{ | \vec{ s }_1 \cdot
\vec{ s }_2 | }{ | \vec{ s }_1 | | \vec{ s }_2 | } ) \\\)</span>.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5>
<p>同样使用向量,不妨设方向向量<span class="math inline">\(\vec{ s } = (
n , m , p )\)</span>,法向量<span class="math inline">\(\vec{ f } = ( a ,
b , c )\)</span>,那么<span class="math inline">\(\varphi = \arcsin (
\frac{ | \vec{ s } \cdot \vec{ f } | }{ | \vec{ s } | | \vec{ f } | }
)\)</span>.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则<span class="math inline">\(am + bn + cp =
0\)</span>.</p></li>
<li><p>若直线与平面垂直,则<span class="math inline">\(\frac{ a }{ m } =
\frac{ b }{ n } = \frac{ c }{ p }\)</span>.注意这里分母可能除以<span class="math inline">\(0\)</span>,我们实际上应该是三个形如<span class="math inline">\(a = mt\)</span>的参数方程,这里简化了.</p></li>
</ol>
<h4><span id="交点">交点</span></h4>
<p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">范畴论初步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2>
<h3><span id="映射">映射</span></h3>
<p>设<span class="math inline">\(A , B\)</span>为两个集合,<span class="math inline">\(\varphi\)</span>称为从<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的一个<strong>映射</strong>,如果对于任意<span class="math inline">\(a \in A\)</span>,<span class="math inline">\(\exists b \in B , b = \varphi ( a
)\)</span>.此时<span class="math inline">\(b\)</span>称为<span class="math inline">\(a\)</span>在<span class="math inline">\(\varphi\)</span>下的像,<span class="math inline">\(a\)</span>称为<span class="math inline">\(b\)</span>在<span class="math inline">\(\varphi\)</span>下的原像或反像.一般地,这个定义可以拓展到<span class="math inline">\(S \subseteq A\)</span>,<span class="math inline">\(\varphi ( S ) = \{ \varphi ( a ) \mid a \in S
\}\)</span>,定义<span class="math inline">\(\varphi^{ - 1 } ( T ) = \{ a
| \varphi ( a ) \in T , a \in S \}\)</span>.</p>
<p>如果<span class="math inline">\(\forall a_1 , a_2 \in A , a_1 \ne a_2
, \varphi ( a_1 ) \ne \varphi ( a_2 )\)</span>,称<span class="math inline">\(\varphi\)</span>是<strong>单射</strong>.</p>
<p>如果<span class="math inline">\(\forall b \in B , \exists a \in A ,
\varphi ( a ) = b\)</span>.称<span class="math inline">\(\varphi\)</span>为<strong>满射</strong>.</p>
<p>如果<span class="math inline">\(\varphi\)</span>既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果<span class="math inline">\(A = B\)</span>,我们又称<span class="math inline">\(\varphi\)</span>为一个<strong>变换</strong>.</p>
<p>设<span class="math inline">\(f : A \rightarrow B , g : B \rightarrow
A\)</span>,那么:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(g \circ f = id_A\)</span>,称<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的一个<strong>左逆</strong>,不难发现<span class="math inline">\(f\)</span>存在左逆当且仅当<span class="math inline">\(f\)</span>是单射.</p></li>
<li><p>如果<span class="math inline">\(f \circ g = id_B\)</span>,称<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的一个<strong>右逆</strong>,不难发现<span class="math inline">\(f\)</span>存在右逆当且仅当<span class="math inline">\(f\)</span>是满射.</p></li>
<li><p>如果<span class="math inline">\(g\)</span>既是<span class="math inline">\(f\)</span>的左逆又是<span class="math inline">\(f\)</span>的右逆,则称<span class="math inline">\(g\)</span>为<span class="math inline">\(f\)</span>的<strong>逆</strong>,不难发现<span class="math inline">\(f\)</span>存在逆当且仅当<span class="math inline">\(f\)</span>是双射,并且逆唯一.</p></li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3>
<p>集合<span class="math inline">\(A ,
B\)</span>的<strong>笛卡尔积</strong>或<strong>直积</strong>是指<span class="math inline">\(A\)</span>的元素与<span class="math inline">\(B\)</span>的元素构成的有序对的集合,即<span class="math inline">\(A \times B = \{ ( a , b ) \mid a \in A , b \in B
\}\)</span>.可以推广到多元对.</p>
<p>集合<span class="math inline">\(A\)</span>上的一个<strong>二元运算</strong>是由<span class="math inline">\(A \times A\)</span>到<span class="math inline">\(A\)</span>的一个映射.对于定义在<span class="math inline">\(U\)</span>上的一个二元运算,不妨用<span class="math inline">\(+\)</span>来表示,集合<span class="math inline">\(A
, B \subseteq U\)</span>的<strong>闵可夫斯基和</strong>定义为<span class="math inline">\(A + B = \{ a + b \mid a \in A , b \in B
\}\)</span>.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合<span class="math inline">\(A\)</span>上的一个<strong>二元关系</strong><span class="math inline">\(R\)</span>定义为<span class="math inline">\(A
\times A\)</span>的一个子集(可以理解为满足二元关系的解集),如果<span class="math inline">\(( a_1 , a_2 ) \in R\)</span>,就称<span class="math inline">\(a_1 , a_2\)</span>有关系<span class="math inline">\(R\)</span>,记作<span class="math inline">\(a_1
Ra_2\)</span>,注意这里有序.</p>
<p>如果<span class="math inline">\(R\)</span>满足以下三个性质:</p>
<ol type="1">
<li><p>反身性:<span class="math inline">\(\forall a \in A ,
aRa\)</span>.</p></li>
<li><p>对称性:<span class="math inline">\(a_1 Ra_2 \Leftrightarrow a_2
Ra_1\)</span>.</p></li>
<li><p>传递性:<span class="math inline">\(a_1 Ra_2 , a_2 Ra_3
\Leftrightarrow a_1 Ra_3\)</span>.</p></li>
</ol>
<p>则称<span class="math inline">\(R\)</span>是一个<strong>等价关系</strong>,不难发现满足等价关系的元素构成了若干个集合,称作<strong>等价类</strong>.等价关系通常记作<span class="math inline">\(\sim\)</span>.</p>
<p>如果将等价关系的(2)改作:</p>
<ol start="2" type="1">
<li>反对称性:<span class="math inline">\(a_1 Ra_2 , a_2 Ra_1
\Leftrightarrow a_1 = a_2\)</span>.</li>
</ol>
<p>则称<span class="math inline">\(R\)</span>是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作<span class="math inline">\(\leq\)</span>.</p>
<h4><span id="保序映射">保序映射</span></h4>
<p>对于映射<span class="math inline">\(f : A \rightarrow
B\)</span>,如果<span class="math inline">\(\forall a , a &#39; \in A , a
\leq a &#39; \Rightarrow f ( a ) \leq f ( a &#39;
)\)</span>,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4>
<p>对于偏序集<span class="math inline">\(( A , R
)\)</span>来说,定义:</p>
<ol type="1">
<li><p>链:<span class="math inline">\(A &#39; \subseteq A , \forall x ,
y \in A &#39; , [ xRy \lor yRx ] = 1\)</span>.</p></li>
<li><p>反链:<span class="math inline">\(A &#39; \subseteq A , \forall x
, y \in A &#39; , [ xRy \lor yRx ] = 0\)</span>.</p></li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p></li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,<span class="math inline">\(| A | \leq
3\)</span>显然成立.</p>
<p>当<span class="math inline">\(| A | &gt;
3\)</span>时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为<span class="math inline">\(d\)</span>,下面证明其最小链覆盖也是<span class="math inline">\(d\)</span>.</p>
<p>考虑取一条尽可能长的链<span class="math inline">\(A
&#39;\)</span>,设其中最大的为<span class="math inline">\(M\)</span>,最小的为<span class="math inline">\(m\)</span>(如果有多个就任取一个).</p>
<p>考虑<span class="math inline">\(T = A \setminus A
&#39;\)</span>,如果<span class="math inline">\(T\)</span>中的最长反链数小于<span class="math inline">\(d\)</span>,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链<span class="math inline">\(S\)</span>,使得<span class="math inline">\(S \cap
A &#39; = \emptyset\)</span>.考虑设<span class="math inline">\(A^{ + } =
\{ x | x \in A \land \exists s \in S , sRx \}\)</span>,<span class="math inline">\(A^{ - } = \{ x | x \in A \land \exists s \in S ,
xRs \}\)</span>.不难发现<span class="math inline">\(m\)</span>一定不在<span class="math inline">\(|
A^{ + } |\)</span>中,不然取出的那条链<span class="math inline">\(A
&#39;\)</span>可以更长.同理<span class="math inline">\(M\)</span>一定不在<span class="math inline">\(|
A^{ - } |\)</span>中,也即<span class="math inline">\(| A^+ | , | A^- |
&lt; | A |\)</span>.</p>
<p>我们又发现<span class="math inline">\(A^+ \cup A^- =
A\)</span>,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,<span class="math inline">\(S
\subseteq A^{ + } \cap A^{ - }\)</span>.</p>
<p>由数学归纳,<span class="math inline">\(A^+\)</span>和<span class="math inline">\(A^-\)</span>中的最小链覆盖均为<span class="math inline">\(d\)</span>,并且一个以<span class="math inline">\(S\)</span>中元素开头,一个以<span class="math inline">\(S\)</span>中元素结尾,我们把它俩拼起来就是一个大小为<span class="math inline">\(d\)</span>的新的大小为<span class="math inline">\(d\)</span>的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4>
<p>考虑定义一种等价关系<span class="math inline">\(\sim\)</span>,我们可以在此基础上定义商集<span class="math inline">\(A / \sim = \{ [ a ] | a \in A
\}\)</span>,其中<span class="math inline">\([ a ]\)</span>是<span class="math inline">\(a\)</span>所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过<span class="math inline">\(\mathbb{ N
}\)</span>来定义<span class="math inline">\(\mathbb{ Z
}\)</span>.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系<span class="math inline">\(\sim\)</span>,<span class="math inline">\(( n , m
) \sim ( n &#39; , m &#39; )\)</span>当且仅当<span class="math inline">\(n + m &#39; = m + n
&#39;\)</span>.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将<span class="math inline">\(\mathbb{ N } /
\sim\)</span>定义为整数,更确切地,对于任意一组<span class="math inline">\(( n , m )\)</span>其代表的就是<span class="math inline">\(n - m\)</span>这个整数.</p>
<p>容易定义加法:<span class="math inline">\(( n , m ) + ( n &#39; , m
&#39; ) = ( n + n &#39; , m + m &#39; )\)</span>,乘法<span class="math inline">\(( n , m ) \times ( n &#39; , m &#39; ) = ( mm
&#39; + nn &#39; , mn &#39; + m &#39; n
)\)</span>.也可以定义大小关系<span class="math inline">\(( n , m ) \leq
( n &#39; , m &#39; ) \Leftrightarrow n + m &#39; \leq m + n
&#39;\)</span>.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义<span class="math inline">\(- ( n , m ) = ( m , n
)\)</span>即可,容易验证二者之和处于<span class="math inline">\(( 0 , 0
)\)</span>这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用<span class="math inline">\(\mathbb{ Z }\)</span>构造<span class="math inline">\(\mathbb{ Q }\)</span>,构造二元组<span class="math inline">\(\mathbb{ Z } \times \mathbb{ N
}_+\)</span>,定义<span class="math inline">\(( r , s ) \sim ( r &#39; ,
s &#39; ) \Leftrightarrow rs &#39; = r &#39;
s\)</span>,容易验证其满足等价关系的性质.实际上其对应的就是<span class="math inline">\(\frac{ r }{ s
}\)</span>这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3>
<h4><span id="外延公理">外延公理</span></h4>
<p><span class="math inline">\(A = B \Leftrightarrow ( A \subset B )
\land ( B \subset A )\)</span>.</p>
<h4><span id="配对公理">配对公理</span></h4>
<p>对于任意元素<span class="math inline">\(a , b\)</span>,存在集合<span class="math inline">\(\{ a , b \}\)</span>.特别地,当<span class="math inline">\(a = b\)</span>的时候存在集合<span class="math inline">\(\{ a \}\)</span>.</p>
<p>值得一提的是可以将数对<span class="math inline">\(( a , b
)\)</span>定义为<span class="math inline">\(\{ \{ a \} , \{ a , b \}
\}\)</span>,下面的幂集公理说明了数对属于<span class="math inline">\(2^{
2^{ A \cup B } } , a \in A , b \in B\)</span>.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4>
<p>对于一个集合<span class="math inline">\(A\)</span>,和一个性质<span class="math inline">\(P\)</span>,若<span class="math inline">\(\alpha\)</span>满足性质<span class="math inline">\(P\)</span>则称<span class="math inline">\(P (
\alpha )\)</span>.那么存在集合:</p>
<p><span class="math display">\[
\{ x | x \in A \land P ( x ) \}
\]</span></p>
<p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质<span class="math inline">\(P\)</span>都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4>
<p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4>
<p>一个集合的所有子集构成一个新的集合(可以记作<span class="math inline">\(2^A\)</span>).</p>
<h4><span id="无穷公理">无穷公理</span></h4>
<p>称满足以下性质的集合为归纳集:</p>
<ol type="1">
<li><p><span class="math inline">\(\emptyset \in A\)</span>.</p></li>
<li><p>若<span class="math inline">\(\alpha \in A\)</span>,则<span class="math inline">\(\{ \alpha \} \cup \alpha \in A\)</span>.</p></li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4>
<p>对于集合<span class="math inline">\(A\)</span>和一种定义在集合<span class="math inline">\(A\)</span>上的映射<span class="math inline">\(F\)</span>,存在集合<span class="math inline">\(A
&#39;\)</span>使得<span class="math inline">\(x \in A &#39;
\Leftrightarrow x = F ( a ) , a \in A\)</span>.</p>
<p>用替换公理可以证明映射也是一种集合,并且从<span class="math inline">\(A \rightarrow
B\)</span>的所有映射可以构成集合,可以记作<span class="math inline">\(B^A\)</span>.</p>
<h4><span id="正则公理">正则公理</span></h4>
<p>对任何非空集合<span class="math inline">\(A\)</span>,存在<span class="math inline">\(a \in A\)</span>使得<span class="math inline">\(\forall a &#39; \in A\)</span>,<span class="math inline">\(a &#39; \notin a\)</span>,也就是<span class="math inline">\(a \cap A = \emptyset\)</span>.</p>
<h4><span id="选择公理">选择公理</span></h4>
<p>说对于任何一族非空集<span class="math inline">\(A\)</span>,总能从其中的每个集合<span class="math inline">\(a\)</span>选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5>
<p>如果<span class="math inline">\(X\)</span>上的一个偏序关系<span class="math inline">\(\leq\)</span>,满足其每条链<span class="math inline">\(A\)</span>都存在上界(<span class="math inline">\(\exists x \in X , \forall a \in A , x \geq
a\)</span>),那么<span class="math inline">\(X\)</span>存在极大元<span class="math inline">\(( \exists x \in X , \forall a \in X , a \geq x
\Rightarrow a = x )\)</span>.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系<span class="math inline">\(( A &#39; &#39; , g &#39; &#39; ) \leq ( A &#39; ,
g &#39; )\)</span>当且仅当<span class="math inline">\(A &#39; &#39;
\subseteq A &#39;\)</span>并且<span class="math inline">\(\forall x \in
A &#39; &#39; , g &#39; &#39; ( x ) = g &#39; ( x
)\)</span>.这样拿出来的极大元就是我们需要的<span class="math inline">\(A
\rightarrow g ( A )\)</span>.</p>
<h5><span id="良序定理">良序定理</span></h5>
<p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对<span class="math inline">\(( S , R )\)</span>组成的集合,其中满足<span class="math inline">\(S\)</span>对于偏序关系<span class="math inline">\(R\)</span>来说是良序的,我们定义两个二元对<span class="math inline">\(a , b\)</span>满足<span class="math inline">\(a
\leq b\)</span>当且仅当它们的<span class="math inline">\(R\)</span>相等并且<span class="math inline">\(S_a
\subseteq
S_b\)</span>.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)<span class="math inline">\(( S , R )\)</span>,注意到如果<span class="math inline">\(S\)</span>是全集则证毕,如果不是,则取一个全集中不在<span class="math inline">\(S\)</span>的元素<span class="math inline">\(x\)</span>接到<span class="math inline">\(S\)</span>的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3>
<p>如果存在单射<span class="math inline">\(\varphi : A \rightarrow
B\)</span>,则称<span class="math inline">\(| A | \leq | B
|\)</span>.如果存在双射,则称<span class="math inline">\(| A | = | B
|\)</span>.</p>
<p>如果使用选择公理的话,可以说明如果存在满射<span class="math inline">\(\varphi : A \rightarrow B\)</span>,则称<span class="math inline">\(| A | \geq | B |\)</span>.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有<span class="math inline">\(A ,
B\)</span>两个集合,接下来我们证明一定存在一个从<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的映射,且其要么为单射要么为满射.</p>
<p>我们记<span class="math inline">\(X\)</span>为所有<span class="math inline">\(A\)</span>的子集到<span class="math inline">\(B\)</span>的单射组成的集合,并且我们定义这样一种偏序关系:若<span class="math inline">\(f : A_f \rightarrow B , g : A_g \rightarrow B ,
A_f \subseteq A_g , \forall a \in A_f , f ( a ) = g ( a )\)</span>.</p>
<p>这样的话,我们不妨取出<span class="math inline">\(X\)</span>的一个全序的子集<span class="math inline">\(I\)</span>,显然其存在上界.</p>
<p>根据Zorn引理,<span class="math inline">\(X\)</span>存在极大元<span class="math inline">\(g : A_g \rightarrow
B\)</span>,此时我们开始讨论:</p>
<p>如果<span class="math inline">\(A_g =
A\)</span>,那么找到了一个单射<span class="math inline">\(g : A
\rightarrow B\)</span>.</p>
<p>反之,如果<span class="math inline">\(A_g \subsetneq
A\)</span>,考虑如果<span class="math inline">\(g ( A_g ) =
B\)</span>,也就是找到了一个满射;反之,考虑取<span class="math inline">\(a
&#39; \in A \setminus A_g , b &#39; \in B \setminus g ( A_g
)\)</span>,在<span class="math inline">\(g\)</span>的基础上加上映射<span class="math inline">\(a &#39; \mapsto b &#39;\)</span>,这是一个比<span class="math inline">\(g\)</span>还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4>
<p>如果<span class="math inline">\(| A | \leq | B | \land | B | \leq | A
|\)</span>,则<span class="math inline">\(| A | = | B |\)</span>.</p>
<p>不妨设<span class="math inline">\(f : A \rightarrow B , g : B
\rightarrow
A\)</span>我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用<span class="math inline">\(f , f^{ - 1
}\)</span>来构造双射,只有一种除外:那就是以一个<span class="math inline">\(B\)</span>中节点开始不断延伸的无限的,我们在这里使用<span class="math inline">\(g , g^{ - 1 }\)</span>来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取<span class="math inline">\(C_0 = B \setminus f ( A )\)</span>,<span class="math inline">\(C_n = f ( g ( C_{ n - 1 } )
)\)</span>,那么对于<span class="math inline">\(C = \cup_{ n \geq 0 }
C_n\)</span>,使用<span class="math inline">\(g , g^{ - 1
}\)</span>构造双射,剩下的使用<span class="math inline">\(f , f^{ - 1
}\)</span>构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4>
<p>我们称集合<span class="math inline">\(A\)</span>是<strong>可数</strong>的,当且仅当<span class="math inline">\(| A | = | \mathbb{ N } |\)</span>.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是<span class="math inline">\(0\)</span>)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>显然都是代数数.</p>
<p>我们接下来看两个代数数<span class="math inline">\(x ,
y\)</span>.考虑如何构造<span class="math inline">\(x +
y\)</span>作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<p><span class="math display">\[
\begin{aligned}
X &amp; = \sum_{ k = 0 }^n a_k x^k = 0 \\
Y &amp; = \sum_{ k = 0 }^m b_k y^k = 0
\end{aligned}
\]</span></p>
<p>对于加法,考虑:<span class="math inline">\(( x + y )^0 , ( x + y )^1 ,
\cdots\)</span>,这些东西,先把它们对<span class="math inline">\(X\)</span>取膜再对<span class="math inline">\(Y\)</span>取膜,得到的一定是<span class="math inline">\(nm\)</span>维的,只需要取<span class="math inline">\(nm +
1\)</span>个就会出现线性相关.乘法同理考虑<span class="math inline">\((
xy )^0 , ( xy )^1 , \cdots\)</span>即可.</p>
<p>值得一提的是,<span class="math inline">\(| \mathbb{ R } | = 2^{ |
\mathbb{ N } | }\)</span>.这个是怎么构造的呢?只需要证明<span class="math inline">\([ 0 , 1
]\)</span>上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果<span class="math inline">\(k\)</span>在取出的自然数子集中,那么小数点后第<span class="math inline">\(k + 1\)</span>位为<span class="math inline">\(1\)</span>否则为<span class="math inline">\(0\)</span>,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是<span class="math inline">\(0 . 1 =
0 . 0111
\cdots\)</span>,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明<span class="math inline">\(| \mathbb{ R } | \leq 2^{ | \mathbb{ N } |
}\)</span>并且<span class="math inline">\(| \mathbb{ R } | \geq 2^{ |
\mathbb{ N } | }\)</span>,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2>
<h3><span id="范畴">范畴</span></h3>
<p>一个<strong>范畴</strong><span class="math inline">\(\mathcal{ C
}\)</span>应当包含以下:</p>
<ol type="1">
<li><p>一个类<span class="math inline">\(\rm{ Ob } ( \mathcal{ C }
)\)</span>,其元素称作<span class="math inline">\(\mathcal{ C
}\)</span>的<strong>对象</strong>.</p></li>
<li><p>对于<span class="math inline">\(X , Y \in \rm{ Ob } ( \mathcal{ C
} )\)</span>指定一个集合<span class="math inline">\(\text{ Hom }_{
\mathcal{ C } } ( X , Y )\)</span>,称作<span class="math inline">\(\mathcal{ C }\)</span>中从<span class="math inline">\(X\)</span>到<span class="math inline">\(Y\)</span>的<strong>态射</strong>.</p></li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol type="1">
<li><p>对于<span class="math inline">\(X \in \text{ Ob } ( \mathcal{ C }
)\)</span>存在其到自身的<strong>恒等态射</strong><span class="math inline">\(\text{ id }_X \in \text{ Hom }_{ \mathcal{ C } } (
X , X )\)</span>.</p></li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong><span class="math inline">\(\circ : \text{ Hom }_{ \mathcal{ C } } ( Y , Z )
\times \text{ Hom }_{ \mathcal{ C } } ( X , Y ) \to \text{ Hom }_{
\mathcal{ C } } ( X , Z ) , ( g , f ) \mapsto g \circ
f\)</span>.</p></li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol type="1">
<li><p><strong>结合律</strong>:对于<span class="math inline">\(\mathcal{
C }\)</span>中的态射<span class="math inline">\(h , g ,
f\)</span>,如果合成有意义,那么<span class="math inline">\(h ( gf ) = (
hg ) f\)</span>.</p></li>
<li><p><strong>单位元</strong>:对于<span class="math inline">\(f \in
\text{ Hom }_{ \mathcal{ C } } ( X , Y )\)</span>,<span class="math inline">\(f \circ \text{ id }_X = f = \text{ id }_Y \circ
f\)</span>.</p></li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有<span class="math inline">\(\text{ id }_X = \text{ id }_X \text{ id &#39; }_X
= \text{ id &#39; }_X\)</span>.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<p><span class="math display">\[
\xymatrix{ R \ar[r]^u \ar[d]_x &amp; S \ar[d]^v \\
T \ar[r]_y &amp; U }
\]</span></p>
<p>这意味着<span class="math inline">\(yx = vu\)</span>.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol type="1">
<li><p>如果对于<span class="math inline">\(f \in \text{ Hom } ( X , Y
)\)</span>,<span class="math inline">\(\exists g \in \text{ Hom } ( Y ,
X )\)</span>使得<span class="math inline">\(gf = \text{ id
}_X\)</span>,那么称<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的一个<strong>左逆</strong>,称<span class="math inline">\(f\)</span>是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p></li>
<li><p>如果<span class="math inline">\(f\)</span>左右均可逆,易见左右逆相等,记作<span class="math inline">\(f^{ - 1 }\)</span>,易见<span class="math inline">\(f^{ - 1 }\)</span>可逆而且<span class="math inline">\(( f^{ - 1 } )^{ - 1 } = f\)</span>.此时称<span class="math inline">\(f\)</span>是<strong>同构</strong>的.</p></li>
</ol>
<p>同构还有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(( \text{ id }_X )^{ - 1 } = \text{ id
}_X\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>均为同构并且合成有意义,那么<span class="math inline">\(gf\)</span>是同构并且<span class="math inline">\((
gf )^{ - 1 } = f^{ - 1 } g^{ - 1 }\)</span>.</p></li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol type="1">
<li><p>自同态幺半群:<span class="math inline">\(\text{ End }_{ \mathcal{
C } } ( X ) = \text{ Hom }_{ \mathcal{ C } } ( X , X
)\)</span>.</p></li>
<li><p>自同构群:<span class="math inline">\(\text{ Aut }_{ \mathcal{ C }
} ( X ) = ( \text{ End }_{ \mathcal{ C } } ( X )
)^\times\)</span>.</p></li>
</ol>
<p>如此起名的原因是由抽象代数知识见到<span class="math inline">\(\text{
End }\)</span>对二元运算<span class="math inline">\(\circ\)</span>构成幺半群,<span class="math inline">\(\text{ Aut }\)</span>则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称<span class="math inline">\(\mathcal{ C } &#39;\)</span>是<span class="math inline">\(\mathcal{ C }\)</span>的子范畴当且仅当:</p>
<ol type="1">
<li><p><span class="math inline">\(\text{ Ob } ( \mathcal{ C } &#39; )
\subseteq \text{ Ob } ( \mathcal{ C } )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall X , Y \in \text{ Ob } (
\mathcal{ C } &#39; )\)</span>都有<span class="math inline">\(\text{ Hom
}_{ \mathcal{ C } &#39; } ( X , Y ) \subseteq \text{ Hom }_{ \mathcal{ C
} } ( X , Y )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall X \in \text{ Ob } ( \mathcal{
C } &#39; )\)</span>,<span class="math inline">\(\text{ id }_X = \text{
id }_X &#39;\)</span>.</p></li>
<li><p>态射在<span class="math inline">\(\mathcal{ C }
&#39;\)</span>中的合成运算应从<span class="math inline">\(\mathcal{ C
}\)</span>中继承而来.</p></li>
</ol>
<p>特别地,如果<span class="math inline">\(\forall X , Y \in \text{ Ob }
( \mathcal{ C } &#39; ) , \text{ Hom } ( X , Y )_{ \mathcal{ C } &#39; }
= \text{ Hom }_{ \mathcal{ C } } ( X , Y )\)</span>,则称<span class="math inline">\(\mathcal{ C } &#39;\)</span>是<span class="math inline">\(\mathcal{ C }\)</span>的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3>
<p>如果<span class="math inline">\(\mathcal{ C
}\)</span>是一个范畴,其中有一个元素<span class="math inline">\(X \in
\mathrm{ Ob } ( \mathcal{ C } )\)</span>,如果<span class="math inline">\(\forall Y \in \mathrm{ Ob } ({ \mathcal{ C } }
)\)</span>,<span class="math inline">\(| \mathrm{ Hom }_{ \mathcal{ C }
} ( X , Y ) | = 1\)</span>,则称它是始(initial)的.类似地,如果对于<span class="math inline">\(Y \in \mathrm{ Ob } ( \mathcal{ C }
)\)</span>,<span class="math inline">\(\forall X \in \mathrm{ Ob } (
\mathcal{ C } )\)</span>,<span class="math inline">\(| \mathrm{ Hom }_{
\mathcal{ C } } ( X , Y ) | = 1\)</span>,则称<span class="math inline">\(Y\)</span>是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(X , X &#39; \in \mathrm{ Ob } (
\mathcal{ C } )\)</span>都是initial的,则存在一个唯一的同构<span class="math inline">\(a : X \cong X &#39;\)</span>.</p></li>
<li><p>如果<span class="math inline">\(Y , Y &#39; \in \mathrm{ Ob } (
\mathcal{ C } )\)</span>都是terminal的,则存在一个唯一的同构<span class="math inline">\(b : Y \cong Y &#39;\)</span>.</p></li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3>
<p>我们定义从<span class="math inline">\(\mathcal{ C }
&#39;\)</span>到<span class="math inline">\(\mathcal{ C
}\)</span>的<strong>函子</strong><span class="math inline">\(F\)</span>需要有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall X \in \text{ Ob } ( \mathcal{
C } &#39; )\)</span>,指定一个<span class="math inline">\(\mathcal{ C
}\)</span>中的对象<span class="math inline">\(FX\)</span>.或记作<span class="math inline">\(F : \text{ Ob } ( \mathcal{ C } &#39; ) \to \text{
Ob } ( \mathcal{ C } )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall X , Y \in \text{ Ob } (
\mathcal{ C } &#39; )\)</span>,对于态射<span class="math inline">\(f : X
\to Y\)</span>指定一个<span class="math inline">\(\mathcal{ C
}\)</span>中的对象<span class="math inline">\(Ff\)</span>.或记作<span class="math inline">\(F : \text{ Hom }_\mathcal{ C } &#39; ( X , Y ) \to
\text{ Hom }_\mathcal{ C } ( FX , FY )\)</span>.</p></li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall g , f \in \text{ Hom }_{
\mathcal{ C } &#39; }\)</span>,它们的合成有意义,则<span class="math inline">\(F ( gf ) = F ( g ) F ( f )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall X \in \text{ Ob } ( \mathcal{
C } &#39; )\)</span>,<span class="math inline">\(F ( \text{ id }_X ) =
\text{ id }_{ FX }\)</span>.</p></li>
</ol>
<p>我们一般也将上述函子记作<span class="math inline">\(F : \mathcal{ C }
&#39; \to \mathcal{ C
}\)</span>.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然<span class="math inline">\(F\)</span>可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\forall T \in \text{ Ob } (
\mathcal{ C } ) , \exists X \in \text{ Ob } ( \mathcal{ C } &#39;
)\)</span>使得<span class="math inline">\(T \cong FX\)</span>,则称<span class="math inline">\(F\)</span>是<strong>本质满</strong>的.</p></li>
<li><p>如果<span class="math inline">\(\forall X , Y \in \text{ Ob } (
\mathcal{ C } &#39; )\)</span>,<span class="math inline">\(F : \text{
Hom }_{ \mathcal{ C } &#39; } ( X , Y ) \to \text{ Hom }_{ \mathcal{ C }
} ( FX , FY )\)</span>均为单射,则称<span class="math inline">\(F\)</span>是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p></li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓<span class="math inline">\(\text{ Hom
}\)</span>函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴<span class="math inline">\(\mathcal{ C
}\)</span>以及其对象<span class="math inline">\(X\)</span>,我们定义函子<span class="math inline">\(\text{ Hom }_{ \mathcal{ C } } ( X , \cdot ) :
\mathcal{ C } \to Set\)</span>,它映对象<span class="math inline">\(Y\)</span>为集合<span class="math inline">\(\text{
Hom }_{ \mathcal{ C } } ( X , Y )\)</span>,映态射<span class="math inline">\(f : Y \to Z\)</span>为映射<span class="math inline">\(\text{ Hom }_{ \mathcal{ C } } ( X , \cdot ) f :
\text{ Hom }_{ \mathcal{ C } } ( X , Y ) \to \text{ Hom }_{ \mathcal{ C
} } ( X , Z ) , h \mapsto f \circ h\)</span>.</p>
<p>同理可以定义函子<span class="math inline">\(\text{ Hom }_{ \mathcal{
C } } ( \cdot , X )\)</span>.</p>
<p>对于函子<span class="math inline">\(\text{ Hom }_{ \mathcal{ C } } (
X , \cdot )\)</span>,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3>
<h4><span id="kleisli范畴">Kleisli范畴</span></h4>
<p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol type="1">
<li><p>加上修饰.</p></li>
<li><p>合并修饰.</p></li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">组合数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2>
<h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3>
<p>定义下降幂<span class="math inline">\(x^{ \underline{ k } } = \prod_{
i = 0 }^{ k - 1 } ( x - i ) = \frac{ x ! }{ ( x - k ) ! }\)</span>.</p>
<p>定义上升幂<span class="math inline">\(x^{ \overline{ k } } \prod_{ i
= 0 }^{ k - 1 } ( x + i ) = \frac{ ( x + k - 1 ) ! }{ ( x - 1 ) !
}\)</span>.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:<span class="math inline">\(r^{ \underline{ k } }
( r - 0 . 5 )^{ \underline{ k } } = \cfrac{ ( 2 r )^{ \underline{ 2 k }
} }{ 2^{ 2 k } } , k \in \mathbb{ N }\)</span>.</p>
<p>他们之间存在转换:<span class="math inline">\(x^{ \underline{ n } } =
( - 1 )^n ( - x )^{ \overline{ n } }\)</span>.</p>
<p>同时存在大小关系:<span class="math inline">\(x^{ \underline{ n } }
\leq x^n \leq x^{ \overline{ n } }\)</span>,其中<span class="math inline">\(0 \leq n &lt; x\)</span>.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3>
<p>考虑令<span class="math inline">\(\binom{ n }{ m
}\)</span>表示从一个大小为<span class="math inline">\(n\)</span>的子集中选出大小为<span class="math inline">\(m\)</span>的子集的方案数.第一次有<span class="math inline">\(n\)</span>个选择,第二次有<span class="math inline">\(n - 1\)</span>个选择……第m次有<span class="math inline">\(n - m +
1\)</span>个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是<span class="math inline">\(m !\)</span>,因此显然有<span class="math inline">\(\binom{ n }{ m } = \cfrac{ n^{ \underline{ m } }
}{ m ! }\)</span>.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
<p><span class="math inline">\(\binom{ r }{ k } = \begin{cases}\cfrac{
r^{ \underline{ k } } }{ k ! } &amp; k \geq 0 \\ 0 &amp; k &lt;
0\end{cases} , r \in \mathbb{ C } , k \in \mathbb{ Z }\)</span>.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把<span class="math inline">\(\binom{ r }{ k }\)</span>看作了一个关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式.</p>
<p>另外根据定义,<span class="math inline">\(r \in \mathbb{ Z } \land r
&lt; k\)</span>时,该公式给出<span class="math inline">\(0\)</span>.</p>
<p>值得一提的是,为了使二项式系数在面对<span class="math inline">\(0\)</span>的时候更加简洁,通常直接定义<span class="math inline">\(0 ! = 1 , 0^0 = 1\)</span>.</p>
<p>另外不难发现<span class="math inline">\(\binom{ 2 n }{ n
}\)</span>是所有<span class="math inline">\(\binom{ 2 n }{ k
}\)</span>中最大的.事实上我们有Wallis公式:<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ ( \frac{ 2^{
2 n } }{ \binom{ 2 n }{ n } } )^2 }{ 2 n + 1 } = \frac{ \pi }{ 2
}\)</span>.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3>
<ol type="1">
<li>阶乘展开式:<span class="math inline">\(\binom{ n }{ k } = \cfrac{ n
! }{ k ! ( n - k ) ! } , n , k \in \mathbb{ N } , n \geq k
\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="2" type="1">
<li>对称恒等式:<span class="math inline">\(\binom{ n }{ k } = \binom{ n
}{ n - k } , n \in \mathbb{ N } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\(( 1 )\)</span>,<span class="math inline">\(0 \leq k \leq
n\)</span>时是显然的.而其他情况两边都会给出<span class="math inline">\(0\)</span>,因此也是成立的.</p>
<ol start="3" type="1">
<li>吸收恒等式:<span class="math inline">\(\binom{ r }{ k } = \cfrac{ r
}{ k } \binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z } \land k \ne 0
\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="4" type="1">
<li>吸收恒等式的变式:<span class="math inline">\(k \binom{ r }{ k } = r
\binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\(( 3 )\)</span>,只需要验证<span class="math inline">\(k = 0\)</span>的情况即可,也是显然的.</p>
<ol start="5" type="1">
<li>相伴恒等式:<span class="math inline">\(( r - k ) \binom{ r }{ k } =
r \binom{ r - 1 }{ k } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
( r - k ) \binom{ r }{ k } &amp; = ( r - k ) \binom{ r }{ r - k } \\
&amp; = r \binom{ r - 1 }{ r - k - 1 } \\
&amp; = r \binom{ r - 1 }{ k }
\end{aligned}
\]</span></p>
<p>问题在于:我们在上述描述中并未提到<span class="math inline">\(r\)</span>的范围,但是推导过程要求<span class="math inline">\(r \in \mathbb{ N
}\)</span>.不过,我们已经说明了二项式系数是关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式,因此只需要有<span class="math inline">\(k + 1\)</span>个<span class="math inline">\(r\)</span>满足这个公式即可.而根据推导过程显然有无限个<span class="math inline">\(r\)</span>满足,因此这个公式对<span class="math inline">\(r \in \mathbb{ C }\)</span>也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<p><span class="math display">\[
\begin{aligned}
k \binom{ r }{ k } &amp; = r \binom{ r - 1 }{ k - 1 } \\
( r - k ) \binom{ r }{ r - k } &amp; = r \binom{ r - 1 }{ r - k - 1 } \\
( r - k ) \binom{ r }{ k } &amp; = r \binom{ r - 1 }{ k }
\end{aligned}
\]</span></p>
<ol start="6" type="1">
<li>加法公式:<span class="math inline">\(\binom{ r }{ k } = \binom{ r -
1 }{ k } + \binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明可以使用定义,也可以先用<span class="math inline">\(r \in \mathbb{
N }\)</span>的情况给出组合意义,再使用多项式推理法证明.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\binom{ r }{ m } \binom{ m }{ k } =
\binom{ r }{ k } \binom{ r - k }{ m - k } , n , k \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol start="8" type="1">
<li>平行求和法:<span class="math inline">\(\sum_{ k \leq n } \binom{ r +
k }{ k } = \binom{ r + n + 1 }{ n } , n \in \mathbb{ N }
\\\)</span>.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p><span class="math inline">\(\binom{ r + n + 1 }{ n } = \binom{ r + n
}{ n } + \binom{ r + n }{ n - 1 } = \binom{ r + n }{ n } + \binom{ r + n
- 1 }{ n - 1 } + \binom{ r + n - 1 }{ n - 2 } = . . .
\\\)</span>,最终下标会减成负数,这样后面的项就全都是<span class="math inline">\(0\)</span>了.</p>
<p>也可以考虑组合意义:如果<span class="math inline">\(r \in \mathbb{ N
}\)</span>,那么我们考虑从右到左第一个没有被选上的数,假设它是<span class="math inline">\(r + k +
1\)</span>,那么在它右边的数全部选择了,一共是<span class="math inline">\(n - k\)</span>个数,而还需要在左边的<span class="math inline">\(r + k\)</span>中选择<span class="math inline">\(k\)</span>个数.</p>
<ol start="9" type="1">
<li>上指标求和法:<span class="math inline">\(\sum_{ 0 \leq k \leq n }
\binom{ k }{ m } = \binom{ n + 1 }{ m + 1 } , n , m \in \mathbb{ N }
\\\)</span>.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是<span class="math inline">\(k + 1\)</span>,接下来就还需要在<span class="math inline">\([ 1 , k ]\)</span>中选择<span class="math inline">\(m\)</span>个.</p>
<p>如果我们将这个公式两边同时乘以<span class="math inline">\(m
!\)</span>,我们可以得到公式:<span class="math inline">\(\sum_{ 0 \leq k
\leq n } k^{ \underline{ m } } = \cfrac{ ( n + 1 )^{ \underline{ m + 1 }
} }{ m + 1 } , n , m \in \mathbb{ N }
\\\)</span>,这也就是有限微积分的公式中的一个.</p>
<ol start="10" type="1">
<li>二项式定理:<span class="math inline">\(( x + y )^r = \sum_{ k }
\binom{ r }{ k } x^k y^{ r - k } , r \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 0 \leq k \leq n } \binom{ n }{ k } &amp; = 2^n , n \in \mathbb{ N
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令<span class="math inline">\(x = y =
1\)</span>即可证明.</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 0 \leq k \leq n } ( - 1 )^k \binom{ n }{ k } &amp; = 0^n = [ n =
0 ] , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令<span class="math inline">\(x = - 1 , y =
1\)</span>即可证明,值得一提的是,当<span class="math inline">\(n =
0\)</span>的时候这个式子给出<span class="math inline">\(1\)</span>,并在其他情况下给出<span class="math inline">\(0\)</span>,这个式子是二项式反演的基础.</p>
<ol start="11" type="1">
<li>三项式定理:<span class="math inline">\(( x + y + z )^n = \sum_{ 0
\leq a , b , c \leq n } [ a + b + c = n ] \cfrac{ n ! }{ a ! b ! c ! }
x^a y^b z^c , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,<span class="math inline">\(\cfrac{
n ! }{ a ! b ! c ! } = \binom{ n }{ b + c } \binom{ b + c }{ c
}\)</span>.</p>
<ol start="12" type="1">
<li>多项式定理:<span class="math inline">\(( \sum_{ i = 1 }^m x_i )^n =
\sum_{ \forall i \in [ 1 , m ] , 0 \leq a_i \leq n } [ \sum_{ i = 1 }^m
a_i = n ] \cfrac{ n ! }{ \prod_{ i = 1 }^m a_i ! } \prod_{ i = 1 }^m
x_i^{ a_i } , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol start="13" type="1">
<li>范德蒙德卷积:<span class="math inline">\(\sum_{ k } \binom{ r }{ m +
k } \binom{ s }{ n - k } = \binom{ r + s }{ n + m } , n , m \in \mathbb{
Z } \\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol start="14" type="1">
<li>范德蒙德卷积的变式:<span class="math inline">\(\sum_{ k } \binom{ l
}{ m + k } \binom{ s }{ n + k } = \binom{ l + s }{ l - m + n } , l \in
\mathbb{ N } , n , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\binom{ l }{ m + k } = \binom{ l }{ l -
m - k }\)</span>,然后运用范德蒙德卷积即可得到答案.</p>
<ol start="15" type="1">
<li>上指标反转公式:<span class="math inline">\(\binom{ r }{ k } = ( - 1
)^k \binom{ k - r - 1 }{ k } \\\)</span>.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ r }{ k } ( - 1
)^k = ( - 1 )^m \binom{ r - 1 }{ m } , m \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \leq m } \binom{ r }{ k } ( - 1 )^k &amp; = \sum_{ k \leq m }
\binom{ k - r - 1 }{ k } \\
&amp; = \binom{ - r + m }{ m } = ( - 1 )^m \binom{ r - 1 }{ m }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(\sum_{ - q \leq k \leq l } \binom{ l - k
}{ m } \binom{ q + k }{ n } = \binom{ l + q + 1 }{ m + n + 1 } , n , m
\in \mathbb{ N } , l + q \geq 0 \\\)</span>.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ a + b }{ a + k }
\binom{ a + b }{ b + k } ( - 1 )^k = \binom{ a + b }{ a } , a , b \in
\mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{ k = 0 }^m \cfrac{ \binom{ m }{ k
} }{ \binom{ n }{ k } } = \cfrac{ n + 1 }{ n + 1 - m } , n , m \in
\mathbb{ N } , n \geq m \\\)</span>.</li>
</ol>
<p>我们有<span class="math inline">\(\binom{ n }{ m } \binom{ m }{ k } =
\binom{ n }{ k } \binom{ n - k }{ m - k } \\\)</span>,两边同时除以<span class="math inline">\(\binom{ n }{ m } \binom{ n - k }{ m - k }
\\\)</span>,于是我们得到了<span class="math inline">\(\cfrac{ \binom{ m
}{ k } }{ \binom{ n }{ k } } = \cfrac{ \binom{ n - k }{ m - k } }{
\binom{ n }{ m } } \\\)</span>.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^m \cfrac{ \binom{ m }{ k } }{ \binom{ n }{ k } } &amp; =
\sum_{ k = 0 }^m \cfrac{ \binom{ n - k }{ m - k } }{ \binom{ n }{ m } }
\\
&amp; = \cfrac{ 1 }{ \binom{ n }{ m } } \sum_{ k = 0 }^m \binom{ n - k
}{ m - k } \\
&amp; = \cfrac{ 1 }{ \binom{ n }{ m } } \sum_{ k = 0 }^m \binom{ n - m +
k }{ k } \\
&amp; = \cfrac{ \binom{ n + 1 }{ m } }{ \binom{ n }{ m } } \\
&amp; = \cfrac{ n + 1 }{ n + 1 - m }
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(( - 1 )^m \binom{ - n - 1 }{ m } = ( - 1
)^n \binom{ - m - 1 }{ n } , n , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于<span class="math inline">\(\binom{ n + m }{ m } \\\)</span>.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ r }{ k } (
\cfrac{ r }{ 2 } - k ) = \cfrac{ m + 1 }{ 2 } \binom{ r }{ m + 1 } , m
\in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ m + r }{ k }
x^k y^{ m - k } = \sum_{ k \leq m } \binom{ - r }{ k } ( - x )^k ( x + y
)^{ m - k } , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>不妨令左边的值为<span class="math inline">\(S_m\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_m &amp; = \sum_{ k \leq m } \binom{ m + r }{ k } x^k y^{ m - k } =
\sum_{ k \leq m } \binom{ m + r - 1 }{ k } x^k y^{ m - k } + \sum_{ k
\leq m } \binom{ m + r - 1 }{ k - 1 } x^k y^{ m - k } \\
&amp; = y \sum_{ k &lt; m } \binom{ m - 1 + r }{ k } x^k y^{ m - 1 - k }
+ \binom{ m + r - 1 }{ m } x^m + x \sum_{ k \leq m } \binom{ m + r - 1
}{ k - 1 } x^{ k - 1 } y^{ m - k } \\
&amp; = ( x + y ) S_{ m - 1 } + \binom{ m + r - 1 }{ m } x^m \\
&amp; = ( x + y ) S_{ m - 1 } + \binom{ r }{ m } ( - x )^m
\end{aligned}
\]</span></p>
<p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ m + k }{ k }
2^{ - k } = 2^m , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(( 7 )\)</span>,将<span class="math inline">\(x = y = 1 , r = m + 1\)</span>带入,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \leq m } \binom{ 2 m + 1 }{ k } &amp; = \sum_{ k \leq m }
\binom{ m + k }{ k } 2^{ m - k } \\
2^{ 2 m } &amp; = \sum_{ k \leq m } \binom{ m + k }{ k } 2^{ m - k } \\
2^m &amp; = \sum_{ k \leq m } \binom{ m + k }{ k } 2^{ - k }
\end{aligned}
\]</span></p>
<ol start="9" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ l }{ m + k } \binom{
s + k }{ n } ( - 1 )^k = ( - 1 )^{ l + m } \binom{ s - m }{ n - l } , l
\in \mathbb{ N } , n , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\sum_{ k \leq l } \binom{ l - k }{ m }
\binom{ s }{ k - n } ( - 1 )^k = ( - 1 )^{ l + m } \binom{ s - m - 1 }{
l - n - m } , l , n , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\binom{ r }{ k } \binom{ r - \cfrac{ 1
}{ 2 } }{ k } = \cfrac{ \binom{ 2 r }{ 2 k } \binom{ 2 k }{ k } }{ 2^{ 2
k } } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>将加倍公式两边同时除以<span class="math inline">\(k
!^2\)</span>即可得到这个公式.</p>
<ol start="2" type="1">
<li><span class="math inline">\(\binom{ n - \cfrac{ 1 }{ 2 } }{ n } =
\cfrac{ \binom{ 2 n }{ n } }{ 2^{ 2 n } } , n \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>将<span class="math inline">\(( 1 )\)</span>中令<span class="math inline">\(r = k = n\)</span>即可得到这个公式.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\binom{ - \cfrac{ 1 }{ 2 } }{ n } = (
\cfrac{ - 1 }{ 4 } )^n \binom{ 2 n }{ n } , n \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>即<span class="math inline">\(( 2 )\)</span>的变形.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ n }{ 2 k } \binom{ 2
k }{ k } 2^{ - 2 k } = \binom{ n - \cfrac{ 1 }{ 2 } }{ \lfloor \cfrac{ n
}{ 2 } \rfloor } , n \in \mathbb{ N } \\\)</span></li>
</ol>
<p>首先根据<span class="math inline">\(( 1 )\)</span>,左边<span class="math inline">\(= \sum_{ k } \binom{ \cfrac{ n }{ 2 } }{ k }
\binom{ \cfrac{ n - 1 }{ 2 } }{ k } \\\)</span>,而考虑到<span class="math inline">\(\cfrac{ n }{ 2 }\)</span>和<span class="math inline">\(\cfrac{ n - 1 }{ 2
}\)</span>必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ - \cfrac{ 1 }{ 2 } }{
k } \binom{ - \cfrac{ 1 }{ 2 } }{ n - k } = ( - 1 )^n , n \in \mathbb{ N
} \\\)</span>.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ 2 k }{ k } \binom{ 2
n - 2 k }{ n - k } = 4^n , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>由<span class="math inline">\(( 5 )\)</span>和<span class="math inline">\(( 3 )\)</span>不难推出.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ n }{ k } \cfrac{ ( -
1 )^k }{ x + k } = x^{ - 1 } \binom{ x + n }{ n }^{ - 1 } , x \notin \{
0 , - 1 , . . . , - n \} \\\)</span>.</li>
</ol>
<p>令<span class="math inline">\(f ( x ) = ( x - 1 )^{ \underline{ - 1 }
}\)</span>,直接做高阶差分即可得到这个式子.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{ k = 0 }^n \binom{ r }{ k }
\binom{ r }{ n - k } ( - 1 )^k = [ n \ is \ \mathrm{ even } ] ( - 1 )^{
\cfrac{ n }{ 2 } } \binom{ r }{ \cfrac{ n }{ 2 } } \\\)</span>.</li>
</ol>
<p>首先不难发现,<span class="math inline">\(( 1 - z )^r = \sum_{ k \geq
0 } ( - 1 )^k \binom{ r }{ k } \\\)</span>.</p>
<p>考虑<span class="math inline">\(( 1 - z )^r ( 1 + z )^r = ( 1 - z^2
)^r\)</span>.</p>
<p>我们有<span class="math inline">\([ z^n ] ( 1 - z )^r ( 1 + z )^r = [
z^n ] ( 1 - z^2 )^r\)</span>,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3>
<p>卡特兰数<span class="math inline">\(f_n\)</span>表示:长度为<span class="math inline">\(2 n\)</span>的合法括号序列个数.</p>
<p>卡特兰数的前几项为<span class="math inline">\(1 , 1 , 2 , 5 , 14 , 42
, 132 \cdots\)</span>.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:<span class="math inline">\(f_n = \sum_{ i = 0 }^{ n - 1 }
f_i f_{ n - 1 - i }\)</span>.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如<span class="math inline">\(( A ) B\)</span>.</p>
<p>考虑将其删成<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,则<span class="math inline">\(A\)</span>一定合法,因为若<span class="math inline">\(A\)</span>不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:<span class="math inline">\(f_n = \frac{ 1 }{ n + 1 } C_{ 2
n }^n = C_{ 2 n }^n - C_{ 2 n }^{ n - 1 }\)</span>.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , 0
)\)</span>不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到<span class="math inline">\(( 2 n , 0
)\)</span>的方案数是<span class="math inline">\(C_{ 2 n
}^n\)</span>.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点<span class="math inline">\(( x , - 1 )\)</span>.</p>
<p>考虑将<span class="math inline">\(x\)</span>以后的折线以直线<span class="math inline">\(y = - 1\)</span>为对称轴反转,那么终点到了<span class="math inline">\(( 2 n , - 2 )\)</span>.</p>
<p>不难发现,任意从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , - 2
)\)</span>的方案一定唯一对应了一种从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , 0
)\)</span>的不合法方案.因为从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , - 2
)\)</span>一定会经过直线<span class="math inline">\(y = -
1\)</span>,将后半部分对称后就是其对应方案.而从<span class="math inline">\(( 0 , 0 )\)</span>走到<span class="math inline">\(( 2 n , - 2 )\)</span>的方案数为<span class="math inline">\(C_{ 2 n }^{ n - 1 }\)</span>.</p>
<p>因而<span class="math inline">\(f_n = C_{ 2 n }^n - C_{ 2 n }^{ n - 1
} \\\)</span>.</p>
<p>而<span class="math inline">\(C_{ 2 n }^n - C_{ 2 n }^{ n - 1 } =
\frac{ ( 2 n ) ! }{ n ! n ! } - \frac{ ( 2 n ) ! }{ ( n - 1 ) ! ( n + 1
) ! } = \frac{ ( 2 n ) ! }{ n ! ( n + 1 ) ! } = \frac{ C_{ 2 n }^n }{ n
+ 1 } \\\)</span>.</p>
<p>递推定义:<span class="math inline">\(f_n = \frac{ 4 n - 2 }{ n + 1 }
f_{ n - 1 } \\\)</span>.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\</p>
<p>f_{n-1}=</p>
<p>\end{cases}\</p>
<p>不难发现<span class="math inline">\(f_n = \frac{ ( 2 n - 1 ) ( 2 n )
}{ n ( n + 1 ) } f_{ n - 1 } \\\)</span>.整理,得到<span class="math inline">\(f_n = \frac{ 4 n - 2 }{ n + 1 } f_{ n - 1 }
\\\)</span>.</p>
<p>换个记号,设<span class="math inline">\(C_n\)</span>为卡特兰数的第<span class="math inline">\(n\)</span>项,卡特兰数有一个著名的结论是<span class="math inline">\(k\)</span>次卷积:</p>
<p><span class="math display">\[
C^{ ( k ) }_n = \sum_{ \sum_{ j = 1 }^k a_j = n } \prod C_{ a_i } =
\frac{ k }{ n + k } \binom{ 2 n + k - 1 }{ n }
\]</span></p>
<p>我们可以这么理解它:它指的是一个长度为<span class="math inline">\(n +
k - 1\)</span>的括号序列,前<span class="math inline">\(k -
1\)</span>个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成<span class="math inline">\(( ( ( A ) B ) C )
D\)</span>之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<p><span class="math display">\[
\begin{aligned}
C^{ ( k ) }_n &amp; = \binom{ 2 n + k - 1 }{ n } - \binom{ 2 n + k - 1
}{ n - 1 } \\
&amp; = \frac{ k }{ n + k } \binom{ 2 n + k - 1 }{ n }
\end{aligned}
\]</span></p>
<h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5>
<p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是<span class="math inline">\(\binom{ 2 n }{ n }\)</span>.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5>
<p>给定<span class="math inline">\(x , n\)</span>,对<span class="math inline">\(y \in [ 1 , n ]\)</span>,固定<span class="math inline">\(p_x =
y\)</span>做笛卡尔树的<strong>形态</strong>计数.<span class="math inline">\(n \leq 5 \times 10^5\)</span>.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现<span class="math inline">\(a_x = y\)</span>只要满足:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>节点的祖先数量不超过<span class="math inline">\(y - 1\)</span>个(深度小于等于<span class="math inline">\(y\)</span>).</p></li>
<li><p><span class="math inline">\(x\)</span>节点的子树大小不超过<span class="math inline">\(n - y + 1\)</span>.</p></li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出<span class="math inline">\(f_p\)</span>表示<span class="math inline">\(x\)</span>的深度为<span class="math inline">\(p\)</span>的答案,<span class="math inline">\(g_p\)</span>表示<span class="math inline">\(x\)</span>的子树大小为<span class="math inline">\(p\)</span>的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:<span class="math inline">\(x\)</span>的祖先有两种:一种在序列中在<span class="math inline">\(x\)</span>的左边,一种在<span class="math inline">\(x\)</span>的右边.我们设前者为<span class="math inline">\(0 = l_0 &lt; l_1 &lt; l_2 &lt; \cdots l_p &lt; l_{
p + 1 } = x\)</span>,设后者为<span class="math inline">\(n + 1 = r_0
&gt; r_1 &gt; r_2 &gt; \cdots &gt; r_{ q } &gt; r_{ q + 1 } =
x\)</span>.这么分类有什么用呢?我们考虑<span class="math inline">\(( l_{
i - 1 } , l_{ i } )\)</span>这一段数能放在哪里,它只能是<span class="math inline">\(l_{ i
}\)</span>的左儿子,独立于整棵树,因此这一段的答案就是<span class="math inline">\(C_{ l_i - l_{ i - 1 } - 1 }\)</span>.</p>
<p>记:</p>
$$
<span class="math display">\[\begin{aligned}
L_p &amp; = \sum_{ l } \prod_{ i = 1 }^{ p + 1 } C_{ l_i - l_{ i - 1 } -
1 } \\
R_q &amp; = \sum_{ r } \prod_{ i = 1 }^{ q + 1 } C_{ r_{ i - 1 } - r_i -
1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到这等价于卡特兰数的<span class="math inline">\(k\)</span>次卷积,有:</p>
$$
<span class="math display">\[\begin{aligned}
L_p &amp; = C_{ x - p - 1 }^{ ( p + 1 ) } \\
R_q &amp; = C^{ ( q + 1 ) }_{ n - x - q } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时的答案自然是<span class="math inline">\(f_{ p + q + 1 } = L_p R_q
\binom{ p + q }{ q }\)</span>,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把<span class="math inline">\(x\)</span>的子树从原树中删去,然后插入<span class="math inline">\(x\)</span>一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为<span class="math inline">\(p\)</span>,右子树大小为<span class="math inline">\(q\)</span>,我们有<span class="math inline">\(g_{ p
+ q + 1 } = C_p C_q C_{ n - ( p + q + 1 ) } = C_{ n - 1 }^{ ( 3 )
}\)</span>,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3>
<h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k \binom{ m - k - 1 }{
m - n - 1 } , n , m \in \mathbb{ N } \land m &gt; n \\\)</span>.</p>
<p>这个式子乘了个系数<span class="math inline">\(k\)</span>导致很难处理,一个自然的想法是使用吸收恒等式将<span class="math inline">\(k\)</span>消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n k \binom{ m - k - 1 }{ m - n - 1 } &amp; = \sum_{ k = 0
}^n m \binom{ m - k - 1 }{ m - n - 1 } - \sum_{ k = 0 }^n ( m - k )
\binom{ m - k - 1 }{ m - n - 1 } \\
&amp; = m \sum_{ k = 0 }^{ m - 1 } \binom{ m - k - 1 }{ m - n - 1 } - (
m - n ) \sum_{ k = 0 }^m \binom{ m - k }{ m - n }
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(S_m = \sum_{ k = 0 }^m \binom{ m -
k }{ m - n } \\\)</span>,不难发现我们有:</p>
<p><span class="math display">\[
S_m = \sum_{ k = 0 }^m \binom{ k }{ m - n } = \binom{ m + 1 }{ m - n + 1
}
\]</span></p>
<p>于是原式<span class="math inline">\(= mS_{ m - 1 } - ( m - n ) S_m =
\cfrac{ n }{ m - n + 1 } \binom{ m }{ m - n } \\\)</span>.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将<span class="math inline">\(k = \binom{ k }{ 1 }\)</span>带入:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n k \binom{ m - k - 1 }{ m - n - 1 } &amp; = \sum_{ k = 0
}^n \binom{ k }{ 1 } \binom{ m - k - 1 }{ m - n - 1 } \\
&amp; = \binom{ m }{ m - n + 1 } \\
&amp; = \cfrac{ n }{ m - n + 1 } \binom{ m }{ m - n }
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{ k } k \binom{ n }{ k } \binom{ s
}{ k } , n \in \mathbb{ N } \\\)</span>.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到<span class="math inline">\(n\)</span>和<span class="math inline">\(s\)</span>的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k } k \binom{ n }{ k } \binom{ s }{ k } &amp; = s \sum_{ k }
\binom{ n }{ k } \binom{ s - 1 }{ k - 1 } \\
&amp; = s \binom{ n + s - 1 }{ n - 1 }
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(\sum_{ 0 \leq k } \binom{ n + k }{ 2 k
} \binom{ 2 k }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n \in \mathbb{ N }
\\\)</span>.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 0 \leq k } \binom{ n + k }{ 2 k } \binom{ 2 k }{ k } \cfrac{ ( -
1 )^k }{ k + 1 } &amp; = \sum_{ 0 \leq k } \binom{ n + k }{ k } \binom{
n }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n \in \mathbb{ N } \\
&amp; = \cfrac{ 1 }{ n + 1 } \sum_{ 0 \leq k } \binom{ n + k }{ k }
\binom{ n + 1 }{ k + 1 }{ ( - 1 )^k } \\
&amp; = \cfrac{ 1 }{ n + 1 } \sum_{ 0 \leq k } \binom{ - n - 1 }{ k }
\binom{ n + 1 }{ k + 1 } \\
&amp; = \cfrac{ 1 }{ n + 1 } \binom{ 0 }{ n } \\
&amp; = [ n = 0 ]
\end{aligned}
\]</span></p>
<h5><span id="example4">Example4</span></h5>
<p>求<span class="math inline">\(\sum_{ k \geq 0 } \binom{ n + k }{ m +
2 k } \binom{ 2 k }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n , m \in
\mathbb{ N_+ } \\\)</span>.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的<span class="math inline">\(( 1 )\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \geq 0 } \binom{ n + k }{ m + 2 k } \binom{ 2 k }{ k } \cfrac{
( - 1 )^k }{ k + 1 } &amp; = \sum_{ k \geq 0 } \sum_{ 0 \leq j \leq n +
k - 1 } \binom{ n + k - 1 - j }{ 2 k } \binom{ j }{ m - 1 } \binom{ 2 k
}{ k } \cfrac{ ( - 1 )^k }{ k + 1 } \\
&amp; = \sum_{ 0 \leq j \leq n - 1 } \binom{ j }{ m - 1 } \sum_{ j + 1 -
n \leq k , 0 \leq k } \binom{ n + k - 1 - j }{ 2 k } \binom{ 2 k }{ k }
\cfrac{ ( - 1 )^k }{ k + 1 }
\end{aligned}
\]</span></p>
<p>注意到如果<span class="math inline">\(j + 1 - n \geq
0\)</span>,则<span class="math inline">\(\binom{ n + k - 1 - j }{ 2 k }
\\\)</span>应为<span class="math inline">\(0\)</span>.所以有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ 0 \leq j \leq n - 1 } \binom{ j }{ m - 1 } \sum_{ j + 1 - n
\leq k , 0 \leq k } \binom{ n + k - 1 - j }{ 2 k } \binom{ 2 k }{ k }
\cfrac{ ( - 1 )^k }{ k + 1 } \\
= &amp; \sum_{ 0 \leq j &lt; n } \binom{ j }{ m - 1 } [ n - 1 - j = 0 ]
= \binom{ n - 1 }{ m - 1 }
\end{aligned}
\]</span></p>
<h5><span id="example5">Example5</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n ( C_n^k
)^2\)</span>.</p>
<p><span class="math display">\[
\sum_{ k = 0 }^n ( C_n^k )^2 = \sum_{ k = 0 }^n C_{ n }^k \times C_{ n
}^{ n - k } = C_n^{ 2 n }
\]</span></p>
<h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(Q_n = \sum_{ k \leq 2^n } \binom{ 2^n -
k }{ k } ( - 1 )^k , n \in \mathbb{ N } \\\)</span>.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于<span class="math inline">\(Q_n\)</span>的式子中实际上只与<span class="math inline">\(2^n\)</span>有关,我们不妨令<span class="math inline">\(R_n = \sum_{ k \leq n } \binom{ n - k }{ k } ( - 1
)^k \\\)</span>,显然有<span class="math inline">\(Q_n = R_{ 2^n
}\)</span>.</p>
<p>而我们有:</p>
<p><span class="math display">\[
\begin{aligned}
R_n &amp; = \sum_{ k \leq n } \binom{ n - 1 - k }{ k } ( - 1 )^k +
\sum_{ k \leq n } \binom{ n - 1 - k }{ k - 1 } ( - 1 )^k \\
&amp; = \sum_{ k \leq n } \binom{ n - 1 - k }{ k } ( - 1 )^k + \sum_{ k
\leq n - 1 } \binom{ n - k - 2 }{ k } ( - 1 )^{ k + 1 } \\
&amp; = \sum_{ k \leq n - 1 } \binom{ n - 1 - k }{ k } ( - 1 )^k +
\binom{ - 1 }{ n } ( - 1 )^n - ( \sum_{ k \leq n - 2 } \binom{ n - 2 - k
}{ k } ( - 1 )^k + \binom{ - 1 }{ n - 1 } ( - 1 )^{ n - 1 } ) \\
&amp; = \sum_{ k \leq n - 1 } \binom{ n - 1 - k }{ k } ( - 1 )^k -
\sum_{ k \leq n - 1 } \binom{ n - 2 - k }{ k } ( - 1 )^k \\
&amp; = R_{ n - 1 } - R_{ n - 2 } \\
&amp; = R_{ n - 2 } - R_{ n - 3 } - R_{ n - 2 } \\
&amp; = - R_{ n - 3 } \\
&amp; = R_{ n - 6 }
\end{aligned}
\]</span></p>
<p>也即<span class="math inline">\(R_n\)</span>具有周期性,不难计算前几项答案,最后有<span class="math inline">\(Q_n \begin{cases}1 &amp; n = 0 \\ 0 &amp; n \ is \
\mathrm{ odd } \\ - 1 &amp; n &gt; 0 \land n \ is \ \mathrm{ even
}\end{cases}\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(( \sum^{ + \infty }_{ i = 0 } C^{ ik +
r }_{ nk } ) \mod p\)</span>.</p>
<p>考虑设<span class="math inline">\(f ( n , r ) = \sum^{ + \infty }_{ i
= 0 } C^{ ik + r }_{ nk } \\\)</span>,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n , r ) &amp; = \sum^{ + \infty }_{ i = 0 } C^{ ik + r }_{ nk } \\
&amp; = \sum_{ i = 0 }^{ + \infty } \sum_{ j = 0 }^k C_{ nk - k }^{ ik +
r - j } \times C_k^j \\
&amp; = \sum^k_{ j = 0 } C_k^j \sum_{ i = 0 }^{ + \infty } C_{ nk - k
}^{ ik + r - j } \\
&amp; = \sum_{ j = 0 }^k C_k^j f ( n - 1 , r - j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理上式,得到:<span class="math inline">\(f ( n , r ) = \sum_{ j = 0
}^k C_k^j f ( n - 1 , r - j ) \\\)</span>.</p>
<p>于是我们得到了关于<span class="math inline">\(f\)</span>的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4>
<h5><span id="example">Example</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 1 }^n k^2
C_n^k\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
( ( 1 + x )^n ) &amp; = ( \sum_{ k = 0 }^n C_n^k x^{ k } ) \\
( ( 1 + x )^n ) &#39; &amp; = ( \sum_{ k = 0 }^n C_n^k x^{ k } ) &#39;
\\
n ( 1 + x )^{ n - 1 } &amp; = \sum_{ k = 0 }^n kC_n^k x^{ k - 1 } \\
nx ( 1 + x )^{ n - 1 } &amp; = \sum_{ k = 0 }^n kC_n^k x^{ k } \\
( nx ( 1 + x )^{ n - 1 } ) &#39; &amp; = ( \sum_{ k = 0 }^n kC_n^k x^{ k
} ) &#39; \\
n ( ( 1 + x )^{ n - 1 } + ( n - 1 ) x ( 1 + x )^{ n - 2 } ) &amp; =
\sum_{ k = 0 }^n k^2 C_n^k x^{ k - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>取<span class="math inline">\(x = 1\)</span>,则原式<span class="math inline">\(= n ( n + 1 ) 2^{ n - 2 }\)</span>.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>多次询问给定<span class="math inline">\(k , r\)</span>,<span class="math inline">\(\sum k \leq 2 n , r &lt; 2 n - k\)</span>,求<span class="math inline">\(\sum_{ i = 0 }^{ r } \frac{ 1 }{ 2^i } \binom{ i
}{ n - k }\)</span>,.</p>
<p>我们把模型抽象成:在二维平面上,从<span class="math inline">\(( 0 , 0
)\)</span>随机游走到<span class="math inline">\(( n - k + 1 , r - n + k
)\)</span>正下方(包含这个点)的概率,容易发现此时向右走了<span class="math inline">\(n - k\)</span>步,总共走了<span class="math inline">\(\leq
r\)</span>步,然后再向右走一步保证第一次走到了<span class="math inline">\(( n - k + 1 , r - n + k )\)</span>下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到<span class="math inline">\(x + y = r + 1\)</span>这条直线时横坐标<span class="math inline">\(\geq n - k +
1\)</span>的概率.枚举一下总共向上走了几步,就得到<span class="math inline">\(\frac{ 1 }{ 2^{ r } } \sum_{ j = 0 }^{ r - n + k }
\binom{ r + 1 }{ j }\)</span>,注意这里是<span class="math inline">\(\frac{ 1 }{ 2^r
}\)</span>,因为从一开始钦定了一步,因此映射过来需要多乘个<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>,反映射就要乘个<span class="math inline">\(2\)</span>.但是这个式子还是做不了,因为<span class="math inline">\(r\)</span>并不满足<span class="math inline">\(\sum
r \leq 2 n\)</span>.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于<span class="math inline">\(1 - \frac{ 1 }{ 2^{ r } } \sum_{ i = 0 }^{ n - k }
\binom{ r + 1 }{ i }\)</span>.我们考虑暴力预处理出<span class="math inline">\(f_r = \sum_{ i = 0 }^{ n } \binom{ r }{ i
}\)</span>,每次删掉一个后缀的组合数就行.现在的问题在于<span class="math inline">\(f\)</span>怎么做.</p>
<p>直接拆组合数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_r &amp; = \sum_{ i = 0 }^n \binom{ r }{ i } \\
&amp; = \sum_{ i = 0 }^n \binom{ r - 1 }{ i - 1 } + \sum_{ i = 0 }^n
\binom{ r - 1 }{ i } \\
&amp; = 2 \sum_{ i = 0 }^n \binom{ r - 1 }{ i } - \binom{ r - 1 }{ n }
\\
&amp; = 2 f_{ r - 1 } - \binom{ r - 1 }{ n }
\end{aligned}
\]</span></p>
<h3><span id="lucas定理">Lucas定理</span></h3>
<p>若<span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(C_n^m \mod p = C_{ n \mod p }^{ m \mod p } \times
C_{ \lfloor \frac{ n }{ p } \rfloor }^{ \lfloor \frac{ m }{ p } \rfloor
} \mod p \\\)</span>.</p>
<p>或者说,将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>在<span class="math inline">\(p\)</span>进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若<span class="math inline">\(i \ne 0\)</span>且<span class="math inline">\(i \ne p\)</span>,<span class="math inline">\(C_{ p
}^i \equiv \frac{ p }{ i } C_{ p - 1 }^{ i - 1 } \equiv 0 ( \mod p )
\\\)</span>.</p>
<p>而根据二项式定理,<span class="math inline">\(( 1 + x )^p \equiv
\sum_{ i = 0 }^p C_{ p }^i x^i = 1 + x^p ( \mod p ) \\\)</span>.</p>
<p>令<span class="math inline">\(n = k_1 p + b_1\)</span>,<span class="math inline">\(m = k_2 p + b_2\)</span>,则<span class="math inline">\(( 1 + x )^n = ( 1 + x )^{ k_1 p } ( 1 + x )^{ b_1
} \\\)</span>.</p>
<p>而<span class="math inline">\(( 1 + x )^{ k_1 p } \equiv ( 1 + x^p
)^{ k_1 } ( \mod p ) \\\)</span>,有<span class="math inline">\(( 1 + x
)^n \equiv ( 1 + x^p )^{ k_1 } ( 1 + x )^{ b_1 } \\\)</span>.</p>
<p>根据二项式定理,<span class="math inline">\(C_n^m \bmod
p\)</span>即<span class="math inline">\(x^m\)</span>项的系数.</p>
<p>我们可以得出,<span class="math inline">\(C_n^m x^m \equiv C_{ k_1 }^{
k_2 } x^{ k_2 p } C_{ b 1 }^{ b_2 } x^{ b_2 } \pmod{ p }
\\\)</span>,那么有<span class="math inline">\(C_a^b \equiv C_{ k_1 }^{
k_2 } C_{ b_1 }^{ b_2 } \pmod{ p } \\\)</span>.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<p><span class="math display">\[
\binom{ n }{ m } \equiv [ m \subseteq n ] \pmod{ 2 }
\]</span></p>
<h5><span id="example1cf1770fkoxia-andsequence">Example1([CF1770F]Koxia and
Sequence)</span></h5>
<p>首先观察样例并思考,可以发现当<span class="math inline">\(n\)</span>为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是<span class="math inline">\(0\)</span>),所以异或值为<span class="math inline">\(0\)</span>.不然,我们可以翻转<span class="math inline">\(a [ 2 . . . n ]\)</span>,得出答案应该是所有<span class="math inline">\(a_1\)</span>的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有<span class="math inline">\(y &#39; \subseteq y\)</span>,求出满足<span class="math inline">\(a_i \subseteq y &#39; , \sum a_i =
x\)</span>时,<span class="math inline">\(a_1\)</span>异或和.接下来怎么做呢?我们考虑拆位,若<span class="math inline">\(2^k \subseteq y &#39;\)</span>,假设<span class="math inline">\(a_1\)</span>的第<span class="math inline">\(k\)</span>位是<span class="math inline">\(1\)</span>,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第<span class="math inline">\(k\)</span>位贡献是:</p>
<p><span class="math display">\[
[ 2^k \subseteq y &#39; ] \bigoplus_{ \sum a = x } [ 2^k \subseteq a_1 ]
\prod_{ i = 1 }^n [ a_i \subseteq y &#39; ]
\]</span></p>
<p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:<span class="math inline">\([ x \subseteq y ] \equiv \binom{ y }{ x } \pmod{ 2
}\)</span>.</p>
<p>所以原式化简为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \binom{ y &#39; }{ 2^k } \sum_{ \sum a = x } \binom{ a_1 }{ 2^k }
\prod_{ i = 1 }^n \binom{ y &#39; }{ a_i } \pmod{ 2 } \\
= &amp; \binom{ y &#39; }{ 2^k } \sum_{ a_1 } \binom{ y &#39; - 2^k }{
a_1 - 2^k } \sum_{ \sum a = x - a_1 } \prod_{ i = 2 }^n \binom{ y &#39;
}{ a_i } \pmod{ 2 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \binom{ y &#39; }{ 2^k } \sum_{ a_1 } \binom{ y &#39; - 2^k }{ a_1
- 2^k } \binom{ ( n - 1 ) y &#39; }{ x - a_1 } \pmod{ 2 } \\
= &amp; \binom{ y &#39; }{ 2^k } \binom{ ny &#39; - 2^k }{ x - 2^k }
\pmod{ 2 } \\
= &amp; [ 2^k \subseteq y &#39; ] [ ( x - 2^k ) \subseteq ( ny &#39; -
2^k ) ]
\end{aligned}
\]</span></p>
<h3><span id="扩展lucas定理">扩展Lucas定理</span></h3>
<p>令<span class="math inline">\(p = \prod p_i^{ e_i
}\)</span>,那我们只要对于每个<span class="math inline">\(i\)</span>求出<span class="math inline">\(C_n^m
\mod p_i^{ e_i }\)</span>,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求<span class="math inline">\(C_n^m \mod
p^k\)</span>,其中<span class="math inline">\(p \in \mathrm{ prime
}\)</span>.</p>
<p>原式<span class="math inline">\(= \frac{ n ! }{ m ! ( n - m ) ! }
\mod p^k = \frac{ \frac{ n ! }{ p^x } }{ \frac{ m ! }{ p^y } \frac{ ( n
- m ) ! }{ p^z } } p^{ x - y - z } \mod p^k \\\)</span>.</p>
<p>现在问题转化为求<span class="math inline">\(\frac{ n ! }{ p^x } \mod
p^k 以 及 p^x \\\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n ! &amp; = \prod_{ i = 1 } i \\
&amp; = ( \prod_{ i = wp , w \in \mathbb{ Z } } i ) ( \prod_{ i \ne wp ,
w \in \mathbb{ Z } } i ) \\
&amp; = p^{ \lfloor n p \rfloor } ( \lfloor n p \rfloor ! ) ( \prod_{ i
\ne wp , w \in \mathbb{ Z } } i ) \\
&amp; \equiv p^{ \lfloor \frac{ n }{ p } \rfloor } ( \lfloor \frac{ n }{
p } \rfloor ! ) ( \prod_{ i = 1 , i \ne wp , w \in \mathbb{ Z } }^{ p^k
} i )^{ \lfloor \frac{ n }{ p^k } \rfloor } ( \prod^{ n \ \bmod{ p^k }
}_{ i = p^k \lfloor \frac{ n }{ p^k } \rfloor , i \ne wp , w \in
\mathbb{ Z } } i ) ( \mod p^k )
\end{aligned}
\]</span></p>
<p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将<span class="math inline">\([ 1
, n ]\)</span>的所有数全部排成一个宽为<span class="math inline">\(p^k\)</span>的矩阵.</p>
<p>那右边第一项就是把那些<span class="math inline">\(p\)</span>的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2>
<h3><span id="第一类斯特林数">第一类斯特林数</span></h3>
<p><span class="math inline">\(n \brack k \\\)</span>:长度为<span class="math inline">\(n\)</span>的排列划分成<span class="math inline">\(k\)</span>个轮换的方案数.</p>
<p>考虑现在已经将<span class="math inline">\(n -
1\)</span>个数分成了若干轮换,现在新加入第<span class="math inline">\(n\)</span>个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然<span class="math inline">\(\left [ \begin{array}{ c } n \\ k\end{array}
\right ] = ( n - 1 ) \left [ \begin{array}{ c } n - 1 \\ k\end{array}
\right ] + \left [ \begin{array}{ c } n - 1 \\ k - 1\end{array} \right ]
\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left [ \begin{array}{ c }
0 \\ k\end{array} \right ] = [ k = 0 ] \\\)</span>.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:<span class="math inline">\(\sum_{ k = 0 }^n \left [ \begin{array}{ c } n \\
k\end{array} \right ] = n !\)</span>.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3>
<p><span class="math inline">\(\left \{ \begin{array}{ c } n \\
k\end{array} \right \}\)</span>:将<span class="math inline">\(n\)</span>个本质不同的物品划分成k个非空集合的方案数.</p>
<p>考虑现在已经放好<span class="math inline">\(n -
1\)</span>个物品,正要放入第<span class="math inline">\(n\)</span>个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然<span class="math inline">\(\left \{ \begin{array}{ c } n \\ k\end{array}
\right \} = k \left \{ \begin{array}{ c } n - 1 \\ k\end{array} \right
\} + \left \{ \begin{array}{ c } n - 1 \\ k - 1\end{array} \right \}
\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left \{ \begin{array}{ c
} 0 \\ k\end{array} \right \} = [ k = 0 ] \\\)</span>.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3>
<p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:<span class="math inline">\({ n \brack m } ={ - m \brace - n }
\\\)</span>.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3>
<ol type="1">
<li><span class="math inline">\(x^n = \sum_{ k = 0 }^n \left \{
\begin{array}{ c } n \\ k\end{array} \right \} x^{ \underline{ k } } =
\sum_{ k = 0 }^n \left \{ \begin{array}{ c } n \\ k\end{array} \right \}
( - 1 )^{ n - k } x^{ \overline{ k } } \\\)</span>.</li>
</ol>
<p>证明:先考虑前半段,不妨使用数学归纳.若<span class="math inline">\(x^{
n - 1 } = \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}{ c } n - 1 \\
k\end{array} \right \} x^{ \underline{ k } } \\\)</span>,我们要证</p>
<p>\</p>
$$
<span class="math display">\[\begin{aligned}
x \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} x^{ \underline{ k } } &amp; = \sum_{ k = 0 }^{ n }
\left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} x^{ \underline{ k } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑<span class="math inline">\(( x - k ) x^{ \underline{ k } } = x^{
\underline{ k + 1 } }\)</span>,所以<span class="math inline">\(x \cdot
x^{ \underline{ k } } = x^{ \underline{ k + 1 } } + kx^{ \underline{ k }
} \\\)</span>.那么左边即:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} x^{ \underline{ k + 1 } } + \sum_{ k = 0 }^{ n - 1
} \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} kx^{ \underline{ k } } \\
= &amp; \sum_{ k = 1 }^{ n } \left \{ \begin{array}
{ c } n - 1 \\
k - 1
\end{array} \right \} x^{ \underline{ k } } + \sum_{ k = 1 }^{ n } \left
\{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} kx^{ \underline{ k } } \\
= &amp; \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} x^{ \underline{ k } } \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>至于后半段,由于<span class="math inline">\(x^{ \underline{ n } } = (
- 1 )^n ( - x )^{ \overline{ n } } \\\)</span>,所以<span class="math inline">\(x^n = \sum_{ k = 0 }^n \left \{ \begin{array}{ c }
n \\ k\end{array} \right \} ( - 1 )^k ( - x )^{ \overline{ k } }
\\\)</span>.</p>
<p>不妨用<span class="math inline">\(x\)</span>来代替<span class="math inline">\(- x\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( - x )^n &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^k ( x )^{ \overline{ k } } \\
x^n &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^{ n - k } x^{ \overline{ k } }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><p><span class="math inline">\(x^{ \overline{ n } } = \sum_{ k = 0
}^n \left [ \begin{array}{ c } n \\ k\end{array} \right ] x^k
\\\)</span>.</p></li>
<li><p><span class="math inline">\(x^{ \underline{ n } } = \sum_{ k = 0
}^n \left [ \begin{array}{ c } n \\ k\end{array} \right ] ( - 1 )^{ n -
k } x^k \\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于<span class="math inline">\(( x + n - 1 ) x^k = x^{ k
+ 1 } + ( n - 1 ) x^k
\\\)</span>,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol start="4" type="1">
<li>反转公式:<span class="math inline">\(\sum_{ k = 0 }^n \left [
\begin{array}{ c } n \\ k\end{array} \right ] \left \{ \begin{array}{ c
} k \\ m\end{array} \right \} ( - 1 )^{ n - k } = \sum_{ k = 0 }^n \left
\{ \begin{array}{ c } n \\ k\end{array} \right \} \left [ \begin{array}{
c } k \\ m\end{array} \right ] ( - 1 )^{ n - k } = [ m = n ]
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑先证明后半部分,将(3)带入(1),得到<span class="math inline">\(x^n =
\sum_{ k = 0 }^n \left \{ \begin{array}{ c } n \\ k\end{array} \right \}
x^{ \underline{ k } } = \sum_{ k = 0 }^n \sum_{ m = 0 }^k \left \{
\begin{array}{ c } n \\ k\end{array} \right \} \left [ \begin{array}{ c
} k \\ m\end{array} \right ] ( - 1 )^{ n - k } x^m \\\)</span>.</p>
<p>由于这对任意<span class="math inline">\(x\)</span>都成立,因此右边除了<span class="math inline">\(x^n\)</span>以外的项系数均为<span class="math inline">\(0\)</span>,而<span class="math inline">\(x^n\)</span>的系数为<span class="math inline">\(1\)</span>.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n + 1 \\
m + 1\end{array} \right \} = \sum_{ k = m }^n \left ( \begin{array}{ c }
n \\ k\end{array} \right ) \left \{ \begin{array}{ c } k \\ m\end{array}
\right \} \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n + 1 \\ m
+ 1\end{array} \right ] = \sum_{ k = m }^n \left ( \begin{array}{ c } n
\\ k\end{array} \right ) \left [ \begin{array}{ c } k \\ m\end{array}
\right ] \\\)</span>.</p></li>
</ol>
<p>证明:对于前者,考虑组合意义,将<span class="math inline">\(n +
1\)</span>个分为<span class="math inline">\(m +
1\)</span>组,也就是先找一部分分成<span class="math inline">\(m\)</span>组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3>
<ol start="7" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n \\
m\end{array} \right \} = \sum_{ k = m }^n \left ( \begin{array}{ c } n
\\ k\end{array} \right ) \left \{ \begin{array}{ c } k + 1 \\ m +
1\end{array} \right \} ( - 1 )^{ n - k } \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n \\
m\end{array} \right ] = \sum_{ k = m }^n \left ( \begin{array}{ c } n \\
k\end{array} \right ) \left [ \begin{array}{ c } k + 1 \\ m +
1\end{array} \right ] ( - 1 )^{ n - k } \\\)</span>.</p></li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol start="9" type="1">
<li><span class="math inline">\(m ! \left \{ \begin{array}{ c } n \\
m\end{array} \right \} = \sum_{ k = 0 }^m C_m^k k^n ( - 1 )^{ m - k }
\\\)</span>.</li>
</ol>
<p>证明:首先有<span class="math inline">\(m^n = \sum_{ k = 0 }^m m^{
\underline{ k } } \left \{ \begin{array}{ c } m \\ k\end{array} \right
\} = \sum_{ k = 0 }^m k ! C_m^k \left \{ \begin{array}{ c } m \\
k\end{array} \right \} \\\)</span>,对这个式子进行二项式反演即可.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\left \{ \begin{array}{ c } n + 1 \\ m +
1\end{array} \right \} = \sum_{ k = 0 }^n \left \{ \begin{array}{ c } k
\\ m\end{array} \right \} ( m + 1 )^{ n - k } \\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前<span class="math inline">\(k\)</span>个分为<span class="math inline">\(m\)</span>组,把第<span class="math inline">\(k +
1\)</span>个数放到第<span class="math inline">\(m +
1\)</span>组.然后剩下<span class="math inline">\(( n + 1 ) - ( k + 1 ) =
n -
k\)</span>个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第<span class="math inline">\(m + 1\)</span>组(最小值最大的那组)在<span class="math inline">\(k\)</span>不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol start="11" type="1">
<li><span class="math inline">\(\left [ \begin{array}{ c } n + 1 \\ m +
1\end{array} \right ] = \sum_{ k = 0 }^n \left [ \begin{array}{ c } k \\
m\end{array} \right ] C_{ n }^k ( n - k ) ! = n ! \sum_{ k = 0 }^n
\frac{ \left [ \begin{array}{ c } k \\ m\end{array} \right ] }{ k ! }
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果<span class="math inline">\(n &gt;
0\)</span>,我们有<span class="math inline">\(\left [ \begin{array}{ c }
n \\ 1\end{array} \right ] = ( n - 1 ) !
\\\)</span>.这个式子很显然,我们现在有一个长度为<span class="math inline">\(n - 1\)</span>的环,想要往里插入第<span class="math inline">\(n\)</span>个数有<span class="math inline">\(n -
1\)</span>种选择,所以我们有:<span class="math inline">\(\left [
\begin{array}{ c } n \\ 1\end{array} \right ] = \left [ \begin{array}{ c
} n - 1 \\ 1\end{array} \right ] ( n - 1 )
\\\)</span>,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将<span class="math inline">\(n +
1\)</span>个数划分成<span class="math inline">\(m +
1\)</span>个环,我们先将其中<span class="math inline">\(k\)</span>个数划分成<span class="math inline">\(m\)</span>个环,剩下<span class="math inline">\(n +
1 -
k\)</span>个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第<span class="math inline">\(n +
1\)</span>个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于<span class="math inline">\(C_n^k ( n - k ) ! = C_n^{ n - k } (
n - k ) ! = n^{ \underline{ n - k } } = \frac{ n ! }{ k ! }
\\\)</span>.因此后半部分也得证.</p>
<ol start="12" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n + m + 1
\\ m\end{array} \right \} = \sum_{ k = 0 }^m k \left \{ \begin{array}{ c
} n + k \\ k\end{array} \right \} \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n + m + 1
\\ m\end{array} \right ] \sum_{ k = 0 }^m ( n + k ) \left [
\begin{array}{ c } n + k \\ k\end{array} \right ] \\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将<span class="math inline">\(n +
k\)</span>个位置分到<span class="math inline">\(k\)</span>个集合之后.还剩下<span class="math inline">\(( n + m + 1 ) - ( n + k ) = ( m - k + 1
)\)</span>个数,剩下<span class="math inline">\(( m - k
)\)</span>个集合.</p>
<p>拿出来<span class="math inline">\(( n + k + 1
)\)</span>这个数,剩下的数刚好够每个集合放一个.最后枚举一下把<span class="math inline">\(( n + k + 1
)\)</span>放在哪里即可.由于每个划分一定存在一段(可能是<span class="math inline">\(0\)</span>)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol start="14" type="1">
<li><span class="math inline">\(C_n^m ( n - 1 )^{ \underline{ n - m } }
= \sum_{ k = m }^n \left [ \begin{array}{ c } n \\ k\end{array} \right ]
\left \{ \begin{array}{ c } k \\ m\end{array} \right \}
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑<span class="math inline">\(( n - 1 )^{ \underline{ n - m } } =
\frac{ ( n - 1 ) ! }{ ( m - 1 ) ! } \\\)</span>,不妨设<span class="math inline">\(f ( n , m ) = \sum_{ k = m }^n \left [
\begin{array}{ c } n \\ k\end{array} \right ] \left \{ \begin{array}{ c
} k \\ m\end{array} \right \} \\\)</span>,相当于将<span class="math inline">\(n\)</span>个数分成非空<span class="math inline">\(m\)</span>组,然后组内的数要形成若干轮换的方案数.那么知道<span class="math inline">\(f ( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m )
f ( n - 1 , m ) \\\)</span>.</p>
<p>设<span class="math inline">\(g ( n , m ) = C_n^m \frac{ ( n - 1 ) !
}{ ( m - 1 ) ! } = \frac{ n ! ( n - 1 ) ! }{ m ! ( n - m ) ! ( m - 1 ) !
} \\\)</span>,那么知道:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n - 1 , m - 1 ) &amp; = \frac{ ( n - 1 ) ! ( n - 2 ) ! }{ ( m - 1 )
! ( n - m ) ! ( m - 2 ) ! } \\
g ( n - 1 , m ) &amp; = \frac{ ( n - 1 ) ! ( n - 2 ) ! }{ m ! ( n - 1 -
m ) ! ( m - 2 ) ! } \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然<span class="math inline">\(g ( n , m ) = g ( n - 1 , m - 1 ) + (
n - 1 + m ) g ( n - 1 , m ) \\\)</span>,数学归纳即可.</p>
<ol start="15" type="1">
<li><p><span class="math inline">\(C_n^m = \frac{ n ! }{ m ! ( n - m ) !
} = \sum_{ k = m }^n \left \{ \begin{array}{ c } n + 1 \\ k +
1\end{array} \right \} \left [ \begin{array}{ c } k \\ m\end{array}
\right ] ( - 1 )^{ m - k } \\\)</span>.</p></li>
<li><p><span class="math inline">\(n^{ \underline{ n - m } } = \frac{ n
! }{ m ! } = \sum_{ k = m }^n \left [ \begin{array}{ c } n + 1 \\ k +
1\end{array} \right ] \left \{ \begin{array}{ c } k \\ m\end{array}
\right \} ( - 1 )^{ m - k } ， 其 中 m \leq n \\\)</span>.</p></li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol start="17" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n \\ l +
m\end{array} \right \} C_{ l + m }^l = \sum_{ k = l }^n \left \{
\begin{array}{ c } k \\ l\end{array} \right \} \left \{ \begin{array}{ c
} n - k \\ m\end{array} \right \} C_n^k \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n \\ l +
m\end{array} \right ] C_{ l + m }^l = \sum_{ k = l }^n \left [
\begin{array}{ c } k \\ l\end{array} \right ] \left [ \begin{array}{ c }
n - k \\ m\end{array} \right ] C_n^k \\\)</span>.</p></li>
</ol>
<p>证明:先考虑前者,左边即先将<span class="math inline">\(n\)</span>个数分为<span class="math inline">\(l +
m\)</span>个集合,然后再挑出<span class="math inline">\(l\)</span>个集合.那不妨枚举这<span class="math inline">\(l\)</span>个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2>
<p>记<span class="math inline">\(\left \langle \begin{array}\\ n \\
k\end{array} \right \rangle\)</span>表示<span class="math inline">\(\{ 1
, 2 , . . . , n \}\)</span>的排列<span class="math inline">\(a\)</span>中满足这条性质的排列个数:存在且只存在<span class="math inline">\(k\)</span>个升高,换句话说,存在且只存在<span class="math inline">\(k\)</span>个<span class="math inline">\(i\)</span>,满足<span class="math inline">\(1 \leq
i &lt; n\)</span>,<span class="math inline">\(a_i &lt; a_{ i + 1
}\)</span>.不难发现<span class="math inline">\(\left \langle
\begin{array}\\ n \\ k\end{array} \right \rangle = \left \langle
\begin{array}\\ n \\ n - k - 1\end{array} \right \rangle\)</span>.</p>
<p>考虑在一个<span class="math inline">\(\{ 1 , 2 , . . . , n - 1
\}\)</span>的排列中插入<span class="math inline">\(n\)</span>,设插入的位置是原本<span class="math inline">\(a_i\)</span>的后面,那么要么原本<span class="math inline">\(a_i &lt; a_{ i + 1
}\)</span>,要么反之.前者不会改变排列的升高的数量,后者则会增加<span class="math inline">\(1\)</span>.另外还有一种情况是插入到了序列最前面.于是我们自然得到:<span class="math inline">\(\left \langle \begin{array}\\ n \\ k\end{array}
\right \rangle = ( k + 1 ) \left \langle \begin{array}\\ n - 1 \\
k\end{array} \right \rangle + ( n - k ) \left \langle \begin{array}\\ n
- 1 \\ k - 1\end{array} \right \rangle\)</span>.</p>
<p>特别地,我们令<span class="math inline">\(\left \langle
\begin{array}\\ 0 \\ k\end{array} \right \rangle = [ k = 0
]\)</span>,若<span class="math inline">\(k &lt; 0\)</span>,则<span class="math inline">\(\left \langle \begin{array}\\ n \\ k\end{array}
\right \rangle = 0\)</span>.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3>
<p>我们有Worpitzky恒等式:</p>
<p><span class="math display">\[
x^n = \sum_{ k \geq 0 } \binom{ x + k }{ n } \left \langle \begin{array}
\\
n \\
k
\end{array} \right \rangle , n \in \mathbb{ N }
\]</span></p>
<p>还有另一个恒等式:</p>
<p><span class="math display">\[
\left \langle \begin{array}
\\
n \\
m
\end{array} \right \rangle = \sum_{ k = 0 }^m \binom{ n + 1 }{ k } ( m +
1 - k )^n ( - 1 )^k
\]</span></p>
<p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2>
<p>定义<span class="math inline">\(B_j\)</span>为第<span class="math inline">\(j\)</span>个伯努利数,且满足<span class="math inline">\(\sum_{ j = 0 }^m \binom{ m + 1 }{ j } B_j = [ m =
0 ] , m \geq 0 \\\)</span>.</p>
<p>定义<span class="math inline">\(S_m ( n ) = \sum_{ i = 0 }^{ n - 1 }
i^m\)</span>.</p>
<p>伯努利数满足公式:<span class="math inline">\(S_m ( n ) = \cfrac{ 1 }{
m + 1 } \sum_{ k = 0 }^m \binom{ m + 1 }{ k } B_k n^{ m + 1 - k }
\\\)</span>.</p>
<p>证明如下:</p>
<p>对<span class="math inline">\(S_{ m + 1 } ( n
)\)</span>使用扰动法,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
S_{ m + 1 } ( n ) + n^{ m + 1 } &amp; = \sum_{ k = 0 }^{ n - 1 } ( k + 1
)^{ m + 1 } \\
&amp; = \sum_{ k = 0 }^{ n - 1 } \sum_{ j = 0 }^{ m + 1 } \binom{ m + 1
}{ j } k^j \\
&amp; = \sum_{ j = 0 }^{ m + 1 } \binom{ m + 1 }{ j } S_j ( n ) \\
&amp; = \sum_{ j = 0 }^{ m } \binom{ m + 1 }{ j } S_j ( n ) + S_{ m + 1
} ( n ) \\
n^{ m + 1 } &amp; = \sum_{ j = 0 }^m \binom{ m + 1 }{ j } S_j ( n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来使用数学归纳,假设<span class="math inline">\(0 \leq j &lt;
m\)</span>时该公式成立,并假设有<span class="math inline">\(S_m ( n ) =
\cfrac{ 1 }{ m + 1 } \sum_{ k = 0 }^m \binom{ m + 1 }{ k } B_k n^{ m + 1
- k } + \Delta \\\)</span>,我们只需要证明<span class="math inline">\(\Delta = 0\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
n^{ m + 1 } &amp; = \sum_{ j = 0 }^m \binom{ m + 1 }{ j } \cfrac{ 1 }{ j
+ 1 } \sum_{ k = 0 }^j \binom{ j + 1 }{ k } B_k n^{ j + 1 - k } + ( m +
1 ) \Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ k } \binom{ m +
1 }{ j } \cfrac{ 1 }{ j + 1 } B_k n^{ j + 1 - k } + ( m + 1 ) \Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ j - k } \binom{
m + 1 }{ j } \cfrac{ 1 }{ j + 1 } B_{ j - k } n^{ k + 1 } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ k + 1 } \binom{
m + 1 }{ j } \cfrac{ 1 }{ j + 1 } B_{ j - k } n^{ k + 1 } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq m } \cfrac{ n^{ k + 1 } }{ k + 1 } \sum_{ j
= k }^m B_{ j - k } \binom{ m + 1 }{ j } \binom{ j }{ k } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq m } \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{
m + 1 }{ k } \sum_{ j = k }^m B_{ j - k } \binom{ m + 1 - k }{ j - k } +
( m + 1 ) \Delta \\
&amp; = \sum_{ k = 0 }^m \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{ m + 1 }{
k } \sum_{ j = 0 }^{ m - k } B_{ j } \binom{ m + 1 - k }{ j } + ( m + 1
) \Delta \\
&amp; = \sum_{ k = 0 }^m \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{ m + 1 }{
k } [ m - k = 0 ] + ( m + 1 ) \Delta \\
&amp; = n^{ m + 1 } + ( m + 1 ) \Delta
\end{aligned}
\]</span></p>
<p>显然<span class="math inline">\(\Delta = 0\)</span>,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2>
<p>定义斐波那契数<span class="math inline">\(F_n = \begin{cases}0 &amp;
n = 0 \\ 1 &amp; n = 1 \\ F_{ n - 1 } + F_{ n - 2 } &amp; n &gt;
1\end{cases}\)</span>.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3>
<p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<p><span class="math display">\[
F_{ n + 1 } F_{ n - 1 } - F_n^2 = ( - 1 )^n , n &gt; 0
\]</span></p>
<p>事实上,如果我们将斐波那契数的递推式改写作:<span class="math inline">\(F_n = F_{ n + 2 } - F_{ n + 1
}\)</span>,我们可以在<span class="math inline">\(n \in \mathbb{ Z
}\)</span>的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<p><span class="math display">\[
F_{ - n } = ( - 1 )^{ n - 1 } F_n , n \in \mathbb{ Z }
\]</span></p>
<h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3>
<p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
F_{ n + k } &amp; = F_k F_{ n + 1 } + F_{ k - 1 } F_n \\
F_{ n + m + 1 } &amp; = F_{ n + 1 } F_{ m + 1 } + F_n F_m
\end{aligned}
\]</span></p>
<p>另外,如果我们在上面这个式子中取<span class="math inline">\(k = wn , w
\in \mathbb{ N }\)</span>并使用归纳法,我们又可以得到一个性质:<span class="math inline">\(F_{ kn }\)</span>是<span class="math inline">\(F_n\)</span>的倍数,<span class="math inline">\(k
\in \mathbb{ Z }\)</span>.</p>
<p>再观察这个式子,使用归纳法可以证明<span class="math inline">\(\gcd (
F_{ n } , F_{ n - 1 } ) = 1\)</span>,进一步有:<span class="math inline">\(\gcd ( F_{ n + m } , F_m ) = \gcd ( F_n , F_m
)\)</span>.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<p><span class="math display">\[
\gcd ( F_m , F_n ) = F_{ \gcd ( n , m ) }
\]</span></p>
<p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<p><span class="math display">\[
F_n^2 | F_m \Leftrightarrow nF_n | m , n &gt; 2
\]</span></p>
<p>这个引理的证明如下:</p>
<p>由于<span class="math inline">\(F_{ n + 1 } \equiv F_{ n - 1 } \pmod{
F_n }\)</span>.于是我们有:<span class="math inline">\(F_{ 2 n } = F_n
F_{ n + 1 } + F_{ n - 1 } F_n\)</span>,也就是<span class="math inline">\(F_{ 2 n } \equiv 2 F_n F_{ n + 1 } \pmod{ F_n^2
}\)</span>.</p>
<p>另外我们有:<span class="math inline">\(F_{ 2 n + 1 } \equiv F_{ n + 1
}^2 \pmod{ F_n^2 }\)</span>.</p>
<p>同理,使用归纳法可以证明:<span class="math inline">\(F_{ kn } \equiv
kF_n F_{ n + 1 }^{ k - 1 } \pmod{ F_n^2 } , F_{ kn + 1 } \equiv F_{ n +
1 }^k \pmod{ F_n^2 }\)</span>.</p>
<p>而<span class="math inline">\(F_{ n + 1 } \bot F_n\)</span>,于是<span class="math inline">\(F_{ kn } \equiv 0 \pmod{ F_n^2 } \Leftrightarrow k
\equiv 0 \pmod{ F_n } , n &gt; 2\)</span>.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3>
<p>我们如果定义<span class="math inline">\(j \gg k \Leftrightarrow j
\geq k + 2\)</span>,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:<span class="math inline">\(n =
\sum_{ i = 1 }^r F_{ k_i } , \forall 1 \leq i &lt; r , k_i \gg k_{ i + 1
} \gg 0\)</span>.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果<span class="math inline">\(\exists k\)</span>满足<span class="math inline">\(F_k = n\)</span>,则显然成立,不然,应<span class="math inline">\(\exists k\)</span>满足<span class="math inline">\(F_k &lt; n &lt; F_{ k + 1 }\)</span>,而<span class="math inline">\(n - F_k\)</span>的表示已经存在了.另外,由于<span class="math inline">\(n - F_k &lt; F_{ k + 1 } - F_k = F_{ k - 1
}\)</span>,因此必定不可能出现选了<span class="math inline">\(F_k\)</span>又选了<span class="math inline">\(F_{
k - 1 }\)</span>的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择<span class="math inline">\(F_k\)</span>而是选择<span class="math inline">\(F_{ k - 1
}\)</span>,那么显然接下来无论怎么选,它们的加和都不可能大于等于<span class="math inline">\(F_k\)</span>,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数<span class="math inline">\(n\)</span>以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3>
<p>使用生成函数,令<span class="math inline">\(F ( z ) = \sum_{ k \geq 0
} F_k z^k\)</span>.那么不难发现<span class="math inline">\(F ( z ) - zF
( z ) - z^2 F ( z ) = z\)</span>,也就是<span class="math inline">\(F ( z
) = \cfrac{ z }{ 1 - z - z^2 }\)</span>.</p>
<p>考虑这个形式一定可以分解为<span class="math inline">\(F ( z ) =
\cfrac{ a }{ 1 - \alpha z } + \cfrac{ b }{ 1 - \beta z
}\)</span>的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令<span class="math inline">\(\phi = \cfrac{ 1 +
\sqrt{ 5 } }{ 2 } , \hat \phi = \cfrac{ 1 - \sqrt{ 5 } }{ 2
}\)</span>,那么可以得到<span class="math inline">\(F_n = \cfrac{ 1 }{
\sqrt{ 5 } } ( \phi^n - \hat \phi^n )\)</span>.</p>
<p>另外,由于<span class="math inline">\(\hat
\phi^n\)</span>的影响很小,于是又有<span class="math inline">\(F_n =
\lfloor \cfrac{ \phi^n }{ \sqrt{ 5 } } + 0 . 5 \rfloor\)</span>.</p>
<h3><span id="连项式">连项式</span></h3>
<p>连项式多项式<span class="math inline">\(K_n ( x_1 , x_2 , . . . , x_n
)\)</span>定义为:<span class="math inline">\(K_n ( x_1 , x_2 , . . . ,
x_n ) = \begin{cases}1 &amp; n = 0 \\ x_1 &amp; n = 1 \\ x_n K_{ n - 1 }
( x_1 , x_2 , . . . x_{ n - 1 } ) + K_{ n - 2 } ( x_1 , x_2 , . . . ,
x_{ n - 2 } ) &amp; n \geq 2\end{cases}\)</span>.</p>
<p>通过定义不难发现:<span class="math inline">\(K_n ( 1 , 1 , . . . , 1
) = F_{ n + 1 }\)</span>.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数<span class="math inline">\(( x_{ n - 1 } , x_n
)\)</span>.我们考虑用这样一种形式的字符串来表示最后某一项的情况:‘.’为还没有消除掉的项,长度为<span class="math inline">\(1\)</span>;’-‘为已经消除了的两项,长度为<span class="math inline">\(2\)</span>.那么<span class="math inline">\(K_n (
x_1 , x_2 , . . . , x_n )\)</span>就可以表示为一个长度为<span class="math inline">\(n\)</span>的字符串,其中若有<span class="math inline">\(k\)</span>个’-‘,有<span class="math inline">\(n -
2 k\)</span>个’.’,则有<span class="math inline">\(\binom{ n - k }{ k
}\)</span>种不同的排列方式.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
K_n ( z , z , . . . , z ) &amp; = \sum_{ k = 0 }^n \binom{ n - k }{ k }
z^{ n - 2 k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,这也导出:<span class="math inline">\(F_{ n + 1 } = \sum_{ k = 0
}^n \binom{ n - k }{ k } \\\)</span>.</p>
<p>考虑上面的构造过程,不难发现<span class="math inline">\(K_n ( x_1 ,
x_2 , . . . , x_n ) = K_n ( x_n , x_{ n - 1 } , . . . , x_1
)\)</span>.</p>
<p>于是递归式可以写成:<span class="math inline">\(K_n ( x_1 , x_2 , . .
. , x_n ) = x_1 K_{ n - 1 } ( x_2 , x_3 , . . . x_{ n } ) + K_{ n - 2 }
( x_3 , x_4 , . . . , x_{ n } )\)</span>.</p>
<p>进一步地,不断展开后得到:</p>
<p><span class="math display">\[
\begin{aligned}
K_{ m + n } ( x_1 , . . . , x_m , x_{ m + 1 } , . . . , x_{ n + m } )
&amp; = \\
K_m ( x_1 , . . . , x_m ) K_n ( x_{ m + 1 } , . . . , x_{ n + m } ) +
K_{ m - 1 } ( x_1 , . . . , x_{ m - 1 } ) K_{ n - 1 } ( x_{ m + 2 } , .
. . , x_{ n + m } )
\end{aligned}
\]</span></p>
<p>另外,根据连项式的定义,不难导出<span class="math inline">\(K_n ( x_1 ,
. . . , x_n + y ) = K_n ( x_1 , . . . , x_n ) + K_{ n - 1 } ( x_1 , . .
. , x_{ n - 1 } ) y\)</span>.</p>
<p>由这个公式可以推出:<span class="math inline">\(\cfrac{ K_{ n + 1 } (
a_0 , . . . , a_n ) }{ K_n ( a_1 , . . . , a_n ) } = \cfrac{ K_n ( a_0 ,
. . . , a_{ n - 1 } + \cfrac{ 1 }{ a_n } ) }{ K_{ n - 1 } ( a_1 , . . .
, a_{ n - 1 } + \cfrac{ 1 }{ a_n } ) }\)</span>.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<p><span class="math display">\[
\cfrac{ K_{ n + 1 } ( a_0 , . . . , a_n ) }{ K_n ( a_1 , . . . , a_n ) }
= a_0 + \cfrac{ 1 }{ a_1 + \cfrac{ 1 }{ a_2 + \cfrac{ 1 }{ a_3 + . . . }
} }
\]</span></p>
<p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" class="post-title-link" itemprop="url">简单乐理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="前言">前言</span></h3>
<p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3>
<h4><span id="拍音理论">拍音理论</span></h4>
<p>假设两个正弦单音的频率分别是<span class="math inline">\(\omega ,
\omega + \delta\)</span>,那么它们叠加后是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
= &amp; 2 \sin \left ( 2 \pi ( \omega + \frac{ \delta }{ 2 } ) t \right
) \cos ( \pi \delta t )
\end{aligned}
\]</span></p>
<p>注意到这个声音受到<span class="math inline">\(\cos ( \pi \delta t
)\)</span>的控制.因此会以<span class="math inline">\(\frac{ \delta }{ 2
}\)</span>的频率振动,由于<span class="math inline">\(\delta\)</span>应该远小于<span class="math inline">\(\omega\)</span>,这里就会产生<span class="math inline">\(\delta = | \omega_1 - \omega_2
|\)</span>个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4>
<p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol type="1">
<li><p>弦长<span class="math inline">\(L\)</span>.</p></li>
<li><p>张力<span class="math inline">\(T\)</span>.</p></li>
<li><p>线密度<span class="math inline">\(\rho\)</span>.</p></li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点<span class="math inline">\(u ( x , t )\)</span>,首先是一维振动方程:</p>
<p><span class="math display">\[
\frac{ \partial^2 u }{ \partial x^2 } = \frac{ \rho }{ T } \frac{
\partial^2 u }{ \partial t^2 }
\]</span></p>
<p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<p><span class="math display">\[
u_n ( x , t ) = c_n \sin ( \omega_n t + \theta_n ) \sin ( \frac{ n \pi
}{ L } x )
\]</span></p>
<p>其中第<span class="math inline">\(n\)</span>项的频率满足:</p>
<p><span class="math display">\[
f_n = \frac{ n }{ 2 L } \sqrt{ \frac{ T }{ \rho } }
\]</span></p>
<p>其中我们将<span class="math inline">\(f_1\)</span>称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中<span class="math inline">\(f_n , n \geq 2\)</span>对应的是第<span class="math inline">\(n - 1\)</span>泛音.</p>
<p>特别地,如果我们干脆记<span class="math inline">\(f =
f_1\)</span>,上述结果告诉我们弦的振动产生的一列频率是:</p>
<p><span class="math display">\[
f , 2 f , 3 f , \cdots
\]</span></p>
<p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的<span class="math inline">\(n\)</span>,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0"></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的<span class="math inline">\(f_{ 2 k + 1 }\)</span>,泛音列中只剩下<span class="math inline">\(2 f , 4 f ,
\cdots\)</span>.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按<span class="math inline">\(\frac{ 1 }{ 3
}\)</span>处呢?那泛音列中就会只剩下<span class="math inline">\(3 f , 6 f
, 9 f , \cdots\)</span>,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是<span class="math inline">\(f , 3 f , 5 f , \cdots\)</span>.</p>
<h4><span id="管乐器">管乐器</span></h4>
<p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<p><span class="math display">\[
f , 2 f , 3 f , 4 f , \cdots
\]</span></p>
<p>闭管的泛音列:</p>
<p><span class="math display">\[
f , 3 f , 5 f , 7 f
\]</span></p>
<p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4>
<p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots
\end{gathered}
\]</span></p>
<p>或是:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac{ 3 }{ 2 } f , 3 f , \frac{ 9 }{ 2 } f , 6 f , \cdots
\end{gathered}
\]</span></p>
<p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3>
<p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是<span class="math inline">\(L_p = 20 \log_{ 10 } ( \frac{ p }{ p_0 }
)\)</span>,其中<span class="math inline">\(p_0 = 20 \mu Pa\)</span>.</p>
<h4><span id="音程">音程</span></h4>
<p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<div class="line-block">度数 | 半音数 | 名称 |</div>
<div class="line-block">—- | —— | —— |</div>
<div class="line-block">一 | 0 | 纯一度 |</div>
<div class="line-block">二 | 1 | 小二度 |</div>
<div class="line-block">二 | 2 | 大二度 |</div>
<div class="line-block">三 | 3 | 小三度 |</div>
<div class="line-block">三 | 4 | 大三度 |</div>
<div class="line-block">四 | 5 | 纯四度 |</div>
<div class="line-block">四 | 6 | 增四度 |</div>
<div class="line-block">五 | 6 | 减五度 |</div>
<div class="line-block">五 | 7 | 纯五度 |</div>
<div class="line-block">六 | 8 | 小六度 |</div>
<div class="line-block">六 | 9 | 大六度 |</div>
<div class="line-block">七 | 10 | 小七度 |</div>
<div class="line-block">七 | 11 | 大七度 |</div>
<div class="line-block">八 | 12 | 纯八度 |</div>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<div class="line-block">音程 | 频率比 |</div>
<div class="line-block">—— | —— |</div>
<div class="line-block">纯八度 | <span class="math inline">\(2 :
1\)</span> |</div>
<div class="line-block">纯五度 | <span class="math inline">\(3 :
2\)</span> |</div>
<div class="line-block">纯四度 | <span class="math inline">\(4 :
3\)</span> |</div>
<div class="line-block">大三度 | <span class="math inline">\(5 :
4\)</span> |</div>
<div class="line-block">小三度 | <span class="math inline">\(6 :
5\)</span> |</div>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4>
<p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定<span class="math inline">\(C\)</span>的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为<span class="math inline">\(1\)</span>,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求<span class="math inline">\(\{ 7 k \} \pmod{ 12
}\)</span>这个数列对吧,简单数论知识告诉我们它必然能遍历<span class="math inline">\(12\)</span>种情况,具体而言:</p>
$$
<span class="math display">\[\begin{aligned}
C \to &amp; &amp; G \to &amp; &amp; D \to &amp; &amp; A \to &amp; &amp;
E \to &amp; &amp; B \to \\
1 \to &amp; &amp; \frac{ 3 }{ 2 } \to &amp; &amp; \frac{ 3^2 }{ 2^3 }
\to &amp; &amp; \frac{ 3^3 }{ 2^4 } \to &amp; &amp; \frac{ 3^4 }{ 2^6 }
\to &amp; &amp; \frac{ 3^5 }{ 2^7 } \to \\
\\
\\
\# F \to &amp; &amp; \# C \to &amp; &amp; \# G \to &amp; &amp; \# D \to
&amp; &amp; \# A \to &amp; &amp; \# E \\
\frac{ 3^6 }{ 2^9 } \to &amp; &amp; \frac{ 3^7 }{ 2^{ 11 } } \to &amp;
&amp; \frac{ 3^8 }{ 2^{ 12 } } \to &amp; &amp; \frac{ 3^9 }{ 2^{ 14 } }
\to &amp; &amp; \frac{ 3^{ 10 } }{ 2^{ 15 } } \to &amp; &amp; \frac{ 3^{
11 } }{ 2^{ 17 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度<span class="math inline">\(CE\)</span>的比是<span class="math inline">\(\frac{ 81 }{ 64 } &gt; \frac{ 80 }{ 64 } = \frac{
5 }{ 4 }\)</span>.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的<span class="math inline">\(\# E \ne F\)</span>,你对着这个<span class="math inline">\(\# E\)</span>往上再升一个音得到的理应是<span class="math inline">\(C &#39; = \frac{ 3^{ 12 } }{ 2^{ 18 } } &gt;
2\)</span>,具体来说<span class="math inline">\(\frac{ 3^{ 12 } }{ 2^{ 19
} } \approx 1 .
013643\)</span>,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于<span class="math inline">\(1\)</span>的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升<span class="math inline">\(12\)</span>个纯五度,再下降<span class="math inline">\(7\)</span>个纯八度理应回到原点,可是:</p>
<p><span class="math display">\[
( \frac{ 3 }{ 2 } )^{ 12 } \times ( \frac{ 1 }{ 2 } )^7 &gt; 1
\]</span></p>
<p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4>
<p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定<span class="math inline">\(C\)</span>的频率为<span class="math inline">\(1\)</span>.接下来用正三和弦(一个大三度和一个小三度)<span class="math inline">\(I : C - E - G\)</span>,<span class="math inline">\(IV : F - A - C &#39;\)</span>,<span class="math inline">\(V : G - B - D &#39;\)</span>的比例是<span class="math inline">\(4 : 5 : 6\)</span>确定剩下的:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; &amp; D &amp; &amp; E &amp; &amp; F &amp; &amp; G &amp; &amp; A
&amp; &amp; B &amp; &amp; C &#39; &amp; &amp; D &#39; \\
1 &amp; &amp; \frac{ 9 }{ 8 } &amp; &amp; \frac{ 5 }{ 4 } &amp; &amp;
\frac{ 4 }{ 3 } &amp; &amp; \frac{ 3 }{ 2 } &amp; &amp; \frac{ 5 }{ 3 }
&amp; &amp; \frac{ 15 }{ 8 } &amp; &amp; 2 &amp; &amp; \frac{ 9 }{ 4 }
\end{aligned}
\]</span></p>
<p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol type="1">
<li><p>五度音程<span class="math inline">\(D -
A\)</span>不协和,比例为<span class="math inline">\(\frac{ 80 }{ 54 }
&lt; \frac{ 81 }{ 54 } = \frac{ 3 }{ 2
}\)</span>.这直接导致了转调会出错.</p></li>
<li><p>有两种不同的大二度:音程<span class="math inline">\(C - D , F - G
, A - B\)</span>的比例是<span class="math inline">\(\frac{ 9 }{ 8
}\)</span>而音程<span class="math inline">\(D - E , G -
A\)</span>的比例为<span class="math inline">\(\frac{ 10 }{ 9
}\)</span>.</p></li>
<li><p><strong>谐调音差</strong>:从<span class="math inline">\(C\)</span>出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:<span class="math inline">\(( \frac{ 3 }{ 2 } )^4 \times ( \frac{ 1 }{ 2 } )^2
\times \frac{ 4 }{ 5 } = \frac{ 81 }{ 80 } = 1 . 0125 &gt;
1\)</span>.</p></li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4>
<p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用<span class="math inline">\(\sqrt[12]{ 2
}\)</span>来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是<span class="math inline">\(f_1 , f_2\)</span>,则它们的音分数定义为<span class="math inline">\(1200 \log_2 ( \frac{ f_2 }{ f_1 }
)\)</span>,容易见到十二平均律拿到的一个半音恰好是<span class="math inline">\(100\)</span>音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3>
<h4><span id="大小调">大小调</span></h4>
<h5><span id="自然大调">自然大调</span></h5>
<p>就是我们最常用的<span class="math inline">\(CDEFGABC
&#39;\)</span>,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol type="1">
<li><p>主音</p></li>
<li><p>上主音</p></li>
<li><p>中音</p></li>
<li><p>下属音</p></li>
<li><p>属音</p></li>
<li><p>下中音</p></li>
<li><p>导音</p></li>
</ol>
<p>用五度相生,下属音<span class="math inline">\(\rightarrow\)</span>主音<span class="math inline">\(\rightarrow\)</span>属音.</p>
<h5><span id="自然小调">自然小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以<span class="math inline">\(ABCDEFG\)</span>用的调子,然而这里的问题是<span class="math inline">\(G\)</span>作为导音却和<span class="math inline">\(A &#39;\)</span>差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用<span class="math inline">\(A , B , C
, D , E , F , (^\# G )\)</span>.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用<span class="math inline">\(A , B , C
, D , E , (^\# F ) , (^\# G )\)</span>.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4>
<p>以五度相生:</p>
<p><span class="math display">\[
C \to G \to D \to A \to E \to B \to (^\# F ) \to (^\# C )
\]</span></p>
<p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从<span class="math inline">\(C\)</span>开始每次往后跳一次都要在一个音阶上增一个升号.从<span class="math inline">\(C\)</span>大调提升到<span class="math inline">\(G\)</span>大调的时候就是将<span class="math inline">\(C\)</span>的下属音(也就是<span class="math inline">\(F\)</span>)升音.</p>
<p>对称地,反方向的五度相生:</p>
<p><span class="math display">\[
C \to F \to (^b B ) \to (^b E ) \to (^b A ) \to (^b D ) \to (^b G ) \to
(^b C )
\]</span></p>
<p>那这个应该降什么呢?比如从<span class="math inline">\(C\)</span>大调提升到<span class="math inline">\(F\)</span>大调的时候就是将<span class="math inline">\(F\)</span>的下属音<span class="math inline">\(B\)</span>降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png"></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3>
<h4><span id="三和弦">三和弦</span></h4>
<p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol type="1">
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成<span class="math inline">\(4 : 5 : 6\)</span>的频率关系.</p></li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p></li>
<li><p>减三和弦:两个小三度.</p></li>
<li><p>增三和弦:两个大三度.</p></li>
</ol>
<h4><span id="七和弦">七和弦</span></h4>
<p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol type="1">
<li><p>减减七和弦(减七和弦):小小小.</p></li>
<li><p>减小七和弦(半减七和弦):小小大.</p></li>
<li><p>小小七和弦(小七和弦):小大小.</p></li>
<li><p>小大七和弦:小大大.</p></li>
<li><p>大小七和弦(属七和弦):大小小.</p></li>
<li><p>大大七和弦(大七和弦):大小大.</p></li>
<li><p>增大七和弦:大大小.</p></li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4>
<p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p></li>
</ol>
<p>对于七和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p></li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p></li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4>
<p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为<span class="math inline">\(C - E - G\)</span>,<span class="math inline">\(F -
A - C &#39;\)</span>,<span class="math inline">\(G - B - D
&#39;\)</span>.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol type="1">
<li><p>正格进行:<span class="math inline">\(I \to V \to
I\)</span>.</p></li>
<li><p>变格进行:<span class="math inline">\(I \to IV \to
I\)</span>.</p></li>
<li><p>复式进行:<span class="math inline">\(I \to IV \to V \to
I\)</span>.</p></li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<p><span class="math display">\[
\xymatrix{ &amp; &amp; &amp; &amp; I \\
&amp; &amp; IV \ar[r] \ar[d] \ar[dr] \ar[rru] &amp; vii \degree \ar[ru]
&amp; \\
iii \ar[r] &amp; vi \ar[r] \ar[ru] &amp; ii \ar[r] \ar[ru] &amp; V
\ar[ruu] &amp; }
\]</span></p>
<p>其中<span class="math inline">\(I\)</span>较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4>
<p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol type="1">
<li><p>平行变换<span class="math inline">\(P\)</span>:保持纯五度音阶不变,将三音切换.</p></li>
<li><p>关系变换<span class="math inline">\(R\)</span>:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p></li>
<li><p>导音变换<span class="math inline">\(L\)</span>:保持小三度音阶不变,补上剩下的一个.</p></li>
</ol>
<p>容易见到<span class="math inline">\(R \circ ( L \circ R )^3 =
P\)</span>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" class="post-title-link" itemprop="url">程序设计实习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2>
<h3><span id="基本分析">基本分析</span></h3>
<h4><span id="union-bound">Union Bound</span></h4>
<p>即:<span class="math inline">\(Pr [ \bigcup_i X_i ] \leq \sum Pr [
X_i ]\)</span>,取等当且仅当所有<span class="math inline">\(X_i\)</span>互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4>
<p>若<span class="math inline">\(X \geq 0\)</span>,则<span class="math inline">\(Pr [ X \geq t \mathbb{ E } [ X ] ] \leq \frac{ 1
}{ t }\)</span>.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6>
<p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有<span class="math inline">\(\frac{ 1 }{
2 }\)</span>的概率是割边,因此期望自然是<span class="math inline">\(\frac{ 1 }{ 2 } | E | \geq \frac{ 1 }{ 2 } |
\text{ max - cut } |\)</span>.</p>
<p>由此立即见到,<span class="math inline">\(Pr [ | ans | \leq ( \frac{ 1
}{ 2 } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac{ 1 }{ 2
} + \epsilon ) | E | ] \leq \frac{ 1 }{ 1 + 2 \epsilon }\)</span>.</p>
<p>由于每次独立操作,因此如果有<span class="math inline">\(P\)</span>的概率失败,那么运行<span class="math inline">\(T\)</span>次后至少成功一次的概率应当为<span class="math inline">\(1 - P^T\)</span>.从而<span class="math inline">\(T
= O ( \log_P{ \delta } ) = O ( \cfrac{ \ln \frac{ 1 }{ \delta } }{ \ln (
1 +{ 2 \epsilon } ) } ) \approx O ( \cfrac{ \ln \frac{ 1 }{ \delta } }{
\epsilon } )\)</span>即可拿到<span class="math inline">\(\delta\)</span>失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>设<span class="math inline">\(X_1 , \cdots , X_n \in [ 0 , 1
]\)</span>是独立,同期望(期望为<span class="math inline">\(\mu \geq
t\)</span>)的随机变量,令<span class="math inline">\(X = \frac{ \sum_k
X_k }{ n }\)</span>,对于任何失败概率<span class="math inline">\(\delta
\in ( 0 , 1 )\)</span>,应当有:</p>
<p><span class="math display">\[
Pr \left [ | X - \mu | \geq \sqrt{ \cfrac{ \log ( 1 / \delta ) }{ nt } }
\mu \right ] \leq \delta
\]</span></p>
<h6><span id="examplemedian-trick">Example(Median Trick)</span></h6>
<p>现在有一个黑盒能够以<span class="math inline">\(p &gt; \frac{ 1 }{ 2
}\)</span>的概率正确回答Yes或者No,问重复<span class="math inline">\(T\)</span>选多少次能拿到<span class="math inline">\(1 - \delta\)</span>的成功概率.</p>
<p>考虑重复<span class="math inline">\(T\)</span>次后应当有期望<span class="math inline">\(pT\)</span>个正确答案,因此直接取中位数.称此算法为Median
Trick.</p>
<p>Chernoff Bound 告诉我们<span class="math inline">\(T = O ( \log
\frac{ 1 }{ \delta } )\)</span>足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4>
<p>设独立随机变量<span class="math inline">\(x_1 , \cdots , x_m \in [ s
, t ]\)</span>,令<span class="math inline">\(X = \sum_i
x_i\)</span>,则:</p>
<p><span class="math display">\[
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac{ 2 z^2 }{ m ( t -
s )^2 } \right )
\]</span></p>
<h3><span id="编程中的随机性">编程中的随机性</span></h3>
<p>一般采用伪随机,也即是给定初值<span class="math inline">\(X_0\)</span>,通过某个确定性的函数来生成<span class="math inline">\(X_{ n + 1 } = f ( X_n )\)</span>这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1 - ( 1 - p )^k\)</span>,时间复杂度为<span class="math inline">\(O ( kf ( n ) )\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为<span class="math inline">\(O ( f ( n ) g ( n
) )\)</span>,其中<span class="math inline">\(f ( n
)\)</span>为枚举部分的复杂度,<span class="math inline">\(g ( n
)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g ( n )\)</span>不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n \leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O ( n^3 )\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil \frac{ n }{ 7 }
\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{ 1 }{ 7
}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{ 1 }{ 49 }\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1 - ( \frac{ 48 }{ 49 } )^{ 1000
}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{ n }{ 2
}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n \leq
10^6\)</span>,<span class="math inline">\(a_i \leq 10^{ 12
}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O ( n \sqrt{ a } )\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt{ a
}\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([ l , r ]\)</span>,问<span class="math inline">\(a
[ l , r
]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\(( n , m \leq 500000 , 1 \leq a_i \leq n
)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k = 2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O ( n^2 d )\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A = \begin{bmatrix}\vec{ a_1 } , \vec{ a_2 } , . .
. , \vec{ a_n }\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B =
AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{ i , j }\)</span>在<span class="math inline">\(\mod 2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B =
C\)</span>,那么对于任意一个<span class="math inline">\(X_{ m \times n
}\)</span>都应该满足<span class="math inline">\(XB = XC\)</span>,取<span class="math inline">\(m =
1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB \ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O ( nd )\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O ( n
)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D = B -
C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{ i , j } \ne 0\)</span>.我们令<span class="math inline">\(E = X \times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j = \sum_{ k } X_k D_{ k , j
}\)</span>,不难解得:<span class="math inline">\(E_i = - \frac{ 1 }{ D_{
i , j } } \sum_{ k \ne i } X_k D_{ k , j }\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O ( nd )\)</span>.</p>
<p><span class="math inline">\(k = 3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{
j } B_{ i , j }^2 X_j = \sum_{ j } B_{ i , j } X_j B_{ h , i
}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T ( n )\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要<span class="math inline">\(+
1\)</span>或者<span class="math inline">\(-
1\)</span>或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ n - 1 } ( T_i
+ T_{ n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ \frac{ 3 n }{
4 } } ( T ( i ) + T ( n - i - 1 ) ) + \frac{ 2 }{ n } \sum_{ i = \frac{
3 n }{ 4 } }^{ n } ( T ( i ) + T ( n - i - 1 ) )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(T ( n ) \geq n\)</span>,所以对于<span class="math inline">\(\frac{ n }{ 2 } \leq i \leq
j\)</span>,我们显然有:<span class="math inline">\(T ( i ) + T ( n - i )
\leq T ( j ) + T ( n - j )\)</span>.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{
\frac{ 3 n }{ 4 } } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n }{ 4 } ) )
+ \frac{ 2 }{ n } \sum_{ i = \frac{ 3 n }{ 4 } }^{ n } ( T ( n - 1 ) + T
( 0 ) ) \\
&amp; \leq n + \frac{ 1 }{ 2 } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n
}{ 4 } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T ( n ) \leq cn \log
n\)</span>,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 1 }{ 2 } ( \frac{ 3 cn }{ 4 } \log (
\frac{ 3 n }{ 4 } ) + \frac{ cn }{ 4 } \log ( \frac{ n }{ 4 } ) + c ( n
- 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac{ 3 n }{ 8 } \log n - \frac{ 3 n }{ 8 } \log
\frac{ 4 }{ 3 } + \frac{ n }{ 8 } \log n - \frac{ n }{ 4 } + \frac{ n }{
2 } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac{ 3 c }{ 8 } \log ( \frac{ 4 }{ 3 } ) -
\frac{ c }{ 4 } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^{ i - 1 } i \\
( 1 - p ) k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^i i \\
pk &amp; = \sum_{ i = 2 }^{ \infty } p ( 1 - p )^{ i - 1 } = p \sum_{ i
= 0 }^{ \infty } ( 1 - p )^i \\
k &amp; = \frac{ 1 }{ p }
\end{aligned}
\]</span></p>
<p>则期望复杂度为<span class="math inline">\(O ( \frac{ f ( n ) }{ p }
)\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([ x_1 , x_2 )\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1 \times 2 \leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>),而此时的<span class="math inline">\([ x_1 , x_2
)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1 , 2 , 4 , . .
.\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E_{ t + 1 } &gt; E_t \\
e^{ \frac{ E_{ t + 1 } - E_t }{ T } } &amp; E_{ t + 1 } \leq E_t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k
\in ( 0 , 1 )\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T = kT\)</span>,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间<span class="math inline">\(\Omega\)</span>:在一个给定问题中可能发生的所有情况.</p>
<p>事件:<span class="math inline">\(\Omega\)</span>的一个子集.</p>
<p>基本事件<span class="math inline">\(\omega\)</span>:<span class="math inline">\(\Omega\)</span>中的单个元素,也可以看作集合大小为<span class="math inline">\(1\)</span>的事件.</p>
<p>概率:若<span class="math inline">\(\omega \in
\Omega\)</span>,我们称它发生的概率为<span class="math inline">\(\Pr (
\omega )\)</span>,有<span class="math inline">\(\Pr ( \omega ) \geq
0\)</span>且<span class="math inline">\(\sum_{ \omega \in \Omega } \Pr (
\omega ) = 1\)</span>.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>定义在同一个概率空间<span class="math inline">\(\Omega\)</span>上,对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,我们称<span class="math inline">\(\Pr (
X = x \land Y = y )\)</span>为它们的联合分布.</p>
<p>独立:如果对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,<span class="math inline">\(\Pr ( X = x
\land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y )\)</span>,我们称<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是独立的.</p>
<p>期望(均值)<span class="math inline">\(E
X\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的期望<span class="math inline">\(EX =
\sum_{ x \in X ( \Omega ) } x \times \Pr ( X = x ) = \sum_{ w \in \Omega
} X ( \omega ) \Pr ( \omega )\)</span>.</p>
<p>中位数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的中位数为满足<span class="math inline">\(\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x )
\geq 0 . 5\)</span>的<span class="math inline">\(x \in X ( \Omega
)\)</span>所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的众数为满足<span class="math inline">\(\Pr ( X = x ) \geq \Pr ( X = x &#39; ) , \forall x
&#39; \in X ( \Omega )\)</span>的<span class="math inline">\(x \in X (
\Omega )\)</span>所组成的集合.</p>
<p>方差<span class="math inline">\(VX\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的方差<span class="math inline">\(VX = E
( ( X - EX )^2 )\)</span>.</p>
<p>标准差<span class="math inline">\(\sigma\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的标准差<span class="math inline">\(\sigma = \sqrt{ VX }\)</span>.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果<span class="math inline">\(X ,
Y\)</span>是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><p><span class="math inline">\(E ( X + Y ) = EX +
EY\)</span>.</p></li>
<li><p><span class="math inline">\(E ( \alpha X ) = \alpha
EX\)</span>.</p></li>
<li><p>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>互相独立,那么<span class="math inline">\(E ( XY ) = ( EX ) ( EY )\)</span>.</p></li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X - EX )^2 ) &amp; = E ( X^2 - 2 X ( EX ) + ( EX )^2 ) \\
&amp; = E ( X^2 ) - 2 ( EX ) ( EX ) + ( EX )^2 \\
&amp; = E ( X^2 ) - ( EX )^2
\end{aligned}
\]</span></p>
<p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为独立的随机变量时,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( ( X + Y )^2 ) - ( EX + EY )^2 \\
&amp; = E ( ( X + Y )^2 ) - ( EX )^2 - 2 ( EX ) ( EY ) - ( EY )^2
\end{aligned}
\]</span></p>
<p>而又有:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X + Y )^2 ) &amp; = E ( X^2 + 2 XY + Y^2 ) \\
&amp; = E ( X^2 ) + 2 ( EX ) ( EY ) + E ( Y^2 )
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( X^2 ) + 2 ( EX ) ( EY ) + E ( Y^2 ) - ( EX )^2 -
2 ( EX ) ( EY ) - ( EY )^2 \\
&amp; = VX + VY
\end{aligned}
\]</span></p>
<p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<p><span class="math display">\[
\Pr ( ( X - EX )^2 \geq \alpha ) \leq \cfrac{ VX }{ \alpha } , \alpha
&gt; 0
\]</span></p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
VX &amp; = \sum_{ \omega \in \Omega } ( X ( \omega ) - EX )^2 \Pr (
\omega ) \\
&amp; \geq \sum_{ \omega \in \Omega } ( X ( \omega ) - EX )^2 \Pr (
\omega ) [ ( X ( \omega ) - EX )^2 \geq \alpha ] \\
&amp; \geq \sum_{ \omega \in \Omega } \alpha \Pr ( \omega ) [ ( X (
\omega ) - EX )^2 \geq \alpha ] \\
&amp; = \alpha \Pr ( ( X - EX )^2 \geq \alpha )
\end{aligned}
\]</span></p>
<p>如果我们用<span class="math inline">\(c^2 VX\)</span>代替<span class="math inline">\(\alpha\)</span>,我们就有:</p>
<p><span class="math inline">\(\Pr ( | X - EX | \geq c \sigma ) \leq
\cfrac{ 1 }{ c^2 }\)</span>.</p>
<p>简单来说,这个不等式说明:<span class="math inline">\(X\)</span>落在<span class="math inline">\(( EX - c
\sigma , EX + c \sigma )\)</span>之外的概率至多为<span class="math inline">\(\cfrac{ 1 }{ c^2 }\)</span>.</p>
<p>另外,如果我们取<span class="math inline">\(n\)</span>个独立的样本<span class="math inline">\(X_1 , X_2 , . . . , X_n\)</span>,令<span class="math inline">\(S = \sum_{ i = 1 }^n
X_i\)</span>,那么它的均值是<span class="math inline">\(nEX\)</span>,标准差是<span class="math inline">\(\sqrt{ n } \sigma\)</span>,也就是说,<span class="math inline">\(\cfrac{ S }{ n }\)</span>落在<span class="math inline">\(( EX - \cfrac{ c \sigma }{ \sqrt{ n } } , EX +
\cfrac{ c \sigma }{ \sqrt{ n } } )\)</span>之外的概率小于等于<span class="math inline">\(\cfrac{ 1 }{ c^2 }\)</span>.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了<span class="math inline">\(n\)</span>个值<span class="math inline">\(X_1 , X_2 , . . . ,
X_n\)</span>,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p><span class="math inline">\(\hat EX = \cfrac{ \sum_{ i = 1 }^n X_i }{
n }\)</span>.</p>
<p><span class="math inline">\(\hat VX = \cfrac{ \sum_{ i = 1 }^n X_i^2
}{ n - 1 } - \cfrac{ ( \sum_{ i = 1 }^n X_i )^2 }{ n ( n - 1 )
}\)</span>.</p>
<p>这里的<span class="math inline">\(\hat
VX\)</span>似乎与定义不是那么相符.但是它拥有更好的性质:<span class="math inline">\(E ( \hat VX ) = VX\)</span>.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \hat VX ) &amp; = \cfrac{ 1 }{ n - 1 } E ( \sum_{ i = 1 }^n X_i^2 -
\cfrac{ 1 }{ n } \sum_{ j = 1 }^n \sum_{ k = 1 }^n X_j X_k ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( \sum_{ i = 1 }^n E ( X_i^2 ) - \cfrac{ 1
}{ n } \sum_{ i = 1 }^n \sum_{ j = 1 }^n E ( X_i X_j ) ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( \sum_{ i = 1 }^n E ( X^2 ) - \cfrac{ 1 }{
n } \sum_{ i = 1 }^n \sum_{ j = 1 }^n ( ( EX )^2 [ j \ne k ] + E ( X^2 )
[ j = k ] ) ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( nE ( X^2 ) - \cfrac{ 1 }{ n } ( nE ( X^2
) + n ( n - 1 ) ( EX )^2 ) ) \\
&amp; = E ( X^2 ) - ( EX )^2 \\
&amp; = VX
\end{aligned}
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为<span class="math inline">\(P ( A | B
) = \frac{ P ( AB ) }{ P ( B ) } \\\)</span>.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有<span class="math inline">\(\{ B_i
\}\)</span>是样本空间的一个划分,即<span class="math inline">\(\forall i
, j\)</span>,有<span class="math inline">\(B_i \cap B_j =
\emptyset\)</span>,并且有<span class="math inline">\(\bigcup_{ i = 1 }^n
B_i = \Omega\)</span>.则有<span class="math inline">\(P ( B_i | A ) =
\frac{ P ( AB_i ) }{ P ( A ) } = \frac{ P ( AB_i ) }{ P ( A ) \sum P (
B_j ) } = \frac{ P ( A B_i ) }{ \sum_{ j = 1 }^n P ( A B_j ) } = \frac{
P ( A | B_i ) P ( B_i ) }{ \sum_{ j = 1 }^n P ( A | B_j ) P ( B_j ) }
\\\)</span>.</p>
<p>简化形式:<span class="math inline">\(P ( B | A ) = \frac{ P ( A | B )
P ( B ) }{ P ( A ) } \\\)</span>.</p>
<p>另外,我们考虑设<span class="math inline">\(O ( B ) = \cfrac{ P ( B )
}{ P ( \lnot B ) }\)</span>,称<span class="math inline">\(\cfrac{ P ( B
| E ) }{ P ( \lnot B | E ) }\)</span>为贝叶斯算子,则同理可得:</p>
<p><span class="math display">\[
O ( B | E ) = O ( B ) \cfrac{ P ( B | E ) }{ P ( \lnot B | E ) }
\]</span></p>
<p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果<span class="math inline">\(X\)</span>是定义在概率空间<span class="math inline">\(\Omega\)</span>上的随机变量,那么它的概率生成函数为<span class="math inline">\(G_X ( z ) = \sum_{ k \geq 0 } \Pr ( X = k ) z^k =
E ( z^X )\)</span>.</p>
<p>不难发现<span class="math inline">\(G_X ( z
)\)</span>需要满足的条件:所有系数都非负并且<span class="math inline">\(G_X ( 1 ) = 1\)</span>.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = G_X &#39; ( 1 ) \\
E ( X^2 ) &amp; = G &#39; &#39;_X ( 1 ) + G_X &#39; ( 1 ) \\
VX &amp; = G_X &#39; &#39; ( 1 ) + G_X &#39; ( 1 ) - ( G_X &#39; ( 1 )
)^2
\end{aligned}
\]</span></p>
<p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G ) &amp; = G &#39; ( 1 ) \\
Var ( G ) &amp; = G &#39; &#39; ( 1 ) + G &#39; ( 1 ) - ( G &#39; ( 1 )
)^2
\end{aligned}
\]</span></p>
<p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<p><span class="math display">\[
G ( 1 + t ) = \sum_{ i \geq 0 } \cfrac{ G^{ ( i ) } ( 1 ) }{ i ! } t^i
\]</span></p>
<p>另外,我们不难发现:<span class="math inline">\(G_{ X + Y } ( z ) = G_X
( z ) G_Y ( z )\)</span>.</p>
<p>根据前面的推导,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G_{ X + Y } ) &amp; = Mean ( G_X ) + Mean ( G_Y ) \\
Var ( G_{ X + Y } ) &amp; = Var ( G_X ) + Var ( G_Y )
\end{aligned}
\]</span></p>
<p>换句话说,若<span class="math inline">\(G_X ( 1 ) = 1 , G_Y ( 1 ) =
1\)</span>,那么这个式子与直接对<span class="math inline">\(G_{ X + Y
}\)</span>使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G_X ) &amp; = Mean ( G_{ X + Y } ) - Mean ( G_Y ) \\
Var ( G_X ) &amp; = Var ( G_{ X + Y } ) - Var ( G_Y )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为<span class="math inline">\(p\)</span>,反面向上的概率为<span class="math inline">\(q\)</span>,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设<span class="math inline">\(N\)</span>为所有不包含THTTH的硬币序列的生成函数,<span class="math inline">\(S\)</span>为所有只有结尾为THTTH的硬币序列的生成函数,令<span class="math inline">\(H = pz , T = qz\)</span>,<span class="math inline">\(1\)</span>为空集,我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N \times ( H + T ) &amp; = N + S \\
N \times THTTH &amp; = S + S \times TTH
\end{aligned}
\]</span></p>
<p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设<span class="math inline">\(A\)</span>是我们要找到的字符串,<span class="math inline">\(m\)</span>是它的长度,令<span class="math inline">\(A^{ ( k ) }\)</span>表示<span class="math inline">\(A\)</span>字符串的前<span class="math inline">\(k\)</span>个字符所组成的字符串,<span class="math inline">\(A_{ ( k ) }\)</span>表示<span class="math inline">\(A\)</span>字符串的后<span class="math inline">\(k\)</span>个字符所组成的字符串.这样的形式与<span class="math inline">\(k\)</span>阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S \\
N \times A &amp; = S ( \sum_{ k = 0 }^{ m - 1 } A^{ ( k ) } [ A^{ ( m -
k ) } = A_{ ( m - k ) } ] )
\end{aligned}
\]</span></p>
<p>如果我们设<span class="math inline">\(\tilde{ A
}\)</span>为将字符串<span class="math inline">\(A\)</span>中的H替换成<span class="math inline">\(\cfrac{ 1 }{ p } z\)</span>,T替换成<span class="math inline">\(\cfrac{ 1 }{ q }
z\)</span>之后的值,那么显然有:</p>
<p><span class="math display">\[
\begin{aligned}
N \times A &amp; = A \times S \times ( \sum_{ k = 1 }^{ m } \tilde{ A
}_{ ( k ) } [ A^{ ( k ) } = A_{ ( k ) } ] ) \\
N &amp; = S \times ( \sum_{ k = 1 }^{ m } \tilde{ A }_{ ( k ) } [ A^{ (
k ) } = A_{ ( k ) } ] ) \\
\cfrac{ S - 1 }{ H + T - 1 } &amp; = S \times ( \sum_{ k = 1 }^{ m }
\tilde{ A }_{ ( k ) } [ A^{ ( k ) } = A_{ ( k ) } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum_{ k = 1 }^{ m } \tilde{ A }_{
( k ) } [ A^{ ( k ) } &amp; = A_{ ( k ) } ] ) ) = 1
\end{aligned}
\]</span></p>
<p>这显然是一个卷积的形式.</p>
<p>令<span class="math inline">\(w = \sum_{ k = 1 }^{ m } \tilde{ A }_{
( k ) } [ A^{ ( k ) } = A_{ ( k ) } ]\)</span>.</p>
<p>令<span class="math inline">\(H ( z ) = 1\)</span>,<span class="math inline">\(F ( z ) = ( 1 + ( 1 - z ) \times w
)\)</span>,<span class="math inline">\(G ( z ) = S\)</span>.</p>
<p>那么我们显然可以直接求<span class="math inline">\(G ( z
)\)</span>的期望和方差,事实上:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = \sum_{ k = 1 }^{ m } \tilde{ A }_{ ( k ) } [ A^{ ( k ) } =
A_{ ( k ) } ] \\
VX &amp; = ( EX )^2 - \sum_{ k = 1 }^m ( 2 k - 1 ) \tilde{ A }_{ ( k ) }
[ A^{ ( k ) } = A_{ ( k ) } ]
\end{aligned}
\]</span></p>
<p>如果硬币是均匀的(<span class="math inline">\(p = q = \cfrac{ 1 }{ 2
}\)</span>)我们引入另一个符号:我们设<span class="math inline">\(A : A =
\sum_{ k = 1 }^m 2^{ k } [ A^{ ( k ) } = A_{ ( k ) }
]\)</span>.那么显然期望需要的抛硬币次数就是<span class="math inline">\((
A : A )\)</span>.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设<span class="math inline">\(S_A\)</span>为所有以HHT结尾的硬币序列的生成函数,设<span class="math inline">\(S_B\)</span>为所有以HTT结尾的硬币序列的生成函数.<span class="math inline">\(N\)</span>为其它的硬币序列的生成函数,令<span class="math inline">\(H = T = 0 . 5 z\)</span>.</p>
<p>我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S_A + S_B \\
N \times HHT &amp; = S_A \\
N \times HTT &amp; = S_A \times T + S_B
\end{aligned}
\]</span></p>
<p>解方程并带入<span class="math inline">\(z =
1\)</span>,可以有得知以HHT结尾的概率为<span class="math inline">\(\cfrac{ 2 }{ 3 }\)</span>.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,那么可以求出:</p>
<p><span class="math display">\[
\cfrac{ S_A }{ S_B } = \cfrac{ B : B - B : A }{ A : A - A : B }
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{ k , i }\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F , G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p><span class="math inline">\(1 + xG ( x ) = \sum_k F_k ( x ) + G (
x )\)</span>.</p></li>
<li><p><span class="math inline">\(( \frac{ 1 }{ 2 } x )^L G ( x ) =
\sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 } ( \frac{ 1 }{ 2 } x
)^i [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i ) } ]\)</span>.</p></li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x =
1\)</span>,发现<span class="math inline">\(\sum_{ k } F_k ( 1 ) =
1\)</span>.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 }
( \frac{ 1 }{ 2 } x )^{ i - L } [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i )
} ] \\
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 1 }^{ L } (
\frac{ 1 }{ 2 } x )^{ - i } [ A_k^{ ( i ) } ={ A_j }_{ ( i ) } ]
\end{aligned}
\]</span></p>
<p>带入<span class="math inline">\(x = 1\)</span>,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum_{ j = 1 }^n F_j ( 1 ) \sum_{ i = 1 }^{ L } 2^i [ A_k^{ (
i ) } ={ A_j }_{ ( i ) } ]
\]</span></p>
<p>不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n + 1\)</span>个等式,可以算出<span class="math inline">\(G ( 1 ) , F_{ 1 \cdots n } ( 1 )\)</span>这<span class="math inline">\(n + 1\)</span>个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为<span class="math inline">\(n +
1\)</span>的概率空间,其中<span class="math inline">\(\Pr ( \omega_k ) =
\binom{ n }{ k } p^k q^{ n - k }
\\\)</span>,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令<span class="math inline">\(H ( z ) = q +
pz\)</span>,不难发现二项式分布的生成函数为<span class="math inline">\(H
( z )^n\)</span>.</p>
<p>不难发现,满足二项式分布的随机变量的均值是<span class="math inline">\(np\)</span>,方差是<span class="math inline">\(npq\)</span>.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:<span class="math inline">\(G ( z )^n = ( \cfrac{ p }{ 1 - qz } )^n = \sum_{ k
} \binom{ n + k - 1 }{ k } p^n q^k z^k\)</span>.</p>
<p>我们考虑如何求<span class="math inline">\(G ( z
)\)</span>的方差和均值,不妨设<span class="math inline">\(F ( z ) =
\cfrac{ 1 - qz }{ p } = \cfrac{ 1 }{ p } - \cfrac{ q }{ p }
z\)</span>,则<span class="math inline">\(G ( z )^n = F ( z )^{ - n
}\)</span>.</p>
<p>不难发现<span class="math inline">\(F ( z
)\)</span>满足二项式分布.也就是说,以<span class="math inline">\(( n , p
, q )\)</span>为参数的负二项式分布也就是以<span class="math inline">\((
- n , - \cfrac{ q }{ p } , \cfrac{ 1 }{ p }
)\)</span>为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为<span class="math inline">\(1\)</span>的<span class="math inline">\(n\)</span>个点的树,问所有点对<span class="math inline">\(( i , j ) ( 1 \leq i , j \leq n
)\)</span>中,从<span class="math inline">\(i\)</span>走到<span class="math inline">\(j\)</span>的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设<span class="math inline">\(f_u\)</span>表示<span class="math inline">\(u\)</span>随机走到它父亲的期望,<span class="math inline">\(g_v\)</span>表示<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的期望.</p>
<p>对于<span class="math inline">\(f_u\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_u &amp; = \cfrac{ \sum_{ u \rightarrow v } ( f_v + f_u ) }{ \deg_u } +
1 \\
f_u &amp; = \deg_u + \sum_{ u \rightarrow v } f_v
\end{aligned}
\]</span></p>
<p>对于<span class="math inline">\(g_v\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
g_v &amp; = \cfrac{ g_u + g_v + \sum_{ u \rightarrow w , w \ne v } ( g_v
+ f_w ) }{ \deg_u } + 1 \\
g_v &amp; = g_u + \sum_{ u \rightarrow w , w \ne v } f_w + \deg_u
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵<span class="math inline">\(n\)</span>个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从<span class="math inline">\(1\)</span>号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案<span class="math inline">\(+ 1\)</span>.当走到度数为<span class="math inline">\(1\)</span>的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设<span class="math inline">\(f_u\)</span>表示以<span class="math inline">\(u\)</span>为起点的路径的期望长度,不难注意到<span class="math inline">\(f_{ leaf } = 1\)</span>且<span class="math inline">\(f_u = 1 + \cfrac{ 1 }{ \deg_u } \sum_{ u
\rightarrow v \lor v \rightarrow u }
f_v\)</span>.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得<span class="math inline">\(f_u = k_u f_{ fa } +
b_u\)</span>,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出<span class="math inline">\(g_v\)</span>表示从<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的概率,再令<span class="math inline">\(f_u\)</span>表示从<span class="math inline">\(u\)</span>走到父亲的概率,类似Example1,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_u &amp; = \cfrac{ 1 }{ \deg_u } ( 1 + \sum_{ u \rightarrow v } f_v f_u
) \\
g_v &amp; = \cfrac{ 1 }{ \deg_u } ( 1 + g_v g_u + \sum_{ u \rightarrow w
, w \ne v } f_w g_v )
\end{aligned}
\]</span></p>
<p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为<span class="math inline">\(\frac{ 1 }{ \binom{ n }{ 2 } }\)</span>.</p>
<p>把所有人权值从大到小排序,设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>个人的时候的期望,不难发现:<span class="math inline">\(f_{ i } = \frac{ 1 }{ \binom{ i }{ 2 } } v_i + ( 1
- \frac{ 1 }{ \binom{ i }{ 2 } } ) f_{ i - 1 }\)</span>.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设<span class="math inline">\(f_{ i , j }\)</span>表示过了<span class="math inline">\(i\)</span>关,花费为<span class="math inline">\(j\)</span>的期望,不难发现所有的<span class="math inline">\(f\)</span>都需要与<span class="math inline">\(f_{
0 , 0 }\)</span>取<span class="math inline">\(\min\)</span>,这咋办?</p>
<p>我们考虑二分这个<span class="math inline">\(f_{ 0 , 0
}\)</span>,做的时候直接取<span class="math inline">\(\min\)</span>,这样最后还会求出一个<span class="math inline">\(f_{ 0 , 0
}\)</span>,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的<span class="math inline">\(f_{ 0 , 0
}\)</span>越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取<span class="math inline">\(\min\)</span>的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张<span class="math inline">\(n \times
m\)</span>的图(假设<span class="math inline">\(n \geq
m\)</span>),其中格点<span class="math inline">\(( a , b
)\)</span>表示现在还剩<span class="math inline">\(a\)</span>个Yes,<span class="math inline">\(b\)</span>个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从<span class="math inline">\(( n , m )\)</span>走到<span class="math inline">\(( 0 , 0
)\)</span>的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线<span class="math inline">\(y =
x\)</span>翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从<span class="math inline">\(( n , m )\)</span>走到<span class="math inline">\(( 0 , 0 )\)</span>一定会经过<span class="math inline">\(n\)</span>条有向边,所以期望贡献一定要加上一个<span class="math inline">\(n\)</span>.而如果我走到了直线<span class="math inline">\(y = x\)</span>上,那接下来的贡献是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2>
<h3><span id="树">树</span></h3>
<ol type="1">
<li><p>随机树树高为<span class="math inline">\(\sqrt{ n
}\)</span>.</p></li>
<li><p>点的度数期望为<span class="math inline">\(\log
n\)</span>.</p></li>
</ol>
<h3><span id="数">数</span></h3>
<ol type="1">
<li>数字的期望因数个数为<span class="math inline">\(\log
V\)</span>.</li>
</ol>
<h3><span id="序列">序列</span></h3>
<ol type="1">
<li>随机序列的LIS长度期望为<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1 - ( 1 - p )^k\)</span>,时间复杂度为<span class="math inline">\(O ( kf ( n ) )\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为<span class="math inline">\(O ( f ( n ) g ( n
) )\)</span>,其中<span class="math inline">\(f ( n
)\)</span>为枚举部分的复杂度,<span class="math inline">\(g ( n
)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g ( n )\)</span>不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n \leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O ( n^3 )\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil \frac{ n }{ 7 }
\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{ 1 }{ 7
}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{ 1 }{ 49 }\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1 - ( \frac{ 48 }{ 49 } )^{ 1000
}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{ n }{ 2
}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n \leq
10^6\)</span>,<span class="math inline">\(a_i \leq 10^{ 12
}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O ( n \sqrt{ a } )\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt{ a
}\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([ l , r ]\)</span>,问<span class="math inline">\(a
[ l , r
]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\(( n , m \leq 500000 , 1 \leq a_i \leq n
)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k = 2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O ( n^2 d )\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A = \begin{bmatrix}\vec{ a_1 } , \vec{ a_2 } , . .
. , \vec{ a_n }\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B =
AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{ i , j }\)</span>在<span class="math inline">\(\mod 2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B =
C\)</span>,那么对于任意一个<span class="math inline">\(X_{ m \times n
}\)</span>都应该满足<span class="math inline">\(XB = XC\)</span>,取<span class="math inline">\(m =
1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB \ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O ( nd )\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O ( n
)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D = B -
C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{ i , j } \ne 0\)</span>.我们令<span class="math inline">\(E = X \times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j = \sum_{ k } X_k D_{ k , j
}\)</span>,不难解得:<span class="math inline">\(E_i = - \frac{ 1 }{ D_{
i , j } } \sum_{ k \ne i } X_k D_{ k , j }\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O ( nd )\)</span>.</p>
<p><span class="math inline">\(k = 3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{
j } B_{ i , j }^2 X_j = \sum_{ j } B_{ i , j } X_j B_{ h , i
}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T ( n )\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要<span class="math inline">\(+
1\)</span>或者<span class="math inline">\(-
1\)</span>或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ n - 1 } ( T_i
+ T_{ n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ \frac{ 3 n }{
4 } } ( T ( i ) + T ( n - i - 1 ) ) + \frac{ 2 }{ n } \sum_{ i = \frac{
3 n }{ 4 } }^{ n } ( T ( i ) + T ( n - i - 1 ) )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(T ( n ) \geq n\)</span>,所以对于<span class="math inline">\(\frac{ n }{ 2 } \leq i \leq
j\)</span>,我们显然有:<span class="math inline">\(T ( i ) + T ( n - i )
\leq T ( j ) + T ( n - j )\)</span>.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{
\frac{ 3 n }{ 4 } } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n }{ 4 } ) )
+ \frac{ 2 }{ n } \sum_{ i = \frac{ 3 n }{ 4 } }^{ n } ( T ( n - 1 ) + T
( 0 ) ) \\
&amp; \leq n + \frac{ 1 }{ 2 } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n
}{ 4 } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T ( n ) \leq cn \log
n\)</span>,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 1 }{ 2 } ( \frac{ 3 cn }{ 4 } \log (
\frac{ 3 n }{ 4 } ) + \frac{ cn }{ 4 } \log ( \frac{ n }{ 4 } ) + c ( n
- 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac{ 3 n }{ 8 } \log n - \frac{ 3 n }{ 8 } \log
\frac{ 4 }{ 3 } + \frac{ n }{ 8 } \log n - \frac{ n }{ 4 } + \frac{ n }{
2 } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac{ 3 c }{ 8 } \log ( \frac{ 4 }{ 3 } ) -
\frac{ c }{ 4 } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^{ i - 1 } i \\
( 1 - p ) k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^i i \\
pk &amp; = \sum_{ i = 2 }^{ \infty } p ( 1 - p )^{ i - 1 } = p \sum_{ i
= 0 }^{ \infty } ( 1 - p )^i \\
k &amp; = \frac{ 1 }{ p }
\end{aligned}
\]</span></p>
<p>则期望复杂度为<span class="math inline">\(O ( \frac{ f ( n ) }{ p }
)\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([ x_1 , x_2 )\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1 \times 2 \leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>),而此时的<span class="math inline">\([ x_1 , x_2
)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1 , 2 , 4 , . .
.\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E_{ t + 1 } &gt; E_t \\
e^{ \frac{ E_{ t + 1 } - E_t }{ T } } &amp; E_{ t + 1 } \leq E_t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k
\in ( 0 , 1 )\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T = kT\)</span>,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/4/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
