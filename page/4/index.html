<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/4/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">文化课数学导论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A2%AB%E6%96%87%E5%8C%96%E8%AF%BE%E5%88%9B%E9%A3%9E%E4%BA%86/" itemprop="url" rel="index"><span itemprop="name">被文化课创飞了</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="概统导论">概统导论</span></h2><h3><span id="习惯的更改">习惯的更改</span></h3><p>这一部分主要是和组合相关,文化课中的组合内容有一些很奇怪的形式,比如竞赛中为了避免巨量的字母符号所带来的丑陋形式,会将$C _{ n  } ^k $写作$\binom { n  } { k  } $,而文化课中不允许此类更改,再者文化课中将$C _{ n  } ^k a ^{ n - k  } b ^k $称作二项式的第$k + 1 $项(从第$1 $项开始编号),此等同样是一个需要改正的习惯.</p>
<h3><span id="从线性角度审视">从线性角度审视</span></h3><p>首先我们有$E ( aX + b ) = aE ( X ) + b , D ( aX + b ) = a ^2 D ( X ) $.</p>
<p>我们都知道期望满足线性可加,也就是$E ( X _1 + X _2 ) = E ( X _1 ) + E ( X _2 ) $,这很好理解,因为期望从一开始定义就是所有情况下的答案的加和,因此根据我们的加法交换律和结合律就可以导出上面的式子.</p>
<p>我们还知道期望的乘法在相互独立的条件下是可以直接乘的,也就是若$X _1 $和$X _2 $相互独立,$E ( X _1 X _2 ) = E ( X _1 ) E ( X _2 ) $,同样是拆期望那个式子,使用乘法分配律得到.</p>
<p>而方差在相互独立的条件下同样是线性可加的,也就是只要$X _1 $和$X _2 $相互独立,$D ( X _1 + X _2 ) = D ( X _1 ) + D ( X _2 ) $.从形式上证明是好证明的,我们考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
D ( X _1 + X _2 ) & = E ( ( X _1 + X _2 ) ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + E ( 2 X _1 X _2 ) + E ( X _2 ^2 ) - E ^2 ( X _1 + X _2 ) \\
& = E ( X _1 ^2 ) + 2 E ( X _1 ) E ( X _2 ) + E ( X _2 ^2 ) - ( E ( X _1 ) + E ( X _2 ) ) ^2 \\
& = E ( X _1 ^2 ) - E ^2 ( X _1 ) + E ( X _2 ^2 ) - E ^2 ( X _2 ) \\
& = D ( X _1 ) + D ( X _2 ) 
\end{aligned}</script><p>或者你也可以卷积然后求导啊!</p>
<p>如何从感性上理解这一点呢?很遗憾,笔者暂时没有想出从感性上理解的方式.从感觉上来讲,笔者比较相信这和独立变量以及正交性有关,查询相关资料得到了协方差的概念,也就是当两个变量独立的时候协方差为$0 $,不然$D ( X _1 + X _2 ) $要再加上两倍的协方差.笔者的能力也就到此了.</p>
<p>对于数据统计部分,我们会发现它在做的其实都是一个套路:将数据放在均值的两侧,也就是减去均值,这样新的值的均值为$0 $,并且缩放权值,使得方差恰好为$1 $.这个做法在正态分布那里就已经展示了它的强大.这是下面概统的极重要的思想,似乎被称作”标准化”.如果我们痴迷于这个思想,就会发现概统的一切复杂的公式的目的只有两个:让误差均值为$0 $的前提下,使得方差最小.</p>
<h3><span id="分布列">分布列</span></h3><h4><span id="两点分布">两点分布</span></h4><p>直接写的话也就是$P ( X ) = \begin{cases}p &amp; X = 1 \ 1 - p &amp; X = 0 \ 0 &amp; other \end{cases} $,事实上这么写可能不太严谨,因为两点分布的$X = 1 $和$X = 0 $两个事件互为对立,但笔者仍然选择这种形式来写,因为看着舒服.</p>
<p>考虑概率生成函数,自然是$G ( x ) = ( 1 - p ) + px $.由此式子轻松推得$E ( x ) = G ‘ ( 1 ) = p , D ( x ) = E ( x ^2 ) - E ^2 ( x ) = G ‘ ‘ ( 1 ) + G ‘ ( 1 ) - ( G ‘ ( 1 ) ) ^2 = p - p ^2 = p ( 1 - p ) $.</p>
<p>这里非要炫技用一下概率生成函数是因为笔者快忘了这玩意怎么用了,这个东西在下面几乎不会再用到了.</p>
<h4><span id="二项式分布">二项式分布</span></h4><p>所谓$n $重伯努利试验,也就是$n $次两点分布的累计,满足$P ( X = k ) = C _{ n  } ^k ( 1 - p ) ^{ n - k  } p ^k $,我们关注两个事情,也就是二项式分布的$E ( X ) = np , D ( X ) = np ( 1 - p ) $,也就是将两点分布的均值与方差给拆开单独累加了.</p>
<h4><span id="超几何分布">超几何分布</span></h4><p>所谓不放回取球,考虑目前有$N $个数字,有$M $个是$1 $,剩下$N - M $个是$0 $,取出$n $次,取出了$m $个$1 $的概率.简单组合一下得到此概率为$\frac { C _{ M  } ^m C _{ N - M  } ^{ n - m  }  } { C _{ N  } ^n  } \ $,注意这里必须保证$n \leq N $.</p>
<p>由范德蒙德卷积得知,$\sum _{ m  } C _{ M  } ^m C _{ N - M  } ^{ n - m  } = C _{ N  } ^n $,因此该分布列所有情况之和为$1 $.</p>
<p>考虑其均值,从感性上讲必定是$\frac { nM  } { N  } $.</p>
<p>从理性上讲,首先可以吸收恒等式+范德蒙德卷积,其次可以概率生成函数.</p>
<p>结合来讲,考虑每一个事件:它必然形如$01101 $之类的,表示每一次取出时拿到的球.不难发现对于事件的全集,我们交换前两个球,仍然唯一对应到了事件的全集.也就是说取出的顺序并不重要,第一次取得到$1 $的概率,和第二次取得到$1 $的概率完全相等,这必然意味着两次的期望相等.</p>
<p>方差是$n \frac { N ( N - M ) ( N - n )  } { N ^2 ( N - 1 )  } $,不太想管这个东西了.</p>
<h4><span id="正态分布">正态分布</span></h4><p>前面的分布大都是离散的,而正态分布是连续函数,因此我们写$f ( x ) = \frac { e ^{ - \frac { ( x - \mu ) ^2  } { 2 \sigma ^2  }  }  } { \sigma \sqrt { 2 \pi  }  } \ $,是不是看着非常震撼!其中的方差是$\sigma ^2 $,期望是$\mu $.本着闲着没事干的原则,我们来彻底冷静一下剖析整个正态分布函数:</p>
<p>众所周知,标准正态分布满足$\sigma = 1 , \mu = 0 $,此时的函数也就是$f ( x ) = \frac { e ^{ - \frac { x ^2  } { 2  }  }  } { \sqrt { 2 \pi  }  } $.一个好奇是,你凭啥说所有情况下的概率之和为$1 $,事实上这其实是因为$g ( x ) = e ^{ - x ^2  } $的积分是$\sqrt { \pi  } $,不会求这个积分.</p>
<p>观察$g ( x ) = e ^{ - x ^2  } $这个函数,你会发现它其实是想要模拟一个钟形曲线,也就是中间部分要更高,两边要更低.如果只是这样,我们完全可以用函数$e ^{ - | x |  } $模拟,但这样的曲线并不圆滑,中间有个小突起,这是因为绝对值本身的分段函数性质,因此直接把上面那个东西换成平方得到一个更圆滑的曲线,如果想要这个曲线横向放缩,则对横坐标使用变换,这就是$\sigma $的由来,将$x \rightarrow \sigma x $,也就是在$x $那里除去一个$\sigma $.而对这个曲线进行横向移动,也就是将$x \rightarrow x - \mu $.</p>
<p>这也就引出所谓的$3 \sigma $原则了,同样是积分.</p>
<h3><span id="成对数据的统计">成对数据的统计</span></h3><h4><span id="样本相关系数">样本相关系数</span></h4><p>对于若干数据$( x _i , y _i ) $,我们先进行标准化,也就是减去均值后再除以方差,这样做使得$x , y $分别的均值为$0 $,方差为$1 $.下面默认已经标准化过了.</p>
<p>不妨构造$n $维向量$\vec { x  } = ( x _1 , x _2 , \cdots , x _n ) , \vec { y  } = ( y _1 , y _2 , \cdots , y _n ) $,考虑它们的点乘$\vec { x  } \cdot \vec { y  } $,不难发现由于方差为$1 $,因此$| \vec { x  } | = | \vec { y  } | = \sqrt { n  } $,因此它们的点乘为$n \cos \theta $,设$r = \frac { \vec { x  } \cdot \vec { y  }  } { n  } = \cos \theta $.</p>
<p>如果$\exists k $,$\forall i , y _i = kx _i $,此时必有$| r | = 1 $,因此我们断言(为啥呢?其实是不太理解的啊)当$| r | $越靠近$1 $的时候,$x , y $之间的线性关系越强.</p>
<h4><span id="最小二乘法">最小二乘法</span></h4><p>我们在上面的角度审视中提出了一个观点:在满足均值为$0 $的前提下,使得方差最小.由此我们审视所谓的一元线性回归方程:$Y = bx + a + e , E ( e ) = 0 , D ( e ) = \sigma ^2 $.</p>
<p>现在我们要做的就是,已知若干组数据$( x _i , y _i ) $,去构造一组$a , b $满足上面的条件.不妨令$e _i = y _i - ( bx _i + a ) $,若$\sum e _i = 0 $,必有$a = \bar { y  } - b \bar { x  } $,带入解得当$\sigma $最小的时候,$b = \frac { \sum _{ i  } ( x _i - \bar { x  } ) ( y _i - \bar { y  } )  } { \sum _{ i  } ( x _i - \bar { x  } ) ^2  } \ $.</p>
<p>提出质疑:为啥这里不需要对数据进行标准化呢?</p>
<p>因为标准化没有用,我们的目的是找到那个$b $使得$\sigma $最小,标准化说到底只是为了保证$\sigma = 1 $的工具,没有必要在这里标准化.</p>
<h4><span id="独立性检验">独立性检验</span></h4><p>使用卡方分布,懒得去学细节了.</p>
<p>独立性检验其实是依赖于这么一件事实:那就是如果两个事件独立,我们得知$P ( AB ) = P ( A ) P ( B ) $,那么我们反推,如果我们在现实中的估计中,发现$P ( AB ) $和$P ( A ) P ( B ) $差的太大,那么我们就认定其没有独立性.</p>
<p>接下来不妨设在测试过程中估算出:$P ( 00 ) = \frac { a  } { n  } , P ( 01 ) = \frac { b  } { n  } , P ( 10 ) = \frac { c  } { n  } , P ( 11 ) = \frac { d  } { n  } $.那么$P ( A = 0 ) P ( B = 0 ) = \frac { ( a + b ) ( a + c )  } { n ^2  } $.我们计算它与$P ( 00 ) $的差,平方后除以$P ( A = 0 ) P ( B = 0 ) $然后做四遍求和化简,得到$\chi ^2 = \frac { n ( ad - bc ) ^2  } { ( a + b ) ( a + c ) ( c + d ) ( b + d )  } $.</p>
<p>这有什么用呢?通过牛逼数学家的计算,我们可以认为如果独立性成立,那么$P ( \chi ^2 \geq x _\alpha ) = \alpha $.或者给出我们经验上的准则:</p>
<p>选取一个较小的$\alpha $,并得知其对应的$x _\alpha $,如果$\chi ^2 \geq x _\alpha $,推断独立性不成立,犯错的概率是$\alpha $.反之断言其独立性成立,犯错的概率不可知,肯定$\alpha $越大犯错的概率越小.</p>
<h2><span id="函数导论">函数导论</span></h2><h3><span id="常用对数表">常用对数表</span></h3><ol>
<li><p>$\ln 2 = 0 . 693 $.</p>
</li>
<li><p>$\ln 3 = 1 . 099 $.</p>
</li>
<li><p>$\ln 5 = 1 . 609 $.</p>
</li>
<li><p>$\ln 0 . 1 = - 2 . 303 $.</p>
</li>
<li><p>$\ln 0 . 5 = - 0 . 693 $.</p>
</li>
</ol>
<h3><span id="常用指数表">常用指数表</span></h3><ol>
<li><p>$e = 2 . 718 $.</p>
</li>
<li><p>$e ^2 = 7 . 389 $.</p>
</li>
<li><p>$e ^3 = 20 . 086 $.</p>
</li>
<li><p>$e ^5 = 148 . 413 $.</p>
</li>
<li><p>$e ^{ 0 . 1  } = 1 . 105 $.</p>
</li>
<li><p>$e ^{ 0 . 5  } = 1 . 649 $.</p>
</li>
<li><p>$e ^\pi = 23 . 147 $.</p>
</li>
</ol>
<h3><span id="基本函数的图像及性质">基本函数的图像及性质</span></h3><h4><span id="fxxex">$f(x)=xe^x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xe^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = ( x + 1 ) e ^x $,$x = - 1 $的时候,取最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxxln-x">$f(x)=x\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xlnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 + \ln x , x = \frac { 1  } { e  } $的时候,有最小值$- \frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow 0 ^{ +  }  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracexx">$f(x)=\frac{e^x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\e^xdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { e ^x ( x - 1 )  } { x ^2  } , x = 1 $的时候,有极小值$e $.</p>
<p>另外$\lim _{ x \rightarrow - \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxfracln-xx">$f(x)=\frac{\ln x}{x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\lnxdivx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - \ln x  } { x ^2  } , x = e $的时候,有极大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<hr>
<h4><span id="fxx-ln-x">$f(x)=x-\ln x$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xminuslnx.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = 1 - \frac { 1  } { x  } , x = 1 $的时候,有最小值$1 $.</p>
<hr>
<h4><span id="fxfracxex">$f(x)=\frac{x}{e^x}$</span></h4><h5><span id="图像">图像</span></h5><p><img src="F:\Studying Materials\学习资料（ymh）\OI资料\笔记\基本函数的图像\xdive^x.png" alt></p>
<h5><span id="极值与极限">极值与极限</span></h5><p>$f ‘ ( x ) = \frac { 1 - x  } { e ^x  } , x = 1 $的时候,有最大值$\frac { 1  } { e  } $.</p>
<p>另外$\lim _{ x \rightarrow + \infty  } f ( x ) = 0 \ $.</p>
<h3><span id="预处理函数">预处理函数</span></h3><h4><span id="分离对数">分离对数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = ( 2 + x + ax ^2 ) \ln ( x + 1 ) - 2 x $,已知$x = 0 $是极大值点,求$a $.</p>
<p>考虑分离对数后操作多项式,我们显然可找到$0 &lt; t &lt; 1 , 2 + t + at ^2 &gt; 0 , 2 - t + at ^2 &gt; 0 $,下面只考虑$x \in [ - t , t ] $.此时$f ( x ) = ( 2 + x + ax ^2 ) ( \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } ) $.</p>
<p>考虑令$g ( x ) = \ln ( x + 1 ) - \frac { 2 x  } { 2 + x + ax ^2  } $,由于$f ( 0 ) = 0 $,只需证明$g ( x ) \leq 0 , x \in [ - t , t ] $即可.</p>
<p>而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ' ( x ) & = \frac { 1  } { x + 1  } - \frac { 4 - 2 ax ^2  } { ( 2 + x + ax ^2 ) ^2  } \\
& = \frac { x ^2 ( a ^2 x ^2 + 4 ax + 6 a + 1 )  } { ( x + 1 ) ( 2 + x + ax ^2 )  } \\
\text { sign  } ( g ' ( x ) ) & = \text { sign  } ( a ^2 x ^2 + 4 ax + 6 a + 1 ) 
\end{aligned}</script><p>则$a ^2 0 ^2 + 4 a 0 + 6 a + 1 = 0 $,$a = - \frac { 1  } { 6  } $.验证一下.</p>
<h4><span id="消去指数">消去指数</span></h4><h5><span id="example">Example</span></h5><p>令$f ( x ) = e ^x - \ln ( x + 1 ) + ax ^3 - x ^2 - 1 $,若$\forall x \in ( - 1 , 1 ) , f ( x ) \geq 0 $,求$a $.</p>
<p>$f ( 0 ) = 0 $,于是上面的条件等价于$0 $是$( - 1 , 1 ) $的最小值点.</p>
<p>考虑$f ‘ ( x ) = e ^x - \frac { 1  } { x + 1  } + 3 ax ^2 - 2 x $,则$f ‘ ( 0 ) = 0 $恒成立.</p>
<p>讨论$g ( x ) = 1 + e ^{ - x  } ( 3 ax ^2 - 2 x - \frac { 1  } { x + 1  } ) $的正负,看$g ‘ ( x ) = \frac { x ( - 3 ax ^3 + 2 x ^2 + ( 9 a + 2 ) x + 6 a - 1 )  } { ( x + 1 ) ^2 e ^x  } $.</p>
<p>接下来的讨论是简单的.</p>
<h3><span id="消元法">消元法</span></h3><h4><span id="变化条件">变化条件</span></h4><h5><span id="example">Example</span></h5><p>已知$x + 2 y = 1 $,求$x ^2 + y ^2 $的最小值.</p>
<p>直接令$x = 1 - 2 y $,带入即可.</p>
<h4><span id="变化所求">变化所求</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^3 = 2 $,求$x + y $的最小值.</p>
<p>这个的话不妨设其最小值为$C $,有$x + y \geq C $,移项得到$y \geq C - x $,两边三次方然后带入.</p>
<h3><span id="换元法">换元法</span></h3><h4><span id="普通参数方程">普通参数方程</span></h4><h5><span id="example">Example</span></h5><p>已知$x ^2 + y ^2 - xy = 1 $,求$x + y $的最小值.</p>
<p>这个的话大概是这样,我们找到一个$t $,使得$x = f ( t ) , y = g ( t ) $,然后换元.</p>
<p>比如这个题,你就可以凑成$( x - \frac { y  } { 2  } ) ^2 + ( \frac { \sqrt { 3  }  } { 2  } y ) ^2 = 1 $,然后做三角换元.</p>
<h4><span id="齐次化构造">齐次化构造</span></h4><h5><span id="example1对数平均不等式">Example1(对数平均不等式)</span></h5><p>求证$\sqrt { ab  } &lt; \frac { a - b  } { \ln a - \ln b  } &lt; \frac { a + b  } { 2  } $.</p>
<p>两边证明方式类似,这里只证明右半边,下面的证明的每一步均为充要的,因而可以倒退.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { a - b  } { \ln a - \ln b  } & < \frac { a + b  } { 2  } \\
\frac { a - b  } { a + b  } & < \frac { \ln \frac { a  } { b  }  } { 2  } \\
\frac { \frac { a  } { b  } - 1  } { \frac { a  } { b  } + 1  } & < \frac { \ln \frac { a  } { b  }  } { 2  } 
\end{aligned}</script><p>换元,令$t = \frac { a  } { b  } $,然后下面大力求导.</p>
<h5><span id="example2">Example2</span></h5><p>已知函数$f ( x ) = 3 \ln x - ax $,若$x _1 &lt; x _2 $是$f ( x ) $的两个零点,求证$f ‘ ( \frac { x _1 + 3 x _2  } { 4  } ) &lt; 0 $.</p>
<p>我们来分析已知,我们目前知道的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
3 \ln x _1 = ax _1 \\
3 \ln x _2 = ax _2 
\end{cases}</script><p>我们想要知道的是:$\frac { 12  } { x _1 + 3 x _2  } &lt; a $.</p>
<p>这就是整个题全部的部分,和前面的函数其实一点关系都没太有.那么这个东西怎么搞呢?我们先把$a $给换掉,事实上我们根据前面的方程有$a = \frac { 3 \ln \frac { x _2  } { x _1  }  } { x _2 - x _1  } $.</p>
<p>于是我们只需要证明:$\frac { x _1 + 3 x _2  } { 4  } &gt; \frac { x _2 - x _1  } { \ln \frac { x _2  } { x _1  }  } $,这是一个很显然的齐次化形式.</p>
<h5><span id="example3">Example3</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>同样分析已知,我们得到的是:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _1 = ax _1 \\
\ln x _2 = ax _2 
\end{cases}</script><p>通过简单线代知识我们知道,如果我们想把这两个条件同时用上,我们最好先相加再相减,这样这一步推下来就是充要的:</p>
<script type="math/tex; mode=display">
\begin{cases}
\ln x _2 - \ln x _1 = a ( x _2 - x _1 ) \\
\ln x _2 + \ln x _1 = a ( x _2 + x _1 ) 
\end{cases}</script><p>这里先把所求变形一下,我们把它改成$\ln x _1 + \ln x _2 &gt; 2 $.</p>
<p>发现了什么?这个东西等价于$a ( x _2 + x _1 ) &gt; 2 $,至此,我们用上了第二个式子,并且将其蕴含到了答案中.</p>
<p>接下来用第一个式子代换$a $即可.</p>
<h5><span id="example4">Example4</span></h5><p>已知$f ( x ) = x ^2 + axe ^x - ae ^{ 2 x  } $有三个不同的零点$x _1 &lt; x _2 &lt; x _3 $,求$a $的范围,并求证$( 1 - \frac { x _1  } { e ^{ x _1  }  } ) ^2 ( 1 - \frac { x _2  } { e ^{ x _2  }  } ) ( 1 - \frac { x _3  } { e ^{ x _3  }  } ) = 1 $.</p>
<p>考虑两边同时除以$e ^{ 2 x  } $,这样得到$g ( x ) = ( \frac { x  } { e ^x  } ) ^2 + a \frac { x  } { e ^x  } - a $,令$t = \frac { x  } { e ^x  } $得到$g ( t ) = t ^2 + at - a = 0 $.</p>
<p>考察$g ( t ) = 0 $的两根$t _1 &lt; t _2 $,根据韦达定理,首先需要满足$\Delta = a ^2 + 4 a &gt; 0 \Rightarrow a &gt; 0 $,然后$t _1 + t _2 = - a , t _1 t _2 = - a $.</p>
<p>接下来考察函数$\frac { x  } { e ^x  } $,这个函数图像我们很熟悉,如果想要最后有三个零点,又因为$t _1 , t _2 $中必有一负,因此$t _2 \in ( 0 , \frac { 1  } { e  } ) $.由此立得$0 &lt; a &lt; \frac { 1  } { e ( e - 1 )  } $.</p>
<p>接下来考虑后面那个东西,其实就是简单韦达定理,随便做做.</p>
<h4><span id="同构化构造">同构化构造</span></h4><h5><span id="example1">Example1</span></h5><p>若$x &gt; 0 $时,$ax ( e ^{ ax  } + 1 ) \geq 2 ( x ^2 + 1 ) \ln x $恒成立,求$a $取值范围.</p>
<p>一般这种题先判$a $的正负,注意到$x &gt; 1 $的时候右边恒大于$0 $,因此$a &gt; 0 $.</p>
<p>观察这个式子,发现形式似乎很相似,更进一步地,我们把常数$2 $放进$\ln $,自然有:$ax ( e ^{ ax  } + 1 ) \geq ( x ^2 + 1 ) \ln x ^2 $.</p>
<p>考虑令$t _1 = ax , t _2 = \ln x ^2 $,则:</p>
<script type="math/tex; mode=display">
t _1 ( e ^{ t _1  } + 1 ) \geq t _2 ( e ^{ t _2  } + 1 )</script><p>接下来分析函数$f ( x ) = x ( e ^x + 1 ) $的单调性,就可以得到$a \geq \frac { 2  } { e  } $.</p>
<h3><span id="不等式相关">不等式相关</span></h3><h4><span id="基本不等式相关">基本不等式相关</span></h4><h5><span id="方程角度的审视">方程角度的审视</span></h5><p>我们曾经下过这么一个论断:即对于有一个方程限制的双变量,求另一个式子的最值,我们是可以有一套机械化方法探路的.具体而言,这个方法基于大部分情况下,我们只需要两个二元方程就可以得到确定的(唯一或者唯二或者常数个)原本的两个变量的值.</p>
<p>于是我们设一个常数来表示其中一个方程,另一个方程自然是题目给出的限制条件,我们只需要把所求转化为对于这个常数的限制就好了.</p>
<p>如果我们再去仔细揣摩这个过程,我们会发现一些更有趣的事情:即只要我们能做到”降次”这件事,我们似乎一定存在方程的解.这可能类似于所谓的齐次化构造$\frac { m  } { n  } = k $.</p>
<p>那这意味着什么呢?在绝大多数情况下我们拿到的方程都是非齐次的方程,这给了我们机会去降次.</p>
<p>我们给出一个例题:</p>
<h5><span id="example">Example</span></h5><p>已知$n , m &gt; 0 , 2 m + n = nm $,求$n + m + \sqrt { n ^2 + m ^2  } $的最小值.</p>
<p>这个题有一个方式是观察到$n , m , \sqrt { n ^2 + m ^2  } $是直角三角形的三条边然后使用三角换元.但我们接下来会给出一个更加厉害的做法:</p>
<p>我们想要知道它的最小值,就是想要证明下面这个不等式并且证明等号成立:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n + m + \sqrt { n ^2 + m ^2  } & \geq k \\
\Leftarrow \sqrt { n ^2 + m ^2  } & \geq k - n - m \\

\end{aligned}</script><p>如果$n + m \geq k $,那么不等式显然成立,下面只需要证明$n + m &lt; k $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt { n ^2 + m ^2  } & \geq k - n - m \\
\Leftarrow n ^2 + m ^2 & \geq ( k - ( n + m ) ) ^2 \\
\Leftarrow k ^2 + ( n + m ) ^2 - 2 k ( n + m ) & \leq n ^2 + m ^2 \\
\Leftarrow k ^2 + 2 nm - 2 k ( n + m ) & \leq 0 \\
\Leftarrow k ^2 + n ( 2 - 2 k ) + m ( 4 - 2 k ) & \leq 0 \\
\Leftarrow k ^2 & \leq n ( 2 k - 2 ) + m ( 2 k - 4 ) 
\end{aligned}</script><p>变形方程得到$\frac { 2  } { n  } + \frac { 1  } { m  } = 1 $,使用这个式子来降次:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ( 2 k - 2 ) + m ( 2 k - 4 ) & = 6 k - 8 + \frac { n  } { m  } ( 2 k - 2 ) + \frac { m  } { n  } ( 4 k - 8 ) \\

\end{aligned}</script><p>要严谨一点的话我们需要证明$4 k - 8 \geq 0 $,$k \geq 2 $.这非常简单,因为$k \geq n + m &gt; 3 $.</p>
<p>这就足够了么?不需要证明存在一个$w = \frac { n  } { m  } $使得带入到原方程中有解么?这个其实是显然易证的.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
n ( 2 k - 2 ) + m ( 2 k - 4 ) \geq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>这个等号可以取到,也就是说,只要满足:</p>
<script type="math/tex; mode=display">
k ^2 \leq 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下界,特别地,如果满足:</p>
<script type="math/tex; mode=display">
k ^2 = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  }</script><p>那么这个$k $就是一个下确界,也就是我们想要求的最小值.</p>
<p>事情还没有解决(即使这个时候你已经能猜到$k = 10 $是一个解了),接下来我们必须求出一个$k $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 & = 6 k - 8 + 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
k ^2 - 6 k + 8 & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 ) ( k - 2 )  } \\
\sqrt { k - 2  } & = \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } 
\end{aligned}</script><p>我们看上去走投无路了对么?其实不然,你发现这个式子两边的次是不等的,我们可以使用它降次!换言之,把这个$\sqrt { k - 2  } $带入到上面去!</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k - 4 ) ( k - 2 ) & = 2 \sqrt { 8 ( k - 1 )  } \frac { 2 \sqrt { 8 ( k - 1 )  }  } { k - 4  } \\
( k - 4 ) ( k - 2 ) & = \frac { 32 ( k - 1 )  } { k - 4  } \\

\end{aligned}</script><p>我想你这个时候又会发现我们走投无路了,但稍微思考一下就会发现,这个方程一定没有常数项(或者说$k = 0 $是这个方程的一个解).</p>
<p>这样得到了一个二次方程,我们自然可以解出$k = 10 $.</p>
<h4><span id="泰勒展开">泰勒展开</span></h4><h5><span id="抽象函数的泰勒展开">抽象函数的泰勒展开</span></h5><script type="math/tex; mode=display">
\begin{aligned}
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( x _0 )  } { k !  } ( x - x _0 ) ^k \\
f ( x ) & = \sum _{ k \geq 0  } \frac { f ^{ ( k )  } ( 0 )  } { k !  } x ^k \\

\end{aligned}</script><h5><span id="常用泰勒展开公式">常用泰勒展开公式</span></h5><ol>
<li><p>$\frac { 1  } { 1 - x  } = \sum _{ k \geq 0  } x ^k = 1 + x + x ^2 + \cdots \ $.</p>
</li>
<li><p>$e ^x = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } = 1 + x + \frac { 1  } { 2 !  } x ^2 + \cdots \ $.</p>
</li>
<li><p>$\ln ( 1 + x ) = \sum _{ k \geq 1  } ( - 1 ) ^{ k - 1  } \frac { x ^k  } { k  } = x - \frac { 1  } { 2  } x ^2 + \frac { 1  } { 3  } x ^3 + \cdots \ $.</p>
</li>
</ol>
<h4><span id="极值点偏移">极值点偏移</span></h4><h5><span id="example1">Example1</span></h5><p>已知函数$f ( x ) = \ln x - ax $,其有两个零点$x _1 \ne x _2 $,求证$x _1 x _2 &gt; e ^2 $.</p>
<p>极值点偏移的形式,应该是形如$g ( x ) = a $有两个解$x _1 , x _2 $,然后使得$x _1 + x _2 $满足一定条件.因此我们先变形条件:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { \ln x _1  } { x _1  } = a \\
\frac { \ln x _2  } { x _2  } = a 
\end{cases}</script><p>也就是目前我们构造出了函数$g ( x ) = \frac { \ln x  } { x  } $,观察$g ( x ) $图像立得$x _1 + x _2 &gt; 2 e $.</p>
<p>我们发现,$x _1 x _2 \leq \frac { ( x _1 + x _2 ) ^2  } { 4  } $,这个形式看上去非常正确!但是问题在于,我们好像不太能去变形不等式了,怎么办呢?</p>
<p>考虑对着我们要证明的东西去搞,极值点偏移可以解决相加性问题,因此我们变形所求为$\ln x _1 + \ln x _2 &lt; 2 $,然后令$t _1 = \ln x _1 , t _2 = \ln x _2 $,带入立有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { t _1  } { e ^{ t _1  }  } = a \\
\frac { t _2  } { e ^{ t _2  }  } = a 
\end{cases}</script><p>而$g ( x ) = \frac { x  } { e ^x  } $恰好也是满足$x _1 + x _2 &gt; 2 $的这么一个函数!于是我们就解决了问题.</p>
<h5><span id="example2">Example2</span></h5><p>$f ( x ) = x ( 1 - \ln x ) $,$b \ln a - a \ln b = a - b $,求证$2 &lt; \frac { 1  } { a  } + \frac { 1  } { b  } &lt; e $.</p>
<p>首先变形条件得到$b ( 1 + \ln a ) = a ( 1 + \ln b ) $,得到$f ( \frac { 1  } { a  } ) = f ( \frac { 1  } { b  } ) $,左半部分就是经典极值点偏移.</p>
<p>那么右半部分怎么做呢?我们来考虑:</p>
<p>$f ‘ ( x ) = - \ln x $,其在$( 0 , 1 ) \uparrow , ( 1 , + \infty ) \downarrow $,考察极值点偏移,我们想要证明$\frac { 1  } { b  } &lt; e - \frac { 1  } { a  } $,我们就想办法把$\frac { 1  } { b  } $和$e - \frac { 1  } { a  } $扔到同一个区间里,而它们确实同在$( 1 , + \infty ) $这个区间内.</p>
<p>比较有启发性的是,你发现$\frac { 1  } { b  } , e - \frac { 1  } { a  } $和$\frac { 1  } { a  } , e - \frac { 1  } { b  } $这两对必有一对在同一个区间内部.</p>
<p>现在我们就可以套路化了:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 1  } { b  } & < e - \frac { 1  } { a  } \\
f ( \frac { 1  } { a  } ) & = f ( \frac { 1  } { b  } ) & > f ( e - \frac { 1  } { a  } ) 
\end{aligned}</script><p>对着上面那个函数证明即可.</p>
<h5><span id="example3">Example3</span></h5><p>$f ( x ) = e ^{ x - 1  } - ax $在$( 0 , 2 ) $有两个零点$x _1 , x _2 $,求证$x _1 x _2 &gt; \frac { 1  } { a  } $.</p>
<p>首先要证明$a $的范围啊,我们不加证明地给出:$a \in ( 1 , \frac { e  } { 2  } ) $,并且$( - \infty , 1 + \ln a ) \downarrow , ( 1 + \ln a , + \infty ) \uparrow $.</p>
<p>这个其实差不多啊,简单来说就是首先列方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
ax _1 = e ^{ x _1 - 1  } \\
ax _2 = e ^{ x _2 - 1  } 
\end{cases}</script><p>我们知道,一般双变量的问题加法会比较好做(原理是加法便于看单调区间),因此现在我们有两条路可走:要么变化所求,两边取$\ln $,要么变化已知.</p>
<p>我们发现如果变化所求,我们还得对已知两边取$\ln $,这也太麻烦了,不如直接变化已知.具体地,我们把已知的式子相乘就可以得到$x _1 x _2 $和$x _1 + x _2 $之间的关系,带下来就可以了.然后观察单调区间做极值点偏移.最后的式子应该形如$0 &lt; f ( 2 + \ln a - x _2 ) $,也就是$0 &lt; ae ^{ 1 - x _2  } - a ( 2 + \ln a - x _2 ) $.</p>
<p>但是这样有一个问题,我们把$f $带进去,你会发现最后我们的式子同时带有$a , x _2 $,这个就难做了,咋办呢?考虑拿$ax _2 = e ^{ x _2 - 1  } $操作一下把$a $消掉就好了.</p>
<h4><span id="切割线放缩">切割线放缩</span></h4><h5><span id="基本的切割线不等式">基本的切割线不等式</span></h5><ol>
<li><p>$e ^x \geq x + 1 $.</p>
</li>
<li><p>$\frac { x - 1  } { x  } \leq \ln x \leq x - 1 $.</p>
</li>
</ol>
<p>乍一看非常平凡,事实上有一些不平凡的推论:</p>
<ol>
<li>$\ln ( n + 1 ) &lt; \sum _{ k = 1  } ^n \frac { 1  } { k  } $.</li>
</ol>
<p>考虑$\ln ( \frac { n + 1  } { n  } ) &lt; \frac { 1  } { n  } $,左右两边分别求和得到上面的式子.</p>
<ol>
<li>$\ln n &gt; \sum _{ k = 2  } ^n \frac { 1  } { k  } , n &gt; 1 $.</li>
</ol>
<p>这个怎么证明呢?考虑左右取负,也就是需要证明$\ln \frac { 1  } { n  } &lt; - \sum _{ k = 2  } ^n \frac { 1  } { k  } $.</p>
<p>考虑$\ln ( \frac { n - 1  } { n  } ) \leq - \frac { 1  } { n  } $,两边求和得到上式.</p>
<ol>
<li>$\sum _{ k = 1  } ^n ( \frac { k  } { n  } ) ^n &lt; \frac { e  } { e - 1  } $.</li>
</ol>
<p>考虑$n \ln ( \frac { k  } { n  } ) \leq k - n $,也就有$( \frac { k  } { n  } ) ^n \leq e ^{ k - n  } $,两边求和得到上式.</p>
<h5><span id="一般的切割线放缩">一般的切割线放缩</span></h5><h6><span id="example1">Example1</span></h6><p>设$f ( x ) = x \ln x $,若$f ( x ) = b $有两个实数根$x _1 , x _2 ( x _1 &lt; x _2 ) $,求证:$be + 1 &lt; x _2 - x _1 &lt; \frac { e ^{ - 3  } + 2 + 3 b  } { 2  } $.</p>
<p>注意到$f ( x ) $下凸,考虑求出两条切线,那么这两条切线与$y = b $的交点之差要大于等于$x _2 - x _1 $,两条割线交点之差要小于等于$x _2 - x _1 $.</p>
<p>先求好求的割线,一般而言,我们考虑边界情况,也就是$b \rightarrow - \frac { 1  } { e  } $的情况,为了让这种情况有解,我们的割线必过$( \frac { 1  } { e  } , - \frac { 1  } { e  } ) $.</p>
<p>考虑直接选取$( 0 , 0 ) $和$( 1 , 0 ) $作为另外两个点,这两条割线就是$x = - y $和$x = ( e - 1 ) y + 1 $.做差立得上面的式子.</p>
<p>那么后半边怎么证明呢?我们考虑一个想法是:这题既然出出来了,它必然不可能是虚的.因此我们要找的切点不可能过于离谱.</p>
<p>另外一个事实是,我们考虑如果我们找到了一条切线,那么由于不等式的右边是定值,我们肯定想要让令一条切线稍微平均一下,使得$( x _2 - x _1 ) _{ \max  } $尽可能地小对吧!</p>
<p>我们不妨设我们要找的两个切点,一个横坐标是$u $,另一个是$v $,其中$v &lt; \frac { 1  } { e  } &lt; u $,那么两条切线分别是:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = \frac { y - f ( u )  } { f ' ( u )  } + u \\
x = \frac { y - f ( v )  } { f ' ( v )  } + v 
\end{cases}</script><p>那么,现在我们要做的就是找到一组$( u , v ) $,使得:</p>
<script type="math/tex; mode=display">
\frac { b - f ( u )  } { f ' ( u )  } + u - \frac { b - f ( v )  } { f ' ( v )  } - v = \frac { e ^{ - 3  } + 2 + 3 b  } { 2  }</script><p>感觉很难搞啊,我们不妨让$u = 1 $,自然有:</p>
<script type="math/tex; mode=display">
\frac { ( f ' ( v ) - 1 ) b + f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  } + 3 b  } { 2  }</script><p>然后我们凑系数,上面的式子,我们大胆猜测:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { f ' ( v ) - 1  } { f ' ( v )  } = \frac { 3  } { 2  } \\
\frac { f ( v ) - vf ' ( v )  } { f ' ( v )  } = \frac { e ^{ - 3  }  } { 2  } 
\end{cases}</script><p>考虑让$f ‘ ( v ) = - 2 $,则$v = e ^{ - 3  } $,带入发现正好适配.</p>
<h4><span id="凹凸性反转">凹凸性反转</span></h4><h5><span id="example1">Example1</span></h5><p>求证:$\forall x \in ( 0 , + \infty ) , \ln x + 1 &gt; \frac { 1  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2 x  } $.</p>
<p>这个式子看上去就很震撼,那么我们该怎么处理呢?</p>
<p>我们知道常数项在导数中是好处理的,而且我们通过强大的注意力,发现右边那个式子如果乘以$x $,他就是一个凸函数了,而左边也是有凹凸性的.</p>
<p>因此我们变形为$x \ln x + x &gt; \frac { x  } { e ^{ x + 1  }  } - \frac { 2  } { e ^2  } $,然后证明左边的最小值$\geq $右边的最大值.</p>
<h4><span id="比较大小">比较大小</span></h4><p>接下来以一个题为例,介绍一下几种估算/严谨的比较大小方式.</p>
<h5><span id="example1">Example1</span></h5><p>已知$a = 0 . 1 e ^{ 0 . 1  } , b = \frac { 1  } { 9  } , c = - \ln 0 . 9 $,求比较$a , b , c $的大小关系.</p>
<h6><span id="二阶导数">二阶导数</span></h6><p>我们上面声明过了二次导数可以判断极值类型,我们用这个方式来计算$a $和$c $的大小关系.</p>
<p>构造函数$f ( x ) = xe ^x + \ln ( 1 - x ) $,则$f ( 0 . 1 ) &gt; 0 \Rightarrow a &gt; c $.</p>
<p>考察$f ( 0 ) = 0 $,$f ‘ ( 0 ) = 0 $,$f ‘ ‘ ( 0 ) = 4 &gt; 0 $,则$f ( 0 ) = 0 $是一个极小值点,并在接下来有着增大的趋势.因此我们可以估算$f ( 0 . 1 ) &gt; 0 $.</p>
<h6><span id="估算定积分">估算定积分</span></h6><p>考察$a $和$b $的大小关系,不妨设$f ( x ) = ( 1 - x ) e ^{ 1 - x  } - \frac { 1  } { 10 x  } $,则$f ( 0 . 9 ) &lt; 0 \Rightarrow b &gt; a $.</p>
<p>注意到$f ( 1 ) = - \frac { 1  } { 10  } $,$f ‘ ( 1 ) = - \frac { 9  } { 10  } $,考虑估算一下积分,那么$f ( 0 . 9 ) \approx f ( 1 ) - f ‘ ( 1 ) 0 . 1 = - \frac { 1  } { 100  } &lt; 0 $.</p>
<p>你可能会觉得这个$- \frac { 1  } { 100  } $,是不是不太能那么肯定地估算啊.但是实际上,我们考察$f ‘ ( x ) = ( x - 2 ) e ^{ 1 - x  } + \frac { 1  } { 10 x ^2  } $,这个东西在$[ 0 . 9 , 1 ] $上直觉上平均值是大于$- \frac { 9  } { 10  } $的,这样就有道理多了(真的么).</p>
<h6><span id="泰勒展开">泰勒展开</span></h6><p>上面提过了,这里略过.</p>
<h6><span id="正经做法">正经做法</span></h6><p>接下来开抄标答.</p>
<p>令$f _a ( x ) = xe ^x , f _b ( x ) = \frac { x  } { 1 - x  } , f _c ( x ) = - \ln ( 1 - x ) $.</p>
<p>这样当$x = 0 . 1 $的时候所有的数字都被正确表示了.</p>
<p>比较$a , b $:</p>
<p>考虑它们都有乘除项,考虑使用对数把乘除改为加减,立有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = \ln ( a ) - \ln ( b ) & = x + \ln ( 1 - x ) \\
y ' & = 1 - \frac { 1  } { 1 - x  } & = \frac { - x  } { 1 - x  } 
\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单减,这样立有$a &lt; b $.</p>
<p>比较$a , c $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
y & = a - c & = xe ^x + \ln ( 1 - x ) \\
y ' & = ( x + 1 ) e ^x - \frac { 1  } { 1 - x  } & = \frac { ( 1 + x ) ( 1 - x ) e ^x - 1  } { 1 - x  } \\

\end{aligned}</script><p>注意到$x = 0 $的时候$y = 0 $,又注意到其在$( 0 , 0 . 1 ) $上单增,这样立有$a &gt; c $.</p>
<p>经验教训:在构造函数的时候,你一定要找一些简单一点的函数来构造,<strong>最好不要带有系数</strong>.</p>
<h2><span id="数列导论">数列导论</span></h2><h3><span id="递归式的求解">递归式的求解</span></h3><h4><span id="特征根法">特征根法</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>在上面做$k = 2 $的时候,我们已经发现了这个问题的棘手.甚至动用了求根公式.那有没有什么办法能让这个方法拓展到更高维呢?我们引入线性代数.</p>
<h6><span id="重定义向">重定义向</span></h6><p>由于《线性代数》一书的作者与笔者使用字母习惯略有差异,为了防止出错,下面一律使用原书的使用习惯,可能会与前面的定义不尽相同.</p>
<p>给定$a _0 , . . . , a _n $,其中$a _0 \ne 0 $,对于所有的$k \in \mathbb { N  } $,若有下列式子成立:</p>
<script type="math/tex; mode=display">
a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = z _k</script><p>则称为一个$n $阶线性差分方程(或递归关系).为了简化,通常取$a _0 = 1 $.若$\{ z _k \} $是零序列,则称其是一个齐次线性方程.</p>
<h6><span id="引入矩阵">引入矩阵</span></h6><p>我们注意到,对于齐次差分方程而言,如果不给定$y _0 , \cdots y _{ n - 1  } $,只是构造一组满足条件的$y $的话,自然的想法是令$y _k = r ^k $.其中$r $是辅助方程$a _0 r ^{ n  } + a _1 r ^{ n - 1  } + \cdots + a _n = 0 $的一个根.</p>
<p>注意到如果我们将上面的内容看作是$T : \{ y _k \} \mapsto \{ z _k \} $这样一个映射,这显然是一个线性变换.这意味着齐次方程$a _0 y _{ k + n  } + a _1 y _{ k + n - 1  } + \cdots + a _n y _k = 0 $的解集就是$T $的核,设为$H $,不难发现只要给定$y _0 , \cdots y _{ n - 1  } $,这个解就唯一确定,将它们看作自由变量,这意味着$\dim H = n $.</p>
<p>还没完,注意到我们解方程可以解出$n $个根,如果这$n $个根互不相同,这意味着它们必然线性无关.这样的话我们就可以轻松求得所有的解集,就算给定了$y _0 , \cdots y _{ n - 1  } $,我们也可以用解集的基通过线性组合拟合出来答案.</p>
<p>至于如果这$n $个根有重根的话怎么办,我们发现这可能拟合失败.根据上面的经验,我们发现我们需要找到另外几组线性无关的$\mathbb { R  } ^k $的向量来拟合.</p>
<p>最后,如果对于非齐次线性递推的答案,可能就需要猜根了.总之需要猜出总共$n $个线性无关的根,然后拟合初值.我们如此做:对于一个出现了$m $次的根$r $,我们注意到$r ^k , kr ^k , \cdots , k ^{ m - 1  } r ^k $都是满足条件的解,且他们线性无关.这个结论是怎么得到的呢?</p>
<p>首先,我们注意到如果初始条件成立,我们只要错位相减就可以做数学归纳,也就是说我们需要证明初始条件成立,下面以$kr ^k $作为例子,即证明:</p>
<script type="math/tex; mode=display">
a _0 nr ^n + a _1 ( n - 1 ) r ^{ n - 1  } + \cdots + a _1 r = 0</script><p>是满足条件的.</p>
<p>用一下简单的生成函数技巧,如果有两个$r $作为根,必然意味着原方程形如$( y - r ) ^2 P $,其中$P $是一个关于$y $的多项式.</p>
<p>我们把它写开:$( y ^2 - 2 ry + r ^2 ) P = 0 $,然后我们用$kr ^k $去代替$r ^k $,不难发现代替后右边还是个多项式,而左边变成了$0 $,这意味着这个根一定可行.</p>
<p>对于更高次的问题,只需要用二项式定理解决一下就行.</p>
<p>不过!我们可以用导数解决这个问题:我们对原方程两边求导.</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _0 r ^{ n + k  } + a _1 r ^{ n + k - 1  } + \cdots + a _1 r ^k & = 0 \\
a _0 ( n + k ) r ^{ n + k - 1  } + a _1 ( n + k - 1 ) r ^{ n + k - 2  } + \cdots + a _1 kr ^{ k - 1  } & = 0 \\
a _0 ( n + k ) r ^{ n + k  } + a _1 ( n + k - 1 ) r ^{ n + k - 1  } + \cdots + a _1 kr ^{ k  } & = 0 \\

\end{aligned}</script><p>这样我们就可以数学归纳解决.</p>
<p>另外,我们注意一个问题:$( ( y - r ) ^2 P ) ‘ = ( y - r ) ( ( y - r ) P ) ‘ + ( y - r ) ‘ ( y - r ) P = ( y - r ) [ ( y - r ) ‘ P + ( ( y - r ) P ) ‘ ] $,$r $一定是这个方程的一个根,高次是同理的.</p>
<h6><span id="再进一步">再进一步</span></h6><p>我们注意到齐次差分方程一定能写成$\vec { x  } _k = A \vec { x  } _{ k - 1  } $的形式.如果我们取$A $的特征向量的线性组合作为$\vec { x  } _0 $,不难发现一定是满足条件的.</p>
<p>更进一步,如果我们定义元素和为$1 $的向量为概率向量,由概率向量组成的矩阵为概率矩阵,那么确定了初始向量的齐次差分方程最后一定会收敛到一个值.证明的话直接求通项然后去求极限即可.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="数列中的求和问题">数列中的求和问题</span></h3><h4><span id="和式的基本运算">和式的基本运算</span></h4><p>分配律:$\ \sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i \ $.</p>
<p>结合律:$\ \sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i $.</p>
<p>交换律:$\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  } $,其中$p $是$S $集合的重新排列.</p>
<p>交换求和顺序:</p>
<ol>
<li><p>$\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] $.</p>
</li>
<li><p>$\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } $.</p>
</li>
</ol>
<p>一般分配律:$\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j ) $.</p>
<h4><span id="交换顺序法">交换顺序法</span></h4><h6><span id="example1等差数列求和">Example1(等差数列求和)</span></h6><p>等差数列求和：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h6><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h6><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\

\end{aligned}</script><p>又有$( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) $,显然有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \leq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \leq b _j \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & \geq n \sum _{ i = 1  } ^n a _i b _i , \forall i & < j , a _i & \leq a _j \land b _i & \geq b _j \\

\end{aligned}</script><p>上式被称为切比雪夫单调不等式.</p>
<h6><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h6><p>即$\sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \ $.</p>
<p>令$S _n = \sum _{ 1 \leq j &lt; k \leq n  } ( a _j b _k - a _k b _j ) ^2 \ $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k - a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h6><span id="example1等比数列求和">Example1(等比数列求和)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h6><span id="example2平方和公式">Example2(平方和公式)</span></h6><p>$S _n = \sum _{ i = 0  } ^n i ^2 $.</p>
<p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推，我们设$W _n = \sum _{ i = 0  } i ^3 $</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h4><span id="展开和收缩">展开和收缩</span></h4><h6><span id="example1平方和公式">Example1(平方和公式)</span></h6><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="problme3">Problme3</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="problemex2">ProblemEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<p>$g ( x ) = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f ( x ) + C \ $</p>
<p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<p>\Delta(x^{\underline{m}})=mx^{\underline{m-1}}，\sum mx^{\underline{m-1}}\delta x=x^{\underline{m}}+C，m\ne 0\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $，有:</p>
<p>令H(x)=\sum_{i=1}^x\frac{1}{i}\\\Delta(H(x))=x^{\underline{-1}}，\sum x^{\underline{-1}}\delta x =H(x)+C\\</p>
<p>\\</p>
<p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<p>$\Delta ( 2 ^x ) = 2 ^x ， \sum 2 ^x \delta x = 2 ^x + C \ $</p>
<p>$\Delta ( c ^x ) = ( c - 1 ) c ^x ， \sum c ^x \delta x = \frac { c ^x  } { c - 1  } + C , c \ne 1 \ $</p>
<p>$\Delta ( c ^{ \underline { x  }  } ) = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x = c ^{ \underline { x  }  } + C , c - x \ne 0 \ $.</p>
<p>根据组合数公式,有:</p>
<p>$\Delta ( \binom { x  } { k  } ) = \binom { x  } { k - 1  } \ $.</p>
<h6><span id="example1">Example1</span></h6><p>仍然考虑平方和公式：</p>
<p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p>$\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \ $.</p>
<h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k 2 ^k \\
& = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x \\
& = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 \\

\end{aligned}</script><h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3">Example3</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } \\
& = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="example4">Example4</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script><h3><span id="基础数论在数列中的应用">基础数论在数列中的应用</span></h3><h5><span id="example">Example</span></h5><p>令$A = \{ 2 n - 1 | n \in \mathbb { N  } _{ +  } \} , B = \{ 3 n - 1 | n \in \mathbb { N  } _{ +  } \} $.求$A \cap B $,以及$A \cup B $的最小的一百项之和.</p>
<p>对于前者,我们知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a \in A \Leftrightarrow a & \equiv - 1 \pmod { 2  } \\
b \in B \Leftrightarrow b & \equiv - 1 \pmod { 6  } \\

\end{aligned}</script><p>所以$A \cap B = \{ 6 n - 1 | n \in \mathbb { N  } _{ +  } \} $.</p>
<p>而同理,$x \in A \cup B \Leftrightarrow x \equiv - 1 / - 2 / - 3 / - 5 \pmod { 6  } $.于是后者是简单的.</p>
<h3><span id="构造双射在数列中的应用">构造双射在数列中的应用</span></h3><p>设$A = \{ x | x = 2 n - 1 , n \in \mathbb { N  } _+ \} , B = \{ x | x = 2 ^n , n \in \mathbb { N  } _+ \} $,现在将$A \cup B $中的元素排序并提取成一个数列$a $,求使得$S _n &gt; 12 a _n $最小的正整数$n $.</p>
<p>写出数列,它长这样:</p>
<script type="math/tex; mode=display">
\begin{matrix}
1 & 2 \\
3 & 4 \\
5 & 7 & 8 \\
9 & 11 & 13 & 15 & 16 \\
& & \cdots 
\end{matrix}</script><p>不妨设$n $在第$r $行$c $列,显然$( r , c ) $和$n $构成双射.</p>
<p>那么我们现在无非有两个思路:要么找到一个方式使得对于给定的$n $能快速表达$( r , c ) $,要么反之.显然反之比较简单.</p>
<p>考虑设前$k $行共有$W _k $个数,不难发现$W _{ k + 1  } = W _k + 2 ^{ k - 1  } + 1 , W _k = 2 ^{ k - 1  } + k $.</p>
<p>显然,对于$( r , c ) $来说,它对应的$n $就是$W _{ r - 1  } + c $.</p>
<p>令$SR _{ r  } $为前$r $行数字之和,不难发现$SR _r = 2 ^{ r + 1  } - 2 + ( 2 ^{ r - 1  } ) ^2 $.</p>
<p>接下来考虑找到这个最小的$n $,显然$r \ne 1 $,接下来只考虑$r \geq 2 $的情况.</p>
<p>那么我们可以轻松写出$S _n $和$a _n $的表达式,下面直接给出:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = SR _{ r - 1  } + \sum _{ k = 1  } ^c ( 2 ^{ r - 1  } + 2 k - 1 ) - [ c & = 2 ^{ r - 2  } + 2 ] \\
S _n & = 2 ^r - 2 + 4 ^{ r - 2  } + 2 ^{ r - 1  } c + c ^2 - [ c & = 2 ^{ r - 2  } + 1 ] \\
a _n & = 2 ^{ r - 1  } + 2 c - 1 - [ c & = 2 ^{ r - 2  } + 1 ] 
\end{aligned}</script><p>讨论一下$[ c = 2 ^{ r - 2  } + 1 ] $这个判定式取$0 $还是取$1 $,这样就做完了.</p>
<h3><span id="不等式放缩在数列中的应用">不等式放缩在数列中的应用</span></h3><h2><span id="几何导论">几何导论</span></h2><h3><span id="三角相关">三角相关</span></h3><h4><span id="三角恒等变换">三角恒等变换</span></h4><h5><span id="两角和差公式">两角和差公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( A + B ) & = \sin A \cos B + \sin B \cos A \\
\sin ( A - B ) & = \sin A \cos B - \sin B \cos A \\
\cos ( A + B ) & = \cos A \cos B - \sin A \sin B \\
\cos ( A - B ) & = \cos A \cos B + \sin A \sin B \\
\tan ( A + B ) & = \frac { \tan A + \tan B  } { 1 - \tan A \tan B  } \\
\tan ( A - B ) & = \frac { \tan A - \tan B  } { 1 + \tan A \tan B  } 
\end{aligned}</script><h5><span id="倍角公式">倍角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\tan ( 2 A ) & = \frac { 2 \tan A  } { 1 - \tan ^2 A  } \\
\sin ( 2 A ) & = 2 \sin A \cos A \\
\cos ( 2 A ) & = \cos ^2 A - \sin ^2 A & = 2 \cos ^2 A - 1 & = 1 - 2 \sin ^2 A 
\end{aligned}</script><h5><span id="半角公式">半角公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 - \cos A  } { 2  }  } \\
\cos ( \frac { A  } { 2  } ) & = \pm \sqrt { \frac { 1 + \cos A  } { 2  }  } \\
\tan ( \frac { A  } { 2  } ) & = \frac { \sin A  } { 1 + \cos A  } & = \frac { 1 - \cos A  } { \sin A  } & = \pm \sqrt { \frac { 1 - \cos A  } { 1 + \cos A  }  } 
\end{aligned}</script><h5><span id="和差化积">和差化积</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A + \sin B & = 2 \sin ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\sin A - \sin B & = 2 \cos ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\cos A + \cos B & = 2 \cos ( \frac { A + B  } { 2  } ) \cos ( \frac { A - B  } { 2  } ) \\
\cos A - \cos B & = - 2 \sin ( \frac { A + B  } { 2  } ) \sin ( \frac { A - B  } { 2  } ) \\
\tan A + \tan B & = \frac { \sin ( A + B )  } { \cos A \cos B  } 
\end{aligned}</script><p>值得一提的是,如果你对和差化积特别熟悉,你不难发现下面这个式子:</p>
<script type="math/tex; mode=display">
\sin ^2 A - \sin ^2 B = \sin ( A - B ) \sin ( A + B )</script><p>如果细看会发现,这其实就是和差化积与二倍角公式并用得到的推论,但实际上用处远比和差化积要多.</p>
<h5><span id="积化和差">积化和差</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sin A \sin B & = - \frac { 1  } { 2  } [ \cos ( A + B ) - \cos ( A - B ) ] \\
\cos A \cos B & = \frac { 1  } { 2  } [ \cos ( A + B ) + \cos ( A - B ) ] \\
\sin A \cos B & = \frac { 1  } { 2  } [ \sin ( A + B ) + \sin ( A - B ) ] \\
\cos A \sin B & = \frac { 1  } { 2  } [ \sin ( A + B ) - \sin ( A - B ) ] 
\end{aligned}</script><h5><span id="万能公式">万能公式</span></h5><p>令$w = \tan \frac { A  } { 2  } $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin A & = \frac { 2 w  } { 1 + w ^2  } \\
\cos A & = \frac { 1 - w ^2  } { 1 + w ^2  } \\
\tan A & = \frac { 2 w  } { 1 - w ^2  } 
\end{aligned}</script><p>当然,这个所谓的万能公式其实一点用都没有,因为我们有更强大的公式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos ( x ) & = \frac { e ^{ ix  } + e ^{ - ix  }  } { 2  } \\
\sin ( x ) & = \frac { e ^{ ix  } - e ^{ - ix  }  } { 2 i  } 
\end{aligned}</script><h5><span id="补充公式">补充公式</span></h5><script type="math/tex; mode=display">
\begin{aligned}
1 + \sin A & = ( \sin \frac { A  } { 2  } + \cos \frac { A  } { 2  } ) ^2 \\
1 - \sin A & = ( \sin \frac { A  } { 2  } - \cos \frac { A  } { 2  } ) ^2 
\end{aligned}</script><h4><span id="周期函数与初等数论">周期函数与初等数论</span></h4><p>我们知道,处理三角中的周期性问题时,需要设一些取值为整数的$k $来解决问题,这引发我们思考:是否可以将初等数论中的模法来解决这一类问题呢?</p>
<h6><span id="example1">Example1</span></h6><p>已知函数$f ( x ) = \sin ( \omega x + \varphi ) , w &gt; 0 $,$f ( - \frac { \pi  } { 6  } ) = 0 , f ( \frac { \pi  } { 2  } ) = - 1 $,求$w $和$\varphi $的表达式.</p>
<p>正确做法应该是强设$k _1 , k _2 $,但我们来使用模法.</p>
<p>必须要注意的一点是,我们这里的$\omega $和$\varphi $都不是整数,这意味着我们必须时刻保证同余式子左侧是整数,也就是在操作的时候不可以使用任何逆元!换句话说,你两边同时做乘法的时候,只可以同时乘以整数,不可以同时乘以分数.</p>
<p>不妨令$\frac { \pi  } { 2  } $为单位$1 $,我们必有以下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- \frac { \omega  } { 3  } + \varphi & \equiv 0 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><p>下面推导$\omega $,首先将上面两个式子直接相减,立有:</p>
<script type="math/tex; mode=display">
\frac { 4  } { 3  } \omega \equiv 1 \pmod { 2  }</script><p>对于$\varphi $,考虑类似的做法,将第一个式子乘以$3 $后与第二个式子相加,立有:</p>
<script type="math/tex; mode=display">
4 \varphi \equiv 1 \pmod { 2  }</script><p>这样我们得到的必须满足的条件就有以下几条:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 4  } { 3  } \omega & \equiv 1 \pmod { 2  } \\
4 \varphi & \equiv 1 \pmod { 2  } \\
\omega + \varphi & \equiv 3 \pmod { 4  } 
\end{aligned}</script><h3><span id="向量相关">向量相关</span></h3><h4><span id="旋转模型">旋转模型</span></h4><p>自己瞎起的名字.</p>
<h6><span id="example1">Example1</span></h6><p>已知$AB = 2 , AC = 1 , \angle A = \theta $,$BC $绕$B $点顺时针旋转$\frac { \pi  } { 3  } $得到$BD $,求以$\theta $表示$S _{ \triangle CBD  } $.</p>
<p>先来说文化课做法,我们直接表示$S $,令$\alpha = \angle ABC $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S & = | BD | \sin ( \alpha + \frac { \pi  } { 3  } ) \\

\end{aligned}</script><p>对于这个式子,我们发现如果我们能得到$| BD | \sin ( \alpha ) $和$| BD | \cos ( \alpha ) $就可以解决了对吧.</p>
<p>这两个怎么求得呢?我们发现$BD $是$\alpha $的一条临边.观察正弦定理和余弦定理可知,正弦定理可以帮助我们求出$| BD | \sin \alpha $,余弦定理可以帮助我们求出$| BD | \cos \alpha $.</p>
<p>然而,如果我们再冷静一下,会得到一个更厉害一点的做法:</p>
<p>我们直接建系,立刻可以求出$\overrightarrow { AB  } $和$\overrightarrow { BC  } $的坐标表示,将$\overrightarrow { BC  } $用旋转矩阵转过去,拿叉积算一下两个向量所生成的三角形面积即可.</p>
<p>如果要把这个做法对应到文化课可以拿到分的做法的话,首先叉积可以去掉,改为直接暴力算.至于旋转的话可能需要一些操作例如三角换元之类的.</p>
<h4><span id="爪子模型">爪子模型</span></h4><p>比起套模型,我们来总结一下向量中的两个做题法则:</p>
<ol>
<li><p>如果存在两条不共线向量,已知它们的夹角以及边长,这个题至少可以通过设单位向量暴力运算解决.</p>
</li>
<li><p>如果通篇题目不涉及边长,或者是涉及边长,但所求是角,将某个边长当作$1 $是一定没有问题的,这样可以少掉一个未知量,为将来的做题提供更明确的道路.</p>
</li>
</ol>
<p>直接来看题:</p>
<h6><span id="example1">Example1</span></h6><p>$\triangle ABC $中,$b ^2 = ac $,点$D $在$AC $上且满足$BD = b $,有$\overrightarrow { AD  } = 2 \overrightarrow { DC  } $,求$\cos \angle ABC $.</p>
<p>这题通篇没有提到任何的边长,我们可以直接钦定$c = 1 $,于是有$b ^2 = a $.</p>
<p>考虑我们要求$\cos \angle ABC $,而我们有一条很奇怪的边$BD $,似乎不满足任何性质,我们立刻想到要把它用$\angle ABC $的两条边向量表示,除此之外没有任何别的表示方式.</p>
<p>后面就没有什么了,这题的难点在于后面的解方程过程,但只要你敢让$c = 1 $,后面的解方程极其简单.</p>
<h4><span id="奔驰定理及三角形四心">奔驰定理及三角形四心</span></h4><h5><span id="奔驰定理">奔驰定理</span></h5><p>对于$\triangle ABC $内一点$P $,立有$S _{ \triangle PBC  } \overrightarrow { PA  } + S _{ \triangle PAC  } \overrightarrow { PB  } + S _{ \triangle PAB  } \overrightarrow { PC  } = \vec { 0  } $.</p>
<p>看到的证明都略麻烦,下面给出一个容易理解的证明.</p>
<p>我们物理上学过拉密定理,其实也就是运用三角形法则以及正弦定理.利用拉密定理,令$a = PA , b = PB , c = PC $,我们要证奔驰定理,也就是要证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
bc \sin \alpha \overrightarrow { PA  } + ac \sin \beta \overrightarrow { PB  } + ab \sin \gamma \overrightarrow { PC  } & = \vec { 0  } \\
abc \sin \alpha \frac { \overrightarrow { PA  }  } { a  } + abc \sin \beta \frac { \overrightarrow { PB  }  } { b  } + abc \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\
\sin \alpha \frac { \overrightarrow { PA  }  } { a  } + \sin \beta \frac { \overrightarrow { PB  }  } { b  } + \sin \gamma \frac { \overrightarrow { PC  }  } { c  } & = \vec { 0  } \\

\end{aligned}</script><p>考虑$| \frac { \overrightarrow { PA  }  } { a  } | = | \frac { \overrightarrow { PB  }  } { b  } | = | \frac { \overrightarrow { PC  }  } { c  } | = 1 $,后者根据拉密定理显然成立.</p>
<h5><span id="外心">外心</span></h5><p>有正弦定理,$| \overrightarrow { OA  } | = | \overrightarrow { OB  } | = | \overrightarrow { OC  } | = \frac { a  } { 2 \sin A  } $.</p>
<p>考虑三个三角形的面积可以表示为$\frac { r ^2  } { 2  } \sin \theta $,又考虑到圆中的$\theta $是圆心角是圆周角的两倍,立有$\sin ( 2 A ) \overrightarrow { OA  } + \sin ( 2 B ) \overrightarrow { OB  } + \sin ( 2 C ) \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>下面给出一个例题:</p>
<h6><span id="example1">Example1</span></h6><p>在$\triangle ABC $中,$AB = 2 , BC = \sqrt { 10  } , AC = 3 $,若$O $是其外心,且$\overrightarrow { AO  } = p \overrightarrow { AB  } + q \overrightarrow { AC  } $.</p>
<p>先给出我一开始的想法:</p>
<p>在没学奔驰定理之前,我们看到这个外心,第一反应肯定是使用$| OA | = | OB | = | OC | $,也就是这三个长度都是好求的.因此,我们考虑对上面的式子两边平方,得到一个关于$p , q $的方程.但是这样没有解决问题.</p>
<p>考虑我们只用了$| OA | $,用上$| OB | $,这样的话我们两边同时加上$\overrightarrow { BA  } $,就可以得到$p , q $的另一个方程,可以解出两组解,直接舍也可以舍,不然的话根据$| OC | $也可以舍一个解.</p>
<p>但是这样太蠢了啊,我们考虑直接凑奔驰定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { AO  } & = p \overrightarrow { AB  } + q \overrightarrow { AC  } \\
\vec { 0  } & = ( p + q - 1 ) \overrightarrow { OA  } + p \overrightarrow { OB  } + q \overrightarrow { OC  } 
\end{aligned}</script><p>考察奔驰定理,立有$\frac { p + q - 1  } { \sin ( 2 A )  } = \frac { p  } { \sin ( 2 B )  } = \frac { q  } { \sin ( 2 C )  } $,简单题.</p>
<h6><span id="example2">Example2</span></h6><p>已知相异两点$O , H $分别为$\triangle ABC $的外心和垂心,若$\overrightarrow { OH  } = m ( \overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } ) $,求$m $.</p>
<p>这题要用到的性质是,我们一定要知道$( \overrightarrow { OB  } + \overrightarrow { OC  } ) \cdot \overrightarrow { BC  } = 0 $,这也是外心的一个很重要的性质.</p>
<p>由此,我们让左边凑出$\overrightarrow { AH  } $,然后两边同时乘以$\overrightarrow { BC  } $就可以解决.注意到最后解方程的时候要么$m = 1 $,要么三角形等边,但是我们声明过$O , H $相异两点.</p>
<h5><span id="重心">重心</span></h5><p>首先重心将中线三等分,这个我竟然一直没细想过怎么证明啊,只是觉得倍长中线肯定能证明.</p>
<p>事实上用不到那么麻烦,你直接连接两个中点,立有中位线,然后以重心为两个三角形的顶点,立有一组对顶角且对边平行的$1 : 2 $的相似.</p>
<p>又考察三条中线将整个三角形分成了六部分,这六部分的面积是相等的.</p>
<p>为啥呢?因为你可以先把三角形分成三部分(也就是每个顶点连到重心),然后将这三部分内部的两个小三角形证明面积相等(因为此时重心是它的顶点,沿着中线连下去就还是这个三角形的中线),再利用上面的三等分结论就显然了啊.</p>
<p>结合奔驰定理,立有若$O $是重心,则必有$\overrightarrow { OA  } + \overrightarrow { OB  } + \overrightarrow { OC  } = \vec { 0  } $.</p>
<p>然后听说有个物理理想实验的理解方式,大概是说这与力矩结合一下就可以得到这是他物理重心的结论,不会.</p>
<h5><span id="垂心">垂心</span></h5><p>若$O $是重心,立有$\overrightarrow { OA  } \cdot \overrightarrow { BC  } = 0 $,将$\overrightarrow { BC  } = \overrightarrow { BO  } + \overrightarrow { OC  } $,立有$\overrightarrow { OA  } \cdot \overrightarrow { OB  } = \overrightarrow { OA  } \cdot \overrightarrow { OC  } = \overrightarrow { OB  } \cdot \overrightarrow { OC  } $.同时顺带证明了三条高交于一点.</p>
<p>根据奔驰定理还有$\overrightarrow { OA  } \tan A + \overrightarrow { OB  } \tan B + \overrightarrow { OC  } \tan C = \vec { 0  } $.</p>
<h5><span id="内心">内心</span></h5><p>根据奔驰定理,立有$a \overrightarrow { OA  } + b \overrightarrow { OB  } + c \overrightarrow { OC  } = \vec { 0  } $.</p>
<h3><span id="立体几何相关">立体几何相关</span></h3><h4><span id="基本概念">基本概念</span></h4><h5><span id="直线">直线</span></h5><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h5><span id="平面">平面</span></h5><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h5><span id="夹角">夹角</span></h5><h6><span id="两直线夹角">两直线夹角.</span></h6><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h6><span id="直线与平面的夹角">直线与平面的夹角</span></h6><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h5><span id="交点">交点</span></h5><p>联立方程硬解.</p>
<h4><span id="基本定理">基本定理</span></h4><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h5><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h5><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h5><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h5><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>
<h3><span id="圆锥曲线">圆锥曲线</span></h3><h4><span id="约定">约定</span></h4><p>对于所有对称情况结论只讨论一种(其它情况可通过坐标变换得到),但是例题以及做题方法除外.</p>
<p>大部分涉及斜率的存在性问题,统一不予考虑.如果遇到实际例题,只需特别处理那几个特殊情况即可($mx + ny = 1 $需要判断过原点的直线,$y = kx + b $需要判断平行于$y $轴的直线),显然大部分情况下是平凡的.</p>
<h4><span id="椭圆">椭圆</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之和为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | F _1 P | + | F _2 P | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为椭圆.</p>
<h5><span id="椭圆方程">椭圆方程</span></h5><h6><span id="标准方程">标准方程</span></h6><p>由定义不难得到椭圆的标准方程:$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( b ^2 = a ^2 - c ^2 , a &gt; b &gt; 0 ) $.</p>
<h6><span id="一般方程">一般方程</span></h6><p>$nx ^2 + my ^2 = 1 ( n , m \geq 0 ) $,这样设的好处在于如果不知道焦点的位置,仍然可以设方程并进行代数运算,最后判断一下$n $和$m $的大小关系即可.</p>
<h5><span id="椭圆重要元素">椭圆重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = a - ex _0 $.</p>
<h6><span id="焦点弦">焦点弦</span></h6><p>过$F _1 $的弦$| AB | = 2 a + e ( x _1 + x _2 ) $.</p>
<p>过$F _2 $的弦$| AB | = 2 a - e ( x _1 + x _2 ) $.</p>
<p>注意到焦点弦最短时$x _1 = x _2 $.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li><p>$C = 2 a + 2 c $.</p>
</li>
<li><p>$S = b ^2 \tan \frac { \theta  } { 2  } = c | y _P | $.</p>
</li>
<li><p>$\cos \theta \geq 1 - 2 e ^2 $(当$P $在短轴上取等).</p>
</li>
<li><p>$| PF _1 | | PF _2 | = \frac { 2 b ^2  } { 1 + \cos \theta  } $.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example1">Example1</span></h6><p>已知椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,$P $是椭圆上一点,$\angle F _1 PF _2 $的角平分线交$x $轴于$Q ( \frac { c  } { 4  } , 0 ) $,求离心率取值范围.</p>
<p>注意到$S _{ \bigtriangleup QPF _1  } = \frac { 5  } { 3  } S _{ \bigtriangleup QPF _2  } $,又有$Q $到$PF _1 $和$PF _2 $的距离相等,用等积法,显然$PF _1 = \frac { 5  } { 4  } a , PF _2 = \frac { 3  } { 4  } a $.</p>
<p>然后用三角形不等式做差就行.$2 c &gt; \frac { 1  } { 2  } a , \frac { 1  } { 4  } &lt; e $</p>
<h4><span id="双曲线">双曲线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内与两定点$F _1 , F _2 $距离之差为常数($&gt; | F _1 F _2 | $)的点轨迹.即:$\{ P \mid | | F _1 P | - | F _2 P | | = 2 a , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第二定义">第二定义</span></h6><p>平面内一动点到定点与准线($x = \pm \frac { a ^2  } { c  } $)的距离比是常数$e = \frac { c  } { a  } $的点轨迹,即$\{ P \mid \frac { | PF _1 |  } { d _1  } = \frac { | PF _2 |  } { d _2  } = \frac { c  } { a  } = e , F _1 ( - c , 0 ) , F _2 ( c , 0 ) \} $.</p>
<h6><span id="第三定义">第三定义</span></h6><p>平面内一动点到两定点$A _1 ( - a , 0 ) , A _2 ( a , 0 ) $的斜率乘积等于定值$e ^2 - 1 $的轨迹称为双曲线.</p>
<h5><span id="双曲线重要元素">双曲线重要元素</span></h5><h6><span id="焦半径">焦半径</span></h6><p>若$P ( x _0 , y _0 ) , ( x _0 &gt; 0 ) $,则$| PF _1 | = a + ex _0 $,$| PF _2 | = - a + ex _0 $.</p>
<h6><span id="渐近线">渐近线</span></h6><p>$y = \pm \frac { b  } { a  } x $.</p>
<p>如果换个方向的双曲线,事实上就是把双曲线标准方程的等号右边写成$0 $得到的两个直线方程.</p>
<h6><span id="焦点三角形">焦点三角形</span></h6><p>即$\bigtriangleup PF _1 F _2 $,令$\theta = \angle F _1 PF _2 $,有以下性质:</p>
<ol>
<li>$S = \frac { b ^2  } { \tan \frac { \theta  } { 2  }  } $.</li>
</ol>
<h4><span id="抛物线">抛物线</span></h4><h5><span id="定义">定义</span></h5><h6><span id="第一定义">第一定义</span></h6><p>平面内一动点到定点与准线的距离相等的点轨迹.</p>
<h5><span id="抛物线重要元素">抛物线重要元素</span></h5><h6><span id="焦点弦">焦点弦</span></h6><p><del>我曾经以为整理完二项式恒等式后再也不会有同样恐怖的结论群了</del></p>
<p>直线$AB $为过$y ^2 = 2 px ( p &gt; 0 ) $焦点的弦,$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,倾斜角为$\theta $,准线与$x $轴交点为$E ( - \frac { p  } { 2  } , 0 ) $,作$AA _1 $,$BB _1 $垂直于准线于$A _1 , B _1 $,则:</p>
<ol>
<li><p>$| AF | = x _1 + \frac { p  } { 2  } $,$| BF | = x _2 + \frac { p  } { 2  } $,$| AB | = x _1 + x _2 + p , \frac { 1  } { | FA |  } + \frac { 1  } { | FB |  } = \frac { 2  } { p  } $.</p>
</li>
<li><p>$| AF | = \frac { p  } { 1 - \cos \theta  } , | BF | = \frac { p  } { 1 + \cos \theta  } , | AB | = \frac { 2 p  } { \sin ^2 \theta  } $.</p>
</li>
<li><p>$x _1 x _2 = \frac { p ^2  } { 4  } $,$y _1 y _2 = - p ^2 $.</p>
</li>
<li><p>$S _{ \bigtriangleup AOB  } = \frac { p ^2  } { 2 \sin \theta  } $.</p>
</li>
<li><p>$k _{ AE  } + k _{ BE  } = 0 $.</p>
</li>
<li><p>$A , O , B _1 $三点共线,$B , O , A _1 $三点共线.</p>
</li>
<li><p>以$AB $为直径的圆与抛物线的准线相切.</p>
</li>
<li><p>以$A _1 B _1 $为直径的圆与$AB $相切.</p>
</li>
<li><p>以$AF $或$BF $为直径的圆与$y $轴相切.</p>
</li>
</ol>
<h4><span id="通用解法">通用解法</span></h4><h5><span id="联立方程">联立方程</span></h5><h6><span id="点参">点参</span></h6><p>不设直线斜率,直接通过设点坐标并且导出直线斜率.</p>
<p>这种做法通常要么不能做,要么能做并且非常简单,需要强大的构造能力.</p>
<p><strong>弦长公式</strong></p>
<p>已知直线$l $上有两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,那么$| NM | = \sqrt { 1 + k ^2  } | x _1 - x _2 | = \sqrt { 1 + \frac { 1  } { k ^2  }  } | y _1 - y _2 | $.</p>
<p><strong>点差法</strong></p>
<p>设圆锥曲线上两点$A ( x _1 , y _1 ) , B ( x _2 , y _2 ) $,其中点$M ( x _0 , y _0 ) $,有$2 x _0 = x _1 + x _2 , 2 y _0 = y _1 + y _2 $.</p>
<p>把这两个点带入圆锥曲线方程并做差,可以通过平方差公式消去几项.然后可以表示出直线斜率,大概做做.</p>
<p><strong>垂径定理</strong></p>
<p>已知直线$l $与曲线交于两点$N ( x _1 , y _1 ) , M ( x _2 , y _2 ) $,这条直线的斜率为$k $,$MN $的中点为$P ( x _0 , y _0 ) $,那么:</p>
<ol>
<li><p>在椭圆$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 ( a &gt; b &gt; 0 ) $中,$k \frac { y _0  } { x _0  } = - \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $中,$k \frac { y _0  } { x _0  } = \frac { b ^2  } { a ^2  } = e ^2 - 1 $.</p>
</li>
<li><p>在抛物线$y ^2 = 2 px ( p &gt; 0 ) $中,$k = \frac { p  } { y _0  } = \frac { x _0  } { p  } $.</p>
</li>
</ol>
<h6><span id="小联立">小联立</span></h6><p>如果题目中有两条直线,它们之间的斜率满足一定关系,那么可以通过把这两个直线的斜率都设出来,然后再添加一个方程来实现.</p>
<p>这个方法的优点在于,有的时候分离出的方程会让原始式子简单很多.</p>
<p>缺点在于,有的时候会让原始式子复杂很多.</p>
<h6><span id="大联立">大联立</span></h6><p>直接设主要直线的方程,然后其它直线均通过主要直线方程导出.</p>
<p>最常用的方法.</p>
<p><strong>齐次化</strong></p>
<p>本质是平移坐标系.</p>
<p>简单来说,如果图中有两条有公共点的直线$PA $,$PB $,我们可以将公共点$P $平移至原点,这样$PA $和$PB $的方程都方便表达.然后设$AB $的方程为$mx + ny = 1 $(注意这个式子不能表示过原点的直线,需要特判).</p>
<p>由于进行了平移,新得到的圆锥曲线方程可能存在一次项和零次项,我们将一次项乘以$mx + ny $,零次项乘以$( mx + ny ) ^2 $,这样就得到了一个齐次式子.将两边同时除以$x ^2 $后就得到了一个和$k = \frac { y  } { x  } $有关的方程.</p>
<p>换句话说,某种意义下,齐次化应该算是点参和大联立的结合体:大部分情况下,能用点参的条件是斜率可以用点坐标轻松表示,而如果点的坐标比较奇怪就没办法表示,而齐次化可以完美解决这个问题.</p>
<p><strong>非对称性韦达定理</strong></p>
<p>大概就是求出一个用一个方程的根表达的式子,然后需要继续化简.</p>
<p>通常的做法是寻找方程的$x _1 x _2 $和$x _1 + x _2 $之间的关系来做.</p>
<p>当然还有一种情况是问形如$\frac { Ax _1 + Bx _2  } { Cx _1 + Dx _2  } $是定值的问题,这个时候一定有$\frac { A  } { C  } = \frac { B  } { D  } $.</p>
<p>还没完,非对称性韦达定理的应用巨多,例如令$w = \frac { x _1  } { x _2  } $,自然有$w + \frac { 1  } { w  } + 2 = \frac { ( x _1 + x _2 ) ^2  } { x _1 x _2  } $.</p>
<p>还比如有$y _2 = ny _1 + m $,我们可以用配凑技巧改写作$( y _2 + w ) = k ( y _1 + w ) $,也就有$\frac { y _2 + w  } { y _1 + w  } = k $,类似上面的做法也可以求.</p>
<p><strong>硬解定理</strong></p>
<p>设直线$y = kx + \varphi $与曲线$\frac { x ^2  } { m  } + \frac { y ^2  } { n  } = 1 $相交于$A ( x _1 , y _1 ) $和$B ( x _2 , y _2 ) $.</p>
<p>那么联立方程是:$( n + mk ^2 ) x ^2 + 2 k \varphi mx + m ( \varphi ^2 - n ) = 0 $.</p>
<p>判别式:$\Delta = 4 mn ( n + mk ^2 - \varphi ^2 ) $.</p>
<p>韦达定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x _1 + x _2 & = \frac { - 2 km \varphi  } { n + mk ^2  } \\
x _1 x _2 & = \frac { m ( \varphi ^2 - n )  } { n + mk ^2  } \\
| x _1 - x _2 | & = \frac { \sqrt { \Delta  }  } { n + mk ^2  } 
\end{aligned}</script><h6><span id="配凑法">配凑法</span></h6><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/521025768">https://zhuanlan.zhihu.com/p/521025768</a>.</p>
<p>先猜结论,再对着结论构造一个对称式子,从而声明这个式子就是答案.</p>
<p>问题在于咋构造,通常前面的部分还是按部就班来.最后来一步”注意到”来机械降神.</p>
<p>感觉没什么太大用,因为小题直接猜结论,大题按部就班不会太慢.</p>
<h6><span id="应用">应用</span></h6><p><strong>Example1(大联立/点参)</strong></p>
<p>已知抛物线$y ^2 = 4 x $,若$A , B $位于抛物线上$x $轴上方不同的两点,直线$OA , OB $的斜率分别为$k _1 , k _2 $,且满足$k _1 k _2 - 4 = 4 k _1 + 4 k _2 $,求证:$AB $过定点,并求出$k _{ AB  } $的取值范围.</p>
<p>注意到$k _1 $和$k _2 $之间的关系很复杂,这个时候就别惦记你那小联立了,老老实实拿大联立做吧.</p>
<p>设$AB : y = kx + b $,则$A ( x _1 , kx _1 + b ) , B ( x _2 , kx _2 + b ) $,显然$k _1 = k + \frac { b  } { x _1  } , k _2 = k + \frac { b  } { x _2  } $.</p>
<p>直接带入方程,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k + \frac { b  } { x _1  } ) ( k + \frac { b  } { x _2  } ) - 4 & = 4 ( 2 k + \frac { b  } { x _1  } + \frac { b  } { x _2  } ) \\
k ^2 + kb ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) + \frac { b ^2  } { x _1 x _2  } - 4 & = 8 k + 4 b ( \frac { 1  } { x _1  } + \frac { 1  } { x _2  } ) \\

\end{aligned}</script><p>而直接大联立得到的式子是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k ^2 x ^2 + ( 2 kb - 4 ) x + b ^2 & = 0 \\
\Delta & = 16 - 16 kb & > 0 , kb & < 1 \\
x _1 x _2 & = \frac { b ^2  } { k ^2  } , x _1 + x _2 & = \frac { 4 - 2 kb  } { k ^2  } , \frac { 1  } { x _1  } + \frac { 1  } { x _2  } & = \frac { 4 - 2 kb  } { b ^2  } 
\end{aligned}</script><p>带入,得到$k - b = 4 $,因此过定点$( - 1 , - 4 ) $,与$kb &lt; 1 $联立得到$k &lt; 2 + \sqrt { 5  } $.</p>
<p>还没完,这种题一定要检查一遍条件.注意到$AB $为$x $轴上方两点的性质没用到,这意味着$y _1 y _2 &gt; 0 \land y _1 + y _2 &gt; 0 $,带入方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b ^2 + b ( \frac { 4 - 2 kb  } { k  } ) + b ^2 & > 0 \\
\frac { 4 - 2 kb  } { k  } + 2 b & > 0 
\end{aligned}</script><p>化简得到$\begin{cases}b &gt; 0 \ k &gt; 0 \end{cases} $,解得$k &gt; 4 $,于是$k \in ( 4 , 2 + \sqrt { 5  } ) $.</p>
<p>这啥暴力计算啊…没啥好方法嘛?</p>
<p>首先显然的一点是:由于是在做抛物线,直线方程设成反式肯定会好算很多.<del>(整理到这里才意识到可以设反式,但是懒得改前面的内容了)</del></p>
<p>看上去式子太复杂确实不太可能用小联立做.问题在于,$OA $和$OB $的斜率看上去都很好表示,为何不能用点参做呢?</p>
<p>我们尝试直接用点参:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k _{ OA  } & = \frac { y _1  } { x _1  } , k _{ OB  } & = \frac { y _2  } { x _2  } \\
\frac { y _1 y _2  } { x _1 x _2  } - 4 & = 4 ( \frac { y _1  } { x _1  } + \frac { y _2  } { x _2  } ) \\
16 - 4 y _1 y _2 & = 16 ( y _1 + y _2 ) 
\end{aligned}</script><p>我们毫不费力就导出了用反式之后做的式子,这仿佛在预示我们点参是有用的,让我们继续:</p>
<script type="math/tex; mode=display">
\begin{aligned}
AB : \\
x - x _1 & = ( y - y _1 ) \frac { x 1 - x _2  } { y _1 - y _2  } \\
x - \frac { y _1 ^2  } { 4  } & = ( y - y _1 ) \frac { 1  } { 4  } ( y _1 + y _2 ) \\
x & = \frac { y _1 + y _2  } { 4  } y - \frac { y _1 y _2  } { 4  } \\
x & = \frac { y _1 + y _2  } { 4  } y - 1 + ( y _1 + y _2 ) 
\end{aligned}</script><p>显然过定点$( - 1 , - 4 ) $,并且通过$y _1 $和$y _2 $的关系也很好求斜率的范围.</p>
<p>另外值得一提的是,通常情况下,不要用那个$\frac { x - x _1  } { x _1 - x _2  } = \frac { y - y _1  } { y _1 - y _2  } $的方程直接表示直线,你做抛物线的很重要的一个目标是通过消参来让式子变得更简洁,而不是去硬着头皮算,上面这个直线方程咋消参啊.</p>
<p><strong>Example2(齐次化)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + y ^2 = 1 $,$P , Q $在椭圆上,$A ( 2 , 0 ) $,$k _{ AP  } k _{ AQ  } = \frac { 1  } { 20  } $,求证:$PQ $过定点.</p>
<p>注意到$A ( 2 , 0 ) $,设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$PQ : m ( x - 2 ) + yn = 1 $,那么我们要求的也就是$x - 2 $和$y $之间的关系.</p>
<p>第一步先要把椭圆方程配出来,显然$\frac { x ^2  } { 4  } + y ^2 = 1 \Rightarrow \frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 $.</p>
<p>显然?这咋配的啊.</p>
<p>其实简单来说也就是令$x ‘ = x - 2 , y ‘ = y $,我们有$x = x ‘ + 2 , y = y ‘ $,带入就可以得到关于$x ‘ , y ‘ $的方程,然后再带回$x $和$y $就行.</p>
<p>我们开始推导:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { ( x - 2 ) ^2  } { 4  } + ( x - 2 ) + y ^2 = 0 \\
( x - 2 ) ^2 + 4 ( x - 2 ) + 4 y ^2 = 0 \\
( x - 2 ) ^2 + 4 n ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
( 4 n + 1 ) ( x - 2 ) ^2 + 4 my ( x - 2 ) + 4 y ^2 = 0 \\
4 n + 1 + 4 m \frac { y  } { x - 2  } + 4 ( \frac { y  } { x - 2  } ) ^2 = 0 \\

\end{aligned}</script><p>令$k = \frac { y  } { x - 2  } $,也就得到了$4 n + 1 + 4 mk + 4 k ^2 = 0 $.用一遍韦达定理,有:$k _1 k _2 = \frac { 4 n + 1  } { 4  } = \frac { 1  } { 20  } , n = - \frac { 1  } { 5  } $.</p>
<p>也就有:$PQ : - \frac { 1  } { 5  } ( x - 2 ) + my = 1 $,显然过定点$( - 3 , 0 ) $.</p>
<p><strong>Example3(小联立)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 9  } + y ^2 = 1 $,$P , Q $是该椭圆上两动点,$M , N $分别为$P , Q $在$x $轴上的射影,而且$k _{ OP  } k _{ OQ  } = - 1 $,记$S = S _{ \bigtriangleup OPM  } + S _{ \bigtriangleup OQN  } $,求$S $的最大值.</p>
<p>出现了两条直线!提问:使用大联立还是小联立.</p>
<p>考虑这么一个事实:大联立的用处应该体现在直线$PQ $很重要的时候,而这个题除了$P , Q $两点以外,和$PQ $半毛钱关系都没有.而且如果使用小联立,那么两个斜率之间的关系也很好表示,因此我们选择小联立.</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,$k = \frac { y _1  } { x _1  } , - \frac { 1  } { k  } = \frac { y _2  } { x _2  } $:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = | x _1 y _1 | + | x _2 y _2 | \\
& = | x _1 ^2 k - \frac { 1  } { k  } x _2 ^2 | \\

\end{aligned}</script><p>而联立方程,有:</p>
<script type="math/tex; mode=display">
x _1 ^2 = \frac { 1  } { \frac { 1  } { 9  } + k  } , x _2 ^2 = \frac { 1  } { \frac { 1  } { 9  } - \frac { 1  } { k  }  }</script><p>代入计算即可求解.</p>
<p>当然这个题斜率形式很好看,拿点参肯定也是可以做的,但是没啥必要,因为斜率关系很好看.</p>
<p>等一下,大联立真的没啥希望嘛?</p>
<p>确实没啥希望,因为直线$PQ $有两个未知量,我们还需要拿$k _{ OP  } k _{ OQ  } = - 1 $限制它们的关系,不如直接小联立.</p>
<p><strong>Example4(非对称性韦达定理)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 2  } + y ^2 = 1 $,$F ( 1 , 0 ) $,直线$l $过$F $且交椭圆于$A , B $两点.求问:$x $轴上是否存在异于$F $的一点$Q $,使得$\frac { k _{ QA  }  } { k _{ QB  }  } $是定值.</p>
<p>直接设$AB : x = ky + 1 $,$Q ( q , 0 ) $.我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = \frac { y _1 ( q - x _2 )  } { y _2 ( q - x _1 )  } \\
& = - \frac { ky _1 y _2 + y _1 - qy _1  } { ky _1 y _2 + y _2 - qy _2  } 
\end{aligned}</script><p>坏了,这咋做.</p>
<p>我们用一下韦达定理得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( k ^2 + 2 ) y ^2 + 2 ky - 1 & = 0 \\
\Delta & = 8 k ^2 + 8 & > 0 \\
y _1 + y _2 & = - \frac { 2 k  } { k ^2 + 2  } \\
y _1 y _2 & = - \frac { 1  } { k ^2 + 2  } \\

\end{aligned}</script><p>注意到$\frac { ( y _1 + y _2 )  } { 2  } = k ( y _1 y _2 ) $,代入,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { k _{ QA  }  } { k _{ QB  }  } & = - \frac { y _1 + y _2 + 2 y _1 - 2 qy _1  } { y _1 + y _2 + 2 y _2 - 2 qy _2  } \\
& = - \frac { ( 3 - 2 q ) y _1 + y _2  } { ( 3 - 2 q ) y _2 + y _1  } 
\end{aligned}</script><p>若是定值,那么就有:$\frac { 3 - 2 q  } { 1  } = \frac { 1  } { 3 - 2 q  } $,解得$q _1 = 1 ( F ) $,$q _2 = 2 ( Q ) $.</p>
<p>所以$Q ( 2 , 0 ) $.</p>
<p><strong>Example5(配凑法)</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,过$F ( - 1 , 0 ) $的直线交椭圆于$M , N $两点,过$M $作直线$x = - 4 $的垂线,垂足为$E $,求证:$EN $过定点.</p>
<p>根据对称原理,显然这个定点一定在$x $轴上.</p>
<p>我们先写大联立的式子:设$MN : x = - 1 + ky $,带入有$( 3 m ^2 + 4 ) y ^2 - 6 my - 9 = 0 $.再设$M ( x _1 , y _1 ) , N ( x _2 , y _2 ) $,自然有:</p>
<script type="math/tex; mode=display">
\begin{cases}
\Delta = 144 k ^2 + 144 \\
y _1 + y _2 = \frac { 6 k  } { 3 k ^2 + 4  } \\
y _1 y _2 = \frac { - 9  } { 3 k ^2 + 4  } 
\end{cases}</script><p>接下来呢,我们想一下我们要求什么:我们要求出$EN $的表达式:形如$y - m = k ( x - n ) $,然后声明$( n , m ) $是定点.</p>
<p>这又意味着啥呢,这意味着在这条直线上,除了那个定点以外,一定有$k = \frac { y - m  } { x - n  } $.而我们现在有两个点$E ( - 4 , y _1 ) $和$N ( x _2 , y _2 ) $,又猜出$m = 0 $,也就是我们要找到一个$n $满足$\frac { y _1  } { - 4 - n  } = \frac { y _2  } { x _2 - n  } $.</p>
<p>我们倒着推:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { x _2 - n  } \\
\frac { y _1  } { - 4 - n  } & = \frac { y _2  } { ky _2 - 1 - n  } 
\end{aligned}</script><p>这是啥,这是非对称性韦达定理.</p>
<p>这一步已经可以暴力化简了.但那样还不如直接做呢.所以我们直接选择从非对称性韦达定理的角度推过来.</p>
<p>观察韦达定理的关系式,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
ky _1 y _2 + \frac { 3  } { 2  } ( y _1 + y _2 ) & = 0 \\
( x _2 + \frac { 5  } { 2  } ) y _1 & = - \frac { 3  } { 2  } y _2 \\
y _1 & = \frac { - 3  } { 2  } \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - \frac { 3  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\
\frac { y _1  } { - 4 + \frac { 5  } { 2  }  } & = \frac { y _2  } { x _2 + \frac { 5  } { 2  }  } \\

\end{aligned}</script><p>做到这一步发现要做完了,不难发现$n = \frac { 5  } { 2  } $.</p>
<p>等一下,最后咋就这么巧就凑出来了呢?</p>
<p>因为你都确定了$m = 0 $了,肯定是可以凑出来的,除非它真的不过定点.</p>
<h5><span id="极点极线">极点极线</span></h5><h6><span id="定义">定义</span></h6><p><strong>几何定义</strong></p>
<p><del>感觉这个定义大概率没啥用</del></p>
<p>过不在二次曲线上的一点$P $作直线$l $交二次曲线于$M , N $两点(离$P $近的是$M $),则在$l $上有且只有一点$Q $,使得$| MQ | | NP | = | MP | | NQ | $(即$P , Q , M , N $构成一调和点列).当$l $绕着$P $旋转时,$Q $的轨迹是一条直线$p $(或一部分),这条直线$p $叫做点$P $关于二次曲线的极线,而$P $叫做$p $关于该曲线的极点.</p>
<p>以椭圆为例子,接下来我们声明:$p : \frac { x _0 x  } { a ^2  } + \frac { y _0 y  } { b ^2  } = 1 $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>代数定义</strong></p>
<p>对于不在二次曲线$C : Ax ^2 + Bxy + Cy ^2 + Dx + Ey + F = 0 $上的一点$P ( x _0 , y _0 ) $,我们称它的极线为$p : Axx _0 + B \frac { x _0 y + y _0 x  } { 2  } + Cyy _0 + D \frac { x + x _0  } { 2  } + E \frac { y + y _0  } { 2  } + F = 0 $.</p>
<p>而对于在二次曲线上的点,我们也可以这么定义,不难发现此时极线就是过极点的切线.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="基本性质">基本性质</span></h6><p><strong>性质1(配极原理)</strong></p>
<p>对于同一条二次曲线$C $,如果点$P $的极线经过点$Q $,那么点$Q $的极线经过点$P $.</p>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<p><strong>性质2(配极原理推论)</strong></p>
<p>两点连线的极点是这两点的极线的交点;两直线交点的极线是这两直线的极点的连线.</p>
<p>证明:由性质1,显然.</p>
<p><strong>性质3(极点与极线的位置关系)</strong></p>
<p>ps:对于双曲线而言:我们所说的在内部指的是平面中被双曲线分为的三部分平面中对称的那两部分.抛物线类似.</p>
<ol>
<li><p>设四边形$ABCD $(对边不平行)内接于二次曲线$C $,则对角线交点$P $的极线是两组对边交点的连线.反之同理,若$P $在二次曲线内部,那以这个点为对角线交点的内接四边形对边交点的连线就是它的极线.这告诉我们:若一个点在二次曲线内,那它的极线一定在二次曲线外.反之亦然成立.</p>
</li>
<li><p>若一个点在二次曲线上,那它的极线就是过这个点的二次曲线的切线.</p>
</li>
<li><p>若一个点在二次曲线外,那它的极线就是过这个点向二次曲线作两条切线,这两条切线与二次曲线的交点的连线.</p>
</li>
</ol>
<p>证明:我有一个绝妙的证法,可惜这里地方太小,写不下.</p>
<h6><span id="使用方法">使用方法</span></h6><p>通过极点极线猜结论,然后想办法证明结论.</p>
<p><strong>Example1</strong></p>
<p>已知$\frac { \cos \theta  } { a  } + \frac { \sin \theta  } { b  } = 1 $,求证:$\frac { 1  } { a ^2  } + \frac { 1  } { b ^2  } \geq 1 $.</p>
<p>设直线$l : \frac { x  } { a  } + \frac { y  } { b  } = 1 $,$M ( \cos \theta , \sin \theta ) $,则$M $在$l $上.</p>
<p>又注意到$M $显然是在单位圆上,而$l $是单位圆关于$P ( \frac { 1  } { a  } , \frac { 1  } { b  } ) $的极点.又注意到$l $与单位圆至少有一个交点,因此$P $要么在圆上要么在圆外,得证.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 4  } + \frac { y ^2  } { 3  } = 1 $,$A _1 ( - 2 , 0 ) , A _2 ( 2 , 0 ) , D ( \frac { 1  } { 2  } , 0 ) $,过$D $的直线交椭圆于$P , Q $两点(不与$A _1 , A _2 $重合).$A _1 P \cap A _2 Q = M $,$A _1 Q \cap A _2 P = N $,设$k _1 = k _{ A _1 P  } , k _2 = k _{ A _1 Q  } $.求证:$k _1 k _2 $是定值,求出这个定值并求出$\bigtriangleup DMN $面积的最小值.</p>
<p>一眼极点极线,通过极点极线知识不难得知$MN : x = 8 $.</p>
<p>我们先来看已知$MN : x = 8 $之后怎么做:</p>
<p>设$P ( x _1 , y _1 ) , Q ( x _2 , y _2 ) $,再设$PQ : x = ky + \frac { 1  } { 2  } $,则:$k _1 k _2 = \frac { y _1  } { x _1 + 2  } \frac { y _2  } { x _2 + 2  } $,不难算出$k _1 k _2 = - \frac { 9  } { 20  } $.</p>
<p>此时$S _{ \bigtriangleup DMN  } = | MN | | 8 - \frac { 1  } { 2  } | \frac { 1  } { 2  } $.不难发现只需求出$| MN | _{ \min  } $即可.而$MN \bot x $轴,所以$| MN | = | y _M - y _N | $.</p>
<p>接下来咋做?第一问求得$k _1 $和$k _2 $的关系不能白求啊!</p>
<p>我们有$A _1 P : x = - 2 + \frac { 1  } { k _1  } y , A _1 Q : x = - 2 + \frac { 1  } { k _2  } y $,带入$x = 8 $,求得$y _M = 10 k _1 , y _N = 10 k _2 $.</p>
<p>于是$| MN | = 10 | k _1 - k _2 | $.注意到$k _1 &gt; 0 \land - k _2 &gt; 0 \land k _1 ( - k _2 ) = \frac { 9  } { 20  } $,显然可以用基本不等式计算,最后得到$S _{ \min  } = \frac { 45 \sqrt { 5  }  } { 2  } $.</p>
<p>好,问题就差一步极点极线的证明了.</p>
<p>这个时候,我们先说出$A _1 Q : x = - 2 + \frac { y _2  } { x _2 + 2  } y , A _2 P : x = 2 + \frac { y _1  } { x _1 - 2  } y $,然后我们声明这两条直线的交点的横坐标一定是$8 $,然后代入验证即可.</p>
<p>好吧我也觉得很无赖,没办法.</p>
<h5><span id="隐函数求导">隐函数求导</span></h5><p>大概是这样的:</p>
<p>拿椭圆举例子,我们假设椭圆方程是$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们将$y $看作$x $的函数,对两边求导,自然得到:</p>
<script type="math/tex; mode=display">
\frac { 2 x  } { a ^2  } + \frac { 2 yy '  } { b ^2  } = 0</script><p>这是个方程,你可以解得$y ‘ = - \frac { b ^2 x  } { a ^2 y  } $.而这就是椭圆过$( x , y ) $这一点切线的斜率.用点斜式就可以得到方程.</p>
<p>目前没发现这方法在除了推导切线方程以外有啥用.</p>
<h5><span id="线性变换">线性变换</span></h5><p>大概率没啥用的方法,不过思想还是挺重要的.</p>
<p><del>(好吧我特意写这么一栏只是因为我线代学魔怔了)</del></p>
<p>简单来说就是把一般的图形变成特殊的图形,然后乱做.</p>
<p>线性变换的问题在于角的变化有点随意.不过边长以及斜率的变化都可以控制.</p>
<p><del>不过感觉只有椭圆是迫真有用的东西</del></p>
<h6><span id="旋转矩阵">旋转矩阵</span></h6><p>向量$\vec { b  } = ( x , y ) $逆时针旋转$\theta $后得到的答案是$A \vec { b  } $,其中</p>
<p>\cos\theta,-\sin\theta\\</p>
<p>\sin\theta,\cos\theta</p>
<p>\end{bmatrix} </p>
<p>你要不喜欢矩阵表示也不是不行,那向量$( x , y ) $旋转$\theta $得到$( x ‘ , y ‘ ) $,其中</p>
<p>y’=xsin\theta+ycos\theta</p>
<h6><span id="椭圆转化成圆">椭圆转化成圆</span></h6><p>我们注意到圆的方程是$( x ‘ ) ^2 + ( y ‘ ) ^2 = 1 $,而椭圆的方程形如$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>我们注意到上面的式子等价于:$( \frac { x  } { a  } ) ^2 + ( \frac { y  } { b  } ) ^2 = 1 $.我们将原坐标系中的所有坐标$( x , y ) $全部变成$( \frac { x  } { a  } , \frac { y  } { b  } ) $之后,就得到了一个新的坐标系.在新的坐标系中,我们只需要对着圆做就行.</p>
<p>换成线性代数语言,令$\vec { f  } = ( x , y ) $满足椭圆方程,令$\vec { g  } = ( x ‘ , y ‘ ) $满足圆的方程,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}
\frac { 1  } { a  } , 0 \\
0 , \frac { 1  } { b  } 
\end{bmatrix} \vec { f  } & = \vec { g  } \\

\end{aligned}</script><script type="math/tex; mode=display">
\begin{bmatrix}
a , 0 \\
0 , { b  } 
\end{bmatrix} \vec { g  } = \vec { f  }</script><h6><span id="双曲线转化为反比例函数">双曲线转化为反比例函数</span></h6><p>注意到反比例函数的方程是$x ‘ y ‘ = 1 $,而双曲线的方程是$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $.</p>
<p>这个要硬配可能有些抽象.我们拿矩阵导一导.</p>
<p>首先先转化为$x ^2 - y ^2 = 2 $的形式,需要左乘矩阵$\begin{bmatrix}\frac { \sqrt { 2  }  } { a  } , 0 \ 0 , \frac { \sqrt { 2  }  } { b  } \end{bmatrix} $.</p>
<p>然后这个形式和我们所需要的反比例函数的形式只差一步旋转$\frac { \pi  } { 4  } $了.旋转矩阵为</p>
<p>\frac{1}{\sqrt{2}},-\frac{1}{\sqrt{2}}\\</p>
<p>\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}</p>
<p>\end{bmatrix}</p>
<p>把两个东西乘起来得到矩阵</p>
<p>\frac{1}{a},-\frac{1}{b}\\</p>
<p>\frac{1}{a},\frac{1}{b}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x ‘ = \frac { x  } { a  } - \frac { y  } { b  } , y ‘ = \frac { x  } { a  } + \frac { y  } { b  } $.带入反比例函数的方程:</p>
<script type="math/tex; mode=display">
x ' y ' = \frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1</script><p>对着矩阵求逆一下得到:逆矩阵为</p>
<p>\frac{a}{2},\frac{a}{2}\\</p>
<p>-\frac{b}{2},\frac{b}{2}</p>
<p>\end{bmatrix}</p>
<p>验证一下,我们有$x = \frac { a  } { 2  } ( x ‘ + y ‘ ) , y = \frac { b  } { 2  } ( { y ‘ - x ‘  } ) $,带入双曲线方程得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( \frac { x  } { a  } ) ^2 - ( \frac { y  } { b  } ) ^2 & = 1 \\
( x ' + y ' ) ^2 - ( x ' - y ' ) ^2 & = 4 \\
x ' y ' & = 1 
\end{aligned}</script><p>要觉得矩阵部分比较魔怔也可以直接看上面的普通描述.</p>
<h6><span id="抛物线转化为二次函数">抛物线转化为二次函数</span></h6><p>这个比较简单,交换$x , y $即可,小问题.</p>
<h5><span id="极坐标">极坐标</span></h5><p>平面内取一点$O $为极点,引一条射线$Ox $叫做极轴,再选定单位长度和单位角度以及角度正方向,就建立了一个极坐标系.</p>
<p>对于平面上任意一点$M $,令$\rho = | OM | $,$\theta $为以$Ox $为始边,沿角度正方向(一般是逆时针方向)转到$OM $的夹角.那么我们称$( \rho , \theta ) $为$M $的极坐标,其中$\rho $叫做极径,$\theta $叫做极角.</p>
<p>$\rho $有可能取负,我们通常认为$( - \rho , \theta ) = ( \rho , \theta + \pi ) $.</p>
<p>通常情况下默认$0 \leq \theta &lt; 2 \pi , \rho \geq 0 $.如果遇到和直角坐标系结合的问题,通常默认原点为极点,$x $轴正半轴为极轴且二者单位长度相等.下文如无特殊说明均按此建立极坐标.</p>
<p>注意到若$M $在直角坐标系中坐标为$( x , y ) $,在极坐标中坐标为$( \rho , \theta ) $,若$M \ne O $自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x & = \rho \cos \theta , y & = \rho \sin \theta \\
\rho ^2 & = x ^2 + y ^2 , \theta & = \begin{cases}
\frac { \pi  } { 2  } & x = 0 \land y > 0 \\
\frac { 3 \pi  } { 2  } & x = 0 \land y < 0 \\
\arctan ( \frac { y  } { x  } ) & x \ne 0 
\end{cases} 
\end{aligned}</script><p>看到这里,聪明的你可能已经发现了不对劲:那这玩意怎么做坐标系变换呢?这玩意难道能乱乘矩阵嘛?这俩项单位都不一样欸.</p>
<p>别急,你注意到这个东西看上去不太能整什么抽象的坐标系,做的时候直接考虑转化为平面直角坐标系再做.</p>
<h6><span id="圆的极坐标方程">圆的极坐标方程</span></h6><p>显然是$\rho ^2 = r ^2 $.</p>
<p>另外,如果中心在$C ( \rho _0 , \theta _0 ) $,半径为$r $的方程咋求呢?</p>
<p>我们考虑本质是坐标系变换,想都别想先转平面直角坐标系,自然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
r ^2 & = ( \rho \cos \theta - \rho _0 \cos \theta _0 ) ^2 + ( \rho \sin \theta - \rho _0 \sin \theta _0 ) \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos \theta \cos \theta _0 - 2 \rho \rho _0 \sin \theta \sin \theta _0 \\
r ^2 & = \rho ^2 + \rho _0 ^2 - 2 \rho \rho _0 \cos ( \theta - \theta _0 ) 
\end{aligned}</script><p>另外由于$\cos \theta = \cos ( - \theta ) $,这个公式应该不难背.</p>
<h6><span id="直线的极坐标方程">直线的极坐标方程</span></h6><p>过定点$( \rho _1 , \theta _1 ) $,且倾斜角为$\alpha $:$\rho \sin ( \alpha - \theta ) = \rho _1 \sin ( \alpha - \theta _1 ) $.</p>
<p>这个咋推的呢,先换回平面直角坐标系,假设过定点$( x _1 , y _1 ) $,倾斜角为$\alpha $,我们自然有$( x - x _1 ) \sin \alpha = ( y - y _1 ) \cos \alpha $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) \sin \alpha & = ( y - y _1 ) \cos \alpha \\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) \sin \alpha & = ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \cos \alpha \\
\rho \sin ( \alpha - \theta ) & = \rho _1 \sin ( \alpha - \theta _1 ) 
\end{aligned}</script><p>其实本质还是极坐标轴变换,因为过极点的直线是显然的.</p>
<p>我们再来考虑一个:求过定点$( \rho _1 , \theta _1 ) $和$( \rho _2 , \theta _2 ) $的直线方程.</p>
<p>同理的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - x _1 ) ( y _2 - y _1 ) & = ( y - y _1 ) ( x _2 - x _1 ) \\
\\
( \rho \cos \theta - \rho _1 \cos \theta _1 ) ( \rho _2 \sin \theta _2 - \rho _1 \sin \theta _1 ) \\
& = ( \rho _2 \cos \theta _2 - \rho _1 \cos \theta _1 ) ( \rho \sin \theta - \rho _1 \sin \theta _1 ) \\
\\
\rho \rho _2 ( \cos \theta \sin \theta _2 - \cos \theta _2 \sin \theta ) \\
+ \rho \rho _1 ( - \cos \theta \sin \theta _1 + \sin \theta \cos \theta _1 ) \\
+ \rho _1 \rho _2 ( - \cos \theta _1 \sin \theta _2 + \cos \theta _2 \sin \theta _1 ) \\
& = 0 \\
\\
\rho \rho _2 \sin ( \theta _2 - \theta ) + \rho \rho _1 \sin ( \theta - \theta _1 ) + \rho _1 \rho _2 \sin ( \theta _1 - \theta _2 ) & = 0 
\end{aligned}</script><p>太丑了吧,甚至不对称?</p>
<p>(网上的资料这一步可以继续往下化简,用一些三角函数知识).</p>
<p>这个故事教给我们:极坐标系下是很难表示一些直线的.</p>
<p>那表示曲线呢?</p>
<h6><span id="圆锥曲线的极坐标方程">圆锥曲线的极坐标方程</span></h6><p>优美的来了!</p>
<p>我们注意到圆锥曲线的一种定义是:到准线距离$d $和到定点距离$r $之比为常数的曲线.令$e = \frac { r  } { d  } $.</p>
<p>假定定点为原点,极轴垂直于准线,$h $为定点到准线的距离,又设曲线上一点为$M ( \rho , \theta ) $,自然有:$r = \rho , d = h + \rho \cos \theta $.</p>
<p>于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
e & = \frac { \rho  } { h + \rho \cos \theta  } \\
he + e \rho \cos \theta & = \rho \\
\rho & = \frac { he  } { 1 - e \cos \theta  } 
\end{aligned}</script><p>值得一提的是这玩意不能将圆理解为$e = 0 $的圆锥曲线.</p>
<h5><span id="参数方程">参数方程</span></h5><p>在平面直角坐标系中,曲线上任意一点的坐标$x , y $都是某个变量$t $的函数$\begin{cases}x = f ( t ) \ y = g ( t ) \end{cases} $.</p>
<h6><span id="圆的参数方程">圆的参数方程</span></h6><p>$M ( r \cos \theta , r \sin \theta ) $,其中$\theta $是$\angle OMx $.</p>
<h6><span id="直线的参数方程">直线的参数方程</span></h6><p>$M ( x _0 + t \cos \theta , y _0 + t \sin \theta ) $,其中$\theta $是倾斜角,$t $是参数,$M _0 ( x _0 , y _0 ) $.</p>
<p>注意到$| M _0 M | = | t | $.事实上,设$\vec { e  } = ( \cos \theta , \sin \theta ) $,也就是直线的单位方向向量,则$\overrightarrow { M _0 M  } = t \vec { e  } $.</p>
<h6><span id="椭圆的参数方程">椭圆的参数方程</span></h6><p>$M ( a \cos \theta , b \sin \theta ) $,其中$\theta $称为$M $的离心角.</p>
<p>值得注意的是,这里的$\theta $并非$\angle MOx $,而是将椭圆线性变换回圆后对应点的对应圆心角.</p>
<p><strong>Example1</strong></p>
<p>在椭圆$\frac { x ^2  } { 9  } + \frac { y ^2  } { 4  } = 1 $上求一点$M $,使$M $到直线$x + 2 y - 10 = 0 $的距离最小.</p>
<p>直接令$M = ( 3 \cos \theta , 2 \sin \theta ) $,则$d = \frac { | 3 \cos \theta + 4 \sin \theta - 10 |  } { \sqrt { 5  }  } = | \sqrt { 5  } \sin ( \theta + \varphi ) - 2 \sqrt { 5  } | $,其中$\varphi = \arcsin \frac { 3  } { 5  } $.</p>
<p>于是$d _{ \min  } = \sqrt { 5  } $,此时$\sin ( \theta + \varphi ) = 1 = \sin { \frac { \pi  } { 2  }  } $,那么就有$\theta = \frac { \pi  } { 2  } - \varphi $,$\sin \theta = \cos \varphi = \frac { 4  } { 5  } , \cos \theta = \sin \varphi = \frac { 3  } { 5  } $.</p>
<p>则$M = ( \frac { 9  } { 5  } , \frac { 8  } { 5  } ) $.</p>
<p><strong>Example2</strong></p>
<p>已知椭圆$\frac { x ^2  } { 100  } + \frac { y ^2  } { 64  } = 1 $,有一内接矩阵$ABCD $($AB / / x , BC / / y $),求矩阵最大面积.</p>
<p>直接令$A = ( 10 \cos \theta , 8 \sin \theta ) $,则$S = 20 \cos \theta \times 16 \sin \theta = 160 \sin ( 2 \theta ) $,$S _{ \max  } = 160 $.</p>
<h6><span id="双曲线的参数方程">双曲线的参数方程</span></h6><p>$M ( \frac { a  } { \cos \theta  } , b \tan \theta ) = M ( a \sec \theta , b \tan \theta ) $,其中$\theta $称为$M $的离心角,通常规定$\theta \in [ 0 , 2 \pi ] \land \theta \ne \frac { \pi  } { 2  } \land \theta \ne \frac { 3 \pi  } { 2  } $.</p>
<p>其实本质也就是三角恒等式$\sec ^2 \theta = 1 + \tan ^2 \theta $.</p>
<p><strong>Example1</strong></p>
<p>圆$O : x ^2 + ( y - 2 ) ^2 = 1 $上有一点$P $,双曲线$x ^2 - y ^2 = 1 $上有一点$Q $,求$| PQ | _{ \min  } $.</p>
<p>设$Q ( \sec \theta , \tan \theta ) $,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
| OQ | ^2 & = \sec ^2 \theta + ( \tan \theta - 2 ) ^2 \\
& = \tan ^2 \theta + 1 ( \tan \theta - 2 ) ^2 \\
& = 2 ( \tan \theta - 1 ) ^2 + 3 
\end{aligned}</script><p>$| OQ | _{ \min  } = \sqrt { 3  } , | PQ | _{ \min  } = \sqrt { 3  } - 1 $.</p>
<p><strong>Example2</strong></p>
<p>求证:等轴双曲线平行于实轴的弦在两顶点所张的角均为直角.</p>
<p>设$P ( a \sec \theta , a \tan \theta ) , Q ( - a \sec \theta , a \tan \theta ) $,则$k _P = \frac { a \tan \theta  } { a \sec \theta - a  } , k _Q = \frac { a \tan \theta  } { - a \sec \theta - a  } $.注意到$k _P \cdot k _Q = - 1 $.</p>
<p><strong>Example3</strong></p>
<p>已知双曲线$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,$A , B $是双曲线同支上相异两点,线段$AB $的垂直平分线与$x $轴相交于点$P ( x _0 , 0 ) $,求证:$| x _0 | &gt; \frac { c ^2  } { a  } = \frac { a ^2 + b ^2  } { a  } $.</p>
<p>设$A ( a \sec \alpha , b \tan \alpha ) , B ( a \sec \beta , b \tan \beta ) $,则中点$M ( \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) , \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) $.</p>
<p>于是中垂线方程为$y - \frac { b  } { 2  } ( \tan \alpha + \tan \beta ) ) = - \frac { a ( \sec \alpha - \sec \beta )  } { b ( \tan \alpha - \tan \beta )  } [ x - \frac { a  } { 2  } ( \sec \alpha + \sec \beta ) ] $.</p>
<p>代入$P ( x _0 , 0 ) $,求得$x _0 = \frac { c ^2  } { 2 a  } ( \sec \alpha + \sec \beta ) $.</p>
<p>也就是要比较$| \sec \alpha + \sec \beta | $和$2 $的大小关系,注意到$A , B $同支,所以$| \sec \alpha + \sec \beta | &gt; 2 $.</p>
<h6><span id="抛物线的参数方程">抛物线的参数方程</span></h6><p>$M ( \frac { 2 p  } { \tan ^2 \theta  } , \frac { 2 p  } { \tan \theta  } ) $,其中$\theta $称为$M $的离心角,意义是该点和原点所确定直线的斜率,注意这个参数方程不能表示抛物线顶点.</p>
<p>事实上,我们可以有一个别的参数方程表达:$M ( 2 pk ^2 , 2 pk ) $,这个参数方程可以表示顶点.</p>
<p><strong>Example1</strong></p>
<p>若抛物线$\begin{cases}x = 2 pt ^2 \ y = 2 pt \end{cases} $上有不同两点$M _1 , M _2 $,所对应的参数分别是$t _1 , t _2 $,求直线$M _1 M _2 $所在直线的斜率.</p>
<p>$k _{ M _1 M _2  } = \frac { 2 pt _1 - 2 pt _2  } { 2 pt _1 ^2 - 2 pt _2 ^2  } = \frac { 1  } { t _1 + t _2  } $.</p>
<p><strong>Example2</strong></p>
<p>$A , B $是抛物线$y ^2 = 2 px $上异于顶点的两动点,且$OA \bot OB $,$AB $上有一点$M $满足$OM \bot AB $,求$M $的轨迹方程.</p>
<p>设$M ( x , y ) , A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) $,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\overrightarrow { OM  } & = ( x , y ) \\
\overrightarrow { OA  } & = ( 2 pt _1 ^2 , 2 pt _1 ) \\
\overrightarrow { OB  } & = ( 2 pt _2 ^2 , 2 pt _2 ) \\
\overrightarrow { AB  } & = ( 2 p ( t _2 ^2 - t _1 ^2 ) , 2 p ( t _2 - t _1 ) ) 
\end{aligned}</script><p>因为$\overrightarrow { OA  } \bot \overrightarrow { OB  } $,所以$( 2 pt _1 t _2 ) ^2 + ( 2 p ) ^2 t _1 t _2 = 0 $,$t _1 t _2 = - 1 $.</p>
<p>因为$\overrightarrow { AB  } \bot \overrightarrow { OM  } $,又有$k _{ AB  } = \frac { 1  } { t _1 + t _2  } $,所以$k _{ OM  } = - ( t _1 + t _2 ) $,$\frac { y  } { x  } = - ( t _1 + t _2 ) $.</p>
<p>接下来咋做捏?注意到我们好像忘记了$ABM $三点共线的性质,拿向量做这个东西.</p>
<p>$\overrightarrow { AM  } = ( x - 2 pt _1 ^2 , y - 2 pt _1 ) , \overrightarrow { MB  } = ( 2 pt _2 ^2 - x , 2 pt _2 - y ) $.</p>
<p>那么有$( x - 2 pt _1 ^2 ) ( 2 pt _2 - y ) = ( 2 pt _2 ^2 - x ) ( y - 2 pt _1 ) $.</p>
<p>化简得到$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p>等一下,这咋想到的啊.</p>
<p>首先注意到我们有两个点$A , B $,自然要设出它们的参数方程.然后呢?然后我们发现最后$M $一定和$t _1 , t _2 $有关.但是我们要求的是$M $的方程,其中不能带有$t _1 , t _2 $,因此考虑把$M $的坐标设出来,再用这个坐标表示$t _1 , t _2 $,表示不出来表示$t _1 t _2 , t _1 + t _2 $也可以,然后消掉即可.</p>
<p>当然这题还有一个做法,注意到$M $一定在以$| OA | $为直径的圆上,$B $同理,这两个圆的方程分别为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^2 + y ^2 - 2 pt _1 ^2 x - 2 pt _1 y & = 0 \\
x ^2 + y ^2 - 2 pt _2 ^2 x - 2 pt _2 y & = 0 
\end{aligned}</script><p>也就是说,$t _1 , t _2 $是同一个方程的两个根,根据韦达定理自然有$t _1 t _2 = \frac { - ( x ^2 + y ^2 )  } { 2 px  } = - 1 $,于是直接有$x ^2 + y ^2 - 2 px = 0 $.</p>
<p>还没完,注意到$O $一定是一个根,要去掉,所以答案就是$x ^2 + y ^2 - 2 px = 0 ( x \ne 0 ) $.</p>
<p><strong>Example3</strong></p>
<p>已知$A , B , C $是抛物线$y ^2 = 2 px ( p &gt; 0 ) $上的三个点,且$BC $与$x $轴垂直,直线$AB $和$AC $分别与抛物线的轴交于$D , E $两点,求证:抛物线的顶点平分$DE $.</p>
<p>设$A ( 2 pt _1 ^2 , 2 pt _1 ) , B ( 2 pt _2 ^2 , 2 pt _2 ) , C ( 2 pt _2 ^2 , - 2 pt _2 ) $,注意到$AB : y - 2 pt _1 = \frac { 1  } { t _1 + t _2  } ( x - 2 pt _1 ^2 ) $,$AC : t - 2 pt _1 = \frac { 1  } { t _1 - t _2  } ( x - 2 pt _1 ^2 ) $.</p>
<p>可求得$D ( - 2 pt _1 t _2 , 0 ) , E ( 2 pt _1 t _2 , 0 ) $,于是得证.</p>
<h5><span id="蒙日圆">蒙日圆</span></h5><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/591258689">https://zhuanlan.zhihu.com/p/591258689</a></p>
<h6><span id="定义">定义</span></h6><p>过圆锥曲线外一点作两条互相垂直的切线,那么这一点的轨迹是一个圆,这个圆被称为蒙日圆,又叫外准圆.</p>
<h6><span id="方程">方程</span></h6><p><strong>椭圆的蒙日圆方程</strong></p>
<p>设椭圆为$\frac { x ^2  } { a ^2  } + \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 + b ^2 $.</p>
<p>证明:直接设椭圆上一点就可以导出.</p>
<p><strong>双曲线的蒙日圆方程</strong></p>
<p>设双曲线为$\frac { x ^2  } { a ^2  } - \frac { y ^2  } { b ^2  } = 1 $,其蒙日圆方程为$x ^2 + y ^2 = a ^2 - b ^2 $.</p>
<p>证明:其实注意到椭圆的证明中设$b $是复数也是成立的,自然得证双曲线.</p>
<p>我知道你在想啥,你在想有没有可能一个点向双曲线能做出超过两条切线.事实上根据渐近线的原理这是不可能滴.</p>
<p><strong>抛物线的蒙日圆方程</strong></p>
<p>设抛物线$y ^2 = 2 px $,其蒙日圆方程为$x = - \frac { p  } { 2  } $.</p>
<p>有一说一,直线是半径无穷大的圆.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">高等代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<ul>
<li><a href="#抽象代数">抽象代数</a><ul>
<li><a href="#群">群</a><ul>
<li><a href="#定义">定义</a></li>
<li><a href="#基本概念和事实">基本概念和事实</a><ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul>
</li>
<li><a href="#子群">子群</a><ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#example8">Example8</a></li>
</ul>
</li>
<li><a href="#同态和同构">同态和同构</a></li>
<li><a href="#群的实例">群的实例</a><ul>
<li><a href="#全变换群对称群与交错群">全变换群,对称群与交错群</a></li>
<li><a href="#一般线性群">一般线性群</a></li>
<li><a href="#克莱因四元群">克莱因四元群</a></li>
<li><a href="#循环群">循环群</a></li>
</ul>
</li>
<li><a href="#相反群">相反群</a><ul>
<li><a href="#example1-2">Example1</a></li>
</ul>
</li>
<li><a href="#陪集">陪集</a></li>
<li><a href="#群作用">群作用</a><ul>
<li><a href="#cayley定理">Cayley定理</a></li>
<li><a href="#burnside引理">Burnside引理</a></li>
<li><a href="#p-群">$p$-群</a><ul>
<li><a href="#example1-3">Example1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#正规子群">正规子群</a><ul>
<li><a href="#正规子群的判定定理">正规子群的判定定理</a><ul>
<li><a href="#example1-4">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul>
</li>
<li><a href="#正规子群与同态">正规子群与同态</a></li>
<li><a href="#同态基本定理">同态基本定理</a></li>
<li><a href="#第一同构定理">第一同构定理</a></li>
<li><a href="#第二同构定理">第二同构定理</a></li>
<li><a href="#交换化">交换化</a><ul>
<li><a href="#example1-5">Example1</a></li>
<li><a href="#example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#群的直和与直积">群的直和与直积</a><ul>
<li><a href="#直和">直和</a></li>
<li><a href="#半直积">半直积</a><ul>
<li><a href="#example1-6">Example1</a></li>
<li><a href="#example2二面体群">Example2(二面体群)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#环">环</a><ul>
<li><a href="#子环">子环</a></li>
<li><a href="#理想">理想</a></li>
<li><a href="#同态和同构-1">同态和同构</a><ul>
<li><a href="#同态基本定理-1">同态基本定理</a></li>
<li><a href="#第一同构定理-1">第一同构定理</a></li>
<li><a href="#第二同构定理-1">第二同构定理</a></li>
</ul>
</li>
<li><a href="#整环">整环</a><ul>
<li><a href="#特征">特征</a></li>
<li><a href="#整除性">整除性</a></li>
<li><a href="#唯一分解整环ufd">唯一分解整环(UFD)</a></li>
<li><a href="#主理想整环pid">主理想整环(PID)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#多项式环">多项式环</a><ul>
<li><a href="#一元多项式环">一元多项式环</a></li>
<li><a href="#多元多项式环">多元多项式环</a></li>
<li><a href="#不可约多项式">不可约多项式</a><ul>
<li><a href="#本原多项式">本原多项式</a></li>
<li><a href="#一个判定不可约的算法">一个判定不可约的算法</a></li>
<li><a href="#不可约多项式上的扩域">不可约多项式上的扩域</a></li>
</ul>
</li>
<li><a href="#对称多项式">对称多项式</a><ul>
<li><a href="#牛顿公式">牛顿公式</a></li>
</ul>
</li>
<li><a href="#结式">结式</a></li>
<li><a href="#判别式">判别式</a></li>
</ul>
</li>
<li><a href="#域">域</a><ul>
<li><a href="#分式域">分式域</a></li>
<li><a href="#子域">子域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#线性代数">线性代数</a><ul>
<li><a href="#矩阵引入">矩阵引入</a><ul>
<li><a href="#矩阵运算">矩阵运算</a></li>
<li><a href="#分块矩阵">分块矩阵</a></li>
</ul>
</li>
<li><a href="#线性方程组">线性方程组</a><ul>
<li><a href="#系数矩阵和增广矩阵">系数矩阵和增广矩阵</a></li>
<li><a href="#矩阵的初等行变换">矩阵的初等行变换</a></li>
<li><a href="#阶梯形矩阵">阶梯形矩阵</a><ul>
<li><a href="#简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</a></li>
</ul>
</li>
<li><a href="#解线性方程组">解线性方程组</a><ul>
<li><a href="#存在与唯一性定理">存在与唯一性定理</a></li>
</ul>
</li>
<li><a href="#矩阵方程">矩阵方程</a></li>
<li><a href="#齐次线性方程组">齐次线性方程组</a></li>
</ul>
</li>
<li><a href="#线性空间">线性空间</a><ul>
<li><a href="#相关运算">相关运算</a><ul>
<li><a href="#直积">直积</a></li>
<li><a href="#直和-1">直和</a></li>
<li><a href="#叉乘">叉乘</a></li>
</ul>
</li>
<li><a href="#线性无关与线性相关">线性无关与线性相关</a></li>
<li><a href="#子空间">子空间</a><ul>
<li><a href="#向量的线性组合">向量的线性组合</a></li>
<li><a href="#线性映射">线性映射</a></li>
<li><a href="#基和维数">基和维数</a></li>
</ul>
</li>
<li><a href="#可逆矩阵">可逆矩阵</a><ul>
<li><a href="#初等矩阵">初等矩阵</a></li>
<li><a href="#求解逆矩阵">求解逆矩阵</a><ul>
<li><a href="#example1lu分解">Example1(LU分解)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#核与像与秩">核与像与秩</a><ul>
<li><a href="#sylvester秩不等式">Sylvester秩不等式</a></li>
<li><a href="#frobenius秩不等式">Frobenius秩不等式</a></li>
</ul>
</li>
<li><a href="#对偶空间">对偶空间</a></li>
<li><a href="#直和分解与分块矩阵">直和分解与分块矩阵</a></li>
<li><a href="#基的变换">基的变换</a><ul>
<li><a href="#矩阵的共轭相似">矩阵的共轭(相似)</a></li>
<li><a href="#矩阵的相抵">矩阵的相抵</a></li>
</ul>
</li>
<li><a href="#商空间">商空间</a><ul>
<li><a href="#同态基本定理-2">同态基本定理</a></li>
<li><a href="#第一同构定理-2">第一同构定理</a></li>
<li><a href="#第二同构定理-2">第二同构定理</a></li>
<li><a href="#旗">旗</a></li>
<li><a href="#不变子空间">不变子空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#行列式">行列式</a><ul>
<li><a href="#置换排列">置换(排列)</a></li>
<li><a href="#交错形式">交错形式</a></li>
<li><a href="#定义-1">定义</a></li>
<li><a href="#余子式与代数余子式">余子式与代数余子式</a></li>
<li><a href="#行列式定向">行列式定向</a></li>
<li><a href="#克拉默cramer法则">克拉默(Cramer)法则</a></li>
<li><a href="#一些特殊行列式">一些特殊行列式</a><ul>
<li><a href="#置换矩阵">置换矩阵</a></li>
<li><a href="#上三角矩阵">上三角矩阵</a></li>
<li><a href="#分块上三角矩阵">分块上三角矩阵</a></li>
<li><a href="#范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</a></li>
<li><a href="#一类分块矩阵">一类分块矩阵</a></li>
</ul>
</li>
<li><a href="#特征多项式">特征多项式</a></li>
<li><a href="#cayley-hamilton定理">Cayley-Hamilton定理</a></li>
<li><a href="#矩阵的迹">矩阵的迹</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#binet-cauchy定理">Binet-Cauchy定理</a></li>
<li><a href="#特征值与特征向量">特征值与特征向量</a></li>
<li><a href="#极小多项式">极小多项式</a></li>
<li><a href="#同步对角化">同步对角化</a></li>
<li><a href="#上三角化">上三角化</a></li>
<li><a href="#广义特征子空间">广义特征子空间</a></li>
<li><a href="#特殊矩阵的特征值">特殊矩阵的特征值</a><ul>
<li><a href="#example-1">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#双线性形式">双线性形式</a><ul>
<li><a href="#线性映射-1">线性映射</a></li>
<li><a href="#非退化形式">非退化形式</a></li>
<li><a href="#伴随映射">伴随映射</a></li>
<li><a href="#分类问题">分类问题</a></li>
<li><a href="#二次型">二次型</a><ul>
<li><a href="#实二次型">实二次型</a></li>
<li><a href="#惯性sylvester定理">惯性(Sylvester)定理</a></li>
</ul>
</li>
<li><a href="#辛空间">辛空间</a><ul>
<li><a href="#达布定理">达布定理</a></li>
</ul>
</li>
<li><a href="#回看对偶空间">回看对偶空间</a><ul>
<li><a href="#双重对偶">双重对偶</a></li>
<li><a href="#核余核与对偶映射">核,余核与对偶映射</a></li>
<li><a href="#像自对偶">像自对偶</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#实内积空间">实内积空间</a><ul>
<li><a href="#勾股定理">勾股定理</a></li>
<li><a href="#柯西不等式">柯西不等式</a></li>
<li><a href="#三角不等式">三角不等式</a></li>
<li><a href="#距离相关">距离相关</a></li>
<li><a href="#正交向量族">正交向量族</a></li>
<li><a href="#gram-schmidt-正交化">Gram-Schmidt 正交化</a><ul>
<li><a href="#example1ru分解">Example1(RU分解)</a></li>
<li><a href="#example2legendre多项式">Example2(Legendre多项式)</a></li>
</ul>
</li>
<li><a href="#正交算子">正交算子</a></li>
<li><a href="#正交补空间">正交补空间</a></li>
<li><a href="#投影矩阵">投影矩阵</a></li>
<li><a href="#自伴算子">自伴算子</a><ul>
<li><a href="#实sylvester-判准">(实)Sylvester 判准</a></li>
<li><a href="#实正定矩阵的二次根">(实)正定矩阵的二次根</a><ul>
<li><a href="#example1-7">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
</ul>
</li>
<li><a href="#极分解">极分解</a></li>
<li><a href="#最小二乘法">最小二乘法</a></li>
</ul>
</li>
<li><a href="#奇异值分解">奇异值分解</a></li>
<li><a href="#moore-penrose-广义逆">Moore-Penrose 广义逆</a></li>
<li><a href="#极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</a></li>
<li><a href="#perron-frobenius定理">Perron-Frobenius定理</a><ul>
<li><a href="#collatz-wielandt公式">Collatz-Wielandt公式</a></li>
<li><a href="#perron定理">Perron定理</a></li>
</ul>
</li>
<li><a href="#实正交变换的标准型">实正交变换的标准型</a><ul>
<li><a href="#欧拉角">欧拉角</a></li>
<li><a href="#四元数">四元数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#复内积空间">复内积空间</a><ul>
<li><a href="#共轭空间">共轭空间</a></li>
<li><a href="#复半双线性形式">(复)半双线性形式</a></li>
<li><a href="#伴随映射-1">伴随映射</a></li>
<li><a href="#hermite形式">Hermite形式</a><ul>
<li><a href="#正规线性映射">正规线性映射</a></li>
<li><a href="#二次型-1">二次型</a></li>
</ul>
</li>
<li><a href="#复内积空间-1">复内积空间</a><ul>
<li><a href="#酉变换">酉变换</a></li>
<li><a href="#正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</a></li>
<li><a href="#相关实内积空间定理推广">相关实内积空间定理推广</a></li>
<li><a href="#复矩阵范数实例">复矩阵范数实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#模">模</a><ul>
<li><a href="#自由模">自由模</a><ul>
<li><a href="#example1非自由模">Example1(非自由模)</a></li>
</ul>
</li>
<li><a href="#线性映射和模结构">线性映射和模结构</a></li>
<li><a href="#主理想环上的有限生成模">主理想环上的有限生成模</a><ul>
<li><a href="#自由模与其子模">自由模与其子模</a></li>
<li><a href="#smith标准型">Smith标准型</a></li>
<li><a href="#结构定理">结构定理</a></li>
<li><a href="#有限生成交换群的分类">有限生成交换群的分类</a></li>
</ul>
</li>
<li><a href="#有理标准型">有理标准型</a><ul>
<li><a href="#example1-8">Example1</a></li>
</ul>
</li>
<li><a href="#jordan标准型">Jordan标准型</a><ul>
<li><a href="#加性jordan-chevalley分解">加性Jordan-Chevalley分解</a></li>
<li><a href="#乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#张量积">张量积</a><ul>
<li><a href="#张量积与直和">张量积与直和</a></li>
<li><a href="#kronecker积">Kronecker积</a></li>
<li><a href="#张量积与对偶空间">张量积与对偶空间</a></li>
<li><a href="#张量代数">张量代数</a><ul>
<li><a href="#另一种构造">另一种构造</a></li>
<li><a href="#又看对偶空间">又看对偶空间</a><ul>
<li><a href="#example1-9">Example1</a></li>
<li><a href="#example2-4">Example2</a></li>
</ul>
</li>
<li><a href="#简单应用">简单应用</a></li>
</ul>
</li>
<li><a href="#域的变换">域的变换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3><p>三个柱子,$n $个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T _n $表示答案,显然$T _0 = 0 , T _1 = 1 $.</p>
<p>而我们一定可以找到一种方案,使得前$n - 1 $个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把$n - 1 $个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:$T _n \leq 2 T _{ n - 1  } + 1 $.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:$2 T _{ n - 1  } + 1 \leq T _n $.于是有$T _n = 2 T _{ n - 1  } + 1 $.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4><p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4><p>考虑设$T _n $为n个圆盘时的最小操作次数.假设已知$T _{ n - 1  } $,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T _{ n  } = 3 T _{ n - 1  } + 2 , T _0 = 0 $.</p>
<p>考虑如何求该式子的封闭形式,令$W _n = T _n + 1 $,显然有$W _n = 3 W _{ n - 1  } , W _0 = 1 $,显然$W _n = 3 ^n $,有$T _n = 3 ^n - 1 $.</p>
<p>注意到$T _n $刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4><p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2 ^n - 1 $.</p>
<h4><span id="solution-2">Solution 2</span></h4><p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4><p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4><p>令$Q _n $为将n个圆盘从A移动到B的最小操作次数,令$R _n $为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q _0 = 0 , R _0 = 0 $.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q _n $的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,$R _n $的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q _n = 2 R _{ n - 1  } + 1 , 1 \leq n $.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R _n = R _{ n - 1  } + 1 + Q _{ n - 1  } + 1 + R _{ n - 1  } = Q _n + Q _{ n - 1  } + 1 , 1 \leq n $.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4><p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4><p>a.仍然令$T _n $为n对圆盘的最小操作次数,显然$T _n = 2 T _{ n - 1  } + 2 , T _0 = 0 $,可解得$T _n = 2 ^{ n + 1  } - 2 $.</p>
<p>b.令$Q _n $为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现$Q _n = T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } + 1 + T _{ n - 1  } = 4 T _{ n - 1  } + 3 = 2 ^{ n + 2  } - 5 $.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q _n $就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4><p>类似Problem11,但第$i $大的圆盘有$k _i $个.</p>
<h4><span id="solution-5">Solution 5</span></h4><p>无区别,只是$T _n = 2 T _{ n - 1  } + k _n , T _0 = 0 $.</p>
<p>如果求封闭形式的话,显然有$T _n = \sum _{ i = 1  } ^n 2 ^{ n - i  } k _i $.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3><p>在上述问题中，我们已经有了以下式子：</p>
<p>$T _n = 2 T _{ n - 1  } + 1 , n &gt; 0 , T _0 = 0 $.</p>
<p>如果$n $很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出$T _n $的方法.</p>
<p>换句话说，我们想要把$T _n $表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4><h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5><p>解递归式:$Q _n = \begin{cases}\alpha &amp; n = 0 \ \beta &amp; n = 1 \ \frac { ( 1 + Q _{ n - 1  } )  } { Q _{ n - 2  }  } &amp; n &gt; 1 \end{cases} $,保证$\forall n , Q _n &gt; 0 $.</p>
<h5><span id="solution">Solution</span></h5><p>注意到$Q _2 = \frac { \beta + 1  } { \alpha  } , Q _3 = \frac { \beta + \alpha + 1  } { \beta \alpha  } , Q _4 = \frac { 1 + \alpha  } { \beta  } , Q _5 = \alpha , Q _6 = \beta $.</p>
<p>显然该递归式存在长度为$5 $的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4><p>观察T序列的前几项，可以发现似乎有$T _n = 2 ^n - 1 $.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n = 0 $成立，显然可验证.</p>
<p>2.若该公式对$n = k $时成立，那该公式必然对$n = k + 1 $成立.</p>
<p>因为有$T _{ k + 1  } = 2 T _k + 1 = 2 \times 2 ^k + 2 - 1 = 2 ^{ k + 1  } - 1 $.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5><p>求证:$\prod _{ i = 1  } ^n x _i \leq ( \frac { \sum _{ i = 1  } ^n x _i  } { n  } ) ^n , \forall i \in N _+ , 1 \leq i \leq n , 0 \leq x _i $.</p>
<h5><span id="solution">Solution</span></h5><p>使用反向归纳法.</p>
<p>1.$n = 2 $时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n = k $时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A _1 = \sqrt [k ] { \prod _{ i = 1  } ^k x _i  } , B _1 = \sqrt [k ] { \prod _{ i = k + 1  } ^{ 2 k  } x _i  } , A _2 = ( \frac { \sum _{ i = 1  } ^k x _i  } { k  } ) , B _2 = ( \frac { \sum _{ i = k + 1  } ^{ 2 k  } x _i  } { k  } ) $,显然有$A _1 \leq A _2 , B _1 \leq B _2 $.</p>
<p>同时有$( \frac { A _2 + B _2  } { 2  } ) \geq \sqrt { A _2 B _2  } \geq \sqrt { A _1 B _1  } $.</p>
<p>3.若该式子对$n = k $时成立,则该式子对$n = k - 1 $的时候也成立.</p>
<p>令$x _k = \frac { \sum _{ i = 1  } ^{ k - 1  } x _i  } { k - 1  } $,有$x _k \prod _{ i = 1  } ^{ k - 1  } x _i \leq ( x _k ) ^k $.</p>
<p>则显然$n = k - 1 $时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4><p>考虑令$U _n = T _n + 1 $,显然有:$T _n + 1 = 2 T _{ n - 1  } + 2 $.即$U _n = 2 U _{ n - 1  } $,显然$U _n = 2 ^n $,则$T _n = 2 ^n - 1 $.</p>
<p>这个做法可以做掉所有形如$a _{ n + 1  } = pa _n + q $的递归式.我们有:</p>
<script type="math/tex; mode=display">
a _{ n + 1  } + \frac { q  } { p - 1  } = p ( a _n + \frac { q  } { p - 1  } )</script><p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4><p>考虑递归式$a _n T _n = b _n T _{ n - 1  } + c _n $.如果我们能找到一个不为0的求和因子$s _n $并满足$s _n b _n = s _{ n - 1  } a _{ n - 1  } $.那么我们两面同时乘以$s _n $,显然有：$s _n a _n T _n = s _{ n - 1  } a _{ n - 1  } T _{ n - 1  } + c _n s _n $.</p>
<p>令$S _n = s _n a _n T _n $.显然有$S _n = s _0 a _0 T _0 + \sum _{ i = 1  } ^n s _i c _i $,则$T _n = \frac { S _n  } { s _n a _n  } $.</p>
<p>而我们也会发现$s _n = \frac { \prod _{ i = 1  } ^{ n - 1  } a _i  } { \prod _{ i = 1  } ^n b _i  } $.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5><p>结论:排序$n $个数时,其期望复杂度满足:</p>
<script type="math/tex; mode=display">
C _n = \begin{cases}
0 & n = 0 , 1 \\
n + 1 + \frac { 2  } { n  } \sum _{ i = 0  } ^{ n - 1  } C _k & n > 1 
\end{cases}</script><p>不妨考虑两边同时乘以$n $,有 $nC _n = n ^2 + n + 2 \sum _{ i = 0  } ^{ n - 1  } C _i , n &gt; 1 $ .</p>
<p>显然也有$( n - 1 ) C _{ n - 1  } = ( n - 1 ) ^2 + n - 1 + 2 \sum _{ i = 0  } ^{ n - 2  } C _i , n &gt; 2 $.</p>
<p>二式相消,有$nC _n - ( n - 1 ) C _{ n - 1  } = 2 n + 2 C _{ n - 1  } , n &gt; 2 $.</p>
<p>而同时有$C _2 = 3 $.即:$nC _n = ( n + 1 ) C _{ n - 1  } + 2 n , n &gt; 2 $,可以使用转化和式的方法,两边乘以$\frac { 1  } { n ( n + 1 )  } $解决.</p>
<h5><span id="example2">Example2</span></h5><p>已知$a _1 = 1 $,$a _n = \sqrt { S _n  } + \sqrt { S _{ n - 1  }  } $,求$a _n $.</p>
<p>注意到$a _n = S _n - S _{ n - 1  } $,则有$\sqrt { S _n  } - \sqrt { S _{ n - 1  }  } = 1 $,于是$\sqrt { S _n  } = n $,$S _n = n ^2 $,$a _n = 2 n - 1 $.</p>
<h4><span id="成套方法">成套方法</span></h4><p>如果我们有</p>
<p>\alpha &amp; n=1\\</p>
<p>2f(\frac n 2)+\beta &amp; n=2k,k\in \mathbb{N_+}\\</p>
<p>2f(\frac {n-1}2)+\gamma &amp;n=2k+1,k\in \mathbb{N_+}</p>
<p>\end{cases}</p>
<p>其中$n = 2 ^m + l $且$2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>该如何求出$f ( n ) $的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有$f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n ) \gamma $,而有$A 、 B 、 C $互不影响且$\alpha \beta \gamma $与$ABC $无关.</p>
<p>那无论$\beta $和$\gamma $的取值如何,$A ( n ) $都不会受到影响,我们考虑$\beta = \gamma = 0 $的特殊情况,此时显然有$A ( n ) = 2 ^m $.</p>
<p>接下来,我们考虑取$\alpha \beta \gamma $的特殊值,去得到ABC之间的关系.</p>
<p>例如，当$f ( n ) = 1 $时，由递推式可知$\alpha = 1 , \beta = \gamma = - 1 $,那么有$A ( n ) - B ( n ) - C ( n ) = f ( n ) = 1 $.</p>
<p>同理，$f ( n ) = n $时，可知$\alpha = 1 , \beta = 0 , \gamma = 1 $,此时有$A ( n ) + C ( n ) = f ( n ) = n $.</p>
<p>显然可以通过解方程求得$B ( n ) $和$C ( n ) $.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC $互不影响且$\alpha \beta \gamma $与$ABC $无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4><p>一个常系数的$k $阶线性递推关系形如:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = P _n + \sum _{ i = 1  } ^k c _i a _{ n - i  } , n & \geq k \\
a _0 & = C _0 , a _1 & = C _1 , . . . , a _{ k - 1  } & = C _{ k - 1  } 
\end{aligned}</script><p>当$P = 0 $时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5><p>我们称方程$r ^k = \sum _{ i = 1  } ^k c _i r ^{ k - i  } $是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5><p>若其特征方程有两个不同的根$r _1 $和$r _2 $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n $.</p>
<p>若其特征方程有两个相同的根$r $,那么存在两个常数$\alpha _1 $和$\alpha _2 $,满足$a _n = \alpha _1 r ^n + \alpha _2 nr ^n $.</p>
<p>先考虑前者的证明,首先考虑对于$n = 0 $或者$n = 1 $的情况,我们考虑求出一组$\alpha _1 $和$\alpha _2 $来满足:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 + \alpha _2 \\
C _1 & = \alpha _1 r _1 + \alpha _2 r _2 
\end{aligned}</script><p>若$r _1 \ne r _2 $,可以解得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha _1 & = \cfrac { C _1 - C _0 r _2  } { r _1 - r _2  } \\
\alpha _2 & = C _0 - \alpha _1 
\end{aligned}</script><p>接下来考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r _1 ^{ n - 1  } + \alpha _2 r _2 ^{ n - 1  } ) + c _2 ( \alpha _1 r _1 ^{ n - 2  } + \alpha _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 ( c _1 r _1 ^{ n - 1  } + c _2 r _1 ^{ n - 2  } ) + \alpha _2 ( c _1 r _2 ^{ n - 1  } + c _2 r _2 ^{ n - 2  } ) \\
& = \alpha _1 r _1 ^n + \alpha _2 r _2 ^n 
\end{aligned}</script><p>接下来考虑后者,首先我们有$\Delta = c _1 ^2 + 4 c _2 = 0 $,考虑初始条件:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C _0 & = \alpha _1 \\
C _1 & = \alpha _1 r + \alpha _2 r \\

\end{aligned}</script><p>接下来我们考虑数学归纳:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _n & = c _1 a _{ n - 1  } + c _2 a _{ n - 2  } \\
& = c _1 ( \alpha _1 r ^{ n - 1  } + \alpha _2 nr ^{ n - 1  } - \alpha _2 r ^{ n - 1  } ) + c _2 ( \alpha _1 r ^{ n - 2  } + \alpha _2 nr ^{ n - 2  } - 2 \alpha _2 r ^{ n - 2  } ) \\
& = a _n - c _1 \alpha _2 r ^{ n - 1  } - 2 c _2 \alpha _2 r ^{ n - 2  } 
\end{aligned}</script><p>我们接下来只需证明$c _1 r + 2 c _2 = 0 $即可.根据方程,不难发现$r = \cfrac { c _1  } { 2  } $,根据$\Delta = 0 $,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5><p>直接在复数域上定义$f _k ( x ) = \{ n ^k x ^n \} _{ n = 0  } ^\infty $,此时我们规定$0 ^0 = 1 $.特别地,当$x = 0 $的时候,定义$f _k ( x ) $的第$k $项是$1 $,其余项是$0 $.在此基础上定义线性映射$T : ( a _n ) _{ n = 0  } ^\infty \mapsto ( a _{ n + 1  } ) _{ n = 0  } ^\infty $,立刻见到:$( T - x ) ^{ k + 1  } f _k ( x ) = 0 , ( T - x ) ^k f _k ( x ) \ne 0 $.原因只需简单数学归纳.而此还可以引出$f _0 ( x ) , f _1 ( x ) , \cdots $线性无关.</p>
<p>在此基础上观察线性递推$a _{ n + d  } = c _{ d - 1  } a _{ n + d - 1  } + \cdots + c _0 a _n $,不妨取$G ( x ) = x ^d - c _{ d - 1  } x ^{ d - 1  } - \cdots - c _0 $,立刻应当见到如果$a $是$G $的根并且重数为$e ( a ) $,那么$f _{ 0  } ( x ) , \cdots , f _{ e ( a ) - 1  } ( a ) $都在$\ker f ( T ) $中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如$\sum _j w _i f _i ( y ) = \sum _j w _j f _j ( x ) $的情况,此时对右边直接操作若干次$( T - x ) $就可以把右边全部消成$0 $,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于$n $的多项式右边的$( T - x ) $是不会改变左边这边的每一个位置多项式的$\deg $,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6><p>我们都知道矩阵加速:也就是$\vec { x  } _{ k + 1  } = A \vec { x  } $,$\vec { x  } _{ n  } = A ^n \vec { x  } _0 $.而我们又知道CH定理:$p ( A ) = 0 $,我们用多项式取膜,有$A ^n = p ( A ) F ( A ) + G ( A ) = G ( A ) $,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3><p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是$2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 , 9 $.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有$J ( 2 n ) = 2 J ( n ) - 1 $;当人数是奇数时,我们杀掉一号,然后有$J ( 2 n + 1 ) = 2 J ( n ) + 1 $.</p>
<p>整理得到:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 1 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>仍然可以使用数学归纳，如果令$n = 2 ^m + l 且 2 ^m \leq n &lt; 2 ^{ m + 1  } $.</p>
<p>有$J ( n ) = 2 l + 1 $.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从$0 $开始编号:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
0 & n = 1 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 1 , k \in \mathbb { N _+  } 
\end{cases}</script><p>这下相信$J ( n ) $是多少就很显然了,将$n $写成二进制的形式,这个就相当于把首位$1 $抹去然后在末尾加个$0 $.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4><p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4><p>显然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
2 & n = 2 \\
1 & n = 3 \\
2 J ( \frac { n  } { 2  } ) - 1 & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 1 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>从$0 $开始编号,自然有:</p>
<script type="math/tex; mode=display">
J ( n ) = \begin{cases}
1 & n = 2 \\
0 & n = 3 \\
2 J ( \frac { n  } { 2  } ) & n = 2 k + 2 , k \in \mathbb { N _+  } \\
2 J ( \frac { n - 1  } { 2  } ) + 2 & n = 2 k + 3 , k \in \mathbb { N _+  } 
\end{cases}</script><p>显然$J ( n ) $也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2><h3><span id="和式的基本运算">和式的基本运算</span></h3><p>分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ca _i = c \sum _{ i \in S  } a _i</script><p>一般分配律:</p>
<script type="math/tex; mode=display">
\sum _{ i  } \sum _{ j  } a _{ i  } b _j = ( \sum _{ i  } a _i ) ( \sum _j b _j )</script><p>结合律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } ( a _i + b _i ) = \sum _{ i \in S  } a _i + \sum _{ i \in S  } b _i</script><p>交换律:</p>
<script type="math/tex; mode=display">
\sum _{ i \in S  } a _i = \sum _{ p ( i ) \in S  } a _{ p ( i )  }</script><p>交换求和顺序:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i  } \sum _{ j  } a _{ i , j  } [ P ( i , j ) ] & = \sum _{ j  } \sum _{ i  } a _{ i , j  } [ P ( i , j ) ] \\
\sum _{ i = 1  } ^n \sum _{ j = i  } ^n a _{ i , j  } & = \sum _{ j = 1  } ^n \sum _{ i = 1  } ^j a _{ i , j  } 
\end{aligned}</script><h3><span id="和式的封闭形式">和式的封闭形式</span></h3><h4><span id="交换顺序法">交换顺序法</span></h4><h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ( ai + b ) & = \sum _{ i = 0  } ^n ( a ( n - i ) + b ) \\
2 S _n & = \sum _{ i = 0  } ^n ( an + 2 b ) & = an ( n + 1 ) + 2 b ( n + 1 ) \\
S _n & = ( n + 1 ) ( \frac { an  } { 2  } + b ) 
\end{aligned}</script><h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5><p>令$S = \sum _{ 1 \leq i &lt; j \leq n  } ( a _j - a _i ) ( b _j - b _i ) = \sum _{ 1 \leq j &lt; i \leq n  } ( a _j - a _i ) ( b _j - b _i ) $.</p>
<p>考虑恒等式$[ 1 \leq j &lt; i \leq n ] + [ 1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq n ] $.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 S & = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) - \sum _{ 1 \leq i = j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = \sum _{ 1 \leq i , j \leq n  } ( a _j - a _i ) ( b _j - b _i ) \\
& = 2 n \sum _{ i = 1  } ^n a _i b _i - 2 ( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) \\
( \sum _{ i = 1  } ^n a _i ) ( \sum _{ j = 1  } ^n b _j ) & = n \sum _{ i = 1  } ^n a _i b _i - \sum _{ 1 \leq i < j \leq n  } ( a _j - a _i ) ( b _j - b _i ) 
\end{aligned}</script><p>显然有以下式子:</p>
<p>(\sum_{i=1}^na_i)(\sum_{j=1}^nb_j)\geq n\sum_{i=1}^na_ib_i，\forall i&lt;j，a_i\leq a_j且b_i\geq b_j\\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5><p>证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 & = ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - ( \sum _{ i = 1  } ^n a _i b _i ) ^2 \\

\end{aligned}</script><p>有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ 1 \leq j < k \leq n  } ( a _j b _k - a _k b _j ) ^2 \\
2 S _n & = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j b _k - a _k b _j ) ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n ( a _j ^2 b _k ^2 - 2 a _j a _k b _j b _k + a _k ^2 b _j ^2 ) \\
& = 2 ( \sum _{ i = 1  } ^n a _i ^2 ) ( \sum _{ i = 1  } ^n b _i ^2 ) - 2 ( \sum _{ i = 1  } ^n a _i b _i ) ^2 
\end{aligned}</script><h4><span id="扰动法">扰动法</span></h4><h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n ax ^i \\
& = a + \sum _{ i = 1  } ^n ax ^i \\
& = a + x \sum _{ i = 0  } ^{ n - 1  } ax ^i \\
& = a + xS _{ n - 1  } 
\end{aligned}</script><p>而$S _{ n - 1  } + ax ^n = S _n = a + xS _{ n - 1  } $,有$S _n + ax ^{ n + 1  } = a + xS _n , S _n = a \frac { x ^{ n + 1  } - 1  } { x - 1  } $，其中$x \ne 1 $.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5><p>如果直接对该公式使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 0  } ^n i ^2 & = \sum _{ i = 0  } ^{ n - 1  } i ^2 + n ^2 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^2 + n ^2 \\
& = S _n - 2 \sum _{ i = 1  } ^n i + n + n ^2 
\end{aligned}</script><p>我们无法得到$S _n $的封闭形式,但我们发现我们得到了$\sum _{ i = 1  } ^n i $的封闭形式.</p>
<p>那以此类推,我们设$W _n = \sum _{ i = 0  } i ^3 $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
W _n & = \sum _{ i = 0  } ^{ n - 1  } i ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n ( i - 1 ) ^3 + n ^3 \\
& = \sum _{ i = 1  } ^n i ^3 - 3 \sum _{ i = 1  } ^n i ^2 + 3 \sum _{ i = 1  } ^n i - n + n ^3 \\
& = W _n - 3 S _n + 3 \frac { n + n ^2  } { 2  } - n + n ^3 \\
S _n & = \frac { n + n ^2  } { 2  } - \frac { n - n ^3  } { 3  } \\
& = \frac { n + 3 n ^2 + 2 n ^3  } { 6  } \\
& = \frac { n ( 1 + 3 n + 2 n ^2 )  } { 6  } \\
& = \frac { n ( 2 n + 1 ) ( n + 1 )  } { 6  } 
\end{aligned}</script><h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5><p>令$H _n = \sum _{ k = 1  } ^n \frac { 1  } { k  } $,求$\sum _{ i = 0  } ^n H _i $.</p>
<h5><span id="solution3">Solution3</span></h5><p>不妨考虑$\sum _{ i = 0  } ^n iH _{ i  } $的值.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^n iH _{ i  } & = \sum _{ i = 1  } ^n [ ( i - 1 + 1 ) H _{ i - 1  } + 1 ] \\
& = n + \sum _{ i = 0  } ^{ n - 1  } H _i + \sum _{ i = 0  } ^{ n  } iH _i - nH _n \\
\sum _{ i = 0  } ^{ n - 1  } H _i & = n ( H _n - 1 ) \\
\sum _{ i = 0  } ^n H _i & = ( n + 1 ) ( H _{ n + 1  } - 1 ) \\

\end{aligned}</script><h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5><p>求$S _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } , T _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i , U _n = \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } i ^2 $.</p>
<h5><span id="solution-4">Solution 4</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ i = 1  } ^{ n  } ( - 1 ) ^{ n - i  } + ( - 1 ) ^n \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - 1 - i  } \\
- S _{ n - 1  } + 1 & = ( - 1 ) ^n + S _{ n - 1  } \\
S _{ n - 1  } & = \frac { 1 - ( - 1 ) ^n  } { 2  } \\
S _n & = \frac { 1 + ( - 1 ) ^n  } { 2  } 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
T _{ n  } & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i \\
- T _{ n - 1  } + n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- T _{ n - 1  } + n & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^n ( - 1 ) ^{ n - i  } - ( - 1 ) ^n \\
- T _{ n - 1  } + n & = T _{ n - 1  } + S _n - ( - 1 ) ^n \\
n - \frac { 1 - ( - 1 ) ^n  } { 2  } & = 2 T _{ n - 1  } \\
T _n & = \frac { 1  } { 2  } ( n + 1 + \frac { - 1 - ( - 1 ) ^n  } { 2  } ) & = \frac { 1  } { 2  } ( n + \frac { 1 - ( - 1 ) ^n  } { 2  } ) 
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
U _n & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } i ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 + 1 ) ^2 \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) ^2 + 2 \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } ( i - 1 ) + \sum _{ i = 1  } ^n ( - 1 ) ^{ n - i  } \\
- U _{ n - 1  } + n ^2 & = \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i ^2 + 2 \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } i + \sum _{ i = 0  } ^{ n - 1  } ( - 1 ) ^{ n - i - 1  } \\
- U _{ n - 1  } + n ^2 & = U _{ n - 1  } + 2 T _{ n - 1  } + S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - 2 T _{ n - 1  } - S _{ n - 1  } \\
2 U _{ n - 1  } & = n ^2 - ( n - \frac { 1 - ( - 1 ) ^n  } { 2  } ) - \frac { 1 - ( - 1 ) ^n  } { 2  } \\
2 U _{ n - 1  } & = n ^2 - n \\
U _n & = \frac { n ( n + 1 )  } { 2  } 
\end{aligned}</script><h4><span id="转化为递归式">转化为递归式</span></h4><p>考虑和式$S _n = \sum _{ i = 0  } ^n f ( i ) = S _{ n - 1  } + f ( n ) \ $，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5><p>求$\sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 \ $.</p>
<h5><span id="solution1">Solution1</span></h5><p>令$S ( n ) = \sum _{ i = 0  } ^n ( - 1 ) ^i i ^2 = S ( n - 1 ) + ( - 1 ) ^n n ^2 $,考虑使用成套方法.</p>
<p>不妨令$S ( n ) = S ( n - 1 ) + ( - 1 ) ^n ( \alpha + \beta n + \gamma n ^2 ) = \alpha A ( n ) + \beta B ( n ) + \gamma C ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n , 可 以 解 得 \alpha = - 1 , \beta = 2 , \gamma = 0 $,有$( - 1 ) ^n n = - A ( n ) + 2 B ( n ) $.</p>
<p>令$S ( n ) = ( - 1 ) ^n n ^2 , 可 以 解 得 \alpha = 1 , \beta = - 2 , \gamma = 2 $,有$( - 1 ) ^n n ^2 = A ( n ) - 2 B ( n ) + 2 C ( n ) $.</p>
<p>显然可解得$2 C ( n ) = ( - 1 ) ^n n ^2 + ( - 1 ) ^n n , C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<p>而原式中,$S ( n ) = C ( n ) = ( - 1 ) ^n \frac { n ( n + 1 )  } { 2  } $.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5><p>有$2 T _n = nT _{ n - 1  } + 3 n ! , T _0 = 5 $,求$T _n $.</p>
<h5><span id="solution-2">Solution 2</span></h5><p>令$s _n = \frac { 2 ^{ n - 1  }  } { n !  } $,两边同时乘以$s _n $,有$\frac { 2 ^n  } { n !  } T _n = \frac { 2 ^{ n - 1  }  } { ( n - 1 ) !  } T _{ n - 1  } + 3 \times 2 ^{ n - 1  } \ $.</p>
<p>令$S _n = \frac { 2 ^n  } { n !  } T _n $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = S _{ n - 1  } + 3 \times 2 ^{ n - 1  } \\
& = 5 + 3 \sum _{ i = 0  } ^{ n - 1  } 2 ^i \\
& = 5 + 3 \times 2 ^{ n + 1  } - 3 \\
& = 3 \times 2 ^{ n  } + 2 \\
T _n & = 3 n ! + \frac { n !  } { 2 ^{ n - 1  }  } 
\end{aligned}</script><h4><span id="转化为积分形式">转化为积分形式</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数$f ( x ) = x ^2 $,显然$\int _0 ^n x ^2 dx = \frac { n ^3  } { 3  } \sim S _n \ $.</p>
<p>接下来,我们考虑求得二者之间的误差,设$E _n = S _n - \frac { n ^3  } { 3  } \ $,对其使用扰动法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \frac { n ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 + 1 ) ^3  } { 3  } \\
& = S _{ n - 1  } + n ^2 - \frac { ( n - 1 ) ^3  } { 3  } - ( n - 1 ) ^2 - ( n - 1 ) - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n ^2 - n ^2 + 2 n - 1 - n + 1 - \frac { 1  } { 3  } \\
& = E _{ n - 1  } + n - \frac { 1  } { 3  } 
\end{aligned}</script><p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E _n & = S _n - \int _0 ^n x ^2 dx \\
& = \sum _{ k = 1  } ^n ( k ^2 - \int _{ k - 1  } ^k x ^2 dx ) \\
& = \sum _{ k = 1  } ^n ( k ^2 - \frac { k ^3 - ( k - 1 ) ^3  } { 3  } ) \\
& = \sum _{ k = 1  } ^n ( k - \frac { 1  } { 3  } ) 
\end{aligned}</script><p>这是一个简单的和式.而$S _n = E _n + \frac { n ^3  } { 3  } \ $,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5><p>已知$a _1 = 1 , a _{ n + 1  } - a _n = - \frac { 1  } { 3  } a _n ^2 $,估计$a _n $的值.</p>
<p>考虑构造一个函数$f ( n ) $使得$f ( n ) \approx a _n $,那我们就可以将$a _{ n + 1  } - a _n \approx f _n $.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,$\exists x _0 \in [ n , n + 1 ] , f ‘ ( x _0 ) = f ( n + 1 ) - f ( n ) $,而对于增长率变化不大的函数,直接认为$f ‘ ( x _0 ) = f ‘ ( n ) $是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入$f ( 1 ) = 1 $解得$f ( n ) = \frac { 3  } { n + 2  } $.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令$a _n = \frac { 3  } { n + 2  } - b _n $,带入化简,得到$\{ b _n \} $的递推式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac { 3  } { n + 3  } - b _{ n + 1  } & = ( \frac { 3  } { n + 2  } - b _n ) ( 1 - \frac { 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _{ n + 1  } - \frac { 3  } { n + 3  } & = ( b _n - \frac { 3  } { n + 2  } ) ( \frac { n + 1  } { n + 2  } + \frac { b _n  } { 3  } ) \\
b _1 & = 0 , b _{ n + 1  } & = \frac { b _n ^2  } { 3  } + \frac { n  } { n + 2  } b _n + \frac { 3  } { ( n + 2 ) ^2 ( n + 3 )  } 
\end{aligned}</script><p>算到这里,我们可以很轻易使用数学归纳法算出$b _n \leq \frac { 1  } { 4 n  } $,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个$b _n $的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设$b _n ^2 &lt; &lt; b _n $:</p>
<p>那么这个$b _n $是$O ( \frac { \ln n  } { n ^2  } ) $级别的.</p>
<p>如何理解这个级别?考虑别乱动$b _n $的系数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b _{ n + 1  } & = \frac { n  } { n + 2  } b _n + \frac { 1  } { n ( n + 1 ) ( n + 2 )  } \\
( n + 1 ) ( n + 2 ) b _{ n + 1  } & = n ( n + 1 ) b _n + \frac { 1  } { n  } \\
g ( n ) & = n ( n + 1 ) b _n , g ' ( n ) & = \frac { 1  } { n  } , g ( n ) & = \ln n \\
b _n & = \frac { \ln n  } { n ^2  } 
\end{aligned}</script><p>这警戒我们以后乱估计的时候千万别把$O ( n ^{ \epsilon  } ) $和$O ( 1 ) $搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现$b _n \leq \frac { 3 \ln n  } { n ( n + 1 )  } $.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4><h5><span id="example1平方和公式">Example1(平方和公式)</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _n & = \sum _{ k = 1  } ^n k ^2 \\
& = \sum _{ k = 1  } ^n \sum _{ i = 1  } ^k k \\
& = \sum _{ i = 1  } ^n \sum _{ k = i  } ^n k \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( i + n ) ( n - i + 1 ) \\
& = \sum _{ i = 1  } ^n \frac { 1  } { 2  } ( in - i ^2 + i + n ^2 - ni + n ) \\
& = \frac { 1  } { 2  } ( \sum _{ i = 1  } ^n i - \sum _{ i = 1  } ^n i ^2 + n ^3 + n ^2 ) \\
& = \frac { 1  } { 4  } n ( n + 1 ) - \frac { 1  } { 2  } S _n + \frac { n ^3 + n ^2  } { 2  } 
\end{aligned}</script><p>整理得到$S _n $.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5><p>求$\sum _{ i = 1  } ^n i 2 ^i \ $.</p>
<h5><span id="solution-2">Solution 2</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n i 2 ^i & = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i 2 ^i \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n 2 ^i \\
& = \sum _{ j = 1  } ^n ( 2 ^{ n + 1  } - 2 ^j ) \\
& = n 2 ^{ n + 1  } - ( 2 ^{ n + 1  } - 2 ) \\
& = ( n - 1 ) 2 ^{ n + 1  } + 2 
\end{aligned}</script><h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5><p>求$\sum _{ i = 1  } ^n i ^3 \ $.</p>
<h5><span id="solution-3">Solution 3</span></h5><script type="math/tex; mode=display">
\begin{aligned}
S ( n ) & = \sum _{ i = 1  } ^n i ^3 \\
& = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i i ^2 \\
& = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n i ^2 \\
& = \sum _{ j = 1  } ^n ( \frac { n ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { ( j - 1 ) j ( 2 j - 1 )  } { 6  } ) \\
& = \frac { n ^2 ( n + 1 ) ( 2 n + 1 )  } { 6  } - \frac { 1  } { 3  } S ( n ) + \frac { n ( n + 1 ) ( 2 n + 1 )  } { 12  } - \frac { n ( n + 1 )  } { 12  } \\
S ( n ) & = \frac { n ^2 ( n + 1 ) ^2  } { 4  } 
\end{aligned}</script><h5><span id="exampleex">ExampleEX</span></h5><p>求$\sum _{ i = 1  } ^n iq ^i ( q \ne 1 ) $.</p>
<h5><span id="solutionex">SolutionEX</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n iq ^i & = \sum _{ j = 1  } ^n \sum _{ i = j  } ^n q ^i \\
& = \sum _{ j = 1  } ^n \frac { q ^j - q ^{ n + 1  }  } { 1 - q  } \\
& = \frac { 1  } { q - 1  } \sum _{ j = 1  } ^n ( q ^{ n + 1  } - q ^j ) \\
& = \frac { 1  } { q - 1  } ( nq ^{ n + 1  } - \frac { q ^{ n + 1  } - q  } { q - 1  } ) \\

\end{aligned}</script><h5><span id="exampleex2">ExampleEX2</span></h5><p>求$\sum _{ i = 1  } ^n ( ai + b ) q ^{ i - 1  } ( q \ne 1 ) $.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5><p>令$A = \frac { a  } { q - 1  } , B = \frac { b - A  } { q - 1  } $,答案为$( An + B ) q ^n - B $.</p>
<h4><span id="有限微积分">有限微积分</span></h4><h5><span id="移位算子">移位算子</span></h5><p>定义移位算子$E $，使得$Ef ( x ) = f ( x + 1 ) $.</p>
<h5><span id="差分算子">差分算子</span></h5><p>定义差分算子$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有$\Delta = E - 1 $.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5><p>定义逆差分算子$\Sigma $,可以得到有限微积分的基本定理:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( x ) & = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x & = f ( x ) + C \\

\end{aligned}</script><p>这里的$\Sigma $又被称为不定和式,是差分等于$g $的一个函数类.</p>
<p>值得一提的是,这里的$C $与无限微积分中的$C $有一定区别,这里的$C $可以是满足$p ( x ) = p ( x + 1 ) $的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5><p>如果$g ( x ) = \Delta f ( x ) $,那么有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = f ( x ) | ^{ b  } _a = f ( b ) - f ( a ) \ $.</p>
<p>值得一提的是,如果$a \leq b $,显然有$\sum \nolimits _{ a  } ^b g ( x ) \delta x = \sum _{ x = a  } ^{ b - 1  } g ( x ) \ $.</p>
<p>但如果$a &gt; b $,那么$\sum \nolimits _{ a  } ^b g ( x ) \delta x = - \sum \nolimits _b ^a g ( x ) \delta x \ $.</p>
<p>事实上,我们一定有:$\sum \nolimits _a ^b g ( x ) \delta x + \sum \nolimits _b ^c g ( x ) \delta x = \sum \nolimits _a ^c g ( x ) \delta x \ $.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5><p>类比无限微积分中的$D ( x ^m ) = mx ^{ m - 1  } $，有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( x ^{ \underline { m  }  } ) & = mx ^{ \underline { m - 1  }  } \\
\sum mx ^{ \underline { m - 1  }  } \delta x & = x ^{ \underline { m  }  } + C , m \ne 0 \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( \ln x ) = \frac { 1  } { x  } $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( H ( x ) ) & = x ^{ \underline { - 1  }  } & = \frac { 1  } { x + 1  } \\
\sum x ^{ \underline { - 1  }  } \delta x & = H ( x ) + C \\
\\

\end{aligned}</script><p>类比无限微积分中的$D ( e ^x ) = e ^x $,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( 2 ^x ) & = 2 ^x , \sum 2 ^x \delta x & = 2 ^x + C \\
\Delta ( c ^x ) & = ( c - 1 ) c ^x , \sum c ^x \delta x & = \frac { c ^x  } { c - 1  } + C , c \ne 1 \\
\Delta ( c ^{ \underline { x  }  } ) & = \frac { c ^{ \underline { x + 2  }  }  } { c - x  } , \sum \frac { c ^{ \underline { x + 2  }  }  } { c - x  } \delta x & = c ^{ \underline { x  }  } + C , c - x \ne 0 \\

\end{aligned}</script><p>根据组合数公式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta ( \binom { x  } { k  } ) & = \binom { x  } { k - 1  } \\
\sum \binom { x  } { k - 1  } \delta x & = \binom { x  } { k  } + C 
\end{aligned}</script><h6><span id="example平方和公式">Example(平方和公式)</span></h6><p>我们有:$k ^2 = k ^{ \underline { 2  }  } + k ^{ \underline { 1  }  } \ $.</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ n - 1  } & = \sum _{ i = 0  } ^{ n - 1  } i ^2 \\
& = \sum _{ i = 0  } ^{ n - 1  } ( i ^{ \underline { 2  }  } + i ^{ \underline { 1  }  } ) \\
& = \sum \nolimits _{ 0  } ^n x ^{ \underline { 2  }  } \delta x + \sum \nolimits _{ 0  } ^n x ^{ \underline { 1  }  } \delta x \\
& = \frac { n ^\underline { 3  }  } { 3  } + \frac { n ^{ \underline { 2  }  }  } { 2  } 
\end{aligned}</script><p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5><p>考虑一阶差分是$\Delta f ( x ) = f ( x + 1 ) - f ( x ) $,那么二阶差分就是$\Delta ^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f ( x ) $.</p>
<p>类似地,我们可以通过归纳法证明$\Delta ^n f ( x ) = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } f ( x + k ) \ $.</p>
<p>事实上有一种更简单的证明方法,由于$\Delta = E - 1 $,于是$\Delta ^n = ( E - 1 ) ^n = \sum _{ k  } \binom { n  } { k  } ( - 1 ) ^{ n - k  } E ^k \ $,由于$E ^k f ( x ) = f ( x + k ) $,即可证明原式.</p>
<p>另外,不难发现如果$f ( x ) $是一个关于$x $的$d $次多项式,那么$\Delta f ( x ) $是一个$d - 1 $次多项式.同理,$\Delta ^d f ( x ) $会是一个常数而$\Delta ^{ d + 1  } f ( x ) $会是$0 $,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6><p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为$x _1 , x _2 $.</p>
<p>不难写出期望转移式子:$f _i = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 $,并且$f _{ x _1  } = f _{ x _2  } = 0 $.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _i & = \cfrac { 1  } { 2  } ( f _{ i - 1  } + f _{ i + 1  } ) + 1 \\
2 f _i & = f _{ i - 1  } + f _{ i + 1  } + 2 \\
f _i - f _{ i - 1  } & = f _{ i + 1  } - f _i + 2 \\
\Delta f _{ i - 1  } & = \Delta f _{ i  } + 2 \\
\Delta f _i - \Delta f _{ i - 1  } & = - 2 \\
\Delta ^2 f _{ i - 1  } & = - 2 
\end{aligned}</script><p>$f $的二阶差分是常数,也就是说$f $是二次多项式,不难求得其二次项系数为$- 1 $又知道两个零点,显然可以得到$f $的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5><p>令$f ( x ) = \sum _{ 0 \leq i \leq d  } a _i x ^i \ $.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为$f ( x ) = \sum _{ 0 \leq i \leq d  } b _i x ^{ \underline { i  }  } \ $.</p>
<p>我们设$c _i = i ! b _i $,于是有:$f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i  } \ $.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为$f ( x ) $的牛顿级数.</p>
<p>于是不难发现有:$\Delta ^n f ( x ) = \sum _{ 0 \leq i \leq d  } c _i \binom { x  } { i - n  } \ $.如果我们令$x = 0 $,则有:$\Delta ^n f ( 0 ) = \begin{cases}c _n &amp; n \leq d \ 0 &amp; n &gt; d \end{cases} $.那么牛顿级数的另一种表示即:$f ( x ) = \sum _{ 0 \leq i \leq d  } \Delta ^i f ( 0 ) \binom { x  } { d  } \ $.</p>
<p>另外,如果我们展开一下$c _n = \Delta ^n f ( 0 ) $,我们可以得到公式:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } c _i \binom { k  } { i  } ) = ( - 1 ) ^n c _n , n \in \mathbb { N  } \ $.</p>
<p>如果我们将多项式还原,由于$a _n = b _n $,有:</p>
<p>$\sum _{ k  } \binom { n  } { k  } ( - 1 ) ^k ( \sum _{ 0 \leq i \leq n  } a _i k ^i ) = ( - 1 ) ^n n ! a _n , n \in \mathbb { N  } \ $.</p>
<p>另外,如果$x \in \mathbb { N  } $,那么我们有:$f ( x ) = \sum _{ 0 \leq k  } \Delta ^k f ( 0 ) \binom { x  } { 0  } $,根据多项式推理法,这个公式对$\forall x \in \mathbb { Z  } $都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<script type="math/tex; mode=display">
g ( a + x ) = \sum _{ 0 \leq k  } \cfrac { \Delta ^k g ( a )  } { k !  } x ^{ \underline { k  }  }</script><h6><span id="example">Example</span></h6><p>求$\sum _{ k  } \binom { n  } { k  } \binom { r - sk  } { n  } ( - 1 ) ^k , n \in \mathbb { N  } \ $.</p>
<p>如果我们令$f ( k ) = \binom { r - sk  } { n  } = \sum _{ 0 \leq i \leq n  } a _i k ^i \ $,不难发现$a _n = \cfrac { ( - 1 ) ^n s ^n  } { n !  } $,于是显然原式$= s ^n $.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\Delta ( uv ) & = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x + 1 ) - u ( x ) v ( x ) \\
& = v ( x + 1 ) \Delta u + u ( x ) \Delta v & = Ev \Delta u + u \Delta v \\

\end{aligned}</script><p>两边取不定和，即可得到分部求和法则:</p>
<p>$\sum u \Delta v = uv - \sum Ev \Delta u \ $.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = l  } ^{ r - 1  } ( a _{ i + 1  } - a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( b _{ i + 1  } - b _i ) \\
\sum _{ i = l  } ^{ r - 1  } ( \Delta a _i ) b _i & = a _r b _r - a _l b _l - \sum _{ i = l  } ^{ r - 1  } a _{ i + 1  } ( \Delta b _i ) 
\end{aligned}</script><p>对于$l = 0 , r = n , a _0 = b _0 = 0 $的特殊情况,应当有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } a _{ i + 1  } ( \Delta b _i ) \\
\sum _{ i = 1  } ^n a _i ( b _{ i + 1  } - b _i ) & = a _n b _n - \sum _{ i = 0  } ^{ n - 1  } ( \Delta a _i ) b _i 
\end{aligned}</script><p>取两组数列$\alpha , \beta $,并令$\sum _{ i = 1  } ^n \beta _i = B _i $,立刻有:</p>
<script type="math/tex; mode=display">
\sum _{ i = 1  } ^n \alpha _i \beta _i = \alpha _n B _n - \sum _{ i = 1  } ^{ n - 1  } ( \alpha _{ i + 1  } - \alpha _i ) B _i</script><h6><span id="example1">Example1</span></h6><p>求$\sum _{ k = 0  } ^n k 2 ^k \ $.</p>
<p>根据分部求和法则，我们有:</p>
<p>$\sum x 2 ^x \delta x = x 2 ^x - \sum 2 ^{ x + 1  } \delta x = x 2 ^x - 2 ^{ x + 1  } + C \ $.</p>
<p>改为定和式形式，显然有:</p>
<p>$\sum _{ k = 0  } ^n k 2 ^k = \sum \nolimits _0 ^{ n + 1  } x 2 ^x \delta x = ( n + 1 ) 2 ^{ n + 1  } - 2 ^{ n + 2  } + 2 = ( n - 1 ) 2 ^{ n + 1  } + 2 \ $.</p>
<h6><span id="example2">Example2</span></h6><p>求$\sum _{ k = 0  } ^{ n - 1  } kH _k \ $.</p>
<p>令$u ( x ) = H _x , v ( x ) = \frac { 1  } { 2  } x ^{ \underline { 2  }  } \ $.</p>
<p>带入分部求和法则，显然有:</p>
<p>$\sum xH _x \delta x = \frac { x ^\underline { 2  }  } { 2  } H _x - \frac { x ^\underline { 2  }  } { 4  } + C \ $.</p>
<p>带入即可求出原式$= \frac { n ^\underline { 2  }  } { 2  } ( H _n - \frac { 1  } { 2  } ) \ $.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6><p>求$\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } \ $.</p>
<h6><span id="solution-3">Solution 3</span></h6><p>令$u = ( 2 n + 1 ) , v = - \frac { 1  } { i  } $,则$\Delta u = 2 , \Delta v = \frac { 1  } { i ( i + 1 )  } $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \frac { 2 i + 1  } { i ( i + 1 )  } & = ( 2 n + 3 ) \times ( - \frac { 1  } { n + 1  } ) + 3 - \sum _{ i = 1  } ^n ( - \frac { 2  } { i + 1  } ) \\
& = - \frac { 2 n + 3  } { n + 1  } + 2 H _n + \frac { n + 3  } { n + 1  } & = 2 H _n - \frac { n  } { n + 1  } 
\end{aligned}</script><h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6><p>求$\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } \ $.</p>
<h6><span id="solution-4">Solution 4</span></h6><p>令$u = H _n , v = - \frac { 1  } { n + 1  } , \Delta u = \frac { 1  } { n + 1  } , \Delta v = \frac { 1  } { ( n + 1 ) ( n + 2 )  } \ $.</p>
<p>根据分部求和法则,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 0  } ^{ n - 1  } \frac { H _k  } { ( k + 1 ) ( k + 2 )  } & = - \frac { H _n  } { n + 1  } - \sum _{ i = 0  } ^{ n - 1  } ( - \frac { 1  } { ( i + 2 ) ( i + 1 )  } ) \\
& = - \frac { H _n  } { n + 1  } + \sum _{ i = 0  } ^{ n - 1  } ( \frac { 1  } { i + 1  } - \frac { 1  } { i + 2  } ) \\
& = - \frac { H _n  } { n + 1  } + H _n - ( H _n - 1 + \frac { 1  } { n + 1  } ) \\
& = 1 - \frac { H _n + 1  } { n + 1  } 
\end{aligned}</script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">贪心与构造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="贪心">贪心</span></h2><h3><span id="排除不优策略">排除不优策略</span></h3><h5><span id="example1cf1612e">Example1(CF1612E)</span></h5><p>先把期望写开,我们发现如果选择了$t $个消息$a _1 , a _2 , . . . , a _t $,那么答案就是$\sum [ \exists j , m _i = a _j ] \cfrac { \min ( t , k _i )  } { t  } $.显然如果$t $固定,那么每个$a _j $的贡献是独立的.于是只需要枚举$t $然后取贡献最大的.</p>
<p>但是,如果$t &gt; \max \{ k _i \} $,这个时候$t - 1 $的答案是$t - 1 $个数之和除以$t - 1 $,$t $的答案是这$t - 1 $个数之和加上另一个更小的数除以$t $,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度$O ( n \max \{ k _i \} ) $.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5><p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分($b _{ i , j  } = a _{ i , j  } \oplus a _{ i + 1 , j  } \oplus a _{ i , j + 1  } \oplus a _{ i + 1 , j + 1  } $)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是$0 $了,那么矩阵外不可能是$1 $,也就是原矩阵也全都是$0 $了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成$0 $才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5><p>首先注意到,如果我们对$( x , y ) $使用操作四,那我们不可能再对一个$( x , i ) $使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有$b _{ x , y  } , b _{ n , y  } , b _{ x , m  } $都是$1 $的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个$1 $,所以一定不如直接用一操作来的划算.不然,如果三个都是$1 $,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后$b _{ n , m  } $变成$1 $了,再不行也可以使用一次$1 $操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果$b _{ x , y  } , b _{ n , y  } , b _{ x , m  } $都是$1 $,我们就把$x $到$y $连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5><p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i $条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i $表示第$i $个分界点可能的最小值,$g _i $表示第$i $个分界点可能的最大值.假设我们目前二分的最大值要小于等于$mx $,最小值要大于等于$mn $,那么我们有转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1  } & = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } & = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}</script><p>注意到$f $与$g $的转移是无关的,而显然对于第$i $个分界点,它可以取$[ f _i , g _i ] $中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans _{ i  } $表示第$i $条分界线是啥,那么我们$ans _i $是可以取$[ ans _{ i + 1  } - mx , ans _{ i + 1  } - mn ] $中的任何一个数字的,我们将其和上面求出的$[ f _i , g _i ] $求一下交集.如果交集为空,说明要么$ans _{ i + 1  } - mn &lt; f _i , f _{ i + 1  } &lt; ans _{ i + 1  } &lt; f _i + mn $,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差$\leq mx - mn $.</p>
<h5><span id="example52022zrtg十连测day7-palindrome">Example5(2022zrtg十连测day7 Palindrome)</span></h5><p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对$( l , r ) $,我们想给每一个点对赋值:$a _l = i , a _r = n - i + 1 $(注意如果$n $是奇数,那么中心点应该是$a _{ mid  } = \frac { n + 1  } { 2  } $),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对$( l _1 , r _1 ) $,$( l _2 , r _2 ) $之间的三种可能的关系:不交,包含,相交且不包含.会发现若$l $小则让$a _l $尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5><p>强强题.</p>
<p>首先发现这个$\pm 1 $操作很奇怪.我们不妨这么考虑:设最后的答案序列为$b $,那么答案其实就是$\sum | b _i - a _i | $.这实际上是什么呢?实际上是数轴上$a _i $和$b _i $之间的距离.既然这样,那么我们同时反转$a $和$b $,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个$a $,将它和$x $同时反转,那么答案不变.这么做后我们可以直接清空所有$a $的最高位,只剩下$x $可能有最高位.</p>
<p>那$x $的最高位一定会让若干$a $往上变成它.注意到最多只会有一个$a $会向上满足$x $的最高位.证明的话同样考虑取反,如果有两个$a $满足$a _i \oplus b _i $和$a _j \oplus b _j $这一位是$1 $,我们仍然考虑数轴,有$| not ( b _i ) - a _i | \leq | a _i - b _i | $,这由$a _i \oplus b _i $最高位是$1 $导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个$a $上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的$a $可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5><h5><span id="example8">Example8()</span></h5><h3><span id="带悔贪心">带悔贪心</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个数组,给出若干次操作$[ l , r , k ] $表示可以将$a [ l \cdots r ] $减一进行至多$k $次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5><p>给定一个序列,每次可以选择相邻的两个数,使其中一个$- 1 $,另一个$- 2 $,求使得整个序列都小于等于$0 $的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol>
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p>
</li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p>
</li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p>
</li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做$( - 2 , - 1 ) $,最后不够了再加个$( - 1 , - 2 ) $补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候$( - 1 , - 2 ) + ( - 1 , - 2 ) $比$( - 2 , - 1 ) $更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做$( - 2 , - 1 ) $,最后不够了再加个$( - 1 , - 2 ) $补一下.我们通过样例以及其它栗子发现:有的时候$( - 1 , - 2 ) + ( - 1 , - 2 ) $比$( - 2 , - 1 ) $更优秀,这启发我们:能不能在做后面位置的时候将前面的$( - 2 , - 1 ) $变成$( - 1 , - 2 ) + ( - 1 , - 2 ) $呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个$( - 2 , - 1 ) $操作,那么我可以在这个位置进行一个$( 0 , - 3 ) $操作.显然$( 0 , - 3 ) + ( - 2 , - 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2 ) $.我们完成了反悔的操作!</p>
<p>但是,我们直接认为$( - 1 , - 2 ) $不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个$( - 1 , - 2 ) + ( - 1 , - 2 ) $,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑$( - 3 , 0 ) $怎么反悔.这个看上去很疑惑:我们为了使$( - 2 , - 1 ) $变成$( - 1 , - 2 ) + ( - 1 , - 2 ) $而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在$( - 2 , - 1 ) $的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:$( - 3 , 0 ) $这个技能的发动是有前提条件的:前面必须有$( - 2 , - 1 ) $才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个$( - 2 , - 1 ) $,也很清楚每个地方用了几个$( - 3 , 0 ) $.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:$( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 2 , - 1 ) = ( - 3 , 0 ) + ( 0 , - 3 ) $,或者$( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 1 , - 2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3 ) $.</p>
<p>最后遇到一个点,能用$( 0 , - 3 ) $就用$( 0 , - 3 ) $,不够用的再补齐.这个原因也很简单:如果我们在这里不用$( - 3 , 0 ) $而用其它的代替的话,你会发现无论如何都等价于$( - 3 , 0 ) $然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的$( - 2 , - 1 ) $和$( - 1 , - 2 ) $的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的$( - 3 , 0 ) $操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3><h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5><p>给你一个长度为$n $的序列$a $,保证$a _1 = a _n = 1 $.每次你可以选择一个$i ( 1 &lt; i &lt; n ) $将$a _i $删去并付出$a _{ i - 1  } a _i a _{ i + 1  } $的代价.删去$a _i $后序列两端会接起来,求删成两个$1 $的最小代价.</p>
<p>首先注意到,如果有一个$1 &lt; i &lt; n $满足$a _i = 1 $,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要$1 $的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个$1 $所划分.接下来我们只考虑中间所有数$\geq 2 $的情况.</p>
<p>再思考一个事实:当$a , b \geq 2 $时,一定有$ab \geq a + b $.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是$\sum _{ i = 2  } ^{ n - 2  } a _i a _{ i + 1  } + \min _{ i = 2  } ^{ n - 1  } { a _i  } $.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5><p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造$a $数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5><p>给定一张图,每个点上有一个权值$a _i $,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5><p>先考虑$a _i $互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数$\leq $还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在$a _i $相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的$( a _i , a _{ i + 1  } ) $,然后这么选:$a _i , a _{ i + 1  } , a _n , a _{ i - 1  } , a _{ n - 1  } , a _{ i - 2  } . . . $,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在$a _i $上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5><p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是$a $和$b $,其中$2 a &lt; b $.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果$b $之前吃过别的鱼,假设是$c $和$d $(不妨假设$d \geq c $),有$b = c + d $,由鸽笼原理,发现$d &gt; a $.这意味着:如果$a $都没被操作掉,那么$d $必不可能被操作掉,这也就是说$b $不可能出现.因此$b $在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于$b $,且$a $就是所有一开始小于$b $的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是$w _i &gt; 2 \sum _{ j = 1  } ^{ i - 1  } w _j $,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多$\log w $个,我们考虑一下这个两倍的用处,我们按照值域$[ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , . . . , [ 2 ^{ k - 1  } + 1 , 2 ^k ] $将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5><p>给定$n $个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol>
<li><p>$S $表示标准球.</p>
</li>
<li><p>$&lt; A , B &gt; $表示称量集合$A $和集合$B $,$&lt; A , B &gt; = 0 $表示平衡,$&lt; A , B &gt; = A $表示$A $较重,$&lt; A , B &gt; = B $表示$B $较重.</p>
</li>
</ol>
<h6><span id="信息论">信息论</span></h6><p>如果一个随机变量$x $有$n $种取值,出现概率分别为$p _1 , p _2 , \cdots , p _n $,则其熵为$H ( x ) = f ( p _1 , p _2 , \cdots , p _n ) = \sum { C p _i \ln \frac { 1  } { p _i  }  } $,$C $为正整数,通常取$1 $.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量$x $的一个熵为$h $的信息后,$x $的熵会减少$h $.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有$n $个球,每个球等概率成为次品,因此总熵是$\ln n $,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是$\ln 3 $,也就是说我们至少要猜$\frac { \ln n  } { \ln 3  } = \log _3 n $次.如果我们不知道次品的轻重,那么至少要猜$\frac { \ln 2 n  } { \ln 3  } = \log _3 2 n $次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6><p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p>$n $个叶子的树的最小深度是$\lceil \log _3 n \rceil $,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6><p>不妨假设$f ( n ) $表示有$n $个球的最少次数,注意到$f ( 3 ) = 1 $.</p>
<p>根据信息论,$f ( n ) \geq \lceil \log _3 n \rceil $,下面证明等号成立:</p>
<p>首先考虑证明$f ( 3 ^m ) = m $,$m = 1 $时已经得证.$m &gt; 1 $时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此$f ( 3 ^m ) \leq f ( 3 ^{ m - 1  } ) + 1 $.综合信息论下界$f ( 3 ^m ) \geq m $,我们不难得出以上结论.至于$n \ne 3 ^m $的情况,我们类似这个过程按照$n \bmod 3 $的值讨论一下即可,于是有$f ( n ) \leq f ( \lceil \frac { n  } { 3  } \rceil ) + 1 $.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6><p>根据信息论下界,$f ( n ) \geq \lceil \log _3 2 n \rceil $.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有$n $个球,第二堆有$m $个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是$g ( n , m ) $,则$g ( n , m ) = \lceil \log _3 ( n + m ) \rceil $.</p>
<p>先证明信息论下界,不难发现仍然是$g ( n , m ) = \lceil \log _3 ( n + m ) \rceil $.</p>
<p>首先不难发现,$g ( 1 , 0 ) = g ( 0 , 1 ) = 0 , g ( 1 , 1 ) = g ( 2 , 0 ) = g ( 0 , 2 ) = 1 $.</p>
<p>仍然使用数学归纳,假设$n + m &lt; k ( k \geq 3 ) $的时候成立,我们接下来证明$n + m = k $的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若$n = 3 p , m = 3 q $,我们将$n $分成等数量的三堆:$A _1 , B _1 , C _1 $,将$m $分成等质量的三堆$A _2 , B _2 , C _2 $.</p>
<p>接下来称量$\lang A _1 + A _2 , B _1 + B _2 \rang $.</p>
<ol>
<li><p>如果$\langle A _1 + A _2 , B _1 + B _2 \rang = 0 $,那么答案在$C _1 \cup C _2 $中,此时有$g ( n , m ) = g ( \frac { n  } { 3  } , \frac { m  } { 3  } ) + 1 $.</p>
</li>
<li><p>如果$\lang A _1 + A _2 , B _1 + B _2 \rang = A _1 + A _2 $,由于若次品在$A _2 $中,那么它不可能是重球,因此次品不可能在$A _2 $中,同理不可能在$B _1 $中,只可能在$A _1 \cup B _2 $中,此时有$g ( n , m ) = g ( \frac { n  } { 3  } , \frac { m  } { 3  } ) + 1 $.</p>
</li>
<li><p>$\lang A _1 + A _2 , B _1 + B _2 \rang = B _1 + B _2 $,同理.</p>
</li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p>$n = 3 p + 1 , m = 3 q + 2 $.此时我们将第一堆分成$A _1 ( p ) , B _1 ( p ) , C _1 ( p + 1 ) $,将第二堆分成$A _2 ( q + 1 ) , B _2 ( q + 1 ) , C _2 ( q ) $,然后$\lang A _1 + A _2 , B _1 + B _2 \rang $,接下来和情况1一样,于是有$g ( n , m ) = \max \{ g ( p , q + 1 ) , g ( p + 1 , q ) \} = \lceil \log _3 \frac { n + m  } { 3  } \rceil + 1 $.</p>
<p>同理,当$n , m \bmod 3 $的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论$n \bmod 3 $的值.</p>
<p><strong>情况1</strong></p>
<p>当$n = 3 p $时,直接分成$A ( p ) , B ( p ) , C ( p ) $,然后$\lang A , B \rang $.如果平衡则接下来需要$f ( p ) = \lceil \log _3 2 p \rceil $次,不然根据引理,需要$\lceil \log _3 ( p + p ) \rceil $次,因此$f ( n ) = \lceil \log _3 2 p \rceil + 1 = \lceil \log _3 6 p \rceil = \lceil \log _3 2 n \rceil $.</p>
<p><strong>情况2</strong></p>
<p>当$n = 3 p + 1 $时,一种自然的想法是分成$A ( p + 1 ) , B ( p ) , C ( p ) $,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了$2 p + 2 , 2 p , 2 p $,这显然是不优秀的.正确的做法是分成$A = \{ S , 1 , \cdots p \} , B = \{ p + 1 , \cdots 2 p + 1 \} , C = \{ 2 p + 2 , \cdots 3 p + 1 \} $.由于存在标准球,此时如果$\lang A , B \rang = A  or  B $,那么转化成$g ( p , p + 1 ) = \lceil \log _3 ( 2 p + 1 ) \rceil $,不然转化成$f ( p ) = \lceil \log _3 2 p \rceil $.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6><p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有$n \bmod 3 = 1 $的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题$f ( n ) = \lceil \log _3 ( 2 n + 2 ) \rceil $.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6><p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将$a $个球放左边,$b $个球放右边,$a \leq b $,在左边补上$b - a $个标准球.</p>
<ol>
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要$\lceil \log _3 ( a + b ) \rceil + 1 $步.</p>
</li>
<li><p>如果天平平衡,需要$f ( n - a - b ) + 1 $步.</p>
</li>
</ol>
<p>我们有$f ( n ) = \min _{ a , b  } \{ \max \{ f ( n - a - b ) , \lceil \log _3 ( a + b ) \rceil \} \} + 1 $.</p>
<p>注意到接下来的步数只与$a + b $有关,取$b - a \leq 1 $,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到$f ( n ) = \lceil \log _3 ( 2 n - 1 ) \rceil $.</p>
<p>接下来归纳法就简单了,只需要对于$n \bmod 3 $的余数讨论一下,然后再讨论一下$a $的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5><p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求$n $所在位置.要求询问次数$\leq \lceil 1 . 5 \log _2 n \rceil $,询问区间总长度$\leq 3 n $.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设$T ( n ) $表示长度为$n $的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程$T ( n ) = \min _{ m &lt; n  } \{ \max \{ T ( m ) + 1 , T ( n - m ) + 2 \} \} $.</p>
<p>当然有$m _n \leq m _{ n + 1  } $,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3><h4><span id="模型1">模型1</span></h4><p>给定$n $个元素$x _1 , . . . , x _n $,以及一个定义域为这些元素的序列,定义域为有序集合的函数$F $.求出对于所有的$n $阶排列$p $,表达式$F ( \{ x _{ p _1  } , x _{ p _2  } , . . . , x _{ p _n  } \} ) $最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5><p>给定$n $个二元正整数对$( a _i , b _i ) $,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的$a $乘上序列中这个二元组之后的所有二元组的$b $之和的总和,求最小代价.$n , a _i , b _i \leq 10 ^6 $.</p>
<p>转化为上面的形式,也即:$F ( \{ ( a _1 , b _1 ) , . . . , ( a _n , b _n ) \} ) = \sum _{ 1 \leq i &lt; j \leq k  } a _i b _j $.</p>
<p>考虑调整法,令排列$( q _1 , . . . , q _n ) = ( p _1 , . . . , p _{ i - 1  } , p _{ i + 1  } , p _i , p _{ i + 2  } , . . . , p _n ) $.则:</p>
<script type="math/tex; mode=display">
F ( \{ ( a _{ p _1  } , b _{ p _1  } ) , . . . , ( a _{ p _n  } , b _{ p _n  } ) \} ) - F ( \{ ( a _{ q _1  } , b _{ q _1  } ) , . . . , ( a _{ q _n  } , b _{ q _n  } ) \} ) = a _{ p _i  } b _{ p _{ i + 1  }  } - a _{ p _{ i + 1  }  } b _{ p _i  }</script><p>因而如果$a _{ p _i  } b _{ p _{ i + 1  }  } - a _{ p _{ i + 1  }  } b _{ p _i  } &gt; 0 $,则$F ( \{ ( a _{ p _1  } , b _{ p _1  } ) , . . . , ( a _{ p _n  } , b _{ p _n  } ) \} ) &gt; F ( \{ ( a _{ q _1  } , b _{ q _1  } ) , . . . , ( a _{ q _n  } , b _{ q _n  } ) \} ) $,也就是说$( p _1 , . . . , p _n ) $不是最优解.因此只有满足$\forall 1 \leq i &lt; n $,$\cfrac { a _{ p _i  }  } { b _{ p _i  }  } \leq \cfrac { a _{ p _{ i + 1  }  }  } { b _{ p _{ i + 1  }  }  } $可能是最优解.</p>
<p>如果一个$p $满足这样的性质,则所有$\cfrac { a  } { b  } $相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换$\cfrac { a  } { b  } $相等的两个位置,是不会使答案改变的.因此直接按照$\cfrac { a  } { b  } $排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5><p>设给出的元素的集合为$S $,定义$S $上的一种二元比较关系$\leq $,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol>
<li><p>强完全性:$\forall a , b \in S $,$a \leq b \lor b \leq a = 1 $.</p>
</li>
<li><p>传递性:$\forall a , b , c \in S $,$a \leq b , b \leq c \Rightarrow a \leq c $.</p>
</li>
<li><p>$\forall a , b \in S $,如果$a \leq b $,则对于任意一个包含$\{ a , b \} $作为子段的元素序列$\{ s _1 , . . . , s _{ k - 1  } , a , b , s _{ k + 2  } , . . . , s _n \} $和$\{ s _1 , . . . , s _{ k - 1  } , b , a , s _{ k + 2  } , . . . , s _n \} $都有:$F ( \{ s _1 , . . . , s _{ k - 1  } , a , b , s _{ k + 2  } , . . . , s _n \} ) \leq F ( \{ s _1 , . . . , s _{ k - 1  } , b , a , s _{ k + 2  } , . . . , s _n \} ) $.</p>
</li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义$\leq $后自然也就定义了$= $,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到$\leq $的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5><p>给定$n $个包含小写字符的字符串$s _1 , . . . , s _n $,找到一个$n $阶排列$p $,将$s _{ p _1  } , s _{ p _2  } , . . . , s _{ p _n  } $顺序拼接得到$S $,使$S $的字典序最小.</p>
<p>令$s \leq t $当且仅当$s + t $的字典序$\leq $t+s</p>
<p>此时我们注意到:$s + t $的字典序小于等于$t + s $的字典序当且仅当$s ^{ \infty  } \leq t ^{ \infty  } $.原因是:不妨设$s $的长度$\leq t $的长度.若$s $不是$t $的前缀,那显然只需比较$t $的前缀和$s $的字典序即可,此时上面两个条件等价;若$s $是$t $的前缀,则我们需要比较$t $的前缀和$t $的后缀,注意到$t $的前缀还是$s $,于是需要比较$s $和$t $的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5><p>有$n $个箱子,第$i $个箱子有重量$w _i $和承载量$v _i $,$( w _i , v _i &gt; 0 ) $,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化$\min _{ i = 1  } ^n \{ v _i - \sum _{ j = 1  } ^{ i - 1  } w _j \} $,并判断是否$\geq 0 $.</p>
<p>我们令$b _i = - ( v _i + w _i ) , a _i = - v _i $,则我们要最大化$\min \{ \sum _{ j = 1  } ^{ i - 1  } b _i - \sum _{ j = 1  } ^i a _i \} $.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义$x \leq y $当且仅当$F ( \{ x , y \} ) \leq F ( \{ y , x \} ) $,那么对于两个元素$( a _1 , b _1 ) , ( a _2 , b _2 ) $,显然$( a _1 , b _1 ) \leq ( a _2 , b _2 ) $当且仅当$\min \{ - a _1 , b _1 - a _1 - a _2 \} \geq \min \{ - a _2 , b _2 - a _1 - a _2 \} $.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol>
<li><p>都大于等于第一个元素,则相当于$a _1 \leq a _2 \land b _1 - a _1 \geq 0 $.</p>
</li>
<li><p>都大于等于第二个元素,则相当于$b _1 \geq b _2 \land b _2 - a _2 \leq 0 $.</p>
</li>
</ol>
<p>可能这里后面和$0 $比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对$b - a $的符号进行讨论:</p>
<ol>
<li><p>若$sgn ( b _1 - a _1 ) &gt; sgn ( b _2 - a _2 ) $,则不等式成立.</p>
</li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 1 $,则不等式成立当且仅当$a _1 \leq a _2 $.</p>
</li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = 0 $,则不等式成立.</p>
</li>
<li><p>若$sgn ( b _1 - a _1 ) = sgn ( b _2 - a _2 ) = - 1 $,则不等式成立当且仅当$b _1 \geq b _2 $.</p>
</li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时$b _1 = a _1 $,$b _2 = a _2 $,两条件必有一真.(1)则是因为此时满足$b _1 - a _1 &gt; b _2 - a _2 \land sgn ( b _1 - a _1 ) \geq 0 \land sgn ( b _2 - a _2 ) \leq 0 $.也就有$a _2 - a _1 &gt; b _2 - b _1 \land b _1 \geq a _1 \land b _2 \leq a _2 $.怎么着都能成立.</p>
<p>由此发现,对于$sgn ( b - a ) $相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( a _1 , b _1 ) & \leq ( a _2 , b _2 ) \\
\Updownarrow \\
( sgn ( b _1 - a _1 ) & > sgn ( b _2 - a _2 ) ) \\
\lor ( sgn ( b _1 - a _1 ) & = sgn ( b _2 - a _2 ) \land F ( \{ 1 , 2 \} ) & \leq F ( \{ 2 , 1 \} ) 
\end{aligned}</script><h4><span id="模型2">模型2</span></h4><p>给定$n $个元素$x _1 , . . . , x _n $,以及一个定义域为这些元素的序列,值域为有序集合的函数$F $.求出对于给定整数$k $,所有的$n $阶排列$p $的长度为$k $的子序列,表达式$F ( \{ x _{ p _1  } , x _{ p _2  } , . . . , x _{ p _k  } \} ) $最小值.</p>
<p>如果$k = n $,则就是模型1.不然,我们考虑先选出一个大小为$k $的子集,然后使用模型1.不难发现,我们最后取出的$\{ x _{ p _1  } , x _{ p _2  } , . . . , x _{ p _k  } \} $一定是$n = k $时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5><p>有$n $个物品,第$i $个物品有非负费用$c _i $和价值$v _i $,两个人进行如下博弈:</p>
<ol>
<li><p>第一个人要么选择一个物品,付出$c _i $的代价;要么选择结束游戏.</p>
</li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行$k $次);也可以选择不操作,此时第一个人获得$v _i $的收益,博弈结束.</p>
</li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.$( n \leq 1 . 5 \times 10 ^5 , k \leq 9 ) $</p>
</li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择$k + 1 $个,然后收益为$\min _{ i = 1  } ^{ k - 1  } \{ v _{ x _i  } - \sum _{ j = 1  } ^i c _{ x _j  } \} $(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度$O ( n \log n + nk ) $.</p>
<h2><span id="构造">构造</span></h2><h3><span id="增量构造">增量构造</span></h3><h5><span id="example1">Example1</span></h5><p>平面上有$n $条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有$n $条直线的答案,求$n + 1 $条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5><p>给定若干个角度$a _1 , \cdots , a _n \in \{ 90 \degree , 270 \degree \} $,要求构造一个$n $边形(边必须平行于坐标轴),使得其内角依次是$a _1 , \cdots , a _n $.</p>
<p>首先有解条件显然是判定它们的和是否是$180 \degree ( n - 2 ) $.</p>
<p>注意到相邻的$90 \degree $和$270 \degree $无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5><p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5><p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3><p>常见于操作可逆,想要让$S \rightarrow T $.这个时候可以找一个中间状态$A $,让$S \rightarrow A , T \rightarrow A $.</p>
<h5><span id="example1">Example1</span></h5><p>坐标系上每个整点有个灯,初始只有$( X , 0 ) $亮着,每次把$( x , y ) $,$( x , y + 1 ) $,$( x + 1 , y ) $状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p>$n \leq 10 ^5 $,坐标的绝对值均$\leq 10 ^{ 17  } $.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线$y = - inf $,然后比对.我们注意到$( X , 0 ) $向下推的过程类似一个组合数递推的过程,由经典公式$\binom { S  } { T  } \equiv [ T \subseteq S ] \bmod 2 $可知,我们取$inf = 2 ^{ 63  } - 1 $即可.然后最后在这条线上一定是有一个区间是$1 $,我们需要找到区间左端点,我们选择在直线上随便找到一个$1 $,由于$inf $很大,大于$10 ^{ 17  } $,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,$n \leq 10 ^4 $,但是初始点可能是$( X , Y ) $.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点$( j , - inf ) $和$( k , - inf ) $是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出$X $和$Y $.而上述条件满足当且仅当$[ j - X \subseteq Y + inf ] $.</p>
<p>如果我们随便找一个点$( p , - inf ) $满足条件,那我们接下来只需要枚举$w $,判断$( p - 2 ^w , - inf ) $是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间$[ l , r ] $中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">计算几何</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2><p>参考:<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong">https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong</a>.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3><h4><span id="eps">eps</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$\vec { a  } \cdot \vec { b  } = | \vec { a  } | | \vec { b  } | \cos \theta = x _a x _b + y _a y _b $.也就等于$\vec { a  } $在$b $上的投影与$\vec { b  } $的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol>
<li><p>如果$\vec { a  } \cdot \vec { b  } = 0 $,则说明$\vec { a  } \bot \vec { b  } $.</p>
</li>
<li><p>如果$\vec { a  } \cdot \vec { b  } &gt; 0 $,则说明$\vec { a  } $和$\vec { b  } $正方向的夹角小于$90 \degree $.</p>
</li>
<li><p>如果$\vec { a  } \cdot \vec { b  } &lt; 0 $,则说明$\vec { a  } $和$\vec { b  } $正方向的夹角大于$90 \degree $.</p>
</li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$\vec { a  } \times \vec { b  } = x _a y _b - y _a x _b $.也就等于$\vec { a  } , \vec { b  } $两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol>
<li><p>如果$\vec { a  } \times \vec { b  } = 0 $,说明二者共线.</p>
</li>
<li><p>如果$\vec { a  } \times \vec { b  } &lt; 0 $,说明从$\vec { a  } $到$\vec { b  } $的方向是顺时针.</p>
</li>
<li><p>如果$\vec { a  } \times \vec { b  } &gt; 0 $,说明从$\vec { a  } $到$\vec { b  } $的方向是逆时针.</p>
</li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵$\begin{bmatrix}\cos \theta &amp; - \sin \theta \ \sin \theta &amp; \cos \theta \end{bmatrix} $.</p>
<h4><span id="line">Line</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下$x _{ L _1  } , x _{ L _2  } , y _{ L _1  } , y _{ L _2  } $围成的四边形,计算面积后用等高不等底计算.注意$ls $和$rs $所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4><p>利用叉乘,任取平面上一点$O $,则$S = \frac { 1  } { 2  } \sum _{ i = 1  } ^n \overrightarrow { OP _i  } \times \overrightarrow { OP _{ i + 1  }  } $.证明的话考虑分$O $在内部和$O $在外部两种情况分类讨论.注意此时的$P $必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为$a $,它的边上(包括顶点)的整点数为$b $,则它的面积$S = a + \frac { b  } { 2  } - 1 $.</p>
<h3><span id="基本算法">基本算法</span></h3><h4><span id="排序算法">排序算法</span></h4><h5><span id="极角排序">极角排序</span></h5><p>定义原点$O $并建立坐标系,所有点按照和$O $所连直线与$x $轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是$x $相同比$y $,否则比$x $.</p>
<h4><span id="二维凸包">二维凸包</span></h4><h5><span id="定义">定义</span></h5><p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5><p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否$ABC $三点是一个上凸的(注意$ABC $三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4><h5><span id="定义">定义</span></h5><p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5><p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4><p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5><p>两个区域$A , B $的闵可夫斯基和定义为$\{ a + b \mid a \in A , b \in B \} $.</p>
<h5><span id="实现">实现</span></h5><p>事实上,新的区域所形成的凸包,一定是原本$A , B $的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下$A , B $,使得$B $有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是$B $这个边加上$A $的最右边的点.这样这条边必定还在最终的凸包上.就算$A $最右边的是一条边,你也会发现最终的凸包最右边也一定是由$A $的这条边和$B $的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4><h5><span id="定义">定义</span></h5><p>定义半平面为满足$ax + by + c &gt; 0 $或$ax + by + c \geq 0 $的点对$( x , y ) $组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5><p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2><p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3><h4><span id="直线">直线</span></h4><p>使用直线的方向向量$\vec { s  } = ( n , m , p ) $和直线上一点$M _0 = ( x _0 , y _0 , z _0 ) $.那么方程显然为:</p>
<script type="math/tex; mode=display">
\frac { x - x _0  } { n  } = \frac { y - y _0  } { m  } = \frac { z - z _0  } { p  }</script><p>如果换元,我们还有参数方程:</p>
<script type="math/tex; mode=display">
\begin{cases}
x = x _0 + nt \\
y = y _0 + mt \\
z = z _0 + pt 
\end{cases}</script><h4><span id="平面">平面</span></h4><p>使用平面上的一点$P _0 ( x _0 , y _0 , z _0 ) $和该平面的法向量$\vec { n  } $来表示一个平面,不妨设$\vec { n  } = ( A , B , C ) $,则该平面的方程显然为:</p>
<script type="math/tex; mode=display">
A ( x - x _0 ) + B ( y - y _0 ) + C ( z - z _0 ) = 0</script><p>如果我们令$D = - ( Ax _0 + By _0 + Cz _) $,那么平面方程为:</p>
<script type="math/tex; mode=display">
Ax + By + Cz + D = 0</script><h4><span id="夹角">夹角</span></h4><h5><span id="两直线夹角">两直线夹角.</span></h5><p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是$\vec { s _1  } = ( n _1 , m _1 , p _1 ) , \vec { s _2  } = ( n _2 , m _2 , p _2 ) $,也就有$\varphi = \arccos ( \frac { | \vec { s  } _1 \cdot \vec { s  } _2 |  } { | \vec { s  } _1 | | \vec { s  } _2 |  } ) \ $.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5><p>同样使用向量,不妨设方向向量$\vec { s  } = ( n , m , p ) $,法向量$\vec { f  } = ( a , b , c ) $,那么$\varphi = \arcsin ( \frac { | \vec { s  } \cdot \vec { f  } |  } { | \vec { s  } | | \vec { f  } |  } ) $.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol>
<li><p>若直线与平面平行,则$am + bn + cp = 0 $.</p>
</li>
<li><p>若直线与平面垂直,则$\frac { a  } { m  } = \frac { b  } { n  } = \frac { c  } { p  } $.注意这里分母可能除以$0 $,我们实际上应该是三个形如$a = mt $的参数方程,这里简化了.</p>
</li>
</ol>
<h4><span id="交点">交点</span></h4><p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3><p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401766934">https://zhuanlan.zhihu.com/p/401766934</a></p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4><p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4><p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">范畴论初步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%8C%83%E7%95%B4%E8%AE%BA%E5%88%9D%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="基础集合论">基础集合论</span></h2><h3><span id="映射">映射</span></h3><p>设$A , B $为两个集合,$\varphi $称为从$A $到$B $的一个<strong>映射</strong>,如果对于任意$a \in A $,$\exists b \in B , b = \varphi ( a ) $.此时$b $称为$a $在$\varphi $下的像,$a $称为$b $在$\varphi $下的原像或反像.一般地,这个定义可以拓展到$S \subseteq A $,$\varphi ( S ) = \{ \varphi ( a ) \mid a \in S \} $,定义$\varphi ^{ - 1  } ( T ) = \{ a | \varphi ( a ) \in T , a \in S \} $.</p>
<p>如果$\forall a _1 , a _2 \in A , a _1 \ne a _2 , \varphi ( a _1 ) \ne \varphi ( a _2 ) $,称$\varphi $是<strong>单射</strong>.</p>
<p>如果$\forall b \in B , \exists a \in A , \varphi ( a ) = b $.称$\varphi $为<strong>满射</strong>.</p>
<p>如果$\varphi $既是单射又是满射,称其为<strong>双射</strong>或<strong>一一映射</strong>.</p>
<p>如果$A = B $,我们又称$\varphi $为一个<strong>变换</strong>.</p>
<p>设$f : A \rightarrow B , g : B \rightarrow A $,那么:</p>
<ol>
<li><p>如果$g \circ f = id _A $,称$g $是$f $的一个<strong>左逆</strong>,不难发现$f $存在左逆当且仅当$f $是单射.</p>
</li>
<li><p>如果$f \circ g = id _B $,称$g $是$f $的一个<strong>右逆</strong>,不难发现$f $存在右逆当且仅当$f $是满射.</p>
</li>
<li><p>如果$g $既是$f $的左逆又是$f $的右逆,则称$g $为$f $的<strong>逆</strong>,不难发现$f $存在逆当且仅当$f $是双射,并且逆唯一.</p>
</li>
</ol>
<h3><span id="二元运算与二元关系">二元运算与二元关系</span></h3><p>集合$A , B $的<strong>笛卡尔积</strong>或<strong>直积</strong>是指$A $的元素与$B $的元素构成的有序对的集合,即$A \times B = \{ ( a , b ) \mid a \in A , b \in B \} $.可以推广到多元对.</p>
<p>集合$A $上的一个<strong>二元运算</strong>是由$A \times A $到$A $的一个映射.对于定义在$U $上的一个二元运算,不妨用$+ $来表示,集合$A , B \subseteq U $的<strong>闵可夫斯基和</strong>定义为$A + B = \{ a + b \mid a \in A , b \in B \} $.OI中常见的如取背包等算法,其实就是在做闵和后去除或合并若干点.</p>
<p>集合$A $上的一个<strong>二元关系</strong>$R $定义为$A \times A $的一个子集(可以理解为满足二元关系的解集),如果$( a _1 , a _2 ) \in R $,就称$a _1 , a _2 $有关系$R $,记作$a _1 Ra _2 $,注意这里有序.</p>
<p>如果$R $满足以下三个性质:</p>
<ol>
<li><p>反身性:$\forall a \in A , aRa $.</p>
</li>
<li><p>对称性:$a _1 Ra _2 \Leftrightarrow a _2 Ra _1 $.</p>
</li>
<li><p>传递性:$a _1 Ra _2 , a _2 Ra _3 \Leftrightarrow a _1 Ra _3 $.</p>
</li>
</ol>
<p>则称$R $是一个<strong>等价关系</strong>,不难发现满足等价关系的元素构成了若干个集合,称作<strong>等价类</strong>.等价关系通常记作$\sim $.</p>
<p>如果将等价关系的(2)改作:</p>
<ol>
<li>反对称性:$a _1 Ra _2 , a _2 Ra _1 \Leftrightarrow a _1 = a _2 $.</li>
</ol>
<p>则称$R $是一个<strong>偏序关系</strong>,具有某种偏序关系的集合称为<strong>偏序集</strong>,如果任意两个元素都存在偏序关系,称作<strong>全序集</strong>.如果一个全序集的任意一个子集存在最小元,则称其为<strong>良序集</strong>.</p>
<p>偏序关系通常记作$\leq $.</p>
<h4><span id="保序映射">保序映射</span></h4><p>对于映射$f : A \rightarrow B $,如果$\forall a , a ‘ \in A , a \leq a ‘ \Rightarrow f ( a ) \leq f ( a ‘ ) $,则称其为保序的.</p>
<h4><span id="dilworth定理">Dilworth定理</span></h4><p>对于偏序集$( A , R ) $来说,定义:</p>
<ol>
<li><p>链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 1 $.</p>
</li>
<li><p>反链:$A ‘ \subseteq A , \forall x , y \in A ‘ , [ xRy \lor yRx ] = 0 $.</p>
</li>
<li><p>链覆盖:挑出最少数量的链,使得其可重复覆盖了所有点.</p>
</li>
</ol>
<p>Dilworth定理是说:一个偏序集的最长反链等于最小链覆盖.</p>
<p>考虑数学归纳,$| A | \leq 3 $显然成立.</p>
<p>当$| A | &gt; 3 $时,如果存在一个点和其它任何点都没有偏序关系,那显然把它删掉就可以数学归纳.</p>
<p>反之,设其最长反链数为$d $,下面证明其最小链覆盖也是$d $.</p>
<p>考虑取一条尽可能长的链$A ‘ $,设其中最大的为$M $,最小的为$m $(如果有多个就任取一个).</p>
<p>考虑$T = A \setminus A ‘ $,如果$T $中的最长反链数小于$d $,则数学归纳成立.</p>
<p>反之,则一定可以取出一个反链$S $,使得$S \cap A ‘ = \emptyset $.考虑设$A ^{ +  } = \{ x | x \in A \land \exists s \in S , sRx \} $,$A ^{ -  } = \{ x | x \in A \land \exists s \in S , xRs \} $.不难发现$m $一定不在$| A ^{ +  } | $中,不然取出的那条链$A ‘ $可以更长.同理$M $一定不在$| A ^{ -  } | $中,也即$| A ^+ | , | A ^- | &lt; | A | $.</p>
<p>我们又发现$A ^+ \cup A ^- = A $,原因是如果一个点不在这两个集合中,一定可以添加到最长反链中.</p>
<p>我们还发现由于偏序关系的反身性,$S \subseteq A ^{ +  } \cap A ^{ -  } $.</p>
<p>由数学归纳,$A ^+ $和$A ^- $中的最小链覆盖均为$d $,并且一个以$S $中元素开头,一个以$S $中元素结尾,我们把它俩拼起来就是一个大小为$d $的新的大小为$d $的链覆盖.而且显然不会有更优的结果了.</p>
<h4><span id="商集">商集</span></h4><p>考虑定义一种等价关系$\sim $,我们可以在此基础上定义商集$A / \sim = \{ [ a ] | a \in A \} $,其中$[ a ] $是$a $所在的等价类.</p>
<p>商群有一个很漂亮的应用是,通过$\mathbb { N  } $来定义$\mathbb { Z  } $.(默认加法和乘法都存在幺元,结合律,消去律,交换律,分配律)</p>
<p>这个是怎么做呢?考虑定义一种等价关系$\sim $,$( n , m ) \sim ( n ‘ , m ‘ ) $当且仅当$n + m ‘ = m + n ‘ $.虽然我们手上没有加法逆元和乘法逆元,但我们有加法和乘法的消去律,这样可以验证该等价关系满足反身性,传递性,对称性.</p>
<p>然后我们将$\mathbb { N  } / \sim $定义为整数,更确切地,对于任意一组$( n , m ) $其代表的就是$n - m $这个整数.</p>
<p>容易定义加法:$( n , m ) + ( n ‘ , m ‘ ) = ( n + n ‘ , m + m ‘ ) $,乘法$( n , m ) \times ( n ‘ , m ‘ ) = ( mm ‘ + nn ‘ , mn ‘ + m ‘ n ) $.也可以定义大小关系$( n , m ) \leq ( n ‘ , m ‘ ) \Leftrightarrow n + m ‘ \leq m + n ‘ $.</p>
<p>不过由于我们定义的是等价类,所以还要证明这样的定义是良定义的,这个是容易验证的.</p>
<p>还有相反数,定义$- ( n , m ) = ( m , n ) $即可,容易验证二者之和处于$( 0 , 0 ) $这个等价类,也容易验证相反数唯一.</p>
<p>同理可以用$\mathbb { Z  } $构造$\mathbb { Q  } $,构造二元组$\mathbb { Z  } \times \mathbb { N  } _+ $,定义$( r , s ) \sim ( r ‘ , s ‘ ) \Leftrightarrow rs ‘ = r ‘ s $,容易验证其满足等价关系的性质.实际上其对应的就是$\frac { r  } { s  } $这个有理数,对着构造四则运算即可.</p>
<h3><span id="zfc公理体系">ZFC公理体系</span></h3><h4><span id="外延公理">外延公理</span></h4><p>$A = B \Leftrightarrow ( A \subset B ) \land ( B \subset A ) $.</p>
<h4><span id="配对公理">配对公理</span></h4><p>对于任意元素$a , b $,存在集合$\{ a , b \} $.特别地,当$a = b $的时候存在集合$\{ a \} $.</p>
<p>值得一提的是可以将数对$( a , b ) $定义为$\{ \{ a \} , \{ a , b \} \} $,下面的幂集公理说明了数对属于$2 ^{ 2 ^{ A \cup B  }  } , a \in A , b \in B $.</p>
<h4><span id="分离公理模式">分离公理(模式)</span></h4><p>对于一个集合$A $,和一个性质$P $,若$\alpha $满足性质$P $则称$P ( \alpha ) $.那么存在集合:</p>
<script type="math/tex; mode=display">
\{ x | x \in A \land P ( x ) \}</script><p>注意全体集合并不构成集合(ZFC公理体系不提供一种方式生成全体集合的集合),因此分离公理避免了罗素悖论.</p>
<p>之所以称为模式,是因为其对于每个性质$P $都构造了相应的公理.</p>
<h4><span id="并集公理">并集公理</span></h4><p>允许将集合取并.</p>
<h4><span id="幂集公理">幂集公理</span></h4><p>一个集合的所有子集构成一个新的集合(可以记作$2 ^A $).</p>
<h4><span id="无穷公理">无穷公理</span></h4><p>称满足以下性质的集合为归纳集:</p>
<ol>
<li><p>$\emptyset \in A $.</p>
</li>
<li><p>若$\alpha \in A $,则$\{ \alpha \} \cup \alpha \in A $.</p>
</li>
</ol>
<p>则归纳集存在.</p>
<h4><span id="替换公理模式">替换公理(模式)</span></h4><p>对于集合$A $和一种定义在集合$A $上的映射$F $,存在集合$A ‘ $使得$x \in A ‘ \Leftrightarrow x = F ( a ) , a \in A $.</p>
<p>用替换公理可以证明映射也是一种集合,并且从$A \rightarrow B $的所有映射可以构成集合,可以记作$B ^A $.</p>
<h4><span id="正则公理">正则公理</span></h4><p>对任何非空集合$A $,存在$a \in A $使得$\forall a ‘ \in A $,$a ‘ \notin a $,也就是$a \cap A = \emptyset $.</p>
<h4><span id="选择公理">选择公理</span></h4><p>说对于任何一族非空集$A $,总能从其中的每个集合$a $选出一个元素.</p>
<p>选择公理独立于其它的集合公理,一些数学家好像还不愿意承认选择公理.</p>
<p>选择公理等价于另外两个命题:Zorn引理和良序定理.</p>
<h5><span id="zorn引理">Zorn引理</span></h5><p>如果$X $上的一个偏序关系$\leq $,满足其每条链$A $都存在上界($\exists x \in X , \forall a \in A , x \geq a $),那么$X $存在极大元$( \exists x \in X , \forall a \in X , a \geq x \Rightarrow a = x ) $.</p>
<p>Zorn引理可以证明选择公理,简单来说就是定义偏序关系$( A ‘ ‘ , g ‘ ‘ ) \leq ( A ‘ , g ‘ ) $当且仅当$A ‘ ‘ \subseteq A ‘ $并且$\forall x \in A ‘ ‘ , g ‘ ‘ ( x ) = g ‘ ( x ) $.这样拿出来的极大元就是我们需要的$A \rightarrow g ( A ) $.</p>
<h5><span id="良序定理">良序定理</span></h5><p>所有的集合都可以被良序排列,或者说都存在一种偏序,使得其任意子集都是良序集.</p>
<p>良序定理的证明要用的Zorn引理,即考虑所有的二元对$( S , R ) $组成的集合,其中满足$S $对于偏序关系$R $来说是良序的,我们定义两个二元对$a , b $满足$a \leq b $当且仅当它们的$R $相等并且$S _a \subseteq S _b $.现在取出一个全序的子集并找到其中最大的集合(也就是其它所有集合的并)$( S , R ) $,注意到如果$S $是全集则证毕,如果不是,则取一个全集中不在$S $的元素$x $接到$S $的后面得到了一个更大的集合,这就产生了矛盾,具体细节过程可以参考下面关于集合基数的全序性的证明.</p>
<p>良序定理可以证明选择公理,因为只需每个集合选最小的元素再用替换公理模式换掉就行了.</p>
<h3><span id="集合的基数">集合的基数</span></h3><p>如果存在单射$\varphi : A \rightarrow B $,则称$| A | \leq | B | $.如果存在双射,则称$| A | = | B | $.</p>
<p>如果使用选择公理的话,可以说明如果存在满射$\varphi : A \rightarrow B $,则称$| A | \geq | B | $.</p>
<p>值得一提的是这种偏序关系是全序的,这个怎么证明呢?</p>
<p>考虑现在有$A , B $两个集合,接下来我们证明一定存在一个从$A $到$B $的映射,且其要么为单射要么为满射.</p>
<p>我们记$X $为所有$A $的子集到$B $的单射组成的集合,并且我们定义这样一种偏序关系:若$f : A _f \rightarrow B , g : A _g \rightarrow B , A _f \subseteq A _g , \forall a \in A _f , f ( a ) = g ( a ) $.</p>
<p>这样的话,我们不妨取出$X $的一个全序的子集$I $,显然其存在上界.</p>
<p>根据Zorn引理,$X $存在极大元$g : A _g \rightarrow B $,此时我们开始讨论:</p>
<p>如果$A _g = A $,那么找到了一个单射$g : A \rightarrow B $.</p>
<p>反之,如果$A _g \subsetneq A $,考虑如果$g ( A _g ) = B $,也就是找到了一个满射;反之,考虑取$a ‘ \in A \setminus A _g , b ‘ \in B \setminus g ( A _g ) $,在$g $的基础上加上映射$a ‘ \mapsto b ‘ $,这是一个比$g $还要大的元,不符合Zorn引理.</p>
<h4><span id="cantor-bernstein定理">Cantor-Bernstein定理</span></h4><p>如果$| A | \leq | B | \land | B | \leq | A | $,则$| A | = | B | $.</p>
<p>不妨设$f : A \rightarrow B , g : B \rightarrow A $我们考虑一个感性的做法:考虑将这个东西画成二分图,然后要找它的完美匹配.我们不妨先把不同的连通块拆开,你会发现大部分的图都可以用$f , f ^{ - 1  } $来构造双射,只有一种除外:那就是以一个$B $中节点开始不断延伸的无限的,我们在这里使用$g , g ^{ - 1  } $来构造即可.</p>
<p>如果要把上面的东西写成形式化的东西,我们可以这么写:取$C _0 = B \setminus f ( A ) $,$C _n = f ( g ( C _{ n - 1  } ) ) $,那么对于$C = \cup _{ n \geq 0  } C _n $,使用$g , g ^{ - 1  } $构造双射,剩下的使用$f , f ^{ - 1  } $构造双射.</p>
<h4><span id="可数无穷与不可数无穷">可数无穷与不可数无穷</span></h4><p>我们称集合$A $是<strong>可数</strong>的,当且仅当$| A | = | \mathbb { N  } | $.</p>
<p>我们可以发现可数个可数集合的并一定可数,因为你可以把这些位置全排列起来然后绕着数.</p>
<p>这样就可以发现,首先整系数多项式方程有可数个,因此整系数多项式方程的根也有可数个,我们将这些数称作代数数,其它实数称为超越数.</p>
<p>这又有一个结论是说,代数数对四则运算构成域.</p>
<p>首先一个代数数的加法逆元和乘法逆元(只要不是$0 $)肯定一定是代数数,你只需要对着原方程改一改就可以构造出新方程.</p>
<p>幺元肯定也是存在的,因为$1 $和$0 $显然都是代数数.</p>
<p>我们接下来看两个代数数$x , y $.考虑如何构造$x + y $作为根的方程.</p>
<p>下面是qyc老师给的做法,直接考虑有方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
X & = \sum _{ k = 0  } ^n a _k x ^k & = 0 \\
Y & = \sum _{ k = 0  } ^m b _k y ^k & = 0 
\end{aligned}</script><p>对于加法,考虑:$( x + y ) ^0 , ( x + y ) ^1 , \cdots $,这些东西,先把它们对$X $取膜再对$Y $取膜,得到的一定是$nm $维的,只需要取$nm + 1 $个就会出现线性相关.乘法同理考虑$( xy ) ^0 , ( xy ) ^1 , \cdots $即可.</p>
<p>值得一提的是,$| \mathbb { R  } | = 2 ^{ | \mathbb { N  } |  } $.这个是怎么构造的呢?只需要证明$[ 0 , 1 ] $上的实数和自然数集合能一一对应就可以了对吧,考虑将这些实数写成二进制下的形式,然后如果$k $在取出的自然数子集中,那么小数点后第$k + 1 $位为$1 $否则为$0 $,这样就构造了一组映射.</p>
<p>不过其实这样做有一点小问题,那就是$0 . 1 = 0 . 0111 \cdots $,但这两个数字对应的集合并不相等.然而会出问题的点的个数是可数无穷个,因此其实差一下也没什么问题.如果或者可以反复来一下证明$| \mathbb { R  } | \leq 2 ^{ | \mathbb { N  } |  } $并且$| \mathbb { R  } | \geq 2 ^{ | \mathbb { N  } |  } $,用上面的构造就行.</p>
<h2><span id="简单范畴论">简单范畴论</span></h2><h3><span id="范畴">范畴</span></h3><p>一个<strong>范畴</strong>$\mathcal { C  } $应当包含以下:</p>
<ol>
<li><p>一个类$\rm { Ob  } ( \mathcal { C  } ) $,其元素称作$\mathcal { C  } $的<strong>对象</strong>.</p>
</li>
<li><p>对于$X , Y \in \rm { Ob  } ( \mathcal { C  } ) $指定一个集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,称作$\mathcal { C  } $中从$X $到$Y $的<strong>态射</strong>.</p>
</li>
</ol>
<p>对于态射来说,其还应当具有以下特点:</p>
<ol>
<li><p>对于$X \in \text { Ob  } ( \mathcal { C  } ) $存在其到自身的<strong>恒等态射</strong>$\text { id  } _X \in \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>态射间可以进行合成,换言之存在<strong>合成映射</strong>$\circ : \text { Hom  } _{ \mathcal { C  }  } ( Y , Z ) \times \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , ( g , f ) \mapsto g \circ f $.</p>
</li>
</ol>
<p>另外,合成映射还应当满足:</p>
<ol>
<li><p><strong>结合律</strong>:对于$\mathcal { C  } $中的态射$h , g , f $,如果合成有意义,那么$h ( gf ) = ( hg ) f $.</p>
</li>
<li><p><strong>单位元</strong>:对于$f \in \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,$f \circ \text { id  } _X = f = \text { id  } _Y \circ f $.</p>
</li>
</ol>
<p>由上得知恒等态射的唯一性,因为如果存在两种恒等态射,必定有$\text { id  } _X = \text { id  } _X \text { id ‘  } _X = \text { id ‘  } _X $.</p>
<p>在此基础上可以定义所谓<strong>交换图表</strong>,意味着态射的合成是所谓殊途同归的.例如,如果下面这个图表是交换的:</p>
<script type="math/tex; mode=display">
\xymatrix { R \ar [r ] ^u \ar [d ] _x & S \ar [d ] ^v \\
T \ar [r ] _y & U  }</script><p>这意味着$yx = vu $.</p>
<p>必须要指出的是,我们这里范畴所包含的对象并不是单指某一特定元素,而也有可能是某一数学结构(例如集合).</p>
<p>特别地,如果:</p>
<ol>
<li><p>如果对于$f \in \text { Hom  } ( X , Y ) $,$\exists g \in \text { Hom  } ( Y , X ) $使得$gf = \text { id  } _X $,那么称$g $是$f $的一个<strong>左逆</strong>,称$f $是<strong>左可逆</strong>的或者是<strong>单态射</strong>.同理可以定义<strong>右逆</strong>以及所谓<strong>满态射</strong>.</p>
</li>
<li><p>如果$f $左右均可逆,易见左右逆相等,记作$f ^{ - 1  } $,易见$f ^{ - 1  } $可逆而且$( f ^{ - 1  } ) ^{ - 1  } = f $.此时称$f $是<strong>同构</strong>的.</p>
</li>
</ol>
<p>同构还有以下性质:</p>
<ol>
<li><p>$( \text { id  } _X ) ^{ - 1  } = \text { id  } _X $.</p>
</li>
<li><p>如果$f $和$g $均为同构并且合成有意义,那么$gf $是同构并且$( gf ) ^{ - 1  } = f ^{ - 1  } g ^{ - 1  } $.</p>
</li>
</ol>
<p>于是在此基础上追加定义:</p>
<ol>
<li><p>自同态幺半群:$\text { End  } _{ \mathcal { C  }  } ( X ) = \text { Hom  } _{ \mathcal { C  }  } ( X , X ) $.</p>
</li>
<li><p>自同构群:$\text { Aut  } _{ \mathcal { C  }  } ( X ) = ( \text { End  } _{ \mathcal { C  }  } ( X ) ) ^\times $.</p>
</li>
</ol>
<p>如此起名的原因是由抽象代数知识见到$\text { End  } $对二元运算$\circ $构成幺半群,$\text { Aut  } $则构成群.</p>
<p>我们还可以定义所谓<strong>子范畴</strong>.称$\mathcal { C  } ‘ $是$\mathcal { C  } $的子范畴当且仅当:</p>
<ol>
<li><p>$\text { Ob  } ( \mathcal { C  } ‘ ) \subseteq \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $都有$\text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \subseteq \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$\text { id  } _X = \text { id  } _X ‘ $.</p>
</li>
<li><p>态射在$\mathcal { C  } ‘ $中的合成运算应从$\mathcal { C  } $中继承而来.</p>
</li>
</ol>
<p>特别地,如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) , \text { Hom  } ( X , Y ) _{ \mathcal { C  } ‘  } = \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,则称$\mathcal { C  } ‘ $是$\mathcal { C  } $的一个全子范畴.</p>
<h3><span id="泛性质初步">泛性质初步</span></h3><p>如果$\mathcal { C  } $是一个范畴,其中有一个元素$X \in \mathrm { Ob  } ( \mathcal { C  } ) $,如果$\forall Y \in \mathrm { Ob  } ( { \mathcal { C  }  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称它是始(initial)的.类似地,如果对于$Y \in \mathrm { Ob  } ( \mathcal { C  } ) $,$\forall X \in \mathrm { Ob  } ( \mathcal { C  } ) $,$| \mathrm { Hom  } _{ \mathcal { C  }  } ( X , Y ) | = 1 $,则称$Y $是终(terminal)的.</p>
<p>现在我们有以下结论:</p>
<ol>
<li><p>如果$X , X ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是initial的,则存在一个唯一的同构$a : X \cong X ‘ $.</p>
</li>
<li><p>如果$Y , Y ‘ \in \mathrm { Ob  } ( \mathcal { C  } ) $都是terminal的,则存在一个唯一的同构$b : Y \cong Y ‘ $.</p>
</li>
</ol>
<p>二者均是显然的,请自行检验.</p>
<p>这个结论是泛性质方法的基础.</p>
<h3><span id="函子">函子</span></h3><p>我们定义从$\mathcal { C  } ‘ $到$\mathcal { C  } $的<strong>函子</strong>$F $需要有以下性质:</p>
<ol>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,指定一个$\mathcal { C  } $中的对象$FX $.或记作$F : \text { Ob  } ( \mathcal { C  } ‘ ) \to \text { Ob  } ( \mathcal { C  } ) $.</p>
</li>
<li><p>$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,对于态射$f : X \to Y $指定一个$\mathcal { C  } $中的对象$Ff $.或记作$F : \text { Hom  } _\mathcal { C  } ‘ ( X , Y ) \to \text { Hom  } _\mathcal { C  } ( FX , FY ) $.</p>
</li>
</ol>
<p>上述对态射的函子还应当满足以下性质:</p>
<ol>
<li><p>$\forall g , f \in \text { Hom  } _{ \mathcal { C  } ‘  } $,它们的合成有意义,则$F ( gf ) = F ( g ) F ( f ) $.</p>
</li>
<li><p>$\forall X \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F ( \text { id  } _X ) = \text { id  } _{ FX  } $.</p>
</li>
</ol>
<p>我们一般也将上述函子记作$F : \mathcal { C  } ‘ \to \mathcal { C  } $.这当然意味着函子是可以合成的并仍然满足结合律.</p>
<p>既然$F $可以在某种程度上看作映射,我们当然还可以引出以下定义:</p>
<ol>
<li><p>如果$\forall T \in \text { Ob  } ( \mathcal { C  } ) , \exists X \in \text { Ob  } ( \mathcal { C  } ‘ ) $使得$T \cong FX $,则称$F $是<strong>本质满</strong>的.</p>
</li>
<li><p>如果$\forall X , Y \in \text { Ob  } ( \mathcal { C  } ‘ ) $,$F : \text { Hom  } _{ \mathcal { C  } ‘  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( FX , FY ) $均为单射,则称$F $是<strong>忠实</strong>的.如果均为满射,则称其为<strong>全</strong>的.如果均为双射,则称其为<strong>全忠实</strong>的.</p>
</li>
</ol>
<p>回忆到Haskell语言中对函子的定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span> :: (a-&gt;b)-&gt;f a-&gt; f b</span><br><span class="line">(&lt;$) :: b -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$) = fmap.const</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a-&gt;b)-&gt;f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>
<p>回忆到Haskell语言中对函子的要求:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id == id</span><br><span class="line"><span class="title">fmap</span> (f.g)==(fmap f).(fmap g)</span><br></pre></td></tr></table></figure>
<p>容易见到其类似性.</p>
<p>函子的类型很多,比如最平凡的一类函子是所谓<strong>忘却函子</strong>.但我们在这里着重提所谓$\text { Hom  } $函子,其是Haskell语言中Curring化的基础:</p>
<p>对于范畴$\mathcal { C  } $以及其对象$X $,我们定义函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) : \mathcal { C  } \to Set $,它映对象$Y $为集合$\text { Hom  } _{ \mathcal { C  }  } ( X , Y ) $,映态射$f : Y \to Z $为映射$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) f : \text { Hom  } _{ \mathcal { C  }  } ( X , Y ) \to \text { Hom  } _{ \mathcal { C  }  } ( X , Z ) , h \mapsto f \circ h $.</p>
<p>同理可以定义函子$\text { Hom  } _{ \mathcal { C  }  } ( \cdot , X ) $.</p>
<p>对于函子$\text { Hom  } _{ \mathcal { C  }  } ( X , \cdot ) $,我们可以一窥其在Haskell中的具体定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- fmap :: (b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">fmap</span> fbc fab = fbc.fab</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- pure :: c-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="comment">-- &lt;*&gt; :: (a-&gt;(b-&gt;c))-&gt;(a-&gt;b)-&gt;(a-&gt;c)</span></span><br><span class="line"><span class="title">pure</span> tb = \ta -&gt; tb</span><br><span class="line">(&lt;*&gt;) fabc fab = \ta -&gt; ((fmap (fabc ta) fab) ta)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line"><span class="comment">-- (&gt;&gt;=) :: (r-&gt;a)-&gt;(a-&gt;(r-&gt;b))-&gt;(r-&gt;b)</span></span><br><span class="line">(&gt;&gt;=) fra farb = \tr -&gt; ( farb (fra tr) tr )</span><br></pre></td></tr></table></figure>
<h3><span id="范畴实例">范畴实例</span></h3><h4><span id="kleisli范畴">Kleisli范畴</span></h4><p>简单理解Kleisli范畴的话就是,我们被允许给一个元素进行如下的操作:</p>
<ol>
<li><p>加上修饰.</p>
</li>
<li><p>合并修饰.</p>
</li>
</ol>
<p>Kleisili范畴在Haskell里的具体表现就是Monad.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">fmap</span>        :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$)        :: a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$)        =  fmap . const</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line"><span class="title">pure</span> :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line"><span class="title">return</span> :: a -&gt; m a</span><br><span class="line"><span class="title">return</span> = pure</span><br><span class="line"><span class="title">join</span> :: m(m a)-&gt; m a</span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"><span class="title">ma</span> &gt;&gt;= f = join (fmap f ma)</span><br><span class="line">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">组合数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2><h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3><p>定义下降幂$x ^{ \underline { k  }  } = \prod _{ i = 0  } ^{ k - 1  } ( x - i ) = \frac { x !  } { ( x - k ) !  } $.</p>
<p>定义上升幂$x ^{ \overline { k  }  } \prod _{ i = 0  } ^{ k - 1  } ( x + i ) = \frac { ( x + k - 1 ) !  } { ( x - 1 ) !  } $.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:$r ^{ \underline { k  }  } ( r - 0 . 5 ) ^{ \underline { k  }  } = \cfrac { ( 2 r ) ^{ \underline { 2 k  }  }  } { 2 ^{ 2 k  }  } , k \in \mathbb { N  } $.</p>
<p>他们之间存在转换:$x ^{ \underline { n  }  } = ( - 1 ) ^n ( - x ) ^{ \overline { n  }  } $.</p>
<p>同时存在大小关系:$x ^{ \underline { n  }  } \leq x ^n \leq x ^{ \overline { n  }  } $,其中$0 \leq n &lt; x $.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3><p>考虑令$\binom { n  } { m  } $表示从一个大小为$n $的子集中选出大小为$m $的子集的方案数.第一次有$n $个选择,第二次有$n - 1 $个选择……第m次有$n - m + 1 $个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是$m ! $,因此显然有$\binom { n  } { m  } = \cfrac { n ^{ \underline { m  }  }  } { m !  } $.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
<p>$\binom { r  } { k  } = \begin{cases}\cfrac { r ^{ \underline { k  }  }  } { k !  } &amp; k \geq 0 \ 0 &amp; k &lt; 0 \end{cases} , r \in \mathbb { C  } , k \in \mathbb { Z  } $.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把$\binom { r  } { k  } $看作了一个关于$r $的$k $次多项式.</p>
<p>另外根据定义,$r \in \mathbb { Z  } \land r &lt; k $时,该公式给出$0 $.</p>
<p>值得一提的是,为了使二项式系数在面对$0 $的时候更加简洁,通常直接定义$0 ! = 1 , 0 ^0 = 1 $.</p>
<p>另外不难发现$\binom { 2 n  } { n  } $是所有$\binom { 2 n  } { k  } $中最大的.事实上我们有Wallis公式:$\lim _{ n \rightarrow \infty  } \frac { ( \frac { 2 ^{ 2 n  }  } { \binom { 2 n  } { n  }  } ) ^2  } { 2 n + 1  } = \frac { \pi  } { 2  } $.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3><ol>
<li>阶乘展开式:$\binom { n  } { k  } = \cfrac { n !  } { k ! ( n - k ) !  } , n , k \in \mathbb { N  } , n \geq k \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol>
<li>对称恒等式:$\binom { n  } { k  } = \binom { n  } { n - k  } , n \in \mathbb { N  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>根据$( 1 ) $,$0 \leq k \leq n $时是显然的.而其他情况两边都会给出$0 $,因此也是成立的.</p>
<ol>
<li>吸收恒等式:$\binom { r  } { k  } = \cfrac { r  } { k  } \binom { r - 1  } { k - 1  } , k \in \mathbb { Z  } \land k \ne 0 \ $.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol>
<li>吸收恒等式的变式:$k \binom { r  } { k  } = r \binom { r - 1  } { k - 1  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>根据$( 3 ) $,只需要验证$k = 0 $的情况即可,也是显然的.</p>
<ol>
<li>相伴恒等式:$( r - k ) \binom { r  } { k  } = r \binom { r - 1  } { k  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( r - k ) \binom { r  } { k  } & = ( r - k ) \binom { r  } { r - k  } \\
& = r \binom { r - 1  } { r - k - 1  } \\
& = r \binom { r - 1  } { k  } 
\end{aligned}</script><p>问题在于:我们在上述描述中并未提到$r $的范围,但是推导过程要求$r \in \mathbb { N  } $.不过,我们已经说明了二项式系数是关于$r $的$k $次多项式,因此只需要有$k + 1 $个$r $满足这个公式即可.而根据推导过程显然有无限个$r $满足,因此这个公式对$r \in \mathbb { C  } $也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k \binom { r  } { k  } & = r \binom { r - 1  } { k - 1  } \\
( r - k ) \binom { r  } { r - k  } & = r \binom { r - 1  } { r - k - 1  } \\
( r - k ) \binom { r  } { k  } & = r \binom { r - 1  } { k  } 
\end{aligned}</script><ol>
<li>加法公式:$\binom { r  } { k  } = \binom { r - 1  } { k  } + \binom { r - 1  } { k - 1  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明可以使用定义,也可以先用$r \in \mathbb { N  } $的情况给出组合意义,再使用多项式推理法证明.</p>
<ol>
<li>$\binom { r  } { m  } \binom { m  } { k  } = \binom { r  } { k  } \binom { r - k  } { m - k  } , n , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol>
<li>平行求和法:$\sum _{ k \leq n  } \binom { r + k  } { k  } = \binom { r + n + 1  } { n  } , n \in \mathbb { N  } \ $.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p>$\binom { r + n + 1  } { n  } = \binom { r + n  } { n  } + \binom { r + n  } { n - 1  } = \binom { r + n  } { n  } + \binom { r + n - 1  } { n - 1  } + \binom { r + n - 1  } { n - 2  } = . . . \ $,最终下标会减成负数,这样后面的项就全都是$0 $了.</p>
<p>也可以考虑组合意义:如果$r \in \mathbb { N  } $,那么我们考虑从右到左第一个没有被选上的数,假设它是$r + k + 1 $,那么在它右边的数全部选择了,一共是$n - k $个数,而还需要在左边的$r + k $中选择$k $个数.</p>
<ol>
<li>上指标求和法:$\sum _{ 0 \leq k \leq n  } \binom { k  } { m  } = \binom { n + 1  } { m + 1  } , n , m \in \mathbb { N  } \ $.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是$k + 1 $,接下来就还需要在$[ 1 , k ] $中选择$m $个.</p>
<p>如果我们将这个公式两边同时乘以$m ! $,我们可以得到公式:$\sum _{ 0 \leq k \leq n  } k ^{ \underline { m  }  } = \cfrac { ( n + 1 ) ^{ \underline { m + 1  }  }  } { m + 1  } , n , m \in \mathbb { N  } \ $,这也就是有限微积分的公式中的一个.</p>
<ol>
<li>二项式定理:$( x + y ) ^r = \sum _{ k  } \binom { r  } { k  } x ^k y ^{ r - k  } , r \in \mathbb { N  } \ $.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq k \leq n  } \binom { n  } { k  } & = 2 ^n , n \in \mathbb { N  } \\

\end{aligned}</script><p>在二项式定理中令$x = y = 1 $即可证明.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq k \leq n  } ( - 1 ) ^k \binom { n  } { k  } & = 0 ^n & = [ n & = 0 ] , n \in \mathbb { N  } \\

\end{aligned}</script><p>在二项式定理中令$x = - 1 , y = 1 $即可证明,值得一提的是,当$n = 0 $的时候这个式子给出$1 $,并在其他情况下给出$0 $,这个式子是二项式反演的基础.</p>
<ol>
<li>三项式定理:$( x + y + z ) ^n = \sum _{ 0 \leq a , b , c \leq n  } [ a + b + c = n ] \cfrac { n !  } { a ! b ! c !  } x ^a y ^b z ^c , n \in \mathbb { N  } \ $.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,$\cfrac { n !  } { a ! b ! c !  } = \binom { n  } { b + c  } \binom { b + c  } { c  } $.</p>
<ol>
<li>多项式定理:$( \sum _{ i = 1  } ^m x _i ) ^n = \sum _{ \forall i \in [ 1 , m ] , 0 \leq a _i \leq n  } [ \sum _{ i = 1  } ^m a _i = n ] \cfrac { n !  } { \prod _{ i = 1  } ^m a _i !  } \prod _{ i = 1  } ^m x _i ^{ a _i  } , n \in \mathbb { N  } \ $.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol>
<li>范德蒙德卷积:$\sum _{ k  } \binom { r  } { m + k  } \binom { s  } { n - k  } = \binom { r + s  } { n + m  } , n , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol>
<li>范德蒙德卷积的变式:$\sum _{ k  } \binom { l  } { m + k  } \binom { s  } { n + k  } = \binom { l + s  } { l - m + n  } , l \in \mathbb { N  } , n , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>有$\binom { l  } { m + k  } = \binom { l  } { l - m - k  } $,然后运用范德蒙德卷积即可得到答案.</p>
<ol>
<li>上指标反转公式:$\binom { r  } { k  } = ( - 1 ) ^k \binom { k - r - 1  } { k  } \ $.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3><ol>
<li>$\sum _{ k \leq m  } \binom { r  } { k  } ( - 1 ) ^k = ( - 1 ) ^m \binom { r - 1  } { m  } , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k \leq m  } \binom { r  } { k  } ( - 1 ) ^k & = \sum _{ k \leq m  } \binom { k - r - 1  } { k  } \\
& = \binom { - r + m  } { m  } & = ( - 1 ) ^m \binom { r - 1  } { m  } 
\end{aligned}</script><ol>
<li>$\sum _{ - q \leq k \leq l  } \binom { l - k  } { m  } \binom { q + k  } { n  } = \binom { l + q + 1  } { m + n + 1  } , n , m \in \mathbb { N  } , l + q \geq 0 \ $.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol>
<li>$\sum _{ k  } \binom { a + b  } { a + k  } \binom { a + b  } { b + k  } ( - 1 ) ^k = \binom { a + b  } { a  } , a , b \in \mathbb { N  } \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol>
<li>$\sum _{ k = 0  } ^m \cfrac { \binom { m  } { k  }  } { \binom { n  } { k  }  } = \cfrac { n + 1  } { n + 1 - m  } , n , m \in \mathbb { N  } , n \geq m \ $.</li>
</ol>
<p>我们有$\binom { n  } { m  } \binom { m  } { k  } = \binom { n  } { k  } \binom { n - k  } { m - k  } \ $,两边同时除以$\binom { n  } { m  } \binom { n - k  } { m - k  } \ $,于是我们得到了$\cfrac { \binom { m  } { k  }  } { \binom { n  } { k  }  } = \cfrac { \binom { n - k  } { m - k  }  } { \binom { n  } { m  }  } \ $.</p>
<p>有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^m \cfrac { \binom { m  } { k  }  } { \binom { n  } { k  }  } & = \sum _{ k = 0  } ^m \cfrac { \binom { n - k  } { m - k  }  } { \binom { n  } { m  }  } \\
& = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m \binom { n - k  } { m - k  } \\
& = \cfrac { 1  } { \binom { n  } { m  }  } \sum _{ k = 0  } ^m \binom { n - m + k  } { k  } \\
& = \cfrac { \binom { n + 1  } { m  }  } { \binom { n  } { m  }  } \\
& = \cfrac { n + 1  } { n + 1 - m  } 
\end{aligned}</script><ol>
<li>$( - 1 ) ^m \binom { - n - 1  } { m  } = ( - 1 ) ^n \binom { - m - 1  } { n  } , n , m \in \mathbb { N  } \ $.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于$\binom { n + m  } { m  } \ $.</p>
<ol>
<li>$\sum _{ k \leq m  } \binom { r  } { k  } ( \cfrac { r  } { 2  } - k ) = \cfrac { m + 1  } { 2  } \binom { r  } { m + 1  } , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol>
<li>$\sum _{ k \leq m  } \binom { m + r  } { k  } x ^k y ^{ m - k  } = \sum _{ k \leq m  } \binom { - r  } { k  } ( - x ) ^k ( x + y ) ^{ m - k  } , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>不妨令左边的值为$S _m $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _m & = \sum _{ k \leq m  } \binom { m + r  } { k  } x ^k y ^{ m - k  } & = \sum _{ k \leq m  } \binom { m + r - 1  } { k  } x ^k y ^{ m - k  } + \sum _{ k \leq m  } \binom { m + r - 1  } { k - 1  } x ^k y ^{ m - k  } \\
& = y \sum _{ k < m  } \binom { m - 1 + r  } { k  } x ^k y ^{ m - 1 - k  } + \binom { m + r - 1  } { m  } x ^m + x \sum _{ k \leq m  } \binom { m + r - 1  } { k - 1  } x ^{ k - 1  } y ^{ m - k  } \\
& = ( x + y ) S _{ m - 1  } + \binom { m + r - 1  } { m  } x ^m \\
& = ( x + y ) S _{ m - 1  } + \binom { r  } { m  } ( - x ) ^m 
\end{aligned}</script><p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol>
<li>$\sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ - k  } = 2 ^m , m \in \mathbb { N  } \ $.</li>
</ol>
<p>考虑$( 7 ) $,将$x = y = 1 , r = m + 1 $带入,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k \leq m  } \binom { 2 m + 1  } { k  } & = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ m - k  } \\
2 ^{ 2 m  } & = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ m - k  } \\
2 ^m & = \sum _{ k \leq m  } \binom { m + k  } { k  } 2 ^{ - k  } 
\end{aligned}</script><ol>
<li>$\sum _{ k  } \binom { l  } { m + k  } \binom { s + k  } { n  } ( - 1 ) ^k = ( - 1 ) ^{ l + m  } \binom { s - m  } { n - l  } , l \in \mathbb { N  } , n , m \in \mathbb { Z  } \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol>
<li>$\sum _{ k \leq l  } \binom { l - k  } { m  } \binom { s  } { k - n  } ( - 1 ) ^k = ( - 1 ) ^{ l + m  } \binom { s - m - 1  } { l - n - m  } , l , n , m \in \mathbb { N  } \ $.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3><ol>
<li>$\binom { r  } { k  } \binom { r - \cfrac { 1  } { 2  }  } { k  } = \cfrac { \binom { 2 r  } { 2 k  } \binom { 2 k  } { k  }  } { 2 ^{ 2 k  }  } , k \in \mathbb { Z  } \ $.</li>
</ol>
<p>将加倍公式两边同时除以$k ! ^2 $即可得到这个公式.</p>
<ol>
<li>$\binom { n - \cfrac { 1  } { 2  }  } { n  } = \cfrac { \binom { 2 n  } { n  }  } { 2 ^{ 2 n  }  } , n \in \mathbb { Z  } \ $.</li>
</ol>
<p>将$( 1 ) $中令$r = k = n $即可得到这个公式.</p>
<ol>
<li>$\binom { - \cfrac { 1  } { 2  }  } { n  } = ( \cfrac { - 1  } { 4  } ) ^n \binom { 2 n  } { n  } , n \in \mathbb { Z  } \ $.</li>
</ol>
<p>即$( 2 ) $的变形.</p>
<ol>
<li>$\sum _{ k  } \binom { n  } { 2 k  } \binom { 2 k  } { k  } 2 ^{ - 2 k  } = \binom { n - \cfrac { 1  } { 2  }  } { \lfloor \cfrac { n  } { 2  } \rfloor  } , n \in \mathbb { N  } \ $</li>
</ol>
<p>首先根据$( 1 ) $,左边$= \sum _{ k  } \binom { \cfrac { n  } { 2  }  } { k  } \binom { \cfrac { n - 1  } { 2  }  } { k  } \ $,而考虑到$\cfrac { n  } { 2  } $和$\cfrac { n - 1  } { 2  } $必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol>
<li>$\sum _{ k  } \binom { - \cfrac { 1  } { 2  }  } { k  } \binom { - \cfrac { 1  } { 2  }  } { n - k  } = ( - 1 ) ^n , n \in \mathbb { N  } \ $.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol>
<li>$\sum _{ k  } \binom { 2 k  } { k  } \binom { 2 n - 2 k  } { n - k  } = 4 ^n , n \in \mathbb { N  } \ $.</li>
</ol>
<p>由$( 5 ) $和$( 3 ) $不难推出.</p>
<ol>
<li>$\sum _{ k  } \binom { n  } { k  } \cfrac { ( - 1 ) ^k  } { x + k  } = x ^{ - 1  } \binom { x + n  } { n  } ^{ - 1  } , x \notin \{ 0 , - 1 , . . . , - n \} \ $.</li>
</ol>
<p>令$f ( x ) = ( x - 1 ) ^{ \underline { - 1  }  } $,直接做高阶差分即可得到这个式子.</p>
<ol>
<li>$\sum _{ k = 0  } ^n \binom { r  } { k  } \binom { r  } { n - k  } ( - 1 ) ^k = [ n  is  \mathrm { even  } ] ( - 1 ) ^{ \cfrac { n  } { 2  }  } \binom { r  } { \cfrac { n  } { 2  }  } \ $.</li>
</ol>
<p>首先不难发现,$( 1 - z ) ^r = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { r  } { k  } \ $.</p>
<p>考虑$( 1 - z ) ^r ( 1 + z ) ^r = ( 1 - z ^2 ) ^r $.</p>
<p>我们有$[ z ^n ] ( 1 - z ) ^r ( 1 + z ) ^r = [ z ^n ] ( 1 - z ^2 ) ^r $,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3><p>卡特兰数$f _n $表示:长度为$2 n $的合法括号序列个数.</p>
<p>卡特兰数的前几项为$1 , 1 , 2 , 5 , 14 , 42 , 132 \cdots $.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:$f _n = \sum _{ i = 0  } ^{ n - 1  } f _i f _{ n - 1 - i  } $.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如$( A ) B $.</p>
<p>考虑将其删成$A $和$B $,则$A $一定合法,因为若$A $不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:$f _n = \frac { 1  } { n + 1  } C _{ 2 n  } ^n = C _{ 2 n  } ^n - C _{ 2 n  } ^{ n - 1  } $.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从$( 0 , 0 ) $走到$( 2 n , 0 ) $不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到$( 2 n , 0 ) $的方案数是$C _{ 2 n  } ^n $.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点$( x , - 1 ) $.</p>
<p>考虑将$x $以后的折线以直线$y = - 1 $为对称轴反转,那么终点到了$( 2 n , - 2 ) $.</p>
<p>不难发现,任意从$( 0 , 0 ) $走到$( 2 n , - 2 ) $的方案一定唯一对应了一种从$( 0 , 0 ) $走到$( 2 n , 0 ) $的不合法方案.因为从$( 0 , 0 ) $走到$( 2 n , - 2 ) $一定会经过直线$y = - 1 $,将后半部分对称后就是其对应方案.而从$( 0 , 0 ) $走到$( 2 n , - 2 ) $的方案数为$C _{ 2 n  } ^{ n - 1  } $.</p>
<p>因而$f _n = C _{ 2 n  } ^n - C _{ 2 n  } ^{ n - 1  } \ $.</p>
<p>而$C _{ 2 n  } ^n - C _{ 2 n  } ^{ n - 1  } = \frac { ( 2 n ) !  } { n ! n !  } - \frac { ( 2 n ) !  } { ( n - 1 ) ! ( n + 1 ) !  } = \frac { ( 2 n ) !  } { n ! ( n + 1 ) !  } = \frac { C _{ 2 n  } ^n  } { n + 1  } \ $.</p>
<p>递推定义:$f _n = \frac { 4 n - 2  } { n + 1  } f _{ n - 1  } \ $.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\frac{(2n)!}{n!(n+1)!}\\</p>
<p>f_{n-1}=\frac{(2n-2)!}{(n-1)!(n)!}</p>
<p>\end{cases}\\</p>
<p>不难发现$f _n = \frac { ( 2 n - 1 ) ( 2 n )  } { n ( n + 1 )  } f _{ n - 1  } \ $.整理,得到$f _n = \frac { 4 n - 2  } { n + 1  } f _{ n - 1  } \ $.</p>
<p>换个记号,设$C _n $为卡特兰数的第$n $项,卡特兰数有一个著名的结论是$k $次卷积:</p>
<script type="math/tex; mode=display">
C ^{ ( k )  } _n = \sum _{ \sum _{ j = 1  } ^k a _j = n  } \prod C _{ a _i  } = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  }</script><p>我们可以这么理解它:它指的是一个长度为$n + k - 1 $的括号序列,前$k - 1 $个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成$( ( ( A ) B ) C ) D $之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C ^{ ( k )  } _n & = \binom { 2 n + k - 1  } { n  } - \binom { 2 n + k - 1  } { n - 1  } \\
& = \frac { k  } { n + k  } \binom { 2 n + k - 1  } { n  } 
\end{aligned}</script><h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5><p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是$\binom { 2 n  } { n  } $.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5><p>给定$x , n $,对$y \in [ 1 , n ] $,固定$p _x = y $做笛卡尔树的<strong>形态</strong>计数.$n \leq 5 \times 10 ^5 $.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现$a _x = y $只要满足:</p>
<ol>
<li><p>$x $节点的祖先数量不超过$y - 1 $个(深度小于等于$y $).</p>
</li>
<li><p>$x $节点的子树大小不超过$n - y + 1 $.</p>
</li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出$f _p $表示$x $的深度为$p $的答案,$g _p $表示$x $的子树大小为$p $的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:$x $的祖先有两种:一种在序列中在$x $的左边,一种在$x $的右边.我们设前者为$0 = l _0 &lt; l _1 &lt; l _2 &lt; \cdots l _p &lt; l _{ p + 1  } = x $,设后者为$n + 1 = r _0 &gt; r _1 &gt; r _2 &gt; \cdots &gt; r _{ q  } &gt; r _{ q + 1  } = x $.这么分类有什么用呢?我们考虑$( l _{ i - 1  } , l _{ i  } ) $这一段数能放在哪里,它只能是$l _{ i  } $的左儿子,独立于整棵树,因此这一段的答案就是$C _{ l _i - l _{ i - 1  } - 1  } $.</p>
<p>记:</p>
<script type="math/tex; mode=display">
\begin{aligned}
L _p & = \sum _{ l  } \prod _{ i = 1  } ^{ p + 1  } C _{ l _i - l _{ i - 1  } - 1  } \\
R _q & = \sum _{ r  } \prod _{ i = 1  } ^{ q + 1  } C _{ r _{ i - 1  } - r _i - 1  } \\

\end{aligned}</script><p>注意到这等价于卡特兰数的$k $次卷积,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
L _p & = C _{ x - p - 1  } ^{ ( p + 1 )  } \\
R _q & = C ^{ ( q + 1 )  } _{ n - x - q  } \\

\end{aligned}</script><p>此时的答案自然是$f _{ p + q + 1  } = L _p R _q \binom { p + q  } { q  } $,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把$x $的子树从原树中删去,然后插入$x $一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为$p $,右子树大小为$q $,我们有$g _{ p + q + 1  } = C _p C _q C _{ n - ( p + q + 1 )  } = C _{ n - 1  } ^{ ( 3 )  } $,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3><h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4><h5><span id="example1">Example1</span></h5><p>求$\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } , n , m \in \mathbb { N  } \land m &gt; n \ $.</p>
<p>这个式子乘了个系数$k $导致很难处理,一个自然的想法是使用吸收恒等式将$k $消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } & = \sum _{ k = 0  } ^n m \binom { m - k - 1  } { m - n - 1  } - \sum _{ k = 0  } ^n ( m - k ) \binom { m - k - 1  } { m - n - 1  } \\
& = m \sum _{ k = 0  } ^{ m - 1  } \binom { m - k - 1  } { m - n - 1  } - ( m - n ) \sum _{ k = 0  } ^m \binom { m - k  } { m - n  } 
\end{aligned}</script><p>不妨令$S _m = \sum _{ k = 0  } ^m \binom { m - k  } { m - n  } \ $,不难发现我们有:</p>
<script type="math/tex; mode=display">
S _m = \sum _{ k = 0  } ^m \binom { k  } { m - n  } = \binom { m + 1  } { m - n + 1  }</script><p>于是原式$= mS _{ m - 1  } - ( m - n ) S _m = \cfrac { n  } { m - n + 1  } \binom { m  } { m - n  } \ $.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将$k = \binom { k  } { 1  } $带入:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^n k \binom { m - k - 1  } { m - n - 1  } & = \sum _{ k = 0  } ^n \binom { k  } { 1  } \binom { m - k - 1  } { m - n - 1  } \\
& = \binom { m  } { m - n + 1  } \\
& = \cfrac { n  } { m - n + 1  } \binom { m  } { m - n  } 
\end{aligned}</script><h5><span id="example2">Example2</span></h5><p>求$\sum _{ k  } k \binom { n  } { k  } \binom { s  } { k  } , n \in \mathbb { N  } \ $.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到$n $和$s $的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k  } k \binom { n  } { k  } \binom { s  } { k  } & = s \sum _{ k  } \binom { n  } { k  } \binom { s - 1  } { k - 1  } \\
& = s \binom { n + s - 1  } { n - 1  } 
\end{aligned}</script><h5><span id="example3">Example3</span></h5><p>求$\sum _{ 0 \leq k  } \binom { n + k  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n \in \mathbb { N  } \ $.</p>
<p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq k  } \binom { n + k  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } & = \sum _{ 0 \leq k  } \binom { n + k  } { k  } \binom { n  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n \in \mathbb { N  } \\
& = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { n + k  } { k  } \binom { n + 1  } { k + 1  } { ( - 1 ) ^k  } \\
& = \cfrac { 1  } { n + 1  } \sum _{ 0 \leq k  } \binom { - n - 1  } { k  } \binom { n + 1  } { k + 1  } \\
& = \cfrac { 1  } { n + 1  } \binom { 0  } { n  } \\
& = [ n & = 0 ] 
\end{aligned}</script><h5><span id="example4">Example4</span></h5><p>求$\sum _{ k \geq 0  } \binom { n + k  } { m + 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } , n , m \in \mathbb { N _+  } \ $.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的$( 1 ) $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k \geq 0  } \binom { n + k  } { m + 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } & = \sum _{ k \geq 0  } \sum _{ 0 \leq j \leq n + k - 1  } \binom { n + k - 1 - j  } { 2 k  } \binom { j  } { m - 1  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } \\
& = \sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{ j + 1 - n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } 
\end{aligned}</script><p>注意到如果$j + 1 - n \geq 0 $,则$\binom { n + k - 1 - j  } { 2 k  } \ $应为$0 $.所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ 0 \leq j \leq n - 1  } \binom { j  } { m - 1  } \sum _{ j + 1 - n \leq k , 0 \leq k  } \binom { n + k - 1 - j  } { 2 k  } \binom { 2 k  } { k  } \cfrac { ( - 1 ) ^k  } { k + 1  } \\
& = \sum _{ 0 \leq j < n  } \binom { j  } { m - 1  } [ n - 1 - j & = 0 ] & = \binom { n - 1  } { m - 1  } 
\end{aligned}</script><h5><span id="example5">Example5</span></h5><p>求$\sum _{ k = 0  } ^n ( C _n ^k ) ^2 $.</p>
<script type="math/tex; mode=display">
\sum _{ k = 0  } ^n ( C _n ^k ) ^2 = \sum _{ k = 0  } ^n C _{ n  } ^k \times C _{ n  } ^{ n - k  } = C _n ^{ 2 n  }</script><h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4><h5><span id="example1">Example1</span></h5><p>求$Q _n = \sum _{ k \leq 2 ^n  } \binom { 2 ^n - k  } { k  } ( - 1 ) ^k , n \in \mathbb { N  } \ $.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于$Q _n $的式子中实际上只与$2 ^n $有关,我们不妨令$R _n = \sum _{ k \leq n  } \binom { n - k  } { k  } ( - 1 ) ^k \ $,显然有$Q _n = R _{ 2 ^n  } $.</p>
<p>而我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
R _n & = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k + \sum _{ k \leq n  } \binom { n - 1 - k  } { k - 1  } ( - 1 ) ^k \\
& = \sum _{ k \leq n  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k + \sum _{ k \leq n - 1  } \binom { n - k - 2  } { k  } ( - 1 ) ^{ k + 1  } \\
& = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k + \binom { - 1  } { n  } ( - 1 ) ^n - ( \sum _{ k \leq n - 2  } \binom { n - 2 - k  } { k  } ( - 1 ) ^k + \binom { - 1  } { n - 1  } ( - 1 ) ^{ n - 1  } ) \\
& = \sum _{ k \leq n - 1  } \binom { n - 1 - k  } { k  } ( - 1 ) ^k - \sum _{ k \leq n - 1  } \binom { n - 2 - k  } { k  } ( - 1 ) ^k \\
& = R _{ n - 1  } - R _{ n - 2  } \\
& = R _{ n - 2  } - R _{ n - 3  } - R _{ n - 2  } \\
& = - R _{ n - 3  } \\
& = R _{ n - 6  } 
\end{aligned}</script><p>也即$R _n $具有周期性,不难计算前几项答案,最后有$Q _n \begin{cases}1 &amp; n = 0 \ 0 &amp; n  is  \mathrm { odd  } \ - 1 &amp; n &gt; 0 \land n  is  \mathrm { even  } \end{cases} $.</p>
<h5><span id="example2">Example2</span></h5><p>求$( \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{ nk  } ) \mod p $.</p>
<p>考虑设$f ( n , r ) = \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{ nk  } \ $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f ( n , r ) & = \sum ^{ + \infty  } _{ i = 0  } C ^{ ik + r  } _{ nk  } \\
& = \sum _{ i = 0  } ^{ + \infty  } \sum _{ j = 0  } ^k C _{ nk - k  } ^{ ik + r - j  } \times C _k ^j \\
& = \sum ^k _{ j = 0  } C _k ^j \sum _{ i = 0  } ^{ + \infty  } C _{ nk - k  } ^{ ik + r - j  } \\
& = \sum _{ j = 0  } ^k C _k ^j f ( n - 1 , r - j ) \\

\end{aligned}</script><p>整理上式,得到:$f ( n , r ) = \sum _{ j = 0  } ^k C _k ^j f ( n - 1 , r - j ) \ $.</p>
<p>于是我们得到了关于$f $的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4><h5><span id="example">Example</span></h5><p>求$\sum _{ k = 1  } ^n k ^2 C _n ^k $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
( ( 1 + x ) ^n ) & = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } ) \\
( ( 1 + x ) ^n ) ' & = ( \sum _{ k = 0  } ^n C _n ^k x ^{ k  } ) ' \\
n ( 1 + x ) ^{ n - 1  } & = \sum _{ k = 0  } ^n kC _n ^k x ^{ k - 1  } \\
nx ( 1 + x ) ^{ n - 1  } & = \sum _{ k = 0  } ^n kC _n ^k x ^{ k  } \\
( nx ( 1 + x ) ^{ n - 1  } ) ' & = ( \sum _{ k = 0  } ^n kC _n ^k x ^{ k  } ) ' \\
n ( ( 1 + x ) ^{ n - 1  } + ( n - 1 ) x ( 1 + x ) ^{ n - 2  } ) & = \sum _{ k = 0  } ^n k ^2 C _n ^k x ^{ k - 1  } \\

\end{aligned}</script><p>取$x = 1 $,则原式$= n ( n + 1 ) 2 ^{ n - 2  } $.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4><h5><span id="example1">Example1</span></h5><p>多次询问给定$k , r $,$\sum k \leq 2 n , r &lt; 2 n - k $,求$\sum _{ i = 0  } ^{ r  } \frac { 1  } { 2 ^i  } \binom { i  } { n - k  } $,.</p>
<p>我们把模型抽象成:在二维平面上,从$( 0 , 0 ) $随机游走到$( n - k + 1 , r - n + k ) $正下方(包含这个点)的概率,容易发现此时向右走了$n - k $步,总共走了$\leq r $步,然后再向右走一步保证第一次走到了$( n - k + 1 , r - n + k ) $下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到$x + y = r + 1 $这条直线时横坐标$\geq n - k + 1 $的概率.枚举一下总共向上走了几步,就得到$\frac { 1  } { 2 ^{ r  }  } \sum _{ j = 0  } ^{ r - n + k  } \binom { r + 1  } { j  } $,注意这里是$\frac { 1  } { 2 ^r  } $,因为从一开始钦定了一步,因此映射过来需要多乘个$\frac { 1  } { 2  } $,反映射就要乘个$2 $.但是这个式子还是做不了,因为$r $并不满足$\sum r \leq 2 n $.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于$1 - \frac { 1  } { 2 ^{ r  }  } \sum _{ i = 0  } ^{ n - k  } \binom { r + 1  } { i  } $.我们考虑暴力预处理出$f _r = \sum _{ i = 0  } ^{ n  } \binom { r  } { i  } $,每次删掉一个后缀的组合数就行.现在的问题在于$f $怎么做.</p>
<p>直接拆组合数,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _r & = \sum _{ i = 0  } ^n \binom { r  } { i  } \\
& = \sum _{ i = 0  } ^n \binom { r - 1  } { i - 1  } + \sum _{ i = 0  } ^n \binom { r - 1  } { i  } \\
& = 2 \sum _{ i = 0  } ^n \binom { r - 1  } { i  } - \binom { r - 1  } { n  } \\
& = 2 f _{ r - 1  } - \binom { r - 1  } { n  } 
\end{aligned}</script><h3><span id="lucas定理">Lucas定理</span></h3><p>若$p $是质数,则$C _n ^m \mod p = C _{ n \mod p  } ^{ m \mod p  } \times C _{ \lfloor \frac { n  } { p  } \rfloor  } ^{ \lfloor \frac { m  } { p  } \rfloor  } \mod p \ $.</p>
<p>或者说,将$n $和$m $在$p $进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若$i \ne 0 $且$i \ne p $,$C _{ p  } ^i \equiv \frac { p  } { i  } C _{ p - 1  } ^{ i - 1  } \equiv 0 ( \mod p ) \ $.</p>
<p>而根据二项式定理,$( 1 + x ) ^p \equiv \sum _{ i = 0  } ^p C _{ p  } ^i x ^i = 1 + x ^p ( \mod p ) \ $.</p>
<p>令$n = k _1 p + b _1 $,$m = k _2 p + b _2 $,则$( 1 + x ) ^n = ( 1 + x ) ^{ k _1 p  } ( 1 + x ) ^{ b _1  } \ $.</p>
<p>而$( 1 + x ) ^{ k _1 p  } \equiv ( 1 + x ^p ) ^{ k _1  } ( \mod p ) \ $,有$( 1 + x ) ^n \equiv ( 1 + x ^p ) ^{ k _1  } ( 1 + x ) ^{ b _1  } \ $.</p>
<p>根据二项式定理,$C _n ^m \bmod p $即$x ^m $项的系数.</p>
<p>我们可以得出,$C _n ^m x ^m \equiv C _{ k _1  } ^{ k _2  } x ^{ k _2 p  } C _{ b 1  } ^{ b _2  } x ^{ b _2  } \pmod { p  } \ $,那么有$C _a ^b \equiv C _{ k _1  } ^{ k _2  } C _{ b _1  } ^{ b _2  } \pmod { p  } \ $.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<script type="math/tex; mode=display">
\binom { n  } { m  } \equiv [ m \subseteq n ] \pmod { 2  }</script><h5><span id="example1cf1770fkoxia-and-sequence">Example1([CF1770F]Koxia and Sequence)</span></h5><p>首先观察样例并思考,可以发现当$n $为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是$0 $),所以异或值为$0 $.不然,我们可以翻转$a [ 2 . . . n ] $,得出答案应该是所有$a _1 $的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有$y ‘ \subseteq y $,求出满足$a _i \subseteq y ‘ , \sum a _i = x $时,$a _1 $异或和.接下来怎么做呢?我们考虑拆位,若$2 ^k \subseteq y ‘ $,假设$a _1 $的第$k $位是$1 $,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第$k $位贡献是:</p>
<script type="math/tex; mode=display">
[ 2 ^k \subseteq y ' ] \bigoplus _{ \sum a = x  } [ 2 ^k \subseteq a _1 ] \prod _{ i = 1  } ^n [ a _i \subseteq y ' ]</script><p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:$[ x \subseteq y ] \equiv \binom { y  } { x  } \pmod { 2  } $.</p>
<p>所以原式化简为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\binom { y '  } { 2 ^k  } \sum _{ \sum a = x  } \binom { a _1  } { 2 ^k  } \prod _{ i = 1  } ^n \binom { y '  } { a _i  } \pmod { 2  } \\
& = \binom { y '  } { 2 ^k  } \sum _{ a _1  } \binom { y ' - 2 ^k  } { a _1 - 2 ^k  } \sum _{ \sum a = x - a _1  } \prod _{ i = 2  } ^n \binom { y '  } { a _i  } \pmod { 2  } \\

\end{aligned}</script><p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\binom { y '  } { 2 ^k  } \sum _{ a _1  } \binom { y ' - 2 ^k  } { a _1 - 2 ^k  } \binom { ( n - 1 ) y '  } { x - a _1  } \pmod { 2  } \\
& = \binom { y '  } { 2 ^k  } \binom { ny ' - 2 ^k  } { x - 2 ^k  } \pmod { 2  } \\
& = [ 2 ^k \subseteq y ' ] [ ( x - 2 ^k ) \subseteq ( ny ' - 2 ^k ) ] 
\end{aligned}</script><h3><span id="扩展lucas定理">扩展Lucas定理</span></h3><p>令$p = \prod p _i ^{ e _i  } $,那我们只要对于每个$i $求出$C _n ^m \mod p _i ^{ e _i  } $,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求$C _n ^m \mod p ^k $,其中$p \in prime $.</p>
<p>原式$= \frac { n !  } { m ! ( n - m ) !  } \mod p ^k = \frac { \frac { n !  } { p ^x  }  } { \frac { m !  } { p ^y  } \frac { ( n - m ) !  } { p ^z  }  } p ^{ x - y - z  } \mod p ^k \ $.</p>
<p>现在问题转化为求$\frac { n !  } { p ^x  } \mod p ^k 以 及 p ^x \ $.</p>
<p>注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ! & = \prod _{ i = 1  } i \\
& = ( \prod _{ i = wp , w \in \mathbb { Z  }  } i ) ( \prod _{ i \ne wp , w \in \mathbb { Z  }  } i ) \\
& = p ^{ \lfloor n p \rfloor  } ( \lfloor n p \rfloor ! ) ( \prod _{ i \ne wp , w \in \mathbb { Z  }  } i ) \\
& \equiv p ^{ \lfloor \frac { n  } { p  } \rfloor  } ( \lfloor \frac { n  } { p  } \rfloor ! ) ( \prod _{ i = 1 , i \ne wp , w \in \mathbb { Z  }  } ^{ p ^k  } i ) ^{ \lfloor \frac { n  } { p ^k  } \rfloor  } ( \prod ^{ n \ \bmod { p ^k  }  } _{ i = p ^k \lfloor \frac { n  } { p ^k  } \rfloor , i \ne wp , w \in \mathbb { Z  }  } i ) ( \mod p ^k ) 
\end{aligned}</script><p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将$[ 1 , n ] $的所有数全部排成一个宽为$p ^k $的矩阵.</p>
<p>那右边第一项就是把那些$p $的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2><h3><span id="第一类斯特林数">第一类斯特林数</span></h3><p>$n \brack k \ $:长度为$n $的排列划分成$k $个轮换的方案数.</p>
<p>考虑现在已经将$n - 1 $个数分成了若干轮换,现在新加入第$n $个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然$\left [ \begin{array}{ c  } n \ k \end{array} \right ] = ( n - 1 ) \left [ \begin{array}{ c  } n - 1 \ k \end{array} \right ] + \left [ \begin{array}{ c  } n - 1 \ k - 1 \end{array} \right ] \ $.</p>
<p>特别地,我们定义$\left [ \begin{array}{ c  } 0 \ k \end{array} \right ] = [ k = 0 ] \ $.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:$\sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] = n ! $.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3><p>$\left \{ \begin{array}{ c  } n \ k \end{array} \right \} $:将$n $个本质不同的物品划分成k个非空集合的方案数.</p>
<p>考虑现在已经放好$n - 1 $个物品,正要放入第$n $个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然$\left \{ \begin{array}{ c  } n \ k \end{array} \right \} = k \left \{ \begin{array}{ c  } n - 1 \ k \end{array} \right \} + \left \{ \begin{array}{ c  } n - 1 \ k - 1 \end{array} \right \} \ $.</p>
<p>特别地,我们定义$\left \{ \begin{array}{ c  } 0 \ k \end{array} \right \} = [ k = 0 ] \ $.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3><p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:${ n \brack m  } = { - m \brace - n  } \ $.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3><ol>
<li>$x ^n = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} x ^{ \underline { k  }  } = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} ( - 1 ) ^{ n - k  } x ^{ \overline { k  }  } \ $.</li>
</ol>
<p>证明:先考虑前半段,不妨使用数学归纳.若$x ^{ n - 1  } = \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}{ c  } n - 1 \ k \end{array} \right \} x ^{ \underline { k  }  } \ $,我们要证</p>
<p>\\</p>
<script type="math/tex; mode=display">
\begin{aligned}
x \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} x ^{ \underline { k  }  } & = \sum _{ k = 0  } ^{ n  } \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} x ^{ \underline { k  }  } \\

\end{aligned}</script><p>考虑$( x - k ) x ^{ \underline { k  }  } = x ^{ \underline { k + 1  }  } $,所以$x \cdot x ^{ \underline { k  }  } = x ^{ \underline { k + 1  }  } + kx ^{ \underline { k  }  } \ $.那么左边即:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} x ^{ \underline { k + 1  }  } + \sum _{ k = 0  } ^{ n - 1  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} kx ^{ \underline { k  }  } \\
& = \sum _{ k = 1  } ^{ n  } \left \{ \begin{array}
{ c  } n - 1 \\
k - 1 
\end{array} \right \} x ^{ \underline { k  }  } + \sum _{ k = 1  } ^{ n  } \left \{ \begin{array}
{ c  } n - 1 \\
k 
\end{array} \right \} kx ^{ \underline { k  }  } \\
& = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} x ^{ \underline { k  }  } \\
\\

\end{aligned}</script><p>至于后半段,由于$x ^{ \underline { n  }  } = ( - 1 ) ^n ( - x ) ^{ \overline { n  }  } \ $,所以$x ^n = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} ( - 1 ) ^k ( - x ) ^{ \overline { k  }  } \ $.</p>
<p>不妨用$x $来代替$- x $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( - x ) ^n & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} ( - 1 ) ^k ( x ) ^{ \overline { k  }  } \\
x ^n & = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k 
\end{array} \right \} ( - 1 ) ^{ n - k  } x ^{ \overline { k  }  } 
\end{aligned}</script><ol>
<li><p>$x ^{ \overline { n  }  } = \sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] x ^k \ $.</p>
</li>
<li><p>$x ^{ \underline { n  }  } = \sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] ( - 1 ) ^{ n - k  } x ^k \ $.</p>
</li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于$( x + n - 1 ) x ^k = x ^{ k + 1  } + ( n - 1 ) x ^k \ $,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol>
<li>反转公式:$\sum _{ k = 0  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} ( - 1 ) ^{ n - k  } = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} \left [ \begin{array}{ c  } k \ m \end{array} \right ] ( - 1 ) ^{ n - k  } = [ m = n ] \ $.</li>
</ol>
<p>证明:</p>
<p>考虑先证明后半部分,将(3)带入(1),得到$x ^n = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } n \ k \end{array} \right \} x ^{ \underline { k  }  } = \sum _{ k = 0  } ^n \sum _{ m = 0  } ^k \left \{ \begin{array}{ c  } n \ k \end{array} \right \} \left [ \begin{array}{ c  } k \ m \end{array} \right ] ( - 1 ) ^{ n - k  } x ^m \ $.</p>
<p>由于这对任意$x $都成立,因此右边除了$x ^n $以外的项系数均为$0 $,而$x ^n $的系数为$1 $.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol>
<li><p>$\left \{ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right \} = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left \{ \begin{array}{ c  } k \ m \end{array} \right \} \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right ] = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left [ \begin{array}{ c  } k \ m \end{array} \right ] \ $.</p>
</li>
</ol>
<p>证明:对于前者,考虑组合意义,将$n + 1 $个分为$m + 1 $组,也就是先找一部分分成$m $组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3><ol>
<li><p>$\left \{ \begin{array}{ c  } n \ m \end{array} \right \} = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left \{ \begin{array}{ c  } k + 1 \ m + 1 \end{array} \right \} ( - 1 ) ^{ n - k  } \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n \ m \end{array} \right ] = \sum _{ k = m  } ^n \left ( \begin{array}{ c  } n \ k \end{array} \right ) \left [ \begin{array}{ c  } k + 1 \ m + 1 \end{array} \right ] ( - 1 ) ^{ n - k  } \ $.</p>
</li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol>
<li>$m ! \left \{ \begin{array}{ c  } n \ m \end{array} \right \} = \sum _{ k = 0  } ^m C _m ^k k ^n ( - 1 ) ^{ m - k  } \ $.</li>
</ol>
<p>证明:首先有$m ^n = \sum _{ k = 0  } ^m m ^{ \underline { k  }  } \left \{ \begin{array}{ c  } m \ k \end{array} \right \} = \sum _{ k = 0  } ^m k ! C _m ^k \left \{ \begin{array}{ c  } m \ k \end{array} \right \} \ $,对这个式子进行二项式反演即可.</p>
<ol>
<li>$\left \{ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right \} = \sum _{ k = 0  } ^n \left \{ \begin{array}{ c  } k \ m \end{array} \right \} ( m + 1 ) ^{ n - k  } \ $.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前$k $个分为$m $组,把第$k + 1 $个数放到第$m + 1 $组.然后剩下$( n + 1 ) - ( k + 1 ) = n - k $个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第$m + 1 $组(最小值最大的那组)在$k $不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol>
<li>$\left [ \begin{array}{ c  } n + 1 \ m + 1 \end{array} \right ] = \sum _{ k = 0  } ^n \left [ \begin{array}{ c  } k \ m \end{array} \right ] C _{ n  } ^k ( n - k ) ! = n ! \sum _{ k = 0  } ^n \frac { \left [ \begin{array}{ c  } k \ m \end{array} \right ]  } { k !  } \ $.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果$n &gt; 0 $,我们有$\left [ \begin{array}{ c  } n \ 1 \end{array} \right ] = ( n - 1 ) ! \ $.这个式子很显然,我们现在有一个长度为$n - 1 $的环,想要往里插入第$n $个数有$n - 1 $种选择,所以我们有:$\left [ \begin{array}{ c  } n \ 1 \end{array} \right ] = \left [ \begin{array}{ c  } n - 1 \ 1 \end{array} \right ] ( n - 1 ) \ $,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将$n + 1 $个数划分成$m + 1 $个环,我们先将其中$k $个数划分成$m $个环,剩下$n + 1 - k $个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第$n + 1 $个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于$C _n ^k ( n - k ) ! = C _n ^{ n - k  } ( n - k ) ! = n ^{ \underline { n - k  }  } = \frac { n !  } { k !  } \ $.因此后半部分也得证.</p>
<ol>
<li><p>$\left \{ \begin{array}{ c  } n + m + 1 \ m \end{array} \right \} = \sum _{ k = 0  } ^m k \left \{ \begin{array}{ c  } n + k \ k \end{array} \right \} \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n + m + 1 \ m \end{array} \right ] \sum _{ k = 0  } ^m ( n + k ) \left [ \begin{array}{ c  } n + k \ k \end{array} \right ] \ $.</p>
</li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将$n + k $个位置分到$k $个集合之后.还剩下$( n + m + 1 ) - ( n + k ) = ( m - k + 1 ) $个数,剩下$( m - k ) $个集合.</p>
<p>拿出来$( n + k + 1 ) $这个数,剩下的数刚好够每个集合放一个.最后枚举一下把$( n + k + 1 ) $放在哪里即可.由于每个划分一定存在一段(可能是$0 $)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol>
<li>$C _n ^m ( n - 1 ) ^{ \underline { n - m  }  } = \sum _{ k = m  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} \ $.</li>
</ol>
<p>证明:</p>
<p>考虑$( n - 1 ) ^{ \underline { n - m  }  } = \frac { ( n - 1 ) !  } { ( m - 1 ) !  } \ $,不妨设$f ( n , m ) = \sum _{ k = m  } ^n \left [ \begin{array}{ c  } n \ k \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} \ $,相当于将$n $个数分成非空$m $组,然后组内的数要形成若干轮换的方案数.那么知道$f ( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m ) f ( n - 1 , m ) \ $.</p>
<p>设$g ( n , m ) = C _n ^m \frac { ( n - 1 ) !  } { ( m - 1 ) !  } = \frac { n ! ( n - 1 ) !  } { m ! ( n - m ) ! ( m - 1 ) !  } \ $,那么知道:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g ( n - 1 , m - 1 ) & = \frac { ( n - 1 ) ! ( n - 2 ) !  } { ( m - 1 ) ! ( n - m ) ! ( m - 2 ) !  } \\
g ( n - 1 , m ) & = \frac { ( n - 1 ) ! ( n - 2 ) !  } { m ! ( n - 1 - m ) ! ( m - 2 ) !  } \\

\end{aligned}</script><p>显然$g ( n , m ) = g ( n - 1 , m - 1 ) + ( n - 1 + m ) g ( n - 1 , m ) \ $,数学归纳即可.</p>
<ol>
<li><p>$C _n ^m = \frac { n !  } { m ! ( n - m ) !  } = \sum _{ k = m  } ^n \left \{ \begin{array}{ c  } n + 1 \ k + 1 \end{array} \right \} \left [ \begin{array}{ c  } k \ m \end{array} \right ] ( - 1 ) ^{ m - k  } \ $.</p>
</li>
<li><p>$n ^{ \underline { n - m  }  } = \frac { n !  } { m !  } = \sum _{ k = m  } ^n \left [ \begin{array}{ c  } n + 1 \ k + 1 \end{array} \right ] \left \{ \begin{array}{ c  } k \ m \end{array} \right \} ( - 1 ) ^{ m - k  } ， 其 中 m \leq n \ $.</p>
</li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol>
<li><p>$\left \{ \begin{array}{ c  } n \ l + m \end{array} \right \} C _{ l + m  } ^l = \sum _{ k = l  } ^n \left \{ \begin{array}{ c  } k \ l \end{array} \right \} \left \{ \begin{array}{ c  } n - k \ m \end{array} \right \} C _n ^k \ $.</p>
</li>
<li><p>$\left [ \begin{array}{ c  } n \ l + m \end{array} \right ] C _{ l + m  } ^l = \sum _{ k = l  } ^n \left [ \begin{array}{ c  } k \ l \end{array} \right ] \left [ \begin{array}{ c  } n - k \ m \end{array} \right ] C _n ^k \ $.</p>
</li>
</ol>
<p>证明:先考虑前者,左边即先将$n $个数分为$l + m $个集合,然后再挑出$l $个集合.那不妨枚举这$l $个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2><p>记$\left \langle \begin{array}\ n \ k \end{array} \right \rangle $表示$\{ 1 , 2 , . . . , n \} $的排列$a $中满足这条性质的排列个数:存在且只存在$k $个升高,换句话说,存在且只存在$k $个$i $,满足$1 \leq i &lt; n $,$a _i &lt; a _{ i + 1  } $.不难发现$\left \langle \begin{array}\ n \ k \end{array} \right \rangle = \left \langle \begin{array}\ n \ n - k - 1 \end{array} \right \rangle $.</p>
<p>考虑在一个$\{ 1 , 2 , . . . , n - 1 \} $的排列中插入$n $,设插入的位置是原本$a _i $的后面,那么要么原本$a _i &lt; a _{ i + 1  } $,要么反之.前者不会改变排列的升高的数量,后者则会增加$1 $.另外还有一种情况是插入到了序列最前面.于是我们自然得到:$\left \langle \begin{array}\ n \ k \end{array} \right \rangle = ( k + 1 ) \left \langle \begin{array}\ n - 1 \ k \end{array} \right \rangle + ( n - k ) \left \langle \begin{array}\ n - 1 \ k - 1 \end{array} \right \rangle $.</p>
<p>特别地,我们令$\left \langle \begin{array}\ 0 \ k \end{array} \right \rangle = [ k = 0 ] $,若$k &lt; 0 $,则$\left \langle \begin{array}\ n \ k \end{array} \right \rangle = 0 $.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3><p>我们有Worpitzky恒等式:</p>
<script type="math/tex; mode=display">
x ^n = \sum _{ k \geq 0  } \binom { x + k  } { n  } \left \langle \begin{array}
\\
n \\
k 
\end{array} \right \rangle , n \in \mathbb { N  }</script><p>还有另一个恒等式:</p>
<script type="math/tex; mode=display">
\left \langle \begin{array}
\\
n \\
m 
\end{array} \right \rangle = \sum _{ k = 0  } ^m \binom { n + 1  } { k  } ( m + 1 - k ) ^n ( - 1 ) ^k</script><p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2><p>定义$B _j $为第$j $个伯努利数,且满足$\sum _{ j = 0  } ^m \binom { m + 1  } { j  } B _j = [ m = 0 ] , m \geq 0 \ $.</p>
<p>定义$S _m ( n ) = \sum _{ i = 0  } ^{ n - 1  } i ^m $.</p>
<p>伯努利数满足公式:$S _m ( n ) = \cfrac { 1  } { m + 1  } \sum _{ k = 0  } ^m \binom { m + 1  } { k  } B _k n ^{ m + 1 - k  } \ $.</p>
<p>证明如下:</p>
<p>对$S _{ m + 1  } ( n ) $使用扰动法,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
S _{ m + 1  } ( n ) + n ^{ m + 1  } & = \sum _{ k = 0  } ^{ n - 1  } ( k + 1 ) ^{ m + 1  } \\
& = \sum _{ k = 0  } ^{ n - 1  } \sum _{ j = 0  } ^{ m + 1  } \binom { m + 1  } { j  } k ^j \\
& = \sum _{ j = 0  } ^{ m + 1  } \binom { m + 1  } { j  } S _j ( n ) \\
& = \sum _{ j = 0  } ^{ m  } \binom { m + 1  } { j  } S _j ( n ) + S _{ m + 1  } ( n ) \\
n ^{ m + 1  } & = \sum _{ j = 0  } ^m \binom { m + 1  } { j  } S _j ( n ) \\

\end{aligned}</script><p>接下来使用数学归纳,假设$0 \leq j &lt; m $时该公式成立,并假设有$S _m ( n ) = \cfrac { 1  } { m + 1  } \sum _{ k = 0  } ^m \binom { m + 1  } { k  } B _k n ^{ m + 1 - k  } + \Delta \ $,我们只需要证明$\Delta = 0 $.</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ^{ m + 1  } & = \sum _{ j = 0  } ^m \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } \sum _{ k = 0  } ^j \binom { j + 1  } { k  } B _k n ^{ j + 1 - k  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k  } \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _k n ^{ j + 1 - k  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { j - k  } \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k + 1  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq j \leq m  } \binom { j + 1  } { k + 1  } \binom { m + 1  } { j  } \cfrac { 1  } { j + 1  } B _{ j - k  } n ^{ k + 1  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  } \sum _{ j = k  } ^m B _{ j - k  } \binom { m + 1  } { j  } \binom { j  } { k  } + ( m + 1 ) \Delta \\
& = \sum _{ 0 \leq k \leq m  } \cfrac { n ^{ k + 1  }  } { k + 1  } \binom { m + 1  } { k  } \sum _{ j = k  } ^m B _{ j - k  } \binom { m + 1 - k  } { j - k  } + ( m + 1 ) \Delta \\
& = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom { m + 1  } { k  } \sum _{ j = 0  } ^{ m - k  } B _{ j  } \binom { m + 1 - k  } { j  } + ( m + 1 ) \Delta \\
& = \sum _{ k = 0  } ^m \cfrac { n ^{ k + 1  }  } { k + 1  } \binom { m + 1  } { k  } [ m - k & = 0 ] + ( m + 1 ) \Delta \\
& = n ^{ m + 1  } + ( m + 1 ) \Delta 
\end{aligned}</script><p>显然$\Delta = 0 $,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2><p>定义斐波那契数$F _n = \begin{cases}0 &amp; n = 0 \ 1 &amp; n = 1 \ F _{ n - 1  } + F _{ n - 2  } &amp; n &gt; 1 \end{cases} $.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3><p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<script type="math/tex; mode=display">
F _{ n + 1  } F _{ n - 1  } - F _n ^2 = ( - 1 ) ^n , n > 0</script><p>事实上,如果我们将斐波那契数的递推式改写作:$F _n = F _{ n + 2  } - F _{ n + 1  } $,我们可以在$n \in \mathbb { Z  } $的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<script type="math/tex; mode=display">
F _{ - n  } = ( - 1 ) ^{ n - 1  } F _n , n \in \mathbb { Z  }</script><h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3><p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
F _{ n + k  } & = F _k F _{ n + 1  } + F _{ k - 1  } F _n \\
F _{ n + m + 1  } & = F _{ n + 1  } F _{ m + 1  } + F _n F _m 
\end{aligned}</script><p>另外,如果我们在上面这个式子中取$k = wn , w \in \mathbb { N  } $并使用归纳法,我们又可以得到一个性质:$F _{ kn  } $是$F _n $的倍数,$k \in \mathbb { Z  } $.</p>
<p>再观察这个式子,使用归纳法可以证明$\gcd ( F _{ n  } , F _{ n - 1  } ) = 1 $,进一步有:$\gcd ( F _{ n + m  } , F _m ) = \gcd ( F _n , F _m ) $.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<script type="math/tex; mode=display">
\gcd ( F _m , F _n ) = F _{ \gcd ( n , m )  }</script><p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<script type="math/tex; mode=display">
F _n ^2 | F _m \Leftrightarrow nF _n | m , n > 2</script><p>这个引理的证明如下:</p>
<p>由于$F _{ n + 1  } \equiv F _{ n - 1  } \pmod { F _n  } $.于是我们有:$F _{ 2 n  } = F _n F _{ n + 1  } + F _{ n - 1  } F _n $,也就是$F _{ 2 n  } \equiv 2 F _n F _{ n + 1  } \pmod { F _n ^2  } $.</p>
<p>另外我们有:$F _{ 2 n + 1  } \equiv F _{ n + 1  } ^2 \pmod { F _n ^2  } $.</p>
<p>同理,使用归纳法可以证明:$F _{ kn  } \equiv kF _n F _{ n + 1  } ^{ k - 1  } \pmod { F _n ^2  } , F _{ kn + 1  } \equiv F _{ n + 1  } ^k \pmod { F _n ^2  } $.</p>
<p>而$F _{ n + 1  } \bot F _n $,于是$F _{ kn  } \equiv 0 \pmod { F _n ^2  } \Leftrightarrow k \equiv 0 \pmod { F _n  } , n &gt; 2 $.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3><p>我们如果定义$j \gg k \Leftrightarrow j \geq k + 2 $,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:$n = \sum _{ i = 1  } ^r F _{ k _i  } , \forall 1 \leq i &lt; r , k _i \gg k _{ i + 1  } \gg 0 $.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果$\exists k $满足$F _k = n $,则显然成立,不然,应$\exists k $满足$F _k &lt; n &lt; F _{ k + 1  } $,而$n - F _k $的表示已经存在了.另外,由于$n - F _k &lt; F _{ k + 1  } - F _k = F _{ k - 1  } $,因此必定不可能出现选了$F _k $又选了$F _{ k - 1  } $的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择$F _k $而是选择$F _{ k - 1  } $,那么显然接下来无论怎么选,它们的加和都不可能大于等于$F _k $,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数$n $以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3><p>使用生成函数,令$F ( z ) = \sum _{ k \geq 0  } F _k z ^k $.那么不难发现$F ( z ) - zF ( z ) - z ^2 F ( z ) = z $,也就是$F ( z ) = \cfrac { z  } { 1 - z - z ^2  } $.</p>
<p>考虑这个形式一定可以分解为$F ( z ) = \cfrac { a  } { 1 - \alpha z  } + \cfrac { b  } { 1 - \beta z  } $的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令$\phi = \cfrac { 1 + \sqrt { 5  }  } { 2  } , \hat \phi = \cfrac { 1 - \sqrt { 5  }  } { 2  } $,那么可以得到$F _n = \cfrac { 1  } { \sqrt { 5  }  } ( \phi ^n - \hat \phi ^n ) $.</p>
<p>另外,由于$\hat \phi ^n $的影响很小,于是又有$F _n = \lfloor \cfrac { \phi ^n  } { \sqrt { 5  }  } + 0 . 5 \rfloor $.</p>
<h3><span id="连项式">连项式</span></h3><p>连项式多项式$K _n ( x _1 , x _2 , . . . , x _n ) $定义为:$K _n ( x _1 , x _2 , . . . , x _n ) = \begin{cases}1 &amp; n = 0 \ x _1 &amp; n = 1 \ x _n K _{ n - 1  } ( x _1 , x _2 , . . . x _{ n - 1  } ) + K _{ n - 2  } ( x _1 , x _2 , . . . , x _{ n - 2  } ) &amp; n \geq 2 \end{cases} $.</p>
<p>通过定义不难发现:$K _n ( 1 , 1 , . . . , 1 ) = F _{ n + 1  } $.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数$( x _{ n - 1  } , x _n ) $.我们考虑用这样一种形式的字符串来表示最后某一项的情况:’.’为还没有消除掉的项,长度为$1 $;’-‘为已经消除了的两项,长度为$2 $.那么$K _n ( x _1 , x _2 , . . . , x _n ) $就可以表示为一个长度为$n $的字符串,其中若有$k $个’-‘,有$n - 2 k $个’.’,则有$\binom { n - k  } { k  } $种不同的排列方式.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
K _n ( z , z , . . . , z ) & = \sum _{ k = 0  } ^n \binom { n - k  } { k  } z ^{ n - 2 k  } \\

\end{aligned}</script><p>另外,这也导出:$F _{ n + 1  } = \sum _{ k = 0  } ^n \binom { n - k  } { k  } \ $.</p>
<p>考虑上面的构造过程,不难发现$K _n ( x _1 , x _2 , . . . , x _n ) = K _n ( x _n , x _{ n - 1  } , . . . , x _1 ) $.</p>
<p>于是递归式可以写成:$K _n ( x _1 , x _2 , . . . , x _n ) = x _1 K _{ n - 1  } ( x _2 , x _3 , . . . x _{ n  } ) + K _{ n - 2  } ( x _3 , x _4 , . . . , x _{ n  } ) $.</p>
<p>进一步地,不断展开后得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
K _{ m + n  } ( x _1 , . . . , x _m , x _{ m + 1  } , . . . , x _{ n + m  } ) & = \\
K _m ( x _1 , . . . , x _m ) K _n ( x _{ m + 1  } , . . . , x _{ n + m  } ) + K _{ m - 1  } ( x _1 , . . . , x _{ m - 1  } ) K _{ n - 1  } ( x _{ m + 2  } , . . . , x _{ n + m  } ) 
\end{aligned}</script><p>另外,根据连项式的定义,不难导出$K _n ( x _1 , . . . , x _n + y ) = K _n ( x _1 , . . . , x _n ) + K _{ n - 1  } ( x _1 , . . . , x _{ n - 1  } ) y $.</p>
<p>由这个公式可以推出:$\cfrac { K _{ n + 1  } ( a _0 , . . . , a _n )  } { K _n ( a _1 , . . . , a _n )  } = \cfrac { K _n ( a _0 , . . . , a _{ n - 1  } + \cfrac { 1  } { a _n  } )  } { K _{ n - 1  } ( a _1 , . . . , a _{ n - 1  } + \cfrac { 1  } { a _n  } )  } $.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<script type="math/tex; mode=display">
\cfrac { K _{ n + 1  } ( a _0 , . . . , a _n )  } { K _n ( a _1 , . . . , a _n )  } = a _0 + \cfrac { 1  } { a _1 + \cfrac { 1  } { a _2 + \cfrac { 1  } { a _3 + . . .  }  }  }</script><p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" class="post-title-link" itemprop="url">简单乐理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="前言">前言</span></h3><p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3><h4><span id="拍音理论">拍音理论</span></h4><p>假设两个正弦单音的频率分别是$\omega , \omega + \delta $,那么它们叠加后是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
& = 2 \sin \left ( 2 \pi ( \omega + \frac { \delta  } { 2  } ) t \right ) \cos ( \pi \delta t ) 
\end{aligned}</script><p>注意到这个声音受到$\cos ( \pi \delta t ) $的控制.因此会以$\frac { \delta  } { 2  } $的频率振动,由于$\delta $应该远小于$\omega $,这里就会产生$\delta = | \omega _1 - \omega _2 | $个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4><p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol>
<li><p>弦长$L $.</p>
</li>
<li><p>张力$T $.</p>
</li>
<li><p>线密度$\rho $.</p>
</li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点$u ( x , t ) $,首先是一维振动方程:</p>
<script type="math/tex; mode=display">
\frac { \partial ^2 u  } { \partial x ^2  } = \frac { \rho  } { T  } \frac { \partial ^2 u  } { \partial t ^2  }</script><p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<script type="math/tex; mode=display">
u _n ( x , t ) = c _n \sin ( \omega _n t + \theta _n ) \sin ( \frac { n \pi  } { L  } x )</script><p>其中第$n $项的频率满足:</p>
<script type="math/tex; mode=display">
f _n = \frac { n  } { 2 L  } \sqrt { \frac { T  } { \rho  }  }</script><p>其中我们将$f _1 $称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中$f _n , n \geq 2 $对应的是第$n - 1 $泛音.</p>
<p>特别地,如果我们干脆记$f = f _1 $,上述结果告诉我们弦的振动产生的一列频率是:</p>
<script type="math/tex; mode=display">
f , 2 f , 3 f , \cdots</script><p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的$n $,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0" alt></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的$f _{ 2 k + 1  } $,泛音列中只剩下$2 f , 4 f , \cdots $.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按$\frac { 1  } { 3  } $处呢?那泛音列中就会只剩下$3 f , 6 f , 9 f , \cdots $,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是$f , 3 f , 5 f , \cdots $.</p>
<h4><span id="管乐器">管乐器</span></h4><p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<script type="math/tex; mode=display">
f , 2 f , 3 f , 4 f , \cdots</script><p>闭管的泛音列:</p>
<script type="math/tex; mode=display">
f , 3 f , 5 f , 7 f</script><p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4><p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots 
\end{gathered}</script><p>或是:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac { 3  } { 2  } f , 3 f , \frac { 9  } { 2  } f , 6 f , \cdots 
\end{gathered}</script><p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3><p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是$L _p = 20 \log _{ 10  } ( \frac { p  } { p _0  } ) $,其中$p _0 = 20 \mu Pa $.</p>
<h4><span id="音程">音程</span></h4><p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<p>| 度数 | 半音数 | 名称   |</p>
<p>| —— | ——— | ——— |</p>
<p>| 一   | 0      | 纯一度 |</p>
<p>| 二   | 1      | 小二度 |</p>
<p>| 二   | 2      | 大二度 |</p>
<p>| 三   | 3      | 小三度 |</p>
<p>| 三   | 4      | 大三度 |</p>
<p>| 四   | 5      | 纯四度 |</p>
<p>| 四   | 6      | 增四度 |</p>
<p>| 五   | 6      | 减五度 |</p>
<p>| 五   | 7      | 纯五度 |</p>
<p>| 六   | 8      | 小六度 |</p>
<p>| 六   | 9      | 大六度 |</p>
<p>| 七   | 10     | 小七度 |</p>
<p>| 七   | 11     | 大七度 |</p>
<p>| 八   | 12     | 纯八度 |</p>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<p>| 音程   | 频率比 |</p>
<p>| ——— | ——— |</p>
<p>| 纯八度 | $2 : 1 $  |</p>
<p>| 纯五度 | $3 : 2 $  |</p>
<p>| 纯四度 | $4 : 3 $  |</p>
<p>| 大三度 | $5 : 4 $  |</p>
<p>| 小三度 | $6 : 5 $  |</p>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4><p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定$C $的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为$1 $,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求$\{ 7 k \} \pmod { 12  } $这个数列对吧,简单数论知识告诉我们它必然能遍历$12 $种情况,具体而言:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C \to & & G \to & & D \to & & A \to & & E \to & & B \to \\
1 \to & & \frac { 3  } { 2  } \to & & \frac { 3 ^2  } { 2 ^3  } \to & & \frac { 3 ^3  } { 2 ^4  } \to & & \frac { 3 ^4  } { 2 ^6  } \to & & \frac { 3 ^5  } { 2 ^7  } \to \\
\\
\\
\# F \to & & \# C \to & & \# G \to & & \# D \to & & \# A \to & & \# E \\
\frac { 3 ^6  } { 2 ^9  } \to & & \frac { 3 ^7  } { 2 ^{ 11  }  } \to & & \frac { 3 ^8  } { 2 ^{ 12  }  } \to & & \frac { 3 ^9  } { 2 ^{ 14  }  } \to & & \frac { 3 ^{ 10  }  } { 2 ^{ 15  }  } \to & & \frac { 3 ^{ 11  }  } { 2 ^{ 17  }  } \\

\end{aligned}</script><p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度$CE $的比是$\frac { 81  } { 64  } &gt; \frac { 80  } { 64  } = \frac { 5  } { 4  } $.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的$# E \ne F $,你对着这个$# E $往上再升一个音得到的理应是$C ‘ = \frac { 3 ^{ 12  }  } { 2 ^{ 18  }  } &gt; 2 $,具体来说$\frac { 3 ^{ 12  }  } { 2 ^{ 19  }  } \approx 1 . 013643 $,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于$1 $的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升$12 $个纯五度,再下降$7 $个纯八度理应回到原点,可是:</p>
<script type="math/tex; mode=display">
( \frac { 3  } { 2  } ) ^{ 12  } \times ( \frac { 1  } { 2  } ) ^7 > 1</script><p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4><p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定$C $的频率为$1 $.接下来用正三和弦(一个大三度和一个小三度)$I : C - E - G $,$IV : F - A - C ‘ $,$V : G - B - D ‘ $的比例是$4 : 5 : 6 $确定剩下的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
C & & D & & E & & F & & G & & A & & B & & C ' & & D ' \\
1 & & \frac { 9  } { 8  } & & \frac { 5  } { 4  } & & \frac { 4  } { 3  } & & \frac { 3  } { 2  } & & \frac { 5  } { 3  } & & \frac { 15  } { 8  } & & 2 & & \frac { 9  } { 4  } 
\end{aligned}</script><p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol>
<li><p>五度音程$D - A $不协和,比例为$\frac { 80  } { 54  } &lt; \frac { 81  } { 54  } = \frac { 3  } { 2  } $.这直接导致了转调会出错.</p>
</li>
<li><p>有两种不同的大二度:音程$C - D , F - G , A - B $的比例是$\frac { 9  } { 8  } $而音程$D - E , G - A $的比例为$\frac { 10  } { 9  } $.</p>
</li>
<li><p><strong>谐调音差</strong>:从$C $出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:$( \frac { 3  } { 2  } ) ^4 \times ( \frac { 1  } { 2  } ) ^2 \times \frac { 4  } { 5  } = \frac { 81  } { 80  } = 1 . 0125 &gt; 1 $.</p>
</li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4><p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用$\sqrt [12 ] { 2  } $来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是$f _1 , f _2 $,则它们的音分数定义为$1200 \log _2 ( \frac { f _2  } { f _1  } ) $,容易见到十二平均律拿到的一个半音恰好是$100 $音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3><h4><span id="大小调">大小调</span></h4><h5><span id="自然大调">自然大调</span></h5><p>就是我们最常用的$CDEFGABC ‘ $,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol>
<li><p>主音</p>
</li>
<li><p>上主音</p>
</li>
<li><p>中音</p>
</li>
<li><p>下属音</p>
</li>
<li><p>属音</p>
</li>
<li><p>下中音</p>
</li>
<li><p>导音</p>
</li>
</ol>
<p>用五度相生,下属音$\rightarrow $主音$\rightarrow $属音.</p>
<h5><span id="自然小调">自然小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以$ABCDEFG $用的调子,然而这里的问题是$G $作为导音却和$A ‘ $差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用$A , B , C , D , E , F , ( ^# G ) $.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5><p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用$A , B , C , D , E , ( ^# F ) , ( ^# G ) $.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4><p>以五度相生:</p>
<script type="math/tex; mode=display">
C \to G \to D \to A \to E \to B \to ( ^\# F ) \to ( ^\# C )</script><p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从$C $开始每次往后跳一次都要在一个音阶上增一个升号.从$C $大调提升到$G $大调的时候就是将$C $的下属音(也就是$F $)升音.</p>
<p>对称地,反方向的五度相生:</p>
<script type="math/tex; mode=display">
C \to F \to ( ^b B ) \to ( ^b E ) \to ( ^b A ) \to ( ^b D ) \to ( ^b G ) \to ( ^b C )</script><p>那这个应该降什么呢?比如从$C $大调提升到$F $大调的时候就是将$F $的下属音$B $降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png" alt></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3><h4><span id="三和弦">三和弦</span></h4><p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol>
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成$4 : 5 : 6 $的频率关系.</p>
</li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p>
</li>
<li><p>减三和弦:两个小三度.</p>
</li>
<li><p>增三和弦:两个大三度.</p>
</li>
</ol>
<h4><span id="七和弦">七和弦</span></h4><p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol>
<li><p>减减七和弦(减七和弦):小小小.</p>
</li>
<li><p>减小七和弦(半减七和弦):小小大.</p>
</li>
<li><p>小小七和弦(小七和弦):小大小.</p>
</li>
<li><p>小大七和弦:小大大.</p>
</li>
<li><p>大小七和弦(属七和弦):大小小.</p>
</li>
<li><p>大大七和弦(大七和弦):大小大.</p>
</li>
<li><p>增大七和弦:大大小.</p>
</li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4><p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol>
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p>
</li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p>
</li>
</ol>
<p>对于七和弦来说:</p>
<ol>
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p>
</li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p>
</li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p>
</li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4><p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为$C - E - G $,$F - A - C ‘ $,$G - B - D ‘ $.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol>
<li><p>正格进行:$I \to V \to I $.</p>
</li>
<li><p>变格进行:$I \to IV \to I $.</p>
</li>
<li><p>复式进行:$I \to IV \to V \to I $.</p>
</li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<script type="math/tex; mode=display">
\xymatrix { & & & & I \\
& & IV \ar [r ] \ar [d ] \ar [dr ] \ar [rru ] & vii \degree \ar [ru ] & \\
iii \ar [r ] & vi \ar [r ] \ar [ru ] & ii \ar [r ] \ar [ru ] & V \ar [ruu ] &  }</script><p>其中$I $较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4><p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol>
<li><p>平行变换$P $:保持纯五度音阶不变,将三音切换.</p>
</li>
<li><p>关系变换$R $:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p>
</li>
<li><p>导音变换$L $:保持小三度音阶不变,补上剩下的一个.</p>
</li>
</ol>
<p>容易见到$R \circ ( L \circ R ) ^3 = P $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" class="post-title-link" itemprop="url">程序设计实习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2><h3><span id="基本分析">基本分析</span></h3><h4><span id="union-bound">Union Bound</span></h4><p>即:$Pr [ \bigcup _i X _i ] \leq \sum Pr [ X _i ] $,取等当且仅当所有$X _i $互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4><p>若$X \geq 0 $,则$Pr [ X \geq t \mathbb { E  } [ X ] ] \leq \frac { 1  } { t  } $.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6><p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有$\frac { 1  } { 2  } $的概率是割边,因此期望自然是$\frac { 1  } { 2  } | E | \geq \frac { 1  } { 2  } | \text { max - cut  } | $.</p>
<p>由此立即见到,$Pr [ | ans | \leq ( \frac { 1  } { 2  } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac { 1  } { 2  } + \epsilon ) | E | ] \leq \frac { 1  } { 1 + 2 \epsilon  } $.</p>
<p>由于每次独立操作,因此如果有$P $的概率失败,那么运行$T $次后至少成功一次的概率应当为$1 - P ^T $.从而$T = O ( \log _P { \delta  } ) = O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \ln ( 1 + { 2 \epsilon  } )  } ) \approx O ( \cfrac { \ln \frac { 1  } { \delta  }  } { \epsilon  } ) $即可拿到$\delta $失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4><p>设$X _1 , \cdots , X _n \in [ 0 , 1 ] $是独立,同期望(期望为$\mu \geq t $)的随机变量,令$X = \frac { \sum _k X _k  } { n  } $,对于任何失败概率$\delta \in ( 0 , 1 ) $,应当有:</p>
<script type="math/tex; mode=display">
Pr \left [ | X - \mu | \geq \sqrt { \cfrac { \log ( 1 / \delta )  } { nt  }  } \mu \right ] \leq \delta</script><h6><span id="examplemedian-trick">Example(Median Trick)</span></h6><p>现在有一个黑盒能够以$p &gt; \frac { 1  } { 2  } $的概率正确回答Yes或者No,问重复$T $选多少次能拿到$1 - \delta $的成功概率.</p>
<p>考虑重复$T $次后应当有期望$pT $个正确答案,因此直接取中位数.称此算法为Median Trick.</p>
<p>Chernoff Bound 告诉我们$T = O ( \log \frac { 1  } { \delta  } ) $足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4><p>设独立随机变量$x _1 , \cdots , x _m \in [ s , t ] $,令$X = \sum _i x _i $,则:</p>
<script type="math/tex; mode=display">
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac { 2 z ^2  } { m ( t - s ) ^2  } \right )</script><h3><span id="编程中的随机性">编程中的随机性</span></h3><p>一般采用伪随机,也即是给定初值$X _0 $,通过某个确定性的函数来生成$X _{ n + 1  } = f ( X _n ) $这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2><h3><span id="基本定义">基本定义</span></h3><p>概率空间$\Omega $:在一个给定问题中可能发生的所有情况.</p>
<p>事件:$\Omega $的一个子集.</p>
<p>基本事件$\omega $:$\Omega $中的单个元素,也可以看作集合大小为$1 $的事件.</p>
<p>概率:若$\omega \in \Omega $,我们称它发生的概率为$\Pr ( \omega ) $,有$\Pr ( \omega ) \geq 0 $且$\sum _{ \omega \in \Omega  } \Pr ( \omega ) = 1 $.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量$X $和$Y $定义在同一个概率空间$\Omega $上,对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,我们称$\Pr ( X = x \land Y = y ) $为它们的联合分布.</p>
<p>独立:如果对于每一个在$X $取值范围内的$x $以及在$Y $取值范围内的$y $,$\Pr ( X = x \land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y ) $,我们称$X $和$Y $是独立的.</p>
<p>期望(均值)$E X $:我们设概率空间上的随机变量$X $的期望$EX = \sum _{ x \in X ( \Omega )  } x \times \Pr ( X = x ) = \sum _{ w \in \Omega  } X ( \omega ) \Pr ( \omega ) $.</p>
<p>中位数:我们设概率空间上的随机变量$X $的中位数为满足$\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x ) \geq 0 . 5 $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量$X $的众数为满足$\Pr ( X = x ) \geq \Pr ( X = x ‘ ) , \forall x ‘ \in X ( \Omega ) $的$x \in X ( \Omega ) $所组成的集合.</p>
<p>方差$VX $:我们设概率空间上的随机变量$X $的方差$VX = E ( ( X - EX ) ^2 ) $.</p>
<p>标准差$\sigma $:我们设概率空间上的随机变量$X $的标准差$\sigma = \sqrt { VX  } $.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3><p>如果$X , Y $是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol>
<li><p>$E ( X + Y ) = EX + EY $.</p>
</li>
<li><p>$E ( \alpha X ) = \alpha EX $.</p>
</li>
<li><p>如果$X $和$Y $互相独立,那么$E ( XY ) = ( EX ) ( EY ) $.</p>
</li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3><p>我们考虑方差的定义式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X - EX ) ^2 ) & = E ( X ^2 - 2 X ( EX ) + ( EX ) ^2 ) \\
& = E ( X ^2 ) - 2 ( EX ) ( EX ) + ( EX ) ^2 \\
& = E ( X ^2 ) - ( EX ) ^2 
\end{aligned}</script><p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当$X $和$Y $为独立的随机变量时,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( ( X + Y ) ^2 ) - ( EX + EY ) ^2 \\
& = E ( ( X + Y ) ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 
\end{aligned}</script><p>而又有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( ( X + Y ) ^2 ) & = E ( X ^2 + 2 XY + Y ^2 ) \\
& = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) 
\end{aligned}</script><p>则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
V ( X + Y ) & = E ( X ^2 ) + 2 ( EX ) ( EY ) + E ( Y ^2 ) - ( EX ) ^2 - 2 ( EX ) ( EY ) - ( EY ) ^2 \\
& = VX + VY 
\end{aligned}</script><p>即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式:</p>
<script type="math/tex; mode=display">
\Pr ( ( X - EX ) ^2 \geq \alpha ) \leq \cfrac { VX  } { \alpha  } , \alpha > 0</script><p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
VX & = \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) \\
& \geq \sum _{ \omega \in \Omega  } ( X ( \omega ) - EX ) ^2 \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& \geq \sum _{ \omega \in \Omega  } \alpha \Pr ( \omega ) [ ( X ( \omega ) - EX ) ^2 & \geq \alpha ] \\
& = \alpha \Pr ( ( X - EX ) ^2 & \geq \alpha ) 
\end{aligned}</script><p>如果我们用$c ^2 VX $代替$\alpha $,我们就有:</p>
<p>$\Pr ( | X - EX | \geq c \sigma ) \leq \cfrac { 1  } { c ^2  } $.</p>
<p>简单来说,这个不等式说明:$X $落在$( EX - c \sigma , EX + c \sigma ) $之外的概率至多为$\cfrac { 1  } { c ^2  } $.</p>
<p>另外,如果我们取$n $个独立的样本$X _1 , X _2 , . . . , X _n $,令$S = \sum _{ i = 1  } ^n X _i $,那么它的均值是$nEX $,标准差是$\sqrt { n  } \sigma $,也就是说,$\cfrac { S  } { n  } $落在$( EX - \cfrac { c \sigma  } { \sqrt { n  }  } , EX + \cfrac { c \sigma  } { \sqrt { n  }  } ) $之外的概率小于等于$\cfrac { 1  } { c ^2  } $.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3><p>如果我们随机取得了$n $个值$X _1 , X _2 , . . . , X _n $,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p>$\hat EX = \cfrac { \sum _{ i = 1  } ^n X _i  } { n  } $.</p>
<p>$\hat VX = \cfrac { \sum _{ i = 1  } ^n X _i ^2  } { n - 1  } - \cfrac { ( \sum _{ i = 1  } ^n X _i ) ^2  } { n ( n - 1 )  } $.</p>
<p>这里的$\hat VX $似乎与定义不是那么相符.但是它拥有更好的性质:$E ( \hat VX ) = VX $.</p>
<p>证明如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
E ( \hat VX ) & = \cfrac { 1  } { n - 1  } E ( \sum _{ i = 1  } ^n X _i ^2 - \cfrac { 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k = 1  } ^n X _j X _k ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X _i ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n E ( X _i X _j ) ) \\
& = \cfrac { 1  } { n - 1  } ( \sum _{ i = 1  } ^n E ( X ^2 ) - \cfrac { 1  } { n  } \sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( ( EX ) ^2 [ j \ne k ] + E ( X ^2 ) [ j & = k ] ) ) \\
& = \cfrac { 1  } { n - 1  } ( nE ( X ^2 ) - \cfrac { 1  } { n  } ( nE ( X ^2 ) + n ( n - 1 ) ( EX ) ^2 ) ) \\
& = E ( X ^2 ) - ( EX ) ^2 \\
& = VX 
\end{aligned}</script><h3><span id="条件概率">条件概率</span></h3><p>已知事件B发生时事件A发生的概率为$P ( A | B ) = \frac { P ( AB )  } { P ( B )  } \ $.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4><p>贝叶斯公式:如果有$\{ B _i \} $是样本空间的一个划分,即$\forall i , j $,有$B _i \cap B _j = \emptyset $,并且有$\bigcup _{ i = 1  } ^n B _i = \Omega $.则有$P ( B _i | A ) = \frac { P ( AB _i )  } { P ( A )  } = \frac { P ( AB _i )  } { P ( A ) \sum P ( B _j )  } = \frac { P ( A B _i )  } { \sum _{ j = 1  } ^n P ( A B _j )  } = \frac { P ( A | B _i ) P ( B _i )  } { \sum _{ j = 1  } ^n P ( A | B _j ) P ( B _j )  } \ $.</p>
<p>简化形式:$P ( B | A ) = \frac { P ( A | B ) P ( B )  } { P ( A )  } \ $.</p>
<p>另外,我们考虑设$O ( B ) = \cfrac { P ( B )  } { P ( \lnot B )  } $,称$\cfrac { P ( B | E )  } { P ( \lnot B | E )  } $为贝叶斯算子,则同理可得:</p>
<script type="math/tex; mode=display">
O ( B | E ) = O ( B ) \cfrac { P ( B | E )  } { P ( \lnot B | E )  }</script><p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3><p>如果$X $是定义在概率空间$\Omega $上的随机变量,那么它的概率生成函数为$G _X ( z ) = \sum _{ k \geq 0  } \Pr ( X = k ) z ^k = E ( z ^X ) $.</p>
<p>不难发现$G _X ( z ) $需要满足的条件:所有系数都非负并且$G _X ( 1 ) = 1 $.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = G _X ' ( 1 ) \\
E ( X ^2 ) & = G ' ' _X ( 1 ) + G _X ' ( 1 ) \\
VX & = G _X ' ' ( 1 ) + G _X ' ( 1 ) - ( G _X ' ( 1 ) ) ^2 
\end{aligned}</script><p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G ) & = G ' ( 1 ) \\
Var ( G ) & = G ' ' ( 1 ) + G ' ( 1 ) - ( G ' ( 1 ) ) ^2 
\end{aligned}</script><p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<script type="math/tex; mode=display">
G ( 1 + t ) = \sum _{ i \geq 0  } \cfrac { G ^{ ( i )  } ( 1 )  } { i !  } t ^i</script><p>另外,我们不难发现:$G _{ X + Y  } ( z ) = G _X ( z ) G _Y ( z ) $.</p>
<p>根据前面的推导,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _{ X + Y  } ) & = Mean ( G _X ) + Mean ( G _Y ) \\
Var ( G _{ X + Y  } ) & = Var ( G _X ) + Var ( G _Y ) 
\end{aligned}</script><p>换句话说,若$G _X ( 1 ) = 1 , G _Y ( 1 ) = 1 $,那么这个式子与直接对$G _{ X + Y  } $使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
Mean ( G _X ) & = Mean ( G _{ X + Y  } ) - Mean ( G _Y ) \\
Var ( G _X ) & = Var ( G _{ X + Y  } ) - Var ( G _Y ) 
\end{aligned}</script><h4><span id="example1">Example1</span></h4><p>一枚硬币正面向上的概率为$p $,反面向上的概率为$q $,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设$N $为所有不包含THTTH的硬币序列的生成函数,$S $为所有只有结尾为THTTH的硬币序列的生成函数,令$H = pz , T = qz $,$1 $为空集,我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N \times ( H + T ) & = N + S \\
N \times THTTH & = S + S \times TTH 
\end{aligned}</script><p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设$A $是我们要找到的字符串,$m $是它的长度,令$A ^{ ( k )  } $表示$A $字符串的前$k $个字符所组成的字符串,$A _{ ( k )  } $表示$A $字符串的后$k $个字符所组成的字符串.这样的形式与$k $阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S \\
N \times A & = S ( \sum _{ k = 0  } ^{ m - 1  } A ^{ ( k )  } [ A ^{ ( m - k )  } & = A _{ ( m - k )  } ] ) 
\end{aligned}</script><p>如果我们设$\tilde { A  } $为将字符串$A $中的H替换成$\cfrac { 1  } { p  } z $,T替换成$\cfrac { 1  } { q  } z $之后的值,那么显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N \times A & = A \times S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
N & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
\cfrac { S - 1  } { H + T - 1  } & = S \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] ) ) & = 1 
\end{aligned}</script><p>这显然是一个卷积的形式.</p>
<p>令$w = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.</p>
<p>令$H ( z ) = 1 $,$F ( z ) = ( 1 + ( 1 - z ) \times w ) $,$G ( z ) = S $.</p>
<p>那么我们显然可以直接求$G ( z ) $的期望和方差,事实上:</p>
<script type="math/tex; mode=display">
\begin{aligned}
EX & = \sum _{ k = 1  } ^{ m  } \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] \\
VX & = ( EX ) ^2 - \sum _{ k = 1  } ^m ( 2 k - 1 ) \tilde { A  } _{ ( k )  } [ A ^{ ( k )  } & = A _{ ( k )  } ] 
\end{aligned}</script><p>如果硬币是均匀的($p = q = \cfrac { 1  } { 2  } $)我们引入另一个符号:我们设$A : A = \sum _{ k = 1  } ^m 2 ^{ k  } [ A ^{ ( k )  } = A _{ ( k )  } ] $.那么显然期望需要的抛硬币次数就是$( A : A ) $.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4><p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设$S _A $为所有以HHT结尾的硬币序列的生成函数,设$S _B $为所有以HTT结尾的硬币序列的生成函数.$N $为其它的硬币序列的生成函数,令$H = T = 0 . 5 z $.</p>
<p>我们显然有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
1 + N ( H + T ) & = N + S _A + S _B \\
N \times HHT & = S _A \\
N \times HTT & = S _A \times T + S _B 
\end{aligned}</script><p>解方程并带入$z = 1 $,可以有得知以HHT结尾的概率为$\cfrac { 2  } { 3  } $.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为$A $和$B $,那么可以求出:</p>
<script type="math/tex; mode=display">
\cfrac { S _A  } { S _B  } = \cfrac { B : B - B : A  } { A : A - A : B  }</script><h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4><p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设$g _i $表示进行了$i $步还未结束的概率,$f _{ k , i  } $为进行了$i $步恰好第$k $个人胜利的概率,$F , G $是它们的生成函数,我们自然有:</p>
<ol>
<li><p>$1 + xG ( x ) = \sum _k F _k ( x ) + G ( x ) $.</p>
</li>
<li><p>$( \frac { 1  } { 2  } x ) ^L G ( x ) = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^i [ A _k ^{ ( L - i )  } = { A _j  } _{ ( L - i )  } ] $.</p>
</li>
</ol>
<p>第一个式子的用处在于带入$x = 1 $,发现$\sum _{ k  } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{ L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  } & = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) & = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{ L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } & = { A _j  } _{ ( i )  } ] 
\end{aligned}</script><p>带入$x = 1 $,有:</p>
<script type="math/tex; mode=display">
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [ A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]</script><p>不难发现对于不同的$k $,(2)的右边不同,而左边一定相同,这样就给出了$n $个等式,算上(1)一共有$n + 1 $个等式,可以算出$G ( 1 ) , F _{ 1 \cdots n  } ( 1 ) $这$n + 1 $个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3><p>现在有一个大小为$n + 1 $的概率空间,其中$\Pr ( \omega _k ) = \binom { n  } { k  } p ^k q ^{ n - k  } \ $,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令$H ( z ) = q + pz $,不难发现二项式分布的生成函数为$H ( z ) ^n $.</p>
<p>不难发现,满足二项式分布的随机变量的均值是$np $,方差是$npq $.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:$G ( z ) ^n = ( \cfrac { p  } { 1 - qz  } ) ^n = \sum _{ k  } \binom { n + k - 1  } { k  } p ^n q ^k z ^k $.</p>
<p>我们考虑如何求$G ( z ) $的方差和均值,不妨设$F ( z ) = \cfrac { 1 - qz  } { p  } = \cfrac { 1  } { p  } - \cfrac { q  } { p  } z $,则$G ( z ) ^n = F ( z ) ^{ - n  } $.</p>
<p>不难发现$F ( z ) $满足二项式分布.也就是说,以$( n , p , q ) $为参数的负二项式分布也就是以$( - n , - \cfrac { q  } { p  } , \cfrac { 1  } { p  } ) $为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3><h4><span id="树上随机游走">树上随机游走</span></h4><p>随机游走指每次从相邻的点中随机选一个走过去， 重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5><p>给一棵所有边长都为$1 $的$n $个点的树,问所有点对$( i , j ) ( 1 \leq i , j \leq n ) $中,从$i $走到$j $的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设$f _u $表示$u $随机走到它父亲的期望,$g _v $表示$v $的父亲(假设是$u $)走到$v $的期望.</p>
<p>对于$f _u $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { \sum _{ u \rightarrow v  } ( f _v + f _u )  } { \deg _u  } + 1 \\
f _u & = \deg _u + \sum _{ u \rightarrow v  } f _v 
\end{aligned}</script><p>对于$g _v $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g _v & = \cfrac { g _u + g _v + \sum _{ u \rightarrow w , w \ne v  } ( g _v + f _w )  } { \deg _u  } + 1 \\
g _v & = g _u + \sum _{ u \rightarrow w , w \ne v  } f _w + \deg _u 
\end{aligned}</script><h5><span id="example2">Example2</span></h5><p>给出一棵$n $个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从$1 $号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案$+ 1 $.当走到度数为$1 $的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设$f _u $表示以$u $为起点的路径的期望长度,不难注意到$f _{ leaf  } = 1 $且$f _u = 1 + \cfrac { 1  } { \deg _u  } \sum _{ u \rightarrow v \lor v \rightarrow u  } f _v $.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得$f _u = k _u f _{ fa  } + b _u $,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出$g _v $表示从$v $的父亲(假设是$u $)走到$v $的概率,再令$f _u $表示从$u $走到父亲的概率,类似Example1,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _u & = \cfrac { 1  } { \deg _u  } ( 1 + \sum _{ u \rightarrow v  } f _v f _u ) \\
g _v & = \cfrac { 1  } { \deg _u  } ( 1 + g _v g _u + \sum _{ u \rightarrow w , w \ne v  } f _w g _v ) 
\end{aligned}</script><p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4><h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5><p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为$\frac { 1  } { \binom { n  } { 2  }  } $.</p>
<p>把所有人权值从大到小排序,设$f _i $表示只考虑前$i $个人的时候的期望,不难发现:$f _{ i  } = \frac { 1  } { \binom { i  } { 2  }  } v _i + ( 1 - \frac { 1  } { \binom { i  } { 2  }  } ) f _{ i - 1  } $.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4><h5><span id="example1cf865c">Example1(CF865C)</span></h5><p>首先写出转移式子,但是存在后效性.如果我们设$f _{ i , j  } $表示过了$i $关,花费为$j $的期望,不难发现所有的$f $都需要与$f _{ 0 , 0  } $取$\min $,这咋办?</p>
<p>我们考虑二分这个$f _{ 0 , 0  } $,做的时候直接取$\min $,这样最后还会求出一个$f _{ 0 , 0  } $,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的$f _{ 0 , 0  } $越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取$\min $的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5><p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5><p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张$n \times m $的图(假设$n \geq m $),其中格点$( a , b ) $表示现在还剩$a $个Yes,$b $个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从$( n , m ) $走到$( 0 , 0 ) $的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线$y = x $翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从$( n , m ) $走到$( 0 , 0 ) $一定会经过$n $条有向边,所以期望贡献一定要加上一个$n $.而如果我走到了直线$y = x $上,那接下来的贡献是$\frac { 1  } { 2  } $.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2><h3><span id="树">树</span></h3><ol>
<li><p>随机树树高为$\sqrt { n  } $.</p>
</li>
<li><p>点的度数期望为$\log n $.</p>
</li>
</ol>
<h3><span id="数">数</span></h3><ol>
<li>数字的期望因数个数为$\log V $.</li>
</ol>
<h3><span id="序列">序列</span></h3><ol>
<li>随机序列的LIS长度期望为$O ( \sqrt { n  } ) $.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2><h3><span id="数值概率算法">数值概率算法</span></h3><p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3><p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的monte-carlo算法">求解最优化问题的Monte Carlo算法</span></h5><p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte Carlo算法.</p>
<h5><span id="求解判定性问题的monte-carlo算法">求解判定性问题的Monte Carlo算法</span></h5><ol>
<li><p>假倾向的Monte Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p>
</li>
<li><p>真倾向的Monte Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p>
</li>
<li><p>产生双侧错误的Monte Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p>
</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5><p>显然,如果我们有一个单词正确率为$p $,时间复杂度为$O ( f ( n ) ) $的算法,我们运行其$k $次,则正确率为$1 - ( 1 - p ) ^k $,时间复杂度为$O ( kf ( n ) ) $.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5><p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举一些元素.</p>
</li>
<li><p>设这个算法的复杂度为$O ( f ( n ) g ( n ) ) $,其中$f ( n ) $为枚举部分的复杂度,$g ( n ) $为单词枚举中计算所需的复杂度.大部分情况下应保证$g ( n ) $不会很大.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找元素来降低复杂度.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度.</p>
</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要用到一个或多个传入的元素.</p>
</li>
<li><p>这个元素的值不应该依赖于输入数据.</p>
</li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机这个元素.</p>
</li>
<li><p>计算随机化情况下的正确率以及复杂度</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6><p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6><p>平面上有$n $个互不重合的点,已知存在不超过$7 $条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.$n \leq 10000 $.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是$O ( n ^3 ) $的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于$\lceil \frac { n  } { 7  } \rceil $个点.换句话说,我们随机一个点,这个点在这条直线上的概率是$\frac { 1  } { 7  } $,因此随机两个点确定这条直线的概率为$\frac { 1  } { 49  } $.随机$1000 $次,错误概率为$1 - ( \frac { 48  } { 49  } ) ^{ 1000  } $,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6><p>给定一个长度为$n $的序列,要求找出一个长度大于等于$\frac { n  } { 2  } $的子序列,使这个子序列中所有数的$\gcd $最大,求最大的$\gcd $.$n \leq 10 ^6 $,$a _i \leq 10 ^{ 12  } $.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是$\frac { 1  } { 2  } $.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度$O ( n \sqrt { a  } ) $,好像不太能过.</p>
<p>冷静一下,我们不妨将这$\sqrt { a  } $个质因子全都存下来,然后将$n $个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个$\gcd $,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6><p>给定长度为$n $的序列$a $,有$m $次询问,每次给定一个区间$[ l , r ] $,问$a [ l , r ] $中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.$( n , m \leq 500000 , 1 \leq a _i \leq n ) $.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5><p>先考虑$k = 2 $的情况:</p>
<p>首先,我们自然可以枚举一个向量$A $并判断它与其它向量的内积,这样复杂度为$O ( n ^2 d ) $.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设$A = \begin{bmatrix}\vec { a _1  } , \vec { a _2  } , . . . , \vec { a _n  } \end{bmatrix} $,那我们要验证的无非是$B = AA ^T $中是否存在一个不在主对角线上的元素$B _{ i , j  } $在$\mod 2 $意义下为$0 $.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵$C $,其中$C $的主对角线元素与$B $相同,而其他元素全是$1 $.接下来我们要做的无非是找到$B $和$C $不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果$B = C $,那么对于任意一个$X _{ m \times n  } $都应该满足$XB = XC $,取$m = 1 $,我们的问题就转化为:是否能找到一个$X $,使得$XB \ne XC $?这显然可以随机化.计算前者的复杂度为$O ( nd ) $,后者由于$C $很特殊,可以在$O ( n ) $的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte Carlo算法.问题在于正确率:</p>
<p>令$D = B - C $,若返回相等但实际上不相等,则$D $中至少存在一个不为$0 $的数字,假设$D _{ i , j  } \ne 0 $.我们令$E = X \times D $,那么只有当$E $是零向量时才会错误.而$E _j = \sum _{ k  } X _k D _{ k , j  } $,不难解得:$E _i = - \frac { 1  } { D _{ i , j  }  } \sum _{ k \ne i  } X _k D _{ k , j  } $,也就是说如果$X $的其它位置都确定了,那么$E $只有一种取值会返回错误.由于$k $一共就俩取值,所以正确率至少$\frac { 1  } { 2  } $.</p>
<p>至于找到答案:我们找到一个不为$0 $的$E _i $,那么一定存在一组解包含了第$i $个向量,只需枚举另一个向量检验就行,复杂度$O ( nd ) $.</p>
<p>$k = 3 $的话,我们注意到$\mod 3 $意义下,$1 $和$2 $的平方都是$1 $.考虑$\sum _{ j  } B _{ i , j  } ^2 X _j = \sum _{ j  } B _{ i , j  } X _j B _{ h , i  } ^T $,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3><p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5><h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6><ol>
<li><p>这个算法需要枚举全排列.</p>
</li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p>
</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6><ol>
<li><p>随机化寻找排列来降低复杂度.</p>
</li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p>
</li>
</ol>
<h5><span id="example">Example</span></h5><h6><span id="快速排序算法">快速排序算法</span></h6><p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设$T ( n ) $表示对长度为$n $的序列运行快速排序算法所需的期望时间,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( 0 ) & = 0 \\
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) 
\end{aligned}</script><p>做放缩(可能有些地方需要$+ 1 $或者$- 1 $或者加取整,但是问题不大,反正是期望):</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & = n + \frac { 1  } { n  } \sum _{ i = 0  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ n - 1  } ( T _i + T _{ n - i - 1  } ) \\
& = n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( i ) + T ( n - i - 1 ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( i ) + T ( n - i - 1 ) ) 
\end{aligned}</script><p>由于$T ( n ) \geq n $,所以对于$\frac { n  } { 2  } \leq i \leq j $,我们显然有:$T ( i ) + T ( n - i ) \leq T ( j ) + T ( n - j ) $.</p>
<p>因此:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 2  } { n  } \sum _{ i = \frac { n  } { 2  }  } ^{ \frac { 3 n  } { 4  }  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) ) + \frac { 2  } { n  } \sum _{ i = \frac { 3 n  } { 4  }  } ^{ n  } ( T ( n - 1 ) + T ( 0 ) ) \\
& \leq n + \frac { 1  } { 2  } ( T ( \frac { 3 n  } { 4  } ) + T ( \frac { n  } { 4  } ) + T ( n - 1 ) ) 
\end{aligned}</script><p>我们要证明$\exists c $,$T ( n ) \leq cn \log n $,考虑使用数学归纳法,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
T ( n ) & \leq n + \frac { 1  } { 2  } ( \frac { 3 cn  } { 4  } \log ( \frac { 3 n  } { 4  } ) + \frac { cn  } { 4  } \log ( \frac { n  } { 4  } ) + c ( n - 1 ) \log ( n - 1 ) ) \\
& \leq n + c ( \frac { 3 n  } { 8  } \log n - \frac { 3 n  } { 8  } \log \frac { 4  } { 3  } + \frac { n  } { 8  } \log n - \frac { n  } { 4  } + \frac { n  } { 2  } \log n ) \\
& = cn \log n + n ( 1 - \frac { 3 c  } { 8  } \log ( \frac { 4  } { 3  } ) - \frac { c  } { 4  } ) 
\end{aligned}</script><p>于是显然存在,假设成立.</p>
<h6><span id="一类由monte-carlo算法改造而成的算法">一类由Monte Carlo算法改造而成的算法</span></h6><p>对于一类一定有解的构造性问题,假设我们有一个正确率为$p $,时间复杂度为$O ( f ( n ) ) $的产生单侧错误的Monte Carlo算法,我们时图将其改造为Las Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行$k $次,则:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } i \\
( 1 - p ) k & = \sum _{ i = 1  } ^{ \infty  } p ( 1 - p ) ^i i \\
pk & = \sum _{ i = 2  } ^{ \infty  } p ( 1 - p ) ^{ i - 1  } & = p \sum _{ i = 0  } ^{ \infty  } ( 1 - p ) ^i \\
k & = \frac { 1  } { p  } 
\end{aligned}</script><p>则期望复杂度为$O ( \frac { f ( n )  } { p  } ) $.</p>
<h6><span id="example3cf329c-graph-reconstruction">Example3(CF329C Graph Reconstruction)</span></h6><h6><span id="example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6><p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置$x _1 $和第二个位置$x _2 $,显然只要问到$[ x _1 , x _2 ) $是正确的.</p>
<p>考虑因为是随机,所以$x _1 \times 2 \leq x _2 $的概率应当是不低的(事实上约为$\frac { 1  } { 2  } $),而此时的$[ x _1 , x _2 ) $中必有一个位置是二的整数幂,因此我们查询一个等比数列:$1 , 2 , 4 , . . . $.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3><h4><span id="爬山">爬山</span></h4><p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4><p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<script type="math/tex; mode=display">
P = \begin{cases}
1 & E _{ t + 1  } > E _t \\
e ^{ \frac { E _{ t + 1  } - E _t  } { T  }  } & E _{ t + 1  } \leq E _t 
\end{cases}</script><p>具体流程是,先设定一个初始温度$T _0 $,降温速度$k \in ( 0 , 1 ) $,以及终止温度$T _k $,每次操作后让$T = kT $,直到其小于终止温度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/4/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
