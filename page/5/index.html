<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/5/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js" defer></script>





  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3>
<p>三个柱子,<span class="math inline">\(n\)</span>个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令<span class="math inline">\(T_n\)</span>表示答案,显然<span class="math inline">\(T_0 = 0 , T_1 = 1\)</span>.</p>
<p>而我们一定可以找到一种方案,使得前<span class="math inline">\(n -
1\)</span>个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把<span class="math inline">\(n -
1\)</span>个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:<span class="math inline">\(T_n \leq 2 T_{ n - 1 } + 1\)</span>.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:<span class="math inline">\(2 T_{ n - 1 } + 1 \leq T_n\)</span>.于是有<span class="math inline">\(T_n = 2 T_{ n - 1 } + 1\)</span>.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4>
<p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4>
<p>考虑设<span class="math inline">\(T_n\)</span>为n个圆盘时的最小操作次数.假设已知<span class="math inline">\(T_{ n - 1 }\)</span>,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:<span class="math inline">\(T_{ n } = 3 T_{ n - 1 } + 2 , T_0 =
0\)</span>.</p>
<p>考虑如何求该式子的封闭形式,令<span class="math inline">\(W_n = T_n +
1\)</span>,显然有<span class="math inline">\(W_n = 3 W_{ n - 1 } , W_0 =
1\)</span>,显然<span class="math inline">\(W_n = 3^n\)</span>,有<span class="math inline">\(T_n = 3^n - 1\)</span>.</p>
<p>注意到<span class="math inline">\(T_n\)</span>刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4>
<p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于<span class="math inline">\(2^n - 1\)</span>.</p>
<h4><span id="solution-2">Solution 2</span></h4>
<p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4>
<p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4>
<p>令<span class="math inline">\(Q_n\)</span>为将n个圆盘从A移动到B的最小操作次数,令<span class="math inline">\(R_n\)</span>为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,<span class="math inline">\(Q_0 = 0 , R_0 =
0\)</span>.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此<span class="math inline">\(Q_n\)</span>的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,<span class="math inline">\(R_n\)</span>的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有<span class="math inline">\(Q_n = 2 R_{ n - 1 } + 1 , 1 \leq
n\)</span>.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有<span class="math inline">\(R_n = R_{ n - 1 } + 1 + Q_{ n - 1 } + 1
+ R_{ n - 1 } = Q_n + Q_{ n - 1 } + 1 , 1 \leq n\)</span>.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4>
<p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4>
<p>a.仍然令<span class="math inline">\(T_n\)</span>为n对圆盘的最小操作次数,显然<span class="math inline">\(T_n = 2 T_{ n - 1 } + 2 , T_0 =
0\)</span>,可解得<span class="math inline">\(T_n = 2^{ n + 1 } -
2\)</span>.</p>
<p>b.令<span class="math inline">\(Q_n\)</span>为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现<span class="math inline">\(Q_n = T_{ n - 1 } + 1 + T_{ n - 1 } + 1 + T_{ n -
1 } + 1 + T_{ n - 1 } = 4 T_{ n - 1 } + 3 = 2^{ n + 2 } -
5\)</span>.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的<span class="math inline">\(Q_n\)</span>就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4>
<p>类似Problem11,但第<span class="math inline">\(i\)</span>大的圆盘有<span class="math inline">\(k_i\)</span>个.</p>
<h4><span id="solution-5">Solution 5</span></h4>
<p>无区别,只是<span class="math inline">\(T_n = 2 T_{ n - 1 } + k_n ,
T_0 = 0\)</span>.</p>
<p>如果求封闭形式的话,显然有<span class="math inline">\(T_n = \sum_{ i =
1 }^n 2^{ n - i } k_i\)</span>.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3>
<p>在上述问题中，我们已经有了以下式子：</p>
<p><span class="math inline">\(T_n = 2 T_{ n - 1 } + 1 , n &gt; 0 , T_0
= 0\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出<span class="math inline">\(T_n\)</span>的方法.</p>
<p>换句话说，我们想要把<span class="math inline">\(T_n\)</span>表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4>
<h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5>
<p>解递归式:<span class="math inline">\(Q_n = \begin{cases}\alpha &amp;
n = 0 \\ \beta &amp; n = 1 \\ \frac{ ( 1 + Q_{ n - 1 } ) }{ Q_{ n - 2 }
} &amp; n &gt; 1\end{cases}\)</span>,保证<span class="math inline">\(\forall n , Q_n &gt; 0\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>注意到<span class="math inline">\(Q_2 = \frac{ \beta + 1 }{ \alpha }
, Q_3 = \frac{ \beta + \alpha + 1 }{ \beta \alpha } , Q_4 = \frac{ 1 +
\alpha }{ \beta } , Q_5 = \alpha , Q_6 = \beta\)</span>.</p>
<p>显然该递归式存在长度为<span class="math inline">\(5\)</span>的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4>
<p>观察T序列的前几项，可以发现似乎有<span class="math inline">\(T_n =
2^n - 1\)</span>.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于<span class="math inline">\(n =
0\)</span>成立，显然可验证.</p>
<p>2.若该公式对<span class="math inline">\(n =
k\)</span>时成立，那该公式必然对<span class="math inline">\(n = k +
1\)</span>成立.</p>
<p>因为有<span class="math inline">\(T_{ k + 1 } = 2 T_k + 1 = 2 \times
2^k + 2 - 1 = 2^{ k + 1 } - 1\)</span>.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5>
<p>求证:<span class="math inline">\(\prod_{ i = 1 }^n x_i \leq ( \frac{
\sum_{ i = 1 }^n x_i }{ n } )^n , \forall i \in N_+ , 1 \leq i \leq n ,
0 \leq x_i\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>使用反向归纳法.</p>
<p>1.<span class="math inline">\(n =
2\)</span>时,即基本不等式,显然成立.</p>
<p>2.若该式子对<span class="math inline">\(n =
k\)</span>时成立,则该式子对n=2k时也成立.</p>
<p>不妨令<span class="math inline">\(A_1 = \sqrt[k]{ \prod_{ i = 1 }^k
x_i } , B_1 = \sqrt[k]{ \prod_{ i = k + 1 }^{ 2 k } x_i } , A_2 = (
\frac{ \sum_{ i = 1 }^k x_i }{ k } ) , B_2 = ( \frac{ \sum_{ i = k + 1
}^{ 2 k } x_i }{ k } )\)</span>,显然有<span class="math inline">\(A_1
\leq A_2 , B_1 \leq B_2\)</span>.</p>
<p>同时有<span class="math inline">\(( \frac{ A_2 + B_2 }{ 2 } ) \geq
\sqrt{ A_2 B_2 } \geq \sqrt{ A_1 B_1 }\)</span>.</p>
<p>3.若该式子对<span class="math inline">\(n =
k\)</span>时成立,则该式子对<span class="math inline">\(n = k -
1\)</span>的时候也成立.</p>
<p>令<span class="math inline">\(x_k = \frac{ \sum_{ i = 1 }^{ k - 1 }
x_i }{ k - 1 }\)</span>,有<span class="math inline">\(x_k \prod_{ i = 1
}^{ k - 1 } x_i \leq ( x_k )^k\)</span>.</p>
<p>则显然<span class="math inline">\(n = k - 1\)</span>时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4>
<p>考虑令<span class="math inline">\(U_n = T_n + 1\)</span>,显然有:<span class="math inline">\(T_n + 1 = 2 T_{ n - 1 } + 2\)</span>.即<span class="math inline">\(U_n = 2 U_{ n - 1 }\)</span>,显然<span class="math inline">\(U_n = 2^n\)</span>,则<span class="math inline">\(T_n = 2^n - 1\)</span>.</p>
<p>这个做法可以做掉所有形如<span class="math inline">\(a_{ n + 1 } =
pa_n + q\)</span>的递归式.我们有:</p>
<p><span class="math display">\[
a_{ n + 1 } + \frac{ q }{ p - 1 } = p ( a_n + \frac{ q }{ p - 1 } )
\]</span></p>
<p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4>
<p>考虑递归式<span class="math inline">\(a_n T_n = b_n T_{ n - 1 } +
c_n\)</span>.如果我们能找到一个不为0的求和因子<span class="math inline">\(s_n\)</span>并满足<span class="math inline">\(s_n
b_n = s_{ n - 1 } a_{ n - 1 }\)</span>.那么我们两面同时乘以<span class="math inline">\(s_n\)</span>,显然有：<span class="math inline">\(s_n a_n T_n = s_{ n - 1 } a_{ n - 1 } T_{ n - 1 }
+ c_n s_n\)</span>.</p>
<p>令<span class="math inline">\(S_n = s_n a_n T_n\)</span>.显然有<span class="math inline">\(S_n = s_0 a_0 T_0 + \sum_{ i = 1 }^n s_i
c_i\)</span>,则<span class="math inline">\(T_n = \frac{ S_n }{ s_n a_n
}\)</span>.</p>
<p>而我们也会发现<span class="math inline">\(s_n = \frac{ \prod_{ i = 1
}^{ n - 1 } a_i }{ \prod_{ i = 1 }^n b_i }\)</span>.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5>
<p>结论:排序<span class="math inline">\(n\)</span>个数时,其期望复杂度满足:</p>
<p><span class="math display">\[
C_n = \begin{cases}
0 &amp; n = 0 , 1 \\
n + 1 + \frac{ 2 }{ n } \sum_{ i = 0 }^{ n - 1 } C_k &amp; n &gt; 1
\end{cases}
\]</span></p>
<p>不妨考虑两边同时乘以<span class="math inline">\(n\)</span>,有 <span class="math inline">\(nC_n = n^2 + n + 2 \sum_{ i = 0 }^{ n - 1 } C_i ,
n &gt; 1\)</span> .</p>
<p>显然也有<span class="math inline">\(( n - 1 ) C_{ n - 1 } = ( n - 1
)^2 + n - 1 + 2 \sum_{ i = 0 }^{ n - 2 } C_i , n &gt; 2\)</span>.</p>
<p>二式相消,有<span class="math inline">\(nC_n - ( n - 1 ) C_{ n - 1 } =
2 n + 2 C_{ n - 1 } , n &gt; 2\)</span>.</p>
<p>而同时有<span class="math inline">\(C_2 = 3\)</span>.即:<span class="math inline">\(nC_n = ( n + 1 ) C_{ n - 1 } + 2 n , n &gt;
2\)</span>,可以使用转化和式的方法,两边乘以<span class="math inline">\(\frac{ 1 }{ n ( n + 1 ) }\)</span>解决.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知<span class="math inline">\(a_1 = 1\)</span>,<span class="math inline">\(a_n = \sqrt{ S_n } + \sqrt{ S_{ n - 1 }
}\)</span>,求<span class="math inline">\(a_n\)</span>.</p>
<p>注意到<span class="math inline">\(a_n = S_n - S_{ n - 1
}\)</span>,则有<span class="math inline">\(\sqrt{ S_n } - \sqrt{ S_{ n -
1 } } = 1\)</span>,于是<span class="math inline">\(\sqrt{ S_n } =
n\)</span>,<span class="math inline">\(S_n = n^2\)</span>,<span class="math inline">\(a_n = 2 n - 1\)</span>.</p>
<h4><span id="成套方法">成套方法</span></h4>
<p>如果我们有</p>
<p>&amp; n=1\</p>
<p>2f(n 2)+&amp; n=2k,k\</p>
<p>2f(2)+&amp;n=2k+1,k</p>
<p>\end{cases}</p>
<p>其中<span class="math inline">\(n = 2^m + l\)</span>且<span class="math inline">\(2^m \leq n &lt; 2^{ m + 1 }\)</span>.</p>
<p>该如何求出<span class="math inline">\(f ( n
)\)</span>的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有<span class="math inline">\(f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n )
\gamma\)</span>,而有<span class="math inline">\(A 、 B 、
C\)</span>互不影响且<span class="math inline">\(\alpha \beta
\gamma\)</span>与<span class="math inline">\(ABC\)</span>无关.</p>
<p>那无论<span class="math inline">\(\beta\)</span>和<span class="math inline">\(\gamma\)</span>的取值如何,<span class="math inline">\(A ( n )\)</span>都不会受到影响,我们考虑<span class="math inline">\(\beta = \gamma =
0\)</span>的特殊情况,此时显然有<span class="math inline">\(A ( n ) =
2^m\)</span>.</p>
<p>接下来,我们考虑取<span class="math inline">\(\alpha \beta
\gamma\)</span>的特殊值,去得到ABC之间的关系.</p>
<p>例如，当<span class="math inline">\(f ( n ) =
1\)</span>时，由递推式可知<span class="math inline">\(\alpha = 1 , \beta
= \gamma = - 1\)</span>,那么有<span class="math inline">\(A ( n ) - B (
n ) - C ( n ) = f ( n ) = 1\)</span>.</p>
<p>同理，<span class="math inline">\(f ( n ) = n\)</span>时，可知<span class="math inline">\(\alpha = 1 , \beta = 0 , \gamma =
1\)</span>,此时有<span class="math inline">\(A ( n ) + C ( n ) = f ( n )
= n\)</span>.</p>
<p>显然可以通过解方程求得<span class="math inline">\(B ( n
)\)</span>和<span class="math inline">\(C ( n )\)</span>.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明<span class="math inline">\(ABC\)</span>互不影响且<span class="math inline">\(\alpha \beta \gamma\)</span>与<span class="math inline">\(ABC\)</span>无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4>
<p>一个常系数的<span class="math inline">\(k\)</span>阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = P_n + \sum_{ i = 1 }^k c_i a_{ n - i } , n \geq k \\
a_0 &amp; = C_0 , a_1 = C_1 , . . . , a_{ k - 1 } = C_{ k - 1 }
\end{aligned}
\]</span></p>
<p>当<span class="math inline">\(P = 0\)</span>时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程<span class="math inline">\(r^k = \sum_{ i = 1 }^k c_i r^{
k - i
}\)</span>是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根<span class="math inline">\(r_1\)</span>和<span class="math inline">\(r_2\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r_1^n + \alpha_2
r_2^n\)</span>.</p>
<p>若其特征方程有两个相同的根<span class="math inline">\(r\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r^n + \alpha_2 nr^n\)</span>.</p>
<p>先考虑前者的证明,首先考虑对于<span class="math inline">\(n =
0\)</span>或者<span class="math inline">\(n =
1\)</span>的情况,我们考虑求出一组<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C_0 &amp; = \alpha_1 + \alpha_2 \\
C_1 &amp; = \alpha_1 r_1 + \alpha_2 r_2
\end{aligned}
\]</span></p>
<p>若<span class="math inline">\(r_1 \ne r_2\)</span>,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha_1 &amp; = \cfrac{ C_1 - C_0 r_2 }{ r_1 - r_2 } \\
\alpha_2 &amp; = C_0 - \alpha_1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r_1^{ n - 1 } + \alpha_2 r_2^{ n - 1 } ) + c_2 (
\alpha_1 r_1^{ n - 2 } + \alpha_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 ( c_1 r_1^{ n - 1 } + c_2 r_1^{ n - 2 } ) + \alpha_2 (
c_1 r_2^{ n - 1 } + c_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 r_1^n + \alpha_2 r_2^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有<span class="math inline">\(\Delta = c_1^2 +
4 c_2 = 0\)</span>,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C_0 &amp; = \alpha_1 \\
C_1 &amp; = \alpha_1 r + \alpha_2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r^{ n - 1 } + \alpha_2 nr^{ n - 1 } - \alpha_2
r^{ n - 1 } ) + c_2 ( \alpha_1 r^{ n - 2 } + \alpha_2 nr^{ n - 2 } - 2
\alpha_2 r^{ n - 2 } ) \\
&amp; = a_n - c_1 \alpha_2 r^{ n - 1 } - 2 c_2 \alpha_2 r^{ n - 2 }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明<span class="math inline">\(c_1 r + 2 c_2 =
0\)</span>即可.根据方程,不难发现<span class="math inline">\(r = \cfrac{
c_1 }{ 2 }\)</span>,根据<span class="math inline">\(\Delta =
0\)</span>,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>直接在复数域上定义<span class="math inline">\(f_k ( x ) = \{ n^k x^n
\}_{ n = 0 }^\infty\)</span>,此时我们规定<span class="math inline">\(0^0
= 1\)</span>.特别地,当<span class="math inline">\(x =
0\)</span>的时候,定义<span class="math inline">\(f_k ( x
)\)</span>的第<span class="math inline">\(k\)</span>项是<span class="math inline">\(1\)</span>,其余项是<span class="math inline">\(0\)</span>.在此基础上定义线性映射<span class="math inline">\(T : ( a_n )_{ n = 0 }^\infty \mapsto ( a_{ n + 1 }
)_{ n = 0 }^\infty\)</span>,立刻见到:<span class="math inline">\(( T - x
)^{ k + 1 } f_k ( x ) = 0 , ( T - x )^k f_k ( x ) \ne
0\)</span>.原因只需简单数学归纳.而此还可以引出<span class="math inline">\(f_0 ( x ) , f_1 ( x ) ,
\cdots\)</span>线性无关.</p>
<p>在此基础上观察线性递推<span class="math inline">\(a_{ n + d } = c_{ d
- 1 } a_{ n + d - 1 } + \cdots + c_0 a_n\)</span>,不妨取<span class="math inline">\(G ( x ) = x^d - c_{ d - 1 } x^{ d - 1 } - \cdots -
c_0\)</span>,立刻应当见到如果<span class="math inline">\(a\)</span>是<span class="math inline">\(G\)</span>的根并且重数为<span class="math inline">\(e ( a )\)</span>,那么<span class="math inline">\(f_{ 0 } ( x ) , \cdots , f_{ e ( a ) - 1 } ( a
)\)</span>都在<span class="math inline">\(\ker f ( T
)\)</span>中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如<span class="math inline">\(\sum_j w_i f_i ( y ) = \sum_j w_j f_j ( x
)\)</span>的情况,此时对右边直接操作若干次<span class="math inline">\(( T
- x )\)</span>就可以把右边全部消成<span class="math inline">\(0\)</span>,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于<span class="math inline">\(n\)</span>的多项式右边的<span class="math inline">\(( T - x
)\)</span>是不会改变左边这边的每一个位置多项式的<span class="math inline">\(\deg\)</span>,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是<span class="math inline">\(\vec{ x }_{ k +
1 } = A \vec{ x }\)</span>,<span class="math inline">\(\vec{ x }_{ n } =
A^n \vec{ x }_0\)</span>.而我们又知道CH定理:<span class="math inline">\(p ( A ) = 0\)</span>,我们用多项式取膜,有<span class="math inline">\(A^n = p ( A ) F ( A ) + G ( A ) = G ( A
)\)</span>,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3>
<p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是<span class="math inline">\(2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 ,
9\)</span>.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有<span class="math inline">\(J ( 2 n ) = 2 J
( n ) - 1\)</span>;当人数是奇数时,我们杀掉一号,然后有<span class="math inline">\(J ( 2 n + 1 ) = 2 J ( n ) + 1\)</span>.</p>
<p>整理得到:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 1 \\
2 J ( \frac{ n }{ 2 } ) - 1 &amp; n = 2 k , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 1 &amp; n = 2 k + 1 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>仍然可以使用数学归纳，如果令<span class="math inline">\(n = 2^m + l
且 2^m \leq n &lt; 2^{ m + 1 }\)</span>.</p>
<p>有<span class="math inline">\(J ( n ) = 2 l + 1\)</span>.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从<span class="math inline">\(0\)</span>开始编号:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
0 &amp; n = 1 \\
2 J ( \frac{ n }{ 2 } ) &amp; n = 2 k , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 2 &amp; n = 2 k + 1 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>这下相信<span class="math inline">\(J ( n
)\)</span>是多少就很显然了,将<span class="math inline">\(n\)</span>写成二进制的形式,这个就相当于把首位<span class="math inline">\(1\)</span>抹去然后在末尾加个<span class="math inline">\(0\)</span>.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4>
<p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4>
<p>显然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
2 &amp; n = 2 \\
1 &amp; n = 3 \\
2 J ( \frac{ n }{ 2 } ) - 1 &amp; n = 2 k + 2 , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 1 &amp; n = 2 k + 3 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>从<span class="math inline">\(0\)</span>开始编号,自然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 2 \\
0 &amp; n = 3 \\
2 J ( \frac{ n }{ 2 } ) &amp; n = 2 k + 2 , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 2 &amp; n = 2 k + 3 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>显然<span class="math inline">\(J ( n
)\)</span>也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2>
<h3><span id="和式的基本运算">和式的基本运算</span></h3>
<p>分配律:</p>
<p><span class="math display">\[
\sum_{ i \in S } ca_i = c \sum_{ i \in S } a_i
\]</span></p>
<p>一般分配律:</p>
<p><span class="math display">\[
\sum_{ i } \sum_{ j } a_{ i } b_j = ( \sum_{ i } a_i ) ( \sum_j b_j )
\]</span></p>
<p>结合律:</p>
<p><span class="math display">\[
\sum_{ i \in S } ( a_i + b_i ) = \sum_{ i \in S } a_i + \sum_{ i \in S }
b_i
\]</span></p>
<p>交换律:</p>
<p><span class="math display">\[
\sum_{ i \in S } a_i = \sum_{ p ( i ) \in S } a_{ p ( i ) }
\]</span></p>
<p>交换求和顺序:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i } \sum_{ j } a_{ i , j } [ P ( i , j ) ] &amp; = \sum_{ j }
\sum_{ i } a_{ i , j } [ P ( i , j ) ] \\
\sum_{ i = 1 }^n \sum_{ j = i }^n a_{ i , j } &amp; = \sum_{ j = 1 }^n
\sum_{ i = 1 }^j a_{ i , j }
\end{aligned}
\]</span></p>
<h3><span id="和式的封闭形式">和式的封闭形式</span></h3>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ( ai + b ) = \sum_{ i = 0 }^n ( a ( n - i )
+ b ) \\
2 S_n &amp; = \sum_{ i = 0 }^n ( an + 2 b ) = an ( n + 1 ) + 2 b ( n + 1
) \\
S_n &amp; = ( n + 1 ) ( \frac{ an }{ 2 } + b )
\end{aligned}
\]</span></p>
<h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5>
<p>令<span class="math inline">\(S = \sum_{ 1 \leq i &lt; j \leq n } (
a_j - a_i ) ( b_j - b_i ) = \sum_{ 1 \leq j &lt; i \leq n } ( a_j - a_i
) ( b_j - b_i )\)</span>.</p>
<p>考虑恒等式<span class="math inline">\([ 1 \leq j &lt; i \leq n ] + [
1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq
n ]\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S &amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) -
\sum_{ 1 \leq i = j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = 2 n \sum_{ i = 1 }^n a_i b_i - 2 ( \sum_{ i = 1 }^n a_i ) (
\sum_{ j = 1 }^n b_j ) \\
( \sum_{ i = 1 }^n a_i ) ( \sum_{ j = 1 }^n b_j ) &amp; = n \sum_{ i = 1
}^n a_i b_i - \sum_{ 1 \leq i &lt; j \leq n } ( a_j - a_i ) ( b_j - b_i
)
\end{aligned}
\]</span></p>
<p>显然有以下式子:</p>
<p>(_{i=1}<sup>na_i)(<em>{j=1}^nb_j)n</em>{i=1}</sup>na_ib_i，i&lt;j，a_ia_j且b_ib_j\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5>
<p>证明:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 1 \leq j &lt; k \leq n } ( a_j b_k - a_k b_j )^2 &amp; = ( \sum_{
i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - ( \sum_{ i = 1 }^n a_i
b_i )^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ 1 \leq j &lt; k \leq n } ( a_j b_k - a_k b_j )^2 \\
2 S_n &amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j b_k - a_k b_j )^2
\\
&amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j^2 b_k^2 - 2 a_j a_k b_j
b_k + a_k^2 b_j^2 ) \\
&amp; = 2 ( \sum_{ i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - 2 (
\sum_{ i = 1 }^n a_i b_i )^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ax^i \\
&amp; = a + \sum_{ i = 1 }^n ax^i \\
&amp; = a + x \sum_{ i = 0 }^{ n - 1 } ax^i \\
&amp; = a + xS_{ n - 1 }
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(S_{ n - 1 } + ax^n = S_n = a + xS_{ n -
1 }\)</span>,有<span class="math inline">\(S_n + ax^{ n + 1 } = a + xS_n
, S_n = a \frac{ x^{ n + 1 } - 1 }{ x - 1 }\)</span>，其中<span class="math inline">\(x \ne 1\)</span>.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n i^2 = \sum_{ i = 0 }^{ n - 1 } i^2 + n^2 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^2 + n^2 \\
&amp; = S_n - 2 \sum_{ i = 1 }^n i + n + n^2
\end{aligned}
\]</span></p>
<p>我们无法得到<span class="math inline">\(S_n\)</span>的封闭形式,但我们发现我们得到了<span class="math inline">\(\sum_{ i = 1 }^n i\)</span>的封闭形式.</p>
<p>那以此类推,我们设<span class="math inline">\(W_n = \sum_{ i = 0 }
i^3\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
W_n &amp; = \sum_{ i = 0 }^{ n - 1 } i^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n i^3 - 3 \sum_{ i = 1 }^n i^2 + 3 \sum_{ i = 1
}^n i - n + n^3 \\
&amp; = W_n - 3 S_n + 3 \frac{ n + n^2 }{ 2 } - n + n^3 \\
S_n &amp; = \frac{ n + n^2 }{ 2 } - \frac{ n - n^3 }{ 3 } \\
&amp; = \frac{ n + 3 n^2 + 2 n^3 }{ 6 } \\
&amp; = \frac{ n ( 1 + 3 n + 2 n^2 ) }{ 6 } \\
&amp; = \frac{ n ( 2 n + 1 ) ( n + 1 ) }{ 6 }
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5>
<p>令<span class="math inline">\(H_n = \sum_{ k = 1 }^n \frac{ 1 }{ k
}\)</span>,求<span class="math inline">\(\sum_{ i = 0 }^n
H_i\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>不妨考虑<span class="math inline">\(\sum_{ i = 0 }^n iH_{ i
}\)</span>的值.</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 0 }^n iH_{ i } &amp; = \sum_{ i = 1 }^n [ ( i - 1 + 1 ) H_{ i
- 1 } + 1 ] \\
&amp; = n + \sum_{ i = 0 }^{ n - 1 } H_i + \sum_{ i = 0 }^{ n } iH_i -
nH_n \\
\sum_{ i = 0 }^{ n - 1 } H_i &amp; = n ( H_n - 1 ) \\
\sum_{ i = 0 }^n H_i &amp; = ( n + 1 ) ( H_{ n + 1 } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5>
<p>求<span class="math inline">\(S_n = \sum_{ i = 0 }^n ( - 1 )^{ n - i
} , T_n = \sum_{ i = 0 }^n ( - 1 )^{ n - i } i , U_n = \sum_{ i = 0 }^n
( - 1 )^{ n - i } i^2\)</span>.</p>
<h5><span id="solution-4">Solution 4</span></h5>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 1 }^{ n } ( - 1 )^{ n - i } + ( - 1 )^n \\
- S_{ n - 1 } + 1 &amp; = ( - 1 )^n + \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{
n - 1 - i } \\
- S_{ n - 1 } + 1 &amp; = ( - 1 )^n + S_{ n - 1 } \\
S_{ n - 1 } &amp; = \frac{ 1 - ( - 1 )^n }{ 2 } \\
S_n &amp; = \frac{ 1 + ( - 1 )^n }{ 2 }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
T_{ n } &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } i \\
- T_{ n - 1 } + n &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 ) +
\sum_{ i = 1 }^n ( - 1 )^{ n - i } \\
- T_{ n - 1 } + n &amp; = \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1 }
i + \sum_{ i = 0 }^n ( - 1 )^{ n - i } - ( - 1 )^n \\
- T_{ n - 1 } + n &amp; = T_{ n - 1 } + S_n - ( - 1 )^n \\
n - \frac{ 1 - ( - 1 )^n }{ 2 } &amp; = 2 T_{ n - 1 } \\
T_n &amp; = \frac{ 1 }{ 2 } ( n + 1 + \frac{ - 1 - ( - 1 )^n }{ 2 } ) =
\frac{ 1 }{ 2 } ( n + \frac{ 1 - ( - 1 )^n }{ 2 } )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
U_n &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } i^2 \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 +
1 )^2 \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1
)^2 + 2 \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 ) + \sum_{ i = 1 }^n
( - 1 )^{ n - i } \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1
} i^2 + 2 \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1 } i + \sum_{ i =
0 }^{ n - 1 } ( - 1 )^{ n - i - 1 } \\
- U_{ n - 1 } + n^2 &amp; = U_{ n - 1 } + 2 T_{ n - 1 } + S_{ n - 1 } \\
2 U_{ n - 1 } &amp; = n^2 - 2 T_{ n - 1 } - S_{ n - 1 } \\
2 U_{ n - 1 } &amp; = n^2 - ( n - \frac{ 1 - ( - 1 )^n }{ 2 } ) - \frac{
1 - ( - 1 )^n }{ 2 } \\
2 U_{ n - 1 } &amp; = n^2 - n \\
U_n &amp; = \frac{ n ( n + 1 ) }{ 2 }
\end{aligned}
\]</span></p>
<h4><span id="转化为递归式">转化为递归式</span></h4>
<p>考虑和式<span class="math inline">\(S_n = \sum_{ i = 0 }^n f ( i ) =
S_{ n - 1 } + f ( n ) \\\)</span>，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 0 }^n ( - 1 )^i i^2
\\\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>令<span class="math inline">\(S ( n ) = \sum_{ i = 0 }^n ( - 1 )^i
i^2 = S ( n - 1 ) + ( - 1 )^n n^2\)</span>,考虑使用成套方法.</p>
<p>不妨令<span class="math inline">\(S ( n ) = S ( n - 1 ) + ( - 1 )^n (
\alpha + \beta n + \gamma n^2 ) = \alpha A ( n ) + \beta B ( n ) +
\gamma C ( n )\)</span>.</p>
<p>令<span class="math inline">\(S ( n ) = ( - 1 )^n n , 可 以 解 得
\alpha = - 1 , \beta = 2 , \gamma = 0\)</span>,有<span class="math inline">\(( - 1 )^n n = - A ( n ) + 2 B ( n )\)</span>.</p>
<p>令<span class="math inline">\(S ( n ) = ( - 1 )^n n^2 , 可 以 解 得
\alpha = 1 , \beta = - 2 , \gamma = 2\)</span>,有<span class="math inline">\(( - 1 )^n n^2 = A ( n ) - 2 B ( n ) + 2 C ( n
)\)</span>.</p>
<p>显然可解得<span class="math inline">\(2 C ( n ) = ( - 1 )^n n^2 + ( -
1 )^n n , C ( n ) = ( - 1 )^n \frac{ n ( n + 1 ) }{ 2 }\)</span>.</p>
<p>而原式中,<span class="math inline">\(S ( n ) = C ( n ) = ( - 1 )^n
\frac{ n ( n + 1 ) }{ 2 }\)</span>.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5>
<p>有<span class="math inline">\(2 T_n = nT_{ n - 1 } + 3 n ! , T_0 =
5\)</span>,求<span class="math inline">\(T_n\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p>令<span class="math inline">\(s_n = \frac{ 2^{ n - 1 } }{ n !
}\)</span>,两边同时乘以<span class="math inline">\(s_n\)</span>,有<span class="math inline">\(\frac{ 2^n }{ n ! } T_n = \frac{ 2^{ n - 1 } }{ (
n - 1 ) ! } T_{ n - 1 } + 3 \times 2^{ n - 1 } \\\)</span>.</p>
<p>令<span class="math inline">\(S_n = \frac{ 2^n }{ n ! }
T_n\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = S_{ n - 1 } + 3 \times 2^{ n - 1 } \\
&amp; = 5 + 3 \sum_{ i = 0 }^{ n - 1 } 2^i \\
&amp; = 5 + 3 \times 2^{ n + 1 } - 3 \\
&amp; = 3 \times 2^{ n } + 2 \\
T_n &amp; = 3 n ! + \frac{ n ! }{ 2^{ n - 1 } }
\end{aligned}
\]</span></p>
<h4><span id="转化为积分形式">转化为积分形式</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数<span class="math inline">\(f ( x ) = x^2\)</span>,显然<span class="math inline">\(\int_0^n x^2 dx = \frac{ n^3 }{ 3 } \sim S_n
\\\)</span>.</p>
<p>接下来,我们考虑求得二者之间的误差,设<span class="math inline">\(E_n =
S_n - \frac{ n^3 }{ 3 } \\\)</span>,对其使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
E_n &amp; = S_n - \frac{ n^3 }{ 3 } \\
&amp; = S_{ n - 1 } + n^2 - \frac{ ( n - 1 + 1 )^3 }{ 3 } \\
&amp; = S_{ n - 1 } + n^2 - \frac{ ( n - 1 )^3 }{ 3 } - ( n - 1 )^2 - (
n - 1 ) - \frac{ 1 }{ 3 } \\
&amp; = E_{ n - 1 } + n^2 - n^2 + 2 n - 1 - n + 1 - \frac{ 1 }{ 3 } \\
&amp; = E_{ n - 1 } + n - \frac{ 1 }{ 3 }
\end{aligned}
\]</span></p>
<p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<p><span class="math display">\[
\begin{aligned}
E_n &amp; = S_n - \int_0^n x^2 dx \\
&amp; = \sum_{ k = 1 }^n ( k^2 - \int_{ k - 1 }^k x^2 dx ) \\
&amp; = \sum_{ k = 1 }^n ( k^2 - \frac{ k^3 - ( k - 1 )^3 }{ 3 } ) \\
&amp; = \sum_{ k = 1 }^n ( k - \frac{ 1 }{ 3 } )
\end{aligned}
\]</span></p>
<p>这是一个简单的和式.而<span class="math inline">\(S_n = E_n + \frac{
n^3 }{ 3 } \\\)</span>,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5>
<p>已知<span class="math inline">\(a_1 = 1 , a_{ n + 1 } - a_n = -
\frac{ 1 }{ 3 } a_n^2\)</span>,估计<span class="math inline">\(a_n\)</span>的值.</p>
<p>考虑构造一个函数<span class="math inline">\(f ( n )\)</span>使得<span class="math inline">\(f ( n ) \approx a_n\)</span>,那我们就可以将<span class="math inline">\(a_{ n + 1 } - a_n \approx f_n\)</span>.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,<span class="math inline">\(\exists x_0 \in [ n , n + 1 ] , f &#39; ( x_0 ) =
f ( n + 1 ) - f ( n )\)</span>,而对于增长率变化不大的函数,直接认为<span class="math inline">\(f &#39; ( x_0 ) = f &#39; ( n
)\)</span>是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入<span class="math inline">\(f (
1 ) = 1\)</span>解得<span class="math inline">\(f ( n ) = \frac{ 3 }{ n
+ 2 }\)</span>.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令<span class="math inline">\(a_n = \frac{ 3 }{ n + 2 } -
b_n\)</span>,带入化简,得到<span class="math inline">\(\{ b_n
\}\)</span>的递推式:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 3 }{ n + 3 } - b_{ n + 1 } &amp; = ( \frac{ 3 }{ n + 2 } - b_n )
( 1 - \frac{ 1 }{ n + 2 } + \frac{ b_n }{ 3 } ) \\
b_{ n + 1 } - \frac{ 3 }{ n + 3 } &amp; = ( b_n - \frac{ 3 }{ n + 2 } )
( \frac{ n + 1 }{ n + 2 } + \frac{ b_n }{ 3 } ) \\
b_1 &amp; = 0 , b_{ n + 1 } = \frac{ b_n^2 }{ 3 } + \frac{ n }{ n + 2 }
b_n + \frac{ 3 }{ ( n + 2 )^2 ( n + 3 ) }
\end{aligned}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出<span class="math inline">\(b_n \leq \frac{ 1 }{ 4 n
}\)</span>,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个<span class="math inline">\(b_n\)</span>的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设<span class="math inline">\(b_n^2 &lt; &lt; b_n\)</span>:</p>
<p>那么这个<span class="math inline">\(b_n\)</span>是<span class="math inline">\(O ( \frac{ \ln n }{ n^2 } )\)</span>级别的.</p>
<p>如何理解这个级别?考虑别乱动<span class="math inline">\(b_n\)</span>的系数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
b_{ n + 1 } &amp; = \frac{ n }{ n + 2 } b_n + \frac{ 1 }{ n ( n + 1 ) (
n + 2 ) } \\
( n + 1 ) ( n + 2 ) b_{ n + 1 } &amp; = n ( n + 1 ) b_n + \frac{ 1 }{ n
} \\
g ( n ) &amp; = n ( n + 1 ) b_n , g &#39; ( n ) = \frac{ 1 }{ n } , g (
n ) = \ln n \\
b_n &amp; = \frac{ \ln n }{ n^2 }
\end{aligned}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把<span class="math inline">\(O ( n^{
\epsilon } )\)</span>和<span class="math inline">\(O ( 1
)\)</span>搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现<span class="math inline">\(b_n \leq \frac{
3 \ln n }{ n ( n + 1 ) }\)</span>.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ k = 1 }^n k^2 \\
&amp; = \sum_{ k = 1 }^n \sum_{ i = 1 }^k k \\
&amp; = \sum_{ i = 1 }^n \sum_{ k = i }^n k \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( i + n ) ( n - i + 1 ) \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( in - i^2 + i + n^2 - ni + n )
\\
&amp; = \frac{ 1 }{ 2 } ( \sum_{ i = 1 }^n i - \sum_{ i = 1 }^n i^2 +
n^3 + n^2 ) \\
&amp; = \frac{ 1 }{ 4 } n ( n + 1 ) - \frac{ 1 }{ 2 } S_n + \frac{ n^3 +
n^2 }{ 2 }
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(S_n\)</span>.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i 2^i \\\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n i 2^i &amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i 2^i \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n 2^i \\
&amp; = \sum_{ j = 1 }^n ( 2^{ n + 1 } - 2^j ) \\
&amp; = n 2^{ n + 1 } - ( 2^{ n + 1 } - 2 ) \\
&amp; = ( n - 1 ) 2^{ n + 1 } + 2
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i^3 \\\)</span>.</p>
<h5><span id="solution-3">Solution 3</span></h5>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum_{ i = 1 }^n i^3 \\
&amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i i^2 \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n i^2 \\
&amp; = \sum_{ j = 1 }^n ( \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 6 } -
\frac{ ( j - 1 ) j ( 2 j - 1 ) }{ 6 } ) \\
&amp; = \frac{ n^2 ( n + 1 ) ( 2 n + 1 ) }{ 6 } - \frac{ 1 }{ 3 } S ( n
) + \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 12 } - \frac{ n ( n + 1 ) }{ 12 }
\\
S ( n ) &amp; = \frac{ n^2 ( n + 1 )^2 }{ 4 }
\end{aligned}
\]</span></p>
<h5><span id="exampleex">ExampleEX</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n iq^i ( q \ne 1
)\)</span>.</p>
<h5><span id="solutionex">SolutionEX</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n iq^i &amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n q^i \\
&amp; = \sum_{ j = 1 }^n \frac{ q^j - q^{ n + 1 } }{ 1 - q } \\
&amp; = \frac{ 1 }{ q - 1 } \sum_{ j = 1 }^n ( q^{ n + 1 } - q^j ) \\
&amp; = \frac{ 1 }{ q - 1 } ( nq^{ n + 1 } - \frac{ q^{ n + 1 } - q }{ q
- 1 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="exampleex2">ExampleEX2</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n ( ai + b ) q^{ i - 1 }
( q \ne 1 )\)</span>.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令<span class="math inline">\(A = \frac{ a }{ q - 1 } , B = \frac{ b
- A }{ q - 1 }\)</span>,答案为<span class="math inline">\(( An + B ) q^n
- B\)</span>.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子<span class="math inline">\(E\)</span>，使得<span class="math inline">\(Ef ( x ) = f ( x + 1 )\)</span>.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子<span class="math inline">\(\Delta f ( x ) = f ( x + 1 )
- f ( x )\)</span>，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有<span class="math inline">\(\Delta = E -
1\)</span>.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子<span class="math inline">\(\Sigma\)</span>,可以得到有限微积分的基本定理:</p>
$$
<span class="math display">\[\begin{aligned}
g ( x ) &amp; = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f
( x ) + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里的<span class="math inline">\(\Sigma\)</span>又被称为不定和式,是差分等于<span class="math inline">\(g\)</span>的一个函数类.</p>
<p>值得一提的是,这里的<span class="math inline">\(C\)</span>与无限微积分中的<span class="math inline">\(C\)</span>有一定区别,这里的<span class="math inline">\(C\)</span>可以是满足<span class="math inline">\(p
( x ) = p ( x + 1 )\)</span>的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果<span class="math inline">\(g ( x ) = \Delta f ( x
)\)</span>,那么有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = f ( x ) |^{ b }_a = f ( b ) - f ( a ) \\\)</span>.</p>
<p>值得一提的是,如果<span class="math inline">\(a \leq
b\)</span>,显然有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = \sum_{ x = a }^{ b - 1 } g ( x ) \\\)</span>.</p>
<p>但如果<span class="math inline">\(a &gt; b\)</span>,那么<span class="math inline">\(\sum \nolimits_{ a }^b g ( x ) \delta x = - \sum
\nolimits_b^a g ( x ) \delta x \\\)</span>.</p>
<p>事实上,我们一定有:<span class="math inline">\(\sum \nolimits_a^b g (
x ) \delta x + \sum \nolimits_b^c g ( x ) \delta x = \sum \nolimits_a^c
g ( x ) \delta x \\\)</span>.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的<span class="math inline">\(D ( x^m ) = mx^{ m - 1
}\)</span>，有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( x^{ \underline{ m } } ) &amp; = mx^{ \underline{ m - 1 } } \\
\sum mx^{ \underline{ m - 1 } } \delta x &amp; = x^{ \underline{ m } } +
C , m \ne 0 \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的<span class="math inline">\(D ( \ln x ) = \frac{ 1
}{ x }\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( H ( x ) ) &amp; = x^{ \underline{ - 1 } } = \frac{ 1 }{ x + 1 }
\\
\sum x^{ \underline{ - 1 } } \delta x &amp; = H ( x ) + C \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的<span class="math inline">\(D ( e^x ) =
e^x\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( 2^x ) &amp; = 2^x , \sum 2^x \delta x = 2^x + C \\
\Delta ( c^x ) &amp; = ( c - 1 ) c^x , \sum c^x \delta x = \frac{ c^x }{
c - 1 } + C , c \ne 1 \\
\Delta ( c^{ \underline{ x } } ) &amp; = \frac{ c^{ \underline{ x + 2 }
} }{ c - x } , \sum \frac{ c^{ \underline{ x + 2 } } }{ c - x } \delta x
= c^{ \underline{ x } } + C , c - x \ne 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据组合数公式,有:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta ( \binom{ x }{ k } ) &amp; = \binom{ x }{ k - 1 } \\
\sum \binom{ x }{ k - 1 } \delta x &amp; = \binom{ x }{ k } + C
\end{aligned}
\]</span></p>
<h6><span id="example平方和公式">Example(平方和公式)</span></h6>
<p>我们有:<span class="math inline">\(k^2 = k^{ \underline{ 2 } } + k^{
\underline{ 1 } } \\\)</span>.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S_{ n - 1 } &amp; = \sum_{ i = 0 }^{ n - 1 } i^2 \\
&amp; = \sum_{ i = 0 }^{ n - 1 } ( i^{ \underline{ 2 } } + i^{
\underline{ 1 } } ) \\
&amp; = \sum \nolimits_{ 0 }^n x^{ \underline{ 2 } } \delta x + \sum
\nolimits_{ 0 }^n x^{ \underline{ 1 } } \delta x \\
&amp; = \frac{ n^\underline{ 3 } }{ 3 } + \frac{ n^{ \underline{ 2 } }
}{ 2 }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5>
<p>考虑一阶差分是<span class="math inline">\(\Delta f ( x ) = f ( x + 1
) - f ( x )\)</span>,那么二阶差分就是<span class="math inline">\(\Delta^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f
( x )\)</span>.</p>
<p>类似地,我们可以通过归纳法证明<span class="math inline">\(\Delta^n f (
x ) = \sum_{ k } \binom{ n }{ k } ( - 1 )^{ n - k } f ( x + k )
\\\)</span>.</p>
<p>事实上有一种更简单的证明方法,由于<span class="math inline">\(\Delta =
E - 1\)</span>,于是<span class="math inline">\(\Delta^n = ( E - 1 )^n =
\sum_{ k } \binom{ n }{ k } ( - 1 )^{ n - k } E^k \\\)</span>,由于<span class="math inline">\(E^k f ( x ) = f ( x + k
)\)</span>,即可证明原式.</p>
<p>另外,不难发现如果<span class="math inline">\(f ( x
)\)</span>是一个关于<span class="math inline">\(x\)</span>的<span class="math inline">\(d\)</span>次多项式,那么<span class="math inline">\(\Delta f ( x )\)</span>是一个<span class="math inline">\(d - 1\)</span>次多项式.同理,<span class="math inline">\(\Delta^d f ( x )\)</span>会是一个常数而<span class="math inline">\(\Delta^{ d + 1 } f ( x )\)</span>会是<span class="math inline">\(0\)</span>,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6>
<p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为<span class="math inline">\(x_1 , x_2\)</span>.</p>
<p>不难写出期望转移式子:<span class="math inline">\(f_i = \cfrac{ 1 }{ 2
} ( f_{ i - 1 } + f_{ i + 1 } ) + 1\)</span>,并且<span class="math inline">\(f_{ x_1 } = f_{ x_2 } = 0\)</span>.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp; = \cfrac{ 1 }{ 2 } ( f_{ i - 1 } + f_{ i + 1 } ) + 1 \\
2 f_i &amp; = f_{ i - 1 } + f_{ i + 1 } + 2 \\
f_i - f_{ i - 1 } &amp; = f_{ i + 1 } - f_i + 2 \\
\Delta f_{ i - 1 } &amp; = \Delta f_{ i } + 2 \\
\Delta f_i - \Delta f_{ i - 1 } &amp; = - 2 \\
\Delta^2 f_{ i - 1 } &amp; = - 2
\end{aligned}
\]</span></p>
<p><span class="math inline">\(f\)</span>的二阶差分是常数,也就是说<span class="math inline">\(f\)</span>是二次多项式,不难求得其二次项系数为<span class="math inline">\(- 1\)</span>又知道两个零点,显然可以得到<span class="math inline">\(f\)</span>的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5>
<p>令<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } a_i
x^i
\\\)</span>.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } b_i x^{
\underline{ i } } \\\)</span>.</p>
<p>我们设<span class="math inline">\(c_i = i ! b_i\)</span>,于是有:<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } c_i \binom{ x
}{ i } \\\)</span>.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为<span class="math inline">\(f ( x )\)</span>的牛顿级数.</p>
<p>于是不难发现有:<span class="math inline">\(\Delta^n f ( x ) = \sum_{
0 \leq i \leq d } c_i \binom{ x }{ i - n } \\\)</span>.如果我们令<span class="math inline">\(x = 0\)</span>,则有:<span class="math inline">\(\Delta^n f ( 0 ) = \begin{cases}c_n &amp; n \leq d
\\ 0 &amp; n &gt; d\end{cases}\)</span>.那么牛顿级数的另一种表示即:<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } \Delta^i f ( 0
) \binom{ x }{ d } \\\)</span>.</p>
<p>另外,如果我们展开一下<span class="math inline">\(c_n = \Delta^n f ( 0
)\)</span>,我们可以得到公式:</p>
<p><span class="math inline">\(\sum_{ k } \binom{ n }{ k } ( - 1 )^k (
\sum_{ 0 \leq i \leq n } c_i \binom{ k }{ i } ) = ( - 1 )^n c_n , n \in
\mathbb{ N } \\\)</span>.</p>
<p>如果我们将多项式还原,由于<span class="math inline">\(a_n =
b_n\)</span>,有:</p>
<p><span class="math inline">\(\sum_{ k } \binom{ n }{ k } ( - 1 )^k (
\sum_{ 0 \leq i \leq n } a_i k^i ) = ( - 1 )^n n ! a_n , n \in \mathbb{
N } \\\)</span>.</p>
<p>另外,如果<span class="math inline">\(x \in \mathbb{ N
}\)</span>,那么我们有:<span class="math inline">\(f ( x ) = \sum_{ 0
\leq k } \Delta^k f ( 0 ) \binom{ x }{ 0
}\)</span>,根据多项式推理法,这个公式对<span class="math inline">\(\forall x \in \mathbb{ Z }\)</span>都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<p><span class="math display">\[
g ( a + x ) = \sum_{ 0 \leq k } \cfrac{ \Delta^k g ( a ) }{ k ! } x^{
\underline{ k } }
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>求<span class="math inline">\(\sum_{ k } \binom{ n }{ k } \binom{ r -
sk }{ n } ( - 1 )^k , n \in \mathbb{ N } \\\)</span>.</p>
<p>如果我们令<span class="math inline">\(f ( k ) = \binom{ r - sk }{ n }
= \sum_{ 0 \leq i \leq n } a_i k^i \\\)</span>,不难发现<span class="math inline">\(a_n = \cfrac{ ( - 1 )^n s^n }{ n !
}\)</span>,于是显然原式<span class="math inline">\(= s^n\)</span>.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v = Ev \Delta u + u \Delta
v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p><span class="math inline">\(\sum u \Delta v = uv - \sum Ev \Delta u
\\\)</span>.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = l }^{ r - 1 } ( a_{ i + 1 } - a_i ) b_i &amp; = a_r b_r - a_l
b_l - \sum_{ i = l }^{ r - 1 } a_{ i + 1 } ( b_{ i + 1 } - b_i ) \\
\sum_{ i = l }^{ r - 1 } ( \Delta a_i ) b_i &amp; = a_r b_r - a_l b_l -
\sum_{ i = l }^{ r - 1 } a_{ i + 1 } ( \Delta b_i )
\end{aligned}
\]</span></p>
<p>对于<span class="math inline">\(l = 0 , r = n , a_0 = b_0 =
0\)</span>的特殊情况,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } ( \Delta a_i ) b_i &amp; = a_n b_n - \sum_{ i =
0 }^{ n - 1 } a_{ i + 1 } ( \Delta b_i ) \\
\sum_{ i = 1 }^n a_i ( b_{ i + 1 } - b_i ) &amp; = a_n b_n - \sum_{ i =
0 }^{ n - 1 } ( \Delta a_i ) b_i
\end{aligned}
\]</span></p>
<p>取两组数列<span class="math inline">\(\alpha ,
\beta\)</span>,并令<span class="math inline">\(\sum_{ i = 1 }^n \beta_i
= B_i\)</span>,立刻有:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n \alpha_i \beta_i = \alpha_n B_n - \sum_{ i = 1 }^{ n -
1 } ( \alpha_{ i + 1 } - \alpha_i ) B_i
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k 2^k \\\)</span>.</p>
<p>根据分部求和法则，我们有:</p>
<p><span class="math inline">\(\sum x 2^x \delta x = x 2^x - \sum 2^{ x
+ 1 } \delta x = x 2^x - 2^{ x + 1 } + C \\\)</span>.</p>
<p>改为定和式形式，显然有:</p>
<p><span class="math inline">\(\sum_{ k = 0 }^n k 2^k = \sum
\nolimits_0^{ n + 1 } x 2^x \delta x = ( n + 1 ) 2^{ n + 1 } - 2^{ n + 2
} + 2 = ( n - 1 ) 2^{ n + 1 } + 2 \\\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^{ n - 1 } kH_k
\\\)</span>.</p>
<p>令<span class="math inline">\(u ( x ) = H_x , v ( x ) = \frac{ 1 }{ 2
} x^{ \underline{ 2 } } \\\)</span>.</p>
<p>带入分部求和法则，显然有:</p>
<p><span class="math inline">\(\sum xH_x \delta x = \frac{ x^\underline{
2 } }{ 2 } H_x - \frac{ x^\underline{ 2 } }{ 4 } + C \\\)</span>.</p>
<p>带入即可求出原式<span class="math inline">\(= \frac{ n^\underline{ 2
} }{ 2 } ( H_n - \frac{ 1 }{ 2 } ) \\\)</span>.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i (
i + 1 ) } \\\)</span>.</p>
<h6><span id="solution-3">Solution 3</span></h6>
<p>令<span class="math inline">\(u = ( 2 n + 1 ) , v = - \frac{ 1 }{ i
}\)</span>,则<span class="math inline">\(\Delta u = 2 , \Delta v =
\frac{ 1 }{ i ( i + 1 ) }\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i ( i + 1 ) } &amp; = ( 2 n + 3 )
\times ( - \frac{ 1 }{ n + 1 } ) + 3 - \sum_{ i = 1 }^n ( - \frac{ 2 }{
i + 1 } ) \\
&amp; = - \frac{ 2 n + 3 }{ n + 1 } + 2 H_n + \frac{ n + 3 }{ n + 1 } =
2 H_n - \frac{ n }{ n + 1 }
\end{aligned}
\]</span></p>
<h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{
( k + 1 ) ( k + 2 ) } \\\)</span>.</p>
<h6><span id="solution-4">Solution 4</span></h6>
<p>令<span class="math inline">\(u = H_n , v = - \frac{ 1 }{ n + 1 } ,
\Delta u = \frac{ 1 }{ n + 1 } , \Delta v = \frac{ 1 }{ ( n + 1 ) ( n +
2 ) } \\\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{ ( k + 1 ) ( k + 2 ) } &amp; = -
\frac{ H_n }{ n + 1 } - \sum_{ i = 0 }^{ n - 1 } ( - \frac{ 1 }{ ( i + 2
) ( i + 1 ) } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + \sum_{ i = 0 }^{ n - 1 } ( \frac{ 1 }{
i + 1 } - \frac{ 1 }{ i + 2 } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + H_n - ( H_n - 1 + \frac{ 1 }{ n + 1 }
) \\
&amp; = 1 - \frac{ H_n + 1 }{ n + 1 }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">贪心与构造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="贪心">贪心</span></h2>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了<span class="math inline">\(t\)</span>个消息<span class="math inline">\(a_1 ,
a_2 , . . . , a_t\)</span>,那么答案就是<span class="math inline">\(\sum
[ \exists j , m_i = a_j ] \cfrac{ \min ( t , k_i ) }{ t
}\)</span>.显然如果<span class="math inline">\(t\)</span>固定,那么每个<span class="math inline">\(a_j\)</span>的贡献是独立的.于是只需要枚举<span class="math inline">\(t\)</span>然后取贡献最大的.</p>
<p>但是,如果<span class="math inline">\(t &gt; \max \{ k_i
\}\)</span>,这个时候<span class="math inline">\(t -
1\)</span>的答案是<span class="math inline">\(t -
1\)</span>个数之和除以<span class="math inline">\(t - 1\)</span>,<span class="math inline">\(t\)</span>的答案是这<span class="math inline">\(t
- 1\)</span>个数之和加上另一个更小的数除以<span class="math inline">\(t\)</span>,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度<span class="math inline">\(O ( n \max \{ k_i \}
)\)</span>.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分(<span class="math inline">\(b_{ i , j } = a_{ i
, j } \oplus a_{ i + 1 , j } \oplus a_{ i , j + 1 } \oplus a_{ i + 1 , j
+ 1
}\)</span>)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是<span class="math inline">\(0\)</span>了,那么矩阵外不可能是<span class="math inline">\(1\)</span>,也就是原矩阵也全都是<span class="math inline">\(0\)</span>了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成<span class="math inline">\(0\)</span>才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对<span class="math inline">\(( x , y
)\)</span>使用操作四,那我们不可能再对一个<span class="math inline">\(( x
, i )\)</span>使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有<span class="math inline">\(b_{ x , y } ,
b_{ n , y } , b_{ x , m }\)</span>都是<span class="math inline">\(1\)</span>的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个<span class="math inline">\(1\)</span>,所以一定不如直接用一操作来的划算.不然,如果三个都是<span class="math inline">\(1\)</span>,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后<span class="math inline">\(b_{ n , m }\)</span>变成<span class="math inline">\(1\)</span>了,再不行也可以使用一次<span class="math inline">\(1\)</span>操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果<span class="math inline">\(b_{ x , y } , b_{ n , y } , b_{ x , m
}\)</span>都是<span class="math inline">\(1\)</span>,我们就把<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 } &amp; = \max \{ a_{ i + 1 } , f_i + mn \} \\
g_{ i + 1 } &amp; = \min \{ a_{ i + 2 } , g_i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([ f_i , g_i
]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{ i
}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ ans_{ i + 1 } - mx , ans_{ i + 1 } - mn
]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([ f_i , g_i
]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{ i + 1 } - mn &lt; f_i , f_{ i + 1 } &lt;
ans_{ i + 1 } &lt; f_i +
mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx - mn\)</span>.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对<span class="math inline">\(( l ,
r )\)</span>,我们想给每一个点对赋值:<span class="math inline">\(a_l = i
, a_r = n - i + 1\)</span>(注意如果<span class="math inline">\(n\)</span>是奇数,那么中心点应该是<span class="math inline">\(a_{ mid } = \frac{ n + 1 }{ 2
}\)</span>),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对<span class="math inline">\(( l_1 , r_1
)\)</span>,<span class="math inline">\(( l_2 , r_2
)\)</span>之间的三种可能的关系:不交,包含,相交且不包含.会发现若<span class="math inline">\(l\)</span>小则让<span class="math inline">\(a_l\)</span>尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个<span class="math inline">\(\pm
1\)</span>操作很奇怪.我们不妨这么考虑:设最后的答案序列为<span class="math inline">\(b\)</span>,那么答案其实就是<span class="math inline">\(\sum | b_i - a_i
|\)</span>.这实际上是什么呢?实际上是数轴上<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>之间的距离.既然这样,那么我们同时反转<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个<span class="math inline">\(a\)</span>,将它和<span class="math inline">\(x\)</span>同时反转,那么答案不变.这么做后我们可以直接清空所有<span class="math inline">\(a\)</span>的最高位,只剩下<span class="math inline">\(x\)</span>可能有最高位.</p>
<p>那<span class="math inline">\(x\)</span>的最高位一定会让若干<span class="math inline">\(a\)</span>往上变成它.注意到最多只会有一个<span class="math inline">\(a\)</span>会向上满足<span class="math inline">\(x\)</span>的最高位.证明的话同样考虑取反,如果有两个<span class="math inline">\(a\)</span>满足<span class="math inline">\(a_i
\oplus b_i\)</span>和<span class="math inline">\(a_j \oplus
b_j\)</span>这一位是<span class="math inline">\(1\)</span>,我们仍然考虑数轴,有<span class="math inline">\(| not ( b_i ) - a_i | \leq | a_i - b_i
|\)</span>,这由<span class="math inline">\(a_i \oplus
b_i\)</span>最高位是<span class="math inline">\(1\)</span>导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个<span class="math inline">\(a\)</span>上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的<span class="math inline">\(a\)</span>可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作<span class="math inline">\([ l , r , k
]\)</span>表示可以将<span class="math inline">\(a [ l \cdots r
]\)</span>减一进行至多<span class="math inline">\(k\)</span>次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个<span class="math inline">\(- 1\)</span>,另一个<span class="math inline">\(-
2\)</span>,求使得整个序列都小于等于<span class="math inline">\(0\)</span>的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p></li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p></li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p></li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.我们通过样例以及其它栗子发现:有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀,这启发我们:能不能在做后面位置的时候将前面的<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个<span class="math inline">\(( - 2 , - 1
)\)</span>操作,那么我可以在这个位置进行一个<span class="math inline">\((
0 , - 3 )\)</span>操作.显然<span class="math inline">\(( 0 , - 3 ) + ( -
2 , - 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>.我们完成了反悔的操作!</p>
<p>但是,我们直接认为<span class="math inline">\(( - 1 , - 2
)\)</span>不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑<span class="math inline">\(( - 3 , 0
)\)</span>怎么反悔.这个看上去很疑惑:我们为了使<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在<span class="math inline">\(( - 2 , - 1
)\)</span>的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:<span class="math inline">\(( - 3 , 0
)\)</span>这个技能的发动是有前提条件的:前面必须有<span class="math inline">\(( - 2 , - 1
)\)</span>才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个<span class="math inline">\(( - 2 , - 1
)\)</span>,也很清楚每个地方用了几个<span class="math inline">\(( - 3 , 0
)\)</span>.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 2 , -
1 ) = ( - 3 , 0 ) + ( 0 , - 3 )\)</span>,或者<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 1 , -
2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3
)\)</span>.</p>
<p>最后遇到一个点,能用<span class="math inline">\(( 0 , - 3
)\)</span>就用<span class="math inline">\(( 0 , - 3
)\)</span>,不够用的再补齐.这个原因也很简单:如果我们在这里不用<span class="math inline">\(( - 3 , 0
)\)</span>而用其它的代替的话,你会发现无论如何都等价于<span class="math inline">\(( - 3 , 0 )\)</span>然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的<span class="math inline">\(( - 2 , - 1 )\)</span>和<span class="math inline">\(( - 1 , - 2
)\)</span>的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的<span class="math inline">\(( - 3 , 0
)\)</span>操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,保证<span class="math inline">\(a_1 =
a_n = 1\)</span>.每次你可以选择一个<span class="math inline">\(i ( 1
&lt; i &lt; n )\)</span>将<span class="math inline">\(a_i\)</span>删去并付出<span class="math inline">\(a_{ i - 1 } a_i a_{ i + 1
}\)</span>的代价.删去<span class="math inline">\(a_i\)</span>后序列两端会接起来,求删成两个<span class="math inline">\(1\)</span>的最小代价.</p>
<p>首先注意到,如果有一个<span class="math inline">\(1 &lt; i &lt;
n\)</span>满足<span class="math inline">\(a_i =
1\)</span>,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要<span class="math inline">\(1\)</span>的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个<span class="math inline">\(1\)</span>所划分.接下来我们只考虑中间所有数<span class="math inline">\(\geq 2\)</span>的情况.</p>
<p>再思考一个事实:当<span class="math inline">\(a , b \geq
2\)</span>时,一定有<span class="math inline">\(ab \geq a +
b\)</span>.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是<span class="math inline">\(\sum_{ i = 2 }^{ n - 2 } a_i a_{ i + 1 } + \min_{
i = 2 }^{ n - 1 }{ a_i
}\)</span>.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造<span class="math inline">\(a\)</span>数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值<span class="math inline">\(a_i\)</span>,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑<span class="math inline">\(a_i\)</span>互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数<span class="math inline">\(\leq\)</span>还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在<span class="math inline">\(a_i\)</span>相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的<span class="math inline">\(( a_i , a_{ i + 1 } )\)</span>,然后这么选:<span class="math inline">\(a_i , a_{ i + 1 } , a_n , a_{ i - 1 } , a_{ n - 1
} , a_{ i - 2 } . .
.\)</span>,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在<span class="math inline">\(a_i\)</span>上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,其中<span class="math inline">\(2 a
&lt;
b\)</span>.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果<span class="math inline">\(b\)</span>之前吃过别的鱼,假设是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>(不妨假设<span class="math inline">\(d
\geq c\)</span>),有<span class="math inline">\(b = c +
d\)</span>,由鸽笼原理,发现<span class="math inline">\(d &gt;
a\)</span>.这意味着:如果<span class="math inline">\(a\)</span>都没被操作掉,那么<span class="math inline">\(d\)</span>必不可能被操作掉,这也就是说<span class="math inline">\(b\)</span>不可能出现.因此<span class="math inline">\(b\)</span>在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于<span class="math inline">\(b\)</span>,且<span class="math inline">\(a\)</span>就是所有一开始小于<span class="math inline">\(b\)</span>的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是<span class="math inline">\(w_i &gt; 2 \sum_{ j = 1 }^{ i - 1 }
w_j\)</span>,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多<span class="math inline">\(\log
w\)</span>个,我们考虑一下这个两倍的用处,我们按照值域<span class="math inline">\([ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , .
. . , [ 2^{ k - 1 } + 1 , 2^k
]\)</span>将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span>表示标准球.</p></li>
<li><p><span class="math inline">\(&lt; A , B
&gt;\)</span>表示称量集合<span class="math inline">\(A\)</span>和集合<span class="math inline">\(B\)</span>,<span class="math inline">\(&lt; A , B
&gt; = 0\)</span>表示平衡,<span class="math inline">\(&lt; A , B &gt; =
A\)</span>表示<span class="math inline">\(A\)</span>较重,<span class="math inline">\(&lt; A , B &gt; = B\)</span>表示<span class="math inline">\(B\)</span>较重.</p></li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量<span class="math inline">\(x\)</span>有<span class="math inline">\(n\)</span>种取值,出现概率分别为<span class="math inline">\(p_1 , p_2 , \cdots , p_n\)</span>,则其熵为<span class="math inline">\(H ( x ) = f ( p_1 , p_2 , \cdots , p_n ) = \sum{ C
p_i \ln \frac{ 1 }{ p_i } }\)</span>,<span class="math inline">\(C\)</span>为正整数,通常取<span class="math inline">\(1\)</span>.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量<span class="math inline">\(x\)</span>的一个熵为<span class="math inline">\(h\)</span>的信息后,<span class="math inline">\(x\)</span>的熵会减少<span class="math inline">\(h\)</span>.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有<span class="math inline">\(n\)</span>个球,每个球等概率成为次品,因此总熵是<span class="math inline">\(\ln
n\)</span>,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是<span class="math inline">\(\ln 3\)</span>,也就是说我们至少要猜<span class="math inline">\(\frac{ \ln n }{ \ln 3 } = \log_3
n\)</span>次.如果我们不知道次品的轻重,那么至少要猜<span class="math inline">\(\frac{ \ln 2 n }{ \ln 3 } = \log_3 2
n\)</span>次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p><span class="math inline">\(n\)</span>个叶子的树的最小深度是<span class="math inline">\(\lceil \log_3 n
\rceil\)</span>,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设<span class="math inline">\(f ( n )\)</span>表示有<span class="math inline">\(n\)</span>个球的最少次数,注意到<span class="math inline">\(f ( 3 ) = 1\)</span>.</p>
<p>根据信息论,<span class="math inline">\(f ( n ) \geq \lceil \log_3 n
\rceil\)</span>,下面证明等号成立:</p>
<p>首先考虑证明<span class="math inline">\(f ( 3^m ) = m\)</span>,<span class="math inline">\(m = 1\)</span>时已经得证.<span class="math inline">\(m &gt;
1\)</span>时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此<span class="math inline">\(f ( 3^m ) \leq f ( 3^{ m - 1 } ) +
1\)</span>.综合信息论下界<span class="math inline">\(f ( 3^m ) \geq
m\)</span>,我们不难得出以上结论.至于<span class="math inline">\(n \ne
3^m\)</span>的情况,我们类似这个过程按照<span class="math inline">\(n
\bmod 3\)</span>的值讨论一下即可,于是有<span class="math inline">\(f ( n
) \leq f ( \lceil \frac{ n }{ 3 } \rceil ) + 1\)</span>.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,<span class="math inline">\(f ( n ) \geq \lceil \log_3
2 n \rceil\)</span>.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有<span class="math inline">\(n\)</span>个球,第二堆有<span class="math inline">\(m\)</span>个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是<span class="math inline">\(g ( n , m )\)</span>,则<span class="math inline">\(g ( n , m ) = \lceil \log_3 ( n + m )
\rceil\)</span>.</p>
<p>先证明信息论下界,不难发现仍然是<span class="math inline">\(g ( n , m
) = \lceil \log_3 ( n + m ) \rceil\)</span>.</p>
<p>首先不难发现,<span class="math inline">\(g ( 1 , 0 ) = g ( 0 , 1 ) =
0 , g ( 1 , 1 ) = g ( 2 , 0 ) = g ( 0 , 2 ) = 1\)</span>.</p>
<p>仍然使用数学归纳,假设<span class="math inline">\(n + m &lt; k ( k
\geq 3 )\)</span>的时候成立,我们接下来证明<span class="math inline">\(n
+ m = k\)</span>的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若<span class="math inline">\(n = 3 p , m = 3 q\)</span>,我们将<span class="math inline">\(n\)</span>分成等数量的三堆:<span class="math inline">\(A_1 , B_1 , C_1\)</span>,将<span class="math inline">\(m\)</span>分成等质量的三堆<span class="math inline">\(A_2 , B_2 , C_2\)</span>.</p>
<p>接下来称量<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>.</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = 0\)</span>,那么答案在<span class="math inline">\(C_1 \cup
C_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g (
\frac{ n }{ 3 } , \frac{ m }{ 3 } ) + 1\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = A_1 + A_2\)</span>,由于若次品在<span class="math inline">\(A_2\)</span>中,那么它不可能是重球,因此次品不可能在<span class="math inline">\(A_2\)</span>中,同理不可能在<span class="math inline">\(B_1\)</span>中,只可能在<span class="math inline">\(A_1 \cup B_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g ( \frac{ n }{ 3 } , \frac{ m }{ 3
} ) + 1\)</span>.</p></li>
<li><p><span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2 \rangle
= B_1 + B_2\)</span>,同理.</p></li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p><span class="math inline">\(n = 3 p + 1 , m = 3 q +
2\)</span>.此时我们将第一堆分成<span class="math inline">\(A_1 ( p ) ,
B_1 ( p ) , C_1 ( p + 1 )\)</span>,将第二堆分成<span class="math inline">\(A_2 ( q + 1 ) , B_2 ( q + 1 ) , C_2 ( q
)\)</span>,然后<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>,接下来和情况1一样,于是有<span class="math inline">\(g (
n , m ) = \max \{ g ( p , q + 1 ) , g ( p + 1 , q ) \} = \lceil \log_3
\frac{ n + m }{ 3 } \rceil + 1\)</span>.</p>
<p>同理,当<span class="math inline">\(n , m \bmod
3\)</span>的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论<span class="math inline">\(n
\bmod 3\)</span>的值.</p>
<p><strong>情况1</strong></p>
<p>当<span class="math inline">\(n = 3 p\)</span>时,直接分成<span class="math inline">\(A ( p ) , B ( p ) , C ( p )\)</span>,然后<span class="math inline">\(\langle A , B
\rangle\)</span>.如果平衡则接下来需要<span class="math inline">\(f ( p )
= \lceil \log_3 2 p \rceil\)</span>次,不然根据引理,需要<span class="math inline">\(\lceil \log_3 ( p + p )
\rceil\)</span>次,因此<span class="math inline">\(f ( n ) = \lceil
\log_3 2 p \rceil + 1 = \lceil \log_3 6 p \rceil = \lceil \log_3 2 n
\rceil\)</span>.</p>
<p><strong>情况2</strong></p>
<p>当<span class="math inline">\(n = 3 p +
1\)</span>时,一种自然的想法是分成<span class="math inline">\(A ( p + 1 )
, B ( p ) , C ( p
)\)</span>,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了<span class="math inline">\(2 p + 2 , 2 p , 2
p\)</span>,这显然是不优秀的.正确的做法是分成<span class="math inline">\(A = \{ S , 1 , \cdots p \} , B = \{ p + 1 , \cdots
2 p + 1 \} , C = \{ 2 p + 2 , \cdots 3 p + 1
\}\)</span>.由于存在标准球,此时如果<span class="math inline">\(\langle A
, B \rangle = A \ or \ B\)</span>,那么转化成<span class="math inline">\(g ( p , p + 1 ) = \lceil \log_3 ( 2 p + 1 )
\rceil\)</span>,不然转化成<span class="math inline">\(f ( p ) = \lceil
\log_3 2 p \rceil\)</span>.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有<span class="math inline">\(n \bmod 3 =
1\)</span>的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题<span class="math inline">\(f ( n ) = \lceil \log_3 ( 2 n + 2 )
\rceil\)</span>.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将<span class="math inline">\(a\)</span>个球放左边,<span class="math inline">\(b\)</span>个球放右边,<span class="math inline">\(a
\leq b\)</span>,在左边补上<span class="math inline">\(b -
a\)</span>个标准球.</p>
<ol type="1">
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要<span class="math inline">\(\lceil \log_3 ( a + b ) \rceil +
1\)</span>步.</p></li>
<li><p>如果天平平衡,需要<span class="math inline">\(f ( n - a - b ) +
1\)</span>步.</p></li>
</ol>
<p>我们有<span class="math inline">\(f ( n ) = \min_{ a , b } \{ \max \{
f ( n - a - b ) , \lceil \log_3 ( a + b ) \rceil \} \} + 1\)</span>.</p>
<p>注意到接下来的步数只与<span class="math inline">\(a +
b\)</span>有关,取<span class="math inline">\(b - a \leq
1\)</span>,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到<span class="math inline">\(f ( n ) = \lceil
\log_3 ( 2 n - 1 ) \rceil\)</span>.</p>
<p>接下来归纳法就简单了,只需要对于<span class="math inline">\(n \bmod
3\)</span>的余数讨论一下,然后再讨论一下<span class="math inline">\(a\)</span>的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求<span class="math inline">\(n\)</span>所在位置.要求询问次数<span class="math inline">\(\leq \lceil 1 . 5 \log_2 n
\rceil\)</span>,询问区间总长度<span class="math inline">\(\leq 3
n\)</span>.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设<span class="math inline">\(T ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程<span class="math inline">\(T ( n ) = \min_{ m &lt;
n } \{ \max \{ T ( m ) + 1 , T ( n - m ) + 2 \} \}\)</span>.</p>
<p>当然有<span class="math inline">\(m_n \leq m_{ n + 1
}\)</span>,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3>
<h4><span id="模型1">模型1</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,定义域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,表达式<span class="math inline">\(F (
\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_n } \} )\)</span>最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个二元正整数对<span class="math inline">\(( a_i , b_i
)\)</span>,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的<span class="math inline">\(a\)</span>乘上序列中这个二元组之后的所有二元组的<span class="math inline">\(b\)</span>之和的总和,求最小代价.<span class="math inline">\(n , a_i , b_i \leq 10^6\)</span>.</p>
<p>转化为上面的形式,也即:<span class="math inline">\(F ( \{ ( a_1 , b_1
) , . . . , ( a_n , b_n ) \} ) = \sum_{ 1 \leq i &lt; j \leq k } a_i
b_j\)</span>.</p>
<p>考虑调整法,令排列<span class="math inline">\(( q_1 , . . . , q_n ) =
( p_1 , . . . , p_{ i - 1 } , p_{ i + 1 } , p_i , p_{ i + 2 } , . . . ,
p_n )\)</span>.则:</p>
<p><span class="math display">\[
F ( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \}
) - F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n } )
\} ) = a_{ p_i } b_{ p_{ i + 1 } } - a_{ p_{ i + 1 } } b_{ p_i }
\]</span></p>
<p>因而如果<span class="math inline">\(a_{ p_i } b_{ p_{ i + 1 } } - a_{
p_{ i + 1 } } b_{ p_i } &gt; 0\)</span>,则<span class="math inline">\(F
( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \} )
&gt; F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n }
) \} )\)</span>,也就是说<span class="math inline">\(( p_1 , . . . , p_n
)\)</span>不是最优解.因此只有满足<span class="math inline">\(\forall 1
\leq i &lt; n\)</span>,<span class="math inline">\(\cfrac{ a_{ p_i } }{
b_{ p_i } } \leq \cfrac{ a_{ p_{ i + 1 } } }{ b_{ p_{ i + 1 } }
}\)</span>可能是最优解.</p>
<p>如果一个<span class="math inline">\(p\)</span>满足这样的性质,则所有<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的两个位置,是不会使答案改变的.因此直接按照<span class="math inline">\(\cfrac{ a }{ b }\)</span>排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为<span class="math inline">\(S\)</span>,定义<span class="math inline">\(S\)</span>上的一种二元比较关系<span class="math inline">\(\leq\)</span>,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li><p>强完全性:<span class="math inline">\(\forall a , b \in
S\)</span>,<span class="math inline">\(a \leq b \lor b \leq a =
1\)</span>.</p></li>
<li><p>传递性:<span class="math inline">\(\forall a , b , c \in
S\)</span>,<span class="math inline">\(a \leq b , b \leq c \Rightarrow a
\leq c\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in
S\)</span>,如果<span class="math inline">\(a \leq
b\)</span>,则对于任意一个包含<span class="math inline">\(\{ a , b
\}\)</span>作为子段的元素序列<span class="math inline">\(\{ s_1 , . . .
, s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \}\)</span>和<span class="math inline">\(\{ s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 }
, . . . , s_n \}\)</span>都有:<span class="math inline">\(F ( \{ s_1 , .
. . , s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \} ) \leq F ( \{
s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 } , . . . , s_n \}
)\)</span>.</p></li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义<span class="math inline">\(\leq\)</span>后自然也就定义了<span class="math inline">\(=\)</span>,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到<span class="math inline">\(\leq\)</span>的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个包含小写字符的字符串<span class="math inline">\(s_1 , . . . , s_n\)</span>,找到一个<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,将<span class="math inline">\(s_{ p_1 }
, s_{ p_2 } , . . . , s_{ p_n }\)</span>顺序拼接得到<span class="math inline">\(S\)</span>,使<span class="math inline">\(S\)</span>的字典序最小.</p>
<p>令<span class="math inline">\(s \leq t\)</span>当且仅当<span class="math inline">\(s + t\)</span>的字典序<span class="math inline">\(\leq\)</span>t+s</p>
<p>此时我们注意到:<span class="math inline">\(s +
t\)</span>的字典序小于等于<span class="math inline">\(t +
s\)</span>的字典序当且仅当<span class="math inline">\(s^{ \infty } \leq
t^{ \infty }\)</span>.原因是:不妨设<span class="math inline">\(s\)</span>的长度<span class="math inline">\(\leq
t\)</span>的长度.若<span class="math inline">\(s\)</span>不是<span class="math inline">\(t\)</span>的前缀,那显然只需比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(s\)</span>的字典序即可,此时上面两个条件等价;若<span class="math inline">\(s\)</span>是<span class="math inline">\(t\)</span>的前缀,则我们需要比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(t\)</span>的后缀,注意到<span class="math inline">\(t\)</span>的前缀还是<span class="math inline">\(s\)</span>,于是需要比较<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有<span class="math inline">\(n\)</span>个箱子,第<span class="math inline">\(i\)</span>个箱子有重量<span class="math inline">\(w_i\)</span>和承载量<span class="math inline">\(v_i\)</span>,<span class="math inline">\(( w_i ,
v_i &gt; 0
)\)</span>,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化<span class="math inline">\(\min_{ i = 1 }^n \{ v_i -
\sum_{ j = 1 }^{ i - 1 } w_j \}\)</span>,并判断是否<span class="math inline">\(\geq 0\)</span>.</p>
<p>我们令<span class="math inline">\(b_i = - ( v_i + w_i ) , a_i = -
v_i\)</span>,则我们要最大化<span class="math inline">\(\min \{ \sum_{ j
= 1 }^{ i - 1 } b_i - \sum_{ j = 1 }^i a_i \}\)</span>.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义<span class="math inline">\(x \leq y\)</span>当且仅当<span class="math inline">\(F ( \{ x , y \} ) \leq F ( \{ y , x \}
)\)</span>,那么对于两个元素<span class="math inline">\(( a_1 , b_1 ) , (
a_2 , b_2 )\)</span>,显然<span class="math inline">\(( a_1 , b_1 ) \leq
( a_2 , b_2 )\)</span>当且仅当<span class="math inline">\(\min \{ - a_1
, b_1 - a_1 - a_2 \} \geq \min \{ - a_2 , b_2 - a_1 - a_2
\}\)</span>.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li><p>都大于等于第一个元素,则相当于<span class="math inline">\(a_1 \leq
a_2 \land b_1 - a_1 \geq 0\)</span>.</p></li>
<li><p>都大于等于第二个元素,则相当于<span class="math inline">\(b_1 \geq
b_2 \land b_2 - a_2 \leq 0\)</span>.</p></li>
</ol>
<p>可能这里后面和<span class="math inline">\(0\)</span>比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对<span class="math inline">\(b -
a\)</span>的符号进行讨论:</p>
<ol type="1">
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) &gt; sgn ( b_2 -
a_2 )\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 1\)</span>,则不等式成立当且仅当<span class="math inline">\(a_1 \leq
a_2\)</span>.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 0\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = - 1\)</span>,则不等式成立当且仅当<span class="math inline">\(b_1
\geq b_2\)</span>.</p></li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时<span class="math inline">\(b_1 = a_1\)</span>,<span class="math inline">\(b_2
= a_2\)</span>,两条件必有一真.(1)则是因为此时满足<span class="math inline">\(b_1 - a_1 &gt; b_2 - a_2 \land sgn ( b_1 - a_1 )
\geq 0 \land sgn ( b_2 - a_2 ) \leq 0\)</span>.也就有<span class="math inline">\(a_2 - a_1 &gt; b_2 - b_1 \land b_1 \geq a_1 \land
b_2 \leq a_2\)</span>.怎么着都能成立.</p>
<p>由此发现,对于<span class="math inline">\(sgn ( b - a
)\)</span>相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<p><span class="math display">\[
\begin{aligned}
( a_1 , b_1 ) &amp; \leq ( a_2 , b_2 ) \\
\Updownarrow \\
( sgn ( b_1 - a_1 ) &amp; &gt; sgn ( b_2 - a_2 ) ) \\
\lor ( sgn ( b_1 - a_1 ) &amp; = sgn ( b_2 - a_2 ) \land F ( \{ 1 , 2 \}
) \leq F ( \{ 2 , 1 \} )
\end{aligned}
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,值域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于给定整数<span class="math inline">\(k\)</span>,所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>的长度为<span class="math inline">\(k\)</span>的子序列,表达式<span class="math inline">\(F ( \{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\} )\)</span>最小值.</p>
<p>如果<span class="math inline">\(k =
n\)</span>,则就是模型1.不然,我们考虑先选出一个大小为<span class="math inline">\(k\)</span>的子集,然后使用模型1.不难发现,我们最后取出的<span class="math inline">\(\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\}\)</span>一定是<span class="math inline">\(n =
k\)</span>时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有<span class="math inline">\(n\)</span>个物品,第<span class="math inline">\(i\)</span>个物品有非负费用<span class="math inline">\(c_i\)</span>和价值<span class="math inline">\(v_i\)</span>,两个人进行如下博弈:</p>
<ol type="1">
<li><p>第一个人要么选择一个物品,付出<span class="math inline">\(c_i\)</span>的代价;要么选择结束游戏.</p></li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行<span class="math inline">\(k\)</span>次);也可以选择不操作,此时第一个人获得<span class="math inline">\(v_i\)</span>的收益,博弈结束.</p></li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.<span class="math inline">\(( n \leq 1 . 5 \times 10^5 , k \leq 9
)\)</span></p></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择<span class="math inline">\(k + 1\)</span>个,然后收益为<span class="math inline">\(\min_{ i = 1 }^{ k - 1 } \{ v_{ x_i } - \sum_{ j =
1 }^i c_{ x_j }
\}\)</span>(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度<span class="math inline">\(O ( n \log n + nk )\)</span>.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有<span class="math inline">\(n\)</span>条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有<span class="math inline">\(n\)</span>条直线的答案,求<span class="math inline">\(n +
1\)</span>条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度<span class="math inline">\(a_1 , \cdots , a_n \in \{
90 \degree , 270 \degree \}\)</span>,要求构造一个<span class="math inline">\(n\)</span>边形(边必须平行于坐标轴),使得其内角依次是<span class="math inline">\(a_1 , \cdots , a_n\)</span>.</p>
<p>首先有解条件显然是判定它们的和是否是<span class="math inline">\(180
\degree ( n - 2 )\)</span>.</p>
<p>注意到相邻的<span class="math inline">\(90 \degree\)</span>和<span class="math inline">\(270
\degree\)</span>无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让<span class="math inline">\(S \rightarrow
T\)</span>.这个时候可以找一个中间状态<span class="math inline">\(A\)</span>,让<span class="math inline">\(S
\rightarrow A , T \rightarrow A\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有<span class="math inline">\(( X , 0
)\)</span>亮着,每次把<span class="math inline">\(( x , y
)\)</span>,<span class="math inline">\(( x , y + 1 )\)</span>,<span class="math inline">\(( x + 1 , y
)\)</span>状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p><span class="math inline">\(n \leq 10^5\)</span>,坐标的绝对值均<span class="math inline">\(\leq 10^{ 17 }\)</span>.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线<span class="math inline">\(y = - inf\)</span>,然后比对.我们注意到<span class="math inline">\(( X , 0
)\)</span>向下推的过程类似一个组合数递推的过程,由经典公式<span class="math inline">\(\binom{ S }{ T } \equiv [ T \subseteq S ] \bmod
2\)</span>可知,我们取<span class="math inline">\(inf = 2^{ 63 } -
1\)</span>即可.然后最后在这条线上一定是有一个区间是<span class="math inline">\(1\)</span>,我们需要找到区间左端点,我们选择在直线上随便找到一个<span class="math inline">\(1\)</span>,由于<span class="math inline">\(inf\)</span>很大,大于<span class="math inline">\(10^{ 17
}\)</span>,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,<span class="math inline">\(n \leq
10^4\)</span>,但是初始点可能是<span class="math inline">\(( X , Y
)\)</span>.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点<span class="math inline">\(( j , - inf )\)</span>和<span class="math inline">\(( k , - inf
)\)</span>是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>.而上述条件满足当且仅当<span class="math inline">\([ j - X \subseteq Y + inf ]\)</span>.</p>
<p>如果我们随便找一个点<span class="math inline">\(( p , - inf
)\)</span>满足条件,那我们接下来只需要枚举<span class="math inline">\(w\)</span>,判断<span class="math inline">\(( p -
2^w , - inf
)\)</span>是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间<span class="math inline">\([ l , r
]\)</span>中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">计算几何</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2>
<p>参考:https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3>
<h4><span id="eps">eps</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec{ a } \cdot \vec{ b } = | \vec{
a } | | \vec{ b } | \cos \theta = x_a x_b + y_a
y_b\)</span>.也就等于<span class="math inline">\(\vec{ a
}\)</span>在<span class="math inline">\(b\)</span>上的投影与<span class="math inline">\(\vec{ b }\)</span>的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } =
0\)</span>,则说明<span class="math inline">\(\vec{ a } \bot \vec{ b
}\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } &gt;
0\)</span>,则说明<span class="math inline">\(\vec{ a }\)</span>和<span class="math inline">\(\vec{ b }\)</span>正方向的夹角小于<span class="math inline">\(90 \degree\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } &lt;
0\)</span>,则说明<span class="math inline">\(\vec{ a }\)</span>和<span class="math inline">\(\vec{ b }\)</span>正方向的夹角大于<span class="math inline">\(90 \degree\)</span>.</p></li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec{ a } \times \vec{ b } = x_a
y_b - y_a x_b\)</span>.也就等于<span class="math inline">\(\vec{ a } ,
\vec{ b }\)</span>两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } =
0\)</span>,说明二者共线.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } &lt;
0\)</span>,说明从<span class="math inline">\(\vec{ a }\)</span>到<span class="math inline">\(\vec{ b }\)</span>的方向是顺时针.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } &gt;
0\)</span>,说明从<span class="math inline">\(\vec{ a }\)</span>到<span class="math inline">\(\vec{ b }\)</span>的方向是逆时针.</p></li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵<span class="math inline">\(\begin{bmatrix}\cos \theta &amp; - \sin \theta \\
\sin \theta &amp; \cos \theta\end{bmatrix}\)</span>.</p>
<h4><span id="line">Line</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下<span class="math inline">\(x_{ L_1 } , x_{ L_2 } ,
y_{ L_1 } , y_{ L_2
}\)</span>围成的四边形,计算面积后用等高不等底计算.注意<span class="math inline">\(ls\)</span>和<span class="math inline">\(rs\)</span>所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4>
<p>利用叉乘,任取平面上一点<span class="math inline">\(O\)</span>,则<span class="math inline">\(S = \frac{ 1 }{ 2 } \sum_{ i = 1 }^n
\overrightarrow{ OP_i } \times \overrightarrow{ OP_{ i + 1 }
}\)</span>.证明的话考虑分<span class="math inline">\(O\)</span>在内部和<span class="math inline">\(O\)</span>在外部两种情况分类讨论.注意此时的<span class="math inline">\(P\)</span>必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为<span class="math inline">\(a\)</span>,它的边上(包括顶点)的整点数为<span class="math inline">\(b\)</span>,则它的面积<span class="math inline">\(S
= a + \frac{ b }{ 2 } - 1\)</span>.</p>
<h3><span id="基本算法">基本算法</span></h3>
<h4><span id="排序算法">排序算法</span></h4>
<h5><span id="极角排序">极角排序</span></h5>
<p>定义原点<span class="math inline">\(O\)</span>并建立坐标系,所有点按照和<span class="math inline">\(O\)</span>所连直线与<span class="math inline">\(x\)</span>轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(x\)</span>相同比<span class="math inline">\(y\)</span>,否则比<span class="math inline">\(x\)</span>.</p>
<h4><span id="二维凸包">二维凸包</span></h4>
<h5><span id="定义">定义</span></h5>
<p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5>
<p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否<span class="math inline">\(ABC\)</span>三点是一个上凸的(注意<span class="math inline">\(ABC\)</span>三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5>
<p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4>
<p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5>
<p>两个区域<span class="math inline">\(A ,
B\)</span>的闵可夫斯基和定义为<span class="math inline">\(\{ a + b \mid
a \in A , b \in B \}\)</span>.</p>
<h5><span id="实现">实现</span></h5>
<p>事实上,新的区域所形成的凸包,一定是原本<span class="math inline">\(A ,
B\)</span>的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下<span class="math inline">\(A , B\)</span>,使得<span class="math inline">\(B\)</span>有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是<span class="math inline">\(B\)</span>这个边加上<span class="math inline">\(A\)</span>的最右边的点.这样这条边必定还在最终的凸包上.就算<span class="math inline">\(A\)</span>最右边的是一条边,你也会发现最终的凸包最右边也一定是由<span class="math inline">\(A\)</span>的这条边和<span class="math inline">\(B\)</span>的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义半平面为满足<span class="math inline">\(ax + by + c &gt;
0\)</span>或<span class="math inline">\(ax + by + c \geq
0\)</span>的点对<span class="math inline">\(( x , y
)\)</span>组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5>
<p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2>
<p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3>
<h4><span id="直线">直线</span></h4>
<p>使用直线的方向向量<span class="math inline">\(\vec{ s } = ( n , m , p
)\)</span>和直线上一点<span class="math inline">\(M_0 = ( x_0 , y_0 ,
z_0 )\)</span>.那么方程显然为:</p>
<p><span class="math display">\[
\frac{ x - x_0 }{ n } = \frac{ y - y_0 }{ m } = \frac{ z - z_0 }{ p }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x_0 + nt \\
y = y_0 + mt \\
z = z_0 + pt
\end{cases}
\]</span></p>
<h4><span id="平面">平面</span></h4>
<p>使用平面上的一点<span class="math inline">\(P_0 ( x_0 , y_0 , z_0
)\)</span>和该平面的法向量<span class="math inline">\(\vec{ n
}\)</span>来表示一个平面,不妨设<span class="math inline">\(\vec{ n } = (
A , B , C )\)</span>,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x_0 ) + B ( y - y_0 ) + C ( z - z_0 ) = 0
\]</span></p>
<p>如果我们令<span class="math inline">\(D = - ( Ax_0 + By_0 +
Cz_)\)</span>,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h4><span id="夹角">夹角</span></h4>
<h5><span id="两直线夹角">两直线夹角.</span></h5>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是<span class="math inline">\(\vec{ s_1 } = ( n_1 ,
m_1 , p_1 ) , \vec{ s_2 } = ( n_2 , m_2 , p_2 )\)</span>,也就有<span class="math inline">\(\varphi = \arccos ( \frac{ | \vec{ s }_1 \cdot
\vec{ s }_2 | }{ | \vec{ s }_1 | | \vec{ s }_2 | } ) \\\)</span>.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5>
<p>同样使用向量,不妨设方向向量<span class="math inline">\(\vec{ s } = (
n , m , p )\)</span>,法向量<span class="math inline">\(\vec{ f } = ( a ,
b , c )\)</span>,那么<span class="math inline">\(\varphi = \arcsin (
\frac{ | \vec{ s } \cdot \vec{ f } | }{ | \vec{ s } | | \vec{ f } | }
)\)</span>.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则<span class="math inline">\(am + bn + cp =
0\)</span>.</p></li>
<li><p>若直线与平面垂直,则<span class="math inline">\(\frac{ a }{ m } =
\frac{ b }{ n } = \frac{ c }{ p }\)</span>.注意这里分母可能除以<span class="math inline">\(0\)</span>,我们实际上应该是三个形如<span class="math inline">\(a = mt\)</span>的参数方程,这里简化了.</p></li>
</ol>
<h4><span id="交点">交点</span></h4>
<p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">组合数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2>
<h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3>
<p>定义下降幂<span class="math inline">\(x^{ \underline{ k } } = \prod_{
i = 0 }^{ k - 1 } ( x - i ) = \frac{ x ! }{ ( x - k ) ! }\)</span>.</p>
<p>定义上升幂<span class="math inline">\(x^{ \overline{ k } } \prod_{ i
= 0 }^{ k - 1 } ( x + i ) = \frac{ ( x + k - 1 ) ! }{ ( x - 1 ) !
}\)</span>.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:<span class="math inline">\(r^{ \underline{ k } }
( r - 0 . 5 )^{ \underline{ k } } = \cfrac{ ( 2 r )^{ \underline{ 2 k }
} }{ 2^{ 2 k } } , k \in \mathbb{ N }\)</span>.</p>
<p>他们之间存在转换:<span class="math inline">\(x^{ \underline{ n } } =
( - 1 )^n ( - x )^{ \overline{ n } }\)</span>.</p>
<p>同时存在大小关系:<span class="math inline">\(x^{ \underline{ n } }
\leq x^n \leq x^{ \overline{ n } }\)</span>,其中<span class="math inline">\(0 \leq n &lt; x\)</span>.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3>
<p>考虑令<span class="math inline">\(\binom{ n }{ m
}\)</span>表示从一个大小为<span class="math inline">\(n\)</span>的子集中选出大小为<span class="math inline">\(m\)</span>的子集的方案数.第一次有<span class="math inline">\(n\)</span>个选择,第二次有<span class="math inline">\(n - 1\)</span>个选择……第m次有<span class="math inline">\(n - m +
1\)</span>个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是<span class="math inline">\(m !\)</span>,因此显然有<span class="math inline">\(\binom{ n }{ m } = \cfrac{ n^{ \underline{ m } }
}{ m ! }\)</span>.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
<p><span class="math inline">\(\binom{ r }{ k } = \begin{cases}\cfrac{
r^{ \underline{ k } } }{ k ! } &amp; k \geq 0 \\ 0 &amp; k &lt;
0\end{cases} , r \in \mathbb{ C } , k \in \mathbb{ Z }\)</span>.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把<span class="math inline">\(\binom{ r }{ k }\)</span>看作了一个关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式.</p>
<p>另外根据定义,<span class="math inline">\(r \in \mathbb{ Z } \land r
&lt; k\)</span>时,该公式给出<span class="math inline">\(0\)</span>.</p>
<p>值得一提的是,为了使二项式系数在面对<span class="math inline">\(0\)</span>的时候更加简洁,通常直接定义<span class="math inline">\(0 ! = 1 , 0^0 = 1\)</span>.</p>
<p>另外不难发现<span class="math inline">\(\binom{ 2 n }{ n
}\)</span>是所有<span class="math inline">\(\binom{ 2 n }{ k
}\)</span>中最大的.事实上我们有Wallis公式:<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ ( \frac{ 2^{
2 n } }{ \binom{ 2 n }{ n } } )^2 }{ 2 n + 1 } = \frac{ \pi }{ 2
}\)</span>.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3>
<ol type="1">
<li>阶乘展开式:<span class="math inline">\(\binom{ n }{ k } = \cfrac{ n
! }{ k ! ( n - k ) ! } , n , k \in \mathbb{ N } , n \geq k
\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="2" type="1">
<li>对称恒等式:<span class="math inline">\(\binom{ n }{ k } = \binom{ n
}{ n - k } , n \in \mathbb{ N } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\(( 1 )\)</span>,<span class="math inline">\(0 \leq k \leq
n\)</span>时是显然的.而其他情况两边都会给出<span class="math inline">\(0\)</span>,因此也是成立的.</p>
<ol start="3" type="1">
<li>吸收恒等式:<span class="math inline">\(\binom{ r }{ k } = \cfrac{ r
}{ k } \binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z } \land k \ne 0
\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="4" type="1">
<li>吸收恒等式的变式:<span class="math inline">\(k \binom{ r }{ k } = r
\binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\(( 3 )\)</span>,只需要验证<span class="math inline">\(k = 0\)</span>的情况即可,也是显然的.</p>
<ol start="5" type="1">
<li>相伴恒等式:<span class="math inline">\(( r - k ) \binom{ r }{ k } =
r \binom{ r - 1 }{ k } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
( r - k ) \binom{ r }{ k } &amp; = ( r - k ) \binom{ r }{ r - k } \\
&amp; = r \binom{ r - 1 }{ r - k - 1 } \\
&amp; = r \binom{ r - 1 }{ k }
\end{aligned}
\]</span></p>
<p>问题在于:我们在上述描述中并未提到<span class="math inline">\(r\)</span>的范围,但是推导过程要求<span class="math inline">\(r \in \mathbb{ N
}\)</span>.不过,我们已经说明了二项式系数是关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式,因此只需要有<span class="math inline">\(k + 1\)</span>个<span class="math inline">\(r\)</span>满足这个公式即可.而根据推导过程显然有无限个<span class="math inline">\(r\)</span>满足,因此这个公式对<span class="math inline">\(r \in \mathbb{ C }\)</span>也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<p><span class="math display">\[
\begin{aligned}
k \binom{ r }{ k } &amp; = r \binom{ r - 1 }{ k - 1 } \\
( r - k ) \binom{ r }{ r - k } &amp; = r \binom{ r - 1 }{ r - k - 1 } \\
( r - k ) \binom{ r }{ k } &amp; = r \binom{ r - 1 }{ k }
\end{aligned}
\]</span></p>
<ol start="6" type="1">
<li>加法公式:<span class="math inline">\(\binom{ r }{ k } = \binom{ r -
1 }{ k } + \binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明可以使用定义,也可以先用<span class="math inline">\(r \in \mathbb{
N }\)</span>的情况给出组合意义,再使用多项式推理法证明.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\binom{ r }{ m } \binom{ m }{ k } =
\binom{ r }{ k } \binom{ r - k }{ m - k } , n , k \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol start="8" type="1">
<li>平行求和法:<span class="math inline">\(\sum_{ k \leq n } \binom{ r +
k }{ k } = \binom{ r + n + 1 }{ n } , n \in \mathbb{ N }
\\\)</span>.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p><span class="math inline">\(\binom{ r + n + 1 }{ n } = \binom{ r + n
}{ n } + \binom{ r + n }{ n - 1 } = \binom{ r + n }{ n } + \binom{ r + n
- 1 }{ n - 1 } + \binom{ r + n - 1 }{ n - 2 } = . . .
\\\)</span>,最终下标会减成负数,这样后面的项就全都是<span class="math inline">\(0\)</span>了.</p>
<p>也可以考虑组合意义:如果<span class="math inline">\(r \in \mathbb{ N
}\)</span>,那么我们考虑从右到左第一个没有被选上的数,假设它是<span class="math inline">\(r + k +
1\)</span>,那么在它右边的数全部选择了,一共是<span class="math inline">\(n - k\)</span>个数,而还需要在左边的<span class="math inline">\(r + k\)</span>中选择<span class="math inline">\(k\)</span>个数.</p>
<ol start="9" type="1">
<li>上指标求和法:<span class="math inline">\(\sum_{ 0 \leq k \leq n }
\binom{ k }{ m } = \binom{ n + 1 }{ m + 1 } , n , m \in \mathbb{ N }
\\\)</span>.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是<span class="math inline">\(k + 1\)</span>,接下来就还需要在<span class="math inline">\([ 1 , k ]\)</span>中选择<span class="math inline">\(m\)</span>个.</p>
<p>如果我们将这个公式两边同时乘以<span class="math inline">\(m
!\)</span>,我们可以得到公式:<span class="math inline">\(\sum_{ 0 \leq k
\leq n } k^{ \underline{ m } } = \cfrac{ ( n + 1 )^{ \underline{ m + 1 }
} }{ m + 1 } , n , m \in \mathbb{ N }
\\\)</span>,这也就是有限微积分的公式中的一个.</p>
<ol start="10" type="1">
<li>二项式定理:<span class="math inline">\(( x + y )^r = \sum_{ k }
\binom{ r }{ k } x^k y^{ r - k } , r \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 0 \leq k \leq n } \binom{ n }{ k } &amp; = 2^n , n \in \mathbb{ N
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令<span class="math inline">\(x = y =
1\)</span>即可证明.</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 0 \leq k \leq n } ( - 1 )^k \binom{ n }{ k } &amp; = 0^n = [ n =
0 ] , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令<span class="math inline">\(x = - 1 , y =
1\)</span>即可证明,值得一提的是,当<span class="math inline">\(n =
0\)</span>的时候这个式子给出<span class="math inline">\(1\)</span>,并在其他情况下给出<span class="math inline">\(0\)</span>,这个式子是二项式反演的基础.</p>
<ol start="11" type="1">
<li>三项式定理:<span class="math inline">\(( x + y + z )^n = \sum_{ 0
\leq a , b , c \leq n } [ a + b + c = n ] \cfrac{ n ! }{ a ! b ! c ! }
x^a y^b z^c , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,<span class="math inline">\(\cfrac{
n ! }{ a ! b ! c ! } = \binom{ n }{ b + c } \binom{ b + c }{ c
}\)</span>.</p>
<ol start="12" type="1">
<li>多项式定理:<span class="math inline">\(( \sum_{ i = 1 }^m x_i )^n =
\sum_{ \forall i \in [ 1 , m ] , 0 \leq a_i \leq n } [ \sum_{ i = 1 }^m
a_i = n ] \cfrac{ n ! }{ \prod_{ i = 1 }^m a_i ! } \prod_{ i = 1 }^m
x_i^{ a_i } , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol start="13" type="1">
<li>范德蒙德卷积:<span class="math inline">\(\sum_{ k } \binom{ r }{ m +
k } \binom{ s }{ n - k } = \binom{ r + s }{ n + m } , n , m \in \mathbb{
Z } \\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol start="14" type="1">
<li>范德蒙德卷积的变式:<span class="math inline">\(\sum_{ k } \binom{ l
}{ m + k } \binom{ s }{ n + k } = \binom{ l + s }{ l - m + n } , l \in
\mathbb{ N } , n , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\binom{ l }{ m + k } = \binom{ l }{ l -
m - k }\)</span>,然后运用范德蒙德卷积即可得到答案.</p>
<ol start="15" type="1">
<li>上指标反转公式:<span class="math inline">\(\binom{ r }{ k } = ( - 1
)^k \binom{ k - r - 1 }{ k } \\\)</span>.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ r }{ k } ( - 1
)^k = ( - 1 )^m \binom{ r - 1 }{ m } , m \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \leq m } \binom{ r }{ k } ( - 1 )^k &amp; = \sum_{ k \leq m }
\binom{ k - r - 1 }{ k } \\
&amp; = \binom{ - r + m }{ m } = ( - 1 )^m \binom{ r - 1 }{ m }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(\sum_{ - q \leq k \leq l } \binom{ l - k
}{ m } \binom{ q + k }{ n } = \binom{ l + q + 1 }{ m + n + 1 } , n , m
\in \mathbb{ N } , l + q \geq 0 \\\)</span>.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ a + b }{ a + k }
\binom{ a + b }{ b + k } ( - 1 )^k = \binom{ a + b }{ a } , a , b \in
\mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{ k = 0 }^m \cfrac{ \binom{ m }{ k
} }{ \binom{ n }{ k } } = \cfrac{ n + 1 }{ n + 1 - m } , n , m \in
\mathbb{ N } , n \geq m \\\)</span>.</li>
</ol>
<p>我们有<span class="math inline">\(\binom{ n }{ m } \binom{ m }{ k } =
\binom{ n }{ k } \binom{ n - k }{ m - k } \\\)</span>,两边同时除以<span class="math inline">\(\binom{ n }{ m } \binom{ n - k }{ m - k }
\\\)</span>,于是我们得到了<span class="math inline">\(\cfrac{ \binom{ m
}{ k } }{ \binom{ n }{ k } } = \cfrac{ \binom{ n - k }{ m - k } }{
\binom{ n }{ m } } \\\)</span>.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^m \cfrac{ \binom{ m }{ k } }{ \binom{ n }{ k } } &amp; =
\sum_{ k = 0 }^m \cfrac{ \binom{ n - k }{ m - k } }{ \binom{ n }{ m } }
\\
&amp; = \cfrac{ 1 }{ \binom{ n }{ m } } \sum_{ k = 0 }^m \binom{ n - k
}{ m - k } \\
&amp; = \cfrac{ 1 }{ \binom{ n }{ m } } \sum_{ k = 0 }^m \binom{ n - m +
k }{ k } \\
&amp; = \cfrac{ \binom{ n + 1 }{ m } }{ \binom{ n }{ m } } \\
&amp; = \cfrac{ n + 1 }{ n + 1 - m }
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(( - 1 )^m \binom{ - n - 1 }{ m } = ( - 1
)^n \binom{ - m - 1 }{ n } , n , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于<span class="math inline">\(\binom{ n + m }{ m } \\\)</span>.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ r }{ k } (
\cfrac{ r }{ 2 } - k ) = \cfrac{ m + 1 }{ 2 } \binom{ r }{ m + 1 } , m
\in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ m + r }{ k }
x^k y^{ m - k } = \sum_{ k \leq m } \binom{ - r }{ k } ( - x )^k ( x + y
)^{ m - k } , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>不妨令左边的值为<span class="math inline">\(S_m\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_m &amp; = \sum_{ k \leq m } \binom{ m + r }{ k } x^k y^{ m - k } =
\sum_{ k \leq m } \binom{ m + r - 1 }{ k } x^k y^{ m - k } + \sum_{ k
\leq m } \binom{ m + r - 1 }{ k - 1 } x^k y^{ m - k } \\
&amp; = y \sum_{ k &lt; m } \binom{ m - 1 + r }{ k } x^k y^{ m - 1 - k }
+ \binom{ m + r - 1 }{ m } x^m + x \sum_{ k \leq m } \binom{ m + r - 1
}{ k - 1 } x^{ k - 1 } y^{ m - k } \\
&amp; = ( x + y ) S_{ m - 1 } + \binom{ m + r - 1 }{ m } x^m \\
&amp; = ( x + y ) S_{ m - 1 } + \binom{ r }{ m } ( - x )^m
\end{aligned}
\]</span></p>
<p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ m + k }{ k }
2^{ - k } = 2^m , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(( 7 )\)</span>,将<span class="math inline">\(x = y = 1 , r = m + 1\)</span>带入,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \leq m } \binom{ 2 m + 1 }{ k } &amp; = \sum_{ k \leq m }
\binom{ m + k }{ k } 2^{ m - k } \\
2^{ 2 m } &amp; = \sum_{ k \leq m } \binom{ m + k }{ k } 2^{ m - k } \\
2^m &amp; = \sum_{ k \leq m } \binom{ m + k }{ k } 2^{ - k }
\end{aligned}
\]</span></p>
<ol start="9" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ l }{ m + k } \binom{
s + k }{ n } ( - 1 )^k = ( - 1 )^{ l + m } \binom{ s - m }{ n - l } , l
\in \mathbb{ N } , n , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\sum_{ k \leq l } \binom{ l - k }{ m }
\binom{ s }{ k - n } ( - 1 )^k = ( - 1 )^{ l + m } \binom{ s - m - 1 }{
l - n - m } , l , n , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\binom{ r }{ k } \binom{ r - \cfrac{ 1
}{ 2 } }{ k } = \cfrac{ \binom{ 2 r }{ 2 k } \binom{ 2 k }{ k } }{ 2^{ 2
k } } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>将加倍公式两边同时除以<span class="math inline">\(k
!^2\)</span>即可得到这个公式.</p>
<ol start="2" type="1">
<li><span class="math inline">\(\binom{ n - \cfrac{ 1 }{ 2 } }{ n } =
\cfrac{ \binom{ 2 n }{ n } }{ 2^{ 2 n } } , n \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>将<span class="math inline">\(( 1 )\)</span>中令<span class="math inline">\(r = k = n\)</span>即可得到这个公式.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\binom{ - \cfrac{ 1 }{ 2 } }{ n } = (
\cfrac{ - 1 }{ 4 } )^n \binom{ 2 n }{ n } , n \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>即<span class="math inline">\(( 2 )\)</span>的变形.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ n }{ 2 k } \binom{ 2
k }{ k } 2^{ - 2 k } = \binom{ n - \cfrac{ 1 }{ 2 } }{ \lfloor \cfrac{ n
}{ 2 } \rfloor } , n \in \mathbb{ N } \\\)</span></li>
</ol>
<p>首先根据<span class="math inline">\(( 1 )\)</span>,左边<span class="math inline">\(= \sum_{ k } \binom{ \cfrac{ n }{ 2 } }{ k }
\binom{ \cfrac{ n - 1 }{ 2 } }{ k } \\\)</span>,而考虑到<span class="math inline">\(\cfrac{ n }{ 2 }\)</span>和<span class="math inline">\(\cfrac{ n - 1 }{ 2
}\)</span>必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ - \cfrac{ 1 }{ 2 } }{
k } \binom{ - \cfrac{ 1 }{ 2 } }{ n - k } = ( - 1 )^n , n \in \mathbb{ N
} \\\)</span>.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ 2 k }{ k } \binom{ 2
n - 2 k }{ n - k } = 4^n , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>由<span class="math inline">\(( 5 )\)</span>和<span class="math inline">\(( 3 )\)</span>不难推出.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ n }{ k } \cfrac{ ( -
1 )^k }{ x + k } = x^{ - 1 } \binom{ x + n }{ n }^{ - 1 } , x \notin \{
0 , - 1 , . . . , - n \} \\\)</span>.</li>
</ol>
<p>令<span class="math inline">\(f ( x ) = ( x - 1 )^{ \underline{ - 1 }
}\)</span>,直接做高阶差分即可得到这个式子.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{ k = 0 }^n \binom{ r }{ k }
\binom{ r }{ n - k } ( - 1 )^k = [ n \ is \ \mathrm{ even } ] ( - 1 )^{
\cfrac{ n }{ 2 } } \binom{ r }{ \cfrac{ n }{ 2 } } \\\)</span>.</li>
</ol>
<p>首先不难发现,<span class="math inline">\(( 1 - z )^r = \sum_{ k \geq
0 } ( - 1 )^k \binom{ r }{ k } \\\)</span>.</p>
<p>考虑<span class="math inline">\(( 1 - z )^r ( 1 + z )^r = ( 1 - z^2
)^r\)</span>.</p>
<p>我们有<span class="math inline">\([ z^n ] ( 1 - z )^r ( 1 + z )^r = [
z^n ] ( 1 - z^2 )^r\)</span>,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3>
<p>卡特兰数<span class="math inline">\(f_n\)</span>表示:长度为<span class="math inline">\(2 n\)</span>的合法括号序列个数.</p>
<p>卡特兰数的前几项为<span class="math inline">\(1 , 1 , 2 , 5 , 14 , 42
, 132 \cdots\)</span>.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:<span class="math inline">\(f_n = \sum_{ i = 0 }^{ n - 1 }
f_i f_{ n - 1 - i }\)</span>.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如<span class="math inline">\(( A ) B\)</span>.</p>
<p>考虑将其删成<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,则<span class="math inline">\(A\)</span>一定合法,因为若<span class="math inline">\(A\)</span>不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:<span class="math inline">\(f_n = \frac{ 1 }{ n + 1 } C_{ 2
n }^n = C_{ 2 n }^n - C_{ 2 n }^{ n - 1 }\)</span>.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , 0
)\)</span>不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到<span class="math inline">\(( 2 n , 0
)\)</span>的方案数是<span class="math inline">\(C_{ 2 n
}^n\)</span>.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点<span class="math inline">\(( x , - 1 )\)</span>.</p>
<p>考虑将<span class="math inline">\(x\)</span>以后的折线以直线<span class="math inline">\(y = - 1\)</span>为对称轴反转,那么终点到了<span class="math inline">\(( 2 n , - 2 )\)</span>.</p>
<p>不难发现,任意从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , - 2
)\)</span>的方案一定唯一对应了一种从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , 0
)\)</span>的不合法方案.因为从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , - 2
)\)</span>一定会经过直线<span class="math inline">\(y = -
1\)</span>,将后半部分对称后就是其对应方案.而从<span class="math inline">\(( 0 , 0 )\)</span>走到<span class="math inline">\(( 2 n , - 2 )\)</span>的方案数为<span class="math inline">\(C_{ 2 n }^{ n - 1 }\)</span>.</p>
<p>因而<span class="math inline">\(f_n = C_{ 2 n }^n - C_{ 2 n }^{ n - 1
} \\\)</span>.</p>
<p>而<span class="math inline">\(C_{ 2 n }^n - C_{ 2 n }^{ n - 1 } =
\frac{ ( 2 n ) ! }{ n ! n ! } - \frac{ ( 2 n ) ! }{ ( n - 1 ) ! ( n + 1
) ! } = \frac{ ( 2 n ) ! }{ n ! ( n + 1 ) ! } = \frac{ C_{ 2 n }^n }{ n
+ 1 } \\\)</span>.</p>
<p>递推定义:<span class="math inline">\(f_n = \frac{ 4 n - 2 }{ n + 1 }
f_{ n - 1 } \\\)</span>.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\</p>
<p>f_{n-1}=</p>
<p>\end{cases}\</p>
<p>不难发现<span class="math inline">\(f_n = \frac{ ( 2 n - 1 ) ( 2 n )
}{ n ( n + 1 ) } f_{ n - 1 } \\\)</span>.整理,得到<span class="math inline">\(f_n = \frac{ 4 n - 2 }{ n + 1 } f_{ n - 1 }
\\\)</span>.</p>
<p>换个记号,设<span class="math inline">\(C_n\)</span>为卡特兰数的第<span class="math inline">\(n\)</span>项,卡特兰数有一个著名的结论是<span class="math inline">\(k\)</span>次卷积:</p>
<p><span class="math display">\[
C^{ ( k ) }_n = \sum_{ \sum_{ j = 1 }^k a_j = n } \prod C_{ a_i } =
\frac{ k }{ n + k } \binom{ 2 n + k - 1 }{ n }
\]</span></p>
<p>我们可以这么理解它:它指的是一个长度为<span class="math inline">\(n +
k - 1\)</span>的括号序列,前<span class="math inline">\(k -
1\)</span>个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成<span class="math inline">\(( ( ( A ) B ) C )
D\)</span>之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<p><span class="math display">\[
\begin{aligned}
C^{ ( k ) }_n &amp; = \binom{ 2 n + k - 1 }{ n } - \binom{ 2 n + k - 1
}{ n - 1 } \\
&amp; = \frac{ k }{ n + k } \binom{ 2 n + k - 1 }{ n }
\end{aligned}
\]</span></p>
<h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5>
<p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是<span class="math inline">\(\binom{ 2 n }{ n }\)</span>.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5>
<p>给定<span class="math inline">\(x , n\)</span>,对<span class="math inline">\(y \in [ 1 , n ]\)</span>,固定<span class="math inline">\(p_x =
y\)</span>做笛卡尔树的<strong>形态</strong>计数.<span class="math inline">\(n \leq 5 \times 10^5\)</span>.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现<span class="math inline">\(a_x = y\)</span>只要满足:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>节点的祖先数量不超过<span class="math inline">\(y - 1\)</span>个(深度小于等于<span class="math inline">\(y\)</span>).</p></li>
<li><p><span class="math inline">\(x\)</span>节点的子树大小不超过<span class="math inline">\(n - y + 1\)</span>.</p></li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出<span class="math inline">\(f_p\)</span>表示<span class="math inline">\(x\)</span>的深度为<span class="math inline">\(p\)</span>的答案,<span class="math inline">\(g_p\)</span>表示<span class="math inline">\(x\)</span>的子树大小为<span class="math inline">\(p\)</span>的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:<span class="math inline">\(x\)</span>的祖先有两种:一种在序列中在<span class="math inline">\(x\)</span>的左边,一种在<span class="math inline">\(x\)</span>的右边.我们设前者为<span class="math inline">\(0 = l_0 &lt; l_1 &lt; l_2 &lt; \cdots l_p &lt; l_{
p + 1 } = x\)</span>,设后者为<span class="math inline">\(n + 1 = r_0
&gt; r_1 &gt; r_2 &gt; \cdots &gt; r_{ q } &gt; r_{ q + 1 } =
x\)</span>.这么分类有什么用呢?我们考虑<span class="math inline">\(( l_{
i - 1 } , l_{ i } )\)</span>这一段数能放在哪里,它只能是<span class="math inline">\(l_{ i
}\)</span>的左儿子,独立于整棵树,因此这一段的答案就是<span class="math inline">\(C_{ l_i - l_{ i - 1 } - 1 }\)</span>.</p>
<p>记:</p>
$$
<span class="math display">\[\begin{aligned}
L_p &amp; = \sum_{ l } \prod_{ i = 1 }^{ p + 1 } C_{ l_i - l_{ i - 1 } -
1 } \\
R_q &amp; = \sum_{ r } \prod_{ i = 1 }^{ q + 1 } C_{ r_{ i - 1 } - r_i -
1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到这等价于卡特兰数的<span class="math inline">\(k\)</span>次卷积,有:</p>
$$
<span class="math display">\[\begin{aligned}
L_p &amp; = C_{ x - p - 1 }^{ ( p + 1 ) } \\
R_q &amp; = C^{ ( q + 1 ) }_{ n - x - q } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时的答案自然是<span class="math inline">\(f_{ p + q + 1 } = L_p R_q
\binom{ p + q }{ q }\)</span>,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把<span class="math inline">\(x\)</span>的子树从原树中删去,然后插入<span class="math inline">\(x\)</span>一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为<span class="math inline">\(p\)</span>,右子树大小为<span class="math inline">\(q\)</span>,我们有<span class="math inline">\(g_{ p
+ q + 1 } = C_p C_q C_{ n - ( p + q + 1 ) } = C_{ n - 1 }^{ ( 3 )
}\)</span>,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3>
<h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k \binom{ m - k - 1 }{
m - n - 1 } , n , m \in \mathbb{ N } \land m &gt; n \\\)</span>.</p>
<p>这个式子乘了个系数<span class="math inline">\(k\)</span>导致很难处理,一个自然的想法是使用吸收恒等式将<span class="math inline">\(k\)</span>消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n k \binom{ m - k - 1 }{ m - n - 1 } &amp; = \sum_{ k = 0
}^n m \binom{ m - k - 1 }{ m - n - 1 } - \sum_{ k = 0 }^n ( m - k )
\binom{ m - k - 1 }{ m - n - 1 } \\
&amp; = m \sum_{ k = 0 }^{ m - 1 } \binom{ m - k - 1 }{ m - n - 1 } - (
m - n ) \sum_{ k = 0 }^m \binom{ m - k }{ m - n }
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(S_m = \sum_{ k = 0 }^m \binom{ m -
k }{ m - n } \\\)</span>,不难发现我们有:</p>
<p><span class="math display">\[
S_m = \sum_{ k = 0 }^m \binom{ k }{ m - n } = \binom{ m + 1 }{ m - n + 1
}
\]</span></p>
<p>于是原式<span class="math inline">\(= mS_{ m - 1 } - ( m - n ) S_m =
\cfrac{ n }{ m - n + 1 } \binom{ m }{ m - n } \\\)</span>.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将<span class="math inline">\(k = \binom{ k }{ 1 }\)</span>带入:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n k \binom{ m - k - 1 }{ m - n - 1 } &amp; = \sum_{ k = 0
}^n \binom{ k }{ 1 } \binom{ m - k - 1 }{ m - n - 1 } \\
&amp; = \binom{ m }{ m - n + 1 } \\
&amp; = \cfrac{ n }{ m - n + 1 } \binom{ m }{ m - n }
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{ k } k \binom{ n }{ k } \binom{ s
}{ k } , n \in \mathbb{ N } \\\)</span>.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到<span class="math inline">\(n\)</span>和<span class="math inline">\(s\)</span>的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k } k \binom{ n }{ k } \binom{ s }{ k } &amp; = s \sum_{ k }
\binom{ n }{ k } \binom{ s - 1 }{ k - 1 } \\
&amp; = s \binom{ n + s - 1 }{ n - 1 }
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(\sum_{ 0 \leq k } \binom{ n + k }{ 2 k
} \binom{ 2 k }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n \in \mathbb{ N }
\\\)</span>.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 0 \leq k } \binom{ n + k }{ 2 k } \binom{ 2 k }{ k } \cfrac{ ( -
1 )^k }{ k + 1 } &amp; = \sum_{ 0 \leq k } \binom{ n + k }{ k } \binom{
n }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n \in \mathbb{ N } \\
&amp; = \cfrac{ 1 }{ n + 1 } \sum_{ 0 \leq k } \binom{ n + k }{ k }
\binom{ n + 1 }{ k + 1 }{ ( - 1 )^k } \\
&amp; = \cfrac{ 1 }{ n + 1 } \sum_{ 0 \leq k } \binom{ - n - 1 }{ k }
\binom{ n + 1 }{ k + 1 } \\
&amp; = \cfrac{ 1 }{ n + 1 } \binom{ 0 }{ n } \\
&amp; = [ n = 0 ]
\end{aligned}
\]</span></p>
<h5><span id="example4">Example4</span></h5>
<p>求<span class="math inline">\(\sum_{ k \geq 0 } \binom{ n + k }{ m +
2 k } \binom{ 2 k }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n , m \in
\mathbb{ N_+ } \\\)</span>.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的<span class="math inline">\(( 1 )\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \geq 0 } \binom{ n + k }{ m + 2 k } \binom{ 2 k }{ k } \cfrac{
( - 1 )^k }{ k + 1 } &amp; = \sum_{ k \geq 0 } \sum_{ 0 \leq j \leq n +
k - 1 } \binom{ n + k - 1 - j }{ 2 k } \binom{ j }{ m - 1 } \binom{ 2 k
}{ k } \cfrac{ ( - 1 )^k }{ k + 1 } \\
&amp; = \sum_{ 0 \leq j \leq n - 1 } \binom{ j }{ m - 1 } \sum_{ j + 1 -
n \leq k , 0 \leq k } \binom{ n + k - 1 - j }{ 2 k } \binom{ 2 k }{ k }
\cfrac{ ( - 1 )^k }{ k + 1 }
\end{aligned}
\]</span></p>
<p>注意到如果<span class="math inline">\(j + 1 - n \geq
0\)</span>,则<span class="math inline">\(\binom{ n + k - 1 - j }{ 2 k }
\\\)</span>应为<span class="math inline">\(0\)</span>.所以有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ 0 \leq j \leq n - 1 } \binom{ j }{ m - 1 } \sum_{ j + 1 - n
\leq k , 0 \leq k } \binom{ n + k - 1 - j }{ 2 k } \binom{ 2 k }{ k }
\cfrac{ ( - 1 )^k }{ k + 1 } \\
= &amp; \sum_{ 0 \leq j &lt; n } \binom{ j }{ m - 1 } [ n - 1 - j = 0 ]
= \binom{ n - 1 }{ m - 1 }
\end{aligned}
\]</span></p>
<h5><span id="example5">Example5</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n ( C_n^k
)^2\)</span>.</p>
<p><span class="math display">\[
\sum_{ k = 0 }^n ( C_n^k )^2 = \sum_{ k = 0 }^n C_{ n }^k \times C_{ n
}^{ n - k } = C_n^{ 2 n }
\]</span></p>
<h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(Q_n = \sum_{ k \leq 2^n } \binom{ 2^n -
k }{ k } ( - 1 )^k , n \in \mathbb{ N } \\\)</span>.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于<span class="math inline">\(Q_n\)</span>的式子中实际上只与<span class="math inline">\(2^n\)</span>有关,我们不妨令<span class="math inline">\(R_n = \sum_{ k \leq n } \binom{ n - k }{ k } ( - 1
)^k \\\)</span>,显然有<span class="math inline">\(Q_n = R_{ 2^n
}\)</span>.</p>
<p>而我们有:</p>
<p><span class="math display">\[
\begin{aligned}
R_n &amp; = \sum_{ k \leq n } \binom{ n - 1 - k }{ k } ( - 1 )^k +
\sum_{ k \leq n } \binom{ n - 1 - k }{ k - 1 } ( - 1 )^k \\
&amp; = \sum_{ k \leq n } \binom{ n - 1 - k }{ k } ( - 1 )^k + \sum_{ k
\leq n - 1 } \binom{ n - k - 2 }{ k } ( - 1 )^{ k + 1 } \\
&amp; = \sum_{ k \leq n - 1 } \binom{ n - 1 - k }{ k } ( - 1 )^k +
\binom{ - 1 }{ n } ( - 1 )^n - ( \sum_{ k \leq n - 2 } \binom{ n - 2 - k
}{ k } ( - 1 )^k + \binom{ - 1 }{ n - 1 } ( - 1 )^{ n - 1 } ) \\
&amp; = \sum_{ k \leq n - 1 } \binom{ n - 1 - k }{ k } ( - 1 )^k -
\sum_{ k \leq n - 1 } \binom{ n - 2 - k }{ k } ( - 1 )^k \\
&amp; = R_{ n - 1 } - R_{ n - 2 } \\
&amp; = R_{ n - 2 } - R_{ n - 3 } - R_{ n - 2 } \\
&amp; = - R_{ n - 3 } \\
&amp; = R_{ n - 6 }
\end{aligned}
\]</span></p>
<p>也即<span class="math inline">\(R_n\)</span>具有周期性,不难计算前几项答案,最后有<span class="math inline">\(Q_n \begin{cases}1 &amp; n = 0 \\ 0 &amp; n \ is \
\mathrm{ odd } \\ - 1 &amp; n &gt; 0 \land n \ is \ \mathrm{ even
}\end{cases}\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(( \sum^{ + \infty }_{ i = 0 } C^{ ik +
r }_{ nk } ) \mod p\)</span>.</p>
<p>考虑设<span class="math inline">\(f ( n , r ) = \sum^{ + \infty }_{ i
= 0 } C^{ ik + r }_{ nk } \\\)</span>,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n , r ) &amp; = \sum^{ + \infty }_{ i = 0 } C^{ ik + r }_{ nk } \\
&amp; = \sum_{ i = 0 }^{ + \infty } \sum_{ j = 0 }^k C_{ nk - k }^{ ik +
r - j } \times C_k^j \\
&amp; = \sum^k_{ j = 0 } C_k^j \sum_{ i = 0 }^{ + \infty } C_{ nk - k
}^{ ik + r - j } \\
&amp; = \sum_{ j = 0 }^k C_k^j f ( n - 1 , r - j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理上式,得到:<span class="math inline">\(f ( n , r ) = \sum_{ j = 0
}^k C_k^j f ( n - 1 , r - j ) \\\)</span>.</p>
<p>于是我们得到了关于<span class="math inline">\(f\)</span>的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4>
<h5><span id="example">Example</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 1 }^n k^2
C_n^k\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
( ( 1 + x )^n ) &amp; = ( \sum_{ k = 0 }^n C_n^k x^{ k } ) \\
( ( 1 + x )^n ) &#39; &amp; = ( \sum_{ k = 0 }^n C_n^k x^{ k } ) &#39;
\\
n ( 1 + x )^{ n - 1 } &amp; = \sum_{ k = 0 }^n kC_n^k x^{ k - 1 } \\
nx ( 1 + x )^{ n - 1 } &amp; = \sum_{ k = 0 }^n kC_n^k x^{ k } \\
( nx ( 1 + x )^{ n - 1 } ) &#39; &amp; = ( \sum_{ k = 0 }^n kC_n^k x^{ k
} ) &#39; \\
n ( ( 1 + x )^{ n - 1 } + ( n - 1 ) x ( 1 + x )^{ n - 2 } ) &amp; =
\sum_{ k = 0 }^n k^2 C_n^k x^{ k - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>取<span class="math inline">\(x = 1\)</span>,则原式<span class="math inline">\(= n ( n + 1 ) 2^{ n - 2 }\)</span>.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>多次询问给定<span class="math inline">\(k , r\)</span>,<span class="math inline">\(\sum k \leq 2 n , r &lt; 2 n - k\)</span>,求<span class="math inline">\(\sum_{ i = 0 }^{ r } \frac{ 1 }{ 2^i } \binom{ i
}{ n - k }\)</span>,.</p>
<p>我们把模型抽象成:在二维平面上,从<span class="math inline">\(( 0 , 0
)\)</span>随机游走到<span class="math inline">\(( n - k + 1 , r - n + k
)\)</span>正下方(包含这个点)的概率,容易发现此时向右走了<span class="math inline">\(n - k\)</span>步,总共走了<span class="math inline">\(\leq
r\)</span>步,然后再向右走一步保证第一次走到了<span class="math inline">\(( n - k + 1 , r - n + k )\)</span>下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到<span class="math inline">\(x + y = r + 1\)</span>这条直线时横坐标<span class="math inline">\(\geq n - k +
1\)</span>的概率.枚举一下总共向上走了几步,就得到<span class="math inline">\(\frac{ 1 }{ 2^{ r } } \sum_{ j = 0 }^{ r - n + k }
\binom{ r + 1 }{ j }\)</span>,注意这里是<span class="math inline">\(\frac{ 1 }{ 2^r
}\)</span>,因为从一开始钦定了一步,因此映射过来需要多乘个<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>,反映射就要乘个<span class="math inline">\(2\)</span>.但是这个式子还是做不了,因为<span class="math inline">\(r\)</span>并不满足<span class="math inline">\(\sum
r \leq 2 n\)</span>.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于<span class="math inline">\(1 - \frac{ 1 }{ 2^{ r } } \sum_{ i = 0 }^{ n - k }
\binom{ r + 1 }{ i }\)</span>.我们考虑暴力预处理出<span class="math inline">\(f_r = \sum_{ i = 0 }^{ n } \binom{ r }{ i
}\)</span>,每次删掉一个后缀的组合数就行.现在的问题在于<span class="math inline">\(f\)</span>怎么做.</p>
<p>直接拆组合数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_r &amp; = \sum_{ i = 0 }^n \binom{ r }{ i } \\
&amp; = \sum_{ i = 0 }^n \binom{ r - 1 }{ i - 1 } + \sum_{ i = 0 }^n
\binom{ r - 1 }{ i } \\
&amp; = 2 \sum_{ i = 0 }^n \binom{ r - 1 }{ i } - \binom{ r - 1 }{ n }
\\
&amp; = 2 f_{ r - 1 } - \binom{ r - 1 }{ n }
\end{aligned}
\]</span></p>
<h3><span id="lucas定理">Lucas定理</span></h3>
<p>若<span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(C_n^m \mod p = C_{ n \mod p }^{ m \mod p } \times
C_{ \lfloor \frac{ n }{ p } \rfloor }^{ \lfloor \frac{ m }{ p } \rfloor
} \mod p \\\)</span>.</p>
<p>或者说,将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>在<span class="math inline">\(p\)</span>进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若<span class="math inline">\(i \ne 0\)</span>且<span class="math inline">\(i \ne p\)</span>,<span class="math inline">\(C_{ p
}^i \equiv \frac{ p }{ i } C_{ p - 1 }^{ i - 1 } \equiv 0 ( \mod p )
\\\)</span>.</p>
<p>而根据二项式定理,<span class="math inline">\(( 1 + x )^p \equiv
\sum_{ i = 0 }^p C_{ p }^i x^i = 1 + x^p ( \mod p ) \\\)</span>.</p>
<p>令<span class="math inline">\(n = k_1 p + b_1\)</span>,<span class="math inline">\(m = k_2 p + b_2\)</span>,则<span class="math inline">\(( 1 + x )^n = ( 1 + x )^{ k_1 p } ( 1 + x )^{ b_1
} \\\)</span>.</p>
<p>而<span class="math inline">\(( 1 + x )^{ k_1 p } \equiv ( 1 + x^p
)^{ k_1 } ( \mod p ) \\\)</span>,有<span class="math inline">\(( 1 + x
)^n \equiv ( 1 + x^p )^{ k_1 } ( 1 + x )^{ b_1 } \\\)</span>.</p>
<p>根据二项式定理,<span class="math inline">\(C_n^m \bmod
p\)</span>即<span class="math inline">\(x^m\)</span>项的系数.</p>
<p>我们可以得出,<span class="math inline">\(C_n^m x^m \equiv C_{ k_1 }^{
k_2 } x^{ k_2 p } C_{ b 1 }^{ b_2 } x^{ b_2 } \pmod{ p }
\\\)</span>,那么有<span class="math inline">\(C_a^b \equiv C_{ k_1 }^{
k_2 } C_{ b_1 }^{ b_2 } \pmod{ p } \\\)</span>.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<p><span class="math display">\[
\binom{ n }{ m } \equiv [ m \subseteq n ] \pmod{ 2 }
\]</span></p>
<h5><span id="example1cf1770fkoxia-andsequence">Example1([CF1770F]Koxia and
Sequence)</span></h5>
<p>首先观察样例并思考,可以发现当<span class="math inline">\(n\)</span>为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是<span class="math inline">\(0\)</span>),所以异或值为<span class="math inline">\(0\)</span>.不然,我们可以翻转<span class="math inline">\(a [ 2 . . . n ]\)</span>,得出答案应该是所有<span class="math inline">\(a_1\)</span>的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有<span class="math inline">\(y &#39; \subseteq y\)</span>,求出满足<span class="math inline">\(a_i \subseteq y &#39; , \sum a_i =
x\)</span>时,<span class="math inline">\(a_1\)</span>异或和.接下来怎么做呢?我们考虑拆位,若<span class="math inline">\(2^k \subseteq y &#39;\)</span>,假设<span class="math inline">\(a_1\)</span>的第<span class="math inline">\(k\)</span>位是<span class="math inline">\(1\)</span>,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第<span class="math inline">\(k\)</span>位贡献是:</p>
<p><span class="math display">\[
[ 2^k \subseteq y &#39; ] \bigoplus_{ \sum a = x } [ 2^k \subseteq a_1 ]
\prod_{ i = 1 }^n [ a_i \subseteq y &#39; ]
\]</span></p>
<p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:<span class="math inline">\([ x \subseteq y ] \equiv \binom{ y }{ x } \pmod{ 2
}\)</span>.</p>
<p>所以原式化简为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \binom{ y &#39; }{ 2^k } \sum_{ \sum a = x } \binom{ a_1 }{ 2^k }
\prod_{ i = 1 }^n \binom{ y &#39; }{ a_i } \pmod{ 2 } \\
= &amp; \binom{ y &#39; }{ 2^k } \sum_{ a_1 } \binom{ y &#39; - 2^k }{
a_1 - 2^k } \sum_{ \sum a = x - a_1 } \prod_{ i = 2 }^n \binom{ y &#39;
}{ a_i } \pmod{ 2 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \binom{ y &#39; }{ 2^k } \sum_{ a_1 } \binom{ y &#39; - 2^k }{ a_1
- 2^k } \binom{ ( n - 1 ) y &#39; }{ x - a_1 } \pmod{ 2 } \\
= &amp; \binom{ y &#39; }{ 2^k } \binom{ ny &#39; - 2^k }{ x - 2^k }
\pmod{ 2 } \\
= &amp; [ 2^k \subseteq y &#39; ] [ ( x - 2^k ) \subseteq ( ny &#39; -
2^k ) ]
\end{aligned}
\]</span></p>
<h3><span id="扩展lucas定理">扩展Lucas定理</span></h3>
<p>令<span class="math inline">\(p = \prod p_i^{ e_i
}\)</span>,那我们只要对于每个<span class="math inline">\(i\)</span>求出<span class="math inline">\(C_n^m
\mod p_i^{ e_i }\)</span>,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求<span class="math inline">\(C_n^m \mod
p^k\)</span>,其中<span class="math inline">\(p \in \mathrm{ prime
}\)</span>.</p>
<p>原式<span class="math inline">\(= \frac{ n ! }{ m ! ( n - m ) ! }
\mod p^k = \frac{ \frac{ n ! }{ p^x } }{ \frac{ m ! }{ p^y } \frac{ ( n
- m ) ! }{ p^z } } p^{ x - y - z } \mod p^k \\\)</span>.</p>
<p>现在问题转化为求<span class="math inline">\(\frac{ n ! }{ p^x } \mod
p^k 以 及 p^x \\\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n ! &amp; = \prod_{ i = 1 } i \\
&amp; = ( \prod_{ i = wp , w \in \mathbb{ Z } } i ) ( \prod_{ i \ne wp ,
w \in \mathbb{ Z } } i ) \\
&amp; = p^{ \lfloor n p \rfloor } ( \lfloor n p \rfloor ! ) ( \prod_{ i
\ne wp , w \in \mathbb{ Z } } i ) \\
&amp; \equiv p^{ \lfloor \frac{ n }{ p } \rfloor } ( \lfloor \frac{ n }{
p } \rfloor ! ) ( \prod_{ i = 1 , i \ne wp , w \in \mathbb{ Z } }^{ p^k
} i )^{ \lfloor \frac{ n }{ p^k } \rfloor } ( \prod^{ n \ \bmod{ p^k }
}_{ i = p^k \lfloor \frac{ n }{ p^k } \rfloor , i \ne wp , w \in
\mathbb{ Z } } i ) ( \mod p^k )
\end{aligned}
\]</span></p>
<p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将<span class="math inline">\([ 1
, n ]\)</span>的所有数全部排成一个宽为<span class="math inline">\(p^k\)</span>的矩阵.</p>
<p>那右边第一项就是把那些<span class="math inline">\(p\)</span>的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2>
<h3><span id="第一类斯特林数">第一类斯特林数</span></h3>
<p><span class="math inline">\(n \brack k \\\)</span>:长度为<span class="math inline">\(n\)</span>的排列划分成<span class="math inline">\(k\)</span>个轮换的方案数.</p>
<p>考虑现在已经将<span class="math inline">\(n -
1\)</span>个数分成了若干轮换,现在新加入第<span class="math inline">\(n\)</span>个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然<span class="math inline">\(\left [ \begin{array}{ c } n \\ k\end{array}
\right ] = ( n - 1 ) \left [ \begin{array}{ c } n - 1 \\ k\end{array}
\right ] + \left [ \begin{array}{ c } n - 1 \\ k - 1\end{array} \right ]
\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left [ \begin{array}{ c }
0 \\ k\end{array} \right ] = [ k = 0 ] \\\)</span>.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:<span class="math inline">\(\sum_{ k = 0 }^n \left [ \begin{array}{ c } n \\
k\end{array} \right ] = n !\)</span>.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3>
<p><span class="math inline">\(\left \{ \begin{array}{ c } n \\
k\end{array} \right \}\)</span>:将<span class="math inline">\(n\)</span>个本质不同的物品划分成k个非空集合的方案数.</p>
<p>考虑现在已经放好<span class="math inline">\(n -
1\)</span>个物品,正要放入第<span class="math inline">\(n\)</span>个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然<span class="math inline">\(\left \{ \begin{array}{ c } n \\ k\end{array}
\right \} = k \left \{ \begin{array}{ c } n - 1 \\ k\end{array} \right
\} + \left \{ \begin{array}{ c } n - 1 \\ k - 1\end{array} \right \}
\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left \{ \begin{array}{ c
} 0 \\ k\end{array} \right \} = [ k = 0 ] \\\)</span>.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3>
<p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:<span class="math inline">\({ n \brack m } ={ - m \brace - n }
\\\)</span>.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3>
<ol type="1">
<li><span class="math inline">\(x^n = \sum_{ k = 0 }^n \left \{
\begin{array}{ c } n \\ k\end{array} \right \} x^{ \underline{ k } } =
\sum_{ k = 0 }^n \left \{ \begin{array}{ c } n \\ k\end{array} \right \}
( - 1 )^{ n - k } x^{ \overline{ k } } \\\)</span>.</li>
</ol>
<p>证明:先考虑前半段,不妨使用数学归纳.若<span class="math inline">\(x^{
n - 1 } = \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}{ c } n - 1 \\
k\end{array} \right \} x^{ \underline{ k } } \\\)</span>,我们要证</p>
<p>\</p>
$$
<span class="math display">\[\begin{aligned}
x \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} x^{ \underline{ k } } &amp; = \sum_{ k = 0 }^{ n }
\left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} x^{ \underline{ k } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑<span class="math inline">\(( x - k ) x^{ \underline{ k } } = x^{
\underline{ k + 1 } }\)</span>,所以<span class="math inline">\(x \cdot
x^{ \underline{ k } } = x^{ \underline{ k + 1 } } + kx^{ \underline{ k }
} \\\)</span>.那么左边即:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} x^{ \underline{ k + 1 } } + \sum_{ k = 0 }^{ n - 1
} \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} kx^{ \underline{ k } } \\
= &amp; \sum_{ k = 1 }^{ n } \left \{ \begin{array}
{ c } n - 1 \\
k - 1
\end{array} \right \} x^{ \underline{ k } } + \sum_{ k = 1 }^{ n } \left
\{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} kx^{ \underline{ k } } \\
= &amp; \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} x^{ \underline{ k } } \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>至于后半段,由于<span class="math inline">\(x^{ \underline{ n } } = (
- 1 )^n ( - x )^{ \overline{ n } } \\\)</span>,所以<span class="math inline">\(x^n = \sum_{ k = 0 }^n \left \{ \begin{array}{ c }
n \\ k\end{array} \right \} ( - 1 )^k ( - x )^{ \overline{ k } }
\\\)</span>.</p>
<p>不妨用<span class="math inline">\(x\)</span>来代替<span class="math inline">\(- x\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( - x )^n &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^k ( x )^{ \overline{ k } } \\
x^n &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^{ n - k } x^{ \overline{ k } }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><p><span class="math inline">\(x^{ \overline{ n } } = \sum_{ k = 0
}^n \left [ \begin{array}{ c } n \\ k\end{array} \right ] x^k
\\\)</span>.</p></li>
<li><p><span class="math inline">\(x^{ \underline{ n } } = \sum_{ k = 0
}^n \left [ \begin{array}{ c } n \\ k\end{array} \right ] ( - 1 )^{ n -
k } x^k \\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于<span class="math inline">\(( x + n - 1 ) x^k = x^{ k
+ 1 } + ( n - 1 ) x^k
\\\)</span>,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol start="4" type="1">
<li>反转公式:<span class="math inline">\(\sum_{ k = 0 }^n \left [
\begin{array}{ c } n \\ k\end{array} \right ] \left \{ \begin{array}{ c
} k \\ m\end{array} \right \} ( - 1 )^{ n - k } = \sum_{ k = 0 }^n \left
\{ \begin{array}{ c } n \\ k\end{array} \right \} \left [ \begin{array}{
c } k \\ m\end{array} \right ] ( - 1 )^{ n - k } = [ m = n ]
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑先证明后半部分,将(3)带入(1),得到<span class="math inline">\(x^n =
\sum_{ k = 0 }^n \left \{ \begin{array}{ c } n \\ k\end{array} \right \}
x^{ \underline{ k } } = \sum_{ k = 0 }^n \sum_{ m = 0 }^k \left \{
\begin{array}{ c } n \\ k\end{array} \right \} \left [ \begin{array}{ c
} k \\ m\end{array} \right ] ( - 1 )^{ n - k } x^m \\\)</span>.</p>
<p>由于这对任意<span class="math inline">\(x\)</span>都成立,因此右边除了<span class="math inline">\(x^n\)</span>以外的项系数均为<span class="math inline">\(0\)</span>,而<span class="math inline">\(x^n\)</span>的系数为<span class="math inline">\(1\)</span>.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n + 1 \\
m + 1\end{array} \right \} = \sum_{ k = m }^n \left ( \begin{array}{ c }
n \\ k\end{array} \right ) \left \{ \begin{array}{ c } k \\ m\end{array}
\right \} \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n + 1 \\ m
+ 1\end{array} \right ] = \sum_{ k = m }^n \left ( \begin{array}{ c } n
\\ k\end{array} \right ) \left [ \begin{array}{ c } k \\ m\end{array}
\right ] \\\)</span>.</p></li>
</ol>
<p>证明:对于前者,考虑组合意义,将<span class="math inline">\(n +
1\)</span>个分为<span class="math inline">\(m +
1\)</span>组,也就是先找一部分分成<span class="math inline">\(m\)</span>组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3>
<ol start="7" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n \\
m\end{array} \right \} = \sum_{ k = m }^n \left ( \begin{array}{ c } n
\\ k\end{array} \right ) \left \{ \begin{array}{ c } k + 1 \\ m +
1\end{array} \right \} ( - 1 )^{ n - k } \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n \\
m\end{array} \right ] = \sum_{ k = m }^n \left ( \begin{array}{ c } n \\
k\end{array} \right ) \left [ \begin{array}{ c } k + 1 \\ m +
1\end{array} \right ] ( - 1 )^{ n - k } \\\)</span>.</p></li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol start="9" type="1">
<li><span class="math inline">\(m ! \left \{ \begin{array}{ c } n \\
m\end{array} \right \} = \sum_{ k = 0 }^m C_m^k k^n ( - 1 )^{ m - k }
\\\)</span>.</li>
</ol>
<p>证明:首先有<span class="math inline">\(m^n = \sum_{ k = 0 }^m m^{
\underline{ k } } \left \{ \begin{array}{ c } m \\ k\end{array} \right
\} = \sum_{ k = 0 }^m k ! C_m^k \left \{ \begin{array}{ c } m \\
k\end{array} \right \} \\\)</span>,对这个式子进行二项式反演即可.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\left \{ \begin{array}{ c } n + 1 \\ m +
1\end{array} \right \} = \sum_{ k = 0 }^n \left \{ \begin{array}{ c } k
\\ m\end{array} \right \} ( m + 1 )^{ n - k } \\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前<span class="math inline">\(k\)</span>个分为<span class="math inline">\(m\)</span>组,把第<span class="math inline">\(k +
1\)</span>个数放到第<span class="math inline">\(m +
1\)</span>组.然后剩下<span class="math inline">\(( n + 1 ) - ( k + 1 ) =
n -
k\)</span>个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第<span class="math inline">\(m + 1\)</span>组(最小值最大的那组)在<span class="math inline">\(k\)</span>不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol start="11" type="1">
<li><span class="math inline">\(\left [ \begin{array}{ c } n + 1 \\ m +
1\end{array} \right ] = \sum_{ k = 0 }^n \left [ \begin{array}{ c } k \\
m\end{array} \right ] C_{ n }^k ( n - k ) ! = n ! \sum_{ k = 0 }^n
\frac{ \left [ \begin{array}{ c } k \\ m\end{array} \right ] }{ k ! }
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果<span class="math inline">\(n &gt;
0\)</span>,我们有<span class="math inline">\(\left [ \begin{array}{ c }
n \\ 1\end{array} \right ] = ( n - 1 ) !
\\\)</span>.这个式子很显然,我们现在有一个长度为<span class="math inline">\(n - 1\)</span>的环,想要往里插入第<span class="math inline">\(n\)</span>个数有<span class="math inline">\(n -
1\)</span>种选择,所以我们有:<span class="math inline">\(\left [
\begin{array}{ c } n \\ 1\end{array} \right ] = \left [ \begin{array}{ c
} n - 1 \\ 1\end{array} \right ] ( n - 1 )
\\\)</span>,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将<span class="math inline">\(n +
1\)</span>个数划分成<span class="math inline">\(m +
1\)</span>个环,我们先将其中<span class="math inline">\(k\)</span>个数划分成<span class="math inline">\(m\)</span>个环,剩下<span class="math inline">\(n +
1 -
k\)</span>个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第<span class="math inline">\(n +
1\)</span>个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于<span class="math inline">\(C_n^k ( n - k ) ! = C_n^{ n - k } (
n - k ) ! = n^{ \underline{ n - k } } = \frac{ n ! }{ k ! }
\\\)</span>.因此后半部分也得证.</p>
<ol start="12" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n + m + 1
\\ m\end{array} \right \} = \sum_{ k = 0 }^m k \left \{ \begin{array}{ c
} n + k \\ k\end{array} \right \} \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n + m + 1
\\ m\end{array} \right ] \sum_{ k = 0 }^m ( n + k ) \left [
\begin{array}{ c } n + k \\ k\end{array} \right ] \\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将<span class="math inline">\(n +
k\)</span>个位置分到<span class="math inline">\(k\)</span>个集合之后.还剩下<span class="math inline">\(( n + m + 1 ) - ( n + k ) = ( m - k + 1
)\)</span>个数,剩下<span class="math inline">\(( m - k
)\)</span>个集合.</p>
<p>拿出来<span class="math inline">\(( n + k + 1
)\)</span>这个数,剩下的数刚好够每个集合放一个.最后枚举一下把<span class="math inline">\(( n + k + 1
)\)</span>放在哪里即可.由于每个划分一定存在一段(可能是<span class="math inline">\(0\)</span>)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol start="14" type="1">
<li><span class="math inline">\(C_n^m ( n - 1 )^{ \underline{ n - m } }
= \sum_{ k = m }^n \left [ \begin{array}{ c } n \\ k\end{array} \right ]
\left \{ \begin{array}{ c } k \\ m\end{array} \right \}
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑<span class="math inline">\(( n - 1 )^{ \underline{ n - m } } =
\frac{ ( n - 1 ) ! }{ ( m - 1 ) ! } \\\)</span>,不妨设<span class="math inline">\(f ( n , m ) = \sum_{ k = m }^n \left [
\begin{array}{ c } n \\ k\end{array} \right ] \left \{ \begin{array}{ c
} k \\ m\end{array} \right \} \\\)</span>,相当于将<span class="math inline">\(n\)</span>个数分成非空<span class="math inline">\(m\)</span>组,然后组内的数要形成若干轮换的方案数.那么知道<span class="math inline">\(f ( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m )
f ( n - 1 , m ) \\\)</span>.</p>
<p>设<span class="math inline">\(g ( n , m ) = C_n^m \frac{ ( n - 1 ) !
}{ ( m - 1 ) ! } = \frac{ n ! ( n - 1 ) ! }{ m ! ( n - m ) ! ( m - 1 ) !
} \\\)</span>,那么知道:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n - 1 , m - 1 ) &amp; = \frac{ ( n - 1 ) ! ( n - 2 ) ! }{ ( m - 1 )
! ( n - m ) ! ( m - 2 ) ! } \\
g ( n - 1 , m ) &amp; = \frac{ ( n - 1 ) ! ( n - 2 ) ! }{ m ! ( n - 1 -
m ) ! ( m - 2 ) ! } \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然<span class="math inline">\(g ( n , m ) = g ( n - 1 , m - 1 ) + (
n - 1 + m ) g ( n - 1 , m ) \\\)</span>,数学归纳即可.</p>
<ol start="15" type="1">
<li><p><span class="math inline">\(C_n^m = \frac{ n ! }{ m ! ( n - m ) !
} = \sum_{ k = m }^n \left \{ \begin{array}{ c } n + 1 \\ k +
1\end{array} \right \} \left [ \begin{array}{ c } k \\ m\end{array}
\right ] ( - 1 )^{ m - k } \\\)</span>.</p></li>
<li><p><span class="math inline">\(n^{ \underline{ n - m } } = \frac{ n
! }{ m ! } = \sum_{ k = m }^n \left [ \begin{array}{ c } n + 1 \\ k +
1\end{array} \right ] \left \{ \begin{array}{ c } k \\ m\end{array}
\right \} ( - 1 )^{ m - k } ， 其 中 m \leq n \\\)</span>.</p></li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol start="17" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n \\ l +
m\end{array} \right \} C_{ l + m }^l = \sum_{ k = l }^n \left \{
\begin{array}{ c } k \\ l\end{array} \right \} \left \{ \begin{array}{ c
} n - k \\ m\end{array} \right \} C_n^k \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n \\ l +
m\end{array} \right ] C_{ l + m }^l = \sum_{ k = l }^n \left [
\begin{array}{ c } k \\ l\end{array} \right ] \left [ \begin{array}{ c }
n - k \\ m\end{array} \right ] C_n^k \\\)</span>.</p></li>
</ol>
<p>证明:先考虑前者,左边即先将<span class="math inline">\(n\)</span>个数分为<span class="math inline">\(l +
m\)</span>个集合,然后再挑出<span class="math inline">\(l\)</span>个集合.那不妨枚举这<span class="math inline">\(l\)</span>个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2>
<p>记<span class="math inline">\(\left \langle \begin{array}\\ n \\
k\end{array} \right \rangle\)</span>表示<span class="math inline">\(\{ 1
, 2 , . . . , n \}\)</span>的排列<span class="math inline">\(a\)</span>中满足这条性质的排列个数:存在且只存在<span class="math inline">\(k\)</span>个升高,换句话说,存在且只存在<span class="math inline">\(k\)</span>个<span class="math inline">\(i\)</span>,满足<span class="math inline">\(1 \leq
i &lt; n\)</span>,<span class="math inline">\(a_i &lt; a_{ i + 1
}\)</span>.不难发现<span class="math inline">\(\left \langle
\begin{array}\\ n \\ k\end{array} \right \rangle = \left \langle
\begin{array}\\ n \\ n - k - 1\end{array} \right \rangle\)</span>.</p>
<p>考虑在一个<span class="math inline">\(\{ 1 , 2 , . . . , n - 1
\}\)</span>的排列中插入<span class="math inline">\(n\)</span>,设插入的位置是原本<span class="math inline">\(a_i\)</span>的后面,那么要么原本<span class="math inline">\(a_i &lt; a_{ i + 1
}\)</span>,要么反之.前者不会改变排列的升高的数量,后者则会增加<span class="math inline">\(1\)</span>.另外还有一种情况是插入到了序列最前面.于是我们自然得到:<span class="math inline">\(\left \langle \begin{array}\\ n \\ k\end{array}
\right \rangle = ( k + 1 ) \left \langle \begin{array}\\ n - 1 \\
k\end{array} \right \rangle + ( n - k ) \left \langle \begin{array}\\ n
- 1 \\ k - 1\end{array} \right \rangle\)</span>.</p>
<p>特别地,我们令<span class="math inline">\(\left \langle
\begin{array}\\ 0 \\ k\end{array} \right \rangle = [ k = 0
]\)</span>,若<span class="math inline">\(k &lt; 0\)</span>,则<span class="math inline">\(\left \langle \begin{array}\\ n \\ k\end{array}
\right \rangle = 0\)</span>.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3>
<p>我们有Worpitzky恒等式:</p>
<p><span class="math display">\[
x^n = \sum_{ k \geq 0 } \binom{ x + k }{ n } \left \langle \begin{array}
\\
n \\
k
\end{array} \right \rangle , n \in \mathbb{ N }
\]</span></p>
<p>还有另一个恒等式:</p>
<p><span class="math display">\[
\left \langle \begin{array}
\\
n \\
m
\end{array} \right \rangle = \sum_{ k = 0 }^m \binom{ n + 1 }{ k } ( m +
1 - k )^n ( - 1 )^k
\]</span></p>
<p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2>
<p>定义<span class="math inline">\(B_j\)</span>为第<span class="math inline">\(j\)</span>个伯努利数,且满足<span class="math inline">\(\sum_{ j = 0 }^m \binom{ m + 1 }{ j } B_j = [ m =
0 ] , m \geq 0 \\\)</span>.</p>
<p>定义<span class="math inline">\(S_m ( n ) = \sum_{ i = 0 }^{ n - 1 }
i^m\)</span>.</p>
<p>伯努利数满足公式:<span class="math inline">\(S_m ( n ) = \cfrac{ 1 }{
m + 1 } \sum_{ k = 0 }^m \binom{ m + 1 }{ k } B_k n^{ m + 1 - k }
\\\)</span>.</p>
<p>证明如下:</p>
<p>对<span class="math inline">\(S_{ m + 1 } ( n
)\)</span>使用扰动法,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
S_{ m + 1 } ( n ) + n^{ m + 1 } &amp; = \sum_{ k = 0 }^{ n - 1 } ( k + 1
)^{ m + 1 } \\
&amp; = \sum_{ k = 0 }^{ n - 1 } \sum_{ j = 0 }^{ m + 1 } \binom{ m + 1
}{ j } k^j \\
&amp; = \sum_{ j = 0 }^{ m + 1 } \binom{ m + 1 }{ j } S_j ( n ) \\
&amp; = \sum_{ j = 0 }^{ m } \binom{ m + 1 }{ j } S_j ( n ) + S_{ m + 1
} ( n ) \\
n^{ m + 1 } &amp; = \sum_{ j = 0 }^m \binom{ m + 1 }{ j } S_j ( n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来使用数学归纳,假设<span class="math inline">\(0 \leq j &lt;
m\)</span>时该公式成立,并假设有<span class="math inline">\(S_m ( n ) =
\cfrac{ 1 }{ m + 1 } \sum_{ k = 0 }^m \binom{ m + 1 }{ k } B_k n^{ m + 1
- k } + \Delta \\\)</span>,我们只需要证明<span class="math inline">\(\Delta = 0\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
n^{ m + 1 } &amp; = \sum_{ j = 0 }^m \binom{ m + 1 }{ j } \cfrac{ 1 }{ j
+ 1 } \sum_{ k = 0 }^j \binom{ j + 1 }{ k } B_k n^{ j + 1 - k } + ( m +
1 ) \Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ k } \binom{ m +
1 }{ j } \cfrac{ 1 }{ j + 1 } B_k n^{ j + 1 - k } + ( m + 1 ) \Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ j - k } \binom{
m + 1 }{ j } \cfrac{ 1 }{ j + 1 } B_{ j - k } n^{ k + 1 } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ k + 1 } \binom{
m + 1 }{ j } \cfrac{ 1 }{ j + 1 } B_{ j - k } n^{ k + 1 } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq m } \cfrac{ n^{ k + 1 } }{ k + 1 } \sum_{ j
= k }^m B_{ j - k } \binom{ m + 1 }{ j } \binom{ j }{ k } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq m } \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{
m + 1 }{ k } \sum_{ j = k }^m B_{ j - k } \binom{ m + 1 - k }{ j - k } +
( m + 1 ) \Delta \\
&amp; = \sum_{ k = 0 }^m \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{ m + 1 }{
k } \sum_{ j = 0 }^{ m - k } B_{ j } \binom{ m + 1 - k }{ j } + ( m + 1
) \Delta \\
&amp; = \sum_{ k = 0 }^m \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{ m + 1 }{
k } [ m - k = 0 ] + ( m + 1 ) \Delta \\
&amp; = n^{ m + 1 } + ( m + 1 ) \Delta
\end{aligned}
\]</span></p>
<p>显然<span class="math inline">\(\Delta = 0\)</span>,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2>
<p>定义斐波那契数<span class="math inline">\(F_n = \begin{cases}0 &amp;
n = 0 \\ 1 &amp; n = 1 \\ F_{ n - 1 } + F_{ n - 2 } &amp; n &gt;
1\end{cases}\)</span>.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3>
<p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<p><span class="math display">\[
F_{ n + 1 } F_{ n - 1 } - F_n^2 = ( - 1 )^n , n &gt; 0
\]</span></p>
<p>事实上,如果我们将斐波那契数的递推式改写作:<span class="math inline">\(F_n = F_{ n + 2 } - F_{ n + 1
}\)</span>,我们可以在<span class="math inline">\(n \in \mathbb{ Z
}\)</span>的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<p><span class="math display">\[
F_{ - n } = ( - 1 )^{ n - 1 } F_n , n \in \mathbb{ Z }
\]</span></p>
<h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3>
<p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
F_{ n + k } &amp; = F_k F_{ n + 1 } + F_{ k - 1 } F_n \\
F_{ n + m + 1 } &amp; = F_{ n + 1 } F_{ m + 1 } + F_n F_m
\end{aligned}
\]</span></p>
<p>另外,如果我们在上面这个式子中取<span class="math inline">\(k = wn , w
\in \mathbb{ N }\)</span>并使用归纳法,我们又可以得到一个性质:<span class="math inline">\(F_{ kn }\)</span>是<span class="math inline">\(F_n\)</span>的倍数,<span class="math inline">\(k
\in \mathbb{ Z }\)</span>.</p>
<p>再观察这个式子,使用归纳法可以证明<span class="math inline">\(\gcd (
F_{ n } , F_{ n - 1 } ) = 1\)</span>,进一步有:<span class="math inline">\(\gcd ( F_{ n + m } , F_m ) = \gcd ( F_n , F_m
)\)</span>.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<p><span class="math display">\[
\gcd ( F_m , F_n ) = F_{ \gcd ( n , m ) }
\]</span></p>
<p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<p><span class="math display">\[
F_n^2 | F_m \Leftrightarrow nF_n | m , n &gt; 2
\]</span></p>
<p>这个引理的证明如下:</p>
<p>由于<span class="math inline">\(F_{ n + 1 } \equiv F_{ n - 1 } \pmod{
F_n }\)</span>.于是我们有:<span class="math inline">\(F_{ 2 n } = F_n
F_{ n + 1 } + F_{ n - 1 } F_n\)</span>,也就是<span class="math inline">\(F_{ 2 n } \equiv 2 F_n F_{ n + 1 } \pmod{ F_n^2
}\)</span>.</p>
<p>另外我们有:<span class="math inline">\(F_{ 2 n + 1 } \equiv F_{ n + 1
}^2 \pmod{ F_n^2 }\)</span>.</p>
<p>同理,使用归纳法可以证明:<span class="math inline">\(F_{ kn } \equiv
kF_n F_{ n + 1 }^{ k - 1 } \pmod{ F_n^2 } , F_{ kn + 1 } \equiv F_{ n +
1 }^k \pmod{ F_n^2 }\)</span>.</p>
<p>而<span class="math inline">\(F_{ n + 1 } \bot F_n\)</span>,于是<span class="math inline">\(F_{ kn } \equiv 0 \pmod{ F_n^2 } \Leftrightarrow k
\equiv 0 \pmod{ F_n } , n &gt; 2\)</span>.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3>
<p>我们如果定义<span class="math inline">\(j \gg k \Leftrightarrow j
\geq k + 2\)</span>,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:<span class="math inline">\(n =
\sum_{ i = 1 }^r F_{ k_i } , \forall 1 \leq i &lt; r , k_i \gg k_{ i + 1
} \gg 0\)</span>.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果<span class="math inline">\(\exists k\)</span>满足<span class="math inline">\(F_k = n\)</span>,则显然成立,不然,应<span class="math inline">\(\exists k\)</span>满足<span class="math inline">\(F_k &lt; n &lt; F_{ k + 1 }\)</span>,而<span class="math inline">\(n - F_k\)</span>的表示已经存在了.另外,由于<span class="math inline">\(n - F_k &lt; F_{ k + 1 } - F_k = F_{ k - 1
}\)</span>,因此必定不可能出现选了<span class="math inline">\(F_k\)</span>又选了<span class="math inline">\(F_{
k - 1 }\)</span>的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择<span class="math inline">\(F_k\)</span>而是选择<span class="math inline">\(F_{ k - 1
}\)</span>,那么显然接下来无论怎么选,它们的加和都不可能大于等于<span class="math inline">\(F_k\)</span>,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数<span class="math inline">\(n\)</span>以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3>
<p>使用生成函数,令<span class="math inline">\(F ( z ) = \sum_{ k \geq 0
} F_k z^k\)</span>.那么不难发现<span class="math inline">\(F ( z ) - zF
( z ) - z^2 F ( z ) = z\)</span>,也就是<span class="math inline">\(F ( z
) = \cfrac{ z }{ 1 - z - z^2 }\)</span>.</p>
<p>考虑这个形式一定可以分解为<span class="math inline">\(F ( z ) =
\cfrac{ a }{ 1 - \alpha z } + \cfrac{ b }{ 1 - \beta z
}\)</span>的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令<span class="math inline">\(\phi = \cfrac{ 1 +
\sqrt{ 5 } }{ 2 } , \hat \phi = \cfrac{ 1 - \sqrt{ 5 } }{ 2
}\)</span>,那么可以得到<span class="math inline">\(F_n = \cfrac{ 1 }{
\sqrt{ 5 } } ( \phi^n - \hat \phi^n )\)</span>.</p>
<p>另外,由于<span class="math inline">\(\hat
\phi^n\)</span>的影响很小,于是又有<span class="math inline">\(F_n =
\lfloor \cfrac{ \phi^n }{ \sqrt{ 5 } } + 0 . 5 \rfloor\)</span>.</p>
<h3><span id="连项式">连项式</span></h3>
<p>连项式多项式<span class="math inline">\(K_n ( x_1 , x_2 , . . . , x_n
)\)</span>定义为:<span class="math inline">\(K_n ( x_1 , x_2 , . . . ,
x_n ) = \begin{cases}1 &amp; n = 0 \\ x_1 &amp; n = 1 \\ x_n K_{ n - 1 }
( x_1 , x_2 , . . . x_{ n - 1 } ) + K_{ n - 2 } ( x_1 , x_2 , . . . ,
x_{ n - 2 } ) &amp; n \geq 2\end{cases}\)</span>.</p>
<p>通过定义不难发现:<span class="math inline">\(K_n ( 1 , 1 , . . . , 1
) = F_{ n + 1 }\)</span>.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数<span class="math inline">\(( x_{ n - 1 } , x_n
)\)</span>.我们考虑用这样一种形式的字符串来表示最后某一项的情况:‘.’为还没有消除掉的项,长度为<span class="math inline">\(1\)</span>;’-‘为已经消除了的两项,长度为<span class="math inline">\(2\)</span>.那么<span class="math inline">\(K_n (
x_1 , x_2 , . . . , x_n )\)</span>就可以表示为一个长度为<span class="math inline">\(n\)</span>的字符串,其中若有<span class="math inline">\(k\)</span>个’-‘,有<span class="math inline">\(n -
2 k\)</span>个’.’,则有<span class="math inline">\(\binom{ n - k }{ k
}\)</span>种不同的排列方式.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
K_n ( z , z , . . . , z ) &amp; = \sum_{ k = 0 }^n \binom{ n - k }{ k }
z^{ n - 2 k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,这也导出:<span class="math inline">\(F_{ n + 1 } = \sum_{ k = 0
}^n \binom{ n - k }{ k } \\\)</span>.</p>
<p>考虑上面的构造过程,不难发现<span class="math inline">\(K_n ( x_1 ,
x_2 , . . . , x_n ) = K_n ( x_n , x_{ n - 1 } , . . . , x_1
)\)</span>.</p>
<p>于是递归式可以写成:<span class="math inline">\(K_n ( x_1 , x_2 , . .
. , x_n ) = x_1 K_{ n - 1 } ( x_2 , x_3 , . . . x_{ n } ) + K_{ n - 2 }
( x_3 , x_4 , . . . , x_{ n } )\)</span>.</p>
<p>进一步地,不断展开后得到:</p>
<p><span class="math display">\[
\begin{aligned}
K_{ m + n } ( x_1 , . . . , x_m , x_{ m + 1 } , . . . , x_{ n + m } )
&amp; = \\
K_m ( x_1 , . . . , x_m ) K_n ( x_{ m + 1 } , . . . , x_{ n + m } ) +
K_{ m - 1 } ( x_1 , . . . , x_{ m - 1 } ) K_{ n - 1 } ( x_{ m + 2 } , .
. . , x_{ n + m } )
\end{aligned}
\]</span></p>
<p>另外,根据连项式的定义,不难导出<span class="math inline">\(K_n ( x_1 ,
. . . , x_n + y ) = K_n ( x_1 , . . . , x_n ) + K_{ n - 1 } ( x_1 , . .
. , x_{ n - 1 } ) y\)</span>.</p>
<p>由这个公式可以推出:<span class="math inline">\(\cfrac{ K_{ n + 1 } (
a_0 , . . . , a_n ) }{ K_n ( a_1 , . . . , a_n ) } = \cfrac{ K_n ( a_0 ,
. . . , a_{ n - 1 } + \cfrac{ 1 }{ a_n } ) }{ K_{ n - 1 } ( a_1 , . . .
, a_{ n - 1 } + \cfrac{ 1 }{ a_n } ) }\)</span>.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<p><span class="math display">\[
\cfrac{ K_{ n + 1 } ( a_0 , . . . , a_n ) }{ K_n ( a_1 , . . . , a_n ) }
= a_0 + \cfrac{ 1 }{ a_1 + \cfrac{ 1 }{ a_2 + \cfrac{ 1 }{ a_3 + . . . }
} }
\]</span></p>
<p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" class="post-title-link" itemprop="url">简单乐理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="前言">前言</span></h3>
<p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3>
<h4><span id="拍音理论">拍音理论</span></h4>
<p>假设两个正弦单音的频率分别是<span class="math inline">\(\omega ,
\omega + \delta\)</span>,那么它们叠加后是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
= &amp; 2 \sin \left ( 2 \pi ( \omega + \frac{ \delta }{ 2 } ) t \right
) \cos ( \pi \delta t )
\end{aligned}
\]</span></p>
<p>注意到这个声音受到<span class="math inline">\(\cos ( \pi \delta t
)\)</span>的控制.因此会以<span class="math inline">\(\frac{ \delta }{ 2
}\)</span>的频率振动,由于<span class="math inline">\(\delta\)</span>应该远小于<span class="math inline">\(\omega\)</span>,这里就会产生<span class="math inline">\(\delta = | \omega_1 - \omega_2
|\)</span>个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4>
<p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol type="1">
<li><p>弦长<span class="math inline">\(L\)</span>.</p></li>
<li><p>张力<span class="math inline">\(T\)</span>.</p></li>
<li><p>线密度<span class="math inline">\(\rho\)</span>.</p></li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点<span class="math inline">\(u ( x , t )\)</span>,首先是一维振动方程:</p>
<p><span class="math display">\[
\frac{ \partial^2 u }{ \partial x^2 } = \frac{ \rho }{ T } \frac{
\partial^2 u }{ \partial t^2 }
\]</span></p>
<p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<p><span class="math display">\[
u_n ( x , t ) = c_n \sin ( \omega_n t + \theta_n ) \sin ( \frac{ n \pi
}{ L } x )
\]</span></p>
<p>其中第<span class="math inline">\(n\)</span>项的频率满足:</p>
<p><span class="math display">\[
f_n = \frac{ n }{ 2 L } \sqrt{ \frac{ T }{ \rho } }
\]</span></p>
<p>其中我们将<span class="math inline">\(f_1\)</span>称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中<span class="math inline">\(f_n , n \geq 2\)</span>对应的是第<span class="math inline">\(n - 1\)</span>泛音.</p>
<p>特别地,如果我们干脆记<span class="math inline">\(f =
f_1\)</span>,上述结果告诉我们弦的振动产生的一列频率是:</p>
<p><span class="math display">\[
f , 2 f , 3 f , \cdots
\]</span></p>
<p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的<span class="math inline">\(n\)</span>,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0"></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的<span class="math inline">\(f_{ 2 k + 1 }\)</span>,泛音列中只剩下<span class="math inline">\(2 f , 4 f ,
\cdots\)</span>.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按<span class="math inline">\(\frac{ 1 }{ 3
}\)</span>处呢?那泛音列中就会只剩下<span class="math inline">\(3 f , 6 f
, 9 f , \cdots\)</span>,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是<span class="math inline">\(f , 3 f , 5 f , \cdots\)</span>.</p>
<h4><span id="管乐器">管乐器</span></h4>
<p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<p><span class="math display">\[
f , 2 f , 3 f , 4 f , \cdots
\]</span></p>
<p>闭管的泛音列:</p>
<p><span class="math display">\[
f , 3 f , 5 f , 7 f
\]</span></p>
<p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4>
<p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots
\end{gathered}
\]</span></p>
<p>或是:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac{ 3 }{ 2 } f , 3 f , \frac{ 9 }{ 2 } f , 6 f , \cdots
\end{gathered}
\]</span></p>
<p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3>
<p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是<span class="math inline">\(L_p = 20 \log_{ 10 } ( \frac{ p }{ p_0 }
)\)</span>,其中<span class="math inline">\(p_0 = 20 \mu Pa\)</span>.</p>
<h4><span id="音程">音程</span></h4>
<p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<div class="line-block">度数 | 半音数 | 名称 |</div>
<div class="line-block">—- | —— | —— |</div>
<div class="line-block">一 | 0 | 纯一度 |</div>
<div class="line-block">二 | 1 | 小二度 |</div>
<div class="line-block">二 | 2 | 大二度 |</div>
<div class="line-block">三 | 3 | 小三度 |</div>
<div class="line-block">三 | 4 | 大三度 |</div>
<div class="line-block">四 | 5 | 纯四度 |</div>
<div class="line-block">四 | 6 | 增四度 |</div>
<div class="line-block">五 | 6 | 减五度 |</div>
<div class="line-block">五 | 7 | 纯五度 |</div>
<div class="line-block">六 | 8 | 小六度 |</div>
<div class="line-block">六 | 9 | 大六度 |</div>
<div class="line-block">七 | 10 | 小七度 |</div>
<div class="line-block">七 | 11 | 大七度 |</div>
<div class="line-block">八 | 12 | 纯八度 |</div>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<div class="line-block">音程 | 频率比 |</div>
<div class="line-block">—— | —— |</div>
<div class="line-block">纯八度 | <span class="math inline">\(2 :
1\)</span> |</div>
<div class="line-block">纯五度 | <span class="math inline">\(3 :
2\)</span> |</div>
<div class="line-block">纯四度 | <span class="math inline">\(4 :
3\)</span> |</div>
<div class="line-block">大三度 | <span class="math inline">\(5 :
4\)</span> |</div>
<div class="line-block">小三度 | <span class="math inline">\(6 :
5\)</span> |</div>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4>
<p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定<span class="math inline">\(C\)</span>的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为<span class="math inline">\(1\)</span>,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求<span class="math inline">\(\{ 7 k \} \pmod{ 12
}\)</span>这个数列对吧,简单数论知识告诉我们它必然能遍历<span class="math inline">\(12\)</span>种情况,具体而言:</p>
$$
<span class="math display">\[\begin{aligned}
C \to &amp; &amp; G \to &amp; &amp; D \to &amp; &amp; A \to &amp; &amp;
E \to &amp; &amp; B \to \\
1 \to &amp; &amp; \frac{ 3 }{ 2 } \to &amp; &amp; \frac{ 3^2 }{ 2^3 }
\to &amp; &amp; \frac{ 3^3 }{ 2^4 } \to &amp; &amp; \frac{ 3^4 }{ 2^6 }
\to &amp; &amp; \frac{ 3^5 }{ 2^7 } \to \\
\\
\\
\# F \to &amp; &amp; \# C \to &amp; &amp; \# G \to &amp; &amp; \# D \to
&amp; &amp; \# A \to &amp; &amp; \# E \\
\frac{ 3^6 }{ 2^9 } \to &amp; &amp; \frac{ 3^7 }{ 2^{ 11 } } \to &amp;
&amp; \frac{ 3^8 }{ 2^{ 12 } } \to &amp; &amp; \frac{ 3^9 }{ 2^{ 14 } }
\to &amp; &amp; \frac{ 3^{ 10 } }{ 2^{ 15 } } \to &amp; &amp; \frac{ 3^{
11 } }{ 2^{ 17 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度<span class="math inline">\(CE\)</span>的比是<span class="math inline">\(\frac{ 81 }{ 64 } &gt; \frac{ 80 }{ 64 } = \frac{
5 }{ 4 }\)</span>.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的<span class="math inline">\(\# E \ne F\)</span>,你对着这个<span class="math inline">\(\# E\)</span>往上再升一个音得到的理应是<span class="math inline">\(C &#39; = \frac{ 3^{ 12 } }{ 2^{ 18 } } &gt;
2\)</span>,具体来说<span class="math inline">\(\frac{ 3^{ 12 } }{ 2^{ 19
} } \approx 1 .
013643\)</span>,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于<span class="math inline">\(1\)</span>的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升<span class="math inline">\(12\)</span>个纯五度,再下降<span class="math inline">\(7\)</span>个纯八度理应回到原点,可是:</p>
<p><span class="math display">\[
( \frac{ 3 }{ 2 } )^{ 12 } \times ( \frac{ 1 }{ 2 } )^7 &gt; 1
\]</span></p>
<p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4>
<p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定<span class="math inline">\(C\)</span>的频率为<span class="math inline">\(1\)</span>.接下来用正三和弦(一个大三度和一个小三度)<span class="math inline">\(I : C - E - G\)</span>,<span class="math inline">\(IV : F - A - C &#39;\)</span>,<span class="math inline">\(V : G - B - D &#39;\)</span>的比例是<span class="math inline">\(4 : 5 : 6\)</span>确定剩下的:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; &amp; D &amp; &amp; E &amp; &amp; F &amp; &amp; G &amp; &amp; A
&amp; &amp; B &amp; &amp; C &#39; &amp; &amp; D &#39; \\
1 &amp; &amp; \frac{ 9 }{ 8 } &amp; &amp; \frac{ 5 }{ 4 } &amp; &amp;
\frac{ 4 }{ 3 } &amp; &amp; \frac{ 3 }{ 2 } &amp; &amp; \frac{ 5 }{ 3 }
&amp; &amp; \frac{ 15 }{ 8 } &amp; &amp; 2 &amp; &amp; \frac{ 9 }{ 4 }
\end{aligned}
\]</span></p>
<p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol type="1">
<li><p>五度音程<span class="math inline">\(D -
A\)</span>不协和,比例为<span class="math inline">\(\frac{ 80 }{ 54 }
&lt; \frac{ 81 }{ 54 } = \frac{ 3 }{ 2
}\)</span>.这直接导致了转调会出错.</p></li>
<li><p>有两种不同的大二度:音程<span class="math inline">\(C - D , F - G
, A - B\)</span>的比例是<span class="math inline">\(\frac{ 9 }{ 8
}\)</span>而音程<span class="math inline">\(D - E , G -
A\)</span>的比例为<span class="math inline">\(\frac{ 10 }{ 9
}\)</span>.</p></li>
<li><p><strong>谐调音差</strong>:从<span class="math inline">\(C\)</span>出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:<span class="math inline">\(( \frac{ 3 }{ 2 } )^4 \times ( \frac{ 1 }{ 2 } )^2
\times \frac{ 4 }{ 5 } = \frac{ 81 }{ 80 } = 1 . 0125 &gt;
1\)</span>.</p></li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4>
<p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用<span class="math inline">\(\sqrt[12]{ 2
}\)</span>来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是<span class="math inline">\(f_1 , f_2\)</span>,则它们的音分数定义为<span class="math inline">\(1200 \log_2 ( \frac{ f_2 }{ f_1 }
)\)</span>,容易见到十二平均律拿到的一个半音恰好是<span class="math inline">\(100\)</span>音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3>
<h4><span id="大小调">大小调</span></h4>
<h5><span id="自然大调">自然大调</span></h5>
<p>就是我们最常用的<span class="math inline">\(CDEFGABC
&#39;\)</span>,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol type="1">
<li><p>主音</p></li>
<li><p>上主音</p></li>
<li><p>中音</p></li>
<li><p>下属音</p></li>
<li><p>属音</p></li>
<li><p>下中音</p></li>
<li><p>导音</p></li>
</ol>
<p>用五度相生,下属音<span class="math inline">\(\rightarrow\)</span>主音<span class="math inline">\(\rightarrow\)</span>属音.</p>
<h5><span id="自然小调">自然小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以<span class="math inline">\(ABCDEFG\)</span>用的调子,然而这里的问题是<span class="math inline">\(G\)</span>作为导音却和<span class="math inline">\(A &#39;\)</span>差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用<span class="math inline">\(A , B , C
, D , E , F , (^\# G )\)</span>.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用<span class="math inline">\(A , B , C
, D , E , (^\# F ) , (^\# G )\)</span>.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4>
<p>以五度相生:</p>
<p><span class="math display">\[
C \to G \to D \to A \to E \to B \to (^\# F ) \to (^\# C )
\]</span></p>
<p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从<span class="math inline">\(C\)</span>开始每次往后跳一次都要在一个音阶上增一个升号.从<span class="math inline">\(C\)</span>大调提升到<span class="math inline">\(G\)</span>大调的时候就是将<span class="math inline">\(C\)</span>的下属音(也就是<span class="math inline">\(F\)</span>)升音.</p>
<p>对称地,反方向的五度相生:</p>
<p><span class="math display">\[
C \to F \to (^b B ) \to (^b E ) \to (^b A ) \to (^b D ) \to (^b G ) \to
(^b C )
\]</span></p>
<p>那这个应该降什么呢?比如从<span class="math inline">\(C\)</span>大调提升到<span class="math inline">\(F\)</span>大调的时候就是将<span class="math inline">\(F\)</span>的下属音<span class="math inline">\(B\)</span>降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png"></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3>
<h4><span id="三和弦">三和弦</span></h4>
<p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol type="1">
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成<span class="math inline">\(4 : 5 : 6\)</span>的频率关系.</p></li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p></li>
<li><p>减三和弦:两个小三度.</p></li>
<li><p>增三和弦:两个大三度.</p></li>
</ol>
<h4><span id="七和弦">七和弦</span></h4>
<p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol type="1">
<li><p>减减七和弦(减七和弦):小小小.</p></li>
<li><p>减小七和弦(半减七和弦):小小大.</p></li>
<li><p>小小七和弦(小七和弦):小大小.</p></li>
<li><p>小大七和弦:小大大.</p></li>
<li><p>大小七和弦(属七和弦):大小小.</p></li>
<li><p>大大七和弦(大七和弦):大小大.</p></li>
<li><p>增大七和弦:大大小.</p></li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4>
<p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p></li>
</ol>
<p>对于七和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p></li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p></li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4>
<p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为<span class="math inline">\(C - E - G\)</span>,<span class="math inline">\(F -
A - C &#39;\)</span>,<span class="math inline">\(G - B - D
&#39;\)</span>.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol type="1">
<li><p>正格进行:<span class="math inline">\(I \to V \to
I\)</span>.</p></li>
<li><p>变格进行:<span class="math inline">\(I \to IV \to
I\)</span>.</p></li>
<li><p>复式进行:<span class="math inline">\(I \to IV \to V \to
I\)</span>.</p></li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<p><span class="math display">\[
\xymatrix{ &amp; &amp; &amp; &amp; I \\
&amp; &amp; IV \ar[r] \ar[d] \ar[dr] \ar[rru] &amp; vii \degree \ar[ru]
&amp; \\
iii \ar[r] &amp; vi \ar[r] \ar[ru] &amp; ii \ar[r] \ar[ru] &amp; V
\ar[ruu] &amp; }
\]</span></p>
<p>其中<span class="math inline">\(I\)</span>较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4>
<p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol type="1">
<li><p>平行变换<span class="math inline">\(P\)</span>:保持纯五度音阶不变,将三音切换.</p></li>
<li><p>关系变换<span class="math inline">\(R\)</span>:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p></li>
<li><p>导音变换<span class="math inline">\(L\)</span>:保持小三度音阶不变,补上剩下的一个.</p></li>
</ol>
<p>容易见到<span class="math inline">\(R \circ ( L \circ R )^3 =
P\)</span>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">随机算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-26 10:17:13" itemprop="dateModified" datetime="2025-09-26T10:17:13+08:00">2025-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2>
<h3><span id="基本分析">基本分析</span></h3>
<h4><span id="union-bound">Union Bound</span></h4>
<p>即:<span class="math inline">\(Pr [ \bigcup_i X_i ] \leq \sum Pr [
X_i ]\)</span>,取等当且仅当所有<span class="math inline">\(X_i\)</span>互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4>
<p>若<span class="math inline">\(X \geq 0\)</span>,则<span class="math inline">\(Pr [ X \geq t \mathbb{ E } [ X ] ] \leq \frac{ 1
}{ t }\)</span>.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6>
<p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有<span class="math inline">\(\frac{ 1 }{
2 }\)</span>的概率是割边,因此期望自然是<span class="math inline">\(\frac{ 1 }{ 2 } | E | \geq \frac{ 1 }{ 2 } |
\text{ max - cut } |\)</span>.</p>
<p>由此立即见到,<span class="math inline">\(Pr [ | ans | \leq ( \frac{ 1
}{ 2 } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac{ 1 }{ 2
} + \epsilon ) | E | ] \leq \frac{ 1 }{ 1 + 2 \epsilon }\)</span>.</p>
<p>由于每次独立操作,因此如果有<span class="math inline">\(P\)</span>的概率失败,那么运行<span class="math inline">\(T\)</span>次后至少成功一次的概率应当为<span class="math inline">\(1 - P^T\)</span>.从而<span class="math inline">\(T
= O ( \log_P{ \delta } ) = O ( \cfrac{ \ln \frac{ 1 }{ \delta } }{ \ln (
1 +{ 2 \epsilon } ) } ) \approx O ( \cfrac{ \ln \frac{ 1 }{ \delta } }{
\epsilon } )\)</span>即可拿到<span class="math inline">\(\delta\)</span>失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>设<span class="math inline">\(X_1 , \cdots , X_n \in [ 0 , 1
]\)</span>是独立,同期望(期望为<span class="math inline">\(\mu \geq
t\)</span>)的随机变量,令<span class="math inline">\(X = \frac{ \sum_k
X_k }{ n }\)</span>,对于任何失败概率<span class="math inline">\(\delta
\in ( 0 , 1 )\)</span>,应当有:</p>
<p><span class="math display">\[
Pr \left [ | X - \mu | \geq \sqrt{ \cfrac{ \log ( 1 / \delta ) }{ nt } }
\mu \right ] \leq \delta
\]</span></p>
<h6><span id="examplemedian-trick">Example(Median Trick)</span></h6>
<p>现在有一个黑盒能够以<span class="math inline">\(p &gt; \frac{ 1 }{ 2
}\)</span>的概率正确回答Yes或者No,问重复<span class="math inline">\(T\)</span>选多少次能拿到<span class="math inline">\(1 - \delta\)</span>的成功概率.</p>
<p>考虑重复<span class="math inline">\(T\)</span>次后应当有期望<span class="math inline">\(pT\)</span>个正确答案,因此直接取中位数.称此算法为Median
Trick.</p>
<p>Chernoff Bound 告诉我们<span class="math inline">\(T = O ( \log
\frac{ 1 }{ \delta } )\)</span>足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4>
<p>设独立随机变量<span class="math inline">\(x_1 , \cdots , x_m \in [ s
, t ]\)</span>,令<span class="math inline">\(X = \sum_i
x_i\)</span>,则:</p>
<p><span class="math display">\[
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac{ 2 z^2 }{ m ( t -
s )^2 } \right )
\]</span></p>
<h3><span id="编程中的随机性">编程中的随机性</span></h3>
<p>一般采用伪随机,也即是给定初值<span class="math inline">\(X_0\)</span>,通过某个确定性的函数来生成<span class="math inline">\(X_{ n + 1 } = f ( X_n )\)</span>这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1 - ( 1 - p )^k\)</span>,时间复杂度为<span class="math inline">\(O ( kf ( n ) )\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为<span class="math inline">\(O ( f ( n ) g ( n
) )\)</span>,其中<span class="math inline">\(f ( n
)\)</span>为枚举部分的复杂度,<span class="math inline">\(g ( n
)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g ( n )\)</span>不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n \leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O ( n^3 )\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil \frac{ n }{ 7 }
\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{ 1 }{ 7
}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{ 1 }{ 49 }\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1 - ( \frac{ 48 }{ 49 } )^{ 1000
}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{ n }{ 2
}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n \leq
10^6\)</span>,<span class="math inline">\(a_i \leq 10^{ 12
}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O ( n \sqrt{ a } )\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt{ a
}\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([ l , r ]\)</span>,问<span class="math inline">\(a
[ l , r
]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\(( n , m \leq 500000 , 1 \leq a_i \leq n
)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k = 2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O ( n^2 d )\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A = \begin{bmatrix}\vec{ a_1 } , \vec{ a_2 } , . .
. , \vec{ a_n }\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B =
AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{ i , j }\)</span>在<span class="math inline">\(\mod 2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B =
C\)</span>,那么对于任意一个<span class="math inline">\(X_{ m \times n
}\)</span>都应该满足<span class="math inline">\(XB = XC\)</span>,取<span class="math inline">\(m =
1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB \ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O ( nd )\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O ( n
)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D = B -
C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{ i , j } \ne 0\)</span>.我们令<span class="math inline">\(E = X \times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j = \sum_{ k } X_k D_{ k , j
}\)</span>,不难解得:<span class="math inline">\(E_i = - \frac{ 1 }{ D_{
i , j } } \sum_{ k \ne i } X_k D_{ k , j }\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O ( nd )\)</span>.</p>
<p><span class="math inline">\(k = 3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{
j } B_{ i , j }^2 X_j = \sum_{ j } B_{ i , j } X_j B_{ h , i
}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T ( n )\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要<span class="math inline">\(+
1\)</span>或者<span class="math inline">\(-
1\)</span>或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ n - 1 } ( T_i
+ T_{ n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ \frac{ 3 n }{
4 } } ( T ( i ) + T ( n - i - 1 ) ) + \frac{ 2 }{ n } \sum_{ i = \frac{
3 n }{ 4 } }^{ n } ( T ( i ) + T ( n - i - 1 ) )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(T ( n ) \geq n\)</span>,所以对于<span class="math inline">\(\frac{ n }{ 2 } \leq i \leq
j\)</span>,我们显然有:<span class="math inline">\(T ( i ) + T ( n - i )
\leq T ( j ) + T ( n - j )\)</span>.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{
\frac{ 3 n }{ 4 } } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n }{ 4 } ) )
+ \frac{ 2 }{ n } \sum_{ i = \frac{ 3 n }{ 4 } }^{ n } ( T ( n - 1 ) + T
( 0 ) ) \\
&amp; \leq n + \frac{ 1 }{ 2 } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n
}{ 4 } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T ( n ) \leq cn \log
n\)</span>,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 1 }{ 2 } ( \frac{ 3 cn }{ 4 } \log (
\frac{ 3 n }{ 4 } ) + \frac{ cn }{ 4 } \log ( \frac{ n }{ 4 } ) + c ( n
- 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac{ 3 n }{ 8 } \log n - \frac{ 3 n }{ 8 } \log
\frac{ 4 }{ 3 } + \frac{ n }{ 8 } \log n - \frac{ n }{ 4 } + \frac{ n }{
2 } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac{ 3 c }{ 8 } \log ( \frac{ 4 }{ 3 } ) -
\frac{ c }{ 4 } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^{ i - 1 } i \\
( 1 - p ) k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^i i \\
pk &amp; = \sum_{ i = 2 }^{ \infty } p ( 1 - p )^{ i - 1 } = p \sum_{ i
= 0 }^{ \infty } ( 1 - p )^i \\
k &amp; = \frac{ 1 }{ p }
\end{aligned}
\]</span></p>
<p>则期望复杂度为<span class="math inline">\(O ( \frac{ f ( n ) }{ p }
)\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([ x_1 , x_2 )\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1 \times 2 \leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>),而此时的<span class="math inline">\([ x_1 , x_2
)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1 , 2 , 4 , . .
.\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E_{ t + 1 } &gt; E_t \\
e^{ \frac{ E_{ t + 1 } - E_t }{ T } } &amp; E_{ t + 1 } \leq E_t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k
\in ( 0 , 1 )\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T = kT\)</span>,直到其小于终止温度.</p>
<h3><span id="数据随机下的性质">数据随机下的性质</span></h3>
<h4><span id="树">树</span></h4>
<ol type="1">
<li><p>随机树树高为<span class="math inline">\(\sqrt{ n
}\)</span>.</p></li>
<li><p>点的度数期望为<span class="math inline">\(\log
n\)</span>.</p></li>
</ol>
<h4><span id="数">数</span></h4>
<ol type="1">
<li>数字的期望因数个数为<span class="math inline">\(\log
V\)</span>.</li>
</ol>
<h4><span id="序列">序列</span></h4>
<ol type="1">
<li>随机序列的LIS长度期望为<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-19 21:00:45" itemprop="dateModified" datetime="2025-12-19T21:00:45+08:00">2025-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间<span class="math inline">\(\Omega\)</span>:在一个给定问题中可能发生的所有情况.</p>
<p>事件:<span class="math inline">\(\Omega\)</span>的一个子集.</p>
<p>基本事件<span class="math inline">\(\omega\)</span>:<span class="math inline">\(\Omega\)</span>中的单个元素,也可以看作集合大小为<span class="math inline">\(1\)</span>的事件.</p>
<p>概率:若<span class="math inline">\(\omega \in
\Omega\)</span>,我们称它发生的概率为<span class="math inline">\(\Pr (
\omega )\)</span>,有<span class="math inline">\(\Pr ( \omega ) \geq
0\)</span>且<span class="math inline">\(\sum_{ \omega \in \Omega } \Pr (
\omega ) = 1\)</span>.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>定义在同一个概率空间<span class="math inline">\(\Omega\)</span>上,对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,我们称<span class="math inline">\(\Pr (
X = x \land Y = y )\)</span>为它们的联合分布.</p>
<p>独立:如果对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,<span class="math inline">\(\Pr ( X = x
\land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y )\)</span>,我们称<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是独立的.</p>
<p>期望(均值)<span class="math inline">\(E
X\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的期望<span class="math inline">\(EX =
\sum_{ x \in X ( \Omega ) } x \times \Pr ( X = x ) = \sum_{ w \in \Omega
} X ( \omega ) \Pr ( \omega )\)</span>.</p>
<p>中位数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的中位数为满足<span class="math inline">\(\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x )
\geq 0 . 5\)</span>的<span class="math inline">\(x \in X ( \Omega
)\)</span>所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的众数为满足<span class="math inline">\(\Pr ( X = x ) \geq \Pr ( X = x &#39; ) , \forall x
&#39; \in X ( \Omega )\)</span>的<span class="math inline">\(x \in X (
\Omega )\)</span>所组成的集合.</p>
<p>方差<span class="math inline">\(VX\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的方差<span class="math inline">\(VX = E
( ( X - EX )^2 )\)</span>.</p>
<p>标准差<span class="math inline">\(\sigma\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的标准差<span class="math inline">\(\sigma = \sqrt{ VX }\)</span>.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果<span class="math inline">\(X ,
Y\)</span>是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><p><span class="math inline">\(E ( X + Y ) = EX +
EY\)</span>.</p></li>
<li><p><span class="math inline">\(E ( \alpha X ) = \alpha
EX\)</span>.</p></li>
<li><p>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>互相独立,那么<span class="math inline">\(E ( XY ) = ( EX ) ( EY )\)</span>.</p></li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<p>此外(3)的逆命题不成立.考虑取<span class="math inline">\(X\)</span>分别以<span class="math inline">\(\frac{1}{2}\)</span>的概率选取<span class="math inline">\(-1\)</span>和<span class="math inline">\(1\)</span>,取<span class="math inline">\(Y=X^2\)</span>,则<span class="math inline">\(E(X)=E(XY)=0\)</span>.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X - EX )^2 ) &amp; = E ( X^2 - 2 X ( EX ) + ( EX )^2 ) \\
&amp; = E ( X^2 ) - 2 ( EX ) ( EX ) + ( EX )^2 \\
&amp; = E ( X^2 ) - ( EX )^2
\end{aligned}
\]</span></p>
<p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为独立的随机变量时,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( ( X + Y )^2 ) - ( EX + EY )^2 \\
&amp; = E ( ( X + Y )^2 ) - ( EX )^2 - 2 ( EX ) ( EY ) - ( EY )^2
\end{aligned}
\]</span></p>
<p>而又有:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X + Y )^2 ) &amp; = E ( X^2 + 2 XY + Y^2 ) \\
&amp; = E ( X^2 ) + 2 ( EX ) ( EY ) + E ( Y^2 )
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( X^2 ) + 2 ( EX ) ( EY ) + E ( Y^2 ) - ( EX )^2 -
2 ( EX ) ( EY ) - ( EY )^2 \\
&amp; = VX + VY
\end{aligned}
\]</span></p>
<p>即:独立随机变量之和的方差等于它们的方差之和.此外显然也有<span class="math inline">\(\mathrm{Var}(X-Y)=\mathrm{Var}(X)+\mathrm{Var}(Y)\)</span>.</p>
<p>事实上,容易见到可以定义协方差<span class="math inline">\(\mathrm{Cov}(X,Y)=E(XY)-E(X)E(Y)\)</span>.容易见到以下性质:</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{Cov}(X,X)=\mathrm{Var}(X)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(X,Y)=\mathrm{Cov}(Y,X)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(aX,bY)=ab\mathrm{Cov}(X,Y)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(X_1+X_2,Y)=\mathrm{Cov}(X_1,Y)+\mathrm{Cov}(X_2,Y)\)</span>.</li>
<li>若<span class="math inline">\(X,Y\)</span>相互独立,则<span class="math inline">\(\mathrm{Cov}(X,Y)=0\)</span>.然而逆命题不成立.</li>
<li><span class="math inline">\(\mathrm{Var}(\sum_{i}X_i)=\sum_{i}\sum_j\mathrm{Cov}(X_i,X_j)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Var}(X+Y)=\mathrm{Var}(X)+\mathrm{Var}(Y)+2\mathrm{Cov}(X,Y)\)</span>.</li>
</ol>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了<span class="math inline">\(n\)</span>个值<span class="math inline">\(X_1 , X_2 , . . . ,
X_n\)</span>,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p><span class="math inline">\(\hat EX = \cfrac{ \sum_{ i = 1 }^n X_i }{
n }\)</span>.</p>
<p><span class="math inline">\(\hat VX = \cfrac{ \sum_{ i = 1 }^n X_i^2
}{ n - 1 } - \cfrac{ ( \sum_{ i = 1 }^n X_i )^2 }{ n ( n - 1 )
}\)</span>.</p>
<p>这里的<span class="math inline">\(\hat
VX\)</span>似乎与定义不是那么相符.但是它拥有更好的性质:<span class="math inline">\(E ( \hat VX ) = VX\)</span>.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \hat VX ) &amp; = \cfrac{ 1 }{ n - 1 } E ( \sum_{ i = 1 }^n X_i^2 -
\cfrac{ 1 }{ n } \sum_{ j = 1 }^n \sum_{ k = 1 }^n X_j X_k ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( \sum_{ i = 1 }^n E ( X_i^2 ) - \cfrac{ 1
}{ n } \sum_{ i = 1 }^n \sum_{ j = 1 }^n E ( X_i X_j ) ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( \sum_{ i = 1 }^n E ( X^2 ) - \cfrac{ 1 }{
n } \sum_{ i = 1 }^n \sum_{ j = 1 }^n ( ( EX )^2 [ j \ne k ] + E ( X^2 )
[ j = k ] ) ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( nE ( X^2 ) - \cfrac{ 1 }{ n } ( nE ( X^2
) + n ( n - 1 ) ( EX )^2 ) ) \\
&amp; = E ( X^2 ) - ( EX )^2 \\
&amp; = VX
\end{aligned}
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为<span class="math inline">\(P ( A | B
) = \frac{ P ( AB ) }{ P ( B ) } \\\)</span>.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有<span class="math inline">\(\{ B_i
\}\)</span>是样本空间的一个划分,即<span class="math inline">\(\forall i
, j\)</span>,有<span class="math inline">\(B_i \cap B_j =
\emptyset\)</span>,并且有<span class="math inline">\(\bigcup_{ i = 1 }^n
B_i = \Omega\)</span>.则有<span class="math inline">\(P ( B_i | A ) =
\frac{ P ( AB_i ) }{ P ( A ) } = \frac{ P ( AB_i ) }{ P ( A ) \sum P (
B_j ) } = \frac{ P ( A B_i ) }{ \sum_{ j = 1 }^n P ( A B_j ) } = \frac{
P ( A | B_i ) P ( B_i ) }{ \sum_{ j = 1 }^n P ( A | B_j ) P ( B_j ) }
\\\)</span>.</p>
<p>简化形式:<span class="math inline">\(P ( B | A ) = \frac{ P ( A | B )
P ( B ) }{ P ( A ) } \\\)</span>.</p>
<p>另外,我们考虑设<span class="math inline">\(O ( B ) = \cfrac{ P ( B )
}{ P ( \lnot B ) }\)</span>,称<span class="math inline">\(\cfrac{ P ( B
| E ) }{ P ( \lnot B | E ) }\)</span>为贝叶斯算子,则同理可得:</p>
<p><span class="math display">\[
O ( B | E ) = O ( B ) \cfrac{ P ( B | E ) }{ P ( \lnot B | E ) }
\]</span></p>
<p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果<span class="math inline">\(X\)</span>是定义在概率空间<span class="math inline">\(\Omega\)</span>上的随机变量,那么它的概率生成函数为<span class="math inline">\(G_X ( z ) = \sum_{ k \geq 0 } \Pr ( X = k ) z^k =
E ( z^X )\)</span>.</p>
<p>不难发现<span class="math inline">\(G_X ( z
)\)</span>需要满足的条件:所有系数都非负并且<span class="math inline">\(G_X ( 1 ) = 1\)</span>.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = G_X &#39; ( 1 ) \\
E ( X^2 ) &amp; = G &#39; &#39;_X ( 1 ) + G_X &#39; ( 1 ) \\
VX &amp; = G_X &#39; &#39; ( 1 ) + G_X &#39; ( 1 ) - ( G_X &#39; ( 1 )
)^2
\end{aligned}
\]</span></p>
<p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G ) &amp; = G &#39; ( 1 ) \\
Var ( G ) &amp; = G &#39; &#39; ( 1 ) + G &#39; ( 1 ) - ( G &#39; ( 1 )
)^2
\end{aligned}
\]</span></p>
<p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<p><span class="math display">\[
G ( 1 + t ) = \sum_{ i \geq 0 } \cfrac{ G^{ ( i ) } ( 1 ) }{ i ! } t^i
\]</span></p>
<p>另外,我们不难发现:<span class="math inline">\(G_{ X + Y } ( z ) = G_X
( z ) G_Y ( z )\)</span>.</p>
<p>根据前面的推导,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G_{ X + Y } ) &amp; = Mean ( G_X ) + Mean ( G_Y ) \\
Var ( G_{ X + Y } ) &amp; = Var ( G_X ) + Var ( G_Y )
\end{aligned}
\]</span></p>
<p>换句话说,若<span class="math inline">\(G_X ( 1 ) = 1 , G_Y ( 1 ) =
1\)</span>,那么这个式子与直接对<span class="math inline">\(G_{ X + Y
}\)</span>使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G_X ) &amp; = Mean ( G_{ X + Y } ) - Mean ( G_Y ) \\
Var ( G_X ) &amp; = Var ( G_{ X + Y } ) - Var ( G_Y )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为<span class="math inline">\(p\)</span>,反面向上的概率为<span class="math inline">\(q\)</span>,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设<span class="math inline">\(N\)</span>为所有不包含THTTH的硬币序列的生成函数,<span class="math inline">\(S\)</span>为所有只有结尾为THTTH的硬币序列的生成函数,令<span class="math inline">\(H = pz , T = qz\)</span>,<span class="math inline">\(1\)</span>为空集,我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N \times ( H + T ) &amp; = N + S \\
N \times THTTH &amp; = S + S \times TTH
\end{aligned}
\]</span></p>
<p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设<span class="math inline">\(A\)</span>是我们要找到的字符串,<span class="math inline">\(m\)</span>是它的长度,令<span class="math inline">\(A^{ ( k ) }\)</span>表示<span class="math inline">\(A\)</span>字符串的前<span class="math inline">\(k\)</span>个字符所组成的字符串,<span class="math inline">\(A_{ ( k ) }\)</span>表示<span class="math inline">\(A\)</span>字符串的后<span class="math inline">\(k\)</span>个字符所组成的字符串.这样的形式与<span class="math inline">\(k\)</span>阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S \\
N \times A &amp; = S ( \sum_{ k = 0 }^{ m - 1 } A^{ ( k ) } [ A^{ ( m -
k ) } = A_{ ( m - k ) } ] )
\end{aligned}
\]</span></p>
<p>如果我们设<span class="math inline">\(\tilde{ A
}\)</span>为将字符串<span class="math inline">\(A\)</span>中的H替换成<span class="math inline">\(\cfrac{ 1 }{ p } z\)</span>,T替换成<span class="math inline">\(\cfrac{ 1 }{ q }
z\)</span>之后的值,那么显然有:</p>
<p><span class="math display">\[
\begin{aligned}
N \times A &amp; = A \times S \times ( \sum_{ k = 1 }^{ m } \tilde{ A
}_{ ( k ) } [ A^{ ( k ) } = A_{ ( k ) } ] ) \\
N &amp; = S \times ( \sum_{ k = 1 }^{ m } \tilde{ A }_{ ( k ) } [ A^{ (
k ) } = A_{ ( k ) } ] ) \\
\cfrac{ S - 1 }{ H + T - 1 } &amp; = S \times ( \sum_{ k = 1 }^{ m }
\tilde{ A }_{ ( k ) } [ A^{ ( k ) } = A_{ ( k ) } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum_{ k = 1 }^{ m } \tilde{ A }_{
( k ) } [ A^{ ( k ) } &amp; = A_{ ( k ) } ] ) ) = 1
\end{aligned}
\]</span></p>
<p>这显然是一个卷积的形式.</p>
<p>令<span class="math inline">\(w = \sum_{ k = 1 }^{ m } \tilde{ A }_{
( k ) } [ A^{ ( k ) } = A_{ ( k ) } ]\)</span>.</p>
<p>令<span class="math inline">\(H ( z ) = 1\)</span>,<span class="math inline">\(F ( z ) = ( 1 + ( 1 - z ) \times w
)\)</span>,<span class="math inline">\(G ( z ) = S\)</span>.</p>
<p>那么我们显然可以直接求<span class="math inline">\(G ( z
)\)</span>的期望和方差,事实上:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = \sum_{ k = 1 }^{ m } \tilde{ A }_{ ( k ) } [ A^{ ( k ) } =
A_{ ( k ) } ] \\
VX &amp; = ( EX )^2 - \sum_{ k = 1 }^m ( 2 k - 1 ) \tilde{ A }_{ ( k ) }
[ A^{ ( k ) } = A_{ ( k ) } ]
\end{aligned}
\]</span></p>
<p>如果硬币是均匀的(<span class="math inline">\(p = q = \cfrac{ 1 }{ 2
}\)</span>)我们引入另一个符号:我们设<span class="math inline">\(A : A =
\sum_{ k = 1 }^m 2^{ k } [ A^{ ( k ) } = A_{ ( k ) }
]\)</span>.那么显然期望需要的抛硬币次数就是<span class="math inline">\((
A : A )\)</span>.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设<span class="math inline">\(S_A\)</span>为所有以HHT结尾的硬币序列的生成函数,设<span class="math inline">\(S_B\)</span>为所有以HTT结尾的硬币序列的生成函数.<span class="math inline">\(N\)</span>为其它的硬币序列的生成函数,令<span class="math inline">\(H = T = 0 . 5 z\)</span>.</p>
<p>我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S_A + S_B \\
N \times HHT &amp; = S_A \\
N \times HTT &amp; = S_A \times T + S_B
\end{aligned}
\]</span></p>
<p>解方程并带入<span class="math inline">\(z =
1\)</span>,可以有得知以HHT结尾的概率为<span class="math inline">\(\cfrac{ 2 }{ 3 }\)</span>.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,那么可以求出:</p>
<p><span class="math display">\[
\cfrac{ S_A }{ S_B } = \cfrac{ B : B - B : A }{ A : A - A : B }
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{ k , i }\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F , G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p><span class="math inline">\(1 + xG ( x ) = \sum_k F_k ( x ) + G (
x )\)</span>.</p></li>
<li><p><span class="math inline">\(( \frac{ 1 }{ 2 } x )^L G ( x ) =
\sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 } ( \frac{ 1 }{ 2 } x
)^i [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i ) } ]\)</span>.</p></li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x =
1\)</span>,发现<span class="math inline">\(\sum_{ k } F_k ( 1 ) =
1\)</span>.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 }
( \frac{ 1 }{ 2 } x )^{ i - L } [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i )
} ] \\
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 1 }^{ L } (
\frac{ 1 }{ 2 } x )^{ - i } [ A_k^{ ( i ) } ={ A_j }_{ ( i ) } ]
\end{aligned}
\]</span></p>
<p>带入<span class="math inline">\(x = 1\)</span>,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum_{ j = 1 }^n F_j ( 1 ) \sum_{ i = 1 }^{ L } 2^i [ A_k^{ (
i ) } ={ A_j }_{ ( i ) } ]
\]</span></p>
<p>不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n + 1\)</span>个等式,可以算出<span class="math inline">\(G ( 1 ) , F_{ 1 \cdots n } ( 1 )\)</span>这<span class="math inline">\(n + 1\)</span>个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为<span class="math inline">\(n +
1\)</span>的概率空间,其中<span class="math inline">\(\Pr ( \omega_k ) =
\binom{ n }{ k } p^k q^{ n - k }
\\\)</span>,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令<span class="math inline">\(H ( z ) = q +
pz\)</span>,不难发现二项式分布的生成函数为<span class="math inline">\(H
( z )^n\)</span>.</p>
<p>不难发现,满足二项式分布的随机变量的均值是<span class="math inline">\(np\)</span>,方差是<span class="math inline">\(npq\)</span>.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:<span class="math inline">\(G ( z )^n = ( \cfrac{ p }{ 1 - qz } )^n = \sum_{ k
} \binom{ n + k - 1 }{ k } p^n q^k z^k\)</span>.</p>
<p>我们考虑如何求<span class="math inline">\(G ( z
)\)</span>的方差和均值,不妨设<span class="math inline">\(F ( z ) =
\cfrac{ 1 - qz }{ p } = \cfrac{ 1 }{ p } - \cfrac{ q }{ p }
z\)</span>,则<span class="math inline">\(G ( z )^n = F ( z )^{ - n
}\)</span>.</p>
<p>不难发现<span class="math inline">\(F ( z
)\)</span>满足二项式分布.也就是说,以<span class="math inline">\(( n , p
, q )\)</span>为参数的负二项式分布也就是以<span class="math inline">\((
- n , - \cfrac{ q }{ p } , \cfrac{ 1 }{ p }
)\)</span>为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为<span class="math inline">\(1\)</span>的<span class="math inline">\(n\)</span>个点的树,问所有点对<span class="math inline">\(( i , j ) ( 1 \leq i , j \leq n
)\)</span>中,从<span class="math inline">\(i\)</span>走到<span class="math inline">\(j\)</span>的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设<span class="math inline">\(f_u\)</span>表示<span class="math inline">\(u\)</span>随机走到它父亲的期望,<span class="math inline">\(g_v\)</span>表示<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的期望.</p>
<p>对于<span class="math inline">\(f_u\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_u &amp; = \cfrac{ \sum_{ u \rightarrow v } ( f_v + f_u ) }{ \deg_u } +
1 \\
f_u &amp; = \deg_u + \sum_{ u \rightarrow v } f_v
\end{aligned}
\]</span></p>
<p>对于<span class="math inline">\(g_v\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
g_v &amp; = \cfrac{ g_u + g_v + \sum_{ u \rightarrow w , w \ne v } ( g_v
+ f_w ) }{ \deg_u } + 1 \\
g_v &amp; = g_u + \sum_{ u \rightarrow w , w \ne v } f_w + \deg_u
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵<span class="math inline">\(n\)</span>个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从<span class="math inline">\(1\)</span>号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案<span class="math inline">\(+ 1\)</span>.当走到度数为<span class="math inline">\(1\)</span>的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设<span class="math inline">\(f_u\)</span>表示以<span class="math inline">\(u\)</span>为起点的路径的期望长度,不难注意到<span class="math inline">\(f_{ leaf } = 1\)</span>且<span class="math inline">\(f_u = 1 + \cfrac{ 1 }{ \deg_u } \sum_{ u
\rightarrow v \lor v \rightarrow u }
f_v\)</span>.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得<span class="math inline">\(f_u = k_u f_{ fa } +
b_u\)</span>,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出<span class="math inline">\(g_v\)</span>表示从<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的概率,再令<span class="math inline">\(f_u\)</span>表示从<span class="math inline">\(u\)</span>走到父亲的概率,类似Example1,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_u &amp; = \cfrac{ 1 }{ \deg_u } ( 1 + \sum_{ u \rightarrow v } f_v f_u
) \\
g_v &amp; = \cfrac{ 1 }{ \deg_u } ( 1 + g_v g_u + \sum_{ u \rightarrow w
, w \ne v } f_w g_v )
\end{aligned}
\]</span></p>
<p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为<span class="math inline">\(\frac{ 1 }{ \binom{ n }{ 2 } }\)</span>.</p>
<p>把所有人权值从大到小排序,设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>个人的时候的期望,不难发现:<span class="math inline">\(f_{ i } = \frac{ 1 }{ \binom{ i }{ 2 } } v_i + ( 1
- \frac{ 1 }{ \binom{ i }{ 2 } } ) f_{ i - 1 }\)</span>.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设<span class="math inline">\(f_{ i , j }\)</span>表示过了<span class="math inline">\(i\)</span>关,花费为<span class="math inline">\(j\)</span>的期望,不难发现所有的<span class="math inline">\(f\)</span>都需要与<span class="math inline">\(f_{
0 , 0 }\)</span>取<span class="math inline">\(\min\)</span>,这咋办?</p>
<p>我们考虑二分这个<span class="math inline">\(f_{ 0 , 0
}\)</span>,做的时候直接取<span class="math inline">\(\min\)</span>,这样最后还会求出一个<span class="math inline">\(f_{ 0 , 0
}\)</span>,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的<span class="math inline">\(f_{ 0 , 0
}\)</span>越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取<span class="math inline">\(\min\)</span>的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张<span class="math inline">\(n \times
m\)</span>的图(假设<span class="math inline">\(n \geq
m\)</span>),其中格点<span class="math inline">\(( a , b
)\)</span>表示现在还剩<span class="math inline">\(a\)</span>个Yes,<span class="math inline">\(b\)</span>个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从<span class="math inline">\(( n , m )\)</span>走到<span class="math inline">\(( 0 , 0
)\)</span>的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线<span class="math inline">\(y =
x\)</span>翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从<span class="math inline">\(( n , m )\)</span>走到<span class="math inline">\(( 0 , 0 )\)</span>一定会经过<span class="math inline">\(n\)</span>条有向边,所以期望贡献一定要加上一个<span class="math inline">\(n\)</span>.而如果我走到了直线<span class="math inline">\(y = x\)</span>上,那接下来的贡献是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="一些不等式">一些不等式</span></h2>
<h3><span id="union-bound">Union Bound</span></h3>
<p>即:<span class="math inline">\(\mathbb{P} [ \bigcup_i X_i ] \leq \sum
\mathbb P [ X_i ]\)</span>,取等当且仅当所有<span class="math inline">\(X_i\)</span>互斥.</p>
<h3><span id="markov-不等式">Markov 不等式</span></h3>
<p>若<span class="math inline">\(X \geq 0\)</span>,则<span class="math inline">\(\mathbb{P} [ X \geq t \mathbb{ E } [ X ] ] \leq
\frac{ 1 }{ t }\)</span>.</p>
<p>显然,多的太多的话就会超过<span class="math inline">\(E\)</span>.</p>
<h3><span id="chebyshev-不等式">Chebyshev 不等式</span></h3>
<p>当<span class="math inline">\(\sigma(X)&gt;0\)</span>时,有 <span class="math display">\[
\mathbb{P}(|X-\mathbb{E}(X)|\geq c\sdot \sigma(X))\leq \frac{1}{c^2}
\]</span> 证明的话直接考虑设<span class="math inline">\(Y=(X-\mathbb
E(X))^2\)</span>,用Markov不等式得到: <span class="math display">\[
\begin{aligned}
\mathbb{P}(Y\geq c^2\mathbb E(Y))&amp;\leq \frac{1}{c^2}\\
\mathbb{P}((X-\mathbb E(X))^2\geq c^2\sigma^2(X))&amp;\leq
\frac{1}{c^2}\\
\mathbb{P}|(X-\mathbb E(X)|\geq c\sigma(X))&amp;\leq \frac{1}{c^2}\\
\end{aligned}
\]</span></p>
<h2><span id="一些离散分布">一些离散分布</span></h2>
<h3><span id="泊松分布">泊松分布</span></h3>
<p>取二项分布的极限情况.设此时<span class="math inline">\(n=\lambda
m\)</span>,每个东西有<span class="math inline">\(\frac{1}{m}\)</span>的概率选入,则对于一个固定的常数<span class="math inline">\(k\)</span>,当<span class="math inline">\(m\to
\infty\)</span>的时候,<span class="math inline">\(P(X=k)=\frac{1}{k!}\lambda^k
e^{-\lambda}\)</span>,记作<span class="math inline">\(X\sim
\pi(\lambda)\)</span>.</p>
<p>欸,虽然我们这里只考虑了<span class="math inline">\(k\)</span>某种程度上远小于<span class="math inline">\(m\)</span>的存在,但好在大的部分也不会有什么太大影响,因此:
<span class="math display">\[
\sum_k P(X=k)=1
\]</span> 原因是<span class="math inline">\(e^{\lambda}=\sum_k
\frac{\lambda^k}{k!}\)</span>.</p>
<p>此时来看<span class="math inline">\(\mathbb
E(X)\)</span>,留神到无非是上面那个东西转移了一下子,因此<span class="math inline">\(\mathbb{E}(X)=\lambda\)</span>.</p>
<p>来看<span class="math inline">\(\mathbb{E}(X^2)\)</span>,自然有:
<span class="math display">\[
\begin{aligned}
&amp;\sum_k \frac{1}{k!}\lambda^k e^{-\lambda}k^2\\
=&amp;\sum_k \frac{1}{k!}\lambda^k e^{-\lambda}k(k-1)+\sum_k
\frac{1}{k!}\lambda^k e^{-\lambda}k\\
=&amp;\lambda^2+\lambda
\end{aligned}
\]</span> 所以<span class="math inline">\(\sigma^2(X)=\mathbb{E}(X^2)-(\mathbb
E(X))^2=\lambda\)</span>.</p>
<h3><span id="几何分布">几何分布</span></h3>
<p>伯努利试验中首次发生结果<span class="math inline">\(A\)</span>的次数,记作<span class="math inline">\(X\sim \text{G}(p)\)</span>.</p>
<p>显然<span class="math inline">\(P(X=k)=p(1-p)^{k-1}\)</span>,此外<span class="math inline">\(P(X&gt;n)=(1-p)^n\)</span>.</p>
<p>设<span class="math inline">\(f(p)=\sum_{k\geq
1}(1-p)^{k-1}\)</span>,则<span class="math inline">\(f(p)=\frac{1}{p}\)</span>,<span class="math inline">\(E(X)=-pf&#39;(p)=\frac{1}{p}\)</span>,<span class="math inline">\(\sigma^2(X)=\frac{1-p}{p^2}\)</span>.</p>
<p>很重要的一个性质是无记忆性.即<span class="math inline">\(P(X&gt;m+n|X&gt;m)=P(X&gt;n)\)</span>.</p>
<h3><span id="负二项分布">负二项分布</span></h3>
<p>伯努利实验中结果<span class="math inline">\(A\)</span>发生<span class="math inline">\(r\)</span>次的重复次数.则<span class="math inline">\(P(X=k)=\binom{k-1}{r-1}p^r(1-p)^{k-r}\)</span>,记作<span class="math inline">\(X\sim \text{NB}(r,p)\)</span>.显然<span class="math inline">\(\text{NB}(1,p)\sim
\text{G}(p)\)</span>.必然有<span class="math inline">\(E(X)=\frac{r}{p}\)</span>.</p>
<p>首先要验证: <span class="math display">\[
\begin{aligned}
\sum_{k\geq r}P(X=k)&amp;=\sum_{k\geq r}\binom{k-1}{r-1}p^r(1-p)^{k-r}\\
&amp;=\sum_{l\geq 0}\binom{l+r-1}{r-1}p^r(1-p)^l\\
&amp;=\sum_{l\geq 0}\binom{l+r-1}{l}p^r(1-p)^l
\end{aligned}
\]</span> 而: <span class="math display">\[
\begin{aligned}
p^{-r}&amp;=(1-(1-p))^{-r}\\
&amp;=\sum_{l\geq 0}\binom{-r}{l}(-1)^l(1-p)^{l}\\
&amp;=\sum_{l\geq 0}\binom{l+r-1}{l}(1-p)^l
\end{aligned}
\]</span></p>
<h2><span id="连续随机变量">连续随机变量</span></h2>
<p>给定随机变量<span class="math inline">\(X\)</span>和实数<span class="math inline">\(x\)</span>,定义<span class="math inline">\(F(x)=P(X\leq x)\)</span>为随机变量<span class="math inline">\(X\)</span>的<strong>分布函数</strong>.</p>
<p>分布函数有如下性质:</p>
<ol type="1">
<li><strong>有界性</strong>:<span class="math inline">\(0\leq F(x)\leq
1\)</span>,而且<span class="math inline">\(\lim_{x\to
-\infty}F(x)=0,\lim_{x\to +\infty}F(x)=1\)</span>.</li>
<li><strong>单调性</strong>:<span class="math inline">\(F(x)\)</span>单调不减.</li>
<li><strong>右连续</strong>:<span class="math inline">\(F(x_0+0)=F(x_0)\)</span>.</li>
</ol>
<p>如果存在一个<span class="math inline">\(f(x)\)</span>,使得<span class="math inline">\(F(x)=\int_{-\infty}^x
f(x)\mathrm{d}x\)</span>,则称<span class="math inline">\(X\)</span>是<strong>连续随机变量</strong>,而<span class="math inline">\(f(x)\)</span>是其概率密度函数.它还应当满足以下性质:</p>
<ol type="1">
<li><strong>非负性</strong>:<span class="math inline">\(f(x)\geq
0\)</span>.</li>
<li><strong>正则性</strong>:<span class="math inline">\(\int_{-\infty}^{+\infty}f(t)\mathrm{d}t=1\)</span>.</li>
</ol>
<p>对于连续随机变量.此时<span class="math inline">\(F\)</span>还满足左连续<span class="math inline">\(F(x_0-0)=F(x_0)\)</span>.</p>
<p>由此还可以得出连续随机变量在任何一点处取值必然为零,因为<span class="math inline">\(P(a\leq X\leq a)=P(a&lt;X&lt;a)=0\)</span>.</p>
<p>由此可以定义期望:当<span class="math inline">\(\int_{-\infty}^{+\infty}f(x)|x|\mathrm{d}x&lt;\infty\)</span>,则定义<span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}xf(x)\mathrm{d}x\)</span>.注意这里要求的是绝对可积而不是可积.</p>
<p>现在我们来搞定:<span class="math inline">\(P(X\leq
E(X))&gt;0\)</span>.</p>
<p>策略是反证:如果<span class="math inline">\(P(X\leq
E(X))=0\)</span>.此时任取一个<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(P(X\leq E(X)+\epsilon)\leq
\frac{1}{2}\)</span>.</p>
<p>此时<span class="math inline">\(E(X)\geq P(X\geq
E(X)+\epsilon)(E(X)+\epsilon)+P(X&lt;
E(X)+\epsilon)E(X)&gt;E(X)\)</span>,这就矛盾了.</p>
<p>接下来来做Markov不等式,对于非负随机变量<span class="math inline">\(X\)</span>,若<span class="math inline">\(E(X)&gt;
0,a&gt;0\)</span>,则<span class="math inline">\(P(X\geq aE(X))\leq
\frac{1}{a}\)</span>.原因是: <span class="math display">\[
\begin{aligned}
E(X)&amp;=\int_{-\infty}^{+\infty}f(x)x\mathrm{d}x\\
&amp;\geq \int_{aE(X)}^{+\infty}f(x)x\mathrm{d}x\\
&amp;\geq \int_{aE(X)}^{+\infty}f(x)aE(X)\mathrm{d}x\\
&amp;=aE(X)\int_{aE(X)}^{+\infty}f(x)\mathrm{d}x\\
&amp;=aE(X)P(X\geq aE(X))
\end{aligned}
\]</span> 此时还可以定义<span class="math inline">\(\mathrm{Var}(X)=E((X-E(X))^2)=E(X^2)-E^2(X)\)</span>.</p>
<p>Chebyshev不等式的证明只依赖于Markov不等式,因此在这里也能用.</p>
<h3><span id="高斯分布">高斯分布</span></h3>
<p>概率密度函数<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\)</span>.</p>
<p>除了上述已经提到的性质,它还满足:</p>
<ol type="1">
<li>对称性:<span class="math inline">\(f(x)=f(-x)\)</span>.</li>
<li><span class="math inline">\(f(x)_{\max}=f(0)\)</span>.</li>
<li><span class="math inline">\(\lim_{x\to -\infty}f(x)=\lim_{x\to
+\infty}f(x)=0\)</span>.</li>
<li><span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}f(x)x\mathrm{d}x=0\)</span>.</li>
<li><span class="math inline">\(E(X^2)=\int_{-\infty}^{+\infty}f(x)x^2\mathrm{d}x=1\)</span>.</li>
<li><span class="math inline">\(\mathrm{Var}(X)=1\)</span>.</li>
</ol>
<p>其中(5)的证明见: <span class="math display">\[
\begin{aligned}
\int_{-\infty}^{+\infty}f(x)x^2\mathrm{d}x&amp;=\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}x^2\mathrm{d}x\\
&amp;=\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}}(-x)\mathrm{d}e^{-\frac{x^2}{2}}\\
&amp;=\frac{1}{\sqrt{2\pi}}(-x)e^{-\frac{x^2}{2}}|_{-\infty}^{+\infty}+\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\mathrm{d}x\\
&amp;=1
\end{aligned}
\]</span> 还可以对此进行推广,考虑<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span>,记<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.只需取<span class="math inline">\(y=\frac{x-\mu}{\sigma}\)</span>,就可以转换回标准正态分布,并且此时<span class="math inline">\(F_Y(y)=F_X(\sigma y+\mu)\)</span>.</p>
<h3><span id="指数分布">指数分布</span></h3>
<p>对于<span class="math inline">\(\lambda&gt;0\)</span>,定义概率密度函数<span class="math inline">\(f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;x\geq
0\\0&amp;x&lt;0\end{cases}\)</span>,记作<span class="math inline">\(X\sim
\mathrm{EXP}(\lambda)\)</span>.其分布函数<span class="math inline">\(F(X)=\begin{cases}1-e^{-\lambda
x}&amp;X&gt;0\\0&amp;X\leq 0\end{cases}\)</span>.</p>
<p>它同样也有无记忆性.考虑<span class="math inline">\(P(X&gt;t)=e^{-\lambda t}\)</span>,从而<span class="math inline">\(P(X&gt;s+t|X&gt;s)=P(X&gt;t)\)</span>.</p>
<h3><span id="伽马分布">伽马分布</span></h3>
<p>对于<span class="math inline">\(\alpha&gt;0\)</span>,定义伽马函数<span class="math inline">\(\Gamma(\alpha)=\int_0^{+\infty}x^{\alpha-1}e^{-x}\mathrm{d}x\)</span>.我们见过很多次这个东西了,请看:</p>
<ol type="1">
<li><span class="math inline">\(\Gamma(1)=1\)</span>.</li>
<li><span class="math inline">\(\Gamma(\frac{1}{2})=\sqrt{\pi}\)</span>.</li>
<li><span class="math inline">\(\Gamma(\alpha+1)=\alpha\Gamma(\alpha)\)</span>.</li>
<li><span class="math inline">\(\Gamma(n+1)=n!\)</span>.</li>
<li><span class="math inline">\(\Gamma(n+\frac{1}{2})=\frac{(2n)!}{4^nn!}\sqrt
\pi\)</span>.</li>
</ol>
<p>对于<span class="math inline">\(\lambda,\alpha&gt;0\)</span>,定义概率密度函数<span class="math inline">\(f(x)=\begin{cases}\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda
x}&amp;x\geq 0\\0&amp;x&lt;0\end{cases}\)</span>,称此时<span class="math inline">\(x\)</span>符合伽马分布,记作<span class="math inline">\(X\sim \Gamma(\alpha,\lambda)\)</span>.</p>
<p>先把正则性验证了吧,令<span class="math inline">\(y=\lambda
x\)</span>,则<span class="math inline">\(f(x)=\frac{\lambda}{\Gamma(\alpha)}y^{\alpha-1}e^{-y}\)</span>,则<span class="math inline">\(f(x)\mathrm{d}x=\frac{1}{\Gamma(\alpha)}y^{\alpha-1}e^{-y}\mathrm{d}y\)</span>,于是搞定了.</p>
<p>然后是其期望: <span class="math display">\[
\begin{aligned}
E(X)&amp;=\int_{0}^{+\infty}xf(x)\mathrm{d}x\\&amp;=\int_0^{+\infty}\frac{1}{\Gamma(\alpha)}y^{\alpha}e^{-y}\frac{\mathrm{d}y}{\lambda}\\
&amp;=\frac{\Gamma(\alpha+1)}{\Gamma(\alpha)\lambda}\\
&amp;=\frac{\alpha}{\lambda}
\end{aligned}
\]</span> 类似地,<span class="math inline">\(\int_0^{+\infty}x^2f(x)\mathrm{d}x=\frac{\Gamma(\alpha+2)}{\Gamma(\alpha)\lambda^2}\)</span>,从而算出<span class="math inline">\(\mathrm{Var}(X)=\frac{\alpha}{\lambda^2}\)</span>.显然当<span class="math inline">\(X\sim \Gamma(\alpha,\lambda)\)</span>时，<span class="math inline">\(Y=kX\sim
\Gamma(\alpha,\frac{\lambda}{k})\)</span>.</p>
<p>当<span class="math inline">\(\alpha=1\)</span>的时候,我们得到了指数分布<span class="math inline">\(\Gamma(1,\lambda)\sim
\mathrm{Exp}(\lambda)\)</span>.</p>
<p>另一个特例是,<span class="math inline">\(\alpha=\frac{n}{2},\lambda=\frac{1}{2}\)</span>.此时我们称其为自由度为<span class="math inline">\(n\)</span>的卡方<span class="math inline">\(\chi^2\)</span>分布.记作<span class="math inline">\(\chi^2(n)\)</span>,其数学期望为<span class="math inline">\(n\)</span>,方差为<span class="math inline">\(2n\)</span>.当<span class="math inline">\(n=1\)</span>的时候,<span class="math inline">\(f(x)=\sqrt \frac{1}{2\pi
x}e^{-\frac{x}{2}}\)</span>.</p>
<h2><span id="多维离散随机变量">多维离散随机变量</span></h2>
<h3><span id="重期望公式">重期望公式</span></h3>
<p>考虑把<span class="math inline">\(E(X|Y)\)</span>视作一个<span class="math inline">\(g(Y)\)</span>,则<span class="math inline">\(E(E(X|Y))=E(X)\)</span>.原因是<span class="math inline">\(E(E(X|Y))=\sum_j P(Y=y_j)E(X|Y=y_j)\)</span>.</p>
<h2><span id="多维连续随机变量">多维连续随机变量</span></h2>
<p>设<span class="math inline">\(F(x,y)=P(X\leq x\land Y\leq
y)\)</span>.应该有:</p>
<p><strong>联合分布函数</strong>有如下性质:</p>
<ol type="1">
<li><strong>有界性</strong>:<span class="math inline">\(0\leq F(x,y)\leq
1\)</span>,而且<span class="math inline">\(\lim_{x\to
-\infty}F(x,y)=\lim_{y\to -\infty}F(x,y)=0,\lim_{x,y\to
+\infty}F(x,y)=1\)</span>.</li>
<li><strong>单调性</strong>:当<span class="math inline">\(x_1\leq
x_2\)</span>时,<span class="math inline">\(F(x_1,y)\leq
F(x_2,y)\)</span>;当<span class="math inline">\(y_1\leq
y_2\)</span>时,<span class="math inline">\(F(x,y_1)\leq
F(x,y_2)\)</span>.</li>
<li><strong>右连续</strong>:<span class="math inline">\(F(x_0+0,y)=F(x_0,y)\)</span>,<span class="math inline">\(F(x,y_0+0)=F(x,y_0)\)</span>.</li>
<li><strong>非负性</strong>:<span class="math inline">\(P(a&lt;X\leq
b,c&lt;Y\leq d)=F(b,d)-F(a,d)-F(b,c)+F(a,c)\geq 0\)</span>.</li>
</ol>
<p>当<span class="math inline">\(F\)</span>连续时,如果能找到函数<span class="math inline">\(f\geq 0\)</span>满足<span class="math inline">\(F(x,y)=\int_{-\infty}^x\int_{-\infty}^y
f(u,v)\mathrm{d}v\mathrm{d}u\)</span>,称<span class="math inline">\(f\)</span>为<strong>联合密度函数</strong>.</p>
接下来来看条件分布函数和条件密度函数,当概率密度函数的确连续时,定义: $$
<span class="math display">\[\begin{aligned}
P(X\leq x|Y=y)&amp;=\lim_{\Delta\to +0}P(X\leq x|y\leq Y\leq y+\Delta)\\
&amp;=\lim_{\Delta\to
+0}\cfrac{\int_{-\infty}^x\int_{y}^{y+\Delta}f(u,v)\mathrm{d}v\mathrm{d}u}{\int_{y}^{y+\Delta}f_Y(v)\mathrm{d}v}\\
&amp;=\lim_{\Delta\to
+0}\cfrac{\int_{-\infty}^x(\frac{1}{\Delta}\int_{y}^{y+\Delta}f(u,v)\mathrm{d}v)\mathrm{d}u}{\frac{1}{\Delta}\int_{y}^{y+\Delta}f_Y(v)\mathrm{d}v}\\
&amp;=\cfrac{\int_{-\infty}^xf(u,y)\mathrm{d}u}{f_Y(y)}\\
&amp;=\int_{-\infty}^x\cfrac{f(u,y)}{f_Y(y)}\mathrm{d}u\\

\end{aligned}\]</span>
<p>$$ 其中<span class="math inline">\(f_Y(y)=\int_{-\infty}^{+\infty}f(u,y)\mathrm{d}u\)</span>.</p>
<p>当<span class="math inline">\(\forall x,y\)</span>都有<span class="math inline">\(f(x,y)=f_X(x)f_Y(y)\)</span>,则称<span class="math inline">\(X,Y\)</span>相互独立.</p>
<p>容易检验<span class="math inline">\(E(X+Y)=E(X)+E(Y)\)</span>,而且当<span class="math inline">\(X,Y\)</span>相互独立的时候,<span class="math inline">\(E(XY)=E(X)E(Y)\)</span>,于是自然也有<span class="math inline">\(\mathrm{Var}(X\pm
Y)=\mathrm{Var}(X)+\mathrm{Var}(Y)\)</span>.</p>
<h3><span id="二维正态分布">二维正态分布</span></h3>
<p>即: <span class="math display">\[
f(x,y)=\frac{\exp(-\frac{1}{2(1-\rho^2)}\left(\frac{(x-\mu_1)^2}{\sigma_1^2}+\frac{(y-\mu_2)^2}{\sigma_2^2}-\frac{2\rho(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}\right))}{2\pi
\sigma_1\sigma_2\sqrt{1-\rho^2}}
\]</span> 现在来验证正则性,取<span class="math inline">\(u=\frac{\frac{x-\mu_1}{\sigma_1}-\rho
\frac{y-\mu_2}{\sigma_2}}{\sqrt{1-\rho^2}},v=\frac{y-\mu_2}{\sigma_2}\)</span>.而<span class="math inline">\(\left|\frac{\partial(u,v)}{\partial(x,y)}\right|=\sigma_1\sigma_2\sqrt{1-\rho^2}\)</span>​.于是:
<span class="math display">\[
\begin{aligned}
&amp;\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}x\mathrm{d}y\\
=&amp;\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)\mathrm{d}u\mathrm{d}v\\
=&amp;1
\end{aligned}
\]</span> 此外请看: <span class="math display">\[
\begin{aligned}
f_X(x)&amp;=\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}y\\
&amp;=\sigma_2\sqrt{1-\rho^2}\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}u\\
&amp;=\frac{1}{\sigma_1\sqrt{2\pi}}\exp\left(-\frac{(x-\mu_1)^2}{2\sigma_1^2}\right)
\end{aligned}
\]</span> 于是当<span class="math inline">\(X,Y\sim
N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\)</span>,则<span class="math inline">\(X\sim N(\mu_1,\sigma_1^2),Y\sim
N(\mu_2,\sigma_2^2)\)</span>.</p>
<p>此外: <span class="math display">\[
\begin{aligned}
f(x|y)&amp;=\frac{f(x,y)}{f_Y(y)}\\
&amp;=\frac{1}{\sigma_1\sqrt{2\pi}\sqrt{1-\rho^2}}\exp\left(-\frac{1}{2(1-\rho^2)}\left(\frac{x-\mu_1}{\sigma_1}-\rho\frac{y-\mu_2}{\sigma_2}\right)^2\right)
\end{aligned}
\]</span> 也就是说,当<span class="math inline">\(Y=y\)</span>时,<span class="math inline">\(X\sim
N(\mu_1+\rho\frac{\sigma_1}{\sigma_2}(y-\mu_2),\sigma_1^2(1-\rho^2))\)</span>,容易见到相互独立当且仅当<span class="math inline">\(\rho=0\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(n\times n\)</span>的矩阵<span class="math inline">\(A\)</span>中每个元素独立服从<span class="math inline">\(N(0,1)\)</span>.求<span class="math inline">\(E(\det
A),E(\mathrm{trace}(A)),E(\mathrm{trace}(A^2))\)</span>.</p>
<p>考虑<span class="math inline">\(\det
A=\sum_{\sigma}\mathrm{sgn}(\sigma)\prod
A_{i,\sigma(i)}\)</span>.直接套期望就知道<span class="math inline">\(E(\det A)=0\)</span>.</p>
<p>显然<span class="math inline">\(E(\mathrm{trace}(A))=0\)</span>.</p>
<p>而<span class="math inline">\(E(\mathrm{trace}(A^2))\)</span>中,每一个<span class="math inline">\((A^2)_{i,i}=\sum_{j}E(a_{i,j}a_{j,i})=1\)</span>,于是<span class="math inline">\(E(\mathrm{trace}(A^2))=n\)</span>.</p>
<h3><span id="重期望公式">重期望公式</span></h3>
<p>定义<span class="math inline">\(E(X|Y=y)=\int_{-\infty}^{+\infty}f(x|y)x\mathrm{d}x\)</span>.则<span class="math inline">\(E(E(X|Y))=E(X)\)</span>.</p>
<h3><span id="协方差">协方差</span></h3>
<p>和离散时的基本全部一样.其实早该看出来协方差就是一种双线性形式.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明二维正态分布的<span class="math inline">\(\mathrm{Cov}(X,Y)=\sigma_1\sigma_2\rho\)</span>.</p>
<p>容易见到: <span class="math display">\[
\begin{aligned}
\mathrm{Cov}(X,Y)&amp;=\int\int
f(x,y)(x-\mu_1)(y-\mu_2)\mathrm{d}x\mathrm{d}y\\
&amp;=\int\int\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)\sigma_1\sigma_2v(u\sqrt{1-\rho^2}+\rho
v)\mathrm{d}u\mathrm{d}v
\end{aligned}
\]</span> 然而: <span class="math display">\[
\begin{aligned}
\int\int\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)uv\mathrm{d}u\mathrm{d}v&amp;=0\\
\int\int\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)v^2\mathrm{d}u\mathrm{d}v&amp;=1\\
\end{aligned}
\]</span> 带入得到结果.</p>
<h4><span id="相关系数">相关系数</span></h4>
<p>可以定义相关系数<span class="math inline">\(\mathrm{Corr}(X,Y)=\frac{\mathrm{Cov}(X,Y)}{\sigma(X)\sigma(Y)}\)</span>.一个很好玩的事是两个变量的任意线性变换<span class="math inline">\(X&#39;=aX+b\)</span>后,仍有: <span class="math display">\[
\begin{aligned}
\mathrm{Corr}(X&#39;,Y)=\frac{a\mathrm{Cov}(X,Y)}{|a|\sigma(X)\sigma(Y)}=\mathrm{sgn}(a)\frac{\mathrm{Cov}(X,Y)}{\sigma(X)\sigma(Y)}
\end{aligned}
\]</span> 一个显然结论是当标准化后即<span class="math inline">\(\tilde
X=\frac{X-E(X)}{\sigma(X)}\)</span>后相关系数不变.</p>
<p>此外,我们可以证明以下性质:</p>
<ol type="1">
<li><span class="math inline">\(|\mathrm{Corr}(X,Y)|\leq
1\)</span>.</li>
<li>如果<span class="math inline">\(|\mathrm{Corr}(X,Y)|=1\)</span>等价于<span class="math inline">\(Y,X\)</span>存在关系<span class="math inline">\(a\ne 0\)</span>使得<span class="math inline">\(P(Y=aX+b)=1\)</span>.</li>
</ol>
<p>(1)(2)其实就是柯西不等式对吧,因为<span class="math inline">\(\mathrm{Cov}\)</span>其实是某种内积,所以当然有<span class="math inline">\(\frac{\mathrm{Cov}(X,Y)}{\sqrt{\mathrm{Cov}(X,X)\mathrm{Cov}(Y,Y)}}\in
[-1,1]\)</span>.</p>
<h4><span id="协方差矩阵">协方差矩阵</span></h4>
<p>设随机变量<span class="math inline">\(X=(X_1,\cdots,X_n)\)</span>,定义<span class="math inline">\(E(X)=(E(X_1),\cdots,E(X_n))\)</span>为其<strong>数学期望向量</strong>,而<span class="math inline">\(\mathrm{Cov}(X)=E((X-E(X))(X-E(X))^t)\)</span>为<span class="math inline">\(X\)</span>的协方差矩阵.也就是<span class="math inline">\(\mathrm{Cov}(X)_{i,j}=\mathrm{Cov}(X_i,X_j)\)</span>.容易见到其半正定,原因是<span class="math inline">\(\alpha^t\mathrm{Cov}(X)\alpha=E((\alpha^t(X-E(X)))^2)\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求二维正态分布的协方差矩阵.</p>
<p>显然为: <span class="math display">\[
B=\begin{bmatrix}
\sigma_1^2&amp;\rho\sigma_1\sigma_2\\
\rho\sigma_1\sigma_2&amp;\sigma_2^2
\end{bmatrix}
\]</span> 此外<span class="math inline">\(\det(B)=(1-\rho^2)\sigma_1^2\sigma_2^2\)</span>.其逆矩阵<span class="math inline">\(B^{-1}=\frac{1}{1-\rho^2}\begin{bmatrix}\frac{1}{\sigma_1^2}&amp;-\frac{\rho}{\sigma_1\sigma_2}\\-\frac{\rho}{\sigma_1\sigma_2}&amp;\frac{1}{\sigma_2^2}\end{bmatrix}\)</span>.</p>
<p>此时见到: <span class="math display">\[
\begin{aligned}
f(x_1,x_2)&amp;=\frac{\exp(-\frac{1}{2(1-\rho^2)}\left(\frac{(x_1-\mu_1)^2}{\sigma_1^2}+\frac{(x_2-\mu_2)^2}{\sigma_2^2}-\frac{2\rho(x_1-\mu_1)(x_2-\mu_2)}{\sigma_1\sigma_2}\right))}{2\pi
\sigma_1\sigma_2\sqrt{1-\rho^2}}\\
&amp;=\frac{1}{2\pi\sqrt {\det B}}\exp\left(-\frac{1}{2}(\vec x-\vec
\mu)^TB^{-1}(\vec x-\vec \mu)\right)
\end{aligned}
\]</span> 从而容易推广到任意多维,只需定义: <span class="math display">\[
\begin{aligned}
f(\vec x)
&amp;=\frac{1}{(2\pi)^{\frac{n}{2}}\sqrt {\det
B}}\exp\left(-\frac{1}{2}(\vec x-\vec \mu)^TB^{-1}(\vec x-\vec
\mu)\right)
\end{aligned}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>求证:当<span class="math inline">\(\vec X\sim N(\vec
\mu,B)\)</span>,则<span class="math inline">\(\vec Y=A\vec X+\vec b\sim
N(A\vec \mu+\vec b,ABA^t)\)</span>,其中<span class="math inline">\(A\)</span>必须行满秩.</p>
<p>当<span class="math inline">\(A\)</span>是方阵的时候,直接可逆,于是:
<span class="math display">\[
\begin{aligned}
f_Y(y)&amp;=f_X(A^{-1}(y-b))|\frac{\partial x}{\partial y}|\\
&amp;=f_X(A^{-1}(y-b))|\frac{\partial y}{\partial x}|^{-1}\\
&amp;=f_X(A^{-1}(y-b))|\frac{1}{\det A}|\\
&amp;=\frac{1}{(2\pi)^{\frac{n}{2}}\sqrt {\det
ABA^{t}}}\exp\left(-\frac{1}{2}(A^{-1}(\vec y-\vec b)-\vec
\mu)^TB^{-1}(A^{-1}(\vec y-\vec b)-\vec \mu)\right)\\
&amp;=\frac{1}{(2\pi)^{\frac{n}{2}}\sqrt {\det
ABA^{t}}}\exp\left(-\frac{1}{2}(\vec y-A\vec \mu-\vec
b)^T(ABA^{T})^{-1}(A^{-1}(\vec y-A\vec \mu-\vec b)\right)
\end{aligned}
\]</span>
此外,一般的多为高斯分布可以看作独立同分布标准正态分布线性变换后的结果,原因是当<span class="math inline">\(X\sim N(0,I),Y\sim N(\vec
\mu,B)\)</span>,当然有<span class="math inline">\(Y=B^{\frac{1}{2}}X+\vec \mu\)</span>.</p>
<p>特别地,把一个有一定信息关系的东西<span class="math inline">\(Y\)</span>变成<span class="math inline">\(X\)</span>也只需要<span class="math inline">\(X=B^{-\frac{1}{2}}(X-\vec \mu
)\)</span>,这个过程一般叫<strong>白化</strong>.因为信息被缩简单了.</p>
<p>然而,考虑如果<span class="math inline">\(X\sim
N(0,I)\)</span>,如果<span class="math inline">\(Y=AX\)</span>,此时<span class="math inline">\(Y\)</span>的结果似乎只和<span class="math inline">\(AA^t\)</span>有关,而与<span class="math inline">\(A\)</span>竟然无关.特别地,如果<span class="math inline">\(A\)</span>是一个正交矩阵,则<span class="math inline">\(Y\)</span>干脆和<span class="math inline">\(X\)</span>服从同样的分布.</p>
<p>这揭示了正态分布其实更关注于<strong>模长</strong>,换言之,当<span class="math inline">\(\vec \mu=0,B=I\)</span>的时候,<span class="math inline">\(f(\vec y)\)</span>其实是只和<span class="math inline">\(\vec
y\)</span>的模长相关的.此时如果看它的等密度轮廓线其实是一圈又一圈的圆.而拉伸之后就成了某种一圈又一圈的椭圆(因为要拉伸呀).</p>
<h3><span id="卷积">卷积</span></h3>
<p>若<span class="math inline">\(X,Y\)</span>相互独立,考虑<span class="math inline">\(Z=X+Y\)</span>,则<span class="math inline">\(f_Z(z)=\int_{-\infty}^{+\infty}f_X(z-y)f_Y(y)\mathrm{d}y\)</span>.</p>
<h2><span id="熵">熵</span></h2>
<p>离散情况下将熵定义为<span class="math inline">\(H[X]=E(\log
\frac{1}{P(X)})=\sum_{i}P_i\log \frac{1}{P_i}\)</span>.如果设<span class="math inline">\(|X|=|\{x|P(x)&gt;0\}|\)</span>,则容易见到<span class="math inline">\(0\leq H[X]\leq \log|X|\)</span>.</p>
<p>接下来我们想定义条件熵,直观的理解是”去掉<span class="math inline">\(X\)</span>的信息后<span class="math inline">\(Y\)</span>还剩多少信息”: <span class="math display">\[
\begin{aligned}
H[Y|X]&amp;=\sum_xH[Y|X=x]P[X=x]\\
&amp;=\sum_x\sum_yP(Y=y|X=x)P[X=x]\lg\frac{1}{P(Y=y|X=x)}\\
&amp;=\sum_{x,y}P(Y=y,X=x)\lg\frac{1}{P(Y=y|X=x)}\\
&amp;=E(\lg\frac{1}{P(Y|X)})
\end{aligned}
\]</span></p>
<p>首先检验<span class="math inline">\(f(x)=x\ln
x\)</span>是下凸函数,原因是<span class="math inline">\(f&#39;(x)=1+\ln
x\)</span>而<span class="math inline">\(f&#39;&#39;(x)=\frac{1}{x}&gt;0\)</span>.于是琴生不等式给出<span class="math inline">\(f(\frac{a+b}{2})\leq
\frac{f(a)+f(b)}{2}\)</span>,或说<span class="math inline">\(E(f(X))\geq
f(E(X))\)</span>.</p>
<p>另外一个很重要的工具是对数求和不等式,对于任何非负实数<span class="math inline">\(a_1,\cdots,a_n\)</span>和正数<span class="math inline">\(b_1,\cdots,b_n\)</span>,记<span class="math inline">\(a=\sum_i a_i,b=\sum_i b_i\)</span>,则: <span class="math display">\[
\sum_i a_i\log\frac{a_i}{b_i}\geq a\log \frac{a}{b}
\]</span> 一个重要的性质是证明其是上凸函数,对于任意分布<span class="math inline">\(P,Q\)</span>和<span class="math inline">\(\lambda\in (0,1)\)</span>,都有: <span class="math display">\[
H[\lambda P+(1-\lambda)Q]\geq \lambda H[P]+(1-\lambda)H[Q]
\]</span> 原因是考虑: <span class="math display">\[
f(\lambda p_i+(1-\lambda)q_i)\leq \lambda f(p_i)+(1-\lambda)f(q_i)
\]</span> 可以见到以下性质:</p>
<ol type="1">
<li><span class="math inline">\(H[X,Y]=H[X]+H[Y|X]\)</span>.</li>
<li><span class="math inline">\(H[X|Y]\leq H[X]\)</span>.</li>
<li>作为(2)的推论,互信息<span class="math inline">\(I(X,Y)=H[X]+H[Y]-H[X,Y]=H[X]-H[X|Y]\geq
0\)</span>.</li>
<li>对于一个确定性函数<span class="math inline">\(g\)</span>,<span class="math inline">\(H[X]\geq H[g(X)]\)</span>.</li>
<li><span class="math inline">\(I(X;YZ)=I(X;Z)+I(X;Y|Z)\)</span>.</li>
<li><span class="math inline">\(I(X;Y\mid Z)\leq
I(X;Y)+H(Z)\)</span>.</li>
<li>当<span class="math inline">\(X,Y,Z\)</span>满足Markov规则,或者说<span class="math inline">\(P_{X,Y,Z}=P_XP_{Y|X}P_{Z|Y}\)</span>,或说<span class="math inline">\(P_{Z|Y}=P_{Z|XY}\)</span>,则<span class="math inline">\(I(X;Y)=I(X;Z)+I(X;Y|Z)\)</span>.这自然推出<span class="math inline">\(I(X;Y)\geq
I(X;Z)\)</span>,也即这个过程中信息不会增多.</li>
</ol>
<p>(1)是上述的一个显然推论.</p>
<p>(2)的话考虑: <span class="math display">\[
\begin{aligned}
&amp;H[X]-H[X|Y]\\
=&amp;\sum_x\left(P(X=x)\lg \frac{1}{P(X=x)}-\sum_y P(X=x,Y=y)\lg
\frac{1}{P(X=x|Y=y)}\right)\\
=&amp;\sum_x\left(\sum_y P(X=x,Y=y)\lg
\frac{P(X=x|Y=y)}{P(X=x)}\right)\\
=&amp;\sum_x\sum_y P(X=x,Y=y)\lg \frac{P(X=x,Y=y)}{P(X=x)P(Y=y)}\\
\end{aligned}
\]</span> 不妨令<span class="math inline">\(a_i=P(X=x,Y=y),b_i=P(X=x)P(Y=y)\)</span>.容易见到<span class="math inline">\(a=\sum_i a_i=1,b=\sum_i
b_i=1\)</span>.于是上式变为: <span class="math display">\[
\begin{aligned}
&amp;H[X]-H[X|Y]\\
=&amp;\sum_i a_i\lg \frac{a_i}{b_i}\\
=&amp;-\sum_i a_i\lg \frac{b_i}{a_i}\\
\geq &amp;-\sum_i a_i (\frac{b_i}{a_i}-1)\\
=&amp;-\sum_i (b_i-a_i)\\
=&amp;0
\end{aligned}
\]</span> 对于(4),轻易地: <span class="math display">\[
\begin{aligned}
H[X,g(X)]&amp;=H[g(X)]+H[X|g(X)]\\
H[X]&amp;=H[g(X)]+H[X|g(X)]
\end{aligned}
\]</span> 然而后者非负,于是显然.特别地,当<span class="math inline">\(g\)</span>是一个单射的时候,<span class="math inline">\(H[X]=H[g(X)]\)</span>.</p>
<p>对于(5),留神到<span class="math inline">\(H[X]=I(X;Z)+H[X|Z]\)</span>,考虑: <span class="math display">\[
\begin{aligned}
I(X;YZ)&amp;=H[X]-H[X|YZ]\\
&amp;=I(X;Z)+H[X|Z]-H[X|YZ]
\end{aligned}
\]</span> 然而<span class="math inline">\(I(X;Y\mid Z)=H[X|
Z]-H[(X|Y)|Z]=H[X|Z]-H[X|YZ]\)</span>.</p>
<p>对于(6),考虑: <span class="math display">\[
\begin{aligned}
I(X;YZ)&amp;=I(X;Z)+I(X;Y\mid Z)\\
&amp;=I(X;Y)+I(X;Z\mid Y)\\
I(X;Y\mid Z)&amp;=I(X;Y)+I(X;Z\mid Y)-I(X;Z)\\
\end{aligned}
\]</span> 然而<span class="math inline">\(I(X;Z\mid
Y)=H[Z|Y]-H[X|YZ]\leq H[Z]\)</span>,而<span class="math inline">\(I(X;Z)\geq 0\)</span>,于是显然.</p>
<p>对于(7),考虑: <span class="math display">\[
\begin{aligned}
I(X;YZ)&amp;=I(X;Y)+I(X;Z\mid Y)\\
I(X;YZ)&amp;=I(X;Z)+I(X;Y\mid Z)\\
\end{aligned}
\]</span> 此外: <span class="math display">\[
\begin{aligned}
I(X;Y)+I(X;Z\mid Y)&amp;=H[X]-H[X|Y]+H[Z|Y]-H[Z|YX]\\
&amp;=H[X]-H[X|Y]+H[Z|Y]-H[Z|Y]\\
&amp;=I(X;Y)
\end{aligned}
\]</span> 于是<span class="math inline">\(I(X;Z\mid
Y)=0\)</span>,这就证毕.</p>
<h3><span id="kl散度">KL散度</span></h3>
<p>定义<span class="math inline">\(D(P||Q)=\sum_x P(x)\lg
\frac{P(x)}{Q(x)}\)</span>.其中如果<span class="math inline">\(P(x)\ne
0\)</span>而<span class="math inline">\(Q(x)=0\)</span>的情况出现,我们就说此时其为<span class="math inline">\(+\infty\)</span>.我们想要证明:<span class="math inline">\(D(P||Q)\geq 0\)</span>.考虑: <span class="math display">\[
\begin{aligned}
D(P||Q)&amp;=E_{x\sim Q}(\frac{P(X)}{Q(X)}\lg \frac{P(X)}{Q(X)})\\
&amp;\geq f\left(E_{x\sim Q}(\frac{P(X)}{Q(X)})\right)\\
&amp;=f(1)\\
&amp;=0
\end{aligned}
\]</span> 从而这的确是某种衡量偏离程度的算子.</p>
此外还应当定义条件KL散度.考察: $$
<span class="math display">\[\begin{aligned}
D(P_{X,Z}||Q_{X,Z})&amp;=\sum_{(x,z)} P_{X,Z}(x,z)\log
\frac{P_{X,Z}(x,z)}{Q_{X,Z}(x,z)}\\
&amp;=\sum_{(x,z)} P_{Z|X}(z|x)P_{X}(x)\log
\frac{P_{Z|X}(z|x)P_{X}(x)}{Q_{Z|X}(z|x)Q_{X}(x)}\\

&amp;=D(P_X||Q_X)+\sum_{(x,z)} P_{Z|X}(z|x)P_{X}(x)\log
\frac{P_{Z|X}(z|x)}{Q_{Z|X}(z|x)}\\
\end{aligned}\]</span>
<p>$$ 将后面的部分定义为<span class="math inline">\(D(P_{Y|X}||Q_{Y|X}\mid
P_X)\)</span>.顺便应该有<span class="math inline">\(D(P_{X,Z}||Q_{X,Z})\geq D(P_X||Q_X)\)</span>.</p>
<p>此外还应当证明KL散度凸性.对于概率分布对<span class="math inline">\((P_1,Q_1),(P_2,Q_2)\)</span>,以及任意<span class="math inline">\(\theta\in [0,1]\)</span>,令<span class="math inline">\(P=\theta P_1+(1-\theta)P_2,Q=\theta
Q_1+(1-\theta)Q_2\)</span>.下面我们证明下凸: <span class="math display">\[
D(P||Q)\leq \theta D(P_1||Q_1)+(1-\theta)D(P_2||Q_2)
\]</span></p>
<p>此外,有趣的性质是证明<span class="math inline">\(I(X;Y)=D(P_{XY}||P_XP_Y)\)</span>,不过这个只需简单转化即可.</p>
<p>另外,对任意<span class="math inline">\(P_X,Q_X\)</span>和kernel<span class="math inline">\(P_{Y|X}\)</span>,令<span class="math inline">\(P_Y=P_X\circ P_{Y|X}\)</span>,<span class="math inline">\(Q_Y=Q_X\circ P_{Y|X}\)</span>.
散度的data-processing不等式给出:<span class="math inline">\(D(P_X||Q_X)\geq D(P_Y||Q_Y)\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证<span class="math inline">\(d(p||q)=D(\mathrm{Bern}(p)||\mathrm{Bern}(q))\geq
(2\log e)(p-q)^2\)</span>.</p>
<p>具体来说,<span class="math inline">\(d(p||q)=p\log
\frac{p}{q}+(1-p)\log \frac{1-p}{1-q }\)</span>.</p>
<h3><span id="编码">编码</span></h3>
<h4><span id="一般无损编码">一般无损编码</span></h4>
<p>考虑一个编码-解码过程,要求编码器Encode是一个到<span class="math inline">\(\{0,1\}^*\)</span>的单射,从而存在其的一个左逆Decode满足$((x))=x
$.</p>
<p>对于编码,我们非常在意的是它的长度.考虑设<span class="math inline">\(L(X)=\text{len}(\text{Encode}(X))\)</span>,我们下面将会估计<span class="math inline">\(E(L(X))\)</span>的大小.</p>
<p>首先证明其下界,我们断言: <span class="math display">\[
H(X)-H(L)\leq E[L(X)]
\]</span> 由于<span class="math inline">\(H(X)-H(L)=H(X|L)\)</span>,因此其实只需要证明<span class="math inline">\(H(X|L)\leq
E[L]\)</span>.由于该编码无损,不妨设<span class="math inline">\(n(l)\)</span>为满足<span class="math inline">\(L(x)=l\)</span>的数量,容易见到<span class="math inline">\(n(l)\leq 2^l\)</span>,立刻有<span class="math inline">\(H(X|L=l)=\log_2 n(l)\leq l\)</span>.于是: <span class="math display">\[
H(X|L)=\sum_l P(L=l)H(X|L=l)\leq \sum_{l}P(L=l)l=E[L]
\]</span> 此外我们还想要估计<span class="math inline">\(H(L)\)</span>具体有多大,事实上: <span class="math display">\[
H(L)\leq \log_2(e(1+E[L]))
\]</span> 下面来看一种比较优秀的编码方式.不妨假设<span class="math inline">\(P(x_1)\geq P(x_2)\geq
\cdots\)</span>,于是自然有<span class="math inline">\(P(x_i)\geq
\frac{1}{i}\)</span>.取码长<span class="math inline">\(L(x_i)=\lfloor
\log_2i\rfloor\)</span>.其实就是按照出现的频率用小码,则: <span class="math display">\[
\begin{aligned}
E[L(X)]&amp;=\sum_i P(x_i)\lfloor \log_2 i\rfloor\\
&amp;\leq \sum_i P(x_i)\log_2 i\\
&amp;\leq \sum_i P(x_i)\log_2 \frac{1}{P(x_i)}\\
&amp;=H(X)
\end{aligned}
\]</span></p>
<h4><span id="前缀码">前缀码</span></h4>
<p>一个更合适的例子是前缀码,对于一个<span class="math inline">\(L(X)\)</span>函数,我们声称存在前缀码<span class="math inline">\(f\)</span>使得<span class="math inline">\(|f(x_i)|=L(x_i)\)</span>,当且仅当<span class="math inline">\(\sum_{x\in A}2^{-L(x)}\leq
1\)</span>,原因是在二叉树上表示一下.</p>
<p>众所周知Huffman编码是最优编码,现在我们来看它为什么优秀,我们说其满足<span class="math inline">\(H(X)\leq E[L(X)]\leq
H(X)+1\)</span>,下面我们来证明这个结论.</p>
<p>先证上界,由于Huffman编码是最优编码,我们只要选取任意一个编码,使得它的界<span class="math inline">\(\leq
H(X)+1\)</span>即可.根据上面的引理,我们直接将<span class="math inline">\(x\)</span>映射到一个长度为<span class="math inline">\(\lceil \log
\frac{1}{P(x)}\rceil\)</span>的前缀编码.此时: <span class="math display">\[
\begin{aligned}
E(L(X))&amp;=\sum_{x}P(x)\lceil \log \frac{1}{P(x)}\rceil\\
&amp;\leq \sum_{x}P(x)\left(\log \frac{1}{P(x)}+1\right)\\
&amp;=H(X)+1
\end{aligned}
\]</span> 再来看下界.来证明任意前缀编码都会被这个下界控制住.</p>
<p>对于一个前缀编码,实际上是把<span class="math inline">\(X\)</span>映射到了另一个<span class="math inline">\(Y\)</span>处.由于这是一个单射,所以有<span class="math inline">\(H(X)=H(Y)\)</span>.然而: <span class="math display">\[
\begin{aligned}
H(Y)&amp;=\sum_{t}H(Y_t|Y_{1}\cdots Y_{t-1})\\
\end{aligned}
\]</span> 来看一个特定的<span class="math inline">\(H(Y_t|Y_1\cdots
Y_{t-1}=y_1\cdots y_{t-1})\)</span>,如果此时<span class="math inline">\(y_1\cdots y_{t-1}\)</span>已经能解码了,那<span class="math inline">\(Y_t\)</span>就一定是空白,因此此时熵为<span class="math inline">\(0\)</span>;反之,则<span class="math inline">\(Y_t\)</span>要么是<span class="math inline">\(0\)</span>要么是<span class="math inline">\(1\)</span>,伯努利分布的最大值只有<span class="math inline">\(\log_2
2=1\)</span>.因此我们可以发现,对于一个特定的<span class="math inline">\(x\)</span>和对应的<span class="math inline">\(y_1\cdots y_k\)</span>,一定有<span class="math inline">\(H(Y_t|Y_1\cdots Y_{t-1}=y_1\cdots y_{t-1})\leq
Pr[L(x)\geq t]\)</span>.</p>
<p>所以实际上<span class="math inline">\(H(Y)\leq \sum_t Pr[L(X)\geq
t]=E(L)\)</span>.</p>
<h4><span id="几乎无损压缩">几乎无损压缩</span></h4>
<p>对于独立同分布<span class="math inline">\(X^n\)</span>,如果满足:
<span class="math display">\[
Pr[\text{Decode}(\text{Encode}(X^n))=X^n]\geq 1-\epsilon,\epsilon\to 0
\]</span> 则称其为几乎无损压缩.不妨记录<span class="math inline">\(\vec
X\sim X^n\)</span>.</p>
<p>现在我们来看做到几乎无损压缩需要怎么办.我们将说明几乎就一定需要<span class="math inline">\(nH(X)\)</span>左右的信息长度才足够.事实上:</p>
<ol type="1">
<li><span class="math inline">\(\forall
\delta&gt;0\)</span>,存在编码方案使得<span class="math inline">\(L\leq
n(H(X)+\delta)\)</span>,并且错误概率趋近于<span class="math inline">\(0\)</span>.</li>
<li><span class="math inline">\(\forall \delta&gt;0\)</span>,如果<span class="math inline">\(L&lt;n(H(X)-\delta)\)</span>,则无论怎么编码,错误概率趋近于<span class="math inline">\(1\)</span>.</li>
</ol>
<p>先来证明(1),考虑直接取<span class="math inline">\(L=n(H(X)+\delta)\)</span>,并且编码出现概率最大的前<span class="math inline">\(2^L\)</span>个元素,剩下的扔掉.不妨可以发现我们只会扔掉所有<span class="math inline">\(P(\vec X)\leq
2^{-n(H(X)+\delta)}\)</span>的,原因是比这个阈值大的不可能超过<span class="math inline">\(2^L\)</span>个.然而留意到<span class="math inline">\(P(\vec X=(x_1,\cdots,x_n))=\prod_i
P(X=x_i)\)</span>: <span class="math display">\[
\begin{aligned}
Pr[P(\vec X)\leq 2^{-n(H(X)+\delta)}]&amp;=Pr[-\log_2P(\vec X)\geq
n(H(X)+\delta)]\\
&amp;=Pr[-\sum_i\log_2P(X_i)\geq n(H(X)+\delta)]\\
\end{aligned}
\]</span> 可是<span class="math inline">\(\sum_i -\log_2
P(X_i)\)</span>的期望恰好为<span class="math inline">\(H(X)\)</span>,因此根据Chernoff-Hoeffding
Bound,这个错误概率<span class="math inline">\(\leq
e^{-O(n\delta^2)}\)</span>.</p>
<p>那么反过来的界怎么证明呢?此时最多可编码<span class="math inline">\(2^{n(H(X)-\delta)}\)</span>个元素.仍然用Chernoff
Bound就可以搞定了.</p>
<h4><span id="通用压缩">通用压缩</span></h4>
<p>我们上面的所有讨论都基于已知分布的情况.如果我们不知道分布,又能做到多好的编码呢?</p>
<p>当编码的时候不知道分布,但解码的时候知道分布的时候,事实上可以做到:<span class="math inline">\(\varlimsup_{n\to \infty}\frac{1}{n}E[L_n(X^n)]\leq
H(X)+\epsilon\)</span>,其中<span class="math inline">\(\epsilon\)</span>可以任意小.</p>
<p>这个怎么做呢?考虑一个暴力方法,我先随便将信息映射到<span class="math inline">\(\{0,1\}^L\)</span>.此时的Encode并非单射.解码的时候直接最大似然估计找最好的那个解码.</p>
<p>假设<span class="math inline">\(x_i\to c_i\)</span>,并且<span class="math inline">\(P(x_1)\geq P(x_2)\geq
\cdots\)</span>,取一个阈值<span class="math inline">\(M=2^{n(H(X)+\delta)}\)</span>,以及<span class="math inline">\(L=n(H(X)+2\delta)\)</span>现在来看失败概率也就是:
<span class="math display">\[
\begin{aligned}
&amp;\sum_{i} P(x_i)Pr[c_i\in \{c_1,\cdots,c_{i-1}\}]\\
=&amp;\sum_{i=1}^M P(x_i)Pr[c_i\in \{c_1,\cdots,c_{i-1}\}]+\sum_{i\geq
M} P(x_i)Pr[c_i\in \{c_1,\cdots,c_{i-1}\}]\\
\leq &amp;\sum_{i=1}^M P(x_i)\frac{M}{2^L}+2^{-O(n\delta^2)}\\
\leq &amp;2^{-O(n\delta)}+2^{-O(n\delta^2)}\\
\end{aligned}
\]</span> 这个错误概率就很小了.</p>
<h3><span id="信道编码">信道编码</span></h3>
<p>定义<strong>信道</strong>为某种会”污染”信息的东西,或者干脆写称条件概率分布<span class="math inline">\(P_{Y|X}\)</span>.此外定义<strong>信道容量</strong><span class="math inline">\(C=\max_{P_X}I(X;Y)\)</span>,其中<span class="math inline">\((X,Y)\sim P_XP_{Y|X}\)</span>.</p>
<p>现在我们考虑一个一般的信道编码,取<span class="math inline">\(W\to
\vec X\in \mathcal{X}^L\to \vec Y\in \mathcal{Y}^L\to \hat
W\)</span>.</p>
<p>现在我们来证明以下性质:</p>
<ol type="1">
<li><span class="math inline">\(I(\vec X;\vec Y)\leq L\sdot
C\)</span></li>
<li>data-processing不等式:<span class="math inline">\(I(W;\hat W)\leq
I(\vec X;\vec Y)\)</span></li>
</ol>
<p>对于(1),由于<span class="math inline">\(Y_i\)</span>独立地依赖于<span class="math inline">\(X_i\)</span>,考虑: <span class="math display">\[
\begin{aligned}
I(\vec X;\vec Y)&amp;=\sum_i I(\vec X;Y_i\mid Y_1\cdots Y_{i-1})\\
&amp;=\sum_i I(X_i;Y_i)\\
&amp;\leq L\sdot C
\end{aligned}
\]</span> 至于(2),实际上是互信息的data-processing不等式.</p>
<p>接下来我们要搞定传送速率的问题.不妨设<span class="math inline">\(n=H(W)\)</span>,现在我们将要证明: <span class="math display">\[
n\leq\frac{LC+H(\epsilon)}{1-\epsilon}
\]</span> 其中<span class="math inline">\(\epsilon\)</span>是可接受的最大错误概率,定义为<span class="math inline">\(\epsilon=\max_w Pr[\hat W\ne W|W=w]\)</span>.</p>
<p>怎么证明呢?考虑取一个指示变量<span class="math inline">\(Z\)</span>,当<span class="math inline">\(\hat W\ne
W\)</span>的时候<span class="math inline">\(Z=1\)</span>,否则<span class="math inline">\(Z=0\)</span>.不妨直接让<span class="math inline">\(Z\)</span>多错一点,到达<span class="math inline">\(Pr[Z=1|W=w]\equiv
\epsilon\)</span>以方便我们下面的分析.这样的话<span class="math inline">\(Z\)</span>和<span class="math inline">\(W\)</span>就独立了.此时立刻见到: <span class="math display">\[
(1-\epsilon)I(W;\hat W\mid Z=0)\leq I(W;\hat W\mid Z)\leq I(W;\hat
W)+H(Z)
\]</span> 而<span class="math inline">\(I(W;\hat W\mid
Z=0)=I(W;W)=H(W)=n\)</span>.</p>
<h2><span id="极限的情况">极限的情况</span></h2>
<h3><span id="尾不等式">尾不等式</span></h3>
<p>留神到如果事件在<span class="math inline">\(n\)</span>次中发生了<span class="math inline">\(n_a\)</span>次,其实是不能说<span class="math inline">\(\lim_{n\to
\infty}\frac{n_a}{n}=P\)</span>的.因为后面总是会有微小的扰动.但似乎总能刻画这些微小扰动的代价.</p>
<p>设<span class="math inline">\(f_n(A)=\frac{n_a}{n}\)</span>.如果我们能求出<span class="math inline">\(P(|f_n-p|\geq \epsilon)=P(|n_a-E(n_a)|\geq
n\epsilon)\)</span>的上界,看上去就会非常优秀.进一步地:</p>
<ol type="1">
<li>尾不等式:给出<span class="math inline">\(P(X\geq
k)\)</span>的上界.</li>
<li>集中不等式:给出<span class="math inline">\(P(|X-E(X)|\geq
k)\)</span>的上界.</li>
</ol>
<h6><span id="example1">Example1</span></h6>
<p>对二项分布用Chebyshev不等式,轻易有: <span class="math display">\[
P(|n_A-E(n_A)|\geq n\epsilon)\leq \frac{p(1-p)}{n\epsilon^2}
\]</span> 这个估计有点菜,右侧是<span class="math inline">\(O(\frac{1}{n})\)</span>的,这个趋近也太慢了.</p>
<p>考虑一下它为什么菜,问题在于Chebyshev不等式只用到了”两两独立”这件事,但是实际上二项分布更强一点,它其实是”互相独立”的.</p>
<h4><span id="矩">矩</span></h4>
<p>定义<span class="math inline">\(E(X^k)\)</span>为<span class="math inline">\(X\)</span>的<strong><span class="math inline">\(k\)</span>阶原点矩</strong>,而将<span class="math inline">\(E((X-E(X))^k)\)</span>称为<span class="math inline">\(X\)</span>的<strong><span class="math inline">\(k\)</span>阶中心距</strong>.则期望是其一阶原点矩而方差是二阶中心矩.</p>
<p>对于随机变量<span class="math inline">\(X\)</span>,定义<span class="math inline">\(M_X(t)=E(e^{tX})\)</span>为<span class="math inline">\(X\)</span>的<strong>矩生成函数</strong>.考虑:
<span class="math display">\[
\begin{aligned}
E(e^{Xt})&amp;=\sum_{k=0}^ne^{kt}P(X=k)\\
&amp;=\sum_{k=0}^nP(X=k)\left(\sum_{j=0}^{+\infty}\frac{(kt)^j}{j!}\right)\\
&amp;=\sum_{j=0}^{\infty}\frac{t^j}{j!}\sum_{k=0}^nP(X=k)k^j\\
&amp;=\sum_{j=0}^\infty \frac{t^j}{j!}E(X^j)
\end{aligned}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>对<span class="math inline">\(X\sim B(n,p)\)</span>,求<span class="math inline">\(E((X-E(X))^4)\)</span>.</p>
<p>考虑其矩生成函数: <span class="math display">\[
\begin{aligned}
E(e^{Xt})&amp;=\sum_{k=0}^ne^{kt}P(X=k)\\
&amp;=\sum_{k=0}^ne^{kt}\binom{n}{k}p^k(1-p)^{n-k}\\
&amp;=\sum_{k=0}^n\binom{n}{k}(pe^{t})^k(1-p)^{n-k}\\
&amp;=(pe^t+(1-p))^n\\
&amp;=(1+p(e^t-1))^n
\end{aligned}
\]</span> 令<span class="math inline">\(Y=X-E(X)\)</span>,则<span class="math inline">\(E(e^{Yt})=E(e^{Xt})e^{-tpn}\)</span>,现在我们可以对其求四次导数得到:
<span class="math display">\[
E((X-E(X))^4)=np(1-p)^4+n(1-p)p^4+3n(n-1)p^2(1-p^2)
\]</span> 那这个有什么用呢?考虑对其用Markov不等式: <span class="math display">\[
P((X-E(X))^4\geq (n\epsilon)^4)\leq
\frac{O(n^2)}{(n\epsilon)^4}=O(\frac{1}{n^2\epsilon^4})
\]</span> 这的确给出了一个更好的估计.</p>
<p>但是再做六阶矩好像也很痛苦,而且这只能给出一个多项式估计,但看着这个逼近速度就不太可能是多项式估计,那怎么办呢?</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>考虑直接对<span class="math inline">\(e^{tX}\)</span>用Markov不等式:</p>
<ol type="1">
<li>当<span class="math inline">\(t&gt;0\)</span>的时候,有<span class="math inline">\(P(X\geq k)\leq M_X(t)e^{-tk}\)</span>.</li>
<li>当<span class="math inline">\(t&lt;0\)</span>的时候,有<span class="math inline">\(P(X\leq k)\leq M_X(t)e^{-tk}\)</span>.</li>
</ol>
<p>左侧没有<span class="math inline">\(t\)</span>而右侧有,那看上去只要找到能使右侧取到最小值的<span class="math inline">\(t\)</span>就万事大吉了.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(X\sim
\pi(\lambda)\)</span>的时候,求<span class="math inline">\(P(X\geq
x)\)</span>的上界.其中<span class="math inline">\(x&gt;\lambda\)</span>.</p>
<p>先求此时的矩生成函数: <span class="math display">\[
\begin{aligned}
E(e^{Xt})&amp;=e^{-\lambda}\sum_{k\geq 0}\frac{\lambda^k}{k!}e^{kt}\\
&amp;=e^{-\lambda}\sum_{k\geq 0}\frac{(\lambda e^t)^k}{k!}\\
&amp;=e^{\lambda (e^t-1)}
\end{aligned}
\]</span> 当<span class="math inline">\(t&gt;0\)</span>的时候,我们想要优化<span class="math inline">\(e^{\lambda(e^t-1)-tx}\)</span>的最小值,直接对<span class="math inline">\(t\)</span>求导,发现当<span class="math inline">\(t=\ln\frac{x}{\lambda}\)</span>时最小.</p>
<p>此时: <span class="math display">\[
P(X\geq x)\leq \frac{e^{-\lambda}(e\lambda)^x}{x^x}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>当<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>,求<span class="math inline">\(P(X-E(X)\geq k\sigma)\)</span>的上界.</p>
<p>还是求矩生成函数,考虑: <span class="math display">\[
E(e^{tX})=\int_{-\infty}^{+\infty}\frac{1}{\sqrt
{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}+tx}=e^{\mu
t+\frac{\sigma^2t^2}{2}}
\]</span> 从而: <span class="math display">\[
P(X\geq k\sigma+\mu)\leq e^{\mu
t+\frac{\sigma^2t^2}{2}}e^{-t(\mu+k\sigma)}=e^{\frac{\sigma^2t^2}{2}-k\sigma
t}
\]</span> 当<span class="math inline">\(t=\frac{k}{\sigma}\)</span>的时候取最小值,从而最后的界是<span class="math inline">\(e^{-\frac{k^2}{2}}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>当<span class="math inline">\(X\sim B(n,p)\)</span>,求<span class="math inline">\(P(X-E(X)\geq n\epsilon)\)</span>的上界.</p>
<p>考虑<span class="math inline">\(M_X(t)=(1-p+pe^t)^n\)</span>.</p>
<p>然后需要一个Lemma,我们说<span class="math inline">\((1-p)e^{-tp}+pe^{t(1-p)}\leq
e^{\frac{t^2}{8}}\)</span>,这个会在后面的Hoeffding引理证明.</p>
<p>直接带入,右侧为: <span class="math display">\[
\begin{aligned}
M_X(t)e^{-t(E(X)+n\epsilon)}&amp;=e^{-tn\epsilon}\left((1-p)e^{-tp}+pe^{t(1-p)}\right)^n\\
&amp;\leq e^{-tn\epsilon+\frac{nt^2}{8}}
\end{aligned}
\]</span> 取<span class="math inline">\(t=4\epsilon\)</span>得到<span class="math inline">\(e^{-2n\epsilon^2}\)</span>的上界.</p>
<p>此外取<span class="math inline">\(t=-4\epsilon\)</span>得到<span class="math inline">\(P(X-E(X)\leq -n\epsilon)\)</span>的上界为<span class="math inline">\(e^{-2n\epsilon^2}\)</span>.</p>
<p>于是我们有<span class="math inline">\(P(|X-E(X)|\geq n\epsilon)\leq
2e^{-2n\epsilon^2}\)</span>.</p>
<h4><span id="hoeffding引理">Hoeffding引理</span></h4>
<p>若实数随机变量<span class="math inline">\(a\leq X\leq
b\)</span>,则<span class="math inline">\(M_{X-E(X)}(t)=E(e^{t(X-E(X))})\leq
e^{\frac{t^2(b-a)^2}{8}}\)</span>.</p>
<h6><span id="example1chernoff-hoeffding不等式">Example1(Chernoff-Hoeffding不等式)</span></h6>
<p>若<span class="math inline">\(X=\sum_{i=1}^n X_i\)</span>,其中<span class="math inline">\(X_i\)</span>相互独立且<span class="math inline">\(a\leq X_i\leq b\)</span>.则(<span class="math inline">\(k&gt; 0\)</span>):</p>
<ol type="1">
<li><span class="math inline">\(P(X\geq E(X)+k)\leq
e^{-\frac{2k^2}{n(b-a)^2}}\)</span>.</li>
<li><span class="math inline">\(P(X\leq E(X)-k)\leq
e^{-\frac{2k^2}{n(b-a)^2}}\)</span>.</li>
</ol>
<p>怎么证明呢,考虑<span class="math inline">\(P(X\geq E(X)+k)\leq
M_{X-E(X)}(t)e^{-tk}\)</span>.</p>
<p>然而: <span class="math display">\[
\begin{aligned}
M_{X-E(X)}(t)&amp;=E(e^{t(X-E(X))})\\
&amp;=E(\prod_i e^{t(X_i-E(X_i))})\\
&amp;=\prod_i E(e^{t(X_i-E(X_i))})\\
&amp;=\prod_i M_{X_i-E(X_i)}(t)\\
&amp;\leq e^{n\frac{t^2(b-a)^2}{8}}
\end{aligned}
\]</span> 接下来对后面那个东西最优化,可以发现<span class="math inline">\(t=\frac{4k}{n(b-a)^2}\)</span>的时候足够优秀,这就证明了上面的不等式.</p>
<h4><span id="sanov-bound">Sanov Bound</span></h4>
<p>回忆到斯特林公式<span class="math inline">\(n!\sim \sqrt{2\pi
n}(\frac{n}{e})^n\)</span>.</p>
<p>先来看一个在二项分布上的版本,不妨设<span class="math inline">\(X_1,\cdots,X_n\sim
\mathrm{Bern}(p)\)</span>,而<span class="math inline">\(q&gt;p\)</span>,我们断言: <span class="math display">\[
\frac{1}{n+1}\exp(-nd(q||p))\leq Pr[\sum_i^n X_i\geq qn]\leq
(n(1-q)+1)\exp(-nd(q||p))
\]</span> 为此留神到<span class="math inline">\(Pr[\sum_i^n X_i\geq
qn]=\sum_{t=qn}^n\binom{n}{t}p^t(1-p)^{n-t}\)</span>,容易证明当<span class="math inline">\(q&gt;p\)</span>的时候,<span class="math inline">\(\binom{n}{t}p^t(1-p)^{n-t}\)</span>单调下降.</p>
<p>此时来看<span class="math inline">\(\binom{n}{qn}\)</span>的取值:
<span class="math display">\[
\begin{aligned}
1&amp;\geq \binom{n}{qn}q^{qn}(1-q)^{n-qn}\\
\binom{n}{qn}&amp;\leq \frac{1}{q^{qn}(1-q)^{n-qn}}\\
&amp;=\left((\frac{1}{q})^q(\frac{1}{1-q})^{1-q}\right)^n\\
&amp;=\left(\exp(q\ln  \frac{1}{q}+(1-q)\ln \frac{1}{1-q})\right)^n\\
&amp;=\exp(nh(q))
\end{aligned}
\]</span> 此外,我们知道<span class="math inline">\(\binom{n}{t}q^{t}(1-q)^{n-t}\)</span>在<span class="math inline">\(t=qn\)</span>处取最大值,从而$
q<sup>{qn}(1-q)</sup>{n-qn}<span class="math inline">\(,于是给出\)</span>(nh(q))(nh(q))$.</p>
<p>此时观察: <span class="math display">\[
\begin{aligned}
\exp(nh(q))p^{qn}(1-p)^{n-qn}&amp;=\exp(nh(q))\exp(n(q\ln p+(1-q)\ln
(1-p)))\\
&amp;=\exp(n(q\ln \frac{p}{q}+(1-q)\ln \frac{1-p}{1-q}))\\
&amp;=\exp(-nd(q||p))
\end{aligned}
\]</span> 从而给出了上面的答案.</p>
<p>现在来看一个一般的版本.对于一个可能的空间<span class="math inline">\(\Omega=\{v_1,\cdots
v_L\}\)</span>,现在有一个分布<span class="math inline">\(P:\Omega\to
[0,1]\)</span>,记录<span class="math inline">\(p_i=P(v_i)\)</span>.</p>
<p>现在从<span class="math inline">\(P\)</span>中独立取样<span class="math inline">\(x_1,\cdots,x_n\)</span>.考虑对于一个特定的可重集合<span class="math inline">\(S\)</span>,求<span class="math inline">\(Pr[\{x_1,\cdots
,x_n\}=S]\)</span>.回忆到可重集的定义为<span class="math inline">\(S:\Omega\to\mathbb{N}\)</span>,不妨干脆记录<span class="math inline">\(s_i=S(v_i)\)</span>.容易发现<span class="math inline">\(Pr[\{x_1,\cdots
,x_n\}=S]=\binom{n}{s_1,\cdots,s_L}p_1^{s_1}\cdots
p_L^{s_L}\)</span>.</p>
<p>现在考虑一个新的分布<span class="math inline">\(Q:\Omega\to
[0,1]\)</span>,其中<span class="math inline">\(q_i=\frac{s_i}{n}\)</span>,此时如果采样<span class="math inline">\(y_1,\cdots,y_n\sim Q\)</span>的时候,先来看看<span class="math inline">\(Pr[\{y_1,\cdots,y_n\}=S]\)</span>.</p>
<p>容易见到<span class="math inline">\(|\Omega\to \mathbb N|\leq
\frac{1}{(n+1)^{L-1}}\)</span>,从而见到以下简单估计(需要证明当前的情况的概率是所有情况中最大的):
<span class="math display">\[
\begin{gathered}
\frac{1}{(n+1)^{L-1}}\leq Pr[\{y_1,\cdots,y_n\}=S]\leq 1\\
\frac{1}{(n+1)^{L-1}}\leq \binom{n}{s_1,\cdots,s_L}\leq
\left((\frac{1}{q_1})^{q_1}\cdots (\frac{1}{q_L})^{q_L}\right)^n\\
\frac{\exp(nH(Q))}{(n+1)^{L-1}}\leq \binom{n}{s_1,\cdots,s_L}\leq
\exp(nH(Q))\\
\end{gathered}
\]</span> 这给出了<span class="math inline">\(\binom{n}{s_1,\cdots,s_L}\)</span>的一个上下界.</p>
<p>现在回看: <span class="math display">\[
\begin{aligned}
Pr[\{x_1,\cdots ,x_n\}=S]&amp;=\binom{n}{s_1,\cdots,s_L}p_1^{s_1}\cdots
p_L^{s_L}\\
&amp;\leq \exp(nH(Q))\exp(n\sum_i q_i\log p_i)\\
&amp;=\exp(-nD(Q||P))
\end{aligned}
\]</span></p>
<p>左侧也有类似的结论.</p>
<p>如果这里把<span class="math inline">\(\{x_1,\cdots
,x_n\}=S\)</span>弱化到<span class="math inline">\(\{x_1,\cdots
,x_n\}\in A\)</span>,则右边当然要补一个<span class="math inline">\(|A|\)</span>,当然显然<span class="math inline">\(|A|\leq (n+1)^{L-1}\)</span></p>
<h3><span id="大数定律">大数定律</span></h3>
<p>对于随机变量<span class="math inline">\(\{X_i\}\)</span>,对于任意<span class="math inline">\(\epsilon&gt;0\)</span>,如果: <span class="math display">\[
\lim_{n\to \infty} P(|\frac{1}{n}\sum_i^n X_i-\frac{1}{n}\sum_i^n
E(X_i)|&lt;\epsilon)=1
\]</span> 则称它们满足大数定律.</p>
<p>一般而言,对于一列随机变量<span class="math inline">\(\{Y_i\}\)</span>和一个随机变量<span class="math inline">\(Y\)</span>,如果<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,<span class="math inline">\(\lim_{n\to
\infty}P(|Y_n-Y|&lt;\epsilon)=1\)</span>,则称其<strong>依概率收敛</strong>.</p>
<h4><span id="markov大数定律">Markov大数定律</span></h4>
<p>若<span class="math inline">\(\mathrm{Var}(\sum X_i)\sim
o(n^2)\)</span>,则<span class="math inline">\(\{X_n\}\)</span>符合大数定律.</p>
<p>策略是考虑<span class="math inline">\(\mathrm{Var}(\frac{\sum
X_i}{n})=\frac{1}{n^2}\mathrm{Var}(\sum
X_i)\)</span>.用Chebyshev不等式碾一下就好了.</p>
<h4><span id="khinchin大数定律弱大数定律">Khinchin大数定律(弱大数定律)</span></h4>
<p>设<span class="math inline">\(\{X_i\}\)</span>独立同分布,且数学期望<span class="math inline">\(\mu=E(X_i)\)</span>存在,则<span class="math inline">\(\{X_i\}\)</span>满足大数定律.</p>
<h3><span id="特征函数">特征函数</span></h3>
<p>对于随机变量<span class="math inline">\(X\)</span>,设<span class="math inline">\(\phi_X(t)=E(e^{itX})\)</span>为其特征函数.容易见到<span class="math inline">\(\phi_X(-it)=E(e^{tX})\)</span>.一些常见的特征函数:</p>
<ol type="1">
<li><span class="math inline">\(X\sim
\pi(\lambda),M_X(t)=e^{\lambda(e^t-1)},\phi_X(t)=e^{\lambda(e^{it}-1)}\)</span>.</li>
<li><span class="math inline">\(X\sim N(\mu,\sigma^2),M_X(t)=e^{\mu
t+\frac{\sigma^2t^2}{2}},\phi_X(t)=e^{i\mu
t-\frac{\sigma^2t^2}{2}}\)</span>.</li>
<li><span class="math inline">\(X\sim
B(n,p),M_X(t)=(1-p+pe^t)^n,\phi_X(t)=(1-p+pe^{it})^n\)</span>.</li>
<li><span class="math inline">\(X\)</span>服从柯西分布,<span class="math inline">\(f(x)=\frac{1}{\pi(x^2+1)}\)</span>,则<span class="math inline">\(\phi_X(t)=e^{-|t|}\)</span>.</li>
</ol>
<p>随机变量的分布函数由其特征函数唯一确定.此外,依分布收敛等价于特征函数逐点收敛.</p>
<p>依照上面的结论,就可以拿到<span class="math inline">\(X_n\sim
\pi(n)\)</span>推出<span class="math inline">\(\frac{X_n-n}{\sqrt n}\to
N(0,1)\)</span>,原因正是上面的依分布收敛的性质.</p>
<h3><span id="中心极限定理">中心极限定理</span></h3>
<p>先来看Lindeberg-Levy版本:</p>
<p>设<span class="math inline">\(\{X_n\}\)</span>独立同分布,而且<span class="math inline">\(E(X_n)=\mu,\mathrm{Var}(X_n)=\sigma^2\)</span>,设<span class="math inline">\(Y_n=\sum_i^n X_i\)</span>,而<span class="math inline">\(\tilde{Y}_n=\frac{Y_n-E(Y_n)}{\sigma(Y_n)}=\frac{\sum_i^n
(X_i-\mu)}{\sqrt n\sigma}\)</span>.</p>
<p>我们断言<span class="math inline">\(\tilde
Y_n\)</span>一定依分布收敛于<span class="math inline">\(Z\)</span>,其中<span class="math inline">\(Z\sim
N(0,1)\)</span>.</p>
<p>为什么呢?用泰勒展开考虑<span class="math inline">\(\Re
\phi_{X_n-\mu}(t)=1-\frac{\sigma^2}{2}t^2+o(t^2)\)</span>.此时<span class="math inline">\(\Re \phi_{\tilde
Y_n}(t)=(1-\frac{t^2}{2n}+o(\frac{t^2}{n}))^n\to
e^{-\frac{t^2}{2}}\)</span>.</p>
<p>现在来看一个强的版本:</p>
<p>Berry-Esseen定理:在上述版本的基础上,如果<span class="math inline">\(E(|X_n-\mu|^3)\)</span>有限,则收敛速度有: <span class="math display">\[
|P(\tilde Y_n\leq x)-P(Z\leq x)|\leq
O(1)\frac{E(|X_n-\mu|^3)}{\sigma^3\sqrt{n}}
\]</span></p>
<h2><span id="统计">统计</span></h2>
<h3><span id="点估计">点估计</span></h3>
<p>将只依赖于样本,不依赖于任何位置参数的函数称作<strong>统计量</strong>.例如:</p>
<ol type="1">
<li>样本均值<span class="math inline">\(\bar X=\frac{1}{n}\sum_{i=1}^n
X_i\)</span>.</li>
<li>样本方差<span class="math inline">\(S^2=\frac{1}{n-1}\sum_{i=1}^n(X_i-\bar
X)^2\)</span>.</li>
<li>样本<span class="math inline">\(k\)</span>阶矩<span class="math inline">\(A_k=\frac{1}{n}\sum_{i=1}^n X_i^k\)</span>.</li>
<li>样本<span class="math inline">\(k\)</span>阶中心矩<span class="math inline">\(B_k=\frac{1}{n}\sum_{i=1}^n(X_i-\bar
X)^k\)</span>.</li>
</ol>
<p>对于<span class="math inline">\(\theta\)</span>的估计量<span class="math inline">\(\hat
\theta\)</span>,定义<strong>偏差</strong><span class="math inline">\(\mathrm{Bias}(\hat \theta)=E(\hat
\theta)-\theta\)</span>.如果其等于<span class="math inline">\(0\)</span>,则称其是<strong>无偏</strong>的.如果<span class="math inline">\(\lim_{n\to \infty}\mathrm{Bias}(\hat
\theta)=\theta\)</span>,则称<span class="math inline">\(\hat\theta\)</span>是<strong>渐进无偏</strong>的.</p>
<p>此外定义<span class="math inline">\(\mathrm{MSE}(\hat
\theta)=E\left((\hat\theta-\theta)^2\right)\)</span>.容易见到: <span class="math display">\[
\begin{aligned}
\mathrm{MSE}(\hat\theta)&amp;=E\left((\hat\theta-\theta)^2\right)\\
&amp;=E\left((\hat\theta-E(\hat\theta)+E(\hat\theta)-\theta)^2\right)\\
&amp;=E\left((\hat\theta-E(\hat\theta))^2\right)+\left(E(\hat\theta)-\theta\right)^2\\
&amp;=\mathrm{Var}(\hat \theta)+\left(\mathrm{Bias}(\hat\theta)\right)^2
\end{aligned}
\]</span> 因此对于无偏估计的<span class="math inline">\(\mathrm{MSE}(\hat\theta)=\mathrm{Var}(\hat\theta)\)</span>.</p>
<p>此外,如果估计量依概率收敛,或言<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,<span class="math inline">\(\lim_{n\to
\infty}P\left(|\hat\theta_n-\theta|\geq
\epsilon\right)=0\)</span>,则称<span class="math inline">\(\hat\theta_n\)</span>是<strong>一致估计量</strong>.</p>
<p>我们有性质:如果<span class="math inline">\(\lim_{n\to
\infty}\mathrm{MSE}(\hat\theta_n)\to 0\)</span>,则<span class="math inline">\(\hat\theta_n\)</span>为一致估计量.原因是: <span class="math display">\[
\begin{aligned}
&amp;P\left(|\hat\theta_n-\theta|\geq \epsilon\right)\\
=&amp;P\left((\hat\theta_n-\theta)^2\geq \epsilon^2\right)\\
\leq &amp;\frac{\mathrm{MSE}(\hat\theta_n)}{\epsilon^2}
\end{aligned}
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(E(X)\)</span>和<span class="math inline">\(\mathrm{Var}(X)\)</span>均存在,独立随机的样本序列<span class="math inline">\(X_1,\cdots,X_n\)</span>,现在考虑<span class="math inline">\(\hat\theta_A=\bar X\)</span>,<span class="math inline">\(\hat \theta_B=X_1\)</span>.</p>
<p>显然它们都是<span class="math inline">\(E(X)\)</span>的无偏估计.然而<span class="math inline">\(\mathrm{MSE}(\hat\theta_A)=\frac{\mathrm{Var}(X)}{n}\)</span>,而<span class="math inline">\(\mathrm{MSE}(\hat\theta_B)=\mathrm{Var}(X)\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>假设已知<span class="math inline">\(X\sim
U(0,\theta)\)</span>.考虑<span class="math inline">\(\hat\theta_A=2\bar
X\)</span>和<span class="math inline">\(\hat\theta_B=\max_k\{X_k\}\)</span>.</p>
<p>容易见到<span class="math inline">\(\hat\theta_A\)</span>无偏.现在来看<span class="math inline">\(\hat\theta_B\)</span>,自然地: <span class="math display">\[
\begin{aligned}
F_{\hat\theta_B}(x)&amp;=(F_X(x))^n\\&amp;=(\frac{x}{\theta})^n\\
E(\hat\theta_B)&amp;=\int_0^{+\infty}(1-F_{\hat\theta_B}(x))\mathrm{d}x\\
&amp;=\int_0^\theta(1-(\frac{x}{\theta})^n)\mathrm{d}x\\
&amp;=\frac{n}{n+1}\theta
\end{aligned}
\]</span> 但至少<span class="math inline">\(\hat\theta_C=\frac{n+1}{n}\hat\theta_B\)</span>无偏.</p>
<p>现在来看,容易见到<span class="math inline">\(\mathrm{MSE}(\hat\theta)=\frac{\theta^2}{3n}\)</span>.留神到:
<span class="math display">\[
\begin{aligned}
E(\hat\theta_B^2)&amp;=\int_0^{\theta^2}\left(1-\frac{x^{\frac{n}{2}}}{\theta^n}\right)\mathrm{d}x\\
&amp;=\theta^2-\frac{2}{n+2}\theta^2\\
&amp;=\frac{n}{n+2}\theta^2
\end{aligned}
\]</span> 于是<span class="math inline">\(\mathrm{Var}(\hat\theta_C^2)=(\frac{n+1}{n})^2\mathrm{Var}(\hat\theta_B^2)=\frac{\theta^2}{n(n+2)}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑<span class="math inline">\(B_2\)</span>对<span class="math inline">\(\mathrm{Var}(X)\)</span>的估计,显然有<span class="math inline">\(B_2=\frac{1}{n}\sum_k X_k^2-(\bar
X)^2\)</span>.也就是说<span class="math inline">\(E(B_2)=E(X^2)-E(\bar
X^2)\)</span>.看上去欣欣向荣,然而: <span class="math display">\[
\begin{aligned}
E(\bar X^2)&amp;=E((\bar X-E(\bar X)+E(\bar X))^2)\\
&amp;=E((\bar X-E(\bar X))^2)+(E(\bar X))^2\\
&amp;=(E(\bar X))^2+\frac{\mathrm{Var}(X)}{n}
\end{aligned}
\]</span> 这就出事了.</p>
<h6><span id="example4正态分布">Example4(正态分布)</span></h6>
<p>考虑估计一个正态分布<span class="math inline">\(X\sim
N(\mu,\sigma^2)\)</span>.取<span class="math inline">\(\bar
X\)</span>和<span class="math inline">\(S^2\)</span>作为其期望和方差的估计量.现在我们将展示一个非常厉害的结论,那就是<span class="math inline">\(\bar X\)</span>和<span class="math inline">\(S^2\)</span>实际上是独立的.</p>
<p>考虑一个正交矩阵<span class="math inline">\(U\)</span>,其第一行每个元素限定为<span class="math inline">\(\frac{1}{\sqrt
n}\)</span>,其余行任取.由于其正交性,这必然意味着其余行所有元素之和为<span class="math inline">\(0\)</span>.现在来取<span class="math inline">\(\vec Y=U\vec X\)</span>.从前的结论告知我们<span class="math inline">\(\vec Y\)</span>服从<span class="math inline">\(n\)</span>维高斯分布.而且:</p>
<ol type="1">
<li><span class="math inline">\(E(\vec Y)=(\sqrt
n\mu,0,\cdots,0)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(\vec
Y)=\sigma^2I\)</span>.</li>
<li><span class="math inline">\(\sum_k Y_k^2=\sum_k X_k^2\)</span>.</li>
</ol>
<p>其中(1)是由于除第一行外,每一行的所有元素和为<span class="math inline">\(0\)</span>.(2)是因为原本的<span class="math inline">\(\vec
X\)</span>的各个分量独立.(3)是因为正交变换保模长.</p>
<p>此时必定有<span class="math inline">\(\bar X=\frac{Y_1}{\sqrt
n}\)</span>,事实上还有: <span class="math display">\[
\begin{aligned}
(n-1)S^2&amp;=\sum_{i=1}^n(X_i-\bar X)^2\\
&amp;=(\sum_k X_k^2)-n\bar X^2\\
&amp;=\sum_{k=1}^nY_k^2-Y_1^2\\
&amp;=\sum_{k=2}^nY_k^2
\end{aligned}
\]</span> 于是二者独立.还能得知<span class="math inline">\(\bar X\sim
N(\mu,\frac{\sigma^2}{n})\)</span>,以及<span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)\)</span>.</p>
<h4><span id="矩法">矩法</span></h4>
<p>显然<span class="math inline">\(k\)</span>阶矩的估计总是无偏的.因此一个想法是将我们想要估计的量写成矩的函数,再分别估计矩(注意,这样做在该函数并非一次的时候当然未必无偏).</p>
<h4><span id="最大似然估计">最大似然估计</span></h4>
<p>尝试选择参数<span class="math inline">\(\theta\)</span>,使得<span class="math inline">\(L(\theta)=P(X_1=x_1,\cdots,X_n=x_n|\theta)\)</span>最大.</p>
<p>如果样本干脆是均匀随机的,那就只需要最大化对数似然函数<span class="math inline">\(\ln L(\theta)=\sum_{i=1}^n \ln
P(X_i=x_i|\theta)\)</span>.</p>
<p>这样做当然不可能是无偏的.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑一个均匀分布<span class="math inline">\(U(0,\theta)\)</span>,对其进行最大似然估计的结果是<span class="math inline">\(\hat\theta=\max\{x_1,\cdots,x_n\}\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>考虑一个分类函数<span class="math inline">\(f:X\to
Y\)</span>.现在我们已经有其采样的一些结果<span class="math inline">\((x_i,y_i)\)</span>,想要去估计一个函数<span class="math inline">\(f_\theta\)</span>.根据上面说的,我们需要最小化<span class="math inline">\(\sum_{i=1}^n-\ln f_\theta(y_i|x_i)\)</span>.</p>
<p>现在考虑一个标签分布<span class="math inline">\(g(y|x_i)=[y=y_i]\)</span>.我们来看交叉熵: <span class="math display">\[
\begin{aligned}
H(g,f_\theta)&amp;=-\sum_{y}g(y|x_i)\ln f_\theta(y|x_i)\\
&amp;=-\ln f_\theta(y_i|x_i)
\end{aligned}
\]</span></p>
<h3><span id="区间估计">区间估计</span></h3>
<p>我们想要更进一步,对于一个想要估计量<span class="math inline">\(\theta\)</span>,以及两个统计量<span class="math inline">\(\hat\theta_L\)</span>和<span class="math inline">\(\hat\theta_R\)</span>,如果必有<span class="math inline">\(P(\hat\theta_L\leq \theta\leq \hat\theta_U)\geq
1-\alpha\)</span>,则称<span class="math inline">\([\hat\theta_L,\hat\theta_R]\)</span>为<span class="math inline">\(\theta\)</span>的<strong>置信水平</strong>为<span class="math inline">\(1-\alpha\)</span>的<strong>置信区间</strong>.类似还可以定义<strong>单侧置信下限</strong>和<strong>单侧置信上限</strong>.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于一个<span class="math inline">\(X\sim
N(\mu,\sigma^2)\)</span>,假设<span class="math inline">\(\sigma^2\)</span>已知,设计一个对<span class="math inline">\(\mu\)</span>的置信水平为<span class="math inline">\(1-\alpha\)</span>的估计.</p>
<p>考虑<span class="math inline">\(\bar X\sim
N(\mu,\frac{\sigma^2}{n})\)</span>.此时必定有<span class="math inline">\(\frac{\bar X-\mu}{\frac{\sigma}{\sqrt{n}}}\sim
N(0,1)\)</span>.只需要取一组<span class="math inline">\(c,d\)</span>,使得<span class="math inline">\(P(c\leq \frac{\bar
X-\mu}{\frac{\sigma}{\sqrt{n}}}\leq d)=1-\alpha\)</span>即可.</p>
<p>现在取<span class="math inline">\(\Phi(x)=\int_{-\infty}^x\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}\mathrm{d}t\)</span>为其分布函数,取<span class="math inline">\(c=\Phi^{-1}(\frac{\alpha}{2}),d=\Phi^{-1}(1-\frac{\alpha}{2})\)</span>.留神到<span class="math inline">\(c+d=0\)</span>.化简就有: <span class="math display">\[
P(\bar X-\frac{\Phi^{-1}(1-\frac{\alpha}{2})\sigma}{\sqrt n}\leq \mu\leq
\bar X+\frac{\Phi^{-1}(1-\frac{\alpha}{2})\sigma}{\sqrt n})=1-\alpha
\]</span> 不过这个估计因为要算<span class="math inline">\(\Phi^{-1}\)</span>,可能意义不是特别大.回忆到Chernoff
Bound给出: <span class="math display">\[
P(X-E(X)\geq k\sigma)\leq e^{-\frac{k^2}{2}}
\]</span> 于是立刻有<span class="math inline">\(P(|\bar X-\mu|\geq
\frac{k\sigma}{\sqrt n})\leq 2e^{-\frac{k^2}{2}}\)</span>.</p>
<p>从而: <span class="math display">\[
P(\bar X-\frac{\sigma\sqrt{2\ln(\frac{2}{\alpha})}}{\sqrt n}\leq \mu\leq
\bar X+\frac{\sigma\sqrt{2\ln(\frac{2}{\alpha})}}{\sqrt n})\geq 1-\alpha
\]</span>
现在我们来干另一件事,众所周知,中心极限定理说大部分估计最后都会趋于一个正态分布.那么在此时,能否估计出<span class="math inline">\(P(\mu=\bar X)=O(\frac{1}{\sqrt n})\)</span>呢?</p>
<p>考虑取<span class="math inline">\(\alpha=1-O(\frac{1}{\sqrt
n})\)</span>,就可以发现这个时候的<span class="math inline">\(\mu\)</span>已经落在<span class="math inline">\(\bar X\pm O(1)\)</span>的区间内了.</p>
<h6><span id="example2">Example2</span></h6>
<p>考虑对<span class="math inline">\(X\sim B(1,p)\)</span>.设计<span class="math inline">\(p\)</span>的置信水平<span class="math inline">\(1-\alpha\)</span>的置信区间.</p>
<p>直接考虑Chernoff Bound,给出<span class="math inline">\(P(|\bar
X-p|&gt;\epsilon)\leq 2e^{-2n\epsilon^2}\)</span>.取<span class="math inline">\(\epsilon=\sqrt{\frac{\ln\frac{2}{\alpha}}{2n}}\)</span>,于是:
<span class="math display">\[
P(\bar X-\sqrt{\frac{\ln(\frac{2}{\alpha})}{2n}}\leq p\leq \bar
X+\sqrt{\frac{\ln(\frac{2}{\alpha})}{2n}})\geq 1-\alpha
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数论相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-15 21:35:01" itemprop="dateModified" datetime="2025-08-15T21:35:01+08:00">2025-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2>
<h3><span id="维度">维度</span></h3>
<h4><span id="b维正交范围">B维正交范围</span></h4>
<p>对于一个<span class="math inline">\(B\)</span>维的点<span class="math inline">\(x\)</span>,满足<span class="math inline">\(\forall
1 \leq i \leq B , l_i \leq x_i \leq
r_i\)</span>,称所有这样的点组成的集合为一个<span class="math inline">\(B\)</span>维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果<span class="math inline">\(l ,
r\)</span>有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个<span class="math inline">\(B\)</span>维正交范围有<span class="math inline">\(k\)</span>个有用限制,称它为<span class="math inline">\(k - side\)</span>的.</p>
<p>例如,找到区间<span class="math inline">\([ l , r ]\)</span>中<span class="math inline">\(&lt; x\)</span>的元素,这个矩形是<span class="math inline">\(3 - side\)</span>的.找到区间<span class="math inline">\([ 1 , l ]\)</span>中<span class="math inline">\(&lt; x\)</span>的元素,这个矩形是<span class="math inline">\(2 -
side\)</span>的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3>
<h4><span id="矩阵乘法">矩阵乘法</span></h4>
<p>做<span class="math inline">\(n \times
n\)</span>的矩阵乘法目前得到的最优秀复杂度也是<span class="math inline">\(O ( n^{ 2 . 373 } )\)</span>.</p>
<p>另外可以归约:<span class="math inline">\(01\)</span>矩阵和整数矩阵在去除<span class="math inline">\(\log n\)</span>后的复杂度相同.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5>
<p>考虑构造一棵树:他有<span class="math inline">\(\sqrt{ n
}\)</span>个叉,每个叉上有<span class="math inline">\(\sqrt{ n
}\)</span>个点.我们将这些叉编号为<span class="math inline">\([ 1 ,
\sqrt{ n } ]\)</span>.然后我们考虑询问两个叉所组成的链的答案,设<span class="math inline">\(f_{ i , j }\)</span>表示数字<span class="math inline">\(j\)</span>是否在<span class="math inline">\(i\)</span>的叉上出现过,不难发现它们合并的时候要对<span class="math inline">\(f\)</span>做或运算,<span class="math inline">\(01\)</span>矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5>
<p>考虑对序列和值域同时分块,考虑序列中第<span class="math inline">\(L\)</span>到第<span class="math inline">\(R\)</span>个块的答案,设为<span class="math inline">\(f ( L , R )\)</span>,这两块间的答案设为<span class="math inline">\(g ( L , R )\)</span>,显然<span class="math inline">\(f ( L , R ) = f ( L + 1 , R ) + f ( L , R - 1 ) -
f ( L + 1 , R - 1 ) + g ( L , R )\)</span>,而由于对值域分块,<span class="math inline">\(g ( L , R ) = \sum a \times
b\)</span>的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5>
<p>平面上有若干点,两个操作:每次将横坐标小于等于<span class="math inline">\(A\)</span>的点加上<span class="math inline">\(v\)</span>,或者查询纵坐标小于等于<span class="math inline">\(B\)</span>的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="分块">分块</span></h3>
<h5><span id="example1luogup8527ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</span></h5>
<p>首先将<span class="math inline">\(a\)</span>分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的<span class="math inline">\(L\)</span>的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为<span class="math inline">\(B\)</span>,暴力处理散块的复杂度是<span class="math inline">\(O ( Bm )\)</span>,处理整块的复杂度是<span class="math inline">\(O ( \frac{ n }{ B } ( m + n \log n )
)\)</span>.取<span class="math inline">\(B^2 = \frac{ n }{ m } ( m + n
\log n ) = 500\)</span>最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了<span class="math inline">\(B =
2048\)</span>.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079riapq">Example2(luogu[Ynoi2079]
riapq)</span></h5>
<p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了<span class="math inline">\([ 1
, l - 1 ]\)</span>对<span class="math inline">\([ l , r
]\)</span>的贡献.</p>
<p>先序列分块.然后<span class="math inline">\([ 1 , l - 1
]\)</span>中的整块对<span class="math inline">\([ l , r
]\)</span>的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将<span class="math inline">\([ 1 , l - 1
]\)</span>中的整块的树状数组进行一个<span class="math inline">\([ l , r
]\)</span>的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到<span class="math inline">\(O ( Bq \log n )\)</span>的时间复杂度和<span class="math inline">\(O ( Bn )\)</span>的空间复杂度.</p>
<p>问题在于<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块咋办.首先<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块对<span class="math inline">\([ l , r
]\)</span>中的散块的贡献是好处理的,因为总共就<span class="math inline">\(O ( \frac{ n }{ B }
)\)</span>个数字,直接全部存下来排序做归并就可以统计,时间复杂度<span class="math inline">\(O ( Bq \log n )\)</span>.</p>
<p>现在的问题在于<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块对<span class="math inline">\([ l , r
]\)</span>中的整块如何贡献.能不能把<span class="math inline">\([ l , r
]\)</span>的信息统计在<span class="math inline">\([ 1 , l - 1
]\)</span>的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有<span class="math inline">\(\frac{ n }{ B }\)</span>个,整块一共有<span class="math inline">\(B\)</span>个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为<span class="math inline">\(O ( n \sqrt{ n } \log n
)\)</span>,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</span></h5>
<p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu6331">Example4(Walking Plan HDU
6331)</span></h5>
<p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度<span class="math inline">\(O ( nq )\)</span>.</p>
<h5><span id="example5p5063-ynoi2014置身天上之森">Example5(P5063 [Ynoi2014]
置身天上之森)</span></h5>
<p>考虑如果<span class="math inline">\(n =
2^k\)</span>,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的<span class="math inline">\(a\)</span>(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是<span class="math inline">\(n\)</span>不一定是<span class="math inline">\(2^k\)</span>,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5>
<p>大概是对于每个块处理出它的值域范围:一开始是<span class="math inline">\([ 1 , n
]\)</span>,然后每次操作都会将整个块分为两部分:<span class="math inline">\([ 1 , x )\)</span>和<span class="math inline">\([
x , maxn ]\)</span>,讨论一下<span class="math inline">\(maxn\)</span>和<span class="math inline">\(2
x\)</span>的大小,就可以用<span class="math inline">\(\min ( x , maxn - x
)\)</span>的复杂度使得<span class="math inline">\(maxn\)</span>变成<span class="math inline">\(maxn - x\)</span>,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3>
<h5><span id="example1luogup5047ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5>
<p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到<span class="math inline">\(O ( n \sqrt{ n } \log n )\)</span>.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为<span class="math inline">\([
l , r ]\)</span>对<span class="math inline">\(r\)</span>的贡献实际上就是<span class="math inline">\([ 1 , r ]\)</span>对<span class="math inline">\(r\)</span>的贡献减去<span class="math inline">\([
1 , l - 1 ]\)</span>对<span class="math inline">\(r\)</span>的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入<span class="math inline">\(O ( n )\)</span>次但是需要查询<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到<span class="math inline">\(O ( n )\)</span>.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3>
<p>我们现在有一个需要维护的<span class="math inline">\(n \times
n\)</span>的平面,我们现在对其进行分块:</p>
<ol type="1">
<li><p>将平面分成<span class="math inline">\(n^{ \frac{ 1 }{ 2 }
}\)</span>个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times n^{
\frac{ 3 }{ 4 } }\)</span>的<span class="math inline">\(A\)</span>块,以<span class="math inline">\(A\)</span>块为单位做二维前缀和.</p></li>
<li><p>每个<span class="math inline">\(A\)</span>块内部分成<span class="math inline">\(n^{ \frac{ 1 }{ 2 } }\)</span>个<span class="math inline">\(n^{ \frac{ 1 }{ 2 } } \times n^{ \frac{ 1 }{ 2 }
}\)</span>的<span class="math inline">\(B\)</span>块,在<span class="math inline">\(A\)</span>块内部以<span class="math inline">\(B\)</span>块为单位做二维前缀和.</p></li>
<li><p>将整个平面横着分别分成一个个<span class="math inline">\(n \times
n^{ \frac{ 3 }{ 4 } }\)</span>的<span class="math inline">\(C\)</span>块.(竖着也要分成一个个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times
n\)</span>的块,是类似的,略去)</p></li>
<li><p>每个<span class="math inline">\(C\)</span>块内部分成<span class="math inline">\(\sqrt{ n }\)</span>个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times n^{ \frac{ 1 }{ 2 }
}\)</span>个<span class="math inline">\(D\)</span>块,在<span class="math inline">\(C\)</span>块内部以<span class="math inline">\(D\)</span>块为单位做二位前缀和.</p></li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.同时注意到空间复杂度是<span class="math inline">\(O ( n
)\)</span>的.</p>
<p>查询显然是分四种情况讨论:<span class="math inline">\(A , B ,
D\)</span>块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应<span class="math inline">\(O ( 1 )\)</span>个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个<span class="math inline">\(l\)</span>对应<span class="math inline">\(O ( 1
)\)</span>个<span class="math inline">\(r\)</span>,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有<span class="math inline">\(O ( \sqrt{ n }
)\)</span>个查询,记录一下即可.这样就做到了<span class="math inline">\(O
( \sqrt{ n } )\)</span>单点改,<span class="math inline">\(O ( 1
)\)</span>查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现<span class="math inline">\(O
( 1 )\)</span>单点改,那这种情况下如何实现<span class="math inline">\(O (
\sqrt{ n } )\)</span>求和呢?首先还是可以<span class="math inline">\(O (
\sqrt{ n } )\)</span>求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度<span class="math inline">\(&lt; n^{ \frac{ 1 }{ 2 }
}\)</span>,我们就可以在每次查询的时候用<span class="math inline">\(\sqrt{ n
}\)</span>的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以<span class="math inline">\(O ( \sqrt{ n } )\)</span>求散块.</p>
<h5><span id="example1luogup7448-ynoi2007rdiq">Example1(luoguP7448 [Ynoi2007]
rdiq)</span></h5>
<p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和<span class="math inline">\(a_r\)</span>颜色相同的点是<span class="math inline">\(r
&#39;\)</span>,则显然新增的逆序对只可能出现在<span class="math inline">\([ r &#39; , r ]\)</span>中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从<span class="math inline">\(n \rightarrow
1\)</span>扫左端点,总共做<span class="math inline">\(O ( n
)\)</span>次单点修改,做<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为<span class="math inline">\(( r &#39; +
1 , a_r )\)</span>,右上角是<span class="math inline">\(( r , \infty
)\)</span>的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令<span class="math inline">\(rev ( x ) = n - x +
1\)</span>.然后将所有点的纵坐标<span class="math inline">\(rev\)</span>掉,现在我们要查询的也就是左下角为<span class="math inline">\(( r &#39; + 1 , 1 )\)</span>,右上角是<span class="math inline">\(( r , rev ( a_r )
)\)</span>的矩阵,这玩意可以拆前缀和拆成形如左下角是<span class="math inline">\(( 1 , 1 )\)</span>,右上角是<span class="math inline">\(( i , rev ( a_i )
)\)</span>的矩阵.也就是说我们的<span class="math inline">\(O ( n \sqrt{
n } )\)</span>次矩阵查询本质上只有<span class="math inline">\(O ( n
)\)</span>种.</p>
<p>拆到这里发现其实到这一步<span class="math inline">\(a_r\)</span>和<span class="math inline">\(a_{ r
&#39;
}\)</span>是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</span></h5>
<p>首先自然的想法是拿莫队扫掉<span class="math inline">\([ l_1 , r_1
]\)</span>这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维<span class="math inline">\([ l_2
, r_2
]\)</span>扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点<span class="math inline">\(( a , a )\)</span>上加上一个相应的<span class="math inline">\(b\)</span>,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点<span class="math inline">\(A ( x_1 , x_1 )\)</span>和<span class="math inline">\(B ( x_2 , x_2 )\)</span>之间的<span class="math inline">\(( x_1 , x_2 )\)</span>上加上一个<span class="math inline">\(- b\)</span>,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol type="1">
<li><p>莫队时查询一个点的前驱后继,这个操作就需要<span class="math inline">\(O ( 1 )\)</span>完成.</p></li>
<li><p><span class="math inline">\(n \sqrt{ n
}\)</span>次单点修改,这个操作需要<span class="math inline">\(O ( 1
)\)</span>完成.</p></li>
<li><p><span class="math inline">\(n\)</span>次矩阵求和,这个操作需要在小于<span class="math inline">\(O ( \sqrt{ n } )\)</span>的时间完成.</p></li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为<span class="math inline">\(O (
n \sqrt{ n }
)\)</span>,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3>
<h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5>
<p>首先反应是扔到trie上然后异或就是打个tag,但是<span class="math inline">\(+
1\)</span>很难处理,因为它形如在trie上找到所有长度连续为<span class="math inline">\(1\)</span>到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是<span class="math inline">\(+ 1\)</span>的话就相当于反转一条从根开始均为<span class="math inline">\(1\)</span>的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3>
<h4><span id="普通线段树">普通线段树</span></h4>
<h5><span id="example1luogup6780ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</span></h5>
<p>感觉这题比较厉害.</p>
<p>先扔做法:对<span class="math inline">\(c\)</span>分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求<span class="math inline">\(\max\)</span>.而对于块间如何做呢?</p>
<p>我们设<span class="math inline">\(suf_i\)</span>为前一个块的后<span class="math inline">\(i\)</span>个数之和,<span class="math inline">\(pre_i\)</span>为后一个块的前<span class="math inline">\(i\)</span>个数之和.注意到我们要求的就是<span class="math inline">\(\max \{ suf_i + pre_j | i + j \leq c
\}\)</span>.这个咋做呢?</p>
<p>你注意到这个<span class="math inline">\(i + j \leq
c\)</span>的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用<span class="math inline">\(j \rightarrow c - j +
1\)</span>的话,这个限制就转化为了<span class="math inline">\(i + c - j +
1 \leq c\)</span>,也就是<span class="math inline">\(i &lt;
j\)</span>,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对<span class="math inline">\(c\)</span>分块?</p>
<p>一方面,题目中的<span class="math inline">\(c\)</span>是给定的.另一方面,我们注意到我们需要维护一个和<span class="math inline">\(c\)</span>有关的东西,而如果没有<span class="math inline">\(c\)</span>,或者说<span class="math inline">\(c =
n\)</span>的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了<span class="math inline">\(c = n\)</span>的条件.考虑到这一点,对<span class="math inline">\(c\)</span>分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将<span class="math inline">\(a [ l - 1 ]\)</span>和<span class="math inline">\(a [ r + 1 ]\)</span>都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个<span class="math inline">\(maxn\)</span>设成<span class="math inline">\(-
\infty\)</span>的.如果这两个东西设成等大的<span class="math inline">\(-
\infty\)</span>,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比<span class="math inline">\(- \infty\)</span>还要小的数字,最底层的<span class="math inline">\(maxn\)</span>有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4>
<p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5>
<p>注意到每个点其实只需要找到<span class="math inline">\([ i - r_i , i -
1 ]\)</span>和<span class="math inline">\([ i + 1 , i + r_i
]\)</span>这两段的最大值,设为<span class="math inline">\(x\)</span>,则最后的答案就是<span class="math inline">\(\max \{ a_i + x \}\)</span>.</p>
<p>思考这个过程,我们将<span class="math inline">\([ i - r_i , i - 1
]\)</span>和<span class="math inline">\([ i + 1 , i + r_i
]\)</span>这两条线段以<span class="math inline">\(a_i\)</span>的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的<span class="math inline">\(a_i\)</span>的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4>
<h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5>
<p>考虑全局的和是<span class="math inline">\(sum\)</span>,则我们要在这些数中找到一个分界点,使得左边的和大于等于<span class="math inline">\(sum\)</span>,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(a_i , b_i\)</span>,选定至多<span class="math inline">\(k\)</span>个位置使这里的值为<span class="math inline">\(a_i - b_i\)</span>,其它位置的值是<span class="math inline">\(a_i\)</span>,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的<span class="math inline">\(mid\)</span>,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出<span class="math inline">\(\min_{ k = 1 }^r \{ \max ( \max_{ i = k + 1 }^n \{
sum_{ i } \} , - b_k + \max_{ i = 1 }^k \{ sum_i \} )
\}\)</span>.注意改掉一个位置后要把它的<span class="math inline">\(b\)</span>变成<span class="math inline">\(0\)</span>.</p>
<p>那么什么样的<span class="math inline">\(b\)</span>有可能是我们要选中的呢?显然可能被选中的<span class="math inline">\(b\)</span>一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:<span class="math inline">\(\min_{ k = 1 }^r \{ \max ( \max_{ i = k + 1 }^n \{
sum_{ i } \} , - \max_{ i = k }^n \{ b_i \} + \max_{ i = 1 }^k \{ sum_i
\} )
\}\)</span>,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的<span class="math inline">\(\max\)</span>尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \min_{ k = 1 }^r \{ \max ( sufmax ( sum )_{ k + 1 } , - sufmax ( b
)_k + premax ( sum )_k \} \\
= &amp; \min_{ k = 1 }^r \{ \max ( sufmax ( sum )_{ k + 1 } , - \max (
sufmax ( b )_{ k + 1 } , b_k ) + premax ( sum )_k \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的<span class="math inline">\(k\)</span>后面最大的<span class="math inline">\(b\)</span>,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响<span class="math inline">\(sufmax ( b
)\)</span>的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的<span class="math inline">\(b\)</span>,这个<span class="math inline">\(b\)</span>必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4>
<h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4>
<h4><span id="吉司机线段树">吉司机线段树</span></h4>
<h4><span id="李超线段树">李超线段树</span></h4>
<h3><span id="珂朵莉树">珂朵莉树</span></h3>
<h5><span id="example1luogup8512ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</span></h5>
<p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3>
<h3><span id="kd-tree">KD-Tree</span></h3>
<p>处理<span class="math inline">\(K\)</span>维正交范围(给定<span class="math inline">\(n\)</span>个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度<span class="math inline">\(O ( n^{ 1 - \frac{ 1 }{ k } } + \log n
)\)</span>.(单调修改复杂度只是<span class="math inline">\(O ( \log n
)\)</span>)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4>
<p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4>
<p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> siz;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">ll d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=cur[mid];</span><br><span class="line">tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line"><span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3>
<h5><span id="example1cfgym101613factor-freetree">Example1([CFgym101613]Factor-free
tree)</span></h5>
<p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是<span class="math inline">\(\sum dep_u\)</span>,是可以被卡成<span class="math inline">\(O ( n^2 )\)</span>的.</p>
<p>但我们考虑类似dsu on
tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5>
<p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为<span class="math inline">\([ l , r ]\)</span>,这样会有:<span class="math inline">\([ l - 1 , i - 1 ] \rightarrow [ i , r
]\)</span>.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3>
<h5><span id="exampleloj3151">Example(loj3151)</span></h5>
<p>首先自然地,我们设<span class="math inline">\(f_{ i , j
}\)</span>表示前<span class="math inline">\(i\)</span>个测试点已经分成了<span class="math inline">\(j\)</span>段的方案数,然后做转移,复杂度<span class="math inline">\(O ( T^2 S )\)</span>.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到<span class="math inline">\(k\)</span>最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把<span class="math inline">\([ l , r
]\)</span>分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点<span class="math inline">\(r\)</span>,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3>
<p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5>
<p>维护一个序列支持把<span class="math inline">\(x\)</span>位置的值改为<span class="math inline">\(y\)</span>或查询一个区间中小于<span class="math inline">\(y\)</span>的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</span></h5>
<p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开<span class="math inline">\(100\)</span>个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2>
<h3><span id="分开考虑">分开考虑</span></h3>
<h5><span id="example1p6105-ynoi2010y-fast-trie">Example1(P6105 [Ynoi2010]
y-fast trie)</span></h5>
<p>考虑只有两种可能:</p>
<ol type="1">
<li><p><span class="math inline">\(x + y &lt; C\)</span>,取<span class="math inline">\(x + y\)</span>作为答案.</p></li>
<li><p><span class="math inline">\(x + y \geq C\)</span>,取<span class="math inline">\(x + y - C\)</span>作为答案.</p></li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在<span class="math inline">\([ 0 , \lceil \frac{ C }{ 2 } \rceil
)\)</span>中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,<span class="math inline">\(x + y &lt; C\)</span>也就是<span class="math inline">\(x &lt; C -
y\)</span>,我们把第二个集合中的元素全部变成<span class="math inline">\(C
- y\)</span>后插入,只需最小化<span class="math inline">\(C - x -
y\)</span>,这个只需要维护最大的<span class="math inline">\(x\)</span>和最小的<span class="math inline">\(C -
y\)</span>就行.</p>
<h3><span id="合并信息">合并信息</span></h3>
<p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</span></h5>
<p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5>
<p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用<span class="math inline">\(O ( \log n
)\)</span>的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5>
<p>设<span class="math inline">\(w_i\)</span>为从上往下延伸到<span class="math inline">\(i\)</span>这个点后,还能多往下延伸多少,一开始<span class="math inline">\(w\)</span>都是<span class="math inline">\(-
1\)</span>,每次操作会让<span class="math inline">\(w + =
1\)</span>.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3>
<h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5>
<p>自然的想法是考虑找到每个点前面第一个和它之和为<span class="math inline">\(w\)</span>的数字,但这样就炸了,因为每修改一个点可能要影响<span class="math inline">\(O ( n )\)</span>个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为<span class="math inline">\(w\)</span>的数字,而显然只有两个数互相匹配才可行.如果<span class="math inline">\(i &lt; j &lt; k , ( i , j ) , ( i , k
)\)</span>分别配对,那么显然<span class="math inline">\(( i , k
)\)</span>没有用.这样每个点只有<span class="math inline">\(O ( 1
)\)</span>个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3>
<h5><span id="example1luogup5278算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</span></h5>
<p>首先考虑<span class="math inline">\(k =
1\)</span>怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p><span class="math inline">\(k \ne
1\)</span>怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在<span class="math inline">\(\bmod
k\)</span>意义下全部相等,维护差分数组的区间<span class="math inline">\(\gcd\)</span>就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5>
<p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为<span class="math inline">\(q\)</span>的衣服,<span class="math inline">\([ 0 ,
q )\)</span>的人肯定买不了,<span class="math inline">\([ q , 2 q - 1
]\)</span>的人买完后,手上的钱至少减半,我们暴力处理,至于<span class="math inline">\([ 2 q , + \infty
)\)</span>,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5>
<p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到<span class="math inline">\(0\)</span>,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</span></h5>
<p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是<span class="math inline">\(pre [ i ] = i - 1\)</span>).</p>
<h3><span id="根号分治">根号分治</span></h3>
<h5><span id="example1luogup7722-ynoi2007tmpq">Example1(luoguP7722 [Ynoi2007]
tmpq)</span></h5>
<p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改<span class="math inline">\(a , b ,
c\)</span>中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个数字<span class="math inline">\(x\)</span>,每次随机在<span class="math inline">\([ 1 , x ]\)</span>中一个数<span class="math inline">\(y\)</span>并令<span class="math inline">\(x
\leftarrow x \bmod y\)</span>,初始值为<span class="math inline">\(n\)</span>,求期望几次能变成<span class="math inline">\(0\)</span>.</p>
<p>注意到如果<span class="math inline">\(y\)</span>很小就直接做,<span class="math inline">\(y\)</span>很大的话<span class="math inline">\(\lfloor \frac{ x }{ y }
\rfloor\)</span>很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5>
<p>给定序列,每次询问给出两个数字<span class="math inline">\(x ,
y\)</span>,求最小的<span class="math inline">\(| i - j
|\)</span>满足<span class="math inline">\(a_i = x , a_j =
y\)</span>.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果<span class="math inline">\(x ,
y\)</span>出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5>
<p>首先对于<span class="math inline">\(Y\)</span>很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于<span class="math inline">\(Y\)</span>很大的情况,<span class="math inline">\(\frac{ n }{ Y
}\)</span>一定很小,我们不断查询大于等于<span class="math inline">\(kY\)</span>的最小元素即可,这个可以值域分块来根号平衡做到<span class="math inline">\(O ( 1 )\)</span>查询,<span class="math inline">\(O
( \sqrt{ n }
)\)</span>单点修改.具体地,我们对每个块处理出大于等于这个块的最小的<span class="math inline">\(X\)</span>,以及块内每个点后面最小的<span class="math inline">\(X\)</span>(必须在块内),然后定位到<span class="math inline">\(kY\)</span>的块.</p>
<h5><span id="example6">Example6</span></h5>
<p>给定<span class="math inline">\(n , m\)</span>,以及序列<span class="math inline">\(a\)</span>和长度为<span class="math inline">\(n\)</span>的排列<span class="math inline">\(y\)</span>,你需要回答<span class="math inline">\(m\)</span>个询问.对每个询问,给定<span class="math inline">\(l , r\)</span>,查询:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n \sum_{ j = i + 1 }^n [ a_i = a_j ] \prod_{ k = i }^j [
l \leq y_k \leq r ]
\]</span></p>
<p>注意到<span class="math inline">\(y_i =
i\)</span>的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点<span class="math inline">\(( x , y ) , a_x
= a_y , \nexists x &lt; z &lt; y , a_z = a_x\)</span>,对于<span class="math inline">\(( x , y
)\)</span>这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于<span class="math inline">\(\sqrt{ n
}\)</span>的数字,它们最多只有<span class="math inline">\(\sqrt{ n
}\)</span>个,考虑莫队复杂度<span class="math inline">\(O ( n \sqrt{ m }
+ m )\)</span>,因此我们可以对每个分别做莫队,总复杂度<span class="math inline">\(O ( n \sqrt{ m } + m \sqrt{ n }
)\)</span>,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于<span class="math inline">\(\sqrt{ n
}\)</span>的数字,这些数字一共最多有<span class="math inline">\(n\)</span>个,每个点暴力配对就有<span class="math inline">\(O ( n \sqrt{ n } )\)</span>个点对,然后<span class="math inline">\(O ( m
)\)</span>次询问,用根号平衡做扫描线,这里复杂度<span class="math inline">\(O ( n \sqrt{ n } + m \sqrt{ n } )\)</span>.</p>
<h3><span id="重链分治">重链分治</span></h3>
<h5><span id="example1luogu5314ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</span></h5>
<p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为<span class="math inline">\(1\)</span>,支持把一条链上所有点加上<span class="math inline">\(k\)</span>,或者查询距离一个点<span class="math inline">\(&lt; = 1\)</span>的所有点的点权<span class="math inline">\(kth\)</span>.<span class="math inline">\(n \leq 2
\times 10^5\)</span>.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改<span class="math inline">\(O ( \log n )\)</span>个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="一维扫描线">一维扫描线</span></h4>
<p>最经典的应用是对于一个<span class="math inline">\(B\)</span>维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个<span class="math inline">\(B -
1\)</span>维的动态问题.不过扫描线处理的时候可能需要是低<span class="math inline">\(side\)</span>的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4>
<p>也就是莫队.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1cf1609finteresting-sections">Example1(CF1609F
Interesting Sections)</span></h5>
<p>首先枚举每个数的<span class="math inline">\(popcount\)</span>,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点<span class="math inline">\(x\)</span>作为最大值的影响区间<span class="math inline">\([ l , r ]\)</span>,也就是如果一个区间左端点在<span class="math inline">\([ l , x ]\)</span>,右端点在<span class="math inline">\([ x , r
]\)</span>即可满足条件.我们考虑放入一个左下角坐标为<span class="math inline">\(( l , x )\)</span>,右上角坐标为<span class="math inline">\(( x , r
)\)</span>的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5>
<p>离散化,设<span class="math inline">\(S = \{ l \} \cup \{ r
\}\)</span>,考虑用<span class="math inline">\(len_i\)</span>表示<span class="math inline">\(i\)</span>节点及以前最多能有多少阳光.我们考虑用<span class="math inline">\(len_{ i - 1 }\)</span>更新<span class="math inline">\(len_i\)</span>,如果<span class="math inline">\([ i
- 1 , i ]\)</span>没被覆盖,显然直接加上这段的长度.如果<span class="math inline">\([ i - 1 , i
]\)</span>被覆盖大于两次,那显然直接继承<span class="math inline">\(len_{
i - 1 }\)</span>.</p>
<p>先考虑<span class="math inline">\([ i - 1 , i
]\)</span>被两朵云覆盖了怎么办,我们考虑用<span class="math inline">\(h_{
j , k }\)</span>表示当前被且只被<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>共同覆盖的区间长度,不难发现<span class="math inline">\(h_{ j , k
}\)</span>有值的地方很少,用map.然后还要加上它们各自的贡献,用<span class="math inline">\(g_j\)</span>表示当前被且只被<span class="math inline">\(j\)</span>覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断<span class="math inline">\([ i - 1 , i
]\)</span>是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果<span class="math inline">\([ i - 1 , i
]\)</span>被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为<span class="math inline">\(k\)</span>,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是<span class="math inline">\(g_j +
g_k\)</span>,用线段树处理出当前代价和小于等于<span class="math inline">\(C\)</span>的<span class="math inline">\(k\)</span>的<span class="math inline">\(g_k\)</span>的最大值就行.</p>
<p>再考虑有交的情况,答案应该为<span class="math inline">\(g_j + g_k +
h_{ j , k }\)</span>,我们在每次遇到<span class="math inline">\(( j , k
)\)</span>的时候都在对方那里打个tag就好,也就是对于每个<span class="math inline">\(j\)</span>,处理出和它有交的云中<span class="math inline">\(g_j + g_k + h_{ j , k
}\)</span>的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5>
<p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成<span class="math inline">\(0\)</span>后那些数一定没清空).</p>
<h5><span id="example4luogup7709wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5>
<p>如果初始序列全为<span class="math inline">\(0\)</span>:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5>
<p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5>
<p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是<span class="math inline">\(L &lt; R\)</span>,自然有<span class="math inline">\(L \leq \min \{ r_i \} , R \geq \max \{ l_i
\}\)</span>,那么当我们确定<span class="math inline">\(L\)</span>后,我们有<span class="math inline">\(R
\in [ \max \{ l_i \} , f ( L ) ]\)</span>.接下来我们考虑如何计算<span class="math inline">\(f ( L )\)</span>.</p>
<p>注意到<span class="math inline">\(L &lt; l_i \Rightarrow R \leq
r_i\)</span>,我们考虑将<span class="math inline">\(l_i\)</span>这个点的权值设成<span class="math inline">\(r_i\)</span>,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3>
<h4><span id="回滚莫队">回滚莫队</span></h4>
<h4><span id="带修莫队">带修莫队</span></h4>
<p>也就是维护三维的扫描线,根据KDT不难发现复杂度是<span class="math inline">\(O ( nm^{ \frac{ 2 }{ 3 } } )\)</span>,<span class="math inline">\(B = n^{ \frac{ 2 }{ 3 } }\)</span>,排序原则是<span class="math inline">\(( ls , rs , t
)\)</span>,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4>
<h4><span id="二次离线莫队">二次离线莫队</span></h4>
<p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个<span class="math inline">\(\log
n\)</span>的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带<span class="math inline">\(\log
n\)</span>的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有<span class="math inline">\(n
\sqrt{ n }\)</span>次询问,每次询问<span class="math inline">\(f ( l , r
, r + 1 )\)</span>表示区间<span class="math inline">\([ l , r
]\)</span>对<span class="math inline">\(r +
1\)</span>的逆序对贡献.考虑差分成<span class="math inline">\(f ( 1 , r ,
r + 1 ) - f ( 1 , l - 1 , r + 1
)\)</span>,前者显然可以迅速求出.而后者的右端点需要移动<span class="math inline">\(n\)</span>次,需要查询总共<span class="math inline">\(n \sqrt{ n }\)</span>次,zhe’ge</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5>
<p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都<span class="math inline">\(4 - side\)</span>了,但是有可减性,减成<span class="math inline">\(2 - side\)</span>就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5>
<p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉<span class="math inline">\(p =
2\)</span>和<span class="math inline">\(p =
5\)</span>的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字<span class="math inline">\(\bmod p\)</span>的值,设为<span class="math inline">\(suf_i\)</span>,假设存在两个点<span class="math inline">\(l , r\)</span>满足<span class="math inline">\(p |
( suf_l - suf_{ r + 1 } )\)</span>,那么<span class="math inline">\([ l ,
r ]\)</span>就是合法的,这是自然的,也就等价于<span class="math inline">\(suf_l = suf_{ r + 1 }\)</span>,相当于要对满足<span class="math inline">\(suf_l = suf_{ r + 1 }\)</span>的二元组<span class="math inline">\(( l , r )\)</span>计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604美好的每一天">Example3(luoguP3604
美好的每一天)</span></h5>
<p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3>
<p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的<span class="math inline">\(( l , r
)\)</span>的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5>
<p>考虑转化为二维平面,<span class="math inline">\(a_{ l , r } = maxn -
minn - ( r - l )\)</span>,显然只需要找到为<span class="math inline">\(0\)</span>的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有<span class="math inline">\(3 -
side\)</span>的,但是可差分成<span class="math inline">\(2 -
side\)</span>.</p>
<h3><span id="时间倒流">时间倒流</span></h3>
<h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5>
<p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5>
<p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3>
<h5><span id="example1cf1540d-inverseinversions">Example1(CF1540D Inverse
Inversions)</span></h5>
<p>考虑对于一个数列怎么构造:假设只考虑前<span class="math inline">\(k\)</span>个数,它们的取值是<span class="math inline">\([ 1 , k ]\)</span>,现在加入第<span class="math inline">\(k +
1\)</span>个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都<span class="math inline">\(+ 1\)</span>,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道<span class="math inline">\(p_i\)</span>是多少,根据上面的构造过程,首先将<span class="math inline">\(p_i =
a_i\)</span>,然后不断向后遍历,每遇到一个<span class="math inline">\(a_j\)</span>,如果<span class="math inline">\(a_j
\leq p_i\)</span>,则把<span class="math inline">\(p_i + =
1\)</span>.</p>
<p>我们将数列分块,设块长为<span class="math inline">\(B\)</span>,那一个值经过一个块的时候最多加块长个<span class="math inline">\(1\)</span>.也就是经过整块的时候是一个<span class="math inline">\(B\)</span>段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是<span class="math inline">\(\sum{ \cfrac{ B }{ 2^i } } = B\)</span>的,</p>
<p>于是最后复杂度为<span class="math inline">\(O ( T ( B + \cfrac{ n }{
B } \log n ) )\)</span>,取<span class="math inline">\(B = \sqrt{ n \log
n }\)</span>即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3>
<p>根号平衡主要用到下面四个东西:</p>
<ol type="1">
<li><p><span class="math inline">\(O ( 1 )\)</span>单点加,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>区间和:维护块内的和即可.</p></li>
<li><p><span class="math inline">\(O ( \sqrt{ n } )\)</span>单点加,<span class="math inline">\(O ( 1
)\)</span>区间和:维护块内和块间的前缀和即可.</p></li>
<li><p><span class="math inline">\(O ( \sqrt{ n } )\)</span>区间加,<span class="math inline">\(O ( 1 )\)</span>单点和:差分转化为<span class="math inline">\(( 2 )\)</span>.当然打标记也是可以的.</p></li>
<li><p><span class="math inline">\(O ( 1 )\)</span>区间加,<span class="math inline">\(O ( \sqrt{ n } )\)</span>单点和:差分转化为<span class="math inline">\(( 1 )\)</span>.当然打标记也是可以的.</p></li>
</ol>
<p>还有一些拓展的东西:</p>
<ol start="5" type="1">
<li><p>维护值域<span class="math inline">\(O ( n
)\)</span>的集合,支持<span class="math inline">\(O ( 1
)\)</span>插入,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块就可以.</p></li>
<li><p>维护值域<span class="math inline">\(O ( n
)\)</span>的集合,支持<span class="math inline">\(O ( \sqrt{ n }
)\)</span>插入,<span class="math inline">\(O ( 1 )\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块,然后暴力改变每个点所属的块就行.</p></li>
</ol>
<h4><span id="example">Example</span></h4>
<h5><span id="example1区间众数">Example1(区间众数)</span></h5>
<p>首先分块,处理出<span class="math inline">\(f_{ l , r
}\)</span>表示块<span class="math inline">\([ l , r
]\)</span>的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是<span class="math inline">\(\log n\)</span>的,因此复杂度<span class="math inline">\(O ( n \sqrt{ n \log n } )\)</span>.</p>
<p>但是可以优化,我们设<span class="math inline">\(mx\)</span>表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于<span class="math inline">\(mx\)</span>可以<span class="math inline">\(O ( 1
)\)</span>判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然<span class="math inline">\(mx\)</span>增加总次数也不会超过<span class="math inline">\(O ( \sqrt{ n } )\)</span>,因此做到<span class="math inline">\(O ( n \sqrt{ n } )\)</span>.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-andchuru">Example2(CodeChef Chef and
Churu)</span></h5>
<p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个<span class="math inline">\(O ( 1 )\)</span>查询区间和,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5>
<p>莫队,发现有<span class="math inline">\(m\)</span>次查询,<span class="math inline">\(n \sqrt{ m }\)</span>次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5>
<p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有<span class="math inline">\(O ( n
)\)</span>种,用值域分块就可以平衡复杂度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">数学分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-23 11:03:53" itemprop="dateModified" datetime="2025-10-23T11:03:53+08:00">2025-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="实数">实数</span></h3>
<p>首先我们拿到了有理数,然后我们按照以下步骤定义无理数:</p>
<p>首先我们注意到有理数是不连续的.问题在于我们要将其中不连续的部分给补上.首先我们应当去发现一下如何去发现有理数中的一个断点:</p>
<p>设<span class="math inline">\(S\)</span>是一个全序非空集合,我们找到它的两个非空子集<span class="math inline">\(A , B\)</span>,若满足:</p>
<ol type="1">
<li><p><span class="math inline">\(A \cap B = \emptyset , A \cup B =
S\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a \in A , b \in B , a &lt;
b\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span>中无最大元素.</p></li>
</ol>
<p>则称这是<span class="math inline">\(S\)</span>的一个<strong>分划</strong>,记作<span class="math inline">\(( A | B )\)</span>.接下来我们先考虑<span class="math inline">\(S = \mathbb{ Q }\)</span>的情况.</p>
<p>我们注意到一些事,比如说注意到<span class="math inline">\(B\)</span>中有可能没有最小元素.举个例子的话,我们令<span class="math inline">\(S = \mathbb{ Q } , A = \{ x | x \leq 0 \lor ( x
&gt; 0 \land x^2 &lt; 2 ) \}\)</span>,显然<span class="math inline">\(A\)</span>中无最大元素,此时取<span class="math inline">\(B = S \setminus A\)</span>,则显然<span class="math inline">\(B\)</span>中无最小元素(反证法),假设存在最小元素则可以调整到更小的元素,因为容易证明不存在一个有理数的平方为<span class="math inline">\(2\)</span>.</p>
<p>通过上面的铺垫我们知道,有理数并非连续的,因此如果<span class="math inline">\(B\)</span>中有最小元素,则称这是一个<strong>有理分划</strong>;如果<span class="math inline">\(B\)</span>中无最小元素,则称这是一个<strong>无理分划</strong>.容易发现有理分划与有理数一一对应.我们将无理分划也去对应到一些数上,这就产生了无理数的定义.只需比较<span class="math inline">\(A\)</span>集合的大小包含关系就可以比较两个实数的大小.</p>
<p>那我们还需要做的一件事是去证明无理数也有四则运算法则.不妨直接拿分划去验证四则运算法则:</p>
<ol type="1">
<li><p>加法:对于<span class="math inline">\(( A_c | B_c ) + ( A_d | B_d
)\)</span>,我们取<span class="math inline">\(A_{ c + d } = \{ x + y | x
\in A_c , y \in A_d \}\)</span>即可.</p></li>
<li><p>减法:只需定义加法逆元.如果是无理分划的话,直接把<span class="math inline">\(A ,
B\)</span>中的元素全部取反再交换即可;如果是有理分划的话,需要注意取反再交换后<span class="math inline">\(A\)</span>中出现了最大元素,只需要在这里把那个元素给提出来就行.</p></li>
<li><p>乘法:两个正数相乘可以直接模仿加法,如果有负数的话就把负号提出来再把绝对值作乘法即可.</p></li>
<li><p>除法:只需定义乘法逆元,这个有点麻烦需要判断<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>哪个集合是同号的,但总之这个是平凡的.</p></li>
</ol>
<h4><span id="戴德金分割定理">戴德金分割定理</span></h4>
<p>对<span class="math inline">\(\mathbb{ R }\)</span>的任一分划<span class="math inline">\(( A | B )\)</span>,<span class="math inline">\(B\)</span>中必定有最小元素.</p>
<p>这个怎么证明呢?对于分划<span class="math inline">\(( A | B
)\)</span>,我们直接取<span class="math inline">\(A &#39; = A \cap
\mathbb{ Q } , B &#39; = B \cap \mathbb{ Q }\)</span>,不难发现<span class="math inline">\(( A &#39; | B &#39; )\)</span>一定是<span class="math inline">\(\mathbb{ Q }\)</span>的一个分划,也就是说<span class="math inline">\(( A &#39; | B &#39; )\)</span>对应了一个实数<span class="math inline">\(x\)</span>.</p>
<p>既然如此就可以考虑<span class="math inline">\(x\)</span>应该属于哪个集合.我们注意到:如果<span class="math inline">\(x \in A\)</span>,那么<span class="math inline">\(x\)</span>必定是<span class="math inline">\(A\)</span>中的最大元素;如果<span class="math inline">\(x \in B\)</span>,那么<span class="math inline">\(x\)</span>必定是<span class="math inline">\(B\)</span>中的最小元素.</p>
<p>两部分是类似的,只考虑前一部分.考虑反证,如果<span class="math inline">\(\exists y &gt; x , y \in A , x \in
A\)</span>,那么<span class="math inline">\(A &#39; \subsetneq
A_y\)</span>,那么<span class="math inline">\(A_y\)</span>就一定不是<span class="math inline">\(A\)</span>的子集.换言之,<span class="math inline">\(\exists w \in A_y\)</span>,<span class="math inline">\(\forall z \in A , w &gt; z\)</span>.但我们有<span class="math inline">\(y &gt; w\)</span>,这必然意味着<span class="math inline">\(y \notin A\)</span>,与假设不符.</p>
<h4><span id="确界存在定理">确界存在定理</span></h4>
<p>若<span class="math inline">\(M\)</span>有上(下)界,则必然有上(下)确界.</p>
<p>设<span class="math inline">\(M\)</span>有上界<span class="math inline">\(c\)</span>,由于它是一个实数,它应该可以写作<span class="math inline">\(( A_c | B_c )\)</span>的形式.<span class="math inline">\(\forall \alpha \in M , A_\alpha \subset
A_c\)</span>.</p>
<p>于是我们取<span class="math inline">\(A = \bigcup_{ \alpha \in M }
A_\alpha , B = \mathbb{ Q } \setminus A\)</span>,我们来说明<span class="math inline">\(( A | B )\)</span>是一个分划.</p>
<p>首先由于有上界,显然<span class="math inline">\(A , B \ne \emptyset ,
A \cap B = \emptyset , A \cup B = \mathbb{ Q }\)</span>.</p>
<p>如果 <span class="math inline">\(\exists b \in B , a \in A , b &lt;
a\)</span>,这是不可能的,因为如果<span class="math inline">\(b &lt;
a\)</span>,那么<span class="math inline">\(b \in A , b \notin
B\)</span>.</p>
<p>因为所有的<span class="math inline">\(A_\alpha\)</span>中都没有最大元素,反证即可说明<span class="math inline">\(A\)</span>中无最大元素.</p>
<p>那么<span class="math inline">\(( A | B )\)</span>就是<span class="math inline">\(M\)</span>的上确界.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明对于单增函数<span class="math inline">\(f : [ 0 , 1 ] \rightarrow
[ 0 , 1 ]\)</span>,<span class="math inline">\(f ( [ 0 , 1 ] ) \subseteq
( 0 , 1 )\)</span>,则<span class="math inline">\(f\)</span>与<span class="math inline">\(y = x\)</span>一定有交点.</p>
<p>取<span class="math inline">\(A = \{ x | f ( x ) &lt; x
\}\)</span>,则<span class="math inline">\(1 \in A , A \subseteq [ 0 , 1
]\)</span>.取<span class="math inline">\(a = \inf A\)</span>.</p>
<p>此时我们断言<span class="math inline">\(f ( a ) =
a\)</span>,否则:</p>
<p>如果<span class="math inline">\(f ( a ) &lt; a\)</span>,取<span class="math inline">\(\epsilon = a - f ( a )\)</span>,注意到<span class="math inline">\(f ( a - \frac{ \epsilon }{ 2 } ) &lt; f ( a ) &lt;
a - \frac{ \epsilon }{ 2 }\)</span>,因此<span class="math inline">\(( a
- \frac{ \epsilon }{ 2 } ) \in A\)</span>,与<span class="math inline">\(a\)</span>是下确界矛盾.</p>
<p>如果<span class="math inline">\(f ( a ) &gt; a\)</span>,取<span class="math inline">\(\epsilon = f ( a ) - a\)</span>.考虑由于<span class="math inline">\(a\)</span>是下确界,因此<span class="math inline">\(\exists b \in A , b \in ( a , a + \frac{ \epsilon
}{ 2 } )\)</span>.那么<span class="math inline">\(b &lt; a + \frac{
\epsilon }{ 2 } &lt; f ( a ) &lt; f ( b )\)</span>,这与<span class="math inline">\(b \in A\)</span>矛盾.</p>
<h4><span id="阿基米德性质">阿基米德性质</span></h4>
<p>以下命题等价,任取其一均可作为阿基米德性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall y \in \mathbb{ R
}\)</span>,<span class="math inline">\(\exists n \in \mathbb{ N } , n
&gt; y\)</span>.</p></li>
<li><p><span class="math inline">\(\forall x \in \mathbb{ R }_+ ,
\exists n \in \mathbb{ N }\)</span>,<span class="math inline">\(nx &gt;
1\)</span>.</p></li>
<li><p><span class="math inline">\(\{ \frac{ 1 }{ n }
\}\)</span>有聚点.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
1 }{ n }\)</span>存在.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
1 }{ n } = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
1 }{ 2^n } = 0\)</span>.</p></li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)<span class="math inline">\(\Rightarrow\)</span>(3)<span class="math inline">\(\Rightarrow\)</span>(4)<span class="math inline">\(\Rightarrow ( 5 )\)</span>是显然的.又考虑<span class="math inline">\(\{ \frac{ 1 }{ 2^n } \}\)</span>是<span class="math inline">\(\{ \frac{ 1 }{ n } \}\)</span>的子列,所以<span class="math inline">\(( 5 ) \Rightarrow ( 6 )\)</span>.而取一个<span class="math inline">\(\frac{ 1 }{ 2^k } &lt; \frac{ 1 }{ | y |
}\)</span>即可(6)<span class="math inline">\(\Rightarrow\)</span>(1).</p>
<p>阿基米德性质可以由确界存在定理推来,简单来说考虑<span class="math inline">\(x \in \mathbb{ R }_+ , A = \{ nx | nx &lt; 1
\}\)</span>.反证,如果<span class="math inline">\(A\)</span>是无限集合,那么根据确界存在定理一定存在最小上确界<span class="math inline">\(\alpha \leq 1\)</span>有<span class="math inline">\(\forall n , nx &lt; \alpha , ( n + 1 ) x &lt;
\alpha , nx &lt; \alpha - x\)</span>,这就说明<span class="math inline">\(\alpha -
x\)</span>是一个更小的上界,这就矛盾了.</p>
<h3><span id="实数集上的一元函数">实数集上的一元函数</span></h3>
<h4><span id="性质">性质</span></h4>
<h5><span id="奇偶性">奇偶性</span></h5>
<p>首先需要定义域关于原点对称.</p>
<p>然后注意到取<span class="math inline">\(f ( x ) = \frac{ f ( x ) + f
( - x ) }{ 2 } + \frac{ f ( x ) - f ( - x ) }{ 2
}\)</span>,可将任意定义域关于原点对称的函数写作奇偶函数之和.</p>
<p>事实上,对于一个可以求任意次导数的偶函数<span class="math inline">\(f\)</span>,是否总存在一个可以求任意次导数的函数<span class="math inline">\(g\)</span>使得<span class="math inline">\(f ( x )
= g ( x^2 )\)</span>.</p>
<p>这个问题的难点肯定在于<span class="math inline">\(0\)</span>附近对吧.</p>
<p>这个证明要用到泰勒展开.</p>
<p><span class="math display">\[
f ( \sqrt{ x } ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( 0 ) }{ k ! }
x^\frac{ k }{ 2 } + \frac{ f^{ ( n + 1 ) } ( \xi_n ) }{ ( n + 1 ) ! }
x^\frac{ n + 1 }{ 2 }
\]</span></p>
<p>两边求导,应该有:</p>
<p><span class="math display">\[
( f ( \sqrt{ x } ) )^{ ( t ) } = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( 0
) \prod \limits_{ i = 0 }^{ t - 1 } ( \frac{ k }{ 2 } - i ) }{ k ! } x^{
\frac{ k }{ 2 } - t } + \frac{ f^{ ( n + 1 ) } ( \xi_n ) \prod \limits_{
i = 0 }^{ t - 1 } ( \frac{ n + 1 }{ 2 } - i ) }{ ( n + 1 ) ! } x^{
\frac{ n + 1 }{ 2 } - t }
\]</span></p>
<p>我们知道<span class="math inline">\(f\)</span>任意阶导数存在,所以在闭区间<span class="math inline">\([ - 1 , 1
]\)</span>上任意阶导数有界.这就意味着,对于固定的<span class="math inline">\(t\)</span>.只要取足够大的<span class="math inline">\(n = 2 t + 2\)</span>满足<span class="math inline">\(\frac{ n + 1 }{ 2 } - t &gt;
1\)</span>,就可以让余项趋于<span class="math inline">\(0\)</span>.</p>
<p>现在来数学归纳,用多项式的特殊情况,假设<span class="math inline">\(g^{
( t ) } ( 0 ) = \frac{ t ! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0
)\)</span>,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
g^{ ( t + 1 ) } ( 0 ) = \frac{ ( f ( \sqrt{ x } ) )^{ ( t ) } - \frac{ t
! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0 ) }{ x } \\
= \cfrac{ \sum_{ k = 0 }^{ 2 t + 2 } \frac{ f^{ ( k ) } ( 0 ) \prod
\limits_{ i = 0 }^{ t - 1 } ( \frac{ k }{ 2 } - i ) }{ k ! } x^{ \frac{
k }{ 2 } - t } - \frac{ t ! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0 ) }{ x } \\
= \cfrac{ \sum_{ k = 0 }^{ 2 t + 2 } \frac{ f^{ ( k ) } ( 0 ) \prod
\limits_{ i = 0 }^{ t - 1 } ( \frac{ k }{ 2 } - i ) }{ k ! } x^{ \frac{
k }{ 2 } } - \frac{ t ! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0 ) x^t }{ x^{ 1
+ t } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>一片混乱,考虑一下下面这项:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ f^{ ( k ) } ( 0 ) \prod \limits_{ i = 0 }^{ t - 1 } (
\frac{ k }{ 2 } - i ) }{ k ! } x^{ \frac{ k }{ 2 } } \\
= &amp; \frac{ f^{ ( k ) } ( 0 ) \prod \limits_{ i = 0 }^{ t - 1 } ( k -
2 i ) }{ k ! 2^t } x^{ \frac{ k }{ 2 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个时候我们注意到,当<span class="math inline">\(k\)</span>是奇数的时候应该有<span class="math inline">\(f^{ ( k ) } ( 0 ) = 0\)</span>,当<span class="math inline">\(k\)</span>是偶数并且<span class="math inline">\(k
\leq t - 1\)</span>的时候应该有<span class="math inline">\(\prod
\limits_{ i = 0 }^{ t - 1 } ( k - 2 i ) =
0\)</span>,这意味着这个求和最后只会剩下<span class="math inline">\(\frac{ f^{ ( 2 t ) } ( 0 ) t ! }{ ( 2 t ) ! } x^{
t } + \frac{ f^{ 2 t + 2 } ( 0 ) ( t + 1 ) ! }{ ( 2 t + 2 ) ! } x^{ t +
1 }\)</span>,然而前半部分和后面的刚好消掉了,这就数学归纳成立了.</p>
<h5><span id="有界性">有界性</span></h5>
<h5><span id="单调性">单调性</span></h5>
<h5><span id="周期性">周期性</span></h5>
<p>周期函数不一定有最小正周期,比如狄利克雷函数.</p>
<p>还有个思考题:</p>
<p>如果<span class="math inline">\(f , g\)</span>是定义域为<span class="math inline">\(R\)</span>的最小正周期分别为<span class="math inline">\(T_1 , T_2\)</span>的周期函数,求问:</p>
<ol type="1">
<li><p>若<span class="math inline">\(\frac{ T_1 }{ T_2 } \in \mathbb{ Q
}\)</span>,则<span class="math inline">\(f +
g\)</span>是周期函数.</p></li>
<li><p>若<span class="math inline">\(\frac{ T_1 }{ T_2 } \in \mathbb{ R
} \setminus \mathbb{ Q }\)</span>,结论如何.</p></li>
<li><p>若<span class="math inline">\(f ,
g\)</span>均连续,结论如何.</p></li>
</ol>
<p>(1)显然,(3)必定不是周期函数,原因是考虑反证:</p>
<p>如果是的话,必定有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x + T ) + g ( x + T ) &amp; = f ( x ) + g ( x ) \\
f ( x + T ) - f ( x ) &amp; = g ( x ) - g ( x + T )
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(h ( x ) = f ( x + T ) - f ( x ) = g ( x
) - g ( x + T )\)</span>,则<span class="math inline">\(h ( x
)\)</span>以<span class="math inline">\(T_1 ,
T_2\)</span>为周期,那么其以<span class="math inline">\(pT_1 +
qT_2\)</span>为周期,可逼近这个无理数使得其周期趋近于<span class="math inline">\(0\)</span>,用<span class="math inline">\(h\)</span>的连续性,于是<span class="math inline">\(h ( x )\)</span>为常函数,不符题意.</p>
<p>(2)怎么办呢?有没有一种构造方式使得它是周期函数呢?</p>
<p>构造<span class="math inline">\(d_{ p , q } ( x ) = \begin{cases}1
&amp; \exists m , n \in \mathbb{ Z } , mp + nq = x \\ 0 &amp; \forall m
, n \in \mathbb{ Z } , mp + nq \ne x\end{cases}\)</span>.</p>
<p>取<span class="math inline">\(f ( x ) = d_{ 1 , \sqrt{ 2 } } ( x ) -
d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x ) , g ( x ) = d_{ \sqrt{ 2 } , \sqrt{
3 } } ( x ) - d_{ 1 , \sqrt{ 3 } }\)</span>,容易见到<span class="math inline">\(f + g\)</span>的周期为<span class="math inline">\(1\)</span>,下面证明<span class="math inline">\(f\)</span>的最小正周期是<span class="math inline">\(\sqrt{ 2 }\)</span>,而<span class="math inline">\(g\)</span>的最小正周期是<span class="math inline">\(\sqrt{ 3 }\)</span>.</p>
<p>二者相似,只考虑证明前者,如若存在一个<span class="math inline">\(T\)</span>,使得<span class="math inline">\(f ( x )
= f ( x + T )\)</span>,则有:</p>
<p><span class="math display">\[
\begin{aligned}
d_{ 1 , \sqrt{ 2 } } ( x ) - d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x ) &amp; =
d_{ 1 , \sqrt{ 2 } } ( x + T ) - d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x + T )
\\
d_{ 1 , \sqrt{ 2 } } ( x ) - d_{ 1 , \sqrt{ 2 } } ( x + T ) &amp; = d_{
\sqrt{ 2 } , \sqrt{ 3 } } ( x ) - d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x + T
)
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(x = \sqrt{ 3 }\)</span>得到:</p>
<p><span class="math display">\[
d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( \sqrt{ 3 } + T ) - d_{ 1 , \sqrt{ 2 } }
( \sqrt{ 3 } + T ) = 1
\]</span></p>
<p>这就意味着:</p>
$$
<span class="math display">\[\begin{cases}
d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( \sqrt{ 3 } + T ) = 1 \\
d_{ 1 , \sqrt{ 2 } } ( \sqrt{ 3 } + T ) = 0 \\

\end{cases}\]</span>
<p>$$</p>
<p>从而<span class="math inline">\(T = n \sqrt{ 2 } + m \sqrt{ 3
}\)</span>,其中<span class="math inline">\(m \ne - 1\)</span>.再取<span class="math inline">\(x = 0\)</span>得到:</p>
<p><span class="math display">\[
d_{ 1 , \sqrt{ 2 } } ( T ) = d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( T ) = 1
\]</span></p>
<p>这就必然意味着<span class="math inline">\(T = n \sqrt{ 2
}\)</span>,从而<span class="math inline">\(f\)</span>的最小正周期恰好就是<span class="math inline">\(\sqrt{ 2 }\)</span>.</p>
<h4><span id="基本初等函数">基本初等函数</span></h4>
<ol type="1">
<li><p>常值函数</p></li>
<li><p>指数函数</p></li>
<li><p>对数函数</p></li>
<li><p>幂函数</p></li>
<li><p>三角函数</p></li>
<li><p>反三角函数</p></li>
</ol>
<p>其中有一些函数的定义其实有一些缺陷,我们将在讨论完连续性后给出.</p>
<h4><span id="初等函数">初等函数</span></h4>
<p>由基本初等函数经过有限次四则运算和复合得到的函数.</p>
<p>举个逆天例子:</p>
<p><span class="math display">\[
f ( x ) = \begin{cases}
\sqrt{ - x } &amp; x &lt; 0 \\
0 &amp; x \in [ 0 , 1 ] \\
\ln x &amp; x &gt; 1
\end{cases}
\]</span></p>
<p>注意到<span class="math inline">\(f ( x ) = \sqrt{ \frac{ \sqrt{ x^2
} - x }{ 2 } } + \ln \frac{ x + \sqrt{ ( x - 1 )^2 } + 1 }{ 2
}\)</span>.</p>
<h4><span id="代数函数">代数函数</span></h4>
<p>存在多项式<span class="math inline">\(F ( x , y )\)</span>满足<span class="math inline">\(F ( x , f ( x ) ) \equiv 0\)</span>的函数<span class="math inline">\(f ( x )\)</span>称为代数函数.</p>
<h3><span id="数列极限">数列极限</span></h3>
<h4><span id="定义">定义</span></h4>
<p>设<span class="math inline">\(\{ a_n
\}\)</span>是一个给定的序列,若<span class="math inline">\(\exists
l\)</span>,<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N \in \mathbb{ N
}\)</span>,<span class="math inline">\(\forall n &gt; N , | a_n - l |
&lt; \epsilon\)</span>.我们称<span class="math inline">\(l\)</span>是这个序列的<strong>极限</strong>,记作<span class="math inline">\(\lim_{ n \rightarrow \infty } a_n = l
\\\)</span>.</p>
<h4><span id="性质">性质</span></h4>
<ol type="1">
<li><p>若数列存在极限,则极限唯一.</p></li>
<li><p>有极限的数列有界.</p></li>
<li><p>数列的极限可以四则运算.</p></li>
<li><p>设序列<span class="math inline">\(\{ a_n \} , \{ b_n
\}\)</span>有极限并且分别为<span class="math inline">\(l_a ,
l_b\)</span>,若<span class="math inline">\(\exists N \in \mathbb{ N
}\)</span>,<span class="math inline">\(\forall n &gt; N , a_n \geq
b_n\)</span>,则<span class="math inline">\(l_a \geq
l_b\)</span>.</p></li>
<li><p>设序列<span class="math inline">\(\{ a_n \} , \{ b_n
\}\)</span>有极限并且分别为<span class="math inline">\(l_a ,
l_b\)</span>,如果<span class="math inline">\(l_a &gt;
l_b\)</span>,则<span class="math inline">\(\exists N \in \mathbb{ N
}\)</span>,<span class="math inline">\(\forall n &gt; N , a_n &gt;
b_n\)</span>.</p></li>
<li><p>夹逼定理:设<span class="math inline">\(\{ a_n \} , \{ b_n \} , \{
c_n \}\)</span>是三个序列,且<span class="math inline">\(\exists N_0 ,
\forall n &gt; n_0 , a_n \leq b_n \leq c_n\)</span>.那么如果<span class="math inline">\(\lim_{ n \rightarrow \infty } a_n = \lim_{ n
\rightarrow \infty } c_n = l \\\)</span>,则<span class="math inline">\(\lim_{ n \rightarrow \infty } b_n = l
\\\)</span>.</p></li>
<li><p>对于原序列,若它有极限<span class="math inline">\(l\)</span>,取出它的无穷项子序列,那这个子序列的极限必然也是<span class="math inline">\(l\)</span>.(如果一个序列能取出两个无穷项子序列使得极限不相同,那么原序列必然无极限)</p></li>
</ol>
<p>大部分的证明都很显然,只需要套用极限定义即可,这里举几个证明为例.</p>
<p>(3):</p>
<p>设序列<span class="math inline">\(\{ a_n \} , \{ b_n
\}\)</span>有极限并且分别为<span class="math inline">\(l_a ,
l_b\)</span>,则要证<span class="math inline">\(\lim_{ n \rightarrow
\infty } ( a_n \pm b_n ) = l_a \pm l_b \\\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } ( a_n b_n ) = l_a
l_b \\\)</span>,若<span class="math inline">\(l_b \ne 0\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } ( \frac{ a_n }{ b_n
} ) = \frac{ l_a }{ l_b } \\\)</span>.</p>
<p>先证明加减法,取<span class="math inline">\(\frac{ 1 }{ 2 }
\epsilon\)</span>然后合并起来就行.</p>
<p>乘法也类似,首先有:</p>
<p><span class="math display">\[
\begin{aligned}
l_a - \epsilon_1 &amp; &lt; a_n &lt; l_a + \epsilon_1 \\
l_b - \epsilon_2 &amp; &lt; b_n &lt; l_b + \epsilon_2
\end{aligned}
\]</span></p>
<p>于是自然有:</p>
<p><span class="math display">\[
\begin{aligned}
| a_n b_n - l_a l_b | &amp; = | ( a_n - l_a ) b_n + l_a ( b_n - l_b ) |
\\
&amp; \leq | b_n | | a_n - l_a | + | l_a | | b_n - l_b | \\
&amp; &lt; | b_n | \epsilon_1 + | l_a | \epsilon_2 \\
&amp; &lt; | l_b \pm \epsilon_2 | \epsilon_1 + | l_a | \epsilon_2
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(\epsilon_1 =
\epsilon_2\)</span>,尝试构造一组解使得<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \epsilon_1 &gt;
0\)</span>,<span class="math inline">\(| l_b \pm \epsilon_1 | \epsilon_1
+ | l_a | \epsilon_1 &lt; \epsilon\)</span>.限制一下<span class="math inline">\(\epsilon &lt; 1 , \epsilon_1 &lt;
1\)</span>,取<span class="math inline">\(\epsilon_1 = \frac{ \epsilon }{
1 + | l_b | + | l_a | }\)</span>即可.</p>
<p>接下来证明除法,实际上只需要证明若<span class="math inline">\(l_b \ne
0\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } (
\frac{ 1 }{ b_n } ) = \frac{ 1 }{ l_b } \\\)</span>.</p>
<p>考虑:<span class="math inline">\(l_b \lim_{ n \rightarrow \infty }
b_n = l_b^2 &gt; 0 \\\)</span>,这意味着当<span class="math inline">\(\exists N_0 , \forall n &gt; N_0 , l_b b_n &gt; 0
\\\)</span>,或者更强一点,<span class="math inline">\(\exists N_0 ,
\forall n &gt; N_0 , l_b b_n &gt; \frac{ 1 }{ 2 } l_b^2 \\\)</span>.</p>
<p>不妨设<span class="math inline">\(\epsilon &#39; &gt; 0 , \exists N_1
, \forall n &gt; N_1 , | l_b - b_n | &lt; \epsilon &#39;\)</span></p>
<p>取<span class="math inline">\(n &gt; \max ( N_0 , N_1
)\)</span>此时自然有:</p>
<p><span class="math display">\[
| \frac{ 1 }{ b_n } - \frac{ 1 }{ l_b } | = \frac{ | l_b - b_n | }{ |
b_n l_b | } \leq \frac{ 2 }{ l_b^2 } \epsilon &#39;
\]</span></p>
<p>取<span class="math inline">\(\epsilon &#39; = \frac{ l_b^2 }{ 2 }
\epsilon\)</span>即可得证.</p>
<p>(4):</p>
<p>反证,设<span class="math inline">\(l_a &lt; l_b\)</span>,那么取<span class="math inline">\(\epsilon = \frac{ l_b - l_a }{ 2
}\)</span>,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
| a_N - l_a | &amp; &lt; \epsilon \\
a_N &amp; &lt; \frac{ l_a + l_b }{ 2 } &lt; b_N
\end{aligned}
\]</span></p>
<p>这是不可能的.</p>
<h4><span id="单调收敛准则">单调收敛准则</span></h4>
<p>单调有界无穷数列有极限.</p>
<p>不妨设<span class="math inline">\(\{ a_n
\}\)</span>是一个单调有界无穷数列(不妨假设其单增,不然可以取反变成单增),且<span class="math inline">\(\forall n , a_n \leq l_a\)</span>.</p>
<p>考虑集合<span class="math inline">\(A = \{ x_n | n \in \mathbb{ N }_+
\}\)</span>,根据确界存在定理,其一定有上确界.令<span class="math inline">\(a\)</span>是它的上确界,我们来证明<span class="math inline">\(a\)</span>一定是数列的极限.</p>
<p>由于<span class="math inline">\(a\)</span>是上确界,这意味着<span class="math inline">\(\forall \epsilon &gt; 0 , a -
\epsilon\)</span>不是上确界,所以<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,<span class="math inline">\(\exists
N\)</span>,<span class="math inline">\(\forall n &gt; N , a - \epsilon
&lt; a_n \leq a &lt; a + \epsilon\)</span>,这就是极限的定义.</p>
<h4><span id="自然对数的底数">自然对数的底数</span></h4>
<p>定义<span class="math inline">\(e = \lim_{ n \rightarrow \infty } ( 1
+ \frac{ 1 }{ n } )^n
\\\)</span>.如何证明它存在极限呢?考虑单调有界无穷序列必定存在极限,定义<span class="math inline">\(x_n = ( 1 + \frac{ 1 }{ n }
)^n\)</span>,于是先证明它有界:</p>
<p><span class="math display">\[
\begin{aligned}
( 1 + \frac{ 1 }{ n } )^n &amp; = \sum_{ k = 0 }^n \frac{ n^{
\underline{ k } } }{ k ! } \frac{ 1 }{ n^k } \\
&amp; &lt; \sum_{ k = 0 }^n \frac{ 1 }{ k ! } \\
&amp; &lt; 2 + \sum_{ k = 2 }^n \frac{ 1 }{ k ( k - 1 ) } \\
&amp; = 2 + \sum_{ k = 2 }^n ( \frac{ 1 }{ k - 1 } - \frac{ 1 }{ k } )
&lt; 3
\end{aligned}
\]</span></p>
<p>接下来证明单调,只需证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt[n + 1]{ ( 1 + \frac{ 1 }{ n } )^n } &amp; &lt; \frac{ n + 2 }{ n +
1 } \\
\sqrt[n + 1]{ 1 ( 1 + \frac{ 1 }{ n } )^n } &amp; &lt; \frac{ 1 + n ( 1
+ \frac{ 1 }{ n } ) }{ n + 1 }
\end{aligned}
\]</span></p>
<p>由均值不等式显然.</p>
<p>如果我们考虑另一个极限<span class="math inline">\(y_n = ( 1 + \frac{
1 }{ n } )^{ n + 1 }\)</span>,注意到:</p>
<p><span class="math display">\[
\frac{ 1 }{ y_n } = ( \frac{ n }{ n + 1 } )^{ n + 1 } \times 1 &lt; (
\frac{ n + 1 }{ n + 2 } )^{ n + 2 } = \frac{ 1 }{ y_{ n + 1 } }
\]</span></p>
<p>发现<span class="math inline">\(y_n\)</span>单调递减且<span class="math inline">\(y_n &gt; x_n\)</span>,并且<span class="math inline">\(\lim_{ n \rightarrow \infty } y_n - x_n =
0\)</span>,这就意味着二者必然同时趋向于一个常数的两侧,定义为<span class="math inline">\(e = 2 . 7182818284 \cdots\)</span>.</p>
<p>这里还可以推出一些结论.因为我们知道:</p>
<p><span class="math display">\[
\begin{aligned}
x_n &amp; &lt; e &lt; y_n \\
n \ln ( 1 + \frac{ 1 }{ n } ) &amp; &lt; 1 &lt; ( n + 1 ) \ln ( 1 +
\frac{ 1 }{ n } ) \\
\frac{ 1 }{ n + 1 } &amp; &lt; \ln ( n + 1 ) - \ln ( n ) &lt; \frac{ 1
}{ n } \\
H_{ n + 1 } - 1 &amp; &lt; \ln ( n + 1 ) &lt; H_n
\end{aligned}
\]</span></p>
<p>用这个可以注意到定义<span class="math inline">\(z_n = H_n - \ln
n\)</span>,这个东西肯定<span class="math inline">\(\geq
0\)</span>且<span class="math inline">\(\leq 1\)</span>,而且注意到<span class="math inline">\(z_{ n + 1 } - z_n = \frac{ 1 }{ n + 1 } - \ln
\frac{ n + 1 }{ n } &lt;
0\)</span>,所以单调有界,这个极限就是欧拉常数<span class="math inline">\(\gamma = 0 . 57 \cdots\)</span>.</p>
<p>接下来证明<span class="math inline">\(e\)</span>是无理数.</p>
<p>考虑<span class="math inline">\(e = \lim_{ n \rightarrow \infty } ( 1
+ \frac{ 1 }{ n } )^n\)</span>,取二项式定理,取<span class="math inline">\(x_k = \sum_{ k = 0 }^n \frac{ n^{ \underline{ k }
} }{ k ! n^k } \leq \sum_{ k = 0 }^n \frac{ 1 }{ k ! } =
U_n\)</span>.</p>
<p>而又注意到<span class="math inline">\(x_n = \sum_{ k = 0 }^n \frac{
n^{ \underline{ k } } }{ k ! n^k }\)</span>,取定一个确定的上界<span class="math inline">\(m \leq n\)</span>,则<span class="math inline">\(x_n \geq \sum_{ k = 0 }^m \frac{ n^{ \underline{ k
} } }{ k ! n^k } = y_n\)</span>.由于<span class="math inline">\(m\)</span>有限,所以当<span class="math inline">\(n
\rightarrow \infty\)</span>时,<span class="math inline">\(y_n
\rightarrow U_n\)</span>的前<span class="math inline">\(m\)</span>项,此时再令<span class="math inline">\(m
\to \infty\)</span>,根据夹逼定理,立刻得到<span class="math inline">\(x_n
\rightarrow U_n\)</span>.换言之,<span class="math inline">\(m\)</span>增大引起的误差总可以被后面的<span class="math inline">\(n\)</span>的增大抹平.</p>
<p>考虑一下计算误差,设<span class="math inline">\(r_n = e -
U_n\)</span>,则<span class="math inline">\(r_n = \sum_{ k \geq n + 1 }
\frac{ 1 }{ k ! } = \frac{ 1 }{ ( n + 1 ) ! } \sum_{ k \geq 0 } \frac{ 1
}{ ( n + 2 )^{ \overline{ k } } } &lt; \frac{ 1 }{ ( n + 1 ) ! } \sum_{
k \geq 0 } \frac{ 1 }{ ( n + 2 )^k } = \frac{ 1 }{ ( n + 1 ) ! } \frac{
n + 2 }{ n + 1 } &lt; \frac{ 1 }{ n \times n ! }\)</span>.</p>
<p>如果<span class="math inline">\(e\)</span>是有理数,设<span class="math inline">\(e = \frac{ m }{ n } \in \mathbb{ Q
}\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp; &lt; r_n = \frac{ m }{ n } - U_n &lt; \frac{ 1 }{ n \times n ! }
\\
0 &amp; &lt; m \times ( n - 1 ) ! - U_n \times n ! &lt; \frac{ 1 }{ n }
\end{aligned}
\]</span></p>
<p>这立刻导出矛盾,因为<span class="math inline">\(U_n \times n
!\)</span>一定是整数.</p>
<h4><span id="开区间与闭区间">开区间与闭区间</span></h4>
<p>定义一个集合的内部点:<span class="math inline">\(x , \exists \delta
&gt; 0 , ( x - \delta , x + \delta ) \subseteq
A\)</span>.我们将一个集合的所有内部点组成的集合记作<span class="math inline">\(A^{ \degree }\)</span>.</p>
<p>这样就可以定义一个集合是内部为空的,就是其没有内部点.反之,如果每个点都是其内部点,那么称其为稠密的.</p>
<p>定义一个集合的边界点:<span class="math inline">\(x , \forall \delta
&gt; 0 , ( x - \delta , x + \delta ) \cap A \ne \emptyset , ( x - \delta
, x + \delta ) \cap A^C \ne \emptyset\)</span>.</p>
<p>一个集合称为开集合,当且仅当<span class="math inline">\(A = A^{
\degree }\)</span>.</p>
<p>一个集合称为闭集合,当且仅当对于集合中的任何一个数列,数列极限也存在于这个集合中.</p>
<p>当然也可以用补集来用开集合定义闭集合(补集是开集合的集合是闭集合)或者反之.</p>
<p>由此我们知道开集的并是开集,有限个开集的交是开集;闭集的交是闭集,有限个闭集的并是闭集.</p>
<p>容易发现包含于<span class="math inline">\(A\)</span>的所有开集的并是<span class="math inline">\(A^{ \degree }\)</span>.</p>
<p>我们类似定义<span class="math inline">\(A\)</span>的闭包是<span class="math inline">\(\bar{ A }\)</span>.</p>
<p>而且容易发现如果<span class="math inline">\(f\)</span>是连续函数,那么如果<span class="math inline">\(U\)</span>是开集,那么<span class="math inline">\(f^{ - 1 } ( U )\)</span>(也就是<span class="math inline">\(U\)</span>的原像)也是开集.</p>
<h4><span id="区间套定理">区间套定理</span></h4>
<p>设<span class="math inline">\(I_n = [ a_n , b_n ] \ne \emptyset , I_{
n + 1 } \subseteq I_{ n }\)</span>,则<span class="math inline">\(I =
\bigcap_{ n \geq 1 } I_n\)</span>存在且是一个非空闭区间.</p>
<p>怎么证明?考虑<span class="math inline">\(a_n\)</span>单增,<span class="math inline">\(b_n\)</span>单减并且<span class="math inline">\(a_1 \leq a_n \leq b_n \leq b_1\)</span>,所以<span class="math inline">\(a_n\)</span>存在极限,不妨设为<span class="math inline">\(l_a\)</span>,同理<span class="math inline">\(b_n\)</span>也存在极限,设为<span class="math inline">\(l_b\)</span>.容易验证<span class="math inline">\(I
= [ l_a , l_b ]\)</span>.</p>
<p>类似地,设<span class="math inline">\(I_n = ( a_n , b_n ) \ne
\emptyset , I_{ n + 1 } \subseteq I_{ n }\)</span>,并且<span class="math inline">\(a_n ,
b_n\)</span>不会从某一项开始往后全都是常数(换言之其极限不等于其每一项,且不会上下波动),则<span class="math inline">\(I = \bigcap_{ n \geq 1 }
I_n\)</span>存在且是一个非空闭区间.</p>
<p>特别地,当<span class="math inline">\(\lim | b_n - a_n | =
0\)</span>的时候,上述给出一个单点.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(x_1 = a , x_2 = b , a \ne b , x_{ n + 2
} = \frac{ x_{ n + 1 } + x_n }{ 2 }\)</span>,问<span class="math inline">\(\lim_{ n \rightarrow \infty }
x_n\)</span>是否存在.</p>
<p>可以设<span class="math inline">\(c_n = \min \{ x_n , x_{ n + 1 } \}
, d_n = \max \{ x_n , x_{ n + 1 } \}\)</span>,讨论<span class="math inline">\(x_{ n + 1 }\)</span>和<span class="math inline">\(x_n\)</span>的大小关系(二者显然不相等)可以知道<span class="math inline">\([ c_n , d_n
]\)</span>满足区间套定理的条件,又注意到<span class="math inline">\(| I_{
n + 1 } | = | x_{ n + 2 } - x_{ n + 1 } | = \frac{ 1 }{ 2 } | I_n
|\)</span>,所以区间长度趋近于<span class="math inline">\(0\)</span>,这样的话<span class="math inline">\(\lim_{ n \rightarrow \infty } c_n = \lim_{ n
\rightarrow \infty } x_n = \lim_{ n \rightarrow \infty }
d_n\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(a_1 &gt; b_1 &gt; 0\)</span>,<span class="math inline">\(a_{ n + 1 } = \frac{ a_n + b_n }{ 2 } , b_{ n + 1
} = \sqrt{ a_n b_n }\)</span>.求证<span class="math inline">\(a_n ,
b_n\)</span>极限都存在且相等.</p>
<p>还是区间套定理,容易验证满足区间套定理的条件,那么要注意到<span class="math inline">\(| I_{ n + 1 } | = \frac{ a_n + b_n }{ 2 } - \sqrt{
a_n b_n } &lt; \frac{ a_n + b_n }{ 2 } - b_n = \frac{ 1 }{ 2 } | I_n
|\)</span>,所以<span class="math inline">\(\lim_{ n \rightarrow \infty }
| I_n | = 0\)</span>,这就证明了二者存在且相等.</p>
<p>其实先用单调有界数列有极限,再对着递推式两边求下极限就可以了.</p>
<h4><span id="有限覆盖定理">有限覆盖定理</span></h4>
<p>覆盖:<span class="math inline">\(\Sigma
:\)</span>由一些开区间组成的集合.若<span class="math inline">\(M \subset
\mathbb{ R }\)</span>,称<span class="math inline">\(M\)</span>被<span class="math inline">\(\Sigma\)</span>覆盖,当且仅当<span class="math inline">\(M \subseteq \bigcup_{ \sigma \in \Sigma }
\sigma\)</span>.</p>
<p>有限覆盖定理是说,如果<span class="math inline">\(M = [ a , b
]\)</span>是一个有界闭区间,且<span class="math inline">\(M\)</span>被<span class="math inline">\(\Sigma\)</span>覆盖,则一定存在一个<span class="math inline">\(\Sigma\)</span>的有限子集<span class="math inline">\(\Sigma_1\)</span>,使得<span class="math inline">\(M\)</span>能被<span class="math inline">\(\Sigma_1\)</span>覆盖.</p>
<p>换言之,有界闭区间若能被开区间覆盖,则一定能被有限个开区间覆盖.</p>
<p>反证:如果<span class="math inline">\(M\)</span>不能被有限覆盖,那么<span class="math inline">\([ a , \frac{ a + b }{ 2 } ]\)</span>和<span class="math inline">\([ \frac{ a + b }{ 2 } , b
]\)</span>至少有一个不能被有限覆盖(如果它俩都能那<span class="math inline">\([ a , b
]\)</span>肯定也能).不妨取出二者中任意一个不能被有限覆盖的区间,设为<span class="math inline">\([ a_1 , b_1
]\)</span>,再进行上面的操作就可以得到<span class="math inline">\([ a_2 ,
b_2
]\)</span>,以此类推,如此我们得到了一个满足区间套定理的区间序列而且均不能被有限覆盖,根据区间套定理,可以取出它们交集的那个元素<span class="math inline">\(c\)</span>.由于<span class="math inline">\(\{ c \}
\in M\)</span>,所以<span class="math inline">\(\exists \sigma \in \Sigma
, c \in \sigma\)</span>.因为<span class="math inline">\(\sigma\)</span>是开区间,所以<span class="math inline">\(\exists \epsilon &gt; 0 , [ c - \epsilon , c +
\epsilon ] \in \sigma\)</span>,而显然可以找到一个<span class="math inline">\(N &gt; 0\)</span>,<span class="math inline">\(\forall n \geq N\)</span>,<span class="math inline">\([ a_n , b_n ] \in [ c - \epsilon , c + \epsilon
]\)</span>,这就矛盾了.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:有界闭区间上的局部有界(对于每一个点,它都存在一个开区间邻域是有界的)函数是整体有界函数.</p>
<p>设定义域为<span class="math inline">\([ a , b ]\)</span>,考虑<span class="math inline">\(\forall x_0 \in [ a , b ] , \exists \sigma &gt;
0\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\(( x_0 - \sigma , x_0 + \sigma
)\)</span>上有界,注意到设<span class="math inline">\(I_{ x_0 } = ( x_0 -
\sigma , x_0 + \sigma )\)</span>,那么<span class="math inline">\([ a , b
]\)</span>一定被<span class="math inline">\(I\)</span>这个区间集合开覆盖,那么就能被有限开覆盖,取出那有限个区间对应的值域并起来就行.</p>
<h6><span id="example2">Example2</span></h6>
<p>证明:有界闭区间上的局部增(对于每一个点,它都存在一个开区间邻域是增的)函数是整体增函数.</p>
<p>证明和上面一样,合并两个开区间的时候找任意一个交集元素即可.</p>
<h4><span id="外测度与零测集">外测度与零测集</span></h4>
<p>定义<strong>外测度:</strong>对于<span class="math inline">\(E
\subseteq \mathbb{ R }\)</span>,定义<span class="math inline">\(m^* ( E
)\)</span>为<span class="math inline">\(E\)</span>的外测度,<span class="math inline">\(m^* ( E ) = \inf \{ ( \sum | I_k | ) \mid \bigcup
I_k \supseteq E \}\)</span>,也就是找一列区间使得其并起来能包含<span class="math inline">\(E\)</span>.</p>
<p>定义<strong>零测集</strong>:外测度为<span class="math inline">\(0\)</span>的集合.容易发现<span class="math inline">\(m^* ( \bigcup E_k ) \leq \sum m^* ( E_k
)\)</span>.于是可数个零测集的并仍然是零测集.</p>
<p>如果一个集合的势可数,那它当然是零测集,原因是可以构造<span class="math inline">\(I_n = ( x_n - \delta , x_n + \delta ) , \delta =
\frac{ 1 }{ 2^{ n + 1 } }\)</span>.由这个构造<span class="math inline">\(\epsilon_k = \frac{ \epsilon }{ 2^{ k + 1 }
}\)</span>可以说明可数个零测集的并仍然是零测集.</p>
<p>反之,一个集合是零测集不一定代表其可数,例如康托三分集:先把<span class="math inline">\([ 0 , 1 )\)</span>上扣去<span class="math inline">\([ \frac{ 1 }{ 3 } , \frac{ 2 }{ 3 }
)\)</span>,然后再对剩下的线段也做类似的操作,每次扣掉中间一段.算一下每次扣去的长度,发现长度恰好为<span class="math inline">\(1\)</span>,于是当然是零测集.但注意到这对应着一个三进制小数并且每一位只能是<span class="math inline">\(0 , 2\)</span>,那这当然势仍然是<span class="math inline">\(2^\mathbb{ N }\)</span>,于是不可数.</p>
<h4><span id="vitali覆盖引理">Vitali覆盖引理</span></h4>
<p>当<span class="math inline">\(E \subseteq R\)</span>,称一族区间<span class="math inline">\(\Gamma = \{ I_\alpha \}\)</span>是<span class="math inline">\(E\)</span>的一个Vitali覆盖,若对<span class="math inline">\(\forall x \in E , \epsilon &gt; 0\)</span>,<span class="math inline">\(\exists I_{ \alpha } \in \Gamma , | I_\alpha |
&lt; \epsilon , x \in
I_\alpha\)</span>.也就是对于任何一个点都存在足够小的区间把它盖住.</p>
<p>Vitali覆盖引理是说,如果<span class="math inline">\(E\)</span>是一个有界集(或者推广到外测度有限的集合),<span class="math inline">\(\Gamma\)</span>是<span class="math inline">\(E\)</span>的一个Vitali覆盖,则<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,<span class="math inline">\(\Gamma\)</span>中可以拿出有限个两两不交的区间<span class="math inline">\(I_j \in \Gamma\)</span>,满足<span class="math inline">\(m^* ( E \setminus ( \bigcup I_j ) ) &lt;
\epsilon\)</span>.注意这里取区间的方式依赖于<span class="math inline">\(\epsilon\)</span>的选取.</p>
<p>取一个开集<span class="math inline">\(G \supseteq E , m^* ( G ) &lt;
\infty\)</span>,不妨设<span class="math inline">\(\Gamma\)</span>中的每个区间都<span class="math inline">\(\subseteq
G\)</span>(原因在于Vitali覆盖保证了任意小的区间覆盖,而开集的性质使得总有区间在其中).在此基础上,由于上面的<span class="math inline">\(\Gamma\)</span>是任意一个Vitali覆盖,所以我们不妨假设<span class="math inline">\(\Gamma\)</span>中的每个区间都是闭区间(也就是把端点加进去,那当然仍然是Vitali覆盖而且更难满足限制,因为闭区间更难以两两不交),这当然仍是可以的.</p>
<p>现在我们归纳取区间,我们任取一个<span class="math inline">\(I_1 \in
\Gamma\)</span>,开始不断往上添区间.设<span class="math inline">\(I_1 ,
\cdots , I_k\)</span>已经被我们拿到,而且两两不交.</p>
<p>如果此时<span class="math inline">\(E \subseteq \bigcup_{ j = 1 }^k
I_j\)</span>,当然直接满足条件.</p>
<p>反之,令<span class="math inline">\(\delta_k = \sup \{ ( | I | ) \mid
I \in \Gamma , I \cap I_j = \emptyset , 1 \leq j \leq k
\}\)</span>.容易发现<span class="math inline">\(\delta_k &lt;
\infty\)</span>.那我们取<span class="math inline">\(I_{ k + 1
}\)</span>使得<span class="math inline">\(\forall 1 \leq j \leq k , I_{
k + 1 } \cap I_j = \emptyset , | I_{ k + 1 } | &gt; \frac{ 1 }{ 2 }
\delta_k\)</span>,这当然做得到.</p>
<p>如果一直做下去都没有使得<span class="math inline">\(E \subseteq
\bigcup I_j\)</span>,那我们就可以拿到一个区间列.接下来我们考虑<span class="math inline">\(\sum | I_k |\)</span>,此时由于<span class="math inline">\(I_k\)</span>两两不交,当然有<span class="math inline">\(\sum | I_k | \leq m^* ( G ) &lt;
\infty\)</span>,那么根据单调收敛准则,<span class="math inline">\(\sum |
I_k |\)</span>趋于一个极限,于是<span class="math inline">\(| I_k
|\)</span>当然趋近于<span class="math inline">\(0\)</span>,那么<span class="math inline">\(\delta_k\)</span>趋近于<span class="math inline">\(0\)</span>.在此基础上,我们当然可以取一个<span class="math inline">\(N &gt; 0\)</span>,<span class="math inline">\(\forall n \geq N , \sum_{ k \geq n + 1 } | I_k |
&lt; \frac{ 1 }{ 5 } \epsilon\)</span>.</p>
<p>此时<span class="math inline">\(\forall x \in E \setminus ( \bigcup_{
k \leq N } I_k )\)</span>.由于<span class="math inline">\(I_k\)</span>均为闭区间,所以<span class="math inline">\(E \setminus ( \bigcup_{ k \leq N } I_k
)\)</span>必定是开区间,这也就是说<span class="math inline">\(x\)</span>存在一个小邻域<span class="math inline">\(I &#39; \in \Gamma\)</span>并且<span class="math inline">\(I &#39; \subseteq E \setminus ( \bigcup_{ k \leq N
} I_k )\)</span>.那当然有<span class="math inline">\(I &#39; \cap (
\bigcup_{ k \leq N } I_k ) = \emptyset\)</span>,也就是<span class="math inline">\(I &#39; \cap I_k = \emptyset , 1 \leq k \leq
N\)</span>.由于<span class="math inline">\(| I &#39;
|\)</span>有限且不为<span class="math inline">\(0\)</span>,而<span class="math inline">\(\delta_n \rightarrow 0\)</span>.一定<span class="math inline">\(\exists n \geq N\)</span>,使得<span class="math inline">\(I &#39; \cap ( \bigcup_{ k \leq n } I_k ) =
\emptyset , I &#39; \cap I_{ n + 1 } \ne
\emptyset\)</span>.发现此时<span class="math inline">\(| I &#39; | \leq
\delta_n &lt; 2 | I_{ n + 1 } |\)</span>.</p>
<p>此时会出个什么事呢?由于<span class="math inline">\(| I &#39; | &lt; 2
| I_{ n + 1 } |\)</span>,所以我们把<span class="math inline">\(I_{ n + 1
}\)</span>这个区间扩大五倍(中心不变,半径扩大到原本的五倍)就一定能盖住<span class="math inline">\(I &#39;\)</span>.</p>
<p>那会怎么样呢?那<span class="math inline">\(m^* ( E \setminus (
\bigcup_{ k \leq N } I_k ) ) \leq 5 \sum_{ k \geq N + 1 } | I_k | &lt;
\epsilon\)</span>.于是证毕.</p>
<h4><span id="聚点原理">聚点原理</span></h4>
<p>假设<span class="math inline">\(M\)</span>是一个实数集,称<span class="math inline">\(x_0\)</span>是<span class="math inline">\(M\)</span>的聚点,当且仅当<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,<span class="math inline">\(( ( x_0 - \epsilon , x_0 ) \cup ( x_0 , x_0 +
\epsilon ) ) \cap M \ne \emptyset\)</span>,或说,<span class="math inline">\(\forall \epsilon &gt; 0 , ( x_0 - \epsilon , x_0 +
\epsilon ) \cap M\)</span>是一个无限集.可以理解为,<span class="math inline">\(x_0\)</span>不是一个孤点.</p>
<p>引理:<span class="math inline">\(x_0\)</span>为<span class="math inline">\(M\)</span>的聚点,当且仅当<span class="math inline">\(\exists \{ x_n \} \in M \setminus \{ x_0 \} ,
\lim_{ n \rightarrow \infty } x_n =
x_0\)</span>.充分性显然,必要性的话只需取<span class="math inline">\(\epsilon = 2^{ - n
}\)</span>然后从上面的交集拿点就行.</p>
<p>聚点原理:有界无穷集<span class="math inline">\(M\)</span>必有聚点.</p>
<p>我们可以找一个<span class="math inline">\(I_0 = [ a , b ] , M \subset
I_0\)</span>,我们找<span class="math inline">\([ a , \frac{ a + b }{ 2 }
] , [ \frac{ a + b }{ 2 } , b ]\)</span>,其中至少有一个和<span class="math inline">\(M\)</span>的交集为无穷集,我们取其为<span class="math inline">\([ a_1 , b_1
]\)</span>,不断这么做又会得到一个闭区间套列,交起来得到的那个元素<span class="math inline">\(c\)</span>就是聚点,因为<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N &gt; 0 ,
\forall n \geq N , | b_n - a_n | &lt; \epsilon\)</span>,那么<span class="math inline">\([ a_n , b_n ] \subseteq ( c - \epsilon , c +
\epsilon )\)</span>,立刻证毕.</p>
<h4><span id="baire纲定理">Baire纲定理</span></h4>
<ol type="1">
<li><p>设<span class="math inline">\(\{ F_n
\}\)</span>是一列内部为空(没有除空集以外的开子集)的闭集,则<span class="math inline">\(\bigcup_{ n = 1 }^{ \infty }
F_n\)</span>内部为空.</p></li>
<li><p>设<span class="math inline">\(\{ G_n
\}\)</span>是一列稠密(补集内部为空)的开集,则<span class="math inline">\(\bigcap_{ n = 1 }^{ \infty }
G_n\)</span>稠密.</p></li>
</ol>
<p>(1)(2)等价,下面只证明(1):</p>
<p>反证,假设<span class="math inline">\(F = \bigcup_{ n = 1 }^{ \infty }
F_n\)</span>内部不为空,也就是其存在一个内部开集<span class="math inline">\(( x_0 - \delta_0 , x_0 + \delta_0 ) \subseteq
F\)</span>.由于<span class="math inline">\(F_1\)</span>是一个闭集,因此<span class="math inline">\(( x_0 - \delta_0 , x_0 + \delta_0 ) \setminus
F_1\)</span>当然是一个开集,于是其就存在一个子区间<span class="math inline">\([ x_1 - \delta_1 , x_1 + \delta_1 ] \subseteq (
x_0 - \delta_0 , x_0 + \delta_0 )\)</span>并且<span class="math inline">\([ x_1 - \delta_1 , x_1 + \delta_1 ] \cap F_1 =
\emptyset\)</span>,同理可以找到一列闭区间<span class="math inline">\(\{
[ x_k - \delta_k , x_k + \delta_k ] \}\)</span>使得<span class="math inline">\([ x_k - \delta_k , x_k + \delta_k ] \cap \bigcup_{
j = 1 }^k F_j = \emptyset\)</span>.</p>
<p>容易见到我们可以任意调小<span class="math inline">\(\delta_k\)</span>的大小,调整使得<span class="math inline">\(\delta_k &lt; \frac{ 1 }{ k
}\)</span>总成立就得到了一列闭区间套,必然拿到了一个单独的点<span class="math inline">\(\xi\)</span>,那么<span class="math inline">\(\xi
\in ( x_0 - \delta_0 , x_0 + \delta_0 ) \subseteq
F\)</span>,然而对于任意区间都有<span class="math inline">\(\xi \notin
F_n\)</span>,因此<span class="math inline">\(\xi \notin
F\)</span>,这就导出了矛盾.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\(f ( x )\)</span>连续,并且<span class="math inline">\(\forall x &gt; 0 , \lim_{ n \rightarrow \infty } f
( nx ) = 0\)</span>,则<span class="math inline">\(\lim_{ x \rightarrow
\infty } f ( x ) = 0\)</span>.</p>
<p>对于一个<span class="math inline">\(\epsilon &gt;
0\)</span>,考虑构造内部为空的闭集<span class="math inline">\(F_n = \{ x
| \forall k \geq n , f ( kx ) \leq \epsilon
\}\)</span>(为什么这是闭集呢?因为当你设<span class="math inline">\(F_{ n
, k }\)</span>满足上述定义,那<span class="math inline">\(F_{ n , k
}\)</span>肯定是闭集,然后<span class="math inline">\(F_n\)</span>就是上述这些的交,当然也是闭集).容易发现<span class="math inline">\(F_n\)</span>的并是<span class="math inline">\(\mathbb{ R
}_+\)</span>,那就一定至少有一个闭集内部不为空,我们就可以取出其中的一个区间设为<span class="math inline">\(( a , b
)\)</span>,然后用这个区间在若干倍后覆盖后半部分数轴,原因是当<span class="math inline">\(n\)</span>足够大的时候,一定有<span class="math inline">\(nb &gt; ( n + 1 ) a\)</span>存在.</p>
<h4><span id="致密性定理">致密性定理</span></h4>
<p>有界无穷数列有收敛的子列.</p>
<p>考虑数列值域<span class="math inline">\(M = \{ x | x = x_n , n \in
\mathbb{ N }_+ \}\)</span>.</p>
<p>如果<span class="math inline">\(M\)</span>是有限集合,那<span class="math inline">\(\exists a\)</span>,<span class="math inline">\(I =
\{ n | x_n = a
\}\)</span>是无限集合,把这些数拿出来就是一个无限的常数列.</p>
<p>如果<span class="math inline">\(M\)</span>是无限集,那其存在聚点,设<span class="math inline">\(a\)</span>为其中一个聚点.则<span class="math inline">\(M_k = ( ( a - \frac{ 1 }{ k } , a + \frac{ 1 }{ k
} ) \setminus \{ a \} ) \cap M , k \in \mathbb{ N
}_+\)</span>是个无限集.</p>
<p>那只需要取<span class="math inline">\(x_{ n_k }\)</span>为<span class="math inline">\(M_k\)</span>中的某个<span class="math inline">\(x_{ n &#39; }\)</span>满足<span class="math inline">\(n &#39; &gt; n_{ k - 1
}\)</span>即可,由于这是无限集,所以显然可以取出.拿出来的这个数列显然以<span class="math inline">\(a\)</span>为极限.</p>
<h4><span id="柯西收敛准则">柯西收敛准则</span></h4>
<p>称一个数列为柯西数列,当且仅当<span class="math inline">\(\forall
\epsilon &gt; 0 , \exists N &gt; 0 , \forall n , m \geq N , | x_n - x_m
| &lt; \epsilon\)</span>.</p>
<p>一个数列收敛的充要条件是他是一个柯西数列.</p>
<p>先证必要性:</p>
<p><span class="math inline">\(\forall \epsilon &gt; 0 , \exists N &gt;
0 , \forall n , m \geq N , | a - x_n | &lt; \frac{ \epsilon }{ 2 } , | a
- x_m | &lt; \frac{ \epsilon }{ 2 } , | x_n - x_m | \leq | x_n - a | + |
a - x_m | &lt; \epsilon\)</span>.</p>
<p>再证充分性:</p>
<p>考虑取<span class="math inline">\(\epsilon = 1\)</span>,则<span class="math inline">\(\exists N_1 , \forall n \geq N_1 , | x_n - x_{ N_1
} | &lt; 1\)</span>,于是<span class="math inline">\(| x_n | &lt; | x_{
N_1 } | + 1\)</span>,于是<span class="math inline">\(\forall n , | x_n |
&lt; \max_{ k = 1 }^{ N_1 } \{ | x_k | \} +
1\)</span>,于是这个数列有界,那么存在无穷子列有极限<span class="math inline">\(a\)</span>.</p>
<p>那么<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N
&gt; 0 , \forall n_k , m \geq N , | x_{ n_k } - x_m | &lt;
\epsilon\)</span>,其中<span class="math inline">\(\{ x_{ n_k }
\}\)</span>以<span class="math inline">\(a\)</span>为极限,于是可以取足够远的<span class="math inline">\(x_{ n_k }\)</span>.接下来就是简单说明的环节了.</p>
<p>柯西收敛准则的充分性还可以用上下极限证明:</p>
<p>取<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N ,
\forall n \geq N , x_n \in ( x_N - \epsilon , x_N + \epsilon
)\)</span>,那么上下极限之差<span class="math inline">\(\leq 2
\epsilon\)</span>.</p>
<p>于是引出了实数的第二种定义方式:我们定义两个柯西列等价,有<span class="math inline">\(\{ x_n \} \sim \{ y_n \} \Leftrightarrow \lim_{ n
\rightarrow \infty } | x_n - y_n | =
0\)</span>.那么所有有理数组成的柯西列的等价类构成实数集合.不难证明这样定义出来的实数和戴德金分割等价.</p>
<p>这个定义方式只依赖于距离的定义.而且我们可以证明任何一次扩充后得到的空间一定是封闭的.用这个例子就是说你对于一个实数的柯西列,证明它一定收敛到一个实数.那么就可以把这个柯西列的每一个数(作为实数,实际上对应了一个柯西列)中抽出一个数来,然后证明这些数组成的新的柯西列与刚才那个柯西列等价,这样就证明了其封闭性.其实只要第<span class="math inline">\(k\)</span>个数把其代表的任意一个柯西列中选第<span class="math inline">\(k\)</span>个元素构造即可.</p>
<h4><span id="上下极限">上下极限</span></h4>
<p>我们推广广义极限,也就是一个数列可以以<span class="math inline">\(+
\infty\)</span>或者<span class="math inline">\(-
\infty\)</span>为极限.这个容易用<span class="math inline">\(\epsilon -
N\)</span>语言写出来.这样的话我们立刻得到单调数列有极限.</p>
<p>那我们取任意一个数列从某一项往后的上确界<span class="math inline">\(h_n = \sup_{ k \geq n } \{ x_k
\}\)</span>和下确界<span class="math inline">\(l_n = \inf_{ k \geq n }
\{ x_k \}\)</span>,那么注意到<span class="math inline">\(\{ l_n
\}\)</span>单调不降,<span class="math inline">\(\{ h_n
\}\)</span>单调不增,所以二者都存在极限.由此可以定义上下极限,并且任意数列都一定存在上下极限.</p>
<p>注意到<span class="math inline">\(\lim_{ n \rightarrow \infty } l_n =
\sup_{ n \geq 1 } \inf_{ k \geq n } \{ x_k \} , \lim_{ n \rightarrow
\infty } h_n = \inf_{ n \geq 1 } \sup_{ k \geq n } \{ x_k
\}\)</span>,于是<span class="math inline">\(\varliminf_{ n \rightarrow
\infty } x_n = \lim_{ n \rightarrow \infty } l_n \leq \lim_{ n
\rightarrow \infty } h_n = \varlimsup_{ n \rightarrow \infty }
x_n\)</span>.</p>
<p>那么<span class="math inline">\(x_n\)</span>存在极限当且仅当<span class="math inline">\(\varlimsup_{ n \rightarrow \infty } x_n =
\varliminf_{ n \rightarrow \infty } x_n\)</span>.</p>
<p>充分性很好证明,只需要使用夹逼定理即可.</p>
<p>必要性也很好说如果极限不是<span class="math inline">\(\infty\)</span>,<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall n
\geq N , a - \epsilon &lt; x_n &lt; a + \epsilon\)</span>,那么<span class="math inline">\(a - \epsilon &lt; l_n \leq h_n &lt; a +
\epsilon\)</span>.自然得到两者极限相等.是<span class="math inline">\(\infty\)</span>也很好说.</p>
<p>上下极限同样有保序性,相反数有<span class="math inline">\(\varlimsup (
- x ) = - \varliminf x\)</span>,但是不能简单的四则运算,而是有<span class="math inline">\(\varliminf x_n + \varliminf y_n \leq \varliminf (
x_n + y_n ) \leq \varlimsup ( x_n + y_n ) \leq \varlimsup x_n +
\varlimsup y_n\)</span>,我们这里先不讨论出现<span class="math inline">\(\infty - \infty\)</span>的情况.</p>
<p>证明的话只需注意到<span class="math inline">\(\inf_{ k \geq n } x_k +
\inf_{ k \geq n } y_k \leq x_m + y_m , \forall m \geq
n\)</span>,因此对右边可以取下确界,然后两边一起取极限即可.</p>
<p>另外还有结论是<span class="math inline">\(\varliminf ( x_n + y_n )
\leq \varlimsup x_n + \varliminf
y_n\)</span>.这个又如何证明呢?只需证明:</p>
$$
<span class="math display">\[\begin{aligned}
\varliminf ( x_n + y_n ) - \varlimsup x_n &amp; \leq \varliminf y_n \\
\varliminf ( x_n + y_n ) + \varliminf ( - x_n ) &amp; \leq \varliminf
y_n \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是证毕.</p>
<p>乘法的话需要规定<span class="math inline">\(x_n , y_n &gt;
0\)</span>,然后和加法的不等式形式是类似的(同样先不考虑<span class="math inline">\(0 \times \infty\)</span>的情况).</p>
<p>如果<span class="math inline">\(\{ x_n \} , \{ y_n
\}\)</span>其中一个存在极限,那么上面的不等式就可以取等了(当然仍然不讨论出现<span class="math inline">\(\infty - \infty\)</span>和<span class="math inline">\(0 \times \infty\)</span>的情况).如果<span class="math inline">\(x_n = y_n &gt;
0\)</span>的话上面的乘法不等式也可以取等,换言之<span class="math inline">\(x_n &gt; 0\)</span>的时候<span class="math inline">\(\varlimsup x_n^2 = ( \varlimsup x_n
)^2\)</span>成立.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于数列<span class="math inline">\(\{ a_n \}\)</span>,满足<span class="math inline">\(a_n &gt; 0\)</span>,<span class="math inline">\(a_{ n + 2 } = \frac{ 2 }{ a_{ n + 1 } + a_n
}\)</span>.</p>
<p>求证:</p>
<ol type="1">
<li><p><span class="math inline">\(\{ a_n \}\)</span>有界.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } a_n =
1\)</span>.</p></li>
<li><p><span class="math inline">\(\exists \lambda \in ( 0 , 1 ) , c
&gt; 0\)</span>,<span class="math inline">\(\forall n , | a_n - 1 | &lt;
c \lambda^n\)</span>.</p></li>
<li><p>对所有满足条件的数列,求<span class="math inline">\(\min ( \lambda
) = \frac{ \sqrt{ 2 } }{ 2 }\)</span>.</p></li>
</ol>
<p>对于(1),取<span class="math inline">\(M = \max ( \max ( a_1 , a_2 ) ,
\frac{ 1 }{ \min ( a_1 , a_2 ) } )\)</span>,数学归纳可证明<span class="math inline">\(a_n \in [ \frac{ 1 }{ M } , M ]\)</span>.</p>
<p>两边取一下上极限和下极限,立刻得到<span class="math inline">\(1 \leq
\overline{ a } \underline{ a } \leq 1\)</span>,于是<span class="math inline">\(\overline{ a } \underline{ a } = 1\)</span>.</p>
<p>后面不会了(乐).</p>
<h4><span id="stolz定理">Stolz定理</span></h4>
<p>如果<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
a_{ n + 1 } - a_n }{ b_{ n + 1 } - b_n } = A\)</span>,并且<span class="math inline">\(\{ b_n \}\)</span>单调递增且发散,那么<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ a_n }{ b_n }
= A\)</span>.</p>
<p>这个怎么证明呢?先取<span class="math inline">\(c_n = a_n -
Ab_n\)</span>,考虑<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists N &gt; 0 , \forall n \geq N\)</span>,有:</p>
<p><span class="math display">\[
c_{ n + 1 } - c_n \leq | c_{ n + 1 } - c_n | &lt; \epsilon ( b_{ n + 1 }
- b_n )
\]</span></p>
<p>两边求和,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
c_{ n } - c_N &amp; &lt; \epsilon ( b_{ n } - b_N ) \\
\frac{ c_n - c_N }{ b_n - b_N } &amp; &lt; \epsilon \\
\frac{ \frac{ c_n }{ b_n } - \frac{ c_N }{ b_n } }{ 1 - \frac{ b_N }{
b_n } } &amp; &lt; \epsilon
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(b_n\)</span>发散,对左边取极限就得到<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ c_n }{ b_n }
= 0\)</span>,也就证明了原结论.</p>
<p>如果将上述条件改为:</p>
<ol type="1">
<li><p><span class="math inline">\(\{ b_n \}\)</span>单调递减且<span class="math inline">\(\lim b_n = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\lim a_n = 0\)</span>.</p></li>
</ol>
<p>上述定理也是成立的.</p>
<p>证明仍然是上面那个过程,只是做一些小修改:</p>
<p><span class="math display">\[
\begin{aligned}
c_{ N } - c_n &amp; &lt; \epsilon ( b_{ N } - b_n ) \\
\frac{ c_N - c_n }{ b_N - b_n } &amp; &lt; \epsilon \\
\frac{ \frac{ c_N }{ b_N } - \frac{ c_n }{ b_N } }{ 1 - \frac{ b_n }{
b_N } } &amp; &lt; \epsilon
\end{aligned}
\]</span></p>
<p>两边取极限.</p>
<p>把Stolz定理推广到上下极限上.换言之,当:</p>
<ol type="1">
<li><span class="math inline">\(\{ b_n
\}\)</span>单调上升且趋近于无穷.</li>
</ol>
<p>或:</p>
<ol type="1">
<li><p><span class="math inline">\(\{ b_n \}\)</span>单调递减且<span class="math inline">\(\lim b_n = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\lim a_n = 0\)</span>.</p></li>
</ol>
<p>此时应当有:</p>
<p><span class="math display">\[
\varliminf \frac{ a_{ n + 1 } - a_n }{ b_{ n + 1 } - b_n } \leq
\varliminf \frac{ a_n }{ b_n } \leq \varlimsup \frac{ a_n }{ b_n } \leq
\varlimsup \frac{ a_{ n + 1 } - a_n }{ b_{ n + 1 } - b_n }
\]</span></p>
<p>上述命题的一个平凡推论是:</p>
<p><span class="math display">\[
\varliminf ( a_{ n + 1 } - a_n ) \leq \varliminf \frac{ a_n }{ n } \leq
\varlimsup \frac{ a_n }{ n } \leq \varlimsup ( a_{ n + 1 } - a_n )
\]</span></p>
<h3><span id="实数的完备性基本定理">实数的完备性基本定理</span></h3>
<p>我们将以下定理称作实数的完备性的基本定理:</p>
<ol start="0" type="1">
<li><p>戴德金分割定理</p></li>
<li><p>确界存在定理</p></li>
<li><p>单调收敛准则</p></li>
<li><p>闭区间套定理(+阿基米德性质)</p></li>
<li><p>有限覆盖定理</p></li>
<li><p>聚点原理</p></li>
<li><p>致密性定理</p></li>
<li><p>柯西收敛准则(+阿基米德性质)</p></li>
</ol>
<p>这七条定理(除了3和7,它们需要与阿基米德性质配合使用)全部与戴德金分割定理等价.</p>
<p>我们上面已经论证了其中的部分推导关系,我们在下面声称它们分为若干组推导链条,分别代表了实数的不同性质.</p>
<h3><span id="函数极限">函数极限</span></h3>
<h4><span id="定义">定义</span></h4>
<p>函数的极限类型比较多:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>是从一点<span class="math inline">\(a\)</span>的右侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x
\rightarrow a + 0\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>是从一点<span class="math inline">\(a\)</span>的左侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x
\rightarrow a - 0\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>同时从一点<span class="math inline">\(a\)</span>的两侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x
\rightarrow a\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>无限制增大,记作<span class="math inline">\(x \rightarrow + \infty\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>无限制减小,记作<span class="math inline">\(x \rightarrow - \infty\)</span>.</p></li>
<li><p><span class="math inline">\(| x |\)</span>无限制增大,<span class="math inline">\(x\)</span>同时增大或减小,记作<span class="math inline">\(x \rightarrow \infty\)</span>.</p></li>
</ol>
<p>序列极限的定理在函数极限的条件下几乎也全都成立.</p>
<h5><span id="单侧极限">单侧极限</span></h5>
<p>即<span class="math inline">\(x \rightarrow a + 0\)</span>和<span class="math inline">\(x \rightarrow a -
0\)</span>,这两种是对称的,我们只讨论前一种.</p>
<p>若<span class="math inline">\(\exists l , \forall \epsilon &gt; 0 ,
\exists \delta &gt; 0 , \forall 0 &lt; x - a &lt; \delta , | f ( x ) - l
| &lt; \epsilon\)</span>.我们称<span class="math inline">\(l\)</span>是<span class="math inline">\(x
\rightarrow a + 0\)</span>时<span class="math inline">\(f ( x
)\)</span>的<strong>右极限</strong>,记作<span class="math inline">\(\lim_{ x \rightarrow a + 0 } f ( x ) = l
\\\)</span>,同理可以定义<strong>左极限</strong>.</p>
<h5><span id="双侧极限">双侧极限</span></h5>
<p>若左右极限都存在且相等,那么双侧极限也存在并且<span class="math inline">\(\lim_{ x \rightarrow a } f ( x ) = \lim_{ x
\rightarrow a + 0 } f ( x ) = \lim_{ x \rightarrow a - 0 } f ( x )
\\\)</span>.</p>
<h5><span id="自变量趋于无穷时的极限">自变量趋于无穷时的极限</span></h5>
<p>设函数<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( a , + \infty )\)</span>上有定义,若<span class="math inline">\(\exists l\)</span>,<span class="math inline">\(\forall \epsilon , \exists A \geq a , \forall x
&gt; A , | f ( x ) - l | &lt; \epsilon\)</span>,则记<span class="math inline">\(\lim_{ x \rightarrow + \infty } f ( x ) = l
\\\)</span>,同理定义<span class="math inline">\(\lim_{ x \rightarrow -
\infty }\)</span>,若二者均存在且相等,定义<span class="math inline">\(\lim_{ x \rightarrow \infty } = \lim_{ x
\rightarrow + \infty } = \lim_{ x \rightarrow - \infty }\)</span>.</p>
<h4><span id="上下极限">上下极限</span></h4>
<p>定义去心邻域<span class="math inline">\(U_0 ( x_0 , \delta ) = ( x_0
- \delta , x_0 + \delta ) \setminus \{ x_0 \}\)</span>.</p>
<p>定义<span class="math inline">\(\varlimsup_{ x \rightarrow x_0 } f (
x ) = \lim_{ \delta \rightarrow + 0 } \sup_{ x \in U_0 ( x_0 , \delta )
} f ( x )\)</span>,下极限同理.</p>
<p>显然<span class="math inline">\(\lim_{ x \rightarrow x_0 } f ( x ) =
A \Leftrightarrow \varlimsup_{ x \rightarrow x_0 } f ( x ) =
\varliminf_{ x \rightarrow x_0 } f ( x ) = A\)</span>.</p>
<h4><span id="第一可数公理">第一可数公理</span></h4>
<p>函数极限当然满足四则运算法则,保序性,夹逼定理,单调收敛准则,柯西收敛准则.</p>
<p>事实上函数极限和数列极限满足关系:</p>
<p><span class="math inline">\(\forall \{ x_n \} \in U_0 ( x_0
)\)</span>,如果<span class="math inline">\(\lim_{ n \rightarrow \infty }
x_n = x_0\)</span>,那么<span class="math inline">\(\lim_{ n \rightarrow
\infty } f ( x_n ) = \lim_{ x \rightarrow x_0 } f ( x
)\)</span>,前提是这两个极限都存在.</p>
<p>证明是堆<span class="math inline">\(\delta -
\epsilon\)</span>语言,不再赘述.</p>
<p>而它们之间关系的本质其实是:<span class="math inline">\(x_0\)</span>处的”任意小邻域”其实可以用某列邻域替代.</p>
<p>我们定义邻域基:一个由<span class="math inline">\(x_0\)</span>的邻域组成的集合<span class="math inline">\(U\)</span>,如果对于任意小邻域,<span class="math inline">\(U\)</span>中都存在一个邻域比这个邻域更小,那么就称<span class="math inline">\(U\)</span>是一个邻域基.<span class="math inline">\(\mathbb{ R
}\)</span>的特殊之处在于任意一个点都有可数邻域基,这被称为第一可数公理(<span class="math inline">\(C_1\)</span>公理).</p>
<p>另外<span class="math inline">\(\mathbb{ R
}\)</span>是可分的,也就是它存在可数稠密集(<span class="math inline">\(\mathbb{ Q }\)</span>).</p>
<h4><span id="无穷大量和无穷小量">无穷大量和无穷小量</span></h4>
<p>如果<span class="math inline">\(x \rightarrow x_0\)</span>时,<span class="math inline">\(f ( x )\)</span>有界,称<span class="math inline">\(f ( x ) = O ( 1 )\)</span>.</p>
<p>如果<span class="math inline">\(x \rightarrow
x_0\)</span>的时候,<span class="math inline">\(f ( x ) \rightarrow
0\)</span>,称<span class="math inline">\(f ( x ) = o ( 1 )\)</span>.</p>
<p>如果<span class="math inline">\(f , g = o ( 1 )\)</span>,<span class="math inline">\(\frac{ f }{ g } \rightarrow
1\)</span>,那么称二者为<strong>等价无穷小</strong>;如果<span class="math inline">\(\frac{ f }{ g } = c \ne
0\)</span>,则称二者为同阶无穷小(可记作<span class="math inline">\(f \sim
g\)</span>);如果<span class="math inline">\(\frac{ f }{ g } =
0\)</span>,则称<span class="math inline">\(f\)</span>为<span class="math inline">\(g\)</span>的<strong>高阶无穷小</strong>,可记作<span class="math inline">\(f = o ( g )\)</span>.</p>
<p>同阶无穷小在做乘除法的时候是可以替换的.</p>
<p>如果<span class="math inline">\(\frac{ f }{ g
}\)</span>是有界的,那么可以写作<span class="math inline">\(f = O ( g
)\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(\lim_{ x \rightarrow 0 } \frac{ \sin x }{
x } = 1\)</span>.</p>
<p>因为其左右对称,考虑取<span class="math inline">\(x \in ( 0 , \frac{
\pi }{ 2 } )\)</span>我们有<span class="math inline">\(\sin x &lt; x
&lt; \tan x\)</span>(用单位元的面积证明).</p>
<p>那么考虑<span class="math inline">\(\frac{ \sin x }{ x } &lt;
1\)</span>,又注意到:</p>
<p><span class="math display">\[
\frac{ \sin x }{ x } &gt; \frac{ \sin x }{ \tan x } = \cos x
\]</span></p>
<p>夹逼定理一下就行.</p>
<p>类似可以证明<span class="math inline">\(\lim_{ x \rightarrow 0 }
\frac{ \tan x }{ x } = 1 , \lim_{ x \rightarrow 0 } \frac{ 1 - \cos x }{
x^2 } = \frac{ 1 }{ 2 } ,\)</span></p>
<h6><span id="example2">Example2</span></h6>
<p><span class="math inline">\(\lim_{ x \rightarrow 0 } \frac{ x - \sin
x }{ x^3 } = \frac{ 1 }{ 6 }\)</span>.</p>
<p>下面有个三次方,考虑套用一下三倍角公式,我们知道:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = \frac{ x - \sin x }{ x^3 } = \frac{ x - ( 3 \sin \frac{
x }{ 3 } - 4 \sin^3 \frac{ x }{ 3 } ) }{ x^3 } \\
&amp; = \frac{ 3 ( \frac{ x }{ 3 } - \sin \frac{ x }{ 3 } ) + 4 \sin^3
\frac{ x }{ 3 } }{ ( \frac{ x }{ 3 } )^3 } \frac{ 1 }{ 27 } \\
&amp; = \frac{ 1 }{ 9 } f ( \frac{ x }{ 3 } ) + \frac{ 4 }{ 27 } (
\frac{ \sin \frac{ x }{ 3 } }{ \frac{ x }{ 3 } } )^3
\end{aligned}
\]</span></p>
<p>看上去两边取上下极限就做完了对吧!但是还差一点,因为我们要证明上下极限都不是无穷,起码得说明它有界.</p>
<p>注意到<span class="math inline">\(\frac{ x - \sin x }{ x^3 } &lt;
\frac{ \tan x - \sin x }{ x^3 } = \frac{ \sin x }{ x } ( \frac{ 1 - \cos
x }{ x^2 \cos x } ) = \frac{ \sin x }{ x } ( \frac{ 2 \sin^2 \frac{ x }{
2 } }{ x^2 \cos x }
)\)</span>,这样两边限定一下范围再取上极限可以说明原式上极限有界.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\lim_{ x \rightarrow 0 } \frac{ \sin x
- \tan x }{ x^3 }\)</span>.</p>
<p>考虑<span class="math inline">\(\frac{ \sin x - \tan x }{ x^3 } =
\frac{ \sin x }{ x } \frac{ 1 }{ x^2 } \frac{ \cos x - 1 }{ \cos x } =
\frac{ \tan x }{ x } \frac{ \cos x - 1 }{ x^2 } = - \frac{ 1 }{ 2
}\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p><span class="math inline">\(\lim_{ t \rightarrow 0 } \frac{ \log_{ a
} ( 1 + t ) }{ t } = \frac{ 1 }{ \ln a }\)</span>.</p>
<p><span class="math display">\[
\lim_{ t \rightarrow 0 } \frac{ \log_{ a } ( 1 + t ) }{ t } = \log_a
\lim_{ t \rightarrow 0 } ( 1 + t )^{ \frac{ 1 }{ t } } = \log_a e =
\frac{ 1 }{ \ln a }
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(\lim_{ t \rightarrow 0 } \frac{ a^t - 1
}{ t } = \ln a\)</span>.</p>
<p>令<span class="math inline">\(s = a^t - 1\)</span>,则原式等于<span class="math inline">\(\lim_{ s \rightarrow 0 } \frac{ s }{ \log_a ( s +
1 ) } = \ln a\)</span>.</p>
<h6><span id="example6">Example6</span></h6>
<p><span class="math inline">\(\lim_{ t \rightarrow 0 } \frac{ ( 1 + t
)^\mu - 1 }{ t } = \mu\)</span>.</p>
<p>令<span class="math inline">\(s = ( 1 + t )^\mu -
1\)</span>,那么原式等于<span class="math inline">\(\lim_{ t \rightarrow
0 , s \rightarrow 0 } \mu \frac{ s }{ \ln ( 1 + s ) } \frac{ \ln ( 1 + t
) }{ t } = \mu\)</span>.</p>
<h4><span id="连续函数">连续函数</span></h4>
<p>不妨设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( a , b )\)</span>上有定义,若对于<span class="math inline">\(x_0 \in ( a , b )\)</span>,<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处有双侧极限且<span class="math inline">\(\lim_{ x \rightarrow x_0 } f ( x ) = f ( x_0
)\)</span>,称其在<span class="math inline">\(x_0\)</span>处<strong>连续</strong>,<span class="math inline">\(x_0\)</span>称为<strong>连续点</strong>,若<span class="math inline">\(\forall x_0 \in ( a , b )\)</span>,<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续,则称其在<span class="math inline">\(( a , b
)\)</span>上<strong>连续</strong>.连续性相当于说:取极限和<span class="math inline">\(f\)</span>可以交换顺序,换言之<span class="math inline">\(\lim_{ x \rightarrow x_0 } f ( x ) = f ( \lim_{ x
\rightarrow x_0 } x )\)</span>.</p>
<p>我们也可以类似上面定义<strong>左连续</strong>和<strong>右连续</strong>,若<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a
, b ]\)</span>上有定义,且在<span class="math inline">\(( a , b
)\)</span>上连续,在<span class="math inline">\(a\)</span>处右连续,在<span class="math inline">\(b\)</span>处左连续,称其在<span class="math inline">\([ a , b ]\)</span>上连续.</p>
<p>如果<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>附近有定义且不连续,则称<span class="math inline">\(x_0\)</span>是一个<strong>间断点</strong>,间断点有以下几种:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\lim_{ x \rightarrow x_0 + 0 } f
( x )\)</span>和<span class="math inline">\(\lim_{ x \rightarrow x_0 - 0
} f ( x )\)</span>都存在但不相等或者不等于<span class="math inline">\(f
( x_0
)\)</span>,则称为<strong>第一类间断点</strong>.如果是后者情况,可以通过修改<span class="math inline">\(f ( x_0
)\)</span>的定义来去掉这个间断点,因而一般被称为<strong>可去间断点</strong>.</p></li>
<li><p>反之,如果<span class="math inline">\(\lim_{ x \rightarrow x_0 + 0
} f ( x )\)</span>和<span class="math inline">\(\lim_{ x \rightarrow x_0
- 0 } f ( x
)\)</span>至少有一个不存在,则称为<strong>第二类间断点</strong>.</p></li>
</ol>
<p>使用单调收敛准则,可证明单调函数没有第二类间断点.并且单调函数的间断点只有可数个(几乎处处连续).</p>
<p>这个怎么证明呢?考虑设<span class="math inline">\(M\)</span>是函数<span class="math inline">\(f\)</span>的第一类间断点集,取<span class="math inline">\(x \in M , I_x = ( f ( x_0 - 0 ) , f ( x_0 + 0 )
)\)</span>,由于函数单调,所以这些<span class="math inline">\(I_x\)</span>两两不交.考虑映射<span class="math inline">\(M \rightarrow \mathbb{ Q } , x \mapsto \min ( I_x
\cap \mathbb{ Q } )\)</span>,也就是考虑每一个<span class="math inline">\(I_x\)</span>中都有若干个有理数,且互不相交,那么显然这个映射是个单射,<span class="math inline">\(M\)</span>可数.</p>
<p>事实上有更强的结论:任意函数的第一类间断点集都是可数的.</p>
<p>设<span class="math inline">\(M\)</span>是函数<span class="math inline">\(f\)</span>的第一类间断点集,取<span class="math inline">\(M_n = \{ x \in M \mid | f ( x + 0 ) - f ( x - 0 )
| &gt; \frac{ 1 }{ n } \} , M &#39; = \{ x \in M | f ( x + 0 ) = f ( x -
0 ) \ne f ( x ) \}\)</span>.</p>
<p>注意到<span class="math inline">\(M = ( \bigcup_{ n \geq 1 } M_n )
\cup M &#39;\)</span>.</p>
<p>我们定义孤立点:如果<span class="math inline">\(x \in A , \exists
\sigma , ( x - \sigma , x + \sigma ) \nsubseteq A\)</span>,则称<span class="math inline">\(x\)</span>是<span class="math inline">\(A\)</span>中的一个孤立点.类似刚才证明可数性,我们每个孤立点都可以取一段邻域,领域中一定存在有理数,所以任意一个集合中的孤立点个数一定是可数的.</p>
<p>又发现所有的<span class="math inline">\(x \in M_n\)</span>,<span class="math inline">\(x\)</span>都是孤立点,原因很显然因为在<span class="math inline">\(x\)</span>的两侧小区间都在趋近于一个极限,所以它们肯定不是第一类间断点.所以所有的<span class="math inline">\(M_n\)</span>都是可数集.</p>
<p>那怎么证明<span class="math inline">\(M
&#39;\)</span>是可数集呢?考虑取<span class="math inline">\(M &#39;_n =
\{ x \in M | | f ( x ) - f ( x - 0 ) | &gt; \frac{ 1 }{ n }
\}\)</span>,现在<span class="math inline">\(M &#39; = \bigcup_{ n \geq 1
} M &#39;_n\)</span>,而<span class="math inline">\(M
&#39;_n\)</span>一定是孤立点集,所以<span class="math inline">\(M
&#39;\)</span>可数.</p>
<p>综上就可以看出<span class="math inline">\(M\)</span>是一个可数集.</p>
<p>而第二类间断点则是可以有任意多个,例如对于迪利克雷函数,其处处都是第二类间断点.</p>
<p>由于连续性由极限定义,这意味着在<span class="math inline">\(( a , b
)\)</span>上的连续函数的有定义的四则运算必定得到的还是在<span class="math inline">\(( a , b
)\)</span>上的连续函数.那么,如果我们对于一个区间<span class="math inline">\(I\)</span>,定义<span class="math inline">\(C ( I
)\)</span>为所有在<span class="math inline">\(I\)</span>上连续的函数组成的集合,<span class="math inline">\(C ( I
)\)</span>就是一个线性空间.且不难发现,连续函数的复合仍然是连续函数.这其实对应着<span class="math inline">\(\lim_{ x \rightarrow a } g ( f ( x ) ) = g (
\lim_{ x \rightarrow a } f ( x ) ) = g ( f ( a ) ) \\\)</span>.</p>
<p>另外,如果一个连续函数有单值反函数,则反函数必连续.</p>
<p>不难证明,所有的初等函数在定义域上都是连续的.</p>
<p>另外:连续周期非常值函数一定有最小正周期.</p>
<p>考虑设正周期的集合是<span class="math inline">\(\{ t
\}\)</span>,取<span class="math inline">\(T = \inf \{ t \}\)</span>.</p>
<p>当<span class="math inline">\(T =
0\)</span>的时候,取一个正周期的数列<span class="math inline">\(\{ t_n \}
\rightarrow 0\)</span>,然后<span class="math inline">\(\forall x &lt; y
, x_n = x + \lfloor \frac{ y - x }{ t_n } \rfloor t_n , | y - x_n | \leq
t_n \rightarrow 0\)</span>,于是<span class="math inline">\(\lim_{ n } f
( x_n ) = f ( y )\)</span>,而恒有<span class="math inline">\(f ( x ) = f
( x_n )\)</span>于是这是一个常值函数.</p>
<p>反之,则取<span class="math inline">\(\{ t_n \} \rightarrow T , f ( x
+ T ) = \lim_{ n } f ( x + t_n ) = f ( x )\)</span>.</p>
<h5><span id="一致连续">一致连续</span></h5>
<p>假设<span class="math inline">\(f : I \rightarrow \mathbb{ R
}\)</span>,若<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists \delta &gt; 0 , \forall x_1 , x_2 \in I , | x_1 - x_2 | &lt;
\delta , | f ( x_1 ) - f ( x_2 ) | &lt;
\epsilon\)</span>,则称其<strong>一致连续</strong>.一致连续性是一个比连续性强得多的性质,例如<span class="math inline">\(f ( x ) = x^2\)</span>就不是一致连续的.</p>
<h5><span id="李氏连续">李氏连续</span></h5>
<p>假设<span class="math inline">\(f : I \rightarrow \mathbb{ R
}\)</span>,若<span class="math inline">\(\exists L , \forall x_1 , x_2
\in I , | f ( x_1 ) - f ( x_2 ) | \leq L | x_1 - x_2
|\)</span>,则称其<strong>李氏连续</strong>.李氏连续当然强于一致连续.</p>
<h4><span id="闭区间下的连续函数">闭区间下的连续函数</span></h4>
<h5><span id="介值定理零点存在定理">介值定理(零点存在定理)</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义且连续,<span class="math inline">\(f ( a ) \ne f ( b )\)</span>,则<span class="math inline">\(\forall \eta \in ( f ( a ) , f ( b ) ) , \exists c
\in ( a , b ) , f ( c ) = \eta\)</span>.这当然等价于<span class="math inline">\(f ( a ) f ( b ) &lt; 0 \Rightarrow \exists c \in (
a , b ) , f ( c ) = 0\)</span>.</p>
<p>考虑取<span class="math inline">\(f ( \frac{ a + b }{ 2 }
)\)</span>,如果<span class="math inline">\(f ( \frac{ a + b }{ 2 } ) =
0\)</span>那就完事了.不然的话考虑<span class="math inline">\(f ( a ) f (
\frac{ a + b }{ 2 } )\)</span>和<span class="math inline">\(f ( \frac{ a
+ b }{ 2 } ) f ( b )\)</span>中必定有恰好一个小于<span class="math inline">\(0\)</span>,这当然给出一个闭区间套,不妨设最后套出了一个单点<span class="math inline">\(c\)</span>.此时取极限立刻有<span class="math inline">\(0 \geq \lim f ( a_n ) f ( b_n ) = f ( c
)^2\)</span>,于是<span class="math inline">\(f ( c ) = 0\)</span>.</p>
<p>也有一个存在性证明:反证,如果<span class="math inline">\(\forall x \in
[ a , b ]\)</span>,<span class="math inline">\(f ( x ) \ne
0\)</span>.那么<span class="math inline">\(\forall x \in [ a , b ] ,
\exists \delta ( x ) &gt; 0\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\(( x -
\delta ( x ) , x + \delta ( x ) )\)</span>与<span class="math inline">\(f ( x
)\)</span>同号.根据有限覆盖定理,我们可以拿出有限个开区间来覆盖整个区间.此时可以将这些开区间排序,相邻两个区间两两有交,自然导出矛盾.</p>
<p>介质定理还有两个推论:</p>
<ol type="1">
<li><p><strong>介值定理的推论1</strong>:设<span class="math inline">\(f
( x )\)</span>在<span class="math inline">\([ a , b
]\)</span>上有定义且连续,那么<span class="math inline">\([ f ( a ) , f (
b ) ] \subseteq\)</span>其值域.</p></li>
<li><p><strong>介值定理的推论2</strong>:单调连续函数的反函数仍然是单调连续函数.</p></li>
</ol>
<p>推论(1)显然,考虑推论(2)的证明:</p>
<p>考虑对于连续单增函数<span class="math inline">\(f ( x ) \in C ( a , b
) , \alpha = f ( a + 0 ) , \beta = f ( b - 0
)\)</span>.先要证明其存在反函数<span class="math inline">\(\varphi \in C
( \alpha , \beta )\)</span>.</p>
<p>这里有一点小问题是我们要用介值定理要把定义域控制在闭区间,但这当然是好做的,对于任何一个<span class="math inline">\(c \in ( a , b )\)</span>,你一定可以取一个<span class="math inline">\(a_1 , b_1\)</span>使得<span class="math inline">\(f ( a_1 ) &lt; f ( c ) &lt; f ( b_1
)\)</span>,这样<span class="math inline">\(f ( x ) \in C [ a_1 , b_1
]\)</span>.</p>
<p>这样的话容易说明<span class="math inline">\(f\)</span>是<span class="math inline">\(( a , b ) \rightarrow ( \alpha , \beta
)\)</span>的双射,于是反函数是存在的.反函数的单调性是好证的.</p>
<p>对于反函数的连续性,反证,假设其在某一点<span class="math inline">\(c
\in ( \alpha , \beta )\)</span>处不连续,必然意味着<span class="math inline">\(a &lt; \varphi ( c - 0 ) &lt; \varphi ( c + 0 )
&lt; b\)</span>.此时容易说明<span class="math inline">\(\varphi ( x )
\in ( a , b ) \setminus ( \varphi ( c - 0 ) , \varphi ( c + 0 ) ) \cup
\{ \varphi ( c ) \}\)</span>,那只需要取<span class="math inline">\(w \in
( \varphi ( c - 0 ) , \varphi ( c + 0 ) ) \setminus \{ \varphi ( c )
\}\)</span>,<span class="math inline">\(\nexists x , \varphi ( x ) =
w\)</span>,这当然与我们上述结论不符.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于连续函数<span class="math inline">\(f \in C [ a , b ] , \forall
x_0 \in [ a , b ] \setminus \mathbb{ Q } , \varlimsup_{ \Delta x
\rightarrow 0 + 0 } \frac{ f ( x_0 + \Delta x ) - f ( x_0 ) }{ \Delta x
} \geq 0\)</span>,求证:<span class="math inline">\(f\)</span>单调递增.</p>
<p>先考虑把条件改成<span class="math inline">\(\forall x_0 \in [ a , b
]\)</span>怎么做.</p>
<p>一个想法是反证,如果不单调的话,找一个点使得它的右上导数小于<span class="math inline">\(0\)</span>.最自然的想法是找最大值,但最大值有可能只能证明右上导数<span class="math inline">\(\leq
0\)</span>.所以有一个想法是拿一条稍微斜一点(也就是斜率为较小的负数)的直线去截整个曲线.</p>
<p>下面反证,如果其不单增,总能找到两个点<span class="math inline">\(a
&#39; &lt; b &#39;\)</span>,使得<span class="math inline">\(f ( a &#39;
) &gt; f ( b &#39; )\)</span>.此时任意取一个<span class="math inline">\(\epsilon_0 &lt; f ( a &#39; ) - f ( b &#39;
)\)</span>,然后取一个点<span class="math inline">\(B = ( b &#39; , f ( b
&#39; ) + \epsilon_0 )\)</span>.当然可以再取一个<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(\epsilon + \epsilon_0 &lt; f ( a &#39; ) - f ( b
&#39; )\)</span>,然后取一个点<span class="math inline">\(A = ( a &#39; ,
f ( b &#39; ) + \epsilon_0 + \epsilon )\)</span>,这样<span class="math inline">\(AB\)</span>这条直线确定了一条斜率<span class="math inline">\(k &lt; 0\)</span>的一次函数<span class="math inline">\(g ( x )\)</span>,不妨设<span class="math inline">\(h ( x ) = f ( x ) - g ( x )\)</span>,容易发现<span class="math inline">\(h ( a &#39; ) &gt; 0 , h ( b &#39; ) &lt;
0\)</span>,所以可以取一个变号零点<span class="math inline">\(x_\epsilon
= \sup \{ x | h ( x ) \geq 0 , x \in [ a &#39; , b &#39; ]
\}\)</span>.当<span class="math inline">\(\epsilon\)</span>取值不一样的时候当然可以取不同的而且是不可数个<span class="math inline">\(x_\epsilon\)</span>,此时可以取出一个无理数<span class="math inline">\(x_0\)</span>,那考虑<span class="math inline">\(\varlimsup_{ \Delta x \rightarrow 0 + 0 } \frac{ f
( x_0 + \Delta x ) - f ( x_0 ) }{ \Delta x } = \varlimsup_{ \Delta x
\rightarrow 0 + 0 } \frac{ h ( x_0 + \Delta x ) }{ \Delta x } + k \leq k
&lt; 0\)</span>,这就矛盾了.</p>
<h5><span id="有界定理">有界定理</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义且连续,<span class="math inline">\(\exists A , B\)</span>,<span class="math inline">\(\forall x_0 \in [ a , b ] , A \leq f ( x_0 ) \leq
B\)</span>.</p>
<p>可以用之前的有限覆盖定理所证明的闭区间上的局部有界函数是有界函数,然后还有另一个证明:</p>
<p>假设无界,则存在一个数列<span class="math inline">\(\{ x_n
\}\)</span>使得<span class="math inline">\(| f ( x_n ) | \rightarrow +
\infty\)</span>.由于<span class="math inline">\(\{ x_n
\}\)</span>是有界数列,其一定有收敛子列<span class="math inline">\(\{ x
&#39;_n \}\)</span>收敛于<span class="math inline">\(x
&#39;\)</span>,当然<span class="math inline">\(| f ( x &#39; ) | =
\lim_{ n \rightarrow \infty } | f ( x_n ) | = +
\infty\)</span>,这当然产生了矛盾.</p>
<p>还有一个闭区间套的证明方式:你考虑每次区间分两半,一定有其中一半是无界的,然后做闭区间套.</p>
<h5><span id="最值定理">最值定理</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义且连续,<span class="math inline">\(\exists x_1 , x_2 \in [ a , b ]\)</span>,<span class="math inline">\(\forall x_0 \in [ a , b ] , f ( x_1 ) \leq f ( x_0
) \leq f ( x_2 )\)</span>.</p>
<p>考虑先用有界定理得知<span class="math inline">\(f ( x ) \in C [ a , b
]\)</span>有界,然后就可以拿到其上下确界<span class="math inline">\(m
\leq f ( x ) \leq M\)</span>,只需证明其上下确界均能取到就行.</p>
<p>反证,考虑若<span class="math inline">\(M\)</span>取不到,那考虑定义<span class="math inline">\(g ( x ) = \frac{ 1 }{ M - f ( x ) } &gt;
0\)</span>,根据有界定理<span class="math inline">\(g ( x
)\)</span>有上界<span class="math inline">\(C\)</span>,于是<span class="math inline">\(\frac{ 1 }{ M - f ( x ) } \leq C \Rightarrow f ( x
) \leq M - \frac{ 1 }{ C }\)</span>,矛盾.</p>
<p>或者我们知道<span class="math inline">\(M\)</span>是上确界则<span class="math inline">\(M - \frac{ 1 }{ n }\)</span>不是上界,取出<span class="math inline">\(\{ x_n \}\)</span>使得<span class="math inline">\(M - \frac{ 1 }{ n } &lt; f ( x_n ) \leq
M\)</span>,那么<span class="math inline">\(\{ x_n
\}\)</span>必然有收敛子列,设其收敛于<span class="math inline">\(x_0\)</span>,那么根据夹逼定理必然能得到<span class="math inline">\(f ( x_0 ) = M\)</span>.</p>
<h5><span id="康托尔定理">康托尔定理</span></h5>
<p>有界闭区间上的连续函数必然一致连续.</p>
<p>考虑反证,反命题是<span class="math inline">\(\exists \epsilon_0 &gt;
0 , \forall n &gt; 0 , \exists x &#39;_n , x &#39; &#39;_n , | x &#39;_n
- x &#39; &#39;_n | &lt; \frac{ 1 }{ n } , | f ( x &#39;_n ) - f ( x
&#39; &#39;_n ) | \geq \epsilon_0\)</span>.</p>
<p>用致密性定理,取出<span class="math inline">\(\{ x &#39;_n
\}\)</span>的收敛子列,可以拿到<span class="math inline">\(\{ x &#39;
&#39;_n \}\)</span>与其对应的数列,二者必然同时收敛于一个值<span class="math inline">\(x_0\)</span>,那么<span class="math inline">\(| f (
x &#39;_n ) - f ( x &#39; &#39;_n ) | = 0 \geq
\epsilon_0\)</span>,当然矛盾.</p>
<p>如果是开区间呢?如果<span class="math inline">\(f ( x ) \in C ( a , b
]\)</span>,其在开区间<span class="math inline">\(( a , b
]\)</span>上一致连续,这需要等价于<span class="math inline">\(\forall x_n
\in ( a , b ) , x_n \rightarrow a\)</span>,<span class="math inline">\(\{ f ( x_n ) \}\)</span>是柯西列(也就是<span class="math inline">\(f ( a + 0
)\)</span>极限存在),由此看出开区间上的一致连续函数必然能延拓称闭区间上的连续函数.</p>
<h4><span id="不动点和周期点">不动点和周期点</span></h4>
<p>定义<span class="math inline">\(f ( x
)\)</span>的<strong>不动点</strong><span class="math inline">\(\text{
fix } f ( x ) \Leftrightarrow f ( x ) =
x\)</span>,<strong>周期点</strong><span class="math inline">\(P_n = \{ x
| f^{ [ n ] } ( x ) = x \land \forall 0 &lt; m &lt; n , f^{ [ m ] } ( x
) \ne x \}\)</span>,其中<span class="math inline">\(f^{ [ n ] } ( x
)\)</span>表示将<span class="math inline">\(f\)</span>复合<span class="math inline">\(n\)</span>次.</p>
<h5><span id="压缩映照原理">压缩映照原理</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义并且<span class="math inline">\(f ( [ a , b ] ) \subseteq [ a , b
]\)</span>,并且满足<span class="math inline">\(\exists 0 \leq q &lt; 1 ,
\forall x , y \in [ a , b ] , | f ( x ) - f ( y ) | \leq q | x - y
|\)</span>,那么<span class="math inline">\([ a , b
]\)</span>上存在唯一的不动点<span class="math inline">\(c\)</span>.</p>
<p>任取一个点<span class="math inline">\(x_0 \in [ a , b
]\)</span>,考虑<span class="math inline">\(x_{ n + 1 } = f ( x_n
)\)</span>,然后尝试判断这个数列的极限,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
| x_{ n + 1 } - x_n | &amp; = | f ( x_n ) - f ( x_{ n - 1 } ) | \leq q |
x_n - x_{ n - 1 } | \leq q^{ n } | x_1 - x_0 | \\
| x_{ n + p } - x_n | &amp; \leq \sum_{ k = 1 }^p | x_{ n + k } - x_{ n
+ k - 1 } | \\
&amp; \leq \sum_{ k = 0 }^{ p - 1 } q^{ n + k } | x_1 - x_0 | = | x_1 -
x_0 | q^n \frac{ 1 - q^{ p } }{ 1 - q }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(\{ x_n
\}\)</span>是柯西列,其极限存在,取<span class="math inline">\(c = \lim
x_n\)</span>,容易发现:</p>
<p><span class="math display">\[
| f ( x_n ) - f ( c ) | \leq q | x_n - c |
\]</span></p>
<p>两边取极限得知<span class="math inline">\(f ( c ) =
c\)</span>,于是<span class="math inline">\(c\)</span>是一个不动点.如果还存在一个不动点<span class="math inline">\(c &#39; \ne c\)</span>,那么:</p>
<p><span class="math display">\[
| c - c &#39; | = | f ( c ) - f ( c &#39; ) | \leq q | c - c &#39; |
\]</span></p>
<p>不符.</p>
<h5><span id="李-约克定理">李-约克定理</span></h5>
<p>对于一个<span class="math inline">\(f ( x ) \in C [ a , b
]\)</span>,如果<span class="math inline">\(P_3 \ne
\emptyset\)</span>,那么<span class="math inline">\(\forall n \in
\mathbb{ N }_+\)</span>,<span class="math inline">\(P_n \ne
\emptyset\)</span>.</p>
<h6><span id="引理一">引理一</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(G : J \rightarrow \mathbb{ R
}\)</span>是连续函数,<span class="math inline">\(\forall I = [ a , b ]
\subseteq G ( J )\)</span>,<span class="math inline">\(\exists Q = [ a
&#39; , b &#39; ] \subseteq J , G ( Q ) = I\)</span>.</p>
<p>根据介值定理,当然存在一对点<span class="math inline">\(p ,
q\)</span>,<span class="math inline">\(I = [ G ( p ) , G ( q )
]\)</span>.不妨设<span class="math inline">\(p &lt; q\)</span>,那么<span class="math inline">\(a &#39; = \sup \{ x \in [ p , q ] | G ( x ) = G (
p ) \} , b &#39; = \inf \{ x \in [ a &#39; , q ] | G ( x ) = G ( q )
\}\)</span>即可.</p>
<p>换言之,我们可以拿到一个区间使得它的像正是我们想要的区间.感性理解的话我们可以对一个区间求原像并且原像当然也是一个区间.那我们自然可以对区间进行迭代.这样迭代的区间有什么性质么?</p>
<h6><span id="引理二">引理二</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(F : J \rightarrow
J\)</span>是连续函数,取一列闭区间<span class="math inline">\(I_n\)</span>,满足<span class="math inline">\(\forall n \geq 0 , I_n \subseteq J , I_{ n + 1 }
\subseteq F ( I_n )\)</span>.不妨把这种区间列记作<span class="math inline">\(I_0 \Rightarrow I_1 \Rightarrow I_2 \Rightarrow
\cdots\)</span>.</p>
<p>那么我们可以找到一列闭区间<span class="math inline">\(I_0 = Q_0
\supseteq Q_1 \supseteq Q_2 \cdots\)</span>,<span class="math inline">\(\forall n \geq 0\)</span>,有<span class="math inline">\(F^{ [ n ] } ( Q_n ) = I_n\)</span>.</p>
<p>考虑数学归纳,假设对于<span class="math inline">\(\leq
n\)</span>的都已经满足,现在有<span class="math inline">\(I_{ n + 1 }
\subseteq F ( I_n ) = F^{ [ n + 1 ] } ( Q_n )\)</span>,令<span class="math inline">\(G = F^{ [ n + 1 ]
}\)</span>然后用引理一就可以.</p>
<p>这个引理的意义在于,<span class="math inline">\(\{ I_n
\}\)</span>当然不必是一条链,但是只要其满足一定的性质,我们就可以在它们中找到一条链,也就是每迭代一次都可能会将射出去的那个集合变小,或者是射出需要的集合所需要的初始集合变小.</p>
<p>这个当然也是给我们求原像的机会.我们尝试感性理解一下这个在干什么:</p>
<p>如果一个函数操作完一个区间后会把这个区间变小,那显然我如果想求<span class="math inline">\(F^{ [ - n ] } ( I )\)</span>,<span class="math inline">\(n\)</span>越大得到的原像就越大对吧.反之,如果会把这个区间变大,那<span class="math inline">\(n\)</span>越大得到的原像就越小对吧.</p>
<p>这个讨论显然是不好的,我们得想办法刻画一下这个东西.那当然要在这里蕴含一个<span class="math inline">\(F\)</span>本身.</p>
<p>于是用上面的定义会发现,即使<span class="math inline">\(F\)</span>会把这个区间扩张到奇怪的大小,只要我们能把它缩回去,那不断取原像的过程照样是可行的.</p>
<h6><span id="引理三">引理三</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(G : J \rightarrow \mathbb{ R
}\)</span>是连续函数,<span class="math inline">\(I \subseteq
J\)</span>是闭区间,并且<span class="math inline">\(I \subseteq G ( I
)\)</span>或者<span class="math inline">\(G ( I ) \subseteq
I\)</span>,都可以推出<span class="math inline">\(\exists p \in I , G ( p
) = p\)</span>.</p>
<p>只需构造函数<span class="math inline">\(H ( x ) = x - G ( x
)\)</span>然后用介值定理即可.</p>
<h6><span id="李-约克定理">李-约克定理</span></h6>
<p>设<span class="math inline">\(q_3 \in P_3\)</span>,则<span class="math inline">\(F ( q_3 ) , F ( F ( q_3 ) ) \in
P_3\)</span>,容易看出,这三个点中必然有一个点<span class="math inline">\(a \in P_3\)</span>,使得<span class="math inline">\(a , b = F ( a ) , c = F ( F ( a )
)\)</span>这三个数单调递增或单调递减.不妨设<span class="math inline">\(a
&lt; b &lt; c\)</span>.</p>
<p>下面证明对于任意<span class="math inline">\(k &gt;
0\)</span>,存在<span class="math inline">\(k\)</span>周期点.</p>
<p>我们接下来取<span class="math inline">\(K = [ a , b ] , L = [ b , c
]\)</span>,立刻由介值定理发现<span class="math inline">\(F ( K )
\supseteq L\)</span>以及<span class="math inline">\(F ( L ) \supseteq [
a , c ] = K \cup L\)</span>.</p>
<p>接下来我们开始构造一列满足引理二的闭区间,我们考虑:</p>
<ol type="1">
<li><p>当<span class="math inline">\(k =
1\)</span>的时候,我们直接取<span class="math inline">\(\forall n , I_n =
L\)</span>.</p></li>
<li><p>当<span class="math inline">\(k &gt; 1\)</span>的时候,取<span class="math inline">\(I_n = \begin{cases}K &amp; n \equiv 0 \pmod{ k }
\\ L &amp; \text{ otherwise }\end{cases}\)</span></p></li>
</ol>
<p>现在我们可以用引理二立刻拿到区间列<span class="math inline">\(\{ Q_n
\}\)</span>,我们发现<span class="math inline">\(Q_k \subseteq Q_0 = I_0
= I_k = F^{ [ k ] } ( Q_k )\)</span>,根据引理三立刻得到<span class="math inline">\(\exists q \in Q_k , F^{ [ k ] } ( q ) =
q\)</span>.</p>
<p>那么这个<span class="math inline">\(q\)</span>有没有可能存在更小的周期<span class="math inline">\(d\)</span>呢?如果有的话,不妨取其中最小的那个<span class="math inline">\(d\)</span>,辗转相除一下自然有<span class="math inline">\(d | k\)</span>,那么当然要有<span class="math inline">\(F^{ [ k ] } ( q ) = F^{ [ k - d ] } ( q ) =
q\)</span>.</p>
<p>此时我们发现<span class="math inline">\(q \in Q_k \subseteq Q_{ k - d
}\)</span>,<span class="math inline">\(q \in I_{ k } \cap I_{ k - d } =
K \cap L = \{ b \}\)</span>,于是<span class="math inline">\(F^{ [ k ] }
( q ) = b , F^{ [ k + 1 ] } ( q ) = c , F^{ [ k + 2 ] } ( q ) =
a\)</span>.</p>
<p>这说明此时<span class="math inline">\(d = 3\)</span>.</p>
<p>而当<span class="math inline">\(k \geq 4\)</span>的时候,<span class="math inline">\(F^{ [ k + 2 ] } ( q ) = a \notin
L\)</span>,这当然与<span class="math inline">\(I_{ k + 2 } =
L\)</span>矛盾.</p>
<p>仔细观察一下上面的过程,我们到底依赖于什么东西得到了这个?</p>
<p>首先找到<span class="math inline">\(q\)</span>使得<span class="math inline">\(F^{ [ k ] } ( q ) =
q\)</span>这个其实反而并不是最主要的,因为只要<span class="math inline">\(F ( q ) = q\)</span>那么显然<span class="math inline">\(F^{ [ k ] } ( q ) =
q\)</span>,真正离谱的是竟然要让这个点在之前从未跳到过<span class="math inline">\(q\)</span>.这也是这个证明的最精髓的部分,那就是证明任何一个<span class="math inline">\(d &lt; q\)</span>都不是周期.</p>
<p>那我们考虑取一个区间(也就是<span class="math inline">\(K\)</span>),在<span class="math inline">\(K\)</span>中取一个合法的<span class="math inline">\(q\)</span>,然后我们只要找到一个闭区间(也就是<span class="math inline">\(Q_k \subseteq K\)</span>),使得它当且仅当复合<span class="math inline">\(k\)</span>次的时候才会打到<span class="math inline">\(K\)</span>上,在其它时候都得打在<span class="math inline">\(K\)</span>的外面(在这里是<span class="math inline">\(L\)</span>)上,那自然是可行的了对吧.而数字<span class="math inline">\(3\)</span>恰好完美地给出了这个构造.</p>
<p>如果我们再总结一下上面的过程,我们需要找到两个区间<span class="math inline">\(K , L\)</span>,找到一个<span class="math inline">\(Q_k \subseteq K\)</span>,使得<span class="math inline">\(F^k ( Q_k )\)</span>可以打到<span class="math inline">\(K\)</span>上但是对于<span class="math inline">\(d
&lt; k\)</span>,<span class="math inline">\(F^d ( Q_k
)\)</span>打到<span class="math inline">\(L\)</span>上.于是根据引理三其存在<span class="math inline">\(k\)</span>周期点,但是几乎不可能存在<span class="math inline">\(d\)</span>周期点(这里就需要简单判断一下<span class="math inline">\(L \cap K\)</span>的部分了)</p>
<p>这样的<span class="math inline">\(K\)</span>和<span class="math inline">\(L\)</span>怎么构造呢?如果我们构造<span class="math inline">\(F ( K )\)</span>打到<span class="math inline">\(L\)</span>上,<span class="math inline">\(F ( L
)\)</span>打到<span class="math inline">\(K\)</span>上显然是吧不合理的,那就可以一个打到另一个,另一个打到全集上再用引理一缩一下,这个看上去合理多了.这当然就是<span class="math inline">\(F ( K ) \supseteq L\)</span>以及<span class="math inline">\(F ( L ) \supseteq [ a , c ] = K \cup
L\)</span>.</p>
<h5><span id="sharkovskii定理">Sharkovskii定理</span></h5>
<p>定义如下的一种序关系<span class="math inline">\(\prec\)</span>(称为Sharkovskii序):</p>
<p><span class="math display">\[
\begin{gathered}
3 \prec 5 \prec 7 \prec \cdots \\
\prec 2 \times 3 \prec 2 \times 5 \prec \cdots \\
\cdots \\
\prec 2^k \times 3 \prec 2^k \times 5 \prec \cdots \\
\cdots \\
\cdots \prec 2^n \prec 2^{ n - 1 } \prec \cdots \prec 4 \prec 2 \prec 1
\end{gathered}
\]</span></p>
<p>对于<span class="math inline">\(f ( x ) \in C [ l , r ] , f : [ l , r
] \rightarrow [ l , r ]\)</span>.那么如果<span class="math inline">\(m
\prec n , P_m \ne \emptyset \Rightarrow P_n \ne \emptyset\)</span>.</p>
<p>(首先发现当然存在不动点)</p>
<p>这咋办呢?我们刚才用了<span class="math inline">\(3\)</span>的最重要的性质就是<span class="math inline">\(3\)</span>个点可以排成有序的一列,如果有类似的引理,那我们就可以尝试推广上面的结论.</p>
<h6><span id="引理">引理</span></h6>
<p>设<span class="math inline">\(f : I \rightarrow
I\)</span>是连续函数,<span class="math inline">\(f\)</span>有<span class="math inline">\(2 n +
1\)</span>周期点但无更小非一奇数阶周期点,我们取出其一个周期轨<span class="math inline">\(x_0 \rightarrow x_1 \rightarrow \cdots x_{ 2 n
}\)</span>,必有以下两者成立其一:</p>
<ol type="1">
<li><p><span class="math inline">\(x_{ 2 n } &lt; x_{ 2 n - 2 } &lt;
\cdots &lt; x_2 &lt; x_0 &lt; x_1 &lt; \cdots &lt; x_{ 2 n - 3 } &lt;
x_{ 2 n - 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(x_{ 2 n } &gt; x_{ 2 n - 2 } &gt;
\cdots &gt; x_2 &gt; x_0 &gt; x_1 &gt; \cdots &gt; x_{ 2 n - 3 } &gt;
x_{ 2 n - 1 }\)</span>.</p></li>
</ol>
<p>这个引理怎么证明呢?考虑把周期轨排一下序然后归纳,我们不妨假设排好序后的结果是<span class="math inline">\(y_0 &lt; y_1 &lt; \cdots &lt; y_{ 2 n
}\)</span>.</p>
<p>如果引理成立,(第一种情况下)取<span class="math inline">\(I_0 = [ x_0
, x_1 ]\)</span>,则<span class="math inline">\(I_0 \Rightarrow
I_0\)</span>.容易发现其实只有<span class="math inline">\(I_0\)</span>有这个性质,那我们不妨来看看满足<span class="math inline">\([ y_k , y_{ k + 1 } ] \Rightarrow [ y_k , y_{ k +
1 } ]\)</span>的情况是什么样子的,尝试去满足<span class="math inline">\([
f ( y_{ k + 1 } ) , f ( y_{ k } ) ] \supseteq [ y_k , y_{ k + 1 }
]\)</span>.这个时候注意到我们可以把所有点分成两类:满足<span class="math inline">\(f ( y_i ) \geq y_{ i + 1 }\)</span>(称为<span class="math inline">\(\alpha\)</span>类点,容易见到这里也就等价于<span class="math inline">\(f ( y_i ) &gt; y_i\)</span>)和<span class="math inline">\(f ( y_i ) \leq y_{ i - 1 }\)</span>(称为<span class="math inline">\(\beta\)</span>类点)的.那我们就是要找到一个<span class="math inline">\(k\)</span>使得<span class="math inline">\(y_k\)</span>是<span class="math inline">\(\alpha\)</span>类点并且<span class="math inline">\(y_{ k + 1 }\)</span>是<span class="math inline">\(\beta\)</span>类点.</p>
<p>由于<span class="math inline">\(f ( y_0 ) \geq y_1 , f ( y_{ 2 n } )
\leq y_{ 2 n - 1
}\)</span>,这两类点显然都有,那就一定存在交界的地方,这样我们就可以拿出这个分界的地方记作<span class="math inline">\(I_0 = [ y_k , y_{ k + 1 } ]\)</span>,其中<span class="math inline">\(y_k\)</span>是<span class="math inline">\(\alpha\)</span>类点,<span class="math inline">\(y_{ k + 1 }\)</span>是<span class="math inline">\(\beta\)</span>类点.</p>
<p>我们不妨定义一个集合<span class="math inline">\(S\)</span>的张成区间<span class="math inline">\(A\)</span>为<span class="math inline">\(A = [ \inf
S , \sup S ]\)</span>,那我们现在取<span class="math inline">\(S_0 = \{
y_k , y_{ k + 1 } \}\)</span>,设周期轨为<span class="math inline">\(O_f
= \{ x_0 , \cdots x_{ 2 n } \}\)</span>,我们递归定义<span class="math inline">\(S_{ k + 1 } = f ( A_k ) \cap
O_f\)</span>,容易根据上面对<span class="math inline">\(S_0\)</span>的构造发现<span class="math inline">\(S_0 \subsetneq S_1\)</span>,并且<span class="math inline">\(S_k\)</span>中因为取了一段极大的区间(但并没有包含所有周期点),所以一定能跳出这个区间(不然这个区间内部就可以自己射自己),所以<span class="math inline">\(S_k \subsetneq S_{ k + 1 }\)</span>.</p>
<p>那由此我们当然可以得到一条链:</p>
<p><span class="math display">\[
S_0 \subsetneq S_1 \subsetneq \cdots \subsetneq S_t = O_f
\]</span></p>
<p>按理来说应该有<span class="math inline">\(t = 2 n -
1\)</span>(这就会给出每次<span class="math inline">\(S\)</span>扩张只会多一个数),让我们先来证明这个结论:</p>
<p>反证,假设<span class="math inline">\(t &lt; 2 n -
1\)</span>,尝试找到一个更小的奇数周期来推出矛盾,不妨尝试找到一个<span class="math inline">\(2 n - 1\)</span>的周期(当然,如果<span class="math inline">\(2 n + 1 =
3\)</span>的话,这个结论我们在李约克定理已经证明了,所以下面假设<span class="math inline">\(2 n + 1 \geq 5\)</span>).</p>
<p>我不说你也知道我要干啥,我们考虑在末尾补<span class="math inline">\(2
n - t - 1\)</span>个<span class="math inline">\(A_t\)</span>,并把最后一个缩成<span class="math inline">\(A_0\)</span>,当然有:</p>
<p><span class="math display">\[
A_0 \Rightarrow A_1 \Rightarrow A_2 \Rightarrow \cdots \Rightarrow A_t
\Rightarrow A_t \supseteq A_0
\]</span></p>
<p>但这样并不太行,因为这些区间的交不是空的,我们起码得把其中的一个区间给挪出去,不妨考虑改掉最后一个<span class="math inline">\(A_t\)</span>,试图取一个<span class="math inline">\(l \ne k\)</span>使得<span class="math inline">\([
y_l , y_{ l + 1 } ] \Rightarrow A_0 = [ y_k , y_{ k + 1 }
]\)</span>.如果我们结合一下下面的主定理的证明部分,其实我们可以发现这里的<span class="math inline">\([ y_l , y_{ l + 1 } ]\)</span>也就是<span class="math inline">\(I_{ 2 n - 1 }\)</span>.</p>
<p>我们上面已经保证了<span class="math inline">\(f ( y_{ k + 1 } ) \leq
y_k\)</span>,如果有<span class="math inline">\(f ( y_{ k + 2 } ) \geq
y_{ k + 1 }\)</span>,那当然可以取<span class="math inline">\(l = k +
1\)</span>.也就是如果我们的这一列点类别中出现了<span class="math inline">\(\alpha \beta
\alpha\)</span>这样的结构就完事了.如果找不到,那说明<span class="math inline">\(f ( y_{ k + 2 } ) \leq y_{ k + 1
}\)</span>.我们继续往后找,如果可以遇到第一个<span class="math inline">\(f ( y_i ) \geq y_{ k + 1 }\)</span>,那<span class="math inline">\([ y_{ i - 1 } , y_i
]\)</span>自然是满足条件的.如果一直都找不到,说明始终有<span class="math inline">\(f ( y_i ) &lt; y_{ k + 1 } \leq y_{ i - 1 } , i
\in [ k + 2 , 2 n ]\)</span>,那说明后面全是<span class="math inline">\(\beta\)</span>点.</p>
<p>同理如果出现了<span class="math inline">\(\beta \alpha
\beta\)</span>这样的结构也找到了.不然类似同理,如果一直找不到就说明前面全是<span class="math inline">\(\alpha\)</span>点,前面的点始终满足<span class="math inline">\(f ( y_i ) \geq y_{ k + 1 } , i \in [ 0 , k
]\)</span>.</p>
<p>这已经推导出了矛盾,因为我们发现前面的点射到后面,后面的点射到前面,问题在于前面有<span class="math inline">\(k + 1\)</span>个点,后面有<span class="math inline">\(2 n - k\)</span>个点,于是<span class="math inline">\(k + 1 = 2 n - k \Rightarrow 2 k + 1 = 2
n\)</span>,这导出了矛盾.</p>
<p>所以确实可以找到这样的<span class="math inline">\(l \ne k , [ y_l ,
y_{ l + 1 } ] \Rightarrow [ y_k , y_{ k + 1 }
]\)</span>,那我们用上面的区间列自然可以推导出存在一个<span class="math inline">\(2 n -
1\)</span>周期点(或者其因子周期点,不过那也导出矛盾了).</p>
<p>于是<span class="math inline">\(t = 2 n -
1\)</span>,这表示我们拿到的这条链<span class="math inline">\(S_0
\subsetneq S_1 \subsetneq \cdots \subsetneq S_t =
O_f\)</span>每次只增加一个元素.如果<span class="math inline">\(S_0\)</span>到<span class="math inline">\(S_1\)</span>是只增加了一个元素,当然说明<span class="math inline">\(f ( y_k ) = y_{ k + 1 }\)</span>或者<span class="math inline">\(f ( y_{ k + 1 } ) =
y_k\)</span>.两者的证明是一样的,不妨设<span class="math inline">\(f (
y_k ) = y_{ k + 1 }\)</span>.</p>
<p>此时我们取<span class="math inline">\(x_0 = y_k , x_1 = y_{ k + 1
}\)</span>,此时其实也可以发现<span class="math inline">\(x_2 &lt; x_0
&lt; x_1\)</span>.并且根据上面的说法,我们知道<span class="math inline">\(A_{ k } \subsetneq A_{ k + 1
}\)</span>,那这个扩张一定是每次在边界上往外跑一个,也就是每次取一个新的迭代出来的结果扔到左边或者扔到右边.</p>
<p>网络上有关于这一点的证明往往是反证,假设不按规则走的话然后去尝试构造三周期点推到矛盾,但我们这里给出另一个证明方法:</p>
<p>考虑由于每次只增大一个数,那么如果我们能证明这一列<span class="math inline">\(y\)</span>形如<span class="math inline">\(\alpha
\cdots \alpha \beta \cdots \beta\)</span>的形式就做完了,这等价于<span class="math inline">\(I_0\)</span>的唯一性.</p>
<p>假设还有另一个区间也满足要求,对于这个新的区间,我们设其是<span class="math inline">\([ y_l , y_{ l + 1 }
]\)</span>,我们再拿一个周期点<span class="math inline">\(y_{ l + 2
}\)</span>出来,假设这三个数按照顺序是<span class="math inline">\(a &lt;
b &lt; c\)</span>,那么根据上面的结论一定有<span class="math inline">\(b
\rightarrow c \rightarrow a\)</span>或者<span class="math inline">\(b
\rightarrow a \rightarrow c\)</span>成立,这就说明<span class="math inline">\(b\)</span>被夹在了中间.而我们从一个<span class="math inline">\(I_0\)</span>扩张当然是逐步的,会将<span class="math inline">\(x_3 , x_4
\cdots\)</span>逐个加入,这必然意味着在<span class="math inline">\(b\)</span>加入之前,<span class="math inline">\(a ,
c\)</span>中已经有一个加进去了,但这是不可能的,只有<span class="math inline">\(b\)</span>加入后才能把<span class="math inline">\(a , c\)</span>给加进去.</p>
<h6><span id="sharkovskii定理">sharkovskii定理</span></h6>
<p>有了引理就可以开始类比了,不妨假设<span class="math inline">\(x_{ 2 n
} &lt; x_{ 2 n - 2 } &lt; \cdots &lt; x_2 &lt; x_0 &lt; x_1 &lt; \cdots
&lt; x_{ 2 n - 3 } &lt; x_{ 2 n - 1 }\)</span>.</p>
<p>现在我们要取区间列了,显然有一些奇偶对跳的现象,事实上我们取<span class="math inline">\(I_0 = [ x_0 , x_1 ] , I_{ 2 k - 1 } = [ x_{ 2 k }
, x_{ 2 k - 2 } ] , I_{ 2 k } = [ x_{ 2 k - 1 } , x_{ 2 k + 1 }
]\)</span>显然就是满足条件的.而且这些区间除了端点外完全不相交(而且任意三个区间的交都是空集).这一列一共有<span class="math inline">\(2 n\)</span>个区间.我们事实上可以取<span class="math inline">\(J = [ x_{ 0 } , x_{ 2 n - 1 } ] = \bigcup I_{ 2 k
}\)</span>放到整个区间的最后.</p>
<p>接下来我们用这些东西去对于多种情况来对跳.</p>
<p><strong>Case1</strong></p>
<p>(假设<span class="math inline">\(2 n +
1\)</span>是最小的非空的非一奇数周期)首先证明<span class="math inline">\(P_{ 2 n + 1 } \ne \emptyset \Rightarrow \forall 0
&lt; k , P_{ k + 2 n } \ne \emptyset\)</span>.</p>
<p>在前面补<span class="math inline">\(k\)</span>个<span class="math inline">\(I_0\)</span>,在最后也补一个<span class="math inline">\(I_0\)</span>,构造区间列:</p>
<p><span class="math display">\[
I_0 \Rightarrow I_0 \Rightarrow \cdots \Rightarrow I_0 \Rightarrow I_1
\Rightarrow I_2 \Rightarrow \cdots \Rightarrow I_{ 2 n - 1 } \Rightarrow
I_0
\]</span></p>
<p>也就是在前面补<span class="math inline">\(I_0\)</span>直到整个区间列的数量为<span class="math inline">\(k + 2 n + 1\)</span>,此时当然存在<span class="math inline">\(x_0 \in Q_{ k + 2 n }\)</span>使得<span class="math inline">\(f^{ [ k + 2 n ] } ( x_0 ) =
x_0\)</span>,只需证明<span class="math inline">\(\nexists d | ( k + 2 n
)\)</span>,<span class="math inline">\(f^{ [ d ] } ( x_0 ) =
x_0\)</span>即可.这当然好证,因为<span class="math inline">\(d \leq
\frac{ k + 2 n }{ 2 } \leq \max ( k , 2 n
)\)</span>,因为你只需要把它卡在那一堆<span class="math inline">\(I_0\)</span>和<span class="math inline">\(I_k\)</span>的分界线上就行.</p>
<p><strong>Case2</strong></p>
<p>(假设<span class="math inline">\(2 n +
1\)</span>是最小的非空的非一奇数周期)接下来我们来证明<span class="math inline">\(P_{ 2 n + 1 } \ne \emptyset \Rightarrow \forall 0
&lt; m , P_{ 2 m } \ne \emptyset\)</span>.</p>
<p>当<span class="math inline">\(2 m &gt; 2 n +
1\)</span>的时候我们已经证完了,接下来考虑<span class="math inline">\(2 m
&lt; 2 n + 1\)</span>的情况.</p>
<p>由于<span class="math inline">\(\forall k , I_{ 2 n - 1 } \Rightarrow
I_{ 2 k }\)</span>,我们考虑取出<span class="math inline">\(2 m +
1\)</span>个区间列,恰好有:</p>
<p><span class="math display">\[
I_{ 2 n - 2 m } \Rightarrow I_{ 2 n - 2 m + 1 } \Rightarrow \cdots
\Rightarrow I_{ 2 n - 1 } \Rightarrow I_{ 2 n - 2 m }
\]</span></p>
<p>接下来就是简单说明的过程了.</p>
<p><strong>Case3</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 4 } \ne \emptyset
\Rightarrow P_2 \ne \emptyset\)</span>.</p>
<p>这个证明就比较无聊了,我们进行暴力讨论,不妨假设<span class="math inline">\(a &lt; b &lt; c &lt; d\)</span>,那么:</p>
<ol type="1">
<li><span class="math inline">\(a \rightarrow b \rightarrow c
\rightarrow d \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ b , c ]
\Rightarrow [ c , d ] \Rightarrow [ a , d ] \supseteq [ a , b
]\)</span>,于是可证明有三周期点,当然有二周期点.</p>
<ol start="2" type="1">
<li><span class="math inline">\(a \rightarrow b \rightarrow d
\rightarrow c \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ b , d ]
\Rightarrow [ c , d ] \Rightarrow [ a , c ] \supseteq [ a , b
]\)</span>,于是可证明有三周期点,当然有二周期点.</p>
<ol start="3" type="1">
<li><span class="math inline">\(a \rightarrow c \rightarrow b
\rightarrow d \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ c , d ]
\Rightarrow [ a , b ]\)</span>,当然有二周期点.</p>
<ol start="4" type="1">
<li><span class="math inline">\(a \rightarrow c \rightarrow d
\rightarrow b \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , c ] \Rightarrow [ c , d ]
\Rightarrow [ b , d ] \Rightarrow [ a , b ] \Rightarrow [ a , c ]
\supseteq [ b , c ] \Rightarrow [ a , d ] \supseteq [ a , c
]\)</span>.于是有五周期点,于是有二周期点.</p>
<ol start="5" type="1">
<li><span class="math inline">\(a \rightarrow d \rightarrow b
\rightarrow c \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ c , d ]
\Rightarrow [ a , b ]\)</span>,当然有二周期点.</p>
<ol start="6" type="1">
<li><span class="math inline">\(a \rightarrow d \rightarrow c
\rightarrow b \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ b , c ] \Rightarrow [ a , b ]
\Rightarrow [ a , d ] \supseteq [ b , c ]\)</span>,于是有二周期点.</p>
<p><strong>Case4</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n + 1 } } \ne
\emptyset \Rightarrow P_{ 2^n } \ne \emptyset\)</span>.</p>
<p>考虑上面命题等价于<span class="math inline">\(f^{ [ 2^{ n - 1 } ]
}\)</span>有四周期点,则其有二周期点.</p>
<p><strong>Case5</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n } p } \ne
\emptyset \Rightarrow P_{ 2^n q } \ne \emptyset\)</span>,其中<span class="math inline">\(p , q \in \text{ odd } , p &lt; q\)</span>.</p>
<p>考虑<span class="math inline">\(f^{ [ 2^n ] }\)</span>有<span class="math inline">\(p\)</span>周期点,当然也就有<span class="math inline">\(q\)</span>周期点.</p>
<p><strong>Case6</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n } p } \ne
\emptyset \Rightarrow P_{ 2^m q } \ne \emptyset\)</span>,其中<span class="math inline">\(p , q \in \text{ odd } , m &gt; n\)</span>.</p>
<p>考虑<span class="math inline">\(f^{ [ 2^n ] }\)</span>有<span class="math inline">\(p\)</span>周期点,当然也就有<span class="math inline">\(q 2^{ m - n }\)</span>周期点.</p>
<p><strong>Case7</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n } p } \ne
\emptyset \Rightarrow P_{ 2^m } \ne \emptyset\)</span>,其中<span class="math inline">\(p \in \text{ odd }\)</span>.</p>
<p>选取<span class="math inline">\(N = \max ( n + 1 , m + 1
)\)</span>,则考虑<span class="math inline">\(f^{ [ 2^n ]
}\)</span>有<span class="math inline">\(p\)</span>周期点,则其有<span class="math inline">\(2^{ N - n }\)</span>周期点,<span class="math inline">\(P_{ 2^N } \ne \emptyset\)</span>.于是<span class="math inline">\(P_{ 2^m } \ne \emptyset\)</span>.</p>
<h3><span id="导数">导数</span></h3>
<p>设函数<span class="math inline">\(f ( x )\)</span>在一个区间<span class="math inline">\(( a , b )\)</span>上有定义,对于给定的<span class="math inline">\(x_0 \in ( a , b )\)</span>,考虑增量<span class="math inline">\(\Delta x \ne 0 \land x_0 + \Delta x \in ( a , b
)\)</span>,则<span class="math inline">\(\Delta y = f ( x_0 + \Delta x )
- f ( x_0 )\)</span>称为关于<span class="math inline">\(\Delta
x\)</span>的<strong>增量</strong>.若极限<span class="math inline">\(\lim_{ \Delta x \rightarrow 0 } \frac{ \Delta y }{
\Delta x } \\\)</span>存在则称这个函数在<span class="math inline">\(x_0\)</span>处<strong>可导</strong>,并称这个值为这个函数在<span class="math inline">\(x_0\)</span>处的<strong>导数</strong>或者<strong>微商</strong>,记作<span class="math inline">\(f &#39; ( x_0 )\)</span>或<span class="math inline">\(\frac{ \text{ d } f }{ \text{ d } x } |_{ x = x_0
}\)</span>.同理可以定义出<strong>左导数</strong>和<strong>右导数</strong>.如果某个函数的导数构成一个函数,我们称这个函数为其对应的<strong>导函数</strong>.</p>
<p>显然右可导能推出右连续,左可导能推出左连续.换言之,可导一定连续.</p>
<p>但是连续不一定可导,相当漂亮的一个反例是<span class="math inline">\(f
( x ) = \begin{cases}0 &amp; x = 0 \\ x \sin \frac{ 1 }{ x } &amp;
\text{ otherwise }\end{cases}\)</span>,其在零点没有左右导数.</p>
<p>如果<span class="math inline">\(f\)</span>的<span class="math inline">\(n - 1\)</span>次导数存在,记作<span class="math inline">\(f^{ ( n - 1 ) } ( x
)\)</span>,如果该函数可导则其导数称作<span class="math inline">\(f^{ ( n
) } ( x )\)</span>.</p>
<p>如果<span class="math inline">\(f^{ ( n ) } ( x )\)</span>在<span class="math inline">\(I\)</span>上连续,则称<span class="math inline">\(f
\in C^{ n } ( I )\)</span>.如果其任意阶可导,则称<span class="math inline">\(f \in C^{ \infty } ( I )\)</span>.</p>
<p>特别地,如果称一个函数是<span class="math inline">\(\alpha\)</span>次可导,即<span class="math inline">\(| f ( x ) - f ( y ) | \leq | x - y
|^\alpha\)</span>.其实就是Holder连续.</p>
<h4><span id="导数基本运算">导数基本运算</span></h4>
<p>导数也可以类似求出四则运算以及复合的法则:</p>
<ol type="1">
<li><p><span class="math inline">\([ cf ( x ) ] &#39; = cf &#39; ( x
)\)</span>.</p></li>
<li><p><span class="math inline">\([ f ( x ) \pm g ( x ) ] &#39; = f
&#39; ( x ) \pm g &#39; ( x )\)</span>.</p></li>
<li><p><span class="math inline">\([ f ( x ) g ( x ) ] &#39; = f &#39; (
x ) g ( x ) + g &#39; ( x ) f ( x )\)</span>.</p></li>
<li><p>(莱布尼茨公式):<span class="math inline">\([ f ( x ) g ( x ) ]^{
( n ) } = \sum_{ k = 0 }^n \binom{ n }{ k } f^{ ( k ) } ( x ) g^{ ( n -
k ) } ( x )\)</span>.</p></li>
<li><p><span class="math inline">\([ \frac{ f ( x ) }{ g ( x ) } ] &#39;
= \frac{ f &#39; ( x ) g ( x ) - g &#39; ( x ) f ( x ) }{ g^2 ( x ) } ,
g ( x ) \ne 0\)</span>.</p></li>
<li><p><span class="math inline">\([ g ( f ( x ) ) ] &#39; = g &#39; ( f
( x ) ) f &#39; ( x )\)</span>.</p></li>
</ol>
<p>(1)(2)比较平凡.</p>
<p>(3)(4)的证明的话,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ f ( x + \Delta x ) g ( x + \Delta x ) - f ( x ) g ( x ) }{
\Delta x } \\
= &amp; \frac{ f ( x + \Delta x ) - f ( x ) }{ \Delta x } g ( x + \Delta
x ) + f ( x ) \frac{ g ( x + \Delta x ) - g ( x ) }{ \Delta x }
\end{aligned}
\]</span></p>
<p>取一下极限就行.</p>
<p>(5)的话,其实求出<span class="math inline">\(( \frac{ 1 }{ g ( x ) } )
&#39;\)</span>就行了,我们来看:</p>
<p><span class="math display">\[
\begin{aligned}
( \frac{ 1 }{ g ( x ) } ) &#39; &amp; = \lim_{ \Delta x \rightarrow 0 }
\frac{ \frac{ 1 }{ g ( x + \Delta x ) } - \frac{ 1 }{ g ( x ) } }{
\Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \frac{ g ( x ) - g ( x +
\Delta x ) }{ g ( x + \Delta x ) g ( x ) } }{ \Delta x } \\
&amp; = \frac{ - g &#39; ( x ) }{ g^2 ( x ) }
\end{aligned}
\]</span></p>
<p>对于(6),不妨设<span class="math inline">\(f ( x_0 ) =
y_0\)</span>.</p>
<p>当<span class="math inline">\(\Delta y \ne
0\)</span>的时候,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\lim_{ \Delta y \rightarrow 0 } \frac{ g ( y_0 + \Delta y ) - g ( y_0 )
}{ \Delta y } &amp; = g &#39; ( y_0 ) \\
\lim_{ \Delta y \rightarrow 0 } [ \frac{ g ( y_0 + \Delta y ) - g ( y_0
) }{ \Delta y } - g &#39; ( y_0 ) ] &amp; = 0
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(\eta ( \Delta y ) = \frac{ g ( y_0 +
\Delta y ) - g ( y_0 ) }{ \Delta y } - g &#39; ( y_0 ) = \frac{ \Delta z
}{ \Delta y } - g &#39; ( y_0 ) , \Delta y \ne 0\)</span>,那么<span class="math inline">\(\lim_{ \Delta y \rightarrow 0 } \eta ( \Delta y )
= 0\)</span>.</p>
<p>此时有:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ \Delta z }{ \Delta x } &amp; = \frac{ \Delta z }{ \Delta y }
\frac{ \Delta y }{ \Delta x } = \eta ( \Delta y ) \frac{ \Delta y }{
\Delta x } + g &#39; ( y_0 ) \frac{ \Delta y }{ \Delta x } \\

\end{aligned}\]</span>
<p>$$</p>
<p>带上极限,前者为<span class="math inline">\(0\)</span>.</p>
<p>另一种写法是,类似上面的讨论,我们这里有一些无穷小量,而且(除了<span class="math inline">\(\frac{ \Delta z }{ \Delta x
}\)</span>以外)也不会出现无穷小量之间的除法,用一下当然有,<span class="math inline">\(g ( y + \Delta y ) - g ( y ) = ( g &#39; ( y ) + o
( 1 ) ) \Delta y , f ( x + \Delta x ) - f ( x ) = ( f &#39; ( x ) + o (
1 ) ) \Delta x\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta z &amp; = ( g &#39; ( y ) + o ( 1 ) ) \Delta y \\
&amp; = ( g &#39; ( y ) + o ( 1 ) ) ( f &#39; ( x ) + o ( 1 ) ) \Delta x
\\

\end{aligned}\]</span>
<p>$$</p>
<p>两边除一下<span class="math inline">\(\Delta
x\)</span>两边求极限就行.</p>
<p>不难发现上面的过程等价于啥呢?等价于:</p>
<p><span class="math display">\[
\frac{ \text{ d } z }{ \text{ d } x } = \frac{ \text{ d } z }{ \text{ d
} y } \frac{ \text{ d } y }{ \text{ d } x }
\]</span></p>
<h4><span id="反函数的导数">反函数的导数</span></h4>
<p>我们首先声称:如果<span class="math inline">\(x = \varphi ( y ) ,
\varphi &#39; \ne 0 \Rightarrow\)</span><span class="math inline">\(有
反 函 数\)</span>f=^{-1}</p>
<p>然后我们声称:如果<span class="math inline">\(x = \varphi ( y ) \in C
( c , d )\)</span>,并且其严格单调且连续.如果<span class="math inline">\(( x_0 , y_0 )\)</span>处其导数存在,则<span class="math inline">\(f &#39; ( x_0 ) = \frac{ 1 }{ \varphi &#39; ( f (
x_0 ) ) }\)</span>.</p>
<p>这个可以用极限证明,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x_0 ) &amp; = \lim_{ x \rightarrow x_0 } \frac{ f ( x ) - f (
x_0 ) }{ x - x_0 } \\
&amp; = \lim_{ y \rightarrow y_0 } \frac{ y - y_0 }{ \varphi ( y ) -
\varphi ( y_0 ) } \\
&amp; = \lim_{ y \rightarrow y_0 } \frac{ 1 }{ \frac{ \varphi ( y ) -
\varphi ( y_0 ) }{ y - y_0 } } \\
&amp; = \frac{ 1 }{ \varphi &#39; ( y_0 ) }
\end{aligned}
\]</span></p>
<p>现在我们证明了反函数有导数,立即有:</p>
<p><span class="math display">\[
f ( g ( x ) ) = x \Rightarrow f &#39; ( x ) g &#39; ( f ( x ) ) = 1
\]</span></p>
<h4><span id="隐函数求导">隐函数求导</span></h4>
<p>这里我们不加证明地给出隐函数求导法则,也就是暂且把<span class="math inline">\(y\)</span>当成<span class="math inline">\(x\)</span>的函数.</p>
<h6><span id="example1">Example1</span></h6>
<p>举例的话,我们来看方程:</p>
<p><span class="math display">\[
x = y + \epsilon \sin y
\]</span></p>
<p>两边对<span class="math inline">\(x\)</span>求导:</p>
<p><span class="math display">\[
\begin{aligned}
1 &amp; = y &#39; + y &#39; \epsilon \cos y \\
y &#39; &amp; = \frac{ 1 }{ 1 + \epsilon \cos y }
\end{aligned}
\]</span></p>
<h4><span id="参数方程的求导">参数方程的求导</span></h4>
<p>如果<span class="math inline">\(\begin{cases}x = x ( t ) \\ y = y ( t
)\end{cases}\)</span>,考虑求导<span class="math inline">\(\frac{ \text{
d } y }{ \text{ d } x }\)</span>.</p>
<p>这个做法就是反函数+链式法则.当然要保证下面需要的地方导数都不是<span class="math inline">\(0\)</span>.</p>
<p>不妨设<span class="math inline">\(t = t ( x )\)</span>,当然有<span class="math inline">\(y = y ( t ( x ) )\)</span>,那么<span class="math inline">\(\frac{ \text{ d } y }{ \text{ d } x } = y &#39; (
t ( x ) ) t &#39; ( x ) = \frac{ y &#39; ( t ) }{ x &#39; ( t )
}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>极坐标的求导:</p>
<p><span class="math display">\[
\begin{cases}
x = r ( \theta ) \cos \theta \\
y = r ( \theta ) \sin \theta
\end{cases}
\]</span></p>
<p>当然<span class="math inline">\(\frac{ \text{ d } y }{ \text{ d } x }
= \frac{ r &#39; \sin \theta + r \cos \theta }{ r &#39; \cos \theta - r
\sin \theta } = \frac{ \tan \theta + \frac{ r }{ r &#39; } }{ 1 - \tan
\theta \frac{ r }{ r &#39; } } = \tan ( \theta + \arctan ( \frac{ r }{ r
&#39; } ) ) = \tan \alpha\)</span>.</p>
<p>而容易发现<span class="math inline">\(\tan
\alpha\)</span>其实是切线和<span class="math inline">\(x\)</span>轴正半轴的夹角.</p>
<h4><span id="初等函数的导数">初等函数的导数</span></h4>
<p>下面给出若干初等函数的导数.</p>
<h5><span id="常函数">常函数</span></h5>
<p>常函数的连续性显然.</p>
<p>导数有:</p>
<p><span class="math display">\[
f ( x ) = c \Rightarrow f &#39; ( x ) = 0
\]</span></p>
<p>证明显然.</p>
<h5><span id="三角函数">三角函数</span></h5>
<p>三角函数的连续性比较有意思,考虑只需证明<span class="math inline">\(\sin x\)</span>连续即可,使用和差化积得到<span class="math inline">\(| \sin x - \sin x_0 | = | 2 \sin \frac{ x - x_0 }{
2 } \cos \frac{ x + x_0 }{ 2 } | \leq 2 | \sin \frac{ x - x_0 }{ 2 } |
\leq | x - x_0 |\)</span>.</p>
<p>导数有:</p>
<p><span class="math display">\[
\begin{aligned}
\sin &#39; ( x ) &amp; = \cos ( x ) \\
\cos &#39; ( x ) &amp; = - \sin ( x )
\end{aligned}
\]</span></p>
<p>只给出前者的证明,后者类似,或者换个元做诱导公式也行.</p>
<p>我们有和差化积:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin ( x + \Delta x ) - \sin ( x ) \\
= &amp; 2 \sin ( \frac{ \Delta x }{ 2 } ) \cos ( x + \frac{ \Delta x }{
2 } )
\end{aligned}
\]</span></p>
<p>自然有:</p>
<p><span class="math display">\[
\begin{aligned}
\lim_{ \Delta x \rightarrow 0 } \frac{ \Delta y }{ \Delta x } &amp; =
\lim_{ \Delta x \rightarrow 0 } \frac{ 2 \sin ( \frac{ \Delta x }{ 2 } )
\cos ( x + \frac{ \Delta x }{ 2 } ) }{ \Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \sin ( \frac{ \Delta x }{
2 } ) }{ \frac{ \Delta x }{ 2 } } \cos ( x + \frac{ \Delta x }{ 2 } ) \\
&amp; = \cos ( x )
\end{aligned}
\]</span></p>
<p>进一步,我们可以考虑高阶导数:</p>
<p><span class="math display">\[
\begin{aligned}
( \sin x )^{ ( n ) } &amp; = \sin ( x + \frac{ n \pi }{ 2 } ) \\
( \cos x )^{ ( n ) } &amp; = \cos ( x + \frac{ n \pi }{ 2 } )
\end{aligned}
\]</span></p>
<p>而考虑<span class="math inline">\(( \tan x )
&#39;\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( \tan x ) &#39; &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \frac{
\sin ( x + \Delta x ) }{ \cos ( x + \Delta x ) } - \frac{ \sin x }{ \cos
x } }{ \Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \sin \Delta x }{ \Delta x
} \frac{ 1 }{ \cos x \cos ( x + \Delta x ) } \\
&amp; = \frac{ 1 }{ \cos^2 x }
\end{aligned}
\]</span></p>
<h5><span id="反三角函数">反三角函数</span></h5>
<p>使用反函数的导数公式:</p>
<p><span class="math display">\[
\begin{aligned}
\arctan &#39; ( x ) &amp; = \frac{ 1 }{ 1 + x^2 } \\
\arccos &#39; ( x ) &amp; = \frac{ - 1 }{ \sqrt{ 1 - x^2 } } \\
\arcsin &#39; ( x ) &amp; = \frac{ 1 }{ \sqrt{ 1 - x^2 } }
\end{aligned}
\]</span></p>
<p>反三角函数的高阶导数比较困难,我们来看个例子:</p>
<p>考虑<span class="math inline">\(y = \arctan x\)</span>,<span class="math inline">\(y &#39; = \frac{ 1 }{ 1 + x^2 } = \frac{ 1 }{ 1 +
\tan^2 y } = \cos^2 y\)</span>,那么<span class="math inline">\(y &#39;
&#39; = - 2 \cos y \sin y \times y &#39; = - \cos^2 y \sin 2
y\)</span>,事实上容易用归纳法证明<span class="math inline">\(y^{ ( n ) }
= ( n - 1 ) ! \cos^n y \sin ( n ( y + \frac{ \pi }{ 2 } )
)\)</span>.</p>
<p>不过还有一种办法,那就是我们考虑<span class="math inline">\(y &#39; =
- \frac{ 1 }{ 2 i } ( \frac{ 1 }{ i + x } + \frac{ 1 }{ i - x }
)\)</span>,用这个归纳立刻得到<span class="math inline">\(y^{ ( n ) } = -
\frac{ ( n - 1 ) ! }{ 2 i } ( ( i - x )^{ - n } - ( - 1 )^n ( i + x )^{
- n } )\)</span>.</p>
<p>然而<span class="math inline">\(y = \arcsin
x\)</span>要麻烦得多.下面我们来看一下:</p>
<p><span class="math display">\[
\begin{aligned}
y &#39; &amp; = \frac{ 1 }{ \sqrt{ 1 - x^2 } } \\
( y &#39; )^2 ( 1 - x^2 ) &amp; = 1 \\
( 1 - x^2 ) 2 y &#39; y &#39; &#39; - 2 x ( y &#39; )^2 &amp; \equiv 0
\\
( 1 - x^2 ) 2 y &#39; &#39; - 2 xy &#39; &amp; \equiv 0
\end{aligned}
\]</span></p>
<p>两边求<span class="math inline">\(n -
2\)</span>次导,利用莱布尼茨公式,化简后得到:</p>
<p><span class="math display">\[
( 1 - x^2 ) y^{ ( n ) } + ( 3 - 2 n ) xy^{ ( n - 1 ) } - ( n - 2 )^2 y^{
( n - 2 ) } \equiv 0
\]</span></p>
<h5><span id="指数函数">指数函数</span></h5>
<p>我们需要首先拿到指数为有理数的东西.</p>
<p>首先整数次方是有定义的,我们需要拿到形如<span class="math inline">\(f
( x ) = a^{ \frac{ 1 }{ x }
}\)</span>的东西,这个考虑取一下反函数即可.然后二者嵌套一下得到形如<span class="math inline">\(a^{ \frac{ q }{ p }
}\)</span>的幂函数,取反一下得到形如<span class="math inline">\(a^{ -
\frac{ q }{ p } }\)</span>的幂函数.</p>
<p>然后要定义无理数指数幂,类似戴德金分割,定义<span class="math inline">\(a^x = \sup_{ q \leq x , q \in Q }
a^q\)</span>.</p>
<p>当然我们要验证那些指数的运算法则,还有一些单调性(两个无理数之间插入两个有理数就可以拆成单调的,这里还需要讨论一下和<span class="math inline">\(1\)</span>的大小关系),这些当然都是对的.</p>
<p>然后我们就可以拿出指数函数,用反函数定义对数函数.</p>
<p>指数函数的连续性:考虑对于<span class="math inline">\(f ( x ) =
a^x\)</span>,<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N &gt; 0 , a &lt; ( 1 +
\epsilon )^N\)</span>,此时取<span class="math inline">\(q_1 &lt; x_0
&lt; q_2\)</span>,<span class="math inline">\(q_2 - q_1 &lt; \frac{ 1 }{
N }\)</span>,这当然能做得到.考虑<span class="math inline">\(a^{ x_0 }
\leq f ( x_0 + 0 ) \leq f ( q_2 )\)</span>,于是<span class="math inline">\(1 \leq \frac{ a^{ q_2 } }{ a^{ q_1 } } \leq a^{
\frac{ 1 }{ N } } \leq 1 + \epsilon\)</span>.</p>
<p>先来看最特殊的指数函数:</p>
<p><span class="math display">\[
f ( x ) = e^x \Rightarrow f &#39; ( x ) = e^x
\]</span></p>
<p>事实上我们还有:</p>
<p><span class="math display">\[
f ( x ) = a^x \Rightarrow f &#39; ( x ) = a^x \ln a , a &gt; 0
\]</span></p>
<p>下面来看下为啥:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ a^{ x +
\Delta x } - a^x }{ \Delta x } \\
&amp; = a^x \lim_{ \Delta x \rightarrow 0 } \frac{ a^{ \Delta x } - 1 }{
\Delta x } \\
&amp; = a^x \ln a
\end{aligned}
\]</span></p>
<p>而高阶导数有:</p>
<p><span class="math display">\[
f ( x ) = e^{ ax } \Rightarrow f^{ ( n ) } = a^n e^{ ax }
\]</span></p>
<h5><span id="对数函数">对数函数</span></h5>
<p>先看:</p>
<p><span class="math display">\[
f ( x ) = \log_a ( x ) \Rightarrow f &#39; ( x ) = \frac{ 1 }{ x \ln a }
\]</span></p>
<p>证明的话考虑:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \log_a ( 1
+ \frac{ \Delta x }{ x } ) }{ \Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \log_a ( 1 + \frac{
\Delta x }{ x } ) }{ \frac{ \Delta x }{ x } } \frac{ 1 }{ x } \\
&amp; = \frac{ 1 }{ x \ln a }
\end{aligned}
\]</span></p>
<p>再看:</p>
<p><span class="math display">\[
f ( x ) = \ln | x | \Rightarrow f &#39; ( x ) = \frac{ 1 }{ x }
\]</span></p>
<p>考虑<span class="math inline">\(f ( x ) = \ln | x | = \frac{ 1 }{ 2 }
\ln x^2\)</span>.</p>
<p>考虑对数函数的高阶导数:</p>
<p><span class="math display">\[
f ( x ) = \ln x \Rightarrow f^{ ( n ) } ( x ) = ( - 1 )^{ n - 1 } ( n -
1 ) ! x^{ - n }
\]</span></p>
<h5><span id="幂函数">幂函数</span></h5>
<p>我们只需要定义<span class="math inline">\(x^{ \alpha } = e^{ \alpha
\ln x }\)</span>即可.</p>
<p>导数有:</p>
<p><span class="math display">\[
f ( x ) = x^\mu \Leftrightarrow f &#39; ( x ) = \mu x^{ \mu - 1 }
\]</span></p>
<p>证明的话,考虑<span class="math inline">\(x =
0\)</span>的时候根据定义显然,如果<span class="math inline">\(x \ne
0\)</span>,那么:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ ( x +
\Delta x )^\mu - x^\mu }{ \Delta x } \\
&amp; = \lim_{ \frac{ \Delta x }{ x } \rightarrow 0 } \frac{ ( 1 +
\frac{ \Delta x }{ x } )^\mu - 1 }{ \frac{ \Delta x }{ x } } x^{ \mu - 1
} \\
&amp; = \mu x^{ \mu - 1 }
\end{aligned}
\]</span></p>
<p>容易发现其高阶导数是:</p>
<p><span class="math display">\[
f ( x ) = x^\alpha \Rightarrow f^{ ( n ) } ( x ) = \alpha^{ \underline{
n } } x^{ \alpha - n }
\]</span></p>
<h5><span id="一般初等函数">一般初等函数</span></h5>
<p>定理:初等函数在其定义域上除了至多一个孤立点集外,可求导并且导函数也是初等函数.</p>
<h4><span id="单调函数的导数">单调函数的导数</span></h4>
<p>定义右上导数<span class="math inline">\(D^+ f ( x_0 ) = \varlimsup_{
h \rightarrow 0 + 0 } \frac{ f ( x_0 + h ) - f ( x_0 ) }{ h
}\)</span>,同理定义右下导数<span class="math inline">\(D_+\)</span>,左上导数<span class="math inline">\(D^{ - }\)</span>,左下导数<span class="math inline">\(D_-\)</span>.那么<span class="math inline">\(f
&#39; ( x_0 )\)</span>存在的充要条件当然是<span class="math inline">\(D_+ = D^+ = D_- = D^-\)</span>并且有限.</p>
<p>下面证明单调(不妨设为单增)函数<span class="math inline">\(f : [ a , b
] \rightarrow \mathbb{ R }\)</span>几乎处处有导数.</p>
<p>我们接下来尝试证明<span class="math inline">\(E_1 = \{ x \in [ a , b
] \mid D^+ f ( x ) &gt; D_- f ( x ) \} , E_2 = \{ x \in [ a , b ] \mid
D^- f ( x ) &gt; D_+ f ( x ) \}\)</span>两个集合是零测集.此时<span class="math inline">\(E_1 \cup E_2\)</span>就是零测集,而<span class="math inline">\(\mathbb{ R } \setminus ( E_1 \cup E_2
)\)</span>中的点都满足<span class="math inline">\(D^{ + } f ( x ) \leq
D_- f ( x ) \leq D^- f ( x ) \leq D_+ f ( x ) \leq D^+ f ( x
)\)</span>,于是它们都相等(可能等于<span class="math inline">\(+
\infty\)</span>).</p>
<p>二者类似,我们下面挑选前者进行证明:</p>
<p>考虑设<span class="math inline">\(A_{ r , s } = \{ x | D^+ f ( x )
&gt; r &gt; s &gt; D_- f ( x ) \}\)</span>,其中<span class="math inline">\(r ,
s\)</span>都是正有理数(因为是单调递增).这当然是可数个集合,所以只需要证明其中任意一个是零测集就可以.我们取<span class="math inline">\(A = A_{ r , s }\)</span>,下面证明<span class="math inline">\(A\)</span>是零测集.</p>
<p>反证,先假设<span class="math inline">\(A\)</span>不是零测集,<span class="math inline">\(m^* ( A ) &gt; 0\)</span>且有限(最大是<span class="math inline">\(b - a\)</span>).</p>
<p>首先删除<span class="math inline">\(A\)</span>中的孤立点集.由于孤立点集是零测集,这当然不会对答案有什么影响,也不会删成空集.这样下面可以直接假设<span class="math inline">\(A\)</span>是开集.</p>
<p>根据定义,存在任意小的<span class="math inline">\(h &gt;
0\)</span>使得<span class="math inline">\(\frac{ f ( x - h ) - f ( x )
}{ - h } &lt; s \Rightarrow f ( x ) - f ( x - h ) &lt;
sh\)</span>,那么我们取出这些<span class="math inline">\(I_{ x , h } = [
x - h , x ]\)</span>,并且满足<span class="math inline">\(I_{ x , h }
\subseteq A\)</span>.它们当然构成<span class="math inline">\(A\)</span>的一个Vitali覆盖.</p>
<p>根据Vitali覆盖引理我们有<span class="math inline">\(\exists I_{ k } =
[ x_k - h_k , x_k ]\)</span>两两不交并且满足<span class="math inline">\(m^* ( A \setminus ( \bigcup I_k ) ) &lt;
\epsilon\)</span>.而考虑<span class="math inline">\(m^* ( A \setminus (
\bigcup I_k ) ) + m^* ( \bigcup I_k ) \geq m^* ( A
)\)</span>,不妨令<span class="math inline">\(B = \bigcup
I_k\)</span>于是我们得到了<span class="math inline">\(m^* ( B ) &gt; m^*
( A ) - \epsilon\)</span>.</p>
<p>这里我曾经以为可以直接写<span class="math inline">\(m^* ( B ) = m^* (
A )\)</span>,但实际上是不行的,因为我们<span class="math inline">\(B\)</span>的构造依赖于<span class="math inline">\(\epsilon\)</span>.</p>
<p>同时由于所有的<span class="math inline">\(I_k \subseteq
A\)</span>并且两两不交,我们还有<span class="math inline">\(\sum_j h_j
\leq m^* ( A ) &lt; ( 1 + \epsilon ) m^* ( A )\)</span>.</p>
<p>而我们发现我们又有<span class="math inline">\(f ( x_j ) - f ( x_j -
h_j ) &lt; sh_j\)</span>,两边求和就有<span class="math inline">\(\sum f
( x_j ) - f ( x_j - h_j ) &lt; sm^* ( A )\)</span>.</p>
<p>而接下来考虑<span class="math inline">\(B\)</span>,<span class="math inline">\(B\)</span>当然仍然是一个开集.对于<span class="math inline">\(\forall y \in
B\)</span>,当然应该存在一个任意小的<span class="math inline">\(k &gt;
0\)</span>使得<span class="math inline">\(f ( y + k ) - f ( y ) &gt;
rk\)</span>.取出这些区间<span class="math inline">\([ y , y + k
]\)</span>当然仍然构成<span class="math inline">\(B\)</span>的一个Vitali覆盖.类似上面,我们当然有结论<span class="math inline">\(\sum f ( y_j + k_j ) - f ( y_j ) &gt; rm^* ( B )
&gt; r ( m^* ( A ) - \epsilon )\)</span>.但考虑<span class="math inline">\([ y_j , y_j + k_j ]\)</span>一定被包含在某个<span class="math inline">\([ x_j - h_j , x_j
]\)</span>中,又根据函数的单调性,自然可以知道<span class="math inline">\(sm^* ( A ) &gt; \sum f ( x_j ) - f ( x_j - h_j )
\geq \sum f ( y_j + k_j ) - f ( y_j ) &gt; r ( m^* ( A ) - \epsilon
)\)</span>.于是<span class="math inline">\(sm^* ( A ) \geq rm^* ( A
)\)</span>,这当然导出<span class="math inline">\(m^* ( A ) =
0\)</span>,与条件不符!</p>
<p>接下来的修补工作是证明<span class="math inline">\(E = \{ x | f &#39;
( x ) = + \infty \}\)</span>的集合是零测集.这意味着对于<span class="math inline">\(\forall N &gt; 0 , \exists \Delta x &gt; 0 , f ( x
+ \Delta x ) - f ( x ) &gt; N \Delta x\)</span>,取<span class="math inline">\([ x , x + \Delta x ]\)</span>当然仍然是<span class="math inline">\(E\)</span>的一个Vitali覆盖.同样根据Vitali覆盖引理得知<span class="math inline">\(\sum \Delta x &gt; m^* ( E ) -
\epsilon\)</span>,如果<span class="math inline">\(m^* ( E ) \ne
0\)</span>,做Vitali覆盖后对<span class="math inline">\(f ( x + \Delta x
) - f ( x ) &gt; N \Delta
x\)</span>左右两边分别求和,左边是有界,上界当然是<span class="math inline">\(f ( b ) - f ( a
)\)</span>,但右边无界.这就给出矛盾了.</p>
<p>理解一下上面的过程的话就是,由于该单调函数定义在一个闭区间上,那么这个单调函数应该有某种最值性.这必然会限制其大小,而如果哪里的大小崩坏了导致没有导数,这些地方的外测度一定要是<span class="math inline">\(0\)</span>,不然整体的最值性无法保证.</p>
<h4><span id="李氏连续函数的导数">李氏连续函数的导数</span></h4>
<p>注意到李氏连续的定义<span class="math inline">\(| f ( x ) - f ( y ) |
\leq L | x - y |\)</span>,注意到<span class="math inline">\(f ( x ) = f
( x ) - Lx + Lx\)</span>.</p>
<p>如果钦定<span class="math inline">\(x &lt;
y\)</span>,那李氏连续等价于<span class="math inline">\(f ( y ) - f ( x )
\leq | f ( x ) - f ( y ) | \leq L ( y - x ) , f ( y ) - Ly \leq f ( x )
- Lx\)</span>,于是<span class="math inline">\(f ( x ) -
Lx\)</span>是单调降函数,当然几乎处处可导,而<span class="math inline">\(Lx\)</span>作为初等函数当然处处可导.</p>
<p>李氏连续几乎等价于导函数有界.</p>
<p>下面我们证明:如果<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上可导,那么<span class="math inline">\(| f &#39; | \leq L \Leftrightarrow | f ( x_1 ) - f
( x_2 ) | \leq L | x_1 - x_2 |\)</span>.</p>
<p>右推左是显然的,除一下然后取极限即可.</p>
<p>左推右也很显然,只需用一下拉格朗日中值定理即可.</p>
<h4><span id="微分">微分</span></h4>
<p>设<span class="math inline">\(y = f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处有定义,假设有一个常数<span class="math inline">\(A\)</span>使得<span class="math inline">\(f ( x_0
+ \Delta x ) - f ( x_0 ) = A \Delta x + o ( \Delta x ) , \Delta x
\rightarrow 0\)</span>,称<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(x_0\)</span>处<strong>可微</strong>,并把<span class="math inline">\(\text{ d } f = \text{ d } y = A \Delta
x\)</span>称为<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处的<strong>微分</strong>,由于后半部分是一个更高阶的无穷小量,我们说微分是函数改变量的线性主要部分.</p>
<h5><span id="微分与导数微商">微分与导数(微商)</span></h5>
<p>结合导数极限的定义,就可以得到<span class="math inline">\(\text{ d } y
= f &#39; ( x ) \text{ d } x\)</span>,<span class="math inline">\(f
&#39; ( x ) = \frac{ \text{ d } y }{ \text{ d } x }
\\\)</span>.这就是我们将导数称作<strong>微商</strong>的原因.换言之,一阶可微一定一阶可导,反之亦然.但容易发现,可微的定义要比可导好得多,可微可以往外拓展到平面等拓扑结构,但可导不行.</p>
<p>一阶微分具有<strong>形式不变性</strong>.换言之就是,我们在求导的时候是需要选定一个自变量的,当选定的自变量是<span class="math inline">\(y\)</span>的时候,根据上面自然会有<span class="math inline">\(z = g ( y ) , \text{ d } z = g &#39; ( y ) \text{
d } y\)</span>.</p>
<p>但是当选定的自变量不是<span class="math inline">\(y\)</span>的时候,上面的形式是同样成立的.我们下面证明这个结论,令<span class="math inline">\(y = f ( x )\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
[ g ( f ( x ) ) ] &#39; &amp; = g &#39; ( f ( x ) ) f &#39; ( x ) \\
\text{ d } z &amp; = g &#39; ( f ( x ) ) f &#39; ( x ) \text{ d } x \\
\text{ d } z &amp; = g &#39; ( y ) \text{ d } y \\

\end{aligned}\]</span>
<p>$$</p>
<p>必须提出高阶微分不存在形式不变性,换句话说,<span class="math inline">\(z = g ( y )\)</span>的二阶微分的形式不等价于<span class="math inline">\(z = g ( y = f ( x )
)\)</span>的二阶微分,你不能乱换元.</p>
<p>一般将高阶微分记作<span class="math inline">\(\frac{ \text{ d }^n y
}{ \text{ d } x^n }\)</span>.</p>
<h4><span id="导函数的性质">导函数的性质</span></h4>
<h5><span id="费马定理">费马定理</span></h5>
<p>如果<span class="math inline">\(f ( x )\)</span>在邻域<span class="math inline">\(U ( \xi , \delta )\)</span>上有定义,<span class="math inline">\(\xi\)</span>是其的一个极值点,在<span class="math inline">\(\xi\)</span>处存在导数,那么<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<p>不妨考虑最大值情况,<span class="math inline">\(f &#39; ( \xi ) =
\lim_{ \Delta x \to + 0 } \frac{ f ( \xi + \Delta x ) - f ( \xi ) }{
\Delta x } = \lim_{ \Delta x \to - 0 } \frac{ f ( \xi + \Delta x ) - f (
\xi ) }{ \Delta x }\)</span>,前者<span class="math inline">\(\leq
0\)</span>,后者<span class="math inline">\(\geq 0\)</span>,此时当然<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<h5><span id="罗尔中值定理">罗尔中值定理</span></h5>
<p>如果<span class="math inline">\(f \in C [ a , b
]\)</span>且可导,并且<span class="math inline">\(f ( a ) = f ( b
)\)</span>.则<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>,<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<p>即:可导函数两个零点间一定有导数的零点.</p>
<p>设<span class="math inline">\(M\)</span>为<span class="math inline">\(f [ a , b ]\)</span>上的最大值,<span class="math inline">\(m\)</span>是最小值,当二者相等即常值函数的时候,当然成立.</p>
<p>当<span class="math inline">\(M &gt; m\)</span>的时候,则<span class="math inline">\(M &gt; f ( a )\)</span>和<span class="math inline">\(m &lt; f ( a )\)</span>至少有一个成立.不妨设<span class="math inline">\(f ( M ) &gt; f ( a ) = f ( b )\)</span>.</p>
<p>根据费马定理,这个极值点的导数为<span class="math inline">\(0\)</span>.</p>
<p>由此可以推论:函数的零点数量<span class="math inline">\(| \{ x | f ( x
) = 0 \} | \leq 1 + | \{ x | f &#39; ( x ) = 0 \} |\)</span>.</p>
<p>这当然可以推出<span class="math inline">\(n\)</span>次多项式至多<span class="math inline">\(n\)</span>个实根.</p>
<p>事实上可以证明更强的结论,当<span class="math inline">\(c_i\)</span>不全为<span class="math inline">\(0\)</span>的时候,取<span class="math inline">\(n\)</span>个不同实数<span class="math inline">\(\lambda_k\)</span>,<span class="math inline">\(f (
x ) = \sum_{ i = 1 }^n c_i x^{ \lambda_i }\)</span>至多有<span class="math inline">\(n - 1\)</span>个正根.</p>
<p>归纳法,<span class="math inline">\(n = 1\)</span>的时候显然成立.<span class="math inline">\(n - 1\)</span>时成立的话,考虑<span class="math inline">\(f ( x ) = 0 \Leftrightarrow x^{ - \lambda_n } f (
x ) = 0\)</span>,而后者有一项是常数项,求导后少一项.</p>
<h5><span id="拉格朗日中值定理">拉格朗日中值定理</span></h5>
<p><span class="math inline">\(f \in C [ a , b ]\)</span>,并且在<span class="math inline">\(( a , b )\)</span>上可导，<span class="math inline">\(\exists \xi \in ( a , b ) , f &#39; ( \xi ) =
\frac{ f ( b ) - f ( a ) }{ b - a }\)</span>.</p>
<p>考虑先把函数放平,设<span class="math inline">\(g ( x ) = f ( x ) -
\frac{ f ( b ) - f ( a ) }{ b - a } ( x - a ) - f ( a
)\)</span>,容易发现<span class="math inline">\(g ( a ) = g ( b ) =
0\)</span>,根据罗尔中值定理,<span class="math inline">\(\exists \xi , g
&#39; ( \xi ) = 0 = f &#39; ( \xi ) - \frac{ f ( b ) - f ( a ) }{ b - a
} , f &#39; ( \xi ) = \frac{ f ( b ) - f ( a ) }{ b - a }\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\(f &#39; ( x ) \equiv 0
\Rightarrow f ( x ) \equiv C\)</span>.</p>
<p>考虑<span class="math inline">\(\forall x , y , x \ne
y\)</span>,<span class="math inline">\(\forall \xi , f &#39; ( \xi ) =
\frac{ f ( y ) - f ( x ) }{ y - x } = 0 \Rightarrow f ( x ) = f ( y
)\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>证明:如果<span class="math inline">\(f &#39; ( x ) \equiv g &#39; ( x
)\)</span>,那么<span class="math inline">\(f ( x ) = g ( x ) +
C\)</span>.</p>
<p>考虑<span class="math inline">\(h ( x ) = f ( x ) - g ( x ) , h &#39;
( x ) \equiv 0 \Rightarrow h ( x ) = C\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑对抛物线用拉格朗日中值定理,设<span class="math inline">\(f ( x )
= px^2 + qx + r\)</span>,则<span class="math inline">\(\frac{ f ( b ) -
f ( a ) }{ b - a } = \frac{ p ( b^2 - a^2 ) + q ( b - a ) }{ b - a } = p
( b + a ) + q = f &#39; ( \frac{ a + b }{ 2 } )\)</span>.</p>
<p>反过来,如果恒有<span class="math inline">\(\frac{ f ( b ) - f ( a )
}{ b - a } = f &#39; ( \frac{ a + b }{ 2 }
)\)</span>,事实上也可以推出<span class="math inline">\(f ( x
)\)</span>是抛物线.</p>
<p>此时我们有<span class="math inline">\(f ( x + y ) - f ( x - y ) = 2
yf &#39; ( x )\)</span>,取<span class="math inline">\(y =
1\)</span>,知道<span class="math inline">\(f ( x ) \in C^{ \infty
}\)</span>,于是可以两边对<span class="math inline">\(y\)</span>求两次导数,得到<span class="math inline">\(f &#39; &#39; ( x + y ) - f &#39; &#39; ( x - y )
\equiv 0\)</span>,取<span class="math inline">\(y =
x\)</span>,这当然意味着<span class="math inline">\(f &#39; &#39; ( x
)\)</span>是常函数.</p>
<h5><span id="柯西中值定理">柯西中值定理</span></h5>
<p><span class="math inline">\(f , g \in C [ a , b
]\)</span>,并且均在<span class="math inline">\(( a , b
)\)</span>上可导,其中<span class="math inline">\(g &#39; ( x ) \ne
0\)</span>.则<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>,<span class="math inline">\(\frac{ f ( b ) - f ( a ) }{ g ( b
) - g ( a ) } = \frac{ f &#39; ( \xi ) }{ g &#39; ( \xi )
}\)</span>.</p>
<p>此时注意到<span class="math inline">\(g ( b ) \ne g ( a
)\)</span>,原因是根据拉格朗日中值定理,如果<span class="math inline">\(g
( b ) = g ( a ) , \exists \xi \in ( a , b ) , g &#39; ( \xi ) =
0\)</span>,这与<span class="math inline">\(g &#39; ( x ) \ne
0\)</span>矛盾.</p>
<p>令<span class="math inline">\(F ( x ) = f ( x ) ( g ( b ) - g ( a ) )
- g ( x ) ( f ( b ) - f ( a ) )\)</span>.</p>
<p>接下来注意到上述命题等价于<span class="math inline">\(\exists \xi \in
( a , b ) , F &#39; ( \xi ) = 0\)</span>.</p>
<p>而注意到<span class="math inline">\(F ( a ) = f ( a ) g ( b ) - g ( a
) f ( b ) = F ( b )\)</span>,根据罗尔中值定理立刻得到答案.</p>
<p>然而这个东西竟然还能推广,我们有:</p>
<p>如果<span class="math inline">\(f , g , h \in C [ a , b
]\)</span>并且在<span class="math inline">\(( a , b
)\)</span>上可导,<span class="math inline">\(\exists \xi \in ( a , b )
,\)</span>有:</p>
<p><span class="math display">\[
\left | \begin{matrix}
f &#39; ( \xi ) &amp; g &#39; ( \xi ) &amp; h &#39; ( \xi ) \\
f ( a ) &amp; g ( a ) &amp; h ( a ) \\
f ( b ) &amp; g ( b ) &amp; h ( b )
\end{matrix} \right | = 0
\]</span></p>
<p>证明的话考虑构造:</p>
<p><span class="math display">\[
F ( x ) = \left | \begin{matrix}
f ( x ) &amp; g ( x ) &amp; h ( x ) \\
f ( a ) &amp; g ( a ) &amp; h ( a ) \\
f ( b ) &amp; g ( b ) &amp; h ( b )
\end{matrix} \right |
\]</span></p>
<p>注意到<span class="math inline">\(F ( a ) = F ( b ) = 0\)</span>.</p>
<h5><span id="广义微分中值定理">广义微分中值定理</span></h5>
<h6><span id="广义罗尔中值定理">广义罗尔中值定理</span></h6>
<p>如果<span class="math inline">\(f \in C [ a , b ]\)</span>且<span class="math inline">\(\forall x \in ( a , b ) , f &#39;_\pm ( x
)\)</span>均存在,并且<span class="math inline">\(f ( a ) = f ( b ) =
0\)</span>.则<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>,<span class="math inline">\(f_+ &#39; ( \xi ) f_- &#39; ( \xi
) \leq 0\)</span>.</p>
<p>证明和罗尔中值定理没区别,仍然是找最值.</p>
<h6><span id="广义拉格朗日中值定理">广义拉格朗日中值定理</span></h6>
<p>如果<span class="math inline">\(f \in C [ a , b ]\)</span>且<span class="math inline">\(\forall x \in ( a , b ) , f &#39;_\pm ( x
)\)</span>均存在,<span class="math inline">\(\eta = \frac{ f ( a ) - f (
b ) }{ a - b }\)</span>,则<span class="math inline">\(\exists \xi \in (
a , b )\)</span>,<span class="math inline">\(( f_+ &#39; ( \xi ) - \eta
) ( f_- &#39; ( \xi ) - \eta ) \leq 0\)</span>.</p>
<p>证明差不多,仍然是把函数放平然后用广义罗尔中值定理就行.</p>
<h5><span id="导函数与间断点">导函数与间断点</span></h5>
<p>导函数不存在第一类间断点.</p>
<p>证明的话,考虑证明当<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(x_0\)</span>处可导的时候,<span class="math inline">\(\exists x_n &lt; x_0 &lt; y_n\)</span>,使得<span class="math inline">\(x_n , y_n \rightarrow x_0\)</span>,并且满足<span class="math inline">\(\lim f &#39; ( x_n ) = \lim f &#39; ( y_n ) = f
&#39; ( x_0 )\)</span>.</p>
<p>原因根据拉格朗日中值定理,<span class="math inline">\(\exists x_n \in
( x_0 - \frac{ 1 }{ n } , x_0 )\)</span>,<span class="math inline">\(f
&#39; ( x_n ) = \frac{ f ( x_0 ) - f ( x_0 - \frac{ 1 }{ n } ) }{ \frac{
1 }{ n } }\)</span>,直接这么取当然就是可行的.</p>
<h5><span id="函数的升降性">函数的升降性</span></h5>
<p><span class="math inline">\(f \in C [ a , b ]\)</span>并且在<span class="math inline">\(( a , b )\)</span>上可导,<span class="math inline">\(f\)</span>单调不减<span class="math inline">\(\Leftrightarrow\)</span>f’(x)</p>
<p>左推右当然是导数定义,右推左可以用拉格朗日微分中值定理.</p>
<p>另外由于保号性,<span class="math inline">\(f &#39; ( x ) &gt; 0
\Rightarrow f \uparrow\)</span>,但反之不成立.</p>
<h5><span id="函数的极值">函数的极值</span></h5>
<p>若<span class="math inline">\(f\)</span>在<span class="math inline">\(( x_0 - \delta , x_0 + \delta )\)</span>上<span class="math inline">\(n - 1\)</span>次可导,<span class="math inline">\(\forall 1 \leq k \leq n - 1 , f^{ ( k ) } ( x_0 )
= 0\)</span>.而且<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处存在<span class="math inline">\(n\)</span>阶导数并有<span class="math inline">\(f^{ ( n ) } ( x_0 ) \ne
0\)</span>.我们有以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(n\)</span>是奇数的时候,<span class="math inline">\(x_0\)</span>不是极值点.</p></li>
<li><p><span class="math inline">\(n\)</span>是偶数且<span class="math inline">\(f^{ ( n ) } ( x_0 ) &lt; 0\)</span>时,<span class="math inline">\(x_0\)</span>是极大值点.</p></li>
<li><p><span class="math inline">\(n\)</span>是偶数且<span class="math inline">\(f^{ ( n ) } ( x_0 ) &gt; 0\)</span>时,<span class="math inline">\(x_0\)</span>是极小值点.</p></li>
</ol>
<p>证明考虑泰勒公式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = f ( x_0 ) + \sum_{ k = 1 }^n \frac{ f^{ ( k ) } ( x_0 )
}{ k ! } ( x - x_0 )^k + o ( ( x - x_0 )^n ) \\
f ( x ) - f ( x_0 ) &amp; = ( x - x_0 )^n ( \frac{ f^{ ( n ) } ( x_0 )
}{ n ! } + o ( 1 ) )
\end{aligned}
\]</span></p>
<p>于是取极小邻域并且<span class="math inline">\(n\)</span>是偶数的时候<span class="math inline">\(f ( x ) - f ( x_0 )\)</span>和<span class="math inline">\(f^{ ( n ) } ( x_0 )\)</span>同号,上述命题立见.</p>
<h5><span id="达布定理">达布定理</span></h5>
<p>也即:导函数拥有介值性.</p>
<p>如果<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b ]\)</span>上可导,<span class="math inline">\(f &#39; ( a ) f &#39; ( b ) &lt;
0\)</span>,那么<span class="math inline">\(\exists \xi \in ( a , b ) , f
&#39; ( \xi ) = 0\)</span>.</p>
<p>不妨设<span class="math inline">\(f &#39; ( a ) &gt; 0 &gt; f &#39; (
b )\)</span>,那么<span class="math inline">\(f\)</span>在<span class="math inline">\(a\)</span>处附近递增,在<span class="math inline">\(b\)</span>处附近递减.那我们取一下<span class="math inline">\(f ( \xi ) = \max_{ [ a , b ] } \{ f ( x )
\}\)</span>,那么<span class="math inline">\(\xi \ne a , \xi \ne
b\)</span>,于是<span class="math inline">\(\xi \in ( a , b
)\)</span>,<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<p>那我们加个常数就可以把这个推广到导函数的介值性.</p>
<p>然而这个介值性比连续性弱得多,例如下面这个函数的导函数就在闭区间<span class="math inline">\([ 0 , 1 ]\)</span>上有界但没有最值:</p>
<p><span class="math display">\[
f ( x ) = \begin{cases}
- x^2 ( 1 + \sin{ \frac{ 1 }{ x } } ) &amp; x \ne 0 \\
0 &amp; x = 0
\end{cases}
\]</span></p>
<p>其构造思路是让其在<span class="math inline">\(0\)</span>附近的导数在<span class="math inline">\(( - 1 , 1 )\)</span>上下波动,这样上确界为<span class="math inline">\(1\)</span>,但<span class="math inline">\(0\)</span>处跳出去,所以取不到<span class="math inline">\(1\)</span>.</p>
<p>下面这个函数更极端,其导函数在闭区间<span class="math inline">\([ 0 ,
1 ]\)</span>上无界:</p>
<p><span class="math display">\[
f ( x ) = \begin{cases}
x^2 \sin{ \frac{ 1 }{ x^2 } } &amp; x \ne 0 \\
0 &amp; x = 0
\end{cases}
\]</span></p>
<p>其构造思路应当是让其在<span class="math inline">\(0\)</span>处相当厉害地波动.</p>
<h5><span id="函数的凹凸性">函数的凹凸性</span></h5>
<p>定义一个函数是下凸的,若对<span class="math inline">\(\forall x_1 ,
x_2 \in I , \forall \lambda \in [ 0 , 1 ] , f ( \lambda x_1 + ( 1 -
\lambda ) x_2 ) \leq \lambda f ( x_1 ) + ( 1 - \lambda ) f ( x_2
)\)</span>.</p>
<p>如果一个函数是下凸的,那么其充要条件是<span class="math inline">\(\forall x_1 , x_2 , x_3 \in I\)</span>满足<span class="math inline">\(x_1 &lt; x_2 &lt; x_3\)</span>,<span class="math inline">\(\left | \begin{matrix}1 &amp; x_1 &amp; f ( x_1 )
\\ 1 &amp; x_2 &amp; f ( x_2 ) \\ 1 &amp; x_3 &amp; f ( x_3
)\end{matrix} \right | \geq 0\)</span>.只需设<span class="math inline">\(x_2 = \lambda x_1 + ( 1 - \lambda )
x_3\)</span>然后简单变形即可.</p>
<p>不妨设<span class="math inline">\(k ( x_1 , x_2 ) = \frac{ f ( x_1 )
- f ( x_2 ) }{ x_1 - x_2
}\)</span>也就是这里的割线斜率.还可以证明如果一个函数是下凸的,那么其充要条件是<span class="math inline">\(\forall x_1 , x_2 , x_3 \in I , x_1 &lt; x_2 &lt;
x_3\)</span>,斜率有<span class="math inline">\(k ( x_1 , x_2 ) \leq k (
x_1 , x_3 ) \leq k ( x_2 , x_3
)\)</span>,即所谓三弦引理.这个性质容易证明,而且该性质立刻说明开区间上的有界下凸函数一定是李氏连续函数.这意味着其应当几乎处处可导.另外三弦引理还可以改为<span class="math inline">\(k ( x_1 , x_2 ) \leq k ( x_2 , x_3
)\)</span>,原因是中间项一定是两项的带权平均.</p>
<p>另外显然的是:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(f\)</span>可导,那么<span class="math inline">\(f\)</span>下凸<span class="math inline">\(\Leftrightarrow\)</span>f’</p></li>
<li><p>如果<span class="math inline">\(f\)</span>可二阶导,那么<span class="math inline">\(f\)</span>下凸<span class="math inline">\(\Leftrightarrow\)</span>f’’</p></li>
</ol>
<p>如果<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>附近连续并且在<span class="math inline">\(x_0\)</span>左右小邻域内凸性相反,称其为<span class="math inline">\(f ( x )\)</span>的一个<strong>拐点</strong>.</p>
<p>容易说明<span class="math inline">\(f &#39; &#39; ( x_0 ) =
0\)</span>是拐点的必要条件,原因是拐点处<span class="math inline">\(f
&#39; ( x )\)</span>的增减性相反,<span class="math inline">\(x_0\)</span>必定是<span class="math inline">\(f
&#39; ( x )\)</span>的极值点.由此还可以套用之前的极值点结论:</p>
<p>若<span class="math inline">\(f\)</span>在<span class="math inline">\(( a , b )\)</span>上<span class="math inline">\(n\)</span>次可导,<span class="math inline">\(\exists x_0 \in ( a , b ) , \forall 1 \leq k \leq
n - 1 , f^{ ( k ) } ( x_0 ) = 0\)</span>.并且<span class="math inline">\(\forall x \in ( a , b ) , f^{ ( n ) } ( x ) &gt;
0\)</span>我们有以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(n\)</span>是奇数的时候,<span class="math inline">\(f ( x )\)</span>是严格单增函数.</p></li>
<li><p><span class="math inline">\(n\)</span>是偶数的时候,<span class="math inline">\(f ( x )\)</span>是严格下凸函数.</p></li>
</ol>
<p>但上述条件疑似有点过强,能不能放弱一点呢?</p>
<p>可以发现一个在开区间<span class="math inline">\(( a , b
)\)</span>上的函数是下凸的充要条件应当是以下条件同时成立:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall x \in ( a , b
)\)</span>,<span class="math inline">\(f &#39;_\pm ( x
)\)</span>均存在,并且<span class="math inline">\(f &#39;_- ( x ) \leq f
&#39;_+ ( x )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall x_1 , x_2 \in ( a , b ) , x_1
&lt; x_2\)</span>,<span class="math inline">\(f &#39;_+ ( x_1 ) \leq f
&#39;_- ( x_2 )\)</span>.</p></li>
</ol>
<p>必要性几乎是显然的,只需用三弦引理然后在每个点都卡一下极限就行.</p>
<p>充分性略有麻烦.考虑反证,只需反推三弦引理即可.设其不是凸的,那就<span class="math inline">\(\exists x_1 , x_2 , x_3 \in ( a , b ) , x_1 &lt;
x_2 &lt; x_3 , k ( x_1 , x_2 ) &gt; k ( x_2 , x_3 )\)</span>.不妨设<span class="math inline">\(\eta_1 = k ( x_1 , x_2 ) , \eta_2 = k ( x_2 , x_3
)\)</span>那么根据广义拉格朗日中值定理,<span class="math inline">\(\exists \xi_1 \in ( x_1 , x_2 ) , \xi_2 \in ( x_2
, x_3 )\)</span>,使得<span class="math inline">\(( f_+ &#39; ( \xi_1 ) -
\eta_1 ) ( f &#39;_- ( \xi_1 ) - \eta_1 ) \leq 0 , ( f_+ &#39; ( \xi_2 )
- \eta_2 ) ( f &#39;_- ( \xi_2 ) - \eta_2 ) \leq 0\)</span>.</p>
<p>立刻得到<span class="math inline">\(f &#39;_+ ( \xi_1 ) \geq \eta_1
\geq f_- &#39; ( \xi_1 ) , f &#39;_+ ( \xi_2 ) \geq \eta_2 \geq f_-
&#39; ( \xi_2 )\)</span>,由于<span class="math inline">\(\eta_1 &gt;
\eta_2\)</span>,所以<span class="math inline">\(f &#39;_+ ( \xi_1 ) \geq
\eta_1 &gt; \eta_2 \geq f &#39;_- ( \xi_2 )\)</span>,但<span class="math inline">\(\xi_1 &lt; \xi_2\)</span>,这就出现了矛盾.</p>
<p>还可以证明下凸函数除了可数个点以外都可导,并且几乎处处有二阶导数.</p>
<p>这个怎么证明呢?考虑由(1)(2),可以发现<span class="math inline">\(f
&#39;_+ ( x )\)</span>和<span class="math inline">\(f_- &#39; ( x
)\)</span>都是单调函数,那么除了可数个点以外它们均连续,而它们在连续处必定可导,原因是<span class="math inline">\(f_+ &#39; ( x_0 - \epsilon ) \leq f &#39;_- ( x_0
) \leq f &#39;_+ ( x_0
)\)</span>,夹逼一下就可以了.而这样的话其导数单调,于是处处二阶可导.</p>
<p>由此还可以发现:<span class="math inline">\(f\)</span>在开区间<span class="math inline">\(I\)</span>上,是下凸的等价于:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall x_0 \in I , f &#39;_\pm ( x_0
)\)</span>存在.</p></li>
<li><p><span class="math inline">\(\forall x \in I , f ( x ) \geq f (
x_0 ) + f &#39;_\pm ( x_0 ) ( x - x_0 )\)</span>.</p></li>
</ol>
<p>必要性:</p>
<p>考虑已知凸函数,只需证明<span class="math inline">\(f ( x ) - f ( x_0
) \geq f &#39;_\pm ( x_0 ) ( x - x_0 )\)</span>.不妨假设<span class="math inline">\(x &gt;
x_0\)</span>(另一方向同理),于是只需证明<span class="math inline">\(\frac{ f ( x ) - f ( x_0 ) }{ x - x_0 } \geq f
&#39;_\pm ( x_0 )\)</span>,用广义拉格朗日微分中值定理立刻得见此成立.</p>
<p>充分性:</p>
<p>任取两点<span class="math inline">\(x_1 , x_2 \in I , x_1 &lt;
x_2\)</span>,有<span class="math inline">\(\frac{ f ( x_2 ) - f ( x_1 )
}{ x_2 - x_1 } \geq f_- &#39; ( x_1
)\)</span>,那么左边那个东西取极限得到<span class="math inline">\(f
&#39;_+ ( x_1 )\)</span>,这样就说明了任何一个点都有<span class="math inline">\(f &#39;_+ ( x ) \geq f &#39;_- ( x )\)</span>.</p>
<p>接下来仍然容易得到:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x_2 ) &amp; \geq f ( x_1 ) + f &#39;_+ ( x_1 ) ( x_2 - x_1 ) \\
f ( x_1 ) &amp; \geq f ( x_2 ) + f &#39;_- ( x_2 ) ( x_1 - x_2 )
\end{aligned}
\]</span></p>
<p>由上述式子立刻得到<span class="math inline">\(f_+ &#39; ( x_1 ) &#39;
\leq f_- &#39; ( x_2 )\)</span>.这样就证明了充分性.</p>
<h4><span id="经典不等式">经典不等式</span></h4>
<h5><span id="琴生不等式">琴生不等式</span></h5>
<p>如果<span class="math inline">\(f\)</span>在区间<span class="math inline">\(I\)</span>上是下凸的,则<span class="math inline">\(\forall x_i \in I , \lambda_i \in [ 0 , 1 ] , \sum
\lambda_i = 1\)</span>,那么<span class="math inline">\(f ( \sum
\lambda_i x_i ) \leq \sum \lambda_i f ( x_i
)\)</span>.从几何角度来看,这意味着在<span class="math inline">\(f ( \sum
\lambda_i x_i
)\)</span>处作的切线位于原函数下方.所以函数如果是上凸的话不等号要反向.</p>
<p>当所有<span class="math inline">\(x_i\)</span>均相等的时候显然成立.</p>
<p>不然考虑直接取<span class="math inline">\(x_0 = \sum \lambda_i
x_i\)</span>,此时发现<span class="math inline">\(x_0\)</span>一定在区间内部.于是我们知道<span class="math inline">\(f ( x_i ) \geq f ( x_0 ) + f &#39;_+ ( x_0 ) ( x_i
- x_0 )\)</span>,求和得到<span class="math inline">\(\sum \lambda_i f (
x_i ) \geq f ( x_0 ) + f_+ &#39; ( x_0 ) \sum \lambda_i ( x_i - x_0 ) =
f ( x_0 )\)</span>,这样就证毕了.</p>
<p>容易将琴生不等式推广到积分形式,当<span class="math inline">\(\varphi
( x )\)</span>是下凸连续函数的时候,当然有<span class="math inline">\(\varphi ( \int_0^1 f \text{ d } x ) \leq \int_0^1
\varphi ( f ( x ) ) \text{ d } x\)</span>,证明只需对黎曼和求极限.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:圆内接<span class="math inline">\(n\)</span>边形以正<span class="math inline">\(n\)</span>边形面积和周长最大.</p>
<p>不妨设其为单位元,用圆心向顶点连边,会得到一圈圆心角<span class="math inline">\(\alpha_1 , \ldots ,
\alpha_n\)</span>,它们之和应当是<span class="math inline">\(2
\pi\)</span>并且范围均在<span class="math inline">\(( 0 , \pi
]\)</span>里(原因是圆心肯定得包含在正<span class="math inline">\(n\)</span>边形里,不然肯定不算大),此范围内<span class="math inline">\(\sin\)</span>是下凸函数,那么<span class="math inline">\(S = \frac{ 1 }{ 2 } \sum \sin \alpha_i \leq \frac{
n }{ 2 } \sin \frac{ \sum \alpha_i }{ n } = \frac{ n }{ 2 } \sin \frac{
2 \pi }{ n }\)</span>,<span class="math inline">\(L = 2 \sum \sin \frac{
\alpha_i }{ 2 } \leq 2 n \sin \frac{ \sum \alpha_i }{ 2 n } = 2 n \sin
\frac{ \pi }{ n }\)</span>.</p>
<p>同理还可以证明圆外接<span class="math inline">\(n\)</span>边形以正<span class="math inline">\(n\)</span>边形面积和周长最小,证明可以考虑取切线然后用<span class="math inline">\(\tan\)</span>的凸性.</p>
<h5><span id="均值不等式">均值不等式</span></h5>
<p>当<span class="math inline">\(x_i &gt; 0\)</span>时:</p>
<p><span class="math display">\[
\frac{ n }{ \sum \frac{ 1 }{ x_i } } \leq ( \prod x_i )^{ \frac{ 1 }{ n
} } \leq \frac{ \sum x_i }{ n }
\]</span></p>
<p>取<span class="math inline">\(f ( x ) = \ln x\)</span>,<span class="math inline">\(f ( x )\)</span>是上凸的,于是<span class="math inline">\(\ln \frac{ \sum x_i }{ n } \geq \frac{ 1 }{ n }
\sum \ln x_i\)</span>,右边得证,取倒数得到左边.</p>
<h5><span id="柯西-赫尔德不等式">柯西-赫尔德不等式</span></h5>
<p>当<span class="math inline">\(a_i , b_i &gt; 0\)</span>并且<span class="math inline">\(\frac{ 1 }{ p } + \frac{ 1 }{ q } =
1\)</span>时,有<span class="math inline">\(\sum a_i b_i \leq ( \sum
a_i^p )^{ \frac{ 1 }{ p } } ( \sum b_i^q )^{ \frac{ 1 }{ q }
}\)</span>.其特例给出柯西不等式.</p>
<p>套用琴生不等式,取<span class="math inline">\(f ( x ) = x^{ \frac{ 1
}{ q } } , \lambda_i = \frac{ a_i^p }{ \sum_j a_j^p } , x_i = \frac{
b_i^q }{ a_i^p }\)</span>,容易发现<span class="math inline">\(f ( x
)\)</span>上凸.</p>
<p>这样就会得到:</p>
$$
<span class="math display">\[\begin{aligned}
f ( \sum \lambda_i x_i ) &amp; \geq \sum \lambda_i f ( x_i ) \\
( \sum_i \frac{ b_i^q }{ \sum_j a_j^p } )^{ \frac{ 1 }{ q } } &amp; \geq
\sum_i \frac{ a_i b_i }{ \sum_j a_j^p } \\

\end{aligned}\]</span>
<p>$$</p>
<p>化简一下就可以了.</p>
<p>在这里也可以将此形式拓展到积分形式,注意到当<span class="math inline">\(\frac{ 1 }{ p } + \frac{ 1 }{ q } =
1\)</span>时,<span class="math inline">\(a^{ \frac{ 1 }{ p } } b^{
\frac{ 1 }{ q } } = e^{ \frac{ \ln a }{ p } + \frac{ \ln b }{ q } } \leq
\frac{ a }{ p } + \frac{ b }{ q }\)</span>,原因是琴生不等式.</p>
<p>此时令<span class="math inline">\(F = ( \int_a^b | f ( x ) |^p \text{
d } x )^{ \frac{ 1 }{ p } } , G = ( \int_a^b | g ( x ) |^q \text{ d } x
)^{ \frac{ 1 }{ q } }\)</span>,再令<span class="math inline">\(a =
\frac{ | f ( x ) |^p }{ F^p } , b = \frac{ | g ( x ) |^q }{ G^q
}\)</span>,根据上面的不等式立刻得到<span class="math inline">\(\frac{ |
f ( x ) g ( x ) | }{ FG } \leq \frac{ a }{ p } + \frac{ b }{ q
}\)</span>,此时做两边积分,注意到<span class="math inline">\(\int a =
\int b = 1\)</span>,立刻得到<span class="math inline">\(( \int_a^b | f (
x ) |^p \text{ d } x )^{ \frac{ 1 }{ p } } ( \int_a^b | g ( x ) |^q
\text{ d } x )^{ \frac{ 1 }{ q } } \geq \int_a^b | f ( x ) g ( x ) |
\text{ d } x\)</span>.</p>
<h5><span id="闵可夫斯基minkovski不等式">闵可夫斯基(Minkovski)不等式</span></h5>
<p><span class="math inline">\(x_i , y_i \geq 0 , p \geq
1\)</span>,则<span class="math inline">\(( \sum ( x_i + y_i )^p )^{
\frac{ 1 }{ p } } \leq ( \sum x_i^p )^{ \frac{ 1 }{ p } } + ( \sum y_i^p
)^{ \frac{ 1 }{ p } }\)</span>.这其实揭示了某种度量下的三角形不等式.</p>
<p>套用琴生不等式,取<span class="math inline">\(f ( x ) = ( 1 - x^{
\frac{ 1 }{ p } } )^p , x \in ( 0 , 1 )\)</span>.求导得到<span class="math inline">\(f &#39; ( x ) = - ( 1 - x^{ \frac{ 1 }{ p } } )^{
p - 1 } x^{ \frac{ 1 }{ p } - 1 }\)</span>,再来一次化简得到<span class="math inline">\(f &#39; &#39; ( x ) = ( 1 - \frac{ 1 }{ p } ) ( 1
- x^{ \frac{ 1 }{ p } } )^{ p - 2 } x^{ \frac{ 1 }{ p } - 2 } \geq
0\)</span>.于是<span class="math inline">\(f ( x )\)</span>下凸.</p>
<p>取<span class="math inline">\(\lambda_i = \frac{ ( x_i + y_i )^p }{
\sum_j ( x_j + y_j )^p }\)</span>,<span class="math inline">\(u_i = (
\frac{ x_i }{ x_i + y_i } )^p\)</span>.这样得到:</p>
<p><span class="math display">\[
\begin{aligned}
( 1 - \frac{ ( \sum x_i^p )^{ \frac{ 1 }{ p } } }{ ( \sum_j ( x_j + y_j
)^p )^{ \frac{ 1 }{ p } } } )^p &amp; \leq \sum_i \frac{ ( x_i + y_i )^p
}{ \sum_j ( x_j + y_j )^p } ( \frac{ y_i }{ x_i + y_i } )^p \\
( ( \sum ( x_i + y_i )^p )^{ \frac{ 1 }{ p } } - ( \sum x_i^p )^{ \frac{
1 }{ p } } )^p &amp; \leq \sum y_i^p
\end{aligned}
\]</span></p>
<p>化简一下就做完了.</p>
<h4><span id="洛必达法则">洛必达法则</span></h4>
<p>来看几个抽象的问题:</p>
<ol type="1">
<li><p><span class="math inline">\(\infty - \infty\)</span>.</p></li>
<li><p><span class="math inline">\(0 \times \infty\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ 0 }{ 0 }\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \infty }{ \infty
}\)</span>.</p></li>
<li><p><span class="math inline">\(0^0\)</span>.</p></li>
<li><p><span class="math inline">\(1^\infty\)</span>.</p></li>
<li><p><span class="math inline">\(\infty^0\)</span>.</p></li>
</ol>
<p>(1)可以写成<span class="math inline">\(\infty ( 1 - \frac{ \infty }{
\infty } )\)</span>,这样就转化成了(4)和(2).</p>
<p>(2)可以写成<span class="math inline">\(\frac{ 0 }{ \frac{ 1 }{ \infty
} }\)</span>,就转化成了(3).</p>
<p>(5)可以写成<span class="math inline">\(e^{ 0 \ln 0
}\)</span>,就转化成了(2).</p>
<p>(6)可以写成<span class="math inline">\(e^{ \infty \ln 1
}\)</span>,就转化成了(2).</p>
<p>(7)可以写成<span class="math inline">\(e^{ 0 \ln \infty
}\)</span>,就转化成了(2).</p>
<p>这样的话我们只需要解决俩问题就行了,也就是<span class="math inline">\(\frac{ 0 }{ 0 }\)</span>和<span class="math inline">\(\frac{ \infty }{ \infty }\)</span>.</p>
<h5><span id="00型">0/0型</span></h5>
<p>如果<span class="math inline">\(f , g\)</span>在<span class="math inline">\(U_0 ( a , \delta )\)</span>上可导,<span class="math inline">\(g &#39; ( x ) \ne 0\)</span>,<span class="math inline">\(\lim_{ x \rightarrow a } f ( x ) = \lim_{ x
\rightarrow a } g ( x ) = 0\)</span>.那么若<span class="math inline">\(\lim_{ x \rightarrow a } \frac{ f &#39; ( x ) }{ g
&#39; ( x ) } = k \Rightarrow \lim_{ x \rightarrow a } \frac{ f ( x ) }{
g ( x ) } = k\)</span>.</p>
<p>这个只需要定义<span class="math inline">\(f ( a ) = g ( a ) =
0\)</span>,这样这俩函数就连续了.然后直接跑柯西中值定理就可以对<span class="math inline">\(\frac{ f ( x ) - f ( a ) }{ g ( x ) - g ( a ) } =
\frac{ f &#39; ( \xi ) }{ g &#39; ( \xi ) }\)</span>.</p>
<p>这里可以看出洛必达法则是单向的,因为我们取得<span class="math inline">\(\xi\)</span>并不是连续变化的,只是取了一个<span class="math inline">\(\rightarrow 0\)</span>的<span class="math inline">\(\xi\)</span>的子列.</p>
<p>而如果<span class="math inline">\(a = \infty\)</span>,那就考虑取<span class="math inline">\(t \rightarrow 0\)</span>,然后把<span class="math inline">\(x\)</span>换成<span class="math inline">\(\frac{ 1
}{ t }\)</span>,做复合函数求导即可,结论无差异.</p>
<h5><span id="inftyinfty型"><span class="math inline">\(\infty\)</span>/<span class="math inline">\(\infty\)</span>型</span></h5>
<p>如果<span class="math inline">\(f , g\)</span>在<span class="math inline">\(U_0 ( a , \delta )\)</span>上可导,<span class="math inline">\(g &#39; ( x ) \ne 0\)</span>,<span class="math inline">\(\lim_{ x \rightarrow a } g ( x ) =
\infty\)</span>.那么若<span class="math inline">\(\lim_{ x \rightarrow a
} \frac{ f &#39; ( x ) }{ g &#39; ( x ) } = k \Rightarrow \lim_{ x
\rightarrow a } \frac{ f ( x ) }{ g ( x ) } = k\)</span>.</p>
<p>这个证明麻烦一点,先来讨论<span class="math inline">\(k \ne \pm
\infty\)</span>的情况.</p>
<p>考虑<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists \delta &gt; 0 , \forall
\xi \in ( a , a + \delta )\)</span>,应当有<span class="math inline">\(k
- \epsilon &lt; \frac{ f &#39; ( \xi ) }{ g &#39; ( \xi ) } &lt; k +
\epsilon\)</span>,那么<span class="math inline">\(\forall x \in ( a , a
+ \delta )\)</span>,取<span class="math inline">\(x_1 = a +
\delta\)</span>当然有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ f ( x ) - f ( x_1 ) }{ g ( x ) - g ( x_1 ) } &amp; = \frac{ f
&#39; ( \xi ) }{ g &#39; ( \xi ) } \\
\frac{ f ( x ) }{ g ( x ) } &amp; = \frac{ f &#39; ( \xi ) }{ g &#39; (
\xi ) } ( 1 - \frac{ g ( x_1 ) }{ g ( x ) } ) + \frac{ f ( x_1 ) }{ g (
x ) }
\end{aligned}
\]</span></p>
<p>两边取极限就做完了.</p>
<p>当<span class="math inline">\(k = \pm
\infty\)</span>的时候容易发现上面那个还能用.</p>
<h4><span id="泰勒公式">泰勒公式</span></h4>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处有<span class="math inline">\(n\)</span>阶导数,则<strong>泰勒公式</strong>声称<span class="math inline">\(x \rightarrow x_0\)</span>时<span class="math inline">\(f ( x ) = \sum_{ k = 0 }^n f^{ ( k ) } ( x_0 )
\frac{ ( x - x_0 )^k }{ k ! } + o ( ( x - x_0 )^n )\)</span>,其中<span class="math inline">\(o ( ( x - x_0 )^n
)\)</span>称作<strong>皮亚诺余项</strong>.特别地,当<span class="math inline">\(x_0 =
0\)</span>的时候,称其为<strong>麦克劳林公式</strong>.</p>
<p>要证明这个式子只需证明<span class="math inline">\(\lim_{ x
\rightarrow x_0 } \frac{ f ( x ) - \sum_{ k = 0 }^n f^{ ( k ) } ( x_0 )
\frac{ ( x - x_0 )^k }{ k ! } }{ ( x - x_0 )^n } =
0\)</span>.对上下分别用<span class="math inline">\(n -
1\)</span>次洛必达法则后,那么只需要证明<span class="math inline">\(\lim_{ x \rightarrow x_0 } \frac{ f^{ ( n - 1 ) }
( x ) - f^{ ( n - 1 ) ( x_0 ) } }{ ( x - x_0 ) } - f^{ ( n ) } ( x_0 ) =
0\)</span>.而这当然就是导数的定义,于是就证毕了.</p>
<h5><span id="拉格朗日余项">拉格朗日余项</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( a , b )\)</span>上有<span class="math inline">\(n + 1\)</span>阶导数,并且<span class="math inline">\(f ( x ) \in C^n [ a , b ]\)</span>,泰勒公式有<span class="math inline">\(f ( x ) = \sum_{ k = 0 }^n f^{ ( k ) } ( x_0 )
\frac{ ( x - x_0 )^k }{ k ! } + \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n +
1 ) ! } ( x - x_0 )^{ n + 1 }\)</span>,其中<span class="math inline">\(\xi \in ( x_0 , x )\)</span>.一般将<span class="math inline">\(\frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! } (
x - x_0 )^{ n + 1 }\)</span>称作<strong>拉格朗日余项</strong>.</p>
<p>证明的话,考虑对于一个固定的<span class="math inline">\(x\)</span>,构造<span class="math inline">\(F ( t )
= f ( x ) - \sum_{ k = 0 }^n f^{ ( k ) } ( t ) \frac{ ( x - t )^k }{ k !
}\)</span>,<span class="math inline">\(G ( t ) = ( x - t )^{ n + 1
}\)</span>.这里之所以固定<span class="math inline">\(x\)</span>而移动<span class="math inline">\(x_0\)</span>的原因是,如果反过来固定则求导就不能实现下面的错项相消.不难发现<span class="math inline">\(F ( x ) = G ( x ) =
0\)</span>,此时考虑必定有一个<span class="math inline">\(\xi \in ( x_0 ,
x )\)</span>满足<span class="math inline">\(\frac{ F &#39; ( \xi ) }{ G
&#39; ( \xi ) } = \frac{ F ( x_0 ) - F ( x ) }{ G ( x_0 ) - G ( x ) } =
\frac{ F ( x_0 ) }{ G ( x_0 ) }\)</span>.</p>
<p>这个时候研究一下他们的导数,注意到<span class="math inline">\(G &#39;
( t ) = - ( n + 1 ) ( x - t )^{ n }\)</span>,<span class="math inline">\(F &#39; ( t ) = - \sum_{ k = 0 }^n f^{ ( k + 1 ) }
( t ) \frac{ ( x - t )^k }{ k ! } + \sum_{ k = 1 }^n f^{ ( k ) } ( t )
\frac{ ( x - t )^{ k - 1 } }{ ( k - 1 ) ! } = - f^{ ( n + 1 ) } ( t )
\frac{ ( x - t )^n }{ n ! }\)</span>.</p>
<p>于是<span class="math inline">\(\frac{ F ( x_0 ) }{ G ( x_0 ) } =
\frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! }\)</span>,<span class="math inline">\(F ( x_0 ) = \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n
+ 1 ) ! } ( x - x_0 )^{ n + 1 }\)</span>.</p>
<p>下面给出一些常见的泰勒展开公式(其中<span class="math inline">\(0 &lt;
\theta &lt; 1\)</span>):</p>
<ol type="1">
<li><p><span class="math inline">\(e^x = \sum_{ k = 0 }^n \frac{ x^k }{
k ! } + \frac{ e^{ \theta x } x^{ n + 1 } }{ ( n + 1 ) ! } = 1 + \frac{
x }{ 1 ! } + \frac{ x^2 }{ 2 ! } + \frac{ x^3 }{ 3 ! } + o ( x^3
)\)</span>.</p></li>
<li><p><span class="math inline">\(\sin x = \sum_{ k = 0 }^{ n } \frac{
( - 1 )^k x^{ 2 k + 1 } }{ ( 2 k + 1 ) ! } + ( - 1 )^{ n + 1 } \frac{
\cos \theta x }{ ( 2 n + 3 ) ! } x^{ 2 n + 3 } = x - \frac{ 1 }{ 3 ! }
x^3 + o ( x^4 )\)</span>.</p></li>
<li><p><span class="math inline">\(\cos x = \sum_{ k = 0 }^n \frac{ ( -
1 )^k x^{ 2 k } }{ ( 2 k ) ! } + ( - 1 )^{ n + 1 } \frac{ \cos \theta x
}{ ( 2 n + 2 ) ! } x^{ 2 n + 2 } = 1 - \frac{ 1 }{ 2 ! } x^2 + \frac{ 1
}{ 4 ! } x^4 + o ( x^5 )\)</span>.</p></li>
<li><p><span class="math inline">\(\tan x = x + \frac{ 1 }{ 3 } x^3 +
\frac{ 2 }{ 15 } x^5 + o ( x^6 )\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 + x ) = \sum_{ k = 1 }^n
\frac{ ( - 1 )^{ k - 1 } x^k }{ k } + ( - 1 )^n \frac{ x^{ n + 1 } }{ (
n + 1 ) ( 1 + \theta x )^{ n + 1 } } = x - \frac{ 1 }{ 2 } x^2 + \frac{
1 }{ 3 } x^3 + o ( x^3 )\)</span>.</p></li>
<li><p><span class="math inline">\(( 1 + x )^\alpha = \sum_{ k = 0 }^n
\frac{ \alpha^{ \underline{ k } } }{ k ! } x^k + \frac{ \alpha^{
\underline{ n + 1 } } }{ ( n + 1 ) ! } ( 1 + \theta x )^{ \alpha - n - 1
} x^{ n + 1 }\)</span>.</p></li>
</ol>
<h4><span id="解析函数">解析函数</span></h4>
<p>不妨设<span class="math inline">\(f_n ( x , x_0 ) = \sum_{ k = 0 }^n
f^{ ( k ) } ( x_0 ) \frac{ ( x - x_0 )^k }{ k ! }\)</span>.我们称<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处解析,若<span class="math inline">\(\exists \delta &gt; 0\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } f_n ( x , x_0 ) = f
( x )\)</span>,也即泰勒展式在一个邻域上可以逼近原函数.</p>
<p>如果其在<span class="math inline">\(( a , b
)\)</span>上任何一点都解析,那么称其在<span class="math inline">\(( a , b
)\)</span>上解析,记作<span class="math inline">\(f \in C^\omega ( a , b
)\)</span>.</p>
<p>解析函数应当有如下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(f , g\)</span>在<span class="math inline">\(x_0\)</span>处解析,那么<span class="math inline">\(f , g\)</span>的四则运算在<span class="math inline">\(x_0\)</span>处也解析.</p></li>
<li><p><span class="math inline">\(f , g\)</span>均解析,并且<span class="math inline">\(f \circ g\)</span>有意义,那么<span class="math inline">\(f \circ g\)</span>也解析.</p></li>
<li><p><span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处解析,那么<span class="math inline">\(f^{ - 1 }\)</span>在<span class="math inline">\(f
( x_0 )\)</span>处解析.</p></li>
<li><p>初等函数基本是解析函数.</p></li>
</ol>
<p>对于(1):</p>
<p><span class="math inline">\(f \pm g\)</span>当然是平凡的,至于<span class="math inline">\(fg\)</span>和<span class="math inline">\(\frac{ f
}{ g }\)</span>如何证明解析性,我们回头再说.</p>
<p>对于(2):</p>
<p>回头再说.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式<span class="math inline">\(P_n = \sum_{ i = 0 }^{ n } y_i
( \prod_{ j = 0 \land j \ne i }^{ n } \frac{ x - x_j }{ x_i - x_j } )
\\\)</span>.显然当<span class="math inline">\(x =
x_i\)</span>时,该多项式的答案为<span class="math inline">\(y_i\)</span>.</p>
<p>用这个在一个<span class="math inline">\(n +
1\)</span>次可导的函数<span class="math inline">\(f \in C ( a , b
)\)</span>上打<span class="math inline">\(n +
1\)</span>个点并且取出这个多项式<span class="math inline">\(P_n\)</span>,考虑它们的误差.取<span class="math inline">\(\omega ( x ) = \prod_{ k = 0 }^n ( x - x_k
)\)</span>,事实上有:<span class="math inline">\(\exists \xi \in ( a , b
) , f ( x ) = P_n ( x ) + \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) !
} \omega ( x )\)</span>.</p>
<p>取<span class="math inline">\(h ( t ) = f ( t ) - P_n ( t
)\)</span>,考虑对于一个固定的<span class="math inline">\(x \ne
x_i\)</span>,取<span class="math inline">\(g ( t ) = \frac{ h ( x ) }{
\omega ( x ) } \omega ( t ) - h ( t )\)</span>.注意到<span class="math inline">\(g ( x ) = 0 , g ( x_i ) = 0\)</span>,所以<span class="math inline">\(g\)</span>有<span class="math inline">\(n +
2\)</span>个零点,所以<span class="math inline">\(g^{ ( n + 1 )
}\)</span>一定有一个零点,记为<span class="math inline">\(\xi\)</span>.</p>
<p>那么我们就有<span class="math inline">\(g^{ ( n + 1 ) } ( \xi ) =
\frac{ h ( x ) }{ \omega ( x ) } ( n + 1 ) ! - f^{ ( n + 1 ) } ( \xi ) =
0\)</span>.上述命题就得证了.</p>
<p>那么怎么样能让<span class="math inline">\(\omega ( x
)\)</span>这个东西的最大值尽可能小呢?</p>
<p>我们定义所谓<span class="math inline">\(n\)</span>次切比雪夫多项式<span class="math inline">\(f\)</span>,使得对于任何一个首项为<span class="math inline">\(1\)</span>的多项式<span class="math inline">\(T_n\)</span>,<span class="math inline">\(\max_{ (
a , b ) } | T_n | \geq \max_{ ( a , b ) } | f |\)</span>.</p>
<p>事实上<span class="math inline">\([ - 1 , 1
]\)</span>上的切比雪夫多项式可以用递推关系描述:</p>
<p><span class="math display">\[
P_n = \begin{cases}
1 &amp; n = 0 \\
x &amp; n = 1 \\
x^2 - \frac{ 1 }{ 2 } &amp; n = 2 \\
xP_{ n - 1 } - \frac{ 1 }{ 4 } P_{ n - 2 } &amp; \text{ otherwise }
\end{cases}
\]</span></p>
<p>还可以写成<span class="math inline">\(P_n = \frac{ 1 }{ 2^{ n - 1 } }
\cos ( n \arccos x )\)</span>.</p>
<h4><span id="函数的作图">函数的作图</span></h4>
<h5><span id="渐近线">渐近线</span></h5>
<p>如果对于一个函数<span class="math inline">\(y = f ( x
)\)</span>,存在一条直线<span class="math inline">\(l\)</span>使得函数上一点<span class="math inline">\(P ( x , f ( x ) )\)</span>距离原点距离<span class="math inline">\(\to + \infty\)</span>的时候,<span class="math inline">\(( x , f ( x ) )\)</span>与<span class="math inline">\(l\)</span>的距离<span class="math inline">\(\to
0\)</span>.</p>
<p>大概可以有以下几类渐近线:</p>
<ol type="1">
<li><p>水平渐近线:<span class="math inline">\(f ( + \infty ) =
C\)</span>或<span class="math inline">\(f ( - \infty ) =
C\)</span>.</p></li>
<li><p>垂直渐近线:<span class="math inline">\(f ( x_0 - 0 ) =
\infty\)</span>或<span class="math inline">\(f ( x_0 + 0 ) =
\infty\)</span>.</p></li>
<li><p>斜渐近线:<span class="math inline">\(l = kx +
b\)</span>,那么<span class="math inline">\(\lim_{ x \to + \infty }
\frac{ f ( x ) }{ x } = a , \lim_{ x \to \infty } ( f ( x ) - ax ) =
b\)</span>.</p></li>
</ol>
<h5><span id="作图">作图</span></h5>
<ol type="1">
<li><p>确定定义域和值域.</p></li>
<li><p>研究其奇偶性,周期性.</p></li>
<li><p>研究<span class="math inline">\(f &#39; ( x ) =
0\)</span>的根以确定极值点和升降区间.</p></li>
<li><p>研究<span class="math inline">\(f &#39; &#39; ( x ) =
0\)</span>的根找出拐点.</p></li>
<li><p>求出渐近线.</p></li>
</ol>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>目的是找到一个函数<span class="math inline">\(f\)</span>的零点,尝试取上面任何一点并作切线,找到切线与<span class="math inline">\(x\)</span>轴的交点.或者说任取<span class="math inline">\(x_0\)</span>,取<span class="math inline">\(x_{ n +
1 } = x_n - \frac{ f ( x_n ) }{ f &#39; ( x_n ) }\)</span>.</p>
<p>我们需要证明这个做法的正确性,事实上:</p>
<p>如果<span class="math inline">\(f &#39; , f &#39;
&#39;\)</span>在<span class="math inline">\([ a , b
]\)</span>上非零,<span class="math inline">\(\exists c \in [ a , b ] , f
( c ) = 0\)</span>,那我们取<span class="math inline">\(x_0 \in [ a , b
]\)</span>满足<span class="math inline">\(f ( x_0 ) f &#39; &#39; ( x_0
) &gt; 0\)</span>,那么取<span class="math inline">\(x_{ n + 1 } = x_n -
\frac{ f ( x_n ) }{ f &#39; ( x_n ) }\)</span>的数列<span class="math inline">\(\{ x_n \} \rightarrow c\)</span>.事实上:</p>
<ol type="1">
<li><p>当<span class="math inline">\(f &#39; f &#39; &#39; &gt;
0\)</span>,<span class="math inline">\(x_n\)</span>单调下降趋近于<span class="math inline">\(c\)</span>.</p></li>
<li><p>当<span class="math inline">\(f &#39; f &#39; &#39; &lt;
0\)</span>,<span class="math inline">\(x_n\)</span>单调上升趋近于<span class="math inline">\(c\)</span>.</p></li>
</ol>
<p>并且<span class="math inline">\(| x_n - c | \sim O ( 2^{ - 2^n }
)\)</span>.</p>
<p>上述讨论情况有点多,我们下面只讨论其中一种进行证明:</p>
<p>当<span class="math inline">\(f &#39; &gt; 0 , f &#39; &#39; &gt;
0\)</span>的时候,<span class="math inline">\(f\)</span>是一个单调上升的下凸函数.容易发现这个数列单调下降并且应当大于<span class="math inline">\(c\)</span>,那它就有极限,两边取极限得知<span class="math inline">\(\lim_{ n \to \infty } f ( x_n ) = 0\)</span>.</p>
<p>接下来看一下逼近速度,泰勒公式展开一下知道<span class="math inline">\(0 = f ( c ) = f ( x_n ) + f &#39; ( x_n ) ( c -
x_n ) + \frac{ f &#39; &#39; ( \xi ) }{ 2 } ( c - x_n
)^2\)</span>.从上面的结果容易看出<span class="math inline">\(n \geq
1\)</span>的时候,<span class="math inline">\(| x_{ n + 1 } - c | =
\frac{ | f ( x_n ) + f &#39; ( x_n ) ( c - x_n ) | }{ | f &#39; ( x_n )
| } = \frac{ f &#39; &#39; ( \xi ) }{ 2 | f &#39; ( x_n ) | } ( c - x_n
)^2\)</span>.前面那个系数是有界的,可以看作一个常数.于是这一次的误差应当是上一次误差的平方级别.</p>
<h3><span id="积分">积分</span></h3>
<h4><span id="不定积分">不定积分</span></h4>
<p>如果存在可导函数<span class="math inline">\(F\)</span>满足<span class="math inline">\(F &#39; ( x ) = f ( x )\)</span>,则称一个函数<span class="math inline">\(f\)</span>是<strong>可积</strong>的,<span class="math inline">\(F ( x )\)</span>是<span class="math inline">\(f (
x )\)</span>的<strong>原函数</strong>,或称其为<span class="math inline">\(f ( x )\)</span>的不定积分.</p>
<p>我们之前已经证明过导数相等的两个函数最多只差一个常数,因此一个函数的原函数是有唯一的<span class="math inline">\(F ( x ) + C\)</span>的形式的.</p>
<h5><span id="不定积分的运算">不定积分的运算</span></h5>
<p>只给出以下两个运算法则:</p>
<p><span class="math display">\[
\begin{aligned}
\int ( f ( x ) \pm g ( x ) ) \text{ d } x &amp; = \int f ( x ) \text{ d
} x \pm \int g ( x ) \text{ d } x \\
\int \alpha f ( x ) \text{ d } x &amp; = \alpha \int f ( x ) \text{ d }
x
\end{aligned}
\]</span></p>
<h5><span id="积分表">积分表</span></h5>
<ol type="1">
<li><p><span class="math inline">\(\int x^\alpha \text{ d } x = \frac{
x^{ \alpha + 1 } }{ \alpha + 1 } + C , \alpha \ne - 1\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ x } = \ln
| x | + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int e^x \text{ d } x = e^x +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \cos x \text{ d } x = \sin x +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \sin x \text{ d } x = - \cos x +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \cos^2 x
} = \tan x + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \sin^2 x
} = - \cot x + C = - \frac{ 1 }{ \tan x } + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ 1 + x^2 }
= \arctan x + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \sqrt{ 1
- x^2 } } = \arcsin x + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \sqrt{
x^2 \pm a^2 } } = \ln | x + \sqrt{ x^2 \pm a^2 } | +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \sqrt{ a^2 - x^2 } \text{ d } x
= \frac{ 1 }{ 2 } ( x \sqrt{ a^2 - x^2 } + a^2 \arcsin \frac{ x }{ a } )
+ C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \sqrt{ x^2 \pm a^2 } \text{ d }
x = \frac{ 1 }{ 2 } ( x \sqrt{ x^2 \pm a^2 } \pm a^2 \ln | x + \sqrt{
x^2 \pm a^2 } | ) + C\)</span>.</p></li>
</ol>
<h5><span id="换元法">换元法</span></h5>
<p>第一换元法:设<span class="math inline">\(\int g ( t ) \text{ d } t =
G ( t ) + C\)</span>,<span class="math inline">\(w ( x
)\)</span>可导,则<span class="math inline">\(\int g ( w ( x ) ) w &#39;
( x ) \text{ d } x = G ( w ( x ) ) +
C\)</span>.证明只需对右边求导即可.</p>
<p>第二换元法:设<span class="math inline">\(x ( t
)\)</span>可导,且有反函数<span class="math inline">\(t ( x
)\)</span>,那么如果<span class="math inline">\(\int f ( x ( t ) ) x
&#39; ( t ) \text{ d } t = G ( t ) + C\)</span>,则<span class="math inline">\(\int f \text{ d } x = G ( t ( x ) ) +
C\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I_n = \int \tan^n x \text{ d }
x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \int \tan^{ n - 2 } ( \frac{ 1 }{ \cos^2 x } - 1 ) \text{ d
} x \\
&amp; = \int \tan^{ n - 2 } x ( \text{ d } \tan x ) - I_{ n - 2 } \\
&amp; = \frac{ \tan^{ n - 1 } x }{ n - 2 } - I_{ n - 2 }
\end{aligned}
\]</span></p>
<p>边界条件的话<span class="math inline">\(I_0 = x + C , I_1 = \int
\frac{ \sin x }{ \cos x } \text{ d } x = - \int \frac{ 1 }{ \cos x } (
\text{ d } \cos x ) = - \ln ( \cos x ) + C\)</span>.</p>
<h5><span id="分部积分">分部积分</span></h5>
<p>我们应当有<span class="math inline">\(( uv ) &#39; = u &#39; v + v
&#39; u\)</span>,两边积分得到<span class="math inline">\(uv = \int u
&#39; v \text{ d } x + \int v &#39; u \text{ d }
x\)</span>,变形得到<span class="math inline">\(\int v \text{ d } u = uv
- \int u \text{ d } v\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I_n = \int \cos^n x \text{ d }
x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \int \cos^{ n - 1 } x ( \text{ d } \sin x ) \\
&amp; = \cos^{ n - 1 } x \sin x + ( n - 1 ) \int \sin^2 x \cos^{ n - 2 }
x \text{ d } x \\
&amp; = \cos^{ n - 1 } x \sin x + ( n - 1 ) \int ( 1 - \cos^2 x ) \cos^{
n - 2 } x \text{ d } x \\
&amp; = \cos^{ n - 1 } \sin x + ( n - 1 ) I_{ n - 2 } - ( n - 1 ) I_n
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(I_n = \frac{ 1 }{ n } \cos^{ n -
1 } x \sin x + \frac{ n - 1 }{ n } I_{ n - 2 }\)</span>.</p>
<p>边界条件当然是<span class="math inline">\(I_0 = x + C , I_1 = \sin x
+ C\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I_n = \int \frac{ \text{ d } x }{
\cos^n x }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \int \frac{ \text{ d } \tan x }{ \cos^{ n - 2 } x } \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } - \int \tan x ( \text{ d }
\cos^{ 2 - n } x ) \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } + ( 2 - n ) \int \cos^{ - n
} x \sin^2 x \text{ d } x \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } + ( 2 - n ) \int \cos^{ - n
} x ( 1 - \cos^2 x ) \text{ d } x \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } + ( 2 - n ) I_n - ( 2 - n )
I_{ n - 2 }
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(I_n = \frac{ 1 }{ n - 1 } \frac{
\tan x }{ \cos^{ n - 2 } x } + \frac{ n - 2 }{ n - 1 } I_{ n - 2
}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(I_{ m , n } = \int \sin^m x \cos ( nx )
\text{ d } x\)</span>,其中<span class="math inline">\(m &lt;
n\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_{ m , n } &amp; = \int \sin^m x \cos ( nx ) \text{ d } x \\
&amp; = \frac{ 1 }{ n } \int \sin^m x \text{ d } \sin ( nx ) \\
&amp; = \frac{ 1 }{ n } \left ( \sin^m x \sin ( nx ) - \frac{ m }{ n }
\int \sin ( nx ) \sin^{ m - 1 } x \cos x \text{ d } x \right )
\end{aligned}
\]</span></p>
<p>然后观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int \sin ( nx ) \sin^{ m - 1 } x \cos x \text{ d } x \\
= &amp; - \frac{ 1 }{ n } \int \sin^{ m - 1 } x \cos x \text{ d } \cos (
nx ) \\
= &amp; - \frac{ 1 }{ n } ( \cos ( nx ) \sin^{ m - 1 } x \cos x - \int
\cos ( nx ) ( \text{ d } \sin^{ m - 1 } x \cos x ) )
\end{aligned}
\]</span></p>
<p>观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int \cos ( nx ) ( \text{ d } \sin^{ m - 1 } x \cos x ) \\
= &amp; \int \cos ( nx ) ( - \sin^{ m } + ( m - 1 ) \sin^{ m - 2 } x
\cos^2 x ) \text{ d } x \\
= &amp; \int \cos ( nx ) ( ( m - 1 ) \sin^{ m - 2 } x - m \sin^m x ) )
\text{ d } x \\
= &amp; ( m - 1 ) I_{ m - 2 , n } - mI_{ m , n }
\end{aligned}
\]</span></p>
<p>往回倒腾倒腾,边界条件是:</p>
<p><span class="math display">\[
\begin{aligned}
I_{ 0 , n } &amp; = \int \cos ( nx ) \text{ d } x = \frac{ \sin ( nx )
}{ n } + C \\
I_{ 1 , n } &amp; = \int \sin x \cos ( nx ) \text{ d } x \\
&amp; = \frac{ 1 }{ 2 } \int ( \sin ( ( n + 1 ) x ) - \sin ( ( n - 1 ) x
) ) \text{ d } x \\
&amp; = \frac{ 1 }{ 2 } ( \frac{ - \cos ( ( n + 1 ) x ) }{ n + 1 } +
\frac{ \cos ( ( n - 1 ) x ) }{ n - 1 } ) + C
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(I_n = \int \frac{ \text{ d } x }{ ( x^2
+ a^2 )^n }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \frac{ x }{ ( x^2 + a^2 )^n } - \int x \text{ d } \frac{ 1
}{ ( x^2 + a^2 )^n } \\
&amp; = \frac{ x }{ ( x^2 + a^2 )^n } + 2 n \int \frac{ x^2 + a^2 - a^2
}{ ( x^2 + a^2 )^{ n + 1 } } \text{ d } x \\
&amp; = \frac{ x }{ ( x^2 + a^2 )^n } + 2 nI_{ n } - 2 a^2 nI_{ n + 1 }
\end{aligned}
\]</span></p>
<p>边界是<span class="math inline">\(I_1 = \frac{ 1 }{ a } \arctan
\frac{ x }{ a } + C\)</span>.</p>
<h6><span id="example5">Example5</span></h6>
<p>求<span class="math inline">\(I = \int x \cos^3 x \text{ d }
x\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
I &amp; = \int x \cos^3 x \text{ d } x = \int x \cos^2 x \text{ d } (
\sin x ) \\
&amp; = x \cos^2 x \sin x - \int \sin x ( \cos^2 x \text{ d } x - 2 x
\cos x \sin x ) \\
&amp; = x \cos^2 x \sin x + \int \cos^2 x ( \text{ d } \cos x ) + 2 \int
x \cos x \sin^2 x \text{ d } x \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 \int x \cos x ( 1
- \cos^2 x ) \text{ d } x \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 \int x \cos x
\text{ d } x - 2 I \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 \int x ( \text{ d
} \sin x ) - 2 I \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 ( x \sin x + \cos
x ) - 2 I + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是<span class="math inline">\(3 I = x \cos^2 x \sin x + \frac{
\cos^3 x }{ 3 } + 2 ( x \sin x + \cos x ) + C\)</span>.</p>
<h5><span id="有理分式的不定积分">有理分式的不定积分</span></h5>
<p>考虑真分式<span class="math inline">\(R ( x ) = \frac{ P ( x ) }{ Q (
x ) }\)</span>,其中<span class="math inline">\(\deg P ( x ) &lt; \deg Q
( x )\)</span>.至于其他分式可以做长除法变成真分式.</p>
<p>定义最简真分式形如<span class="math inline">\(\frac{ A }{ ( x - a )^m
} , \frac{ Bx + C }{ ( x^2 + px + q )^n }\)</span>.</p>
<p>先证明一个引理:实数域上,任何一个多项式可以分解为若干不可约的一次多项式和二次多项式的乘积.</p>
<p>原因是复根一定成对出现,如果<span class="math inline">\(z\)</span>是复根,那么<span class="math inline">\(\bar{ z }\)</span>一定也是复根,原因是<span class="math inline">\(\overline{ zw } = \bar{ z } \bar{ w
}\)</span>,对一个多项式两边逐项取共轭就可以发现上述结论.那只需要把成对的复根扔到一个二次多项式里就行.</p>
<p>再证明一个引理:实数上,任何一个真分式都可以转化为若干最简真分式的线性组合.</p>
<p>先拆一次项,如上将<span class="math inline">\(Q ( x ) = ( x - a )^m R
( x )\)</span>,其中<span class="math inline">\(R ( a ) \ne
0\)</span>,那我们考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ P ( x ) }{ Q ( x ) } - \frac{ A_1 }{ ( x - a )^m } &amp; = \frac{
P ( x ) - A_1 R ( x ) }{ ( x - a )^m R ( x ) } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时取<span class="math inline">\(A_1 = \frac{ P ( a ) }{ R ( a )
}\)</span>,立刻见到<span class="math inline">\(( x - a ) | ( P ( x ) -
A_1 R ( x ) )\)</span>,于是上下至少少一次,这样就可以继续分解了.</p>
<p>再拆二次项,如上将<span class="math inline">\(Q ( x ) = ( x^2 + px + q
)^m R ( x )\)</span>,其中<span class="math inline">\(( x^2 + px + q )
\nmid R ( x )\)</span>,那:</p>
<p><span class="math display">\[
\frac{ P ( x ) }{ Q ( x ) } - \frac{ A_1 x + B_1 }{ ( x^2 + px + q )^m }
= \frac{ P ( x ) - ( A_1 x + B_1 ) R ( x ) }{ ( x^2 + px + q )^m R ( x )
}
\]</span></p>
<p>令<span class="math inline">\(T ( x ) = P ( x ) - ( A_1 x + B_1 ) R (
x )\)</span>,类似上面应当要确定<span class="math inline">\(A_1 ,
B_1\)</span>使得上面那部分是<span class="math inline">\(x^2 + px +
q\)</span>的倍数就可以.直接取<span class="math inline">\(x^2 + px +
q\)</span>的某个复根<span class="math inline">\(\alpha\)</span>,则只需<span class="math inline">\(T ( \alpha ) =
0\)</span>即可,这是两个方程(实部虚部),而我们有两个未知数,理应可以解出答案.具体解得过程其实也可以直接把<span class="math inline">\(P ( x )\)</span>和<span class="math inline">\(R (
x )\)</span>直接先用多项式长除法杀一杀然后剩的部分判一下方程.</p>
<p>这样最后就只需要对拆出来的东西逐项积分就行.意味着有理函数的原函数是初等函数.</p>
<h5><span id="有理三角函数的不定积分">有理三角函数的不定积分</span></h5>
<p>即<span class="math inline">\(\sin x , \cos
x\)</span>经过有限步四则运算得到的函数.</p>
<p>我们定义二元有理函数<span class="math inline">\(R ( u , v
)\)</span>,那么有理三角函数实际上是<span class="math inline">\(R ( \cos
x , \sin x )\)</span>.</p>
<p>下面给出以下命题:</p>
<ol type="1">
<li><p>如果其对于<span class="math inline">\(u\)</span>是奇函数,也即<span class="math inline">\(R ( u , v ) = - R ( - u , v )\)</span>,那么<span class="math inline">\(R ( u , v ) = uR_1 ( u^2 , v )\)</span>,其中<span class="math inline">\(R_1\)</span>是另一个二元有理函数.如果对于<span class="math inline">\(v\)</span>是奇函数则同理.</p></li>
<li><p>当<span class="math inline">\(R ( - u , - v ) = R ( u , v
)\)</span>时,那么<span class="math inline">\(R ( u , v ) = R_1 ( \frac{
u }{ v } , v^2 )\)</span>.</p></li>
</ol>
<p>证明只需要拆做<span class="math inline">\(R ( u , v ) = \frac{ P ( u
, v ) }{ Q ( u , v ) }\)</span>,其中<span class="math inline">\(P ,
Q\)</span>是两个多项式,然后只需简单书写即可证明.</p>
<p>对于(1)形式的有理三角函数,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int R ( \cos x , \sin x ) \text{ d } x \\
= &amp; \int \cos xR ( \cos^2 x , \sin x ) \text{ d } x \\
\\
= &amp; \int R_1 ( 1 - \sin^2 x , \sin x ) \text{ d } ( \sin x ) \\
= &amp; \int R_1 ( 1 - t^2 , t ) \text{ d } t
\end{aligned}
\]</span></p>
<p>对于(2)形式的有理三角函数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int R ( \cos x , \sin x ) \text{ d } x \\
= &amp; \int R_1 ( \cos^2 x , \tan x ) \text{ d } x \\
= &amp; \int R_1 ( \frac{ 1 }{ 1 + \tan^2 x } , \tan x ) \text{ d } x \\
= &amp; \int R_1 ( \frac{ 1 }{ 1 + t^2 } , t ) \frac{ \text{ d } t }{ 1
+ t^2 }
\end{aligned}
\]</span></p>
<p>有了这两种形式后呢?我们注意到任意的有理三角函数都可以表示为以上两种函数之和,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; R ( u , v ) \\
= &amp; \frac{ R ( u , v ) - R ( - u , v ) }{ 2 } \\
+ \frac{ R ( - u , v ) - R ( - u , - v ) }{ 2 } \\
+ \frac{ R ( - u , - v ) + R ( u , v ) }{ 2 }
\end{aligned}
\]</span></p>
<p>或者,令<span class="math inline">\(t = \tan \frac{ x }{ 2
}\)</span>,那么<span class="math inline">\(\sin x = \frac{ 2 t }{ 1 +
t^2 } , \cos x = \frac{ 1 - t^2 }{ 1 + t^2 } , \text{ d } x = 2 \frac{
\text{ d } t }{ 1 + t^2 }\)</span>.</p>
<h5><span id="无理函数的不定积分">无理函数的不定积分</span></h5>
<p>我们考虑以下几类无理函数:</p>
<p>第一类是<span class="math inline">\(R ( x , \sqrt[m]{ \frac{ ax + b
}{ cx + d } } )\)</span>的形式.只需做换元<span class="math inline">\(t^m
= \frac{ a_1 x + b_1 }{ a_2 x + b_2 }\)</span>,立刻得到原式其实就是<span class="math inline">\(R ( \frac{ b_2 t^m - b_1 }{ a_1 - a_2 t^m } , t
)\)</span>,并且<span class="math inline">\(\text{ d }
x\)</span>也可以转化到<span class="math inline">\(\text{ d }
t\)</span>.</p>
<p>第二类是形如<span class="math inline">\(\int x^m ( a + bx^n )^p
\text{ d } x\)</span>,其中<span class="math inline">\(m , n , p \in
\mathbb{ Q }\)</span>.</p>
<p>令<span class="math inline">\(t = x^n\)</span>,上式就变成了<span class="math inline">\(\frac{ 1 }{ n } \int t^{ \frac{ m + 1 }{ n } - 1 }
( a + bt )^p \text{ d } t\)</span>.令<span class="math inline">\(q =
\frac{ m + 1 }{ n } - 1\)</span>.我们只需要做<span class="math inline">\(\frac{ 1 }{ n } \int t^q ( a + bt )^p \text{ d } t
= \frac{ 1 }{ n } \int t^{ p + q } ( \frac{ a + bt }{ t }
)^p\)</span>.事实上,下面三种情况可以积出来:</p>
<ol type="1">
<li><p><span class="math inline">\(p \in \mathbb{ Z }\)</span>.</p></li>
<li><p><span class="math inline">\(q \in \mathbb{ Z }\)</span>.</p></li>
<li><p><span class="math inline">\(p + q \in \mathbb{ Z
}\)</span>.</p></li>
</ol>
<p>其它的都无初等形式.</p>
<p>第三类是形如<span class="math inline">\(R ( x , \sqrt{ ax^2 + bx + c
} )\)</span>,不妨假设<span class="math inline">\(b^2 - 4 ac \ne 0 , a
\ne 0\)</span>.</p>
<ol type="1">
<li><p><span class="math inline">\(b^2 - 4 ac &gt;
0\)</span>,则有两个实根<span class="math inline">\(\alpha &gt;
\beta\)</span>,此时提一下实根就可以知道原式等于<span class="math inline">\(R ( x , ( x - \beta ) \sqrt{ \frac{ a ( x - \alpha
) }{ x - \beta } } )\)</span>,这就能做了.</p></li>
<li><p><span class="math inline">\(b^2 - 4 ac &lt;
0\)</span>,则无实根,不妨假设<span class="math inline">\(a &gt;
0\)</span>.则做<span class="math inline">\(t - \sqrt{ a } x = \sqrt{
ax^2 + bx + c }\)</span>并两边平方就可以反解出<span class="math inline">\(x = \frac{ t^2 - c }{ b + 2 \sqrt{ a } t
}\)</span>,原本的积分就变成了关于<span class="math inline">\(t\)</span>的有理函数的积分.</p></li>
</ol>
<h5><span id="双曲换元">双曲换元</span></h5>
<p>引入双曲三角函数<span class="math inline">\(\sinh ( x ) = \frac{ e^x
- e^{ - x } }{ 2 } , \cosh = \frac{ e^x + e^{ - x } }{ 2
}\)</span>以及<span class="math inline">\(\tanh ( x ) = \frac{ \sinh ( x
) }{ \cosh ( x ) }\)</span>.留意到<span class="math inline">\(\cosh^2 -
\sinh^2 = 1\)</span>.以及:</p>
<ol type="1">
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\sinh ( x ) = \cosh ( x )\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\cosh ( x ) = \sinh ( x )\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\tanh ( x ) = \frac{ 1 }{ \cosh^2 ( x ) } = 1 - \tanh^2 ( x
)\)</span></p></li>
</ol>
<p>应当发现:</p>
<ol type="1">
<li><p><span class="math inline">\(\sinh ( 2 x ) = 2 \sinh ( x ) \cosh (
x )\)</span></p></li>
<li><p><span class="math inline">\(\cosh ( 2 x ) = \cosh^2 ( x ) +
\sinh^2 ( x ) = 2 \cosh^2 ( x ) - 1 = 1 + 2 \sinh^2 ( x
)\)</span></p></li>
</ol>
<p>另外其反函数应当是:</p>
<ol type="1">
<li><p><span class="math inline">\(\text{ arsinh } ( x ) = \ln ( x +
\sqrt{ x^2 + 1 } )\)</span></p></li>
<li><p><span class="math inline">\(\text{ arcosh } ( x ) = \ln ( x +
\sqrt{ x^2 - 1 } )\)</span></p></li>
</ol>
<p>应当发现:</p>
<ol type="1">
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\text{ arsinh } ( x ) = \frac{ 1 }{ \sqrt{ x^2 + 1 } }\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\text{ arcosh } ( x ) = \frac{ 1 }{ \sqrt{ x^2 - 1 } }\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\text{ artanh } ( x ) = \frac{ 1 }{ 1 - x^2 }\)</span></p></li>
</ol>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I = \int \frac{ \text{ d } x }{ \sqrt{
x^2 \pm a^2 } }\)</span>,其中<span class="math inline">\(a &gt;
0\)</span>.</p>
<p>于是<span class="math inline">\(\int \frac{ \text{ d } x }{ \sqrt{
x^2 \pm a^2 } } = \ln | x + \sqrt{ x^2 \pm a^2 } | + C\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I = \int \sqrt{ a^2 - x^2 } \text{ d }
x\)</span>.</p>
<p>考虑三角换元,应当小心符号,这里注意到<span class="math inline">\(x \in
[ - a , a ]\)</span>,因此直接取<span class="math inline">\(x = a \sin
t\)</span>,<span class="math inline">\(t \in [ - \frac{ \pi }{ 2 } ,
\frac{ \pi }{ 2 } ]\)</span>,此时<span class="math inline">\(\cos t \geq
0\)</span>恒成立,则有:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = a^2 \int \cos^2 t \text{ d } t \\
&amp; = a^2 \int \frac{ 1 + \cos ( 2 t ) }{ 2 } \text{ d } t \\
&amp; = \frac{ a^2 t }{ 2 } + \frac{ a^2 }{ 4 } \sin ( 2 t ) + C \\
&amp; = \frac{ 1 }{ 2 } ( x \sqrt{ a^2 - x^2 } + a^2 \arcsin \frac{ x }{
a } ) + C
\end{aligned}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(I = \int \sqrt{ x^2 \pm a^2 } \text{ d
} x\)</span>.</p>
<p>使用双曲换元,先考虑<span class="math inline">\(\int \sqrt{ x^2 + a^2
} \text{ d } x\)</span>的情况,此时换<span class="math inline">\(x = a
\sinh t\)</span>,<span class="math inline">\(\cosh t \geq
0\)</span>,根号是平凡开出的,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = a^2 \int \cosh^2 t \text{ d } t \\
&amp; = a^2 \int \frac{ 1 + \cosh ( 2 t ) }{ 2 } \text{ d } t \\
&amp; = \frac{ a^2 t }{ 2 } + \frac{ a^2 }{ 4 } \sinh ( 2 t ) + C \\
&amp; = \frac{ 1 }{ 2 } ( x \sqrt{ x^2 + a^2 } + a^2 \text{ arsinh }
\frac{ x }{ a } ) + C
\end{aligned}
\]</span></p>
<p>另一个同理,仍然使用双曲换元,结果是<span class="math inline">\(\frac{
1 }{ 2 } ( x \sqrt{ x^2 - a^2 } + a^2 \text{ arcosh } \frac{ x }{ a } )
+ C\)</span></p>
<h5><span id="椭圆积分">椭圆积分</span></h5>
<p>以下是几个常见的无初等形式的积分:</p>
<ol type="1">
<li><p><span class="math inline">\(\int \frac{ e^x }{ x } \text{ d }
x\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \ln x
}\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \sin x }{ x } \text{ d }
x\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \cos x }{ x } \text{ d }
x\)</span>.</p></li>
<li><p><span class="math inline">\(\int e^{ x^2 } \text{ d }
x\)</span>.</p></li>
</ol>
<p>另外还有一类椭圆积分也无初等形式:设<span class="math inline">\(R ( x
, y )\)</span>是二元有理函数,其中<span class="math inline">\(y = \sqrt{
P_3 ( x ) }\)</span>或<span class="math inline">\(\sqrt{ P_4 ( x )
}\)</span>,也即根号下放了个三次或者四次多项式,那么<span class="math inline">\(\int R ( x , y ) \text{ d }
x\)</span>可能很难有初等形式.这样的积分可以被归结为三类椭圆积分.</p>
<p>首先说明<span class="math inline">\(R ( x , \sqrt{ P_3 ( x ) }
)\)</span>可以转化,原因是<span class="math inline">\(P_3 ( x ) =
0\)</span>一定有至少一个实数解,任意取出一个设为<span class="math inline">\(\lambda\)</span>,则<span class="math inline">\(P_3
( x ) = ( x - \lambda ) P_2 ( x )\)</span>,令<span class="math inline">\(t^2 + \lambda = x\)</span>,带入可以转化为<span class="math inline">\(R ( t^2 + \lambda , \sqrt{ P_2 ( t^2 + \lambda ) }
) = R_1 ( t , \sqrt{ P_4 ( t ) }
)\)</span>.这就意味着其实根号下四次多项式是更本质一些的.</p>
<p>而四次多项式可以分解为<span class="math inline">\(P_4 ( x ) = a ( x^2
+ p_1 x + q_1 ) ( x^2 + p_2 x + q_2
)\)</span>.不妨假设其无重根(如果有重根的话,那么根号下就可以开出去一部分,那就可积了),设其四个根(可能有复根)分别为<span class="math inline">\(\alpha_1 , \beta_1 , \alpha_2 ,
\beta_2\)</span>,并且<span class="math inline">\(\alpha_1 ,
\beta_1\)</span>是上述分解中前半部分的根,特别地,如果这是四个实根,则不妨调整它们的顺序使得<span class="math inline">\(\alpha_1 &gt; \beta_1 &gt; \alpha_2 &gt;
\beta_2\)</span>.那么根据韦达定理总有:<span class="math inline">\(p_1 =
- ( \alpha_1 + \beta_1 ) , q_1 = \alpha_1
\beta_1\)</span>,后半部分同理.</p>
<p>我们尝试把这两个式子的一次项都去掉,当<span class="math inline">\(p_1
= p_2\)</span>的时候可以直接一起配方令<span class="math inline">\(x = t
- \frac{ p }{ 2 }\)</span>.当<span class="math inline">\(p_1 \ne
p_2\)</span>的时候,尝试换元用<span class="math inline">\(t\)</span>代替<span class="math inline">\(x\)</span>,不妨设<span class="math inline">\(x =
\frac{ u t + v }{ 1 + t }\)</span>,那么<span class="math inline">\(( x^2
+ p_1 x + q_1 ) = \frac{ P_2 &#39; ( t ) }{ ( 1 + t )^2
}\)</span>.为了让其没有一次项应当解以下方程:</p>
<p><span class="math display">\[
\begin{cases}
2 u v + p_1 ( u + v ) + 2 q_1 = 0 \\
2 u v + p_2 ( u + v ) + 2 q_2 = 0
\end{cases}
\]</span></p>
<p>此时可以解出来<span class="math inline">\(\begin{cases}u + v = -
\frac{ 2 ( q_1 - q_2 ) }{ p_1 - p_2 } \\ u v = \frac{ p_2 q_1 - p_1 q_2
}{ p_1 - p_2 }\end{cases}\)</span>,为了解出<span class="math inline">\(u
, v\)</span>是两个实数,应当检验<span class="math inline">\(( u + v )^2 -
4 uv \geq 0\)</span>是否成立.带入韦达定理发现左边等于<span class="math inline">\(( \alpha_1 - \alpha_2 ) ( \alpha_1 - \beta_2 ) (
\beta_1 - \alpha_2 ) ( \beta_1 - \beta_2 ) &gt;
0\)</span>.原因是如果是四个实根,则根据假设立刻得到.如果存在复根则配对一下复根也可以立刻得到.</p>
<p>总之,在上面的一系列操作后,我们要研究的形式统一成了<span class="math inline">\(R ( t , y = \sqrt{ A ( 1 + m_1 t^2 ) ( 1 + m_2 t^2
) } ) = \frac{ a ( t ) + b ( t ) y }{ c ( t ) + d ( t ) y } = B_1 ( t )
+ B_2 ( t ) y\)</span>,其中<span class="math inline">\(B_1 ( t ) , B_2 (
t )\)</span>都是<span class="math inline">\(t\)</span>的有理函数.前者可以直接积分拆出去,那我们关心的就只剩下后面的<span class="math inline">\(B_2 ( t ) y = \frac{ B_2 ( t ) y }{ y
}\)</span>的部分.</p>
<p>我们之前已经提过可以将一个函数拆为偶函数和奇函数之和,事实上:</p>
<p><span class="math display">\[
R ( t ) = \frac{ R ( t ) + R ( - t ) }{ 2 } + \frac{ R ( t ) - R ( - t )
}{ 2 } = R_1 ( t^2 ) + tR_2 ( t^2 )
\]</span></p>
<p>那么后者立刻可以换元积分,只剩下前者做不动.剩下的形式是:<span class="math inline">\(\int \frac{ R ( t^2 ) }{ \sqrt{ A ( 1 + m_1 t^2 )
( 1 + m_2 t^2 ) } } \text{ d } t\)</span>,其中<span class="math inline">\(A\)</span>可以先扔出去一些,使得<span class="math inline">\(A = \pm
1\)</span>.而且由于被积函数是偶函数,所以还可以不妨设<span class="math inline">\(t \geq
0\)</span>.由于根号下不能变成二次函数(不然就直接做完了),还不妨设<span class="math inline">\(m_1 \ne m_2 , m_1 \ne 0 , m_2 \ne
0\)</span>.下面开始讨论:</p>
<ol type="1">
<li><span class="math inline">\(A = 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = - h_2^2 , h_1 &gt; h_2 &gt;
0\)</span>.</li>
</ol>
<p>此时令<span class="math inline">\(t = \frac{ z }{ h_1
}\)</span>带入化简变形再扔出去点常数得到原式变化为<span class="math inline">\(\int \frac{ R ( z^2 ) }{ \sqrt{ ( 1 - z^2 ) ( 1 -
k^2 z^2 ) } } \text{ d } z\)</span>,其中<span class="math inline">\(k =
\frac{ h_2 }{ h_1 }\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(A = 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = h_2^2 , h_1 &gt; 0 , h_2
&gt; 0\)</span>.</li>
</ol>
<p>此时令<span class="math inline">\(t = \frac{ \sqrt{ 1 - z^2 } }{ h_1
}\)</span>.扔出去一些常数仍然可以化简成(1)的形式,只是<span class="math inline">\(k = \frac{ h_2 }{ \sqrt{ h_1^2 + h_2^2 }
}\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(A = 1 , m_1 = h_1^2 , m_2 = h_2^2 , h_1
&gt; h_2 &gt; 0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t = \frac{ z }{ h_1 \sqrt{ 1 - z^2 }
}\)</span>.扔出去一些常数仍然是(1)的形式,只是<span class="math inline">\(k = \frac{ \sqrt{ h_1^2 - h_2^2 } }{ h_1
}\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(A = - 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = h_2^2 , h_1 &gt; 0 , h_2
&gt; 0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t = \frac{ 1 }{ h_1 \sqrt{ 1 - z^2 }
}\)</span>,还是(1)的形式,只是<span class="math inline">\(k = \frac{ h_1
}{ \sqrt{ h_1^2 + h_2^2 } }\)</span>.</p>
<ol start="5" type="1">
<li><span class="math inline">\(A = - 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = - h_2^2 , h_1 &gt; h_2 &gt;
0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t = \frac{ \sqrt{ 1 - \frac{ h_1^2 -
h^2_2 }{ h_1^2 } z^2 } }{ h_2 }\)</span>,还是(1),只是<span class="math inline">\(k = \frac{ \sqrt{ h_1^2 - h_2^2 } }{ h_1
}\)</span>.</p>
<p>这样就全都转化为了<span class="math inline">\(\int \frac{ R ( z^2 )
}{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } } \text{ d }
z\)</span>的形式了.然后把<span class="math inline">\(R ( z^2
)\)</span>给拆开,那么这个式子就应该是<span class="math inline">\(I_n =
\int \frac{ z^{ 2 n } }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } } \text{ d
} z\)</span>和<span class="math inline">\(H_m = \int \frac{ \text{ d } z
}{ ( z^2 - a )^m \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) }
}\)</span>的线性组合,注意这里系数有可能是复数.</p>
<p>此时注意到</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( z^{ 2 n - 3 } \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } ) &#39; \\
= &amp; ( 2 n - 3 ) z^{ 2 n - 4 } \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } +
z^{ 2 n - 3 } \frac{ 2 k^2 z^3 - ( k^2 + 1 ) z }{ \sqrt{ ( 1 - z^2 ) ( 1
- k^2 z^2 ) } } \\
= &amp; \frac{ ( 2 n - 3 ) z^{ 2 n - 4 }{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) }
+ z^{ 2 n - 3 } ( 2 k^2 z^3 - ( k^2 + 1 ) z ) }{ \sqrt{ ( 1 - z^2 ) ( 1
- k^2 z^2 ) } } \\
= &amp; \frac{ ( 2 n - 1 ) k^2 z^{ 2 n } - ( 2 n - 2 ) ( k^2 + 1 ) z^{ 2
n - 2 } + ( 2 n - 3 ) z^{ 2 n - 4 } }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2
) } }
\end{aligned}
\]</span></p>
<p>两边积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( 2 n - 1 ) k^2 I_n - ( 2 n - 2 ) ( k^2 + 1 ) I_{ n - 1 } + ( 2 n
- 3 ) I_{ n - 2 } \\
= &amp; z^{ 2 n - 3 } \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) }
\end{aligned}
\]</span></p>
<p>上述只要<span class="math inline">\(n\)</span>是整数就行,甚至不需要<span class="math inline">\(n\)</span>是正的.所以所有的<span class="math inline">\(I_n\)</span>,包括负整数<span class="math inline">\(n\)</span>,都可以被<span class="math inline">\(I_0
, I_1\)</span>表示.</p>
<p>接下来看<span class="math inline">\(H_m\)</span>,当<span class="math inline">\(a = 0\)</span>的时候无非是<span class="math inline">\(H_m = I_{ - m }\)</span>,</p>
<p>接下来注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; ( \frac{ z }{ ( z^2 - a )^{ m - 1 } } \sqrt{ ( 1 - z^2 ) ( 1 - k^2
z^2 ) } ) &#39; \\
= &amp; \frac{ ( 2 - 2 m ) z^2 + z^2 - a }{ ( z^2 - a )^m } \sqrt{ ( 1 -
z^2 ) ( 1 - k^2 z^2 ) } \\
+ \frac{ 2 k^2 z^4 - ( k^2 + 1 ) z^2 }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2
) } } \frac{ 1 }{ ( z^2 - a )^{ m - 1 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(C = \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 )
}\)</span>,<span class="math inline">\(W = z^2 - a\)</span>,那么<span class="math inline">\(C^2 = k^2 ( W + a )^2 - ( k^2 + 1 ) ( W + a ) +
1\)</span>.上式化简为:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; = \frac{ ( 2 - 2 m ) ( W + a ) C^2 }{ W^m C } + \frac{ C^2 + 2 k^2
( W + a )^2 - ( k^2 + 1 ) ( W + a ) }{ W^{ m - 1 } C } \\
&amp; = \frac{ ( 2 - 2 m ) ( W + a ) ( k^2 ( W + a )^2 - ( k^2 + 1 ) ( W
+ a ) + 1 ) }{ W^m C } \\
+ \frac{ 3 k^2 ( W + a )^2 - 2 ( k^2 + 1 ) ( W + a ) + 1 }{ W^{ m - 1 }
C }
\end{aligned}
\]</span></p>
<p>接下来是繁复的化简,然后两边积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ z }{ ( z^2 - a )^{ m - 1 } } \sqrt{ ( 1 - z^2 ) ( 1 - k^2
z^2 ) } \\
= &amp; ( 2 m - 2 ) ( - a + ( k^2 + 1 ) a^2 - k^2 a^3 ) H_m \\
- ( 2 m - 3 ) ( 1 - 2 a ( k^2 + 1 ) + 3 k^2 a^2 ) H_{ m - 1 } \\
+ ( 2 m - 4 ) ( k^2 + 1 - 3 k^2 a ) H_{ m - 2 } \\
- ( 2 m - 5 ) k^2 H_{ m - 3 }
\end{aligned}
\]</span></p>
<p>而注意到<span class="math inline">\(H_0 = I_0 , H_{ - 1 } = I_1 -
aI_0\)</span>.</p>
<p>综上,所有的椭圆积分都可以由<span class="math inline">\(I_0 , I_1 ,
H_1\)</span>表示.也就是椭圆积分可以转化为以下三种积分:</p>
<ol type="1">
<li><p><span class="math inline">\(\int \frac{ \text{ d } z }{ \sqrt{ (
1 - z^2 ) ( 1 - k^2 z^2 ) } }\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ z^2 \text{ d } z }{
\sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } }\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } z }{ ( 1 +
hz^2 ) \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } }\)</span>,其中<span class="math inline">\(h\)</span>可以是复数.</p></li>
</ol>
<p>有意思的是如果令<span class="math inline">\(z = \sin
\varphi\)</span>,<span class="math inline">\(\text{ d } z = \sqrt{ 1 -
z^2 } \text{ d }
\varphi\)</span>,这样形式就好看了很多.椭圆积分可以用以下的优美形式表示:</p>
<ol type="1">
<li><p><span class="math inline">\(E ( k , \varphi ) = \int \frac{
\text{ d } \varphi }{ \sqrt{ 1 - k^2 \sin^2 \varphi }
}\)</span>.</p></li>
<li><p><span class="math inline">\(F ( k , \varphi ) = \int \sqrt{ 1 -
k^2 \sin^2 \varphi } \ \text{ d } \varphi\)</span>.</p></li>
<li><p><span class="math inline">\(\Pi ( h , k , \varphi ) = \int \frac{
\text{ d } \varphi }{ ( 1 + h \sin^2 \varphi ) \sqrt{ 1 - k^2 \sin^2
\varphi } }\)</span>,其中<span class="math inline">\(h\)</span>可以是复数.</p></li>
</ol>
<p>其中:</p>
<p><span class="math display">\[
\begin{aligned}
\int \frac{ z^2 \text{ d } z }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } }
&amp; = \int \frac{ \sin^2 \varphi \text{ d } \varphi }{ \sqrt{ 1 - k^2
\sin^2 \varphi } } \\
&amp; = \int ( \frac{ 1 }{ k^2 \sqrt{ 1 - k^2 \sin^2 \varphi } } \text{
) } - \frac{ 1 - k^2 \sin^2 \varphi }{ k^2 \sqrt{ 1 - k^2 \sin^2 \varphi
} } \text{ ) } d \varphi \\
&amp; = \frac{ E ( k , \varphi ) }{ k^2 } - \frac{ F ( k , \varphi ) }{
k^2 }
\end{aligned}
\]</span></p>
<h4><span id="黎曼积分">黎曼积分</span></h4>
<p>设<span class="math inline">\(f ( x )\)</span>是定义在<span class="math inline">\([ a , b ]\)</span>上的函数,对于区间<span class="math inline">\([ a , b ]\)</span>插入分点<span class="math inline">\(x_i ( i = 0 , 1 , \cdots , n )\)</span>,且有<span class="math inline">\(a = x_0 &lt; x_1 &lt; \cdots &lt; x_n =
b\)</span>,我们称之为对区间<span class="math inline">\([ a , b
]\)</span>的一种<strong>分割</strong>,并记为<span class="math inline">\(\Delta\)</span>.又记<span class="math inline">\(\Delta x_i = x_i - x_{ i - 1 } , i \in [ 1 , n
]\)</span>,<span class="math inline">\(\lambda ( \Delta ) = \max \{
\Delta x_i \mid i \in [ 1 , n ] \}\)</span>,并定义黎曼和<span class="math inline">\(S_\Delta = \sum_{ i = 1 }^n f ( \xi_i ) \Delta
x_i\)</span>.</p>
<p>若存在实数<span class="math inline">\(J\)</span>,对<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt;
0\)</span>,对于任意分划,只要<span class="math inline">\(\lambda ( \Delta
) &lt; \delta\)</span>,都有<span class="math inline">\(| S_\Delta - J |
&lt; \epsilon \\\)</span>,则称<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\([ a , b
]\)</span>上<strong>黎曼可积</strong>,这个<span class="math inline">\(J\)</span>为<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\([ a , b
]\)</span>上的<strong>定积分</strong>,记作<span class="math inline">\(\int_{ a }^b f ( x ) \text{ d } x
\\\)</span>.容易见到定积分唯一,证明无非也是拿<span class="math inline">\(\epsilon\)</span>去卡.</p>
<p>对于<span class="math inline">\([ a , b
]\)</span>上的连续函数,定积分实际上就是其与<span class="math inline">\(f
( x )\)</span>围成面积的代数和.</p>
<p>由此可以顺便定义<strong>达布上下和</strong>,即令<span class="math inline">\(m_i = \inf_{ [ x_{ i - 1 } , x_i ] } f ( x ) , M_i
= \sup_{ [ x_{ i - 1 } , x_i ] } f ( x
)\)</span>,并定义<strong>振幅</strong><span class="math inline">\(w_i =
M_i - m_i\)</span>,特别地定义<span class="math inline">\(M = \sup ( M_i
) , m = \inf ( m_i )\)</span>.定义<span class="math inline">\(\overline{
S }_\Delta = \sum M_i \Delta x_i , \underline{ S }_{ \Delta } = \sum m_i
\Delta x_i\)</span>.</p>
<p>并在此基础上定义上下积分,上积分<span class="math inline">\(\overline{
\int_a^b } f ( x ) \text{ d } x = \inf \overline{ S }_\Delta ,
\underline{ \int_a^b } f ( x ) \text{ d } x = \sup \underline{ S
}_\Delta\)</span>.上下积分显然都是存在的,我们会在后面证明黎曼可积等价于上下积分相等.</p>
<p>为了方便,我们约定:</p>
<ol type="1">
<li><p><span class="math inline">\(a = b\)</span>,<span class="math inline">\(\int_a^b f ( x ) \text{ d } x =
0\)</span>.</p></li>
<li><p><span class="math inline">\(a &gt; b\)</span>,<span class="math inline">\(\int_a^b f ( x ) \text{ d } x = - \int_b^a f ( x )
\text{ d } x\)</span>.</p></li>
</ol>
<p>下列性质应当是成立的:</p>
<ol type="1">
<li><p>(必要条件)如果一个函数黎曼可积,则它在该闭区间上有界.</p></li>
<li><p>对于任意分划任取<span class="math inline">\(\xi\)</span>,都有<span class="math inline">\(\underline{ S }_\Delta \leq S_\Delta ( \xi ) \leq
\overline{ S }_\Delta\)</span>.</p></li>
<li><p><span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists \xi_1 ,
\xi_2\)</span>,使得<span class="math inline">\(\underline{ S }_\Delta -
\epsilon \leq S_\Delta ( \xi_1 )\)</span>,<span class="math inline">\(\overline{ S }_\Delta + \epsilon \geq S_\Delta (
\xi_2 )\)</span>.</p></li>
</ol>
<p>再定义所谓加细:如果<span class="math inline">\(\Delta_1 \subseteq
\Delta_2\)</span>,那么称<span class="math inline">\(\Delta_2\)</span>是<span class="math inline">\(\Delta_1\)</span>的加细.此时应当有<span class="math inline">\(\overline{ S }_{ \Delta_1 } \geq \overline{ S }_{
\Delta_2 } , \underline{ S }_{ \Delta_1 } \leq \underline{ S }_{
\Delta_2 }\)</span>.另外容易注意到如果<span class="math inline">\(|
\Delta_2 \setminus \Delta_1 | = k\)</span>,那么<span class="math inline">\(0 \leq \overline{ S }_{ \Delta_1 } - \overline{ S
}_{ \Delta_2 } \leq k \lambda ( \Delta_1 ) ( M - m
)\)</span>,原因是考虑把这些新的断点一个一个加上去,每次加一个会新断开原本的断点,此时最多造成<span class="math inline">\(( M - m ) \Delta x \leq ( M - m ) \lambda (
\Delta_1 )\)</span>的差.注意到此时这些东西似乎全都可以被限制住.</p>
<p>这同样给出了原因:为什么我们会定义上下积分呢?因为随着分点的加多,也就是随着划分的加细,达布上下和会分别单调递减或递增,这样就应当存在一个极限,然而问题在于我们难以在划分上定义序,这样就少了某种极限的方式.然而,我们试图绕开来找到一种确定的能探到极限的方式.</p>
<p>另外的结论是对于任意两个分划<span class="math inline">\(\Delta_1 ,
\Delta_2\)</span>,总有<span class="math inline">\(\underline{ S }_{
\Delta_1 } \leq \overline{ S }_{ \Delta_2 }\)</span>.原因是<span class="math inline">\(\Delta = \Delta_1 \cup
\Delta_2\)</span>,立刻见到<span class="math inline">\(\underline{ S }_{
\Delta_1 } \leq \underline{ S }_{ \Delta } \leq \overline{ S }_\Delta
\leq \overline{ S }_{ \Delta_2 }\)</span>.这意味着<span class="math inline">\(\overline{ \int } f \geq \underline{ \int }
f\)</span>.</p>
<p>接下来证明定积分中的<strong>达布定理</strong>,也就是<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt;
0\)</span>,<span class="math inline">\(\forall \Delta , \lambda ( \Delta
) &lt; \delta\)</span>的时候,<span class="math inline">\(0 \leq
\overline{ S }_\Delta - \overline{ \int_a^b } f ( x ) \text{ d } x \leq
\epsilon\)</span>.换言之<span class="math inline">\(\lim_{ \lambda (
\Delta ) \to 0 } \overline{ S }_{ \Delta } = \overline{ \int_a^b } f ( x
) \text{ d } x\)</span>,当然下积分也是同理的.</p>
<p>这个的证明考虑先用上积分的定义,应当存在一个<span class="math inline">\(\Delta &#39;\)</span>,满足<span class="math inline">\(0 \leq \overline{ S }_{ \Delta &#39; } -
\overline{ \int_a^b } f ( x ) \text{ d } x \leq \frac{ \epsilon }{ 2
}\)</span>.不妨设<span class="math inline">\(| \Delta &#39; | =
n_0\)</span>,接下来取<span class="math inline">\(\delta &lt; \frac{
\epsilon }{ 2 n_0 ( M - m ) }\)</span>,那么接下来对于<span class="math inline">\(\forall \Delta , \lambda ( \Delta ) &lt;
\delta\)</span>的时候,取<span class="math inline">\(\Delta^* = \Delta
&#39; \cup \Delta\)</span>,根据上面我们证明的步骤,这里最多会多<span class="math inline">\(n_0\)</span>个断点,自然得知<span class="math inline">\(\overline{ S }_{ \Delta } - \overline{ S }_{
\Delta^* } \leq n_0 \lambda ( \Delta ) ( M - m ) &lt; \frac{ \epsilon }{
2 }\)</span>.</p>
<p>这样的话就可以注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \overline{ S }_\Delta - \overline{ \int_a^b } f ( x ) \text{ d } x
\\
= &amp; ( \overline{ S }_{ \Delta &#39; } - \overline{ \int_a^b } f ( x
) \text{ d } x ) - ( \overline{ S }_{ \Delta &#39; } - \overline{ S }_{
\Delta } ) \\
&lt; &amp; \frac{ \epsilon }{ 2 } - ( \overline{ S }_{ \Delta^* } -
\overline{ S }_\Delta ) &lt; \epsilon
\end{aligned}
\]</span></p>
<p>这里可以证明原函数可积的充分必要条件是上下积分相等.</p>
<p>首先证明充分性:当上下积分相等的时候,设其为<span class="math inline">\(J\)</span>,取足够小的<span class="math inline">\(\epsilon\)</span>,由上知道<span class="math inline">\(\exists \delta &gt; 0\)</span>,使得<span class="math inline">\(J - \epsilon &lt; \underline{ S }_\Delta \leq
S_\Delta ( \xi ) \leq \overline{ S }_\Delta &lt; J +
\epsilon\)</span>,夹逼一下立刻知道其满足.</p>
<p>然后证明必要性:当原函数可积分的时候,只要分点足够密,应当有<span class="math inline">\(J - \epsilon &lt; \underline{ S }_\Delta \leq
\underline{ \int } f ( x ) \text{ d } x \leq \overline{ \int } f ( x )
\text{ d } x \leq \overline{ S }_\Delta &lt; J + \epsilon\)</span>.</p>
<p>而由于我们可以见到上和与下和应当是错开来的,而如果它们中间能接上自然意味着上下积分相等.因此推论为:如果<span class="math inline">\(f\)</span>在闭区间上有界并且<span class="math inline">\(\forall \epsilon , \exists
\Delta\)</span>使得<span class="math inline">\(0 \leq \overline{ S
}_\Delta - \underline{ S }_\Delta \leq \epsilon\)</span>,则<span class="math inline">\(f\)</span>可积.我们最初拿到的那个定义也可以这么改:只需要存在一个分划而不需要使得任意分划都这么满足.方式就是用我们已经找到的这个去并我们想要限制的那个,然后把限制延后一点使得这些全被限制住.</p>
<p>由上述可以证明闭区间上的连续函数一定是闭区间上的可积函数.原因是闭区间上的连续函数一定是一致连续函数,那么对于一个<span class="math inline">\(\epsilon\)</span>,可以找到一个<span class="math inline">\(\delta\)</span>控制住区间长度,使得极差<span class="math inline">\(&lt; \epsilon\)</span>.此时直接找一个<span class="math inline">\(\Delta\)</span>,注意到<span class="math inline">\(\overline{ S } - \underline{ S } = \sum ( M_i -
m_i ) \Delta x_i \leq \sum \epsilon \Delta x \leq ( b - a )
\epsilon\)</span>,只需取<span class="math inline">\(\epsilon \to
0\)</span>就可以搞定.</p>
<p>还可以证明如果<span class="math inline">\(f\)</span>在闭区间上有界并且只有有限个间断点,那么<span class="math inline">\(f\)</span>可积.原因也很简单,只需要拿足够小的区间把这有限个间断点盖住,然后外面继续如上操作,间断点处尽可能缩小区间长度来取出其影响.</p>
<p>还可以证明单调函数一定可积,原因是<span class="math inline">\(\overline{ S } - \underline{ S } \leq \delta ( f (
b ) - f ( a ) ) \to 0\)</span>.</p>
<h5><span id="可积性与连续性的关系勒贝格定理">可积性与连续性的关系(勒贝格定理)</span></h5>
<p>我们还可以进一步探索黎曼可积和连续性的关系,例如,我们可以证明:<span class="math inline">\(\forall f \in R [ a , b ] , \forall \epsilon &gt;
0 , \exists g \in C [ a , b ] \int_a^b | f ( x ) - g ( x ) | \text{ d }
x &lt; \epsilon\)</span>.</p>
<p>如何证明呢?感觉上只需要用分段线性函数去逼近一下就可以了对吧.所以我们考虑对于划分<span class="math inline">\(\Delta\)</span>,直接把所有的<span class="math inline">\(( x_i , f ( x_i )
)\)</span>连起来形成一个分段线性函数.然后观察此时的<span class="math inline">\(| f - g |\)</span>,不妨分段考虑,对于<span class="math inline">\(\int_{ x_{ i - 1 } }^{ x_i } ( f - g ) ( x )
\text{ d } x \leq ( M_i - m_i ) \Delta
x_i\)</span>,而后者求和之后实际上就是<span class="math inline">\(\overline{ S } - \underline{ S }\)</span>,当<span class="math inline">\(f\)</span>可积的时候这个当然会趋近于<span class="math inline">\(0\)</span>.</p>
<p>我们还可以证明<span class="math inline">\(f \in R [ a , b
]\)</span>的连续点在<span class="math inline">\([ a , b
]\)</span>上稠密,只需要证明<span class="math inline">\(\forall [ \alpha
, \beta ] \in R [ a , b ] , \alpha &lt; \beta\)</span>,<span class="math inline">\([ \alpha , \beta
]\)</span>这个区间内存在连续点即可.考虑定义一点处的振幅<span class="math inline">\(w_{ f } ( x_0 ) = \lim_{ \delta \to + 0 } w_f (
x_0 - \delta , x_0 + \delta )\)</span>,这个随着<span class="math inline">\(\delta\)</span>缩小当然应当是单调不增的,因此一定有非负极限(但可能是无穷大).我们注意到<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处连续的充要条件是<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处的振幅为<span class="math inline">\(0\)</span>.必要性和充分性都容易证明.</p>
<p>我们考虑用区间套来找到这个连续点,考虑对于<span class="math inline">\([ \alpha_0 , \beta_0 ] \in [ a , b
]\)</span>,取分划<span class="math inline">\(\Delta_0\)</span>使得<span class="math inline">\(\sum w_i \Delta x_i &lt; \frac{ 1 }{ 2 } ( \beta_0
- \alpha_0 )\)</span>,并且加细使得<span class="math inline">\(\lambda (
\Delta_0 ) &lt; \frac{ 1 }{ 2 } ( \beta_0 - \alpha_0
)\)</span>,注意这里的两个<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>其实用处不同,前者是为了让<span class="math inline">\(w_i\)</span>足够小,后者是为了让区间长度足够小.此时考虑由于<span class="math inline">\(\sum \Delta x_i = \beta_0 -
\alpha_0\)</span>,所以一定存在一个<span class="math inline">\(w_i &lt;
\frac{ 1 }{ 2 }\)</span>,拿出这个区间作为<span class="math inline">\([
\alpha_1 , \beta_1 ]\)</span>,则区间长度至少折半,并且只需在上述对<span class="math inline">\([ \alpha_n , \beta_n ]\)</span>时取<span class="math inline">\(\sum w_i \Delta x_i &lt; \frac{ 1 }{ 2^{ n + 1 } }
( \beta_0 - \alpha_0 )\)</span>就可以使得<span class="math inline">\(w_i\)</span>也趋近于<span class="math inline">\(0\)</span>,这样就能用区间套找到一个点使得它是连续点.</p>
<p>事实上可以证明一个函数黎曼可积的充分必要条件是其有界并且几乎处处连续.</p>
<p>为了方便不妨把<span class="math inline">\(f\)</span>延拓到整个实轴,令<span class="math inline">\(f ( x ) = \begin{cases}f ( a ) &amp; x \leq a \\ f
( b ) &amp; x \geq b \\ f ( x ) &amp; \text{ otherwise
}\end{cases}\)</span>.</p>
<p>下面定义<span class="math inline">\(E_r = \{ x_0 \mid w_f ( x_0 )
\geq \frac{ 1 }{ r }
\}\)</span>.我们考虑证明其是闭集,也就是证明其补集<span class="math inline">\(E_r^c = \{ x_0 \in ( a , b ) \mid w_f ( x_0 ) &lt;
\frac{ 1 }{ r } \}\)</span>是开集.如果<span class="math inline">\(x_0
\in E_r^c\)</span>,注意到此时<span class="math inline">\(\exists \delta
&gt; 0 , w_f ( x_0 - \delta , x_0 + \delta ) &lt; \frac{ 1 }{ r
}\)</span>,那么这必然意味着<span class="math inline">\(x_0\)</span>邻域中的点的振幅也会<span class="math inline">\(&lt; \frac{ 1 }{ r
}\)</span>,这当然意味着其是开集.</p>
<p>令<span class="math inline">\(D\)</span>是<span class="math inline">\(f\)</span>的间断点集,容易见到<span class="math inline">\(D = \bigcup_{ n = 1 }^{ \infty }
E_n\)</span>,下面只需要证明每个<span class="math inline">\(E_n\)</span>都是零测集即可.</p>
<p>先证明必要性:当<span class="math inline">\(f \in R [ a , b
]\)</span>时,则<span class="math inline">\(f\)</span>有界,现在对于固定的<span class="math inline">\(m\)</span>,尝试证明<span class="math inline">\(E_m\)</span>是零测的,由达布定理,<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,<span class="math inline">\(\exists \Delta\)</span>,使得<span class="math inline">\(\sum w_i \Delta x_i = \overline{ S }_\Delta -
\underline{ S }_\Delta &lt; \epsilon\)</span>.</p>
<p>观察前者,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\epsilon &amp; &gt; \sum w_i \Delta x_i = \overline{ S }_\Delta -
\underline{ S }_\Delta \\
&amp; = \sum_{ E_m \cap ( x_{ k - 1 } , x_k ) \ne \emptyset } w_k \Delta
x_k + \sum_{ E_m \cap ( x_{ k - 1 } , x_k ) = \emptyset } w_k \Delta x_k
\\
&amp; \geq \frac{ 1 }{ m } \sum_{ E_m \cap ( x_{ k - 1 } , x_k ) \ne
\emptyset } \Delta x_k
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(m^* ( E_m ) \leq \sum_{ E_m \cap (
x_{ k - 1 } , x_k ) \ne \emptyset } \Delta x_k &lt; m
\epsilon\)</span>,由于<span class="math inline">\(m\)</span>一开始就固定,<span class="math inline">\(\epsilon\)</span>可以尽量小,所以这意味着<span class="math inline">\(E_m\)</span>是零测集.必要性得证.</p>
<p>再证明充分性:当每一个<span class="math inline">\(E_m\)</span>都是零测集的时候,<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,取<span class="math inline">\(r \in N_+ , r &gt; \frac{ 1 }{ \epsilon
}\)</span>.此时见到<span class="math inline">\(E_{ r
}^c\)</span>是开集,那它可以写成若干两两不交开区间的并,不妨记作<span class="math inline">\(E_r^c = \bigcup_{ k = 1 }^{ \infty }
T_k\)</span>.由于此时<span class="math inline">\(E_m\)</span>是零测集,这意味着<span class="math inline">\(\sum | T_k | = b -
a\)</span>.接下来可以取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\sum_1^n
| T_k | &gt; b - a - \frac{ \epsilon }{ 2 }\)</span>,接下来取<span class="math inline">\(T_k\)</span>的闭子区间<span class="math inline">\(J_k\)</span>,使得<span class="math inline">\(\sum_1^n | J_k | &gt; b - a -
\epsilon\)</span>.这里为什么要把开区间再进一步缩成闭区间呢?原因是你这里如果直接用开区间构造分划可能会把端点处给包进去,因此我们不得不设其端点处的一部分值拿到闭区间,这样那些振幅较大的就被舍弃了.</p>
<p>接下来考虑由于每个点<span class="math inline">\(x_0 \in
J_k\)</span>的<span class="math inline">\(w_f ( x_0 ) &lt; \frac{ 1 }{ r
} &lt; \epsilon\)</span>,必定有其一个小邻域<span class="math inline">\((
x_0 - \delta , x_0 + \delta )\)</span>满足整个邻域的振幅<span class="math inline">\(&lt;
\epsilon\)</span>,用有限覆盖定理拿出一个开覆盖,然后缩掉这些开覆盖的区间就能拿到一个<span class="math inline">\(J_k\)</span>的分划(或者干脆将这些开区间的端点和<span class="math inline">\(J_k\)</span>的端点直接当作一个分划),把这些分划全都并起来就得到了一个划分<span class="math inline">\(\Delta\)</span>.</p>
<p>此时观察这个划分,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \overline{ S }_\Delta - \underline{ S }_\Delta \\
= &amp; \sum w_k \Delta x_k \\
= &amp; \sum_{ [ x_{ k - 1 } , x_k ] \subseteq \bigcup J_i } w_k \Delta
x_k + \sum_{ [ x_{ k - 1 } , x_k ] \subsetneq \bigcup J_i } w_k \Delta
x_k \\
&lt; &amp; \epsilon ( b - a ) + ( M - m ) \epsilon
\end{aligned}
\]</span></p>
<p>这样就可以使其任意小.</p>
<p>上述证明同样声明了:黎曼可积的充要条件是震荡区间超过某个值的区间长度之和随着细分的增加应当尽可能小.</p>
<p>上述结论立刻能见到比如黎曼函数是黎曼可积的,因为其间断点集就是有理点集,就是零测集.</p>
<h5><span id="可积函数的简单性质">可积函数的简单性质</span></h5>
<p>不妨设<span class="math inline">\(f , g \in R [ a , b
]\)</span>,则:</p>
<ol type="1">
<li><p><span class="math inline">\(m ( b - a ) \leq \int_a^b f ( x )
\text{ d } x \leq M ( b - a )\)</span>.</p></li>
<li><p><span class="math inline">\(f \geq 0\)</span>则<span class="math inline">\(\int_a^b f ( x ) \text{ d } x \geq
0\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ a }^b ( f \pm g ) \text{ d } x
= \int_a^b f \text{ d } x \pm \int_a^b g \text{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ a }^b Cf \text{ d } x = C
\int_a^b f \text{ d } x\)</span>.</p></li>
<li><p>(保序性)<span class="math inline">\(f \geq g\)</span>则<span class="math inline">\(\int_a^b f \text{ d } x \geq \int_a^b g \text{ d }
x\)</span>.事实上只要<span class="math inline">\(f \geq
g\)</span>在一个稠密子集上成立即可.</p></li>
<li><p>如果<span class="math inline">\(c \in [ a , b
]\)</span>,那么此时<span class="math inline">\(f \in R [ a , c ] , f \in
R [ c , b ]\)</span>,并且<span class="math inline">\(\int_a^b f \text{ d
} x = \int_a^c f \text{ d } x + \int_c^b f \text{ d }
x\)</span>.</p></li>
<li><p>如果<span class="math inline">\(g\)</span>是连续函数,那么<span class="math inline">\(g ( f ( x ) ) \in R [ a , b ]\)</span>.</p></li>
<li><p><span class="math inline">\(| f | \in R [ a , b
]\)</span>,并且<span class="math inline">\(| \int_a^b f ( x ) \text{ d }
x | \leq \int_a^b | f ( x ) | \text{ d } x\)</span>.</p></li>
<li><p>如果除了一个有限的点集以外,<span class="math inline">\(g =
f\)</span>,则<span class="math inline">\(g \in R [ a , b
]\)</span>并且<span class="math inline">\(\int_a^b g \text{ d } x =
\int_a^b f \text{ d } x\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f \geq 0 , \int_a^b f \text{ d }
x = 0\)</span>,那么<span class="math inline">\(f\)</span>在其连续点集合上恒等于<span class="math inline">\(0\)</span>.</p></li>
</ol>
<p>(1)(2)是显然的,(3)(4)(5)只需将积分看作黎曼和的极限,(6)的话考虑在<span class="math inline">\([ a , b
]\)</span>上间断点集都是零测的了,那么其子集<span class="math inline">\([
a , c ] , [ c , b ]\)</span>上的间断点集当然也是零测集.</p>
<p>(7)的话考虑一个几乎处处连续的函数在外面套一层连续函数当然也是几乎处处连续的.</p>
<p>(8)的话考虑绝对值函数是连续函数,然后注意到<span class="math inline">\(- | f ( x ) | \leq f ( x ) \leq | f ( x )
|\)</span>使用保序性就可以了.</p>
<p>(9)的证明是简单的.但是为什么是有限点集而不是零测集呢?因为如果是无限个点,那么它们不仅会影响自己的连续性,还会影响旁边点的连续性,例如迪利克雷函数.这里可以看出来黎曼函数是有其限制性的,推广到勒贝格积分后会消除这个问题.</p>
<p>(10)的话只需考虑反证法,对于一个连续点<span class="math inline">\(x_0\)</span>,如果<span class="math inline">\(f (
x_0 ) &gt; 0\)</span>,那么周围应当有一个小邻域也大于<span class="math inline">\(0\)</span>,或者干脆用一致连续性取<span class="math inline">\(&gt; \frac{ f ( x ) }{ 2
}\)</span>的一个小邻域,这样就反证完了.</p>
<h5><span id="广义原函数">广义原函数</span></h5>
<p>对于<span class="math inline">\(f ( x ) : I \to \mathbb{ R
}\)</span>,称<span class="math inline">\(F ( x
)\)</span>为其<strong>广义原函数</strong>,若<span class="math inline">\(\forall c , d \in I , c &lt; d\)</span>满足<span class="math inline">\(\frac{ F ( d ) - F ( c ) }{ d - c } \in [ \inf_{ [
c , d ] } f ( x ) , \sup_{ [ c , d ] } f ( x )
]\)</span>.容易见到原函数一定是广义原函数,原因是拉格朗日中值定理.</p>
<p>应当容易注意到以下命题:</p>
<ol type="1">
<li><p>局部有界函数的广义原函数是局部李氏连续的,故几乎处处有导数.</p></li>
<li><p><span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续,<span class="math inline">\(F (
x )\)</span>是<span class="math inline">\(f ( x
)\)</span>的广义原函数,则<span class="math inline">\(F &#39; ( x_0
)\)</span>存在并且恰好等于<span class="math inline">\(f ( x_0
)\)</span>.</p></li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的证明的话,考虑<span class="math inline">\(| \frac{ F ( x ) - F (
x_0 ) }{ x - x_0 } - f ( x_0 ) | \leq w_f [ x_0 , x ]\)</span>,由于<span class="math inline">\(f ( x_0 )\)</span>连续,那么此时其振幅<span class="math inline">\(w_f [ x_0 , x ]\)</span>在<span class="math inline">\(x \to x_0\)</span>时应当趋近于<span class="math inline">\(0\)</span>,使用夹逼定理,于是证毕.</p>
<h5><span id="牛顿-莱布尼茨公式微积分基本定理">牛顿-莱布尼茨公式(微积分基本定理)</span></h5>
<p>先证明一个引理:如果<span class="math inline">\(f ( x ) \in [ a , b
]\)</span>,<span class="math inline">\(F ( x
)\)</span>是其广义原函数,那么<span class="math inline">\(\underline{
\int_a^b } f ( x ) \text{ d } x \leq F ( b ) - F ( a ) \leq \overline{
\int_a^b } f ( x ) \text{ d } x\)</span>.</p>
<p>证明的话,只需证明对于任意分划<span class="math inline">\(\Delta\)</span>都有<span class="math inline">\(\underline{ S }_\Delta ( f ) \leq F ( b ) - F ( a
) \leq \overline{ S }_\Delta f ( x )\)</span>.而注意到<span class="math inline">\(F ( b ) - F ( a ) = \sum F ( x_i ) - F ( x_{ i - 1
} ) = \sum \frac{ F ( x_i ) - F ( x_{ i - 1 } ) }{ x_i - x_{ i - 1 } }
\Delta x_i\)</span>.而根据广义原函数的定义,<span class="math inline">\(m_i \leq \frac{ F ( x_i ) - F ( x_{ i - 1 } ) }{
x_i - x_{ i - 1 } } \leq M_i\)</span>,立刻证毕.</p>
<p>由此显然证明了牛顿-莱布尼茨公式(NL公式):设<span class="math inline">\(f ( x ) \in R [ a , b
]\)</span>,并且能找到其一个广义原函数<span class="math inline">\(F ( x
)\)</span>,则<span class="math inline">\(F ( b ) - F ( a ) = \int_a^b f
( x ) \text{ d } x\)</span>.</p>
<p>接下来声明一个定理:如果一个函数<span class="math inline">\(f ( x )
\in R [ a , b
]\)</span>,它就存在广义原函数,而且不同的广义原函数最多相差一个常数.</p>
<p>先证明存在性,我们注意到变限积分<span class="math inline">\(F ( x ) =
\int_a^x f ( t ) \text{ d } t\)</span>显然是<span class="math inline">\(f ( x
)\)</span>的广义原函数,而且它是处处连续的,只需套用定义就可以证明.</p>
<p>再证唯一性,设<span class="math inline">\(F_1 ( x ) , F_2 ( x
)\)</span>都是<span class="math inline">\(f ( x
)\)</span>的广义原函数.根据LN公式,有<span class="math inline">\(F_1 ( x
) - F_1 ( a ) = \int_{ a }^x f ( t ) \text{ d } t = F_2 ( x ) - F_2 ( a
)\)</span>,立刻有<span class="math inline">\(F_1 ( x ) - F_2 ( x ) = F_1
( a ) - F_2 ( a ) = C\)</span>.</p>
<p>此时回忆到<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续可以推出<span class="math inline">\(F ( x
)\)</span>可导,那么反过来是否成立呢?考虑以下经典反例:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; = \begin{cases}
0 &amp; x = 0 \\
x^2 \sin \frac{ 1 }{ x } &amp; \text{ otherwise }
\end{cases} \\
f ( x ) &amp; = F &#39; ( x ) = \begin{cases}
0 &amp; x = 0 \\
2 x \sin \frac{ 1 }{ x } - \cos \frac{ 1 }{ x } &amp; \text{ otherwise }
\end{cases}
\end{aligned}
\]</span></p>
<p>但总之可以看到连续函数一定有原函数.</p>
<p>此时回忆到我们曾经定义过左右上下导数<span class="math inline">\((
F_\pm ) &#39;\)</span>和<span class="math inline">\(( F^\pm )
&#39;\)</span>.设<span class="math inline">\(f \in R [ a , b
]\)</span>,<span class="math inline">\(F\)</span>是<span class="math inline">\(f\)</span>的广义原函数,不妨直接设<span class="math inline">\(F ( x ) = \int_a^x f ( t ) \text{ d }
t\)</span>,那么我们声明<span class="math inline">\(\int_a^b ( F_\pm )
&#39; \text{ d } x = \int_a^b ( F^\pm ) &#39; \text{ d } x = \int_a^b f
( x ) \text{ d } x\)</span>.</p>
<p>四个证明类似,只考虑其中之一<span class="math inline">\(F_+
&#39;\)</span>如何证明.取<span class="math inline">\(m_0 = \inf_{ [ c ,
d ] } f\)</span>,下面令<span class="math inline">\(G ( x ) = F ( x ) - F
( c ) - m_0 ( x - c ) = \int_c^x ( f ( t ) - m_0 ) \text{ d }
t\)</span>.当<span class="math inline">\(x \in [ c , d
]\)</span>时,容易发现<span class="math inline">\(G ( x
)\)</span>单增.既然如此,其任意左右上下导数当然都<span class="math inline">\(\geq 0\)</span>,也就是<span class="math inline">\(( G_+ ) &#39; = ( F_+ ) &#39; - m_0 \geq
0\)</span>.同理如果取<span class="math inline">\(M_0 = \sup_{ [ c , d ]
} f\)</span>的话还可以证明<span class="math inline">\(( F_+ ) &#39; \leq
M_0\)</span>.</p>
<p>那么就有<span class="math inline">\(w_{ F_+ &#39; } [ c , d ] \leq
w_{ f } [ c , d ]\)</span>,我们知道<span class="math inline">\(f\)</span>是黎曼可积的,也就是<span class="math inline">\(0 \leq \sum w_{ F_+ &#39; } [ x_{ i - 1 } , x_i ]
\Delta x_i \leq \sum w_f [ x_{ i - 1 } , x_i ] \Delta x_i &lt;
\epsilon\)</span>,此时就可以证明其可积性.</p>
<p>而注意到<span class="math inline">\(f\)</span>几乎处处连续,<span class="math inline">\(F\)</span>几乎处处可导,并且在<span class="math inline">\(f\)</span>的连续点处<span class="math inline">\(f
( x ) = F_+
&#39;\)</span>,这个连续点集当然是稠密集,因此它们的积分相等,这样就做完了.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\int_a^b \text{ sgn } ( x ) \text{ d }
x\)</span>.</p>
<p>注意到<span class="math inline">\(\text{ sgn } ( x
)\)</span>的广义原函数是<span class="math inline">\(| x
|\)</span>,所以<span class="math inline">\(\int_a^b \text{ sgn } ( x )
\text{ d } x = | b | - | a |\)</span>.</p>
<h6><span id="example2黎曼引理">Example2(黎曼引理)</span></h6>
<p>设<span class="math inline">\(f \in R [ a , b ] , g \in R [ 0 , T
]\)</span>并且<span class="math inline">\(g\)</span>在<span class="math inline">\(\mathbb{ R }\)</span>上以<span class="math inline">\(T\)</span>为周期.求证:</p>
<p><span class="math display">\[
\lim_{ \lambda \to \infty } \int_a^b f ( x ) g ( \lambda x ) \text{ d }
x = \cfrac{ \int_0^T g ( x ) \text{ d } x }{ T } \int_a^b f ( x ) \text{
d } x
\]</span></p>
<p>首先注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \lim_{ \lambda \to \infty } \int_a^b f ( x ) g ( \lambda x )
\text{ d } x \\
= &amp; \lim_{ \lambda \to \infty } \int_a^b f ( x ) ( g ( \lambda x ) -
\cfrac{ \int_0^T g ( x ) \text{ d } x }{ T } + \cfrac{ \int_0^T g ( x )
\text{ d } x }{ T } ) \text{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>因此可以用<span class="math inline">\(g ( \lambda x ) - \cfrac{
\int_0^T g ( x ) \text{ d } x }{ T }\)</span>代替<span class="math inline">\(g\)</span>,这样就能满足<span class="math inline">\(\int_0^T g ( x ) \text{ d } x = 0\)</span>.</p>
<p>接下来只需证明<span class="math inline">\(\lim_{ \lambda \to \infty }
\int_a^b f ( x ) g ( \lambda x ) \text{ d } x = 0\)</span>,不妨设<span class="math inline">\(| f ( x ) | \leq M , | g ( x ) | \leq
M\)</span>.</p>
<p>考虑对分划<span class="math inline">\(\Delta\)</span>,满足<span class="math inline">\(\sum w_i \Delta x_i \leq \epsilon\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_a^b f ( x ) g ( \lambda x ) \text{ d } x | \\
= &amp; | \sum \int_{ x_{ i - 1 } }^{ x_i } ( f ( x ) - f ( x_i ) + f (
x_i ) ) g ( \lambda x ) \text{ d } x | \\
\leq &amp; | \sum \int_{ x_{ i - 1 } }^{ x_i } f ( x_i ) g ( \lambda x )
\text{ d } x | + | \sum \int_{ x_{ i - 1 } }^{ x_i } ( f ( x ) - f ( x_i
) ) g ( \lambda x ) \text{ d } x | \\
\leq &amp; \sum | f ( x_i ) | \cdot | \int_{ x_{ i - 1 } }^{ x_i } g (
\lambda x ) \text{ d } x | + M \sum w_i \Delta x_i \\
\leq &amp; M \sum | \int_{ x_{ i - 1 } }^{ x_i } g ( \lambda x ) \text{
d } x | + M \sum w_i \Delta x_i \\
\leq &amp; M \sum | \frac{ 1 }{ \lambda } \int_{ \lambda x_{ i - 1 } }^{
\lambda x_i } g ( x ) \text{ d } x | + M \epsilon
\end{aligned}
\]</span></p>
<p>接下来设<span class="math inline">\(G ( x ) = \int_0^x g ( t ) \text{
d } t\)</span>,由于<span class="math inline">\(g\)</span>的周期性,而且其在任何一个长度为<span class="math inline">\(T\)</span>的区间上积分为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(| G ( x
) | \leq W\)</span>,那么<span class="math inline">\(\forall x , y , | G
( x ) - G ( y ) | \leq 2 W\)</span>.</p>
<p>那么上式就<span class="math inline">\(\leq 2 MW \frac{ n }{ \lambda }
+ M \epsilon\)</span>,这里虽然有个无穷大的<span class="math inline">\(n\)</span>,但由于<span class="math inline">\(\lambda\)</span>可以尽可能大且在<span class="math inline">\(n\)</span>之后决定取值,因此这个影响可以被消除.</p>
<p>这个命题的一个平凡推论是<span class="math inline">\(g ( x ) = \sin (
nx )\)</span>:</p>
<p><span class="math display">\[
\lim_{ \lambda \to \infty } \int_a^b f ( x ) \sin ( \lambda x ) \mathrm{
d } x = \lim_{ \lambda \to \infty } \int_a^b f ( x ) \cos ( \lambda x )
\mathrm{ d } x = 0
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\lim_{ n \to \infty }
I_n\)</span>,其中<span class="math inline">\(I_n = \frac{ 1 }{ n^{ 1 +
\alpha } } ( \sum_{ k = 1 }^n k^\alpha ) = \frac{ 1 }{ n } \sum_{ k = 1
}^n ( \frac{ k }{ n } )^\alpha\)</span>.</p>
<p>注意到<span class="math inline">\(n \to
\infty\)</span>的时候,上面就等于<span class="math inline">\(\int_0^1
x^\alpha \text{ d } x = \frac{ 1 }{ 1 + \alpha }\)</span>.</p>
<h6><span id="example4dirichlet核">Example4(Dirichlet核)</span></h6>
<p>求<span class="math inline">\(\int_0^{ \frac{ \pi }{ 2 } } \frac{
\sin ( ( 2 n + 1 ) x ) }{ \sin x } \text{ d } x\)</span>.</p>
<p>注意到根据积化和差有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ \pi }{ 2 } } \frac{ \sin ( ( 2 n + 1 ) x ) }{ \sin
x } \text{ d } x \\
= &amp; \int_0^{ \frac{ \pi }{ 2 } } ( 1 + 2 \sum_k \cos ( 2 kx ) )
\text{ d } x \\
= &amp; \frac{ \pi }{ 2 } + 2 \sum_{ k } \frac{ 1 }{ 2 k } \sin ( k \pi
) \\
= &amp; \frac{ \pi }{ 2 }
\end{aligned}
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p>考虑<span class="math inline">\(f \in \mathbb{ R }\)</span>,<span class="math inline">\(\forall a &lt; b\)</span>,都有<span class="math inline">\(f \in R [ a , b ]\)</span>,已知<span class="math inline">\(f ( x ) = \int_0^x f ( t ) \text{ d }
t\)</span>,求证<span class="math inline">\(f \equiv 0\)</span>.</p>
<p>首先注意到变限积分是李氏连续的,因此<span class="math inline">\(f\)</span>当然就是局部李氏连续的,因此自然看出<span class="math inline">\(f\)</span>在<span class="math inline">\(\mathbb{ R
}\)</span>上都是连续的.既然如此,那<span class="math inline">\(f\)</span>就在<span class="math inline">\(\mathbb{
R }\)</span>上处处可导并且<span class="math inline">\(f &#39; ( x )
\equiv f ( x )\)</span>,同理还可以看出<span class="math inline">\(f\)</span>实际上任意阶可导.理应见到<span class="math inline">\(f\)</span>应当和<span class="math inline">\(e^x\)</span>有关,凑<span class="math inline">\(g (
x ) = \frac{ f ( x ) }{ e^x }\)</span>,则<span class="math inline">\(g
&#39; ( x ) = \frac{ f &#39; - f }{ e^x } \equiv
0\)</span>,这立刻得到<span class="math inline">\(g ( x ) \equiv
C\)</span>.</p>
<p>然而<span class="math inline">\(g ( 0 ) = f ( 0 ) =
0\)</span>,于是<span class="math inline">\(g \equiv C \equiv
0\)</span>,所以<span class="math inline">\(f \equiv 0\)</span>.</p>
<h5><span id="换元法">换元法</span></h5>
<p>不妨设<span class="math inline">\(f \in R [ a , b ] , F &#39; =
f\)</span>,<span class="math inline">\(\varphi ( t ) : [ \alpha , \beta
] \to [ a , b ]\)</span>,<span class="math inline">\(\varphi ( \alpha )
= a , \varphi ( \beta ) = b\)</span>,并且<span class="math inline">\(\varphi\)</span>可导,而且<span class="math inline">\(f ( \varphi ( t ) ) \varphi &#39; ( t ) \in R [
\alpha , \beta ]\)</span>,则:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \text{ d } x = \int_\alpha^\beta f ( \varphi ( t ) )
\varphi &#39; ( t ) \text{ d } t
\]</span></p>
<p>证明的话,考虑考虑NL公式,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
( F ( \varphi ( t ) ) ) &#39; &amp; = f ( \varphi ( t ) ) \varphi &#39;
( t ) \\
\int_\alpha^\beta ( F ( \varphi ( t ) ) ) &#39; &amp; =
\int_\alpha^\beta f ( \varphi ( t ) ) \varphi &#39; ( t ) \\
F ( b ) - F ( a ) &amp; = \int_\alpha^\beta f ( \varphi ( t ) ) \varphi
&#39; ( t )
\end{aligned}
\]</span></p>
<p>然而回忆到有原函数和是否黎曼可积之间是有区别的,适当调整条件可以得到另一个策略的换元法:不妨设<span class="math inline">\(f \in R [ a , b ] , \varphi ( t ) : [ \alpha ,
\beta ] \to [ a , b ]\)</span>,并且<span class="math inline">\(\varphi (
t )\)</span>单增,<span class="math inline">\(\varphi ( \alpha ) = a ,
\varphi ( \beta ) = b\)</span>,<span class="math inline">\(\varphi\)</span>可导并且<span class="math inline">\(\varphi &#39; \in R [ \alpha , \beta
]\)</span>,则<span class="math inline">\(f ( \varphi ( t ) ) \varphi
&#39; ( t ) \in R [ \alpha , \beta ]\)</span>且上述积分仍然成立.</p>
<p>策略是对两边做黎曼和,利用<span class="math inline">\(\varphi\)</span>的单调性和一致连续性,可以取<span class="math inline">\(S_{ \Delta } = \sum f ( \eta_k ) \Delta
x_k\)</span>,利用中值定理可以写作<span class="math inline">\(S_{ \Delta
} = \sum f ( \varphi ( \xi_k ) ) \varphi &#39; ( \mu_k ) \Delta
t_k\)</span>.</p>
<p>而另一边的黎曼和<span class="math inline">\(\sigma_{ \Delta &#39; } =
\sum f ( \varphi ( \xi_k ) ) \varphi &#39; ( \xi_k ) \Delta
t_k\)</span>.</p>
<p>只需证明二者之差趋近于<span class="math inline">\(0\)</span>,令<span class="math inline">\(M = \sup | f | ,\)</span>做差得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum f ( \varphi ( \xi_k ) ) ( \varphi &#39; ( \xi_k ) - \varphi
&#39; ( \mu_k ) ) \Delta t_k | \\
\leq &amp; M | \sum ( \varphi &#39; ( \xi_k ) - \varphi &#39; ( \mu_k )
) \Delta t_k | \\
\leq &amp; M | \sum w_k \Delta t_k |
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(\varphi\)</span>可积,上述趋近于<span class="math inline">\(0\)</span>.</p>
<p>这些定理都有点诡异,它们会在RS积分处再详细讨论.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\int_0^{ \frac{ \pi }{ 2 } } \frac{
\sin x }{ \sin x + \cos x } \text{ d } x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ \pi }{ 2 } } \frac{ \sin x }{ \sin x + \cos x }
\text{ d } x \\
= &amp; \int_0^{ \frac{ \pi }{ 4 } } \left ( \frac{ \sin x }{ \sin x +
\cos x } + \frac{ \sin ( \frac{ \pi }{ 2 } - x ) }{ \sin ( \frac{ \pi }{
2 } - x ) + \cos ( \frac{ \pi }{ 2 } - x ) } \right ) \text{ d } x \\
= &amp; \int_0^{ \frac{ \pi }{ 4 } } \frac{ \sin x + \cos x }{ \sin x +
\cos x } \text{ d } x \\
= &amp; \frac{ \pi }{ 4 }
\end{aligned}
\]</span></p>
<p>其实就是找个点对折.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I = \int_0^\pi \frac{ \theta \sin
\theta }{ a + b \cos^2 \theta } \text{ d } \theta\)</span>,其中<span class="math inline">\(a , b &gt; 0\)</span>.</p>
<p>令<span class="math inline">\(\theta = \pi -
\varphi\)</span>,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = - \int_\pi^0 \frac{ ( \pi - \varphi ) \sin \varphi }{ a + b
\cos^2 \varphi } \text{ d } \varphi \\
&amp; = \int_0^\pi \frac{ ( \pi - \varphi ) \sin \varphi }{ a + b \cos^2
\varphi } \text{ d } \varphi \\
&amp; = \pi \int_{ 0 }^\pi \frac{ \sin \varphi }{ a + b \cos^2 \varphi }
\text{ d } \varphi - I
\end{aligned}
\]</span></p>
<p>移项得到:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = \frac{ \pi }{ 2 } \int_0^\pi \frac{ - \text{ d } \cos \theta
}{ a + b \cos^2 \theta } \\
&amp; = \frac{ \pi }{ \sqrt{ ab } } \arctan \sqrt{ \frac{ b }{ a } }
\end{aligned}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>如果<span class="math inline">\(\forall a &lt; b , f \in R [ a , b
]\)</span>,并且<span class="math inline">\(f ( x + y ) = f ( x ) + f ( y
)\)</span>恒成立,求证<span class="math inline">\(f ( x ) \equiv f ( 1 )
x\)</span>.</p>
<p>固定<span class="math inline">\(x\)</span>,对<span class="math inline">\(y\)</span>从<span class="math inline">\([ 0 , 1
]\)</span>积分,得到:</p>
<p><span class="math display">\[
f ( x ) = \int_x^{ x + 1 } f ( t ) \text{ d } t - \int_0^1 f ( y )
\text{ d } y
\]</span></p>
<p>而变限积分是局部李氏连续的,所以<span class="math inline">\(f ( x
)\)</span>局部连续,所以<span class="math inline">\(f ( x
)\)</span>整体连续,立刻得到<span class="math inline">\(f ( x
)\)</span>可导,立刻得到其是<span class="math inline">\(C^\infty\)</span>的.</p>
<p>那就可以两边对<span class="math inline">\(x\)</span>求导,得到<span class="math inline">\(\forall y , f &#39; ( x + y ) = f &#39; ( x
)\)</span>,因此<span class="math inline">\(f &#39; \equiv
C\)</span>.</p>
<h5><span id="分部积分">分部积分</span></h5>
<p>设<span class="math inline">\(u , v \in R [ a , b
]\)</span>并且均可导,而且<span class="math inline">\(u &#39; , v &#39;
\in R [ a , b ]\)</span>,则:</p>
<p><span class="math display">\[
( uv ) &#39; = u &#39; v + uv &#39;
\]</span></p>
<p>从这里能看出<span class="math inline">\(( uv )
&#39;\)</span>也是黎曼可积的,那就可以用牛顿莱布尼茨公式两边积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b uv &#39; \text{ d } x &amp; = uv \mid_a^b - \int_a^b u &#39; v
\text{ d } x \\
&amp; = \int_a^b u \text{ d } v = uv \mid_a^b - \int_a^b v \text{ d } u
\end{aligned}
\]</span></p>
<p>这个版本当然是简单的,那能不能上点难度呢?</p>
<p>不妨考虑<span class="math inline">\(f , g \in R [ a , b
]\)</span>,那它们的广义原函数可以取为<span class="math inline">\(F ( x )
= \int_a^x f ( t ) \text{ d } t + A , G ( x ) = \int_a^x g ( t ) \text{
d } t + B\)</span>.</p>
<p>则<span class="math inline">\(\int_a^b Fg \text{ d } x = FG \mid_a^b
- \int_a^b Gf \text{ d } x\)</span>.</p>
<p>先证明一个引理:</p>
<p><span class="math display">\[
\lim_{ \lambda ( \Delta ) \to 0 } \sum_k^n f ( \xi_k ) \int_{ x_{ i - 1
} }^{ x_i } g ( t ) \text{ d } t = \int_a^b f ( x ) g ( x ) \text{ d } x
\]</span></p>
<p>证明无非是用黎曼和,设<span class="math inline">\(M = \sup | f
|\)</span>,直接考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_k^n f ( \xi ) \int_{ x_{ i - 1 } }^{ x_i } g \mathrm{ d } t
- \sum_k^n \int_{ x_{ i - 1 } }^{ x_i } fg \text{ d } t | \\
\leq &amp; \sum | f ( \xi_k ) | \int_{ x_{ i - 1 } }^{ x_i } | g ( t ) -
g ( \xi_k ) | \text{ d } t + | \sum f ( \xi_k ) g ( \xi_k ) \Delta t_k -
\int_a^b f g \text{ d } t | \\
\leq &amp; M \sum w_k ( g ) \text{ d } t + \sum w_k ( fg ) \Delta t_i
\end{aligned}
\]</span></p>
<p>这个当然趋向于<span class="math inline">\(0\)</span>.</p>
<p>使用abel求和法则,得到:</p>
<p><span class="math display">\[
\begin{aligned}
( FG ) \mid_a^b &amp; = \sum_k ( F ( x_k ) G ( x_k ) - F ( x_{ k - 1 } )
G ( x_{ k - 1 } ) ) \\
&amp; = \sum_k ( F ( x_k ) G ( x_k ) - F ( x_{ k - 1 } ) G ( x_k ) + F (
x_{ k - 1 } ) G ( x_k ) - F ( x_{ k - 1 } ) G ( x_{ k - 1 } ) ) \\
&amp; = \sum_{ k }^n G ( x_k ) ( F ( x_k ) - F ( x_{ k - 1 } ) ) +
\sum_{ k } F ( x_{ k - 1 } ) ( G ( x_i ) - G ( x_{ i - 1 } ) ) \\
&amp; = \sum_k G ( x_i ) \int_{ x_{ i - 1 } }^{ x_i } f ( x ) \text{ d }
x + \sum_{ k }^n F ( x_{ i - 1 } ) \int_{ x_{ i - 1 } }^{ x_i } g ( x )
\text{ d } x
\end{aligned}
\]</span></p>
<p>使用引理就完事了.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:</p>
<p><span class="math display">\[
\int_a^x ( \int_a^t f ( u ) \text{ d } u ) \text{ d } t = \int_a^x ( x -
t ) f ( t ) \text{ d } t
\]</span></p>
<p>令<span class="math inline">\(F ( x ) = \int_a^t f ( t ) \text{ d }
t\)</span>,<span class="math inline">\(g ( x ) = 1 , G ( x ) = x -
a\)</span>就可以直接套用分部积分公式得到:</p>
$$
<span class="math display">\[\begin{aligned}
LHS &amp; = \int_a^x F ( t ) g ( t ) \text{ d } t \\
&amp; = FG \mid_a^x - \int_a^x f ( t ) G ( t ) \text{ d } t \\
&amp; = ( x - a ) \int_a^x f ( t ) \text{ d } t - \int_a^x f ( t ) ( t -
a ) \text{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就做完了.</p>
<p>或者设<span class="math inline">\(F ( a ) =
0\)</span>,将上式记作:</p>
<p><span class="math display">\[
\int_a^x F ( t ) \mathrm{ d } t = \int_a^x ( x - t ) F &#39; ( t )
\mathrm{ d } t
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I = \int_0^{ \frac{ \pi }{ 2 } } \frac{
x \sin x \cos x }{ ( a^2 \cos^2 x + b^2 \sin^2 x )^2 } \text{ d }
x\)</span>,其中<span class="math inline">\(a , b &gt; 0\)</span>.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ \pi }{ 2 } } \frac{ x \sin x \cos x }{ ( a^2
\cos^2 x + b^2 \sin^2 x )^2 } \text{ d } x \\
= &amp; \frac{ - 1 }{ 2 ( b^2 - a^2 ) } \int_0^{ \frac{ \pi }{ 2 } } x
\text{ d } ( \frac{ 1 }{ a^2 + ( b^2 - a^2 ) \sin^2 x } ) \\
= &amp; \frac{ - 1 }{ 2 ( b^2 - a^2 ) } ( \frac{ \pi }{ 2 b^2 } -
\int_0^{ \frac{ \pi }{ 2 } } \frac{ \text{ d } x }{ a^2 \cos^2 x + b^2
\sin^2 x } ) \\
= &amp; \frac{ 1 }{ 2 ( b^2 - a^2 ) } ( - \frac{ \pi }{ 2 b^2 } +
\int_0^{ \frac{ \pi }{ 2 } } \frac{ \text{ d } \tan x }{ a^2 + b^2
\tan^2 x } ) \\
= &amp; \frac{ 1 }{ 2 ( b^2 - a^2 ) } ( - \frac{ \pi }{ 2 b^2 } + \frac{
\pi }{ 2 ab } ) \\
= &amp; \frac{ \pi }{ 4 ab^2 ( a + b ) }
\end{aligned}
\]</span></p>
<h6><span id="example3wallis公式">Example3(Wallis公式)</span></h6>
<p>求<span class="math inline">\(I_n = \int_0^{ \frac{ \pi }{ 2 } }
\sin^n x \text{ d } x\)</span>.</p>
<p>换元后直接分部积分:</p>
$$
<span class="math display">\[\begin{aligned}
I_n &amp; = - \int_0^{ \frac{ \pi }{ 2 } } \sin^{ n - 1 } x \text{ d }
\cos x \\
&amp; = \int_0^{ \frac{ \pi }{ 2 } } \cos x \text{ d } ( \sin^{ n - 1 }
x ) \\
&amp; = ( n - 1 ) \int_0^{ \frac{ \pi }{ 2 } } \sin^{ n - 2 } x ( 1 -
\sin^2 x ) \text{ d } x \\
&amp; = ( n - 1 ) I_{ n - 2 } - ( n - 1 ) I_n \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是<span class="math inline">\(I_n = \frac{ n - 1 }{ n } I_{ n - 2
}\)</span>.</p>
<p>注意到<span class="math inline">\(I_0 = \frac{ \pi }{ 2 } , I_1 =
1\)</span>,所以<span class="math inline">\(I_{ 2 m } = \frac{ ( 2 m - 1
) ! ! }{ ( 2 m ) ! ! } \frac{ \pi }{ 2 } , I_{ 2 m + 1 } = \frac{ ( 2 m
) ! ! }{ ( 2 m + 1 ) ! ! }\)</span>.</p>
<p>然而注意到<span class="math inline">\(I_n\)</span>随着<span class="math inline">\(n\)</span>增大而减小,于是应该有<span class="math inline">\(I_{ 2 m + 1 } \leq I_{ 2 m } \leq I_{ 2 m - 1
}\)</span>,展开得到:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ 2 n + 1 } ( \frac{ ( 2 n ) ! ! }{ ( 2 n - 1 ) !
! } )^2 \\
&amp; \leq \frac{ \pi }{ 2 } \leq \\
\frac{ 1 }{ 2 n } ( \frac{ ( 2 n ) ! ! }{ ( 2 n - 1 ) ! ! } )^2 &amp; =
b_n
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(\lim a_n = \lim b_n\)</span>,因此<span class="math inline">\(\lim a_n = \lim b_n = \frac{ \pi }{ 2
}\)</span>.</p>
<h5><span id="泰勒公式的积分余项">泰勒公式的积分余项</span></h5>
<p>回忆到泰勒公式的余项:</p>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(a\)</span>处有<span class="math inline">\(n\)</span>阶导数,则<span class="math inline">\(f (
x ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( a ) }{ k ! } ( x - a )^k + o
( ( x - a )^n )\)</span>.</p>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( \alpha , \beta )\)</span>上有<span class="math inline">\(n + 1\)</span>阶导数,则<span class="math inline">\(f ( x ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( a
) }{ k ! } ( x - a )^k + \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! }
( x - a )^{ n + 1 }\)</span>.</p>
<p>事实上还可以写积分余项,若<span class="math inline">\(f^{ ( n + 1 ) }
\in R [ \alpha , \beta ]\)</span>,则<span class="math inline">\(f ( x )
= \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( a ) }{ k ! } ( x - a )^k +
\frac{ 1 }{ n ! } \int_a^x ( x - t )^n f^{ ( n + 1 ) } ( t ) \text{ d }
t\)</span>.</p>
<p>首先能写出<span class="math inline">\(f ( x ) = f ( a ) + \int_a^x f
&#39; ( t ) \text{ d }
t\)</span>,考虑不断展开后面那一项,用分部积分注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^x f^{ ( m + 1 ) } ( t ) \frac{ ( x - t )^m }{ m ! } \text{
d } t \\
= &amp; \int_a^x f^{ ( m + 1 ) } ( t ) \text{ d } ( - \frac{ ( x - t )^{
m + 1 } }{ ( m + 1 ) ! } ) \\
= &amp; f^{ ( m + 1 ) } ( a ) \frac{ ( x - a )^{ m + 1 } }{ ( m + 1 ) !
} + \frac{ 1 }{ ( m + 1 ) ! } \int_a^x ( x - t )^{ m + 1 } f^{ ( m + 2 )
} ( t ) \text{ d } t
\end{aligned}
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>函数<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上各阶导数存在且非负,求证:</p>
<p><span class="math display">\[
f ( x ) = \sum_{ n = 0 }^\infty \frac{ f^{ ( n ) } ( a ) }{ n ! } ( x -
a )^n
\]</span></p>
<p>其实这个题应该放到幂级数那里,不过确实和积分余项关系更大.分析的话首先会发现要证两边相等一定要搞定余项对吧,但是拉格朗日余项要求对所有的点的任意阶导数都存在一个控制,但这是做不到的,原函数对导函数的控制只能是在一段连续区间上的控制(用NL公式),而做不到对所有单点的控制.因此使用积分余项,一个自然的想法是除了<span class="math inline">\(b\)</span>端点以外的误差应该都比<span class="math inline">\(b\)</span>处的误差要小,注意到:</p>
<p><span class="math display">\[
\frac{ x - t }{ x - a } \leq \frac{ b - t }{ b - a }
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
\begin{aligned}
R_n ( x ) &amp; = \frac{ 1 }{ n ! } \int_a^x f^{ ( n + 1 ) } ( t ) ( x -
t )^n \mathrm{ d } t \\
&amp; \leq \frac{ ( x - a )^n }{ ( b - a )^n } \frac{ 1 }{ n ! }
\int_a^x f^{ ( n + 1 ) } ( t ) ( b - t )^n \mathrm{ d } t \\
&amp; \leq \frac{ ( x - a )^n }{ ( b - a )^n } R_n ( b )
\end{aligned}
\]</span></p>
<p>接下来如果能控制<span class="math inline">\(R_n ( b
)\)</span>就万事大吉,发现:</p>
<p><span class="math display">\[
\begin{aligned}
R_n ( b ) &amp; = \frac{ 1 }{ n ! } \int_a^b f^{ ( n + 1 ) } ( t ) ( b -
t )^n \mathrm{ d } t \\
&amp; = \frac{ 1 }{ n ! } \int_a^b ( b - t )^n \mathrm{ d } f^{ ( n ) }
( t ) \\
&amp; = - \frac{ ( b - a )^n }{ n ! } f^{ ( n ) } ( a ) + \frac{ 1 }{ (
n - 1 ) ! } \int_a^b ( b - t )^{ n - 1 } f^{ ( n ) } ( t ) \\
&amp; \leq R_{ n - 1 } ( b ) \\
&amp; \leq \cdots \leq f ( b ) - f ( a )
\end{aligned}
\]</span></p>
<p>这就搞定了,当<span class="math inline">\(x \in [ a , b
)\)</span>的时候,由于<span class="math inline">\(\frac{ ( x - a )^n }{ (
b - a )^n } \to
0\)</span>而自然完事.而单调函数的端点是随便延拓的,写下来的话,如果端点处不满足则必然端点处不收敛,意味着:</p>
<p><span class="math display">\[
\lim_{ x \to b - 0 } \sum_{ n = 0 }^\infty \frac{ f^{ ( n ) } ( a ) }{ n
! } ( x - a )^n = + \infty
\]</span></p>
<p>但这不可能,因为左边的恰好是原本收敛的那个函数<span class="math inline">\(x \to b - 0\)</span>处的表现.</p>
<h5><span id="积分第一中值定理">积分第一中值定理</span></h5>
<p>设<span class="math inline">\(f , g \in R [ a , b ]\)</span>并且<span class="math inline">\(g\)</span>不变号.不妨设<span class="math inline">\(f\)</span>的连续点集为<span class="math inline">\(A\)</span>,称它的<strong>本性上界</strong>为<span class="math inline">\(M = \inf_{ x \in A } ( f ( x )
)\)</span>,同理定义<strong>本性下界</strong><span class="math inline">\(m\)</span>.则<span class="math inline">\(\exists
\mu \in [ m , M ]\)</span>使得:</p>
<p><span class="math display">\[
\int_a^b fg ( x ) \text{ d } x = \mu \int_a^b g ( x ) \text{ d } x
\]</span></p>
<p>来证明这个事,不妨设<span class="math inline">\(g ( x ) \geq
0\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b g ( x ) \text{ d } x =
0\)</span>的时候,此时由于<span class="math inline">\(g ( x ) \geq
0\)</span>,因此<span class="math inline">\(g ( x
)\)</span>一定几乎处处为零(否则,存在一个<span class="math inline">\(g\)</span>的连续点处不为<span class="math inline">\(0\)</span>,在这个点邻域附近卡一下就能卡掉),那左右两边都等于<span class="math inline">\(0\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b g ( x ) \text{ d } x &gt;
0\)</span>的时候,由于<span class="math inline">\(mg \leq gf \leq
Mg\)</span>对于<span class="math inline">\(f\)</span>的连续点集<span class="math inline">\(A\)</span>成立,而这是个稠密集,立刻见到<span class="math inline">\(\int_a^b mg \text{ d } x \leq \int_a^b gf \text{ d
} x \leq \int_a^b Mg \text{ d } x\)</span>.于是<span class="math inline">\(\mu = \frac{ \int_a^b f g \text{ d } x }{ \int_a^b
g \text{ d } x } \in [ m , M ]\)</span>.</p>
<p>作为更加常见的版本,当<span class="math inline">\(f \in C [ a , b
]\)</span>的时候,<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>使得:</p>
<p><span class="math display">\[
\int_a^b fg ( x ) \text{ d } x = f ( \xi ) \int_a^b g ( x ) \text{ d } x
\]</span></p>
<p>该版本与之前的区别在于要断言<span class="math inline">\(\xi \ne a ,
\xi \ne b\)</span>.使用反证法,在<span class="math inline">\(\int_a^b g (
x ) \text{ d } x &gt; 0\)</span>的时候,不妨假设<span class="math inline">\(\xi = b\)</span>,此时前面<span class="math inline">\(( a , b )\)</span>中不能有和<span class="math inline">\(f ( b
)\)</span>相同的,又因为其是连续函数,因此不妨设<span class="math inline">\(( a , b )\)</span>中<span class="math inline">\(f
( x )\)</span>均比<span class="math inline">\(f ( b
)\)</span>要小,用极限把端点用保号性卡出来就知道<span class="math inline">\([ a , b ]\)</span>中<span class="math inline">\(f
( x ) \leq f ( b )\)</span>.</p>
<p>由于此时<span class="math inline">\(\int_a^b g ( x ) \text{ d } x
&gt; 0\)</span>,于是一定存在一个<span class="math inline">\(x_0 , g (
x_0 ) &gt; 0\)</span>,并且<span class="math inline">\(x_0\)</span>是一个连续点.此时就存在其一个小邻域都<span class="math inline">\(&gt; \frac{ 1 }{ 2 } g ( x_0 ) &gt;
0\)</span>,并且这个邻域上的<span class="math inline">\(f ( x ) &lt; f (
b )\)</span>.在这个邻域上立刻可以发现:</p>
<p><span class="math display">\[
\int_a^b ( M - f ( x ) ) g ( x ) \text{ d } x &gt; 0
\]</span></p>
<p>这就有了矛盾.</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(f \in R [ 0 , 1 ]\)</span>,<span class="math inline">\(f ( + 0 )\)</span>存在,则:</p>
<p><span class="math display">\[
\lim_{ n \to + \infty } \int_0^1 \frac{ n f ( x ) }{ 1 + n^2 x^2 }
\text{ d } x = \frac{ \pi }{ 2 } f ( + 0 )
\]</span></p>
<p>不妨设<span class="math inline">\(f ( 0 ) = f ( + 0
)\)</span>,因为改变有限个点的取值是不会改变其积分的.</p>
<p>此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^1 \frac{ n f ( x ) }{ 1 + n^2 x^2 } \text{ d } x \\
= &amp; \int_0^{ \frac{ 1 }{ \sqrt{ n } } } \frac{ n f ( x ) }{ 1 + n^2
x^2 } \text{ d } x + \int_{ \frac{ 1 }{ \sqrt{ n } } }^{ 1 } \frac{ n f
( x ) }{ 1 + n^2 x^2 } \text{ d } x
\end{aligned}
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ 1 }{ \sqrt{ n } } } \frac{ n f ( x ) }{ 1 + n^2
x^2 } \text{ d } x \\
= &amp; \mu \int_0^{ \frac{ 1 }{ \sqrt{ n } } } \frac{ n }{ 1 + n^2 x^2
} \text{ d } x \\
= &amp; \mu \arctan \sqrt{ n } \to f ( 0 ) \frac{ \pi }{ 2 }
\end{aligned}
\]</span></p>
<p>而后者:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ \frac{ 1 }{ \sqrt{ n } } }^{ 1 } \frac{ n f ( x ) }{ 1 +
n^2 x^2 } \text{ d } x | \\
\leq &amp; \sup | f | ( \arctan ( nx ) \mid_{ \frac{ 1 }{ \sqrt{ n } }
}^1 ) \\
= &amp; \sup | f | \arctan ( \frac{ n - \sqrt{ n } }{ 1 + n \sqrt{ n } }
) \to 0
\end{aligned}
\]</span></p>
<p>这样就做完了.这里拆成两部分可能是难以想到的,事实上这么做的意义是使得<span class="math inline">\(\mu \to f ( 0 )\)</span>而放缩,其中这个<span class="math inline">\(nx\)</span>的变化量很大,因此可以稍微匀一下变化.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f\)</span>二阶可导,并且一,二阶导可积,则<span class="math inline">\(\exists \xi \in ( a , b )\)</span>,使得<span class="math inline">\(\int_a^b f ( x ) \text{ d } x = ( b - a ) f (
\frac{ a + b }{ 2 } ) + \frac{ ( b - a )^3 }{ 24 } f &#39; &#39; ( \xi
)\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f ( x ) \text{ d } x \\
= &amp; \int_{ a }^{ \frac{ a + b }{ 2 } } f ( x ) \text{ d } x + \int_{
\frac{ a + b }{ 2 } }^{ b } f ( x ) \text{ d } x \\
= &amp; \int_0^{ \frac{ b - a }{ 2 } } f ( a + t ) \text{ d } t +
\int_0^{ \frac{ b - a }{ 2 } } f ( b - t ) \text{ d } t \\
= &amp; \int_0^{ \frac{ b - a }{ 2 } } f ( a + t ) + f ( b - t ) \text{
d } t \\
= &amp; t ( f ( a + t ) + f ( b - t ) ) \mid_0^{ \frac{ b - a }{ 2 } } -
\int_0^{ \frac{ b - a }{ 2 } } t ( f &#39; ( a + t ) - f &#39; ( b - t )
) \text{ d } t \\
= &amp; ( b - a ) f ( \frac{ a + b }{ 2 } ) - \int_0^{ \frac{ b - a }{ 2
} } t ( f &#39; ( a + t ) - f &#39; ( b - t ) ) \text{ d } t
\end{aligned}
\]</span></p>
<p>前半部分已经完事了,接下来看后半部分,继续分部积分:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ b - a }{ 2 } } t ( f &#39; ( a + t ) - f &#39; ( b
- t ) ) \text{ d } t \\
= &amp; \frac{ 1 }{ 2 } \int_0^{ \frac{ b - a }{ 2 } } ( f &#39; ( a + t
) - f &#39; ( b - t ) ) \text{ d } ( t^2 ) \\
= &amp; \left ( \frac{ t^2 }{ 2 } ( f &#39; ( a + t ) - f &#39; ( b - t
) ) \right ) \mid_{ 0 }^{ \frac{ b - a }{ 2 } } - \int_0^{ \frac{ b - a
}{ 2 } } \frac{ t^2 }{ 2 } ( f &#39; &#39; ( a + t ) + f &#39; &#39; ( b
- t ) ) \text{ d } t \\
= &amp; - \int_0^{ \frac{ b - a }{ 2 } } \frac{ t^2 }{ 2 } ( f &#39;
&#39; ( a + t ) + f &#39; &#39; ( b - t ) ) \text{ d } t \\
= &amp; \mu \int_0^{ \frac{ b - a }{ 2 } } \frac{ t^2 }{ 2 } \text{ d }
t \\
= &amp; \mu \frac{ ( b - a )^3 }{ 48 }
\end{aligned}
\]</span></p>
<p>接下来看<span class="math inline">\(\mu\)</span>,<span class="math inline">\(\mu \in [ \inf ( f &#39; &#39; ( a + t ) + f &#39;
&#39; ( b - t ) ) , \sup ( f &#39; &#39; ( a + t ) + f &#39; &#39; ( b -
t ) ) ]\)</span>,由导函数介值性,意味着必然<span class="math inline">\(\exists \xi_1 \in [ 0 , \frac{ b - a }{ 2 }
]\)</span>使得<span class="math inline">\(\mu = f &#39; &#39; ( a +
\xi_1 ) + f &#39; &#39; ( b - \xi_1 )\)</span>.再用一次<span class="math inline">\(2 f &#39; &#39;\)</span>的介值性得到<span class="math inline">\(\mu = 2 f &#39; &#39; ( \xi ) , \xi \in ( a +
\xi_1 , b - \xi_1 ) \subseteq ( a , b )\)</span>.</p>
<h5><span id="积分第二中值定理">积分第二中值定理</span></h5>
<p>设<span class="math inline">\(g \in R [ a , b ] , f \geq
0\)</span>,并且<span class="math inline">\(f\)</span>单调,则:</p>
<ol type="1">
<li><p><span class="math inline">\(f\)</span>单调递减时,<span class="math inline">\(\exists \xi \in [ a , b ]\)</span>,<span class="math inline">\(\int_a^b f g \text{ d } x = f ( a + 0 ) \int_a^\xi
g ( x ) \text{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(f\)</span>单调递增时,<span class="math inline">\(\exists \xi \in [ a , b ]\)</span>,<span class="math inline">\(\int_a^b f g \text{ d } x = f ( b - 0 ) \int_\xi^b
g ( x ) \text{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(\exists \xi \in [ a , b
]\)</span>,<span class="math inline">\(\int_a^b f g \text{ d } x = f ( a
+ 0 ) \int_a^\xi g \text{ d } x + f ( b - 0 ) \int_\xi^b g \text{ d }
x\)</span>.</p></li>
<li><p>在上述基础上,如果<span class="math inline">\(f\)</span>不是几乎常值函数,那么上述的<span class="math inline">\(\xi \in ( a , b )\)</span>.</p></li>
</ol>
<p>(1)(2)相似,下面只对(1)进行证明:</p>
<p>不妨设<span class="math inline">\(f ( a ) = f ( a + 0 ) , G =
\int_a^x g ( x ) \text{ d } x\)</span>是<span class="math inline">\(g\)</span>的广义原函数,其满足<span class="math inline">\(G ( a ) = 0\)</span>,不妨设<span class="math inline">\(M = \sup G , m = \inf G\)</span>,回忆到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b f g \text{ d } x &amp; = \lim_{ \lambda ( \Delta ) \to 0 }
\sum_{ i = 1 }^n f ( x_{ i - 1 } ) \int_{ x_{ i - 1 } }^{ x_i } g \text{
d } x \\
&amp; = \sum_{ i = 1 }^n f ( x_{ i - 1 } ) ( G ( x_i ) - G ( x_{ i - 1 }
) ) \\
&amp; = f ( x_{ n - 1 } ) G ( x_n ) + \sum_{ i = 1 }^{ n - 1 } ( f ( x_{
i - 1 } ) - f ( x_{ i } ) ) G ( x_i ) \\
&amp; \leq f ( a ) M
\end{aligned}
\]</span></p>
<p>在最后一步放缩进行修改就可以改为<span class="math inline">\(\geq f (
a ) m\)</span>,而我们已经得知<span class="math inline">\(G\)</span>的连续性,因此用介值性就可以解决上述问题.</p>
<p>难点在于(4)如何证明.</p>
<p>当其不是几乎常值函数的时候,应该满足<span class="math inline">\(f ( a
+ 0 ) &gt; f ( b - 0 )\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b f g \text{ d } x =
0\)</span>的时候,如果迫不得已必须取端点就应当有<span class="math inline">\(\forall \xi \in ( a , b )\)</span>,都有<span class="math inline">\(\int_a^\xi g \text{ d } x \ne
0\)</span>,由于其连续导出的介值性那就当然拿到了<span class="math inline">\(G\)</span>的保号性.我们上面已经用Abel变换得到了:</p>
$$
<span class="math display">\[\begin{aligned}
\int_a^b f g \text{ d } x &amp; = \sum_{ i = 1 }^n f ( x_{ i - 1 } ) ( G
( x_i ) - G ( x_{ i - 1 } ) ) \\
&amp; = f ( x_{ n - 1 } ) G ( x_n ) + \sum_{ i = 1 }^{ n - 1 } ( f ( x_{
i - 1 } ) - f ( x_{ i } ) ) G ( x_i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时考虑取<span class="math inline">\(c , d\)</span>使得<span class="math inline">\(a &lt; c &lt; d &lt; b\)</span>,并且满足<span class="math inline">\(f ( c ) &gt; f ( d )\)</span>,由于<span class="math inline">\(f\)</span>并不是几乎常值函数,这当然可以做到,上式每一项都是<span class="math inline">\(\geq 0\)</span>的,那就可以把区间从<span class="math inline">\([ a , b ]\)</span>重新控制到<span class="math inline">\([ c , d ]\)</span>中.于是此时上式立刻:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f g \text{ d } x \\
\geq &amp; ( f ( c ) - f ( d ) ) \min_{ [ c , d ] } G ( x ) &gt; 0
\end{aligned}
\]</span></p>
<p>然而我们假设中<span class="math inline">\(\int_a^b f g \text{ d } x =
0\)</span>,这样就导出了矛盾.</p>
<p>接下来考虑<span class="math inline">\(\int_a^b f g \text{ d } x \ne
0\)</span>的情况,如果其迫不得已必须取在端点的话当然要取到右端点此时应该有<span class="math inline">\(\int_a^b f g \text{ d } x = f ( a ) \int_a^b g
\text{ d } x\)</span>.</p>
<p>仍然看上面的Abel变换后的结果,同时按照上面同样的办法取出一个子区间<span class="math inline">\([ c , d
]\)</span>.回忆到为了保证前面都没有能和<span class="math inline">\(G ( b
)\)</span>相同的,因此<span class="math inline">\(G ( b
)\)</span>必然是前面的最大值.再回忆到<span class="math inline">\(G ( a )
= 0\)</span>,立刻能得到<span class="math inline">\(G ( b ) &gt; \sup_{ [
a , c ] } G ( x )\)</span>,设后者为<span class="math inline">\(M\)</span>,应当有:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_a^b f g \text{ d } x \\
= &amp; f ( x_{ n - 1 } ) G ( b ) + \sum_{ i = 1 }^{ n - 1 } ( f ( x_{ i
- 1 } ) - f ( x_{ i } ) ) G ( x_i ) \\
\leq &amp; f ( x_{ n - 1 } ) G ( b ) + M ( f ( a ) - f ( c ) ) + G ( b )
( f ( c ) - f ( b ) ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里这个<span class="math inline">\(f ( x_{ n - 1 }
)\)</span>很烦,但是当<span class="math inline">\(\lambda ( \Delta ) \to
0\)</span>的时候当然会使得<span class="math inline">\(f ( x_{ n - 1 } )
\to f ( b - 0 )\)</span>,上式变更为:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f g \text{ d } x \\
\leq &amp; f ( b ) G ( b ) + M ( f ( a ) - f ( c ) ) + G ( b ) ( f ( c )
- f ( b ) ) \\
= &amp; M ( f ( a ) - f ( c ) ) + G ( b ) f ( c ) \\
&lt; &amp; f ( a ) G ( b )
\end{aligned}
\]</span></p>
<p>这就导出了矛盾.</p>
<p>最后来看(3),不妨设<span class="math inline">\(f\)</span>单减,设<span class="math inline">\(\varphi ( x ) = f ( x ) - f ( b ) \geq
0\)</span>且单减,用(1)的结论得到<span class="math inline">\(\exists \xi
\in [ a , b ]\)</span>使得<span class="math inline">\(\int_a^b \varphi g
\text{ d } x = \varphi ( a ) \int_a^\xi g \text{ d }
x\)</span>.变形后就可以得到原本的式子.单增是同理的.总之,(3)是(1)(2)的一个更为优美的推论.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f \in C^1 [ a , b
]\)</span>,并且满足<span class="math inline">\(f
&#39;\)</span>单调递减,且<span class="math inline">\(f &#39; ( b ) \geq
M &gt; 0\)</span>.求证:<span class="math inline">\(| \int_a^b \cos f ( x
) \text{ d } x | \leq \frac{ 2 }{ M }\)</span>.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_a^b \cos f ( x ) \text{ d } x \\
= &amp; \int_a^b \frac{ f &#39; \cos f }{ f &#39; } \text{ d } x \\
= &amp; \frac{ 1 }{ f &#39; ( b ) } \int_\xi^b f &#39; \cos f \text{ d }
x \\
= &amp; \frac{ 1 }{ f &#39; ( b ) } ( \sin f ( b ) - \sin f ( \xi ) ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这就完事了.</p>
<h5><span id="有界变差函数">有界变差函数</span></h5>
<p>对于一个<span class="math inline">\(f : [ a , b ] \to
R\)</span>的函数,做分划<span class="math inline">\(\Delta : a = x_0 &lt;
\cdots &lt; x_n = b\)</span>,定义其变差为<span class="math inline">\(V_\Delta = \sum_k | f ( x_i ) - f ( x_{ i - 1 } )
|\)</span>,定义其全变差为<span class="math inline">\(V_{ [ a , b ] } ( f
) = \sup_\Delta V_\Delta\)</span>.当全变差为有限的时候,称<span class="math inline">\(f\)</span>是有界变差函数.容易见到由介值定理,如果<span class="math inline">\(f\)</span>可导而且<span class="math inline">\(f
&#39;\)</span>可积,则<span class="math inline">\(V_{ [ a , b ] } ( f ) =
\int_a^b | f &#39; | \mathrm{ d } x\)</span>.</p>
<p>应当容易见到,闭区间上的单调函数是有界变差的,且<span class="math inline">\(V_{ | f | } \leq V_f , V_{ f + g } \leq V_f +
V_g\)</span>.</p>
<p>接下来我们来证明:<span class="math inline">\(f\)</span>是有界变差函数,当且仅当<span class="math inline">\(f\)</span>是两个单调(不一定严格)函数的差.或者更严格一点,可以写成两个单调不减函数的差.另外,作为这个命题的平凡推论,我们知道有界变差函数几乎处处可导,并且有至多可数个间断点,且只有第一类间断点.</p>
<p>充分性显然,下面来看必要性.假设<span class="math inline">\(f\)</span>是有界变差的,此时类似积分可以定义一个变上限函数<span class="math inline">\(V_f ( x ) = V_f [ a , x
]\)</span>,其显然是单调不降的.</p>
<p>接下来定义<span class="math inline">\(g = V_f ( x ) - f ( x
)\)</span>,我们来说明它一定也是单调不减的.</p>
<p>那考虑当<span class="math inline">\(x_2 &gt; x_1\)</span>时,观察<span class="math inline">\(g ( x_2 ) - g ( x_1 ) = V_f ( x_2 ) - V_f ( x_1 )
- ( f ( x_2 ) - f ( x_1 ) )\)</span>.</p>
<p>既然全变差的定义依赖于分划,我们当然可以加分点,自然有<span class="math inline">\(V_f ( x_2 ) - V_f ( x_1 ) = V_{ f , [ x_1 , x_2 ]
} \geq | f ( x_2 ) - f ( x_1 ) | \geq f ( x_2 ) - f ( x_1
)\)</span>.</p>
<p>自然得证.</p>
<p>可应当意识到连续函数不一定是有界变差函数,原因仍然考虑<span class="math inline">\(f ( x ) = \begin{cases}0 &amp; x = 0 \\ x \sin
\frac{ 1 }{ x } &amp; \text{ otherwise
}\end{cases}\)</span>.在闭区间<span class="math inline">\([ 0 , 1
]\)</span>上取<span class="math inline">\(x_k = \frac{ 1 }{ ( k + \frac{
1 }{ 2 } ) \pi }\)</span>,这样<span class="math inline">\(\sin \frac{ 1
}{ x_i }\)</span>的取值正负交替,容易见到出现了调和级数.</p>
<p>然而,稍微加点条件,我们可以证明李氏连续是有界变差的.可以直接套用定义,也可以回忆到<span class="math inline">\(f ( x ) = f ( x ) - Lx + Lx = Lx - ( Lx - f ( x )
)\)</span>.因此导函数有界就一定有界变差.并且此时,可以让其拆出两个不降的可导函数.</p>
<h5><span id="定积分的应用">定积分的应用</span></h5>
<h6><span id="example1图形证明不等式">Example1(图形证明不等式)</span></h6>
<p>回忆到我们证明积分形式的柯西不等式的时候,证明了当<span class="math inline">\(\frac{ 1 }{ p } + \frac{ 1 }{ q } =
1\)</span>时,<span class="math inline">\(a^{ \frac{ 1 }{ p } } b^{
\frac{ 1 }{ q } } = e^{ \frac{ \ln a }{ p } + \frac{ \ln b }{ q } } \leq
\frac{ a }{ p } + \frac{ b }{ q }\)</span>.</p>
<p>下面可以用类似的策略理解这个式子,首先等价于证明<span class="math inline">\(ab \leq \frac{ a^p }{ p } + \frac{ b^q }{ q
}\)</span>.原因是考虑设<span class="math inline">\(S_1 = \frac{ a^p }{ p
} , S_2 = \frac{ b^q }{ q }\)</span>,设<span class="math inline">\(f ( x
) = x^{ p - 1 }\)</span>,留意到<span class="math inline">\(f ( x
)\)</span>的积分表示出了<span class="math inline">\(S_1\)</span>,而<span class="math inline">\(f^{ - 1 } ( x )\)</span>恰好表示出了<span class="math inline">\(S_2\)</span>.</p>
<h6><span id="example2参数方程曲线面积">Example2(参数方程曲线面积)</span></h6>
<p>回忆到换元法,取参数方程<span class="math inline">\(\begin{cases}x = x
( t ) \\ y = y ( t )\end{cases}\)</span>,此时不妨假设<span class="math inline">\(x ( \alpha ) = a , x ( \beta ) =
b\)</span>,且<span class="math inline">\(x ( t
)\)</span>单调递增且连续,<span class="math inline">\(x &#39; ( t
)\)</span>除有限点外都存在且黎曼可积.那当然应当有:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \text{ d } x = \int_\alpha^\beta y ( t ) x &#39; ( t )
\text{ d } t
\]</span></p>
<p>注意到如果反之条件使得<span class="math inline">\(x ( \alpha ) = b ,
x ( \beta ) = a\)</span>,则需要补一个<span class="math inline">\(-
1\)</span>.</p>
<p>由此可见,对于不自交的任意参数方程表示的曲线,直接积分的正负号一抵消,仍然可以求出曲线下方的面积.如果自交,就是要把自交部分的面积减去.顺便而言,简单封闭曲线(例如圆或者椭圆)当然是上述我们所说的特殊情况.</p>
<p>不过对于封闭曲线,由于转一圈会回到同一个点处,使用分部积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_\alpha^\beta y x &#39; \text{ d } t \\
= &amp; \int_\alpha^\beta y \text{ d } x \\
= &amp; xy |_a^b - \int_\alpha^\beta xy &#39; \text{ d } t \\
= &amp; - \int_\alpha^\beta xy &#39; \text{ d } t
\end{aligned}
\]</span></p>
<p>兼顾一下对称性,可以写作<span class="math inline">\(S = \frac{ 1 }{ 2
} | \int_\alpha^\beta ( x &#39; y - y &#39; x ) \text{ d } t
|\)</span>.由此立刻得到椭圆面积为<span class="math inline">\(ab
\pi\)</span>.</p>
<h6><span id="example3极坐标的面积">Example3(极坐标的面积)</span></h6>
<p>设<span class="math inline">\(r = r ( \theta ) , \theta \in [ \alpha
, \beta ] , r ( \theta ) \in C ( \alpha , \beta )\)</span>.</p>
<p>此时考虑对<span class="math inline">\(\theta\)</span>做划分,取<span class="math inline">\(\Delta : \alpha = \theta_0 &lt; \cdots &lt;
\theta_n = \beta\)</span>,并取<span class="math inline">\(m_i = \inf_{ [
\theta_{ i - 1 } , \theta_i ] } r , M_i = \sup_{ [ \theta_{ i - 1 } ,
\theta_i ] }\)</span>,立刻得到<span class="math inline">\(\frac{ 1 }{ 2
} m_i^2 \Delta \theta_i \leq \Delta S_i \leq \frac{ 1 }{ 2 } \sum M_i^2
\Delta \theta_i\)</span>,这样加密后得到<span class="math inline">\(S =
\frac{ 1 }{ 2 } \int_\alpha^\beta r^2 ( \theta ) \text{ d }
\theta\)</span>.</p>
<h6><span id="example4参数方程曲线的弧长">Example4(参数方程曲线的弧长)</span></h6>
<p>取参数方程<span class="math inline">\(\begin{cases}x = x ( t ) \\ y =
y ( t )\end{cases}\)</span>,并且假设<span class="math inline">\(x ,
y\)</span>均连续.首先我们应当定义其”弧长”的含义.</p>
<p>可以使用折线逼近的策略定义弧长.具体而言,直接取分划<span class="math inline">\(\Delta : \alpha = t_0 &lt; \cdots &lt; t_n =
\beta\)</span>.定义一个点<span class="math inline">\(P_i = ( x ( t_i ) ,
y ( t_i )
)\)</span>,这样我们当然就得到了若干个点,在这些点上就可以将相邻两个点求出折线,设折线长为<span class="math inline">\(\overline{ M_{ i - 1 } M_i }\)</span>.</p>
<p>接下来,称曲线是可求长的,当且仅当取出的折线的上确界是有限的,并将此上确界定义为曲线长.</p>
<p>我们接下来证明,其可求长当且仅当<span class="math inline">\(x ( t
)\)</span>和<span class="math inline">\(y ( t
)\)</span>都是有界变差的.</p>
<p>先看必要性,任取分划<span class="math inline">\(\Delta : \alpha = t_0
&lt; \cdots &lt; t_n = \beta\)</span>.立刻得到<span class="math inline">\(V_\Delta ( x ) = \sum | x_i - x_{ i - 1 } | \leq
\sum \overline{ M_{ i - 1 } M_i }\)</span>,当然是有界的,对于<span class="math inline">\(y ( t )\)</span>同理.</p>
<p>另外,斜边小于两条直角边的和(三角形不等式),于是充分性也显然.</p>
<p>然而真要实际应用需要稍加条件,即:<span class="math inline">\(x ( t ) ,
y ( t
)\)</span>可导且导函数黎曼可积(说明其导函数有界,为李氏连续函数,那自然是有界变差函数).则弧长为<span class="math inline">\(\int_\alpha^\beta \sqrt{ ( x &#39; ( t ) )^2 + ( y
&#39; ( t ) )^2 } \text{ d } t\)</span>.</p>
<p>证明比较容易,考虑勾股定理,<span class="math inline">\(\overline{ M_{
i - 1 } M_i } = \sqrt{ ( x ( t_i ) - x ( t_{ i - 1 } ) )^2 + ( y ( t_i )
- y ( t_{ i - 1 } ) )^2 }\)</span>.使用微分中值定理,得到其等于<span class="math inline">\(\Delta t_i \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y
&#39; ( \eta_i ) )^2 }\)</span>.这里强行换成一个东西,于是就会得到<span class="math inline">\(\Delta t_i \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y
&#39; ( \xi_i ) )^2 } + w_i\)</span>的形式,其中<span class="math inline">\(w_i\)</span>恰为两项之差.然后换黎曼和,只需证明后者<span class="math inline">\(w_i\)</span>随着加密而趋向于<span class="math inline">\(0\)</span>.而这个根号差可以做分子有理化.具体而言:</p>
<p><span class="math display">\[
\begin{aligned}
w_i &amp; = \Delta t_i \left ( \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y
&#39; ( \eta_i ) )^2 } - \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y &#39; (
\xi_i ) )^2 } \right ) \\
&amp; = \Delta t_i \frac{ y &#39; ( \eta_i )^2 - y &#39; ( \xi_i )^2 }{
\sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y &#39; ( \eta_i ) )^2 } + \sqrt{ ( x
&#39; ( \xi_i ) )^2 + ( y &#39; ( \xi_i ) )^2 } } \\
&amp; = \Delta t_i \frac{ ( y &#39; ( \eta_i ) + y &#39; ( \xi_i ) ) }{
\sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y &#39; ( \eta_i ) )^2 } + \sqrt{ ( x
&#39; ( \xi_i ) )^2 + ( y &#39; ( \xi_i ) )^2 } } ( y &#39; ( \eta_i ) -
y &#39; ( \xi_i ) ) \\
&amp; \leq \Delta t_i ( y &#39; ( \eta_i ) - y &#39; ( \xi_i ) )
\end{aligned}
\]</span></p>
<p>最后会得到<span class="math inline">\(\leq \sum \omega_{ y &#39; }
\Delta t_i\)</span>,立刻得到其趋向于<span class="math inline">\(0\)</span>.顺便还要证明这个是上确界,只需要证明加点后答案增加即可,然后用黎曼积分那一部分的对划分取并的技巧即可.</p>
<p>由此应当能推出直角坐标系下弧长公式,即<span class="math inline">\(l =
\int_a^b \sqrt{ 1 + ( f &#39; ( x ) )^2 } \text{ d } x\)</span>.</p>
<h6><span id="example5极坐标下的弧长公式">Example5(极坐标下的弧长公式)</span></h6>
<p>此时应当有<span class="math inline">\(x &#39; = r &#39; \cos \theta -
r \sin \theta , y &#39; = r &#39; \sin \theta + r \cos
\theta\)</span>,注意到<span class="math inline">\(( x &#39; )^2 + ( y
&#39; )^2 = r^2 + ( r &#39; )^2\)</span>,于是极坐标下的公式当然是<span class="math inline">\(l = \int_\alpha^\beta \sqrt{ r^2 + ( r &#39; )^2 }
\text{ d } \theta\)</span>.</p>
<h6><span id="example6等周不等式">Example6(等周不等式)</span></h6>
<p>求给定长度的闭合曲线能围出的最大面积.</p>
<p>设<span class="math inline">\(\Gamma\)</span>是一个周长为<span class="math inline">\(l\)</span>的简单可求长闭曲线,其面积为<span class="math inline">\(A\)</span>,我们下面证明<span class="math inline">\(A \leq \frac{ l^2 }{ 4 \pi }\)</span>.</p>
<p>先考虑<span class="math inline">\(\Gamma\)</span>比较光滑的情况,也就是其有导函数且导函数可积.参数方程给出<span class="math inline">\(l = \int_\alpha^\beta \sqrt{ ( x &#39; )^2 + ( y
&#39; )^2 } \text{ d } \theta\)</span>而<span class="math inline">\(A =
\int_\alpha^\beta xy &#39; \text{ d }
\theta\)</span>.注意这里假设曲线是逆时针方向旋转的.</p>
<p>接下来,考虑在原基础上画个圆,这个圆的参数方程横坐标继承自上述<span class="math inline">\(x ( \theta )\)</span>而纵坐标由圆定义为<span class="math inline">\(\bar{ y } = \pm \sqrt{ r^2 - x^2
}\)</span>,这里的<span class="math inline">\(2 r = \sup x - \inf
x\)</span>.也就是横着的最长距离.为了使得这个圆转起来是合理的,实际上应该找到上述曲线的左右端点然后分段函数定义,我们这里略去此细节.</p>
<p>然后呢,此时观察到应当有<span class="math inline">\(\pi r^2 = -
\int_\alpha^\beta \bar{ y } x &#39; \text{ d }
\theta\)</span>,发挥注意力得到:</p>
<p><span class="math display">\[
\begin{aligned}
2 \sqrt{ A \pi r^2 } &amp; \leq A + \pi r^2 \\
&amp; = \int_\alpha^\beta ( xy &#39; + \bar{ y } x &#39; ) \text{ d }
\theta \\
&amp; \leq \int_\alpha^\beta \sqrt{ x^2 + ( \bar{ y } )^2 } \sqrt{ y
&#39;^2 + x &#39;^2 } \text{ d } t \\
&amp; = rl
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<p>那么不光滑怎么办呢?可以用分段光滑函数(比如折线)逼近,这样就行了.</p>
<h6><span id="example7求多面体体积">Example7(求多面体体积)</span></h6>
<p>体积的定义无非类似面积,用夹逼定理定义任意形状的体积.</p>
<p>考虑对于每个<span class="math inline">\(x\)</span>,在<span class="math inline">\(x\)</span>那里做截面,设得到的截面面积是<span class="math inline">\(S ( x )\)</span>,那么体积感觉上应当是<span class="math inline">\(V = \int_a^b S ( x ) \text{ d } x\)</span>.</p>
<p>然而这个结论的准确证明可能需要一些重积分知识.我们尝试越级打怪,加一个很神秘的条件:就是两个截面之间一定存在包含关系以及<span class="math inline">\(S ( x )\)</span>是关于<span class="math inline">\(x\)</span>连续变化的.然后看看能不能把这个结论证出来.</p>
<p>考虑<span class="math inline">\(x\)</span>的范围是<span class="math inline">\([ a , b ]\)</span>,接下来对其作分划<span class="math inline">\(\Delta : a = x_0 &lt; \cdots &lt; x_n =
b\)</span>.接下来取<span class="math inline">\(\eta_i ,
\xi_i\)</span>满足<span class="math inline">\(S ( \xi_i ) = \max_{ [ x_{
i - 1 } , x_i ] } S ( x ) , S ( \eta_i ) = \min_{ [ x_{ i - 1 } , x_i ]
} S ( x )\)</span>.此时回忆到包含关系,那么我们拿出来的<span class="math inline">\(\xi_i\)</span>和<span class="math inline">\(\eta_i\)</span>当然就是包含别人以及被包含的两个截面,以它们为底面积做柱体,留意到此时当然有:</p>
<p><span class="math display">\[
S ( \eta_i ) ( x_{ i } - x_{ i - 1 } ) \leq V_{ [ x_{ i - 1 } , x_i ] }
\leq S ( \xi_i ) ( x_i - x_{ i - 1 } )
\]</span></p>
<p>回忆到假设<span class="math inline">\(S ( x
)\)</span>是连续变化的因此黎曼可积,于是这个东西两边其实就是达布上下和,立刻得到积分的结论.</p>
<p>旋转体当然满足以上条件,易见旋转体的体积为<span class="math inline">\(\pi \int_a^b f^2 ( x ) \mathrm{ d }
x\)</span>,参数方程同理.</p>
<h6><span id="example8旋转体的侧面积公式">Example8(旋转体的侧面积公式)</span></h6>
<p>曲面的面积难以定义,所以我们现在暂时成为物理系学生.下面只考虑旋转体.</p>
<p>对于旋转体来说,先用折线逼近原曲线,然后旋转后得到若干圆台,用圆台的侧面积之和去逼近旋转体的侧面积.</p>
<p>对于<span class="math inline">\([ a , b
]\)</span>,我们先做一个分划<span class="math inline">\(\Delta : a = x_0
&lt; \cdots &lt; x_n = b\)</span>,<span class="math inline">\(y_i = f (
x_i )\)</span>.圆台侧面积给出<span class="math inline">\(\Delta S_i =
\pi ( y_{ i - 1 } + y_i ) | \overline{ M_{ i - 1 } M_i } | = \pi ( y_{ i
- 1 } + y_i ) \sqrt{ 1 + ( \cfrac{ y_i - y_{ i - 1 } }{ x_i - x_{ i - 1
} } )^2 } \Delta x_i\)</span>,利用微分中值定理,就有:</p>
<p><span class="math display">\[
\begin{aligned}
S_i &amp; = \pi ( y_{ i - 1 } + y_i ) \sqrt{ 1 + ( f &#39; ( \xi_i ) )^2
} \Delta x_i \\
&amp; = 2 \pi f ( \xi_i ) \sqrt{ 1 + ( f &#39; ( \xi_i ) )^2 } \Delta
x_i + ( y_i + y_{ i - 1 } - 2 \pi f ( \xi_i ) ) \sqrt{ 1 + ( f &#39; (
\xi_i ) )^2 } \Delta x_i
\end{aligned}
\]</span></p>
<p>加密后第二项可以用振幅控制住,所以答案就是<span class="math inline">\(2 \pi \int_a^b f ( x ) \sqrt{ 1 + ( f &#39; ( x )
)^2 } \mathrm{ d } x\)</span>.</p>
<p>对于参数方程当然也是平凡的,答案应当是<span class="math inline">\(2
\pi \int_a^b y \sqrt{ 1 + ( \frac{ y &#39; }{ x &#39; } )^2 } x &#39;
\mathrm{ d } t = 2 \pi \int_a^b y \sqrt{ ( x &#39; )^2 + ( y &#39; )^2 }
\mathrm{ d } t\)</span>,注意这里是按照<span class="math inline">\(x\)</span>轴翻转.应当看到由此一段球面上的环的面积就是<span class="math inline">\(2 \pi r \Delta x\)</span>.</p>
<h6><span id="example9pi的无理性证明">Example9(<span class="math inline">\(\pi\)</span>的无理性证明)</span></h6>
<p>假设<span class="math inline">\(\pi = \frac{ p }{ q } \in \mathbb{ Q
}\)</span>并且<span class="math inline">\(p \bot q , p , q \in \mathbb{
N_+ }\)</span>.</p>
<p>考虑设<span class="math inline">\(f_n ( x ) = q^n x^n ( p - qx
)^n\)</span>,留意到<span class="math inline">\(\forall 0 \leq i \leq n -
1\)</span>,有<span class="math inline">\(f_n^{ ( i ) } ( 0 ) = f_n^{ ( i
) } ( \pi ) = 0\)</span>.</p>
<p>接下来考察<span class="math inline">\(\forall n \leq i \leq 2
n\)</span>,此时留意到<span class="math inline">\(f_n^{ ( i ) } ( 0
)\)</span>和<span class="math inline">\(f_n^{ ( i ) } ( \pi
)\)</span>都应当是整数并且是<span class="math inline">\(n
!\)</span>的倍数(是<span class="math inline">\(0\)</span>也是<span class="math inline">\(n !\)</span>的倍数).</p>
<p>考虑积分<span class="math inline">\(I_n = \frac{ 1 }{ n ! }
\int_0^\pi f_n ( x ) \sin x \mathrm{ d } x &gt;
0\)</span>.对其狂暴使用分部积分:</p>
$$
<span class="math display">\[\begin{aligned}
I_n &amp; = \frac{ 1 }{ n ! } \int_0^\pi f_n ( x ) \sin x \mathrm{ d } x
\\
&amp; = \frac{ 1 }{ n ! } \int_0^\pi f_n ( x ) \mathrm{ d } ( - \cos x )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>不断做分部积分,前面扔出来的项也就是<span class="math inline">\(f_n^{
( i ) } ( 0 )\)</span>或者<span class="math inline">\(f_n^{ ( i ) } (
\pi )\)</span>然后再乘上<span class="math inline">\(\sin ,
\cos\)</span>在<span class="math inline">\(0 ,
\pi\)</span>之类取值的问题.总之,这个东西算出来一定是<span class="math inline">\(n !\)</span>的倍数,前面乘了个<span class="math inline">\(\frac{ 1 }{ n !
}\)</span>,他就一定是整数.又因为其大于<span class="math inline">\(0\)</span>,他就一定<span class="math inline">\(\geq 1\)</span>.</p>
<p>那么矛盾在哪呢?留意到<span class="math inline">\(f_n = ( qx ( p - qx
) )^n \leq ( \frac{ p }{ 2 } )^{ 2 n } , \sin x \leq
1\)</span>,所以<span class="math inline">\(I_n \leq \frac{ 1 }{ n ! } (
\frac{ p }{ 2 } )^{ 2 n } \pi \to 0\)</span>.</p>
<h6><span id="example10古鲁金第一定理">Example10(古鲁金第一定理)</span></h6>
<p>躲开微元法,要证明一些东西可以扔进去的话(比如密度函数),应当可以通过”平均密度”的概念用之前那个引理(分部积分那里,步骤是先积分,乘系数,后求和),总之都是平凡的.</p>
<p>考虑一个旋转体,反正用上面那套东西,搞出来质心应当有<span class="math inline">\(\bar{ y } = \frac{ \int_\alpha^\beta y \sqrt{ x
&#39;^2 + y &#39;^2 } \mathrm{ d } t }{ l }\)</span>.移项得到<span class="math inline">\(2 \pi \bar{ y } l = 2 \pi \int_\alpha^\beta y
\sqrt{ x &#39;^2 + y &#39;^2 } \mathrm{ d }
t\)</span>.也就是:旋转线转一圈,质心周长乘以曲线的弧长等于侧面积.</p>
<h6><span id="example11古鲁金第二定理">Example11(古鲁金第二定理)</span></h6>
<p>考虑两条曲线夹起来的部分,也就是设<span class="math inline">\([ a , b
]\)</span>上有<span class="math inline">\(f ( x ) \geq g ( x ) \geq
0\)</span>,那这两条线就会围出一块二维出来.这一块的质心能不能求呢?当然也可以,只不过略有区别,<span class="math inline">\(\bar{ x } = \frac{ \int_a^b x ( f ( x ) - g ( x )
\mathrm{ d } x ) }{ S }\)</span>,而<span class="math inline">\(\bar{ y }
= \frac{ 1 }{ 2 } \frac{ \int_a^b ( f^2 ( x ) - g^2 ( x ) \mathrm{ d } x
) }{ S }\)</span>.移项得到<span class="math inline">\(2 S \bar{ y } =
\int_a^b ( f^2 ( x ) - g^2 ( x ) \mathrm{ d } x
)\)</span>,也就是旋转面转一圈,质心周长乘以面积等于体积.</p>
<h6><span id="example12转动惯量">Example12(转动惯量)</span></h6>
<p>定义为<span class="math inline">\(J = \int mr^2\)</span>.</p>
<p>考虑以<span class="math inline">\(x\)</span>轴为旋转轴,先考虑线的情况,无非是分成小段每一段分别处理,对于每一段用长度和密度的乘积来逼质量,关于<span class="math inline">\(x\)</span>轴的转动惯量<span class="math inline">\(J = \int_\alpha^\beta y^2 ( t ) \rho ( t ) \sqrt{
( x &#39; ( t ) )^2 + ( y &#39; ( t ) )^2 } \text{ d } t\)</span>.</p>
<h6><span id="example13">Example13</span></h6>
<p>设<span class="math inline">\(F\)</span>是所有满足<span class="math inline">\(f \in C^1 [ 0 , 1 ] \mid f ( 0 ) = 0 , f ( 1 ) = 1
, f &#39; \geq 0\)</span>,<span class="math inline">\(f
&#39;\)</span>单调不降的函数<span class="math inline">\(f\)</span>组成的集合,记<span class="math inline">\(S_f\)</span>为<span class="math inline">\(f ( x
)\)</span>绕<span class="math inline">\(x\)</span>轴转一圈得到的侧面积,求<span class="math inline">\(\sup_{ f \in F } S_f\)</span>和<span class="math inline">\(\inf_{ f \in F } S_f\)</span>.</p>
<p>先猜下确界是<span class="math inline">\(\pi\)</span>,上确界是<span class="math inline">\(\sqrt{ 2 } \pi\)</span>.</p>
<p>先证明下界是对的,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S_f &amp; = 2 \pi \int_0^1 f \sqrt{ 1 + ( f &#39; )^2 } \mathrm{ d } x
\geq 2 \pi \int_0^1 f \cdot f &#39; \mathrm{ d } x \\
&amp; = \pi
\end{aligned}
\]</span></p>
<p>怎么逼近呢?这个当然是直接平的是最优秀的对吧,考虑<span class="math inline">\(f_n ( x ) = x^n\)</span>,发现:</p>
<p><span class="math display">\[
\pi \leq S_{ f_n } \leq 2 \pi \int_0^1 f_n ( 1 + f_n &#39; ) \mathrm{ d
} x = \pi + 2 \pi \int_0^1 f_n \mathrm{ d } x = \pi + \frac{ 2 \pi }{ n
+ 1 } \to \pi
\]</span></p>
<p>上界怎么搞定呢?考虑肯定是<span class="math inline">\(f ( x ) =
x\)</span>是最好的,我们下面证明任意一段曲线,如果把曲线拉直就更优秀.</p>
<p>也就是考虑<span class="math inline">\(( 0 , 0 )\)</span>和<span class="math inline">\(( x_0 , f ( x_0 ) )\)</span>的连线<span class="math inline">\(y = \frac{ f ( x_0 ) }{ x_0 }
x\)</span>,容易见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ x_0 } y \sqrt{ 1 + ( y &#39; )^2 } \mathrm{ d } x \\
= &amp; \int_0^{ x_0 } \frac{ f ( x_0 ) }{ x_0 } x \sqrt{ 1 + ( \frac{ f
( x_0 ) }{ x_0 } )^2 } \mathrm{ d } x \\
= &amp; \frac{ 1 }{ 2 } f ( x_0 ) \sqrt{ x_0^2 + f ( x_0 )^2 }
\end{aligned}
\]</span></p>
<p>只要我们证明:</p>
<p><span class="math display">\[
\int_0^x f ( t ) \sqrt{ 1 + ( f &#39; ( t ) )^2 } \mathrm{ d } t \leq
\frac{ 1 }{ 2 } f ( x ) \sqrt{ x^2 + f^2 ( x ) }
\]</span></p>
<p>即可.注意到它们在零点的取值相同,因此直接算导数之差,要证:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ 2 } f &#39; \sqrt{ x^2 + f^2 } + \frac{ x + f \cdot f &#39;
}{ 2 \sqrt{ x^2 + f^2 } } f - f \sqrt{ 1 + ( f &#39; )^2 } &amp; \geq 0
\\
2 f \sqrt{ 1 + ( f &#39; )^2 } \sqrt{ x^2 + f^2 } &amp; \leq ( x^2 + 2
f^2 ) f &#39; + xf
\end{aligned}
\]</span></p>
<p>敢算就敢赢,两边平方得到:</p>
<p><span class="math display">\[
3 f^2 x^2 + 4 f^4 \leq x^4 ( f &#39; )^2 + 2 x^3 f \cdot f &#39; + 2
xf^3 f &#39;
\]</span></p>
<p>注意到下凸函数满足<span class="math inline">\(f &#39; \geq \frac{ f
}{ x }\)</span>,上述结论刚刚好得证,出这个题的lwg老师真是高人了.</p>
<h5><span id="定积分近似计算">定积分近似计算</span></h5>
<p>考虑对<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d }
x\)</span>做数值近似,将<span class="math inline">\([ a , b
]\)</span>等分,取<span class="math inline">\(x_k = a + \frac{ k }{ n } (
b - a )\)</span>,其中<span class="math inline">\(0 \leq k \leq
n\)</span>,而<span class="math inline">\(\Delta x = \frac{ b - a }{ n
}\)</span>,<span class="math inline">\(x_{ k - \frac{ 1 }{ 2 } } =
\frac{ x_k + x_{ k - 1 } }{ 2 }\)</span>.</p>
<p>那么用黎曼和逼积分,那么无非三种方式:要么算左端点的函数值,要么算右端点的函数值,要么算中间点的函数值.</p>
<p>问题在于计算误差,我们下面证明,如果<span class="math inline">\(f\)</span>一阶可导,则:</p>
<ol type="1">
<li><p><span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x =
\frac{ b - a }{ n } \sum_{ k = 1 }^n y_k - \frac{ ( b - a )^2 }{ 2 n } f
&#39; ( \xi )\)</span></p></li>
<li><p><span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x =
\frac{ b - a }{ n } \sum_{ k = 1 }^n y_{ k - 1 } + \frac{ ( b - a )^2 }{
2 n } f &#39; ( \eta )\)</span></p></li>
</ol>
<p>两个是类似的,只证第一个,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f ( x ) \mathrm{ d } x - \frac{ b - a }{ n } \sum_{ k = 1
}^n y_k \\
= &amp; \sum_{ k = 1 }^n \int_{ x_{ k - 1 } }^{ x_k } ( f ( x ) - f (
x_k ) ) \mathrm{ d } x \\
= &amp; \sum_{ k = 1 }^n \int_{ x_{ k - 1 } }^{ x_k } ( f ( x ) - f (
x_k ) ) \mathrm{ d } ( x - x_{ k - 1 } ) \\
= &amp; - \sum_{ k = 1 }^n \int_{ x_{ k - 1 } }^{ x_k } ( x - x_{ k - 1
} ) f &#39; ( x ) \mathrm{ d } x \\
= &amp; - \sum_{ k = 1 }^n f &#39; ( \xi_k ) \int_{ x_{ k - 1 } }^{ x_k
} ( x - x_{ k - 1 } ) \mathrm{ d } x \\
= &amp; - \sum_{ k = 1 }^n f &#39; ( \xi_k ) \frac{ ( b - a )^2 }{ 2 n^2
} \\
= &amp; - \frac{ ( b - a )^2 }{ 2 n } f &#39; ( \xi )
\end{aligned}
\]</span></p>
<p>最后一步是因为求均值也可以用介值定理.</p>
<p>那么在中点估计会怎么样呢?考虑给<span class="math inline">\(f\)</span>更好的条件,让<span class="math inline">\(f\)</span>二阶可导,则:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \mathrm{ d } x = \frac{ b - a }{ n } \sum_{ k = 1 }^n
y_{ k - \frac{ 1 }{ 2 } } - \frac{ ( b - a )^3 }{ 24 n^2 } f &#39; &#39;
( \xi )
\]</span></p>
<p>在<span class="math inline">\(x_{ k - \frac{ 1 }{ 2 }
}\)</span>处做泰勒展开,应当有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( x ) - f ( x_{ k - \frac{ 1 }{ 2 } } ) &amp; = ( x - x_{ k - \frac{ 1
}{ 2 } } ) f &#39; ( x_{ k - \frac{ 1 }{ 2 } } ) + \frac{ 1 }{ 2 } ( x -
x_{ k - \frac{ 1 }{ 2 } } )^2 f &#39; &#39; ( \xi_k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设<span class="math inline">\(m_k \leq f &#39; &#39; ( \xi_k )
\leq M_k\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
\int_{ x_{ k - 1 } }^{ x_k } ( f ( x ) - f ( x_{ k - \frac{ 1 }{ 2 } } )
) \mathrm{ d } x &amp; \leq \frac{ M_k }{ 2 } \int_{ x_{ k - 1 } }^{ x_k
} ( x - x_{ k - \frac{ 1 }{ 2 } } )^2 \mathrm{ d } x \\
&amp; = M_k \frac{ ( b - a )^3 }{ 24 n^3 }
\end{aligned}
\]</span></p>
<p>用介值定理就可以求和,原命题自然得证.</p>
<p>而上面的做法是矩形逼近,能不能用梯形逼近呢?用梯形逼近的话其实无非是<span class="math inline">\(\frac{ b - a }{ n } ( \frac{ y_0 + y_n }{ 2 }
\sum_{ k = 1 }^{ n - 1 } y_k )\)</span>,然而,对于<span class="math inline">\(f \in C^2 [ a , b ]\)</span>,我们声明:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \mathrm{ d } x = \frac{ b - a }{ n } ( \frac{ y_0 + y_n
}{ 2 } \sum_{ k = 1 }^{ n - 1 } y_k ) - \frac{ ( b - a )^3 }{ 12 n^2 } f
&#39; &#39; ( \xi )
\]</span></p>
<p>证明当然还是分部积分,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } x \\
= &amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } ( x - x_{ k -
1 } ) \\
= &amp; f ( x_k ) \frac{ b - a }{ n } - \int_{ x_{ k - 1 } }^{ x_k } ( x
- x_{ k - 1 } ) f &#39; ( x ) \mathrm{ d } x \\
= &amp; f ( x_k ) \frac{ b - a }{ n } - \frac{ 1 }{ 2 } \int_{ x_{ k - 1
} }^{ x_k } f &#39; ( x ) \mathrm{ d } ( x - x_{ k - 1 } )^2 \\
= &amp; f ( x_k ) \frac{ b - a }{ n } - \frac{ 1 }{ 2 } f &#39; ( x_k )
( \frac{ b - a }{ n } )^2 + \frac{ 1 }{ 2 } \int_{ x_{ k - 1 } }^{ x_k }
f &#39; &#39; ( x ) ( x - x_{ k - 1 } )^2 \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>同理,在上面换<span class="math inline">\(x - x_k\)</span>而非<span class="math inline">\(x - x_{ k - 1 }\)</span>,就可以得到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } x \\
= &amp; f ( x_{ k - 1 } ) \frac{ b - a }{ n } + \frac{ 1 }{ 2 } f &#39;
( x_{ k - 1 } ) ( \frac{ b - a }{ n } )^2 + \frac{ 1 }{ 2 } \int_{ x_{ k
- 1 } }^{ x_k } f &#39; &#39; ( x ) ( x - x_{ k } )^2 \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时用NL公式,应当能见到把上面两式子相加可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } x \\
= &amp; \frac{ f ( x_{ k - 1 } ) + f ( x_k ) }{ 2 } \frac{ b - a }{ n }
+ \frac{ 1 }{ 4 } \int_{ x_{ k - 1 } }^{ x_k } f &#39; &#39; ( x ) ( ( x
- x_{ k } )^2 + ( x - x_{ k - 1 } )^2 - ( \frac{ b - a }{ n } )^2 )
\mathrm{ d } x \\
= &amp; \frac{ f ( x_{ k - 1 } ) + f ( x_k ) }{ 2 } \frac{ b - a }{ n }
+ \frac{ 1 }{ 2 } \int_{ x_{ k - 1 } }^{ x_k } f &#39; &#39; ( x ) ( x -
x_k ) ( x - x_{ k - 1 } ) \mathrm{ d } x \\
= &amp; \frac{ f ( x_{ k - 1 } ) + f ( x_k ) }{ 2 } \frac{ b - a }{ n }
+ \frac{ 1 }{ 2 } f &#39; &#39; ( \xi_k ) \int_{ x_{ k - 1 } }^{ x_k } (
x - x_k ) ( x - x_{ k - 1 } ) \mathrm{ d } x \\
= &amp; \frac{ y_{ k - 1 } + y_k }{ 2 } \Delta x - \frac{ 1 }{ 12 } f
&#39; &#39; ( \xi_k ) \frac{ ( b - a )^3 }{ n^3 }
\end{aligned}
\]</span></p>
<p>这样就完事了,接下来对<span class="math inline">\(n\)</span>求个和就能得到之前的公式.</p>
<p>接下来是二次曲线逼近.考虑用<span class="math inline">\(( x_{ k - 1 }
, y_{ k - 1 } ) , ( x_{ k - \frac{ 1 }{ 2 } } , y_{ k - \frac{ 1 }{ 2 }
} ) , ( x_k , y_k
)\)</span>三个点确定一条二次曲线.不妨设这条二次曲线为<span class="math inline">\(Q_k ( x ) = px^2 + qx +
r\)</span>.然而,此时观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } Q_k ( x ) \mathrm{ d } x \\
= &amp; \frac{ p }{ 3 } ( x_k^3 - x_{ k - 1 }^3 ) + \frac{ q }{ 2 } (
x_k^2 - x_{ k - 1 }^2 ) + r ( x_k - x_{ k - 1 } ) \\
= &amp; \frac{ x_k - x_{ k - 1 } }{ 6 } ( Q_k ( x_k ) + Q_k ( x_{ k - 1
} ) + Q_k ( x_{ k - \frac{ 1 }{ 2 } } ) ) \\
= &amp; \frac{ b - a }{ 6 n } ( y_{ k - 1 } + y_k + 4 y_{ k - \frac{ 1
}{ 2 } } )
\end{aligned}
\]</span></p>
<p>这也很合理,观察一下就可以知道这个恰好是在尝试把梯形逼近和中点逼近两种方式尝试约掉后面的误差项系数.</p>
<p>定理是,如果<span class="math inline">\(f \in C^4 [ a , b
]\)</span>,误差项为<span class="math inline">\(- \frac{ ( b - a )^5 }{
2880 n^4 } f^{ ( 4 ) } ( \xi )\)</span>.这就是所谓辛普森积分法.</p>
<h5><span id="广义积分">广义积分</span></h5>
<p>考虑函数<span class="math inline">\(f : [ a , + \infty ) \to \mathbb{
R }\)</span>,如果其<span class="math inline">\(\forall b &gt;
a\)</span>,<span class="math inline">\(f \in R [ a , b
]\)</span>,我们称其<strong>内闭可积</strong>.那我们就定义其广义积分为<span class="math inline">\(\int_a^{ + \infty } f \mathrm{ d } x = \lim_{ b
\to + \infty } \int_a^b f \mathrm{ d }
x\)</span>,当后者极限存在时.同理当然可以定义区间<span class="math inline">\(( - \infty , b ]\)</span>上的广义积分.而如果<span class="math inline">\(\int_0^{ + \infty } f \mathrm{ d }
x\)</span>和<span class="math inline">\(\int_{ - \infty }^0 f \mathrm{ d
} x\)</span>都收敛,则定义它们的和为<span class="math inline">\(\int_{ -
\infty }^{ + \infty } f \mathrm{ d } x\)</span>.</p>
<p>称一个函数的<strong>瑕点</strong>为其局部无界的点,则考虑<span class="math inline">\(f : [ a , b ) \to \mathbb{ R }\)</span>,其中<span class="math inline">\(b\)</span>是<span class="math inline">\(f\)</span>的瑕点,且<span class="math inline">\(f\)</span>内闭可积,则<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x = \lim_{ A \to b -
0 } \int_a^A f ( x ) \mathrm{ d }
x\)</span>,若后者极限存在.瑕积分和上述广义积分并无明显区别,下述也不再区分.</p>
<p>在进一步讨论前,我们应当再仔细研究一下广义积分的收敛性,也就是当什么时候其极限存在呢?我们有以下命题:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( x ) \geq 0 , x \in [ a , + \infty
)\)</span>时,<span class="math inline">\(F ( A ) = \int_a^A f ( x )
\mathrm{ d } x\)</span>单增.那么此时<span class="math inline">\(F ( +
\infty )\)</span>存在当且仅当<span class="math inline">\(F ( A
)\)</span>有界.</p></li>
<li><p>比较原理:<span class="math inline">\(0 \leq f \leq cg , c &gt;
0\)</span>,若<span class="math inline">\(\int_a^{ + \infty } g \mathrm{
d } x\)</span>收敛,则<span class="math inline">\(\int_a^{ + \infty } f
\mathrm{ d } x\)</span>收敛.该结论可以移植到瑕积分上.</p></li>
<li><p>比较原理的推论:<span class="math inline">\(f , g \geq 0 , 0 &lt;
c_1 \leq \frac{ f }{ g } \leq c_2\)</span>,则<span class="math inline">\(\int f \mathrm{ d } x , \int g \mathrm{ d }
x\)</span>收敛性相同.进一步地,如果<span class="math inline">\(f , g \geq
0\)</span>,在趋近于某个瑕点的时候,<span class="math inline">\(\frac{ f
}{ g }\)</span>趋近于某个非零常数,那它们在这一点的收敛性相同.</p></li>
</ol>
<p>(1)是根据单调收敛准则,而(2)则是(1)的推论,只是给出了一个界.</p>
<p>定义函数<span class="math inline">\(f\)</span>是<strong>绝对收敛</strong>,当<span class="math inline">\(\int_a^{ + \infty } | f | \mathrm{ d } x &lt;
\infty\)</span>时.而考虑<span class="math inline">\(f = | f | - ( | f |
- f )\)</span>,而<span class="math inline">\(0 \leq | f | - f \leq 2 | f
|\)</span>,所以绝对收敛可以推出收敛,但反之不可.因此,我们将收敛但不绝对收敛的函数称为<strong>条件收敛</strong>.该结论也可以移植到瑕积分上.</p>
<p>接下来,我们有<strong>柯西收敛原理</strong>:<span class="math inline">\(\int_a^{ + \infty } f \mathrm{ d }
x\)</span>收敛的充要条件是对于<span class="math inline">\(\forall
\epsilon &gt; 0 , \exists M &gt; a\)</span>使得<span class="math inline">\(\forall A &gt; B \geq M\)</span>,都有<span class="math inline">\(| \int_{ B }^A f \mathrm{ d } x | &lt;
\epsilon\)</span>.</p>
<p>证明当然无非是函数部分柯西收敛准则的重复应用.</p>
<p>柯西收敛原理推到瑕积分上的话,考虑<span class="math inline">\(F ( x )
= \int_a^x f ( t ) \mathrm{ d } t\)</span>,则瑕积分<span class="math inline">\(\lim_{ t \to b - 0 } F ( t
)\)</span>存在当且仅当<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists \delta &gt;
0\)</span>,当<span class="math inline">\(x_1 , x_2 \in ( b - \delta , b
)\)</span>的时候,有<span class="math inline">\(| F ( x_1 ) - F ( x_2 ) |
&lt; \epsilon\)</span>.</p>
<p>接下来还有<strong>Dirichlet-Abel判别法</strong>,设<span class="math inline">\(f , g : [ a , + \infty ) \to \mathbb{ R
}\)</span>内闭可积,<span class="math inline">\(f\)</span>单调,那有:</p>
<ol type="1">
<li><p>Dirichlet判别法:如果<span class="math inline">\(f ( + \infty ) =
0\)</span>,<span class="math inline">\(G ( A ) = \int_a^A g \mathrm{ d }
x\)</span>有界,则<span class="math inline">\(\int_a^{ + \infty } fg
\mathrm{ d } x\)</span>收敛.</p></li>
<li><p>Abel判别法:如果<span class="math inline">\(f\)</span>有界,<span class="math inline">\(\int_a^{ \infty } g \mathrm{ d }
x\)</span>收敛,则<span class="math inline">\(\int_a^{ + \infty } fg
\mathrm{ d } x\)</span>收敛.</p></li>
</ol>
<p>用第二积分中值定理,就有<span class="math inline">\(\int_A^B f g
\mathrm{ d } x = f ( A ) \int_A^\xi g \mathrm{ d } x + f ( B ) \int_{
\xi }^B g \mathrm{ d }
x\)</span>.用柯西收敛原理则上述两条均为显然.结论当然可以推广到瑕积分上.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f\)</span>在<span class="math inline">\(( - \infty , + \infty )\)</span>上内闭可积,且<span class="math inline">\(f ( + \infty ) = A , f ( - \infty ) =
B\)</span>,对于<span class="math inline">\(a &gt; 0\)</span>,求证<span class="math inline">\(\int_{ - \infty }^{ + \infty } \left ( f ( x + a )
- f ( x ) \right ) \mathrm{ d } x\)</span>收敛并求其值.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^{ C } \left ( f ( x + a ) - f ( x ) \right ) \mathrm{ d } x &amp;
= \int_{ a }^{ C + a } f ( x ) \mathrm{ d } x - \int_0^C f ( x )
\mathrm{ d } x \\
&amp; = \int_{ C }^{ C + a } f ( x ) \mathrm{ d } x - \int_0^a f ( x )
\mathrm{ d } x \\
&amp; \to aA - \int_0^a f ( x ) \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>另一侧同理为:</p>
<p><span class="math display">\[
\begin{aligned}
\int_{ - C }^{ 0 } \left ( f ( x + a ) - f ( x ) \right ) \mathrm{ d } x
&amp; = \int_{ - C + a }^{ a } f ( x ) \mathrm{ d } x - \int_{ - C }^0 f
( x ) \mathrm{ d } x \\
&amp; = - \int_{ - C }^{ - C + a } f ( x ) \mathrm{ d } x + \int_0^a f (
x ) \mathrm{ d } x \\
&amp; \to - aB + \int_0^a f ( x ) \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>于是答案是<span class="math inline">\(a ( A - B )\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:</p>
<p><span class="math display">\[
\int_{ 1 }^{ + \infty } \frac{ \mathrm{ d } x }{ x^p } = \begin{cases}
\lt \infty &amp; p \gt 1 \\
\infty &amp; p \leq 1
\end{cases}
\]</span></p>
<p>显然.</p>
<h6><span id="example3">Example3</span></h6>
<p>求证:<span class="math inline">\(\int_a^{ + \infty } \frac{ \sin^2 x
}{ x^2 } \mathrm{ d } x\)</span>收敛.</p>
<p>原因是由比较原理,所以<span class="math inline">\(0 \leq \frac{ \sin^2
x }{ x^2 } \leq \frac{ 1 }{ x^2 }\)</span>,立刻知其收敛性.</p>
<h6><span id="example4">Example4</span></h6>
<p>判断<span class="math inline">\(\int_0^{ + \infty } \frac{ x \mathrm{
d } x }{ 1 + x^4 \sin^2 x }\)</span>的收敛性.</p>
<p>考虑取<span class="math inline">\(F ( A ) = \int_0^A \frac{ x
\mathrm{ d } x }{ 1 + x^4 \sin^2 x }\)</span>,接下来考虑<span class="math inline">\(F ( n \pi ) = \sum_{ k = 1 }^n
U_k\)</span>,其中<span class="math inline">\(U_k = \int_{ ( k - 1 ) \pi
}^{ k \pi } \frac{ x \mathrm{ d } x }{ 1 + x^4 \sin^2 x }\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
U_k &amp; = \int_{ ( k - 1 ) \pi }^{ k \pi } \frac{ x \mathrm{ d } x }{
1 + x^4 \sin^2 x } \\
&amp; \geq \int_{ ( k - 1 ) \pi }^{ k \pi } \frac{ x \mathrm{ d } x }{ 1
+ ( k \pi )^4 \sin^2 x } \\
&amp; \geq 2 ( k - 1 ) \pi \int_{ 0 }^{ \frac{ \pi }{ 2 } } \frac{ x
\mathrm{ d } x }{ 1 + ( k \pi )^4 ( \sin x )^2 } \\
&amp; \geq 2 ( k - 1 ) \pi \int_{ 0 }^{ \frac{ \pi }{ 2 } } \frac{ x
\mathrm{ d } x }{ 1 + ( k \pi )^4 x^2 } \\
&amp; = \frac{ 2 ( k - 1 ) \pi }{ k^2 \pi^2 } \arctan ( k^2 \pi^2 x )
|_0^{ \frac{ \pi }{ 2 } } \\
&amp; \geq \frac{ 2 ( k - 1 ) \pi }{ k^2 \pi^2 } \arctan ( \frac{ \pi^3
}{ 2 } ) \\
&amp; = O ( \frac{ 1 }{ k } )
\end{aligned}
\]</span></p>
<p>这就证完了,必然发散.</p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(f : ( - \infty , + \infty ) \to \mathbb{
R }\)</span>且内闭可积,<span class="math inline">\(p &gt;
0\)</span>,并且<span class="math inline">\(\int_{ - \infty }^{ + \infty
} | f |^p \mathrm{ d } x &lt; \infty\)</span>,求证<span class="math inline">\(\lim_{ h \to 0 } \int_{ - \infty }^{ + \infty }
\left | f ( x + h ) - f ( x ) \right |^p \mathrm{ d }
x\)</span>收敛.</p>
<p>既然<span class="math inline">\(\int_{ - \infty }^{ + \infty } | f
|^p \mathrm{ d } x &lt; \infty\)</span>,那么一定存在一个足够大的<span class="math inline">\(A\)</span>,使得<span class="math inline">\(\int_{
A }^{ + \infty } | f |^p \mathrm{ d }
x\)</span>足够小,不妨取足够大的<span class="math inline">\(A &gt;
0\)</span>使得<span class="math inline">\(\int_{ A - 1 }^{ + \infty } |
f |^p \mathrm{ d } x &lt; \epsilon_1\)</span>.</p>
<p>事实上考虑<span class="math inline">\(| u + v | \leq | u | + | v |
\leq 2 \max ( | u | , | v | )\)</span>,那么<span class="math inline">\(|
u + v |^p \leq 2^p ( | u |^p + | v |^p )\)</span>,取<span class="math inline">\(| h | &lt; 1\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ A }^{ + \infty } \left | f ( x + h ) - f ( x ) \right |^p
\mathrm{ d } x \\
\leq &amp; 2^p \int_{ A }^{ + \infty } | f ( x + h ) |^p \mathrm{ d } x
+ 2^p \int_{ A }^{ + \infty } | f ( x ) |^p \mathrm{ d } x \\
= &amp; 2^p \int_{ A + h }^{ + \infty } | f ( x ) |^p \mathrm{ d } x +
2^p \int_{ A }^{ + \infty } | f ( x ) |^p \mathrm{ d } x \\
\leq &amp; 2^{ p + 1 } \int_{ A - 1 }^{ + \infty } | f |^p \mathrm{ d }
x \\
\leq &amp; 2^{ p + 1 } \epsilon_1
\end{aligned}
\]</span></p>
<p>同理,另一侧也可以放掉.现在的问题在于<span class="math inline">\(( - A
+ 1 , A - 1 )\)</span>中间这一段.</p>
<p>考虑用一个线性函数逼近,做分划<span class="math inline">\(\Delta : - A
+ 1 = x_0 &lt; \cdots &lt; x_n = A -
1\)</span>,取线性函数逼近,策略为<span class="math inline">\(x \in [ x_{
k - 1 } , x_k ]\)</span>的时候<span class="math inline">\(g ( x ) =
\frac{ f ( x_k ) - f ( x_{ k - 1 } ) }{ x_k - x_{ k - 1 } } ( x - x_{ k
- 1 } ) + f ( x_{ k - 1 } )\)</span>.接下来考虑对于每一段,设<span class="math inline">\(M_k = \sup_{ [ x_{ k - 1 } , x_k ] } f , m_k =
\inf_{ [ x_{ k - 1 } , x_k ] } f\)</span>,则每一段可以被控制为<span class="math inline">\(M_k -
m_k\)</span>.我们早在之前就提过黎曼可积的函数可被线性函数逼近,然而疑问是这种逼近能否在<span class="math inline">\(p\)</span>次方意义下满足,于是取足够小的划分使得<span class="math inline">\(\sum_{ k = 1 }^n ( M_k - m_k ) \Delta x_k &lt;
\epsilon_2^2\)</span>.</p>
<p>接下来常规分治,取<span class="math inline">\(C = \{ 1 \leq k \leq n |
M_k - m_k \geq \epsilon_2 \}\)</span>而<span class="math inline">\(B =
\{ 1 \leq k \leq n | M_k - m_k &lt; \epsilon_2 \}\)</span>.见到<span class="math inline">\(\sum_{ k \in C } \Delta x_k &lt;
\epsilon_2\)</span>.不妨设<span class="math inline">\(M = \sup_{ [ - A +
1 , A - 1 ] } f , m = \inf_{ [ - A + 1 , A - 1 ] } f\)</span>立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ - A + 1 }^{ A - 1 } \left | f - g \right |^p \mathrm{ d } x
\\
\leq &amp; \sum_{ k } | M_k - m_k |^p \Delta x_k \\
= &amp; \sum_{ k \in C } | M_k - m_k |^p \Delta x_k + \sum_{ k \in B } |
M_k - m_k |^p \Delta x_k \\
\leq &amp; | M - m |^p \epsilon_2 + \epsilon_2^p ( 2 A - 2 )
\end{aligned}
\]</span></p>
<p>这样这里就被限制住了,而考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ - \infty }^{ + \infty } \left | f ( x + h ) - f ( x )
\right |^p \mathrm{ d } x \\
\leq &amp; \int_{ - \infty }^{ + \infty } 3^p \left ( \left | f ( x + h
) - g ( x + h ) \right |^p + \left | g ( x + h ) - g ( x ) \right |^p +
\left | f ( x ) - g ( x ) \right |^p \right ) \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>前后两项都能被上述控制住,只剩中间的<span class="math inline">\(| g (
x + h ) - g ( x ) |^p\)</span>是<span class="math inline">\(O ( h^p
)\)</span>的,只需调整<span class="math inline">\(h\)</span>就能控制住.</p>
<h6><span id="example6">Example6</span></h6>
<p>求证:<span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{
x } \mathrm{ d } x\)</span>是条件收敛的.</p>
<p>用DA判别法,取<span class="math inline">\(f = \frac{ 1 }{ x
}\)</span>当然趋近于<span class="math inline">\(0\)</span>,而<span class="math inline">\(| \int_1^A \sin x \mathrm{ d } x | \leq
2\)</span>,于是收敛.</p>
<p>那接下来就要证明它并非绝对收敛.只需考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_1^{ + \infty } \frac{ | \sin x | }{ x } \mathrm{ d } x \\
\geq &amp; \int_1^{ + \infty } \frac{ \sin^2 x }{ x } \mathrm{ d } x \\
= &amp; \int_1^{ + \infty } \frac{ 1 - \cos^2 x }{ x } \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>当然并不绝对收敛.</p>
<p>事实上还可以直接求出来这个积分的值.</p>
<p>接下来考虑<span class="math inline">\(f ( x ) = \begin{cases}0 &amp;
x = 0 \\ \frac{ 1 }{ x } - \frac{ 1 }{ 2 \sin \frac{ x }{ 2 } } &amp; x
\in [ - \pi , \pi ] \setminus \{ 0
\}\end{cases}\)</span>.只需泰勒展开就知道它是解析的.回忆到黎曼引理:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \infty } \frac{ \sin x }{ x } \mathrm{ d } x \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ ( n + \frac{ 1 }{ 2 } ) \pi
} \frac{ \sin x }{ x } \mathrm{ d } x \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \frac{ \sin ( ( n +
\frac{ 1 }{ 2 } ) t ) }{ t } \mathrm{ d } t \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \left ( f ( t ) +
\frac{ 1 }{ 2 \sin \frac{ t }{ 2 } } \right ) \sin ( ( n + \frac{ 1 }{ 2
} ) t ) \mathrm{ d } t \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \frac{ 1 }{ 2 \sin
\frac{ t }{ 2 } } \sin ( ( n + \frac{ 1 }{ 2 } ) t ) \mathrm{ d } t \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \left ( \frac{ 1 }{ 2
} + \sum_{ k = 1 }^n \cos ( kt ) \right ) \mathrm{ d } t \\
= &amp; \frac{ \pi }{ 2 }
\end{aligned}
\]</span></p>
<h6><span id="example7">Example7</span></h6>
<p>给定<span class="math inline">\(f \in C [ 0 , + \infty
]\)</span>,<span class="math inline">\(\int_0^{ + \infty } f^2 \mathrm{
d } x &lt; + \infty , f ( 0 ) = 0\)</span>,取<span class="math inline">\(g ( x ) = \int_0^x f ( t ) \mathrm{ d }
t\)</span>,求证:<span class="math inline">\(\int_0^{ + \infty } \frac{
g^2 ( x ) }{ x^2 } \mathrm{ d } x \leq 4 \int_0^{ + \infty } f^2
\mathrm{ d } x\)</span>以证明前者存在.</p>
<p>当然是分部积分,用洛必达法则知道<span class="math inline">\(\lim_{ x
\to 0 } \frac{ g }{ x } \to 0\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^A \frac{ g^2 }{ x^2 } \mathrm{ d } x &amp; = \int_0^A g^2
\mathrm{ d } ( - \frac{ 1 }{ x } ) \\
&amp; = - \frac{ g^2 ( x ) }{ x } |_0^A + \int_0^A \frac{ 2 gf }{ x }
\mathrm{ d } x \\
&amp; = - \frac{ g^2 ( A ) }{ A } + 2 \int_0^A \frac{ g }{ x } f
\mathrm{ d } x \\
&amp; \leq 2 ( \int_0^A \frac{ g^2 }{ x^2 } \mathrm{ d } x )^{ \frac{ 1
}{ 2 } } ( \int_0^A f^2 \mathrm{ d } x )^{ \frac{ 1 }{ 2 } }
\end{aligned}
\]</span></p>
<p>整理一下就做完了.</p>
<h6><span id="example8欧拉积分">Example8(欧拉积分)</span></h6>
<p>求<span class="math inline">\(\int_0^{ + \infty } \frac{ x^{ p - 1 }
}{ 1 + x } \mathrm{ d } x , 0 &lt; p &lt; 1\)</span>的收敛性和值.</p>
<p>考虑<span class="math inline">\(\frac{ x^{ p - 1 } }{ 1 + x
}\)</span>在<span class="math inline">\(x \to
0\)</span>的时候趋近于<span class="math inline">\(x^{ p - 1
}\)</span>,而在<span class="math inline">\(x \to
\infty\)</span>的时候趋近于<span class="math inline">\(x^{ p - 2
}\)</span>,因此绝对收敛.</p>
<p>难点在于把这个东西求出来.接下来将采取一些不严谨的说法.</p>
<p>考虑<span class="math inline">\(0 \leq x &lt;
1\)</span>的时候,有:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ x^{ p - 1 } }{ 1 + x } &amp; = x^{ p - 1 } \sum_{ j = 0 }^\infty
( - x )^j \\
&amp; = \sum_{ j = 0 } ( - 1 )^j x^{ p + j - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>暂时抛开多余的思量,两边做积分:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^1 \frac{ x^{ p - 1 } }{ 1 + x } \mathrm{ d } x &amp; = \sum_{ j =
0 } ( - 1 )^j \int_0^1 x^{ p + j - 1 } \mathrm{ d } x \\
&amp; = \sum_{ j = 0 } ( - 1 )^j \frac{ 1 }{ p + j }
\end{aligned}
\]</span></p>
<p>另一边,其实只需换元,可以发现:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_1^{ + \infty } \frac{ x^{ p - 1 } }{ 1 + x } \mathrm{ d } x
\\
= &amp; \int_0^1 \frac{ t^{ 1 - p } }{ 1 + t^{ - 1 } } \frac{ \mathrm{ d
} t }{ t^2 } \\
= &amp; \int_0^1 \frac{ t^{ - p } }{ 1 + t } \mathrm{ d } t \\
= &amp; \int_0^1 \frac{ t^{ 1 - p - 1 } }{ 1 + t } \mathrm{ d } t \\
= &amp; \sum_{ j = 0 }^{ \infty } ( - 1 )^j \frac{ 1 }{ 1 - p + j } \\
= &amp; \sum_{ j = 0 }^{ \infty } ( - 1 )^{ j + 1 } \frac{ 1 }{ p - ( j
+ 1 ) } \\
= &amp; \sum_{ j = 1 }^{ \infty } ( - 1 )^{ j } \frac{ 1 }{ p - j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>结合起来,答案当然就是<span class="math inline">\(\sum_{ j = - \infty
}^{ + \infty } \frac{ ( - 1 )^j }{ p + j }\)</span>.</p>
<p>我们暂且断言上面那个无穷级数等于<span class="math inline">\(\frac{
\pi }{ \sin ( p \pi ) }\)</span>,原因是我们权且承认下述级数是正确的:</p>
<p><span class="math display">\[
\frac{ 1 }{ \sin t } = \sum_{ j = - \infty }^{ + \infty } \frac{ ( - 1
)^j }{ p + j \pi }
\]</span></p>
<h6><span id="example9frullani积分">Example9(Frullani积分)</span></h6>
<p>当<span class="math inline">\(f \in C [ 0 , + \infty
)\)</span>,且<span class="math inline">\(\int_0^{ + \infty } \frac{ f (
x ) }{ x } \mathrm{ d } x\)</span>收敛,求证<span class="math inline">\(\int_0^{ + \infty } \frac{ f ( ax ) - f ( bx ) }{
x } \mathrm{ d } x = f ( 0 ) \ln \frac{ b }{ a }\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_A^{ B } \frac{ f ( ax ) - f ( bx ) }{ x } \mathrm{ d } x \\
= &amp; \int_{ aA }^{ aB } \frac{ f ( x ) }{ x } \mathrm{ d } x - \int_{
bA }^{ bB } \frac{ f ( x ) }{ x } \mathrm{ d } x \\
= &amp; \int_{ aA }^{ bA } \frac{ f ( x ) }{ x } \mathrm{ d } x - \int_{
aB }^{ bB } \frac{ f ( x ) }{ x } \mathrm{ d } x \\
= &amp; \int_{ a }^{ b } \frac{ f ( Ax ) }{ x } \mathrm{ d } x - \int_{
aB }^{ bB } \frac{ f ( x ) }{ x } \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>前者当<span class="math inline">\(A \to
0\)</span>的时候当然转化为<span class="math inline">\(\int_{ a }^{ b }
\frac{ f ( 0 ) }{ x } \mathrm{ d }
x\)</span>,而后者用柯西判准知道趋近于<span class="math inline">\(0\)</span>,立刻完事.</p>
<h6><span id="example10">Example10</span></h6>
<p>求<span class="math inline">\(I = \int_0^{ \frac{ \pi }{ 2 } } \ln (
\sin x ) \mathrm{ d } x\)</span>.</p>
<p>考虑<span class="math inline">\(x \to 0\)</span>的时候,<span class="math inline">\(\ln ( \sin x ) \sim \ln x\)</span>,而<span class="math inline">\(\int \ln x = x \ln x -
x\)</span>,因此是绝对收敛的.</p>
<p>那怎么求这个积分呢?考虑一些对称技巧,立刻有:</p>
$$
<span class="math display">\[\begin{aligned}
I &amp; = \int_0^{ \frac{ \pi }{ 2 } } \ln ( \sin x ) \mathrm{ d } x \\
&amp; = \int_{ \frac{ \pi }{ 2 } }^{ \pi } \ln ( \sin x ) \mathrm{ d } x
\\
&amp; = \int_{ 0 }^{ \frac{ \pi }{ 2 } } \ln ( \cos x ) \mathrm{ d } x
\\

\end{aligned}\]</span>
<p>$$</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = \frac{ 1 }{ 2 } \int_0^\pi \ln ( \sin x ) \mathrm{ d } x \\
&amp; = \int_0^{ \frac{ \pi }{ 2 } } \ln ( \sin 2 t ) \mathrm{ d } t \\
&amp; = \int_0^{ \frac{ \pi }{ 2 } } \left ( \ln 2 + \ln ( \sin t ) +
\ln ( \cos t ) \right ) \mathrm{ d } t \\
&amp; = \frac{ \pi }{ 2 } \ln 2 + 2 I
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(I = - \frac{ \pi }{ 2 } \ln
2\)</span>.</p>
<h6><span id="example11">Example11</span></h6>
<p>讨论<span class="math inline">\(\int_0^1 \frac{ \ln x }{ x^{ \alpha }
} , \alpha &gt; 0\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(x \in ( 0 , 1 ]\)</span>的时候,<span class="math inline">\(\frac{ \ln x }{ x^{ \alpha } } \leq
0\)</span>,因此其收敛性当然等价于绝对收敛性.取<span class="math inline">\(x \to 0\)</span>的部分,而考虑:</p>
<p>当<span class="math inline">\(0 &lt; \alpha &lt;
1\)</span>,任取一个足够小的<span class="math inline">\(\delta &gt;
0\)</span>使得<span class="math inline">\(0 &lt; \alpha + \delta &lt;
1\)</span>,都可以取足够逼近的<span class="math inline">\(x \to
0\)</span>使得<span class="math inline">\(| \frac{ \ln x }{ x^{ \alpha }
} | &lt; \frac{ 1 }{ x^{ \alpha + \delta }
}\)</span>.于是此时绝对收敛.反之,当<span class="math inline">\(\alpha
\geq 1\)</span>的时候,<span class="math inline">\(| \frac{ \ln x }{
x^\alpha } | &gt; \frac{ 1 }{ x }\)</span>,此时发散.</p>
<h6><span id="example12">Example12</span></h6>
<p>讨论<span class="math inline">\(p , q &gt; 0\)</span>,<span class="math inline">\(\int_2^{ + \infty } \frac{ \mathrm{ d } x }{ x^p
\ln^q x }\)</span>的收敛性.</p>
<p>当<span class="math inline">\(p &gt; 1\)</span>的时候,显然<span class="math inline">\(\frac{ 1 }{ x^p \ln^q x } &lt; \frac{ 1 }{ x^p
}\)</span>,因此当然绝对收敛.</p>
<p>当<span class="math inline">\(p &lt;
1\)</span>的时候,同Example11,只需放掉<span class="math inline">\(\ln
x\)</span>就行,因此是发散的.</p>
<p>当<span class="math inline">\(p =
1\)</span>的时候,估计出了点问题,此时做换元<span class="math inline">\(t
= \ln x\)</span>,则原式变为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ \ln 2 }^{ + \infty } e^{ - t } e^{ t } \frac{ 1 }{ t^q }
\mathrm{ d } t \\
= &amp; \int_{ \ln 2 }^{ + \infty } \frac{ 1 }{ t^q } \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以当<span class="math inline">\(q &gt; 1\)</span>的时候收敛,当<span class="math inline">\(q \leq 1\)</span>的时候发散.</p>
<h6><span id="example13">Example13</span></h6>
<p>讨论<span class="math inline">\(I = \int_0^{ \frac{ \pi }{ 2 } }
\frac{ \sin x }{ x^p } \mathrm{ d } x\)</span>的收敛性.</p>
<p>设<span class="math inline">\(f = \frac{ \sin x }{ x
}\)</span>,容易见到<span class="math inline">\(f\)</span>在<span class="math inline">\(( 0 , \frac{ \pi }{ 2 }
)\)</span>上是单调递减的,那就应当有:</p>
<p><span class="math display">\[
\frac{ 2 }{ \pi } \frac{ 1 }{ x^{ p - 1 } } \leq \frac{ \sin x }{ x^p }
= \frac{ \sin x }{ x } \frac{ 1 }{ x^{ p - 1 } } \leq \frac{ 1 }{ x^{ p
- 1 } }
\]</span></p>
<p>因此其收敛性等价于<span class="math inline">\(\int_{ 0 }^{ \frac{ \pi
}{ 2 } } \frac{ 1 }{ x^{ p - 1 } }\)</span>的收敛性,当<span class="math inline">\(p &lt; 2\)</span>时收敛.</p>
<h6><span id="example14">Example14</span></h6>
<p>设<span class="math inline">\(f \in C^2 [ a , + \infty
)\)</span>,若<span class="math inline">\(\int_a^{ + \infty } f^2 ( x )
\mathrm{ d } x &lt; + \infty , \int_a^{ + \infty } ( f &#39; &#39; )^2 (
x ) \mathrm{ d } x &lt; + \infty\)</span>,求证<span class="math inline">\(\int_a^{ + \infty } ( f &#39; )^2 ( x ) \mathrm{ d
} x &lt; + \infty\)</span>.</p>
<p>此时考虑做分部积分,当然有:</p>
$$
<span class="math display">\[\begin{aligned}
\int_a^x f ( t ) f &#39; &#39; ( t ) \mathrm{ d } t &amp; = f ( x ) f
&#39; ( x ) - f ( a ) f &#39; ( a ) - \int_a^x ( f &#39; ( t ) )^2
\mathrm{ d } t \\
f ( x ) f &#39; ( x ) &amp; = f ( a ) f &#39; ( a ) + \int_a^x f ( t ) f
&#39; &#39; ( t ) \mathrm{ d } t + \int_a^x ( f &#39; ( t ) )^2 \mathrm{
d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时回忆到柯西不等式:</p>
<p><span class="math display">\[
( \int_a^x f ( t ) f &#39; &#39; ( t ) \mathrm{ d } t ) \leq ( \int_a^x
f^2 ( t ) \mathrm{ d } t ) ( \int_a^x ( f &#39; &#39; ( t ) )^2 \mathrm{
d } t )
\]</span></p>
<p>因此这一项被控制住了,于是我们知道<span class="math inline">\(f ( x )
f &#39; ( x )\)</span>和<span class="math inline">\(\int_a^x ( f &#39; (
t ) )^2 \mathrm{ d } t\)</span>收敛性相同.</p>
<p>接下来反证原结论,假设后者并不收敛而是趋近<span class="math inline">\(+ \infty\)</span>.那<span class="math inline">\(f
( x ) f &#39; ( x ) \to + \infty\)</span>,对其做积分,则:</p>
<p><span class="math display">\[
\int_a^{ + \infty } f ( x ) f &#39; ( x ) \mathrm{ d } x = \int_a^{ +
\infty } f ( x ) \mathrm{ d } f ( x ) = f^2 ( x ) - f^2 ( a )
\]</span></p>
<p>因此<span class="math inline">\(f^2 ( x ) \to +
\infty\)</span>,这当然与<span class="math inline">\(\int_a^{ + \infty }
f^2 ( x ) \mathrm{ d } x &lt; + \infty\)</span>相违背.</p>
<h6><span id="example15">Example15</span></h6>
<p>判断<span class="math inline">\(\int_1^{ + \infty } \tan \left (
\cfrac{ \sin x }{ x } \right ) \mathrm{ d } x\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{
x } \mathrm{ d } x\)</span>当然是收敛的,而对<span class="math inline">\(\tan \frac{ \sin x }{ x
}\)</span>做泰勒展开应该和<span class="math inline">\(\frac{ \sin x }{ x
}\)</span>同阶,于是:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_1^{ + \infty } \tan \left ( \cfrac{ \sin x }{ x } \right )
\mathrm{ d } x \\
= &amp; \int_1^{ + \infty } \frac{ \sin x }{ x } \mathrm{ d } x +
\int_1^{ + \infty } \left ( \tan \left ( \cfrac{ \sin x }{ x } \right )
- \frac{ \sin x }{ x } \right ) \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>前半部分当然收敛,后半部分取绝对值放缩后是<span class="math inline">\(O ( \frac{ 1 }{ x^2 } )\)</span>的,当然也收敛.</p>
<h6><span id="example16">Example16</span></h6>
<p>讨论<span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{
x^p } \arctan x \mathrm{ d } x , p &gt; 0\)</span>的收敛性.</p>
<p><span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{ x^p
} \mathrm{ d } x\)</span>收敛,而<span class="math inline">\(\arctan
x\)</span>单调有界,立刻知道收敛.</p>
<h6><span id="example17">Example17</span></h6>
<p>讨论<span class="math inline">\(\int_2^{ + \infty } \frac{ \cos
\sqrt{ x } }{ x^p \ln x } \mathrm{ d } x\)</span>的收敛性.</p>
<p>当然先做换元<span class="math inline">\(t = \sqrt{ x
}\)</span>,那么原式变成:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ \sqrt{ 2 } }^{ + \infty } \frac{ 2 t \cos t \mathrm{ d } t
}{ t^{ 2 p } \ln t^2 } \\
= &amp; \int_{ \sqrt{ 2 } }^{ + \infty } \frac{ \cos t \mathrm{ d } t }{
t^{ 2 p - 1 } \ln t } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math inline">\(2 p - 1 &gt; 1 , p &gt;
1\)</span>的时候当然绝对收敛,而<span class="math inline">\(0 \leq 2 p -
1 \leq 1\)</span>的时候用DA判准知道收敛,<span class="math inline">\(2 p
- 1 &lt; 0\)</span>的时候当然发散.</p>
<h6><span id="example18磨光核函数">Example18(磨光核函数)</span></h6>
<p>构造一个<span class="math inline">\(C^{ \infty }\)</span>的函数<span class="math inline">\(g ( x )\)</span>,满足当<span class="math inline">\(x \leq 0\)</span>的时候,<span class="math inline">\(g ( x ) = 0\)</span>;而当<span class="math inline">\(x \geq 1\)</span>的时候,<span class="math inline">\(g ( x ) =
1\)</span>.也就是你要造一个函数把两段直线焊接起来.</p>
<p>考虑<span class="math inline">\(h ( x ) = \begin{cases}e^{ - \frac{ 1
}{ x^2 } } &amp; x \ne 0 \\ 0 &amp; x = 0\end{cases}\)</span>.这个<span class="math inline">\(h ( x )\)</span>容易检验是<span class="math inline">\(C^{ \infty }\)</span>的,只需看<span class="math inline">\(0\)</span>点处的可导性即可.</p>
<p>取<span class="math inline">\(H ( x ) = \int_{ - \infty }^x h ( t ) h
( 1 - t ) \mathrm{ d } t\)</span>.容易见到这函数在<span class="math inline">\(0\)</span>处和<span class="math inline">\(1\)</span>处都无穷阶可导.稍微乘下常数就可以搞定.</p>
<h6><span id="example19">Example19</span></h6>
<p><span class="math inline">\(\int_0^{ + \infty } f ( x ) \mathrm{ d }
x\)</span>收敛,<span class="math inline">\(xf ( x
)\)</span>单调,求证:<span class="math inline">\(\lim_{ x \to \inf } xf (
x ) \ln x = 0\)</span>.</p>
<p>首先容易证明<span class="math inline">\(xf ( x
)\)</span>单调递减趋于<span class="math inline">\(0\)</span>.那么:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ x_0 }^{ x_0^2 } f ( x ) \mathrm{ d } x \\
= &amp; \int_{ x_0 }^{ x_0^2 } f ( x ) \frac{ x }{ x } \mathrm{ d } x \\
= &amp; \int_{ x_0 }^{ x_0^2 } xf ( x ) \mathrm{ d } \ln x \\
\geq &amp; x_0^2 f ( x_0^2 ) \ln x_0 \\
= &amp; \frac{ 1 }{ 2 } x_0^2 f ( x_0^2 ) \ln x_0^2
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(x_0 \to
\inf\)</span>用柯西准则证毕.</p>
<h6><span id="example20">Example20</span></h6>
<p>求证:当<span class="math inline">\(\int_a^b | f | &lt;
\infty\)</span>的时候,黎曼引理仍然成立.</p>
<p>回忆到黎曼引理要求<span class="math inline">\(f \in R [ a , b
]\)</span>,但这里的确可以推广,原因是瑕积分肯定只有有限个瑕点(有无限个瑕点能立刻证明发散),只需要用足够小的区间把这有限个瑕点盖住,用柯西准则就可以证明这部分很小,而外面的部分当然是正常的黎曼引理.</p>
<h4><span id="rs积分">RS积分</span></h4>
<p>设<span class="math inline">\(\alpha ( x ) : [ a , b ] \to \mathbb{ R
}\)</span>是一个单调不减的函数,对于有界函数<span class="math inline">\(f
( x ) : [ a , b ] \to \mathbb{ R }\)</span>,考虑一个分划<span class="math inline">\(P : a = x_0 &lt; \cdots &lt; x_n =
b\)</span>,定义<span class="math inline">\(\Delta \alpha_k = \alpha (
x_k ) - \alpha ( x_{ k - 1 } ) \geq 0\)</span>,并定义<span class="math inline">\(M_k = \sup_{ [ x_{ k - 1 } , x_k ] } f ( x ) , m_k
= \inf_{ [ x_{ k - 1 } , x_k ] } f ( x
)\)</span>.在此基础上定义<strong>上和</strong><span class="math inline">\(U ( P , f , \alpha ) = \sum_{ k = 1 }^n M_k \Delta
\alpha_k\)</span>,同理定义<strong>下和</strong><span class="math inline">\(L ( P , f , \alpha ) = \sum_{ k = 1 }^n m_k \Delta
\alpha_k\)</span>.定义<strong>上积分</strong><span class="math inline">\(\overline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha = \inf_P{ U ( P , f , \alpha )
}\)</span>,同理定义<strong>下积分</strong><span class="math inline">\(\underline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha = \inf_P{ L ( P , f , \alpha ) }\)</span>.那么如果有以下<span class="math inline">\(\overline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha = \underline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha\)</span>,称<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b ]\)</span>上关于<span class="math inline">\(\alpha\)</span><strong>RS可积</strong>,记作<span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>,而将此值称作<span class="math inline">\(f\)</span>关于<span class="math inline">\(\alpha\)</span>的RS积分,记作<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } \alpha\)</span>.</p>
<p>类比黎曼积分那套理论,应当有以下显而易见的性质:</p>
<ol type="1">
<li><p>分划<span class="math inline">\(P^*\)</span>如果是<span class="math inline">\(P\)</span>的加密,那么<span class="math inline">\(L
( P , f , \alpha ) \leq L ( P^* , f , \alpha ) , U ( P , f , \alpha )
\geq U ( P^* , f , \alpha )\)</span>.</p></li>
<li><p><span class="math inline">\(L ( P_1 , f , \alpha ) \leq U ( P_2 ,
f , \alpha )\)</span>.</p></li>
<li><p><span class="math inline">\(\underline{ \int_{ a }^b } f ( x )
\mathrm{ d } \alpha \leq \overline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R
}_\alpha\)</span>,其充要条件是<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,存在分划<span class="math inline">\(P\)</span>使得<span class="math inline">\(0 \leq U
( P , f , \alpha ) - L ( P , f , \alpha ) &lt;
\epsilon\)</span>.</p></li>
</ol>
<p>接下来考虑证明一些性质:</p>
<ol type="1">
<li><p><span class="math inline">\(f_1 , f_2 \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(f_1 + f_2 \in{ R }_\alpha [ a ,
b ]\)</span>,并且<span class="math inline">\(\int_a^b ( f_1 + f_2 )
\mathrm{ d } \alpha = \int_a^b f_1 \mathrm{ d } \alpha + \int_a^b f_2
\mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(cf \in{ R }_\alpha [ a , b
]\)</span>,并且<span class="math inline">\(\int_a^b ( cf ) \mathrm{ d }
\alpha = c \int_a^b f \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f_1 , f_2 \in{ R }_\alpha [ a , b ] ,
f_1 \leq f_2\)</span>,则<span class="math inline">\(\int_a^b f_1
\mathrm{ d } \alpha \leq \int_a^b f_2 \mathrm{ d }
\alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , c \in [
a , b ]\)</span>,那么<span class="math inline">\(f \in{ R }_\alpha [ a ,
c ] , f \in{ R }_\alpha [ c , b ]\)</span>,且<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = \int_a^c f
\mathrm{ d } \alpha + \int_c^b f \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , | f |
\leq M\)</span>,则<span class="math inline">\(| \int_a^b f \mathrm{ d }
\alpha | \leq M \left ( \alpha ( b ) - \alpha ( a ) \right
)\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_{ \alpha_1 } [ a , b
]\)</span>并且<span class="math inline">\(f \in{ R }_{ \alpha_2 } [ a ,
b ]\)</span>,则<span class="math inline">\(f \in{ R }_{ \alpha_1 +
\alpha_2 } [ a , b ]\)</span>,并且<span class="math inline">\(\int_a^b f
\mathrm{ d } ( \alpha_1 + \alpha_2 ) = \int_a^b f \mathrm{ d } \alpha_1
+ \int_a^b f \mathrm{ d } \alpha_2\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , c &gt;
0\)</span>.则<span class="math inline">\(f \in{ R }_{ c \alpha } [ a , b
]\)</span>,并且<span class="math inline">\(\int_a^b f \mathrm{ d } ( c
\alpha ) = c \int_a^b f \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , m \leq
f \leq M , g \in C [ m , M ]\)</span>.则<span class="math inline">\(g (
f ( x ) ) \in{ R }_\alpha [ a , b ]\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(| f | \in{ R }_\alpha [ a , b
]\)</span>,且<span class="math inline">\(| \int_a^b f \mathrm{ d }
\alpha | \leq \int_a^b | f | \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f_1 , f_2 \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(f_1 f_2 \in{ R }_\alpha [ a , b
]\)</span>.</p></li>
<li><p>如果极限<span class="math inline">\(\lim_{ \lambda ( P ) \to 0 }
( \sum f ( t_k ) \Delta \alpha_k ) , t_k \in [ x_{ k - 1 } , x_k
]\)</span>存在,则<span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>并且其RS积分就是上述极限.然而,逆命题未必成立.</p></li>
</ol>
<p>对于(1),考虑对于分划<span class="math inline">\(P_1 ,
P_2\)</span>而言:</p>
<p><span class="math display">\[
\begin{aligned}
L ( P_1 , f_1 , \alpha ) + L ( P_2 , f_2 , \alpha ) &amp; \leq L ( P_1
\cup P_2 , f_1 , \alpha ) + L ( P_1 \cup P_2 , f_2 , \alpha ) \\
&amp; \leq L ( P_1 \cup P_2 , f_1 + f_2 , \alpha ) \\
&amp; \leq U ( P_1 \cup P_2 , f_1 + f_2 , \alpha ) \\
&amp; \leq U ( P_1 \cup P_2 , f_1 , \alpha ) + U ( P_1 \cup P_2 , f_2 ,
\alpha ) \leq U ( P_1 , f_1 , \alpha ) + U ( P_2 , f_2 , \alpha )
\end{aligned}
\]</span></p>
<p>对此式子两边同取上下确界可以证明<span class="math inline">\(\forall
\epsilon &gt; 0 , U ( P_1 \cup P_2 , f_1 + f_2 , \alpha ) - L ( P_1 \cup
P_2 , f_1 + f_2 , \alpha ) &lt; \epsilon\)</span>,即可得证(1).</p>
<p>对于(2),显然<span class="math inline">\(U ( P , cf , \alpha ) = cU (
P , f , \alpha )\)</span>,下和同理,于是立即得证.</p>
<p>对于(3),由(1),显然<span class="math inline">\(f_2 \geq
f_1\)</span>时,<span class="math inline">\(\int_a^b ( f_2 - f_1 )
\mathrm{ d } \alpha \geq 0\)</span>,于是<span class="math inline">\(\int_a^b f_2 \mathrm{ d } \alpha \geq \int_a^b f_1
\mathrm{ d } \alpha\)</span>.</p>
<p>对于(4),考虑既然<span class="math inline">\(f \in R_\alpha [ a , b
]\)</span>,那么<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,都应该<span class="math inline">\(\exists P\)</span>使得<span class="math inline">\(U_{ [ a , b ] } ( P , f , \alpha ) - L_{ [ a , b ]
} ( P , f , \alpha ) &lt; \epsilon\)</span>,而令<span class="math inline">\(P &#39; = P \cup \{ c \}\)</span>,也就是将<span class="math inline">\(c\)</span>强行作为一个分点,上式仍然成立,而可以将<span class="math inline">\(P &#39;\)</span>拆分为两个部分,不妨记作<span class="math inline">\(P_1 , P_2\)</span>,应该有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; U_{ [ a , b ] } ( P &#39; , f , \alpha ) - L_{ [ a , b ] } ( P
&#39; , f , \alpha ) \\
= &amp; U_{ [ a , c ] } ( P_1 , f , \alpha ) - L_{ [ a , c ] } ( P_1 , f
, \alpha ) + U_{ [ c , b ] } ( P_2 , f , \alpha ) - L_{ [ c , b ] } (
P_2 , f , \alpha ) &lt; \epsilon
\end{aligned}
\]</span></p>
<p>此二项均为正,因此分别<span class="math inline">\(&lt;
\epsilon\)</span>,那也就说明了<span class="math inline">\(f \in R_\alpha
[ a , c ]\)</span>且<span class="math inline">\(f \in R_\alpha [ c , b
]\)</span>,并且仍然是钦定<span class="math inline">\(c\)</span>为分点就可以见到<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = \int_a^c f
\mathrm{ d } \alpha + \int_c^b f \mathrm{ d } \alpha\)</span>.</p>
<p>对于(5),由(3)可以得知:</p>
<p><span class="math display">\[
- \int_a^b M \mathrm{ d } \alpha \leq \int_a^b f \mathrm{ d } \alpha
\leq \int_a^b M \mathrm{ d } \alpha
\]</span></p>
<p>而由定义立刻见到<span class="math inline">\(\int_a^b M \mathrm{ d }
\alpha = M ( \alpha ( b ) - \alpha ( a ) )\)</span>.</p>
<p>对于(6),考虑<span class="math inline">\(\Delta ( \alpha_1 + \alpha_2
)_k = \Delta \alpha_1 + \Delta \alpha_2\)</span>,因此<span class="math inline">\(U ( P , f , \alpha_1 + \alpha_2 ) = U ( P , f ,
\alpha_1 ) + U ( P , f , \alpha_2 )\)</span>.因此证明与(4)无异.</p>
<p>对于(7),只需考虑<span class="math inline">\(\Delta ( c \alpha ) = c
\Delta \alpha\)</span>,于是<span class="math inline">\(U ( P , f , c
\alpha ) = cU ( P , f , \alpha )\)</span>,于是证明与(2)无异.</p>
<p>考虑(8)的证明,由于<span class="math inline">\(g\)</span>是闭区间上的连续函数,立刻知道其一致连续.也就是<span class="math inline">\(\forall \epsilon &gt; 0 , \exists 0 &lt; \delta
&lt; \epsilon\)</span>,使得<span class="math inline">\(| s - t | &lt;
\delta\)</span>时一定有<span class="math inline">\(| g ( s ) - g ( t ) |
&lt; \epsilon\)</span>.接下来考虑由于<span class="math inline">\(f \in
R_\alpha [ a , b ]\)</span>,应当可以取一组划分<span class="math inline">\(P : a = x_0 &lt; \cdots &lt; x_n =
b\)</span>,使得<span class="math inline">\(U ( P , f , \alpha ) - L ( P
, f , \alpha ) &lt; \delta^2\)</span>.考虑将划分分为两类:<span class="math inline">\(A = \{ 1 \leq k \leq n \mid M_k - m_k &lt; \delta
\}\)</span>和<span class="math inline">\(B = \{ 1 \leq k \leq n \mid M_k
- m_k \geq \delta
\}\)</span>.这个思路就会和根号分治很像.那接下来考虑定义<span class="math inline">\(M_k^* = \sup_{ [ x_{ k - 1 } , x_k ] } g ( f ( x )
) , m_k^* = \inf_{ [ x_{ k - 1 } , x_k ] } g ( f ( x ) )\)</span>.</p>
<p>那这就会使得当<span class="math inline">\(k \in
A\)</span>的时候,由于<span class="math inline">\(g\)</span>的一致连续性,立刻可以知道<span class="math inline">\(M_k^* - m_k^* \leq \epsilon\)</span>.而当<span class="math inline">\(k \in B\)</span>的时候,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\delta \sum_{ k \in B } \Delta \alpha_k &amp; \leq \sum_{ k \in B } (
M_k - m_k ) \Delta \alpha_k \\
&amp; = U ( P , f , \alpha ) - L ( P , f , \alpha ) &lt; \delta^2
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(\sum_{ k \in B } \Delta \alpha_k &lt;
\delta\)</span>.如此一来:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; U ( P , g \circ f , \alpha ) - L ( P , g \circ f , \alpha ) \\
= &amp; \sum_{ k \in A } ( M_k^* - m_k^* ) \Delta \alpha_k + \sum_{ k
\in B } ( M_k^* - m_k^* ) \Delta \alpha_k \\
&lt; &amp; \epsilon ( \alpha ( b ) - \alpha ( a ) ) + 2 ( \sup | g | )
\delta \\
&lt; &amp; \epsilon \left ( \alpha ( b ) - \alpha ( a ) + 2 \sup | g |
\right )
\end{aligned}
\]</span></p>
<p>这样就证毕了.</p>
<p>考虑(9)的证明,首先由(8)知道<span class="math inline">\(| f | \in{ R
}_\alpha [ a , b ]\)</span>.而我们可以说存在<span class="math inline">\(c = \pm 1\)</span>,使得<span class="math inline">\(| \int_a^b f \mathrm{ d } \alpha | = c ( \int_a^b
f \mathrm{ d } \alpha )\)</span>.而<span class="math inline">\(cf ( x )
\leq | f ( x ) |\)</span>,由(3)的保序性得证.</p>
<p>考虑(10)的证明,嵌套函数<span class="math inline">\(g =
x^2\)</span>并利用(9),则我们可以知道如果<span class="math inline">\(f
\in{ R }_\alpha [ a , b ]\)</span>,那么<span class="math inline">\(f^2
\in{ R }_\alpha [ a , b ]\)</span>.此时观察到<span class="math inline">\(4 f_1 f_2 = ( f_1 + f_2 )^2 - ( f_1 - f_2
)^2\)</span>,立即得证.</p>
<p>(11)的证明比较显然.(11)直接的逆命题的话有个反例是考虑<span class="math inline">\(f ( x ) = \begin{cases}1 &amp; x \geq 0 \\ 0 &amp;
x &lt; 0\end{cases} , \alpha ( x ) = \begin{cases}1 &amp; x &gt; 0 \\ 0
&amp; x \leq 0\end{cases}\)</span>.此时会发现<span class="math inline">\(x =
0\)</span>这个点取不取在分划里是重要的,只要不取在分划里,怎么加密也没有用.</p>
<p>接下来当然应当研究一下连续性对RS可积的意义.我们声明:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(f \in C [ a , b
]\)</span>,则<span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>且对<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists \delta &gt; 0\)</span>,并且只要<span class="math inline">\(\lambda ( P ) &lt; \delta\)</span>,那么<span class="math inline">\(| \sum f ( t_k ) \Delta \alpha_k - \int_a^b f
\mathrm{ d } \alpha | &lt; \epsilon\)</span>,其中<span class="math inline">\(t_k \in [ x_{ k - 1 } , x_k ]\)</span>.</p></li>
<li><p>(1)中的条件如果改成<span class="math inline">\(f \in R_\alpha [ a
, b ] , \alpha \in C [ a , b ]\)</span>,结论仍然成立.</p></li>
<li><p>如果<span class="math inline">\(f\)</span>单调,但是<span class="math inline">\(\alpha\)</span>连续,则我们也能证明<span class="math inline">\(f_\alpha \in{ R }_\alpha [ a , b
]\)</span>.</p></li>
<li><p>作为(3)的推论,如果<span class="math inline">\(f\)</span>是有界变差函数,<span class="math inline">\(\alpha\)</span>连续,也能证明<span class="math inline">\(f_\alpha \in{ R }_\alpha [ a , b
]\)</span>.</p></li>
<li><p>如果<span class="math inline">\([ a , b
]\)</span>上的有界函数<span class="math inline">\(f\)</span>只有有限个间断点,并且<span class="math inline">\(f\)</span>和<span class="math inline">\(\alpha\)</span>的间断点集交集为空,则<span class="math inline">\(f \in R_\alpha [ a , b
]\)</span>.同时,(1)中的性质仍然成立.</p></li>
</ol>
<p>(1)的证明,考虑<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,取<span class="math inline">\(\gamma &gt;
0\)</span>,使得<span class="math inline">\(\left ( \alpha ( b ) - \alpha
( a ) \right ) \gamma &lt; \epsilon\)</span>.此时,<span class="math inline">\(f\)</span>是闭区间上的连续函数,那它就一定是一致连续的函数.那么<span class="math inline">\(\exists \delta &gt; 0\)</span>,当<span class="math inline">\(| x - y | &lt; \delta\)</span>的时候,有<span class="math inline">\(| f ( x ) - f ( y ) | &lt;
\gamma\)</span>.此时只需考虑<span class="math inline">\(U ( P , f ,
\alpha ) - L ( P , f , \alpha ) &lt; \epsilon\)</span>就做完了.</p>
<p>(2)的证明,考虑既然<span class="math inline">\(f \in R_{ \alpha } [ a
, b ]\)</span>,因此一定存在一组分划<span class="math inline">\(P^*\)</span>使得<span class="math inline">\(U (
P^* , f , \alpha ) &lt; \int_a^b f \mathrm{ d } \alpha +
\epsilon\)</span>.</p>
<p>那么接下来对于任意一组分划<span class="math inline">\(P : a = x_0
&lt; \cdots &lt; x_m = b\)</span>,将其分为两组:一组是<span class="math inline">\(A = \{ k \mid \exists i , x_i^* \in ( x_{ k - 1 }
, x_k ) \}\)</span>,<span class="math inline">\(B = \{ 1 , 2 , \cdots ,
m \} \setminus A\)</span>.也即<span class="math inline">\(B\)</span>中的每个区间都被包含在<span class="math inline">\(P^*\)</span>的分划中.既然如此,在<span class="math inline">\(B\)</span>上的和的部分当然就要<span class="math inline">\(\leq U ( P^* , f , \alpha ) &lt; \int_a^b f
\mathrm{ d } \alpha + \epsilon\)</span>.只要我们能证明<span class="math inline">\(A\)</span>能被控制住即可.</p>
<p>而由于<span class="math inline">\(\alpha\)</span>连续,其在<span class="math inline">\([ a , b
]\)</span>上绝对连续,可以取足够小的分划使得<span class="math inline">\(\Delta \alpha\)</span>足够小.既然如此,<span class="math inline">\(\sum_{ k \in A } f ( t_k ) \Delta \alpha_k \leq nM
\max \{ \Delta \alpha_k \}\)</span>,其中<span class="math inline">\(M\)</span>是<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b
]\)</span>上的上界,这个立刻可以被<span class="math inline">\(\max \{
\Delta \alpha_k \}\)</span>控制住.</p>
<p>(3)的证明,不妨设<span class="math inline">\(f\)</span>单调不降,此时考虑取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\frac{
\alpha ( b ) - \alpha ( a ) }{ n } ( f ( b ) - f ( a ) ) &lt;
\epsilon\)</span>.那么由于<span class="math inline">\(\alpha\)</span>连续,所以其有介值性,可以通过选取划分使得<span class="math inline">\(\Delta \alpha_k \equiv \frac{ \alpha ( b ) -
\alpha ( a ) }{ n } ( f ( b ) - f ( a ) )\)</span>,那还是考虑<span class="math inline">\(U ( P , f , \alpha ) - L ( P , f , \alpha ) &lt;
\epsilon\)</span>即可.</p>
<p>(5)的证明相当平凡,只需用闭区间上的连续函数是一致连续处理间断点即可,在此略过.</p>
<p>于上述基础上进一步拓展,可以拓展到<span class="math inline">\(\alpha\)</span>是有界变差的情况.原因是有界变差函数可以表示为两个不降函数的差,不妨设<span class="math inline">\(\alpha ( x ) = \beta ( x ) - \gamma ( x
)\)</span>,则我们定义<span class="math inline">\(\int_a^b f \mathrm{ d }
\alpha = \int_a^b f \mathrm{ d } \beta - \int_a^b f \mathrm{ d }
\gamma\)</span>.</p>
<p>这个还要证明是良定的,原因是如果一个有界变差函数能表示成两种情形,有<span class="math inline">\(\beta_1 ( x ) - \gamma_1 ( x ) = \beta_2 ( x ) -
\gamma_2 ( x )\)</span>,那么<span class="math inline">\(\beta_1 ( x ) +
\gamma_2 ( x ) = \beta_2 ( x ) + \gamma_1 ( x
)\)</span>,这两边都是不降函数,那根据<span class="math inline">\(\alpha\)</span>部分可以加减的性质就完事了.</p>
<p>既然如此,对拓展的版本进一步寻找性质,不妨设<span class="math inline">\(V ( x ) = V_a^x \alpha\)</span>.</p>
<ol type="1">
<li><p><span class="math inline">\(f \in C [ a , b ]\)</span>且<span class="math inline">\(\alpha\)</span>是有界变差,或<span class="math inline">\(f , \alpha\)</span>都是有界变差且<span class="math inline">\(f\)</span>连续时,<span class="math inline">\(|
\int_a^b f \mathrm{ d } \alpha | \leq \int_a^b f \mathrm{ d }
V\)</span></p></li>
<li><p>作为(1)的推论,上述条件时,<span class="math inline">\(| \int_a^b f
\mathrm{ d } \alpha | \leq \sup | f | \times V_a^b
\alpha\)</span></p></li>
<li><p>(分部积分):当<span class="math inline">\(\alpha ,
f\)</span>都是有界变差,并且它们有一个是连续的时候,<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = f \alpha \mid_a^b
- \int_a^b \alpha \mathrm{ d } f\)</span>.应当见到其实该定理只需要<span class="math inline">\(\alpha , f\)</span>有一个是连续就行.</p></li>
<li><p>(第一积分中值定理):<span class="math inline">\(f \in C [ a , b
]\)</span>且<span class="math inline">\(\alpha\)</span>不降,则<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = f ( \xi ) \left (
\alpha ( b ) - \alpha ( a ) \right )\)</span>.</p></li>
<li><p>(第二积分中值定理):<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b ]\)</span>上单调,<span class="math inline">\(\alpha\)</span>是连续有界变差.则<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = f ( a ) \left (
\alpha ( \xi ) - \alpha ( a ) \right ) + f ( b ) \left ( \alpha ( b ) -
\alpha ( \xi ) \right )\)</span>.</p></li>
<li><p>(变量替换公式):如果<span class="math inline">\(f , g \in C [ a ,
b ]\)</span>并且<span class="math inline">\(g\)</span>严格增,取<span class="math inline">\(h = g^{ - 1 }\)</span>,<span class="math inline">\(c = g ( a ) , d = g ( b )\)</span>,那么<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x = \int_c^d f ( h (
y ) ) \mathrm{ d } h ( y )\)</span>.</p></li>
<li><p>(和黎曼可积的关系):<span class="math inline">\(f \in R [ a , b
]\)</span>,<span class="math inline">\(\alpha\)</span>可导并且<span class="math inline">\(\alpha &#39; \in R [ a , b ]\)</span>,则<span class="math inline">\(f \in R_\alpha [ a , b ]\)</span>,且<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = \int_a^b f \alpha
&#39; \mathrm{ d } x\)</span></p></li>
</ol>
<p>考虑(1)的证明,由于此时已经可以使用求和来逼近,那不妨考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| S ( P , f , \alpha ) | &amp; = | \sum f ( t_k ) \Delta \alpha_k | \\
&amp; \leq | \sum f ( t_k ) | \cdot | \Delta \alpha_k | \\
&amp; \leq | \sum f ( t_k ) | \Delta V_k
\end{aligned}
\]</span></p>
<p>于是证毕.(2)自是(1)的推论.</p>
<p>(3)的话,当然是Abel求和,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S ( P , f , \alpha ) &amp; = \sum_{ k = 1 }^n f ( t_k ) ( \alpha ( x_k )
- \alpha ( x_{ k - 1 } ) ) \\
&amp; = f ( b ) \alpha ( b ) - f ( a ) \alpha ( a ) - \sum_{ k = 1 }^{ n
+ 1 } \alpha ( x_{ k - 1 } ) ( f ( t_k ) - f ( t_{ k - 1 } ) ) \\
&amp; = f \alpha |_a^b - S ( Q , \alpha , f )
\end{aligned}
\]</span></p>
<p>容易见到<span class="math inline">\(| P | \to 0\)</span>会导致<span class="math inline">\(| Q | \to 0\)</span>,便是显然.</p>
<p>考虑(4),由于<span class="math inline">\(f\)</span>是连续的,直接取<span class="math inline">\(f\)</span>的上下界并介值定理一下即是显然.</p>
<p>考虑(5),用分部积分公式,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b f \mathrm{ d } \alpha &amp; = f ( b ) \alpha ( b ) - f ( a )
\alpha ( a ) - \int_a^b \alpha \mathrm{ d } f \\
&amp; = f ( b ) \alpha ( b ) - f ( a ) \alpha ( a ) - \alpha ( \xi ) ( f
( b ) - f ( a ) )
\end{aligned}
\]</span></p>
<p>整理一下即可.</p>
<p>考虑(6),由于连续性,因此对<span class="math inline">\(x\)</span>做的划分同样通过一个<span class="math inline">\(h\)</span>成为了新的一组划分,而且由于闭区间上的连续函数是一致连续的,这个划分当然也趋近于<span class="math inline">\(0\)</span>,立即见到成立.</p>
<p>对于(7),首先用介值定理得到<span class="math inline">\(\Delta \alpha_k
= \alpha &#39; ( \xi_k ) \Delta x_k\)</span>,那当然有:</p>
<p><span class="math display">\[
\begin{aligned}
S ( P , f , \alpha ) &amp; = \sum f ( t_k ) \Delta \alpha_k \\
&amp; = \sum f ( t_k ) \alpha &#39; ( t_k ) \Delta x_k + \sum f ( t_k )
( \alpha &#39; ( \xi_k ) - \alpha &#39; ( t_k ) ) \Delta x_k
\end{aligned}
\]</span></p>
<p>而后面那一项绝对值不超过<span class="math inline">\(| \sup f | \sum
\omega_{ \alpha &#39; }\)</span>,当然趋近于<span class="math inline">\(0\)</span>.</p>
<h3><span id="级数">级数</span></h3>
<p>对于数列<span class="math inline">\(\{ a_n \}\)</span>,定义<span class="math inline">\(S_n = \sum_{ k = 1 }^n a_k\)</span>.如果<span class="math inline">\(\lim_{ n \to \infty }
S_n\)</span>存在,则称级数<span class="math inline">\(\sum_{ k = 1 }^{
\infty } a_n\)</span><strong>收敛</strong>,记作<span class="math inline">\(S = \sum_{ k }^{ \infty }
a_n\)</span>,否则如若上述极限不存在,称其<strong>发散</strong>.</p>
<p>容易见到以下性质显然成立,然而逆命题并不总是成立:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum^{ + \infty } a_n = A , \sum^{ +
\infty } b_n = B\)</span>,则<span class="math inline">\(\sum^{ + \infty
} ( a_n + b_n ) = A + B\)</span>.</p></li>
<li><p><span class="math inline">\(\sum^{ + \infty } a_n =
A\)</span>,则<span class="math inline">\(\sum^{ + \infty } c a_n =
cA\)</span>.</p></li>
<li><p>结合律:<span class="math inline">\(\sum^{ + \infty } a_n =
A\)</span>,若<span class="math inline">\(\{ n_k
\}\)</span>是递增正整数序列且<span class="math inline">\(n_0 =
1\)</span>,设<span class="math inline">\(C_k = \sum_{ n = n_{ k - 1 }
}^{ n_k - 1 } a_n\)</span>,则<span class="math inline">\(\sum_k^{ +
\infty } C_k = A\)</span>.</p></li>
</ol>
<p>(1)(2)显然,(3)当然是因为原数列收敛立刻能推出其子列收敛.</p>
<p>如果<span class="math inline">\(\sum | a_n | &lt;
\infty\)</span>,则称此级数<strong>绝对收敛</strong>.考虑<span class="math inline">\(a_n = | a_n | - ( | a_n | - a_n
)\)</span>,前后两者都是正项数列而且<span class="math inline">\(| a_n | -
a_n \leq 2 | a_n
|\)</span>,所以绝对收敛当然能推出收敛,而反之不可.将收敛但不绝对收敛的级数称作<strong>条件收敛</strong>.绝对收敛的两个级数之和当然也绝对收敛,乘一个系数后也绝对收敛.</p>
<p>我们有<strong>柯西收敛原理</strong>:<span class="math inline">\(\sum
a_n\)</span>收敛的充要条件是<span class="math inline">\(\forall \epsilon
&gt; 0\)</span>,<span class="math inline">\(\exists N &gt; 0 , \forall m
&gt; n \geq N\)</span>,<span class="math inline">\(| \sum_{ k = n }^m
a_k | &lt; \epsilon\)</span>.用柯西准则立刻见到如若<span class="math inline">\(\lim_{ n \to \infty } S_n\)</span>收敛则必有<span class="math inline">\(\lim_{ n \to \infty } a_n =
0\)</span>.但反命题当然不成立.这是相当重要的,正是因为<span class="math inline">\(\lim_{ n \to \infty } a_n =
0\)</span>,所以我们才总能使用泰勒展开等手段进行估计和放缩.</p>
<p>再还有Abel-Dirichlet判别法,设<span class="math inline">\(a_n\)</span>单调,<span class="math inline">\(B_n =
\sum_{ k = 1 }^n b_k\)</span>,<span class="math inline">\(B_n\)</span>有界,<span class="math inline">\(| B_n
| \leq M\)</span>:</p>
<ol type="1">
<li><p>引理:<span class="math inline">\(| \sum_{ k = 1 }^n a_k b_k |
\leq M ( | a_1 | + 2 | a_n | ) \leq 2 M ( | a_1 | + | a_n |
)\)</span>.</p></li>
<li><p>Dirichlet判别法:若<span class="math inline">\(a_n \to
0\)</span>,<span class="math inline">\(B_n\)</span>有界,则<span class="math inline">\(\sum a_k b_k\)</span>收敛.</p></li>
<li><p>Abel判别法:若<span class="math inline">\(B_n\)</span>收敛,<span class="math inline">\(a_n\)</span>有界,则<span class="math inline">\(\sum a_k b_k\)</span>收敛.</p></li>
</ol>
<p>(1)的话当然只需使用Abel变换,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 1 }^n a_k b_k &amp; = \sum_{ k = 1 }^n a_k ( B_k - B_{ k - 1
} ) \\
&amp; = a_n B_n + \sum_{ k = 1 }^{ n - 1 } ( a_k - a_{ k + 1 } ) B_k
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = 1 }^n a_k b_k | \\
\leq &amp; | a_n B_n | + \sum_{ k = 1 }^{ n - 1 } | a_k - a_{ k + 1 } |
\cdot | B_k | \\
\leq &amp; M ( | a_1 - a_n | + | a_n | ) \\
\leq &amp; M ( | a_1 | + 2 | a_n | )
\end{aligned}
\]</span></p>
<p>(2)(3)的话用柯西判准,考虑任意一段求和<span class="math inline">\(|
B_{ n + p } - B_{ n - 1 } | \leq 2 M\)</span>,于是:</p>
<p><span class="math display">\[
| \sum_{ k = n }^{ n + p } a_k b_k | \leq 2 M ( | a_n | + 2 | a_{ n + p
} | )
\]</span></p>
<p>则属显然.</p>
<p>DA判别法的一个推论是,对于<span class="math inline">\(\sum
b_k\)</span>和<span class="math inline">\(\sum
c_k\)</span>来说,如果<span class="math inline">\(\frac{ b_k }{ c_k
}\)</span>单调有界且不趋于<span class="math inline">\(0\)</span>,那么它们敛散性相同.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum \frac{ \sin ( nx ) }{ n
}\)</span>的收敛性.</p>
<p>首先当<span class="math inline">\(x = 2 k
\pi\)</span>的时候当然收敛,否则使用DA判别法,考虑证明<span class="math inline">\(\sum \sin ( nx )\)</span>有界.</p>
<p>用积化和差,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| \sum_{ k = 1 }^n \sin ( kx ) | &amp; = \left | \frac{ \sum 2 \sin
\frac{ x }{ 2 } \sin ( kx ) }{ 2 \sin ( \frac{ x }{ 2 } ) } \right | \\
&amp; = \left | \frac{ \sum \cos ( k - \frac{ 1 }{ 2 } ) x - \cos ( k +
\frac{ 1 }{ 2 } ) x }{ 2 \sin ( \frac{ x }{ 2 } ) } \right | \\
&amp; \leq \frac{ 1 }{ | \sin \frac{ x }{ 2 } | }
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<p>能不能进一步把上面的这个级数求出来呢?考虑欧拉公式,令<span class="math inline">\(z = e^{ ix }\)</span>,知道<span class="math inline">\(e^{ inx } = \cos ( nx ) + i \sin ( nx
)\)</span>,所以<span class="math inline">\(\sum \frac{ z^n }{ n } = -
\ln ( 1 - z )\)</span>的虚部就是所求.</p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
- \ln ( 1 - z ) &amp; = - \ln ( 1 - \cos x - i \sin x ) \\
&amp; = - \ln \left ( 2 ( \sin \frac{ x }{ 2 } ) ( \sin \frac{ x }{ 2 }
- i \cos \frac{ x }{ 2 } ) \right ) \\
&amp; = - \ln \left ( 2 ( \sin \frac{ x }{ 2 } ) e^{ \frac{ x - \pi }{ 2
} i } \right ) \\
&amp; = - \ln ( 2 \sin \frac{ x }{ 2 } ) + \frac{ \pi - x }{ 2 } i
\end{aligned}
\]</span></p>
<p>这就顺便解决了<span class="math inline">\(\sum \frac{ \cos ( nx ) }{
n }\)</span>的情况.</p>
<h6><span id="example2">Example2</span></h6>
<p>判断<span class="math inline">\(\sum \frac{ ( - 1 )^n }{ n^p + ( - 1
)^n } , p &gt; 0\)</span>的收敛性.</p>
<p>观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ ( - 1 )^n }{ n^p + ( - 1 )^n } \\
= &amp; \frac{ ( - 1 )^n }{ n^p } \frac{ 1 }{ 1 + \frac{ ( - 1 )^n }{
n^p } } \\
= &amp; \frac{ ( - 1 )^n }{ n^p } \frac{ 1 - \frac{ ( - 1 )^n }{ n^p }
}{ 1 - \frac{ 1 }{ n^{ 2 p } } } \\
= &amp; \frac{ ( - 1 )^n }{ n^p - \frac{ 1 }{ n^p } } - \frac{ 1 }{ n^{
2 p } - 1 }
\end{aligned}
\]</span></p>
<p>前半部分当然收敛,于是<span class="math inline">\(p \leq \frac{ 1 }{ 2
}\)</span>的时候发散,<span class="math inline">\(\frac{ 1 }{ 2 } &lt; p
\leq 1\)</span>的时候条件收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum \frac{ \sin ( \frac{ n \pi }{ 4 }
) }{ n^p + \sin ( \frac{ n \pi }{ 4 } ) }\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p + \sin ( \frac{ n \pi
}{ 4 } ) } \\
= &amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } \frac{ 1 }{ 1 +
\frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } } \\
= &amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } \left ( 1 - \frac{
\sin ( \frac{ n \pi }{ 4 } ) }{ n^p } + o ( \frac{ 1 }{ n^p } ) \right )
\\
= &amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } - \frac{ \sin^2 (
\frac{ n \pi }{ 4 } ) }{ n^{ 2 p } } + o ( \frac{ 1 }{ n^{ 2 p } } )
\end{aligned}
\]</span></p>
<p>见到应该是<span class="math inline">\(p \leq \frac{ 1 }{ 2
}\)</span>发散,<span class="math inline">\(\frac{ 1 }{ 2 } &lt; p \leq
1\)</span>的时候条件收敛,<span class="math inline">\(p &gt;
1\)</span>的时候绝对收敛.</p>
<h4><span id="正项级数">正项级数</span></h4>
<ol type="1">
<li><p>当<span class="math inline">\(a_n \geq 0\)</span>的时候,<span class="math inline">\(S_n\)</span>有界<span class="math inline">\(\Leftrightarrow\)</span>S_n</p></li>
<li><p>当<span class="math inline">\(0 \leq a_n \leq
b_n\)</span>,若<span class="math inline">\(\sum^{ + \infty } b_n &lt;
\infty\)</span>,则<span class="math inline">\(\sum^{ + \infty } a_n &lt;
\infty\)</span>.</p></li>
<li><p>若<span class="math inline">\(a_n , b_n &gt; 0\)</span>,则若<span class="math inline">\(\varlimsup_{ n \to \infty } \frac{ a_n }{ b_n }
&lt; \infty\)</span>,则<span class="math inline">\(\sum^{ + \infty } b_n
&lt; \infty \Rightarrow \sum^{ + \infty } a_n &lt;
\infty\)</span>.</p></li>
<li><p>若<span class="math inline">\(a_n , b_n &gt; 0\)</span>,则若<span class="math inline">\(\varliminf_{ n \to \infty } \frac{ a_n }{ b_n }
&gt; 0\)</span>,则<span class="math inline">\(\sum^{ + \infty } b_n =
\infty \Rightarrow \sum^{ + \infty } a_n = \infty\)</span>.</p></li>
<li><p>若<span class="math inline">\(a_n\)</span>单调递减趋近于<span class="math inline">\(0\)</span>.则<span class="math inline">\(\sum^{ +
\infty }_n a_n &lt; \infty \Leftrightarrow \sum_{ k }^{ + \infty } 2^k
a_{ 2^k } &lt; \infty\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ k = 1 }^{ + \infty } \frac{ 1
}{ n^p }\)</span>,当<span class="math inline">\(p \leq
1\)</span>的时候发散,而当<span class="math inline">\(p &gt;
1\)</span>的时候收敛.</p></li>
<li><p><span class="math inline">\(\sum_{ k = 2 }^{ + \infty } \frac{ 1
}{ n \ln^p n }\)</span>,当<span class="math inline">\(p \leq
1\)</span>的时候发散,而当<span class="math inline">\(p &gt;
1\)</span>的时候收敛.</p></li>
<li><p>设单调递减连续正函数<span class="math inline">\(f ( x
)\)</span>满足<span class="math inline">\(a_n = f ( n )\)</span>,则<span class="math inline">\(\sum_{ k = 1 }^{ + \infty } a_k &lt; \infty
\Leftrightarrow \int_1^{ + \infty } f ( x ) \mathrm{ d } x &lt;
\infty\)</span>.</p></li>
<li><p>比值判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,如果<span class="math inline">\(\varlimsup_{ n \to \infty }
\frac{ a_{ n + 1 } }{ a_n } &lt; 1\)</span>,则<span class="math inline">\(\sum a_n &lt; \infty\)</span>.</p></li>
<li><p>比值判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,如果<span class="math inline">\(\varliminf_{ n \to \infty }
\frac{ a_{ n + 1 } }{ a_n } &gt; 1\)</span>,则<span class="math inline">\(\sum a_n = \infty\)</span>.</p></li>
<li><p>根值判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,设<span class="math inline">\(l = \varlimsup_{ n \to \infty }
( a_n )^{ \frac{ 1 }{ n } }\)</span>,如果<span class="math inline">\(l
&lt; 1\)</span>,则<span class="math inline">\(\sum a_n &lt;
\infty\)</span>;若<span class="math inline">\(l &gt; 1\)</span>,则<span class="math inline">\(\sum a_n = \infty\)</span>.</p></li>
<li><p>对于<span class="math inline">\(a_n &gt; 0\)</span>,如果<span class="math inline">\(\varliminf_{ n \to \infty } n \ln \frac{ a_n }{
a_{ n + 1 } } &gt; 1\)</span>,则<span class="math inline">\(\sum a_n
&lt; \infty\)</span>.</p></li>
<li><p>对于<span class="math inline">\(a_n &gt; 0\)</span>,如果<span class="math inline">\(\varlimsup_{ n \to \infty } n \ln \frac{ a_n }{
a_{ n + 1 } } &lt; 1\)</span>,则<span class="math inline">\(\sum a_n =
\infty\)</span>.</p></li>
<li><p>拉贝判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,若<span class="math inline">\(\varliminf_{ n \to \infty } n (
\frac{ a_n }{ a_{ n + 1 } } - 1 ) &gt; 1\)</span>,则<span class="math inline">\(\sum a_n &lt; \infty\)</span>.</p></li>
<li><p>拉贝判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,若<span class="math inline">\(\varlimsup_{ n \to \infty } n (
\frac{ a_n }{ a_{ n + 1 } } - 1 ) &lt; 1\)</span>,则<span class="math inline">\(\sum a_n = \infty\)</span>.</p></li>
</ol>
<p>(1)当然是单调收敛准则.(2)只是(1)的推论.</p>
<p>(3)(4)只需套用定义即可.</p>
<p>(5)的话,不妨设<span class="math inline">\(S_n = \sum_{ k = 1 }^n
a_k\)</span>而<span class="math inline">\(T_n = \sum_{ k = 1 }^n 2^k a_{
2^k }\)</span>考虑当<span class="math inline">\(2^k \leq
n\)</span>的时候,有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; \geq \sum_{ j = 1 }^{ 2^k } a_j \\
&amp; = a_1 + \sum_{ j = 0 }^{ k - 1 } \sum_{ i = 2^j + 1 }^{ 2^{ j + 1
} } a_i \\
&amp; \geq \frac{ 1 }{ 2 } T_k
\end{aligned}
\]</span></p>
<p>当<span class="math inline">\(n &lt; 2^{ k + 1
}\)</span>的时候,则有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; \leq \sum_{ j = 1 }^{ 2^k } a_j \\
&amp; = \sum_{ j = 0 }^{ k - 1 } \sum_{ i = 2^j }^{ 2^{ j + 1 } - 1 }
a_i \\
&amp; \leq T_k
\end{aligned}
\]</span></p>
<p>(6)的话,首先<span class="math inline">\(p \leq 1\)</span>的时候<span class="math inline">\(\frac{ 1 }{ n^p } \geq \frac{ 1 }{ n
}\)</span>于是显然,而当<span class="math inline">\(p &gt;
1\)</span>的时候,考虑用(5),观察<span class="math inline">\(\sum 2^k
\frac{ 1 }{ 2^{ pk } } = \sum 2^{ ( 1 - p ) k }\)</span>,当然收敛.</p>
<p>(7)的话亦然考虑(5),等价于<span class="math inline">\(\sum 2^k \frac{
1 }{ 2^k k^p \ln^p 2 } = \sum \frac{ 1 }{ k^p \ln^p 2
}\)</span>,等价于(6)了.这个结论还可以推广到<span class="math inline">\(\sum \frac{ 1 }{ n \ln n ( \ln \ln n )^p
}\)</span>,总之都是类似的做法,结论也类似.</p>
<p>(8)的证明只需考虑:</p>
<p><span class="math display">\[
a_{ n + 1 } = f ( n + 1 ) \leq \int_n^{ n + 1 } f ( t ) \mathrm{ d } t
\leq f ( n ) = a_n
\]</span></p>
<p>立刻证毕.</p>
<p>而且这个估计还可以更精细,事实上我们可以证明下列极限总是存在:</p>
<p><span class="math display">\[
\lim_{ n \to \infty } ( \sum_{ k = m }^n f ( k ) - \int_m^n f ( x )
\mathrm{ d } x ) = \alpha
\]</span></p>
<p>而且还满足<span class="math inline">\(0 \leq \alpha \leq f ( m
)\)</span>.</p>
<p>考虑固定<span class="math inline">\(m\)</span>,设<span class="math inline">\(g ( n ) = \sum_{ k = m }^n f ( k ) - \int_m^n f (
x ) \mathrm{ d }
x\)</span>,用单调收敛准则,我们先证明它单调递减且有下界,注意到:</p>
<p><span class="math display">\[
g ( n ) - g ( n + 1 ) = - f ( n + 1 ) + \int_{ n }^{ n + 1 } f ( x )
\mathrm{ d } x \geq 0
\]</span></p>
<p>这就证明了其单调递减,而又有:</p>
<p><span class="math display">\[
g ( n ) = \sum_{ k = m }^{ n - 1 } \left ( f ( k ) - \int_{ k }^{ k + 1
} f ( x ) \mathrm{ d } x \right ) + f ( n ) \geq f ( n ) \geq 0
\]</span></p>
<p>因此有下界.同时注意到<span class="math inline">\(g ( m ) = f ( m
)\)</span>,因此总有<span class="math inline">\(0 \leq \alpha \leq f ( m
)\)</span>成立.</p>
<p>不仅如此,如果<span class="math inline">\(f ( n )\)</span>还满足<span class="math inline">\(\lim_{ x \to \infty } f ( x ) =
0\)</span>,我们还可以把这个极限收敛的速度求出来.我们有:</p>
<p><span class="math display">\[
| \sum_{ k = m }^n f ( k ) - \int_m^n f ( x ) \mathrm{ d } x - \alpha |
\leq f ( n )
\]</span></p>
<p>干脆令<span class="math inline">\(l &gt;
n\)</span>,考虑LHS应该是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = m }^n f ( k ) - \int_m^n f ( x ) \mathrm{ d } x -
\alpha \\
= &amp; \sum_{ k = m }^n f ( k ) - \int_m^n f ( x ) \mathrm{ d } x -
\left ( \lim_{ l \to \infty } ( \sum_{ k = m }^l f ( k ) - \int_m^l f (
x ) \mathrm{ d } x ) \right ) \\
= &amp; \lim_{ l \to \infty } \left ( \int_n^l f ( x ) \mathrm{ d } x -
\sum_{ k = n + 1 }^l f ( k ) \right ) \\
= &amp; \lim_{ l \to \infty } \left ( \sum_{ k = n + 1 }^l ( \int_{ k -
1 }^k f ( k ) \mathrm{ d } x - f ( k ) ) \right ) \\
\leq &amp; \lim_{ l \to \infty } \left ( \sum_{ k = n + 1 }^l ( f ( k -
1 ) - f ( k ) ) \right ) \\
\leq &amp; f ( n )
\end{aligned}
\]</span></p>
<p>而上式换个方向放缩就可以知道<span class="math inline">\(\geq
0\)</span>,这就搞定.</p>
<p>(9)(10)类似(3)(4),用等比数列控制住即可.</p>
<p>(11)的话,如若<span class="math inline">\(l = \varlimsup_{ n \to
\infty } ( a_n )^{ \frac{ 1 }{ n } }\)</span>.</p>
<p>当<span class="math inline">\(l &lt; 1\)</span>的时候,取<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(l + \epsilon &lt; 1\)</span>,则<span class="math inline">\(\exists N_0 &gt; 0\)</span>,<span class="math inline">\(\forall n \geq N_0\)</span>,<span class="math inline">\(( a_n )^{ \frac{ 1 }{ n } } &lt; l +
\epsilon\)</span>,意味着<span class="math inline">\(a_n &lt; ( l +
\epsilon )^n\)</span>,立刻见到其收敛.</p>
<p>当<span class="math inline">\(l &gt; 1\)</span>的时候,取<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(l - \epsilon &gt;
1\)</span>,则存在原数列的一个无穷子列<span class="math inline">\(\{ n_k
\}\)</span>,使得<span class="math inline">\(a_{ n_k } &gt; ( l -
\epsilon )^{ n_k } \to \infty\)</span>,当然发散.</p>
<p>而注意到根据Stolz定理:</p>
<p><span class="math display">\[
\varliminf \frac{ a_{ n + 1 } }{ a_n } \leq \varliminf \sqrt[n]{ a_n }
\leq \varlimsup \sqrt[n]{ a_n } \leq \varlimsup \frac{ a_{ n + 1 } }{
a_n }
\]</span></p>
<p>这就意味着根值判别法理论上严格强于比值判别法.</p>
<p>(12)(13)的证明,考虑当<span class="math inline">\(l = \varliminf_{ n
\to \infty } n \ln \frac{ a_n }{ a_{ n + 1 } } &gt;
1\)</span>的时候,取<span class="math inline">\(\epsilon &gt; 0 , p = l -
\epsilon &gt; 1\)</span>,那么就有<span class="math inline">\(\exists N_0
&gt; 0 , \forall n \geq N_0\)</span>,都有:</p>
<p><span class="math display">\[
\begin{aligned}
n \ln \frac{ a_n }{ a_{ n + 1 } } &amp; &gt; p \\
\frac{ a_n }{ a_{ n + 1 } } &amp; &gt; e^{ \frac{ p }{ n } } &gt; \left
( ( 1 + \frac{ 1 }{ n } )^n \right )^{ \frac{ p }{ n } } \\
\frac{ a_{ n + 1 } }{ a_n } &amp; &lt; \cfrac{ \frac{ 1 }{ ( n + 1 )^p }
}{ \frac{ 1 }{ n^p } }
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(b_n = \frac{ 1 }{ n^p
}\)</span>,由上见到<span class="math inline">\(a_n &lt; \frac{ a_{ N_0 }
}{ b_{ N_0 } } b_n\)</span>,这就控制住了.(13)同理.控制<span class="math inline">\(e\)</span>的时候改用不等式<span class="math inline">\(e &lt; ( 1 + \frac{ 1 }{ n - 1 }
)^n\)</span>即可.</p>
<p>(14)(15)仍然类似,设<span class="math inline">\(b_n = n ( \frac{ a_n
}{ a_{ n + 1 } } - 1 )\)</span>.</p>
<p>当<span class="math inline">\(l = \varliminf_{ n \to \infty } b_n
&gt; 1\)</span>的时候,取<span class="math inline">\(\epsilon &gt;
0\)</span>,<span class="math inline">\(l - \epsilon &gt;
1\)</span>,则<span class="math inline">\(\exists N_0 &gt; 0 , \forall n
\geq N_0\)</span>,<span class="math inline">\(b_n &gt; l - \epsilon = l
&#39;\)</span>.而:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ a_n }{ a_{ n + 1 } } &amp; = 1 + \frac{ b_n }{ n } \\
\ln \frac{ a_n }{ a_{ n + 1 } } &amp; = \ln ( 1 + \frac{ b_n }{ n } )
&gt; \ln ( 1 + \frac{ l &#39; }{ n } ) \\
\varliminf n \ln \frac{ a_n }{ a_{ n + 1 } } &amp; \geq \varliminf \ln (
1 + \frac{ l &#39; }{ n } )^{ n } = l &#39; &gt; 1
\end{aligned}
\]</span></p>
<p>这就做完了.(15)同理.</p>
<h6><span id="example1">Example1</span></h6>
<p>斐波那契数列<span class="math inline">\(f_0 = 0 , f_1 =
1\)</span>,求<span class="math inline">\(\sum \frac{ 1 }{ f_k
}\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(f_{ n - 1 } \leq 2 f_{ n - 2
}\)</span>,所以<span class="math inline">\(f_n = f_{ n - 1 } + f_{ n - 2
} \geq \frac{ 3 }{ 2 } f_{ n - 1 } \geq ( \frac{ 3 }{ 2 } )^{ n - 1
}\)</span>.这就做完了.</p>
<h6><span id="example2">Example2</span></h6>
<p>假设<span class="math inline">\(0 &lt;
a_n\)</span>单调递增且有界,求证:<span class="math inline">\(\sum ( 1 -
\frac{ a_k }{ a_{ k + 1 } } ) &lt; \infty\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum ( 1 - \frac{ a_k }{ a_{ k + 1 } } ) \\
= &amp; \sum{ a_k } ( \frac{ 1 }{ a_k } - \frac{ 1 }{ a_{ k + 1 } } ) \\
\leq &amp; \sup{ a } \sum ( \frac{ 1 }{ a_k } - \frac{ 1 }{ a_{ k + 1 }
} ) \\
\leq &amp; \frac{ \sup{ a } }{ a_1 }
\end{aligned}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum \frac{ 1 }{ n^p - n^q } , p &gt; q
&gt; 0\)</span>的收敛性.</p>
<p>直接考虑<span class="math inline">\(\lim_{ n \to \infty } \cfrac{
\frac{ 1 }{ n^p - n^q } }{ \frac{ 1 }{ n^p } } = 1\)</span>,所以<span class="math inline">\(p \leq 1\)</span>的时候发散,<span class="math inline">\(p &gt; 1\)</span>的时候收敛.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum \sin \frac{ 1 }{ n^2
}\)</span>的收敛性.</p>
<p>直接考虑<span class="math inline">\(\lim_{ n \to \infty } \cfrac{
\sin \frac{ 1 }{ n^2 } }{ \frac{ 1 }{ n^2 } } = 1\)</span>,所以收敛.</p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(a_n = ( 1 - \sqrt[3]{ \frac{ n - 1 }{ n +
1 } } )^p , p &gt; 0\)</span>,讨论<span class="math inline">\(\sum
a_n\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt[3]{ \frac{ n - 1 }{ n + 1 } } &amp; = ( 1 - \frac{ 1 }{ n } )^{
\frac{ 1 }{ 3 } } ( 1 + \frac{ 1 }{ n } )^{ - \frac{ 1 }{ 3 } } \\
&amp; = ( 1 - \frac{ 1 }{ 3 n } + O ( \frac{ 1 }{ n^2 } ) ) ( 1 - \frac{
1 }{ 3 n } + O ( \frac{ 1 }{ n^2 } ) ) \\
&amp; = 1 - \frac{ 2 }{ 3 n } + O ( \frac{ 1 }{ n^2 } )
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(a_n\)</span>和<span class="math inline">\(\frac{ 1 }{ n^p }\)</span>同敛散.</p>
<h6><span id="example6">Example6</span></h6>
<p>求<span class="math inline">\(S_n = \sum_{ k = 1 }^n \frac{ 1 }{
\sqrt{ k } } - 2 \sqrt{ n }\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
a_{ n + 1 } &amp; = S_{ n + 1 } - S_n \\
&amp; = \frac{ 1 }{ \sqrt{ n + 1 } } - 2 \sqrt{ n + 1 } + 2 \sqrt{ n }
\\
&amp; = \frac{ 1 }{ \sqrt{ n + 1 } } - \frac{ 2 }{ \sqrt{ n + 1 } +
\sqrt{ n } } \\
&amp; = \frac{ \sqrt{ n } - \sqrt{ n + 1 } }{ \sqrt{ n + 1 } ( \sqrt{ n
+ 1 } + \sqrt{ n } ) } \\
&amp; = \frac{ - 1 }{ \sqrt{ n + 1 } ( \sqrt{ n + 1 } + \sqrt{ n } )^2 }
= O ( - n^{ - \frac{ 3 }{ 2 } } )
\end{aligned}
\]</span></p>
<p>所以收敛.</p>
<h6><span id="example7">Example7</span></h6>
<p>求<span class="math inline">\(a_n = \frac{ 1 }{ \sqrt{ n } } - \sqrt{
\ln ( 1 + \frac{ 1 }{ n } ) }\)</span>的级数和收敛性.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ \sqrt{ n } } - \sqrt{ \ln ( 1 + \frac{ 1 }{ n }
) } \\
&amp; = \frac{ 1 }{ \sqrt{ n } } - \sqrt{ \frac{ 1 }{ n } - \frac{ 1 }{
2 n^2 } + o ( \frac{ 1 }{ n^2 } ) } \\
&amp; = \frac{ 1 }{ \sqrt{ n } } - \frac{ 1 }{ \sqrt{ n } } \left ( 1 -
\frac{ 1 }{ 2 n } + o ( \frac{ 1 }{ n } ) \right )^{ \frac{ 1 }{ 2 } }
\\
&amp; = \frac{ 1 }{ \sqrt{ n } } - \frac{ 1 }{ \sqrt{ n } } \left ( 1 -
\frac{ 1 }{ 4 n } + o ( \frac{ 1 }{ n } ) \right ) \\
&amp; = O ( n^{ - \frac{ 3 }{ 2 } } )
\end{aligned}
\]</span></p>
<p>所以收敛.</p>
<h6><span id="example8">Example8</span></h6>
<p>设<span class="math inline">\(\zeta ( a ) = \sum_{ k = 1 }^{ \infty }
\frac{ 1 }{ k^a }\)</span>,求<span class="math inline">\(\lim_{ \sigma
\to 0 + 0 } \sigma \zeta ( 1 + \sigma )\)</span>和<span class="math inline">\(\lim_{ \sigma \to 0 + 0 } \left ( \zeta ( 1 +
\sigma ) - \frac{ 1 }{ \sigma } \right )\)</span>.</p>
<p>取<span class="math inline">\(f ( x ) = \frac{ 1 }{ x^{ 1 + \sigma }
}\)</span>,设<span class="math inline">\(F ( x ) = \int_1^x f ( t )
\mathrm{ d } t\)</span>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = n + 1 }^{ \infty } a_k &amp; \leq F ( + \infty ) - F ( n )
\leq \sum_{ k = n }^{ \infty } a_k \\
F ( + \infty ) - F ( n + 1 ) &amp; \leq \sum_{ k = n + 1 }^{ \infty }
a_k \leq F ( + \infty ) - F ( n ) \\
\frac{ 1 }{ \sigma } \frac{ 1 }{ ( n + 1 )^\sigma } &amp; \leq \sum_{ k
= n + 1 }^{ \infty } a_k \leq \frac{ 1 }{ \sigma } \frac{ 1 }{ n^\sigma
} \\
\frac{ 1 }{ ( n + 1 )^\sigma } &amp; \leq \sigma \sum_{ k = n + 1 }^{
\infty } a_k \leq \frac{ 1 }{ n^\sigma }
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(n = 0\)</span>和<span class="math inline">\(n = 1\)</span>得到<span class="math inline">\(1
\leq \sigma \zeta ( 1 + \sigma ) \leq \sigma + 1\)</span>,于是<span class="math inline">\(\lim_{ \sigma \to 0 + 0 } \sigma \zeta ( 1 +
\sigma ) = 1\)</span>.</p>
<p>而同理,见到:</p>
<p><span class="math display">\[
\zeta ( 1 + \sigma ) = 1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots +
\frac{ 1 }{ n^{ 1 + \sigma } } + \sum_{ k = n + 1 }^{ \infty } \frac{ 1
}{ k^{ 1 + \sigma } }
\]</span></p>
<p>而:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; 1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 +
\sigma } } + \frac{ 1 }{ \sigma } \frac{ 1 }{ ( n + 1 )^\sigma } \\
\leq &amp; \zeta ( 1 + \sigma ) \leq \\
1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 + \sigma
} } + \frac{ 1 }{ \sigma } \frac{ 1 }{ n^\sigma } \\

\end{aligned}\]</span>
<p>$$</p>
<p>用上述不等式:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; 1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 +
\sigma } } + \frac{ 1 }{ \sigma } \left ( \frac{ 1 }{ ( n + 1 )^\sigma }
- 1 \right ) \\
\leq &amp; \zeta ( 1 + \sigma ) - \frac{ 1 }{ \sigma } \leq \\
1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 + \sigma
} } + \frac{ 1 }{ \sigma } \left ( \frac{ 1 }{ n^\sigma } - 1 \right )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>两边对<span class="math inline">\(\sigma \to 0 +
0\)</span>取极限,见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; 1 + \frac{ 1 }{ 2 } + \cdots + \frac{ 1 }{ n } - \ln ( n + 1 ) \\
\leq &amp; \varliminf_{ \sigma \to 0 + 0 } ( \zeta ( 1 + \sigma ) -
\frac{ 1 }{ \sigma } ) \leq \varlimsup_{ \sigma \to 0 + 0 } ( \zeta ( 1
+ \sigma ) - \frac{ 1 }{ \sigma } ) \leq \\
1 + \frac{ 1 }{ 2 } + \cdots + \frac{ 1 }{ n } - \ln ( n )
\end{aligned}
\]</span></p>
<p>两边对<span class="math inline">\(n\)</span>取极限得到<span class="math inline">\(\lim_{ \sigma \to 0 + 0 } \zeta ( 1 + \sigma ) -
\frac{ 1 }{ \sigma } = \gamma\)</span>.</p>
<h6><span id="example9">Example9</span></h6>
<p><span class="math inline">\(a_n &gt; 0\)</span>,证明:若<span class="math inline">\(\varlimsup_{ n \to \infty } a_n^{ \frac{ 1 }{ \ln
n } } &lt; \frac{ 1 }{ e }\)</span>则收敛.若<span class="math inline">\(\varliminf_{ n \to \infty } a_n^{ \frac{ 1 }{ \ln
n } } &gt; \frac{ 1 }{ e }\)</span>则发散.</p>
<p>只证前者,则存在<span class="math inline">\(p &gt; 1\)</span>使得<span class="math inline">\(\varlimsup_{ n \to \infty } a_n^{ \frac{ 1 }{ \ln
n } } &lt; \frac{ 1 }{ e^p }\)</span>,两边取<span class="math inline">\(\ln\)</span>就做完了.</p>
<h6><span id="example10">Example10</span></h6>
<p><span class="math inline">\(a_n &gt; 0\)</span>,证明:若<span class="math inline">\(\varliminf_{ n \to \infty } \cfrac{ \ln \frac{ 1
}{ a_n } }{ \ln n } &gt; 1\)</span>则收敛.若<span class="math inline">\(\varlimsup_{ n \to \infty } \cfrac{ \ln \frac{ 1
}{ a_n } }{ \ln n } &lt; 1\)</span>则发散.</p>
<p>只证前者,考虑前者等价于<span class="math inline">\(\varlimsup_{ n \to
\infty } \ln a_n^{ \frac{ 1 }{ \ln n } } &lt; -
1\)</span>,转化为Example9.</p>
<h6><span id="example11">Example11</span></h6>
<p>数列<span class="math inline">\(\{ a_n \}\)</span>恒正,数列<span class="math inline">\(b_n = \frac{ a_n }{ a_{ n + 1 } } - 1 - \frac{ 1
}{ n }\)</span>的部分和有界,求证<span class="math inline">\(\sum
a_n\)</span>发散.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ a_n }{ a_{ n + 1 } } &amp; = 1 + \frac{ 1 }{ n } + b_n \leq e^{
\frac{ 1 }{ n } + b_n } \\
\frac{ a_1 }{ a_{ n + 1 } } &amp; \leq e^{ \ln n + \gamma + M } = cn \\
a_n &amp; \geq \frac{ ca_1 }{ n }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h4><span id="交错级数">交错级数</span></h4>
<p>考虑<span class="math inline">\(\sum ( - 1 )^{ n - 1 }
a_n\)</span>,其中<span class="math inline">\(a_n &gt; 0\)</span>.</p>
<p>Leibniz定理:如果<span class="math inline">\(a_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>,则交错级数收敛.</p>
<p>考虑<span class="math inline">\(S_{ 2 n } = ( a_1 - a_2 ) + ( a_3 -
a_4 ) + \cdots\)</span>而<span class="math inline">\(S_{ 2 n + 1 } = a_1
- ( a_2 - a_3 ) - ( a_4 - a_5 ) - \cdots\)</span>,所以见到<span class="math inline">\(S_{ 2 n }\)</span>单调上升,<span class="math inline">\(S_{ 2 n + 1 }\)</span>单调下降.并且显然<span class="math inline">\(S_{ 2 n } &lt; S_{ 2 n + 1 }\)</span>.而且<span class="math inline">\(S_{ 2 n + 1 } - S_{ 2 n } = a_{ 2 n + 1 } \to
0\)</span>,所以二者均收敛且极限相同极限相同.</p>
<p>当然,这也只是DA判别法的一个特例.</p>
<p>Leibniz定理还可以如此理解:由于后面的项正负抵消,我们发现:</p>
<p><span class="math display">\[
| \sum_{ k = n }^\infty ( - 1 )^k a_k | \leq a_n \to 0
\]</span></p>
<p>也就是后面的交错都可以被首项控制住.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(\sum ( - 1 )^{ n } \frac{ \ln^2 n }{
n }\)</span>的收敛性.</p>
<p>取<span class="math inline">\(f ( x ) = \frac{ \ln^2 x }{ x
}\)</span>,则<span class="math inline">\(f &#39; = \frac{ 2 \ln x -
\ln^2 x }{ x^2 }\)</span>,显然当<span class="math inline">\(x\)</span>足够大的时候<span class="math inline">\(f &#39; ( x ) &lt; 0\)</span>且<span class="math inline">\(f ( + \infty ) = 0\)</span>,所以原式收敛.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(a_n &gt; 0\)</span>,求证:若<span class="math inline">\(\varliminf n ( \frac{ a_n }{ a_{ n + 1 } } - 1 )
&gt; 0\)</span>,则<span class="math inline">\(\sum ( - 1 )^n
a_n\)</span>收敛.</p>
<p>考虑<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(\exists \epsilon &gt; 0\)</span>,使得<span class="math inline">\(n ( \frac{ a_n }{ a_{ n + 1 } } - 1 ) &gt;
\epsilon\)</span>,也就是<span class="math inline">\(\frac{ a_{ n + 1 }
}{ a_n } &lt; \frac{ n }{ n + \epsilon } &lt; 1\)</span>,这就能证明<span class="math inline">\(a_n\)</span>单调递减.下面只需要证明<span class="math inline">\(\lim a_n = 0\)</span>即可.</p>
<p>而考虑取定<span class="math inline">\(N &gt; 0\)</span>,对于<span class="math inline">\(n \geq N\)</span>,有<span class="math inline">\(\frac{ a_n }{ a_N } = \prod_{ k = N }^{ n - 1 }
\frac{ a_{ k + 1 } }{ a_{ k } }\)</span>,<span class="math inline">\(a_N\)</span>是定死的,下面只需要证明后面那个乘积趋近于<span class="math inline">\(0\)</span>.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \prod_{ k = N }^{ n - 1 } \frac{ a_{ k + 1 } }{ a_{ k } } \\
&lt; &amp; \prod_{ k = N }^{ n - 1 } \frac{ n }{ n + \epsilon } \\
= &amp; \prod_{ k = N }^{ n - 1 } \frac{ 1 }{ 1 + \frac{ \epsilon }{ n }
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>然而注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \prod_{ k = N }^{ n - 1 } ( 1 + \frac{ \epsilon }{ n } ) \\
\geq &amp; 1 + \frac{ \epsilon }{ N } + \cdots + \frac{ \epsilon }{ n -
1 } \to \infty
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f ( x ) = \sum_{ n = 1 }^\infty \frac{
( - 1 )^{ n - 1 } }{ n^x } , x \in ( 0 , \infty )\)</span>,求<span class="math inline">\(\sup f\)</span>和<span class="math inline">\(\inf
f\)</span>.</p>
<p>首先显然能搞出<span class="math inline">\(f ( x ) \in C^\infty ( 0 ,
+ \infty
)\)</span>,原因是能证明其和其若干阶导数都内闭一致收敛(用DA判法).</p>
<p>首先交错级数的绝对值要<span class="math inline">\(\leq\)</span>首项,所以先猜<span class="math inline">\(\sup f = 1\)</span>.考虑:</p>
<p><span class="math display">\[
f ( x ) = 1 - \sum_{ n = 1 }^\infty \left ( \frac{ 1 }{ ( 2 n )^x } -
\frac{ 1 }{ ( 2 n + 1 )^x } \right )
\]</span></p>
<p>容易见到只要让<span class="math inline">\(x \to
\infty\)</span>那就逐项趋近于<span class="math inline">\(0\)</span>.</p>
<p>还有一个问题是<span class="math inline">\(\inf f\)</span>.考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } - \frac{ 1 }{ ( 2 n
+ 1 )^x } \\
= &amp; \sum_{ n = 1 }^\infty \int_{ 2 n }^{ 2 n + 1 } \frac{ x \mathrm{
d } t }{ t^{ x + 1 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里注意到我们积分的那几段都是<span class="math inline">\([ 2 n , 2 n
+ 1 ]\)</span>,我们可以把奇数段补上,因为<span class="math inline">\(x
&gt; 0\)</span>,所以补的那一段更大,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ n = 1 }^\infty \int_{ 2 n }^{ 2 n + 1 } \frac{ x \mathrm{ d
} t }{ t^{ x + 1 } } \\
\leq &amp; \frac{ 1 }{ 2 } \int_1^{ + \infty } \frac{ \mathrm{ d } t }{
t^{ x + 1 } } = \frac{ 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(f ( x ) = 1 - \sum_{ n = 1 }^\infty
\left ( \frac{ 1 }{ ( 2 n )^x } - \frac{ 1 }{ ( 2 n + 1 )^x } \right
)\)</span>,所以<span class="math inline">\(f ( x ) \geq \frac{ 1 }{ 2
}\)</span>.</p>
<p>接下来来证明其能取到,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } - \frac{ 1 }{ ( 2 n
+ 1 )^x } \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } \left ( 1 - \frac{
1 }{ ( 1 + \frac{ 1 }{ 2 n } )^x } \right ) \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } \left ( \frac{ x
}{ 2 n } + O ( \frac{ x }{ n^2 } ) \right ) \\
= &amp; \frac{ x }{ 2^{ x + 1 } } \zeta ( x + 1 ) + xO ( 1 ) \\
\to &amp; \frac{ 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>原因是<span class="math inline">\(\lim_{ x \to 0 + 0 } x \zeta ( x +
1 ) \to 1\)</span>,这个结论我们之前搞定过.</p>
<h4><span id="积分判别法">积分判别法</span></h4>
<p>取<span class="math inline">\(\omega_n = \sup_{ [ n , n + 1 ] } f -
\inf_{ [ n , n + 1 ] } f \geq 0\)</span>.我们声称若<span class="math inline">\(\sum \omega_n &lt; \infty\)</span>,则<span class="math inline">\(\int_1^{ \infty } f ( x ) \mathrm{ d }
x\)</span>与<span class="math inline">\(\sum f ( n
)\)</span>收敛性相同.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ k = 1 }^n f_k - \int_1^{ n + 1 } f ( x ) \mathrm{ d } x \\
= &amp; \sum_{ k = 1 }^n \int_k^{ k + 1 } ( f ( k ) - f ( x ) ) \mathrm{
d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑证明右式绝对收敛,有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = 1 }^n \int_k^{ k + 1 } | f ( k ) - f ( x ) | \mathrm{ d
} x \\
\leq &amp; \sum_{ k = 1 }^n \int_k^{ k + 1 } \omega_k \mathrm{ d } x \\
= &amp; \sum_{ k = 1 }^{ n + 1 } \omega_k
\end{aligned}
\]</span></p>
<p>这就证毕.</p>
<p>问题又来到如何搞定<span class="math inline">\(\sum \omega_n &lt;
\infty\)</span>的条件,其实只要有界变差就行了对吧,我们断言:如果<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f
&#39;\)</span>可积且<span class="math inline">\(\int_1^{ \infty } | f
&#39; | \mathrm{ d } x &lt; \infty\)</span>则<span class="math inline">\(\sum \omega_n &lt; \infty\)</span>.</p>
<p>对于<span class="math inline">\(\omega_n\)</span>,不妨<span class="math inline">\([ n , n + 1 ]\)</span>的上界在<span class="math inline">\(x_1\)</span>处取到,下界在<span class="math inline">\(x_2\)</span>处取到,于是:</p>
$$
<span class="math display">\[\begin{aligned}
\omega_n &amp; = f ( x_1 ) - f ( x_2 ) \\
&amp; = | \int_{ x_1 }^{ x_2 } f &#39; \mathrm{ d } x | \\
&amp; \leq | \int_{ x_1 }^{ x_2 } | f &#39; | \mathrm{ d } x | \\
&amp; \leq \int_{ n }^{ n + 1 } | f &#39; | \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是<span class="math inline">\(\sum \omega \leq \int_1^{ + \infty }
| f &#39; | \mathrm{ d } x\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum \frac{ \sin ( n^\alpha x ) }{
n^\beta }\)</span>的收敛性,其中<span class="math inline">\(\beta &gt;
\alpha &gt; 0 , \alpha + \beta &gt; 1\)</span>.</p>
<p>用积分判别法,考虑取<span class="math inline">\(f ( t ) = \frac{ \sin
( t^\alpha x ) }{ t^\beta }\)</span>,考虑:</p>
<p><span class="math display">\[
f &#39; ( t ) = \frac{ x \alpha t^{ \alpha - 1 + \beta } \cos ( t^\alpha
x ) - \beta t^{ \beta - 1 } \sin ( t^\alpha x ) }{ t^{ 2 \beta } }
\]</span></p>
<p>逐项观察,都是<span class="math inline">\(O ( \frac{ 1 }{ t^{ \beta -
\alpha + 1 } } )\)</span>级别,这样<span class="math inline">\(\int | f
&#39; | \mathrm{ d } t\)</span>就收敛了.</p>
<p>那就只需要看积分的收敛性,取<span class="math inline">\(s =
t^\alpha\)</span>考察:</p>
$$
<span class="math display">\[\begin{aligned}
\int_1^{ \infty } f ( t ) \mathrm{ d } t &amp; = \int_1^{ \infty }
\frac{ \sin ( t^\alpha x ) }{ t^\beta } \mathrm{ d } t \\
&amp; = \int_1^{ \infty } \frac{ \sin ( s x ) \frac{ 1 }{ \alpha } s^{
\frac{ 1 }{ \alpha } - 1 } }{ s^\frac{ \beta }{ \alpha } } \mathrm{ d }
s \\
&amp; = \int_1^{ \infty } \frac{ \sin ( s x ) }{ \alpha s^\frac{ \beta +
\alpha - 1 }{ \alpha } } \mathrm{ d } s \\

\end{aligned}\]</span>
<p>$$</p>
<p>后者用DA判法知道收敛.</p>
<h4><span id="级数的交换顺序">级数的交换顺序</span></h4>
<p>定义<span class="math inline">\(\mathbb{ N
}_+\)</span>的一个重排<span class="math inline">\(f : \mathbb{ N }_+ \to
\mathbb{ N }_+\)</span>,当且仅当<span class="math inline">\(f ( 1 ) , f
( 2 ) , \cdots\)</span>这个数列中,每个正整数都恰好出现一次.</p>
<p>我们声称正项级数满足:<span class="math inline">\(\sum a_n = \sum a_{
f ( n ) }\)</span>.</p>
<p>如何证明呢?</p>
<p>当<span class="math inline">\(\sum a_n &lt;
\infty\)</span>的时候,考虑设<span class="math inline">\(A_n = \sum_{ k =
1 }^n a_k , B_n = \sum_{ k = 1 }^n a_{ f ( k ) }\)</span>.考虑取<span class="math inline">\(N_n = \max_{ 1 \leq k \leq n } f ( k
)\)</span>,那就有:</p>
<p><span class="math display">\[
B_n = \sum_{ k = 1 }^n a_{ f ( k ) } \leq A_{ N_n } \leq \sum_{ 1 }^{
\infty } a_n
\]</span></p>
<p>于是<span class="math inline">\(B_n\)</span>当然是收敛的,并且<span class="math inline">\(\sum a_{ f ( n ) } \leq \sum
a_n\)</span>,而如果<span class="math inline">\(a_{ f ( n )
}\)</span>是<span class="math inline">\(a_n\)</span>的重排,那么反之,<span class="math inline">\(a_n\)</span>是<span class="math inline">\(a_{ f (
n ) }\)</span>的重排,于是<span class="math inline">\(\sum a_{ f ( n ) }
\geq \sum a_n\)</span>,这就证明了二者相同.</p>
<p>既如此,如果<span class="math inline">\(\sum
a_n\)</span>发散的时候,就可以反证法证明<span class="math inline">\(\sum
a_{ f ( n ) }\)</span>不可能收敛.这样就完成了证明.</p>
<p>下面我们证明,如果<span class="math inline">\(\sum
a_n\)</span>绝对收敛,换言之<span class="math inline">\(\sum | a_n | &lt;
\infty\)</span>,那么仍有<span class="math inline">\(\sum a_n = \sum a_{
f ( n ) }\)</span>.</p>
<p>考虑取<span class="math inline">\(a_n^+ = \frac{ | a_n | + a_n }{ 2 }
, a_n^- = \frac{ | a_n | - a_n }{ 2 }\)</span>.那考虑<span class="math inline">\(0 \leq a_n^+ \leq | a_n | , 0 \leq a_n^- \leq |
a_n |\)</span>,所以它们当然都绝对收敛,那当然有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum a_n &amp; = \sum ( a_n^+ - a_n^- ) \\
&amp; = ( \sum a_n^+ ) - ( \sum a_n^- )
\end{aligned}
\]</span></p>
<p>而后者当然可以随意重排.</p>
<p>那么对于条件收敛呢?我们有<strong>黎曼重排定理</strong>:如果<span class="math inline">\(\sum a_n\)</span>条件收敛,则<span class="math inline">\(\forall B \leq A\)</span>,其中<span class="math inline">\(A , B \in \mathbb{ R } \cup \{ \pm \infty
\}\)</span>,则存在重排<span class="math inline">\(f\)</span>,令<span class="math inline">\(S_n = \sum_{ k = 1 }^n a_{ f ( k )
}\)</span>,有:</p>
<p><span class="math display">\[
\varliminf S_n = B , \varlimsup S_n = A
\]</span></p>
<p>为证明此,考虑设<span class="math inline">\(I_+ = \{ n \in \mathbb{ N
}_+ \mid a_n \geq 0 \} = \{ n_1 &lt; n_2 \cdots \}\)</span>,<span class="math inline">\(I_-\)</span>类似设出.</p>
<p>容易见到首先<span class="math inline">\(\lim a_n \to
0\)</span>,并且<span class="math inline">\(\sum_{ n \in I_+ } a_n = +
\infty , \sum_{ n \in I_- } a_n = - \infty\)</span>.</p>
<p>考虑先从<span class="math inline">\(I_+\)</span>里取数,然后不断加加加加加直到超过<span class="math inline">\(A\)</span>,由于正的部分相加是正无穷,这当然能做到,然后就继续从<span class="math inline">\(I_-\)</span>里取数开始回退,退退退退到<span class="math inline">\(B\)</span>之下,再重复上述过程.由于<span class="math inline">\(a_n \to 0\)</span>,这玩意当然会满足条件.</p>
<p>那么如果<span class="math inline">\(A\)</span>是正无穷呢?那没关系,我就每次加数的时候变化<span class="math inline">\(A\)</span>,第一次个循环令<span class="math inline">\(A = 1\)</span>,第二次令<span class="math inline">\(A =
2\)</span>,以此类推.由此见上述命题的合理性.而且具体的论证过程只需要对这上面写抽象语言就行.</p>
<p>可是,难道一般的级数就真的不能交换顺序了嘛?事实上使用柯西准则,我们可以证明如果重排是局部的,或者说<span class="math inline">\(\exists M &gt; 0 , \forall n , | n - f ( n ) |
\leq M &lt;
\infty\)</span>,换言之交换的距离有上界,那交换后敛散性不变.</p>
<p>这个怎么证明呢?首先如果原级数收敛的话,用柯西准则,因为通项趋于<span class="math inline">\(0\)</span>,所以往外扩张适当有界长度(实际上就是<span class="math inline">\(M\)</span>)应当无影响.如果原级数发散的话,如果通项还是不趋于<span class="math inline">\(0\)</span>那当然还是完蛋,否则的话还可以用上面的证明.这就证毕了.</p>
<h6><span id="example">Example</span></h6>
<p><span class="math inline">\(a_n &gt; 0\)</span>,当<span class="math inline">\(\sum \frac{ 1 }{ a_n } &lt;
\infty\)</span>的时候,求证<span class="math inline">\(\sum \frac{ n }{
\sum_{ k = 1 }^n a_k } &lt; \infty\)</span>.</p>
<p>首先考虑<span class="math inline">\(\{ a_n
\}\)</span>单增的情况,如果不单增的话,可以直接对其进行排序.</p>
<p>考虑<span class="math inline">\(\frac{ 2 n }{ \sum_{ k = 1 }^{ 2 n }
a_k } &lt; \frac{ 2 n }{ na_n } = \frac{ 2 }{ a_n }\)</span>,同理<span class="math inline">\(\frac{ 2 n - 1 }{ \sum_{ k = 1 }^{ 2 n } a_k }
&lt; \frac{ 2 n - 1 }{ na_n } &lt; \frac{ 2 }{ a_n
}\)</span>,于是证毕.</p>
<h4><span id="级数的乘法">级数的乘法</span></h4>
<p>考虑<span class="math inline">\(( \sum a_j ) ( \sum b_k ) = \sum a_j
b_k\)</span>,首要的问题在于如何指定后者的求和顺序.</p>
<p>柯西策略是,考虑取<span class="math inline">\(c_n = \sum_{ j + k = n +
1 } a_j b_k\)</span>,然后取原式顺序为<span class="math inline">\(\sum
c_n\)</span>.此好处是可以求解生成函数乘积,<span class="math inline">\((
\sum a_j x^j ) ( \sum b_k x^k )\)</span>.</p>
<p>矩形策略是,考虑取<span class="math inline">\(c_n = \sum_{ \max ( j ,
k ) = n } a_j b_k\)</span>,然后取原式顺序为<span class="math inline">\(\sum c_n\)</span>.此好处是它的求和天然是<span class="math inline">\(( \sum_{ j = 1 }^n a_j ) ( \sum_{ k = 1 }^n b_k
)\)</span>的极限.所以此方法天然有如果<span class="math inline">\(\sum
a_j = A , \sum b_k = B\)</span>,则<span class="math inline">\(\sum c =
AB\)</span>.</p>
<p>接下来我们证明,如果<span class="math inline">\(\sum a\)</span>和<span class="math inline">\(\sum
b\)</span>都绝对收敛,那它们的乘积任意排列都是相等的.换言之只要双重指标集合<span class="math inline">\(\{ ( j_i , k_i ) \} = \{ ( j , k )
\}\)</span>那就都收敛于同一值.</p>
<p>证明策略类似,取<span class="math inline">\(N_n = \max_{ 1 \leq i \leq
n } ( j_i , k_i )\)</span>,那么当然有:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n | a_{ j_i } b_{ k_i } | \leq ( \sum_{ j = 1 }^{ N_n } |
a_{ j } | ) ( \sum_{ k = 1 }^{ N_n } | b_{ k } | )
\]</span></p>
<p>那当然就绝对收敛,再类似之前的可以证明其与顺序无关,这个时候用矩形策略就可以知道最终就收敛于<span class="math inline">\(( \sum a ) ( \sum b )\)</span>.</p>
<p>如果是条件收敛,矩形和当然没问题,仍然收敛,难点当然在于柯西和何时收敛?我们声称:如果<span class="math inline">\(\sum a_n\)</span>收敛,<span class="math inline">\(\sum | b_n | &lt;
\infty\)</span>,也就是一个收敛一个绝对收敛,我们就能推出柯西和是收敛的而且就等于矩形和.</p>
<p>考虑设矩形法的<span class="math inline">\(u_k = \sum_{ \max ( i , j )
= k } a_i b_j\)</span>,柯西法的<span class="math inline">\(c_k = \sum_{
i + j = k + 1 } a_i b_j\)</span>,考虑求:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = 1 }^n u_k - c_k | \\
= &amp; | \sum_{ i_j &gt; n + 1 , i \leq n , j \leq n } a_i b_j | \\
\leq &amp; \sum_{ i = 2 }^n | b_i | | \sum_{ j = n - i + 2 }^n a_j | \\
= &amp; \sum_{ i = 2 }^N | b_i | | \sum_{ j = n - i + 2 }^n a_j | +
\sum_{ i = N + 1 }^n | b_i | | \sum_{ j = n - i + 2 }^n a_j |
\end{aligned}
\]</span></p>
<p>接下来用柯西收敛原理,先取<span class="math inline">\(N\)</span>,只要<span class="math inline">\(N\)</span>足够大,由于<span class="math inline">\(|
\sum_{ j = n - i + 2 }^n a_j |\)</span>当然是有界的,因为<span class="math inline">\(\sum a\)</span>收敛,只要<span class="math inline">\(N\)</span>足够大,不管<span class="math inline">\(n\)</span>如何,<span class="math inline">\(\sum_{
i = N + 1 }^n | b_i
|\)</span>用柯西收敛原理就足够小.这样后半项就解决了.</p>
<p>前半项同理,在<span class="math inline">\(N\)</span>取定的时候<span class="math inline">\(\sum_{ i = 2 }^N | b_i
|\)</span>就取定有界了.而只要在此基础上使得<span class="math inline">\(n\)</span>尽可能大,<span class="math inline">\(|
\sum_{ j = n - i + 2 }^n a_j
|\)</span>用柯西收敛原理就控制住了,于是整体就很小.那就证明了此时柯西和恰好就是矩形和.</p>
<p>一般的柯西和没有这么好的结论,但其实证明可以类似上面,具体地,我们取<span class="math inline">\(A_n = \sum_{ k = 1 }^n a_k , B_n = \sum_{ k = 1
}^n b_k\)</span>并且<span class="math inline">\(\lim A , \lim
B\)</span>都存在,取柯西和<span class="math inline">\(c_n = \sum_{ k = 1
}^n a_k b_{ n - k + 1 }\)</span>,我们断言<span class="math inline">\(C_n
= \sum_{ k = 1 }^n c_k\)</span>收敛当且仅当极限<span class="math inline">\(\lim_{ n \to \infty } \sum_{ k = 1 }^n a_k \sum_{
j = n - k + 1 }^n b_j\)</span>存在.</p>
<p>原因是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = 1 }^n a_k \sum_{ j = n - k + 1 }^n b_j \\
= &amp; \sum_{ k = 1 }^n a_k ( B_n - B_{ n - k } ) \\
= &amp; B_n A_n - ( \sum_{ k = 1 }^{ n - 1 } a_k B_{ n - k } ) \\
= &amp; B_n A_n - C_{ n - 1 }
\end{aligned}
\]</span></p>
<p>这就证毕,而且当然见到只有上述极限为<span class="math inline">\(0\)</span>的时候,柯西和才会有<span class="math inline">\(\lim C = ( \lim A ) ( \lim B )\)</span>.</p>
<h4><span id="无穷乘积">无穷乘积</span></h4>
<p>对于数列<span class="math inline">\(\{ a_n \}\)</span>,设<span class="math inline">\(A_n = \prod_{ k = 1 }^n a_k\)</span>,若<span class="math inline">\(\lim_{ n \to \infty }
A_n\)</span>存在且非零,则称<span class="math inline">\(\prod_{ k = 1 }^{
+ \infty }
a_k\)</span>收敛.为什么这里要求非零呢?因为我们希望类似无穷和,这里去掉前有限项后,敛散性不变.这就要求我们最好判掉零的情况.如若其极限为<span class="math inline">\(0\)</span>,则仍称其发散,但有的时候发散到零也会有一些性质,到时我们会单独讨论.</p>
<p>既然如此,不妨设<span class="math inline">\(a_n \ne
0\)</span>.有以下性质:</p>
<ol type="1">
<li><p>若<span class="math inline">\(\prod a_n\)</span>收敛,则<span class="math inline">\(\lim a_n = 1\)</span>.既然如此,<span class="math inline">\(a_n\)</span>从某一项开始就满足<span class="math inline">\(a_n &gt; 0\)</span>.之后不妨干脆设<span class="math inline">\(a_n &gt; 0\)</span>.</p></li>
<li><p><span class="math inline">\(A_n\)</span>有非<span class="math inline">\(0\)</span>极限当且仅当<span class="math inline">\(\ln A_n\)</span>有极限.</p></li>
<li><p>柯西收敛准则:<span class="math inline">\(A_n\)</span>有非零极限的必要条件是<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall N
\leq n \leq m\)</span>,<span class="math inline">\(| 1 - \prod_{ k = n
}^m a_k | &lt; \epsilon\)</span>.特别地,如果<span class="math inline">\(\forall a_n \ne
0\)</span>,则上式为充要条件.</p></li>
</ol>
<p>(1)(2)显然.</p>
<p>(3)的话也比较显然.</p>
<p>总之,既然<span class="math inline">\(\lim a_n \to
1\)</span>,不妨干脆设其为<span class="math inline">\(1 +
a_n\)</span>,其中<span class="math inline">\(\lim a_n =
0\)</span>,从而原本要研究的<span class="math inline">\(\prod ( 1 + a_n
)\)</span>可以转为研究<span class="math inline">\(\sum \ln ( 1 + a_n
)\)</span>.</p>
<ol type="1">
<li><p>当<span class="math inline">\(a_n\)</span>定号的时候,<span class="math inline">\(\sum \ln ( 1 + a_n )\)</span>和<span class="math inline">\(\sum a_n\)</span>的敛散性相同.</p></li>
<li><p>当<span class="math inline">\(a_n\)</span>不定号的时候,若<span class="math inline">\(\sum a_n^2 &lt; \infty\)</span>,则<span class="math inline">\(\sum \ln ( 1 + a_n )\)</span>和<span class="math inline">\(\sum a_n\)</span>的敛散性相同.同理如若<span class="math inline">\(\sum
a_n^2\)</span>发散,则上述两个级数至少一个发散.</p></li>
<li><p><span class="math inline">\(\sum | \ln ( 1 + a_n )
|\)</span>和<span class="math inline">\(\sum | a_n
|\)</span>的敛散性相同.</p></li>
</ol>
<p>(1)是因为<span class="math inline">\(\lim \frac{ \ln ( 1 + a_n ) }{
a_n } = 1\)</span>.</p>
<p>(2)是因为<span class="math inline">\(a_n - \ln ( 1 + a_n
)\)</span>可以被<span class="math inline">\(a_n^2\)</span>控制住,原因是<span class="math inline">\(a_n \to 0\)</span>,换言之存在<span class="math inline">\(c_1 , c_2\)</span>使得<span class="math inline">\(c_1 x^2 &lt; a_n - \ln ( 1 + a_n ) &lt; c_2
x^2\)</span>,只需要对<span class="math inline">\(0\)</span>附近做个简单放缩.既然它们的差收敛,那它们当然敛散性相同.</p>
<p>(3)还是因为<span class="math inline">\(\lim \frac{ | \ln ( 1 + x ) |
}{ | x | } = 1\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(| x | &lt; 1\)</span>的时候,求<span class="math inline">\(\prod_{ k = 1 } ( 1 + x^{ 2^{ k - 1 } }
)\)</span>的极限.</p>
<p>容易见到<span class="math inline">\(A_n = \prod_{ k = 1 }^n ( 1 + x^{
2^{ k - 1 } } ) = \frac{ 1 - x^{ 2^n } }{ 1 - x
}\)</span>,这样自然就收敛了.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\prod_{ k = 1 } \cos \frac{ \varphi }{
2^k }\)</span>.</p>
<p>当<span class="math inline">\(\varphi \ne 0\)</span>的时候,考虑<span class="math inline">\(A_n = \prod_{ k = 1 }^n \cos \frac{ \varphi }{ 2^k
} = \frac{ \sin \varphi }{ 2^n \sin \frac{ \varphi }{ 2^n }
}\)</span>.虽然这里当<span class="math inline">\(\varphi = 2^k
\pi\)</span>的时候会有若干项分母为<span class="math inline">\(0\)</span>,但由于我们可以干脆去掉这前几项,而只看后几项分母均不为<span class="math inline">\(0\)</span>,当然收敛于<span class="math inline">\(\frac{ \sin \varphi }{ \varphi }\)</span>.</p>
<p>而<span class="math inline">\(\varphi =
0\)</span>的时候每一项都是<span class="math inline">\(1\)</span>,乘起来仍然收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑<span class="math inline">\(\Gamma ( x ) = \frac{ 1 }{ x }
\prod_{ n = 1 }^{ \infty } \frac{ ( 1 + \frac{ 1 }{ n } )^x }{ 1 +
\frac{ x }{ n } }\)</span>敛散性,其中<span class="math inline">\(x \ne 0
, - 1 , - 2 , \cdots\)</span>.</p>
<p>直接泰勒展开,见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ ( 1 + \frac{ 1 }{ n } )^x }{ 1 + \frac{ x }{ n } } \\
= &amp; ( 1 + \frac{ x }{ n } + \frac{ x ( x - 1 ) }{ 2 n^2 } + o (
\frac{ 1 }{ n^2 } ) ) ( 1 - \frac{ x }{ n } + \frac{ x^2 }{ n^2 } + o (
\frac{ 1 }{ n^2 } ) ) \\
= &amp; 1 + \frac{ x ( x - 1 ) }{ 2 n^2 } + o ( \frac{ 1 }{ n^2 } )
\end{aligned}
\]</span></p>
<p>这就绝对收敛了.</p>
<p>而我们观察<span class="math inline">\(A_n\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
A_n &amp; = \frac{ 1 }{ x } \prod_{ k = 1 }^{ n } \frac{ ( \frac{ k + 1
}{ k } )^x }{ 1 + \frac{ x }{ k } } \\
&amp; = \frac{ ( n + 1 )^x }{ x ( 1 + \frac{ x }{ 1 } ) \cdots ( 1 +
\frac{ x }{ n } ) } \\
&amp; = ( \frac{ n + 1 }{ n } )^x \frac{ n ! n^x }{ x^{ \overline{ n + 1
} } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是见到:</p>
<p><span class="math display">\[
\frac{ \Gamma ( x + 1 ) }{ \Gamma ( x ) } = \lim_{ n \to \infty } \frac{
( n + 1 ) x }{ x + 1 + n } = x
\]</span></p>
<p>所以<span class="math inline">\(\Gamma ( x + 1 ) = x \Gamma ( x
)\)</span>,而且<span class="math inline">\(\Gamma ( 1 ) =
1\)</span>,所以<span class="math inline">\(\Gamma ( n ) = n
!\)</span>,这实际上是阶乘函数的一个推广.</p>
<p>而此时有<span class="math inline">\(\Gamma ( x + 1 ) = x \Gamma ( x )
= \prod_{ n = 1 }^\infty \frac{ ( 1 + \frac{ 1 }{ n } )^x }{ 1 + \frac{
x }{ n } }\)</span>.</p>
<p>而观察这个级数:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \prod_{ n = 1 }^\infty \frac{ e^{ \frac{ 1 }{ n } } }{ 1 + \frac{
1 }{ n } } \\
= &amp; \frac{ e^{ 1 + \frac{ 1 }{ 2 } + \cdots + \frac{ 1 }{ n } } }{ n
+ 1 } \\
= &amp; \frac{ e^{ \ln n + \gamma + c_n } }{ n + 1 } \to e^\gamma
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(\gamma\)</span>是欧拉常数,误差项<span class="math inline">\(c_n = H_n - \ln n - \gamma \to 0\)</span>.</p>
<p>从而观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; e^{ \gamma x } \Gamma ( x + 1 ) \\
= &amp; \prod_{ n = 1 }^\infty \frac{ e^{ \frac{ x }{ n } } }{ 1 +
\frac{ x }{ n } }
\end{aligned}
\]</span></p>
<p>从而<span class="math inline">\(\frac{ 1 }{ \Gamma ( x + 1 ) } = e^{
\gamma x } \prod_{ n = 1 }^\infty ( 1 + \frac{ x }{ n } ) e^{ - \frac{ x
}{ n } }\)</span>.</p>
<p>在此基础上,如若设<span class="math inline">\(b_n = \frac{ n ! n^x }{
x^{ \overline{ n + 1 } } }\)</span>.容易见到<span class="math inline">\(\lim b_n = \lim A_n = \Gamma ( x
)\)</span>,而观察到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ b_{ n + 1 } }{ b_n } &amp; = \frac{ ( 1 + \frac{ 1 }{ n } )^{ x +
1 } }{ 1 + \frac{ x + 1 }{ n } } \\
&amp; = 1 + \frac{ x ( x + 1 ) }{ 2 n^2 } + o ( \frac{ 1 }{ n^2 } ) \\
&amp; \to 1
\end{aligned}
\]</span></p>
<p>而且如若<span class="math inline">\(x ( x + 1 ) &gt;
0\)</span>,并且取<span class="math inline">\(n\)</span>足够大,则上式大于<span class="math inline">\(1\)</span>,反之上式小于<span class="math inline">\(1\)</span>.因此当<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(b_n\)</span>单调有界(原因是其极限存在).</p>
<p>因此还可以得到结论:<span class="math inline">\(\sum \frac{ n ! a_n }{
x^{ \overline{ n + 1 } } }\)</span>和<span class="math inline">\(\sum
\frac{ a_n }{ n^x }\)</span>敛散性相同,其中<span class="math inline">\(x
\ne 0 , - 1 , - 2 , \cdots\)</span>.原因只是因为这俩的比值恰好是<span class="math inline">\(b_n\)</span>单调有界,根据DA判别法知道二者同敛散.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 1 }^\infty \frac{ ( nx )^n
}{ n ! }\)</span>的收敛性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\frac{ a_{ n + 1 } }{ a_n } = ( \frac{ n + 1 }{ n } )^n x \to ex
\]</span></p>
<p>根据比值判法,当<span class="math inline">\(| x | &lt; \frac{ 1 }{ e
}\)</span>的时候绝对收敛,而当<span class="math inline">\(| x | &gt;
\frac{ 1 }{ e }\)</span>的时候发散,问题只在于<span class="math inline">\(| x | = \frac{ 1 }{ e }\)</span>的时候如何.</p>
<p>当<span class="math inline">\(x = \frac{ 1 }{ e
}\)</span>的时候,使用拉贝判法:</p>
<p><span class="math display">\[
\begin{aligned}
n ( \frac{ a_n }{ a_{ n + 1 } } - 1 ) &amp; = n ( ( 1 - \frac{ 1 }{ n +
1 } )^n e - 1 ) \\
&amp; = n ( e^{ n \ln ( 1 - \frac{ 1 }{ n + 1 } ) + 1 } - 1 ) \\
&amp; = n ( e^{ n ( - \frac{ 1 }{ n + 1 } - \frac{ 1 }{ 2 ( n + 1 )^2 }
+ o ( \frac{ 1 }{ n^2 } ) ) + 1 } - 1 ) \\
&amp; = n ( e^{ \frac{ 1 }{ n + 1 } - \frac{ n }{ 2 ( n + 1 )^2 } + o (
\frac{ 1 }{ n } ) } - 1 ) \\
&amp; = n ( \frac{ 1 }{ n + 1 } - \frac{ n }{ 2 ( n + 1 )^2 } + o (
\frac{ 1 }{ n } ) ) \\
&amp; \to \frac{ 1 }{ 2 } &lt; 1
\end{aligned}
\]</span></p>
<p>所以发散.</p>
<p>当<span class="math inline">\(x = - \frac{ 1 }{ e
}\)</span>的时候,使用DA判法:应当见到<span class="math inline">\(a_n = (
- 1 )^n | a_n |\)</span>,此时<span class="math inline">\(| a_n
|\)</span>单调递减且趋于<span class="math inline">\(0\)</span>,用DA判法知道其收敛.</p>
<p>所以条件收敛.</p>
<h6><span id="example5">Example5</span></h6>
<p>求证<span class="math inline">\(\sum a_n ( x^2 - 1 ) ( x^2 - 2^2 )
\cdots ( x^2 - n^2 )\)</span>对<span class="math inline">\(\forall x
\notin \mathbb{ Z }\)</span>,其都有相同的敛散性.就是对于一个确定的<span class="math inline">\(\{ a_n \}\)</span>,对所有的<span class="math inline">\(x\)</span>,要么都收敛,要么都发散.</p>
<p>考虑设<span class="math inline">\(f_n ( x ) = ( x^2 - 1 ) ( x^2 - 2^2
) \cdots ( x^2 - n^2 )\)</span>,观察到:</p>
<p><span class="math display">\[
\frac{ f_n ( x ) }{ f_n ( x_0 ) } = \frac{ ( x^2 - 1 ) ( x^2 - 2^2 )
\cdots ( x^2 - n^2 ) }{ ( x_0^2 - 1 ) ( x_0^2 - 2^2 ) \cdots ( x_0^2 -
n^2 ) }
\]</span></p>
<p>这当然是个无穷乘积,观察到<span class="math inline">\(\frac{ x^2 - n^2
}{ x_0^2 - n^2 } = 1 + \frac{ x^2 - x_0^2 }{ x_0^2 - n^2 } = 1 + O (
\frac{ 1 }{ n^2 } )\)</span>,所以<span class="math inline">\(\lim_{ n
\to \infty } \frac{ f_n ( x ) }{ f_n ( x_0 ) }\)</span>存在且非零.</p>
<p>而且,当<span class="math inline">\(n\)</span>足够大的时候,或者更进一步说<span class="math inline">\(| n | &gt; \max ( | x | , | x_0 |
)\)</span>的时候<span class="math inline">\(\frac{ f_n ( x ) }{ f_n (
x_0 ) }\)</span>当然就定号了,而且<span class="math inline">\(\frac{ x^2
- n^2 }{ x_0^2 - n^2 } = 1 + \frac{ x^2 - x_0^2 }{ x_0^2 - n^2
}\)</span>,其与<span class="math inline">\(1\)</span>比较只取决于<span class="math inline">\(x^2 - x_0^2\)</span>,这就意味着<span class="math inline">\(\frac{ f_n ( x ) }{ f_n ( x_0 ) }\)</span>在<span class="math inline">\(n\)</span>足够大的时候是单调有界非零的,于是DA判法知道同敛散.</p>
<h6><span id="example6">Example6</span></h6>
<p>求证<span class="math inline">\(\sin x = x \prod_{ k = 1 }^{ \infty }
( 1 - \frac{ x^2 }{ k^2 \pi^2 } )\)</span>.</p>
<p>先看<span class="math inline">\(\sin x =
0\)</span>的根,假设其根为<span class="math inline">\(u +
iv\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sin x &amp; = \frac{ e^{ ix } - e^{ - ix } }{ 2 i } = 0 \\
e^{ 2 ix } &amp; = 1 \\
e^{ 2 iu - 2 v } &amp; = 1 \\
| e^{ 2 iu - 2 v } | &amp; = 1 \\
e^{ - 2 v } &amp; = 1 \\
v &amp; = 0
\end{aligned}
\]</span></p>
<p>所以其只有实根,用多项式理论知道如若<span class="math inline">\(\sin
x\)</span>的根只有<span class="math inline">\(2 k
\pi\)</span>,应该有:</p>
<p><span class="math display">\[
\sin x = cx \prod_{ k = 1 }^{ \infty } ( 1 - \frac{ x^2 }{ k^2 \pi^2 } )
\]</span></p>
<p>容易见到这个无穷乘积的确收敛,而<span class="math inline">\(x \to
0\)</span>的时候<span class="math inline">\(\frac{ \sin x }{ x } =
1\)</span>,所以<span class="math inline">\(c = 1\)</span>.</p>
<p>那么考虑<span class="math inline">\(\sin x\)</span>的泰勒展开,有:</p>
<p><span class="math display">\[
\begin{aligned}
1 - \frac{ x^2 }{ 6 } + \cdots &amp; = \prod_{ k = 1 } ( 1 - \frac{ x^2
}{ k^2 \pi^2 } ) \\
&amp; = 1 - ( \frac{ 1 }{ \pi^2 } \sum_k \frac{ 1 }{ k^2 } ) x^2 +
\cdots
\end{aligned}
\]</span></p>
<p>这就能知道<span class="math inline">\(\sum_{ k = 1 }^\infty \frac{ 1
}{ k^2 } = \frac{ \pi^2 }{ 6 }\)</span>.</p>
<p>然而上述的多项式理论还是太过粗糙,下面提供一种更加严谨的证明:</p>
<p>我们有欧拉公式:</p>
$$
<span class="math display">\[\begin{aligned}
( \cos x + i \sin x )^{ 2 n + 1 } &amp; = \cos ( 2 n + 1 ) x + i \sin (
2 n + 1 ) x \\

\end{aligned}\]</span>
<p>$$</p>
<p>然而左侧可以使用二项式定理展开,有:</p>
<p><span class="math display">\[
( \cos x + i \sin x )^{ 2 n + 1 } = \sum \binom{ 2 n + 1 }{ k } \cos^k x
( i \sin x )^{ 2 n + 1 - k }
\]</span></p>
<p>容易见到为了贡献虚部,<span class="math inline">\(k\)</span>必须是偶数,那此时<span class="math inline">\(\cos^k x = ( 1 - \sin^2 x )^{ \frac{ k }{ 2 }
}\)</span>,总之,我们发现应该存在一个<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(P_n\)</span>,使得:</p>
$$
<span class="math display">\[\begin{aligned}
\sin ( 2 n + 1 ) x &amp; = ( \sin x ) P_n ( \sin^2 x ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个多项式的根应该怎么取呢?考虑当<span class="math inline">\(\varphi_k = \frac{ k \pi }{ 2 n + 1 } , 1 \leq k
\leq n\)</span>的时候,左侧为<span class="math inline">\(0\)</span>,而右侧<span class="math inline">\(\sin
\varphi_k\)</span>不该为<span class="math inline">\(0\)</span>,更进一步地,<span class="math inline">\(\sin^2
\varphi_k\)</span>两两不同,这就知道它们确实是<span class="math inline">\(P_n\)</span>的<span class="math inline">\(n\)</span>个根.同时见到<span class="math inline">\(P ( 0 ) = \lim_{ x \to 0 } P_n ( \sin^2 x ) = 2 n
+ 1\)</span>,从而我们已经能唯一确定这个有限项多项式<span class="math inline">\(P_n ( x ) = ( 2 n + 1 ) \prod_{ k = 1 }^n ( 1 -
\frac{ x }{ \sin^2 \varphi_k } )\)</span>.</p>
<p>接下来,将原本上式中的<span class="math inline">\(x\)</span>换成<span class="math inline">\(\frac{ x }{ 2 n + 1 }\)</span>,我们就能得到:</p>
<p><span class="math display">\[
\sin x = ( 2 n + 1 ) \sin ( \frac{ x }{ 2 n + 1 } ) \prod_{ k = 1 }^n (
1 - \frac{ \sin^2 \frac{ x }{ 2 n + 1 } }{ \sin^2 \varphi_k } )
\]</span></p>
<p>这里已经十分接近我们想要的答案了,但是这个项数和<span class="math inline">\(n\)</span>一起增大,策略当然是大小步极限,考虑取:</p>
$$
<span class="math display">\[\begin{aligned}
U_m &amp; = ( 2 n + 1 ) \sin \frac{ x }{ 2 n + 1 } \prod_{ k = 1 }^m ( 1
- \frac{ \sin^2 \frac{ x }{ 2 n + 1 } }{ \sin^2 \varphi_k } ) \\
V_m &amp; = \prod_{ k = m + 1 }^n ( 1 - \frac{ \sin^2 \frac{ x }{ 2 n +
1 } }{ \sin^2 \varphi_k } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>取定<span class="math inline">\(m\)</span>,当然总能取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(U_m \to
x \prod_{ k = 1 }^m ( 1 - \frac{ x^2 }{ k^2 \pi^2 } )\)</span>.</p>
<p>而用柯西准则,当<span class="math inline">\(m\)</span>足够大的时候,如果能证明<span class="math inline">\(V_m \to 1\)</span>就完事了.我们考虑:</p>
$$
<span class="math display">\[\begin{aligned}
1 &amp; \geq V_m \geq \prod_{ k = m + 1 }^\infty ( 1 - \frac{ \sin^2
\frac{ x }{ 2 n + 1 } }{ \sin^2 \varphi_k } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而回忆到当<span class="math inline">\(\sin^2 x \leq
x^2\)</span>恒成立,在<span class="math inline">\(x \in [ 0 , \frac{ \pi
}{ 2 } ]\)</span>的时候,<span class="math inline">\(\sin x \geq \frac{ 2
}{ \pi } x\)</span>也成立,所以:</p>
$$
<span class="math display">\[\begin{aligned}
V_m &amp; \geq \prod_{ k = m + 1 }^\infty ( 1 - \frac{ \sin^2 \frac{ x
}{ 2 n + 1 } }{ \sin^2 \varphi_k } ) \\
&amp; \geq \prod_{ k = m + 1 }^\infty ( 1 - \frac{ x^2 }{ 4 k^2 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时回忆到<span class="math inline">\(\prod_{ k = 1 }^\infty ( 1 -
\frac{ x^2 }{ 4 k^2 } )\)</span>是收敛的,所以由柯西准则,当<span class="math inline">\(m\)</span>足够大的时候,<span class="math inline">\(\prod_{ k = m + 1 }^\infty ( 1 - \frac{ x^2 }{ 4
k^2 } )\)</span>趋近于<span class="math inline">\(1\)</span>,这就证毕了.</p>
<h3><span id="函数项数列">函数项数列</span></h3>
<p>也就是每一项都是一个函数的数列,假设定义域在<span class="math inline">\(I \subseteq \mathbb{ R }\)</span>上,写作<span class="math inline">\(\{ f_n ( x ) \}\)</span>.此时对于一个固定的<span class="math inline">\(x_0 \in I\)</span>,则<span class="math inline">\(\{ f_n ( x_0 )
\}\)</span>就是一个普通的数列.当然不一定<span class="math inline">\(I\)</span>中的每一个<span class="math inline">\(x_0\)</span>都收敛,我们将<strong>收敛点</strong>的集合称为函数项级数的<strong>收敛域</strong>,其它的点称为<strong>发散点</strong>,发散点组成的集合称为<strong>发散域</strong>.</p>
<p>对于收敛域,直接记<span class="math inline">\(f ( x ) = \lim_{ n \to
\infty } f_n ( x )\)</span>,我们将这里的<span class="math inline">\(f (
x
)\)</span>就是这个函数列的<strong>极限函数</strong>.既然有了极限就可以定义级数,也就是可以定义<span class="math inline">\(S_n = \sum_{ k = 1 }^n f_k ( x
)\)</span>,然后取其极限拿到<span class="math inline">\(\sum_{ k = 1
}^\infty f_n ( x ) = S ( x )\)</span>.</p>
<p>我们要解决的问题大概有以下三个:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(f_n\)</span>均是连续的,那么要求什么条件,可以满足<span class="math inline">\(f\)</span>连续.也就是两层极限什么时候可以交换顺序.</p></li>
<li><p>如果<span class="math inline">\(f_n\)</span>均是黎曼可积的,那么要求什么条件,可以满足<span class="math inline">\(f\)</span>黎曼可积并且<span class="math inline">\(\lim \int f_n = \int
f\)</span>,也就是极限和积分什么时候可以交换顺序.</p></li>
<li><p>如果<span class="math inline">\(f_n\)</span>均可导,那么什么时候<span class="math inline">\(f\)</span>也可导,并且<span class="math inline">\(\lim f_n &#39; = f
&#39;\)</span>,也就是极限和导数什么时候可以交换顺序.</p></li>
</ol>
<p>如果不加条件,上述三条全都是不满足的,下述Example会给出若干例子.</p>
<h6><span id="example1">Example1</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = x^n , x \in [ 0 , 1
]\)</span>,求其极限函数.</p>
<p>显然<span class="math inline">\(f ( x ) = \begin{cases}1 &amp; x = 1
\\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,由此可以见到,连续函数的极限函数不一定连续.</p>
<h6><span id="example2">Example2</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = \begin{cases}1 &amp; ( n !
) x \in \mathbb{ Z } \\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,求其极限函数.</p>
<p>显然是迪利克雷函数.</p>
<p>则<span class="math inline">\(f_n ( x
)\)</span>只有有限个间断点,容易见到其黎曼可积,然而迪利克雷函数并不黎曼可积.可积函数的极限函数不一定可积.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = nx ( 1 - x^2 )^n , x \in [
0 , 1 ]\)</span>,求其极限函数.</p>
<p>容易见到<span class="math inline">\(\lim f_n ( x ) =
0\)</span>,也就是这个函数处处收敛到<span class="math inline">\(0\)</span>.</p>
<p>然而,对其求积分:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^1 f_n ( x ) \mathrm{ d } x &amp; = \int_0^1 nx ( 1 - x^2 )^n
\mathrm{ d } x \\
&amp; = - \frac{ n }{ 2 } \int_0^1 ( 1 - x^2 )^n \mathrm{ d } ( 1 - x^2
) \\
&amp; = - \frac{ n }{ 2 ( n + 1 ) } ( 1 - x^2 )^{ n + 1 } |_0^1 \\
&amp; = \frac{ n }{ 2 ( n + 1 ) } \to \frac{ 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>由此见到,极限函数的积分不一定等于积分的极限.极限和积分不一定可交换.</p>
<h6><span id="example4">Example4</span></h6>
<p>考虑<span class="math inline">\(f_n ( x ) = \begin{cases}2 n^2 x \\ x
\in [ 0 , \frac{ 1 }{ 2 n } ] \\ 2 n^2 ( x - \frac{ 1 }{ n } ) &amp; x
\in ( \frac{ 1 }{ 2 n } , \frac{ 1 }{ n } ] \\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,也就是这个函数在<span class="math inline">\(\frac{
1 }{ 2 n }\)</span>处高度为<span class="math inline">\(n\)</span>,底长为<span class="math inline">\(\frac{ 1 }{ n
}\)</span>的一个小三角形.求其极限函数.</p>
<p>对于每一个点,这个函数当然逐点收敛于<span class="math inline">\(0\)</span>.然而也可以见到,这个函数的积分对于每一个<span class="math inline">\(n\)</span>来说都是<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>再次说明了极限函数的积分不一定等于积分的极限.极限和积分不一定可交换.</p>
<h6><span id="example5">Example5</span></h6>
<p>考虑<span class="math inline">\(f_n ( x ) = \frac{ \sin ( nx ) }{
\sqrt{ n } }\)</span>,求其极限函数.</p>
<p>当然逐点收敛于<span class="math inline">\(0\)</span>,然而观察到<span class="math inline">\(f_n &#39; ( x ) = \sqrt{ n } \cos
nx\)</span>,<span class="math inline">\(f &#39; ( x ) =
0\)</span>.因此,光滑函数列的导数的极限又不一定等于极限的导数.</p>
<h4><span id="一致收敛">一致收敛</span></h4>
<p>我们称一列函数<span class="math inline">\(\{ f_n ( x )
\}\)</span>是<strong>一致收敛</strong>到<span class="math inline">\(f (
x )\)</span>,当且仅当<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N = N ( \epsilon
)\)</span>,使得当<span class="math inline">\(n \geq
N\)</span>的时候,<span class="math inline">\(| f ( x ) - f_n ( x ) |
&lt; \epsilon , \forall x \in I\)</span>.注意这里的<span class="math inline">\(N\)</span>不取决于<span class="math inline">\(x\)</span>的选取,这就是和极限不同的地方,一致收敛要求整个函数都在逐步地贴向最终的函数.此时,记<span class="math inline">\(f_n ( x ) \rightrightarrows f ( x
)\)</span>.还可以定义<strong>内闭一致收敛</strong>的概念,也就是对于一个<span class="math inline">\(I\)</span>的任意的子紧集(在<span class="math inline">\(\mathbb{ R
}\)</span>上表现为有界闭集)都一致收敛.</p>
<p>一致收敛的等价定义当然是,取<span class="math inline">\(M_n = \sup_{ x
\in I } | f_n ( x ) - f ( x ) |\)</span>,那么一致收敛等价于<span class="math inline">\(\lim M_n = 0\)</span>.</p>
<p>一致收敛强大的地方在于,对于收敛来说,是取定了<span class="math inline">\(x\)</span>再挪动<span class="math inline">\(n\)</span>,因此<span class="math inline">\(n\)</span>可以控制<span class="math inline">\(x\)</span>.然而,一致收敛要求先取定<span class="math inline">\(n\)</span>再挪动<span class="math inline">\(x\)</span>.这种天然的交换能力赋予了一致收敛的强大.另外还容易见到,当<span class="math inline">\(I\)</span>的点集是有限的时候,一定一致收敛.</p>
<p>我们还可以定义<strong>一致有界</strong>的概念,当存在一个上界<span class="math inline">\(M\)</span>,使得<span class="math inline">\(\forall
n , | f_n | \leq
M\)</span>恒成立.显然,如果一个函数列一致有界,则极限函数肯定有界.</p>
<p>另外,我们可以见到,如果<span class="math inline">\(f_n
\rightrightarrows f\)</span>,那么如果<span class="math inline">\(f\)</span>有界,则<span class="math inline">\(f_n\)</span>一致有界.反之,如果<span class="math inline">\(f_n\)</span>有界,则<span class="math inline">\(f_n\)</span>一致有界.</p>
<p>考虑前者,是因为:</p>
<p><span class="math display">\[
| f_n | \leq | f_n - f | + | f |
\]</span></p>
<p>这俩当然是有界的.</p>
<p>对于后者,考虑反证,假设<span class="math inline">\(f\)</span>无界(因为如果有界则前者即可推出),那么:</p>
<p><span class="math display">\[
| f | \leq | f - f_n | + | f_n |
\]</span></p>
<p>由于<span class="math inline">\(| f - f_n
|\)</span>必然需要有界,因此前者无界,后者无论对于哪个<span class="math inline">\(n\)</span>来说,必然也得无界.</p>
<p>我们有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(f_n \rightrightarrows f , g_n
\rightrightarrows g , x \in I\)</span>,则<span class="math inline">\(c_1
f_n + c_2 g_n \rightrightarrows c_1 f + c_2 g , x \in
I\)</span>.</p></li>
<li><p><span class="math inline">\(f_n \rightrightarrows f , g_n
\rightrightarrows g , x \in I\)</span>,而且<span class="math inline">\(f
, g\)</span>有界,则<span class="math inline">\(f_n g_n \rightrightarrows
fg , x \in I\)</span>.</p></li>
<li><p>如果<span class="math inline">\(x \in I\)</span>的时候<span class="math inline">\(f_n \rightrightarrows f\)</span>,<span class="math inline">\(x \in J\)</span>的时候也<span class="math inline">\(f_n \rightrightarrows f\)</span>,则当<span class="math inline">\(x \in I \cup J\)</span>的时候也有<span class="math inline">\(f_n \rightrightarrows f\)</span>.</p></li>
</ol>
<p>对于(1),考虑令<span class="math inline">\(M_{ n } = \sup | f_n - f |
, K_n = \sup | g_n - g |\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | ( c_1 f_n + c_2 g_n ) - ( c_1 f + c_2 g ) | \\
\leq &amp; | c_1 | M_n + | c_2 | K_n \to 0
\end{aligned}
\]</span></p>
<p>立刻证毕.</p>
<p>对于(2),经典的做法:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n g_n - fg | \\
= &amp; | f_n ( g_n - g ) + g ( f_n - f ) | \\
\leq &amp; | f_n | \cdot | g_n - g | + | g | \cdot | f_n - f |
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(| f_n |\)</span>一致有界,<span class="math inline">\(| g_n |\)</span>一致有界得到<span class="math inline">\(| g |\)</span>有界,所以上式就被控制住了.</p>
<p>对于(3),只需要把两部分的<span class="math inline">\(\sup\)</span>分开算就可以见到仍能被控制住.</p>
<p>这里也有<strong>柯西准则</strong>:对于一列函数<span class="math inline">\(\{ f_n \}\)</span>,其一致收敛的充要条件是,<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall n ,
m \geq N , | f_n ( x ) - f_m ( x ) | &lt; \epsilon\)</span>.</p>
<p>必要性显然,只证充分性,对于此时固定一个确定的<span class="math inline">\(x\)</span>,那么<span class="math inline">\(\{ f_n
( x ) \}\)</span>就是一个柯西列且存在极限.逐点取极限就可以拿到<span class="math inline">\(f ( x ) = \lim_{ n \to \infty } f_n ( x
)\)</span>.而<span class="math inline">\(| f_n ( x ) - f_m ( x ) | &lt;
\epsilon\)</span>中只需要让<span class="math inline">\(m \to
\infty\)</span>就拿到了<span class="math inline">\(| f_n ( x ) - f ( x )
| \leq \epsilon\)</span>,这恰好是一致收敛的定义.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:<span class="math inline">\(f_n ( x ) = \frac{ x }{ 1 + n^2 x^2
}\)</span>一致收敛.</p>
<p>当然处处收敛于<span class="math inline">\(0\)</span>了,考虑用均值不等式,有<span class="math inline">\(| f_n ( x ) | \leq \frac{ | x | }{ 2 n | x | } =
\frac{ 1 }{ 2 n }\)</span>,这就搞定.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:<span class="math inline">\(f_n ( x ) = x^n , x \in [ 0 , 1
)\)</span>并不一致收敛.</p>
<p>当然处处收敛到<span class="math inline">\(0\)</span>,但是<span class="math inline">\(\sup f_n ( x ) = 1\)</span>,所以并不一致收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = \frac{ 1 }{ n } , g_n ( x )
= x , x \in ( 0 , + \infty )\)</span>,容易见到<span class="math inline">\(f_n \rightrightarrows 0 , g_n \rightrightarrows
x\)</span>.而且<span class="math inline">\(f_n ( x
)\)</span>当然一致有界.然而,<span class="math inline">\(f_n g_n \not
\rightrightarrows 0\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p>当<span class="math inline">\(g \in C [ 0 , 1 ] , g ( 1 ) =
0\)</span>,求证:<span class="math inline">\(f_n ( x ) = g ( x ) x^n
\rightrightarrows 0\)</span>.</p>
<p>由于<span class="math inline">\(g\)</span>在闭区间上连续,则其必然在闭区间上一致连续.因此<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,取<span class="math inline">\(\delta \in ( 0 , 1 )\)</span>,使得<span class="math inline">\(x \in [ \delta , 1 ]\)</span>的时候,<span class="math inline">\(| g ( x ) | &lt; \epsilon\)</span>,而取<span class="math inline">\(M = \sup_{ [ 0 , 1 ] } | g |\)</span>,那么<span class="math inline">\(| f_n ( x ) | \leq M \delta^n +
\epsilon\)</span>,注意这里的<span class="math inline">\(\delta\)</span>不取决于<span class="math inline">\(n\)</span>的选取这就搞定.</p>
<h6><span id="example5">Example5</span></h6>
<p>设<span class="math inline">\(f_n ( x ) = n \left ( \sqrt{ x + \frac{
1 }{ n } } - \sqrt{ x } \right ) , x \in ( 0 , + \infty
)\)</span>,判断其收敛性.</p>
<p>容易发现<span class="math inline">\(f_n ( x ) = \frac{ 1 }{ \sqrt{ x
+ \frac{ 1 }{ n } } + \sqrt{ x } } \to \frac{ 1 }{ 2 \sqrt{ x }
}\)</span>,因此其收敛.问题在于判断其是否一致收敛.</p>
<p>观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - \frac{ 1 }{ 2 \sqrt{ x } } | \\
= &amp; \frac{ \sqrt{ x + \frac{ 1 }{ n } } - \sqrt{ x } }{ 2 \sqrt{ x }
\left ( \sqrt{ x + \frac{ 1 }{ n } } + \sqrt{ x } \right ) } \\
= &amp; \frac{ 1 }{ 2 n \sqrt{ x } \left ( \sqrt{ x + \frac{ 1 }{ n } }
+ \sqrt{ x } \right )^2 }
\end{aligned}
\]</span></p>
<p>一个策略是直接对此式子求导,但也可以采取另一种分析策略,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt{ x + \frac{ 1 }{ n } } &amp; = \sqrt{ x } \left ( 1 + \frac{ 1 }{
nx } \right )^{ \frac{ 1 }{ 2 } } \\
&amp; = \sqrt{ x } \left ( 1 + \frac{ 1 }{ 2 nx } + O ( \frac{ 1 }{ n^2
} ) \right )
\end{aligned}
\]</span></p>
<p>所以当<span class="math inline">\(x\)</span>足够小的时候可能会出问题,直接取<span class="math inline">\(x = \frac{ 1 }{ n }\)</span>,误差为:</p>
<p><span class="math display">\[
\frac{ 1 }{ 2 \sqrt{ n } \left ( \frac{ 1 + \sqrt{ 2 } }{ \sqrt{ n } }
\right )^2 } = O ( \sqrt{ n } )
\]</span></p>
<p>这就证明了并非一致收敛.</p>
<h6><span id="example6">Example6</span></h6>
<p><span class="math inline">\([ 0 , 1 ]\)</span>上的<span class="math inline">\(f_n ( x )\)</span>满足<span class="math inline">\(\exists L &gt; 0 , \forall x \ne y , | f_n ( x ) -
f_n ( y ) | \leq L | x - y |\)</span>.并且<span class="math inline">\(\forall x \in [ 0 , 1 ] , f_n ( x ) \to f ( x
)\)</span>.求证:<span class="math inline">\(f_n ( x ) \rightrightarrows
f ( x )\)</span>.也就是:一致李氏连续的收敛函数列一定一致收敛.</p>
<p>李氏连续意味着我们可以用控制自变量的方式控制因变量.回忆到定义在有限集上的收敛函数列一定是一致收敛的.因此我们选择在数轴上打足够密的点来控制.</p>
<p>具体地,<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,我们将<span class="math inline">\([ 0 , 1
]\)</span>拆为长度不超过<span class="math inline">\(\frac{ \epsilon }{ 3
L }\)</span>的小区间.假设分点是<span class="math inline">\(x_1 , \cdots
, x_K\)</span>.这当然对于一个<span class="math inline">\(\epsilon\)</span>来说是有限个点,我们可以让它们同时趋近于一致收敛,用柯西准则,也就是拿到一个<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n , m \geq N\)</span>,<span class="math inline">\(| f_n ( x_i ) - f_m (
x_i ) | &lt; \frac{ \epsilon }{ 3 }\)</span>.</p>
<p>现在<span class="math inline">\(\forall x \in [ 0 , 1 ] , \exists x_i
, | x - x_i | &lt; \frac{ \epsilon }{ 3 L }\)</span>.于是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - f_m ( x ) | \\
\leq &amp; | f_n ( x ) - f_n ( x_i ) | + | f_n ( x_i ) - f_m ( x_i ) | +
| f_m ( x_i ) - f_m ( x ) | \\
&lt; &amp; \epsilon
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h4><span id="函数项级数">函数项级数</span></h4>
<p>函数项级数上也有柯西准则,也就是函数项级数的一致收敛性等价于<span class="math inline">\(\forall \epsilon , \exists N , \forall n , m \geq
N , | \sum_{ k = n }^m f_k ( x ) | &lt; \epsilon , \forall x \in
I\)</span>.</p>
<p>还可以在这里定义<strong>绝对收敛</strong>:也就是<span class="math inline">\(\sum | f_n ( x )
|\)</span>收敛.当然仍有绝对收敛推收敛.如果<span class="math inline">\(\sum | f_n ( x )
|\)</span>还一致收敛,则称原级数<strong>绝对一致收敛</strong>.注意,这里的绝对一致收敛是定义在<span class="math inline">\(| f_n
|\)</span>的基础上.也就是说,一个函数既绝对收敛,又一致收敛,但它可能并不绝对一致收敛.然而反之是成立的,如果一个函数绝对一致收敛,可以推出它一致收敛,原因是<span class="math inline">\(\sum | f_n | \geq | \sum f_n
|\)</span>,用柯西准则就可以得知.</p>
<p>另外,用柯西准则可以见到如果<span class="math inline">\(\sum f_n
\rightrightarrows f\)</span>,那么<span class="math inline">\(f_n ( x )
\rightrightarrows 0\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑函数项级数<span class="math inline">\(\sum ( - x )^n ( 1 - x ) ,
x \in [ 0 , 1 ]\)</span>.</p>
<p>直接考虑其余项,<span class="math inline">\(R_n ( x ) = \sum_{ k = n +
1 }^\infty ( - x )^k ( 1 - x ) = \frac{ ( - x )^{ n + 1 } ( 1 - x ) }{ 1
+ x }\)</span>.此时考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| R_n | &amp; \leq x^{ n + 1 } ( 1 - x ) \\
&amp; = \frac{ 1 }{ n + 1 } ( n + 1 ) ( 1 - x ) x^{ n + 1 } \\
&amp; \leq \frac{ 1 }{ n + 1 } ( \frac{ n + 1 }{ n + 2 } )^{ n + 2 } \\
&amp; \leq \frac{ 1 }{ n + 1 } \to 0
\end{aligned}
\]</span></p>
<p>所以该级数一致收敛.</p>
<p>那么是否绝对收敛呢?考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = 1 }^n | ( - x )^n ( 1 - x ) | \\
= &amp; \sum_{ k = 1 }^n ( x^k - x^{ k + 1 } ) \\
= &amp; x - x^{ n + 1 }
\end{aligned}
\]</span></p>
<p>所以当然也绝对收敛到<span class="math inline">\(\begin{cases}x &amp;
x \in [ 0 , 1 ) \\ 0 &amp; x = 1\end{cases}\)</span>.</p>
<p>可是,它并不是绝对一致收敛的.考虑<span class="math inline">\(\sup_{ [
0 , 1 ) } | S ( x ) - S_n ( x ) | = \sup_{ [ 0 , 1 ) } | x^{ n + 1 } | =
1\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum \left ( \cos \frac{ \pi x }{ n }
\right )^{ n^3 }\)</span>的收敛域.</p>
<p>不妨设<span class="math inline">\(u_n ( x ) = \left ( \cos \frac{ \pi
x }{ n } \right )^{ n^3 }\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt[n]{ u_n ( x ) } &amp; = \left ( \cos \frac{ \pi x }{ n } \right
)^{ n^2 } \\
&amp; = \left ( 1 - \frac{ \pi^2 x^2 }{ 2 n^2 } + O ( \frac{ 1 }{ n^4 }
) \right )^{ n^2 } \\
&amp; = \exp ( n^2 \ln \left ( 1 - \frac{ \pi^2 x^2 }{ 2 n^2 } + O (
\frac{ 1 }{ n^4 } ) \right ) ) \\
&amp; = \exp ( n^2 \left ( - \frac{ \pi^2 x^2 }{ 2 n^2 } + O ( \frac{ 1
}{ n^4 } ) \right ) ) \\
&amp; = \exp ( - \frac{ \pi^2 x^2 }{ 2 } + O ( \frac{ 1 }{ n^2 } ) ) \\
&amp; \to e^{ - \frac{ \pi^2 x^2 }{ 2 } }
\end{aligned}
\]</span></p>
<p>所以最后模拟成了一个等比数列,那收敛域就是<span class="math inline">\(\mathbb{ R } \setminus \{ 0 \}\)</span>.</p>
<h5><span id="m判别法">M判别法</span></h5>
<p>若<span class="math inline">\(| f_n ( x ) | \leq a_n , x \in
I\)</span>,如果<span class="math inline">\(\sum a_n &lt;
\infty\)</span>,则<span class="math inline">\(\sum f_n ( x
)\)</span>绝对一致收敛.</p>
<p>证明的话,考虑用一般级数可以拿到<span class="math inline">\(\forall
\epsilon &gt; 0 , \exists N , \forall n , m \geq N , \sum_{ k = n }^m |
a_n | &lt; \epsilon\)</span>,但又有<span class="math inline">\(\forall x
\in I , \sum_{ k = n }^m | f_n ( x ) | \leq \sum_{ k = n }^m
a_k\)</span>,这就知道其绝对一致收敛.</p>
<h5><span id="da判别法">DA判别法</span></h5>
<p>假设<span class="math inline">\(\{ a_n ( x ) \} , \{ b_n ( x )
\}\)</span>是两个函数列.对于任意固定的<span class="math inline">\(x \in
I\)</span>,<span class="math inline">\(\{ a_n ( x )
\}\)</span>是一个单调数列.注意这里其实不要求大家都递增或递减,只要对于每一个点都是单调的.而取<span class="math inline">\(B_n ( x ) = \sum_{ k = 1 }^n b_k ( x
)\)</span>.则当:</p>
<ol type="1">
<li><p>Dirichlet判别法:当<span class="math inline">\(a_n ( x )
\rightrightarrows 0\)</span>,<span class="math inline">\(B_n ( x
)\)</span>一致有界时,则<span class="math inline">\(\sum a_n
b_n\)</span>一致收敛.</p></li>
<li><p>Able判别法:当<span class="math inline">\(\{ a_n ( x )
\}\)</span>一致有界,<span class="math inline">\(B_n ( x
)\)</span>一致收敛时,则<span class="math inline">\(\sum a_n
b_n\)</span>一致收敛.</p></li>
</ol>
<p>证明和级数部分完全一样,只需要对于任意的<span class="math inline">\(x\)</span>都这么搞即可:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = n + 1 }^{ n + p } a_k ( x ) b_k ( x ) | \\
= &amp; | \sum_{ k = n + 1 }^{ n + p } a_k ( x ) ( B_{ k } ( x ) - B_{ k
- 1 } ( x ) ) | \\
= &amp; | a_{ n + p } B_{ n + p } ( x ) + \sum_{ k = n + 1 }^{ n + p - 1
} ( a_k ( x ) - a_{ k + 1 } ( x ) ) B_k ( x ) | \\
\leq &amp; M ( a_{ n + 1 } ( x ) + 2 a_{ n + p } ( x ) )
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(M = \sup_{ 1 \leq i \leq p } \{ |
\sum_{ k = n + 1 }^{ n + i } b_k ( x ) | \}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(b_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>的时候,求证:<span class="math inline">\(\sum_{ k = 1 }^\infty b_n \sin ( nx ) , x \in
\mathbb{ R }\)</span>一致收敛的充要条件是<span class="math inline">\(b_n
= o ( \frac{ 1 }{ n } )\)</span>.</p>
<p>先证必要性,设<span class="math inline">\(S_{ n , p } = \sum_{ k = n
}^p b_k \sin ( kx )\)</span>.由柯西原理,<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall n ,
p \geq N , | S_{ n , p } | &lt; \epsilon\)</span>.此时取<span class="math inline">\(p = 2 n - 1 , x = \frac{ \pi }{ 4 n
}\)</span>,此时当<span class="math inline">\(n \leq k \leq
p\)</span>的时候,<span class="math inline">\(\sin ( k \pi ) &gt; \sin
\frac{ \pi }{ 4 }\)</span>,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
\epsilon &amp; &gt; | S_{ n , p } ( x ) | \\
&amp; &gt; nb_{ 2 n } \sin \frac{ \pi }{ 4 } = \frac{ \sqrt{ 2 } }{ 2 }
n b_{ 2 n }
\end{aligned}
\]</span></p>
<p>这就搞定了<span class="math inline">\(b_{ 2 n } = o ( \frac{ 1 }{ n }
)\)</span>,又因为<span class="math inline">\(b_n\)</span>是单调下降的,那当然搞定了.</p>
<p>再证充分性,只要证明在<span class="math inline">\([ 0 , \pi
]\)</span>上一致收敛,由于<span class="math inline">\(\sin ( nx
)\)</span>是奇函数,那么在<span class="math inline">\([ - \pi , 0
]\)</span>上当然也一致收敛,那就搞定了.</p>
<p>设<span class="math inline">\(\mu_n = \max_{ m \geq n }{ mb_m
}\)</span>,注意到<span class="math inline">\(\mu_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>.下面开始讨论:</p>
<p>当<span class="math inline">\(x \in [ 0 , \frac{ \pi }{ p }
]\)</span>的时候,此时<span class="math inline">\(S_{ n , p
}\)</span>中的每一项都同号.自然有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = n }^p b_k \sin ( kx ) &amp; \leq \sum_{ k = n }^p b_k kx \\
&amp; \leq \frac{ \pi }{ p } \sum_{ k = n }^p b_k k \\
&amp; \leq \frac{ \pi }{ p } ( p - n ) \mu_n \\
&amp; \leq \pi \mu_n
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<p>当<span class="math inline">\(x \in [ \frac{ \pi }{ n } , \pi
]\)</span>的时候,和差化积公式给出:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = 1 }^n \sin ( kx ) | \\
= &amp; \left | \frac{ \cos ( k - \frac{ 1 }{ 2 } ) x - \cos ( k +
\frac{ 1 }{ 2 } ) }{ 2 \sin \frac{ x }{ 2 } } \right | \\
\leq &amp; \frac{ 1 }{ | \sin \frac{ x }{ 2 } | } \\
&lt; &amp; n
\end{aligned}
\]</span></p>
<p>原因是当<span class="math inline">\(\frac{ x }{ 2 } \leq \frac{ \pi
}{ 2 }\)</span>的时候,<span class="math inline">\(\sin \frac{ x }{ 2 }
\geq \frac{ 2 }{ \pi } \frac{ x }{ 2 } \geq n\)</span>.</p>
<p>回忆到Abel变换给出<span class="math inline">\(| S_{ n , p } | \leq n
( 2 b_n + b_p ) &lt; 3 nb_n \to 0\)</span>.这就搞定.</p>
<p>当<span class="math inline">\(x \in ( \frac{ \pi }{ p } , \frac{ \pi
}{ n } )\)</span>的时候,取<span class="math inline">\(m = \lfloor \frac{
\pi }{ x } \rfloor \leq \frac{ \pi }{ x }\)</span>.那我们就有:<span class="math inline">\(\frac{ \pi }{ m + 1 } \leq x \leq \frac{ \pi }{ m
}\)</span>.</p>
<p>当<span class="math inline">\(k \in [ n , m ]\)</span>的时候,<span class="math inline">\(kx \leq \pi\)</span>,那<span class="math inline">\(\sin ( kx ) \leq
kx\)</span>就成立,那么和上面一样:</p>
<p><span class="math display">\[
| S_{ n , m } | \leq \pi \mu_n
\]</span></p>
<p>当<span class="math inline">\(k \in [ m + 1 , p
]\)</span>的时候,此时<span class="math inline">\(\frac{ 1 }{ | \sin
\frac{ x }{ 2 } | } \geq \frac{ 1 }{ m + 1 }\)</span>,因此:</p>
<p><span class="math display">\[
| S_{ m + 1 , p } | \leq ( m + 1 ) ( 2 b_{ m + 1 } + b_p ) &lt; 3 \mu_{
m + 1 }
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
| S_{ n , p } | \leq | S_{ n , m } | + | S_{ m + 1 , p } | &lt; \pi
\mu_n + 3 \mu_{ m + 1 }
\]</span></p>
<p>这就搞定.</p>
<h4><span id="连续性">连续性</span></h4>
<p>我们还可以定义<strong>等度连续</strong>的概念:我们说<span class="math inline">\(f_n\)</span>等度连续,当<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt;
0\)</span>,使得<span class="math inline">\(\forall x ,
y\)</span>,若<span class="math inline">\(| x - y | &lt;
\delta\)</span>,则<span class="math inline">\(\forall n , | f_n ( x ) -
f_n ( y ) | &lt;
\epsilon\)</span>.其实就是某种一致(函数列)的一致(定义域上)连续.</p>
<p>我们可以证明:如果<span class="math inline">\(f_n ( x ) \in C [ a , b
]\)</span>,而且其等度连续,则如果<span class="math inline">\(\lim_{ n \to
\infty } f_n ( x ) = f ( x ) , x \in [ a , b ]\)</span>,则<span class="math inline">\(f_n \rightrightarrows f , x \in [ a , b
]\)</span>.</p>
<p>证明与前述Example6证明一致李氏连续类似,事实上Example6是这个的一个推论.我们取定<span class="math inline">\(\delta\)</span>,使得<span class="math inline">\(|
x - y | &lt; \delta\)</span>时一定有<span class="math inline">\(\forall
n , | f_n ( x ) - f_n ( y ) | &lt; \frac{ \epsilon }{ 3
}\)</span>,此时再令<span class="math inline">\(n \to
\infty\)</span>,就有<span class="math inline">\(| f ( x ) - f ( y ) |
\leq \frac{ \epsilon }{ 3 }\)</span>,再取一个分划<span class="math inline">\(\Delta : a = x_0 &lt; \cdots &lt; x_m =
b\)</span>并要求<span class="math inline">\(\lambda ( \Delta ) &lt;
\delta\)</span>.</p>
<p>自然有:</p>
<p><span class="math display">\[
\begin{aligned}
| f_n ( x ) - f ( x ) | &amp; \leq | f_n ( x ) - f_n ( x_i ) | + | f_n (
x_i ) - f ( x_i ) | + | f ( x_i ) - f ( x ) | \\
&amp; \leq \epsilon
\end{aligned}
\]</span></p>
<p>原因仍是有限点集上的收敛一定是一致收敛.</p>
<p>下面要探索的就是一致连续是否保持了原函数项级数的作用.</p>
<p>先看一个引理:当<span class="math inline">\(x_0 \in [ a , b
]\)</span>的时候,如若当<span class="math inline">\(x \in [ a , b ]
\setminus \{ x_0 \}\)</span>,<span class="math inline">\(f_n ( x )
\rightrightarrows f ( x )\)</span>,已知<span class="math inline">\(\lim_{ x \to x_0 } f_n ( x ) =
\alpha_n\)</span>存在.则<span class="math inline">\(\lim_{ n \to \infty
} \alpha_n\)</span>存在而且<span class="math inline">\(\lim_{ x \to x_0
} f ( x ) = \lim_{ n \to \infty } \alpha_n\)</span>.换言之,<span class="math inline">\(\lim_{ x \to x_0 } \lim_{ n \to \infty } f_n ( x )
= \lim_{ n \to \infty } \lim_{ x \to x_0 } f_n ( x )\)</span>.</p>
<p>证明的话,首先要证明<span class="math inline">\(\lim_{ n \to \infty }
\alpha_n\)</span>存在,考虑<span class="math inline">\(\forall \epsilon
&gt; 0 , \exists N , \forall n , m \geq N\)</span>,有<span class="math inline">\(| f_n ( x ) - f_m ( x ) | &lt; \frac{ \epsilon }{
3 }\)</span>,取极限知道<span class="math inline">\(| \alpha_n - \alpha_m
| \leq \frac{ \epsilon }{ 3 }\)</span>,这说明<span class="math inline">\(\{ \alpha_n
\}\)</span>是柯西列,当然收敛.不妨设<span class="math inline">\(\alpha =
\lim_{ n \to \infty } \alpha_n\)</span>.</p>
<p>此时有:</p>
<p><span class="math display">\[
| f ( x ) - \alpha | \leq | f ( x ) - f_N ( x ) | + | f_N ( x ) -
\alpha_N | + | \alpha_N - \alpha |
\]</span></p>
<p>两边一取极限使得<span class="math inline">\(x \to
x_0\)</span>,立刻见到<span class="math inline">\(| f ( x ) - \alpha |
&lt;
\epsilon\)</span>.这已经能看出一致连续的强大了.正是因为一致连续可以先固定<span class="math inline">\(N\)</span>,我们才可以在这里对<span class="math inline">\(x \to
x_0\)</span>取极限.所以这里有一个天然的可交换性.</p>
<p>这个引理的一个推论是:如果<span class="math inline">\(f_n
\rightrightarrows f , x \in [ a , b ]\)</span>,则对于<span class="math inline">\(x_0 \in [ a , b ]\)</span>,如果<span class="math inline">\(f_n ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续,则<span class="math inline">\(f\)</span>也在<span class="math inline">\(x_0\)</span>处连续.原因是既然连续,则<span class="math inline">\(\alpha_n = \lim_{ x \to x_0 } f_n ( x ) = f_n (
x_0 )\)</span>,所以<span class="math inline">\(\lim_{ x \to x_0 } f ( x
) = \lim_{ n \to \infty } f_n ( x_0 ) = f ( x_0
)\)</span>.这就说明在<span class="math inline">\(x_0\)</span>处连续.更有推论:如果<span class="math inline">\(f_n \in C [ a , b ] , f_n \rightrightarrows
f\)</span>,则<span class="math inline">\(f \in C [ a , b
]\)</span>.从而还可以见到,如果一串连续函数收敛到一个不连续函数,那这肯定也不是一致收敛的.</p>
<p>那么反过来,如果连续函数列收敛到连续函数,能不能推出一致收敛呢?我们事实上有<strong>迪尼定理</strong>:如果<span class="math inline">\(f_n ( x ) \in C [ a , b ]\)</span>,当<span class="math inline">\(n &lt; m\)</span>的时候,<span class="math inline">\(\forall x \in [ a , b ] , f_n ( x ) \leq f_m ( x
)\)</span>,此时如若<span class="math inline">\(f_n \rightarrow
f\)</span>,而且<span class="math inline">\(f \in C [ a , b
]\)</span>,则<span class="math inline">\(f_n \rightrightarrows
f\)</span>.也就是只要有一定的单调性,我们就可以说一致连续是连续函数列收敛到连续函数的充要条件.</p>
<p>取<span class="math inline">\(R_n ( x ) = f ( x ) - f_n ( x ) \geq
0\)</span>,注意到<span class="math inline">\(\lim_{ n \to \infty } R ( x
) = 0\)</span>而且<span class="math inline">\(R_n ( x
)\)</span>连续且逐点随<span class="math inline">\(n\)</span>单调递减,则必有<span class="math inline">\(R_n \to 0\)</span>.如果我们能证明<span class="math inline">\(R_n ( x ) \rightrightarrows
0\)</span>,那就万事大吉.不妨设<span class="math inline">\(M_n = \max_{ x
\in [ a , b ] } R_n ( x ) = R_n ( x_n )\)</span>,那么只要证明<span class="math inline">\(M_n \to 0\)</span>就可以搞定一致收敛.然而<span class="math inline">\(M_n\)</span>本身是单调下降的.反证,如果<span class="math inline">\(\lim_{ n \to \infty } M_n = c &gt;
0\)</span>,此时观察<span class="math inline">\(x_n \in [ a , b
]\)</span>,既然如此,<span class="math inline">\(\{ x_n
\}\)</span>必定有收敛子列,任取一个收敛子列<span class="math inline">\(\{
x_{ n_k } \}\)</span>并假设其收敛到<span class="math inline">\(x_0\)</span>,接下来看:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \lim_{ m \to \infty } R_m ( x_0 ) \\
= &amp; \lim_{ m \to \infty } \lim_{ x_{ n_k } \to x_0 } R_m ( x_{ n_k }
) \\
\geq &amp; \lim_{ m \to \infty } \lim_{ n_k &gt; m , x_{ n_k } \to x_0 }
R_{ n_k } ( x_{ n_k } ) \\
= &amp; \lim_{ x_{ n_k } \to x_0 } R_{ n_k } ( x_{ n_k } ) &gt; 0
\end{aligned}
\]</span></p>
<p>可这就出事了.于是矛盾,反证成立.</p>
<p>迪尼定理的一个推论是如果<span class="math inline">\(f_n ( x ) \geq
0\)</span>,那么此时<span class="math inline">\(S_n ( x ) = \sum_k^n f (
x )\)</span>就是逐点单调的了.因此我们可以看到此时<span class="math inline">\(\sum f_n\)</span>一致收敛性也就等价于其连续性.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(f_n \geq 0\)</span>,而且<span class="math inline">\(\forall n , f_n\)</span>单增的时候,如若<span class="math inline">\(\sum f_n ( x ) \leq M , \forall x \in [ a , b
)\)</span>.求证此时<span class="math inline">\(\lim_{ x \to b - 0 }
\sum_{ n = 1 }^\infty f_n ( x ) = \sum_{ n = 1 }^\infty f_n ( b - 0
)\)</span>.</p>
<p>设<span class="math inline">\(S_n = \sum_k^n f_k ( x
)\)</span>,取定<span class="math inline">\(m\)</span>,此时<span class="math inline">\(\forall x \in [ a , b )\)</span>,<span class="math inline">\(S ( x ) \geq S_m ( x )\)</span>.令<span class="math inline">\(x \to b - 0\)</span>,自然有<span class="math inline">\(\sum_{ n = 1 }^m f_n ( b - 0 ) \leq \lim_{ x \to b
- 0 } S ( x )\)</span>.直接令<span class="math inline">\(S ( b - 0 ) =
\lim_{ x \to b - 0 } S ( x )\)</span>,这个极限存在,原因是<span class="math inline">\(S ( x )\)</span>是单调的.从而取极限得到<span class="math inline">\(\sum_{ n = 1 }^\infty f_n ( b - 0 ) \leq S ( b - 0
)\)</span>.</p>
<p>接下来另一个方向,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 1 }^m f_n ( x ) &amp; \leq \sum_{ n = 1 }^m f_n ( b - 0 )
\leq \sum_{ n = 1 }^\infty f_n ( b - 0 ) \\
S ( x ) &amp; \leq \sum_{ n = 1 }^\infty f_n ( b - 0 ) \\
S ( b - 0 ) &amp; \leq \sum_{ n = 1 }^\infty f_n ( b - 0 )
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h6><span id="example2">Example2</span></h6>
<p><span class="math inline">\(f_n\)</span>在<span class="math inline">\([ a , b ]\)</span>上可微而且<span class="math inline">\(f_n &#39; \in R [ a , b ]\)</span>,若<span class="math inline">\(\forall x \in [ a , b ] , \forall n , | \sum_{ k =
1 }^n f_k &#39; ( x ) | \leq M\)</span>,<span class="math inline">\(\sum
f_n ( x )\)</span>在<span class="math inline">\([ a , b
]\)</span>上收敛.求证其在<span class="math inline">\([ a , b
]\)</span>上一致收敛.</p>
<p>容易观察到<span class="math inline">\(\sum f_n ( x
)\)</span>一致李氏连续,用之前等度连续的结论就可以做掉.</p>
<h4><span id="可积性">可积性</span></h4>
<p>如果<span class="math inline">\(f_n \in R [ a , b ] , f_n
\rightrightarrows f\)</span>,则我们声明<span class="math inline">\(f \in
R [ a , b ]\)</span>且<span class="math inline">\(\int_a^b f \mathrm{ d
} x = \lim_{ n \to \infty } \int_a^b f_n \mathrm{ d } x\)</span>.</p>
<p>考虑证明,首先<span class="math inline">\(f_n\)</span>是有界的,又因为一致收敛,所以能推出<span class="math inline">\(f\)</span>也是有界的.</p>
<p>一个想法是使用勒贝格定理.直接取<span class="math inline">\(K_n\)</span>是<span class="math inline">\(f_n\)</span>的间断点集,立刻得到<span class="math inline">\(K_n\)</span>是零测集.接下来令<span class="math inline">\(K = \bigcup K_n\)</span>,那<span class="math inline">\(K\)</span>还是零测集(可数个零测集的并),此时对于<span class="math inline">\(\forall x \in [ a , b ] \setminus K\)</span>,<span class="math inline">\(\forall n , f_n\)</span>都在<span class="math inline">\(x\)</span>处连续,那<span class="math inline">\(f\)</span>肯定也在<span class="math inline">\(x\)</span>处连续,所以<span class="math inline">\(f\)</span>的间断点集就一定被包含于零测集<span class="math inline">\(K\)</span>,所以黎曼可积.</p>
<p>接下来的问题是是否积分相等,取<span class="math inline">\(M_n = \sup_{
[ a , b ] } | f - f_n |\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_a^b f \mathrm{ d } x - \int_a^b f_n \mathrm{ d } x | \\
\leq &amp; \int_a^b | f - f_n | \mathrm{ d } x \\
\leq &amp; \int_a^b M_n \mathrm{ d } x \\
= &amp; M_n ( b - a ) \to 0
\end{aligned}
\]</span></p>
<p>这就搞定.然而注意到这里需要依赖于<span class="math inline">\(b -
a\)</span>的有界性.</p>
<p>另一个策略是直接用分划达布和证明<span class="math inline">\(f \in R [
a , b ]\)</span>.不妨设<span class="math inline">\(| f_n | \leq M , | f
| \leq M\)</span>.则<span class="math inline">\(\forall \epsilon &gt; 0
, \exists n\)</span>,<span class="math inline">\(| f_n ( x ) - f ( x ) |
&lt; \epsilon\)</span>.由于<span class="math inline">\(f_n ( x ) \in R [
a , b ]\)</span>,可以取定分划<span class="math inline">\(\Delta : a =
x_0 &lt; \cdots &lt; x_p = b\)</span>,使得<span class="math inline">\(\sum ( M_i - m_i ) \Delta x_i &lt;
\epsilon\)</span>.</p>
<p>于此,我们取<span class="math inline">\(\bar{ M }_i = \sup_{ [ x_{ i -
1 } , x_i ] } f ( x ) , \bar{ m }_i\)</span>同理.观察到<span class="math inline">\(\forall x \in [ x_{ i - 1 } , x_i ] , f ( x ) \leq
f_n ( x ) + \epsilon \leq M_i + \epsilon\)</span>,所以一定有<span class="math inline">\(\bar{ M }_i \leq M_i + \epsilon\)</span>.对于<span class="math inline">\(\bar{ m }_i\)</span>同理.此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum ( \bar{ M }_i - \bar{ m }_i ) \Delta x_i \\
\leq &amp; \sum ( M_i - m_i ) \Delta x_i + 2 \epsilon ( b - a ) \\
\leq &amp; \epsilon ( 1 + 2 ( b - a ) )
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>事实上这个结论可以更强,可以放弃一致收敛的条件.我们有<strong>控制收敛定理</strong>:假设<span class="math inline">\(f_n \in R [ a , b
]\)</span>,而且它们一致有界,<span class="math inline">\(\forall n ,
\forall x \in [ a , b ] , | f_n | \leq M\)</span>.并且<span class="math inline">\(f ( x ) = \lim_{ n \to \infty } f_n ( x ) \in R [
a , b ]\)</span>,则<span class="math inline">\(\int_a^b f ( x ) \mathrm{
d } x = \lim_{ n \to \infty } \int_a^b f_n ( x ) \mathrm{ d }
x\)</span>.</p>
<p>为证明此,先引入一些相关的定义:</p>
<p>定义<strong>阶梯函数</strong>为分段常值函数,假设<span class="math inline">\(f \in R [ a , b
]\)</span>,则我们可以用阶梯函数逼近<span class="math inline">\(f\)</span>,具体而言,假设<span class="math inline">\(g\)</span>是阶梯函数,并且<span class="math inline">\(g \leq f\)</span>,那么我们可以将<span class="math inline">\(g\)</span>类似达布下和而分划够细,以使得<span class="math inline">\(\int_a^b f \mathrm{ d } x = \sup_{ g \leq f ,
\text{ g is a step function } } \{ \int_a^b g ( x ) \mathrm{ d } x
\}\)</span>.</p>
<p>定义<strong>初等集</strong>:有限个不交区间的并,可以见到其测度<span class="math inline">\(m ( E )\)</span>就是所有不交区间的长度之和.</p>
<p>定义<strong>闭初等集</strong>:有限个不交闭区间的并.</p>
<p>定义<strong>有界闭初等集列</strong>:<span class="math inline">\(A_n\)</span>是闭初等集.容易见到,如果<span class="math inline">\(A_n \ne \emptyset\)</span>,而且<span class="math inline">\(A_{ n + 1 } \subseteq A_n\)</span>,则<span class="math inline">\(\bigcap_{ n = 1 }^\infty A_n \ne
\emptyset\)</span>,证明的话只需类似区间套定理,每个<span class="math inline">\(A_n\)</span>内取一个点,这个点列是有界的,那它就一定有收敛子列,收敛到的那个点一定被含在每一个<span class="math inline">\(A_n\)</span>中.这就搞定.</p>
<p>不妨设<span class="math inline">\(A_n\)</span>是有界非空集列,满足<span class="math inline">\(A_{ n + 1 } \subseteq A_n , A_n \ne \emptyset ,
\bigcap_{ n = 1 }^\infty A_n = \emptyset\)</span>.此时定义<span class="math inline">\(\alpha_n = \sup \{ m ( E ) \mid E \subseteq A_n ,
\text{ E is a closed elementary set } \}\)</span>.我们下面证明<span class="math inline">\(\lim_{ n \to \infty } \alpha_n = 0\)</span>.</p>
<p>首先显然<span class="math inline">\(\alpha_n\)</span>单调递减.如若其不以<span class="math inline">\(0\)</span>为极限,则一定有正下界<span class="math inline">\(\alpha_n &gt; \delta &gt;
0\)</span>.我们可以取<span class="math inline">\(A_n\)</span>的闭初等子集<span class="math inline">\(E_n \subseteq A_n\)</span>满足<span class="math inline">\(m ( E_n ) &gt; \alpha_n - \frac{ \delta }{ 2^n
}\)</span>.</p>
<p>接下来定义<span class="math inline">\(H_n = \bigcap_{ k = 1 }^n
E_k\)</span>,这当然是初等集,此时见到<span class="math inline">\(H_{ n +
1 } \subseteq H_n\)</span>.接下来对<span class="math inline">\(A_n
\setminus H_n\)</span>的任意初等子集<span class="math inline">\(E\)</span>,显然:</p>
<p><span class="math display">\[
\begin{aligned}
E &amp; = E \setminus H_n \\
&amp; = E \setminus ( \bigcap_{ k = 1 }^n E_k ) \\
&amp; = \bigcup_{ k = 1 }^n ( E \setminus E_k )
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(E \subseteq A_n \subseteq
A_k\)</span>,所以<span class="math inline">\(E_k\)</span>和<span class="math inline">\(E \setminus E_k\)</span>都是<span class="math inline">\(A_k\)</span>的初等子集.所以:</p>
<p><span class="math display">\[
\begin{aligned}
m ( E \setminus E_k ) + m ( E_k ) &amp; \leq \alpha_k \\
m ( E \setminus E_k ) &amp; \leq \frac{ \delta }{ 2^k }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(m ( E ) \leq
\delta\)</span>.如果<span class="math inline">\(H_n =
\emptyset\)</span>,那么<span class="math inline">\(m ( E ) =
\alpha_n\)</span>,这就不符.所以<span class="math inline">\(H_n \ne
\emptyset\)</span>,所以<span class="math inline">\(\bigcap_{ n = 1
}^\infty H_n \ne \emptyset\)</span>,所以<span class="math inline">\(\bigcap A_n \ne
\emptyset\)</span>.矛盾,这就证明了原本的结论.</p>
<p>接下来考虑<span class="math inline">\(f ( x ) - f_n ( x
)\)</span>,当没有一致连续的条件时,可能出现问题的地方在于有的地方两者不一定靠的足够近,想办法让这种地方所占的长度尽可能小就行.</p>
<p>对于<span class="math inline">\(\forall \epsilon &gt; 0 , A_n = \{ x
\in [ a , b ] \mid \exists j \geq n , | f_j ( x ) - f ( x ) | \geq
\epsilon \}\)</span>.容易见到<span class="math inline">\(A_{ n + 1 }
\subseteq A_n\)</span>,由于<span class="math inline">\(f_n \to
f\)</span>,所以<span class="math inline">\(\bigcap_{ n = 1 }^\infty A_n
= \emptyset\)</span>.引理告诉我们<span class="math inline">\(\alpha_n
\to 0\)</span>.既然如此,存在<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n \geq N\)</span>,<span class="math inline">\(A_n\)</span>的任意初等子集<span class="math inline">\(E\)</span>都有<span class="math inline">\(m ( E )
&lt; \epsilon\)</span>.取<span class="math inline">\(F = [ a , b ]
\setminus E\)</span>.这其实更像是取<span class="math inline">\([ a , b
]\)</span>的一个分划,因此如果我们在上面取阶梯函数的话,完全可以让阶梯函数所需的那个分划和这个分划并起来,从而完全由上述结果取到阶梯函数,此外我们的<span class="math inline">\(A_n \setminus E\)</span>的部分由于落在<span class="math inline">\(F\)</span>里而需要被<span class="math inline">\(\epsilon\)</span>控制.</p>
<p>此时取阶梯函数<span class="math inline">\(S ( x )\)</span>满足<span class="math inline">\(0 \leq S ( x ) \leq | f ( x ) - f_n ( x )
|\)</span>.这个时候看<span class="math inline">\(S ( x
)\)</span>的积分:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b S ( x ) \mathrm{ d } x &amp; = \int_E S ( x ) \mathrm{ d } x +
\int_F S ( x ) \mathrm{ d } x \\
&amp; \leq 2 M \epsilon + \epsilon ( b - a )
\end{aligned}
\]</span></p>
<p>这个对任意<span class="math inline">\(S ( x
)\)</span>都成立,由于我们之前说的阶梯函数的上界可以逼近原函数,所以这就意味着:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_a^b f_n ( x ) - f ( x ) \mathrm{ d } x | \\
\leq &amp; \int_a^b | f_n ( x ) - f ( x ) | \mathrm{ d } x \\
\leq &amp; 2 M \epsilon + \epsilon ( b - a )
\end{aligned}
\]</span></p>
<p>这就搞定.不过细心的读者也许会注意到一些问题,首先是这里用内测度逼近疑似有点神秘,然而如果用勒贝格测度的定义直接跑其实一眼就能看出来上面的结论.</p>
<p>还有另一个结论:假设<span class="math inline">\(f_n \in R [ a , b ] ,
| f_n | \leq M\)</span>,已知<span class="math inline">\(\lim_{ n \to
\infty } f_n ( x ) = f ( x )\)</span>存在(注意这里并不要求<span class="math inline">\(f ( x ) \in R [ a , b
]\)</span>),我们就可以证明<span class="math inline">\(\lim_{ n \to
\infty } \int_a^b f_n ( x ) \mathrm{ d } x\)</span>存在.</p>
<p>考虑<span class="math inline">\(| \int_a^b f_n \mathrm{ d } x | \leq
M ( b - a )\)</span>有界,所以其可以取上下极限操作.令<span class="math inline">\(\overline{ F } = \varlimsup_{ n \to \infty }
\int_a^b f_n \mathrm{ d } x , \underline{ F } = \varliminf_{ n \to
\infty } \int_a^b f_n \mathrm{ d }
x\)</span>.既然如此,就一定存在两列<span class="math inline">\(\{ n_k
\}\)</span>和<span class="math inline">\(\{ m_k \}\)</span>,使得<span class="math inline">\(\overline{ F } = \lim_{ k \to \infty } \int_a^b
f_{ n_k } \mathrm{ d } x , \underline{ F } = \lim_{ k \to \infty }
\int_a^b f_{ m_k } \mathrm{ d } x\)</span>.然而:</p>
<p><span class="math display">\[
\begin{aligned}
\overline{ F } - \underline{ F } &amp; = \lim_{ k \to \infty } \int_a^b
( f_{ n_k } - f_{ m_k } ) \mathrm{ d } x \\
&amp; = \int_a^b \lim_{ k \to \infty } ( f_{ n_k } - f_{ m_k } )
\mathrm{ d } x = 0
\end{aligned}
\]</span></p>
<p>这你就可以见到,我们其实可以把这个极限干脆定义成<span class="math inline">\(f\)</span>的积分.这实际上就是勒贝格积分.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:<span class="math inline">\(\int_0^1 \frac{ 1 }{ x^x } \mathrm{
d } x = \sum_{ n = 1 }^\infty \frac{ 1 }{ n^n }\)</span>.</p>
<p>展开:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ x^x } &amp; = e^{ - x \ln x } \\
&amp; = \sum_{ n \geq 0 } \frac{ ( - x \ln x )^n }{ n ! }
\end{aligned}
\]</span></p>
<p>容易证明这个函数项级数是一致收敛的,那我们就可以逐项积分,而且积分内可以做多少次分部积分都无所谓(反正是有限逼近无限).</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^1 \frac{ 1 }{ x^x } \mathrm{ d } x \\
= &amp; \int_0^1 \sum_{ n \geq 0 } \frac{ ( - x \ln x )^n }{ n ! }
\mathrm{ d } x \\
= &amp; \sum_{ n \geq 0 } \int_0^1 \frac{ ( - x \ln x )^n }{ n ! }
\mathrm{ d } x
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(x = e^{ - t }\)</span>,换元:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ n \geq 0 } \int_0^1 \frac{ ( - x \ln x )^n }{ n ! }
\mathrm{ d } x \\
= &amp; - \sum_{ n \geq 0 } \frac{ 1 }{ n ! } \int_0^{ + \infty } e^{ -
( n + 1 ) t } t^n \mathrm{ d } t
\end{aligned}
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ + \infty } e^{ - ( n + 1 ) t } t^n \mathrm{ d } t \\
= &amp; \frac{ - 1 }{ n + 1 } \int_0^{ + \infty } t^n \mathrm{ d } e^{ -
( n + 1 ) t } \\
= &amp; \frac{ - 1 }{ n + 1 } \left ( e^{ - ( n + 1 ) t } t^{ n } |_0^{
+ \infty } - n \int_0^{ + \infty } e^{ - ( n + 1 ) t } t^{ n - 1 }
\right ) \\
= &amp; \frac{ n }{ n + 1 } \int_0^{ + \infty } e^{ - ( n + 1 ) t } t^{
n - 1 } \\
= &amp; \cdots \\
= &amp; \frac{ n ! }{ ( n + 1 )^{ n } } \int_0^{ + \infty } e^{ - ( n +
1 ) t } \mathrm{ d } t \\
= &amp; - \frac{ n ! }{ ( n + 1 )^{ n + 1 } }
\end{aligned}
\]</span></p>
<p>和上面结合一下就证毕.</p>
<h6><span id="example2">Example2</span></h6>
<p>设函数列<span class="math inline">\(\{ f_n ( x )
\}\)</span>任意内闭可积,并且<span class="math inline">\(\{ f_n ( x )
\}\)</span>在<span class="math inline">\(\mathbb{ R
}\)</span>上一致收敛到<span class="math inline">\(f ( x
)\)</span>,再设存在函数<span class="math inline">\(g ( x
)\)</span>满足:</p>
<p><span class="math display">\[
| f_n ( x ) | \leq g ( x )
\]</span></p>
<p>并且<span class="math inline">\(\int_{ - \infty }^{ + \infty } g ( x
) \mathrm{ d } x &lt; + \infty\)</span>.求证下列积分收敛而且:</p>
<p><span class="math display">\[
\int_{ - \infty }^{ + \infty } f ( x ) \mathrm{ d } x = \lim_{ n \to
\infty } \int_{ - \infty }^{ + \infty } f_n ( x ) \mathrm{ d } x
\]</span></p>
<p>首先要证明<span class="math inline">\(\int_{ - \infty }^{ + \infty }
f ( x ) \mathrm{ d } x\)</span>收敛.只需观察到<span class="math inline">\(| f_n | \leq g\)</span>两遍取极限就可以拿到<span class="math inline">\(| f | \leq g\)</span>,所以绝对收敛.</p>
<p>接下来考虑如何证明相等,这里的问题在于虽然<span class="math inline">\(f ( x ) \rightrightarrows
f\)</span>,但是由于区间长度无限长,因此这个控制会被放大.于此我们的策略是考虑将区间分成三段:<span class="math inline">\([ - \infty , - A ] , [ - A , A ] , [ A , + \infty
]\)</span>,对于中间的部分用一致收敛控制住,对于前后的部分用柯西准则控制住.</p>
<p>具体而言,<span class="math inline">\(| f ( x ) - f_n ( x ) | \leq 2 g
( x )\)</span>取足够大的<span class="math inline">\(A\)</span>使得<span class="math inline">\(\int_{ A }^{ + \infty } g ( x ) \mathrm{ d } x
\leq \frac{ \epsilon }{ 6 }\)</span>以及<span class="math inline">\(\int_{ - \infty }^{ - A } g ( x ) \mathrm{ d } x
\leq \frac{ \epsilon }{ 6 }\)</span>,接下来考虑取足够大的<span class="math inline">\(n\)</span>使得在<span class="math inline">\([ - A
, A ]\)</span>上,<span class="math inline">\(| f_n ( x ) - f ( x ) |
&lt; \frac{ \epsilon }{ 6 A }\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ - \infty }^{ + \infty } f_n ( x ) - f ( x ) \mathrm{ d }
x | \\
\leq &amp; | \int_{ - A }^{ + A } f_n ( x ) - f ( x ) \mathrm{ d } x | +
| \int_{ - \infty }^{ - A } f_n ( x ) - f ( x ) \mathrm{ d } x | + |
\int_{ + A }^{ + \infty } f_n ( x ) - f ( x ) \mathrm{ d } x | \\
\leq &amp; 2 A \frac{ \epsilon }{ 6 A } + \frac{ \epsilon }{ 6 } \times
4 \\
= &amp; \epsilon
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h4><span id="可微性">可微性</span></h4>
<p>先看一个平凡的命题:假设<span class="math inline">\(f_n \in C^1 [ a ,
b ] , x_0 \in [ a , b ]\)</span>,已知<span class="math inline">\(\{ f_n
( x_0 ) \}\)</span>收敛,而且<span class="math inline">\(f_n &#39;
\rightrightarrows g\)</span>.则<span class="math inline">\(f_n
\rightrightarrows f\)</span>,其中<span class="math inline">\(f \in C^1 [
a , b ]\)</span>,并且恰好满足<span class="math inline">\(f &#39; =
g\)</span>.</p>
<p>考虑<span class="math inline">\(g ( x ) = \lim_{ n \to \infty } f_n
&#39; ( x ) , x \in [ a , b ]\)</span>当然能得到<span class="math inline">\(g ( x )\)</span>是连续函数.</p>
<p>接下来考虑NL公式给出:</p>
$$
<span class="math display">\[\begin{aligned}
f_n ( x ) &amp; = f_n ( x_0 ) + \int_{ x_0 }^x f &#39;_n ( t ) \mathrm{
d } t \\
\lim_{ n \to \infty } f_n ( x ) &amp; = \lim_{ n \to \infty } f_n ( x_0
) + \lim_{ n \to \infty } \int_{ x_0 }^x f &#39;_n ( t ) \mathrm{ d } t
\\
\lim_{ n \to \infty } f_n ( x ) &amp; = \lim_{ n \to \infty } f_n ( x_0
) + \int_{ x_0 }^x \lim_{ n \to \infty } f &#39;_n ( t ) \mathrm{ d } t
\\
f ( x ) &amp; = \lim_{ n \to \infty } f_n ( x_0 ) + \int_{ x_0 }^x g ( t
) \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>这就见到<span class="math inline">\(f_n \to f , f \in C^1 [ a , b
]\)</span>而且<span class="math inline">\(f &#39; =
g\)</span>.现在的问题是能否推出一致收敛<span class="math inline">\(f_n
\rightrightarrows f\)</span>.有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - f ( x ) | \\
= &amp; | f_n ( x_0 ) + \int_{ x_0 }^x f_n &#39; ( t ) \mathrm{ d } t -
f ( x_0 ) - \int_{ x_0 }^x g ( t ) | \\
\leq &amp; | f_n ( x_0 ) - f ( x_0 ) | + | \int_{ x_0 }^x f_n &#39; ( t
) \mathrm{ d } t - \int_{ x_0 }^x g ( t ) | \\
\leq &amp; | f_n ( x_0 ) - f ( x_0 ) | + ( b - a ) \sup | f_n &#39; - g
|
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<p>上述结果能不能加强呢?事实上有一个更一般的结果:假设对于一串连续函数<span class="math inline">\(f_n ( x ) \in C [ a , b ]\)</span>,已知<span class="math inline">\(\exists x_0 \in [ a , b ]\)</span>,<span class="math inline">\(\lim_{ n \to \infty } f_n ( x_0
)\)</span>存在.若对于<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N &gt; 0 , \forall n , m
\geq N\)</span>,函数<span class="math inline">\(g ( x ) = f_n ( x ) -
f_m ( x )\)</span>的李氏常数<span class="math inline">\(&lt;
\epsilon\)</span>.则我们可以推出<span class="math inline">\(\{ f_n ( x )
\}\)</span>一致收敛,设<span class="math inline">\(f_n ( x )
\rightrightarrows f ( x )\)</span>,若对于某个<span class="math inline">\(x \in [ a , b ]\)</span>,如果<span class="math inline">\(f_n &#39; ( x )\)</span>恒存在,而且<span class="math inline">\(\lim_{ n \to \infty } f_n &#39; ( x
)\)</span>存在,则<span class="math inline">\(f &#39; ( x
)\)</span>存在而且<span class="math inline">\(f &#39; ( x ) = \lim_{ n
\to \infty } f_n &#39; ( x )\)</span>.</p>
<p>这个结论的正确性比较直观,就是用李氏连续的性质限制整个函数的波动.这个结论当然要严格强于原本的结论,因为闭区间上的可导函数自然是李氏连续函数,如若<span class="math inline">\(f_n &#39; ( x
)\)</span>一致连续,当然能推出上述的李氏连续性质,立刻得到原本结论.</p>
<p>下面考虑证明:<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists N , \forall n , m \geq N\)</span>,都有<span class="math inline">\(| f_n ( x_0 ) - f_m ( x_0 ) | &lt; \frac{ \epsilon
}{ 2 }\)</span>,并且<span class="math inline">\(f_n ( x ) - f_m ( x
)\)</span>的李氏常数<span class="math inline">\(&lt; \frac{ \epsilon }{
2 ( b - a ) }\)</span>.注意到此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - f_m ( x ) | \\
\leq &amp; | f_n ( x ) - f_m ( x ) - ( f_n ( x_0 ) - f_m ( x_0 ) ) | + |
f_n ( x_0 ) - f_m ( x_0 ) | \\
&lt; &amp; \frac{ \epsilon }{ 2 ( b - a ) } | x - x_0 | + \frac{
\epsilon }{ 2 } \leq \epsilon
\end{aligned}
\]</span></p>
<p>这就证明了<span class="math inline">\(f_n\)</span>一致收敛,不妨设<span class="math inline">\(f_n \rightrightarrows f\)</span>.</p>
<p>接下来对于某个<span class="math inline">\(x \in [ a , b
]\)</span>,定义<span class="math inline">\(\varphi_n ( t ) = \frac{ f_n
( t ) - f_n ( x ) }{ t - x } , t \in [ a , b ] \setminus \{ x
\}\)</span>,并补定义<span class="math inline">\(\varphi ( t ) = \frac{ f
( t ) - f ( x ) }{ t - x } , t \in [ a , b ] \setminus \{ x
\}\)</span>.显然<span class="math inline">\(\varphi_n ( t ) \in C [ a ,
b ] \setminus \{ x \}\)</span></p>
<p>首先注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \varphi_n ( t ) - \varphi_m ( t ) | \\
= &amp; \frac{ 1 }{ | t - x | } | f_n ( t ) - f_m ( t ) - ( f_n ( x ) -
f_m ( x ) ) | \\
\leq &amp; \frac{ 1 }{ | t - x | } \frac{ \epsilon }{ 2 ( b - a ) } | t
- x | \\
= &amp; \frac{ \epsilon }{ 2 ( b - a ) }
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(\varphi_n ( t
)\)</span>一致收敛,而且容易见到<span class="math inline">\(\varphi_n
\rightrightarrows \varphi\)</span>.从而:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ t \to x } \varphi ( t ) \\
&amp; = \lim_{ t \to x } \lim_{ n \to \infty } \varphi_n ( t ) \\
&amp; = \lim_{ n \to \infty } \lim_{ t \to x } \varphi_n ( t ) \\
&amp; = \lim_{ n \to \infty } f_n &#39; ( x )
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<p>容易发现上述的推论是可导函数列的收敛性质(并不需要<span class="math inline">\(C^1\)</span>).而且我们还可以推出一个推论:那就是导函数一致收敛到的函数也是导函数.</p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(\{ q_n \}\)</span>是<span class="math inline">\([ 0 , 1
]\)</span>中的全体有理数排成的数列.定义<span class="math inline">\(f ( x
) = \sum_{ n = 1 }^\infty \frac{ | x - q_n | }{ 3^n } , x \in [ 0 , 1
]\)</span>.</p>
<p>首先用大M判别法,注意到<span class="math inline">\(\frac{ | x - q_n |
}{ 3^n } \leq \frac{ 1 }{ 3^n
}\)</span>,而每一项都是连续的,所以总的<span class="math inline">\(f ( x
)\)</span>是连续函数,而且这个定义也是收敛的.而且对于<span class="math inline">\(x_0 \in [ 0 , 1 ] \setminus \mathbb{ Q
}\)</span>,<span class="math inline">\(f_n &#39; ( x_0
)\)</span>当然都是存在的,而且见到<span class="math inline">\(f_n &#39; (
x_0 ) = \sum_{ k = 1 }^n \frac{ \text{ sgn } ( x_0 - q_k ) }{ 3^k
}\)</span>,并且这个导数还足够小.因此立刻见到当<span class="math inline">\(n , m\)</span>足够大的时候,立刻见到<span class="math inline">\(f_n - f_m\)</span>的李氏常数可以尽可能小.</p>
<p>于是套用上面的结论可以知道<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\([ 0 , 1 ] \setminus \mathbb{ Q
}\)</span>处可导.那么其在<span class="math inline">\(\mathbb{ Q } \cap [
0 , 1 ]\)</span>上可导么?如若<span class="math inline">\(x \in \mathbb{
Q }\)</span>,不妨设<span class="math inline">\(x =
q_n\)</span>,则考虑<span class="math inline">\(f ( x ) = \frac{ | x -
q_n | }{ 3^n } + \sum_{ k \ne n } \frac{ | x - q_k | }{ 3^k
}\)</span>,前半部分在<span class="math inline">\(q_n\)</span>处不可导可后半部分在<span class="math inline">\(q_n\)</span>处可导,于是总和当然不可导.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f ( x ) = \sum_{ n = 1 }^\infty \frac{
\sin ( nx ) }{ n^3 }\)</span>,求其导函数.</p>
<p>观察到<span class="math inline">\(\sum_{ n = 1 }^\infty | ( \frac{
\sin ( nx ) }{ n^3 } ) &#39; | \leq \sum \frac{ 1 }{ n^2 } &lt;
\infty\)</span>,所以其导函数也绝对一致收敛.立刻能推出<span class="math inline">\(f \in C^1 ( - \infty , + \infty
)\)</span>,而且导函数就是逐项求导的<span class="math inline">\(f &#39; (
x ) = \sum_{ n = 1 }^\infty \frac{ \cos ( nx ) }{ n^2 }\)</span>.</p>
<h4><span id="部分应用">部分应用</span></h4>
<h5><span id="borel引理">Borel引理</span></h5>
<p>对任何一个实数列<span class="math inline">\(\{ a_n
\}\)</span>,都存在一个函数<span class="math inline">\(f ( x ) \in C^{
\infty } ( \mathbb{ R } )\)</span>,满足<span class="math inline">\(f^{ (
n ) } ( 0 ) = a_n\)</span>.</p>
<p>考虑造一个<span class="math inline">\(g ( x ) = \begin{cases}1 &amp;
0 \leq x \leq \frac{ 1 }{ 2 } \\ 0 &amp; x \geq
1\end{cases}\)</span>,其中中间少了一段用磨光核连起来.考虑造一个单调递增无界正数列<span class="math inline">\(\{ \lambda_n \}\)</span>,并取:</p>
<p><span class="math display">\[
f ( x ) = \sum_{ n = 0 }^\infty \frac{ a_n x^n }{ n ! } g ( \lambda_n |
x | )
\]</span></p>
<p>这个的好处是什么呢?我们发现当<span class="math inline">\(\lambda_n |
x | \geq 1\)</span>,<span class="math inline">\(| x | \geq \frac{ 1 }{
\lambda_n }\)</span>的时候<span class="math inline">\(g ( \lambda_n | x
| ) = 0\)</span>,又因为<span class="math inline">\(\lambda_n\)</span>单调递增趋近于无穷,所以除了<span class="math inline">\(0\)</span>以外的所有点上都是有限和,因此全都收敛而且全都可导,所以<span class="math inline">\(f \in C^{ \infty } ( \mathbb{ R } \setminus \{ 0
\} )\)</span>.</p>
<p>考虑<span class="math inline">\(f_n ( x ) = \frac{ a_n x^n }{ n ! } g
( \lambda_n | x | )\)</span>,这个当然是<span class="math inline">\(C^{
\infty }\)</span>的.并且当然有<span class="math inline">\(f_n^{ ( n ) }
( 0 ) = a_n\)</span>.现在如果我们能搞定这个导数级数的收敛性就搞定了<span class="math inline">\(0\)</span>处的可导性了对吧.取<span class="math inline">\(M_k = \max_{ 0 \leq l \leq k } | g^{ ( l ) }
|\)</span>,当<span class="math inline">\(k \leq
n\)</span>的时候考虑:</p>
$$
<span class="math display">\[\begin{aligned}
| f_n^{ ( k ) } ( x ) | &amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0
}^k \left | \binom{ k }{ m } n^{ \underline{ k - m } } x^{ n - k + m }
g^{ ( m ) } ( \lambda_n | x | ) \lambda_n^m \right | \\
&amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0 }^k \left | \binom{ k }{
m } n^{ \underline{ k - m } } x^{ n - k + m } M_k \lambda_n^m \right |
\\

\end{aligned}\]</span>
<p>$$</p>
<p>注意这里的<span class="math inline">\(x\)</span>一定很小,<span class="math inline">\(| x | &lt; \frac{ 1 }{ \lambda_n
}\)</span>的时候上式才有意义,开始放缩:</p>
<p><span class="math display">\[
\begin{aligned}
| f_n^{ ( k ) } ( x ) | &amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0
}^k \left | \frac{ k ! }{ m ! ( k - m ) ! } n^{ \underline{ k - m } }
M_k \frac{ 1 }{ \lambda_n^{ n - k } } \right | \\
&amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0 }^k \left | \frac{ k !
}{ m ! ( k - m ) ! } n^{ \underline{ k - m } } M_k \frac{ 1 }{
\lambda_n^{ n - k } } \right | \\
&amp; = \frac{ | a_n | }{ n ! } \sum_{ m = 0 }^k \left | \frac{ k ! }{ m
! ( k - m ) ! } \frac{ n ! }{ ( n - k + m ) ! } M_k \frac{ 1 }{
\lambda_n^{ n - k } } \right | \\
&amp; \leq | a_n | M_k \frac{ 1 }{ \lambda_n^{ n - k } } k !
\end{aligned}
\]</span></p>
<p>显然只需取足够小的<span class="math inline">\(\lambda_n\)</span>就用大M判别法控制住了.</p>
<h5><span id="维尔斯特拉斯函数">维尔斯特拉斯函数</span></h5>
<p>考虑造一个处处连续处处不可导的函数,首先它应该在任何一个区间上都没有单调性(因为单调函数几乎处处可导).</p>
<p>首先造一个连续的<span class="math inline">\(2\)</span>周期函数<span class="math inline">\(h ( x ) = \begin{cases}x &amp; 0 \leq x \leq 1 \\
2 - x &amp; 1 \leq x \leq 2 \\ h ( x - 2 ) &amp; \text{ otherwise
}\end{cases}\)</span>.或者我们干脆定义<span class="math inline">\(h ( x
) = \sin ( \frac{ \pi }{ 2 } 4^n x
)\)</span>,这样这个函数更光滑一点,但对论证几乎没有区别.</p>
<p>考虑造<span class="math inline">\(f ( x ) = \sum_{ n = 0 }^{ \infty }
( \frac{ 3 }{ 4 } )^n h ( 4^n x )\)</span>,注意到:</p>
<p><span class="math display">\[
f ( x ) \leq \sum ( \frac{ 3 }{ 4 } )^n &lt; \infty
\]</span></p>
<p>根据大M判别法,所以这个函数的确绝对一致收敛.那这个函数就确实继承了连续性.</p>
<p>首先有引理:如果<span class="math inline">\(f &#39; ( x_0
)\)</span>存在,而且<span class="math inline">\(\alpha_n \leq x_0 \leq
\beta_n , 0 &lt; \beta_n - \alpha_n \to 0\)</span>,则<span class="math inline">\(\lim_{ n \to \infty } \frac{ f ( \beta_n ) - f (
\alpha_n ) }{ \beta_n - \alpha_n } \to f &#39; ( x_0 )\)</span>.取<span class="math inline">\(\lambda_n = \frac{ \beta_n - x_0 }{ \beta_n -
\alpha_n }\)</span>,容易见到<span class="math inline">\(0 \leq \lambda_n
\leq 1\)</span>,见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ f ( \beta_n ) - f ( \alpha_n ) }{ \beta_n - \alpha_n } - f
&#39; ( x_0 ) \\
= &amp; \lambda_n ( \frac{ f ( \beta_n ) - f ( x_0 ) }{ \beta_n - x_0 }
- f &#39; ( x_0 ) ) + ( 1 - \lambda_n ) ( \frac{ \alpha_n - f ( x_0 ) }{
\alpha_n - x_0 } - f &#39; ( x_0 ) )
\end{aligned}
\]</span></p>
<p>容易见到趋近于<span class="math inline">\(0\)</span>.不过要简单判断一下<span class="math inline">\(\alpha_n = x_0\)</span>的情况.</p>
<p>既然如此,<span class="math inline">\(\forall x \in \mathbb{ R
}\)</span>,考虑定义<span class="math inline">\(\alpha_m = \frac{ \lfloor
4^m x \rfloor }{ 4^m } , \beta_m = \alpha_m + \frac{ 1 }{ 4^m
}\)</span>,容易见到<span class="math inline">\(\alpha_m \leq x &lt;
\beta_m\)</span>.并且当<span class="math inline">\(n \leq
m\)</span>的时候，<span class="math inline">\(( 4^n \alpha_m , 4^n
\beta_m )\)</span>上不存在整数.</p>
<p>见到:</p>
<p><span class="math display">\[
4^n ( \beta_m - \alpha_m ) = \begin{cases}
\in 4 \mathbb{ N } &amp; n &gt; m \\
1 &amp; n = m \\
&lt; 1 &amp; \text{ otherwise }
\end{cases}
\]</span></p>
<p>于是:</p>
<p><span class="math display">\[
| h ( 4^n \beta_m ) - h ( 4^n \alpha_m ) | = \begin{cases}
0 &amp; n &gt; m \\
| 4^n \beta_m - 4^n \alpha_m | = 4^{ n - m } &amp; n \leq m
\end{cases}
\]</span></p>
<p>把<span class="math inline">\(n &lt;
m\)</span>的地方往负了放,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
| f ( \beta_m ) - f ( \alpha_m ) | &amp; = \sum_{ n = 0 }^m ( \frac{ 3
}{ 4 } )^n ( h ( 4^n \beta_m ) - h ( 4^n \alpha_m ) ) \\
&amp; \geq ( \frac{ 3 }{ 4 } )^m - \sum_{ n = 0 }^{ m - 1 } ( \frac{ 3
}{ 4 } )^n 4^{ n - m } \\
&amp; = ( \frac{ 3 }{ 4 } )^m - \frac{ 1 }{ 4^m } \frac{ 3^m - 1 }{ 2 }
\\
&amp; = \frac{ 1 }{ 4^m } \frac{ 3^m + 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
\frac{ | f ( \beta_m ) - f ( \alpha_m ) | }{ \beta_m - \alpha_m } \geq
\frac{ 3^m + 1 }{ 2 }
\]</span></p>
<p>然而如若这点导数存在,那么这里的导数就是<span class="math inline">\(\lim_{ m \to \infty } \frac{ 3^m + 1 }{ 2 } =
\infty\)</span>,这就矛盾了.因此这个函数处处不可导.</p>
<h5><span id="连续曲线充满平面">连续曲线充满平面</span></h5>
<p>存在充满<span class="math inline">\([ 0 , 1 ] \times [ 0 , 1
]\)</span>的连续曲线.连续曲线在这里定义为<span class="math inline">\(( x
( t ) , y ( t ) ) , t \in [ 0 , 1 ]\)</span>满足<span class="math inline">\(x ( t ) , y ( t ) \in C [ 0 , 1
]\)</span>,任意<span class="math inline">\(( a , b ) \in [ 0 , 1 ]
\times [ 0 , 1 ]\)</span>,都存在<span class="math inline">\(t\)</span>使得<span class="math inline">\(a = x (
t ) , b = y ( t )\)</span>.</p>
<p>搞一个连续函数<span class="math inline">\(g ( t )\)</span>满足:</p>
$$ g ( t ) =
<span class="math display">\[\begin{cases}
0 &amp; t \in [ 0 , \frac{ 1 }{ 3 } ] \cup [ \frac{ 5 }{ 3 } , 2 ] \\
3 t - 1 &amp; t \in [ \frac{ 1 }{ 3 } , \frac{ 2 }{ 3 } ] \\
1 &amp; t \in [ \frac{ 2 }{ 3 } , \frac{ 4 }{ 3 } ] \\
3 t + 5 &amp; t \in [ \frac{ 4 }{ 3 } , \frac{ 5 }{ 3 } ] \\

\end{cases}\]</span>
<p>$$</p>
<p>并且满足<span class="math inline">\(g ( t + 2 ) = g ( t
)\)</span>,也就是一个周期梯形函数.</p>
<p>接下来定义:</p>
<p><span class="math display">\[
\begin{aligned}
x ( t ) &amp; = \sum_{ n = 1 }^\infty \frac{ 1 }{ 2^n } g ( 3^{ 2 n - 2
} t ) \\
y ( t ) &amp; = \sum_{ n = 1 }^\infty \frac{ 1 }{ 2^n } g ( 3^{ 2 n - 1
} t )
\end{aligned}
\]</span></p>
<p>容易发现<span class="math inline">\(0 \leq x ( t ) , y ( t ) \leq
\sum_{ n = 1 }^\infty \frac{ 1 }{ 2^n } =
1\)</span>,所以的确绝对一致收敛,继承了连续性而且确实在<span class="math inline">\([ 0 , 1 ] \times [ 0 , 1 ]\)</span>中.</p>
<p>接下来<span class="math inline">\(\forall ( a , b ) \in [ 0 , 1 ]
\times [ 0 , 1 ]\)</span>,我们尝试找到一个<span class="math inline">\(t\)</span>使得<span class="math inline">\(a = x (
t ) , b = y ( t )\)</span>.考虑取二者的二进制表示<span class="math inline">\(a = \sum_{ n = 1 }^\infty \frac{ a_n }{ 2^n } , b
= \sum_{ n = 1 }^\infty \frac{ b_n }{ 2^n }\)</span>,其中<span class="math inline">\(a_n , b_n \in \{ 0 , 1
\}\)</span>.取一个新的数列<span class="math inline">\(c_{ 2 n - 1 } =
a_n , c_{ 2 n } = b_n\)</span>.取<span class="math inline">\(0 \leq c =
2 \sum_{ n = 1 }^\infty \frac{ c_n }{ 3^n } \leq
1\)</span>,下面我们证明<span class="math inline">\(x ( c ) = a , x ( c )
= b\)</span>.</p>
<p>考虑<span class="math inline">\(3^k c = 2 \sum_{ n = 1 }^k \frac{ c_n
}{ 3^{ n - k } } + 2 \sum_{ n = k + 1 }^\infty \frac{ c_n }{ 3^{ n - k }
}\)</span>.其中前半部分是个偶整数,因此在带入函数<span class="math inline">\(g\)</span>后会消失,观察后半部分,容易见到:如果<span class="math inline">\(c_{ k + 1 } = 0\)</span>,则后半部分<span class="math inline">\(\leq \frac{ 1 }{ 3 }\)</span>;如果<span class="math inline">\(c_{ k + 1 } = 1\)</span>,则后半部分<span class="math inline">\(\geq \frac{ 2 }{ 3 }\)</span>,因此<span class="math inline">\(g ( 3^k c ) = c_{ k + 1
}\)</span>.带入原式定义就看到<span class="math inline">\(x ( c ) = a , y
( c ) = b\)</span>.</p>
<p>甚至说,这里的<span class="math inline">\(c\)</span>其实就在康托尔三分集中,所以事实上这个曲线上的零测集就足以覆盖整个平面.</p>
<h4><span id="幂级数">幂级数</span></h4>
<p>我们把形如<span class="math inline">\(f ( x ) = \sum_{ n = 0 }^{
\infty } a_n ( x - x_0
)^n\)</span>的函数项级数称作<strong>幂级数</strong>,由于可以做自变量平移,不妨假设<span class="math inline">\(x_0 = 0\)</span>而<span class="math inline">\(f (
x ) = \sum_{ n = 0 }^{ \infty } a_n x^n\)</span>.</p>
<p>一个最先遇到的问题当然是幂级数的收敛范围,首先<span class="math inline">\(x = 0\)</span>肯定收敛.其次我们可以发现如果<span class="math inline">\(f ( r )\)</span>收敛,那么<span class="math inline">\(\forall x \in \mathbb{ R } , | x | &lt; | r
|\)</span>都有<span class="math inline">\(f ( x
)\)</span>收敛,原因是:</p>
<p><span class="math display">\[
\sum | a_n x^n | = \sum | a_n r^n | \cdot | \frac{ x }{ r } |^n
\]</span></p>
<p>由于<span class="math inline">\(\sum a_n
r^n\)</span>收敛,所以其通项<span class="math inline">\(\lim_{ n \to
\infty } a_n r^n = 0\)</span>,那至少是有界的,而<span class="math inline">\(| \frac{ x }{ r }
|^n\)</span>又是个无穷递降等比数列,那就肯定收敛.既然如此,取<span class="math inline">\(R = \sup \{ | x | , x \in \mathbb{ R } | f ( x )
\text{ is converge } \}\)</span>.由上面的结论我们知道<span class="math inline">\(\forall x \in ( - R , R )\)</span>都有<span class="math inline">\(f ( x )\)</span>收敛,另外<span class="math inline">\(\forall x , | x | &gt; R\)</span>都有<span class="math inline">\(f ( x )\)</span>发散.既然如此,我们将<span class="math inline">\(( - R , R
)\)</span>称作幂级数的<strong>收敛区间</strong>,容易见到收敛域和收敛区间最多只可能差两个点,换言之设收敛域为<span class="math inline">\(E\)</span>,则自然有<span class="math inline">\(( -
R , R ) \subseteq E \subseteq [ - R , R ]\)</span>.</p>
<p>取<span class="math inline">\(\rho = \varlimsup_{ n \to + \infty }
\sqrt[n]{ | a_n | }\)</span>,则<span class="math inline">\(R = \rho^{ -
1 }\)</span>(这里要做一些约定:不妨设<span class="math inline">\(\inf^{ -
1 } = 0\)</span>和<span class="math inline">\(0^{ - 1 } =
\inf\)</span>).原因是<span class="math inline">\(\varlimsup_{ n \to +
\infty } \sqrt[n]{ | a_n x^n | } = | x |
\rho\)</span>,用根值判别法就显然了.</p>
<p>这里还有一个更弱的比值判别法的版本:如若<span class="math inline">\(a_n \ne 0\)</span>,<span class="math inline">\(\rho = \lim_{ n \to \infty } \left | \frac{ a_{ n
+ 1 } }{ a_n } \right |\)</span>存在,则<span class="math inline">\(R =
\rho^{ - 1 }\)</span>.原因是Stolz定理给出:</p>
<p><span class="math display">\[
\varliminf \frac{ | a_{ n + 1 } | }{ | a_n | } \leq \varliminf \sqrt[n]{
| a_n | } \leq \varlimsup \sqrt[n]{ | a_n | } \leq \varlimsup \frac{ |
a_{ n + 1 } | }{ | a_n | }
\]</span></p>
<p>下面我们证明,在收敛区间的内部<span class="math inline">\(( - R , R
)\)</span>内,<span class="math inline">\(\sum a_n
x^n\)</span>是内闭绝对一致收敛的.而如果其在端点处也收敛,例如在<span class="math inline">\(x = R\)</span>时收敛的话,则其在<span class="math inline">\([ 0 , R ]\)</span>上一致收敛.</p>
<p>前者的话,只需用大M判别法即可,任取<span class="math inline">\([ - r ,
r ] \subseteq ( - R , R )\)</span>然后看<span class="math inline">\(|
a_n x^n | \leq | a_n r^n |\)</span>.</p>
<p>而对于后者的话,考虑<span class="math inline">\(\sum a_n x^n = \sum
a_n R^n ( \frac{ x }{ R } )^n\)</span>,而<span class="math inline">\((
\frac{ x }{ R } )^n\)</span>是单调一致有界,而<span class="math inline">\(\sum a_n R^n\)</span>收敛,用DA判法则搞定.</p>
<p>上述结论的一个显然推论是幂级数是收敛域上的连续函数(因为在收敛域上都是一致连续的).</p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(R =
1\)</span>,既然有一致连续性,若<span class="math inline">\(\sum
a_n\)</span>收敛,则极限存在有<span class="math inline">\(\lim_{ x \to 1
- 0 } f ( x ) = f ( 1 ) = \sum
a_n\)</span>.然而这个结论反过来不成立,例如<span class="math inline">\(f
( x ) = \sum ( - x )^n = \frac{ 1 }{ 1 + x
}\)</span>,容易见到极限为<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>可是<span class="math inline">\(f ( 1 )\)</span>并不收敛.</p>
<p>上述结论能不能加点条件使得反之成立呢?我们下面证明若<span class="math inline">\(a_n = o ( \frac{ 1 }{ n } )\)</span>,若<span class="math inline">\(\lim_{ x \to 1 - 0 } f ( x ) =
S\)</span>存在,则<span class="math inline">\(\sum a_n = S\)</span>.</p>
<p>考虑取<span class="math inline">\(\sigma_n = \frac{ 1 }{ n } \sum_{ k
= 0 }^n k | a_k |\)</span>,由Stolz定理知道<span class="math inline">\(\lim \sigma_n = \lim n | a_n | =
0\)</span>.取<span class="math inline">\(S_n = \sum_{ k = 1 }^n
a_k\)</span>,我们要证明的就是当<span class="math inline">\(n \to
\inf\)</span>的时候<span class="math inline">\(| S - S_n
|\)</span>尽可能小.当<span class="math inline">\(x \in ( - 1 , 1
)\)</span>的时候,注意到:</p>
$$
<span class="math display">\[\begin{aligned}
S_n - S &amp; = f ( x ) - S - \sum_{ k = n + 1 }^\infty a_k x^k + \sum_{
k = 0 }^n a_k ( 1 - x^k ) \\
&amp; = f ( x ) - S - \sum_{ k = n + 1 }^\infty a_k x^k + \sum_{ k = 0
}^n a_k ( 1 - x ) ( 1 + x + \cdots + x^{ k - 1 } ) \\
&amp; \leq f ( x ) - S - \sum_{ k = n + 1 }^\infty a_k x^k + ( 1 - x )
\sum_{ k = 0 }^n ka_k \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math inline">\(\forall \epsilon &gt;
0\)</span>,取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\sigma_n &lt; \frac{ \epsilon }{ 3
}\)</span>而且使得<span class="math inline">\(| na_n | &lt; \frac{
\epsilon }{ 3 }\)</span>总成立,那么:</p>
<p><span class="math display">\[
| S_n - S | \leq | f ( x ) - S | + ( 1 - x ) n \sigma_n + \frac{
\epsilon }{ 3 n } \frac{ x^{ n + 1 } }{ 1 - x }
\]</span></p>
<p>取<span class="math inline">\(x = 1 - \frac{ 1 }{ n
}\)</span>,即可得证.</p>
<p>如果加点单调性也可以.设<span class="math inline">\(a_n &gt;
0\)</span>,如果<span class="math inline">\(f ( x ) = \sum_n a_n
x^n\)</span>满足<span class="math inline">\(f ( 1 -
)\)</span>存在,则<span class="math inline">\(\sum a_n = f ( 1 -
)\)</span>.</p>
<p>这个结论与之前的一致收敛那里的单调性质完全相似.首先由<span class="math inline">\(\sum_n a_n \leq f ( 1 -
)\)</span>得到这个级数收敛,然后又可以放到<span class="math inline">\(\sum a_n x^n \leq \sum_n
a_n\)</span>,让左边趋近一下得到<span class="math inline">\(f ( 1 - )
\leq \sum_n a_n\)</span>.</p>
<h5><span id="柯西和">柯西和</span></h5>
<p>设<span class="math inline">\(\sum a_n = A , \sum b_n =
B\)</span>,设<span class="math inline">\(c_n = \sum_{ k = 0 }^n a_{ n -
k } b_k\)</span>,我们下面证明若<span class="math inline">\(\sum
c_n\)</span>收敛,则<span class="math inline">\(\sum c_n =
AB\)</span>.</p>
<p>考虑设<span class="math inline">\(f ( x ) = \sum a_n x^n , g ( x ) =
\sum b_n x^n\)</span>,则其收敛半径肯定<span class="math inline">\(\geq
1\)</span>,既然如此在任何内闭区间<span class="math inline">\([ - r , r ]
\subseteq ( - 1 , 1 )\)</span>,<span class="math inline">\(f ,
g\)</span>都在<span class="math inline">\([ - r , r
]\)</span>上绝对一致收敛,既然如此我们就可以把这个乘积随便打乱顺序,得到<span class="math inline">\(f ( x ) g ( x ) = \sum c_n x^n , \forall x \in [ -
r , r ]\)</span>.而我们又有<span class="math inline">\(\sum
c_n\)</span>收敛,既然如此<span class="math inline">\(\sum c_n = h ( 1 )
= \lim_{ x \to 1 - 0 } h ( x ) = ( \lim_{ x \to 1 - 0 } f ( x ) ) (
\lim_{ x \to 1 - 0 } g ( x ) ) = AB\)</span>,则搞定.</p>
<p>其中<span class="math inline">\(\sum
c_n\)</span>收敛这个条件是必须的,如果去掉后结论不成立,有如下反例:</p>
<p>设<span class="math inline">\(a_n = b_n\)</span>考虑对<span class="math inline">\(( 1 + x )^{ - \frac{ 1 }{ 2 }
}\)</span>做泰勒展开,得到<span class="math inline">\(f ( x ) = g ( x ) =
\sum a_n x^n = \frac{ 1 }{ \sqrt{ 1 + x } }\)</span>此时<span class="math inline">\(f ( 1 ) , g ( 1 )\)</span>都收敛,原因是<span class="math inline">\(a_n = ( - 1 )^n \frac{ ( 2 n - 1 ) ! ! }{ 2^n n !
}\)</span>,用DA判法知道其收敛.然而<span class="math inline">\(f ( x ) g
( x ) = \frac{ 1 }{ 1 + x }\)</span>,<span class="math inline">\(c_n = (
- 1 )^n\)</span>,因此<span class="math inline">\(\sum
c_n\)</span>不收敛,这就完蛋了.</p>
<h5><span id="逐项微积分">逐项微积分</span></h5>
<p>既然幂级数在收敛域上一致收敛,那当然可以逐项积分.而且注意到<span class="math inline">\(\varlimsup \sqrt[n + 1]{ \frac{ | a_n | }{ n + 1 }
} = \varlimsup \sqrt[n]{ | a_n | }\)</span>,原因是<span class="math inline">\(\lim \sqrt[n]{ n } =
1\)</span>,因此收敛半径不变,然而积分后,端点处有可能被包含入收敛域,原因是DA判法,原本的<span class="math inline">\(a_n x^n\)</span>之和如果有界,配了一个多的下降<span class="math inline">\(\frac{ 1 }{ n }\)</span>就会收敛,例如<span class="math inline">\(\sum \frac{ x^n }{ n }\)</span>.</p>
<p>同理,对于逐项求导也可以发现收敛半径不变.所以幂级数可以在收敛域上逐项积分任意多次,也可以在收敛区间内逐项求导任意多次.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 0 }^\infty \frac{ ( - 1 )^n
}{ 3 n + 1 }\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
f ( x ) &amp; = \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n }{ 3 n + 1 } x^{
3 n + 1 } \\
&amp; = \sum_{ n = 0 }^\infty \int_0^x ( - 1 )^n t^{ 3 n } \mathrm{ d }
t \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们想让这里的求和和积分交换顺序对吧!那首先得规定<span class="math inline">\(x \in ( - 1 , 1 )\)</span>而取不到<span class="math inline">\(1\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = \sum_{ n = 0 }^\infty \int_0^x ( - 1 )^n t^{ 3 n }
\mathrm{ d } t \\
&amp; = \int_0^x \sum_{ n = 0 }^\infty ( - t )^{ 3 n } \mathrm{ d } t \\
&amp; = \int_0^x \frac{ \mathrm{ d } t }{ 1 + t^3 }
\end{aligned}
\]</span></p>
<p>后面那个可以积出来,而且<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(( - 1 , 1
)\)</span>上取值就是如此.而发现<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(1\)</span>处收敛,因此拿这个积出来的结果极限逼近一下就行.</p>
<h5><span id="泰勒级数">泰勒级数</span></h5>
<p>对于一个<span class="math inline">\(f \in
C^\infty\)</span>,考虑泰勒展开有:</p>
<p><span class="math display">\[
f ( x ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } ( x - x_0
)^k + r_n ( x )
\]</span></p>
<p>其中依照拉格朗日余项,<span class="math inline">\(r_n ( x ) = \frac{
f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! } ( x - x_0 )^{ n + 1
}\)</span>,若存在<span class="math inline">\(\delta &gt;
0\)</span>,当<span class="math inline">\(x \in ( x_0 - \delta , x_0 +
\delta )\)</span>的时候,<span class="math inline">\(\lim_{ n \to \infty
} r_n = 0\)</span>,则称该函数在<span class="math inline">\(x_0\)</span>处解析,也就是可以用泰勒级数逼近它.</p>
<p>我们有一个命题:如果<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(x_0\)</span>处解析,则其在<span class="math inline">\(x_0\)</span>附近的一个小邻域上解析(证明可以参考Example15).因此解析的概念以拓宽到区间上,如果其在一个开区间<span class="math inline">\(I\)</span>上解析,则称其<span class="math inline">\(\in C^\omega ( I )\)</span>.</p>
<p>而且我们还可以见到,如果<span class="math inline">\(f^{ ( n ) } ( x
)\)</span>一致有界(或者至少与<span class="math inline">\(n\)</span>无关),则由于<span class="math inline">\(( x - x_0 )^n\)</span>会被<span class="math inline">\(\frac{ 1 }{ ( n + 1 ) !
}\)</span>控制住,所以其在<span class="math inline">\(\mathbb{ R
}\)</span>上都是解析的.所以<span class="math inline">\(\sin x , \cos
x\)</span>都是解析的,另外<span class="math inline">\(e^x , \ln
x\)</span>的导数大小与<span class="math inline">\(n\)</span>无关,所以也解析.</p>
<p>当<span class="math inline">\(f , g\)</span>在<span class="math inline">\(x_0\)</span>处解析的时候,应当有<span class="math inline">\(f \pm g , fg , \frac{ f }{ g
}\)</span>都是解析的.而且如果<span class="math inline">\(f\)</span>在<span class="math inline">\(g ( x_0
)\)</span>处解析,则<span class="math inline">\(f ( g ( x )
)\)</span>也在<span class="math inline">\(x_0\)</span>处解析.这个太难算了,我们承认这个事实好了,反正就是硬算.</p>
<h6><span id="example1广义二项式定理">Example1(广义二项式定理)</span></h6>
<p>求<span class="math inline">\(f ( x ) = ( 1 + x
)^\alpha\)</span>在<span class="math inline">\(0\)</span>处的解析性.</p>
<p>也就是要证明<span class="math inline">\(f ( x ) = ( 1 + x )^\alpha =
\sum_{ n = 0 }^\infty \frac{ \alpha^{ \underline{ n } } }{ n ! }
x^n\)</span>.</p>
<p>用比值法,观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \frac{ \binom{ \alpha }{ n } }{ \binom{ \alpha }{ n + 1 } } | \\
= &amp; | \frac{ n + 1 }{ \alpha - n } | \to 1
\end{aligned}
\]</span></p>
<p>所以右端收敛半径为<span class="math inline">\(1\)</span>.既然如此先搞定右端那个幂级数,设<span class="math inline">\(g ( x ) = \sum_{ n = 0 }^\infty \binom{ \alpha }{
n } x^n , x \in ( - 1 , 1 )\)</span>.观察到:</p>
<p><span class="math display">\[
\begin{aligned}
g &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty n \binom{ \alpha }{ n } x^{
n - 1 } \\
( 1 + x ) g &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty n \binom{ \alpha
}{ n } x^{ n - 1 } + \sum_{ n = 1 }^\infty n \binom{ \alpha }{ n } x^{ n
} \\
&amp; = \alpha + \sum_{ n = 1 }^\infty \left ( n \binom{ \alpha }{ n } +
( n + 1 ) \binom{ \alpha }{ n + 1 } \right ) x^n \\
&amp; = \alpha + \alpha \sum_{ n = 1 }^\infty \binom{ \alpha }{ n } x^n
\\
&amp; = \alpha g
\end{aligned}
\]</span></p>
<p>此时见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \left ( \frac{ g }{ ( 1 + x )^\alpha } \right ) &#39; \\
= &amp; - \alpha ( 1 + x )^{ - \alpha - 1 } g + ( 1 + x )^{ - \alpha } g
&#39; \\
= &amp; ( 1 + x )^{ - \alpha - 1 } ( - \alpha g + ( 1 + x ) g &#39; )
\equiv 0
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(\frac{ g }{ ( 1 + x )^\alpha
}\)</span>是一常数,演算<span class="math inline">\(x =
0\)</span>的部分就可以知道当<span class="math inline">\(x \in ( - 1 , 1
)\)</span>的时候它俩相等.</p>
<p>最后再补一下端点,</p>
<p>当<span class="math inline">\(\alpha &gt; 0 , x = \pm
1\)</span>的时候,下面直接证明它绝对收敛,也就是证明<span class="math inline">\(\sum | \binom{ \alpha }{ n } | &lt;
\inf\)</span>.,考虑拉贝判法:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; n \left ( \frac{ | \binom{ \alpha }{ n } | }{ | \binom{ \alpha }{
n + 1 } | } - 1 \right ) \\
= &amp; n ( \frac{ n + 1 }{ n - \alpha } - 1 ) \to 1 + \alpha &gt; 0
\end{aligned}
\]</span></p>
<p>所以此时收敛域是<span class="math inline">\([ - 1 , 1 ]\)</span>.</p>
<p>当<span class="math inline">\(- 1 &lt; \alpha &lt;
0\)</span>的时候,估一下发现:</p>
<p><span class="math display">\[
\begin{aligned}
| \binom{ \alpha }{ n } | &amp; = | ( 1 - \frac{ \alpha + 1 }{ 1 } )
\cdots ( 1 - \frac{ \alpha + 1 }{ n } ) | \\
&amp; = e^{ \sum_k \ln | 1 - \frac{ 1 + \alpha }{ k } | } \\
&amp; \approx e^{ - \sum_k \frac{ 1 + \alpha }{ k } } \\
&amp; \approx \frac{ 1 }{ n^{ 1 + \alpha } }
\end{aligned}
\]</span></p>
<p>而且此时<span class="math inline">\(\binom{ \alpha }{ n
}\)</span>本身是个交错级数,所以在<span class="math inline">\(-
1\)</span>处不收敛而在<span class="math inline">\(1\)</span>处收敛.同理当<span class="math inline">\(\alpha \leq - 1\)</span>的时候,<span class="math inline">\(| \binom{ \alpha }{ n } |\)</span>并不趋向于<span class="math inline">\(0\)</span>所以两端都不收敛.</p>
<h6><span id="example2反三角函数">Example2(反三角函数)</span></h6>
<p>考虑由Example1,当<span class="math inline">\(| x | &lt;
1\)</span>的时候:</p>
<p><span class="math display">\[
( 1 - x^2 )^{ - \frac{ 1 }{ 2 } } = 1 + \sum_{ n = 1 }^\infty \frac{ ( 2
n - 1 ) ! ! }{ ( 2 n ) ! ! } x^{ 2 n }
\]</span></p>
<p>两遍逐项积分,有:</p>
<p><span class="math display">\[
\arcsin x = x + \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{ ( 2 n )
! ! } \frac{ x^{ 2 n + 1 } }{ 2 n + 1 }
\]</span></p>
<p>继续用拉贝判别法,注意到:</p>
<p><span class="math display">\[
n \left ( \frac{ a_n }{ a_{ n + 1 } } - 1 \right ) \to \frac{ 3 }{ 2 }
\]</span></p>
<p>所以收敛.而且还可以发现这一下积分使得端点处也搞定了,所以上式对<span class="math inline">\([ - 1 , 1 ]\)</span>都成立.</p>
<h6><span id="example3平方倒数和">Example3(平方倒数和)</span></h6>
<p>还可再整点活,令<span class="math inline">\(x = \sin
t\)</span>带入上式,得到:</p>
$$
<span class="math display">\[\begin{aligned}
t &amp; = \sin t + \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{ ( 2 n
) ! ! } \frac{ \sin^{ 2 n + 1 } t }{ 2 n + 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两遍在<span class="math inline">\([ 0 , \frac{ \pi }{ 2 }
]\)</span>上积分,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ \pi^2 }{ 8 } &amp; = 1 + \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 )
! ! }{ ( 2 n ) ! ! ( 2 n + 1 ) } \frac{ ( 2 n ) ! ! }{ ( 2 n + 1 ) ! ! }
\\
&amp; = 1 + \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n + 1 )^2 } \\
&amp; = \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n - 1 )^2 }
\end{aligned}
\]</span></p>
<p>所以奇数的平方和是<span class="math inline">\(\frac{ \pi^2 }{ 8
}\)</span>,那么:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } &amp; = \frac{ \pi^2 }{ 8 } +
\frac{ 1 }{ 4 } \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } \\
\sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } &amp; = \frac{ \pi^2 }{ 6 }
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>当<span class="math inline">\(c &gt;
0\)</span>的时候,求证存在多项式列<span class="math inline">\(\{ P_n ( x
) \} \rightrightarrows | x | , x \in [ - c , c ]\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| x | &amp; = ( x^2 )^{ \frac{ 1 }{ 2 } } \\
&amp; = ( c^2 - ( c^2 - x^2 ) )^{ \frac{ 1 }{ 2 } } \\
&amp; = c ( 1 - \left ( 1 - \frac{ x^2 }{ c^2 } \right ) )^{ \frac{ 1 }{
2 } }
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(1 - \frac{ x^2 }{ c^2 } \in [ 0 , 1 ]
, \frac{ 1 }{ 2 } &gt; 0\)</span>,只需要对此用广义二项式定理即可.</p>
<h6><span id="example5">Example5</span></h6>
<p>求<span class="math inline">\(\int_0^\pi \frac{ \ln ( 1 + a \cos x )
}{ \cos x } \mathrm{ d } x\)</span>.</p>
<p>对着上面那个<span class="math inline">\(\ln\)</span>做泰勒级数,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_0^\pi \frac{ \ln ( 1 + a \cos x ) }{ \cos x } \mathrm{ d } x
\\
= &amp; \int_0^\pi a + \sum_{ n = 1 }^\infty ( - 1 )^n \frac{ a^{ n + 1
} \cos^n x }{ n + 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>而回忆到<span class="math inline">\(\int_0^\pi \cos^m x \mathrm{ d }
x\)</span>在<span class="math inline">\(m\)</span>是奇数的时候当然为<span class="math inline">\(0\)</span>,偶数的时候转化为<span class="math inline">\(\sin x\)</span>,答案是<span class="math inline">\(\frac{ ( m - 1 ) ! ! }{ m ! ! } \pi\)</span>.</p>
<p>所以原式变成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^\pi a + \sum_{ n = 1 }^\infty ( - 1 )^n \frac{ a^{ n + 1 }
\cos^n x }{ n + 1 } \\
= &amp; \pi ( a + \sum_{ m = 1 }^\infty \frac{ ( 2 m - 1 ) ! ! }{ ( 2 m
) ! ! } \frac{ a^{ 2 m + 1 } }{ 2 m + 1 } ) \\
= &amp; \pi \arcsin a
\end{aligned}
\]</span></p>
<h6><span id="example6">Example6</span></h6>
<p>求<span class="math inline">\(S = \sum_{ n = 0 }^\infty \frac{ ( - 1
)^n ( n + 1 )^3 }{ n ! }\)</span>.</p>
<p>见到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n ( n + 1 )^3 }{ n ! } e^{ (
n + 1 ) x } \\
= &amp; \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n }{ n ! } ( e^{ ( n + 1 )
x } ) &#39; &#39; &#39; \\

\end{aligned}\]</span>
<p>$$</p>
<p>取<span class="math inline">\(f ( x ) = \sum_{ n = 0 }^\infty \frac{
( - 1 )^n }{ n ! } e^{ ( n + 1 ) x }\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n }{ n ! } e^{ ( n
+ 1 ) x } \\
&amp; = e^x \sum_{ n = 0 }^\infty \frac{ ( - e^x )^n }{ n ! } \\
&amp; = e^{ x - e^x }
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; &amp; = ( 1 - e^x ) f \\
f &#39; &#39; &amp; = ( 1 - 3 e^x + e^{ 2 x } ) f \\
f &#39; &#39; &#39; &amp; = ( - 3 e^x + 2 e^{ 2 x } ) f + ( 1 - e^x ) (
1 - 3 e^x + e^{ 2 x } ) f \\
f &#39; &#39; &#39; ( 0 ) &amp; = - f ( 0 ) = - \frac{ 1 }{ e }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h6><span id="example7">Example7</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 1 }^\infty \frac{ \cos ( nx
) }{ n }\)</span>.</p>
<p>取<span class="math inline">\(t \in ( - 1 , 1 ]\)</span>,设:</p>
$$
<span class="math display">\[\begin{aligned}
f ( t ) &amp; = \sum_{ n = 1 }^\infty \frac{ \cos ( nx ) }{ n } t^n \\
f &#39; &amp; = \sum_{ n = 1 }^\infty \cos ( nx ) t^{ n - 1 } \\
&amp; = \Re \sum_{ n = 1 }^\infty t^{ n - 1 } e^{ inx } \\
&amp; = \Re \frac{ e^{ ix } }{ 1 - te^{ ix } } \\
&amp; = \Re \frac{ \cos x + i \sin x }{ 1 - t \cos x - it \sin x } \\
&amp; = \Re \frac{ ( \cos x + i \sin x ) ( 1 - t \cos x + it \sin x ) }{
( 1 - t \cos x )^2 + t^2 \sin^2 x } \\
&amp; = \frac{ \cos x ( 1 - t \cos x ) - t \sin^2 x }{ ( 1 - t \cos x
)^2 + t^2 \sin^2 x } \\
&amp; = \frac{ \cos x - t }{ 1 - 2 t \cos x + t^2 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时应当有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( t ) &amp; = f ( 0 ) + \int_0^t f &#39; ( t ) \mathrm{ d } t \\
&amp; = - \frac{ 1 }{ 2 } \ln ( 1 - 2 t \cos x + t^2 )
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(f ( 1 ) = - \ln 2 - \ln | \sin \frac{ x
}{ 2 } |\)</span>,这就求出了原式.</p>
<h6><span id="example8">Example8</span></h6>
<p>考虑<span class="math inline">\(\zeta ( x ) = \sum_{ n = 1 }^\infty
\frac{ 1 }{ n^x }\)</span>,有定理说:</p>
<p><span class="math display">\[
\zeta ( x ) = \frac{ 1 }{ x - 1 } + \sum_{ n = 0 }^\infty \frac{ ( - 1
)^n \gamma_n }{ n ! } ( x - 1 )^n
\]</span></p>
<p>其中后半部分是整个复平面上的解析函数,并有:</p>
<p><span class="math display">\[
\gamma_n = \lim_{ m \to \infty } \left ( \sum_{ k = 1 }^m \frac{ ( \ln k
)^n }{ k } - \frac{ ( \ln m )^{ n + 1 } }{ n + 1 } \right )
\]</span></p>
<h6><span id="example9">Example9</span></h6>
<p>求<span class="math inline">\(S ( x ) = 1 + \sum_{ n = 1 }^\infty
\frac{ ( 2 n - 1 ) ! ! }{ ( 2 n ) ! ! } x^n\)</span>,其中<span class="math inline">\(| x | &lt; 1\)</span>.</p>
<p>容易见到其收敛半径是<span class="math inline">\(1\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S &#39; ( x ) &amp; = \frac{ 1 }{ 2 } + \sum_{ n = 1 }^\infty \frac{ ( 2
n + 1 ) ! ! }{ ( 2 n + 2 ) ! ! } ( n + 1 ) x^n \\
2 S &#39; ( x ) &amp; = 1 + \sum_{ n = 1 }^\infty \frac{ ( 2 n + 1 ) ! !
}{ ( 2 n ) ! ! } x^{ n } \\
2 xS &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{
( 2 n - 2 ) ! ! } x^n \\
2 xS &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{
( 2 n ) ! ! } 2 nx^n \\
2 S &#39; ( x ) - 2 xS &#39; ( x ) &amp; = S ( x ) \\
\frac{ \mathrm{ d } x }{ 2 ( 1 - x ) } &amp; = \frac{ \mathrm{ d } S ( x
) }{ S ( x ) } \\
- \frac{ 1 }{ 2 } \ln ( 1 - x ) &amp; = \ln S ( x ) \\
S ( x ) &amp; = \frac{ 1 }{ \sqrt{ 1 - x } }
\end{aligned}
\]</span></p>
<h6><span id="example10">Example10</span></h6>
<p>当<span class="math inline">\(| x | &lt; 1\)</span>,求<span class="math inline">\(S ( x ) = \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n
x^n }{ 2 n + 1 }\)</span>.</p>
<p>容易见到收敛半径为<span class="math inline">\(1\)</span>,令<span class="math inline">\(x = t^2\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
S ( t^2 ) = \sum_{ n = 0 }^\infty ( - 1 )^n \frac{ 1 }{ t } \int_0^t u^{
2 n } \mathrm{ d } u \\
= \frac{ 1 }{ t } \int_0^t \sum_{ n = 0 }^\infty ( - 1 )^n u^{ 2 n }
\mathrm{ d } u \\
= \frac{ 1 }{ t } \int_0^t \frac{ \mathrm{ d } u }{ 1 + u^2 } \\
= \frac{ \arctan t }{ t } \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以<span class="math inline">\(S ( x ) = \frac{ \arctan \sqrt{ x }
}{ \sqrt{ x } }\)</span>.</p>
<h6><span id="example11">Example11</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 2 }^\infty \frac{ ( - 1 )^n
}{ n^2 + n - 2 }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
S ( x ) = \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{ n - 1 } }{ n^2 + n
- 2 } \\
= \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{ n - 1 } }{ 3 } \left (
\frac{ 1 }{ n - 1 } - \frac{ 1 }{ n + 2 } \right ) \\
= \frac{ 1 }{ 3 } \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{ n - 1 } }{
n - 1 } - \frac{ 1 }{ 3 x^3 } \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{
n + 2 } }{ n + 2 } \\
= \frac{ 1 }{ 3 } \ln ( 1 + x ) - \frac{ 1 }{ 3 x^3 } \left ( - \ln ( 1
+ x ) + x - \frac{ x^2 }{ 2 } + \frac{ x^3 }{ 3 } \right )
\end{aligned}
\]</span></p>
<p>而注意到带入<span class="math inline">\(x = 1\)</span>的时候<span class="math inline">\(S ( x )\)</span>收敛,这就搞定了,带入<span class="math inline">\(x = 1\)</span>就行.</p>
<h6><span id="example12">Example12</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 1 }^\infty \frac{ n }{ ( n +
1 ) ! }\)</span>.</p>
<p>设<span class="math inline">\(S ( x ) = \sum_{ n = 0 }^\infty \frac{
( n + 1 ) x^n }{ ( n + 2 ) ! }\)</span>,显然收敛,直接逐项积分.</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^x S ( t ) \mathrm{ d } t &amp; = \sum_{ n = 0 }^\infty \frac{ x^{
n + 1 } }{ ( n + 2 ) ! } \\
&amp; = \sum_{ n = 1 }^\infty \frac{ x^{ n } }{ ( n + 1 ) ! } \\
x ( \int_0^x S ( t ) \mathrm{ d } t + 1 ) &amp; = e^x - 1 \\
S ( x ) &amp; = \left ( \frac{ e^x - 1 }{ x } \right ) &#39; = \frac{
xe^x - e^x + 1 }{ x^2 }
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h6><span id="example13">Example13</span></h6>
<p>求<span class="math inline">\(\int_0^\infty \frac{ x \mathrm{ d } x
}{ e^{ 2 \pi x } - 1 }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^\infty \frac{ x \mathrm{ d } x }{ e^{ 2 \pi x } - 1 } \\
= \int_0^\infty \frac{ xe^{ - 2 \pi x } \mathrm{ d } x }{ 1 - e^{ - 2
\pi x } } \\
= \int_0^{ \infty } xe^{ - 2 \pi x } \sum_{ n = 0 }^\infty e^{ - 2 \pi n
x } \mathrm{ d } x \\
= \sum_{ n = 0 }^\infty \int_0^{ + \infty } xe^{ - 2 \pi ( n + 1 ) x }
\mathrm{ d } x \\
= \sum_{ n = 0 }^\infty \frac{ 1 }{ - 2 \pi ( n + 1 ) } \int_0^{ +
\infty } x \mathrm{ d } e^{ - 2 \pi ( n + 1 ) x } \\
= \sum_{ n = 0 }^\infty \frac{ 1 }{ 2 \pi ( n + 1 ) } \int_0^{ + \infty
} e^{ - 2 \pi ( n + 1 ) x } \mathrm{ d } x \\
= \sum_{ n = 0 }^\infty \frac{ 1 }{ 4 \pi^2 ( n + 1 )^2 } \\
= \frac{ 1 }{ 24 }
\end{aligned}
\]</span></p>
<p>其中中间的交换积分号和求和号是源于所有的部分和都可以小于等于<span class="math inline">\(g ( x )\)</span>,并且<span class="math inline">\(\int_0^{ \infty } g\)</span>收敛.</p>
<h6><span id="example14">Example14</span></h6>
<p>求<span class="math inline">\(\int_0^1 \frac{ \ln ( 1 + x ) }{ x }
\mathrm{ d } x\)</span>.</p>
<p>直接展开对吧,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^1 \frac{ \ln ( 1 + x ) }{ x } \mathrm{ d } x \\
= &amp; \int_0^1 \sum_{ n = 1 }^\infty \frac{ ( - 1 )^{ n - 1 } x^{ n -
1 } }{ n } \\
= &amp; \sum_{ n = 1 }^\infty \int_0^1 \frac{ ( - 1 )^{ n - 1 } x^{ n -
1 } }{ n } \mathrm{ d } x \\
= &amp; \sum_{ n = 1 }^\infty \frac{ ( - 1 )^{ n - 1 } }{ n^2 } \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n - 1 )^2 } - \sum_{ n = 1
}^\infty \frac{ 1 }{ ( 2 n )^2 } \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } - 2 \sum_{ n = 1
}^\infty \frac{ 1 }{ ( 2 n )^2 } \\
= &amp; \frac{ 1 }{ 2 } \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } \\
= &amp; \frac{ \pi^2 }{ 12 }
\end{aligned}
\]</span></p>
<h6><span id="example15">Example15</span></h6>
<p>设<span class="math inline">\(I\)</span>是开区间,<span class="math inline">\(f \in C^\infty ( I )\)</span>,求证<span class="math inline">\(f \in C^\omega ( I )\)</span>当且仅当<span class="math inline">\(\forall x_0 \in I , \exists M , B , r &gt;
0\)</span>,使得<span class="math inline">\(\forall | x - x_0 | &lt; r ,
| f^{ ( n ) } ( x ) | \leq MB^n n
!\)</span>.就是说对于区间内任何一个点,在它的小邻域处,任意阶导数都可以被和<span class="math inline">\(n\)</span>有关的一个速率控制住.</p>
<p>充分性比较简单,考虑取<span class="math inline">\(S ( x ) = \sum
\frac{ f^{ ( n ) } ( x_0 ) }{ n ! } ( x - x_0 )^n\)</span>对其取<span class="math inline">\(| \sqrt[n]{ \frac{ f^{ ( n ) } ( x_0 ) }{ n ! } }
| \leq \sqrt[n]{ MB^n } = \sqrt[n]{ M } B &lt; +
\infty\)</span>,所以总之收敛半径不为<span class="math inline">\(0\)</span>.那就总能取一个足够小的<span class="math inline">\(r &lt; \frac{ 1 }{ B
}\)</span>.此时用泰勒展开的拉格朗日余项:</p>
<p><span class="math display">\[
\begin{aligned}
\left | f ( x ) - \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } (
x - x_0 )^k \right | &amp; = \left | \frac{ f^{ ( n + 1 ) } ( \xi ) }{ (
n + 1 ) ! } ( x - x_0 )^{ n + 1 } \right | \\
&amp; \leq | B^{ n + 1 } ( x - x_0 )^{ n + 1 } M | \\
&amp; \leq | ( Br )^{ n + 1 } M | \to 0
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>接下来是必要性.考虑<span class="math inline">\(\varlimsup_{ n \to
\infty } \sqrt[n]{ | \frac{ f^{ ( n ) } ( x_0 ) | }{ n ! } } = \frac{ 1
}{ R } &gt; 0\)</span>,那就可以取<span class="math inline">\(0 &lt; r
&lt; M &lt; R\)</span>,存在一个<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n \geq N\)</span>都有<span class="math inline">\(| f^{ ( n ) } ( x_0 ) |
\leq n ! ( \frac{ 1 }{ M } )^n\)</span>.</p>
<p>接下来想要把这个性质挪到<span class="math inline">\(x_0\)</span>周围小邻域上对吧.于此我们考虑先逼近后逐项求导:</p>
<p><span class="math display">\[
\begin{aligned}
| f^{ ( n ) } ( x ) | &amp; = | \sum_{ k = 0 }^\infty \frac{ f^{ ( n + k
) } ( x_0 ) }{ k ! } ( x - x_0 )^k | \\
&amp; \leq \sum_{ k = 0 }^\infty \frac{ | f^{ ( n + k ) } ( x_0 ) | }{ k
! } | x - x_0 |^k \\
&amp; \leq \sum_{ k = 0 }^\infty \frac{ ( n + k ) ! }{ k ! M^{ n + k } }
r^k \\
&amp; = \frac{ n ! }{ M^n } \sum_{ k = 0 }^\infty \frac{ ( n + k )^{
\underline{ k } } }{ k ! } ( \frac{ r }{ M } )^k \\
&amp; = \frac{ n ! }{ M^n } \sum_{ k = 0 }^\infty \frac{ ( - n - 1 )^{
\underline{ k } } }{ k ! } ( \frac{ - r }{ M } )^k \\
&amp; = \frac{ n ! }{ M^n } ( 1 - \frac{ r }{ M } )^{ - n - 1 } \\
&amp; = Mn ! ( M - r )^{ - ( n + 1 ) }
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h6><span id="example16">Example16</span></h6>
<p>若非常数<span class="math inline">\(f\)</span>在<span class="math inline">\(( a , b )\)</span>的每一点都解析,则其零点集在<span class="math inline">\(( a , b )\)</span>内无聚点.</p>
<p>考虑如果一个点<span class="math inline">\(c \in ( a , b
)\)</span>是<span class="math inline">\(f\)</span>的聚点的话,那么<span class="math inline">\(c\)</span>一定是<span class="math inline">\(f\)</span>的任意阶导数的聚点.由于任意阶导数都是连续的,因此<span class="math inline">\(c\)</span>处的任意阶导数都是<span class="math inline">\(0\)</span>.又因为<span class="math inline">\(f\)</span>解析,所以<span class="math inline">\(c\)</span>周围的一个小邻域必然全部为<span class="math inline">\(0\)</span>.既如此取最长的小邻域为<span class="math inline">\(( \alpha , \beta )\)</span>,下面我们证明<span class="math inline">\(( \alpha , \beta ) = ( a , b
)\)</span>,不妨假设<span class="math inline">\(a \ne
\alpha\)</span>,由于连续性得知<span class="math inline">\(f\)</span>在<span class="math inline">\([ \alpha ,
\beta )\)</span>上取值为<span class="math inline">\(0\)</span>,然而这意味着<span class="math inline">\(\alpha\)</span>必然也是零点集的聚点,因此它还可以继续往左延申一个小邻域,这就与<span class="math inline">\(a\)</span>是最靠左的矛盾了.</p>
<p>不过这个做法不能推广到复平面上,原因是平面上的介值定理难搞一点啊.</p>
<p>提供另一种证明方法,考虑<span class="math inline">\(f\)</span>在<span class="math inline">\(( a , b )\)</span>上的零点的聚点<span class="math inline">\(x_0\)</span>,如果<span class="math inline">\(x_0\)</span>的任意阶导数都是<span class="math inline">\(0\)</span>的话,那还是按照上面一样往外面扩就行了对吧.反之,设<span class="math inline">\(f ( x_0 ) = f^{ ( 1 ) } ( x_0 ) = \cdots = f^{ ( N
- 1 ) } ( x_0 ) = 0 , f^{ ( N ) } ( x_0 ) \ne 0\)</span>,此时考虑<span class="math inline">\(f ( x ) = ( x - x_0 )^{ N + 1 } \sum_{ n = 0
}^\infty \frac{ f^{ ( N + n + 1 ) } }{ ( N + n + 1 ) ! } ( x - x_0
)^n\)</span>,不妨设<span class="math inline">\(g ( x ) = \sum_{ n = 0
}^\infty \frac{ f^{ ( N + n + 1 ) } }{ ( N + n + 1 ) ! } ( x - x_0
)^n\)</span>,容易发现<span class="math inline">\(g ( x_0 ) \ne
0\)</span>,既然如此,<span class="math inline">\(g\)</span>肯定在<span class="math inline">\(x_0\)</span>的一个小邻域(要与解析的那个邻域取交)上非<span class="math inline">\(0\)</span>,设为<span class="math inline">\(( x_0 -
\delta , x_0 + \delta )\)</span>上非零,可这样<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\((
x_0 - \delta , x_0 ) \cup ( x_0 , x_0 + \delta
)\)</span>上必然非零,这与<span class="math inline">\(x_0\)</span>是零点聚点矛盾了.</p>
<h5><span id="多项式逼近">多项式逼近</span></h5>
<p>如果对于函数<span class="math inline">\(f ( x ) : [ a , b ] \to
\mathbb{ R }\)</span>,存在一个多项式列可以一致收敛到<span class="math inline">\(f ( x
)\)</span>,则称其可以被多项式<strong>一致逼近</strong>.容易见到一个必要条件是<span class="math inline">\(f ( x ) \in C [ a , b ]\)</span>.</p>
<p>事实上我们有<strong>维尔斯特拉斯定理</strong>:有界闭区间上的连续函数可由多项式一致连续逼近.首先不妨假设<span class="math inline">\([ a , b ] = [ 0 , 1
]\)</span>.下面给出两种证明:</p>
<p>其一是构造性证明,我们有<strong>Bernstein多项式</strong>:</p>
<p><span class="math display">\[
B_n ( f ) = \sum_{ p = 0 }^n \binom{ n }{ p } f ( \frac{ p }{ n } ) x^p
( 1 - x )^{ n - p }
\]</span></p>
<p>这个多项式有很多性质,首先随便放缩一下就知道这个多项式在<span class="math inline">\([ 0 , 1 ]\)</span>上有界,更具体地有<span class="math inline">\(\min f \leq B_n \leq \max f\)</span>,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
B_n ( f ) &amp; \leq \sum_p \binom{ n }{ p } f ( \frac{ p }{ n } ) x^p (
1 - x )^{ n - p } \\
&amp; \leq ( \max f ) \sum_p \binom{ n }{ p } x^p ( 1 - x )^{ n - p } \\
&amp; = \max f
\end{aligned}
\]</span></p>
<p>另一边同理.</p>
<p>其次有<span class="math inline">\(\deg ( B_n ) \leq
n\)</span>.以及这个甚至是<span class="math inline">\(f\)</span>的线性映射,或言<span class="math inline">\(B_n ( \alpha f + \beta g ) = \alpha B_n ( f ) +
\beta B_n ( g )\)</span>.</p>
<p>取<span class="math inline">\(r_p ( x ) = \binom{ n }{ p } x^p ( 1 -
x )^{ n - p }\)</span>,注意到:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum_p r_p ( x ) =
1\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_p pr_p ( x ) =
nx\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_p p ( p - 1 ) r_p ( x ) = n ( n
- 1 ) x^2\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_p p^2 r_p ( x ) = n ( n - 1 )
x^2 + nx\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ p = 0 }^n ( p - nx )^2 r_p ( x
) \leq \frac{ n }{ 4 }\)</span>.</p></li>
</ol>
<p>前四条类似,以(3)为例,证明的话考虑对<span class="math inline">\(( x +
y )^n = \sum_p \binom{ n }{ p } x^p y^{ n - p }\)</span>两边对<span class="math inline">\(x\)</span>求两次导数:</p>
<p><span class="math display">\[
n ( n - 1 ) x^2 ( x + y )^{ n - 2 } = \sum_p^n \binom{ n }{ p } p ( p -
1 ) x^p y^{ n - p }
\]</span></p>
<p>带入<span class="math inline">\(y = 1 - x\)</span>即可.</p>
<p>(5)的话也只需要计算,观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ p = 0 }^n ( p - nx )^2 r_p ( x ) \\
= &amp; \sum_p p^2 r_p - 2 nx \sum_p pr_p + n^2 x^2 \sum r_p \\
= &amp; n ( n - 1 ) x^2 + nx - 2 n^2 x^2 + n^2 x^2 \\
= &amp; nx ( 1 - x ) \leq \frac{ n }{ 4 }
\end{aligned}
\]</span></p>
<p>我们见到:</p>
$$
<span class="math display">\[\begin{aligned}
| B_n ( f ) - f | &amp; = \left | \sum_{ p = 0 }^n \binom{ n }{ p } f (
\frac{ p }{ n } ) x^p ( 1 - x )^{ n - p } - \sum_{ p = 0 }^n \binom{ n
}{ p } f ( x ) x^p ( 1 - x )^{ n - p } \right | \\
&amp; \leq \sum_{ p = 0 }^n \binom{ n }{ p } | f ( \frac{ p }{ n } ) - f
( x ) | x^p ( 1 - x )^{ n - p } \\

\end{aligned}\]</span>
<p>$$</p>
<p>既然<span class="math inline">\(f ( x
)\)</span>闭区间上连续则有一致连续,<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,取<span class="math inline">\(\delta &gt;
0\)</span>,使得只要<span class="math inline">\(| x - x &#39; | &lt;
\delta , | f ( x ) - f ( x &#39; ) | &lt; \frac{ \epsilon }{ 2
}\)</span>,那有:</p>
<p><span class="math display">\[
\begin{aligned}
| B_n ( f ) - f | &amp; \leq \sum_{ p = 0 }^n \binom{ n }{ p } | f (
\frac{ p }{ n } ) - f ( x ) | x^p ( 1 - x )^{ n - p } \\
&amp; = \sum_{ | \frac{ p }{ n } - x | &lt; \delta }^n \binom{ n }{ p }
| f ( \frac{ p }{ n } ) - f ( x ) | x^p ( 1 - x )^{ n - p } + \sum_{ |
\frac{ p }{ n } - x | \geq \delta }^n \binom{ n }{ p } | f ( \frac{ p }{
n } ) - f ( x ) | x^p ( 1 - x )^{ n - p } \\
&amp; \leq \frac{ \epsilon }{ 2 } + \frac{ 2 \max | f | }{ n^2 \delta^2
} \sum_{ p = 0 }^n ( p - nx )^2 r_p ( x ) \\
&amp; \leq \frac{ \epsilon }{ 2 } + \frac{ \max | f | }{ 2 n \delta^2 }
\end{aligned}
\]</span></p>
<p>倒数第二步是由于当<span class="math inline">\(| \frac{ p }{ n } - x |
\geq \delta\)</span>,所以<span class="math inline">\(\frac{ ( p - nx )^2
}{ n^2 \delta^2 } \geq 1\)</span>.</p>
<p>最后一步是因为当<span class="math inline">\(\epsilon\)</span>确定的时候,<span class="math inline">\(\delta\)</span>就已经确定了,然而<span class="math inline">\(n\)</span>可以足够大,这就控制住了.</p>
<p>再给另一个存在性证明.回忆到<span class="math inline">\([ a , b
]\)</span>上的连续函数组成的集合<span class="math inline">\(C [ a , b
]\)</span>是一个完备线性空间.称<span class="math inline">\(A \subseteq C
[ a , b ]\)</span>是一个<strong>代数</strong>当且仅当<span class="math inline">\(\forall f , g \in A\)</span>,<span class="math inline">\(\forall c \in \mathbb{ R }\)</span>,<span class="math inline">\(f + g , fg , cf \in A\)</span>.容易见到如果<span class="math inline">\(P\)</span>是一个有限项多项式,<span class="math inline">\(f \in A\)</span>,则<span class="math inline">\(P (
f ) \in A\)</span>.</p>
<p>在此基础上定义<span class="math inline">\(\bar{ A }\)</span>为<span class="math inline">\(A\)</span>的<strong>闭包</strong>,定义为:</p>
<p><span class="math display">\[
\bar{ A } = \{ f \in C [ a , b ] | \exists \{ f_n \} \in A , f_n
\rightrightarrows f \}
\]</span></p>
<p>容易见到<span class="math inline">\(A \subseteq \bar{ A
}\)</span>.而且容易见到<span class="math inline">\(\bar{ A
}\)</span>肯定也是一个代数.而见到<span class="math inline">\(\overline{
( \bar{ A } ) } = \bar{ A
}\)</span>,原因是柯西列导出的已经是闭的了,无法再往外拓展.</p>
<p>回忆到绝对值函数可以由多项式函数逼近,所以如果<span class="math inline">\(f \in \bar{ A }\)</span>,则<span class="math inline">\(| f | \in \bar{ A }\)</span>.更进一步,如果<span class="math inline">\(f , g \in \bar{ A }\)</span>,由于<span class="math inline">\(\max ( f , g ) = \frac{ f + g }{ 2 } + \frac{ | f
- g | }{ 2 }\)</span>,所以<span class="math inline">\(\max ( f , g ) \in
\bar{ A }\)</span>,同理<span class="math inline">\(\min ( f , g ) \in
\bar{ A }\)</span>.</p>
<p>我们有一个定理说:设<span class="math inline">\(A \subseteq C [ a , b
]\)</span>是一个代数,并且<span class="math inline">\(f ( x ) = c \in
A\)</span>.并且<span class="math inline">\(\forall x , y \in [ a , b ] ,
x \ne y , \exists f \in A , f ( x ) \ne f ( y )\)</span>则<span class="math inline">\(\bar{ A } = C [ a , b
]\)</span>.容易见到这个定理强于维尔斯特拉斯定理.这个定理叫<strong>Stone-Weierstrass定理</strong>.</p>
<p>下面我们来证明这个结论.</p>
<p>先搞一个引理:<span class="math inline">\(\forall x_1 , x_2 \in [ a ,
b ] , x_1 \ne x_2 , \forall \alpha , \beta \in \mathbb{ R
}\)</span>,则<span class="math inline">\(\exists h \in A , h ( x_1 ) =
\alpha , h ( x_2 ) = \beta\)</span>.</p>
<p>证明的话,考虑由已知<span class="math inline">\(\exists \varphi \in A
, \varphi ( x_1 ) \ne \varphi ( x_2
)\)</span>.此时把这个函数给挪一下,取<span class="math inline">\(h ( x )
= \alpha + ( \beta - \alpha ) \frac{ \varphi ( x ) - \varphi ( x_1 ) }{
\varphi ( x_2 ) - \varphi ( x_1 )
}\)</span>.(其实这个应该是双传递性,但是我目前没看出如何用双传递性来解释证明过程.)</p>
<p>接下来考虑证明原定理,来证明<span class="math inline">\(\forall f \in
C [ a , b ] , \forall n , \exists g_n \in \bar{ A } , | f ( x ) - g_n (
x ) | &lt; \frac{ 1 }{ n }\)</span>,由于我们刚才的引理,<span class="math inline">\(\forall x , y \in [ a , b ] , \exists h_{ x , y }
( z ) \in A , h_{ x , y } ( x ) = f ( x ) , h_{ x , y } ( y ) = f ( y
)\)</span>.这个函数由<span class="math inline">\(x ,
y\)</span>所确定.</p>
<p>固定<span class="math inline">\(x\)</span>不动,对<span class="math inline">\(\forall y \in [ a , b ]\)</span>,<span class="math inline">\(\exists \delta = \delta ( y
)\)</span>,由于一致连续性,当<span class="math inline">\(z \in I_y = ( y
- \delta , y + \delta )\)</span>的时候,<span class="math inline">\(h_{ x
, y } ( z ) &lt; f ( z ) + \frac{ 1 }{ n }\)</span>.而这里的<span class="math inline">\(I_y\)</span>构成了一个开覆盖(边界上可能需要挪一下,但反正能做到),用有限覆盖定理拿到有限个区间<span class="math inline">\(I_{ y_1 , } , \cdots , I_{ y_m
}\)</span>覆盖了<span class="math inline">\([ a , b
]\)</span>.此时取<span class="math inline">\(h_x ( z ) = \min \{ h_{ x ,
y_1 } , \cdots , h_{ x , y_m } \}\)</span>,见到<span class="math inline">\(h_x ( z ) &lt; f ( z ) + \frac{ 1 }{ n } , \forall
z \in [ a , b ]\)</span>.而且<span class="math inline">\(h_x ( x ) = f (
x )\)</span>.</p>
<p>既然<span class="math inline">\(h_x ( x ) = f ( x
)\)</span>,考虑<span class="math inline">\(\exists \delta , I_x = ( x -
\delta , x + \delta )\)</span>使得<span class="math inline">\(h_x ( z )
&gt; f ( z ) - \frac{ 1 }{ n } , \forall z \in
I_x\)</span>.对此再做有限覆盖得到<span class="math inline">\(h_{ x_1 } ,
\cdots , h_{ x_l }\)</span>,取<span class="math inline">\(g_n = \max \{
h_{ x_1 } , \cdots , h_{ x_l } \}\)</span>.显然:</p>
<p><span class="math display">\[
f ( z ) - \frac{ 1 }{ n } &lt; g_n ( z ) &lt; f ( z ) + \frac{ 1 }{ n }
\]</span></p>
<p>搞定了.</p>
<p>那么,这个多项式能不能再来点限制呢?比如说我不许在多项式里出现<span class="math inline">\(x^2\)</span>项可以吗?也可以.考虑<span class="math inline">\(f \in C [ a , b ]\)</span>,则<span class="math inline">\(f ( x^{ \frac{ 1 }{ 3 } } ) \in C [ a^{ \frac{ 1
}{ 3 } } , b^{ \frac{ 1 }{ 3 } } ]\)</span>,所以存在一个多项式<span class="math inline">\(P ( x ) \rightrightarrows f ( x^{ \frac{ 1 }{ 3 }
} )\)</span>,意味着<span class="math inline">\(P ( x^3 )
\rightrightarrows f ( x ) , x \in [ a , b ]\)</span>.而<span class="math inline">\(P ( x^3 )\)</span>当然没有<span class="math inline">\(x^2\)</span>项.</p>
<p>也就是说这些多项式很多都是浪费的.那么有没有一个非常厉害的结论能告诉我什么样的多项式可以呢?考虑在<span class="math inline">\([ 0 , 1 ]\)</span>上,<span class="math inline">\(\mathrm{ Span } \{ 1 , x^{ \lambda_1 } , \cdots
\}\)</span>张成的多项式,其中<span class="math inline">\(0 &lt; \lambda_1
&lt; \lambda_2 &lt; \cdots\)</span>,其中<span class="math inline">\(\lambda_n \to \infty\)</span>.注意这里不要求<span class="math inline">\(\lambda_i\)</span>是整数,如果其闭包能张成<span class="math inline">\(C [ 0 , 1 ]\)</span>,当且仅当<span class="math inline">\(\sum \frac{ 1 }{ \lambda_i } = +
\infty\)</span>.这被称为<strong>Muntz定理</strong>,(其一个更强的推广是去掉<span class="math inline">\(\lambda_n \to
\infty\)</span>的结论,取而代之的是需要满足<span class="math inline">\(\sum \frac{ \lambda_i }{ 1 + \lambda_i^2 } = +
\infty\)</span>)</p>
<p>这个定理的必要性我们目前难以证明,先证明其充分性.</p>
<p>考虑<span class="math inline">\(\forall m \in \mathbb{ N }_+
\setminus \{ \lambda_i \}\)</span>,都可以定义一个函数列,其中<span class="math inline">\(Q_0 ( x ) = x^m , Q_n ( x ) = ( \lambda_n - m )
x^{ \lambda_n } \int_x^1 Q_{ n - 1 } ( t ) t^{ - 1 - \lambda_n }
\mathrm{ d } t\)</span>.我们先证明<span class="math inline">\(Q_n\)</span>一定长成<span class="math inline">\(x^m - \sum_{ i = 1 }^n a_{ n , i } x^{ \lambda_i
}\)</span>的形式.</p>
<p>数学归纳证明此结论,设<span class="math inline">\(Q_n = x^m - \sum_{ i
= 1 }^n a_{ n , i } x^{ \lambda_i }\)</span>,来看<span class="math inline">\(Q_{ n + 1 }\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
Q_{ n + 1 } ( x ) &amp; = ( \lambda_{ n + 1 } - m ) x^{ \lambda_{ n + 1
} } \int_x^1 Q_{ n } ( t ) t^{ - 1 - \lambda_{ n + 1 } } \mathrm{ d } t
\\
&amp; = ( \lambda_{ n + 1 } - m ) x^{ \lambda_{ n + 1 } } \int_x^1 ( t^m
- \sum_{ i = 1 }^n a_{ n , i } t^{ \lambda_i } ) t^{ - 1 - \lambda_{ n +
1 } } \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>后面那部分直接积出来就是了,然后前面有一个<span class="math inline">\(\lambda_{ n + 1 }\)</span>,这样就搞定了.</p>
<p>下面定义一个函数的模长<span class="math inline">\(\Vert Q \Vert =
\max_{ [ 0 , 1 ] } | Q ( x ) |\)</span>,此时:</p>
<p><span class="math display">\[
\begin{aligned}
| Q_n ( x ) | &amp; \leq | \lambda_n - m | x^{ \lambda_n } \Vert Q_{ n -
1 } \Vert \int_x^1 t^{ - 1 - \lambda_n } \mathrm{ d } t \\
&amp; = | \lambda_n - m | x^{ \lambda_n } \cdot \Vert Q_{ n - 1 } \Vert
\frac{ x^{ - \lambda_n } - 1 }{ \lambda_n } \\
&amp; = | 1 - \frac{ m }{ \lambda_n } | \cdot \Vert Q_{ n - 1 } \Vert (
1 - x^{ \lambda_n } ) \\
&amp; \leq | 1 - \frac{ m }{ \lambda_n } | \cdot \Vert Q_{ n - 1 } \Vert
\\
&amp; \leq \prod_{ i = 1 }^n | 1 - \frac{ m }{ \lambda_i } |
\end{aligned}
\]</span></p>
<p>然而回忆到<span class="math inline">\(\sum \frac{ 1 }{ \lambda_i
}\)</span>发散.所以后面那个连乘积必然发散,但是容易见到<span class="math inline">\(m\)</span>取死后,其从<span class="math inline">\(\lambda_i &gt;
m\)</span>的时候就是单调递减的,那又发散必然知道其趋近于<span class="math inline">\(0\)</span>.所以<span class="math inline">\(\lim
\Vert Q_n \Vert = 0\)</span>.那又回忆到<span class="math inline">\(Q_n =
x^m - \sum_{ i = 1 }^n a_{ n , i } x^{ \lambda_i
}\)</span>,这已经说明<span class="math inline">\(x^m\)</span>可以被<span class="math inline">\(\{ x^{ \lambda_i }
\}\)</span>一致逼近,原命题充分性搞定.</p>
<p>现在来看固定在<span class="math inline">\(\lambda_i \in \mathbb{ N
}_+\)</span>的情形,能否给出一个充要条件呢?我们下面证明对于互异的<span class="math inline">\(\{ \lambda_i \} \in \mathbb{ N }_+\)</span>,<span class="math inline">\(C [ a , b ] = \overline{ \mathrm{ span } } \{ x^{
\lambda_i } , 1 \}\)</span>的充要条件是:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(0 \notin ( a , b
)\)</span>,当<span class="math inline">\(\sum \frac{ 1 }{ \lambda_i } =
+ \infty\)</span>.</p></li>
<li><p>如果<span class="math inline">\(a &lt; 0 &lt;
b\)</span>,要求<span class="math inline">\(\sum_{ \lambda_i \in \mathrm{
even } } \frac{ 1 }{ \lambda_i } = + \infty , \sum_{ \lambda_i \in
\mathrm{ odd } } \frac{ 1 }{ \lambda_i } = + \infty\)</span>.</p></li>
</ol>
<p>先证这个命题的充分性,对于<span class="math inline">\(0 \notin ( a , b
)\)</span>,不妨设<span class="math inline">\(0 \leq a &lt; b =
1\)</span>,容易发现此时的确满足<span class="math inline">\(\lim
\lambda_n = + \infty\)</span>而且<span class="math inline">\(\sum_i
\frac{ 1 }{ \lambda_i } = + \infty\)</span>,这就搞定了.</p>
<p>对于<span class="math inline">\(a &lt; 0 &lt;
b\)</span>,我们只要证明在<span class="math inline">\(C [ - 1 , 1
]\)</span>上的函数都可以被一致逼近即可对吧.考虑<span class="math inline">\(g_1 ( x ) = \frac{ f ( x ) + f ( - x ) }{ 2
}\)</span>是其偶函数部分,自然可以被偶次的部分逼近(原因是只需要逼近<span class="math inline">\([ 0 , 1 ]\)</span>上就可以延拓).反之亦然同理,<span class="math inline">\(g_2 ( x ) = \frac{ f ( x ) - f ( - x ) }{ 2
}\)</span>也可以被奇数次的部分逼近并且延拓,这也就搞定.</p>
<p>回忆到如果一个函数如果在一个无穷区间上可以被有限次多项式一致逼近,用柯西准则做那个函数列就可以证明这个函数一定是一个多项式.下面我们来推广这个结论.</p>
<p>设<span class="math inline">\(V\)</span>是一个内积空间,其中<span class="math inline">\(g , f_1 , \cdots , f_n \in V\)</span>是其中的<span class="math inline">\(n\)</span>个向量,设<span class="math inline">\(E =
\mathrm{ Span } \{ f_1 , \cdots , f_n \}\)</span>,回忆到<span class="math inline">\(g\)</span>到<span class="math inline">\(E\)</span>的距离定义为:</p>
<p><span class="math display">\[
d = \min_{ p \in E } \Vert g - p \Vert = \sqrt{ \cfrac{ G ( g , f_1 ,
\cdots , f_n ) }{ G ( f_1 , \cdots , f_n ) } }
\]</span></p>
<p>其中<span class="math inline">\(G ( f_1 , \cdots , f_n ) = \det | (
f_i | f_j ) |\)</span>.</p>
<p>而考虑取两列数列<span class="math inline">\(\{ \alpha_i \} , \{
\beta_j \}\)</span>,回忆到李文威考试题给出过:</p>
<p><span class="math display">\[
\det ( \frac{ 1 }{ \alpha_i + \beta_j } ) = \cfrac{ \prod_{ 1 \leq i
&lt; j \leq n } ( \alpha_j - \alpha_i ) ( \beta_j - \beta_i ) }{ \prod_{
1 \leq i , j \leq n } ( \alpha_i + \beta_j ) }
\]</span></p>
<p>又回忆到<span class="math inline">\(C [ 0 , 1
]\)</span>也是一个内积空间,可以定义<span class="math inline">\(( f | g )
= \int_0^1 fg \mathrm{ d } x\)</span>.容易见到<span class="math inline">\(( x^a | x^b ) = \frac{ 1 }{ a + b + 1
}\)</span>.现在我们就可以用上面的行列式硬算了.考虑取<span class="math inline">\(E = \mathrm{ span } \{ x^{ \lambda_1 } , \cdots ,
x^{ \lambda_n } \}\)</span>,取<span class="math inline">\(d = ( x^{
\lambda } , E )\)</span>,容易见到:</p>
<p><span class="math display">\[
d ( x^\lambda , E ) = \frac{ 1 }{ \sqrt{ 2 \lambda + 1 } } \prod_{ i = 1
}^n \left | \frac{ \lambda - \lambda_i }{ \lambda + \lambda_i + 1 }
\right |
\]</span></p>
<p>下面我们引进一个引理:</p>
<p>对于数列<span class="math inline">\(\{ \lambda_i \} &gt;
0\)</span>且单增,如果<span class="math inline">\(c = \inf_{ i \geq 1 }
\{ \lambda_{ i + 1 } - \lambda_i \} &gt; 0\)</span>,如果<span class="math inline">\(\sum_{ i = 1 }^\infty \frac{ 1 }{ \lambda_i } &lt;
\infty\)</span>,则<span class="math inline">\(\lim_{ m \to \infty }
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 , i \ne m }^\infty \ln \left |
\frac{ \lambda_i + \lambda_m }{ \lambda_i - \lambda_m } \right | =
0\)</span>.</p>
<p>这个定理的详细证明较为麻烦,而且与主线无关,将在下述Example3处讲解.</p>
<p>考虑取<span class="math inline">\(P ( x ) \in \mathrm{ Span }_{ i \ne
m } \{ x^{ \lambda_i } \}\)</span>,由于子空间只有有限项非零,所以<span class="math inline">\(\exists n\)</span>使得<span class="math inline">\(P ( x ) \in E = \mathrm{ Span }_{ i \ne m , i \leq
n } \{ x^{ \lambda_i } \}\)</span>,此时观察到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; d ( x^{ \lambda_m } , P ( x ) ) \\
\geq &amp; d ( x^\lambda_m , E ) \\
= &amp; \frac{ 1 }{ \sqrt{ 2 \lambda_m + 1 } } \prod_{ i = 1 , i \ne m
}^n \left | \frac{ \lambda_m - \lambda_i }{ \lambda_m + \lambda_i + 1 }
\right | \\
\geq &amp; \frac{ 1 }{ \sqrt{ 2 \lambda_m + 1 } } \prod_{ i = 1 , i \ne
m }^{ \infty } \left | \frac{ \lambda_m - \lambda_i }{ \lambda_m +
\lambda_i + 1 } \right | \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上述引理,我们知道最后那一项取<span class="math inline">\(\ln\)</span>后是一个<span class="math inline">\(o
( \lambda_m )\)</span>的东西,不妨将后面那一项记作<span class="math inline">\(e^{ - l_m \lambda_m }\)</span>,其中<span class="math inline">\(l_m &gt; 0 , \lim_{ m \to \infty } l_m =
0\)</span>.</p>
<p>为了简化说明引进<span class="math inline">\(\lambda_0 =
0\)</span>,</p>
<p>再来一个引理:对<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists C_\epsilon &gt;
0\)</span>,满足<span class="math inline">\(\forall P ( x ) \in \mathrm{
Span }_{ i \geq 0 } \{ x^{ \lambda_i } \} , \lambda_0 =
0\)</span>,不妨设<span class="math inline">\(P ( x ) = \sum_{ i = 0 }^n
a_i x^{ \lambda_i }\)</span>,我们有<span class="math inline">\(| a_m |
\leq C_\epsilon ( 1 + \epsilon )^{ \lambda_m } \Vert P
\Vert\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ P ( x ) }{ a_m } &amp; = x^{ \lambda_i } + \sum_{ i \leq n , i
\ne m }^n \frac{ a_i }{ a_m } x^{ \lambda_m } \\
\frac{ \Vert P ( x ) \Vert }{ | a_m | } &amp; \geq d ( x^{ \lambda_m } ,
E ) \geq e^{ - l_m \lambda_m } \\
| a_m | &amp; \leq e^{ l_m \lambda_m } \Vert P ( x ) \Vert
\end{aligned}
\]</span></p>
<p>而当<span class="math inline">\(m\)</span>充分大的时候,当然有<span class="math inline">\(e^{ l_m } \leq 1 +
\epsilon\)</span>,这就证毕了.</p>
<p>万事俱备,下面我们来证明必要性:办法是使用反证法,假设<span class="math inline">\(f \in C [ 0 , 1 ]\)</span>,当<span class="math inline">\(\lambda_0 = 0 , \sum_{ i = 1 }^\infty \frac{ 1 }{
\lambda_i } &lt; \infty\)</span>时,并且<span class="math inline">\(P_n (
x ) = \sum_{ i = 0 }^n a_{ i , n } x^{ \lambda_i } \rightrightarrows f (
x )\)</span>.则当然也有<span class="math inline">\(\Vert P_n \Vert \to
\Vert f \Vert\)</span>,那<span class="math inline">\(\Vert P_n
\Vert\)</span>就有界了,既然如此,<span class="math inline">\(a_{ i , n }
\leq C_\epsilon ( 1 + \epsilon )^{ \lambda_i
}\)</span>,也就是说所有的<span class="math inline">\(a_{ i , n
}\)</span>都是有界的.</p>
<p>我们想要求出一个子列<span class="math inline">\(\{ n_k
\}\)</span>,使得<span class="math inline">\(\forall i , \lim_{ k \to
\infty } a_{ i , n_k }\)</span>收敛于某个数<span class="math inline">\(a_i\)</span>,方法是对角线法则,对于第一行其肯定存在收敛子列,取其第一个数为<span class="math inline">\(n_1\)</span>,对于第二行,在第一行对应下来的元素中肯定也有收敛子列,取其第一个元素作为<span class="math inline">\(n_2\)</span>,依次类推.这样我们就得到了一个新的函数列<span class="math inline">\(P_{ n_k } \to g ( x ) = \sum_{ i = 0 }^\infty a_i
x^{ \lambda_i }\)</span>.此时考虑<span class="math inline">\(\varlimsup
\sqrt[\lambda_i]{ | a_i | } \leq 1 + \epsilon\)</span>,因此<span class="math inline">\(g ( x )\)</span>收敛半径<span class="math inline">\(\geq 1\)</span>.然而,<span class="math inline">\(P_{ n_k } \to f ( x )\)</span>,因此<span class="math inline">\(f ( x ) = g ( x )\)</span>.然而<span class="math inline">\(g ( x )\)</span>的收敛半径<span class="math inline">\(\geq
1\)</span>,因此一般的函数当然不能被一致逼近.</p>
<p>另一个问题是如果<span class="math inline">\(a &lt; 0 &lt;
b\)</span>该怎么办,接下来假设<span class="math inline">\(\sum_{
\lambda_i \in \mathrm{ even } } \frac{ 1 }{ \lambda_i } &lt;
\infty\)</span>.放缩一下边界,我们下面来证明此时不能逼近<span class="math inline">\(C [ - 1 , 1 ]\)</span>上的偶函数.</p>
<p>假设<span class="math inline">\(f \in C [ - 1 , 1
]\)</span>并且是偶函数,对于一列函数列,可以拆成偶函数<span class="math inline">\(g_n\)</span>和奇函数<span class="math inline">\(h_n\)</span>部分,前者只包含偶数次后者只包含奇数次.此时有<span class="math inline">\(g_n + h_n \rightrightarrows
f\)</span>,由于是偶函数,换号得到<span class="math inline">\(g_n - h_n
\rightrightarrows f\)</span>,这就必然得到<span class="math inline">\(g_n
\rightrightarrows f\)</span>,但<span class="math inline">\(g_n\)</span>并不能逼近所有的,这就矛盾了.</p>
<h6><span id="example1">Example1</span></h6>
<p>若<span class="math inline">\(f ( x
)\)</span>在无穷区间上可以用多项式一致逼近,求证<span class="math inline">\(f\)</span>为多项式.</p>
<p>考虑多项式列<span class="math inline">\(\{ P_n
\}\)</span>上有柯西准则,所以当<span class="math inline">\(N\)</span>足够大的时候,<span class="math inline">\(\forall n , m \geq N\)</span>,<span class="math inline">\(\sup | P_n - P_m
|\)</span>足够小,然而由于无穷区间,如果<span class="math inline">\(\deg (
P_n - P_m ) &gt;
0\)</span>就完蛋了,所以从某一项开始,这个多项式列的两两之间一定之差一个常数.不妨干脆设<span class="math inline">\(P_n = P + c_n\)</span>的形式,既然<span class="math inline">\(P_n\)</span>收敛,那么<span class="math inline">\(c_n\)</span>肯定收敛,设其收敛于<span class="math inline">\(c\)</span>,则<span class="math inline">\(f ( x ) =
P + c\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>若<span class="math inline">\(f \in C [ a , b ]\)</span>,<span class="math inline">\(\{ p_n \} \rightrightarrows f\)</span>,并且<span class="math inline">\(\{ p_n
\}\)</span>为次数一致有界的多项式列,求证<span class="math inline">\(f\)</span>为多项式.</p>
<p>设次数上界为<span class="math inline">\(n\)</span>,一个想法是说我这些多项式是有限多个的,你直接拿切比雪夫多项式作为基,既然现在都是有限和的情况了,那在线性空间上收敛当然是在每一个基对应的系数都收敛,这就意味着<span class="math inline">\(f\)</span>肯定是多项式.</p>
<h6><span id="example3lemma">Example3(Lemma)</span></h6>
<p>对于数列<span class="math inline">\(\{ \lambda_i \} &gt;
0\)</span>且单增,如果<span class="math inline">\(c = \inf_{ i \geq 1 }
\{ \lambda_{ i + 1 } - \lambda_i \} &gt; 0\)</span>,如果<span class="math inline">\(\sum_{ i = 1 }^\infty \frac{ 1 }{ \lambda_i } &lt;
\infty\)</span>,则<span class="math inline">\(\lim_{ m \to \infty }
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 , i \ne m }^\infty \ln \left |
\frac{ \lambda_i + \lambda_m }{ \lambda_i - \lambda_m } \right | =
0\)</span>.</p>
<p>考虑证明,由于每一项都是正的,因此我们分别证明后面的无穷和部分在<span class="math inline">\([ 1 , m - 1 ]\)</span>和<span class="math inline">\([ m + 1 , + \infty )\)</span>上均为<span class="math inline">\(0\)</span>.</p>
<p>思路呼之欲出,将<span class="math inline">\(\lambda_i\)</span>按照与<span class="math inline">\(\lambda_m\)</span>的比例分为两段:任意取定常数<span class="math inline">\(\epsilon &gt; 0\)</span>,下面开始分析.</p>
<p>设当<span class="math inline">\(i \geq N_1\)</span>的时候有<span class="math inline">\(\lambda_i \geq ( 1 - \epsilon )
\lambda_m\)</span>成立,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N_1 - 1 } \ln ( 1 +
\frac{ 2 \lambda_i }{ \lambda_m - \lambda_i } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N_1 - 1 } \frac{ 2
\lambda_i }{ \lambda_m - \lambda_i } \\
= &amp; \sum_{ i = 1 }^{ N_1 - 1 } \frac{ 2 \lambda_i }{ ( \lambda_m -
\lambda_i ) \lambda_m } \\
= &amp; 2 \sum_{ i = 1 }^{ N_1 - 1 } ( \frac{ 1 }{ \lambda_m - \lambda_i
} - \frac{ 1 }{ \lambda_m } ) \\
\leq &amp; 2 \sum_{ i = 1 }^{ N_1 - 1 } \frac{ 1 }{ \epsilon \lambda_m }
- \frac{ 1 }{ \lambda_m } \\
= &amp; \frac{ N_1 - 1 }{ \lambda_m } ( \frac{ 2 }{ \epsilon } - 1 ) \\
\leq &amp; \frac{ m }{ \lambda_m } ( \frac{ 2 }{ \epsilon } - 1 )
\end{aligned}
\]</span></p>
<p>然而注意到<span class="math inline">\(\{ \frac{ 1 }{ \lambda_m }
\}\)</span>单调递减,用柯西准则得到:</p>
<p><span class="math display">\[
\sum_{ k = m + 1 }^{ 3 m } \frac{ 1 }{ \lambda_k } \geq \frac{ m }{
\lambda_{ 2 m } }
\]</span></p>
<p>所以得到<span class="math inline">\(\lim_{ m \to + \infty } \frac{ m
}{ \lambda_m } \to 0\)</span>.</p>
<p>然后考虑设<span class="math inline">\(i &gt; N_2\)</span>时有<span class="math inline">\(( 1 + \epsilon ) \lambda_m \leq
\lambda_i\)</span>,设<span class="math inline">\(( 1 + \epsilon ) =
\frac{ 1 }{ 1 - \epsilon_2 }\)</span>,则<span class="math inline">\(\lambda_m \leq ( 1 - \epsilon_2 )
\lambda_i\)</span>留神到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_2 + 1 }^{ + \infty } \ln ( 1
+ \frac{ 2 \lambda_m }{ \lambda_i - \lambda_m } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_2 + 1 }^{ + \infty }
\frac{ 2 \lambda_m }{ \lambda_i - \lambda_m } \\
= &amp; \sum_{ i = N_2 + 1 }^{ + \infty } \frac{ 2 }{ \lambda_i -
\lambda_m } \\
\leq &amp; \sum_{ i = N_2 + 1 }^{ + \infty } \frac{ 4 }{ \epsilon_2
\lambda_i } \\
\leq &amp; \sum_{ i = m }^{ + \infty } \frac{ 4 }{ \epsilon_2 \lambda_i
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>由柯西准则就可以知道其趋近于<span class="math inline">\(0\)</span>.</p>
<p>由上面的分析见到如果预先取定<span class="math inline">\(\epsilon\)</span>,再移动<span class="math inline">\(m\)</span>,开头结尾两端都可以尽可能小对吧.最后我们要做的就是中间很靠近<span class="math inline">\(\lambda_m\)</span>的两段了,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_1 }^{ m - 1 } \ln ( \frac{ 2
\lambda_m }{ \lambda_m - \lambda_i } - 1 ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_1 }^{ m - 1 } \ln (
\frac{ 2 \lambda_m }{ c ( m - i ) } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设<span class="math inline">\(M = m - N_1\)</span>,上式变为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_1 }^{ m - 1 } \ln ( \frac{ 2
\lambda_m }{ c ( m - i ) } - 1 ) \\
= &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N } \ln ( \frac{ 2
\lambda_m }{ ic } - 1 ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N } \ln ( \frac{ 2
\lambda_m }{ ic } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = m + 1 }^{ N_2 } \ln ( 1 +
\frac{ 2 \lambda_m }{ \lambda_i - \lambda_m } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = m + 1 }^{ N_2 } \ln ( 1 +
\frac{ 2 \lambda_m }{ c ( i - m ) } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = m + 1 }^{ N_2 } \ln (
\frac{ 2 \lambda_m + cm }{ c ( i - m ) } )
\end{aligned}
\]</span></p>
<p>然而<span class="math inline">\(\frac{ m }{ \lambda_m } \to
0\)</span>,于是后面的主要项仍是<span class="math inline">\(\ln ( \frac{
\lambda_m }{ ic } )\)</span>形状,而考虑<span class="math inline">\(\max
( N_2 - m , m - N_1 ) \leq \frac{ \epsilon \lambda_m }{ c
}\)</span>,接下来只要证明:</p>
<p><span class="math display">\[
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c
} } \ln ( \frac{ \lambda_m }{ ic } ) \to 0
\]</span></p>
<p>就做完了对吧,发现:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c
} } \ln ( \frac{ \lambda_m }{ ic } ) &amp; = \frac{ 1 }{ \lambda_m }
\sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln ( \lambda_m ) -
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c
} } \ln ( ic ) \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) - \frac{
1 }{ \lambda_m } \sum_{ i = 2 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln
( i ) \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) - \frac{
1 }{ \lambda_m } \sum_{ i = 2 }^{ \lfloor \frac{ \epsilon \lambda_m }{ c
} \rfloor } \int_{ i - 1 }^{ i } \ln ( i ) \mathrm{ d t } \\
&amp; \leq \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) -
\frac{ 1 }{ \lambda_m } \int_{ 1 }^{ \frac{ \epsilon \lambda_m }{ c } -
1 } \ln t \mathrm{ d t } \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) - \frac{
1 }{ \lambda_m } \int_{ 1 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln t
\mathrm{ d t } + \frac{ 1 }{ \lambda_m } \int_{ \frac{ \epsilon
\lambda_m }{ c } - 1 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln t
\mathrm{ d } t \\
&amp; \leq \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) -
\frac{ 1 }{ \lambda_m } \int_{ 1 }^{ \frac{ \epsilon \lambda_m }{ c } }
\ln t \mathrm{ d t } + \frac{ \ln ( \frac{ \epsilon \lambda_m }{ c } )
}{ \lambda_m } \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) + \frac{
\ln ( \frac{ \epsilon \lambda_m }{ c } ) }{ \lambda_m } - \frac{ 1 }{
\lambda_m } ( \frac{ \epsilon \lambda_m }{ c } \ln ( \frac{ \epsilon
\lambda_m }{ c } ) - 1 ) \\
&amp; = \frac{ \epsilon }{ c } \ln \epsilon + \frac{ 1 + \ln ( \frac{
\epsilon \lambda_m }{ c } ) }{ \lambda_m }
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(\epsilon\)</span>在<span class="math inline">\(m\)</span>之前决定,因此<span class="math inline">\(\lambda_m \to
\infty\)</span>的时候可以让后者趋近于<span class="math inline">\(0\)</span>,此时再让<span class="math inline">\(\epsilon \to 0\)</span>可以让前者为<span class="math inline">\(0\)</span>,这就搞定了.</p>
<h6><span id="example4黎曼引理">Example4(黎曼引理)</span></h6>
<p>求证:<span class="math inline">\(f \in C [ a , b ]\)</span>,<span class="math inline">\(\lim_{ n \to \infty } \int_a^b f ( x ) \sin ( nx )
\mathrm{ d } x = 0\)</span>.</p>
<p>当<span class="math inline">\(f \in C^1 [ a , b
]\)</span>的时候,由于:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f ( x ) \sin ( nx ) \mathrm{ d } x \\
= &amp; - \frac{ 1 }{ n } \int_a^b f \mathrm{ d } \cos ( nx ) \\
= &amp; - \frac{ 1 }{ n } f \cos ( nx ) |_a^b + \frac{ 1 }{ n } \int_a^b
\cos ( nx ) f &#39; \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>两边取绝对值然后让<span class="math inline">\(n \to
\infty\)</span>就搞定.</p>
<p>既然如此,考虑当<span class="math inline">\(f \in C [ a , b
]\)</span>的时候,用多项式逼近<span class="math inline">\(f\)</span>,有<span class="math inline">\(| f - P |
&lt; \epsilon\)</span>,当然:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \varlimsup_{ n \to \infty } | \int_a^b f \sin ( nx ) \mathrm{ d }
x | \\
\leq &amp; \varlimsup_{ n \to \infty } | \int_a^b | f - P | \sin ( nx )
\mathrm{ d } x | \\
\leq &amp; \epsilon ( b - a )
\end{aligned}
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p>当<span class="math inline">\(f \in C [ a , b ]\)</span>,如果<span class="math inline">\(\forall n \in \mathbb{ N }\)</span>,<span class="math inline">\(\int_a^b f x^n \mathrm{ d } x =
0\)</span>,求证<span class="math inline">\(f \equiv 0\)</span>.</p>
<p>也就是任意多项式<span class="math inline">\(P\)</span>都有<span class="math inline">\(\int_a^b fP \mathrm{ d } x = 0\)</span>.取<span class="math inline">\(P\)</span>使得<span class="math inline">\(| P - f
| &lt; \epsilon\)</span>,于是:</p>
<p><span class="math display">\[
\begin{aligned}
| \int_a^b f^2 \mathrm{ d } x | &amp; = | \int_a^b fP \mathrm{ d } x +
\int_a^b f ( f - P ) \mathrm{ d } x | \\
&amp; = | \int_a^b f ( f - P ) \mathrm{ d } x | \\
&amp; \leq \epsilon \int_a^b | f | \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(\int_a^b f^2 \mathrm{ d } x =
0\)</span>所以<span class="math inline">\(f \equiv 0\)</span>.</p>
<h4><span id="傅里叶级数">傅里叶级数</span></h4>
<p>定义<strong>三角系</strong>为形如<span class="math inline">\(\{ 1 ,
\cos ( nx ) , \sin ( nx )
\}\)</span>的集合,它们张成的线性空间中,也就是有限的线性组合<span class="math inline">\(\sum_{ k = 0 }^n a_k \cos ( kx ) + b_k \sin ( kx
)\)</span>称为<span class="math inline">\(n\)</span>阶<strong>三角多项式</strong>.当<span class="math inline">\(n \to
\infty\)</span>的时候则称其为<strong>三角级数</strong>.容易见到<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi )\)</span>.</p>
<p>下面我们来证明三角系两两正交,只需检查:</p>
<ol type="1">
<li><p>当<span class="math inline">\(m \ne n\)</span>的时候,<span class="math inline">\(\int_{ - \pi }^{ \pi } \cos ( mx ) \cos ( nx )
\mathrm{ d } x\)</span>.</p></li>
<li><p>当<span class="math inline">\(m \ne n\)</span>的时候,<span class="math inline">\(\int_{ - \pi }^{ \pi } \sin ( mx ) \sin ( nx )
\mathrm{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(\forall n , m \in \mathbb{ Z
}\)</span>,<span class="math inline">\(\int_{ - \pi }^{ \pi } \sin ( nx
) \cos ( mx ) \mathrm{ d } x = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ - \pi }^{ \pi } \cos^2 ( nx )
\mathrm{ d x } = \int_{ - \pi }^{ \pi } \sin^2 ( nx ) \mathrm{ d x } =
\pi\)</span>.</p></li>
</ol>
<p>不妨设<span class="math inline">\(\frac{ a_0 }{ 2 } + \sum_{ 1
}^\infty a_k \cos ( kx ) + b_k \sin ( kx ) \rightrightarrows f ( x
)\)</span>,假如<span class="math inline">\(f ( x
)\)</span>的确一致收敛到某个函数,我们实际上可以用<span class="math inline">\(f ( x
)\)</span>去反推系数,两边乘一些东西再积分应该见到:</p>
<ol type="1">
<li><p><span class="math inline">\(a_0 = \frac{ 1 }{ \pi } \int_{ - \pi
}^{ \pi } f ( x ) \mathrm{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(a_k = \frac{ 1 }{ \pi } \int_{ - \pi
}^{ \pi } f ( x ) \cos ( kx ) \mathrm{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(b_k = \frac{ 1 }{ \pi } \int_{ - \pi
}^{ \pi } f ( x ) \sin ( kx ) \mathrm{ d } x\)</span>.</p></li>
</ol>
<p>应该是显然见到的.</p>
<p>当<span class="math inline">\(f\)</span>在<span class="math inline">\([ - \pi , \pi ]\)</span>上绝对可积,也就是<span class="math inline">\(\int_{ - \pi }^\pi | f | \mathrm{ d } x &lt;
\infty\)</span>,那我们就可以按照上述方法拿到一个三角级数的系数,这个三角级数被称为<span class="math inline">\(f ( x
)\)</span>的<strong>傅里叶级数</strong>或者<strong>傅里叶展开</strong>.注意我们这里其实还并没有说这个三角级数的确收敛到<span class="math inline">\(f ( x )\)</span>,而只能说我们可以如此由<span class="math inline">\(f ( x
)\)</span>构造出一个傅里叶级数.我们有时也将这样的函数记作<span class="math inline">\(f ( x ) \in F [ - \pi , \pi
]\)</span>,不妨干脆将<span class="math inline">\(f ( x
)\)</span>依照<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi
)\)</span>的条件延拓<span class="math inline">\(f ( x
)\)</span>定义(或者干脆要求<span class="math inline">\(f ( x
)\)</span>是以<span class="math inline">\(2
\pi\)</span>为周期的函数),应当见到以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(\lim_{ n \to \infty } a_n = \lim_{ n
\to \infty } b_n = 0\)</span>.</p></li>
<li><p><span class="math inline">\(a_n ( \alpha f + \beta g ) = \alpha
a_n ( f ) + \beta a_n ( g )\)</span>.</p></li>
<li><p><span class="math inline">\(b_n ( \alpha f + \beta g ) = \alpha
b_n ( f ) + \beta b_n ( g )\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f ( x )\)</span>是奇函数,则<span class="math inline">\(a_n ( f ) \equiv 0\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f ( x )\)</span>是偶函数,则<span class="math inline">\(b_n ( f ) \equiv 0\)</span>.</p></li>
<li><p>记<span class="math inline">\(f_h ( x ) = f ( x + h
)\)</span>,则<span class="math inline">\(a_n ( f_h ) = a_n ( f ) \cos (
nh ) + b_n ( f ) \sin ( nh )\)</span>.</p></li>
<li><p>记<span class="math inline">\(f_h ( x ) = f ( x + h
)\)</span>,则<span class="math inline">\(b_n ( f_h ) = b_n ( f ) \cos (
nh ) - a_n ( f ) \sin ( nh )\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f ( x ) \equiv f ( x + \pi
)\)</span>,则<span class="math inline">\(a_{ 2 n - 1 } ( f ) = b_{ 2 n -
1 } ( f )\)</span>.</p></li>
<li><p>对<span class="math inline">\(\alpha \in ( 0 , 1
]\)</span>,若<span class="math inline">\(| f ( x ) - f ( y ) | \leq L |
x - y |^\alpha , \forall x , y \in [ - \pi , \pi ]\)</span>,则<span class="math inline">\(a_n = b_n = O ( \frac{ 1 }{ n^\alpha }
)\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f &#39;\)</span>绝对可积,则<span class="math inline">\(a_n = b_n = o ( \frac{ 1 }{ n }
)\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f &#39;\)</span>绝对可积,则<span class="math inline">\(a_n ( f ) = - \frac{ b_n ( f &#39; ) }{ n
}\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f &#39;\)</span>绝对可积,则<span class="math inline">\(b_n ( f ) = \frac{ a_n ( f &#39; ) }{ n
}\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可以导<span class="math inline">\(m\)</span>次,而且<span class="math inline">\(f^{ (
m ) }\)</span>绝对可积,则<span class="math inline">\(a_n = b_n = o (
\frac{ 1 }{ n^m } )\)</span>.</p></li>
<li><p>若<span class="math inline">\(f \in C ( \mathbb{ R } ) , f ( x +
2 \pi ) \equiv f ( x )\)</span>,则<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,则存在一列三角多项式一致逼近<span class="math inline">\(f\)</span>.</p></li>
<li><p>若<span class="math inline">\(f \in C ( \mathbb{ R } ) , f ( x +
2 \pi ) \equiv f ( x )\)</span>,若<span class="math inline">\(\forall n
\geq 0 , a_n \equiv b_n \equiv 0\)</span>,则<span class="math inline">\(f \equiv 0\)</span>.</p></li>
</ol>
<p>(1)是由于黎曼引理,我们前面已经用若干种方法反复证过了.</p>
<p>(2)(3)是积分线性的显然结果,(4)(5)只需带入定义即可发现.</p>
<p>(6)(7)的话当然是因为和差角公式.(8)的话根据(6)和(7)由于<span class="math inline">\(a_n ( f ) = a_n ( f_\pi ) = a_n ( f ) ( - 1
)^n\)</span>,这就搞定.</p>
<p>(9)的话,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^{ \pi } f ( x ) \cos ( nx )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi - \frac{ \pi }{ n } }^{ \pi -
\frac{ \pi }{ n } } f ( x + \frac{ \pi }{ n } ) \cos ( nt + \pi )
\mathrm{ d } x \\
&amp; = - \frac{ 1 }{ \pi } \int_{ - \pi }^{ \pi } f ( x + \frac{ \pi }{
n } ) \cos ( nt ) \mathrm{ d } x \\
a_n &amp; = \frac{ 1 }{ 2 \pi } \int_{ - \pi }^{ \pi } ( f ( x ) - f ( x
+ \frac{ \pi }{ n } ) ) \cos ( nx ) \mathrm{ d } x \\
| a_n | &amp; \leq \frac{ 1 }{ 2 \pi } \int_{ - \pi }^{ \pi } L ( \frac{
\pi }{ n } )^\alpha \\
&amp; = O ( 1 ) \frac{ 1 }{ n^\alpha }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>至于(10)的话,<span class="math inline">\(a_n = b_n = O ( \frac{ 1 }{
n } )\)</span>当然只是(9)的推论.那怎么证明是<span class="math inline">\(o ( \frac{ 1 }{ n } )\)</span>的呢?考虑:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^{ \pi } f \cos ( nx )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ n \pi } \int_{ - \pi }^{ \pi } f \mathrm{ d } \sin (
nx ) \\
&amp; = - \frac{ 1 }{ n \pi } \int_{ - \pi }^{ \pi } \sin ( nx ) f &#39;
\mathrm{ d } x \\
&amp; = o ( \frac{ 1 }{ n } )
\end{aligned}
\]</span></p>
<p>上述过程也自然拿到了(11)和(12).</p>
<p>(13)的话也只需要由(11)和(12)拿到:</p>
<p><span class="math display">\[
| a_n ( f ) | + | b_n ( f ) | \leq \frac{ | a_n ( f^{ ( m ) } ) | + |
b_n ( f^{ ( m ) } ) | }{ n^m }
\]</span></p>
<p>其实还有一个推论是如果<span class="math inline">\(f\)</span>是<span class="math inline">\(2 \pi\)</span>周期的解析函数,则<span class="math inline">\(| a_n ( f ) | , | b_n ( f ) | \leq Me^{ - nc
}\)</span>.而且甚至说这个条件是充要的,如果趋向于零的速度确实为此,则<span class="math inline">\(f\)</span>也的确是解析函数.可惜的是这个结论需要用到复分析的结果,不得不在此略过.</p>
<p>(14)的话,乍一看像是Stone-Weierstrass定理的另一则应用,直接观察Stone-Weierstrass定理的证明发现的确可以照搬到三角多项式上(因为难点只在<span class="math inline">\(f ( - \pi ) = f ( \pi
)\)</span>,但原证明中分离的性质只用于贴合函数上的两个点),然而如果想要直接封装原定理拿过来的话的确难以处理<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi
)\)</span>的性质(其实可以从复平面绕过去).下面提供另一则证明:</p>
<p>先看当<span class="math inline">\(f ( x
)\)</span>是偶函数的时候,观察<span class="math inline">\(x \in [ 0 , \pi
]\)</span>,取<span class="math inline">\(y = \cos x\)</span>,见到<span class="math inline">\(f ( \arccos y ) \in C [ - 1 , 1
]\)</span>.此时存在一个多项式<span class="math inline">\(P ( y ) = P (
\cos x )\)</span>一致逼近<span class="math inline">\(f ( x
)\)</span>,而<span class="math inline">\(P ( \cos x
)\)</span>当然是三角多项式.</p>
<p>考虑取<span class="math inline">\(g ( x ) = f ( x ) + f ( - x
)\)</span>,则如上知道<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,存在三角多项式<span class="math inline">\(T_1 ( x
)\)</span>使得<span class="math inline">\(\forall x \in \mathbb{ R } , |
g ( x ) - T_1 ( x ) | &lt; \frac{ \epsilon }{ 2 }\)</span>.</p>
<p>再取<span class="math inline">\(\varphi ( x ) = ( f ( x ) - f ( - x )
) \sin x\)</span>当然也是偶函数,存在三角多项式<span class="math inline">\(T_2 ( x )\)</span>使得<span class="math inline">\(\forall x \in \mathbb{ R } , | \varphi ( x ) - T_2
( x ) | &lt; \frac{ \epsilon }{ 2 }\)</span>.</p>
<p>既然如此,考虑取<span class="math inline">\(T_3 ( x ) = T_1 \sin^2 x +
T_2 \sin x\)</span>,由上见到<span class="math inline">\(| 2 f ( x )
\sin^2 x - T_3 ( x ) | &lt; \epsilon\)</span>,也就是说对于任何<span class="math inline">\(f ( x )\)</span>都能找到如此一个<span class="math inline">\(T_3 ( x )\)</span>满足条件.</p>
<p>既然如此,考虑对<span class="math inline">\(f ( x - \frac{ \pi }{ 2 }
)\)</span>做上述操作,也就是存在三角多项式<span class="math inline">\(T_4
( x )\)</span>满足:</p>
<p><span class="math display">\[
\begin{aligned}
| 2 f ( x - \frac{ \pi }{ 2 } ) \sin^2 x - T_4 ( x ) | &lt; \epsilon \\
| 2 f ( x ) \cos^2 x - T_4 ( x + \frac{ \pi }{ 2 } ) | &lt; \epsilon
\end{aligned}
\]</span></p>
<p>既然如此,得到:<span class="math inline">\(| 2 f ( x ) - T_3 ( x ) -
T_4 ( x + \frac{ \pi }{ 2 } ) | &lt; 2 \epsilon\)</span>,这就搞定了.</p>
<p>对于(15),考虑找一列三角多项式一致逼近<span class="math inline">\(f (
x )\)</span>,由于<span class="math inline">\(f ( x
)\)</span>的傅里叶级数总是<span class="math inline">\(0\)</span>,所以对于三角多项式<span class="math inline">\(T_n\)</span>来说一定有<span class="math inline">\(\int_{ - \pi }^{ \pi } f ( x ) T_n ( x ) \mathrm{
d } x \equiv 0\)</span>,既然如此考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\int_{ - \pi }^{ \pi } f^2 \mathrm{ d } x &amp; = \int_{ - \pi }^\pi f (
f - T_n ) \mathrm{ d } x \\
&amp; \leq \int_{ - \pi }^\pi | f | \cdot | f - T_n | \mathrm{ d } x \\
&amp; \leq \epsilon \int_{ - \pi }^\pi | f | \mathrm{ d } x &amp; \to 0
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(f \equiv
0\)</span>.这意味着连续函数的傅里叶展开是唯一的.</p>
<p>(15)的一则类似结果是,你可以从中看出<span class="math inline">\(\{ 1 ,
\sin ( nx ) , \cos ( nx )
\}\)</span>三角系是缺一不可的,而不像多项式那样可以去掉很多.例如如果我们在其中去掉<span class="math inline">\(\sin x\)</span>的话,那么<span class="math inline">\(\sin
x\)</span>本身就无法逼近,原因是反证法,如果能逼近,考虑一列三角多项式<span class="math inline">\(\{ T_n \}\)</span>并且其中不含<span class="math inline">\(\sin
x\)</span>,然而,由于三角系中两两正交,因此<span class="math inline">\(\forall T_n ,\)</span>都有<span class="math inline">\(\int_{ - \pi }^{ \pi } T_n \sin x \mathrm{ d } x
\equiv 0\)</span>,因此从(15)的证明过程就可以见到必然有<span class="math inline">\(\sin x \equiv 0\)</span>,这当然就出事了.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(x \in [ - \pi , \pi
]\)</span>,考虑一列<span class="math inline">\(\{ b_n
\}\)</span>单调下降趋近于<span class="math inline">\(0\)</span>,那么根据DA判法当然有<span class="math inline">\(S ( x ) = \sum_{ n = 1 }^\infty b_n \sin ( nx
)\)</span>是逐点收敛的,假设收敛于<span class="math inline">\(f ( x
)\)</span>.如果<span class="math inline">\(f ( x )\)</span>的确是<span class="math inline">\([ - \pi , \pi
]\)</span>上的绝对可积函数.求证:此时上述<span class="math inline">\(S (
x )\)</span>的确是<span class="math inline">\(f ( x
)\)</span>的傅里叶级数.</p>
<p>容易见到<span class="math inline">\(f ( x
)\)</span>是奇函数,其傅里叶级数中的<span class="math inline">\(a_n
\equiv 0\)</span>.此时不妨只看<span class="math inline">\(x \in [ 0 ,
\pi ]\)</span>上的结果.</p>
<p>难点当然在于<span class="math inline">\(S ( x ) \to
f\)</span>并不一定是一致逼近,但应该观察到的是:</p>
<p><span class="math display">\[
| \sin ( mx ) \sum_{ k = 1 }^n \sin ( kx ) | \leq \left | \frac{ \sin (
mx ) }{ \sin \frac{ x }{ 2 } } \right | \leq \left | \frac{ mx }{ \frac{
x }{ \pi } } \right | = | m \pi |
\]</span></p>
<p>所以这个一致有界,前面的<span class="math inline">\(| b_n
|\)</span>单调趋近于<span class="math inline">\(0\)</span>,DA判法告诉我们<span class="math inline">\(\sin ( mx ) S ( x
)\)</span>一致收敛,那逐项积分就证完了<span class="math inline">\(\int_{
- \pi }^{ \pi } g ( x ) \sin ( mx ) \mathrm{ d } x = \pi
b_m\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(f ( x ) = \frac{ 1 - r^2 }{ 1 - 2 r
\cos x + r^2 } , | r | &lt; 1\)</span>的傅里叶级数.</p>
<p>考虑在复数上做此操作,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ 1 - z } &amp; = \frac{ 1 - \bar{ z } }{ ( 1 - z ) ( 1 -
\bar{ z } ) } \\
&amp; = \frac{ 1 - \bar{ z } }{ 1 - 2 \Re z + | z |^2 } \\
&amp; = \frac{ 1 - r \cos x + ir \sin x }{ 1 - 2 r \cos x + r^2 }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(2 \Re ( \frac{ 1 }{ 1 - z } ) - 1 = f
( x )\)</span>,然而:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ 1 }{ 1 - z } &amp; = \sum_{ n \geq 0 } z^n = \sum_{ n \geq 0 }
r^n e^{ inx } \\
\Re ( \frac{ 1 }{ 1 - z } ) &amp; = 1 + \sum_{ n \geq 1 } r^n \cos ( nx
) \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以<span class="math inline">\(f ( x ) = 1 + \sum_{ n \geq 1 } 2 r^n
\cos ( nx )\)</span>.</p>
<h5><span id="与原函数的收敛关系">与原函数的收敛关系</span></h5>
<p>做完以上操作后,我们来考虑这个傅里叶级数到底是否逼近于<span class="math inline">\(f ( x )\)</span>本身,设<span class="math inline">\(S_n ( x ) = \frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n (
a_k \cos ( kx ) + b_k \sin ( kx ) )\)</span>.此时考虑:</p>
$$
<span class="math display">\[\begin{aligned}
S_n ( x_0 ) &amp; = \frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n \int_{ - \pi
}^\pi f ( x ) ( \cos kx \cdot \cos kx_0 + \sin kx \cdot \sin kx_0 )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ 2 \pi } \int_{ - \pi }^\pi f ( x ) \mathrm{ d } x +
\sum_{ k = 1 }^n \int_{ - \pi }^\pi f ( x ) \cos k ( x - x_0 ) \mathrm{
d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) \left ( \frac{ 1 }{
2 } + \sum_{ k = 1 }^n \cos k ( x - x_0 ) \right ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) \frac{ \sin ( n +
\frac{ 1 }{ 2 } ) ( x - x_0 ) }{ 2 \sin \frac{ x - x_0 }{ 2 } } \mathrm{
d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨令迪利克雷核<span class="math inline">\(D_n ( x ) = \frac{ \sin (
n + \frac{ 1 }{ 2 } ) x }{ 2 \sin \frac{ x }{ 2 } } , \varphi ( x_0 , x
) = \frac{ f ( x_0 + x ) + f ( x_0 - x ) }{ 2 }\)</span>,应当见到<span class="math inline">\(\frac{ 1 }{ \pi } \int_{ - \pi }^\pi D_n ( x )
\mathrm{ d } x = 1\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
S_n ( x_0 ) &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) D_{ n }
( x - x_0 ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( t + x_0 ) D_{ n } ( t )
\mathrm{ d } t \\
&amp; = \frac{ 1 }{ \pi } \int_0^\pi ( f ( x_0 + t ) + f ( x_0 - t ) )
D_n ( t ) \mathrm{ d } t \\
&amp; = \frac{ 2 }{ \pi } \int_0^\pi \varphi ( x_0 , t ) D_n ( t )
\mathrm{ d } t
\end{aligned}
\]</span></p>
<p>问题在于最后如何判断这个积分的收敛性,事实上可以找到若干个逼近的充分条件:</p>
<ol type="1">
<li>分段可导时候的情况</li>
</ol>
<p>下面我们来证明:当<span class="math inline">\(f\)</span>是Holder连续的时候,<span class="math inline">\(\lim_{ n \to \infty } S_n ( x ) \to f ( x
)\)</span>.</p>
<p>我们有如下<strong>黎曼局部化引理</strong>:对<span class="math inline">\(\forall 0 &lt; \delta &lt; \pi\)</span>,都有<span class="math inline">\(\lim_{ n \to \infty } \left ( S_n ( x_0 ) - \frac{
2 }{ \pi } \int_0^\delta \varphi ( x_0 , t ) \frac{ \sin ( n + \frac{ 1
}{ 2 } ) t }{ t } \mathrm{ d } t \right ) = 0\)</span>.</p>
<p>如何证明此呢?考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ \pi }{ 2 } S_n ( x_0 ) &amp; = \int_0^\delta \varphi ( x_0 , t )
D_n ( t ) \mathrm{ d } t + \int_\delta^\pi \varphi ( x_0 , t ) D_n ( t )
\mathrm{ d } t \\
&amp; = \int_0^\delta \varphi ( x_0 , t ) \frac{ \sin ( n + \frac{ 1 }{
2 } ) t }{ t } \mathrm{ d } t + \int_0^\delta \varphi ( x_0 , t ) \frac{
t - 2 \sin \frac{ t }{ 2 } }{ 2 t \sin \frac{ t }{ 2 } } \sin ( n +
\frac{ 1 }{ 2 } ) t \mathrm{ d } t \\
&amp; + \int_\delta^\pi \frac{ \varphi ( x_0 , t ) }{ 2 \sin \frac{ t }{
2 } } \sin ( n + \frac{ 1 }{ 2 } ) t \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>留神到<span class="math inline">\(\frac{ t - 2 \sin \frac{ t }{ 2 }
}{ 2 t \sin \frac{ t }{ 2 }
}\)</span>极限存在,因此其的确有界,对后面两项用黎曼引理就知道趋近于<span class="math inline">\(0\)</span>.</p>
<p>接下来我们还有一个引理:当<span class="math inline">\(\varphi \in R [
0 , \delta ]\)</span>的时候,如果<span class="math inline">\(\varphi ( 0
+ )\)</span>存在,并且<span class="math inline">\(\int_0^\delta \frac{ |
\varphi ( t ) - \varphi ( 0 + ) | }{ t } &lt; \infty\)</span>,则<span class="math inline">\(\lim_{ \lambda \to \infty } \int_0^\delta \varphi
( t ) \frac{ \sin \lambda t }{ t } \mathrm{ d } t = \frac{ \pi }{ 2 }
\varphi ( 0 + )\)</span>.</p>
<p>于此证明,根据黎曼引理:</p>
<p><span class="math display">\[
\begin{aligned}
\lim_{ \lambda \to \infty } \int_0^\delta \frac{ \varphi ( t ) - \varphi
( 0 + ) }{ t } \sin \lambda t \mathrm{ d } t &amp; = 0 \\
\lim_{ \lambda \to \infty } \int_0^\delta \frac{ \varphi ( t ) }{ t }
\sin \lambda t \mathrm{ d } t &amp; = \lim_{ \lambda \to \infty }
\int_0^\delta \frac{ \varphi ( 0 + ) }{ t } \sin \lambda t \mathrm{ d }
t \\
&amp; = \varphi ( 0 + ) \lim_{ \lambda \to \infty } \int_0^{ \lambda
\delta } \frac{ \sin t }{ t } \mathrm{ d } t \\
&amp; = \frac{ \pi }{ 2 } \varphi ( 0 + )
\end{aligned}
\]</span></p>
<p>既然如此,当<span class="math inline">\(f\)</span>是霍尔德连续,也就是<span class="math inline">\(\exists \alpha \in ( 0 , 1 ] , \exists C &gt;
0\)</span>,使得<span class="math inline">\(| f ( x_0 + t ) - f ( x_0 ) |
\leq C | t |^\alpha\)</span>,此时见到<span class="math inline">\(|
\varphi ( x_0 , t ) - \varphi ( x_0 , 0 + ) | = O ( | t |^\alpha
)\)</span>,用上述引理知道此时<span class="math inline">\(S_n ( x_0 ) \to
f ( x_0 )\)</span>.</p>
<p>上述结论还可以得到一个更神秘的结论,我们上述引理只用到了在<span class="math inline">\(x_0\)</span>附近的结果,那如果<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>附近不连续呢?</p>
<p>假设<span class="math inline">\(f ( x_0 \pm 0
)\)</span>均存在,我们可以定义<strong>广义导数</strong>,定义右广义导数为<span class="math inline">\(D_+ f ( x_0 ) = \lim_{ h \to 0 + } \frac{ f ( x_0
+ h ) - f ( x_0 + 0 ) }{ h }\)</span>,同理定义左广义导数.</p>
<p>当<span class="math inline">\(D_\pm f ( x_0
)\)</span>存在的时候,考虑此时<span class="math inline">\(\frac{ |
\varphi ( t ) - \varphi ( 0 + ) | }{ t
}\)</span>没有瑕点,那上述结论当然也就满足.</p>
<p>如果我们定义分段可导为除了若干个断点处的左右广义导数不相同,其余所有点的左右广义导数都存在.那上述结论也就满足.</p>
<ol start="2" type="1">
<li>分段单调时候的情况</li>
</ol>
<p>我们有<strong>Jordan引理</strong>:设<span class="math inline">\(\varphi\)</span>在<span class="math inline">\([ 0
, \delta ]\)</span>上单调,则<span class="math inline">\(\lim_{ \lambda
\to \infty } \int_0^\delta \frac{ \varphi ( x ) }{ x } \sin ( \lambda x
) \mathrm{ d } x = \frac{ \pi }{ 2 } \varphi ( 0 + )\)</span>.</p>
<p>对Jordan引理的证明,不妨设<span class="math inline">\(\varphi\)</span>单调递增,对<span class="math inline">\(\forall \epsilon &gt; 0 , \exists 0 &lt; \delta
&#39; &lt; \delta\)</span>,使得<span class="math inline">\(\forall t \in
( 0 , \delta &#39; ) , 0 \leq \varphi ( t ) - \varphi ( 0 + ) &lt;
\epsilon\)</span>.</p>
<p>不妨设<span class="math inline">\(| \int_0^t \frac{ \sin x }{ x } |
\leq M , \forall t &gt; 0\)</span>,考虑根据积分第二中值定理:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_0^{ \delta &#39; } ( \varphi ( t ) - \varphi ( 0 + ) )
\frac{ \sin ( \lambda t ) }{ t } \mathrm{ d } t | \\
= &amp; | ( \varphi ( \delta &#39; ) - \varphi ( 0 + ) ) \int_\xi^{
\delta &#39; } \frac{ \sin ( \lambda t ) }{ t } \mathrm{ d } t | \\
\leq &amp; 2 M \epsilon
\end{aligned}
\]</span></p>
<p>而在<span class="math inline">\([ \delta &#39; , \delta
]\)</span>上可以直接用黎曼引理这就搞定了.</p>
<p>如果<span class="math inline">\(\varphi\)</span>是有限个单调函数的和,上述结论当然也成立了.所以该结论对有界变差函数是成立的.</p>
<p>因此,当<span class="math inline">\(f \in [ - \pi , \pi
]\)</span>上逐段单调的时候,<span class="math inline">\(\varphi\)</span>逐段是两个单调函数的差,那此时当然也有<span class="math inline">\(\lim_{ n \to \infty } S_n ( x ) = \frac{ f ( x + 0
) + f ( x - 0 ) }{ 2 }\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f ( x ) = \begin{cases}- 1 &amp; x \in
( - \pi , 0 ) \\ 0 &amp; x = 0 \lor x = - \pi \lor x = \pi \\ 1 &amp; x
\in ( 0 , \pi )\end{cases}\)</span>.</p>
<p>见到这的确是一个奇函数,直接求它的傅里叶级数,见到是:</p>
<p><span class="math display">\[
\frac{ 4 }{ \pi } \sum_{ n = 0 }^\infty \frac{ \sin ( 2 n + 1 ) x }{ 2 n
+ 1 } = \frac{ f ( x + 0 ) + f ( x - 0 ) }{ 2 } = f ( x )
\]</span></p>
<p>我们竟然得到了一个一个神秘级数,很牛.</p>
<p>而且这个三角级数在<span class="math inline">\(( 0 , \pi
)\)</span>上处处收敛到<span class="math inline">\(1\)</span>,这个性质在幂级数的时候是无法想象的,我们之前证明过了开区间上的非常值幂级数的零点集一定没有聚点.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f ( x ) = \begin{cases}\pi + x &amp; x
\in [ - \pi , 0 ) \\ \pi - x &amp; x \in [ 0 , \pi
)\end{cases}\)</span>,也就是一个锯齿状的小函数,当然分段单调了.由于是一个偶函数,积分得到<span class="math inline">\(a_n = \frac{ 2 }{ \pi } \int_0^\pi ( \pi - x )
\cos ( nx ) \mathrm{ d } x = \frac{ 2 }{ n^2 \pi } ( 1 - ( - 1 )^n
)\)</span>.</p>
<p>这当然是个连续函数,那此时有:</p>
<p><span class="math display">\[
f ( x ) = \frac{ \pi }{ 2 } + \frac{ 4 }{ \pi } ( \sum_{ k = 0 }^\infty
\frac{ \cos ( 2 k + 1 ) x }{ ( 2 k + 1 )^2 } )
\]</span></p>
<p>两边带入<span class="math inline">\(x = 0\)</span>就知道<span class="math inline">\(\sum_{ k = 0 }^\infty \frac{ 1 }{ ( 2 k + 1 )^2 }
= \frac{ \pi^2 }{ 8 }\)</span>.</p>
<p>还没完,用大M判别法容易检验这个式子两边是绝对一致收敛的,那我们两边逐项积分得到:</p>
$$
<span class="math display">\[\begin{aligned}
\int_0^x f ( t ) \mathrm{ d } t &amp; = \frac{ \pi }{ 2 } x + \frac{ 4
}{ \pi } \sum_{ k = 0 }^\infty \int_0^x \frac{ \cos ( 2 k + 1 ) t }{ ( 2
k + 1 )^2 } \mathrm{ d } t \\
&amp; = \frac{ \pi }{ 2 } x + \frac{ 4 }{ \pi } \sum_{ k = 0 }^\infty
\frac{ \sin ( 2 k + 1 ) t }{ ( 2 k + 1 )^3 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>把左边的<span class="math inline">\(f\)</span>积出来,设其为<span class="math inline">\(g ( x ) = \begin{cases}\pi x + \frac{ x^2 }{ 2 }
&amp; x \in [ - \pi , 0 ) \\ \pi x - \frac{ x^2 }{ 2 } &amp; x \in [ 0 ,
\pi
)\end{cases}\)</span>.那它的傅里叶展开就等于右边的东西(因为一致收敛).带入<span class="math inline">\(x = \frac{ \pi }{ 2 }\)</span>,可以得到<span class="math inline">\(\frac{ \pi^3 }{ 32 } = \sum_{ k = 0 }^\infty
\frac{ ( - 1 )^k }{ ( 2 k + 1 )^3 }\)</span>.</p>
<p>那接下来还可以两边再积分对吧!过程我也懒得写了,总之能推出<span class="math inline">\(\sum_{ k = 0 }^\infty \frac{ 1 }{ ( 2 k + 1 )^4 }
= \frac{ \pi^4 }{ 96 }\)</span>,可以得到<span class="math inline">\(\sum_{ k = 1 }^\infty \frac{ 1 }{ k^4 } = \frac{
\pi^4 }{ 90 }\)</span>.</p>
<p>所以总之,我们可以用上面的策略得到所有的<span class="math inline">\(\zeta ( 2 n )\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑对<span class="math inline">\(\cos ( ax )\)</span>在<span class="math inline">\([ - \pi , \pi
]\)</span>截取出来并延拓,然后对其作傅里叶展开,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\cos ( ax ) &amp; = \frac{ \sin ( a \pi ) }{ a \pi } + \sum_{ n = 1
}^\infty \frac{ ( - 1 )^n 2 a }{ a^2 - n^2 } \frac{ \sin ( a \pi ) }{
\pi } \cos ( nx ) \\
\frac{ 1 }{ \sin ( a \pi ) } &amp; = \frac{ 1 }{ a \pi } + \sum_{ n = 1
}^\infty \frac{ ( - 1 )^n 2 a \pi }{ ( a \pi )^2 - ( n \pi )^2 }
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(z = a \pi\)</span>,得到:</p>
<p><span class="math display">\[
\frac{ 1 }{ \sin z } = \frac{ 1 }{ z } + \sum_{ n = 1 }^\infty ( - 1 )^n
( \frac{ 1 }{ z - n \pi } + \frac{ 1 }{ z + n \pi } )
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>假设<span class="math inline">\(\int_{ - \infty }^{ + \infty } | f |
\mathrm{ d } x &lt; \infty\)</span>,且存在<span class="math inline">\(x_0 , \delta\)</span>,<span class="math inline">\(f ( x_0 \pm 0
)\)</span>存在,使得以下二者其一成立:</p>
<ol type="1">
<li><p><span class="math inline">\(f\)</span>在<span class="math inline">\(( x_0 - \delta , x_0 + \delta
)\)</span>上是有界变差的.</p></li>
<li><p>积分<span class="math inline">\(\int_0^\delta \frac{ | f ( x_0
\pm t ) - f ( x_0 \pm 0 ) | }{ t } &lt; \infty\)</span>.</p></li>
</ol>
<p>则:</p>
<p><span class="math display">\[
\lim_{ \alpha \to \infty } \frac{ 1 }{ \pi } \int_{ - \infty }^{ +
\infty } f ( x_0 + t ) \frac{ \sin ( \alpha t ) }{ t } \mathrm{ d } t =
\frac{ 1 }{ 2 } ( f ( x_0 + 0 ) + f ( x_0 - 0 ) )
\]</span></p>
<p>只需要证明:</p>
<p><span class="math display">\[
\lim_{ \alpha \to \infty } \int_{ 0 }^\infty ( f ( x_0 + t ) - f ( x_0 +
0 ) ) \frac{ \sin ( \alpha t ) }{ t } \mathrm{ d } t = 0
\]</span></p>
<p>首先<span class="math inline">\([ 0 , + \infty )\)</span>上,对于<span class="math inline">\([ 0 , \delta
]\)</span>只需要正常做就行了.可是<span class="math inline">\(\frac{ f (
x_0 + t ) - f ( x_0 + 0 ) }{ t }\)</span>在<span class="math inline">\((
\delta , + \infty
)\)</span>上未必可积,这就有点难绷.开动脑筋,想起来既然这里有一个<span class="math inline">\(\mathbb{ R
}\)</span>上的绝对可积,那当然得用一用我们的柯西准则,考虑将后面拆成<span class="math inline">\(( \delta , M )\)</span>和<span class="math inline">\([ M , + \infty )\)</span>.如果我们能把后面的<span class="math inline">\([ M , + \infty
)\)</span>搞定,那中间那一段用黎曼引理就搞定了.</p>
<p>后面怎么做呢,简单放缩:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ M }^\infty ( f ( x_0 + t ) - f ( x_0 + 0 ) ) \frac{ \sin
( \alpha t ) }{ t } \mathrm{ d } t | \\
\leq &amp; | \int_{ M }^\infty f ( x_0 + t ) \frac{ \sin ( \alpha t ) }{
t } \mathrm{ d } t | + | \int_{ M }^\infty f ( x_0 + 0 ) \frac{ \sin (
\alpha t ) }{ t } \mathrm{ d } t | \\
\leq &amp; \int_{ M }^\infty | f ( x_0 + t ) | \mathrm{ d } t + | f (
x_0 + 0 ) \int_{ M }^\infty \frac{ \sin ( \alpha t ) }{ t } \mathrm{ d }
t | \\
\to &amp; 0
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h5><span id="一致收敛到原函数的情形">一致收敛到原函数的情形</span></h5>
<p>那此时该函数肯定连续,然而连续函数未必总能一致逼近,Example1给出了一个反例.</p>
<p>那么应该加如何条件呢?先证明一个加强版的黎曼引理:</p>
<p>设<span class="math inline">\(g ( x )\)</span>是<span class="math inline">\([ A , B ]\)</span>上的绝对可积函数,取<span class="math inline">\(S_p = \sup_{ a , b \in [ A , B ] } | \int_a^b g (
t ) \sin pt \mathrm{ d } t | + \sup_{ a , b \in [ A , B ] } | \int_a^b g
( t ) \cos pt \mathrm{ d } t |\)</span>,我们要证明<span class="math inline">\(\lim_{ p \to \infty } S_p =
0\)</span>.这个还并不显然,因为<span class="math inline">\(a ,
b\)</span>是可以在<span class="math inline">\(p\)</span>之后决定的.实际上这里就是为了拿到一个一致控制性,我们想让我们的黎曼引理是能一致控制住整个区间的,这样我们才能得到一致收敛的条件.</p>
<p>首先考虑<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,当<span class="math inline">\(g ( x ) \in R [ a , b
]\)</span>的时候,可以先用连续函数逼近,再将连续函数变为多项式逼近.而当<span class="math inline">\(g ( x
)\)</span>有瑕点的时候,可以将瑕点逼掉.所以总能找到一个多项式<span class="math inline">\(f ( x )\)</span>满足<span class="math inline">\(\int_A^B | g ( x ) - f ( x ) | \mathrm{ d } x &lt;
\frac{ \epsilon }{ 2 }\)</span>.然后考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b f \sin ( pt ) \mathrm{ d } t &amp; = \frac{ 1 }{ p } f \cos (
pt ) |_a^b + \frac{ 1 }{ p } \int_a^b \cos ( pt ) f &#39; \mathrm{ d } t
\\
&amp; \to 0
\end{aligned}
\]</span></p>
<p>由此还可以再推出一个引理,<span class="math inline">\(\lim_{ p \to
\infty } \sup_{ A \leq x_0 \pm a , x_0 \pm b \leq B } | \int_a^b g ( x_0
\pm t ) \cos ( pt ) \mathrm{ d } t | =
0\)</span>.原因是换元后用和差角公式拆开就行.</p>
<p>进一步推广,考虑<span class="math inline">\(\gamma ( t
)\)</span>是<span class="math inline">\([ a , b
]\)</span>上的有界变差函数,我们证明:<span class="math inline">\(\lim_{ p
\to \infty } \sup_{ A \leq x_0 \pm a , x_0 \pm b \leq B } | \int_a^b g (
x_0 \pm t ) \gamma ( t ) \cos ( pt ) \mathrm{ d } t | = 0\)</span>.</p>
<p>不妨设<span class="math inline">\(\gamma ( t
)\)</span>单调递增,然后用积分第二中值定理就可以发现:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b g ( x_0 \pm t ) \gamma ( t ) \sin ( pt ) \mathrm{ d } t
\\
= &amp; \gamma ( a ) \int_a^\xi g ( x_0 \pm t ) \sin ( pt ) \mathrm{ d }
t + \gamma ( b ) \int_\xi^b g ( x_0 \pm t ) \sin ( pt ) \mathrm{ d } t
\\
\to &amp; 0
\end{aligned}
\]</span></p>
<p>接下来设<span class="math inline">\(\varphi ( t ) = f ( x + t ) + f (
x - t ) - 2 f ( x )\)</span>,假设<span class="math inline">\(f\)</span>是<span class="math inline">\([ - \pi ,
\pi ]\)</span>上的绝对可积函数,而且<span class="math inline">\(f\)</span>限制在子区间<span class="math inline">\([ a , b
]\)</span>上是连续的.我们有<strong>迪尼定理</strong>:若<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt; 0 ,
\sup_{ x \in [ a , b ] } \int_0^\delta \frac{ | \varphi ( t ) | }{ t }
\mathrm{ d } t &lt; \epsilon\)</span>,则其傅里叶级数<span class="math inline">\(S_n ( x )\)</span>在区间<span class="math inline">\([ a , b ]\)</span>上一致逼近<span class="math inline">\(f\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
S_n ( x ) - f ( x ) &amp; = \frac{ 1 }{ \pi } \int_0^\pi \varphi ( t )
\frac{ \sin ( n + \frac{ 1 }{ 2 } ) t }{ 2 \sin \frac{ t }{ 2 } }
\mathrm{ d } t \\
&amp; = \frac{ 1 }{ \pi } ( \int_0^\delta + \int_\delta^\pi ) \varphi (
t ) \frac{ \sin ( n + \frac{ 1 }{ 2 } ) t }{ 2 \sin \frac{ t }{ 2 } }
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑前者:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^\delta &amp; \leq \frac{ 1 }{ \pi } \int_0^\delta \frac{ |
\varphi ( t ) | }{ t } \frac{ \frac{ t }{ 2 } }{ \sin \frac{ t }{ 2 } }
\mathrm{ d } t \\
&amp; \leq \frac{ 1 }{ 2 } \int_0^\delta \frac{ | \varphi ( t ) | }{ t }
\mathrm{ d } t \\
&amp; &lt; \frac{ \epsilon }{ 2 }
\end{aligned}
\]</span></p>
<p>至于后者,只需上述引理就搞定.</p>
<p>于是最后我们可以得到,如果<span class="math inline">\(f\)</span>是Holder连续的时候,那对于任意的<span class="math inline">\([ a , b ]\)</span>,都一定有<span class="math inline">\(S_n \rightrightarrows f ( x )\)</span>.</p>
<p>而如果当<span class="math inline">\(f\)</span>是有界变差的时候,此时考虑<span class="math inline">\(f\)</span>几乎处处可导,而在其可导的地方当然由上面的结果就一致收敛了,所以可以知道这个函数列几乎处处一致收敛到<span class="math inline">\(f\)</span>.</p>
<p>然而容易检验如果一个连续函数列几乎处处一致收敛到一个连续函数,那当然它们就是一致收敛的关系.考虑反证,<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,设可导点集为<span class="math inline">\(A\)</span>,则<span class="math inline">\(\exists n
, \sup_{ x \in A } ( f ( x ) - f_n ( x ) ) &lt; \epsilon\)</span>.</p>
<p>假设不一致收敛,此时<span class="math inline">\(\exists
x_0\)</span>使得<span class="math inline">\(f ( x_0 ) - f_n ( x_0 ) &gt;
4 \epsilon\)</span>.然而由于<span class="math inline">\(n\)</span>已经定死,所以现在<span class="math inline">\(f\)</span>和<span class="math inline">\(f_n\)</span>都是一致连续的,往旁边区间绕一下就行了.不管这个区间多小,由于<span class="math inline">\([ - \pi , \pi ] \setminus
A\)</span>是零测的,所以总有与<span class="math inline">\(A\)</span>的交.</p>
<p>从上面也可以看到,只要一个连续函数几乎处处可导,那它的傅里叶级数就可以一致逼近它.</p>
<h6><span id="example1">Example1</span></h6>
<p>设:</p>
<p><span class="math display">\[
\begin{aligned}
Q_{ m , n } &amp; &amp; = \sum_{ k = 1 }^n \frac{ \sin ( m + n - k ) x
}{ k } - \sum_{ k = 1 }^n \frac{ \sin ( m + n + k ) x }{ k } \\
&amp; &amp; = - 2 \cos ( m + n ) x \sum_{ v = 1 } \frac{ \sin ( vx ) }{
v }
\end{aligned}
\]</span></p>
<p>容易检查这个函数是有界的,只需:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ v = 1 }^n \frac{ \sin vx }{ v } &amp; &amp; = \int_0^x \sum_{ v =
1 }^n \cos vt \mathrm{ d } t \\
&amp; &amp; = \int_0^x ( - \frac{ 1 }{ 2 } + \frac{ \sin ( n + \frac{ 1
}{ 2 } ) t }{ 2 \sin \frac{ t }{ 2 } } ) \\
&amp; &amp; = - \frac{ x }{ 2 } + \int_0^x ( \frac{ 1 }{ 2 \sin \frac{ t
}{ 2 } } - \frac{ 1 }{ t } ) + \int_0^{ ( n + \frac{ 1 }{ 2 } ) x }
\frac{ \sin t }{ t } \mathrm{ d } t
\end{aligned}
\]</span></p>
<p>这样用黎曼引理立刻见到其有界,存在常数<span class="math inline">\(C\)</span>使得<span class="math inline">\(| \sum_{
v = 1 }^n \frac{ \sin vx }{ v } | \leq C\)</span>,那<span class="math inline">\(| Q_{ n , m } | \leq 2 C\)</span>也有界.</p>
<p>定义<span class="math inline">\(m_k = n_k = 2^{ k^3
}\)</span>,取函数<span class="math inline">\(\varphi ( x ) = \sum_{ k =
1 }^\infty \frac{ 1 }{ k^2 } Q_{ m_k , n_k } ( x )\)</span>,既然<span class="math inline">\(Q_{ m_k , n_k
}\)</span>有界,根据大M判别法,这个东西当然一致收敛而且<span class="math inline">\(2 \pi\)</span>周期连续.</p>
<p>既然如此,考察<span class="math inline">\(\varphi ( x
)\)</span>是奇函数,它的傅里叶展开的确就是上述形式(原因是连续函数有唯一傅里叶展开).</p>
<p>接下来考虑其波动考虑由于我们的<span class="math inline">\(m_k = n_k =
2^{ k^3 }\)</span>,所以其实这里很稀疏的,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
S_{ 2 n_k - 1 } ( x ) - S_{ n_k - 1 } ( x ) &amp; = \frac{ 1 }{ k^2 }
\left ( \sum_{ l = 1 }^{ n_k } \frac{ \sin ( 2 n_k - l ) x }{ l } \right
)
\end{aligned}
\]</span></p>
<p>接下来带入<span class="math inline">\(x = \frac{ \pi }{ 4 n_k
}\)</span>,见到:</p>
<p><span class="math display">\[
\begin{aligned}
( S_{ 2 n_k - 1 } - S_{ n_k - 1 } ) ( \frac{ \pi }{ 4 n_k } ) &amp; &gt;
\frac{ \sqrt{ 2 } }{ 2 } \frac{ 1 }{ k^2 } ( \sum_{ l = 1 }^{ n_k }
\frac{ 1 }{ l } ) \\
&amp; &gt; \frac{ \sqrt{ 2 } }{ 2 } \frac{ 1 }{ k^2 } \ln n_k \\
&amp; &gt; \frac{ \sqrt{ 2 } \ln 2 }{ 2 } k \\
&amp; \to \infty
\end{aligned}
\]</span></p>
<p>因此见到不一致收敛,很厉害!</p>
<h5><span id="cesaro收敛">Cesaro收敛</span></h5>
<p>接下来我们引入<strong>Cesaro收敛</strong>的概念,回忆到Stolz定理给出若取定<span class="math inline">\(\sigma_n = \frac{ a_1 + \cdots + a_n }{ n
}\)</span>,回忆到如果<span class="math inline">\(a_n \to
a\)</span>,则<span class="math inline">\(\sigma_n \to
a\)</span>,然而反之未必成立.因此,<span class="math inline">\(\sigma_n\)</span>如果收敛的话,这是一个比<span class="math inline">\(a_n\)</span>收敛弱的条件.</p>
<p>在傅里叶级数这里也引入这个概念,我们不再研究<span class="math inline">\(S_n ( x )\)</span>的收敛性,而考虑<span class="math inline">\(\sigma_n ( x ) = \frac{ S_0 ( x ) + \cdots + S_n (
x ) }{ n + 1 }\)</span>的收敛性.考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\sigma_n ( x ) &amp; = \frac{ S_0 ( x ) + \cdots + S_n ( x ) }{ n + 1 }
\\
&amp; = \frac{ 1 }{ ( n + 1 ) \pi } \int_{ - \pi }^\pi f ( x + t )
\frac{ \sum_{ k = 0 }^n \sin ( k + \frac{ 1 }{ 2 } ) t }{ 2 \sin \frac{
t }{ 2 } } \mathrm{ d } t \\
&amp; = \frac{ 1 }{ ( n + 1 ) \pi } \int_{ - \pi }^\pi f ( x + t )
\frac{ 1 - \cos ( n + 1 ) t }{ 2 \sin^2 \frac{ t }{ 2 } } \mathrm{ d } t
\\
&amp; = \frac{ 1 }{ ( n + 1 ) \pi } \int_{ - \pi }^\pi f ( x + t )
\frac{ \sin^2 ( \frac{ n + 1 }{ 2 } t ) }{ 2 \sin^2 \frac{ t }{ 2 } }
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>设费叶核<span class="math inline">\(\phi_n ( t ) = \frac{ \sin^2
\frac{ n + 1 }{ 2 } t }{ 2 ( n + 1 ) \sin^2 \frac{ t }{ 2 }
}\)</span>.容易见到<span class="math inline">\(\phi_n ( t ) = \phi_n ( -
t )\)</span>,<span class="math inline">\(\phi ( 0 ) = \frac{ n + 1 }{ 2
}\)</span>,而且<span class="math inline">\(\frac{ 1 }{ \pi } \int_{ -
\pi }^\pi \phi_n ( t ) \mathrm{ d } t = 1\)</span>,原因是<span class="math inline">\(\phi_n ( t
)\)</span>原本是个三角多项式,因此这里的积分只和其常数项有关,而常数项为<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>现在我们说,当<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi
)\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\([ - \pi , \pi ]\)</span>上绝对可积,并且<span class="math inline">\(f ( x_0 \pm 0 )\)</span>极限存在,则<span class="math inline">\(\lim_{ n \to \infty } \sigma_n ( x_n ) = \frac{ f
( x_0 + 0 ) + f ( x_0 - 0 ) }{ 2 }\)</span>.进一步,如果<span class="math inline">\(f \in C ( \mathbb{ R } )\)</span>,则<span class="math inline">\(\sigma_n ( x ) \rightrightarrows f ( x
)\)</span>.</p>
<p>考虑设<span class="math inline">\(I_n = \sigma_n ( x ) - \frac{ f ( x
+ 0 ) + f ( x - 0 ) }{ 2 }\)</span>,有:</p>
<p><span class="math display">\[
I_n = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi \phi_n ( t ) ( f ( x + t ) +
f ( x - t ) - f ( x + 0 ) - f ( x - 0 ) ) \mathrm{ d } t
\]</span></p>
<p>此时考虑<span class="math inline">\(f ( x \pm 0
)\)</span>存在意味着<span class="math inline">\(\forall \epsilon &gt; 0
, \exists \delta &gt; 0\)</span>,使得当<span class="math inline">\(0
&lt; t \leq \delta\)</span>的时候,总有<span class="math inline">\(| f (
x \pm t ) - f ( x \pm 0 ) | &lt; \frac{ \epsilon }{ 2 \pi
}\)</span>,于是我们上面的<span class="math inline">\(I_n\)</span>就可以拆成<span class="math inline">\(\int_0^\delta +
\int_\delta^\pi\)</span>两部分.</p>
<p>对于前者:</p>
<p><span class="math display">\[
\frac{ 1 }{ \pi } | \int_0^\delta | \leq \frac{ \epsilon }{ 2 \pi }
\int_0^\pi \phi_n ( t ) \mathrm{ d } t &lt; \frac{ \epsilon }{ 2 }
\]</span></p>
<p>对于后者只要能控制<span class="math inline">\(\max_{ [ \delta , \pi ]
} \phi_n ( t )\)</span>就行,而这是显然的,因为当<span class="math inline">\(t \geq
\delta\)</span>的时候,分母就有下界了,让<span class="math inline">\(n \to
\infty\)</span>的时候当然趋近于<span class="math inline">\(0\)</span>.所以<span class="math inline">\(\lim_{
n \to \infty } I_n = 0\)</span>.</p>
<p>接下来的疑问是当<span class="math inline">\(f\)</span>连续时为何一致收敛,这当然是因为<span class="math inline">\(f\)</span>是一致连续的,那我上述唯一涉及<span class="math inline">\(x\)</span>的地方,也就是当<span class="math inline">\(f ( x \pm t ) \to f ( x
)\)</span>的部分就可以被控制住,这就搞定了.</p>
<p>Cesaro收敛的另一个好处在于,当<span class="math inline">\(f ( x + 0
)\)</span>和<span class="math inline">\(f ( x - 0
)\)</span>存在的时候,由于如果逐点收敛一定就能导出Cesaro收敛,因此,如果傅里叶级数在某一点处收敛,则它必然也在这一点处Cesaro收敛且收敛于同一个<span class="math inline">\(\frac{ f ( x + 0 ) + f ( x - 0 ) }{ 2
}\)</span>,换言之如果收敛则一定收敛于此.</p>
<h5><span id="平均收敛">平均收敛</span></h5>
<p>考虑如果一列函数<span class="math inline">\(f_n\)</span>,如果<span class="math inline">\(\int | f_n - f | \to
0\)</span>则我们称这列函数<strong>平均收敛</strong>到<span class="math inline">\(f\)</span>.一个平均收敛的函数列可以处处点不收敛,一个逐点收敛的函数也可能并不平均收敛(因为积分不一定收敛).</p>
<p>考虑定义<strong>平方可积函数</strong><span class="math inline">\(f\)</span>为几乎处处连续而且只有有限个瑕点的<span class="math inline">\(f\)</span>并且满足<span class="math inline">\(\int_{ - \pi }^\pi f^2 \mathrm{ d } x &lt;
\infty\)</span>.容易见到闭区间上的平方可积要强于绝对可积,原因正是柯西不等式:</p>
<p><span class="math display">\[
\int_{ - \pi }^\pi | f | \mathrm{ d } x \leq \sqrt{ ( \int_{ - \pi }^\pi
f^2 \mathrm{ d } x ) ( \int_{ - \pi }^\pi 1 \mathrm{ d } x ) }
\]</span></p>
<p>从而看到如果<span class="math inline">\(\int ( f_n - f )^2 \mathrm{ d
} x \to 0\)</span>则当然有<span class="math inline">\(\int | f_n - f |
\mathrm{ d } x \to 0\)</span>,因此我们往往计算前者.</p>
<p>假设<span class="math inline">\(f\)</span>是平方绝对可积的,考虑定义<span class="math inline">\(\mathcal{ F }_n\)</span>为<span class="math inline">\(n\)</span>阶三角多项式组成的集合,设<span class="math inline">\(S_n\)</span>是<span class="math inline">\(f\)</span>的傅里叶展开的前<span class="math inline">\(n\)</span>项,我们有:</p>
<ol type="1">
<li><p><span class="math inline">\(\int_{ - \pi }^\pi ( f - S_n )^2
\mathrm{ d } x = \min_{ T_n \in \mathcal{ F }_n } \int_{ - \pi }^\pi ( f
- T_n )^2 \mathrm{ d } x\)</span>.</p></li>
<li><p><strong>Bessel不等式</strong>:<span class="math inline">\(\frac{
a_0^2 }{ 2 } + \sum_{ n = 1 }^\infty ( a_n^2 + b_n^2 ) \leq \frac{ 1 }{
\pi } \int_{ - \pi }^\pi f^2 \mathrm{ d } x\)</span>.</p></li>
<li><p><strong>Parseval等式</strong>:<span class="math inline">\(\frac{
a_0^2 }{ 2 } + \sum_{ n = 1 }^\infty ( a_n^2 + b_n^2 ) = \frac{ 1 }{ \pi
} \int_{ - \pi }^\pi f^2 \mathrm{ d } x\)</span>.</p></li>
<li><p><strong>广义Parseval等式</strong>:设<span class="math inline">\(f
, g\)</span>都平方可积,则<span class="math inline">\(\frac{ 1 }{ \pi }
\int_{ - \pi }^\pi fg \mathrm{ d } x = \frac{ a_0 ( f ) a_0 ( g ) }{ 2 }
+ \sum_{ n = 1 }^\infty ( a_n ( f ) a_n ( g ) + b_n ( f ) b_n ( g )
)\)</span>.</p></li>
</ol>
<p>先看(1)和(2),假设<span class="math inline">\(T_n = \frac{ A_0 }{ 2 }
+ \sum_{ k = 1 }^n A_k \cos ( kx ) + B_k \sin ( kx )\)</span>,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ - \pi }^\pi ( f - T_n )^2 \mathrm{ d } x \\
= &amp; \int_{ - \pi }^\pi f^2 \mathrm{ d } x + \pi \left ( \frac{ A_0^2
}{ 2 } + \sum_{ k = 1 }^n ( A_k^2 + B_k^2 ) \right ) - 2 \pi ( A_0
\frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n a_k A_k + b_k B_k ) \\
= &amp; \int_{ - \pi }^\pi f^2 \mathrm{ d } x + \pi \left ( \frac{ ( A_0
- a_0 )^2 }{ 2 } + \sum_{ k = 1 }^n ( a_k - A_k )^2 + ( b_k - B_k )^2
\right ) - \pi \left ( \frac{ a_0^2 }{ 2 } + \sum_{ k = 1 }^n a_k^2 +
b_k^2 \right ) \\
\geq &amp; \int_{ - \pi }^\pi f^2 \mathrm{ d } x - \pi \left ( \frac{
a_0^2 }{ 2 } + \sum_{ k = 1 }^n a_k^2 + b_k^2 \right ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>等号成立当且仅当<span class="math inline">\(A_k = a_k , B_k =
b_k\)</span>,这样上述两者就都证毕.</p>
<p>再看(3),由(1)和(2),只需要证明对于平方可积函数总存在一列三角多项式<span class="math inline">\(T_n\)</span>使得<span class="math inline">\(\lim_{
n \to \infty } \int_{ - \pi }^\pi ( f - T_n )^2 \mathrm{ d } x =
0\)</span>即可.</p>
<p>当<span class="math inline">\(f\)</span>是黎曼可积的时候这里较为平凡,只需要先用连续函数<span class="math inline">\(g\)</span>逼近<span class="math inline">\(f\)</span>,再用三角多项式逼近<span class="math inline">\(g\)</span>即可.最终因为有<span class="math inline">\(( T - f )^2 \leq 2 ( T - g )^2 + 2 ( f - g
)^2\)</span>就行.顺便一提这个不等式还可以证明平方可积的函数的和差也一定是平方可积.</p>
<p>接下来要把瑕点给处理掉,由于平方可积,所以瑕点那里的积分会足够小,直接把那一段抹平成<span class="math inline">\(0\)</span>就行.抹平了后的函数可以被逼近,而抹平带来的影响又很小,这就搞定了.</p>
<p>再看(4),对<span class="math inline">\(( f + g )\)</span>和<span class="math inline">\(( f - g
)\)</span>分别做Parseval等式,然后用它们一作差就能证明此结论.</p>
<p>关于Bessel不等式和Parseval等式,一个更好的理解是它体现了正交基上的操作,Bessel不等式说对于一组正交基我们总有<span class="math inline">\(\Vert u \Vert^2 \leq \sum_k ( u | e_k
)^2\)</span>成立.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:函数<span class="math inline">\(f , g\)</span>在<span class="math inline">\([ - \pi , \pi
]\)</span>上黎曼可积,则它们的傅里叶级数相同的充分必要条件是<span class="math inline">\(\int_{ - \pi }^\pi | f - g | \mathrm{ d } x =
0\)</span>.</p>
<p>先证明充分性,比较显然:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ - \pi }^\pi ( f - g ) \sin ( nx ) \mathrm{ d } x | \\
\leq &amp; \int_{ - \pi }^\pi | f - g | \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>再证必要性,也很显然,考虑如果傅里叶级数相同,则Parseval等式必有<span class="math inline">\(\int f^2 \mathrm{ d } x = \int g^2 \mathrm{ d } x
= \int fg \mathrm{ d } x\)</span>,这说明<span class="math inline">\(\int
( f - g )^2 \mathrm{ d } x = 0\)</span>,立刻推出<span class="math inline">\(\int | f - g | \mathrm{ d } x = 0\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:当<span class="math inline">\(b_n\)</span>单调递减趋近于<span class="math inline">\(0\)</span>的时候,如果<span class="math inline">\(\sum \frac{ b_n }{ n } &lt;
\infty\)</span>,则<span class="math inline">\(f ( x ) = \sum b_n \sin (
nx )\)</span>在<span class="math inline">\([ - \pi , \pi
]\)</span>上绝对可积.</p>
<p>不妨设<span class="math inline">\(x \in [ - \pi , \pi
]\)</span>,首先考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = n + 1 }^{ n + m } \sin ( kx ) | \\
= &amp; | \frac{ \cos ( n + m + \frac{ 1 }{ 2 } ) - \cos ( n + \frac{ 1
}{ 2 } ) }{ 2 \sin \frac{ x }{ 2 } } | \\
\leq &amp; \frac{ 1 }{ | \sin \frac{ x }{ 2 } | }
\end{aligned}
\]</span></p>
<p>此时考虑设<span class="math inline">\(S_m = \sum_{ k = n + 1 }^{ m }
\sin ( kx )\)</span>,取<span class="math inline">\(x \in [ \frac{ \pi }{
n + 1 } , \frac{ \pi }{ n } ]\)</span>,用Abel变换立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = n + 1 }^{ n + m } b_k \sin ( kx ) | \\
= &amp; | \sum_{ k = n + 1 }^{ n + m } b_k ( S_{ k } - S_{ k - 1 } ) |
\\
= &amp; | \sum_{ k = n + 1 }^{ n + m - 1 } ( b_{ k } - b_{ k + 1 } ) S_{
k } - b_{ n + 1 } S_{ n } + b_{ n + m } S_{ n + m } | \\
= &amp; | \sum_{ k = n + 1 }^{ n + m - 1 } ( b_{ k } - b_{ k + 1 } ) S_{
k } + b_{ n + m } S_{ n + m } | \\
\leq &amp; \frac{ b_n }{ | \sin \frac{ x }{ 2 } | } \\
\leq &amp; \frac{ \pi }{ x } b_{ n + 1 } \\
\leq &amp; ( n + 1 ) b_n
\end{aligned}
\]</span></p>
<p>这里已经和<span class="math inline">\(m\)</span>没有关系了,既然如此考虑取<span class="math inline">\(B_n = \sum_{ k = 1 }^n b_k\)</span>,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
\int_0^\pi | f | \mathrm{ d x } &amp; = \sum_{ n = 1 }^\infty \int_{
\frac{ \pi }{ n + 1 } }^{ \frac{ \pi }{ n } } | f | \mathrm{ d } x \\
&amp; \leq \sum_{ n = 1 }^\infty \int_{ \frac{ \pi }{ n + 1 } }^{ \frac{
\pi }{ n } } ( B_n + ( n + 1 ) b_n ) \mathrm{ d } x \\
&amp; = \sum_{ n = 1 }^\infty \frac{ \pi }{ n ( n + 1 ) } ( B_n + ( n +
1 ) b_n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时只需检验<span class="math inline">\(\sum \frac{ B_n }{ n ( n + 1
) }\)</span>收敛就行了对吧.这个比较平凡:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 1 }^\infty \frac{ B_n }{ n ( n + 1 ) } &amp; = \sum_{ n = 1
}^\infty \frac{ 1 }{ n ( n + 1 ) } \sum_{ k = 1 } b_k \\
&amp; = \sum_{ k = 1 }^\infty b_k \sum_{ n = k }^\infty \frac{ 1 }{ n (
n + 1 ) } \\
&amp; = \sum_{ k = 1 }^\infty \frac{ b_k }{ k } \\
&amp; &lt; \infty
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h5><span id="逐项积分">逐项积分</span></h5>
<p>设<span class="math inline">\(f\)</span>绝对可积,其傅里叶级数为<span class="math inline">\(\frac{ a_0 }{ 2 } + \sum a_n \cos ( nx ) + b_n
\sin ( nx )\)</span>,考虑取<span class="math inline">\(F ( x ) =
\int_0^x ( f ( t ) - \frac{ a_0 }{ 2 } ) \mathrm{ d }
t\)</span>,容易检查<span class="math inline">\(F ( x
)\)</span>是有界变差的,原因是<span class="math inline">\(\sum | F ( x_i
) - F ( x_{ i - 1 } ) | = \sum | \int_{ x_{ i - 1 } }^{ x_i } f ( t )
\mathrm{ d } t | \leq \int | f |\)</span>.</p>
<p>既然如此,它就会被它的傅里叶级数一致逼近,不妨记作<span class="math inline">\(F ( x ) = \frac{ A_0 }{ 2 } + \sum_{ n = 1
}^\infty A_n \cos ( nx ) + B_n \sin ( nx )\)</span>.</p>
<p>接下来考虑把这些系数都求出来,先令<span class="math inline">\(x =
0\)</span>求出<span class="math inline">\(\frac{ A_0 }{ 2 } + \sum_{ n =
1 }^\infty A_n = 0\)</span>,当<span class="math inline">\(n \geq
1\)</span>的时候,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
A_n &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi F ( x ) \cos ( nx )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } F ( x ) \frac{ \sin ( nx ) }{ n } |_{ - \pi
}^\pi - \frac{ 1 }{ n \pi } \int_{ - \pi }^\pi f ( x ) \sin ( nx )
\mathrm{ d } x \\
&amp; = - \frac{ b_n }{ n }
\end{aligned}
\]</span></p>
<p>注意这里用的分部积分是广义分部积分,我们曾经搞过.</p>
<p>同理<span class="math inline">\(B_n = \frac{ a_n }{ n
}\)</span>,补一个<span class="math inline">\(x\)</span>的傅里叶级数进去,于是我们见到:</p>
<p><span class="math display">\[
\int_0^x f ( t ) \mathrm{ d } t = \frac{ a_0 }{ 2 } x + \sum_{ n = 1
}^\infty a_n \int_0^x \cos ( nt ) \mathrm{ d } t + b_n \int_0^x \sin (
nt ) \mathrm{ d } t
\]</span></p>
<p>也就是一个函数和傅里叶级数逐项积分后总相等.</p>
<h5><span id="逐项微分">逐项微分</span></h5>
<p>设<span class="math inline">\(f\)</span>可导而且是<span class="math inline">\(2 \pi\)</span>周期的,并且<span class="math inline">\(\int_{ - \pi }^\pi | f &#39; | \mathrm{ d } x &lt;
\infty\)</span>,那由逐项积分那里的结论,自然有<span class="math inline">\(a_0 ( f &#39; ) = 0 , a_n ( f &#39; ) = nb_n ( f )
, b_n ( f &#39; ) = - na_n ( f )\)</span>,也就是当:<span class="math inline">\(f = \frac{ a_0 }{ 2 } + \sum a_n \cos ( nx ) + b_n
\sin ( nx )\)</span>,则<span class="math inline">\(f &#39; \sim \sum -
na_n \sin ( nx ) + nb_n \cos ( nx )\)</span>.</p>
<h5><span id="收敛速度的估计">收敛速度的估计</span></h5>
<p>最后来分析一下它的收敛能力,不妨假设<span class="math inline">\(f\)</span>是<span class="math inline">\(2
\pi\)</span>周期逐段可导函数,并且<span class="math inline">\(\int_{ -
\pi }^{ \pi } ( f &#39; )^2 \mathrm{ d } x &lt; \infty\)</span>,则<span class="math inline">\(\max | f ( x ) - S_n ( x ) | = o ( \frac{ 1 }{
\sqrt{ n } } )\)</span>,原因是由Parseval等式,有:</p>
<p><span class="math display">\[
\frac{ 1 }{ \pi } \int_{ - \pi }^\pi ( f &#39; )^2 \mathrm{ d } x =
\frac{ a_0 ( f &#39; )^2 }{ 2 } + \sum_{ n = 1 }^\infty ( a_n ( f &#39;
)^2 + b_n ( f &#39; )^2 )
\]</span></p>
<p>也就是后面这个级数收敛对吧,那柯西准则给出:</p>
<p><span class="math display">\[
\sum_{ k = n + 1 }^\infty ( a_k ( f &#39; )^2 + b_k ( f &#39; )^2 ) = o
( 1 )
\]</span></p>
<p>现在来看误差项:</p>
<p><span class="math display">\[
\begin{aligned}
| f ( x ) - S_n ( x ) | &amp; \leq | \sum_{ k = n + 1 }^\infty a_k ( f )
\cos ( kx ) + b_k ( f ) \sin ( kx ) | \\
&amp; \leq \sum_{ k = n + 1 }^\infty | a_k ( f ) | + | b_k ( f ) | \\
&amp; = \sum_{ k = n + 1 }^\infty \frac{ | a_k ( f &#39; ) | + | b_k ( f
&#39; ) | }{ k } \\
&amp; \leq \sqrt{ \sum_{ k = n + 1 }^\infty | a_k ( f &#39; )^2 | + |
b_k ( f &#39; )^2 | } \sqrt{ \sum_{ k = n + 1 }^\infty \frac{ 1 }{ k^2 }
} \\
&amp; = o ( 1 ) \frac{ 1 }{ \sqrt{ n } }
\end{aligned}
\]</span></p>
<h5><span id="复数形式">复数形式</span></h5>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; \sim \frac{ a_0 }{ 2 } + \sum a_n \cos ( nx ) + b_n \sin (
nx ) \\
&amp; = \frac{ a_0 }{ 2 } + \sum a_n \frac{ e^{ inx } + e^{ - inx } }{ 2
} + \sum b_n \frac{ e^{ inx } - e^{ - inx } }{ 2 i } \\
&amp; = \sum_{ n = - \infty }^\infty c_n e^{ inx }
\end{aligned}
\]</span></p>
<p>此时有<span class="math inline">\(c_n = \frac{ 1 }{ 2 \pi } \int_{ -
\pi }^\pi f ( x ) e^{ - inx } \mathrm{ d } x\)</span>.</p>
<h5><span id="三角级数的唯一性问题">三角级数的唯一性问题</span></h5>
<p>接下来来解决点看上去很平凡的问题,如果:</p>
<p><span class="math display">\[
\frac{ a_0 }{ 2 } + \sum_{ n = 1 }^\infty a_n \cos ( nx ) + b_n \sin (
nx ) = \frac{ \tilde{ a_0 } }{ 2 } + \sum_{ n = 1 }^\infty \tilde{ a_n }
\cos ( nx ) + \tilde{ b_n } \sin ( nx )
\]</span></p>
<p>而且左右两端都收敛到某个函数.能否导出<span class="math inline">\(a_n
= \tilde{ a_n } , b_n = \tilde{ b_n
}\)</span>.注意这里并不能两遍乘个<span class="math inline">\(\cos ( nx
)\)</span>然后积分,因为未必可积.</p>
<p>我们下面可以证明,如果上面这种相等除了至多可数个点以外都成立,那就是同一个三角级数.当然只需要证明当:</p>
<p><span class="math display">\[
\frac{ a_0 }{ 2 } + \sum_{ n = 1 }^\infty a_n \cos ( nx ) + b_n \sin (
nx ) = 0
\]</span></p>
<p>至多除了一个可数集合<span class="math inline">\(E = \{ x_1 , x_2 ,
\cdots \}\)</span>以外成立的时候有<span class="math inline">\(a_n = b_n
= 0\)</span>即可.</p>
<p>先来证明一个引理:此时<span class="math inline">\(\lim_{ n \to \infty
} a_n = \lim_{ n \to \infty } b_n =
0\)</span>.这还并不显然,因为这个三角级数并不一定是傅里叶级数.</p>
<p>首先级数收敛,通项趋近于<span class="math inline">\(0\)</span>,首先设<span class="math inline">\(\rho_n = \sqrt{ a_n^2 + b_n^2 }\)</span>,则<span class="math inline">\(a_n \cos ( nx ) + b_n \sin ( nx ) = \rho_n \sin (
nx + \varphi_n )\)</span>.现在只需要证明<span class="math inline">\(\lim_{ n \to \infty } \rho_n = 0\)</span>.</p>
<p>反证,如果没有上述结论,则总存在一个无穷子列<span class="math inline">\(\{ \rho_{ n_k } \}_k\)</span>大于某一个正常数<span class="math inline">\(c\)</span>,设其指标集合为<span class="math inline">\(F = \{ n_1 &lt; n_2 &lt; \cdots \}\)</span>.</p>
<p>现在考虑<span class="math inline">\([ 0 , 2 \pi
]\)</span>上,找一个区间<span class="math inline">\(I_1 = [ l_1 , r_1
]\)</span>使得其不含有<span class="math inline">\(x_1\)</span>,由于<span class="math inline">\(F\)</span>通项肯定趋近无穷大,总能找到一个<span class="math inline">\(m_1 \in F\)</span>,使得<span class="math inline">\(| [ m_1 l_1 , m_1 r_1 ] | = m_1 | I_1 | &gt; 2
\pi\)</span>.既然它的区间长度足够大,那其中总有一个子区间<span class="math inline">\(J_1 \subseteq I_1\)</span>,使得<span class="math inline">\(\sin ( m_1 x + \varphi_{ m_1 } ) &gt; \frac{ 1 }{
2 }\)</span>在<span class="math inline">\(J_1\)</span>上成立.那我当然可以再找一个子区间<span class="math inline">\(I_2 \subseteq J_1\)</span>使得<span class="math inline">\(I_2\)</span>中不含有<span class="math inline">\(x_2\)</span>,重复以上操作,这就是一个闭区间套.最后套出来了一个点<span class="math inline">\(w \notin E\)</span>,此时<span class="math inline">\(\sin ( m_k w + \varphi_{ m_k } ) &gt; \frac{ 1 }{
2 }\)</span>,自然有<span class="math inline">\(\varphi_{ m_k } \sin (
m_k w + \varphi_{ m_k } ) &gt; \frac{ c }{ 2
}\)</span>,这立刻导出矛盾.</p>
<p>再来一个引理:假设<span class="math inline">\(F ( x ) \in C ( a , b
)\)</span>,可数集合<span class="math inline">\(E \subseteq ( a , b
)\)</span>.定义其<strong>二阶差分</strong>为<span class="math inline">\(\Delta_h^2 F ( x ) = F ( x + 2 h ) + F ( x - 2 h )
- 2 F ( x )\)</span>.已知其<strong>广义二阶导数</strong><span class="math inline">\(\delta^2 F = \varlimsup_{ h \to + 0 } \frac{
\Delta_h^2 F ( x ) }{ 4 h^2 } \geq 0 , \forall x \notin
E\)</span>,而<span class="math inline">\(\varlimsup_{ h \to + 0 } \frac{
\Delta_h^2 F ( x ) }{ h } \geq 0 , \forall x \in
E\)</span>.则结论是<span class="math inline">\(F ( x
)\)</span>是一个下凸函数.</p>
<p>这个结论的自然之处在于如果<span class="math inline">\(F &#39; &#39; (
x )\)</span>存在,那<span class="math inline">\(F ( x + 2 h ) = F ( x ) +
F &#39; ( x ) 2 h + \frac{ F &#39; &#39; ( x ) }{ 2 } ( 2 h )^2 + o (
h^2 )\)</span>并且<span class="math inline">\(F ( x - 2 h ) = F ( x ) -
F &#39; ( x ) 2 h + \frac{ F &#39; &#39; ( x ) }{ 2 } ( 2 h )^2 + o (
h^2 )\)</span>,所以上面那个<span class="math inline">\(\delta^2 F = F
&#39; &#39; ( x )\)</span>,那如果它非负当然是下凸函数.</p>
<p>那如果<span class="math inline">\(F &#39; &#39; ( x
)\)</span>不存在呢?反证,假设<span class="math inline">\(F\)</span>不凸,则一定存在一个子区间<span class="math inline">\(( \alpha , \beta ) \subseteq ( a , b
)\)</span>,使得在这个区间上,<span class="math inline">\(F ( x
)\)</span>函数在<span class="math inline">\(( \alpha , \beta
)\)</span>这条弦之上(因为连续性,至少有三个点是违背三弦定理的,作一条弦后,函数有一些部分在上面有一些部分在下面,取某个恒在上面的子区间即可).</p>
<p>总之,我们找到了一个子区间<span class="math inline">\(( \alpha , \beta
)\)</span>使得:</p>
<p><span class="math display">\[
F ( x ) - \left ( \frac{ F ( \beta ) - F ( \alpha ) }{ \beta - \alpha }
( x - \alpha ) + F ( \alpha ) \right ) &gt; 0
\]</span></p>
<p>接下来要推矛盾,分成两种情况:</p>
<p>第一种情况是<span class="math inline">\(\delta^2 F &gt;
0\)</span>的情形,考虑辅助函数<span class="math inline">\(G_\mu ( x ) = F
( x ) - ( \mu ( x - a ) + F ( \alpha ) )\)</span>,其中<span class="math inline">\(\mu = \frac{ F ( \beta ) - F ( \alpha ) }{ \beta -
\alpha } +
\epsilon\)</span>,也就是比原本那条弦的斜率稍微大了一点点,那只要<span class="math inline">\(\epsilon\)</span>落在某个足够小的区间内,<span class="math inline">\(G_\mu ( x )\)</span>仍然有大于零的部分.直接取<span class="math inline">\(G_\mu ( x_0 ( \mu ) ) = \max_{ [ \alpha , \beta ]
} G_\mu\)</span>,此时观察到<span class="math inline">\(G_\mu\)</span>和<span class="math inline">\(F\)</span>只差一个一次函数,它们作二阶差分后就相等了,然而,由于<span class="math inline">\(G_\mu ( x_0 ( \mu ) )\)</span>取的是最大值,当<span class="math inline">\(h\)</span>取足够小的时候,它的二阶差分一定小于等于<span class="math inline">\(0\)</span>,因此能导出<span class="math inline">\(x_0 ( \mu ) \in E\)</span>,并且同理能导出<span class="math inline">\(\varlimsup_{ h \to + 0 } \frac{ \Delta_h^2 F ( x_0
( \mu ) ) }{ h } = 0\)</span>.从而导出:</p>
<p><span class="math display">\[
\varlimsup_{ h \to + 0 } \frac{ G_\mu ( x_0 ( \mu ) - 2 h ) - G_\mu (
x_0 ( \mu ) ) }{ h } = \varlimsup_{ h \to + 0 } \frac{ G_\mu ( x_0 ( \mu
) + 2 h ) - G_\mu ( x_0 ( \mu ) ) }{ h } = 0
\]</span></p>
<p>欸,你怎么变一阶差分了,那我的一次函数不就有用了么,必定有:</p>
<p><span class="math display">\[
\varlimsup_{ h \to + 0 } \frac{ F ( x_0 ( \mu ) - 2 h ) - F ( x_0 ( \mu
) ) }{ h } = 2 \mu
\]</span></p>
<p>所以<span class="math inline">\(\mu \to x_0 ( \mu
)\)</span>为单射,这与<span class="math inline">\(x_0 ( \mu ) \in
E\)</span>矛盾.</p>
<p>那么等于<span class="math inline">\(0\)</span>的情况呼之欲出了对吧,此时任意的<span class="math inline">\(n\)</span>都可以做到<span class="math inline">\(F
( x ) + \frac{ x^2 }{ n }\)</span>是凸的,随便搞个反证法就可以知道<span class="math inline">\(F ( x )\)</span>必定是凸的.</p>
<p>最后来设<span class="math inline">\(F ( x ) = \frac{ a_0 }{ 4 } x^2 -
\sum_{ n = 1 }^\infty \frac{ a_n \cos ( nx ) + b_n \sin ( nx ) }{ n^2
}\)</span>,由于<span class="math inline">\(a_n \to 0 , b_n \to
0\)</span>,所以这玩意用大M判别法知道绝对一致收敛,那就是一个连续函数.</p>
<p>此时计算:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta_h^2 F ( x ) &amp; = \frac{ a_0 }{ 4 } ( ( x + 2 h )^2 + ( x - 2 h
)^2 - 2 x^2 ) \\
&amp; - \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } ( a_n ( \cos ( n ( x + 2
h ) ) + \cos ( n ( x - 2 h ) ) - 2 \cos ( nx ) ) \\
&amp; + b_n ( \sin ( n ( x + 2 h ) ) + \sin ( n ( x - 2 h ) ) - 2 \sin (
nx ) ) ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而此时对后面的部分用和差化积,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \cos ( n ( x + 2 h ) ) + \cos ( n ( x - 2 h ) ) - 2 \cos ( nx ) \\
= &amp; 2 \cos ( nx ) \cos ( 2 nh ) - 2 \cos ( nx ) \\
= &amp; 2 \cos ( nx ) ( \cos ( 2 nh ) - 1 ) \\
= &amp; - 4 \cos ( nx ) \sin^2 ( nh )
\end{aligned}
\]</span></p>
<p>于是:</p>
<p><span class="math display">\[
\frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } = \frac{ a_0 }{ 2 } + \sum_{ n = 1
}^\infty ( a_n \cos ( nx ) + b_n \sin ( nx ) ) ( \frac{ \sin ( nh ) }{
nh } )^2
\]</span></p>
<p>乍一看已经要完事了对吧!很可惜并没有,因为这个<span class="math inline">\(n \to
\infty\)</span>了,我们还需要证明下面这个引理:当<span class="math inline">\(\sum_{ n = 1 }^\infty a_n =
s\)</span>收敛的时候,那么<span class="math inline">\(\lim_{ h \to 0 + }
\sum_{ n = 1 }^\infty a_n ( \frac{ \sin ( nh ) }{ nh } )^2 =
s\)</span>.</p>
<p>最难过的是这里的<span class="math inline">\(a_n\)</span>不定号,我们可能第一反应是前部分可以让<span class="math inline">\(n \to
\infty\)</span>而后半部分可以直接抛掉,可在不定号的时候这一切都难以实现了.对于不定号项的求和,我们也许唯一的武器只有Abel变换.设<span class="math inline">\(a_0 = 0 , b_n ( h ) = ( \frac{ \sin ( nh ) }{ nh }
)^2 , b_0 ( h ) = 1 , S_n = \sum_{ k = 1 }^n a_k\)</span>.立刻得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 0 }^\infty a_n b_n ( h ) &amp; = \sum_{ n = 1 }^\infty ( S_n
- S_{ n - 1 } ) b_n ( h ) \\
&amp; = \sum_{ n = 0 }^\infty S_n ( b_n ( h ) - b_{ n + 1 } ( h ) )
\end{aligned}
\]</span></p>
<p>既然<span class="math inline">\(S_n\)</span>收敛,不妨设<span class="math inline">\(| S_n | &lt; M\)</span>,下面来估计:</p>
$$
<span class="math display">\[\begin{aligned}
| b_{ n + 1 } ( h ) - b_{ n } ( h ) | &amp; = | \int_{ nh }^{ ( n + 1 )
h } ( \frac{ \sin^2 t }{ t^2 } ) &#39; \mathrm{ d } t | \\
&amp; \leq \int_{ nh }^{ ( n + 1 ) h } | \frac{ 2 \sin t ( \cos t -
\frac{ \sin t }{ t } ) }{ t^2 } | \mathrm{ d } t \\
\sum | b_{ n + 1 } ( h ) - b_{ n } ( h ) | &amp; \leq \int_{ 0 }^{ +
\infty } | \frac{ 2 \sin t ( \cos t - \frac{ \sin t }{ t } ) }{ t^2 } |
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>盯着这个积分,发现其在<span class="math inline">\(0\)</span>附近极限存在(泰勒展开就能看到),而在无穷处其实就是<span class="math inline">\(O ( \frac{ 1 }{ t^2 }
)\)</span>,所以这个积分存在,当然有<span class="math inline">\(\sum | b_{
n + 1 } ( h ) - b_{ n } ( h ) | \leq +
\infty\)</span>,其实上面的过程就是在证明这个函数是有界变差的对吧!准备工作业已就绪,不妨设<span class="math inline">\(\varphi_n = b_n ( h ) - b_{ n + 1 } ( h
)\)</span>,请看:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ n = 0 }^\infty a_n b_n ( h ) - s | \\
= &amp; | \sum_{ n = 0 }^\infty ( s_n \varphi_n ( h ) - s \varphi_n ( h
) ) | \\
\leq &amp; \sum_{ n = 0 }^N | S_n - s | \cdot | \varphi_n ( h ) | +
\sum_{ n = N + 1 }^\infty | S_n - s | \cdot | \varphi_n ( h ) |
\end{aligned}
\]</span></p>
<p>只要取定足够大的<span class="math inline">\(N\)</span>就可以使得<span class="math inline">\(| S_n - s | \to 0\)</span>,而在此时只要让<span class="math inline">\(h \to 0\)</span>就可以让前半部分定死的<span class="math inline">\(\varphi_n ( h ) \to 0\)</span>,于是就搞定了.</p>
<p>从而我们可以看到上述引理的确成立了,进一步地两个上极限都等于<span class="math inline">\(0\)</span>,所以<span class="math inline">\(F ( x
)\)</span>的确是下凸函数,然而正是因为等于<span class="math inline">\(0\)</span>,所以<span class="math inline">\(- F ( x
)\)</span>也是下凸函数,所以<span class="math inline">\(F ( x
)\)</span>既是上凸,又是下凸,那它必然是一个一次函数.那<span class="math inline">\(a_0 = 0\)</span>就是必然的了.既然<span class="math inline">\(a_0 = 0\)</span>,<span class="math inline">\(F ( x
)\)</span>就是一个<span class="math inline">\(2
\pi\)</span>周期函数,所以它必然是常值函数.然而一个三角级数一致收敛到一个常值函数,这个三角级数本身必然是常值函数,所以<span class="math inline">\(a_n = b_n = 0\)</span>,这就搞定了.</p>
<h5><span id="傅里叶级数的最佳逼近性">傅里叶级数的最佳逼近性</span></h5>
<p>下面我们想证明:傅里叶级数是最佳逼近,如果一个三角级数处处收敛到了一个黎曼可积函数,则这个三角级数就是这个函数的傅里叶级数.(事实上这个结论在绝对可积时也是对的,甚至可以有有限个点不收敛到它)</p>
<p>不妨设<span class="math inline">\(f \in R [ - \pi , \pi
]\)</span>,有界<span class="math inline">\(m \leq f \leq
M\)</span>.三角级数<span class="math inline">\(\frac{ a_0 }{ 2 } + \sum
a_n \cos ( nx ) + b_n \sin ( nx
)\)</span>逐点逼近于它本身.我们上面引入的也就是<span class="math inline">\(\delta^2 F ( x_0 ) = f ( x_0 )\)</span>.</p>
<p>来引入一个引理:如果<span class="math inline">\(\forall x_0 \in ( a ,
b ) , \delta^2 F = \lim_{ h \to + 0 } \frac{ \Delta_h^2 F }{ 4 h^2 } \in
[ m , M ]\)</span>,则不加极限的情况,<span class="math inline">\(\forall
x_0 \in ( a + h , b - h ) , h &gt; 0 , \frac{ \Delta_h^2 F }{ 4 h^2 }
\in [ m , M ]\)</span>.</p>
<p>我想这应该是平凡的,方向呼之欲出:使用介值定理.不过这里是二次函数,那我们就取定<span class="math inline">\(F ( x_0 ) , F ( x_0 \pm 2 h
)\)</span>三个点,过这三个点做一个二次函数.事实上这个二次函数就是<span class="math inline">\(\varphi ( x ) = F ( x_0 ) + ( x - x_0 ) \frac{ F (
x_0 + 2 h ) - F ( x_0 - 2 h ) }{ 4 h } + \frac{ ( x - x_0 )^2 }{ 2 }
\frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 }\)</span>.取<span class="math inline">\(g ( x ) = F ( x ) - \varphi ( x )\)</span>,则<span class="math inline">\(g ( x )\)</span>会在<span class="math inline">\(x_0 , x_0 \pm 2 h\)</span>取值为<span class="math inline">\(0\)</span>,并且其在<span class="math inline">\((
x_0 - 2 h , x_0 + 2 h )\)</span>上肯定有一个最大值<span class="math inline">\(x_1\)</span>和一个最小值<span class="math inline">\(x_2\)</span>,在前者的广义二阶导数<span class="math inline">\(\leq 0\)</span>而后者<span class="math inline">\(\geq 0\)</span>,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\delta^2 F ( x_1 ) - \frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 } &amp; \leq 0
\leq \delta^2 F ( x_2 ) - \frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 } \\
m &amp; \leq \frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 } \leq M
\end{aligned}
\]</span></p>
<p>现在我们就知道如何做了,回忆到:</p>
<p><span class="math display">\[
\frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } = \frac{ a_0 }{ 2 } + \sum_{ n = 1
}^\infty ( a_n \cos ( nx ) + b_n \sin ( nx ) ) ( \frac{ \sin ( nh ) }{
nh } )^2
\]</span></p>
<p>当我不取<span class="math inline">\(h \to
0\)</span>的时候这个两边可是一致收敛的.那右边肯定是前边的傅里叶级数,立刻有:</p>
$$
<span class="math display">\[\begin{aligned}
a_n ( \frac{ \sin ( nh ) }{ nh } )^2 &amp; = \frac{ 1 }{ \pi } \int_{ -
\pi }^\pi \frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d }
x \\
b_n ( \frac{ \sin ( nh ) }{ nh } )^2 &amp; = \frac{ 1 }{ \pi } \int_{ -
\pi }^\pi \frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } \sin ( nx ) \mathrm{ d }
x \\

\end{aligned}\]</span>
<p>$$</p>
<p>那我们自然有:</p>
$$
<span class="math display">\[\begin{aligned}
a_n &amp; = \lim_{ h \to + 0 } a_n ( \frac{ \sin ( nh ) }{ nh } )^2 \\
&amp; = \lim_{ h \to + 0 } \frac{ 1 }{ \pi } \int_{ - \pi }^\pi \frac{
\Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>然而此时<span class="math inline">\(\frac{ \Delta_h^2 F ( x ) }{ 4
h^2 } \in [ m , M ]\)</span>,后面积分那个东西有界.欸,取<span class="math inline">\(h = \frac{ 1 }{ n } \to
0\)</span>可以拿到一个一致有界的函数列,这不是我们控制收敛定理么,交换顺序!</p>
$$
<span class="math display">\[\begin{aligned}
a_n &amp; = \lim_{ h \to + 0 } \frac{ 1 }{ \pi } \int_{ - \pi }^\pi
\frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi \lim_{ h \to + 0 } \frac{
\Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) \cos ( nx )
\mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>这就证毕了.</p>
<h5><span id="傅里叶级数不逐点收敛到自身的连续周期函数">傅里叶级数不逐点收敛到自身的连续周期函数</span></h5>
<p>定义<span class="math inline">\(C ( T )\)</span>为<span class="math inline">\(2
\pi\)</span>周期连续函数组成的线性空间.此时定义<span class="math inline">\(\Vert f - g \Vert = \sup | f - g
|\)</span>,其实也就是Banach空间对吧.有了范数定义距离,有了距离就可以有开闭集的概念.Baire纲定理告诉我们此时可数个开稠集的交集仍然是稠密集(不过未必是开集).</p>
<p>现在考虑<span class="math inline">\(f ( x
)\)</span>的傅里叶级数,取<span class="math inline">\(S_n ( f , x ) =
\frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n a_k \cos ( kx ) + b_k \sin ( kx
)\)</span>,迪利克雷核的结论告诉我们<span class="math inline">\(S_n ( f ,
x ) = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( t ) D_n ( x - t )
\mathrm{ d } t\)</span>,其中<span class="math inline">\(D_n ( w ) =
\frac{ \sin ( n + \frac{ 1 }{ 2 } ) w }{ 2 \sin \frac{ w }{ 2 }
}\)</span>.</p>
<p>接下来定义<span class="math inline">\(\varphi_f ( x ) = \sup_{ n \geq
1 } | S_n ( f , x ) |\)</span>,取<span class="math inline">\(E_m ( x ) =
\{ f \in C ( T ) | \varphi_f ( x ) &gt; m
\}\)</span>.下面我们来证明:<span class="math inline">\(E_m ( x
)\)</span>是<span class="math inline">\(C ( T )\)</span>的开稠子集.</p>
<p>是开集应该是自然的结论,因为当<span class="math inline">\(n ,
x\)</span>定死的时候,<span class="math inline">\(S_n ( f , x
)\)</span>从定义看是连续地依赖于<span class="math inline">\(f\)</span>.如果<span class="math inline">\(f \in
E_m ( x )\)</span>,则<span class="math inline">\(\exists n , | S_n ( f ,
x ) | &gt; m\)</span>,那它周围当然有一个小邻域,使得其中的<span class="math inline">\(g\)</span>都满足<span class="math inline">\(| S_n
( g , x ) | &gt; m\)</span>了,所以这肯定是开集.</p>
<p>接下来得证明它是稠集,定义<span class="math inline">\(g_n ( t ) =
\begin{cases}1 &amp; D_n ( t ) \geq 1 \\ - 1 &amp; D_n ( t ) \leq - 1 \\
D_n ( t ) &amp; \text{ otherwise }\end{cases}\)</span>.此时发现:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \pi } \int_{ - \pi }^\pi g_n ( t ) D_n ( t ) \mathrm{
d } t \\
= &amp; O ( 1 ) + \frac{ 1 }{ \pi } \int_{ - \pi }^\pi | D_n ( t ) |
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>原因是<span class="math inline">\(| D_n ( t ) | \geq
1\)</span>的部分二者相等,而不同的部分在有限区间上积分不会太大.</p>
<p>然而:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ 1 }{ \pi } \int_{ - \pi }^\pi | D_n ( t ) | \mathrm{ d } t
\\
= &amp; \frac{ 2 }{ \pi } \int_0^\pi | D_n ( t ) | \mathrm{ d } t \\
= &amp; \frac{ 1 }{ \pi } \int_0^\pi | \frac{ \sin ( n + \frac{ 1 }{ 2 }
) t }{ 2 \sin \frac{ t }{ 2 } } | \mathrm{ d } t \\
&gt; &amp; \frac{ 1 }{ \pi } \int_0^\pi | \frac{ \sin ( n + \frac{ 1 }{
2 } ) t }{ t } | \mathrm{ d } t \\
&gt; &amp; \frac{ 1 }{ \pi } \int_0^{ ( n + \frac{ 1 }{ 2 } ) \pi }
\frac{ | \sin t | }{ t } \mathrm{ d } t \\
&gt; &amp; \frac{ 1 }{ \pi } \sum_{ k = 2 }^n \int_{ ( k - 1 ) \pi }^{ k
\pi } \frac{ | \sin t | }{ t } \mathrm{ d } t \\
= &amp; \sum_{ k = 2 }^n O ( 1 ) \frac{ 1 }{ k } \\
= &amp; O ( \ln n )
\end{aligned}
\]</span></p>
<p>接下来考虑取<span class="math inline">\(h_n = \frac{ g_n }{ \sqrt{ ln
n } } \to 0\)</span>,则<span class="math inline">\(S_n ( h_n , x ) = O (
\sqrt{ \ln n } )\)</span>.此时设<span class="math inline">\(U_{ \epsilon
} ( f ) = \{ g \in C ( T ) | \Vert f - g \Vert &lt; \epsilon
\}\)</span>,回忆到三角多项式可以一致逼近任何连续周期函数,所以存在三角多项式(有限项)<span class="math inline">\(T \in U_{ \frac{ \epsilon }{ 2 } } ( f
)\)</span>.</p>
<p>取<span class="math inline">\(r_n ( x ) = T + h_n\)</span>,由于<span class="math inline">\(h_n \to 0\)</span>,所以当<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(r_n ( x ) = g + h_n \in U_\epsilon ( f
)\)</span>.此时<span class="math inline">\(S_n ( r_n , x ) = S_n ( T , x
) + S_n ( h_n , x )\)</span>,但是<span class="math inline">\(T\)</span>是有限项三角多项式,所以<span class="math inline">\(S_n ( r_n , x ) = O ( 1 ) + O ( \sqrt{ \ln n } )
\to \infty\)</span>.这就搞定了,那此时<span class="math inline">\(r_n \in
E_m ( x )\)</span>而且在<span class="math inline">\(f\)</span>的邻域里.所以这个集合是稠密的.</p>
<p>接下来取<span class="math inline">\(E_x = \bigcap_{ m = 1 }^\infty
E_m ( x )\)</span>,容易发现<span class="math inline">\(E_x\)</span>中的所有函数在<span class="math inline">\(x\)</span>这一点的傅里叶级数竟然都无界,我可以干脆取<span class="math inline">\(E = \bigcap_{ x \in \mathbb{ Q } }
E_x\)</span>,则这里面存在一个函数,这个函数的傅里叶级数在任意有理点处发散.</p>
<p>其实还可以更牛,取<span class="math inline">\(F_m ( f ) = \{ x \in
\mathbb{ R } | \varphi_f ( x ) &gt; m \}\)</span>,这显然是个开集.取<span class="math inline">\(F_f = \bigcap_{ n = 1 }^\infty
F_n\)</span>,这就是可数个开集的交.而且从上面的论证可以发现<span class="math inline">\(\mathbb{ Q } \subseteq
F_f\)</span>,可是这里的<span class="math inline">\(\mathbb{ Q
}\)</span>是稠密的,所以<span class="math inline">\(F_f\)</span>必然也是稠密的,那它就是可数个开稠集的交,有结论说可数个开稠集的交一定是不可数集合.</p>
<p>然而,还有结论说一个周期连续函数的傅里叶级数其实几乎处处收敛于本身.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f ( x )\)</span>是<span class="math inline">\(2 \pi\)</span>周期连续函数,设<span class="math inline">\(M_n = \max_{ x \in [ - \pi , \pi ] } | S_n ( x )
|\)</span>,求证:<span class="math inline">\(\lim_{ n \to \infty } \frac{
M_n }{ \ln n } = 0\)</span>.</p>
<p>不妨设<span class="math inline">\(M_f = \max f\)</span>,考虑<span class="math inline">\(| S_n ( x ) | \leq | S_n ( x ) - f | +
M_f\)</span>,而后者是个死数,除以<span class="math inline">\(\ln
n\)</span>后当然趋近于<span class="math inline">\(0\)</span>.</p>
<p>现在只需要看前者,然而:</p>
<p><span class="math display">\[
\begin{aligned}
S_n ( x ) - f &amp; = \frac{ 1 }{ \pi } \int_{ 0 }^\pi ( f ( x + t ) + f
( x - t ) - 2 f ( x ) ) D_n ( t ) \mathrm{ d } t \\
&amp; = \frac{ 1 }{ \pi } \int_{ 0 }^\delta ( f ( x + t ) + f ( x - t )
- 2 f ( x ) ) D_n ( t ) \mathrm{ d } t
\end{aligned}
\]</span></p>
<p>而回忆到<span class="math inline">\(\int_0^\pi | D_n ( t ) | = O (
\ln n )\)</span>,由一致连续性前半部分显然可以决定一个<span class="math inline">\(\delta\)</span>是前者<span class="math inline">\(&lt; \epsilon\)</span>,这就搞定了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/5/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
