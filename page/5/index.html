<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/5/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2>
<h3><span id="维度">维度</span></h3>
<h4><span id="b维正交范围">B维正交范围</span></h4>
<p>对于一个$B <span class="math inline">\(维的点\)</span>x <span class="math inline">\(,满足\)</span> i B , l _i x _i r _i <span class="math inline">\(,称所有这样的点组成的集合为一个\)</span>B
$维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果$l , r <span class="math inline">\(有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个\)</span>B
<span class="math inline">\(维正交范围有\)</span>k <span class="math inline">\(个有用限制,称它为\)</span>k - side $的.</p>
<p>例如,找到区间$[ l , r ] <span class="math inline">\(中\)</span>&lt; x
$的元素,这个矩形是$3 - side <span class="math inline">\(的.找到区间\)</span>[ 1 , l ] <span class="math inline">\(中\)</span>&lt; x $的元素,这个矩形是$2 - side
$的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3>
<h4><span id="矩阵乘法">矩阵乘法</span></h4>
<p>做$n n <span class="math inline">\(的矩阵乘法目前得到的最优秀复杂度也是\)</span>O ( n
^{ 2 . 373 } ) $.</p>
<p>另外可以归约:$01 <span class="math inline">\(矩阵和整数矩阵在去除\)</span>n
$后的复杂度相同.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5>
<p>考虑构造一棵树:他有$ <span class="math inline">\(个叉,每个叉上有\)</span> <span class="math inline">\(个点.我们将这些叉编号为\)</span>[ 1 , ] <span class="math inline">\(.然后我们考虑询问两个叉所组成的链的答案,设\)</span>f
_{ i , j } <span class="math inline">\(表示数字\)</span>j <span class="math inline">\(是否在\)</span>i <span class="math inline">\(的叉上出现过,不难发现它们合并的时候要对\)</span>f
$做或运算,$01 $矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5>
<p>考虑对序列和值域同时分块,考虑序列中第$L <span class="math inline">\(到第\)</span>R <span class="math inline">\(个块的答案,设为\)</span>f ( L , R ) <span class="math inline">\(,这两块间的答案设为\)</span>g ( L , R ) <span class="math inline">\(,显然\)</span>f ( L , R ) = f ( L + 1 , R ) + f (
L , R - 1 ) - f ( L + 1 , R - 1 ) + g ( L , R ) <span class="math inline">\(,而由于对值域分块,\)</span>g ( L , R ) = a b
$的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5>
<p>平面上有若干点,两个操作:每次将横坐标小于等于$A <span class="math inline">\(的点加上\)</span>v <span class="math inline">\(,或者查询纵坐标小于等于\)</span>B
$的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="分块">分块</span></h3>
<h5><span id="example1luogup8527ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</span></h5>
<p>首先将$a
$分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的$L
$的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为$B <span class="math inline">\(,暴力处理散块的复杂度是\)</span>O ( Bm ) <span class="math inline">\(,处理整块的复杂度是\)</span>O ( { B } ( m + n n )
) <span class="math inline">\(.取\)</span>B ^2 = { m } ( m + n n ) = 500
$最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了$B = 2048 $.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079riapq">Example2(luogu[Ynoi2079]
riapq)</span></h5>
<p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了$[ 1 , l - 1 ] <span class="math inline">\(对\)</span>[ l , r ] $的贡献.</p>
<p>先序列分块.然后$[ 1 , l - 1 ] <span class="math inline">\(中的整块对\)</span>[ l , r ] <span class="math inline">\(的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将\)</span>[
1 , l - 1 ] <span class="math inline">\(中的整块的树状数组进行一个\)</span>[ l , r ] <span class="math inline">\(的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到\)</span>O
( Bq n ) <span class="math inline">\(的时间复杂度和\)</span>O ( Bn )
$的空间复杂度.</p>
<p>问题在于$[ 1 , l - 1 ] <span class="math inline">\(中的散块咋办.首先\)</span>[ 1 , l - 1 ] <span class="math inline">\(中的散块对\)</span>[ l , r ] <span class="math inline">\(中的散块的贡献是好处理的,因为总共就\)</span>O ( {
B } ) <span class="math inline">\(个数字,直接全部存下来排序做归并就可以统计,时间复杂度\)</span>O
( Bq n ) $.</p>
<p>现在的问题在于$[ 1 , l - 1 ] <span class="math inline">\(中的散块对\)</span>[ l , r ] <span class="math inline">\(中的整块如何贡献.能不能把\)</span>[ l , r ] <span class="math inline">\(的信息统计在\)</span>[ 1 , l - 1 ] <span class="math inline">\(的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有\)</span>
{ B } <span class="math inline">\(个,整块一共有\)</span>B
$个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为$O ( n n ) $,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</span></h5>
<p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu6331">Example4(Walking Plan HDU
6331)</span></h5>
<p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度$O ( nq )
$.</p>
<h5><span id="example5p5063-ynoi2014置身天上之森">Example5(P5063 [Ynoi2014]
置身天上之森)</span></h5>
<p>考虑如果$n = 2 ^k <span class="math inline">\(,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的\)</span>a
$(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是$n $不一定是$2 ^k
$,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5>
<p>大概是对于每个块处理出它的值域范围:一开始是$[ 1 , n ] <span class="math inline">\(,然后每次操作都会将整个块分为两部分:\)</span>[ 1 ,
x ) <span class="math inline">\(和\)</span>[ x , maxn ] <span class="math inline">\(,讨论一下\)</span>maxn $和$2 x <span class="math inline">\(的大小,就可以用\)</span>( x , maxn - x ) <span class="math inline">\(的复杂度使得\)</span>maxn <span class="math inline">\(变成\)</span>maxn - x $,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3>
<h5><span id="example1luogup5047ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5>
<p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到$O ( n n ) $.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为$[ l , r ] <span class="math inline">\(对\)</span>r <span class="math inline">\(的贡献实际上就是\)</span>[ 1 , r ] <span class="math inline">\(对\)</span>r <span class="math inline">\(的贡献减去\)</span>[ 1 , l - 1 ] <span class="math inline">\(对\)</span>r $的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这$O ( n ) <span class="math inline">\(次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入\)</span>O
( n ) <span class="math inline">\(次但是需要查询\)</span>O ( n )
$次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了$O ( n ) <span class="math inline">\(,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到\)</span>O
( n ) $.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3>
<p>我们现在有一个需要维护的$n n $的平面,我们现在对其进行分块:</p>
<ol type="1">
<li><p>将平面分成$n ^{ { 2 } } <span class="math inline">\(个\)</span>n
^{ { 4 } } n ^{ { 4 } } <span class="math inline">\(的\)</span>A <span class="math inline">\(块,以\)</span>A $块为单位做二维前缀和.</p></li>
<li><p>每个$A <span class="math inline">\(块内部分成\)</span>n ^{ { 2 }
} <span class="math inline">\(个\)</span>n ^{ { 2 } } n ^{ { 2 } } <span class="math inline">\(的\)</span>B <span class="math inline">\(块,在\)</span>A <span class="math inline">\(块内部以\)</span>B $块为单位做二维前缀和.</p></li>
<li><p>将整个平面横着分别分成一个个$n n ^{ { 4 } } <span class="math inline">\(的\)</span>C <span class="math inline">\(块.(竖着也要分成一个个\)</span>n ^{ { 4 } } n
$的块,是类似的,略去)</p></li>
<li><p>每个$C <span class="math inline">\(块内部分成\)</span> <span class="math inline">\(个\)</span>n ^{ { 4 } } n ^{ { 2 } } <span class="math inline">\(个\)</span>D <span class="math inline">\(块,在\)</span>C <span class="math inline">\(块内部以\)</span>D $块为单位做二位前缀和.</p></li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度$O ( ) <span class="math inline">\(.同时注意到空间复杂度是\)</span>O ( n ) $的.</p>
<p>查询显然是分四种情况讨论:$A , B , D
$块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应$O
( 1 ) $个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个$l <span class="math inline">\(对应\)</span>O ( 1 ) <span class="math inline">\(个\)</span>r <span class="math inline">\(,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有\)</span>O
( ) <span class="math inline">\(个查询,记录一下即可.这样就做到了\)</span>O ( )
<span class="math inline">\(单点改,\)</span>O ( 1 ) $查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现$O ( 1 ) <span class="math inline">\(单点改,那这种情况下如何实现\)</span>O ( ) <span class="math inline">\(求和呢?首先还是可以\)</span>O ( )
$求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度$&lt; n ^{ { 2 }
} <span class="math inline">\(,我们就可以在每次查询的时候用\)</span>
<span class="math inline">\(的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以\)</span>O
( ) $求散块.</p>
<h5><span id="example1luogup7448-ynoi2007rdiq">Example1(luoguP7448 [Ynoi2007]
rdiq)</span></h5>
<p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和$a
_r <span class="math inline">\(颜色相同的点是\)</span>r ’ <span class="math inline">\(,则显然新增的逆序对只可能出现在\)</span>[ r ’ , r
] $中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从$n <span class="math inline">\(扫左端点,总共做\)</span>O ( n ) <span class="math inline">\(次单点修改,做\)</span>O ( n ) $次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为$( r ’ + 1 , a _r ) <span class="math inline">\(,右上角是\)</span>( r , ) $的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令$rev ( x )
= n - x + 1 <span class="math inline">\(.然后将所有点的纵坐标\)</span>rev <span class="math inline">\(掉,现在我们要查询的也就是左下角为\)</span>( r ’ +
1 , 1 ) <span class="math inline">\(,右上角是\)</span>( r , rev ( a _r )
) <span class="math inline">\(的矩阵,这玩意可以拆前缀和拆成形如左下角是\)</span>(
1 , 1 ) <span class="math inline">\(,右上角是\)</span>( i , rev ( a _i )
) <span class="math inline">\(的矩阵.也就是说我们的\)</span>O ( n )
<span class="math inline">\(次矩阵查询本质上只有\)</span>O ( n )
$种.</p>
<p>拆到这里发现其实到这一步$a <em>r <span class="math inline">\(和\)</span>a </em>{ r ’ }
$是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</span></h5>
<p>首先自然的想法是拿莫队扫掉$[ l _1 , r _1 ] $这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维$[ l _2 , r _2 ]
$扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点$(
a , a ) <span class="math inline">\(上加上一个相应的\)</span>b <span class="math inline">\(,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点\)</span>A
( x _1 , x _1 ) <span class="math inline">\(和\)</span>B ( x _2 , x _2 )
<span class="math inline">\(之间的\)</span>( x _1 , x _2 ) <span class="math inline">\(上加上一个\)</span>- b
$,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol type="1">
<li><p>莫队时查询一个点的前驱后继,这个操作就需要$O ( 1 ) $完成.</p></li>
<li><p>$n <span class="math inline">\(次单点修改,这个操作需要\)</span>O
( 1 ) $完成.</p></li>
<li><p>$n <span class="math inline">\(次矩阵求和,这个操作需要在小于\)</span>O ( )
$的时间完成.</p></li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为$O ( n )
$,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3>
<h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5>
<p>首先反应是扔到trie上然后异或就是打个tag,但是$+ 1
$很难处理,因为它形如在trie上找到所有长度连续为$1
$到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是$+ 1
$的话就相当于反转一条从根开始均为$1 $的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3>
<h4><span id="普通线段树">普通线段树</span></h4>
<h5><span id="example1luogup6780ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</span></h5>
<p>感觉这题比较厉害.</p>
<p>先扔做法:对$c <span class="math inline">\(分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求\)</span>$.而对于块间如何做呢?</p>
<p>我们设$suf _i <span class="math inline">\(为前一个块的后\)</span>i
<span class="math inline">\(个数之和,\)</span>pre _i <span class="math inline">\(为后一个块的前\)</span>i <span class="math inline">\(个数之和.注意到我们要求的就是\)</span>{ suf _i +
pre _j | i + j c } $.这个咋做呢?</p>
<p>你注意到这个$i + j c <span class="math inline">\(的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用\)</span>j
c - j + 1 <span class="math inline">\(的话,这个限制就转化为了\)</span>i
+ c - j + 1 c <span class="math inline">\(,也就是\)</span>i &lt; j
$,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对$c $分块?</p>
<p>一方面,题目中的$c <span class="math inline">\(是给定的.另一方面,我们注意到我们需要维护一个和\)</span>c
<span class="math inline">\(有关的东西,而如果没有\)</span>c <span class="math inline">\(,或者说\)</span>c = n <span class="math inline">\(的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了\)</span>c
= n <span class="math inline">\(的条件.考虑到这一点,对\)</span>c
$分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将$a
[ l - 1 ] <span class="math inline">\(和\)</span>a [ r + 1 ]
$都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个$maxn <span class="math inline">\(设成\)</span>- <span class="math inline">\(的.如果这两个东西设成等大的\)</span>-
$,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比$- <span class="math inline">\(还要小的数字,最底层的\)</span>maxn
$有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4>
<p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5>
<p>注意到每个点其实只需要找到$[ i - r _i , i - 1 ] <span class="math inline">\(和\)</span>[ i + 1 , i + r _i ] <span class="math inline">\(这两段的最大值,设为\)</span>x <span class="math inline">\(,则最后的答案就是\)</span>{ a _i + x } $.</p>
<p>思考这个过程,我们将$[ i - r _i , i - 1 ] <span class="math inline">\(和\)</span>[ i + 1 , i + r _i ] <span class="math inline">\(这两条线段以\)</span>a _i <span class="math inline">\(的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的\)</span>a
_i $的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4>
<h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5>
<p>考虑全局的和是$sum <span class="math inline">\(,则我们要在这些数中找到一个分界点,使得左边的和大于等于\)</span>sum
$,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定$a _i , b _i <span class="math inline">\(,选定至多\)</span>k
<span class="math inline">\(个位置使这里的值为\)</span>a _i - b _i <span class="math inline">\(,其它位置的值是\)</span>a _i
$,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的$mid
$,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出$<em>{ k = 1 } ^r { ( </em>{ i
= k + 1 } ^n { sum _{ i } } , - b <em>k + </em>{ i = 1 } ^k { sum _i } )
} <span class="math inline">\(.注意改掉一个位置后要把它的\)</span>b
$变成$0 $.</p>
<p>那么什么样的$b <span class="math inline">\(有可能是我们要选中的呢?显然可能被选中的\)</span>b
<span class="math inline">\(一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:\)</span><em>{
k = 1 } ^r { ( </em>{ i = k + 1 } ^n { sum <em>{ i } } , - </em>{ i = k
} ^n { b <em>i } + </em>{ i = 1 } ^k { sum _i } ) } <span class="math inline">\(,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的\)</span>$尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是:</p>
$$
<span class="math display">\[\begin{aligned}
\min _{ k = 1  } ^r \{ \max ( sufmax ( sum ) _{ k + 1  } , - sufmax ( b
) _k + premax ( sum ) _k \} \\
&amp; = \min _{ k = 1  } ^r \{ \max ( sufmax ( sum ) _{ k + 1  } , -
\max ( sufmax ( b ) _{ k + 1  } , b _k ) + premax ( sum ) _k \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的$k <span class="math inline">\(后面最大的\)</span>b <span class="math inline">\(,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响\)</span>sufmax
( b ) <span class="math inline">\(的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的\)</span>b
<span class="math inline">\(,这个\)</span>b
$必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4>
<h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4>
<h4><span id="吉司机线段树">吉司机线段树</span></h4>
<h4><span id="李超线段树">李超线段树</span></h4>
<h3><span id="珂朵莉树">珂朵莉树</span></h3>
<h5><span id="example1luogup8512ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</span></h5>
<p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3>
<h3><span id="kd-tree">KD-Tree</span></h3>
<p>处理$K <span class="math inline">\(维正交范围(给定\)</span>n <span class="math inline">\(个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度\)</span>O
( n ^{ 1 - { k } } + n ) <span class="math inline">\(.(单调修改复杂度只是\)</span>O ( n ) $)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4>
<p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4>
<p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> siz;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">ll d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=cur[mid];</span><br><span class="line">tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line"><span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3>
<h5><span id="example1cfgym101613factor-freetree">Example1([CFgym101613]Factor-free
tree)</span></h5>
<p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是$dep
_u <span class="math inline">\(,是可以被卡成\)</span>O ( n ^2 ) $的.</p>
<p>但我们考虑类似dsu on
tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5>
<p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为$[ l , r ] <span class="math inline">\(,这样会有:\)</span>[ l - 1 , i - 1 ]
$.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3>
<h5><span id="exampleloj3151">Example(loj3151)</span></h5>
<p>首先自然地,我们设$f _{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个测试点已经分成了\)</span>j <span class="math inline">\(段的方案数,然后做转移,复杂度\)</span>O ( T ^2 S )
$.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到$k
$最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把$[ l , r ] <span class="math inline">\(分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点\)</span>r
$,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3>
<p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5>
<p>维护一个序列支持把$x <span class="math inline">\(位置的值改为\)</span>y <span class="math inline">\(或查询一个区间中小于\)</span>y $的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</span></h5>
<p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开$100
$个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2>
<h3><span id="分开考虑">分开考虑</span></h3>
<h5><span id="example1p6105-ynoi2010y-fast-trie">Example1(P6105 [Ynoi2010]
y-fast trie)</span></h5>
<p>考虑只有两种可能:</p>
<ol type="1">
<li><p>$x + y &lt; C <span class="math inline">\(,取\)</span>x + y
$作为答案.</p></li>
<li><p>$x + y C <span class="math inline">\(,取\)</span>x + y - C
$作为答案.</p></li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在$[
0 , { 2 } )
$中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,$x + y &lt; C <span class="math inline">\(也就是\)</span>x &lt;
C - y <span class="math inline">\(,我们把第二个集合中的元素全部变成\)</span>C - y
<span class="math inline">\(后插入,只需最小化\)</span>C - x - y <span class="math inline">\(,这个只需要维护最大的\)</span>x <span class="math inline">\(和最小的\)</span>C - y $就行.</p>
<h3><span id="合并信息">合并信息</span></h3>
<p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</span></h5>
<p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5>
<p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用$O ( n )
$的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5>
<p>设$w _i <span class="math inline">\(为从上往下延伸到\)</span>i <span class="math inline">\(这个点后,还能多往下延伸多少,一开始\)</span>w <span class="math inline">\(都是\)</span>- 1 <span class="math inline">\(,每次操作会让\)</span>w + = 1
$.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3>
<h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5>
<p>自然的想法是考虑找到每个点前面第一个和它之和为$w <span class="math inline">\(的数字,但这样就炸了,因为每修改一个点可能要影响\)</span>O
( n ) $个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为$w <span class="math inline">\(的数字,而显然只有两个数互相匹配才可行.如果\)</span>i
&lt; j &lt; k , ( i , j ) , ( i , k ) <span class="math inline">\(分别配对,那么显然\)</span>( i , k ) <span class="math inline">\(没有用.这样每个点只有\)</span>O ( 1 )
$个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3>
<h5><span id="example1luogup5278算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</span></h5>
<p>首先考虑$k = 1
$怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p>$k <span class="math inline">\(怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在\)</span>k
<span class="math inline">\(意义下全部相等,维护差分数组的区间\)</span>$就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5>
<p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为$q <span class="math inline">\(的衣服,\)</span>[ 0 , q ) <span class="math inline">\(的人肯定买不了,\)</span>[ q , 2 q - 1 ] <span class="math inline">\(的人买完后,手上的钱至少减半,我们暴力处理,至于\)</span>[
2 q , + ) $,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5>
<p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到$0
$,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</span></h5>
<p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是$pre
[ i ] = i - 1 $).</p>
<h3><span id="根号分治">根号分治</span></h3>
<h5><span id="example1luogup7722-ynoi2007tmpq">Example1(luoguP7722 [Ynoi2007]
tmpq)</span></h5>
<p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改$a , b , c $中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个数字$x <span class="math inline">\(,每次随机在\)</span>[ 1 ,
x ] <span class="math inline">\(中一个数\)</span>y <span class="math inline">\(并令\)</span>x x y <span class="math inline">\(,初始值为\)</span>n $,求期望几次能变成$0 $.</p>
<p>注意到如果$y <span class="math inline">\(很小就直接做,\)</span>y
<span class="math inline">\(很大的话\)</span> { y }
$很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5>
<p>给定序列,每次询问给出两个数字$x , y <span class="math inline">\(,求最小的\)</span>| i - j | <span class="math inline">\(满足\)</span>a _i = x , a _j = y $.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果$x , y $出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5>
<p>首先对于$Y $很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于$Y <span class="math inline">\(很大的情况,\)</span> { Y } <span class="math inline">\(一定很小,我们不断查询大于等于\)</span>kY <span class="math inline">\(的最小元素即可,这个可以值域分块来根号平衡做到\)</span>O
( 1 ) <span class="math inline">\(查询,\)</span>O ( ) <span class="math inline">\(单点修改.具体地,我们对每个块处理出大于等于这个块的最小的\)</span>X
<span class="math inline">\(,以及块内每个点后面最小的\)</span>X <span class="math inline">\((必须在块内),然后定位到\)</span>kY $的块.</p>
<h5><span id="example6">Example6</span></h5>
<p>给定$n , m <span class="math inline">\(,以及序列\)</span>a <span class="math inline">\(和长度为\)</span>n <span class="math inline">\(的排列\)</span>y <span class="math inline">\(,你需要回答\)</span>m <span class="math inline">\(个询问.对每个询问,给定\)</span>l , r $,查询:</p>
<p><span class="math display">\[
\sum _{ i = 1  } ^n \sum _{ j = i + 1  } ^n [ a _i = a _j ] \prod _{ k =
i  } ^j [ l \leq y _k \leq r ]
\]</span></p>
<p>注意到$y _i = i
$的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点$( x , y ) , a _x = a _y , x &lt; z &lt; y ,
a _z = a _x <span class="math inline">\(,对于\)</span>( x , y )
$这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于$ <span class="math inline">\(的数字,它们最多只有\)</span> <span class="math inline">\(个,考虑莫队复杂度\)</span>O ( n + m ) <span class="math inline">\(,因此我们可以对每个分别做莫队,总复杂度\)</span>O (
n + m ) $,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于$ <span class="math inline">\(的数字,这些数字一共最多有\)</span>n <span class="math inline">\(个,每个点暴力配对就有\)</span>O ( n ) <span class="math inline">\(个点对,然后\)</span>O ( m ) <span class="math inline">\(次询问,用根号平衡做扫描线,这里复杂度\)</span>O ( n
+ m ) $.</p>
<h3><span id="重链分治">重链分治</span></h3>
<h5><span id="example1luogu5314ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</span></h5>
<p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为$1 <span class="math inline">\(,支持把一条链上所有点加上\)</span>k <span class="math inline">\(,或者查询距离一个点\)</span>&lt; = 1 <span class="math inline">\(的所有点的点权\)</span>kth <span class="math inline">\(.\)</span>n ^5 $.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改$O
( n ) $个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="一维扫描线">一维扫描线</span></h4>
<p>最经典的应用是对于一个$B <span class="math inline">\(维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个\)</span>B
- 1 <span class="math inline">\(维的动态问题.不过扫描线处理的时候可能需要是低\)</span>side
$的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4>
<p>也就是莫队.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1cf1609finteresting-sections">Example1(CF1609F
Interesting Sections)</span></h5>
<p>首先枚举每个数的$popcount
$,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点$x <span class="math inline">\(作为最大值的影响区间\)</span>[ l , r ] <span class="math inline">\(,也就是如果一个区间左端点在\)</span>[ l , x ]
<span class="math inline">\(,右端点在\)</span>[ x , r ] <span class="math inline">\(即可满足条件.我们考虑放入一个左下角坐标为\)</span>(
l , x ) <span class="math inline">\(,右上角坐标为\)</span>( x , r )
$的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5>
<p>离散化,设$S = { l } { r } <span class="math inline">\(,考虑用\)</span>len <em>i <span class="math inline">\(表示\)</span>i <span class="math inline">\(节点及以前最多能有多少阳光.我们考虑用\)</span>len
</em>{ i - 1 } <span class="math inline">\(更新\)</span>len <em>i <span class="math inline">\(,如果\)</span>[ i - 1 , i ] <span class="math inline">\(没被覆盖,显然直接加上这段的长度.如果\)</span>[ i -
1 , i ] <span class="math inline">\(被覆盖大于两次,那显然直接继承\)</span>len </em>{ i
- 1 } $.</p>
<p>先考虑$[ i - 1 , i ] <span class="math inline">\(被两朵云覆盖了怎么办,我们考虑用\)</span>h <em>{ j
, k } <span class="math inline">\(表示当前被且只被\)</span>j <span class="math inline">\(和\)</span>k <span class="math inline">\(共同覆盖的区间长度,不难发现\)</span>h </em>{ j , k
} <span class="math inline">\(有值的地方很少,用map.然后还要加上它们各自的贡献,用\)</span>g
_j <span class="math inline">\(表示当前被且只被\)</span>j <span class="math inline">\(覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断\)</span>[
i - 1 , i ] $是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果$[ i - 1 , i ] <span class="math inline">\(被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为\)</span>k
$,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是$g _j + g _k <span class="math inline">\(,用线段树处理出当前代价和小于等于\)</span>C <span class="math inline">\(的\)</span>k <span class="math inline">\(的\)</span>g _k $的最大值就行.</p>
<p>再考虑有交的情况,答案应该为$g _j + g <em>k + h </em>{ j , k } <span class="math inline">\(,我们在每次遇到\)</span>( j , k ) <span class="math inline">\(的时候都在对方那里打个tag就好,也就是对于每个\)</span>j
<span class="math inline">\(,处理出和它有交的云中\)</span>g _j + g <em>k
+ h </em>{ j , k }
$的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5>
<p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成$0
$后那些数一定没清空).</p>
<h5><span id="example4luogup7709wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5>
<p>如果初始序列全为$0 $:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5>
<p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5>
<p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是$L
&lt; R <span class="math inline">\(,自然有\)</span>L { r _i } , R { l _i
} <span class="math inline">\(,那么当我们确定\)</span>L <span class="math inline">\(后,我们有\)</span>R <span class="math inline">\(.接下来我们考虑如何计算\)</span>f ( L ) $.</p>
<p>注意到$L &lt; l _i R r _i <span class="math inline">\(,我们考虑将\)</span>l _i <span class="math inline">\(这个点的权值设成\)</span>r _i
$,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3>
<h4><span id="回滚莫队">回滚莫队</span></h4>
<h4><span id="带修莫队">带修莫队</span></h4>
<p>也就是维护三维的扫描线,根据KDT不难发现复杂度是$O ( nm ^{ { 3 } } )
<span class="math inline">\(,\)</span>B = n ^{ { 3 } } <span class="math inline">\(,排序原则是\)</span>( ls , rs , t )
$,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4>
<h4><span id="二次离线莫队">二次离线莫队</span></h4>
<p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个$n <span class="math inline">\(的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带\)</span>n
$的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有$n <span class="math inline">\(次询问,每次询问\)</span>f ( l , r , r + 1 ) <span class="math inline">\(表示区间\)</span>[ l , r ] <span class="math inline">\(对\)</span>r + 1 <span class="math inline">\(的逆序对贡献.考虑差分成\)</span>f ( 1 , r , r + 1
) - f ( 1 , l - 1 , r + 1 ) <span class="math inline">\(,前者显然可以迅速求出.而后者的右端点需要移动\)</span>n
<span class="math inline">\(次,需要查询总共\)</span>n $次,zhe’ge</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5>
<p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都$4
- side $了,但是有可减性,减成$2 - side $就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5>
<p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉$p = 2 <span class="math inline">\(和\)</span>p = 5 <span class="math inline">\(的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字\)</span>p
<span class="math inline">\(的值,设为\)</span>suf _i <span class="math inline">\(,假设存在两个点\)</span>l , r <span class="math inline">\(满足\)</span>p | ( suf <em>l - suf </em>{ r + 1 }
) <span class="math inline">\(,那么\)</span>[ l , r ] <span class="math inline">\(就是合法的,这是自然的,也就等价于\)</span>suf <em>l
= suf </em>{ r + 1 } <span class="math inline">\(,相当于要对满足\)</span>suf <em>l = suf </em>{ r +
1 } <span class="math inline">\(的二元组\)</span>( l , r )
$计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604美好的每一天">Example3(luoguP3604
美好的每一天)</span></h5>
<p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3>
<p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的$( l , r )
$的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5>
<p>考虑转化为二维平面,$a _{ l , r } = maxn - minn - ( r - l )
$,显然只需要找到为$0
$的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有$3 - side $的,但是可差分成$2 - side $.</p>
<h3><span id="时间倒流">时间倒流</span></h3>
<h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5>
<p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5>
<p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3>
<h5><span id="example1cf1540d-inverseinversions">Example1(CF1540D Inverse
Inversions)</span></h5>
<p>考虑对于一个数列怎么构造:假设只考虑前$k <span class="math inline">\(个数,它们的取值是\)</span>[ 1 , k ] <span class="math inline">\(,现在加入第\)</span>k + 1 <span class="math inline">\(个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都\)</span>+
1 $,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道$p _i <span class="math inline">\(是多少,根据上面的构造过程,首先将\)</span>p _i = a
_i <span class="math inline">\(,然后不断向后遍历,每遇到一个\)</span>a _j
<span class="math inline">\(,如果\)</span>a _j p _i <span class="math inline">\(,则把\)</span>p _i + = 1 $.</p>
<p>我们将数列分块,设块长为$B $,那一个值经过一个块的时候最多加块长个$1
<span class="math inline">\(.也就是经过整块的时候是一个\)</span>B
$段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是$
= B $的,</p>
<p>于是最后复杂度为$O ( T ( B + { B } n ) ) <span class="math inline">\(,取\)</span>B = $即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3>
<p>根号平衡主要用到下面四个东西:</p>
<ol type="1">
<li><p>$O ( 1 ) <span class="math inline">\(单点加,\)</span>O ( )
$区间和:维护块内的和即可.</p></li>
<li><p>$O ( ) <span class="math inline">\(单点加,\)</span>O ( 1 )
$区间和:维护块内和块间的前缀和即可.</p></li>
<li><p>$O ( ) <span class="math inline">\(区间加,\)</span>O ( 1 ) <span class="math inline">\(单点和:差分转化为\)</span>( 2 )
$.当然打标记也是可以的.</p></li>
<li><p>$O ( 1 ) <span class="math inline">\(区间加,\)</span>O ( ) <span class="math inline">\(单点和:差分转化为\)</span>( 1 )
$.当然打标记也是可以的.</p></li>
</ol>
<p>还有一些拓展的东西:</p>
<ol start="5" type="1">
<li><p>维护值域$O ( n ) <span class="math inline">\(的集合,支持\)</span>O ( 1 ) <span class="math inline">\(插入,\)</span>O ( ) <span class="math inline">\(查询第\)</span>k $小:值域分块就可以.</p></li>
<li><p>维护值域$O ( n ) <span class="math inline">\(的集合,支持\)</span>O ( ) <span class="math inline">\(插入,\)</span>O ( 1 ) <span class="math inline">\(查询第\)</span>k
$小:值域分块,然后暴力改变每个点所属的块就行.</p></li>
</ol>
<h4><span id="example">Example</span></h4>
<h5><span id="example1区间众数">Example1(区间众数)</span></h5>
<p>首先分块,处理出$f _{ l , r } <span class="math inline">\(表示块\)</span>[ l , r ] <span class="math inline">\(的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是\)</span>n
<span class="math inline">\(的,因此复杂度\)</span>O ( n ) $.</p>
<p>但是可以优化,我们设$mx <span class="math inline">\(表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于\)</span>mx
<span class="math inline">\(可以\)</span>O ( 1 ) <span class="math inline">\(判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然\)</span>mx
<span class="math inline">\(增加总次数也不会超过\)</span>O ( ) <span class="math inline">\(,因此做到\)</span>O ( n ) $.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-andchuru">Example2(CodeChef Chef and
Churu)</span></h5>
<p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个$O
( 1 ) <span class="math inline">\(查询区间和,\)</span>O ( )
$单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5>
<p>莫队,发现有$m <span class="math inline">\(次查询,\)</span>n
$次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5>
<p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有$O ( n ) $种,用值域分块就可以平衡复杂度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">平邑一中集训作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="反悔贪心">反悔贪心</span></h3>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6940</p>
<p>首先发现,从上往下扫行,然后对于每个右下角匹配一个列最近的左上角是最优秀的.所以拿set维护上述过程.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3268</p>
<p>这题比较厉害,直接扫,然后维护每个圆当前与这条线的两个交点,注意到这些交点的顺序是固定的,于是可以拿set维护.</p>
<h3><span id="二分图hall定理">二分图HALL定理</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc076_d</p>
<p>根据Hall定理,我们只要找到一个子集的人,使得人数与它们的区间的并所包含的椅子数量之差最大,这个最大值就是答案.而它们区间的并显然是同样类型的区间,也就是中间扣去一段.考虑枚举中间扣去的那一段是啥,就可以快速算答案.这玩意可以扫描线维护.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF981F</p>
<p>一眼丁真,鉴定为二分+Hall定理.</p>
<p>这题真正的难点在于如何check.考虑我们现在有了若干个区间$[ l , r ]
<span class="math inline">\(,每个整数点上都有一个人.然后要check.那就必须满足\)</span>r
_j - l _i j - i <span class="math inline">\(,这意味着\)</span>r _j - j l
_i - i $,然后就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3488</p>
<p>比较简单,考虑如果最后找的若干个区间是分开的,那它们必然其中有一个区间自己就不合法.因此找到这个区间就行,然后每个位置减去$k
<span class="math inline">\(,用线段树维护区间小子段和判断加上\)</span>k
d $是否小于$0 $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>这题比较厉害啊.首先猜到要用网络流.</p>
<p>然后注意到选的集合$= <span class="math inline">\(选的数字等价于不选的集合\)</span>+ <span class="math inline">\(选的数字\)</span>= n
$.考虑最小割.先将边权全部取反,这样变成求最大权值,</p>
<p>然后集合连权值加上一个极大值$M <span class="math inline">\(,单点连极大值\)</span>M
$.这样割掉一个单点意味着选这个单点,割掉一个集合意味着不选这个集合.由于存在完美匹配,因此一定会跑出答案.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc106_e</p>
<p>首先答案显然不会超过$2 nk
$,考虑二分,这样每一天会有哪些人来就知道了.然后对着上面的信息做高维前缀和就可以知道对于一个人的集合,它会来哪些天.这样就可以check.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc037_d</p>
<p>考虑最后$C D <span class="math inline">\(显然需要把该放的位置归位,这样我们的\)</span>a
$里面存的完全可以是它应该在第几行这个信息.</p>
<p>再考虑$B C <span class="math inline">\(,显然只需要保证每列的\)</span>a
$互不相同,这一步就可以满足上面的要求.</p>
<p>于是,$A B <span class="math inline">\(只需要保证每列的\)</span>a
$互不相同.这个可以使用网络流实现.</p>
<p>那么,如何证明一定有解呢?这是一张正则二分图,根据Hall定理推论,一定存在完美匹配.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc029_f</p>
<p>这题好牛啊.发现如果几个集合的并的点数过少,那么一定无解.因为怎么连都会连出环来.这直接将整个题的思路引向Hall定理.</p>
<p>考虑直接做二分图匹配.左边是点右边是集合,然后连边.</p>
<p>那么根据Hall定理一定存在$n - 1 <span class="math inline">\(的匹配,并且恰好有一个点没被匹配到.我们干脆删掉这个点,最后再加回来.事实上理论上来说我删掉哪个点都应该存在完美匹配,我们先只删一个.然后从\)</span>r
$开始不断dfs找到一条遍历所有边的交错树,对着交错树构造就行.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1519F</p>
<p>首先注意到,只要任意一个宝箱集合需要的钥匙集合的权值大于等于自己,那Bob就输了.这类似Hall定理.我们把钥匙和宝箱都拆点,然后判断拆点后的图是否存在完美匹配.求完美匹配可以使用状压.</p>
<h3><span id="轮廓线dp">轮廓线dp</span></h3>
<p>这个板块好像没啥说的,因为思维难度远低于代码难度.而且思路都比较直接.</p>
<p>放一下我做的题.</p>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5056</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2289</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3886</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P1933</p>
<h3><span id="广义串并联图">广义串并联图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6790</p>
<p>比较简单,首先这个图这么简单,那它大概率是个广义串并联图.感性理解一下,$n
$的时候肯定是存在度数较小的边的,并且你在合并的过程中它也一直是仙人掌+至多一条边的形状.</p>
<p>然后简单做做.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P8426</p>
<p>ps:本题选入笔记:图论-广义串并联图/三度化-Example2.</p>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果$S <span class="math inline">\(和\)</span>T <span class="math inline">\(在一个点双中,我们找到两个点\)</span>u , v <span class="math inline">\(,使得\)</span>u v <span class="math inline">\(,并且\)</span>u $的出度至少是$2 <span class="math inline">\(,\)</span>v $的入度至少是$2
$,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为$2
<span class="math inline">\(的点\)</span>v <span class="math inline">\(,找到它的入点\)</span>u <span class="math inline">\(,如果\)</span>u $的出度不是$2 <span class="math inline">\(,那么\)</span>u $也是一个入度至少为$2 <span class="math inline">\(的点.这样往前推一定至少能推到一个点(因为不可能\)</span>S
$贡献了俩入度).</p>
<p>如何保证$S , T <span class="math inline">\(在一个点双中呢?其实只需要添加一条边\)</span>( S ,
T , dis _{ S T } ) <span class="math inline">\(就行了.显然加了后不会对答案产生影响.然后不在\)</span>S
, T $这个边双内的点也没有用了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://loj.ac/p/3076</p>
<p>这题没啥好说的,小E的集训队论文讲的很清楚.简单来说就是用三度化求出一棵决策树,然后做动态dp.</p>
<h3><span id="动态规划第一期">动态规划第一期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1810G</p>
<p>ps:本题选入笔记:动态规划-动态规划的优化-反向操作-Example1.</p>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k <span class="math inline">\(暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取\)</span><span class="math inline">\(操作很艰难.但如果!我把这个dp反过来,我设\)</span>f
_{ i , j } <span class="math inline">\(表示**从后往前**dp到\)</span>i
$,当前的最大前缀和是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i -
1  } \}  }
\]</span></p>
<p>最后在$f _{ 1 , j } <span class="math inline">\(处乘上\)</span>h _j
$.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g <em>{ i , j } <span class="math inline">\(表示如果初始只有\)</span>f </em>{ i , j } = 1
$,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g
_{ i , j  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>我认真考虑过这个$P <span class="math inline">\(应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些\)</span>P
$变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<p>回来简单提下容斥做法,其实是有一个自然的想法是只要这个序列中出现过前缀和为$x
<span class="math inline">\(的位置,我们就加上一个\)</span>h <em>x - h
</em>{ x - 1 }
$.然后我们要统计的是出现过的,因此用容斥把这个条件删了就行.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc061_c</p>
<p>这题纯容斥,首先考虑找到一种统计答案序列而非操作序列的方式:一般而言会选择建立某种双射.考虑一个答案序列可以怎么被操作到:或者说,对于一个答案序列,判断它能否操作到.</p>
<p>注意到序列中第一个元素,肯定是选择左端点比较合理.因为这样它对后面的限制要少一些.那么其实双射方式就呼之欲出了:就是从左往右扫,能取左端点就取左端点.我们就可以对这个操作序列进行计数.</p>
<p>这个操作序列怎么计数呢?考虑这个序列满足啥条件:其实就是能选左边的就不会选右边的,那也就是不可能出现一个空的区间,这个区间没有任何数字.对着这个条件容斥即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc134_e</p>
<p>这题见过两次了.大概是按部就班一点一点去找条件.</p>
<p>至于考试怎么办,考试打表啊!</p>
<p>下面抄一下演算纸上的结论,注意这些判定条件的优先级从前往后:</p>
<ol type="1">
<li><p>如果序列全$1 $,显然后手获胜.</p></li>
<li><p>如果序列不是全$1 <span class="math inline">\(并且存在奇数,选择\)</span>m = 2
$,先手获胜.</p></li>
<li><p>如果序列全$2 $,显然后手获胜.</p></li>
<li><p>如果序列全是偶数并且不全是$4 <span class="math inline">\(的倍数,取\)</span>m = 4
$转化为(3),先手获胜.</p></li>
<li><p>如果序列全是$4 <span class="math inline">\(的倍数,考虑取\)</span>m = 3 <span class="math inline">\(,如果序列中只有\)</span> = 1 <span class="math inline">\(或者只有\)</span> = 2 <span class="math inline">\(的数字,显然先手获胜.不然,如果同时存在,考虑先手取\)</span>m
= 12 <span class="math inline">\(,序列中就会只剩下\)</span>{ 4 , 8 }
$.此时如果后手取一个奇数,显然会剩下奇数,根据(2)先手获胜;如果后手取一个偶数,讨论一下全部的偶数,都是先手获胜.</p></li>
</ol>
<p>综上,除非所有的数字都是$12 <span class="math inline">\(的倍数,不然后手获胜当且仅当序列是\)</span>{ 1 } ,
{ 2 } , { 4 , 8 } $.</p>
<p>如果所有的数字都是$12 $的倍数,最多只有$16 $个,状压即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_abc290_h</p>
<p>显然对于猫来说,它的$d <span class="math inline">\((定义为左右狗的数量之差,对于狗同理)是一个从左到右先减少再增加的东西.因此一个\)</span>O
( n ^4 ) <span class="math inline">\(的dp是简单设计的,也就是\)</span>f
_{ i , j , k , l } <span class="math inline">\(表示目前用了\)</span>i
<span class="math inline">\(只猫,有\)</span>j <span class="math inline">\(只放在前面,\)</span>i - j $只放在后面,狗同理.</p>
<p>这个怎么优化呢?我们仔细思考,如果要放,是不是最好放的平均一点.因此引出一个结论:那就是一定存在一个分界点,使得左右猫的数量相同,狗的数量也相同.你可能会好奇$n
, m <span class="math inline">\(都是奇数怎么办,这种情况下会把中间的两个点当作分界点.如果\)</span>n
+ m $是奇数就找中间的那个点,不然就找中间的那个空格.</p>
<p>这个是怎么证明的呢?我们考虑对于猫来说,先找到能平分猫的分界点.然后考虑这个点左右两侧的狗的数量是否相同(这里先假设狗的数量是偶数,奇数是同理的,只是要多说几步).我们选择狗多的那一边,把这边最靠近分界线的那只狗恰好移过分界线.注意到这样一定更优秀.</p>
<p>那么上面的结论证明了啥呢?证明了整个序列一定可以分成两部分(左右两部分).这有什么用?这去掉了前两维.具体来讲,对于一部分,如果可以填某只猫或某只狗二者之一,一定选择权值较小的先填,这样的话这一对的贡献就会少一些.其实就是把权值转化为每个序列中每一对的贡献.于是这个结论就是对的,我们可以把猫狗放在一起排序来处理第一维.复杂度$O
( n ^3 ) $.</p>
<p>测完样例发现一个问题啊,上面那个结论还真不能简单地拓展到奇数.因为会出现权值相等的情况.对于偶数来讲,权值相等是无所谓的.但是奇数不行.因此我们选择如果$n
<span class="math inline">\(是奇数,就挑出最大的那只强行放在中间,\)</span>m
$同理.</p>
<p>但是,这题被爆标了.存在$O ( n n ) $的做法:</p>
<p>注意到,$d $总是一样的.因为这个猫前面的狗会因为它而贡献$1
$,然后这个猫和后面的狗也会贡献$1 <span class="math inline">\(.于是考虑从大到小开始放,优先放中间.然后先把狗堆一边,猫堆另一边,堆不动了再放对边,这样就是满足让\)</span>a
<span class="math inline">\(较大的\)</span>d $较小.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9338</p>
<p>首先能划分就一定需要是一个合法括号序列.同时这意味着一定可以划分出$N
$个合法的序列.</p>
<p>也就是说,我们其实只在乎这个序列最少能划分出多少,并且判断这个数字是否小于等于$K
$.那么如何求这个数字呢?</p>
<p>考虑第一个$B <span class="math inline">\(,它一定会和它左边的某个\)</span>A <span class="math inline">\(配对,不妨设它左边有\)</span>i <span class="math inline">\(个\)</span>A <span class="math inline">\(,那么最好的办法显然是这\)</span>i <span class="math inline">\(个\)</span>A <span class="math inline">\(和后面紧接着的\)</span>i <span class="math inline">\(个\)</span>B <span class="math inline">\(合并成一个序列.这是为什么呢?因为第一个\)</span>B
<span class="math inline">\(需要配对,因此它需要在一个序列中,把它删掉后后面的一个\)</span>B
<span class="math inline">\(也需要配对,而此时它前面的\)</span>A
$其实都是等价的,于是选择最早的那个,以此类推.</p>
<p>然后题解开始变魔术了.设$f [ x ] <span class="math inline">\(表示第\)</span>x <span class="math inline">\(个\)</span>B <span class="math inline">\(前有多少个\)</span>A <span class="math inline">\(,那我们做的实际上就是\)</span>x = 1 <span class="math inline">\(,然后不断做\)</span>x : = f [ x ] + 1 <span class="math inline">\(直到\)</span>x &gt; n
$.发现这样其实顺便把合法括号序列那个条件一起满足了,因为如果不合法一定会跳跳跳跳跳然后死循环.</p>
<p>那么我们的交换操作实际上是啥呢?首先不可能交换两个相同的,那实际上就是给一个$f
<span class="math inline">\(,实际上显然不可能给一个\)</span>f $减一.</p>
<p>但是这样会出现一个问题是,我们其实并不能选择任意一个$f <span class="math inline">\(进行更改.那怎么办呢?事实上,只要过程中满足\)</span>
&lt; i n , f <em>i f </em>{ i - 1 } <span class="math inline">\(,那我们的修改就一定可以实现.因为这等价于把后面的一个\)</span>A
<span class="math inline">\(挪前面去了.这样我们一开始进行操作使得整个序列满足\)</span>f
_i i $.</p>
<p>于是就有了一个$O ( n ^3 ) <span class="math inline">\(的dp,即设\)</span>dp _{ i , k } <span class="math inline">\(表示跳到\)</span>i <span class="math inline">\(跳了\)</span>k <span class="math inline">\(步的最小花费,每次跳到\)</span>j <span class="math inline">\(的话要求把\)</span>[ i , n ] <span class="math inline">\(上的所有\)</span>f <span class="math inline">\(对\)</span>j - 1 <span class="math inline">\(取\)</span>$.</p>
<p>仔细观察上面的过程,不难发现答案关于$k <span class="math inline">\(是凸的,用wqs二分去掉第二维,于是现在就有了一个\)</span>O
( n ^2 n ) $的一维dp.</p>
<p>不妨设$sum _x <span class="math inline">\(表示\)</span>f _i x <span class="math inline">\(的\)</span>f _i <span class="math inline">\(之和,\)</span>cnt _x <span class="math inline">\(表示这样的\)</span>f _i <span class="math inline">\(的个数,再设\)</span>pre _i <span class="math inline">\(为\)</span>f <span class="math inline">\(的前缀和.由于\)</span>f _i i $,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
dp _i &amp; = dp _j + \\
( i - 1 ) ( cnt _{ i - 1  } - j + 1 ) - sum _{ i - 1  } + pre _{ j -
1  } - val
\end{aligned}
\]</span></p>
<p>其中$val <span class="math inline">\(是wqs二分出来的惩罚量.然后如果能选前面的\)</span>i
$尽量选靠前的.再就是dp过程中需要记录跳了几步,但是不作为dp的维度而是内容.</p>
<p>显然可以斜率优化,于是复杂度$O ( n n ) $.</p>
<h4><span id="第六题">第六题</span></h4>
<p>考虑Hall定理,设最后的盒子是$x _1 , x _2 , , x _k
$,将它们<strong>从大到小</strong>排序,那么合法当且仅当:</p>
<ol type="1">
<li><p>$x = a $.</p></li>
<li><p>$k , _{ i = 1 } ^k x <em>i </em>{ i = 1 } ^n { k , a _i }
$.</p></li>
</ol>
<p>为啥是这个方向的Hall定理呢?因为我们肯定要对$x
$做一个背包的问题,这个时候肯定是对后面那一个已知的操作会比较好.</p>
<p>然后就直接dp.把$b <span class="math inline">\(从大到小排序,\)</span>f
_{ i , j , k } <span class="math inline">\(表示当前考虑前\)</span>i
<span class="math inline">\(个\)</span>b <span class="math inline">\(,选了\)</span>j <span class="math inline">\(个,和为\)</span>k <span class="math inline">\(是否可行,用bitset优化一下得到\)</span>O ( { w } )
$的算法.</p>
<p>但是实际上,考虑到$m <span class="math inline">\(其实是\)</span> <span class="math inline">\(级别的,再注意到dp的过程中,\)</span>j { b _i }
<span class="math inline">\(,因此\)</span>max _j = O ( S S ) <span class="math inline">\(,所以这个算法是\)</span>O ( { w } ) $的.</p>
<p>实现可以使用滚动数组.然后压位的话要压掉最后一维.</p>
<p>dp的话是下面这样的:</p>
<p><span class="math display">\[
\begin{gathered}
dp _{ i , j , k  } \rightarrow dp _{ i + 1 , j , k  } \\
dp _{ i , j , k  } \rightarrow dp _{ i , j + 1 , k + b _i  }
\end{gathered}
\]</span></p>
<p>算的时候记得删掉过大的$k $.</p>
<p>看到这种dp可能第一反应是考虑能不能交换dp状态和dp值,但是这个哪一维状态也不是和状态是单调的.</p>
<p>至于构造方案,暴力用堆一个一个做.</p>
<h3><span id="组合数学">组合数学</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_jsc2019_qual_f</p>
<p>比较牛.首先千万要看清楚不是每个点的值在$[ L , R ] <span class="math inline">\(之间而是和在\)</span>[ L , R ] $之间!</p>
<p>然后考虑后者怎么做.注意到如果是第$M <span class="math inline">\(大等于第\)</span>M + 1 <span class="math inline">\(大的话,中间那一段会是一段连续的,这个特别难搞.所以我们考虑求第\)</span>M
<span class="math inline">\(大不等于第\)</span>M + 1 <span class="math inline">\(大,这样前\)</span>M <span class="math inline">\(个和后\)</span>N - M
$个数字其实就分开了.而且因为前后没有相等的数字,我们很容易把它们乱序合并起来.</p>
<p>因此接下来的关键在于把前后分开,假设$a _M = x <span class="math inline">\(,那么前\)</span>M <span class="math inline">\(个数字大于等于\)</span>x <span class="math inline">\(,后\)</span>M <span class="math inline">\(个数字小于\)</span>x <span class="math inline">\(.不妨假设此时全局和为\)</span>s
$,那我们如何解决这个问题呢?</p>
<p>首先较大的那几个可以隔板法做,较小的那几个是个经典容斥:枚举有几个大于等于$x
<span class="math inline">\(的,这个数量不会超过\)</span> { x }
$,然后剩下的暴力隔板.</p>
<p>写式子之前考虑上面那个$s <span class="math inline">\(怎么办,总不能暴力枚举,其实写出来也可以用二项式技巧去掉,但是更重要的是,为啥你不转化成和在\)</span>[
0 , R ] <span class="math inline">\(的答案减去和在\)</span>[ 0 , L - 1 ]
$的答案呢?这下做完了.</p>
<p>于是我们只考虑限制是$[ 0 , R ] $.</p>
<p>这个时候我还在想要把左右两边分开求答案然后卷起来,但是这样还是避免不了枚举一边的和.事实上,我们可以把二者放在一起做容斥.下面式子会给出一个显式的表达.另外就是,有一个很大的问题在于我们如何钦定$a
<em>M = x <span class="math inline">\(,这一点其实是难以做到的.但我们可以钦定\)</span>a
<em>M x , a </em>{ M + 1 } &lt; x <span class="math inline">\(,然后再减去\)</span>a <em>M x + 1 , a </em>{ M + 1
} &lt; x <span class="math inline">\(.为了方便,我们不妨设\)</span>a
<em>M x , a </em>{ M + 1 } y <span class="math inline">\(的答案是\)</span>f ( x , y ) <span class="math inline">\(,然后我们要求的就是\)</span></em>{ x } f ( x , x -
1 ) - f ( x + 1 , x - 1 ) $.</p>
<p>接下来写一下$f ( x , y ) $的式子:</p>
<p><span class="math display">\[
f ( x , y ) = \sum _{ i = 0  } \binom { N - M  } { i  } ( - 1 ) ^i
\binom { R - Mx - i ( y + 1 ) + N  } { N  }
\]</span></p>
<p>乍一看不太能算,实际上注意到$R - Mx - i ( y + 1 ) <span class="math inline">\(,由于\)</span>x , y <span class="math inline">\(同级别,这意味着\)</span>i <span class="math inline">\(大致是\)</span> { x }
$级别的.于是就是一个调和级数复杂度.</p>
<h4><span id="第二题第三题">第二题/第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1264D2</p>
<p>直接做的hard version.</p>
<p>首先我们发现,不妨我们最后取出来的串一定是个$( ( ( ) ) ) <span class="math inline">\(这样的结构.再进一步,我们找到这个结构在原串上的分界点,设其左侧有\)</span>s
_l <span class="math inline">\(个\)</span>( <span class="math inline">\(,右侧有\)</span>s _r <span class="math inline">\(个\)</span>) <span class="math inline">\(,那么这个串的长度一定形如\)</span>{ s _l , s _r }
<span class="math inline">\(,由于随着分界点的右移,\)</span>s _l <span class="math inline">\(增大,\)</span>s _r
$减小,因此一定是它俩相等的时候最优秀.</p>
<p>于是我们考虑枚举分界点,对于每个分界点枚举答案.不妨设左侧有$a _l <span class="math inline">\(个问号,总共有\)</span>a $个问问号,答案显然是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k  } k \binom { a _l  } { k - s _l  } \binom { a - a _l  } { k -
s _r  } \\
&amp; = \sum _{ k  } ( k - s _l ) \binom { a _l  } { k - s _l  } \binom
{ a - a _l  } { k - s _r  } + \sum _{ k  } s _l \binom { a _l  } { k - s
_l  } \binom { a - a _l  } { k - s _r  } \\
&amp; = a _l \sum _{ k  } \binom { a _l - 1  } { k - s _l - 1  } \binom
{ a - a _l  } { k - s _r  } + s _l \sum _{ k  } \binom { a _l  } { k - s
_l  } \binom { a - a _l  } { k - s _r  } \\
&amp; = a _l \sum _{ k  } \binom { a _l - 1  } { a _l - k + s _l  }
\binom { a - a _l  } { k - s _r  } + s _l \sum _{ k  } \binom { a _l  }
{ a _l - k + s _l  } \binom { a - a _l  } { k - s _r  } \\
&amp; = a _l \binom { a - 1  } { a _l + s _l - s _r  } + s _l \binom {
a  } { a _l + s _l - s _r  }
\end{aligned}
\]</span></p>
<p>不过这里有个问题啊,那就是$a = 0 <span class="math inline">\(怎么办,扩域的二项式我其实是不太会算的.于是我特判了\)</span>a
= 0 $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc146_e</p>
<p>由于相同值域相互间有限制,不妨考虑值域那一维扫一下.</p>
<p>进一步地,我们考虑维护若干个上升的直线,然后每次可以选择把两条直线并起来成为一个峰,或者凭空分裂出两条直线作为一个谷.维护直线数量并且从下往上扫就可以了.</p>
<p>但是你注意一个问题,我们是不能先分裂出两条直线,再把它俩合并起来的.考虑能不能设计一点自适应的东西.当前的直线数量一定是偶数,然后我们每隔一个判断是否要合并,或者直接在一半的空位置上判断是否要分裂就行.更具体地,我们设$f
_{ i , j } <span class="math inline">\(表示当前有\)</span>j <span class="math inline">\(个位置能放\)</span>i <span class="math inline">\(的答案.显然\)</span>j = b _i
$,所以这一维看上去是没用的.</p>
<p>但是我们仔细想一想,我们要维护若干条折线.这些折线是有左右端点的,我们需要做的就是要么加入一条折线,要么合并两条折线,这两个操作都会带来一个空位置.而一条不操作的折线会带来两个空位置.其实相当于每个操作减少了一个空位置.不过有一个问题啊,我们只能通过$b
_i
$得知有多少个空位置,却不知道有多少条折线.事实上空位置数量=折线端点数量+操作次数.也就是说,和dp关系比较大的是折线数量,但我们只能推测出空位置数量.这下这下了.</p>
<p>但是但是但是,我们写一个$O ( n ^2 ) <span class="math inline">\(的dp,\)</span>f <em>{ i , j , 0 / 1 , 0 / 1 }
<span class="math inline">\(表示当前做到\)</span>i <span class="math inline">\(,有\)</span>j <span class="math inline">\(条折线,左端点是否已经选定,右端点是否已经选定.为啥要记录后两维呢?因为这不是环,这是一个排列,最左侧端点和最右侧端点是有可能直接停步的.因此我们还得讨论这个.说实话有点麻烦,所以我们先忽略左右端点,假设它们一直延伸.不妨设\)</span>k
= cnt </em>{ merge } - cnt <em>{ split } <span class="math inline">\(,自然有\)</span>k = 2 j - b <em>i <span class="math inline">\(.不放在设\)</span>w = cnt </em>{ split } , cnt
</em>{ merge } = k + w <span class="math inline">\(,再设\)</span>F ( n ,
m ) <span class="math inline">\(为将\)</span>n <span class="math inline">\(个无编号球放到\)</span>m <span class="math inline">\(个有编号盒子(盒子可空)的方案数,不难发现\)</span>F
( n , m ) = { m - 1 } $.那我们有:</p>
$$
<span class="math display">\[\begin{gathered}
f _{ i - 1 , j  } \sum _{ w \geq 0  } \binom { j - 1  } { k + w  } F ( w
, j - w - k + 1 ) \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \sum _{ w  } \binom { j - 1  } { k + w  } \binom { j -
k  } { j - w - k  } \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \binom { 2 j - k - 1  } { j  } \rightarrow f _{ i , j
- k  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>用范德蒙德卷积的时候一定要注意,这个东西是扩域后的二项式,因此一定要在意一下枚举量是否取遍整数,这里是发现如果$w
&lt; 0 $,那么后面那个组合数一定是$0 $.</p>
<p>原本其实很怕这个转移,因为觉得很麻烦,但其实写出来就不麻烦了.甚至加两维也是好做的,我们不妨设后两维的和为$t
$,就是几个端点是挂的,我们仍然有:</p>
<p><span class="math display">\[
\begin{aligned}
b _i &amp; = 2 ( j - k ) + cnt _{ merge  } - cnt _{ split  } - t +
\Delta t \\
k &amp; = 2 j - t + \Delta t - b _i
\end{aligned}
\]</span></p>
<p>其中$t <span class="math inline">\(是决定在这里停步的端点数量,\)</span>t <span class="math inline">\(是停步后的端点数量,\)</span>j - k <span class="math inline">\(是做完选择后,在\)</span>i <span class="math inline">\(处的折线数量,两个\)</span>cnt
$都是在做选择的<strong>过程中</strong>所做的merge和split的抉择数量.这样我们就完成了转移.</p>
<p>没完没完,差点就寄了.如果左右端点没有确认,那么我们是可以在左边或者右边split的.令$t
’ = t - t $,于是重推一下式子:</p>
$$
<span class="math display">\[\begin{gathered}
f _{ i - 1 , j  } \sum _{ w \geq 0  } \binom { j - 1  } { k + w  } F ( w
, j - w - k + 1 - t &#39; ) \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \sum _{ w  } \binom { j - 1  } { k + w  } \binom { j -
k - t &#39;  } { j - w - k - t &#39;  } \rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \binom { 2 j - k - 1 - t &#39;  } { j - t &#39;  }
\rightarrow f _{ i , j - k  } \\
f _{ i - 1 , j  } \binom { b _i - 1  } { j - t &#39;  } \rightarrow f _{
i , j - k  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这一步步是怎么加上去的呢?实际上是按照先merge,再slipt,再stop来做的.因为split一定要放在最后,防止split了一个stop的点或者split在了一个merge好了的区间中.</p>
<p>但是这个转移是$O ( n b ) <span class="math inline">\(的,咋办呢?我们本着先冷静再冷静始终冷静的想法,去考虑一下\)</span>j
<span class="math inline">\(的取值:不难发现在上面的操作过程中,基本都是一个\)</span>j
<span class="math inline">\(对应一个\)</span>j - k <span class="math inline">\(,只有在\)</span>t <span class="math inline">\(变化的时候才会增加一个状态,这意味着\)</span>O (
cnt _t ) = O ( cnt _j ) <span class="math inline">\(,因此总空间是\)</span>O ( n ) <span class="math inline">\(的,于是时间也是\)</span>O ( n ) <span class="math inline">\(的,拿map维护一下这个dp就行,时间退化至\)</span>O (
n n ) $.</p>
<p>再有一个细节就是组合数怎么办,哦,$b $这么小,那没事了.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P6276</p>
<p>首先显然不会破坏环的形态.也就是说,你把所有置换环的长度求出来然后求lcm就是一个排列的阶.这直接启发我们对于每个质数分开求贡献.</p>
<p>更进一步地,我们发现只要排列中有$p ^k <span class="math inline">\(的倍数,我们就直接贡献一个\)</span>p <span class="math inline">\(作为答案.因此我们枚举\)</span>q = p ^k <span class="math inline">\(并统计有多少个排列至少有长度为\)</span>q <span class="math inline">\(的倍数的环.这都至少了,直接容斥就行,我们设当前有\)</span>i
$个点,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ i  } &amp; = \sum _{ q | k  } - f _{ i - k , j - 1  } \binom { i -
1  } { k - 1  } ( k - 1 ) ! \\
&amp; = \sum _{ q | k  } - { ( i - 1 )  } ^{ \underline { k - 1  }  } f
_{ i - k , j - 1  }
\end{aligned}
\]</span></p>
<p>$_{ q | i } - f _i ( n - i ) ! { i } <span class="math inline">\(就是答案.这样复杂度是\)</span>O ( ( { q } ) ^2 ) =
O ( n ^2 ) <span class="math inline">\(,事实上要更少,因为你发现我们只会对某个\)</span>q =
p ^k $做这个东西.</p>
<p>另外由于模数不确定,我们还要对着每个$i $预处理下降幂,有点难蚌的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc060_d</p>
<p>ps:本题选入笔记:常见套路-组合意义-Example3.</p>
<p>这题听了三遍,直接抄笔记.</p>
<p>不妨设$C _p = { i | p <em>i &gt; p </em>{ i + 1 } , 1 i &lt; n }
$.</p>
<p>用一下组合意义,注意到答案等于:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2
\]</span></p>
<p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2 = \sum _{ S  } ( \sum _{ S
\subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C
_p ] ) ^2
\]</span></p>
<p>这个咋做呢?我们考虑用组合意义展开:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | -
| S |  } [ T \subseteq C _p ] ) ^2 \\
&amp; = \sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T
_1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [
T _2 \subseteq C _p ] )
\end{aligned}
\]</span></p>
<p>注意到$S $屁用没有,直接交换枚举顺序.</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + |
T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2
\subseteq C _p ] ) \\
&amp; = \sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T
_1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [
T _2 \subseteq C _p ] )
\end{aligned}
\]</span></p>
<p>考虑$( _{ p } [ T _1 C _p ] ) <span class="math inline">\(怎么求,注意到这等价于所有\)</span>T _1 <span class="math inline">\(中的位置全都被钦定为\)</span>&gt; <span class="math inline">\(,而其他位置任意,如果我们设所有以大于号连接的部分的长度为\)</span>l
_1 , l _2 , . . . , l <em>k <span class="math inline">\(,那么这里的答案就是\)</span>n ! </em>{ i = 1 } ^k
{ l _i ! } $.</p>
<p>但我们很快发现了难点:$2 ^{ | T _1 T _2 | }
$这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在$T _1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(中都是\)</span>&gt; <span class="math inline">\(的位置,这个好像不太好求,因为\)</span>&gt;
$是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | +
| T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2
\subseteq C _p ] ) \\
&amp; = \sum _{ T _1 , T _2  } 2 ^{ ( ( n - 1 ) - | T _1 \cup T _2 | ) -
( n - 1 )  } ( - 2 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1
\subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
&amp; = 2 ^{ 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1
|  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 )
^{ | T _2 |  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - |
T _1 \cup T _2 |  }
\end{aligned}
\]</span></p>
<p>其中$n - 1 - | T _1 T _2 | <span class="math inline">\(意味着均不在\)</span>T _1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(中的位置的数量.为了给每一段连续的\)</span>&gt;
$都分配权值,我们进行一个细小的修改:</p>
<p><span class="math display">\[
2 ^{ - 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 | + 1  }
\frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ |
T _2 | + 1  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T
_1 \cup T _2 |  }
\]</span></p>
<p>写到这里应该就能发现,接下来必然要对$n - 1 - | T _1 T _2 | <span class="math inline">\(做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对\)</span>T
_1 <span class="math inline">\(和\)</span>T _2 <span class="math inline">\(求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了\)</span>&gt;
$,我们自然有:</p>
$$
<span class="math display">\[\begin{gathered}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T
_1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  }
( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{
2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时$| T _1 T _2 |
<span class="math inline">\(这个限制就显得尤其强,如果只是\)</span>S T _1
, T _2 <span class="math inline">\(就会好做很多:我们可以钦定\)</span>S
$作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
$$
<span class="math display">\[\begin{aligned}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T
_1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  }
( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{
2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\
&amp; = 2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } \sum _{ S \subseteq T
_1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } {
\prod l _{ 1 , i  } !  } ) \sum _{ S \subseteq T _2  } ( \frac { 1  } {
( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>令$f ( T ) = <em>{ S T } ( { ( - 2 ) ^{ | T | + 1 } } { l </em>{ 2 ,
i } ! } ) \ $,则原式即:</p>
<p><span class="math display">\[
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } ( \sum _{ S \subseteq T  } f ( T )
) ^2
\]</span></p>
<p>考虑下面这个东西怎么求:</p>
<p><span class="math display">\[
\sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2
\]</span></p>
<p>注意到,如果我们把每一段($[ T <em>i , T </em>{ i + 1 } ) <span class="math inline">\()的贡献求和,那么\)</span>f ( T ) <span class="math inline">\(相当于这些和乘起来,那么\)</span>( <em>{ S T } f (
T ) ) ^2 <span class="math inline">\(就是这些和的平方乘起来.换句话说,我们自然有\)</span>ans
<em>n = </em>{ m } ans </em>{ n - m } g ^2 _{ m } <span class="math inline">\(,其中\)</span>g <em>m <span class="math inline">\(表示长度为\)</span>m <span class="math inline">\(的一段的贡献之和.而\)</span>g </em>{ n } = <em>m g
</em>{ n - m } { - 2 m ! } <span class="math inline">\(.二者都可以使用分治FFT或多项式求逆解决.更进一步地,\)</span>h
_i = { - 2 i ! } , G = { 1 - H } , F = { 1 - G } $.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将$( &gt; , &gt; ) $容斥掉,这样我们有若干种对:$2 ( &lt;
, &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e ) <span class="math inline">\(,然后我们发现两个序列联系得太紧了,我们考虑分配系数:\)</span>&lt;
<span class="math inline">\(,\)</span>e - { } <span class="math inline">\(,但是这样发现\)</span>( e , e )
$算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1188E</p>
<p>首先发现肯定不可能所有颜色都点过,那么至少有一个颜色没点过.</p>
<p>然后呢?考虑操作序列和答案序列是否一一对应,事实上确实是这样,因为至少有一个颜色没点过,因此可以找到下降最多的那个颜色,这样就知道了总共操作过程.然后由每个颜色减少的次数,就可以知道每种颜色操作的次数.接下来就只需要对于每种操作次数判断是否能在全程非负的前提下做完.</p>
<p>一个显然的必要条件是,不妨设$l _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(种颜色操作次数,\)</span>a _i + l _i k l <span class="math inline">\(.但是操作过程中有可能有负数,这个怎么办呢?注意到为了让\)</span>a
<span class="math inline">\(不变负数,我们必须要让它在\)</span>a _i + 1
<span class="math inline">\(时刻前完成至少一次操作,在\)</span>a _i + k +
1 $时刻前完成至少两次操作……</p>
<p>注意到只需要满足第一个条件就行,因为后面的条件只需要把当前所有需要做的人排个序,挨个做.显然就一定会满足条件.根据Hall定理,从前往后判断每一时刻是不是能填满前面的每个人,并将它和$a
<span class="math inline">\(取\)</span><span class="math inline">\(得到\)</span>maxt <span class="math inline">\(,这就是\)</span>l <span class="math inline">\(的最大值.不难发现只要\)</span>l maxt <span class="math inline">\(就一定有解.枚举\)</span>t <span class="math inline">\(计算每个\)</span>a <span class="math inline">\(需要的次数,剩下的次数随意分配,注意要保证\)</span>l
= 0 <span class="math inline">\(,要减去\)</span>l $的情况.</p>
<p>事实上啊,只要我们得知了前一个要求条件然后枚举$t
$就行,时刻维护着复杂度就对,根本不用管后面的东西.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1595</p>
<p>弱智题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://darkbzoj.cc/problem/4665</p>
<p>直接容斥,用dp出前$i <span class="math inline">\(个人,钦定\)</span>j
$个人拿到了自己的糖果的方案数.然后容斥起来就行.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4859</p>
<p>ps:本题选入笔记:容斥与反演-容斥-Example3.</p>
<p>首先可以用dp+双指针得到$f _i <span class="math inline">\(表示勒令\)</span>i <span class="math inline">\(对满足条件的方案数.把\)</span>k <span class="math inline">\(的定义改为恰好\)</span>k
$对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a <span class="math inline">\(对的方案会被恰好\)</span>b <span class="math inline">\(对的方案计算\)</span> { a } <span class="math inline">\(次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为\)</span>k
$的方案贡献为$1 <span class="math inline">\(,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为\)</span>k
+ 1 $的方案贡献为$0 <span class="math inline">\(,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令\)</span>ans
= f <em>k <span class="math inline">\(,第二步除去其中被多算的\)</span>k
+ 1 <span class="math inline">\(,这一步令\)</span>ans - = { k } f </em>{
k + 1 } <span class="math inline">\(.这个时候,我们再考虑\)</span>k + 2
<span class="math inline">\(的贡献:它将在\)</span>f <em>k <span class="math inline">\(时贡献\)</span> { k } <span class="math inline">\(次,在\)</span>f </em>{ k + 1 } <span class="math inline">\(时贡献\)</span>- { k + 1 } { k } = - { k } { 1 }
<span class="math inline">\(次,那它现在的贡献还有:\)</span>- { k } <span class="math inline">\(次.以此类推,可以得到\)</span>ans = _{ i = k } ^n f
_i ( - 1 ) ^{ i - k } { k } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P
_i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i <span class="math inline">\(,因为只有这个时候,我们才能通过分析满不满足\)</span>P
_i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1
/ 0 $就行.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://darkbzoj.cc/problem/2839</p>
<p>简单二项式反演.(埋下伏笔)</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://codeforces.com/gym/101933/problem/K</p>
<p>考虑如果用小于等于$k <span class="math inline">\(种是好计算的(设为\)</span>f _k <span class="math inline">\(),显然\)</span>f _k = k ( k - 1 ) ^{ n - 1 }
$,对着做二项式反演.</p>
<p>一开始想直接拿$f <em>k - f </em>{ k - 1 }
$,实际上不行,因为颜色之间是有区别的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6478</p>
<p>这个题面真你妈逆天.</p>
<p>发现我们要求恰好$k <span class="math inline">\(个,自然的想法是想到钦定\)</span>k <span class="math inline">\(个,不妨假设钦定\)</span>k <span class="math inline">\(个的答案是\)</span>f _k $,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } ans _i \\
ans _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } ( - 1 ) ^{ i -
k  } f _i
\end{aligned}
\]</span></p>
<p>至于$f <span class="math inline">\(怎么求,你直接dp,设\)</span>dp _{ i
, j } <span class="math inline">\(表示当前在\)</span>i <span class="math inline">\(,子树内部选了\)</span>j <span class="math inline">\(对祖先后代,那我们就知道目前子树内还有多少可以和\)</span>i
$配对.合并是个树形背包.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1228E</p>
<p>ps:本题选入笔记:容斥与反演-反演-二项式反演-Example3.</p>
<p>不妨设至多有$i <span class="math inline">\(行\)</span>j $列最小值为$1
<span class="math inline">\(的答案是\)</span>f <em>{ i , j } <span class="math inline">\(,恰好有\)</span>i <span class="math inline">\(行\)</span>j $列最小值为$1 <span class="math inline">\(的答案是\)</span>g </em>{ i , j } $,注意到:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>令$h <em>{ n , m } = </em>{ j = 0 } ^m { j } g <em>{ n , j } \ <span class="math inline">\(,则\)</span>f </em>{ n , m } = <em>{ i = 0 } ^n {
i } h </em>{ i , m } \ <span class="math inline">\(,而\)</span>f _{ n ,
m } = k ^{ nm } ( k - 1 ) ^{ NM - nm } <span class="math inline">\(.做两次二项式反演得到\)</span>g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f
_{ n , m } { n } { m } k ^{ nm } ( k - 1 ) ^{ NM - nm }
$呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  }
g _{ s , t  } \\
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } &amp; = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ S , T  } &amp; = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S |
| T |  } \\
h _{ S , T  } &amp; = \sum _{ s \subseteq S  } ( - 1 ) ^{ | s | - | S
|  } f _{ s , T  } \\
g _{ S , T  } &amp; = \sum _{ t \subseteq T  } ( - 1 ) ^{ | t | - | T
|  } h _{ S , t  }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g <em>{ n , m } <span class="math inline">\(本身就包含了所有\)</span>| S | = n , | T | = m
<span class="math inline">\(的情况的和,并且在组合数\)</span> { j } <span class="math inline">\(那里就找到了唯一确定的\)</span>f </em>{ s , t }
<span class="math inline">\(,因此\)</span>f _{ n , m } <span class="math inline">\(是唯一确定的.这意味着这里\)</span>f <span class="math inline">\(的\)</span>n , m
$并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } f _i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个问题其实非常显然,我们的$g _{ i , j } <span class="math inline">\(定义为所有\)</span>| S | = i , | T | = j <span class="math inline">\(的答案之和.\)</span>f
$也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{
j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M } <span class="math inline">\(,那此时\)</span>g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,$g <span class="math inline">\(是已知的集合,\)</span>f <span class="math inline">\(是未知的集合.我们乘上组合数就可以得到对于\)</span>f
$来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f <span class="math inline">\(的定义改成\)</span>f _{ n , m } = k ^{ nm } ( k -
1 ) ^{ NM - nm } $就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知$n <span class="math inline">\(行\)</span>m <span class="math inline">\(列的集合的前提下,从中选出\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列并求\)</span>g <span class="math inline">\(.那么你从哪知道的\)</span>n <span class="math inline">\(行\)</span>m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } \sum _{
i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } {
j  } g _{ i , j  } \\
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } k ^{
nm  } ( k - 1 ) ^{ NM - nm  }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ’ <em>{ i ,
j } <span class="math inline">\(为至少有\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列不满足条件的方案数,自然有\)</span>f ’ </em>{ i ,
j } = f _{ N - i , M - j } $.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39; _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j
= m  } ^M \binom { j  } { m  } g &#39; _{ i , j  }
\]</span></p>
<p>最后答案就是$g ’ _{ 0 , 0 } $.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF997C</p>
<p>和上一题差不多,不妨设$g <em>{ n , m } <span class="math inline">\(表示恰好有\)</span>n <span class="math inline">\(行\)</span>m <span class="math inline">\(列同色的答案,\)</span>f </em>{ i , j } <span class="math inline">\(为钦定\)</span>i <span class="math inline">\(行\)</span>j $列同色的答案,自然有:</p>
<p><span class="math display">\[
g _{ n , m  } = \sum _{ i = n  } ^N ( - 1 ) ^{ i - n  } \binom { N  } {
i  } \binom { i  } { n  } \sum _{ j = m  } ^N ( - 1 ) ^{ j - m  } \binom
{ N  } { j  } \binom { j  } { m  } f _{ i , j  }
\]</span></p>
<p>可以求出$g _{ 0 , 0 } $然后再拿全集减一下.</p>
<p>我们求一下$g _{ 0 , 0 } $:</p>
<p><span class="math display">\[
g _{ 0 , 0  } = \sum _{ i = 0  } ^N ( - 1 ) ^{ i  } \binom { N  } { i  }
\sum _{ j = 0  } ^N ( - 1 ) ^{ j  } \binom { N  } { j  } f _{ i , j  }
\]</span></p>
<p>注意到$[ i = 0 j = 0 ]
$的时候算的挺特殊的,因此先把那些算掉,我们就只需要算下面这个东西:</p>
<p><span class="math display">\[
3 \sum _{ i = 1  } ^N ( - 1 ) ^{ i  } \binom { N  } { i  } \sum _{ j =
1  } ^N ( - 1 ) ^{ j  } \binom { N  } { j  } 3 ^{ ( N - i ) ( N - j )  }
\]</span></p>
<p>看后面那一块:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ j = 1  } ^N ( - 1 ) ^{ j  } \binom { N  } { j  } { ( 3 ^{ ( N -
i )  } )  } ^{ ( N - j )  } \\
&amp; = ( - 1 ) ^{ [ N \ne 0 \pmod { 2  } ]  } \sum _{ j = 1  } ^N ( - 1
) ^{ N - j  } \binom { N  } { N - j  } { ( 3 ^{ ( N - i )  } )  } ^{ ( N
- j )  }
\end{aligned}
\]</span></p>
<p>再看后面那一块:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ j = 1  } ^N ( - 1 ) ^{ N - j  } \binom { N  } { N - j  } { ( 3
^{ ( N - i )  } )  } ^{ ( N - j )  } \\
&amp; = \sum _{ j = 0  } ^{ N - 1  } ( - 1 ) ^j \binom { N  } { j  } { (
3 ^{ N - i  } )  } ^{ j  } \\
&amp; = \sum _{ j = 0  } ^{ N  } ( - 1 ) ^j \binom { N  } { j  } { ( 3
^{ N - i  } )  } ^{ j  } - ( - 1 ) ^N { ( 3 ^{ N - i  } )  } ^N \\
&amp; = ( 1 - 3 ^{ N - i  } ) ^N - ( - 1 ) ^N { ( 3 ^{ N - i  } )  } ^N
\end{aligned}
\]</span></p>
<p>这样就做完了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4491</p>
<p>直接二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^{ m  } ( - 1 ) ^{ i - k  } \binom { m  }
{ i  } \binom { i  } { k  } \binom { n  } { iS  } \frac { ( iS ) !  } {
( S ! ) ^i  } ( m - i ) ^{ n - iS  } \\
&amp; = \sum _{ i = k  } ^{ m  } ( - 1 ) ^{ i - k  } \frac { m !  } { (
m - i ) !  } \frac { 1  } { k ! ( i - k ) !  } \frac { n !  } { ( n - iS
) !  } \frac { 1  } { ( S ! ) ^i  } ( m - i ) ^{ n - iS  }
\end{aligned}
\]</span></p>
<p>令$tag = m ! n ! $,自然有:</p>
<p><span class="math display">\[
\frac { k ! f _k  } { tag  } = \sum _{ i = k  } ^m \frac { ( - 1 ) ^{ i
- k  }  } { ( i - k ) !  } \frac { ( m - i ) ^{ n - iS  }  } { ( m - i )
! ( n - iS ) ! ( S ! ) ^i  }
\]</span></p>
<p>注意到枚举量即$i , k , i - k <span class="math inline">\(,是一个卷积的形式,更进一步地,我们设\)</span>F
<em>k = { tag } , g </em>{ i } = { i ! } , h _i = { ( m - i ) ! ( n - iS
) ! ( S ! ) ^i } \ $.自然有:</p>
<p><span class="math display">\[
F _k = g _{ i - k  } h _i
\]</span></p>
<p>再设$g <em>k = G </em>{ m - k } , G <em>k = g </em>{ m - k }
$,自然有:</p>
<p><span class="math display">\[
F _k = G _{ m - i + k  } h _i
\]</span></p>
<p>ntt即可.</p>
<h4><span id="第十题第十一题">第十题/第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4931</p>
<p>ps:本题选入笔记:多项式与生成函数-生成函数-求微分方程</p>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } \binom { n  } { i  } \binom { n  } { i  } i ! ( 2 n - 2 i ) ! 2 ^i
\\
&amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { k ! ( i -
k ) !  } \frac { n !  } { ( n - i ) !  } \frac { n !  } { ( n - i ) !  }
( 2 n - 2 i ) ! 2 ^i \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = k  } ^n ( - 1 )
^{ i - k  } \frac { 1  } { ( i - k ) !  } \binom { 2 n - 2 i  } { n -
i  } 2 ^{ i - k  } \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = 0  } ^{ n  }
\frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到后者只与$n - k <span class="math inline">\(有关,不妨设其为\)</span>f <em>{ n } = </em>{ i = 0
} ^{ n } { i ! } { n - i } <span class="math inline">\(,预处理一下就可以做到\)</span>O ( n ^2 + nT )
$.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } f _{ n - k  } \\
f _{ n  } &amp; = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } {
i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到$f <span class="math inline">\(是一个卷积的形式,设其生成函数为\)</span>F _n <span class="math inline">\(,\)</span>g _n = { n ! } , h _n = { n } <span class="math inline">\(,我们自然有\)</span>F = GH $.</p>
<p>考虑$G <span class="math inline">\(和\)</span>H <span class="math inline">\(的生成函数形式,先看\)</span>G
$,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum _{ n \geq 0  } \frac { ( - 2 x ) ^n  } { n !  } = e ^{ - 2 x  }
\]</span></p>
<p>再看$H $,是一个类似卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac { 1  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! ) ^2 \frac { 2 ^k  } { k !  } [ x ^{ n - k  } ] \frac { e ^{ - 2
x  }  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>现在看$F $,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F ^2 = e ^{ - 4 x  }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e ^{ - 4 x  } \\
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F ^2
\\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f _{ i + 1  } - 8 if _i &amp; = 16 f _{ i - 1  } \\
if _i &amp; = 4 ( i - 1 ) f _{ i - 1  } + 8 f _{ i - 2  }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P5339</p>
<p>简单题,不妨设当前这个序列中不同颜色的分别有$a , b , c , d <span class="math inline">\(个(区别于题面中的\)</span>A , B , C , D
$),自然有:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { k  } { 0  } \binom {
n - 3 k  } { k  } \frac { ( n - 4 k ) !  } { ( a - k ) ! ( b - k ) ! ( c
- k ) ! ( d - k ) !  } \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n - 3 k  } { k  } \frac
{ ( n - 4 k ) !  } { ( a - k ) ! ( b - k ) ! ( c - k ) ! ( d - k ) !  }
\end{aligned}
\]</span></p>
<p>然后对最后那个东西做背包就行.</p>
<h4><span id="第十三题">第十三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5400</p>
<h3><span id="字符串算法">字符串算法</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P7114</p>
<p>调和级数加哈希,简单题,场切了.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3526</p>
<p>注意到一个事实:如果这个字符串存在长度为$k <span class="math inline">\(的周期,等价于存在长度为\)</span>len - k
$的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设$q $为最小周期,如果$2 q n <span class="math inline">\(,也就是原串能写成\)</span>tt t ’ <span class="math inline">\(的形式.我们不妨先求\)</span>tt ’ <span class="math inline">\(对应的答案,然后在前面拼\)</span>t <span class="math inline">\(.根据\)</span> { 2 }
$的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果$2 q &gt; n <span class="math inline">\(,此时必定有\)</span>s =
tat <span class="math inline">\(,其中\)</span>t <span class="math inline">\(是border.考虑递归求解\)</span>t <span class="math inline">\(,然后就只需要找到一个\)</span>a <span class="math inline">\(满足条件,最小的\)</span>a $是全$0
$,能放的话肯定放,不然我们就放一个$0 $.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全$0 $不合法:</p>
<ol type="1">
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l |
t | + | a | <span class="math inline">\(:考虑\)</span>l
$的最后一段是一段全$0 <span class="math inline">\(,也就必然意味着\)</span>t $的最后一段是全$0
$,这么不断推下去就可以说明整个序列都是全$0 $,此时放上$0
$必定合法.</p></li>
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l
&gt; | t | + | a | <span class="math inline">\(:不妨设当前的\)</span>l
<span class="math inline">\(是最大的那个(最小的无意义,因为需要保证\)</span>| l
| &gt; | t | <span class="math inline">\(),此时最短周期必然是\)</span>d
= 2 | t | + | a | - l <span class="math inline">\(.由于\)</span>| t | +
| a | <span class="math inline">\(也是周期并且二者之和\)</span>n <span class="math inline">\(,因此必然有\)</span>d | ( | t | + | a | ) <span class="math inline">\(.把\)</span>ta <span class="math inline">\(按照\)</span>d <span class="math inline">\(长度划分.如果\)</span>d | a | $必有该串是全$0
<span class="math inline">\(串,不然考虑此时\)</span>d = | b | + | a |
<span class="math inline">\(,\)</span>b <span class="math inline">\(是\)</span>t <span class="math inline">\(的一段后缀.考虑此时的周期必然\)</span>&lt; | b | +
| a | <span class="math inline">\(,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比\)</span>|
b | - | a | <span class="math inline">\(少了\)</span>w <span class="math inline">\(,那么此时必定有\)</span>b <span class="math inline">\(的前\)</span>w $个字符是$0 $,但是由于$0 <span class="math inline">\(后面第一个\)</span>b <span class="math inline">\(也往前平移了\)</span>w <span class="math inline">\(格,因此它的第\)</span>w $个字符必定是$1
$,这就保证了$0 1 $必定合法.</p></li>
</ol>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6623</p>
<p>考虑怎么维护所有点权值$+ 1 <span class="math inline">\(后的结果.一个自然的想法是,如果前\)</span>[ 0 , k -
1 ] $位都是$1 <span class="math inline">\(,或者说\)</span>v - 1 <span class="math inline">\(,那加一后会让第\)</span>k <span class="math inline">\(位取反.所以我们设\)</span>t _{ i , j , k } <span class="math inline">\(表示\)</span>i <span class="math inline">\(的子树内,\)</span> ^k <span class="math inline">\(的结果为\)</span>j <span class="math inline">\(的权值的数量.发现这个非常容易维护,用启发式合并可以做到\)</span>O
( n ^2 n ) $.</p>
<p>考虑这个权值的变化其实比较有规律,因为是树上的距离的差.我们考虑把距离这个东西做树上差分,设$v
_i = c _i + dis ( i , 1 )
$,我们要找到子树内部满足条件的其实就是在找满足:</p>
<p><span class="math display">\[
\begin{aligned}
v _i - dis ( x , 1 ) - 1 &amp; \equiv - 1 \pmod { 2 ^k  } \\
v _i &amp; \equiv dis ( x , 1 ) \pmod { 2 ^k  }
\end{aligned}
\]</span></p>
<p>也就是说我们每次对这个桶中要找的元素很固定,用一下colorful
tree的trick可以做到$O ( n n ) $.</p>
<p>然后然后,这题还有一个无脑做法是,我们倒着建01trie,这样$+ 1
$后可以快速更新.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1535F</p>
<p>我一开始第一反应是对$n len ^5 $这玩意根号分治,但是麻烦得很.</p>
<p>我们来看我当时想的根号分治部分:首先枚举两个字符串然后判断是好做的.我们来看$n
<span class="math inline">\(很大,\)</span>len
$较小的时候:此时枚举某个串的后缀,并同时枚举其前缀,然后前缀相同的若干个字符是一个trie上的子树,dfn是一个区间,后缀同理,这样就是一个二维数点问题.</p>
<p>冷静看一下上面的过程,你需要判断中间那一段$[ l + 1 , r - 1 ] <span class="math inline">\(是否是单调不降的序列.那如果我们枚举\)</span>r
<span class="math inline">\(,然后直接看满足单调不降的序列最靠左的\)</span>l
<span class="math inline">\(是谁,再看\)</span>[ 1 , l ] <span class="math inline">\(相同,这样不就直接做完了嘛?总之,先按照字符不同分类,再按照字典序排序,然后枚举\)</span>r
<span class="math inline">\(,二分找LCP满足条件的区间,和trie上dfn区间构成一个二维数点,总复杂度\)</span>O
( n len len ) $.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3311</p>
<p>简单题,ACAM上做数位dp.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1437G</p>
<p>首先肯定可以fail树上树剖,这个做法一眼秒.</p>
<p>然后我看题解发现这个题也可以colorful
tree.大概就是你先离线,然后维护时间维的答案,那么所有的修改操作就可以改成将时间在$[
l , r ] <span class="math inline">\(这段的字数答案取\)</span>$.这个是一个二维的问题.</p>
<p>但是,我们按照colorful
tree的思路去搞,每次dfs到一个点的时候,把答案加入线段树,在返回的时候撤销.注意colorful
tree其实不用撤销,因为它的信息满足可减性,这题不行.然后就实现了单$<span class="math inline">\(做法.可以使用吉司机,但是没必要,因为查询是单点查询,在每个节点上标记永久化然后一路取\)</span>$就行.</p>
<p>总结一下上面的这个东西是啥啊,就是说,你发现我们查询的内容是到根的一条链的最大值,这个还挺难做的,因为这条链不满足什么区间的性质,但是子树满足,因此想到了我们可以把操作改成对子树取$$.但是这个操作不满足可减性,难以消去.</p>
<p>如果不满足可删除性,我们一般要想想它是不是满足可撤销性,显然是满足的.因此自然想到了colorful
tree.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1483F</p>
<p>这题可能比较像lxl当时讲的那个支配对问题.我们考虑合法的$( i , j )
<span class="math inline">\(的数量的一个上界.一个自然的发现是,考虑先把所有的串按照长度排个序,然后对于较长的串,去找较小的串是否和它满足条件,一个自然的观察是,对于这个较长的串的每个位置\)</span>i
<span class="math inline">\(,最多只有一个串是满足条件的\)</span>[ 1 , i
] <span class="math inline">\(的后缀.因为如果有多个后缀可以选取最长的那个(注意当\)</span>i
= len <span class="math inline">\(的时候要选次长的那个,最长的是这个串本身),于是合法的\)</span>(
i , j ) <span class="math inline">\(数量只有\)</span>len <span class="math inline">\(个.首先这些\)</span>( i , j ) <span class="math inline">\(是有重复的,不过去重很简单.我们现在需要判定是否统计上了\)</span>(
i , j ) <span class="math inline">\(和\)</span>( k , j ) <span class="math inline">\(使得\)</span>i <span class="math inline">\(是\)</span>k <span class="math inline">\(的子串,\)</span>k <span class="math inline">\(是\)</span>j <span class="math inline">\(的子串.不难发现如果有这种情况出现,必然是因为\)</span>k
<span class="math inline">\(在\)</span>j <span class="math inline">\(中的出现位置在某一个\)</span>i <span class="math inline">\(之后,但是\)</span>k <span class="math inline">\(中又出现了\)</span>i <span class="math inline">\(,因此它的左端点必然在\)</span>i
$之前.我们维护一个单调栈,每次弹出左端点比当前左端点靠右的那些点,这些一定不会贡献答案.</p>
<p>我本来以为这样就做完了,实际上没有,上面的过程出了什么问题呢?我们确实能删掉所有的$(
i , j ) <span class="math inline">\(使得存在\)</span>( k , j ) <span class="math inline">\(满足\)</span>i <span class="math inline">\(是\)</span>k <span class="math inline">\(的子串,并且\)</span>i <span class="math inline">\(不是\)</span>k
$的后缀.但是如果是后缀的话我们是有可能删不掉的.</p>
<p>这个问题怎么解决呢?考虑这种事情会发生当且仅当$i <span class="math inline">\(所代表的ACAM的节点是\)</span>k <span class="math inline">\(的父亲.于是我们用树状数组维护这个东西,具体来说,从大到小判断\)</span>i
<span class="math inline">\(是否合法,并且在这个点上\)</span>+ 1
$,用树状数组统计子树内部是否有点就行.注意即使被弹出栈的那些字符串,也需要在这个过程中删去它所有的后缀.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1110H</p>
<p>考虑一个暴力的想法是,这个$[ l , r ] <span class="math inline">\(的限制条件其实等价于要求\)</span>[ l , r ] <span class="math inline">\(内的所有数字作为子串出现的次数加起来.把所有的这些字符串全部扔进ACAM,然后对着它dp.不妨设\)</span>dp
_{ i , j } <span class="math inline">\(表示当前走到\)</span>i <span class="math inline">\(节点,然后后面还可以填\)</span>j
$个位置的答案,自然有:</p>
<p><span class="math display">\[
dp _{ i , j  } = \max \{ dp _{ son , j - 1  } \} + cnt _i
\]</span></p>
<p>其中$cnt _i <span class="math inline">\(表示\)</span>i
$节点是多少子串的endn,构造方案是简单的.</p>
<p>考虑如何优化,注意到dp部分看上去挺优秀的,难搞的是ACAM的建树.我们不能把所有数字全扔进去.这种区间信息看上去就是如果走到当前,后面全填$0
$或者后面全填$9
$都能满足条件,那我们就开摆.更具体地来说,我们发现当前的最靠前的那一位没有用了:以它为开头的一定可以找到一个答案(其实因为填的数位).所以我们直接跳fail把那一位跳掉.</p>
<p>如果说的再形象一点的话就是,我们插入的过程其实很废,对于一些特定的前缀$x
<span class="math inline">\(,它的子树内部会形成一个满十叉树.这个是我们无法接受的.来考虑这个东西怎么办,我们一路dfs到叶子后肯定要跳fail,根据ACAM的建树过程,这等价于跳到\)</span>x
<span class="math inline">\(的fail,因此其实就等价于把\)</span>x
$这一位(或者后面的几位)跳掉.</p>
<p>但是,如果你顺着这个思路想,你开始逐渐剥掉满十叉树,然后一点一点搞,你会做的巨他妈复杂.</p>
<p>我们完全没有必要只在满十叉树的时候才跳跃.换句话说,如果后面填$len
$长度的字符串全部合法,我们就在这里统计答案,然后继续跳son而不是fail.</p>
<p>我们考虑既然这里填$len <span class="math inline">\(都可以,那填\)</span>l - 1 <span class="math inline">\(的长度或者填\)</span>r + 1
$的长度就不一定能全部合法了.只有后面几位填的满足某种条件才能合法.但是你注意啊,我们并不在左端点统计答案,而是在这个串填到某一位(可能是最后一位),然后后面都可以随便填的时候,才统计这里的答案,不一定跳fail.而我们跳fail的时候,会删去若干个前缀字符,这些答案会随着fail链一路传过来.还有一个问题是,如果我们跳fail跳到了被删去的虚拟节点怎么办?这种情况压根不会有贡献:这个被删去的虚拟节点的贡献会被传到它的某个祖先上,然后早早地贡献掉.我们跳到的fail应该是第一个不是虚拟节点的位置.因此这里也不会被更新答案.</p>
<p>这样整个题就是简单的了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4218</p>
<p>首先有一个$O ( n ^2 ) <span class="math inline">\(的暴力是,我们暴力在\)</span>SAM
$上跑一遍所有的串.我们考虑怎么优化这个东西.</p>
<p>树上路径,想到点分治,我们考虑对于一个分治中心$x <span class="math inline">\(,求出所有经过它的路径.这个怎么求呢?我们考虑先求出所有\)</span>u
x <span class="math inline">\(的路径,以及所有\)</span>x v <span class="math inline">\(的路径,假设前者的终点为\)</span>p <span class="math inline">\(,后者的起点为\)</span>p <span class="math inline">\(,那我们可以在\)</span>p <span class="math inline">\(节点统计答案.但是发现\)</span>u x <span class="math inline">\(这个东西需要往前加字符,不过这个好做,首先往前加字符等价于在parent
tree上跳儿子,而所有的儿子前面的第一个字符肯定是不同的,我们处理出\)</span>son
_{ x , c } <span class="math inline">\(表示在\)</span>x <span class="math inline">\(这个节点,往前加一个字符\)</span>c
$会到哪个节点.当然这个你实在不行把串反过来也行.</p>
<p>以及为了不让$u <span class="math inline">\(和\)</span>v <span class="math inline">\(在同一棵子树内,我们需要对其做容斥.不难发现每次操作和每次容斥的复杂度都是\)</span>O
( m + size ) <span class="math inline">\(的.总复杂度\)</span>O ( n n +
nm ) $,好像不太行.</p>
<p>冷静一下,我们把$siz <span class="math inline">\(较小的那些拿上面的暴力处理掉,这样就只有\)</span>siz
$较大的那些会有用了.这个复杂度怎么证明呢?我们考虑点分树.不妨假设它是一棵二叉树(其它的情况是类似的).</p>
<p>考虑将它的第$B $层以下的树全部暴力,这里一共有$2 ^{ B } <span class="math inline">\(棵树,每棵复杂度是\)</span>O ( 2 ^{ 2 ( n - B ) } )
$的.</p>
<p>它的第$B $层以上的跑上面的点分树,这里一共有$2 ^B <span class="math inline">\(个节点,每个节点要跑一次\)</span>O ( n + m )
$的做法.</p>
<p>平衡一下复杂度,设$B = { 2 } <span class="math inline">\(,此时复杂度\)</span>O ( ( n + m ) ) $.</p>
<h3><span id="动态规划第二期">动态规划第二期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P9318</p>
<p>不合法的情况如此方便,因为两边直接独立了,因此直接考虑二项式反演,设$f
_k <span class="math inline">\(表示恰好有\)</span>k <span class="math inline">\(个裂缝,\)</span>g _k <span class="math inline">\(表示钦定有\)</span>k $个裂缝,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g _k &amp; = \sum _{ i = k  } ^w \binom { i  } { k  } f _i \\
f _k &amp; = \sum _{ i = k  } ^w \binom { i  } { k  } ( - 1 ) ^{ i -
k  } g _i \\
ans &amp; = f _0 &amp; = \sum _{ i = 0  } ^w ( - 1 ) ^{ i  } g _i
\end{aligned}
\]</span></p>
<p>考虑设一个高为$h <span class="math inline">\(,长为\)</span>k <span class="math inline">\(的段随便填的方案数,显然就是每一层都随便填的方案数,也就是\)</span>w
_k = ( F _k ) ^h ( w _0 = 0 ) <span class="math inline">\(,其中\)</span>F _k <span class="math inline">\(是斐波那契数列的第\)</span>k <span class="math inline">\(项,那么\)</span>g <em>i <span class="math inline">\(就是这玩意做卷积.更具体地,我们设\)</span>g </em>{
i , j } <span class="math inline">\(表示目前长度为\)</span>j <span class="math inline">\(,分成了\)</span>i $段的答案,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g _{ i , j  } &amp; = \sum _{ k &lt; j  } g _{ i - 1 , k  } w _{ j -
k  } \\
G _i &amp; = W ^i
\end{aligned}
\]</span></p>
<p>这个生成函数形式其实没啥用,因为模数是$10 ^9 + 7 <span class="math inline">\(.上述dp的复杂度是\)</span>O ( n ^3 ) $的.</p>
<p>冷静一下不要魔怔,我们考虑别二项式反演,直接补集转化,这样就只需要知道最靠前的裂缝.换句话说,我们设$f
_i <span class="math inline">\(表示当前考虑到前\)</span>i <span class="math inline">\(列,然后没有裂缝的方案数,不难发现\)</span>f _n = w
<em>n - </em>{ k = 1 } ^{ n - 1 } f <em>k w </em>{ n - k } <span class="math inline">\(.这样就是\)</span>O ( w ^2 ) $的.</p>
<p>冷静一下,注意到$wh <span class="math inline">\(有限制,因此复杂度应该要和\)</span>wh <span class="math inline">\(有关,考虑对于一个联通的块的答案,你的最右侧一定不是平的,应该是有凹凸的.我们设\)</span>f
_{ i , j } <span class="math inline">\(表示当前dp完了前\)</span>i <span class="math inline">\(列,在第\)</span>i + 1 <span class="math inline">\(列凸出来了\)</span>j
$个位置.转移的话考虑凹的位置填什么,如果填$2 $就往后再凸一格,如果填$1
$就没啥事.具体地:</p>
<p><span class="math display">\[
f _{ n , m  } \binom { h - m  } { k  } \rightarrow f _{ n + 1 , k  } , k
\in [ 0 , h - m ]
\]</span></p>
<p>这个dp的复杂度为$O ( wh ^2 ) <span class="math inline">\(.注意到这两个dp的复杂度不同,于是分治,不妨设\)</span>N
= wh $,</p>
<p>第一个dp的复杂度是$O ( { h ^2 } ) <span class="math inline">\(,第二个dp的复杂度是\)</span>O ( Nh ) <span class="math inline">\(,当\)</span>h N ^{ { 3 } } <span class="math inline">\(的时候使用第二个dp,不然使用第一个,复杂度\)</span>O
( N ^{ { 3 } } ) $.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1250D</p>
<p>最重要的观察在于,这题等价于保留最多的区间,使得若其中某两个区间有交,那么它们必定颜色相同,但是同时需要满足一些形如某个区间只能染某种颜色的限制条件.原因很简单,首先原题的意思自然是找到染色方式,使得满足与其有交的区间颜色必定和它相同.那么对于一个满足条件的区间,如果与它有交的区间不满足条件,我们把那个区间删了这个区间也不会不满足条件.于是合法的不会变成不合法,接下来需要说明不合法的不会变成合法.首先是原本已经确定了颜色的区间,这个限制好做.然后是如果一个区间没有确定颜色,那它不能被包括在多个确定了的区间.这等价于,我们对于与右端点相交的所有无色区间全部作为新的右端点来更新.这样后面选的时候就不会错误更新右端点了.</p>
<p>或者我们换一个更清晰的描述,我们现在想要得到一些极长的段,使得这些段两两不交,并且与这些段相交的区间都是一个颜色.那么被完全包含在这个段内的区间显然就是答案,我们要最大化这个.</p>
<p>然后上面形成若干限制条件,但是这个在下面的dp中是好处理的.不过有个细节是,如果有两个相邻的连续段(不一定紧邻)的颜色相同,那么我们上一个区间的后面拖着的无色区间是不必对此产生影响的.这怎么办呢?特判一下同色.</p>
<p>这样的dp就很好设计了,更具体地,设$f _{ r , k } <span class="math inline">\(表示目前\)</span>[ 1 , r ] <span class="math inline">\(,包含\)</span>r <span class="math inline">\(的那个区间颜色是\)</span>k
$,最多能保留多少个区间.自然有:</p>
<p><span class="math display">\[
[ l , r ] = k \Rightarrow f _{ r , k  } \leftarrow cnt _{ l , r , k  } +
\max _{ i = 0  } ^{ l - 1  } f _{ i , k &#39;  }
\]</span></p>
<p>设$g <em>{ i } = </em>{ k } f _{ i , k } $,我们有:</p>
<p><span class="math display">\[
[ l , r ] = k \Rightarrow f _{ r , k  } \leftarrow cnt _{ l , r , k  } +
\max _{ i = 0  } ^{ l - 1  } g _{ i  }
\]</span></p>
<p>对于$g _i <span class="math inline">\(做前缀\)</span><span class="math inline">\(,这样就只需要枚举\)</span>r , k <span class="math inline">\(.复杂度\)</span>O ( n ^2 c ) $.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1158F</p>
<p>考虑如何判断一个串的密度,不妨设它密度为$P
$,我们从左往右找到第一个位置,使得前缀的密度为$1 <span class="math inline">\(,那么显然这个位置的后缀的密度是\)</span>P - 1
<span class="math inline">\(,如果小了,那么这个第一个位置所代表的那个数字开头的子序列就不全.如果多了,那显然可以构造出密度至少为\)</span>P
+ 1 <span class="math inline">\(的子序列.由上面这个描述,我们发现一个密度为\)</span>P
<span class="math inline">\(的序列一定可以分成\)</span>P <span class="math inline">\(个子段,使得每个子段都出现了\)</span>[ 1 , c ]
<span class="math inline">\(中所有的数字.更进一步地,我们如果不是划分,那么\)</span>P
<span class="math inline">\(中一定存在\)</span>P <span class="math inline">\(个互不相交的子段,使得每个子段都出现了\)</span>[ 1
, c ] <span class="math inline">\(中所有的数字并且每个子段最后的那个元素只出现了一次.顺便我们还可以发现\)</span>p
{ c } $.</p>
<p>由上面,我们可以发现一个状压dp,也就是设$dp _{ i , j , S } <span class="math inline">\(表示当前走到\)</span>i <span class="math inline">\(,前面的密度为\)</span>j <span class="math inline">\(,然后如果在后面全出现了\)</span>S
$中的数字,那么密度会变大$1 <span class="math inline">\(.这样给出了一个\)</span> { c } 2 ^c $的做法.</p>
<p>质数感觉不太行啊,考虑考虑dp,上面的形式看上去就很好dp,设$dp <em>{ i ,
j } <span class="math inline">\(表示当前在\)</span>i <span class="math inline">\(然后密度是\)</span>j <span class="math inline">\(的方案数,再设\)</span>f </em>{ l , r } <span class="math inline">\(表示在\)</span>[ l , r ] <span class="math inline">\(中选出一个子序列,\)</span>r <span class="math inline">\(必选且\)</span>a <em>r <span class="math inline">\(只出现了一次的方案数.不妨设\)</span>T <em>i <span class="math inline">\(表示\)</span>i <span class="math inline">\(在这个区间出现的次数,不难发现\)</span>f </em>{ l ,
r } = </em>{ i a _r } ( 2 ^{ T _i } - 1 ) <span class="math inline">\(.这个只需要枚举\)</span>l <span class="math inline">\(扫\)</span>r <span class="math inline">\(就可以\)</span>O ( n ^2 ) $算.自然有转移:</p>
<p><span class="math display">\[
dp _{ i , j  } = \sum _{ k &lt; i  } dp _{ k , j - 1  } f _{ k + 1 ,
i  }
\]</span></p>
<p>不过吧这么转移有一个小问题,那就是我们的$dp _{ i , j } <span class="math inline">\(必须是最后一段以\)</span>i <span class="math inline">\(结尾.那么我们最后统计答案还要算上最后的那一段没有选出\)</span>[
1 , c ] $的答案.不过这个也好算.</p>
<p>但是还有一个方式,那就是从后往前dp,然后每次放这么一段,对dp取一个后缀和来转移.</p>
<p>总之,这个dp的复杂度是$O ( { c } ) <span class="math inline">\(的.取\)</span>c = n <span class="math inline">\(为两个复杂度的边界,这样总复杂度是\)</span>O ( n ^2
n ) $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1175G</p>
<p>显然设$f _{ i , j } <span class="math inline">\(为前\)</span>j <span class="math inline">\(个划分了\)</span>i $段,自然有:</p>
<p><span class="math display">\[
f _{ i , j  } = \min _{ k &lt; j  } \{ f _{ i - 1 , k  } + ( j - k )
\max _{ l = k + 1  } ^j a _l \}
\]</span></p>
<p>第一反应是决策单调性,可惜没有.</p>
<p>不过后面那个形式很简单,我们暴力一点维护这个东西.用单调栈维护出当前哪些后缀的最大值相等,不妨记这个最大值为$m
$.我们改成刷表更新:</p>
<p><span class="math display">\[
f _{ i - 1 , k  } + ( j - k ) \max _{ l = k + 1  } ^j a _l \rightarrow f
_{ i , j  }
\]</span></p>
<p>对于每层$i <span class="math inline">\(从左往右扫\)</span>k <span class="math inline">\(,然后维护单调栈,然后对于每个点,它对右边的贡献在\)</span><em>{
l = k + 1 } ^j a <em>l <span class="math inline">\(不变的情况下,就是一条稳定的一次函数.但是这样还有一个问题,就是我们如何快速求出一个区间的所有的直线.这个的话,我们考虑对于不同的\)</span></em>{
l = k + 1 } ^j a <em>l <span class="math inline">\(,求出最小的\)</span>f
</em>{ i - 1 , k } - k </em>{ l = k + 1 } ^j a _l <span class="math inline">\(,这相当于一个凸包,然后用斜率为\)</span>m
$的直线来切点.然后合并两个凸包可以启发式合并,用链表维护队列.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9312</p>
<p>首先观察到我们可以限制手上的灯笼能照亮的海拔是一段区间,因为我们可以先选择不断扩张,而不是提前买,等到了需要用的时候再买就行.</p>
<p>一个自然的想法是$f <em>{ s , l , r } <span class="math inline">\(表示以\)</span>s <span class="math inline">\(为起点,当前能走到的海拔高度是\)</span>[ l , r ]
<span class="math inline">\(.为什么需要记录\)</span>s <span class="math inline">\(呢?因为可能有不同的区间走出来的海拔高度都是\)</span>[
l , r ] <span class="math inline">\(.那我们设\)</span>f </em>{ l , r }
<span class="math inline">\(为当前海拔最低的那个灯编号是\)</span>l <span class="math inline">\(,最高的那个编号是\)</span>r <span class="math inline">\(.然后我们要知道的就是\)</span>f _{ s , s } <span class="math inline">\(.然后按照区间从大到小dp.这样有一个\)</span>O ( k
^3 ) $的做法.</p>
<p>考虑如何优化,不妨假设当前新买的灯笼是第$u
$个,那么我们分情况讨论一下:</p>
<ol type="1">
<li><p>$f <em>{ i , u } + c <em>u f </em>{ i , j } <span class="math inline">\(.这种情况需要保证\)</span>u <span class="math inline">\(能买的地方在\)</span>i , j <span class="math inline">\(的控制区域里,并且需要满足\)</span>u <span class="math inline">\(的区间和\)</span>i , j <span class="math inline">\(的区间是相交的.这种情况上也就是需要\)</span>u
<span class="math inline">\(的下界小于等于\)</span>j <span class="math inline">\(的上界.这个比较好处理,我们从大到小枚举\)</span>j
<span class="math inline">\(,等\)</span>f </em>{ i , u }
$不合法的时候把它删了就是了.</p></li>
<li><p>$f _{ u , u } + c <em>u f </em>{ i , j }
$.和上面是类似的.</p></li>
</ol>
<p>也就是说,我们现在唯一最需要搞定的就是怎么让$u <span class="math inline">\(能买的地方在\)</span>i , j
$的控制区域里,不难发现这是一个看上去比较典的线段树维护dp.</p>
<p>事实上有一种更简单的写法,不妨设$L , R <span class="math inline">\(为实际控制的海拔范围,\)</span>S , T
$为实际控制的山峰范围,我们先把转移仔细写一下:</p>
<ol type="1">
<li><p>$f _{ l , u } + c <em>u f </em>{ l , r } ( R _u &gt; R _r L _u u
) $.</p></li>
<li><p>$f _{ u , r } + c <em>u f </em>{ l , r } ( L _u &lt; L _l R _u u
) $.</p></li>
<li><p>$f _{ u , u } + c <em>u f </em>{ l , r } ( L _u &lt; L _l R _u R
_u &gt; R _r L _u u ) $.</p></li>
</ol>
<p>按照$L <span class="math inline">\(从小到大枚举,按照\)</span>R
$从大到小枚举,那上面的所有转移都是无后效性的.</p>
<p>注意到第三种转移没有意义,我们可以直接改写成:</p>
<ol type="1">
<li><p>${ f <em>{ l , u } , f </em>{ u , u } } + c <em>u f </em>{ l , r
} ( R _u &gt; R _r L _u u ) $.</p></li>
<li><p>${ f <em>{ u , r } , f </em>{ u , u } } + c <em>u f </em>{ l , r
} ( L _u &lt; L _l R _u u ) $.</p></li>
</ol>
<p>原因在于,我们其实只想要让$u <span class="math inline">\(与\)</span>l
, r
$所代表的区间相交,这个比较重要,其它的都不重要.就算转移是错误的,那样转移一定不优秀.</p>
<p>此刻对于(1)我们想知道的就是固定$l <span class="math inline">\(的情况下,按照\)</span>R <span class="math inline">\(从大到小枚举的贡献,以及对称情况,不难发现这个用堆也是能做的.也就是在\)</span>l
<span class="math inline">\(相同的前提下,如果\)</span>R _i &lt; R _j
&lt; R _k <span class="math inline">\(,如果\)</span>k <span class="math inline">\(不能贡献到\)</span>j <span class="math inline">\(,那么\)</span>k <span class="math inline">\(必然不能贡献到\)</span>i
$,这就保证了堆的正确性.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P8294</p>
<p>毛估估的话就是设$f _{ x , s , t } <span class="math inline">\(表示在断开\)</span>x <span class="math inline">\(到父亲这条边时,\)</span>x <span class="math inline">\(的值来自子树内的点\)</span>s <span class="math inline">\(,然后从父亲换下来的值将要去子树内的\)</span>t
<span class="math inline">\(.不难发现\)</span>( x , s , t ) <span class="math inline">\(合法当且仅当\)</span>x = lca ( s , t ) <span class="math inline">\(,这样状态数就是\)</span>O ( n ^2 ) $的.</p>
<p>来细细写一写转移:</p>
<p>首先,如果$cnt <em>{ son } = 0 <span class="math inline">\(,显然\)</span>f </em>{ x , x , x } = d _x $.</p>
<p>如果$cnt _{ son } = 1 <span class="math inline">\(,不妨设其儿子是\)</span>u <span class="math inline">\(,不难发现此时必有\)</span>s _x = x t _x = x
$,讨论一下:</p>
<p>若$s _x = x $,那么之间换出去就行,然后因为要一路换下去:</p>
<p><span class="math display">\[
f _{ x , x , t _x  } \leftarrow f _{ u , s _u , t _x  } + d _x
\]</span></p>
<p>反之,那么要先把$s _x <span class="math inline">\(换到\)</span>x
$这里,然后再换出去,此时有:</p>
<p><span class="math display">\[
f _{ x , s _x , x  } \leftarrow f _{ u , s _x , t _u  } + d _x + d _{ s
_x  } ( dep _{ s _x  } - dep _{ x  } )
\]</span></p>
<p>注意到上述复杂度均为$O ( n ^2 ) <span class="math inline">\(.因为枚举一下\)</span>( s _u , t _x ) <span class="math inline">\(或\)</span>( s _x , t _u ) <span class="math inline">\(就可以确定\)</span>u <span class="math inline">\(,而\)</span>x <span class="math inline">\(是\)</span>u $的父亲,自然也可以确定.</p>
<p>这个式子已经给了我们启发了,剩下的类似.有时间再补这个题吧,太精神污染了.</p>
<h3><span id="数据结构">数据结构</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1648D</p>
<p>不妨设$f _i <span class="math inline">\(表示从\)</span>( 1 , 1 )
<span class="math inline">\(走到\)</span>( 2 , i ) <span class="math inline">\(的最大收益,显然求出这个后再拼一下第三行的后缀和就是答案.我们枚举覆盖\)</span>(
2 , i ) <span class="math inline">\(的区间是\)</span>k <span class="math inline">\(,此时必然需要满足\)</span>l _k i r _k $.</p>
<p>不妨设$sum <span class="math inline">\(表示每一行的前缀和,\)</span>sufsum
$表示第三行的后缀和,注意到转移:</p>
<p><span class="math display">\[
\begin{gathered}
- c _k + \max _{ l _k - 1 \leq j &lt; i \leq r _k  } \{ f _j \}
\rightarrow f _i \\
- c _k + \max _{ l _k \leq j \leq i \leq r _k  } \{ sum _{ 1 , j  } -
sum _{ 2 , j - 1  } \} \rightarrow f _i
\end{gathered}
\]</span></p>
<p>这个东西即使我们枚举$k , i <span class="math inline">\(,然后数据结构优化\)</span>j <span class="math inline">\(来转移它也是艰难的.那咋办呢?我们考虑我们枚举\)</span>k
<span class="math inline">\(的原因是,我们需要保证\)</span>i r _k <span class="math inline">\(.如果我们钦点\)</span>i = r _k <span class="math inline">\(,那我们上面的枚举就只有一维了.也就是需要保证\)</span>i
<span class="math inline">\(右边的点一定走不到,这样我们上面的转移仍然是正确的.至于计算答案,一个反应是把这个\)</span>f
<span class="math inline">\(做一下后缀\)</span><span class="math inline">\(.但其实不对!因为你往后多走点可能多吃到了一点\)</span>a
$.</p>
<p>那么怎么处理这个东西呢?考虑如果当前选的这个区间不是最后一个区间,那我从后面的$r
<span class="math inline">\(走到前面的一个\)</span>i <span class="math inline">\(再拐到第三行去,显然只会有第二行的一段和的差别,我们把这个差别统计进去就行.但是如果只开了一个区间,也就是从第一行拐下来没到结尾直接拐下第三行了,那么第一行的贡献也要减去.我们可以把\)</span>f
<em>{ i } <span class="math inline">\(改成\)</span>f </em>{ i , 0 / 1 }
$来解决这种问题.</p>
<p>于是吧,我们就有了下面这个转移:</p>
<p><span class="math display">\[
\begin{gathered}
- c _k + \max _{ l _k - 1 \leq j &lt; r _k  } \{ f _{ j , 0  } , f _{ j
, 1  } \} \rightarrow f _{ r _k , 1  } \\
- c _k + \max _{ l _k \leq j \leq r _k  } \{ sum _{ 1 , j  } - sum _{ 2
, j - 1  } \} \rightarrow f _{ r _k , 0  }
\end{gathered}
\]</span></p>
<p>然后怎么贡献答案呢?首先你不能往左走太多,至少不能超过最后选的那个区间.事实上我们发现最后一定只有一个区间的右端点超过了拐点.因为选择的所有区间一定没有包含关系,而右端点可以对拐点取$<span class="math inline">\(.因此我们枚举当前最靠右的那个区间\)</span>k <span class="math inline">\(,以及最后拐到第三行的点\)</span>i $,自然有:</p>
<p><span class="math display">\[
\begin{gathered}
- c _k + \max _{ l _k - 1 \leq j &lt; r _k  } \{ f _{ j , 0  } , f _{ j
, 1  } \} + \max _{ j &lt; i \leq r _k  } \{ sum _{ 2 , i  } + sufsum _{
i  } \} \rightarrow ans \\
- c _k + \max _{ l _k \leq j \leq i \leq r _k  } \{ sum _{ 1 , j  } -
sum _{ 2 , j - 1  } + sum _{ 2 , i  } + sufsum _i \} \rightarrow ans
\end{gathered}
\]</span></p>
<p>要统计所有$j &lt; i <span class="math inline">\(或者\)</span>j i
$的点对的答案在线段树上都是好做的.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P9371</p>
<p>考虑如何判断$x <span class="math inline">\(是否是这个区间的中位数:我们把大于\)</span>x
$的记作$1 <span class="math inline">\(,小于\)</span>x <span class="math inline">\(的记作\)</span>- 1 <span class="math inline">\(,\)</span>x $记作$0 <span class="math inline">\(,如果区间和的绝对值小于等于\)</span>x <span class="math inline">\(的出现次数,那么\)</span>x $满足条件.</p>
<p>我们先扫值域,这样修改每个点的取值的总复杂度均摊.对于每一个权值$v
<span class="math inline">\(,枚举权值是\)</span>v <span class="math inline">\(的一个点作为这个区间中最靠左的\)</span>v <span class="math inline">\(,然后考虑找到最大的右端点使得合法,而由于确定了最靠左的\)</span>v
<span class="math inline">\(,我们其实是不在乎这个区间左端点是啥的,只要包含这个点就行,不妨设这个点为\)</span>l
$.</p>
<p>接下来在每个点记录以这个点的为结尾的所有后缀和(要求左端点小于等于$l
<span class="math inline">\()的集合.不难发现,这个集合一定是一段区间,因为每个值只有可能是\)</span>
$或$0 <span class="math inline">\(.于是我们要维护的就是这些点的最大后缀和以及最小后缀和,然后判断这个值与\)</span>x
<span class="math inline">\(的大小关系.用线段树维护这两个东西的\)</span><span class="math inline">\(和\)</span>$,能往右跳就往右跳.</p>
<p>有个细节是我们需要保证这些后缀和的左端点小于等于$l <span class="math inline">\(,这其实等价于直接求\)</span>l <span class="math inline">\(这里的最小后缀和以及最大后缀和,然后在每个点上只需要存这个点与\)</span>l
<span class="math inline">\(这段区间和即可,这个在\)</span>l
$的移动过程中是好维护的.</p>
<p>至于最大后缀和的合并是简单的.</p>
<p>写起来发现上面那个东西其实不太好搞啊,我们考虑改改描述,上面等价于将每个区间改成最小后缀和$-
x <span class="math inline">\(出现次数,以及最大后缀和\)</span>+ x
$出现次数,然后只需要判断这个区间是否包含$0 $.好像还是不太好做???</p>
<p>冷静一下,注意到相邻两个位置的最大后缀和相差不超过$1
$,这意味着我们可以维护一段区间的所有区间的并,这必定还是一个区间.然后判断这个并是否包含$0
$,这个就方便线段树上二分了.至于我们的修改操作,无非是以下几种操作:</p>
<ol type="1">
<li><p>对于每个$l
$以及它的一对后缀和,在线段树上找到最靠右的一个叶子使得这个区间在加上这对后缀和更改后包含$0
$.</p></li>
<li><p>在更改当前处理的值$v $的时候,将所有点的值恢复为前缀和.</p></li>
<li><p>在更改当前处理的值$v <span class="math inline">\(的时候,将某些点的值置为\)</span>- 1
$,将某些点的值置为$0 $.</p></li>
</ol>
<p>显然都好做.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P7220</p>
<p>ps:本题选入笔记:常见套路-二进制分组-Example1</p>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点$(
x , y ) <span class="math inline">\(,随着\)</span>x <span class="math inline">\(的增大\)</span>y
$不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.考虑求出所有能影响到一个询问的区间,把它们扔到线段树上,然后就可以用线段树分治维护这个东西.具体来说,我们在线段树上dfs,每次遇到一个区间,把该搞得全部搞完,然后这个点的位置就留在这里了,在后面dfs到其它的区间后再改.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9168</p>
<p>场上写了$48 pts <span class="math inline">\(,简单来说就是对于每个\)</span>m
$,从下往上合并,然后当某一个时刻某棵子树内人数大于子树大小,就把最菜的那几个给删了.根据Hall定理,这样做显然是正确的.</p>
<p>接下来看怎么优化,首先第一反应肯定是线段树分治,这样我们只需要做加入和撤销,就不需要做删除了.撤销总是好做的.</p>
<p>那么只有加入怎么做呢?这个点能造成的影响无非是以下几种:</p>
<ol type="1">
<li><p>它被加入,没有别的点被删除.</p></li>
<li><p>它被加入,另一个点被删除.</p></li>
<li><p>它没有被加入.</p></li>
</ol>
<p>注意到(1)发生当且仅当这个点到根的路径上没有节点是满节点,这个判一下就行.</p>
<p>然后考虑(2),(3),淘汰必然会发生,并且必定是在离插入点最近的那个满的祖先.</p>
<p>这样的话我们需要实现的就是两件事:</p>
<ol type="1">
<li><p>对于一个点,找到离他最近的满的祖先.</p></li>
<li><p>查询子树内部点的最小值.</p></li>
<li><p>支持在点上插入和删除.</p></li>
</ol>
<p>这三个操作显然都可以用树剖维护.算上线段树分治,这样就是$O ( n ^3 n )
$.</p>
<p>不过吧,我们需要说明一件事情:那就是为啥选择子树内最小的那个点一定是优秀的.我们可以简单举个例子来反对这个直觉:如果有两个点权值相同,一个点是另一个点的祖先,那显然选择祖先会优秀一点,因为这个祖先对下面子树的限制要小一些.</p>
<p>我们可以这么干:我们在一开始那个暴力中这么规定:每次满员了之后,删掉权值最小的,权值相同的则按照编号删.对于一个子树$x
$,假设它所有儿子的子树都合法了,并且它需要删,此时:</p>
<ol type="1">
<li><p>如果我们之前想删的那个点已经死了,那就完事了.</p></li>
<li><p>如果我们之前想删的那个点没死,注意到我们接下来插入的点一定排序比当时想删它的时候只大不小,那此时必然还要删掉它.</p></li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF464E</p>
<p>之前做过,就是最短路.但是我们要实现高精度加法和高精度比较大小,注意到加上一个$2
^x $在二进制上的体现是某段$1 $变成$0 $,某一个$0 $变成$1
$,这个可以用主席树实现.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1801E</p>
<p>简单题,考虑暴力显然是直接大力并查集,而并查集的操作其实是不多的:一次有用的并查集操作必定是会让连通块个数减少$1
<span class="math inline">\(,因此操作均摊.于是考虑二分+哈希找到第一个有用的并查集操作.这就必然要求我们快速求出一条路径的哈希值.考虑哈希是可以差分的,因此处理每个点到根的哈希值(注意要维护两个方向)即可.每改变一个点就把子树内全部更改一下,这样就做完了.使用启发式合并可以做到\)</span>O
( n ^2 n ) $.</p>
<p>不过发现这个过程只有区间加法和单点查询,可以使用树状数组.</p>
<p>然后就卡了一晚上常数.事实上这题存在二进制分组做法:我们发现我们要做的无非是将两段直上直下的序列,然后定义它们对应数字相等.我们可以将一个点到它的$2
^k $级祖先所形成的这么一段拆成一段,这样就可以直接倍增然后处理.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF702F</p>
<p>典典典.考虑维护人的平衡树,然后每次check一个衬衫.注意到它会把大于等于它的人给减去这个值.我们考虑将这个splay分裂开来,然后对大于等于它的那些点打个减法tag,再与小于它的那个分裂出去的树合并起来.但是splay无法支持快速合并两棵无大小关系的树(ye不能启发式合并,因为以后还要裂开),我们考虑当前衬衫的价格是$v
<span class="math inline">\(,将所有人分成\)</span>[ 0 , v ) , [ v , 2 v
) , [ 2 v , + ) <span class="math inline">\(,三个部分,第一个部分不用管,第二个部分减去\)</span>v
<span class="math inline">\(后变成第一个部分,我们把它们暴力插入第一个部分.第三个部分直接打tag并合并,由于第二个部分的暴力插入会使得权值减半,因此总复杂度\)</span>O
( n ^2 n ) $.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P6072</p>
<p>考虑对于每一条边,求出以这条边为界限,两边的最大值然后加起来,显然就是答案.</p>
<p>还有一点是,一条路径$x - y <span class="math inline">\(的权值可以表示为\)</span>dep _x dep _y
$,这就启发我们用01trie维护最大异或值.</p>
<p>现在相当于求出$f _x <span class="math inline">\(表示\)</span>x <span class="math inline">\(的子树内的答案,再求出\)</span>g _x <span class="math inline">\(表示\)</span>x <span class="math inline">\(的子树外的答案.这个怎么求呢?首先\)</span>f _x
$可以启发式合并01trie.</p>
<p>对于$g _x <span class="math inline">\(,也很好做.你考虑求出全局最大的那条路径,显然只要分割点不在这条路径上,就会选取它.反之的话,就是两条路径往下dfs,这个直接暴力做01trie就是\)</span>O
( n w ) $.</p>
<p>做到这里我们冷静一下看看$f <span class="math inline">\(,注意到只有临近上面我们说的那条链的\)</span>f
<span class="math inline">\(,或者是就在这条链上的\)</span>f <span class="math inline">\(.我们只需要求出这些\)</span>f <span class="math inline">\(,因为再往下也没啥用,这样就能让总复杂度变成\)</span>O
( n w ) $.</p>
<h3><span id="图论">图论</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4768</p>
<p>典中典,求kruskal重构树,以及$1 $到所有点的最短路即可.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1408G</p>
<p>首先你需要发现,一个点集内部的边全部小于它与外界相连的边,那么如果我们从小到大加边,那么必然有一个时刻是这个点集成为了一个和外界分离的团.因此,考虑从小到大加边,并考虑kruskal重构树的结构,我们就可以将这个过程展现在树上.并且这个过程等价于区间合并.因此我们的问题转化为了有若干区间,选取若干不交的区间覆盖全集的方案数,简单的.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P9167</p>
<p>我们设题面中的$t <span class="math inline">\(座城市是关键城市,根据题面,断掉这\)</span>t <span class="math inline">\(座城市之间的边,会使得图分裂成若干个大小相差至多为\)</span>k
<span class="math inline">\(的连通块.我们不妨认为在一个连通块中,关键城市控制着里面的所有点,那么被不同城市控制的点一定没有边相连.如果此时图是树的话我们已经做完了,无非是要在树上划分点集.反之,我们考虑dfs树,维护出点双意义下的\)</span>dfn
, low $.注意到一个连通块必定在dfs树上也是连通块.</p>
<p>那么一个点能作为关键点,当且仅当它在dfs树上的某些子树所组成的城市都被控制,这个可以通过$low
<span class="math inline">\(来判断.枚举连通块大小,并设\)</span>dp _{ i ,
j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(子树上部还有\)</span>j <span class="math inline">\(个城市没决定被控制,这样就可以dp.注意到第二维有用的信息不多,这样就可以优化到\)</span>O
( n ) $.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9170</p>
<p>先看Bob,先把$| T | = 1 <span class="math inline">\(的选了,然后删掉.不断做这个过程直到所有的\)</span>|
T | = 2 <span class="math inline">\(,此时将这两个点之间连一条边,那就会形成一张图.对于每个连通块,若\)</span>|
E | &gt; | V | $,则必然无解.其它的情况必然有解,这就解决了第一个问题.</p>
<p>不过其实没必要删$| T | = 1 $,直接连自环就行.</p>
<p>对于Alice,考虑以下几种情况:</p>
<ol type="1">
<li><p>$| S T | = 0 $,显然Alice选啥都没用.</p></li>
<li><p>$| S T | = 1 $,此时Alice必然选那个和Bob有交的.</p></li>
<li><p>$| S T | = 2 $,此时Alice可以选择其中一个.</p></li>
</ol>
<p>这样的话,Alice就已经确定了一些东西,而不确定另一些东西.Alice必然是要让Bob能选的最小情况最大,我们考虑再讨论一下:</p>
<ol type="1">
<li><p>$| E | = | V | <span class="math inline">\(,此时连通块是一个基环树.那么除了环以外的点一定都选好了.如果是自环那么怎么选都行.反之,环上有两种选择方式(就是一个点会在哪条边上被选).考虑对于两种方式,Alice已经确定必选的数量分别是\)</span>c
_1 , c _2 <span class="math inline">\(,而Alice现在还可以选的个数是\)</span>c <span class="math inline">\(,我们也就是要选取\)</span>i <span class="math inline">\(,最大化\)</span>{ c _1 + i , c _2 + c - i } <span class="math inline">\(,显然取\)</span>c _1 + i = c _2 + c - i , i = { 2
} <span class="math inline">\(,注意如果\)</span>i $要对$0 <span class="math inline">\(取\)</span><span class="math inline">\(,对\)</span>c <span class="math inline">\(取\)</span>$.</p></li>
<li><p>$| E | = | V | - 1 <span class="math inline">\(,此时连通块是一棵树,并且有一个点不会被选择.不妨设\)</span>f
_i <span class="math inline">\(表示\)</span>i <span class="math inline">\(这个点不会被选的方案数,那Alice对于一条边的定向,会让这条边其中一侧的子树的\)</span>f
<span class="math inline">\(整体\)</span>+ 1 <span class="math inline">\(.这个看上去极其熟悉.典中典套路是,考虑两条边选择使得\)</span>V
_1 , V _2 $分别加了$1 <span class="math inline">\(,如果\)</span>V _1 V
_2 = $,同时取反这两条边的选择,一定不劣.于是选择的边会让加$1 <span class="math inline">\(的点集两两有交.枚举交集中的一个点\)</span>x <span class="math inline">\(,则所有边的选择全部确定:每条边都选择深度较低的那个点.仔细考虑此时,Bob的最优选择是啥.如果Bob选择了一个点\)</span>y
<span class="math inline">\(,那么\)</span>f _y <span class="math inline">\(显然是\)</span>f _x <span class="math inline">\(减去\)</span>x <span class="math inline">\(到\)</span>y <span class="math inline">\(的路径上Alice能选的数量加上Alice只有一种选择,并且在这里为反向选择的数量.我们要最大化这个东西,也就是最小化\)</span>x
<span class="math inline">\(到\)</span>y
$的路径上Alice能选的数量,其实也就是最小化一棵树的深度,这个是方便dp的.</p></li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF235D</p>
<p>这个形式看上去极其复杂,考虑简单化一下:我们考虑对当前图选一个分治中心,对答案的贡献是$|
G |
$,不难发现,这相当于每个点贡献了一次.进一步地,这等价于对于每个点,判断它会在多少个点作为分治重心的时候,仍然在那个点所在的连通块中.</p>
<p>如果原图是树,这等价于对于$u , v <span class="math inline">\(,\)</span>u <span class="math inline">\(是\)</span>( u , v ) <span class="math inline">\(路径上第一个被删除的点的概率,这等价于\)</span> {
len } $.这样树的情况就做完了.</p>
<p>考虑基环树怎么做:如果两个点$( u , v ) <span class="math inline">\(之间路径唯一,那上面做的显然还是对的.反之,我们有公式\)</span>P
( A B ) = P ( A ) + P ( B ) - P ( A B ) <span class="math inline">\(,因此你把这两条路径求出来,加起来,减去它们同时发生的概率即可.注意同时发生的概率不是\)</span>P
( A ) P ( B )
$,因为这两件事不独立,事实上应该是这两条路径的点集并的大小分之一.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4429</p>
<p>如果图不连通可以对于每个块分开考虑,下面只考虑图连通的情况:</p>
<p>显然,如果图不是二分图一定无解.</p>
<p>其次,我们注意到孤立点和一度点一定都可以删去,前者显然,后者是因为与它相邻的那个点的颜色如果确定,那它一定有一种和它选不一样的方法.这样当前所有点的度数$
$.</p>
<p>接下来,青鱼说得好,我们把很多比较能看出来有解的情况判掉,剩下的就是无解.</p>
<ol type="1">
<li>偶环一定有解.</li>
</ol>
<p>如果偶环上的颜色全都一样,那直接二分图染色.不然,一定存在相邻的两个点$x
, y <span class="math inline">\(使得\)</span>x <span class="math inline">\(有一种颜色,\)</span>y <span class="math inline">\(没有,直接让\)</span>x <span class="math inline">\(染这种颜色,\)</span>x - y <span class="math inline">\(这条边就没用了,断掉,然后顺着\)</span>x
$平推过去,一定有解.</p>
<p>妈的,剩下的不会了,先咕着.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1672G</p>
<p>发现个事情:如果当前所有行和所有列的异或值都是$0 <span class="math inline">\(,那么我们可以每次选取四个点然后点击,这样这四个点会改变,而其它点都不改变,从左上开始一直点相邻的四个点,这样最后左上角的\)</span>(
n - 1 ) ( m - 1 ) $的矩阵就全空,而由于每行每列$1
$的个数都是偶数,这个过程不改变这个性质,因此最后一定全图是空的.</p>
<p>而由于最后的状态是全空,因此在变化过程中总有一个时刻使得每行每列异或值为$0
$.</p>
<p>考虑异或的过程,如果$n
$是偶数,那么这么一次异或会使得除了一列以外的所有列都异或上$1 <span class="math inline">\(.如果\)</span>n $是奇数,则会使得全局异或上$1
$.</p>
<p>现在我们来讨论一下$n , m $的奇偶性(对称情况可以反转,不讨论):</p>
<ol type="1">
<li><p>$n , m
$均为偶数.只考虑第一行,从第二列开始,如果当前这一列和第一列不一样就把它操作掉.这样最后所有列的异或值都相同.如果最后是全$1
<span class="math inline">\(,我们把第一行轮着点一遍,这样每一列都被点了\)</span>m
- 1
$次,而行的奇偶性不变.也就是说,此时无论怎么填都是有解的.行再一样做</p></li>
<li><p>$n <span class="math inline">\(是奇数,\)</span>m
$是偶数.此时必须要求所有列的异或值相同.每一行如何做可以(1)一样使得每一行异或值都是$0
$.枚举所有列是$0 $还是是$1 $,留一个?来调整,剩下的?随便选.</p></li>
<li><p>都是奇数,此时要求所有行和所有列的奇偶性分别相同.枚举这四种奇偶性情况,然后将$?
$看成连在横坐标和纵坐标之间的边.那也就相当于确定了每个点的度数,然后问有多少种选边方式.典中典.对于每个连通块,求出一棵生成树,然后剩下的边随便选,用生成树一路调整上去.注意这要求所有点的度数之和是偶数,也就是至少得是一张合法的图.</p></li>
</ol>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc117_f</p>
<p>考虑求出前缀和,此时要满足条件,不妨设全局和为$x $,此时必然有:</p>
<p><span class="math display">\[
\begin{aligned}
\forall 0 &amp; \leq i &amp; &lt; n , s _{ i + n  } - s _i &amp; \geq a
_i \\
\forall n &amp; \leq i &amp; &lt; 2 n , x - ( s _{ i  } - s _{ i - n  }
) &amp; \geq a _i , s _i - s _{ i - n  } &amp; \leq x - a _i \\
\forall 0 &amp; \leq i &amp; &lt; 2 n , s _i &amp; \leq s _{ i + 1  }
\end{aligned}
\]</span></p>
<p>注意上面的限制条件限制住了$s <em>{ i + n } - s </em>{ i } <span class="math inline">\(的上下界,我们不妨设它的上下界分别为\)</span>l
<span class="math inline">\(和\)</span>r <span class="math inline">\(.但是这俩需要知道\)</span>x <span class="math inline">\(才能求出来,于是不妨二分\)</span>x $.</p>
<p>贪心地构造,考虑每次要求$s <em>{ i + n } <span class="math inline">\(尽可能地小,于是如果\)</span>l <em>i s </em>{ i - 1
+ n } - s </em>{ i - 1 } r <em>i <span class="math inline">\(,我们就继承前面的答案.反之,如果\)</span>l <em>i
&gt; s </em>{ i - 1 + n } - s </em>{ i - 1 } <span class="math inline">\(,我们就提升\)</span>s <em>{ i + n } = s </em>{ i -
1 } + l <em>i <span class="math inline">\(,\)</span>r <span class="math inline">\(同理.这样走到最后一定是最小的,只需要满足\)</span>s
</em>{ n - 1 } s <em>n s </em>{ 2 n - 1 } x $即可.</p>
<p>但是你发现个事情,我们前面一直在保证$s <span class="math inline">\(尽可能小,却没有保证\)</span>s _{ n - 1 } s _n
<span class="math inline">\(.我们怎么处理这里的\)</span>s _n <span class="math inline">\(呢?考虑再次二分,每次找到最小的\)</span>s _n
$满足前一个条件.那我们就需要说明两件事情:</p>
<ol type="1">
<li><p>满足前一个条件的$s _n $满足单调性.</p></li>
<li><p>$s _n $越小,越有可能满足第二个条件.</p></li>
</ol>
<p>先来说(2),这个比较显然.因为如果$s _n <span class="math inline">\(在前面较小不满足的话,我们可以在后面某个地方给提升得大一点,显然由于\)</span>s
_n $的提升比较自由,这个是可以做到的.</p>
<p>再来看(1),如果一个$s _n <span class="math inline">\(满足条件,我们把这个\)</span>s <em>n $增大$1 <span class="math inline">\(.考虑将前面的所有\)</span>s </em>{ 0 n - 1 }
$全部提升$1 $,这样所有的差都不变,因此仍然满足条件.</p>
<p>冷静总结一下这个题,其实就是我们首先要发现很多可二分的性质:</p>
<ol type="1">
<li>$s _{ 2 n } $可二分.</li>
</ol>
<p>这个是显然的,放更多显然不会更劣.但是我们要在这个基础上找到一种方法,使得如果当前二分的值合法,一定能构造出一组答案.我们发现如果没有$s
<em>{ n } s </em>{ n - 1 } <span class="math inline">\(这个限制,一切都是好做的:因为我们可以贪心地使得当前的\)</span>s
$最小.</p>
<ol start="2" type="1">
<li>$s _n $可二分.</li>
</ol>
<p>这个是怎么发现的呢?因为我们发现我们勒令$s _n <span class="math inline">\(是啥,似乎对这个贪心过程没有啥影响.如果\)</span>s
<em>n <span class="math inline">\(过小,上面的贪心过程就会在\)</span>s
<em>n s </em>{ n - 1 } <span class="math inline">\(这里判出错.如果\)</span>s <em>n <span class="math inline">\(过大,则会在\)</span>s </em>{ 2 n - 1 } s </em>{ 2
n } <span class="math inline">\(上判错.这意味着\)</span>s _n
$可能需要是一个区间才合法.接下来就是去证明它确实是一个区间是合法的,并且证明我们的贪心过程能在这个贪心过程中正确地check.</p>
<h3><span id="线性代数">线性代数</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1224</p>
<p>首先显然的一点是,我们把它搞成一个矩阵$A <span class="math inline">\(,然后拿\)</span>A A ^T
$.注意到如果最后的答案矩阵存在$0 <span class="math inline">\(就有解,这个解就是\)</span>B _{ i , j } = 0 <span class="math inline">\(的那对\)</span>( i , j )
$.到这里已经可以猜到,这题不是什么正经题,应该要搞一些随机化东西.</p>
<p>想起来之前那个经典判断$A B = C
$的题,就是随机几个向量然后乘起来.这个我们想想能不能类似做.</p>
<p>先考虑$k = 2 <span class="math inline">\(,如果\)</span>A A ^T $是全$1
<span class="math inline">\(矩阵,那么我们随机一个向量去乘它,得到的向量每一位必然都是这个向量所有数字之和.不难发现如果这个向量每一位差别足够大就可以check,这就提供了一个\)</span>O
( nd ) <span class="math inline">\(的做法,不过我们实现肯定造不出差别足够大的向量,因此可以多check几次.然后如果第\)</span>i
<span class="math inline">\(行不满足条件,一定存在一组\)</span>( i , j )
<span class="math inline">\(作为答案,枚举\)</span>j $即可.</p>
<p>再考虑$k = 3 $,这个有点难搞.实际上是一个牛逼发现:$1 ^2 ^2 <span class="math inline">\(.因此我们考虑将\)</span>B <span class="math inline">\(矩阵的每一位平方后与一个向量相乘.考虑\)</span><em>{
j } B </em>{ i , j } ^2 r <em>j = </em>{ j } B <em>{ i , j } r <em>j B
^T </em>{ j , i } <span class="math inline">\(,考虑构造矩阵\)</span>R
<span class="math inline">\(,使得\)</span>R </em>{ i , i } = r <em>i , R
</em>{ i , j } = 0 , i j <span class="math inline">\(,不难发现\)</span>(
BR ) <em>{ i , j } = B </em>{ i , j } R <em>{ j , j } <span class="math inline">\(,于是\)</span>( BRB ^T ) </em>{ i , i } = <em>{ j
} B </em>{ i , j } R <em>{ j , j } B ^T </em>{ j , i }
$.接下来我们只要check $BRB ^T <span class="math inline">\(的对角线即可.然后\)</span>B ^T = ( AA ^T ) ^T = {
A ^T } ^T A ^T = AA ^T $.于是有:</p>
<p><span class="math display">\[
BRB ^T = AA ^T RAA ^T
\]</span></p>
<p>考虑$A <span class="math inline">\(是一个\)</span>n d <span class="math inline">\(的矩阵,\)</span>A ^T <span class="math inline">\(是一个\)</span>d n <span class="math inline">\(的矩阵.不妨假设我们已经算出了\)</span>A ^T RA
<span class="math inline">\(,那这里是好算的,因为\)</span>( ABC ) <em>{ i
, i } = </em>{ j , k } A <em>{ i , k } B </em>{ k , j } C _{ j , i }
<span class="math inline">\(,这里可以\)</span>O ( nd ^2 )
$地check每一个位置.</p>
<p>那我们现在面临的问题就是如何去求出来$A ^T RA <span class="math inline">\(.注意到\)</span>RA <span class="math inline">\(是一个\)</span>n d <span class="math inline">\(的矩阵,因此如果知道\)</span>RA <span class="math inline">\(,\)</span>A ^T ( RA ) <span class="math inline">\(是好求的.我们现在需要求出\)</span>RA <span class="math inline">\(.由于\)</span>R <span class="math inline">\(是对角线矩阵,\)</span>( RA ) <em>{ i , j } = R
</em>{ i , i } A _{ i , j } <span class="math inline">\(,这样就可以\)</span>O ( nd ) $求.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P6772</p>
<p>典中典,首先如果是边权的话有个经典dp:设$dp _{ i , x } <span class="math inline">\(表示当前经过了\)</span>i <span class="math inline">\(条边,目前在\)</span>x
$点的最优答案,自然有转移:</p>
<p><span class="math display">\[
dp _{ i , x  } = \max \{ dp _{ i - 1 , y  } + val _{ y \rightarrow x  }
\}
\]</span></p>
<p>这是一个经典的${ , + } $矩阵,可以矩阵加速.</p>
<p>这个题不是边权,但是点权可以改成入边的边权,只不过起点需要特判.</p>
<p>还有一个问题是边权不是$1
$,拆边的话复杂度太高,考虑拆点,每个点拆成五个,然后只有最后一个点才会连出边,剩下的按照距离出边的距离连到前面的点.</p>
<p>至于美食节,一个想法是直接矩阵加速到那一天,然后把对应的点加上美食节的权值,继续做完每个美食节即可.但这样复杂度是$O
( kN ^3 T ) $的.</p>
<p>冷静一下,预处理出矩阵的二的次幂,这样就是$O ( kN ^2 T + N ^3 T )
$.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6125</p>
<p>简单题,建ACAM,然后对于每个人求答案.枚举每个人,对于每个点,设$p _i
$为以它为起点,最后这个人胜利的概率,做高斯消元即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3706</p>
<p>ps:本题选入笔记:概率与期望-概率生成函数-Example3.</p>
<p>把上面的东西给形式化一下,不妨设$g <em>i <span class="math inline">\(表示进行了\)</span>i <span class="math inline">\(步还未结束的概率,\)</span>f </em>{ k , i } <span class="math inline">\(为进行了\)</span>i <span class="math inline">\(步恰好第\)</span>k <span class="math inline">\(个人胜利的概率,\)</span>F , G
$是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p>$1 + xG ( x ) = _k F _k ( x ) + G ( x ) $.</p></li>
<li><p>$( { 2 } x ) ^L G ( x ) = _{ j = 1 } ^n F <em>j ( x ) </em>{ i =
0 } ^{ L - 1 } ( { 2 } x ) ^i [ A _k ^{ ( L - i ) } = { A <em>j } </em>{
( L - i ) } ] $.</p></li>
</ol>
<p>第一个式子的用处在于带入$x = 1 <span class="math inline">\(,发现\)</span>_{ k } F _k ( 1 ) = 1 $.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 0  } ^{
L - 1  } ( \frac { 1  } { 2  } x ) ^{ i - L  } [ A _k ^{ ( L - i )  }
&amp; = { A _j  } _{ ( L - i )  } ] \\
x ^L G ( x ) &amp; = \sum _{ j = 1  } ^n F _j ( x ) \sum _{ i = 1  } ^{
L  } ( \frac { 1  } { 2  } x ) ^{ - i  } [ A _k ^{ ( i )  } &amp; = { A
_j  } _{ ( i )  } ]
\end{aligned}
\]</span></p>
<p>带入$x = 1 $,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum _{ j = 1  } ^n F _j ( 1 ) \sum _{ i = 1  } ^{ L  } 2 ^i [
A _k ^{ ( i )  } = { A _j  } _{ ( i )  } ]
\]</span></p>
<p>不难发现对于不同的$k <span class="math inline">\(,(2)的右边不同,而左边一定相同,这样就给出了\)</span>n
<span class="math inline">\(个等式,算上(1)一共有\)</span>n + 1 <span class="math inline">\(个等式,可以算出\)</span>G ( 1 ) , F _{ 1 n } ( 1 )
<span class="math inline">\(这\)</span>n + 1 $个未知数.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3292</p>
<p>首先第一反应是树剖+线段树上合并线性基,轻松做到$O ( q ^2 n ^2 v )
$.</p>
<p>但是过不太去!注意到$n <span class="math inline">\(要小一点,考虑离线点分治.记录下从分治中心到每个点的线性基,这样只需要做\)</span>q
<span class="math inline">\(次线性基合并,复杂度是\)</span>O ( q ^2 v + n
n v ) $.</p>
<p>不过如果你做过CF1100F,那这题就是上个树.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4151</p>
<p>典中典,注意到一个值异或两遍就会没掉.我们考虑随便求一条$S T
$的路径,然后再求出来所有的环上的异或值.我们发现我们可以走到一个简单环上,走一圈再原路返回,这样答案只会异或上简单环的异或值.对这个东西用线性基就行.</p>
<p>至于这个东西的正确性,首先考虑$S T <span class="math inline">\(唯一的情况,这样的话你如果要扩展就必须走环.不然,则\)</span>S
T $有边在环上,只要溜达一圈就行.</p>
<p>接下来的问题在于找简单环.我们直接dfs,就可以找到一部分环.但是其实是没有找到全部的环的.但是没关系,在dfs的过程中,dfs树不可能有横插边,也就是所有找到的的环不在树上的边一定是反走边.而没有找到的环可能是若干个反走边拼起来的.这必然意味着它可以由那些反走边所代表的环拼起来:原因比较简单,考虑从上往下遍历这个没找到的环,那么每条边一定被经过了两次:下去一次,上来一次.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P6178</p>
<p>板子题</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P4455</p>
<p>板子题</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4336</p>
<p>简单题,无脑矩阵树定理+容斥.复杂度$O ( 2 ^n n ^3 ) $.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P5807</p>
<p>板子题</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF917D</p>
<p>一眼二项式反演.不妨设$f _i <span class="math inline">\(表示钦定\)</span>i $条边已经选上了的答案.显然:</p>
<p><span class="math display">\[
ans _k = \sum _{ i \geq k  } ( - 1 ) ^{ i - k  } \binom { i  } { k  } f
_i
\]</span></p>
<p>对于$f _i <span class="math inline">\(,考虑Prufer序列的推论:\)</span>k <span class="math inline">\(个大小分别为\)</span>s _1 , s _2 , , s <em>k <span class="math inline">\(的连通块,任意加边使得连通块成树的方案数是\)</span>n
^{ k - 2 } s <span class="math inline">\(.于是考虑dp,不妨设\)</span>dp
</em>{ x , i , j } <span class="math inline">\(表示当前\)</span>x <span class="math inline">\(为根的子树内部,当前\)</span>x <span class="math inline">\(所在连通块的大小是\)</span>i <span class="math inline">\(的方案数,这样可以做到\)</span>O ( n ^3 ) $.</p>
<p>看了看题解发现可以做到$O ( n ^2 ) <span class="math inline">\(.简单来说就是考虑\)</span>s <span class="math inline">\(的组合意义,是在每个连通块内选一个点的方案数.那我们可以用\)</span>f
_{ i , j , 0 / 1 } <span class="math inline">\(表示当前\)</span>i <span class="math inline">\(子树内选了\)</span>j <span class="math inline">\(个点,然后\)</span>i
$所在连通块内是否选点了的方案数.</p>
<h3><span id="计算几何">计算几何</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2742</p>
<p>板子题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3829</p>
<p>简单题,注意到圆弧之和一定是一个圆,因此把角上的四个点拿出来做凸包即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4196</p>
<p>板子题.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3256</p>
<p>板子题.甚至</p>
<h4><span id="第五题第六题第七题">第五题/第六题/第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P1742</p>
<p>https://www.luogu.com.cn/problem/P2533</p>
<p>https://www.luogu.com.cn/problem/P4288</p>
<p>三个题全是一样的.</p>
<p>大概是这么做的啊,就是说我们增量构造,每次对于前$i <span class="math inline">\(个点的最小覆盖圆,考虑\)</span>i + 1 <span class="math inline">\(个点在不在圆上.如果在就忽略,不在的话,那它必然是新圆的一个卡着边的点.考虑再找到另两个卡着边的点,我们暴力枚举这两个点.并且计算出所有的圆,挑选面积最大的那个.事实上,可以直接每次更新圆,直到这个圆包含了前\)</span>i
+ 1 $个点,显然总会遇到,然后之后就不会更新这个圆了.</p>
<p>这个写法导致了复杂度正确.具体来说,考虑一个点成为卡着圆边界的点的概率是$
{ n } $,这三层循环的调用次数分别是:</p>
<p><span class="math display">\[
\begin{aligned}
T _3 ( n ) &amp; = O ( n ) \\
T _2 ( n ) &amp; = O ( n ) + \sum _{ i = 1  } ^n \frac { 3  } { i  } T
_3 ( i ) \\
T _1 ( n ) &amp; = O ( n ) + \sum _{ i = 1  } ^n \frac { 3  } { i  } T
_2 ( n )
\end{aligned}
\]</span></p>
<p>显然$T _1 ( n ) = O ( n ) $.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P2287</p>
<p>枚举三个点,然后判断这三个点所在平面是否是三维凸包的一个面.注意四点共面就完蛋了,因此每个点加上一个随机扰动量.这个量首先得在eps范围内显著体现出来,其次还不能对答案影响太大.这个题是直接给了一个小于$10
^{ - 10 } $的扰动量,然后因为没有判相等操作,直接用了c++的浮点数比较.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P1452</p>
<p>板子题.</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6247</p>
<p>板子题.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3187</p>
<p>旋转卡壳的时候维护三个边界就行.</p>
<h3><span id="网络流建图">网络流建图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>Hall引理的时候做过.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF311E</p>
<p>发现变$0 $变$1 $这个操作可逆,不妨先把所有位置都变成$1 $.</p>
<p>接下来考虑把若干个$1 $变成$0 $.不难发现:一个全$0 <span class="math inline">\(的要求合法\)</span>$所有包含位置都是$0 <span class="math inline">\(\Leftrightarrow\)</span>所 有 包 含 位 置 都 不 是
<span class="math inline">\(1\)</span>$包含这些的全$1
$要求不合法.这是一个最大权闭合子图问题.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF884F</p>
<p>直接费用流,考虑左边每个点是字母,然后连到右边的点上,拆一下点保证对应的位置不会有相同字母.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF802C</p>
<p>牛逼题,考虑我们不好搞这个丢弃的东西,因为你也不知道你留下来的是谁.因此我们考虑如果一本书不在当天丢弃,那就一定会对下本书产生贡献,我们把它当成将书卖出.</p>
<p>也就是说,考虑将每一天建点,上面这个过程保证了我们每一天的书都会买,这就保证了最大流量.</p>
<p>将每一天建点并以流量为$k - 1
$的边相连(因为下一天必须买书),然后如果这本书要留着,就在前一天卖掉.</p>
<p>但是这样需要保证,我们卖书的时候必定在前面没有丢弃这本书,拆点维护,用一个点同时维护当天丢弃和卖书两种操作即可.</p>
<p>点数是$2 n <span class="math inline">\(的,边数有拆点的\)</span>n
<span class="math inline">\(条,连接相邻两天的\)</span>n
$条,卖出的和丢弃的共$2 n $条,这样总共是$4 n $条边.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF786E</p>
<p>一眼最小割,然后线段树+树剖优化建图.注意这样是$O ( n ^2 n ) <span class="math inline">\(的建图,我们把树剖跳topn的过程建一个点,这样就是\)</span>O
( n n ) $的建图.</p>
<p>考虑点数,原图有$n $个点,线段树是$2 n <span class="math inline">\(个点,树剖只会贡献\)</span>n $个点,点数是$4 n
$的.</p>
<p>考虑边数,注意到一个点会连$2 n <span class="math inline">\(条边到树剖上,在最后一下会连\)</span>n
$个点到线段树上,因此总边数是$2 n + 3 m n ^6 $,但是显然远远跑不满.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1139E</p>
<p>第一反应是二分答案,然后拿网络流二分图匹配check,这样复杂度是$O ( n ^2
n ) $的.</p>
<p>事实上注意删人后答案只减不增,因此复杂度$O ( n ^2 ) $.</p>
<p>但是这样过不去,考虑把删除改成增加,这样就可以在残留网络上跑,然后就能过了.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1061E</p>
<p>考虑每个问题,其实是形如要保证子树内有一定数量的点不能选.也就是这个限制要和修建港口抢城市.</p>
<p>但是不同的限制可能限制了同一城市,我们发现深度更浅的那个限制数量可以减去深度较深的限制数量,毕竟较深的满足较浅的也就满足了.</p>
<p>但是这个思路建图好像有点不太对.因为两个树的港口是通用的,那考虑让一个限制是入,另一个限制是出.换句话说,让一个限制被源点流,另一个限制流向汇点,中间是树节点,源点连出去的边有一个权值,跑费用流.</p>
<p>注意到每个点只会被连一次,因此边数大概是$2 n $级别,点数是$3 n
$级别.</p>
<p>总之这种网络流题,主要还是要考虑谁连着源点,谁连着汇点.这个题我一开始以为是限制连源点,然后城市连汇点,发现做不了,那就两种限制分别连源点和汇点.</p>
<h3><span id="交互题练习">交互题练习</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5875</p>
<p>这是广义串并联图嘛?好像显然不是.</p>
<p>但是仍然有性质,如果没有点权的话,注意到(1)一定会选新加入的点,(3)也一定会选新加入的点,(2)则一定要么两者都选要么都不选.</p>
<p>现在有点权,考虑把新加入的点删了,不妨设新加入的点为$i <span class="math inline">\(,主持人为\)</span>x $,自然有:</p>
<ol type="1">
<li><p>$a _i ans , a _x : = { 0 , a _x - a _i } $.</p></li>
<li><p>$a _x : = a _x + a _i $.</p></li>
<li><p>$a _x : = { a _x , a _i } $.</p></li>
</ol>
<p>不难发现每一步操作做完后,答案都不会改变.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3641</p>
<p>牛逼题.</p>
<p>考虑答案最小是什么,根据鸽笼原理,显然是$B = { n - 1 } $.</p>
<p>所以我们按照值域每$B <span class="math inline">\(长度分块,然后考虑答案不可能出现在块内,也就是块内的点对不可能贡献答案,答案只有可能由上一个数字(也就是上一个查询到的\)</span>mx
<span class="math inline">\()和当前块的\)</span>mn <span class="math inline">\(贡献.这样一开始的贡献是\)</span>n + 1 <span class="math inline">\(,中间问了\)</span>n - 1 <span class="math inline">\(次,总共涉及到了\)</span>n - 2
$个数字,这样就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3777</p>
<h5><span id="sub1">Sub1</span></h5>
<p>minValue是好求的,我们考虑选取${ 1 , 0 , , 0 }
$,这样的话对手必然放弃一个,被放弃的那个就是最小的.</p>
<h5><span id="sub2">Sub2</span></h5>
<p>一个显然的想法是,如果我们一开始全选$1 <span class="math inline">\(,那么对手一定会选取\)</span>[ 51 , 100 ]
$中的所有数字.</p>
<p>然后呢?我们接下来考虑继续在$[ 51 , 100 ]
$这些数字中找到最大的.我们肯定要让它们全选$2 <span class="math inline">\(,这样对方可能会放弃一些这个区间中较小的数字,然后去选取\)</span>[
1 , 50 ] $中较大的一些.持续这个过程,发现正好需要四次操作.</p>
<h5><span id="sub3">Sub3</span></h5>
<p>考虑结合sub1和sub2,我们不妨询问${ x , x , 0 , 0 , } <span class="math inline">\(,这样直觉上总是存在一个\)</span>x
$使得前两个数字有一个被放弃.</p>
<p>事实上也确实.考虑前两个数字中较小的那一个,设为$v <span class="math inline">\(,当\)</span>_{ i = x } ^{ 2 x } i = { 2 } v <span class="math inline">\(的时候,显然它就会被放弃,对于这个最小的\)</span>x
<span class="math inline">\(,会发现两个数字中较大的那个(设为\)</span>w )
<span class="math inline">\(一定不会被放弃,因为如果它被放弃了,一定是因为\)</span>w
x - 1 <span class="math inline">\(,而我们知道\)</span> { 2 } &lt; v &lt;
w x - 1 <span class="math inline">\(,又因为\)</span>x
$,因此显然不成立.</p>
<p>二分这个$x <span class="math inline">\(,由于\)</span>v _{ } = 99
<span class="math inline">\(,发现\)</span>x $,直接二分需要四次.</p>
<p>然后有个牛逼做法是,考虑每个$x <span class="math inline">\(能控制一个区间的\)</span>v <span class="math inline">\(,发现\)</span>x = 7 <span class="math inline">\(的那个区间全部被覆盖了两次,因此不用选取\)</span>x
= 7 $.</p>
<h5><span id="sub4">Sub4</span></h5>
<p>这个简单,不难发现只需要在$B _i = B _j = 100
$,那么对手就必然需要在这两者中选一个留下来,这样我们就可以比较任意两个位置的大小,使用stable_sort即可.</p>
<h5><span id="sub5">Sub5</span></h5>
<p>一种想法是sub4+sub3,但过不去.</p>
<p>冷静思考,注意到sub2,我们其实是知道了某些位置在哪个权值区间的.对着这个分治下去,这样实现了划分区间的功能,按理说应该是会有$2
n - 1 $个节点.</p>
<p>冷静一下,$l = r <span class="math inline">\(的叶子节点是不用计算的,因此刚好玩了\)</span>n - 1
$次.</p>
<p>现在唯一的问题是,我们怎么找到一个$w <span class="math inline">\(,使得这个区间内我都选\)</span>w <span class="math inline">\(后,然后这个区间一定会被划分呢?考虑\)</span>sub 3
<span class="math inline">\(告诉我们如果\)</span>r - l + 1 <span class="math inline">\(一定有解,考虑\)</span>( r , 100 ] <span class="math inline">\(的数字肯定要被选,那对方只剩下\)</span>r <span class="math inline">\(个石子,不妨直接令\)</span>w = { r - l + 1 } + 1
<span class="math inline">\(,注意到这个区间一定选不满.并且由于\)</span>r
- l + 1 &gt; 12 $,因此你会发现前面即使全选了也有剩余.</p>
<p>实际的写法选择了直接枚举$w $,然后判断是否合法.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P4373</p>
<p>这怎么做!考虑分块.(这谁想得到啊)</p>
<p>不妨设$f <em>i <span class="math inline">\(表示\)</span>[ i , i + k -
1 ] <span class="math inline">\(的最小值,我们先求出来\)</span>f </em>{ 0
} , f <em>{ B } , f </em>{ 2 B } , <span class="math inline">\(的值.这个怎么求呢?考虑一个值什么时候有用:如果它比队列末尾优秀肯定有用,不然只有它是\)</span>B
<span class="math inline">\(的倍数,它才有可能有用.我们只去维护这两种情况,就可以做到\)</span>O
( ) $的空间.</p>
<p>然后考虑剩下的$( iB , ( i + 1 ) B ) <span class="math inline">\(这些答案怎么求.不难发现这些的\)</span>f <span class="math inline">\(一定大于等于\)</span>f <em>{ iB } <span class="math inline">\(并且小于等于\)</span>f </em>{ ( i + 1 ) B } <span class="math inline">\(.如果直接对这个做单调队列空间还是不足,但我们发现做单调队列的时候,会被弹出的只有\)</span>[
f <em>{ iB } , ( i + 1 ) B ) <span class="math inline">\(这些数字,剩下的只要右端点卡到它,就一定不会被弹出.因此只需要对前面这个东西做单调队列,直到做到\)</span>f
</em>{ ( i + 1 ) B }
$出现,那我们就停下来,把前面该输出的答案全部输出.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P5473</p>
<p>考虑异或能实现的是判断奇偶性,具体来说,我们很容易判断一个点到一个集合内部点的奇偶性.考虑这样其实已经能$O
( n )
$找到一个点了:我们每修改一个前缀,然后check所有不在这个前缀内的点,这样就可以知道它俩是有边的.</p>
<p>这个过程能不能二分呢?好像不能,那我们随机化.</p>
<p>换句话说,我们random_shuffle一下序列,然后分治,每次把左侧的点全部点亮,然后看右侧的点有没有发生变化.如果发生了,则说明左侧的点到右侧的点的边的数量是奇数,递归下去处理,就可以至少连一条边,把这条边删了继续做.</p>
<p>然后发现这么写有个$L _c = 0 <span class="math inline">\(的\)</span>B
<span class="math inline">\(包过不去啊,那个包可以考虑我们对于一个点\)</span>x
<span class="math inline">\(,二分\)</span>[ 0 , x - 1 ] <span class="math inline">\(中谁是它的父亲.不难发现如果把\)</span>[ 0 , k ]
$这个前缀全部modify掉,并且它父亲在里面,那它当前状态一定是$1
$.用整体二分解决这个问题.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6541</p>
<p>考虑动态点分树.每次找到一对点$x , y <span class="math inline">\(,\)</span>x <span class="math inline">\(已知,\)</span>y <span class="math inline">\(未知,然后explore(x,y).如果得到的是未知的点,那就不断操作直到得到\)</span>y
$.</p>
<p>反之,考虑得到了$z <span class="math inline">\(,由于\)</span>z <span class="math inline">\(已知,因此\)</span>z <span class="math inline">\(在我们的点分树上.不妨从\)</span>z <span class="math inline">\(暴力向上跳到\)</span>x <span class="math inline">\(,这样就可以知道\)</span>y <span class="math inline">\(在\)</span>x
$的哪个方向,往那个方向的点分树儿子走一步即可.</p>
<p>至于动态点分树怎么做,替罪羊重构即可.</p>
<p>至于链,我们每次随机一个没有搞定的点,走过去即可.期望的错误次数是$O ( n
) $的.</p>
<h3><span id="模拟退火">模拟退火</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2503</p>
<p>考虑如果要求有序划分,可以直接写一个dp.</p>
<p>因此我们考虑每次交换几个位置,然后当成有序的跑dp,用这个来模拟退火.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2538</p>
<p>随机交换两个城市的状态即可.如果为了复杂度更好一点可以要求交换的城市状态必然不同.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5544</p>
<p>这题退火退半天退不出来,但是爬山直接过了.</p>
<p>这是为啥呢?原因在于,这题我们既然要对坐标进行跳跃,很有可能大部分坐标的答案都是$0
$.这就必然导致了我们一开始可能跳到了很远的地方,但是由于一直是$0
$,因此不断地跳过去.很难蚌.</p>
<p>而爬山不会有这种问题.</p>
<p>有没有什么改良的方式?一种是改变估价函数,通过精细实现估价函数导致其估价为连续实数函数,这样退火的效果就会好很多.</p>
<p>总的来说,退火失败的地方在于它一开始跳跃得太远了.而由于前几次操作我们跳出去的概率很大,因此极难得到答案.对于这种跳跃性不确定的题,反而你发现爬山不会拘束于局部最优解,而是会跳出去的.这也就是爬山在这题表现极其良好的原因.</p>
<p>有没有什么更优秀的方式呢?我们考虑先爬几次山,爬到一个好地方,然后以这个位置开始退火往旁边跳.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P7218</p>
<p>考虑一个显然的贪心是,直接枚举每个$W $,能放就放.</p>
<p>考虑把一开始所有能放的$W
$全拿出来作为一个操作序列,然后用模拟退火打乱.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1105E</p>
<p>不妨考虑满足某个人要求,就一定要在一段时间内全是它的id.也就是说如果两个人都抢了一段时间,那这两个人不能同时选择.</p>
<p>这也就是一个最大团问题,模拟退火解决一下.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="kmp">KMP</span></h3>
<h5><span id="example1zr23省选第一轮集训day5b">Example1(zr23省选第一轮集训day5b)</span></h5>
<p>必须提一下的是,能用KMP的前提是可以比较两个字符串是否相等,不一定是比较两个字母相等.只要能比较两个字符串是否相等,并且已知$A
= B <span class="math inline">\(能快速判断是否有\)</span>A + a = B + b
<span class="math inline">\(,那么就可以使用KMP.并不要求\)</span>A = B
<span class="math inline">\(并且\)</span>a = b <span class="math inline">\(才有\)</span>A + a = B + b $.</p>
<p>因此,我们取$p <span class="math inline">\(的置换\)</span>q <span class="math inline">\(,然后找到所有和\)</span>q
$的大小关系一样的区间即可,要证明这是个等价关系,然后就可以上KMP了.</p>
<h5><span id="example2noi2014-动物园">Example2(NOI2014 动物园)</span></h5>
<p>自然的想法是先求border数组,然后每次暴力跳border直到当前前后缀不重叠.根据border的定义显然是对的.但这样复杂度不对.</p>
<p>另一个想法是我们能不能在做KMP的时候,直接判掉当前长度是否超过,如果超过就放弃呢?也不对,因为这样往前跳也会用到这个border数组,但往前跳有可能跳的很少.</p>
<p>因此我们先求border,再第二遍做KMP,用另一个数组,但是往前跳的时候用border跳,其他情况正常做就行.</p>
<h3><span id="border理论">border理论</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p>$s <span class="math inline">\(的某个border长度为\)</span>k <span class="math inline">\(等价于\)</span>| s | - k <span class="math inline">\(是\)</span>s $的周期.</p>
<p>证明显然.</p>
<h5><span id="定理2周期引理">定理2(周期引理)</span></h5>
<p>弱周期引理:如果$p , q <span class="math inline">\(是\)</span>s <span class="math inline">\(的周期且\)</span>p + q | s | <span class="math inline">\(,那么\)</span>( p , q ) <span class="math inline">\(是\)</span>s $的周期.</p>
<p>考虑分开两面证明,不妨设$p &gt; q , r = p - q <span class="math inline">\(,先证明\)</span>i &gt; q , s <em>i = s </em>{ i +
r } <span class="math inline">\(,事实上\)</span>s <em>i = s </em>{ i - q
} = s <em>{ i - q + p } = s </em>{ i + r } <span class="math inline">\(.再考虑证明\)</span>i | s | - p , s <em>i = s
</em>{ i + r } <span class="math inline">\(,事实上\)</span>s <em>i = s
</em>{ i + p } = s <em>{ i + p - q } = s </em>{ i + r } $.</p>
<p>由于$p + q | s | <span class="math inline">\(,因此上面那个证明对所有\)</span>i
$成立,由此得证.</p>
<p>强周期引理:如果$p , q <span class="math inline">\(是\)</span>s <span class="math inline">\(的周期且\)</span>p + q - ( p , q ) | s | <span class="math inline">\(,那么\)</span>( p , q ) <span class="math inline">\(是\)</span>s $的周期.</p>
<p>这个有一个生成函数证明.简单来说我们不妨设长度为$p <span class="math inline">\(的那个周期的生成函数为\)</span>P ( z ) <span class="math inline">\(,它是一个\)</span>p - 1 <span class="math inline">\(次的生成函数.同理定义\)</span>Q ( z ) <span class="math inline">\(.不妨设\)</span>S _p ( z ) = { 1 - z ^p } <span class="math inline">\(,同理定义\)</span>S _q ( z ) $.</p>
<p>如果我们能说明$S _p ( z ) = S _q ( z ) <span class="math inline">\(,由于这两个都是无穷项,由欧几里得算法立刻得到\)</span>(
p , q ) $是其周期.考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S _p ( z ) - S _q ( z ) \\
&amp; = \frac { P ( z )  } { 1 - z ^p  } - \frac { Q ( z )  } { 1 - z
^q  } \\
&amp; = \frac { 1 - z ^g  } { ( 1 - z ^p ) ( 1 - z ^q )  } ( \frac { 1 -
z ^q  } { 1 - z ^g  } P ( z ) - \frac { 1 - z ^p  } { 1 - z ^g  } Q ( z
) )
\end{aligned}
\]</span></p>
<p>此时注意到括号里面的那个东西的次数有限,设其为$H ( z ) <span class="math inline">\(,不难发现\)</span>H ( z ) <span class="math inline">\(的次数是\)</span>p + q - g - 1 <span class="math inline">\(.若\)</span>H ( z ) <span class="math inline">\(,又因为\)</span> { ( 1 - z ^p ) ( 1 - z ^q ) }
$的常数项不为$0 <span class="math inline">\(,因此\)</span> k p + q - g -
1 , [ z ^k ] ( S _p ( z ) - S _q ( z ) ) <span class="math inline">\(,但根据假设,\)</span> k n - 1 p + q - g - 1 <span class="math inline">\(,应该有\)</span>[ z ^k ] ( S _p ( z ) - S _q ( z )
) = 0 <span class="math inline">\(,因此\)</span>H ( z ) = 0 <span class="math inline">\(,因此\)</span>S _p ( z ) = S _q ( z ) $.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若$S <span class="math inline">\(是\)</span>T <span class="math inline">\(的前缀,且\)</span>T <span class="math inline">\(有周期\)</span>a <span class="math inline">\(,\)</span>S <span class="math inline">\(有整周期\)</span>b <span class="math inline">\(,\)</span>b | a , | S | a <span class="math inline">\(,则\)</span>T <span class="math inline">\(有周期\)</span>b $.证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>若$2 | S | | T | <span class="math inline">\(,则\)</span>S <span class="math inline">\(在\)</span>T $中的匹配位置必为等差序列.</p>
<p>证明考虑WPL就行.</p>
<h5><span id="定理5">定理5</span></h5>
<p>$S <span class="math inline">\(的长度大于等于\)</span> { 2 }
$的border长度构成一个等差序列.</p>
<p>不妨设最长的border长度为$n - p <span class="math inline">\(,还有一个border长度是\)</span>n - q <span class="math inline">\(,\)</span>q &gt; p <span class="math inline">\(,那么必有长度为\)</span>n - ( p , q ) <span class="math inline">\(的border.注意到\)</span>n - p <span class="math inline">\(是最长的border,则\)</span>( p , q ) p <span class="math inline">\(,\)</span>p | q $.</p>
<h5><span id="定理6">定理6</span></h5>
<p>一个串的所有border按照长度排序后,可以被划分成$O ( n )
$个等差序列.</p>
<p>首先,将该串的长度$ { 2 } <span class="math inline">\(的border拿出作为一个等差序列.考虑这些中长度最小的\)</span>T
$.</p>
<p>再考虑最小循环节$d <span class="math inline">\(,如果\)</span>d { 4 }
<span class="math inline">\(,那么不断减小一定有\)</span>| T | { 4 } n
<span class="math inline">\(.反之则最长border本身就\)</span> { 4 } n
<span class="math inline">\(,于是剩下的border都是\)</span>T <span class="math inline">\(的border.这样就证明了\)</span>O ( n ) <span class="math inline">\(,事实上更紧凑的界是\)</span>_2 | S | $,不会证.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poi2011okr-periodicity">Example1([POI2011]OKR-Periodicity)</span></h5>
<p>注意到一个事实:如果这个字符串存在长度为$k <span class="math inline">\(的周期,等价于存在长度为\)</span>len - k
$的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设$q $为最小周期,如果$2 q &lt; n <span class="math inline">\(,也就是原串能写成\)</span>tt t ’ <span class="math inline">\(的形式.我们不妨先求\)</span>tt ’ <span class="math inline">\(对应的答案,然后在前面拼\)</span>t <span class="math inline">\(.根据\)</span> { 2 }
$的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果$2 q n <span class="math inline">\(,此时必定有\)</span>s = tat
<span class="math inline">\(,其中\)</span>t <span class="math inline">\(是border.考虑递归求解\)</span>t <span class="math inline">\(,然后就只需要找到一个\)</span>a <span class="math inline">\(满足条件,最小的\)</span>a $是全$0
$,能放的话肯定放,不然我们就放一个$0 $.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全$0 $不合法:</p>
<ol type="1">
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l |
t | + | a | <span class="math inline">\(:考虑\)</span>l
$的最后一段是一段全$0 <span class="math inline">\(,也就必然意味着\)</span>t $的最后一段是全$0
$,这么不断推下去就可以说明整个序列都是全$0 $,此时放上$0
$必定合法.</p></li>
<li><p>新增一个长度$l <span class="math inline">\(的border,\)</span>l
&gt; | t | + | a | <span class="math inline">\(:不妨设当前的\)</span>l
<span class="math inline">\(是最大的那个(最小的无意义,因为需要保证\)</span>| l
| &gt; | t | <span class="math inline">\(),此时最短周期必然是\)</span>d
= 2 | t | + | a | - l <span class="math inline">\(.由于\)</span>| t | +
| a | <span class="math inline">\(也是周期并且二者之和\)</span>n <span class="math inline">\(,因此必然有\)</span>d | ( | t | + | a | ) <span class="math inline">\(.把\)</span>ta <span class="math inline">\(按照\)</span>d <span class="math inline">\(长度划分.如果\)</span>d | a | $必有该串是全$0
<span class="math inline">\(串,不然考虑此时\)</span>d = | b | + | a |
<span class="math inline">\(,\)</span>b <span class="math inline">\(是\)</span>t <span class="math inline">\(的一段后缀.考虑此时的周期必然\)</span>&lt; | b | +
| a | <span class="math inline">\(,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比\)</span>|
b | - | a | <span class="math inline">\(少了\)</span>w <span class="math inline">\(,那么此时必定有\)</span>b <span class="math inline">\(的前\)</span>w $个字符是$0 $,但是由于$0 <span class="math inline">\(后面第一个\)</span>b <span class="math inline">\(也往前平移了\)</span>w <span class="math inline">\(格,因此它的第\)</span>w $个字符必定是$1
$,这就保证了$0 1 $必定合法.</p></li>
</ol>
<h3><span id="sa">SA</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个长度为$n <span class="math inline">\(的字符串,要从中从左往右选出若干段不相交的子串,使得选出的这些串中,每个串都是上一个串的严格子串.求最多能选出多少段.\)</span>n
^5 $.</p>
<p>不难发现一定有一组答案每段的长度是$k , k - 1 , , 2 , 1
$,我们不妨把串反过来,这样就是$1 , 2 , , k - 1 , k <span class="math inline">\(.这样就可以设计一个简单的dp是\)</span>f _{ i , j }
<span class="math inline">\(表示以\)</span>i <span class="math inline">\(结尾,\)</span>i <span class="math inline">\(这段长度为\)</span>j <span class="math inline">\(是否可行,发现单调性后把dp状态扔进值里,\)</span>f
_i <span class="math inline">\(表示以\)</span>i <span class="math inline">\(结尾的最大长度是多少,这样用SA做lcp就可以实现\)</span>O
( n ^2 ) <span class="math inline">\(.仔细观察转移过程,我们可以二分答案,然后用主席树+SA判断答案是否可行.复杂度\)</span>O
( n ^2 n ) $.</p>
<p>那么怎么优化呢?我们考虑类似height的证明:$f <em>i f </em>{ i - 1 } + 1
<span class="math inline">\(,原因很简单,如果\)</span>f <em>i &gt; f
</em>{ i - 1 } + 1 <span class="math inline">\(,那么我们把\)</span>f _i
<span class="math inline">\(那个序列的末尾字符全部删掉,自然得到了一个以\)</span>i
- 1 <span class="math inline">\(结尾,长度为\)</span>f <em>i - 1 &gt; f
</em>{ i - 1 } $的串,于是就可以类似height那样去掉二分,很厉害.</p>
<h3><span id="acam">ACAM</span></h3>
<p>用于对于每个文本串的前缀,求出它以哪些模式串为后缀.</p>
<h5><span id="example1uoj772企鹅游戏">Example1(uoj772企鹅游戏)</span></h5>
<p>考虑一个暴力:建出$s <span class="math inline">\(的AC自动机,然后我们记录fail树结构,然后把\)</span>t
<span class="math inline">\(放上去跑,每次暴力向上跳fail树上的匹配节点,这样的复杂度就是\)</span>O
( 匹 配 节 点 个 数 ) $.</p>
<p>但是这个复杂度是正确的.</p>
<p>为啥呢?首先对于任意节点,它在fail树上的祖先中匹配节点个数不可能超过$O
( ) <span class="math inline">\(个,这是个自然根号,因此复杂度至少是\)</span>O ( L )
$.</p>
<p>但还没完,考虑所有长度小于等于$B <span class="math inline">\(的模式串,他们会被匹配\)</span>O ( B | t | ) <span class="math inline">\(次.对于所有长度大于\)</span>B <span class="math inline">\(的模式串,考虑只有长度大于\)</span>B <span class="math inline">\(的文本串会匹配到他们,于是复杂度\)</span>O ( { B ^2
} ) <span class="math inline">\(,\)</span>B = L ^{ { 3 } } <span class="math inline">\(得到\)</span>O ( L ^{ { 3 } } ) $.</p>
<h5><span id="example2loj3396-novel">Example2(loj3396 novel)</span></h5>
<p>offline.</p>
<h3><span id="pam">PAM</span></h3>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li>本质不同回文串最多只有$n $个.</li>
</ol>
<p>证明:考虑类似manacher,每次将$S S + c <span class="math inline">\(,新产生的回文串一定是\)</span>S + c
$的最长回文后缀.</p>
<h4><span id="算法">算法</span></h4>
<p>回文自动机由转移边和fail树构成,经过一条转移边的影响是在前后均添加一个该字符,一个状态在fail树上指向它的最长回文border.</p>
<p>我们记录两个根:长度为$- 1 $的奇根和长度为$0
$的偶根,偶根的失配指针指向奇根.</p>
<p>增量构造,每次加入个新字符,然后在fail树上跳祖先直到$s <em>i = s </em>{
i - len - 1 } $.</p>
<p>继续跳这个节点,直到又遇到一个位置,那这个位置就是当前节点的fail指针所指向的点.这个操作是$O
( n )
$的,因为这个fail指针只有一个永远不会访问,另外的都会访问至少一次,在访问的时候就会均摊掉求的时候往上跳的复杂度,因为深度直接减去这玩意了.</p>
<h3><span id="sam">SAM</span></h3>
<ol type="1">
<li><p>$endpos ( T ) <span class="math inline">\(表示子串\)</span>T
<span class="math inline">\(在\)</span>S <span class="math inline">\(中出现位置的末尾集合,特别地,我们设\)</span>endpos
( ) = { 1 , , | S | - 1 , | S | } $.</p></li>
<li><p>若两个不同的子串的$endpos <span class="math inline">\(相等,则称它们为一个\)</span>endpos
$等价类.</p></li>
</ol>
<p>下面开始证明引理:</p>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li><p>字符串$s <span class="math inline">\(的两个非空子串\)</span>u
<span class="math inline">\(和\)</span>w <span class="math inline">\(的\)</span>endpos <span class="math inline">\(相同(假设\)</span>| u | | w | <span class="math inline">\(),当且仅当字符串\)</span>u <span class="math inline">\(在\)</span>s <span class="math inline">\(中的每次出现,都是以\)</span>w
$后缀的形式存在.</p></li>
<li><p>字符串$s <span class="math inline">\(的两个非空子串\)</span>u
<span class="math inline">\(和\)</span>w <span class="math inline">\(的\)</span>endpos <span class="math inline">\(集合的交为空(假设\)</span>| u | | w | <span class="math inline">\(),当且仅当字符串\)</span>u <span class="math inline">\(不是\)</span>w $的后缀.</p></li>
<li><p>字符串$s <span class="math inline">\(的两个非空子串\)</span>u
<span class="math inline">\(和\)</span>w <span class="math inline">\(的\)</span>endpos <span class="math inline">\(集合的交为\)</span>endpos ( w ) <span class="math inline">\((假设\)</span>| u | | w | <span class="math inline">\(),当且仅当字符串\)</span>u <span class="math inline">\(是\)</span>w $的后缀.</p></li>
</ol>
<p>证明都是显然的.</p>
<ol start="4" type="1">
<li>对于一个$endpos <span class="math inline">\(等价类中的子串\)</span>u
<span class="math inline">\(,要么\)</span>u <span class="math inline">\(是这个等价类中最短的子串,要么存在一个子串\)</span>w
<span class="math inline">\(且\)</span>| w | + 1 = | u | <span class="math inline">\(,\)</span>w <span class="math inline">\(是\)</span>u $的后缀</li>
</ol>
<p>由前面的引理,容易证明.</p>
<ol start="5" type="1">
<li>对于一个$endpos <span class="math inline">\(等价类中最短的子串\)</span>w <span class="math inline">\(,不妨设\)</span>v <span class="math inline">\(是\)</span>w <span class="math inline">\(去掉最前面的元素后得到的子串,那么\)</span>v <span class="math inline">\(在另一个\)</span>endpos <span class="math inline">\(等价类中,我们将\)</span>endpos ( w ) endpos ( v )
<span class="math inline">\(,记\)</span>link ( w ) = v <span class="math inline">\(或\)</span>fa ( w ) = v
$,这就是后缀链接link,这些关系构成树.</li>
</ol>
<p>首先除了$<span class="math inline">\(,每个\)</span>w $的出度都是$1
<span class="math inline">\(,而我们发现所有的子串都会以\)</span>$作为祖先,这就证明了连通性.</p>
<ol start="6" type="1">
<li>$endpos <span class="math inline">\(等价类的数量有\)</span>O ( n )
$个.</li>
</ol>
<p>考虑后缀链接树,显然一个点的$endpos <span class="math inline">\(集合包含它的所有儿子的\)</span>endpos <span class="math inline">\(集合的并,并且它所有儿子的\)</span>endpos
$集合两两无交,这等价于一个合并的过程.</p>
<h4><span id="约定">约定</span></h4>
<ol type="1">
<li><p>记$longest ( v ) <span class="math inline">\(为\)</span>v <span class="math inline">\(这个\)</span>endpos <span class="math inline">\(等价类中最长的一个字符串,记\)</span>len ( v )
<span class="math inline">\(为它的长度.类似地定义\)</span>shortest ( v )
<span class="math inline">\(和\)</span>minlen ( v ) <span class="math inline">\(,不难发现\)</span>minlen ( v ) = len ( fa ( v ) )
+ 1 <span class="math inline">\(.每个节点的子串数量也就是\)</span>len (
v ) - len ( fa ( v ) ) $.</p></li>
<li><p>记$siz ( v ) <span class="math inline">\(为\)</span>v <span class="math inline">\(这个\)</span>endpos <span class="math inline">\(等价类的\)</span>endpos $集合的大小.</p></li>
</ol>
<h4><span id="算法">算法</span></h4>
<p>先来捋一下整个过程:整个SAM分为两部分:</p>
<p>第一部分:后缀链接树(parent tree).</p>
<p>它的信息由下文中的fa记录.对于每一个节点:它对应一个endpos等价类,因此它拥有一个父亲节点,也就是后缀链接link指向的节点.同时它拥有一个len,表示这个endpos等价类中最长的子串的长度.</p>
<p>第二部分:trie图.</p>
<p>它的信息由下文中的son记录,表示一个endpos(设为x)通过一条trie边走到另一个endpos(设为y),不难发现x中的所有endpos+1所形成的集合包含y.我们注意这一点后,会发现只要从$<span class="math inline">\(所代表的节点不断地走trie边,最后走到的节点的对应长度的子串就是我们想要的子串.这也意味着我们要保证对应长度的子串一定在走到节点的子串集合中.另外有个结论是trie图的边数是\)</span>O
( n ) <span class="math inline">\(的.这必然要求走trie走到的那个节点的\)</span>len
<span class="math inline">\(的长度的区间包含了这个节点的\)</span>len
<span class="math inline">\(的长度的区间\)</span>+ 1 $.</p>
<p>也就是说,走trie边的过程是不断在字符串后面添加字符的过程,而走link的过程是不断在字符串前面删去字符串的过程(当然,反向link自然是不断在字符串前面加上另一个字符串集合的过程).</p>
<p>下面给出构造代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>&#123;</span><br><span class="line"><span class="type">int</span> fa;</span><br><span class="line"><span class="type">int</span> son[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> len,siz;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cntp=<span class="number">1</span>,las=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> End[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_c</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=++cntp;</span><br><span class="line">End[i]=x;tr[x].siz=<span class="number">1</span>;<span class="comment">//新建一个endpos=&#123;i&#125;</span></span><br><span class="line"><span class="comment">//End[i]存的是前缀[1,i]的结束位置,由于我们当前正在插入i,自然是x.</span></span><br><span class="line"><span class="type">int</span> prex=las;</span><br><span class="line">las=cntp;</span><br><span class="line"><span class="comment">//las存储的是当前的终止节点,其实也就是End[i],我们每次要找到上一次的终止节点,根据它来操作.</span></span><br><span class="line">tr[x].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==<span class="number">0</span>;prex=tr[prex].fa)tr[prex].son[c]=x;</span><br><span class="line"><span class="comment">//考虑当前的串:[1,i-1]+&#x27;c&#x27;,如果前面存在一个endpos集合包含[j,i-1](这个集合可能是空子串所在的集合)并且它存在一条&#x27;c&#x27;边,那么就存在这么一个子串[j,i-1]+&#x27;c&#x27;,它的endpos应该是&#123;i&#125;这个集合的祖先.</span></span><br><span class="line"><span class="comment">//如果在判断[j,i-1]的时候,发现[j,i-1]+&#x27;c&#x27;在原串中不存在,那么我们就直接连过来.可以发现在这个跳跃的过程中就是不断探索当前x的shortest的过程.</span></span><br><span class="line"><span class="keyword">if</span>(!prex)&#123;</span><br><span class="line"><span class="comment">//说明一直到最后都没有找到字母c,这也意味着c在前面根本没出现过,于是endpos=&#123;i&#125;的等价类是[1,i],[2,i],...,[i,i],所以父亲设为1.</span></span><br><span class="line">tr[x].fa=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> y=tr[prex].son[c];</span><br><span class="line"><span class="comment">//考虑这里的prex到底是什么意义,它意味着我们找到了一个最长的[j,i-1]的子串所在的endpos集合,并且[j,i-1]+&#x27;c&#x27;这个子串在原串存在,这也意味着[j,i-1]+&#x27;c&#x27;这个子串所在的endpos集合必然真包含&#123;i&#125;,而这个子串的长度是tr[prex].len+1.</span></span><br><span class="line"><span class="keyword">if</span>(tr[y].len==tr[prex].len+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果y这个节点的长度恰好也是tr[prex].len+1,那么必然意味着[j,i]这个子串完全就在y这里,而[j-1,i]这些子串不在y这里,但被y表示的endpos集合包含.</span></span><br><span class="line">tr[x].fa=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//反之,这里y这个节点的endpos集合就可以分成两部分了:第一部分的endpos集合在加入[j,i]这个子串后不变:因为它们的长度都大于tr[prex].len+1,它们必然不可能存在一个endpos是i.而第二部分,其实也只包含一个子串:就是长度等于tr[prex].len+1的子串,它的endpos集合必然是第一部分的endpos集合并上&#123;i&#125;,根据我们上面所发现的parent tree的本质是合并endpos集合的性质,它应该是第一部分以及&#123;i&#125;的父亲(也就是这两部分合并的结果),我们把第二部分拿出来单独建点.</span></span><br><span class="line"><span class="type">int</span> fay=++cntp;</span><br><span class="line">tr[fay]=tr[y];</span><br><span class="line">tr[fay].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line">tr[y].fa=tr[x].fa=fay;</span><br><span class="line"><span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==y;prex=tr[prex].fa)tr[prex].son[c]=fay;</span><br><span class="line"><span class="comment">//注意单独建点后,原本指向y的trie边要改向.这是为什么呢?考虑当前这条边是什么意义:它必然指向一个endpos集合要包含&#123;i&#125;的点,因为这样才能保证trie图的性质.此时指向y的点就不能是包含&#123;i-1&#125;的点了.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> que[MAXN&lt;&lt;<span class="number">1</span>],l,r;</span><br><span class="line"><span class="type">int</span> ind[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work_siz</span><span class="params">()</span></span>&#123;<span class="comment">//通过一次拓扑排序处理出siz</span></span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">++ind[tr[i].fa];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ind[i]==<span class="number">0</span>)que[++r]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="type">int</span> x=que[l];++l;</span><br><span class="line">tr[tr[x].fa].siz+=tr[x].siz;</span><br><span class="line">--ind[tr[x].fa];</span><br><span class="line"><span class="keyword">if</span>(ind[tr[x].fa]==<span class="number">0</span>)que[++r]=tr[x].fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是省掉了很多说明:比如这里的复杂度证明以及边数证明,但是我们咕了吧.</p>
<h4><span id="应用">应用</span></h4>
<h5><span id="检查字符串是否出现">检查字符串是否出现</span></h5>
<p>从根开始跳trie边就行.</p>
<h5><span id="不同子串个数">不同子串个数</span></h5>
<p>显然是$len <em>i - len </em>{ fa _i } $.</p>
<h4><span id="例题">例题</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给出一个长度为$n <span class="math inline">\(的小写字母串,你需要计算有多少对非空字符串\)</span>(
A , B ) $满足:</p>
<ol type="1">
<li><p>$AB $是原串的子串.</p></li>
<li><p>每次$A <span class="math inline">\(在原串中作为子串出现后,要么紧跟着出现一个子串\)</span>B
<span class="math inline">\(,要么\)</span>A <span class="math inline">\(后面放不下一个子串\)</span>B $.</p></li>
</ol>
<p>两个字符串被认为是不同的当且仅当他们在某个位置上字母不同,$| S | ^5
$.</p>
<p>首先,我们考虑确定$( AB , A )
$这个二元组,对反串建立SAM,我们自然有:</p>
<ol type="1">
<li><p>$AB <span class="math inline">\(的endpos集合是\)</span>A
$的endpos集合的后缀.</p></li>
<li><p>$A <span class="math inline">\(的endpos集合中存在的最大的不存在于\)</span>AB
<span class="math inline">\(的endpos集合的endpos的大小小于\)</span>| AB
| $.</p></li>
</ol>
<p>看到这里你可能有疑问:为啥要建立反串.因为不建立反串的话$( AB , B )
<span class="math inline">\(的endpos可能根本没啥区别,这个很难处理\)</span>A
$.SAM最强大的武器还是在于它能快速处理endpos.</p>
<p>那么接下来我们要在SAM上判断这两件事,我们需要一些更方便判断的条件.首先一个自然的发现是,$A
<span class="math inline">\(的最大的endpos必然也是\)</span>AB <span class="math inline">\(的最大的endpos,我们进行一个类似重链剖分的操作:将每个点的重儿子设为它所有儿子中最大的endpos最大的那个.不难发现此时的\)</span>A
<span class="math inline">\(与\)</span>AB <span class="math inline">\(必然在同一条重链上,且\)</span>A <span class="math inline">\(是\)</span>AB <span class="math inline">\(的祖先.不过显然这并不能保证一定是后缀,我们开始补条件,直到补到它充要:另一个显然的条件是,设\)</span>mx
_v <span class="math inline">\(表示节点\)</span>v <span class="math inline">\(的轻儿子中最大的endpos最大是多少,那么\)</span>A
<span class="math inline">\(与\)</span>AB <span class="math inline">\(间的所有\)</span>mx <span class="math inline">\(的最大值就是\)</span>A <span class="math inline">\(的endpos集合中存在的最大的不存在于\)</span>AB
<span class="math inline">\(的endpos集合的endpos的大小,它需要小于\)</span>| AB
| <span class="math inline">\(.进一步发现这个数字必然需要小于\)</span>AB
<span class="math inline">\(的endpos的集合中最小的那个(不然就不是后缀),这被包含于小于\)</span>|
AB | $这个条件.</p>
<p>接下来就拆重链,写单调栈就行.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">多项式与生成函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2>
<h3><span id="复数相关">复数相关</span></h3>
<p>棣莫弗定理:$( cos + i ) ^n = ( n ) + i ( n ) $.</p>
<p>欧拉公式:$e ^{ i } = - 1 $.</p>
<p>也就是$e ^{ 2 i } = 1 <span class="math inline">\(,同时又有\)</span>e
^{ i } = cos + i · sin $,证明直接使用泰勒展开.</p>
<p>单位根:对于$x ^n = 1 <span class="math inline">\(,我们会有\)</span>n
<span class="math inline">\(个根,设第\)</span>k <span class="math inline">\(个根为\)</span>_n ^k <span class="math inline">\(.那么我们有:\)</span>_n ^k = e ^{ 2 { n } i } =
cos ( 2 { n } ) + i · sin ( 2 { n } ) $.</p>
<p>单位根有以下性质:</p>
<ol type="1">
<li><p>折半引理:$_{ 2 n } ^{ 2 k } = _n ^k \
$,由我们上面推导的通项公式即可证明.</p></li>
<li><p>消去引理:$_n ^{ k + { 2 } } = - _n ^k \
$,同样使用通项，运用三角恒等变换可证明.</p></li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4>
<p>上复平面,设$S _k = ( { n } , { n } ) <span class="math inline">\(,也就是\)</span>z _k = { n } + i { n } <span class="math inline">\(是方程\)</span>z ^n - 1 = 0
$的复根.我们把这个方程写开:</p>
<p><span class="math display">\[
z ^n - 1 = ( z - 1 ) ( z ^{ n - 1  } + z ^{ n - 2  } + \cdots + 1 ) = 0
\]</span></p>
<p>不难发现$z = 1 $是平凡解.</p>
<p>我们不妨定义$f ( x ) = <em>{ k = 1 } ^n ( 1 + X ^k ) = </em>{ k } a
_k X ^k $,事实上我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac { 1  } { n  } \sum _{ j = 1  } ^n f ( \omega _n ^j ) &amp; = \frac
{ 1  } { n  } \sum _{ j = 1  } ^n \sum _{ k \geq 0  } a _k \omega ^{
kj  } _n \\
&amp; = \frac { 1  } { n  } \sum _{ k \geq 0  } a _k \sum _{ j = 1  } ^n
\omega _{ n  } ^{ kj  } \\
&amp; = \sum _{ j \geq 0  } a _{ jn  } + \frac { 1  } { n  } \sum _{ k
\geq 0 , n \nmid k  } a _k \frac { 1 - \omega ^{ nj  } _n  } { 1 -
\omega ^{ k  } _n  } \omega _{ n  } ^j \\
&amp; = \sum _{ j \geq 0  } a _{ jn  }
\end{aligned}
\]</span></p>
<p>事实上,我们令$d = { ( j , n ) } <span class="math inline">\(,容易发现\)</span>f ( <em>n ^j ) = ( </em>{ k = 1
} ^d ( 1 + _n ^{ kj } ) ) ^{ { d } } <span class="math inline">\(,又容易发现\)</span>n | jd $.</p>
接下来观察$X ^d - 1 = <em>{ k = 1 } ^d ( X - </em>{ n } ^{ kj } ) <span class="math inline">\(,带入\)</span>X = - 1 <span class="math inline">\(得到\)</span>f ( _n ^j ) =
<span class="math display">\[\begin{cases}2 ^{ \frac { n  } { d  }  }
&amp; d \in \text { odd  } \\ 0 &amp; d \in \text { even  }
\end{cases}\]</span>
<p>$.</p>
<p>接下来考虑拿到$<em>{ j } a </em>{ jn } <span class="math inline">\(,只需求\)</span> { n } <em>{ j = 1 } ^n f ( <em>n
^j ) = { n } </em>{ d , ( j , n ) = { d } } 2 ^{ { d } } = { n } </em>{
d } ( d ) 2 ^{ { d } } $.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5>
<p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现$+ , - , , , <span class="math inline">\(五种操作.而对于正\)</span>n <span class="math inline">\(边形,显然只要我们能将\)</span> { n }
$用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6>
<p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma _1 &amp; = z _1 + z _4 \\
\sigma _2 &amp; = z _2 + z _3
\end{aligned}
\]</span></p>
<p>不难验证:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma _1 + \sigma _2 &amp; = - 1 \\
\sigma _1 \sigma _2 &amp; = - 1
\end{aligned}
\]</span></p>
<p>可以求出复合条件的解,将$z $带入又有:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma _1 &amp; = 2 \cos \frac { 2 \pi  } { 5  } \\
\sigma _2 &amp; = 2 \cos \frac { 4 \pi  } { 5  }
\end{aligned}
\]</span></p>
<p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6>
<p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6>
<p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设$n prime <span class="math inline">\(,我们用\)</span>p <span class="math inline">\(代替\)</span>n $.</p>
<p>我们有$z _1 = { p } + i { p } <span class="math inline">\(,由于其它的\)</span>z <span class="math inline">\(都可以表示成它的幂,因此我们记\)</span>= z _1
$.</p>
<p>我们现在想要这么分组:</p>
<p><span class="math display">\[
\sigma _{ k + 1  } = \sum _{ 1 \leq l \leq p - 1 , f ( l , k ) = 1  }
\varepsilon ^l
\]</span></p>
<h3><span id="泰勒展开">泰勒展开</span></h3>
<p>即$f ( x ) = g ( x ) = f ( x <em>0 ) + </em>{ k } { k ! } ( x - x _0
) ^k \ <span class="math inline">\(.\)</span>x _0 = 0
$的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2>
<h3><span id="多项式基础">多项式基础</span></h3>
<h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4>
<p>代数基本定理:一个$n - 1 <span class="math inline">\(次方程在复数域上有且只有\)</span>n - 1 $个根.</p>
<p>定理:一个$n - 1 <span class="math inline">\(次多项式在\)</span>n
$个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个$n - 1 <span class="math inline">\(次多项式\)</span>A ( x ) <span class="math inline">\(和\)</span>B ( x ) <span class="math inline">\(且有\)</span>i , A ( x _i ) = B ( x _i ) \ $.</p>
<p>令$C ( x ) = A ( x ) - B ( x ) <span class="math inline">\(,那么\)</span>C ( x ) <span class="math inline">\(至多是一个\)</span>n - 1 <span class="math inline">\(次多项式且\)</span>i , C ( x _i ) = 0 \ <span class="math inline">\(,也就是\)</span>C ( x ) <span class="math inline">\(有\)</span>n $个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:$A ( x ) = _{ i = 0 } ^{ n - 1 } a _i x ^i \ $.</p>
<p>点值表示法:$y <em>i = </em>{ j = 0 } ^{ n - 1 } a _j x _i ^j \ $.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式$_{ i = 0 } ^{ n - 1 } y <em>i ( </em>{ j = 0 j i } ^{ n -
1 } { x _i - x _j } ) \ <span class="math inline">\(.显然当\)</span>x =
x _i <span class="math inline">\(时,该多项式的答案为\)</span>y _i $.</p>
<p>另外,如果$x _i = i $,不难发现这个式子可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^{ n  } y _i ( \prod _{ j = 1 \land j \ne i  } ^{ n  }
\frac { x - x _j  } { x _i - x _j  } ) \\
\\
&amp; = \sum _{ i = 1  } ^n y _i ( \prod _{ j = 1 \land j \ne i  } ^n
\cfrac { x - j  } { i - j  } ) \\
&amp; = \sum _{ i = 1  } ^n y _i ( - 1 ) ^{ n - i  } ( \cfrac { 1  } { (
i - 1 ) ! ( n - i ) !  } \prod _{ j = 1 , j \ne i  } ^{ n  } ( x - j ) )
\end{aligned}
\]</span></p>
<h3><span id="多项式运算">多项式运算</span></h3>
<p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4>
<h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5>
<h6><span id="dft">DFT</span></h6>
<p>将$n <span class="math inline">\(次单位根(默认\)</span>n <span class="math inline">\(是二的整次幂,如果少了的话补零,设\)</span>n = 2 ^w
<span class="math inline">\()分别带入\)</span>A ( x ) <span class="math inline">\(得到点值向量\)</span>A ( _n ^k ) \ $.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
A ( x ) &amp; = \sum _{ i = 0  } ^{ n - 1  } a _i x ^i \\
&amp; = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^i
+ \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a _i x ^i \\
&amp; = \sum _{ i = 2 k , k \in \mathbb { N  }  } ^{ n - 2  } a _i x ^{
2 k  } + x \sum _{ i = 2 k + 1 , k \in \mathbb { N  }  } ^{ n - 1  } a
_i x ^{ 2 k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>令</p>
<p>A_2(x)=_{i=2k+1,k}<sup>{n-1}a_ix</sup>{k}\$, 那 么
$A(x)=A_1(x<sup>2)+xA_2(x</sup>2)\</p>
<p>接下来分类讨论:</p>
<p>$ k { 2 } - 1 , k \ $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^k ) &amp; = A _1 ( \omega _n ^{ 2 k  } ) + \omega _n ^k A
_2 ( \omega _n ^{ 2 k  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据折半引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^k ) &amp; = A _1 ( \omega _{ \frac { n  } { 2  }  } ^k )
+ \omega _n ^k A _2 ( \omega ^k _{ \frac { n  } { 2  }  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们处理完了前半部分.</p>
<p>$ { 2 } k + { 2 } n - 1 , k \ $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) &amp; = A _1 ( \omega _n
^{ 2 k + n  } ) + \omega _n ^{ k + \frac { n  } { 2  }  } A _2 ( \omega
_n ^{ 2 k + n  } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据消去引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega _n ^{ k + \frac { n  } { 2  }  } ) &amp; = A _1 ( \omega _{
\frac { n  } { 2  }  } ^k ) - \omega _n ^k A _2 ( \omega _{ \frac { n  }
{ 2  }  } ^k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>综上,我们可以递归处理$A _1 <span class="math inline">\(和\)</span>A
_2 <span class="math inline">\(,然后合并得到\)</span>A
$的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6>
<p>设$A ( _n ^k ) = d <em>k \ <span class="math inline">\(,构造多项式\)</span>F ( x ) = </em>{ i = 0 } ^{ n
- 1 } d _i x ^i \ $.</p>
<p>我们求出$F ( x ) <span class="math inline">\(的点值表示,设\)</span>c
_k = F ( _n ^{ - k } ) \ $,也即:</p>
$$
<span class="math display">\[\begin{aligned}
c _k &amp; = \sum _{ i = 0  } ^{ n - 1  } d _i ( \omega _n ^{ - k  } )
^i \\
&amp; = \sum _{ i = 0  } ^{ n - 1  } ( \sum _{ j = 0  } ^{ n - 1  } a _j
( \omega _n ^i ) ^j ) ( \omega _n ^{ - k  } ) ^i \\
&amp; = \sum _{ j = 0  } ^{ n - 1  } a _j \sum _{ i = 0  } ^{ n - 1  } (
\omega _n ^i ) ^{ j - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>当$j = k <span class="math inline">\(时,显然\)</span>_{ i = 0 } ^{ n
- 1 } ( _n ^i ) ^{ j - k } = n \ $.</p>
<p>否则根据等比数列求和公式,$_{ i = 0 } ^{ n - 1 } ( _n ^i ) ^{ j - k }
= { _n ^{ j - k } - 1 } = 0 \ $.</p>
<p>所以$_{ i = 0 } ^{ n - 1 } ( _n ^i ) ^{ j - k } = n [ j = k ] \
$.</p>
<p>那么我们有</p>
<p>a_k=\</p>
<h6><span id="写法">写法</span></h6>
<p>递归写法显然.</p>
<p>递归过程中,第$k <span class="math inline">\(层相当于在根据数在第\)</span>k $位的二进制数是$1
$还是$0 $来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">ll ak=a[i+k];</span><br><span class="line">a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5>
<p>由于FFT中的单位根会产生精度误差,因此在膜$998244353
$意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为$g <span class="math inline">\(,\)</span>g _n = g ^{ { n } } \
$,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol type="1">
<li><p>$g _n ^n = g _n ^0 = 1 <span class="math inline">\(且\)</span> i
&lt; j &lt; n , g _n ^i g _n ^j $,证明由原根的性质.</p></li>
<li><p>折半引理:$g <em>{ 2 n } ^{ 2 k } = g </em>{ n } ^k
$,证明显然.</p></li>
<li><p>消去引理:$g _{ n } ^{ k + { 2 } } = - g ^k _n \ <span class="math inline">\(.由于\)</span>g ^{ { 2 } } = - 1
$,该结论显然成立.</p></li>
</ol>
<p>由上我们证明了,我们完全可以使用$g _n <span class="math inline">\(代替\)</span>_n $进行变换.</p>
<p>另外,注意到$998244352 = 2 ^{ 23 } \ $,而$2 ^{ 23 } ^6 \ <span class="math inline">\(.因而,当\)</span>n ^6 <span class="math inline">\(的时候,\)</span>g _n
$可以直接求出.这也是为什么大部分NTT题目都使用$998244353
$作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5>
<p>范德蒙德矩阵形如:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; \alpha _1 &amp; \cdots &amp; \alpha _1 ^{ n - 1  } \\
1 &amp; \alpha _2 &amp; \cdots &amp; \alpha _2 ^{ n - 1  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \alpha _m &amp; \cdots &amp; \alpha _m ^{ n - 1  }
\end{bmatrix} \in \mathbb { R  } ^{ m \times n  }
\]</span></p>
<p>如果取单位根,我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega _n ^1 &amp; \cdots &amp; \omega _2 ^{ n - 1  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega _n ^{ n - 1  } &amp; \cdots &amp; \omega _n ^{ ( n - 1 )
^2  }
\end{bmatrix} \in \mathbb { R  } ^{ n \times n  }
\]</span></p>
<p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega _n ^1 &amp; \cdots &amp; \omega _2 ^{ n - 1  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega _n ^{ n - 1  } &amp; \cdots &amp; \omega _n ^{ ( n - 1 )
^2  }
\end{bmatrix} ^{ - 1  } = \frac { 1  } { n  } \begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega _n ^{ - 1  } &amp; \cdots &amp; \omega _2 ^{ - ( n - 1
)  } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega _n ^{ - ( n - 1 )  } &amp; \cdots &amp; \omega _n ^{ - (
n - 1 ) ^2  }
\end{bmatrix}
\]</span></p>
<h4><span id="分治fft">分治FFT</span></h4>
<p>给定$g ( x ) <span class="math inline">\(和\)</span>f ( 0 ) <span class="math inline">\(,求\)</span>f ( x ) = _{ y = 1 } ^x f ( x - y ) g
( y ) $,答案对$998244353 $取膜.</p>
<p>考虑分治,假如我们已经知道了$f ( x ) , x <span class="math inline">\(.那我们可以计算出这段部分对\)</span>f ( y ) ， y
$的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算$f <span class="math inline">\(和\)</span>g $的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4>
<p>对于多项式$P ( x ) <span class="math inline">\(,找到\)</span>Q ( x )
<span class="math inline">\(使得\)</span>Q ( x ) P ( x ) \ <span class="math inline">\(.显然\)</span>Q ( x ) $是唯一的.</p>
<p>首先不妨设$n = 2 ^k \ $.</p>
<p>如果我们已知$P ( x ) Q <em>{ k - 1 } ( x ) \ <span class="math inline">\(,同时肯定有\)</span>P ( x ) Q </em>{ k } ( x ) \
<span class="math inline">\(,相减得到\)</span>Q <em>k ( x ) - Q </em>{ k
- 1 } ( x ) \ $.</p>
<p>两边平方:</p>
$$
<span class="math display">\[\begin{aligned}
Q _k ^2 ( x ) + Q ^2 _{ k - 1  } ( x ) - 2 Q _k ( x ) Q _{ k - 1  } ( x
) &amp; \equiv 0 \pmod { x ^{ 2 ^k  }  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边乘一下$P ( x ) $:</p>
$$
<span class="math display">\[\begin{aligned}
Q _k ( x ) - 2 Q _{ k - 1  } ( x ) + P ( x ) Q _{ k - 1  } ^2 ( x )
&amp; \equiv 0 \pmod { x ^n  } \\
Q _k ( x ) &amp; \equiv 2 Q _{ k - 1  } ( x ) - P ( x ) Q _{ k - 1  } ^2
( x ) \pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据主定理，这么做复杂度是$O ( n _2 n ) $的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; \equiv F ( x ) G ( x ) + f _0 \pmod { x ^{ n + 1  }  } \\
F ( x ) &amp; = \frac { f ( 0 )  } { 1 - G ( x )  } \pmod { x ^{ n +
1  }  }
\end{aligned}
\]</span></p>
<p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4>
<p>对于$n <span class="math inline">\(次多项式\)</span>F ( x ) <span class="math inline">\(和\)</span>m <span class="math inline">\(次多项式\)</span>G ( x ) <span class="math inline">\(,找到\)</span>Q ( x ) , R ( x ) <span class="math inline">\(使得\)</span>F ( x ) = G ( x ) Q ( x ) + R ( x ) \
$.</p>
<p>考虑对于$n <span class="math inline">\(次多项式\)</span>F ( x ) <span class="math inline">\(,令\)</span>F _R ( x ) = x ^n F ( { x } ) <span class="math inline">\(,如果设\)</span>f _i <span class="math inline">\(为其\)</span>x ^i <span class="math inline">\(项前的系数,不难发现\)</span>f _R ( i ) = f ( n - i
) $.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; = G ( x ) Q ( x ) + R ( x ) \\
F ( \cfrac { 1  } { x  } ) &amp; = G ( \cfrac { 1  } { x  } ) Q ( \cfrac
{ 1  } { x  } ) + R ( \cfrac { 1  } { x  } ) \\
x ^n F ( \cfrac { 1  } { x  } ) &amp; = x ^m G ( \cfrac { 1  } { x  } )
x ^{ n - m  } Q ( \cfrac { 1  } { x  } ) + x ^{ n - m + 1  } x ^{ m -
1  } R ( \cfrac { 1  } { x  } ) \\
F _R ( x ) &amp; = G _R ( x ) Q _R ( x ) + x ^{ n - m + 1  } R _R ( x )
\\
F _R ( x ) &amp; \equiv G _R ( x ) Q _R ( x ) \pmod { x ^{ n - m +
1  }  } \\
Q _R ( x ) &amp; \equiv F _R ( x ) G _R ^{ - 1  } ( x ) \pmod { x ^{ n -
m + 1  }  }
\end{aligned}
\]</span></p>
<p>于是只要做一遍多项式求逆即可求得$Q ( x ) <span class="math inline">\(,再做一遍相减既可以得到\)</span>R ( x ) $.</p>
<h4><span id="多项式ln">多项式ln</span></h4>
<p>给出$n - 1 <span class="math inline">\(次多项式\)</span>A ( x ) <span class="math inline">\(,求一个多项式\)</span>B ( x ) <span class="math inline">\(,满足\)</span>B ( x ) A ( x ) $.</p>
<p>我们有:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \ln A ( x ) \pmod { x ^n  } \\
B &#39; ( x ) &amp; \equiv \cfrac { A &#39; ( x )  } { A ( x )  } \pmod
{ nx ^{ n - 1  }  } \\
B ( x ) &amp; \equiv \int \cfrac { A &#39; ( x )  } { A ( x )  } dx
\pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当$[ x ^0 ] f ( x ) = 1 <span class="math inline">\(的时候,\)</span>f ( x ) $有对数多项式.</p>
<p>我们对最后再做一步:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \int _0 ^x \cfrac { A &#39; ( t )  } { A ( t )  }
dt + B ( 0 ) \pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>首先$B ( 0 ) = A ( 0 ) = a _0 <span class="math inline">\(,如果\)</span>a _0 a _0 <span class="math inline">\(,则\)</span>B ( 0 )
$,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若$[ x ^0 ] f ( x ) = 1 <span class="math inline">\(的时候,\)</span>B
( 0 ) = 0 $,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>给定多项式$G ( x ) <span class="math inline">\(,求一个多项式\)</span>F ( x ) <span class="math inline">\(满足\)</span>G ( F ( x ) ) $.</p>
<p>首先$n = 1 <span class="math inline">\(的时候,也就是求\)</span>G ( F
( x ) ) $.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在$x ^{ { 2 } } <span class="math inline">\(意义下的答案\)</span>F _0 ( x ) <span class="math inline">\(,我们考虑在\)</span>F _0 ( x ) $处做泰勒展开:</p>
$$
<span class="math display">\[\begin{aligned}
G ( F ( x ) ) &amp; = \sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k
)  } ( F _0 ( x ) )  } { k !  } ( F ( x ) - F _0 ( x ) ) ^k &amp; \equiv
0 \pmod { x ^n  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑$F ( x ) - F _0 ( x ) <span class="math inline">\(,由于\)</span>F
_0 ( x ) F ( x ) <span class="math inline">\(,因此,因此\)</span>( F ( x
) - F _0 ( x ) ) ^2 $.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ k = 0  } ^{ + \infty  } \frac { G ^{ ( k )  } ( F _0 ( x ) )  }
{ k !  } ( F ( x ) - F _0 ( x ) ) ^k &amp; \equiv 0 \pmod { x ^n  } \\
G ( F _0 ( x ) ) + G &#39; ( F _0 ( x ) ) ( F ( x ) - F _0 ( x ) ) &amp;
\equiv 0 \pmod { x ^n  } \\
F ( x ) &amp; \equiv F _0 ( x ) - \frac { G ( F _0 ( x ) )  } { G &#39;
( F _0 ( x ) )  } \pmod { x ^n  }
\end{aligned}
\]</span></p>
<p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4>
<p>给定$h ( x ) <span class="math inline">\(,设\)</span>g ( f ( x ) ) =
f ^2 ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
f ( x ) \equiv f _0 ( x ) - \frac { f ^2 ( x ) - h ( x )  } { 2 f _0 ( x
)  } \equiv \frac { f ^2 ( x ) + h ( x )  } { 2 f _0 ( x )  } \pmod { x
^n  }
\]</span></p>
<p>还没完,用牛顿迭代前一定要求$g ( a ) <span class="math inline">\(的解,也就是\)</span>[ x ^0 ] h ( x )
$的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4>
<p>给定$h ( x ) <span class="math inline">\(,设\)</span>g ( f ( x ) ) =
f ( x ) - h ( x ) $,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; \equiv f _0 ( x ) - \frac { \ln f _0 ( x ) - h ( x )  } {
\frac { 1  } { f _0 ( x )  }  } \pmod { x ^n  } \\
&amp; \equiv f _0 ( x ) ( 1 - \ln f _0 ( x ) + h ( x ) ) \pmod { x ^n  }
\end{aligned}
\]</span></p>
<p>还没完,还需要求$g ( a ) <span class="math inline">\(的解,注意到存在\)</span><span class="math inline">\(当且仅当\)</span>[ x ^0 ] g ( x ) <span class="math inline">\(,此时\)</span>f ( x ) $.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4>
<p>求$<span class="math inline">\(后求\)</span><span class="math inline">\(即可,唯一的问题是为什么指数可以对\)</span>p
$取膜.</p>
<p>我们有一个结论:</p>
<p><span class="math display">\[
f ( x ^p ) \equiv f ( x ) ^p \pmod { p  }
\]</span></p>
<p>这个结论很简单,注意到$( a + b ) ^p a ^p + b ^p $即可.</p>
<p>而又由于$n &lt; p <span class="math inline">\(,因此\)</span>f ( x )
^p f ( 0 ) <span class="math inline">\(,通常取\)</span>f ( 0 ) = 1 <span class="math inline">\(,于是就可以直接对\)</span>p $取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4>
<p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做$<span class="math inline">\(的时候的直接数组传参,会导致\)</span><span class="math inline">\(的复杂度退化到\)</span>O ( n ^2 n ) $.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">ll x[qwq];</span><br><span class="line"><span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">ll ak=(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">x.k=k;</span><br><span class="line">x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">y.x[i]=x*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">y.limit=x.limit;y.k=x.k;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">tmp_inv.x[i]=x.x[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">tmp_inv.k=q_inv.k=k;</span><br><span class="line">q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line"><span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line"><span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">x.limit=lim,x.k=k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">tmp_exp.k=q_exp.k=k;</span><br><span class="line">q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_exp;</span><br><span class="line">&#125;</span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3>
<p>集合幂级数形如$_{ i = 0 } ^{ 2 ^n - 1 } a _i x ^i <span class="math inline">\(,其中二进制数\)</span>i <span class="math inline">\(表示\)</span>{ 1 , 2 , . . . , n } <span class="math inline">\(的一个子集,用\)</span>| i |
$表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4>
<p>高维前缀和:$c <em>i = </em>{ j i } a _j \ $.</p>
<p>高维后缀和:$c <em>i = </em>{ j i } a _j \ $.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:$c <em>i = </em>{ j } _{ k } [ j k = i ] a _j b _k \ $.</p>
<p>与卷积:$c <em>i = </em>{ j } _{ k } [ j k = i ] a _j b _k \ $.</p>
<p>二者求法类似,考虑如何求$a <span class="math inline">\(和\)</span>b
$的或卷积:</p>
<p>引理:</p>
<p>若$j , k i <span class="math inline">\(,则\)</span>j k i
$,逆命题同样成立.</p>
<p>若$j , k i <span class="math inline">\(,则\)</span>j k i
$,逆命题同样成立.</p>
<p>设$a , b , c <span class="math inline">\(的高维前缀和分别为\)</span>A
, B , C $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A _i B _i &amp; = ( \sum _{ j \subseteq i  } a _j ) ( \sum _{ k
\subseteq i  } b _k ) \\
&amp; = \sum _{ j , k \subseteq i  } a _i b _k \\
&amp; = \sum _{ k \lor j \subseteq i  } a _i b _k \\
&amp; = C _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>现在考虑已知$C <span class="math inline">\(求\)</span>c <span class="math inline">\(,本质上是一个反演.注意到\)</span><em>{ r p } ( - 1
) ^{ | r | } = </em>{ k = 0 } ^{ | p | } C _{ | p | } ^k ( - 1 ) ^k = [
p = 0 ] \ $,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
c ( p ) &amp; = \sum _{ q \subseteq p  } [ p - q &amp; = 0 ] c ( q ) \\
&amp; = \sum _{ q \subseteq p  } \sum _{ r \subseteq ( p - q )  } ( - 1
) ^{ | r |  } c ( q ) \\
&amp; = \sum _{ r \subseteq p  } ( - 1 ) ^{ | r |  } \sum _{ q \subseteq
( p - r )  } c ( q ) \\
&amp; = \sum _{ r \subseteq p  } ( - 1 ) ^{ r  } C ( p - r ) \\
&amp; = \sum _{ r \subseteq p  } ( - 1 ) ^{ | p | - | r |  } C ( r ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是有$c ( S ) = _{ T S } ( - 1 ) ^{ | S | - | T | } C ( T ) \
$(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度$O ( 2 ^n n ) $.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4>
<p>异或卷积:$c _i = _j _k [ j k = i ] a _j b _k \ $.</p>
<p>引理:$( i j ) k = ( i k ) ( j k ) $.</p>
<p>证明的话考虑如果$k = 0 <span class="math inline">\(,二者显然相等;当\)</span>k = 1 <span class="math inline">\(的时候,左右都等价于\)</span>( i j ) $.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数$FWT ( a ) <span class="math inline">\(,满足\)</span>FWT ( a ) <em>i = </em>{ j = 0 } ^{
2 ^n - 1 } ( - 1 ) ^{ | i j | } a _j \ $.</p>
<p>那么有:</p>
$$
<span class="math display">\[\begin{aligned}
FWT ( c ) _i &amp; = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i
\land j |  } c _j \\
&amp; = \sum _{ j = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | i \land j |  } \sum
_{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  } [ k \oplus l
&amp; = j ] a _k b _l \\
&amp; = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  }
( - 1 ) ^{ | ( k \oplus l ) \land i |  } a _k b _l \\
&amp; = \sum _{ k = 0  } ^{ 2 ^n - 1  } \sum _{ l = 0  } ^{ 2 ^n - 1  }
( - 1 ) ^{ | k \land i |  } a _k ( - 1 ) ^{ | l \land i |  } b _l \\
&amp; = FWT ( a ) _i FWT ( b ) _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>时间复杂度$O ( 2 ^n n ) $.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的$ { 2 }
$都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4>
<h5><span id="线性代数角度">线性代数角度</span></h5>
<p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换$FWT $,使得</p>
<ol type="1">
<li><p>若$c <em>i = </em>{ j k } a _j b _k <span class="math inline">\(,则\)</span>FWT ( c ) = FWT ( a ) FWT ( b )
$.</p></li>
<li><p>这个线性变换是可逆的.</p></li>
<li><p>做这个线性变换和其逆变换的复杂度都可以接受.</p></li>
</ol>
<p>我们设$FWT ( A ) <em>i = </em>{ j } w ( i , j ) A _j <span class="math inline">\(,我们想要做的就是构造一组满足上述条件的\)</span>w
$.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( C ) _i &amp; = FWT ( A ) _i FWT ( B ) _i \\
\sum _{ j  } w ( i , j ) C _j &amp; = \sum _{ j , k  } w ( i , j ) w ( i
, k ) A _j B _k
\end{aligned}
\]</span></p>
<p>再考虑:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; = A * B \\
C _i &amp; = \sum _{ k \oplus l = i  } A _k B _l \\
\sum _{ j  } w ( i , j ) C _j &amp; = \sum _j w ( i , j ) \sum _{ k
\oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k &amp; = \sum _j w ( i
, j ) \sum _{ k \oplus l = j  } A _k B _l \\
\sum _{ j , k  } w ( i , j ) w ( i , k ) A _j B _k &amp; = \sum _{ j ,
k  } A _j B _k w ( i , j \oplus k )
\end{aligned}
\]</span></p>
<p>比较两边系数,有$w ( i , j ) w ( i , k ) = w ( i , j k )
$.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于$<span class="math inline">\(是集合的运算,我们可以对二进制分开考虑.换句话说,如果\)</span>a
= _{ i = 0 } a <em>i 2 ^i , b = </em>{ i = 0 } b <em>i 2 ^i <span class="math inline">\(,那么\)</span>w ( a , b ) = </em>{ i = 0 } w ( a
_i , b _i ) $一定是满足条件的.</p>
<p>这样我们就可以只求一个$2 <span class="math inline">\(的线性变换矩阵就好.我们接下来将对三种常见的基础位运算(\)</span>,
, xor ( ) <span class="math inline">\()分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出\)</span>FWT
( a ) $呢?</p>
<p>考虑和FFT一样折半,令$i _0 <span class="math inline">\(为\)</span>i
$的最高位是否是$1 <span class="math inline">\(,\)</span>i ’ <span class="math inline">\(为\)</span>i <span class="math inline">\(去掉最高位后的二进制数字,令\)</span>n = 2 ^m
$我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) _i &amp; = \sum _{ j = 0  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
&amp; = \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i , j ) A _j + \sum
_{ j = 2 ^{ m - 1  }  } ^{ 2 ^m - 1  } w ( i , j ) A _j \\
&amp; = w ( i _0 , 0 ) \sum _{ j = 0  } ^{ 2 ^{ m - 1  } - 1  } w ( i
&#39; , j &#39; ) A _j + w ( i _0 , 1 ) \sum _{ j = 2 ^{ m - 1  }  } ^{
2 ^m - 1  } w ( i &#39; , j &#39; ) A _j
\end{aligned}
\]</span></p>
<p>这样就实现了规模减半,复杂度$O ( mn ) $.</p>
下面我们设FWT的变换矩阵为$
<span class="math display">\[\begin{bmatrix}w ( 0 , 0 ) &amp; w ( 0 , 1
) \\ w ( 1 , 0 ) &amp; w ( 1 , 1 ) \end{bmatrix}\]</span>
<p>$.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6>
取矩阵$
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ 1 &amp; 1
\end{bmatrix}\]</span>
<span class="math inline">\(.其逆矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}1 &amp; 0 \\ - 1 &amp; 1
\end{bmatrix}\]</span>
<p>$.</p>
<h6><span id="与卷积">与卷积</span></h6>
取矩阵$
<span class="math display">\[\begin{bmatrix}1 &amp; 1 \\ 0 &amp; 1
\end{bmatrix}\]</span>
<span class="math inline">\(.其逆矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}1 &amp; - 1 \\ 0 &amp; 1
\end{bmatrix}\]</span>
<p>$.</p>
<h6><span id="异或卷积">异或卷积</span></h6>
取矩阵$
<span class="math display">\[\begin{bmatrix}1 &amp; 1 \\ 1 &amp; - 1
\end{bmatrix}\]</span>
<span class="math inline">\(.其逆矩阵为\)</span>
<span class="math display">\[\begin{bmatrix}\frac { 1  } { 2  } &amp;
\frac { 1  } { 2  } \\ \frac { 1  } { 2  } &amp; - \frac { 1  } { 2  }
\end{bmatrix}\]</span>
<p>$.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5>
<p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:$x ^S x ^T = x ^{ S T }
$,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) _S &amp; = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ | S
\land T |  } a _T \\
IFWT ( A ) _S &amp; = \frac { 1  } { 2 ^n  } FWT ( A ) _S
\end{aligned}
\]</span></p>
<p>这等价于:</p>
<p><span class="math display">\[
\begin{aligned}
[ x ^S ] FWT ( A ) &amp; = \sum _{ T = 0  } ^{ 2 ^n - 1  } ( - 1 ) ^{ |
S \land T |  } a _T \\
[ x ^S ] IFWT ( A ) &amp; = [ x ^S ] \frac { 1  } { 2 ^n  } FWT ( A )
\end{aligned}
\]</span></p>
<h4><span id="子集卷积">子集卷积</span></h4>
<p>子集卷积:$c <em>i = </em>{ j } _{ k } [ j k = , j k = i ] a _j b _k \
$.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些$[ j k ] <span class="math inline">\(的答案,而\)</span>[ j k = , j k = i ] = [ | j | +
| k | = | i | , j k = i ] \ $.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再$n ^2 <span class="math inline">\(次结合,并做IFMT,最终将结果累计,复杂度\)</span>O (
2 ^n n ^2 ) $.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4>
<p>其实就是设$g _{ i , j } = z ^i f _j $,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1agc034f-rng-andxor">Example1([AGC034F] RNG and
XOR)</span></h5>
<p>设$f _i ( n ) <span class="math inline">\(表示操作\)</span>n <span class="math inline">\(次后第一次变成\)</span>i <span class="math inline">\(的概率,\)</span>g _i ( n ) <span class="math inline">\(表示操作\)</span>n <span class="math inline">\(次后变成\)</span>i <span class="math inline">\(的概率.\)</span>F , G $分别是其生成函数.</p>
<p>注意到$G _i = F _i G _0 , F _i = { G _0 } <span class="math inline">\(,而\)</span>F _i ’ ( 1 ) <span class="math inline">\(就是期望.接下来的问题在于如何求\)</span>G $.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把$a _i { a } <span class="math inline">\(,然后做\)</span>A = FWT ( a ) <span class="math inline">\(,注意这里\)</span>A _0 = a = 1 <span class="math inline">\(,FWT自身有很好的性质:\)</span>a = { 2 ^N } FWT ( A
) <span class="math inline">\(.我们做\)</span>n <span class="math inline">\(次操作后得到的概率数组也就是\)</span> { 2 ^N } FWT
( A ^n ) $.展开FWT的式子,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g _i ( n ) &amp; = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land
j |  } A _j ^n x ^n \\
G _i &amp; = \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j |  }
\frac { 1  } { 1 - A _j x  } \\
F _i &amp; = \frac { G _i  } { G _0  } \\
F _i &#39; &amp; = \frac { G _i &#39; G _0 - G _0 &#39; G _i  } { G _0
^2  } \\
&amp; = \frac { ( \sum _{ j = 0  } ^{ 2 ^N - 1  } ( - 1 ) ^{ | i \land j
|  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N
- 1  } \frac { 1  } { 1 - A _j x  } ) - ( \sum _{ j = 0  } ^{ 2 ^N -
1  } \frac { A _j  } { ( 1 - A _j x ) ^2  } ) ( \sum _{ j = 0  } ^{ 2 ^N
- 1  } ( - 1 ) ^{ | i \land j |  } \frac { 1  } { 1 - A _j x  } )  } { (
\sum _{ j = 0  } ^{ 2 ^N - 1  } \frac { 1  } { 1 - A _j x  } ) ^2  }
\end{aligned}
\]</span></p>
<p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求$F ’ _i (
1 ) <span class="math inline">\(,因此我们直接把\)</span>x = 1 <span class="math inline">\(带入算一算就好.不过由于\)</span>A _0 = 1
$,我们必须要解决分母为$0 <span class="math inline">\(的情况,解决的方法是分母乘上\)</span>( 1 - x )
<span class="math inline">\(,这样就消掉了\)</span>j = 0
$的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5>
<p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边$u
v <span class="math inline">\(就异或上\)</span>( 2 ^u + 2 ^v )
$.最后要求这个二进制数是$0 <span class="math inline">\(.我们用一个二元组\)</span>( a , F ) <span class="math inline">\(表示在集合幂级数上异或上\)</span>a <span class="math inline">\(,在多项式上乘上\)</span>F <span class="math inline">\(.显然一条边是\)</span>( 0 , 1 ) + ( 2 ^u + 2 ^v ,
x )
$.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上$1
+ x $要么乘上$1 - x <span class="math inline">\(,做完FWT得到的每一个\)</span>FWT _i <span class="math inline">\(一定形如\)</span>( 1 + x ) ^k ( 1 - x ) ^{ m - k }
<span class="math inline">\(,做IFWT的时候直接求\)</span> { 2 ^N } ( 1 +
x ) ^k ( 1 - x ) ^{ m - k } $即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:$(
0 , 1 ) <span class="math inline">\(和\)</span>( 2 ^u + 2 ^v , x )
$,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个$i <span class="math inline">\(求\)</span>k <span class="math inline">\(,也就是对于每个\)</span>i <span class="math inline">\(求有多少条边满足\)</span>| i ( 2 ^u + 2 ^v ) | = 1
<span class="math inline">\(,也就是求有多少条边一段链接在了\)</span>i
$的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-cloves-3-iii">Example3(CF1034E Little C
Loves 3 III)</span></h5>
<p>仍然是子集卷积,转化为$c <em>i = </em>{ j } _{ k } [ | j | + | k | = |
i | , j k = i ] a _j b _k \ <span class="math inline">\(.然后我们将\)</span>a _j $乘上$4 ^j <span class="math inline">\(,将\)</span>b _k $乘上$4 ^k <span class="math inline">\(,最后把\)</span>c _i $除去$4 ^i $对$4
$取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2chiori-and-doll-picking">Example4(CF1336E2
Chiori and Doll Picking)</span></h5>
<p>先考虑easy version.首先求出线性基,如果线性基的大小$k
$比较小,我们可以直接$2 ^k
$枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个$1
<span class="math inline">\(取决于选了多少个元素,其他位置共有\)</span>m
- k <span class="math inline">\(个,可以直接状压进状态.这样复杂度就是\)</span>O ( {
2 ^k , m ^2 2 ^{ m - k } } ) $.</p>
<p>那么我们怎么优化呢?首先$k $较大的时候有点难做,我们看看能不能优化到$2
^{ m - k } $.</p>
<p>考虑设$f _i ^c = [ | i | = c ] <span class="math inline">\(,将线性基能做出的线性空间设为\)</span>A <span class="math inline">\(,\)</span>A _S = 1 <span class="math inline">\(当且仅当线性基能异或出\)</span>S <span class="math inline">\((最后再把那些废元素贡献到答案里).那么\)</span>popcount
= c <span class="math inline">\(的答案就是\)</span>IFWT ( FWT ( F ) FWT
( A ) ) _0 <span class="math inline">\(.考虑\)</span>IFWT <em>0 = { 2 ^m
} </em>{ i = 0 } ^{ 2 ^m - 1 } FWT ( F ) _i FWT ( A ) _i
$,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:$FWT ( A ) $要么是$2 ^k $,要么是$0 $.</p>
<p>考虑:</p>
<p><span class="math display">\[
A * A = A \times 2 ^k
\]</span></p>
<p>这句是为啥呢?因为对于右边的每一个数字$x <span class="math inline">\(和左边的一个数字\)</span>y <span class="math inline">\(,如果它们都在线性基中,一定存在一个数字\)</span>z
<span class="math inline">\(满足\)</span>y z = x $,不然就是$0 $.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) _i \cdot FWT ( A ) _i &amp; = FWT ( A ) _i \times 2 ^k \\
FWT ( A ) _i &amp; = 0 \lor 2 ^k
\end{aligned}
\]</span></p>
<p>引理2:$FWT ( A ) _i = 2 ^k x , A _x , | i x | $.</p>
<p>直接展开上面的式子,用$_{ S T } ( - 1 ) ^{ | S | } = [ T = ] $.</p>
<p>引理3:$FWT ( A ) $中值为$2 ^k $的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果$i <span class="math inline">\(满足条件,\)</span>j <span class="math inline">\(满足条件,一开始做FWT时我们已经注意到:\)</span>( i
j ) x = ( i x ) ( j x ) $.于是这个引理也显然成立.</p>
<p>引理4:$FWT ( A ) $中值为$2 ^k <span class="math inline">\(的位置构成的线性基的大小是\)</span>m - k $.</p>
<p>设这些位置构成的空间是$B <span class="math inline">\(,\)</span>B _S =
1 <span class="math inline">\(当且仅当\)</span>S
$在这个空间中.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) &amp; = B \times 2 ^k \\
A &amp; = IFWT ( B ) \times 2 ^k
\end{aligned}
\]</span></p>
<p>注意到$a _0 = 1 <span class="math inline">\(,也就是\)</span> { 2 ^m }
b = 1 , b = 2 ^{ m - k } $,这就证明了引理.</p>
<p>引理5:将$A <span class="math inline">\(的线性基对应的矩阵从前往后消成最简,\)</span>B
<span class="math inline">\(的线性基对应的矩阵从后往前消成最简,上\)</span>A
<span class="math inline">\(下\)</span>B <span class="math inline">\(拼成一个\)</span>m m
$的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据$rank ( A ) + rank ( B ) = k + m - k = m
$可以知道主对角线一定全是$1 <span class="math inline">\(,然后我们任取\)</span>A <span class="math inline">\(中的一个基\)</span>x <span class="math inline">\(和\)</span>B <span class="math inline">\(中的一个基\)</span>y <span class="math inline">\(,应该有\)</span>| x y |
$.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由$A <span class="math inline">\(得知\)</span>B
$长什么样.</p>
<p>引理6:$FWT ( F ^c ) _i <span class="math inline">\(只和\)</span>| i |
$有关.</p>
<p>因为$F ^c <em>i <span class="math inline">\(只和\)</span>| i | <span class="math inline">\(有关,这里考虑一下对称性就可以.因此设\)</span>w
</em>{ d } ^c = FWT ( F ^c ) _i , | i | = d $.</p>
<p>然后注意到$w <em>d ^c = </em>{ i = 0 } ^{ 2 ^m - 1 } ( - 1 ) ^{ | i (
2 ^d - 1 ) | } [ | i | = c ] $.组合意义展开一下:</p>
<p><span class="math display">\[
w _d ^c = \sum _{ j = 0  } ^{ d  } ( - 1 ) ^{ j  } \binom { d  } { j  }
\binom { m - d  } { c - j  }
\]</span></p>
<p>接下来怎么做呢?令$g <em>d = </em>{ i = 0 } ^{ 2 ^m - 1 } [ A _i = 1 ]
[ | i | = d ] <span class="math inline">\(,这里可以\)</span>O ( 2 ^{ m -
k } ) $,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5>
<p>首先发现”如果没有边那么是$0 $“这个限制太强了,如果我们能改为”如果是$0
$,那么可有边可无边”的话,整个序列就会被$1 <span class="math inline">\(的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设\)</span>g
_{ len , S } <span class="math inline">\(表示长度为\)</span>len <span class="math inline">\(,一段长度为\)</span>len - 1 $的连续的$1 <span class="math inline">\(对应的集合是\)</span>S
$的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个$0
$).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5>
<p>首先可以类似数位dp设计一个$dp _{ i , S } <span class="math inline">\(表示目前dp到了第\)</span>i <span class="math inline">\(位,然后前面的\)</span>limit <span class="math inline">\(是\)</span>S $.接下来分类讨论当前的最大值限制是$1
$还是$0 $.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2>
<h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3>
<h4><span id="概念">概念</span></h4>
<p>我们定义一个幂级数形如$A ( z ) = _{ k } a _k z ^k <span class="math inline">\(,并使\)</span>[ z ^n ] A ( z ) = a _n <span class="math inline">\(.则称\)</span>A ( z ) <span class="math inline">\(是\)</span>a _0 , a _1 , . . . $的生成函数.</p>
<h4><span id="运算">运算</span></h4>
<ol type="1">
<li><p>$A ( z ) + B ( z ) = _{ n } ( f _n + g _n ) z ^n $.</p></li>
<li><p>$z ^m A ( z ) = <em>{ n } g </em>{ n } z ^{ n + m } = <em>{ n m }
g </em>{ n - m } z ^n $.</p></li>
<li><p>$A ( cz ) = _{ n } c ^n f _n z ^n $.</p></li>
<li><p>$A ’ ( z ) = _{ n } ig _i z ^{ i - 1 } $.</p></li>
<li><p>$A ( z ) dz = _{ n } { n + 1 } g _n z ^{ n + 1 } $.</p></li>
<li><p>$A ( z ) B ( z ) = <em>{ n } ( </em>{ k = 0 } ^n f <em>k g </em>{
n - k } ) z ^n $.</p></li>
<li><p>$ { 1 - z } A ( z ) = <em>{ n } ( </em>{ k = 0 } ^n g _k ) z ^n
$.</p></li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4>
<ol type="1">
<li>$ { 1 - z } = <em>{ k } z ^k \ <span class="math inline">\(,\)</span> { 1 - cz } = </em>{ k } c ^k z ^k \
$.</li>
</ol>
<p>证明显然.</p>
<ol start="2" type="1">
<li>$( 1 + z ) ^r = <em>{ k } { k } z ^k \ <span class="math inline">\(,\)</span>( 1 - z ) ^r = </em>{ k } ( - 1 ) ^k { k
} z ^k \ $.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol start="3" type="1">
<li>$ { 1 - z ^m } = _{ n } [ n | m ] z ^n \ $.</li>
</ol>
<p>证明显然.</p>
<ol start="4" type="1">
<li>$ { ( 1 - z ) ^{ n + 1 } } = <em>{ k } { n } z ^k , n \ <span class="math inline">\(,\)</span> { ( 1 - z ) ^{ n + 1 } } = </em>{ k } {
n } z ^k , n \ $</li>
</ol>
<p>直接使用二项式定理展开$( 1 - z ) ^{ - n - 1 } $,可以得到:</p>
<p><span class="math display">\[
( 1 - z ) ^{ - n - 1  } = \sum _{ k \geq 0  } ( - 1 ) ^k \binom { - n -
1  } { k  } z ^k
\]</span></p>
<p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { 1  } { ( 1 - z ) ^2  } &amp; = \sum _{ n \geq 0  } ( n + 1 ) z
^n \\
\cfrac { z  } { ( 1 - z ) ^2  } &amp; = \sum _{ n \geq 0  } nz ^n
\end{aligned}
\]</span></p>
<p>根据$( 1 ) $求导即可得到此式.</p>
<ol start="5" type="1">
<li><p>$e ^z = _{ k } { k ! } \ $.</p></li>
<li><p>$( { 1 - z } ) = _{ n } { n } z ^n $.</p></li>
<li><p>$( 1 + z ) = _{ k } ( - 1 ) ^k { k + 1 } \ $.</p></li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol start="8" type="1">
<li>$ { 2 x } = _{ k } { k + 1 } x ^k $.</li>
</ol>
<p>也即卡特兰数$C _k $的生成函数,证明考虑:</p>
<p><span class="math display">\[
xC ^2 + 1 = C
\]</span></p>
<p>然后得到两个根,带入$x = 0 $舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3>
<p>https://zhuanlan.zhihu.com/p/53079223</p>
<p>序列${ a } <span class="math inline">\(的指数生成函数定义为形式幂级数\)</span>F ( x ) = a
_n { n ! } <span class="math inline">\(.注意\)</span>[ x ^n ] F ( x ) =
a _n $.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) \hat G ( x ) &amp; = \sum _{ j \geq 0  } a _j \frac { x
^j  } { j !  } \sum _{ k \geq 0  } b _k \frac { x ^k  } { k !  } \\
&amp; = \sum _{ k \geq 0  } x ^k \sum _{ j = 0  } ^k a _j b _{ k - j  }
\frac { k !  } { j ! ( k - j ) !  } \frac { 1  } { k !  } \\
&amp; = \sum _{ k \geq 0  } \frac { x ^k  } { k !  } \sum _{ j = 0  } ^k
a _j b _{ k - j  } \binom { k  } { j  }
\end{aligned}
\]</span></p>
<p>即$_{ i = 0 } ^n { i } a <em>i b </em>{ n - i } $的EFG.</p>
<p>注意到有一个特例是$x F ( x ) <span class="math inline">\(就是\)</span> { n - 1 } a _i $的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li>$e ^x = _{ k } { k ! } $</li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol start="2" type="1">
<li>$e ^{ px } = _{ k } p ^k { k ! } $</li>
</ol>
<p>换元后可以得到.一个经典特例是$e ^{ - x } = _{ k } ( - 1 ) ^k { k ! }
$.</p>
<ol start="3" type="1">
<li>$ { 2 } = _{ k } [ 2 | k ] { k ! } $.</li>
</ol>
<p>显然.</p>
<ol start="4" type="1">
<li>$( 1 + x ) ^n = _{ k } n ^{ } { k ! } $.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol start="5" type="1">
<li><p>$( 1 + x ) = _{ k } ( - 1 ) ^{ k - 1 } ( k - 1 ) ! { k ! }
$.</p></li>
<li><p>$( 1 - x ) = _{ k } ( k - 1 ) ! { k ! } $.</p></li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4>
<p>我们设$F _k ( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(个有标号元素划分成\)</span>k <span class="math inline">\(个非空无序集合的情况,\)</span>f _i <span class="math inline">\(为\)</span>i <span class="math inline">\(个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和\)</span>|
S | $有关的定义在集合上的函数),有:</p>
<p><span class="math display">\[
F _k ( n ) = \frac { n !  } { k !  } \sum _{ \sum _{ i = 1  } ^k a _i =
n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a _j !  }
\]</span></p>
<p>设$ ( x ) = _{ n } f _n { n ! } $,再设:</p>
<p><span class="math display">\[
\begin{aligned}
\hat G _k ( x ) &amp; = \sum _{ n \geq 0  } F _k ( n ) \frac { x ^n  } {
n !  } \\
&amp; = \sum _{ n \geq 0  } x ^n \frac { 1  } { k !  } \sum _{ \sum _{ i
= 1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  }  } { a
_j !  } \\
&amp; = \sum _{ n \geq 0  } \frac { 1  } { k !  } \sum _{ \sum _{ i =
1  } ^k a _i = n  } \prod _{ j = 1  } ^k \frac { f _{ a _j  } x ^{ a
_j  }  } { a _j !  } \\
&amp; = \frac { 1  } { k !  } \hat F ^k ( x )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\sum _{ k \geq 0  } \hat G _k ( x ) = \exp \hat F ( x )
\]</span></p>
<p>或者直接递推:</p>
$$
<span class="math display">\[\begin{aligned}
F _k ( x ) &amp; = \sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  }
F _{ k - 1  } ( n - i ) f _i \frac { 1  } { k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{aligned}
\hat G _k ( x ) &amp; = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } F
_k ( n ) \\
&amp; = \sum _{ n \geq 0  } \frac { x ^n  } { n !  } \sum _{ i = 1  } ^{
n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n - i ) f _i \frac {
1  } { k  } \\
&amp; = \frac { 1  } { k  } \sum _{ n \geq 0  } \frac { x ^n  } { n !  }
\sum _{ i = 1  } ^{ n - k + 1  } \binom { n  } { i  } F _{ k - 1  } ( n
- i ) f _i \\
&amp; = \frac { 1  } { k  } \hat G _{ k - 1  } ( x ) \hat F ( x ) \\
&amp; = \frac { 1  } { k !  } \hat F ^k ( x )
\end{aligned}
\]</span></p>
<p>简而言之,$[ x ^n ] F ( x ) <span class="math inline">\(是将\)</span>n
<span class="math inline">\(个有标号的元素放到同一个无序集合的方案数,而\)</span>[
x ^n ] F ( x ) <span class="math inline">\(是将\)</span>n
$个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poj3734">Example1(POJ3734)</span></h5>
<p>对于红黄色砖块,其选取方案为${ 1 , 0 , 1 , 0 , } <span class="math inline">\(,对应的EGF是\)</span> { 2 } $.</p>
<p>对于蓝绿色砖块,选取方案是$e ^x $.</p>
<p>乘起来有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) &amp; = ( \frac { e ^x + e ^{ - x  }  } { 2  } ) ^2 e ^{ 2
x  } \\
&amp; = \frac { ( e ^{ 2 x  } + 2 + e ^{ - 2 x  } ) e ^{ 2 x  }  } {
4  } \\
&amp; = \frac { e ^{ 4 x  } + 2 e ^{ 2 x  } + 1  } { 4  } \\
&amp; = \frac { 1  } { 4  } + \sum _{ k \geq 0  } \frac { 4 ^i + 2 ^{ i
+ 1  }  } { 4  } \frac { x ^i  } { i !  }
\end{aligned}
\]</span></p>
<p>于是有$[ x ^n ] F ( x ) = 4 ^{ n - 1 } + 2 ^{ n - 1 } $.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5>
<p>长度为$n <span class="math inline">\(的排列数的指数生成函数是\)</span>P ( x ) = _{ n }
{ n ! } = { 1 - x } $.</p>
<p>长度为$n <span class="math inline">\(的圆排列的指数生成函数是\)</span>Q ( x ) = _{ n }
{ n ! } = { n } = - ( 1 - x ) = { 1 - x } $.</p>
<p>于是有$Q ( x ) = P ( x ) $.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5>
<p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为$1
<span class="math inline">\(的置换环,其EGF显然是\)</span>_{ n } { n } =
- ( 1 - x ) - x <span class="math inline">\(,错排数的EGF对其取\)</span>$即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5>
<p>考虑如果$n <span class="math inline">\(个点带编号的无向连通图的EGF是\)</span>F ( x )
<span class="math inline">\(,那么\)</span>n <span class="math inline">\(个点带标号无向图的EGF就是\)</span>F ( x ) <span class="math inline">\(,后者直接计数,前者对后者做一次\)</span>$就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5>
<p>求有多少个映射$f : { 1 , 2 , , n } { 1 , 2 , , n } <span class="math inline">\(满足\)</span>f f f <span class="math inline">\((共\)</span>k <span class="math inline">\(个\)</span>f <span class="math inline">\()\)</span>= f f f <span class="math inline">\((共\)</span>k - 1 <span class="math inline">\(个\)</span>f $).</p>
<p>考虑将$i f _i <span class="math inline">\(,这等价于对深度不超过\)</span>k
$的基环树(环的长度为$1 <span class="math inline">\()计数,等价于对深度不超过\)</span>k <span class="math inline">\(的有根树计数.注意到删去根节点后等价于对深度不超过\)</span>k
- 1 <span class="math inline">\(的有根树计数,因此\)</span>F <em>k ( x )
= x F </em>{ k - 1 } ( x ) $.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5>
<p>假设$k <span class="math inline">\(次操作后\)</span>a _i <span class="math inline">\(减少了\)</span>b <em>i <span class="math inline">\(,实际上要求的就是\)</span></em>{ i = 1 } ^n a
<em>i - </em>{ i = 1 } ^n ( a _i - b _i ) $.</p>
<p>考虑对所有情况下的$_{ i = 1 } ^n ( a _i - b _i ) <span class="math inline">\(求和,注意到\)</span>k <span class="math inline">\(次操作,使得\)</span>i <span class="math inline">\(出现\)</span>b <em>i <span class="math inline">\(次的方案数是\)</span> { </em>{ i = 1 } ^n b _i ! }
<span class="math inline">\(.直接设\)</span>a _j $的EGF是</p>
<p><span class="math display">\[
\begin{aligned}
\hat F _{ j  } ( x ) &amp; = \sum _{ i \geq 0  } ( a _j - i ) \frac { x
^i  } { i !  } \\
&amp; = \sum _{ i \geq 0  } a _j \frac { x ^i  } { i !  } - \sum _{ i
\geq 1  } \frac { x ^i  } { ( i - 1 ) !  } \\
&amp; = a _j e ^x - xe ^x &amp; = ( a _j - x ) e ^x
\end{aligned}
\]</span></p>
<p>答案就是$[ x ^k ] _{ j = 1 } ^n F _j ( x ) $.</p>
<h5><span id="example7">Example7</span></h5>
<h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3>
<p>对于序列$f <em>n <span class="math inline">\(,定义其DGF为\)</span> (
x ) = </em>{ i } { i ^x } <span class="math inline">\(.注意到若\)</span>f <span class="math inline">\(是积性函数,那么\)</span> ( x ) = <em>{ p prime }
</em>{ i } { p ^{ ix } } \ $.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>对于两个序列$f , g
$,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde { F  } ( x ) \tilde { G  } ( x ) &amp; = \sum _{ i  } \sum _{
j  } \frac { f ( i ) g ( j )  } { ( ij ) ^x  } \\
&amp; = \sum _{ i  } \frac { 1  } { i ^x  } \sum _{ d | i  } f ( d ) g (
\frac { i  } { d  } )
\end{aligned}
\]</span></p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li>$( x ) = [ x = 1 ] $.</li>
</ol>
<p>显然为$ ( x ) = 1 $.</p>
<ol start="2" type="1">
<li>$I ( x ) = 1 $.</li>
</ol>
<p>其封闭式是黎曼函数$( x ) $,事实上,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\zeta ( x ) &amp; = \prod _{ i \geq 1  } \frac { 1  } { i ^x  } \\
&amp; = \prod _{ p \in prime  } \sum _{ i \geq 0  } \frac { 1  } { p ^{
ix  }  } \\
&amp; = \prod _{ p \in prime  } \frac { 1  } { 1 - p ^{ - x  }  }
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li>$( n ) $.</li>
</ol>
<p>其DGF为$ ( x ) = _{ p prime } ( 1 - p ^{ - x } ) <span class="math inline">\(.注意到\)</span>( x ) ( x ) = 1 , ( x ) = { ( x )
} $.</p>
<ol start="4" type="1">
<li>$id ( n ) = n $.</li>
</ol>
<p>有$ ( n ) = <em>{ i } { i ^x } = </em>{ i } { i ^{ x - 1 } } = ( x -
1 ) $.</p>
<ol start="5" type="1">
<li>$I _k ( n ) = n ^k $.</li>
</ol>
<p><span class="math display">\[
\tilde { I _k  } ( x ) = \prod _{ i \geq 1  } \frac { 1  } { i ^{ x -
k  }  } = \zeta ( x - k )
\]</span></p>
<ol start="6" type="1">
<li>$( n ) $.</li>
</ol>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde { \Phi  } ( x ) &amp; = \prod _{ p \in prime  } ( 1 + \frac { p -
1  } { p ^x  } + \frac { p ( p - 1 )  } { p ^{ 2 x  }  } + \cdots ) \\
&amp; = \prod _{ p \in prime  } \frac { 1 - p ^{ - x  }  } { 1 - p ^{ 1
- x  }  } \\
&amp; = \tilde { \Phi  } ( x ) &amp; = \frac { \zeta ( x - 1 )  } {
\zeta ( x )  }
\end{aligned}
\]</span></p>
<p>也注意到$ ( x ) I ( x ) = ( x - 1 ) = ( x ) $.</p>
<ol start="7" type="1">
<li>$<em>k ( n ) = </em>{ d | n } d ^k $.</li>
</ol>
<p>注意到$_k ( n ) = I _k ( n ) * I _0 ( n ) <span class="math inline">\(,也就是说\)</span> ( x ) = ( x - k ) ( x ) $.</p>
<ol start="8" type="1">
<li>$u ( n ) = | ( n ) | $.</li>
</ol>
<p>$ ( n ) = { ( 2 n ) } $.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5>
<p>考虑对于$f ( n ) = n ^2 ( n ) <span class="math inline">\(构造积性函数\)</span>g ( n ) , h ( n ) <span class="math inline">\(使得\)</span>f * g = h $.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde { F  } ( x ) &amp; = \prod _{ p \in prime  } ( 1 + \sum _{ k \geq
1  } \frac { p ^{ 3 k - 1  } ( p - 1 )  } { p ^{ kx  }  } ) \\
&amp; = \prod _{ p \in prime  } \frac { 1 - p ^{ 2 - x  }  } { 1 - p ^{
3 - x  }  } &amp; = \frac { \zeta ( x - 3 )  } { \zeta ( x - 2 )  }
\end{aligned}
\]</span></p>
<p>也就是$f * I _2 = I _3 $.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3>
<p>对于复数的阶乘,我们通常定义:</p>
<p><span class="math display">\[
\cfrac { 1  } { z !  } = \lim _{ n \rightarrow + \infin  } \binom { n +
z  } { z  } n ^{ - z  }
\]</span></p>
<p>同时我们定义$( z + 1 ) = z ! <span class="math inline">\(,有:\)</span>( - z ) ! ( z ) = { ( z ) } $.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<p><span class="math display">\[
\begin{aligned}
z ^{ \underline { w  }  } &amp; = \cfrac { z !  } { ( z - w ) !  } \\
z ^{ \overline { w  }  } &amp; = \cfrac { \Gamma ( z + w )  } { \Gamma (
z )  }
\end{aligned}
\]</span></p>
<p>通过以上我们还可以有二项式系数的定义:</p>
<p><span class="math display">\[
\binom { z  } { w  } = \lim _{ \zeta \rightarrow z , \omega \rightarrow
w  } \cfrac { \zeta !  } { \omega ! ( \zeta - \omega ) !  }
\]</span></p>
<h3><span id="超几何级数">超几何级数</span></h3>
<h4><span id="超几何函数">超几何函数</span></h4>
我们定义超几何函数$F ( a _1 , . . . , a _m ; b _1 , . . . b _n ; z ) = F
(
<span class="math display">\[\begin{array}{ r |  } a _1 , . . . , a _m
\\ b _1 , . . . , b _n \end{array}\]</span>
<p>z ) = <em>{ k } { k ! </em>{ i = 1 } ^n b _i ^{ } } $.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$ { 0 } = 1 <span class="math inline">\(之类的式子,可以发现当\)</span>z = 0 <span class="math inline">\(时任意超几何函数总是\)</span>= 1 $.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0
$或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4>
<h5><span id="合流超几何函数">合流超几何函数</span></h5>
我们通常把形如$M ( a ; b ; z ) = F (
<span class="math display">\[\begin{array}{ r |  } a \\ b
\end{array}\]</span>
<p>z ) = _{ k } { b ^{ } k ! } $的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r |  } 1 \\
1
\end{array} z \right ) = e ^z
\]</span></p>
<p>也即常见生成函数中的$( 6 ) $.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5>
我们把形如$F (
<span class="math display">\[\begin{array}{ r |  } a , b \\ c
\end{array}\]</span>
<p>z ) = _{ k } { c ^{ } k ! } $的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } 1 , 1 \\ 1
\end{array}\]</span>
z ) = { 1 - z } $.</li>
</ol>
<p>即常见生成函数$( 1 ) $.</p>
<ol start="2" type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } - a , 1 \\ 1
\end{array}\]</span>
<ul>
<li>z ) = ( 1 + z ) ^a $.</li>
</ul></li>
</ol>
<p>即常见生成函数$( 2 ) $.</p>
<ol start="3" type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } a , 1 \\ 1
\end{array}\]</span>
z ) = { ( 1 - z ) ^a } $.</li>
</ol>
<p>即常见生成函数$( 4 ) $.</p>
<ol start="4" type="1">
<li>$F (
<span class="math display">\[\begin{array}{ r |  } 1 , 1 \\ 2
\end{array}\]</span>
<ul>
<li>z ) = { z } $.</li>
</ul></li>
</ol>
<p>即常见生成函数$( 7 ) $.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4>
<p>我们先考虑改写超几何级数的形式:</p>
$F (
<span class="math display">\[\begin{array}{ r |  } a _1 , . . . , a _m
\\ b _1 , . . . , b _n \end{array}\]</span>
<p>z ) = _{ k } t _k , t <em>k = { k ! </em>{ i = 1 } ^n b _i ^{ } }
$.</p>
<p>不难发现$t _0 = 1 $,而:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { t _{ k + 1  }  } { t _k  } &amp; = \cfrac { z ^{ k + 1  }  } {
z ^k  } \cfrac { k !  } { ( k + 1 ) !  } \cfrac { \prod _{ i = 1  } ^m a
_i ^{ \overline { k + 1  }  }  } { \prod _{ i = 1  } ^m a _i ^{
\overline { k  }  }  } \cfrac { \prod _{ i = 1  } ^n b _i ^{ \overline {
k  }  }  } { \prod _{ i = 1  } ^n b _i ^{ \overline { k + 1  }  }  } \\
&amp; = \cfrac { \prod _{ i = 1  } ^m ( k + a _i )  } { \prod _{ i =
1  } ^n ( k + b _i )  } \cfrac { z  } { k + 1  }
\end{aligned}
\]</span></p>
<p>换句话说,$ { t _k } <span class="math inline">\(是关于\)</span>k
<span class="math inline">\(的一个有理函数.而根据代数基本定理,任意\)</span>k
<span class="math inline">\(的有理函数在\)</span> <span class="math inline">\(内都可以分解为以上的形式(如果缺少\)</span>k + 1
<span class="math inline">\(项则需要上下同时乘以\)</span>k + 1
$以补上).</p>
<p>换句话说,对于一个无穷级数$_{ k } t _k <span class="math inline">\(,我们先将\)</span> { t _k } <span class="math inline">\(表示回超几何函数,设为\)</span>F $.</p>
<p>那么有:$_{ k } t _k = t _0 F $.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$$函数的定义)来使这些公式全部成立.But
who
cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5>
求证:$_{ k n } { k } = { n } F (
<span class="math display">\[\begin{array}{ r |  } 1 , - n \\ - n - r
\end{array}\]</span>
<p>1 ) = { r + 1 } , n \ $.</p>
<p>首先考虑:</p>
<p><span class="math display">\[
\sum _{ k \leq n  } \binom { r + k  } { k  } = \sum _{ k \geq 0  }
\binom { r + n - k  } { n - k  }
\]</span></p>
<p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<p><span class="math display">\[
\binom { r + n  } { n  } F \left ( \begin{array}
{ r |  } 1 , - n \\
- n - r
\end{array} 1 \right ) = \binom { r + n + 1  } { n  }
\]</span></p>
<p>两边同时除以$ { n } $得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5>
<p>通过范德蒙德卷积,不难验证:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r |  } a , b \\
c
\end{array} 1 \right ) = \cfrac { \Gamma ( c - a - b ) \Gamma ( c )  } {
\Gamma ( c - a ) \Gamma ( c - b )  } , - b \in \mathbb { N  }
\]</span></p>
<p>这个公式的一个特例是:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r |  } a , - n \\
c
\end{array} 1 \right ) &amp; = \cfrac { ( c - a ) ^{ \overline {
n  }  }  } { c ^{ \overline { n  }  }  } &amp; = \cfrac { ( a - c ) ^{
\underline { n  }  }  } { ( - c ) ^{ \underline { n  }  }  } , n \in
\mathbb { N  } \\
\sum _{ k \geq 0  } \cfrac { a ^{ \overline { k  }  } ( - n ) ^{
\overline { k  }  }  } { c ^{ \overline { k  }  } k !  } &amp; = \cfrac
{ ( c - a ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  }  }
&amp; = \cfrac { ( a - c ) ^{ \underline { n  }  }  } { ( - c ) ^{
\underline { n  }  }  } , n \in \mathbb { N  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r |  } a , b , - n \\
c , a + b - n - c + 1
\end{array} 1 \right ) &amp; = \cfrac { ( c - a ) ^{ \overline { n  }  }
( c - b ) ^{ \overline { n  }  }  } { c ^{ \overline { n  }  } ( c - a -
b ) ^{ \overline { n  }  }  } &amp; = \cfrac { ( a - c ) ^{ \underline {
n  }  } ( b - c ) ^{ \underline { n  }  }  } { ( - c ) ^{ \underline {
n  }  } ( a + b - c ) ^{ \overline { n  }  }  } , n \in \mathbb { N  }
\\

\end{aligned}\]</span>
<p>$$</p>
<p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3>
<h4><span id="example1luogu4931">Example1(luogu4931)</span></h4>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } \binom { n  } { i  } \binom { n  } { i  } i ! ( 2 n - 2 i ) ! 2 ^i
\\
&amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \frac { 1  } { k ! ( i -
k ) !  } \frac { n !  } { ( n - i ) !  } \frac { n !  } { ( n - i ) !  }
( 2 n - 2 i ) ! 2 ^i \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = k  } ^n ( - 1 )
^{ i - k  } \frac { 1  } { ( i - k ) !  } \binom { 2 n - 2 i  } { n -
i  } 2 ^{ i - k  } \\
&amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } \sum _{ i = 0  } ^{ n  }
\frac { ( - 2 ) ^{ i  }  } { i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到后者只与$n - k <span class="math inline">\(有关,不妨设其为\)</span>f <em>{ n } = </em>{ i = 0
} ^{ n } { i ! } { n - i } <span class="math inline">\(,预处理一下就可以做到\)</span>O ( n ^2 + nT )
$.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! ) ^2 \frac { 2 ^k  } { k !  } f _{ n - k  } \\
f _{ n  } &amp; = \sum _{ i = 0  } ^{ n  } \frac { ( - 2 ) ^{ i  }  } {
i !  } \binom { 2 n - 2 i  } { n - i  }
\end{aligned}
\]</span></p>
<p>注意到$f <span class="math inline">\(是一个卷积的形式,设其生成函数为\)</span>F _n <span class="math inline">\(,\)</span>g _n = { n ! } , h _n = { n } <span class="math inline">\(,我们自然有\)</span>F = GH $.</p>
<p>考虑$G <span class="math inline">\(和\)</span>H <span class="math inline">\(的生成函数形式,先看\)</span>G
$,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum _{ n \geq 0  } \frac { ( - 2 x ) ^n  } { n !  } = e ^{ - 2 x  }
\]</span></p>
<p>再看$H $,是卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac { 1  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! ) ^2 \frac { 2 ^k  } { k !  } [ x ^{ n - k  } ] \frac { e ^{ - 2
x  }  } { \sqrt { 1 - 4 x  }  }
\]</span></p>
<p>现在看$F $,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F ^2 = e ^{ - 4 x  }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e ^{ - 4 x  } \\
- 4 F ^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F ^2
\\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f _{ i + 1  } - 8 if _i &amp; = 16 f _{ i - 1  } \\
if _i &amp; = 4 ( i - 1 ) f _{ i - 1  } + 8 f _{ i - 2  }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3>
<h4><span id="求解递归关系">求解递归关系</span></h4>
<p>我们假设已经有了$R ( z ) = _{ k } g _k z ^k <span class="math inline">\(,并且\)</span>R ( z ) = { Q ( z ) } <span class="math inline">\(,其中\)</span>P ( z ) <span class="math inline">\(和\)</span>Q ( z ) <span class="math inline">\(都是多项式,我们想要找到一种方式求解\)</span>[ z ^n
] R ( z ) $.</p>
<p>考虑有理函数$S ( z ) = _{ k = 1 } ^m { 1 - <em>k z } \ <span class="math inline">\(,不难发现\)</span>[ z ^n ] S ( z ) = </em>{ k = 1
} ^m a _k _k ^n \ $.</p>
<p>那么可以证明,只要$Q ( z ) = 0 <span class="math inline">\(无重根并且无零根,那么就存在一组系数满足\)</span>S
( z ) = R ( z ) $.</p>
<p>我们这么定义”反射”运算,若$Q ( z ) = _{ k = 0 } ^m q <em>k z ^k \
<span class="math inline">\(,则其反射多项式为\)</span>Q ^R ( z ) =
</em>{ k = 0 } ^m q _k z ^{ m - k } \ $.</p>
<p>若$Q ( z ) = q <em>0 </em>{ k = 1 } ^m ( 1 - _k z ) <span class="math inline">\(,则显然有\)</span>Q ^R ( z ) = q <em>0 </em>{ k =
1 } ^m ( z - _k ) \ $.</p>
<p>那么显然这里求出来的这组数$<span class="math inline">\(就是\)</span>S
( z ) <span class="math inline">\(中的那组\)</span>$.</p>
<p>而我们有$a _k = { Q ’ ( _k ) } $.</p>
<h4><span id="example1">Example1</span></h4>
<p>已知$n ! = <em>{ k } { k } g </em>{ n - k } , n \ <span class="math inline">\(,求\)</span>g _n $.</p>
<p>首先两边同时除以$n ! $并将组合数用阶乘形式展开,我们有:</p>
<p><span class="math display">\[
1 = \sum _{ k  } \cfrac { g _{ n - k  }  } { k ! ( n - k ) !  } .
\]</span></p>
<p>如果我们令$D ( z ) = _{ k } { k ! } z ^k $,则有:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac { 1  } { 1 - z  } &amp; = e ^z D ( z ) \\
D ( z ) &amp; = \cfrac { 1  } { 1 - z  } e ^{ - z  } \\
D ( z ) &amp; = ( \sum _{ k \geq 0  } z ^k ) ( \sum _{ k \geq 0  } ( - 1
) ^k \cfrac { z ^k  } { k !  } ) \\
[ z ^n ] D ( z ) &amp; = \sum _{ k = 0  } ^n \cfrac { ( - 1 ) ^k  } { k
!  }
\end{aligned}
\]</span></p>
<p>于是$g <em>n = n ! </em>{ k = 0 } ^n { k ! } \ $.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4>
<p>首先设$F _i ( x ) <span class="math inline">\(为第\)</span>i <span class="math inline">\(家的生成函数,这个是显然可以快速预处理出来的.令\)</span>M
= 520 $.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有$n <span class="math inline">\(个多项式,最高次数是\)</span>M <span class="math inline">\(,因此一共要插入\)</span>nM <span class="math inline">\(个值,又要处理每个后缀,复杂度来到\)</span>O ( n ^2
M ^3 ) <span class="math inline">\(.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到\)</span>O
( n ^2 M ^2 ) $.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到$O ( n ^2
Mq ) <span class="math inline">\(.但\)</span>n
$如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下$2 ^n <span class="math inline">\(的答案,复杂度来到\)</span>O ( nM 2 ^n q ) <span class="math inline">\(.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到\)</span>O
( { B } B 2 ^B MnM ) <span class="math inline">\(,单次询问复杂度来到\)</span>O ( { B } Mnq ) <span class="math inline">\(.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以\)</span>k
<span class="math inline">\(要大于\)</span>m $,就直接输出$0
$.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要$O ( ( nM ) ^2 q ) <span class="math inline">\(的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到\)</span>O
( nMq ) $.</p>
<h4><span id="example3十二省联考-2019皮配">Example3([十二省联考 2019]
皮配)</span></h4>
<p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为$xy , y , x , 1 <span class="math inline">\(,这样最后判断幂在一个区间内的\)</span>x <span class="math inline">\(和\)</span>y $前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是$( x ^{ s _i
} y ^{ s _i } + x ^{ s _i } ) + ( y ^{ s _i } + 1 ) = ( ( x ^{ s _i } +
1 ) ) ( ( y ^{ s _i } + 1 ) ) <span class="math inline">\(.也就是\)</span>x <span class="math inline">\(和\)</span>y $是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于$O ( mk ^2 s )
$.最后两部分合并一下.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" class="post-title-link" itemprop="url">图论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="约定">约定</span></h3>
<p>$K _n <span class="math inline">\(为\)</span>n $个点的完全图</p>
<h3><span id="树的性质">树的性质</span></h3>
<h5><span id="example1hdu6035colorfultree">Example1([HDU6035]Colorful
Tree)</span></h5>
<p>考虑每种颜色的贡献,一种颜色的贡献显然是删去所有这个颜色的边后,剩下的联通块之间的路径.</p>
<h5><span id="example22022qbxt国庆day1tree">Example2([2022qbxt国庆Day1]tree)</span></h5>
<p>首先考虑分开处理每个点,在做每个点的时候假设它的所有子节点全部已经满足条件了,最终我们再通过计算组合数的方式计算即可.</p>
<p>那么最后,我们需要对于每个点进行处理,假设我们已知这个子树的集合是$S
<span class="math inline">\(,那么我们需要用容斥计算如果当前子树集合是\)</span>S
$的子集的情况,不难发现容斥式子:</p>
<p><span class="math display">\[
ans = \sum _{ k = \max \{ f _v | x \rightarrow v \}  } ^{ f _x  } ( - 1
) ^{ f _x - k  } k \binom { f _x  } { k  } \sum _{ x \rightarrow v  }
\binom { k  } { f _v  }
\]</span></p>
<p>其实也就是个二项式反演的形式.</p>
<p>这题还需要一些技巧优化,我们首先发现由于$f _v <span class="math inline">\(有可能有重复的,我们可以提前把重复的\)</span>f _v
<span class="math inline">\(压缩到一起再用快速幂求,于是后面的部分最多不过\)</span>
<span class="math inline">\(级别.而前面是一个类似于树上启发式合并的东西,于是复杂度\)</span>O
( n n ) $.</p>
<h5><span id="example3cf1628egroceries-in-meteor-town">Example3(CF1628E
Groceries in Meteor Town)</span></h5>
<p>因为要求路径最大值,所以先建Kruskal重构树.然后问题转化为求一个点和一群白点的LCA是谁.</p>
<p>树上多点LCA有个经典性质:也就相当于其中$dfn
$序最大的和最小的两个点的LCA.</p>
<p>至于区间覆盖可以用线段树.</p>
<h5><span id="example4loj3692">Example4(loj3692)</span></h5>
<p>注意到$D $很小.</p>
<p>我们考虑处理邻域乘,设$f <em>{ x , i } <span class="math inline">\(表示\)</span>x <span class="math inline">\(的\)</span>i <span class="math inline">\(级儿子需要乘上的答案.每次修改时,先将\)</span>f
</em>{ x , D } <span class="math inline">\(和\)</span>f _{ x , D - 1 }
<span class="math inline">\(乘上\)</span>W <span class="math inline">\(,然后令\)</span>x = fa _x <span class="math inline">\(,\)</span>D = D - 2 <span class="math inline">\(,继续此操作直到\)</span>D $为$0 $.</p>
<p>然后询问的时候直接暴力跳$D $层父亲找答案,不难发现这样做是对的.</p>
<p>同样的思路可以脱离点分治处理很多邻域问题.</p>
<h4><span id="树的直径">树的直径</span></h4>
<ol type="1">
<li><p>定义:树中最长的一条简单路径.</p></li>
<li><p>树的直径可能有多个.</p></li>
<li><p>直径的两个端点一定是两个叶子节点.</p></li>
<li><p>如果树有多条直径,树的不同的直径的中点/中边一定是相同的.</p></li>
<li><p>到一个点距离最远的点一定是直径的一个端点.</p></li>
<li><p>对于两棵树,如果第一棵树直径两端点为$( u , v ) <span class="math inline">\(,第二棵树直径两端点为\)</span>( x , y ) <span class="math inline">\(,用一条边将两棵树连接,那么新树的直径一定是\)</span>u
, v , x , y $中的两个点.</p></li>
</ol>
<p>上述的证明大都是考虑反证法:如果不成立,则一定存在一条更长的直径.</p>
<h5><span id="example1sdoi2013直径">Example1([SDOI2013]直径)</span></h5>
<p>有一个做法是:考虑找到直径的中点/中边,找到它到两边的最远距离的点,显然两边的点分别的以中点/中边的两个端点为根的LCA中间的部分就是一定会被包含的边.</p>
<h4><span id="树的重心">树的重心</span></h4>
<ol type="1">
<li><p>定义:树的重心是删去后所有剩余子树大小最大值最小的点.</p></li>
<li><p>树的重心是删去后所有剩余子树大小全部小于等于$ { 2 }
$的点.</p></li>
<li><p>树的重心只有可能有一个或两个.</p></li>
<li><p>如果树有两个重心,那么这两个重心相邻.</p></li>
<li><p>树的重心是所有点到其距离之和最小的点.</p></li>
<li><p>把一个树添加或删除一个叶子,那么它的重心最多只移动一条边的距离.</p></li>
<li><p>把两个树通过一条边相连得到一个新的树,那么新的树的重心在连接原来两个树的重心的路径上.</p></li>
</ol>
<p>(2)的证明如下:</p>
<p>如果重心是$u <span class="math inline">\(,且删去\)</span>u <span class="math inline">\(后剩余最大子树大小大于\)</span> { 2 } <span class="math inline">\(,设这棵子树中与\)</span>u <span class="math inline">\(相邻的点为\)</span>v <span class="math inline">\(,则我们删去\)</span>v
$后,最大子树大小一定会减少,不满足假设,所以(2)得证.</p>
<p>另外,如果一个点删去后所有剩余子树大小全部小于等于$ { 2 } <span class="math inline">\(,那它也一定是重心.因为不存在除了重心以外的满足条件的点:考虑调整法,与重心相邻的点一定都不满足条件,因为它们的子树大小全都小于等于\)</span>
{ 2 } <span class="math inline">\(,移动后最大子树一定不小于\)</span>n -
{ 2 } $.</p>
<p>(3)(4)的证明如下:</p>
<p>首先证明:如果有两个点都是重心,那它们一定相邻.</p>
<p>考虑如果二者不相邻,那删去它们后剩下的最大子树大小一定相等,设这两个点分别为$x
, y <span class="math inline">\(,那删去\)</span>x <span class="math inline">\(后,剩下的最大子树一定包含了\)</span>y <span class="math inline">\(,而这个子树的大小一定小于等于\)</span> { 2 } <span class="math inline">\(.那删去\)</span>y <span class="math inline">\(后,剩下的最大子树大小必定大于\)</span> { 2 }
$,一定不合法.</p>
<p>而树上不可能有超过两个点两两相邻,于是最多只有两个重心,且它们一定相邻.</p>
<p>(5)的证明如下:</p>
<p>考虑如果$u <span class="math inline">\(是树的重心,我们看能不能将\)</span>u
$调整到另一个点使得所有点到其距离之和更小.</p>
<p>由于调整是一步一步做的,显然只需要判断所有和$u <span class="math inline">\(相邻的点是否符合条件即可.设这个点为\)</span>x
<span class="math inline">\(,那我们把\)</span>u <span class="math inline">\(改为\)</span>x <span class="math inline">\(,会使答案减小\)</span>siz _x <span class="math inline">\(,增加\)</span>n - siz _x <span class="math inline">\(,由于\)</span>siz _x { 2 }
$,所以这么做一定不优.</p>
<p>(6)的证明如下:</p>
<p>首先,如果加入一个叶子节点后,各个子树大小仍然都$&lt; { 2 }
$,那显然不必调整.</p>
<p>不然,显然是往叶子节点移动一格或者加入一个相邻的重心.</p>
<p>(7)的证明如下:</p>
<p>不妨设两棵树大小分别为$siz _a siz _b
$,然后令相连的两个点是这两棵树的根.</p>
<p>对于$b <span class="math inline">\(中的重心,肯定是会往根跳,并且不可能跳出\)</span>b
$原本的树.</p>
<h5><span id="example1csp-s2019树的重心">Example1([CSP-S2019]树的重心)</span></h5>
<p>首先取重心$rt $为根,如果有两个就随便取一个.</p>
<p>接下来我们考虑对于每个点$x <span class="math inline">\(,它在什么情况下会成为重心.首先,删掉的边不可能在\)</span>x
<span class="math inline">\(的子树内,不然一定不可能取到\)</span>x <span class="math inline">\(的.然后,我们假设删掉的子树大小为\)</span>S <span class="math inline">\(,\)</span>x <span class="math inline">\(的子树内最大的一个子树大小为\)</span>g _x
$,那么根据重心的性质有:</p>
$$
<span class="math display">\[\begin{aligned}
2 ( n - S - siz _x ) &amp; \leq n - S \\
2 g _x &amp; \leq n - S \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理得到:</p>
<p><span class="math display">\[
2 g _x \leq n - S \leq 2 siz _x
\]</span></p>
<p>考虑这个怎么计算:如果没有删边必须在$x <span class="math inline">\(子树外的限制,那显然可以直接遍历一遍存下\)</span>n
- S <span class="math inline">\(,然后统一使用值域树状数组做.而我们接下来考虑删去\)</span>x
$子树内的贡献,类似colorful
tree的做法,每次dfs到一个点,记录下来当前树状数组的答案,然后dfs子树,回溯时拿新答案减去旧答案就是子树内的答案.</p>
<p>接下来我们需要考虑$x = rt $怎么做.</p>
<p>考虑$x
$的子树中最大的那个和次大的那个,如果我们删去的节点不在最大的子树中,那只需要保证最大的子树大小满足条件;不然,只需保证次大的子树大小满足条件,也是好维护的.</p>
<h4><span id="树的结构的维护">树的结构的维护</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定一棵树,树上点有点权$val <span class="math inline">\(.现在有一个值\)</span>sum $,初始为$0 $.从$1 <span class="math inline">\(号点出发,每第一次到一个点\)</span>u <span class="math inline">\(,就会使\)</span>sum + = val _u <span class="math inline">\(.求在时刻保证\)</span>sum <span class="math inline">\(的前提下,\)</span>sum $最终的最大值.</p>
<p>首先注意到为了保证$sum <span class="math inline">\(这个性质,一个节点应该有两个值:\)</span>lim <span class="math inline">\(表示能走到这个点所需要的最小的\)</span>sum <span class="math inline">\(,\)</span>val <span class="math inline">\(表示到了这个点后能获得的价值.显然如果\)</span>val
$则无意义.</p>
<p>如果我们能一开始处理出根的所有儿子的$lim <span class="math inline">\(和\)</span>val <span class="math inline">\(,我们就可以使用先走\)</span>lim <span class="math inline">\(小的点,并不断累计\)</span>sum $的方式做.</p>
<p>所以考虑不断向上合并信息.不难发现此时一个点要处理出多对$( lim , val )
$.考虑用一个左偏树维护这个东西.</p>
<p>但是,我们还需要保证不能跳着选点.也就是说我们要保证选中一个点,这个点的父亲必须选,怎么办呢?</p>
<p>一个方式是,我们把排序方法从只看$lim <span class="math inline">\(变成先判是否存在祖先后代关系,再判断\)</span>lim
$.</p>
<p>另一个方式是,我们每次直接把当前子树根节点扔到堆顶.但是需要满足堆的性质.不难发现如果这个点$val
&lt; 0 <span class="math inline">\(,我们可以将它与下面的\)</span>lim
<span class="math inline">\(最的节点合并直到这个点\)</span>val <span class="math inline">\(.而如果这个点的\)</span>lim
$太大,我们同样可以合并.注意到这样我们采取了一种很聪明的方式维护了树的形态.</p>
<h4><span id="dfs树的性质">dfs树的性质</span></h4>
<h5><span id="example1cf1361ejames-andthe-chase">Example1([CF1361E]James and
the Chase)</span></h5>
<p>如何判断一个点是否是好的呢?首先,如果要求是任意路径,那一个点是好的当且仅当它是一个叶向有根树的根.</p>
<p>现在要求是简单路径,那也就是说如果走了重复点是可以忽略的,这也就是说这个叶向有根树可以有反走边,而显然不能有横插边.不难发现这是充要条件.</p>
<p>另一个问题是:如何快速判断一个点是否满足上述条件呢?首先我们求出以一个好的点为根的dfs树(随机选取一定数量的点,如果一个都不是好点直接输出$-
1 <span class="math inline">\(),然后我们发现:一个点\)</span>u <span class="math inline">\(是好的必要条件是它的子树内只有一条反走边,证明显然.假设\)</span>u
<span class="math inline">\(通过这条反走边走到了点\)</span>v <span class="math inline">\(,那么\)</span>u <span class="math inline">\(是好的点当且仅当\)</span>v $也是好的点.</p>
<p>这是为啥呢?首先,因为我们是以一个好点为根跑的dfs树,所以$u <span class="math inline">\(走到子树内的点必定只有一种方式.那子树外的点呢?走到\)</span>v
<span class="math inline">\(后,显然就要从它走到其它点,而它到\)</span>u
<span class="math inline">\(的子树内显然只有一种方案,那如果\)</span>v
<span class="math inline">\(到其它点也只有一种方案,那么根据\)</span>u v
<span class="math inline">\(这条路径,\)</span>u $显然也是好点.</p>
<h5><span id="example2loj-6276">Example2(Loj 6276)</span></h5>
<p>找到所有颜色相同的点对$( x , y )
$,经过它们的路径都不合法,显然经过它们的路径可以用dfs序刻画成矩阵,最后要求矩阵面积并.</p>
<h3><span id="圆方树的性质">圆方树的性质</span></h3>
<ol type="1">
<li><p>对于任意的非空无向图$G <span class="math inline">\(,一定存在一个\)</span>G <span class="math inline">\(的点双连通分量\)</span>B <span class="math inline">\(,使得\)</span>B $中只有不超过$1 <span class="math inline">\(个节点是\)</span>G <span class="math inline">\(的割点.其中,若\)</span>B <span class="math inline">\(中没有\)</span>G <span class="math inline">\(的割点,则有\)</span>B = G $.</p></li>
<li><p>若一个点双连通分量不为$K _2
$,则该点双连通分量中至少有一个简单环.</p></li>
<li><p>在仙人掌上的每个点双连通分量要么是$K _2
$,要么是一个简单环.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双连通分量中的任意一个点\)</span>u <span class="math inline">\(,一定存在一个简单环\)</span>C <span class="math inline">\(使得\)</span>u <span class="math inline">\(在\)</span>C $上.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双连通分量中的任意两个点\)</span>u , v <span class="math inline">\(,一定存在一个简单环\)</span>C <span class="math inline">\(使得\)</span>u , v <span class="math inline">\(在\)</span>C $上.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双,任给一点\)</span>x <span class="math inline">\(和一边\)</span>e <span class="math inline">\(,一定存在经过\)</span>x , e $的简单环.</p></li>
<li><p>对于一个不是$K _2 <span class="math inline">\(的点双,任给两点\)</span>s , t <span class="math inline">\(和一边\)</span>e <span class="math inline">\(,一定存在一条\)</span>s - e - t
$的简单路径.</p></li>
</ol>
<p>(6)的证明非常变魔术,你考虑把$e : u v <span class="math inline">\(这条边给改成\)</span>u w v <span class="math inline">\(,然后\)</span>w <span class="math inline">\(和\)</span>x <span class="math inline">\(在一个简单环上,意味着\)</span>u , w , v , x
$在一个简单环上.</p>
<p>(7)考虑(6)就行,先找到$s <span class="math inline">\(和\)</span>e
<span class="math inline">\(所在的简单环,然后从这个环上连到\)</span>t
$.</p>
<h3><span id="任意图的性质">任意图的性质</span></h3>
<ol type="1">
<li>若一张无向连通图$G $中存在$3 <span class="math inline">\(个不同的一度点\)</span>x , y , z <span class="math inline">\(,则一定存在一个点\)</span>u { x , y , z }
$使得存在$3 <span class="math inline">\(条两两没有公共边的简单路径满足其中一个端点均为\)</span>u
$ 且另一个端点分别为$x , y , z $.(证明考虑求生成树后讨论LCA)</li>
</ol>
<h3><span id="dsu-on-tree">dsu on tree</span></h3>
<h5><span id="exampleqoj5020">Example(QOJ5020)</span></h5>
<p>我们考虑树链剖分,这样将问题转化为三部分:</p>
<ol type="1">
<li><p>对于某个点而言,到它距离$d
$的点数量.这个问题可以使用点分治解决.</p></li>
<li><p>对于某条重链的上半部分而言,它连接的所有轻子树中,到它距离$d
$的点数量.这个问题直接dsu on tree.</p></li>
<li><p>对于某个点而言,在它子树内到它距离$d
$的点数量.这个问题也可以直接dsu on tree.</p></li>
</ol>
<p>为什么转化为三个部分就能求解呢?我们考虑一条链$u w v <span class="math inline">\(,其中\)</span>w <span class="math inline">\(是这条链上深度最浅的点.那么首先我们统计在\)</span>w
<span class="math inline">\(子树外的,这一个部分可以由(1)和(3)做差求出来.然后我们要求的就是在\)</span>w
<span class="math inline">\(子树内,到这条链的距离\)</span>d
$的点的数量.这个怎么求呢?我们考虑差分,求一下$1 u $和$1 w
$的答案然后做差.这样我们对这条到根的路径重链剖分,只需要处理重链的上半部分以及两条重链的连接处.不难发现两条重链的连接处会被多算一次,拿(3)减一下就好.以及这条路径所叉出去的重儿子也需要用(3).</p>
<p>现在的问题在于怎么求(2)和(3),先考虑(2),我们对于每一条重链从顶端走到低端不断地加入轻儿子,然后维护BIT就行.(3)是类似的,只不过是需要从底端走到顶端.</p>
<p>注意如果把重儿子和轻儿子分开处理,那么可能会在一些奇怪的地方算重,解决方法是特判$w
$处的答案,然后拆成两条互相之间完全没有影响的链,当然这也有可能会发生跳重链的时候轻儿子算重的情况,同样需要判断一下.</p>
<h3><span id="最小生成树">最小生成树</span></h3>
<h5><span id="example1cf1550f-jumpingaround">Example1(CF1550F Jumping
Around)</span></h5>
<p>首先考虑离线.注意到每次肯定跳到一个自己能跳到的点,而这个点应该是所需灵活度最小的点.</p>
<p>考虑boruvka算法,建立最小生成树并判断.</p>
<h3><span id="kruskal重构树">Kruskal重构树</span></h3>
<p>最小生成树时,每一次加边的时候把那个边变成虚点,两个点连到这条边上.任意两个点的LCA就是它们路径上的最小边权.</p>
<h3><span id="最短路">最短路</span></h3>
<h5><span id="example1cf1753d-the-beach">Example1(CF1753D The Beach)</span></h5>
<p>首先,自然的想法是把格子图黑白染色.</p>
<p>然后,我们注意到一个床是不可能被移动两次及以上的.因为如果是横着动两次,那不动自然就有一对空位置了;如果是转两次,考虑转的目的一定是为了空出某个位置或某两个位置(不可能为了空出三个位置,显然这么做很闲),一次操作足矣;如果是动一次转一次也是一样的,要么转的很闲要么原本就存在这么一对空位置.</p>
<p>我们再进行一步转化,考虑把动床改为动格子.换句话说,每个格子可以通过一定的代价移动到和它相邻的床的与它不相邻的那个位置上.注意到移动格子的过程只会把黑格子移动到黑格子,白格子移动到白格子.</p>
<p>于是建立超级源点跑两边最短路,枚举最后床放在哪里即可.不过这里有一点是一个床有没有可能被黑白最短路同时跑了一遍,是有可能的,但这么跑一定不优秀,不可能是最小答案.</p>
<h5><span id="example2cf843ddynamicshortest-path">Example2([CF843D]Dynamic
Shortest Path)</span></h5>
<p>注意到$O ( nq ) <span class="math inline">\(能过.而且每次修改只是对于若干条边\)</span>+ 1
$,自然想到每次修改完后跑01bfs.</p>
<p>但是怎么跑呢?注意到维护每个点最短路的增量,并且在路径的增量上跑01bfs,自然可求.</p>
<h5><span id="example3同余最短路luogup2371墨墨的等式">Example3
同余最短路([luoguP2371]墨墨的等式)</span></h5>
<p>因为$a _i <span class="math inline">\(无序,假设\)</span>a _1 <span class="math inline">\(最小,那么所有的数字都可以按\)</span>a _1 <span class="math inline">\(的结果分成\)</span>a _1 <span class="math inline">\(类.我们按照余数设置\)</span>a _1 $个点,编号为$0
<span class="math inline">\(至\)</span>a _1 - 1 $.</p>
<p>设$dis _i <span class="math inline">\(为所有能组成的数中且\)</span>a
_1 <span class="math inline">\(余数为\)</span>i <span class="math inline">\(的最小数.那么,所有能表示出来的\)</span>a _1 <span class="math inline">\(余数为\)</span>i <span class="math inline">\(的数都可以写作\)</span>dis _i + k a _1 , k <span class="math inline">\(的形式,求得\)</span>dis _i $后可以很轻易算出.</p>
<p>那么怎么求$dis _i <span class="math inline">\(呢?我们考虑:对于任意一个数\)</span>k <span class="math inline">\(,它可以怎么得到.注意到如果\)</span>k - a _j <span class="math inline">\((其中\)</span>i j <span class="math inline">\()可行,那么\)</span>k <span class="math inline">\(一定可行.自然有:\)</span>dis _i = { dis _j + a _k
| 0 j &lt; a _i , k i } $.</p>
<p>这显然是一个最短路问题.</p>
<h3><span id="差分约束">差分约束</span></h3>
<h5><span id="example1agc056c-01balanced">Example1([AGC056C] 01
Balanced)</span></h5>
<p>将$1 <span class="math inline">\(看成\)</span>- 1 $,$0 <span class="math inline">\(看成\)</span>+ 1 <span class="math inline">\(,不难发现字典序最小也就是让前缀和序列字典序最小,并且有\)</span>sum
<em>{ r <em>i } = sum </em>{ l <em>i - 1 } <span class="math inline">\(以及\)</span>- 1 sum </em>{ i } - sum </em>{ i - 1
} $,然后做$01 <span class="math inline">\(bfs跑最短路,显然最短路可以保证每个\)</span>sum
$都尽可能小.</p>
<p>然后另一个问题在于这玩意为啥不会让$sum <em>i = sum </em>{ i - 1 }
$,这个建图后观察一下就知道不会发生这种情况.</p>
<h3><span id="2-sat">2-SAT</span></h3>
<h5><span id="example1cf1697f">Example1(CF1697F)</span></h5>
<p>对每个点建立$k <span class="math inline">\(对点表示\)</span>a _i x
<span class="math inline">\(和\)</span>a _i &lt; x $,就能做了.</p>
<h5><span id="example22021集训队互测-序列">Example2(2021集训队互测 序列)</span></h5>
<p>注意到如果$a _i &lt; x <span class="math inline">\(,那么\)</span>a _j
x a _k x $,这样就可以刻画所有的条件.</p>
<p>而且一定可以刻画所有的条件.</p>
<h3><span id="对偶图">对偶图</span></h3>
<h5><span id="example1csp-s-2021交通规划">Example1([CSP-S 2021]
交通规划)</span></h5>
<p>先考虑如果附加点的颜色全都相同,那肯定输出$0 $即可.</p>
<p>考虑附加点的数量为$2
$的时候,那显然最优情况需要将整个图分成各自联通的两部分,一部分染成黑色,一部分染成白色.可以发现这就是一个对偶图.</p>
<p>而如果附加点的数量很多怎么做呢?稍微思考一下</p>
<h3><span id="广义串并联图三度化">广义串并联图/三度化</span></h3>
<h4><span id="定义">定义</span></h4>
<p>定义:不存在$4
$个点使得任意两点之间存在一条简单路径,且这六条路径不在$4
$个点之外的地方相交.</p>
<h4><span id="删一度点">删一度点</span></h4>
<p>经典问题引入:树上带权最大独立集.</p>
<p>首先dp是可以实现的,我们考虑是否存在贪心算法.</p>
<p>首先,如果不带权,我们显然可以每次选取一度点或零度点,并删去所有相连的点.这样做显然是最优的.</p>
<p>但怎么做带权的方法呢?我们注意到可以先删掉所有负点权的点,然后可以加入剩下的所有零度点.</p>
<p>那么对于一度点呢?对于一个一度点$u <span class="math inline">\(和它的相邻点\)</span>v <span class="math inline">\(,我们不能盲目选\)</span>u <span class="math inline">\(的原因是可能选取\)</span>v <span class="math inline">\(会更优秀.考虑做一个带悔贪心,我们先把\)</span>u
<span class="math inline">\(选上,然后把\)</span>v <span class="math inline">\(的权值设为\)</span>val _v - val _u <span class="math inline">\(,相当于我们仍然可以选\)</span>v <span class="math inline">\(,但是要花费\)</span>val _u <span class="math inline">\(的代价把\)</span>u $删去.</p>
<p>我们把类似这样的操作称为<strong>删一度点</strong>.</p>
<h4><span id="缩二度点">缩二度点</span></h4>
<p>问题引入:给定一个仙人掌,每个点可以染色为$0 $或$1 <span class="math inline">\(,\)</span>u $节点染成$0 <span class="math inline">\(会有\)</span>b _u <span class="math inline">\(的贡献,不然有\)</span>w _u <span class="math inline">\(的贡献.若一条边\)</span>e <span class="math inline">\(相邻的两点颜色相同则有\)</span>s _e <span class="math inline">\(的贡献,不然有\)</span>d _e $的贡献,求最大答案.</p>
<p>首先如果有一度点和零度点,我们仍然可以使用删一度点的操作.</p>
<p>如果没有,考虑仙人掌上的一个点双一定是一个简单环.而且一定存在一个点双$B
<span class="math inline">\(满足\)</span>B $只包含一个割点.</p>
<p>那么对于这个点双上的一个非割点$x <span class="math inline">\(以及和它相邻的两个点\)</span>u <span class="math inline">\(和\)</span>v <span class="math inline">\(,我们考虑\)</span>x <span class="math inline">\(的染色有可能改变\)</span>u <span class="math inline">\(和\)</span>v $的答案,那么怎么办呢?</p>
<p>冷静思考一下,我们想办法把$x <span class="math inline">\(给删掉.简单来说,我们把\)</span>u <span class="math inline">\(和\)</span>v <span class="math inline">\(之间连一条边权为\)</span>[ w <em>{ 0 , 0 } , w
</em>{ 0 , 1 } , w <em>{ 1 , 0 } , w </em>{ 1 , 1 } ] <span class="math inline">\(的边,分别表示\)</span>u <span class="math inline">\(和\)</span>v <span class="math inline">\(的染色为以上四种情况时这条边(也就是原本的\)</span>x
<span class="math inline">\()的最大贡献是什么,这显然可以通过讨论\)</span>x
<span class="math inline">\(的取值而求得.这样初始边权实际上就是\)</span>[ s ,
d , d , s ]
$,于是我们就可以删掉一个二度点并连起来与它相邻的两个点,我们把类似这样的操作称为<strong>缩二度点</strong>.</p>
<h4><span id="叠合重边">叠合重边</span></h4>
<p>注意到使用缩二度点的时候,会把一个三元环缩成两个点及链接它们的两条重边,但是我们可以直接把重边合起来,我们把类似这样的操作称为<strong>叠合重边</strong>.</p>
<h4><span id="正确性证明">正确性证明</span></h4>
<p>接下来我们证明:任何广义串并联图都可以通过以上三种操作缩为一个点.</p>
<h5><span id="引理1">引理1</span></h5>
<p>对于一个无向图$G $,若进行若干次删一度点操作,缩$2 <span class="math inline">\(度点操作以及叠合重边操作后得到的图不是广义串并联图,那么\)</span>G
$也不是广义串并联图.</p>
<p>考虑用逆操作还原原图.删一度点的逆操作是加入一个点,叠合重边的逆操作是将一条边变成两条边,这两个操作显然不会使一个不是广义串并联图的图变成广义串并联图.接下来考虑缩二度点的逆操作:删掉一条边$(
u , v ) <span class="math inline">\(并加入一个点\)</span>w <span class="math inline">\(和两条边\)</span>( u , w ) <span class="math inline">\(和\)</span>( w , v ) $.</p>
<p>由于这个图不是广义串并联图,所以一定存在一组反例点${ a , b , c , d }
$.如果我们删掉的边不在作为反例的六条边上,那显然不影响;如果在,由于新加入的两条边仍然可以作为路径,所以也不影响.</p>
<p>于是引理得证.</p>
<h5><span id="引理2">引理2</span></h5>
<p>任意一张所有点的度数都大于等于$3
$的简单无向连通图,一定不是广义串并联图.</p>
<p>这个引理的严格证明有些麻烦.我们冷静一下,一个四个点的完全图满足以上条件且不是广义串并联图.而其他的图感性理解一下应该可以通过缩路径的方式变成一个四个点的完全图.</p>
<p>结合引理1,我们得知任意一个操作后不能变成单个节点的图的无向连通图不是广义串并联图.</p>
<h5><span id="引理3">引理3</span></h5>
<p>任意一个满足$m n + k <span class="math inline">\(的图,通过删一度点,缩二度点,叠合重边操作后,\)</span>m
<span class="math inline">\(和\)</span>n <span class="math inline">\(都会到达一个\)</span>O ( k ) $的量级.</p>
<p>考虑缩完点后,所有点的度数$ $,于是有$2 m n <span class="math inline">\(,而在操作过程中,\)</span>m - n <span class="math inline">\(的值显然是不增的,于是有\)</span>m - n k <span class="math inline">\(,解一下方程得到\)</span>n k , m k $.</p>
<h4><span id="example122zr提高十连测day6摆件">Example1(22zr提高十连测day6摆件)</span></h4>
<p>首先考虑颜色之间没啥区别,所以对于一棵树来说,朴素的dp是可以的.</p>
<p>简单来说,设$dp _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(棵子树的答案.合并的时候考虑设\)</span>f _v = { k }
dp _v sam _e + { k } dp _v dif _e <span class="math inline">\(,自然有\)</span>dp <em>u = </em>{ u v } f _v \
$.</p>
<p>接下来考虑先随便找一棵生成树,然后暴力枚举多余的反走边的深度较低的叶子节点的颜色,再进行dp即可.</p>
<p>另外也可以缩点后做,不过对于这题没啥区别.</p>
<h4><span id="example2joi-open-2022放学路">Example2([JOI Open 2022]
放学路)</span></h4>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果$S <span class="math inline">\(和\)</span>T <span class="math inline">\(在一个点双中,我们找到两个点\)</span>u , v <span class="math inline">\(,使得\)</span>u v <span class="math inline">\(,并且\)</span>u $的出度至少是$2 <span class="math inline">\(,\)</span>v $的入度至少是$2
$,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为$2
<span class="math inline">\(的点\)</span>v <span class="math inline">\(,找到它的入点\)</span>u <span class="math inline">\(,如果\)</span>u $的出度不是$2 <span class="math inline">\(,那么\)</span>u $也是一个入度至少为$2 <span class="math inline">\(的点.这样往前推一定至少能推到一个点(因为不可能\)</span>S
$贡献了俩入度).</p>
<p>如何保证$S , T <span class="math inline">\(在一个点双中呢?其实只需要添加一条边\)</span>( S ,
T , dis _{ S T } ) <span class="math inline">\(就行了.显然加了后不会对答案产生影响.然后不在\)</span>S
, T $这个边双内的点也没有用了.</p>
<h3><span id="点分治">点分治</span></h3>
<h5><span id="example1cfgym101002k">Example1(CFgym101002K)</span></h5>
<p>点分治,假设当前分治重心是$g <span class="math inline">\(,将每个数缩成一个二元组\)</span>( w _i , d _i )
<span class="math inline">\(,所求就是\)</span>w _i w _j + d _i + d _j
$最小,直接排序做斜率优化.</p>
<h4><span id="点分树的性质">点分树的性质</span></h4>
<ol type="1">
<li><p>点分树的高度是$O ( n ) $级别.</p></li>
<li><p>两个点在原树上的路径一定经过其在点分树上的LCA.</p></li>
</ol>
<h5><span id="example1codechef-btree">Example1(codechef [BTREE])</span></h5>
<p>这题用到了一个经典套路:一个树形连通图的点数减去边数为$1
$,把虚树建出来,能到达一个点的守卫必然是一个树形连通图(虚树中原本没有守卫的点可以加个不同覆盖范围的守卫).于是我们只需要求出每个守卫能覆盖多少点以及两个守卫之间的那条路径能覆盖多少个点,前者用点分树轻松维护,后者的话找一下这条边上的某个满足条件的点就行.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树,现在在上面选定$m $对不同的点,要求每对点的距离之和最大.</p>
<p>考虑如果确定了$2 m <span class="math inline">\(个点,我们如何匹配他们.对每条边算贡献,假设这条边两侧分别有\)</span>a
, b <span class="math inline">\(个点,那么这条边最大的贡献就是\)</span>{
a , b } $.不难发现这个上界可以取到,只需要取这$2 m <span class="math inline">\(个点的带权重心,由于不存在绝对众数,所以直接两两匹配.枚举带权重心是啥,这样复杂度\)</span>O
( n ^2 ) $.</p>
<p>那么怎么优化呢?我们注意到如果以一个点$x <span class="math inline">\(作为根,而它有一个儿子\)</span>y <span class="math inline">\(,\)</span>y <span class="math inline">\(的子树中选了少于\)</span>m <span class="math inline">\(个点,那么我们以\)</span>y <span class="math inline">\(为根一定是不优秀的,不然一开始就不可能只选少于\)</span>m
$个点,再考虑带权重心这个东西,上点分树.</p>
<p>具体来说,我们建立点分树,然后从点分树的根开始枚举带权重心,如果当前没有一棵子树选了$m
<span class="math inline">\(个点,就停止,不然往选了\)</span>m <span class="math inline">\(个点的那棵子树走(如果有两个的话选第\)</span>m
<span class="math inline">\(大更大的那个),这样就只会选取\)</span>O ( n )
$个带权重心.</p>
<h3><span id="边分治">边分治</span></h3>
<p>需要建立虚点转二叉树.</p>
<h4><span id="边分树的性质">边分树的性质</span></h4>
<ol type="1">
<li><p>非叶子节点代表边,叶子节点代表点.</p></li>
<li><p>边分树的高度是$O ( n ) $级别.</p></li>
<li><p>边分树上每棵子树中的叶子节点一定联通.</p></li>
<li><p>是一棵完全二叉树.</p></li>
<li><p>两个点在原树上的路径一定经过其在边分树上的LCA所代表的边.</p></li>
</ol>
<h3><span id="二分图">二分图</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="最大流-最小割定理">最大流-最小割定理</span></h5>
<h5><span id="hall定理">Hall定理</span></h5>
<p>对于二分图$V _1 , V _2 , E , | V _1 | | V _2 | <span class="math inline">\(,那么该图存在完备匹配的充要条件是\)</span>Q V _1 ,
| Q | | N ( Q ) | <span class="math inline">\(,其中\)</span>N ( Q )
<span class="math inline">\(指的是所有与\)</span>Q
$中点有边相连的点的集合.</p>
<p>必要性很显然,接下来说明充分性.设$T <span class="math inline">\(为最小点覆盖,也就是最大匹配的数量,再设\)</span>M
$为最大匹配,此时自然有:</p>
<p><span class="math display">\[
| M | = | T | = | T _1 | + | T _2 | \geq | T _1 | + | N ( V _1 / T _1 )
| \geq | T _1 | + | V _1 / T _1 | = | V _1 |
\]</span></p>
<p>显然$| M | | V _1 | <span class="math inline">\(,于是\)</span>| M | =
| V _1 | $.</p>
<p>另外,Hall定理有一个推论:正则二分图一定存在完美匹配.什么叫正则二分图,就是所有的点的度数(不为$0
$)都相等的图.</p>
<p>$2 ^d
$-正则二分图求完美匹配的话,可以不断求欧拉回路并给边定向,每次把一个方向的边全都删掉,这样就转化成了$2
^{ d - 1 } <span class="math inline">\(-正则二分图,不断递归到\)</span>d
= 0 $.</p>
<h5><span id="vizing定理">Vizing定理</span></h5>
<p>设$f ( G ) <span class="math inline">\(表示将\)</span>G
$边染色,使得有公共点的边的颜色不同,最少需要的颜色数量.</p>
<p>设$( G ) <span class="math inline">\(表示\)</span>G
$中的点的最大度数.</p>
<p>对于一般图,我们有:$( G ) f ( G ) ( G ) + 1 <span class="math inline">\(,对于二分图有\)</span>( G ) = f ( G ) $.</p>
<p>考虑这个的证明:我们每次将一对点$( x , y ) <span class="math inline">\(染色,考虑设它们当前没染色的最小的颜色是\)</span>l
_x , l _y ( l _x l _y ) $,如果相等就直接选,不然类似增广路更新.</p>
<h4><span id="二分图最大权匹配">二分图最大权匹配</span></h4>
<p>假定二分图两边两两有边(不是的话可以补上$-
$的边),这样就一定存在完美匹配.</p>
<p>我们给每个点一个顶标权值$v <span class="math inline">\(,对于任意一条边\)</span>e : a b <span class="math inline">\(,它的权值是\)</span>w _e <span class="math inline">\(,我们要求\)</span>v <span class="math inline">\(满足\)</span>v _a + v _b w _e $.</p>
<p>如果我们规定了一组顶标后,取出所有满足$v _a + v _b = w _e
$的边后的图(称作相等子图)存在完美匹配,那这组完美匹配就一定是最大权匹配.</p>
<p>这是为啥呢?考虑此时的最大权其实也就是$v <span class="math inline">\(,而由于\)</span>v _a + v _b w _e <span class="math inline">\(,因此最大权匹配一定不会超过\)</span>v
$.这就是一个可达的上界.</p>
<p>那么我们该怎么得到一个相等子图呢?考虑先构造一组合法的顶标,让左部端点取边的最大值,右部端点取$0
$,然后开始增广.</p>
<p>从左侧任意一个非匹配点出发,在相等子图上走增广路并增广.如果增广失败,我们将访问过的左部端点全部减去$d
<span class="math inline">\(,右部端点全部加上\)</span>d
$,注意到此时匹配边一定不会变化,因为匹配边要么两个端点都没被访问过,要么都被访问过.而左端点被访问过,右端点没被访问过的边有可能加入相等子图,我们考虑取所有这种边的需要的差值的最小值并进行更新.但是直接这么做的复杂度有点高.</p>
<p>使用bfs优化,可以发现只会扩大$O ( n ^2 ) <span class="math inline">\(次子图,每次复杂度\)</span>O ( n ) <span class="math inline">\(,增广的复杂度类似,于是总复杂度\)</span>O ( n ^3 )
$.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-ofjapanopenstrain-contest-1489-bpoint-pairs">Example1([
XVII Open Cup named after E.V. Pankratiev. Grand Prix of
Japan(openstrain contest 1489) B]Point Pairs)</span></h5>
<p>看到这种要求横坐标或纵坐标相同的题,有一个自然的想法是建立二分图,对于点$(
x , y ) <span class="math inline">\(,将二分图左边的\)</span>x <span class="math inline">\(和右边的\)</span>y
$连一条边.那么配对等价于要每次找两条相邻的边删掉.那么如何删掉呢?</p>
<p>首先发现的是,二分图不同的连通块可以分开处理,我们接下来只讨论一个连通块的情况.如果这个连通块有奇数条边,显然一定不行.而又可以发现,如果这个连通块有一个点度数仅为$1
$,那这条边如何删是确定的,我们可以把它和另一条边删掉,不难发现怎么删最后得到的新图仍然联通.而如果不存在度数为$1
$的点呢?由于这是一个二分图,不存在奇环,所以我们可以找一个简单环删掉,之后显然也是一个连通块.我们到这里就可以发现问题了.运用数学归纳不难证明:只要一个连通块的边数是偶数就一定合法.</p>
<p>然后我们可以使用可撤销的分治解决这个问题.</p>
<h3><span id="网络流常见模型">网络流常见模型</span></h3>
<h4><span id="最大流">最大流</span></h4>
<h4><span id="最小费用最大流">最小费用最大流</span></h4>
<h4><span id="最小割">最小割</span></h4>
<p>最大流$= $最小割,证明显然.</p>
<p>最小割求方案。这个是简单的，我们删去所有流量$0 <span class="math inline">\(的边后从\)</span>S <span class="math inline">\(开始bfs，找到所有\)</span>S <span class="math inline">\(能到达的点，显然这些点（注意如果这个点一开始就不能到达\)</span>T
<span class="math inline">\(，那它是废物，不用管它，下面只讨论它能到达\)</span>T
<span class="math inline">\(的情况）组成一个SCC（为啥呢？首先\)</span>S
<span class="math inline">\(能到达它们，其次由于是最小割，因此这个点一定到达不了\)</span>T
<span class="math inline">\(，而原本是可以到达\)</span>T <span class="math inline">\(的，假设这个点是\)</span>x <span class="math inline">\(，那么一定是原本存在一条\)</span>S x T <span class="math inline">\(的路径被割掉了，也就是现在一定存在一条\)</span>x S
<span class="math inline">\(的路径）。最小割包含的边一定是这个集合和其它集合交界处的边。这是为啥呢？首先这些边一定组成了原图的一个割，其次，我们发现割不可能存在\)</span>S
<span class="math inline">\(所在SCC中，而割掉完全不连接\)</span>S <span class="math inline">\(的边可以发现不如割其中一个点在\)</span>S
$所在SCC的边。</p>
<h5><span id="example1luogup4313-文理分科">Example1(luoguP4313 文理分科)</span></h5>
<p>先把所有的满意值全部吃下,然后考虑放弃哪些.</p>
<p>对于每个人$u <span class="math inline">\(,将\)</span>S <span class="math inline">\(向他连一条流量为\)</span>art <span class="math inline">\(的边,它向\)</span>T <span class="math inline">\(连一条为\)</span>science
$的边,表示它自己要么放弃文科,要么放弃理科.</p>
<p>然后再对每个点建立一个虚点$u ’ <span class="math inline">\(,\)</span>S <span class="math inline">\(向\)</span>u ’ <span class="math inline">\(连一条为\)</span>sameart <span class="math inline">\(的边,\)</span>u ’ <span class="math inline">\(向相邻的实点连\)</span><span class="math inline">\(的边,表示要么放弃\)</span>sameart <span class="math inline">\(,要么那些点全都放弃理科.\)</span>samescience
$是同理的.</p>
<p>从这也可以看出来,大部分最小割的题目其实就是将冲突的选项放到一条路径中,然后考虑放弃哪些,将这个限制用最小割表示出来.</p>
<h5><span id="example2hnoi2013切糕">Example2([HNOI2013]切糕)</span></h5>
<p>也是显然的最小割,唯一难处理的地方在于相差$D $.</p>
<p>这个怎么做呢?建图后先每一竖轴都变成了一条链,我们在链之间加一些$<span class="math inline">\(的边,使得如果断开的两个点之差大于\)</span>D
$,那就可以通过这条边破坏最小割结构.</p>
<p>这题同样告诉我们:对于最小割题目中的限制条件,几乎都是需要考虑破坏最小割结构的(也有可能是用费用流限制).</p>
<h5><span id="example3uoj704">Example3(uoj704)</span></h5>
<p>二分图最小割计数.</p>
<p>先求出最小割,然后显然每个匹配的三条边一定会选择一条割掉.</p>
<p>不妨设$a _i = 0 / 1 / 2 <span class="math inline">\(表示第\)</span>i
$对匹配割掉了哪一条边.</p>
<p>考虑每个非匹配边$( u , v ) $对点权的限制:</p>
<ol type="1">
<li><p>$u <span class="math inline">\(在最大匹配\)</span>i <span class="math inline">\(中,\)</span>v <span class="math inline">\(不在.则\)</span>a _i = 0 $.</p></li>
<li><p>$v <span class="math inline">\(在最大匹配\)</span>i <span class="math inline">\(中,\)</span>u <span class="math inline">\(不在,则\)</span>a _i = 2 $.</p></li>
<li><p>$u <span class="math inline">\(在最大匹配\)</span>i <span class="math inline">\(中,\)</span>v <span class="math inline">\(在最大匹配\)</span>j <span class="math inline">\(中,则\)</span>a _i = 0 <span class="math inline">\(或\)</span>a _j = 2 $.</p></li>
</ol>
<p>前两种是好处理的,考虑第三种:显然所有都选$2 $或所有都选$0 <span class="math inline">\(是一种方案,更进一步地,我们将\)</span>i j
$,那么在一个强连通分量中的点一定都是$2 $或都是$0
$.这样可以缩点,缩点后发现DAG上的每一条路径的染色都形如$0 , 0 , 0 , , 0 ,
( 1 ) , 2 , , 2 , 2 , 2 $.</p>
<p>不妨折半搜索,按照拓扑排序,确定前一半哪些是$0 $,剩下是$1 / 2
$,那他们的后继必然全都是$2 $,这样后面的是$2
$的集合一定是这个后继集合的超集,高维后缀和.</p>
<p>接下来只需要判断哪些位置可以选$1 $.相当于前驱全都是$0
$并且后继全都是$2 $.</p>
<h4><span id="二分图匹配">二分图匹配</span></h4>
<h4><span id="二分图最小点覆盖">二分图最小点覆盖</span></h4>
<p>二分图最小点覆盖$= $二分图最小割.</p>
<p>问题在于如何求解方案.</p>
<p>我们从左侧的非匹配点开始dfs,走还有残留流量的路径.并将路径上所有的点全都打上标记.那么左侧所有的未标记点和右侧所有的标记点就是一组合法的方案.</p>
<p>这是为啥呢?首先我们注意到,左侧的非匹配点一定会被标记,右侧的非匹配点一定不会被标记.</p>
<p>为啥右侧的非匹配点一定不会被标记呢?因为如果被标记了,从左侧非匹配点到右侧非匹配点这条路径的起始边和终边就都是非匹配边,显然是一条增广路.</p>
<p>然后我们又注意到:对于一组匹配点,要么两者都被标记,要么两者都不被标记,因为一旦走到了右侧点,下一步必然走向左侧点.而如果走到了左侧点,也必然是从右侧点走过来的.</p>
<p>接下来我们讨论一下:</p>
<p>对于非匹配边,由于其必然连了一个左侧非匹配点,所以它的右边必然被选择了.</p>
<p>对于匹配边,不难发现它会被某个匹配点覆盖掉.</p>
<p>于是得证.</p>
<p>当然,上面的证明略显啰嗦.事实上我们这么考虑:</p>
<p>首先,我们按照套路,求出$S <span class="math inline">\(所有能到达的点.根据二分图的性质,这个点的集合必然不包括\)</span>T
$.</p>
<p>然后我们取所有不在这个点集的左侧点和所有在这个点集的右侧点,这样所有的点被分为了四个部分,边也自然被分为了四个部分,讨论一下就知道这四个部分中有一个部分是不存在边的.于是得证.</p>
<h4><span id="二分图最大独立集">二分图最大独立集</span></h4>
<p>二分图最大独立集$= n - $二分图最小点覆盖.</p>
<h5><span id="example1cf1404e">Example1(CF1404E)</span></h5>
<p>在两个可选矩形的边界处建立一个点,如果它被选了,那么说明这个矩形和上面那个矩形被一起覆盖了.然后注意到每有一个点被选,自然就多覆盖了一个矩形,显然一个矩形不可能又跟纵向的一起被覆盖又跟横向的一起被覆盖,在他俩之间连边跑最大独立集即可.</p>
<p>感觉还是类似于最小路径覆盖,将这种两个一起被覆盖就减少答案的东西转换成一整条流.</p>
<h4><span id="最大权闭合子图">最大权闭合子图</span></h4>
<p>原图的边流量设为$+ <span class="math inline">\(,然后对于每个点\)</span>x <span class="math inline">\(,如果\)</span>val _x &gt; 0 <span class="math inline">\(,那么\)</span>ans + = val _x <span class="math inline">\(,然后将\)</span>S x <span class="math inline">\(,流量为\)</span>val _x <span class="math inline">\(;不然,\)</span>x T <span class="math inline">\(,流量为\)</span>- val _x <span class="math inline">\(,然后求出最小割\)</span>w <span class="math inline">\(,答案即为\)</span>ans - w $.</p>
<h5><span id="example1luogup4177">Example1(luoguP4177)</span></h5>
<p>只需要把中间的$$边改为租用的代价即可.</p>
<h4><span id="最小路径覆盖覆盖点">最小路径覆盖(覆盖点)</span></h4>
<p>将每个点$x <span class="math inline">\(拆为两个点\)</span>A _x <span class="math inline">\(,\)</span>B _x <span class="math inline">\(,将\)</span>S <span class="math inline">\(向所有\)</span>A <span class="math inline">\(连边,\)</span>B <span class="math inline">\(向\)</span>T <span class="math inline">\(连边,如果图中存在一条路径\)</span>x y <span class="math inline">\(,则连边\)</span>A _x B _y $,流量均为$1 <span class="math inline">\(,然后求出最大流\)</span>w <span class="math inline">\(,答案即为\)</span>n - w $.</p>
<p>还有一个版本是可以重复走点,做一遍传递闭包就行.因为可重复相当于原图上的可跳点,这个版本又叫最小链覆盖.</p>
<h5><span id="example1网络流24题魔术球问题">Example1([网络流24题]魔术球问题)</span></h5>
<p>枚举球数,不断在残联网络上加边并在新图跑最小路径覆盖即可.</p>
<h4><span id="最长反链">最长反链</span></h4>
<p>反链是一个点的集合,满足这个集合中的点两两不可达.</p>
<p>最长反链$= $可重复走点的最小点覆盖(最小链覆盖).</p>
<p>为啥呢?因为发现做完传递闭包后等价于新图的最大独立集.当然图是有性质的,观察一下可重复走点的最小点覆盖就可以发现等价于传递闭包后在二分图上求最大独立集.</p>
<h5><span id="example1cf1630fmaking-itbipartite">Example1([CF1630F]Making It
Bipartite)</span></h5>
<p>首先显然的一点是,对于任意一个数字$x <span class="math inline">\(,这个序列中不能同时出现\)</span>px <span class="math inline">\(和\)</span>pqx <span class="math inline">\(,其中\)</span>p , q <span class="math inline">\(都是大于等于二的正整数.这是显然的.如果我们把图改为有向图,由\)</span>x
px $,那么整个图就只会有两种点:只有出边的点和只有入边的点.</p>
<p>那么我们该怎么办呢?如果是只能出现$x <span class="math inline">\(就不能出现\)</span>px <span class="math inline">\(,那这就是一个经典的最长反链问题.但多了一层,我们可以考虑类似分层图的思想:建立和原图完全一样的图\)</span>G
’ <span class="math inline">\(,并且将\)</span>G <span class="math inline">\(中的\)</span>x <span class="math inline">\(向\)</span>G ’ <span class="math inline">\(中的\)</span>x ’
$连有向边,然后跑最长反链.不难发现这样做是正确的.</p>
<h4><span id="平面图最小割">平面图最小割</span></h4>
<p>平面图最小割$= $对偶图最短路.</p>
<h4><span id="最小费用任意流">最小费用任意流</span></h4>
<p>一般费用流,但是当当前增广路代价为正的就停止增广.</p>
<p>和最小费用最大流不一样,这玩意是可以增量的.</p>
<p>只需要考虑所有新的从源到汇的增广路以及增加过程出现的负环即可.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<p>费用流模型很好建立,问题在于这个东西好像跑费用流有点慢.</p>
<p>那咋办呢?我们考虑到费用流是有凸性的.所以搭配一下wqs二分.</p>
<p>然后分一下三种情况讨论:</p>
<ol type="1">
<li><p>直接$S T <span class="math inline">\(的负增广路,相当于选取最小的\)</span>b <span class="math inline">\(和当前的\)</span>a $搭配.</p></li>
<li><p>有一条$S a b a S <span class="math inline">\(的负环,相当于以当前的\)</span>a <span class="math inline">\(代替前面的某个较大的\)</span>a $.</p></li>
<li><p>有一条$S a b T b a S <span class="math inline">\(的负环,注意到这个环必然没意义,因为不可能存在一条\)</span>T
S <span class="math inline">\(的负路径(不然反路径就是正的,而最小费用任意流不可能流正路径),所以这种情况不如直接选\)</span>S
T $的路径.</p></li>
</ol>
<p>讨论完拿堆模拟一下就行.</p>
<p>这引出了著名的模拟费用流算法.</p>
<h4><span id="负费用最小流">负费用最小流</span></h4>
<p>一般费用流,但是当增广当前增广路时费用变成正的就停止增广.</p>
<p>注意如果两条增广路代价相同选流量大的那条.</p>
<h4><span id="有负环的费用流">有负环的费用流</span></h4>
<p>首先注意到:如果初始图没有负环,那无论后面怎么流都不可能出来负环.因为这意味着要么是一开始流了个正环,要么是一开始有负路径不走走正路径,都不太可能.</p>
<p>对于所有的负边$u v <span class="math inline">\(,我们建立两个新点\)</span>S ’ <span class="math inline">\(和\)</span>T ’ <span class="math inline">\(,我们先将这条负边反向权值取相反数并让答案加上\)</span>f
v <span class="math inline">\(,之后令\)</span>u T ’ , S ’ v <span class="math inline">\(,跑\)</span>S ’ T ’ <span class="math inline">\(的费用流,这个时候再在残联网络上跑\)</span>s t
$的费用流就是答案.</p>
<p>为啥会这样呢?</p>
<p>首先先证明正确性,这个东西相当于一开始跑了一下$T ’ u v S ’ <span class="math inline">\(的图.然后我们在跑\)</span>S ’ T ’ <span class="math inline">\(的时候一定是可以把上面的那个东西所从\)</span>T ’ S
’
$的所有流量全都退回去,因为这是一个可以构造的上界.也就相当于我们跑了一个环流.而在费用流里跑环流显然是不会影响答案的.</p>
<p>好,那么为啥这么做就不会出现负环了呢?因为你不可能在跑$S ’ T ’
$的时候跑个正环出来,自然不可能出现负环.</p>
<p>另外有一点是,一个点可能向$S ’ <span class="math inline">\(或\)</span>T ’
$连很多边,其实是可以拼掉的,因为这些边全都是零权边,而构造完后的图是非负权边.</p>
<h4><span id="模拟费用流">模拟费用流</span></h4>
<p>对于特殊的图,模拟EK费用流的增广过程并进行操作.</p>
<p>对着例题记吧.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<h4><span id="散题">散题</span></h4>
<h5><span id="example1cqoi2014危桥">Example1([CQOI2014]危桥)</span></h5>
<p>有一个朴素的想法是:我们直接按题意建图,然后$S a _1 , b _1 <span class="math inline">\(,\)</span>T a _2 , b _2
$,跑最大流然后检查是否满流.</p>
<p>问题在于,这样有可能会出现$a _1 b _2
$的流量,我们怎么避免这种情况呢?</p>
<p>做法是,我们交换$b _1 , b _2
$并重复上面的过程,如果还是满流,我们声明一定合法.</p>
<p>为什么呢?我们注意到此时网络上的流量分为四种:$a _1 a _2 <span class="math inline">\(,\)</span>a _1 b _2 <span class="math inline">\(,\)</span>b _1 a _2 <span class="math inline">\(,\)</span>b _1 b _2 <span class="math inline">\(.不难发现\)</span>a _1 b _2 <span class="math inline">\(和\)</span>b _1 a _2 $的流量是相等的.</p>
<p>在第二次跑网络流时,我们不妨直接将$a _1 a _2 <span class="math inline">\(和\)</span>b _2 b _1 <span class="math inline">\(的流量加入答案并将这两条路径反向.此时,如果\)</span>a
_1 <span class="math inline">\(还是要走到\)</span>b _1 <span class="math inline">\(,你发现第一轮的时候已经找到了一条\)</span>b _1 a
_2 <span class="math inline">\(的路径,我们一定可以走这条来构造出只有\)</span>a _1
a _2 $的路径,另一边同理.</p>
<h3><span id="图的计数问题">图的计数问题</span></h3>
<h4><span id="prufer序列">Prufer序列</span></h4>
<p>我们可以将一颗有编号$n <span class="math inline">\(个点(\)</span>n
<span class="math inline">\()的无根树与一个长度为\)</span>n - 2 <span class="math inline">\(的Prufer序列建立双射.换句话说,一颗有编号\)</span>n
<span class="math inline">\(个节点的无根树总共有\)</span>n ^{ n - 2 }
$种(Cayley公式).</p>
<p>首先证明一个树可以对应到一个序列:每次选择一个度数为$1 <span class="math inline">\(的编号最小的点,把它连向的点加到序列中并把这个点删去,直到最后只剩下两个节点,这样我们就把一棵树对应到一个序列.不难发现每个点出现的次数是其度数\)</span>-
1 $.</p>
<p>然后证明一个序列可以还原成一棵树:</p>
<p>我们可以通过序列得知每个点的度数,每次找到度数中最小的那个点并把它与序列中的第一个元素连边并删去序列中的第一个元素,不断这么做显然可以还原树.</p>
<h5><span id="example">Example</span></h5>
<p>一个$n <span class="math inline">\(个点的图有\)</span>k <span class="math inline">\(个连通块,现在加入\)</span>k - 1
$条边使得图连通,求方案数.</p>
<p>令$s _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(个连通块的点数,\)</span>d _i <span class="math inline">\(为第\)</span>i <span class="math inline">\(个连通块所新连上的边数,如果我们令\)</span> { c _1
, c _2 , . . . , c _m } = { c _1 ! c _2 ! . . . c <em>m ! } , </em>{ i =
1 } ^m c _i = n \ <span class="math inline">\(,也即将\)</span>n <span class="math inline">\(个位置拆分成\)</span>m <span class="math inline">\(个集合,第\)</span>i <span class="math inline">\(个集合有\)</span>c _i $个位置的方案数.</p>
<p>那我们所需要做的也就是枚举每个连通块所新连出的边数$d _i <span class="math inline">\(,于是答案即\)</span>_d [ d _i = 2 k - 2 ] { d _1 -
1 , d _2 - 1 , . . . , d <em>k - 1 } </em>{ i = 1 } ^k s _i ^{ d _i } \
$.</p>
<p>注意到我们有多项式定理:$( x _1 + x _2 + . . . + x <em>m ) ^n = </em>{
c } [ c _i = n ] { c _1 , c _2 , . . . , c <em>m } </em>{ i = 1 } ^m x
_i ^{ c _i } \ $.</p>
<p>于是原式$= n ^{ k - 2 } _{ i = 1 } ^k s _i $.</p>
<h4><span id="prufer序列的矩阵树定理理解">Prufer序列的矩阵树定理理解</span></h4>
<p>事实上,Prufer序列其实是可以拿矩阵树定理代替的(但是更麻烦一点).</p>
<p>我们先考虑证明Cayley公式:构造矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>其主余子式为:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>将所有行全部加到第一行:</p>
<p><span class="math display">\[
\begin{bmatrix}
- 1 &amp; - 1 &amp; \cdots &amp; - 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>全部加下来,然后就成了上三角矩阵,将对角线乘起来就是$n ^{ n - 2 }
$.</p>
<p>连通块的结论是类似的.</p>
<h4><span id="lgv引理">LGV引理</span></h4>
<p>设$G <span class="math inline">\(是一个有限的带权有向无环图,有点集\)</span>V <span class="math inline">\(的一个大小为\)</span>n <span class="math inline">\(的子集\)</span>A = { a _1 , a _2 , . . . , a _n }
<span class="math inline">\(作为起点集合,一个大小为\)</span>n <span class="math inline">\(的子集\)</span>B = { b _1 , b _2 , . . . , b _n }
$作为终点集合.</p>
<p>记边$i <span class="math inline">\(的权值为\)</span>w <em>i <span class="math inline">\(.对于有向路径\)</span>p <span class="math inline">\(,记路径上所有边的边权的乘积为\)</span>W ( p )
<span class="math inline">\(.记\)</span>e ( u , v ) = </em>{ p : u v } W
( p ) <span class="math inline">\(,即从\)</span>u <span class="math inline">\(到\)</span>v $的所有路径的边权乘积之和.</p>
<p>记$P : A B = ( p _1 , p _2 , . . . , p _n ) <span class="math inline">\(,\)</span>p _i <span class="math inline">\(表示从\)</span>a <em>i <span class="math inline">\(到\)</span>b </em>{ ( i ) } <span class="math inline">\(的一条路径,其中\)</span><span class="math inline">\(是一个排列,记\)</span>sign ( ) <span class="math inline">\(为\)</span>- 1 <span class="math inline">\(以这个排列的逆序对数量为幂的值.又记\)</span>( P )
<span class="math inline">\(为\)</span>P <span class="math inline">\(所对应终点的排列.若满足\)</span> i , j n , i j
<span class="math inline">\(,\)</span>p <em>i <span class="math inline">\(与\)</span>p <em>j <span class="math inline">\(没有公共点,则记作\)</span>P ^u <span class="math inline">\(,否则记作\)</span>P ^c <span class="math inline">\(,若不作区分记作\)</span>P <span class="math inline">\(.记\)</span>W </em>{ all } ( P ) = </em>{ i = 1 }
^n W ( p _i ) \ $,也就是所有路径的乘积.</p>
<p>设矩阵$M <span class="math inline">\(满足\)</span>M _{ i , j } = e (
a _i , b _j ) $,那么有:</p>
<p><span class="math display">\[
\det M = \sum _{ P ^u : A \rightarrow B  } sign ( \sigma ( P ^u ) ) W _{
all  } ( P ^u )
\]</span></p>
<p>证明:</p>
<p>根据行列式的定义,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\det M &amp; = \sum _{ \sigma  } sign ( \sigma ) \prod _{ i = 1  } ^n e
( a _i , b _{ \sigma ( i )  } ) \\
&amp; = \sum _{ \sigma  } sign ( \sigma ) \prod _{ i = 1  } ^n \sum _{ p
_i : a _i \rightarrow b _{ \sigma ( i )  }  } w ( p _i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑后面那部分,$<em>{ i = 1 } ^n </em>{ p _i : a <em>i b </em>{ ( i )
} } w ( p _i ) \ <span class="math inline">\(形如一个卷积的形式,所以这个式子等价于所有对应排列为\)</span><span class="math inline">\(的\)</span>P <span class="math inline">\(的\)</span>w ( P ) $,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\det M &amp; = \sum _{ \sigma  } sign ( \sigma ) ( \sum _{ P : \{ a _1 ,
. . . , a _n \} \rightarrow \{ b _{ \sigma ( 1 )  } , . . . , b _{
\sigma ( n )  } \}  } w ( P ) ) \\
&amp; = \sum _{ P : A \rightarrow B  } sign ( \sigma ( P ) ) w ( P ) \\
&amp; = \sum _{ P ^u : A \rightarrow B  } sign ( \sigma ( P ^u ) ) w ( P
^u ) + \sum _{ P ^c : A \rightarrow B  } sign ( \sigma ( P ^c ) ) w ( P
^c )
\end{aligned}
\]</span></p>
<p>接下来只需证明$_{ P ^c : A B } sign ( ( P ^c ) ) w ( P ^c ) = 0 \
$即可.</p>
<p>设所有$P ^c <span class="math inline">\(组成的集合为\)</span>E <span class="math inline">\(,考虑构造一个映射\)</span>f : E E
$满足如下条件:</p>
<ol type="1">
<li><p>$f ( P ^c ) P ^c $.</p></li>
<li><p>$f ( f ( P ^c ) ) = P ^c $.</p></li>
<li><p>$w ( f ( P ^c ) ) = w ( P ^c ) $.</p></li>
<li><p>$sign ( f ( P ^c ) ) = - sign ( P ^c ) $.</p></li>
</ol>
<p>上面的结论即得证.</p>
<p>我们不妨考虑$P ^c <span class="math inline">\(中的第一对相交的路径\)</span>p _i <span class="math inline">\(和\)</span>p _j
$,并交换它们的终点.显然满足上述条件,于是结论得证.</p>
<h5><span id="example">Example</span></h5>
<p>现在有$n <span class="math inline">\(个点,第\)</span>i <span class="math inline">\(个点位于\)</span>( a _i , 1 ) <span class="math inline">\(,需要走到\)</span>( b _i , n ) <span class="math inline">\(.一个在\)</span>( x , y ) <span class="math inline">\(的点可以走向\)</span>( x + 1 , y ) <span class="math inline">\(或\)</span>( x , y + 1 )
$.求路径不相交的方案数.</p>
<p>路径不相交,则终点排列只有可能是${ 1 , 2 , . . . , n }
$,直接使用LGV引理即可.</p>
<h4><span id="矩阵树定理">矩阵树定理</span></h4>
<h5><span id="无向图情况">无向图情况</span></h5>
定义无向图的度数矩阵$D ( G ) <span class="math inline">\(为:\)</span>D (
G ) _{ i , j } =
<span class="math display">\[\begin{cases}0 &amp; i \ne j \\ \deg _{
i  } &amp; i = j \end{cases}\]</span>
<p>$.</p>
令$w ( i , j ) <span class="math inline">\(为\)</span>i <span class="math inline">\(与\)</span>j <span class="math inline">\(之间直接相连的无向边个数,定义无向图的邻接矩阵\)</span>A
( G ) _{ i , j } =
<span class="math display">\[\begin{cases}0 &amp; i = j \\ w ( i , j )
&amp; i \ne j \end{cases}\]</span>
<p>$</p>
<p>定义无向图的基尔霍夫矩阵(又称拉普拉斯矩阵)$L ( G ) = D ( G ) - A ( G
) $.</p>
<p>记$t ( G ) <span class="math inline">\(为图\)</span>G <span class="math inline">\(的生成树个数,那么有:\)</span>t ( G )
$等于基尔霍夫矩阵任意一个主余子式.</p>
<p>引理:无向图的基尔霍夫矩阵的任意一个代数余子式都相等.</p>
<p>证明:考虑删去第$i <span class="math inline">\(行,设剩下的矩阵为\)</span>A = [ _1 , _2 , . . . ,
_n ] <span class="math inline">\(,根据基尔霍夫矩阵的性质,不难发现\)</span> = <span class="math inline">\(.\)</span> j &lt; k n <span class="math inline">\(,如果我们删去第\)</span>j <span class="math inline">\(列,考虑将除了第\)</span>k <span class="math inline">\(列的其它列全部加到第\)</span>k <span class="math inline">\(列,于是得到矩阵\)</span>[ <em>1 , . . . , </em>{ j
- 1 } , <em>{ j + 1 } , . . . , </em>{ k - 1 } , - <em>j , </em>{ k + 1
} , . . . , _n ] <span class="math inline">\(.我们接下来一路将第\)</span>k <span class="math inline">\(列交换到第\)</span>j + 1 <span class="math inline">\(列之前并取反,我们就得到了删去第\)</span>k <span class="math inline">\(列的矩阵,于是有\)</span>M <em>{ i , j } = ( - 1 )
^{ 1 + ( k - 1 ) - ( j + 1 ) + 1 } M </em>{ i , k } <span class="math inline">\(,也就是\)</span>C <em>{ i , j } = C </em>{ i , k }
<span class="math inline">\(,同理可证明\)</span>C <em>{ j , i } = C
</em>{ k , i } $.</p>
<p>接下来,用$T <span class="math inline">\(表示生成树的边的集合,设\)</span>w ( T ) = <em>{ e
T } w ( e ) <span class="math inline">\(,我们只需证明\)</span>C </em>{ 1
, 1 } = w ( T ) $.</p>
定义$( e , u ) = v , e = { u , v } <span class="math inline">\(,考虑构造一个\)</span>n m <span class="math inline">\(的矩阵\)</span>A <span class="math inline">\(满足\)</span>A _{ i , j } =
<span class="math display">\[\begin{cases}1 &amp; i \in e _j \land i
&lt; \zeta ( e _j , i ) \\ - 1 &amp; i \in e _j \land i &gt; \zeta ( e
_j , i ) \\ 0 &amp; other \end{cases}\]</span>
<p>\ $.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
AA ^T ( i , j ) &amp; = \sum _{ k = 1  } ^m A ( i , k ) A ^T ( k , j )
\\
&amp; = \sum _{ k = 1  } ^m A ( i , k ) A ( j , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>当$i = j <span class="math inline">\(时,不难发现\)</span>AA ^T ( i ,
j ) = _{ k = 1 } ^m [ i e _k ] = <em>i <span class="math inline">\(.不然,注意到显然为\)</span>- </em>{ k = 1 } ^m [ i
e _k ] [ j e _k ] <span class="math inline">\(.也就是说,\)</span>AA ^T =
L $.</p>
<p>定义$A <span class="math inline">\(删去第一行后得到的矩阵为\)</span>B
<span class="math inline">\(,则\)</span>BB ^T = M _{ 1 , 1 }
$.此时我们带入Cauchy-Binet公式,得到:</p>
<p><span class="math display">\[
\begin{aligned}
M _{ 1 , 1  } &amp; = \sum _{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . .
. , m \}  } \det ( B [ S ] B ^T [ S ] ) \\
&amp; = \sum _{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . . . , m \}  }
\det ( B [ S ] ) ^2
\end{aligned}
\]</span></p>
<p>接下来我们需要证明:如果$S <span class="math inline">\(集合构成了一棵生成树,那么\)</span>B [ S ] = <span class="math inline">\(.反之,\)</span>B [ S ] = 0 $.</p>
<p>如果集合没有构成一个生成树,则至少存在一个简单环.如果有某个点是孤立点那么答案肯定是$0
$,因此只需考虑每个点都与边连通的情况即可.</p>
<p>考虑这种情况下,如果有两条边$( u _1 , u _2 ) <span class="math inline">\(和\)</span>( u _2 , u _3 ) <span class="math inline">\(被选上了,那么我们可以通过列变换将它们改为\)</span>(
u _1 , u _2 ) <span class="math inline">\(和\)</span>( u _1 , u _3 )
$.这样不断进行下去,如果存在环,一定会出现重边选择的情况,这个时候行列式的值为$0
<span class="math inline">\(.如果不存在环,那么我们可以通过这个操作得到一个菊花图.所以行列式为\)</span>
$.</p>
<p>所以定理得证.</p>
<h6><span id="example省选联考-2020-a卷作业题">Example([省选联考 2020 A
卷]作业题)</span></h6>
<p>给定一个图,设第$i <span class="math inline">\(条边的权值为\)</span>w
<em>i <span class="math inline">\(,求所有生成树的\)</span>( w <em>1 , .
. . , w </em>{ n - 1 } ) </em>{ i = 1 } ^{ n - 1 } w _i $之和.</p>
<p>首先前面的$<span class="math inline">\(可以使用\)</span>I = id
$来处理.于是剩下的问题在于我们如何将一个生成树的边的和代替乘积作为贡献来求和.</p>
<p>不妨进行扩域,令$j ^2 = 0 , j <span class="math inline">\(,这样我们可以类比复数来将每个数写作\)</span>a + bj
<span class="math inline">\(的模式.考虑将每条边的边权改为\)</span>w _i j
+ 1 <span class="math inline">\(并定义新域的四则运算,取最后得到的数\)</span>a + bj
<span class="math inline">\(的\)</span>b $作为答案即可.</p>
<p>另外,注意到这样做复杂度$wn ^3 <span class="math inline">\(,很难通过.考虑每次只当边数大于等于\)</span>n - 1
<span class="math inline">\(的时候再跑行列式.不妨设\)</span>( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(的因数个数,考虑如果因数很分散,那肯定复杂度很低,不然,我们有复杂度\)</span>O
( n ^3 { n - 1 } ) $,可以通过.</p>
<h6><span id="example北京省选集训2019生成树计数">Example([北京省选集训2019]生成树计数)</span></h6>
<p>给定一个图,设第$i <span class="math inline">\(条边的权值为\)</span>w
<em>i <span class="math inline">\(,求所有生成树的\)</span>( </em>{ i = 1
} ^{ n - 1 } w _i ) ^k $之和.</p>
<p>考虑将第$e <span class="math inline">\(条边边权改为\)</span>_{ i = 0
} ^k { i ! } <span class="math inline">\(.根据多项式定理,显然最后取\)</span>[ x ^k ] <span class="math inline">\(并乘以\)</span>k ! $即可.</p>
<h5><span id="有向图情况">有向图情况</span></h5>
定义有向图的出度矩阵$D ^{ out } ( G ) =
<span class="math display">\[\begin{cases}0 &amp; i \ne j \\ \deg ^{
out  } _i &amp; i = j \end{cases}\]</span>
<p><span class="math inline">\(,类似地可以定义入度矩阵\)</span>D ^{ in }
( G ) $.</p>
令$cnte ( i , j ) <span class="math inline">\(为从\)</span>i <span class="math inline">\(直接连向\)</span>j <span class="math inline">\(的有向边个数,定义有向图的邻接矩阵\)</span>A ( G )
_{ i , j } =
<span class="math display">\[\begin{cases}0 &amp; i = j \\ cnte ( i , j
) &amp; i \ne j \end{cases}\]</span>
<p>$</p>
<p>定义有向图的出度基尔霍夫矩阵$L ^{ out } ( G ) = D ^{ out } ( G ) - A
( G ) <span class="math inline">\(,同理可以定义其入度基尔霍夫矩阵\)</span>L ^{ in }
( G ) $.</p>
<p>记$t ^{ root } ( r , G ) <span class="math inline">\(为图\)</span>G
<span class="math inline">\(以\)</span>r <span class="math inline">\(为根的根向生成树(\)</span>r <span class="math inline">\(为根时,所有边都从儿子指向父亲)个数,同理可以定义叶向生成树个数\)</span>t
^{ leaf } ( r , G ) $.</p>
<p>设$M ^{ out } <em>{ r , r } <span class="math inline">\(为\)</span>L
^{ out } <span class="math inline">\(的主余子式,有\)</span>t ^{ root } (
r , G ) = M ^{ out } </em>{ r , r } $.叶向同理.</p>
<p>下面只简单提到根向生成树的证明,叶向同理.</p>
<p>类似于无向图,我们考虑构造$n m <span class="math inline">\(矩阵\)</span>A <span class="math inline">\(和\)</span>( n - 1 ) m <span class="math inline">\(矩阵\)</span>B $:</p>
<p><span class="math display">\[
\begin{aligned}
A _{ i , j  } &amp; = \begin{cases}
1 &amp; e _j &#39; s \ head \ is \ i \\
- 1 &amp; e _j &#39; s \ tail \ is \ i \\
0 &amp; other
\end{cases} \\
B _{ i , j  } &amp; = \begin{cases}
1 &amp; e _j &#39; s \ head \ is \ i \\
0 &amp; other
\end{cases}
\end{aligned}
\]</span></p>
<p>剩下的部分与无向图类似.</p>
<h4><span id="best定理">BEST定理</span></h4>
<p>设$ec ( G ) <span class="math inline">\(为有向图\)</span>G
$的欧拉回路个数,若其存在欧拉回路,则:</p>
<p><span class="math display">\[
ec ( G ) = t ^{ root  } ( G , x ) \prod _{ i = 1  } ^n ( \deg _i - 1 ) !
\]</span></p>
<p>其中$_i = ^{ in } _i = _i ^{ out } $.</p>
<p>考虑如果勒令以$x <span class="math inline">\(为起点,我们保留除了\)</span>x <span class="math inline">\(以外每个点的最后经过的出边,最后一定会形成一棵根向树.而其他点可以随便选(由于我们勒令了每个点存在一个出边,所以不可能走到死胡同),这样的答案是\)</span>t
^{ root } ( G , x ) <em>x </em>{ i = 1 } ^n ( _i - 1 ) ! $.</p>
<p>但是如果没有规定起点,考虑循环重构,在我们选择不同的边当作初始边时,只需循环一下总体的顺序,就可以得到以另一条边为初始边的另一个图,所以答案要比规定起点的答案多除一个$_x
$.</p>
<h4><span id="格路计数问题">格路计数问题</span></h4>
<h5><span id="定义">定义</span></h5>
<ol type="1">
<li><p>在平面直角坐标系中,横坐标和纵坐标都是整数的点称为格点,平面格路是指从一个格点到另一格点只走格点的路,格路的长度是指其所走的路的步数.</p></li>
<li><p>对于一条从$( 0 , 0 ) <span class="math inline">\(到\)</span>( n ,
m ) <span class="math inline">\(的格路,若其只使用了上步\)</span>U = ( 0
, 1 ) <span class="math inline">\(,右步\)</span>L = ( 1 , 0 ) <span class="math inline">\(,则我们称其为\)</span>( n , m ) $自由路.</p></li>
<li><p>记$ ( n , m ) <span class="math inline">\(为\)</span>( n , m )
<span class="math inline">\(自由路的集合,\)</span>F ( n , m ) = # ( n ,
m ) <span class="math inline">\(为\)</span>( n , m ) <span class="math inline">\(自由路数量,即\)</span> ( n , m ) <span class="math inline">\(的元素个数,显然\)</span>F ( n , m ) = { n } \
$.</p></li>
<li><p>对于一条从$( 0 , 0 ) <span class="math inline">\(到\)</span>( n ,
m ) <span class="math inline">\(的自由路,若其始终不经过对角线\)</span>y
= { n } x <span class="math inline">\(下方,则我们称之为\)</span>( n , m
) - Dyck $路.</p></li>
<li><p>记$ ( n , m ) <span class="math inline">\(为\)</span>( n , m )
<span class="math inline">\(自由路的集合,\)</span>D ( n , m ) = # ( n ,
m ) <span class="math inline">\(为\)</span>( n , m ) <span class="math inline">\(自由路数量,即\)</span> ( n , m )
$的元素个数.</p></li>
<li><p>对于从$( 0 , 0 ) <span class="math inline">\(到\)</span>( n , m )
$的$2 <span class="math inline">\(条格路\)</span>P , Q <span class="math inline">\(,其中\)</span>P = u _1 u <em>2 . . . u </em>{ n +
m } , Q = v _1 v <em>2 . . . v </em>{ n + m } ( u <em>i , v <em>i , i =
1 , 2 , . . . , n + m ) $.若 $i , u </em>{ i + 1 } . . . u </em>{ n + m
} u _1 . . . u _i = v _1 v <em>2 . . . v </em>{ n + m } <span class="math inline">\(,则我们称格路\)</span>P , Q <span class="math inline">\(等价.将\)</span>P <span class="math inline">\(的等价格路全集记为\)</span>[ P ] $.</p></li>
<li><p>对于任意格路$P <span class="math inline">\(,记\)</span>P <em>k =
u </em>{ k + 1 } . . . u _{ n + m } u _1 . . . u _k <span class="math inline">\(,则\)</span>[ P ] = { P _k | k = 1 , 2 , 3 , · · ·
, n + m } <span class="math inline">\(.定义\)</span>P <span class="math inline">\(的周期为使得\)</span>P = P _k <span class="math inline">\(的最小数\)</span>k <span class="math inline">\(，用\)</span>period ( P ) <span class="math inline">\(表示,则显然有\)</span># [ P ] = period ( P )
$.</p></li>
</ol>
<h5><span id="定理">定理</span></h5>
<h4><span id="散模型">散模型</span></h4>
<h5><span id="多叉堆计数">多叉堆计数</span></h5>
<p>有一棵树,要求给每个点一个$[ 1 , n ]
$的权值且不同的点权值不同,满足父亲的权值小于儿子的权值,求方案数.</p>
<p>不妨设以$u <span class="math inline">\(为根节点的子树方案数为\)</span>f _u <span class="math inline">\(,\)</span>u <span class="math inline">\(的儿子是\)</span>v _1 , . . . , v _k <span class="math inline">\(,注意到\)</span>f <em>u = { siz </em>{ v <em>1 } ,
siz </em>{ v <em>2 } , . . . , siz </em>{ v <em>k } } f </em>{ v _i } =
( siz <em>u - 1 ) ! </em>{ u v } { siz _v ! } \ $.</p>
<p>那么考虑根的答案$f _1 <span class="math inline">\(,考虑不断将\)</span>f _1 <span class="math inline">\(中含有的其它\)</span>f _u $向下展开,自然的,除了$1
<span class="math inline">\(号点外,每个点对答案都贡献了一个\)</span> {
siz } <span class="math inline">\(,而根的贡献是\)</span>( n - 1 ) !
$.</p>
<p>也就是说,$ans = ( n - 1 ) ! _{ u = 2 } ^n { siz <em>u } = n ! </em>{
u = 1 } ^n { siz _u } \ $.</p>
<h6><span id="example1agc060c-large-heap">Example1([AGC060C] Large Heap)</span></h6>
<p>如果没有限制,就是一个简单的多叉堆计数.</p>
<p>而有了限制怎么做呢?我们考虑把$u $到$1 <span class="math inline">\(的路径和\)</span>v $到$1 <span class="math inline">\(的路径归并起来,会得到一条长链.我们只要确定了长链上的元素,通过组合数以及二叉堆计数,自然可以算出不在长链上的元素的答案.而对于长链上的元素,我们可以直接设计一个\)</span>O
( n ^2 ) $的dp即可.</p>
<h6><span id="example2heoi2013sao">Example2([HEOI2013]SAO)</span></h6>
<p>显然给出的是一张树形图,然后每条边有一个限制表示这条边所连接的两个点哪个更大.现在给每个点一个$[
1 , n ] $的权值且不同的点权值不同求方案数.</p>
<p>我们随便找一个点然后当成有根树做,然后如果只有父亲小于儿子的边就是简单的多叉堆计数.不然,我们可以做一个简单容斥.这样问题就又转化回多叉堆计数,容斥部分写一个树形dp就好.</p>
<p>补一下,这个树形dp没有那么简单.首先你注意到多叉堆计数是跟子树大小有关系的,所以你不能简单地设计$f
<em>{ i , j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(子树内选中了\)</span>j <span class="math inline">\(条边的代价,你必须加一维来处理子树大小,也就是设\)</span>f
</em>{ u , siz , cnt } <span class="math inline">\(表示\)</span>u <span class="math inline">\(所在连通块大小为\)</span>siz <span class="math inline">\(,子树中总共选择了\)</span>cnt $条边的代价.</p>
<p>但是注意到这题的容斥系数是$( - 1 ) ^k <span class="math inline">\(,其中\)</span>k <span class="math inline">\(是选择的儿子小于父亲的数量,然后其它的要求儿子大于父亲的边随便选.你发现你选中了一条边,无非是对答案乘以一个\)</span>-
1 <span class="math inline">\(,这是没有必要记录的.因此直接以\)</span>f
_{ u , siz } $的状态转移就行.</p>
<p>这个故事告诉我们别什么容斥都最后算,你能在做的过程中把$- 1
$乘上去就别惦记最后统一求和了.</p>
<h5><span id="三元环计数">三元环计数</span></h5>
<p>我们对原图建立一个新的有向图,在新图中,如果$u v <span class="math inline">\(,则在原图中\)</span>u &lt; v <span class="math inline">\(或\)</span>u = v u &lt; v <span class="math inline">\(.根据自然根号,每个点的出度不会超过\)</span>O ( )
$.</p>
<p>接下来枚举原图的一条边$u v <span class="math inline">\(,只要在新的图中找到\)</span>w <span class="math inline">\(满足\)</span>u v , u w , v w <span class="math inline">\(即可.打tag做一做,复杂度\)</span>O ( n ) $.</p>
<h5><span id="四元环计数">四元环计数</span></h5>
<p>仍然类似三元环计数那样建立新图.</p>
<p>考虑原图中的两条边$u v <span class="math inline">\(和\)</span>u v ’
<span class="math inline">\(,我们考虑对四元环中度数最大的那个点\)</span>w
<span class="math inline">\(计数,对于这个\)</span>w <span class="math inline">\(统计一个tag表示形如\)</span>u v w <span class="math inline">\(的数量,每次改变\)</span>u
$的时候清空一下全图tag.</p>
<h5><span id="有标号dag计数">有标号DAG计数</span></h5>
<p>即:</p>
$$
<span class="math display">\[\begin{aligned}
f _n &amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k -
1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明见反演与容斥-子集反演-Example2.</p>
<h6><span id="example1qoj5749">Example1(qoj5749)</span></h6>
<p>注意到一个环内部不能有任何边,那么其实也就是有标号DAG计数,只不过要乘上一个斯特林数.不妨设$g
_{ n , m } <span class="math inline">\(为\)</span>n <span class="math inline">\(个点\)</span>m <span class="math inline">\(条边的答案,再设\)</span>G _n
$为其生成函数.事实上,我们自然有:</p>
$$
<span class="math display">\[\begin{aligned}
G _n &amp; = \sum _{ k = 1  } \binom { n  } { k  } \sum _{ j = 1  } ^k {
k \brack j  } ( - 1 ) ^{ j - 1  } ( 1 + z ) ^{ k ( n - k )  } G _{ n -
k  } \\
&amp; = \sum _{ k = 1  } \binom { n  } { k  } ( 1 + z ) ^{ k ( n - k
)  } G _{ n - k  } \sum _{ j = 1  } ^k { k \brack j  } ( - 1 ) ^{ j -
1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>逆用斯特林公式,如果$n $:</p>
<p><span class="math display">\[
\sum _{ i  } { n \brack i  } ( - 1 ) ^{ i - 1  } = ( - 1 ) \times ( - 1
) ^{ \overline { n  }  } = [ n = 1 ]
\]</span></p>
<p>注意到$G _1 = 1 $,于是:</p>
<p><span class="math display">\[
\begin{aligned}
G _n &amp; = n ( 1 + z ) ^{ n - 1  } G _{ n - 1  } \\
&amp; = n ! ( 1 + z ) ^{ \frac { n ( n - 1 )  } { 2  }  } \\
[ z ^m ] G _n &amp; = n ! \binom { \frac { n ( n - 1 )  } { 2  }  } {
m  }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" class="post-title-link" itemprop="url">反演与容斥</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="反演">反演</span></h2>
<p>假设有两个函数$f <span class="math inline">\(和\)</span>g <span class="math inline">\(满足:\)</span>f ( n ) = <em>{ k } a </em>{ n , k }
g ( k ) $,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( S ) &amp; = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S )
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
f ( S ) &amp; = \sum _{ S \subseteq T \subseteq U  } g ( T )
\Leftrightarrow g ( S ) &amp; = \sum _{ S \subseteq T \subseteq U  } ( -
1 ) ^{ | T | - | S |  } f ( T )
\end{aligned}
\]</span></p>
<p>证明:</p>
<p><span class="math display">\[
\begin{aligned}
g ( S ) &amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f (
T ) \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | T |  }
\sum _{ P \subseteq T  } g ( P ) \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) \sum _{ T
\subseteq S / P  } ( - 1 ) ^{ | T | + | P |  } \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) ( - 1 ) ^{
| P |  } \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T |  } \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) [ S &amp; =
P ] ( - 1 ) ^{ | P |  } \\
&amp; = g ( S )
\end{aligned}
\]</span></p>
<p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5>
<p>根据子集反演,设$cnt <em>S <span class="math inline">\(为集合为\)</span>S <span class="math inline">\(的数量,然后设\)</span>f <em>S = </em>{ S ’ S } cnt
</em>{ S ’ } <span class="math inline">\(,有:\)</span>ans = _{ S } 2 ^{
f _S } ( - 1 ) ^{ n - | S | } $.</p>
<p>做一遍高维前缀和就好,复杂度$O ( n 2 ^n ) <span class="math inline">\(,应该也可以用分治FMT无脑做到\)</span>O ( n ^2 2 ^n
) $.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5>
<p>设$f _{ i , j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(个点,其中有\)</span>j $个点的入度数为$0
$的方案数.(等一下,为撒子想到要记度数为$0
$的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这$j <span class="math inline">\(个点后,还剩下\)</span>k $个零度点.于是自然有:</p>
<p><span class="math display">\[
f _{ i , j  } = \binom { i  } { j  } \sum _{ k = 1  } ^{ i - j  } ( 2 ^j
- 1 ) ^k 2 ^{ j ( i - j - k )  } f _{ i - j , k  }
\]</span></p>
<p>等一下咧,这复杂度$O ( n ^3 ) $了,这咋办啊?</p>
<p>好像转移优化不太了,因为$k
$很难省去(在指数上).但我们注意到我们定义的时候说:$0 <span class="math inline">\(度点的数量恰好为\)</span>k
$,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少$k
$个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设$f ( n , S ) <span class="math inline">\(表示\)</span>n <span class="math inline">\(个点,其中只有\)</span>S $中的点的入度为$0 <span class="math inline">\(;类似定义\)</span>g ( n , S ) <span class="math inline">\(表示\)</span>n <span class="math inline">\(个点,至少\)</span>S $中的点的入度为$0 <span class="math inline">\(.显然我们所求也就是\)</span>g ( n , )
$,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n , S ) &amp; = 2 ^{ | S | ( n - | S | )  } g ( n - | S | ,
\emptyset ) \\
g ( n , S ) &amp; = \sum _{ S \subseteq T  } f ( n , T )
\end{aligned}
\]</span></p>
<p>对第二个式子用子集反演,有:</p>
<p><span class="math display">\[
f ( n , S ) = \sum _{ S \subseteq T  } ( - 1 ) ^{ | T | - | S |  } g ( n
, T )
\]</span></p>
<p>接下来使用反复带入大法:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , \emptyset ) &amp; = \sum _{ \emptyset \ne T  } f ( n , T ) \\
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } g ( n , S )
\\
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S |
( n - | S | )  } g ( n - | S | , \emptyset ) \\
&amp; = \sum _{ m = 1  } ^n \sum _{ | T | = m  } \sum _{ T \subseteq
S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S
| , \emptyset ) \\
&amp; = \sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n
\binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n
- m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k ,
\emptyset ) \\
&amp; = \sum _{ k = 1  } ^n \sum _{ m = 1  } ^k \binom { n  } { m  }
\binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \sum _{ m = 1  } ^k \binom { k  } { m  } ( - 1 ) ^{
k - m  } \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) ( ( 1 - 1 ) ^k - ( - 1 ) ^k ) \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) ( - 1 ) ^{ k - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到复杂度已经降到$O ( n ^2 ) $了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个$(
- 1 ) ^{ k - 1 }
$,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
$$
<span class="math display">\[\begin{aligned}
f _n &amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k -
1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是直接设,然后钦定其有至少$j $个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 0  } ^n C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
f ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } g (
k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k
\binom { n  } { k  } f ( k ) \\
f ( n ) &amp; = \sum _{ k = n  } ^N C _k ^n g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _k ^n f ( k ) \\
f ( n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } g (
k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^k
\binom { k  } { n  } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然以$( - 1 ) ^n g ( n ) <span class="math inline">\(代替\)</span>g
( n ) $即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k )
\\
&amp; = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^{ n - m  } ( - 1 ) ^k C _{
n - m  } ^k C _n ^m g ( m ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k \sum _{ m = 0  } ^{ n -
k  } C _{ n - k  } ^m g ( m ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k f ( n - k ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example1错排问题">Example1(错排问题)</span></h5>
<p>$n
$个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设$f ( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(个人随便站的方案数,\)</span>g ( n ) <span class="math inline">\(为\)</span>n $个人都站错的方案数.</p>
<p>如果知道$g <span class="math inline">\(的表达式,我们可以通过枚举有多少人站错位置来得到\)</span>f
<span class="math inline">\(,即:\)</span>f ( n ) = _{ k = 0 } ^n C _n ^k
g ( k ) $.</p>
<p>显然就是一个二项式反演,$g ( n ) = _{ k = 0 } ^n ( - 1 ) ^{ n - k } C
<em>n ^k f ( k ) = </em>{ k = 0 } ^n ( - 1 ) ^{ n - k } C _n ^k k !
$.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:$g
( n ) = n ! _{ 0 k n } { k ! } \ $.</p>
<p>不难发现$n ! <span class="math inline">\(的后面形如\)</span>e ^{ - 1
} $的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n ) &amp; = \cfrac { n !  } { e  } - n ! \sum _{ k &gt; n  } \cfrac
{ ( - 1 ) ^k  } { k !  } \\
&amp; = \cfrac { n !  } { e  } - \cfrac { ( - 1 ) ^{ n + 1  }  } { n +
1  } \sum _{ 0 \leq k  } ( - 1 ) ^k \cfrac { ( n + 1 ) !  } { ( k + n +
1 ) !  }
\end{aligned}
\]</span></p>
<p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有$g
( n ) = { e } + { 2 } + [ n = 0 ] $.</p>
<p>另外,观察$g <span class="math inline">\(关于\)</span>f <span class="math inline">\(的表达式,不难求出\)</span>g <span class="math inline">\(的递推式:\)</span>g ( n ) = ng ( n - 1 ) + ( - 1 )
^n $.</p>
<p>下面证明$g <em>n = ( n - 1 ) ( g </em>{ n - 1 } + g _{ n - 2 } )
$,事实上,右边等于:</p>
$$
<span class="math display">\[\begin{aligned}
( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) \\
&amp; = ( - 1 ) ^{ n - 1  } ( n - 1 ) + ( n - 1 ) \sum _{ k = 0  } ^{ n
- 2  } ( ( n - 1 ) ! \frac { ( - 1 ) ^k  } { k !  } + ( n - 2 ) ! \frac
{ ( - 1 ) ^k  } { k !  } ) \\
&amp; = n ! \sum _{ k = 0  } ^{ n - 2  } \frac { ( - 1 ) ^k  } { k !  }
- ( n - 1 ) ( - 1 ) ^n \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example2cf1750g">Example2(CF1750G)</span></h5>
<p>如果没有字典序限制就是经典的二项式反演:考虑能被分为$k <span class="math inline">\(段,说明有\)</span>n - k
$个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了$x
<span class="math inline">\(个数字,\)</span>y <span class="math inline">\(个区间,那么钦定\)</span>j <span class="math inline">\(对的方案是\)</span> { j } ( x - j ) ! <span class="math inline">\(.然后要乘上前面已经有了的,也就是乘上形如\)</span>(
1 + z ) ^k <span class="math inline">\(.这样复杂度\)</span>O ( n ^4 )
$.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的$x
, y , k <span class="math inline">\(有\)</span>O ( 1 ) <span class="math inline">\(种不同的取值,因此不用枚举.这样就是\)</span>O ( n
^3 ) <span class="math inline">\(.但是那个多项式乘法也可以规避,考虑最后的答案形如\)</span>(
1 + z ) ^k P <em>k ( x ) <span class="math inline">\(,我们考虑写成\)</span>P </em>{ n - 1 } ( z ) + = (
1 + z ) P _n ( z ) <span class="math inline">\(,然后不断这么做,就只需要\)</span>O ( n ^2 ) $.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5>
<p>不妨设至多有$i <span class="math inline">\(行\)</span>j $列最小值为$1
<span class="math inline">\(的答案是\)</span>f <em>{ i , j } <span class="math inline">\(,恰好有\)</span>i <span class="math inline">\(行\)</span>j $列最小值为$1 <span class="math inline">\(的答案是\)</span>g </em>{ i , j } $,注意到:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>令$h <em>{ n , m } = </em>{ j = 0 } ^m { j } g <em>{ n , j } \ <span class="math inline">\(,则\)</span>f </em>{ n , m } = <em>{ i = 0 } ^n {
i } h </em>{ i , m } \ <span class="math inline">\(,而\)</span>f _{ n ,
m } = k ^{ nm } ( k - 1 ) ^{ NM - nm } <span class="math inline">\(.做两次二项式反演得到\)</span>g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f
_{ n , m } { n } { m } k ^{ nm } ( k - 1 ) ^{ NM - nm }
$呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  }
g _{ s , t  } \\
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } &amp; = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ S , T  } &amp; = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S |
| T |  } \\
h _{ s , T  } &amp; = \sum _{ S \subseteq s  } ( - 1 ) ^{ | s | - | S
|  } f _{ S , T  } \\
g _{ s , t  } &amp; = \sum _{ T \subseteq t  } ( - 1 ) ^{ | t | - | T
|  } h _{ s , T  }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g <em>{ n , m } <span class="math inline">\(本身就包含了所有\)</span>| S | = n , | T | = m
<span class="math inline">\(的情况的和,并且在组合数\)</span> { j } <span class="math inline">\(那里就找到了唯一确定的\)</span>f </em>{ s , t }
<span class="math inline">\(,因此\)</span>f _{ n , m } <span class="math inline">\(是唯一确定的.这意味着这里\)</span>f <span class="math inline">\(的\)</span>n , m
$并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } f _i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个问题其实非常显然,我们的$g _{ i , j } <span class="math inline">\(定义为所有\)</span>| S | = i , | T | = j <span class="math inline">\(的答案之和.\)</span>f
$也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{
j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M } <span class="math inline">\(,那此时\)</span>g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,$g <span class="math inline">\(是已知的集合,\)</span>f <span class="math inline">\(是未知的集合.我们乘上组合数就可以得到对于\)</span>f
$来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f <span class="math inline">\(的定义改成\)</span>f _{ n , m } = k ^{ nm } ( k -
1 ) ^{ NM - nm } $就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知$n <span class="math inline">\(行\)</span>m <span class="math inline">\(列的集合的前提下,从中选出\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列并求\)</span>g <span class="math inline">\(.那么你从哪知道的\)</span>n <span class="math inline">\(行\)</span>m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } \sum _{
i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } {
j  } g _{ i , j  } \\
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } k ^{
nm  } ( k - 1 ) ^{ NM - nm  }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ’ <em>{ i ,
j } <span class="math inline">\(为至少有\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列不满足条件的方案数,自然有\)</span>f ’ </em>{ i ,
j } = f _{ N - i , M - j } $.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39; _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j
= m  } ^M \binom { j  } { m  } g &#39; _{ i , j  }
\]</span></p>
<p>最后答案就是$g ’ _{ 0 , 0 } $.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k
= 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\
f ( n ) &amp; = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k =
0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^{ n - k  } f ( k ) \\
f ( m ) &amp; = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left [
\begin{array}
{ c  } n \\
m
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) &amp; = \sum _{ k =
0  } ^M \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} f ( k ) \\
f ( m ) &amp; = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left \{
\begin{array}
{ c  } n \\
m
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) &amp; = \sum _{ k
= 0  } ^M \left [ \begin{array}
{ c  } k \\
m
\end{array} \right ] f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } &amp; = \sum _{ k = 0  } ^n
\left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} \left [ \begin{array}
{ c  } k \\
m
\end{array} \right ] ( - 1 ) ^{ n - k  } &amp; = [ m &amp; = n ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m = 0  } ^n [ m &amp; = n ] g ( m ) \\
&amp; = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( m ) \\
&amp; = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } \sum _{ m = 0  } ^k \left \{
\begin{array}
{ c  } k \\
m
\end{array} \right \} g ( m ) &amp; = \sum _{ k = 0  } ^n \left [
\begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( m ) &amp; = \sum _{ n = m  } ^M [ n &amp; = m ] g ( n ) \\
&amp; = \sum _{ n = m  } ^M \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( n ) \\
&amp; = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( n ) &amp; = \sum _{ d | n  } g ( d ) \Leftrightarrow g ( n ) &amp; =
\sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\
f ( n ) &amp; = \sum _{ n | d  } g ( d ) \Leftrightarrow g ( n ) &amp; =
\sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\
f ( x ) &amp; = \sum _{ 1 \leq d  } g ( d ) \Leftrightarrow g ( x )
&amp; = \sum _{ 1 \leq d  } f ( \cfrac { x  } { d  } ) \mu ( d )
\end{aligned}
\]</span></p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m | n  } [ \frac { n  } { m  } &amp; = 1 ] g ( m
) \\
&amp; = \sum _{ m | n  } \sum _{ d | \frac { n  } { m  }  } \mu ( d ) g
( m ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$[ d | { m } ] = [ md | n ] = [ m | { d } ] \ $.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ d | n  } \mu ( d ) \sum _{ m | \frac { n  } {
d  }  } g ( m ) \\
&amp; = \sum _{ d | n  } \mu ( d ) f ( \frac { n  } { d  } ) \\
&amp; = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第二个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ n | d  } [ \frac { d  } { n  } &amp; = 1 ] g ( d
) \\
&amp; = \sum _{ n | d  } \sum _{ c | \frac { d  } { n  }  } \mu ( c ) g
( d ) \\
&amp; = \sum _{ c | d  } \sum _{ nc | d  } \mu ( c ) g ( d ) \\
&amp; = \sum _{ c  } \mu ( c ) f ( nc ) \\
&amp; = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq d  } g ( \cfrac { x  } { d  } ) \mu ( d ) &amp; = \sum _{
d \geq 1  } \mu ( d ) \sum _{ k \geq 1  } f ( \cfrac { x  } { kd  } ) \\
&amp; = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d , k
\geq 1  } [ m &amp; = dk ] \mu ( d ) \\
&amp; = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d | m  }
\mu ( d ) \\
&amp; = f ( x )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>求长度为$n <span class="math inline">\(且仅包含小写英文字母且循环节长度恰为\)</span>n
$的字符串个数.</p>
<p>不妨设$f ( n ) <span class="math inline">\(表示长度为\)</span>n <span class="math inline">\(的字符串个数,\)</span>g ( n ) <span class="math inline">\(表示长度为\)</span>n <span class="math inline">\(且循环节长度恰为\)</span>n $的字符串个数.</p>
<p>有$f ( n ) = <em>{ d | n } g ( d ) <span class="math inline">\(,根据莫比乌斯反演,\)</span>g ( n ) = </em>{ d | n
} ( { d } ) f ( d ) $.</p>
<h4><span id="example2">Example2</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m gcd ( i , j ) \ $.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) &amp; = \sum
_{ i = 1  } ^n \sum _{ j = 1  } ^m id [ gcd ( i , j ) ] \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j
)  } \varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="交换枚举顺序">交换枚举顺序</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  }
\varphi ( d ) &amp; = \sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{
\lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac
{ m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="分离无关变量">分离无关变量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } {
d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  }
\rfloor  } _{ j = 1  } \varphi ( d ) &amp; = \sum ^{ \min ( n , m )  }
_{ d = 1  } \varphi ( d ) \times \lfloor \cfrac { n  } { d  } \rfloor
\times \lfloor \cfrac { m  } { d  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑使用数论分块,只需处理出$( d ) <span class="math inline">\(的前缀和即可在\)</span>O ( + )
$的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m [ gcd ( i , j ) = 1 ] \
$.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从$id <span class="math inline">\(变为了\)</span>$.</p>
<h4><span id="example4">Example4</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m [ gcd ( i , j ) prime ] \
$.</p>
<p>考虑增加枚举量,则:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ]
&amp; = \sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m \sum _{ p \in
prime  } [ gcd ( i , j ) &amp; = p ] \\
&amp; = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { d  }
\rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{
j = 1  } [ gcd ( pi , pj ) &amp; = p ] \\
&amp; = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { p  }
\rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { p  } \rfloor  } _{
j = 1  } [ gcd ( i , j ) &amp; = 1 ] \\
&amp; = \sum _{ p \in prime  } \sum _{ d = 1  } ^{ \min ( \lfloor \frac
{ m  } { p  } \rfloor , \lfloor \frac { n  } { p  } \rfloor )  } \mu ( d
) \lfloor \cfrac { n  } { pd  } \rfloor \lfloor \cfrac { m  } { pd  }
\rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5>
<p>考虑设$x = pd <span class="math inline">\(,则变为\)</span><em>{ x = 1
} ^{ ( n , m ) } </em>{ p prime p | x } ( { p } ) { x } { x } \ $.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4>
<p>首先先考虑去掉$lcm <span class="math inline">\(使得式子中只有\)</span>i , j , ( i , j ) $.</p>
<p>显然可以构造函数$f ( x ) = x ^{ c - d } , g ( x ) = x ^d , h ( x ) =
x ^d \ <span class="math inline">\(,然后将题目转化为\)</span>_{ j = 1 }
^n f ( gcd ( i , j ) ) g ( i ) h ( j ) x _j b _i ( p ) \ $.</p>
<p>$( i , j ) $很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出$f <em>r ( n ) <span class="math inline">\(使得\)</span>f ( n
) = </em>{ d | n } f _r ( d ) \ <span class="math inline">\(,也即\)</span>f <em>r ( n ) = </em>{ d | n } ( { d
} ) f ( d ) $.</p>
<p>则原式即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ j = 1  } ^n \sum _{ d  } [ d | i ] [ d | j ] f _r ( d ) g ( i )
h ( j ) x _j &amp; \equiv b _i ( \mod p ) \\
\sum _{ d | i  } f _r ( d ) \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j
&amp; \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$z <em>d = </em>{ j = 1 } ^n [ d | j ] h ( j ) x <em>j \ <span class="math inline">\(,有\)</span></em>{ d | i } f _r ( d ) z _d { g ( i
) } ( p ) \ $.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出$z _d $.</p>
<p>而$z <em>d = </em>{ j = 1 } ^n [ d | j ] h ( j ) x <em>j = </em>{ d |
j } ^n h ( j ) x _j <span class="math inline">\(,可以再次使用莫比乌斯反演求出\)</span>h ( j ) x _j
<span class="math inline">\(,进而求\)</span>x _j $.</p>
<p>无解条件显然是$g _i = 0 x _i $.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol type="1">
<li><p>通过增加枚举量消掉$lcm <span class="math inline">\(以及\)</span>$这些难以处理的项.</p></li>
<li><p>将$i <span class="math inline">\(与\)</span>j
$尽量分到式子两边.</p></li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p></li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4>
<p>首先注意到一个重要的事实:我们只需要询问所有$( x ) <span class="math inline">\(的\)</span>x <span class="math inline">\(,就可以得到全部信息,而这些\)</span>x
$的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \bigoplus _{ i \in A  } i [ \gcd ( i , n ) &amp; = 1 ]
\\
&amp; = \bigoplus _{ i \in A  } ^c i \sum _{ d | i , d | n  } \mu ( d )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$<em>{ d | i } ( d ) = </em>{ d | i } | ( d ) | $,于是:</p>
<p><span class="math display">\[
f ( n ) = \bigoplus _{ d | n  } | \mu ( d ) | \bigoplus _{ d | i , i \in
A  } i
\]</span></p>
<p>接下来只要我们形式上写作$n <span class="math inline">\(,我们就默认\)</span>( n ) <span class="math inline">\(,又令\)</span>g ( n ) = <em>{ n | i , i A } i
<span class="math inline">\(,此时自然有\)</span>f ( n ) = </em>{ d | n }
g ( d ) \ <span class="math inline">\(.这是一个经典的莫反形式,我们再反演回去就可以得到\)</span>g
( n ) = <em>{ d | n } ( { d } ) f ( d ) = </em>{ d | n } f ( d ) <span class="math inline">\(,也就是说我们可以求得所有的\)</span>g ( n ) <span class="math inline">\(,也就是这个集合中所有是\)</span>n
$的倍数的异或值.</p>
<p>注意一个事实:如果我们设$w ( m ) = <em>{ p prime , p | m } p <span class="math inline">\(,那么我们就可以按照\)</span>w <span class="math inline">\(的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进\)</span>A
<span class="math inline">\(的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设\)</span>S
( n ) = { x | w ( x ) = n } <span class="math inline">\(,又设\)</span>h
( n ) = </em>{ i A , i S ( n ) } i <span class="math inline">\(.考虑用\)</span>g ( n ) <span class="math inline">\(表示\)</span>h ( n ) $,我们有:</p>
<p><span class="math display">\[
g ( n ) = \bigoplus _{ n | d  } | \mu ( \frac { d  } { n  } ) | h ( d )
\]</span></p>
<p>反演,有$h ( n ) = _{ n | d } g ( d ) \ <span class="math inline">\(.于是我们可以求得所有的\)</span>h ( n ) $了.</p>
<p>现在的问题在于:对于数$n , ( n ) <span class="math inline">\(,我们要在\)</span>S ( n ) <span class="math inline">\(中选出若干个数,使得它们的异或和为\)</span>h ( n )
<span class="math inline">\(,并且选出的数字总共有\)</span>| A | $个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3>
<p>设$S $为可重集合.</p>
<p>一般形式:定义$( S ) <span class="math inline">\(,若\)</span>S
$包含重复元素则为$0 <span class="math inline">\(,否则为\)</span>( - 1 )
^{ | S | } $.</p>
$$
<span class="math display">\[\begin{aligned}
f ( S ) &amp; = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S )
&amp; = \sum _{ T \subseteq S  } \mu ( S - T ) f ( T ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3>
<p>一般形式($_n = e ^{ { n } } $):</p>
<p><span class="math display">\[
f _m = \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ mk  } g _k
\Leftrightarrow g _m = \frac { 1  } { n  } \sum _{ k = 0  } ^{ n - 1  }
\omega _n ^{ - mk  } f _k
\]</span></p>
<p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3>
<p>考虑莫比乌斯反演的过程,我们实际上使用的是$[ m | n ] _{ d | { m } } (
d ) = [ n = m ] \ $.</p>
<p>令$c = md <span class="math inline">\(,左边\)</span>= _{ c | n } [ m
| c ] ( { m } ) = ( [ c | n ] ) ( [ m | c ] ( { m } ) ) \ $.</p>
<p>令$A <em>{ c , n } = [ c | n ] <span class="math inline">\(,\)</span>B </em>{ m , c } = [ m | c ] ( { m } ) \
<span class="math inline">\(,那我们有\)</span>BA = I $.</p>
<p>刚才的过程相当于:</p>
$$
<span class="math display">\[\begin{aligned}
Ax &amp; = b \\
x &amp; = Ix \\
x &amp; = ( BA ) x \\
x &amp; = B ( Ax ) \\
x &amp; = Bb \\

\end{aligned}\]</span>
<p>$$</p>
<p>无论是二项式反演还是莫比乌斯反演,他们都满足$f ( n ) <span class="math inline">\(所依赖的\)</span>g ( k ) <span class="math inline">\(有\)</span>k n \ $.</p>
<p>根据上面的情况,我们发现$A <span class="math inline">\(是一个下三角矩阵,\)</span>B <span class="math inline">\(是\)</span>A ^{ - 1 } $.</p>
<p>现在来推导满足$k n $的一般情况反演:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 1  } ^n a _{ n , k  } g ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设算子$( n , m ) <span class="math inline">\(,满足\)</span><em>{
k = 1 } ^n a </em>{ n , k } ( k , m ) = <em>{ k = 1 } ^n ( n , k ) a
</em>{ k , m } = [ n = m ] \ $.</p>
<p>即$AB = BA = I \ $.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m = 1  } ^n [ n &amp; = m ] g ( m ) \\
&amp; = \sum _{ m = 1  } ^n \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k ,
m  } g ( m ) \\
&amp; = \sum _{ k = 1  } ^n \mu ( n , k ) f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
$$
<span class="math display">\[\begin{aligned}
c _r &amp; = \sum _{ p , q  } [ f ( p , q ) &amp; = r ] a _p b _q \\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们需要把$f
$分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2>
<h4><span id="一般形式">一般形式</span></h4>
<p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:$<em>{ i = 1 } ^n S <em>i = </em>{ T { 1 , . . . , n } } ( - 1
) ^{ | T - 1 | } </em>{ p T } S _p $.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属$m <span class="math inline">\(个集合\)</span>T _1 , . . . , T _m
$,而除了这些集合以外的集合,</p>
<p><span class="math display">\[
\begin{aligned}
cnt &amp; = \sum _{ i = 1  } ^m ( - 1 ) ^{ i - 1  } \binom { m  } { i  }
\\
&amp; = \binom { m  } { 0  } - \sum _{ i = 0  } ^m ( - 1 ) ^i \binom {
m  } { i  } \\
&amp; = 1 - [ m &amp; = 0 ]
\end{aligned}
\]</span></p>
<p>显然,当这个元素被包含的时候,贡献为$1 $,反之贡献为$0 $.</p>
<p>如果我们定义一类在集合上的函数$F ( S ) = _{ p S } F ( p )
$,那么自然也有:</p>
<p><span class="math display">\[
F ( \bigcup _{ i = 1  } ^n S _i ) = \sum _{ T \subseteq \{ 1 , . . . , n
\}  } ( - 1 ) ^{ | T | - 1  } F ( \bigcap _{ p \in T  } S _p )
\]</span></p>
<p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<p><span class="math display">\[
\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  }
^n \overline { S _i  } \mid
\]</span></p>
<p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5>
<p>考虑不定方程$_{ i = 1 } ^n x _i = m <span class="math inline">\(,和\)</span>n <span class="math inline">\(个限制条件\)</span>x _i b _i <span class="math inline">\(,其中\)</span>m <span class="math inline">\(和\)</span>b _i
$都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件):</p>
<ol type="1">
<li><p>$U <span class="math inline">\(是满足\)</span>_{ i = 1 } ^n x _i
= m $的所有非负整数解;</p></li>
<li><p>对于每个变量$i <span class="math inline">\(,都对应一个\)</span>P
_i = [ x _i b _i ] $.</p></li>
</ol>
<p>设所有满足$P <em>i <span class="math inline">\(的解构成集合\)</span>S
<em>i <span class="math inline">\(,那么我们需要求解的值就是\)</span></em>{ i = 1 }
^n S <em>i <span class="math inline">\(.而\)</span>U <span class="math inline">\(显然是\)</span> { n - 1 } <span class="math inline">\(.我们有:\)</span></em>{ i = 1 } ^n S <em>i = | U |
- </em>{ i = 1 } ^n <span class="math inline">\(.考虑对\)</span></em>{ i
= 1 } ^n <span class="math inline">\(使用容斥原理,注意到\)</span> <span class="math inline">\(的意义是满足\)</span>x <em>{ i } b </em>{ i } + 1
$的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5>
<p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件):</p>
<ol type="1">
<li><p>$U <span class="math inline">\(是长度为\)</span>n
$的所有排列;</p></li>
<li><p>对于每个变量$i <span class="math inline">\(,都对应一个\)</span>P
_i = [ p _i i ] $.</p></li>
</ol>
<p>注意到所求仍然是$<em>{ i = 1 } ^n S <em>i <span class="math inline">\(.于是我们仍然试图\)</span>| </em>{ k = 1 } ^m |
<span class="math inline">\(.考虑其意义,也即:有\)</span>m <span class="math inline">\(个位置被确定了,而其它位置没有限制,于是\)</span>|
</em>{ k = 1 } ^m | = { m } ( n - m ) ! <span class="math inline">\(.根据容斥,自然有:\)</span>d <em>n = n ! - </em>{ m
= 1 } ^n ( - 1 ) ^{ m - 1 } { m } ( n - m ) ! = n ! _{ m = 0 } ^n { m !
} $.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5>
<p>首先可以用dp+双指针得到$f _i <span class="math inline">\(表示勒令\)</span>i <span class="math inline">\(对满足条件的方案数.把\)</span>k <span class="math inline">\(的定义改为恰好\)</span>k
$对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a <span class="math inline">\(对的方案会被恰好\)</span>b <span class="math inline">\(对的方案计算\)</span> { a } <span class="math inline">\(次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为\)</span>k
$的方案贡献为$1 <span class="math inline">\(,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为\)</span>k
+ 1 $的方案贡献为$0 <span class="math inline">\(,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令\)</span>ans
= f <em>k <span class="math inline">\(,第二步除去其中被多算的\)</span>k
+ 1 <span class="math inline">\(,这一步令\)</span>ans - = { k } f </em>{
k + 1 } <span class="math inline">\(.这个时候,我们再考虑\)</span>k + 2
<span class="math inline">\(的贡献:它将在\)</span>f <em>k <span class="math inline">\(时贡献\)</span> { k } <span class="math inline">\(次,在\)</span>f </em>{ k + 1 } <span class="math inline">\(时贡献\)</span>- { k + 1 } { k } = - { k } { 1 }
<span class="math inline">\(次,那它现在的贡献还有:\)</span>- { k } <span class="math inline">\(次.以此类推,可以得到\)</span>ans = _{ i = k } ^n f
_i ( - 1 ) ^{ i - k } { k } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P
_i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i <span class="math inline">\(,因为只有这个时候,我们才能通过分析满不满足\)</span>P
_i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1
/ 0 $就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5>
<p>如果直接对于每次询问暴力做,复杂度显然是$O ( 4 ns )
$,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画$P
_i = [ use _i d _i ] <span class="math inline">\(,从而可以用容斥做.复杂度\)</span>O ( 4 m + n 2 ^4
) $.</p>
<h5><span id="example5">Example5</span></h5>
<p>Alice和Bob在玩游戏,他们有一个$n <span class="math inline">\(个点的无向完全图,设所有的边组成了集合\)</span>E
<span class="math inline">\(,他们想取遍\)</span>E <span class="math inline">\(的所有非空子集,对某个集合\)</span>S <span class="math inline">\(有一个估价\)</span>f ( S ) <span class="math inline">\(:考虑\)</span>n <span class="math inline">\(个点与\)</span>S <span class="math inline">\(中的边组成的图,我们用\)</span>m <span class="math inline">\(种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么\)</span>f
( S ) <span class="math inline">\(等于这个图的染色方案数.同时,Alice喜欢奇数,所以当\)</span>|
S | <span class="math inline">\(为奇数时,Alice的分值加上\)</span>f ( S )
<span class="math inline">\(,否则Alice的分值减去\)</span>f ( S ) <span class="math inline">\(,求最后的分值.\)</span>( n , m ^6 ) $.</p>
<p>一开始抄题的时候没有写染色而是直接写”设$k <span class="math inline">\(为连通块个数,则\)</span>f ( S ) = m ^k <span class="math inline">\(.&quot;然后发现做不了,因为\)</span>| S | <span class="math inline">\(相同的\)</span>f ( S ) <span class="math inline">\(不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个\)</span>m
$,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那$x y col _x = col _y <span class="math inline">\(.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与\)</span>-
1 <span class="math inline">\(有关的单位元素(从一开始就是点)和与\)</span>f
$有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令$F ( C ) <span class="math inline">\(表示在\)</span>C <span class="math inline">\(情况下的染色方案,\)</span>T _{ ( i , j ) } <span class="math inline">\(表示满足边\)</span>( i , j ) $限制的解集:</p>
<p><span class="math display">\[
ans = \sum _{ \emptyset \ne S \subseteq E  } ( - 1 ) ^{ | S | - 1  } F (
\bigcap _{ ( i , j ) \in S  } T _{ ( i , j )  } )
\]</span></p>
<p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出$ans
<span class="math inline">\(的意义:显然是\)</span>F ( _{ i = 1 } ^{ m }
P _i ) <span class="math inline">\(.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是\)</span>m
^n - m ^{ } $.</p>
<h5><span id="example6">Example6</span></h5>
<p>求$( n ) $.</p>
<p>考虑这么一个事实:假设$n = p _i ^{ q _i } <span class="math inline">\(,注意到令\)</span>P <em>i = [ ( i , n ) = 1 ]
<span class="math inline">\(,我们所求也就是\)</span></em>{ i = 1 } ^n S
_i $.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5>
<p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如$ABCABCAB
. . . $这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于$3
$并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5>
<p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的$1
$,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是$_{ i = 0 } ^{ ( n , m ) } ( - 1 ) ^i { i } { i
} i ! ( m + 1 ) ^{ n - i } ( n + 1 ) ^{ m - i } $.</p>
<h5><span id="example9">Example9</span></h5>
<p>给定若干个限制条件$( x , y ) <span class="math inline">\(,表示\)</span>a _x = y <span class="math inline">\(和\)</span>a _y = x
$必须满足至少一个,求排列方案数.</p>
<p>首先$i p _i
$把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为$2
<span class="math inline">\(的链,它自己成环的话是不用\)</span> $的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是$
$,所以一个有$1
$个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为$2
$的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-squareconstraints">Example10([AGC036F] Square
Constraints)</span></h5>
<p>由题意得:$n ^2 - i ^2 P _i ^2 ( 2 n ) ^2 - i ^2 $.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为$l
<em>i <span class="math inline">\(,那么只有上界的答案应该是什么呢?将\)</span>l <span class="math inline">\(从小到大排序,答案就是\)</span></em>{ i = 0 } ^{ 2
n - 1 } ( l <em>i - i ) <span class="math inline">\(.(注意到必须满足\)</span>l </em>{ 2 n - 1 } = 2 n
- 1 $.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个$
{ 4 } <span class="math inline">\(的圆弧.而通过圆弧的性质不难看出:最终的\)</span>l
<span class="math inline">\(分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道\)</span>l
<span class="math inline">\(按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照\)</span>l
<span class="math inline">\(的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度\)</span>O
( n ^3 ) $.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5>
<p>(下面将$n <span class="math inline">\(和\)</span>m $反着写)</p>
<p>设$p = { n } , q = n - p $.</p>
<p>首先注意到期望$= P [ len ] + P [ len ] + $.</p>
<p>考虑如何计算$P [ len x ] <span class="math inline">\(,如果我们设\)</span>a _i <span class="math inline">\(表示以\)</span>i <span class="math inline">\(作为开头的极长的带劲的长度大于等于\)</span>x <span class="math inline">\(的序列的集合,那么最后无非是要求所有\)</span>a
<span class="math inline">\(的并.考虑用容斥做到求所有\)</span>a
$的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5>
<p>给定$n , k <span class="math inline">\(和\)</span>n <span class="math inline">\(个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过\)</span>k
<span class="math inline">\(.\)</span>n $.</p>
<p>著名结论:$n <span class="math inline">\(个点\)</span>m <span class="math inline">\(个连通块任意连边成树的方案数是\)</span>n ^{ m - 2
} s <span class="math inline">\(,其中\)</span>s <span class="math inline">\(是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过\)</span>k
<span class="math inline">\(,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于\)</span>k
<span class="math inline">\(的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过\)</span>k
$,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数$( - 1 ) ^{ 块 数
- 1 } $.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4>
<p>对于:</p>
<p><span class="math display">\[
\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . .
, n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid
\]</span></p>
<p>考虑一个特例:$S _i = { 1 , 2 , , a _i } <span class="math inline">\(,那么上面的式子导出min-max容斥(我们设\)</span>S =
{ a _1 , a _2 , , a _n } $)(第二个式子可以把前缀改成后缀):</p>
<p><span class="math display">\[
\begin{aligned}
\max ( S ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{
| T | - 1  } \min ( T ) \\
\min ( S ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{
| T | - 1  } \max ( T )
\end{aligned}
\]</span></p>
<p>由于是集合,这个式子在期望意义下同样成立:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \max \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } (
- 1 ) ^{ | T | - 1  } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } (
- 1 ) ^{ | T | - 1  } E ( \max \{ S \} )
\end{aligned}
\]</span></p>
<p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<p><span class="math display">\[
\begin{aligned}
kth \max \{ S \} &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( -
1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \min \{ T \} \\
kth \min \{ S \} &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( -
1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \max \{ T \} \\
E ( kth \max \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne
\emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E
( \min \{ T \} ) \\
E ( kth \min \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne
\emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E
( \max \{ T \} )
\end{aligned}
\]</span></p>
<p>原理是消掉前$k - 1 $大的数字,让他们的贡献为$0
$,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5>
<p>不妨设$tim _i <span class="math inline">\(为\)</span>[ i , i + 1 ]
$第一次被覆盖的时间,答案就是:</p>
<p><span class="math display">\[
E ( \max _{ i = 1  } ^{ n - 1  } \{ tim _i \} ) = \sum _{ T \subseteq \{
1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E
( \min _{ j \in T  } \{ tim _j \} )
\]</span></p>
<p>设$f ( S ) <span class="math inline">\(为有多少个区间能覆盖至少一个\)</span>[ i , i + 1 ]
, i S <span class="math inline">\(,考虑\)</span>E = p <em>{ [ t ] } + p
</em>{ [ t ] } + p <em>{ [ t ] } + <span class="math inline">\(,于是\)</span>E ( </em>{ j S } { tim _j } ) = { f
( S ) } $.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne
\emptyset  } ( - 1 ) ^{ | T | - 1  } f ( T ) \\
&amp; = \sum _{ k = 0  } ^m \frac { m  } { k  } \sum _{ T \subseteq \{ 1
, 2 , \cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k  } ( - 1 ) ^{ |
T | - 1  }
\end{aligned}
\]</span></p>
<p>注意到$f ( S ) <span class="math inline">\(可能不那么好求,我们求\)</span>g ( S ) = m - f ( S
) <span class="math inline">\(,也就是不包含任何一个\)</span>[ i , i + 1
] , i S $的区间个数,我们有:</p>
<p><span class="math display">\[
ans = \sum _{ k = 0  } ^m \frac { m  } { m - k  } \sum _{ T \subseteq \{
1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k  } ( - 1 ) ^{
| T | - 1  }
\]</span></p>
<p>这里已经不难写出$O ( n ^3 ) $的dp了.</p>
<p>那么怎么优化呢?设$dp <em>{ i , j } <span class="math inline">\(表示只考虑\)</span>[ 1 , i ] <span class="math inline">\(时(\)</span>[ i - 1 , i ] <span class="math inline">\(必选),\)</span></em>{ g ( T ) = j } ( - 1 ) ^{ | T
| - 1 } <span class="math inline">\(的答案,不难发现每次加入一个区间\)</span>[ l , r ]
<span class="math inline">\(就会让\)</span>dp <em>{ i , j } , i &lt; = l
<span class="math inline">\(对\)</span>dp </em>{ r , j + 1 }
$的贡献乘一个$1 $.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度$O
( nm n ) $.</p>
<h4><span id="反射容斥">反射容斥</span></h4>
<p>一般形式:给定二维平面上两个点$S <span class="math inline">\(和\)</span>T <span class="math inline">\(,其中\)</span>T <span class="math inline">\(在\)</span>S <span class="math inline">\(的右方,给定两条线\)</span>y = a <span class="math inline">\(和\)</span>y = b <span class="math inline">\(,每次可以向右上或者右下走一步,求不碰线的从\)</span>S
<span class="math inline">\(到\)</span>T $的方案数.</p>
<p>我们不妨设$A <span class="math inline">\(表示一定碰了一次上界的方案数,\)</span>B <span class="math inline">\(表示一定碰了一次下界的方案数,\)</span>AB
$表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走$- A - B + AB + BA - ABA - BAB . . . $.</p>
<p>考虑设步数为$n <span class="math inline">\(,那显然长度最多为\)</span>
{ a - b } $.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="post-title-link" itemprop="url">博弈论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3>
<p>$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,有\)</span>n <span class="math inline">\(颗石子,每次可以取\)</span>x $颗,其中$1 x m \ <span class="math inline">\(,求\)</span>A $是否能赢.</p>
<p>考虑直接令石子数量为状态,有$SG ( x ) = mex { SG ( y ) | { 0 , x - m }
y x - 1 } \ <span class="math inline">\(,注意到\)</span>SG ( x ) = 0
<span class="math inline">\(当且仅当\)</span>x ( m + 1 ) $.</p>
<p>我们使用数学归纳证明:</p>
<p>当$0 x m $时,显然成立.</p>
<p>而对于$x <span class="math inline">\(,如果\)</span>x ( m + 1 ) \
<span class="math inline">\(,那么集合\)</span>S = { y | { 0 , x - m } y
x - 1 } <span class="math inline">\(中一定\)</span>y <span class="math inline">\(满足\)</span>y ( m + 1 ) \ $.</p>
<p>也就是$y <span class="math inline">\(满足\)</span>SG ( y ) = 0 <span class="math inline">\(,那么\)</span>SG ( n ) = 0 $.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3>
<p>$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,有\)</span>n <span class="math inline">\(堆石子,第\)</span>i <span class="math inline">\(堆石子有\)</span>x _i
$个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果$x $均等于$0 <span class="math inline">\(一定先手必败.考虑令\)</span>w = x _1 x _2 . . . x
_n <span class="math inline">\((\)</span>w <span class="math inline">\(即为全游戏的\)</span>SG <span class="math inline">\(值),那么先手必败当且仅当\)</span>w = 0 \ $.</p>
<p>证明:</p>
<p>只需证明当$w <span class="math inline">\(时一定存在一种方法使得\)</span>w = 0 \ $.</p>
<p>考虑$w <span class="math inline">\(的最高位为第\)</span>k <span class="math inline">\(位,那么一定存在一个\)</span>x _i <span class="math inline">\(的第\)</span>k $位为$1 $.将它改为$0 <span class="math inline">\(,然后这个\)</span>x _i
$的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4>
<p>$A <span class="math inline">\(和\)</span>B <span class="math inline">\(,有\)</span>n <span class="math inline">\(堆石子,第\)</span>i <span class="math inline">\(堆石子有\)</span>x _i <span class="math inline">\(个石子.每次可以任选不超过\)</span>k
$堆取走若干个石子,最后不能取的人输.</p>
<p>将$x _i $写成二进制,如果每一位的$1 <span class="math inline">\(的个数均是\)</span>k + 1
$的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4>
<p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于$2
$的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p>$SG ( x ) = mex { { SG ( v ) | x v } , { SG ( x - i ) SG ( i ) | 1 i
&lt; x } } \ $.</p>
<p>找一下规律可以发现:</p>
$$
<span class="math display">\[\begin{aligned}
SG ( x ) &amp; = \begin{cases}
x - 1 &amp; x \equiv 0 ( \mod 4 ) \\
x &amp; x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 &amp; x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设当$x k $时结论成立.</p>
<p>当$x = 4 k + 1 <span class="math inline">\(时,前半部分一定是取遍了\)</span>[ 1 , 4 k ] $.</p>
<p>但是一定不存在$a <span class="math inline">\(和\)</span>b <span class="math inline">\(满足\)</span>a + b = 4 k + 1 <span class="math inline">\(并且\)</span>SG ( a ) SG ( b ) = 4 k + 1 <span class="math inline">\(.讨论一下\)</span>a <span class="math inline">\(和\)</span>b <span class="math inline">\(在\)</span> $意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3>
<p>$n <span class="math inline">\(个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.\)</span>A
<span class="math inline">\(和\)</span>B
$每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用$SG ( u ) = mex { SG ( v ) | u v } $.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是$0 $.</p>
<p>首先如果$SG ( u ) = x <span class="math inline">\(,那么\)</span> y
&lt; x <span class="math inline">\(,\)</span>v <span class="math inline">\(使得\)</span>u v <span class="math inline">\(且\)</span>SG ( v ) = y
$.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能$y &gt; x $,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个$u ’ <span class="math inline">\(使得\)</span>SG ( u ’ ) = x $,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4>
<p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol type="1">
<li><p>游戏的SG函数不为$0 $且游戏中某个单一游戏的SG函数大于$1
$.</p></li>
<li><p>游戏的SG函数为$0 $且游戏中没有单一游戏的SG函数大于$1 $.</p></li>
</ol>
<p>如果没有单一游戏的SG函数大于$1 $,那么显然游戏的SG函数为$0
$就赢了,否则就输了.</p>
<p>而如果SG函数为$0 $且存在某个单一游戏的SG函数大于$1 $,一定是输的.</p>
<p>因为这个情况下,后手先按照正常$SG
$游戏压着先手,最后一定会剩两堆一样大于$1
$的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4>
<p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在$DAG <span class="math inline">\(上dp的时候除了\)</span>SG
$我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4>
<p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4>
<p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:$SG ( u ) = _{ u v } ( SG ( v ) + 1 ) $.</p>
<p>考虑归纳假设.如果$u <span class="math inline">\(只有\)</span>v <span class="math inline">\(一个儿子.那么要么将\)</span>v
$子树全删,要么删一部分,有:</p>
<p><span class="math display">\[
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 &lt; SG ( v ) ) = SG ( v )
+ 1
\]</span></p>
<p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的$SG
$为$0 <span class="math inline">\(,而显然\)</span>SG <span class="math inline">\(图中的其它节点的\)</span>SG <span class="math inline">\(均要\)</span>+ 1 $.</p>
<h4><span id="example4">Example4</span></h4>
<p>$n
$个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环$SG = 1 <span class="math inline">\(,偶环\)</span>SG = 0
$.</p>
<p>这么考虑:边数为$k <span class="math inline">\(的链的\)</span>SG <span class="math inline">\(为\)</span>k $.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到$1
$.偶环同理,不可能得到$0 $.</p>
<h4><span id="example5">Example5</span></h4>
<p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,$SG
$值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3>
<p>一个数$N
$,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当$N $是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当$N <span class="math inline">\(是斐波那契数时必败,不妨假设\)</span>N = N _0 + N
_1 $,</p>
<p>考虑将$N <span class="math inline">\(看成两堆,因为如果第一次取走了大于\)</span>N _1
<span class="math inline">\(颗石子,由于\)</span>N _0 N _1 \
$,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在$N _0 <span class="math inline">\(堆取石子,原因是如果取了大于\)</span>N _0 <span class="math inline">\(颗石子,由于\)</span>N = N _0 + N _1 N _0 \
$.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取$N _0 <span class="math inline">\(这一堆,如果在这一堆取的过程中,先手一直取得不超过\)</span>N
_0 <span class="math inline">\(剩下的数,那么根据归纳假设,后手一定可以取走\)</span>N
_0 <span class="math inline">\(堆的最后一个石子,此时局面变成了只剩\)</span>N _1
<span class="math inline">\(颗石子.只要此时先手不能一次取走\)</span>N _1
<span class="math inline">\(颗石子,先手就必败.而后手最后一步拿走石子最多会拿走\)</span>
{ 3 } N _0 <span class="math inline">\(的石子,但是,\)</span> { 3 } N _0
&lt; N _1 $,因此一定不可能.</p>
<p>否则,仍然是先手取走了$N _0 <span class="math inline">\(全部石子,又当了先手取\)</span>N _1
$的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设$N = <em>{ i = 1 } ^k f </em>{ p _i } <span class="math inline">\(,其中\)</span>p _1 &lt; p _2 &lt; p _3 &lt; . . .
&lt; p <em>k \ <span class="math inline">\(,先手取走\)</span>f </em>{ p
<em>1 } \ $.由于$2 f </em>{ p <em>1 } &lt; f </em>{ p <em>2 } <span class="math inline">\(,因此后手接下来无论如何不可能取得大于等于\)</span>f
</em>{ p <em>2 } \ <span class="math inline">\(,问题转化为一堆大小为\)</span>f </em>{ p _2 }
$的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3>
<p>给出一张二分图和起点$S <span class="math inline">\(,\)</span>A <span class="math inline">\(和\)</span>B
$轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点$S
$,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含$S <span class="math inline">\(,那么\)</span>A
<span class="math inline">\(只需要每次走到一个和\)</span>S <span class="math inline">\(匹配的点即可.\)</span>B <span class="math inline">\(无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含\)</span>S
$的点,与假设不符.</p>
<p>而如果存在一个匹配不包含$S <span class="math inline">\(,如果\)</span>A <span class="math inline">\(仍然第一步走到一个和\)</span>S <span class="math inline">\(匹配的点那么\)</span>B <span class="math inline">\(一定能想办法走到一个不在当前\)</span>A <span class="math inline">\(选择的最大匹配中的点而在一个不包含\)</span>S <span class="math inline">\(的最大匹配中的点,于是\)</span>B $必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4>
<p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设$dp <em>{ S , x } =
0 / 1 <span class="math inline">\(表示目前集合\)</span>S <span class="math inline">\(中的所有人都已经离场了,而目前金条在\)</span>x
<span class="math inline">\(手中,金条会不会被抢.显然,如果\)</span>y
<span class="math inline">\(满足\)</span>dp </em>{ S { x } , y } = 0
<span class="math inline">\(,也就是金条在\)</span>y <span class="math inline">\(手里不会被抢,那\)</span>x
$手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与$S
$匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果$S
<span class="math inline">\(和\)</span>x
$并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断$S <span class="math inline">\(是否一定在其中,只需要先删去\)</span>S <span class="math inline">\(,跑dinic,再在残联网络上加上\)</span>S
$,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3>
<h4><span id="example1zr23省选10连-day1clashmas">Example1(zr[23省选10连 day1]
Clashmas)</span></h4>
<p>注意到删点对树形态的影响,考虑重心</p>
<ol type="1">
<li>$n $为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol start="2" type="1">
<li>$n $为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时$n
$为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为$S
_A <span class="math inline">\(,B的点的集合为\)</span>S _B <span class="math inline">\(.以原重心为根建树,设其所有儿子组成的集合为\)</span>S
<em>C <span class="math inline">\(,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当\)</span></em>{
u S _A S _C } siz <em>u </em>{ u S _B S _C } siz _u $.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中$siz
$最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol start="3" type="1">
<li>$n $为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时$n
$为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol start="4" type="1">
<li>$n $为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol start="5" type="1">
<li>$n $为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3>
<h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5>
<p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设$f _i <span class="math inline">\(为还剩\)</span>i <span class="math inline">\(条蛇的时候能不能吃,那\)</span>f <em>i = 1 <span class="math inline">\(的话,要么\)</span>i = 2 <span class="math inline">\(,要么吃完后不是最小的,要么\)</span>f </em>{ i - 1
} = 0 $.</p>
<p>递归做就好了.另外这题需要复杂度$O ( n )
$,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5>
<p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5>
<p>首先考虑如果有人作为第$n - p + 1 <span class="math inline">\(个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读\)</span>n
- p $个人.</p>
<p>继续思考,如果有人作为第$n - 2 p + 1
$个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有$n p <span class="math inline">\(个人复读,并且一定是前\)</span>n p
$在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5>
<p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录$f
<em>{ i , j } <span class="math inline">\(表示当前的\)</span>G <span class="math inline">\(是\)</span>i <span class="math inline">\(,\)</span>G <span class="math inline">\(的倍数还剩下\)</span>j <span class="math inline">\(个,然后做转移,再进一步发现我们只关心\)</span>j
<span class="math inline">\(的奇偶性.于是记\)</span>f </em>{ i , 0 / 1 }
$即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5>
<p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在$[
l _i , r _i ] $,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为$0
$.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为$0
$.</p>
<p>换句话说,我们现在有$x _1 , x _2 , x _3 <span class="math inline">\(,我们要将其中一个\)</span>x _i <span class="math inline">\(改为\)</span>y _i $,其他不变,使得他们仨异或值为$0
<span class="math inline">\(.和Nim游戏类似,假设他们仨异或值的最高位为\)</span>k
<span class="math inline">\(.那么一定有一个\)</span>x _i <span class="math inline">\(的第\)</span>k $位为$1 $,将它改为$0
$,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的$[
l _i , r _i ] $求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5>
<p>Nim游戏,但是每堆石子有一个$K _i <span class="math inline">\(.如果这堆石子剩\)</span>x _i <span class="math inline">\(个每次最多取\)</span> { K _i }
$个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-n k,k)&amp;n(k)\</p>
<p>n k&amp;n=0(k)\</p>
<p>\end{cases}\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于$k <span class="math inline">\(是否大于\)</span>
<span class="math inline">\(讨论一下,如果\)</span>k &lt; <span class="math inline">\(暴力,最多只会做\)</span> <span class="math inline">\(次.否则,意识到此时可以通过求一个区间\)</span>[ l ,
r ] <span class="math inline">\(,满足\)</span>x , { k } <span class="math inline">\(均相等,加速一下.这种区间最多只会有\)</span>
$个.</p>
<h5><span id="problem7">Problem7</span></h5>
<p>一个数$N
$,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当$N = 2 ^k $,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5>
<p>A和B,有$n <span class="math inline">\(颗石子,每次可以取\)</span>x
$颗,其中$1 x { 2 } \ $.</p>
<p>仍然令石子数量为状态,注意到$SG ( x ) = 0 <span class="math inline">\(当且仅当\)</span>x + 1 = 2 ^k - 1 <span class="math inline">\(,也即\)</span>x = 2 ^k - 2 \ $.首先,注意到:</p>
$$
<span class="math display">\[\begin{aligned}
n - \lceil \frac { n  } { 2  } \rceil &amp; = \lfloor \frac { n  } {
2  } \rfloor \\
SG ( n ) &amp; = mex \{ SG ( y ) | \lfloor \frac { n  } { 2  } \rfloor
&amp; \leq y &amp; \leq n - 1 \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>设$n = 2 ^k - w $,其中:</p>
$$
<span class="math display">\[\begin{aligned}
- 2 ^{ k - 1  } + 2 &amp; \leq w &amp; \leq 2 \\
\lfloor \frac { 2 ^k - w  } { 2  } \rfloor &amp; = 2 ^{ k - 1  } -
\lfloor \frac { w  } { 2  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>当$w = 2 <span class="math inline">\(时,原式\)</span>= 2 ^{ k - 1 } -
1 &gt; 2 ^{ k - 1 } - 2 \ $.反之.$2 ^k - 2
$原式.因此数学归纳即可证明.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">北大相关选拔数学真题汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3>
<h4><span id="problem4">Problem4</span></h4>
<p>设$G ( x ) = ( x ^2 + x - 1 ) ^{ 100 } = _{ k = 0 } ^{ 200 } a _k x
^k $,求$2 a _0 - a _1 - a _2 + 2 a <em>3 - a <em>4 - a <em>5 + + 2 a
</em>{ 198 } - a </em>{ 199 } - a </em>{ 200 } $.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑求出$<em>{ 0 k } { a </em>{ 3 k } } <span class="math inline">\(.直接取三次单位根\)</span>_3 = - { 2 } + { 2 } i
$,自然有$1 + _3 + _3 ^2 = 0 <span class="math inline">\(,所以\)</span>G
( 1 ) + G ( <em>3 ) + G ( <em>3 ^2 ) = 3 </em>{ 0 k } { a </em>{ 3 k } }
$.</p>
<p>所以答案显然是$G ( _3 ) + G ( _3 ^2 ) = ( - 2 ) ^{ 100 } + ( - 2 ) ^{
100 } = 2 ^{ 101 } $.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>等差数列中,$a <em>1 &gt; 0 <span class="math inline">\(,公差\)</span>d &lt; 0 , { a </em>{ 30 } } &lt; -
1 <span class="math inline">\(,求最大的正整数\)</span>n <span class="math inline">\(,使得\)</span>S _n &gt; 0 $.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>显然$S <em>{ 60 } = 30 ( a </em>{ 30 } + a <em>{ 31 } ) &lt; 0 , S
</em>{ 59 } = 59 a _{ 30 } &gt; 0 $.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>全为整数的等差数列,$d = 4 <span class="math inline">\(,求所有满足\)</span>S _n = 2024 <span class="math inline">\(的\)</span>n $的和.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>则$n ( 2 n - 2 + a _1 ) = 2024 = 2 ^3 <span class="math inline">\(.显然只要\)</span>n | 2024 $即可.</p>
<p>所有$n <span class="math inline">\(的和自然是\)</span>( 1 + 2 + 4 + 8
) ( 1 + 11 ) ( 1 + 23 ) = 15 = 4320 $.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>整数数列$U <em>n <span class="math inline">\(满足\)</span>U <em>0 = 1
<span class="math inline">\(,且当\)</span>n <span class="math inline">\(的时候\)</span>U </em>{ n + 1 } U </em>{ n - 1 } =
kU <em>n <span class="math inline">\(,其中\)</span>k <span class="math inline">\(是一个正整数.问能让\)</span>U </em>{ N } = N <span class="math inline">\(的\)</span>k <span class="math inline">\(的个数有多少个,其中\)</span>N = 2024 $.</p>
<h5><span id="solution14">Solution14</span></h5>
<p>则$U <em>{ n + 1 } = { U </em>{ n - 1 } } , { U <em>n } = k { U
</em>{ n - 1 } } { U _n } $.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设$T
<em>n = </em>{ k = 1 } ^n U _k , W _n = U <em>n </em>{ k = 1 } ^{ n - 2
} U _k $.</p>
<p>注意到$W <em>n = kW </em>{ n - 1 } , W <em>1 = U <em>1 , W <em>n = k
^{ n - 1 } U <em>1 <span class="math inline">\(.又注意到\)</span>T <em>n
= kU </em>{ n - 1 } W </em>{ n - 1 } = kW </em>{ n - 1 } { T </em>{ n -
2 } } = k ^{ n - 1 } U <em>1 { T </em>{ n - 2 } } = ( k ^{ n - 1 } U
<em>1 ) ( k ^{ n - 2 } U <em>1 ) { T </em>{ n - 3 } } <span class="math inline">\(,\)</span>T </em>{ n - 3 } = ( k ^{ n - 4 } U
<em>1 ) ( k ^{ n - 5 } U <em>1 ) { T </em>{ n - 6 } } <span class="math inline">\(.所以\)</span>T </em>{ n } = k ^6 T </em>{ n - 6 }
<span class="math inline">\(,所以\)</span>U $存在长度为$6 <span class="math inline">\(的循环节.所以\)</span>U <em>{ N } = { T </em>{ N -
1 } } = { T _1 } = U _2 = kU _1 $.(其实直接暴力找循环节也是可以的)</p>
<p>所以$k <span class="math inline">\(需要是\)</span>N $的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设$w = U _1 <span class="math inline">\(,则\)</span>U $的前六项是:$1
, w , kw , k ^2 , { w } , { w } <span class="math inline">\(.要求\)</span>kw = N , w | k <span class="math inline">\(,所以\)</span>( 11 ) | k <span class="math inline">\(,\)</span>k <span class="math inline">\(.所以\)</span>k = 4 <span class="math inline">\(或\)</span>k = 8 $.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>求使方程$ { x } = N = 2024 <span class="math inline">\(恰有两个整数解的正整数\)</span>n $的个数.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
N &amp; \leq \frac { 10 ^n  } { x  } &amp; &lt; N + 1 \\
xN &amp; \leq 10 ^n &amp; &lt; x ( N + 1 ) \\
\frac { 10 ^n  } { N + 1  } &amp; &lt; x &amp; \leq \frac { 10 ^n  } {
N  } \\
\lfloor \frac { 10 ^n  } { N + 1  } \rfloor &amp; &lt; x &amp; \leq
\lfloor \frac { 10 ^n  } { N  } \rfloor \\
\lfloor \frac { 10 ^n  } { N  } \rfloor - \lfloor \frac { 10 ^n  } { N +
1  } \rfloor &amp; = 2 \\
\frac { 10 ^n  } { N ( N + 1 )  } - \frac { 10 ^n \bmod N  } { N  } +
\frac { 10 ^n \bmod { ( N + 1 )  }  } { N + 1  } &amp; = 2
\end{aligned}
\]</span></p>
<p>显然$ { N ( N + 1 ) } = 1 , 2 , 3 <span class="math inline">\(.而\)</span>N ( N + 1 ) = 4098600 <span class="math inline">\(,所以只有\)</span>n = 7
$可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是$5 ! = 30 $.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>$f ( x ) = x + x + x + x , x <span class="math inline">\(,求其不超过\)</span>n = 2024
$的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>显然$f ( x + 1 ) = f ( x ) + 20 <span class="math inline">\(,因此我们先考虑\)</span>x , n = 2024 <span class="math inline">\(中分别独立随机两个正整数(可以相同)\)</span>a , b
$,则求$3 ^a + 7 ^b $的概率.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>考虑$( 10 ) = 4 <span class="math inline">\(,所以原题答案等价于\)</span>n = 4
$的时候的答案.在这$16 <span class="math inline">\(中可能性中满足条件的只有三种,概率为\)</span> { 16
} $.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3>
<h4><span id="problem3">Problem3</span></h4>
<p>已知$a <em>1 = { 2 } , a </em>{ n + 1 } = a _n ^2 - 2 <span class="math inline">\(,求\)</span>a _n , n = 2023 $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>这个一看就不是好解的,想都别想直接数学归纳,注意到$a _n = { 2 ^{ 2 ^{ n
- 1 } } } <span class="math inline">\(,那么\)</span>a _n = 2 ^{ 2 ^{ n -
1 } } $.</p>
<p>而$( 7 ) = 6 , ( 6 ) = 2 $.由扩展欧拉定理,立刻有:$2 ^{ 2 ^{ 2022 } }
^{ 2 ^{ 2022 } } ^{ 2 ^{ 6 } } $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>$50 <span class="math inline">\(个队伍两两打比赛,胜一场积分\)</span>+
1 $,负一场积分不变,无平局.</p>
<p>且任取$27 $支队伍,其中一定有一支队伍负于其它的$26
$支,也一定有一支队伍胜于其它的$26 $支.</p>
<p>问$50 $支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>答案是$50 $.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都$ <span class="math inline">\(的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都\)</span>&gt;
27 <span class="math inline">\(,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为\)</span>k
<span class="math inline">\(的简单环,由鸽笼原理,剩下的\)</span>n - k
<span class="math inline">\(个点中至少有\)</span> { 2 } <span class="math inline">\(个点对着\)</span>k <span class="math inline">\(个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要\)</span>k
+ { 2 } <span class="math inline">\(即可,此时\)</span>k
$即可.由于这是竞赛图,显然存在长度为$4 $的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为$u <span class="math inline">\(.我们任意取一个击败过它的点(如果有的话),假设为\)</span>v
$,再取$25 <span class="math inline">\(个被\)</span>u <span class="math inline">\(击败的点(显然这些点存在),设这些点集为\)</span>S
<span class="math inline">\(.则\)</span>u , v , S <span class="math inline">\(组成的集合中,有一个点可以击败其它所有点,根据假设,只能是\)</span>v
<span class="math inline">\(.由此,可以知道,只要是\)</span>u <span class="math inline">\(能击败的点,\)</span>v <span class="math inline">\(一定能击败,而且\)</span>v <span class="math inline">\(能击败\)</span>u <span class="math inline">\(,因此\)</span>_v &gt; _u <span class="math inline">\(,与假设不符.因此一定不存在一个\)</span>v <span class="math inline">\(可以击败\)</span>u <span class="math inline">\(.删掉\)</span>u
$后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>一只蚂蚁第一天在$( 0 , 0 ) <span class="math inline">\(,第\)</span>k
+ 1 <span class="math inline">\(天向上下左右随机一个方向移动\)</span> {
4 ^k } <span class="math inline">\(单位,求第\)</span>n <span class="math inline">\(天的可能位置数量,\)</span>n = 2023 $.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>不妨设第$n <span class="math inline">\(天不同位置数量为\)</span>S _n
<span class="math inline">\(,显然只要前面岔开了,后面永远无法走到一个点.所以\)</span>S
<em>1 = 1 , S </em>{ n + 1 } = 4 S <em>n , S </em>{ 2023 } = 4 ^{ 2022 }
$.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>集合$U = { 1 , 2 , , n } , n = 10 <span class="math inline">\(,求\)</span>U
$中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>集合是无序的,这个很难搞,我们先从$U $中把$1 $去掉最后再加上.</p>
<p>先考虑可以重复放$1 $的情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^{ n  } \sum _{ k = 1  } ^{ n  } [
\gcd ( i , j ) &amp; = 1 ] [ \gcd ( i , k ) &amp; = 1 ] [ \gcd ( j , k )
&amp; = 1 ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从$1 , 3 , 5 , 7 , 9 $中选,答案应该是$1 + 2
{ 2 } = 7 $.</p>
<p>接下来考虑选一个偶数,如果选$2 , 4 , 8 $是等价的,答案此时是$3 ( { 2 }
- 1 ) = 27 $.如果选$6 <span class="math inline">\(的话答案是\)</span> {
2 } = 3 $.如果选$10 <span class="math inline">\(的话方案数是\)</span> {
2 } - 1 = 5 $,加起来方案数是$42 $.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>集合$U = { 1 , 2 , , n } , n = 366 <span class="math inline">\(,则\)</span>U $的互不相交且各元素之和为$17
$的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5>
<p>考虑$ { 17 } = 21 , 366 $.答案显然是$21 + 10 + 1 = 179 $个.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>三个互不相同的数的$= 20 , = 20000
$,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然等价于$= 1 , = 1000 = 2 ^3 ^3 <span class="math inline">\(.先只分析其中一个质因子,方案应该是\)</span>( 0 , 0
, 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , ( 0 , 3 , 3 )
$,打乱一下顺序的话就共有$3 + 6 + 6 + 3 = 18
$种方案.如果可以重复,平方一下得到$324 $.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有$2
= 12 $种,于是答案为$312 $.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>求$ { n } , k , n = 2023 $种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5>
<p><span class="math display">\[
\begin{aligned}
\lfloor \frac { k ^2  } { n  } \rfloor &amp; = d \\
d &amp; \leq \frac { k ^2  } { n  } &amp; &lt; d + 1 \\
nd &amp; \leq k ^2 &amp; &lt; n ( d + 1 )
\end{aligned}
\]</span></p>
<p>由于两个完全平方数的差是固定的,不妨猜测存在一个$k _0 <span class="math inline">\(,\)</span>k _0 <span class="math inline">\(的\)</span>k <span class="math inline">\(会扎堆,但是这些\)</span>d <span class="math inline">\(全都能取到,\)</span>&gt; k _0 <span class="math inline">\(的则不会有两个\)</span>k <span class="math inline">\(得到相同的元素.所以前者统计不同的\)</span>d <span class="math inline">\(,后者统计不同的\)</span>k <span class="math inline">\(考虑\)</span>( k + 1 ) ^2 - k ^2 = 2 k + 1 <span class="math inline">\(.分界线应该是\)</span>k _0 = 1011 $.</p>
<p>所以答案应该是$n - k _0 + { 2 k _0 + 1 } + 1 = 1012 + 506 = 1518
$.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>对四元组$( a , b , c , d ) $计数,满足$101 | ( a + b + c + d ) $且$0
&lt; a &lt; b &lt; c &lt; d $.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>这题真的厉害啊.</p>
<p>不妨设$S _k <span class="math inline">\(为满足\)</span>( a + b + c +
d ) k $的满足$0 &lt; a &lt; b &lt; c &lt; d <span class="math inline">\(的四元组数量.不难发现\)</span>S _k = { 4 } $.</p>
<p>注意到$( a , b , c , d ) ( a + 1 , b + 1 , c + 1 , d + 1 ) <span class="math inline">\(,注意这里是\)</span> <span class="math inline">\(意义下的加法,这是一个双射,所以\)</span>S <em>{ k }
= S </em>{ k + 4 } <span class="math inline">\(,下标同样也是\)</span>
<span class="math inline">\(意义下进行的.又因为\)</span>( 101 , 4 ) = 1
<span class="math inline">\(,所以所有的\)</span>S _k <span class="math inline">\(均相等.\)</span>S _0 = { 101 } = 40425 $.</p>
<h4><span id="problem16">Problem16</span></h4>
<p>问方程$x x = 6 $的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5>
<p>$6 = x x x ^2 <span class="math inline">\(,所以\)</span>x = ,
$.显然都不可以.所以个数为$0 $.</p>
<h4><span id="problem17">Problem17</span></h4>
<p>设$R ( n ) = _{ k = 2 } ^{ 10 } ( n k ) <span class="math inline">\(,求满足\)</span>R ( n ) = R ( n + 1 ) <span class="math inline">\(的十进制下的两位数\)</span>n $的个数.</p>
<h5><span id="solution17">Solution17</span></h5>
<p>从$R ( n ) <span class="math inline">\(到\)</span>R ( n + 1 )
$,应该是加了若干个$1 <span class="math inline">\(,然后又丢了几个\)</span>k - 1
$这样的.那就一定需要丢掉的数字之和为$9 <span class="math inline">\(.枚举一下,丢了的只有可能是以下情况:\)</span>( 9 )
, ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 + 3 + 2 ) <span class="math inline">\(,分别对应了\)</span>n + 1 <span class="math inline">\(应该是分别以下数的倍数\)</span>( 9 ) , ( 14 ) , (
6 ) , ( 20 ) , ( 12 ) <span class="math inline">\(,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:\)</span>(
7 + 2 ) <span class="math inline">\(,并且分别不能是以下数字的倍数\)</span>( 3 , 4 , 5
) $.</p>
<p>取一下的话$n + 1 $可以是:$14 , 98 <span class="math inline">\(,\)</span>n = 13 , 97
$,验证一下均合法,所以答案为$2 $.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>已知$a &lt; b &lt; c &lt; d <span class="math inline">\(,而\)</span>x
, y , z , w <span class="math inline">\(是\)</span>a , b , c , d <span class="math inline">\(的一个排列,求\)</span>( x - y ) ^2 + ( y - z ) ^2
+ ( z - w ) ^2 + ( w - x ) ^2 $得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>圆排列个数是$3 ! = 6 $个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是$( x , y , z , w )
, ( x , z , w , y ) , ( x , w , y , z ) $.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 \\
&amp; = 2 ( x ^2 + z ^2 + y ^2 + w ^2 ) - 2 ( xy + yz + zw + wx )
\end{aligned}
\]</span></p>
<p>显然只要$xy + yz + zw + wx
$不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>已知$0 &lt; x _1 &lt; x _2 &lt; &lt; x <em>9 <span class="math inline">\(且\)</span></em>{ k = 1 } ^9 x <em>k = 220 <span class="math inline">\(,在\)</span></em>{ k = 1 } ^5 x _k <span class="math inline">\(最大的前提下,最小化\)</span>x _9 - x _1 $.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>不妨枚举一下$x _5 <span class="math inline">\(选啥,设\)</span>f ( S ,
m , k ) <span class="math inline">\(表示选出\)</span>k <span class="math inline">\(个互不相同的数,使得它们\)</span>m <span class="math inline">\(且总和为\)</span>S <span class="math inline">\(,是否可行.不难发现\)</span>f ( S , m , k ) = [ { 2
} S { 2 } ] $.</p>
<p>那我们要求的就是:</p>
<p><span class="math display">\[
\begin{aligned}
\max _{ 5 \leq x _5  } \{ S | f ( 220 - 4 x _5 - S , + \infty , 4 )
&amp; = 1 \land f ( S - x _5 , x _5 - 1 , 4 ) &amp; = 1 \} \\
&amp; = \max _{ 5 \leq x _5  } \{ S | 4 x _5 + S &amp; \leq 210 \land 10
+ x _5 &amp; \leq S &amp; \leq 5 x _5 - 10 \} \\
&amp; = \max _{ 5 \leq x _5  } ( \min \{ 5 x _5 - 10 , 210 - 4 x _5 \} )
\end{aligned}
\]</span></p>
<p>立刻得到$x _5 = 24 , 25 , S = 110
$,那么后面的选法就一定了,后面四个数一定是$26 , 27 , 28 , 29 <span class="math inline">\(,只需要让\)</span>x _1 $最大即可</p>
<p>$x _5 = 24 $时,此时最优显然是$20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 ,
29 <span class="math inline">\(,\)</span>x _9 - x _1 = 9 $.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>有一个$n <span class="math inline">\(边形,其中有\)</span> { 2 } <span class="math inline">\(条对角线,不存在三线交于一点的情况,问这些对角线将该\)</span>n
<span class="math inline">\(边形分成了多少个部分.\)</span>n = 10 $.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了$ { 4 }
$个点(任意四个点有且只有一种交法),每交一个点就会多出$2
$条边,所以多出来了$2 { 4 } + { 2 } $条边.</p>
<p>考虑内部的若干个部分一定是$a _3 <span class="math inline">\(个三角形,\)</span>a _4 <span class="math inline">\(个四边形,...,\)</span>a _k <span class="math inline">\(个\)</span>k $边形,总之我们发现:</p>
<p><span class="math display">\[
\begin{cases}
\sum _{ j = 3  } ^k ( j - 2 ) \pi a _j = ( n - 2 ) \pi + 2 \pi \binom {
n  } { 4  } \\
\sum _{ j = 3  } ^k ja _j = n + 4 \binom { n  } { 4  } + n ( n - 3 )
\end{cases}
\]</span></p>
<p>两式得到:$_{ j = 3 } ^k a _j = { 2 } + { 4 } $.</p>
<p>$n = 10 $的时候,答案为$246 $.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求$_{ i = 1 } ^n { 20 } , n = 2024 $.</p>
<h5><span id="solution1">Solution1</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \\
&amp; = \sum _{ i = 1  } ^n \lfloor \frac { \sum _{ k = 0  } ^i 20 ^k (
- 1 ) ^{ i - k  } \binom { i  } { k  }  } { 20  } \rfloor \\
&amp; = - \lfloor \frac { n  } { 2  } \rfloor + \sum _{ i = 1  } ^{ n  }
\frac { 19 ^i - ( - 1 ) ^i  } { 20  } \\
&amp; = - \lfloor \frac { n  } { 2  } \rfloor + \frac { \frac { 19  } {
18  } ( 19 ^n - 1 ) - ( \frac { ( - 1 ) ^n - 1  } { 2  } )  } { 20  }
\end{aligned}
\]</span></p>
<p>带入$n = 2024 <span class="math inline">\(并\)</span> $,原式为:</p>
<p><span class="math display">\[
\equiv - 4 + \frac { 5  } { 4  } ( 1 - 5 ^n ) \equiv - 4 + 3 ( 1 - 5 ^n
)
\]</span></p>
<p>注意到$2024 = 2 <span class="math inline">\(,原式\)</span>- 4 - 9
$.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>求长度为$n <span class="math inline">\(的排列个数,使得排列中\)</span>i , a <em>i = a
</em>{ i + 1 } - 1 <span class="math inline">\(.\)</span>n = 8 $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>一眼容斥,也就是每个长度为$k <span class="math inline">\(的连续段的容斥系数应该是\)</span>( - 1 ) ^{ k - 1
} <span class="math inline">\(.那么设分成了\)</span>w <span class="math inline">\(个段,总的容斥系数应该是\)</span>( - 1 ) ^{ n - w }
<span class="math inline">\(,答案就是\)</span>f <em>{ n ’ } = </em>{ w =
1 } ^n ( - 1 ) ^{ n - w } w ! { w - 1 } = <em>{ w = 0 } ^{ n ’ } ( - 1 )
^{ n ’ - w } { w } ( w + 1 ) ! = n ’ ! </em>{ w = 0 } ^{ n ’ } { w ! } (
n ’ - w + 1 ) $,此时已经能算出答案是$16687 $.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设$g <em>n <span class="math inline">\(为错排数量,显然有\)</span>f </em>{ n } = nf <em>{
n - 1 } + g </em>{ n } $,立刻算出答案是$16687 $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>已知数列$1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , <span class="math inline">\(,求其第\)</span>n <span class="math inline">\(项\)</span> <span class="math inline">\(的值,\)</span>n = 2024 $.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑第一个值为$k <span class="math inline">\(的地方应该在哪里.显然\)</span>a <em>{ { 2 } + 1 }
= k <span class="math inline">\(.注意到\)</span>a </em>{ 2081 } = 65
<span class="math inline">\(,所以\)</span>a _n = 64 <span class="math inline">\(,其\)</span> = 4 $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>求四元组$( a _1 , a _2 , a _3 , a _4 ) <span class="math inline">\(的个数,满足\)</span>a _1 , a _2 , a _3 , a _4 { 1
, 2 , 3 } $,且$10 &lt; a _1 a _2 a _3 a _4 &lt; 20 $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>排个序按照字典序开搜,只有三种可能:${ 3 , 3 , 2 , 1 } , { 3 , 2 , 2 ,
1 } , { 2 , 2 , 2 , 2 } $,打乱顺序的话就有$25 $种可能.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>求$ <span class="math inline">\(上方程\)</span>x ^2 - 13 x + 11 = 0
$的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>首先注意到$x = { 13 } $,那么自然有方程组:</p>
<p><span class="math display">\[
\begin{cases}
\frac { x ^2 + 11  } { 13  } \leq x \\
x &lt; \frac { x ^2 + 11  } { 13  } + 1
\end{cases}
\]</span></p>
<p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑$x ^2
$这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设$x = $的形式,带入有不等式:</p>
<p><span class="math display">\[
\begin{aligned}
k - x + 1 &amp; \leq 0 &amp; &lt; k - x + 2 \\
1 &amp; \leq \sqrt { 2 + 13 k  } - k &amp; &lt; 2 \\
\begin{cases}
0 &lt; k ^2 - 9 k + 2 \\
k ^2 - 11 k - 1 \leq 0
\end{cases}
\end{aligned}
\]</span></p>
<p>冷静一下!注意到$0 k <span class="math inline">\(,又根据第一个不等式得知大部分\)</span>k <span class="math inline">\(应该会很大,开始暴力枚举一下,合法的情况有:\)</span>k
= 0 , 9 , 10 , 11 $,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4>
<p>在一个体积为$1 <span class="math inline">\(的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积\)</span>
{ 8 } $的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5>
原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积$
{ 8 } <span class="math inline">\(.考虑设这个点是\)</span>( x , x , h )
<span class="math inline">\(,那么必然有\)</span>
<span class="math display">\[\begin{cases}( 1 - h ) x ^2 &gt; \frac {
1  } { 8  } \\ h ( 1 - x ) ^2 &gt; \frac { 1  } { 8  }
\end{cases}\]</span>
<p>$,化简,只要$8 &gt; { x ^2 } + { ( 1 - x ) ^2 }
$即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取$( 0 . 5 , 0 . 5 , 0 . 1 ) <span class="math inline">\(即可.那么是不是可以证明答案一定\)</span>&gt; 3
$呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积$ {
8 } <span class="math inline">\(的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为\)</span>(
x , y , h ) , x , y , h { 2 } $,然后证明$8 &gt; { xy } + { ( 1 - x ) ( 1
- y ) } , x , y { 2 } $这个不等式无解即可.</p>
<p>由基本不等式,$ { xy } + { ( 1 - x ) ( 1 - y ) } = 8 $,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>设$S ( n ) <span class="math inline">\(表示正整数\)</span>n <span class="math inline">\(的十进制数码和,求满足\)</span>S ( n ) S ( n + 1 )
<span class="math inline">\(的最小的\)</span>n $.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>显然必须发生进位,不妨设$n = 10 ^k a + 10 ^k - 1 <span class="math inline">\(,\)</span>a <span class="math inline">\(,\)</span>S ( n ) = S ( a ) + 9 k , S ( n + 1 ) =
S ( a ) + 1 $,</p>
<p>此时显然有$9 k - 1 <span class="math inline">\(,\)</span>k <span class="math inline">\(.\)</span>n _{ } = 49999 $.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>求满足以下条件的最大的正整数$n <span class="math inline">\(:十进制下每一位数字互不相同,且\)</span>m , 10 ^m n
, { 10 ^m } | n $.</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是$0 $.</p>
<p>不妨设其为$ <span class="math inline">\(,其中\)</span>b = 10 c <span class="math inline">\(,\)</span>a <span class="math inline">\(是\)</span>b <span class="math inline">\(的因子,不妨枚举一下\)</span>k = { a } <span class="math inline">\(.注意到因为\)</span>a $中不能有$0 <span class="math inline">\(,所以\)</span>k { 2 , 4 , 5 , 8 } <span class="math inline">\(.取\)</span>k = 2 $试出来$3570 <span class="math inline">\(是合法的,而且显然\)</span>k { 4 , 5 , 8 }
$的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>$a <em>1 = , a </em>{ n + 1 } = a _n + { a _n - a <em>n } <span class="math inline">\(,求\)</span></em>{ k = 1 } ^{ n } a _k , n = 2024
$.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>这一看就是个环,设$a _n = b _n + c _n $.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<p><span class="math display">\[
\begin{cases}
a _1 = 0 + \sqrt { 2  } \\
a _2 = 2 + \sqrt { 2  } \\
a _3 = 4 + \sqrt { 2  } \\
\cdots
\end{cases}
\]</span></p>
<p>容易猜测$b _n = 2 ( n - 1 ) , c _n = 1 <span class="math inline">\(.也就是\)</span>a _n = 2 ( n - 1 ) +
$,数学归纳一下即可.</p>
<p>那么$_{ k = 1 } ^n a _k = n ( n - 1 ) + n <span class="math inline">\(,带入\)</span>n = 2024 $即可.</p>
<h3><span id="2022图选">2022图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol type="1">
<li><p>任意两个正方形至多有一个顶点重合</p></li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol type="1">
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p></li>
<li><p>边可以相交,放到正十二边形的边上.</p></li>
</ol>
<h4><span id="problem2">Problem2</span></h4>
<p>求$( { 2 } ) ^{ 12 } $.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>考虑$( { 2 } ) ^3 = 2 + <span class="math inline">\(,\)</span>( { 2 }
) ^{ 12 } = 161 + = 321 $.</p>
<p>也可以考虑类似斐波那契数列,取$f <em>n = ( { 2 } ) ^{ n } + ( { 2 } )
^{ n } <span class="math inline">\(,其满足\)</span>f <em>n = f </em>{ n
- 1 } + f </em>{ n - 2 } , f _0 = 2 , f <em>1 = 1 <span class="math inline">\(,取\)</span>f </em>{ 12 } - 1 $就是答案$321 $.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于一个加法乘法环,要求你利用:</p>
<ol type="1">
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p></li>
<li><p>加法结合律、逆元.</p></li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>倒反天罡题.</p>
<p>注意到$( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a + 1 ) <span class="math inline">\(,所以\)</span>a + b = b + a $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你$n <span class="math inline">\(个数集\)</span>a _i <span class="math inline">\(,其中\)</span>| a _i | = i + 1 <span class="math inline">\(,要你选出\)</span>n <span class="math inline">\(个两两不同的数字满足\)</span>x _i a _i
$,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是$2 ^n $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice和Bob博弈.Alice先选一个数$m <span class="math inline">\(,然后Bob选一个数\)</span>n ( n &gt; m ) <span class="math inline">\(,并构造一个\)</span>n <span class="math inline">\(个点的竞赛图.Alice如果能从中选出\)</span>m <span class="math inline">\(个不同的点,满足不存在某个点\)</span>x <span class="math inline">\(到这\)</span>m
$个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是$( 1 - { 2 ^m } ) ^{
n - 2 } <span class="math inline">\(,因此期望为\)</span>E = { m } ( 1 -
{ 2 ^m } ) ^{ n - 2 } <span class="math inline">\(,只需\)</span>n <span class="math inline">\(足够大的时候期望\)</span>&lt; 1 $,则说明一定存在$0
$,也就是Bob总有必胜策略.</p>
<p>注意到只需证明$n <span class="math inline">\(,\)</span> { m } &lt; (
{ 2 ^m - 1 } ) ^{ n - 2 } <span class="math inline">\(,而\)</span> { m }
= { m ! } &lt; n ^m <span class="math inline">\(.下面证明\)</span>n , n
^m &lt; ( { 2 ^m - 1 } ) ^{ n - 2 } $.</p>
<p>两边取$<span class="math inline">\(,不妨假设\)</span>n <span class="math inline">\(,有\)</span>m n &lt; ( n - 2 ) ( { 2 ^m - 1 } ) ,
{ ( { 2 ^m - 1 } ) } &lt; { n } <span class="math inline">\(,\)</span> {
n } <span class="math inline">\(显然在\)</span>n <span class="math inline">\(的时候单增,所以一定存在这么一个\)</span>n $.</p>
<h3><span id="2023图选">2023图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>求正整数拆分成有序的$1 , 2 $序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>定义$* <span class="math inline">\(为集合\)</span>G
$上的二元运算,已知:</p>
<ol type="1">
<li><p>满足结合律$a ∗ b ∗ c = a ∗ ( b ∗ c ) $.</p></li>
<li><p>存在左单位元$e <span class="math inline">\(,对任意\)</span>a
<span class="math inline">\(满足\)</span>e ∗ a = a $.</p></li>
<li><p>对任意$a <span class="math inline">\(存在左逆元\)</span>b <span class="math inline">\(,使\)</span>b ∗ a = e $.</p></li>
</ol>
<p>问:</p>
<ol type="1">
<li><p>左单位元是否也为右单位元.</p></li>
<li><p>左逆元是否也为右逆元.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>看(2),考虑设$b <span class="math inline">\(是\)</span>a <span class="math inline">\(的左逆元,\)</span>c <span class="math inline">\(是\)</span>b <span class="math inline">\(的左逆元,则\)</span>cba = ce = a , ab = ceb = e
$.</p>
<p>看(1),设$b <span class="math inline">\(是\)</span>a <span class="math inline">\(的逆元,\)</span>ea = aba = ae
$,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明$ab <span class="math inline">\(的时候\)</span>b <span class="math inline">\(不能彻底损失信息,而观察\)</span>ab = eab <span class="math inline">\(知道\)</span>a $也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算$(
a _1 , b _1 ) ( a _2 , b _2 ) <span class="math inline">\(,想办法让其损失掉\)</span>( a _1 , b _1 ) <span class="math inline">\(中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到\)</span>(
a _1 , b _1 ) ( a _2 , b _2 ) = ( a _1 + a _2 , b _2 ) <span class="math inline">\(即可,存在左幺元为\)</span>( 0 , 0 ) <span class="math inline">\(,右逆元为\)</span>( - a , 0 ) $.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>$f <span class="math inline">\(的定义域和值域都是正整数并且\)</span>f
( xy ) = f ( x ) + f ( y ) - 1 $,求:</p>
<ol type="1">
<li><p>是否存在这样的函数.</p></li>
<li><p>是否存在无数个这样的函数.</p></li>
<li><p>是否存在严格递增的函数.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>令$g ( x ) = f ( x ) - 1 <span class="math inline">\(,则\)</span>g (
xy ) = g ( x ) + g ( y ) $.</p>
<p>对于(1),取$g ( x ) = 0 , f ( x ) = 1 $即可.</p>
<p>对于(2),考虑$g ( p ^k ) = kg ( p ) <span class="math inline">\(,只需要让\)</span>g ( p ) $取不同的值即可.</p>
<p>对于(3),考虑$g ( 2 ^a ) = ag ( 2 ) <span class="math inline">\(,\)</span>g ( 3 ^b ) = bg ( 3 ) $.</p>
<p>考虑构造$a , b $,使得$2 ^a &lt; 3 ^b <span class="math inline">\(但是\)</span>ag ( 2 ) bg ( 3 ) <span class="math inline">\(.不妨取\)</span>a = { g ( 2 ) } $,那么必定有:</p>
$$
<span class="math display">\[\begin{aligned}
2 ^{ \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil  } &amp; &lt; 3 ^b
\\
\lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil &amp; &lt; b \log _2 3 \\
\frac { bg ( 3 )  } { g ( 2 )  } + \Delta &amp; \leq b \log _2 3 \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是如果存在,必定需要$ { g ( p <em>2 ) } </em>{ p _2 } p _1 { g ( p
<em>1 ) } </em>{ p _1 } p _2 <span class="math inline">\(,也就是\)</span> { g ( p <em>1 ) } = </em>{ p _1 }
p _2 $.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于任意$2 n - 1 <span class="math inline">\(个正整数(可重复),问其中是否一定有\)</span>n <span class="math inline">\(个数的和能被\)</span>n <span class="math inline">\(整除,这题\)</span>n = 50 $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑当$n <span class="math inline">\(是合数的时候,设\)</span>n = pq
<span class="math inline">\(,则可以将其拆成\)</span>q - 1 $组每组$2 p
$个数以及一组$2 p - 1 <span class="math inline">\(个数,因此只需要这些都可以找到\)</span>p <span class="math inline">\(个数使得其是\)</span>p $的倍数,组合起来就行了.</p>
<p>只需要解决$n $是质数的情况.</p>
<p>感觉场上的最优解应该是解决$n = 2 <span class="math inline">\(和\)</span>n = 5 <span class="math inline">\(的情况然后拼成\)</span>n = 50 $.</p>
<p>$n = 2 $的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然$S = <em>{ } ( x </em>{ p <em>1 } + x
</em>{ p <em>2 } + + x </em>{ p _n } ) ^{ p - 1 } { n } $.</p>
<p>但是考虑左边那个多项式的每一项,形如$c <em>{ i = 1 } ^k x </em>{ p _i
} ^{ e _i } <span class="math inline">\(.注意到\)</span>c <span class="math inline">\(一定是\)</span> { n - k } <span class="math inline">\(的倍数,而后者\)</span>n $为$0 $.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为$1 <span class="math inline">\(并不是对称的,而左边是个对称式子,某个\)</span>x
$增大也无所谓,这意味着左边应该是为$0 $的,我们要做的就是去证明它是$0
$.</p>
<h3><span id="2024图选">2024图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问在双曲线$xy = 1 $上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>不会做,取个特殊值知道答案应该是$[ 2 , + ) $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol type="1">
<li><p>如果$n , m <span class="math inline">\(都是好的,那么\)</span>nm
$是好的.</p></li>
<li><p>$2024 $不是好的.</p></li>
</ol>
<h5><span id="solution2">Solution2</span></h5>
<p>如果$n = a ^2 + b ^2 , m = c ^2 + d ^2 <span class="math inline">\(,那么\)</span>nm = a ^2 c ^2 + a ^2 d ^2 + b ^2 c
^2 + b ^2 d ^2 = ( ac - bd ) ^2 + ( ad + bc ) ^2 $.</p>
<p>$2024 = 2 ^3 <span class="math inline">\(,使用反证法,不妨设其可以被表示为\)</span>a ^2 + b
^2 $.</p>
<p>讨论一下:如果$a , b <span class="math inline">\(均为奇数,那么\)</span>a ^2 + b ^2 $,不符题意.</p>
<p>于是$a , b <span class="math inline">\(应该均为偶数,那么就有\)</span>a ’ ^2 + b ’ ^2 =
506 $.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于集合$G <span class="math inline">\(,\)</span>e G <span class="math inline">\(,定义域为\)</span>G <span class="math inline">\(的函数\)</span>f $满足以下性质:</p>
<ol type="1">
<li><p>$e G <span class="math inline">\(,但\)</span>e <span class="math inline">\(不在\)</span>f $的值域中.</p></li>
<li><p>$G <span class="math inline">\(关于\)</span>f $封闭.</p></li>
<li><p>若$A G <span class="math inline">\(,\)</span>e A <span class="math inline">\(且\)</span>A <span class="math inline">\(对\)</span>f <span class="math inline">\(封闭,则\)</span>A = G $.</p></li>
</ol>
<p>在$G <span class="math inline">\(上定义二元运算\)</span><span class="math inline">\(,满足\)</span>ae = a , af ( b ) = f ( ab ) $.</p>
<p>求证:</p>
<ol type="1">
<li><p>存在幺元.</p></li>
<li><p>运算满足交换律.</p></li>
<li><p>运算满足结合律.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往$A <span class="math inline">\(里面扔个\)</span>e <span class="math inline">\(,此时\)</span>A <span class="math inline">\(一定不满足条件.我们不断从\)</span>A <span class="math inline">\(中选出一个元素\)</span>w <span class="math inline">\(满足\)</span>f ( w ) A <span class="math inline">\(,并把\)</span>A : = A { f ( w ) } <span class="math inline">\(.不断做这个过程显然最后会得到\)</span>G <span class="math inline">\(,这意味着任何一个元素\)</span>a <span class="math inline">\(可以写成\)</span>f ( f ( f f ( e ) ) )
$的形式.</p>
<p>不妨将$f <span class="math inline">\(函数嵌套\)</span>k <span class="math inline">\(次记作\)</span>f ^{ ( k ) } <span class="math inline">\(,那么我们要证明的是\)</span>a = f ^{ ( A ) } ( e )
, b = f ^{ ( B ) } ( e ) <span class="math inline">\(,\)</span>ab = ba
$.</p>
<p>考虑$ab = f ^{ ( A ) } ( e ) f ^{ ( B ) } ( e ) = f ^{ ( B ) } ( f ^{
( A ) } ( e ) e ) = f ^{ ( A + B ) } ( e ) $,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给出一个具体函数满足:</p>
<ol type="1">
<li><p>$f ( x + y ) = f ( x ) + f ( y ) + xy $.</p></li>
<li><p>$f ( xy ) = f ( x ) f ( y ) + f ( x - 1 ) f ( y - 1 ) $.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>先注意到$f ( 0 ) = 0 , f ( 1 ) = 1 $.</p>
<p>以$x <span class="math inline">\(为主元两边求导,立刻得到\)</span>f ’
( x + y ) = f ’ ( x ) + y <span class="math inline">\(,因此\)</span>f ’
( x ) $是斜率为$1 <span class="math inline">\(的一次函数,立刻得到\)</span>f ( x ) = { 2 } + { 2
} $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于$r = <span class="math inline">\(,是否存在正整数\)</span>p <span class="math inline">\(和整数\)</span>q <span class="math inline">\(满足\)</span>| pr - q | &lt; { 2024 } <span class="math inline">\(且\)</span>p &lt; 2024 $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑取$0 , , 2 , 3 , <span class="math inline">\(的小数部分,记作\)</span>a _0 , a <em>1 , a </em>{
2023 } $.</p>
<p>由鸽笼原理,一定存在两个数$0 x &lt; y <span class="math inline">\(满足\)</span>| a _x - a _y | &lt; { 2024 }
$,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>在一个数轴上,你站在$0 <span class="math inline">\(点,并按照如下算法寻找\)</span>x ( x &gt; 0 )
$点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. $3 x $ B. $5 x $ C. $7 x $ D. $9 x $ E. 以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>考虑找到牛的时候$step $为多少,应该为$2 ^{ 2 k } <span class="math inline">\(,其中\)</span>k $满足$2 ^{ 2 k } x &gt; 2 ^{ 2 ( k
- 1 ) } <span class="math inline">\(.此时走的步数应该是\)</span>ans = 2
_{ i = 0 } ^{ 2 k - 1 } 2 ^i + x = 2 ^{ 2 k + 1 } - 1 + x <span class="math inline">\(步.而\)</span>x ^{ 2 k } &lt; 4 x <span class="math inline">\(,所以\)</span>ans &lt; 9 x - 1 $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定$10 <span class="math inline">\(个实数变量\)</span>x <em>1 , , x
</em>{ 10 } <span class="math inline">\(,满足它们均\)</span> <span class="math inline">\(且两两不同.你要寻找一组\)</span>{ x } <span class="math inline">\(和一个实数\)</span>a <span class="math inline">\(,使得存在尽可能多组\)</span>b , b <em>i = <span class="math inline">\(,满足\)</span></em>{ i = 1 } ^{ 10 } b _i x _i ( a
, a + 2 ) $.</p>
<p>最多存在多少组$b $?</p>
<p>A. $512 $ B. $252 $ C. $504 $ D. $684 $ E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>不妨猜测$x $全取$1 <span class="math inline">\(最优,此时的答案是\)</span> { 5 } = 252 $.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于$x <span class="math inline">\(,所以如果存在两组\)</span>b <span class="math inline">\(,使得\)</span>A <span class="math inline">\(组中选择取\)</span>+ 1 <span class="math inline">\(恰好是\)</span>B <span class="math inline">\(组的子集,那么\)</span>S _A S _B - 2
$,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让$x $尽可能接近$1
$,这样就是满足条件的.所以问题变为对于一个大小为$10 <span class="math inline">\(的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取\)</span>
{ 5 } $最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给定无向图$G = ( V , E ) $,我们称一个图是好的,如果:</p>
<ol type="1">
<li><p>每个点的度数均为$d $.</p></li>
<li><p>任何一个大小不超过$ { 2 } <span class="math inline">\(的联通集合\)</span>S <span class="math inline">\(,其邻居(不属于\)</span>S <span class="math inline">\(但和\)</span>S <span class="math inline">\(中的某个点存在直接相连的边)的大小\)</span> { 4 } |
S | $.</p></li>
</ol>
<p>求证:好的图中任意两个点$u , v <span class="math inline">\(之间的最短路径长度\)</span>dis ( u , v ) = O ( | V
| ) $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑以$u <span class="math inline">\(为起点一点一点往外扩张,这样一直扩张到\)</span> { 2
} + 1 <span class="math inline">\(时,集合中每个点到\)</span>u <span class="math inline">\(的距离不超过\)</span>O ( | V | ) $.</p>
<p>然后以$v <span class="math inline">\(做同样的事,由于这两个集合大小之和大于\)</span>| V
| <span class="math inline">\(,说明一定有交,且存在一条路径长度为\)</span>O ( | V
| ) $的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你两个完全相同的鸡蛋和一个$n = 100
$层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有$101
$个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设$f <em>{ i , 1 / 2 } <span class="math inline">\(表示一棵有\)</span>i $个叶子的树,最多向右走$1 / 2
<span class="math inline">\(步,深度最低为多少.显然\)</span>f </em>{ i ,
1 } = i - 1 $.</p>
<p>不妨设最后的最大深度为$k $,需要满足$1 + <em>{ i = 1 } ^k i = 1 + { 2
} , k ( k + 1 ) <span class="math inline">\(,\)</span>k </em>{ } = 14
$.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>$n <span class="math inline">\(个人要进行一场游戏.游戏设计者准备了\)</span>n
<span class="math inline">\(张卡片,正面分别写着\)</span>n <span class="math inline">\(个人的名字,背面写了\)</span>[ 1 , n ] <span class="math inline">\(共\)</span>n
$个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,$n <span class="math inline">\(个人可以经过充分的讨论,并依次进入房间,一张一张地翻开\)</span>
{ 2 }
$张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有$n
$个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过$0
. 1 $的胜率.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是$a
<span class="math inline">\(,如果\)</span>a <span class="math inline">\(就是自己的编号就下班;反之接下来翻开\)</span>a
<span class="math inline">\(位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于\)</span>
{ 2 } $的环.</p>
<p>考虑总方案数是$n ! <span class="math inline">\(.不妨枚举这个环的长度为\)</span>K <span class="math inline">\(,则存在一个长度\)</span>= K &gt; { 2 } <span class="math inline">\(的环的方案数是\)</span> { K } ( K - 1 ) ! ( n - K
) ! = { K } <span class="math inline">\(.所以此时的概率为\)</span> { K }
$.</p>
<p>那么失败的概率就是$H <em>n - H </em>{ { 2 } } $.</p>
<h3><span id="2022茶选">2022茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化$z = 5 x _1 + 8 x _2 + 4 x _3 $,其中:</p>
<ol type="1">
<li><p>$x _1 , x _2 , x _3 $</p></li>
<li><p>$ { 2 } x _1 + 5 x _2 + 9 x _3 $</p></li>
<li><p>$4 x _1 + 7 x _2 + 3 x _3 $</p></li>
</ol>
<p>再提一个问题:最小化$v = 3 y _1 + 6 y _2 $,其中:</p>
<ol type="1">
<li><p>$y _1 , y _2 $</p></li>
<li><p>$ { 2 } y _1 + 4 y _2 $</p></li>
<li><p>$5 y _1 + 7 y _2 $</p></li>
<li><p>$9 y _1 + 3 y _2 $</p></li>
</ol>
<p>现在请你证明:$z v $.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>下面乘一下配一下上面的系数,自然得证.</p>
写成矩阵形式,设$X =
<span class="math display">\[\begin{bmatrix}x _1 &amp; x _2 &amp; x _3
\end{bmatrix}\]</span>
, A =
<span class="math display">\[\begin{bmatrix}0 . 5 &amp; 4 \\ 5 &amp; 7
\\ 9 &amp; 3 \end{bmatrix}\]</span>
, Y =
<span class="math display">\[\begin{bmatrix}y _1 \\ y _2
\end{bmatrix}\]</span>
<p><span class="math inline">\(,不难发现\)</span>z XAY v $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>半径为$R $的球里放点,要求两两之间距离不能小于$1 <span class="math inline">\(,证明至多放\)</span>( 2 R + 1 ) ^3 $个.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>要求两两距离不能小于$1 $等价于往其中放半径为$0 . 5 <span class="math inline">\(的球,这种球体积为\)</span> { 3 } { 8 } <span class="math inline">\(.然后原球要扩大一圈,所以原球体积变为\)</span> { 3
} ( R + 0 . 5 ) ^3 $.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数$n $.</p>
<p>它每秒以$v <span class="math inline">\(的速度行驶,其中\)</span>v
$是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数$x <span class="math inline">\(,你会得知此时车的坐标是否是\)</span>x $(Yes or
No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>第$t <span class="math inline">\(秒的时候车应该在\)</span>n + vt
<span class="math inline">\(处.由于我们知道现在是第几秒,枚举\)</span>n ,
v <span class="math inline">\(然后不断check即可.这个是经典的证明\)</span> ^2
<span class="math inline">\(和\)</span> <span class="math inline">\(等势.按照\)</span>| n | + | v |
$排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对满足$i , | i - p _i | $的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>简单题,设$f _n <span class="math inline">\(为答案,考虑\)</span>p _n
$取什么.</p>
<p>当$p <em>n = n <span class="math inline">\(时,方案数为\)</span>f
</em>{ n - 1 } $.</p>
<p>当$p <em>n = n - 1 <span class="math inline">\(时,\)</span>p </em>{ n
- 1 } = n <span class="math inline">\(,方案数为\)</span>f _{ n - 2 }
$.</p>
<p>于是,$f _1 = 1 , f <em>2 = 2 <span class="math inline">\(,\)</span>f
<em>n = f </em>{ n - 1 } + f </em>{ n - 2 } $.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>你有一个$n n $的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择$k
$个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数$k <span class="math inline">\(最小值是\)</span>n $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是$ { 4 } = n
$个.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>设$F = { S _1 , S <em>2 , S <em>3 , . . . , S </em>{ | F | } } <span class="math inline">\(,定义一个集合\)</span>T <span class="math inline">\(能被\)</span>F $ shattered为:$T <span class="math inline">\(的任意一个子集(包括它自己和空集),都可以由\)</span>T
S </em>{ i <em>1 } S </em>{ i <em>2 } . . . <span class="math inline">\(表示.其中\)</span>S </em>{ i _j } <span class="math inline">\(是\)</span>F <span class="math inline">\(中的集合(就是说每个子集都等于\)</span>T <span class="math inline">\(和某些\)</span>F $内集合的交.)</p>
<p>定义一个$F <span class="math inline">\(的&quot;VC-Dimension&quot;是,能被他shattered的集合\)</span>T
$的大小的最大值.</p>
<p>$F <span class="math inline">\(中的集合们只会包含某\)</span>n
$种不同的元素.证明:</p>
<ol type="1">
<li><p>任意一个$F <span class="math inline">\(能shattered的\)</span>T
<span class="math inline">\(至少有\)</span>| F | $个.</p></li>
<li><p>对于一个VC-Dimension的大小为$k <span class="math inline">\(的\)</span>F <span class="math inline">\(,其\)</span>| F | _{ i = 0 } ^k { i } $.</p></li>
</ol>
<h5><span id="solution6">Solution6</span></h5>
<p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的$S <span class="math inline">\(,满足\)</span>S , S { x } F <span class="math inline">\(,然后将这些\)</span>S { x } <span class="math inline">\(拎出来,假设有\)</span>t <span class="math inline">\(个,左边删去\)</span>x <span class="math inline">\(后再进行数学归纳得到\)</span>| F | - t <span class="math inline">\(个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有\)</span>t
<span class="math inline">\(个集合,在这\)</span>t <span class="math inline">\(个集合添上\)</span>x $这个元素即可.</p>
<p>$t = 0 <span class="math inline">\(怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为\)</span>S
<span class="math inline">\((选取最大的那个集合为新加入的),我们在前面的集合中找到一个与\)</span>S
<span class="math inline">\(有交的集合\)</span>T <span class="math inline">\(,根据上面的预处理,此集合显然存在.选出一个\)</span>x
S T <span class="math inline">\(,不妨设\)</span>S = S ’ { x } <span class="math inline">\(,令\)</span>T ’ = S ’ T <span class="math inline">\(,然后用\)</span>T ’ <span class="math inline">\(代替原本的\)</span>T $即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>令$p ( x ) <span class="math inline">\(表示\)</span>x <span class="math inline">\(的最大质因子,求所有\)</span>( x , y , z )
$使得:</p>
<ol type="1">
<li><p>$x &lt; y &lt; z <span class="math inline">\(且\)</span>x + z = 2
y $.</p></li>
<li><p>$p ( xyz ) $.</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>不妨令$g = ( x , y , z ) <span class="math inline">\(,令\)</span>x ’
= { g } <span class="math inline">\(,则只需要解:\)</span>x ’ + z ’ = 2 y
’ $.</p>
<p>我们有$y - x = z - y <span class="math inline">\(,则\)</span>( y ’ ,
x ’ ) = ( y ’ , y ’ - x ’ ) = ( y ’ , z ’ ) = 1
$,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol type="1">
<li><p>$2 x ’ , 2 z ’ $.</p></li>
<li><p>$2 x ’ , 2 z ’ , 2 y ’ $.</p></li>
</ol>
<p>先看(1),设$x ’ = 3 ^a , z ’ = 3 ^c , y ’ = 2 ^b $.方程变为$3 ^a ( 1 +
3 ^{ c - a } ) = 2 ^{ b + 1 } <span class="math inline">\(,一定有\)</span>a = 0 $,只需解$1 + 3 ^{ c } = 2 ^{
b + 1 } $.</p>
当$b <span class="math inline">\(的时候,经检验有\)</span>
<span class="math display">\[\begin{cases}c = 0 \\ b = 0
\end{cases}\]</span>
<span class="math inline">\((舍)和\)</span>
<span class="math display">\[\begin{cases}c = 1 \\ b = 1
\end{cases}\]</span>
<p>$两组解.</p>
<p>当$b $的时候,注意到$3 ^{ c } - 1 <span class="math inline">\(,所以\)</span>c $是偶数.又注意到$3 ^{ c } - 1
<span class="math inline">\(,但是奇数的平方\)</span> $应该是$1
$,不符.</p>
<p>再看(2),设$x ’ = 2 ^d , z ’ = 2 ^e , y ’ = 3 ^b $.</p>
<p>当$e = 1 $时,显然不符.</p>
当$d = 1 , e &gt; 1 $时,要解$2 ^{ e - 1 } + 1 = 3 ^{ b } <span class="math inline">\(.当\)</span>e = 2 <span class="math inline">\(的时候有一组解\)</span>
<span class="math display">\[\begin{cases}e = 2 \\ b = 1
\end{cases}\]</span>
<p><span class="math inline">\(.当\)</span>e $的时候,有$3 ^b <span class="math inline">\(,说明\)</span>b $是偶数.</p>
那必然有$2 ^{ e - 1 } = 3 ^b - 1 = ( 3 ^{ { 2 } } + 1 ) ( 3 ^{ { 2 } } -
1 ) <span class="math inline">\(.令\)</span>t = 3 ^{ { 2 } } - 1 $,则$2
^{ e - 1 } = t ( t + 2 ) <span class="math inline">\(.则要么\)</span>t =
2 <span class="math inline">\(,要么\)</span>t + 2 = 2 <span class="math inline">\(.解出\)</span>b - 2 <span class="math inline">\(,此时有\)</span>
<span class="math display">\[\begin{cases}e = 4 \\ b = 2
\end{cases}\]</span>
<p>$.</p>
综上,解出来的解有$
<span class="math display">\[\begin{cases}x &#39; = 2 \\ y &#39; = 3 \\
z &#39; = 4 \end{cases}\]</span>
,
<span class="math display">\[\begin{cases}x &#39; = 1 \\ y &#39; = 2 \\
z &#39; = 3 \end{cases}\]</span>
,
<span class="math display">\[\begin{cases}x &#39; = 2 \\ y &#39; = 9 \\
z &#39; = 16 \end{cases}\]</span>
<p>$.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程$2 ^x + 1 = 3 ^y <span class="math inline">\(,考虑两边\)</span> <span class="math inline">\(知道\)</span>x <span class="math inline">\(是奇数,于是\)</span>v _3 ( 2 ^x + 1 ) = v _3 ( 3 )
+ v _3 ( x ) = y , 3 ^{ y - 1 } | x , x ^{ y - 1 }
$,用这个放缩一下就行.</p>
<p>再看方程$2 ^x = 3 ^y + 1 <span class="math inline">\(.仍然考虑两边\)</span> <span class="math inline">\(,知道\)</span>y <span class="math inline">\(是奇数.\)</span>x = v _2 ( 3 ^y + 1 ) = v _2 ( 3 +
1 ) = 2 $,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定两个随机分布：</p>
<p>$x ∼ D _1 <span class="math inline">\(:从\)</span>{ 0 , 1 , … , p − 1
} <span class="math inline">\(中等概率随机一个\)</span>y <span class="math inline">\(,令\)</span>x = y     { 2 ^k } $.</p>
<p>$x ∼ D _1 <span class="math inline">\(:从\)</span>{ 0 , 1 , … , 2 ^k
- 1 } <span class="math inline">\(中等概率随机一个\)</span>y <span class="math inline">\(,令\)</span>x = y   $.</p>
<p>定义二者的统计距离为:$SD ( D <em>1 , D <em>2 ) = { 2 } </em>{ i = 0 }
^{ 2 ^k - 1 } | P </em>{ D <em>1 } ( x = i ) - P </em>{ D _2 } ( x = i )
| $.</p>
<p>求证:$SD ( D _1 , D _2 ) ≤ { 4 p } $.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>令$w = p <span class="math inline">\(.则\)</span>SD ( D _1 , D <em>2
) = { 2 } ( P </em>{ D <em>1 } ( x = 0 ) - P </em>{ D <em>2 } ( x = 0 )
) + { 2 } ( P </em>{ D <em>2 } ( x = w ) - P </em>{ D _1 } ( x = w ) )
$.</p>
<p>令$k = { 2 ^k } = { 2 ^k } <span class="math inline">\(不难发现\)</span>P _{ D <em>1 } ( x = 0 ) = { p }
, P </em>{ D _1 } ( x = w ) = { p } $.</p>
<p>则$SD ( D _1 , D _2 ) = { 2 } ( { p 2 ^k } - { 2 ^k } ) + { 2 } ( { 2
^k } - { p 2 ^k } ) = { 2 ^{ k + 1 } } ( { p } + { p } ) = { p 2 ^k }
$.</p>
<p>要证明$ { p 2 ^k } { 4 p } w ( 2 ^k - w ) ( 2 ^{ k - 1 } ) ^2
$.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给你一个单增函数$f <span class="math inline">\(,满足定义域和值域都是\)</span> <span class="math inline">\(,并且\)</span>f ( f ( n ) ) = 3 n <span class="math inline">\(,求\)</span>f ( 2023 ) $.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>首先我们不妨先试一下$f ( f ( 1 ) ) = 3 <span class="math inline">\(.由于\)</span>f ( 1 ) <span class="math inline">\(,且\)</span>f ( 1 ) <span class="math inline">\(,所以\)</span>f ( 1 ) = 2 , f ( 2 ) = 3 $.</p>
<p>考虑$f ( 3 n ) <span class="math inline">\(,必然存在一个\)</span>n
&lt; m &lt; 3 n <span class="math inline">\(,使得\)</span>f ( n ) = m ,
f ( m ) = 3 n $.</p>
<p>用这个找前几项,发现规律是把$n $写成三进制形式,如果首位是$1 $就变成$2
$,首位是$2 $就改为$1 $再在后面加个$0 <span class="math inline">\(.容易验证这是合法的\)</span>f <span class="math inline">\(且\)</span>f ( 2023 ) = 3882 $.</p>
<p>但问题没有解决,需要证明它是唯一的$f $.</p>
<p>考虑数学归纳假设现在$f ( x ) , x $都确定了.</p>
<p>注意到如果$f ( n ) = m , f ( m ) = 3 n , f ( 3 n ) = 3 m , f ( 3 m )
= 9 n <span class="math inline">\(.所以如果\)</span>f ( n ) = m <span class="math inline">\(,我们实际上有\)</span>f ( 3 ^k m ) = 3 ^{ k + 1 }
n , f ( 3 ^k n ) = 3 ^k m <span class="math inline">\(.数学归纳即可以证明\)</span>f ( 3 k + 3 )
$一定是确定的.</p>
<p>接下来要证明$f ( 3 k + 1 ) <span class="math inline">\(和\)</span>f (
3 k + 2 ) $一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol type="1">
<li><p>$f ( 3 k ) + 3 = f ( 3 k + 3 ) $.</p></li>
<li><p>$n , f ( n ) = 3 k + w ( w { 1 , 2 } ) $.</p></li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当$k $在三进制下首位如果是$2 $,则一定满足(2).</p>
<p>当$k $在三进制下首位是$1 $,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对于一个$n n <span class="math inline">\(的包含\)</span>[ 1 , n ^2 ]
$各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol type="1">
<li><p>如果一个排列矩阵满足每行恰有模$n <span class="math inline">\(余\)</span>[ 0 , n - 1 ] <span class="math inline">\(的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第\)</span>i
<span class="math inline">\(行第\)</span>j <span class="math inline">\(列为\)</span>( i - 1 ) n + j
$的矩阵(不妨称为有序矩阵).</p></li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列$n <span class="math inline">\(不相同,可以先将每行按照\)</span>n
$排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将$n <span class="math inline">\(不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是\)</span>n
$正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>有$n ( ) <span class="math inline">\(个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称\)</span>n
$是好的.求证:</p>
<ol type="1">
<li><p>$4 $是好的.</p></li>
<li><p>如果$n <span class="math inline">\(是奇数,那么\)</span>n
$不是好的.</p></li>
<li><p>求出所有好的$n $.</p></li>
</ol>
<h5><span id="solution5">Solution5</span></h5>
<p>首先可以证明$2 $是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要$2
^n $步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样$0 $和$1 $就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到$1100 $来一个$1010 $之后啥也不变,但是$1010 $来一个$1010
$一定赢了.所以上来先来一个$1010 $,如果赢了就下班,没赢就来个$1100
$,这样$1100 $要么下班,要么变成了$1010 $,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:$0000 , 1111 , 1010 , 1111 , 1100 , 1111 ,
1010 , 1111 , 1000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111
$.</p>
<p>上面的构造启发我们手玩一下$n = 3 $,注意到此时的问题在于$100 $和$110
$,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全$0
$;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全$0
$.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全$0
<span class="math inline">\(的成功状态.我们不妨令一个成功状态的度为\)</span>d
<span class="math inline">\(表示它可以经过\)</span>d $步到达全$0
$,显然全$1 <span class="math inline">\(的\)</span>d = 1 <span class="math inline">\(,\)</span>n = 4 $的时候,$1010 <span class="math inline">\(的\)</span>d = 2
$,因为其可以通过一次操作转化为全$1 $,$1100 <span class="math inline">\(的\)</span>d = 3 $,因为其可以用一次操作转化为$1010
$.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向$d
$比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然$n = 3 <span class="math inline">\(的时候,\)</span>{ 110 , 100 }
$就是失败状态.</p>
<p>而对于$n <span class="math inline">\(取任意来说,一定得存在一个\)</span>d = 2 <span class="math inline">\(的成功状态.一个显然的\)</span>d = 2 <span class="math inline">\(的成功状态要满足的条件是,假设它是\)</span>a <span class="math inline">\(,那么存在一个数\)</span>b <span class="math inline">\(,使得\)</span>a b $是全$1 $或者全$0 <span class="math inline">\(.既然\)</span>a <span class="math inline">\(和\)</span>b <span class="math inline">\(旋转后只有两种结果,那么\)</span>b
$的循环节必定为$2 <span class="math inline">\(,也就是\)</span>b
$一定要是$101 <span class="math inline">\(这样的,于是\)</span>n
$是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找$d = 3 $的成功状态,现在我们已知的四种成功状态是$111 $,$000
$,$101 $,$010 $,所以考虑构造一个循环节长度为$4
$的串,使得异或完它是这上面四种其一,注意到$1100 $就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明$n = 2 ^k $一定是好的.考虑数学归纳,不妨这么干:构造一个长度为$2
^{ k - 1 } <span class="math inline">\(的串\)</span>b <span class="math inline">\(,使得其\)</span>b _i = a <em>i a </em>{ i + 2 ^{ k
- 1 } } <span class="math inline">\(.然后由数学归纳,可以造出\)</span>b
$全$0 <span class="math inline">\(的情况.而如果\)</span>b $全$0
$,则原串一定存在长为$2 ^{ k - 1 } <span class="math inline">\(的循环节,并且消除循环节的过程不会改变\)</span>b
$的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设$n = 2 ^k m $,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造$b <span class="math inline">\(数组,由于\)</span>b $数组都不可能全$0
$,显然也不可能成立.</p>
<p>这个能不能顺便证明$n $是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了$n - 1
$个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前$n - 1
$个位置的异或值为$1 $.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为$50
% $,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5>
简单题,设$f _0 , f _1 , f _2 , f _3 <span class="math inline">\(,然后有\)</span>
<span class="math display">\[\begin{cases}f _3 = 0 \\ f _2 = \frac {
1  } { 2  } f _3 + \frac { 1  } { 2  } f _0 + 1 \\ f _1 = \frac { 1  } {
2  } f _2 + \frac { 1  } { 2  } f _0 + 1 \\ f _0 = \frac { 1  } { 2  } f
_1 + \frac { 1  } { 2  } f _0 + 1 \end{cases}\]</span>
<p><span class="math inline">\(,算出\)</span>f _0 = 14 $.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<p><span class="math display">\[
x ^3 + □ x ^2 + □ x + □ = 0
\]</span></p>
<h5><span id="solution2">Solution2</span></h5>
<p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为$- A , - B , - C <span class="math inline">\(,方程应该可以写作\)</span>( x + A ) ( x + B ) ( x
+ C ) = 0 $.</p>
<p>拆开有$x ^3 + ( A + B + C ) x ^2 + ( AB + AC + BC ) x + ABC = 0
$.</p>
<p>这么对称,不妨猜一手Alice先选择$0 $,讨论一下:</p>
<ol type="1">
<li>Bob令$ABC = 0 <span class="math inline">\(.不妨令\)</span>C = 0
$.</li>
</ol>
<p>此时方程变为$x ^2 + ( A + B ) x + AB = 0
$.直接秒了,随便选一个数就行(比如选$3 <span class="math inline">\(,如果Bob令\)</span>AB = 3 $,就再选$4 <span class="math inline">\(;如果令\)</span>A + B = 3 $,就再选$2 $)</p>
<ol start="2" type="1">
<li>Bob令$A + B + C = 0 , C = - A - B $.</li>
</ol>
<p>不妨令$C ’ = - C , D = AB <span class="math inline">\(,则\)</span>AB
+ AC + BC = D - C ’ ^2 , ABC = DC ’ $.</p>
<p>接下来Alice要选择一个数字$k <span class="math inline">\(,如果Bob又令\)</span>D - C ’ ^2 = k <span class="math inline">\(,发现在此时如果\)</span>k
$是一个负的完全平方数,并且Alice接下来选择$0 $,当场就下班了.</p>
<p>所以不妨直接让$k = - n ^2 <span class="math inline">\(,然后看当\)</span>DC ’ = - n ^2 <span class="math inline">\(的时候如何去解.此时有\)</span>AB ( A + B ) = n ^2
$.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择$- 3 ^2 ^2 ^2 $,这样就赢了.</p>
<ol start="3" type="1">
<li>Bob令$AB + AC + BC = 0 , C = - { A + B } $.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择$6 ^2 ^3
$,两种情况如下:</p>
<p><span class="math display">\[
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) &amp; = 0 \\
( x - 2 \times 6 ^2 \times 7 ^2 ) ( x + 3 \times 6 ^2 \times 7 ^2 ) ( x
+ 6 \times 6 ^2 \times 7 ^2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>后来又找人讨论了一下这个是咋得出来的啊.考虑$ABC <span class="math inline">\(,我们有的条件其实是\)</span> { A } + { B } + { C }
= 0 <span class="math inline">\(.方程现在是\)</span>x ^3 + ( A + B - { A
+ B } ) x ^2 - { A + B } = 0 <span class="math inline">\(.不妨令\)</span>a = A + B , b = AB <span class="math inline">\(,方程实际上是\)</span>x ^3 + ( a - { a } ) x ^2 -
{ a } = 0 <span class="math inline">\(.最好能让\)</span>a <span class="math inline">\(小一点,因此我们不妨直接取\)</span>a = 1 <span class="math inline">\(,此时\)</span>A = - n , B = n + 1 , C = n ( n + 1
) <span class="math inline">\(,只要能构造这样的两组\)</span>A , B , C
<span class="math inline">\(使得它们的\)</span>a _1 - { a _1 } = - { a
_2 } <span class="math inline">\(即可.直接造看上去没啥前途,但是不难发现\)</span>A =
- nk , B = ( n + 1 ) k , C = n ( n + 1 ) k <span class="math inline">\(依然合法.此时有\)</span>k _1 = a _1 , b _1 = - n (
n + 1 ) a _1 ^2 , k _2 = a _2 , b _2 = - n ( n + 1 ) a _2 ^2 <span class="math inline">\(,我们有\)</span>a _1 ( n ^2 + n + 1 ) = - n ^2 ( n
+ 1 ) ^2 a _2 ^3 <span class="math inline">\(.取\)</span>n = 2
$试试看!此时有$7 a _1 = - 36 a _2 ^3 <span class="math inline">\(.取\)</span>a _2 = 7 , a _1 = - 6 ^2 ^2
$,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外$3
$个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌$1
$个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>有公式:</p>
<p><span class="math display">\[
\sum _{ S \subseteq \{ 1 , 2 , \cdots , n \}  } ( P ( f ( R ) \oplus
\bigoplus _{ i \in S  } R _i = 0 ) - P ( f ( R ) \oplus \bigoplus _{ i
\in S  } R _i = 1 ) ) ^2 = 1
\]</span></p>
<p>其中$f <span class="math inline">\(是任意一个将\)</span>{ 0 , 1 } ^n
{ 0 , 1 } <span class="math inline">\(的函数,\)</span><span class="math inline">\(是二进制意义下的异或运算,\)</span>R <span class="math inline">\(是\)</span>{ 0 , 1 } ^n <span class="math inline">\(上的均匀分布,\)</span>R _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(位.再定义\)</span><em>S ( r ) = </em>{ i S } ( - 1
) ^{ r _i } $.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol type="1">
<li><p>$_S ( r ) _S ( r ’ ) = _S ( r r ’ ) $.</p></li>
<li><p>当$r <span class="math inline">\(时,\)</span>_{ S { 1 , , n } }
_S ( r ) = 0 $.</p></li>
<li><p>$[ f ( r ) _{ i S } r _i = 0 ] - [ f ( r ) _{ i S } r _i = 1 ] =
( - 1 ) ^{ f ( r ) } _S ( r ) $.</p></li>
<li><p>证明原命题.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>(1)显然.</p>
<p>(2)也很经典,挑选一个$j <span class="math inline">\(,使得\)</span>r _j
= 1 <span class="math inline">\(,然后所有的集合分为两类:一类是包含\)</span>j <span class="math inline">\(,一类不包含,两类集合一一对应并且\)</span>$互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到$P ( f ( R ) <em>{ i S } R <em>i = 0 ) = { 2 ^n }
</em>{ r } [ f ( r ) _{ i S } r _i = 0 ] <span class="math inline">\(,而\)</span></em>{ r } [ f ( r ) _{ i S } r _i = 0
] - [ f ( r ) _{ i S } r _i = 1 ] = _r ( - 1 ) ^{ f ( r ) } <em>S ( r )
<span class="math inline">\(,要证明的只是\)</span></em>{ S } { 4 ^n } (
_r ( - 1 ) ^{ f ( r ) } _S ( r ) ) ^2 = 1 $,而:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ S  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 \\
&amp; = \sum _S \sum _{ r  } \sum _{ r &#39;  } ( - 1 ) ^{ f ( r ) + f (
r &#39; )  } \chi _S ( r \oplus r &#39; ) \\
&amp; = \sum _{ r  } \sum _{ r &#39;  } ( - 1 ) ^{ f ( r ) + f ( r &#39;
)  } \sum _S \chi _S ( r \oplus r &#39; ) \\
&amp; = \sum _{ r  } 2 ^n &amp; = 4 ^n
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于$50
% $.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数$x <span class="math inline">\(,然后随机一只手,看上面的数字\)</span>a <span class="math inline">\(,如果\)</span>a x <span class="math inline">\(就认为\)</span>a <span class="math inline">\(大,反之认为\)</span>b
$大.只要随机到一个区间内的实数的概率不为$0 $即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5>
<p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令$p <span class="math inline">\(为素数,把整个图形放大\)</span>p $倍(也就是长度$1
<span class="math inline">\(变成长度\)</span>p <span class="math inline">\().下面把每个交叉点\)</span>( x , y ) <span class="math inline">\(换成其整数部分\)</span>( x , y ) <span class="math inline">\(,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被\)</span>p
<span class="math inline">\(整除.这样这个新的大矩形的面积也能被\)</span>p
<span class="math inline">\(整除,所以它的有一边长能被\)</span>p
$整除.这条边只是被换成了它长度的整数部分,所以变化不超过$1
$,所以在放大之前这条边的长度和某个整数相差不超过$1 / p
$.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有$2
$条边或者$4
$条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点$(
x , y ) <span class="math inline">\(染色:如果\)</span>x <span class="math inline">\(是整数,染X颜色.如果\)</span>x <span class="math inline">\(不是整数但\)</span>y
$是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为$[ 0 , a ] <span class="math inline">\(,并假设\)</span>b <span class="math inline">\(不是整数.把所有小矩形的下边界去掉,然后令\)</span>f
( t ) <span class="math inline">\(为所有上边界\)</span>y <span class="math inline">\(坐标不是整数,并且与直线\)</span>y = t <span class="math inline">\(相交的小矩形的\)</span>x <span class="math inline">\(方向边长之和.那么\)</span>f ( 0 ) = 0 <span class="math inline">\(,而且当\)</span>f ( t ) <span class="math inline">\(变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以\)</span>f
( b ) <span class="math inline">\(是整数.而因为\)</span>b <span class="math inline">\(不是整数,\)</span>f ( b ) <span class="math inline">\(就是最靠上的所有小矩形的宽之和,等于\)</span>a
<span class="math inline">\(,所以\)</span>a $是整数.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2>
<h3><span id="分析状态">分析状态</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个$[ 1 ,
m ] $中的数字,然后进行以下判断:</p>
<ol type="1">
<li><p>如果当前序列末尾两个数字相同且小于$t <span class="math inline">\(,假设都是\)</span>x <span class="math inline">\(,那就将它们都删去,加入一个\)</span>x + 1
$.</p></li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为$n
$,终止操作.</p></li>
</ol>
<p>给定$n , m , t $,求最终序列的元素和的期望.</p>
<p>$n , m ^3 , t ^9 $.</p>
<p>首先$t ^9 <span class="math inline">\(显然是没用的,因为它最多也就能这么凑:\)</span>m + n
- 2 , m + n - 3 , , m , m <span class="math inline">\(,合成一个\)</span>m + n - 1 <span class="math inline">\(,因此我们令\)</span>t = { t , m + n - 1 }
$即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置$i <span class="math inline">\(,有\)</span>a <em>i &lt; a </em>{ i + 1 } <span class="math inline">\(,那么无论后面怎么做,这里的\)</span>a <em>i <span class="math inline">\(都必不可能被删除.以此,我们不妨设\)</span>f </em>{
i , j } <span class="math inline">\(表示序列长度为\)</span>i <span class="math inline">\(,序列开头元素为\)</span>j
$的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过$t <span class="math inline">\(,另一个是序列的长度不能超过\)</span>n <span class="math inline">\(.我们不妨设\)</span>ans _{ n , t } <span class="math inline">\(表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移\)</span>ans
$需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下$ans <em>{ n , t } <span class="math inline">\(,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有\)</span>ans
</em>{ n , t } = _{ x = 1 } ^t E ( n 个 位 置 , 第 一 个 位 置 是 x 并
且 没 有 被 删 去 ) $.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:$3 , 3 , 3 $,最终的答案应该是$4 , 3 $.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了$3 , [ 3 , 3 ]
$,最终的答案就变成了$3 , 4 <span class="math inline">\(.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设\)</span>g
<em>{ i , j } <span class="math inline">\(表示当前后面还有\)</span>i - 1
<span class="math inline">\(个位置,当前前面已经放好了一个\)</span>j
<span class="math inline">\(,这个\)</span>j <span class="math inline">\(不能被删掉的期望,显然有\)</span>ans </em>{ n , t }
= <em>{ x } ^t g </em>{ n , x } P ( 最 终 序 列 中 , 这 里 是 k ) <span class="math inline">\(,问题只在于如何求\)</span>g <span class="math inline">\(.这个\)</span>g _{ n , k } <span class="math inline">\(是钦定了这个位置放\)</span>k <span class="math inline">\(的期望,后面我们需要将它乘上这个位置放\)</span>k
$的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个$g <em>{ n , k } = ( k + </em>{ j k } g <em>{ n -
1 , j } ) <span class="math inline">\(.但是实际上这个是不对的.这里的\)</span>k <span class="math inline">\(不能删掉不意味着后面的\)</span>j <span class="math inline">\(不能删掉,事实上后面的\)</span>j <span class="math inline">\(爱怎么删怎么删,只要不搞出一个\)</span>k <span class="math inline">\(来就可以.因此我们需要设\)</span>f </em>{ i , j }
<span class="math inline">\(表示当前后面还有\)</span>i <span class="math inline">\(个位置,第一个位置不能是\)</span>j <span class="math inline">\(,也不能曾经是\)</span>j <span class="math inline">\((因为这里只要是\)</span>j <span class="math inline">\(都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设\)</span>f
_{ i , j } <span class="math inline">\(表示后面还有\)</span>i <span class="math inline">\(个位置,第一个位置现在或曾经是过\)</span>j <span class="math inline">\(的期望.那么全集是什么呢?全集是\)</span>ans _i
$.</p>
<p>还没完啊,我们还需要求一下这里是$k <span class="math inline">\(的概率,由于还有一个类似的\)</span>f <span class="math inline">\(,我们还要求一下这里曾经是\)</span>k <span class="math inline">\(的概率.设前者为\)</span>q <em>{ i , k } <span class="math inline">\(,后者为\)</span>p </em>{ i , k } <span class="math inline">\(.我们来强调一下这里设计的原则:这里的\)</span>p
<span class="math inline">\(其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了\)</span>k
<span class="math inline">\(,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过\)</span>k
$了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是$k <span class="math inline">\(等价于这里是\)</span>k <span class="math inline">\(并且后面没有出现过\)</span>k <span class="math inline">\(,也就是\)</span>q <em>{ i , k } = p </em>{ i , k }
( 1 - p _{ i - 1 , k } ) <span class="math inline">\(.这里加一个限制是因为有不能超过\)</span>t
$的限制.</p>
<p>对于后者,这里的$k <span class="math inline">\(有很多种可能出现过,一种是直接加入,一种是合并而来,于是\)</span>p
<em>{ i , k } = { m } [ k m ] + p </em>{ i , k - 1 } p _{ i - 1 , k - 1
} $.</p>
<p>因此我们几经辗转,终于得到了$g $的转移式子:</p>
<p><span class="math display">\[
q _{ i , k  } g _{ n , k  } = p _{ i , k  } ( k + ans _{ i - 1  } - f _{
i - 1 , k  } p _{ i - 1 , k  } )
\]</span></p>
<p>就差$f <span class="math inline">\(了.\)</span>f <span class="math inline">\(有两种可能:要么最后仍然是\)</span>k <span class="math inline">\(,要么这个\)</span>k $已经被杀掉了.于是:</p>
<p><span class="math display">\[
p _{ i , k  } f _{ i , k  } = q _{ i , k  } g _{ i , k  } + ( p _{ i ,
k  } - q _{ i , k  } ) f _{ i , k + 1  }
\]</span></p>
<h5><span id="example2cf1007e">Example2(CF1007E)</span></h5>
<p>首先我们需要发现一个很强的性质:作用到了第$i <span class="math inline">\(个站台就会清空前面所有站台.清空后就和\)</span>a _i
<span class="math inline">\(无关了,而如果还没涉及到一定和\)</span>a _i
$有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设$f <em>{ i , j } <span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(个站台,要撑\)</span>j <span class="math inline">\(个单位时间需要的最少火车数量.\)</span>g </em>{ i ,
j } <span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(个站台,要撑\)</span>j <span class="math inline">\(个单位时间,并且\)</span>[ 1 , i - 1 ] <span class="math inline">\(全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为\)</span>+
<span class="math inline">\(表示无法满足(对于全局,我们在\)</span>n + 1
<span class="math inline">\(处放一个\)</span>a = + , b = 0 , c = + <span class="math inline">\(来保证一定会满载).为什么需要\)</span>g <span class="math inline">\(作为辅助dp数组呢?我们先对着\)</span>f $分析.</p>
<p>考虑$f _{ i , j } $的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前$j <span class="math inline">\(轮中根本没接走站台\)</span>i
<span class="math inline">\(的人.此时需要满足\)</span>f <em>{ i - 1 , j
} + a <em>i + j b <em>i c <em>i <span class="math inline">\(.那么这里怎么更新\)</span>g <span class="math inline">\(呢?设\)</span>L = sa </em>{ i - 1 } + sb </em>{ i
- 1 } j <span class="math inline">\(,显然\)</span>g </em>{ i , j } = { K
} <span class="math inline">\(,并且需要保证此时没有用到\)</span>i <span class="math inline">\(以后的站台,因此需要保证\)</span> { K } K sa </em>{
i } + sb <em>i j <span class="math inline">\(.注意到由于这里保证了\)</span>f </em>{ i - 1 , j }
<span class="math inline">\(是可以取到的,因此我们可以撑到第\)</span>j
<span class="math inline">\(秒,剩下的火车在\)</span>j + $秒全选.</p>
<p>第二种,前$j <span class="math inline">\(轮中有火车接走站台\)</span>i
<span class="math inline">\(的人.设最后一次是在\)</span>r <span class="math inline">\(时间接走的站台\)</span>i <span class="math inline">\(,那么此时必然清空了\)</span>[ 1 , i - 1 ] <span class="math inline">\(,这里用了\)</span>g <em>{ i , r } <span class="math inline">\(.然后为了防止这里在\)</span>[ r + 1 , j ] <span class="math inline">\(这段时间中爆掉,因此还需要\)</span>w = { K } <span class="math inline">\(,其中\)</span>rem <span class="math inline">\(是\)</span>r <span class="math inline">\(时刻\)</span>i <span class="math inline">\(剩下的人数.这些火车都要在\)</span>r <span class="math inline">\(时刻之前解决(因为我们设了最后一次在\)</span>r
<span class="math inline">\(时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在\)</span>r
<span class="math inline">\(这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有\)</span>wK
rem <span class="math inline">\(.但是,接下来在\)</span>[ r + 1 , j ]
<span class="math inline">\(时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设\)</span>f
</em>{ i , j , 0 } <span class="math inline">\(表示只考虑前\)</span>i
<span class="math inline">\(个站台,要撑\)</span>j <span class="math inline">\(个单位时间需要的最少火车数量,但是\)</span>[ 1 , i
] $都被清空为$0 $过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol type="1">
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p></li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将$g
_{ 1 , t , 0 / 1 } $全部设为$0 $,因为我觉得无论如何$0 <span class="math inline">\(位置都是清空的,但实际上这是错误的!因为在\)</span>t
$时刻的$1 <span class="math inline">\(位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前\)</span>i
<span class="math inline">\(个的合法性,并且如果我们想要让\)</span>i
<span class="math inline">\(位置合法,一定要求让\)</span>[ 1 , i - 1 ]
$合法.</p></li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从$r t
<span class="math inline">\(这个过程中会积累的量,这些量必然要在\)</span>r
$时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p></li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>定义一个有根树为大菊花,当且仅当这棵树的根的度数$m x root , ( x ) &gt;
2 <span class="math inline">\(.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.\)</span>(
n ^5 , m ) $</p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到$O
( nm ^2 ) $.</p>
<p>注意到这个背包是可删除的,所以就能做到$O ( nm ) $.</p>
<h3><span id="dp分界点">dp分界点</span></h3>
<h4><span id="example12022zrtg十连测day7permutation">Example1(2022zrtg十连测day7
Permutation)</span></h4>
<p>首先注意到$[ 3 , n ] $一定会被分成两段递减的序列,分别跟在$1 $和$2
$的后面,假设$1 $在$2 <span class="math inline">\(前面,这样算出答案后乘以\)</span>n $即可.</p>
<p>注意到$i + 1 <span class="math inline">\(一定可以放到\)</span>i <span class="math inline">\(的前面,设\)</span>f _i <span class="math inline">\(表示在\)</span>i <span class="math inline">\(和\)</span>i + 1 <span class="math inline">\(之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即\)</span>i
<span class="math inline">\(的倍数\)</span> <span class="math inline">\(之类的,于是可以实现,复杂度\)</span>O ( n n )
$.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3>
<h4><span id="example1cf1666e">Example1(CF1666E)</span></h4>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i
$条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最小值,\)</span>g _i <span class="math inline">\(表示第\)</span>i <span class="math inline">\(个分界点可能的最大值.假设我们目前二分的最大值要小于等于\)</span>mx
<span class="math inline">\(,最小值要大于等于\)</span>mn
$,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i + 1  } &amp; = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } &amp; = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$f <span class="math inline">\(与\)</span>g <span class="math inline">\(的转移是无关的,而显然对于第\)</span>i <span class="math inline">\(个分界点,它可以取\)</span>[ f _i , g _i ]
$中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans <em>{ i } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(条分界线是啥,那么我们\)</span>ans <em>i <span class="math inline">\(是可以取\)</span>[ ans <em>{ i + 1 } - mx , ans
</em>{ i + 1 } - mn ] <span class="math inline">\(中的任何一个数字的,我们将其和上面求出的\)</span>[
f _i , g _i ] <span class="math inline">\(求一下交集.如果交集为空,说明要么\)</span>ans
</em>{ i + 1 } - mn &lt; f <em>i , f </em>{ i + 1 } &lt; ans </em>{ i +
1 } &lt; f _i + mn <span class="math inline">\(,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差\)</span>mx
- mn $.</p>
<h3><span id="数位dp">数位dp</span></h3>
<h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4>
<p>首先设$f _{ i , j } <span class="math inline">\(表示长度为\)</span>i
<span class="math inline">\(的,以\)</span>S [ n - j + 1 . . . n ]
$为子序列的字符串个数.</p>
<p>考虑按位处理,每次将$T <span class="math inline">\(的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出\)</span>k
<span class="math inline">\(.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为\)</span>k
$.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4>
<p>第一反应就是枚举$x ’ <span class="math inline">\(和\)</span>y ’ <span class="math inline">\(,然后用数位dp枚举\)</span>d <span class="math inline">\(使得\)</span>x = dx ’ , y = dy ’ $.</p>
<p>但是有一个问题在于如果$( x ’ , y ’ ) <span class="math inline">\(怎么办,这样有可能会算重.我们发现我们只判断\)</span>(
x ’ , y ’ ) = 1 $的情况就行,然后写一个$2 ^8 <span class="math inline">\(判断\)</span>x ’ , 2 x ’ , 3 x ’ , 4 x ’ <span class="math inline">\(以及对应的\)</span>y ’ <span class="math inline">\(出现了没有.复杂度\)</span>( 9 ^4 ^8 _{ 10 } n )
$,有点难过.</p>
<p>但是我们发现这个$2 ^8
$可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有$3
^4 $的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3>
<h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4>
<p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是$O
( nd ^2 ) <span class="math inline">\(的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是\)</span>O
( nd ) $的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取$$转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>现在有一个$[ 1 , n ] <span class="math inline">\(的排列,现在要从中选出一个集合\)</span>S <span class="math inline">\(,满足\)</span>x S , 2 x S , 3 x S $,求方案数.</p>
<p>首先考虑将每个数分解为$a ^b ^c <span class="math inline">\(的形式,显然\)</span>a $不相同的数之间互不干扰.</p>
<p>对于$a <span class="math inline">\(相同的一群数,我们考虑将\)</span>(
b , c )
$作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>$n $个点的树,一开始位于一号点,每个点有一个颜色($0 $或$1 <span class="math inline">\(),每次随机选择一个点\)</span>v <span class="math inline">\(,从当前所在点移动到\)</span>v <span class="math inline">\(并将\)</span>v
$的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为$1
$,当然不为$1 $也能做).</p>
<p>$n $.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是$1
$还是$0 <span class="math inline">\(就可以.不妨设\)</span>f <em>{ i }
<span class="math inline">\(表示当前有\)</span>i $个点是$1 $,最后全$1
$或者全$0 <span class="math inline">\(所需要的期望步数,显然\)</span>f
<em>0 = f <em>n = 0 <span class="math inline">\(,\)</span>f </em>{ i } =
{ 2 } ( f </em>{ i + 1 } + f </em>{ i - 1 } ) + 1
$.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在$u
<span class="math inline">\(,只要当前没有结束,我们还要选点\)</span>v
<span class="math inline">\(,对答案的期望的贡献就是\)</span>u <span class="math inline">\(到这棵树上所有点的距离之和除以\)</span>n <span class="math inline">\(,而这是一个定值.也就是说,只要我们统计一下到了每个点\)</span>u
$多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设$f <em>{ i , j , 0 / 1 } <span class="math inline">\(表示当前场面上有\)</span>i $个$1 <span class="math inline">\(,\)</span>j $号点这里是$0 $还是$1 <span class="math inline">\(,它在结束前能被期望选多少次,注意\)</span>f </em>{
n / 0 , j , 0 / 1 } = 0 <span class="math inline">\(.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设\)</span>f
_{ i , 0 / 1 } <span class="math inline">\(表示当前有\)</span>i $个$1
$,$0 / 1 $染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ 0 / n , 0 / 1  } &amp; = 0 \\
f _{ i , 0  } &amp; = \frac { i  } { n  } f _{ i - 1 , 0  } + \frac { n
- i - 1  } { n  } f _{ i + 1 , 0  } + \frac { 1  } { n  } ( f _{ i + 1 ,
1  } + [ i + 1 \ne n ] ) \\
f _{ i , 1  } &amp; = \frac { i - 1  } { n  } f _{ i - 1 , 1  } + \frac
{ n - i  } { n  } f _{ i + 1 , 1  } + \frac { 1  } { n  } ( f _{ i - 1 ,
0  } + [ i - 1 \ne 0 ] )
\end{aligned}
\]</span></p>
<p>为啥最后加上了$[ i + 1 n ]
$呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了$f <em>{ i , 0 / 1 } <span class="math inline">\(和\)</span>f </em>{ i - 1 , 0 / 1 } <span class="math inline">\(,我们发现我们可以用这两个方程求出\)</span>f <em>{
i + 1 , 0 / 1 } <span class="math inline">\(,然后就比较典了:我们将所有的函数表示成\)</span>af
</em>{ 1 , 0 } + bf <em>{ 1 , 1 } + c <span class="math inline">\(的形式(之所以这么表示,是因为我们架设了\)</span>f
</em>{ 1 , 0 / 1 } <span class="math inline">\(已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出\)</span>f
<em>{ n , 0 / 1 } <span class="math inline">\(,而\)</span>f </em>{ n , 0
/ 1 } $我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3>
<h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4>
<p>首先注意到,$a _i = 1 <span class="math inline">\(的时候和\)</span>a
_i <span class="math inline">\(的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设\)</span>f
_i <span class="math inline">\(为\)</span>a _i = 1 <span class="math inline">\(,而其他\)</span>a $全都为$0 <span class="math inline">\(时的答案,不难发现最后的答案也就是\)</span> $.</p>
<p>而上面的转移自然是:$f _i = { b <em>i , w + </em>{ j = l } ^r f _j }
$.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次$f _i
$最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查$n
$次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3>
<h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5>
<p>考虑组合意义,$a _i ^2 <span class="math inline">\(的意义也即满足操作序列\)</span>u <span class="math inline">\(和操作序列\)</span>v <span class="math inline">\(的最终结果相同的二元组\)</span>( u , v )
$的数量.</p>
<p>不妨设$dp <em>{ i , j , k } <span class="math inline">\(为第一个装置上方已经动了\)</span>i <span class="math inline">\(个珠子,下放动了\)</span>j <span class="math inline">\(个珠子,第二个装置上方动了\)</span>k <span class="math inline">\(个珠子,下方动了\)</span>i + j - k <span class="math inline">\(个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然\)</span>dp
</em>{ n , m , n } $即答案.</p>
<h5><span id="example2">Example2</span></h5>
<p>求长度为$n <span class="math inline">\(的排列的\)</span>( _{ i = 2 }
^{ n - 1 } [ a <em>i &lt; a </em>{ i - 1 } a <em>i &lt; a </em>{ i + 1 }
] ) ^k <span class="math inline">\(的期望\)</span>( n ^9 , k ) $.</p>
<p>$O ( n ^2 k ^2 ) $是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是$ans ^k $,而加入$1 <span class="math inline">\(的时候,对于每个长度为\)</span>n - 1 <span class="math inline">\(的排列,有\)</span>( n - 2 - 2 ans )
$个位置加入后会使答案加一,那我们要求的也就是:</p>
<p><span class="math display">\[
\sum ( n - 1 - 2 ans ) ( ans + 1 ) ^k + \sum ( 2 ans + 2 ) ans ^k
\]</span></p>
<p>推一推式子就可以做到$O ( nk ^2 ) $,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,$ans ^k <span class="math inline">\(等价于从所有的地方中可重复地选出\)</span>k
$个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为$1 <span class="math inline">\(的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设\)</span>f
_{ i , j } <span class="math inline">\(表示已经选了\)</span>i <span class="math inline">\(段波动序列,其中有\)</span>j <span class="math inline">\(个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度\)</span>O
( k ^3 ) $.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3>
<h4><span id="example1">Example1</span></h4>
<p>求$<em>{ i = 1 } ^n </em>{ j = 1 } ^n ( a _i a _j ) ^2 <span class="math inline">\(,\)</span>n ^5 <span class="math inline">\(,\)</span>a _i ^9 $.</p>
<p>考虑设$f _i <span class="math inline">\(表示只考虑前\)</span>i
$低的位置,高位全部默认为$0 <span class="math inline">\(的方案数.如果我们设\)</span>cnt <em>i <span class="math inline">\(表示\)</span>a <span class="math inline">\(中第\)</span>i $位为$1 <span class="math inline">\(的数个数,那根据\)</span>( a + b ) ^2 = a ^2 + 2 ab
+ b ^2 <span class="math inline">\(,我们只需要求出\)</span>g </em>{ i }
<span class="math inline">\(表示只考虑前\)</span>i <span class="math inline">\(低的位置,第\)</span>i + 1 $位是$1 <span class="math inline">\(的数和第\)</span>i + 1 $位是$0 <span class="math inline">\(的数两两异或之和,显然有\)</span>f <em>i = f </em>{
i - 1 } + 2 cnt <em>i ^i g </em>{ i - 1 } + cnt _i 2 ^{ i + 1 } $.</p>
<p>$g <span class="math inline">\(可以用\)</span>O ( n a ) <span class="math inline">\(的复杂度求,这样总复杂度\)</span>O ( n ^2 a )
$.</p>
<h3><span id="线头dp">线头dp</span></h3>
<h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5>
<p>令$dp _{ i , j , k } <span class="math inline">\(表示目前倒到第\)</span>i <span class="math inline">\(个水杯,前面还有\)</span>j <span class="math inline">\(个延续过来的未结束的线头,目前已经选定了\)</span>k
<span class="math inline">\(个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是\)</span>O
( n ^5 ) <span class="math inline">\(的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了\)</span>O
( n ^4 ) $的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5>
<p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设$dp
_{ i , 0 / 1 / 2 } <span class="math inline">\(表示前\)</span>i
$个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212svjetlo">Example3([COCI2020-2021#2]
Svjetlo)</span></h5>
<p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设$dp _{ u , 0 / 1 , 1 / 2 } <span class="math inline">\(为\)</span>u $的状态为$0 / 1 <span class="math inline">\(,以\)</span>u $为根的子树内有$1 / 2
$个线头的方案数.注意如果子树内有$0 / 2 <span class="math inline">\(个线头,那么会在\)</span>u
$处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此$dp _{ u , s ,
2 } <span class="math inline">\(的两个接头实际上一个位于\)</span>u <span class="math inline">\(,另一个位于\)</span>u $的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5>
<p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设$dp _{ i , j , k } <span class="math inline">\(表示目前走到\)</span>i <span class="math inline">\(,前面分成\)</span>j <span class="math inline">\(组,总贡献不超过\)</span>k
$的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489-jtravel-in-sugar-country">Example5([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489) J]Travel in Sugar Country)</span></h5>
<p>一条线段上有$n ( ) <span class="math inline">\(个商店,要从中选出\)</span>k ( ) <span class="math inline">\(个不同的商店\)</span>s _1 , s _2 , , s _k <span class="math inline">\(,使得按顺序遍历这\)</span>k <span class="math inline">\(个商店的路径长度是\)</span>m ( )
$的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设$dp <em>{ i , j , w , l } <span class="math inline">\(表示目前在判断了\)</span>i <span class="math inline">\(个商店,选了\)</span>j <span class="math inline">\(个,并且目前整个图有\)</span>w <span class="math inline">\(条&quot;路径&quot;(连续走动),走过的路在\)</span>m
<span class="math inline">\(一意义下为\)</span>l <span class="math inline">\(的方案数.最后的答案就是\)</span>dp </em>{ n , k ,
1 , 0 } $.</p>
<p>首先,我们对每个点求出$D ( 1 , x ) <span class="math inline">\(,然后\)</span>D ( x , y ) = | D ( 1 , y ) - D ( 1
, x ) | <span class="math inline">\(,不难发现\)</span>x <span class="math inline">\(越大\)</span>D ( 1 , x ) <span class="math inline">\(越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的\)</span>D
$和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径($s _1
s _1 <span class="math inline">\(),接下来,我们每插入一个点\)</span>x
$,我们考虑它的贡献:</p>
<ol type="1">
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是$-
2 D ( 1 , x ) $,对方案数的贡献为$1 $.</p></li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为$0
$.</p></li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为$2 D ( 1 , x )
$.</p></li>
</ol>
<p>这样我们就做到了$O ( n ^4 km ) $的复杂度.如果我们加两维$0 / 1 <span class="math inline">\(表示目前起点和终点是否加入,就可以把复杂度优化到\)</span>O
( n ^2 km ) $.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3>
<p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4>
<p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3>
<p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4>
<p>先考虑数字两两不同的时候怎么做,我们先找到$A <span class="math inline">\(中的全局最大值所在位置和\)</span>B <span class="math inline">\(中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时\)</span>A
<span class="math inline">\(取出的数量和\)</span>B
$的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把$B <span class="math inline">\(序列分成两部分,这两部分将由\)</span>A <span class="math inline">\(中相等的两部分分别生成.不妨假设这个全局最大值的位置是\)</span>x
<span class="math inline">\(,那么对于\)</span>[ 1 , x ] <span class="math inline">\(这一段的\)</span>A <span class="math inline">\(生成的\)</span>B <span class="math inline">\(数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的\)</span>A
<span class="math inline">\(能生成的\)</span>B <span class="math inline">\(的数量.对于\)</span>[ 1 , x + 1 ] $则任意.</p>
<p>那么我们所需要做的就是求出$A <span class="math inline">\(的某一段删掉若干次最大值后的序列所能生成的\)</span>B
<span class="math inline">\(的数量.不妨设\)</span>dp _{ l , r , i }
<span class="math inline">\(表示\)</span>[ l , r ] <span class="math inline">\(中所有\)</span>i
$的数字组成的序列所能生成的数量.</p>
<p>如果$[ l , r ] <span class="math inline">\(这段区间中没有数字\)</span>i <span class="math inline">\(,那显然\)</span>dp <em>{ l , r , i } = dp </em>{ l
, r , i - 1 } <span class="math inline">\(,不然,我们可以枚举两端分开的位置,那这个位置一定在数字\)</span>i
$的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4>
<p>注意到第$n <span class="math inline">\(个元素一定是山峰.所以我们考虑用第\)</span>n
$个元素分割整个区间为两部分.</p>
<p>设$f _n <span class="math inline">\(为\)</span>n <span class="math inline">\(个元素且开头为山谷的答案.枚举第\)</span>n <span class="math inline">\(个元素在位置\)</span>k <span class="math inline">\((\)</span>k - 1 <span class="math inline">\(是奇数),则\)</span>f <em>k f </em>{ n - 1 - k } {
k } f _n $.</p>
<h4><span id="example3">Example3</span></h4>
<p>给定数组$a <span class="math inline">\(,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.\)</span>n
$.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设$f <em>{ l , r
} <span class="math inline">\(为将\)</span>[ l , r ] <span class="math inline">\(删干净后再去删\)</span>a </em>{ l - 1 } , a _{ r +
1 } <span class="math inline">\(的方案数,然后枚举\)</span>[ l , r ]
$中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairingpoints">Example4([AGC039E] Pairing
Points)</span></h4>
<p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从$1 $号点这里断开,枚举$1 <span class="math inline">\(号点连接哪个点,然后就可以让\)</span>( 2 , 2 n )
<span class="math inline">\(这些点断开了.我们设计\)</span>f <em>{ i , j
, k } <span class="math inline">\(或\)</span>[ i , j ] ( k ) <span class="math inline">\(表示区间\)</span>[ i , j ] <span class="math inline">\(中的\)</span>k $向外连了一条边.答案是枚举$1 <span class="math inline">\(号点连了哪个点,也就是\)</span></em>{ i = 3 } ^{ 2
n - 1 } f _{ 2 , 2 n , i } $.</p>
<p>于是我们现在的问题在于如何求$f _{ i , j , k } <span class="math inline">\(.由于边要联通,所以与\)</span>k <span class="math inline">\(相连的这条边必然被\)</span>[ i , j ] <span class="math inline">\(中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为\)</span>x
y <span class="math inline">\(.这样整个区间被分为了两个部分:\)</span>[ i
, k ] ( x ) , [ k , j ] ( y ) <span class="math inline">\(.但是问题并没有得到解决.因为\)</span>[ i , x ]
<span class="math inline">\(和\)</span>[ y , j ] <span class="math inline">\(之间的确不可能出现连边了,但\)</span>[ x , k ]
<span class="math inline">\(和\)</span>[ k , y ] <span class="math inline">\(之间仍然可能出现连边.但我们发现:在\)</span>[ i , k
] $中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为$p , q <span class="math inline">\(.现在整个区间被分为了三个部分:\)</span>[ i , p ] (
x ) , [ p , q ] ( k ) , [ q , j ] ( y )
$,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-andremove">Example5([AGC035D] Add and
Remove)</span></h4>
<p>首先自然想到区间dp.但是难以处理的是如果一个区间$[ l , r ] <span class="math inline">\(中间删掉一个点\)</span>p <span class="math inline">\(之后,\)</span>[ l , p - 1 ] <span class="math inline">\(和\)</span>[ p + 1 , r ]
$会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到$[ l + 1 , r - 1 ] <span class="math inline">\(中最后删除的点\)</span>p <span class="math inline">\(,这样区间\)</span>[ l , r ] <span class="math inline">\(的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除\)</span>[
l + 1 , p - 1 ] <span class="math inline">\(的时候,对\)</span>p <span class="math inline">\(产生的贡献和删除\)</span>[ p + 1 , r - 1 ] <span class="math inline">\(的时候对\)</span>p
$的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设$a
_l <span class="math inline">\(贡献了\)</span>x <span class="math inline">\(倍,\)</span>a _r <span class="math inline">\(贡献了\)</span>y <span class="math inline">\(倍,那么由于\)</span>a _p <span class="math inline">\(会两边都贡献到,所以\)</span>a _p <span class="math inline">\(会对答案贡献\)</span>x + y $倍.</p>
<p>于是设计一个dp是:$f <em>{ l , r , x , y } <span class="math inline">\(表示删除\)</span>[ l + 1 , r - 1 ] <span class="math inline">\(后,\)</span>xa <em>l + ya <em>r <span class="math inline">\(最小是多少.自然有\)</span>f </em>{ l , r , x , y }
= { f </em>{ l , p , x , x + y } + f </em>{ p , r , x + y , y } + ( x +
y ) a _p } $.</p>
<p>至于复杂度,前两维肯定是$n ^2 <span class="math inline">\(的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移\)</span>n
$层,因此是$2 ^n <span class="math inline">\(的空间,于是时间复杂度不会超过\)</span>O ( n ^3 2
^n ) <span class="math inline">\(,其实经过一些奇怪计算应该是不会超过\)</span>O ( 2
^n ) $的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4>
<p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设$f _{ l , r } <span class="math inline">\(表示删除\)</span>[ l , r ] <span class="math inline">\(区间的代价.接下来我们无非要枚举\)</span>k <span class="math inline">\(,使得\)</span>k $是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如$l <span class="math inline">\(,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果\)</span>a
<em>l = a <em>k <span class="math inline">\(,那么这等价于\)</span>f
</em>{ l + 1 , k - 1 } + [ l = k - 1 ] + f </em>{ k + 1 , r }
$.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4>
<p>首先考虑一下$m = 2 ^k - 1 $的情况,首先我们要判断有几个数最高位是$1
$,然后接下来判断第二位哪些数字是$1 $.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是$1
$的就一定大于最高位是$0 <span class="math inline">\(的了,这两个区间就没有影响了.因此可以设\)</span>f
_{ l , r , k } <span class="math inline">\(表示\)</span>[ l , r ] <span class="math inline">\(这个区间,前面已经有了\)</span>k $个$1
$的最大贡献.</p>
<p>那么对于$m ^k - 1 <span class="math inline">\(的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过\)</span>m
$就行了.</p>
<h3><span id="相互独立">相互独立</span></h3>
<h5><span id="example12019zrtg十连测day1origami">Example1(2019zrtg十连测day1
origami)</span></h5>
<p>看上去很不好做,先考虑宽为$1 $怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间$[
l , r ] <span class="math inline">\(,然后看\)</span>[ 1 , l - 1 ] <span class="math inline">\(和\)</span>[ r + 1 , m ] <span class="math inline">\(能不能折进来.也就是判断以\)</span>r <span class="math inline">\(和\)</span>r + 1
$为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设$f _i <span class="math inline">\(表示能不能折成以\)</span>[ 1 , i ] <span class="math inline">\(为最下层,\)</span>g _i <span class="math inline">\(表示能不能折成\)</span>[ i , n ] <span class="math inline">\(为最下层,那\)</span>[ l , r ] <span class="math inline">\(能折出来当且仅当\)</span>f _r = g _l = 1
$,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-anedge">Example2(CF1616G Just Add an
Edge)</span></h5>
<p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如$1 x y n $,并且$1 x <span class="math inline">\(和\)</span>y n <span class="math inline">\(不交,然后添加边\)</span>x y $.</p>
<p>那么什么时候$1 x <span class="math inline">\(和\)</span>y n <span class="math inline">\(没有交并且他们的并是\)</span>[ 1 , n ]
$呢?考虑将$1 x $这条路径上的点染色为$0 <span class="math inline">\(,\)</span>y n $上的点染色为$1 <span class="math inline">\(,由于边只有从前往后的,因此\)</span>[ 1 , y - 1 ]
$必然为$0 <span class="math inline">\(,\)</span>[ x + 1 , n ] $必然为$1
$.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了$y <span class="math inline">\(,现在想要找到\)</span>x <span class="math inline">\(,我们现在假设染色的末尾是\)</span>( i , i + 1 )
<span class="math inline">\(,也就是\)</span>i <span class="math inline">\(染色和\)</span>i + 1
$的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个$p <span class="math inline">\(,满足\)</span>p p + 1 <span class="math inline">\(,那么\)</span>p <span class="math inline">\(和\)</span>p + 1 <span class="math inline">\(永远不可能染同种颜色,我们直接以它为断点,自然发现\)</span>p
$的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了$p p + 1
$这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立$0
<span class="math inline">\(和\)</span>n + 1 $两个虚点,向所有点连边.</p>
<p>总之$O ( nm )
$的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3>
<p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5>
<p>首先考虑已知一个序列,如何快速求它最后有几个位置不是$0 <span class="math inline">\(.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其\)</span>-
1 $并重复判断操作,直到为$0 $或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是$0 <span class="math inline">\(相当于判断后面的已知序列的\)</span>mex <span class="math inline">\(,这个要记入状态中,于是考虑设\)</span>dp _{ i , j }
<span class="math inline">\(表示当前到了第\)</span>i <span class="math inline">\(个位置,后面的数的\)</span>mex - 1 <span class="math inline">\(是\)</span>j $的方案数.</p>
<p>但是如果直接这么设会发现,当前$i <span class="math inline">\(的加入有可能会改变\)</span>mex <span class="math inline">\(的值,而这个改变是很难处理的,因为如果\)</span>i
<span class="math inline">\(位置选择了\)</span>j + 1 <span class="math inline">\(这个数字,那么\)</span>mex <span class="math inline">\(要向上伸展到某一个值,而如果不选择\)</span>j + 1
<span class="math inline">\(,也有可能选择一个更大的值后不断落到\)</span>j + 1
<span class="math inline">\(,这意味着我们转移时需要枚举补上\)</span>j +
1 <span class="math inline">\(这个数字后的\)</span>mex
$并用刷表法转移.</p>
<p>不妨设这个数字是$k <span class="math inline">\(.如果我们插入一个数字后直接更新当前的答案,可以发现这个\)</span>k
<span class="math inline">\(是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起\)</span>mex
<span class="math inline">\(的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全\)</span>[
j + 2 , k ] $这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以$2
^{ n } $.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5>
<p>$O ( n ^3 ) <span class="math inline">\(的暴力是显然的:设\)</span>f
_{ i , j , k } <span class="math inline">\(表示目前考虑到第\)</span>i
<span class="math inline">\(个位置,前面还有\)</span>j <span class="math inline">\(个A,已经选了\)</span>k
$个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到$n ^2 $.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设$f
_{ i , j } <span class="math inline">\(表示目前考虑到\)</span>i <span class="math inline">\(,还需要\)</span>j <span class="math inline">\(个B才能凑齐\)</span>c _B
$个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3>
<h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5>
<p>设$f <em>{ i , j } <span class="math inline">\(表示长度为\)</span>i
<span class="math inline">\(,开头为山峰且高度为\)</span>j <span class="math inline">\(的方案数;\)</span>g </em>{ i , j } <span class="math inline">\(表示长度为\)</span>i <span class="math inline">\(,开头为山谷且高度为\)</span>j <span class="math inline">\(的方案数.注意到这俩显然是一个双射,也就是\)</span>f
<em>{ i , j } = g </em>{ i , i - j + 1 } $.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于$j
<span class="math inline">\(的数都向上平移一格,于是自然有:\)</span>f
<em>{ i , j } = </em>{ k = 1 } ^{ j - 1 } g <em>{ i - 1 , k } = </em>{ k
= 1 } ^{ j - 1 } f _{ i - 1 , i - k } $.</p>
<p>另外,这个式子可以稍微转化为:$f <em>{ i , j } = f </em>{ i - 1 , i - j
+ 1 } + f <em>{ i , j - 1 } = g </em>{ i - 1 , j - 1 } + f _{ i , j - 1
} $.</p>
<p>上式可以这么理解:我们讨论一下$j <span class="math inline">\(和\)</span>j - 1 <span class="math inline">\(是否相邻,如果相邻必然是\)</span>j <span class="math inline">\(是山峰,\)</span>j - 1
$是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1group">Example2(2019zrtg十连测day1
group)</span></h5>
<p>首先注意到$2 k n nk ^5 <span class="math inline">\(,不难发现\)</span>k $.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到$O
( nk ^2 ) $.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点$w <span class="math inline">\(,使得成为组长的经验\)</span>w <span class="math inline">\(,成为组员的经验\)</span>w
$,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5>
<p>双序列计数,考虑把$x $双射到某个东西上.</p>
<p>考虑最后的图一定是个$DAG
$,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设$dp _{ l , r , mx } <span class="math inline">\(表示只考虑\)</span>[ l , r ] <span class="math inline">\(这一段的线段,然后最大值所在位置需要\)</span>mx
$的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3>
<p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweightedincreasing-subsequences">Example1([CF1621G]Weighted
Increasing Subsequences)</span></h5>
<h2><span id="动态规划的优化">动态规划的优化</span></h2>
<h3><span id="递进转移">递进转移</span></h3>
<p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5>
<p>有$m <span class="math inline">\(种礼物,每种礼物有无数个(有有限个也能做),\)</span>n
<span class="math inline">\(个朋友,第\)</span>i <span class="math inline">\(个朋友喜欢第\)</span>j <span class="math inline">\(个礼物的概率是\)</span>p <em>{ i , j } <span class="math inline">\(,\)</span>i , p </em>{ i , j } = 1 $.</p>
<p>现在你可以选$n
$件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p>$n , m $.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出$g
_{ i , j } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(种礼物一共选了\)</span>j
$个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么$g <span class="math inline">\(怎么求呢?这个是简单的,我们设\)</span>f <em>{ i , j
} <span class="math inline">\(表示喜欢第\)</span>i <span class="math inline">\(种礼物的人有\)</span>j <span class="math inline">\(个的概率,不难发现\)</span>g </em>{ i , j } = <em>{
k = 0 } ^n { j , k } f </em>{ i , k } <span class="math inline">\(.递推式就有\)</span>g <em>{ i , j } = g </em>{ i ,
j - 1 } + <em>{ k = j } ^n f </em>{ i , k } <span class="math inline">\(.\)</span>f $同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是$O ( n ^2 m )
$的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现$g _{ i , j } <span class="math inline">\(满足四边形不等式,而其转移是经典的\)</span>k
$点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于$g _i <span class="math inline">\(是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为\)</span>c
<em>i <span class="math inline">\(,每次选当前\)</span>g </em>{ i , c
<em>i + 1 } - g </em>{ i , c _i } <span class="math inline">\(最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为\)</span>c
_i <span class="math inline">\(越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度\)</span>O
( n ^2 n ) <span class="math inline">\(,不太确定有没有\)</span>O ( n ^2
) $的做法.</p>
<p>但是第二个背包,也就是$f <span class="math inline">\(怎么求呢?我们发现我们没有必要把\)</span>g <span class="math inline">\(全都求出来,只需要求目前需要的一部分就可以了,由于\)</span>f
= 1 <span class="math inline">\(,因此后缀和可以改为前缀和,考虑到每往后推一位是\)</span>O
( n ) <span class="math inline">\(的,但是只会往后推总共\)</span>O ( n )
<span class="math inline">\(位,因此这里复杂度\)</span>O ( n ^2 ) $.</p>
<h5><span id="example2">Example2</span></h5>
<p>给一个字符串,求一个最大长度$L { 2 } <span class="math inline">\(,使得前\)</span>L <span class="math inline">\(个字符与后\)</span>L $个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<p><span class="math display">\[
ABSBA
\]</span></p>
<p>我们枚举$A <span class="math inline">\(的长度,然后就只需要求\)</span>B <span class="math inline">\(,设\)</span>f <em>{ i } <span class="math inline">\(表示字符串去掉开头和结尾的\)</span>i <span class="math inline">\(个字符后的border,有\)</span>f </em>{ i - 1 } f _i
+ 1 $.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3>
<p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k <span class="math inline">\(暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取\)</span><span class="math inline">\(操作很艰难.但如果!我把这个dp反过来,我设\)</span>f
_{ i , j } <span class="math inline">\(表示**从后往前**dp到\)</span>i
<span class="math inline">\(,当前的最大前缀和是\)</span>j
$的概率是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i -
1  } \}  }
\]</span></p>
<p>最后在$f _{ 1 , j } <span class="math inline">\(处乘上\)</span>h _j
$.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g <em>{ i , j } <span class="math inline">\(表示如果初始只有\)</span>f </em>{ i , j } = 1
$,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g
_{ i , j  } \\

\end{gathered}\]</span>
<p>$$</p>
<p>我认真考虑过这个$P <span class="math inline">\(应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些\)</span>P
$变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3>
<h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4>
<p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于$200
$.也就是说转移矩阵大概是$200 <span class="math inline">\(的,设状态数为\)</span>S $.</p>
<p>继续考虑,如果直接做的话复杂度是$O ( TS ^3 n ) $,过不了.</p>
<p>我们考虑将一个$n <span class="math inline">\(在\)</span>w <span class="math inline">\(进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了\)</span>O
( wS ^3 _w n + TS ^2 _w n ) <span class="math inline">\(,平衡一下复杂度即可,大概取\)</span>w = 4
$会比较优秀.</p>
<h4><span id="example2noionline3提高组魔法值">Example2([NOI
Online#3提高组]魔法值)</span></h4>
<p>重新定义矩阵乘法:用$<span class="math inline">\(替换原本的\)</span>+
$,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4>
<p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令$f <em>i = </em>{ j , a _j = a _i - 1 } f _j <span class="math inline">\(,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的\)</span><span class="math inline">\(的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的\)</span>f
$.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设$f _{
i , j } <span class="math inline">\(表示所有\)</span>a _x = i <span class="math inline">\(的\)</span>x <span class="math inline">\(中第\)</span>j <span class="math inline">\(小的\)</span>x $的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4>
<p>注意到$m <span class="math inline">\(和\)</span>k
$很小,这一定是突破口.</p>
<p>又注意到如果$a _{ i + 1 } &gt; a <em>i <span class="math inline">\(,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字\)</span>x
+ 1 <span class="math inline">\(,我们考虑它只能插入\)</span>[ x + 1 - m
, x ] <span class="math inline">\(后面,我们直接用一个二进制数\)</span>S
<span class="math inline">\(表示\)</span>[ x + 1 - m , x ] <span class="math inline">\(中的数字是否存在,然后就可以在转移上直接调用\)</span>popcount
( S ) <span class="math inline">\(.设\)</span>dp </em>{ i , j , S }
<span class="math inline">\(表示目前考虑完了数字\)</span>i <span class="math inline">\(,插入了\)</span>j <span class="math inline">\(个数字,存在情况是\)</span>S <span class="math inline">\(.直接对它做矩阵加速就可以做到\)</span>O ( ( 2 ^m k
) ^3 n ) $.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4>
<p>设$dp _{ i , j } <span class="math inline">\(表示第\)</span>i <span class="math inline">\(天走到城市\)</span>j $的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上$k
$.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3>
<p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4>
<p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设$f _{ l , r } <span class="math inline">\(表示\)</span>a _l
<span class="math inline">\(和\)</span>a _r <span class="math inline">\(必选的前提下,\)</span>[ l , r ]
$这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设$dp <em>{ i , j } <span class="math inline">\(表示前\)</span>i
<span class="math inline">\(个点,最大值为\)</span>j <span class="math inline">\(的方案数,不难发现最后一个矩阵的最小值一定是\)</span>a
</em>{ i } <span class="math inline">\(.然后\)</span>dp <em>{ a , b } =
</em>{ i &lt; a , j &lt; b } dp <em>{ i , j } f </em>{ i + 1 , a }
$.</p>
<p>这个转移是$n ^4 <span class="math inline">\(的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到\)</span>n
^2 <span class="math inline">\(,这样我们就得到了一个复杂度\)</span>O ( n
^3 ) $的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点$i
<span class="math inline">\(,它所在矩阵的最左边的点\)</span>k <span class="math inline">\(,最右边的点\)</span>k <span class="math inline">\(,然后此时的答案为\)</span>pre [ j - 1 ] [ a [ k ]
- 1 ] nxt [ k + 1 ] [ a [ j ] + 1 ] f [ j ] [ i ] f [ i ] [ k ] $.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设$g <em>{ i , j } <span class="math inline">\(为接下来我们要选\)</span>[ i , j ] <span class="math inline">\(,\)</span>i <span class="math inline">\(是矩阵左端点,\)</span>j <span class="math inline">\(任意且这两个点必在矩阵中,左右两边的方案数.初始条件\)</span>g
</em>{ i , j } = pre [ i - 1 ] [ a [ j ] - 1 ] nxt [ j + 1 ] [ a [ i ] +
1 ] $.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3>
<h4><span id="example2022zrtg十连测day7zero">Example(2022zrtg十连测day7
Zero)</span></h4>
<p>设$k = { i , j } <span class="math inline">\(,首先可以求出\)</span>x
, y , z $分别表示:</p>
<ol type="1">
<li><p>$x <span class="math inline">\(:只包含第一行的格子的以\)</span>k
$为右端点的和为$0 <span class="math inline">\(的最小矩形的左端点\)</span>- 1 $.</p></li>
<li><p>$y <span class="math inline">\(:只包含第二行的格子的以\)</span>k
$为右端点的和为$0 <span class="math inline">\(的最小矩形的左端点\)</span>- 1 $.</p></li>
<li><p>$z <span class="math inline">\(:同时包含两行的格子的以\)</span>k
$为右端点的和为$0 <span class="math inline">\(的最小矩形的左端点\)</span>- 1 $.</p></li>
</ol>
<p>那么自然有转移:</p>
<p><span class="math display">\[
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z
, z ) + 1 \}
\end{gathered}
\]</span></p>
<p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到$f ( i , k ) <span class="math inline">\(关于\)</span>i <span class="math inline">\(不降,于是显然当\)</span>f ( i , y ) f ( i , k - 1
) <span class="math inline">\(的时候才会由\)</span>f ( i , y ) + 1 <span class="math inline">\(转移过来.我们不妨设\)</span>p _i <span class="math inline">\(表示最小的位置满足\)</span>f ( i , p _i ) = f ( i
, k - 1 ) <span class="math inline">\(,那转移也就是\)</span>f ( i , k )
f ( i , k - 1 ) + [ p _i y ] <span class="math inline">\(.并且每进行一次转移,都会满足\)</span>p _i y <span class="math inline">\(的\)</span>p _i <span class="math inline">\(设为\)</span>k $.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的$i <span class="math inline">\(在当前\)</span>k <span class="math inline">\(的\)</span>f <span class="math inline">\(值,将这个点放到\)</span>p _i <span class="math inline">\(位置上.然后我们每次找到\)</span>y <span class="math inline">\(并把所有在\)</span>y <span class="math inline">\(位置前的点都合并到\)</span>k <span class="math inline">\(这个点上,并打一个加法\)</span>tag
$,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的$p _k $.</p>
<p>最后还需要处理一下$f _{ k , k } $,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照${ i , j }
$为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3>
<p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5>
<p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是$ i
&lt; j &lt; k n <span class="math inline">\(,\)</span>a _i &gt; a _j
&gt; a _k $.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是$dp _{ i , j }
<span class="math inline">\(表示现在做到\)</span>i <span class="math inline">\(,另一个上升子序列的终点是\)</span>j
$,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在$i <span class="math inline">\(一定的情况下,\)</span>j <span class="math inline">\(的值越小越容易满足.所以设\)</span>dp _i <span class="math inline">\(表示一个上升子序列的终点是\)</span>i
$,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5>
<p>首先自然的设计是$dp _{ l , r , u , d } <span class="math inline">\(,然后优化一下就是\)</span>O ( n ^4 )
$.然后咋做?</p>
<p>注意到答案不超过$<span class="math inline">\(级别,所以设\)</span>dp
_{ l , r , u , c } <span class="math inline">\(表示答案为\)</span>c
<span class="math inline">\(的时候,最大的\)</span>d <span class="math inline">\(是多少.然后就\)</span>O ( n ^3 n ) $.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数$a _i <span class="math inline">\(减去\)</span>[ 1 , a _i ] $中的一个数字,减成$0
<span class="math inline">\(就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.\)</span>(
n ) $</p>
<p>先考虑一个$O ( n ^2 a ^2 ) $的dp,比较显然,因为一个人取数显然要么取$1
<span class="math inline">\(要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设\)</span>dp
_{ l , r , x , y } <span class="math inline">\(表示目前Alice在取第\)</span>l <span class="math inline">\(堆,Bob在取第\)</span>r <span class="math inline">\(堆,第\)</span>l <span class="math inline">\(堆为\)</span>x <span class="math inline">\(,第\)</span>r <span class="math inline">\(堆为\)</span>y $的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把$a
$存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是$1 <span class="math inline">\(还是更大的数好像无所谓.那:如果\)</span>a _1 = x
<span class="math inline">\(的时候,Alice能赢,那\)</span>a _1 = x + 1
$的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选$1
<span class="math inline">\(,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于\)</span>a
_l <span class="math inline">\(或\)</span>a _r $.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存$0 / 1 $是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设$dp _{ l , r } <span class="math inline">\(表示当前Alice在\)</span>l <span class="math inline">\(,Bob在\)</span>r <span class="math inline">\(,Bob还没动\)</span>a _r <span class="math inline">\(的前提下,\)</span>a <em>l <span class="math inline">\(至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较\)</span>dp
</em>{ 1 , 1 } <span class="math inline">\(和\)</span>a _1
$的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选$l <span class="math inline">\(,Bob开始选\)</span>r <span class="math inline">\(,那Alice的获胜条件显然是\)</span>dp _{ l , r } a
_r $</p>
<p>如果可以全选(也就是Alice开始选$l + 1 <span class="math inline">\(,Bob开始选\)</span>r <span class="math inline">\(的时候Alice能赢),就直接让\)</span>dp <em>{ l , r }
= 1 <span class="math inline">\(.不然,由于清空堆的人要输,所以Alice为了不输,必须要让\)</span>dp
</em>{ l , r - 1 } <span class="math inline">\(也满足条件,一个自然的想法是\)</span>dp <em>{ l , r
- 1 } + a <em>r + 1 <span class="math inline">\(,但是这个值好像没有必要:因为Bob并不是只有会不断清空\)</span>a
<em>r <span class="math inline">\(的,如果目前的\)</span>[ l + 1 , r ]
<span class="math inline">\(这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢\)</span>[
l + 1 , r ] <span class="math inline">\(的值,Bob就必须全清空,所以如果我们设\)</span>g
</em>{ l , r } <span class="math inline">\(是Bob的\)</span>dp <span class="math inline">\(数组,那其实这里应该是\)</span>a <em>r + 1 + dp
</em>{ l , r - 1 } - g </em>{ l + 1 , r } <span class="math inline">\(,因为Bob的策略一定是一步一步走到\)</span>g </em>{
l + 1 , r } $后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5>
<p>自然的想法是$dp _{ i , j } <span class="math inline">\(表示\)</span>i
<span class="math inline">\(子树内划分成\)</span>j <span class="math inline">\(个连通块是否合法,然后我们发现如果\)</span>j <span class="math inline">\(满足条件,那么\)</span>j + 2
$一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3>
<p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于$y
$轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5>
<p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3>
<p>能用WQS二分解决的问题通常形如:需要在$n <span class="math inline">\(个物品中选择恰好\)</span>m <span class="math inline">\(个,使得最后答案最大.并且如果令\)</span>f _i <span class="math inline">\(表示选了\)</span>i <span class="math inline">\(个的最大答案,\)</span>f _i
$必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数$C <span class="math inline">\(,每选择一个物品就减去\)</span>C <span class="math inline">\(的答案.不难发现这样我们一定能逼近\)</span>f _m
$.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3>
<p>对于定义在$ <span class="math inline">\(上的二元函数\)</span>w <span class="math inline">\(,若对定义域上任意\)</span>a , b , c , d ( a b c d
) <span class="math inline">\(都有\)</span>w ( a , c ) + w ( b , d ) w (
a , d ) + w ( b , c ) <span class="math inline">\(,也就是交叉小于包含,则称函数\)</span>w
$满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:$w
$所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于$0
$.</p>
<p>如果它还满足$ l ’ l r r ’ n , w ( l , r ) w ( l ’ , r ’ )
$，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理$<span class="math inline">\(型dp的问题,对于\)</span><span class="math inline">\(型dp需要取相反数改成\)</span>$.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p>若二元函数$w ( x , y ) <span class="math inline">\(满足\)</span>w ( a
, b ) + w ( a + 1 , b + 1 ) w ( a , b + 1 ) + w ( a + 1 , b ) <span class="math inline">\(.其中\)</span>a &lt; a + 1 b &lt; b + 1 <span class="math inline">\(,则\)</span>w $满足四边形不等式.</p>
<p>证明:</p>
<p>对于$a + 1 &lt; c $ 有</p>
$$
<span class="math display">\[\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1
, c ) \\
w ( a + 1 , c + 1 ) &amp; \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a
, c ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>同时有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) &amp; \leq w ( a + 1 , c + 1 ) + w
( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
+ 1 , c + 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
<p><span class="math display">\[
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) &amp; \leq w ( a
, c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) &amp; \leq w ( a + 1 , c ) + w ( a + 2
, c + 1 )
\end{aligned}
\]</span></p>
<p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个$2
$的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5>
<p>若$w _1 ( l , r ) , w _2 ( l , r ) <span class="math inline">\(满足四边形不等式(或区间包含单调性),则\)</span>c _1
, c _2 <span class="math inline">\(,\)</span>( c _1 w _1 + c _2 w _2 )
$满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若$f ( x ) , g ( x ) <span class="math inline">\(使得\)</span>w ( l ,
r ) = f ( r ) - g ( l ) <span class="math inline">\(,则\)</span>w <span class="math inline">\(满足四边形恒等式.当\)</span>f , g <span class="math inline">\(单调递增时,\)</span>w $还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>设$h <span class="math inline">\(是一个单调递增的下凸函数(一阶导数单调递增),若\)</span>w
( l , r ) <span class="math inline">\(满足四边形不等式和区间包含单调性,则复合函数\)</span>h
( w ( l , r ) ) $也满足四边形不等式和区间包含单调性.</p>
<p>令$l _1 l _2 r _1 r _2 <span class="math inline">\(,由于\)</span>w
$满足四边形不等式,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l _1 , r _1 ) + w ( l _2 , r _2 ) &amp; \leq w ( l _1 , r _2 ) + w (
l _2 , r _1 ) \\
0 &amp; \leq w ( l _1 , r _1 ) - w ( l _2 , r _1 ) &amp; \leq w ( l _1 ,
r _2 ) - w ( l _2 , r _2 )
\end{aligned}
\]</span></p>
<p>令$t = w ( l _1 , r _2 ) - w ( l _2 , r _2 ) $,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
w ( l _1 , r _1 ) &amp; \leq w ( l _2 , r _1 ) + t \\
w ( l _1 , r _2 ) &amp; = w ( l _2 , r _2 ) + t \\
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) &amp; \leq h ( w ( l
_2 , r _1 ) + t ) - h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) &amp; = h ( w ( l _2 ,
r _2 ) + t ) - h ( w ( l _2 , r _2 ) )
\end{aligned}
\]</span></p>
<p>不妨令$h ( x ) = h ( x + t ) - h ( x ) <span class="math inline">\(,由于\)</span>h <span class="math inline">\(是下凸函数,所以\)</span>h $函数单调递增.</p>
<p>那么也就有:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) &amp; \leq \Delta h (
w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) &amp; = \Delta h ( w (
l _2 , r _2 ) )
\end{aligned}
\]</span></p>
<p>由于$w ( l _2 , r _1 ) w ( l _2 , r _2 ) <span class="math inline">\(,所以\)</span>h ( w ( l _2 , r _1 ) ) h ( w ( l _2
, r _2 ) ) $于是:</p>
<p><span class="math display">\[
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) &amp; \leq h ( w ( l
_1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) \\
h ( w ( l _1 , r _1 ) ) + h ( w ( l _2 , r _2 ) ) &amp; \leq h ( w ( l
_1 , r _2 ) ) + h ( w ( l _2 , r _1 ) )
\end{aligned}
\]</span></p>
<p>证毕.</p>
<h5><span id="定理5">定理5</span></h5>
<p>设$h <span class="math inline">\(是一个下凸函数(一阶导数单调递增),若\)</span>w ( l
, r ) <span class="math inline">\(满足四边形恒等式和区间包含单调性,则复合函数\)</span>h
( w ( l , r ) ) $也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到$h $单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4>
<p>对于形如$f <em>i = </em>{ 1 j &lt; i } { f _j + w ( j , i ) } <span class="math inline">\(的状态转移方程,记\)</span>p _i <span class="math inline">\(为\)</span>f _i <span class="math inline">\(的最优决策.若\)</span>p <span class="math inline">\(在\)</span>[ 1 , n ] <span class="math inline">\(上单调不降,则称\)</span>f $具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的$<span class="math inline">\(改为\)</span><span class="math inline">\(,并且把\)</span>+ w <span class="math inline">\(改为\)</span>- w $,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5>
<p>定理：对于形如$f <em>i = </em>{ 1 j &lt; i } { f _j + w ( j , i ) }
<span class="math inline">\(的状态转移方程,若\)</span>w <span class="math inline">\(满足四边形不等式,则\)</span>f $有决策单调性.</p>
<p>证明:</p>
<p>$i , j <span class="math inline">\(,根据\)</span>p $的定义,有:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ p _i  } + w ( p _i , i ) &amp; \leq f _j + w ( j , i ) \\
f _{ p _i  } - f _j &amp; \leq w ( j , i ) - w ( p _i , i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而对于$k <span class="math inline">\(,根据\)</span>w
$的四边形不等式,有:</p>
$$
<span class="math display">\[\begin{aligned}
w ( j , i ) + w ( p _i , k ) &amp; \leq w ( j , k ) + w ( p _i , i ) \\
w ( j , i ) - w ( p _i , i ) &amp; \leq w ( j , k ) - w ( p _i , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>联立得到:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ p _i  } - f _j &amp; \leq w ( j , k ) - w ( p _i , k ) \\
f _{ p _i  } + w ( p _i , k ) &amp; \leq w ( j , k ) + f _j \\

\end{aligned}\]</span>
<p>$$</p>
<p>即:$j <span class="math inline">\(对\)</span>k <span class="math inline">\(的更新一定不如\)</span>p _i <span class="math inline">\(对\)</span>k <span class="math inline">\(的更新更优,因此\)</span>p _k <span class="math inline">\(,因此\)</span>f $有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6>
<p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设$f <em>i <span class="math inline">\(表示价值为\)</span>i
<span class="math inline">\(的答案,自然有:\)</span>f <em>i = { f </em>{
i - kc } + sum </em>{ c , k } } $.</p>
<p>如果我们把$c <span class="math inline">\(相同的分层,那这显然是一个最短路型dp,其中\)</span>w
( i , j ) = sum _{ c , { c } } $.</p>
<p>显然这个转移只会让$c <span class="math inline">\(相同的相互转移,于是后面的\)</span>w ( i , j )
<span class="math inline">\(可以理解为一段数字的和,自然满足四边形不等式(\)</span>$也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5>
<p>对于形如$f <em>{ x , j } = </em>{ i = 1 } ^{ x - 1 } { f <em>{ i , j
- 1 } + w </em>{ i , x } } <span class="math inline">\(的状态转移方程,若\)</span>w <span class="math inline">\(满足四边形不等式,则\)</span>f
$有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如$f <em>x = </em>{ i = 1 } ^{ x - 1 } { w _{ i ,
x } } <span class="math inline">\(,我们也可以看作\)</span>k <span class="math inline">\(点最短路型的\)</span>k = 1 $的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6>
<p>令$f ( i , j ) <span class="math inline">\(为在第\)</span>j <span class="math inline">\(个位置建造第\)</span>i
$个基站的代价最小值,那么我们有转移:</p>
<p><span class="math display">\[
f ( i , j ) = \min _{ 1 \leq k &lt; j  } \{ f ( i - 1 , k ) + \sum _{ l
= k + 1  } ^{ j - 1  } w _l [ d _l - s _l &gt; d _k ] [ d _l + s _l &lt;
d _j ] + c _j \}
\]</span></p>
<p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时$d
_k <span class="math inline">\(单调递增,更新答案时\)</span>d _j <span class="math inline">\(单调递增,于是可以直接使用线段树维护,复杂度\)</span>O
( nk n ) $.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度$O ( nk ^2 n ) $.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度$O ( n k n ) $.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6>
<p>自然的设计是$f _{ i , j , k } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个,已经打了\)</span>j <span class="math inline">\(个,末尾有连续\)</span>k
$个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为$f <em>{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个,目前打了\)</span>j <span class="math inline">\(个且第\)</span>i <span class="math inline">\(个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成\)</span>f
</em>{ i , j } <span class="math inline">\(表示前\)</span>i <span class="math inline">\(个,目前有\)</span>j <span class="math inline">\(个没打中而且第\)</span>i
$个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:$dp <em>{ i , j } = { dp </em>{ k , j -
1 } + <em>{ l = k + 1 } ^{ i - 1 } C </em>{ l - k } A _l + P } $.</p>
<p>令$w ( l , r ) = <em>{ k = l + 1 } ^{ r - 1 } C </em>{ k - l } A _k +
P <span class="math inline">\(,接下来我们证明:\)</span>w ( l + 1 , r ) +
w ( l , r - 1 ) w ( l , r ) + w ( l + 1 , r - 1 ) <span class="math inline">\(即可.讨论一下每个\)</span>A
$面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5>
<p>引理:在状态转移方程$f <em>{ i , j } = </em>{ i k &lt; j } { f <em>{ i
, k } + f </em>{ k + 1 , j } + w ( i , j ) } <span class="math inline">\(中(通常\)</span>f <em>{ i , i } = w ( i , i ) = 0
, f </em>{ i , i + 1 } = w _{ i , i + 1 } <span class="math inline">\(),如果\)</span>w <span class="math inline">\(满足四边形不等式和区间包含单调性,那么\)</span>f
$也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明$f <em>{ i , j } + f </em>{ i + 1 , j + 1 } f <em>{ i , j + 1
} + f </em>{ i + 1 , j } <span class="math inline">\(即可,考虑\)</span>j
- i = 1 $的时候,显然成立.</p>
<p>使用数学归纳,假设当$b - a &lt; k <span class="math inline">\(时,\)</span>f <span class="math inline">\(满足四边形不等式,考虑\)</span>j - i = k
$的情况:</p>
<p>设$f <em>{ i , j + 1 } <span class="math inline">\(的最优决策为\)</span>x <span class="math inline">\(,\)</span>f </em>{ i + 1 , j } <span class="math inline">\(的最优决策为\)</span>y $,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i , j + 1  } + f _{ i + 1 , j  } &amp; = f _{ i , x  } + f _{ x + 1
, j + 1  } + w ( i , j + 1 ) + f _{ i + 1 , y  } + f _{ y + 1 , j  } + w
( i + 1 , j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>对于$f <em>{ i , j } <span class="math inline">\(和\)</span>f </em>{
i + 1 , j + 1 } <span class="math inline">\(来说,\)</span>x <span class="math inline">\(和\)</span>y $不一定最优,所以有:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } &amp; \leq f _{ i , x  } + f _{ x
+ 1 , j  } + w ( i , j ) + f _{ i + 1 , y  } + f _{ y + 1 , j + 1  } + w
( i + 1 , j + 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>$w $和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } &amp; \leq f _{ i , j + 1  } + f
_{ i + 1 , j  } \\

\end{aligned}\]</span>
<p>$$</p>
<h6><span id="定理">定理</span></h6>
<p>记$p <em>{ i , j } <span class="math inline">\(为\)</span>f </em>{ i
, j } <span class="math inline">\(的最优决策,若\)</span>f <span class="math inline">\(满足四边形不等式,那么对于\)</span>i &lt; j ， 有 p
<em>{ i , j - 1 } p </em>{ i , j } p _{ i + 1 , j } \ $.</p>
<p>证明:</p>
<p>记$p = p _{ i , j } <span class="math inline">\(,\)</span>k , i &lt;
k p <span class="math inline">\(,因为\)</span>f
$满足四边形不等式,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ i , k  } + f _{ i + 1 , p  } &amp; \leq f _{ i , p  } + f _{ i + 1
, k  } \\
f _{ i + 1 , p  } - f _{ i + 1 , j  } &amp; \leq f _{ i , p  } - f _{ i
, k  }
\end{aligned}
\]</span></p>
<p>根据$p $定义,有:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ i , p  } + f _{ p + 1 , j  } &amp; \leq f _{ i , k  } + f _{ k + 1
, j  } \\
f _{ i , p  } - f _{ i , k  } &amp; \leq f _{ k + 1 , j  } - f _{ p + 1
, j  }
\end{aligned}
\]</span></p>
<p>由上两式移项联立,得到:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ i + 1 , p  } - f _{ i + 1 , k  } &amp; \leq f _{ k + 1 , j  } - f
_{ p + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } &amp; \leq f _{ i + 1 , k  } + f
_{ k + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } + w _{ i + 1 , j  } &amp; \leq f
_{ i + 1 , k  } + f _{ k + 1 , j  } + w _{ i + 1 , j  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>因此对于$f <em>{ i + 1 , j } <span class="math inline">\(,\)</span>p
<span class="math inline">\(比任意的\)</span>k &lt; p <span class="math inline">\(更优,因此\)</span>p </em>{ i + 1 , j } p _{ i , j
} $,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4>
<p>判断一个函数的凸性只需判断$f ( k ) + f ( k + 2 ) f ( k + 1 ) <span class="math inline">\(,而这只需证明\)</span>k <span class="math inline">\(的时候的答案和\)</span>k + 2 <span class="math inline">\(时的答案可以调整出两个\)</span>k + 1 <span class="math inline">\(的答案(不一定是最小答案)并且这两个\)</span>k + 1
<span class="math inline">\(的答案的和小于等于\)</span>k <span class="math inline">\(时和\)</span>k + 2 $时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5>
<p>首先考虑四个点$( a , b , c , d ) <span class="math inline">\(,注意到其一定满足四边形不等式,也就是\)</span>w
<em>{ ac } + w </em>{ bd } w <em>{ ad } + w </em>{ bc } $.</p>
<p>我们现在想证明,设$f <em>k <span class="math inline">\(为新增\)</span>k <span class="math inline">\(个传送机后的减少的答案,我们考虑证明\)</span>f
<em>k + f </em>{ k + 2 } f </em>{ k + 1 } $.</p>
<p>我们画出$f <em>k <span class="math inline">\(时选的点和\)</span>f
</em>{ k + 2 } <span class="math inline">\(时选的点,注意到我们可以用这两次调整出两个\)</span>k
+ 1 <span class="math inline">\(的答案,并且这两个答案的和小于等于\)</span>f <em>k
+ f </em>{ k + 2 } <span class="math inline">\(,于是证明了最小的\)</span>f _{ k + 1 }
$是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量$w <span class="math inline">\(,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于\)</span>w
$的最大的传送机数量,然后就可以做了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">人工智能基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="常用激活函数">常用激活函数</span></h3>
<h4><span id="sigmoid函数">Sigmoid函数</span></h4>
<p>$f ( x ) = { 1 + e ^{ - x } } : ( - , + ) ( 0 , 1 ) $.</p>
<p>$f ’ ( x ) = f ( x ) ( 1 - f ( x ) ) $.</p>
<h4><span id="tanh函数">tanh函数</span></h4>
<p>$f ( x ) = { e ^x + e ^{ - x } } : ( - , + ) ( - 1 , 1 ) $.</p>
<p>$f ’ ( x ) = 1 - f ^2 ( x ) $.</p>
<h4><span id="relu函数">ReLU函数</span></h4>
<p>$f ( x ) = ( 0 , x ) : ( - , + ) ( 0 , + ) $.</p>
<h4><span id="leaky-relu函数">Leaky ReLU函数</span></h4>
<p>$f ( x ) = ( x , x ) , 0 &lt; &lt; 1 : ( - , + ) ( - , + ) $.</p>
<h4><span id="softmax函数">Softmax函数</span></h4>
<p>$f ( x _i ) = { _j e ^{ x _j } } $.</p>
<h3><span id="损失函数">损失函数</span></h3>
<h4><span id="least-square">Least Square</span></h4>
<p>即$_{ i = 1 } ^n ( f ( x _i ) - y _i ) ^2 = ( A - Y A - Y ) <span class="math inline">\(.用最小二乘法取\)</span>= ( A ^T A ) ^{ - 1 } A ^T
Y $.</p>
<h4><span id="cross-entropy">Cross Entropy</span></h4>
<p>用错误的分布$q <span class="math inline">\(来表示真实分布\)</span>p
$的样本,则平均编码长度应该是:</p>
<p><span class="math display">\[
H ( p , q ) = \sum _i p ( i ) \log ( \frac { 1  } { q ( i )  } ) = -
\sum _i p ( i ) \log { q ( i )  }
\]</span></p>
<p>此为交叉熵.</p>
<p>特别地,当最终样本只有两个的时候,例如Logistical
Regression问题,可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
H &amp; = - ( y \log a + ( 1 - y ) \log ( 1 - a ) ) \\
\frac { \partial H  } { \partial a  } &amp; = - ( \frac { y  } { a  } -
\frac { 1 - y  } { 1 - a  } )
\end{aligned}
\]</span></p>
<p>那如果有多个呢?考虑直接对归一化条件作偏导,先有:</p>
<p><span class="math display">\[
\begin{aligned}
H ( p , q ) &amp; = - \sum _i p _i ( \log { q _i  } - \log ( \sum _j q
_j ) ) \\
\frac { \partial H ( p , q )  } { \partial q _k  } &amp; = - \frac { p
_k  } { q _k  } + \frac { \sum p _k  } { \sum _j q _j  } \\
&amp; = - \frac { p _k  } { q _k  } + 1
\end{aligned}
\]</span></p>
<p>再乘以softmax那里的$q _k <span class="math inline">\(,得到\)</span>-
p _k + q _k = - y _k + f ( x _k ) $.</p>
<h3><span id="神经网络实现">神经网络实现</span></h3>
<p>通过若干隐藏层,假设最后的输出层为第$L $层,则:</p>
<ol type="1">
<li><p>对于第$l <span class="math inline">\(层,取\)</span> _l = ( W
<em>l ) ^t </em>{ l - 1 } + _l <span class="math inline">\(.这里对\)</span>W _l
$作转置的目的是写代码的时候需要用行向量.</p></li>
<li><p>对于第$l <span class="math inline">\(层,取\)</span> _l = f ( _l )
<span class="math inline">\(,这里意味着将每一个分量对\)</span>f
$操作.</p></li>
<li><p>对于最终答案,取误差$ = { m } ( - _L - _L ) $.</p></li>
</ol>
<h4><span id="梯度下降法">梯度下降法</span></h4>
<p>换言之就是让$w : = w - { w } <span class="math inline">\(,其中\)</span><span class="math inline">\(是一个选定的小常数,也可以采用类似模拟退火的方式动态决定.事实上可以把各个位置分开,写作\)</span>w
_j : = w _j - { w _j } $.</p>
<p>另外,虽然是这么写,应当见到去掉下标$k <span class="math inline">\(的记号仍然合理,无非是逐分量做此操作,因此下面如无特殊说明,运算均采用逐分量运算.例如可以定义\)</span>
<span class="math inline">\(为两个向量逐分量相乘后得到的新向量,为表区分用\)</span><span class="math inline">\(表示正常的矩阵乘法.甚至采取\)</span>( - ) ^2 <span class="math inline">\(表示其自点积.坦白而言,笔者对此符号相当无奈,可也想不出什么更好的写法了.但总之这种写法总是强于部分参考资料上所将下标放上面的写作\)</span>a
^L
$的做法.笔者所能维持的精神数院人的唯一做法也只能是在下面加上向量符号,藉此泄愤.</p>
<p>顺便一提,应当见到$<span class="math inline">\(和\)</span><span class="math inline">\(这两种运算比较随意,用线性映射来理解,你这个\)</span>W
$任意作用在一个向量上就行.</p>
<h4><span id="误差反向传播">误差反向传播</span></h4>
<p>既然要用梯度下降法,就应该把每一层的偏导都求出来.然而$
$是最后一层的结果,因此应该用链式法则一路求出前面的偏导.</p>
<p>更具体地,不妨设误差函数选的是$( - ) ^2 $,激活函数选的是cross
entropy有:</p>
<ol type="1">
<li><p>$ { <em>{ L } } = ( </em>{ L } - )
$.(如若选择不同的误差函数,这里作适当变化)</p></li>
<li><p>$ { <em>{ l } } = f ’ ( </em>{ l } ) = <em>{ l } ( 1 - </em>{ l }
) $.(如若选取不同的激活函数,这里作适当变化)</p></li>
<li><p>$ { <em>{ l } } = { </em>{ l } } { <em>{ l } } = ( W </em>{ l + 1
} ) ^t ( _l ( 1 - _l ) ) $.</p></li>
<li><p>$ { W <em>{ l } } = ( </em>{ l - 1 } ) <span class="math inline">\(.结果理应是一个矩阵,其实就是这个列向量不断复制若干遍,或者写成\)</span>(
_{ l - 1 } ) ^t M ( 1 ) <span class="math inline">\(,其中\)</span>M ( 1
) $是全$1 $矩阵.</p></li>
<li><p>$ { _{ l } } = 1 $.</p></li>
</ol>
<p>我们应当见到:</p>
<p>不妨设$_l = { _l } $.见到:</p>
<ol type="1">
<li><p>$_L = { <em>L } = { <em>L } { <em>L } = ( </em>{ L } - ) </em>{ L
} ( 1 - </em>{ L } )
$.前者会因为误差函数的选取而改变,后者会因为激活函数的选取而改变.</p></li>
<li><p>$<em>l = { <em>l } = </em>{ l + 1 } { <em>l } = </em>{ l + 1 } (
W </em>{ l + 1 } ) ^t ( <em>{ l } ( 1 - </em>{ l } ) ) $.</p></li>
<li><p>$ { W <em>{ l } } = { </em>{ l } } { W _{ l } } = <em>l a </em>{
l - 1 } ^t $.</p></li>
<li><p>$ { _l } = _l $.</p></li>
</ol>
<p>如此以上更新即可.</p>
<h3><span id="卷积神经网络cnn">卷积神经网络(CNN)</span></h3>
<p>神经网络受矩阵乘法的限制,导致对于真实的尺寸巨大的图像难以快速识别,因此产生了卷积神经网络的概念,大概有以下特征:</p>
<ol type="1">
<li><p>空间上权值共享:不同位置使用同一个卷积核(滤波器)</p></li>
<li><p>稀疏链接:每一层只链接前一层的感受野.</p></li>
<li><p>等变表示:卷积神经网络有某种平移不变性.</p></li>
</ol>
<p>对于2D卷积,其公式如下:</p>
<p><span class="math display">\[
S _{ r , c  } = ( X * W ) _{ r , c  } = \sum _i \sum _j X _{ r + i , c +
j  } \times w _{ i , j  }
\]</span></p>
<p>其中$W <span class="math inline">\(是卷积核,\)</span>X <span class="math inline">\(是输入图像,\)</span>S
$是输出的结果.如果一个图像有多个通道(比如色彩层之类的),每个通道上都需要应用一个卷积核.</p>
<p>下面引入一些名词:</p>
<ol type="1">
<li><p>input size:输入图像的尺寸.</p></li>
<li><p>padding:填充的像素数.</p></li>
<li><p>filter size:卷积核的尺寸.有时也写作两个变量:filter height和filter
width.3D卷积还会有一个filter depth的变量.</p></li>
<li><p>stride:步长.</p></li>
<li><p>output size:卷积后输出的尺寸.有时也写作feature size.</p></li>
<li><p>input channels:输入图像的通道数.</p></li>
<li><p>n filters:卷积核的数量.</p></li>
<li><p>dilation rate:膨胀率,用于空洞卷积.膨胀率为$d <span class="math inline">\(的时候,卷积核中间会插入\)</span>d - 1 $个$0
$间隔.</p></li>
</ol>
<h4><span id="感受野计算">感受野计算</span></h4>
<p>先看output
size的计算,容易见到,其各个维度方面计算是独立的.只要对于单个维度算出卷积核在上面移动的次数,最后将不同维度相乘即可.</p>
<p>对于单个维度,这个维度的移动次数应该是:</p>
$$
<span class="math display">\[\begin{aligned}
\text { output \_ size  } &amp; = \lceil \frac { \text { input \_
size  } + 2 \times \text { padding  } - \text { filter \_ size  } + 1  }
{ \text { stride  }  } \rceil \\
&amp; = \lfloor \frac { \text { input \_ size  } + 2 \times \text {
padding  } - \text { filter \_ size  }  } { \text { stride  }  } \rfloor
+ 1 \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式相当容易理解,原因是$ = 1 <span class="math inline">\(的时候,上面恰好是移动的次数,而\)</span>
$变化的时候,当然要拿到一个上取整.</p>
<p>至于所谓的空洞卷积,只需在上面的基础上改$ $就好.</p>
<p>至于乘法操作,每得到一个$ <span class="math inline">\(当然都会需要\)</span> $次乘法操作.</p>
<p>再看感受野的计算,不妨设$S <em>i <span class="math inline">\(为前\)</span>i <span class="math inline">\(次卷积的\)</span> <span class="math inline">\(的乘积,设\)</span>k </em>{ i + 1 } <span class="math inline">\(表示第\)</span>i + 1 <span class="math inline">\(层的\)</span> $,则:</p>
<p><span class="math display">\[
RF _{ i + 1  } = RF _i + ( k _{ i + 1  } - 1 ) \times S _i
\]</span></p>
<p>这个公式的含义大概是每次先看对应了多大的原数据上的范围,再把原本的边界$RF
_i $给补上.</p>
<h4><span id="池化pooling">池化(Pooling)</span></h4>
<p>池化操作它没有一个可学习的参数,只是对输入数据进行固定的操作.简单来说就是降低输入的规模,以实现更好的鲁棒性以及提高效率.</p>
<p>常见的池化操作包括:</p>
<ol type="1">
<li><p>MaxPooling:取区域内的最大值.</p></li>
<li><p>MeanPooling:取区域内的平均值.</p></li>
<li><p>PyramidPooling:多次进行尺度不同的池化.</p></li>
</ol>
<h4><span id="常见卷积架构">常见卷积架构</span></h4>
<h5><span id="alexnet">AlexNet</span></h5>
<p>首次引入ReLU激活函数,Dropout
技术,以及数据增强,提高了模型的训练效率和泛化能力.</p>
<p>采用了$8 $层深的网络结构,证明了深度网络的潜力.</p>
<h5><span id="vgg">VGG</span></h5>
<p>开始堆叠小尺寸的卷积核,获得与大卷积核相似的感受野的同时可以增加网络深度.</p>
<h5><span id="resnet">ResNet</span></h5>
<p>引入残差的概念,直接将输入数据累加(跳跃连接)到最后的输出中,这样网络学习的实际上是输入和输出之间的残差,从而提高了网络学习能力.</p>
<h5><span id="squeezenet">SqueezeNet</span></h5>
<p>SqueezeNet的基本构建单元是Fire模块.Fire模块由一个squeeze层和一个expand层组成.squeeze层使用$1
$卷积核减少通道数,而expand层则使用$1 $和$3
$卷积核增加通道数.这种设计有效地减少了参数数量和计算量.</p>
<h5><span id="mobilenet">MobileNet</span></h5>
<ol type="1">
<li><p>深度卷积:在这个操作中,每个输入通道独立地进行卷积,这意味着在进行卷积时,不同通道之间没有交互.这样可以减少计算量和参数数量.</p></li>
<li><p>逐点卷积:逐点卷积使用$1
$的卷积核,它作用在深度卷积的输出上,将不同通道的信息整合在一起.逐点卷积可以减少参数数量,同时保持较高的性能.</p></li>
</ol>
<h5><span id="shufflenet">ShuffleNet</span></h5>
<ol type="1">
<li><p>组卷积(Group
Convolution):将通道分成几个组,并使用不同的卷积神经网络层执行标准卷积.</p></li>
<li><p>打乱层(Shuffle
layer):通过对通道进行洗牌,将不同组的信息合并.</p></li>
</ol>
<h5><span id="反卷积">反卷积</span></h5>
<p>也就是将较小的数据特征图扩大到较大的尺寸.有的时候也把这个操作说成上采样.</p>
<ol type="1">
<li><p>插值步骤(Interpolation
Step):首先,在输入特征图的元素之间插入零,增加特征图的尺寸.</p></li>
<li><p>卷积步骤(Convolution
Step):接下来,对扩大后的特征图应用一个标准的卷积操作.此步骤相当于在扩大的特征图上滑动卷积核,计算卷积输出.</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/5/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
